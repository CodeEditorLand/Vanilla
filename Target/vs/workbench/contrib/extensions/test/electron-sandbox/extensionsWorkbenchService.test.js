import*as D from"sinon";import n from"assert";import{generateUuid as z}from"../../../../../base/common/uuid.js";import{ExtensionState as v,AutoCheckUpdatesConfigurationKey as H,AutoUpdateConfigurationKey as J}from"../../common/extensions.js";import{ExtensionsWorkbenchService as Q}from"../../browser/extensionsWorkbenchService.js";import{IExtensionManagementService as b,IExtensionGalleryService as w,InstallOperation as N,IExtensionTipsService as X,getTargetPlatform as W}from"../../../../../platform/extensionManagement/common/extensionManagement.js";import{IWorkbenchExtensionEnablementService as c,EnablementState as o,IExtensionManagementServerService as x,IWorkbenchExtensionManagementService as Y}from"../../../../services/extensionManagement/common/extensionManagement.js";import{IExtensionRecommendationsService as Z}from"../../../../services/extensionRecommendations/common/extensionRecommendations.js";import{getGalleryExtensionId as O}from"../../../../../platform/extensionManagement/common/extensionManagementUtil.js";import{anExtensionManagementServerService as V,TestExtensionEnablementService as y}from"../../../../services/extensionManagement/test/browser/extensionEnablementService.test.js";import{ExtensionGalleryService as _}from"../../../../../platform/extensionManagement/common/extensionGalleryService.js";import{IURLService as ee}from"../../../../../platform/url/common/url.js";import{TestInstantiationService as te}from"../../../../../platform/instantiation/test/common/instantiationServiceMock.js";import{Event as q,Emitter as L}from"../../../../../base/common/event.js";import"../../../../../base/common/paging.js";import{ITelemetryService as ne}from"../../../../../platform/telemetry/common/telemetry.js";import{NullTelemetryService as ae}from"../../../../../platform/telemetry/common/telemetryUtils.js";import{IWorkspaceContextService as le}from"../../../../../platform/workspace/common/workspace.js";import{TestExtensionTipsService as se,TestSharedProcessService as ie}from"../../../../test/electron-sandbox/workbenchTestServices.js";import{ConfigurationTarget as oe,IConfigurationService as re}from"../../../../../platform/configuration/common/configuration.js";import{ILogService as ce,NullLogService as $}from"../../../../../platform/log/common/log.js";import{IProgressService as ue}from"../../../../../platform/progress/common/progress.js";import{ProgressService as de}from"../../../../services/progress/browser/progressService.js";import{INotificationService as K}from"../../../../../platform/notification/common/notification.js";import{NativeURLService as be}from"../../../../../platform/url/common/urlService.js";import{URI as m}from"../../../../../base/common/uri.js";import{CancellationToken as T}from"../../../../../base/common/cancellation.js";import{ExtensionType as h}from"../../../../../platform/extensions/common/extensions.js";import"../../../../../platform/environment/common/environment.js";import{IRemoteAgentService as pe}from"../../../../services/remote/common/remoteAgentService.js";import{RemoteAgentService as Ee}from"../../../../services/remote/electron-sandbox/remoteAgentService.js";import{ISharedProcessService as me}from"../../../../../platform/ipc/electron-sandbox/services.js";import{TestContextService as xe}from"../../../../test/common/workbenchTestServices.js";import{IProductService as ye}from"../../../../../platform/product/common/productService.js";import{ILifecycleService as ge}from"../../../../services/lifecycle/common/lifecycle.js";import{TestLifecycleService as fe}from"../../../../test/browser/workbenchTestServices.js";import{Schemas as I}from"../../../../../base/common/network.js";import{IContextKeyService as he}from"../../../../../platform/contextkey/common/contextkey.js";import{MockContextKeyService as we}from"../../../../../platform/keybinding/test/common/mockKeybindingService.js";import{platform as R}from"../../../../../base/common/platform.js";import{arch as F}from"../../../../../base/common/process.js";import{IExtensionService as qe}from"../../../../services/extensions/common/extensions.js";import{toDisposable as ve}from"../../../../../base/common/lifecycle.js";import{ensureNoDisposablesAreLeakedInTestSuite as Se}from"../../../../../base/test/common/utils.js";import"../../../../../base/common/types.js";import{IUpdateService as De,State as Ie}from"../../../../../platform/update/common/update.js";import{IFileService as Ge}from"../../../../../platform/files/common/files.js";import{FileService as Pe}from"../../../../../platform/files/common/fileService.js";import{UserDataProfileService as ke}from"../../../../services/userDataProfile/common/userDataProfileService.js";import{IUserDataProfileService as Ue}from"../../../../services/userDataProfile/common/userDataProfile.js";import{toUserDataProfile as Me}from"../../../../../platform/userDataProfile/common/userDataProfile.js";import{IDialogService as B}from"../../../../../platform/dialogs/common/dialogs.js";suite("ExtensionsWorkbenchServiceTest",()=>{let t,e;const E=Se();let M,P,k,C;setup(async()=>{E.add(ve(()=>D.restore())),M=E.add(new L),P=E.add(new L),k=E.add(new L),C=E.add(new L),t=E.add(new te),t.stub(ne,ae),t.stub(ce,$),t.stub(Ge,E.add(new Pe(new $))),t.stub(ue,de),t.stub(ye,{}),t.stub(w,_),t.stub(ee,be),t.stub(me,ie),t.stub(he,new we),t.stub(le,new xe),A(),t.stub(pe,Ee),t.stub(Ue,E.add(new ke(Me("test","test",m.file("foo"),m.file("cache"))))),t.stub(Y,{onDidInstallExtensions:P.event,onInstallExtension:M.event,onUninstallExtension:k.event,onDidUninstallExtension:C.event,onDidUpdateExtensionMetadata:q.None,onDidChangeProfile:q.None,async getInstalled(){return[]},async getInstalledWorkspaceExtensions(){return[]},async getExtensionsControlManifest(){return{malicious:[],deprecated:{},search:[]}},async updateMetadata(a,l){return a.identifier.uuid=l.id,a.publisherDisplayName=l.publisherDisplayName,a.publisherId=l.publisherId,a},async canInstall(){return!0},getTargetPlatform:async()=>W(R,F),async resetPinnedStateForAllUserExtensions(a){}}),t.stub(x,V({id:"local",label:"local",extensionManagementService:t.get(b)},null,null)),t.stub(c,E.add(new y(t))),t.stub(ge,E.add(new fe)),t.stub(X,E.add(t.createInstance(se))),t.stub(Z,{}),t.stub(K,{prompt:()=>null}),t.stub(qe,{onDidChangeExtensions:q.None,extensions:[],async whenInstalledExtensionsRegistered(){return!0}}),t.stubPromise(b,"getInstalled",[]),t.stub(w,"isEnabled",!0),t.stubPromise(w,"query",S()),t.stubPromise(w,"getExtensions",[]),t.stubPromise(K,"prompt",0),t.get(c).reset(),t.stub(De,{onStateChange:q.None,state:Ie.Uninitialized})}),test("test gallery extension",async()=>{const a=G("expectedName",{displayName:"expectedDisplayName",version:"1.5.0",publisherId:"expectedPublisherId",publisher:"expectedPublisher",publisherDisplayName:"expectedPublisherDisplayName",description:"expectedDescription",installCount:1e3,rating:4,ratingCount:100},{dependencies:["pub.1","pub.2"]},{manifest:{uri:"uri:manifest",fallbackUri:"fallback:manifest"},readme:{uri:"uri:readme",fallbackUri:"fallback:readme"},changelog:{uri:"uri:changelog",fallbackUri:"fallback:changlog"},download:{uri:"uri:download",fallbackUri:"fallback:download"},icon:{uri:"uri:icon",fallbackUri:"fallback:icon"},license:{uri:"uri:license",fallbackUri:"fallback:license"},repository:{uri:"uri:repository",fallbackUri:"fallback:repository"},signature:{uri:"uri:signature",fallbackUri:"fallback:signature"},coreTranslations:[]});return e=await d(),t.stubPromise(w,"query",S(a)),e.queryGallery(T.None).then(l=>{n.strictEqual(1,l.firstPage.length);const s=l.firstPage[0];n.strictEqual(h.User,s.type),n.strictEqual("expectedName",s.name),n.strictEqual("expectedDisplayName",s.displayName),n.strictEqual("expectedpublisher.expectedname",s.identifier.id),n.strictEqual("expectedPublisher",s.publisher),n.strictEqual("expectedPublisherDisplayName",s.publisherDisplayName),n.strictEqual("1.5.0",s.version),n.strictEqual("1.5.0",s.latestVersion),n.strictEqual("expectedDescription",s.description),n.strictEqual("uri:icon",s.iconUrl),n.strictEqual("fallback:icon",s.iconUrlFallback),n.strictEqual("uri:license",s.licenseUrl),n.strictEqual(v.Uninstalled,s.state),n.strictEqual(1e3,s.installCount),n.strictEqual(4,s.rating),n.strictEqual(100,s.ratingCount),n.strictEqual(!1,s.outdated),n.deepStrictEqual(["pub.1","pub.2"],s.dependencies)})}),test("test for empty installed extensions",async()=>{e=await d(),n.deepStrictEqual([],e.local)}),test("test for installed extensions",async()=>{const a=i("local1",{publisher:"localPublisher1",version:"1.1.0",displayName:"localDisplayName1",description:"localDescription1",icon:"localIcon1",extensionDependencies:["pub.1","pub.2"]},{type:h.User,readmeUrl:"localReadmeUrl1",changelogUrl:"localChangelogUrl1",location:m.file("localPath1")}),l=i("local2",{publisher:"localPublisher2",version:"1.2.0",displayName:"localDisplayName2",description:"localDescription2"},{type:h.System,readmeUrl:"localReadmeUrl2",changelogUrl:"localChangelogUrl2"});t.stubPromise(b,"getInstalled",[a,l]),e=await d();const s=e.local;n.strictEqual(2,s.length);let r=s[0];n.strictEqual(h.User,r.type),n.strictEqual("local1",r.name),n.strictEqual("localDisplayName1",r.displayName),n.strictEqual("localpublisher1.local1",r.identifier.id),n.strictEqual("localPublisher1",r.publisher),n.strictEqual("1.1.0",r.version),n.strictEqual("1.1.0",r.latestVersion),n.strictEqual("localDescription1",r.description),n.ok(r.iconUrl==="file:///localPath1/localIcon1"||r.iconUrl==="vscode-file://vscode-app/localPath1/localIcon1"),n.ok(r.iconUrlFallback==="file:///localPath1/localIcon1"||r.iconUrlFallback==="vscode-file://vscode-app/localPath1/localIcon1"),n.strictEqual(void 0,r.licenseUrl),n.strictEqual(v.Installed,r.state),n.strictEqual(void 0,r.installCount),n.strictEqual(void 0,r.rating),n.strictEqual(void 0,r.ratingCount),n.strictEqual(!1,r.outdated),n.deepStrictEqual(["pub.1","pub.2"],r.dependencies),r=s[1],n.strictEqual(h.System,r.type),n.strictEqual("local2",r.name),n.strictEqual("localDisplayName2",r.displayName),n.strictEqual("localpublisher2.local2",r.identifier.id),n.strictEqual("localPublisher2",r.publisher),n.strictEqual("1.2.0",r.version),n.strictEqual("1.2.0",r.latestVersion),n.strictEqual("localDescription2",r.description),n.strictEqual(void 0,r.licenseUrl),n.strictEqual(v.Installed,r.state),n.strictEqual(void 0,r.installCount),n.strictEqual(void 0,r.rating),n.strictEqual(void 0,r.ratingCount),n.strictEqual(!1,r.outdated),n.deepStrictEqual([],r.dependencies)}),test("test installed extensions get syncs with gallery",async()=>{const a=i("local1",{publisher:"localPublisher1",version:"1.1.0",displayName:"localDisplayName1",description:"localDescription1",icon:"localIcon1",extensionDependencies:["pub.1","pub.2"]},{type:h.User,readmeUrl:"localReadmeUrl1",changelogUrl:"localChangelogUrl1",location:m.file("localPath1")}),l=i("local2",{publisher:"localPublisher2",version:"1.2.0",displayName:"localDisplayName2",description:"localDescription2"},{type:h.System,readmeUrl:"localReadmeUrl2",changelogUrl:"localChangelogUrl2"}),s=G(a.manifest.name,{identifier:a.identifier,displayName:"expectedDisplayName",version:"1.5.0",publisherId:"expectedPublisherId",publisher:a.manifest.publisher,publisherDisplayName:"expectedPublisherDisplayName",description:"expectedDescription",installCount:1e3,rating:4,ratingCount:100},{dependencies:["pub.1"]},{manifest:{uri:"uri:manifest",fallbackUri:"fallback:manifest"},readme:{uri:"uri:readme",fallbackUri:"fallback:readme"},changelog:{uri:"uri:changelog",fallbackUri:"fallback:changlog"},download:{uri:"uri:download",fallbackUri:"fallback:download"},icon:{uri:"uri:icon",fallbackUri:"fallback:icon"},license:{uri:"uri:license",fallbackUri:"fallback:license"},repository:{uri:"uri:repository",fallbackUri:"fallback:repository"},signature:{uri:"uri:signature",fallbackUri:"fallback:signature"},coreTranslations:[]});return t.stubPromise(b,"getInstalled",[a,l]),t.stubPromise(w,"query",S(s)),t.stubPromise(w,"getCompatibleExtension",s),t.stubPromise(w,"getExtensions",[s]),e=await d(),await e.queryLocal(),q.toPromise(e.onChange).then(()=>{const r=e.local;n.strictEqual(2,r.length);let u=r[0];n.strictEqual(h.User,u.type),n.strictEqual("local1",u.name),n.strictEqual("expectedDisplayName",u.displayName),n.strictEqual("localpublisher1.local1",u.identifier.id),n.strictEqual("localPublisher1",u.publisher),n.strictEqual("1.1.0",u.version),n.strictEqual("1.5.0",u.latestVersion),n.strictEqual("expectedDescription",u.description),n.strictEqual("uri:icon",u.iconUrl),n.strictEqual("fallback:icon",u.iconUrlFallback),n.strictEqual(v.Installed,u.state),n.strictEqual("uri:license",u.licenseUrl),n.strictEqual(1e3,u.installCount),n.strictEqual(4,u.rating),n.strictEqual(100,u.ratingCount),n.strictEqual(!0,u.outdated),n.deepStrictEqual(["pub.1"],u.dependencies),u=r[1],n.strictEqual(h.System,u.type),n.strictEqual("local2",u.name),n.strictEqual("localDisplayName2",u.displayName),n.strictEqual("localpublisher2.local2",u.identifier.id),n.strictEqual("localPublisher2",u.publisher),n.strictEqual("1.2.0",u.version),n.strictEqual("1.2.0",u.latestVersion),n.strictEqual("localDescription2",u.description),n.strictEqual(void 0,u.licenseUrl),n.strictEqual(v.Installed,u.state),n.strictEqual(void 0,u.installCount),n.strictEqual(void 0,u.rating),n.strictEqual(void 0,u.ratingCount),n.strictEqual(!1,u.outdated),n.deepStrictEqual([],u.dependencies)})}),test("test extension state computation",async()=>{const a=G("gallery1");return e=await d(),t.stubPromise(w,"query",S(a)),e.queryGallery(T.None).then(l=>{const s=l.firstPage[0];n.strictEqual(v.Uninstalled,s.state);const r=a.identifier;M.fire({identifier:r,source:a,profileLocation:null});const u=e.local;n.strictEqual(1,u.length);const f=u[0];n.strictEqual(`${a.publisher}.${a.name}`,f.identifier.id),n.strictEqual(v.Installing,f.state),P.fire([{identifier:r,source:a,operation:N.Install,local:i(a.name,a,{identifier:r}),profileLocation:null}]),n.strictEqual(v.Installed,f.state),n.strictEqual(1,e.local.length),e.uninstall(f),k.fire({identifier:r,profileLocation:null}),n.strictEqual(v.Uninstalling,f.state),C.fire({identifier:r,profileLocation:null}),n.strictEqual(v.Uninstalled,f.state),n.strictEqual(0,e.local.length)})}),test("test extension doesnot show outdated for system extensions",async()=>{const a=i("a",{version:"1.0.1"},{type:h.System});t.stubPromise(b,"getInstalled",[a]),t.stubPromise(w,"query",S(G(a.manifest.name,{identifier:a.identifier,version:"1.0.2"}))),e=await d(),await e.queryLocal(),n.ok(!e.local[0].outdated)}),test("test canInstall returns false for extensions with out gallery",async()=>{const a=i("a",{version:"1.0.1"},{type:h.System});t.stubPromise(b,"getInstalled",[a]),e=await d();const l=e.local[0];e.uninstall(l),k.fire({identifier:a.identifier,profileLocation:null}),C.fire({identifier:a.identifier,profileLocation:null}),n.ok(!await e.canInstall(l))}),test("test canInstall returns false for a system extension",async()=>{const a=i("a",{version:"1.0.1"},{type:h.System});t.stubPromise(b,"getInstalled",[a]),t.stubPromise(w,"query",S(G(a.manifest.name,{identifier:a.identifier}))),e=await d();const l=e.local[0];n.ok(!await e.canInstall(l))}),test("test canInstall returns true for extensions with gallery",async()=>{const a=i("a",{version:"1.0.1"},{type:h.User});t.stubPromise(b,"getInstalled",[a]);const l=G(a.manifest.name,{identifier:a.identifier});t.stubPromise(w,"query",S(l)),t.stubPromise(w,"getCompatibleExtension",l),t.stubPromise(w,"getExtensions",[l]),e=await d();const s=e.local[0];await q.toPromise(q.filter(e.onChange,r=>!!r?.gallery)),n.ok(await e.canInstall(s))}),test("test onchange event is triggered while installing",async()=>{const a=G("gallery1");e=await d(),t.stubPromise(w,"query",S(a));const s=(await e.queryGallery(T.None)).firstPage[0];n.strictEqual(v.Uninstalled,s.state),M.fire({identifier:a.identifier,source:a,profileLocation:null});const r=q.toPromise(e.onChange);P.fire([{identifier:a.identifier,source:a,operation:N.Install,local:i(a.name,a,a),profileLocation:null}]),await r}),test("test onchange event is triggered when installation is finished",async()=>{const a=G("gallery1");e=await d(),t.stubPromise(w,"query",S(a));const l=D.spy();return e.queryGallery(T.None).then(s=>{const r=s.firstPage[0];n.strictEqual(v.Uninstalled,r.state),E.add(e.onChange(l)),M.fire({identifier:a.identifier,source:a,profileLocation:null}),n.ok(l.calledOnce)})}),test("test onchange event is triggered while uninstalling",async()=>{const a=i("a",{},{type:h.System});t.stubPromise(b,"getInstalled",[a]),e=await d();const l=D.spy();e.uninstall(e.local[0]),E.add(e.onChange(l)),k.fire({identifier:a.identifier,profileLocation:null}),n.ok(l.calledOnce)}),test("test onchange event is triggered when uninstalling is finished",async()=>{const a=i("a",{},{type:h.System});t.stubPromise(b,"getInstalled",[a]),e=await d();const l=D.spy();e.uninstall(e.local[0]),k.fire({identifier:a.identifier,profileLocation:null}),E.add(e.onChange(l)),C.fire({identifier:a.identifier,profileLocation:null}),n.ok(l.calledOnce)}),test("test uninstalled extensions are always enabled",async()=>t.get(c).setEnablement([i("b")],o.DisabledGlobally).then(()=>t.get(c).setEnablement([i("c")],o.DisabledWorkspace)).then(async()=>(e=await d(),t.stubPromise(w,"query",S(G("a"))),e.queryGallery(T.None).then(a=>{const l=a.firstPage[0];n.strictEqual(l.enablementState,o.EnabledGlobally)})))),test("test enablement state installed enabled extension",async()=>t.get(c).setEnablement([i("b")],o.DisabledGlobally).then(()=>t.get(c).setEnablement([i("c")],o.DisabledWorkspace)).then(async()=>{t.stubPromise(b,"getInstalled",[i("a")]),e=await d();const a=e.local[0];n.strictEqual(a.enablementState,o.EnabledGlobally)})),test("test workspace disabled extension",async()=>{const a=i("a");return t.get(c).setEnablement([i("b")],o.DisabledGlobally).then(()=>t.get(c).setEnablement([i("d")],o.DisabledGlobally)).then(()=>t.get(c).setEnablement([a],o.DisabledWorkspace)).then(()=>t.get(c).setEnablement([i("e")],o.DisabledWorkspace)).then(async()=>{t.stubPromise(b,"getInstalled",[a]),e=await d();const l=e.local[0];n.strictEqual(l.enablementState,o.DisabledWorkspace)})}),test("test globally disabled extension",async()=>{const a=i("a");return t.get(c).setEnablement([a],o.DisabledGlobally).then(()=>t.get(c).setEnablement([i("d")],o.DisabledGlobally)).then(()=>t.get(c).setEnablement([i("c")],o.DisabledWorkspace)).then(async()=>{t.stubPromise(b,"getInstalled",[a]),e=await d();const l=e.local[0];n.strictEqual(l.enablementState,o.DisabledGlobally)})}),test("test enablement state is updated for user extensions",async()=>t.get(c).setEnablement([i("c")],o.DisabledGlobally).then(()=>t.get(c).setEnablement([i("b")],o.DisabledWorkspace)).then(async()=>(t.stubPromise(b,"getInstalled",[i("a")]),e=await d(),e.setEnablement(e.local[0],o.DisabledWorkspace).then(()=>{const a=e.local[0];n.strictEqual(a.enablementState,o.DisabledWorkspace)})))),test("test enable extension globally when extension is disabled for workspace",async()=>{const a=i("a");return t.get(c).setEnablement([a],o.DisabledWorkspace).then(async()=>(t.stubPromise(b,"getInstalled",[a]),e=await d(),e.setEnablement(e.local[0],o.EnabledGlobally).then(()=>{const l=e.local[0];n.strictEqual(l.enablementState,o.EnabledGlobally)})))}),test("test disable extension globally",async()=>(t.stubPromise(b,"getInstalled",[i("a")]),e=await d(),e.setEnablement(e.local[0],o.DisabledGlobally).then(()=>{const a=e.local[0];n.strictEqual(a.enablementState,o.DisabledGlobally)}))),test("test system extensions can be disabled",async()=>(t.stubPromise(b,"getInstalled",[i("a",{},{type:h.System})]),e=await d(),e.setEnablement(e.local[0],o.DisabledGlobally).then(()=>{const a=e.local[0];n.strictEqual(a.enablementState,o.DisabledGlobally)}))),test("test enablement state is updated on change from outside",async()=>{const a=i("a");return t.get(c).setEnablement([i("c")],o.DisabledGlobally).then(()=>t.get(c).setEnablement([i("b")],o.DisabledWorkspace)).then(async()=>(t.stubPromise(b,"getInstalled",[a]),e=await d(),t.get(c).setEnablement([a],o.DisabledGlobally).then(()=>{const l=e.local[0];n.strictEqual(l.enablementState,o.DisabledGlobally)})))}),test("test disable extension with dependencies disable only itself",async()=>{const a=i("a",{extensionDependencies:["pub.b"]}),l=i("b"),s=i("c");return t.get(c).setEnablement([a],o.EnabledGlobally).then(()=>t.get(c).setEnablement([l],o.EnabledGlobally)).then(()=>t.get(c).setEnablement([s],o.EnabledGlobally)).then(async()=>(t.stubPromise(b,"getInstalled",[a,l,s]),e=await d(),e.setEnablement(e.local[0],o.DisabledGlobally).then(()=>{n.strictEqual(e.local[0].enablementState,o.DisabledGlobally),n.strictEqual(e.local[1].enablementState,o.EnabledGlobally)})))}),test("test disable extension pack disables the pack",async()=>{const a=i("a",{extensionPack:["pub.b"]}),l=i("b"),s=i("c");return t.get(c).setEnablement([a],o.EnabledGlobally).then(()=>t.get(c).setEnablement([l],o.EnabledGlobally)).then(()=>t.get(c).setEnablement([s],o.EnabledGlobally)).then(async()=>(t.stubPromise(b,"getInstalled",[a,l,s]),e=await d(),e.setEnablement(e.local[0],o.DisabledGlobally).then(()=>{n.strictEqual(e.local[0].enablementState,o.DisabledGlobally),n.strictEqual(e.local[1].enablementState,o.DisabledGlobally)})))}),test("test disable extension pack disable all",async()=>{const a=i("a",{extensionPack:["pub.b"]}),l=i("b"),s=i("c");return t.get(c).setEnablement([a],o.EnabledGlobally).then(()=>t.get(c).setEnablement([l],o.EnabledGlobally)).then(()=>t.get(c).setEnablement([s],o.EnabledGlobally)).then(async()=>(t.stubPromise(b,"getInstalled",[a,l,s]),e=await d(),e.setEnablement(e.local[0],o.DisabledGlobally).then(()=>{n.strictEqual(e.local[0].enablementState,o.DisabledGlobally),n.strictEqual(e.local[1].enablementState,o.DisabledGlobally)})))}),test("test disable extension fails if extension is a dependent of other",async()=>{const a=i("a",{extensionDependencies:["pub.b"]}),l=i("b"),s=i("c");return t.stub(K,{prompt(r,u,f,U){return U.onCancel(),null}}),t.get(c).setEnablement([a],o.EnabledGlobally).then(()=>t.get(c).setEnablement([l],o.EnabledGlobally)).then(()=>t.get(c).setEnablement([s],o.EnabledGlobally)).then(async()=>(t.stubPromise(b,"getInstalled",[a,l,s]),e=await d(),e.setEnablement(e.local[1],o.DisabledGlobally).then(()=>n.fail("Should fail"),r=>n.ok(!0))))}),test("test disable extension disables all dependents when chosen to disable all",async()=>{const a=i("a",{extensionDependencies:["pub.b"]}),l=i("b"),s=i("c");return t.stub(B,{prompt(){return Promise.resolve({result:!0})}}),t.get(c).setEnablement([a],o.EnabledGlobally).then(()=>t.get(c).setEnablement([l],o.EnabledGlobally)).then(()=>t.get(c).setEnablement([s],o.EnabledGlobally)).then(async()=>{t.stubPromise(b,"getInstalled",[a,l,s]),e=await d(),await e.setEnablement(e.local[1],o.DisabledGlobally),n.strictEqual(e.local[0].enablementState,o.DisabledGlobally),n.strictEqual(e.local[1].enablementState,o.DisabledGlobally)})}),test("test disable extension when extension is part of a pack",async()=>{const a=i("a",{extensionPack:["pub.b"]}),l=i("b"),s=i("c");return t.get(c).setEnablement([a],o.EnabledGlobally).then(()=>t.get(c).setEnablement([l],o.EnabledGlobally)).then(()=>t.get(c).setEnablement([s],o.EnabledGlobally)).then(async()=>(t.stubPromise(b,"getInstalled",[a,l,s]),e=await d(),e.setEnablement(e.local[1],o.DisabledGlobally).then(()=>{n.strictEqual(e.local[1].enablementState,o.DisabledGlobally)})))}),test("test disable both dependency and dependent do not promot and do not fail",async()=>{const a=i("a",{extensionDependencies:["pub.b"]}),l=i("b"),s=i("c");return t.get(c).setEnablement([a],o.EnabledGlobally).then(()=>t.get(c).setEnablement([l],o.EnabledGlobally)).then(()=>t.get(c).setEnablement([s],o.EnabledGlobally)).then(async()=>{t.stubPromise(b,"getInstalled",[a,l,s]);const r=D.spy();return e=await d(),e.setEnablement([e.local[1],e.local[0]],o.DisabledGlobally).then(()=>{n.ok(!r.called),n.strictEqual(e.local[0].enablementState,o.DisabledGlobally),n.strictEqual(e.local[1].enablementState,o.DisabledGlobally)})})}),test("test enable both dependency and dependent do not promot and do not fail",async()=>{const a=i("a",{extensionDependencies:["pub.b"]}),l=i("b"),s=i("c");return t.get(c).setEnablement([a],o.DisabledGlobally).then(()=>t.get(c).setEnablement([l],o.DisabledGlobally)).then(()=>t.get(c).setEnablement([s],o.DisabledGlobally)).then(async()=>{t.stubPromise(b,"getInstalled",[a,l,s]);const r=D.spy();return e=await d(),e.setEnablement([e.local[1],e.local[0]],o.EnabledGlobally).then(()=>{n.ok(!r.called),n.strictEqual(e.local[0].enablementState,o.EnabledGlobally),n.strictEqual(e.local[1].enablementState,o.EnabledGlobally)})})}),test("test disable extension does not fail if its dependency is a dependent of other but chosen to disable only itself",async()=>{const a=i("a",{extensionDependencies:["pub.b"]}),l=i("b"),s=i("c",{extensionDependencies:["pub.b"]});return t.get(c).setEnablement([a],o.EnabledGlobally).then(()=>t.get(c).setEnablement([l],o.EnabledGlobally)).then(()=>t.get(c).setEnablement([s],o.EnabledGlobally)).then(async()=>(t.stubPromise(b,"getInstalled",[a,l,s]),e=await d(),e.setEnablement(e.local[0],o.DisabledGlobally).then(()=>{n.strictEqual(e.local[0].enablementState,o.DisabledGlobally)})))}),test("test disable extension if its dependency is a dependent of other disabled extension",async()=>{const a=i("a",{extensionDependencies:["pub.b"]}),l=i("b"),s=i("c",{extensionDependencies:["pub.b"]});return t.get(c).setEnablement([a],o.EnabledGlobally).then(()=>t.get(c).setEnablement([l],o.EnabledGlobally)).then(()=>t.get(c).setEnablement([s],o.DisabledGlobally)).then(async()=>(t.stubPromise(b,"getInstalled",[a,l,s]),e=await d(),e.setEnablement(e.local[0],o.DisabledGlobally).then(()=>{n.strictEqual(e.local[0].enablementState,o.DisabledGlobally)})))}),test("test disable extension if its dependencys dependency is itself",async()=>{const a=i("a",{extensionDependencies:["pub.b"]}),l=i("b",{extensionDependencies:["pub.a"]}),s=i("c");return t.stub(K,{prompt(r,u,f,U){return U.onCancel(),null}}),t.get(c).setEnablement([a],o.EnabledGlobally).then(()=>t.get(c).setEnablement([l],o.EnabledGlobally)).then(()=>t.get(c).setEnablement([s],o.EnabledGlobally)).then(async()=>(t.stubPromise(b,"getInstalled",[a,l,s]),e=await d(),e.setEnablement(e.local[0],o.DisabledGlobally).then(()=>n.fail("An extension with dependent should not be disabled"),()=>null)))}),test("test disable extension if its dependency is dependent and is disabled",async()=>{const a=i("a",{extensionDependencies:["pub.b"]}),l=i("b"),s=i("c",{extensionDependencies:["pub.b"]});return t.get(c).setEnablement([a],o.EnabledGlobally).then(()=>t.get(c).setEnablement([l],o.DisabledGlobally)).then(()=>t.get(c).setEnablement([s],o.EnabledGlobally)).then(async()=>(t.stubPromise(b,"getInstalled",[a,l,s]),e=await d(),e.setEnablement(e.local[0],o.DisabledGlobally).then(()=>n.strictEqual(e.local[0].enablementState,o.DisabledGlobally))))}),test("test disable extension with cyclic dependencies",async()=>{const a=i("a",{extensionDependencies:["pub.b"]}),l=i("b",{extensionDependencies:["pub.c"]}),s=i("c",{extensionDependencies:["pub.a"]});return t.stub(K,{prompt(r,u,f,U){return U.onCancel(),null}}),t.get(c).setEnablement([a],o.EnabledGlobally).then(()=>t.get(c).setEnablement([l],o.EnabledGlobally)).then(()=>t.get(c).setEnablement([s],o.EnabledGlobally)).then(async()=>(t.stubPromise(b,"getInstalled",[a,l,s]),e=await d(),e.setEnablement(e.local[0],o.DisabledGlobally).then(()=>n.fail("An extension with dependent should not be disabled"),()=>null)))}),test("test enable extension with dependencies enable all",async()=>{const a=i("a",{extensionDependencies:["pub.b"]}),l=i("b"),s=i("c");return t.get(c).setEnablement([a],o.DisabledGlobally).then(()=>t.get(c).setEnablement([l],o.DisabledGlobally)).then(()=>t.get(c).setEnablement([s],o.DisabledGlobally)).then(async()=>(t.stubPromise(b,"getInstalled",[a,l,s]),e=await d(),e.setEnablement(e.local[0],o.EnabledGlobally).then(()=>{n.strictEqual(e.local[0].enablementState,o.EnabledGlobally),n.strictEqual(e.local[1].enablementState,o.EnabledGlobally)})))}),test("test enable extension with dependencies does not prompt if dependency is enabled already",async()=>{const a=i("a",{extensionDependencies:["pub.b"]}),l=i("b"),s=i("c");return t.get(c).setEnablement([a],o.DisabledGlobally).then(()=>t.get(c).setEnablement([l],o.EnabledGlobally)).then(()=>t.get(c).setEnablement([s],o.DisabledGlobally)).then(async()=>{t.stubPromise(b,"getInstalled",[a,l,s]);const r=D.spy();return e=await d(),e.setEnablement(e.local[0],o.EnabledGlobally).then(()=>{n.ok(!r.called),n.strictEqual(e.local[0].enablementState,o.EnabledGlobally)})})}),test("test enable extension with dependency does not prompt if both are enabled",async()=>{const a=i("a",{extensionDependencies:["pub.b"]}),l=i("b"),s=i("c");return t.get(c).setEnablement([a],o.DisabledGlobally).then(()=>t.get(c).setEnablement([l],o.DisabledGlobally)).then(()=>t.get(c).setEnablement([s],o.DisabledGlobally)).then(async()=>{t.stubPromise(b,"getInstalled",[a,l,s]);const r=D.spy();return e=await d(),e.setEnablement([e.local[1],e.local[0]],o.EnabledGlobally).then(()=>{n.ok(!r.called),n.strictEqual(e.local[0].enablementState,o.EnabledGlobally),n.strictEqual(e.local[1].enablementState,o.EnabledGlobally)})})}),test("test enable extension with cyclic dependencies",async()=>{const a=i("a",{extensionDependencies:["pub.b"]}),l=i("b",{extensionDependencies:["pub.c"]}),s=i("c",{extensionDependencies:["pub.a"]});return t.get(c).setEnablement([a],o.DisabledGlobally).then(()=>t.get(c).setEnablement([l],o.DisabledGlobally)).then(()=>t.get(c).setEnablement([s],o.DisabledGlobally)).then(async()=>(t.stubPromise(b,"getInstalled",[a,l,s]),e=await d(),e.setEnablement(e.local[0],o.EnabledGlobally).then(()=>{n.strictEqual(e.local[0].enablementState,o.EnabledGlobally),n.strictEqual(e.local[1].enablementState,o.EnabledGlobally),n.strictEqual(e.local[2].enablementState,o.EnabledGlobally)})))}),test("test change event is fired when disablement flags are changed",async()=>t.get(c).setEnablement([i("c")],o.DisabledGlobally).then(()=>t.get(c).setEnablement([i("b")],o.DisabledWorkspace)).then(async()=>{t.stubPromise(b,"getInstalled",[i("a")]),e=await d();const a=D.spy();return E.add(e.onChange(a)),e.setEnablement(e.local[0],o.DisabledGlobally).then(()=>n.ok(a.calledOnce))})),test("test change event is fired when disablement flags are changed from outside",async()=>{const a=i("a");return t.get(c).setEnablement([i("c")],o.DisabledGlobally).then(()=>t.get(c).setEnablement([i("b")],o.DisabledWorkspace)).then(async()=>{t.stubPromise(b,"getInstalled",[a]),e=await d();const l=D.spy();return E.add(e.onChange(l)),t.get(c).setEnablement([a],o.DisabledGlobally).then(()=>n.ok(l.calledOnce))})}),test("test updating an extension does not re-eanbles it when disabled globally",async()=>{e=await d();const a=i("pub.a");await t.get(c).setEnablement([a],o.DisabledGlobally),P.fire([{local:a,identifier:a.identifier,operation:N.Update,profileLocation:null}]),t.stubPromise(b,"getInstalled",[a]);const l=await e.queryLocal();n.strictEqual(l[0].enablementState,o.DisabledGlobally)}),test("test updating an extension does not re-eanbles it when workspace disabled",async()=>{e=await d();const a=i("pub.a");await t.get(c).setEnablement([a],o.DisabledWorkspace),P.fire([{local:a,identifier:a.identifier,operation:N.Update,profileLocation:null}]),t.stubPromise(b,"getInstalled",[a]);const l=await e.queryLocal();n.strictEqual(l[0].enablementState,o.DisabledWorkspace)}),test("test user extension is preferred when the same extension exists as system and user extension",async()=>{e=await d();const a=i("pub.a"),l=i("pub.a",{},{type:h.System});t.stubPromise(b,"getInstalled",[l,a]);const s=await e.queryLocal();n.strictEqual(s.length,1),n.strictEqual(s[0].local,a)}),test("test user extension is disabled when the same extension exists as system and user extension and system extension is disabled",async()=>{e=await d();const a=i("pub.a",{},{type:h.System});await t.get(c).setEnablement([a],o.DisabledGlobally);const l=i("pub.a");t.stubPromise(b,"getInstalled",[a,l]);const s=await e.queryLocal();n.strictEqual(s.length,1),n.strictEqual(s[0].local,l),n.strictEqual(s[0].enablementState,o.DisabledGlobally)}),test("Test local ui extension is chosen if it exists only in local server",async()=>{const l=i("a",{extensionKind:["ui"]},{location:m.file("pub.a")}),s=g(t,p([l]),p([]));t.stub(x,s),t.stub(c,E.add(new y(t))),e=await d();const r=await e.queryLocal();n.strictEqual(r.length,1),n.strictEqual(r[0].local,l)}),test("Test local workspace extension is chosen if it exists only in local server",async()=>{const l=i("a",{extensionKind:["workspace"]},{location:m.file("pub.a")}),s=g(t,p([l]),p([]));t.stub(x,s),t.stub(c,E.add(new y(t))),e=await d();const r=await e.queryLocal();n.strictEqual(r.length,1),n.strictEqual(r[0].local,l)}),test("Test local web extension is chosen if it exists only in local server",async()=>{const l=i("a",{extensionKind:["web"]},{location:m.file("pub.a")}),s=g(t,p([l]),p([]));t.stub(x,s),t.stub(c,E.add(new y(t))),e=await d();const r=await e.queryLocal();n.strictEqual(r.length,1),n.strictEqual(r[0].local,l)}),test("Test local ui,workspace extension is chosen if it exists only in local server",async()=>{const l=i("a",{extensionKind:["ui","workspace"]},{location:m.file("pub.a")}),s=g(t,p([l]),p([]));t.stub(x,s),t.stub(c,E.add(new y(t))),e=await d();const r=await e.queryLocal();n.strictEqual(r.length,1),n.strictEqual(r[0].local,l)}),test("Test local workspace,ui extension is chosen if it exists only in local server",async()=>{const l=i("a",{extensionKind:["workspace","ui"]},{location:m.file("pub.a")}),s=g(t,p([l]),p([]));t.stub(x,s),t.stub(c,E.add(new y(t))),e=await d();const r=await e.queryLocal();n.strictEqual(r.length,1),n.strictEqual(r[0].local,l)}),test("Test local ui,workspace,web extension is chosen if it exists only in local server",async()=>{const l=i("a",{extensionKind:["ui","workspace","web"]},{location:m.file("pub.a")}),s=g(t,p([l]),p([]));t.stub(x,s),t.stub(c,E.add(new y(t))),e=await d();const r=await e.queryLocal();n.strictEqual(r.length,1),n.strictEqual(r[0].local,l)}),test("Test local ui,web,workspace extension is chosen if it exists only in local server",async()=>{const l=i("a",{extensionKind:["ui","web","workspace"]},{location:m.file("pub.a")}),s=g(t,p([l]),p([]));t.stub(x,s),t.stub(c,E.add(new y(t))),e=await d();const r=await e.queryLocal();n.strictEqual(r.length,1),n.strictEqual(r[0].local,l)}),test("Test local web,ui,workspace extension is chosen if it exists only in local server",async()=>{const l=i("a",{extensionKind:["web","ui","workspace"]},{location:m.file("pub.a")}),s=g(t,p([l]),p([]));t.stub(x,s),t.stub(c,E.add(new y(t))),e=await d();const r=await e.queryLocal();n.strictEqual(r.length,1),n.strictEqual(r[0].local,l)}),test("Test local web,workspace,ui extension is chosen if it exists only in local server",async()=>{const l=i("a",{extensionKind:["web","workspace","ui"]},{location:m.file("pub.a")}),s=g(t,p([l]),p([]));t.stub(x,s),t.stub(c,E.add(new y(t))),e=await d();const r=await e.queryLocal();n.strictEqual(r.length,1),n.strictEqual(r[0].local,l)}),test("Test local workspace,web,ui extension is chosen if it exists only in local server",async()=>{const l=i("a",{extensionKind:["workspace","web","ui"]},{location:m.file("pub.a")}),s=g(t,p([l]),p([]));t.stub(x,s),t.stub(c,E.add(new y(t))),e=await d();const r=await e.queryLocal();n.strictEqual(r.length,1),n.strictEqual(r[0].local,l)}),test("Test local workspace,ui,web extension is chosen if it exists only in local server",async()=>{const l=i("a",{extensionKind:["workspace","ui","web"]},{location:m.file("pub.a")}),s=g(t,p([l]),p([]));t.stub(x,s),t.stub(c,E.add(new y(t))),e=await d();const r=await e.queryLocal();n.strictEqual(r.length,1),n.strictEqual(r[0].local,l)}),test("Test local UI extension is chosen if it exists in both servers",async()=>{const a=["ui"],l=i("a",{extensionKind:a},{location:m.file("pub.a")}),s=i("a",{extensionKind:a},{location:m.file("pub.a").with({scheme:I.vscodeRemote})}),r=g(t,p([l]),p([s]));t.stub(x,r),t.stub(c,E.add(new y(t))),e=await d();const u=await e.queryLocal();n.strictEqual(u.length,1),n.strictEqual(u[0].local,l)}),test("Test local ui,workspace extension is chosen if it exists in both servers",async()=>{const a=["ui","workspace"],l=i("a",{extensionKind:a},{location:m.file("pub.a")}),s=i("a",{extensionKind:a},{location:m.file("pub.a").with({scheme:I.vscodeRemote})}),r=g(t,p([l]),p([s]));t.stub(x,r),t.stub(c,E.add(new y(t))),e=await d();const u=await e.queryLocal();n.strictEqual(u.length,1),n.strictEqual(u[0].local,l)}),test("Test remote workspace extension is chosen if it exists in remote server",async()=>{const l=i("a",{extensionKind:["workspace"]},{location:m.file("pub.a").with({scheme:I.vscodeRemote})}),s=g(t,p(),p([l]));t.stub(x,s),t.stub(c,E.add(new y(t))),e=await d();const r=await e.queryLocal();n.strictEqual(r.length,1),n.strictEqual(r[0].local,l)}),test("Test remote workspace extension is chosen if it exists in both servers",async()=>{const a=["workspace"],l=i("a",{extensionKind:a},{location:m.file("pub.a")}),s=i("a",{extensionKind:a},{location:m.file("pub.a").with({scheme:I.vscodeRemote})}),r=g(t,p([l]),p([s]));t.stub(x,r),t.stub(c,E.add(new y(t))),e=await d();const u=await e.queryLocal();n.strictEqual(u.length,1),n.strictEqual(u[0].local,s)}),test("Test remote workspace extension is chosen if it exists in both servers and local is disabled",async()=>{const a=["workspace"],l=i("a",{extensionKind:a},{location:m.file("pub.a")}),s=i("a",{extensionKind:a},{location:m.file("pub.a").with({scheme:I.vscodeRemote})}),r=g(t,p([l]),p([s]));t.stub(x,r),t.stub(c,E.add(new y(t))),await t.get(c).setEnablement([s],o.DisabledGlobally),e=await d();const u=await e.queryLocal();n.strictEqual(u.length,1),n.strictEqual(u[0].local,s),n.strictEqual(u[0].enablementState,o.DisabledGlobally)}),test("Test remote workspace extension is chosen if it exists in both servers and remote is disabled in workspace",async()=>{const a=["workspace"],l=i("a",{extensionKind:a},{location:m.file("pub.a")}),s=i("a",{extensionKind:a},{location:m.file("pub.a").with({scheme:I.vscodeRemote})}),r=g(t,p([l]),p([s]));t.stub(x,r),t.stub(c,E.add(new y(t))),await t.get(c).setEnablement([s],o.DisabledWorkspace),e=await d();const u=await e.queryLocal();n.strictEqual(u.length,1),n.strictEqual(u[0].local,s),n.strictEqual(u[0].enablementState,o.DisabledWorkspace)}),test("Test local ui, workspace extension is chosen if it exists in both servers and local is disabled",async()=>{const a=["ui","workspace"],l=i("a",{extensionKind:a},{location:m.file("pub.a")}),s=i("a",{extensionKind:a},{location:m.file("pub.a").with({scheme:I.vscodeRemote})}),r=g(t,p([l]),p([s]));t.stub(x,r),t.stub(c,E.add(new y(t))),await t.get(c).setEnablement([l],o.DisabledGlobally),e=await d();const u=await e.queryLocal();n.strictEqual(u.length,1),n.strictEqual(u[0].local,l),n.strictEqual(u[0].enablementState,o.DisabledGlobally)}),test("Test local ui, workspace extension is chosen if it exists in both servers and local is disabled in workspace",async()=>{const a=["ui","workspace"],l=i("a",{extensionKind:a},{location:m.file("pub.a")}),s=i("a",{extensionKind:a},{location:m.file("pub.a").with({scheme:I.vscodeRemote})}),r=g(t,p([l]),p([s]));t.stub(x,r),t.stub(c,E.add(new y(t))),await t.get(c).setEnablement([l],o.DisabledWorkspace),e=await d();const u=await e.queryLocal();n.strictEqual(u.length,1),n.strictEqual(u[0].local,l),n.strictEqual(u[0].enablementState,o.DisabledWorkspace)}),test("Test local web extension is chosen if it exists in both servers",async()=>{const a=["web"],l=i("a",{extensionKind:a},{location:m.file("pub.a")}),s=i("a",{extensionKind:a},{location:m.file("pub.a").with({scheme:I.vscodeRemote})}),r=g(t,p([l]),p([s]));t.stub(x,r),t.stub(c,E.add(new y(t))),e=await d();const u=await e.queryLocal();n.strictEqual(u.length,1),n.strictEqual(u[0].local,l)}),test("Test remote web extension is chosen if it exists only in remote",async()=>{const l=i("a",{extensionKind:["web"]},{location:m.file("pub.a").with({scheme:I.vscodeRemote})}),s=g(t,p([]),p([l]));t.stub(x,s),t.stub(c,E.add(new y(t))),e=await d();const r=await e.queryLocal();n.strictEqual(r.length,1),n.strictEqual(r[0].local,l)}),test("Test disable autoupdate for extension when auto update is enabled for all",async()=>{const a=i("a"),l=i("b");t.stubPromise(b,"getInstalled",[a,l]),t.stub(b,"updateMetadata",(s,r)=>(s.pinned=!!r.pinned,s)),e=await d(),n.strictEqual(e.local[0].local?.pinned,void 0),n.strictEqual(e.local[1].local?.pinned,void 0),await e.updateAutoUpdateEnablementFor(e.local[0],!1),n.strictEqual(e.local[0].local?.pinned,void 0),n.strictEqual(e.local[1].local?.pinned,void 0),n.deepStrictEqual(e.getEnabledAutoUpdateExtensions(),[]),n.deepStrictEqual(e.getDisabledAutoUpdateExtensions(),["pub.a"])}),test("Test disable autoupdate for extension when auto update is enabled for enabled extensions",async()=>{A("onlyEnabledExtensions");const a=i("a"),l=i("b");t.stubPromise(b,"getInstalled",[a,l]),t.stub(b,"updateMetadata",(s,r)=>(s.pinned=!!r.pinned,s)),e=await d(),n.strictEqual(e.local[0].local?.pinned,void 0),n.strictEqual(e.local[1].local?.pinned,void 0),await e.updateAutoUpdateEnablementFor(e.local[0],!1),n.strictEqual(e.local[0].local?.pinned,void 0),n.strictEqual(e.local[1].local?.pinned,void 0),n.deepStrictEqual(e.getEnabledAutoUpdateExtensions(),[]),n.deepStrictEqual(e.getDisabledAutoUpdateExtensions(),["pub.a"])}),test("Test enable autoupdate for extension when auto update is enabled for all",async()=>{const a=i("a"),l=i("b");t.stubPromise(b,"getInstalled",[a,l]),t.stub(b,"updateMetadata",(s,r)=>(s.pinned=!!r.pinned,s)),e=await d(),n.strictEqual(e.local[0].local?.pinned,void 0),n.strictEqual(e.local[1].local?.pinned,void 0),await e.updateAutoUpdateEnablementFor(e.local[0],!1),await e.updateAutoUpdateEnablementFor(e.local[0],!0),n.strictEqual(e.local[0].local?.pinned,void 0),n.strictEqual(e.local[1].local?.pinned,void 0),n.deepStrictEqual(e.getEnabledAutoUpdateExtensions(),[]),n.deepStrictEqual(e.getDisabledAutoUpdateExtensions(),[])}),test("Test enable autoupdate for pinned extension when auto update is enabled",async()=>{const a=i("a",void 0,{pinned:!0}),l=i("b");t.stubPromise(b,"getInstalled",[a,l]),t.stub(b,"updateMetadata",(s,r)=>(s.pinned=!!r.pinned,s)),e=await d(),n.strictEqual(e.local[0].local?.pinned,!0),n.strictEqual(e.local[1].local?.pinned,void 0),await e.updateAutoUpdateEnablementFor(e.local[0],!0),n.strictEqual(e.local[0].local?.pinned,!1),n.strictEqual(e.local[1].local?.pinned,void 0),n.deepStrictEqual(e.getEnabledAutoUpdateExtensions(),[]),n.deepStrictEqual(e.getDisabledAutoUpdateExtensions(),[])}),test("Test updateAutoUpdateEnablementFor throws error when auto update is disabled",async()=>{A(!1);const a=i("a"),l=i("b");t.stubPromise(b,"getInstalled",[a,l]),e=await d();try{await e.updateAutoUpdateEnablementFor(e.local[0],!0),n.fail("error expected")}catch{}}),test("Test updateAutoUpdateEnablementFor throws error for publisher when auto update is enabled",async()=>{const a=i("a"),l=i("b");t.stubPromise(b,"getInstalled",[a,l]),e=await d();try{await e.updateAutoUpdateEnablementFor(e.local[0].publisher,!0),n.fail("error expected")}catch{}}),test("Test enable autoupdate for extension when auto update is disabled",async()=>{A(!1);const a=i("a",void 0,{pinned:!0}),l=i("b",void 0,{pinned:!0});t.stubPromise(b,"getInstalled",[a,l]),t.stub(b,"updateMetadata",(s,r)=>(s.pinned=!!r.pinned,s)),e=await d(),n.strictEqual(e.local[0].local?.pinned,!0),n.strictEqual(e.local[1].local?.pinned,!0),await e.updateAutoUpdateEnablementFor(e.local[0],!0),n.strictEqual(e.local[0].local?.pinned,!0),n.strictEqual(e.local[1].local?.pinned,!0),n.deepStrictEqual(e.getEnabledAutoUpdateExtensions(),["pub.a"]),n.deepStrictEqual(e.getDisabledAutoUpdateExtensions(),[])}),test("Test reset autoupdate extensions state when auto update is disabled",async()=>{t.stub(B,{confirm:()=>Promise.resolve({confirmed:!0})});const a=i("a",void 0,{pinned:!0}),l=i("b",void 0,{pinned:!0});t.stubPromise(b,"getInstalled",[a,l]),t.stub(b,"updateMetadata",(s,r)=>(s.pinned=!!r.pinned,s)),e=await d(),await e.updateAutoUpdateEnablementFor(e.local[0],!1),n.deepStrictEqual(e.getEnabledAutoUpdateExtensions(),[]),n.deepStrictEqual(e.getDisabledAutoUpdateExtensions(),["pub.a"]),await e.updateAutoUpdateValue(!1),n.deepStrictEqual(e.getEnabledAutoUpdateExtensions(),[]),n.deepStrictEqual(e.getDisabledAutoUpdateExtensions(),[])}),test("Test reset autoupdate extensions state when auto update is enabled",async()=>{A(!1),t.stub(B,{confirm:()=>Promise.resolve({confirmed:!0})});const a=i("a",void 0,{pinned:!0}),l=i("b",void 0,{pinned:!0});t.stubPromise(b,"getInstalled",[a,l]),t.stub(b,"updateMetadata",(s,r)=>(s.pinned=!!r.pinned,s)),e=await d(),await e.updateAutoUpdateEnablementFor(e.local[0],!0),n.deepStrictEqual(e.getEnabledAutoUpdateExtensions(),["pub.a"]),n.deepStrictEqual(e.getDisabledAutoUpdateExtensions(),[]),await e.updateAutoUpdateValue(!0),n.deepStrictEqual(e.getEnabledAutoUpdateExtensions(),[]),n.deepStrictEqual(e.getDisabledAutoUpdateExtensions(),[])});async function d(){const a=E.add(t.createInstance(Q));return await a.queryLocal(),a}function A(a,l){const s={[J]:a??!0,[H]:l??!0},r=E.add(new L);t.stub(re,{onDidChangeConfiguration:r.event,getValue:u=>u?s[u]:void 0,updateValue:async(u,f)=>{s[u]=f,r.fire({affectedKeys:new Set([u]),source:oe.USER,change:{keys:[],overrides:[]},affectsConfiguration(U,Ce){return!0}})}})}function i(a="someext",l={},s={}){return l={name:a,publisher:"pub",version:"1.0.0",...l},s={type:h.User,location:m.file(`pub.${a}`),identifier:{id:O(l.publisher,l.name)},...s},Object.create({manifest:l,...s})}const j={changelog:null,download:null,icon:null,license:null,manifest:null,readme:null,repository:null,signature:null,coreTranslations:[]};function G(a,l={},s={},r=j){const u=W(R,F),f=Object.create({name:a,publisher:"pub",version:"1.0.0",allTargetPlatforms:[u],properties:{},assets:{},...l});return f.properties={...f.properties,dependencies:[],targetPlatform:u,...s},f.assets={...f.assets,...r},f.identifier={id:O(f.publisher,f.name),uuid:z()},f}function S(...a){return{firstPage:a,total:a.length,pageSize:a.length,getPage:()=>null}}function g(a,l,s){const r={id:"vscode-local",label:"local",extensionManagementService:l||p()},u={id:"vscode-remote",label:"remote",extensionManagementService:s||p()};return V(r,u,null)}function p(a=[]){return{onInstallExtension:q.None,onDidInstallExtensions:q.None,onUninstallExtension:q.None,onDidUninstallExtension:q.None,onDidChangeProfile:q.None,onDidUpdateExtensionMetadata:q.None,getInstalled:()=>Promise.resolve(a),installFromGallery:l=>Promise.reject(new Error("not supported")),updateMetadata:async(l,s,r)=>(l.identifier.uuid=s.id,l.publisherDisplayName=s.publisherDisplayName,l.publisherId=s.publisherId,l),getTargetPlatform:async()=>W(R,F),async getExtensionsControlManifest(){return{malicious:[],deprecated:{},search:[]}},async resetPinnedStateForAllUserExtensions(l){}}}});
