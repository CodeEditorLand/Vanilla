import e from"assert";import{stub as A}from"sinon";import{Emitter as V}from"../../../../../base/common/event.js";import{Disposable as q}from"../../../../../base/common/lifecycle.js";import{Schemas as F}from"../../../../../base/common/network.js";import{normalize as C}from"../../../../../base/common/path.js";import*as p from"../../../../../base/common/platform.js";import{isObject as L}from"../../../../../base/common/types.js";import{URI as h}from"../../../../../base/common/uri.js";import{ensureNoDisposablesAreLeakedInTestSuite as z}from"../../../../../base/test/common/utils.js";import{Selection as P}from"../../../../../editor/common/core/selection.js";import{EditorType as R}from"../../../../../editor/common/editorCommon.js";import"../../../../../platform/commands/common/commands.js";import"../../../../../platform/configuration/common/configuration.js";import{TestConfigurationService as y}from"../../../../../platform/configuration/test/common/testConfigurationService.js";import"../../../../../platform/extensions/common/extensions.js";import"../../../../../platform/label/common/label.js";import"../../../../../platform/workspace/common/workspace.js";import{testWorkspace as W}from"../../../../../platform/workspace/test/common/testWorkspace.js";import{BaseConfigurationResolverService as M}from"../../browser/baseConfigurationResolverService.js";import"../../common/configurationResolver.js";import"../../../extensions/common/extensions.js";import"../../../path/common/pathService.js";import{TestEditorService as D,TestQuickInputService as j}from"../../../../test/browser/workbenchTestServices.js";import{TestContextService as v,TestExtensionService as U,TestStorageService as w}from"../../../../test/common/workbenchTestServices.js";const x=10;class b extends D{get activeTextEditorControl(){return{getEditorType(){return R.ICodeEditor},getSelection(){return new P(x,1,x,10)}}}get activeEditor(){return{get resource(){return h.parse("file:///VSCode/workspaceLocation/file")}}}}class k extends M{}const g={getAppRoot:()=>{},getExecPath:()=>{}};suite("Configuration Resolver Service",()=>{let o;const i={key1:"Value for key1",key2:"Value for key2"};let n,f,S,a,d,u,m,l;const s=z();setup(()=>{n=new _,f=s.add(new b),d=new j,u=new T,m=new O,l=new U,S=W(h.parse("file:///VSCode/workspaceLocation")),a=S.folders[0],o=new k(g,Promise.resolve(i),f,new B,n,new v(S),d,u,m,l,s.add(new w))}),teardown(()=>{o=null}),test("substitute one",async()=>{p.isWindows?e.strictEqual(await o.resolveAsync(a,"abc ${workspaceFolder} xyz"),"abc \\VSCode\\workspaceLocation xyz"):e.strictEqual(await o.resolveAsync(a,"abc ${workspaceFolder} xyz"),"abc /VSCode/workspaceLocation xyz")}),test("workspace folder with argument",async()=>{p.isWindows?e.strictEqual(await o.resolveAsync(a,"abc ${workspaceFolder:workspaceLocation} xyz"),"abc \\VSCode\\workspaceLocation xyz"):e.strictEqual(await o.resolveAsync(a,"abc ${workspaceFolder:workspaceLocation} xyz"),"abc /VSCode/workspaceLocation xyz")}),test("workspace folder with invalid argument",()=>{e.rejects(async()=>await o.resolveAsync(a,"abc ${workspaceFolder:invalidLocation} xyz"))}),test("workspace folder with undefined workspace folder",()=>{e.rejects(async()=>await o.resolveAsync(void 0,"abc ${workspaceFolder} xyz"))}),test("workspace folder with argument and undefined workspace folder",async()=>{p.isWindows?e.strictEqual(await o.resolveAsync(void 0,"abc ${workspaceFolder:workspaceLocation} xyz"),"abc \\VSCode\\workspaceLocation xyz"):e.strictEqual(await o.resolveAsync(void 0,"abc ${workspaceFolder:workspaceLocation} xyz"),"abc /VSCode/workspaceLocation xyz")}),test("workspace folder with invalid argument and undefined workspace folder",()=>{e.rejects(async()=>await o.resolveAsync(void 0,"abc ${workspaceFolder:invalidLocation} xyz"))}),test("workspace root folder name",async()=>{e.strictEqual(await o.resolveAsync(a,"abc ${workspaceRootFolderName} xyz"),"abc workspaceLocation xyz")}),test("current selected line number",async()=>{e.strictEqual(await o.resolveAsync(a,"abc ${lineNumber} xyz"),`abc ${x} xyz`)}),test("relative file",async()=>{e.strictEqual(await o.resolveAsync(a,"abc ${relativeFile} xyz"),"abc file xyz")}),test("relative file with argument",async()=>{e.strictEqual(await o.resolveAsync(a,"abc ${relativeFile:workspaceLocation} xyz"),"abc file xyz")}),test("relative file with invalid argument",()=>{e.rejects(async()=>await o.resolveAsync(a,"abc ${relativeFile:invalidLocation} xyz"))}),test("relative file with undefined workspace folder",async()=>{p.isWindows?e.strictEqual(await o.resolveAsync(void 0,"abc ${relativeFile} xyz"),"abc \\VSCode\\workspaceLocation\\file xyz"):e.strictEqual(await o.resolveAsync(void 0,"abc ${relativeFile} xyz"),"abc /VSCode/workspaceLocation/file xyz")}),test("relative file with argument and undefined workspace folder",async()=>{e.strictEqual(await o.resolveAsync(void 0,"abc ${relativeFile:workspaceLocation} xyz"),"abc file xyz")}),test("relative file with invalid argument and undefined workspace folder",()=>{e.rejects(async()=>await o.resolveAsync(void 0,"abc ${relativeFile:invalidLocation} xyz"))}),test("substitute many",async()=>{p.isWindows?e.strictEqual(await o.resolveAsync(a,"${workspaceFolder} - ${workspaceFolder}"),"\\VSCode\\workspaceLocation - \\VSCode\\workspaceLocation"):e.strictEqual(await o.resolveAsync(a,"${workspaceFolder} - ${workspaceFolder}"),"/VSCode/workspaceLocation - /VSCode/workspaceLocation")}),test("substitute one env variable",async()=>{p.isWindows?e.strictEqual(await o.resolveAsync(a,"abc ${workspaceFolder} ${env:key1} xyz"),"abc \\VSCode\\workspaceLocation Value for key1 xyz"):e.strictEqual(await o.resolveAsync(a,"abc ${workspaceFolder} ${env:key1} xyz"),"abc /VSCode/workspaceLocation Value for key1 xyz")}),test("substitute many env variable",async()=>{p.isWindows?e.strictEqual(await o.resolveAsync(a,"${workspaceFolder} - ${workspaceFolder} ${env:key1} - ${env:key2}"),"\\VSCode\\workspaceLocation - \\VSCode\\workspaceLocation Value for key1 - Value for key2"):e.strictEqual(await o.resolveAsync(a,"${workspaceFolder} - ${workspaceFolder} ${env:key1} - ${env:key2}"),"/VSCode/workspaceLocation - /VSCode/workspaceLocation Value for key1 - Value for key2")}),test("disallows nested keys (#77289)",async()=>{e.strictEqual(await o.resolveAsync(a,"${env:key1} ${env:key1${env:key2}}"),"Value for key1 ${env:key1${env:key2}}")}),test("supports extensionDir",async()=>{A(l,"getExtension").withArgs("publisher.extId").returns(Promise.resolve({extensionLocation:h.file("/some/path")})),e.strictEqual(await o.resolveAsync(a,"${extensionInstallFolder:publisher.extId}"),h.file("/some/path").fsPath)}),test("substitute one env variable using platform case sensitivity",async()=>{p.isWindows?e.strictEqual(await o.resolveAsync(a,"${env:key1} - ${env:Key1}"),"Value for key1 - Value for key1"):e.strictEqual(await o.resolveAsync(a,"${env:key1} - ${env:Key1}"),"Value for key1 - ")}),test("substitute one configuration variable",async()=>{const r=new y({editor:{fontFamily:"foo"},terminal:{integrated:{fontFamily:"bar"}}}),t=new k(g,Promise.resolve(i),s.add(new b),r,n,new v,d,u,m,l,s.add(new w));e.strictEqual(await t.resolveAsync(a,"abc ${config:editor.fontFamily} xyz"),"abc foo xyz")}),test("substitute configuration variable with undefined workspace folder",async()=>{const r=new y({editor:{fontFamily:"foo"}}),t=new k(g,Promise.resolve(i),s.add(new b),r,n,new v,d,u,m,l,s.add(new w));e.strictEqual(await t.resolveAsync(void 0,"abc ${config:editor.fontFamily} xyz"),"abc foo xyz")}),test("substitute many configuration variables",async()=>{const r=new y({editor:{fontFamily:"foo"},terminal:{integrated:{fontFamily:"bar"}}}),t=new k(g,Promise.resolve(i),s.add(new b),r,n,new v,d,u,m,l,s.add(new w));e.strictEqual(await t.resolveAsync(a,"abc ${config:editor.fontFamily} ${config:terminal.integrated.fontFamily} xyz"),"abc foo bar xyz")}),test("substitute one env variable and a configuration variable",async()=>{const r=new y({editor:{fontFamily:"foo"},terminal:{integrated:{fontFamily:"bar"}}}),t=new k(g,Promise.resolve(i),s.add(new b),r,n,new v,d,u,m,l,s.add(new w));p.isWindows?e.strictEqual(await t.resolveAsync(a,"abc ${config:editor.fontFamily} ${workspaceFolder} ${env:key1} xyz"),"abc foo \\VSCode\\workspaceLocation Value for key1 xyz"):e.strictEqual(await t.resolveAsync(a,"abc ${config:editor.fontFamily} ${workspaceFolder} ${env:key1} xyz"),"abc foo /VSCode/workspaceLocation Value for key1 xyz")}),test("substitute many env variable and a configuration variable",async()=>{const r=new y({editor:{fontFamily:"foo"},terminal:{integrated:{fontFamily:"bar"}}}),t=new k(g,Promise.resolve(i),s.add(new b),r,n,new v,d,u,m,l,s.add(new w));p.isWindows?e.strictEqual(await t.resolveAsync(a,"${config:editor.fontFamily} ${config:terminal.integrated.fontFamily} ${workspaceFolder} - ${workspaceFolder} ${env:key1} - ${env:key2}"),"foo bar \\VSCode\\workspaceLocation - \\VSCode\\workspaceLocation Value for key1 - Value for key2"):e.strictEqual(await t.resolveAsync(a,"${config:editor.fontFamily} ${config:terminal.integrated.fontFamily} ${workspaceFolder} - ${workspaceFolder} ${env:key1} - ${env:key2}"),"foo bar /VSCode/workspaceLocation - /VSCode/workspaceLocation Value for key1 - Value for key2")}),test("mixed types of configuration variables",async()=>{const r=new y({editor:{fontFamily:"foo",lineNumbers:123,insertSpaces:!1},terminal:{integrated:{fontFamily:"bar"}},json:{schemas:[{fileMatch:["/myfile","/myOtherfile"],url:"schemaURL"}]}}),t=new k(g,Promise.resolve(i),s.add(new b),r,n,new v,d,u,m,l,s.add(new w));e.strictEqual(await t.resolveAsync(a,"abc ${config:editor.fontFamily} ${config:editor.lineNumbers} ${config:editor.insertSpaces} xyz"),"abc foo 123 false xyz")}),test("uses original variable as fallback",async()=>{const r=new y({editor:{}}),t=new k(g,Promise.resolve(i),s.add(new b),r,n,new v,d,u,m,l,s.add(new w));e.strictEqual(await t.resolveAsync(a,"abc ${unknownVariable} xyz"),"abc ${unknownVariable} xyz"),e.strictEqual(await t.resolveAsync(a,"abc ${env:unknownVariable} xyz"),"abc  xyz")}),test("configuration variables with invalid accessor",()=>{const r=new y({editor:{fontFamily:"foo"}}),t=new k(g,Promise.resolve(i),s.add(new b),r,n,new v,d,u,m,l,s.add(new w));e.rejects(async()=>await t.resolveAsync(a,"abc ${env} xyz")),e.rejects(async()=>await t.resolveAsync(a,"abc ${env:} xyz")),e.rejects(async()=>await t.resolveAsync(a,"abc ${config} xyz")),e.rejects(async()=>await t.resolveAsync(a,"abc ${config:} xyz")),e.rejects(async()=>await t.resolveAsync(a,"abc ${config:editor} xyz")),e.rejects(async()=>await t.resolveAsync(a,"abc ${config:editor..fontFamily} xyz")),e.rejects(async()=>await t.resolveAsync(a,"abc ${config:editor.none.none2} xyz"))}),test("a single command variable",()=>{const r={name:"Attach to Process",type:"node",request:"attach",processId:"${command:command1}",port:5858,sourceMaps:!1,outDir:null};return o.resolveWithInteractionReplace(void 0,r).then(t=>{e.deepStrictEqual({...t},{name:"Attach to Process",type:"node",request:"attach",processId:"command1-result",port:5858,sourceMaps:!1,outDir:null}),e.strictEqual(1,n.callCount)})}),test("an old style command variable",()=>{const r={name:"Attach to Process",type:"node",request:"attach",processId:"${command:commandVariable1}",port:5858,sourceMaps:!1,outDir:null},t=Object.create(null);return t.commandVariable1="command1",o.resolveWithInteractionReplace(void 0,r,void 0,t).then(c=>{e.deepStrictEqual({...c},{name:"Attach to Process",type:"node",request:"attach",processId:"command1-result",port:5858,sourceMaps:!1,outDir:null}),e.strictEqual(1,n.callCount)})}),test("multiple new and old-style command variables",()=>{const r={name:"Attach to Process",type:"node",request:"attach",processId:"${command:commandVariable1}",pid:"${command:command2}",sourceMaps:!1,outDir:"src/${command:command2}",env:{processId:"__${command:command2}__"}},t=Object.create(null);return t.commandVariable1="command1",o.resolveWithInteractionReplace(void 0,r,void 0,t).then(c=>{const E={name:"Attach to Process",type:"node",request:"attach",processId:"command1-result",pid:"command2-result",sourceMaps:!1,outDir:"src/command2-result",env:{processId:"__command2-result__"}};e.deepStrictEqual(Object.keys(c),Object.keys(E)),Object.keys(c).forEach($=>{const I=E[$];L(c[$])?e.deepStrictEqual({...c[$]},I):e.deepStrictEqual(c[$],I)}),e.strictEqual(2,n.callCount)})}),test("a command variable that relies on resolved env vars",()=>{const r={name:"Attach to Process",type:"node",request:"attach",processId:"${command:commandVariable1}",value:"${env:key1}"},t=Object.create(null);return t.commandVariable1="command1",o.resolveWithInteractionReplace(void 0,r,void 0,t).then(c=>{e.deepStrictEqual({...c},{name:"Attach to Process",type:"node",request:"attach",processId:"Value for key1",value:"Value for key1"}),e.strictEqual(1,n.callCount)})}),test("a single prompt input variable",()=>{const r={name:"Attach to Process",type:"node",request:"attach",processId:"${input:input1}",port:5858,sourceMaps:!1,outDir:null};return o.resolveWithInteractionReplace(a,r,"tasks").then(t=>{e.deepStrictEqual({...t},{name:"Attach to Process",type:"node",request:"attach",processId:"resolvedEnterinput1",port:5858,sourceMaps:!1,outDir:null}),e.strictEqual(0,n.callCount)})}),test("a single pick input variable",()=>{const r={name:"Attach to Process",type:"node",request:"attach",processId:"${input:input2}",port:5858,sourceMaps:!1,outDir:null};return o.resolveWithInteractionReplace(a,r,"tasks").then(t=>{e.deepStrictEqual({...t},{name:"Attach to Process",type:"node",request:"attach",processId:"selectedPick",port:5858,sourceMaps:!1,outDir:null}),e.strictEqual(0,n.callCount)})}),test("a single command input variable",()=>{const r={name:"Attach to Process",type:"node",request:"attach",processId:"${input:input4}",port:5858,sourceMaps:!1,outDir:null};return o.resolveWithInteractionReplace(a,r,"tasks").then(t=>{e.deepStrictEqual({...t},{name:"Attach to Process",type:"node",request:"attach",processId:"arg for command",port:5858,sourceMaps:!1,outDir:null}),e.strictEqual(1,n.callCount)})}),test("several input variables and command",()=>{const r={name:"${input:input3}",type:"${command:command1}",request:"${input:input1}",processId:"${input:input2}",command:"${input:input4}",port:5858,sourceMaps:!1,outDir:null};return o.resolveWithInteractionReplace(a,r,"tasks").then(t=>{e.deepStrictEqual({...t},{name:"resolvedEnterinput3",type:"command1-result",request:"resolvedEnterinput1",processId:"selectedPick",command:"arg for command",port:5858,sourceMaps:!1,outDir:null}),e.strictEqual(2,n.callCount)})}),test("input variable with undefined workspace folder",()=>{const r={name:"Attach to Process",type:"node",request:"attach",processId:"${input:input1}",port:5858,sourceMaps:!1,outDir:null};return o.resolveWithInteractionReplace(void 0,r,"tasks").then(t=>{e.deepStrictEqual({...t},{name:"Attach to Process",type:"node",request:"attach",processId:"resolvedEnterinput1",port:5858,sourceMaps:!1,outDir:null}),e.strictEqual(0,n.callCount)})}),test("contributed variable",()=>{const r="npm: compile",t="defaultBuildTask",c={name:"${"+t+"}"};return o.contributeVariable(t,async()=>r),o.resolveWithInteractionReplace(a,c).then(E=>{e.deepStrictEqual({...E},{name:`${r}`})})}),test("resolveWithEnvironment",async()=>{const r={VAR_1:"VAL_1",VAR_2:"VAL_2"},c=await o.resolveWithEnvironment({...r},void 0,"echo ${env:VAR_1}${env:VAR_2}");e.deepStrictEqual(c,"echo VAL_1VAL_2")})});class _{_serviceBrand;callCount=0;onWillExecuteCommand=()=>q.None;onDidExecuteCommand=()=>q.None;executeCommand(i,...n){this.callCount++;let f=`${i}-result`;return n.length>=1&&n[0]&&n[0].value&&(f=n[0].value),Promise.resolve(f)}}class T{_serviceBrand;getUriLabel(i,n){return C(i.fsPath)}getUriBasenameLabel(i){throw new Error("Method not implemented.")}getWorkspaceLabel(i,n){throw new Error("Method not implemented.")}getHostLabel(i,n){throw new Error("Method not implemented.")}getHostTooltip(){throw new Error("Method not implemented.")}getSeparator(i,n){throw new Error("Method not implemented.")}registerFormatter(i){throw new Error("Method not implemented.")}registerCachedFormatter(i){throw new Error("Method not implemented.")}onDidChangeFormatters=new V().event}class O{_serviceBrand;get path(){throw new Error("Property not implemented")}defaultUriScheme=F.file;fileURI(i){throw new Error("Method not implemented.")}userHome(i){const n=h.file("c:\\users\\username");return i?.preferLocal?n:Promise.resolve(n)}hasValidBasename(i,n,f){throw new Error("Method not implemented.")}resolvedUserHome}class B extends y{getValue(i,n){let f;return i==="tasks"&&(f={inputs:[{id:"input1",type:"promptString",description:"Enterinput1",default:"default input1"},{id:"input2",type:"pickString",description:"Enterinput1",default:"option2",options:["option1","option2","option3"]},{id:"input3",type:"promptString",description:"Enterinput3",default:"default input3",password:!0},{id:"input4",type:"command",command:"command1",args:{value:"arg for command"}}]}),f}}
