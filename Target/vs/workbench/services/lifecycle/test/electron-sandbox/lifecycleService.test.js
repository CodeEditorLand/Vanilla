import n from"assert";import{timeout as u}from"../../../../../base/common/async.js";import{DisposableStore as w}from"../../../../../base/common/lifecycle.js";import{runWithFakedTimers as h}from"../../../../../base/test/common/timeTravelScheduler.js";import{ensureNoDisposablesAreLeakedInTestSuite as S}from"../../../../../base/test/common/utils.js";import{ShutdownReason as l,WillShutdownJoinerOrder as c}from"../../common/lifecycle.js";import{NativeLifecycleService as m}from"../../electron-sandbox/lifecycleService.js";import{workbenchInstantiationService as v}from"../../../../test/electron-sandbox/workbenchTestServices.js";suite("Lifecycleservice",function(){let o;const r=new w;class f extends m{testHandleBeforeShutdown(t){return super.handleBeforeShutdown(t)}testHandleWillShutdown(t){return super.handleWillShutdown(t)}}setup(async()=>{const e=v(void 0,r);o=r.add(e.createInstance(f))}),teardown(async()=>{r.clear()}),test("onBeforeShutdown - final veto called after other vetos",async function(){let e=!1,t=!1;const a=[];r.add(o.onBeforeShutdown(i=>{i.veto(new Promise(d=>{e=!0,a.push(1),d(!1)}),"test")})),r.add(o.onBeforeShutdown(i=>{i.finalVeto(()=>new Promise(d=>{t=!0,a.push(2),d(!0)}),"test")}));const s=await o.testHandleBeforeShutdown(l.QUIT);n.strictEqual(s,!0),n.strictEqual(e,!0),n.strictEqual(t,!0),n.strictEqual(a[0],1),n.strictEqual(a[1],2)}),test("onBeforeShutdown - final veto not called when veto happened before",async function(){let e=!1,t=!1;r.add(o.onBeforeShutdown(s=>{s.veto(new Promise(i=>{e=!0,i(!0)}),"test")})),r.add(o.onBeforeShutdown(s=>{s.finalVeto(()=>new Promise(i=>{t=!0,i(!0)}),"test")}));const a=await o.testHandleBeforeShutdown(l.QUIT);n.strictEqual(a,!0),n.strictEqual(e,!0),n.strictEqual(t,!1)}),test("onBeforeShutdown - veto with error is treated as veto",async function(){r.add(o.onBeforeShutdown(t=>{t.veto(new Promise((a,s)=>{s(new Error("Fail"))}),"test")}));const e=await o.testHandleBeforeShutdown(l.QUIT);n.strictEqual(e,!0)}),test("onBeforeShutdown - final veto with error is treated as veto",async function(){r.add(o.onBeforeShutdown(t=>{t.finalVeto(()=>new Promise((a,s)=>{s(new Error("Fail"))}),"test")}));const e=await o.testHandleBeforeShutdown(l.QUIT);n.strictEqual(e,!0)}),test("onWillShutdown - join",async function(){let e=!1;r.add(o.onWillShutdown(t=>{t.join(new Promise(a=>{e=!0,a()}),{id:"test",label:"test"})})),await o.testHandleWillShutdown(l.QUIT),n.strictEqual(e,!0)}),test("onWillShutdown - join with error is handled",async function(){let e=!1;r.add(o.onWillShutdown(t=>{t.join(new Promise((a,s)=>{e=!0,s(new Error("Fail"))}),{id:"test",label:"test"})})),await o.testHandleWillShutdown(l.QUIT),n.strictEqual(e,!0)}),test("onWillShutdown - join order",async function(){return h({useFakeTimers:!0},async()=>{const e=[];r.add(o.onWillShutdown(t=>{t.join(async()=>{e.push("disconnect start"),await u(1),e.push("disconnect end")},{id:"test",label:"test",order:c.Last}),t.join((async()=>{e.push("default start"),await u(1),e.push("default end")})(),{id:"test",label:"test",order:c.Default})})),await o.testHandleWillShutdown(l.QUIT),n.deepStrictEqual(e,["default start","default end","disconnect start","disconnect end"])})}),S()});
