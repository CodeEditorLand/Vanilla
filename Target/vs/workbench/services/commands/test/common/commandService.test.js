import o from"assert";import{DisposableStore as v}from"../../../../../base/common/lifecycle.js";import{CommandsRegistry as m}from"../../../../../platform/commands/common/commands.js";import{CommandService as r}from"../../common/commandService.js";import{NullExtensionService as i}from"../../../extensions/common/extensions.js";import{InstantiationService as a}from"../../../../../platform/instantiation/common/instantiationService.js";import{NullLogService as c}from"../../../../../platform/log/common/log.js";suite("CommandService",function(){let w;setup(function(){w=m.registerCommand("foo",function(){})}),teardown(function(){w.dispose()}),test("activateOnCommand",()=>{let e;const n=new r(new a,new class extends i{activateByEvent(t){return e=t,super.activateByEvent(t)}},new c);return n.executeCommand("foo").then(()=>(o.ok(e,"onCommand:foo"),n.executeCommand("unknownCommandId"))).then(()=>{o.ok(!1)},()=>{o.ok(e,"onCommand:unknownCommandId")})}),test("fwd activation error",async function(){const e=new class extends i{activateByEvent(t){return Promise.reject(new Error("bad_activate"))}},n=new r(new a,e,new c);return await e.whenInstalledExtensionsRegistered(),n.executeCommand("foo").then(()=>o.ok(!1),t=>{o.strictEqual(t.message,"bad_activate")})}),test("!onReady, but executeCommand",function(){let e=0;const n=m.registerCommand("bar",()=>e+=1);new r(new a,new class extends i{whenInstalledExtensionsRegistered(){return new Promise(d=>{})}},new c).executeCommand("bar"),o.strictEqual(e,1),n.dispose()}),test("issue #34913: !onReady, unknown command",function(){let e=0,n;const t=new Promise(l=>{n=l}),s=new r(new a,new class extends i{whenInstalledExtensionsRegistered(){return t}},new c).executeCommand("bar");o.strictEqual(e,0);const u=m.registerCommand("bar",()=>e+=1);return n(!0),s.then(()=>{u.dispose(),o.strictEqual(e,1)})}),test("Stop waiting for * extensions to activate when trigger is satisfied #62457",function(){let e=0;const n=new v,t=[];return new r(new a,new class extends i{activateByEvent(s){return t.push(s),s==="*"?new Promise(()=>{}):s.indexOf("onCommand:")===0?new Promise(u=>{setTimeout(()=>{const l=m.registerCommand(s.substr(10),()=>{e+=1});n.add(l),u()},0)}):Promise.resolve()}},new c).executeCommand("farboo").then(()=>{o.strictEqual(e,1),o.deepStrictEqual(t.sort(),["*","onCommand:farboo"].sort())}).finally(()=>{n.dispose()})}),test("issue #71471: wait for onCommand activation even if a command is registered",()=>{const e=["registering command","resolving activation event","executing command"],n=[],t=new v;return new r(new a,new class extends i{activateByEvent(s){return s==="*"?new Promise(()=>{}):s.indexOf("onCommand:")===0?new Promise(u=>{setTimeout(()=>{n.push("registering command");const l=m.registerCommand(s.substr(10),()=>{n.push("executing command")});t.add(l),setTimeout(()=>{n.push("resolving activation event"),u()},10)},10)}):Promise.resolve()}},new c).executeCommand("farboo2").then(()=>{o.deepStrictEqual(n,e)}).finally(()=>{t.dispose()})}),test("issue #142155: execute commands synchronously if possible",async()=>{const e=[],n=new v;n.add(m.registerCommand("bizBaz",()=>{e.push("executing command")}));const t=new class extends i{activationEventIsDone(s){return!0}},d=new r(new a,t,new c);await t.whenInstalledExtensionsRegistered();try{e.push("before call");const s=d.executeCommand("bizBaz");e.push("after call"),await s,e.push("resolved"),o.deepStrictEqual(e,["before call","executing command","after call","resolved"])}finally{n.dispose()}})});
