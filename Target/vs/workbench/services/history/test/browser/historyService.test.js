import o from"assert";import{ensureNoDisposablesAreLeakedInTestSuite as O,toResource as E}from"../../../../../base/test/common/utils.js";import{URI as g}from"../../../../../base/common/uri.js";import{workbenchInstantiationService as C,TestFileEditorInput as h,registerTestEditor as L,createEditorPart as H,registerTestFileEditor as V,TestServiceAccessor as _,workbenchTeardown as G,registerTestSideBySideEditor as M}from"../../../../test/browser/workbenchTestServices.js";import"../../../../browser/parts/editor/editorPart.js";import{SyncDescriptor as J}from"../../../../../platform/instantiation/common/descriptors.js";import{IEditorGroupsService as W,GroupDirection as T}from"../../../editor/common/editorGroupsService.js";import{EditorNavigationStack as B,HistoryService as j}from"../../browser/historyService.js";import{IEditorService as z,SIDE_GROUP as b}from"../../../editor/common/editorService.js";import{EditorService as K}from"../../../editor/browser/editorService.js";import{DisposableStore as Q}from"../../../../../base/common/lifecycle.js";import{GoFilter as l,GoScope as I,IHistoryService as X}from"../../common/history.js";import{DeferredPromise as F,timeout as P}from"../../../../../base/common/async.js";import{Event as m}from"../../../../../base/common/event.js";import{EditorPaneSelectionChangeReason as q,isResourceEditorInput as Y}from"../../../../common/editor.js";import"../../../../../platform/editor/common/editor.js";import{EditorInput as k}from"../../../../common/editor/editorInput.js";import"../../../textfile/common/textfiles.js";import"../../../../../platform/instantiation/common/instantiation.js";import{FileChangesEvent as Z,FileChangeType as $,FileOperation as N,FileOperationEvent as A}from"../../../../../platform/files/common/files.js";import{isLinux as tt}from"../../../../../base/common/platform.js";import{Selection as s}from"../../../../../editor/common/core/selection.js";import"../../../../browser/parts/editor/editorPane.js";import{TestConfigurationService as et}from"../../../../../platform/configuration/test/common/testConfigurationService.js";import{IConfigurationService as it}from"../../../../../platform/configuration/common/configuration.js";import{SideBySideEditorInput as ot}from"../../../../common/editor/sideBySideEditorInput.js";suite("HistoryService",function(){const D="MyTestEditorForEditorHistory",v="testEditorInputForHistoyService";async function S(t=I.DEFAULT,r=!1){const e=C(void 0,u),c=await H(e,u);e.stub(W,c);const i=u.add(e.createInstance(K,void 0));e.stub(z,i);const n=new et;t===I.EDITOR_GROUP?n.setUserConfiguration("workbench.editor.navigationScope","editorGroup"):t===I.EDITOR&&n.setUserConfiguration("workbench.editor.navigationScope","editor"),r&&n.setUserConfiguration("search",{exclude:{"**/node_modules/**":!0}}),e.stub(it,n);const a=u.add(e.createInstance(j));e.stub(X,a);const d=e.createInstance(_);return[c,a,i,d.textFileService,e,n]}const u=new Q;setup(()=>{u.add(L(D,[new J(h)])),u.add(M()),u.add(V())}),teardown(()=>{u.clear()}),test("back / forward: basics",async()=>{const[t,r]=await S(),e=u.add(new h(g.parse("foo://bar1"),v));await t.activeGroup.openEditor(e,{pinned:!0}),o.strictEqual(t.activeGroup.activeEditor,e);const c=u.add(new h(g.parse("foo://bar2"),v));await t.activeGroup.openEditor(c,{pinned:!0}),o.strictEqual(t.activeGroup.activeEditor,c),await r.goBack(),o.strictEqual(t.activeGroup.activeEditor,e),await r.goForward(),o.strictEqual(t.activeGroup.activeEditor,c)}),test("back / forward: is editor group aware",async function(){const[t,r,e,,c]=await S(),i=E.call(this,"/path/index.txt"),n=E.call(this,"/path/other.html"),a=await e.openEditor({resource:i,options:{pinned:!0}}),d=await e.openEditor({resource:i,options:{pinned:!0}},b);return o.notStrictEqual(a,d),await e.openEditor({resource:n,options:{pinned:!0}},d?.group),await r.goBack(),o.strictEqual(t.activeGroup.id,d?.group.id),o.strictEqual(t.activeGroup.activeEditor?.resource?.toString(),i.toString()),await r.goBack(),o.strictEqual(t.activeGroup.id,a?.group.id),o.strictEqual(t.activeGroup.activeEditor?.resource?.toString(),i.toString()),await r.goForward(),o.strictEqual(t.activeGroup.id,d?.group.id),o.strictEqual(t.activeGroup.activeEditor?.resource?.toString(),i.toString()),await r.goForward(),o.strictEqual(t.activeGroup.id,d?.group.id),o.strictEqual(t.activeGroup.activeEditor?.resource?.toString(),n.toString()),G(c)}),test("back / forward: in-editor text selection changes (user)",async function(){const[,t,r,,e]=await S(),c=E.call(this,"/path/index.txt"),i=await r.openEditor({resource:c,options:{pinned:!0}});return await p(t,i,new s(1,2,1,2)),await p(t,i,new s(15,1,15,1)),await p(t,i,new s(16,1,16,1)),await p(t,i,new s(17,1,17,1)),await p(t,i,new s(30,5,30,8)),await p(t,i,new s(40,1,40,1)),await t.goBack(l.NONE),w(new s(30,5,30,8),i),await t.goBack(l.NONE),w(new s(17,1,17,1),i),await t.goBack(l.NONE),w(new s(1,2,1,2),i),await t.goForward(l.NONE),w(new s(17,1,17,1),i),G(e)}),test("back / forward: in-editor text selection changes (navigation)",async function(){const[,t,r,,e]=await S(),c=E.call(this,"/path/index.txt"),i=await r.openEditor({resource:c,options:{pinned:!0}});return await p(t,i,new s(2,2,2,10)),await p(t,i,new s(5,3,5,20),q.NAVIGATION),await p(t,i,new s(120,8,120,18),q.NAVIGATION),await p(t,i,new s(300,3,300,20)),await p(t,i,new s(500,3,500,20)),await p(t,i,new s(200,3,200,20)),await t.goBack(l.NAVIGATION),w(new s(120,8,120,18),i),await t.goBack(l.NAVIGATION),w(new s(5,3,5,20),i),await t.goBack(l.NAVIGATION),w(new s(5,3,5,20),i),await t.goForward(l.NAVIGATION),w(new s(120,8,120,18),i),await t.goPrevious(l.NAVIGATION),w(new s(5,3,5,20),i),await t.goPrevious(l.NAVIGATION),w(new s(120,8,120,18),i),G(e)}),test("back / forward: in-editor text selection changes (jump)",async function(){const[,t,r,,e]=await S(),c=E.call(this,"/path/index.txt"),i=await r.openEditor({resource:c,options:{pinned:!0}});return await p(t,i,new s(2,2,2,10),q.USER),await p(t,i,new s(5,3,5,20),q.JUMP),await p(t,i,new s(120,8,120,18),q.JUMP),await t.goBack(l.NAVIGATION),w(new s(5,3,5,20),i),await t.goBack(l.NAVIGATION),w(new s(2,2,2,10),i),await t.goForward(l.NAVIGATION),w(new s(5,3,5,20),i),await t.goLast(l.NAVIGATION),w(new s(120,8,120,18),i),await t.goPrevious(l.NAVIGATION),w(new s(5,3,5,20),i),await t.goPrevious(l.NAVIGATION),w(new s(120,8,120,18),i),G(e)}),test("back / forward: selection changes with JUMP or NAVIGATION source are not merged (#143833)",async function(){const[,t,r,,e]=await S(),c=E.call(this,"/path/index.txt"),i=await r.openEditor({resource:c,options:{pinned:!0}});return await p(t,i,new s(2,2,2,10),q.USER),await p(t,i,new s(5,3,5,20),q.JUMP),await p(t,i,new s(6,3,6,20),q.NAVIGATION),await t.goBack(l.NONE),w(new s(5,3,5,20),i),await t.goBack(l.NONE),w(new s(2,2,2,10),i),G(e)}),test("back / forward: edit selection changes",async function(){const[,t,r,,e]=await S(),c=E.call(this,"/path/index.txt"),i=await r.openEditor({resource:c,options:{pinned:!0}});return await p(t,i,new s(2,2,2,10)),await p(t,i,new s(50,3,50,20),q.EDIT),await p(t,i,new s(300,3,300,20)),await p(t,i,new s(500,3,500,20)),await p(t,i,new s(200,3,200,20)),await p(t,i,new s(5,3,5,20),q.EDIT),await p(t,i,new s(200,3,200,20)),await t.goBack(l.EDITS),w(new s(5,3,5,20),i),await t.goBack(l.EDITS),w(new s(50,3,50,20),i),await t.goForward(l.EDITS),w(new s(5,3,5,20),i),G(e)});async function p(t,r,e,c=q.USER){const i=m.toPromise(t.onDidChangeEditorNavigationStack);r.setSelection(e,c),await i}function w(t,r){const e=r.options;e||o.fail("EditorPane has no selection"),o.strictEqual(e.selection?.startLineNumber,t.startLineNumber),o.strictEqual(e.selection?.startColumn,t.startColumn),o.strictEqual(e.selection?.endLineNumber,t.endLineNumber),o.strictEqual(e.selection?.endColumn,t.endColumn)}test("back / forward: tracks editor moves across groups",async function(){const[t,r,e,,c]=await S(),i=E.call(this,"/path/one.txt"),n=E.call(this,"/path/two.html"),a=await e.openEditor({resource:i,options:{pinned:!0}});await e.openEditor({resource:n,options:{pinned:!0}});const d=t.addGroup(t.activeGroup,T.RIGHT),f=m.toPromise(e.onDidActiveEditorChange);return a?.group.moveEditor(a.input,d),await f,await r.goBack(),o.strictEqual(t.activeGroup.id,a?.group.id),o.strictEqual(t.activeGroup.activeEditor?.resource?.toString(),i.toString()),G(c)}),test("back / forward: tracks group removals",async function(){const[t,r,e,,c]=await S(),i=E.call(this,"/path/one.txt"),n=E.call(this,"/path/two.html"),a=await e.openEditor({resource:i,options:{pinned:!0}}),d=await e.openEditor({resource:n,options:{pinned:!0}},b);return o.notStrictEqual(a,d),await a?.group.closeAllEditors(),await r.goBack(),o.strictEqual(t.activeGroup.id,d?.group.id),o.strictEqual(t.activeGroup.activeEditor?.resource?.toString(),n.toString()),G(c)}),test("back / forward: editor navigation stack - navigation",async function(){const[,,t,,r]=await S(),e=r.createInstance(B,l.NONE,I.DEFAULT),c=E.call(this,"/path/index.txt"),i=E.call(this,"/path/index.html"),n=await t.openEditor({resource:c,options:{pinned:!0}});let a=!1;return u.add(e.onDidChange(()=>a=!0)),o.strictEqual(e.canGoBack(),!1),o.strictEqual(e.canGoForward(),!1),o.strictEqual(e.canGoLast(),!1),e.notifyNavigation(n,{reason:q.USER}),o.strictEqual(a,!0),a=!1,o.strictEqual(e.canGoBack(),!1),o.strictEqual(e.canGoLast(),!0),e.notifyNavigation(n,{reason:q.USER}),o.strictEqual(e.canGoBack(),!1),await t.openEditor({resource:i,options:{pinned:!0}}),e.notifyNavigation(n,{reason:q.USER}),o.strictEqual(a,!0),a=!1,o.strictEqual(e.canGoBack(),!0),await e.goBack(),o.strictEqual(e.canGoBack(),!1),o.strictEqual(e.canGoForward(),!0),o.strictEqual(e.canGoLast(),!0),await e.goForward(),o.strictEqual(e.canGoBack(),!0),o.strictEqual(e.canGoForward(),!1),await e.goPrevious(),o.strictEqual(e.canGoBack(),!1),o.strictEqual(e.canGoForward(),!0),await e.goPrevious(),o.strictEqual(e.canGoBack(),!0),o.strictEqual(e.canGoForward(),!1),await e.goBack(),await e.goLast(),o.strictEqual(e.canGoBack(),!0),o.strictEqual(e.canGoForward(),!1),e.dispose(),o.strictEqual(e.canGoBack(),!1),G(r)}),test("back / forward: editor navigation stack - mutations",async function(){const[,,t,,r]=await S(),e=u.add(r.createInstance(B,l.NONE,I.DEFAULT)),c=E.call(this,"/path/index.txt"),i=E.call(this,"/path/index.html"),n=E.call(this,"/path/unrelated.html"),a=await t.openEditor({resource:c,options:{pinned:!0}});e.notifyNavigation(a),await t.openEditor({resource:i,options:{pinned:!0}}),e.notifyNavigation(a),o.strictEqual(e.canGoBack(),!0),e.clear(),o.strictEqual(e.canGoBack(),!1),await t.openEditor({resource:c,options:{pinned:!0}}),e.notifyNavigation(a),await t.openEditor({resource:i,options:{pinned:!0}}),e.notifyNavigation(a),await e.goBack(),o.strictEqual(e.canGoForward(),!0),e.remove(new A(n,N.DELETE)),o.strictEqual(e.canGoForward(),!0),await e.goForward(),o.strictEqual(e.canGoBack(),!0),e.remove(new A(c,N.DELETE)),o.strictEqual(e.canGoBack(),!1),e.clear(),await t.openEditor({resource:c,options:{pinned:!0}}),e.notifyNavigation(a),await t.openEditor({resource:i,options:{pinned:!0}}),e.notifyNavigation(a),o.strictEqual(e.canGoBack(),!0),e.remove(new Z([{resource:c,type:$.DELETED}],!tt)),o.strictEqual(e.canGoBack(),!1),e.clear(),await t.openEditor({resource:c,options:{pinned:!0}}),e.notifyNavigation(a),await t.openEditor({resource:i,options:{pinned:!0}}),e.notifyNavigation(a),o.strictEqual(e.canGoBack(),!0),e.remove(a.input),o.strictEqual(e.canGoBack(),!1),e.clear(),await t.openEditor({resource:c,options:{pinned:!0}}),e.notifyNavigation(a),await t.openEditor({resource:i,options:{pinned:!0}}),e.notifyNavigation(a),o.strictEqual(e.canGoBack(),!0),e.remove(a.group.id),o.strictEqual(e.canGoBack(),!1),e.clear(),await t.openEditor({resource:c,options:{pinned:!0}}),e.notifyNavigation(a),await t.openEditor({resource:i,options:{pinned:!0}}),e.notifyNavigation(a);const d={ctime:0,etag:"",mtime:0,isDirectory:!1,isFile:!0,isSymbolicLink:!1,name:"other.txt",readonly:!1,locked:!1,size:0,resource:E.call(this,"/path/other.txt"),children:void 0};return e.move(new A(c,N.MOVE,d)),await e.goBack(),o.strictEqual(a?.input?.resource?.toString(),d.resource.toString()),G(r)}),test("back / forward: editor group scope",async function(){const[t,r,e,,c]=await S(I.EDITOR_GROUP),i=E.call(this,"/path/one.txt"),n=E.call(this,"/path/two.html"),a=E.call(this,"/path/three.html"),d=await e.openEditor({resource:i,options:{pinned:!0}});await e.openEditor({resource:n,options:{pinned:!0}}),await e.openEditor({resource:a,options:{pinned:!0}});const f=t.addGroup(t.activeGroup,T.RIGHT),y=await e.openEditor({resource:i,options:{pinned:!0}},f);return await e.openEditor({resource:n,options:{pinned:!0}}),await e.openEditor({resource:a,options:{pinned:!0}}),await r.goBack(),await r.goBack(),await r.goBack(),o.strictEqual(t.activeGroup.id,y?.group.id),o.strictEqual(t.activeGroup.activeEditor?.resource?.toString(),i.toString()),await e.openEditor({resource:a,options:{pinned:!0}},d?.group),await r.goBack(),await r.goBack(),await r.goBack(),o.strictEqual(t.activeGroup.id,d?.group.id),o.strictEqual(t.activeGroup.activeEditor?.resource?.toString(),i.toString()),G(c)}),test("back / forward: editor  scope",async function(){const[t,r,e,,c]=await S(I.EDITOR),i=E.call(this,"/path/one.txt"),n=E.call(this,"/path/two.html"),a=await e.openEditor({resource:i,options:{pinned:!0}});return await p(r,a,new s(2,2,2,10)),await p(r,a,new s(50,3,50,20)),await e.openEditor({resource:n,options:{pinned:!0}}),await p(r,a,new s(12,2,12,10)),await p(r,a,new s(150,3,150,20)),await r.goBack(),w(new s(12,2,12,10),a),await r.goBack(),w(new s(12,2,12,10),a),o.strictEqual(t.activeGroup.activeEditor?.resource?.toString(),n.toString()),await e.openEditor({resource:i,options:{pinned:!0}}),await r.goBack(),w(new s(2,2,2,10),a),await r.goBack(),w(new s(2,2,2,10),a),o.strictEqual(t.activeGroup.activeEditor?.resource?.toString(),i.toString()),G(c)}),test("go to last edit location",async function(){const[,t,r,e,c]=await S(),i=E.call(this,"/path/index.txt"),n=E.call(this,"/path/index.html");await r.openEditor({resource:i}),(await e.files.resolve(i)).textEditorModel.setValue("Hello World"),await P(10),await r.openEditor({resource:n});const d=new F;return u.add(r.onDidActiveEditorChange(f=>{d.complete(f)})),t.goLast(l.EDITS),await d.p,o.strictEqual(r.activeEditor?.resource?.toString(),i.toString()),G(c)}),test("reopen closed editor",async function(){const[,t,r,,e]=await S(),c=E.call(this,"/path/index.txt");await(await r.openEditor({resource:c}))?.group.closeAllEditors();const n=new F;return u.add(r.onDidActiveEditorChange(a=>{n.complete(a)})),t.reopenLastClosedEditor(),await n.p,o.strictEqual(r.activeEditor?.resource?.toString(),c.toString()),G(e)}),test("getHistory",async()=>{class t extends h{toUntyped(){return{resource:this.resource,options:{override:"testOverride"}}}}const[r,e,c,,i]=await S(void 0,!0);let n=e.getHistory();o.strictEqual(n.length,0);const a=u.add(new h(g.parse("foo://bar1/node_modules/test.txt"),v));await r.activeGroup.openEditor(a,{pinned:!0});const d=u.add(new h(g.parse("foo://bar2"),v));await r.activeGroup.openEditor(d,{pinned:!0});const f=u.add(new t(g.parse("foo://bar3"),v));await r.activeGroup.openEditor(f,{pinned:!0});const y=u.add(new t(g.file("bar4"),v));await r.activeGroup.openEditor(y,{pinned:!0}),n=e.getHistory(),o.strictEqual(n.length,4),o.strictEqual(Y(n[0])&&!(n[0]instanceof k),!0),o.strictEqual(n[0].options?.override,"testOverride"),o.strictEqual(n[1]instanceof k,!0),o.strictEqual(n[2]instanceof k,!0),o.strictEqual(n[3]instanceof k,!0),e.removeFromHistory(d),n=e.getHistory(),o.strictEqual(n.length,3),o.strictEqual(n[0].resource?.toString(),y.resource.toString()),a.dispose(),n=e.getHistory(),o.strictEqual(n.length,2);const R=u.add(new t(g.parse("file://bar5"),v)),U=u.add(new t(g.file("file://bar1/node_modules/test.txt"),v)),x=new ot(void 0,void 0,U,R,c);return await r.activeGroup.openEditor(x,{pinned:!0}),n=e.getHistory(),o.strictEqual(n.length,3),x.dispose(),n=e.getHistory(),o.strictEqual(n.length,3),G(i)}),test("getLastActiveFile",async()=>{const[t,r]=await S();o.ok(!r.getLastActiveFile("foo"));const e=u.add(new h(g.parse("foo://bar1"),v));await t.activeGroup.openEditor(e,{pinned:!0});const c=u.add(new h(g.parse("foo://bar2"),v));await t.activeGroup.openEditor(c,{pinned:!0}),o.strictEqual(r.getLastActiveFile("foo")?.toString(),c.resource.toString()),o.strictEqual(r.getLastActiveFile("foo","bar2")?.toString(),c.resource.toString()),o.strictEqual(r.getLastActiveFile("foo","bar1")?.toString(),e.resource.toString())}),test("open next/previous recently used editor (single group)",async()=>{const[t,r,e,,c]=await S(),i=u.add(new h(g.parse("foo://bar1"),v)),n=u.add(new h(g.parse("foo://bar2"),v));await t.activeGroup.openEditor(i,{pinned:!0}),o.strictEqual(t.activeGroup.activeEditor,i),await t.activeGroup.openEditor(n,{pinned:!0}),o.strictEqual(t.activeGroup.activeEditor,n);let a=m.toPromise(e.onDidActiveEditorChange);return r.openPreviouslyUsedEditor(),await a,o.strictEqual(t.activeGroup.activeEditor,i),a=m.toPromise(e.onDidActiveEditorChange),r.openNextRecentlyUsedEditor(),await a,o.strictEqual(t.activeGroup.activeEditor,n),a=m.toPromise(e.onDidActiveEditorChange),r.openPreviouslyUsedEditor(t.activeGroup.id),await a,o.strictEqual(t.activeGroup.activeEditor,i),a=m.toPromise(e.onDidActiveEditorChange),r.openNextRecentlyUsedEditor(t.activeGroup.id),await a,o.strictEqual(t.activeGroup.activeEditor,n),G(c)}),test("open next/previous recently used editor (multi group)",async()=>{const[t,r,e,,c]=await S(),i=t.activeGroup,n=u.add(new h(g.parse("foo://bar1"),v)),a=u.add(new h(g.parse("foo://bar2"),v)),d=t.addGroup(i,T.RIGHT);await i.openEditor(n,{pinned:!0}),await d.openEditor(a,{pinned:!0});let f=m.toPromise(e.onDidActiveEditorChange);return r.openPreviouslyUsedEditor(),await f,o.strictEqual(t.activeGroup,i),o.strictEqual(i.activeEditor,n),f=m.toPromise(e.onDidActiveEditorChange),r.openNextRecentlyUsedEditor(),await f,o.strictEqual(t.activeGroup,d),o.strictEqual(d.activeEditor,a),G(c)}),test("open next/previous recently is reset when other input opens",async()=>{const[t,r,e,,c]=await S(),i=u.add(new h(g.parse("foo://bar1"),v)),n=u.add(new h(g.parse("foo://bar2"),v)),a=u.add(new h(g.parse("foo://bar3"),v)),d=u.add(new h(g.parse("foo://bar4"),v));await t.activeGroup.openEditor(i,{pinned:!0}),await t.activeGroup.openEditor(n,{pinned:!0}),await t.activeGroup.openEditor(a,{pinned:!0});let f=m.toPromise(e.onDidActiveEditorChange);return r.openPreviouslyUsedEditor(),await f,o.strictEqual(t.activeGroup.activeEditor,n),await P(0),await t.activeGroup.openEditor(d,{pinned:!0}),f=m.toPromise(e.onDidActiveEditorChange),r.openPreviouslyUsedEditor(),await f,o.strictEqual(t.activeGroup.activeEditor,n),f=m.toPromise(e.onDidActiveEditorChange),r.openNextRecentlyUsedEditor(),await f,o.strictEqual(t.activeGroup.activeEditor,d),G(c)}),test("transient editors suspends editor change tracking",async()=>{const[t,r,e,,c]=await S(),i=u.add(new h(g.parse("foo://bar1"),v)),n=u.add(new h(g.parse("foo://bar2"),v)),a=u.add(new h(g.parse("foo://bar3"),v)),d=u.add(new h(g.parse("foo://bar4"),v)),f=u.add(new h(g.parse("foo://bar5"),v));let y=m.toPromise(e.onDidActiveEditorChange);return await t.activeGroup.openEditor(i,{pinned:!0}),o.strictEqual(t.activeGroup.activeEditor,i),await y,await t.activeGroup.openEditor(n,{transient:!0}),o.strictEqual(t.activeGroup.activeEditor,n),await t.activeGroup.openEditor(a,{transient:!0}),o.strictEqual(t.activeGroup.activeEditor,a),y=m.toPromise(e.onDidActiveEditorChange).then(()=>m.toPromise(e.onDidActiveEditorChange)),await t.activeGroup.openEditor(d,{pinned:!0}),o.strictEqual(t.activeGroup.activeEditor,d),await t.activeGroup.openEditor(f,{pinned:!0}),o.strictEqual(t.activeGroup.activeEditor,f),await r.goBack(),o.strictEqual(t.activeGroup.activeEditor,d),await r.goBack(),o.strictEqual(t.activeGroup.activeEditor,i),await r.goBack(),o.strictEqual(t.activeGroup.activeEditor,i),await r.goForward(),o.strictEqual(t.activeGroup.activeEditor,d),await r.goForward(),o.strictEqual(t.activeGroup.activeEditor,f),G(c)}),O()});
