import o from"assert";import*as g from"fs";import*as s from"../../../common/encoding.js";import*as y from"../../../../../../base/common/stream.js";import{newWriteableBufferStream as h,VSBuffer as w,streamToBufferReadableStream as B}from"../../../../../../base/common/buffer.js";import{splitLines as S}from"../../../../../../base/common/strings.js";import{FileAccess as r}from"../../../../../../base/common/network.js";import{importAMDNodeModule as x}from"../../../../../../amdX.js";import{ensureNoDisposablesAreLeakedInTestSuite as U}from"../../../../../../base/test/common/utils.js";async function b(E){try{const{buffer:l,bytesRead:u}=await d(E,3);return s.detectEncodingByBOMFromBuffer(l,u)}catch{return null}}function d(E,l){return new Promise((u,e)=>{g.open(E,"r",null,(t,n)=>{if(t)return e(t);function i(f,F,p){g.close(n,v=>v?e(v):f&&f.code==="EISDIR"?e(f):u({buffer:F?w.wrap(F):null,bytesRead:p}))}const c=Buffer.allocUnsafe(l);let a=0;function m(){g.read(n,c,a,l-a,null,(f,F)=>f?i(f,null,0):F===0||(a+=F,a===l)?i(null,c,a):m())}m()})})}suite("Encoding",()=>{test("detectBOM does not return error for non existing file",async()=>{const e=r.asFileUri("vs/workbench/services/textfile/test/node/encoding/fixtures/not-exist.css").fsPath,t=await b(e);o.strictEqual(t,null)}),test("detectBOM UTF-8",async()=>{const e=r.asFileUri("vs/workbench/services/textfile/test/node/encoding/fixtures/some_utf8.css").fsPath,t=await b(e);o.strictEqual(t,"utf8bom")}),test("detectBOM UTF-16 LE",async()=>{const e=r.asFileUri("vs/workbench/services/textfile/test/node/encoding/fixtures/some_utf16le.css").fsPath,t=await b(e);o.strictEqual(t,"utf16le")}),test("detectBOM UTF-16 BE",async()=>{const e=r.asFileUri("vs/workbench/services/textfile/test/node/encoding/fixtures/some_utf16be.css").fsPath,t=await b(e);o.strictEqual(t,"utf16be")}),test("detectBOM ANSI",async function(){const e=r.asFileUri("vs/workbench/services/textfile/test/node/encoding/fixtures/some_ansi.css").fsPath,t=await b(e);o.strictEqual(t,null)}),test("detectBOM ANSI (2)",async function(){const e=r.asFileUri("vs/workbench/services/textfile/test/node/encoding/fixtures/empty.txt").fsPath,t=await b(e);o.strictEqual(t,null)}),test("detectEncodingFromBuffer (JSON saved as PNG)",async function(){const e=r.asFileUri("vs/workbench/services/textfile/test/node/encoding/fixtures/some.json.png").fsPath,t=await d(e,512),n=s.detectEncodingFromBuffer(t);o.strictEqual(n.seemsBinary,!1)}),test("detectEncodingFromBuffer (PNG saved as TXT)",async function(){const e=r.asFileUri("vs/workbench/services/textfile/test/node/encoding/fixtures/some.png.txt").fsPath,t=await d(e,512),n=s.detectEncodingFromBuffer(t);o.strictEqual(n.seemsBinary,!0)}),test("detectEncodingFromBuffer (XML saved as PNG)",async function(){const e=r.asFileUri("vs/workbench/services/textfile/test/node/encoding/fixtures/some.xml.png").fsPath,t=await d(e,512),n=s.detectEncodingFromBuffer(t);o.strictEqual(n.seemsBinary,!1)}),test("detectEncodingFromBuffer (QWOFF saved as TXT)",async function(){const e=r.asFileUri("vs/workbench/services/textfile/test/node/encoding/fixtures/some.qwoff.txt").fsPath,t=await d(e,512),n=s.detectEncodingFromBuffer(t);o.strictEqual(n.seemsBinary,!0)}),test("detectEncodingFromBuffer (CSS saved as QWOFF)",async function(){const e=r.asFileUri("vs/workbench/services/textfile/test/node/encoding/fixtures/some.css.qwoff").fsPath,t=await d(e,512),n=s.detectEncodingFromBuffer(t);o.strictEqual(n.seemsBinary,!1)}),test("detectEncodingFromBuffer (PDF)",async function(){const e=r.asFileUri("vs/workbench/services/textfile/test/node/encoding/fixtures/some.pdf").fsPath,t=await d(e,512),n=s.detectEncodingFromBuffer(t);o.strictEqual(n.seemsBinary,!0)}),test("detectEncodingFromBuffer (guess UTF-16 LE from content without BOM)",async function(){const e=r.asFileUri("vs/workbench/services/textfile/test/node/encoding/fixtures/utf16_le_nobom.txt").fsPath,t=await d(e,512),n=s.detectEncodingFromBuffer(t);o.strictEqual(n.encoding,s.UTF16le),o.strictEqual(n.seemsBinary,!1)}),test("detectEncodingFromBuffer (guess UTF-16 BE from content without BOM)",async function(){const e=r.asFileUri("vs/workbench/services/textfile/test/node/encoding/fixtures/utf16_be_nobom.txt").fsPath,t=await d(e,512),n=s.detectEncodingFromBuffer(t);o.strictEqual(n.encoding,s.UTF16be),o.strictEqual(n.seemsBinary,!1)}),test("autoGuessEncoding (UTF8)",async function(){const e=r.asFileUri("vs/workbench/services/textfile/test/node/encoding/fixtures/some_file.css").fsPath,t=await d(e,512*8),n=await s.detectEncodingFromBuffer(t,!0);o.strictEqual(n.encoding,"utf8")}),test("autoGuessEncoding (ASCII)",async function(){const e=r.asFileUri("vs/workbench/services/textfile/test/node/encoding/fixtures/some_ansi.css").fsPath,t=await d(e,512*8),n=await s.detectEncodingFromBuffer(t,!0);o.strictEqual(n.encoding,null)}),test("autoGuessEncoding (ShiftJIS)",async function(){const e=r.asFileUri("vs/workbench/services/textfile/test/node/encoding/fixtures/some.shiftjis.txt").fsPath,t=await d(e,512*8),n=await s.detectEncodingFromBuffer(t,!0);o.strictEqual(n.encoding,"shiftjis")}),test("autoGuessEncoding (CP1252)",async function(){const e=r.asFileUri("vs/workbench/services/textfile/test/node/encoding/fixtures/some.cp1252.txt").fsPath,t=await d(e,512*8),n=await s.detectEncodingFromBuffer(t,!0);o.strictEqual(n.encoding,"windows1252")}),test("autoGuessEncoding (candidateGuessEncodings - ShiftJIS)",async function(){const e=r.asFileUri("vs/workbench/services/textfile/test/node/encoding/fixtures/some.shiftjis.1.txt").fsPath,t=await d(e,512*8),n=await s.detectEncodingFromBuffer(t,!0,["utf8","shiftjis","eucjp"]);o.strictEqual(n.encoding,"shiftjis")});async function E(e,t){return new Promise((n,i)=>{g.readFile(e,(c,a)=>{c?i(c):n(x("@vscode/iconv-lite-umd","lib/iconv-lite-umd.js").then(m=>m.decode(a,s.toNodeEncoding(t))))})})}function l(e){const t=h();return e.map(w.wrap).forEach(n=>{setTimeout(()=>{t.write(n)})}),setTimeout(()=>{t.end()}),t}async function u(e){return y.consumeStream(e,t=>t.join(""))}test("toDecodeStream - some stream",async function(){const e=l([Buffer.from([65,66,67]),Buffer.from([65,66,67]),Buffer.from([65,66,67])]),{detected:t,stream:n}=await s.toDecodeStream(e,{acceptTextOnly:!0,minBytesRequiredForDetection:4,guessEncoding:!1,candidateGuessEncodings:[],overwriteEncoding:async c=>c||s.UTF8});o.ok(t),o.ok(n);const i=await u(n);o.strictEqual(i,"ABCABCABC")}),test("toDecodeStream - some stream, expect too much data",async function(){const e=l([Buffer.from([65,66,67]),Buffer.from([65,66,67]),Buffer.from([65,66,67])]),{detected:t,stream:n}=await s.toDecodeStream(e,{acceptTextOnly:!0,minBytesRequiredForDetection:64,guessEncoding:!1,candidateGuessEncodings:[],overwriteEncoding:async c=>c||s.UTF8});o.ok(t),o.ok(n);const i=await u(n);o.strictEqual(i,"ABCABCABC")}),test("toDecodeStream - some stream, no data",async function(){const e=h();e.end();const{detected:t,stream:n}=await s.toDecodeStream(e,{acceptTextOnly:!0,minBytesRequiredForDetection:512,guessEncoding:!1,candidateGuessEncodings:[],overwriteEncoding:async c=>c||s.UTF8});o.ok(t),o.ok(n);const i=await u(n);o.strictEqual(i,"")}),test("toDecodeStream - encoding, utf16be",async function(){const e=r.asFileUri("vs/workbench/services/textfile/test/node/encoding/fixtures/some_utf16be.css").fsPath,t=B(g.createReadStream(e)),{detected:n,stream:i}=await s.toDecodeStream(t,{acceptTextOnly:!0,minBytesRequiredForDetection:64,guessEncoding:!1,candidateGuessEncodings:[],overwriteEncoding:async m=>m||s.UTF8});o.strictEqual(n.encoding,"utf16be"),o.strictEqual(n.seemsBinary,!1);const c=await E(e,n.encoding),a=await u(i);o.strictEqual(a,c)}),test("toDecodeStream - empty file",async function(){const e=r.asFileUri("vs/workbench/services/textfile/test/node/encoding/fixtures/empty.txt").fsPath,t=B(g.createReadStream(e)),{detected:n,stream:i}=await s.toDecodeStream(t,{acceptTextOnly:!0,guessEncoding:!1,candidateGuessEncodings:[],overwriteEncoding:async m=>m||s.UTF8}),c=await E(e,n.encoding),a=await u(i);o.strictEqual(a,c)}),test("toDecodeStream - decodes buffer entirely",async function(){const e=Buffer.from("\u{1F5A5}\uFE0F\u{1F4BB}\u{1F4BE}"),t=e.slice(0,e.length-1),n=[];for(let f=0;f<t.length;f++)n.push(t.slice(f,f+1));const i=l(n),{stream:c}=await s.toDecodeStream(i,{acceptTextOnly:!0,minBytesRequiredForDetection:4,guessEncoding:!1,candidateGuessEncodings:[],overwriteEncoding:async f=>f||s.UTF8}),a=new TextDecoder().decode(t),m=await u(c);o.strictEqual(m,a)}),test("toDecodeStream - some stream (GBK issue #101856)",async function(){const e=r.asFileUri("vs/workbench/services/textfile/test/node/encoding/fixtures/some_gbk.txt").fsPath,t=B(g.createReadStream(e)),{detected:n,stream:i}=await s.toDecodeStream(t,{acceptTextOnly:!0,minBytesRequiredForDetection:4,guessEncoding:!1,candidateGuessEncodings:[],overwriteEncoding:async()=>"gbk"});o.ok(n),o.ok(i);const c=await u(i);o.strictEqual(c.length,65537)}),test("toDecodeStream - some stream (UTF-8 issue #102202)",async function(){const e=r.asFileUri("vs/workbench/services/textfile/test/node/encoding/fixtures/issue_102202.txt").fsPath,t=B(g.createReadStream(e)),{detected:n,stream:i}=await s.toDecodeStream(t,{acceptTextOnly:!0,minBytesRequiredForDetection:4,guessEncoding:!1,candidateGuessEncodings:[],overwriteEncoding:async()=>"utf-8"});o.ok(n),o.ok(i);const c=await u(i),a=S(c);o.strictEqual(a[981].toString(),"\u554A\u554A\u554A\u554A\u554A\u554Aaaa\u554A\u554A\u554A\u554A\u554A\u554A\u554A\u554A\u554A\u554A\u554A\u554A\u554A\u554A\u554A\u554A\u554A\u554A\uFF0C\u554A\u554A\u554A\u554A\u554A\u554A\u554A\u554A\u554A\u554A\u554A\u3002")}),test("toDecodeStream - binary",async function(){const e=()=>l([Buffer.from([0,0,0]),Buffer.from("Hello World"),Buffer.from([0])]);let t;try{await s.toDecodeStream(e(),{acceptTextOnly:!0,guessEncoding:!1,candidateGuessEncodings:[],overwriteEncoding:async c=>c||s.UTF8})}catch(c){t=c}o.ok(t instanceof s.DecodeStreamError),o.strictEqual(t.decodeStreamErrorKind,s.DecodeStreamErrorKind.STREAM_IS_BINARY);const{detected:n,stream:i}=await s.toDecodeStream(e(),{acceptTextOnly:!1,guessEncoding:!1,candidateGuessEncodings:[],overwriteEncoding:async c=>c||s.UTF8});o.ok(n),o.strictEqual(n.seemsBinary,!0),o.ok(i)}),test("toEncodeReadable - encoding, utf16be",async function(){const e=r.asFileUri("vs/workbench/services/textfile/test/node/encoding/fixtures/some_utf16be.css").fsPath,t=await E(e,s.UTF16be),n=await x("@vscode/iconv-lite-umd","lib/iconv-lite-umd.js"),i=w.wrap(n.encode(t,s.toNodeEncoding(s.UTF16be))).toString(),c=y.consumeReadable(await s.toEncodeReadable(y.toReadable(t),s.UTF16be),w.concat).toString();o.strictEqual(c,i)}),test("toEncodeReadable - empty readable to utf8",async function(){const e={read(){return null}},t=y.consumeReadable(await s.toEncodeReadable(e,s.UTF8),w.concat).toString();o.strictEqual(t,"")}),[{utfEncoding:s.UTF8,relatedBom:s.UTF8_BOM},{utfEncoding:s.UTF8_with_bom,relatedBom:s.UTF8_BOM},{utfEncoding:s.UTF16be,relatedBom:s.UTF16be_BOM},{utfEncoding:s.UTF16le,relatedBom:s.UTF16le_BOM}].forEach(({utfEncoding:e,relatedBom:t})=>{test(`toEncodeReadable - empty readable to ${e} with BOM`,async function(){const n={read(){return null}},i=s.toEncodeReadable(n,e,{addBOM:!0}),c=w.wrap(Buffer.from(t)).toString(),a=y.consumeReadable(await i,w.concat).toString();o.strictEqual(a,c)})}),test("encodingExists",async function(){for(const e in s.SUPPORTED_ENCODINGS){if(e===s.UTF8_with_bom)continue;const t=await x("@vscode/iconv-lite-umd","lib/iconv-lite-umd.js");o.strictEqual(t.encodingExists(e),!0,e)}}),U()});export{b as detectEncodingByBOM};
