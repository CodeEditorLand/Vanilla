var y=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var T=(p,e,o,s)=>{for(var a=s>1?void 0:s?m(e,o):e,t=p.length-1,r;t>=0;t--)(r=p[t])&&(a=(s?r(e,o,a):r(a))||a);return s&&a&&y(e,o,a),a},S=(p,e)=>(o,s)=>e(o,s,p);import{raceCancellation as C}from"../../../base/common/async.js";import{Emitter as g,Event as d}from"../../../base/common/event.js";import{DisposableStore as v}from"../../../base/common/lifecycle.js";import{ILogService as E}from"../../../platform/log/common/log.js";import{ExtHostContext as u,MainContext as w}from"../common/extHost.protocol.js";import{ISpeechService as R,TextToSpeechStatus as I}from"../../contrib/speech/common/speechService.js";import{extHostNamedCustomer as D}from"../../services/extensions/common/extHostCustomers.js";let h=class{constructor(e,o,s){this.speechService=o;this.logService=s;this.proxy=e.getProxy(u.ExtHostSpeech)}proxy;providerRegistrations=new Map;speechToTextSessions=new Map;textToSpeechSessions=new Map;keywordRecognitionSessions=new Map;$registerProvider(e,o,s){this.logService.trace("[Speech] extension registered provider",s.extension.value);const a=this.speechService.registerSpeechProvider(o,{metadata:s,createSpeechToTextSession:(t,r)=>{if(t.isCancellationRequested)return{onDidChange:d.None};const n=new v,i=Math.random();this.proxy.$createSpeechToTextSession(e,i,r?.language);const c=n.add(new g);return this.speechToTextSessions.set(i,{onDidChange:c}),n.add(t.onCancellationRequested(()=>{this.proxy.$cancelSpeechToTextSession(i),this.speechToTextSessions.delete(i),n.dispose()})),{onDidChange:c.event}},createTextToSpeechSession:(t,r)=>{if(t.isCancellationRequested)return{onDidChange:d.None,synthesize:async()=>{}};const n=new v,i=Math.random();this.proxy.$createTextToSpeechSession(e,i,r?.language);const c=n.add(new g);return this.textToSpeechSessions.set(i,{onDidChange:c}),n.add(t.onCancellationRequested(()=>{this.proxy.$cancelTextToSpeechSession(i),this.textToSpeechSessions.delete(i),n.dispose()})),{onDidChange:c.event,synthesize:async x=>{await this.proxy.$synthesizeSpeech(i,x),await C(d.toPromise(d.filter(c.event,l=>l.status===I.Stopped)),t)}}},createKeywordRecognitionSession:t=>{if(t.isCancellationRequested)return{onDidChange:d.None};const r=new v,n=Math.random();this.proxy.$createKeywordRecognitionSession(e,n);const i=r.add(new g);return this.keywordRecognitionSessions.set(n,{onDidChange:i}),r.add(t.onCancellationRequested(()=>{this.proxy.$cancelKeywordRecognitionSession(n),this.keywordRecognitionSessions.delete(n),r.dispose()})),{onDidChange:i.event}}});this.providerRegistrations.set(e,{dispose:()=>{a.dispose()}})}$unregisterProvider(e){const o=this.providerRegistrations.get(e);o&&(o.dispose(),this.providerRegistrations.delete(e))}$emitSpeechToTextEvent(e,o){this.speechToTextSessions.get(e)?.onDidChange.fire(o)}$emitTextToSpeechEvent(e,o){this.textToSpeechSessions.get(e)?.onDidChange.fire(o)}$emitKeywordRecognitionEvent(e,o){this.keywordRecognitionSessions.get(e)?.onDidChange.fire(o)}dispose(){this.providerRegistrations.forEach(e=>e.dispose()),this.providerRegistrations.clear(),this.speechToTextSessions.forEach(e=>e.onDidChange.dispose()),this.speechToTextSessions.clear(),this.textToSpeechSessions.forEach(e=>e.onDidChange.dispose()),this.textToSpeechSessions.clear(),this.keywordRecognitionSessions.forEach(e=>e.onDidChange.dispose()),this.keywordRecognitionSessions.clear()}};h=T([D(w.MainThreadSpeech),S(1,R),S(2,E)],h);export{h as MainThreadSpeech};
