import o from"assert";import{MainThreadMessageService as c}from"../../browser/mainThreadMessageService.js";import"../../../../platform/dialogs/common/dialogs.js";import{NoOpNotification as f}from"../../../../platform/notification/common/notification.js";import"../../../../platform/commands/common/commands.js";import{mock as p}from"../../../../base/test/common/mock.js";import{Disposable as l}from"../../../../base/common/lifecycle.js";import{Event as n}from"../../../../base/common/event.js";import{TestDialogService as h}from"../../../../platform/dialogs/test/common/testDialogService.js";import{ensureNoDisposablesAreLeakedInTestSuite as w}from"../../../../base/test/common/utils.js";import{TestExtensionService as d}from"../../../test/common/workbenchTestServices.js";const m={_serviceBrand:void 0,onWillExecuteCommand:()=>l.None,onDidExecuteCommand:()=>l.None,executeCommand:(e,...t)=>Promise.resolve(void 0)},u=new class{onDidAddNotification=n.None;onDidRemoveNotification=n.None;onDidChangeFilter=n.None;notify(...e){throw new Error("not implemented")}info(...e){throw new Error("not implemented")}warn(...e){throw new Error("not implemented")}error(...e){throw new Error("not implemented")}prompt(e,t,i,s){throw new Error("not implemented")}status(e,t){return l.None}setFilter(){throw new Error("not implemented")}getFilter(e){throw new Error("not implemented")}getFilters(){throw new Error("not implemented")}removeFilter(e){throw new Error("not implemented")}};class v{constructor(t){this.withNotify=t}filter=!1;onDidAddNotification=n.None;onDidRemoveNotification=n.None;onDidChangeFilter=n.None;notify(t){return this.withNotify(t),new f}info(t){throw new Error("Method not implemented.")}warn(t){throw new Error("Method not implemented.")}error(t){throw new Error("Method not implemented.")}prompt(t,i,s,r){throw new Error("Method not implemented")}status(t,i){return l.None}setFilter(){throw new Error("Method not implemented.")}getFilter(t){throw new Error("Method not implemented.")}getFilters(){throw new Error("Method not implemented.")}removeFilter(t){throw new Error("Method not implemented.")}}suite("ExtHostMessageService",function(){test("propagte handle on select",async function(){const e=new c(null,new v(i=>{o.strictEqual(i.actions.primary.length,1),queueMicrotask(()=>i.actions.primary[0].run())}),m,new h,new d),t=await e.$showMessage(1,"h",{},[{handle:42,title:"a thing",isCloseAffordance:!0}]);o.strictEqual(t,42),e.dispose()}),suite("modal",()=>{test("calls dialog service",async()=>{const e=new c(null,u,m,new class extends p(){prompt({type:i,message:s,buttons:r,cancelButton:a}){return o.strictEqual(i,1),o.strictEqual(s,"h"),o.strictEqual(r.length,1),o.strictEqual(a.label,"Cancel"),Promise.resolve({result:r[0].run({checkboxChecked:!1})})}},new d),t=await e.$showMessage(1,"h",{modal:!0},[{handle:42,title:"a thing",isCloseAffordance:!1}]);o.strictEqual(t,42),e.dispose()}),test("returns undefined when cancelled",async()=>{const e=new c(null,u,m,new class extends p(){prompt(i){return Promise.resolve({result:i.cancelButton.run({checkboxChecked:!1})})}},new d),t=await e.$showMessage(1,"h",{modal:!0},[{handle:42,title:"a thing",isCloseAffordance:!1}]);o.strictEqual(t,void 0),e.dispose()}),test("hides Cancel button when not needed",async()=>{const e=new c(null,u,m,new class extends p(){prompt({type:i,message:s,buttons:r,cancelButton:a}){return o.strictEqual(r.length,0),o.ok(a),Promise.resolve({result:a.run({checkboxChecked:!1})})}},new d),t=await e.$showMessage(1,"h",{modal:!0},[{handle:42,title:"a thing",isCloseAffordance:!0}]);o.strictEqual(t,42),e.dispose()})}),w()});
