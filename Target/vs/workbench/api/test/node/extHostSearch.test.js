import c from"assert";import{mapArrayOrNot as j}from"../../../../base/common/arrays.js";import{timeout as $}from"../../../../base/common/async.js";import{CancellationTokenSource as O}from"../../../../base/common/cancellation.js";import{isCancellationError as M}from"../../../../base/common/errors.js";import{revive as A}from"../../../../base/common/marshalling.js";import{joinPath as h}from"../../../../base/common/resources.js";import{URI as k}from"../../../../base/common/uri.js";import"../../../../base/node/pfs.js";import{mock as U}from"../../../../base/test/common/mock.js";import{ensureNoDisposablesAreLeakedInTestSuite as N}from"../../../../base/test/common/utils.js";import{NullLogService as B}from"../../../../platform/log/common/log.js";import{MainContext as L}from"../../common/extHost.protocol.js";import"../../common/extHostConfiguration.js";import"../../common/extHostInitDataService.js";import{Range as E}from"../../common/extHostTypes.js";import{URITransformerService as D}from"../../common/extHostUriTransformerService.js";import{NativeExtHostSearch as K}from"../../node/extHostSearch.js";import{TestRPCProtocol as W}from"../common/testRPCProtocol.js";import{QueryType as p,resultIsMatch as _}from"../../../services/search/common/search.js";import"../../../services/search/common/textSearchManager.js";import{NativeTextSearchManager as z}from"../../../services/search/node/textSearchManager.js";let w,Q,F;class G{lastHandle;results=[];$registerFileSearchProvider(m,S){this.lastHandle=m}$registerTextSearchProvider(m,S){this.lastHandle=m}$registerAITextSearchProvider(m,S){this.lastHandle=m}$unregisterProvider(m){}$handleFileMatch(m,S,x){this.results.push(...x)}$handleTextMatch(m,S,x){this.results.push(...x)}$handleTelemetry(m,S){}dispose(){}}let b;function H(T){return!!T.preview}suite("ExtHostSearch",()=>{const T=N();async function m(P,l="file"){T.add(Q.registerTextSearchProviderOld(l,P)),await w.sync()}async function S(P,l="file"){T.add(Q.registerFileSearchProviderOld(l,P)),await w.sync()}async function x(P,l=!1){let s;try{const r=new O,i=Q.$provideFileSearchResults(F.lastHandle,0,P,r.token);l&&(await $(0),r.cancel()),s=await i}catch(r){if(!M(r))throw await w.sync(),r}return await w.sync(),{results:F.results.map(r=>k.revive(r)),stats:s}}async function R(P){let l;try{const r=new O;l=await Q.$provideTextSearchResults(F.lastHandle,0,P,r.token)}catch(r){if(!M(r))throw await w.sync(),r}return await w.sync(),{results:A(F.results),stats:l}}setup(()=>{w=new W,F=new G;const P=new B;w.set(L.MainThreadSearch,F),b={},Q=T.add(new class extends K{constructor(){super(w,new class extends U(){remote={isRemote:!1,authority:void 0,connectionData:null}},new D(null),new class extends U(){async getConfigProvider(){return{onDidChangeConfiguration(l){},getConfiguration(){return{get(){},has(){return!1},inspect(){},async update(){}}}}}},P),this._pfs=b}createTextSearchManager(l,s){return new z(l,s,this._pfs)}})}),teardown(()=>w.sync());const t=k.file("/foo/bar1"),y=k.file("/foo/bar2"),I="fancy",C=k.from({scheme:I,path:"/project/folder1"});suite("File:",()=>{function P(s=""){return{type:p.File,filePattern:s,folderQueries:[{folder:t}]}}function l(s,r){const i=e=>e.sort().map(o=>o.toString());c.deepStrictEqual(i(s),i(r))}test("no results",async()=>{await S({provideFileSearchResults(i,e,o){return Promise.resolve(null)}});const{results:s,stats:r}=await x(P());c(!r.limitHit),c(!s.length)}),test("simple results",async()=>{const s=[h(t,"file1.ts"),h(t,"file2.ts"),h(t,"subfolder/file3.ts")];await S({provideFileSearchResults(e,o,a){return Promise.resolve(s)}});const{results:r,stats:i}=await x(P());c(!i.limitHit),c.strictEqual(r.length,3),l(r,s)}),test("Search canceled",async()=>{let s=!1;await S({provideFileSearchResults(i,e,o){return new Promise((a,n)=>{function f(){s=!0,a([h(e.folder,"file1.ts")])}o.isCancellationRequested?f():T.add(o.onCancellationRequested(()=>f()))})}});const{results:r}=await x(P(),!0);c(s),c(!r.length)}),test("session cancellation should work",async()=>{let s=0;const r=[];await S({provideFileSearchResults(i,e,o){return r.push(e.session?.onCancellationRequested(()=>{s++})),Promise.resolve([])}}),await x({...P(),cacheKey:"1"},!0),await x({...P(),cacheKey:"2"},!0),Q.$clearCache("1"),c.strictEqual(s,1),r.forEach(i=>i?.dispose())}),test("provider returns null",async()=>{await S({provideFileSearchResults(s,r,i){return null}});try{await x(P()),c(!1,"Expected to fail")}catch{}}),test("all provider calls get global include/excludes",async()=>{await S({provideFileSearchResults(r,i,e){return c(i.excludes.length===2&&i.includes.length===2,"Missing global include/excludes"),Promise.resolve(null)}});const s={type:p.File,filePattern:"",includePattern:{foo:!0,bar:!0},excludePattern:{something:!0,else:!0},folderQueries:[{folder:t},{folder:y}]};await x(s)}),test("global/local include/excludes combined",async()=>{await S({provideFileSearchResults(r,i,e){return i.folder.toString()===t.toString()?(c.deepStrictEqual(i.includes.sort(),["*.ts","foo"]),c.deepStrictEqual(i.excludes.sort(),["*.js","bar"])):(c.deepStrictEqual(i.includes.sort(),["*.ts"]),c.deepStrictEqual(i.excludes.sort(),["*.js"])),Promise.resolve(null)}});const s={type:p.File,filePattern:"",includePattern:{"*.ts":!0},excludePattern:{"*.js":!0},folderQueries:[{folder:t,includePattern:{foo:!0},excludePattern:[{pattern:{bar:!0}}]},{folder:y}]};await x(s)}),test("include/excludes resolved correctly",async()=>{await S({provideFileSearchResults(r,i,e){return c.deepStrictEqual(i.includes.sort(),["*.jsx","*.ts"]),c.deepStrictEqual(i.excludes.sort(),[]),Promise.resolve(null)}});const s={type:p.File,filePattern:"",includePattern:{"*.ts":!0,"*.jsx":!1},excludePattern:{"*.js":!0,"*.tsx":!1},folderQueries:[{folder:t,includePattern:{"*.jsx":!0},excludePattern:[{pattern:{"*.js":!1}}]}]};await x(s)}),test("basic sibling exclude clause",async()=>{const s=["file1.ts","file1.js"];await S({provideFileSearchResults(e,o,a){return Promise.resolve(s.map(n=>h(o.folder,n)))}});const r={type:p.File,filePattern:"",excludePattern:{"*.js":{when:"$(basename).ts"}},folderQueries:[{folder:t}]},{results:i}=await x(r);l(i,[h(t,"file1.ts")])}),test("include, sibling exclude, and subfolder",async()=>{const s=["foo/file1.ts","foo/file1.js"];await S({provideFileSearchResults(e,o,a){return Promise.resolve(s.map(n=>h(o.folder,n)))}});const r={type:p.File,filePattern:"",includePattern:{"**/*.ts":!0},excludePattern:{"*.js":{when:"$(basename).ts"}},folderQueries:[{folder:t}]},{results:i}=await x(r);l(i,[h(t,"foo/file1.ts")])}),test("multiroot sibling exclude clause",async()=>{await S({provideFileSearchResults(i,e,o){let a;return e.folder.fsPath===t.fsPath?a=["folder/fileA.scss","folder/fileA.css","folder/file2.css"].map(n=>h(t,n)):a=["fileB.ts","fileB.js","file3.js"].map(n=>h(y,n)),Promise.resolve(a)}});const s={type:p.File,filePattern:"",excludePattern:{"*.js":{when:"$(basename).ts"},"*.css":!0},folderQueries:[{folder:t,excludePattern:[{pattern:{"folder/*.css":{when:"$(basename).scss"}}}]},{folder:y,excludePattern:[{pattern:{"*.js":!1}}]}]},{results:r}=await x(s);l(r,[h(t,"folder/fileA.scss"),h(t,"folder/file2.css"),h(y,"fileB.ts"),h(y,"fileB.js"),h(y,"file3.js")])}),test("max results = 1",async()=>{const s=[h(t,"file1.ts"),h(t,"file2.ts"),h(t,"file3.ts")];let r=!1;await S({provideFileSearchResults(a,n,f){return T.add(f.onCancellationRequested(()=>r=!0)),Promise.resolve(s)}});const i={type:p.File,filePattern:"",maxResults:1,folderQueries:[{folder:t}]},{results:e,stats:o}=await x(i);c(o.limitHit,"Expected to return limitHit"),c.strictEqual(e.length,1),l(e,s.slice(0,1)),c(r,"Expected to be canceled when hitting limit")}),test("max results = 2",async()=>{const s=[h(t,"file1.ts"),h(t,"file2.ts"),h(t,"file3.ts")];let r=!1;await S({provideFileSearchResults(a,n,f){return T.add(f.onCancellationRequested(()=>r=!0)),Promise.resolve(s)}});const i={type:p.File,filePattern:"",maxResults:2,folderQueries:[{folder:t}]},{results:e,stats:o}=await x(i);c(o.limitHit,"Expected to return limitHit"),c.strictEqual(e.length,2),l(e,s.slice(0,2)),c(r,"Expected to be canceled when hitting limit")}),test("provider returns maxResults exactly",async()=>{const s=[h(t,"file1.ts"),h(t,"file2.ts")];let r=!1;await S({provideFileSearchResults(a,n,f){return T.add(f.onCancellationRequested(()=>r=!0)),Promise.resolve(s)}});const i={type:p.File,filePattern:"",maxResults:2,folderQueries:[{folder:t}]},{results:e,stats:o}=await x(i);c(!o.limitHit,"Expected not to return limitHit"),c.strictEqual(e.length,2),l(e,s),c(!r,"Expected not to be canceled when just reaching limit")}),test("multiroot max results",async()=>{let s=0;await S({async provideFileSearchResults(e,o,a){return T.add(a.onCancellationRequested(()=>s++)),await new Promise(n=>process.nextTick(n)),["file1.ts","file2.ts","file3.ts"].map(n=>h(o.folder,n))}});const r={type:p.File,filePattern:"",maxResults:2,folderQueries:[{folder:t},{folder:y}]},{results:i}=await x(r);c.strictEqual(i.length,2),c.strictEqual(s,2,"Expected all invocations to be canceled when hitting limit")}),test("works with non-file schemes",async()=>{const s=[h(C,"file1.ts"),h(C,"file2.ts"),h(C,"subfolder/file3.ts")];await S({provideFileSearchResults(e,o,a){return Promise.resolve(s)}},I);const r={type:p.File,filePattern:"",folderQueries:[{folder:C}]},{results:i}=await x(r);l(i,s)}),test("if onlyFileScheme is set, do not call custom schemes",async()=>{let s=!1;await S({provideFileSearchResults(i,e,o){return s=!0,Promise.resolve([])}},I);const r={type:p.File,filePattern:"",folderQueries:[]};await x(r),c(!s)})}),suite("Text:",()=>{function P(e){return{matches:[new E(0,0,0,e.length)],text:e}}function l(e,o){return{preview:P("foo"),ranges:[new E(0,0,0,3)],uri:h(e,o)}}function s(e){return{type:p.Text,contentPattern:r(e),folderQueries:[{folder:t}]}}function r(e){return{pattern:e}}function i(e,o){const a=[];for(const v of e)for(const d of v.results)_(d)?a.push({preview:{text:d.previewText,matches:j(d.rangeLocations.map(u=>u.preview),u=>new E(u.startLineNumber,u.startColumn,u.endLineNumber,u.endColumn))},ranges:j(d.rangeLocations.map(u=>u.source),u=>new E(u.startLineNumber,u.startColumn,u.endLineNumber,u.endColumn)),uri:v.resource}):a.push({text:d.text,lineNumber:d.lineNumber,uri:v.resource});const n=v=>`(${v.start.line}, ${v.start.character}), (${v.end.line}, ${v.end.character})`,f=v=>v.sort((d,u)=>{const g=d.uri.toString()+": "+(H(d)?d.preview.text:d.text);return(u.uri.toString()+": "+(H(u)?u.preview.text:u.text)).localeCompare(g)}).map(d=>H(d)?{uri:d.uri.toString(),range:j(d.ranges,n),preview:{text:d.preview.text,match:null}}:{uri:d.uri.toString(),text:d.text,lineNumber:d.lineNumber});return c.deepStrictEqual(f(a),f(o))}test("no results",async()=>{await m({provideTextSearchResults(a,n,f,v){return Promise.resolve(null)}});const{results:e,stats:o}=await R(s("foo"));c(!o.limitHit),c(!e.length)}),test("basic results",async()=>{const e=[l(t,"file1.ts"),l(t,"file2.ts")];await m({provideTextSearchResults(n,f,v,d){return e.forEach(u=>v.report(u)),Promise.resolve(null)}});const{results:o,stats:a}=await R(s("foo"));c(!a.limitHit),i(o,e)}),test("all provider calls get global include/excludes",async()=>{await m({provideTextSearchResults(o,a,n,f){return c.strictEqual(a.includes.length,1),c.strictEqual(a.excludes.length,1),Promise.resolve(null)}});const e={type:p.Text,contentPattern:r("foo"),includePattern:{"*.ts":!0},excludePattern:{"*.js":!0},folderQueries:[{folder:t},{folder:y}]};await R(e)}),test("global/local include/excludes combined",async()=>{await m({provideTextSearchResults(o,a,n,f){return a.folder.toString()===t.toString()?(c.deepStrictEqual(a.includes.sort(),["*.ts","foo"]),c.deepStrictEqual(a.excludes.sort(),["*.js","bar"])):(c.deepStrictEqual(a.includes.sort(),["*.ts"]),c.deepStrictEqual(a.excludes.sort(),["*.js"])),Promise.resolve(null)}});const e={type:p.Text,contentPattern:r("foo"),includePattern:{"*.ts":!0},excludePattern:{"*.js":!0},folderQueries:[{folder:t,includePattern:{foo:!0},excludePattern:[{pattern:{bar:!0}}]},{folder:y}]};await R(e)}),test("include/excludes resolved correctly",async()=>{await m({provideTextSearchResults(o,a,n,f){return c.deepStrictEqual(a.includes.sort(),["*.jsx","*.ts"]),c.deepStrictEqual(a.excludes.sort(),[]),Promise.resolve(null)}});const e={type:p.Text,contentPattern:r("foo"),includePattern:{"*.ts":!0,"*.jsx":!1},excludePattern:{"*.js":!0,"*.tsx":!1},folderQueries:[{folder:t,includePattern:{"*.jsx":!0},excludePattern:[{pattern:{"*.js":!1}}]}]};await R(e)}),test("provider fail",async()=>{await m({provideTextSearchResults(e,o,a,n){throw new Error("Provider fail")}});try{await R(s("foo")),c(!1,"Expected to fail")}catch{}}),test("basic sibling clause",async()=>{b.Promises={readdir:n=>n===t.fsPath?Promise.resolve(["file1.js","file1.ts"]):Promise.reject(new Error("Wrong path"))};const e=[l(t,"file1.js"),l(t,"file1.ts")];await m({provideTextSearchResults(n,f,v,d){return e.forEach(u=>v.report(u)),Promise.resolve(null)}});const o={type:p.Text,contentPattern:r("foo"),excludePattern:{"*.js":{when:"$(basename).ts"}},folderQueries:[{folder:t}]},{results:a}=await R(o);i(a,e.slice(1))}),test("multiroot sibling clause",async()=>{b.Promises={readdir:a=>a===h(t,"folder").fsPath?Promise.resolve(["fileA.scss","fileA.css","file2.css"]):a===y.fsPath?Promise.resolve(["fileB.ts","fileB.js","file3.js"]):Promise.reject(new Error("Wrong path"))},await m({provideTextSearchResults(a,n,f,v){let d;return n.folder.fsPath===t.fsPath?d=[l(t,"folder/fileA.scss"),l(t,"folder/fileA.css"),l(t,"folder/file2.css")]:d=[l(y,"fileB.ts"),l(y,"fileB.js"),l(y,"file3.js")],d.forEach(u=>f.report(u)),Promise.resolve(null)}});const e={type:p.Text,contentPattern:r("foo"),excludePattern:{"*.js":{when:"$(basename).ts"},"*.css":!0},folderQueries:[{folder:t,excludePattern:[{pattern:{"folder/*.css":{when:"$(basename).scss"}}}]},{folder:y,excludePattern:[{pattern:{"*.js":!1}}]}]},{results:o}=await R(e);i(o,[l(t,"folder/fileA.scss"),l(t,"folder/file2.css"),l(y,"fileB.ts"),l(y,"fileB.js"),l(y,"file3.js")])}),test("include pattern applied",async()=>{const e=[l(t,"file1.js"),l(t,"file1.ts")];await m({provideTextSearchResults(n,f,v,d){return e.forEach(u=>v.report(u)),Promise.resolve(null)}});const o={type:p.Text,contentPattern:r("foo"),includePattern:{"*.ts":!0},folderQueries:[{folder:t}]},{results:a}=await R(o);i(a,e.slice(1))}),test("max results = 1",async()=>{const e=[l(t,"file1.ts"),l(t,"file2.ts")];let o=!1;await m({provideTextSearchResults(v,d,u,g){return T.add(g.onCancellationRequested(()=>o=!0)),e.forEach(q=>u.report(q)),Promise.resolve(null)}});const a={type:p.Text,contentPattern:r("foo"),maxResults:1,folderQueries:[{folder:t}]},{results:n,stats:f}=await R(a);c(f.limitHit,"Expected to return limitHit"),i(n,e.slice(0,1)),c(o,"Expected to be canceled")}),test("max results = 2",async()=>{const e=[l(t,"file1.ts"),l(t,"file2.ts"),l(t,"file3.ts")];let o=!1;await m({provideTextSearchResults(v,d,u,g){return T.add(g.onCancellationRequested(()=>o=!0)),e.forEach(q=>u.report(q)),Promise.resolve(null)}});const a={type:p.Text,contentPattern:r("foo"),maxResults:2,folderQueries:[{folder:t}]},{results:n,stats:f}=await R(a);c(f.limitHit,"Expected to return limitHit"),i(n,e.slice(0,2)),c(o,"Expected to be canceled")}),test("provider returns maxResults exactly",async()=>{const e=[l(t,"file1.ts"),l(t,"file2.ts")];let o=!1;await m({provideTextSearchResults(v,d,u,g){return T.add(g.onCancellationRequested(()=>o=!0)),e.forEach(q=>u.report(q)),Promise.resolve(null)}});const a={type:p.Text,contentPattern:r("foo"),maxResults:2,folderQueries:[{folder:t}]},{results:n,stats:f}=await R(a);c(!f.limitHit,"Expected not to return limitHit"),i(n,e),c(!o,"Expected not to be canceled")}),test("provider returns early with limitHit",async()=>{const e=[l(t,"file1.ts"),l(t,"file2.ts"),l(t,"file3.ts")];await m({provideTextSearchResults(f,v,d,u){return e.forEach(g=>d.report(g)),Promise.resolve({limitHit:!0})}});const o={type:p.Text,contentPattern:r("foo"),maxResults:1e3,folderQueries:[{folder:t}]},{results:a,stats:n}=await R(o);c(n.limitHit,"Expected to return limitHit"),i(a,e)}),test("multiroot max results",async()=>{let e=0;await m({async provideTextSearchResults(n,f,v,d){return T.add(d.onCancellationRequested(()=>e++)),await new Promise(u=>process.nextTick(u)),["file1.ts","file2.ts","file3.ts"].forEach(u=>v.report(l(f.folder,u))),null}});const o={type:p.Text,contentPattern:r("foo"),maxResults:2,folderQueries:[{folder:t},{folder:y}]},{results:a}=await R(o);c.strictEqual(a.length,2),c.strictEqual(e,2)}),test("works with non-file schemes",async()=>{const e=[l(C,"file1.ts"),l(C,"file2.ts"),l(C,"file3.ts")];await m({provideTextSearchResults(n,f,v,d){return e.forEach(u=>v.report(u)),Promise.resolve(null)}},I);const o={type:p.Text,contentPattern:r("foo"),folderQueries:[{folder:C}]},{results:a}=await R(o);i(a,e)})})});
