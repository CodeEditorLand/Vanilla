var C=Object.defineProperty;var k=Object.getOwnPropertyDescriptor;var v=(f,l,t,i)=>{for(var n=i>1?void 0:i?k(l,t):l,o=f.length-1,e;o>=0;o--)(e=f[o])&&(n=(i?e(l,t,n):e(n))||n);return i&&n&&C(l,t,n),n},d=(f,l)=>(t,i)=>l(t,i,f);import{app as p}from"electron";import{coalesce as P}from"../../../base/common/arrays.js";import{ThrottledDelayer as D}from"../../../base/common/async.js";import{Emitter as A}from"../../../base/common/event.js";import{normalizeDriveLetter as N,splitRecentLabel as F}from"../../../base/common/labels.js";import{Disposable as W}from"../../../base/common/lifecycle.js";import{Schemas as h}from"../../../base/common/network.js";import{isMacintosh as y,isWindows as I}from"../../../base/common/platform.js";import{basename as R,extUriBiasedIgnorePathCase as m,originalFSPath as w}from"../../../base/common/resources.js";import{URI as O}from"../../../base/common/uri.js";import{Promises as _}from"../../../base/node/pfs.js";import{localize as c}from"../../../nls.js";import{createDecorator as U}from"../../instantiation/common/instantiation.js";import{ILifecycleMainService as J,LifecycleMainPhase as b}from"../../lifecycle/electron-main/lifecycleMainService.js";import{ILogService as x}from"../../log/common/log.js";import{StorageScope as M,StorageTarget as K}from"../../storage/common/storage.js";import{IApplicationStorageMainService as X}from"../../storage/electron-main/storageMainService.js";import{isRecentFile as B,isRecentFolder as E,isRecentWorkspace as S,restoreRecentlyOpened as G,toStoreData as Y}from"../common/workspaces.js";import{WORKSPACE_EXTENSION as T}from"../../workspace/common/workspace.js";import{IWorkspacesManagementMainService as $}from"./workspacesManagementMainService.js";import{ResourceMap as L}from"../../../base/common/map.js";import{IDialogMainService as q}from"../../dialogs/electron-main/dialogMainService.js";const Me=U("workspacesHistoryMainService");let s=class extends W{constructor(t,i,n,o,e){super();this.logService=t;this.workspacesManagementMainService=i;this.lifecycleMainService=n;this.applicationStorageMainService=o;this.dialogMainService=e;this.registerListeners()}static MAX_TOTAL_RECENT_ENTRIES=500;static RECENTLY_OPENED_STORAGE_KEY="history.recentlyOpenedPathsList";_onDidChangeRecentlyOpened=this._register(new A);onDidChangeRecentlyOpened=this._onDidChangeRecentlyOpened.event;registerListeners(){this.lifecycleMainService.when(b.Eventually).then(()=>this.handleWindowsJumpList()),this._register(this.workspacesManagementMainService.onDidEnterWorkspace(t=>this.addRecentlyOpened([{workspace:t.workspace,remoteAuthority:t.window.remoteAuthority}])))}async addRecentlyOpened(t){let i=[],n=[];for(const e of t)if(S(e))!this.workspacesManagementMainService.isUntitledWorkspace(e.workspace)&&!this.containsWorkspace(i,e.workspace)&&i.push(e);else if(E(e))this.containsFolder(i,e.folderUri)||i.push(e);else{const r=this.containsFile(n,e.fileUri),a=e.fileUri.scheme===h.file&&s.COMMON_FILES_FILTER.indexOf(R(e.fileUri))>=0;!r&&!a&&(n.push(e),I&&e.fileUri.scheme===h.file&&p.addRecentDocument(e.fileUri.fsPath))}const o=await this.mergeEntriesFromStorage({workspaces:i,files:n});i=o.workspaces,n=o.files,i.length>s.MAX_TOTAL_RECENT_ENTRIES&&(i.length=s.MAX_TOTAL_RECENT_ENTRIES),n.length>s.MAX_TOTAL_RECENT_ENTRIES&&(n.length=s.MAX_TOTAL_RECENT_ENTRIES),await this.saveRecentlyOpened({workspaces:i,files:n}),this._onDidChangeRecentlyOpened.fire(),y&&this.macOSRecentDocumentsUpdater.trigger(()=>this.updateMacOSRecentDocuments())}async removeRecentlyOpened(t){const i=r=>{const a=this.location(r);for(const g of t)if(m.isEqual(g,a))return!1;return!0},n=await this.getRecentlyOpened(),o=n.workspaces.filter(i),e=n.files.filter(i);(o.length!==n.workspaces.length||e.length!==n.files.length)&&(await this.saveRecentlyOpened({files:e,workspaces:o}),this._onDidChangeRecentlyOpened.fire(),y&&this.macOSRecentDocumentsUpdater.trigger(()=>this.updateMacOSRecentDocuments()))}async clearRecentlyOpened(t){if(t?.confirm){const{response:i}=await this.dialogMainService.showMessageBox({type:"warning",buttons:[c({key:"clearButtonLabel",comment:["&& denotes a mnemonic"]},"&&Clear"),c({key:"cancel",comment:["&& denotes a mnemonic"]},"&&Cancel")],message:c("confirmClearRecentsMessage","Do you want to clear all recently opened files and workspaces?"),detail:c("confirmClearDetail","This action is irreversible!"),cancelId:1});if(i!==0)return}await this.saveRecentlyOpened({workspaces:[],files:[]}),p.clearRecentDocuments(),this._onDidChangeRecentlyOpened.fire()}async getRecentlyOpened(){return this.mergeEntriesFromStorage()}async mergeEntriesFromStorage(t){const i=new L(e=>m.getComparisonKey(e));if(t?.workspaces)for(const e of t.workspaces)i.set(this.location(e),e);const n=new L(e=>m.getComparisonKey(e));if(t?.files)for(const e of t.files)n.set(this.location(e),e);const o=await this.getRecentlyOpenedFromStorage();for(const e of o.workspaces){const r=i.get(this.location(e));r?r.label=r.label??e.label:i.set(this.location(e),e)}for(const e of o.files){const r=n.get(this.location(e));r?r.label=r.label??e.label:n.set(this.location(e),e)}return{workspaces:[...i.values()],files:[...n.values()]}}async getRecentlyOpenedFromStorage(){await this.applicationStorageMainService.whenReady;let t;const i=this.applicationStorageMainService.get(s.RECENTLY_OPENED_STORAGE_KEY,M.APPLICATION);if(typeof i=="string")try{t=JSON.parse(i)}catch(n){this.logService.error("Unexpected error parsing opened paths list",n)}return G(t,this.logService)}async saveRecentlyOpened(t){await this.applicationStorageMainService.whenReady,this.applicationStorageMainService.store(s.RECENTLY_OPENED_STORAGE_KEY,JSON.stringify(Y(t)),M.APPLICATION,K.MACHINE)}location(t){return E(t)?t.folderUri:B(t)?t.fileUri:t.workspace.configPath}containsWorkspace(t,i){return!!t.find(n=>S(n)&&n.workspace.id===i.id)}containsFolder(t,i){return!!t.find(n=>E(n)&&m.isEqual(n.folderUri,i))}containsFile(t,i){return!!t.find(n=>m.isEqual(n.fileUri,i))}static MAX_MACOS_DOCK_RECENT_WORKSPACES=7;static MAX_MACOS_DOCK_RECENT_ENTRIES_TOTAL=10;static MAX_WINDOWS_JUMP_LIST_ENTRIES=7;static COMMON_FILES_FILTER=["COMMIT_EDITMSG","MERGE_MSG","git-rebase-todo"];macOSRecentDocumentsUpdater=this._register(new D(800));async handleWindowsJumpList(){I&&(await this.updateWindowsJumpList(),this._register(this.onDidChangeRecentlyOpened(()=>this.updateWindowsJumpList())))}async updateWindowsJumpList(){if(!I)return;const t=[];if(t.push({type:"tasks",items:[{type:"task",title:c("newWindow","New Window"),description:c("newWindowDesc","Opens a new window"),program:process.execPath,args:"-n",iconPath:process.execPath,iconIndex:0}]}),(await this.getRecentlyOpened()).workspaces.length>0){const i=[];for(const e of p.getJumpListSettings().removedItems){const r=e.args;if(r){const a=/^--(folder|file)-uri\s+"([^"]+)"$/.exec(r);a&&i.push(O.parse(a[2]))}}await this.removeRecentlyOpened(i);let n=!1;const o=P((await this.getRecentlyOpened()).workspaces.slice(0,s.MAX_WINDOWS_JUMP_LIST_ENTRIES).map(e=>{const r=S(e)?e.workspace:e.folderUri,{title:a,description:g}=this.getWindowsJumpListLabel(r,e.label);let u;return O.isUri(r)?u=`--folder-uri "${r.toString()}"`:(n=!0,u=`--file-uri "${r.configPath.toString()}"`),{type:"task",title:a.substr(0,255),description:g.substr(0,255),program:process.execPath,args:u,iconPath:"explorer.exe",iconIndex:0}}));o.length>0&&t.push({type:"custom",name:n?c("recentFoldersAndWorkspaces","Recent Folders & Workspaces"):c("recentFolders","Recent Folders"),items:o})}t.push({type:"recent"});try{const i=p.setJumpList(t);i&&i!=="ok"&&this.logService.warn(`updateWindowsJumpList#setJumpList unexpected result: ${i}`)}catch(i){this.logService.warn("updateWindowsJumpList#setJumpList",i)}}getWindowsJumpListLabel(t,i){if(i)return{title:F(i).name,description:i};if(O.isUri(t))return{title:R(t),description:this.renderJumpListPathDescription(t)};if(this.workspacesManagementMainService.isUntitledWorkspace(t))return{title:c("untitledWorkspace","Untitled (Workspace)"),description:""};let n=R(t.configPath);return n.endsWith(T)&&(n=n.substr(0,n.length-T.length-1)),{title:c("workspaceName","{0} (Workspace)",n),description:this.renderJumpListPathDescription(t.configPath)}}renderJumpListPathDescription(t){return t.scheme==="file"?N(t.fsPath):t.toString()}async updateMacOSRecentDocuments(){if(!y)return;p.clearRecentDocuments();const t=await this.getRecentlyOpened(),i=[];let n=0;for(let e=0;e<t.workspaces.length&&n<s.MAX_MACOS_DOCK_RECENT_WORKSPACES;e++){const r=this.location(t.workspaces[e]);if(r.scheme===h.file){const a=w(r);await _.exists(a)&&(i.push(a),n++)}}const o=[];for(let e=0;e<t.files.length&&n<s.MAX_MACOS_DOCK_RECENT_ENTRIES_TOTAL;e++){const r=this.location(t.files[e]);if(r.scheme===h.file){const a=w(r);if(s.COMMON_FILES_FILTER.includes(R(r))||i.includes(a))continue;await _.exists(a)&&(o.push(a),n++)}}o.reverse().forEach(e=>p.addRecentDocument(e)),i.reverse().forEach(e=>p.addRecentDocument(e))}};s=v([d(0,x),d(1,$),d(2,J),d(3,X),d(4,q)],s);export{Me as IWorkspacesHistoryMainService,s as WorkspacesHistoryMainService};
