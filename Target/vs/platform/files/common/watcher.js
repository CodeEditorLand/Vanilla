import"../../../base/common/event.js";import{GLOBSTAR as l,parse as u}from"../../../base/common/glob.js";import{Disposable as d,DisposableStore as p,MutableDisposable as g}from"../../../base/common/lifecycle.js";import{isAbsolute as v}from"../../../base/common/path.js";import{isLinux as h}from"../../../base/common/platform.js";import{URI as f}from"../../../base/common/uri.js";import{FileChangeFilter as n,FileChangeType as a,isParent as I}from"./files.js";function T(s){return typeof s.correlationId=="number"}function A(s){return s.recursive===!0}class c extends d{constructor(t,r,i,o){super();this.onFileChanges=t;this.onLogMessage=r;this.verboseLogging=i;this.options=o}static MAX_RESTARTS=5;watcher;watcherDisposables=this._register(new g);requests=void 0;restartCounter=0;init(){const t=new p;this.watcherDisposables.value=t,this.watcher=this.createWatcher(t),this.watcher.setVerboseLogging(this.verboseLogging),t.add(this.watcher.onDidChangeFile(r=>this.onFileChanges(r))),t.add(this.watcher.onDidLogMessage(r=>this.onLogMessage(r))),t.add(this.watcher.onDidError(r=>this.onError(r.error,r.request)))}onError(t,r){this.canRestart(t,r)?this.restartCounter<c.MAX_RESTARTS&&this.requests?(this.error(`restarting watcher after unexpected error: ${t}`),this.restart(this.requests)):this.error(`gave up attempting to restart watcher after unexpected error: ${t}`):this.error(t)}canRestart(t,r){return!(!this.options.restartOnError||r||t.indexOf("No space left on device")!==-1||t.indexOf("EMFILE")!==-1)}restart(t){this.restartCounter++,this.init(),this.watch(t)}async watch(t){this.requests=t,await this.watcher?.watch(t)}async setVerboseLogging(t){this.verboseLogging=t,await this.watcher?.setVerboseLogging(t)}error(t){this.onLogMessage({type:"error",message:`[File Watcher (${this.options.type})] ${t}`})}trace(t){this.onLogMessage({type:"trace",message:`[File Watcher (${this.options.type})] ${t}`})}dispose(){return this.watcher=void 0,super.dispose()}}class U extends c{constructor(e,t,r){super(e,t,r,{type:"node.js",restartOnError:!1})}}class M extends c{constructor(e,t,r){super(e,t,r,{type:"universal",restartOnError:!0})}}function S(s){return s.map(e=>({type:e.type,resource:f.revive(e.resource),cId:e.cId}))}function O(s){const e=new y;for(const t of s)e.processEvent(t);return e.coalesce()}function D(s,e){return typeof e=="string"&&!e.startsWith(l)&&!v(e)?{base:s,pattern:e}:e}function N(s,e){const t=[];for(const r of e)t.push(u(D(s,r)));return t}class y{coalesced=new Set;mapPathToChange=new Map;toKey(e){return h?e.resource.fsPath:e.resource.fsPath.toLowerCase()}processEvent(e){const t=this.mapPathToChange.get(this.toKey(e));let r=!1;if(t){const i=t.type,o=e.type;t.resource.fsPath!==e.resource.fsPath&&(e.type===a.DELETED||e.type===a.ADDED)?r=!0:i===a.ADDED&&o===a.DELETED?(this.mapPathToChange.delete(this.toKey(e)),this.coalesced.delete(t)):i===a.DELETED&&o===a.ADDED?t.type=a.UPDATED:i===a.ADDED&&o===a.UPDATED||(t.type=o)}else r=!0;r&&(this.coalesced.add(e),this.mapPathToChange.set(this.toKey(e),e))}coalesce(){const e=[],t=[];return Array.from(this.coalesced).filter(r=>r.type!==a.DELETED?(e.push(r),!1):!0).sort((r,i)=>r.resource.fsPath.length-i.resource.fsPath.length).filter(r=>t.some(i=>I(r.resource.fsPath,i,!h))?!1:(t.push(r.resource.fsPath),!0)).concat(e)}}function $(s,e){if(typeof e=="number")switch(s.type){case a.ADDED:return(e&n.ADDED)===0;case a.DELETED:return(e&n.DELETED)===0;case a.UPDATED:return(e&n.UPDATED)===0}return!1}function K(s){if(typeof s=="number"){const e=[];return s&n.ADDED&&e.push("Added"),s&n.DELETED&&e.push("Deleted"),s&n.UPDATED&&e.push("Updated"),e.length===0?"<all>":`[${e.join(", ")}]`}return"<none>"}export{U as AbstractNonRecursiveWatcherClient,M as AbstractUniversalWatcherClient,c as AbstractWatcherClient,O as coalesceEvents,$ as isFiltered,A as isRecursiveWatchRequest,T as isWatchRequestWithCorrelation,D as normalizeWatcherPattern,N as parseWatcherPatterns,K as requestFilterToString,S as reviveFileChanges};
