import o from"assert";import{realpathSync as P,promises as m}from"fs";import{tmpdir as ie}from"os";import{timeout as R}from"../../../../base/common/async.js";import{dirname as $,join as a}from"../../../../base/common/path.js";import{isLinux as _,isMacintosh as S,isWindows as W}from"../../../../base/common/platform.js";import{Promises as d,RimRafMode as L}from"../../../../base/node/pfs.js";import{getRandomTestPath as re}from"../../../../base/test/node/testUtils.js";import{FileChangeFilter as K,FileChangeType as s}from"../../common/files.js";import{ParcelWatcher as se}from"../../node/watcher/parcel/parcelWatcher.js";import"../../common/watcher.js";import{getDriveLetter as ne}from"../../../../base/common/extpath.js";import{ltrim as le}from"../../../../base/common/strings.js";import{FileAccess as z}from"../../../../base/common/network.js";import{extUriBiasedIgnorePathCase as ce}from"../../../../base/common/resources.js";import{URI as j}from"../../../../base/common/uri.js";import{addUNCHostToAllowlist as oe}from"../../../../base/node/unc.js";import{Emitter as ue,Event as y}from"../../../../base/common/event.js";import{DisposableStore as de}from"../../../../base/common/lifecycle.js";class we extends se{suspendedWatchRequestPollingInterval=100;_onDidWatch=this._register(new ue);onDidWatch=this._onDidWatch.event;onWatchFail=this._onDidWatchFail.event;testRemoveDuplicateRequests(e,q=[]){const U=e.map(T=>({path:T,excludes:q,recursive:!0}));return this.removeDuplicateRequests(U,!1).map(T=>T.path)}getUpdateWatchersDelay(){return 0}async doWatch(e){await super.doWatch(e),await this.whenReady(),this._onDidWatch.fire()}async whenReady(){for(const e of this.watchers)await e.ready}}suite.skip("File Watcher (parcel)",()=>{let t,e,q=!1;function U(i){q=i,e?.setVerboseLogging(i)}U(!1),setup(async()=>{e=new we,e.setVerboseLogging(q),e.onDidLogMessage(r=>{q&&console.log(`[recursive watcher test message] ${r.message}`)}),e.onDidError(r=>{q&&console.log(`[recursive watcher test error] ${r.error}`)}),t=j.file(re(ie(),"vsctests","filewatcher")).fsPath;const i=z.asFileUri("vs/platform/files/test/node/fixtures/service").fsPath;await d.copy(i,t,{preserveSymlinks:!1})}),teardown(async()=>{const i=e.watchers.size;let r=0;for(const l of e.watchers)y.once(l.onDidStop)(()=>{l.stopped&&r++});return await e.stop(),o.strictEqual(r,i,"All watchers must be stopped before the test ends"),e.dispose(),d.rm(t).catch(l=>console.error(l))});function T(i){switch(i){case s.ADDED:return"added";case s.DELETED:return"deleted";default:return"changed"}}async function n(i,r,l,c,h,w){q&&console.log(`Awaiting change type '${T(l)}' on file '${r}'`);const u=await new Promise((E,k)=>{let F=0;const f=i.onDidChangeFile(b=>{for(const g of b)if(ce.isEqual(g.resource,j.file(r))&&g.type===l&&(h===null||g.cId===h)){if(F++,typeof w=="number"&&F<w)continue;f.dispose(),c?k(new Error(`Unexpected file event: ${c}`)):setImmediate(()=>E(b));break}})});return await R(1),u}function V(i,r){return q&&console.log(`Awaiting message of type ${r}`),new Promise(l=>{const c=i.onDidLogMessage(h=>{h.type===r&&(c.dispose(),l())})})}test("basics",async function(){const i={path:t,excludes:[],recursive:!0};await e.watch([i]),o.strictEqual(e.watchers.size,e.watchers.size);const r=Array.from(e.watchers)[0];o.strictEqual(i,r.request),o.strictEqual(r.failed,!1),o.strictEqual(r.stopped,!1);const l=new de,c=new Map,h=new Map,w=a(t,"deep","newFile.txt");l.add(r.subscribe(w,D=>c.set(D.resource.fsPath,D.type))),l.add(r.subscribe(w,D=>h.set(D.resource.fsPath,D.type))),o.strictEqual(r.include(w),!0),o.strictEqual(r.exclude(w),!1);let u=n(e,w,s.ADDED);await d.writeFile(w,"Hello World"),await u,o.strictEqual(c.get(w),s.ADDED),o.strictEqual(h.get(w),s.ADDED);const E=a(t,"deep","New Folder");l.add(r.subscribe(E,D=>c.set(D.resource.fsPath,D.type))),r.subscribe(E,D=>h.set(D.resource.fsPath,D.type)).dispose(),o.strictEqual(r.include(E),!0),o.strictEqual(r.exclude(E),!1),u=n(e,E,s.ADDED),await m.mkdir(E),await u,o.strictEqual(c.get(E),s.ADDED),o.strictEqual(h.has(E),!1);let F=a(t,"deep","renamedFile.txt");l.add(r.subscribe(F,D=>c.set(D.resource.fsPath,D.type))),u=Promise.all([n(e,w,s.DELETED),n(e,F,s.ADDED)]),await d.rename(w,F),await u,o.strictEqual(c.get(w),s.DELETED),o.strictEqual(c.get(F),s.ADDED);let f=a(t,"deep","Renamed Folder");l.add(r.subscribe(f,D=>c.set(D.resource.fsPath,D.type))),u=Promise.all([n(e,E,s.DELETED),n(e,f,s.ADDED)]),await d.rename(E,f),await u,o.strictEqual(c.get(E),s.DELETED),o.strictEqual(c.get(f),s.ADDED);const b=a(t,"deep","RenamedFile.txt");u=Promise.all([n(e,F,s.DELETED),n(e,b,s.ADDED)]),await d.rename(F,b),await u,F=b;const g=a(t,"deep","REnamed Folder");u=Promise.all([n(e,f,s.DELETED),n(e,g,s.ADDED)]),await d.rename(f,g),await u,f=g;const C=a(t,"movedFile.txt");u=Promise.all([n(e,F,s.DELETED),n(e,C,s.ADDED)]),await d.rename(F,C),await u;const I=a(t,"Moved Folder");u=Promise.all([n(e,f,s.DELETED),n(e,I,s.ADDED)]),await d.rename(f,I),await u;const v=a(t,"deep","copiedFile.txt");u=n(e,v,s.ADDED),await m.copyFile(C,v),await u;const x=a(t,"deep","Copied Folder");u=n(e,x,s.ADDED),await d.copy(I,x,{preserveSymlinks:!1}),await u,u=n(e,v,s.UPDATED),await d.writeFile(v,"Hello Change"),await u;const A=a(t,"deep","anotherNewFile.txt");u=n(e,A,s.ADDED),await d.writeFile(A,"Hello Another World"),await u,u=n(e,A,s.UPDATED,"unexpected-event-from-read-file"),await m.readFile(A),await Promise.race([R(100),u]),u=n(e,A,s.UPDATED,"unexpected-event-from-stat"),await m.stat(A),await Promise.race([R(100),u]),u=n(e,x,s.UPDATED,"unexpected-event-from-stat"),await m.stat(x),await Promise.race([R(100),u]),u=n(e,v,s.DELETED),l.add(r.subscribe(v,D=>c.set(D.resource.fsPath,D.type))),await m.unlink(v),await u,o.strictEqual(c.get(v),s.DELETED),u=n(e,x,s.DELETED),l.add(r.subscribe(x,D=>c.set(D.resource.fsPath,D.type))),await m.rmdir(x),await u,o.strictEqual(c.get(x),s.DELETED),l.dispose()}),(S?test.skip:test)("basics (atomic writes)",async function(){await e.watch([{path:t,excludes:[],recursive:!0}]);const i=a(t,"deep","conway.js"),r=n(e,i,s.UPDATED);await m.unlink(i),d.writeFile(i,"Hello Atomic World"),await r}),(_?test:test.skip)("basics (polling)",async function(){return await e.watch([{path:t,excludes:[],pollingInterval:100,recursive:!0}]),p(a(t,"deep","newFile.txt"))});async function p(i,r,l){let c=n(e,i,s.ADDED,void 0,r,l);await d.writeFile(i,"Hello World"),await c,c=n(e,i,s.UPDATED,void 0,r,l),await d.writeFile(i,"Hello Change"),await c,c=n(e,i,s.DELETED,void 0,r,l),await m.unlink(i),await c}test("multiple events",async function(){await e.watch([{path:t,excludes:[],recursive:!0}]),await m.mkdir(a(t,"deep-multiple"));const i=a(t,"newFile-1.txt"),r=a(t,"newFile-2.txt"),l=a(t,"newFile-3.txt"),c=a(t,"deep-multiple","newFile-1.txt"),h=a(t,"deep-multiple","newFile-2.txt"),w=a(t,"deep-multiple","newFile-3.txt"),u=n(e,i,s.ADDED),E=n(e,r,s.ADDED),k=n(e,l,s.ADDED),F=n(e,c,s.ADDED),f=n(e,h,s.ADDED),b=n(e,w,s.ADDED);await Promise.all([await d.writeFile(i,"Hello World 1"),await d.writeFile(r,"Hello World 2"),await d.writeFile(l,"Hello World 3"),await d.writeFile(c,"Hello World 4"),await d.writeFile(h,"Hello World 5"),await d.writeFile(w,"Hello World 6")]),await Promise.all([u,E,k,F,f,b]);const g=n(e,i,s.UPDATED),C=n(e,r,s.UPDATED),I=n(e,l,s.UPDATED),v=n(e,c,s.UPDATED),x=n(e,h,s.UPDATED),A=n(e,w,s.UPDATED);await Promise.all([await d.writeFile(i,"Hello Update 1"),await d.writeFile(r,"Hello Update 2"),await d.writeFile(l,"Hello Update 3"),await d.writeFile(c,"Hello Update 4"),await d.writeFile(h,"Hello Update 5"),await d.writeFile(w,"Hello Update 6")]),await Promise.all([g,C,I,v,x,A]);const D=n(e,a(t,"deep-multiple-copy","newFile-1.txt"),s.ADDED),B=n(e,a(t,"deep-multiple-copy","newFile-2.txt"),s.ADDED),G=n(e,a(t,"deep-multiple-copy","newFile-3.txt"),s.ADDED),J=n(e,a(t,"deep-multiple-copy"),s.ADDED);await d.copy(a(t,"deep-multiple"),a(t,"deep-multiple-copy"),{preserveSymlinks:!1}),await Promise.all([D,B,G,J]);const O=n(e,i,s.DELETED),Q=n(e,r,s.DELETED),X=n(e,l,s.DELETED),Y=n(e,c,s.DELETED),Z=n(e,h,s.DELETED),ee=n(e,w,s.DELETED);await Promise.all([await m.unlink(i),await m.unlink(r),await m.unlink(l),await m.unlink(c),await m.unlink(h),await m.unlink(w)]),await Promise.all([O,Q,X,Y,Z,ee]);const te=n(e,a(t,"deep-multiple"),s.DELETED),ae=n(e,a(t,"deep-multiple-copy"),s.DELETED);await Promise.all([d.rm(a(t,"deep-multiple"),L.UNLINK),d.rm(a(t,"deep-multiple-copy"),L.UNLINK)]),await Promise.all([te,ae])}),test("subsequent watch updates watchers (path)",async function(){await e.watch([{path:t,excludes:[a(P(t),"unrelated")],recursive:!0}]);let i=a(t,"deep","newFile.txt"),r=n(e,i,s.ADDED);await d.writeFile(i,"Hello World"),await r,await e.watch([{path:a(t,"deep"),excludes:[a(P(t),"unrelated")],recursive:!0}]),i=a(t,"deep","newFile2.txt"),r=n(e,i,s.ADDED),await d.writeFile(i,"Hello World"),await r,await e.watch([{path:a(t,"deep"),excludes:[P(t)],recursive:!0}]),await e.watch([{path:a(t,"deep"),excludes:[],recursive:!0}]),i=a(t,"deep","newFile3.txt"),r=n(e,i,s.ADDED),await d.writeFile(i,"Hello World"),await r}),test("invalid path does not crash watcher",async function(){return await e.watch([{path:t,excludes:[],recursive:!0},{path:a(t,"invalid-folder"),excludes:[],recursive:!0},{path:z.asFileUri("").fsPath,excludes:[],recursive:!0}]),p(a(t,"deep","newFile.txt"))}),test("subsequent watch updates watchers (excludes)",async function(){return await e.watch([{path:t,excludes:[P(t)],recursive:!0}]),await e.watch([{path:t,excludes:[],recursive:!0}]),p(a(t,"deep","newFile.txt"))}),test("subsequent watch updates watchers (includes)",async function(){return await e.watch([{path:t,excludes:[],includes:["nothing"],recursive:!0}]),await e.watch([{path:t,excludes:[],recursive:!0}]),p(a(t,"deep","newFile.txt"))}),test("includes are supported",async function(){return await e.watch([{path:t,excludes:[],includes:["**/deep/**"],recursive:!0}]),p(a(t,"deep","newFile.txt"))}),test("includes are supported (relative pattern explicit)",async function(){return await e.watch([{path:t,excludes:[],includes:[{base:t,pattern:"deep/newFile.txt"}],recursive:!0}]),p(a(t,"deep","newFile.txt"))}),test("includes are supported (relative pattern implicit)",async function(){return await e.watch([{path:t,excludes:[],includes:["deep/newFile.txt"],recursive:!0}]),p(a(t,"deep","newFile.txt"))}),test("excludes are supported (path)",async function(){return H([a(P(t),"deep")])}),test("excludes are supported (glob)",function(){return H(["deep/**"])});async function H(i){await e.watch([{path:t,excludes:i,recursive:!0}]);const r=a(t,"deep","newFile.txt"),l=n(e,r,s.ADDED);await d.writeFile(r,"Hello World"),await Promise.any([R(500).then(()=>!0),l.then(()=>!1)])||o.fail("Unexpected change event")}(W?test.skip:test)("symlink support (root)",async function(){const i=a(t,"deep-linked"),r=a(t,"deep");return await m.symlink(r,i),await e.watch([{path:i,excludes:[],recursive:!0}]),p(a(i,"newFile.txt"))}),(W?test.skip:test)("symlink support (via extra watch)",async function(){const i=a(t,"deep-linked"),r=a(t,"deep");return await m.symlink(r,i),await e.watch([{path:t,excludes:[],recursive:!0},{path:i,excludes:[],recursive:!0}]),p(a(i,"newFile.txt"))}),(W?test:test.skip)("unc support",async function(){oe("localhost");const i=`\\\\localhost\\${ne(t)?.toLowerCase()}$\\${le(t.substr(t.indexOf(":")+1),"\\")}`;return await e.watch([{path:i,excludes:[],recursive:!0}]),p(a(i,"deep","newFile.txt"))}),(_?test.skip:test)("wrong casing",async function(){const i=a(t,"DEEP");return await e.watch([{path:i,excludes:[],recursive:!0}]),p(a(i,"newFile.txt"))}),test("invalid folder does not explode",async function(){const i=a(t,"invalid");await e.watch([{path:i,excludes:[],recursive:!0}])}),(W?test.skip:test)("deleting watched path without correlation restarts watching",async function(){const i=a(t,"deep");await e.watch([{path:i,excludes:[],recursive:!0}]);const r=V(e,"warn");await d.rm(i,L.UNLINK),await r,await R(1500),await m.mkdir(i),await R(1500),await e.whenReady();const l=a(i,"newFile.txt"),c=n(e,l,s.ADDED);await d.writeFile(l,"Hello World"),await c}),test("correlationId is supported",async function(){const i=Math.random();return await e.watch([{correlationId:i,path:t,excludes:[],recursive:!0}]),p(a(t,"newFile.txt"),i)}),test("should not exclude roots that do not overlap",()=>{W?(o.deepStrictEqual(e.testRemoveDuplicateRequests(["C:\\a"]),["C:\\a"]),o.deepStrictEqual(e.testRemoveDuplicateRequests(["C:\\a","C:\\b"]),["C:\\a","C:\\b"]),o.deepStrictEqual(e.testRemoveDuplicateRequests(["C:\\a","C:\\b","C:\\c\\d\\e"]),["C:\\a","C:\\b","C:\\c\\d\\e"])):(o.deepStrictEqual(e.testRemoveDuplicateRequests(["/a"]),["/a"]),o.deepStrictEqual(e.testRemoveDuplicateRequests(["/a","/b"]),["/a","/b"]),o.deepStrictEqual(e.testRemoveDuplicateRequests(["/a","/b","/c/d/e"]),["/a","/b","/c/d/e"]))}),test("should remove sub-folders of other paths",()=>{W?(o.deepStrictEqual(e.testRemoveDuplicateRequests(["C:\\a","C:\\a\\b"]),["C:\\a"]),o.deepStrictEqual(e.testRemoveDuplicateRequests(["C:\\a","C:\\b","C:\\a\\b"]),["C:\\a","C:\\b"]),o.deepStrictEqual(e.testRemoveDuplicateRequests(["C:\\b\\a","C:\\a","C:\\b","C:\\a\\b"]),["C:\\a","C:\\b"]),o.deepStrictEqual(e.testRemoveDuplicateRequests(["C:\\a","C:\\a\\b","C:\\a\\c\\d"]),["C:\\a"])):(o.deepStrictEqual(e.testRemoveDuplicateRequests(["/a","/a/b"]),["/a"]),o.deepStrictEqual(e.testRemoveDuplicateRequests(["/a","/b","/a/b"]),["/a","/b"]),o.deepStrictEqual(e.testRemoveDuplicateRequests(["/b/a","/a","/b","/a/b"]),["/a","/b"]),o.deepStrictEqual(e.testRemoveDuplicateRequests(["/a","/a/b","/a/c/d"]),["/a"]))}),test("should ignore when everything excluded",()=>{o.deepStrictEqual(e.testRemoveDuplicateRequests(["/foo/bar","/bar"],["**","something"]),[])}),test("watching same or overlapping paths supported when correlation is applied",async()=>{await e.watch([{path:t,excludes:[],recursive:!0,correlationId:1}]),await p(a(t,"newFile.txt"),null,1),await e.watch([{path:t,excludes:[],recursive:!0,correlationId:1},{path:t,excludes:[],recursive:!0,correlationId:2},{path:t,excludes:[],recursive:!0,correlationId:void 0}]),await p(a(t,"newFile.txt"),null,3),await p(a(t,"otherNewFile.txt"),null,3),await e.watch([{path:t,excludes:[],recursive:!0,correlationId:1},{path:t,excludes:[],recursive:!0,correlationId:2},{path:t,excludes:[],recursive:!0,correlationId:void 0},{path:t,excludes:[a(P(t),"deep")],recursive:!0,correlationId:3},{path:t,excludes:[a(P(t),"other")],recursive:!0,correlationId:4}]),await p(a(t,"newFile.txt"),null,5),await p(a(t,"otherNewFile.txt"),null,5),await e.watch([{path:$(t),excludes:[],recursive:!0,correlationId:1},{path:t,excludes:[],recursive:!0,correlationId:2},{path:a(t,"deep"),excludes:[],recursive:!0,correlationId:3}]),await p(a(t,"deep","newFile.txt"),null,3),await p(a(t,"deep","otherNewFile.txt"),null,3),await e.watch([{path:$(t),excludes:[],recursive:!0,correlationId:1},{path:t,excludes:[a(P(t),"some")],recursive:!0,correlationId:2},{path:a(t,"deep"),excludes:[a(P(t),"other")],recursive:!0,correlationId:3}]),await p(a(t,"deep","newFile.txt"),null,3),await p(a(t,"deep","otherNewFile.txt"),null,3)}),test("watching missing path emits watcher fail event",async function(){const i=y.toPromise(e.onWatchFail),r=a(t,"missing");e.watch([{path:r,excludes:[],recursive:!0}]),await i}),test("deleting watched path emits watcher fail and delete event if correlated",async function(){const i=a(t,"deep");await e.watch([{path:i,excludes:[],recursive:!0,correlationId:1}]);let r=!1;const l=Array.from(e.watchers)[0];o.strictEqual(l.include(i),!0),l.onDidFail(()=>r=!0);const c=y.toPromise(e.onWatchFail),h=n(e,i,s.DELETED,void 0,1);d.rm(i,L.UNLINK),await c,await h,o.strictEqual(r,!0),o.strictEqual(l.failed,!0)}),test("correlated watch requests support suspend/resume (folder, does not exist in beginning, not reusing watcher)",async()=>{await N(!1)}),(S?test:test.skip)("correlated watch requests support suspend/resume (folder, does not exist in beginning, reusing watcher)",async()=>{await N(!0)});async function N(i){let r=y.toPromise(e.onWatchFail);const l=a(t,"not-found"),c=[];i&&(c.push({path:t,excludes:[],recursive:!0}),await e.watch(c));const h={path:l,excludes:[],recursive:!0,correlationId:1};c.push(h),await e.watch(c),await r,i?o.strictEqual(e.isSuspended(h),!0):o.strictEqual(e.isSuspended(h),"polling");let w=n(e,l,s.ADDED,void 0,1),u=y.toPromise(e.onDidWatch);await m.mkdir(l),await w,await u,o.strictEqual(e.isSuspended(h),!1);const E=a(l,"newFile.txt");await p(E,1),r=y.toPromise(e.onWatchFail),await d.rm(l),await r,w=n(e,l,s.ADDED,void 0,1),u=y.toPromise(e.onDidWatch),await m.mkdir(l),await w,await u,await p(E,1)}test("correlated watch requests support suspend/resume (folder, exist in beginning, not reusing watcher)",async()=>{await M(!1)}),(S?test:test.skip)("correlated watch requests support suspend/resume (folder, exist in beginning, reusing watcher)",async()=>{await M(!0)});async function M(i){const r=a(t,"deep"),l=[{path:r,excludes:[],recursive:!0,correlationId:1}];i&&l.push({path:t,excludes:[],recursive:!0}),await e.watch(l);const c=a(r,"newFile.txt");await p(c,1);const h=y.toPromise(e.onWatchFail);await d.rm(r),await h;const w=n(e,r,s.ADDED,void 0,1),u=y.toPromise(e.onDidWatch);await m.mkdir(r),await w,await u,await p(c,1)}test("watch request reuses another recursive watcher even when requests are coming in at the same time",async function(){const i=a(t,"deep","not-existing1"),r=a(t,"deep","not-existing2"),l=a(t,"not-existing3"),c=[{path:i,excludes:[],recursive:!0,correlationId:1},{path:r,excludes:[],recursive:!0,correlationId:2},{path:l,excludes:[],recursive:!0,correlationId:3},{path:a(t,"deep"),excludes:[],recursive:!0}];await e.watch(c),o.strictEqual(e.isSuspended(c[0]),!0),o.strictEqual(e.isSuspended(c[1]),!0),o.strictEqual(e.isSuspended(c[2]),"polling"),o.strictEqual(e.isSuspended(c[3]),!1)}),test("event type filter",async function(){const i={path:t,excludes:[],recursive:!0,filter:K.ADDED|K.DELETED,correlationId:1};await e.watch([i]);const r=a(t,"lorem-newfile.txt");let l=n(e,r,s.ADDED,void 0,1);await d.writeFile(r,"Hello Change"),await l,l=n(e,r,s.DELETED,void 0,1),await m.unlink(r),await l})});export{we as TestParcelWatcher};
