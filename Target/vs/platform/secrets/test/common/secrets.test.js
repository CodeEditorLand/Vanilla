import r from"assert";import*as l from"sinon";import{ensureNoDisposablesAreLeakedInTestSuite as p}from"../../../../base/test/common/utils.js";import{KnownStorageProvider as v}from"../../../encryption/common/encryptionService.js";import{NullLogService as y}from"../../../log/common/log.js";import{BaseSecretStorageService as u}from"../../common/secrets.js";import{InMemoryStorageService as d}from"../../../storage/common/storage.js";class m{_serviceBrand;encryptedPrefix="encrypted+";setUsePlainTextEncryption(){return Promise.resolve()}getKeyStorageProvider(){return Promise.resolve(v.basicText)}encrypt(e){return Promise.resolve(this.encryptedPrefix+e)}decrypt(e){return Promise.resolve(e.substring(this.encryptedPrefix.length))}isEncryptionAvailable(){return Promise.resolve(!0)}}class S{_serviceBrand;setUsePlainTextEncryption(){throw new Error("Method not implemented.")}getKeyStorageProvider(){throw new Error("Method not implemented.")}encrypt(e){throw new Error("Method not implemented.")}decrypt(e){throw new Error("Method not implemented.")}isEncryptionAvailable(){return Promise.resolve(!1)}}suite("secrets",()=>{const i=p();suite("BaseSecretStorageService useInMemoryStorage=true",()=>{let e,n,o;setup(()=>{o=l.createSandbox(),n=o.spy(new m),e=i.add(new u(!0,i.add(new d),n,i.add(new y)))}),teardown(()=>{o.restore()}),test("type",async()=>{r.strictEqual(e.type,"unknown"),await e.set("my-secret","my-secret-value"),r.strictEqual(e.type,"in-memory")}),test("set and get",async()=>{const t="my-secret",a="my-secret-value";await e.set(t,a);const s=await e.get(t);r.strictEqual(s,a),r.strictEqual(n.encrypt.callCount,0),r.strictEqual(n.decrypt.callCount,0)}),test("delete",async()=>{const t="my-secret";await e.set(t,"my-secret-value"),await e.delete(t);const s=await e.get(t);r.strictEqual(s,void 0)}),test("onDidChangeSecret",async()=>{const t="my-secret",a="my-secret-value";let s=!1;i.add(e.onDidChangeSecret(c=>{r.strictEqual(c,t),s=!0})),await e.set(t,a),r.strictEqual(s,!0)})}),suite("BaseSecretStorageService useInMemoryStorage=false",()=>{let e,n,o;setup(()=>{o=l.createSandbox(),n=o.spy(new m),e=i.add(new u(!1,i.add(new d),n,i.add(new y)))}),teardown(()=>{o.restore()}),test("type",async()=>{r.strictEqual(e.type,"unknown"),await e.set("my-secret","my-secret-value"),r.strictEqual(e.type,"persisted")}),test("set and get",async()=>{const t="my-secret",a="my-secret-value";await e.set(t,a);const s=await e.get(t);r.strictEqual(s,a),r.strictEqual(n.encrypt.callCount,1),r.strictEqual(n.decrypt.callCount,1)}),test("delete",async()=>{const t="my-secret";await e.set(t,"my-secret-value"),await e.delete(t);const s=await e.get(t);r.strictEqual(s,void 0)}),test("onDidChangeSecret",async()=>{const t="my-secret",a="my-secret-value";let s=!1;i.add(e.onDidChangeSecret(c=>{r.strictEqual(c,t),s=!0})),await e.set(t,a),r.strictEqual(s,!0)})}),suite("BaseSecretStorageService useInMemoryStorage=false, encryption not available",()=>{let e,n,o;setup(()=>{o=l.createSandbox(),n=o.spy(new S),e=i.add(new u(!1,i.add(new d),n,i.add(new y)))}),teardown(()=>{o.restore()}),test("type",async()=>{r.strictEqual(e.type,"unknown"),await e.set("my-secret","my-secret-value"),r.strictEqual(e.type,"in-memory")}),test("set and get",async()=>{const t="my-secret",a="my-secret-value";await e.set(t,a);const s=await e.get(t);r.strictEqual(s,a),r.strictEqual(n.encrypt.callCount,0),r.strictEqual(n.decrypt.callCount,0)})})});
