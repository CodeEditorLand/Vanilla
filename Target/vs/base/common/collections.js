function a(s,e){const t=Object.create(null);for(const r of s){const o=e(r);let n=t[o];n||(n=t[o]=[]),n.push(r)}return t}function i(s,e){const t=[],r=[];for(const o of s)e.has(o)||t.push(o);for(const o of e)s.has(o)||r.push(o);return{removed:t,added:r}}function l(s,e){const t=[],r=[];for(const[o,n]of s)e.has(o)||t.push(n);for(const[o,n]of e)s.has(o)||r.push(n);return{removed:t,added:r}}function c(s,e){const t=new Set;for(const r of e)s.has(r)&&t.add(r);return t}class d{constructor(e,t){this.toKey=t;for(const r of e)this.add(r)}_map=new Map;get size(){return this._map.size}add(e){const t=this.toKey(e);return this._map.set(t,e),this}delete(e){return this._map.delete(this.toKey(e))}has(e){return this._map.has(this.toKey(e))}*entries(){for(const e of this._map.values())yield[e,e]}keys(){return this.values()}*values(){for(const e of this._map.values())yield e}clear(){this._map.clear()}forEach(e,t){this._map.forEach(r=>e.call(t,r,r,this))}[Symbol.iterator](){return this.values()}[Symbol.toStringTag]="SetWithKey"}export{d as SetWithKey,l as diffMaps,i as diffSets,a as groupBy,c as intersection};
