import t from"assert";import{IndexedDB as O}from"../../../../base/browser/indexedDB.js";import{bufferToReadable as D,bufferToStream as b,VSBuffer as u}from"../../../../base/common/buffer.js";import{DisposableStore as C}from"../../../../base/common/lifecycle.js";import{Schemas as x}from"../../../../base/common/network.js";import{basename as p,joinPath as o}from"../../../../base/common/resources.js";import{URI as R}from"../../../../base/common/uri.js";import{flakySuite as P}from"../../../../base/test/common/testUtils.js";import{IndexedDBFileSystemProvider as k}from"../../browser/indexedDBFileSystemProvider.js";import{FileOperation as y,FileOperationResult as F,FileSystemProviderErrorCode as j,FileType as m}from"../../common/files.js";import{FileService as I}from"../../common/fileService.js";import{NullLogService as L}from"../../../log/common/log.js";P("IndexedDBFileSystemProvider",function(){let e,d;const g="/",c=r=>o(R.from({scheme:x.vscodeUserData,path:g}),...r),f=new C,E=async()=>{await Promise.all([["fixtures","resolver","examples"],["fixtures","resolver","other","deep"],["fixtures","service","deep"],["batched"]].map(r=>c(r)).map(r=>e.createFolder(r))),await Promise.all([[["fixtures","resolver","examples","company.js"],"class company {}"],[["fixtures","resolver","examples","conway.js"],"export function conway() {}"],[["fixtures","resolver","examples","employee.js"],'export const employee = "jax"'],[["fixtures","resolver","examples","small.js"],""],[["fixtures","resolver","other","deep","company.js"],"class company {}"],[["fixtures","resolver","other","deep","conway.js"],"export function conway() {}"],[["fixtures","resolver","other","deep","employee.js"],'export const employee = "jax"'],[["fixtures","resolver","other","deep","small.js"],""],[["fixtures","resolver","index.html"],"<p>p</p>"],[["fixtures","resolver","site.css"],".p {color: red;}"],[["fixtures","service","deep","company.js"],"class company {}"],[["fixtures","service","deep","conway.js"],"export function conway() {}"],[["fixtures","service","deep","employee.js"],'export const employee = "jax"'],[["fixtures","service","deep","small.js"],""],[["fixtures","service","binary.txt"],"<p>p</p>"]].map(([r,a])=>[c(r),a]).map(([r,a])=>e.createFile(r,u.fromString(a))))},q=async()=>{const r=new L;e=new I(r),f.add(e);const a=await O.create("vscode-web-db-test",1,["vscode-userdata-store","vscode-logs-store"]);d=new k(x.vscodeUserData,a,"vscode-userdata-store",!0),f.add(e.registerProvider(x.vscodeUserData,d)),f.add(d)};setup(async function(){this.timeout(15e3),await q()}),teardown(async()=>{await d.reset(),f.clear()}),test("root is always present",async()=>{t.strictEqual((await d.stat(c([]))).type,m.Directory),await d.delete(c([]),{recursive:!0,useTrash:!1,atomic:!1}),t.strictEqual((await d.stat(c([]))).type,m.Directory)}),test("createFolder",async()=>{let r;f.add(e.onDidRunOperation(l=>r=l));const a=await e.resolve(c([])),i=o(a.resource,"newFolder");t.strictEqual((await d.readdir(a.resource)).length,0);const s=await e.createFolder(i);t.strictEqual(s.name,"newFolder"),t.strictEqual((await d.readdir(a.resource)).length,1),t.strictEqual((await d.stat(i)).type,m.Directory),t.ok(r),t.strictEqual(r.resource.path,i.path),t.strictEqual(r.operation,y.CREATE),t.strictEqual(r.target.resource.path,i.path),t.strictEqual(r.target.isDirectory,!0)}),test("createFolder: creating multiple folders at once",async()=>{let r;f.add(e.onDidRunOperation(w=>r=w));const a=["a","couple","of","folders"],i=await e.resolve(c([])),s=o(i.resource,...a),l=await e.createFolder(s),n=a[a.length-1];t.strictEqual(l.name,n),t.strictEqual((await d.stat(s)).type,m.Directory),t.ok(r),t.strictEqual(r.resource.path,s.path),t.strictEqual(r.operation,y.CREATE),t.strictEqual(r.target.resource.path,s.path),t.strictEqual(r.target.isDirectory,!0)}),test("exists",async()=>{let r=await e.exists(c([]));t.strictEqual(r,!0),r=await e.exists(c(["hello"])),t.strictEqual(r,!1)}),test("resolve - file",async()=>{await E();const r=c(["fixtures","resolver","index.html"]),a=await e.resolve(r);t.strictEqual(a.name,"index.html"),t.strictEqual(a.isFile,!0),t.strictEqual(a.isDirectory,!1),t.strictEqual(a.isSymbolicLink,!1),t.strictEqual(a.resource.toString(),r.toString()),t.strictEqual(a.children,void 0),t.ok(a.size>0)}),test("resolve - directory",async()=>{await E();const r=["examples","other","index.html","site.css"],a=c(["fixtures","resolver"]),i=await e.resolve(a);t.ok(i),t.strictEqual(i.resource.toString(),a.toString()),t.strictEqual(i.name,"resolver"),t.ok(i.children),t.ok(i.children.length>0),t.ok(i.isDirectory),t.strictEqual(i.children.length,r.length),t.ok(i.children.every(s=>r.some(l=>p(s.resource)===l))),i.children.forEach(s=>{t.ok(p(s.resource)),["examples","other"].indexOf(p(s.resource))>=0?(t.ok(s.isDirectory),t.strictEqual(s.mtime,void 0),t.strictEqual(s.ctime,void 0)):p(s.resource)==="index.html"?(t.ok(!s.isDirectory),t.ok(!s.children),t.strictEqual(s.mtime,void 0),t.strictEqual(s.ctime,void 0)):p(s.resource)==="site.css"?(t.ok(!s.isDirectory),t.ok(!s.children),t.strictEqual(s.mtime,void 0),t.strictEqual(s.ctime,void 0)):t.fail("Unexpected value "+p(s.resource))})}),test("createFile",async()=>v(r=>u.fromString(r))),test("createFile (readable)",async()=>v(r=>D(u.fromString(r)))),test("createFile (stream)",async()=>v(r=>b(u.fromString(r))));async function v(r){let a;f.add(e.onDidRunOperation(n=>a=n));const i="Hello World",s=c(["test.txt"]);t.strictEqual(await e.canCreateFile(s),!0);const l=await e.createFile(s,r(i));t.strictEqual(l.name,"test.txt"),t.strictEqual((await d.stat(l.resource)).type,m.File),t.strictEqual(new TextDecoder().decode(await d.readFile(l.resource)),i),t.ok(a),t.strictEqual(a.resource.path,s.path),t.strictEqual(a.operation,y.CREATE),t.strictEqual(a.target.resource.path,s.path)}const h=(r,a)=>{const i=Array.from({length:r}).map((l,n)=>({contents:`Hello${n}`,resource:c(["batched",a,`Hello${n}.txt`])}));let s;return{async create(){return s=Promise.all(i.map(l=>d.writeFile(l.resource,u.fromString(l.contents).buffer,{create:!0,overwrite:!0,unlock:!1,atomic:!1})))},async assertContentsCorrect(){if(!s)throw Error("read called before create");await s,await Promise.all(i.map(async(l,n)=>{t.strictEqual((await d.stat(l.resource)).type,m.File),t.strictEqual(new TextDecoder().decode(await d.readFile(l.resource)),l.contents)}))}}};test("createFile - batch",async()=>{const r=h(20,"batch");await r.create(),await r.assertContentsCorrect()}),test("createFile - batch (mixed parallel/sequential)",async()=>{const r=h(1,"batch1"),a=h(20,"batch2"),i=h(1,"batch3"),s=h(20,"batch4");r.create(),a.create(),await Promise.all([r.assertContentsCorrect(),a.assertContentsCorrect()]),i.create(),s.create(),await Promise.all([i.assertContentsCorrect(),s.assertContentsCorrect()]),await Promise.all([r.assertContentsCorrect(),a.assertContentsCorrect()])}),test("rename not existing resource",async()=>{const r=await e.resolve(c([])),a=o(r.resource,"sourceFile"),i=o(r.resource,"targetFile");try{await e.move(a,i,!1)}catch(s){t.deepStrictEqual(s.code,j.FileNotFound);return}t.fail("This should fail with error")}),test("rename to an existing file without overwrite",async()=>{const r=await e.resolve(c([])),a=o(r.resource,"sourceFile");await e.writeFile(a,u.fromString("This is source file"));const i=o(r.resource,"targetFile");await e.writeFile(i,u.fromString("This is target file"));try{await e.move(a,i,!1)}catch(s){t.deepStrictEqual(s.fileOperationResult,F.FILE_MOVE_CONFLICT);return}t.fail("This should fail with error")}),test("rename folder to an existing folder without overwrite",async()=>{const r=await e.resolve(c([])),a=o(r.resource,"sourceFolder");await e.createFolder(a);const i=o(r.resource,"targetFolder");await e.createFolder(i);try{await e.move(a,i,!1)}catch(s){t.deepStrictEqual(s.fileOperationResult,F.FILE_MOVE_CONFLICT);return}t.fail("This should fail with cannot overwrite error")}),test("rename file to a folder",async()=>{const r=await e.resolve(c([])),a=o(r.resource,"sourceFile");await e.writeFile(a,u.fromString("This is source file"));const i=o(r.resource,"targetFolder");await e.createFolder(i);try{await e.move(a,i,!1)}catch(s){t.deepStrictEqual(s.fileOperationResult,F.FILE_MOVE_CONFLICT);return}t.fail("This should fail with error")}),test("rename folder to a file",async()=>{const r=await e.resolve(c([])),a=o(r.resource,"sourceFile");await e.createFolder(a);const i=o(r.resource,"targetFile");await e.writeFile(i,u.fromString("This is target file"));try{await e.move(a,i,!1)}catch(s){t.deepStrictEqual(s.fileOperationResult,F.FILE_MOVE_CONFLICT);return}t.fail("This should fail with error")}),test("rename file",async()=>{const r=await e.resolve(c([])),a=o(r.resource,"sourceFile");await e.writeFile(a,u.fromString("This is source file"));const i=o(r.resource,"targetFile");await e.move(a,i,!1);const s=await e.readFile(i);t.strictEqual(await e.exists(a),!1),t.strictEqual(s.value.toString(),"This is source file")}),test("rename to an existing file with overwrite",async()=>{const r=await e.resolve(c([])),a=o(r.resource,"sourceFile"),i=o(r.resource,"targetFile");await Promise.all([e.writeFile(a,u.fromString("This is source file")),e.writeFile(i,u.fromString("This is target file"))]),await e.move(a,i,!0);const s=await e.readFile(i);t.strictEqual(await e.exists(a),!1),t.strictEqual(s.value.toString(),"This is source file")}),test("rename folder to a new folder",async()=>{const r=await e.resolve(c([])),a=o(r.resource,"sourceFolder");await e.createFolder(a);const i=o(r.resource,"targetFolder");await e.move(a,i,!1),t.deepStrictEqual(await e.exists(a),!1),t.deepStrictEqual(await e.exists(i),!0)}),test("rename folder to an existing folder",async()=>{const r=await e.resolve(c([])),a=o(r.resource,"sourceFolder");await e.createFolder(a);const i=o(r.resource,"targetFolder");await e.createFolder(i),await e.move(a,i,!0),t.deepStrictEqual(await e.exists(a),!1),t.deepStrictEqual(await e.exists(i),!0)}),test("rename a folder that has multiple files and folders",async()=>{const r=await e.resolve(c([])),a=o(r.resource,"sourceFolder"),i=o(a,"folder1","file1"),s=o(a,"folder2","file1"),l=o(a,"folder3");await Promise.all([e.writeFile(i,u.fromString("Source File 1")),e.writeFile(s,u.fromString("Source File 2")),e.createFolder(l)]);const n=o(r.resource,"targetFolder"),w=o(n,"folder1","file1"),S=o(n,"folder2","file1"),T=o(n,"folder3");await e.move(a,n,!1),t.deepStrictEqual(await e.exists(a),!1),t.deepStrictEqual(await e.exists(n),!0),t.strictEqual((await e.readFile(w)).value.toString(),"Source File 1"),t.strictEqual((await e.readFile(S)).value.toString(),"Source File 2"),t.deepStrictEqual(await e.exists(T),!0)}),test("rename a folder to another folder that has some files",async()=>{const r=await e.resolve(c([])),a=o(r.resource,"sourceFolder"),i=o(a,"folder1","file1"),s=o(r.resource,"targetFolder"),l=o(s,"folder1","file1"),n=o(s,"folder1","file2"),w=o(s,"folder2","file1");await Promise.all([e.writeFile(i,u.fromString("Source File 1")),e.writeFile(n,u.fromString("Target File 2")),e.writeFile(w,u.fromString("Target File 3"))]),await e.move(a,s,!0),t.deepStrictEqual(await e.exists(a),!1),t.deepStrictEqual(await e.exists(s),!0),t.strictEqual((await e.readFile(l)).value.toString(),"Source File 1"),t.strictEqual(await e.exists(n),!1),t.strictEqual(await e.exists(w),!1)}),test("deleteFile",async()=>{await E();let r;f.add(e.onDidRunOperation(l=>r=l));const a=c(["fixtures","service","deep","company.js"]),i=c(["fixtures","service","deep","conway.js"]),s=await e.resolve(i);t.strictEqual(await e.canDelete(s.resource,{useTrash:!1}),!0),await e.del(s.resource,{useTrash:!1}),t.strictEqual(await e.exists(s.resource),!1),t.strictEqual(await e.exists(a),!0),t.ok(r),t.strictEqual(r.resource.path,i.path),t.strictEqual(r.operation,y.DELETE);{let l;try{await e.del(s.resource,{useTrash:!1})}catch(n){l=n}t.ok(l),t.strictEqual(l.fileOperationResult,F.FILE_NOT_FOUND)}await q();{let l;try{await e.del(s.resource,{useTrash:!1})}catch(n){l=n}t.ok(l),t.strictEqual(l.fileOperationResult,F.FILE_NOT_FOUND)}}),test("deleteFolder (recursive)",async()=>{await E();let r;f.add(e.onDidRunOperation(n=>r=n));const a=c(["fixtures","service","deep"]),i=c(["fixtures","service","deep","company.js"]),s=c(["fixtures","service","deep","conway.js"]);t.strictEqual(await e.exists(i),!0),t.strictEqual(await e.exists(s),!0);const l=await e.resolve(a);t.strictEqual(await e.canDelete(l.resource,{recursive:!0,useTrash:!1}),!0),await e.del(l.resource,{recursive:!0,useTrash:!1}),t.strictEqual(await e.exists(l.resource),!1),t.strictEqual(await e.exists(i),!1),t.strictEqual(await e.exists(s),!1),t.ok(r),t.strictEqual(r.resource.fsPath,a.fsPath),t.strictEqual(r.operation,y.DELETE)}),test("deleteFolder (non recursive)",async()=>{await E();const r=c(["fixtures","service","deep"]),a=await e.resolve(r);t.ok(await e.canDelete(a.resource)instanceof Error);let i;try{await e.del(a.resource)}catch(s){i=s}t.ok(i)}),test("delete empty folder",async()=>{const r=await e.resolve(c([])),a=o(r.resource,"folder");await e.createFolder(a),await e.del(a),t.deepStrictEqual(await e.exists(a),!1)}),test("delete empty folder with reccursive",async()=>{const r=await e.resolve(c([])),a=o(r.resource,"folder");await e.createFolder(a),await e.del(a,{recursive:!0}),t.deepStrictEqual(await e.exists(a),!1)}),test("deleteFolder with folders and files (recursive)",async()=>{const r=await e.resolve(c([])),a=o(r.resource,"targetFolder"),i=o(a,"folder1","file1");await e.createFile(i);const s=o(a,"folder2","file1");await e.createFile(s);const l=o(a,"folder3");await e.createFolder(l),await e.del(a,{recursive:!0}),t.deepStrictEqual(await e.exists(a),!1),t.deepStrictEqual(await e.exists(o(a,"folder1")),!1),t.deepStrictEqual(await e.exists(o(a,"folder2")),!1),t.deepStrictEqual(await e.exists(i),!1),t.deepStrictEqual(await e.exists(s),!1),t.deepStrictEqual(await e.exists(l),!1)})});
