var w=Object.defineProperty;var P=Object.getOwnPropertyDescriptor;var S=(d,o,t,e)=>{for(var i=e>1?void 0:e?P(o,t):o,a=d.length-1,s;a>=0;a--)(s=d[a])&&(i=(e?s(o,t,i):s(i))||i);return e&&i&&w(o,t,i),i},n=(d,o)=>(t,e)=>o(t,e,d);import{spawn as U}from"child_process";import*as h from"fs";import{tmpdir as A}from"os";import{timeout as R}from"../../../base/common/async.js";import{CancellationToken as b}from"../../../base/common/cancellation.js";import{memoize as k}from"../../../base/common/decorators.js";import{hash as F}from"../../../base/common/hash.js";import*as c from"../../../base/common/path.js";import{URI as q}from"../../../base/common/uri.js";import{checksum as $}from"../../../base/node/crypto.js";import*as v from"../../../base/node/pfs.js";import{IConfigurationService as x}from"../../configuration/common/configuration.js";import{IEnvironmentMainService as T}from"../../environment/electron-main/environmentMainService.js";import{IFileService as C}from"../../files/common/files.js";import{ILifecycleMainService as D}from"../../lifecycle/electron-main/lifecycleMainService.js";import{ILogService as H}from"../../log/common/log.js";import{INativeHostMainService as M}from"../../native/electron-main/nativeHostMainService.js";import{IProductService as E}from"../../product/common/productService.js";import{asJson as N,IRequestService as L}from"../../request/common/request.js";import{ITelemetryService as j}from"../../telemetry/common/telemetry.js";import{DisablementReason as V,State as r,StateType as m,UpdateType as f}from"../common/update.js";import{AbstractUpdateService as z,createUpdateURL as B}from"./abstractUpdateService.js";async function O(d,o=1e3){for(;!d();)await R(o)}let y;function p(){return typeof y>"u"&&(y=h.existsSync(c.join(c.dirname(process.execPath),"unins000.exe"))?f.Setup:f.Archive),y}let u=class extends z{constructor(t,e,i,a,s,l,g,Q,I){super(t,e,a,s,l,I);this.telemetryService=i;this.fileService=g;this.nativeHostMainService=Q;t.setRelaunchHandler(this)}availableUpdate;get cachePath(){const t=c.join(A(),`vscode-${this.productService.quality}-${this.productService.target}-${process.arch}`);return h.promises.mkdir(t,{recursive:!0}).then(()=>t)}handleRelaunch(t){return t?.addArgs||t?.removeArgs||this.state.type!==m.Ready||!this.availableUpdate?!1:(this.logService.trace("update#handleRelaunch(): running raw#quitAndInstall()"),this.doQuitAndInstall(),!0)}async initialize(){if(this.productService.target==="user"&&await this.nativeHostMainService.isAdmin(void 0)){this.setState(r.Disabled(V.RunningAsAdmin)),this.logService.info("update#ctor - updates are disabled due to running as Admin in user setup");return}await super.initialize()}buildUpdateFeedUrl(t){let e=`win32-${process.arch}`;return p()===f.Archive?e+="-archive":this.productService.target==="user"&&(e+="-user"),B(e,t,this.productService)}doCheckForUpdates(t){this.url&&(this.setState(r.CheckingForUpdates(t)),this.requestService.request({url:this.url},b.None).then(N).then(e=>{const i=p();return!e||!e.url||!e.version||!e.productVersion?(this.telemetryService.publicLog2("update:notAvailable",{explicit:!!t}),this.setState(r.Idle(i)),Promise.resolve(null)):i===f.Archive?(this.setState(r.AvailableForDownload(e)),Promise.resolve(null)):(this.setState(r.Downloading),this.cleanup(e.version).then(()=>this.getUpdatePackagePath(e.version).then(a=>v.Promises.exists(a).then(s=>{if(s)return Promise.resolve(a);const l=`${a}.tmp`;return this.requestService.request({url:e.url},b.None).then(g=>this.fileService.writeFile(q.file(l),g.stream)).then(e.sha256hash?()=>$(l,e.sha256hash):()=>{}).then(()=>v.Promises.rename(l,a,!1)).then(()=>a)})).then(a=>{this.availableUpdate={packagePath:a},this.setState(r.Downloaded(e)),this.configurationService.getValue("update.enableWindowsBackgroundUpdates")?this.productService.target==="user"&&this.doApplyUpdate():this.setState(r.Ready(e))})))}).then(void 0,e=>{this.telemetryService.publicLog2("update:error",{messageHash:String(F(String(e)))}),this.logService.error(e);const i=t?e.message||e:void 0;this.setState(r.Idle(p(),i))}))}async doDownloadUpdate(t){t.update.url&&this.nativeHostMainService.openExternal(void 0,t.update.url),this.setState(r.Idle(p()))}async getUpdatePackagePath(t){const e=await this.cachePath;return c.join(e,`CodeSetup-${this.productService.quality}-${t}.exe`)}async cleanup(t=null){const e=t?l=>!new RegExp(`${this.productService.quality}-${t}\\.exe$`).test(l):()=>!0,i=await this.cachePath,s=(await v.Promises.readdir(i)).filter(e).map(async l=>{try{await h.promises.unlink(c.join(i,l))}catch{}});await Promise.all(s)}async doApplyUpdate(){if(this.state.type!==m.Downloaded||!this.availableUpdate)return Promise.resolve(void 0);const t=this.state.update;this.setState(r.Updating(t));const e=await this.cachePath;this.availableUpdate.updateFilePath=c.join(e,`CodeSetup-${this.productService.quality}-${t.version}.flag`),await v.Promises.writeFile(this.availableUpdate.updateFilePath,"flag"),U(this.availableUpdate.packagePath,["/verysilent","/log",`/update="${this.availableUpdate.updateFilePath}"`,"/nocloseapplications","/mergetasks=runcode,!desktopicon,!quicklaunchicon"],{detached:!0,stdio:["ignore","ignore","ignore"],windowsVerbatimArguments:!0}).once("exit",()=>{this.availableUpdate=void 0,this.setState(r.Idle(p()))});const a=`${this.productService.win32MutexName}-ready`,s=await import("@vscode/windows-mutex");O(()=>s.isActive(a)).then(()=>this.setState(r.Ready(t)))}doQuitAndInstall(){this.state.type!==m.Ready||!this.availableUpdate||(this.logService.trace("update#quitAndInstall(): running raw#quitAndInstall()"),this.availableUpdate.updateFilePath?h.unlinkSync(this.availableUpdate.updateFilePath):U(this.availableUpdate.packagePath,["/silent","/log","/mergetasks=runcode,!desktopicon,!quicklaunchicon"],{detached:!0,stdio:["ignore","ignore","ignore"]}))}getUpdateType(){return p()}async _applySpecificUpdate(t){if(this.state.type!==m.Idle)return;const e=this.configurationService.getValue("update.enableWindowsBackgroundUpdates"),i={version:"unknown",productVersion:"unknown"};this.setState(r.Downloading),this.availableUpdate={packagePath:t},this.setState(r.Downloaded(i)),e?this.productService.target==="user"&&this.doApplyUpdate():this.setState(r.Ready(i))}};S([k],u.prototype,"cachePath",1),u=S([n(0,D),n(1,x),n(2,j),n(3,T),n(4,L),n(5,H),n(6,C),n(7,M),n(8,E)],u);export{u as Win32UpdateService};
