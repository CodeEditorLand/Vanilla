import{Lazy as w}from"../../common/lazy.js";import{FileAccess as _}from"../../common/network.js";import{URI as f}from"../../common/uri.js";let h;const u=t=>t.replace(/[^a-z0-9_-]/gi,"_"),g=t=>t.replace(/\r\n/g,`
`);class y{constructor(n){this.test=n;if(!n)throw new Error("assertSnapshot can only be used in a test");if(!n.file)throw new Error("currentTest.file is not set, please open an issue with the test you're trying to run");const s=_.asFileUri(""),e=n.file.split(/[/\\]/g);this.namePrefix=u(n.fullTitle())+".",this.snapshotsDir=f.joinPath(s,...e.slice(0,-1),"__snapshots__")}nextIndex=0;snapshotsDir;namePrefix;usedNames=new Set;async assert(n,s){const e=new Error().stack,c=s?.name?u(s.name):this.nextIndex++,p=this.namePrefix+c+"."+(s?.extension||"snap");this.usedNames.add(p);const r=f.joinPath(this.snapshotsDir,p).fsPath,a=m(n);let i;try{i=await __readFileInTests(r)}catch{console.info(`Creating new snapshot in: ${r}`),await __mkdirPInTests(this.snapshotsDir.fsPath),await __writeFileInTests(r,a);return}if(g(i)!==g(a)){await __writeFileInTests(r+".actual",a);const o=new Error(`Snapshot #${c} does not match expected output`);throw o.expected=i,o.actual=a,o.snapshotPath=r,o.stack=o.stack.split(`
`).slice(0,1).concat(e.split(`
`).slice(3)).join(`
`),o}}async removeOldSnapshots(){const s=(await __readDirInTests(this.snapshotsDir.fsPath)).filter(e=>e.startsWith(this.namePrefix)&&!this.usedNames.has(e));s.length&&console.info(`Deleting ${s.length} old snapshots for ${this.test?.fullTitle()}`),await Promise.all(s.map(e=>__unlinkInTests(f.joinPath(this.snapshotsDir,e).fsPath)))}}const d=Symbol.for("debug.description");function m(t,n=0,s=[]){switch(typeof t){case"bigint":case"boolean":case"number":case"symbol":case"undefined":return String(t);case"string":return n===0?t:JSON.stringify(t);case"function":return`[Function ${t.name}]`;case"object":{if(t===null)return"null";if(t instanceof RegExp)return String(t);if(s.includes(t))return"[Circular]";if(d in t&&typeof t[d]=="function")return t[d]();const e="  ".repeat(n),c="  ".repeat(n+1);if(Array.isArray(t)){const i=t.map(l=>m(l,n+1,[...s,t]));return i.some(l=>l.includes(`
`))||i.join(", ").length>80?`[
${c}${i.join(`,
${c}`)}
${e}]`:`[ ${i.join(", ")} ]`}let p,r="";t instanceof Map?(r="Map ",p=[...t.entries()]):t instanceof Set?(r="Set ",p=[...t.entries()]):p=Object.entries(t);const a=p.map(([i,o])=>`${i}: ${m(o,n+1,[...s,t])}`);return r+(a.length>1?`{
${c}${a.join(`,
${c}`)}
${e}}`:`{ ${a.join(`,
`)} }`)}default:throw new Error(`Unknown type ${t}`)}}setup(function(){const t=this.currentTest;h=new w(()=>new y(t))}),teardown(async function(){this.currentTest?.state==="passed"&&await h?.rawValue?.removeOldSnapshots(),h=void 0});function I(t,n){if(!h)throw new Error("assertSnapshot can only be used in a test");return h.value.assert(t,n)}export{y as SnapshotContext,I as assertSnapshot};
