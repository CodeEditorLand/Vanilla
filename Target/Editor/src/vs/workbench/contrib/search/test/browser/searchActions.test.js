import u from"assert";import"../../../../../base/common/keybindings.js";import{OS as g}from"../../../../../base/common/platform.js";import{URI as M}from"../../../../../base/common/uri.js";import{IModelService as v}from"../../../../../editor/common/services/model.js";import{TestInstantiationService as F}from"../../../../../platform/instantiation/test/common/instantiationServiceMock.js";import{IKeybindingService as f}from"../../../../../platform/keybinding/common/keybinding.js";import{USLayoutResolvedKeybinding as y}from"../../../../../platform/keybinding/common/usLayoutResolvedKeybinding.js";import{QueryType as S}from"../../../../services/search/common/search.js";import{getElementToFocusAfterRemoved as d,getLastNodeFromSameType as b}from"../../browser/searchActionsRemoveReplace.js";import{FileMatch as I,FolderMatch as T,Match as w,SearchModel as E}from"../../browser/searchModel.js";import{MockObjectTree as L}from"./mockSearchTree.js";import{ILabelService as K}from"../../../../../platform/label/common/label.js";import{INotebookEditorService as N}from"../../../notebook/browser/services/notebookEditorService.js";import{createFileUriFromPathFromRoot as x,stubModelService as R,stubNotebookEditorService as k}from"./searchTestCommon.js";import{ensureNoDisposablesAreLeakedInTestSuite as q}from"../../../../../base/test/common/utils.js";suite("Search Actions",()=>{let c,h;const m=q();setup(()=>{c=new F,c.stub(v,R(c,t=>m.add(t))),c.stub(N,k(c,t=>m.add(t))),c.stub(f,{}),c.stub(K,{getUriBasenameLabel:t=>""}),c.stub(f,"resolveKeybinding",t=>y.resolveKeybinding(t,g)),c.stub(f,"lookupKeybinding",t=>null),c.stub(f,"lookupKeybinding",t=>null),h=0}),teardown(()=>{c.dispose()}),test("get next element to focus after removing a match when it has next sibling file",function(){const t=i(),e=i(),n=[t,a(t),a(t),e,a(e),a(e)],o=l(n),r=n[2],s=d(o,r,[r]);u.strictEqual(n[4],s)}),test("get next element to focus after removing a match when it is the only match",function(){const t=i(),e=[t,a(t)],n=l(e),o=e[1],r=d(n,o,[o]);u.strictEqual(void 0,r)}),test("get next element to focus after removing a file match when it has next sibling",function(){const t=i(),e=i(),n=i(),o=[t,a(t),e,a(e),n,a(n)],r=l(o),s=o[2],p=d(r,s,[]);u.strictEqual(o[4],p)}),test("Find last FileMatch in Tree",function(){const t=i(),e=i(),n=i(),o=[t,a(t),e,a(e),n,a(n)],r=l(o),s=b(r,t);u.strictEqual(n,s)}),test("Find last Match in Tree",function(){const t=i(),e=i(),n=i(),o=[t,a(t),e,a(e),n,a(n)],r=l(o),s=b(r,a(t));u.strictEqual(o[5],s)}),test("get next element to focus after removing a file match when it is only match",function(){const t=i(),e=[t,a(t)],n=l(e),o=e[0],r=d(n,o,[]);u.strictEqual(void 0,r)});function i(){const t={resource:M.file("somepath"+ ++h),results:[]},e=c.createInstance(E);m.add(e);const n=c.createInstance(T,M.file("somepath"),"",0,{type:S.Text,folderQueries:[{folder:x()}],contentPattern:{pattern:""}},e.searchResult,e.searchResult,null);m.add(n);const o=c.createInstance(I,{pattern:""},void 0,void 0,n,t,null,"");return o.createMatches(!1),m.add(o),o}function a(t){const e=++h,n=new w(t,["some match"],{startLineNumber:0,startColumn:0,endLineNumber:0,endColumn:2},{startLineNumber:e,startColumn:0,endLineNumber:e,endColumn:2},!1);return t.add(n),n}function l(t){return new L(t)}});
