import e from"assert";import*as n from"../../../../../base/common/errors.js";import{QueryType as y}from"../../../../services/search/common/search.js";import{FileQueryCacheState as h}from"../../common/cacheState.js";import{DeferredPromise as u}from"../../../../../base/common/async.js";import{ensureNoDisposablesAreLeakedInTestSuite as g}from"../../../../../base/test/common/utils.js";suite("FileQueryCacheState",()=>{g(),test("reuse old cacheKey until new cache is loaded",async function(){const t=new r,a=c(t),i=a.cacheKey;e.strictEqual(a.isLoaded,!1),e.strictEqual(a.isUpdating,!1),a.load(),e.strictEqual(a.isLoaded,!1),e.strictEqual(a.isUpdating,!0),await t.loading[i].complete(null),e.strictEqual(a.isLoaded,!0),e.strictEqual(a.isUpdating,!1);const s=c(t,a);s.load(),e.strictEqual(s.isLoaded,!0),e.strictEqual(s.isUpdating,!0),await t.awaitDisposal(0),e.strictEqual(s.cacheKey,i);const l=t.cacheKeys[1];await t.loading[l].complete(null),e.strictEqual(s.isLoaded,!0),e.strictEqual(s.isUpdating,!1),await t.awaitDisposal(1),e.strictEqual(s.cacheKey,l)}),test("do not spawn additional load if previous is still loading",async function(){const t=new r,a=c(t),i=a.cacheKey;a.load(),e.strictEqual(a.isLoaded,!1),e.strictEqual(a.isUpdating,!0),e.strictEqual(Object.keys(t.loading).length,1);const s=c(t,a);s.load(),e.strictEqual(s.isLoaded,!1),e.strictEqual(s.isUpdating,!0),e.strictEqual(t.cacheKeys.length,2),e.strictEqual(Object.keys(t.loading).length,1),e.strictEqual(s.cacheKey,i),await t.loading[i].complete(null),e.strictEqual(s.isLoaded,!0),e.strictEqual(s.isUpdating,!1),await t.awaitDisposal(0)}),test("do not use previous cacheKey if query changed",async function(){const t=new r,a=c(t),i=a.cacheKey;a.load(),await t.loading[i].complete(null),e.strictEqual(a.isLoaded,!0),e.strictEqual(a.isUpdating,!1),await t.awaitDisposal(0),t.baseQuery.excludePattern={"**/node_modules":!0};const s=c(t,a);e.strictEqual(s.isLoaded,!1),e.strictEqual(s.isUpdating,!1),await t.awaitDisposal(1),s.load(),e.strictEqual(s.isLoaded,!1),e.strictEqual(s.isUpdating,!0),e.notStrictEqual(s.cacheKey,i);const l=t.cacheKeys[1];e.strictEqual(s.cacheKey,l),await t.loading[l].complete(null),e.strictEqual(s.isLoaded,!0),e.strictEqual(s.isUpdating,!1),await t.awaitDisposal(1)}),test("dispose propagates",async function(){const t=new r,a=c(t),i=a.cacheKey;a.load(),await t.loading[i].complete(null);const s=c(t,a);e.strictEqual(s.isLoaded,!0),e.strictEqual(s.isUpdating,!1),await t.awaitDisposal(0),s.dispose(),e.strictEqual(s.isLoaded,!1),e.strictEqual(s.isUpdating,!1),await t.awaitDisposal(1),e.ok(t.disposing[i])}),test("keep using old cacheKey when loading fails",async function(){const t=new r,a=c(t),i=a.cacheKey;a.load(),await t.loading[i].complete(null);const s=c(t,a);s.load();const l=t.cacheKeys[1],p=n.errorHandler.getUnexpectedErrorHandler();try{n.setUnexpectedErrorHandler(()=>null),await t.loading[l].error("loading failed")}finally{n.setUnexpectedErrorHandler(p)}e.strictEqual(s.isLoaded,!0),e.strictEqual(s.isUpdating,!1),e.strictEqual(Object.keys(t.loading).length,2),await t.awaitDisposal(0),e.strictEqual(s.cacheKey,i);const o=c(t,s);o.load(),e.strictEqual(o.isLoaded,!0),e.strictEqual(o.isUpdating,!0),e.strictEqual(Object.keys(t.loading).length,3),await t.awaitDisposal(0),e.strictEqual(o.cacheKey,i);const d=t.cacheKeys[2];await t.loading[d].complete(null),e.strictEqual(o.isLoaded,!0),e.strictEqual(o.isUpdating,!1),e.strictEqual(Object.keys(t.loading).length,3),await t.awaitDisposal(2),e.strictEqual(o.cacheKey,d)});function c(t,a){return new h(i=>t.query(i),i=>t.load(i),i=>t.dispose(i),a)}class r{cacheKeys=[];loading={};disposing={};_awaitDisposal=[];baseQuery={type:y.File,folderQueries:[]};query(a){return this.cacheKeys.push(a),Object.assign({cacheKey:a},this.baseQuery)}load(a){const i=new u;return this.loading[a.cacheKey]=i,i.p}dispose(a){const i=new u;this.disposing[a]=i;const s=Object.keys(this.disposing).length;for(const l of this._awaitDisposal[s]||[])l();return delete this._awaitDisposal[s],i.p}awaitDisposal(a){return new Promise(i=>{a===Object.keys(this.disposing).length?i():(this._awaitDisposal[a]||(this._awaitDisposal[a]=[])).push(i)})}}});
