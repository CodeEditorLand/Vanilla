import{promiseWithResolvers as n}from"../../../../base/common/async.js";import{CancellationToken as v}from"../../../../base/common/cancellation.js";import{Emitter as a}from"../../../../base/common/event.js";import{Disposable as l,toDisposable as w}from"../../../../base/common/lifecycle.js";import{createDecorator as d}from"../../../../platform/instantiation/common/instantiation.js";import"../../../common/views.js";import"../../webview/browser/webview.js";const I=d("webviewViewService");class D extends l{_serviceBrand;_resolvers=new Map;_awaitingRevival=new Map;_onNewResolverRegistered=this._register(new a);onNewResolverRegistered=this._onNewResolverRegistered.event;register(e,i){if(this._resolvers.has(e))throw new Error(`View resolver already registered for ${e}`);this._resolvers.set(e,i),this._onNewResolverRegistered.fire({viewType:e});const r=this._awaitingRevival.get(e);return r&&i.resolve(r.webview,v.None).then(()=>{this._awaitingRevival.delete(e),r.resolve()}),w(()=>{this._resolvers.delete(e)})}resolve(e,i,r){const o=this._resolvers.get(e);if(!o){if(this._awaitingRevival.has(e))throw new Error("View already awaiting revival");const{promise:s,resolve:t}=n();return this._awaitingRevival.set(e,{webview:i,resolve:t}),s}return o.resolve(i,r)}}export{I as IWebviewViewService,D as WebviewViewService};
