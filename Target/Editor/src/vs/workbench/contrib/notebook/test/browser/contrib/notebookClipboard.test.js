import e from"assert";import{mock as s}from"../../../../../../base/test/common/mock.js";import{NotebookClipboardContribution as k,runCopyCells as h,runCutCells as g}from"../../../browser/contrib/clipboard/notebookClipboard.js";import{CellKind as r,NOTEBOOK_EDITOR_ID as f,SelectionStateType as d}from"../../../common/notebookCommon.js";import{withTestNotebook as c}from"../testNotebookEditor.js";import"../../../../../services/editor/common/editorService.js";import"../../../browser/notebookBrowser.js";import"../../../../../common/editor.js";import{INotebookService as u}from"../../../common/notebookService.js";import{FoldingModel as b,updateFoldingStateAtIndex as m}from"../../../browser/viewModel/foldingModel.js";import"../../../common/model/notebookCellTextModel.js";import{ensureNoDisposablesAreLeakedInTestSuite as E}from"../../../../../../base/test/common/utils.js";suite("Notebook Clipboard",()=>{E();const p=o=>{const t=new class extends s(){getId(){return f}getControl(){return o}};return new class extends s(){get activeEditorPane(){return t}}};test.skip("Cut multiple selected cells",async function(){await c([["# header 1","markdown",r.Markup,[],{}],["paragraph 1","markdown",r.Markup,[],{}],["paragraph 2","markdown",r.Markup,[],{}]],async(o,t,i,a)=>{a.stub(u,new class extends s(){setToCopy(){}});const n=new k(p(o));t.updateSelectionsState({kind:d.Index,focus:{start:0,end:2},selections:[{start:0,end:2}]},"model"),e.ok(n.runCutAction(a)),e.deepStrictEqual(t.getFocus(),{start:0,end:1}),e.strictEqual(t.length,1),e.strictEqual(t.cellAt(0)?.getText(),"paragraph 2")})}),test.skip("Cut should take folding info into account",async function(){await c([["# header a","markdown",r.Markup,[],{}],["var b = 1;","javascript",r.Code,[],{}],["# header b","markdown",r.Markup,[],{}],["var b = 2;","javascript",r.Code,[],{}],["var c = 3","javascript",r.Markup,[],{}],["# header d","markdown",r.Markup,[],{}],["var e = 4;","javascript",r.Code,[],{}]],async(o,t,i,a)=>{const n=new b;n.attachViewModel(t),m(n,0,!0),m(n,2,!0),t.updateFoldingRanges(n.regions),o.setHiddenAreas(t.getHiddenRanges()),t.updateSelectionsState({kind:d.Index,focus:{start:0,end:1},selections:[{start:0,end:1}]},"model"),a.stub(u,new class extends s(){setToCopy(){}}),new k(p(o)).runCutAction(a),e.strictEqual(t.length,5),await t.undo(),e.strictEqual(t.length,7)})}),test.skip("Copy should take folding info into account",async function(){await c([["# header a","markdown",r.Markup,[],{}],["var b = 1;","javascript",r.Code,[],{}],["# header b","markdown",r.Markup,[],{}],["var b = 2;","javascript",r.Code,[],{}],["var c = 3","javascript",r.Markup,[],{}],["# header d","markdown",r.Markup,[],{}],["var e = 4;","javascript",r.Code,[],{}]],async(o,t,i,a)=>{const n=new b;n.attachViewModel(t),m(n,0,!0),m(n,2,!0),t.updateFoldingRanges(n.regions),o.setHiddenAreas(t.getHiddenRanges()),t.updateSelectionsState({kind:d.Index,focus:{start:0,end:1},selections:[{start:0,end:1}]},"model");let l=[];a.stub(u,new class extends s(){setToCopy(C){l=C}getToCopy(){return{items:l,isCopy:!0}}});const S=new k(p(o));S.runCopyAction(a),t.updateSelectionsState({kind:d.Index,focus:{start:6,end:7},selections:[{start:6,end:7}]},"model"),S.runPasteAction(a),e.strictEqual(t.length,9),e.strictEqual(t.cellAt(8)?.getText(),"var b = 1;")})}),test.skip("#119773, cut last item should not focus on the top first cell",async function(){await c([["# header 1","markdown",r.Markup,[],{}],["paragraph 1","markdown",r.Markup,[],{}],["paragraph 2","markdown",r.Markup,[],{}]],async(o,t,i,a)=>{a.stub(u,new class extends s(){setToCopy(){}});const n=new k(p(o));t.updateSelectionsState({kind:d.Index,focus:{start:2,end:3},selections:[{start:2,end:3}]},"model"),e.ok(n.runCutAction(a)),e.deepStrictEqual(t.getFocus(),{start:1,end:2})})}),test.skip("#119771, undo paste should restore selections",async function(){await c([["# header 1","markdown",r.Markup,[],{}],["paragraph 1","markdown",r.Markup,[],{}],["paragraph 2","markdown",r.Markup,[],{}]],async(o,t,i,a)=>{a.stub(u,new class extends s(){setToCopy(){}getToCopy(){return{items:[t.cellAt(0).model],isCopy:!0}}});const n=new k(p(o));t.updateSelectionsState({kind:d.Index,focus:{start:2,end:3},selections:[{start:2,end:3}]},"model"),e.ok(n.runPasteAction(a)),e.strictEqual(t.length,4),e.deepStrictEqual(t.getFocus(),{start:3,end:4}),e.strictEqual(t.cellAt(3)?.getText(),"# header 1"),await t.undo(),e.strictEqual(t.length,3),e.deepStrictEqual(t.getFocus(),{start:2,end:3})})}),test("copy cell from ui still works if the target cell is not part of a selection",async()=>{await c([["# header 1","markdown",r.Markup,[],{}],["paragraph 1","markdown",r.Markup,[],{}],["paragraph 2","markdown",r.Markup,[],{}]],async(o,t,i,a)=>{let n=[];a.stub(u,new class extends s(){setToCopy(l){n=l}getToCopy(){return{items:n,isCopy:!0}}}),t.updateSelectionsState({kind:d.Index,focus:{start:0,end:1},selections:[{start:0,end:2}]},"model"),e.ok(h(a,o,t.cellAt(0))),e.deepStrictEqual(n,[t.cellAt(0).model,t.cellAt(1).model]),e.ok(h(a,o,t.cellAt(2))),e.deepStrictEqual(n.length,1),e.deepStrictEqual(n,[t.cellAt(2).model])})}),test("cut cell from ui still works if the target cell is not part of a selection",async()=>{await c([["# header 1","markdown",r.Markup,[],{}],["paragraph 1","markdown",r.Markup,[],{}],["paragraph 2","markdown",r.Markup,[],{}],["paragraph 3","markdown",r.Markup,[],{}]],async(o,t,i,a)=>{a.stub(u,new class extends s(){setToCopy(){}getToCopy(){return{items:[],isCopy:!0}}}),t.updateSelectionsState({kind:d.Index,focus:{start:0,end:1},selections:[{start:0,end:2}]},"model"),e.ok(g(a,o,t.cellAt(0))),e.strictEqual(t.length,2),await t.undo(),e.strictEqual(t.length,4),e.deepStrictEqual(t.getFocus(),{start:0,end:1}),e.deepStrictEqual(t.getSelections(),[{start:0,end:2}]),e.ok(g(a,o,t.cellAt(2))),e.strictEqual(t.length,3),e.deepStrictEqual(t.getFocus(),{start:0,end:1}),e.strictEqual(t.cellAt(0)?.getText(),"# header 1"),e.strictEqual(t.cellAt(1)?.getText(),"paragraph 1"),e.strictEqual(t.cellAt(2)?.getText(),"paragraph 3"),await t.undo(),e.strictEqual(t.length,4),t.updateSelectionsState({kind:d.Index,focus:{start:2,end:3},selections:[{start:2,end:4}]},"model"),e.deepStrictEqual(t.getFocus(),{start:2,end:3}),e.ok(g(a,o,t.cellAt(0))),e.deepStrictEqual(t.getFocus(),{start:1,end:2}),e.deepStrictEqual(t.getSelections(),[{start:1,end:3}])})}),test("cut focus cell still works if the focus is not part of any selection",async()=>{await c([["# header 1","markdown",r.Markup,[],{}],["paragraph 1","markdown",r.Markup,[],{}],["paragraph 2","markdown",r.Markup,[],{}],["paragraph 3","markdown",r.Markup,[],{}]],async(o,t,i,a)=>{a.stub(u,new class extends s(){setToCopy(){}getToCopy(){return{items:[],isCopy:!0}}}),t.updateSelectionsState({kind:d.Index,focus:{start:0,end:1},selections:[{start:2,end:4}]},"model"),e.ok(g(a,o,void 0)),e.strictEqual(t.length,3),e.deepStrictEqual(t.getFocus(),{start:0,end:1}),e.deepStrictEqual(t.getSelections(),[{start:1,end:3}])})}),test("cut focus cell still works if the focus is not part of any selection 2",async()=>{await c([["# header 1","markdown",r.Markup,[],{}],["paragraph 1","markdown",r.Markup,[],{}],["paragraph 2","markdown",r.Markup,[],{}],["paragraph 3","markdown",r.Markup,[],{}]],async(o,t,i,a)=>{a.stub(u,new class extends s(){setToCopy(){}getToCopy(){return{items:[],isCopy:!0}}}),t.updateSelectionsState({kind:d.Index,focus:{start:3,end:4},selections:[{start:0,end:2}]},"model"),e.ok(g(a,o,void 0)),e.strictEqual(t.length,3),e.deepStrictEqual(t.getFocus(),{start:2,end:3}),e.deepStrictEqual(t.getSelections(),[{start:0,end:2}])})})});
