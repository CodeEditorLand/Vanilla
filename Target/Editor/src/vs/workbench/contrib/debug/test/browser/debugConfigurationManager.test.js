import s from"assert";import{CancellationToken as c}from"../../../../../base/common/cancellation.js";import{Event as m}from"../../../../../base/common/event.js";import{DisposableStore as C}from"../../../../../base/common/lifecycle.js";import{URI as b}from"../../../../../base/common/uri.js";import{ensureNoDisposablesAreLeakedInTestSuite as y}from"../../../../../base/test/common/utils.js";import{IConfigurationService as S}from"../../../../../platform/configuration/common/configuration.js";import{TestConfigurationService as I}from"../../../../../platform/configuration/test/common/testConfigurationService.js";import{ContextKeyService as w}from"../../../../../platform/contextkey/browser/contextKeyService.js";import{FileService as D}from"../../../../../platform/files/common/fileService.js";import{ServiceCollection as P}from"../../../../../platform/instantiation/common/serviceCollection.js";import{TestInstantiationService as E}from"../../../../../platform/instantiation/test/common/instantiationServiceMock.js";import{NullLogService as f}from"../../../../../platform/log/common/log.js";import{UriIdentityService as T}from"../../../../../platform/uriIdentity/common/uriIdentityService.js";import{ConfigurationManager as q}from"../../browser/debugConfigurationManager.js";import{DebugConfigurationProviderTriggerKind as d}from"../../common/debug.js";import{IPreferencesService as M}from"../../../../services/preferences/common/preferences.js";import{TestQuickInputService as N}from"../../../../test/browser/workbenchTestServices.js";import{TestHistoryService as R,TestContextService as k,TestExtensionService as x,TestStorageService as A}from"../../../../test/common/workbenchTestServices.js";suite("debugConfigurationManager",()=>{const r="custom-type";let t,o;const p={getDebugAdapterDescriptor(e,i){return Promise.resolve(void 0)},activateDebuggers(e,i){return Promise.resolve()},get onDidDebuggersExtPointRead(){return m.None}},l={userSettingsResource:b.file("/tmp/settings.json")},u=new I;setup(()=>{o=new C;const e=o.add(new D(new f)),i=o.add(new E(new P([M,l],[S,u])));t=new q(p,new k,u,new N,i,new A,new x,new R,new T(e),new w(u),new f)}),teardown(()=>o.dispose()),y(),test("resolves configuration based on type",async()=>{o.add(t.registerDebugConfigurationProvider({type:r,resolveDebugConfiguration:(g,a,n)=>(s.strictEqual(a.type,r),Promise.resolve({...a,configurationResolved:!0})),triggerKind:d.Initial}));const e={type:r,request:"launch",name:"configName"},i=await t.resolveConfigurationByProviders(void 0,r,e,c.None);s.strictEqual(i.configurationResolved,!0,"Configuration should be updated by test provider")}),test("resolves configuration from second provider if type changes",async()=>{const e="second-provider";o.add(t.registerDebugConfigurationProvider({type:r,resolveDebugConfiguration:(a,n,v)=>(s.strictEqual(n.type,r),Promise.resolve({...n,type:e})),triggerKind:d.Initial})),o.add(t.registerDebugConfigurationProvider({type:e,resolveDebugConfiguration:(a,n,v)=>(s.strictEqual(n.type,e),Promise.resolve({...n,configurationResolved:!0})),triggerKind:d.Initial}));const i={type:r,request:"launch",name:"configName"},g=await t.resolveConfigurationByProviders(void 0,r,i,c.None);s.strictEqual(g.type,e),s.strictEqual(g.configurationResolved,!0,"Configuration should be updated by test provider")}),teardown(()=>o.clear())});
