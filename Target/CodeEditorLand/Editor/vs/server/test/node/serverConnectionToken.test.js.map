{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/server/test/node/serverConnectionToken.test.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport * as fs from 'fs';\nimport * as os from 'os';\nimport * as path from 'path';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../base/test/common/utils.js';\nimport { getRandomTestPath } from '../../../base/test/node/testUtils.js';\nimport { parseServerConnectionToken, ServerConnectionToken, ServerConnectionTokenParseError, ServerConnectionTokenType } from '../../node/serverConnectionToken.js';\nimport { ServerParsedArgs } from '../../node/serverEnvironmentService.js';\n\nsuite('parseServerConnectionToken', () => {\n\tensureNoDisposablesAreLeakedInTestSuite();\n\n\tfunction isError(r: ServerConnectionToken | ServerConnectionTokenParseError): r is ServerConnectionTokenParseError {\n\t\treturn (r instanceof ServerConnectionTokenParseError);\n\t}\n\n\tfunction assertIsError(r: ServerConnectionToken | ServerConnectionTokenParseError): void {\n\t\tassert.strictEqual(isError(r), true);\n\t}\n\n\ttest('no arguments generates a token that is mandatory', async () => {\n\t\tconst result = await parseServerConnectionToken({} as ServerParsedArgs, async () => 'defaultTokenValue');\n\t\tassert.ok(!(result instanceof ServerConnectionTokenParseError));\n\t\tassert.ok(result.type === ServerConnectionTokenType.Mandatory);\n\t});\n\n\ttest('--without-connection-token', async () => {\n\t\tconst result = await parseServerConnectionToken({ 'without-connection-token': true } as ServerParsedArgs, async () => 'defaultTokenValue');\n\t\tassert.ok(!(result instanceof ServerConnectionTokenParseError));\n\t\tassert.ok(result.type === ServerConnectionTokenType.None);\n\t});\n\n\ttest('--without-connection-token --connection-token results in error', async () => {\n\t\tassertIsError(await parseServerConnectionToken({ 'without-connection-token': true, 'connection-token': '0' } as ServerParsedArgs, async () => 'defaultTokenValue'));\n\t});\n\n\ttest('--without-connection-token --connection-token-file results in error', async () => {\n\t\tassertIsError(await parseServerConnectionToken({ 'without-connection-token': true, 'connection-token-file': '0' } as ServerParsedArgs, async () => 'defaultTokenValue'));\n\t});\n\n\ttest('--connection-token-file --connection-token results in error', async () => {\n\t\tassertIsError(await parseServerConnectionToken({ 'connection-token-file': '0', 'connection-token': '0' } as ServerParsedArgs, async () => 'defaultTokenValue'));\n\t});\n\n\ttest('--connection-token-file', async function () {\n\t\tthis.timeout(10000);\n\t\tconst testDir = getRandomTestPath(os.tmpdir(), 'vsctests', 'server-connection-token');\n\t\tfs.mkdirSync(testDir, { recursive: true });\n\t\tconst filename = path.join(testDir, 'connection-token-file');\n\t\tconst connectionToken = `12345-123-abc`;\n\t\tfs.writeFileSync(filename, connectionToken);\n\t\tconst result = await parseServerConnectionToken({ 'connection-token-file': filename } as ServerParsedArgs, async () => 'defaultTokenValue');\n\t\tassert.ok(!(result instanceof ServerConnectionTokenParseError));\n\t\tassert.ok(result.type === ServerConnectionTokenType.Mandatory);\n\t\tassert.strictEqual(result.value, connectionToken);\n\t\tfs.rmSync(testDir, { recursive: true, force: true });\n\t});\n\n\ttest('--connection-token', async () => {\n\t\tconst connectionToken = `12345-123-abc`;\n\t\tconst result = await parseServerConnectionToken({ 'connection-token': connectionToken } as ServerParsedArgs, async () => 'defaultTokenValue');\n\t\tassert.ok(!(result instanceof ServerConnectionTokenParseError));\n\t\tassert.ok(result.type === ServerConnectionTokenType.Mandatory);\n\t\tassert.strictEqual(result.value, connectionToken);\n\t});\n\n});\n"],
  "mappings": ";;AAKA,OAAO,YAAY;AACnB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,UAAU;AACtB,SAAS,+CAA+C;AACxD,SAAS,yBAAyB;AAClC,SAAS,4BAA4B,uBAAuB,iCAAiC,iCAAiC;AAC9H,SAAS,wBAAwB;AAEjC,MAAM,8BAA8B,MAAM;AACzC,0CAAwC;AAExC,WAAS,QAAQ,GAAkG;AAClH,WAAQ,aAAa;AAAA,EACtB;AAFS;AAIT,WAAS,cAAc,GAAkE;AACxF,WAAO,YAAY,QAAQ,CAAC,GAAG,IAAI;AAAA,EACpC;AAFS;AAIT,OAAK,oDAAoD,YAAY;AACpE,UAAM,SAAS,MAAM,2BAA2B,CAAC,GAAuB,YAAY,mBAAmB;AACvG,WAAO,GAAG,EAAE,kBAAkB,gCAAgC;AAC9D,WAAO,GAAG,OAAO,SAAS,0BAA0B,SAAS;AAAA,EAC9D,CAAC;AAED,OAAK,8BAA8B,YAAY;AAC9C,UAAM,SAAS,MAAM,2BAA2B,EAAE,4BAA4B,KAAK,GAAuB,YAAY,mBAAmB;AACzI,WAAO,GAAG,EAAE,kBAAkB,gCAAgC;AAC9D,WAAO,GAAG,OAAO,SAAS,0BAA0B,IAAI;AAAA,EACzD,CAAC;AAED,OAAK,kEAAkE,YAAY;AAClF,kBAAc,MAAM,2BAA2B,EAAE,4BAA4B,MAAM,oBAAoB,IAAI,GAAuB,YAAY,mBAAmB,CAAC;AAAA,EACnK,CAAC;AAED,OAAK,uEAAuE,YAAY;AACvF,kBAAc,MAAM,2BAA2B,EAAE,4BAA4B,MAAM,yBAAyB,IAAI,GAAuB,YAAY,mBAAmB,CAAC;AAAA,EACxK,CAAC;AAED,OAAK,+DAA+D,YAAY;AAC/E,kBAAc,MAAM,2BAA2B,EAAE,yBAAyB,KAAK,oBAAoB,IAAI,GAAuB,YAAY,mBAAmB,CAAC;AAAA,EAC/J,CAAC;AAED,OAAK,2BAA2B,iBAAkB;AACjD,SAAK,QAAQ,GAAK;AAClB,UAAM,UAAU,kBAAkB,GAAG,OAAO,GAAG,YAAY,yBAAyB;AACpF,OAAG,UAAU,SAAS,EAAE,WAAW,KAAK,CAAC;AACzC,UAAM,WAAW,KAAK,KAAK,SAAS,uBAAuB;AAC3D,UAAM,kBAAkB;AACxB,OAAG,cAAc,UAAU,eAAe;AAC1C,UAAM,SAAS,MAAM,2BAA2B,EAAE,yBAAyB,SAAS,GAAuB,YAAY,mBAAmB;AAC1I,WAAO,GAAG,EAAE,kBAAkB,gCAAgC;AAC9D,WAAO,GAAG,OAAO,SAAS,0BAA0B,SAAS;AAC7D,WAAO,YAAY,OAAO,OAAO,eAAe;AAChD,OAAG,OAAO,SAAS,EAAE,WAAW,MAAM,OAAO,KAAK,CAAC;AAAA,EACpD,CAAC;AAED,OAAK,sBAAsB,YAAY;AACtC,UAAM,kBAAkB;AACxB,UAAM,SAAS,MAAM,2BAA2B,EAAE,oBAAoB,gBAAgB,GAAuB,YAAY,mBAAmB;AAC5I,WAAO,GAAG,EAAE,kBAAkB,gCAAgC;AAC9D,WAAO,GAAG,OAAO,SAAS,0BAA0B,SAAS;AAC7D,WAAO,YAAY,OAAO,OAAO,eAAe;AAAA,EACjD,CAAC;AAEF,CAAC;",
  "names": []
}
