import{isAbsolute as I,join as v,resolve as S}from"../../base/common/path.js";import*as d from"../../base/common/platform.js";import{cwd as _}from"../../base/common/process.js";import{URI as p}from"../../base/common/uri.js";import*as E from"../../base/common/performance.js";import"../../base/common/event.js";import{transformOutgoingURIs as w}from"../../base/common/uriIpc.js";import"../../base/parts/ipc/common/ipc.js";import{ContextKeyDefinedExpr as R,ContextKeyEqualsExpr as u,ContextKeyExpr as C,ContextKeyGreaterEqualsExpr as U,ContextKeyGreaterExpr as P,ContextKeyInExpr as K,ContextKeyNotEqualsExpr as g,ContextKeyNotExpr as b,ContextKeyNotInExpr as D,ContextKeyRegexExpr as h,ContextKeySmallerEqualsExpr as W,ContextKeySmallerExpr as L}from"../../platform/contextkey/common/contextkey.js";import"../../platform/extensionManagement/common/extensionManagement.js";import"../../platform/extensionManagement/common/extensionManagementCLI.js";import{toExtensionDescription as m}from"../../platform/extensionManagement/common/extensionsScannerService.js";import{ExtensionType as f}from"../../platform/extensions/common/extensions.js";import"../../platform/log/common/log.js";import"../../platform/userDataProfile/common/userDataProfile.js";import"./serverEnvironmentService.js";import{dedupExtensions as k}from"../../workbench/services/extensions/common/extensionsUtil.js";import{Schemas as A}from"../../base/common/network.js";import"../../platform/remote/common/remoteExtensionsScanner.js";import"../../platform/languagePacks/common/languagePacks.js";class ue{constructor(r,n,t,o,i,c,a){this._extensionManagementCLI=r;this._userDataProfilesService=t;this._extensionsScannerService=o;this._logService=i;this._extensionGalleryService=c;this._languagePackService=a;const e=n.args["install-builtin-extension"];if(e){i.trace("Installing builtin extensions passed via args...");const x={isMachineScoped:!!n.args["do-not-sync"],installPreReleaseVersion:!!n.args["pre-release"]};E.mark("code/server/willInstallBuiltinExtensions"),this._whenExtensionsReady=this._whenBuiltinExtensionsReady=r.installExtensions([],this._asExtensionIdOrVSIX(e),x,!!n.args.force).then(()=>{E.mark("code/server/didInstallBuiltinExtensions"),i.trace("Finished installing builtin extensions")},l=>{i.error(l)})}const s=n.args["install-extension"];s&&(i.trace("Installing extensions passed via args..."),this._whenExtensionsReady=this._whenBuiltinExtensionsReady.then(()=>r.installExtensions(this._asExtensionIdOrVSIX(s),[],{isMachineScoped:!!n.args["do-not-sync"],installPreReleaseVersion:!!n.args["pre-release"],isApplicationScoped:!0},!!n.args.force)).then(()=>{i.trace("Finished installing extensions")},x=>{i.error(x)}))}_serviceBrand;_whenBuiltinExtensionsReady=Promise.resolve();_whenExtensionsReady=Promise.resolve();_asExtensionIdOrVSIX(r){return r.map(n=>/\.vsix$/i.test(n)?p.file(I(n)?n:v(_(),n)):n)}whenExtensionsReady(){return this._whenExtensionsReady}async scanExtensions(r,n,t,o,i){E.mark("code/server/willScanExtensions"),this._logService.trace(`Scanning extensions using UI language: ${r}`),await this._whenBuiltinExtensionsReady;const c=o?o.filter(e=>e.scheme===A.file).map(e=>e.fsPath):void 0;n=n??this._userDataProfilesService.defaultProfile.extensionsResource;const a=await this._scanExtensions(n,r??d.language,t,c,i);return this._logService.trace("Scanned Extensions",a),this._massageWhenConditions(a),E.mark("code/server/didScanExtensions"),a}async _scanExtensions(r,n,t,o,i){await this._ensureLanguagePackIsInstalled(n,i);const[c,a,e,s]=await Promise.all([this._scanBuiltinExtensions(n),this._scanInstalledExtensions(r,n),this._scanWorkspaceInstalledExtensions(n,t),this._scanDevelopedExtensions(n,o)]);return k(c,a,e,s,this._logService)}async _scanDevelopedExtensions(r,n){return n?(await Promise.all(n.map(t=>this._extensionsScannerService.scanOneOrMultipleExtensions(p.file(S(t)),f.User,{language:r})))).flat().map(t=>m(t,!0)):[]}async _scanWorkspaceInstalledExtensions(r,n){const t=[];if(n?.length){const o=await Promise.all(n.map(i=>this._extensionsScannerService.scanExistingExtension(i,f.User,{language:r})));for(const i of o)i&&t.push(m(i,!1))}return t}async _scanBuiltinExtensions(r){return(await this._extensionsScannerService.scanSystemExtensions({language:r,useCache:!0})).map(t=>m(t,!1))}async _scanInstalledExtensions(r,n){return(await this._extensionsScannerService.scanUserExtensions({profileLocation:r,language:n,useCache:!0})).map(o=>m(o,!1))}async _ensureLanguagePackIsInstalled(r,n){if(!(r===d.LANGUAGE_DEFAULT||!this._extensionGalleryService.isEnabled())){try{if((await this._languagePackService.getInstalledLanguages()).find(o=>o.id===r)){this._logService.trace(`Language Pack ${r} is already installed. Skipping language pack installation.`);return}}catch(t){this._logService.error(t)}if(!n){this._logService.trace(`No language pack id provided for language ${r}. Skipping language pack installation.`);return}this._logService.trace(`Language Pack ${n} for language ${r} is not installed. It will be installed now.`);try{await this._extensionManagementCLI.installExtensions([n],[],{isMachineScoped:!0},!0)}catch(t){this._logService.error(t)}}}_massageWhenConditions(r){const n=(e,s)=>e.replace(/file/g,"vscode-remote"),t=e=>{let s="";return s+=e.global?"g":"",s+=e.ignoreCase?"i":"",s+=e.multiline?"m":"",new RegExp(n(e.source,!0),s)},o=new class{mapDefined(e){return R.create(e)}mapNot(e){return b.create(e)}mapEquals(e,s){return e==="resourceScheme"&&typeof s=="string"?u.create(e,n(s,!1)):u.create(e,s)}mapNotEquals(e,s){return e==="resourceScheme"&&typeof s=="string"?g.create(e,n(s,!1)):g.create(e,s)}mapGreater(e,s){return P.create(e,s)}mapGreaterEquals(e,s){return U.create(e,s)}mapSmaller(e,s){return L.create(e,s)}mapSmallerEquals(e,s){return W.create(e,s)}mapRegex(e,s){return e==="resourceScheme"&&s?h.create(e,t(s)):h.create(e,s)}mapIn(e,s){return K.create(e,s)}mapNotIn(e,s){return D.create(e,s)}},i=e=>{if(!e||!e.when||!/resourceScheme/.test(e.when))return;const s=C.deserialize(e.when);if(!s)return;const x=s.map(o);e.when=x.serialize()},c=e=>{if(Array.isArray(e))for(const s of e)i(s);else i(e)},a=e=>{for(const s in e)c(e[s])};r.forEach(e=>{e.contributes&&(e.contributes.menus&&a(e.contributes.menus),e.contributes.keybindings&&c(e.contributes.keybindings),e.contributes.views&&a(e.contributes.views))})}}class ge{constructor(r,n){this.service=r;this.getUriTransformer=n}listen(r,n){throw new Error("Invalid listen")}async call(r,n,t){const o=this.getUriTransformer(r);switch(n){case"whenExtensionsReady":return this.service.whenExtensionsReady();case"scanExtensions":{const i=t[0],c=t[1]?p.revive(o.transformIncoming(t[1])):void 0,a=Array.isArray(t[2])?t[2].map(l=>p.revive(o.transformIncoming(l))):void 0,e=Array.isArray(t[3])?t[3].map(l=>p.revive(o.transformIncoming(l))):void 0,s=t[4];return(await this.service.scanExtensions(i,c,a,e,s)).map(l=>w(l,o))}}throw new Error("Invalid call")}}export{ge as RemoteExtensionsScannerChannel,ue as RemoteExtensionsScannerService};
