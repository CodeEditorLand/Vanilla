import{Schemas as I}from"../../base/common/network.js";import{isAbsolute as v,join as S,resolve as _}from"../../base/common/path.js";import*as m from"../../base/common/performance.js";import*as d from"../../base/common/platform.js";import{cwd as w}from"../../base/common/process.js";import{URI as x}from"../../base/common/uri.js";import{transformOutgoingURIs as R}from"../../base/common/uriIpc.js";import{ContextKeyDefinedExpr as C,ContextKeyEqualsExpr as u,ContextKeyExpr as U,ContextKeyGreaterEqualsExpr as P,ContextKeyGreaterExpr as K,ContextKeyInExpr as b,ContextKeyNotEqualsExpr as g,ContextKeyNotExpr as D,ContextKeyNotInExpr as L,ContextKeyRegexExpr as f,ContextKeySmallerEqualsExpr as W,ContextKeySmallerExpr as k}from"../../platform/contextkey/common/contextkey.js";import{toExtensionDescription as E}from"../../platform/extensionManagement/common/extensionsScannerService.js";import{ExtensionType as h}from"../../platform/extensions/common/extensions.js";import{dedupExtensions as M}from"../../workbench/services/extensions/common/extensionsUtil.js";class ${constructor(r,n,t,o,i,c,a){this._extensionManagementCLI=r;this._userDataProfilesService=t;this._extensionsScannerService=o;this._logService=i;this._extensionGalleryService=c;this._languagePackService=a;const e=n.args["install-builtin-extension"];if(e){i.trace("Installing builtin extensions passed via args...");const p={isMachineScoped:!!n.args["do-not-sync"],installPreReleaseVersion:!!n.args["pre-release"]};m.mark("code/server/willInstallBuiltinExtensions"),this._whenExtensionsReady=this._whenBuiltinExtensionsReady=r.installExtensions([],this._asExtensionIdOrVSIX(e),p,!!n.args.force).then(()=>{m.mark("code/server/didInstallBuiltinExtensions"),i.trace("Finished installing builtin extensions")},l=>{i.error(l)})}const s=n.args["install-extension"];s&&(i.trace("Installing extensions passed via args..."),this._whenExtensionsReady=this._whenBuiltinExtensionsReady.then(()=>r.installExtensions(this._asExtensionIdOrVSIX(s),[],{isMachineScoped:!!n.args["do-not-sync"],installPreReleaseVersion:!!n.args["pre-release"],isApplicationScoped:!0},!!n.args.force)).then(()=>{i.trace("Finished installing extensions")},p=>{i.error(p)}))}_serviceBrand;_whenBuiltinExtensionsReady=Promise.resolve();_whenExtensionsReady=Promise.resolve();_asExtensionIdOrVSIX(r){return r.map(n=>/\.vsix$/i.test(n)?x.file(v(n)?n:S(w(),n)):n)}whenExtensionsReady(){return this._whenExtensionsReady}async scanExtensions(r,n,t,o,i){m.mark("code/server/willScanExtensions"),this._logService.trace(`Scanning extensions using UI language: ${r}`),await this._whenBuiltinExtensionsReady;const c=o?o.filter(e=>e.scheme===I.file).map(e=>e.fsPath):void 0;n=n??this._userDataProfilesService.defaultProfile.extensionsResource;const a=await this._scanExtensions(n,r??d.language,t,c,i);return this._logService.trace("Scanned Extensions",a),this._massageWhenConditions(a),m.mark("code/server/didScanExtensions"),a}async _scanExtensions(r,n,t,o,i){await this._ensureLanguagePackIsInstalled(n,i);const[c,a,e,s]=await Promise.all([this._scanBuiltinExtensions(n),this._scanInstalledExtensions(r,n),this._scanWorkspaceInstalledExtensions(n,t),this._scanDevelopedExtensions(n,o)]);return M(c,a,e,s,this._logService)}async _scanDevelopedExtensions(r,n){return n?(await Promise.all(n.map(t=>this._extensionsScannerService.scanOneOrMultipleExtensions(x.file(_(t)),h.User,{language:r})))).flat().map(t=>E(t,!0)):[]}async _scanWorkspaceInstalledExtensions(r,n){const t=[];if(n?.length){const o=await Promise.all(n.map(i=>this._extensionsScannerService.scanExistingExtension(i,h.User,{language:r})));for(const i of o)i&&t.push(E(i,!1))}return t}async _scanBuiltinExtensions(r){return(await this._extensionsScannerService.scanSystemExtensions({language:r,useCache:!0})).map(t=>E(t,!1))}async _scanInstalledExtensions(r,n){return(await this._extensionsScannerService.scanUserExtensions({profileLocation:r,language:n,useCache:!0})).map(o=>E(o,!1))}async _ensureLanguagePackIsInstalled(r,n){if(!(r===d.LANGUAGE_DEFAULT||!this._extensionGalleryService.isEnabled())){try{if((await this._languagePackService.getInstalledLanguages()).find(o=>o.id===r)){this._logService.trace(`Language Pack ${r} is already installed. Skipping language pack installation.`);return}}catch(t){this._logService.error(t)}if(!n){this._logService.trace(`No language pack id provided for language ${r}. Skipping language pack installation.`);return}this._logService.trace(`Language Pack ${n} for language ${r} is not installed. It will be installed now.`);try{await this._extensionManagementCLI.installExtensions([n],[],{isMachineScoped:!0},!0)}catch(t){this._logService.error(t)}}}_massageWhenConditions(r){const n=(e,s)=>e.replace(/file/g,"vscode-remote"),t=e=>{let s="";return s+=e.global?"g":"",s+=e.ignoreCase?"i":"",s+=e.multiline?"m":"",new RegExp(n(e.source,!0),s)},o=new class{mapDefined(e){return C.create(e)}mapNot(e){return D.create(e)}mapEquals(e,s){return e==="resourceScheme"&&typeof s=="string"?u.create(e,n(s,!1)):u.create(e,s)}mapNotEquals(e,s){return e==="resourceScheme"&&typeof s=="string"?g.create(e,n(s,!1)):g.create(e,s)}mapGreater(e,s){return K.create(e,s)}mapGreaterEquals(e,s){return P.create(e,s)}mapSmaller(e,s){return k.create(e,s)}mapSmallerEquals(e,s){return W.create(e,s)}mapRegex(e,s){return e==="resourceScheme"&&s?f.create(e,t(s)):f.create(e,s)}mapIn(e,s){return b.create(e,s)}mapNotIn(e,s){return L.create(e,s)}},i=e=>{if(!e||!e.when||!/resourceScheme/.test(e.when))return;const s=U.deserialize(e.when);if(!s)return;const p=s.map(o);e.when=p.serialize()},c=e=>{if(Array.isArray(e))for(const s of e)i(s);else i(e)},a=e=>{for(const s in e)c(e[s])};r.forEach(e=>{e.contributes&&(e.contributes.menus&&a(e.contributes.menus),e.contributes.keybindings&&c(e.contributes.keybindings),e.contributes.views&&a(e.contributes.views))})}}class F{constructor(r,n){this.service=r;this.getUriTransformer=n}listen(r,n){throw new Error("Invalid listen")}async call(r,n,t){const o=this.getUriTransformer(r);switch(n){case"whenExtensionsReady":return this.service.whenExtensionsReady();case"scanExtensions":{const i=t[0],c=t[1]?x.revive(o.transformIncoming(t[1])):void 0,a=Array.isArray(t[2])?t[2].map(l=>x.revive(o.transformIncoming(l))):void 0,e=Array.isArray(t[3])?t[3].map(l=>x.revive(o.transformIncoming(l))):void 0,s=t[4];return(await this.service.scanExtensions(i,c,a,e,s)).map(l=>R(l,o))}}throw new Error("Invalid call")}}export{F as RemoteExtensionsScannerChannel,$ as RemoteExtensionsScannerService};
