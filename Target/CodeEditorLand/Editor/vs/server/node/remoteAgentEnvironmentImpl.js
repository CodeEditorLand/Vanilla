import"../../../vs/base/common/event.js";import{basename as h}from"../../../vs/base/common/path.js";import*as S from"vs/base/common/performance";import*as u from"../../../vs/base/common/platform.js";import"../../../vs/base/common/processes.js";import{joinPath as I}from"../../../vs/base/common/resources.js";import{URI as l}from"../../../vs/base/common/uri.js";import{transformOutgoingURIs as P}from"../../../vs/base/common/uriIpc.js";import{listProcesses as d}from"../../../vs/base/node/ps.js";import"../../../vs/base/parts/ipc/common/ipc.js";import"../../../vs/platform/diagnostics/common/diagnostics.js";import{collectWorkspaceStats as _,getMachineInfo as y}from"../../../vs/platform/diagnostics/node/diagnosticsService.js";import"../../../vs/platform/userDataProfile/common/userDataProfile.js";import"../../../vs/server/node/extensionHostStatusService.js";import{ServerConnectionTokenType as E}from"../../../vs/server/node/serverConnectionToken.js";import"../../../vs/server/node/serverEnvironmentService.js";import{createURITransformer as f}from"../../../vs/workbench/api/node/uriTransformer.js";import"../../../vs/workbench/services/remote/common/remoteAgentEnvironmentChannel.js";class p{constructor(r,t,e,o){this._connectionToken=r;this._environmentService=t;this._userDataProfilesService=e;this._extensionHostStatusService=o}static _namePool=1;async call(r,t,e){switch(t){case"getEnvironmentData":{const o=e,s=f(o.remoteAuthority);let i=await this._getEnvironmentData(o.profile);return i=P(i,s),i}case"getExtensionHostExitInfo":{const o=e;return this._extensionHostStatusService.getExitInfo(o.reconnectionToken)}case"getDiagnosticInfo":{const o=e,s={machineInfo:y()},i=o.includeProcesses?d(process.pid):Promise.resolve();let m=[];const c={};if(o.folders){const a=f("");m=o.folders.map(n=>l.revive(a.transformIncoming(n))).filter(n=>n.scheme==="file").map(n=>_(n.fsPath,["node_modules",".git"]).then(g=>{c[h(n.fsPath)]=g}))}return Promise.all([i,...m]).then(([a,v])=>(s.processes=a||void 0,s.workspaceMetadata=o.folders?c:void 0,s))}}throw new Error(`IPC Command ${t} not found`)}listen(r,t,e){throw new Error("Not supported")}async _getEnvironmentData(r){r&&!this._userDataProfilesService.profiles.some(e=>e.id===r)&&await this._userDataProfilesService.createProfile(r,r);let t=!1;if(process.platform==="linux"){const e=process.glibcVersion;t=(e?parseInt(e.split(".")[1]):28)<=27}return{pid:process.pid,connectionToken:this._connectionToken.type!==E.None?this._connectionToken.value:"",appRoot:l.file(this._environmentService.appRoot),settingsPath:this._environmentService.machineSettingsResource,logsPath:this._environmentService.logsHome,extensionHostLogsPath:I(this._environmentService.logsHome,`exthost${p._namePool++}`),globalStorageHome:this._userDataProfilesService.defaultProfile.globalStorageHome,workspaceStorageHome:this._environmentService.workspaceStorageHome,localHistoryHome:this._environmentService.localHistoryHome,userHome:this._environmentService.userHome,os:u.OS,arch:process.arch,marks:S.getMarks(),useHostProxy:!!this._environmentService.args["use-host-proxy"],profiles:{home:this._userDataProfilesService.profilesHome,all:[...this._userDataProfilesService.profiles].map(e=>({...e}))},isUnsupportedGlibc:t}}}export{p as RemoteAgentEnvironmentChannel};
