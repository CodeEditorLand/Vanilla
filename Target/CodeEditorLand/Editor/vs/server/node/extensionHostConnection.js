var H=Object.defineProperty;var b=Object.getOwnPropertyDescriptor;var g=(n,r,t,e)=>{for(var s=e>1?void 0:e?b(r,t):r,o=n.length-1,c;o>=0;o--)(c=n[o])&&(s=(e?c(r,t,s):c(s))||s);return e&&s&&H(r,t,s),s},f=(n,r)=>(t,e)=>r(t,e,n);import*as C from"child_process";import*as y from"net";import{VSBuffer as S}from"../../base/common/buffer.js";import{Emitter as I,Event as p}from"../../base/common/event.js";import{Disposable as w,DisposableStore as D,toDisposable as N}from"../../base/common/lifecycle.js";import{FileAccess as R}from"../../base/common/network.js";import{delimiter as T,join as u}from"../../base/common/path.js";import{isWindows as E}from"../../base/common/platform.js";import{removeDangerousEnvVariables as O}from"../../base/common/processes.js";import{createRandomIPCHandle as A,NodeSocket as k}from"../../base/parts/ipc/node/ipc.net.js";import{IConfigurationService as $}from"../../platform/configuration/common/configuration.js";import{ILogService as L}from"../../platform/log/common/log.js";import"../../platform/remote/common/remoteAgentConnection.js";import{getResolvedShellEnv as B}from"../../platform/shell/node/shellEnv.js";import{IExtensionHostStatusService as V}from"./extensionHostStatusService.js";import{getNLSConfiguration as M}from"./remoteLanguagePacks.js";import{IServerEnvironmentService as W}from"./serverEnvironmentService.js";import{IPCExtHostConnection as F,SocketExtHostConnection as U,writeExtHostConnection as P}from"../../workbench/services/extensions/common/extensionHostEnv.js";import"../../workbench/services/extensions/common/extensionHostProtocol.js";async function G(n={},r,t,e,s,o){const c=await M(t,e.userDataPath);let d={};if(r)try{d=await B(o,s,e.args,process.env)}catch(l){s.error("ExtensionHostConnection#buildUserEnvironment resolving shell environment failed",l)}const a={...process.env,...d,VSCODE_AMD_ENTRYPOINT:"vs/workbench/api/node/extensionHostProcess",VSCODE_HANDLES_UNCAUGHT_ERRORS:"true",VSCODE_NLS_CONFIG:JSON.stringify(c),...n},v=e.isBuilt?u(e.appRoot,"bin"):u(e.appRoot,"resources","server","bin-dev"),h=u(v,"remote-cli");let i=K(a,"PATH");return i?i=h+T+i:i=h,j(a,"PATH",i),e.args["without-browser-env-var"]||(a.BROWSER=u(v,"helpers",E?"browser.cmd":"browser.sh")),X(a),a}class x{constructor(r,t){this.socket=r;this.initialDataChunk=t}socketDrain(){return this.socket.drain()}toIExtHostSocketMessage(){let r,t,e;return this.socket instanceof k?(r=!0,t=!1,e=S.alloc(0)):(r=!1,t=this.socket.permessageDeflate,e=this.socket.recordedInflateBytes),{type:"VSCODE_EXTHOST_IPC_SOCKET",initialDataChunk:this.initialDataChunk.buffer.toString("base64"),skipWebSocketFrames:r,permessageDeflate:t,inflateBytes:e.buffer.toString("base64")}}}let m=class extends w{constructor(t,e,s,o,c,d,_,a){super();this._reconnectionToken=t;this._environmentService=c;this._logService=d;this._extensionHostStatusService=_;this._configurationService=a;this._canSendSocket=!E||!this._environmentService.args["socket-path"],this._disposed=!1,this._remoteAddress=e,this._extensionHostProcess=null,this._connectionData=new x(s,o),this._log("New connection established.")}_onClose=new I;onClose=this._onClose.event;_canSendSocket;_disposed;_remoteAddress;_extensionHostProcess;_connectionData;dispose(){this._cleanResources(),super.dispose()}get _logPrefix(){return`[${this._remoteAddress}][${this._reconnectionToken.substr(0,8)}][ExtensionHostConnection] `}_log(t){this._logService.info(`${this._logPrefix}${t}`)}_logError(t){this._logService.error(`${this._logPrefix}${t}`)}async _pipeSockets(t,e){const s=new D;s.add(e.socket),s.add(N(()=>{t.destroy()}));const o=()=>{s.dispose()};s.add(e.socket.onEnd(o)),s.add(e.socket.onClose(o)),s.add(p.fromNodeEventEmitter(t,"end")(o)),s.add(p.fromNodeEventEmitter(t,"close")(o)),s.add(p.fromNodeEventEmitter(t,"error")(o)),s.add(e.socket.onData(c=>t.write(c.buffer))),s.add(p.fromNodeEventEmitter(t,"data")(c=>{e.socket.write(S.wrap(c))})),e.initialDataChunk.byteLength>0&&t.write(e.initialDataChunk.buffer)}async _sendSocketToExtensionHost(t,e){await e.socketDrain();const s=e.toIExtHostSocketMessage();let o;e.socket instanceof k?o=e.socket.socket:o=e.socket.socket.socket,t.send(s,o)}shortenReconnectionGraceTimeIfNecessary(){if(!this._extensionHostProcess)return;const t={type:"VSCODE_EXTHOST_IPC_REDUCE_GRACE_TIME"};this._extensionHostProcess.send(t)}acceptReconnection(t,e,s){this._remoteAddress=t,this._log("The client has reconnected.");const o=new x(e,s);if(!this._extensionHostProcess){this._connectionData=o;return}this._sendSocketToExtensionHost(this._extensionHostProcess,o)}_cleanResources(){this._disposed||(this._disposed=!0,this._connectionData&&(this._connectionData.socket.end(),this._connectionData=null),this._extensionHostProcess&&(this._extensionHostProcess.kill(),this._extensionHostProcess=null),this._onClose.fire(void 0))}async start(t){try{let e=process.execArgv?process.execArgv.filter(i=>!/^--inspect(-brk)?=/.test(i)):[];t.port&&!process.pkg&&(e=[`--inspect${t.break?"-brk":""}=${t.port}`]);const s=await G(t.env,!0,t.language,this._environmentService,this._logService,this._configurationService);O(s);let o;if(this._canSendSocket)P(new U,s),o=null;else{const{namedPipeServer:i,pipeName:l}=await this._listenOnPipe();P(new F(l),s),o=i}const c={env:s,execArgv:e,silent:!0};c.execArgv.unshift("--dns-result-order=ipv4first");const d=["--type=extensionHost","--transformURIs"],_=this._environmentService.args["use-host-proxy"];d.push(`--useHostProxy=${_?"true":"false"}`),this._extensionHostProcess=C.fork(R.asFileUri("bootstrap-fork").fsPath,d,c);const a=this._extensionHostProcess.pid;this._log(`<${a}> Launched Extension Host Process.`),this._extensionHostProcess.stdout.setEncoding("utf8"),this._extensionHostProcess.stderr.setEncoding("utf8");const v=p.fromNodeEventEmitter(this._extensionHostProcess.stdout,"data"),h=p.fromNodeEventEmitter(this._extensionHostProcess.stderr,"data");if(this._register(v(i=>this._log(`<${a}> ${i}`))),this._register(h(i=>this._log(`<${a}><stderr> ${i}`))),this._extensionHostProcess.on("error",i=>{this._logError(`<${a}> Extension Host Process had an error`),this._logService.error(i),this._cleanResources()}),this._extensionHostProcess.on("exit",(i,l)=>{this._extensionHostStatusService.setExitInfo(this._reconnectionToken,{code:i,signal:l}),this._log(`<${a}> Extension Host Process exited with code: ${i}, signal: ${l}.`),this._cleanResources()}),o)o.on("connection",i=>{o.close(),this._pipeSockets(i,this._connectionData)});else{const i=l=>{l.type==="VSCODE_EXTHOST_IPC_READY"&&(this._extensionHostProcess.removeListener("message",i),this._sendSocketToExtensionHost(this._extensionHostProcess,this._connectionData),this._connectionData=null)};this._extensionHostProcess.on("message",i)}}catch(e){}}_listenOnPipe(){return new Promise((t,e)=>{const s=A(),o=y.createServer();o.on("error",e),o.listen(s,()=>{o?.removeListener("error",e),t({pipeName:s,namedPipeServer:o})})})}};m=g([f(4,W),f(5,L),f(6,V),f(7,$)],m);function K(n,r){const t=Object.keys(n).filter(s=>s.toLowerCase()===r.toLowerCase()),e=t.length>0?t[0]:r;return n[e]}function j(n,r,t){const e=Object.keys(n).filter(o=>o.toLowerCase()===r.toLowerCase()),s=e.length>0?e[0]:r;n[s]=t}function X(n){for(const r of Object.keys(n))n[r]===null&&delete n[r]}export{m as ExtensionHostConnection,G as buildUserEnvironment};
