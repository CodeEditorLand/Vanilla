{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/server/node/serverConnectionToken.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from \"fs\";\nimport type * as http from \"http\";\nimport type * as url from \"url\";\nimport * as cookie from \"cookie\";\nimport {\n\tconnectionTokenCookieName,\n\tconnectionTokenQueryName,\n} from \"../../base/common/network.js\";\nimport * as path from \"../../base/common/path.js\";\nimport { generateUuid } from \"../../base/common/uuid.js\";\nimport { Promises } from \"../../base/node/pfs.js\";\nimport type { ServerParsedArgs } from \"./serverEnvironmentService.js\";\n\nconst connectionTokenRegex = /^[0-9A-Za-z_-]+$/;\n\nexport enum ServerConnectionTokenType {\n\tNone = 0,\n\tOptional = 1, // TODO: Remove this soon\n\tMandatory = 2,\n}\n\nexport class NoneServerConnectionToken {\n\tpublic readonly type = ServerConnectionTokenType.None;\n\n\tpublic validate(connectionToken: any): boolean {\n\t\treturn true;\n\t}\n}\n\nexport class MandatoryServerConnectionToken {\n\tpublic readonly type = ServerConnectionTokenType.Mandatory;\n\n\tconstructor(public readonly value: string) {}\n\n\tpublic validate(connectionToken: any): boolean {\n\t\treturn connectionToken === this.value;\n\t}\n}\n\nexport type ServerConnectionToken =\n\t| NoneServerConnectionToken\n\t| MandatoryServerConnectionToken;\n\nexport class ServerConnectionTokenParseError {\n\tconstructor(public readonly message: string) {}\n}\n\nexport async function parseServerConnectionToken(\n\targs: ServerParsedArgs,\n\tdefaultValue: () => Promise<string>,\n): Promise<ServerConnectionToken | ServerConnectionTokenParseError> {\n\tconst withoutConnectionToken = args[\"without-connection-token\"];\n\tconst connectionToken = args[\"connection-token\"];\n\tconst connectionTokenFile = args[\"connection-token-file\"];\n\n\tif (withoutConnectionToken) {\n\t\tif (\n\t\t\ttypeof connectionToken !== \"undefined\" ||\n\t\t\ttypeof connectionTokenFile !== \"undefined\"\n\t\t) {\n\t\t\treturn new ServerConnectionTokenParseError(\n\t\t\t\t`Please do not use the argument '--connection-token' or '--connection-token-file' at the same time as '--without-connection-token'.`,\n\t\t\t);\n\t\t}\n\t\treturn new NoneServerConnectionToken();\n\t}\n\n\tif (typeof connectionTokenFile !== \"undefined\") {\n\t\tif (typeof connectionToken !== \"undefined\") {\n\t\t\treturn new ServerConnectionTokenParseError(\n\t\t\t\t`Please do not use the argument '--connection-token' at the same time as '--connection-token-file'.`,\n\t\t\t);\n\t\t}\n\n\t\tlet rawConnectionToken: string;\n\t\ttry {\n\t\t\trawConnectionToken = fs\n\t\t\t\t.readFileSync(connectionTokenFile)\n\t\t\t\t.toString()\n\t\t\t\t.replace(/\\r?\\n$/, \"\");\n\t\t} catch (e) {\n\t\t\treturn new ServerConnectionTokenParseError(\n\t\t\t\t`Unable to read the connection token file at '${connectionTokenFile}'.`,\n\t\t\t);\n\t\t}\n\n\t\tif (!connectionTokenRegex.test(rawConnectionToken)) {\n\t\t\treturn new ServerConnectionTokenParseError(\n\t\t\t\t`The connection token defined in '${connectionTokenFile} does not adhere to the characters 0-9, a-z, A-Z, _, or -.`,\n\t\t\t);\n\t\t}\n\n\t\treturn new MandatoryServerConnectionToken(rawConnectionToken);\n\t}\n\n\tif (typeof connectionToken !== \"undefined\") {\n\t\tif (!connectionTokenRegex.test(connectionToken)) {\n\t\t\treturn new ServerConnectionTokenParseError(\n\t\t\t\t`The connection token '${connectionToken} does not adhere to the characters 0-9, a-z, A-Z or -.`,\n\t\t\t);\n\t\t}\n\n\t\treturn new MandatoryServerConnectionToken(connectionToken);\n\t}\n\n\treturn new MandatoryServerConnectionToken(await defaultValue());\n}\n\nexport async function determineServerConnectionToken(\n\targs: ServerParsedArgs,\n): Promise<ServerConnectionToken | ServerConnectionTokenParseError> {\n\tconst readOrGenerateConnectionToken = async () => {\n\t\tif (!args[\"user-data-dir\"]) {\n\t\t\t// No place to store it!\n\t\t\treturn generateUuid();\n\t\t}\n\t\tconst storageLocation = path.join(args[\"user-data-dir\"], \"token\");\n\n\t\t// First try to find a connection token\n\t\ttry {\n\t\t\tconst fileContents = await fs.promises.readFile(storageLocation);\n\t\t\tconst connectionToken = fileContents\n\t\t\t\t.toString()\n\t\t\t\t.replace(/\\r?\\n$/, \"\");\n\t\t\tif (connectionTokenRegex.test(connectionToken)) {\n\t\t\t\treturn connectionToken;\n\t\t\t}\n\t\t} catch (err) {}\n\n\t\t// No connection token found, generate one\n\t\tconst connectionToken = generateUuid();\n\n\t\ttry {\n\t\t\t// Try to store it\n\t\t\tawait Promises.writeFile(storageLocation, connectionToken, {\n\t\t\t\tmode: 0o600,\n\t\t\t});\n\t\t} catch (err) {}\n\n\t\treturn connectionToken;\n\t};\n\treturn parseServerConnectionToken(args, readOrGenerateConnectionToken);\n}\n\nexport function requestHasValidConnectionToken(\n\tconnectionToken: ServerConnectionToken,\n\treq: http.IncomingMessage,\n\tparsedUrl: url.UrlWithParsedQuery,\n) {\n\t// First check if there is a valid query parameter\n\tif (connectionToken.validate(parsedUrl.query[connectionTokenQueryName])) {\n\t\treturn true;\n\t}\n\n\t// Otherwise, check if there is a valid cookie\n\tconst cookies = cookie.parse(req.headers.cookie || \"\");\n\treturn connectionToken.validate(cookies[connectionTokenCookieName]);\n}\n"],
  "mappings": "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",
  "names": ["ServerConnectionTokenType", "connectionToken"]
}
