var j=Object.defineProperty;var V=Object.getOwnPropertyDescriptor;var U=(v,h,e,n)=>{for(var t=n>1?void 0:n?V(h,e):h,o=v.length-1,r;o>=0;o--)(r=v[o])&&(t=(n?r(h,e,t):r(t))||t);return n&&t&&j(h,e,t),t},w=(v,h)=>(e,n)=>h(e,n,v);import*as B from"crypto";import*as M from"fs";import"http";import*as q from"net";import{createRequire as J}from"node:module";import{performance as G}from"perf_hooks";import*as O from"url";import{isESM as z,LoaderStats as T}from"../../base/common/amd.js";import{VSBuffer as b}from"../../base/common/buffer.js";import{CharCode as K}from"../../base/common/charCode.js";import{isSigPipeError as Q,onUnexpectedError as Z,setUnexpectedErrorHandler as X}from"../../base/common/errors.js";import{isEqualOrParent as $}from"../../base/common/extpath.js";import{Disposable as Y,DisposableStore as ee}from"../../base/common/lifecycle.js";import{connectionTokenQueryName as te,FileAccess as L,getServerRootPath as ne,Schemas as oe}from"../../base/common/network.js";import{dirname as re,join as R}from"../../base/common/path.js";import*as ie from"../../base/common/performance.js";import*as E from"../../base/common/platform.js";import{createRegExp as se,escapeRegExpCharacters as ae}from"../../base/common/strings.js";import{URI as ce}from"../../base/common/uri.js";import{generateUuid as A}from"../../base/common/uuid.js";import{getOSReleaseInfo as de}from"../../base/node/osReleaseInfo.js";import{findFreePort as le}from"../../base/node/ports.js";import{addUNCHostToAllowlist as me,disableUNCAccessRestrictions as ue}from"../../base/node/unc.js";import{PersistentProtocol as he}from"../../base/parts/ipc/common/ipc.net.js";import{NodeSocket as D,WebSocketNodeSocket as pe}from"../../base/parts/ipc/node/ipc.net.js";import{IConfigurationService as fe}from"../../platform/configuration/common/configuration.js";import{IInstantiationService as ge}from"../../platform/instantiation/common/instantiation.js";import{ILogService as x}from"../../platform/log/common/log.js";import{IProductService as ve}from"../../platform/product/common/productService.js";import{ConnectionType as P}from"../../platform/remote/common/remoteAgentConnection.js";import"../../platform/remote/common/remoteAgentEnvironment.js";import{ITelemetryService as Se}from"../../platform/telemetry/common/telemetry.js";import{ExtensionHostConnection as ye}from"./extensionHostConnection.js";import{ManagementConnection as Ce}from"./remoteExtensionManagement.js";import{determineServerConnectionToken as _e,requestHasValidConnectionToken as be,ServerConnectionTokenParseError as ke,ServerConnectionTokenType as F}from"./serverConnectionToken.js";import{IServerEnvironmentService as we}from"./serverEnvironmentService.js";import{setupServerServices as Te}from"./serverServices.js";import{CacheControl as Ee,serveError as k,serveFile as xe,WebClientServer as Pe}from"./webClientServer.js";const Ie=J(import.meta.url),He=5*60*1e3;let I=class extends Y{constructor(e,n,t,o,r,a,d,c,u){super();this._socketServer=e;this._connectionToken=n;this._vsdaMod=t;this._environmentService=a;this._productService=d;this._logService=c;this._instantiationService=u;this._serverRootPath=ne(d,r),this._extHostConnections=Object.create(null),this._managementConnections=Object.create(null),this._allReconnectionTokens=new Set,this._webClientServer=o?this._instantiationService.createInstance(Pe,this._connectionToken,r??"/",this._serverRootPath):null,this._logService.info("Extension host agent started."),this._waitThenShutdown(!0)}_extHostConnections;_managementConnections;_allReconnectionTokens;_webClientServer;_webEndpointOriginChecker=H.create(this._productService);_serverRootPath;shutdownTimer;async handleRequest(e,n){if(e.method!=="GET")return k(e,n,405,`Unsupported method ${e.method}`);if(!e.url)return k(e,n,400,"Bad request.");const t=O.parse(e.url,!0);let o=t.pathname;if(!o)return k(e,n,400,"Bad request.");if(o.startsWith(this._serverRootPath)&&o.charCodeAt(this._serverRootPath.length)===K.Slash&&(o=o.substring(this._serverRootPath.length)),o==="/version")return n.writeHead(200,{"Content-Type":"text/plain"}),void n.end(this._productService.commit||"");if(o==="/delay-shutdown")return this._delayShutdown(),n.writeHead(200),void n.end("OK");if(!be(this._connectionToken,e,t))return k(e,n,403,"Forbidden.");if(o==="/vscode-remote-resource"){const r=t.query.path;if(typeof r!="string")return k(e,n,400,"Bad request.");let a;try{a=ce.from({scheme:oe.file,path:r}).fsPath}catch{return k(e,n,400,"Bad request.")}const d=Object.create(null);this._environmentService.isBuilt&&($(a,this._environmentService.builtinExtensionsPath,!E.isLinux)||$(a,this._environmentService.extensionsPath,!E.isLinux))&&(d["Cache-Control"]="public, max-age=31536000"),d.Vary="Origin";const c=e.headers.origin;return c&&this._webEndpointOriginChecker.matches(c)&&(d["Access-Control-Allow-Origin"]=c),xe(a,Ee.ETAG,this._logService,e,n,d)}if(this._webClientServer){this._webClientServer.handle(e,n,t);return}return n.writeHead(404,{"Content-Type":"text/plain"}),void n.end("Not found")}handleUpgrade(e,n){let t=A(),o=!1,r=!1;if(e.url){const m=O.parse(e.url,!0).query;typeof m.reconnectionToken=="string"&&(t=m.reconnectionToken),m.reconnection==="true"&&(o=!0),m.skipWebSocketFrames==="true"&&(r=!0)}if(e.headers.upgrade===void 0||e.headers.upgrade.toLowerCase()!=="websocket"){n.end("HTTP/1.1 400 Bad Request");return}const a=e.headers["sec-websocket-key"],d=B.createHash("sha1");d.update(a+"258EAFA5-E914-47DA-95CA-C5AB0DC85B11");const u=["HTTP/1.1 101 Switching Protocols","Upgrade: websocket","Connection: Upgrade",`Sec-WebSocket-Accept: ${d.digest("base64")}`];let l=!1;if(!r&&!this._environmentService.args["disable-websocket-compression"]&&e.headers["sec-websocket-extensions"]){const m=Array.isArray(e.headers["sec-websocket-extensions"])?e.headers["sec-websocket-extensions"]:[e.headers["sec-websocket-extensions"]];for(const f of m)if(!/\b((server_max_window_bits)|(server_no_context_takeover)|(client_no_context_takeover))\b/.test(f)){if(/\b(permessage-deflate)\b/.test(f)){l=!0,u.push("Sec-WebSocket-Extensions: permessage-deflate");break}if(/\b(x-webkit-deflate-frame)\b/.test(f)){l=!0,u.push("Sec-WebSocket-Extensions: x-webkit-deflate-frame");break}}}n.write(u.join(`\r
`)+`\r
\r
`),n.setTimeout(0),n.setNoDelay(!0),r?this._handleWebSocketConnection(new D(n,`server-connection-${t}`),o,t):this._handleWebSocketConnection(new pe(new D(n,`server-connection-${t}`),l,null,!0),o,t)}handleServerError(e){this._logService.error("Error occurred in server"),this._logService.error(e)}_getRemoteAddress(e){let n;return e instanceof D?n=e.socket:n=e.socket.socket,n.remoteAddress||"<unknown>"}async _rejectWebSocketConnection(e,n,t){const o=n.getSocket();this._logService.error(`${e} ${t}.`);const r={type:"error",reason:t};n.sendControl(b.fromString(JSON.stringify(r))),n.dispose(),await o.drain(),o.dispose()}_handleWebSocketConnection(e,n,t){const o=this._getRemoteAddress(e),r=`[${o}][${t.substr(0,8)}]`,a=new he({socket:e}),d=this._vsdaMod?new this._vsdaMod.validator:null,c=this._vsdaMod?new this._vsdaMod.signer:null;let u;(s=>(s[s.WaitingForAuth=0]="WaitingForAuth",s[s.WaitingForConnectionType=1]="WaitingForConnectionType",s[s.Done=2]="Done",s[s.Error=3]="Error"))(u||={});let l=0;const m=_=>{l=3,f.dispose(),this._rejectWebSocketConnection(r,a,_)},f=a.onControlMessage(_=>{if(l===0){let p;try{p=JSON.parse(_.toString())}catch{return m("Malformed first message")}if(p.type!=="auth")return m("Invalid first message");if(this._connectionToken.type===F.Mandatory&&!this._connectionToken.validate(p.auth))return m("Unauthorized client refused: auth mismatch");let y=A();if(c)try{y=c.sign(p.data)}catch{}let S=A();if(d)try{S=d.createNewMessage(S)}catch{}const s={type:"sign",data:S,signedData:y};a.sendControl(b.fromString(JSON.stringify(s))),l=1}else if(l===1){let p;try{p=JSON.parse(_.toString())}catch{return m("Malformed second message")}if(p.type!=="connectionType")return m("Invalid second message");if(typeof p.signedData!="string")return m("Invalid second message field type");const y=p.commit,S=this._productService.commit;if(y&&S&&y!==S)return m("Client refused: version mismatch");let s=!1;if(!d)s=!0;else if(this._connectionToken.validate(p.signedData))s=!0;else try{s=d.validate(p.signedData)==="ok"}catch{}if(!s){if(this._environmentService.isBuilt)return m("Unauthorized client refused");this._logService.error(`${r} Unauthorized client handshake failed but we proceed because of dev mode.`)}for(const i in this._managementConnections)this._managementConnections[i].shortenReconnectionGraceTimeIfNecessary();for(const i in this._extHostConnections)this._extHostConnections[i].shortenReconnectionGraceTimeIfNecessary();l=2,f.dispose(),this._handleConnectionType(o,r,a,e,n,t,p)}})}async _handleConnectionType(e,n,t,o,r,a,d){const c=d.desiredConnectionType===P.Management?`${n}[ManagementConnection]`:d.desiredConnectionType===P.ExtensionHost?`${n}[ExtensionHostConnection]`:n;if(d.desiredConnectionType===P.Management)if(r){if(!this._managementConnections[a])return this._allReconnectionTokens.has(a)?this._rejectWebSocketConnection(c,t,"Unknown reconnection token (seen before)"):this._rejectWebSocketConnection(c,t,"Unknown reconnection token (never seen)");t.sendControl(b.fromString(JSON.stringify({type:"ok"})));const u=t.readEntireBuffer();t.dispose(),this._managementConnections[a].acceptReconnection(e,o,u)}else{if(this._managementConnections[a])return this._rejectWebSocketConnection(c,t,"Duplicate reconnection token");t.sendControl(b.fromString(JSON.stringify({type:"ok"})));const u=new Ce(this._logService,a,e,t);this._socketServer.acceptConnection(u.protocol,u.onClose),this._managementConnections[a]=u,this._allReconnectionTokens.add(a),u.onClose(()=>{delete this._managementConnections[a]})}else if(d.desiredConnectionType===P.ExtensionHost){const u=d.args||{language:"en"},l=await this._updateWithFreeDebugPort(u);if(l.port&&this._logService.trace(`${c} - startParams debug port ${l.port}`),this._logService.trace(`${c} - startParams language: ${l.language}`),this._logService.trace(`${c} - startParams env: ${JSON.stringify(l.env)}`),r){if(!this._extHostConnections[a])return this._allReconnectionTokens.has(a)?this._rejectWebSocketConnection(c,t,"Unknown reconnection token (seen before)"):this._rejectWebSocketConnection(c,t,"Unknown reconnection token (never seen)");t.sendPause(),t.sendControl(b.fromString(JSON.stringify(l.port?{debugPort:l.port}:{})));const m=t.readEntireBuffer();t.dispose(),this._extHostConnections[a].acceptReconnection(e,o,m)}else{if(this._extHostConnections[a])return this._rejectWebSocketConnection(c,t,"Duplicate reconnection token");t.sendPause(),t.sendControl(b.fromString(JSON.stringify(l.port?{debugPort:l.port}:{})));const m=t.readEntireBuffer();t.dispose();const f=this._instantiationService.createInstance(ye,a,e,o,m);this._extHostConnections[a]=f,this._allReconnectionTokens.add(a),f.onClose(()=>{f.dispose(),delete this._extHostConnections[a],this._onDidCloseExtHostConnection()}),f.start(l)}}else if(d.desiredConnectionType===P.Tunnel){const u=d.args;this._createTunnel(t,u)}else return this._rejectWebSocketConnection(c,t,"Unknown initial data received")}async _createTunnel(e,n){const t=e.getSocket().socket,o=e.readEntireBuffer();e.dispose(),t.pause();const r=await this._connectTunnelSocket(n.host,n.port);o.byteLength>0&&r.write(o.buffer),r.on("end",()=>t.end()),r.on("close",()=>t.end()),r.on("error",()=>t.destroy()),t.on("end",()=>r.end()),t.on("close",()=>r.end()),t.on("error",()=>r.destroy()),r.pipe(t),t.pipe(r)}_connectTunnelSocket(e,n){return new Promise((t,o)=>{const r=q.createConnection({host:e,port:n,autoSelectFamily:!0},()=>{r.removeListener("error",o),r.pause(),t(r)});r.once("error",o)})}_updateWithFreeDebugPort(e){return typeof e.port=="number"?le(e.port,10,5e3).then(n=>(e.port=n,e)):(e.debugId=void 0,e.port=void 0,e.break=void 0,Promise.resolve(e))}async _onDidCloseExtHostConnection(){if(!this._environmentService.args["enable-remote-auto-shutdown"])return;this._cancelShutdown(),!!Object.keys(this._extHostConnections).length||(console.log("Last EH closed, waiting before shutting down"),this._logService.info("Last EH closed, waiting before shutting down"),this._waitThenShutdown())}_waitThenShutdown(e=!1){this._environmentService.args["enable-remote-auto-shutdown"]&&(this._environmentService.args["remote-auto-shutdown-without-delay"]&&!e?this._shutdown():this.shutdownTimer=setTimeout(()=>{this.shutdownTimer=void 0,this._shutdown()},He))}_shutdown(){if(!!Object.keys(this._extHostConnections).length){console.log("New EH opened, aborting shutdown"),this._logService.info("New EH opened, aborting shutdown");return}else console.log("Last EH closed, shutting down"),this._logService.info("Last EH closed, shutting down"),this.dispose(),process.exit(0)}_delayShutdown(){this.shutdownTimer&&(console.log("Got delay-shutdown request while in shutdown timeout, delaying"),this._logService.info("Got delay-shutdown request while in shutdown timeout, delaying"),this._cancelShutdown(),this._waitThenShutdown())}_cancelShutdown(){this.shutdownTimer&&(console.log("Cancelling previous shutdown timeout"),this._logService.info("Cancelling previous shutdown timeout"),clearTimeout(this.shutdownTimer),this.shutdownTimer=void 0)}};I=U([w(5,we),w(6,ve),w(7,x),w(8,ge)],I);async function Ct(v,h,e){const n=await _e(h);n instanceof ke&&(console.warn(n.message),process.exit(1));function t(s){X(i=>{Q(i)&&i.stack&&/unexpectedErrorHandler/.test(i.stack)||s(i)})}const o=[];t(s=>{o.push(s),console.error(s)});let r=!1;process.on("SIGPIPE",()=>{r||(r=!0,Z(new Error("Unexpected SIGPIPE")))});const a=new ee,{socketServer:d,instantiationService:c}=await Te(n,h,e,a);c.invokeFunction(s=>{const i=s.get(x);o.forEach(g=>i.error(g)),o.length=0,t(g=>i.error(g))}),c.invokeFunction(s=>{const i=s.get(fe);E.isWindows&&(i.getValue("security.restrictUNCAccess")===!1?ue():me(i.getValue("security.allowedUNCHosts")))}),c.invokeFunction(s=>{const i=s.get(x);if(E.isWindows&&process.env.HOMEDRIVE&&process.env.HOMEPATH){const g=R(process.env.HOMEDRIVE,"node_modules"),C=re(R(process.env.HOMEDRIVE,process.env.HOMEPATH)),W=R(C,"node_modules");if(M.existsSync(g)||M.existsSync(W)){const N=`

*
* !!!! Server terminated due to presence of CVE-2020-1416 !!!!
*
* Please remove the following directories and re-try
* ${g}
* ${W}
*
* For more information on the vulnerability https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-1416
*

`;i.warn(N),console.warn(N),process.exit(0)}}});const u=c.invokeFunction(s=>{const i=s.get(x);if(M.existsSync(R(L.asFileUri("").fsPath,"../node_modules/vsda")))try{return Ie("vsda")}catch(C){i.error(C)}return null});let l=h["server-base-path"];l&&!l.startsWith("/")&&(l=`/${l}`);const m=M.existsSync(L.asFileUri(`vs/code/browser/workbench/workbench.${z?"esm.":""}html`).fsPath);if(m&&v&&typeof v!="string"){const s=n.type!==F.None?`?${te}=${n.value}`:"";console.log(`Web UI available at http://localhost${v.port===80?"":`:${v.port}`}${l??""}${s}`)}const f=c.createInstance(I,d,n,u,m,l);ie.mark("code/server/ready");const _=G.now(),p=global.vscodeServerStartTime,y=global.vscodeServerListenTime,S=global.vscodeServerCodeLoadedTime;if(c.invokeFunction(async s=>{const i=s.get(Se);if(i.publicLog2("serverStart",{startTime:p,startedTime:y,codeLoadedTime:S,readyTime:_}),E.isLinux){const g=s.get(x),C=await de(g.error.bind(g));C&&i.publicLog2("serverPlatformInfo",{platformId:C.id,platformVersionId:C.version_id,platformIdLike:C.id_like})}}),h["print-startup-performance"]){const s=T.get();let i="";i+=`

### Load AMD-module
`,i+=T.toMarkdownTable(["Module","Duration"],s.amdLoad),i+=`

### Load commonjs-module
`,i+=T.toMarkdownTable(["Module","Duration"],s.nodeRequire),i+=`

### Invoke AMD-module factory
`,i+=T.toMarkdownTable(["Module","Duration"],s.amdInvoke),i+=`

### Invoke commonjs-module
`,i+=T.toMarkdownTable(["Module","Duration"],s.nodeEval),i+=`Start-up time: ${y-p}
`,i+=`Code loading time: ${S-p}
`,i+=`Initialized time: ${_-p}
`,i+=`
`,console.log(i)}return f}class H{constructor(h){this._originRegExp=h}static create(h){const e=h.webEndpointUrlTemplate,n=h.commit,t=h.quality;if(!e||!n||!t)return new H(null);const o=A(),a=new URL(e.replace("{{uuid}}",o).replace("{{commit}}",n).replace("{{quality}}",t)).origin,d=ae(a).replace(o,"[a-zA-Z0-9\\-]+");try{const c=se(`^${d}$`,!0,{matchCase:!1});return new H(c)}catch{return new H(null)}}matches(h){return this._originRegExp?this._originRegExp.test(h):!1}}export{Ct as createServer};
