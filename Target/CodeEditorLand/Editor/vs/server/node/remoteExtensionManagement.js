import{ProtocolConstants as s}from"../../base/parts/ipc/common/ipc.net.js";import"../../platform/log/common/log.js";import{Emitter as a}from"../../base/common/event.js";import"../../base/common/buffer.js";import{ProcessTimeRunOnceScheduler as r}from"../../base/common/async.js";function i(t){let e=0,n=0,o=0;t>=1e3&&(o=Math.floor(t/1e3),t-=o*1e3),o>=60&&(n=Math.floor(o/60),o-=n*60),n>=60&&(e=Math.floor(n/60),n-=e*60);const c=e?`${e}h`:"",h=n?`${n}m`:"",l=o?`${o}s`:"",d=t?`${t}ms`:"";return`${c}${h}${l}${d}`}class b{constructor(e,n,o,c){this._logService=e;this._reconnectionToken=n;this._reconnectionGraceTime=s.ReconnectionGraceTime,this._reconnectionShortGraceTime=s.ReconnectionShortGraceTime,this._remoteAddress=o,this.protocol=c,this._disposed=!1,this._disconnectRunner1=new r(()=>{this._log(`The reconnection grace time of ${i(this._reconnectionGraceTime)} has expired, so the connection will be disposed.`),this._cleanResources()},this._reconnectionGraceTime),this._disconnectRunner2=new r(()=>{this._log(`The reconnection short grace time of ${i(this._reconnectionShortGraceTime)} has expired, so the connection will be disposed.`),this._cleanResources()},this._reconnectionShortGraceTime),this.protocol.onDidDispose(()=>{this._log("The client has disconnected gracefully, so the connection will be disposed."),this._cleanResources()}),this.protocol.onSocketClose(()=>{this._log(`The client has disconnected, will wait for reconnection ${i(this._reconnectionGraceTime)} before disposing...`),this._disconnectRunner1.schedule()}),this._log("New connection established.")}_onClose=new a;onClose=this._onClose.event;_reconnectionGraceTime;_reconnectionShortGraceTime;_remoteAddress;protocol;_disposed;_disconnectRunner1;_disconnectRunner2;_log(e){this._logService.info(`[${this._remoteAddress}][${this._reconnectionToken.substr(0,8)}][ManagementConnection] ${e}`)}shortenReconnectionGraceTimeIfNecessary(){this._disconnectRunner2.isScheduled()||this._disconnectRunner1.isScheduled()&&(this._log(`Another client has connected, will shorten the wait for reconnection ${i(this._reconnectionShortGraceTime)} before disposing...`),this._disconnectRunner2.schedule())}_cleanResources(){if(this._disposed)return;this._disposed=!0,this._disconnectRunner1.dispose(),this._disconnectRunner2.dispose();const e=this.protocol.getSocket();this.protocol.sendDisconnect(),this.protocol.dispose(),e.end(),this._onClose.fire(void 0)}acceptReconnection(e,n,o){this._remoteAddress=e,this._log("The client has reconnected."),this._disconnectRunner1.cancel(),this._disconnectRunner2.cancel(),this.protocol.beginAcceptReconnection(n,o),this.protocol.endAcceptReconnection()}}export{b as ManagementConnection};
