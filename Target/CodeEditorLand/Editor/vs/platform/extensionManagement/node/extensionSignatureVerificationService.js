var I=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var m=(o,t,i,s)=>{for(var n=s>1?void 0:s?p(t,i):t,c=o.length-1,a;c>=0;c--)(a=o[c])&&(n=(s?a(t,i,n):a(n))||n);return s&&n&&I(t,i,n),n},g=(o,t)=>(i,s)=>t(i,s,o);import{importAMDNodeModule as y}from"../../../../vs/amdX.js";import{getErrorMessage as v}from"../../../../vs/base/common/errors.js";import"../../../../vs/platform/extensionManagement/common/extensionManagement.js";import"../../../../vs/platform/extensions/common/extensions.js";import{createDecorator as S}from"../../../../vs/platform/instantiation/common/instantiation.js";import{ILogService as h,LogLevel as x}from"../../../../vs/platform/log/common/log.js";import{ITelemetryService as M}from"../../../../vs/platform/telemetry/common/telemetry.js";const R=S("IExtensionSignatureVerificationService");var P=(e=>(e.Success="Success",e.RequiredArgumentMissing="RequiredArgumentMissing",e.InvalidArgument="InvalidArgument",e.PackageIsUnreadable="PackageIsUnreadable",e.UnhandledException="UnhandledException",e.SignatureManifestIsMissing="SignatureManifestIsMissing",e.SignatureManifestIsUnreadable="SignatureManifestIsUnreadable",e.SignatureIsMissing="SignatureIsMissing",e.SignatureIsUnreadable="SignatureIsUnreadable",e.CertificateIsUnreadable="CertificateIsUnreadable",e.SignatureArchiveIsUnreadable="SignatureArchiveIsUnreadable",e.FileAlreadyExists="FileAlreadyExists",e.SignatureArchiveIsInvalidZip="SignatureArchiveIsInvalidZip",e.SignatureArchiveHasSameSignatureFile="SignatureArchiveHasSameSignatureFile",e.PackageIntegrityCheckFailed="PackageIntegrityCheckFailed",e.SignatureIsInvalid="SignatureIsInvalid",e.SignatureManifestIsInvalid="SignatureManifestIsInvalid",e.SignatureIntegrityCheckFailed="SignatureIntegrityCheckFailed",e.EntryIsMissing="EntryIsMissing",e.EntryIsTampered="EntryIsTampered",e.Untrusted="Untrusted",e.CertificateRevoked="CertificateRevoked",e.SignatureIsNotValid="SignatureIsNotValid",e.UnknownError="UnknownError",e.PackageIsInvalidZip="PackageIsInvalidZip",e.SignatureArchiveHasTooManyEntries="SignatureArchiveHasTooManyEntries",e))(P||{});class b extends Error{constructor(i){super(i);this.code=i}}let l=class{constructor(t,i){this.logService=t;this.telemetryService=i}moduleLoadingPromise;vsceSign(){return this.moduleLoadingPromise||(this.moduleLoadingPromise=this.resolveVsceSign()),this.moduleLoadingPromise}async resolveVsceSign(){return y("@vscode/vsce-sign","src/main.js")}async verify(t,i,s,n){let c;const a=t.identifier.id;try{c=await this.vsceSign()}catch(u){return this.logService.error("Could not load vsce-sign module",v(u)),this.logService.info(`Extension signature verification is not done: ${a}`),!1}const f=new Date().getTime();let r;try{this.logService.trace(`Verifying extension signature for ${a}...`),r=await c.verify(i,s,this.logService.getLevel()===x.Trace)}catch(u){r={code:"UnknownError",didExecute:!1,output:v(u)}}const d=new Date().getTime()-f;if(this.logService.info(`Extension signature verification result for ${a}: ${r.code}. Executed: ${r.didExecute}. Duration: ${d}ms.`),this.logService.trace(`Extension signature verification output for ${a}:
${r.output}`),this.telemetryService.publicLog2("extensionsignature:verification",{extensionId:a,extensionVersion:t.version,code:r.code,internalCode:r.internalCode,duration:d,didExecute:r.didExecute,clientTargetPlatform:n}),r.code==="Success")return!0;throw new b(r.code)}};l=m([g(0,h),g(1,M)],l);export{P as ExtensionSignatureVerificationCode,b as ExtensionSignatureVerificationError,l as ExtensionSignatureVerificationService,R as IExtensionSignatureVerificationService};
