{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/extensionManagement/node/extensionDownloader.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Promises } from '../../../base/common/async.js';\nimport { getErrorMessage } from '../../../base/common/errors.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { joinPath } from '../../../base/common/resources.js';\nimport * as semver from '../../../base/common/semver/semver.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { generateUuid } from '../../../base/common/uuid.js';\nimport { Promises as FSPromises } from '../../../base/node/pfs.js';\nimport { buffer, CorruptZipMessage } from '../../../base/node/zip.js';\nimport { INativeEnvironmentService } from '../../environment/common/environment.js';\nimport { ExtensionVerificationStatus, toExtensionManagementError } from '../common/abstractExtensionManagementService.js';\nimport { ExtensionManagementError, ExtensionManagementErrorCode, IExtensionGalleryService, IGalleryExtension, InstallOperation } from '../common/extensionManagement.js';\nimport { ExtensionKey, groupByExtension } from '../common/extensionManagementUtil.js';\nimport { fromExtractError } from './extensionManagementUtil.js';\nimport { ExtensionSignatureVerificationError, ExtensionSignatureVerificationCode, IExtensionSignatureVerificationService } from './extensionSignatureVerificationService.js';\nimport { TargetPlatform } from '../../extensions/common/extensions.js';\nimport { IFileService, IFileStatWithMetadata } from '../../files/common/files.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { ITelemetryService } from '../../telemetry/common/telemetry.js';\n\ntype RetryDownloadClassification = {\n\towner: 'sandy081';\n\tcomment: 'Event reporting the retry of downloading';\n\textensionId: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'Extension Id' };\n\tattempts: { classification: 'SystemMetaData'; purpose: 'PerformanceAndHealth'; isMeasurement: true; comment: 'Number of Attempts' };\n};\ntype RetryDownloadEvent = {\n\textensionId: string;\n\tattempts: number;\n};\n\nexport class ExtensionsDownloader extends Disposable {\n\n\tprivate static readonly SignatureArchiveExtension = '.sigzip';\n\n\treadonly extensionsDownloadDir: URI;\n\tprivate readonly cache: number;\n\tprivate readonly cleanUpPromise: Promise<void>;\n\n\tconstructor(\n\t\t@INativeEnvironmentService environmentService: INativeEnvironmentService,\n\t\t@IFileService private readonly fileService: IFileService,\n\t\t@IExtensionGalleryService private readonly extensionGalleryService: IExtensionGalleryService,\n\t\t@IExtensionSignatureVerificationService private readonly extensionSignatureVerificationService: IExtensionSignatureVerificationService,\n\t\t@ITelemetryService private readonly telemetryService: ITelemetryService,\n\t\t@ILogService private readonly logService: ILogService,\n\t) {\n\t\tsuper();\n\t\tthis.extensionsDownloadDir = environmentService.extensionsDownloadLocation;\n\t\tthis.cache = 20; // Cache 20 downloaded VSIX files\n\t\tthis.cleanUpPromise = this.cleanUp();\n\t}\n\n\tasync download(extension: IGalleryExtension, operation: InstallOperation, verifySignature: boolean, clientTargetPlatform?: TargetPlatform): Promise<{ readonly location: URI; readonly verificationStatus: ExtensionVerificationStatus }> {\n\t\tawait this.cleanUpPromise;\n\n\t\tconst location = await this.downloadVSIX(extension, operation);\n\n\t\tif (!verifySignature) {\n\t\t\treturn { location, verificationStatus: false };\n\t\t}\n\n\t\tif (!extension.isSigned) {\n\t\t\treturn { location, verificationStatus: 'PackageIsUnsigned' };\n\t\t}\n\n\t\tlet signatureArchiveLocation;\n\t\ttry {\n\t\t\tsignatureArchiveLocation = await this.downloadSignatureArchive(extension);\n\t\t} catch (error) {\n\t\t\ttry {\n\t\t\t\t// Delete the downloaded VSIX if signature archive download fails\n\t\t\t\tawait this.delete(location);\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.error(error);\n\t\t\t}\n\t\t\tthrow error;\n\t\t}\n\n\t\tlet verificationStatus;\n\t\ttry {\n\t\t\tverificationStatus = await this.extensionSignatureVerificationService.verify(extension, location.fsPath, signatureArchiveLocation.fsPath, clientTargetPlatform);\n\t\t} catch (error) {\n\t\t\tverificationStatus = (error as ExtensionSignatureVerificationError).code;\n\t\t\tif (verificationStatus === ExtensionSignatureVerificationCode.PackageIsInvalidZip || verificationStatus === ExtensionSignatureVerificationCode.SignatureArchiveIsInvalidZip) {\n\t\t\t\ttry {\n\t\t\t\t\t// Delete the downloaded vsix if VSIX or signature archive is invalid\n\t\t\t\t\tawait this.delete(location);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.logService.error(error);\n\t\t\t\t}\n\t\t\t\tthrow new ExtensionManagementError(CorruptZipMessage, ExtensionManagementErrorCode.CorruptZip);\n\t\t\t}\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\t// Delete signature archive always\n\t\t\t\tawait this.delete(signatureArchiveLocation);\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.error(error);\n\t\t\t}\n\t\t}\n\n\t\treturn { location, verificationStatus };\n\t}\n\n\tprivate async downloadVSIX(extension: IGalleryExtension, operation: InstallOperation): Promise<URI> {\n\t\ttry {\n\t\t\tconst location = joinPath(this.extensionsDownloadDir, this.getName(extension));\n\t\t\tconst attempts = await this.doDownload(extension, 'vsix', async () => {\n\t\t\t\tawait this.downloadFile(extension, location, location => this.extensionGalleryService.download(extension, location, operation));\n\t\t\t\ttry {\n\t\t\t\t\tawait this.validate(location.fsPath, 'extension/package.json');\n\t\t\t\t} catch (error) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait this.fileService.del(location);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tthis.logService.warn(`Error while deleting: ${location.path}`, getErrorMessage(e));\n\t\t\t\t\t}\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}, 2);\n\n\t\t\tif (attempts > 1) {\n\t\t\t\tthis.telemetryService.publicLog2<RetryDownloadEvent, RetryDownloadClassification>('extensiongallery:downloadvsix:retry', {\n\t\t\t\t\textensionId: extension.identifier.id,\n\t\t\t\t\tattempts\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn location;\n\t\t} catch (e) {\n\t\t\tthrow toExtensionManagementError(e, ExtensionManagementErrorCode.Download);\n\t\t}\n\t}\n\n\tprivate async downloadSignatureArchive(extension: IGalleryExtension): Promise<URI> {\n\t\ttry {\n\t\t\tconst location = joinPath(this.extensionsDownloadDir, `.${generateUuid()}`);\n\t\t\tconst attempts = await this.doDownload(extension, 'sigzip', async () => {\n\t\t\t\tawait this.extensionGalleryService.downloadSignatureArchive(extension, location);\n\t\t\t\ttry {\n\t\t\t\t\tawait this.validate(location.fsPath, '.signature.p7s');\n\t\t\t\t} catch (error) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait this.fileService.del(location);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tthis.logService.warn(`Error while deleting: ${location.path}`, getErrorMessage(e));\n\t\t\t\t\t}\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}, 2);\n\n\t\t\tif (attempts > 1) {\n\t\t\t\tthis.telemetryService.publicLog2<RetryDownloadEvent, RetryDownloadClassification>('extensiongallery:downloadsigzip:retry', {\n\t\t\t\t\textensionId: extension.identifier.id,\n\t\t\t\t\tattempts\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn location;\n\t\t} catch (e) {\n\t\t\tthrow toExtensionManagementError(e, ExtensionManagementErrorCode.DownloadSignature);\n\t\t}\n\t}\n\n\tprivate async downloadFile(extension: IGalleryExtension, location: URI, downloadFn: (location: URI) => Promise<void>): Promise<void> {\n\t\t// Do not download if exists\n\t\tif (await this.fileService.exists(location)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Download directly if locaiton is not file scheme\n\t\tif (location.scheme !== Schemas.file) {\n\t\t\tawait downloadFn(location);\n\t\t\treturn;\n\t\t}\n\n\t\t// Download to temporary location first only if file does not exist\n\t\tconst tempLocation = joinPath(this.extensionsDownloadDir, `.${generateUuid()}`);\n\t\ttry {\n\t\t\tawait downloadFn(tempLocation);\n\t\t} catch (error) {\n\t\t\ttry {\n\t\t\t\tawait this.fileService.del(tempLocation);\n\t\t\t} catch (e) { /* ignore */ }\n\t\t\tthrow error;\n\t\t}\n\n\t\ttry {\n\t\t\t// Rename temp location to original\n\t\t\tawait FSPromises.rename(tempLocation.fsPath, location.fsPath, 2 * 60 * 1000 /* Retry for 2 minutes */);\n\t\t} catch (error) {\n\t\t\ttry { await this.fileService.del(tempLocation); } catch (e) { /* ignore */ }\n\t\t\tlet exists = false;\n\t\t\ttry { exists = await this.fileService.exists(location); } catch (e) { /* ignore */ }\n\t\t\tif (exists) {\n\t\t\t\tthis.logService.info(`Rename failed because the file was downloaded by another source. So ignoring renaming.`, extension.identifier.id, location.path);\n\t\t\t} else {\n\t\t\t\tthis.logService.info(`Rename failed because of ${getErrorMessage(error)}. Deleted the file from downloaded location`, tempLocation.path);\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async doDownload(extension: IGalleryExtension, name: string, downloadFn: () => Promise<void>, retries: number): Promise<number> {\n\t\tlet attempts = 1;\n\t\twhile (true) {\n\t\t\ttry {\n\t\t\t\tawait downloadFn();\n\t\t\t\treturn attempts;\n\t\t\t} catch (e) {\n\t\t\t\tif (attempts++ > retries) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t\tthis.logService.warn(`Failed downloading ${name}. ${getErrorMessage(e)}. Retry again...`, extension.identifier.id);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected async validate(zipPath: string, filePath: string): Promise<void> {\n\t\ttry {\n\t\t\tawait buffer(zipPath, filePath);\n\t\t} catch (e) {\n\t\t\tthrow fromExtractError(e);\n\t\t}\n\t}\n\n\tasync delete(location: URI): Promise<void> {\n\t\tawait this.cleanUpPromise;\n\t\tawait this.fileService.del(location);\n\t}\n\n\tprivate async cleanUp(): Promise<void> {\n\t\ttry {\n\t\t\tif (!(await this.fileService.exists(this.extensionsDownloadDir))) {\n\t\t\t\tthis.logService.trace('Extension VSIX downloads cache dir does not exist');\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst folderStat = await this.fileService.resolve(this.extensionsDownloadDir, { resolveMetadata: true });\n\t\t\tif (folderStat.children) {\n\t\t\t\tconst toDelete: URI[] = [];\n\t\t\t\tconst vsixs: [ExtensionKey, IFileStatWithMetadata][] = [];\n\t\t\t\tconst signatureArchives: URI[] = [];\n\n\t\t\t\tfor (const stat of folderStat.children) {\n\t\t\t\t\tif (stat.name.endsWith(ExtensionsDownloader.SignatureArchiveExtension)) {\n\t\t\t\t\t\tsignatureArchives.push(stat.resource);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst extension = ExtensionKey.parse(stat.name);\n\t\t\t\t\t\tif (extension) {\n\t\t\t\t\t\t\tvsixs.push([extension, stat]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst byExtension = groupByExtension(vsixs, ([extension]) => extension);\n\t\t\t\tconst distinct: IFileStatWithMetadata[] = [];\n\t\t\t\tfor (const p of byExtension) {\n\t\t\t\t\tp.sort((a, b) => semver.rcompare(a[0].version, b[0].version));\n\t\t\t\t\ttoDelete.push(...p.slice(1).map(e => e[1].resource)); // Delete outdated extensions\n\t\t\t\t\tdistinct.push(p[0][1]);\n\t\t\t\t}\n\t\t\t\tdistinct.sort((a, b) => a.mtime - b.mtime); // sort by modified time\n\t\t\t\ttoDelete.push(...distinct.slice(0, Math.max(0, distinct.length - this.cache)).map(s => s.resource)); // Retain minimum cacheSize and delete the rest\n\t\t\t\ttoDelete.push(...signatureArchives); // Delete all signature archives\n\n\t\t\t\tawait Promises.settled(toDelete.map(resource => {\n\t\t\t\t\tthis.logService.trace('Deleting from cache', resource.path);\n\t\t\t\t\treturn this.fileService.del(resource);\n\t\t\t\t}));\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tthis.logService.error(e);\n\t\t}\n\t}\n\n\tprivate getName(extension: IGalleryExtension): string {\n\t\treturn this.cache ? ExtensionKey.create(extension).toString().toLowerCase() : generateUuid();\n\t}\n\n}\n"],
  "mappings": "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",
  "names": ["error", "location"]
}
