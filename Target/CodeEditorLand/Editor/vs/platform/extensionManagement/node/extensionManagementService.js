var Z=Object.defineProperty;var ee=Object.getOwnPropertyDescriptor;var L=(u,m,e,i)=>{for(var t=i>1?void 0:i?ee(m,e):m,n=u.length-1,s;n>=0;n--)(s=u[n])&&(t=(i?s(m,e,t):s(t))||t);return i&&t&&Z(m,e,t),t},c=(u,m)=>(e,i)=>m(e,i,u);import*as ie from"fs";import{Promises as te,Queue as ne}from"../../../base/common/async.js";import{VSBuffer as se}from"../../../base/common/buffer.js";import{CancellationToken as re}from"../../../base/common/cancellation.js";import"../../../base/common/collections.js";import{toErrorMessage as ae}from"../../../base/common/errorMessage.js";import{CancellationError as w,getErrorMessage as V}from"../../../base/common/errors.js";import{Emitter as oe}from"../../../base/common/event.js";import{hash as le}from"../../../base/common/hash.js";import{Disposable as ce}from"../../../base/common/lifecycle.js";import{ResourceMap as B,ResourceSet as de}from"../../../base/common/map.js";import{Schemas as he}from"../../../base/common/network.js";import*as I from"../../../base/common/path.js";import{joinPath as C}from"../../../base/common/resources.js";import*as xe from"../../../base/common/semver/semver.js";import{isBoolean as q}from"../../../base/common/types.js";import{URI as E}from"../../../base/common/uri.js";import{generateUuid as D}from"../../../base/common/uuid.js";import*as z from"../../../base/node/pfs.js";import{extract as fe,zip as me}from"../../../base/node/zip.js";import*as p from"../../../nls.js";import{IDownloadService as pe}from"../../download/common/download.js";import{INativeEnvironmentService as ue}from"../../environment/common/environment.js";import{AbstractExtensionManagementService as Se,AbstractExtensionTask as j,toExtensionManagementError as d}from"../common/abstractExtensionManagementService.js";import{ExtensionManagementError as M,ExtensionManagementErrorCode as h,IExtensionGalleryService as K,IExtensionManagementService as Ee,InstallOperation as T,EXTENSION_INSTALL_CLIENT_TARGET_PLATFORM_CONTEXT as ve}from"../common/extensionManagement.js";import{areSameExtensions as y,computeTargetPlatform as Ie,ExtensionKey as f,getGalleryExtensionId as A,groupByExtension as ge}from"../common/extensionManagementUtil.js";import{IExtensionsProfileScannerService as _}from"../common/extensionsProfileScannerService.js";import{IExtensionsScannerService as N}from"../common/extensionsScannerService.js";import{ExtensionsDownloader as ye}from"./extensionDownloader.js";import{ExtensionsLifecycle as we}from"./extensionLifecycle.js";import{fromExtractError as Pe,getManifest as k}from"./extensionManagementUtil.js";import{ExtensionsManifestCache as Ue}from"./extensionsManifestCache.js";import{ExtensionsWatcher as Re}from"./extensionsWatcher.js";import{ExtensionType as x}from"../../extensions/common/extensions.js";import{isEngineValid as Le}from"../../extensions/common/extensionValidator.js";import{FileChangeType as De,FileOperationResult as O,IFileService as W,toFileOperationResult as P}from"../../files/common/files.js";import{IInstantiationService as Me,refineServiceDecorator as Te}from"../../instantiation/common/instantiation.js";import{ILogService as G}from"../../log/common/log.js";import{IProductService as be}from"../../product/common/productService.js";import{ITelemetryService as X}from"../../telemetry/common/telemetry.js";import{IUriIdentityService as $}from"../../uriIdentity/common/uriIdentity.js";import{IUserDataProfilesService as Q}from"../../userDataProfile/common/userDataProfile.js";const ki=Te(Ee),J=".vsctmp";let b=class extends Se{constructor(e,i,t,n,s,r,a,o,l,v,S,g){super(e,i,S,t,v,g);this.extensionsScannerService=s;this.extensionsProfileScannerService=r;this.downloadService=a;this.instantiationService=o;this.fileService=l;const Y=this._register(o.createInstance(we));this.extensionsScanner=this._register(o.createInstance(U,F=>Y.postUninstall(F))),this.manifestCache=this._register(new Ue(g,l,S,this,this.logService)),this.extensionsDownloader=this._register(o.createInstance(ye));const H=this._register(new Re(this,this.extensionsScannerService,g,r,S,l,t));this._register(H.onDidChangeExtensionsByAnotherSource(F=>this.onDidChangeExtensionsFromAnotherSource(F))),this.watchForExtensionsNotInstalledBySystem()}extensionsScanner;manifestCache;extensionsDownloader;extractingGalleryExtensions=new Map;_targetPlatformPromise;getTargetPlatform(){return this._targetPlatformPromise||(this._targetPlatformPromise=Ie(this.fileService,this.logService)),this._targetPlatformPromise}async zip(e){this.logService.trace("ExtensionManagementService#zip",e.identifier.id);const i=await this.collectFiles(e),t=await me(C(this.extensionsDownloader.extensionsDownloadDir,D()).fsPath,i);return E.file(t)}async getManifest(e){const{location:i,cleanup:t}=await this.downloadVsix(e),n=I.resolve(i.fsPath);try{return await k(n)}finally{await t()}}getInstalled(e,i=this.userDataProfilesService.defaultProfile.extensionsResource,t={version:this.productService.version,date:this.productService.date}){return this.extensionsScanner.scanExtensions(e??null,i,t)}scanAllUserInstalledExtensions(){return this.extensionsScanner.scanAllUserExtensions(!1)}scanInstalledExtensionAtLocation(e){return this.extensionsScanner.scanUserExtensionAtLocation(e)}async install(e,i={}){this.logService.trace("ExtensionManagementService#install",e.toString());const{location:t,cleanup:n}=await this.downloadVsix(e);try{const s=await k(I.resolve(t.fsPath)),r=A(s.publisher,s.name);if(s.engines&&s.engines.vscode&&!Le(s.engines.vscode,this.productService.version,this.productService.date))throw new Error(p.localize("incompatible","Unable to install extension '{0}' as it is not compatible with VS Code '{1}'.",r,this.productService.version));const o=(await this.installExtensions([{manifest:s,extension:t,options:i}])).find(({identifier:l})=>y(l,{id:r}));if(o?.local)return o.local;throw o?.error?o.error:d(new Error(`Unknown error while installing extension ${r}`))}finally{await n()}}async installFromLocation(e,i){this.logService.trace("ExtensionManagementService#installFromLocation",e.toString());const t=await this.extensionsScanner.scanUserExtensionAtLocation(e);if(!t||!t.manifest.name||!t.manifest.version)throw new Error(`Cannot find a valid extension from the location ${e.toString()}`);return await this.addExtensionsToProfile([[t,{source:"resource"}]],i),this.logService.info("Successfully installed extension",t.identifier.id,i.toString()),t}async installExtensionsFromProfile(e,i,t){this.logService.trace("ExtensionManagementService#installExtensionsFromProfile",e,i.toString(),t.toString());const n=(await this.getInstalled(x.User,i)).filter(s=>e.some(r=>y(r,s.identifier)));if(n.length){const s=await Promise.all(n.map(r=>this.extensionsScanner.scanMetadata(r,i)));await this.addExtensionsToProfile(n.map((r,a)=>[r,s[a]]),t),this.logService.info("Successfully installed extensions",n.map(r=>r.identifier.id),t.toString())}return n}async updateMetadata(e,i,t){return this.logService.trace("ExtensionManagementService#updateMetadata",e.identifier.id),i.isPreReleaseVersion&&(i.preRelease=!0,i.hasPreReleaseVersion=!0),i.isMachineScoped===!1&&(i.isMachineScoped=void 0),i.isBuiltin===!1&&(i.isBuiltin=void 0),i.pinned===!1&&(i.pinned=void 0),e=await this.extensionsScanner.updateMetadata(e,i,t),this.manifestCache.invalidate(t),this._onDidUpdateExtensionMetadata.fire({local:e,profileLocation:t}),e}async reinstallFromGallery(e){if(this.logService.trace("ExtensionManagementService#reinstallFromGallery",e.identifier.id),!this.galleryService.isEnabled())throw new Error(p.localize("MarketPlaceDisabled","Marketplace is not enabled"));const i=await this.getTargetPlatform(),[t]=await this.galleryService.getExtensions([{...e.identifier,preRelease:e.preRelease}],{targetPlatform:i,compatible:!0},re.None);if(!t)throw new Error(p.localize("Not a Marketplace extension","Only Marketplace Extensions can be reinstalled"));await this.extensionsScanner.setUninstalled(e);try{await this.extensionsScanner.removeUninstalledExtension(e)}catch(n){throw new Error(p.localize("removeError","Error while removing the extension: {0}. Please Quit and Start VS Code before trying again.",ae(n)))}return this.installFromGallery(t)}copyExtension(e,i,t,n){return this.extensionsScanner.copyExtension(e,i,t,n)}copyExtensions(e,i){return this.extensionsScanner.copyExtensions(e,i,{version:this.productService.version,date:this.productService.date})}markAsUninstalled(...e){return this.extensionsScanner.setUninstalled(...e)}async cleanUp(){this.logService.trace("ExtensionManagementService#cleanUp");try{await this.extensionsScanner.cleanUp()}catch(e){this.logService.error(e)}}async download(e,i,t){const{location:n}=await this.extensionsDownloader.download(e,i,!t);return n}async downloadVsix(e){if(e.scheme===he.file)return{location:e,async cleanup(){}};this.logService.trace("Downloading extension from",e.toString());const i=C(this.extensionsDownloader.extensionsDownloadDir,D());return await this.downloadService.download(e,i),this.logService.info("Downloaded extension to",i.toString()),{location:i,cleanup:async()=>{try{await this.fileService.del(i)}catch(n){this.logService.error(n)}}}}getCurrentExtensionsManifestLocation(){return this.userDataProfilesService.defaultProfile.extensionsResource}createInstallExtensionTask(e,i,t){const n=i instanceof E?new f({id:A(e.publisher,e.name)},e.version):f.create(i);return this.instantiationService.createInstance(R,n,e,i,t,(s,r)=>{if(i instanceof E)return this.extractVSIX(n,i,t,r);let a=this.extractingGalleryExtensions.get(n.toString());return a||(this.extractingGalleryExtensions.set(n.toString(),a=this.downloadAndExtractGalleryExtension(n,i,s,t,r)),a.finally(()=>this.extractingGalleryExtensions.delete(n.toString()))),a},this.extensionsScanner)}createUninstallExtensionTask(e,i){return new Fe(e,i,this.extensionsProfileScannerService)}async downloadAndExtractGalleryExtension(e,i,t,n,s){const{verificationStatus:r,location:a}=await this.extensionsDownloader.download(i,t,!n.donotVerifySignature,n.context?.[ve]);try{if(s.isCancellationRequested)throw new w;const o=await k(a.fsPath);if(!new f(i.identifier,i.version).equals(new f({id:A(o.publisher,o.name)},o.version)))throw new M(p.localize("invalidManifest","Cannot install '{0}' extension because of manifest mismatch with Marketplace",i.identifier.id),h.Invalid);return{local:await this.extensionsScanner.extractUserExtension(e,a.fsPath,{id:i.identifier.uuid,publisherId:i.publisherId,publisherDisplayName:i.publisherDisplayName,targetPlatform:i.properties.targetPlatform,isApplicationScoped:n.isApplicationScoped,isMachineScoped:n.isMachineScoped,isBuiltin:n.isBuiltin,isPreReleaseVersion:i.properties.isPreReleaseVersion,hasPreReleaseVersion:i.properties.isPreReleaseVersion,installedTimestamp:Date.now(),pinned:n.installGivenVersion?!0:!!n.pinned,preRelease:q(n.preRelease)?n.preRelease:n.installPreReleaseVersion||i.properties.isPreReleaseVersion,source:"gallery"},!1,s),verificationStatus:r}}catch(o){try{await this.extensionsDownloader.delete(a)}catch(l){this.logService.warn("Error while deleting the downloaded file",a.toString(),V(l))}throw d(o)}}async extractVSIX(e,i,t,n){return{local:await this.extensionsScanner.extractUserExtension(e,I.resolve(i.fsPath),{isApplicationScoped:t.isApplicationScoped,isMachineScoped:t.isMachineScoped,isBuiltin:t.isBuiltin,installedTimestamp:Date.now(),pinned:t.installGivenVersion?!0:!!t.pinned,source:"vsix"},t.keepExisting??!0,n)}}async collectFiles(e){const i=async n=>{let s=await z.Promises.readdir(n);s=s.map(o=>I.join(n,o));const r=await Promise.all(s.map(o=>ie.promises.stat(o)));let a=Promise.resolve([]);return r.forEach((o,l)=>{const v=s[l];o.isFile()&&(a=a.then(S=>[...S,v])),o.isDirectory()&&(a=a.then(S=>i(v).then(g=>[...S,...g])))}),a};return(await i(e.location.fsPath)).map(n=>({path:`extension/${I.relative(e.location.fsPath,n)}`,localPath:n}))}async onDidChangeExtensionsFromAnotherSource({added:e,removed:i}){if(i){const t=e&&this.uriIdentityService.extUri.isEqual(i.profileLocation,e.profileLocation)?i.extensions.filter(n=>e.extensions.every(s=>!y(s,n))):i.extensions;for(const n of t)this.logService.info("Extensions removed from another source",n.id,i.profileLocation.toString()),this._onDidUninstallExtension.fire({identifier:n,profileLocation:i.profileLocation})}if(e){const n=(await this.getInstalled(x.User,e.profileLocation)).filter(s=>e.extensions.some(r=>y(r,s.identifier)));this._onDidInstallExtensions.fire(n.map(s=>(this.logService.info("Extensions added from another source",s.identifier.id,e.profileLocation.toString()),{identifier:s.identifier,local:s,profileLocation:e.profileLocation,operation:T.None})))}}knownDirectories=new de;async watchForExtensionsNotInstalledBySystem(){this._register(this.extensionsScanner.onExtract(i=>this.knownDirectories.add(i)));const e=await this.fileService.resolve(this.extensionsScannerService.userExtensionsLocation);for(const i of e.children??[])i.isDirectory&&this.knownDirectories.add(i.resource);this._register(this.fileService.watch(this.extensionsScannerService.userExtensionsLocation)),this._register(this.fileService.onDidFilesChange(i=>this.onDidFilesChange(i)))}async onDidFilesChange(e){if(!e.affects(this.extensionsScannerService.userExtensionsLocation,De.ADDED))return;const i=[];for(const t of e.rawAdded){if(this.knownDirectories.has(t)||!this.uriIdentityService.extUri.isEqual(this.uriIdentityService.extUri.dirname(t),this.extensionsScannerService.userExtensionsLocation)||this.uriIdentityService.extUri.isEqual(t,this.uriIdentityService.extUri.joinPath(this.extensionsScannerService.userExtensionsLocation,".obsolete"))||this.uriIdentityService.extUri.basename(t).startsWith(".")||!(await this.fileService.stat(t)).isDirectory)continue;const n=await this.extensionsScanner.scanUserExtensionAtLocation(t);n&&n.installedTimestamp===void 0&&(this.knownDirectories.add(t),i.push(n))}i.length&&(await this.addExtensionsToProfile(i.map(t=>[t,void 0]),this.userDataProfilesService.defaultProfile.extensionsResource),this.logService.info("Added extensions to default profile from external source",i.map(t=>t.identifier.id)))}async addExtensionsToProfile(e,i){const t=e.map(n=>n[0]);await this.setInstalled(t),await this.extensionsProfileScannerService.addExtensionsToProfile(e,i),this._onDidInstallExtensions.fire(t.map(n=>({local:n,identifier:n.identifier,operation:T.None,profileLocation:i})))}async setInstalled(e){const i=await this.extensionsScanner.getUninstalledExtensions();for(const t of e){const n=f.create(t);i[n.toString()]&&(this.logService.trace("Removing the extension from uninstalled list:",n.id),await this.extensionsScanner.setInstalled(n),this.logService.info("Removed the extension from uninstalled list:",n.id))}}};b=L([c(0,K),c(1,X),c(2,G),c(3,ue),c(4,N),c(5,_),c(6,pe),c(7,Me),c(8,W),c(9,be),c(10,$),c(11,Q)],b);let U=class extends ce{constructor(e,i,t,n,s,r,a){super();this.beforeRemovingExtension=e;this.fileService=i;this.extensionsScannerService=t;this.extensionsProfileScannerService=n;this.uriIdentityService=s;this.telemetryService=r;this.logService=a;this.uninstalledResource=C(this.extensionsScannerService.userExtensionsLocation,".obsolete"),this.uninstalledFileLimiter=new ne}uninstalledResource;uninstalledFileLimiter;_onExtract=this._register(new oe);onExtract=this._onExtract.event;scanAllExtensionPromise=new B;scanUserExtensionsPromise=new B;async cleanUp(){await this.removeTemporarilyDeletedFolders(),await this.removeUninstalledExtensions()}async scanExtensions(e,i,t){try{const n={includeInvalid:!0,profileLocation:i,productVersion:t};let s=[];if(e===null||e===x.System){let r=this.scanAllExtensionPromise.get(i);r||(r=this.extensionsScannerService.scanAllExtensions({includeInvalid:!0,useCache:!0},n,!1).finally(()=>this.scanAllExtensionPromise.delete(i)),this.scanAllExtensionPromise.set(i,r)),s.push(...await r)}else if(e===x.User){let r=this.scanUserExtensionsPromise.get(i);r||(r=this.extensionsScannerService.scanUserExtensions(n).finally(()=>this.scanUserExtensionsPromise.delete(i)),this.scanUserExtensionsPromise.set(i,r)),s.push(...await r)}return s=e!==null?s.filter(r=>r.type===e):s,await Promise.all(s.map(r=>this.toLocalExtension(r)))}catch(n){throw d(n,h.Scanning)}}async scanAllUserExtensions(e){try{const i=await this.extensionsScannerService.scanUserExtensions({includeAllVersions:!e,includeInvalid:!0});return await Promise.all(i.map(t=>this.toLocalExtension(t)))}catch(i){throw d(i,h.Scanning)}}async scanUserExtensionAtLocation(e){try{const i=await this.extensionsScannerService.scanExistingExtension(e,x.User,{includeInvalid:!0});if(i)return await this.toLocalExtension(i)}catch(i){this.logService.error(i)}return null}async extractUserExtension(e,i,t,n,s){const r=e.toString(),a=E.file(I.join(this.extensionsScannerService.userExtensionsLocation.fsPath,`.${D()}`)),o=E.file(I.join(this.extensionsScannerService.userExtensionsLocation.fsPath,r));if(await this.fileService.exists(o)){if(!n)try{return await this.scanLocalExtension(o,x.User)}catch(l){this.logService.warn(`Error while scanning the existing extension at ${o.path}. Deleting the existing extension and extracting it.`,V(l))}try{await this.deleteExtensionFromLocation(e.id,o,"removeExisting")}catch{throw new M(p.localize("errorDeleting","Unable to delete the existing folder '{0}' while installing the extension '{1}'. Please delete the folder manually and try again",o.fsPath,e.id),h.Delete)}}try{if(s.isCancellationRequested)throw new w;try{this.logService.trace(`Started extracting the extension from ${i} to ${o.fsPath}`),await fe(i,a.fsPath,{sourcePath:"extension",overwrite:!0},s),this.logService.info(`Extracted extension to ${o}:`,e.id)}catch(l){throw Pe(l)}try{await this.extensionsScannerService.updateMetadata(a,t)}catch(l){throw this.telemetryService.publicLog2("extension:extract",{extensionId:e.id,code:`${P(l)}`}),d(l,h.UpdateMetadata)}if(s.isCancellationRequested)throw new w;try{this.logService.trace(`Started renaming the extension from ${a.fsPath} to ${o.fsPath}`),await this.rename(a.fsPath,o.fsPath),this.logService.info("Renamed to",o.fsPath)}catch(l){if(l.code==="ENOTEMPTY"){this.logService.info("Rename failed because extension was installed by another source. So ignoring renaming.",e.id);try{await this.fileService.del(a,{recursive:!0})}catch{}}else throw this.logService.info(`Rename failed because of ${V(l)}. Deleted from extracted location`,a),l}this._onExtract.fire(o)}catch(l){try{await this.fileService.del(a,{recursive:!0})}catch{}throw l}return this.scanLocalExtension(o,x.User)}async scanMetadata(e,i){return i?(await this.getScannedExtension(e,i))?.metadata:this.extensionsScannerService.scanMetadata(e.location)}async getScannedExtension(e,i){return(await this.extensionsProfileScannerService.scanProfileExtensions(i)).find(n=>y(n.identifier,e.identifier))}async updateMetadata(e,i,t){try{t?await this.extensionsProfileScannerService.updateMetadata([[e,i]],t):await this.extensionsScannerService.updateMetadata(e.location,i)}catch(n){throw this.telemetryService.publicLog2("extension:extract",{extensionId:e.identifier.id,code:`${P(n)}`,isProfile:!!t}),d(n,h.UpdateMetadata)}return this.scanLocalExtension(e.location,e.type,t)}async getUninstalledExtensions(){try{return await this.withUninstalledExtensions()}catch(e){throw d(e,h.ReadUninstalled)}}async setUninstalled(...e){const i=e.map(t=>f.create(t));await this.withUninstalledExtensions(t=>i.forEach(n=>{t[n.toString()]=!0,this.logService.info("Marked extension as uninstalled",n.toString())}))}async setInstalled(e){try{await this.withUninstalledExtensions(i=>delete i[e.toString()])}catch(i){throw d(i,h.UnsetUninstalled)}}async removeExtension(e,i){if(this.uriIdentityService.extUri.isEqualOrParent(e.location,this.extensionsScannerService.userExtensionsLocation))return this.deleteExtensionFromLocation(e.identifier.id,e.location,i)}async removeUninstalledExtension(e){await this.removeExtension(e,"uninstalled"),await this.withUninstalledExtensions(i=>delete i[f.create(e).toString()])}async copyExtension(e,i,t,n){const s=await this.getScannedExtension(e,i),r=await this.getScannedExtension(e,t);if(n={...s?.metadata,...n},r)if(this.uriIdentityService.extUri.isEqual(r.location,e.location))await this.extensionsProfileScannerService.updateMetadata([[e,{...r.metadata,...n}]],t);else{const a=await this.scanLocalExtension(r.location,e.type,t);await this.extensionsProfileScannerService.removeExtensionFromProfile(a,t),await this.extensionsProfileScannerService.addExtensionsToProfile([[e,{...r.metadata,...n}]],t)}else await this.extensionsProfileScannerService.addExtensionsToProfile([[e,n]],t);return this.scanLocalExtension(e.location,e.type,t)}async copyExtensions(e,i,t){const n=await this.scanExtensions(x.User,e,t),s=await Promise.all(n.filter(r=>!r.isApplicationScoped).map(async r=>[r,await this.scanMetadata(r,e)]));await this.extensionsProfileScannerService.addExtensionsToProfile(s,i)}async deleteExtensionFromLocation(e,i,t){this.logService.trace(`Deleting ${t} extension from disk`,e,i.fsPath);const n=this.uriIdentityService.extUri.joinPath(this.uriIdentityService.extUri.dirname(i),`${this.uriIdentityService.extUri.basename(i)}.${le(D()).toString(16)}${J}`);await this.rename(i.fsPath,n.fsPath),await this.fileService.del(n,{recursive:!0}),this.logService.info(`Deleted ${t} extension from disk`,e,i.fsPath)}withUninstalledExtensions(e){return this.uninstalledFileLimiter.queue(async()=>{let i;try{i=(await this.fileService.readFile(this.uninstalledResource,"utf8")).value.toString()}catch(n){if(P(n)!==O.FILE_NOT_FOUND)throw n}let t={};if(i)try{t=JSON.parse(i)}catch{}return e&&(e(t),Object.keys(t).length?await this.fileService.writeFile(this.uninstalledResource,se.fromString(JSON.stringify(t))):await this.fileService.del(this.uninstalledResource)),t})}async rename(e,i){try{await z.Promises.rename(e,i,2*60*1e3)}catch(t){throw d(t,h.Rename)}}async scanLocalExtension(e,i,t){try{if(t){const s=(await this.extensionsScannerService.scanUserExtensions({profileLocation:t})).find(r=>this.uriIdentityService.extUri.isEqual(r.location,e));if(s)return await this.toLocalExtension(s)}else{const n=await this.extensionsScannerService.scanExistingExtension(e,i,{includeInvalid:!0});if(n)return await this.toLocalExtension(n)}throw new M(p.localize("cannot read","Cannot read the extension from {0}",e.path),h.ScanningExtension)}catch(n){throw d(n,h.ScanningExtension)}}async toLocalExtension(e){const i=await this.fileService.resolve(e.location);let t,n;return i.children&&(t=i.children.find(({name:s})=>/^readme(\.txt|\.md|)$/i.test(s))?.resource,n=i.children.find(({name:s})=>/^changelog(\.txt|\.md|)$/i.test(s))?.resource),{identifier:e.identifier,type:e.type,isBuiltin:e.isBuiltin||!!e.metadata?.isBuiltin,location:e.location,manifest:e.manifest,targetPlatform:e.targetPlatform,validations:e.validations,isValid:e.isValid,readmeUrl:t,changelogUrl:n,publisherDisplayName:e.metadata?.publisherDisplayName,publisherId:e.metadata?.publisherId||null,isApplicationScoped:!!e.metadata?.isApplicationScoped,isMachineScoped:!!e.metadata?.isMachineScoped,isPreReleaseVersion:!!e.metadata?.isPreReleaseVersion,hasPreReleaseVersion:!!e.metadata?.hasPreReleaseVersion,preRelease:!!e.metadata?.preRelease,installedTimestamp:e.metadata?.installedTimestamp,updated:!!e.metadata?.updated,pinned:!!e.metadata?.pinned,isWorkspaceScoped:!1,source:e.metadata?.source??(e.identifier.uuid?"gallery":"vsix")}}async removeUninstalledExtensions(){const e=await this.getUninstalledExtensions();if(Object.keys(e).length===0){this.logService.debug("No uninstalled extensions found.");return}this.logService.debug("Removing uninstalled extensions:",Object.keys(e));const i=await this.extensionsScannerService.scanUserExtensions({includeAllVersions:!0,includeUninstalled:!0,includeInvalid:!0}),t=new Set;for(const s of i)e[f.create(s).toString()]||t.add(s.identifier.id.toLowerCase());try{const s=ge(i,r=>r.identifier);await te.settled(s.map(async r=>{const a=r.sort((o,l)=>xe.rcompare(o.manifest.version,l.manifest.version))[0];t.has(a.identifier.id.toLowerCase())||await this.beforeRemovingExtension(await this.toLocalExtension(a))}))}catch(s){this.logService.error(s)}const n=i.filter(s=>s.metadata&&e[f.create(s).toString()]);await Promise.allSettled(n.map(s=>this.removeUninstalledExtension(s)))}async removeTemporarilyDeletedFolders(){this.logService.trace("ExtensionManagementService#removeTempDeleteFolders");let e;try{e=await this.fileService.resolve(this.extensionsScannerService.userExtensionsLocation)}catch(i){P(i)!==O.FILE_NOT_FOUND&&this.logService.error(i);return}if(e?.children)try{await Promise.allSettled(e.children.map(async i=>{if(!(!i.isDirectory||!i.name.endsWith(J))){this.logService.trace("Deleting the temporarily deleted folder",i.resource.toString());try{await this.fileService.del(i.resource,{recursive:!0}),this.logService.trace("Deleted the temporarily deleted folder",i.resource.toString())}catch(t){P(t)!==O.FILE_NOT_FOUND&&this.logService.error(t)}}}))}catch{}}};U=L([c(1,W),c(2,N),c(3,_),c(4,$),c(5,X),c(6,G)],U);let R=class extends j{constructor(e,i,t,n,s,r,a,o,l,v,S,g){super();this.extensionKey=e;this.manifest=i;this.source=t;this.options=n;this.extractExtensionFn=s;this.extensionsScanner=r;this.uriIdentityService=a;this.galleryService=o;this.userDataProfilesService=l;this.extensionsScannerService=v;this.extensionsProfileScannerService=S;this.logService=g;this.identifier=this.extensionKey.identifier}_operation=T.Install;get operation(){return this.options.operation??this._operation}_verificationStatus;get verificationStatus(){return this._verificationStatus}identifier;async doRun(e){const t=(await this.extensionsScanner.scanExtensions(x.User,this.options.profileLocation,this.options.productVersion)).find(a=>y(a.identifier,this.identifier));t&&(this._operation=T.Update);const n={isApplicationScoped:this.options.isApplicationScoped||t?.isApplicationScoped,isMachineScoped:this.options.isMachineScoped||t?.isMachineScoped,isBuiltin:this.options.isBuiltin||t?.isBuiltin,isSystem:t?.type===x.System?!0:void 0,installedTimestamp:Date.now(),pinned:this.options.installGivenVersion?!0:this.options.pinned??t?.pinned,source:this.source instanceof E?"vsix":"gallery"};let s;if(this.source instanceof E){if(t&&this.extensionKey.equals(new f(t.identifier,t.manifest.version)))try{await this.extensionsScanner.removeExtension(t,"existing")}catch{throw new Error(p.localize("restartCode","Please restart VS Code before reinstalling {0}.",this.manifest.displayName||this.manifest.name))}const a=await this.unsetIfUninstalled(this.extensionKey);if(a)try{await this.extensionsScanner.removeExtension(a,"existing")}catch{throw new Error(p.localize("restartCode","Please restart VS Code before reinstalling {0}.",this.manifest.displayName||this.manifest.name))}}else{if(n.id=this.source.identifier.uuid,n.publisherId=this.source.publisherId,n.publisherDisplayName=this.source.publisherDisplayName,n.targetPlatform=this.source.properties.targetPlatform,n.updated=!!t,n.isPreReleaseVersion=this.source.properties.isPreReleaseVersion,n.hasPreReleaseVersion=t?.hasPreReleaseVersion||this.source.properties.isPreReleaseVersion,n.preRelease=q(this.options.preRelease)?this.options.preRelease:this.options.installPreReleaseVersion||this.source.properties.isPreReleaseVersion||t?.preRelease,t&&t.type!==x.System&&t.manifest.version===this.source.version)return this.extensionsScanner.updateMetadata(t,n,this.options.profileLocation);s=await this.unsetIfUninstalled(this.extensionKey)}if(e.isCancellationRequested)throw d(new w);if(!s){const a=await this.extractExtensionFn(this.operation,e);s=a.local,this._verificationStatus=a.verificationStatus}if(this.uriIdentityService.extUri.isEqual(this.userDataProfilesService.defaultProfile.extensionsResource,this.options.profileLocation))try{await this.extensionsScannerService.initializeDefaultProfileExtensions()}catch(a){throw d(a,h.IntializeDefaultProfile)}if(e.isCancellationRequested)throw d(new w);try{await this.extensionsProfileScannerService.addExtensionsToProfile([[s,n]],this.options.profileLocation,!s.isValid)}catch(a){throw d(a,h.AddToProfile)}const r=await this.extensionsScanner.scanLocalExtension(s.location,x.User,this.options.profileLocation);if(!r)throw new M("Cannot find the installed extension",h.InstalledExtensionNotFound);return this.source instanceof E&&this.updateMetadata(s,e),r}async unsetIfUninstalled(e){return(await this.extensionsScanner.getUninstalledExtensions())[e.toString()]?(this.logService.trace("Removing the extension from uninstalled list:",e.id),await this.extensionsScanner.setInstalled(e),this.logService.info("Removed the extension from uninstalled list:",e.id),(await this.extensionsScanner.scanAllUserExtensions(!0)).find(n=>f.create(n).equals(e))):void 0}async updateMetadata(e,i){try{let[t]=await this.galleryService.getExtensions([{id:e.identifier.id,version:e.manifest.version}],i);if(t||([t]=await this.galleryService.getExtensions([{id:e.identifier.id}],i)),t){const n={id:t.identifier.uuid,publisherDisplayName:t.publisherDisplayName,publisherId:t.publisherId,isPreReleaseVersion:t.properties.isPreReleaseVersion,hasPreReleaseVersion:e.hasPreReleaseVersion||t.properties.isPreReleaseVersion,preRelease:t.properties.isPreReleaseVersion||this.options.installPreReleaseVersion};await this.extensionsScanner.updateMetadata(e,n,this.options.profileLocation)}}catch{}}};R=L([c(6,$),c(7,K),c(8,Q),c(9,N),c(10,_),c(11,G)],R);class Fe extends j{constructor(e,i,t){super();this.extension=e;this.options=i;this.extensionsProfileScannerService=t}async doRun(e){await this.extensionsProfileScannerService.removeExtensionFromProfile(this.extension,this.options.profileLocation)}}export{b as ExtensionManagementService,U as ExtensionsScanner,ki as INativeServerExtensionManagementService};
