var ie=Object.defineProperty;var te=Object.getOwnPropertyDescriptor;var D=(p,S,e,i)=>{for(var t=i>1?void 0:i?te(S,e):S,n=p.length-1,s;n>=0;n--)(s=p[n])&&(t=(i?s(S,e,t):s(t))||t);return i&&t&&ie(S,e,t),t},c=(p,S)=>(e,i)=>S(e,i,p);import*as ne from"fs";import{Promises as se,Queue as re}from"../../../base/common/async.js";import{VSBuffer as ae}from"../../../base/common/buffer.js";import{CancellationToken as oe}from"../../../base/common/cancellation.js";import"../../../base/common/collections.js";import{toErrorMessage as le}from"../../../base/common/errorMessage.js";import{CancellationError as U,getErrorMessage as A}from"../../../base/common/errors.js";import{Emitter as ce}from"../../../base/common/event.js";import{hash as de}from"../../../base/common/hash.js";import{Disposable as he}from"../../../base/common/lifecycle.js";import{ResourceMap as j,ResourceSet as fe}from"../../../base/common/map.js";import{Schemas as xe}from"../../../base/common/network.js";import*as g from"../../../base/common/path.js";import{joinPath as k}from"../../../base/common/resources.js";import*as ue from"../../../base/common/semver/semver.js";import{isBoolean as N}from"../../../base/common/types.js";import{URI as E}from"../../../base/common/uri.js";import{generateUuid as T}from"../../../base/common/uuid.js";import*as K from"../../../base/node/pfs.js";import{extract as me,zip as Se}from"../../../base/node/zip.js";import*as f from"../../../nls.js";import{IDownloadService as pe}from"../../download/common/download.js";import{INativeEnvironmentService as Ee}from"../../environment/common/environment.js";import{AbstractExtensionManagementService as ve,AbstractExtensionTask as W,toExtensionManagementError as h}from"../common/abstractExtensionManagementService.js";import{ExtensionManagementError as v,ExtensionManagementErrorCode as d,IExtensionGalleryService as X,IExtensionManagementService as ge,InstallOperation as V,EXTENSION_INSTALL_CLIENT_TARGET_PLATFORM_CONTEXT as Ie,ExtensionSignatureVerificationCode as u}from"../common/extensionManagement.js";import{areSameExtensions as P,computeTargetPlatform as ye,ExtensionKey as m,getGalleryExtensionId as _,groupByExtension as we}from"../common/extensionManagementUtil.js";import{IExtensionsProfileScannerService as O}from"../common/extensionsProfileScannerService.js";import{IExtensionsScannerService as G}from"../common/extensionsScannerService.js";import{ExtensionsDownloader as Pe}from"./extensionDownloader.js";import{ExtensionsLifecycle as Ue}from"./extensionLifecycle.js";import{fromExtractError as Re,getManifest as B}from"./extensionManagementUtil.js";import{ExtensionsManifestCache as Le}from"./extensionsManifestCache.js";import{ExtensionsWatcher as Me}from"./extensionsWatcher.js";import{ExtensionType as x}from"../../extensions/common/extensions.js";import{isEngineValid as De}from"../../extensions/common/extensionValidator.js";import{FileChangeType as Te,FileOperationResult as $,IFileService as Q,toFileOperationResult as R}from"../../files/common/files.js";import{IInstantiationService as Ve,refineServiceDecorator as be}from"../../instantiation/common/instantiation.js";import{ILogService as z}from"../../log/common/log.js";import{IProductService as Ce}from"../../product/common/productService.js";import{ITelemetryService as J}from"../../telemetry/common/telemetry.js";import{IUriIdentityService as q}from"../../uriIdentity/common/uriIdentity.js";import{IUserDataProfilesService as H}from"../../userDataProfile/common/userDataProfile.js";import{IConfigurationService as Fe}from"../../configuration/common/configuration.js";import{isLinux as Ae}from"../../../base/common/platform.js";const zi=be(ge),Y=".vsctmp";let b=class extends ve{constructor(e,i,t,n,s,r,a,o,l,I,y,w,C){super(e,i,w,t,y,C);this.environmentService=n;this.extensionsScannerService=s;this.extensionsProfileScannerService=r;this.downloadService=a;this.instantiationService=o;this.fileService=l;this.configurationService=I;const Z=this._register(o.createInstance(Ue));this.extensionsScanner=this._register(o.createInstance(L,F=>Z.postUninstall(F))),this.manifestCache=this._register(new Le(C,l,w,this,this.logService)),this.extensionsDownloader=this._register(o.createInstance(Pe));const ee=this._register(new Me(this,this.extensionsScannerService,C,r,w,l,t));this._register(ee.onDidChangeExtensionsByAnotherSource(F=>this.onDidChangeExtensionsFromAnotherSource(F))),this.watchForExtensionsNotInstalledBySystem()}extensionsScanner;manifestCache;extensionsDownloader;extractingGalleryExtensions=new Map;_targetPlatformPromise;getTargetPlatform(){return this._targetPlatformPromise||(this._targetPlatformPromise=ye(this.fileService,this.logService)),this._targetPlatformPromise}async zip(e){this.logService.trace("ExtensionManagementService#zip",e.identifier.id);const i=await this.collectFiles(e),t=await Se(k(this.extensionsDownloader.extensionsDownloadDir,T()).fsPath,i);return E.file(t)}async getManifest(e){const{location:i,cleanup:t}=await this.downloadVsix(e),n=g.resolve(i.fsPath);try{return await B(n)}finally{await t()}}getInstalled(e,i=this.userDataProfilesService.defaultProfile.extensionsResource,t={version:this.productService.version,date:this.productService.date}){return this.extensionsScanner.scanExtensions(e??null,i,t)}scanAllUserInstalledExtensions(){return this.extensionsScanner.scanAllUserExtensions(!1)}scanInstalledExtensionAtLocation(e){return this.extensionsScanner.scanUserExtensionAtLocation(e)}async install(e,i={}){this.logService.trace("ExtensionManagementService#install",e.toString());const{location:t,cleanup:n}=await this.downloadVsix(e);try{const s=await B(g.resolve(t.fsPath)),r=_(s.publisher,s.name);if(s.engines&&s.engines.vscode&&!De(s.engines.vscode,this.productService.version,this.productService.date))throw new Error(f.localize("incompatible","Unable to install extension '{0}' as it is not compatible with VS Code '{1}'.",r,this.productService.version));const o=(await this.installExtensions([{manifest:s,extension:t,options:i}])).find(({identifier:l})=>P(l,{id:r}));if(o?.local)return o.local;throw o?.error?o.error:h(new Error(`Unknown error while installing extension ${r}`))}finally{await n()}}async installFromLocation(e,i){this.logService.trace("ExtensionManagementService#installFromLocation",e.toString());const t=await this.extensionsScanner.scanUserExtensionAtLocation(e);if(!t||!t.manifest.name||!t.manifest.version)throw new Error(`Cannot find a valid extension from the location ${e.toString()}`);return await this.addExtensionsToProfile([[t,{source:"resource"}]],i),this.logService.info("Successfully installed extension",t.identifier.id,i.toString()),t}async installExtensionsFromProfile(e,i,t){this.logService.trace("ExtensionManagementService#installExtensionsFromProfile",e,i.toString(),t.toString());const n=(await this.getInstalled(x.User,i)).filter(s=>e.some(r=>P(r,s.identifier)));if(n.length){const s=await Promise.all(n.map(r=>this.extensionsScanner.scanMetadata(r,i)));await this.addExtensionsToProfile(n.map((r,a)=>[r,s[a]]),t),this.logService.info("Successfully installed extensions",n.map(r=>r.identifier.id),t.toString())}return n}async updateMetadata(e,i,t){return this.logService.trace("ExtensionManagementService#updateMetadata",e.identifier.id),i.isPreReleaseVersion&&(i.preRelease=!0,i.hasPreReleaseVersion=!0),i.isMachineScoped===!1&&(i.isMachineScoped=void 0),i.isBuiltin===!1&&(i.isBuiltin=void 0),i.pinned===!1&&(i.pinned=void 0),e=await this.extensionsScanner.updateMetadata(e,i,t),this.manifestCache.invalidate(t),this._onDidUpdateExtensionMetadata.fire({local:e,profileLocation:t}),e}async reinstallFromGallery(e){if(this.logService.trace("ExtensionManagementService#reinstallFromGallery",e.identifier.id),!this.galleryService.isEnabled())throw new Error(f.localize("MarketPlaceDisabled","Marketplace is not enabled"));const i=await this.getTargetPlatform(),[t]=await this.galleryService.getExtensions([{...e.identifier,preRelease:e.preRelease}],{targetPlatform:i,compatible:!0},oe.None);if(!t)throw new Error(f.localize("Not a Marketplace extension","Only Marketplace Extensions can be reinstalled"));await this.extensionsScanner.setUninstalled(e);try{await this.extensionsScanner.removeUninstalledExtension(e)}catch(n){throw new Error(f.localize("removeError","Error while removing the extension: {0}. Please Quit and Start VS Code before trying again.",le(n)))}return this.installFromGallery(t)}copyExtension(e,i,t,n){return this.extensionsScanner.copyExtension(e,i,t,n)}copyExtensions(e,i){return this.extensionsScanner.copyExtensions(e,i,{version:this.productService.version,date:this.productService.date})}markAsUninstalled(...e){return this.extensionsScanner.setUninstalled(...e)}async cleanUp(){this.logService.trace("ExtensionManagementService#cleanUp");try{await this.extensionsScanner.cleanUp()}catch(e){this.logService.error(e)}}async download(e,i,t){const{location:n}=await this.downloadExtension(e,i,!t);return n}async downloadVsix(e){if(e.scheme===xe.file)return{location:e,async cleanup(){}};this.logService.trace("Downloading extension from",e.toString());const i=k(this.extensionsDownloader.extensionsDownloadDir,T());return await this.downloadService.download(e,i),this.logService.info("Downloaded extension to",i.toString()),{location:i,cleanup:async()=>{try{await this.fileService.del(i)}catch(n){this.logService.error(n)}}}}getCurrentExtensionsManifestLocation(){return this.userDataProfilesService.defaultProfile.extensionsResource}createInstallExtensionTask(e,i,t){const n=i instanceof E?new m({id:_(e.publisher,e.name)},e.version):m.create(i);return this.instantiationService.createInstance(M,n,e,i,t,(s,r)=>{if(i instanceof E)return this.extractVSIX(n,i,t,r);let a=this.extractingGalleryExtensions.get(n.toString());return a||(this.extractingGalleryExtensions.set(n.toString(),a=this.downloadAndExtractGalleryExtension(n,i,s,t,r)),a.finally(()=>this.extractingGalleryExtensions.delete(n.toString()))),a},this.extensionsScanner)}createUninstallExtensionTask(e,i){return new ke(e,i,this.extensionsProfileScannerService)}async downloadAndExtractGalleryExtension(e,i,t,n,s){const{verificationStatus:r,location:a}=await this.downloadExtension(i,t,!n.donotVerifySignature,n.context?.[Ie]);try{if(s.isCancellationRequested)throw new U;const o=await B(a.fsPath);if(!new m(i.identifier,i.version).equals(new m({id:_(o.publisher,o.name)},o.version)))throw new v(f.localize("invalidManifest","Cannot install '{0}' extension because of manifest mismatch with Marketplace",i.identifier.id),d.Invalid);return{local:await this.extensionsScanner.extractUserExtension(e,a.fsPath,{id:i.identifier.uuid,publisherId:i.publisherId,publisherDisplayName:i.publisherDisplayName,targetPlatform:i.properties.targetPlatform,isApplicationScoped:n.isApplicationScoped,isMachineScoped:n.isMachineScoped,isBuiltin:n.isBuiltin,isPreReleaseVersion:i.properties.isPreReleaseVersion,hasPreReleaseVersion:i.properties.isPreReleaseVersion,installedTimestamp:Date.now(),pinned:n.installGivenVersion?!0:!!n.pinned,preRelease:N(n.preRelease)?n.preRelease:n.installPreReleaseVersion||i.properties.isPreReleaseVersion,source:"gallery"},!1,s),verificationStatus:r}}catch(o){try{await this.extensionsDownloader.delete(a)}catch(l){this.logService.warn("Error while deleting the downloaded file",a.toString(),A(l))}throw h(o)}}async downloadExtension(e,i,t,n){if(t){const a=this.configurationService.getValue("extensions.verifySignature");t=N(a)?a:!0}const{location:s,verificationStatus:r}=await this.extensionsDownloader.download(e,i,t,n);if(r!==u.Success&&t&&this.environmentService.isBuilt&&!Ae){if(!e.isSigned)throw new v(f.localize("not signed","Extension is not signed."),d.PackageNotSigned);if(!r)throw new v(f.localize("signature verification not executed","Signature verification was not executed."),d.SignatureVerificationInternal);switch(r){case u.PackageIntegrityCheckFailed:case u.SignatureIsInvalid:case u.SignatureManifestIsInvalid:case u.SignatureIntegrityCheckFailed:case u.EntryIsMissing:case u.EntryIsTampered:case u.Untrusted:case u.CertificateRevoked:case u.SignatureIsNotValid:case u.SignatureArchiveHasTooManyEntries:throw new v(f.localize("signature verification failed","Signature verification failed with '{0}' error.",r),d.SignatureVerificationFailed)}throw new v(f.localize("signature verification failed","Signature verification failed with '{0}' error.",r),d.SignatureVerificationInternal)}return{location:s,verificationStatus:r}}async extractVSIX(e,i,t,n){return{local:await this.extensionsScanner.extractUserExtension(e,g.resolve(i.fsPath),{isApplicationScoped:t.isApplicationScoped,isMachineScoped:t.isMachineScoped,isBuiltin:t.isBuiltin,installedTimestamp:Date.now(),pinned:t.installGivenVersion?!0:!!t.pinned,source:"vsix"},t.keepExisting??!0,n)}}async collectFiles(e){const i=async n=>{let s=await K.Promises.readdir(n);s=s.map(o=>g.join(n,o));const r=await Promise.all(s.map(o=>ne.promises.stat(o)));let a=Promise.resolve([]);return r.forEach((o,l)=>{const I=s[l];o.isFile()&&(a=a.then(y=>[...y,I])),o.isDirectory()&&(a=a.then(y=>i(I).then(w=>[...y,...w])))}),a};return(await i(e.location.fsPath)).map(n=>({path:`extension/${g.relative(e.location.fsPath,n)}`,localPath:n}))}async onDidChangeExtensionsFromAnotherSource({added:e,removed:i}){if(i){const t=e&&this.uriIdentityService.extUri.isEqual(i.profileLocation,e.profileLocation)?i.extensions.filter(n=>e.extensions.every(s=>!P(s,n))):i.extensions;for(const n of t)this.logService.info("Extensions removed from another source",n.id,i.profileLocation.toString()),this._onDidUninstallExtension.fire({identifier:n,profileLocation:i.profileLocation})}if(e){const n=(await this.getInstalled(x.User,e.profileLocation)).filter(s=>e.extensions.some(r=>P(r,s.identifier)));this._onDidInstallExtensions.fire(n.map(s=>(this.logService.info("Extensions added from another source",s.identifier.id,e.profileLocation.toString()),{identifier:s.identifier,local:s,profileLocation:e.profileLocation,operation:V.None})))}}knownDirectories=new fe;async watchForExtensionsNotInstalledBySystem(){this._register(this.extensionsScanner.onExtract(i=>this.knownDirectories.add(i)));const e=await this.fileService.resolve(this.extensionsScannerService.userExtensionsLocation);for(const i of e.children??[])i.isDirectory&&this.knownDirectories.add(i.resource);this._register(this.fileService.watch(this.extensionsScannerService.userExtensionsLocation)),this._register(this.fileService.onDidFilesChange(i=>this.onDidFilesChange(i)))}async onDidFilesChange(e){if(!e.affects(this.extensionsScannerService.userExtensionsLocation,Te.ADDED))return;const i=[];for(const t of e.rawAdded){if(this.knownDirectories.has(t)||!this.uriIdentityService.extUri.isEqual(this.uriIdentityService.extUri.dirname(t),this.extensionsScannerService.userExtensionsLocation)||this.uriIdentityService.extUri.isEqual(t,this.uriIdentityService.extUri.joinPath(this.extensionsScannerService.userExtensionsLocation,".obsolete"))||this.uriIdentityService.extUri.basename(t).startsWith(".")||!(await this.fileService.stat(t)).isDirectory)continue;const n=await this.extensionsScanner.scanUserExtensionAtLocation(t);n&&n.installedTimestamp===void 0&&(this.knownDirectories.add(t),i.push(n))}i.length&&(await this.addExtensionsToProfile(i.map(t=>[t,void 0]),this.userDataProfilesService.defaultProfile.extensionsResource),this.logService.info("Added extensions to default profile from external source",i.map(t=>t.identifier.id)))}async addExtensionsToProfile(e,i){const t=e.map(n=>n[0]);await this.setInstalled(t),await this.extensionsProfileScannerService.addExtensionsToProfile(e,i),this._onDidInstallExtensions.fire(t.map(n=>({local:n,identifier:n.identifier,operation:V.None,profileLocation:i})))}async setInstalled(e){const i=await this.extensionsScanner.getUninstalledExtensions();for(const t of e){const n=m.create(t);i[n.toString()]&&(this.logService.trace("Removing the extension from uninstalled list:",n.id),await this.extensionsScanner.setInstalled(n),this.logService.info("Removed the extension from uninstalled list:",n.id))}}};b=D([c(0,X),c(1,J),c(2,z),c(3,Ee),c(4,G),c(5,O),c(6,pe),c(7,Ve),c(8,Q),c(9,Fe),c(10,Ce),c(11,q),c(12,H)],b);let L=class extends he{constructor(e,i,t,n,s,r,a){super();this.beforeRemovingExtension=e;this.fileService=i;this.extensionsScannerService=t;this.extensionsProfileScannerService=n;this.uriIdentityService=s;this.telemetryService=r;this.logService=a;this.uninstalledResource=k(this.extensionsScannerService.userExtensionsLocation,".obsolete"),this.uninstalledFileLimiter=new re}uninstalledResource;uninstalledFileLimiter;_onExtract=this._register(new ce);onExtract=this._onExtract.event;scanAllExtensionPromise=new j;scanUserExtensionsPromise=new j;async cleanUp(){await this.removeTemporarilyDeletedFolders(),await this.removeUninstalledExtensions()}async scanExtensions(e,i,t){try{const n={includeInvalid:!0,profileLocation:i,productVersion:t};let s=[];if(e===null||e===x.System){let r=this.scanAllExtensionPromise.get(i);r||(r=this.extensionsScannerService.scanAllExtensions({includeInvalid:!0,useCache:!0},n,!1).finally(()=>this.scanAllExtensionPromise.delete(i)),this.scanAllExtensionPromise.set(i,r)),s.push(...await r)}else if(e===x.User){let r=this.scanUserExtensionsPromise.get(i);r||(r=this.extensionsScannerService.scanUserExtensions(n).finally(()=>this.scanUserExtensionsPromise.delete(i)),this.scanUserExtensionsPromise.set(i,r)),s.push(...await r)}return s=e!==null?s.filter(r=>r.type===e):s,await Promise.all(s.map(r=>this.toLocalExtension(r)))}catch(n){throw h(n,d.Scanning)}}async scanAllUserExtensions(e){try{const i=await this.extensionsScannerService.scanUserExtensions({includeAllVersions:!e,includeInvalid:!0});return await Promise.all(i.map(t=>this.toLocalExtension(t)))}catch(i){throw h(i,d.Scanning)}}async scanUserExtensionAtLocation(e){try{const i=await this.extensionsScannerService.scanExistingExtension(e,x.User,{includeInvalid:!0});if(i)return await this.toLocalExtension(i)}catch(i){this.logService.error(i)}return null}async extractUserExtension(e,i,t,n,s){const r=e.toString(),a=E.file(g.join(this.extensionsScannerService.userExtensionsLocation.fsPath,`.${T()}`)),o=E.file(g.join(this.extensionsScannerService.userExtensionsLocation.fsPath,r));if(await this.fileService.exists(o)){if(!n)try{return await this.scanLocalExtension(o,x.User)}catch(l){this.logService.warn(`Error while scanning the existing extension at ${o.path}. Deleting the existing extension and extracting it.`,A(l))}try{await this.deleteExtensionFromLocation(e.id,o,"removeExisting")}catch{throw new v(f.localize("errorDeleting","Unable to delete the existing folder '{0}' while installing the extension '{1}'. Please delete the folder manually and try again",o.fsPath,e.id),d.Delete)}}try{if(s.isCancellationRequested)throw new U;try{this.logService.trace(`Started extracting the extension from ${i} to ${o.fsPath}`),await me(i,a.fsPath,{sourcePath:"extension",overwrite:!0},s),this.logService.info(`Extracted extension to ${o}:`,e.id)}catch(l){throw Re(l)}try{await this.extensionsScannerService.updateMetadata(a,t)}catch(l){throw this.telemetryService.publicLog2("extension:extract",{extensionId:e.id,code:`${R(l)}`}),h(l,d.UpdateMetadata)}if(s.isCancellationRequested)throw new U;try{this.logService.trace(`Started renaming the extension from ${a.fsPath} to ${o.fsPath}`),await this.rename(a.fsPath,o.fsPath),this.logService.info("Renamed to",o.fsPath)}catch(l){if(l.code==="ENOTEMPTY"){this.logService.info("Rename failed because extension was installed by another source. So ignoring renaming.",e.id);try{await this.fileService.del(a,{recursive:!0})}catch{}}else throw this.logService.info(`Rename failed because of ${A(l)}. Deleted from extracted location`,a),l}this._onExtract.fire(o)}catch(l){try{await this.fileService.del(a,{recursive:!0})}catch{}throw l}return this.scanLocalExtension(o,x.User)}async scanMetadata(e,i){return i?(await this.getScannedExtension(e,i))?.metadata:this.extensionsScannerService.scanMetadata(e.location)}async getScannedExtension(e,i){return(await this.extensionsProfileScannerService.scanProfileExtensions(i)).find(n=>P(n.identifier,e.identifier))}async updateMetadata(e,i,t){try{t?await this.extensionsProfileScannerService.updateMetadata([[e,i]],t):await this.extensionsScannerService.updateMetadata(e.location,i)}catch(n){throw this.telemetryService.publicLog2("extension:extract",{extensionId:e.identifier.id,code:`${R(n)}`,isProfile:!!t}),h(n,d.UpdateMetadata)}return this.scanLocalExtension(e.location,e.type,t)}async getUninstalledExtensions(){try{return await this.withUninstalledExtensions()}catch(e){throw h(e,d.ReadUninstalled)}}async setUninstalled(...e){const i=e.map(t=>m.create(t));await this.withUninstalledExtensions(t=>i.forEach(n=>{t[n.toString()]=!0,this.logService.info("Marked extension as uninstalled",n.toString())}))}async setInstalled(e){try{await this.withUninstalledExtensions(i=>delete i[e.toString()])}catch(i){throw h(i,d.UnsetUninstalled)}}async removeExtension(e,i){if(this.uriIdentityService.extUri.isEqualOrParent(e.location,this.extensionsScannerService.userExtensionsLocation))return this.deleteExtensionFromLocation(e.identifier.id,e.location,i)}async removeUninstalledExtension(e){await this.removeExtension(e,"uninstalled"),await this.withUninstalledExtensions(i=>delete i[m.create(e).toString()])}async copyExtension(e,i,t,n){const s=await this.getScannedExtension(e,i),r=await this.getScannedExtension(e,t);if(n={...s?.metadata,...n},r)if(this.uriIdentityService.extUri.isEqual(r.location,e.location))await this.extensionsProfileScannerService.updateMetadata([[e,{...r.metadata,...n}]],t);else{const a=await this.scanLocalExtension(r.location,e.type,t);await this.extensionsProfileScannerService.removeExtensionFromProfile(a,t),await this.extensionsProfileScannerService.addExtensionsToProfile([[e,{...r.metadata,...n}]],t)}else await this.extensionsProfileScannerService.addExtensionsToProfile([[e,n]],t);return this.scanLocalExtension(e.location,e.type,t)}async copyExtensions(e,i,t){const n=await this.scanExtensions(x.User,e,t),s=await Promise.all(n.filter(r=>!r.isApplicationScoped).map(async r=>[r,await this.scanMetadata(r,e)]));await this.extensionsProfileScannerService.addExtensionsToProfile(s,i)}async deleteExtensionFromLocation(e,i,t){this.logService.trace(`Deleting ${t} extension from disk`,e,i.fsPath);const n=this.uriIdentityService.extUri.joinPath(this.uriIdentityService.extUri.dirname(i),`${this.uriIdentityService.extUri.basename(i)}.${de(T()).toString(16)}${Y}`);await this.rename(i.fsPath,n.fsPath),await this.fileService.del(n,{recursive:!0}),this.logService.info(`Deleted ${t} extension from disk`,e,i.fsPath)}withUninstalledExtensions(e){return this.uninstalledFileLimiter.queue(async()=>{let i;try{i=(await this.fileService.readFile(this.uninstalledResource,"utf8")).value.toString()}catch(n){if(R(n)!==$.FILE_NOT_FOUND)throw n}let t={};if(i)try{t=JSON.parse(i)}catch{}return e&&(e(t),Object.keys(t).length?await this.fileService.writeFile(this.uninstalledResource,ae.fromString(JSON.stringify(t))):await this.fileService.del(this.uninstalledResource)),t})}async rename(e,i){try{await K.Promises.rename(e,i,2*60*1e3)}catch(t){throw h(t,d.Rename)}}async scanLocalExtension(e,i,t){try{if(t){const s=(await this.extensionsScannerService.scanUserExtensions({profileLocation:t})).find(r=>this.uriIdentityService.extUri.isEqual(r.location,e));if(s)return await this.toLocalExtension(s)}else{const n=await this.extensionsScannerService.scanExistingExtension(e,i,{includeInvalid:!0});if(n)return await this.toLocalExtension(n)}throw new v(f.localize("cannot read","Cannot read the extension from {0}",e.path),d.ScanningExtension)}catch(n){throw h(n,d.ScanningExtension)}}async toLocalExtension(e){const i=await this.fileService.resolve(e.location);let t,n;return i.children&&(t=i.children.find(({name:s})=>/^readme(\.txt|\.md|)$/i.test(s))?.resource,n=i.children.find(({name:s})=>/^changelog(\.txt|\.md|)$/i.test(s))?.resource),{identifier:e.identifier,type:e.type,isBuiltin:e.isBuiltin||!!e.metadata?.isBuiltin,location:e.location,manifest:e.manifest,targetPlatform:e.targetPlatform,validations:e.validations,isValid:e.isValid,readmeUrl:t,changelogUrl:n,publisherDisplayName:e.metadata?.publisherDisplayName,publisherId:e.metadata?.publisherId||null,isApplicationScoped:!!e.metadata?.isApplicationScoped,isMachineScoped:!!e.metadata?.isMachineScoped,isPreReleaseVersion:!!e.metadata?.isPreReleaseVersion,hasPreReleaseVersion:!!e.metadata?.hasPreReleaseVersion,preRelease:!!e.metadata?.preRelease,installedTimestamp:e.metadata?.installedTimestamp,updated:!!e.metadata?.updated,pinned:!!e.metadata?.pinned,isWorkspaceScoped:!1,source:e.metadata?.source??(e.identifier.uuid?"gallery":"vsix")}}async removeUninstalledExtensions(){const e=await this.getUninstalledExtensions();if(Object.keys(e).length===0){this.logService.debug("No uninstalled extensions found.");return}this.logService.debug("Removing uninstalled extensions:",Object.keys(e));const i=await this.extensionsScannerService.scanUserExtensions({includeAllVersions:!0,includeUninstalled:!0,includeInvalid:!0}),t=new Set;for(const s of i)e[m.create(s).toString()]||t.add(s.identifier.id.toLowerCase());try{const s=we(i,r=>r.identifier);await se.settled(s.map(async r=>{const a=r.sort((o,l)=>ue.rcompare(o.manifest.version,l.manifest.version))[0];t.has(a.identifier.id.toLowerCase())||await this.beforeRemovingExtension(await this.toLocalExtension(a))}))}catch(s){this.logService.error(s)}const n=i.filter(s=>s.metadata&&e[m.create(s).toString()]);await Promise.allSettled(n.map(s=>this.removeUninstalledExtension(s)))}async removeTemporarilyDeletedFolders(){this.logService.trace("ExtensionManagementService#removeTempDeleteFolders");let e;try{e=await this.fileService.resolve(this.extensionsScannerService.userExtensionsLocation)}catch(i){R(i)!==$.FILE_NOT_FOUND&&this.logService.error(i);return}if(e?.children)try{await Promise.allSettled(e.children.map(async i=>{if(!(!i.isDirectory||!i.name.endsWith(Y))){this.logService.trace("Deleting the temporarily deleted folder",i.resource.toString());try{await this.fileService.del(i.resource,{recursive:!0}),this.logService.trace("Deleted the temporarily deleted folder",i.resource.toString())}catch(t){R(t)!==$.FILE_NOT_FOUND&&this.logService.error(t)}}}))}catch{}}};L=D([c(1,Q),c(2,G),c(3,O),c(4,q),c(5,J),c(6,z)],L);let M=class extends W{constructor(e,i,t,n,s,r,a,o,l,I,y,w){super();this.extensionKey=e;this.manifest=i;this.source=t;this.options=n;this.extractExtensionFn=s;this.extensionsScanner=r;this.uriIdentityService=a;this.galleryService=o;this.userDataProfilesService=l;this.extensionsScannerService=I;this.extensionsProfileScannerService=y;this.logService=w;this.identifier=this.extensionKey.identifier}_operation=V.Install;get operation(){return this.options.operation??this._operation}_verificationStatus;get verificationStatus(){return this._verificationStatus}identifier;async doRun(e){const t=(await this.extensionsScanner.scanExtensions(x.User,this.options.profileLocation,this.options.productVersion)).find(a=>P(a.identifier,this.identifier));t&&(this._operation=V.Update);const n={isApplicationScoped:this.options.isApplicationScoped||t?.isApplicationScoped,isMachineScoped:this.options.isMachineScoped||t?.isMachineScoped,isBuiltin:this.options.isBuiltin||t?.isBuiltin,isSystem:t?.type===x.System?!0:void 0,installedTimestamp:Date.now(),pinned:this.options.installGivenVersion?!0:this.options.pinned??t?.pinned,source:this.source instanceof E?"vsix":"gallery"};let s;if(this.source instanceof E){if(t&&this.extensionKey.equals(new m(t.identifier,t.manifest.version)))try{await this.extensionsScanner.removeExtension(t,"existing")}catch{throw new Error(f.localize("restartCode","Please restart VS Code before reinstalling {0}.",this.manifest.displayName||this.manifest.name))}const a=await this.unsetIfUninstalled(this.extensionKey);if(a)try{await this.extensionsScanner.removeExtension(a,"existing")}catch{throw new Error(f.localize("restartCode","Please restart VS Code before reinstalling {0}.",this.manifest.displayName||this.manifest.name))}}else{if(n.id=this.source.identifier.uuid,n.publisherId=this.source.publisherId,n.publisherDisplayName=this.source.publisherDisplayName,n.targetPlatform=this.source.properties.targetPlatform,n.updated=!!t,n.isPreReleaseVersion=this.source.properties.isPreReleaseVersion,n.hasPreReleaseVersion=t?.hasPreReleaseVersion||this.source.properties.isPreReleaseVersion,n.preRelease=N(this.options.preRelease)?this.options.preRelease:this.options.installPreReleaseVersion||this.source.properties.isPreReleaseVersion||t?.preRelease,t&&t.type!==x.System&&t.manifest.version===this.source.version)return this.extensionsScanner.updateMetadata(t,n,this.options.profileLocation);s=await this.unsetIfUninstalled(this.extensionKey)}if(e.isCancellationRequested)throw h(new U);if(!s){const a=await this.extractExtensionFn(this.operation,e);s=a.local,this._verificationStatus=a.verificationStatus}if(this.uriIdentityService.extUri.isEqual(this.userDataProfilesService.defaultProfile.extensionsResource,this.options.profileLocation))try{await this.extensionsScannerService.initializeDefaultProfileExtensions()}catch(a){throw h(a,d.IntializeDefaultProfile)}if(e.isCancellationRequested)throw h(new U);try{await this.extensionsProfileScannerService.addExtensionsToProfile([[s,n]],this.options.profileLocation,!s.isValid)}catch(a){throw h(a,d.AddToProfile)}const r=await this.extensionsScanner.scanLocalExtension(s.location,x.User,this.options.profileLocation);if(!r)throw new v("Cannot find the installed extension",d.InstalledExtensionNotFound);return this.source instanceof E&&this.updateMetadata(s,e),r}async unsetIfUninstalled(e){return(await this.extensionsScanner.getUninstalledExtensions())[e.toString()]?(this.logService.trace("Removing the extension from uninstalled list:",e.id),await this.extensionsScanner.setInstalled(e),this.logService.info("Removed the extension from uninstalled list:",e.id),(await this.extensionsScanner.scanAllUserExtensions(!0)).find(n=>m.create(n).equals(e))):void 0}async updateMetadata(e,i){try{let[t]=await this.galleryService.getExtensions([{id:e.identifier.id,version:e.manifest.version}],i);if(t||([t]=await this.galleryService.getExtensions([{id:e.identifier.id}],i)),t){const n={id:t.identifier.uuid,publisherDisplayName:t.publisherDisplayName,publisherId:t.publisherId,isPreReleaseVersion:t.properties.isPreReleaseVersion,hasPreReleaseVersion:e.hasPreReleaseVersion||t.properties.isPreReleaseVersion,preRelease:t.properties.isPreReleaseVersion||this.options.installPreReleaseVersion};await this.extensionsScanner.updateMetadata(e,n,this.options.profileLocation)}}catch{}}};M=D([c(6,q),c(7,X),c(8,H),c(9,G),c(10,O),c(11,z)],M);class ke extends W{constructor(e,i,t){super();this.extension=e;this.options=i;this.extensionsProfileScannerService=t}async doRun(e){await this.extensionsProfileScannerService.removeExtensionFromProfile(this.extension,this.options.profileLocation)}}export{b as ExtensionManagementService,L as ExtensionsScanner,zi as INativeServerExtensionManagementService};
