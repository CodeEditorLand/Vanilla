var ee=Object.defineProperty;var ie=Object.getOwnPropertyDescriptor;var D=(u,p,e,i)=>{for(var t=i>1?void 0:i?ie(p,e):p,n=u.length-1,s;n>=0;n--)(s=u[n])&&(t=(i?s(p,e,t):s(t))||t);return i&&t&&ee(p,e,t),t},c=(u,p)=>(e,i)=>p(e,i,u);import*as te from"fs";import{Promises as ne,Queue as se}from"../../../base/common/async.js";import{VSBuffer as re}from"../../../base/common/buffer.js";import{CancellationToken as oe}from"../../../base/common/cancellation.js";import{toErrorMessage as ae}from"../../../base/common/errorMessage.js";import{CancellationError as w,getErrorMessage as C}from"../../../base/common/errors.js";import{Emitter as le}from"../../../base/common/event.js";import{hash as ce}from"../../../base/common/hash.js";import{Disposable as de}from"../../../base/common/lifecycle.js";import{ResourceMap as z,ResourceSet as he}from"../../../base/common/map.js";import{Schemas as xe}from"../../../base/common/network.js";import*as E from"../../../base/common/path.js";import{isLinux as fe}from"../../../base/common/platform.js";import{joinPath as A}from"../../../base/common/resources.js";import*as pe from"../../../base/common/semver/semver.js";import{isBoolean as _}from"../../../base/common/types.js";import{URI as S}from"../../../base/common/uri.js";import{generateUuid as M}from"../../../base/common/uuid.js";import*as j from"../../../base/node/pfs.js";import{extract as me,zip as ue}from"../../../base/node/zip.js";import*as m from"../../../nls.js";import{IConfigurationService as Se}from"../../configuration/common/configuration.js";import{IDownloadService as Ee}from"../../download/common/download.js";import{INativeEnvironmentService as ve}from"../../environment/common/environment.js";import{isEngineValid as ye}from"../../extensions/common/extensionValidator.js";import{ExtensionType as x}from"../../extensions/common/extensions.js";import{FileChangeType as Ie,FileOperationResult as N,IFileService as K,toFileOperationResult as P}from"../../files/common/files.js";import{IInstantiationService as ge,refineServiceDecorator as we}from"../../instantiation/common/instantiation.js";import{ILogService as O}from"../../log/common/log.js";import{IProductService as Pe}from"../../product/common/productService.js";import{ITelemetryService as W}from"../../telemetry/common/telemetry.js";import{IUriIdentityService as k}from"../../uriIdentity/common/uriIdentity.js";import{IUserDataProfilesService as X}from"../../userDataProfile/common/userDataProfile.js";import{AbstractExtensionManagementService as Ue,AbstractExtensionTask as Q,toExtensionManagementError as h}from"../common/abstractExtensionManagementService.js";import{EXTENSION_INSTALL_CLIENT_TARGET_PLATFORM_CONTEXT as Re,ExtensionManagementError as U,ExtensionManagementErrorCode as d,IExtensionGalleryService as J,IExtensionManagementService as Le,InstallOperation as T}from"../common/extensionManagement.js";import{ExtensionKey as f,areSameExtensions as g,computeTargetPlatform as De,getGalleryExtensionId as G,groupByExtension as Me}from"../common/extensionManagementUtil.js";import{IExtensionsProfileScannerService as B}from"../common/extensionsProfileScannerService.js";import{IExtensionsScannerService as $}from"../common/extensionsScannerService.js";import{ExtensionsDownloader as Te}from"./extensionDownloader.js";import{ExtensionsLifecycle as be}from"./extensionLifecycle.js";import{fromExtractError as Ve,getManifest as q}from"./extensionManagementUtil.js";import{ExtensionsManifestCache as Fe}from"./extensionsManifestCache.js";import{ExtensionsWatcher as Ce}from"./extensionsWatcher.js";const Ii=we(Le),Y=".vsctmp";let b=class extends Ue{constructor(e,i,t,n,s,r,o,a,l,v,y,I,V){super(e,i,I,t,y,V);this.environmentService=n;this.extensionsScannerService=s;this.extensionsProfileScannerService=r;this.downloadService=o;this.instantiationService=a;this.fileService=l;this.configurationService=v;const H=this._register(a.createInstance(be));this.extensionsScanner=this._register(a.createInstance(R,F=>H.postUninstall(F))),this.manifestCache=this._register(new Fe(V,l,I,this,this.logService)),this.extensionsDownloader=this._register(a.createInstance(Te));const Z=this._register(new Ce(this,this.extensionsScannerService,V,r,I,l,t));this._register(Z.onDidChangeExtensionsByAnotherSource(F=>this.onDidChangeExtensionsFromAnotherSource(F))),this.watchForExtensionsNotInstalledBySystem()}extensionsScanner;manifestCache;extensionsDownloader;extractingGalleryExtensions=new Map;_targetPlatformPromise;getTargetPlatform(){return this._targetPlatformPromise||(this._targetPlatformPromise=De(this.fileService,this.logService)),this._targetPlatformPromise}async zip(e){this.logService.trace("ExtensionManagementService#zip",e.identifier.id);const i=await this.collectFiles(e),t=await ue(A(this.extensionsDownloader.extensionsDownloadDir,M()).fsPath,i);return S.file(t)}async getManifest(e){const{location:i,cleanup:t}=await this.downloadVsix(e),n=E.resolve(i.fsPath);try{return await q(n)}finally{await t()}}getInstalled(e,i=this.userDataProfilesService.defaultProfile.extensionsResource,t={version:this.productService.version,date:this.productService.date}){return this.extensionsScanner.scanExtensions(e??null,i,t)}scanAllUserInstalledExtensions(){return this.extensionsScanner.scanAllUserExtensions(!1)}scanInstalledExtensionAtLocation(e){return this.extensionsScanner.scanUserExtensionAtLocation(e)}async install(e,i={}){this.logService.trace("ExtensionManagementService#install",e.toString());const{location:t,cleanup:n}=await this.downloadVsix(e);try{const s=await q(E.resolve(t.fsPath)),r=G(s.publisher,s.name);if(s.engines&&s.engines.vscode&&!ye(s.engines.vscode,this.productService.version,this.productService.date))throw new Error(m.localize("incompatible","Unable to install extension '{0}' as it is not compatible with VS Code '{1}'.",r,this.productService.version));const a=(await this.installExtensions([{manifest:s,extension:t,options:i}])).find(({identifier:l})=>g(l,{id:r}));if(a?.local)return a.local;throw a?.error?a.error:h(new Error(`Unknown error while installing extension ${r}`))}finally{await n()}}async installFromLocation(e,i){this.logService.trace("ExtensionManagementService#installFromLocation",e.toString());const t=await this.extensionsScanner.scanUserExtensionAtLocation(e);if(!t||!t.manifest.name||!t.manifest.version)throw new Error(`Cannot find a valid extension from the location ${e.toString()}`);return await this.addExtensionsToProfile([[t,{source:"resource"}]],i),this.logService.info("Successfully installed extension",t.identifier.id,i.toString()),t}async installExtensionsFromProfile(e,i,t){this.logService.trace("ExtensionManagementService#installExtensionsFromProfile",e,i.toString(),t.toString());const n=(await this.getInstalled(x.User,i)).filter(s=>e.some(r=>g(r,s.identifier)));if(n.length){const s=await Promise.all(n.map(r=>this.extensionsScanner.scanMetadata(r,i)));await this.addExtensionsToProfile(n.map((r,o)=>[r,s[o]]),t),this.logService.info("Successfully installed extensions",n.map(r=>r.identifier.id),t.toString())}return n}async updateMetadata(e,i,t){return this.logService.trace("ExtensionManagementService#updateMetadata",e.identifier.id),i.isPreReleaseVersion&&(i.preRelease=!0,i.hasPreReleaseVersion=!0),i.isMachineScoped===!1&&(i.isMachineScoped=void 0),i.isBuiltin===!1&&(i.isBuiltin=void 0),i.pinned===!1&&(i.pinned=void 0),e=await this.extensionsScanner.updateMetadata(e,i,t),this.manifestCache.invalidate(t),this._onDidUpdateExtensionMetadata.fire({local:e,profileLocation:t}),e}async reinstallFromGallery(e){if(this.logService.trace("ExtensionManagementService#reinstallFromGallery",e.identifier.id),!this.galleryService.isEnabled())throw new Error(m.localize("MarketPlaceDisabled","Marketplace is not enabled"));const i=await this.getTargetPlatform(),[t]=await this.galleryService.getExtensions([{...e.identifier,preRelease:e.preRelease}],{targetPlatform:i,compatible:!0},oe.None);if(!t)throw new Error(m.localize("Not a Marketplace extension","Only Marketplace Extensions can be reinstalled"));await this.extensionsScanner.setUninstalled(e);try{await this.extensionsScanner.removeUninstalledExtension(e)}catch(n){throw new Error(m.localize("removeError","Error while removing the extension: {0}. Please Quit and Start VS Code before trying again.",ae(n)))}return this.installFromGallery(t)}copyExtension(e,i,t,n){return this.extensionsScanner.copyExtension(e,i,t,n)}copyExtensions(e,i){return this.extensionsScanner.copyExtensions(e,i,{version:this.productService.version,date:this.productService.date})}markAsUninstalled(...e){return this.extensionsScanner.setUninstalled(...e)}async cleanUp(){this.logService.trace("ExtensionManagementService#cleanUp");try{await this.extensionsScanner.cleanUp()}catch(e){this.logService.error(e)}}async download(e,i,t){const{location:n}=await this.downloadExtension(e,i,!t);return n}async downloadVsix(e){if(e.scheme===xe.file)return{location:e,async cleanup(){}};this.logService.trace("Downloading extension from",e.toString());const i=A(this.extensionsDownloader.extensionsDownloadDir,M());return await this.downloadService.download(e,i),this.logService.info("Downloaded extension to",i.toString()),{location:i,cleanup:async()=>{try{await this.fileService.del(i)}catch(n){this.logService.error(n)}}}}getCurrentExtensionsManifestLocation(){return this.userDataProfilesService.defaultProfile.extensionsResource}createInstallExtensionTask(e,i,t){const n=i instanceof S?new f({id:G(e.publisher,e.name)},e.version):f.create(i);return this.instantiationService.createInstance(L,n,e,i,t,(s,r)=>{if(i instanceof S)return this.extractVSIX(n,i,t,r);let o=this.extractingGalleryExtensions.get(n.toString());return o||(this.extractingGalleryExtensions.set(n.toString(),o=this.downloadAndExtractGalleryExtension(n,i,s,t,r)),o.finally(()=>this.extractingGalleryExtensions.delete(n.toString()))),o},this.extensionsScanner)}createUninstallExtensionTask(e,i){return new Ae(e,i,this.extensionsProfileScannerService)}async downloadAndExtractGalleryExtension(e,i,t,n,s){const{verificationStatus:r,location:o}=await this.downloadExtension(i,t,!n.donotVerifySignature,n.context?.[Re]);try{if(s.isCancellationRequested)throw new w;const a=await q(o.fsPath);if(!new f(i.identifier,i.version).equals(new f({id:G(a.publisher,a.name)},a.version)))throw new U(m.localize("invalidManifest","Cannot install '{0}' extension because of manifest mismatch with Marketplace",i.identifier.id),d.Invalid);return{local:await this.extensionsScanner.extractUserExtension(e,o.fsPath,{id:i.identifier.uuid,publisherId:i.publisherId,publisherDisplayName:i.publisherDisplayName,targetPlatform:i.properties.targetPlatform,isApplicationScoped:n.isApplicationScoped,isMachineScoped:n.isMachineScoped,isBuiltin:n.isBuiltin,isPreReleaseVersion:i.properties.isPreReleaseVersion,hasPreReleaseVersion:i.properties.isPreReleaseVersion,installedTimestamp:Date.now(),pinned:n.installGivenVersion?!0:!!n.pinned,preRelease:_(n.preRelease)?n.preRelease:n.installPreReleaseVersion||i.properties.isPreReleaseVersion,source:"gallery"},!1,s),verificationStatus:r}}catch(a){try{await this.extensionsDownloader.delete(o)}catch(l){this.logService.warn("Error while deleting the downloaded file",o.toString(),C(l))}throw h(a)}}async downloadExtension(e,i,t,n){if(t){const o=this.configurationService.getValue("extensions.verifySignature");t=_(o)?o:!0}const{location:s,verificationStatus:r}=await this.extensionsDownloader.download(e,i,t,n);if(r!==!0&&t&&this.environmentService.isBuilt&&!fe)throw new U(m.localize("download failed","Signature verification failed with '{0}' error.",r===!1?"NotExecuted":r),d.Signature);return{location:s,verificationStatus:r}}async extractVSIX(e,i,t,n){return{local:await this.extensionsScanner.extractUserExtension(e,E.resolve(i.fsPath),{isApplicationScoped:t.isApplicationScoped,isMachineScoped:t.isMachineScoped,isBuiltin:t.isBuiltin,installedTimestamp:Date.now(),pinned:t.installGivenVersion?!0:!!t.pinned,source:"vsix"},t.keepExisting??!0,n)}}async collectFiles(e){const i=async n=>{let s=await j.Promises.readdir(n);s=s.map(a=>E.join(n,a));const r=await Promise.all(s.map(a=>te.promises.stat(a)));let o=Promise.resolve([]);return r.forEach((a,l)=>{const v=s[l];a.isFile()&&(o=o.then(y=>[...y,v])),a.isDirectory()&&(o=o.then(y=>i(v).then(I=>[...y,...I])))}),o};return(await i(e.location.fsPath)).map(n=>({path:`extension/${E.relative(e.location.fsPath,n)}`,localPath:n}))}async onDidChangeExtensionsFromAnotherSource({added:e,removed:i}){if(i){const t=e&&this.uriIdentityService.extUri.isEqual(i.profileLocation,e.profileLocation)?i.extensions.filter(n=>e.extensions.every(s=>!g(s,n))):i.extensions;for(const n of t)this.logService.info("Extensions removed from another source",n.id,i.profileLocation.toString()),this._onDidUninstallExtension.fire({identifier:n,profileLocation:i.profileLocation})}if(e){const n=(await this.getInstalled(x.User,e.profileLocation)).filter(s=>e.extensions.some(r=>g(r,s.identifier)));this._onDidInstallExtensions.fire(n.map(s=>(this.logService.info("Extensions added from another source",s.identifier.id,e.profileLocation.toString()),{identifier:s.identifier,local:s,profileLocation:e.profileLocation,operation:T.None})))}}knownDirectories=new he;async watchForExtensionsNotInstalledBySystem(){this._register(this.extensionsScanner.onExtract(i=>this.knownDirectories.add(i)));const e=await this.fileService.resolve(this.extensionsScannerService.userExtensionsLocation);for(const i of e.children??[])i.isDirectory&&this.knownDirectories.add(i.resource);this._register(this.fileService.watch(this.extensionsScannerService.userExtensionsLocation)),this._register(this.fileService.onDidFilesChange(i=>this.onDidFilesChange(i)))}async onDidFilesChange(e){if(!e.affects(this.extensionsScannerService.userExtensionsLocation,Ie.ADDED))return;const i=[];for(const t of e.rawAdded){if(this.knownDirectories.has(t)||!this.uriIdentityService.extUri.isEqual(this.uriIdentityService.extUri.dirname(t),this.extensionsScannerService.userExtensionsLocation)||this.uriIdentityService.extUri.isEqual(t,this.uriIdentityService.extUri.joinPath(this.extensionsScannerService.userExtensionsLocation,".obsolete"))||this.uriIdentityService.extUri.basename(t).startsWith(".")||!(await this.fileService.stat(t)).isDirectory)continue;const n=await this.extensionsScanner.scanUserExtensionAtLocation(t);n&&n.installedTimestamp===void 0&&(this.knownDirectories.add(t),i.push(n))}i.length&&(await this.addExtensionsToProfile(i.map(t=>[t,void 0]),this.userDataProfilesService.defaultProfile.extensionsResource),this.logService.info("Added extensions to default profile from external source",i.map(t=>t.identifier.id)))}async addExtensionsToProfile(e,i){const t=e.map(n=>n[0]);await this.setInstalled(t),await this.extensionsProfileScannerService.addExtensionsToProfile(e,i),this._onDidInstallExtensions.fire(t.map(n=>({local:n,identifier:n.identifier,operation:T.None,profileLocation:i})))}async setInstalled(e){const i=await this.extensionsScanner.getUninstalledExtensions();for(const t of e){const n=f.create(t);i[n.toString()]&&(this.logService.trace("Removing the extension from uninstalled list:",n.id),await this.extensionsScanner.setInstalled(n),this.logService.info("Removed the extension from uninstalled list:",n.id))}}};b=D([c(0,J),c(1,W),c(2,O),c(3,ve),c(4,$),c(5,B),c(6,Ee),c(7,ge),c(8,K),c(9,Se),c(10,Pe),c(11,k),c(12,X)],b);let R=class extends de{constructor(e,i,t,n,s,r,o){super();this.beforeRemovingExtension=e;this.fileService=i;this.extensionsScannerService=t;this.extensionsProfileScannerService=n;this.uriIdentityService=s;this.telemetryService=r;this.logService=o;this.uninstalledResource=A(this.extensionsScannerService.userExtensionsLocation,".obsolete"),this.uninstalledFileLimiter=new se}uninstalledResource;uninstalledFileLimiter;_onExtract=this._register(new le);onExtract=this._onExtract.event;scanAllExtensionPromise=new z;scanUserExtensionsPromise=new z;async cleanUp(){await this.removeTemporarilyDeletedFolders(),await this.removeUninstalledExtensions()}async scanExtensions(e,i,t){try{const n={includeInvalid:!0,profileLocation:i,productVersion:t};let s=[];if(e===null||e===x.System){let r=this.scanAllExtensionPromise.get(i);r||(r=this.extensionsScannerService.scanAllExtensions({includeInvalid:!0,useCache:!0},n,!1).finally(()=>this.scanAllExtensionPromise.delete(i)),this.scanAllExtensionPromise.set(i,r)),s.push(...await r)}else if(e===x.User){let r=this.scanUserExtensionsPromise.get(i);r||(r=this.extensionsScannerService.scanUserExtensions(n).finally(()=>this.scanUserExtensionsPromise.delete(i)),this.scanUserExtensionsPromise.set(i,r)),s.push(...await r)}return s=e!==null?s.filter(r=>r.type===e):s,await Promise.all(s.map(r=>this.toLocalExtension(r)))}catch(n){throw h(n,d.Scanning)}}async scanAllUserExtensions(e){try{const i=await this.extensionsScannerService.scanUserExtensions({includeAllVersions:!e,includeInvalid:!0});return await Promise.all(i.map(t=>this.toLocalExtension(t)))}catch(i){throw h(i,d.Scanning)}}async scanUserExtensionAtLocation(e){try{const i=await this.extensionsScannerService.scanExistingExtension(e,x.User,{includeInvalid:!0});if(i)return await this.toLocalExtension(i)}catch(i){this.logService.error(i)}return null}async extractUserExtension(e,i,t,n,s){const r=e.toString(),o=S.file(E.join(this.extensionsScannerService.userExtensionsLocation.fsPath,`.${M()}`)),a=S.file(E.join(this.extensionsScannerService.userExtensionsLocation.fsPath,r));if(await this.fileService.exists(a)){if(!n)try{return await this.scanLocalExtension(a,x.User)}catch(l){this.logService.warn(`Error while scanning the existing extension at ${a.path}. Deleting the existing extension and extracting it.`,C(l))}try{await this.deleteExtensionFromLocation(e.id,a,"removeExisting")}catch{throw new U(m.localize("errorDeleting","Unable to delete the existing folder '{0}' while installing the extension '{1}'. Please delete the folder manually and try again",a.fsPath,e.id),d.Delete)}}try{if(s.isCancellationRequested)throw new w;try{this.logService.trace(`Started extracting the extension from ${i} to ${a.fsPath}`),await me(i,o.fsPath,{sourcePath:"extension",overwrite:!0},s),this.logService.info(`Extracted extension to ${a}:`,e.id)}catch(l){throw Ve(l)}try{await this.extensionsScannerService.updateMetadata(o,t)}catch(l){throw this.telemetryService.publicLog2("extension:extract",{extensionId:e.id,code:`${P(l)}`}),h(l,d.UpdateMetadata)}if(s.isCancellationRequested)throw new w;try{this.logService.trace(`Started renaming the extension from ${o.fsPath} to ${a.fsPath}`),await this.rename(o.fsPath,a.fsPath),this.logService.info("Renamed to",a.fsPath)}catch(l){if(l.code==="ENOTEMPTY"){this.logService.info("Rename failed because extension was installed by another source. So ignoring renaming.",e.id);try{await this.fileService.del(o,{recursive:!0})}catch{}}else throw this.logService.info(`Rename failed because of ${C(l)}. Deleted from extracted location`,o),l}this._onExtract.fire(a)}catch(l){try{await this.fileService.del(o,{recursive:!0})}catch{}throw l}return this.scanLocalExtension(a,x.User)}async scanMetadata(e,i){return i?(await this.getScannedExtension(e,i))?.metadata:this.extensionsScannerService.scanMetadata(e.location)}async getScannedExtension(e,i){return(await this.extensionsProfileScannerService.scanProfileExtensions(i)).find(n=>g(n.identifier,e.identifier))}async updateMetadata(e,i,t){try{t?await this.extensionsProfileScannerService.updateMetadata([[e,i]],t):await this.extensionsScannerService.updateMetadata(e.location,i)}catch(n){throw this.telemetryService.publicLog2("extension:extract",{extensionId:e.identifier.id,code:`${P(n)}`,isProfile:!!t}),h(n,d.UpdateMetadata)}return this.scanLocalExtension(e.location,e.type,t)}async getUninstalledExtensions(){try{return await this.withUninstalledExtensions()}catch(e){throw h(e,d.ReadUninstalled)}}async setUninstalled(...e){const i=e.map(t=>f.create(t));await this.withUninstalledExtensions(t=>i.forEach(n=>{t[n.toString()]=!0,this.logService.info("Marked extension as uninstalled",n.toString())}))}async setInstalled(e){try{await this.withUninstalledExtensions(i=>delete i[e.toString()])}catch(i){throw h(i,d.UnsetUninstalled)}}async removeExtension(e,i){if(this.uriIdentityService.extUri.isEqualOrParent(e.location,this.extensionsScannerService.userExtensionsLocation))return this.deleteExtensionFromLocation(e.identifier.id,e.location,i)}async removeUninstalledExtension(e){await this.removeExtension(e,"uninstalled"),await this.withUninstalledExtensions(i=>delete i[f.create(e).toString()])}async copyExtension(e,i,t,n){const s=await this.getScannedExtension(e,i),r=await this.getScannedExtension(e,t);if(n={...s?.metadata,...n},r)if(this.uriIdentityService.extUri.isEqual(r.location,e.location))await this.extensionsProfileScannerService.updateMetadata([[e,{...r.metadata,...n}]],t);else{const o=await this.scanLocalExtension(r.location,e.type,t);await this.extensionsProfileScannerService.removeExtensionFromProfile(o,t),await this.extensionsProfileScannerService.addExtensionsToProfile([[e,{...r.metadata,...n}]],t)}else await this.extensionsProfileScannerService.addExtensionsToProfile([[e,n]],t);return this.scanLocalExtension(e.location,e.type,t)}async copyExtensions(e,i,t){const n=await this.scanExtensions(x.User,e,t),s=await Promise.all(n.filter(r=>!r.isApplicationScoped).map(async r=>[r,await this.scanMetadata(r,e)]));await this.extensionsProfileScannerService.addExtensionsToProfile(s,i)}async deleteExtensionFromLocation(e,i,t){this.logService.trace(`Deleting ${t} extension from disk`,e,i.fsPath);const n=this.uriIdentityService.extUri.joinPath(this.uriIdentityService.extUri.dirname(i),`${this.uriIdentityService.extUri.basename(i)}.${ce(M()).toString(16)}${Y}`);await this.rename(i.fsPath,n.fsPath),await this.fileService.del(n,{recursive:!0}),this.logService.info(`Deleted ${t} extension from disk`,e,i.fsPath)}withUninstalledExtensions(e){return this.uninstalledFileLimiter.queue(async()=>{let i;try{i=(await this.fileService.readFile(this.uninstalledResource,"utf8")).value.toString()}catch(n){if(P(n)!==N.FILE_NOT_FOUND)throw n}let t={};if(i)try{t=JSON.parse(i)}catch{}return e&&(e(t),Object.keys(t).length?await this.fileService.writeFile(this.uninstalledResource,re.fromString(JSON.stringify(t))):await this.fileService.del(this.uninstalledResource)),t})}async rename(e,i){try{await j.Promises.rename(e,i,2*60*1e3)}catch(t){throw h(t,d.Rename)}}async scanLocalExtension(e,i,t){try{if(t){const s=(await this.extensionsScannerService.scanUserExtensions({profileLocation:t})).find(r=>this.uriIdentityService.extUri.isEqual(r.location,e));if(s)return await this.toLocalExtension(s)}else{const n=await this.extensionsScannerService.scanExistingExtension(e,i,{includeInvalid:!0});if(n)return await this.toLocalExtension(n)}throw new U(m.localize("cannot read","Cannot read the extension from {0}",e.path),d.ScanningExtension)}catch(n){throw h(n,d.ScanningExtension)}}async toLocalExtension(e){const i=await this.fileService.resolve(e.location);let t,n;return i.children&&(t=i.children.find(({name:s})=>/^readme(\.txt|\.md|)$/i.test(s))?.resource,n=i.children.find(({name:s})=>/^changelog(\.txt|\.md|)$/i.test(s))?.resource),{identifier:e.identifier,type:e.type,isBuiltin:e.isBuiltin||!!e.metadata?.isBuiltin,location:e.location,manifest:e.manifest,targetPlatform:e.targetPlatform,validations:e.validations,isValid:e.isValid,readmeUrl:t,changelogUrl:n,publisherDisplayName:e.metadata?.publisherDisplayName,publisherId:e.metadata?.publisherId||null,isApplicationScoped:!!e.metadata?.isApplicationScoped,isMachineScoped:!!e.metadata?.isMachineScoped,isPreReleaseVersion:!!e.metadata?.isPreReleaseVersion,hasPreReleaseVersion:!!e.metadata?.hasPreReleaseVersion,preRelease:!!e.metadata?.preRelease,installedTimestamp:e.metadata?.installedTimestamp,updated:!!e.metadata?.updated,pinned:!!e.metadata?.pinned,isWorkspaceScoped:!1,source:e.metadata?.source??(e.identifier.uuid?"gallery":"vsix")}}async removeUninstalledExtensions(){const e=await this.getUninstalledExtensions();if(Object.keys(e).length===0){this.logService.debug("No uninstalled extensions found.");return}this.logService.debug("Removing uninstalled extensions:",Object.keys(e));const i=await this.extensionsScannerService.scanUserExtensions({includeAllVersions:!0,includeUninstalled:!0,includeInvalid:!0}),t=new Set;for(const s of i)e[f.create(s).toString()]||t.add(s.identifier.id.toLowerCase());try{const s=Me(i,r=>r.identifier);await ne.settled(s.map(async r=>{const o=r.sort((a,l)=>pe.rcompare(a.manifest.version,l.manifest.version))[0];t.has(o.identifier.id.toLowerCase())||await this.beforeRemovingExtension(await this.toLocalExtension(o))}))}catch(s){this.logService.error(s)}const n=i.filter(s=>s.metadata&&e[f.create(s).toString()]);await Promise.allSettled(n.map(s=>this.removeUninstalledExtension(s)))}async removeTemporarilyDeletedFolders(){this.logService.trace("ExtensionManagementService#removeTempDeleteFolders");let e;try{e=await this.fileService.resolve(this.extensionsScannerService.userExtensionsLocation)}catch(i){P(i)!==N.FILE_NOT_FOUND&&this.logService.error(i);return}if(e?.children)try{await Promise.allSettled(e.children.map(async i=>{if(!(!i.isDirectory||!i.name.endsWith(Y))){this.logService.trace("Deleting the temporarily deleted folder",i.resource.toString());try{await this.fileService.del(i.resource,{recursive:!0}),this.logService.trace("Deleted the temporarily deleted folder",i.resource.toString())}catch(t){P(t)!==N.FILE_NOT_FOUND&&this.logService.error(t)}}}))}catch{}}};R=D([c(1,K),c(2,$),c(3,B),c(4,k),c(5,W),c(6,O)],R);let L=class extends Q{constructor(e,i,t,n,s,r,o,a,l,v,y,I){super();this.extensionKey=e;this.manifest=i;this.source=t;this.options=n;this.extractExtensionFn=s;this.extensionsScanner=r;this.uriIdentityService=o;this.galleryService=a;this.userDataProfilesService=l;this.extensionsScannerService=v;this.extensionsProfileScannerService=y;this.logService=I;this.identifier=this.extensionKey.identifier}_operation=T.Install;get operation(){return this.options.operation??this._operation}_verificationStatus;get verificationStatus(){return this._verificationStatus}identifier;async doRun(e){const t=(await this.extensionsScanner.scanExtensions(x.User,this.options.profileLocation,this.options.productVersion)).find(o=>g(o.identifier,this.identifier));t&&(this._operation=T.Update);const n={isApplicationScoped:this.options.isApplicationScoped||t?.isApplicationScoped,isMachineScoped:this.options.isMachineScoped||t?.isMachineScoped,isBuiltin:this.options.isBuiltin||t?.isBuiltin,isSystem:t?.type===x.System?!0:void 0,installedTimestamp:Date.now(),pinned:this.options.installGivenVersion?!0:this.options.pinned??t?.pinned,source:this.source instanceof S?"vsix":"gallery"};let s;if(this.source instanceof S){if(t&&this.extensionKey.equals(new f(t.identifier,t.manifest.version)))try{await this.extensionsScanner.removeExtension(t,"existing")}catch{throw new Error(m.localize("restartCode","Please restart VS Code before reinstalling {0}.",this.manifest.displayName||this.manifest.name))}const o=await this.unsetIfUninstalled(this.extensionKey);if(o)try{await this.extensionsScanner.removeExtension(o,"existing")}catch{throw new Error(m.localize("restartCode","Please restart VS Code before reinstalling {0}.",this.manifest.displayName||this.manifest.name))}}else{if(n.id=this.source.identifier.uuid,n.publisherId=this.source.publisherId,n.publisherDisplayName=this.source.publisherDisplayName,n.targetPlatform=this.source.properties.targetPlatform,n.updated=!!t,n.isPreReleaseVersion=this.source.properties.isPreReleaseVersion,n.hasPreReleaseVersion=t?.hasPreReleaseVersion||this.source.properties.isPreReleaseVersion,n.preRelease=_(this.options.preRelease)?this.options.preRelease:this.options.installPreReleaseVersion||this.source.properties.isPreReleaseVersion||t?.preRelease,t&&t.type!==x.System&&t.manifest.version===this.source.version)return this.extensionsScanner.updateMetadata(t,n,this.options.profileLocation);s=await this.unsetIfUninstalled(this.extensionKey)}if(e.isCancellationRequested)throw h(new w);if(!s){const o=await this.extractExtensionFn(this.operation,e);s=o.local,this._verificationStatus=o.verificationStatus}if(this.uriIdentityService.extUri.isEqual(this.userDataProfilesService.defaultProfile.extensionsResource,this.options.profileLocation))try{await this.extensionsScannerService.initializeDefaultProfileExtensions()}catch(o){throw h(o,d.IntializeDefaultProfile)}if(e.isCancellationRequested)throw h(new w);try{await this.extensionsProfileScannerService.addExtensionsToProfile([[s,n]],this.options.profileLocation,!s.isValid)}catch(o){throw h(o,d.AddToProfile)}const r=await this.extensionsScanner.scanLocalExtension(s.location,x.User,this.options.profileLocation);if(!r)throw new U("Cannot find the installed extension",d.InstalledExtensionNotFound);return this.source instanceof S&&this.updateMetadata(s,e),r}async unsetIfUninstalled(e){return(await this.extensionsScanner.getUninstalledExtensions())[e.toString()]?(this.logService.trace("Removing the extension from uninstalled list:",e.id),await this.extensionsScanner.setInstalled(e),this.logService.info("Removed the extension from uninstalled list:",e.id),(await this.extensionsScanner.scanAllUserExtensions(!0)).find(n=>f.create(n).equals(e))):void 0}async updateMetadata(e,i){try{let[t]=await this.galleryService.getExtensions([{id:e.identifier.id,version:e.manifest.version}],i);if(t||([t]=await this.galleryService.getExtensions([{id:e.identifier.id}],i)),t){const n={id:t.identifier.uuid,publisherDisplayName:t.publisherDisplayName,publisherId:t.publisherId,isPreReleaseVersion:t.properties.isPreReleaseVersion,hasPreReleaseVersion:e.hasPreReleaseVersion||t.properties.isPreReleaseVersion,preRelease:t.properties.isPreReleaseVersion||this.options.installPreReleaseVersion};await this.extensionsScanner.updateMetadata(e,n,this.options.profileLocation)}}catch{}}};L=D([c(6,k),c(7,J),c(8,X),c(9,$),c(10,B),c(11,O)],L);class Ae extends Q{constructor(e,i,t){super();this.extension=e;this.options=i;this.extensionsProfileScannerService=t}async doRun(e){await this.extensionsProfileScannerService.removeExtensionFromProfile(this.extension,this.options.profileLocation)}}export{b as ExtensionManagementService,R as ExtensionsScanner,Ii as INativeServerExtensionManagementService};
