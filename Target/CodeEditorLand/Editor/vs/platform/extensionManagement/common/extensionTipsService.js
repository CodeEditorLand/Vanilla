var R=Object.defineProperty;var C=Object.getOwnPropertyDescriptor;var B=(x,p,e,n)=>{for(var t=n>1?void 0:n?C(p,e):p,i=x.length-1,s;i>=0;i--)(s=x[i])&&(t=(n?s(p,e,t):s(t))||t);return n&&t&&R(p,e,t),t},v=(x,p)=>(e,n)=>p(e,n,x);import{isNonEmptyArray as k}from"../../../base/common/arrays.js";import{disposableTimeout as g}from"../../../base/common/async.js";import{Event as E}from"../../../base/common/event.js";import{Disposable as F,MutableDisposable as f}from"../../../base/common/lifecycle.js";import{join as P}from"../../../base/common/path.js";import{isWindows as L}from"../../../base/common/platform.js";import{env as I}from"../../../base/common/process.js";import{joinPath as A}from"../../../base/common/resources.js";import{URI as O}from"../../../base/common/uri.js";import{RecommendationSource as D,RecommendationsNotificationResult as d}from"../../extensionRecommendations/common/extensionRecommendations.js";import{ExtensionType as W}from"../../extensions/common/extensions.js";import{IFileService as j}from"../../files/common/files.js";import{IProductService as V}from"../../product/common/productService.js";import{StorageScope as b,StorageTarget as N}from"../../storage/common/storage.js";import{areSameExtensions as U}from"./extensionManagementUtil.js";let T=class extends F{constructor(e,n){super();this.fileService=e;this.productService=n;this.productService.configBasedExtensionTips&&Object.entries(this.productService.configBasedExtensionTips).forEach(([,t])=>this.allConfigBasedTips.set(t.configPath,t))}_serviceBrand;allConfigBasedTips=new Map;getConfigBasedTips(e){return this.getValidConfigBasedTips(e)}async getImportantExecutableBasedTips(){return[]}async getOtherExecutableBasedTips(){return[]}async getValidConfigBasedTips(e){const n=[];for(const[t,i]of this.allConfigBasedTips)if(!(i.configScheme&&i.configScheme!==e.scheme))try{const s=(await this.fileService.readFile(A(e,t))).value.toString();for(const[a,o]of Object.entries(i.recommendations))(!o.contentPattern||new RegExp(o.contentPattern,"mig").test(s))&&n.push({extensionId:a,extensionName:o.name,configName:i.configName,important:!!o.important,isExtensionPack:!!o.isExtensionPack,whenNotInstalled:o.whenNotInstalled})}catch{}return n}};T=B([v(0,j),v(1,V)],T);const S="extensionTips/promptedExecutableTips",M="extensionTips/lastPromptedMediumImpExeTime";class se extends T{constructor(e,n,t,i,s,a,o,r){super(o,r);this.userHome=e;this.windowEvents=n;this.telemetryService=t;this.extensionManagementService=i;this.storageService=s;this.extensionRecommendationNotificationService=a;r.exeBasedExtensionTips&&Object.entries(r.exeBasedExtensionTips).forEach(([m,c])=>{const h=[],u=[],w=[];Object.entries(c.recommendations).forEach(([y,l])=>{l.important?c.important?h.push({extensionId:y,extensionName:l.name,isExtensionPack:!!l.isExtensionPack}):u.push({extensionId:y,extensionName:l.name,isExtensionPack:!!l.isExtensionPack}):w.push({extensionId:y,extensionName:l.name,isExtensionPack:!!l.isExtensionPack})}),h.length&&this.highImportanceExecutableTips.set(m,{exeFriendlyName:c.friendlyName,windowsPath:c.windowsPath,recommendations:h}),u.length&&this.mediumImportanceExecutableTips.set(m,{exeFriendlyName:c.friendlyName,windowsPath:c.windowsPath,recommendations:u}),w.length&&this.allOtherExecutableTips.set(m,{exeFriendlyName:c.friendlyName,windowsPath:c.windowsPath,recommendations:w})}),g(async()=>{await this.collectTips(),this.promptHighImportanceExeBasedTip(),this.promptMediumImportanceExeBasedTip()},3e3,this._store)}highImportanceExecutableTips=new Map;mediumImportanceExecutableTips=new Map;allOtherExecutableTips=new Map;highImportanceTipsByExe=new Map;mediumImportanceTipsByExe=new Map;async getImportantExecutableBasedTips(){const e=await this.getValidExecutableBasedExtensionTips(this.highImportanceExecutableTips),n=await this.getValidExecutableBasedExtensionTips(this.mediumImportanceExecutableTips);return[...e,...n]}getOtherExecutableBasedTips(){return this.getValidExecutableBasedExtensionTips(this.allOtherExecutableTips)}async collectTips(){const e=await this.getValidExecutableBasedExtensionTips(this.highImportanceExecutableTips),n=await this.getValidExecutableBasedExtensionTips(this.mediumImportanceExecutableTips),t=await this.extensionManagementService.getInstalled();this.highImportanceTipsByExe=this.groupImportantTipsByExe(e,t),this.mediumImportanceTipsByExe=this.groupImportantTipsByExe(n,t)}groupImportantTipsByExe(e,n){const t=new Map;e.forEach(r=>t.set(r.extensionId.toLowerCase(),r));const{installed:i,uninstalled:s}=this.groupByInstalled([...t.keys()],n);for(const r of i){const m=t.get(r);m&&this.telemetryService.publicLog2("exeExtensionRecommendations:alreadyInstalled",{extensionId:r,exeName:m.exeName})}for(const r of s){const m=t.get(r);m&&this.telemetryService.publicLog2("exeExtensionRecommendations:notInstalled",{extensionId:r,exeName:m.exeName})}const a=this.getPromptedExecutableTips(),o=new Map;for(const r of s){const m=t.get(r);if(m&&(!a[m.exeName]||!a[m.exeName].includes(m.extensionId))){let c=o.get(m.exeName);c||(c=[],o.set(m.exeName,c)),c.push(m)}}return o}promptHighImportanceExeBasedTip(){if(this.highImportanceTipsByExe.size===0)return;const[e,n]=[...this.highImportanceTipsByExe.entries()][0];this.promptExeRecommendations(n).then(t=>{switch(t){case d.Accepted:this.addToRecommendedExecutables(n[0].exeName,n);break;case d.Ignored:this.highImportanceTipsByExe.delete(e);break;case d.IncompatibleWindow:{const i=E.once(E.latch(E.any(this.windowEvents.onDidOpenMainWindow,this.windowEvents.onDidFocusMainWindow)));this._register(i(()=>this.promptHighImportanceExeBasedTip()));break}case d.TooMany:{const i=this._register(new f);i.value=g(()=>{i.dispose(),this.promptHighImportanceExeBasedTip()},60*60*1e3);break}}})}promptMediumImportanceExeBasedTip(){if(this.mediumImportanceTipsByExe.size===0)return;const e=this.getLastPromptedMediumExeTime(),n=Date.now()-e,t=7*24*60*60*1e3;if(n<t){const a=this._register(new f);a.value=g(()=>{a.dispose(),this.promptMediumImportanceExeBasedTip()},t-n);return}const[i,s]=[...this.mediumImportanceTipsByExe.entries()][0];this.promptExeRecommendations(s).then(a=>{switch(a){case d.Accepted:{this.updateLastPromptedMediumExeTime(Date.now()),this.mediumImportanceTipsByExe.delete(i),this.addToRecommendedExecutables(s[0].exeName,s);const o=this._register(new f);o.value=g(()=>{o.dispose(),this.promptMediumImportanceExeBasedTip()},t);break}case d.Ignored:this.mediumImportanceTipsByExe.delete(i),this.promptMediumImportanceExeBasedTip();break;case d.IncompatibleWindow:{const o=E.once(E.latch(E.any(this.windowEvents.onDidOpenMainWindow,this.windowEvents.onDidFocusMainWindow)));this._register(o(()=>this.promptMediumImportanceExeBasedTip()));break}case d.TooMany:{const o=this._register(new f);o.value=g(()=>{o.dispose(),this.promptMediumImportanceExeBasedTip()},60*60*1e3);break}}})}async promptExeRecommendations(e){const n=await this.extensionManagementService.getInstalled(W.User),t=e.filter(i=>!i.whenNotInstalled||i.whenNotInstalled.every(s=>n.every(a=>!U(a.identifier,{id:s})))).map(({extensionId:i})=>i.toLowerCase());return this.extensionRecommendationNotificationService.promptImportantExtensionsInstallNotification({extensions:t,source:D.EXE,name:e[0].exeFriendlyName,searchValue:`@exe:"${e[0].exeName}"`})}getLastPromptedMediumExeTime(){let e=this.storageService.getNumber(M,b.APPLICATION);return e||(e=Date.now(),this.updateLastPromptedMediumExeTime(e)),e}updateLastPromptedMediumExeTime(e){this.storageService.store(M,e,b.APPLICATION,N.MACHINE)}getPromptedExecutableTips(){return JSON.parse(this.storageService.get(S,b.APPLICATION,"{}"))}addToRecommendedExecutables(e,n){const t=this.getPromptedExecutableTips();t[e]=n.map(({extensionId:i})=>i.toLowerCase()),this.storageService.store(S,JSON.stringify(t),b.APPLICATION,N.USER)}groupByInstalled(e,n){const t=[],i=[],s=n.reduce((a,o)=>(a.add(o.identifier.id.toLowerCase()),a),new Set);return e.forEach(a=>{s.has(a.toLowerCase())?t.push(a):i.push(a)}),{installed:t,uninstalled:i}}async getValidExecutableBasedExtensionTips(e){const n=[],t=new Map;for(const i of e.keys()){const s=e.get(i);if(!s||!k(s.recommendations))continue;const a=[];L?s.windowsPath&&a.push(s.windowsPath.replace("%USERPROFILE%",()=>I.USERPROFILE).replace("%ProgramFiles(x86)%",()=>I["ProgramFiles(x86)"]).replace("%ProgramFiles%",()=>I.ProgramFiles).replace("%APPDATA%",()=>I.APPDATA).replace("%WINDIR%",()=>I.WINDIR)):(a.push(P("/usr/local/bin",i)),a.push(P("/usr/bin",i)),a.push(P(this.userHome.fsPath,i)));for(const o of a){let r=t.get(o);if(r===void 0&&(r=await this.fileService.exists(O.file(o)),t.set(o,r)),r)for(const{extensionId:m,extensionName:c,isExtensionPack:h,whenNotInstalled:u}of s.recommendations)n.push({extensionId:m,extensionName:c,isExtensionPack:h,exeName:i,exeFriendlyName:s.exeFriendlyName,windowsPath:s.windowsPath,whenNotInstalled:u})}}return n}}export{se as AbstractNativeExtensionTipsService,T as ExtensionTipsService};
