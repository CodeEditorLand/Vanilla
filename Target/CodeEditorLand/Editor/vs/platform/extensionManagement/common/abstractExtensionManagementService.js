var j=Object.defineProperty;var B=Object.getOwnPropertyDescriptor;var N=(E,h,i,e)=>{for(var o=e>1?void 0:e?B(h,i):h,r=E.length-1,l;r>=0;r--)(l=E[r])&&(o=(e?l(h,i,o):l(o))||o);return e&&o&&j(h,i,o),o},P=(E,h)=>(i,e)=>h(i,e,E);import{distinct as W,isNonEmptyArray as G}from"../../../base/common/arrays.js";import{Barrier as K,createCancelablePromise as $}from"../../../base/common/async.js";import{CancellationToken as S}from"../../../base/common/cancellation.js";import{CancellationError as X,getErrorMessage as D,isCancellationError as H}from"../../../base/common/errors.js";import{Emitter as M,Event as O}from"../../../base/common/event.js";import{Disposable as J,toDisposable as Q}from"../../../base/common/lifecycle.js";import{ResourceMap as Y}from"../../../base/common/map.js";import{isWeb as Z}from"../../../base/common/platform.js";import{isDefined as ee}from"../../../base/common/types.js";import{URI as L}from"../../../base/common/uri.js";import*as w from"../../../nls.js";import{ExtensionType as R,isApplicationScopedExtension as _}from"../../extensions/common/extensions.js";import{areApiProposalsCompatible as ie}from"../../extensions/common/extensionValidator.js";import{ILogService as ne}from"../../log/common/log.js";import{IProductService as te}from"../../product/common/productService.js";import{ITelemetryService as oe}from"../../telemetry/common/telemetry.js";import{IUriIdentityService as se}from"../../uriIdentity/common/uriIdentity.js";import{IUserDataProfilesService as ae}from"../../userDataProfile/common/userDataProfile.js";import{EXTENSION_INSTALL_DEP_PACK_CONTEXT as re,EXTENSION_INSTALL_SOURCE_CONTEXT as F,ExtensionGalleryError as le,ExtensionGalleryErrorCode as ce,ExtensionManagementError as I,ExtensionManagementErrorCode as m,IExtensionGalleryService as fe,InstallOperation as T,isTargetPlatformCompatible as de,StatisticType as V,TargetPlatformToString as pe}from"./extensionManagement.js";import{areSameExtensions as y,ExtensionKey as xe,getGalleryExtensionId as me,getGalleryExtensionTelemetryData as z,getLocalExtensionTelemetryData as Ee}from"./extensionManagementUtil.js";let k=class extends J{constructor(i,e,o,r,l,d){super();this.galleryService=i;this.telemetryService=e;this.uriIdentityService=o;this.logService=r;this.productService=l;this.userDataProfilesService=d;this._register(Q(()=>{this.installingExtensions.forEach(({task:t})=>t.cancel()),this.uninstallingExtensions.forEach(t=>t.cancel()),this.installingExtensions.clear(),this.uninstallingExtensions.clear()}))}extensionsControlManifest;lastReportTimestamp=0;installingExtensions=new Map;uninstallingExtensions=new Map;_onInstallExtension=this._register(new M);get onInstallExtension(){return this._onInstallExtension.event}_onDidInstallExtensions=this._register(new M);get onDidInstallExtensions(){return this._onDidInstallExtensions.event}_onUninstallExtension=this._register(new M);get onUninstallExtension(){return this._onUninstallExtension.event}_onDidUninstallExtension=this._register(new M);get onDidUninstallExtension(){return this._onDidUninstallExtension.event}_onDidUpdateExtensionMetadata=this._register(new M);get onDidUpdateExtensionMetadata(){return this._onDidUpdateExtensionMetadata.event}participants=[];async canInstall(i){const e=await this.getTargetPlatform();return i.allTargetPlatforms.some(o=>de(o,i.allTargetPlatforms,e))}async installFromGallery(i,e={}){try{const r=(await this.installGalleryExtensions([{extension:i,options:e}])).find(({identifier:l})=>y(l,i.identifier));if(r?.local)return r?.local;throw r?.error?r.error:new I(`Unknown error while installing extension ${i.identifier.id}`,m.Unknown)}catch(o){throw C(o)}}async installGalleryExtensions(i){if(!this.galleryService.isEnabled())throw new I(w.localize("MarketPlaceDisabled","Marketplace is not enabled"),m.NotAllowed);const e=[],o=[];return await Promise.allSettled(i.map(async({extension:r,options:l})=>{try{const d=await this.checkAndGetCompatibleVersion(r,!!l?.installGivenVersion,!!l?.installPreReleaseVersion,l.productVersion??{version:this.productService.version,date:this.productService.date});o.push({...d,options:l})}catch(d){e.push({identifier:r.identifier,operation:T.Install,source:r,error:d,profileLocation:l.profileLocation??this.getCurrentExtensionsManifestLocation()})}})),o.length&&e.push(...await this.installExtensions(o)),e}async uninstall(i,e){return this.logService.trace("ExtensionManagementService#uninstall",i.identifier.id),this.uninstallExtensions([{extension:i,options:e}])}async toggleAppliationScope(i,e){if(_(i.manifest)||i.isBuiltin)return i;if(i.isApplicationScoped){let o=await this.updateMetadata(i,{isApplicationScoped:!1},this.userDataProfilesService.defaultProfile.extensionsResource);this.uriIdentityService.extUri.isEqual(e,this.userDataProfilesService.defaultProfile.extensionsResource)||(o=await this.copyExtension(i,this.userDataProfilesService.defaultProfile.extensionsResource,e));for(const r of this.userDataProfilesService.profiles){const l=(await this.getInstalled(R.User,r.extensionsResource)).find(d=>y(d.identifier,i.identifier));l?this._onDidUpdateExtensionMetadata.fire({local:l,profileLocation:r.extensionsResource}):this._onDidUninstallExtension.fire({identifier:i.identifier,profileLocation:r.extensionsResource})}return o}else{const o=this.uriIdentityService.extUri.isEqual(e,this.userDataProfilesService.defaultProfile.extensionsResource)?await this.updateMetadata(i,{isApplicationScoped:!0},this.userDataProfilesService.defaultProfile.extensionsResource):await this.copyExtension(i,e,this.userDataProfilesService.defaultProfile.extensionsResource,{isApplicationScoped:!0});return this._onDidInstallExtensions.fire([{identifier:o.identifier,operation:T.Install,local:o,profileLocation:this.userDataProfilesService.defaultProfile.extensionsResource,applicationScoped:!0}]),o}}getExtensionsControlManifest(){const i=new Date().getTime();return(!this.extensionsControlManifest||i-this.lastReportTimestamp>1e3*60*5)&&(this.extensionsControlManifest=this.updateControlCache(),this.lastReportTimestamp=i),this.extensionsControlManifest}registerParticipant(i){this.participants.push(i)}async resetPinnedStateForAllUserExtensions(i){try{await this.joinAllSettled(this.userDataProfilesService.profiles.map(async e=>{const o=await this.getInstalled(R.User,e.extensionsResource);await this.joinAllSettled(o.map(async r=>{r.pinned!==i&&await this.updateMetadata(r,{pinned:i},e.extensionsResource)}))}))}catch(e){throw this.logService.error("Error while resetting pinned state for all user extensions",D(e)),e}}async installExtensions(i){const e=new Map,o=new Map,r=[],l=(t,s)=>`${xe.create(t).toString()}-${s.toString()}`,d=(t,s,n,c)=>{const a=this.createInstallExtensionTask(t,s,n),f=`${me(t.publisher,t.name)}-${n.profileLocation.toString()}`;o.set(f,{task:a,root:c}),this._onInstallExtension.fire({identifier:a.identifier,source:s,profileLocation:n.profileLocation}),this.logService.info("Installing extension:",a.identifier.id,n),L.isUri(s)||this.installingExtensions.set(l(s,n.profileLocation),{task:a,waitingTasks:[]})};try{for(const{manifest:t,extension:s,options:n}of i){const c=n.isApplicationScoped||n.isBuiltin||_(t),a={...n,installOnlyNewlyAddedFromExtensionPack:n.installOnlyNewlyAddedFromExtensionPack??!L.isUri(s),isApplicationScoped:c,profileLocation:c?this.userDataProfilesService.defaultProfile.extensionsResource:n.profileLocation??this.getCurrentExtensionsManifestLocation(),productVersion:n.productVersion??{version:this.productService.version,date:this.productService.date}},f=L.isUri(s)?void 0:this.installingExtensions.get(l(s,a.profileLocation));f?(this.logService.info("Extension is already requested to install",f.task.identifier.id,a.profileLocation.toString()),r.push(f.task.waitUntilTaskIsFinished())):d(t,s,a,void 0)}return await Promise.all([...o.values()].map(async({task:t})=>{if(t.options.donotIncludePackAndDependencies)this.logService.info("Installing the extension without checking dependencies and pack",t.identifier.id);else try{const s=await this.getAllDepsAndPackExtensions(t.identifier,t.manifest,!!t.options.installOnlyNewlyAddedFromExtensionPack,!!t.options.installPreReleaseVersion,t.options.profileLocation,t.options.productVersion),n=await this.getInstalled(void 0,t.options.profileLocation,t.options.productVersion),c={...t.options,context:{...t.options.context,[re]:!0}};for(const{gallery:a,manifest:f}of W(s,({gallery:p})=>p.identifier.id)){if(o.has(`${a.identifier.id.toLowerCase()}-${c.profileLocation.toString()}`))continue;const p=this.installingExtensions.get(l(a,c.profileLocation));if(p){if(this.canWaitForTask(t,p.task)){const x=p.task.identifier;this.logService.info("Waiting for already requested installing extension",x.id,t.identifier.id,c.profileLocation.toString()),p.waitingTasks.push(t),r.push(O.toPromise(O.filter(this.onDidInstallExtensions,u=>u.some(g=>y(g.identifier,x)))).then(u=>{if(this.logService.info("Finished waiting for already requested installing extension",x.id,t.identifier.id,c.profileLocation.toString()),!u.find(v=>y(v.identifier,x))?.local)throw new Error(`Extension ${x.id} is not installed`)}))}}else n.some(({identifier:x})=>y(x,a.identifier))||d(f,a,c,t)}}catch(s){if(L.isUri(t.source))G(t.manifest.extensionDependencies)&&this.logService.warn("Cannot install dependencies of extension:",t.identifier.id,s.message),G(t.manifest.extensionPack)&&this.logService.warn("Cannot install packed extensions of extension:",t.identifier.id,s.message);else throw this.logService.error("Error while preparing to install dependencies and extension packs of the extension:",t.identifier.id),s}})),await this.joinAllSettled([...o.entries()].map(async([t,{task:s}])=>{const n=new Date().getTime();let c;try{c=await s.run(),await this.joinAllSettled(this.participants.map(a=>a.postInstall(c,s.source,s.options,S.None)),m.PostInstall)}catch(a){const f=C(a);throw L.isUri(s.source)||A(this.telemetryService,s.operation===T.Update?"extensionGallery:update":"extensionGallery:install",{extensionData:z(s.source),error:f,source:s.options.context?.[F]}),e.set(t,{error:f,identifier:s.identifier,operation:s.operation,source:s.source,context:s.options.context,profileLocation:s.options.profileLocation,applicationScoped:s.options.isApplicationScoped}),this.logService.error("Error while installing the extension",s.identifier.id,D(f),s.options.profileLocation.toString()),f}if(!L.isUri(s.source)){const a=s.operation===T.Update,f=a?void 0:(new Date().getTime()-s.source.lastUpdated)/1e3;if(A(this.telemetryService,a?"extensionGallery:update":"extensionGallery:install",{extensionData:z(s.source),verificationStatus:s.verificationStatus,duration:new Date().getTime()-n,durationSinceUpdate:f,source:s.options.context?.[F]}),Z&&s.operation!==T.Update)try{await this.galleryService.reportStatistic(c.manifest.publisher,c.manifest.name,c.manifest.version,V.Install)}catch{}}e.set(t,{local:c,identifier:s.identifier,operation:s.operation,source:s.source,context:s.options.context,profileLocation:s.options.profileLocation,applicationScoped:c.isApplicationScoped})})),r.length&&await this.joinAllSettled(r),[...e.values()]}catch(t){const s=(a,f,p)=>{const x=[];a.manifest.extensionDependencies?.length&&x.push(...a.manifest.extensionDependencies),a.manifest.extensionPack?.length&&x.push(...a.manifest.extensionPack);for(const u of x){if(p.includes(u.toLowerCase()))continue;p.push(u.toLowerCase());const g=e.get(`${u.toLowerCase()}-${f.toString()}`);g?.local&&(p=s(g.local,f,p))}return p},n=a=>({identifier:a.identifier,operation:T.Install,source:a.source,context:a.options.context,profileLocation:a.options.profileLocation,error:t}),c=[];for(const[a,{task:f,root:p}]of o){const x=e.get(a);x?x.local&&p&&!e.get(`${p.identifier.id.toLowerCase()}-${f.options.profileLocation.toString()}`)?.local&&(c.push(this.createUninstallExtensionTask(x.local,{versionOnly:!0,profileLocation:f.options.profileLocation})),e.set(a,n(f))):(f.cancel(),e.set(a,n(f)))}for(const[a,{task:f}]of o){const p=e.get(a);if(!p?.local||f.options.donotIncludePackAndDependencies)continue;s(p.local,f.options.profileLocation,[p.local.identifier.id.toLowerCase()]).slice(1).some(u=>o.has(`${u.toLowerCase()}-${f.options.profileLocation.toString()}`)&&!e.get(`${u.toLowerCase()}-${f.options.profileLocation.toString()}`)?.local)&&(c.push(this.createUninstallExtensionTask(p.local,{versionOnly:!0,profileLocation:f.options.profileLocation})),e.set(a,n(f)))}throw c.length&&await Promise.allSettled(c.map(async a=>{try{await a.run(),this.logService.info("Rollback: Uninstalled extension",a.extension.identifier.id)}catch(f){this.logService.warn("Rollback: Error while uninstalling extension",a.extension.identifier.id,D(f))}})),t}finally{for(const{task:t}of o.values())t.source&&!L.isUri(t.source)&&this.installingExtensions.delete(l(t.source,t.options.profileLocation));if(e.size){const t=[...e.values()];for(const s of t)s.local&&this.logService.info("Extension installed successfully:",s.identifier.id,s.profileLocation.toString());this._onDidInstallExtensions.fire(t)}}}canWaitForTask(i,e){for(const[,{task:o,waitingTasks:r}]of this.installingExtensions.entries())if(o===i&&(r.includes(e)||r.some(l=>this.canWaitForTask(l,e)))||o===e&&r[0]&&!this.canWaitForTask(i,r[0]))return!1;return!0}async joinAllSettled(i,e){const o=[],r=[],l=await Promise.allSettled(i);for(const t of l)t.status==="fulfilled"?o.push(t.value):r.push(C(t.reason,e));if(!r.length)return o;if(r.length===1)throw r[0];let d=new I("",m.Unknown);for(const t of r)d=new I(d.message?`${d.message}, ${t.message}`:t.message,t.code!==m.Unknown&&t.code!==m.Internal?t.code:d.code);throw d}async getAllDepsAndPackExtensions(i,e,o,r,l,d){if(!this.galleryService.isEnabled())return[];const t=await this.getInstalled(void 0,l,d),s=[],n=[],c=async(a,f)=>{s.push(a);const p=f.extensionDependencies||[],x=[...p];if(f.extensionPack){const u=o?t.find(g=>y(g.identifier,a)):void 0;for(const g of f.extensionPack)u&&u.manifest.extensionPack&&u.manifest.extensionPack.some(v=>y({id:v},{id:g}))||x.every(v=>!y({id:v},{id:g}))&&x.push(g)}if(x.length){const u=x.filter(g=>s.every(v=>!y(v,{id:g})));if(u.length){const g=await this.galleryService.getExtensions(u.map(v=>({id:v,preRelease:r})),S.None);for(const v of g){if(s.find(U=>y(U,v.identifier)))continue;const q=p.some(U=>y({id:U},v.identifier));let b;try{b=await this.checkAndGetCompatibleVersion(v,!1,r,d)}catch(U){if(q)throw U;this.logService.info("Skipping the packed extension as it cannot be installed",v.identifier.id,D(U));continue}n.push({gallery:b.extension,manifest:b.manifest}),await c(b.extension.identifier,b.manifest)}}}};return await c(i,e),n}async checkAndGetCompatibleVersion(i,e,o,r){let l;const d=await this.getExtensionsControlManifest();if(d.malicious.some(n=>y(i.identifier,n)))throw new I(w.localize("malicious extension","Can't install '{0}' extension since it was reported to be problematic.",i.identifier.id),m.Malicious);const t=d.deprecated[i.identifier.id.toLowerCase()];if(t?.extension?.autoMigrate){if(this.logService.info(`The '${i.identifier.id}' extension is deprecated, fetching the compatible '${t.extension.id}' extension instead.`),l=(await this.galleryService.getExtensions([{id:t.extension.id,preRelease:t.extension.preRelease}],{targetPlatform:await this.getTargetPlatform(),compatible:!0,productVersion:r},S.None))[0],!l)throw new I(w.localize("notFoundDeprecatedReplacementExtension","Can't install '{0}' extension since it was deprecated and the replacement extension '{1}' can't be found.",i.identifier.id,t.extension.id),m.Deprecated)}else{if(!await this.canInstall(i)){const n=await this.getTargetPlatform();throw new I(w.localize("incompatible platform","The '{0}' extension is not available in {1} for {2}.",i.identifier.id,this.productService.nameLong,pe(n)),m.IncompatibleTargetPlatform)}if(l=await this.getCompatibleVersion(i,e,o,r),!l){const n=[];throw ie(i.properties.enabledApiProposals??[],n)?!o&&i.properties.isPreReleaseVersion&&(await this.galleryService.getExtensions([i.identifier],S.None))[0]?new I(w.localize("notFoundReleaseExtension","Can't install release version of '{0}' extension because it has no release version.",i.displayName??i.identifier.id),m.ReleaseVersionNotFound):new I(w.localize("notFoundCompatibleDependency","Can't install '{0}' extension because it is not compatible with the current version of {1} (version {2}).",i.identifier.id,this.productService.nameLong,this.productService.version),m.Incompatible):new I(w.localize("incompatibleAPI","Can't install '{0}' extension. {1}",i.displayName??i.identifier.id,n[0]),m.IncompatibleApi)}}this.logService.info("Getting Manifest...",l.identifier.id);const s=await this.galleryService.getManifest(l,S.None);if(s===null)throw new I(`Missing manifest for extension ${l.identifier.id}`,m.Invalid);if(s.version!==l.version)throw new I(`Cannot install '${l.identifier.id}' extension because of version mismatch in Marketplace`,m.Invalid);return{extension:l,manifest:s}}async getCompatibleVersion(i,e,o,r){const l=await this.getTargetPlatform();let d=null;return!e&&i.hasPreReleaseVersion&&i.properties.isPreReleaseVersion!==o&&(d=(await this.galleryService.getExtensions([{...i.identifier,preRelease:o}],{targetPlatform:l,compatible:!0,productVersion:r},S.None))[0]||null),!d&&await this.galleryService.isExtensionCompatible(i,o,l,r)&&(d=i),d||(e?d=(await this.galleryService.getExtensions([{...i.identifier,version:i.version}],{targetPlatform:l,compatible:!0,productVersion:r},S.None))[0]||null:d=await this.galleryService.getCompatibleExtension(i,o,l,r)),d}async uninstallExtensions(i){const e=(n,c)=>`${n.identifier.id.toLowerCase()}${c.versionOnly?`-${n.manifest.version}`:""}@${c.profileLocation.toString()}`,o=(n,c)=>{const a=this.createUninstallExtensionTask(n,c);return this.uninstallingExtensions.set(e(a.extension,c),a),this.logService.info("Uninstalling extension from the profile:",`${n.identifier.id}@${n.manifest.version}`,c.profileLocation.toString()),this._onUninstallExtension.fire({identifier:n.identifier,profileLocation:c.profileLocation,applicationScoped:n.isApplicationScoped}),a},r=(n,c,a)=>{a?this.logService.error("Failed to uninstall extension from the profile:",`${n.identifier.id}@${n.manifest.version}`,c.profileLocation.toString(),a.message):this.logService.info("Successfully uninstalled extension from the profile",`${n.identifier.id}@${n.manifest.version}`,c.profileLocation.toString()),A(this.telemetryService,"extensionGallery:uninstall",{extensionData:Ee(n),error:a}),this._onDidUninstallExtension.fire({identifier:n.identifier,error:a?.code,profileLocation:c.profileLocation,applicationScoped:n.isApplicationScoped})},l=[],d=[],t=[],s=new Y;for(const{extension:n,options:c}of i){const a={...c,profileLocation:n.isApplicationScoped?this.userDataProfilesService.defaultProfile.extensionsResource:c?.profileLocation??this.getCurrentExtensionsManifestLocation()},f=this.uninstallingExtensions.get(e(n,a));f?(this.logService.info("Extensions is already requested to uninstall",n.identifier.id),t.push(f.waitUntilTaskIsFinished())):l.push(o(n,a))}try{for(const n of l.slice(0)){let c=s.get(n.options.profileLocation);if(c||s.set(n.options.profileLocation,c=await this.getInstalled(R.User,n.options.profileLocation)),n.options.donotIncludePack)this.logService.info("Uninstalling the extension without including packed extension",`${n.extension.identifier.id}@${n.extension.manifest.version}`);else{const a=this.getAllPackExtensionsToUninstall(n.extension,c);for(const f of a)this.uninstallingExtensions.has(e(f,n.options))?this.logService.info("Extensions is already requested to uninstall",f.identifier.id):l.push(o(f,n.options))}n.options.donotCheckDependents?this.logService.info("Uninstalling the extension without checking dependents",`${n.extension.identifier.id}@${n.extension.manifest.version}`):this.checkForDependents(l.map(a=>a.extension),c,n.extension)}await this.joinAllSettled(l.map(async n=>{try{if(await n.run(),await this.joinAllSettled(this.participants.map(c=>c.postUninstall(n.extension,n.options,S.None))),n.extension.identifier.uuid)try{await this.galleryService.reportStatistic(n.extension.manifest.publisher,n.extension.manifest.name,n.extension.manifest.version,V.Uninstall)}catch{}}catch(c){const a=C(c);throw r(n.extension,n.options,a),a}finally{d.push(n)}})),t.length&&await this.joinAllSettled(t);for(const n of l)r(n.extension,n.options)}catch(n){const c=C(n);for(const a of l){try{a.cancel()}catch{}d.includes(a)||r(a.extension,a.options,c)}throw c}finally{for(const n of l)this.uninstallingExtensions.delete(e(n.extension,n.options))||this.logService.warn("Uninstallation task is not found in the cache",n.extension.identifier.id)}}checkForDependents(i,e,o){for(const r of i){const l=this.getDependents(r,e);if(l.length){const d=l.filter(t=>!i.some(s=>y(s.identifier,t.identifier)));if(d.length)throw new Error(this.getDependentsErrorMessage(r,d,o))}}}getDependentsErrorMessage(i,e,o){return o===i?e.length===1?w.localize("singleDependentError","Cannot uninstall '{0}' extension. '{1}' extension depends on this.",o.manifest.displayName||o.manifest.name,e[0].manifest.displayName||e[0].manifest.name):e.length===2?w.localize("twoDependentsError","Cannot uninstall '{0}' extension. '{1}' and '{2}' extensions depend on this.",o.manifest.displayName||o.manifest.name,e[0].manifest.displayName||e[0].manifest.name,e[1].manifest.displayName||e[1].manifest.name):w.localize("multipleDependentsError","Cannot uninstall '{0}' extension. '{1}', '{2}' and other extension depend on this.",o.manifest.displayName||o.manifest.name,e[0].manifest.displayName||e[0].manifest.name,e[1].manifest.displayName||e[1].manifest.name):e.length===1?w.localize("singleIndirectDependentError","Cannot uninstall '{0}' extension . It includes uninstalling '{1}' extension and '{2}' extension depends on this.",o.manifest.displayName||o.manifest.name,i.manifest.displayName||i.manifest.name,e[0].manifest.displayName||e[0].manifest.name):e.length===2?w.localize("twoIndirectDependentsError","Cannot uninstall '{0}' extension. It includes uninstalling '{1}' extension and '{2}' and '{3}' extensions depend on this.",o.manifest.displayName||o.manifest.name,i.manifest.displayName||i.manifest.name,e[0].manifest.displayName||e[0].manifest.name,e[1].manifest.displayName||e[1].manifest.name):w.localize("multipleIndirectDependentsError","Cannot uninstall '{0}' extension. It includes uninstalling '{1}' extension and '{2}', '{3}' and other extensions depend on this.",o.manifest.displayName||o.manifest.name,i.manifest.displayName||i.manifest.name,e[0].manifest.displayName||e[0].manifest.name,e[1].manifest.displayName||e[1].manifest.name)}getAllPackExtensionsToUninstall(i,e,o=[]){if(o.indexOf(i)!==-1)return[];o.push(i);const r=i.manifest.extensionPack?i.manifest.extensionPack:[];if(r.length){const l=e.filter(t=>!t.isBuiltin&&r.some(s=>y({id:s},t.identifier))),d=[];for(const t of l)d.push(...this.getAllPackExtensionsToUninstall(t,e,o));return[...l,...d]}return[]}getDependents(i,e){return e.filter(o=>o.manifest.extensionDependencies&&o.manifest.extensionDependencies.some(r=>y({id:r},i.identifier)))}async updateControlCache(){try{return this.logService.trace("ExtensionManagementService.updateControlCache"),await this.galleryService.getExtensionsControlManifest()}catch(i){return this.logService.trace("ExtensionManagementService.refreshControlCache - failed to get extension control manifest",D(i)),{malicious:[],deprecated:{},search:[]}}}};k=N([P(0,fe),P(1,oe),P(2,se),P(3,ne),P(4,te),P(5,ae)],k);function C(E,h){if(E instanceof I)return E;let i;return E instanceof le?i=new I(E.message,E.code===ce.DownloadFailedWriting?m.DownloadFailedWriting:m.Gallery):i=new I(E.message,H(E)?m.Cancelled:h??m.Internal),i.stack=E.stack,i}function A(E,h,{extensionData:i,verificationStatus:e,duration:o,error:r,source:l,durationSinceUpdate:d}){let t,s;ee(e)&&(e===!0?e="Verified":(e===!1||(t=m.Signature,s=e),e="Unverified")),r&&(t=r.code,r.code===m.Signature&&(s=r.message)),E.publicLog(h,{...i,verificationStatus:e,success:!r,duration:o,errorcode:t,errorcodeDetail:s,durationSinceUpdate:d,source:l})}class ni{barrier=new K;cancellablePromise;async waitUntilTaskIsFinished(){return await this.barrier.wait(),this.cancellablePromise}run(){return this.cancellablePromise||(this.cancellablePromise=$(h=>this.doRun(h))),this.barrier.open(),this.cancellablePromise}cancel(){this.cancellablePromise||(this.cancellablePromise=$(h=>new Promise((i,e)=>{const o=h.onCancellationRequested(()=>{o.dispose(),e(new X)})})),this.barrier.open()),this.cancellablePromise.cancel()}}export{k as AbstractExtensionManagementService,ni as AbstractExtensionTask,C as toExtensionManagementError};
