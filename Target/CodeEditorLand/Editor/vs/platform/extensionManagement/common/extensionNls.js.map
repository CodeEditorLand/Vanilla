{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/extensionManagement/common/extensionNls.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isObject, isString } from \"../../../base/common/types.js\";\nimport { localize } from \"../../../nls.js\";\nimport type { ILocalizedString } from \"../../action/common/action.js\";\nimport type { IExtensionManifest } from \"../../extensions/common/extensions.js\";\nimport type { ILogger } from \"../../log/common/log.js\";\n\nexport interface ITranslations {\n\t[key: string]: string | { message: string; comment: string[] } | undefined;\n}\n\nexport function localizeManifest(\n\tlogger: ILogger,\n\textensionManifest: IExtensionManifest,\n\ttranslations: ITranslations,\n\tfallbackTranslations?: ITranslations,\n): IExtensionManifest {\n\ttry {\n\t\treplaceNLStrings(\n\t\t\tlogger,\n\t\t\textensionManifest,\n\t\t\ttranslations,\n\t\t\tfallbackTranslations,\n\t\t);\n\t} catch (error) {\n\t\tlogger.error(error?.message ?? error);\n\t\t/*Ignore Error*/\n\t}\n\treturn extensionManifest;\n}\n\n/**\n * This routine makes the following assumptions:\n * The root element is an object literal\n */\nfunction replaceNLStrings(\n\tlogger: ILogger,\n\textensionManifest: IExtensionManifest,\n\tmessages: ITranslations,\n\toriginalMessages?: ITranslations,\n): void {\n\tconst processEntry = (\n\t\tobj: any,\n\t\tkey: string | number,\n\t\tcommand?: boolean,\n\t) => {\n\t\tconst value = obj[key];\n\t\tif (isString(value)) {\n\t\t\tconst str = <string>value;\n\t\t\tconst length = str.length;\n\t\t\tif (length > 1 && str[0] === \"%\" && str[length - 1] === \"%\") {\n\t\t\t\tconst messageKey = str.substr(1, length - 2);\n\t\t\t\tlet translated = messages[messageKey];\n\t\t\t\t// If the messages come from a language pack they might miss some keys\n\t\t\t\t// Fill them from the original messages.\n\t\t\t\tif (translated === undefined && originalMessages) {\n\t\t\t\t\ttranslated = originalMessages[messageKey];\n\t\t\t\t}\n\t\t\t\tconst message: string | undefined =\n\t\t\t\t\ttypeof translated === \"string\"\n\t\t\t\t\t\t? translated\n\t\t\t\t\t\t: translated?.message;\n\n\t\t\t\t// This branch returns ILocalizedString's instead of Strings so that the Command Palette can contain both the localized and the original value.\n\t\t\t\tconst original = originalMessages?.[messageKey];\n\t\t\t\tconst originalMessage: string | undefined =\n\t\t\t\t\ttypeof original === \"string\" ? original : original?.message;\n\n\t\t\t\tif (!message) {\n\t\t\t\t\tif (!originalMessage) {\n\t\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\t`[${extensionManifest.name}]: ${localize(\"missingNLSKey\", \"Couldn't find message for key {0}.\", messageKey)}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t// if we are translating the title or category of a command\n\t\t\t\t\tcommand &&\n\t\t\t\t\t(key === \"title\" || key === \"category\") &&\n\t\t\t\t\t// and the original value is not the same as the translated value\n\t\t\t\t\toriginalMessage &&\n\t\t\t\t\toriginalMessage !== message\n\t\t\t\t) {\n\t\t\t\t\tconst localizedString: ILocalizedString = {\n\t\t\t\t\t\tvalue: message,\n\t\t\t\t\t\toriginal: originalMessage,\n\t\t\t\t\t};\n\t\t\t\t\tobj[key] = localizedString;\n\t\t\t\t} else {\n\t\t\t\t\tobj[key] = message;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isObject(value)) {\n\t\t\tfor (const k in value) {\n\t\t\t\tif (value.hasOwnProperty(k)) {\n\t\t\t\t\tk === \"commands\"\n\t\t\t\t\t\t? processEntry(value, k, true)\n\t\t\t\t\t\t: processEntry(value, k, command);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (Array.isArray(value)) {\n\t\t\tfor (let i = 0; i < value.length; i++) {\n\t\t\t\tprocessEntry(value, i, command);\n\t\t\t}\n\t\t}\n\t};\n\n\tfor (const key in extensionManifest) {\n\t\tif (extensionManifest.hasOwnProperty(key)) {\n\t\t\tprocessEntry(extensionManifest, key);\n\t\t}\n\t}\n}\n"],
  "mappings": ";;AAKA,SAAS,UAAU,gBAAgB;AACnC,SAAS,gBAAgB;AASlB,SAAS,iBACf,QACA,mBACA,cACA,sBACqB;AACrB,MAAI;AACH;AAAA,MACC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACD;AAAA,EACD,SAAS,OAAO;AACf,WAAO,MAAM,OAAO,WAAW,KAAK;AAAA,EAErC;AACA,SAAO;AACR;AAlBgB;AAwBhB,SAAS,iBACR,QACA,mBACA,UACA,kBACO;AACP,QAAM,eAAe,wBACpB,KACA,KACA,YACI;AACJ,UAAM,QAAQ,IAAI,GAAG;AACrB,QAAI,SAAS,KAAK,GAAG;AACpB,YAAM,MAAc;AACpB,YAAM,SAAS,IAAI;AACnB,UAAI,SAAS,KAAK,IAAI,CAAC,MAAM,OAAO,IAAI,SAAS,CAAC,MAAM,KAAK;AAC5D,cAAM,aAAa,IAAI,OAAO,GAAG,SAAS,CAAC;AAC3C,YAAI,aAAa,SAAS,UAAU;AAGpC,YAAI,eAAe,UAAa,kBAAkB;AACjD,uBAAa,iBAAiB,UAAU;AAAA,QACzC;AACA,cAAM,UACL,OAAO,eAAe,WACnB,aACA,YAAY;AAGhB,cAAM,WAAW,mBAAmB,UAAU;AAC9C,cAAM,kBACL,OAAO,aAAa,WAAW,WAAW,UAAU;AAErD,YAAI,CAAC,SAAS;AACb,cAAI,CAAC,iBAAiB;AACrB,mBAAO;AAAA,cACN,IAAI,kBAAkB,IAAI,MAAM,SAAS,iBAAiB,sCAAsC,UAAU,CAAC;AAAA,YAC5G;AAAA,UACD;AACA;AAAA,QACD;AAEA;AAAA;AAAA,UAEC,YACC,QAAQ,WAAW,QAAQ;AAAA,UAE5B,mBACA,oBAAoB;AAAA,UACnB;AACD,gBAAM,kBAAoC;AAAA,YACzC,OAAO;AAAA,YACP,UAAU;AAAA,UACX;AACA,cAAI,GAAG,IAAI;AAAA,QACZ,OAAO;AACN,cAAI,GAAG,IAAI;AAAA,QACZ;AAAA,MACD;AAAA,IACD,WAAW,SAAS,KAAK,GAAG;AAC3B,iBAAW,KAAK,OAAO;AACtB,YAAI,MAAM,eAAe,CAAC,GAAG;AAC5B,gBAAM,aACH,aAAa,OAAO,GAAG,IAAI,IAC3B,aAAa,OAAO,GAAG,OAAO;AAAA,QAClC;AAAA,MACD;AAAA,IACD,WAAW,MAAM,QAAQ,KAAK,GAAG;AAChC,eAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACtC,qBAAa,OAAO,GAAG,OAAO;AAAA,MAC/B;AAAA,IACD;AAAA,EACD,GAlEqB;AAoErB,aAAW,OAAO,mBAAmB;AACpC,QAAI,kBAAkB,eAAe,GAAG,GAAG;AAC1C,mBAAa,mBAAmB,GAAG;AAAA,IACpC;AAAA,EACD;AACD;AA/ES;",
  "names": []
}
