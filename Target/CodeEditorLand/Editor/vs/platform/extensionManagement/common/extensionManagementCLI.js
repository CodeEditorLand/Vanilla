var R=Object.defineProperty;var G=Object.getOwnPropertyDescriptor;var y=(u,n,o,a)=>{for(var t=a>1?void 0:a?G(n,o):n,f=u.length-1,i;f>=0;f--)(i=u[f])&&(t=(a?i(n,o,t):i(t))||t);return a&&t&&R(n,o,t),t},p=(u,n)=>(o,a)=>n(o,a,u);import{CancellationToken as I}from"../../../base/common/cancellation.js";import{getErrorMessage as E,isCancellationError as M}from"../../../base/common/errors.js";import{Schemas as P}from"../../../base/common/network.js";import{basename as w}from"../../../base/common/resources.js";import{gt as S}from"../../../base/common/semver/semver.js";import{URI as m}from"../../../base/common/uri.js";import{localize as r}from"../../../nls.js";import{EXTENSION_IDENTIFIER_REGEX as V,IExtensionGalleryService as L,IExtensionManagementService as C,InstallOperation as T}from"./extensionManagement.js";import{areSameExtensions as x,getExtensionId as $,getGalleryExtensionId as A,getIdAndVersion as b}from"./extensionManagementUtil.js";import{ExtensionType as v,EXTENSION_CATEGORIES as N}from"../../extensions/common/extensions.js";import"../../log/common/log.js";const O=u=>r("notFound","Extension '{0}' not found.",u),U=r("useId","Make sure you use the full extension ID, including the publisher, e.g.: {0}","ms-dotnettools.csharp");let h=class{constructor(n,o,a){this.logger=n;this.extensionManagementService=o;this.extensionGalleryService=a}get location(){}async listExtensions(n,o,a){let t=await this.extensionManagementService.getInstalled(v.User,a);const f=N.map(e=>e.toLowerCase());if(o&&o!==""){if(f.indexOf(o.toLowerCase())<0){this.logger.info("Invalid category please enter a valid category. To list valid categories run --category without a category specified");return}t=t.filter(e=>e.manifest.categories?e.manifest.categories.map(c=>c.toLowerCase()).indexOf(o.toLowerCase())>-1:!1)}else if(o===""){this.logger.info("Possible Categories: "),f.forEach(e=>{this.logger.info(e)});return}this.location&&this.logger.info(r("listFromLocation","Extensions installed on {0}:",this.location)),t=t.sort((e,s)=>e.identifier.id.localeCompare(s.identifier.id));let i;for(const e of t)i!==e.identifier.id&&(i=e.identifier.id,this.logger.info(n?`${i}@${e.manifest.version}`:i))}async installExtensions(n,o,a,t){const f=[];try{n.length&&this.logger.info(this.location?r("installingExtensionsOnLocation","Installing extensions on {0}...",this.location):r("installingExtensions","Installing extensions..."));const i=[],e=[],s=(l,d,g)=>{e.push({id:l,version:d!=="prerelease"?d:void 0,installOptions:{...a,isBuiltin:g,installPreReleaseVersion:d==="prerelease"||a.installPreReleaseVersion}})};for(const l of n)if(l instanceof m)i.push({vsix:l,installOptions:a});else{const[d,g]=b(l);s(d,g,!1)}for(const l of o)if(l instanceof m)i.push({vsix:l,installOptions:{...a,isBuiltin:!0,donotIncludePackAndDependencies:!0}});else{const[d,g]=b(l);s(d,g,!0)}const c=await this.extensionManagementService.getInstalled(void 0,a.profileLocation);if(i.length&&await Promise.all(i.map(async({vsix:l,installOptions:d})=>{try{await this.installVSIX(l,d,t,c)}catch(g){this.logger.error(g),f.push(l.toString())}})),e.length){const l=await this.installGalleryExtensions(e,c,t);f.push(...l)}}catch(i){throw this.logger.error(r("error while installing extensions","Error while installing extensions: {0}",E(i))),i}if(f.length)throw new Error(r("installation failed","Failed Installing Extensions: {0}",f.join(", ")))}async updateExtensions(n){const o=await this.extensionManagementService.getInstalled(v.User,n),a=[];for(const e of o)e.identifier.uuid&&a.push({...e.identifier,preRelease:e.preRelease});this.logger.trace(r({key:"updateExtensionsQuery",comment:["Placeholder is for the count of extensions"]},"Fetching latest versions for {0} extensions",a.length));const t=await this.extensionGalleryService.getExtensions(a,{compatible:!0},I.None),f=[];for(const e of t)for(const s of o)x(s.identifier,e.identifier)&&S(e.version,s.manifest.version)&&f.push({extension:e,options:{operation:T.Update,installPreReleaseVersion:s.preRelease,profileLocation:n,isApplicationScoped:s.isApplicationScoped}});if(!f.length){this.logger.info(r("updateExtensionsNoExtensions","No extension to update"));return}this.logger.info(r("updateExtensionsNewVersionsAvailable","Updating extensions: {0}",f.map(e=>e.extension.identifier.id).join(", ")));const i=await this.extensionManagementService.installGalleryExtensions(f);for(const e of i)e.error?this.logger.error(r("errorUpdatingExtension","Error while updating extension {0}: {1}",e.identifier.id,E(e.error))):this.logger.info(r("successUpdate","Extension '{0}' v{1} was successfully updated.",e.identifier.id,e.local?.manifest.version))}async installGalleryExtensions(n,o,a){if(n=n.filter(({id:e,version:s})=>{const c=o.find(l=>x(l.identifier,{id:e}));if(c){if(!a&&(!s||s==="prerelease"&&c.preRelease))return this.logger.info(r("alreadyInstalled-checkAndUpdate","Extension '{0}' v{1} is already installed. Use '--force' option to update to latest version or provide '@<version>' to install a specific version, for example: '{2}@1.2.3'.",e,c.manifest.version,e)),!1;if(s&&c.manifest.version===s)return this.logger.info(r("alreadyInstalled","Extension '{0}' is already installed.",`${e}@${s}`)),!1}return!0}),!n.length)return[];const t=[],f=[],i=await this.getGalleryExtensions(n);if(await Promise.all(n.map(async({id:e,version:s,installOptions:c})=>{const l=i.get(e.toLowerCase());if(!l){this.logger.error(`${O(s?`${e}@${s}`:e)}
${U}`),t.push(e);return}try{const g=await this.extensionGalleryService.getManifest(l,I.None);if(g&&!this.validateExtensionKind(g))return}catch(g){this.logger.error(g.message||g.stack||g),t.push(e);return}const d=o.find(g=>x(g.identifier,l.identifier));if(d){if(l.version===d.manifest.version){this.logger.info(r("alreadyInstalled","Extension '{0}' is already installed.",s?`${e}@${s}`:e));return}this.logger.info(r("updateMessage","Updating the extension '{0}' to the version {1}",e,l.version))}c.isBuiltin?this.logger.info(s?r("installing builtin with version","Installing builtin extension '{0}' v{1}...",e,s):r("installing builtin ","Installing builtin extension '{0}'...",e)):this.logger.info(s?r("installing with version","Installing extension '{0}' v{1}...",e,s):r("installing","Installing extension '{0}'...",e)),f.push({extension:l,options:{...c,installGivenVersion:!!s,isApplicationScoped:c.isApplicationScoped||d?.isApplicationScoped}})})),f.length){const e=await this.extensionManagementService.installGalleryExtensions(f);for(const s of e)s.error?(this.logger.error(r("errorInstallingExtension","Error while installing extension {0}: {1}",s.identifier.id,E(s.error))),t.push(s.identifier.id)):this.logger.info(r("successInstall","Extension '{0}' v{1} was successfully installed.",s.identifier.id,s.local?.manifest.version))}return t}async installVSIX(n,o,a,t){const f=await this.extensionManagementService.getManifest(n);if(!f)throw new Error("Invalid vsix");if(await this.validateVSIX(f,a,o.profileLocation,t))try{await this.extensionManagementService.install(n,{...o,installGivenVersion:!0}),this.logger.info(r("successVsixInstall","Extension '{0}' was successfully installed.",w(n)))}catch(e){if(M(e))this.logger.info(r("cancelVsixInstall","Cancelled installing extension '{0}'.",w(n)));else throw e}}async getGalleryExtensions(n){const o=new Map,a=n.some(i=>i.installOptions.installPreReleaseVersion),t=await this.extensionManagementService.getTargetPlatform(),f=[];for(const i of n)V.test(i.id)&&f.push({...i,preRelease:a});if(f.length){const i=await this.extensionGalleryService.getExtensions(f,{targetPlatform:t},I.None);for(const e of i)o.set(e.identifier.id.toLowerCase(),e)}return o}validateExtensionKind(n){return!0}async validateVSIX(n,o,a,t){if(!o){const f={id:A(n.publisher,n.name)},i=t.find(e=>x(f,e.identifier)&&S(e.manifest.version,n.version));if(i)return this.logger.info(r("forceDowngrade","A newer version of extension '{0}' v{1} is already installed. Use '--force' option to downgrade to older version.",i.identifier.id,i.manifest.version,n.version)),!1}return this.validateExtensionKind(n)}async uninstallExtensions(n,o,a){const t=async i=>{if(i instanceof m){const e=await this.extensionManagementService.getManifest(i);return $(e.publisher,e.name)}return i},f=[];for(const i of n){const e=await t(i),c=(await this.extensionManagementService.getInstalled(void 0,a)).filter(l=>x(l.identifier,{id:e}));if(!c.length)throw new Error(`${this.notInstalled(e)}
${U}`);if(c.some(l=>l.type===v.System)){this.logger.info(r("builtin","Extension '{0}' is a Built-in extension and cannot be uninstalled",e));return}if(!o&&c.some(l=>l.isBuiltin)){this.logger.info(r("forceUninstall","Extension '{0}' is marked as a Built-in extension by user. Please use '--force' option to uninstall it.",e));return}this.logger.info(r("uninstalling","Uninstalling {0}...",e));for(const l of c)await this.extensionManagementService.uninstall(l,{profileLocation:a}),f.push(l);this.location?this.logger.info(r("successUninstallFromLocation","Extension '{0}' was successfully uninstalled from {1}!",e,this.location)):this.logger.info(r("successUninstall","Extension '{0}' was successfully uninstalled!",e))}}async locateExtension(n){const o=await this.extensionManagementService.getInstalled();n.forEach(a=>{o.forEach(t=>{if(t.identifier.id===a&&t.location.scheme===P.file){this.logger.info(t.location.fsPath);return}})})}notInstalled(n){return this.location?r("notInstalleddOnLocation","Extension '{0}' is not installed on {1}.",n,this.location):r("notInstalled","Extension '{0}' is not installed.",n)}};h=y([p(1,C),p(2,L)],h);export{h as ExtensionManagementCLI};
