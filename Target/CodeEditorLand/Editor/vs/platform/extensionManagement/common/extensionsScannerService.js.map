{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/extensionManagement/common/extensionsScannerService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { coalesce } from '../../../base/common/arrays.js';\nimport { ThrottledDelayer } from '../../../base/common/async.js';\nimport * as objects from '../../../base/common/objects.js';\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport { IStringDictionary } from '../../../base/common/collections.js';\nimport { getErrorMessage } from '../../../base/common/errors.js';\nimport { getNodeType, parse, ParseError } from '../../../base/common/json.js';\nimport { getParseErrorMessage } from '../../../base/common/jsonErrorMessages.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { FileAccess, Schemas } from '../../../base/common/network.js';\nimport * as path from '../../../base/common/path.js';\nimport * as platform from '../../../base/common/platform.js';\nimport { basename, isEqual, joinPath } from '../../../base/common/resources.js';\nimport * as semver from '../../../base/common/semver/semver.js';\nimport Severity from '../../../base/common/severity.js';\nimport { isEmptyObject } from '../../../base/common/types.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { localize } from '../../../nls.js';\nimport { IEnvironmentService } from '../../environment/common/environment.js';\nimport { IProductVersion, Metadata } from './extensionManagement.js';\nimport { areSameExtensions, computeTargetPlatform, ExtensionKey, getExtensionId, getGalleryExtensionId } from './extensionManagementUtil.js';\nimport { ExtensionType, ExtensionIdentifier, IExtensionManifest, TargetPlatform, IExtensionIdentifier, IRelaxedExtensionManifest, UNDEFINED_PUBLISHER, IExtensionDescription, BUILTIN_MANIFEST_CACHE_FILE, USER_MANIFEST_CACHE_FILE, ExtensionIdentifierMap, parseEnabledApiProposalNames } from '../../extensions/common/extensions.js';\nimport { validateExtensionManifest } from '../../extensions/common/extensionValidator.js';\nimport { FileOperationResult, IFileService, toFileOperationResult } from '../../files/common/files.js';\nimport { createDecorator, IInstantiationService } from '../../instantiation/common/instantiation.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { IProductService } from '../../product/common/productService.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { revive } from '../../../base/common/marshalling.js';\nimport { ExtensionsProfileScanningError, ExtensionsProfileScanningErrorCode, IExtensionsProfileScannerService, IProfileExtensionsScanOptions, IScannedProfileExtension } from './extensionsProfileScannerService.js';\nimport { IUserDataProfile, IUserDataProfilesService } from '../../userDataProfile/common/userDataProfile.js';\nimport { IUriIdentityService } from '../../uriIdentity/common/uriIdentity.js';\nimport { localizeManifest } from './extensionNls.js';\n\nexport type IScannedExtensionManifest = IRelaxedExtensionManifest & { __metadata?: Metadata };\n\ninterface IRelaxedScannedExtension {\n\ttype: ExtensionType;\n\tisBuiltin: boolean;\n\tidentifier: IExtensionIdentifier;\n\tmanifest: IRelaxedExtensionManifest;\n\tlocation: URI;\n\ttargetPlatform: TargetPlatform;\n\tpublisherDisplayName?: string;\n\tmetadata: Metadata | undefined;\n\tisValid: boolean;\n\tvalidations: readonly [Severity, string][];\n}\n\nexport type IScannedExtension = Readonly<IRelaxedScannedExtension> & { manifest: IExtensionManifest };\n\nexport interface Translations {\n\t[id: string]: string;\n}\n\nexport namespace Translations {\n\texport function equals(a: Translations, b: Translations): boolean {\n\t\tif (a === b) {\n\t\t\treturn true;\n\t\t}\n\t\tconst aKeys = Object.keys(a);\n\t\tconst bKeys: Set<string> = new Set<string>();\n\t\tfor (const key of Object.keys(b)) {\n\t\t\tbKeys.add(key);\n\t\t}\n\t\tif (aKeys.length !== bKeys.size) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (const key of aKeys) {\n\t\t\tif (a[key] !== b[key]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbKeys.delete(key);\n\t\t}\n\t\treturn bKeys.size === 0;\n\t}\n}\n\ninterface MessageBag {\n\t[key: string]: string | { message: string; comment: string[] };\n}\n\ninterface TranslationBundle {\n\tcontents: {\n\t\tpackage: MessageBag;\n\t};\n}\n\ninterface LocalizedMessages {\n\tvalues: MessageBag | undefined;\n\tdefault: URI | null;\n}\n\ninterface IBuiltInExtensionControl {\n\t[name: string]: 'marketplace' | 'disabled' | string;\n}\n\nexport type ScanOptions = {\n\treadonly profileLocation?: URI;\n\treadonly includeInvalid?: boolean;\n\treadonly includeAllVersions?: boolean;\n\treadonly includeUninstalled?: boolean;\n\treadonly checkControlFile?: boolean;\n\treadonly language?: string;\n\treadonly useCache?: boolean;\n\treadonly productVersion?: IProductVersion;\n};\n\nexport const IExtensionsScannerService = createDecorator<IExtensionsScannerService>('IExtensionsScannerService');\nexport interface IExtensionsScannerService {\n\treadonly _serviceBrand: undefined;\n\n\treadonly systemExtensionsLocation: URI;\n\treadonly userExtensionsLocation: URI;\n\treadonly onDidChangeCache: Event<ExtensionType>;\n\n\tgetTargetPlatform(): Promise<TargetPlatform>;\n\n\tscanAllExtensions(systemScanOptions: ScanOptions, userScanOptions: ScanOptions, includeExtensionsUnderDev: boolean): Promise<IScannedExtension[]>;\n\tscanSystemExtensions(scanOptions: ScanOptions): Promise<IScannedExtension[]>;\n\tscanUserExtensions(scanOptions: ScanOptions): Promise<IScannedExtension[]>;\n\tscanExtensionsUnderDevelopment(scanOptions: ScanOptions, existingExtensions: IScannedExtension[]): Promise<IScannedExtension[]>;\n\tscanExistingExtension(extensionLocation: URI, extensionType: ExtensionType, scanOptions: ScanOptions): Promise<IScannedExtension | null>;\n\tscanOneOrMultipleExtensions(extensionLocation: URI, extensionType: ExtensionType, scanOptions: ScanOptions): Promise<IScannedExtension[]>;\n\tscanMultipleExtensions(extensionLocations: URI[], extensionType: ExtensionType, scanOptions: ScanOptions): Promise<IScannedExtension[]>;\n\n\tscanMetadata(extensionLocation: URI): Promise<Metadata | undefined>;\n\tupdateMetadata(extensionLocation: URI, metadata: Partial<Metadata>): Promise<void>;\n\tinitializeDefaultProfileExtensions(): Promise<void>;\n}\n\nexport abstract class AbstractExtensionsScannerService extends Disposable implements IExtensionsScannerService {\n\n\treadonly _serviceBrand: undefined;\n\n\tprotected abstract getTranslations(language: string): Promise<Translations>;\n\n\tprivate readonly _onDidChangeCache = this._register(new Emitter<ExtensionType>());\n\treadonly onDidChangeCache = this._onDidChangeCache.event;\n\n\tprivate readonly obsoleteFile = joinPath(this.userExtensionsLocation, '.obsolete');\n\tprivate readonly systemExtensionsCachedScanner = this._register(this.instantiationService.createInstance(CachedExtensionsScanner, this.currentProfile, this.obsoleteFile));\n\tprivate readonly userExtensionsCachedScanner = this._register(this.instantiationService.createInstance(CachedExtensionsScanner, this.currentProfile, this.obsoleteFile));\n\tprivate readonly extensionsScanner = this._register(this.instantiationService.createInstance(ExtensionsScanner, this.obsoleteFile));\n\n\tconstructor(\n\t\treadonly systemExtensionsLocation: URI,\n\t\treadonly userExtensionsLocation: URI,\n\t\tprivate readonly extensionsControlLocation: URI,\n\t\tprivate readonly currentProfile: IUserDataProfile,\n\t\t@IUserDataProfilesService private readonly userDataProfilesService: IUserDataProfilesService,\n\t\t@IExtensionsProfileScannerService protected readonly extensionsProfileScannerService: IExtensionsProfileScannerService,\n\t\t@IFileService protected readonly fileService: IFileService,\n\t\t@ILogService protected readonly logService: ILogService,\n\t\t@IEnvironmentService private readonly environmentService: IEnvironmentService,\n\t\t@IProductService private readonly productService: IProductService,\n\t\t@IUriIdentityService private readonly uriIdentityService: IUriIdentityService,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService,\n\t) {\n\t\tsuper();\n\n\t\tthis._register(this.systemExtensionsCachedScanner.onDidChangeCache(() => this._onDidChangeCache.fire(ExtensionType.System)));\n\t\tthis._register(this.userExtensionsCachedScanner.onDidChangeCache(() => this._onDidChangeCache.fire(ExtensionType.User)));\n\t}\n\n\tprivate _targetPlatformPromise: Promise<TargetPlatform> | undefined;\n\tgetTargetPlatform(): Promise<TargetPlatform> {\n\t\tif (!this._targetPlatformPromise) {\n\t\t\tthis._targetPlatformPromise = computeTargetPlatform(this.fileService, this.logService);\n\t\t}\n\t\treturn this._targetPlatformPromise;\n\t}\n\n\tasync scanAllExtensions(systemScanOptions: ScanOptions, userScanOptions: ScanOptions, includeExtensionsUnderDev: boolean): Promise<IScannedExtension[]> {\n\t\tconst [system, user] = await Promise.all([\n\t\t\tthis.scanSystemExtensions(systemScanOptions),\n\t\t\tthis.scanUserExtensions(userScanOptions),\n\t\t]);\n\t\tconst development = includeExtensionsUnderDev ? await this.scanExtensionsUnderDevelopment(systemScanOptions, [...system, ...user]) : [];\n\t\treturn this.dedupExtensions(system, user, development, await this.getTargetPlatform(), true);\n\t}\n\n\tasync scanSystemExtensions(scanOptions: ScanOptions): Promise<IScannedExtension[]> {\n\t\tconst promises: Promise<IRelaxedScannedExtension[]>[] = [];\n\t\tpromises.push(this.scanDefaultSystemExtensions(!!scanOptions.useCache, scanOptions.language));\n\t\tpromises.push(this.scanDevSystemExtensions(scanOptions.language, !!scanOptions.checkControlFile));\n\t\tconst [defaultSystemExtensions, devSystemExtensions] = await Promise.all(promises);\n\t\treturn this.applyScanOptions([...defaultSystemExtensions, ...devSystemExtensions], ExtensionType.System, scanOptions, false);\n\t}\n\n\tasync scanUserExtensions(scanOptions: ScanOptions): Promise<IScannedExtension[]> {\n\t\tconst location = scanOptions.profileLocation ?? this.userExtensionsLocation;\n\t\tthis.logService.trace('Started scanning user extensions', location);\n\t\tconst profileScanOptions: IProfileExtensionsScanOptions | undefined = this.uriIdentityService.extUri.isEqual(scanOptions.profileLocation, this.userDataProfilesService.defaultProfile.extensionsResource) ? { bailOutWhenFileNotFound: true } : undefined;\n\t\tconst extensionsScannerInput = await this.createExtensionScannerInput(location, !!scanOptions.profileLocation, ExtensionType.User, !scanOptions.includeUninstalled, scanOptions.language, true, profileScanOptions, scanOptions.productVersion ?? this.getProductVersion());\n\t\tconst extensionsScanner = scanOptions.useCache && !extensionsScannerInput.devMode && extensionsScannerInput.excludeObsolete ? this.userExtensionsCachedScanner : this.extensionsScanner;\n\t\tlet extensions: IRelaxedScannedExtension[];\n\t\ttry {\n\t\t\textensions = await extensionsScanner.scanExtensions(extensionsScannerInput);\n\t\t} catch (error) {\n\t\t\tif (error instanceof ExtensionsProfileScanningError && error.code === ExtensionsProfileScanningErrorCode.ERROR_PROFILE_NOT_FOUND) {\n\t\t\t\tawait this.doInitializeDefaultProfileExtensions();\n\t\t\t\textensions = await extensionsScanner.scanExtensions(extensionsScannerInput);\n\t\t\t} else {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\t\textensions = await this.applyScanOptions(extensions, ExtensionType.User, scanOptions, true);\n\t\tthis.logService.trace('Scanned user extensions:', extensions.length);\n\t\treturn extensions;\n\t}\n\n\tasync scanExtensionsUnderDevelopment(scanOptions: ScanOptions, existingExtensions: IScannedExtension[]): Promise<IScannedExtension[]> {\n\t\tif (this.environmentService.isExtensionDevelopment && this.environmentService.extensionDevelopmentLocationURI) {\n\t\t\tconst extensions = (await Promise.all(this.environmentService.extensionDevelopmentLocationURI.filter(extLoc => extLoc.scheme === Schemas.file)\n\t\t\t\t.map(async extensionDevelopmentLocationURI => {\n\t\t\t\t\tconst input = await this.createExtensionScannerInput(extensionDevelopmentLocationURI, false, ExtensionType.User, true, scanOptions.language, false /* do not validate */, undefined, scanOptions.productVersion ?? this.getProductVersion());\n\t\t\t\t\tconst extensions = await this.extensionsScanner.scanOneOrMultipleExtensions(input);\n\t\t\t\t\treturn extensions.map(extension => {\n\t\t\t\t\t\t// Override the extension type from the existing extensions\n\t\t\t\t\t\textension.type = existingExtensions.find(e => areSameExtensions(e.identifier, extension.identifier))?.type ?? extension.type;\n\t\t\t\t\t\t// Validate the extension\n\t\t\t\t\t\treturn this.extensionsScanner.validate(extension, input);\n\t\t\t\t\t});\n\t\t\t\t})))\n\t\t\t\t.flat();\n\t\t\treturn this.applyScanOptions(extensions, 'development', scanOptions, true);\n\t\t}\n\t\treturn [];\n\t}\n\n\tasync scanExistingExtension(extensionLocation: URI, extensionType: ExtensionType, scanOptions: ScanOptions): Promise<IScannedExtension | null> {\n\t\tconst extensionsScannerInput = await this.createExtensionScannerInput(extensionLocation, false, extensionType, true, scanOptions.language, true, undefined, scanOptions.productVersion ?? this.getProductVersion());\n\t\tconst extension = await this.extensionsScanner.scanExtension(extensionsScannerInput);\n\t\tif (!extension) {\n\t\t\treturn null;\n\t\t}\n\t\tif (!scanOptions.includeInvalid && !extension.isValid) {\n\t\t\treturn null;\n\t\t}\n\t\treturn extension;\n\t}\n\n\tasync scanOneOrMultipleExtensions(extensionLocation: URI, extensionType: ExtensionType, scanOptions: ScanOptions): Promise<IScannedExtension[]> {\n\t\tconst extensionsScannerInput = await this.createExtensionScannerInput(extensionLocation, false, extensionType, true, scanOptions.language, true, undefined, scanOptions.productVersion ?? this.getProductVersion());\n\t\tconst extensions = await this.extensionsScanner.scanOneOrMultipleExtensions(extensionsScannerInput);\n\t\treturn this.applyScanOptions(extensions, extensionType, scanOptions, true);\n\t}\n\n\tasync scanMultipleExtensions(extensionLocations: URI[], extensionType: ExtensionType, scanOptions: ScanOptions): Promise<IScannedExtension[]> {\n\t\tconst extensions: IRelaxedScannedExtension[] = [];\n\t\tawait Promise.all(extensionLocations.map(async extensionLocation => {\n\t\t\tconst scannedExtensions = await this.scanOneOrMultipleExtensions(extensionLocation, extensionType, scanOptions);\n\t\t\textensions.push(...scannedExtensions);\n\t\t}));\n\t\treturn this.applyScanOptions(extensions, extensionType, scanOptions, true);\n\t}\n\n\tasync scanMetadata(extensionLocation: URI): Promise<Metadata | undefined> {\n\t\tconst manifestLocation = joinPath(extensionLocation, 'package.json');\n\t\tconst content = (await this.fileService.readFile(manifestLocation)).value.toString();\n\t\tconst manifest: IScannedExtensionManifest = JSON.parse(content);\n\t\treturn manifest.__metadata;\n\t}\n\n\tasync updateMetadata(extensionLocation: URI, metaData: Partial<Metadata>): Promise<void> {\n\t\tconst manifestLocation = joinPath(extensionLocation, 'package.json');\n\t\tconst content = (await this.fileService.readFile(manifestLocation)).value.toString();\n\t\tconst manifest: IScannedExtensionManifest = JSON.parse(content);\n\n\t\t// unset if false\n\t\tif (metaData.isMachineScoped === false) {\n\t\t\tdelete metaData.isMachineScoped;\n\t\t}\n\t\tif (metaData.isBuiltin === false) {\n\t\t\tdelete metaData.isBuiltin;\n\t\t}\n\t\tmanifest.__metadata = { ...manifest.__metadata, ...metaData };\n\n\t\tawait this.fileService.writeFile(joinPath(extensionLocation, 'package.json'), VSBuffer.fromString(JSON.stringify(manifest, null, '\\t')));\n\t}\n\n\tasync initializeDefaultProfileExtensions(): Promise<void> {\n\t\ttry {\n\t\t\tawait this.extensionsProfileScannerService.scanProfileExtensions(this.userDataProfilesService.defaultProfile.extensionsResource, { bailOutWhenFileNotFound: true });\n\t\t} catch (error) {\n\t\t\tif (error instanceof ExtensionsProfileScanningError && error.code === ExtensionsProfileScanningErrorCode.ERROR_PROFILE_NOT_FOUND) {\n\t\t\t\tawait this.doInitializeDefaultProfileExtensions();\n\t\t\t} else {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate initializeDefaultProfileExtensionsPromise: Promise<void> | undefined = undefined;\n\tprivate async doInitializeDefaultProfileExtensions(): Promise<void> {\n\t\tif (!this.initializeDefaultProfileExtensionsPromise) {\n\t\t\tthis.initializeDefaultProfileExtensionsPromise = (async () => {\n\t\t\t\ttry {\n\t\t\t\t\tthis.logService.info('Started initializing default profile extensions in extensions installation folder.', this.userExtensionsLocation.toString());\n\t\t\t\t\tconst userExtensions = await this.scanUserExtensions({ includeInvalid: true });\n\t\t\t\t\tif (userExtensions.length) {\n\t\t\t\t\t\tawait this.extensionsProfileScannerService.addExtensionsToProfile(userExtensions.map(e => [e, e.metadata]), this.userDataProfilesService.defaultProfile.extensionsResource);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait this.fileService.createFile(this.userDataProfilesService.defaultProfile.extensionsResource, VSBuffer.fromString(JSON.stringify([])));\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tif (toFileOperationResult(error) !== FileOperationResult.FILE_NOT_FOUND) {\n\t\t\t\t\t\t\t\tthis.logService.warn('Failed to create default profile extensions manifest in extensions installation folder.', this.userExtensionsLocation.toString(), getErrorMessage(error));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.logService.info('Completed initializing default profile extensions in extensions installation folder.', this.userExtensionsLocation.toString());\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.logService.error(error);\n\t\t\t\t} finally {\n\t\t\t\t\tthis.initializeDefaultProfileExtensionsPromise = undefined;\n\t\t\t\t}\n\t\t\t})();\n\t\t}\n\t\treturn this.initializeDefaultProfileExtensionsPromise;\n\t}\n\n\tprivate async applyScanOptions(extensions: IRelaxedScannedExtension[], type: ExtensionType | 'development', scanOptions: ScanOptions, pickLatest: boolean): Promise<IRelaxedScannedExtension[]> {\n\t\tif (!scanOptions.includeAllVersions) {\n\t\t\textensions = this.dedupExtensions(type === ExtensionType.System ? extensions : undefined, type === ExtensionType.User ? extensions : undefined, type === 'development' ? extensions : undefined, await this.getTargetPlatform(), pickLatest);\n\t\t}\n\t\tif (!scanOptions.includeInvalid) {\n\t\t\textensions = extensions.filter(extension => extension.isValid);\n\t\t}\n\t\treturn extensions.sort((a, b) => {\n\t\t\tconst aLastSegment = path.basename(a.location.fsPath);\n\t\t\tconst bLastSegment = path.basename(b.location.fsPath);\n\t\t\tif (aLastSegment < bLastSegment) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (aLastSegment > bLastSegment) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t});\n\t}\n\n\tprivate dedupExtensions(system: IScannedExtension[] | undefined, user: IScannedExtension[] | undefined, development: IScannedExtension[] | undefined, targetPlatform: TargetPlatform, pickLatest: boolean): IScannedExtension[] {\n\t\tconst pick = (existing: IScannedExtension, extension: IScannedExtension, isDevelopment: boolean): boolean => {\n\t\t\tif (existing.isValid && !extension.isValid) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (existing.isValid === extension.isValid) {\n\t\t\t\tif (pickLatest && semver.gt(existing.manifest.version, extension.manifest.version)) {\n\t\t\t\t\tthis.logService.debug(`Skipping extension ${extension.location.path} with lower version ${extension.manifest.version} in favour of ${existing.location.path} with version ${existing.manifest.version}`);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (semver.eq(existing.manifest.version, extension.manifest.version)) {\n\t\t\t\t\tif (existing.type === ExtensionType.System) {\n\t\t\t\t\t\tthis.logService.debug(`Skipping extension ${extension.location.path} in favour of system extension ${existing.location.path} with same version`);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (existing.targetPlatform === targetPlatform) {\n\t\t\t\t\t\tthis.logService.debug(`Skipping extension ${extension.location.path} from different target platform ${extension.targetPlatform}`);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isDevelopment) {\n\t\t\t\tthis.logService.warn(`Overwriting user extension ${existing.location.path} with ${extension.location.path}.`);\n\t\t\t} else {\n\t\t\t\tthis.logService.debug(`Overwriting user extension ${existing.location.path} with ${extension.location.path}.`);\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t\tconst result = new ExtensionIdentifierMap<IScannedExtension>();\n\t\tsystem?.forEach((extension) => {\n\t\t\tconst existing = result.get(extension.identifier.id);\n\t\t\tif (!existing || pick(existing, extension, false)) {\n\t\t\t\tresult.set(extension.identifier.id, extension);\n\t\t\t}\n\t\t});\n\t\tuser?.forEach((extension) => {\n\t\t\tconst existing = result.get(extension.identifier.id);\n\t\t\tif (!existing && system && extension.type === ExtensionType.System) {\n\t\t\t\tthis.logService.debug(`Skipping obsolete system extension ${extension.location.path}.`);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!existing || pick(existing, extension, false)) {\n\t\t\t\tresult.set(extension.identifier.id, extension);\n\t\t\t}\n\t\t});\n\t\tdevelopment?.forEach(extension => {\n\t\t\tconst existing = result.get(extension.identifier.id);\n\t\t\tif (!existing || pick(existing, extension, true)) {\n\t\t\t\tresult.set(extension.identifier.id, extension);\n\t\t\t}\n\t\t\tresult.set(extension.identifier.id, extension);\n\t\t});\n\t\treturn [...result.values()];\n\t}\n\n\tprivate async scanDefaultSystemExtensions(useCache: boolean, language: string | undefined): Promise<IRelaxedScannedExtension[]> {\n\t\tthis.logService.trace('Started scanning system extensions');\n\t\tconst extensionsScannerInput = await this.createExtensionScannerInput(this.systemExtensionsLocation, false, ExtensionType.System, true, language, true, undefined, this.getProductVersion());\n\t\tconst extensionsScanner = useCache && !extensionsScannerInput.devMode ? this.systemExtensionsCachedScanner : this.extensionsScanner;\n\t\tconst result = await extensionsScanner.scanExtensions(extensionsScannerInput);\n\t\tthis.logService.trace('Scanned system extensions:', result.length);\n\t\treturn result;\n\t}\n\n\tprivate async scanDevSystemExtensions(language: string | undefined, checkControlFile: boolean): Promise<IRelaxedScannedExtension[]> {\n\t\tconst devSystemExtensionsList = this.environmentService.isBuilt ? [] : this.productService.builtInExtensions;\n\t\tif (!devSystemExtensionsList?.length) {\n\t\t\treturn [];\n\t\t}\n\n\t\tthis.logService.trace('Started scanning dev system extensions');\n\t\tconst builtinExtensionControl = checkControlFile ? await this.getBuiltInExtensionControl() : {};\n\t\tconst devSystemExtensionsLocations: URI[] = [];\n\t\tconst devSystemExtensionsLocation = URI.file(path.normalize(path.join(FileAccess.asFileUri('').fsPath, '..', '.build', 'builtInExtensions')));\n\t\tfor (const extension of devSystemExtensionsList) {\n\t\t\tconst controlState = builtinExtensionControl[extension.name] || 'marketplace';\n\t\t\tswitch (controlState) {\n\t\t\t\tcase 'disabled':\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'marketplace':\n\t\t\t\t\tdevSystemExtensionsLocations.push(joinPath(devSystemExtensionsLocation, extension.name));\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tdevSystemExtensionsLocations.push(URI.file(controlState));\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst result = await Promise.all(devSystemExtensionsLocations.map(async location => this.extensionsScanner.scanExtension((await this.createExtensionScannerInput(location, false, ExtensionType.System, true, language, true, undefined, this.getProductVersion())))));\n\t\tthis.logService.trace('Scanned dev system extensions:', result.length);\n\t\treturn coalesce(result);\n\t}\n\n\tprivate async getBuiltInExtensionControl(): Promise<IBuiltInExtensionControl> {\n\t\ttry {\n\t\t\tconst content = await this.fileService.readFile(this.extensionsControlLocation);\n\t\t\treturn JSON.parse(content.value.toString());\n\t\t} catch (error) {\n\t\t\treturn {};\n\t\t}\n\t}\n\n\tprivate async createExtensionScannerInput(location: URI, profile: boolean, type: ExtensionType, excludeObsolete: boolean, language: string | undefined, validate: boolean, profileScanOptions: IProfileExtensionsScanOptions | undefined, productVersion: IProductVersion): Promise<ExtensionScannerInput> {\n\t\tconst translations = await this.getTranslations(language ?? platform.language);\n\t\tconst mtime = await this.getMtime(location);\n\t\tconst applicationExtensionsLocation = profile && !this.uriIdentityService.extUri.isEqual(location, this.userDataProfilesService.defaultProfile.extensionsResource) ? this.userDataProfilesService.defaultProfile.extensionsResource : undefined;\n\t\tconst applicationExtensionsLocationMtime = applicationExtensionsLocation ? await this.getMtime(applicationExtensionsLocation) : undefined;\n\t\treturn new ExtensionScannerInput(\n\t\t\tlocation,\n\t\t\tmtime,\n\t\t\tapplicationExtensionsLocation,\n\t\t\tapplicationExtensionsLocationMtime,\n\t\t\tprofile,\n\t\t\tprofileScanOptions,\n\t\t\ttype,\n\t\t\texcludeObsolete,\n\t\t\tvalidate,\n\t\t\tproductVersion.version,\n\t\t\tproductVersion.date,\n\t\t\tthis.productService.commit,\n\t\t\t!this.environmentService.isBuilt,\n\t\t\tlanguage,\n\t\t\ttranslations,\n\t\t);\n\t}\n\n\tprivate async getMtime(location: URI): Promise<number | undefined> {\n\t\ttry {\n\t\t\tconst stat = await this.fileService.stat(location);\n\t\t\tif (typeof stat.mtime === 'number') {\n\t\t\t\treturn stat.mtime;\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t// That's ok...\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tprivate getProductVersion(): IProductVersion {\n\t\treturn {\n\t\t\tversion: this.productService.version,\n\t\t\tdate: this.productService.date,\n\t\t};\n\t}\n\n}\n\nexport class ExtensionScannerInput {\n\n\tconstructor(\n\t\tpublic readonly location: URI,\n\t\tpublic readonly mtime: number | undefined,\n\t\tpublic readonly applicationExtensionslocation: URI | undefined,\n\t\tpublic readonly applicationExtensionslocationMtime: number | undefined,\n\t\tpublic readonly profile: boolean,\n\t\tpublic readonly profileScanOptions: IProfileExtensionsScanOptions | undefined,\n\t\tpublic readonly type: ExtensionType,\n\t\tpublic readonly excludeObsolete: boolean,\n\t\tpublic readonly validate: boolean,\n\t\tpublic readonly productVersion: string,\n\t\tpublic readonly productDate: string | undefined,\n\t\tpublic readonly productCommit: string | undefined,\n\t\tpublic readonly devMode: boolean,\n\t\tpublic readonly language: string | undefined,\n\t\tpublic readonly translations: Translations\n\t) {\n\t\t// Keep empty!! (JSON.parse)\n\t}\n\n\tpublic static createNlsConfiguration(input: ExtensionScannerInput): NlsConfiguration {\n\t\treturn {\n\t\t\tlanguage: input.language,\n\t\t\tpseudo: input.language === 'pseudo',\n\t\t\tdevMode: input.devMode,\n\t\t\ttranslations: input.translations\n\t\t};\n\t}\n\n\tpublic static equals(a: ExtensionScannerInput, b: ExtensionScannerInput): boolean {\n\t\treturn (\n\t\t\tisEqual(a.location, b.location)\n\t\t\t&& a.mtime === b.mtime\n\t\t\t&& isEqual(a.applicationExtensionslocation, b.applicationExtensionslocation)\n\t\t\t&& a.applicationExtensionslocationMtime === b.applicationExtensionslocationMtime\n\t\t\t&& a.profile === b.profile\n\t\t\t&& objects.equals(a.profileScanOptions, b.profileScanOptions)\n\t\t\t&& a.type === b.type\n\t\t\t&& a.excludeObsolete === b.excludeObsolete\n\t\t\t&& a.validate === b.validate\n\t\t\t&& a.productVersion === b.productVersion\n\t\t\t&& a.productDate === b.productDate\n\t\t\t&& a.productCommit === b.productCommit\n\t\t\t&& a.devMode === b.devMode\n\t\t\t&& a.language === b.language\n\t\t\t&& Translations.equals(a.translations, b.translations)\n\t\t);\n\t}\n}\n\ntype NlsConfiguration = {\n\tlanguage: string | undefined;\n\tpseudo: boolean;\n\tdevMode: boolean;\n\ttranslations: Translations;\n};\n\nclass ExtensionsScanner extends Disposable {\n\n\tprivate readonly extensionsEnabledWithApiProposalVersion: string[];\n\n\tconstructor(\n\t\tprivate readonly obsoleteFile: URI,\n\t\t@IExtensionsProfileScannerService protected readonly extensionsProfileScannerService: IExtensionsProfileScannerService,\n\t\t@IUriIdentityService protected readonly uriIdentityService: IUriIdentityService,\n\t\t@IFileService protected readonly fileService: IFileService,\n\t\t@IProductService productService: IProductService,\n\t\t@IEnvironmentService private readonly environmentService: IEnvironmentService,\n\t\t@ILogService protected readonly logService: ILogService\n\t) {\n\t\tsuper();\n\t\tthis.extensionsEnabledWithApiProposalVersion = productService.extensionsEnabledWithApiProposalVersion?.map(id => id.toLowerCase()) ?? [];\n\t}\n\n\tasync scanExtensions(input: ExtensionScannerInput): Promise<IRelaxedScannedExtension[]> {\n\t\tconst extensions = input.profile ? await this.scanExtensionsFromProfile(input) : await this.scanExtensionsFromLocation(input);\n\t\tlet obsolete: IStringDictionary<boolean> = {};\n\t\tif (input.excludeObsolete && input.type === ExtensionType.User) {\n\t\t\ttry {\n\t\t\t\tconst raw = (await this.fileService.readFile(this.obsoleteFile)).value.toString();\n\t\t\t\tobsolete = JSON.parse(raw);\n\t\t\t} catch (error) { /* ignore */ }\n\t\t}\n\t\treturn isEmptyObject(obsolete) ? extensions : extensions.filter(e => !obsolete[ExtensionKey.create(e).toString()]);\n\t}\n\n\tprivate async scanExtensionsFromLocation(input: ExtensionScannerInput): Promise<IRelaxedScannedExtension[]> {\n\t\tconst stat = await this.fileService.resolve(input.location);\n\t\tif (!stat.children?.length) {\n\t\t\treturn [];\n\t\t}\n\t\tconst extensions = await Promise.all<IRelaxedScannedExtension | null>(\n\t\t\tstat.children.map(async c => {\n\t\t\t\tif (!c.isDirectory) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t// Do not consider user extension folder starting with `.`\n\t\t\t\tif (input.type === ExtensionType.User && basename(c.resource).indexOf('.') === 0) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tconst extensionScannerInput = new ExtensionScannerInput(c.resource, input.mtime, input.applicationExtensionslocation, input.applicationExtensionslocationMtime, input.profile, input.profileScanOptions, input.type, input.excludeObsolete, input.validate, input.productVersion, input.productDate, input.productCommit, input.devMode, input.language, input.translations);\n\t\t\t\treturn this.scanExtension(extensionScannerInput);\n\t\t\t}));\n\t\treturn coalesce(extensions)\n\t\t\t// Sort: Make sure extensions are in the same order always. Helps cache invalidation even if the order changes.\n\t\t\t.sort((a, b) => a.location.path < b.location.path ? -1 : 1);\n\t}\n\n\tprivate async scanExtensionsFromProfile(input: ExtensionScannerInput): Promise<IRelaxedScannedExtension[]> {\n\t\tlet profileExtensions = await this.scanExtensionsFromProfileResource(input.location, () => true, input);\n\t\tif (input.applicationExtensionslocation && !this.uriIdentityService.extUri.isEqual(input.location, input.applicationExtensionslocation)) {\n\t\t\tprofileExtensions = profileExtensions.filter(e => !e.metadata?.isApplicationScoped);\n\t\t\tconst applicationExtensions = await this.scanExtensionsFromProfileResource(input.applicationExtensionslocation, (e) => !!e.metadata?.isBuiltin || !!e.metadata?.isApplicationScoped, input);\n\t\t\tprofileExtensions.push(...applicationExtensions);\n\t\t}\n\t\treturn profileExtensions;\n\t}\n\n\tprivate async scanExtensionsFromProfileResource(profileResource: URI, filter: (extensionInfo: IScannedProfileExtension) => boolean, input: ExtensionScannerInput): Promise<IRelaxedScannedExtension[]> {\n\t\tconst scannedProfileExtensions = await this.extensionsProfileScannerService.scanProfileExtensions(profileResource, input.profileScanOptions);\n\t\tif (!scannedProfileExtensions.length) {\n\t\t\treturn [];\n\t\t}\n\t\tconst extensions = await Promise.all<IRelaxedScannedExtension | null>(\n\t\t\tscannedProfileExtensions.map(async extensionInfo => {\n\t\t\t\tif (filter(extensionInfo)) {\n\t\t\t\t\tconst extensionScannerInput = new ExtensionScannerInput(extensionInfo.location, input.mtime, input.applicationExtensionslocation, input.applicationExtensionslocationMtime, input.profile, input.profileScanOptions, input.type, input.excludeObsolete, input.validate, input.productVersion, input.productDate, input.productCommit, input.devMode, input.language, input.translations);\n\t\t\t\t\treturn this.scanExtension(extensionScannerInput, extensionInfo.metadata);\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}));\n\t\treturn coalesce(extensions);\n\t}\n\n\tasync scanOneOrMultipleExtensions(input: ExtensionScannerInput): Promise<IRelaxedScannedExtension[]> {\n\t\ttry {\n\t\t\tif (await this.fileService.exists(joinPath(input.location, 'package.json'))) {\n\t\t\t\tconst extension = await this.scanExtension(input);\n\t\t\t\treturn extension ? [extension] : [];\n\t\t\t} else {\n\t\t\t\treturn await this.scanExtensions(input);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.logService.error(`Error scanning extensions at ${input.location.path}:`, getErrorMessage(error));\n\t\t\treturn [];\n\t\t}\n\t}\n\n\tasync scanExtension(input: ExtensionScannerInput, metadata?: Metadata): Promise<IRelaxedScannedExtension | null> {\n\t\ttry {\n\t\t\tlet manifest = await this.scanExtensionManifest(input.location);\n\t\t\tif (manifest) {\n\t\t\t\t// allow publisher to be undefined to make the initial extension authoring experience smoother\n\t\t\t\tif (!manifest.publisher) {\n\t\t\t\t\tmanifest.publisher = UNDEFINED_PUBLISHER;\n\t\t\t\t}\n\t\t\t\tmetadata = metadata ?? manifest.__metadata;\n\t\t\t\tdelete manifest.__metadata;\n\t\t\t\tconst id = getGalleryExtensionId(manifest.publisher, manifest.name);\n\t\t\t\tconst identifier = metadata?.id ? { id, uuid: metadata.id } : { id };\n\t\t\t\tconst type = metadata?.isSystem ? ExtensionType.System : input.type;\n\t\t\t\tconst isBuiltin = type === ExtensionType.System || !!metadata?.isBuiltin;\n\t\t\t\tmanifest = await this.translateManifest(input.location, manifest, ExtensionScannerInput.createNlsConfiguration(input));\n\t\t\t\tlet extension: IRelaxedScannedExtension = {\n\t\t\t\t\ttype,\n\t\t\t\t\tidentifier,\n\t\t\t\t\tmanifest,\n\t\t\t\t\tlocation: input.location,\n\t\t\t\t\tisBuiltin,\n\t\t\t\t\ttargetPlatform: metadata?.targetPlatform ?? TargetPlatform.UNDEFINED,\n\t\t\t\t\tpublisherDisplayName: metadata?.publisherDisplayName,\n\t\t\t\t\tmetadata,\n\t\t\t\t\tisValid: true,\n\t\t\t\t\tvalidations: []\n\t\t\t\t};\n\t\t\t\tif (input.validate) {\n\t\t\t\t\textension = this.validate(extension, input);\n\t\t\t\t}\n\t\t\t\tif (manifest.enabledApiProposals && (!this.environmentService.isBuilt || this.extensionsEnabledWithApiProposalVersion.includes(id.toLowerCase()))) {\n\t\t\t\t\tmanifest.originalEnabledApiProposals = manifest.enabledApiProposals;\n\t\t\t\t\tmanifest.enabledApiProposals = parseEnabledApiProposalNames([...manifest.enabledApiProposals]);\n\t\t\t\t}\n\t\t\t\treturn extension;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tif (input.type !== ExtensionType.System) {\n\t\t\t\tthis.logService.error(e);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tvalidate(extension: IRelaxedScannedExtension, input: ExtensionScannerInput): IRelaxedScannedExtension {\n\t\tlet isValid = true;\n\t\t// const validateApiVersion = this.environmentService.isBuilt && this.extensionsEnabledWithApiProposalVersion.includes(extension.identifier.id.toLowerCase());\n\t\tconst validations = validateExtensionManifest(input.productVersion, input.productDate, input.location, extension.manifest, extension.isBuiltin, true);\n\t\tfor (const [severity, message] of validations) {\n\t\t\tif (severity === Severity.Error) {\n\t\t\t\tisValid = false;\n\t\t\t\tthis.logService.error(this.formatMessage(input.location, message));\n\t\t\t}\n\t\t}\n\t\textension.isValid = isValid;\n\t\textension.validations = validations;\n\t\treturn extension;\n\t}\n\n\tprivate async scanExtensionManifest(extensionLocation: URI): Promise<IScannedExtensionManifest | null> {\n\t\tconst manifestLocation = joinPath(extensionLocation, 'package.json');\n\t\tlet content;\n\t\ttry {\n\t\t\tcontent = (await this.fileService.readFile(manifestLocation)).value.toString();\n\t\t} catch (error) {\n\t\t\tif (toFileOperationResult(error) !== FileOperationResult.FILE_NOT_FOUND) {\n\t\t\t\tthis.logService.error(this.formatMessage(extensionLocation, localize('fileReadFail', \"Cannot read file {0}: {1}.\", manifestLocation.path, error.message)));\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tlet manifest: IScannedExtensionManifest;\n\t\ttry {\n\t\t\tmanifest = JSON.parse(content);\n\t\t} catch (err) {\n\t\t\t// invalid JSON, let's get good errors\n\t\t\tconst errors: ParseError[] = [];\n\t\t\tparse(content, errors);\n\t\t\tfor (const e of errors) {\n\t\t\t\tthis.logService.error(this.formatMessage(extensionLocation, localize('jsonParseFail', \"Failed to parse {0}: [{1}, {2}] {3}.\", manifestLocation.path, e.offset, e.length, getParseErrorMessage(e.error))));\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tif (getNodeType(manifest) !== 'object') {\n\t\t\tthis.logService.error(this.formatMessage(extensionLocation, localize('jsonParseInvalidType', \"Invalid manifest file {0}: Not a JSON object.\", manifestLocation.path)));\n\t\t\treturn null;\n\t\t}\n\t\treturn manifest;\n\t}\n\n\tprivate async translateManifest(extensionLocation: URI, extensionManifest: IExtensionManifest, nlsConfiguration: NlsConfiguration): Promise<IExtensionManifest> {\n\t\tconst localizedMessages = await this.getLocalizedMessages(extensionLocation, extensionManifest, nlsConfiguration);\n\t\tif (localizedMessages) {\n\t\t\ttry {\n\t\t\t\tconst errors: ParseError[] = [];\n\t\t\t\t// resolveOriginalMessageBundle returns null if localizedMessages.default === undefined;\n\t\t\t\tconst defaults = await this.resolveOriginalMessageBundle(localizedMessages.default, errors);\n\t\t\t\tif (errors.length > 0) {\n\t\t\t\t\terrors.forEach((error) => {\n\t\t\t\t\t\tthis.logService.error(this.formatMessage(extensionLocation, localize('jsonsParseReportErrors', \"Failed to parse {0}: {1}.\", localizedMessages.default?.path, getParseErrorMessage(error.error))));\n\t\t\t\t\t});\n\t\t\t\t\treturn extensionManifest;\n\t\t\t\t} else if (getNodeType(localizedMessages) !== 'object') {\n\t\t\t\t\tthis.logService.error(this.formatMessage(extensionLocation, localize('jsonInvalidFormat', \"Invalid format {0}: JSON object expected.\", localizedMessages.default?.path)));\n\t\t\t\t\treturn extensionManifest;\n\t\t\t\t}\n\t\t\t\tconst localized = localizedMessages.values || Object.create(null);\n\t\t\t\treturn localizeManifest(this.logService, extensionManifest, localized, defaults);\n\t\t\t} catch (error) {\n\t\t\t\t/*Ignore Error*/\n\t\t\t}\n\t\t}\n\t\treturn extensionManifest;\n\t}\n\n\tprivate async getLocalizedMessages(extensionLocation: URI, extensionManifest: IExtensionManifest, nlsConfiguration: NlsConfiguration): Promise<LocalizedMessages | undefined> {\n\t\tconst defaultPackageNLS = joinPath(extensionLocation, 'package.nls.json');\n\t\tconst reportErrors = (localized: URI | null, errors: ParseError[]): void => {\n\t\t\terrors.forEach((error) => {\n\t\t\t\tthis.logService.error(this.formatMessage(extensionLocation, localize('jsonsParseReportErrors', \"Failed to parse {0}: {1}.\", localized?.path, getParseErrorMessage(error.error))));\n\t\t\t});\n\t\t};\n\t\tconst reportInvalidFormat = (localized: URI | null): void => {\n\t\t\tthis.logService.error(this.formatMessage(extensionLocation, localize('jsonInvalidFormat', \"Invalid format {0}: JSON object expected.\", localized?.path)));\n\t\t};\n\n\t\tconst translationId = `${extensionManifest.publisher}.${extensionManifest.name}`;\n\t\tconst translationPath = nlsConfiguration.translations[translationId];\n\n\t\tif (translationPath) {\n\t\t\ttry {\n\t\t\t\tconst translationResource = URI.file(translationPath);\n\t\t\t\tconst content = (await this.fileService.readFile(translationResource)).value.toString();\n\t\t\t\tconst errors: ParseError[] = [];\n\t\t\t\tconst translationBundle: TranslationBundle = parse(content, errors);\n\t\t\t\tif (errors.length > 0) {\n\t\t\t\t\treportErrors(translationResource, errors);\n\t\t\t\t\treturn { values: undefined, default: defaultPackageNLS };\n\t\t\t\t} else if (getNodeType(translationBundle) !== 'object') {\n\t\t\t\t\treportInvalidFormat(translationResource);\n\t\t\t\t\treturn { values: undefined, default: defaultPackageNLS };\n\t\t\t\t} else {\n\t\t\t\t\tconst values = translationBundle.contents ? translationBundle.contents.package : undefined;\n\t\t\t\t\treturn { values: values, default: defaultPackageNLS };\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\treturn { values: undefined, default: defaultPackageNLS };\n\t\t\t}\n\t\t} else {\n\t\t\tconst exists = await this.fileService.exists(defaultPackageNLS);\n\t\t\tif (!exists) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tlet messageBundle;\n\t\t\ttry {\n\t\t\t\tmessageBundle = await this.findMessageBundles(extensionLocation, nlsConfiguration);\n\t\t\t} catch (error) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tif (!messageBundle.localized) {\n\t\t\t\treturn { values: undefined, default: messageBundle.original };\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tconst messageBundleContent = (await this.fileService.readFile(messageBundle.localized)).value.toString();\n\t\t\t\tconst errors: ParseError[] = [];\n\t\t\t\tconst messages: MessageBag = parse(messageBundleContent, errors);\n\t\t\t\tif (errors.length > 0) {\n\t\t\t\t\treportErrors(messageBundle.localized, errors);\n\t\t\t\t\treturn { values: undefined, default: messageBundle.original };\n\t\t\t\t} else if (getNodeType(messages) !== 'object') {\n\t\t\t\t\treportInvalidFormat(messageBundle.localized);\n\t\t\t\t\treturn { values: undefined, default: messageBundle.original };\n\t\t\t\t}\n\t\t\t\treturn { values: messages, default: messageBundle.original };\n\t\t\t} catch (error) {\n\t\t\t\treturn { values: undefined, default: messageBundle.original };\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Parses original message bundle, returns null if the original message bundle is null.\n\t */\n\tprivate async resolveOriginalMessageBundle(originalMessageBundle: URI | null, errors: ParseError[]): Promise<{ [key: string]: string } | undefined> {\n\t\tif (originalMessageBundle) {\n\t\t\ttry {\n\t\t\t\tconst originalBundleContent = (await this.fileService.readFile(originalMessageBundle)).value.toString();\n\t\t\t\treturn parse(originalBundleContent, errors);\n\t\t\t} catch (error) {\n\t\t\t\t/* Ignore Error */\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\t/**\n\t * Finds localized message bundle and the original (unlocalized) one.\n\t * If the localized file is not present, returns null for the original and marks original as localized.\n\t */\n\tprivate findMessageBundles(extensionLocation: URI, nlsConfiguration: NlsConfiguration): Promise<{ localized: URI; original: URI | null }> {\n\t\treturn new Promise<{ localized: URI; original: URI | null }>((c, e) => {\n\t\t\tconst loop = (locale: string): void => {\n\t\t\t\tconst toCheck = joinPath(extensionLocation, `package.nls.${locale}.json`);\n\t\t\t\tthis.fileService.exists(toCheck).then(exists => {\n\t\t\t\t\tif (exists) {\n\t\t\t\t\t\tc({ localized: toCheck, original: joinPath(extensionLocation, 'package.nls.json') });\n\t\t\t\t\t}\n\t\t\t\t\tconst index = locale.lastIndexOf('-');\n\t\t\t\t\tif (index === -1) {\n\t\t\t\t\t\tc({ localized: joinPath(extensionLocation, 'package.nls.json'), original: null });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlocale = locale.substring(0, index);\n\t\t\t\t\t\tloop(locale);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\t\tif (nlsConfiguration.devMode || nlsConfiguration.pseudo || !nlsConfiguration.language) {\n\t\t\t\treturn c({ localized: joinPath(extensionLocation, 'package.nls.json'), original: null });\n\t\t\t}\n\t\t\tloop(nlsConfiguration.language);\n\t\t});\n\t}\n\n\tprivate formatMessage(extensionLocation: URI, message: string): string {\n\t\treturn `[${extensionLocation.path}]: ${message}`;\n\t}\n\n}\n\ninterface IExtensionCacheData {\n\tinput: ExtensionScannerInput;\n\tresult: IRelaxedScannedExtension[];\n}\n\nclass CachedExtensionsScanner extends ExtensionsScanner {\n\n\tprivate input: ExtensionScannerInput | undefined;\n\tprivate readonly cacheValidatorThrottler: ThrottledDelayer<void> = this._register(new ThrottledDelayer(3000));\n\n\tprivate readonly _onDidChangeCache = this._register(new Emitter<void>());\n\treadonly onDidChangeCache = this._onDidChangeCache.event;\n\n\tconstructor(\n\t\tprivate readonly currentProfile: IUserDataProfile,\n\t\tobsoleteFile: URI,\n\t\t@IUserDataProfilesService private readonly userDataProfilesService: IUserDataProfilesService,\n\t\t@IExtensionsProfileScannerService extensionsProfileScannerService: IExtensionsProfileScannerService,\n\t\t@IUriIdentityService uriIdentityService: IUriIdentityService,\n\t\t@IFileService fileService: IFileService,\n\t\t@IProductService productService: IProductService,\n\t\t@IEnvironmentService environmentService: IEnvironmentService,\n\t\t@ILogService logService: ILogService\n\t) {\n\t\tsuper(obsoleteFile, extensionsProfileScannerService, uriIdentityService, fileService, productService, environmentService, logService);\n\t}\n\n\toverride async scanExtensions(input: ExtensionScannerInput): Promise<IRelaxedScannedExtension[]> {\n\t\tconst cacheFile = this.getCacheFile(input);\n\t\tconst cacheContents = await this.readExtensionCache(cacheFile);\n\t\tthis.input = input;\n\t\tif (cacheContents && cacheContents.input && ExtensionScannerInput.equals(cacheContents.input, this.input)) {\n\t\t\tthis.logService.debug('Using cached extensions scan result', input.type === ExtensionType.System ? 'system' : 'user', input.location.toString());\n\t\t\tthis.cacheValidatorThrottler.trigger(() => this.validateCache());\n\t\t\treturn cacheContents.result.map((extension) => {\n\t\t\t\t// revive URI object\n\t\t\t\textension.location = URI.revive(extension.location);\n\t\t\t\treturn extension;\n\t\t\t});\n\t\t}\n\t\tconst result = await super.scanExtensions(input);\n\t\tawait this.writeExtensionCache(cacheFile, { input, result });\n\t\treturn result;\n\t}\n\n\tprivate async readExtensionCache(cacheFile: URI): Promise<IExtensionCacheData | null> {\n\t\ttry {\n\t\t\tconst cacheRawContents = await this.fileService.readFile(cacheFile);\n\t\t\tconst extensionCacheData: IExtensionCacheData = JSON.parse(cacheRawContents.value.toString());\n\t\t\treturn { result: extensionCacheData.result, input: revive(extensionCacheData.input) };\n\t\t} catch (error) {\n\t\t\tthis.logService.debug('Error while reading the extension cache file:', cacheFile.path, getErrorMessage(error));\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate async writeExtensionCache(cacheFile: URI, cacheContents: IExtensionCacheData): Promise<void> {\n\t\ttry {\n\t\t\tawait this.fileService.writeFile(cacheFile, VSBuffer.fromString(JSON.stringify(cacheContents)));\n\t\t} catch (error) {\n\t\t\tthis.logService.debug('Error while writing the extension cache file:', cacheFile.path, getErrorMessage(error));\n\t\t}\n\t}\n\n\tprivate async validateCache(): Promise<void> {\n\t\tif (!this.input) {\n\t\t\t// Input has been unset by the time we get here, so skip validation\n\t\t\treturn;\n\t\t}\n\n\t\tconst cacheFile = this.getCacheFile(this.input);\n\t\tconst cacheContents = await this.readExtensionCache(cacheFile);\n\t\tif (!cacheContents) {\n\t\t\t// Cache has been deleted by someone else, which is perfectly fine...\n\t\t\treturn;\n\t\t}\n\n\t\tconst actual = cacheContents.result;\n\t\tconst expected = JSON.parse(JSON.stringify(await super.scanExtensions(this.input)));\n\t\tif (objects.equals(expected, actual)) {\n\t\t\t// Cache is valid and running with it is perfectly fine...\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tthis.logService.info('Invalidating Cache', actual, expected);\n\t\t\t// Cache is invalid, delete it\n\t\t\tawait this.fileService.del(cacheFile);\n\t\t\tthis._onDidChangeCache.fire();\n\t\t} catch (error) {\n\t\t\tthis.logService.error(error);\n\t\t}\n\t}\n\n\tprivate getCacheFile(input: ExtensionScannerInput): URI {\n\t\tconst profile = this.getProfile(input);\n\t\treturn this.uriIdentityService.extUri.joinPath(profile.cacheHome, input.type === ExtensionType.System ? BUILTIN_MANIFEST_CACHE_FILE : USER_MANIFEST_CACHE_FILE);\n\t}\n\n\tprivate getProfile(input: ExtensionScannerInput): IUserDataProfile {\n\t\tif (input.type === ExtensionType.System) {\n\t\t\treturn this.userDataProfilesService.defaultProfile;\n\t\t}\n\t\tif (!input.profile) {\n\t\t\treturn this.userDataProfilesService.defaultProfile;\n\t\t}\n\t\tif (this.uriIdentityService.extUri.isEqual(input.location, this.currentProfile.extensionsResource)) {\n\t\t\treturn this.currentProfile;\n\t\t}\n\t\treturn this.userDataProfilesService.profiles.find(p => this.uriIdentityService.extUri.isEqual(input.location, p.extensionsResource)) ?? this.currentProfile;\n\t}\n\n}\n\nexport function toExtensionDescription(extension: IScannedExtension, isUnderDevelopment: boolean): IExtensionDescription {\n\tconst id = getExtensionId(extension.manifest.publisher, extension.manifest.name);\n\treturn {\n\t\tid,\n\t\tidentifier: new ExtensionIdentifier(id),\n\t\tisBuiltin: extension.type === ExtensionType.System,\n\t\tisUserBuiltin: extension.type === ExtensionType.User && extension.isBuiltin,\n\t\tisUnderDevelopment,\n\t\textensionLocation: extension.location,\n\t\tuuid: extension.identifier.uuid,\n\t\ttargetPlatform: extension.targetPlatform,\n\t\tpublisherDisplayName: extension.publisherDisplayName,\n\t\t...extension.manifest,\n\t};\n}\n\nexport class NativeExtensionsScannerService extends AbstractExtensionsScannerService implements IExtensionsScannerService {\n\n\tprivate readonly translationsPromise: Promise<Translations>;\n\n\tconstructor(\n\t\tsystemExtensionsLocation: URI,\n\t\tuserExtensionsLocation: URI,\n\t\tuserHome: URI,\n\t\tcurrentProfile: IUserDataProfile,\n\t\tuserDataProfilesService: IUserDataProfilesService,\n\t\textensionsProfileScannerService: IExtensionsProfileScannerService,\n\t\tfileService: IFileService,\n\t\tlogService: ILogService,\n\t\tenvironmentService: IEnvironmentService,\n\t\tproductService: IProductService,\n\t\turiIdentityService: IUriIdentityService,\n\t\tinstantiationService: IInstantiationService,\n\t) {\n\t\tsuper(\n\t\t\tsystemExtensionsLocation,\n\t\t\tuserExtensionsLocation,\n\t\t\tjoinPath(userHome, '.vscode-oss-dev', 'extensions', 'control.json'),\n\t\t\tcurrentProfile,\n\t\t\tuserDataProfilesService, extensionsProfileScannerService, fileService, logService, environmentService, productService, uriIdentityService, instantiationService);\n\t\tthis.translationsPromise = (async () => {\n\t\t\tif (platform.translationsConfigFile) {\n\t\t\t\ttry {\n\t\t\t\t\tconst content = await this.fileService.readFile(URI.file(platform.translationsConfigFile));\n\t\t\t\t\treturn JSON.parse(content.value.toString());\n\t\t\t\t} catch (err) { /* Ignore Error */ }\n\t\t\t}\n\t\t\treturn Object.create(null);\n\t\t})();\n\t}\n\n\tprotected getTranslations(language: string): Promise<Translations> {\n\t\treturn this.translationsPromise;\n\t}\n\n}\n"],
  "mappings": "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",
  "names": ["Translations", "extensions"]
}
