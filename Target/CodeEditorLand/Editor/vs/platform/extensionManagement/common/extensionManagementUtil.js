import{compareIgnoreCase as c}from"../../../base/common/strings.js";import{getTargetPlatform as m}from"./extensionManagement.js";import{ExtensionIdentifier as g,TargetPlatform as u,UNDEFINED_PUBLISHER as I}from"../../extensions/common/extensions.js";import"../../files/common/files.js";import{isLinux as E,platform as h}from"../../../base/common/platform.js";import{URI as d}from"../../../base/common/uri.js";import{getErrorMessage as y}from"../../../base/common/errors.js";import"../../log/common/log.js";import{arch as x}from"../../../base/common/process.js";import{TelemetryTrustedValue as p}from"../../telemetry/common/telemetryUtils.js";function o(e,t){return e.uuid&&t.uuid?e.uuid===t.uuid:e.id===t.id?!0:c(e.id,t.id)===0}const P=/^([^.]+\..+)-(\d+\.\d+\.\d+)(-(.+))?$/;class a{constructor(t,r,n=u.UNDEFINED){this.identifier=t;this.version=r;this.targetPlatform=n;this.id=t.id}static create(t){const r=t.manifest?t.manifest.version:t.version,n=t.manifest?t.targetPlatform:t.properties.targetPlatform;return new a(t.identifier,r,n)}static parse(t){const r=P.exec(t);return r&&r[1]&&r[2]?new a({id:r[1]},r[2],r[4]||void 0):null}id;toString(){return`${this.id}-${this.version}${this.targetPlatform!==u.UNDEFINED?`-${this.targetPlatform}`:""}`}equals(t){return t instanceof a?o(this,t)&&this.version===t.version&&this.targetPlatform===t.targetPlatform:!1}}const T=/^([^.]+\..+)@((prerelease)|(\d+\.\d+\.\d+(-.*)?))$/;function O(e){const t=T.exec(e);return t&&t[1]?[f(t[1]),t[2]]:[f(e),void 0]}function D(e,t){return`${e}.${t}`}function f(e){return e.toLowerCase()}function X(e,t){return f(D(e??I,t))}function _(e,t){const r=[],n=i=>{for(const s of r)if(s.some(l=>o(t(l),t(i))))return s;return null};for(const i of e){const s=n(i);s?s.push(i):r.push([i])}return r}function q(e){return{id:e.identifier.id,name:e.manifest.name,galleryId:null,publisherId:e.publisherId,publisherName:e.manifest.publisher,publisherDisplayName:e.publisherDisplayName,dependencies:e.manifest.extensionDependencies&&e.manifest.extensionDependencies.length>0}}function K(e){return{id:new p(e.identifier.id),name:new p(e.name),version:e.version,galleryId:e.identifier.uuid,publisherId:e.publisherId,publisherName:e.publisher,publisherDisplayName:e.publisherDisplayName,isPreReleaseVersion:e.properties.isPreReleaseVersion,dependencies:!!(e.properties.dependencies&&e.properties.dependencies.length>0),isSigned:e.isSigned,...e.telemetryData}}const W=new g("pprice.better-merge");function j(e,t){const r=[],n=t.manifest.extensionDependencies?.slice(0)??[];for(;n.length;){const i=n.shift();if(i&&r.every(s=>!o(s.identifier,{id:i}))){const s=e.filter(l=>o(l.identifier,{id:i}));s.length===1&&(r.push(s[0]),n.push(...s[0].manifest.extensionDependencies?.slice(0)??[]))}}return r}async function b(e,t){if(!E)return!1;let r;try{r=(await e.readFile(d.file("/etc/os-release"))).value.toString()}catch{try{r=(await e.readFile(d.file("/usr/lib/os-release"))).value.toString()}catch(i){t.debug("Error while getting the os-release file.",y(i))}}return!!r&&(r.match(/^ID=([^\u001b\r\n]*)/m)||[])[1]==="alpine"}async function k(e,t){const r=await b(e,t),n=m(r?"alpine":h,x);return t.debug("ComputeTargetPlatform:",n),n}export{W as BetterMergeId,a as ExtensionKey,f as adoptToGalleryExtensionId,o as areSameExtensions,k as computeTargetPlatform,j as getExtensionDependencies,D as getExtensionId,X as getGalleryExtensionId,K as getGalleryExtensionTelemetryData,O as getIdAndVersion,q as getLocalExtensionTelemetryData,_ as groupByExtension};
