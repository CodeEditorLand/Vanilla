{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/extensionManagement/common/abstractExtensionManagementService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { distinct, isNonEmptyArray } from '../../../base/common/arrays.js';\nimport { Barrier, CancelablePromise, createCancelablePromise } from '../../../base/common/async.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { CancellationError, getErrorMessage, isCancellationError } from '../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { Disposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { ResourceMap } from '../../../base/common/map.js';\nimport { isWeb } from '../../../base/common/platform.js';\nimport { URI } from '../../../base/common/uri.js';\nimport * as nls from '../../../nls.js';\nimport {\n\tExtensionManagementError, IExtensionGalleryService, IExtensionIdentifier, IExtensionManagementParticipant, IGalleryExtension, ILocalExtension, InstallOperation,\n\tIExtensionsControlManifest, StatisticType, isTargetPlatformCompatible, TargetPlatformToString, ExtensionManagementErrorCode,\n\tInstallOptions, UninstallOptions, Metadata, InstallExtensionEvent, DidUninstallExtensionEvent, InstallExtensionResult, UninstallExtensionEvent, IExtensionManagementService, InstallExtensionInfo, EXTENSION_INSTALL_DEP_PACK_CONTEXT, ExtensionGalleryError,\n\tIProductVersion, ExtensionGalleryErrorCode,\n\tEXTENSION_INSTALL_SOURCE_CONTEXT,\n\tDidUpdateExtensionMetadata,\n\tUninstallExtensionInfo,\n\tExtensionSignatureVerificationCode\n} from './extensionManagement.js';\nimport { areSameExtensions, ExtensionKey, getGalleryExtensionId, getGalleryExtensionTelemetryData, getLocalExtensionTelemetryData } from './extensionManagementUtil.js';\nimport { ExtensionType, IExtensionManifest, isApplicationScopedExtension, TargetPlatform } from '../../extensions/common/extensions.js';\nimport { areApiProposalsCompatible } from '../../extensions/common/extensionValidator.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { IProductService } from '../../product/common/productService.js';\nimport { ITelemetryService } from '../../telemetry/common/telemetry.js';\nimport { IUriIdentityService } from '../../uriIdentity/common/uriIdentity.js';\nimport { IUserDataProfilesService } from '../../userDataProfile/common/userDataProfile.js';\n\nexport type InstallableExtension = { readonly manifest: IExtensionManifest; extension: IGalleryExtension | URI; options: InstallOptions };\n\nexport type InstallExtensionTaskOptions = InstallOptions & { readonly profileLocation: URI; readonly productVersion: IProductVersion };\nexport interface IInstallExtensionTask {\n\treadonly manifest: IExtensionManifest;\n\treadonly identifier: IExtensionIdentifier;\n\treadonly source: IGalleryExtension | URI;\n\treadonly operation: InstallOperation;\n\treadonly options: InstallExtensionTaskOptions;\n\treadonly verificationStatus?: ExtensionSignatureVerificationCode;\n\trun(): Promise<ILocalExtension>;\n\twaitUntilTaskIsFinished(): Promise<ILocalExtension>;\n\tcancel(): void;\n}\n\nexport type UninstallExtensionTaskOptions = UninstallOptions & { readonly profileLocation: URI };\nexport interface IUninstallExtensionTask {\n\treadonly options: UninstallExtensionTaskOptions;\n\treadonly extension: ILocalExtension;\n\trun(): Promise<void>;\n\twaitUntilTaskIsFinished(): Promise<void>;\n\tcancel(): void;\n}\n\nexport abstract class AbstractExtensionManagementService extends Disposable implements IExtensionManagementService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate extensionsControlManifest: Promise<IExtensionsControlManifest> | undefined;\n\tprivate lastReportTimestamp = 0;\n\tprivate readonly installingExtensions = new Map<string, { task: IInstallExtensionTask; waitingTasks: IInstallExtensionTask[] }>();\n\tprivate readonly uninstallingExtensions = new Map<string, IUninstallExtensionTask>();\n\n\tprivate readonly _onInstallExtension = this._register(new Emitter<InstallExtensionEvent>());\n\tget onInstallExtension() { return this._onInstallExtension.event; }\n\n\tprotected readonly _onDidInstallExtensions = this._register(new Emitter<InstallExtensionResult[]>());\n\tget onDidInstallExtensions() { return this._onDidInstallExtensions.event; }\n\n\tprotected readonly _onUninstallExtension = this._register(new Emitter<UninstallExtensionEvent>());\n\tget onUninstallExtension() { return this._onUninstallExtension.event; }\n\n\tprotected _onDidUninstallExtension = this._register(new Emitter<DidUninstallExtensionEvent>());\n\tget onDidUninstallExtension() { return this._onDidUninstallExtension.event; }\n\n\tprotected readonly _onDidUpdateExtensionMetadata = this._register(new Emitter<DidUpdateExtensionMetadata>());\n\tget onDidUpdateExtensionMetadata() { return this._onDidUpdateExtensionMetadata.event; }\n\n\tprivate readonly participants: IExtensionManagementParticipant[] = [];\n\n\tconstructor(\n\t\t@IExtensionGalleryService protected readonly galleryService: IExtensionGalleryService,\n\t\t@ITelemetryService protected readonly telemetryService: ITelemetryService,\n\t\t@IUriIdentityService protected readonly uriIdentityService: IUriIdentityService,\n\t\t@ILogService protected readonly logService: ILogService,\n\t\t@IProductService protected readonly productService: IProductService,\n\t\t@IUserDataProfilesService protected readonly userDataProfilesService: IUserDataProfilesService,\n\t) {\n\t\tsuper();\n\t\tthis._register(toDisposable(() => {\n\t\t\tthis.installingExtensions.forEach(({ task }) => task.cancel());\n\t\t\tthis.uninstallingExtensions.forEach(promise => promise.cancel());\n\t\t\tthis.installingExtensions.clear();\n\t\t\tthis.uninstallingExtensions.clear();\n\t\t}));\n\t}\n\n\tasync canInstall(extension: IGalleryExtension): Promise<boolean> {\n\t\tconst currentTargetPlatform = await this.getTargetPlatform();\n\t\treturn extension.allTargetPlatforms.some(targetPlatform => isTargetPlatformCompatible(targetPlatform, extension.allTargetPlatforms, currentTargetPlatform));\n\t}\n\n\tasync installFromGallery(extension: IGalleryExtension, options: InstallOptions = {}): Promise<ILocalExtension> {\n\t\ttry {\n\t\t\tconst results = await this.installGalleryExtensions([{ extension, options }]);\n\t\t\tconst result = results.find(({ identifier }) => areSameExtensions(identifier, extension.identifier));\n\t\t\tif (result?.local) {\n\t\t\t\treturn result?.local;\n\t\t\t}\n\t\t\tif (result?.error) {\n\t\t\t\tthrow result.error;\n\t\t\t}\n\t\t\tthrow new ExtensionManagementError(`Unknown error while installing extension ${extension.identifier.id}`, ExtensionManagementErrorCode.Unknown);\n\t\t} catch (error) {\n\t\t\tthrow toExtensionManagementError(error);\n\t\t}\n\t}\n\n\tasync installGalleryExtensions(extensions: InstallExtensionInfo[]): Promise<InstallExtensionResult[]> {\n\t\tif (!this.galleryService.isEnabled()) {\n\t\t\tthrow new ExtensionManagementError(nls.localize('MarketPlaceDisabled', \"Marketplace is not enabled\"), ExtensionManagementErrorCode.NotAllowed);\n\t\t}\n\n\t\tconst results: InstallExtensionResult[] = [];\n\t\tconst installableExtensions: InstallableExtension[] = [];\n\n\t\tawait Promise.allSettled(extensions.map(async ({ extension, options }) => {\n\t\t\ttry {\n\t\t\t\tconst compatible = await this.checkAndGetCompatibleVersion(extension, !!options?.installGivenVersion, !!options?.installPreReleaseVersion, options.productVersion ?? { version: this.productService.version, date: this.productService.date });\n\t\t\t\tinstallableExtensions.push({ ...compatible, options });\n\t\t\t} catch (error) {\n\t\t\t\tresults.push({ identifier: extension.identifier, operation: InstallOperation.Install, source: extension, error, profileLocation: options.profileLocation ?? this.getCurrentExtensionsManifestLocation() });\n\t\t\t}\n\t\t}));\n\n\t\tif (installableExtensions.length) {\n\t\t\tresults.push(...await this.installExtensions(installableExtensions));\n\t\t}\n\n\t\treturn results;\n\t}\n\n\tasync uninstall(extension: ILocalExtension, options?: UninstallOptions): Promise<void> {\n\t\tthis.logService.trace('ExtensionManagementService#uninstall', extension.identifier.id);\n\t\treturn this.uninstallExtensions([{ extension, options }]);\n\t}\n\n\tasync toggleAppliationScope(extension: ILocalExtension, fromProfileLocation: URI): Promise<ILocalExtension> {\n\t\tif (isApplicationScopedExtension(extension.manifest) || extension.isBuiltin) {\n\t\t\treturn extension;\n\t\t}\n\n\t\tif (extension.isApplicationScoped) {\n\t\t\tlet local = await this.updateMetadata(extension, { isApplicationScoped: false }, this.userDataProfilesService.defaultProfile.extensionsResource);\n\t\t\tif (!this.uriIdentityService.extUri.isEqual(fromProfileLocation, this.userDataProfilesService.defaultProfile.extensionsResource)) {\n\t\t\t\tlocal = await this.copyExtension(extension, this.userDataProfilesService.defaultProfile.extensionsResource, fromProfileLocation);\n\t\t\t}\n\n\t\t\tfor (const profile of this.userDataProfilesService.profiles) {\n\t\t\t\tconst existing = (await this.getInstalled(ExtensionType.User, profile.extensionsResource))\n\t\t\t\t\t.find(e => areSameExtensions(e.identifier, extension.identifier));\n\t\t\t\tif (existing) {\n\t\t\t\t\tthis._onDidUpdateExtensionMetadata.fire({ local: existing, profileLocation: profile.extensionsResource });\n\t\t\t\t} else {\n\t\t\t\t\tthis._onDidUninstallExtension.fire({ identifier: extension.identifier, profileLocation: profile.extensionsResource });\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn local;\n\t\t}\n\n\t\telse {\n\t\t\tconst local = this.uriIdentityService.extUri.isEqual(fromProfileLocation, this.userDataProfilesService.defaultProfile.extensionsResource)\n\t\t\t\t? await this.updateMetadata(extension, { isApplicationScoped: true }, this.userDataProfilesService.defaultProfile.extensionsResource)\n\t\t\t\t: await this.copyExtension(extension, fromProfileLocation, this.userDataProfilesService.defaultProfile.extensionsResource, { isApplicationScoped: true });\n\n\t\t\tthis._onDidInstallExtensions.fire([{ identifier: local.identifier, operation: InstallOperation.Install, local, profileLocation: this.userDataProfilesService.defaultProfile.extensionsResource, applicationScoped: true }]);\n\t\t\treturn local;\n\t\t}\n\n\t}\n\n\tgetExtensionsControlManifest(): Promise<IExtensionsControlManifest> {\n\t\tconst now = new Date().getTime();\n\n\t\tif (!this.extensionsControlManifest || now - this.lastReportTimestamp > 1000 * 60 * 5) { // 5 minute cache freshness\n\t\t\tthis.extensionsControlManifest = this.updateControlCache();\n\t\t\tthis.lastReportTimestamp = now;\n\t\t}\n\n\t\treturn this.extensionsControlManifest;\n\t}\n\n\tregisterParticipant(participant: IExtensionManagementParticipant): void {\n\t\tthis.participants.push(participant);\n\t}\n\n\tasync resetPinnedStateForAllUserExtensions(pinned: boolean): Promise<void> {\n\t\ttry {\n\t\t\tawait this.joinAllSettled(this.userDataProfilesService.profiles.map(\n\t\t\t\tasync profile => {\n\t\t\t\t\tconst extensions = await this.getInstalled(ExtensionType.User, profile.extensionsResource);\n\t\t\t\t\tawait this.joinAllSettled(extensions.map(\n\t\t\t\t\t\tasync extension => {\n\t\t\t\t\t\t\tif (extension.pinned !== pinned) {\n\t\t\t\t\t\t\t\tawait this.updateMetadata(extension, { pinned }, profile.extensionsResource);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}));\n\t\t\t\t}));\n\t\t} catch (error) {\n\t\t\tthis.logService.error('Error while resetting pinned state for all user extensions', getErrorMessage(error));\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tprotected async installExtensions(extensions: InstallableExtension[]): Promise<InstallExtensionResult[]> {\n\t\tconst installExtensionResultsMap = new Map<string, InstallExtensionResult & { profileLocation: URI }>();\n\t\tconst installingExtensionsMap = new Map<string, { task: IInstallExtensionTask; root: IInstallExtensionTask | undefined }>();\n\t\tconst alreadyRequestedInstallations: Promise<any>[] = [];\n\n\t\tconst getInstallExtensionTaskKey = (extension: IGalleryExtension, profileLocation: URI) => `${ExtensionKey.create(extension).toString()}-${profileLocation.toString()}`;\n\t\tconst createInstallExtensionTask = (manifest: IExtensionManifest, extension: IGalleryExtension | URI, options: InstallExtensionTaskOptions, root: IInstallExtensionTask | undefined): void => {\n\t\t\tif (!URI.isUri(extension)) {\n\t\t\t\tif (installingExtensionsMap.has(`${extension.identifier.id.toLowerCase()}-${options.profileLocation.toString()}`)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst existingInstallingExtension = this.installingExtensions.get(getInstallExtensionTaskKey(extension, options.profileLocation));\n\t\t\t\tif (existingInstallingExtension) {\n\t\t\t\t\tif (root && this.canWaitForTask(root, existingInstallingExtension.task)) {\n\t\t\t\t\t\tconst identifier = existingInstallingExtension.task.identifier;\n\t\t\t\t\t\tthis.logService.info('Waiting for already requested installing extension', identifier.id, root.identifier.id, options.profileLocation.toString());\n\t\t\t\t\t\texistingInstallingExtension.waitingTasks.push(root);\n\t\t\t\t\t\t// add promise that waits until the extension is completely installed, ie., onDidInstallExtensions event is triggered for this extension\n\t\t\t\t\t\talreadyRequestedInstallations.push(\n\t\t\t\t\t\t\tEvent.toPromise(\n\t\t\t\t\t\t\t\tEvent.filter(this.onDidInstallExtensions, results => results.some(result => areSameExtensions(result.identifier, identifier)))\n\t\t\t\t\t\t\t).then(results => {\n\t\t\t\t\t\t\t\tthis.logService.info('Finished waiting for already requested installing extension', identifier.id, root.identifier.id, options.profileLocation.toString());\n\t\t\t\t\t\t\t\tconst result = results.find(result => areSameExtensions(result.identifier, identifier));\n\t\t\t\t\t\t\t\tif (!result?.local) {\n\t\t\t\t\t\t\t\t\t// Extension failed to install\n\t\t\t\t\t\t\t\t\tthrow new Error(`Extension ${identifier.id} is not installed`);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}));\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst installExtensionTask = this.createInstallExtensionTask(manifest, extension, options);\n\t\t\tconst key = `${getGalleryExtensionId(manifest.publisher, manifest.name)}-${options.profileLocation.toString()}`;\n\t\t\tinstallingExtensionsMap.set(key, { task: installExtensionTask, root });\n\t\t\tthis._onInstallExtension.fire({ identifier: installExtensionTask.identifier, source: extension, profileLocation: options.profileLocation });\n\t\t\tthis.logService.info('Installing extension:', installExtensionTask.identifier.id, options);\n\t\t\t// only cache gallery extensions tasks\n\t\t\tif (!URI.isUri(extension)) {\n\t\t\t\tthis.installingExtensions.set(getInstallExtensionTaskKey(extension, options.profileLocation), { task: installExtensionTask, waitingTasks: [] });\n\t\t\t}\n\t\t};\n\n\t\ttry {\n\t\t\t// Start installing extensions\n\t\t\tfor (const { manifest, extension, options } of extensions) {\n\t\t\t\tconst isApplicationScoped = options.isApplicationScoped || options.isBuiltin || isApplicationScopedExtension(manifest);\n\t\t\t\tconst installExtensionTaskOptions: InstallExtensionTaskOptions = {\n\t\t\t\t\t...options,\n\t\t\t\t\tinstallOnlyNewlyAddedFromExtensionPack: options.installOnlyNewlyAddedFromExtensionPack ?? !URI.isUri(extension) /* always true for gallery extensions */,\n\t\t\t\t\tisApplicationScoped,\n\t\t\t\t\tprofileLocation: isApplicationScoped ? this.userDataProfilesService.defaultProfile.extensionsResource : options.profileLocation ?? this.getCurrentExtensionsManifestLocation(),\n\t\t\t\t\tproductVersion: options.productVersion ?? { version: this.productService.version, date: this.productService.date }\n\t\t\t\t};\n\n\t\t\t\tconst existingInstallExtensionTask = !URI.isUri(extension) ? this.installingExtensions.get(getInstallExtensionTaskKey(extension, installExtensionTaskOptions.profileLocation)) : undefined;\n\t\t\t\tif (existingInstallExtensionTask) {\n\t\t\t\t\tthis.logService.info('Extension is already requested to install', existingInstallExtensionTask.task.identifier.id, installExtensionTaskOptions.profileLocation.toString());\n\t\t\t\t\talreadyRequestedInstallations.push(existingInstallExtensionTask.task.waitUntilTaskIsFinished());\n\t\t\t\t} else {\n\t\t\t\t\tcreateInstallExtensionTask(manifest, extension, installExtensionTaskOptions, undefined);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// collect and start installing all dependencies and pack extensions\n\t\t\tawait Promise.all([...installingExtensionsMap.values()].map(async ({ task }) => {\n\t\t\t\tif (task.options.donotIncludePackAndDependencies) {\n\t\t\t\t\tthis.logService.info('Installing the extension without checking dependencies and pack', task.identifier.id);\n\t\t\t\t} else {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst allDepsAndPackExtensionsToInstall = await this.getAllDepsAndPackExtensions(task.identifier, task.manifest, !!task.options.installOnlyNewlyAddedFromExtensionPack, !!task.options.installPreReleaseVersion, task.options.profileLocation, task.options.productVersion);\n\t\t\t\t\t\tconst installed = await this.getInstalled(undefined, task.options.profileLocation, task.options.productVersion);\n\t\t\t\t\t\tconst options: InstallExtensionTaskOptions = { ...task.options, context: { ...task.options.context, [EXTENSION_INSTALL_DEP_PACK_CONTEXT]: true } };\n\t\t\t\t\t\tfor (const { gallery, manifest } of distinct(allDepsAndPackExtensionsToInstall, ({ gallery }) => gallery.identifier.id)) {\n\t\t\t\t\t\t\tif (installed.some(({ identifier }) => areSameExtensions(identifier, gallery.identifier))) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcreateInstallExtensionTask(manifest, gallery, options, task);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t// Installing through VSIX\n\t\t\t\t\t\tif (URI.isUri(task.source)) {\n\t\t\t\t\t\t\t// Ignore installing dependencies and packs\n\t\t\t\t\t\t\tif (isNonEmptyArray(task.manifest.extensionDependencies)) {\n\t\t\t\t\t\t\t\tthis.logService.warn(`Cannot install dependencies of extension:`, task.identifier.id, error.message);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (isNonEmptyArray(task.manifest.extensionPack)) {\n\t\t\t\t\t\t\t\tthis.logService.warn(`Cannot install packed extensions of extension:`, task.identifier.id, error.message);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.logService.error('Error while preparing to install dependencies and extension packs of the extension:', task.identifier.id);\n\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tconst otherProfilesToUpdate = await this.getOtherProfilesToUpdateExtension([...installingExtensionsMap.values()].map(({ task }) => task));\n\t\t\tfor (const [profileLocation, task] of otherProfilesToUpdate) {\n\t\t\t\tcreateInstallExtensionTask(task.manifest, task.source, { ...task.options, profileLocation }, undefined);\n\t\t\t}\n\n\t\t\t// Install extensions in parallel and wait until all extensions are installed / failed\n\t\t\tawait this.joinAllSettled([...installingExtensionsMap.entries()].map(async ([key, { task }]) => {\n\t\t\t\tconst startTime = new Date().getTime();\n\t\t\t\tlet local: ILocalExtension;\n\t\t\t\ttry {\n\t\t\t\t\tlocal = await task.run();\n\t\t\t\t\tawait this.joinAllSettled(this.participants.map(participant => participant.postInstall(local, task.source, task.options, CancellationToken.None)), ExtensionManagementErrorCode.PostInstall);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconst error = toExtensionManagementError(e);\n\t\t\t\t\tif (!URI.isUri(task.source)) {\n\t\t\t\t\t\treportTelemetry(this.telemetryService, task.operation === InstallOperation.Update ? 'extensionGallery:update' : 'extensionGallery:install', {\n\t\t\t\t\t\t\textensionData: getGalleryExtensionTelemetryData(task.source),\n\t\t\t\t\t\t\terror,\n\t\t\t\t\t\t\tsource: task.options.context?.[EXTENSION_INSTALL_SOURCE_CONTEXT]\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tinstallExtensionResultsMap.set(key, { error, identifier: task.identifier, operation: task.operation, source: task.source, context: task.options.context, profileLocation: task.options.profileLocation, applicationScoped: task.options.isApplicationScoped });\n\t\t\t\t\tthis.logService.error('Error while installing the extension', task.identifier.id, getErrorMessage(error), task.options.profileLocation.toString());\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t\tif (!URI.isUri(task.source)) {\n\t\t\t\t\tconst isUpdate = task.operation === InstallOperation.Update;\n\t\t\t\t\tconst durationSinceUpdate = isUpdate ? undefined : (new Date().getTime() - task.source.lastUpdated) / 1000;\n\t\t\t\t\treportTelemetry(this.telemetryService, isUpdate ? 'extensionGallery:update' : 'extensionGallery:install', {\n\t\t\t\t\t\textensionData: getGalleryExtensionTelemetryData(task.source),\n\t\t\t\t\t\tverificationStatus: task.verificationStatus,\n\t\t\t\t\t\tduration: new Date().getTime() - startTime,\n\t\t\t\t\t\tdurationSinceUpdate,\n\t\t\t\t\t\tsource: task.options.context?.[EXTENSION_INSTALL_SOURCE_CONTEXT]\n\t\t\t\t\t});\n\t\t\t\t\t// In web, report extension install statistics explicitly. In Desktop, statistics are automatically updated while downloading the VSIX.\n\t\t\t\t\tif (isWeb && task.operation !== InstallOperation.Update) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait this.galleryService.reportStatistic(local.manifest.publisher, local.manifest.name, local.manifest.version, StatisticType.Install);\n\t\t\t\t\t\t} catch (error) { /* ignore */ }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinstallExtensionResultsMap.set(key, { local, identifier: task.identifier, operation: task.operation, source: task.source, context: task.options.context, profileLocation: task.options.profileLocation, applicationScoped: local.isApplicationScoped });\n\t\t\t}));\n\n\t\t\tif (alreadyRequestedInstallations.length) {\n\t\t\t\tawait this.joinAllSettled(alreadyRequestedInstallations);\n\t\t\t}\n\t\t\treturn [...installExtensionResultsMap.values()];\n\t\t} catch (error) {\n\t\t\tconst getAllDepsAndPacks = (extension: ILocalExtension, profileLocation: URI, allDepsOrPacks: string[]) => {\n\t\t\t\tconst depsOrPacks = [];\n\t\t\t\tif (extension.manifest.extensionDependencies?.length) {\n\t\t\t\t\tdepsOrPacks.push(...extension.manifest.extensionDependencies);\n\t\t\t\t}\n\t\t\t\tif (extension.manifest.extensionPack?.length) {\n\t\t\t\t\tdepsOrPacks.push(...extension.manifest.extensionPack);\n\t\t\t\t}\n\t\t\t\tfor (const id of depsOrPacks) {\n\t\t\t\t\tif (allDepsOrPacks.includes(id.toLowerCase())) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tallDepsOrPacks.push(id.toLowerCase());\n\t\t\t\t\tconst installed = installExtensionResultsMap.get(`${id.toLowerCase()}-${profileLocation.toString()}`);\n\t\t\t\t\tif (installed?.local) {\n\t\t\t\t\t\tallDepsOrPacks = getAllDepsAndPacks(installed.local, profileLocation, allDepsOrPacks);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn allDepsOrPacks;\n\t\t\t};\n\t\t\tconst getErrorResult = (task: IInstallExtensionTask) => ({ identifier: task.identifier, operation: InstallOperation.Install, source: task.source, context: task.options.context, profileLocation: task.options.profileLocation, error });\n\n\t\t\tconst rollbackTasks: IUninstallExtensionTask[] = [];\n\t\t\tfor (const [key, { task, root }] of installingExtensionsMap) {\n\t\t\t\tconst result = installExtensionResultsMap.get(key);\n\t\t\t\tif (!result) {\n\t\t\t\t\ttask.cancel();\n\t\t\t\t\tinstallExtensionResultsMap.set(key, getErrorResult(task));\n\t\t\t\t}\n\t\t\t\t// If the extension is installed by a root task and the root task is failed, then uninstall the extension\n\t\t\t\telse if (result.local && root && !installExtensionResultsMap.get(`${root.identifier.id.toLowerCase()}-${task.options.profileLocation.toString()}`)?.local) {\n\t\t\t\t\trollbackTasks.push(this.createUninstallExtensionTask(result.local, { versionOnly: true, profileLocation: task.options.profileLocation }));\n\t\t\t\t\tinstallExtensionResultsMap.set(key, getErrorResult(task));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const [key, { task }] of installingExtensionsMap) {\n\t\t\t\tconst result = installExtensionResultsMap.get(key);\n\t\t\t\tif (!result?.local) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (task.options.donotIncludePackAndDependencies) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst depsOrPacks = getAllDepsAndPacks(result.local, task.options.profileLocation, [result.local.identifier.id.toLowerCase()]).slice(1);\n\t\t\t\tif (depsOrPacks.some(depOrPack => installingExtensionsMap.has(`${depOrPack.toLowerCase()}-${task.options.profileLocation.toString()}`) && !installExtensionResultsMap.get(`${depOrPack.toLowerCase()}-${task.options.profileLocation.toString()}`)?.local)) {\n\t\t\t\t\trollbackTasks.push(this.createUninstallExtensionTask(result.local, { versionOnly: true, profileLocation: task.options.profileLocation }));\n\t\t\t\t\tinstallExtensionResultsMap.set(key, getErrorResult(task));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rollbackTasks.length) {\n\t\t\t\tawait Promise.allSettled(rollbackTasks.map(async rollbackTask => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait rollbackTask.run();\n\t\t\t\t\t\tthis.logService.info('Rollback: Uninstalled extension', rollbackTask.extension.identifier.id);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tthis.logService.warn('Rollback: Error while uninstalling extension', rollbackTask.extension.identifier.id, getErrorMessage(error));\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tthrow error;\n\t\t} finally {\n\t\t\t// Finally, remove all the tasks from the cache\n\t\t\tfor (const { task } of installingExtensionsMap.values()) {\n\t\t\t\tif (task.source && !URI.isUri(task.source)) {\n\t\t\t\t\tthis.installingExtensions.delete(getInstallExtensionTaskKey(task.source, task.options.profileLocation));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (installExtensionResultsMap.size) {\n\t\t\t\tconst results = [...installExtensionResultsMap.values()];\n\t\t\t\tfor (const result of results) {\n\t\t\t\t\tif (result.local) {\n\t\t\t\t\t\tthis.logService.info(`Extension installed successfully:`, result.identifier.id, result.profileLocation.toString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis._onDidInstallExtensions.fire(results);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async getOtherProfilesToUpdateExtension(tasks: IInstallExtensionTask[]): Promise<[URI, IInstallExtensionTask][]> {\n\t\tconst otherProfilesToUpdate: [URI, IInstallExtensionTask][] = [];\n\t\tconst profileExtensionsCache = new ResourceMap<ILocalExtension[]>();\n\t\tfor (const task of tasks) {\n\t\t\tif (task.operation !== InstallOperation.Update\n\t\t\t\t|| task.options.isApplicationScoped\n\t\t\t\t|| task.options.pinned\n\t\t\t\t|| task.options.installGivenVersion\n\t\t\t\t|| URI.isUri(task.source)\n\t\t\t) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (const profile of this.userDataProfilesService.profiles) {\n\t\t\t\tif (this.uriIdentityService.extUri.isEqual(profile.extensionsResource, task.options.profileLocation)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlet installedExtensions = profileExtensionsCache.get(profile.extensionsResource);\n\t\t\t\tif (!installedExtensions) {\n\t\t\t\t\tinstalledExtensions = await this.getInstalled(ExtensionType.User, profile.extensionsResource);\n\t\t\t\t\tprofileExtensionsCache.set(profile.extensionsResource, installedExtensions);\n\t\t\t\t}\n\t\t\t\tconst installedExtension = installedExtensions.find(e => areSameExtensions(e.identifier, task.identifier));\n\t\t\t\tif (installedExtension && !installedExtension.pinned) {\n\t\t\t\t\totherProfilesToUpdate.push([profile.extensionsResource, task]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn otherProfilesToUpdate;\n\t}\n\n\tprivate canWaitForTask(taskToWait: IInstallExtensionTask, taskToWaitFor: IInstallExtensionTask): boolean {\n\t\tfor (const [, { task, waitingTasks }] of this.installingExtensions.entries()) {\n\t\t\tif (task === taskToWait) {\n\t\t\t\t// Cannot be waited, If taskToWaitFor is waiting for taskToWait\n\t\t\t\tif (waitingTasks.includes(taskToWaitFor)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// Cannot be waited, If taskToWaitFor is waiting for tasks waiting for taskToWait\n\t\t\t\tif (waitingTasks.some(waitingTask => this.canWaitForTask(waitingTask, taskToWaitFor))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Cannot be waited, if the taskToWait cannot be waited for the task created the taskToWaitFor\n\t\t\t// Because, the task waits for the tasks it created\n\t\t\tif (task === taskToWaitFor && waitingTasks[0] && !this.canWaitForTask(taskToWait, waitingTasks[0])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate async joinAllSettled<T>(promises: Promise<T>[], errorCode?: ExtensionManagementErrorCode): Promise<T[]> {\n\t\tconst results: T[] = [];\n\t\tconst errors: ExtensionManagementError[] = [];\n\t\tconst promiseResults = await Promise.allSettled(promises);\n\t\tfor (const r of promiseResults) {\n\t\t\tif (r.status === 'fulfilled') {\n\t\t\t\tresults.push(r.value);\n\t\t\t} else {\n\t\t\t\terrors.push(toExtensionManagementError(r.reason, errorCode));\n\t\t\t}\n\t\t}\n\n\t\tif (!errors.length) {\n\t\t\treturn results;\n\t\t}\n\n\t\t// Throw if there are errors\n\t\tif (errors.length === 1) {\n\t\t\tthrow errors[0];\n\t\t}\n\n\t\tlet error = new ExtensionManagementError('', ExtensionManagementErrorCode.Unknown);\n\t\tfor (const current of errors) {\n\t\t\terror = new ExtensionManagementError(\n\t\t\t\terror.message ? `${error.message}, ${current.message}` : current.message,\n\t\t\t\tcurrent.code !== ExtensionManagementErrorCode.Unknown && current.code !== ExtensionManagementErrorCode.Internal ? current.code : error.code\n\t\t\t);\n\t\t}\n\t\tthrow error;\n\t}\n\n\tprivate async getAllDepsAndPackExtensions(extensionIdentifier: IExtensionIdentifier, manifest: IExtensionManifest, getOnlyNewlyAddedFromExtensionPack: boolean, installPreRelease: boolean, profile: URI | undefined, productVersion: IProductVersion): Promise<{ gallery: IGalleryExtension; manifest: IExtensionManifest }[]> {\n\t\tif (!this.galleryService.isEnabled()) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst installed = await this.getInstalled(undefined, profile, productVersion);\n\t\tconst knownIdentifiers: IExtensionIdentifier[] = [];\n\n\t\tconst allDependenciesAndPacks: { gallery: IGalleryExtension; manifest: IExtensionManifest }[] = [];\n\t\tconst collectDependenciesAndPackExtensionsToInstall = async (extensionIdentifier: IExtensionIdentifier, manifest: IExtensionManifest): Promise<void> => {\n\t\t\tknownIdentifiers.push(extensionIdentifier);\n\t\t\tconst dependecies: string[] = manifest.extensionDependencies || [];\n\t\t\tconst dependenciesAndPackExtensions = [...dependecies];\n\t\t\tif (manifest.extensionPack) {\n\t\t\t\tconst existing = getOnlyNewlyAddedFromExtensionPack ? installed.find(e => areSameExtensions(e.identifier, extensionIdentifier)) : undefined;\n\t\t\t\tfor (const extension of manifest.extensionPack) {\n\t\t\t\t\t// add only those extensions which are new in currently installed extension\n\t\t\t\t\tif (!(existing && existing.manifest.extensionPack && existing.manifest.extensionPack.some(old => areSameExtensions({ id: old }, { id: extension })))) {\n\t\t\t\t\t\tif (dependenciesAndPackExtensions.every(e => !areSameExtensions({ id: e }, { id: extension }))) {\n\t\t\t\t\t\t\tdependenciesAndPackExtensions.push(extension);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dependenciesAndPackExtensions.length) {\n\t\t\t\t// filter out known extensions\n\t\t\t\tconst ids = dependenciesAndPackExtensions.filter(id => knownIdentifiers.every(galleryIdentifier => !areSameExtensions(galleryIdentifier, { id })));\n\t\t\t\tif (ids.length) {\n\t\t\t\t\tconst galleryExtensions = await this.galleryService.getExtensions(ids.map(id => ({ id, preRelease: installPreRelease })), CancellationToken.None);\n\t\t\t\t\tfor (const galleryExtension of galleryExtensions) {\n\t\t\t\t\t\tif (knownIdentifiers.find(identifier => areSameExtensions(identifier, galleryExtension.identifier))) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst isDependency = dependecies.some(id => areSameExtensions({ id }, galleryExtension.identifier));\n\t\t\t\t\t\tlet compatible;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tcompatible = await this.checkAndGetCompatibleVersion(galleryExtension, false, installPreRelease, productVersion);\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tif (!isDependency) {\n\t\t\t\t\t\t\t\tthis.logService.info('Skipping the packed extension as it cannot be installed', galleryExtension.identifier.id, getErrorMessage(error));\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tallDependenciesAndPacks.push({ gallery: compatible.extension, manifest: compatible.manifest });\n\t\t\t\t\t\tawait collectDependenciesAndPackExtensionsToInstall(compatible.extension.identifier, compatible.manifest);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tawait collectDependenciesAndPackExtensionsToInstall(extensionIdentifier, manifest);\n\t\treturn allDependenciesAndPacks;\n\t}\n\n\tprivate async checkAndGetCompatibleVersion(extension: IGalleryExtension, sameVersion: boolean, installPreRelease: boolean, productVersion: IProductVersion): Promise<{ extension: IGalleryExtension; manifest: IExtensionManifest }> {\n\t\tlet compatibleExtension: IGalleryExtension | null;\n\n\t\tconst extensionsControlManifest = await this.getExtensionsControlManifest();\n\t\tif (extensionsControlManifest.malicious.some(identifier => areSameExtensions(extension.identifier, identifier))) {\n\t\t\tthrow new ExtensionManagementError(nls.localize('malicious extension', \"Can't install '{0}' extension since it was reported to be problematic.\", extension.identifier.id), ExtensionManagementErrorCode.Malicious);\n\t\t}\n\n\t\tconst deprecationInfo = extensionsControlManifest.deprecated[extension.identifier.id.toLowerCase()];\n\t\tif (deprecationInfo?.extension?.autoMigrate) {\n\t\t\tthis.logService.info(`The '${extension.identifier.id}' extension is deprecated, fetching the compatible '${deprecationInfo.extension.id}' extension instead.`);\n\t\t\tcompatibleExtension = (await this.galleryService.getExtensions([{ id: deprecationInfo.extension.id, preRelease: deprecationInfo.extension.preRelease }], { targetPlatform: await this.getTargetPlatform(), compatible: true, productVersion }, CancellationToken.None))[0];\n\t\t\tif (!compatibleExtension) {\n\t\t\t\tthrow new ExtensionManagementError(nls.localize('notFoundDeprecatedReplacementExtension', \"Can't install '{0}' extension since it was deprecated and the replacement extension '{1}' can't be found.\", extension.identifier.id, deprecationInfo.extension.id), ExtensionManagementErrorCode.Deprecated);\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tif (!await this.canInstall(extension)) {\n\t\t\t\tconst targetPlatform = await this.getTargetPlatform();\n\t\t\t\tthrow new ExtensionManagementError(nls.localize('incompatible platform', \"The '{0}' extension is not available in {1} for {2}.\", extension.identifier.id, this.productService.nameLong, TargetPlatformToString(targetPlatform)), ExtensionManagementErrorCode.IncompatibleTargetPlatform);\n\t\t\t}\n\n\t\t\tcompatibleExtension = await this.getCompatibleVersion(extension, sameVersion, installPreRelease, productVersion);\n\t\t\tif (!compatibleExtension) {\n\t\t\t\tconst incompatibleApiProposalsMessages: string[] = [];\n\t\t\t\tif (!areApiProposalsCompatible(extension.properties.enabledApiProposals ?? [], incompatibleApiProposalsMessages)) {\n\t\t\t\t\tthrow new ExtensionManagementError(nls.localize('incompatibleAPI', \"Can't install '{0}' extension. {1}\", extension.displayName ?? extension.identifier.id, incompatibleApiProposalsMessages[0]), ExtensionManagementErrorCode.IncompatibleApi);\n\t\t\t\t}\n\t\t\t\t/** If no compatible release version is found, check if the extension has a release version or not and throw relevant error */\n\t\t\t\tif (!installPreRelease && extension.properties.isPreReleaseVersion && (await this.galleryService.getExtensions([extension.identifier], CancellationToken.None))[0]) {\n\t\t\t\t\tthrow new ExtensionManagementError(nls.localize('notFoundReleaseExtension', \"Can't install release version of '{0}' extension because it has no release version.\", extension.displayName ?? extension.identifier.id), ExtensionManagementErrorCode.ReleaseVersionNotFound);\n\t\t\t\t}\n\t\t\t\tthrow new ExtensionManagementError(nls.localize('notFoundCompatibleDependency', \"Can't install '{0}' extension because it is not compatible with the current version of {1} (version {2}).\", extension.identifier.id, this.productService.nameLong, this.productService.version), ExtensionManagementErrorCode.Incompatible);\n\t\t\t}\n\t\t}\n\n\t\tthis.logService.info('Getting Manifest...', compatibleExtension.identifier.id);\n\t\tconst manifest = await this.galleryService.getManifest(compatibleExtension, CancellationToken.None);\n\t\tif (manifest === null) {\n\t\t\tthrow new ExtensionManagementError(`Missing manifest for extension ${compatibleExtension.identifier.id}`, ExtensionManagementErrorCode.Invalid);\n\t\t}\n\n\t\tif (manifest.version !== compatibleExtension.version) {\n\t\t\tthrow new ExtensionManagementError(`Cannot install '${compatibleExtension.identifier.id}' extension because of version mismatch in Marketplace`, ExtensionManagementErrorCode.Invalid);\n\t\t}\n\n\t\treturn { extension: compatibleExtension, manifest };\n\t}\n\n\tprotected async getCompatibleVersion(extension: IGalleryExtension, sameVersion: boolean, includePreRelease: boolean, productVersion: IProductVersion): Promise<IGalleryExtension | null> {\n\t\tconst targetPlatform = await this.getTargetPlatform();\n\t\tlet compatibleExtension: IGalleryExtension | null = null;\n\n\t\tif (!sameVersion && extension.hasPreReleaseVersion && extension.properties.isPreReleaseVersion !== includePreRelease) {\n\t\t\tcompatibleExtension = (await this.galleryService.getExtensions([{ ...extension.identifier, preRelease: includePreRelease }], { targetPlatform, compatible: true, productVersion }, CancellationToken.None))[0] || null;\n\t\t}\n\n\t\tif (!compatibleExtension && await this.galleryService.isExtensionCompatible(extension, includePreRelease, targetPlatform, productVersion)) {\n\t\t\tcompatibleExtension = extension;\n\t\t}\n\n\t\tif (!compatibleExtension) {\n\t\t\tif (sameVersion) {\n\t\t\t\tcompatibleExtension = (await this.galleryService.getExtensions([{ ...extension.identifier, version: extension.version }], { targetPlatform, compatible: true, productVersion }, CancellationToken.None))[0] || null;\n\t\t\t} else {\n\t\t\t\tcompatibleExtension = await this.galleryService.getCompatibleExtension(extension, includePreRelease, targetPlatform, productVersion);\n\t\t\t}\n\t\t}\n\n\t\treturn compatibleExtension;\n\t}\n\n\tasync uninstallExtensions(extensions: UninstallExtensionInfo[]): Promise<void> {\n\n\t\tconst getUninstallExtensionTaskKey = (extension: ILocalExtension, uninstallOptions: UninstallExtensionTaskOptions) => `${extension.identifier.id.toLowerCase()}${uninstallOptions.versionOnly ? `-${extension.manifest.version}` : ''}@${uninstallOptions.profileLocation.toString()}`;\n\n\t\tconst createUninstallExtensionTask = (extension: ILocalExtension, uninstallOptions: UninstallExtensionTaskOptions): IUninstallExtensionTask => {\n\t\t\tconst uninstallExtensionTask = this.createUninstallExtensionTask(extension, uninstallOptions);\n\t\t\tthis.uninstallingExtensions.set(getUninstallExtensionTaskKey(uninstallExtensionTask.extension, uninstallOptions), uninstallExtensionTask);\n\t\t\tthis.logService.info('Uninstalling extension from the profile:', `${extension.identifier.id}@${extension.manifest.version}`, uninstallOptions.profileLocation.toString());\n\t\t\tthis._onUninstallExtension.fire({ identifier: extension.identifier, profileLocation: uninstallOptions.profileLocation, applicationScoped: extension.isApplicationScoped });\n\t\t\treturn uninstallExtensionTask;\n\t\t};\n\n\t\tconst postUninstallExtension = (extension: ILocalExtension, uninstallOptions: UninstallExtensionTaskOptions, error?: ExtensionManagementError): void => {\n\t\t\tif (error) {\n\t\t\t\tthis.logService.error('Failed to uninstall extension from the profile:', `${extension.identifier.id}@${extension.manifest.version}`, uninstallOptions.profileLocation.toString(), error.message);\n\t\t\t} else {\n\t\t\t\tthis.logService.info('Successfully uninstalled extension from the profile', `${extension.identifier.id}@${extension.manifest.version}`, uninstallOptions.profileLocation.toString());\n\t\t\t}\n\t\t\treportTelemetry(this.telemetryService, 'extensionGallery:uninstall', { extensionData: getLocalExtensionTelemetryData(extension), error });\n\t\t\tthis._onDidUninstallExtension.fire({ identifier: extension.identifier, error: error?.code, profileLocation: uninstallOptions.profileLocation, applicationScoped: extension.isApplicationScoped });\n\t\t};\n\n\t\tconst allTasks: IUninstallExtensionTask[] = [];\n\t\tconst processedTasks: IUninstallExtensionTask[] = [];\n\t\tconst alreadyRequestedUninstalls: Promise<any>[] = [];\n\n\t\tconst installedExtensionsMap = new ResourceMap<ILocalExtension[]>();\n\n\t\tfor (const { extension, options } of extensions) {\n\t\t\tconst uninstallOptions: UninstallExtensionTaskOptions = {\n\t\t\t\t...options,\n\t\t\t\tprofileLocation: extension.isApplicationScoped ? this.userDataProfilesService.defaultProfile.extensionsResource : options?.profileLocation ?? this.getCurrentExtensionsManifestLocation()\n\t\t\t};\n\t\t\tconst uninstallExtensionTask = this.uninstallingExtensions.get(getUninstallExtensionTaskKey(extension, uninstallOptions));\n\t\t\tif (uninstallExtensionTask) {\n\t\t\t\tthis.logService.info('Extensions is already requested to uninstall', extension.identifier.id);\n\t\t\t\talreadyRequestedUninstalls.push(uninstallExtensionTask.waitUntilTaskIsFinished());\n\t\t\t} else {\n\t\t\t\tallTasks.push(createUninstallExtensionTask(extension, uninstallOptions));\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tfor (const task of allTasks.slice(0)) {\n\t\t\t\tlet installed = installedExtensionsMap.get(task.options.profileLocation);\n\t\t\t\tif (!installed) {\n\t\t\t\t\tinstalledExtensionsMap.set(task.options.profileLocation, installed = await this.getInstalled(ExtensionType.User, task.options.profileLocation));\n\t\t\t\t}\n\n\t\t\t\tif (task.options.donotIncludePack) {\n\t\t\t\t\tthis.logService.info('Uninstalling the extension without including packed extension', `${task.extension.identifier.id}@${task.extension.manifest.version}`);\n\t\t\t\t} else {\n\t\t\t\t\tconst packedExtensions = this.getAllPackExtensionsToUninstall(task.extension, installed);\n\t\t\t\t\tfor (const packedExtension of packedExtensions) {\n\t\t\t\t\t\tif (this.uninstallingExtensions.has(getUninstallExtensionTaskKey(packedExtension, task.options))) {\n\t\t\t\t\t\t\tthis.logService.info('Extensions is already requested to uninstall', packedExtension.identifier.id);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tallTasks.push(createUninstallExtensionTask(packedExtension, task.options));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (task.options.donotCheckDependents) {\n\t\t\t\t\tthis.logService.info('Uninstalling the extension without checking dependents', `${task.extension.identifier.id}@${task.extension.manifest.version}`);\n\t\t\t\t} else {\n\t\t\t\t\tthis.checkForDependents(allTasks.map(task => task.extension), installed, task.extension);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Uninstall extensions in parallel and wait until all extensions are uninstalled / failed\n\t\t\tawait this.joinAllSettled(allTasks.map(async task => {\n\t\t\t\ttry {\n\t\t\t\t\tawait task.run();\n\t\t\t\t\tawait this.joinAllSettled(this.participants.map(participant => participant.postUninstall(task.extension, task.options, CancellationToken.None)));\n\t\t\t\t\t// only report if extension has a mapped gallery extension. UUID identifies the gallery extension.\n\t\t\t\t\tif (task.extension.identifier.uuid) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait this.galleryService.reportStatistic(task.extension.manifest.publisher, task.extension.manifest.name, task.extension.manifest.version, StatisticType.Uninstall);\n\t\t\t\t\t\t} catch (error) { /* ignore */ }\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconst error = toExtensionManagementError(e);\n\t\t\t\t\tpostUninstallExtension(task.extension, task.options, error);\n\t\t\t\t\tthrow error;\n\t\t\t\t} finally {\n\t\t\t\t\tprocessedTasks.push(task);\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tif (alreadyRequestedUninstalls.length) {\n\t\t\t\tawait this.joinAllSettled(alreadyRequestedUninstalls);\n\t\t\t}\n\n\t\t\tfor (const task of allTasks) {\n\t\t\t\tpostUninstallExtension(task.extension, task.options);\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconst error = toExtensionManagementError(e);\n\t\t\tfor (const task of allTasks) {\n\t\t\t\t// cancel the tasks\n\t\t\t\ttry { task.cancel(); } catch (error) { /* ignore */ }\n\t\t\t\tif (!processedTasks.includes(task)) {\n\t\t\t\t\tpostUninstallExtension(task.extension, task.options, error);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow error;\n\t\t} finally {\n\t\t\t// Remove tasks from cache\n\t\t\tfor (const task of allTasks) {\n\t\t\t\tif (!this.uninstallingExtensions.delete(getUninstallExtensionTaskKey(task.extension, task.options))) {\n\t\t\t\t\tthis.logService.warn('Uninstallation task is not found in the cache', task.extension.identifier.id);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate checkForDependents(extensionsToUninstall: ILocalExtension[], installed: ILocalExtension[], extensionToUninstall: ILocalExtension): void {\n\t\tfor (const extension of extensionsToUninstall) {\n\t\t\tconst dependents = this.getDependents(extension, installed);\n\t\t\tif (dependents.length) {\n\t\t\t\tconst remainingDependents = dependents.filter(dependent => !extensionsToUninstall.some(e => areSameExtensions(e.identifier, dependent.identifier)));\n\t\t\t\tif (remainingDependents.length) {\n\t\t\t\t\tthrow new Error(this.getDependentsErrorMessage(extension, remainingDependents, extensionToUninstall));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate getDependentsErrorMessage(dependingExtension: ILocalExtension, dependents: ILocalExtension[], extensionToUninstall: ILocalExtension): string {\n\t\tif (extensionToUninstall === dependingExtension) {\n\t\t\tif (dependents.length === 1) {\n\t\t\t\treturn nls.localize('singleDependentError', \"Cannot uninstall '{0}' extension. '{1}' extension depends on this.\",\n\t\t\t\t\textensionToUninstall.manifest.displayName || extensionToUninstall.manifest.name, dependents[0].manifest.displayName || dependents[0].manifest.name);\n\t\t\t}\n\t\t\tif (dependents.length === 2) {\n\t\t\t\treturn nls.localize('twoDependentsError', \"Cannot uninstall '{0}' extension. '{1}' and '{2}' extensions depend on this.\",\n\t\t\t\t\textensionToUninstall.manifest.displayName || extensionToUninstall.manifest.name, dependents[0].manifest.displayName || dependents[0].manifest.name, dependents[1].manifest.displayName || dependents[1].manifest.name);\n\t\t\t}\n\t\t\treturn nls.localize('multipleDependentsError', \"Cannot uninstall '{0}' extension. '{1}', '{2}' and other extension depend on this.\",\n\t\t\t\textensionToUninstall.manifest.displayName || extensionToUninstall.manifest.name, dependents[0].manifest.displayName || dependents[0].manifest.name, dependents[1].manifest.displayName || dependents[1].manifest.name);\n\t\t}\n\t\tif (dependents.length === 1) {\n\t\t\treturn nls.localize('singleIndirectDependentError', \"Cannot uninstall '{0}' extension . It includes uninstalling '{1}' extension and '{2}' extension depends on this.\",\n\t\t\t\textensionToUninstall.manifest.displayName || extensionToUninstall.manifest.name, dependingExtension.manifest.displayName\n\t\t\t|| dependingExtension.manifest.name, dependents[0].manifest.displayName || dependents[0].manifest.name);\n\t\t}\n\t\tif (dependents.length === 2) {\n\t\t\treturn nls.localize('twoIndirectDependentsError', \"Cannot uninstall '{0}' extension. It includes uninstalling '{1}' extension and '{2}' and '{3}' extensions depend on this.\",\n\t\t\t\textensionToUninstall.manifest.displayName || extensionToUninstall.manifest.name, dependingExtension.manifest.displayName\n\t\t\t|| dependingExtension.manifest.name, dependents[0].manifest.displayName || dependents[0].manifest.name, dependents[1].manifest.displayName || dependents[1].manifest.name);\n\t\t}\n\t\treturn nls.localize('multipleIndirectDependentsError', \"Cannot uninstall '{0}' extension. It includes uninstalling '{1}' extension and '{2}', '{3}' and other extensions depend on this.\",\n\t\t\textensionToUninstall.manifest.displayName || extensionToUninstall.manifest.name, dependingExtension.manifest.displayName\n\t\t|| dependingExtension.manifest.name, dependents[0].manifest.displayName || dependents[0].manifest.name, dependents[1].manifest.displayName || dependents[1].manifest.name);\n\n\t}\n\n\tprivate getAllPackExtensionsToUninstall(extension: ILocalExtension, installed: ILocalExtension[], checked: ILocalExtension[] = []): ILocalExtension[] {\n\t\tif (checked.indexOf(extension) !== -1) {\n\t\t\treturn [];\n\t\t}\n\t\tchecked.push(extension);\n\t\tconst extensionsPack = extension.manifest.extensionPack ? extension.manifest.extensionPack : [];\n\t\tif (extensionsPack.length) {\n\t\t\tconst packedExtensions = installed.filter(i => !i.isBuiltin && extensionsPack.some(id => areSameExtensions({ id }, i.identifier)));\n\t\t\tconst packOfPackedExtensions: ILocalExtension[] = [];\n\t\t\tfor (const packedExtension of packedExtensions) {\n\t\t\t\tpackOfPackedExtensions.push(...this.getAllPackExtensionsToUninstall(packedExtension, installed, checked));\n\t\t\t}\n\t\t\treturn [...packedExtensions, ...packOfPackedExtensions];\n\t\t}\n\t\treturn [];\n\t}\n\n\tprivate getDependents(extension: ILocalExtension, installed: ILocalExtension[]): ILocalExtension[] {\n\t\treturn installed.filter(e => e.manifest.extensionDependencies && e.manifest.extensionDependencies.some(id => areSameExtensions({ id }, extension.identifier)));\n\t}\n\n\tprivate async updateControlCache(): Promise<IExtensionsControlManifest> {\n\t\ttry {\n\t\t\tthis.logService.trace('ExtensionManagementService.updateControlCache');\n\t\t\treturn await this.galleryService.getExtensionsControlManifest();\n\t\t} catch (err) {\n\t\t\tthis.logService.trace('ExtensionManagementService.refreshControlCache - failed to get extension control manifest', getErrorMessage(err));\n\t\t\treturn { malicious: [], deprecated: {}, search: [] };\n\t\t}\n\t}\n\n\tabstract getTargetPlatform(): Promise<TargetPlatform>;\n\tabstract zip(extension: ILocalExtension): Promise<URI>;\n\tabstract getManifest(vsix: URI): Promise<IExtensionManifest>;\n\tabstract install(vsix: URI, options?: InstallOptions): Promise<ILocalExtension>;\n\tabstract installFromLocation(location: URI, profileLocation: URI): Promise<ILocalExtension>;\n\tabstract installExtensionsFromProfile(extensions: IExtensionIdentifier[], fromProfileLocation: URI, toProfileLocation: URI): Promise<ILocalExtension[]>;\n\tabstract getInstalled(type?: ExtensionType, profileLocation?: URI, productVersion?: IProductVersion): Promise<ILocalExtension[]>;\n\tabstract copyExtensions(fromProfileLocation: URI, toProfileLocation: URI): Promise<void>;\n\tabstract download(extension: IGalleryExtension, operation: InstallOperation, donotVerifySignature: boolean): Promise<URI>;\n\tabstract reinstallFromGallery(extension: ILocalExtension): Promise<ILocalExtension>;\n\tabstract cleanUp(): Promise<void>;\n\n\tabstract updateMetadata(local: ILocalExtension, metadata: Partial<Metadata>, profileLocation: URI): Promise<ILocalExtension>;\n\n\tprotected abstract getCurrentExtensionsManifestLocation(): URI;\n\tprotected abstract createInstallExtensionTask(manifest: IExtensionManifest, extension: URI | IGalleryExtension, options: InstallExtensionTaskOptions): IInstallExtensionTask;\n\tprotected abstract createUninstallExtensionTask(extension: ILocalExtension, options: UninstallExtensionTaskOptions): IUninstallExtensionTask;\n\tprotected abstract copyExtension(extension: ILocalExtension, fromProfileLocation: URI, toProfileLocation: URI, metadata?: Partial<Metadata>): Promise<ILocalExtension>;\n}\n\nexport function toExtensionManagementError(error: Error, code?: ExtensionManagementErrorCode): ExtensionManagementError {\n\tif (error instanceof ExtensionManagementError) {\n\t\treturn error;\n\t}\n\tlet extensionManagementError: ExtensionManagementError;\n\tif (error instanceof ExtensionGalleryError) {\n\t\textensionManagementError = new ExtensionManagementError(error.message, error.code === ExtensionGalleryErrorCode.DownloadFailedWriting ? ExtensionManagementErrorCode.DownloadFailedWriting : ExtensionManagementErrorCode.Gallery);\n\t} else {\n\t\textensionManagementError = new ExtensionManagementError(error.message, isCancellationError(error) ? ExtensionManagementErrorCode.Cancelled : (code ?? ExtensionManagementErrorCode.Internal));\n\t}\n\textensionManagementError.stack = error.stack;\n\treturn extensionManagementError;\n}\n\nfunction reportTelemetry(telemetryService: ITelemetryService, eventName: string,\n\t{\n\t\textensionData,\n\t\tverificationStatus,\n\t\tduration,\n\t\terror,\n\t\tsource,\n\t\tdurationSinceUpdate\n\t}: {\n\t\textensionData: any;\n\t\tverificationStatus?: ExtensionSignatureVerificationCode;\n\t\tduration?: number;\n\t\tdurationSinceUpdate?: number;\n\t\tsource?: string;\n\t\terror?: ExtensionManagementError | ExtensionGalleryError;\n\t}): void {\n\n\t/* __GDPR__\n\t\t\"extensionGallery:install\" : {\n\t\t\t\"owner\": \"sandy081\",\n\t\t\t\"success\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\t\"duration\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\t\"durationSinceUpdate\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n\t\t\t\"errorcode\": { \"classification\": \"CallstackOrException\", \"purpose\": \"PerformanceAndHealth\" },\n\t\t\t\"recommendationReason\": { \"retiredFromVersion\": \"1.23.0\", \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n\t\t\t\"verificationStatus\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n\t\t\t\"source\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n\t\t\t\"${include}\": [\n\t\t\t\t\"${GalleryExtensionTelemetryData}\"\n\t\t\t]\n\t\t}\n\t*/\n\t/* __GDPR__\n\t\t\"extensionGallery:uninstall\" : {\n\t\t\t\"owner\": \"sandy081\",\n\t\t\t\"success\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\t\"duration\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\t\"errorcode\": { \"classification\": \"CallstackOrException\", \"purpose\": \"PerformanceAndHealth\" },\n\t\t\t\"${include}\": [\n\t\t\t\t\"${GalleryExtensionTelemetryData}\"\n\t\t\t]\n\t\t}\n\t*/\n\t/* __GDPR__\n\t\t\"extensionGallery:update\" : {\n\t\t\t\"owner\": \"sandy081\",\n\t\t\t\"success\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\t\"duration\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\t\"errorcode\": { \"classification\": \"CallstackOrException\", \"purpose\": \"PerformanceAndHealth\" },\n\t\t\t\"verificationStatus\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n\t\t\t\"source\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n\t\t\t\"${include}\": [\n\t\t\t\t\"${GalleryExtensionTelemetryData}\"\n\t\t\t]\n\t\t}\n\t*/\n\ttelemetryService.publicLog(eventName, {\n\t\t...extensionData,\n\t\tsource,\n\t\tduration,\n\t\tdurationSinceUpdate,\n\t\tsuccess: !error,\n\t\terrorcode: error?.code,\n\t\tverificationStatus: verificationStatus === ExtensionSignatureVerificationCode.Success ? 'Verified' : (verificationStatus ?? 'Unverified')\n\t});\n}\n\nexport abstract class AbstractExtensionTask<T> {\n\n\tprivate readonly barrier = new Barrier();\n\tprivate cancellablePromise: CancelablePromise<T> | undefined;\n\n\tasync waitUntilTaskIsFinished(): Promise<T> {\n\t\tawait this.barrier.wait();\n\t\treturn this.cancellablePromise!;\n\t}\n\n\trun(): Promise<T> {\n\t\tif (!this.cancellablePromise) {\n\t\t\tthis.cancellablePromise = createCancelablePromise(token => this.doRun(token));\n\t\t}\n\t\tthis.barrier.open();\n\t\treturn this.cancellablePromise;\n\t}\n\n\tcancel(): void {\n\t\tif (!this.cancellablePromise) {\n\t\t\tthis.cancellablePromise = createCancelablePromise(token => {\n\t\t\t\treturn new Promise((c, e) => {\n\t\t\t\t\tconst disposable = token.onCancellationRequested(() => {\n\t\t\t\t\t\tdisposable.dispose();\n\t\t\t\t\t\te(new CancellationError());\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t\tthis.barrier.open();\n\t\t}\n\t\tthis.cancellablePromise.cancel();\n\t}\n\n\tprotected abstract doRun(token: CancellationToken): Promise<T>;\n}\n"],
  "mappings": "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",
  "names": ["result", "gallery", "error", "extensionIdentifier", "manifest", "task"]
}
