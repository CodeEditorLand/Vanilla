var S=Object.defineProperty;var I=Object.getOwnPropertyDescriptor;var h=(c,a,e,t)=>{for(var r=t>1?void 0:t?I(a,e):a,i=c.length-1,o;i>=0;i--)(o=c[i])&&(r=(t?o(a,e,r):o(r))||r);return t&&r&&S(a,e,r),r},d=(c,a)=>(e,t)=>a(e,t,c);import{StringDecoder as y}from"string_decoder";import{app as C,MessageChannelMain as _,utilityProcess as x}from"electron";import{timeout as M}from"../../../base/common/async.js";import{Emitter as p,Event as l}from"../../../base/common/event.js";import{Disposable as U}from"../../../base/common/lifecycle.js";import{FileAccess as k}from"../../../base/common/network.js";import{deepClone as D}from"../../../base/common/objects.js";import{isWindows as L}from"../../../base/common/platform.js";import{removeDangerousEnvVariables as A}from"../../../base/common/processes.js";import s from"../../../base/common/severity.js";import{upcast as N}from"../../../base/common/types.js";import{getUNCHostAllowlist as O,isUNCAccessRestrictionsDisabled as T}from"../../../base/node/unc.js";import{ILifecycleMainService as u}from"../../lifecycle/electron-main/lifecycleMainService.js";import{ILogService as g}from"../../log/common/log.js";import{ITelemetryService as m}from"../../telemetry/common/telemetry.js";import{IWindowsMainService as W}from"../../windows/electron-main/windows.js";function R(c){return typeof c.responseWindowId=="number"}let n=class extends U{constructor(e,t,r){super();this.logService=e;this.telemetryService=t;this.lifecycleMainService=r}static ID_COUNTER=0;static all=new Map;static getAll(){return Array.from(n.all.values())}id=String(++n.ID_COUNTER);_onStdout=this._register(new p);onStdout=this._onStdout.event;_onStderr=this._register(new p);onStderr=this._onStderr.event;_onMessage=this._register(new p);onMessage=this._onMessage.event;_onSpawn=this._register(new p);onSpawn=this._onSpawn.event;_onExit=this._register(new p);onExit=this._onExit.event;_onCrash=this._register(new p);onCrash=this._onCrash.event;process=void 0;processPid=void 0;configuration=void 0;killed=!1;log(e,t){let r;switch(this.configuration?.correlationId?r=`[UtilityProcess id: ${this.configuration?.correlationId}, type: ${this.configuration?.type}, pid: ${this.processPid??"<none>"}]: ${e}`:r=`[UtilityProcess type: ${this.configuration?.type}, pid: ${this.processPid??"<none>"}]: ${e}`,t){case s.Error:this.logService.error(r);break;case s.Warning:this.logService.warn(r);break;case s.Info:this.logService.trace(r);break}}validateCanStart(){return this.process?(this.log("Cannot start utility process because it is already running...",s.Error),!1):!0}start(e){const t=this.doStart(e);return t&&e.payload&&this.postMessage(e.payload)&&this.log("payload sent via postMessage()",s.Info),t}doStart(e){if(!this.validateCanStart())return!1;this.configuration=e;const t=`${this.configuration.type}-${this.id}`,r=k.asFileUri("bootstrap-fork.js").fsPath,i=this.configuration.args??[],o=this.configuration.execArgv??[],v=this.configuration.allowLoadingUnsignedLibraries,w=this.configuration.forceAllocationsToV8Sandbox,E=this.configuration.respondToAuthRequestsFromMainProcess,P="pipe",b=this.createEnv(e);return this.log("creating new...",s.Info),this.process=x.fork(r,i,N({serviceName:t,env:b,execArgv:o,allowLoadingUnsignedLibraries:v,forceAllocationsToV8Sandbox:w,respondToAuthRequestsFromMainProcess:E,stdio:P})),this.registerListeners(this.process,this.configuration,t),!0}createEnv(e){const t=e.env?{...e.env}:{...D(process.env)};t.VSCODE_AMD_ENTRYPOINT=e.entryPoint,typeof e.parentLifecycleBound=="number"&&(t.VSCODE_PARENT_PID=String(e.parentLifecycleBound)),t.VSCODE_CRASH_REPORTER_PROCESS_TYPE=e.type,L&&(T()?t.NODE_DISABLE_UNC_ACCESS_CHECKS="1":t.NODE_UNC_HOST_ALLOWLIST=O().join("\\")),A(t);for(const r of Object.keys(t))t[r]=String(t[r]);return t}registerListeners(e,t,r){if(e.stdout){const i=new y("utf-8");this._register(l.fromNodeEventEmitter(e.stdout,"data")(o=>this._onStdout.fire(typeof o=="string"?o:i.write(o))))}if(e.stderr){const i=new y("utf-8");this._register(l.fromNodeEventEmitter(e.stderr,"data")(o=>this._onStderr.fire(typeof o=="string"?o:i.write(o))))}this._register(l.fromNodeEventEmitter(e,"message")(i=>this._onMessage.fire(i))),this._register(l.fromNodeEventEmitter(e,"spawn")(()=>{this.processPid=e.pid,typeof e.pid=="number"&&n.all.set(e.pid,{pid:e.pid,name:R(t)?`${t.type} [${t.responseWindowId}]`:t.type}),this.log("successfully created",s.Info),this._onSpawn.fire(e.pid)})),this._register(l.fromNodeEventEmitter(e,"exit")(i=>{const o=this.isNormalExit(i)?0:i;this.log(`received exit event with code ${o}`,s.Info),this._onExit.fire({pid:this.processPid,code:o,signal:"unknown"}),this.onDidExitOrCrashOrKill()})),this._register(l.fromNodeEventEmitter(C,"child-process-gone",(i,o)=>({event:i,details:o}))(({details:i})=>{i.type==="Utility"&&i.name===r&&!this.isNormalExit(i.exitCode)&&(this.log(`crashed with code ${i.exitCode} and reason '${i.reason}'`,s.Error),this.telemetryService.publicLog2("utilityprocesscrash",{type:t.type,reason:i.reason,code:i.exitCode}),this._onCrash.fire({pid:this.processPid,code:i.exitCode,reason:i.reason}),this.onDidExitOrCrashOrKill())}))}once(e,t){const r=this._register(this._onMessage.event(i=>{i===e&&(r.dispose(),t())}))}postMessage(e,t){return this.process?(this.process.postMessage(e,t),!0):!1}connect(e){const{port1:t,port2:r}=new _;return this.postMessage(e,[r]),t}enableInspectPort(){if(!this.process||typeof this.processPid!="number")return!1;this.log("enabling inspect port",s.Info);const e=process;return typeof e._debugProcess=="function"?(e._debugProcess(this.processPid),!0):!1}kill(){if(!this.process)return;this.log("attempting to kill the process...",s.Info),this.process.kill()?(this.log("successfully killed the process",s.Info),this.killed=!0,this.onDidExitOrCrashOrKill()):this.log("unable to kill the process",s.Warning)}isNormalExit(e){return e===0?!0:this.killed&&e===15}onDidExitOrCrashOrKill(){typeof this.processPid=="number"&&n.all.delete(this.processPid),this.process=void 0}async waitForExit(e){this.process&&(this.log("waiting to exit...",s.Info),await Promise.race([l.toPromise(this.onExit),M(e)]),this.process&&(this.log(`did not exit within ${e}ms, will kill it now...`,s.Info),this.kill()))}};n=h([d(0,g),d(1,m),d(2,u)],n);let f=class extends n{constructor(e,t,r,i){super(e,r,i);this.windowsMainService=t}start(e){const t=this.windowsMainService.getWindowById(e.responseWindowId);if(!t?.win||t.win.isDestroyed()||t.win.webContents.isDestroyed())return this.log("Refusing to start utility process because requesting window cannot be found or is destroyed...",s.Error),!0;if(!super.doStart(e))return!1;this.registerWindowListeners(t.win,e);const i=this.connect(e.payload);return t.win.webContents.postMessage(e.responseChannel,e.responseNonce,[i]),!0}registerWindowListeners(e,t){t.windowLifecycleBound&&(this._register(l.filter(this.lifecycleMainService.onWillLoadWindow,r=>r.window.win===e)(()=>this.kill())),this._register(l.fromNodeEventEmitter(e,"closed")(()=>this.kill())))}};f=h([d(0,g),d(1,W),d(2,m),d(3,u)],f);export{n as UtilityProcess,f as WindowUtilityProcess};
