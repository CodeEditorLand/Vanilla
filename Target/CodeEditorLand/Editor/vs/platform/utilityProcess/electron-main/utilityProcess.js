var S=Object.defineProperty;var I=Object.getOwnPropertyDescriptor;var m=(p,d,e,t)=>{for(var i=t>1?void 0:t?I(d,e):d,r=p.length-1,s;r>=0;r--)(s=p[r])&&(i=(t?s(d,e,i):s(i))||i);return t&&i&&S(d,e,i),i},c=(p,d)=>(e,t)=>d(e,t,p);import{MessageChannelMain as C,app as x,utilityProcess as _}from"electron";import{Disposable as M}from"../../../base/common/lifecycle.js";import{Emitter as h,Event as n}from"../../../base/common/event.js";import{ILogService as v}from"../../log/common/log.js";import{StringDecoder as E}from"string_decoder";import{timeout as U}from"../../../base/common/async.js";import{FileAccess as k}from"../../../base/common/network.js";import{IWindowsMainService as D}from"../../windows/electron-main/windows.js";import o from"../../../base/common/severity.js";import{ITelemetryService as w}from"../../telemetry/common/telemetry.js";import{ILifecycleMainService as P}from"../../lifecycle/electron-main/lifecycleMainService.js";import{removeDangerousEnvVariables as O}from"../../../base/common/processes.js";import{deepClone as L}from"../../../base/common/objects.js";import{isWindows as N}from"../../../base/common/platform.js";import{isUNCAccessRestrictionsDisabled as A,getUNCHostAllowlist as T}from"../../../base/node/unc.js";import{upcast as W}from"../../../base/common/types.js";function $(p){return typeof p.responseWindowId=="number"}let a=class extends M{constructor(e,t,i){super();this.logService=e;this.telemetryService=t;this.lifecycleMainService=i}static ID_COUNTER=0;static all=new Map;static getAll(){return Array.from(a.all.values())}id=String(++a.ID_COUNTER);_onStdout=this._register(new h);onStdout=this._onStdout.event;_onStderr=this._register(new h);onStderr=this._onStderr.event;_onMessage=this._register(new h);onMessage=this._onMessage.event;_onSpawn=this._register(new h);onSpawn=this._onSpawn.event;_onExit=this._register(new h);onExit=this._onExit.event;_onCrash=this._register(new h);onCrash=this._onCrash.event;process=void 0;processPid=void 0;configuration=void 0;killed=!1;log(e,t){let i;switch(this.configuration?.correlationId?i=`[UtilityProcess id: ${this.configuration?.correlationId}, type: ${this.configuration?.type}, pid: ${this.processPid??"<none>"}]: ${e}`:i=`[UtilityProcess type: ${this.configuration?.type}, pid: ${this.processPid??"<none>"}]: ${e}`,t){case o.Error:this.logService.error(i);break;case o.Warning:this.logService.warn(i);break;case o.Info:this.logService.trace(i);break}}validateCanStart(){return this.process?(this.log("Cannot start utility process because it is already running...",o.Error),!1):!0}start(e){const t=this.doStart(e);return t&&e.payload&&this.postMessage(e.payload)&&this.log("payload sent via postMessage()",o.Info),t}doStart(e){if(!this.validateCanStart())return!1;this.configuration=e;const t=`${this.configuration.type}-${this.id}`,i=k.asFileUri("bootstrap-fork.js").fsPath,r=this.configuration.args??[],s=this.configuration.execArgv??[],f=this.configuration.allowLoadingUnsignedLibraries,y=this.configuration.respondToAuthRequestsFromMainProcess,g="pipe",l=this.createEnv(e);return this.log("creating new...",o.Info),this.process=_.fork(i,r,W({serviceName:t,env:l,execArgv:s,allowLoadingUnsignedLibraries:f,respondToAuthRequestsFromMainProcess:y,stdio:g})),this.registerListeners(this.process,this.configuration,t),!0}createEnv(e){const t=e.env?{...e.env}:{...L(process.env)};t.VSCODE_AMD_ENTRYPOINT=e.entryPoint,typeof e.parentLifecycleBound=="number"&&(t.VSCODE_PARENT_PID=String(e.parentLifecycleBound)),t.VSCODE_CRASH_REPORTER_PROCESS_TYPE=e.type,N&&(A()?t.NODE_DISABLE_UNC_ACCESS_CHECKS="1":t.NODE_UNC_HOST_ALLOWLIST=T().join("\\")),O(t);for(const i of Object.keys(t))t[i]=String(t[i]);return t}registerListeners(e,t,i){if(e.stdout){const r=new E("utf-8");this._register(n.fromNodeEventEmitter(e.stdout,"data")(s=>this._onStdout.fire(typeof s=="string"?s:r.write(s))))}if(e.stderr){const r=new E("utf-8");this._register(n.fromNodeEventEmitter(e.stderr,"data")(s=>this._onStderr.fire(typeof s=="string"?s:r.write(s))))}this._register(n.fromNodeEventEmitter(e,"message")(r=>this._onMessage.fire(r))),this._register(n.fromNodeEventEmitter(e,"spawn")(()=>{this.processPid=e.pid,typeof e.pid=="number"&&a.all.set(e.pid,{pid:e.pid,name:$(t)?`${t.type} [${t.responseWindowId}]`:t.type}),this.log("successfully created",o.Info),this._onSpawn.fire(e.pid)})),this._register(n.fromNodeEventEmitter(e,"exit")(r=>{const s=this.isNormalExit(r)?0:r;this.log(`received exit event with code ${s}`,o.Info),this._onExit.fire({pid:this.processPid,code:s,signal:"unknown"}),this.onDidExitOrCrashOrKill()})),this._register(n.fromNodeEventEmitter(e,"error",(r,s,f)=>({type:r,location:s,report:f}))(({type:r,location:s,report:f})=>{this.log(`crashed due to ${r} from V8 at ${s}`,o.Info);let y=[];try{y=JSON.parse(f).sharedObjects.filter(l=>l.endsWith(".node")).map(l=>{const b=l.indexOf("extensions")===-1?l.indexOf("node_modules"):l.indexOf("extensions");return l.substring(b)})}catch{}this.telemetryService.publicLog2("utilityprocessv8error",{processtype:t.type,error:r,location:s,addons:y})})),this._register(n.fromNodeEventEmitter(x,"child-process-gone",(r,s)=>({event:r,details:s}))(({details:r})=>{r.type==="Utility"&&r.name===i&&!this.isNormalExit(r.exitCode)&&(this.log(`crashed with code ${r.exitCode} and reason '${r.reason}'`,o.Error),this.telemetryService.publicLog2("utilityprocesscrash",{type:t.type,reason:r.reason,code:r.exitCode}),this._onCrash.fire({pid:this.processPid,code:r.exitCode,reason:r.reason}),this.onDidExitOrCrashOrKill())}))}once(e,t){const i=this._register(this._onMessage.event(r=>{r===e&&(i.dispose(),t())}))}postMessage(e,t){return this.process?(this.process.postMessage(e,t),!0):!1}connect(e){const{port1:t,port2:i}=new C;return this.postMessage(e,[i]),t}enableInspectPort(){if(!this.process||typeof this.processPid!="number")return!1;this.log("enabling inspect port",o.Info);const e=process;return typeof e._debugProcess=="function"?(e._debugProcess(this.processPid),!0):!1}kill(){if(!this.process)return;this.log("attempting to kill the process...",o.Info),this.process.kill()?(this.log("successfully killed the process",o.Info),this.killed=!0,this.onDidExitOrCrashOrKill()):this.log("unable to kill the process",o.Warning)}isNormalExit(e){return e===0?!0:this.killed&&e===15}onDidExitOrCrashOrKill(){typeof this.processPid=="number"&&a.all.delete(this.processPid),this.process=void 0}async waitForExit(e){this.process&&(this.log("waiting to exit...",o.Info),await Promise.race([n.toPromise(this.onExit),U(e)]),this.process&&(this.log(`did not exit within ${e}ms, will kill it now...`,o.Info),this.kill()))}};a=m([c(0,v),c(1,w),c(2,P)],a);let u=class extends a{constructor(e,t,i,r){super(e,i,r);this.windowsMainService=t}start(e){const t=this.windowsMainService.getWindowById(e.responseWindowId);if(!t?.win||t.win.isDestroyed()||t.win.webContents.isDestroyed())return this.log("Refusing to start utility process because requesting window cannot be found or is destroyed...",o.Error),!0;if(!super.doStart(e))return!1;this.registerWindowListeners(t.win,e);const r=this.connect(e.payload);return t.win.webContents.postMessage(e.responseChannel,e.responseNonce,[r]),!0}registerWindowListeners(e,t){t.windowLifecycleBound&&(this._register(n.filter(this.lifecycleMainService.onWillLoadWindow,i=>i.window.win===e)(()=>this.kill())),this._register(n.fromNodeEventEmitter(e,"closed")(()=>this.kill())))}};u=m([c(0,v),c(1,D),c(2,w),c(3,P)],u);export{a as UtilityProcess,u as WindowUtilityProcess};
