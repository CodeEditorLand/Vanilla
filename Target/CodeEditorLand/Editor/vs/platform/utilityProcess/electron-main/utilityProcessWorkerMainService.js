var f=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var y=(a,s,e,r)=>{for(var i=r>1?void 0:r?u(s,e):s,t=a.length-1,n;t>=0;t--)(n=a[t])&&(i=(r?n(s,e,i):n(i))||i);return r&&i&&f(s,e,i),i},o=(a,s)=>(e,r)=>s(e,r,a);import{DeferredPromise as g}from"../../../base/common/async.js";import{Emitter as S,Event as k}from"../../../base/common/event.js";import{hash as W}from"../../../base/common/hash.js";import{Disposable as p}from"../../../base/common/lifecycle.js";import{IConfigurationService as w}from"../../configuration/common/configuration.js";import{createDecorator as P}from"../../instantiation/common/instantiation.js";import{ILifecycleMainService as v}from"../../lifecycle/electron-main/lifecycleMainService.js";import{ILogService as m}from"../../log/common/log.js";import{ITelemetryService as h}from"../../telemetry/common/telemetry.js";import{IWindowsMainService as I}from"../../windows/electron-main/windows.js";import{WindowUtilityProcess as U}from"./utilityProcess.js";const A=P("utilityProcessWorker");let d=class extends p{constructor(e,r,i,t,n){super();this.logService=e;this.windowsMainService=r;this.telemetryService=i;this.lifecycleMainService=t;this.configurationService=n}workers=new Map;async createWorker(e){const r=`window: ${e.reply.windowId}, moduleId: ${e.process.moduleId}`;this.logService.trace(`[UtilityProcessWorker]: createWorker(${r})`);const i=this.hash(e);this.workers.has(i)&&(this.logService.warn(`[UtilityProcessWorker]: createWorker() found an existing worker that will be terminated (${r})`),this.disposeWorker(e));const t=new l(this.logService,this.windowsMainService,this.telemetryService,this.lifecycleMainService,this.configurationService,e);if(!t.spawn())return{reason:{code:1,signal:"EINVALID"}};this.workers.set(i,t);const n=new g;return k.once(t.onDidTerminate)(c=>{c.code===0?this.logService.trace(`[UtilityProcessWorker]: terminated normally with code ${c.code}, signal: ${c.signal}`):this.logService.error(`[UtilityProcessWorker]: terminated unexpectedly with code ${c.code}, signal: ${c.signal}`),this.workers.delete(i),n.complete({reason:c})}),n.p}hash(e){return W({moduleId:e.process.moduleId,windowId:e.reply.windowId})}async disposeWorker(e){const r=this.hash(e),i=this.workers.get(r);i&&(this.logService.trace(`[UtilityProcessWorker]: disposeWorker(window: ${e.reply.windowId}, moduleId: ${e.process.moduleId})`),i.kill(),i.dispose(),this.workers.delete(r))}};d=y([o(0,m),o(1,I),o(2,h),o(3,v),o(4,w)],d);let l=class extends p{constructor(e,r,i,t,n,c){super();this.logService=e;this.windowsMainService=r;this.telemetryService=i;this.lifecycleMainService=t;this.configurationService=n;this.configuration=c;this.registerListeners()}_onDidTerminate=this._register(new S);onDidTerminate=this._onDidTerminate.event;utilityProcess=this._register(new U(this.logService,this.windowsMainService,this.telemetryService,this.lifecycleMainService));registerListeners(){this._register(this.utilityProcess.onExit(e=>this._onDidTerminate.fire({code:e.code,signal:e.signal}))),this._register(this.utilityProcess.onCrash(e=>this._onDidTerminate.fire({code:e.code,signal:"ECRASH"})))}spawn(){const r=this.windowsMainService.getWindowById(this.configuration.reply.windowId)?.win?.webContents.getOSProcessId();let i={type:this.configuration.process.type,entryPoint:this.configuration.process.moduleId,parentLifecycleBound:r,windowLifecycleBound:!0,correlationId:`${this.configuration.reply.windowId}`,responseWindowId:this.configuration.reply.windowId,responseChannel:this.configuration.reply.channel,responseNonce:this.configuration.reply.nonce};return this.configuration.process.type==="fileWatcher"&&this.configurationService.getValue("files.experimentalWatcherNext")===!0&&(i={...i,env:{VSCODE_USE_WATCHER2:"true"}}),this.utilityProcess.start(i)}kill(){this.utilityProcess.kill()}};l=y([o(0,m),o(1,I),o(2,h),o(3,v),o(4,w)],l);export{A as IUtilityProcessWorkerMainService,d as UtilityProcessWorkerMainService};
