{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/backup/electron-main/backupMainService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createHash } from \"crypto\";\nimport { isEqual } from \"../../../base/common/extpath.js\";\nimport { Schemas } from \"../../../base/common/network.js\";\nimport { join } from \"../../../base/common/path.js\";\nimport { isLinux } from \"../../../base/common/platform.js\";\nimport { extUriBiasedIgnorePathCase } from \"../../../base/common/resources.js\";\nimport { Promises, RimRafMode } from \"../../../base/node/pfs.js\";\nimport { IConfigurationService } from \"../../configuration/common/configuration.js\";\nimport { IEnvironmentMainService } from \"../../environment/electron-main/environmentMainService.js\";\nimport {\n\tHotExitConfiguration,\n\ttype IFilesConfiguration,\n} from \"../../files/common/files.js\";\nimport { ILogService } from \"../../log/common/log.js\";\nimport { IStateService } from \"../../state/node/state.js\";\nimport { isWorkspaceIdentifier } from \"../../workspace/common/workspace.js\";\nimport { createEmptyWorkspaceIdentifier } from \"../../workspaces/node/workspaces.js\";\nimport {\n\ttype IFolderBackupInfo,\n\ttype IWorkspaceBackupInfo,\n\tisFolderBackupInfo,\n} from \"../common/backup.js\";\nimport {\n\ttype IEmptyWindowBackupInfo,\n\ttype ISerializedBackupWorkspaces,\n\ttype ISerializedEmptyWindowBackupInfo,\n\ttype ISerializedFolderBackupInfo,\n\ttype ISerializedWorkspaceBackupInfo,\n\tdeserializeFolderInfos,\n\tdeserializeWorkspaceInfos,\n\tisEmptyWindowBackupInfo,\n} from \"../node/backup.js\";\nimport type { IBackupMainService } from \"./backup.js\";\n\nexport class BackupMainService implements IBackupMainService {\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate static readonly backupWorkspacesMetadataStorageKey =\n\t\t\"backupWorkspaces\";\n\n\tprotected backupHome = this.environmentMainService.backupHome;\n\n\tprivate workspaces: IWorkspaceBackupInfo[] = [];\n\tprivate folders: IFolderBackupInfo[] = [];\n\tprivate emptyWindows: IEmptyWindowBackupInfo[] = [];\n\n\t// Comparers for paths and resources that will\n\t// - ignore path casing on Windows/macOS\n\t// - respect path casing on Linux\n\tprivate readonly backupUriComparer = extUriBiasedIgnorePathCase;\n\tprivate readonly backupPathComparer = {\n\t\tisEqual: (pathA: string, pathB: string) =>\n\t\t\tisEqual(pathA, pathB, !isLinux),\n\t};\n\n\tconstructor(\n\t\t@IEnvironmentMainService private readonly environmentMainService: IEnvironmentMainService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IStateService private readonly stateService: IStateService\n\t) {\n\t}\n\n\tasync initialize(): Promise<void> {\n\t\t// read backup workspaces\n\t\tconst serializedBackupWorkspaces =\n\t\t\tthis.stateService.getItem<ISerializedBackupWorkspaces>(\n\t\t\t\tBackupMainService.backupWorkspacesMetadataStorageKey,\n\t\t\t) ?? { workspaces: [], folders: [], emptyWindows: [] };\n\n\t\t// validate empty workspaces backups first\n\t\tthis.emptyWindows = await this.validateEmptyWorkspaces(\n\t\t\tserializedBackupWorkspaces.emptyWindows,\n\t\t);\n\n\t\t// validate workspace backups\n\t\tthis.workspaces = await this.validateWorkspaces(\n\t\t\tdeserializeWorkspaceInfos(serializedBackupWorkspaces),\n\t\t);\n\n\t\t// validate folder backups\n\t\tthis.folders = await this.validateFolders(\n\t\t\tdeserializeFolderInfos(serializedBackupWorkspaces),\n\t\t);\n\n\t\t// store metadata in case some workspaces or folders have been removed\n\t\tthis.storeWorkspacesMetadata();\n\t}\n\n\tprotected getWorkspaceBackups(): IWorkspaceBackupInfo[] {\n\t\tif (this.isHotExitOnExitAndWindowClose()) {\n\t\t\t// Only non-folder windows are restored on main process launch when\n\t\t\t// hot exit is configured as onExitAndWindowClose.\n\t\t\treturn [];\n\t\t}\n\n\t\treturn this.workspaces.slice(0); // return a copy\n\t}\n\n\tprotected getFolderBackups(): IFolderBackupInfo[] {\n\t\tif (this.isHotExitOnExitAndWindowClose()) {\n\t\t\t// Only non-folder windows are restored on main process launch when\n\t\t\t// hot exit is configured as onExitAndWindowClose.\n\t\t\treturn [];\n\t\t}\n\n\t\treturn this.folders.slice(0); // return a copy\n\t}\n\n\tisHotExitEnabled(): boolean {\n\t\treturn this.getHotExitConfig() !== HotExitConfiguration.OFF;\n\t}\n\n\tprivate isHotExitOnExitAndWindowClose(): boolean {\n\t\treturn (\n\t\t\tthis.getHotExitConfig() ===\n\t\t\tHotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE\n\t\t);\n\t}\n\n\tprivate getHotExitConfig(): string {\n\t\tconst config =\n\t\t\tthis.configurationService.getValue<IFilesConfiguration>();\n\n\t\treturn config?.files?.hotExit || HotExitConfiguration.ON_EXIT;\n\t}\n\n\tgetEmptyWindowBackups(): IEmptyWindowBackupInfo[] {\n\t\treturn this.emptyWindows.slice(0); // return a copy\n\t}\n\n\tregisterWorkspaceBackup(workspaceInfo: IWorkspaceBackupInfo): string;\n\tregisterWorkspaceBackup(\n\t\tworkspaceInfo: IWorkspaceBackupInfo,\n\t\tmigrateFrom: string,\n\t): Promise<string>;\n\tregisterWorkspaceBackup(\n\t\tworkspaceInfo: IWorkspaceBackupInfo,\n\t\tmigrateFrom?: string,\n\t): string | Promise<string> {\n\t\tif (\n\t\t\t!this.workspaces.some(\n\t\t\t\t(workspace) =>\n\t\t\t\t\tworkspaceInfo.workspace.id === workspace.workspace.id,\n\t\t\t)\n\t\t) {\n\t\t\tthis.workspaces.push(workspaceInfo);\n\t\t\tthis.storeWorkspacesMetadata();\n\t\t}\n\n\t\tconst backupPath = join(this.backupHome, workspaceInfo.workspace.id);\n\n\t\tif (migrateFrom) {\n\t\t\treturn this.moveBackupFolder(backupPath, migrateFrom).then(\n\t\t\t\t() => backupPath,\n\t\t\t);\n\t\t}\n\n\t\treturn backupPath;\n\t}\n\n\tprivate async moveBackupFolder(\n\t\tbackupPath: string,\n\t\tmoveFromPath: string,\n\t): Promise<void> {\n\t\t// Target exists: make sure to convert existing backups to empty window backups\n\t\tif (await Promises.exists(backupPath)) {\n\t\t\tawait this.convertToEmptyWindowBackup(backupPath);\n\t\t}\n\n\t\t// When we have data to migrate from, move it over to the target location\n\t\tif (await Promises.exists(moveFromPath)) {\n\t\t\ttry {\n\t\t\t\tawait Promises.rename(\n\t\t\t\t\tmoveFromPath,\n\t\t\t\t\tbackupPath,\n\t\t\t\t\tfalse /* no retry */,\n\t\t\t\t);\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.error(\n\t\t\t\t\t`Backup: Could not move backup folder to new location: ${error.toString()}`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tregisterFolderBackup(folderInfo: IFolderBackupInfo): string {\n\t\tif (\n\t\t\t!this.folders.some((folder) =>\n\t\t\t\tthis.backupUriComparer.isEqual(\n\t\t\t\t\tfolderInfo.folderUri,\n\t\t\t\t\tfolder.folderUri,\n\t\t\t\t),\n\t\t\t)\n\t\t) {\n\t\t\tthis.folders.push(folderInfo);\n\t\t\tthis.storeWorkspacesMetadata();\n\t\t}\n\n\t\treturn join(this.backupHome, this.getFolderHash(folderInfo));\n\t}\n\n\tregisterEmptyWindowBackup(emptyWindowInfo: IEmptyWindowBackupInfo): string {\n\t\tif (\n\t\t\t!this.emptyWindows.some(\n\t\t\t\t(emptyWindow) =>\n\t\t\t\t\t!!emptyWindow.backupFolder &&\n\t\t\t\t\tthis.backupPathComparer.isEqual(\n\t\t\t\t\t\temptyWindow.backupFolder,\n\t\t\t\t\t\temptyWindowInfo.backupFolder,\n\t\t\t\t\t),\n\t\t\t)\n\t\t) {\n\t\t\tthis.emptyWindows.push(emptyWindowInfo);\n\t\t\tthis.storeWorkspacesMetadata();\n\t\t}\n\n\t\treturn join(this.backupHome, emptyWindowInfo.backupFolder);\n\t}\n\n\tprivate async validateWorkspaces(\n\t\trootWorkspaces: IWorkspaceBackupInfo[],\n\t): Promise<IWorkspaceBackupInfo[]> {\n\t\tif (!Array.isArray(rootWorkspaces)) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst seenIds: Set<string> = new Set();\n\t\tconst result: IWorkspaceBackupInfo[] = [];\n\n\t\t// Validate Workspaces\n\t\tfor (const workspaceInfo of rootWorkspaces) {\n\t\t\tconst workspace = workspaceInfo.workspace;\n\t\t\tif (!isWorkspaceIdentifier(workspace)) {\n\t\t\t\treturn []; // wrong format, skip all entries\n\t\t\t}\n\n\t\t\tif (!seenIds.has(workspace.id)) {\n\t\t\t\tseenIds.add(workspace.id);\n\n\t\t\t\tconst backupPath = join(this.backupHome, workspace.id);\n\t\t\t\tconst hasBackups = await this.doHasBackups(backupPath);\n\n\t\t\t\t// If the workspace has no backups, ignore it\n\t\t\t\tif (hasBackups) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tworkspace.configPath.scheme !== Schemas.file ||\n\t\t\t\t\t\t(await Promises.exists(workspace.configPath.fsPath))\n\t\t\t\t\t) {\n\t\t\t\t\t\tresult.push(workspaceInfo);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If the workspace has backups, but the target workspace is missing, convert backups to empty ones\n\t\t\t\t\t\tawait this.convertToEmptyWindowBackup(backupPath);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tawait this.deleteStaleBackup(backupPath);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate async validateFolders(\n\t\tfolderWorkspaces: IFolderBackupInfo[],\n\t): Promise<IFolderBackupInfo[]> {\n\t\tif (!Array.isArray(folderWorkspaces)) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst result: IFolderBackupInfo[] = [];\n\t\tconst seenIds: Set<string> = new Set();\n\t\tfor (const folderInfo of folderWorkspaces) {\n\t\t\tconst folderURI = folderInfo.folderUri;\n\t\t\tconst key = this.backupUriComparer.getComparisonKey(folderURI);\n\t\t\tif (!seenIds.has(key)) {\n\t\t\t\tseenIds.add(key);\n\n\t\t\t\tconst backupPath = join(\n\t\t\t\t\tthis.backupHome,\n\t\t\t\t\tthis.getFolderHash(folderInfo),\n\t\t\t\t);\n\t\t\t\tconst hasBackups = await this.doHasBackups(backupPath);\n\n\t\t\t\t// If the folder has no backups, ignore it\n\t\t\t\tif (hasBackups) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tfolderURI.scheme !== Schemas.file ||\n\t\t\t\t\t\t(await Promises.exists(folderURI.fsPath))\n\t\t\t\t\t) {\n\t\t\t\t\t\tresult.push(folderInfo);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If the folder has backups, but the target workspace is missing, convert backups to empty ones\n\t\t\t\t\t\tawait this.convertToEmptyWindowBackup(backupPath);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tawait this.deleteStaleBackup(backupPath);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate async validateEmptyWorkspaces(\n\t\temptyWorkspaces: IEmptyWindowBackupInfo[],\n\t): Promise<IEmptyWindowBackupInfo[]> {\n\t\tif (!Array.isArray(emptyWorkspaces)) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst result: IEmptyWindowBackupInfo[] = [];\n\t\tconst seenIds: Set<string> = new Set();\n\n\t\t// Validate Empty Windows\n\t\tfor (const backupInfo of emptyWorkspaces) {\n\t\t\tconst backupFolder = backupInfo.backupFolder;\n\t\t\tif (typeof backupFolder !== \"string\") {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tif (!seenIds.has(backupFolder)) {\n\t\t\t\tseenIds.add(backupFolder);\n\n\t\t\t\tconst backupPath = join(this.backupHome, backupFolder);\n\t\t\t\tif (await this.doHasBackups(backupPath)) {\n\t\t\t\t\tresult.push(backupInfo);\n\t\t\t\t} else {\n\t\t\t\t\tawait this.deleteStaleBackup(backupPath);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate async deleteStaleBackup(backupPath: string): Promise<void> {\n\t\ttry {\n\t\t\tawait Promises.rm(backupPath, RimRafMode.MOVE);\n\t\t} catch (error) {\n\t\t\tthis.logService.error(\n\t\t\t\t`Backup: Could not delete stale backup: ${error.toString()}`,\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate prepareNewEmptyWindowBackup(): IEmptyWindowBackupInfo {\n\t\t// We are asked to prepare a new empty window backup folder.\n\t\t// Empty windows backup folders are derived from a workspace\n\t\t// identifier, so we generate a new empty workspace identifier\n\t\t// until we found a unique one.\n\n\t\tlet emptyWorkspaceIdentifier = createEmptyWorkspaceIdentifier();\n\t\twhile (\n\t\t\tthis.emptyWindows.some(\n\t\t\t\t(emptyWindow) =>\n\t\t\t\t\t!!emptyWindow.backupFolder &&\n\t\t\t\t\tthis.backupPathComparer.isEqual(\n\t\t\t\t\t\temptyWindow.backupFolder,\n\t\t\t\t\t\temptyWorkspaceIdentifier.id,\n\t\t\t\t\t),\n\t\t\t)\n\t\t) {\n\t\t\temptyWorkspaceIdentifier = createEmptyWorkspaceIdentifier();\n\t\t}\n\n\t\treturn { backupFolder: emptyWorkspaceIdentifier.id };\n\t}\n\n\tprivate async convertToEmptyWindowBackup(\n\t\tbackupPath: string,\n\t): Promise<boolean> {\n\t\tconst newEmptyWindowBackupInfo = this.prepareNewEmptyWindowBackup();\n\n\t\t// Rename backupPath to new empty window backup path\n\t\tconst newEmptyWindowBackupPath = join(\n\t\t\tthis.backupHome,\n\t\t\tnewEmptyWindowBackupInfo.backupFolder,\n\t\t);\n\t\ttry {\n\t\t\tawait Promises.rename(\n\t\t\t\tbackupPath,\n\t\t\t\tnewEmptyWindowBackupPath,\n\t\t\t\tfalse /* no retry */,\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tthis.logService.error(\n\t\t\t\t`Backup: Could not rename backup folder: ${error.toString()}`,\n\t\t\t);\n\t\t\treturn false;\n\t\t}\n\t\tthis.emptyWindows.push(newEmptyWindowBackupInfo);\n\n\t\treturn true;\n\t}\n\n\tasync getDirtyWorkspaces(): Promise<\n\t\tArray<IWorkspaceBackupInfo | IFolderBackupInfo>\n\t> {\n\t\tconst dirtyWorkspaces: Array<IWorkspaceBackupInfo | IFolderBackupInfo> =\n\t\t\t[];\n\n\t\t// Workspaces with backups\n\t\tfor (const workspace of this.workspaces) {\n\t\t\tif (await this.hasBackups(workspace)) {\n\t\t\t\tdirtyWorkspaces.push(workspace);\n\t\t\t}\n\t\t}\n\n\t\t// Folders with backups\n\t\tfor (const folder of this.folders) {\n\t\t\tif (await this.hasBackups(folder)) {\n\t\t\t\tdirtyWorkspaces.push(folder);\n\t\t\t}\n\t\t}\n\n\t\treturn dirtyWorkspaces;\n\t}\n\n\tprivate hasBackups(\n\t\tbackupLocation:\n\t\t\t| IWorkspaceBackupInfo\n\t\t\t| IEmptyWindowBackupInfo\n\t\t\t| IFolderBackupInfo,\n\t): Promise<boolean> {\n\t\tlet backupPath: string;\n\n\t\t// Empty\n\t\tif (isEmptyWindowBackupInfo(backupLocation)) {\n\t\t\tbackupPath = join(this.backupHome, backupLocation.backupFolder);\n\t\t}\n\n\t\t// Folder\n\t\telse if (isFolderBackupInfo(backupLocation)) {\n\t\t\tbackupPath = join(\n\t\t\t\tthis.backupHome,\n\t\t\t\tthis.getFolderHash(backupLocation),\n\t\t\t);\n\t\t}\n\n\t\t// Workspace\n\t\telse {\n\t\t\tbackupPath = join(this.backupHome, backupLocation.workspace.id);\n\t\t}\n\n\t\treturn this.doHasBackups(backupPath);\n\t}\n\n\tprivate async doHasBackups(backupPath: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst backupSchemas = await Promises.readdir(backupPath);\n\n\t\t\tfor (const backupSchema of backupSchemas) {\n\t\t\t\ttry {\n\t\t\t\t\tconst backupSchemaChildren = await Promises.readdir(\n\t\t\t\t\t\tjoin(backupPath, backupSchema),\n\t\t\t\t\t);\n\t\t\t\t\tif (backupSchemaChildren.length > 0) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// invalid folder\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// backup path does not exist\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate storeWorkspacesMetadata(): void {\n\t\tconst serializedBackupWorkspaces: ISerializedBackupWorkspaces = {\n\t\t\tworkspaces: this.workspaces.map(\n\t\t\t\t({ workspace, remoteAuthority }) => {\n\t\t\t\t\tconst serializedWorkspaceBackupInfo: ISerializedWorkspaceBackupInfo =\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tid: workspace.id,\n\t\t\t\t\t\t\tconfigURIPath: workspace.configPath.toString(),\n\t\t\t\t\t\t};\n\n\t\t\t\t\tif (remoteAuthority) {\n\t\t\t\t\t\tserializedWorkspaceBackupInfo.remoteAuthority =\n\t\t\t\t\t\t\tremoteAuthority;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn serializedWorkspaceBackupInfo;\n\t\t\t\t},\n\t\t\t),\n\t\t\tfolders: this.folders.map(({ folderUri, remoteAuthority }) => {\n\t\t\t\tconst serializedFolderBackupInfo: ISerializedFolderBackupInfo =\n\t\t\t\t\t{\n\t\t\t\t\t\tfolderUri: folderUri.toString(),\n\t\t\t\t\t};\n\n\t\t\t\tif (remoteAuthority) {\n\t\t\t\t\tserializedFolderBackupInfo.remoteAuthority =\n\t\t\t\t\t\tremoteAuthority;\n\t\t\t\t}\n\n\t\t\t\treturn serializedFolderBackupInfo;\n\t\t\t}),\n\t\t\temptyWindows: this.emptyWindows.map(\n\t\t\t\t({ backupFolder, remoteAuthority }) => {\n\t\t\t\t\tconst serializedEmptyWindowBackupInfo: ISerializedEmptyWindowBackupInfo =\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbackupFolder,\n\t\t\t\t\t\t};\n\n\t\t\t\t\tif (remoteAuthority) {\n\t\t\t\t\t\tserializedEmptyWindowBackupInfo.remoteAuthority =\n\t\t\t\t\t\t\tremoteAuthority;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn serializedEmptyWindowBackupInfo;\n\t\t\t\t},\n\t\t\t),\n\t\t};\n\n\t\tthis.stateService.setItem(\n\t\t\tBackupMainService.backupWorkspacesMetadataStorageKey,\n\t\t\tserializedBackupWorkspaces,\n\t\t);\n\t}\n\n\tprotected getFolderHash(folder: IFolderBackupInfo): string {\n\t\tconst folderUri = folder.folderUri;\n\n\t\tlet key: string;\n\t\tif (folderUri.scheme === Schemas.file) {\n\t\t\tkey = isLinux ? folderUri.fsPath : folderUri.fsPath.toLowerCase(); // for backward compatibility, use the fspath as key\n\t\t} else {\n\t\t\tkey = folderUri.toString().toLowerCase();\n\t\t}\n\n\t\treturn createHash(\"md5\").update(key).digest(\"hex\"); // CodeQL [SM04514] Using MD5 to convert a file path to a fixed length\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
