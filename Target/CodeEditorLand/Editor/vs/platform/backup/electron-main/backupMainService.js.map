{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/backup/electron-main/backupMainService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createHash } from 'crypto';\nimport { isEqual } from '../../../base/common/extpath.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { join } from '../../../base/common/path.js';\nimport { isLinux } from '../../../base/common/platform.js';\nimport { extUriBiasedIgnorePathCase } from '../../../base/common/resources.js';\nimport { Promises, RimRafMode } from '../../../base/node/pfs.js';\nimport { IBackupMainService } from './backup.js';\nimport { ISerializedBackupWorkspaces, IEmptyWindowBackupInfo, isEmptyWindowBackupInfo, deserializeWorkspaceInfos, deserializeFolderInfos, ISerializedWorkspaceBackupInfo, ISerializedFolderBackupInfo, ISerializedEmptyWindowBackupInfo } from '../node/backup.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { IEnvironmentMainService } from '../../environment/electron-main/environmentMainService.js';\nimport { IStateService } from '../../state/node/state.js';\nimport { HotExitConfiguration, IFilesConfiguration } from '../../files/common/files.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { IFolderBackupInfo, isFolderBackupInfo, IWorkspaceBackupInfo } from '../common/backup.js';\nimport { isWorkspaceIdentifier } from '../../workspace/common/workspace.js';\nimport { createEmptyWorkspaceIdentifier } from '../../workspaces/node/workspaces.js';\n\nexport class BackupMainService implements IBackupMainService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate static readonly backupWorkspacesMetadataStorageKey = 'backupWorkspaces';\n\n\tprotected backupHome = this.environmentMainService.backupHome;\n\n\tprivate workspaces: IWorkspaceBackupInfo[] = [];\n\tprivate folders: IFolderBackupInfo[] = [];\n\tprivate emptyWindows: IEmptyWindowBackupInfo[] = [];\n\n\t// Comparers for paths and resources that will\n\t// - ignore path casing on Windows/macOS\n\t// - respect path casing on Linux\n\tprivate readonly backupUriComparer = extUriBiasedIgnorePathCase;\n\tprivate readonly backupPathComparer = { isEqual: (pathA: string, pathB: string) => isEqual(pathA, pathB, !isLinux) };\n\n\tconstructor(\n\t\t@IEnvironmentMainService private readonly environmentMainService: IEnvironmentMainService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IStateService private readonly stateService: IStateService\n\t) {\n\t}\n\n\tasync initialize(): Promise<void> {\n\n\t\t// read backup workspaces\n\t\tconst serializedBackupWorkspaces = this.stateService.getItem<ISerializedBackupWorkspaces>(BackupMainService.backupWorkspacesMetadataStorageKey) ?? { workspaces: [], folders: [], emptyWindows: [] };\n\n\t\t// validate empty workspaces backups first\n\t\tthis.emptyWindows = await this.validateEmptyWorkspaces(serializedBackupWorkspaces.emptyWindows);\n\n\t\t// validate workspace backups\n\t\tthis.workspaces = await this.validateWorkspaces(deserializeWorkspaceInfos(serializedBackupWorkspaces));\n\n\t\t// validate folder backups\n\t\tthis.folders = await this.validateFolders(deserializeFolderInfos(serializedBackupWorkspaces));\n\n\t\t// store metadata in case some workspaces or folders have been removed\n\t\tthis.storeWorkspacesMetadata();\n\t}\n\n\tprotected getWorkspaceBackups(): IWorkspaceBackupInfo[] {\n\t\tif (this.isHotExitOnExitAndWindowClose()) {\n\t\t\t// Only non-folder windows are restored on main process launch when\n\t\t\t// hot exit is configured as onExitAndWindowClose.\n\t\t\treturn [];\n\t\t}\n\n\t\treturn this.workspaces.slice(0); // return a copy\n\t}\n\n\tprotected getFolderBackups(): IFolderBackupInfo[] {\n\t\tif (this.isHotExitOnExitAndWindowClose()) {\n\t\t\t// Only non-folder windows are restored on main process launch when\n\t\t\t// hot exit is configured as onExitAndWindowClose.\n\t\t\treturn [];\n\t\t}\n\n\t\treturn this.folders.slice(0); // return a copy\n\t}\n\n\tisHotExitEnabled(): boolean {\n\t\treturn this.getHotExitConfig() !== HotExitConfiguration.OFF;\n\t}\n\n\tprivate isHotExitOnExitAndWindowClose(): boolean {\n\t\treturn this.getHotExitConfig() === HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE;\n\t}\n\n\tprivate getHotExitConfig(): string {\n\t\tconst config = this.configurationService.getValue<IFilesConfiguration>();\n\n\t\treturn config?.files?.hotExit || HotExitConfiguration.ON_EXIT;\n\t}\n\n\tgetEmptyWindowBackups(): IEmptyWindowBackupInfo[] {\n\t\treturn this.emptyWindows.slice(0); // return a copy\n\t}\n\n\tregisterWorkspaceBackup(workspaceInfo: IWorkspaceBackupInfo): string;\n\tregisterWorkspaceBackup(workspaceInfo: IWorkspaceBackupInfo, migrateFrom: string): Promise<string>;\n\tregisterWorkspaceBackup(workspaceInfo: IWorkspaceBackupInfo, migrateFrom?: string): string | Promise<string> {\n\t\tif (!this.workspaces.some(workspace => workspaceInfo.workspace.id === workspace.workspace.id)) {\n\t\t\tthis.workspaces.push(workspaceInfo);\n\t\t\tthis.storeWorkspacesMetadata();\n\t\t}\n\n\t\tconst backupPath = join(this.backupHome, workspaceInfo.workspace.id);\n\n\t\tif (migrateFrom) {\n\t\t\treturn this.moveBackupFolder(backupPath, migrateFrom).then(() => backupPath);\n\t\t}\n\n\t\treturn backupPath;\n\t}\n\n\tprivate async moveBackupFolder(backupPath: string, moveFromPath: string): Promise<void> {\n\n\t\t// Target exists: make sure to convert existing backups to empty window backups\n\t\tif (await Promises.exists(backupPath)) {\n\t\t\tawait this.convertToEmptyWindowBackup(backupPath);\n\t\t}\n\n\t\t// When we have data to migrate from, move it over to the target location\n\t\tif (await Promises.exists(moveFromPath)) {\n\t\t\ttry {\n\t\t\t\tawait Promises.rename(moveFromPath, backupPath, false /* no retry */);\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.error(`Backup: Could not move backup folder to new location: ${error.toString()}`);\n\t\t\t}\n\t\t}\n\t}\n\n\tregisterFolderBackup(folderInfo: IFolderBackupInfo): string {\n\t\tif (!this.folders.some(folder => this.backupUriComparer.isEqual(folderInfo.folderUri, folder.folderUri))) {\n\t\t\tthis.folders.push(folderInfo);\n\t\t\tthis.storeWorkspacesMetadata();\n\t\t}\n\n\t\treturn join(this.backupHome, this.getFolderHash(folderInfo));\n\t}\n\n\tregisterEmptyWindowBackup(emptyWindowInfo: IEmptyWindowBackupInfo): string {\n\t\tif (!this.emptyWindows.some(emptyWindow => !!emptyWindow.backupFolder && this.backupPathComparer.isEqual(emptyWindow.backupFolder, emptyWindowInfo.backupFolder))) {\n\t\t\tthis.emptyWindows.push(emptyWindowInfo);\n\t\t\tthis.storeWorkspacesMetadata();\n\t\t}\n\n\t\treturn join(this.backupHome, emptyWindowInfo.backupFolder);\n\t}\n\n\tprivate async validateWorkspaces(rootWorkspaces: IWorkspaceBackupInfo[]): Promise<IWorkspaceBackupInfo[]> {\n\t\tif (!Array.isArray(rootWorkspaces)) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst seenIds: Set<string> = new Set();\n\t\tconst result: IWorkspaceBackupInfo[] = [];\n\n\t\t// Validate Workspaces\n\t\tfor (const workspaceInfo of rootWorkspaces) {\n\t\t\tconst workspace = workspaceInfo.workspace;\n\t\t\tif (!isWorkspaceIdentifier(workspace)) {\n\t\t\t\treturn []; // wrong format, skip all entries\n\t\t\t}\n\n\t\t\tif (!seenIds.has(workspace.id)) {\n\t\t\t\tseenIds.add(workspace.id);\n\n\t\t\t\tconst backupPath = join(this.backupHome, workspace.id);\n\t\t\t\tconst hasBackups = await this.doHasBackups(backupPath);\n\n\t\t\t\t// If the workspace has no backups, ignore it\n\t\t\t\tif (hasBackups) {\n\t\t\t\t\tif (workspace.configPath.scheme !== Schemas.file || await Promises.exists(workspace.configPath.fsPath)) {\n\t\t\t\t\t\tresult.push(workspaceInfo);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If the workspace has backups, but the target workspace is missing, convert backups to empty ones\n\t\t\t\t\t\tawait this.convertToEmptyWindowBackup(backupPath);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tawait this.deleteStaleBackup(backupPath);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate async validateFolders(folderWorkspaces: IFolderBackupInfo[]): Promise<IFolderBackupInfo[]> {\n\t\tif (!Array.isArray(folderWorkspaces)) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst result: IFolderBackupInfo[] = [];\n\t\tconst seenIds: Set<string> = new Set();\n\t\tfor (const folderInfo of folderWorkspaces) {\n\t\t\tconst folderURI = folderInfo.folderUri;\n\t\t\tconst key = this.backupUriComparer.getComparisonKey(folderURI);\n\t\t\tif (!seenIds.has(key)) {\n\t\t\t\tseenIds.add(key);\n\n\t\t\t\tconst backupPath = join(this.backupHome, this.getFolderHash(folderInfo));\n\t\t\t\tconst hasBackups = await this.doHasBackups(backupPath);\n\n\t\t\t\t// If the folder has no backups, ignore it\n\t\t\t\tif (hasBackups) {\n\t\t\t\t\tif (folderURI.scheme !== Schemas.file || await Promises.exists(folderURI.fsPath)) {\n\t\t\t\t\t\tresult.push(folderInfo);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If the folder has backups, but the target workspace is missing, convert backups to empty ones\n\t\t\t\t\t\tawait this.convertToEmptyWindowBackup(backupPath);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tawait this.deleteStaleBackup(backupPath);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate async validateEmptyWorkspaces(emptyWorkspaces: IEmptyWindowBackupInfo[]): Promise<IEmptyWindowBackupInfo[]> {\n\t\tif (!Array.isArray(emptyWorkspaces)) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst result: IEmptyWindowBackupInfo[] = [];\n\t\tconst seenIds: Set<string> = new Set();\n\n\t\t// Validate Empty Windows\n\t\tfor (const backupInfo of emptyWorkspaces) {\n\t\t\tconst backupFolder = backupInfo.backupFolder;\n\t\t\tif (typeof backupFolder !== 'string') {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tif (!seenIds.has(backupFolder)) {\n\t\t\t\tseenIds.add(backupFolder);\n\n\t\t\t\tconst backupPath = join(this.backupHome, backupFolder);\n\t\t\t\tif (await this.doHasBackups(backupPath)) {\n\t\t\t\t\tresult.push(backupInfo);\n\t\t\t\t} else {\n\t\t\t\t\tawait this.deleteStaleBackup(backupPath);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate async deleteStaleBackup(backupPath: string): Promise<void> {\n\t\ttry {\n\t\t\tawait Promises.rm(backupPath, RimRafMode.MOVE);\n\t\t} catch (error) {\n\t\t\tthis.logService.error(`Backup: Could not delete stale backup: ${error.toString()}`);\n\t\t}\n\t}\n\n\tprivate prepareNewEmptyWindowBackup(): IEmptyWindowBackupInfo {\n\n\t\t// We are asked to prepare a new empty window backup folder.\n\t\t// Empty windows backup folders are derived from a workspace\n\t\t// identifier, so we generate a new empty workspace identifier\n\t\t// until we found a unique one.\n\n\t\tlet emptyWorkspaceIdentifier = createEmptyWorkspaceIdentifier();\n\t\twhile (this.emptyWindows.some(emptyWindow => !!emptyWindow.backupFolder && this.backupPathComparer.isEqual(emptyWindow.backupFolder, emptyWorkspaceIdentifier.id))) {\n\t\t\temptyWorkspaceIdentifier = createEmptyWorkspaceIdentifier();\n\t\t}\n\n\t\treturn { backupFolder: emptyWorkspaceIdentifier.id };\n\t}\n\n\tprivate async convertToEmptyWindowBackup(backupPath: string): Promise<boolean> {\n\t\tconst newEmptyWindowBackupInfo = this.prepareNewEmptyWindowBackup();\n\n\t\t// Rename backupPath to new empty window backup path\n\t\tconst newEmptyWindowBackupPath = join(this.backupHome, newEmptyWindowBackupInfo.backupFolder);\n\t\ttry {\n\t\t\tawait Promises.rename(backupPath, newEmptyWindowBackupPath, false /* no retry */);\n\t\t} catch (error) {\n\t\t\tthis.logService.error(`Backup: Could not rename backup folder: ${error.toString()}`);\n\t\t\treturn false;\n\t\t}\n\t\tthis.emptyWindows.push(newEmptyWindowBackupInfo);\n\n\t\treturn true;\n\t}\n\n\tasync getDirtyWorkspaces(): Promise<Array<IWorkspaceBackupInfo | IFolderBackupInfo>> {\n\t\tconst dirtyWorkspaces: Array<IWorkspaceBackupInfo | IFolderBackupInfo> = [];\n\n\t\t// Workspaces with backups\n\t\tfor (const workspace of this.workspaces) {\n\t\t\tif ((await this.hasBackups(workspace))) {\n\t\t\t\tdirtyWorkspaces.push(workspace);\n\t\t\t}\n\t\t}\n\n\t\t// Folders with backups\n\t\tfor (const folder of this.folders) {\n\t\t\tif ((await this.hasBackups(folder))) {\n\t\t\t\tdirtyWorkspaces.push(folder);\n\t\t\t}\n\t\t}\n\n\t\treturn dirtyWorkspaces;\n\t}\n\n\tprivate hasBackups(backupLocation: IWorkspaceBackupInfo | IEmptyWindowBackupInfo | IFolderBackupInfo): Promise<boolean> {\n\t\tlet backupPath: string;\n\n\t\t// Empty\n\t\tif (isEmptyWindowBackupInfo(backupLocation)) {\n\t\t\tbackupPath = join(this.backupHome, backupLocation.backupFolder);\n\t\t}\n\n\t\t// Folder\n\t\telse if (isFolderBackupInfo(backupLocation)) {\n\t\t\tbackupPath = join(this.backupHome, this.getFolderHash(backupLocation));\n\t\t}\n\n\t\t// Workspace\n\t\telse {\n\t\t\tbackupPath = join(this.backupHome, backupLocation.workspace.id);\n\t\t}\n\n\t\treturn this.doHasBackups(backupPath);\n\t}\n\n\tprivate async doHasBackups(backupPath: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst backupSchemas = await Promises.readdir(backupPath);\n\n\t\t\tfor (const backupSchema of backupSchemas) {\n\t\t\t\ttry {\n\t\t\t\t\tconst backupSchemaChildren = await Promises.readdir(join(backupPath, backupSchema));\n\t\t\t\t\tif (backupSchemaChildren.length > 0) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// invalid folder\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// backup path does not exist\n\t\t}\n\n\t\treturn false;\n\t}\n\n\n\tprivate storeWorkspacesMetadata(): void {\n\t\tconst serializedBackupWorkspaces: ISerializedBackupWorkspaces = {\n\t\t\tworkspaces: this.workspaces.map(({ workspace, remoteAuthority }) => {\n\t\t\t\tconst serializedWorkspaceBackupInfo: ISerializedWorkspaceBackupInfo = {\n\t\t\t\t\tid: workspace.id,\n\t\t\t\t\tconfigURIPath: workspace.configPath.toString()\n\t\t\t\t};\n\n\t\t\t\tif (remoteAuthority) {\n\t\t\t\t\tserializedWorkspaceBackupInfo.remoteAuthority = remoteAuthority;\n\t\t\t\t}\n\n\t\t\t\treturn serializedWorkspaceBackupInfo;\n\t\t\t}),\n\t\t\tfolders: this.folders.map(({ folderUri, remoteAuthority }) => {\n\t\t\t\tconst serializedFolderBackupInfo: ISerializedFolderBackupInfo =\n\t\t\t\t{\n\t\t\t\t\tfolderUri: folderUri.toString()\n\t\t\t\t};\n\n\t\t\t\tif (remoteAuthority) {\n\t\t\t\t\tserializedFolderBackupInfo.remoteAuthority = remoteAuthority;\n\t\t\t\t}\n\n\t\t\t\treturn serializedFolderBackupInfo;\n\t\t\t}),\n\t\t\temptyWindows: this.emptyWindows.map(({ backupFolder, remoteAuthority }) => {\n\t\t\t\tconst serializedEmptyWindowBackupInfo: ISerializedEmptyWindowBackupInfo = {\n\t\t\t\t\tbackupFolder\n\t\t\t\t};\n\n\t\t\t\tif (remoteAuthority) {\n\t\t\t\t\tserializedEmptyWindowBackupInfo.remoteAuthority = remoteAuthority;\n\t\t\t\t}\n\n\t\t\t\treturn serializedEmptyWindowBackupInfo;\n\t\t\t})\n\t\t};\n\n\t\tthis.stateService.setItem(BackupMainService.backupWorkspacesMetadataStorageKey, serializedBackupWorkspaces);\n\t}\n\n\tprotected getFolderHash(folder: IFolderBackupInfo): string {\n\t\tconst folderUri = folder.folderUri;\n\n\t\tlet key: string;\n\t\tif (folderUri.scheme === Schemas.file) {\n\t\t\tkey = isLinux ? folderUri.fsPath : folderUri.fsPath.toLowerCase(); // for backward compatibility, use the fspath as key\n\t\t} else {\n\t\t\tkey = folderUri.toString().toLowerCase();\n\t\t}\n\n\t\treturn createHash('md5').update(key).digest('hex'); // CodeQL [SM04514] Using MD5 to convert a file path to a fixed length\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
