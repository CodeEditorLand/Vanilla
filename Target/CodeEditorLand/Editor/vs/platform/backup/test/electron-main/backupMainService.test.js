import s from"assert";import{createHash as U}from"crypto";import*as a from"fs";import*as R from"os";import{Schemas as h}from"../../../../base/common/network.js";import*as p from"../../../../base/common/path.js";import*as w from"../../../../base/common/platform.js";import{isEqual as C}from"../../../../base/common/resources.js";import{URI as k}from"../../../../base/common/uri.js";import{Promises as z}from"../../../../base/node/pfs.js";import{flakySuite as T,getRandomTestPath as D}from"../../../../base/test/node/testUtils.js";import{BackupMainService as L}from"../../electron-main/backupMainService.js";import"../../node/backup.js";import{TestConfigurationService as N}from"../../../configuration/test/common/testConfigurationService.js";import{EnvironmentMainService as A}from"../../../environment/electron-main/environmentMainService.js";import{OPTIONS as _,parseArgs as J}from"../../../environment/node/argv.js";import{HotExitConfiguration as M}from"../../../files/common/files.js";import{ConsoleMainLogger as X}from"../../../log/common/log.js";import K from"../../../product/common/product.js";import{isFolderBackupInfo as Q}from"../../common/backup.js";import"../../../workspace/common/workspace.js";import{InMemoryTestStateMainService as V}from"../../../test/electron-main/workbenchTestServices.js";import{LogService as Y}from"../../../log/common/logService.js";import{ensureNoDisposablesAreLeakedInTestSuite as Z}from"../../../../base/test/common/utils.js";T("BackupMainService",()=>{function d(e,r){const n=f=>({folderUri:f.folderUri.toString(),remoteAuthority:f.remoteAuthority});s.deepStrictEqual(e.map(n),r.map(n))}function F(e){return{id:U("md5").update(b(e)).digest("hex"),configPath:k.file(e)}}function l(e,r){return{workspace:{id:U("md5").update(b(e)).digest("hex"),configPath:k.file(e)},remoteAuthority:r}}function u(e,r){return{folderUri:e,remoteAuthority:r}}function O(e){return{id:e.id,configURIPath:e.configPath.toString()}}function j(e){a.existsSync(e.fsPath)||a.mkdirSync(e.fsPath);const r=t.toBackupPath(e);return x(r)}async function I(e){a.existsSync(e.configPath.fsPath)||await z.writeFile(e.configPath.fsPath,"Hello");const r=t.toBackupPath(e.id);return await x(r),e}async function x(e){a.existsSync(e)||(a.mkdirSync(e),a.mkdirSync(p.join(e,h.file)),await z.writeFile(p.join(e,h.file,"foo.txt"),"Hello"))}function g(){return W.getItem("backupWorkspaces")}function o(e){e?W.setItem("backupWorkspaces",JSON.parse(e)):W.removeItem("backupWorkspaces")}function b(e){return w.isLinux?e:e.toLowerCase()}const i=k.file(w.isWindows?"C:\\foo":"/foo"),c=k.file(w.isWindows?"C:\\bar":"/bar");let t,P,W,v,S,E,B;setup(async()=>(S=D(R.tmpdir(),"vsctests","backupmainservice"),E=p.join(S,"Backups"),B=k.file(p.join(S,"folder1")),v=new A(J(process.argv,_),{_serviceBrand:void 0,...K}),await a.promises.mkdir(E,{recursive:!0}),P=new N,W=new V,t=new class extends L{constructor(){super(v,P,new Y(new X),W),this.backupHome=E}toBackupPath(r){const n=r instanceof k?super.getFolderHash({folderUri:r}):r;return p.join(this.backupHome,n)}testGetFolderHash(r){return super.getFolderHash(r)}testGetWorkspaceBackups(){return super.getWorkspaceBackups()}testGetFolderBackups(){return super.getFolderBackups()}},t.initialize())),teardown(()=>z.rm(S)),test("service validates backup workspaces on startup and cleans up (folder workspaces)",async function(){t.registerFolderBackup(u(i)),t.registerFolderBackup(u(c)),await t.initialize(),d(t.testGetFolderBackups(),[]),a.mkdirSync(t.toBackupPath(i)),a.mkdirSync(t.toBackupPath(c)),t.registerFolderBackup(u(i)),t.registerFolderBackup(u(c)),await t.initialize(),d(t.testGetFolderBackups(),[]),s.ok(!a.existsSync(t.toBackupPath(i))),s.ok(!a.existsSync(t.toBackupPath(c))),a.mkdirSync(t.toBackupPath(i)),a.mkdirSync(t.toBackupPath(c)),a.mkdirSync(p.join(t.toBackupPath(i),h.file)),a.mkdirSync(p.join(t.toBackupPath(c),h.untitled)),t.registerFolderBackup(u(i)),t.registerFolderBackup(u(c)),await t.initialize(),d(t.testGetFolderBackups(),[]),s.ok(!a.existsSync(t.toBackupPath(i))),s.ok(!a.existsSync(t.toBackupPath(c)));const e=p.join(t.toBackupPath(i),h.file);a.mkdirSync(t.toBackupPath(i)),a.mkdirSync(t.toBackupPath(c)),a.mkdirSync(e),t.registerFolderBackup(u(i)),s.strictEqual(t.testGetFolderBackups().length,1),s.strictEqual(t.getEmptyWindowBackups().length,0),a.writeFileSync(p.join(e,"backup.txt"),""),await t.initialize(),s.strictEqual(t.testGetFolderBackups().length,0),s.strictEqual(t.getEmptyWindowBackups().length,1)}),test("service validates backup workspaces on startup and cleans up (root workspaces)",async function(){t.registerWorkspaceBackup(l(i.fsPath)),t.registerWorkspaceBackup(l(c.fsPath)),await t.initialize(),s.deepStrictEqual(t.testGetWorkspaceBackups(),[]),a.mkdirSync(t.toBackupPath(i)),a.mkdirSync(t.toBackupPath(c)),t.registerWorkspaceBackup(l(i.fsPath)),t.registerWorkspaceBackup(l(c.fsPath)),await t.initialize(),s.deepStrictEqual(t.testGetWorkspaceBackups(),[]),s.ok(!a.existsSync(t.toBackupPath(i))),s.ok(!a.existsSync(t.toBackupPath(c))),a.mkdirSync(t.toBackupPath(i)),a.mkdirSync(t.toBackupPath(c)),a.mkdirSync(p.join(t.toBackupPath(i),h.file)),a.mkdirSync(p.join(t.toBackupPath(c),h.untitled)),t.registerWorkspaceBackup(l(i.fsPath)),t.registerWorkspaceBackup(l(c.fsPath)),await t.initialize(),s.deepStrictEqual(t.testGetWorkspaceBackups(),[]),s.ok(!a.existsSync(t.toBackupPath(i))),s.ok(!a.existsSync(t.toBackupPath(c)));const e=p.join(t.toBackupPath(i),h.file);a.mkdirSync(t.toBackupPath(i)),a.mkdirSync(t.toBackupPath(c)),a.mkdirSync(e),t.registerWorkspaceBackup(l(i.fsPath)),s.strictEqual(t.testGetWorkspaceBackups().length,1),s.strictEqual(t.getEmptyWindowBackups().length,0),a.writeFileSync(p.join(e,"backup.txt"),""),await t.initialize(),s.strictEqual(t.testGetWorkspaceBackups().length,0),s.strictEqual(t.getEmptyWindowBackups().length,1)}),test("service supports to migrate backup data from another location",async()=>{const e=t.toBackupPath(i);a.mkdirSync(e),a.writeFileSync(p.join(e,"backup.txt"),"Some Data"),t.registerFolderBackup(u(k.file(e)));const r=await t.registerWorkspaceBackup(l(c.fsPath),e);s.ok(a.existsSync(r)),s.ok(a.existsSync(p.join(r,"backup.txt"))),s.ok(!a.existsSync(e));const n=t.getEmptyWindowBackups();s.strictEqual(0,n.length)}),test("service backup migration makes sure to preserve existing backups",async()=>{const e=t.toBackupPath(i);a.mkdirSync(e),a.writeFileSync(p.join(e,"backup.txt"),"Some Data"),t.registerFolderBackup(u(k.file(e)));const r=t.toBackupPath(c);a.mkdirSync(r),a.writeFileSync(p.join(r,"backup.txt"),"Some Data"),t.registerFolderBackup(u(k.file(r)));const n=await t.registerWorkspaceBackup(l(c.fsPath),e);s.ok(a.existsSync(n)),s.ok(a.existsSync(p.join(n,"backup.txt"))),s.ok(!a.existsSync(e));const f=t.getEmptyWindowBackups();s.strictEqual(1,f.length),s.strictEqual(1,a.readdirSync(p.join(E,f[0].backupFolder)).length)}),suite("loadSync",()=>{test("getFolderBackupPaths() should return [] when workspaces.json doesn't exist",()=>{d(t.testGetFolderBackups(),[])}),test("getFolderBackupPaths() should return [] when folders in workspaces.json is absent",async()=>{o("{}"),await t.initialize(),d(t.testGetFolderBackups(),[])}),test("getFolderBackupPaths() should return [] when folders in workspaces.json is not a string array",async()=>{o('{"folders":{}}'),await t.initialize(),d(t.testGetFolderBackups(),[]),o('{"folders":{"foo": ["bar"]}}'),await t.initialize(),d(t.testGetFolderBackups(),[]),o('{"folders":{"foo": []}}'),await t.initialize(),d(t.testGetFolderBackups(),[]),o('{"folders":{"foo": "bar"}}'),await t.initialize(),d(t.testGetFolderBackups(),[]),o('{"folders":"foo"}'),await t.initialize(),d(t.testGetFolderBackups(),[]),o('{"folders":1}'),await t.initialize(),d(t.testGetFolderBackups(),[])}),test('getFolderBackupPaths() should return [] when files.hotExit = "onExitAndWindowClose"',async()=>{const e=u(k.file(i.fsPath.toUpperCase()));t.registerFolderBackup(e),d(t.testGetFolderBackups(),[e]),P.setUserConfiguration("files.hotExit",M.ON_EXIT_AND_WINDOW_CLOSE),await t.initialize(),d(t.testGetFolderBackups(),[])}),test("getWorkspaceBackups() should return [] when workspaces.json doesn't exist",()=>{s.deepStrictEqual(t.testGetWorkspaceBackups(),[])}),test("getWorkspaceBackups() should return [] when folderWorkspaces in workspaces.json is absent",async()=>{o("{}"),await t.initialize(),s.deepStrictEqual(t.testGetWorkspaceBackups(),[])}),test("getWorkspaceBackups() should return [] when rootWorkspaces in workspaces.json is not a object array",async()=>{o('{"rootWorkspaces":{}}'),await t.initialize(),s.deepStrictEqual(t.testGetWorkspaceBackups(),[]),o('{"rootWorkspaces":{"foo": ["bar"]}}'),await t.initialize(),s.deepStrictEqual(t.testGetWorkspaceBackups(),[]),o('{"rootWorkspaces":{"foo": []}}'),await t.initialize(),s.deepStrictEqual(t.testGetWorkspaceBackups(),[]),o('{"rootWorkspaces":{"foo": "bar"}}'),await t.initialize(),s.deepStrictEqual(t.testGetWorkspaceBackups(),[]),o('{"rootWorkspaces":"foo"}'),await t.initialize(),s.deepStrictEqual(t.testGetWorkspaceBackups(),[]),o('{"rootWorkspaces":1}'),await t.initialize(),s.deepStrictEqual(t.testGetWorkspaceBackups(),[])}),test("getWorkspaceBackups() should return [] when workspaces in workspaces.json is not a object array",async()=>{o('{"workspaces":{}}'),await t.initialize(),s.deepStrictEqual(t.testGetWorkspaceBackups(),[]),o('{"workspaces":{"foo": ["bar"]}}'),await t.initialize(),s.deepStrictEqual(t.testGetWorkspaceBackups(),[]),o('{"workspaces":{"foo": []}}'),await t.initialize(),s.deepStrictEqual(t.testGetWorkspaceBackups(),[]),o('{"workspaces":{"foo": "bar"}}'),await t.initialize(),s.deepStrictEqual(t.testGetWorkspaceBackups(),[]),o('{"workspaces":"foo"}'),await t.initialize(),s.deepStrictEqual(t.testGetWorkspaceBackups(),[]),o('{"workspaces":1}'),await t.initialize(),s.deepStrictEqual(t.testGetWorkspaceBackups(),[])}),test('getWorkspaceBackups() should return [] when files.hotExit = "onExitAndWindowClose"',async()=>{const e=i.fsPath.toUpperCase();t.registerWorkspaceBackup(l(e)),s.strictEqual(t.testGetWorkspaceBackups().length,1),s.deepStrictEqual(t.testGetWorkspaceBackups().map(r=>r.workspace.configPath.toString()),[k.file(e).toString()]),P.setUserConfiguration("files.hotExit",M.ON_EXIT_AND_WINDOW_CLOSE),await t.initialize(),s.deepStrictEqual(t.testGetWorkspaceBackups(),[])}),test("getEmptyWorkspaceBackupPaths() should return [] when workspaces.json doesn't exist",()=>{s.deepStrictEqual(t.getEmptyWindowBackups(),[])}),test("getEmptyWorkspaceBackupPaths() should return [] when folderWorkspaces in workspaces.json is absent",async()=>{o("{}"),await t.initialize(),s.deepStrictEqual(t.getEmptyWindowBackups(),[])}),test("getEmptyWorkspaceBackupPaths() should return [] when folderWorkspaces in workspaces.json is not a string array",async function(){o('{"emptyWorkspaces":{}}'),await t.initialize(),s.deepStrictEqual(t.getEmptyWindowBackups(),[]),o('{"emptyWorkspaces":{"foo": ["bar"]}}'),await t.initialize(),s.deepStrictEqual(t.getEmptyWindowBackups(),[]),o('{"emptyWorkspaces":{"foo": []}}'),await t.initialize(),s.deepStrictEqual(t.getEmptyWindowBackups(),[]),o('{"emptyWorkspaces":{"foo": "bar"}}'),await t.initialize(),s.deepStrictEqual(t.getEmptyWindowBackups(),[]),o('{"emptyWorkspaces":"foo"}'),await t.initialize(),s.deepStrictEqual(t.getEmptyWindowBackups(),[]),o('{"emptyWorkspaces":1}'),await t.initialize(),s.deepStrictEqual(t.getEmptyWindowBackups(),[])})}),suite("dedupeFolderWorkspaces",()=>{test("should ignore duplicates (folder workspace)",async()=>{await j(B);const e={workspaces:[],folders:[{folderUri:B.toString()},{folderUri:B.toString()}],emptyWindows:[]};o(JSON.stringify(e)),await t.initialize();const r=g();s.deepStrictEqual(r.folders,[{folderUri:B.toString()}])}),test("should ignore duplicates on Windows and Mac (folder workspace)",async()=>{await j(B);const e={workspaces:[],folders:[{folderUri:B.toString()},{folderUri:B.toString().toLowerCase()}],emptyWindows:[]};o(JSON.stringify(e)),await t.initialize();const r=g();s.deepStrictEqual(r.folders,[{folderUri:B.toString()}])}),test("should ignore duplicates on Windows and Mac (root workspace)",async()=>{const e=p.join(S,"Foo.code-workspace"),r=p.join(S,"FOO.code-workspace"),n=p.join(S,"foo.code-workspace"),f=await I(F(e)),y=await I(F(r)),m=await I(F(n)),H={workspaces:[f,y,m].map(O),folders:[],emptyWindows:[]};o(JSON.stringify(H)),await t.initialize();const q=g();s.strictEqual(q.workspaces.length,w.isLinux?3:1),w.isLinux?s.deepStrictEqual(q.workspaces.map(G=>G.configURIPath),[k.file(e).toString(),k.file(r).toString(),k.file(n).toString()]):s.deepStrictEqual(q.workspaces.map(G=>G.configURIPath),[k.file(e).toString()],"should return the first duplicated entry")})}),suite("registerWindowForBackups",()=>{test("should persist paths to workspaces.json (folder workspace)",async()=>{t.registerFolderBackup(u(i)),t.registerFolderBackup(u(c)),d(t.testGetFolderBackups(),[u(i),u(c)]);const e=g();s.deepStrictEqual(e.folders,[{folderUri:i.toString()},{folderUri:c.toString()}])}),test("should persist paths to workspaces.json (root workspace)",async()=>{const e=l(i.fsPath);t.registerWorkspaceBackup(e);const r=l(c.fsPath);t.registerWorkspaceBackup(r),s.deepStrictEqual(t.testGetWorkspaceBackups().map(f=>f.workspace.configPath.toString()),[i.toString(),c.toString()]),s.strictEqual(e.workspace.id,t.testGetWorkspaceBackups()[0].workspace.id),s.strictEqual(r.workspace.id,t.testGetWorkspaceBackups()[1].workspace.id);const n=g();s.deepStrictEqual(n.workspaces.map(f=>f.configURIPath),[i.toString(),c.toString()]),s.strictEqual(e.workspace.id,n.workspaces[0].id),s.strictEqual(r.workspace.id,n.workspaces[1].id)})}),test("should always store the workspace path in workspaces.json using the case given, regardless of whether the file system is case-sensitive (folder workspace)",async()=>{t.registerFolderBackup(u(k.file(i.fsPath.toUpperCase()))),d(t.testGetFolderBackups(),[u(k.file(i.fsPath.toUpperCase()))]);const e=g();s.deepStrictEqual(e.folders,[{folderUri:k.file(i.fsPath.toUpperCase()).toString()}])}),test("should always store the workspace path in workspaces.json using the case given, regardless of whether the file system is case-sensitive (root workspace)",async()=>{const e=i.fsPath.toUpperCase();t.registerWorkspaceBackup(l(e)),s.deepStrictEqual(t.testGetWorkspaceBackups().map(n=>n.workspace.configPath.toString()),[k.file(e).toString()]);const r=g();s.deepStrictEqual(r.workspaces.map(n=>n.configURIPath),[k.file(e).toString()])}),suite("getWorkspaceHash",()=>{(w.isLinux?test.skip:test)("should ignore case on Windows and Mac",()=>{const e=(r,n)=>{s.strictEqual(t.testGetFolderHash(u(r)),t.testGetFolderHash(u(n)))};w.isMacintosh&&e(k.file("/foo"),k.file("/FOO")),w.isWindows&&e(k.file("c:\\foo"),k.file("C:\\FOO"))})}),suite("mixed path casing",()=>{test("should handle case insensitive paths properly (registerWindowForBackupsSync) (folder workspace)",()=>{t.registerFolderBackup(u(i)),t.registerFolderBackup(u(k.file(i.fsPath.toUpperCase()))),w.isLinux?s.strictEqual(t.testGetFolderBackups().length,2):s.strictEqual(t.testGetFolderBackups().length,1)}),test("should handle case insensitive paths properly (registerWindowForBackupsSync) (root workspace)",()=>{t.registerWorkspaceBackup(l(i.fsPath)),t.registerWorkspaceBackup(l(i.fsPath.toUpperCase())),w.isLinux?s.strictEqual(t.testGetWorkspaceBackups().length,2):s.strictEqual(t.testGetWorkspaceBackups().length,1)})}),suite("getDirtyWorkspaces",()=>{test("should report if a workspace or folder has backups",async()=>{const e=t.registerFolderBackup(u(i)),r=l(i.fsPath),n=t.registerWorkspaceBackup(r);s.strictEqual((await t.getDirtyWorkspaces()).length,0);try{await a.promises.mkdir(p.join(e,h.file),{recursive:!0}),await a.promises.mkdir(p.join(n,h.untitled),{recursive:!0})}catch{}s.strictEqual((await t.getDirtyWorkspaces()).length,0),a.writeFileSync(p.join(e,h.file,"594a4a9d82a277a899d4713a5b08f504"),""),a.writeFileSync(p.join(n,h.untitled,"594a4a9d82a277a899d4713a5b08f504"),"");const f=await t.getDirtyWorkspaces();s.strictEqual(f.length,2);let y=0;for(const m of f)Q(m)?C(i,m.folderUri)&&y++:C(r.workspace.configPath,m.workspace.configPath)&&y++;s.strictEqual(y,2)})}),Z()});
