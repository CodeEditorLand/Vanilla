{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/backup/node/backup.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from \"../../../base/common/uri.js\";\nimport type {\n\tIBaseBackupInfo,\n\tIFolderBackupInfo,\n\tIWorkspaceBackupInfo,\n} from \"../common/backup.js\";\n\nexport interface IEmptyWindowBackupInfo extends IBaseBackupInfo {\n\treadonly backupFolder: string;\n}\n\nexport function isEmptyWindowBackupInfo(\n\tobj: unknown,\n): obj is IEmptyWindowBackupInfo {\n\tconst candidate = obj as IEmptyWindowBackupInfo | undefined;\n\n\treturn typeof candidate?.backupFolder === \"string\";\n}\n\nexport interface ISerializedWorkspaceBackupInfo {\n\treadonly id: string;\n\treadonly configURIPath: string;\n\tremoteAuthority?: string;\n}\n\nexport function deserializeWorkspaceInfos(\n\tserializedBackupWorkspaces: ISerializedBackupWorkspaces,\n): IWorkspaceBackupInfo[] {\n\tlet workspaceBackupInfos: IWorkspaceBackupInfo[] = [];\n\ttry {\n\t\tif (Array.isArray(serializedBackupWorkspaces.workspaces)) {\n\t\t\tworkspaceBackupInfos = serializedBackupWorkspaces.workspaces.map(\n\t\t\t\t(workspace) => ({\n\t\t\t\t\tworkspace: {\n\t\t\t\t\t\tid: workspace.id,\n\t\t\t\t\t\tconfigPath: URI.parse(workspace.configURIPath),\n\t\t\t\t\t},\n\t\t\t\t\tremoteAuthority: workspace.remoteAuthority,\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\t} catch (e) {\n\t\t// ignore URI parsing exceptions\n\t}\n\n\treturn workspaceBackupInfos;\n}\n\nexport interface ISerializedFolderBackupInfo {\n\treadonly folderUri: string;\n\tremoteAuthority?: string;\n}\n\nexport function deserializeFolderInfos(\n\tserializedBackupWorkspaces: ISerializedBackupWorkspaces,\n): IFolderBackupInfo[] {\n\tlet folderBackupInfos: IFolderBackupInfo[] = [];\n\ttry {\n\t\tif (Array.isArray(serializedBackupWorkspaces.folders)) {\n\t\t\tfolderBackupInfos = serializedBackupWorkspaces.folders.map(\n\t\t\t\t(folder) => ({\n\t\t\t\t\tfolderUri: URI.parse(folder.folderUri),\n\t\t\t\t\tremoteAuthority: folder.remoteAuthority,\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\t} catch (e) {\n\t\t// ignore URI parsing exceptions\n\t}\n\n\treturn folderBackupInfos;\n}\n\nexport interface ISerializedEmptyWindowBackupInfo\n\textends IEmptyWindowBackupInfo {}\n\nexport interface ILegacySerializedBackupWorkspaces {\n\treadonly rootURIWorkspaces: ISerializedWorkspaceBackupInfo[];\n\treadonly folderWorkspaceInfos: ISerializedFolderBackupInfo[];\n\treadonly emptyWorkspaceInfos: ISerializedEmptyWindowBackupInfo[];\n}\n\nexport interface ISerializedBackupWorkspaces {\n\treadonly workspaces: ISerializedWorkspaceBackupInfo[];\n\treadonly folders: ISerializedFolderBackupInfo[];\n\treadonly emptyWindows: ISerializedEmptyWindowBackupInfo[];\n}\n"],
  "mappings": ";;AAKA,SAAS,WAAW;AAWb,SAAS,wBACf,KACgC;AAChC,QAAM,YAAY;AAElB,SAAO,OAAO,WAAW,iBAAiB;AAC3C;AANgB;AAcT,SAAS,0BACf,4BACyB;AACzB,MAAI,uBAA+C,CAAC;AACpD,MAAI;AACH,QAAI,MAAM,QAAQ,2BAA2B,UAAU,GAAG;AACzD,6BAAuB,2BAA2B,WAAW;AAAA,QAC5D,CAAC,eAAe;AAAA,UACf,WAAW;AAAA,YACV,IAAI,UAAU;AAAA,YACd,YAAY,IAAI,MAAM,UAAU,aAAa;AAAA,UAC9C;AAAA,UACA,iBAAiB,UAAU;AAAA,QAC5B;AAAA,MACD;AAAA,IACD;AAAA,EACD,SAAS,GAAG;AAAA,EAEZ;AAEA,SAAO;AACR;AArBgB;AA4BT,SAAS,uBACf,4BACsB;AACtB,MAAI,oBAAyC,CAAC;AAC9C,MAAI;AACH,QAAI,MAAM,QAAQ,2BAA2B,OAAO,GAAG;AACtD,0BAAoB,2BAA2B,QAAQ;AAAA,QACtD,CAAC,YAAY;AAAA,UACZ,WAAW,IAAI,MAAM,OAAO,SAAS;AAAA,UACrC,iBAAiB,OAAO;AAAA,QACzB;AAAA,MACD;AAAA,IACD;AAAA,EACD,SAAS,GAAG;AAAA,EAEZ;AAEA,SAAO;AACR;AAlBgB;",
  "names": []
}
