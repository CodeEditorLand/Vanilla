{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/backup/node/backup.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from '../../../base/common/uri.js';\nimport { IBaseBackupInfo, IFolderBackupInfo, IWorkspaceBackupInfo } from '../common/backup.js';\n\nexport interface IEmptyWindowBackupInfo extends IBaseBackupInfo {\n\treadonly backupFolder: string;\n}\n\nexport function isEmptyWindowBackupInfo(obj: unknown): obj is IEmptyWindowBackupInfo {\n\tconst candidate = obj as IEmptyWindowBackupInfo | undefined;\n\n\treturn typeof candidate?.backupFolder === 'string';\n}\n\nexport interface ISerializedWorkspaceBackupInfo {\n\treadonly id: string;\n\treadonly configURIPath: string;\n\tremoteAuthority?: string;\n}\n\nexport function deserializeWorkspaceInfos(serializedBackupWorkspaces: ISerializedBackupWorkspaces): IWorkspaceBackupInfo[] {\n\tlet workspaceBackupInfos: IWorkspaceBackupInfo[] = [];\n\ttry {\n\t\tif (Array.isArray(serializedBackupWorkspaces.workspaces)) {\n\t\t\tworkspaceBackupInfos = serializedBackupWorkspaces.workspaces.map(workspace => (\n\t\t\t\t{\n\t\t\t\t\tworkspace: {\n\t\t\t\t\t\tid: workspace.id,\n\t\t\t\t\t\tconfigPath: URI.parse(workspace.configURIPath)\n\t\t\t\t\t},\n\t\t\t\t\tremoteAuthority: workspace.remoteAuthority\n\t\t\t\t}\n\t\t\t));\n\t\t}\n\t} catch (e) {\n\t\t// ignore URI parsing exceptions\n\t}\n\n\treturn workspaceBackupInfos;\n}\n\nexport interface ISerializedFolderBackupInfo {\n\treadonly folderUri: string;\n\tremoteAuthority?: string;\n}\n\nexport function deserializeFolderInfos(serializedBackupWorkspaces: ISerializedBackupWorkspaces): IFolderBackupInfo[] {\n\tlet folderBackupInfos: IFolderBackupInfo[] = [];\n\ttry {\n\t\tif (Array.isArray(serializedBackupWorkspaces.folders)) {\n\t\t\tfolderBackupInfos = serializedBackupWorkspaces.folders.map(folder => (\n\t\t\t\t{\n\t\t\t\t\tfolderUri: URI.parse(folder.folderUri),\n\t\t\t\t\tremoteAuthority: folder.remoteAuthority\n\t\t\t\t}\n\t\t\t));\n\t\t}\n\t} catch (e) {\n\t\t// ignore URI parsing exceptions\n\t}\n\n\treturn folderBackupInfos;\n}\n\nexport interface ISerializedEmptyWindowBackupInfo extends IEmptyWindowBackupInfo { }\n\nexport interface ILegacySerializedBackupWorkspaces {\n\treadonly rootURIWorkspaces: ISerializedWorkspaceBackupInfo[];\n\treadonly folderWorkspaceInfos: ISerializedFolderBackupInfo[];\n\treadonly emptyWorkspaceInfos: ISerializedEmptyWindowBackupInfo[];\n}\n\nexport interface ISerializedBackupWorkspaces {\n\treadonly workspaces: ISerializedWorkspaceBackupInfo[];\n\treadonly folders: ISerializedFolderBackupInfo[];\n\treadonly emptyWindows: ISerializedEmptyWindowBackupInfo[];\n}\n"],
  "mappings": ";;AAKA,SAAS,WAAW;AACpB,SAAS,iBAAiB,mBAAmB,4BAA4B;AAMlE,SAAS,wBAAwB,KAA6C;AACpF,QAAM,YAAY;AAElB,SAAO,OAAO,WAAW,iBAAiB;AAC3C;AAJgB;AAYT,SAAS,0BAA0B,4BAAiF;AAC1H,MAAI,uBAA+C,CAAC;AACpD,MAAI;AACH,QAAI,MAAM,QAAQ,2BAA2B,UAAU,GAAG;AACzD,6BAAuB,2BAA2B,WAAW,IAAI,gBAChE;AAAA,QACC,WAAW;AAAA,UACV,IAAI,UAAU;AAAA,UACd,YAAY,IAAI,MAAM,UAAU,aAAa;AAAA,QAC9C;AAAA,QACA,iBAAiB,UAAU;AAAA,MAC5B,EACA;AAAA,IACF;AAAA,EACD,SAAS,GAAG;AAAA,EAEZ;AAEA,SAAO;AACR;AAnBgB;AA0BT,SAAS,uBAAuB,4BAA8E;AACpH,MAAI,oBAAyC,CAAC;AAC9C,MAAI;AACH,QAAI,MAAM,QAAQ,2BAA2B,OAAO,GAAG;AACtD,0BAAoB,2BAA2B,QAAQ,IAAI,aAC1D;AAAA,QACC,WAAW,IAAI,MAAM,OAAO,SAAS;AAAA,QACrC,iBAAiB,OAAO;AAAA,MACzB,EACA;AAAA,IACF;AAAA,EACD,SAAS,GAAG;AAAA,EAEZ;AAEA,SAAO;AACR;AAhBgB;",
  "names": []
}
