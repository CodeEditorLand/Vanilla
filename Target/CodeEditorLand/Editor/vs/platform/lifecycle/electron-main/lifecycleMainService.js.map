{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/lifecycle/electron-main/lifecycleMainService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport electron from \"electron\";\nimport { Barrier, Promises, timeout } from \"../../../base/common/async.js\";\nimport { Emitter, Event } from \"../../../base/common/event.js\";\nimport { Disposable, DisposableStore } from \"../../../base/common/lifecycle.js\";\nimport { isMacintosh, isWindows } from \"../../../base/common/platform.js\";\nimport { cwd } from \"../../../base/common/process.js\";\nimport { assertIsDefined } from \"../../../base/common/types.js\";\nimport { validatedIpcMain } from \"../../../base/parts/ipc/electron-main/ipcMain.js\";\nimport type { IAuxiliaryWindow } from \"../../auxiliaryWindow/electron-main/auxiliaryWindow.js\";\nimport type { NativeParsedArgs } from \"../../environment/common/argv.js\";\nimport { IEnvironmentMainService } from \"../../environment/electron-main/environmentMainService.js\";\nimport { createDecorator } from \"../../instantiation/common/instantiation.js\";\nimport { ILogService } from \"../../log/common/log.js\";\nimport { IStateService } from \"../../state/node/state.js\";\nimport {\n\ttype ICodeWindow,\n\ttype LoadReason,\n\tUnloadReason,\n} from \"../../window/electron-main/window.js\";\nimport type {\n\tISingleFolderWorkspaceIdentifier,\n\tIWorkspaceIdentifier,\n} from \"../../workspace/common/workspace.js\";\n\nexport const ILifecycleMainService = createDecorator<ILifecycleMainService>(\n\t\"lifecycleMainService\",\n);\n\ninterface WindowLoadEvent {\n\t/**\n\t * The window that is loaded to a new workspace.\n\t */\n\treadonly window: ICodeWindow;\n\n\t/**\n\t * The workspace the window is loaded into.\n\t */\n\treadonly workspace:\n\t\t| IWorkspaceIdentifier\n\t\t| ISingleFolderWorkspaceIdentifier\n\t\t| undefined;\n\n\t/**\n\t * More details why the window loads to a new workspace.\n\t */\n\treadonly reason: LoadReason;\n}\n\nexport enum ShutdownReason {\n\t/**\n\t * The application exits normally.\n\t */\n\tQUIT = 1,\n\n\t/**\n\t * The application exits abnormally and is being\n\t * killed with an exit code (e.g. from integration\n\t * test run)\n\t */\n\tKILL = 2,\n}\n\nexport interface ShutdownEvent {\n\t/**\n\t * More details why the application is shutting down.\n\t */\n\treason: ShutdownReason;\n\n\t/**\n\t * Allows to join the shutdown. The promise can be a long running operation but it\n\t * will block the application from closing.\n\t */\n\tjoin(id: string, promise: Promise<void>): void;\n}\n\nexport interface IRelaunchHandler {\n\t/**\n\t * Allows a handler to deal with relaunching the application. The return\n\t * value indicates if the relaunch is handled or not.\n\t */\n\thandleRelaunch(options?: IRelaunchOptions): boolean;\n}\n\nexport interface IRelaunchOptions {\n\treadonly addArgs?: string[];\n\treadonly removeArgs?: string[];\n}\n\nexport interface ILifecycleMainService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Will be true if the program was restarted (e.g. due to explicit request or update).\n\t */\n\treadonly wasRestarted: boolean;\n\n\t/**\n\t * Will be true if the program was requested to quit.\n\t */\n\treadonly quitRequested: boolean;\n\n\t/**\n\t * A flag indicating in what phase of the lifecycle we currently are.\n\t */\n\tphase: LifecycleMainPhase;\n\n\t/**\n\t * An event that fires when the application is about to shutdown before any window is closed.\n\t * The shutdown can still be prevented by any window that vetos this event.\n\t */\n\treadonly onBeforeShutdown: Event<void>;\n\n\t/**\n\t * An event that fires after the onBeforeShutdown event has been fired and after no window has\n\t * vetoed the shutdown sequence. At this point listeners are ensured that the application will\n\t * quit without veto.\n\t */\n\treadonly onWillShutdown: Event<ShutdownEvent>;\n\n\t/**\n\t * An event that fires when a window is loading. This can either be a window opening for the\n\t * first time or a window reloading or changing to another URL.\n\t */\n\treadonly onWillLoadWindow: Event<WindowLoadEvent>;\n\n\t/**\n\t * An event that fires before a window closes. This event is fired after any veto has been dealt\n\t * with so that listeners know for sure that the window will close without veto.\n\t */\n\treadonly onBeforeCloseWindow: Event<ICodeWindow>;\n\n\t/**\n\t * Make a `ICodeWindow` known to the lifecycle main service.\n\t */\n\tregisterWindow(window: ICodeWindow): void;\n\n\t/**\n\t * Make a `IAuxiliaryWindow` known to the lifecycle main service.\n\t */\n\tregisterAuxWindow(auxWindow: IAuxiliaryWindow): void;\n\n\t/**\n\t * Reload a window. All lifecycle event handlers are triggered.\n\t */\n\treload(window: ICodeWindow, cli?: NativeParsedArgs): Promise<void>;\n\n\t/**\n\t * Unload a window for the provided reason. All lifecycle event handlers are triggered.\n\t */\n\tunload(\n\t\twindow: ICodeWindow,\n\t\treason: UnloadReason,\n\t): Promise<boolean /* veto */>;\n\n\t/**\n\t * Restart the application with optional arguments (CLI). All lifecycle event handlers are triggered.\n\t */\n\trelaunch(options?: IRelaunchOptions): Promise<void>;\n\n\t/**\n\t * Sets a custom handler for relaunching the application.\n\t */\n\tsetRelaunchHandler(handler: IRelaunchHandler): void;\n\n\t/**\n\t * Shutdown the application normally. All lifecycle event handlers are triggered.\n\t */\n\tquit(willRestart?: boolean): Promise<boolean /* veto */>;\n\n\t/**\n\t * Forcefully shutdown the application and optionally set an exit code.\n\t *\n\t * This method should only be used in rare situations where it is important\n\t * to set an exit code (e.g. running tests) or when the application is\n\t * not in a healthy state and should terminate asap.\n\t *\n\t * This method does not fire the normal lifecycle events to the windows,\n\t * that normally can be vetoed. Windows are destroyed without a chance\n\t * of components to participate. The only lifecycle event handler that\n\t * is triggered is `onWillShutdown` in the main process.\n\t */\n\tkill(code?: number): Promise<void>;\n\n\t/**\n\t * Returns a promise that resolves when a certain lifecycle phase\n\t * has started.\n\t */\n\twhen(phase: LifecycleMainPhase): Promise<void>;\n}\n\nexport enum LifecycleMainPhase {\n\t/**\n\t * The first phase signals that we are about to startup.\n\t */\n\tStarting = 1,\n\n\t/**\n\t * Services are ready and first window is about to open.\n\t */\n\tReady = 2,\n\n\t/**\n\t * This phase signals a point in time after the window has opened\n\t * and is typically the best place to do work that is not required\n\t * for the window to open.\n\t */\n\tAfterWindowOpen = 3,\n\n\t/**\n\t * The last phase after a window has opened and some time has passed\n\t * (2-5 seconds).\n\t */\n\tEventually = 4,\n}\n\nexport class LifecycleMainService\n\textends Disposable\n\timplements ILifecycleMainService\n{\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate static readonly QUIT_AND_RESTART_KEY = \"lifecycle.quitAndRestart\";\n\n\tprivate readonly _onBeforeShutdown = this._register(new Emitter<void>());\n\treadonly onBeforeShutdown = this._onBeforeShutdown.event;\n\n\tprivate readonly _onWillShutdown = this._register(\n\t\tnew Emitter<ShutdownEvent>(),\n\t);\n\treadonly onWillShutdown = this._onWillShutdown.event;\n\n\tprivate readonly _onWillLoadWindow = this._register(\n\t\tnew Emitter<WindowLoadEvent>(),\n\t);\n\treadonly onWillLoadWindow = this._onWillLoadWindow.event;\n\n\tprivate readonly _onBeforeCloseWindow = this._register(\n\t\tnew Emitter<ICodeWindow>(),\n\t);\n\treadonly onBeforeCloseWindow = this._onBeforeCloseWindow.event;\n\n\tprivate _quitRequested = false;\n\tget quitRequested(): boolean {\n\t\treturn this._quitRequested;\n\t}\n\n\tprivate _wasRestarted = false;\n\tget wasRestarted(): boolean {\n\t\treturn this._wasRestarted;\n\t}\n\n\tprivate _phase = LifecycleMainPhase.Starting;\n\tget phase(): LifecycleMainPhase {\n\t\treturn this._phase;\n\t}\n\n\tprivate readonly windowToCloseRequest = new Set<number>();\n\tprivate oneTimeListenerTokenGenerator = 0;\n\tprivate windowCounter = 0;\n\n\tprivate pendingQuitPromise: Promise<boolean> | undefined = undefined;\n\tprivate pendingQuitPromiseResolve: { (veto: boolean): void } | undefined =\n\t\tundefined;\n\n\tprivate pendingWillShutdownPromise: Promise<void> | undefined = undefined;\n\n\tprivate readonly mapWindowIdToPendingUnload = new Map<\n\t\tnumber,\n\t\tPromise<boolean>\n\t>();\n\n\tprivate readonly phaseWhen = new Map<LifecycleMainPhase, Barrier>();\n\n\tprivate relaunchHandler: IRelaunchHandler | undefined = undefined;\n\n\tconstructor(\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IStateService private readonly stateService: IStateService,\n\t\t@IEnvironmentMainService private readonly environmentMainService: IEnvironmentMainService\n\t) {\n\t\tsuper();\n\n\t\tthis.resolveRestarted();\n\t\tthis.when(LifecycleMainPhase.Ready).then(() => this.registerListeners());\n\t}\n\n\tprivate resolveRestarted(): void {\n\t\tthis._wasRestarted = !!this.stateService.getItem(\n\t\t\tLifecycleMainService.QUIT_AND_RESTART_KEY,\n\t\t);\n\n\t\tif (this._wasRestarted) {\n\t\t\t// remove the marker right after if found\n\t\t\tthis.stateService.removeItem(\n\t\t\t\tLifecycleMainService.QUIT_AND_RESTART_KEY,\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate registerListeners(): void {\n\t\t// before-quit: an event that is fired if application quit was\n\t\t// requested but before any window was closed.\n\t\tconst beforeQuitListener = () => {\n\t\t\tif (this._quitRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.trace(\"Lifecycle#app.on(before-quit)\");\n\t\t\tthis._quitRequested = true;\n\n\t\t\t// Emit event to indicate that we are about to shutdown\n\t\t\tthis.trace(\"Lifecycle#onBeforeShutdown.fire()\");\n\t\t\tthis._onBeforeShutdown.fire();\n\n\t\t\t// macOS: can run without any window open. in that case we fire\n\t\t\t// the onWillShutdown() event directly because there is no veto\n\t\t\t// to be expected.\n\t\t\tif (isMacintosh && this.windowCounter === 0) {\n\t\t\t\tthis.fireOnWillShutdown(ShutdownReason.QUIT);\n\t\t\t}\n\t\t};\n\t\telectron.app.addListener(\"before-quit\", beforeQuitListener);\n\n\t\t// window-all-closed: an event that only fires when the last window\n\t\t// was closed. We override this event to be in charge if app.quit()\n\t\t// should be called or not.\n\t\tconst windowAllClosedListener = () => {\n\t\t\tthis.trace(\"Lifecycle#app.on(window-all-closed)\");\n\n\t\t\t// Windows/Linux: we quit when all windows have closed\n\t\t\t// Mac: we only quit when quit was requested\n\t\t\tif (this._quitRequested || !isMacintosh) {\n\t\t\t\telectron.app.quit();\n\t\t\t}\n\t\t};\n\t\telectron.app.addListener(\"window-all-closed\", windowAllClosedListener);\n\n\t\t// will-quit: an event that is fired after all windows have been\n\t\t// closed, but before actually quitting.\n\t\telectron.app.once(\"will-quit\", (e) => {\n\t\t\tthis.trace(\"Lifecycle#app.on(will-quit) - begin\");\n\n\t\t\t// Prevent the quit until the shutdown promise was resolved\n\t\t\te.preventDefault();\n\n\t\t\t// Start shutdown sequence\n\t\t\tconst shutdownPromise = this.fireOnWillShutdown(\n\t\t\t\tShutdownReason.QUIT,\n\t\t\t);\n\n\t\t\t// Wait until shutdown is signaled to be complete\n\t\t\tshutdownPromise.finally(() => {\n\t\t\t\tthis.trace(\n\t\t\t\t\t\"Lifecycle#app.on(will-quit) - after fireOnWillShutdown\",\n\t\t\t\t);\n\n\t\t\t\t// Resolve pending quit promise now without veto\n\t\t\t\tthis.resolvePendingQuitPromise(false /* no veto */);\n\n\t\t\t\t// Quit again, this time do not prevent this, since our\n\t\t\t\t// will-quit listener is only installed \"once\". Also\n\t\t\t\t// remove any listener we have that is no longer needed\n\n\t\t\t\telectron.app.removeListener(\"before-quit\", beforeQuitListener);\n\t\t\t\telectron.app.removeListener(\n\t\t\t\t\t\"window-all-closed\",\n\t\t\t\t\twindowAllClosedListener,\n\t\t\t\t);\n\n\t\t\t\tthis.trace(\"Lifecycle#app.on(will-quit) - calling app.quit()\");\n\n\t\t\t\telectron.app.quit();\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate fireOnWillShutdown(reason: ShutdownReason): Promise<void> {\n\t\tif (this.pendingWillShutdownPromise) {\n\t\t\treturn this.pendingWillShutdownPromise; // shutdown is already running\n\t\t}\n\n\t\tconst logService = this.logService;\n\t\tthis.trace(\"Lifecycle#onWillShutdown.fire()\");\n\n\t\tconst joiners: Promise<void>[] = [];\n\n\t\tthis._onWillShutdown.fire({\n\t\t\treason,\n\t\t\tjoin(id, promise) {\n\t\t\t\tlogService.trace(`Lifecycle#onWillShutdown - begin '${id}'`);\n\t\t\t\tjoiners.push(\n\t\t\t\t\tpromise.finally(() => {\n\t\t\t\t\t\tlogService.trace(\n\t\t\t\t\t\t\t`Lifecycle#onWillShutdown - end '${id}'`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t},\n\t\t});\n\n\t\tthis.pendingWillShutdownPromise = (async () => {\n\t\t\t// Settle all shutdown event joiners\n\t\t\ttry {\n\t\t\t\tawait Promises.settled(joiners);\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.error(error);\n\t\t\t}\n\n\t\t\t// Then, always make sure at the end\n\t\t\t// the state service is flushed.\n\t\t\ttry {\n\t\t\t\tawait this.stateService.close();\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.error(error);\n\t\t\t}\n\t\t})();\n\n\t\treturn this.pendingWillShutdownPromise;\n\t}\n\n\tset phase(value: LifecycleMainPhase) {\n\t\tif (value < this.phase) {\n\t\t\tthrow new Error(\"Lifecycle cannot go backwards\");\n\t\t}\n\n\t\tif (this._phase === value) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.trace(`lifecycle (main): phase changed (value: ${value})`);\n\n\t\tthis._phase = value;\n\n\t\tconst barrier = this.phaseWhen.get(this._phase);\n\t\tif (barrier) {\n\t\t\tbarrier.open();\n\t\t\tthis.phaseWhen.delete(this._phase);\n\t\t}\n\t}\n\n\tasync when(phase: LifecycleMainPhase): Promise<void> {\n\t\tif (phase <= this._phase) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet barrier = this.phaseWhen.get(phase);\n\t\tif (!barrier) {\n\t\t\tbarrier = new Barrier();\n\t\t\tthis.phaseWhen.set(phase, barrier);\n\t\t}\n\n\t\tawait barrier.wait();\n\t}\n\n\tregisterWindow(window: ICodeWindow): void {\n\t\tconst windowListeners = new DisposableStore();\n\n\t\t// track window count\n\t\tthis.windowCounter++;\n\n\t\t// Window Will Load\n\t\twindowListeners.add(\n\t\t\twindow.onWillLoad((e) =>\n\t\t\t\tthis._onWillLoadWindow.fire({\n\t\t\t\t\twindow,\n\t\t\t\t\tworkspace: e.workspace,\n\t\t\t\t\treason: e.reason,\n\t\t\t\t}),\n\t\t\t),\n\t\t);\n\n\t\t// Window Before Closing: Main -> Renderer\n\t\tconst win = assertIsDefined(window.win);\n\t\twindowListeners.add(\n\t\t\tEvent.fromNodeEventEmitter<electron.Event>(\n\t\t\t\twin,\n\t\t\t\t\"close\",\n\t\t\t)((e) => {\n\t\t\t\t// The window already acknowledged to be closed\n\t\t\t\tconst windowId = window.id;\n\t\t\t\tif (this.windowToCloseRequest.has(windowId)) {\n\t\t\t\t\tthis.windowToCloseRequest.delete(windowId);\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.trace(\n\t\t\t\t\t`Lifecycle#window.on('close') - window ID ${window.id}`,\n\t\t\t\t);\n\n\t\t\t\t// Otherwise prevent unload and handle it from window\n\t\t\t\te.preventDefault();\n\t\t\t\tthis.unload(window, UnloadReason.CLOSE).then((veto) => {\n\t\t\t\t\tif (veto) {\n\t\t\t\t\t\tthis.windowToCloseRequest.delete(windowId);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.windowToCloseRequest.add(windowId);\n\n\t\t\t\t\t// Fire onBeforeCloseWindow before actually closing\n\t\t\t\t\tthis.trace(\n\t\t\t\t\t\t`Lifecycle#onBeforeCloseWindow.fire() - window ID ${windowId}`,\n\t\t\t\t\t);\n\t\t\t\t\tthis._onBeforeCloseWindow.fire(window);\n\n\t\t\t\t\t// No veto, close window now\n\t\t\t\t\twindow.close();\n\t\t\t\t});\n\t\t\t}),\n\t\t);\n\t\twindowListeners.add(\n\t\t\tEvent.fromNodeEventEmitter<electron.Event>(\n\t\t\t\twin,\n\t\t\t\t\"closed\",\n\t\t\t)(() => {\n\t\t\t\tthis.trace(\n\t\t\t\t\t`Lifecycle#window.on('closed') - window ID ${window.id}`,\n\t\t\t\t);\n\n\t\t\t\t// update window count\n\t\t\t\tthis.windowCounter--;\n\n\t\t\t\t// clear window listeners\n\t\t\t\twindowListeners.dispose();\n\n\t\t\t\t// if there are no more code windows opened, fire the onWillShutdown event, unless\n\t\t\t\t// we are on macOS where it is perfectly fine to close the last window and\n\t\t\t\t// the application continues running (unless quit was actually requested)\n\t\t\t\tif (\n\t\t\t\t\tthis.windowCounter === 0 &&\n\t\t\t\t\t(!isMacintosh || this._quitRequested)\n\t\t\t\t) {\n\t\t\t\t\tthis.fireOnWillShutdown(ShutdownReason.QUIT);\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\t}\n\n\tregisterAuxWindow(auxWindow: IAuxiliaryWindow): void {\n\t\tconst win = assertIsDefined(auxWindow.win);\n\n\t\tconst windowListeners = new DisposableStore();\n\t\twindowListeners.add(\n\t\t\tEvent.fromNodeEventEmitter<electron.Event>(\n\t\t\t\twin,\n\t\t\t\t\"close\",\n\t\t\t)((e) => {\n\t\t\t\tthis.trace(\n\t\t\t\t\t`Lifecycle#auxWindow.on('close') - window ID ${auxWindow.id}`,\n\t\t\t\t);\n\n\t\t\t\tif (this._quitRequested) {\n\t\t\t\t\tthis.trace(\n\t\t\t\t\t\t`Lifecycle#auxWindow.on('close') - preventDefault() because quit requested`,\n\t\t\t\t\t);\n\n\t\t\t\t\t// When quit is requested, Electron will close all\n\t\t\t\t\t// auxiliary windows before closing the main windows.\n\t\t\t\t\t// This prevents us from storing the auxiliary window\n\t\t\t\t\t// state on shutdown and thus we prevent closing if\n\t\t\t\t\t// quit is requested.\n\t\t\t\t\t//\n\t\t\t\t\t// Interestingly, this will not prevent the application\n\t\t\t\t\t// from quitting because the auxiliary windows will still\n\t\t\t\t\t// close once the owning window closes.\n\n\t\t\t\t\te.preventDefault();\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\t\twindowListeners.add(\n\t\t\tEvent.fromNodeEventEmitter<electron.Event>(\n\t\t\t\twin,\n\t\t\t\t\"closed\",\n\t\t\t)(() => {\n\t\t\t\tthis.trace(\n\t\t\t\t\t`Lifecycle#auxWindow.on('closed') - window ID ${auxWindow.id}`,\n\t\t\t\t);\n\n\t\t\t\twindowListeners.dispose();\n\t\t\t}),\n\t\t);\n\t}\n\n\tasync reload(window: ICodeWindow, cli?: NativeParsedArgs): Promise<void> {\n\t\t// Only reload when the window has not vetoed this\n\t\tconst veto = await this.unload(window, UnloadReason.RELOAD);\n\t\tif (!veto) {\n\t\t\twindow.reload(cli);\n\t\t}\n\t}\n\n\tunload(\n\t\twindow: ICodeWindow,\n\t\treason: UnloadReason,\n\t): Promise<boolean /* veto */> {\n\t\t// Ensure there is only 1 unload running at the same time\n\t\tconst pendingUnloadPromise = this.mapWindowIdToPendingUnload.get(\n\t\t\twindow.id,\n\t\t);\n\t\tif (pendingUnloadPromise) {\n\t\t\treturn pendingUnloadPromise;\n\t\t}\n\n\t\t// Start unload and remember in map until finished\n\t\tconst unloadPromise = this.doUnload(window, reason).finally(() => {\n\t\t\tthis.mapWindowIdToPendingUnload.delete(window.id);\n\t\t});\n\t\tthis.mapWindowIdToPendingUnload.set(window.id, unloadPromise);\n\n\t\treturn unloadPromise;\n\t}\n\n\tprivate async doUnload(\n\t\twindow: ICodeWindow,\n\t\treason: UnloadReason,\n\t): Promise<boolean /* veto */> {\n\t\t// Always allow to unload a window that is not yet ready\n\t\tif (!window.isReady) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.trace(`Lifecycle#unload() - window ID ${window.id}`);\n\n\t\t// first ask the window itself if it vetos the unload\n\t\tconst windowUnloadReason = this._quitRequested\n\t\t\t? UnloadReason.QUIT\n\t\t\t: reason;\n\t\tconst veto = await this.onBeforeUnloadWindowInRenderer(\n\t\t\twindow,\n\t\t\twindowUnloadReason,\n\t\t);\n\t\tif (veto) {\n\t\t\tthis.trace(\n\t\t\t\t`Lifecycle#unload() - veto in renderer (window ID ${window.id})`,\n\t\t\t);\n\n\t\t\treturn this.handleWindowUnloadVeto(veto);\n\t\t}\n\n\t\t// finally if there are no vetos, unload the renderer\n\t\tawait this.onWillUnloadWindowInRenderer(window, windowUnloadReason);\n\n\t\treturn false;\n\t}\n\n\tprivate handleWindowUnloadVeto(veto: boolean): boolean {\n\t\tif (!veto) {\n\t\t\treturn false; // no veto\n\t\t}\n\n\t\t// a veto resolves any pending quit with veto\n\t\tthis.resolvePendingQuitPromise(true /* veto */);\n\n\t\t// a veto resets the pending quit request flag\n\t\tthis._quitRequested = false;\n\n\t\treturn true; // veto\n\t}\n\n\tprivate resolvePendingQuitPromise(veto: boolean): void {\n\t\tif (this.pendingQuitPromiseResolve) {\n\t\t\tthis.pendingQuitPromiseResolve(veto);\n\t\t\tthis.pendingQuitPromiseResolve = undefined;\n\t\t\tthis.pendingQuitPromise = undefined;\n\t\t}\n\t}\n\n\tprivate onBeforeUnloadWindowInRenderer(\n\t\twindow: ICodeWindow,\n\t\treason: UnloadReason,\n\t): Promise<boolean /* veto */> {\n\t\treturn new Promise<boolean>((resolve) => {\n\t\t\tconst oneTimeEventToken = this.oneTimeListenerTokenGenerator++;\n\t\t\tconst okChannel = `vscode:ok${oneTimeEventToken}`;\n\t\t\tconst cancelChannel = `vscode:cancel${oneTimeEventToken}`;\n\n\t\t\tvalidatedIpcMain.once(okChannel, () => {\n\t\t\t\tresolve(false); // no veto\n\t\t\t});\n\n\t\t\tvalidatedIpcMain.once(cancelChannel, () => {\n\t\t\t\tresolve(true); // veto\n\t\t\t});\n\n\t\t\twindow.send(\"vscode:onBeforeUnload\", {\n\t\t\t\tokChannel,\n\t\t\t\tcancelChannel,\n\t\t\t\treason,\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate onWillUnloadWindowInRenderer(\n\t\twindow: ICodeWindow,\n\t\treason: UnloadReason,\n\t): Promise<void> {\n\t\treturn new Promise<void>((resolve) => {\n\t\t\tconst oneTimeEventToken = this.oneTimeListenerTokenGenerator++;\n\t\t\tconst replyChannel = `vscode:reply${oneTimeEventToken}`;\n\n\t\t\tvalidatedIpcMain.once(replyChannel, () => resolve());\n\n\t\t\twindow.send(\"vscode:onWillUnload\", { replyChannel, reason });\n\t\t});\n\t}\n\n\tquit(willRestart?: boolean): Promise<boolean /* veto */> {\n\t\treturn this.doQuit(willRestart).then((veto) => {\n\t\t\tif (!veto && willRestart) {\n\t\t\t\t// Windows: we are about to restart and as such we need to restore the original\n\t\t\t\t// current working directory we had on startup to get the exact same startup\n\t\t\t\t// behaviour. As such, we briefly change back to that directory and then when\n\t\t\t\t// Code starts it will set it back to the installation directory again.\n\t\t\t\ttry {\n\t\t\t\t\tif (isWindows) {\n\t\t\t\t\t\tconst currentWorkingDir = cwd();\n\t\t\t\t\t\tif (currentWorkingDir !== process.cwd()) {\n\t\t\t\t\t\t\tprocess.chdir(currentWorkingDir);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (err) {\n\t\t\t\t\tthis.logService.error(err);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn veto;\n\t\t});\n\t}\n\n\tprivate doQuit(willRestart?: boolean): Promise<boolean /* veto */> {\n\t\tthis.trace(`Lifecycle#quit() - begin (willRestart: ${willRestart})`);\n\n\t\tif (this.pendingQuitPromise) {\n\t\t\tthis.trace(\"Lifecycle#quit() - returning pending quit promise\");\n\n\t\t\treturn this.pendingQuitPromise;\n\t\t}\n\n\t\t// Remember if we are about to restart\n\t\tif (willRestart) {\n\t\t\tthis.stateService.setItem(\n\t\t\t\tLifecycleMainService.QUIT_AND_RESTART_KEY,\n\t\t\t\ttrue,\n\t\t\t);\n\t\t}\n\n\t\tthis.pendingQuitPromise = new Promise((resolve) => {\n\t\t\t// Store as field to access it from a window cancellation\n\t\t\tthis.pendingQuitPromiseResolve = resolve;\n\n\t\t\t// Calling app.quit() will trigger the close handlers of each opened window\n\t\t\t// and only if no window vetoed the shutdown, we will get the will-quit event\n\t\t\tthis.trace(\"Lifecycle#quit() - calling app.quit()\");\n\t\t\telectron.app.quit();\n\t\t});\n\n\t\treturn this.pendingQuitPromise;\n\t}\n\n\tprivate trace(msg: string): void {\n\t\tif (this.environmentMainService.args[\"enable-smoke-test-driver\"]) {\n\t\t\tthis.logService.info(msg); // helps diagnose issues with exiting from smoke tests\n\t\t} else {\n\t\t\tthis.logService.trace(msg);\n\t\t}\n\t}\n\n\tsetRelaunchHandler(handler: IRelaunchHandler): void {\n\t\tthis.relaunchHandler = handler;\n\t}\n\n\tasync relaunch(options?: IRelaunchOptions): Promise<void> {\n\t\tthis.trace(\"Lifecycle#relaunch()\");\n\n\t\tconst args = process.argv.slice(1);\n\t\tif (options?.addArgs) {\n\t\t\targs.push(...options.addArgs);\n\t\t}\n\n\t\tif (options?.removeArgs) {\n\t\t\tfor (const a of options.removeArgs) {\n\t\t\t\tconst idx = args.indexOf(a);\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\targs.splice(idx, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst quitListener = () => {\n\t\t\tif (!this.relaunchHandler?.handleRelaunch(options)) {\n\t\t\t\tthis.trace(\"Lifecycle#relaunch() - calling app.relaunch()\");\n\t\t\t\telectron.app.relaunch({ args });\n\t\t\t}\n\t\t};\n\t\telectron.app.once(\"quit\", quitListener);\n\n\t\t// `app.relaunch()` does not quit automatically, so we quit first,\n\t\t// check for vetoes and then relaunch from the `app.on('quit')` event\n\t\tconst veto = await this.quit(true /* will restart */);\n\t\tif (veto) {\n\t\t\telectron.app.removeListener(\"quit\", quitListener);\n\t\t}\n\t}\n\n\tasync kill(code?: number): Promise<void> {\n\t\tthis.trace(\"Lifecycle#kill()\");\n\n\t\t// Give main process participants a chance to orderly shutdown\n\t\tawait this.fireOnWillShutdown(ShutdownReason.KILL);\n\n\t\t// From extension tests we have seen issues where calling app.exit()\n\t\t// with an opened window can lead to native crashes (Linux). As such,\n\t\t// we should make sure to destroy any opened window before calling\n\t\t// `app.exit()`.\n\t\t//\n\t\t// Note: Electron implements a similar logic here:\n\t\t// https://github.com/electron/electron/blob/fe5318d753637c3903e23fc1ed1b263025887b6a/spec-main/window-helpers.ts#L5\n\n\t\tawait Promise.race([\n\t\t\t// Still do not block more than 1s\n\t\t\ttimeout(1000),\n\n\t\t\t// Destroy any opened window: we do not unload windows here because\n\t\t\t// there is a chance that the unload is veto'd or long running due\n\t\t\t// to a participant within the window. this is not wanted when we\n\t\t\t// are asked to kill the application.\n\t\t\t(async () => {\n\t\t\t\tfor (const window of electron.BrowserWindow.getAllWindows()) {\n\t\t\t\t\tif (window && !window.isDestroyed()) {\n\t\t\t\t\t\tlet whenWindowClosed: Promise<void>;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\twindow.webContents &&\n\t\t\t\t\t\t\t!window.webContents.isDestroyed()\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\twhenWindowClosed = new Promise((resolve) =>\n\t\t\t\t\t\t\t\twindow.once(\"closed\", resolve),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twhenWindowClosed = Promise.resolve();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twindow.destroy();\n\t\t\t\t\t\tawait whenWindowClosed;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})(),\n\t\t]);\n\n\t\t// Now exit either after 1s or all windows destroyed\n\t\telectron.app.exit(code);\n\t}\n}\n"],
  "mappings": "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",
  "names": ["ShutdownReason", "LifecycleMainPhase"]
}
