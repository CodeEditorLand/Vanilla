{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/lifecycle/electron-main/lifecycleMainService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport electron from 'electron';\nimport { validatedIpcMain } from '../../../base/parts/ipc/electron-main/ipcMain.js';\nimport { Barrier, Promises, timeout } from '../../../base/common/async.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { Disposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport { isMacintosh, isWindows } from '../../../base/common/platform.js';\nimport { cwd } from '../../../base/common/process.js';\nimport { assertIsDefined } from '../../../base/common/types.js';\nimport { NativeParsedArgs } from '../../environment/common/argv.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { IStateService } from '../../state/node/state.js';\nimport { ICodeWindow, LoadReason, UnloadReason } from '../../window/electron-main/window.js';\nimport { ISingleFolderWorkspaceIdentifier, IWorkspaceIdentifier } from '../../workspace/common/workspace.js';\nimport { IEnvironmentMainService } from '../../environment/electron-main/environmentMainService.js';\nimport { IAuxiliaryWindow } from '../../auxiliaryWindow/electron-main/auxiliaryWindow.js';\n\nexport const ILifecycleMainService = createDecorator<ILifecycleMainService>('lifecycleMainService');\n\ninterface WindowLoadEvent {\n\n\t/**\n\t * The window that is loaded to a new workspace.\n\t */\n\treadonly window: ICodeWindow;\n\n\t/**\n\t * The workspace the window is loaded into.\n\t */\n\treadonly workspace: IWorkspaceIdentifier | ISingleFolderWorkspaceIdentifier | undefined;\n\n\t/**\n\t * More details why the window loads to a new workspace.\n\t */\n\treadonly reason: LoadReason;\n}\n\nexport const enum ShutdownReason {\n\n\t/**\n\t * The application exits normally.\n\t */\n\tQUIT = 1,\n\n\t/**\n\t * The application exits abnormally and is being\n\t * killed with an exit code (e.g. from integration\n\t * test run)\n\t */\n\tKILL\n}\n\nexport interface ShutdownEvent {\n\n\t/**\n\t * More details why the application is shutting down.\n\t */\n\treason: ShutdownReason;\n\n\t/**\n\t * Allows to join the shutdown. The promise can be a long running operation but it\n\t * will block the application from closing.\n\t */\n\tjoin(id: string, promise: Promise<void>): void;\n}\n\nexport interface IRelaunchHandler {\n\n\t/**\n\t * Allows a handler to deal with relaunching the application. The return\n\t * value indicates if the relaunch is handled or not.\n\t */\n\thandleRelaunch(options?: IRelaunchOptions): boolean;\n}\n\nexport interface IRelaunchOptions {\n\treadonly addArgs?: string[];\n\treadonly removeArgs?: string[];\n}\n\nexport interface ILifecycleMainService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Will be true if the program was restarted (e.g. due to explicit request or update).\n\t */\n\treadonly wasRestarted: boolean;\n\n\t/**\n\t * Will be true if the program was requested to quit.\n\t */\n\treadonly quitRequested: boolean;\n\n\t/**\n\t * A flag indicating in what phase of the lifecycle we currently are.\n\t */\n\tphase: LifecycleMainPhase;\n\n\t/**\n\t * An event that fires when the application is about to shutdown before any window is closed.\n\t * The shutdown can still be prevented by any window that vetos this event.\n\t */\n\treadonly onBeforeShutdown: Event<void>;\n\n\t/**\n\t * An event that fires after the onBeforeShutdown event has been fired and after no window has\n\t * vetoed the shutdown sequence. At this point listeners are ensured that the application will\n\t * quit without veto.\n\t */\n\treadonly onWillShutdown: Event<ShutdownEvent>;\n\n\t/**\n\t * An event that fires when a window is loading. This can either be a window opening for the\n\t * first time or a window reloading or changing to another URL.\n\t */\n\treadonly onWillLoadWindow: Event<WindowLoadEvent>;\n\n\t/**\n\t * An event that fires before a window closes. This event is fired after any veto has been dealt\n\t * with so that listeners know for sure that the window will close without veto.\n\t */\n\treadonly onBeforeCloseWindow: Event<ICodeWindow>;\n\n\t/**\n\t * Make a `ICodeWindow` known to the lifecycle main service.\n\t */\n\tregisterWindow(window: ICodeWindow): void;\n\n\t/**\n\t * Make a `IAuxiliaryWindow` known to the lifecycle main service.\n\t */\n\tregisterAuxWindow(auxWindow: IAuxiliaryWindow): void;\n\n\t/**\n\t * Reload a window. All lifecycle event handlers are triggered.\n\t */\n\treload(window: ICodeWindow, cli?: NativeParsedArgs): Promise<void>;\n\n\t/**\n\t * Unload a window for the provided reason. All lifecycle event handlers are triggered.\n\t */\n\tunload(window: ICodeWindow, reason: UnloadReason): Promise<boolean /* veto */>;\n\n\t/**\n\t * Restart the application with optional arguments (CLI). All lifecycle event handlers are triggered.\n\t */\n\trelaunch(options?: IRelaunchOptions): Promise<void>;\n\n\t/**\n\t * Sets a custom handler for relaunching the application.\n\t */\n\tsetRelaunchHandler(handler: IRelaunchHandler): void;\n\n\t/**\n\t * Shutdown the application normally. All lifecycle event handlers are triggered.\n\t */\n\tquit(willRestart?: boolean): Promise<boolean /* veto */>;\n\n\t/**\n\t * Forcefully shutdown the application and optionally set an exit code.\n\t *\n\t * This method should only be used in rare situations where it is important\n\t * to set an exit code (e.g. running tests) or when the application is\n\t * not in a healthy state and should terminate asap.\n\t *\n\t * This method does not fire the normal lifecycle events to the windows,\n\t * that normally can be vetoed. Windows are destroyed without a chance\n\t * of components to participate. The only lifecycle event handler that\n\t * is triggered is `onWillShutdown` in the main process.\n\t */\n\tkill(code?: number): Promise<void>;\n\n\t/**\n\t * Returns a promise that resolves when a certain lifecycle phase\n\t * has started.\n\t */\n\twhen(phase: LifecycleMainPhase): Promise<void>;\n}\n\nexport const enum LifecycleMainPhase {\n\n\t/**\n\t * The first phase signals that we are about to startup.\n\t */\n\tStarting = 1,\n\n\t/**\n\t * Services are ready and first window is about to open.\n\t */\n\tReady = 2,\n\n\t/**\n\t * This phase signals a point in time after the window has opened\n\t * and is typically the best place to do work that is not required\n\t * for the window to open.\n\t */\n\tAfterWindowOpen = 3,\n\n\t/**\n\t * The last phase after a window has opened and some time has passed\n\t * (2-5 seconds).\n\t */\n\tEventually = 4\n}\n\nexport class LifecycleMainService extends Disposable implements ILifecycleMainService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate static readonly QUIT_AND_RESTART_KEY = 'lifecycle.quitAndRestart';\n\n\tprivate readonly _onBeforeShutdown = this._register(new Emitter<void>());\n\treadonly onBeforeShutdown = this._onBeforeShutdown.event;\n\n\tprivate readonly _onWillShutdown = this._register(new Emitter<ShutdownEvent>());\n\treadonly onWillShutdown = this._onWillShutdown.event;\n\n\tprivate readonly _onWillLoadWindow = this._register(new Emitter<WindowLoadEvent>());\n\treadonly onWillLoadWindow = this._onWillLoadWindow.event;\n\n\tprivate readonly _onBeforeCloseWindow = this._register(new Emitter<ICodeWindow>());\n\treadonly onBeforeCloseWindow = this._onBeforeCloseWindow.event;\n\n\tprivate _quitRequested = false;\n\tget quitRequested(): boolean { return this._quitRequested; }\n\n\tprivate _wasRestarted: boolean = false;\n\tget wasRestarted(): boolean { return this._wasRestarted; }\n\n\tprivate _phase = LifecycleMainPhase.Starting;\n\tget phase(): LifecycleMainPhase { return this._phase; }\n\n\tprivate readonly windowToCloseRequest = new Set<number>();\n\tprivate oneTimeListenerTokenGenerator = 0;\n\tprivate windowCounter = 0;\n\n\tprivate pendingQuitPromise: Promise<boolean> | undefined = undefined;\n\tprivate pendingQuitPromiseResolve: { (veto: boolean): void } | undefined = undefined;\n\n\tprivate pendingWillShutdownPromise: Promise<void> | undefined = undefined;\n\n\tprivate readonly mapWindowIdToPendingUnload = new Map<number, Promise<boolean>>();\n\n\tprivate readonly phaseWhen = new Map<LifecycleMainPhase, Barrier>();\n\n\tprivate relaunchHandler: IRelaunchHandler | undefined = undefined;\n\n\tconstructor(\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IStateService private readonly stateService: IStateService,\n\t\t@IEnvironmentMainService private readonly environmentMainService: IEnvironmentMainService\n\t) {\n\t\tsuper();\n\n\t\tthis.resolveRestarted();\n\t\tthis.when(LifecycleMainPhase.Ready).then(() => this.registerListeners());\n\t}\n\n\tprivate resolveRestarted(): void {\n\t\tthis._wasRestarted = !!this.stateService.getItem(LifecycleMainService.QUIT_AND_RESTART_KEY);\n\n\t\tif (this._wasRestarted) {\n\t\t\t// remove the marker right after if found\n\t\t\tthis.stateService.removeItem(LifecycleMainService.QUIT_AND_RESTART_KEY);\n\t\t}\n\t}\n\n\tprivate registerListeners(): void {\n\n\t\t// before-quit: an event that is fired if application quit was\n\t\t// requested but before any window was closed.\n\t\tconst beforeQuitListener = () => {\n\t\t\tif (this._quitRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.trace('Lifecycle#app.on(before-quit)');\n\t\t\tthis._quitRequested = true;\n\n\t\t\t// Emit event to indicate that we are about to shutdown\n\t\t\tthis.trace('Lifecycle#onBeforeShutdown.fire()');\n\t\t\tthis._onBeforeShutdown.fire();\n\n\t\t\t// macOS: can run without any window open. in that case we fire\n\t\t\t// the onWillShutdown() event directly because there is no veto\n\t\t\t// to be expected.\n\t\t\tif (isMacintosh && this.windowCounter === 0) {\n\t\t\t\tthis.fireOnWillShutdown(ShutdownReason.QUIT);\n\t\t\t}\n\t\t};\n\t\telectron.app.addListener('before-quit', beforeQuitListener);\n\n\t\t// window-all-closed: an event that only fires when the last window\n\t\t// was closed. We override this event to be in charge if app.quit()\n\t\t// should be called or not.\n\t\tconst windowAllClosedListener = () => {\n\t\t\tthis.trace('Lifecycle#app.on(window-all-closed)');\n\n\t\t\t// Windows/Linux: we quit when all windows have closed\n\t\t\t// Mac: we only quit when quit was requested\n\t\t\tif (this._quitRequested || !isMacintosh) {\n\t\t\t\telectron.app.quit();\n\t\t\t}\n\t\t};\n\t\telectron.app.addListener('window-all-closed', windowAllClosedListener);\n\n\t\t// will-quit: an event that is fired after all windows have been\n\t\t// closed, but before actually quitting.\n\t\telectron.app.once('will-quit', e => {\n\t\t\tthis.trace('Lifecycle#app.on(will-quit) - begin');\n\n\t\t\t// Prevent the quit until the shutdown promise was resolved\n\t\t\te.preventDefault();\n\n\t\t\t// Start shutdown sequence\n\t\t\tconst shutdownPromise = this.fireOnWillShutdown(ShutdownReason.QUIT);\n\n\t\t\t// Wait until shutdown is signaled to be complete\n\t\t\tshutdownPromise.finally(() => {\n\t\t\t\tthis.trace('Lifecycle#app.on(will-quit) - after fireOnWillShutdown');\n\n\t\t\t\t// Resolve pending quit promise now without veto\n\t\t\t\tthis.resolvePendingQuitPromise(false /* no veto */);\n\n\t\t\t\t// Quit again, this time do not prevent this, since our\n\t\t\t\t// will-quit listener is only installed \"once\". Also\n\t\t\t\t// remove any listener we have that is no longer needed\n\n\t\t\t\telectron.app.removeListener('before-quit', beforeQuitListener);\n\t\t\t\telectron.app.removeListener('window-all-closed', windowAllClosedListener);\n\n\t\t\t\tthis.trace('Lifecycle#app.on(will-quit) - calling app.quit()');\n\n\t\t\t\telectron.app.quit();\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate fireOnWillShutdown(reason: ShutdownReason): Promise<void> {\n\t\tif (this.pendingWillShutdownPromise) {\n\t\t\treturn this.pendingWillShutdownPromise; // shutdown is already running\n\t\t}\n\n\t\tconst logService = this.logService;\n\t\tthis.trace('Lifecycle#onWillShutdown.fire()');\n\n\t\tconst joiners: Promise<void>[] = [];\n\n\t\tthis._onWillShutdown.fire({\n\t\t\treason,\n\t\t\tjoin(id, promise) {\n\t\t\t\tlogService.trace(`Lifecycle#onWillShutdown - begin '${id}'`);\n\t\t\t\tjoiners.push(promise.finally(() => {\n\t\t\t\t\tlogService.trace(`Lifecycle#onWillShutdown - end '${id}'`);\n\t\t\t\t}));\n\t\t\t}\n\t\t});\n\n\t\tthis.pendingWillShutdownPromise = (async () => {\n\n\t\t\t// Settle all shutdown event joiners\n\t\t\ttry {\n\t\t\t\tawait Promises.settled(joiners);\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.error(error);\n\t\t\t}\n\n\t\t\t// Then, always make sure at the end\n\t\t\t// the state service is flushed.\n\t\t\ttry {\n\t\t\t\tawait this.stateService.close();\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.error(error);\n\t\t\t}\n\t\t})();\n\n\t\treturn this.pendingWillShutdownPromise;\n\t}\n\n\tset phase(value: LifecycleMainPhase) {\n\t\tif (value < this.phase) {\n\t\t\tthrow new Error('Lifecycle cannot go backwards');\n\t\t}\n\n\t\tif (this._phase === value) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.trace(`lifecycle (main): phase changed (value: ${value})`);\n\n\t\tthis._phase = value;\n\n\t\tconst barrier = this.phaseWhen.get(this._phase);\n\t\tif (barrier) {\n\t\t\tbarrier.open();\n\t\t\tthis.phaseWhen.delete(this._phase);\n\t\t}\n\t}\n\n\tasync when(phase: LifecycleMainPhase): Promise<void> {\n\t\tif (phase <= this._phase) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet barrier = this.phaseWhen.get(phase);\n\t\tif (!barrier) {\n\t\t\tbarrier = new Barrier();\n\t\t\tthis.phaseWhen.set(phase, barrier);\n\t\t}\n\n\t\tawait barrier.wait();\n\t}\n\n\tregisterWindow(window: ICodeWindow): void {\n\t\tconst windowListeners = new DisposableStore();\n\n\t\t// track window count\n\t\tthis.windowCounter++;\n\n\t\t// Window Will Load\n\t\twindowListeners.add(window.onWillLoad(e => this._onWillLoadWindow.fire({ window, workspace: e.workspace, reason: e.reason })));\n\n\t\t// Window Before Closing: Main -> Renderer\n\t\tconst win = assertIsDefined(window.win);\n\t\twindowListeners.add(Event.fromNodeEventEmitter<electron.Event>(win, 'close')(e => {\n\n\t\t\t// The window already acknowledged to be closed\n\t\t\tconst windowId = window.id;\n\t\t\tif (this.windowToCloseRequest.has(windowId)) {\n\t\t\t\tthis.windowToCloseRequest.delete(windowId);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.trace(`Lifecycle#window.on('close') - window ID ${window.id}`);\n\n\t\t\t// Otherwise prevent unload and handle it from window\n\t\t\te.preventDefault();\n\t\t\tthis.unload(window, UnloadReason.CLOSE).then(veto => {\n\t\t\t\tif (veto) {\n\t\t\t\t\tthis.windowToCloseRequest.delete(windowId);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.windowToCloseRequest.add(windowId);\n\n\t\t\t\t// Fire onBeforeCloseWindow before actually closing\n\t\t\t\tthis.trace(`Lifecycle#onBeforeCloseWindow.fire() - window ID ${windowId}`);\n\t\t\t\tthis._onBeforeCloseWindow.fire(window);\n\n\t\t\t\t// No veto, close window now\n\t\t\t\twindow.close();\n\t\t\t});\n\t\t}));\n\t\twindowListeners.add(Event.fromNodeEventEmitter<electron.Event>(win, 'closed')(() => {\n\t\t\tthis.trace(`Lifecycle#window.on('closed') - window ID ${window.id}`);\n\n\t\t\t// update window count\n\t\t\tthis.windowCounter--;\n\n\t\t\t// clear window listeners\n\t\t\twindowListeners.dispose();\n\n\t\t\t// if there are no more code windows opened, fire the onWillShutdown event, unless\n\t\t\t// we are on macOS where it is perfectly fine to close the last window and\n\t\t\t// the application continues running (unless quit was actually requested)\n\t\t\tif (this.windowCounter === 0 && (!isMacintosh || this._quitRequested)) {\n\t\t\t\tthis.fireOnWillShutdown(ShutdownReason.QUIT);\n\t\t\t}\n\t\t}));\n\t}\n\n\tregisterAuxWindow(auxWindow: IAuxiliaryWindow): void {\n\t\tconst win = assertIsDefined(auxWindow.win);\n\n\t\tconst windowListeners = new DisposableStore();\n\t\twindowListeners.add(Event.fromNodeEventEmitter<electron.Event>(win, 'close')(e => {\n\t\t\tthis.trace(`Lifecycle#auxWindow.on('close') - window ID ${auxWindow.id}`);\n\n\t\t\tif (this._quitRequested) {\n\t\t\t\tthis.trace(`Lifecycle#auxWindow.on('close') - preventDefault() because quit requested`);\n\n\t\t\t\t// When quit is requested, Electron will close all\n\t\t\t\t// auxiliary windows before closing the main windows.\n\t\t\t\t// This prevents us from storing the auxiliary window\n\t\t\t\t// state on shutdown and thus we prevent closing if\n\t\t\t\t// quit is requested.\n\t\t\t\t//\n\t\t\t\t// Interestingly, this will not prevent the application\n\t\t\t\t// from quitting because the auxiliary windows will still\n\t\t\t\t// close once the owning window closes.\n\n\t\t\t\te.preventDefault();\n\t\t\t}\n\t\t}));\n\t\twindowListeners.add(Event.fromNodeEventEmitter<electron.Event>(win, 'closed')(() => {\n\t\t\tthis.trace(`Lifecycle#auxWindow.on('closed') - window ID ${auxWindow.id}`);\n\n\t\t\twindowListeners.dispose();\n\t\t}));\n\t}\n\n\tasync reload(window: ICodeWindow, cli?: NativeParsedArgs): Promise<void> {\n\n\t\t// Only reload when the window has not vetoed this\n\t\tconst veto = await this.unload(window, UnloadReason.RELOAD);\n\t\tif (!veto) {\n\t\t\twindow.reload(cli);\n\t\t}\n\t}\n\n\tunload(window: ICodeWindow, reason: UnloadReason): Promise<boolean /* veto */> {\n\n\t\t// Ensure there is only 1 unload running at the same time\n\t\tconst pendingUnloadPromise = this.mapWindowIdToPendingUnload.get(window.id);\n\t\tif (pendingUnloadPromise) {\n\t\t\treturn pendingUnloadPromise;\n\t\t}\n\n\t\t// Start unload and remember in map until finished\n\t\tconst unloadPromise = this.doUnload(window, reason).finally(() => {\n\t\t\tthis.mapWindowIdToPendingUnload.delete(window.id);\n\t\t});\n\t\tthis.mapWindowIdToPendingUnload.set(window.id, unloadPromise);\n\n\t\treturn unloadPromise;\n\t}\n\n\tprivate async doUnload(window: ICodeWindow, reason: UnloadReason): Promise<boolean /* veto */> {\n\n\t\t// Always allow to unload a window that is not yet ready\n\t\tif (!window.isReady) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.trace(`Lifecycle#unload() - window ID ${window.id}`);\n\n\t\t// first ask the window itself if it vetos the unload\n\t\tconst windowUnloadReason = this._quitRequested ? UnloadReason.QUIT : reason;\n\t\tconst veto = await this.onBeforeUnloadWindowInRenderer(window, windowUnloadReason);\n\t\tif (veto) {\n\t\t\tthis.trace(`Lifecycle#unload() - veto in renderer (window ID ${window.id})`);\n\n\t\t\treturn this.handleWindowUnloadVeto(veto);\n\t\t}\n\n\t\t// finally if there are no vetos, unload the renderer\n\t\tawait this.onWillUnloadWindowInRenderer(window, windowUnloadReason);\n\n\t\treturn false;\n\t}\n\n\tprivate handleWindowUnloadVeto(veto: boolean): boolean {\n\t\tif (!veto) {\n\t\t\treturn false; // no veto\n\t\t}\n\n\t\t// a veto resolves any pending quit with veto\n\t\tthis.resolvePendingQuitPromise(true /* veto */);\n\n\t\t// a veto resets the pending quit request flag\n\t\tthis._quitRequested = false;\n\n\t\treturn true; // veto\n\t}\n\n\tprivate resolvePendingQuitPromise(veto: boolean): void {\n\t\tif (this.pendingQuitPromiseResolve) {\n\t\t\tthis.pendingQuitPromiseResolve(veto);\n\t\t\tthis.pendingQuitPromiseResolve = undefined;\n\t\t\tthis.pendingQuitPromise = undefined;\n\t\t}\n\t}\n\n\tprivate onBeforeUnloadWindowInRenderer(window: ICodeWindow, reason: UnloadReason): Promise<boolean /* veto */> {\n\t\treturn new Promise<boolean>(resolve => {\n\t\t\tconst oneTimeEventToken = this.oneTimeListenerTokenGenerator++;\n\t\t\tconst okChannel = `vscode:ok${oneTimeEventToken}`;\n\t\t\tconst cancelChannel = `vscode:cancel${oneTimeEventToken}`;\n\n\t\t\tvalidatedIpcMain.once(okChannel, () => {\n\t\t\t\tresolve(false); // no veto\n\t\t\t});\n\n\t\t\tvalidatedIpcMain.once(cancelChannel, () => {\n\t\t\t\tresolve(true); // veto\n\t\t\t});\n\n\t\t\twindow.send('vscode:onBeforeUnload', { okChannel, cancelChannel, reason });\n\t\t});\n\t}\n\n\tprivate onWillUnloadWindowInRenderer(window: ICodeWindow, reason: UnloadReason): Promise<void> {\n\t\treturn new Promise<void>(resolve => {\n\t\t\tconst oneTimeEventToken = this.oneTimeListenerTokenGenerator++;\n\t\t\tconst replyChannel = `vscode:reply${oneTimeEventToken}`;\n\n\t\t\tvalidatedIpcMain.once(replyChannel, () => resolve());\n\n\t\t\twindow.send('vscode:onWillUnload', { replyChannel, reason });\n\t\t});\n\t}\n\n\tquit(willRestart?: boolean): Promise<boolean /* veto */> {\n\t\treturn this.doQuit(willRestart).then(veto => {\n\t\t\tif (!veto && willRestart) {\n\t\t\t\t// Windows: we are about to restart and as such we need to restore the original\n\t\t\t\t// current working directory we had on startup to get the exact same startup\n\t\t\t\t// behaviour. As such, we briefly change back to that directory and then when\n\t\t\t\t// Code starts it will set it back to the installation directory again.\n\t\t\t\ttry {\n\t\t\t\t\tif (isWindows) {\n\t\t\t\t\t\tconst currentWorkingDir = cwd();\n\t\t\t\t\t\tif (currentWorkingDir !== process.cwd()) {\n\t\t\t\t\t\t\tprocess.chdir(currentWorkingDir);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (err) {\n\t\t\t\t\tthis.logService.error(err);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn veto;\n\t\t});\n\t}\n\n\tprivate doQuit(willRestart?: boolean): Promise<boolean /* veto */> {\n\t\tthis.trace(`Lifecycle#quit() - begin (willRestart: ${willRestart})`);\n\n\t\tif (this.pendingQuitPromise) {\n\t\t\tthis.trace('Lifecycle#quit() - returning pending quit promise');\n\n\t\t\treturn this.pendingQuitPromise;\n\t\t}\n\n\t\t// Remember if we are about to restart\n\t\tif (willRestart) {\n\t\t\tthis.stateService.setItem(LifecycleMainService.QUIT_AND_RESTART_KEY, true);\n\t\t}\n\n\t\tthis.pendingQuitPromise = new Promise(resolve => {\n\n\t\t\t// Store as field to access it from a window cancellation\n\t\t\tthis.pendingQuitPromiseResolve = resolve;\n\n\t\t\t// Calling app.quit() will trigger the close handlers of each opened window\n\t\t\t// and only if no window vetoed the shutdown, we will get the will-quit event\n\t\t\tthis.trace('Lifecycle#quit() - calling app.quit()');\n\t\t\telectron.app.quit();\n\t\t});\n\n\t\treturn this.pendingQuitPromise;\n\t}\n\n\tprivate trace(msg: string): void {\n\t\tif (this.environmentMainService.args['enable-smoke-test-driver']) {\n\t\t\tthis.logService.info(msg); // helps diagnose issues with exiting from smoke tests\n\t\t} else {\n\t\t\tthis.logService.trace(msg);\n\t\t}\n\t}\n\n\tsetRelaunchHandler(handler: IRelaunchHandler): void {\n\t\tthis.relaunchHandler = handler;\n\t}\n\n\tasync relaunch(options?: IRelaunchOptions): Promise<void> {\n\t\tthis.trace('Lifecycle#relaunch()');\n\n\t\tconst args = process.argv.slice(1);\n\t\tif (options?.addArgs) {\n\t\t\targs.push(...options.addArgs);\n\t\t}\n\n\t\tif (options?.removeArgs) {\n\t\t\tfor (const a of options.removeArgs) {\n\t\t\t\tconst idx = args.indexOf(a);\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\targs.splice(idx, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst quitListener = () => {\n\t\t\tif (!this.relaunchHandler?.handleRelaunch(options)) {\n\t\t\t\tthis.trace('Lifecycle#relaunch() - calling app.relaunch()');\n\t\t\t\telectron.app.relaunch({ args });\n\t\t\t}\n\t\t};\n\t\telectron.app.once('quit', quitListener);\n\n\t\t// `app.relaunch()` does not quit automatically, so we quit first,\n\t\t// check for vetoes and then relaunch from the `app.on('quit')` event\n\t\tconst veto = await this.quit(true /* will restart */);\n\t\tif (veto) {\n\t\t\telectron.app.removeListener('quit', quitListener);\n\t\t}\n\t}\n\n\tasync kill(code?: number): Promise<void> {\n\t\tthis.trace('Lifecycle#kill()');\n\n\t\t// Give main process participants a chance to orderly shutdown\n\t\tawait this.fireOnWillShutdown(ShutdownReason.KILL);\n\n\t\t// From extension tests we have seen issues where calling app.exit()\n\t\t// with an opened window can lead to native crashes (Linux). As such,\n\t\t// we should make sure to destroy any opened window before calling\n\t\t// `app.exit()`.\n\t\t//\n\t\t// Note: Electron implements a similar logic here:\n\t\t// https://github.com/electron/electron/blob/fe5318d753637c3903e23fc1ed1b263025887b6a/spec-main/window-helpers.ts#L5\n\n\t\tawait Promise.race([\n\n\t\t\t// Still do not block more than 1s\n\t\t\ttimeout(1000),\n\n\t\t\t// Destroy any opened window: we do not unload windows here because\n\t\t\t// there is a chance that the unload is veto'd or long running due\n\t\t\t// to a participant within the window. this is not wanted when we\n\t\t\t// are asked to kill the application.\n\t\t\t(async () => {\n\t\t\t\tfor (const window of electron.BrowserWindow.getAllWindows()) {\n\t\t\t\t\tif (window && !window.isDestroyed()) {\n\t\t\t\t\t\tlet whenWindowClosed: Promise<void>;\n\t\t\t\t\t\tif (window.webContents && !window.webContents.isDestroyed()) {\n\t\t\t\t\t\t\twhenWindowClosed = new Promise(resolve => window.once('closed', resolve));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twhenWindowClosed = Promise.resolve();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twindow.destroy();\n\t\t\t\t\t\tawait whenWindowClosed;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})()\n\t\t]);\n\n\t\t// Now exit either after 1s or all windows destroyed\n\t\telectron.app.exit(code);\n\t}\n}\n"],
  "mappings": "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",
  "names": ["ShutdownReason", "LifecycleMainPhase"]
}
