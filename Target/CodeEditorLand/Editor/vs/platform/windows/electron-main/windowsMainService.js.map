{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/windows/electron-main/windowsMainService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport { app, BrowserWindow, WebContents, shell } from 'electron';\nimport { addUNCHostToAllowlist } from '../../../base/node/unc.js';\nimport { hostname, release, arch } from 'os';\nimport { coalesce, distinct } from '../../../base/common/arrays.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { CharCode } from '../../../base/common/charCode.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { isWindowsDriveLetter, parseLineAndColumnAware, sanitizeFilePath, toSlashes } from '../../../base/common/extpath.js';\nimport { getPathLabel } from '../../../base/common/labels.js';\nimport { Disposable, DisposableStore, IDisposable } from '../../../base/common/lifecycle.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { basename, join, normalize, posix } from '../../../base/common/path.js';\nimport { getMarks, mark } from '../../../base/common/performance.js';\nimport { IProcessEnvironment, isMacintosh, isWindows, OS } from '../../../base/common/platform.js';\nimport { cwd } from '../../../base/common/process.js';\nimport { extUriBiasedIgnorePathCase, isEqualAuthority, normalizePath, originalFSPath, removeTrailingPathSeparator } from '../../../base/common/resources.js';\nimport { assertIsDefined } from '../../../base/common/types.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { getNLSLanguage, getNLSMessages, localize } from '../../../nls.js';\nimport { IBackupMainService } from '../../backup/electron-main/backup.js';\nimport { IEmptyWindowBackupInfo } from '../../backup/node/backup.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { IDialogMainService } from '../../dialogs/electron-main/dialogMainService.js';\nimport { NativeParsedArgs } from '../../environment/common/argv.js';\nimport { IEnvironmentMainService } from '../../environment/electron-main/environmentMainService.js';\nimport { FileType, IFileService } from '../../files/common/files.js';\nimport { IInstantiationService } from '../../instantiation/common/instantiation.js';\nimport { ILifecycleMainService } from '../../lifecycle/electron-main/lifecycleMainService.js';\nimport { ILogService } from '../../log/common/log.js';\nimport product from '../../product/common/product.js';\nimport { IProtocolMainService } from '../../protocol/electron-main/protocol.js';\nimport { getRemoteAuthority } from '../../remote/common/remoteHosts.js';\nimport { IStateService } from '../../state/node/state.js';\nimport { IAddFoldersRequest, INativeOpenFileRequest, INativeWindowConfiguration, IOpenEmptyWindowOptions, IPath, IPathsToWaitFor, isFileToOpen, isFolderToOpen, isWorkspaceToOpen, IWindowOpenable, IWindowSettings } from '../../window/common/window.js';\nimport { CodeWindow } from './windowImpl.js';\nimport { IOpenConfiguration, IOpenEmptyConfiguration, IWindowsCountChangedEvent, IWindowsMainService, OpenContext, getLastFocused } from './windows.js';\nimport { findWindowOnExtensionDevelopmentPath, findWindowOnFile, findWindowOnWorkspaceOrFolder } from './windowsFinder.js';\nimport { IWindowState, WindowsStateHandler } from './windowsStateHandler.js';\nimport { IRecent } from '../../workspaces/common/workspaces.js';\nimport { hasWorkspaceFileExtension, IAnyWorkspaceIdentifier, ISingleFolderWorkspaceIdentifier, isSingleFolderWorkspaceIdentifier, isWorkspaceIdentifier, IWorkspaceIdentifier, toWorkspaceIdentifier } from '../../workspace/common/workspace.js';\nimport { createEmptyWorkspaceIdentifier, getSingleFolderWorkspaceIdentifier, getWorkspaceIdentifier } from '../../workspaces/node/workspaces.js';\nimport { IWorkspacesHistoryMainService } from '../../workspaces/electron-main/workspacesHistoryMainService.js';\nimport { IWorkspacesManagementMainService } from '../../workspaces/electron-main/workspacesManagementMainService.js';\nimport { ICodeWindow, UnloadReason } from '../../window/electron-main/window.js';\nimport { IThemeMainService } from '../../theme/electron-main/themeMainService.js';\nimport { IEditorOptions, ITextEditorOptions } from '../../editor/common/editor.js';\nimport { IUserDataProfile } from '../../userDataProfile/common/userDataProfile.js';\nimport { IPolicyService } from '../../policy/common/policy.js';\nimport { IUserDataProfilesMainService } from '../../userDataProfile/electron-main/userDataProfile.js';\nimport { ILoggerMainService } from '../../log/electron-main/loggerService.js';\nimport { IAuxiliaryWindowsMainService } from '../../auxiliaryWindow/electron-main/auxiliaryWindows.js';\nimport { IAuxiliaryWindow } from '../../auxiliaryWindow/electron-main/auxiliaryWindow.js';\nimport { ICSSDevelopmentService } from '../../cssDev/node/cssDevService.js';\n\n//#region Helper Interfaces\n\ntype RestoreWindowsSetting = 'preserve' | 'all' | 'folders' | 'one' | 'none';\n\ninterface IOpenBrowserWindowOptions {\n\treadonly userEnv?: IProcessEnvironment;\n\treadonly cli?: NativeParsedArgs;\n\n\treadonly workspace?: IWorkspaceIdentifier | ISingleFolderWorkspaceIdentifier;\n\n\treadonly remoteAuthority?: string;\n\n\treadonly initialStartup?: boolean;\n\n\treadonly filesToOpen?: IFilesToOpen;\n\n\treadonly forceNewWindow?: boolean;\n\treadonly forceNewTabbedWindow?: boolean;\n\treadonly windowToUse?: ICodeWindow;\n\n\treadonly emptyWindowBackupInfo?: IEmptyWindowBackupInfo;\n\treadonly forceProfile?: string;\n\treadonly forceTempProfile?: boolean;\n}\n\ninterface IPathResolveOptions {\n\n\t/**\n\t * By default, resolving a path will check\n\t * if the path exists. This can be disabled\n\t * with this flag.\n\t */\n\treadonly ignoreFileNotFound?: boolean;\n\n\t/**\n\t * Will reject a path if it points to a transient\n\t * workspace as indicated by a `transient: true`\n\t * property in the workspace file.\n\t */\n\treadonly rejectTransientWorkspaces?: boolean;\n\n\t/**\n\t * If enabled, will resolve the path line/column\n\t * aware and properly remove this information\n\t * from the resulting file path.\n\t */\n\treadonly gotoLineMode?: boolean;\n\n\t/**\n\t * Forces to resolve the provided path as workspace\n\t * file instead of opening it as a file.\n\t */\n\treadonly forceOpenWorkspaceAsFile?: boolean;\n\n\t/**\n\t * The remoteAuthority to use if the URL to open is\n\t * neither `file` nor `vscode-remote`.\n\t */\n\treadonly remoteAuthority?: string;\n}\n\ninterface IFilesToOpen {\n\treadonly remoteAuthority?: string;\n\n\tfilesToOpenOrCreate: IPath[];\n\tfilesToDiff: IPath[];\n\tfilesToMerge: IPath[];\n\n\tfilesToWait?: IPathsToWaitFor;\n}\n\ninterface IPathToOpen<T = IEditorOptions> extends IPath<T> {\n\n\t/**\n\t * The workspace to open\n\t */\n\treadonly workspace?: IWorkspaceIdentifier | ISingleFolderWorkspaceIdentifier;\n\n\t/**\n\t * Whether the path is considered to be transient or not\n\t * for example, a transient workspace should not add to\n\t * the workspaces history and should never restore.\n\t */\n\treadonly transient?: boolean;\n\n\t/**\n\t * The backup path to use\n\t */\n\treadonly backupPath?: string;\n\n\t/**\n\t * The remote authority for the Code instance to open. Undefined if not remote.\n\t */\n\treadonly remoteAuthority?: string;\n\n\t/**\n\t * Optional label for the recent history\n\t */\n\tlabel?: string;\n}\n\ninterface IWorkspacePathToOpen extends IPathToOpen {\n\treadonly workspace: IWorkspaceIdentifier;\n}\n\ninterface ISingleFolderWorkspacePathToOpen extends IPathToOpen {\n\treadonly workspace: ISingleFolderWorkspaceIdentifier;\n}\n\nfunction isWorkspacePathToOpen(path: IPathToOpen | undefined): path is IWorkspacePathToOpen {\n\treturn isWorkspaceIdentifier(path?.workspace);\n}\n\nfunction isSingleFolderWorkspacePathToOpen(path: IPathToOpen | undefined): path is ISingleFolderWorkspacePathToOpen {\n\treturn isSingleFolderWorkspaceIdentifier(path?.workspace);\n}\n\n//#endregion\n\nexport class WindowsMainService extends Disposable implements IWindowsMainService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly _onDidOpenWindow = this._register(new Emitter<ICodeWindow>());\n\treadonly onDidOpenWindow = this._onDidOpenWindow.event;\n\n\tprivate readonly _onDidSignalReadyWindow = this._register(new Emitter<ICodeWindow>());\n\treadonly onDidSignalReadyWindow = this._onDidSignalReadyWindow.event;\n\n\tprivate readonly _onDidDestroyWindow = this._register(new Emitter<ICodeWindow>());\n\treadonly onDidDestroyWindow = this._onDidDestroyWindow.event;\n\n\tprivate readonly _onDidChangeWindowsCount = this._register(new Emitter<IWindowsCountChangedEvent>());\n\treadonly onDidChangeWindowsCount = this._onDidChangeWindowsCount.event;\n\n\tprivate readonly _onDidMaximizeWindow = this._register(new Emitter<ICodeWindow>());\n\treadonly onDidMaximizeWindow = this._onDidMaximizeWindow.event;\n\n\tprivate readonly _onDidUnmaximizeWindow = this._register(new Emitter<ICodeWindow>());\n\treadonly onDidUnmaximizeWindow = this._onDidUnmaximizeWindow.event;\n\n\tprivate readonly _onDidChangeFullScreen = this._register(new Emitter<{ window: ICodeWindow; fullscreen: boolean }>());\n\treadonly onDidChangeFullScreen = this._onDidChangeFullScreen.event;\n\n\tprivate readonly _onDidTriggerSystemContextMenu = this._register(new Emitter<{ window: ICodeWindow; x: number; y: number }>());\n\treadonly onDidTriggerSystemContextMenu = this._onDidTriggerSystemContextMenu.event;\n\n\tprivate readonly windows = new Map<number, ICodeWindow>();\n\n\tprivate readonly windowsStateHandler = this._register(new WindowsStateHandler(this, this.stateService, this.lifecycleMainService, this.logService, this.configurationService));\n\n\tconstructor(\n\t\tprivate readonly machineId: string,\n\t\tprivate readonly sqmId: string,\n\t\tprivate readonly devDeviceId: string,\n\t\tprivate readonly initialUserEnv: IProcessEnvironment,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@ILoggerMainService private readonly loggerService: ILoggerMainService,\n\t\t@IStateService private readonly stateService: IStateService,\n\t\t@IPolicyService private readonly policyService: IPolicyService,\n\t\t@IEnvironmentMainService private readonly environmentMainService: IEnvironmentMainService,\n\t\t@IUserDataProfilesMainService private readonly userDataProfilesMainService: IUserDataProfilesMainService,\n\t\t@ILifecycleMainService private readonly lifecycleMainService: ILifecycleMainService,\n\t\t@IBackupMainService private readonly backupMainService: IBackupMainService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t\t@IWorkspacesHistoryMainService private readonly workspacesHistoryMainService: IWorkspacesHistoryMainService,\n\t\t@IWorkspacesManagementMainService private readonly workspacesManagementMainService: IWorkspacesManagementMainService,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService,\n\t\t@IDialogMainService private readonly dialogMainService: IDialogMainService,\n\t\t@IFileService private readonly fileService: IFileService,\n\t\t@IProtocolMainService private readonly protocolMainService: IProtocolMainService,\n\t\t@IThemeMainService private readonly themeMainService: IThemeMainService,\n\t\t@IAuxiliaryWindowsMainService private readonly auxiliaryWindowsMainService: IAuxiliaryWindowsMainService,\n\t\t@ICSSDevelopmentService private readonly cssDevelopmentService: ICSSDevelopmentService\n\t) {\n\t\tsuper();\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\n\t\t// Signal a window is ready after having entered a workspace\n\t\tthis._register(this.workspacesManagementMainService.onDidEnterWorkspace(event => this._onDidSignalReadyWindow.fire(event.window)));\n\n\t\t// Update valid roots in protocol service for extension dev windows\n\t\tthis._register(this.onDidSignalReadyWindow(window => {\n\t\t\tif (window.config?.extensionDevelopmentPath || window.config?.extensionTestsPath) {\n\t\t\t\tconst disposables = new DisposableStore();\n\t\t\t\tdisposables.add(Event.any(window.onDidClose, window.onDidDestroy)(() => disposables.dispose()));\n\n\t\t\t\t// Allow access to extension development path\n\t\t\t\tif (window.config.extensionDevelopmentPath) {\n\t\t\t\t\tfor (const extensionDevelopmentPath of window.config.extensionDevelopmentPath) {\n\t\t\t\t\t\tdisposables.add(this.protocolMainService.addValidFileRoot(extensionDevelopmentPath));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Allow access to extension tests path\n\t\t\t\tif (window.config.extensionTestsPath) {\n\t\t\t\t\tdisposables.add(this.protocolMainService.addValidFileRoot(window.config.extensionTestsPath));\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\t}\n\n\topenEmptyWindow(openConfig: IOpenEmptyConfiguration, options?: IOpenEmptyWindowOptions): Promise<ICodeWindow[]> {\n\t\tconst cli = this.environmentMainService.args;\n\t\tconst remoteAuthority = options?.remoteAuthority || undefined;\n\t\tconst forceEmpty = true;\n\t\tconst forceReuseWindow = options?.forceReuseWindow;\n\t\tconst forceNewWindow = !forceReuseWindow;\n\n\t\treturn this.open({ ...openConfig, cli, forceEmpty, forceNewWindow, forceReuseWindow, remoteAuthority, forceTempProfile: options?.forceTempProfile, forceProfile: options?.forceProfile });\n\t}\n\n\topenExistingWindow(window: ICodeWindow, openConfig: IOpenConfiguration): void {\n\n\t\t// Bring window to front\n\t\twindow.focus();\n\n\t\t// Handle --wait\n\t\tthis.handleWaitMarkerFile(openConfig, [window]);\n\t}\n\n\tasync open(openConfig: IOpenConfiguration): Promise<ICodeWindow[]> {\n\t\tthis.logService.trace('windowsManager#open');\n\n\t\tif (openConfig.addMode && (openConfig.initialStartup || !this.getLastActiveWindow())) {\n\t\t\topenConfig.addMode = false; // Make sure addMode is only enabled if we have an active window\n\t\t}\n\n\t\tconst foldersToAdd: ISingleFolderWorkspacePathToOpen[] = [];\n\t\tconst foldersToOpen: ISingleFolderWorkspacePathToOpen[] = [];\n\n\t\tconst workspacesToOpen: IWorkspacePathToOpen[] = [];\n\t\tconst untitledWorkspacesToRestore: IWorkspacePathToOpen[] = [];\n\n\t\tconst emptyWindowsWithBackupsToRestore: IEmptyWindowBackupInfo[] = [];\n\n\t\tlet filesToOpen: IFilesToOpen | undefined;\n\t\tlet openOneEmptyWindow = false;\n\n\t\t// Identify things to open from open config\n\t\tconst pathsToOpen = await this.getPathsToOpen(openConfig);\n\t\tthis.logService.trace('windowsManager#open pathsToOpen', pathsToOpen);\n\t\tfor (const path of pathsToOpen) {\n\t\t\tif (isSingleFolderWorkspacePathToOpen(path)) {\n\t\t\t\tif (openConfig.addMode) {\n\t\t\t\t\t// When run with --add, take the folders that are to be opened as\n\t\t\t\t\t// folders that should be added to the currently active window.\n\t\t\t\t\tfoldersToAdd.push(path);\n\t\t\t\t} else {\n\t\t\t\t\tfoldersToOpen.push(path);\n\t\t\t\t}\n\t\t\t} else if (isWorkspacePathToOpen(path)) {\n\t\t\t\tworkspacesToOpen.push(path);\n\t\t\t} else if (path.fileUri) {\n\t\t\t\tif (!filesToOpen) {\n\t\t\t\t\tfilesToOpen = { filesToOpenOrCreate: [], filesToDiff: [], filesToMerge: [], remoteAuthority: path.remoteAuthority };\n\t\t\t\t}\n\t\t\t\tfilesToOpen.filesToOpenOrCreate.push(path);\n\t\t\t} else if (path.backupPath) {\n\t\t\t\temptyWindowsWithBackupsToRestore.push({ backupFolder: basename(path.backupPath), remoteAuthority: path.remoteAuthority });\n\t\t\t} else {\n\t\t\t\topenOneEmptyWindow = true;\n\t\t\t}\n\t\t}\n\n\t\t// When run with --diff, take the first 2 files to open as files to diff\n\t\tif (openConfig.diffMode && filesToOpen && filesToOpen.filesToOpenOrCreate.length >= 2) {\n\t\t\tfilesToOpen.filesToDiff = filesToOpen.filesToOpenOrCreate.slice(0, 2);\n\t\t\tfilesToOpen.filesToOpenOrCreate = [];\n\t\t}\n\n\t\t// When run with --merge, take the first 4 files to open as files to merge\n\t\tif (openConfig.mergeMode && filesToOpen && filesToOpen.filesToOpenOrCreate.length === 4) {\n\t\t\tfilesToOpen.filesToMerge = filesToOpen.filesToOpenOrCreate.slice(0, 4);\n\t\t\tfilesToOpen.filesToOpenOrCreate = [];\n\t\t\tfilesToOpen.filesToDiff = [];\n\t\t}\n\n\t\t// When run with --wait, make sure we keep the paths to wait for\n\t\tif (filesToOpen && openConfig.waitMarkerFileURI) {\n\t\t\tfilesToOpen.filesToWait = { paths: coalesce([...filesToOpen.filesToDiff, filesToOpen.filesToMerge[3] /* [3] is the resulting merge file */, ...filesToOpen.filesToOpenOrCreate]), waitMarkerFileUri: openConfig.waitMarkerFileURI };\n\t\t}\n\n\t\t// These are windows to restore because of hot-exit or from previous session (only performed once on startup!)\n\t\tif (openConfig.initialStartup) {\n\n\t\t\t// Untitled workspaces are always restored\n\t\t\tuntitledWorkspacesToRestore.push(...this.workspacesManagementMainService.getUntitledWorkspaces());\n\t\t\tworkspacesToOpen.push(...untitledWorkspacesToRestore);\n\n\t\t\t// Empty windows with backups are always restored\n\t\t\temptyWindowsWithBackupsToRestore.push(...this.backupMainService.getEmptyWindowBackups());\n\t\t} else {\n\t\t\temptyWindowsWithBackupsToRestore.length = 0;\n\t\t}\n\n\t\t// Open based on config\n\t\tconst { windows: usedWindows, filesOpenedInWindow } = await this.doOpen(openConfig, workspacesToOpen, foldersToOpen, emptyWindowsWithBackupsToRestore, openOneEmptyWindow, filesToOpen, foldersToAdd);\n\n\t\tthis.logService.trace(`windowsManager#open used window count ${usedWindows.length} (workspacesToOpen: ${workspacesToOpen.length}, foldersToOpen: ${foldersToOpen.length}, emptyToRestore: ${emptyWindowsWithBackupsToRestore.length}, openOneEmptyWindow: ${openOneEmptyWindow})`);\n\n\t\t// Make sure to pass focus to the most relevant of the windows if we open multiple\n\t\tif (usedWindows.length > 1) {\n\n\t\t\t// 1.) focus window we opened files in always with highest priority\n\t\t\tif (filesOpenedInWindow) {\n\t\t\t\tfilesOpenedInWindow.focus();\n\t\t\t}\n\n\t\t\t// Otherwise, find a good window based on open params\n\t\t\telse {\n\t\t\t\tconst focusLastActive = this.windowsStateHandler.state.lastActiveWindow && !openConfig.forceEmpty && !openConfig.cli._.length && !openConfig.cli['file-uri'] && !openConfig.cli['folder-uri'] && !(openConfig.urisToOpen && openConfig.urisToOpen.length);\n\t\t\t\tlet focusLastOpened = true;\n\t\t\t\tlet focusLastWindow = true;\n\n\t\t\t\t// 2.) focus last active window if we are not instructed to open any paths\n\t\t\t\tif (focusLastActive) {\n\t\t\t\t\tconst lastActiveWindow = usedWindows.filter(window => this.windowsStateHandler.state.lastActiveWindow && window.backupPath === this.windowsStateHandler.state.lastActiveWindow.backupPath);\n\t\t\t\t\tif (lastActiveWindow.length) {\n\t\t\t\t\t\tlastActiveWindow[0].focus();\n\t\t\t\t\t\tfocusLastOpened = false;\n\t\t\t\t\t\tfocusLastWindow = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// 3.) if instructed to open paths, focus last window which is not restored\n\t\t\t\tif (focusLastOpened) {\n\t\t\t\t\tfor (let i = usedWindows.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tconst usedWindow = usedWindows[i];\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t(usedWindow.openedWorkspace && untitledWorkspacesToRestore.some(workspace => usedWindow.openedWorkspace && workspace.workspace.id === usedWindow.openedWorkspace.id)) ||\t// skip over restored workspace\n\t\t\t\t\t\t\t(usedWindow.backupPath && emptyWindowsWithBackupsToRestore.some(empty => usedWindow.backupPath && empty.backupFolder === basename(usedWindow.backupPath)))\t\t\t\t\t\t\t// skip over restored empty window\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tusedWindow.focus();\n\t\t\t\t\t\tfocusLastWindow = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// 4.) finally, always ensure to have at least last used window focused\n\t\t\t\tif (focusLastWindow) {\n\t\t\t\t\tusedWindows[usedWindows.length - 1].focus();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Remember in recent document list (unless this opens for extension development)\n\t\t// Also do not add paths when files are opened for diffing or merging, only if opened individually\n\t\tconst isDiff = filesToOpen && filesToOpen.filesToDiff.length > 0;\n\t\tconst isMerge = filesToOpen && filesToOpen.filesToMerge.length > 0;\n\t\tif (!usedWindows.some(window => window.isExtensionDevelopmentHost) && !isDiff && !isMerge && !openConfig.noRecentEntry) {\n\t\t\tconst recents: IRecent[] = [];\n\t\t\tfor (const pathToOpen of pathsToOpen) {\n\t\t\t\tif (isWorkspacePathToOpen(pathToOpen) && !pathToOpen.transient /* never add transient workspaces to history */) {\n\t\t\t\t\trecents.push({ label: pathToOpen.label, workspace: pathToOpen.workspace, remoteAuthority: pathToOpen.remoteAuthority });\n\t\t\t\t} else if (isSingleFolderWorkspacePathToOpen(pathToOpen)) {\n\t\t\t\t\trecents.push({ label: pathToOpen.label, folderUri: pathToOpen.workspace.uri, remoteAuthority: pathToOpen.remoteAuthority });\n\t\t\t\t} else if (pathToOpen.fileUri) {\n\t\t\t\t\trecents.push({ label: pathToOpen.label, fileUri: pathToOpen.fileUri, remoteAuthority: pathToOpen.remoteAuthority });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.workspacesHistoryMainService.addRecentlyOpened(recents);\n\t\t}\n\n\t\t// Handle --wait\n\t\tthis.handleWaitMarkerFile(openConfig, usedWindows);\n\n\t\treturn usedWindows;\n\t}\n\n\tprivate handleWaitMarkerFile(openConfig: IOpenConfiguration, usedWindows: ICodeWindow[]): void {\n\n\t\t// If we got started with --wait from the CLI, we need to signal to the outside when the window\n\t\t// used for the edit operation is closed or loaded to a different folder so that the waiting\n\t\t// process can continue. We do this by deleting the waitMarkerFilePath.\n\t\tconst waitMarkerFileURI = openConfig.waitMarkerFileURI;\n\t\tif (openConfig.context === OpenContext.CLI && waitMarkerFileURI && usedWindows.length === 1 && usedWindows[0]) {\n\t\t\t(async () => {\n\t\t\t\tawait usedWindows[0].whenClosedOrLoaded;\n\n\t\t\t\ttry {\n\t\t\t\t\tawait this.fileService.del(waitMarkerFileURI);\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// ignore - could have been deleted from the window already\n\t\t\t\t}\n\t\t\t})();\n\t\t}\n\t}\n\n\tprivate async doOpen(\n\t\topenConfig: IOpenConfiguration,\n\t\tworkspacesToOpen: IWorkspacePathToOpen[],\n\t\tfoldersToOpen: ISingleFolderWorkspacePathToOpen[],\n\t\temptyToRestore: IEmptyWindowBackupInfo[],\n\t\topenOneEmptyWindow: boolean,\n\t\tfilesToOpen: IFilesToOpen | undefined,\n\t\tfoldersToAdd: ISingleFolderWorkspacePathToOpen[]\n\t): Promise<{ windows: ICodeWindow[]; filesOpenedInWindow: ICodeWindow | undefined }> {\n\n\t\t// Keep track of used windows and remember\n\t\t// if files have been opened in one of them\n\t\tconst usedWindows: ICodeWindow[] = [];\n\t\tlet filesOpenedInWindow: ICodeWindow | undefined = undefined;\n\t\tfunction addUsedWindow(window: ICodeWindow, openedFiles?: boolean): void {\n\t\t\tusedWindows.push(window);\n\n\t\t\tif (openedFiles) {\n\t\t\t\tfilesOpenedInWindow = window;\n\t\t\t\tfilesToOpen = undefined; // reset `filesToOpen` since files have been opened\n\t\t\t}\n\t\t}\n\n\t\t// Settings can decide if files/folders open in new window or not\n\t\tlet { openFolderInNewWindow, openFilesInNewWindow } = this.shouldOpenNewWindow(openConfig);\n\n\t\t// Handle folders to add by looking for the last active workspace (not on initial startup)\n\t\tif (!openConfig.initialStartup && foldersToAdd.length > 0) {\n\t\t\tconst authority = foldersToAdd[0].remoteAuthority;\n\t\t\tconst lastActiveWindow = this.getLastActiveWindowForAuthority(authority);\n\t\t\tif (lastActiveWindow) {\n\t\t\t\taddUsedWindow(this.doAddFoldersToExistingWindow(lastActiveWindow, foldersToAdd.map(folderToAdd => folderToAdd.workspace.uri)));\n\t\t\t}\n\t\t}\n\n\t\t// Handle files to open/diff/merge or to create when we dont open a folder and we do not restore any\n\t\t// folder/untitled from hot-exit by trying to open them in the window that fits best\n\t\tconst potentialNewWindowsCount = foldersToOpen.length + workspacesToOpen.length + emptyToRestore.length;\n\t\tif (filesToOpen && potentialNewWindowsCount === 0) {\n\n\t\t\t// Find suitable window or folder path to open files in\n\t\t\tconst fileToCheck: IPath<IEditorOptions> | undefined = filesToOpen.filesToOpenOrCreate[0] || filesToOpen.filesToDiff[0] || filesToOpen.filesToMerge[3] /* [3] is the resulting merge file */;\n\n\t\t\t// only look at the windows with correct authority\n\t\t\tconst windows = this.getWindows().filter(window => filesToOpen && isEqualAuthority(window.remoteAuthority, filesToOpen.remoteAuthority));\n\n\t\t\t// figure out a good window to open the files in if any\n\t\t\t// with a fallback to the last active window.\n\t\t\t//\n\t\t\t// in case `openFilesInNewWindow` is enforced, we skip\n\t\t\t// this step.\n\t\t\tlet windowToUseForFiles: ICodeWindow | undefined = undefined;\n\t\t\tif (fileToCheck?.fileUri && !openFilesInNewWindow) {\n\t\t\t\tif (openConfig.context === OpenContext.DESKTOP || openConfig.context === OpenContext.CLI || openConfig.context === OpenContext.DOCK || openConfig.context === OpenContext.LINK) {\n\t\t\t\t\twindowToUseForFiles = await findWindowOnFile(windows, fileToCheck.fileUri, async workspace => workspace.configPath.scheme === Schemas.file ? this.workspacesManagementMainService.resolveLocalWorkspace(workspace.configPath) : undefined);\n\t\t\t\t}\n\n\t\t\t\tif (!windowToUseForFiles) {\n\t\t\t\t\twindowToUseForFiles = this.doGetLastActiveWindow(windows);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// We found a window to open the files in\n\t\t\tif (windowToUseForFiles) {\n\n\t\t\t\t// Window is workspace\n\t\t\t\tif (isWorkspaceIdentifier(windowToUseForFiles.openedWorkspace)) {\n\t\t\t\t\tworkspacesToOpen.push({ workspace: windowToUseForFiles.openedWorkspace, remoteAuthority: windowToUseForFiles.remoteAuthority });\n\t\t\t\t}\n\n\t\t\t\t// Window is single folder\n\t\t\t\telse if (isSingleFolderWorkspaceIdentifier(windowToUseForFiles.openedWorkspace)) {\n\t\t\t\t\tfoldersToOpen.push({ workspace: windowToUseForFiles.openedWorkspace, remoteAuthority: windowToUseForFiles.remoteAuthority });\n\t\t\t\t}\n\n\t\t\t\t// Window is empty\n\t\t\t\telse {\n\t\t\t\t\taddUsedWindow(this.doOpenFilesInExistingWindow(openConfig, windowToUseForFiles, filesToOpen), true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Finally, if no window or folder is found, just open the files in an empty window\n\t\t\telse {\n\t\t\t\taddUsedWindow(await this.openInBrowserWindow({\n\t\t\t\t\tuserEnv: openConfig.userEnv,\n\t\t\t\t\tcli: openConfig.cli,\n\t\t\t\t\tinitialStartup: openConfig.initialStartup,\n\t\t\t\t\tfilesToOpen,\n\t\t\t\t\tforceNewWindow: true,\n\t\t\t\t\tremoteAuthority: filesToOpen.remoteAuthority,\n\t\t\t\t\tforceNewTabbedWindow: openConfig.forceNewTabbedWindow,\n\t\t\t\t\tforceProfile: openConfig.forceProfile,\n\t\t\t\t\tforceTempProfile: openConfig.forceTempProfile\n\t\t\t\t}), true);\n\t\t\t}\n\t\t}\n\n\t\t// Handle workspaces to open (instructed and to restore)\n\t\tconst allWorkspacesToOpen = distinct(workspacesToOpen, workspace => workspace.workspace.id); // prevent duplicates\n\t\tif (allWorkspacesToOpen.length > 0) {\n\n\t\t\t// Check for existing instances\n\t\t\tconst windowsOnWorkspace = coalesce(allWorkspacesToOpen.map(workspaceToOpen => findWindowOnWorkspaceOrFolder(this.getWindows(), workspaceToOpen.workspace.configPath)));\n\t\t\tif (windowsOnWorkspace.length > 0) {\n\t\t\t\tconst windowOnWorkspace = windowsOnWorkspace[0];\n\t\t\t\tconst filesToOpenInWindow = isEqualAuthority(filesToOpen?.remoteAuthority, windowOnWorkspace.remoteAuthority) ? filesToOpen : undefined;\n\n\t\t\t\t// Do open files\n\t\t\t\taddUsedWindow(this.doOpenFilesInExistingWindow(openConfig, windowOnWorkspace, filesToOpenInWindow), !!filesToOpenInWindow);\n\n\t\t\t\topenFolderInNewWindow = true; // any other folders to open must open in new window then\n\t\t\t}\n\n\t\t\t// Open remaining ones\n\t\t\tfor (const workspaceToOpen of allWorkspacesToOpen) {\n\t\t\t\tif (windowsOnWorkspace.some(window => window.openedWorkspace && window.openedWorkspace.id === workspaceToOpen.workspace.id)) {\n\t\t\t\t\tcontinue; // ignore folders that are already open\n\t\t\t\t}\n\n\t\t\t\tconst remoteAuthority = workspaceToOpen.remoteAuthority;\n\t\t\t\tconst filesToOpenInWindow = isEqualAuthority(filesToOpen?.remoteAuthority, remoteAuthority) ? filesToOpen : undefined;\n\n\t\t\t\t// Do open folder\n\t\t\t\taddUsedWindow(await this.doOpenFolderOrWorkspace(openConfig, workspaceToOpen, openFolderInNewWindow, filesToOpenInWindow), !!filesToOpenInWindow);\n\n\t\t\t\topenFolderInNewWindow = true; // any other folders to open must open in new window then\n\t\t\t}\n\t\t}\n\n\t\t// Handle folders to open (instructed and to restore)\n\t\tconst allFoldersToOpen = distinct(foldersToOpen, folder => extUriBiasedIgnorePathCase.getComparisonKey(folder.workspace.uri)); // prevent duplicates\n\t\tif (allFoldersToOpen.length > 0) {\n\n\t\t\t// Check for existing instances\n\t\t\tconst windowsOnFolderPath = coalesce(allFoldersToOpen.map(folderToOpen => findWindowOnWorkspaceOrFolder(this.getWindows(), folderToOpen.workspace.uri)));\n\t\t\tif (windowsOnFolderPath.length > 0) {\n\t\t\t\tconst windowOnFolderPath = windowsOnFolderPath[0];\n\t\t\t\tconst filesToOpenInWindow = isEqualAuthority(filesToOpen?.remoteAuthority, windowOnFolderPath.remoteAuthority) ? filesToOpen : undefined;\n\n\t\t\t\t// Do open files\n\t\t\t\taddUsedWindow(this.doOpenFilesInExistingWindow(openConfig, windowOnFolderPath, filesToOpenInWindow), !!filesToOpenInWindow);\n\n\t\t\t\topenFolderInNewWindow = true; // any other folders to open must open in new window then\n\t\t\t}\n\n\t\t\t// Open remaining ones\n\t\t\tfor (const folderToOpen of allFoldersToOpen) {\n\t\t\t\tif (windowsOnFolderPath.some(window => isSingleFolderWorkspaceIdentifier(window.openedWorkspace) && extUriBiasedIgnorePathCase.isEqual(window.openedWorkspace.uri, folderToOpen.workspace.uri))) {\n\t\t\t\t\tcontinue; // ignore folders that are already open\n\t\t\t\t}\n\n\t\t\t\tconst remoteAuthority = folderToOpen.remoteAuthority;\n\t\t\t\tconst filesToOpenInWindow = isEqualAuthority(filesToOpen?.remoteAuthority, remoteAuthority) ? filesToOpen : undefined;\n\n\t\t\t\t// Do open folder\n\t\t\t\taddUsedWindow(await this.doOpenFolderOrWorkspace(openConfig, folderToOpen, openFolderInNewWindow, filesToOpenInWindow), !!filesToOpenInWindow);\n\n\t\t\t\topenFolderInNewWindow = true; // any other folders to open must open in new window then\n\t\t\t}\n\t\t}\n\n\t\t// Handle empty to restore\n\t\tconst allEmptyToRestore = distinct(emptyToRestore, info => info.backupFolder); // prevent duplicates\n\t\tif (allEmptyToRestore.length > 0) {\n\t\t\tfor (const emptyWindowBackupInfo of allEmptyToRestore) {\n\t\t\t\tconst remoteAuthority = emptyWindowBackupInfo.remoteAuthority;\n\t\t\t\tconst filesToOpenInWindow = isEqualAuthority(filesToOpen?.remoteAuthority, remoteAuthority) ? filesToOpen : undefined;\n\n\t\t\t\taddUsedWindow(await this.doOpenEmpty(openConfig, true, remoteAuthority, filesToOpenInWindow, emptyWindowBackupInfo), !!filesToOpenInWindow);\n\n\t\t\t\topenFolderInNewWindow = true; // any other folders to open must open in new window then\n\t\t\t}\n\t\t}\n\n\t\t// Open empty window either if enforced or when files still have to open\n\t\tif (filesToOpen || openOneEmptyWindow) {\n\t\t\tconst remoteAuthority = filesToOpen ? filesToOpen.remoteAuthority : openConfig.remoteAuthority;\n\n\t\t\taddUsedWindow(await this.doOpenEmpty(openConfig, openFolderInNewWindow, remoteAuthority, filesToOpen), !!filesToOpen);\n\t\t}\n\n\t\treturn { windows: distinct(usedWindows), filesOpenedInWindow };\n\t}\n\n\tprivate doOpenFilesInExistingWindow(configuration: IOpenConfiguration, window: ICodeWindow, filesToOpen?: IFilesToOpen): ICodeWindow {\n\t\tthis.logService.trace('windowsManager#doOpenFilesInExistingWindow', { filesToOpen });\n\n\t\tthis.focusMainOrChildWindow(window); // make sure window or any of the children has focus\n\n\t\tconst params: INativeOpenFileRequest = {\n\t\t\tfilesToOpenOrCreate: filesToOpen?.filesToOpenOrCreate,\n\t\t\tfilesToDiff: filesToOpen?.filesToDiff,\n\t\t\tfilesToMerge: filesToOpen?.filesToMerge,\n\t\t\tfilesToWait: filesToOpen?.filesToWait,\n\t\t\ttermProgram: configuration?.userEnv?.['TERM_PROGRAM']\n\t\t};\n\t\twindow.sendWhenReady('vscode:openFiles', CancellationToken.None, params);\n\n\t\treturn window;\n\t}\n\n\tprivate focusMainOrChildWindow(mainWindow: ICodeWindow): void {\n\t\tlet windowToFocus: ICodeWindow | IAuxiliaryWindow = mainWindow;\n\n\t\tconst focusedWindow = BrowserWindow.getFocusedWindow();\n\t\tif (focusedWindow && focusedWindow.id !== mainWindow.id) {\n\t\t\tconst auxiliaryWindowCandidate = this.auxiliaryWindowsMainService.getWindowByWebContents(focusedWindow.webContents);\n\t\t\tif (auxiliaryWindowCandidate && auxiliaryWindowCandidate.parentId === mainWindow.id) {\n\t\t\t\twindowToFocus = auxiliaryWindowCandidate;\n\t\t\t}\n\t\t}\n\n\t\twindowToFocus.focus();\n\t}\n\n\tprivate doAddFoldersToExistingWindow(window: ICodeWindow, foldersToAdd: URI[]): ICodeWindow {\n\t\tthis.logService.trace('windowsManager#doAddFoldersToExistingWindow', { foldersToAdd });\n\n\t\twindow.focus(); // make sure window has focus\n\n\t\tconst request: IAddFoldersRequest = { foldersToAdd };\n\t\twindow.sendWhenReady('vscode:addFolders', CancellationToken.None, request);\n\n\t\treturn window;\n\t}\n\n\tprivate doOpenEmpty(openConfig: IOpenConfiguration, forceNewWindow: boolean, remoteAuthority: string | undefined, filesToOpen: IFilesToOpen | undefined, emptyWindowBackupInfo?: IEmptyWindowBackupInfo): Promise<ICodeWindow> {\n\t\tthis.logService.trace('windowsManager#doOpenEmpty', { restore: !!emptyWindowBackupInfo, remoteAuthority, filesToOpen, forceNewWindow });\n\n\t\tlet windowToUse: ICodeWindow | undefined;\n\t\tif (!forceNewWindow && typeof openConfig.contextWindowId === 'number') {\n\t\t\twindowToUse = this.getWindowById(openConfig.contextWindowId); // fix for https://github.com/microsoft/vscode/issues/97172\n\t\t}\n\n\t\treturn this.openInBrowserWindow({\n\t\t\tuserEnv: openConfig.userEnv,\n\t\t\tcli: openConfig.cli,\n\t\t\tinitialStartup: openConfig.initialStartup,\n\t\t\tremoteAuthority,\n\t\t\tforceNewWindow,\n\t\t\tforceNewTabbedWindow: openConfig.forceNewTabbedWindow,\n\t\t\tfilesToOpen,\n\t\t\twindowToUse,\n\t\t\temptyWindowBackupInfo,\n\t\t\tforceProfile: openConfig.forceProfile,\n\t\t\tforceTempProfile: openConfig.forceTempProfile\n\t\t});\n\t}\n\n\tprivate doOpenFolderOrWorkspace(openConfig: IOpenConfiguration, folderOrWorkspace: IWorkspacePathToOpen | ISingleFolderWorkspacePathToOpen, forceNewWindow: boolean, filesToOpen: IFilesToOpen | undefined, windowToUse?: ICodeWindow): Promise<ICodeWindow> {\n\t\tthis.logService.trace('windowsManager#doOpenFolderOrWorkspace', { folderOrWorkspace, filesToOpen });\n\n\t\tif (!forceNewWindow && !windowToUse && typeof openConfig.contextWindowId === 'number') {\n\t\t\twindowToUse = this.getWindowById(openConfig.contextWindowId); // fix for https://github.com/microsoft/vscode/issues/49587\n\t\t}\n\n\t\treturn this.openInBrowserWindow({\n\t\t\tworkspace: folderOrWorkspace.workspace,\n\t\t\tuserEnv: openConfig.userEnv,\n\t\t\tcli: openConfig.cli,\n\t\t\tinitialStartup: openConfig.initialStartup,\n\t\t\tremoteAuthority: folderOrWorkspace.remoteAuthority,\n\t\t\tforceNewWindow,\n\t\t\tforceNewTabbedWindow: openConfig.forceNewTabbedWindow,\n\t\t\tfilesToOpen,\n\t\t\twindowToUse,\n\t\t\tforceProfile: openConfig.forceProfile,\n\t\t\tforceTempProfile: openConfig.forceTempProfile\n\t\t});\n\t}\n\n\tprivate async getPathsToOpen(openConfig: IOpenConfiguration): Promise<IPathToOpen[]> {\n\t\tlet pathsToOpen: IPathToOpen[];\n\t\tlet isCommandLineOrAPICall = false;\n\t\tlet restoredWindows = false;\n\n\t\t// Extract paths: from API\n\t\tif (openConfig.urisToOpen && openConfig.urisToOpen.length > 0) {\n\t\t\tpathsToOpen = await this.doExtractPathsFromAPI(openConfig);\n\t\t\tisCommandLineOrAPICall = true;\n\t\t}\n\n\t\t// Check for force empty\n\t\telse if (openConfig.forceEmpty) {\n\t\t\tpathsToOpen = [Object.create(null)];\n\t\t}\n\n\t\t// Extract paths: from CLI\n\t\telse if (openConfig.cli._.length || openConfig.cli['folder-uri'] || openConfig.cli['file-uri']) {\n\t\t\tpathsToOpen = await this.doExtractPathsFromCLI(openConfig.cli);\n\t\t\tif (pathsToOpen.length === 0) {\n\t\t\t\tpathsToOpen.push(Object.create(null)); // add an empty window if we did not have windows to open from command line\n\t\t\t}\n\n\t\t\tisCommandLineOrAPICall = true;\n\t\t}\n\n\t\t// Extract paths: from previous session\n\t\telse {\n\t\t\tpathsToOpen = await this.doGetPathsFromLastSession();\n\t\t\tif (pathsToOpen.length === 0) {\n\t\t\t\tpathsToOpen.push(Object.create(null)); // add an empty window if we did not have windows to restore\n\t\t\t}\n\n\t\t\trestoredWindows = true;\n\t\t}\n\n\t\t// Convert multiple folders into workspace (if opened via API or CLI)\n\t\t// This will ensure to open these folders in one window instead of multiple\n\t\t// If we are in `addMode`, we should not do this because in that case all\n\t\t// folders should be added to the existing window.\n\t\tif (!openConfig.addMode && isCommandLineOrAPICall) {\n\t\t\tconst foldersToOpen = pathsToOpen.filter(path => isSingleFolderWorkspacePathToOpen(path)) as ISingleFolderWorkspacePathToOpen[];\n\t\t\tif (foldersToOpen.length > 1) {\n\t\t\t\tconst remoteAuthority = foldersToOpen[0].remoteAuthority;\n\t\t\t\tif (foldersToOpen.every(folderToOpen => isEqualAuthority(folderToOpen.remoteAuthority, remoteAuthority))) { // only if all folder have the same authority\n\t\t\t\t\tconst workspace = await this.workspacesManagementMainService.createUntitledWorkspace(foldersToOpen.map(folder => ({ uri: folder.workspace.uri })));\n\n\t\t\t\t\t// Add workspace and remove folders thereby\n\t\t\t\t\tpathsToOpen.push({ workspace, remoteAuthority });\n\t\t\t\t\tpathsToOpen = pathsToOpen.filter(path => !isSingleFolderWorkspacePathToOpen(path));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check for `window.startup` setting to include all windows\n\t\t// from the previous session if this is the initial startup and we have\n\t\t// not restored windows already otherwise.\n\t\t// Use `unshift` to ensure any new window to open comes last\n\t\t// for proper focus treatment.\n\t\tif (openConfig.initialStartup && !restoredWindows && this.configurationService.getValue<IWindowSettings | undefined>('window')?.restoreWindows === 'preserve') {\n\t\t\tconst lastSessionPaths = await this.doGetPathsFromLastSession();\n\t\t\tpathsToOpen.unshift(...lastSessionPaths.filter(path => isWorkspacePathToOpen(path) || isSingleFolderWorkspacePathToOpen(path) || path.backupPath));\n\t\t}\n\n\t\treturn pathsToOpen;\n\t}\n\n\tprivate async doExtractPathsFromAPI(openConfig: IOpenConfiguration): Promise<IPathToOpen[]> {\n\t\tconst pathResolveOptions: IPathResolveOptions = {\n\t\t\tgotoLineMode: openConfig.gotoLineMode,\n\t\t\tremoteAuthority: openConfig.remoteAuthority\n\t\t};\n\n\t\tconst pathsToOpen = await Promise.all(coalesce(openConfig.urisToOpen || []).map(async pathToOpen => {\n\t\t\tconst path = await this.resolveOpenable(pathToOpen, pathResolveOptions);\n\n\t\t\t// Path exists\n\t\t\tif (path) {\n\t\t\t\tpath.label = pathToOpen.label;\n\n\t\t\t\treturn path;\n\t\t\t}\n\n\t\t\t// Path does not exist: show a warning box\n\t\t\tconst uri = this.resourceFromOpenable(pathToOpen);\n\n\t\t\tthis.dialogMainService.showMessageBox({\n\t\t\t\ttype: 'info',\n\t\t\t\tbuttons: [localize({ key: 'ok', comment: ['&& denotes a mnemonic'] }, \"&&OK\")],\n\t\t\t\tmessage: uri.scheme === Schemas.file ? localize('pathNotExistTitle', \"Path does not exist\") : localize('uriInvalidTitle', \"URI can not be opened\"),\n\t\t\t\tdetail: uri.scheme === Schemas.file ?\n\t\t\t\t\tlocalize('pathNotExistDetail', \"The path '{0}' does not exist on this computer.\", getPathLabel(uri, { os: OS, tildify: this.environmentMainService })) :\n\t\t\t\t\tlocalize('uriInvalidDetail', \"The URI '{0}' is not valid and can not be opened.\", uri.toString(true))\n\t\t\t}, BrowserWindow.getFocusedWindow() ?? undefined);\n\n\t\t\treturn undefined;\n\t\t}));\n\n\t\treturn coalesce(pathsToOpen);\n\t}\n\n\tprivate async doExtractPathsFromCLI(cli: NativeParsedArgs): Promise<IPath[]> {\n\t\tconst pathsToOpen: IPathToOpen[] = [];\n\t\tconst pathResolveOptions: IPathResolveOptions = {\n\t\t\tignoreFileNotFound: true,\n\t\t\tgotoLineMode: cli.goto,\n\t\t\tremoteAuthority: cli.remote || undefined,\n\t\t\tforceOpenWorkspaceAsFile:\n\t\t\t\t// special case diff / merge mode to force open\n\t\t\t\t// workspace as file\n\t\t\t\t// https://github.com/microsoft/vscode/issues/149731\n\t\t\t\tcli.diff && cli._.length === 2 ||\n\t\t\t\tcli.merge && cli._.length === 4\n\t\t};\n\n\t\t// folder uris\n\t\tconst folderUris = cli['folder-uri'];\n\t\tif (folderUris) {\n\t\t\tconst resolvedFolderUris = await Promise.all(folderUris.map(rawFolderUri => {\n\t\t\t\tconst folderUri = this.cliArgToUri(rawFolderUri);\n\t\t\t\tif (!folderUri) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\treturn this.resolveOpenable({ folderUri }, pathResolveOptions);\n\t\t\t}));\n\n\t\t\tpathsToOpen.push(...coalesce(resolvedFolderUris));\n\t\t}\n\n\t\t// file uris\n\t\tconst fileUris = cli['file-uri'];\n\t\tif (fileUris) {\n\t\t\tconst resolvedFileUris = await Promise.all(fileUris.map(rawFileUri => {\n\t\t\t\tconst fileUri = this.cliArgToUri(rawFileUri);\n\t\t\t\tif (!fileUri) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\treturn this.resolveOpenable(hasWorkspaceFileExtension(rawFileUri) ? { workspaceUri: fileUri } : { fileUri }, pathResolveOptions);\n\t\t\t}));\n\n\t\t\tpathsToOpen.push(...coalesce(resolvedFileUris));\n\t\t}\n\n\t\t// folder or file paths\n\t\tconst resolvedCliPaths = await Promise.all(cli._.map(cliPath => {\n\t\t\treturn pathResolveOptions.remoteAuthority ? this.doResolveRemotePath(cliPath, pathResolveOptions) : this.doResolveFilePath(cliPath, pathResolveOptions);\n\t\t}));\n\n\t\tpathsToOpen.push(...coalesce(resolvedCliPaths));\n\n\t\treturn pathsToOpen;\n\t}\n\n\tprivate cliArgToUri(arg: string): URI | undefined {\n\t\ttry {\n\t\t\tconst uri = URI.parse(arg);\n\t\t\tif (!uri.scheme) {\n\t\t\t\tthis.logService.error(`Invalid URI input string, scheme missing: ${arg}`);\n\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tif (!uri.path) {\n\t\t\t\treturn uri.with({ path: '/' });\n\t\t\t}\n\n\t\t\treturn uri;\n\t\t} catch (e) {\n\t\t\tthis.logService.error(`Invalid URI input string: ${arg}, ${e.message}`);\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate async doGetPathsFromLastSession(): Promise<IPathToOpen[]> {\n\t\tconst restoreWindowsSetting = this.getRestoreWindowsSetting();\n\n\t\tswitch (restoreWindowsSetting) {\n\n\t\t\t// none: no window to restore\n\t\t\tcase 'none':\n\t\t\t\treturn [];\n\n\t\t\t// one: restore last opened workspace/folder or empty window\n\t\t\t// all: restore all windows\n\t\t\t// folders: restore last opened folders only\n\t\t\tcase 'one':\n\t\t\tcase 'all':\n\t\t\tcase 'preserve':\n\t\t\tcase 'folders': {\n\n\t\t\t\t// Collect previously opened windows\n\t\t\t\tconst lastSessionWindows: IWindowState[] = [];\n\t\t\t\tif (restoreWindowsSetting !== 'one') {\n\t\t\t\t\tlastSessionWindows.push(...this.windowsStateHandler.state.openedWindows);\n\t\t\t\t}\n\t\t\t\tif (this.windowsStateHandler.state.lastActiveWindow) {\n\t\t\t\t\tlastSessionWindows.push(this.windowsStateHandler.state.lastActiveWindow);\n\t\t\t\t}\n\n\t\t\t\tconst pathsToOpen = await Promise.all(lastSessionWindows.map(async lastSessionWindow => {\n\n\t\t\t\t\t// Workspaces\n\t\t\t\t\tif (lastSessionWindow.workspace) {\n\t\t\t\t\t\tconst pathToOpen = await this.resolveOpenable({ workspaceUri: lastSessionWindow.workspace.configPath }, { remoteAuthority: lastSessionWindow.remoteAuthority, rejectTransientWorkspaces: true /* https://github.com/microsoft/vscode/issues/119695 */ });\n\t\t\t\t\t\tif (isWorkspacePathToOpen(pathToOpen)) {\n\t\t\t\t\t\t\treturn pathToOpen;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Folders\n\t\t\t\t\telse if (lastSessionWindow.folderUri) {\n\t\t\t\t\t\tconst pathToOpen = await this.resolveOpenable({ folderUri: lastSessionWindow.folderUri }, { remoteAuthority: lastSessionWindow.remoteAuthority });\n\t\t\t\t\t\tif (isSingleFolderWorkspacePathToOpen(pathToOpen)) {\n\t\t\t\t\t\t\treturn pathToOpen;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Empty window, potentially editors open to be restored\n\t\t\t\t\telse if (restoreWindowsSetting !== 'folders' && lastSessionWindow.backupPath) {\n\t\t\t\t\t\treturn { backupPath: lastSessionWindow.backupPath, remoteAuthority: lastSessionWindow.remoteAuthority };\n\t\t\t\t\t}\n\n\t\t\t\t\treturn undefined;\n\t\t\t\t}));\n\n\t\t\t\treturn coalesce(pathsToOpen);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate getRestoreWindowsSetting(): RestoreWindowsSetting {\n\t\tlet restoreWindows: RestoreWindowsSetting;\n\t\tif (this.lifecycleMainService.wasRestarted) {\n\t\t\trestoreWindows = 'all'; // always reopen all windows when an update was applied\n\t\t} else {\n\t\t\tconst windowConfig = this.configurationService.getValue<IWindowSettings | undefined>('window');\n\t\t\trestoreWindows = windowConfig?.restoreWindows || 'all'; // by default restore all windows\n\n\t\t\tif (!['preserve', 'all', 'folders', 'one', 'none'].includes(restoreWindows)) {\n\t\t\t\trestoreWindows = 'all'; // by default restore all windows\n\t\t\t}\n\t\t}\n\n\t\treturn restoreWindows;\n\t}\n\n\tprivate async resolveOpenable(openable: IWindowOpenable, options: IPathResolveOptions = Object.create(null)): Promise<IPathToOpen | undefined> {\n\n\t\t// handle file:// openables with some extra validation\n\t\tconst uri = this.resourceFromOpenable(openable);\n\t\tif (uri.scheme === Schemas.file) {\n\t\t\tif (isFileToOpen(openable)) {\n\t\t\t\toptions = { ...options, forceOpenWorkspaceAsFile: true };\n\t\t\t}\n\n\t\t\treturn this.doResolveFilePath(uri.fsPath, options);\n\t\t}\n\n\t\t// handle non file:// openables\n\t\treturn this.doResolveRemoteOpenable(openable, options);\n\t}\n\n\tprivate doResolveRemoteOpenable(openable: IWindowOpenable, options: IPathResolveOptions): IPathToOpen<ITextEditorOptions> | undefined {\n\t\tlet uri = this.resourceFromOpenable(openable);\n\n\t\t// use remote authority from vscode\n\t\tconst remoteAuthority = getRemoteAuthority(uri) || options.remoteAuthority;\n\n\t\t// normalize URI\n\t\turi = removeTrailingPathSeparator(normalizePath(uri));\n\n\t\t// File\n\t\tif (isFileToOpen(openable)) {\n\t\t\tif (options.gotoLineMode) {\n\t\t\t\tconst { path, line, column } = parseLineAndColumnAware(uri.path);\n\n\t\t\t\treturn {\n\t\t\t\t\tfileUri: uri.with({ path }),\n\t\t\t\t\toptions: {\n\t\t\t\t\t\tselection: line ? { startLineNumber: line, startColumn: column || 1 } : undefined\n\t\t\t\t\t},\n\t\t\t\t\tremoteAuthority\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn { fileUri: uri, remoteAuthority };\n\t\t}\n\n\t\t// Workspace\n\t\telse if (isWorkspaceToOpen(openable)) {\n\t\t\treturn { workspace: getWorkspaceIdentifier(uri), remoteAuthority };\n\t\t}\n\n\t\t// Folder\n\t\treturn { workspace: getSingleFolderWorkspaceIdentifier(uri), remoteAuthority };\n\t}\n\n\tprivate resourceFromOpenable(openable: IWindowOpenable): URI {\n\t\tif (isWorkspaceToOpen(openable)) {\n\t\t\treturn openable.workspaceUri;\n\t\t}\n\n\t\tif (isFolderToOpen(openable)) {\n\t\t\treturn openable.folderUri;\n\t\t}\n\n\t\treturn openable.fileUri;\n\t}\n\n\tprivate async doResolveFilePath(path: string, options: IPathResolveOptions, skipHandleUNCError?: boolean): Promise<IPathToOpen<ITextEditorOptions> | undefined> {\n\n\t\t// Extract line/col information from path\n\t\tlet lineNumber: number | undefined;\n\t\tlet columnNumber: number | undefined;\n\t\tif (options.gotoLineMode) {\n\t\t\t({ path, line: lineNumber, column: columnNumber } = parseLineAndColumnAware(path));\n\t\t}\n\n\t\t// Ensure the path is normalized and absolute\n\t\tpath = sanitizeFilePath(normalize(path), cwd());\n\n\t\ttry {\n\t\t\tconst pathStat = await fs.promises.stat(path);\n\n\t\t\t// File\n\t\t\tif (pathStat.isFile()) {\n\n\t\t\t\t// Workspace (unless disabled via flag)\n\t\t\t\tif (!options.forceOpenWorkspaceAsFile) {\n\t\t\t\t\tconst workspace = await this.workspacesManagementMainService.resolveLocalWorkspace(URI.file(path));\n\t\t\t\t\tif (workspace) {\n\n\t\t\t\t\t\t// If the workspace is transient and we are to ignore\n\t\t\t\t\t\t// transient workspaces, reject it.\n\t\t\t\t\t\tif (workspace.transient && options.rejectTransientWorkspaces) {\n\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tworkspace: { id: workspace.id, configPath: workspace.configPath },\n\t\t\t\t\t\t\ttype: FileType.File,\n\t\t\t\t\t\t\texists: true,\n\t\t\t\t\t\t\tremoteAuthority: workspace.remoteAuthority,\n\t\t\t\t\t\t\ttransient: workspace.transient\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tfileUri: URI.file(path),\n\t\t\t\t\ttype: FileType.File,\n\t\t\t\t\texists: true,\n\t\t\t\t\toptions: {\n\t\t\t\t\t\tselection: lineNumber ? { startLineNumber: lineNumber, startColumn: columnNumber || 1 } : undefined\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Folder\n\t\t\telse if (pathStat.isDirectory()) {\n\t\t\t\treturn {\n\t\t\t\t\tworkspace: getSingleFolderWorkspaceIdentifier(URI.file(path), pathStat),\n\t\t\t\t\ttype: FileType.Directory,\n\t\t\t\t\texists: true\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Special device: in POSIX environments, we may get /dev/null passed\n\t\t\t// in (for example git uses it to signal one side of a diff does not\n\t\t\t// exist). In that special case, treat it like a file to support this\n\t\t\t// scenario ()\n\t\t\telse if (!isWindows && path === '/dev/null') {\n\t\t\t\treturn {\n\t\t\t\t\tfileUri: URI.file(path),\n\t\t\t\t\ttype: FileType.File,\n\t\t\t\t\texists: true\n\t\t\t\t};\n\t\t\t}\n\t\t} catch (error) {\n\n\t\t\tif (error.code === 'ERR_UNC_HOST_NOT_ALLOWED' && !skipHandleUNCError) {\n\t\t\t\treturn this.onUNCHostNotAllowed(path, options);\n\t\t\t}\n\n\t\t\tconst fileUri = URI.file(path);\n\n\t\t\t// since file does not seem to exist anymore, remove from recent\n\t\t\tthis.workspacesHistoryMainService.removeRecentlyOpened([fileUri]);\n\n\t\t\t// assume this is a file that does not yet exist\n\t\t\tif (options.ignoreFileNotFound) {\n\t\t\t\treturn {\n\t\t\t\t\tfileUri,\n\t\t\t\t\ttype: FileType.File,\n\t\t\t\t\texists: false\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate async onUNCHostNotAllowed(path: string, options: IPathResolveOptions): Promise<IPathToOpen<ITextEditorOptions> | undefined> {\n\t\tconst uri = URI.file(path);\n\n\t\tconst { response, checkboxChecked } = await this.dialogMainService.showMessageBox({\n\t\t\ttype: 'warning',\n\t\t\tbuttons: [\n\t\t\t\tlocalize({ key: 'allow', comment: ['&& denotes a mnemonic'] }, \"&&Allow\"),\n\t\t\t\tlocalize({ key: 'cancel', comment: ['&& denotes a mnemonic'] }, \"&&Cancel\"),\n\t\t\t\tlocalize({ key: 'learnMore', comment: ['&& denotes a mnemonic'] }, \"&&Learn More\"),\n\t\t\t],\n\t\t\tmessage: localize('confirmOpenMessage', \"The host '{0}' was not found in the list of allowed hosts. Do you want to allow it anyway?\", uri.authority),\n\t\t\tdetail: localize('confirmOpenDetail', \"The path '{0}' uses a host that is not allowed. Unless you trust the host, you should press 'Cancel'\", getPathLabel(uri, { os: OS, tildify: this.environmentMainService })),\n\t\t\tcheckboxLabel: localize('doNotAskAgain', \"Permanently allow host '{0}'\", uri.authority),\n\t\t\tcancelId: 1\n\t\t});\n\n\t\tif (response === 0) {\n\t\t\taddUNCHostToAllowlist(uri.authority);\n\n\t\t\tif (checkboxChecked) {\n\t\t\t\t// Due to https://github.com/microsoft/vscode/issues/195436, we can only\n\t\t\t\t// update settings from within a window. But we do not know if a window\n\t\t\t\t// is about to open or can already handle the request, so we have to send\n\t\t\t\t// to any current window and any newly opening window.\n\t\t\t\tconst request = { channel: 'vscode:configureAllowedUNCHost', args: uri.authority };\n\t\t\t\tthis.sendToFocused(request.channel, request.args);\n\t\t\t\tthis.sendToOpeningWindow(request.channel, request.args);\n\t\t\t}\n\n\t\t\treturn this.doResolveFilePath(path, options, true /* do not handle UNC error again */);\n\t\t}\n\n\t\tif (response === 2) {\n\t\t\tshell.openExternal('https://aka.ms/vscode-windows-unc');\n\n\t\t\treturn this.onUNCHostNotAllowed(path, options); // keep showing the dialog until decision (https://github.com/microsoft/vscode/issues/181956)\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate doResolveRemotePath(path: string, options: IPathResolveOptions): IPathToOpen<ITextEditorOptions> | undefined {\n\t\tconst first = path.charCodeAt(0);\n\t\tconst remoteAuthority = options.remoteAuthority;\n\n\t\t// Extract line/col information from path\n\t\tlet lineNumber: number | undefined;\n\t\tlet columnNumber: number | undefined;\n\n\t\tif (options.gotoLineMode) {\n\t\t\t({ path, line: lineNumber, column: columnNumber } = parseLineAndColumnAware(path));\n\t\t}\n\n\t\t// make absolute\n\t\tif (first !== CharCode.Slash) {\n\t\t\tif (isWindowsDriveLetter(first) && path.charCodeAt(path.charCodeAt(1)) === CharCode.Colon) {\n\t\t\t\tpath = toSlashes(path);\n\t\t\t}\n\n\t\t\tpath = `/${path}`;\n\t\t}\n\n\t\tconst uri = URI.from({ scheme: Schemas.vscodeRemote, authority: remoteAuthority, path: path });\n\n\t\t// guess the file type:\n\t\t// - if it ends with a slash it's a folder\n\t\t// - if in goto line mode or if it has a file extension, it's a file or a workspace\n\t\t// - by defaults it's a folder\n\t\tif (path.charCodeAt(path.length - 1) !== CharCode.Slash) {\n\n\t\t\t// file name ends with .code-workspace\n\t\t\tif (hasWorkspaceFileExtension(path)) {\n\t\t\t\tif (options.forceOpenWorkspaceAsFile) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tfileUri: uri,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tselection: lineNumber ? { startLineNumber: lineNumber, startColumn: columnNumber || 1 } : undefined\n\t\t\t\t\t\t},\n\t\t\t\t\t\tremoteAuthority: options.remoteAuthority\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn { workspace: getWorkspaceIdentifier(uri), remoteAuthority };\n\t\t\t}\n\n\t\t\t// file name starts with a dot or has an file extension\n\t\t\telse if (options.gotoLineMode || posix.basename(path).indexOf('.') !== -1) {\n\t\t\t\treturn {\n\t\t\t\t\tfileUri: uri,\n\t\t\t\t\toptions: {\n\t\t\t\t\t\tselection: lineNumber ? { startLineNumber: lineNumber, startColumn: columnNumber || 1 } : undefined\n\t\t\t\t\t},\n\t\t\t\t\tremoteAuthority\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\treturn { workspace: getSingleFolderWorkspaceIdentifier(uri), remoteAuthority };\n\t}\n\n\tprivate shouldOpenNewWindow(openConfig: IOpenConfiguration): { openFolderInNewWindow: boolean; openFilesInNewWindow: boolean } {\n\n\t\t// let the user settings override how folders are open in a new window or same window unless we are forced\n\t\tconst windowConfig = this.configurationService.getValue<IWindowSettings | undefined>('window');\n\t\tconst openFolderInNewWindowConfig = windowConfig?.openFoldersInNewWindow || 'default' /* default */;\n\t\tconst openFilesInNewWindowConfig = windowConfig?.openFilesInNewWindow || 'off' /* default */;\n\n\t\tlet openFolderInNewWindow = (openConfig.preferNewWindow || openConfig.forceNewWindow) && !openConfig.forceReuseWindow;\n\t\tif (!openConfig.forceNewWindow && !openConfig.forceReuseWindow && (openFolderInNewWindowConfig === 'on' || openFolderInNewWindowConfig === 'off')) {\n\t\t\topenFolderInNewWindow = (openFolderInNewWindowConfig === 'on');\n\t\t}\n\n\t\t// let the user settings override how files are open in a new window or same window unless we are forced (not for extension development though)\n\t\tlet openFilesInNewWindow: boolean = false;\n\t\tif (openConfig.forceNewWindow || openConfig.forceReuseWindow) {\n\t\t\topenFilesInNewWindow = !!openConfig.forceNewWindow && !openConfig.forceReuseWindow;\n\t\t} else {\n\n\t\t\t// macOS: by default we open files in a new window if this is triggered via DOCK context\n\t\t\tif (isMacintosh) {\n\t\t\t\tif (openConfig.context === OpenContext.DOCK) {\n\t\t\t\t\topenFilesInNewWindow = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Linux/Windows: by default we open files in the new window unless triggered via DIALOG / MENU context\n\t\t\t// or from the integrated terminal where we assume the user prefers to open in the current window\n\t\t\telse {\n\t\t\t\tif (openConfig.context !== OpenContext.DIALOG && openConfig.context !== OpenContext.MENU && !(openConfig.userEnv && openConfig.userEnv['TERM_PROGRAM'] === 'vscode')) {\n\t\t\t\t\topenFilesInNewWindow = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// finally check for overrides of default\n\t\t\tif (!openConfig.cli.extensionDevelopmentPath && (openFilesInNewWindowConfig === 'on' || openFilesInNewWindowConfig === 'off')) {\n\t\t\t\topenFilesInNewWindow = (openFilesInNewWindowConfig === 'on');\n\t\t\t}\n\t\t}\n\n\t\treturn { openFolderInNewWindow: !!openFolderInNewWindow, openFilesInNewWindow };\n\t}\n\n\tasync openExtensionDevelopmentHostWindow(extensionDevelopmentPaths: string[], openConfig: IOpenConfiguration): Promise<ICodeWindow[]> {\n\n\t\t// Reload an existing extension development host window on the same path\n\t\t// We currently do not allow more than one extension development window\n\t\t// on the same extension path.\n\t\tconst existingWindow = findWindowOnExtensionDevelopmentPath(this.getWindows(), extensionDevelopmentPaths);\n\t\tif (existingWindow) {\n\t\t\tthis.lifecycleMainService.reload(existingWindow, openConfig.cli);\n\t\t\texistingWindow.focus(); // make sure it gets focus and is restored\n\n\t\t\treturn [existingWindow];\n\t\t}\n\n\t\tlet folderUris = openConfig.cli['folder-uri'] || [];\n\t\tlet fileUris = openConfig.cli['file-uri'] || [];\n\t\tlet cliArgs = openConfig.cli._;\n\n\t\t// Fill in previously opened workspace unless an explicit path is provided and we are not unit testing\n\t\tif (!cliArgs.length && !folderUris.length && !fileUris.length && !openConfig.cli.extensionTestsPath) {\n\t\t\tconst extensionDevelopmentWindowState = this.windowsStateHandler.state.lastPluginDevelopmentHostWindow;\n\t\t\tconst workspaceToOpen = extensionDevelopmentWindowState?.workspace ?? extensionDevelopmentWindowState?.folderUri;\n\t\t\tif (workspaceToOpen) {\n\t\t\t\tif (URI.isUri(workspaceToOpen)) {\n\t\t\t\t\tif (workspaceToOpen.scheme === Schemas.file) {\n\t\t\t\t\t\tcliArgs = [workspaceToOpen.fsPath];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfolderUris = [workspaceToOpen.toString()];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (workspaceToOpen.configPath.scheme === Schemas.file) {\n\t\t\t\t\t\tcliArgs = [originalFSPath(workspaceToOpen.configPath)];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfileUris = [workspaceToOpen.configPath.toString()];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet remoteAuthority = openConfig.remoteAuthority;\n\t\tfor (const extensionDevelopmentPath of extensionDevelopmentPaths) {\n\t\t\tif (extensionDevelopmentPath.match(/^[a-zA-Z][a-zA-Z0-9\\+\\-\\.]+:/)) {\n\t\t\t\tconst url = URI.parse(extensionDevelopmentPath);\n\t\t\t\tconst extensionDevelopmentPathRemoteAuthority = getRemoteAuthority(url);\n\t\t\t\tif (extensionDevelopmentPathRemoteAuthority) {\n\t\t\t\t\tif (remoteAuthority) {\n\t\t\t\t\t\tif (!isEqualAuthority(extensionDevelopmentPathRemoteAuthority, remoteAuthority)) {\n\t\t\t\t\t\t\tthis.logService.error('more than one extension development path authority');\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tremoteAuthority = extensionDevelopmentPathRemoteAuthority;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Make sure that we do not try to open:\n\t\t// - a workspace or folder that is already opened\n\t\t// - a workspace or file that has a different authority as the extension development.\n\n\t\tcliArgs = cliArgs.filter(path => {\n\t\t\tconst uri = URI.file(path);\n\t\t\tif (!!findWindowOnWorkspaceOrFolder(this.getWindows(), uri)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn isEqualAuthority(getRemoteAuthority(uri), remoteAuthority);\n\t\t});\n\n\t\tfolderUris = folderUris.filter(folderUriStr => {\n\t\t\tconst folderUri = this.cliArgToUri(folderUriStr);\n\t\t\tif (folderUri && !!findWindowOnWorkspaceOrFolder(this.getWindows(), folderUri)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn folderUri ? isEqualAuthority(getRemoteAuthority(folderUri), remoteAuthority) : false;\n\t\t});\n\n\t\tfileUris = fileUris.filter(fileUriStr => {\n\t\t\tconst fileUri = this.cliArgToUri(fileUriStr);\n\t\t\tif (fileUri && !!findWindowOnWorkspaceOrFolder(this.getWindows(), fileUri)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn fileUri ? isEqualAuthority(getRemoteAuthority(fileUri), remoteAuthority) : false;\n\t\t});\n\n\t\topenConfig.cli._ = cliArgs;\n\t\topenConfig.cli['folder-uri'] = folderUris;\n\t\topenConfig.cli['file-uri'] = fileUris;\n\n\t\t// Open it\n\t\tconst openArgs: IOpenConfiguration = {\n\t\t\tcontext: openConfig.context,\n\t\t\tcli: openConfig.cli,\n\t\t\tforceNewWindow: true,\n\t\t\tforceEmpty: !cliArgs.length && !folderUris.length && !fileUris.length,\n\t\t\tuserEnv: openConfig.userEnv,\n\t\t\tnoRecentEntry: true,\n\t\t\twaitMarkerFileURI: openConfig.waitMarkerFileURI,\n\t\t\tremoteAuthority,\n\t\t\tforceProfile: openConfig.forceProfile,\n\t\t\tforceTempProfile: openConfig.forceTempProfile\n\t\t};\n\n\t\treturn this.open(openArgs);\n\t}\n\n\tprivate async openInBrowserWindow(options: IOpenBrowserWindowOptions): Promise<ICodeWindow> {\n\t\tconst windowConfig = this.configurationService.getValue<IWindowSettings | undefined>('window');\n\n\t\tconst lastActiveWindow = this.getLastActiveWindow();\n\t\tconst newWindowProfile = windowConfig?.newWindowProfile\n\t\t\t? this.userDataProfilesMainService.profiles.find(profile => profile.name === windowConfig.newWindowProfile) : undefined;\n\t\tconst defaultProfile = newWindowProfile ?? lastActiveWindow?.profile ?? this.userDataProfilesMainService.defaultProfile;\n\n\t\tlet window: ICodeWindow | undefined;\n\t\tif (!options.forceNewWindow && !options.forceNewTabbedWindow) {\n\t\t\twindow = options.windowToUse || lastActiveWindow;\n\t\t\tif (window) {\n\t\t\t\twindow.focus();\n\t\t\t}\n\t\t}\n\n\t\t// Build up the window configuration from provided options, config and environment\n\t\tconst configuration: INativeWindowConfiguration = {\n\n\t\t\t// Inherit CLI arguments from environment and/or\n\t\t\t// the specific properties from this launch if provided\n\t\t\t...this.environmentMainService.args,\n\t\t\t...options.cli,\n\n\t\t\tmachineId: this.machineId,\n\t\t\tsqmId: this.sqmId,\n\t\t\tdevDeviceId: this.devDeviceId,\n\n\t\t\twindowId: -1,\t// Will be filled in by the window once loaded later\n\n\t\t\tmainPid: process.pid,\n\n\t\t\tappRoot: this.environmentMainService.appRoot,\n\t\t\texecPath: process.execPath,\n\t\t\tcodeCachePath: this.environmentMainService.codeCachePath,\n\t\t\t// If we know the backup folder upfront (for empty windows to restore), we can set it\n\t\t\t// directly here which helps for restoring UI state associated with that window.\n\t\t\t// For all other cases we first call into registerEmptyWindowBackup() to set it before\n\t\t\t// loading the window.\n\t\t\tbackupPath: options.emptyWindowBackupInfo ? join(this.environmentMainService.backupHome, options.emptyWindowBackupInfo.backupFolder) : undefined,\n\n\t\t\tprofiles: {\n\t\t\t\thome: this.userDataProfilesMainService.profilesHome,\n\t\t\t\tall: this.userDataProfilesMainService.profiles,\n\t\t\t\t// Set to default profile first and resolve and update the profile\n\t\t\t\t// only after the workspace-backup is registered.\n\t\t\t\t// Because, workspace identifier of an empty window is known only then.\n\t\t\t\tprofile: defaultProfile\n\t\t\t},\n\n\t\t\thomeDir: this.environmentMainService.userHome.with({ scheme: Schemas.file }).fsPath,\n\t\t\ttmpDir: this.environmentMainService.tmpDir.with({ scheme: Schemas.file }).fsPath,\n\t\t\tuserDataDir: this.environmentMainService.userDataPath,\n\n\t\t\tremoteAuthority: options.remoteAuthority,\n\t\t\tworkspace: options.workspace,\n\t\t\tuserEnv: { ...this.initialUserEnv, ...options.userEnv },\n\n\t\t\tnls: {\n\t\t\t\tmessages: getNLSMessages(),\n\t\t\t\tlanguage: getNLSLanguage()\n\t\t\t},\n\n\t\t\tfilesToOpenOrCreate: options.filesToOpen?.filesToOpenOrCreate,\n\t\t\tfilesToDiff: options.filesToOpen?.filesToDiff,\n\t\t\tfilesToMerge: options.filesToOpen?.filesToMerge,\n\t\t\tfilesToWait: options.filesToOpen?.filesToWait,\n\n\t\t\tlogLevel: this.loggerService.getLogLevel(),\n\t\t\tloggers: {\n\t\t\t\twindow: [],\n\t\t\t\tglobal: this.loggerService.getRegisteredLoggers()\n\t\t\t},\n\t\t\tlogsPath: this.environmentMainService.logsHome.with({ scheme: Schemas.file }).fsPath,\n\n\t\t\tproduct,\n\t\t\tisInitialStartup: options.initialStartup,\n\t\t\tperfMarks: getMarks(),\n\t\t\tos: { release: release(), hostname: hostname(), arch: arch() },\n\n\t\t\tautoDetectHighContrast: windowConfig?.autoDetectHighContrast ?? true,\n\t\t\tautoDetectColorScheme: windowConfig?.autoDetectColorScheme ?? false,\n\t\t\taccessibilitySupport: app.accessibilitySupportEnabled,\n\t\t\tcolorScheme: this.themeMainService.getColorScheme(),\n\t\t\tpoliciesData: this.policyService.serialize(),\n\t\t\tcontinueOn: this.environmentMainService.continueOn,\n\n\t\t\tcssModules: this.cssDevelopmentService.isEnabled ? await this.cssDevelopmentService.getCssModules() : undefined\n\t\t};\n\n\t\t// New window\n\t\tif (!window) {\n\t\t\tconst state = this.windowsStateHandler.getNewWindowState(configuration);\n\n\t\t\t// Create the window\n\t\t\tmark('code/willCreateCodeWindow');\n\t\t\tconst createdWindow = window = this.instantiationService.createInstance(CodeWindow, {\n\t\t\t\tstate,\n\t\t\t\textensionDevelopmentPath: configuration.extensionDevelopmentPath,\n\t\t\t\tisExtensionTestHost: !!configuration.extensionTestsPath\n\t\t\t});\n\t\t\tmark('code/didCreateCodeWindow');\n\n\t\t\t// Add as window tab if configured (macOS only)\n\t\t\tif (options.forceNewTabbedWindow) {\n\t\t\t\tconst activeWindow = this.getLastActiveWindow();\n\t\t\t\tactiveWindow?.addTabbedWindow(createdWindow);\n\t\t\t}\n\n\t\t\t// Add to our list of windows\n\t\t\tthis.windows.set(createdWindow.id, createdWindow);\n\n\t\t\t// Indicate new window via event\n\t\t\tthis._onDidOpenWindow.fire(createdWindow);\n\n\t\t\t// Indicate number change via event\n\t\t\tthis._onDidChangeWindowsCount.fire({ oldCount: this.getWindowCount() - 1, newCount: this.getWindowCount() });\n\n\t\t\t// Window Events\n\t\t\tconst disposables = new DisposableStore();\n\t\t\tdisposables.add(createdWindow.onDidSignalReady(() => this._onDidSignalReadyWindow.fire(createdWindow)));\n\t\t\tdisposables.add(Event.once(createdWindow.onDidClose)(() => this.onWindowClosed(createdWindow, disposables)));\n\t\t\tdisposables.add(Event.once(createdWindow.onDidDestroy)(() => this.onWindowDestroyed(createdWindow)));\n\t\t\tdisposables.add(createdWindow.onDidMaximize(() => this._onDidMaximizeWindow.fire(createdWindow)));\n\t\t\tdisposables.add(createdWindow.onDidUnmaximize(() => this._onDidUnmaximizeWindow.fire(createdWindow)));\n\t\t\tdisposables.add(createdWindow.onDidEnterFullScreen(() => this._onDidChangeFullScreen.fire({ window: createdWindow, fullscreen: true })));\n\t\t\tdisposables.add(createdWindow.onDidLeaveFullScreen(() => this._onDidChangeFullScreen.fire({ window: createdWindow, fullscreen: false })));\n\t\t\tdisposables.add(createdWindow.onDidTriggerSystemContextMenu(({ x, y }) => this._onDidTriggerSystemContextMenu.fire({ window: createdWindow, x, y })));\n\n\t\t\tconst webContents = assertIsDefined(createdWindow.win?.webContents);\n\t\t\twebContents.removeAllListeners('devtools-reload-page'); // remove built in listener so we can handle this on our own\n\t\t\tdisposables.add(Event.fromNodeEventEmitter(webContents, 'devtools-reload-page')(() => this.lifecycleMainService.reload(createdWindow)));\n\n\t\t\t// Lifecycle\n\t\t\tthis.lifecycleMainService.registerWindow(createdWindow);\n\t\t}\n\n\t\t// Existing window\n\t\telse {\n\n\t\t\t// Some configuration things get inherited if the window is being reused and we are\n\t\t\t// in extension development host mode. These options are all development related.\n\t\t\tconst currentWindowConfig = window.config;\n\t\t\tif (!configuration.extensionDevelopmentPath && currentWindowConfig?.extensionDevelopmentPath) {\n\t\t\t\tconfiguration.extensionDevelopmentPath = currentWindowConfig.extensionDevelopmentPath;\n\t\t\t\tconfiguration.extensionDevelopmentKind = currentWindowConfig.extensionDevelopmentKind;\n\t\t\t\tconfiguration['enable-proposed-api'] = currentWindowConfig['enable-proposed-api'];\n\t\t\t\tconfiguration.verbose = currentWindowConfig.verbose;\n\t\t\t\tconfiguration['inspect-extensions'] = currentWindowConfig['inspect-extensions'];\n\t\t\t\tconfiguration['inspect-brk-extensions'] = currentWindowConfig['inspect-brk-extensions'];\n\t\t\t\tconfiguration.debugId = currentWindowConfig.debugId;\n\t\t\t\tconfiguration.extensionEnvironment = currentWindowConfig.extensionEnvironment;\n\t\t\t\tconfiguration['extensions-dir'] = currentWindowConfig['extensions-dir'];\n\t\t\t\tconfiguration['disable-extensions'] = currentWindowConfig['disable-extensions'];\n\t\t\t}\n\t\t\tconfiguration.loggers = {\n\t\t\t\tglobal: configuration.loggers.global,\n\t\t\t\twindow: currentWindowConfig?.loggers.window ?? configuration.loggers.window\n\t\t\t};\n\t\t}\n\n\t\t// Update window identifier and session now\n\t\t// that we have the window object in hand.\n\t\tconfiguration.windowId = window.id;\n\n\t\t// If the window was already loaded, make sure to unload it\n\t\t// first and only load the new configuration if that was\n\t\t// not vetoed\n\t\tif (window.isReady) {\n\t\t\tthis.lifecycleMainService.unload(window, UnloadReason.LOAD).then(async veto => {\n\t\t\t\tif (!veto) {\n\t\t\t\t\tawait this.doOpenInBrowserWindow(window, configuration, options, defaultProfile);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tawait this.doOpenInBrowserWindow(window, configuration, options, defaultProfile);\n\t\t}\n\n\t\treturn window;\n\t}\n\n\tprivate async doOpenInBrowserWindow(window: ICodeWindow, configuration: INativeWindowConfiguration, options: IOpenBrowserWindowOptions, defaultProfile: IUserDataProfile): Promise<void> {\n\n\t\t// Register window for backups unless the window\n\t\t// is for extension development, where we do not\n\t\t// keep any backups.\n\n\t\tif (!configuration.extensionDevelopmentPath) {\n\t\t\tif (isWorkspaceIdentifier(configuration.workspace)) {\n\t\t\t\tconfiguration.backupPath = this.backupMainService.registerWorkspaceBackup({\n\t\t\t\t\tworkspace: configuration.workspace,\n\t\t\t\t\tremoteAuthority: configuration.remoteAuthority\n\t\t\t\t});\n\t\t\t} else if (isSingleFolderWorkspaceIdentifier(configuration.workspace)) {\n\t\t\t\tconfiguration.backupPath = this.backupMainService.registerFolderBackup({\n\t\t\t\t\tfolderUri: configuration.workspace.uri,\n\t\t\t\t\tremoteAuthority: configuration.remoteAuthority\n\t\t\t\t});\n\t\t\t} else {\n\n\t\t\t\t// Empty windows are special in that they provide no workspace on\n\t\t\t\t// their configuration. To properly register them with the backup\n\t\t\t\t// service, we either use the provided associated `backupFolder`\n\t\t\t\t// in case we restore a previously opened empty window or we have\n\t\t\t\t// to generate a new empty window workspace identifier to be used\n\t\t\t\t// as `backupFolder`.\n\n\t\t\t\tconfiguration.backupPath = this.backupMainService.registerEmptyWindowBackup({\n\t\t\t\t\tbackupFolder: options.emptyWindowBackupInfo?.backupFolder ?? createEmptyWorkspaceIdentifier().id,\n\t\t\t\t\tremoteAuthority: configuration.remoteAuthority\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (this.userDataProfilesMainService.isEnabled()) {\n\t\t\tconst workspace = configuration.workspace ?? toWorkspaceIdentifier(configuration.backupPath, false);\n\t\t\tconst profilePromise = this.resolveProfileForBrowserWindow(options, workspace, defaultProfile);\n\t\t\tconst profile = profilePromise instanceof Promise ? await profilePromise : profilePromise;\n\t\t\tconfiguration.profiles.profile = profile;\n\n\t\t\tif (!configuration.extensionDevelopmentPath) {\n\t\t\t\t// Associate the configured profile to the workspace\n\t\t\t\t// unless the window is for extension development,\n\t\t\t\t// where we do not persist the associations\n\t\t\t\tawait this.userDataProfilesMainService.setProfileForWorkspace(workspace, profile);\n\t\t\t}\n\t\t}\n\n\t\t// Load it\n\t\twindow.load(configuration);\n\t}\n\n\tprivate resolveProfileForBrowserWindow(options: IOpenBrowserWindowOptions, workspace: IAnyWorkspaceIdentifier, defaultProfile: IUserDataProfile): Promise<IUserDataProfile> | IUserDataProfile {\n\t\tif (options.forceProfile) {\n\t\t\treturn this.userDataProfilesMainService.profiles.find(p => p.name === options.forceProfile) ?? this.userDataProfilesMainService.createNamedProfile(options.forceProfile);\n\t\t}\n\n\t\tif (options.forceTempProfile) {\n\t\t\treturn this.userDataProfilesMainService.createTransientProfile();\n\t\t}\n\n\t\treturn this.userDataProfilesMainService.getProfileForWorkspace(workspace) ?? defaultProfile;\n\t}\n\n\tprivate onWindowClosed(window: ICodeWindow, disposables: IDisposable): void {\n\n\t\t// Remove from our list so that Electron can clean it up\n\t\tthis.windows.delete(window.id);\n\n\t\t// Emit\n\t\tthis._onDidChangeWindowsCount.fire({ oldCount: this.getWindowCount() + 1, newCount: this.getWindowCount() });\n\n\t\t// Clean up\n\t\tdisposables.dispose();\n\t}\n\n\tprivate onWindowDestroyed(window: ICodeWindow): void {\n\n\t\t// Remove from our list so that Electron can clean it up\n\t\tthis.windows.delete(window.id);\n\n\t\t// Emit\n\t\tthis._onDidDestroyWindow.fire(window);\n\t}\n\n\tgetFocusedWindow(): ICodeWindow | undefined {\n\t\tconst window = BrowserWindow.getFocusedWindow();\n\t\tif (window) {\n\t\t\treturn this.getWindowById(window.id);\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tgetLastActiveWindow(): ICodeWindow | undefined {\n\t\treturn this.doGetLastActiveWindow(this.getWindows());\n\t}\n\n\tprivate getLastActiveWindowForAuthority(remoteAuthority: string | undefined): ICodeWindow | undefined {\n\t\treturn this.doGetLastActiveWindow(this.getWindows().filter(window => isEqualAuthority(window.remoteAuthority, remoteAuthority)));\n\t}\n\n\tprivate doGetLastActiveWindow(windows: ICodeWindow[]): ICodeWindow | undefined {\n\t\treturn getLastFocused(windows);\n\t}\n\n\tsendToFocused(channel: string, ...args: any[]): void {\n\t\tconst focusedWindow = this.getFocusedWindow() || this.getLastActiveWindow();\n\n\t\tfocusedWindow?.sendWhenReady(channel, CancellationToken.None, ...args);\n\t}\n\n\tsendToOpeningWindow(channel: string, ...args: any[]): void {\n\t\tthis._register(Event.once(this.onDidSignalReadyWindow)(window => {\n\t\t\twindow.sendWhenReady(channel, CancellationToken.None, ...args);\n\t\t}));\n\t}\n\n\tsendToAll(channel: string, payload?: any, windowIdsToIgnore?: number[]): void {\n\t\tfor (const window of this.getWindows()) {\n\t\t\tif (windowIdsToIgnore && windowIdsToIgnore.indexOf(window.id) >= 0) {\n\t\t\t\tcontinue; // do not send if we are instructed to ignore it\n\t\t\t}\n\n\t\t\twindow.sendWhenReady(channel, CancellationToken.None, payload);\n\t\t}\n\t}\n\n\tgetWindows(): ICodeWindow[] {\n\t\treturn Array.from(this.windows.values());\n\t}\n\n\tgetWindowCount(): number {\n\t\treturn this.windows.size;\n\t}\n\n\tgetWindowById(windowId: number): ICodeWindow | undefined {\n\t\treturn this.windows.get(windowId);\n\t}\n\n\tgetWindowByWebContents(webContents: WebContents): ICodeWindow | undefined {\n\t\tconst browserWindow = BrowserWindow.fromWebContents(webContents);\n\t\tif (!browserWindow) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst window = this.getWindowById(browserWindow.id);\n\n\t\treturn window?.matches(webContents) ? window : undefined;\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
