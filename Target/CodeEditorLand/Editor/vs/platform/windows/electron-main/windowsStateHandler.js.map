{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/windows/electron-main/windowsStateHandler.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport electron from 'electron';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { isMacintosh } from '../../../base/common/platform.js';\nimport { extUriBiasedIgnorePathCase } from '../../../base/common/resources.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { ILifecycleMainService } from '../../lifecycle/electron-main/lifecycleMainService.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { IStateService } from '../../state/node/state.js';\nimport { INativeWindowConfiguration, IWindowSettings } from '../../window/common/window.js';\nimport { IWindowsMainService } from './windows.js';\nimport { defaultWindowState, ICodeWindow, IWindowState as IWindowUIState, WindowMode } from '../../window/electron-main/window.js';\nimport { isSingleFolderWorkspaceIdentifier, isWorkspaceIdentifier, IWorkspaceIdentifier } from '../../workspace/common/workspace.js';\n\nexport interface IWindowState {\n\treadonly windowId?: number;\n\tworkspace?: IWorkspaceIdentifier;\n\tfolderUri?: URI;\n\tbackupPath?: string;\n\tremoteAuthority?: string;\n\tuiState: IWindowUIState;\n}\n\nexport interface IWindowsState {\n\tlastActiveWindow?: IWindowState;\n\tlastPluginDevelopmentHostWindow?: IWindowState;\n\topenedWindows: IWindowState[];\n}\n\ninterface INewWindowState extends IWindowUIState {\n\thasDefaultState?: boolean;\n}\n\ninterface ISerializedWindowsState {\n\treadonly lastActiveWindow?: ISerializedWindowState;\n\treadonly lastPluginDevelopmentHostWindow?: ISerializedWindowState;\n\treadonly openedWindows: ISerializedWindowState[];\n}\n\ninterface ISerializedWindowState {\n\treadonly workspaceIdentifier?: { id: string; configURIPath: string };\n\treadonly folder?: string;\n\treadonly backupPath?: string;\n\treadonly remoteAuthority?: string;\n\treadonly uiState: IWindowUIState;\n}\n\nexport class WindowsStateHandler extends Disposable {\n\n\tprivate static readonly windowsStateStorageKey = 'windowsState';\n\n\tget state() { return this._state; }\n\tprivate readonly _state = restoreWindowsState(this.stateService.getItem<ISerializedWindowsState>(WindowsStateHandler.windowsStateStorageKey));\n\n\tprivate lastClosedState: IWindowState | undefined = undefined;\n\n\tprivate shuttingDown = false;\n\n\tconstructor(\n\t\t@IWindowsMainService private readonly windowsMainService: IWindowsMainService,\n\t\t@IStateService private readonly stateService: IStateService,\n\t\t@ILifecycleMainService private readonly lifecycleMainService: ILifecycleMainService,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService\n\t) {\n\t\tsuper();\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\n\t\t// When a window looses focus, save all windows state. This allows to\n\t\t// prevent loss of window-state data when OS is restarted without properly\n\t\t// shutting down the application (https://github.com/microsoft/vscode/issues/87171)\n\t\telectron.app.on('browser-window-blur', () => {\n\t\t\tif (!this.shuttingDown) {\n\t\t\t\tthis.saveWindowsState();\n\t\t\t}\n\t\t});\n\n\t\t// Handle various lifecycle events around windows\n\t\tthis._register(this.lifecycleMainService.onBeforeCloseWindow(window => this.onBeforeCloseWindow(window)));\n\t\tthis._register(this.lifecycleMainService.onBeforeShutdown(() => this.onBeforeShutdown()));\n\t\tthis._register(this.windowsMainService.onDidChangeWindowsCount(e => {\n\t\t\tif (e.newCount - e.oldCount > 0) {\n\t\t\t\t// clear last closed window state when a new window opens. this helps on macOS where\n\t\t\t\t// otherwise closing the last window, opening a new window and then quitting would\n\t\t\t\t// use the state of the previously closed window when restarting.\n\t\t\t\tthis.lastClosedState = undefined;\n\t\t\t}\n\t\t}));\n\n\t\t// try to save state before destroy because close will not fire\n\t\tthis._register(this.windowsMainService.onDidDestroyWindow(window => this.onBeforeCloseWindow(window)));\n\t}\n\n\t// Note that onBeforeShutdown() and onBeforeCloseWindow() are fired in different order depending on the OS:\n\t// - macOS: since the app will not quit when closing the last window, you will always first get\n\t//          the onBeforeShutdown() event followed by N onBeforeCloseWindow() events for each window\n\t// - other: on other OS, closing the last window will quit the app so the order depends on the\n\t//          user interaction: closing the last window will first trigger onBeforeCloseWindow()\n\t//          and then onBeforeShutdown(). Using the quit action however will first issue onBeforeShutdown()\n\t//          and then onBeforeCloseWindow().\n\t//\n\t// Here is the behavior on different OS depending on action taken (Electron 1.7.x):\n\t//\n\t// Legend\n\t// -  quit(N): quit application with N windows opened\n\t// - close(1): close one window via the window close button\n\t// - closeAll: close all windows via the taskbar command\n\t// - onBeforeShutdown(N): number of windows reported in this event handler\n\t// - onBeforeCloseWindow(N, M): number of windows reported and quitRequested boolean in this event handler\n\t//\n\t// macOS\n\t// \t-     quit(1): onBeforeShutdown(1), onBeforeCloseWindow(1, true)\n\t// \t-     quit(2): onBeforeShutdown(2), onBeforeCloseWindow(2, true), onBeforeCloseWindow(2, true)\n\t// \t-     quit(0): onBeforeShutdown(0)\n\t// \t-    close(1): onBeforeCloseWindow(1, false)\n\t//\n\t// Windows\n\t// \t-     quit(1): onBeforeShutdown(1), onBeforeCloseWindow(1, true)\n\t// \t-     quit(2): onBeforeShutdown(2), onBeforeCloseWindow(2, true), onBeforeCloseWindow(2, true)\n\t// \t-    close(1): onBeforeCloseWindow(2, false)[not last window]\n\t// \t-    close(1): onBeforeCloseWindow(1, false), onBeforeShutdown(0)[last window]\n\t// \t- closeAll(2): onBeforeCloseWindow(2, false), onBeforeCloseWindow(2, false), onBeforeShutdown(0)\n\t//\n\t// Linux\n\t// \t-     quit(1): onBeforeShutdown(1), onBeforeCloseWindow(1, true)\n\t// \t-     quit(2): onBeforeShutdown(2), onBeforeCloseWindow(2, true), onBeforeCloseWindow(2, true)\n\t// \t-    close(1): onBeforeCloseWindow(2, false)[not last window]\n\t// \t-    close(1): onBeforeCloseWindow(1, false), onBeforeShutdown(0)[last window]\n\t// \t- closeAll(2): onBeforeCloseWindow(2, false), onBeforeCloseWindow(2, false), onBeforeShutdown(0)\n\t//\n\tprivate onBeforeShutdown(): void {\n\t\tthis.shuttingDown = true;\n\n\t\tthis.saveWindowsState();\n\t}\n\n\tprivate saveWindowsState(): void {\n\n\t\t// TODO@electron workaround for Electron not being able to restore\n\t\t// multiple (native) fullscreen windows on the same display at once\n\t\t// on macOS.\n\t\t// https://github.com/electron/electron/issues/34367\n\t\tconst displaysWithFullScreenWindow = new Set<number | undefined>();\n\n\t\tconst currentWindowsState: IWindowsState = {\n\t\t\topenedWindows: [],\n\t\t\tlastPluginDevelopmentHostWindow: this._state.lastPluginDevelopmentHostWindow,\n\t\t\tlastActiveWindow: this.lastClosedState\n\t\t};\n\n\t\t// 1.) Find a last active window (pick any other first window otherwise)\n\t\tif (!currentWindowsState.lastActiveWindow) {\n\t\t\tlet activeWindow = this.windowsMainService.getLastActiveWindow();\n\t\t\tif (!activeWindow || activeWindow.isExtensionDevelopmentHost) {\n\t\t\t\tactiveWindow = this.windowsMainService.getWindows().find(window => !window.isExtensionDevelopmentHost);\n\t\t\t}\n\n\t\t\tif (activeWindow) {\n\t\t\t\tcurrentWindowsState.lastActiveWindow = this.toWindowState(activeWindow);\n\n\t\t\t\tif (currentWindowsState.lastActiveWindow.uiState.mode === WindowMode.Fullscreen) {\n\t\t\t\t\tdisplaysWithFullScreenWindow.add(currentWindowsState.lastActiveWindow.uiState.display); // always allow fullscreen for active window\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 2.) Find extension host window\n\t\tconst extensionHostWindow = this.windowsMainService.getWindows().find(window => window.isExtensionDevelopmentHost && !window.isExtensionTestHost);\n\t\tif (extensionHostWindow) {\n\t\t\tcurrentWindowsState.lastPluginDevelopmentHostWindow = this.toWindowState(extensionHostWindow);\n\n\t\t\tif (currentWindowsState.lastPluginDevelopmentHostWindow.uiState.mode === WindowMode.Fullscreen) {\n\t\t\t\tif (displaysWithFullScreenWindow.has(currentWindowsState.lastPluginDevelopmentHostWindow.uiState.display)) {\n\t\t\t\t\tif (isMacintosh && !extensionHostWindow.win?.isSimpleFullScreen()) {\n\t\t\t\t\t\tcurrentWindowsState.lastPluginDevelopmentHostWindow.uiState.mode = WindowMode.Normal;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdisplaysWithFullScreenWindow.add(currentWindowsState.lastPluginDevelopmentHostWindow.uiState.display);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 3.) All windows (except extension host) for N >= 2 to support `restoreWindows: all` or for auto update\n\t\t//\n\t\t// Careful here: asking a window for its window state after it has been closed returns bogus values (width: 0, height: 0)\n\t\t// so if we ever want to persist the UI state of the last closed window (window count === 1), it has\n\t\t// to come from the stored lastClosedWindowState on Win/Linux at least\n\t\tif (this.windowsMainService.getWindowCount() > 1) {\n\t\t\tcurrentWindowsState.openedWindows = this.windowsMainService.getWindows().filter(window => !window.isExtensionDevelopmentHost).map(window => {\n\t\t\t\tconst windowState = this.toWindowState(window);\n\n\t\t\t\tif (windowState.uiState.mode === WindowMode.Fullscreen) {\n\t\t\t\t\tif (displaysWithFullScreenWindow.has(windowState.uiState.display)) {\n\t\t\t\t\t\tif (isMacintosh && windowState.windowId !== currentWindowsState.lastActiveWindow?.windowId && !window.win?.isSimpleFullScreen()) {\n\t\t\t\t\t\t\twindowState.uiState.mode = WindowMode.Normal;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdisplaysWithFullScreenWindow.add(windowState.uiState.display);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn windowState;\n\t\t\t});\n\t\t}\n\n\t\t// Persist\n\t\tconst state = getWindowsStateStoreData(currentWindowsState);\n\t\tthis.stateService.setItem(WindowsStateHandler.windowsStateStorageKey, state);\n\n\t\tif (this.shuttingDown) {\n\t\t\tthis.logService.trace('[WindowsStateHandler] onBeforeShutdown', state);\n\t\t}\n\t}\n\n\t// See note on #onBeforeShutdown() for details how these events are flowing\n\tprivate onBeforeCloseWindow(window: ICodeWindow): void {\n\t\tif (this.lifecycleMainService.quitRequested) {\n\t\t\treturn; // during quit, many windows close in parallel so let it be handled in the before-quit handler\n\t\t}\n\n\t\t// On Window close, update our stored UI state of this window\n\t\tconst state: IWindowState = this.toWindowState(window);\n\t\tif (window.isExtensionDevelopmentHost && !window.isExtensionTestHost) {\n\t\t\tthis._state.lastPluginDevelopmentHostWindow = state; // do not let test run window state overwrite our extension development state\n\t\t}\n\n\t\t// Any non extension host window with same workspace or folder\n\t\telse if (!window.isExtensionDevelopmentHost && window.openedWorkspace) {\n\t\t\tthis._state.openedWindows.forEach(openedWindow => {\n\t\t\t\tconst sameWorkspace = isWorkspaceIdentifier(window.openedWorkspace) && openedWindow.workspace?.id === window.openedWorkspace.id;\n\t\t\t\tconst sameFolder = isSingleFolderWorkspaceIdentifier(window.openedWorkspace) && openedWindow.folderUri && extUriBiasedIgnorePathCase.isEqual(openedWindow.folderUri, window.openedWorkspace.uri);\n\n\t\t\t\tif (sameWorkspace || sameFolder) {\n\t\t\t\t\topenedWindow.uiState = state.uiState;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// On Windows and Linux closing the last window will trigger quit. Since we are storing all UI state\n\t\t// before quitting, we need to remember the UI state of this window to be able to persist it.\n\t\t// On macOS we keep the last closed window state ready in case the user wants to quit right after or\n\t\t// wants to open another window, in which case we use this state over the persisted one.\n\t\tif (this.windowsMainService.getWindowCount() === 1) {\n\t\t\tthis.lastClosedState = state;\n\t\t}\n\t}\n\n\tprivate toWindowState(window: ICodeWindow): IWindowState {\n\t\treturn {\n\t\t\twindowId: window.id,\n\t\t\tworkspace: isWorkspaceIdentifier(window.openedWorkspace) ? window.openedWorkspace : undefined,\n\t\t\tfolderUri: isSingleFolderWorkspaceIdentifier(window.openedWorkspace) ? window.openedWorkspace.uri : undefined,\n\t\t\tbackupPath: window.backupPath,\n\t\t\tremoteAuthority: window.remoteAuthority,\n\t\t\tuiState: window.serializeWindowState()\n\t\t};\n\t}\n\n\tgetNewWindowState(configuration: INativeWindowConfiguration): INewWindowState {\n\t\tconst state = this.doGetNewWindowState(configuration);\n\t\tconst windowConfig = this.configurationService.getValue<IWindowSettings | undefined>('window');\n\n\t\t// Fullscreen state gets special treatment\n\t\tif (state.mode === WindowMode.Fullscreen) {\n\n\t\t\t// Window state is not from a previous session: only allow fullscreen if we inherit it or user wants fullscreen\n\t\t\tlet allowFullscreen: boolean;\n\t\t\tif (state.hasDefaultState) {\n\t\t\t\tallowFullscreen = !!(windowConfig?.newWindowDimensions && ['fullscreen', 'inherit', 'offset'].indexOf(windowConfig.newWindowDimensions) >= 0);\n\t\t\t}\n\n\t\t\t// Window state is from a previous session: only allow fullscreen when we got updated or user wants to restore\n\t\t\telse {\n\t\t\t\tallowFullscreen = !!(this.lifecycleMainService.wasRestarted || windowConfig?.restoreFullscreen);\n\t\t\t}\n\n\t\t\tif (!allowFullscreen) {\n\t\t\t\tstate.mode = WindowMode.Normal;\n\t\t\t}\n\t\t}\n\n\t\treturn state;\n\t}\n\n\tprivate doGetNewWindowState(configuration: INativeWindowConfiguration): INewWindowState {\n\t\tconst lastActive = this.windowsMainService.getLastActiveWindow();\n\n\t\t// Restore state unless we are running extension tests\n\t\tif (!configuration.extensionTestsPath) {\n\n\t\t\t// extension development host Window - load from stored settings if any\n\t\t\tif (!!configuration.extensionDevelopmentPath && this.state.lastPluginDevelopmentHostWindow) {\n\t\t\t\treturn this.state.lastPluginDevelopmentHostWindow.uiState;\n\t\t\t}\n\n\t\t\t// Known Workspace - load from stored settings\n\t\t\tconst workspace = configuration.workspace;\n\t\t\tif (isWorkspaceIdentifier(workspace)) {\n\t\t\t\tconst stateForWorkspace = this.state.openedWindows.filter(openedWindow => openedWindow.workspace && openedWindow.workspace.id === workspace.id).map(openedWindow => openedWindow.uiState);\n\t\t\t\tif (stateForWorkspace.length) {\n\t\t\t\t\treturn stateForWorkspace[0];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Known Folder - load from stored settings\n\t\t\tif (isSingleFolderWorkspaceIdentifier(workspace)) {\n\t\t\t\tconst stateForFolder = this.state.openedWindows.filter(openedWindow => openedWindow.folderUri && extUriBiasedIgnorePathCase.isEqual(openedWindow.folderUri, workspace.uri)).map(openedWindow => openedWindow.uiState);\n\t\t\t\tif (stateForFolder.length) {\n\t\t\t\t\treturn stateForFolder[0];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Empty windows with backups\n\t\t\telse if (configuration.backupPath) {\n\t\t\t\tconst stateForEmptyWindow = this.state.openedWindows.filter(openedWindow => openedWindow.backupPath === configuration.backupPath).map(openedWindow => openedWindow.uiState);\n\t\t\t\tif (stateForEmptyWindow.length) {\n\t\t\t\t\treturn stateForEmptyWindow[0];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// First Window\n\t\t\tconst lastActiveState = this.lastClosedState || this.state.lastActiveWindow;\n\t\t\tif (!lastActive && lastActiveState) {\n\t\t\t\treturn lastActiveState.uiState;\n\t\t\t}\n\t\t}\n\n\t\t//\n\t\t// In any other case, we do not have any stored settings for the window state, so we come up with something smart\n\t\t//\n\n\t\t// We want the new window to open on the same display that the last active one is in\n\t\tlet displayToUse: electron.Display | undefined;\n\t\tconst displays = electron.screen.getAllDisplays();\n\n\t\t// Single Display\n\t\tif (displays.length === 1) {\n\t\t\tdisplayToUse = displays[0];\n\t\t}\n\n\t\t// Multi Display\n\t\telse {\n\n\t\t\t// on mac there is 1 menu per window so we need to use the monitor where the cursor currently is\n\t\t\tif (isMacintosh) {\n\t\t\t\tconst cursorPoint = electron.screen.getCursorScreenPoint();\n\t\t\t\tdisplayToUse = electron.screen.getDisplayNearestPoint(cursorPoint);\n\t\t\t}\n\n\t\t\t// if we have a last active window, use that display for the new window\n\t\t\tif (!displayToUse && lastActive) {\n\t\t\t\tdisplayToUse = electron.screen.getDisplayMatching(lastActive.getBounds());\n\t\t\t}\n\n\t\t\t// fallback to primary display or first display\n\t\t\tif (!displayToUse) {\n\t\t\t\tdisplayToUse = electron.screen.getPrimaryDisplay() || displays[0];\n\t\t\t}\n\t\t}\n\n\t\t// Compute x/y based on display bounds\n\t\t// Note: important to use Math.round() because Electron does not seem to be too happy about\n\t\t// display coordinates that are not absolute numbers.\n\t\tlet state = defaultWindowState();\n\t\tstate.x = Math.round(displayToUse.bounds.x + (displayToUse.bounds.width / 2) - (state.width! / 2));\n\t\tstate.y = Math.round(displayToUse.bounds.y + (displayToUse.bounds.height / 2) - (state.height! / 2));\n\n\t\t// Check for newWindowDimensions setting and adjust accordingly\n\t\tconst windowConfig = this.configurationService.getValue<IWindowSettings | undefined>('window');\n\t\tlet ensureNoOverlap = true;\n\t\tif (windowConfig?.newWindowDimensions) {\n\t\t\tif (windowConfig.newWindowDimensions === 'maximized') {\n\t\t\t\tstate.mode = WindowMode.Maximized;\n\t\t\t\tensureNoOverlap = false;\n\t\t\t} else if (windowConfig.newWindowDimensions === 'fullscreen') {\n\t\t\t\tstate.mode = WindowMode.Fullscreen;\n\t\t\t\tensureNoOverlap = false;\n\t\t\t} else if ((windowConfig.newWindowDimensions === 'inherit' || windowConfig.newWindowDimensions === 'offset') && lastActive) {\n\t\t\t\tconst lastActiveState = lastActive.serializeWindowState();\n\t\t\t\tif (lastActiveState.mode === WindowMode.Fullscreen) {\n\t\t\t\t\tstate.mode = WindowMode.Fullscreen; // only take mode (fixes https://github.com/microsoft/vscode/issues/19331)\n\t\t\t\t} else {\n\t\t\t\t\tstate = {\n\t\t\t\t\t\t...lastActiveState,\n\t\t\t\t\t\tzoomLevel: undefined // do not inherit zoom level\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tensureNoOverlap = state.mode !== WindowMode.Fullscreen && windowConfig.newWindowDimensions === 'offset';\n\t\t\t}\n\t\t}\n\n\t\tif (ensureNoOverlap) {\n\t\t\tstate = this.ensureNoOverlap(state);\n\t\t}\n\n\t\t(state as INewWindowState).hasDefaultState = true; // flag as default state\n\n\t\treturn state;\n\t}\n\n\tprivate ensureNoOverlap(state: IWindowUIState): IWindowUIState {\n\t\tif (this.windowsMainService.getWindows().length === 0) {\n\t\t\treturn state;\n\t\t}\n\n\t\tstate.x = typeof state.x === 'number' ? state.x : 0;\n\t\tstate.y = typeof state.y === 'number' ? state.y : 0;\n\n\t\tconst existingWindowBounds = this.windowsMainService.getWindows().map(window => window.getBounds());\n\t\twhile (existingWindowBounds.some(bounds => bounds.x === state.x || bounds.y === state.y)) {\n\t\t\tstate.x += 30;\n\t\t\tstate.y += 30;\n\t\t}\n\n\t\treturn state;\n\t}\n}\n\nexport function restoreWindowsState(data: ISerializedWindowsState | undefined): IWindowsState {\n\tconst result: IWindowsState = { openedWindows: [] };\n\tconst windowsState = data || { openedWindows: [] };\n\n\tif (windowsState.lastActiveWindow) {\n\t\tresult.lastActiveWindow = restoreWindowState(windowsState.lastActiveWindow);\n\t}\n\n\tif (windowsState.lastPluginDevelopmentHostWindow) {\n\t\tresult.lastPluginDevelopmentHostWindow = restoreWindowState(windowsState.lastPluginDevelopmentHostWindow);\n\t}\n\n\tif (Array.isArray(windowsState.openedWindows)) {\n\t\tresult.openedWindows = windowsState.openedWindows.map(windowState => restoreWindowState(windowState));\n\t}\n\n\treturn result;\n}\n\nfunction restoreWindowState(windowState: ISerializedWindowState): IWindowState {\n\tconst result: IWindowState = { uiState: windowState.uiState };\n\tif (windowState.backupPath) {\n\t\tresult.backupPath = windowState.backupPath;\n\t}\n\n\tif (windowState.remoteAuthority) {\n\t\tresult.remoteAuthority = windowState.remoteAuthority;\n\t}\n\n\tif (windowState.folder) {\n\t\tresult.folderUri = URI.parse(windowState.folder);\n\t}\n\n\tif (windowState.workspaceIdentifier) {\n\t\tresult.workspace = { id: windowState.workspaceIdentifier.id, configPath: URI.parse(windowState.workspaceIdentifier.configURIPath) };\n\t}\n\n\treturn result;\n}\n\nexport function getWindowsStateStoreData(windowsState: IWindowsState): IWindowsState {\n\treturn {\n\t\tlastActiveWindow: windowsState.lastActiveWindow && serializeWindowState(windowsState.lastActiveWindow),\n\t\tlastPluginDevelopmentHostWindow: windowsState.lastPluginDevelopmentHostWindow && serializeWindowState(windowsState.lastPluginDevelopmentHostWindow),\n\t\topenedWindows: windowsState.openedWindows.map(ws => serializeWindowState(ws))\n\t};\n}\n\nfunction serializeWindowState(windowState: IWindowState): ISerializedWindowState {\n\treturn {\n\t\tworkspaceIdentifier: windowState.workspace && { id: windowState.workspace.id, configURIPath: windowState.workspace.configPath.toString() },\n\t\tfolder: windowState.folderUri && windowState.folderUri.toString(),\n\t\tbackupPath: windowState.backupPath,\n\t\tremoteAuthority: windowState.remoteAuthority,\n\t\tuiState: windowState.uiState\n\t};\n}\n"],
  "mappings": ";;;;;;;;;;;;AAKA,OAAO,cAAc;AACrB,SAAS,kBAAkB;AAC3B,SAAS,mBAAmB;AAC5B,SAAS,kCAAkC;AAC3C,SAAS,WAAW;AACpB,SAAS,6BAA6B;AACtC,SAAS,6BAA6B;AACtC,SAAS,mBAAmB;AAC5B,SAAS,qBAAqB;AAC9B,SAAS,4BAA4B,uBAAuB;AAC5D,SAAS,2BAA2B;AACpC,SAAS,oBAAoB,aAAa,gBAAgB,gBAAgB,kBAAkB;AAC5F,SAAS,mCAAmC,uBAAuB,4BAA4B;AAmCxF,IAAM,sBAAN,cAAkC,WAAW;AAAA,EAWnD,YACuC,oBACN,cACQ,sBACV,YACU,sBACvC;AACD,UAAM;AANgC;AACN;AACQ;AACV;AACU;AAIxC,SAAK,kBAAkB;AAAA,EACxB;AAAA,EAzED,OAoDoD;AAAA;AAAA;AAAA,EAEnD,OAAwB,yBAAyB;AAAA,EAEjD,IAAI,QAAQ;AAAE,WAAO,KAAK;AAAA,EAAQ;AAAA,EACjB,SAAS,oBAAoB,KAAK,aAAa,QAAiC,oBAAoB,sBAAsB,CAAC;AAAA,EAEpI,kBAA4C;AAAA,EAE5C,eAAe;AAAA,EAcf,oBAA0B;AAKjC,aAAS,IAAI,GAAG,uBAAuB,MAAM;AAC5C,UAAI,CAAC,KAAK,cAAc;AACvB,aAAK,iBAAiB;AAAA,MACvB;AAAA,IACD,CAAC;AAGD,SAAK,UAAU,KAAK,qBAAqB,oBAAoB,YAAU,KAAK,oBAAoB,MAAM,CAAC,CAAC;AACxG,SAAK,UAAU,KAAK,qBAAqB,iBAAiB,MAAM,KAAK,iBAAiB,CAAC,CAAC;AACxF,SAAK,UAAU,KAAK,mBAAmB,wBAAwB,OAAK;AACnE,UAAI,EAAE,WAAW,EAAE,WAAW,GAAG;AAIhC,aAAK,kBAAkB;AAAA,MACxB;AAAA,IACD,CAAC,CAAC;AAGF,SAAK,UAAU,KAAK,mBAAmB,mBAAmB,YAAU,KAAK,oBAAoB,MAAM,CAAC,CAAC;AAAA,EACtG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAuCQ,mBAAyB;AAChC,SAAK,eAAe;AAEpB,SAAK,iBAAiB;AAAA,EACvB;AAAA,EAEQ,mBAAyB;AAMhC,UAAM,+BAA+B,oBAAI,IAAwB;AAEjE,UAAM,sBAAqC;AAAA,MAC1C,eAAe,CAAC;AAAA,MAChB,iCAAiC,KAAK,OAAO;AAAA,MAC7C,kBAAkB,KAAK;AAAA,IACxB;AAGA,QAAI,CAAC,oBAAoB,kBAAkB;AAC1C,UAAI,eAAe,KAAK,mBAAmB,oBAAoB;AAC/D,UAAI,CAAC,gBAAgB,aAAa,4BAA4B;AAC7D,uBAAe,KAAK,mBAAmB,WAAW,EAAE,KAAK,YAAU,CAAC,OAAO,0BAA0B;AAAA,MACtG;AAEA,UAAI,cAAc;AACjB,4BAAoB,mBAAmB,KAAK,cAAc,YAAY;AAEtE,YAAI,oBAAoB,iBAAiB,QAAQ,SAAS,WAAW,YAAY;AAChF,uCAA6B,IAAI,oBAAoB,iBAAiB,QAAQ,OAAO;AAAA,QACtF;AAAA,MACD;AAAA,IACD;AAGA,UAAM,sBAAsB,KAAK,mBAAmB,WAAW,EAAE,KAAK,YAAU,OAAO,8BAA8B,CAAC,OAAO,mBAAmB;AAChJ,QAAI,qBAAqB;AACxB,0BAAoB,kCAAkC,KAAK,cAAc,mBAAmB;AAE5F,UAAI,oBAAoB,gCAAgC,QAAQ,SAAS,WAAW,YAAY;AAC/F,YAAI,6BAA6B,IAAI,oBAAoB,gCAAgC,QAAQ,OAAO,GAAG;AAC1G,cAAI,eAAe,CAAC,oBAAoB,KAAK,mBAAmB,GAAG;AAClE,gCAAoB,gCAAgC,QAAQ,OAAO,WAAW;AAAA,UAC/E;AAAA,QACD,OAAO;AACN,uCAA6B,IAAI,oBAAoB,gCAAgC,QAAQ,OAAO;AAAA,QACrG;AAAA,MACD;AAAA,IACD;AAOA,QAAI,KAAK,mBAAmB,eAAe,IAAI,GAAG;AACjD,0BAAoB,gBAAgB,KAAK,mBAAmB,WAAW,EAAE,OAAO,YAAU,CAAC,OAAO,0BAA0B,EAAE,IAAI,YAAU;AAC3I,cAAM,cAAc,KAAK,cAAc,MAAM;AAE7C,YAAI,YAAY,QAAQ,SAAS,WAAW,YAAY;AACvD,cAAI,6BAA6B,IAAI,YAAY,QAAQ,OAAO,GAAG;AAClE,gBAAI,eAAe,YAAY,aAAa,oBAAoB,kBAAkB,YAAY,CAAC,OAAO,KAAK,mBAAmB,GAAG;AAChI,0BAAY,QAAQ,OAAO,WAAW;AAAA,YACvC;AAAA,UACD,OAAO;AACN,yCAA6B,IAAI,YAAY,QAAQ,OAAO;AAAA,UAC7D;AAAA,QACD;AAEA,eAAO;AAAA,MACR,CAAC;AAAA,IACF;AAGA,UAAM,QAAQ,yBAAyB,mBAAmB;AAC1D,SAAK,aAAa,QAAQ,oBAAoB,wBAAwB,KAAK;AAE3E,QAAI,KAAK,cAAc;AACtB,WAAK,WAAW,MAAM,0CAA0C,KAAK;AAAA,IACtE;AAAA,EACD;AAAA;AAAA,EAGQ,oBAAoB,QAA2B;AACtD,QAAI,KAAK,qBAAqB,eAAe;AAC5C;AAAA,IACD;AAGA,UAAM,QAAsB,KAAK,cAAc,MAAM;AACrD,QAAI,OAAO,8BAA8B,CAAC,OAAO,qBAAqB;AACrE,WAAK,OAAO,kCAAkC;AAAA,IAC/C,WAGS,CAAC,OAAO,8BAA8B,OAAO,iBAAiB;AACtE,WAAK,OAAO,cAAc,QAAQ,kBAAgB;AACjD,cAAM,gBAAgB,sBAAsB,OAAO,eAAe,KAAK,aAAa,WAAW,OAAO,OAAO,gBAAgB;AAC7H,cAAM,aAAa,kCAAkC,OAAO,eAAe,KAAK,aAAa,aAAa,2BAA2B,QAAQ,aAAa,WAAW,OAAO,gBAAgB,GAAG;AAE/L,YAAI,iBAAiB,YAAY;AAChC,uBAAa,UAAU,MAAM;AAAA,QAC9B;AAAA,MACD,CAAC;AAAA,IACF;AAMA,QAAI,KAAK,mBAAmB,eAAe,MAAM,GAAG;AACnD,WAAK,kBAAkB;AAAA,IACxB;AAAA,EACD;AAAA,EAEQ,cAAc,QAAmC;AACxD,WAAO;AAAA,MACN,UAAU,OAAO;AAAA,MACjB,WAAW,sBAAsB,OAAO,eAAe,IAAI,OAAO,kBAAkB;AAAA,MACpF,WAAW,kCAAkC,OAAO,eAAe,IAAI,OAAO,gBAAgB,MAAM;AAAA,MACpG,YAAY,OAAO;AAAA,MACnB,iBAAiB,OAAO;AAAA,MACxB,SAAS,OAAO,qBAAqB;AAAA,IACtC;AAAA,EACD;AAAA,EAEA,kBAAkB,eAA4D;AAC7E,UAAM,QAAQ,KAAK,oBAAoB,aAAa;AACpD,UAAM,eAAe,KAAK,qBAAqB,SAAsC,QAAQ;AAG7F,QAAI,MAAM,SAAS,WAAW,YAAY;AAGzC,UAAI;AACJ,UAAI,MAAM,iBAAiB;AAC1B,0BAAkB,CAAC,EAAE,cAAc,uBAAuB,CAAC,cAAc,WAAW,QAAQ,EAAE,QAAQ,aAAa,mBAAmB,KAAK;AAAA,MAC5I,OAGK;AACJ,0BAAkB,CAAC,EAAE,KAAK,qBAAqB,gBAAgB,cAAc;AAAA,MAC9E;AAEA,UAAI,CAAC,iBAAiB;AACrB,cAAM,OAAO,WAAW;AAAA,MACzB;AAAA,IACD;AAEA,WAAO;AAAA,EACR;AAAA,EAEQ,oBAAoB,eAA4D;AACvF,UAAM,aAAa,KAAK,mBAAmB,oBAAoB;AAG/D,QAAI,CAAC,cAAc,oBAAoB;AAGtC,UAAI,CAAC,CAAC,cAAc,4BAA4B,KAAK,MAAM,iCAAiC;AAC3F,eAAO,KAAK,MAAM,gCAAgC;AAAA,MACnD;AAGA,YAAM,YAAY,cAAc;AAChC,UAAI,sBAAsB,SAAS,GAAG;AACrC,cAAM,oBAAoB,KAAK,MAAM,cAAc,OAAO,kBAAgB,aAAa,aAAa,aAAa,UAAU,OAAO,UAAU,EAAE,EAAE,IAAI,kBAAgB,aAAa,OAAO;AACxL,YAAI,kBAAkB,QAAQ;AAC7B,iBAAO,kBAAkB,CAAC;AAAA,QAC3B;AAAA,MACD;AAGA,UAAI,kCAAkC,SAAS,GAAG;AACjD,cAAM,iBAAiB,KAAK,MAAM,cAAc,OAAO,kBAAgB,aAAa,aAAa,2BAA2B,QAAQ,aAAa,WAAW,UAAU,GAAG,CAAC,EAAE,IAAI,kBAAgB,aAAa,OAAO;AACpN,YAAI,eAAe,QAAQ;AAC1B,iBAAO,eAAe,CAAC;AAAA,QACxB;AAAA,MACD,WAGS,cAAc,YAAY;AAClC,cAAM,sBAAsB,KAAK,MAAM,cAAc,OAAO,kBAAgB,aAAa,eAAe,cAAc,UAAU,EAAE,IAAI,kBAAgB,aAAa,OAAO;AAC1K,YAAI,oBAAoB,QAAQ;AAC/B,iBAAO,oBAAoB,CAAC;AAAA,QAC7B;AAAA,MACD;AAGA,YAAM,kBAAkB,KAAK,mBAAmB,KAAK,MAAM;AAC3D,UAAI,CAAC,cAAc,iBAAiB;AACnC,eAAO,gBAAgB;AAAA,MACxB;AAAA,IACD;AAOA,QAAI;AACJ,UAAM,WAAW,SAAS,OAAO,eAAe;AAGhD,QAAI,SAAS,WAAW,GAAG;AAC1B,qBAAe,SAAS,CAAC;AAAA,IAC1B,OAGK;AAGJ,UAAI,aAAa;AAChB,cAAM,cAAc,SAAS,OAAO,qBAAqB;AACzD,uBAAe,SAAS,OAAO,uBAAuB,WAAW;AAAA,MAClE;AAGA,UAAI,CAAC,gBAAgB,YAAY;AAChC,uBAAe,SAAS,OAAO,mBAAmB,WAAW,UAAU,CAAC;AAAA,MACzE;AAGA,UAAI,CAAC,cAAc;AAClB,uBAAe,SAAS,OAAO,kBAAkB,KAAK,SAAS,CAAC;AAAA,MACjE;AAAA,IACD;AAKA,QAAI,QAAQ,mBAAmB;AAC/B,UAAM,IAAI,KAAK,MAAM,aAAa,OAAO,IAAK,aAAa,OAAO,QAAQ,IAAM,MAAM,QAAS,CAAE;AACjG,UAAM,IAAI,KAAK,MAAM,aAAa,OAAO,IAAK,aAAa,OAAO,SAAS,IAAM,MAAM,SAAU,CAAE;AAGnG,UAAM,eAAe,KAAK,qBAAqB,SAAsC,QAAQ;AAC7F,QAAI,kBAAkB;AACtB,QAAI,cAAc,qBAAqB;AACtC,UAAI,aAAa,wBAAwB,aAAa;AACrD,cAAM,OAAO,WAAW;AACxB,0BAAkB;AAAA,MACnB,WAAW,aAAa,wBAAwB,cAAc;AAC7D,cAAM,OAAO,WAAW;AACxB,0BAAkB;AAAA,MACnB,YAAY,aAAa,wBAAwB,aAAa,aAAa,wBAAwB,aAAa,YAAY;AAC3H,cAAM,kBAAkB,WAAW,qBAAqB;AACxD,YAAI,gBAAgB,SAAS,WAAW,YAAY;AACnD,gBAAM,OAAO,WAAW;AAAA,QACzB,OAAO;AACN,kBAAQ;AAAA,YACP,GAAG;AAAA,YACH,WAAW;AAAA;AAAA,UACZ;AAAA,QACD;AAEA,0BAAkB,MAAM,SAAS,WAAW,cAAc,aAAa,wBAAwB;AAAA,MAChG;AAAA,IACD;AAEA,QAAI,iBAAiB;AACpB,cAAQ,KAAK,gBAAgB,KAAK;AAAA,IACnC;AAEA,IAAC,MAA0B,kBAAkB;AAE7C,WAAO;AAAA,EACR;AAAA,EAEQ,gBAAgB,OAAuC;AAC9D,QAAI,KAAK,mBAAmB,WAAW,EAAE,WAAW,GAAG;AACtD,aAAO;AAAA,IACR;AAEA,UAAM,IAAI,OAAO,MAAM,MAAM,WAAW,MAAM,IAAI;AAClD,UAAM,IAAI,OAAO,MAAM,MAAM,WAAW,MAAM,IAAI;AAElD,UAAM,uBAAuB,KAAK,mBAAmB,WAAW,EAAE,IAAI,YAAU,OAAO,UAAU,CAAC;AAClG,WAAO,qBAAqB,KAAK,YAAU,OAAO,MAAM,MAAM,KAAK,OAAO,MAAM,MAAM,CAAC,GAAG;AACzF,YAAM,KAAK;AACX,YAAM,KAAK;AAAA,IACZ;AAEA,WAAO;AAAA,EACR;AACD;AAtXa,sBAAN;AAAA,EAYJ;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,GAhBU;AAwXN,SAAS,oBAAoB,MAA0D;AAC7F,QAAM,SAAwB,EAAE,eAAe,CAAC,EAAE;AAClD,QAAM,eAAe,QAAQ,EAAE,eAAe,CAAC,EAAE;AAEjD,MAAI,aAAa,kBAAkB;AAClC,WAAO,mBAAmB,mBAAmB,aAAa,gBAAgB;AAAA,EAC3E;AAEA,MAAI,aAAa,iCAAiC;AACjD,WAAO,kCAAkC,mBAAmB,aAAa,+BAA+B;AAAA,EACzG;AAEA,MAAI,MAAM,QAAQ,aAAa,aAAa,GAAG;AAC9C,WAAO,gBAAgB,aAAa,cAAc,IAAI,iBAAe,mBAAmB,WAAW,CAAC;AAAA,EACrG;AAEA,SAAO;AACR;AAjBgB;AAmBhB,SAAS,mBAAmB,aAAmD;AAC9E,QAAM,SAAuB,EAAE,SAAS,YAAY,QAAQ;AAC5D,MAAI,YAAY,YAAY;AAC3B,WAAO,aAAa,YAAY;AAAA,EACjC;AAEA,MAAI,YAAY,iBAAiB;AAChC,WAAO,kBAAkB,YAAY;AAAA,EACtC;AAEA,MAAI,YAAY,QAAQ;AACvB,WAAO,YAAY,IAAI,MAAM,YAAY,MAAM;AAAA,EAChD;AAEA,MAAI,YAAY,qBAAqB;AACpC,WAAO,YAAY,EAAE,IAAI,YAAY,oBAAoB,IAAI,YAAY,IAAI,MAAM,YAAY,oBAAoB,aAAa,EAAE;AAAA,EACnI;AAEA,SAAO;AACR;AAnBS;AAqBF,SAAS,yBAAyB,cAA4C;AACpF,SAAO;AAAA,IACN,kBAAkB,aAAa,oBAAoB,qBAAqB,aAAa,gBAAgB;AAAA,IACrG,iCAAiC,aAAa,mCAAmC,qBAAqB,aAAa,+BAA+B;AAAA,IAClJ,eAAe,aAAa,cAAc,IAAI,QAAM,qBAAqB,EAAE,CAAC;AAAA,EAC7E;AACD;AANgB;AAQhB,SAAS,qBAAqB,aAAmD;AAChF,SAAO;AAAA,IACN,qBAAqB,YAAY,aAAa,EAAE,IAAI,YAAY,UAAU,IAAI,eAAe,YAAY,UAAU,WAAW,SAAS,EAAE;AAAA,IACzI,QAAQ,YAAY,aAAa,YAAY,UAAU,SAAS;AAAA,IAChE,YAAY,YAAY;AAAA,IACxB,iBAAiB,YAAY;AAAA,IAC7B,SAAS,YAAY;AAAA,EACtB;AACD;AARS;",
  "names": []
}
