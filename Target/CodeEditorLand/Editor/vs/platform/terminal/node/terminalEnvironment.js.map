{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/terminal/node/terminalEnvironment.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as os from 'os';\nimport { FileAccess } from '../../../base/common/network.js';\nimport { getCaseInsensitive } from '../../../base/common/objects.js';\nimport * as path from '../../../base/common/path.js';\nimport { IProcessEnvironment, isMacintosh, isWindows } from '../../../base/common/platform.js';\nimport * as process from '../../../base/common/process.js';\nimport { format } from '../../../base/common/strings.js';\nimport { isString } from '../../../base/common/types.js';\nimport * as pfs from '../../../base/node/pfs.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { IProductService } from '../../product/common/productService.js';\nimport { IShellLaunchConfig, ITerminalEnvironment, ITerminalProcessOptions } from '../common/terminal.js';\nimport { EnvironmentVariableMutatorType } from '../common/environmentVariable.js';\nimport { deserializeEnvironmentVariableCollections } from '../common/environmentVariableShared.js';\nimport { MergedEnvironmentVariableCollection } from '../common/environmentVariableCollection.js';\n\nexport function getWindowsBuildNumber(): number {\n\tconst osVersion = (/(\\d+)\\.(\\d+)\\.(\\d+)/g).exec(os.release());\n\tlet buildNumber: number = 0;\n\tif (osVersion && osVersion.length === 4) {\n\t\tbuildNumber = parseInt(osVersion[3]);\n\t}\n\treturn buildNumber;\n}\n\nexport async function findExecutable(command: string, cwd?: string, paths?: string[], env: IProcessEnvironment = process.env as IProcessEnvironment, exists: (path: string) => Promise<boolean> = pfs.Promises.exists): Promise<string | undefined> {\n\t// If we have an absolute path then we take it.\n\tif (path.isAbsolute(command)) {\n\t\treturn await exists(command) ? command : undefined;\n\t}\n\tif (cwd === undefined) {\n\t\tcwd = process.cwd();\n\t}\n\tconst dir = path.dirname(command);\n\tif (dir !== '.') {\n\t\t// We have a directory and the directory is relative (see above). Make the path absolute\n\t\t// to the current working directory.\n\t\tconst fullPath = path.join(cwd, command);\n\t\treturn await exists(fullPath) ? fullPath : undefined;\n\t}\n\tconst envPath = getCaseInsensitive(env, 'PATH');\n\tif (paths === undefined && isString(envPath)) {\n\t\tpaths = envPath.split(path.delimiter);\n\t}\n\t// No PATH environment. Make path absolute to the cwd.\n\tif (paths === undefined || paths.length === 0) {\n\t\tconst fullPath = path.join(cwd, command);\n\t\treturn await exists(fullPath) ? fullPath : undefined;\n\t}\n\t// We have a simple file name. We get the path variable from the env\n\t// and try to find the executable on the path.\n\tfor (const pathEntry of paths) {\n\t\t// The path entry is absolute.\n\t\tlet fullPath: string;\n\t\tif (path.isAbsolute(pathEntry)) {\n\t\t\tfullPath = path.join(pathEntry, command);\n\t\t} else {\n\t\t\tfullPath = path.join(cwd, pathEntry, command);\n\t\t}\n\n\t\tif (await exists(fullPath)) {\n\t\t\treturn fullPath;\n\t\t}\n\t\tif (isWindows) {\n\t\t\tlet withExtension = fullPath + '.com';\n\t\t\tif (await exists(withExtension)) {\n\t\t\t\treturn withExtension;\n\t\t\t}\n\t\t\twithExtension = fullPath + '.exe';\n\t\t\tif (await exists(withExtension)) {\n\t\t\t\treturn withExtension;\n\t\t\t}\n\t\t}\n\t}\n\tconst fullPath = path.join(cwd, command);\n\treturn await exists(fullPath) ? fullPath : undefined;\n}\n\nexport interface IShellIntegrationConfigInjection {\n\t/**\n\t * A new set of arguments to use.\n\t */\n\tnewArgs: string[] | undefined;\n\t/**\n\t * An optional environment to mixing to the real environment.\n\t */\n\tenvMixin?: IProcessEnvironment;\n\t/**\n\t * An optional array of files to copy from `source` to `dest`.\n\t */\n\tfilesToCopy?: {\n\t\tsource: string;\n\t\tdest: string;\n\t}[];\n}\n\n/**\n * For a given shell launch config, returns arguments to replace and an optional environment to\n * mixin to the SLC's environment to enable shell integration. This must be run within the context\n * that creates the process to ensure accuracy. Returns undefined if shell integration cannot be\n * enabled.\n */\nexport function getShellIntegrationInjection(\n\tshellLaunchConfig: IShellLaunchConfig,\n\toptions: ITerminalProcessOptions,\n\tenv: ITerminalEnvironment | undefined,\n\tlogService: ILogService,\n\tproductService: IProductService\n): IShellIntegrationConfigInjection | undefined {\n\t// Conditionally disable shell integration arg injection\n\t// - The global setting is disabled\n\t// - There is no executable (not sure what script to run)\n\t// - The terminal is used by a feature like tasks or debugging\n\tconst useWinpty = isWindows && (!options.windowsEnableConpty || getWindowsBuildNumber() < 18309);\n\tif (\n\t\t// The global setting is disabled\n\t\t!options.shellIntegration.enabled ||\n\t\t// There is no executable (so there's no way to determine how to inject)\n\t\t!shellLaunchConfig.executable ||\n\t\t// It's a feature terminal (tasks, debug), unless it's explicitly being forced\n\t\t(shellLaunchConfig.isFeatureTerminal && !shellLaunchConfig.forceShellIntegration) ||\n\t\t// The ignoreShellIntegration flag is passed (eg. relaunching without shell integration)\n\t\tshellLaunchConfig.ignoreShellIntegration ||\n\t\t// Winpty is unsupported\n\t\tuseWinpty\n\t) {\n\t\treturn undefined;\n\t}\n\n\tconst originalArgs = shellLaunchConfig.args;\n\tconst shell = process.platform === 'win32' ? path.basename(shellLaunchConfig.executable).toLowerCase() : path.basename(shellLaunchConfig.executable);\n\tconst appRoot = path.dirname(FileAccess.asFileUri('').fsPath);\n\tlet newArgs: string[] | undefined;\n\tconst envMixin: IProcessEnvironment = {\n\t\t'VSCODE_INJECTION': '1'\n\t};\n\n\tif (options.shellIntegration.nonce) {\n\t\tenvMixin['VSCODE_NONCE'] = options.shellIntegration.nonce;\n\t}\n\n\t// Windows\n\tif (isWindows) {\n\t\tif (shell === 'pwsh.exe' || shell === 'powershell.exe') {\n\t\t\tif (!originalArgs || arePwshImpliedArgs(originalArgs)) {\n\t\t\t\tnewArgs = shellIntegrationArgs.get(ShellIntegrationExecutable.WindowsPwsh);\n\t\t\t} else if (arePwshLoginArgs(originalArgs)) {\n\t\t\t\tnewArgs = shellIntegrationArgs.get(ShellIntegrationExecutable.WindowsPwshLogin);\n\t\t\t}\n\t\t\tif (!newArgs) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tnewArgs = [...newArgs]; // Shallow clone the array to avoid setting the default array\n\t\t\tnewArgs[newArgs.length - 1] = format(newArgs[newArgs.length - 1], appRoot, '');\n\t\t\tenvMixin['VSCODE_STABLE'] = productService.quality === 'stable' ? '1' : '0';\n\t\t\tif (options.shellIntegration.suggestEnabled) {\n\t\t\t\tenvMixin['VSCODE_SUGGEST'] = '1';\n\t\t\t}\n\t\t\treturn { newArgs, envMixin };\n\t\t} else if (shell === 'bash.exe') {\n\t\t\tif (!originalArgs || originalArgs.length === 0) {\n\t\t\t\tnewArgs = shellIntegrationArgs.get(ShellIntegrationExecutable.Bash);\n\t\t\t} else if (areZshBashLoginArgs(originalArgs)) {\n\t\t\t\tenvMixin['VSCODE_SHELL_LOGIN'] = '1';\n\t\t\t\taddEnvMixinPathPrefix(options, envMixin);\n\t\t\t\tnewArgs = shellIntegrationArgs.get(ShellIntegrationExecutable.Bash);\n\t\t\t}\n\t\t\tif (!newArgs) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tnewArgs = [...newArgs]; // Shallow clone the array to avoid setting the default array\n\t\t\tnewArgs[newArgs.length - 1] = format(newArgs[newArgs.length - 1], appRoot);\n\t\t\tenvMixin['VSCODE_STABLE'] = productService.quality === 'stable' ? '1' : '0';\n\t\t\treturn { newArgs, envMixin };\n\t\t}\n\t\tlogService.warn(`Shell integration cannot be enabled for executable \"${shellLaunchConfig.executable}\" and args`, shellLaunchConfig.args);\n\t\treturn undefined;\n\t}\n\n\t// Linux & macOS\n\tswitch (shell) {\n\t\tcase 'bash': {\n\t\t\tif (!originalArgs || originalArgs.length === 0) {\n\t\t\t\tnewArgs = shellIntegrationArgs.get(ShellIntegrationExecutable.Bash);\n\t\t\t} else if (areZshBashLoginArgs(originalArgs)) {\n\t\t\t\tenvMixin['VSCODE_SHELL_LOGIN'] = '1';\n\t\t\t\taddEnvMixinPathPrefix(options, envMixin);\n\t\t\t\tnewArgs = shellIntegrationArgs.get(ShellIntegrationExecutable.Bash);\n\t\t\t}\n\t\t\tif (!newArgs) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tnewArgs = [...newArgs]; // Shallow clone the array to avoid setting the default array\n\t\t\tnewArgs[newArgs.length - 1] = format(newArgs[newArgs.length - 1], appRoot);\n\t\t\tenvMixin['VSCODE_STABLE'] = productService.quality === 'stable' ? '1' : '0';\n\t\t\treturn { newArgs, envMixin };\n\t\t}\n\t\tcase 'fish': {\n\t\t\t// The injection mechanism used for fish is to add a custom dir to $XDG_DATA_DIRS which\n\t\t\t// is similar to $ZDOTDIR in zsh but contains a list of directories to run from.\n\t\t\tconst oldDataDirs = env?.XDG_DATA_DIRS ?? '/usr/local/share:/usr/share';\n\t\t\tconst newDataDir = path.join(appRoot, 'out/vs/workbench/contrib/terminal/common/scripts/fish_xdg_data');\n\t\t\tenvMixin['XDG_DATA_DIRS'] = `${oldDataDirs}:${newDataDir}`;\n\t\t\taddEnvMixinPathPrefix(options, envMixin);\n\t\t\treturn { newArgs: undefined, envMixin };\n\t\t}\n\t\tcase 'pwsh': {\n\t\t\tif (!originalArgs || arePwshImpliedArgs(originalArgs)) {\n\t\t\t\tnewArgs = shellIntegrationArgs.get(ShellIntegrationExecutable.Pwsh);\n\t\t\t} else if (arePwshLoginArgs(originalArgs)) {\n\t\t\t\tnewArgs = shellIntegrationArgs.get(ShellIntegrationExecutable.PwshLogin);\n\t\t\t}\n\t\t\tif (!newArgs) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tif (options.shellIntegration.suggestEnabled) {\n\t\t\t\tenvMixin['VSCODE_SUGGEST'] = '1';\n\t\t\t}\n\t\t\tnewArgs = [...newArgs]; // Shallow clone the array to avoid setting the default array\n\t\t\tnewArgs[newArgs.length - 1] = format(newArgs[newArgs.length - 1], appRoot, '');\n\t\t\tenvMixin['VSCODE_STABLE'] = productService.quality === 'stable' ? '1' : '0';\n\t\t\treturn { newArgs, envMixin };\n\t\t}\n\t\tcase 'zsh': {\n\t\t\tif (!originalArgs || originalArgs.length === 0) {\n\t\t\t\tnewArgs = shellIntegrationArgs.get(ShellIntegrationExecutable.Zsh);\n\t\t\t} else if (areZshBashLoginArgs(originalArgs)) {\n\t\t\t\tnewArgs = shellIntegrationArgs.get(ShellIntegrationExecutable.ZshLogin);\n\t\t\t\taddEnvMixinPathPrefix(options, envMixin);\n\t\t\t} else if (originalArgs === shellIntegrationArgs.get(ShellIntegrationExecutable.Zsh) || originalArgs === shellIntegrationArgs.get(ShellIntegrationExecutable.ZshLogin)) {\n\t\t\t\tnewArgs = originalArgs;\n\t\t\t}\n\t\t\tif (!newArgs) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tnewArgs = [...newArgs]; // Shallow clone the array to avoid setting the default array\n\t\t\tnewArgs[newArgs.length - 1] = format(newArgs[newArgs.length - 1], appRoot);\n\n\t\t\t// Move .zshrc into $ZDOTDIR as the way to activate the script\n\t\t\tlet username: string;\n\t\t\ttry {\n\t\t\t\tusername = os.userInfo().username;\n\t\t\t} catch {\n\t\t\t\tusername = 'unknown';\n\t\t\t}\n\t\t\tconst zdotdir = path.join(os.tmpdir(), `${username}-${productService.applicationName}-zsh`);\n\t\t\tenvMixin['ZDOTDIR'] = zdotdir;\n\t\t\tconst userZdotdir = env?.ZDOTDIR ?? os.homedir() ?? `~`;\n\t\t\tenvMixin['USER_ZDOTDIR'] = userZdotdir;\n\t\t\tconst filesToCopy: IShellIntegrationConfigInjection['filesToCopy'] = [];\n\t\t\tfilesToCopy.push({\n\t\t\t\tsource: path.join(appRoot, 'out/vs/workbench/contrib/terminal/common/scripts/shellIntegration-rc.zsh'),\n\t\t\t\tdest: path.join(zdotdir, '.zshrc')\n\t\t\t});\n\t\t\tfilesToCopy.push({\n\t\t\t\tsource: path.join(appRoot, 'out/vs/workbench/contrib/terminal/common/scripts/shellIntegration-profile.zsh'),\n\t\t\t\tdest: path.join(zdotdir, '.zprofile')\n\t\t\t});\n\t\t\tfilesToCopy.push({\n\t\t\t\tsource: path.join(appRoot, 'out/vs/workbench/contrib/terminal/common/scripts/shellIntegration-env.zsh'),\n\t\t\t\tdest: path.join(zdotdir, '.zshenv')\n\t\t\t});\n\t\t\tfilesToCopy.push({\n\t\t\t\tsource: path.join(appRoot, 'out/vs/workbench/contrib/terminal/common/scripts/shellIntegration-login.zsh'),\n\t\t\t\tdest: path.join(zdotdir, '.zlogin')\n\t\t\t});\n\t\t\treturn { newArgs, envMixin, filesToCopy };\n\t\t}\n\t}\n\tlogService.warn(`Shell integration cannot be enabled for executable \"${shellLaunchConfig.executable}\" and args`, shellLaunchConfig.args);\n\treturn undefined;\n}\n\n/**\n * On macOS the profile calls path_helper which adds a bunch of standard bin directories to the\n * beginning of the PATH. This causes significant problems for the environment variable\n * collection API as the custom paths added to the end will now be somewhere in the middle of\n * the PATH. To combat this, VSCODE_PATH_PREFIX is used to re-apply any prefix after the profile\n * has run. This will cause duplication in the PATH but should fix the issue.\n *\n * See #99878 for more information.\n */\nfunction addEnvMixinPathPrefix(options: ITerminalProcessOptions, envMixin: IProcessEnvironment): void {\n\tif (isMacintosh && options.environmentVariableCollections) {\n\t\t// Deserialize and merge\n\t\tconst deserialized = deserializeEnvironmentVariableCollections(options.environmentVariableCollections);\n\t\tconst merged = new MergedEnvironmentVariableCollection(deserialized);\n\n\t\t// Get all prepend PATH entries\n\t\tconst pathEntry = merged.getVariableMap({ workspaceFolder: options.workspaceFolder }).get('PATH');\n\t\tconst prependToPath: string[] = [];\n\t\tif (pathEntry) {\n\t\t\tfor (const mutator of pathEntry) {\n\t\t\t\tif (mutator.type === EnvironmentVariableMutatorType.Prepend) {\n\t\t\t\t\tprependToPath.push(mutator.value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add to the environment mixin to be applied in the shell integration script\n\t\tif (prependToPath.length > 0) {\n\t\t\tenvMixin['VSCODE_PATH_PREFIX'] = prependToPath.join('');\n\t\t}\n\t}\n}\n\nenum ShellIntegrationExecutable {\n\tWindowsPwsh = 'windows-pwsh',\n\tWindowsPwshLogin = 'windows-pwsh-login',\n\tPwsh = 'pwsh',\n\tPwshLogin = 'pwsh-login',\n\tZsh = 'zsh',\n\tZshLogin = 'zsh-login',\n\tBash = 'bash'\n}\n\nconst shellIntegrationArgs: Map<ShellIntegrationExecutable, string[]> = new Map();\n// The try catch swallows execution policy errors in the case of the archive distributable\nshellIntegrationArgs.set(ShellIntegrationExecutable.WindowsPwsh, ['-noexit', '-command', 'try { . \\\"{0}\\\\out\\\\vs\\\\workbench\\\\contrib\\\\terminal\\\\common\\\\scripts\\\\shellIntegration.ps1\\\" } catch {}{1}']);\nshellIntegrationArgs.set(ShellIntegrationExecutable.WindowsPwshLogin, ['-l', '-noexit', '-command', 'try { . \\\"{0}\\\\out\\\\vs\\\\workbench\\\\contrib\\\\terminal\\\\common\\\\scripts\\\\shellIntegration.ps1\\\" } catch {}{1}']);\nshellIntegrationArgs.set(ShellIntegrationExecutable.Pwsh, ['-noexit', '-command', '. \"{0}/out/vs/workbench/contrib/terminal/common/scripts/shellIntegration.ps1\"{1}']);\nshellIntegrationArgs.set(ShellIntegrationExecutable.PwshLogin, ['-l', '-noexit', '-command', '. \"{0}/out/vs/workbench/contrib/terminal/common/scripts/shellIntegration.ps1\"']);\nshellIntegrationArgs.set(ShellIntegrationExecutable.Zsh, ['-i']);\nshellIntegrationArgs.set(ShellIntegrationExecutable.ZshLogin, ['-il']);\nshellIntegrationArgs.set(ShellIntegrationExecutable.Bash, ['--init-file', '{0}/out/vs/workbench/contrib/terminal/common/scripts/shellIntegration-bash.sh']);\nconst pwshLoginArgs = ['-login', '-l'];\nconst shLoginArgs = ['--login', '-l'];\nconst shInteractiveArgs = ['-i', '--interactive'];\nconst pwshImpliedArgs = ['-nol', '-nologo'];\n\nfunction arePwshLoginArgs(originalArgs: string | string[]): boolean {\n\tif (typeof originalArgs === 'string') {\n\t\treturn pwshLoginArgs.includes(originalArgs.toLowerCase());\n\t} else {\n\t\treturn originalArgs.length === 1 && pwshLoginArgs.includes(originalArgs[0].toLowerCase()) ||\n\t\t\t(originalArgs.length === 2 &&\n\t\t\t\t(((pwshLoginArgs.includes(originalArgs[0].toLowerCase())) || pwshLoginArgs.includes(originalArgs[1].toLowerCase())))\n\t\t\t\t&& ((pwshImpliedArgs.includes(originalArgs[0].toLowerCase())) || pwshImpliedArgs.includes(originalArgs[1].toLowerCase())));\n\t}\n}\n\nfunction arePwshImpliedArgs(originalArgs: string | string[]): boolean {\n\tif (typeof originalArgs === 'string') {\n\t\treturn pwshImpliedArgs.includes(originalArgs.toLowerCase());\n\t} else {\n\t\treturn originalArgs.length === 0 || originalArgs?.length === 1 && pwshImpliedArgs.includes(originalArgs[0].toLowerCase());\n\t}\n}\n\nfunction areZshBashLoginArgs(originalArgs: string | string[]): boolean {\n\tif (typeof originalArgs !== 'string') {\n\t\toriginalArgs = originalArgs.filter(arg => !shInteractiveArgs.includes(arg.toLowerCase()));\n\t}\n\treturn originalArgs === 'string' && shLoginArgs.includes(originalArgs.toLowerCase())\n\t\t|| typeof originalArgs !== 'string' && originalArgs.length === 1 && shLoginArgs.includes(originalArgs[0].toLowerCase());\n}\n"],
  "mappings": "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",
  "names": ["fullPath", "ShellIntegrationExecutable"]
}
