import*as F from"child_process";import*as W from"fs";import{dirname as R,resolve as E}from"path";import{Codicon as h}from"../../../../vs/base/common/codicons.js";import{basename as y,delimiter as O,normalize as M}from"../../../../vs/base/common/path.js";import{isLinux as b,isWindows as v}from"../../../../vs/base/common/platform.js";import"../../../../vs/base/common/themables.js";import{isString as L}from"../../../../vs/base/common/types.js";import"../../../../vs/base/common/uri.js";import*as C from"../../../../vs/base/node/pfs.js";import{enumeratePowerShellInstallations as k}from"../../../../vs/base/node/powershell.js";import"../../../../vs/platform/configuration/common/configuration.js";import"../../../../vs/platform/log/common/log.js";import{ProfileSource as w,TerminalSettingId as P}from"../../../../vs/platform/terminal/common/terminal.js";import{findExecutable as U,getWindowsBuildNumber as V}from"../../../../vs/platform/terminal/node/terminalEnvironment.js";var B=(e=>(e.UnixShellsPath="/etc/shells",e))(B||{});let I,S=!0;function Pe(t,e,i,n,l=process.env,c,o,a,u){return c=c||{existsFile:C.SymlinkSupport.existsFile,readFile:W.promises.readFile},v?q(i,c,l,o,n.getValue(P.UseWslProfiles)!==!1,t&&typeof t=="object"?{...t}:n.getValue(P.ProfilesWindows),typeof e=="string"?e:n.getValue(P.DefaultProfileWindows),u,a):K(c,o,i,t&&typeof t=="object"?{...t}:n.getValue(b?P.ProfilesLinux:P.ProfilesMacOs),typeof e=="string"?e:n.getValue(b?P.DefaultProfileLinux:P.DefaultProfileMacOs),u,a,l)}async function q(t,e,i,n,l,c,o,a,u){const g=process.env.hasOwnProperty("PROCESSOR_ARCHITEW6432"),f=`${process.env.windir}\\${g?"Sysnative":"System32"}`;let p=!1;V()>=16299&&(p=!0),await H(a);const r=new Map;if(t){r.set("PowerShell",{source:w.Pwsh,icon:h.terminalPowershell,isAutoDetected:!0}),r.set("Windows PowerShell",{path:`${f}\\WindowsPowerShell\\v1.0\\powershell.exe`,icon:h.terminalPowershell,isAutoDetected:!0}),r.set("Git Bash",{source:w.GitBash,isAutoDetected:!0}),r.set("Command Prompt",{path:`${f}\\cmd.exe`,icon:h.terminalCmd,isAutoDetected:!0}),r.set("Cygwin",{path:[{path:`${process.env.HOMEDRIVE}\\cygwin64\\bin\\bash.exe`,isUnsafe:!0},{path:`${process.env.HOMEDRIVE}\\cygwin\\bin\\bash.exe`,isUnsafe:!0}],args:["--login"],isAutoDetected:!0}),r.set("bash (MSYS2)",{path:[{path:`${process.env.HOMEDRIVE}\\msys64\\usr\\bin\\bash.exe`,isUnsafe:!0}],args:["--login","-i"],env:{CHERE_INVOKING:"1"},icon:h.terminalBash,isAutoDetected:!0});const m=`${process.env.CMDER_ROOT||`${process.env.HOMEDRIVE}\\cmder`}\\vendor\\bin\\vscode_init.cmd`;r.set("Cmder",{path:`${f}\\cmd.exe`,args:["/K",m],requiresPath:process.env.CMDER_ROOT?m:{path:m,isUnsafe:!0},isAutoDetected:!0})}$(c,r);const s=await D(r.entries(),o,e,i,n,u);if(t&&l)try{const m=await N(`${f}\\${p?"wsl":"bash"}.exe`,o);for(const d of m)(!c||!(d.profileName in c))&&s.push(d)}catch{S&&(n?.trace("WSL is not installed, so could not detect WSL profiles"),S=!1)}return s}async function D(t,e,i,n=process.env,l,c){const o=[];for(const[a,u]of t)o.push(G(a,u,e,i,n,l,c));return(await Promise.all(o)).filter(a=>!!a)}async function G(t,e,i,n,l=process.env,c,o){if(e===null)return;let a,u,g;if("source"in e&&!("path"in e)){const s=I?.get(e.source);if(!s)return;a=s.paths,u=e.args||s.args,e.icon?g=A(e.icon):s.icon&&(g=s.icon)}else a=Array.isArray(e.path)?e.path:[e.path],u=v||Array.isArray(e.args)?e.args:void 0,g=A(e.icon);let f;if(o){const s=a.map(d=>typeof d=="string"?d:d.path),m=await o(s);f=new Array(a.length);for(let d=0;d<a.length;d++)typeof a[d]=="string"?f[d]=m[d]:f[d]={path:m[d],isUnsafe:!0}}else f=a.slice();let p;if(e.requiresPath){let s;if(L(e.requiresPath)?s=e.requiresPath:(s=e.requiresPath.path,e.requiresPath.isUnsafe&&(p=s)),!await n.existsFile(s))return}const r=await T(t,i,f,n,l,u,e.env,e.overrideName,e.isAutoDetected,p);if(!r){c?.debug("Terminal profile not validated",t,a);return}return r.isAutoDetected=e.isAutoDetected,r.icon=g,r.color=e.color,r}function A(t){return typeof t=="string"?{id:t}:t}async function H(t){if(I&&!t)return;const[e,i]=await Promise.all([_(),t||j()]);I=new Map,I.set(w.GitBash,{profileName:"Git Bash",paths:e,args:["--login","-i"]}),I.set(w.Pwsh,{profileName:"PowerShell",paths:i,icon:h.terminalPowershell})}async function _(){const t=new Set,e=await U("git.exe");if(e){const l=R(e);t.add(E(l,"../.."))}function i(l,c){c&&l.add(c)}i(t,process.env.ProgramW6432),i(t,process.env.ProgramFiles),i(t,process.env["ProgramFiles(X86)"]),i(t,`${process.env.LocalAppData}\\Program`);const n=[];for(const l of t)n.push(`${l}\\Git\\bin\\bash.exe`,`${l}\\Git\\usr\\bin\\bash.exe`,`${l}\\usr\\bin\\bash.exe`);return n.push(`${process.env.UserProfile}\\scoop\\apps\\git\\current\\bin\\bash.exe`),n.push(`${process.env.UserProfile}\\scoop\\apps\\git-with-openssh\\current\\bin\\bash.exe`),n}async function j(){const t=[];for await(const e of k())t.push(e.exePath);return t}async function N(t,e){const i=[],n=await new Promise((o,a)=>{F.exec("wsl.exe -l -q",{encoding:"utf16le",timeout:1e3},(u,g)=>{if(u)return a("Problem occurred when getting wsl distros");o(g)})});if(!n)return[];const l=new RegExp(/[\r?\n]/),c=n.split(l).filter(o=>o.trim().length>0&&o!=="");for(const o of c){if(o===""||o.startsWith("docker-desktop"))continue;const a=`${o} (WSL)`,u={profileName:a,path:t,args:["-d",`${o}`],isDefault:a===e,icon:z(o),isAutoDetected:!1};i.push(u)}return i}function z(t){return t.includes("Ubuntu")?h.terminalUbuntu:t.includes("Debian")?h.terminalDebian:h.terminalLinux}async function K(t,e,i,n,l,c,o,a){const u=new Map;if(i&&await t.existsFile("/etc/shells")){const g=(await t.readFile("/etc/shells")).toString(),f=(c||g.split(`
`)).map(r=>{const s=r.indexOf("#");return s===-1?r:r.substring(0,s)}).filter(r=>r.trim().length>0),p=new Map;for(const r of f){let s=y(r),m=p.get(s)||0;m++,m>1&&(s=`${s} (${m})`),p.set(s,m),u.set(s,{path:r,isAutoDetected:!0})}}return $(n,u),await D(u.entries(),l,t,a,e,o)}function $(t,e){if(t)for(const[i,n]of Object.entries(t))n===null||typeof n!="object"||!("path"in n)&&!("source"in n)?e.delete(i):(n.icon=n.icon||e.get(i)?.icon,e.set(i,n))}async function T(t,e,i,n,l,c,o,a,u,g){if(i.length===0)return Promise.resolve(void 0);const f=i.shift();if(f==="")return T(t,e,i,n,l,c,o,a,u);const p=typeof f!="string"&&f.isUnsafe,r=typeof f=="string"?f:f.path,s={profileName:t,path:r,args:c,env:o,overrideName:a,isAutoDetected:u,isDefault:t===e,isUnsafePath:p,requiresUnsafePath:g};if(y(r)===r){const d=l.PATH?l.PATH.split(O):void 0,x=await U(r,void 0,d,void 0,n.existsFile);return x?(s.path=x,s.isFromPath=!0,s):T(t,e,i,n,l,c)}return await n.existsFile(M(r))?s:T(t,e,i,n,l,c,o,a,u)}export{Pe as detectAvailableProfiles};
