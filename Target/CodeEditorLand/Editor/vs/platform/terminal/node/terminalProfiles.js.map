{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/terminal/node/terminalProfiles.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport * as cp from 'child_process';\nimport { Codicon } from '../../../base/common/codicons.js';\nimport { basename, delimiter, normalize } from '../../../base/common/path.js';\nimport { isLinux, isWindows } from '../../../base/common/platform.js';\nimport { isString } from '../../../base/common/types.js';\nimport { URI } from '../../../base/common/uri.js';\nimport * as pfs from '../../../base/node/pfs.js';\nimport { enumeratePowerShellInstallations } from '../../../base/node/powershell.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { ITerminalEnvironment, ITerminalExecutable, ITerminalProfile, ITerminalProfileSource, ITerminalUnsafePath, ProfileSource, TerminalIcon, TerminalSettingId } from '../common/terminal.js';\nimport { findExecutable, getWindowsBuildNumber } from './terminalEnvironment.js';\nimport { ThemeIcon } from '../../../base/common/themables.js';\nimport { dirname, resolve } from 'path';\n\nconst enum Constants {\n\tUnixShellsPath = '/etc/shells'\n}\n\nlet profileSources: Map<string, IPotentialTerminalProfile> | undefined;\nlet logIfWslNotInstalled: boolean = true;\n\nexport function detectAvailableProfiles(\n\tprofiles: unknown,\n\tdefaultProfile: unknown,\n\tincludeDetectedProfiles: boolean,\n\tconfigurationService: IConfigurationService,\n\tshellEnv: typeof process.env = process.env,\n\tfsProvider?: IFsProvider,\n\tlogService?: ILogService,\n\tvariableResolver?: (text: string[]) => Promise<string[]>,\n\ttestPwshSourcePaths?: string[]\n): Promise<ITerminalProfile[]> {\n\tfsProvider = fsProvider || {\n\t\texistsFile: pfs.SymlinkSupport.existsFile,\n\t\treadFile: fs.promises.readFile\n\t};\n\tif (isWindows) {\n\t\treturn detectAvailableWindowsProfiles(\n\t\t\tincludeDetectedProfiles,\n\t\t\tfsProvider,\n\t\t\tshellEnv,\n\t\t\tlogService,\n\t\t\tconfigurationService.getValue(TerminalSettingId.UseWslProfiles) !== false,\n\t\t\tprofiles && typeof profiles === 'object' ? { ...profiles } : configurationService.getValue<{ [key: string]: IUnresolvedTerminalProfile }>(TerminalSettingId.ProfilesWindows),\n\t\t\ttypeof defaultProfile === 'string' ? defaultProfile : configurationService.getValue<string>(TerminalSettingId.DefaultProfileWindows),\n\t\t\ttestPwshSourcePaths,\n\t\t\tvariableResolver\n\t\t);\n\t}\n\treturn detectAvailableUnixProfiles(\n\t\tfsProvider,\n\t\tlogService,\n\t\tincludeDetectedProfiles,\n\t\tprofiles && typeof profiles === 'object' ? { ...profiles } : configurationService.getValue<{ [key: string]: IUnresolvedTerminalProfile }>(isLinux ? TerminalSettingId.ProfilesLinux : TerminalSettingId.ProfilesMacOs),\n\t\ttypeof defaultProfile === 'string' ? defaultProfile : configurationService.getValue<string>(isLinux ? TerminalSettingId.DefaultProfileLinux : TerminalSettingId.DefaultProfileMacOs),\n\t\ttestPwshSourcePaths,\n\t\tvariableResolver,\n\t\tshellEnv\n\t);\n}\n\nasync function detectAvailableWindowsProfiles(\n\tincludeDetectedProfiles: boolean,\n\tfsProvider: IFsProvider,\n\tshellEnv: typeof process.env,\n\tlogService?: ILogService,\n\tuseWslProfiles?: boolean,\n\tconfigProfiles?: { [key: string]: IUnresolvedTerminalProfile },\n\tdefaultProfileName?: string,\n\ttestPwshSourcePaths?: string[],\n\tvariableResolver?: (text: string[]) => Promise<string[]>\n): Promise<ITerminalProfile[]> {\n\t// Determine the correct System32 path. We want to point to Sysnative\n\t// when the 32-bit version of VS Code is running on a 64-bit machine.\n\t// The reason for this is because PowerShell's important PSReadline\n\t// module doesn't work if this is not the case. See #27915.\n\tconst is32ProcessOn64Windows = process.env.hasOwnProperty('PROCESSOR_ARCHITEW6432');\n\tconst system32Path = `${process.env['windir']}\\\\${is32ProcessOn64Windows ? 'Sysnative' : 'System32'}`;\n\n\tlet useWSLexe = false;\n\n\tif (getWindowsBuildNumber() >= 16299) {\n\t\tuseWSLexe = true;\n\t}\n\n\tawait initializeWindowsProfiles(testPwshSourcePaths);\n\n\tconst detectedProfiles: Map<string, IUnresolvedTerminalProfile> = new Map();\n\n\t// Add auto detected profiles\n\tif (includeDetectedProfiles) {\n\t\tdetectedProfiles.set('PowerShell', {\n\t\t\tsource: ProfileSource.Pwsh,\n\t\t\ticon: Codicon.terminalPowershell,\n\t\t\tisAutoDetected: true\n\t\t});\n\t\tdetectedProfiles.set('Windows PowerShell', {\n\t\t\tpath: `${system32Path}\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe`,\n\t\t\ticon: Codicon.terminalPowershell,\n\t\t\tisAutoDetected: true\n\t\t});\n\t\tdetectedProfiles.set('Git Bash', {\n\t\t\tsource: ProfileSource.GitBash,\n\t\t\tisAutoDetected: true\n\t\t});\n\t\tdetectedProfiles.set('Command Prompt', {\n\t\t\tpath: `${system32Path}\\\\cmd.exe`,\n\t\t\ticon: Codicon.terminalCmd,\n\t\t\tisAutoDetected: true\n\t\t});\n\t\tdetectedProfiles.set('Cygwin', {\n\t\t\tpath: [\n\t\t\t\t{ path: `${process.env['HOMEDRIVE']}\\\\cygwin64\\\\bin\\\\bash.exe`, isUnsafe: true },\n\t\t\t\t{ path: `${process.env['HOMEDRIVE']}\\\\cygwin\\\\bin\\\\bash.exe`, isUnsafe: true }\n\t\t\t],\n\t\t\targs: ['--login'],\n\t\t\tisAutoDetected: true\n\t\t});\n\t\tdetectedProfiles.set('bash (MSYS2)', {\n\t\t\tpath: [\n\t\t\t\t{ path: `${process.env['HOMEDRIVE']}\\\\msys64\\\\usr\\\\bin\\\\bash.exe`, isUnsafe: true },\n\t\t\t],\n\t\t\targs: ['--login', '-i'],\n\t\t\t// CHERE_INVOKING retains current working directory\n\t\t\tenv: { CHERE_INVOKING: '1' },\n\t\t\ticon: Codicon.terminalBash,\n\t\t\tisAutoDetected: true\n\t\t});\n\t\tconst cmderPath = `${process.env['CMDER_ROOT'] || `${process.env['HOMEDRIVE']}\\\\cmder`}\\\\vendor\\\\bin\\\\vscode_init.cmd`;\n\t\tdetectedProfiles.set('Cmder', {\n\t\t\tpath: `${system32Path}\\\\cmd.exe`,\n\t\t\targs: ['/K', cmderPath],\n\t\t\t// The path is safe if it was derived from CMDER_ROOT\n\t\t\trequiresPath: process.env['CMDER_ROOT'] ? cmderPath : { path: cmderPath, isUnsafe: true },\n\t\t\tisAutoDetected: true\n\t\t});\n\t}\n\n\tapplyConfigProfilesToMap(configProfiles, detectedProfiles);\n\n\tconst resultProfiles: ITerminalProfile[] = await transformToTerminalProfiles(detectedProfiles.entries(), defaultProfileName, fsProvider, shellEnv, logService, variableResolver);\n\n\tif (includeDetectedProfiles && useWslProfiles) {\n\t\ttry {\n\t\t\tconst result = await getWslProfiles(`${system32Path}\\\\${useWSLexe ? 'wsl' : 'bash'}.exe`, defaultProfileName);\n\t\t\tfor (const wslProfile of result) {\n\t\t\t\tif (!configProfiles || !(wslProfile.profileName in configProfiles)) {\n\t\t\t\t\tresultProfiles.push(wslProfile);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tif (logIfWslNotInstalled) {\n\t\t\t\tlogService?.trace('WSL is not installed, so could not detect WSL profiles');\n\t\t\t\tlogIfWslNotInstalled = false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn resultProfiles;\n}\n\nasync function transformToTerminalProfiles(\n\tentries: IterableIterator<[string, IUnresolvedTerminalProfile]>,\n\tdefaultProfileName: string | undefined,\n\tfsProvider: IFsProvider,\n\tshellEnv: typeof process.env = process.env,\n\tlogService?: ILogService,\n\tvariableResolver?: (text: string[]) => Promise<string[]>,\n): Promise<ITerminalProfile[]> {\n\tconst promises: Promise<ITerminalProfile | undefined>[] = [];\n\tfor (const [profileName, profile] of entries) {\n\t\tpromises.push(getValidatedProfile(profileName, profile, defaultProfileName, fsProvider, shellEnv, logService, variableResolver));\n\t}\n\treturn (await Promise.all(promises)).filter(e => !!e) as ITerminalProfile[];\n}\n\nasync function getValidatedProfile(\n\tprofileName: string,\n\tprofile: IUnresolvedTerminalProfile,\n\tdefaultProfileName: string | undefined,\n\tfsProvider: IFsProvider,\n\tshellEnv: typeof process.env = process.env,\n\tlogService?: ILogService,\n\tvariableResolver?: (text: string[]) => Promise<string[]>\n): Promise<ITerminalProfile | undefined> {\n\tif (profile === null) {\n\t\treturn undefined;\n\t}\n\tlet originalPaths: (string | ITerminalUnsafePath)[];\n\tlet args: string[] | string | undefined;\n\tlet icon: ThemeIcon | URI | { light: URI; dark: URI } | undefined = undefined;\n\t// use calculated values if path is not specified\n\tif ('source' in profile && !('path' in profile)) {\n\t\tconst source = profileSources?.get(profile.source);\n\t\tif (!source) {\n\t\t\treturn undefined;\n\t\t}\n\t\toriginalPaths = source.paths;\n\n\t\t// if there are configured args, override the default ones\n\t\targs = profile.args || source.args;\n\t\tif (profile.icon) {\n\t\t\ticon = validateIcon(profile.icon);\n\t\t} else if (source.icon) {\n\t\t\ticon = source.icon;\n\t\t}\n\t} else {\n\t\toriginalPaths = Array.isArray(profile.path) ? profile.path : [profile.path];\n\t\targs = isWindows ? profile.args : Array.isArray(profile.args) ? profile.args : undefined;\n\t\ticon = validateIcon(profile.icon);\n\t}\n\n\tlet paths: (string | ITerminalUnsafePath)[];\n\tif (variableResolver) {\n\t\t// Convert to string[] for resolve\n\t\tconst mapped = originalPaths.map(e => typeof e === 'string' ? e : e.path);\n\n\t\tconst resolved = await variableResolver(mapped);\n\t\t// Convert resolved back to (T | string)[]\n\t\tpaths = new Array(originalPaths.length);\n\t\tfor (let i = 0; i < originalPaths.length; i++) {\n\t\t\tif (typeof originalPaths[i] === 'string') {\n\t\t\t\tpaths[i] = resolved[i];\n\t\t\t} else {\n\t\t\t\tpaths[i] = {\n\t\t\t\t\tpath: resolved[i],\n\t\t\t\t\tisUnsafe: true\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t} else {\n\t\tpaths = originalPaths.slice();\n\t}\n\n\tlet requiresUnsafePath: string | undefined;\n\tif (profile.requiresPath) {\n\t\t// Validate requiresPath exists\n\t\tlet actualRequiredPath: string;\n\t\tif (isString(profile.requiresPath)) {\n\t\t\tactualRequiredPath = profile.requiresPath;\n\t\t} else {\n\t\t\tactualRequiredPath = profile.requiresPath.path;\n\t\t\tif (profile.requiresPath.isUnsafe) {\n\t\t\t\trequiresUnsafePath = actualRequiredPath;\n\t\t\t}\n\t\t}\n\t\tconst result = await fsProvider.existsFile(actualRequiredPath);\n\t\tif (!result) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tconst validatedProfile = await validateProfilePaths(profileName, defaultProfileName, paths, fsProvider, shellEnv, args, profile.env, profile.overrideName, profile.isAutoDetected, requiresUnsafePath);\n\tif (!validatedProfile) {\n\t\tlogService?.debug('Terminal profile not validated', profileName, originalPaths);\n\t\treturn undefined;\n\t}\n\n\tvalidatedProfile.isAutoDetected = profile.isAutoDetected;\n\tvalidatedProfile.icon = icon;\n\tvalidatedProfile.color = profile.color;\n\treturn validatedProfile;\n}\n\nfunction validateIcon(icon: string | TerminalIcon | undefined): TerminalIcon | undefined {\n\tif (typeof icon === 'string') {\n\t\treturn { id: icon };\n\t}\n\treturn icon;\n}\n\nasync function initializeWindowsProfiles(testPwshSourcePaths?: string[]): Promise<void> {\n\tif (profileSources && !testPwshSourcePaths) {\n\t\treturn;\n\t}\n\n\tconst [gitBashPaths, pwshPaths] = await Promise.all([getGitBashPaths(), testPwshSourcePaths || getPowershellPaths()]);\n\n\tprofileSources = new Map();\n\tprofileSources.set(\n\t\tProfileSource.GitBash, {\n\t\tprofileName: 'Git Bash',\n\t\tpaths: gitBashPaths,\n\t\targs: ['--login', '-i']\n\t});\n\tprofileSources.set(ProfileSource.Pwsh, {\n\t\tprofileName: 'PowerShell',\n\t\tpaths: pwshPaths,\n\t\ticon: Codicon.terminalPowershell\n\t});\n}\n\nasync function getGitBashPaths(): Promise<string[]> {\n\tconst gitDirs: Set<string> = new Set();\n\n\t// Look for git.exe on the PATH and use that if found. git.exe is located at\n\t// `<installdir>/cmd/git.exe`. This is not an unsafe location because the git executable is\n\t// located on the PATH which is only controlled by the user/admin.\n\tconst gitExePath = await findExecutable('git.exe');\n\tif (gitExePath) {\n\t\tconst gitExeDir = dirname(gitExePath);\n\t\tgitDirs.add(resolve(gitExeDir, '../..'));\n\t}\n\tfunction addTruthy<T>(set: Set<T>, value: T | undefined): void {\n\t\tif (value) {\n\t\t\tset.add(value);\n\t\t}\n\t}\n\n\t// Add common git install locations\n\taddTruthy(gitDirs, process.env['ProgramW6432']);\n\taddTruthy(gitDirs, process.env['ProgramFiles']);\n\taddTruthy(gitDirs, process.env['ProgramFiles(X86)']);\n\taddTruthy(gitDirs, `${process.env['LocalAppData']}\\\\Program`);\n\n\tconst gitBashPaths: string[] = [];\n\tfor (const gitDir of gitDirs) {\n\t\tgitBashPaths.push(\n\t\t\t`${gitDir}\\\\Git\\\\bin\\\\bash.exe`,\n\t\t\t`${gitDir}\\\\Git\\\\usr\\\\bin\\\\bash.exe`,\n\t\t\t`${gitDir}\\\\usr\\\\bin\\\\bash.exe` // using Git for Windows SDK\n\t\t);\n\t}\n\n\t// Add special installs that don't follow the standard directory structure\n\tgitBashPaths.push(`${process.env['UserProfile']}\\\\scoop\\\\apps\\\\git\\\\current\\\\bin\\\\bash.exe`);\n\tgitBashPaths.push(`${process.env['UserProfile']}\\\\scoop\\\\apps\\\\git-with-openssh\\\\current\\\\bin\\\\bash.exe`);\n\n\treturn gitBashPaths;\n}\n\nasync function getPowershellPaths(): Promise<string[]> {\n\tconst paths: string[] = [];\n\t// Add all of the different kinds of PowerShells\n\tfor await (const pwshExe of enumeratePowerShellInstallations()) {\n\t\tpaths.push(pwshExe.exePath);\n\t}\n\treturn paths;\n}\n\nasync function getWslProfiles(wslPath: string, defaultProfileName: string | undefined): Promise<ITerminalProfile[]> {\n\tconst profiles: ITerminalProfile[] = [];\n\tconst distroOutput = await new Promise<string>((resolve, reject) => {\n\t\t// wsl.exe output is encoded in utf16le (ie. A -> 0x4100)\n\t\tcp.exec('wsl.exe -l -q', { encoding: 'utf16le', timeout: 1000 }, (err, stdout) => {\n\t\t\tif (err) {\n\t\t\t\treturn reject('Problem occurred when getting wsl distros');\n\t\t\t}\n\t\t\tresolve(stdout);\n\t\t});\n\t});\n\tif (!distroOutput) {\n\t\treturn [];\n\t}\n\tconst regex = new RegExp(/[\\r?\\n]/);\n\tconst distroNames = distroOutput.split(regex).filter(t => t.trim().length > 0 && t !== '');\n\tfor (const distroName of distroNames) {\n\t\t// Skip empty lines\n\t\tif (distroName === '') {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// docker-desktop and docker-desktop-data are treated as implementation details of\n\t\t// Docker Desktop for Windows and therefore not exposed\n\t\tif (distroName.startsWith('docker-desktop')) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Create the profile, adding the icon depending on the distro\n\t\tconst profileName = `${distroName} (WSL)`;\n\t\tconst profile: ITerminalProfile = {\n\t\t\tprofileName,\n\t\t\tpath: wslPath,\n\t\t\targs: [`-d`, `${distroName}`],\n\t\t\tisDefault: profileName === defaultProfileName,\n\t\t\ticon: getWslIcon(distroName),\n\t\t\tisAutoDetected: false\n\t\t};\n\t\t// Add the profile\n\t\tprofiles.push(profile);\n\t}\n\treturn profiles;\n}\n\nfunction getWslIcon(distroName: string): ThemeIcon {\n\tif (distroName.includes('Ubuntu')) {\n\t\treturn Codicon.terminalUbuntu;\n\t} else if (distroName.includes('Debian')) {\n\t\treturn Codicon.terminalDebian;\n\t} else {\n\t\treturn Codicon.terminalLinux;\n\t}\n}\n\nasync function detectAvailableUnixProfiles(\n\tfsProvider: IFsProvider,\n\tlogService?: ILogService,\n\tincludeDetectedProfiles?: boolean,\n\tconfigProfiles?: { [key: string]: IUnresolvedTerminalProfile },\n\tdefaultProfileName?: string,\n\ttestPaths?: string[],\n\tvariableResolver?: (text: string[]) => Promise<string[]>,\n\tshellEnv?: typeof process.env\n): Promise<ITerminalProfile[]> {\n\tconst detectedProfiles: Map<string, IUnresolvedTerminalProfile> = new Map();\n\n\t// Add non-quick launch profiles\n\tif (includeDetectedProfiles && await fsProvider.existsFile(Constants.UnixShellsPath)) {\n\t\tconst contents = (await fsProvider.readFile(Constants.UnixShellsPath)).toString();\n\t\tconst profiles = (\n\t\t\t(testPaths || contents.split('\\n'))\n\t\t\t\t.map(e => {\n\t\t\t\t\tconst index = e.indexOf('#');\n\t\t\t\t\treturn index === -1 ? e : e.substring(0, index);\n\t\t\t\t})\n\t\t\t\t.filter(e => e.trim().length > 0)\n\t\t);\n\t\tconst counts: Map<string, number> = new Map();\n\t\tfor (const profile of profiles) {\n\t\t\tlet profileName = basename(profile);\n\t\t\tlet count = counts.get(profileName) || 0;\n\t\t\tcount++;\n\t\t\tif (count > 1) {\n\t\t\t\tprofileName = `${profileName} (${count})`;\n\t\t\t}\n\t\t\tcounts.set(profileName, count);\n\t\t\tdetectedProfiles.set(profileName, { path: profile, isAutoDetected: true });\n\t\t}\n\t}\n\n\tapplyConfigProfilesToMap(configProfiles, detectedProfiles);\n\n\treturn await transformToTerminalProfiles(detectedProfiles.entries(), defaultProfileName, fsProvider, shellEnv, logService, variableResolver);\n}\n\nfunction applyConfigProfilesToMap(configProfiles: { [key: string]: IUnresolvedTerminalProfile } | undefined, profilesMap: Map<string, IUnresolvedTerminalProfile>) {\n\tif (!configProfiles) {\n\t\treturn;\n\t}\n\tfor (const [profileName, value] of Object.entries(configProfiles)) {\n\t\tif (value === null || typeof value !== 'object' || (!('path' in value) && !('source' in value))) {\n\t\t\tprofilesMap.delete(profileName);\n\t\t} else {\n\t\t\tvalue.icon = value.icon || profilesMap.get(profileName)?.icon;\n\t\t\tprofilesMap.set(profileName, value);\n\t\t}\n\t}\n}\n\nasync function validateProfilePaths(profileName: string, defaultProfileName: string | undefined, potentialPaths: (string | ITerminalUnsafePath)[], fsProvider: IFsProvider, shellEnv: typeof process.env, args?: string[] | string, env?: ITerminalEnvironment, overrideName?: boolean, isAutoDetected?: boolean, requiresUnsafePath?: string): Promise<ITerminalProfile | undefined> {\n\tif (potentialPaths.length === 0) {\n\t\treturn Promise.resolve(undefined);\n\t}\n\tconst path = potentialPaths.shift()!;\n\tif (path === '') {\n\t\treturn validateProfilePaths(profileName, defaultProfileName, potentialPaths, fsProvider, shellEnv, args, env, overrideName, isAutoDetected);\n\t}\n\tconst isUnsafePath = typeof path !== 'string' && path.isUnsafe;\n\tconst actualPath = typeof path === 'string' ? path : path.path;\n\n\tconst profile: ITerminalProfile = {\n\t\tprofileName,\n\t\tpath: actualPath,\n\t\targs,\n\t\tenv,\n\t\toverrideName,\n\t\tisAutoDetected,\n\t\tisDefault: profileName === defaultProfileName,\n\t\tisUnsafePath,\n\t\trequiresUnsafePath\n\t};\n\n\t// For non-absolute paths, check if it's available on $PATH\n\tif (basename(actualPath) === actualPath) {\n\t\t// The executable isn't an absolute path, try find it on the PATH\n\t\tconst envPaths: string[] | undefined = shellEnv.PATH ? shellEnv.PATH.split(delimiter) : undefined;\n\t\tconst executable = await findExecutable(actualPath, undefined, envPaths, undefined, fsProvider.existsFile);\n\t\tif (!executable) {\n\t\t\treturn validateProfilePaths(profileName, defaultProfileName, potentialPaths, fsProvider, shellEnv, args);\n\t\t}\n\t\tprofile.path = executable;\n\t\tprofile.isFromPath = true;\n\t\treturn profile;\n\t}\n\n\tconst result = await fsProvider.existsFile(normalize(actualPath));\n\tif (result) {\n\t\treturn profile;\n\t}\n\n\treturn validateProfilePaths(profileName, defaultProfileName, potentialPaths, fsProvider, shellEnv, args, env, overrideName, isAutoDetected);\n}\n\nexport interface IFsProvider {\n\texistsFile(path: string): Promise<boolean>;\n\treadFile(path: string): Promise<Buffer>;\n}\n\ninterface IPotentialTerminalProfile {\n\tprofileName: string;\n\tpaths: string[];\n\targs?: string[];\n\ticon?: ThemeIcon | URI | { light: URI; dark: URI };\n}\n\nexport type IUnresolvedTerminalProfile = ITerminalExecutable | ITerminalProfileSource | null;\n"],
  "mappings": "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",
  "names": ["Constants", "resolve"]
}
