{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/terminal/node/terminalProfiles.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as cp from \"child_process\";\nimport * as fs from \"fs\";\nimport { dirname, resolve } from \"path\";\nimport { Codicon } from \"../../../base/common/codicons.js\";\nimport { basename, delimiter, normalize } from \"../../../base/common/path.js\";\nimport { isLinux, isWindows } from \"../../../base/common/platform.js\";\nimport type { ThemeIcon } from \"../../../base/common/themables.js\";\nimport { isString } from \"../../../base/common/types.js\";\nimport type { URI } from \"../../../base/common/uri.js\";\nimport * as pfs from \"../../../base/node/pfs.js\";\nimport { enumeratePowerShellInstallations } from \"../../../base/node/powershell.js\";\nimport type { IConfigurationService } from \"../../configuration/common/configuration.js\";\nimport type { ILogService } from \"../../log/common/log.js\";\nimport {\n\ttype ITerminalEnvironment,\n\ttype ITerminalExecutable,\n\ttype ITerminalProfile,\n\ttype ITerminalProfileSource,\n\ttype ITerminalUnsafePath,\n\tProfileSource,\n\ttype TerminalIcon,\n\tTerminalSettingId,\n} from \"../common/terminal.js\";\nimport {\n\tfindExecutable,\n\tgetWindowsBuildNumber,\n} from \"./terminalEnvironment.js\";\n\nenum Constants {\n\tUnixShellsPath = \"/etc/shells\",\n}\n\nlet profileSources: Map<string, IPotentialTerminalProfile> | undefined;\nlet logIfWslNotInstalled = true;\n\nexport function detectAvailableProfiles(\n\tprofiles: unknown,\n\tdefaultProfile: unknown,\n\tincludeDetectedProfiles: boolean,\n\tconfigurationService: IConfigurationService,\n\tshellEnv: typeof process.env = process.env,\n\tfsProvider?: IFsProvider,\n\tlogService?: ILogService,\n\tvariableResolver?: (text: string[]) => Promise<string[]>,\n\ttestPwshSourcePaths?: string[],\n): Promise<ITerminalProfile[]> {\n\tfsProvider = fsProvider || {\n\t\texistsFile: pfs.SymlinkSupport.existsFile,\n\t\treadFile: fs.promises.readFile,\n\t};\n\tif (isWindows) {\n\t\treturn detectAvailableWindowsProfiles(\n\t\t\tincludeDetectedProfiles,\n\t\t\tfsProvider,\n\t\t\tshellEnv,\n\t\t\tlogService,\n\t\t\tconfigurationService.getValue(TerminalSettingId.UseWslProfiles) !==\n\t\t\t\tfalse,\n\t\t\tprofiles && typeof profiles === \"object\"\n\t\t\t\t? { ...profiles }\n\t\t\t\t: configurationService.getValue<{\n\t\t\t\t\t\t[key: string]: IUnresolvedTerminalProfile;\n\t\t\t\t\t}>(TerminalSettingId.ProfilesWindows),\n\t\t\ttypeof defaultProfile === \"string\"\n\t\t\t\t? defaultProfile\n\t\t\t\t: configurationService.getValue<string>(\n\t\t\t\t\t\tTerminalSettingId.DefaultProfileWindows,\n\t\t\t\t\t),\n\t\t\ttestPwshSourcePaths,\n\t\t\tvariableResolver,\n\t\t);\n\t}\n\treturn detectAvailableUnixProfiles(\n\t\tfsProvider,\n\t\tlogService,\n\t\tincludeDetectedProfiles,\n\t\tprofiles && typeof profiles === \"object\"\n\t\t\t? { ...profiles }\n\t\t\t: configurationService.getValue<{\n\t\t\t\t\t[key: string]: IUnresolvedTerminalProfile;\n\t\t\t\t}>(\n\t\t\t\t\tisLinux\n\t\t\t\t\t\t? TerminalSettingId.ProfilesLinux\n\t\t\t\t\t\t: TerminalSettingId.ProfilesMacOs,\n\t\t\t\t),\n\t\ttypeof defaultProfile === \"string\"\n\t\t\t? defaultProfile\n\t\t\t: configurationService.getValue<string>(\n\t\t\t\t\tisLinux\n\t\t\t\t\t\t? TerminalSettingId.DefaultProfileLinux\n\t\t\t\t\t\t: TerminalSettingId.DefaultProfileMacOs,\n\t\t\t\t),\n\t\ttestPwshSourcePaths,\n\t\tvariableResolver,\n\t\tshellEnv,\n\t);\n}\n\nasync function detectAvailableWindowsProfiles(\n\tincludeDetectedProfiles: boolean,\n\tfsProvider: IFsProvider,\n\tshellEnv: typeof process.env,\n\tlogService?: ILogService,\n\tuseWslProfiles?: boolean,\n\tconfigProfiles?: { [key: string]: IUnresolvedTerminalProfile },\n\tdefaultProfileName?: string,\n\ttestPwshSourcePaths?: string[],\n\tvariableResolver?: (text: string[]) => Promise<string[]>,\n): Promise<ITerminalProfile[]> {\n\t// Determine the correct System32 path. We want to point to Sysnative\n\t// when the 32-bit version of VS Code is running on a 64-bit machine.\n\t// The reason for this is because PowerShell's important PSReadline\n\t// module doesn't work if this is not the case. See #27915.\n\tconst is32ProcessOn64Windows = process.env.hasOwnProperty(\n\t\t\"PROCESSOR_ARCHITEW6432\",\n\t);\n\tconst system32Path = `${process.env[\"windir\"]}\\\\${is32ProcessOn64Windows ? \"Sysnative\" : \"System32\"}`;\n\n\tlet useWSLexe = false;\n\n\tif (getWindowsBuildNumber() >= 16299) {\n\t\tuseWSLexe = true;\n\t}\n\n\tawait initializeWindowsProfiles(testPwshSourcePaths);\n\n\tconst detectedProfiles: Map<string, IUnresolvedTerminalProfile> = new Map();\n\n\t// Add auto detected profiles\n\tif (includeDetectedProfiles) {\n\t\tdetectedProfiles.set(\"PowerShell\", {\n\t\t\tsource: ProfileSource.Pwsh,\n\t\t\ticon: Codicon.terminalPowershell,\n\t\t\tisAutoDetected: true,\n\t\t});\n\t\tdetectedProfiles.set(\"Windows PowerShell\", {\n\t\t\tpath: `${system32Path}\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe`,\n\t\t\ticon: Codicon.terminalPowershell,\n\t\t\tisAutoDetected: true,\n\t\t});\n\t\tdetectedProfiles.set(\"Git Bash\", {\n\t\t\tsource: ProfileSource.GitBash,\n\t\t\tisAutoDetected: true,\n\t\t});\n\t\tdetectedProfiles.set(\"Command Prompt\", {\n\t\t\tpath: `${system32Path}\\\\cmd.exe`,\n\t\t\ticon: Codicon.terminalCmd,\n\t\t\tisAutoDetected: true,\n\t\t});\n\t\tdetectedProfiles.set(\"Cygwin\", {\n\t\t\tpath: [\n\t\t\t\t{\n\t\t\t\t\tpath: `${process.env[\"HOMEDRIVE\"]}\\\\cygwin64\\\\bin\\\\bash.exe`,\n\t\t\t\t\tisUnsafe: true,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tpath: `${process.env[\"HOMEDRIVE\"]}\\\\cygwin\\\\bin\\\\bash.exe`,\n\t\t\t\t\tisUnsafe: true,\n\t\t\t\t},\n\t\t\t],\n\t\t\targs: [\"--login\"],\n\t\t\tisAutoDetected: true,\n\t\t});\n\t\tdetectedProfiles.set(\"bash (MSYS2)\", {\n\t\t\tpath: [\n\t\t\t\t{\n\t\t\t\t\tpath: `${process.env[\"HOMEDRIVE\"]}\\\\msys64\\\\usr\\\\bin\\\\bash.exe`,\n\t\t\t\t\tisUnsafe: true,\n\t\t\t\t},\n\t\t\t],\n\t\t\targs: [\"--login\", \"-i\"],\n\t\t\t// CHERE_INVOKING retains current working directory\n\t\t\tenv: { CHERE_INVOKING: \"1\" },\n\t\t\ticon: Codicon.terminalBash,\n\t\t\tisAutoDetected: true,\n\t\t});\n\t\tconst cmderPath = `${process.env[\"CMDER_ROOT\"] || `${process.env[\"HOMEDRIVE\"]}\\\\cmder`}\\\\vendor\\\\bin\\\\vscode_init.cmd`;\n\t\tdetectedProfiles.set(\"Cmder\", {\n\t\t\tpath: `${system32Path}\\\\cmd.exe`,\n\t\t\targs: [\"/K\", cmderPath],\n\t\t\t// The path is safe if it was derived from CMDER_ROOT\n\t\t\trequiresPath: process.env[\"CMDER_ROOT\"]\n\t\t\t\t? cmderPath\n\t\t\t\t: { path: cmderPath, isUnsafe: true },\n\t\t\tisAutoDetected: true,\n\t\t});\n\t}\n\n\tapplyConfigProfilesToMap(configProfiles, detectedProfiles);\n\n\tconst resultProfiles: ITerminalProfile[] =\n\t\tawait transformToTerminalProfiles(\n\t\t\tdetectedProfiles.entries(),\n\t\t\tdefaultProfileName,\n\t\t\tfsProvider,\n\t\t\tshellEnv,\n\t\t\tlogService,\n\t\t\tvariableResolver,\n\t\t);\n\n\tif (includeDetectedProfiles && useWslProfiles) {\n\t\ttry {\n\t\t\tconst result = await getWslProfiles(\n\t\t\t\t`${system32Path}\\\\${useWSLexe ? \"wsl\" : \"bash\"}.exe`,\n\t\t\t\tdefaultProfileName,\n\t\t\t);\n\t\t\tfor (const wslProfile of result) {\n\t\t\t\tif (\n\t\t\t\t\t!configProfiles ||\n\t\t\t\t\t!(wslProfile.profileName in configProfiles)\n\t\t\t\t) {\n\t\t\t\t\tresultProfiles.push(wslProfile);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tif (logIfWslNotInstalled) {\n\t\t\t\tlogService?.trace(\n\t\t\t\t\t\"WSL is not installed, so could not detect WSL profiles\",\n\t\t\t\t);\n\t\t\t\tlogIfWslNotInstalled = false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn resultProfiles;\n}\n\nasync function transformToTerminalProfiles(\n\tentries: IterableIterator<[string, IUnresolvedTerminalProfile]>,\n\tdefaultProfileName: string | undefined,\n\tfsProvider: IFsProvider,\n\tshellEnv: typeof process.env = process.env,\n\tlogService?: ILogService,\n\tvariableResolver?: (text: string[]) => Promise<string[]>,\n): Promise<ITerminalProfile[]> {\n\tconst promises: Promise<ITerminalProfile | undefined>[] = [];\n\tfor (const [profileName, profile] of entries) {\n\t\tpromises.push(\n\t\t\tgetValidatedProfile(\n\t\t\t\tprofileName,\n\t\t\t\tprofile,\n\t\t\t\tdefaultProfileName,\n\t\t\t\tfsProvider,\n\t\t\t\tshellEnv,\n\t\t\t\tlogService,\n\t\t\t\tvariableResolver,\n\t\t\t),\n\t\t);\n\t}\n\treturn (await Promise.all(promises)).filter(\n\t\t(e) => !!e,\n\t) as ITerminalProfile[];\n}\n\nasync function getValidatedProfile(\n\tprofileName: string,\n\tprofile: IUnresolvedTerminalProfile,\n\tdefaultProfileName: string | undefined,\n\tfsProvider: IFsProvider,\n\tshellEnv: typeof process.env = process.env,\n\tlogService?: ILogService,\n\tvariableResolver?: (text: string[]) => Promise<string[]>,\n): Promise<ITerminalProfile | undefined> {\n\tif (profile === null) {\n\t\treturn undefined;\n\t}\n\tlet originalPaths: (string | ITerminalUnsafePath)[];\n\tlet args: string[] | string | undefined;\n\tlet icon: ThemeIcon | URI | { light: URI; dark: URI } | undefined;\n\t// use calculated values if path is not specified\n\tif (\"source\" in profile && !(\"path\" in profile)) {\n\t\tconst source = profileSources?.get(profile.source);\n\t\tif (!source) {\n\t\t\treturn undefined;\n\t\t}\n\t\toriginalPaths = source.paths;\n\n\t\t// if there are configured args, override the default ones\n\t\targs = profile.args || source.args;\n\t\tif (profile.icon) {\n\t\t\ticon = validateIcon(profile.icon);\n\t\t} else if (source.icon) {\n\t\t\ticon = source.icon;\n\t\t}\n\t} else {\n\t\toriginalPaths = Array.isArray(profile.path)\n\t\t\t? profile.path\n\t\t\t: [profile.path];\n\t\targs = isWindows\n\t\t\t? profile.args\n\t\t\t: Array.isArray(profile.args)\n\t\t\t\t? profile.args\n\t\t\t\t: undefined;\n\t\ticon = validateIcon(profile.icon);\n\t}\n\n\tlet paths: (string | ITerminalUnsafePath)[];\n\tif (variableResolver) {\n\t\t// Convert to string[] for resolve\n\t\tconst mapped = originalPaths.map((e) =>\n\t\t\ttypeof e === \"string\" ? e : e.path,\n\t\t);\n\n\t\tconst resolved = await variableResolver(mapped);\n\t\t// Convert resolved back to (T | string)[]\n\t\tpaths = new Array(originalPaths.length);\n\t\tfor (let i = 0; i < originalPaths.length; i++) {\n\t\t\tif (typeof originalPaths[i] === \"string\") {\n\t\t\t\tpaths[i] = resolved[i];\n\t\t\t} else {\n\t\t\t\tpaths[i] = {\n\t\t\t\t\tpath: resolved[i],\n\t\t\t\t\tisUnsafe: true,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t} else {\n\t\tpaths = originalPaths.slice();\n\t}\n\n\tlet requiresUnsafePath: string | undefined;\n\tif (profile.requiresPath) {\n\t\t// Validate requiresPath exists\n\t\tlet actualRequiredPath: string;\n\t\tif (isString(profile.requiresPath)) {\n\t\t\tactualRequiredPath = profile.requiresPath;\n\t\t} else {\n\t\t\tactualRequiredPath = profile.requiresPath.path;\n\t\t\tif (profile.requiresPath.isUnsafe) {\n\t\t\t\trequiresUnsafePath = actualRequiredPath;\n\t\t\t}\n\t\t}\n\t\tconst result = await fsProvider.existsFile(actualRequiredPath);\n\t\tif (!result) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tconst validatedProfile = await validateProfilePaths(\n\t\tprofileName,\n\t\tdefaultProfileName,\n\t\tpaths,\n\t\tfsProvider,\n\t\tshellEnv,\n\t\targs,\n\t\tprofile.env,\n\t\tprofile.overrideName,\n\t\tprofile.isAutoDetected,\n\t\trequiresUnsafePath,\n\t);\n\tif (!validatedProfile) {\n\t\tlogService?.debug(\n\t\t\t\"Terminal profile not validated\",\n\t\t\tprofileName,\n\t\t\toriginalPaths,\n\t\t);\n\t\treturn undefined;\n\t}\n\n\tvalidatedProfile.isAutoDetected = profile.isAutoDetected;\n\tvalidatedProfile.icon = icon;\n\tvalidatedProfile.color = profile.color;\n\treturn validatedProfile;\n}\n\nfunction validateIcon(\n\ticon: string | TerminalIcon | undefined,\n): TerminalIcon | undefined {\n\tif (typeof icon === \"string\") {\n\t\treturn { id: icon };\n\t}\n\treturn icon;\n}\n\nasync function initializeWindowsProfiles(\n\ttestPwshSourcePaths?: string[],\n): Promise<void> {\n\tif (profileSources && !testPwshSourcePaths) {\n\t\treturn;\n\t}\n\n\tconst [gitBashPaths, pwshPaths] = await Promise.all([\n\t\tgetGitBashPaths(),\n\t\ttestPwshSourcePaths || getPowershellPaths(),\n\t]);\n\n\tprofileSources = new Map();\n\tprofileSources.set(ProfileSource.GitBash, {\n\t\tprofileName: \"Git Bash\",\n\t\tpaths: gitBashPaths,\n\t\targs: [\"--login\", \"-i\"],\n\t});\n\tprofileSources.set(ProfileSource.Pwsh, {\n\t\tprofileName: \"PowerShell\",\n\t\tpaths: pwshPaths,\n\t\ticon: Codicon.terminalPowershell,\n\t});\n}\n\nasync function getGitBashPaths(): Promise<string[]> {\n\tconst gitDirs: Set<string> = new Set();\n\n\t// Look for git.exe on the PATH and use that if found. git.exe is located at\n\t// `<installdir>/cmd/git.exe`. This is not an unsafe location because the git executable is\n\t// located on the PATH which is only controlled by the user/admin.\n\tconst gitExePath = await findExecutable(\"git.exe\");\n\tif (gitExePath) {\n\t\tconst gitExeDir = dirname(gitExePath);\n\t\tgitDirs.add(resolve(gitExeDir, \"../..\"));\n\t}\n\tfunction addTruthy<T>(set: Set<T>, value: T | undefined): void {\n\t\tif (value) {\n\t\t\tset.add(value);\n\t\t}\n\t}\n\n\t// Add common git install locations\n\taddTruthy(gitDirs, process.env[\"ProgramW6432\"]);\n\taddTruthy(gitDirs, process.env[\"ProgramFiles\"]);\n\taddTruthy(gitDirs, process.env[\"ProgramFiles(X86)\"]);\n\taddTruthy(gitDirs, `${process.env[\"LocalAppData\"]}\\\\Program`);\n\n\tconst gitBashPaths: string[] = [];\n\tfor (const gitDir of gitDirs) {\n\t\tgitBashPaths.push(\n\t\t\t`${gitDir}\\\\Git\\\\bin\\\\bash.exe`,\n\t\t\t`${gitDir}\\\\Git\\\\usr\\\\bin\\\\bash.exe`,\n\t\t\t`${gitDir}\\\\usr\\\\bin\\\\bash.exe`, // using Git for Windows SDK\n\t\t);\n\t}\n\n\t// Add special installs that don't follow the standard directory structure\n\tgitBashPaths.push(\n\t\t`${process.env[\"UserProfile\"]}\\\\scoop\\\\apps\\\\git\\\\current\\\\bin\\\\bash.exe`,\n\t);\n\tgitBashPaths.push(\n\t\t`${process.env[\"UserProfile\"]}\\\\scoop\\\\apps\\\\git-with-openssh\\\\current\\\\bin\\\\bash.exe`,\n\t);\n\n\treturn gitBashPaths;\n}\n\nasync function getPowershellPaths(): Promise<string[]> {\n\tconst paths: string[] = [];\n\t// Add all of the different kinds of PowerShells\n\tfor await (const pwshExe of enumeratePowerShellInstallations()) {\n\t\tpaths.push(pwshExe.exePath);\n\t}\n\treturn paths;\n}\n\nasync function getWslProfiles(\n\twslPath: string,\n\tdefaultProfileName: string | undefined,\n): Promise<ITerminalProfile[]> {\n\tconst profiles: ITerminalProfile[] = [];\n\tconst distroOutput = await new Promise<string>((resolve, reject) => {\n\t\t// wsl.exe output is encoded in utf16le (ie. A -> 0x4100)\n\t\tcp.exec(\n\t\t\t\"wsl.exe -l -q\",\n\t\t\t{ encoding: \"utf16le\", timeout: 1000 },\n\t\t\t(err, stdout) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn reject(\"Problem occurred when getting wsl distros\");\n\t\t\t\t}\n\t\t\t\tresolve(stdout);\n\t\t\t},\n\t\t);\n\t});\n\tif (!distroOutput) {\n\t\treturn [];\n\t}\n\tconst regex = new RegExp(/[\\r?\\n]/);\n\tconst distroNames = distroOutput\n\t\t.split(regex)\n\t\t.filter((t) => t.trim().length > 0 && t !== \"\");\n\tfor (const distroName of distroNames) {\n\t\t// Skip empty lines\n\t\tif (distroName === \"\") {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// docker-desktop and docker-desktop-data are treated as implementation details of\n\t\t// Docker Desktop for Windows and therefore not exposed\n\t\tif (distroName.startsWith(\"docker-desktop\")) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Create the profile, adding the icon depending on the distro\n\t\tconst profileName = `${distroName} (WSL)`;\n\t\tconst profile: ITerminalProfile = {\n\t\t\tprofileName,\n\t\t\tpath: wslPath,\n\t\t\targs: [`-d`, `${distroName}`],\n\t\t\tisDefault: profileName === defaultProfileName,\n\t\t\ticon: getWslIcon(distroName),\n\t\t\tisAutoDetected: false,\n\t\t};\n\t\t// Add the profile\n\t\tprofiles.push(profile);\n\t}\n\treturn profiles;\n}\n\nfunction getWslIcon(distroName: string): ThemeIcon {\n\tif (distroName.includes(\"Ubuntu\")) {\n\t\treturn Codicon.terminalUbuntu;\n\t} else if (distroName.includes(\"Debian\")) {\n\t\treturn Codicon.terminalDebian;\n\t} else {\n\t\treturn Codicon.terminalLinux;\n\t}\n}\n\nasync function detectAvailableUnixProfiles(\n\tfsProvider: IFsProvider,\n\tlogService?: ILogService,\n\tincludeDetectedProfiles?: boolean,\n\tconfigProfiles?: { [key: string]: IUnresolvedTerminalProfile },\n\tdefaultProfileName?: string,\n\ttestPaths?: string[],\n\tvariableResolver?: (text: string[]) => Promise<string[]>,\n\tshellEnv?: typeof process.env,\n): Promise<ITerminalProfile[]> {\n\tconst detectedProfiles: Map<string, IUnresolvedTerminalProfile> = new Map();\n\n\t// Add non-quick launch profiles\n\tif (\n\t\tincludeDetectedProfiles &&\n\t\t(await fsProvider.existsFile(Constants.UnixShellsPath))\n\t) {\n\t\tconst contents = (\n\t\t\tawait fsProvider.readFile(Constants.UnixShellsPath)\n\t\t).toString();\n\t\tconst profiles = (testPaths || contents.split(\"\\n\"))\n\t\t\t.map((e) => {\n\t\t\t\tconst index = e.indexOf(\"#\");\n\t\t\t\treturn index === -1 ? e : e.substring(0, index);\n\t\t\t})\n\t\t\t.filter((e) => e.trim().length > 0);\n\t\tconst counts: Map<string, number> = new Map();\n\t\tfor (const profile of profiles) {\n\t\t\tlet profileName = basename(profile);\n\t\t\tlet count = counts.get(profileName) || 0;\n\t\t\tcount++;\n\t\t\tif (count > 1) {\n\t\t\t\tprofileName = `${profileName} (${count})`;\n\t\t\t}\n\t\t\tcounts.set(profileName, count);\n\t\t\tdetectedProfiles.set(profileName, {\n\t\t\t\tpath: profile,\n\t\t\t\tisAutoDetected: true,\n\t\t\t});\n\t\t}\n\t}\n\n\tapplyConfigProfilesToMap(configProfiles, detectedProfiles);\n\n\treturn await transformToTerminalProfiles(\n\t\tdetectedProfiles.entries(),\n\t\tdefaultProfileName,\n\t\tfsProvider,\n\t\tshellEnv,\n\t\tlogService,\n\t\tvariableResolver,\n\t);\n}\n\nfunction applyConfigProfilesToMap(\n\tconfigProfiles: { [key: string]: IUnresolvedTerminalProfile } | undefined,\n\tprofilesMap: Map<string, IUnresolvedTerminalProfile>,\n) {\n\tif (!configProfiles) {\n\t\treturn;\n\t}\n\tfor (const [profileName, value] of Object.entries(configProfiles)) {\n\t\tif (\n\t\t\tvalue === null ||\n\t\t\ttypeof value !== \"object\" ||\n\t\t\t(!(\"path\" in value) && !(\"source\" in value))\n\t\t) {\n\t\t\tprofilesMap.delete(profileName);\n\t\t} else {\n\t\t\tvalue.icon = value.icon || profilesMap.get(profileName)?.icon;\n\t\t\tprofilesMap.set(profileName, value);\n\t\t}\n\t}\n}\n\nasync function validateProfilePaths(\n\tprofileName: string,\n\tdefaultProfileName: string | undefined,\n\tpotentialPaths: (string | ITerminalUnsafePath)[],\n\tfsProvider: IFsProvider,\n\tshellEnv: typeof process.env,\n\targs?: string[] | string,\n\tenv?: ITerminalEnvironment,\n\toverrideName?: boolean,\n\tisAutoDetected?: boolean,\n\trequiresUnsafePath?: string,\n): Promise<ITerminalProfile | undefined> {\n\tif (potentialPaths.length === 0) {\n\t\treturn Promise.resolve(undefined);\n\t}\n\tconst path = potentialPaths.shift()!;\n\tif (path === \"\") {\n\t\treturn validateProfilePaths(\n\t\t\tprofileName,\n\t\t\tdefaultProfileName,\n\t\t\tpotentialPaths,\n\t\t\tfsProvider,\n\t\t\tshellEnv,\n\t\t\targs,\n\t\t\tenv,\n\t\t\toverrideName,\n\t\t\tisAutoDetected,\n\t\t);\n\t}\n\tconst isUnsafePath = typeof path !== \"string\" && path.isUnsafe;\n\tconst actualPath = typeof path === \"string\" ? path : path.path;\n\n\tconst profile: ITerminalProfile = {\n\t\tprofileName,\n\t\tpath: actualPath,\n\t\targs,\n\t\tenv,\n\t\toverrideName,\n\t\tisAutoDetected,\n\t\tisDefault: profileName === defaultProfileName,\n\t\tisUnsafePath,\n\t\trequiresUnsafePath,\n\t};\n\n\t// For non-absolute paths, check if it's available on $PATH\n\tif (basename(actualPath) === actualPath) {\n\t\t// The executable isn't an absolute path, try find it on the PATH\n\t\tconst envPaths: string[] | undefined = shellEnv.PATH\n\t\t\t? shellEnv.PATH.split(delimiter)\n\t\t\t: undefined;\n\t\tconst executable = await findExecutable(\n\t\t\tactualPath,\n\t\t\tundefined,\n\t\t\tenvPaths,\n\t\t\tundefined,\n\t\t\tfsProvider.existsFile,\n\t\t);\n\t\tif (!executable) {\n\t\t\treturn validateProfilePaths(\n\t\t\t\tprofileName,\n\t\t\t\tdefaultProfileName,\n\t\t\t\tpotentialPaths,\n\t\t\t\tfsProvider,\n\t\t\t\tshellEnv,\n\t\t\t\targs,\n\t\t\t);\n\t\t}\n\t\tprofile.path = executable;\n\t\tprofile.isFromPath = true;\n\t\treturn profile;\n\t}\n\n\tconst result = await fsProvider.existsFile(normalize(actualPath));\n\tif (result) {\n\t\treturn profile;\n\t}\n\n\treturn validateProfilePaths(\n\t\tprofileName,\n\t\tdefaultProfileName,\n\t\tpotentialPaths,\n\t\tfsProvider,\n\t\tshellEnv,\n\t\targs,\n\t\tenv,\n\t\toverrideName,\n\t\tisAutoDetected,\n\t);\n}\n\nexport interface IFsProvider {\n\texistsFile(path: string): Promise<boolean>;\n\treadFile(path: string): Promise<Buffer>;\n}\n\ninterface IPotentialTerminalProfile {\n\tprofileName: string;\n\tpaths: string[];\n\targs?: string[];\n\ticon?: ThemeIcon | URI | { light: URI; dark: URI };\n}\n\nexport type IUnresolvedTerminalProfile =\n\t| ITerminalExecutable\n\t| ITerminalProfileSource\n\t| null;\n"],
  "mappings": "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",
  "names": ["Constants", "resolve"]
}
