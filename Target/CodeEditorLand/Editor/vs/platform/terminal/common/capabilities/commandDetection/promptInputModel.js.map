{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/terminal/common/capabilities/commandDetection/promptInputModel.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { throttle } from \"../../../../../base/common/decorators.js\";\nimport { Emitter, Event } from \"../../../../../base/common/event.js\";\nimport { Disposable } from \"../../../../../base/common/lifecycle.js\";\nimport { ILogService, LogLevel } from \"../../../../log/common/log.js\";\nimport type { ITerminalCommand } from \"../capabilities.js\";\n\nimport type {\n\tIBuffer,\n\tIBufferCell,\n\tIBufferLine,\n\tIMarker,\n\tTerminal,\n} from \"@xterm/headless\";\n\nenum PromptInputState {\n\tUnknown = 0,\n\tInput = 1,\n\tExecute = 2,\n}\n\n/**\n * A model of the prompt input state using shell integration and analyzing the terminal buffer. This\n * may not be 100% accurate but provides a best guess.\n */\nexport interface IPromptInputModel extends IPromptInputModelState {\n\treadonly onDidStartInput: Event<IPromptInputModelState>;\n\treadonly onDidChangeInput: Event<IPromptInputModelState>;\n\treadonly onDidFinishInput: Event<IPromptInputModelState>;\n\t/**\n\t * Fires immediately before {@link onDidFinishInput} when a SIGINT/Ctrl+C/^C is detected.\n\t */\n\treadonly onDidInterrupt: Event<IPromptInputModelState>;\n\n\t/**\n\t * Gets the prompt input as a user-friendly string where `|` is the cursor position and `[` and\n\t * `]` wrap any ghost text.\n\t */\n\tgetCombinedString(): string;\n}\n\nexport interface IPromptInputModelState {\n\t/**\n\t * The full prompt input include ghost text.\n\t */\n\treadonly value: string;\n\t/**\n\t * The prompt input up to the cursor index, this will always exclude the ghost text.\n\t */\n\treadonly prefix: string;\n\t/**\n\t * The prompt input from the cursor to the end, this _does not_ include ghost text.\n\t */\n\treadonly suffix: string;\n\t/**\n\t * The index of the cursor in {@link value}.\n\t */\n\treadonly cursorIndex: number;\n\t/**\n\t * The index of the start of ghost text in {@link value}. This is -1 when there is no ghost\n\t * text.\n\t */\n\treadonly ghostTextIndex: number;\n}\n\nexport interface ISerializedPromptInputModel {\n\treadonly modelState: IPromptInputModelState;\n\treadonly commandStartX: number;\n\treadonly lastPromptLine: string | undefined;\n\treadonly continuationPrompt: string | undefined;\n\treadonly lastUserInput: string;\n}\n\nexport class PromptInputModel extends Disposable implements IPromptInputModel {\n\tprivate _state: PromptInputState = PromptInputState.Unknown;\n\n\tprivate _commandStartMarker: IMarker | undefined;\n\tprivate _commandStartX = 0;\n\tprivate _lastPromptLine: string | undefined;\n\tprivate _continuationPrompt: string | undefined;\n\n\tprivate _lastUserInput = \"\";\n\n\tprivate _value = \"\";\n\tget value() {\n\t\treturn this._value;\n\t}\n\tget prefix() {\n\t\treturn this._value.substring(0, this._cursorIndex);\n\t}\n\tget suffix() {\n\t\treturn this._value.substring(\n\t\t\tthis._cursorIndex,\n\t\t\tthis._ghostTextIndex === -1 ? undefined : this._ghostTextIndex,\n\t\t);\n\t}\n\n\tprivate _cursorIndex = 0;\n\tget cursorIndex() {\n\t\treturn this._cursorIndex;\n\t}\n\n\tprivate _ghostTextIndex = -1;\n\tget ghostTextIndex() {\n\t\treturn this._ghostTextIndex;\n\t}\n\n\tprivate readonly _onDidStartInput = this._register(\n\t\tnew Emitter<IPromptInputModelState>(),\n\t);\n\treadonly onDidStartInput = this._onDidStartInput.event;\n\tprivate readonly _onDidChangeInput = this._register(\n\t\tnew Emitter<IPromptInputModelState>(),\n\t);\n\treadonly onDidChangeInput = this._onDidChangeInput.event;\n\tprivate readonly _onDidFinishInput = this._register(\n\t\tnew Emitter<IPromptInputModelState>(),\n\t);\n\treadonly onDidFinishInput = this._onDidFinishInput.event;\n\tprivate readonly _onDidInterrupt = this._register(\n\t\tnew Emitter<IPromptInputModelState>(),\n\t);\n\treadonly onDidInterrupt = this._onDidInterrupt.event;\n\n\tconstructor(\n\t\tprivate readonly _xterm: Terminal,\n\t\tonCommandStart: Event<ITerminalCommand>,\n\t\tonCommandExecuted: Event<ITerminalCommand>,\n\t\t@ILogService private readonly _logService: ILogService,\n\t) {\n\t\tsuper();\n\n\t\tthis._register(\n\t\t\tEvent.any(\n\t\t\t\tthis._xterm.onCursorMove,\n\t\t\t\tthis._xterm.onData,\n\t\t\t\tthis._xterm.onWriteParsed,\n\t\t\t)(() => this._sync()),\n\t\t);\n\t\tthis._register(this._xterm.onData((e) => this._handleUserInput(e)));\n\n\t\tthis._register(\n\t\t\tonCommandStart((e) =>\n\t\t\t\tthis._handleCommandStart(e as { marker: IMarker }),\n\t\t\t),\n\t\t);\n\t\tthis._register(onCommandExecuted(() => this._handleCommandExecuted()));\n\n\t\tthis._register(\n\t\t\tthis.onDidStartInput(() =>\n\t\t\t\tthis._logCombinedStringIfTrace(\n\t\t\t\t\t\"PromptInputModel#onDidStartInput\",\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\t\tthis._register(\n\t\t\tthis.onDidChangeInput(() =>\n\t\t\t\tthis._logCombinedStringIfTrace(\n\t\t\t\t\t\"PromptInputModel#onDidChangeInput\",\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\t\tthis._register(\n\t\t\tthis.onDidFinishInput(() =>\n\t\t\t\tthis._logCombinedStringIfTrace(\n\t\t\t\t\t\"PromptInputModel#onDidFinishInput\",\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\t\tthis._register(\n\t\t\tthis.onDidInterrupt(() =>\n\t\t\t\tthis._logCombinedStringIfTrace(\n\t\t\t\t\t\"PromptInputModel#onDidInterrupt\",\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\t}\n\n\tprivate _logCombinedStringIfTrace(message: string) {\n\t\t// Only generate the combined string if trace\n\t\tif (this._logService.getLevel() === LogLevel.Trace) {\n\t\t\tthis._logService.trace(message, this.getCombinedString());\n\t\t}\n\t}\n\n\tsetContinuationPrompt(value: string): void {\n\t\tthis._continuationPrompt = value;\n\t\tthis._sync();\n\t}\n\n\tsetLastPromptLine(value: string): void {\n\t\tthis._lastPromptLine = value;\n\t\tthis._sync();\n\t}\n\n\tsetConfidentCommandLine(value: string): void {\n\t\tif (this._value !== value) {\n\t\t\tthis._value = value;\n\t\t\tthis._cursorIndex = -1;\n\t\t\tthis._ghostTextIndex = -1;\n\t\t\tthis._onDidChangeInput.fire(this._createStateObject());\n\t\t}\n\t}\n\n\tgetCombinedString(): string {\n\t\tconst value = this._value.replaceAll(\"\\n\", \"\\u23CE\");\n\t\tif (this._cursorIndex === -1) {\n\t\t\treturn value;\n\t\t}\n\t\tlet result = `${value.substring(0, this.cursorIndex)}|`;\n\t\tif (this.ghostTextIndex !== -1) {\n\t\t\tresult += `${value.substring(this.cursorIndex, this.ghostTextIndex)}[`;\n\t\t\tresult += `${value.substring(this.ghostTextIndex)}]`;\n\t\t} else {\n\t\t\tresult += value.substring(this.cursorIndex);\n\t\t}\n\t\treturn result;\n\t}\n\n\tserialize(): ISerializedPromptInputModel {\n\t\treturn {\n\t\t\tmodelState: this._createStateObject(),\n\t\t\tcommandStartX: this._commandStartX,\n\t\t\tlastPromptLine: this._lastPromptLine,\n\t\t\tcontinuationPrompt: this._continuationPrompt,\n\t\t\tlastUserInput: this._lastUserInput,\n\t\t};\n\t}\n\n\tdeserialize(serialized: ISerializedPromptInputModel): void {\n\t\tthis._value = serialized.modelState.value;\n\t\tthis._cursorIndex = serialized.modelState.cursorIndex;\n\t\tthis._ghostTextIndex = serialized.modelState.ghostTextIndex;\n\t\tthis._commandStartX = serialized.commandStartX;\n\t\tthis._lastPromptLine = serialized.lastPromptLine;\n\t\tthis._continuationPrompt = serialized.continuationPrompt;\n\t\tthis._lastUserInput = serialized.lastUserInput;\n\t}\n\n\tprivate _handleCommandStart(command: { marker: IMarker }) {\n\t\tif (this._state === PromptInputState.Input) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._state = PromptInputState.Input;\n\t\tthis._commandStartMarker = command.marker;\n\t\tthis._commandStartX = this._xterm.buffer.active.cursorX;\n\t\tthis._value = \"\";\n\t\tthis._cursorIndex = 0;\n\t\tthis._onDidStartInput.fire(this._createStateObject());\n\t\tthis._onDidChangeInput.fire(this._createStateObject());\n\n\t\t// Trigger a sync if prompt terminator is set as that could adjust the command start X\n\t\tif (this._lastPromptLine) {\n\t\t\tif (this._commandStartX !== this._lastPromptLine.length) {\n\t\t\t\tconst line = this._xterm.buffer.active.getLine(\n\t\t\t\t\tthis._commandStartMarker.line,\n\t\t\t\t);\n\t\t\t\tif (\n\t\t\t\t\tline\n\t\t\t\t\t\t?.translateToString(true)\n\t\t\t\t\t\t.startsWith(this._lastPromptLine)\n\t\t\t\t) {\n\t\t\t\t\tthis._commandStartX = this._lastPromptLine.length;\n\t\t\t\t\tthis._sync();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _handleCommandExecuted() {\n\t\tif (this._state === PromptInputState.Execute) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._cursorIndex = -1;\n\n\t\t// Remove any ghost text from the input if it exists on execute\n\t\tif (this._ghostTextIndex !== -1) {\n\t\t\tthis._value = this._value.substring(0, this._ghostTextIndex);\n\t\t\tthis._ghostTextIndex = -1;\n\t\t}\n\n\t\tconst event = this._createStateObject();\n\t\tif (this._lastUserInput === \"\\u0003\") {\n\t\t\tthis._lastUserInput = \"\";\n\t\t\tthis._onDidInterrupt.fire(event);\n\t\t}\n\n\t\tthis._state = PromptInputState.Execute;\n\t\tthis._onDidFinishInput.fire(event);\n\t\tthis._onDidChangeInput.fire(event);\n\t}\n\n\t@throttle(0)\n\tprivate _sync() {\n\t\ttry {\n\t\t\tthis._doSync();\n\t\t} catch (e) {\n\t\t\tthis._logService.error(\"Error while syncing prompt input model\", e);\n\t\t}\n\t}\n\n\tprivate _doSync() {\n\t\tif (this._state !== PromptInputState.Input) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst commandStartY = this._commandStartMarker?.line;\n\t\tif (commandStartY === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst buffer = this._xterm.buffer.active;\n\t\tlet line = buffer.getLine(commandStartY);\n\t\tconst commandLine = line?.translateToString(true, this._commandStartX);\n\t\tif (!line || commandLine === undefined) {\n\t\t\tthis._logService.trace(`PromptInputModel#_sync: no line`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst absoluteCursorY = buffer.baseY + buffer.cursorY;\n\t\tlet value = commandLine;\n\t\tlet ghostTextIndex = -1;\n\t\tlet cursorIndex: number;\n\t\tif (absoluteCursorY === commandStartY) {\n\t\t\tcursorIndex = this._getRelativeCursorIndex(\n\t\t\t\tthis._commandStartX,\n\t\t\t\tbuffer,\n\t\t\t\tline,\n\t\t\t);\n\t\t} else {\n\t\t\tcursorIndex = commandLine.trimEnd().length;\n\t\t}\n\n\t\t// Detect ghost text by looking for italic or dim text in or after the cursor and\n\t\t// non-italic/dim text in the cell closest non-whitespace cell before the cursor\n\t\tif (absoluteCursorY === commandStartY && buffer.cursorX > 1) {\n\t\t\t// Ghost text in pwsh only appears to happen on the cursor line\n\t\t\tghostTextIndex = this._scanForGhostText(buffer, line, cursorIndex);\n\t\t}\n\n\t\t// From command start line to cursor line\n\t\tfor (let y = commandStartY + 1; y <= absoluteCursorY; y++) {\n\t\t\tline = buffer.getLine(y);\n\t\t\tconst lineText = line?.translateToString(true);\n\t\t\tif (lineText && line) {\n\t\t\t\t// Check if the line wrapped without a new line (continuation)\n\t\t\t\tif (line.isWrapped) {\n\t\t\t\t\tvalue += lineText;\n\t\t\t\t\tconst relativeCursorIndex = this._getRelativeCursorIndex(\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tbuffer,\n\t\t\t\t\t\tline,\n\t\t\t\t\t);\n\t\t\t\t\tif (absoluteCursorY === y) {\n\t\t\t\t\t\tcursorIndex += relativeCursorIndex;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcursorIndex += lineText.length;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Verify continuation prompt if we have it, if this line doesn't have it then the\n\t\t\t\t// user likely just pressed enter.\n\t\t\t\telse if (\n\t\t\t\t\tthis._continuationPrompt === undefined ||\n\t\t\t\t\tthis._lineContainsContinuationPrompt(lineText)\n\t\t\t\t) {\n\t\t\t\t\tconst trimmedLineText =\n\t\t\t\t\t\tthis._trimContinuationPrompt(lineText);\n\t\t\t\t\tvalue += `\\n${trimmedLineText}`;\n\t\t\t\t\tif (absoluteCursorY === y) {\n\t\t\t\t\t\tconst continuationCellWidth =\n\t\t\t\t\t\t\tthis._getContinuationPromptCellWidth(\n\t\t\t\t\t\t\t\tline,\n\t\t\t\t\t\t\t\tlineText,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\tconst relativeCursorIndex =\n\t\t\t\t\t\t\tthis._getRelativeCursorIndex(\n\t\t\t\t\t\t\t\tcontinuationCellWidth,\n\t\t\t\t\t\t\t\tbuffer,\n\t\t\t\t\t\t\t\tline,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\tcursorIndex += relativeCursorIndex + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcursorIndex += trimmedLineText.length + 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Below cursor line\n\t\tfor (\n\t\t\tlet y = absoluteCursorY + 1;\n\t\t\ty < buffer.baseY + this._xterm.rows;\n\t\t\ty++\n\t\t) {\n\t\t\tline = buffer.getLine(y);\n\t\t\tconst lineText = line?.translateToString(true);\n\t\t\tif (lineText && line) {\n\t\t\t\tif (\n\t\t\t\t\tthis._continuationPrompt === undefined ||\n\t\t\t\t\tthis._lineContainsContinuationPrompt(lineText)\n\t\t\t\t) {\n\t\t\t\t\tvalue += `\\n${this._trimContinuationPrompt(lineText)}`;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (this._logService.getLevel() === LogLevel.Trace) {\n\t\t\tthis._logService.trace(\n\t\t\t\t`PromptInputModel#_sync: ${this.getCombinedString()}`,\n\t\t\t);\n\t\t}\n\n\t\t// Adjust trailing whitespace\n\t\t{\n\t\t\tlet trailingWhitespace =\n\t\t\t\tthis._value.length - this._value.trimEnd().length;\n\n\t\t\t// Handle backspace key\n\t\t\tif (this._lastUserInput === \"\\x7F\") {\n\t\t\t\tthis._lastUserInput = \"\";\n\t\t\t\tif (cursorIndex === this._cursorIndex - 1) {\n\t\t\t\t\t// If trailing whitespace is being increased by removing a non-whitespace character\n\t\t\t\t\tif (\n\t\t\t\t\t\tthis._value.trimEnd().length > value.trimEnd().length &&\n\t\t\t\t\t\tvalue.trimEnd().length <= cursorIndex\n\t\t\t\t\t) {\n\t\t\t\t\t\ttrailingWhitespace = Math.max(\n\t\t\t\t\t\t\tthis._value.length - 1 - value.trimEnd().length,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\t// Standard case; subtract from trailing whitespace\n\t\t\t\t\telse {\n\t\t\t\t\t\ttrailingWhitespace = Math.max(\n\t\t\t\t\t\t\ttrailingWhitespace - 1,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Handle delete key\n\t\t\tif (this._lastUserInput === \"\\x1b[3~\") {\n\t\t\t\tthis._lastUserInput = \"\";\n\t\t\t\tif (cursorIndex === this._cursorIndex) {\n\t\t\t\t\ttrailingWhitespace = Math.max(trailingWhitespace - 1, 0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst valueLines = value.split(\"\\n\");\n\t\t\tconst isMultiLine = valueLines.length > 1;\n\t\t\tconst valueEndTrimmed = value.trimEnd();\n\t\t\tif (!isMultiLine) {\n\t\t\t\t// Adjust trimmed whitespace value based on cursor position\n\t\t\t\tif (valueEndTrimmed.length < value.length) {\n\t\t\t\t\t// Handle space key\n\t\t\t\t\tif (this._lastUserInput === \" \") {\n\t\t\t\t\t\tthis._lastUserInput = \"\";\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tcursorIndex > valueEndTrimmed.length &&\n\t\t\t\t\t\t\tcursorIndex > this._cursorIndex\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\ttrailingWhitespace++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttrailingWhitespace = Math.max(\n\t\t\t\t\t\tcursorIndex - valueEndTrimmed.length,\n\t\t\t\t\t\ttrailingWhitespace,\n\t\t\t\t\t\t0,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// Handle case where a non-space character is inserted in the middle of trailing whitespace\n\t\t\t\tconst charBeforeCursor =\n\t\t\t\t\tcursorIndex === 0 ? \"\" : value[cursorIndex - 1];\n\t\t\t\tif (\n\t\t\t\t\ttrailingWhitespace > 0 &&\n\t\t\t\t\tcursorIndex === this._cursorIndex + 1 &&\n\t\t\t\t\tthis._lastUserInput !== \"\" &&\n\t\t\t\t\tcharBeforeCursor !== \" \"\n\t\t\t\t) {\n\t\t\t\t\ttrailingWhitespace = this._value.length - this._cursorIndex;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isMultiLine) {\n\t\t\t\tvalueLines[valueLines.length - 1] =\n\t\t\t\t\tvalueLines.at(-1)?.trimEnd() ?? \"\";\n\t\t\t\tconst continuationOffset =\n\t\t\t\t\t(valueLines.length - 1) *\n\t\t\t\t\t(this._continuationPrompt?.length ?? 0);\n\t\t\t\ttrailingWhitespace = Math.max(\n\t\t\t\t\t0,\n\t\t\t\t\tcursorIndex - value.length - continuationOffset,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tvalue =\n\t\t\t\tvalueLines.map((e) => e.trimEnd()).join(\"\\n\") +\n\t\t\t\t\" \".repeat(trailingWhitespace);\n\t\t}\n\n\t\tif (\n\t\t\tthis._value !== value ||\n\t\t\tthis._cursorIndex !== cursorIndex ||\n\t\t\tthis._ghostTextIndex !== ghostTextIndex\n\t\t) {\n\t\t\tthis._value = value;\n\t\t\tthis._cursorIndex = cursorIndex;\n\t\t\tthis._ghostTextIndex = ghostTextIndex;\n\t\t\tthis._onDidChangeInput.fire(this._createStateObject());\n\t\t}\n\t}\n\n\tprivate _handleUserInput(e: string) {\n\t\tthis._lastUserInput = e;\n\t}\n\n\t/**\n\t * Detect ghost text by looking for italic or dim text in or after the cursor and\n\t * non-italic/dim text in the cell closest non-whitespace cell before the cursor.\n\t */\n\tprivate _scanForGhostText(\n\t\tbuffer: IBuffer,\n\t\tline: IBufferLine,\n\t\tcursorIndex: number,\n\t): number {\n\t\t// Check last non-whitespace character has non-ghost text styles\n\t\tlet ghostTextIndex = -1;\n\t\tlet proceedWithGhostTextCheck = false;\n\t\tlet x = buffer.cursorX;\n\t\twhile (x > 0) {\n\t\t\tconst cell = line.getCell(--x);\n\t\t\tif (!cell) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cell.getChars().trim().length > 0) {\n\t\t\t\tproceedWithGhostTextCheck =\n\t\t\t\t\t!this._isCellStyledLikeGhostText(cell);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Check to the end of the line for possible ghost text. For example pwsh's ghost text\n\t\t// can look like this `Get-|Ch[ildItem]`\n\t\tif (proceedWithGhostTextCheck) {\n\t\t\tlet potentialGhostIndexOffset = 0;\n\t\t\tlet x = buffer.cursorX;\n\t\t\twhile (x < line.length) {\n\t\t\t\tconst cell = line.getCell(x++);\n\t\t\t\tif (!cell || cell.getCode() === 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (this._isCellStyledLikeGhostText(cell)) {\n\t\t\t\t\tghostTextIndex = cursorIndex + potentialGhostIndexOffset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpotentialGhostIndexOffset += cell.getChars().length;\n\t\t\t}\n\t\t}\n\n\t\treturn ghostTextIndex;\n\t}\n\n\tprivate _trimContinuationPrompt(lineText: string): string {\n\t\tif (this._lineContainsContinuationPrompt(lineText)) {\n\t\t\tlineText = lineText.substring(this._continuationPrompt!.length);\n\t\t}\n\t\treturn lineText;\n\t}\n\n\tprivate _lineContainsContinuationPrompt(lineText: string): boolean {\n\t\treturn !!(\n\t\t\tthis._continuationPrompt &&\n\t\t\tlineText.startsWith(this._continuationPrompt)\n\t\t);\n\t}\n\n\tprivate _getContinuationPromptCellWidth(\n\t\tline: IBufferLine,\n\t\tlineText: string,\n\t): number {\n\t\tif (\n\t\t\t!this._continuationPrompt ||\n\t\t\t!lineText.startsWith(this._continuationPrompt)\n\t\t) {\n\t\t\treturn 0;\n\t\t}\n\t\tlet buffer = \"\";\n\t\tlet x = 0;\n\t\twhile (buffer !== this._continuationPrompt) {\n\t\t\tbuffer += line.getCell(x++)!.getChars();\n\t\t}\n\t\treturn x;\n\t}\n\n\tprivate _getRelativeCursorIndex(\n\t\tstartCellX: number,\n\t\tbuffer: IBuffer,\n\t\tline: IBufferLine,\n\t): number {\n\t\treturn (\n\t\t\tline?.translateToString(true, startCellX, buffer.cursorX).length ??\n\t\t\t0\n\t\t);\n\t}\n\n\tprivate _isCellStyledLikeGhostText(cell: IBufferCell): boolean {\n\t\treturn !!(cell.isItalic() || cell.isDim());\n\t}\n\n\tprivate _createStateObject(): IPromptInputModelState {\n\t\treturn Object.freeze({\n\t\t\tvalue: this._value,\n\t\t\tprefix: this.prefix,\n\t\t\tsuffix: this.suffix,\n\t\t\tcursorIndex: this._cursorIndex,\n\t\t\tghostTextIndex: this._ghostTextIndex,\n\t\t});\n\t}\n}\n"],
  "mappings": "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",
  "names": ["PromptInputState", "x"]
}
