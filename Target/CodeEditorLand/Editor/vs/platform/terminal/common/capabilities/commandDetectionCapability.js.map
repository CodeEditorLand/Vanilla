{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/terminal/common/capabilities/commandDetectionCapability.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { IBuffer, IDisposable, IMarker, Terminal } from \"@xterm/headless\";\nimport { RunOnceScheduler } from \"../../../../base/common/async.js\";\nimport { debounce } from \"../../../../base/common/decorators.js\";\nimport { Emitter } from \"../../../../base/common/event.js\";\nimport {\n\tDisposable,\n\tMandatoryMutableDisposable,\n\tMutableDisposable,\n} from \"../../../../base/common/lifecycle.js\";\nimport { ILogService } from \"../../../log/common/log.js\";\nimport type { ITerminalOutputMatcher } from \"../terminal.js\";\nimport {\n\tCommandInvalidationReason,\n\ttype ICommandDetectionCapability,\n\ttype ICommandInvalidationRequest,\n\ttype IHandleCommandOptions,\n\ttype ISerializedCommandDetectionCapability,\n\ttype ISerializedTerminalCommand,\n\ttype ITerminalCommand,\n\ttype IXtermMarker,\n\tTerminalCapability,\n} from \"./capabilities.js\";\nimport {\n\ttype IPromptInputModel,\n\tPromptInputModel,\n} from \"./commandDetection/promptInputModel.js\";\nimport {\n\ttype ICurrentPartialCommand,\n\tPartialTerminalCommand,\n\tTerminalCommand,\n} from \"./commandDetection/terminalCommand.js\";\n\ninterface ITerminalDimensions {\n\tcols: number;\n\trows: number;\n}\n\nexport class CommandDetectionCapability\n\textends Disposable\n\timplements ICommandDetectionCapability\n{\n\treadonly type = TerminalCapability.CommandDetection;\n\n\tprivate readonly _promptInputModel: PromptInputModel;\n\tget promptInputModel(): IPromptInputModel {\n\t\treturn this._promptInputModel;\n\t}\n\n\tprotected _commands: TerminalCommand[] = [];\n\tprivate _cwd: string | undefined;\n\tprivate _promptTerminator: string | undefined;\n\tprivate _currentCommand: PartialTerminalCommand =\n\t\tnew PartialTerminalCommand(this._terminal);\n\tprivate _commandMarkers: IMarker[] = [];\n\tprivate _dimensions: ITerminalDimensions;\n\tprivate __isCommandStorageDisabled = false;\n\tprivate _handleCommandStartOptions?: IHandleCommandOptions;\n\n\tprivate _commitCommandFinished?: RunOnceScheduler;\n\n\tprivate _ptyHeuristicsHooks: ICommandDetectionHeuristicsHooks;\n\tprivate readonly _ptyHeuristics: MandatoryMutableDisposable<IPtyHeuristics>;\n\n\tget commands(): readonly TerminalCommand[] {\n\t\treturn this._commands;\n\t}\n\tget executingCommand(): string | undefined {\n\t\treturn this._currentCommand.command;\n\t}\n\t// TODO: as is unsafe here and it duplicates behavor of executingCommand\n\tget executingCommandObject(): ITerminalCommand | undefined {\n\t\tif (this._currentCommand.commandStartMarker) {\n\t\t\treturn {\n\t\t\t\tmarker: this._currentCommand.commandStartMarker,\n\t\t\t} as ITerminalCommand;\n\t\t}\n\t\treturn undefined;\n\t}\n\tget currentCommand(): ICurrentPartialCommand {\n\t\treturn this._currentCommand;\n\t}\n\tget cwd(): string | undefined {\n\t\treturn this._cwd;\n\t}\n\tget promptTerminator(): string | undefined {\n\t\treturn this._promptTerminator;\n\t}\n\n\tprivate readonly _onCommandStarted = this._register(\n\t\tnew Emitter<ITerminalCommand>(),\n\t);\n\treadonly onCommandStarted = this._onCommandStarted.event;\n\tprivate readonly _onBeforeCommandFinished = this._register(\n\t\tnew Emitter<ITerminalCommand>(),\n\t);\n\treadonly onBeforeCommandFinished = this._onBeforeCommandFinished.event;\n\tprivate readonly _onCommandFinished = this._register(\n\t\tnew Emitter<ITerminalCommand>(),\n\t);\n\treadonly onCommandFinished = this._onCommandFinished.event;\n\tprivate readonly _onCommandExecuted = this._register(\n\t\tnew Emitter<ITerminalCommand>(),\n\t);\n\treadonly onCommandExecuted = this._onCommandExecuted.event;\n\tprivate readonly _onCommandInvalidated = this._register(\n\t\tnew Emitter<ITerminalCommand[]>(),\n\t);\n\treadonly onCommandInvalidated = this._onCommandInvalidated.event;\n\tprivate readonly _onCurrentCommandInvalidated = this._register(\n\t\tnew Emitter<ICommandInvalidationRequest>(),\n\t);\n\treadonly onCurrentCommandInvalidated =\n\t\tthis._onCurrentCommandInvalidated.event;\n\n\tconstructor(\n\t\tprivate readonly _terminal: Terminal,\n\t\t@ILogService private readonly _logService: ILogService\n\t) {\n\t\tsuper();\n\n\t\tthis._promptInputModel = this._register(new PromptInputModel(this._terminal, this.onCommandStarted, this.onCommandExecuted, this._logService));\n\n\t\t// Pull command line from the buffer if it was not set explicitly\n\t\tthis._register(this.onCommandExecuted(command => {\n\t\t\tif (command.commandLineConfidence !== 'high') {\n\t\t\t\t// HACK: onCommandExecuted actually fired with PartialTerminalCommand\n\t\t\t\tconst typedCommand = (command as ITerminalCommand | PartialTerminalCommand);\n\t\t\t\tcommand.command = typedCommand.extractCommandLine();\n\t\t\t\tcommand.commandLineConfidence = 'low';\n\n\t\t\t\t// ITerminalCommand\n\t\t\t\tif ('getOutput' in typedCommand) {\n\t\t\t\t\tif (\n\t\t\t\t\t\t// Markers exist\n\t\t\t\t\t\ttypedCommand.promptStartMarker && typedCommand.marker && typedCommand.executedMarker &&\n\t\t\t\t\t\t// Single line command\n\t\t\t\t\t\tcommand.command.indexOf('\\n') === -1 &&\n\t\t\t\t\t\t// Start marker is not on the left-most column\n\t\t\t\t\t\ttypedCommand.startX !== undefined && typedCommand.startX > 0\n\t\t\t\t\t) {\n\t\t\t\t\t\tcommand.commandLineConfidence = 'medium';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// PartialTerminalCommand\n\t\t\t\telse if (\n\t\t\t\t\t\t// Markers exist\n\t\t\t\t\t\ttypedCommand.promptStartMarker && typedCommand.commandStartMarker && typedCommand.commandExecutedMarker &&\n\t\t\t\t\t\t// Single line command\n\t\t\t\t\t\tcommand.command.indexOf('\\n') === -1 &&\n\t\t\t\t\t\t// Start marker is not on the left-most column\n\t\t\t\t\t\ttypedCommand.commandStartX !== undefined && typedCommand.commandStartX > 0\n\t\t\t\t\t) {\n\t\t\t\t\t\tcommand.commandLineConfidence = 'medium';\n\t\t\t\t\t}\n\t\t\t}\n\t\t}));\n\n\t\t// Set up platform-specific behaviors\n\t\tconst that = this;\n\t\tthis._ptyHeuristicsHooks = new class implements ICommandDetectionHeuristicsHooks {\n\t\t\tget onCurrentCommandInvalidatedEmitter() { return that._onCurrentCommandInvalidated; }\n\t\t\tget onCommandStartedEmitter() { return that._onCommandStarted; }\n\t\t\tget onCommandExecutedEmitter() { return that._onCommandExecuted; }\n\t\t\tget dimensions() { return that._dimensions; }\n\t\t\tget isCommandStorageDisabled() { return that.__isCommandStorageDisabled; }\n\t\t\tget commandMarkers() { return that._commandMarkers; }\n\t\t\tset commandMarkers(value) { that._commandMarkers = value; }\n\t\t\tget clearCommandsInViewport() { return that._clearCommandsInViewport.bind(that); }\n\t\t\tcommitCommandFinished() {\n\t\t\t\tthat._commitCommandFinished?.flush();\n\t\t\t\tthat._commitCommandFinished = undefined;\n\t\t\t}\n\t\t};\n\t\tthis._ptyHeuristics = this._register(new MandatoryMutableDisposable(new UnixPtyHeuristics(this._terminal, this, this._ptyHeuristicsHooks, this._logService)));\n\n\t\tthis._dimensions = {\n\t\t\tcols: this._terminal.cols,\n\t\t\trows: this._terminal.rows\n\t\t};\n\t\tthis._register(this._terminal.onResize(e => this._handleResize(e)));\n\t\tthis._register(this._terminal.onCursorMove(() => this._handleCursorMove()));\n\t}\n\n\tprivate _handleResize(e: { cols: number; rows: number }) {\n\t\tthis._ptyHeuristics.value.preHandleResize?.(e);\n\t\tthis._dimensions.cols = e.cols;\n\t\tthis._dimensions.rows = e.rows;\n\t}\n\n\t@debounce(500)\n\tprivate _handleCursorMove() {\n\t\tif (this._store.isDisposed) {\n\t\t\treturn;\n\t\t}\n\t\t// Early versions of conpty do not have real support for an alt buffer, in addition certain\n\t\t// commands such as tsc watch will write to the top of the normal buffer. The following\n\t\t// checks when the cursor has moved while the normal buffer is empty and if it is above the\n\t\t// current command, all decorations within the viewport will be invalidated.\n\t\t//\n\t\t// This function is debounced so that the cursor is only checked when it is stable so\n\t\t// conpty's screen reprinting will not trigger decoration clearing.\n\t\t//\n\t\t// This is mostly a workaround for Windows but applies to all OS' because of the tsc watch\n\t\t// case.\n\t\tif (\n\t\t\tthis._terminal.buffer.active === this._terminal.buffer.normal &&\n\t\t\tthis._currentCommand.commandStartMarker\n\t\t) {\n\t\t\tif (\n\t\t\t\tthis._terminal.buffer.active.baseY +\n\t\t\t\t\tthis._terminal.buffer.active.cursorY <\n\t\t\t\tthis._currentCommand.commandStartMarker.line\n\t\t\t) {\n\t\t\t\tthis._clearCommandsInViewport();\n\t\t\t\tthis._currentCommand.isInvalid = true;\n\t\t\t\tthis._onCurrentCommandInvalidated.fire({\n\t\t\t\t\treason: CommandInvalidationReason.Windows,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _clearCommandsInViewport(): void {\n\t\t// Find the number of commands on the tail end of the array that are within the viewport\n\t\tlet count = 0;\n\t\tfor (let i = this._commands.length - 1; i >= 0; i--) {\n\t\t\tconst line = this._commands[i].marker?.line;\n\t\t\tif (line && line < this._terminal.buffer.active.baseY) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\t// Remove them\n\t\tif (count > 0) {\n\t\t\tthis._onCommandInvalidated.fire(\n\t\t\t\tthis._commands.splice(this._commands.length - count, count),\n\t\t\t);\n\t\t}\n\t}\n\n\tsetContinuationPrompt(value: string): void {\n\t\tthis._promptInputModel.setContinuationPrompt(value);\n\t}\n\n\t// TODO: Simplify this, can everything work off the last line?\n\tsetPromptTerminator(promptTerminator: string, lastPromptLine: string) {\n\t\tthis._logService.debug(\n\t\t\t\"CommandDetectionCapability#setPromptTerminator\",\n\t\t\tpromptTerminator,\n\t\t);\n\t\tthis._promptTerminator = promptTerminator;\n\t\tthis._promptInputModel.setLastPromptLine(lastPromptLine);\n\t}\n\n\tsetCwd(value: string) {\n\t\tthis._cwd = value;\n\t}\n\n\tsetIsWindowsPty(value: boolean) {\n\t\tif (\n\t\t\tvalue &&\n\t\t\t!(this._ptyHeuristics.value instanceof WindowsPtyHeuristics)\n\t\t) {\n\t\t\tconst that = this;\n\t\t\tthis._ptyHeuristics.value = new WindowsPtyHeuristics(\n\t\t\t\tthis._terminal,\n\t\t\t\tthis,\n\t\t\t\tnew (class {\n\t\t\t\t\tget onCurrentCommandInvalidatedEmitter() {\n\t\t\t\t\t\treturn that._onCurrentCommandInvalidated;\n\t\t\t\t\t}\n\t\t\t\t\tget onCommandStartedEmitter() {\n\t\t\t\t\t\treturn that._onCommandStarted;\n\t\t\t\t\t}\n\t\t\t\t\tget onCommandExecutedEmitter() {\n\t\t\t\t\t\treturn that._onCommandExecuted;\n\t\t\t\t\t}\n\t\t\t\t\tget dimensions() {\n\t\t\t\t\t\treturn that._dimensions;\n\t\t\t\t\t}\n\t\t\t\t\tget isCommandStorageDisabled() {\n\t\t\t\t\t\treturn that.__isCommandStorageDisabled;\n\t\t\t\t\t}\n\t\t\t\t\tget commandMarkers() {\n\t\t\t\t\t\treturn that._commandMarkers;\n\t\t\t\t\t}\n\t\t\t\t\tset commandMarkers(value) {\n\t\t\t\t\t\tthat._commandMarkers = value;\n\t\t\t\t\t}\n\t\t\t\t\tget clearCommandsInViewport() {\n\t\t\t\t\t\treturn that._clearCommandsInViewport.bind(that);\n\t\t\t\t\t}\n\t\t\t\t\tcommitCommandFinished() {\n\t\t\t\t\t\tthat._commitCommandFinished?.flush();\n\t\t\t\t\t\tthat._commitCommandFinished = undefined;\n\t\t\t\t\t}\n\t\t\t\t})(),\n\t\t\t\tthis._logService,\n\t\t\t);\n\t\t} else if (\n\t\t\t!value &&\n\t\t\t!(this._ptyHeuristics.value instanceof UnixPtyHeuristics)\n\t\t) {\n\t\t\tthis._ptyHeuristics.value = new UnixPtyHeuristics(\n\t\t\t\tthis._terminal,\n\t\t\t\tthis,\n\t\t\t\tthis._ptyHeuristicsHooks,\n\t\t\t\tthis._logService,\n\t\t\t);\n\t\t}\n\t}\n\n\tsetIsCommandStorageDisabled(): void {\n\t\tthis.__isCommandStorageDisabled = true;\n\t}\n\n\tgetCommandForLine(\n\t\tline: number,\n\t): ITerminalCommand | ICurrentPartialCommand | undefined {\n\t\t// Handle the current partial command first, anything below it's prompt is considered part\n\t\t// of the current command\n\t\tif (\n\t\t\tthis._currentCommand.promptStartMarker &&\n\t\t\tline >= this._currentCommand.promptStartMarker?.line\n\t\t) {\n\t\t\treturn this._currentCommand;\n\t\t}\n\n\t\t// No commands\n\t\tif (this._commands.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Line is before any registered commands\n\t\tif (\n\t\t\t(this._commands[0].promptStartMarker ?? this._commands[0].marker!)\n\t\t\t\t.line > line\n\t\t) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Iterate backwards through commands to find the right one\n\t\tfor (let i = this.commands.length - 1; i >= 0; i--) {\n\t\t\tif (\n\t\t\t\t(this.commands[i].promptStartMarker ?? this.commands[i].marker!)\n\t\t\t\t\t.line <= line\n\t\t\t) {\n\t\t\t\treturn this.commands[i];\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tgetCwdForLine(line: number): string | undefined {\n\t\t// Handle the current partial command first, anything below it's prompt is considered part\n\t\t// of the current command\n\t\tif (\n\t\t\tthis._currentCommand.promptStartMarker &&\n\t\t\tline >= this._currentCommand.promptStartMarker?.line\n\t\t) {\n\t\t\treturn this._cwd;\n\t\t}\n\n\t\tconst command = this.getCommandForLine(line);\n\t\tif (command && \"cwd\" in command) {\n\t\t\treturn command.cwd;\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\thandlePromptStart(options?: IHandleCommandOptions): void {\n\t\t// Adjust the last command's finished marker when needed. The standard position for the\n\t\t// finished marker `D` to appear is at the same position as the following prompt started\n\t\t// `A`.\n\t\tconst lastCommand = this.commands.at(-1);\n\t\tif (\n\t\t\tlastCommand?.endMarker &&\n\t\t\tlastCommand?.executedMarker &&\n\t\t\tlastCommand.endMarker.line === lastCommand.executedMarker.line\n\t\t) {\n\t\t\tthis._logService.debug(\n\t\t\t\t\"CommandDetectionCapability#handlePromptStart adjusted commandFinished\",\n\t\t\t\t`${lastCommand.endMarker.line} -> ${lastCommand.executedMarker.line + 1}`,\n\t\t\t);\n\t\t\tlastCommand.endMarker = cloneMarker(\n\t\t\t\tthis._terminal,\n\t\t\t\tlastCommand.executedMarker,\n\t\t\t\t1,\n\t\t\t);\n\t\t}\n\n\t\tthis._currentCommand.promptStartMarker =\n\t\t\toptions?.marker ||\n\t\t\t(lastCommand?.endMarker\n\t\t\t\t? cloneMarker(this._terminal, lastCommand.endMarker)\n\t\t\t\t: this._terminal.registerMarker(0));\n\n\t\tthis._logService.debug(\n\t\t\t\"CommandDetectionCapability#handlePromptStart\",\n\t\t\tthis._terminal.buffer.active.cursorX,\n\t\t\tthis._currentCommand.promptStartMarker?.line,\n\t\t);\n\t}\n\n\thandleContinuationStart(): void {\n\t\tthis._currentCommand.currentContinuationMarker =\n\t\t\tthis._terminal.registerMarker(0);\n\t\tthis._logService.debug(\n\t\t\t\"CommandDetectionCapability#handleContinuationStart\",\n\t\t\tthis._currentCommand.currentContinuationMarker,\n\t\t);\n\t}\n\n\thandleContinuationEnd(): void {\n\t\tif (!this._currentCommand.currentContinuationMarker) {\n\t\t\tthis._logService.warn(\n\t\t\t\t\"CommandDetectionCapability#handleContinuationEnd Received continuation end without start\",\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t\tif (!this._currentCommand.continuations) {\n\t\t\tthis._currentCommand.continuations = [];\n\t\t}\n\t\tthis._currentCommand.continuations.push({\n\t\t\tmarker: this._currentCommand.currentContinuationMarker,\n\t\t\tend: this._terminal.buffer.active.cursorX,\n\t\t});\n\t\tthis._currentCommand.currentContinuationMarker = undefined;\n\t\tthis._logService.debug(\n\t\t\t\"CommandDetectionCapability#handleContinuationEnd\",\n\t\t\tthis._currentCommand.continuations[\n\t\t\t\tthis._currentCommand.continuations.length - 1\n\t\t\t],\n\t\t);\n\t}\n\n\thandleRightPromptStart(): void {\n\t\tthis._currentCommand.commandRightPromptStartX =\n\t\t\tthis._terminal.buffer.active.cursorX;\n\t\tthis._logService.debug(\n\t\t\t\"CommandDetectionCapability#handleRightPromptStart\",\n\t\t\tthis._currentCommand.commandRightPromptStartX,\n\t\t);\n\t}\n\n\thandleRightPromptEnd(): void {\n\t\tthis._currentCommand.commandRightPromptEndX =\n\t\t\tthis._terminal.buffer.active.cursorX;\n\t\tthis._logService.debug(\n\t\t\t\"CommandDetectionCapability#handleRightPromptEnd\",\n\t\t\tthis._currentCommand.commandRightPromptEndX,\n\t\t);\n\t}\n\n\thandleCommandStart(options?: IHandleCommandOptions): void {\n\t\tthis._handleCommandStartOptions = options;\n\t\tthis._currentCommand.cwd = this._cwd;\n\t\t// Only update the column if the line has already been set\n\t\tthis._currentCommand.commandStartMarker =\n\t\t\toptions?.marker || this._currentCommand.commandStartMarker;\n\t\tif (\n\t\t\tthis._currentCommand.commandStartMarker?.line ===\n\t\t\tthis._terminal.buffer.active.cursorY\n\t\t) {\n\t\t\tthis._currentCommand.commandStartX =\n\t\t\t\tthis._terminal.buffer.active.cursorX;\n\t\t\tthis._logService.debug(\n\t\t\t\t\"CommandDetectionCapability#handleCommandStart\",\n\t\t\t\tthis._currentCommand.commandStartX,\n\t\t\t\tthis._currentCommand.commandStartMarker?.line,\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t\tthis._ptyHeuristics.value.handleCommandStart(options);\n\t}\n\n\thandleGenericCommand(options?: IHandleCommandOptions): void {\n\t\tif (options?.markProperties?.disableCommandStorage) {\n\t\t\tthis.setIsCommandStorageDisabled();\n\t\t}\n\t\tthis.handlePromptStart(options);\n\t\tthis.handleCommandStart(options);\n\t\tthis.handleCommandExecuted(options);\n\t\tthis.handleCommandFinished(undefined, options);\n\t}\n\n\thandleCommandExecuted(options?: IHandleCommandOptions): void {\n\t\tthis._ptyHeuristics.value.handleCommandExecuted(options);\n\t\tthis._currentCommand.markExecutedTime();\n\t}\n\n\thandleCommandFinished(\n\t\texitCode: number | undefined,\n\t\toptions?: IHandleCommandOptions,\n\t): void {\n\t\tthis._currentCommand.markFinishedTime();\n\t\tthis._ptyHeuristics.value.preHandleCommandFinished?.();\n\n\t\tthis._logService.debug(\n\t\t\t\"CommandDetectionCapability#handleCommandFinished\",\n\t\t\tthis._terminal.buffer.active.cursorX,\n\t\t\toptions?.marker?.line,\n\t\t\tthis._currentCommand.command,\n\t\t\tthis._currentCommand,\n\t\t);\n\n\t\t// HACK: Handle a special case on some versions of bash where identical commands get merged\n\t\t// in the output of `history`, this detects that case and sets the exit code to the the last\n\t\t// command's exit code. This covered the majority of cases but will fail if the same command\n\t\t// runs with a different exit code, that will need a more robust fix where we send the\n\t\t// command ID and exit code over to the capability to adjust there.\n\t\tif (exitCode === undefined) {\n\t\t\tconst lastCommand =\n\t\t\t\tthis.commands.length > 0\n\t\t\t\t\t? this.commands[this.commands.length - 1]\n\t\t\t\t\t: undefined;\n\t\t\tif (\n\t\t\t\tthis._currentCommand.command &&\n\t\t\t\tthis._currentCommand.command.length > 0 &&\n\t\t\t\tlastCommand?.command === this._currentCommand.command\n\t\t\t) {\n\t\t\t\texitCode = lastCommand.exitCode;\n\t\t\t}\n\t\t}\n\n\t\tif (\n\t\t\tthis._currentCommand.commandStartMarker === undefined ||\n\t\t\t!this._terminal.buffer.active\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._currentCommand.commandFinishedMarker =\n\t\t\toptions?.marker || this._terminal.registerMarker(0);\n\n\t\tthis._ptyHeuristics.value.postHandleCommandFinished?.();\n\n\t\tconst newCommand = this._currentCommand.promoteToFullCommand(\n\t\t\tthis._cwd,\n\t\t\texitCode,\n\t\t\tthis._handleCommandStartOptions?.ignoreCommandLine ?? false,\n\t\t\toptions?.markProperties,\n\t\t);\n\n\t\tif (newCommand) {\n\t\t\tthis._commands.push(newCommand);\n\t\t\tthis._commitCommandFinished = new RunOnceScheduler(() => {\n\t\t\t\tthis._onBeforeCommandFinished.fire(newCommand);\n\t\t\t\tif (!this._currentCommand.isInvalid) {\n\t\t\t\t\tthis._logService.debug(\n\t\t\t\t\t\t\"CommandDetectionCapability#onCommandFinished\",\n\t\t\t\t\t\tnewCommand,\n\t\t\t\t\t);\n\t\t\t\t\tthis._onCommandFinished.fire(newCommand);\n\t\t\t\t}\n\t\t\t}, 50);\n\t\t\tthis._commitCommandFinished.schedule();\n\t\t}\n\t\tthis._currentCommand = new PartialTerminalCommand(this._terminal);\n\t\tthis._handleCommandStartOptions = undefined;\n\t}\n\n\tsetCommandLine(commandLine: string, isTrusted: boolean) {\n\t\tthis._logService.debug(\n\t\t\t\"CommandDetectionCapability#setCommandLine\",\n\t\t\tcommandLine,\n\t\t\tisTrusted,\n\t\t);\n\t\tthis._currentCommand.command = commandLine;\n\t\tthis._currentCommand.commandLineConfidence = \"high\";\n\t\tthis._currentCommand.isTrusted = isTrusted;\n\n\t\tif (isTrusted) {\n\t\t\tthis._promptInputModel.setConfidentCommandLine(commandLine);\n\t\t}\n\t}\n\n\tserialize(): ISerializedCommandDetectionCapability {\n\t\tconst commands: ISerializedTerminalCommand[] = this.commands.map((e) =>\n\t\t\te.serialize(this.__isCommandStorageDisabled),\n\t\t);\n\t\tconst partialCommand = this._currentCommand.serialize(this._cwd);\n\t\tif (partialCommand) {\n\t\t\tcommands.push(partialCommand);\n\t\t}\n\t\treturn {\n\t\t\tisWindowsPty:\n\t\t\t\tthis._ptyHeuristics.value instanceof WindowsPtyHeuristics,\n\t\t\tcommands,\n\t\t\tpromptInputModel: this._promptInputModel.serialize(),\n\t\t};\n\t}\n\n\tdeserialize(serialized: ISerializedCommandDetectionCapability): void {\n\t\tif (serialized.isWindowsPty) {\n\t\t\tthis.setIsWindowsPty(serialized.isWindowsPty);\n\t\t}\n\t\tconst buffer = this._terminal.buffer.normal;\n\t\tfor (const e of serialized.commands) {\n\t\t\t// Partial command\n\t\t\tif (!e.endLine) {\n\t\t\t\t// Check for invalid command\n\t\t\t\tconst marker =\n\t\t\t\t\te.startLine !== undefined\n\t\t\t\t\t\t? this._terminal.registerMarker(\n\t\t\t\t\t\t\t\te.startLine - (buffer.baseY + buffer.cursorY),\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t: undefined;\n\t\t\t\tif (!marker) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tthis._currentCommand.commandStartMarker =\n\t\t\t\t\te.startLine !== undefined\n\t\t\t\t\t\t? this._terminal.registerMarker(\n\t\t\t\t\t\t\t\te.startLine - (buffer.baseY + buffer.cursorY),\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t: undefined;\n\t\t\t\tthis._currentCommand.commandStartX = e.startX;\n\t\t\t\tthis._currentCommand.promptStartMarker =\n\t\t\t\t\te.promptStartLine !== undefined\n\t\t\t\t\t\t? this._terminal.registerMarker(\n\t\t\t\t\t\t\t\te.promptStartLine -\n\t\t\t\t\t\t\t\t\t(buffer.baseY + buffer.cursorY),\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t: undefined;\n\t\t\t\tthis._cwd = e.cwd;\n\t\t\t\tthis._onCommandStarted.fire({ marker } as ITerminalCommand);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Full command\n\t\t\tconst newCommand = TerminalCommand.deserialize(\n\t\t\t\tthis._terminal,\n\t\t\t\te,\n\t\t\t\tthis.__isCommandStorageDisabled,\n\t\t\t);\n\t\t\tif (!newCommand) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis._commands.push(newCommand);\n\t\t\tthis._logService.debug(\n\t\t\t\t\"CommandDetectionCapability#onCommandFinished\",\n\t\t\t\tnewCommand,\n\t\t\t);\n\t\t\tthis._onCommandFinished.fire(newCommand);\n\t\t}\n\t\tif (serialized.promptInputModel) {\n\t\t\tthis._promptInputModel.deserialize(serialized.promptInputModel);\n\t\t}\n\t}\n}\n\n/**\n * Additional hooks to private methods on {@link CommandDetectionCapability} that are needed by the\n * heuristics objects.\n */\ninterface ICommandDetectionHeuristicsHooks {\n\treadonly onCurrentCommandInvalidatedEmitter: Emitter<ICommandInvalidationRequest>;\n\treadonly onCommandStartedEmitter: Emitter<ITerminalCommand>;\n\treadonly onCommandExecutedEmitter: Emitter<ITerminalCommand>;\n\treadonly dimensions: ITerminalDimensions;\n\treadonly isCommandStorageDisabled: boolean;\n\n\tcommandMarkers: IMarker[];\n\n\tclearCommandsInViewport(): void;\n\tcommitCommandFinished(): void;\n}\n\ntype IPtyHeuristics =\n\t// All optional methods\n\tPartial<UnixPtyHeuristics> &\n\t\tPartial<WindowsPtyHeuristics> &\n\t\t// All common methods\n\t\t(UnixPtyHeuristics | WindowsPtyHeuristics) &\n\t\tIDisposable;\n\n/**\n * Non-Windows-specific behavior.\n */\nclass UnixPtyHeuristics extends Disposable {\n\tconstructor(\n\t\tprivate readonly _terminal: Terminal,\n\t\tprivate readonly _capability: CommandDetectionCapability,\n\t\tprivate readonly _hooks: ICommandDetectionHeuristicsHooks,\n\t\tprivate readonly _logService: ILogService,\n\t) {\n\t\tsuper();\n\t\tthis._register(\n\t\t\t_terminal.parser.registerCsiHandler({ final: \"J\" }, (params) => {\n\t\t\t\tif (\n\t\t\t\t\tparams.length >= 1 &&\n\t\t\t\t\t(params[0] === 2 || params[0] === 3)\n\t\t\t\t) {\n\t\t\t\t\t_hooks.clearCommandsInViewport();\n\t\t\t\t}\n\t\t\t\t// We don't want to override xterm.js' default behavior, just augment it\n\t\t\t\treturn false;\n\t\t\t}),\n\t\t);\n\t}\n\n\thandleCommandStart(options?: IHandleCommandOptions) {\n\t\tthis._hooks.commitCommandFinished();\n\n\t\tconst currentCommand = this._capability.currentCommand;\n\t\tcurrentCommand.commandStartX = this._terminal.buffer.active.cursorX;\n\t\tcurrentCommand.commandStartMarker =\n\t\t\toptions?.marker || this._terminal.registerMarker(0);\n\n\t\t// Clear executed as it must happen after command start\n\t\tcurrentCommand.commandExecutedMarker?.dispose();\n\t\tcurrentCommand.commandExecutedMarker = undefined;\n\t\tcurrentCommand.commandExecutedX = undefined;\n\t\tfor (const m of this._hooks.commandMarkers) {\n\t\t\tm.dispose();\n\t\t}\n\t\tthis._hooks.commandMarkers.length = 0;\n\n\t\tthis._hooks.onCommandStartedEmitter.fire({\n\t\t\tmarker: options?.marker || currentCommand.commandStartMarker,\n\t\t\tmarkProperties: options?.markProperties,\n\t\t} as ITerminalCommand);\n\t\tthis._logService.debug(\n\t\t\t\"CommandDetectionCapability#handleCommandStart\",\n\t\t\tcurrentCommand.commandStartX,\n\t\t\tcurrentCommand.commandStartMarker?.line,\n\t\t);\n\t}\n\n\thandleCommandExecuted(options?: IHandleCommandOptions) {\n\t\tconst currentCommand = this._capability.currentCommand;\n\t\tcurrentCommand.commandExecutedMarker =\n\t\t\toptions?.marker || this._terminal.registerMarker(0);\n\t\tcurrentCommand.commandExecutedX = this._terminal.buffer.active.cursorX;\n\t\tthis._logService.debug(\n\t\t\t\"CommandDetectionCapability#handleCommandExecuted\",\n\t\t\tcurrentCommand.commandExecutedX,\n\t\t\tcurrentCommand.commandExecutedMarker?.line,\n\t\t);\n\n\t\t// Sanity check optional props\n\t\tif (\n\t\t\t!currentCommand.commandStartMarker ||\n\t\t\t!currentCommand.commandExecutedMarker ||\n\t\t\tcurrentCommand.commandStartX === undefined\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Calculate the command\n\t\tcurrentCommand.command = this._hooks.isCommandStorageDisabled\n\t\t\t? \"\"\n\t\t\t: this._terminal.buffer.active\n\t\t\t\t\t.getLine(currentCommand.commandStartMarker.line)\n\t\t\t\t\t?.translateToString(\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\tcurrentCommand.commandStartX,\n\t\t\t\t\t\tcurrentCommand.commandRightPromptStartX,\n\t\t\t\t\t)\n\t\t\t\t\t.trim();\n\t\tlet y = currentCommand.commandStartMarker.line + 1;\n\t\tconst commandExecutedLine = currentCommand.commandExecutedMarker.line;\n\t\tfor (; y < commandExecutedLine; y++) {\n\t\t\tconst line = this._terminal.buffer.active.getLine(y);\n\t\t\tif (line) {\n\t\t\t\tconst continuation = currentCommand.continuations?.find(\n\t\t\t\t\t(e) => e.marker.line === y,\n\t\t\t\t);\n\t\t\t\tif (continuation) {\n\t\t\t\t\tcurrentCommand.command += \"\\n\";\n\t\t\t\t}\n\t\t\t\tconst startColumn = continuation?.end ?? 0;\n\t\t\t\tcurrentCommand.command += line.translateToString(\n\t\t\t\t\ttrue,\n\t\t\t\t\tstartColumn,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tif (y === commandExecutedLine) {\n\t\t\tcurrentCommand.command +=\n\t\t\t\tthis._terminal.buffer.active\n\t\t\t\t\t.getLine(commandExecutedLine)\n\t\t\t\t\t?.translateToString(\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tcurrentCommand.commandExecutedX,\n\t\t\t\t\t) || \"\";\n\t\t}\n\t\tthis._hooks.onCommandExecutedEmitter.fire(\n\t\t\tcurrentCommand as ITerminalCommand,\n\t\t);\n\t}\n}\n\nenum AdjustCommandStartMarkerConstants {\n\tMaxCheckLineCount = 10,\n\tInterval = 20,\n\tMaximumPollCount = 10,\n}\n\n/**\n * An object that integrated with and decorates the command detection capability to add heuristics\n * that adjust various markers to work better with Windows and ConPTY. This isn't depended upon the\n * frontend OS, or even the backend OS, but the `IsWindows` property which technically a non-Windows\n * client can emit (for example in tests).\n */\nclass WindowsPtyHeuristics extends Disposable {\n\tprivate readonly _onCursorMoveListener = this._register(\n\t\tnew MutableDisposable(),\n\t);\n\n\tprivate _tryAdjustCommandStartMarkerScheduler?: RunOnceScheduler;\n\tprivate _tryAdjustCommandStartMarkerScannedLineCount = 0;\n\tprivate _tryAdjustCommandStartMarkerPollCount = 0;\n\n\tconstructor(\n\t\tprivate readonly _terminal: Terminal,\n\t\tprivate readonly _capability: CommandDetectionCapability,\n\t\tprivate readonly _hooks: ICommandDetectionHeuristicsHooks,\n\t\t@ILogService private readonly _logService: ILogService,\n\t) {\n\t\tsuper();\n\n\t\tthis._register(_terminal.parser.registerCsiHandler({ final: 'J' }, params => {\n\t\t\t// Clear commands when the viewport is cleared\n\t\t\tif (params.length >= 1 && (params[0] === 2 || params[0] === 3)) {\n\t\t\t\tthis._hooks.clearCommandsInViewport();\n\t\t\t}\n\t\t\t// We don't want to override xterm.js' default behavior, just augment it\n\t\t\treturn false;\n\t\t}));\n\n\t\tthis._register(this._capability.onBeforeCommandFinished(command => {\n\t\t\t// For older Windows backends we cannot listen to CSI J, instead we assume running clear\n\t\t\t// or cls will clear all commands in the viewport. This is not perfect but it's right\n\t\t\t// most of the time.\n\t\t\tif (command.command.trim().toLowerCase() === 'clear' || command.command.trim().toLowerCase() === 'cls') {\n\t\t\t\tthis._tryAdjustCommandStartMarkerScheduler?.cancel();\n\t\t\t\tthis._tryAdjustCommandStartMarkerScheduler = undefined;\n\t\t\t\tthis._hooks.clearCommandsInViewport();\n\t\t\t\tthis._capability.currentCommand.isInvalid = true;\n\t\t\t\tthis._hooks.onCurrentCommandInvalidatedEmitter.fire({ reason: CommandInvalidationReason.Windows });\n\t\t\t}\n\t\t}));\n\t}\n\n\tpreHandleResize(e: { cols: number; rows: number }) {\n\t\t// Resize behavior is different under conpty; instead of bringing parts of the scrollback\n\t\t// back into the viewport, new lines are inserted at the bottom (ie. the same behavior as if\n\t\t// there was no scrollback).\n\t\t//\n\t\t// On resize this workaround will wait for a conpty reprint to occur by waiting for the\n\t\t// cursor to move, it will then calculate the number of lines that the commands within the\n\t\t// viewport _may have_ shifted. After verifying the content of the current line is\n\t\t// incorrect, the line after shifting is checked and if that matches delete events are fired\n\t\t// on the xterm.js buffer to move the markers.\n\t\t//\n\t\t// While a bit hacky, this approach is quite safe and seems to work great at least for pwsh.\n\t\tconst baseY = this._terminal.buffer.active.baseY;\n\t\tconst rowsDifference = e.rows - this._hooks.dimensions.rows;\n\t\t// Only do when rows increase, do in the next frame as this needs to happen after\n\t\t// conpty reprints the screen\n\t\tif (rowsDifference > 0) {\n\t\t\tthis._waitForCursorMove().then(() => {\n\t\t\t\t// Calculate the number of lines the content may have shifted, this will max out at\n\t\t\t\t// scrollback count since the standard behavior will be used then\n\t\t\t\tconst potentialShiftedLineCount = Math.min(\n\t\t\t\t\trowsDifference,\n\t\t\t\t\tbaseY,\n\t\t\t\t);\n\t\t\t\t// For each command within the viewport, assume commands are in the correct order\n\t\t\t\tfor (\n\t\t\t\t\tlet i = this._capability.commands.length - 1;\n\t\t\t\t\ti >= 0;\n\t\t\t\t\ti--\n\t\t\t\t) {\n\t\t\t\t\tconst command = this._capability.commands[i];\n\t\t\t\t\tif (\n\t\t\t\t\t\t!command.marker ||\n\t\t\t\t\t\tcommand.marker.line < baseY ||\n\t\t\t\t\t\tcommand.commandStartLineContent === undefined\n\t\t\t\t\t) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst line = this._terminal.buffer.active.getLine(\n\t\t\t\t\t\tcommand.marker.line,\n\t\t\t\t\t);\n\t\t\t\t\tif (\n\t\t\t\t\t\t!line ||\n\t\t\t\t\t\tline.translateToString(true) ===\n\t\t\t\t\t\t\tcommand.commandStartLineContent\n\t\t\t\t\t) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tconst shiftedY =\n\t\t\t\t\t\tcommand.marker.line - potentialShiftedLineCount;\n\t\t\t\t\tconst shiftedLine =\n\t\t\t\t\t\tthis._terminal.buffer.active.getLine(shiftedY);\n\t\t\t\t\tif (\n\t\t\t\t\t\tshiftedLine?.translateToString(true) !==\n\t\t\t\t\t\tcommand.commandStartLineContent\n\t\t\t\t\t) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// HACK: xterm.js doesn't expose this by design as it's an internal core\n\t\t\t\t\t// function an embedder could easily do damage with. Additionally, this\n\t\t\t\t\t// can't really be upstreamed since the event relies on shell integration to\n\t\t\t\t\t// verify the shifting is necessary.\n\t\t\t\t\t(\n\t\t\t\t\t\tthis._terminal as any\n\t\t\t\t\t)._core._bufferService.buffer.lines.onDeleteEmitter.fire({\n\t\t\t\t\t\tindex: this._terminal.buffer.active.baseY,\n\t\t\t\t\t\tamount: potentialShiftedLineCount,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\thandleCommandStart() {\n\t\tthis._capability.currentCommand.commandStartX =\n\t\t\tthis._terminal.buffer.active.cursorX;\n\n\t\t// On Windows track all cursor movements after the command start sequence\n\t\tthis._hooks.commandMarkers.length = 0;\n\n\t\tconst initialCommandStartMarker =\n\t\t\t(this._capability.currentCommand.commandStartMarker = (\n\t\t\t\tthis._capability.currentCommand.promptStartMarker\n\t\t\t\t\t? cloneMarker(\n\t\t\t\t\t\t\tthis._terminal,\n\t\t\t\t\t\t\tthis._capability.currentCommand.promptStartMarker,\n\t\t\t\t\t\t)\n\t\t\t\t\t: this._terminal.registerMarker(0)\n\t\t\t)!);\n\t\tthis._capability.currentCommand.commandStartX = 0;\n\n\t\t// DEBUG: Add a decoration for the original unadjusted command start position\n\t\t// if ('registerDecoration' in this._terminal) {\n\t\t// \tconst d = (this._terminal as any).registerDecoration({\n\t\t// \t\tmarker: this._capability.currentCommand.commandStartMarker,\n\t\t// \t\tx: this._capability.currentCommand.commandStartX\n\t\t// \t});\n\t\t// \td?.onRender((e: HTMLElement) => {\n\t\t// \t\te.textContent = 'b';\n\t\t// \t\te.classList.add('xterm-sequence-decoration', 'top', 'right');\n\t\t// \t\te.title = 'Initial command start position';\n\t\t// \t});\n\t\t// }\n\n\t\t// The command started sequence may be printed before the actual prompt is, for example a\n\t\t// multi-line prompt will typically look like this where D, A and B signify the command\n\t\t// finished, prompt started and command started sequences respectively:\n\t\t//\n\t\t//     D/my/cwdB\n\t\t//     > C\n\t\t//\n\t\t// Due to this, it's likely that this will be called before the line has been parsed.\n\t\t// Unfortunately, it is also the case that the actual command start data may not be parsed\n\t\t// by the end of the task either, so a microtask cannot be used.\n\t\t//\n\t\t// The strategy used is to begin polling and scanning downwards for up to the next 5 lines.\n\t\t// If it looks like a prompt is found, the command started location is adjusted. If the\n\t\t// command executed sequences comes in before polling is done, polling is canceled and the\n\t\t// final polling task is executed synchronously.\n\t\tthis._tryAdjustCommandStartMarkerScannedLineCount = 0;\n\t\tthis._tryAdjustCommandStartMarkerPollCount = 0;\n\t\tthis._tryAdjustCommandStartMarkerScheduler = new RunOnceScheduler(\n\t\t\t() => this._tryAdjustCommandStartMarker(initialCommandStartMarker),\n\t\t\tAdjustCommandStartMarkerConstants.Interval,\n\t\t);\n\t\tthis._tryAdjustCommandStartMarkerScheduler.schedule();\n\n\t\t// TODO: Cache details about polling for the future - eg. if it always fails, stop bothering\n\t}\n\n\tprivate _tryAdjustCommandStartMarker(start: IMarker) {\n\t\tif (this._store.isDisposed) {\n\t\t\treturn;\n\t\t}\n\t\tconst buffer = this._terminal.buffer.active;\n\t\tlet scannedLineCount =\n\t\t\tthis._tryAdjustCommandStartMarkerScannedLineCount;\n\t\twhile (\n\t\t\tscannedLineCount <\n\t\t\t\tAdjustCommandStartMarkerConstants.MaxCheckLineCount &&\n\t\t\tstart.line + scannedLineCount < buffer.baseY + this._terminal.rows\n\t\t) {\n\t\t\tif (this._cursorOnNextLine()) {\n\t\t\t\tconst prompt = this._getWindowsPrompt(\n\t\t\t\t\tstart.line + scannedLineCount,\n\t\t\t\t);\n\t\t\t\tif (prompt) {\n\t\t\t\t\tconst adjustedPrompt =\n\t\t\t\t\t\ttypeof prompt === \"string\" ? prompt : prompt.prompt;\n\t\t\t\t\tthis._capability.currentCommand.commandStartMarker =\n\t\t\t\t\t\tthis._terminal.registerMarker(0)!;\n\t\t\t\t\tif (typeof prompt === \"object\" && prompt.likelySingleLine) {\n\t\t\t\t\t\tthis._logService.debug(\n\t\t\t\t\t\t\t\"CommandDetectionCapability#_tryAdjustCommandStartMarker adjusted promptStart\",\n\t\t\t\t\t\t\t`${this._capability.currentCommand.promptStartMarker?.line} -> ${this._capability.currentCommand.commandStartMarker.line}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tthis._capability.currentCommand.promptStartMarker?.dispose();\n\t\t\t\t\t\tthis._capability.currentCommand.promptStartMarker =\n\t\t\t\t\t\t\tcloneMarker(\n\t\t\t\t\t\t\t\tthis._terminal,\n\t\t\t\t\t\t\t\tthis._capability.currentCommand\n\t\t\t\t\t\t\t\t\t.commandStartMarker,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t// Adjust the last command if it's not in the same position as the following\n\t\t\t\t\t\t// prompt start marker\n\t\t\t\t\t\tconst lastCommand = this._capability.commands.at(-1);\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tlastCommand &&\n\t\t\t\t\t\t\tthis._capability.currentCommand.commandStartMarker\n\t\t\t\t\t\t\t\t.line !== lastCommand.endMarker?.line\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tlastCommand.endMarker?.dispose();\n\t\t\t\t\t\t\tlastCommand.endMarker = cloneMarker(\n\t\t\t\t\t\t\t\tthis._terminal,\n\t\t\t\t\t\t\t\tthis._capability.currentCommand\n\t\t\t\t\t\t\t\t\t.commandStartMarker,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// use the regex to set the position as it's possible input has occurred\n\t\t\t\t\tthis._capability.currentCommand.commandStartX =\n\t\t\t\t\t\tadjustedPrompt.length;\n\t\t\t\t\tthis._logService.debug(\n\t\t\t\t\t\t\"CommandDetectionCapability#_tryAdjustCommandStartMarker adjusted commandStart\",\n\t\t\t\t\t\t`${start.line} -> ${this._capability.currentCommand.commandStartMarker.line}:${this._capability.currentCommand.commandStartX}`,\n\t\t\t\t\t);\n\t\t\t\t\tthis._flushPendingHandleCommandStartTask();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscannedLineCount++;\n\t\t}\n\t\tif (\n\t\t\tscannedLineCount <\n\t\t\tAdjustCommandStartMarkerConstants.MaxCheckLineCount\n\t\t) {\n\t\t\tthis._tryAdjustCommandStartMarkerScannedLineCount =\n\t\t\t\tscannedLineCount;\n\t\t\tif (\n\t\t\t\t++this._tryAdjustCommandStartMarkerPollCount <\n\t\t\t\tAdjustCommandStartMarkerConstants.MaximumPollCount\n\t\t\t) {\n\t\t\t\tthis._tryAdjustCommandStartMarkerScheduler?.schedule();\n\t\t\t} else {\n\t\t\t\tthis._flushPendingHandleCommandStartTask();\n\t\t\t}\n\t\t} else {\n\t\t\tthis._flushPendingHandleCommandStartTask();\n\t\t}\n\t}\n\n\tprivate _flushPendingHandleCommandStartTask() {\n\t\t// Perform final try adjust if necessary\n\t\tif (this._tryAdjustCommandStartMarkerScheduler) {\n\t\t\t// Max out poll count to ensure it's the last run\n\t\t\tthis._tryAdjustCommandStartMarkerPollCount =\n\t\t\t\tAdjustCommandStartMarkerConstants.MaximumPollCount;\n\t\t\tthis._tryAdjustCommandStartMarkerScheduler.flush();\n\t\t\tthis._tryAdjustCommandStartMarkerScheduler = undefined;\n\t\t}\n\n\t\tthis._hooks.commitCommandFinished();\n\n\t\tif (!this._capability.currentCommand.commandExecutedMarker) {\n\t\t\tthis._onCursorMoveListener.value = this._terminal.onCursorMove(\n\t\t\t\t() => {\n\t\t\t\t\tif (\n\t\t\t\t\t\tthis._hooks.commandMarkers.length === 0 ||\n\t\t\t\t\t\tthis._hooks.commandMarkers[\n\t\t\t\t\t\t\tthis._hooks.commandMarkers.length - 1\n\t\t\t\t\t\t].line !== this._terminal.buffer.active.cursorY\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst marker = this._terminal.registerMarker(0);\n\t\t\t\t\t\tif (marker) {\n\t\t\t\t\t\t\tthis._hooks.commandMarkers.push(marker);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t);\n\t\t}\n\n\t\tif (this._capability.currentCommand.commandStartMarker) {\n\t\t\tconst line = this._terminal.buffer.active.getLine(\n\t\t\t\tthis._capability.currentCommand.commandStartMarker.line,\n\t\t\t);\n\t\t\tif (line) {\n\t\t\t\tthis._capability.currentCommand.commandStartLineContent =\n\t\t\t\t\tline.translateToString(true);\n\t\t\t}\n\t\t}\n\t\tthis._hooks.onCommandStartedEmitter.fire({\n\t\t\tmarker: this._capability.currentCommand.commandStartMarker,\n\t\t} as ITerminalCommand);\n\t\tthis._logService.debug(\n\t\t\t\"CommandDetectionCapability#_handleCommandStartWindows\",\n\t\t\tthis._capability.currentCommand.commandStartX,\n\t\t\tthis._capability.currentCommand.commandStartMarker?.line,\n\t\t);\n\t}\n\n\thandleCommandExecuted(options: IHandleCommandOptions | undefined) {\n\t\tif (this._tryAdjustCommandStartMarkerScheduler) {\n\t\t\tthis._flushPendingHandleCommandStartTask();\n\t\t}\n\t\t// Use the gathered cursor move markers to correct the command start and executed markers\n\t\tthis._onCursorMoveListener.clear();\n\t\tthis._evaluateCommandMarkers();\n\t\tthis._capability.currentCommand.commandExecutedX =\n\t\t\tthis._terminal.buffer.active.cursorX;\n\t\tthis._hooks.onCommandExecutedEmitter.fire(\n\t\t\tthis._capability.currentCommand as ITerminalCommand,\n\t\t);\n\t\tthis._logService.debug(\n\t\t\t\"CommandDetectionCapability#handleCommandExecuted\",\n\t\t\tthis._capability.currentCommand.commandExecutedX,\n\t\t\tthis._capability.currentCommand.commandExecutedMarker?.line,\n\t\t);\n\t}\n\n\tpreHandleCommandFinished() {\n\t\tif (this._capability.currentCommand.commandExecutedMarker) {\n\t\t\treturn;\n\t\t}\n\t\t// This is done on command finished just in case command executed never happens (for example\n\t\t// PSReadLine tab completion)\n\t\tif (this._hooks.commandMarkers.length === 0) {\n\t\t\t// If the command start timeout doesn't happen before command finished, just use the\n\t\t\t// current marker.\n\t\t\tif (!this._capability.currentCommand.commandStartMarker) {\n\t\t\t\tthis._capability.currentCommand.commandStartMarker =\n\t\t\t\t\tthis._terminal.registerMarker(0);\n\t\t\t}\n\t\t\tif (this._capability.currentCommand.commandStartMarker) {\n\t\t\t\tthis._hooks.commandMarkers.push(\n\t\t\t\t\tthis._capability.currentCommand.commandStartMarker,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tthis._evaluateCommandMarkers();\n\t}\n\n\tpostHandleCommandFinished(): void {\n\t\tconst currentCommand = this._capability.currentCommand;\n\t\tconst commandText = currentCommand.command;\n\t\tconst commandLine = currentCommand.commandStartMarker?.line;\n\t\tconst executedLine = currentCommand.commandExecutedMarker?.line;\n\t\tif (\n\t\t\t!commandText ||\n\t\t\tcommandText.length === 0 ||\n\t\t\tcommandLine === undefined ||\n\t\t\tcommandLine === -1 ||\n\t\t\texecutedLine === undefined ||\n\t\t\texecutedLine === -1\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Scan downwards from the command start line and search for every character in the actual\n\t\t// command line. This may end up matching the wrong characters, but it shouldn't matter at\n\t\t// least in the typical case as the entire command will still get matched.\n\t\tlet current = 0;\n\t\tlet found = false;\n\t\tfor (let i = commandLine; i <= executedLine; i++) {\n\t\t\tconst line = this._terminal.buffer.active.getLine(i);\n\t\t\tif (!line) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst text = line.translateToString(true);\n\t\t\tfor (let j = 0; j < text.length; j++) {\n\t\t\t\t// Skip whitespace in case it was not actually rendered or could be trimmed from the\n\t\t\t\t// end of the line\n\t\t\t\twhile (\n\t\t\t\t\tcommandText.length < current &&\n\t\t\t\t\tcommandText[current] === \" \"\n\t\t\t\t) {\n\t\t\t\t\tcurrent++;\n\t\t\t\t}\n\n\t\t\t\t// Character match\n\t\t\t\tif (text[j] === commandText[current]) {\n\t\t\t\t\tcurrent++;\n\t\t\t\t}\n\n\t\t\t\t// Full command match\n\t\t\t\tif (current === commandText.length) {\n\t\t\t\t\t// It's ambiguous whether the command executed marker should ideally appear at\n\t\t\t\t\t// the end of the line or at the beginning of the next line. Since it's more\n\t\t\t\t\t// useful for extracting the command at the end of the current line we go with\n\t\t\t\t\t// that.\n\t\t\t\t\tconst wrapsToNextLine = j >= this._terminal.cols - 1;\n\t\t\t\t\tcurrentCommand.commandExecutedMarker =\n\t\t\t\t\t\tthis._terminal.registerMarker(\n\t\t\t\t\t\t\ti -\n\t\t\t\t\t\t\t\t(this._terminal.buffer.active.baseY +\n\t\t\t\t\t\t\t\t\tthis._terminal.buffer.active.cursorY) +\n\t\t\t\t\t\t\t\t(wrapsToNextLine ? 1 : 0),\n\t\t\t\t\t\t);\n\t\t\t\t\tcurrentCommand.commandExecutedX = wrapsToNextLine\n\t\t\t\t\t\t? 0\n\t\t\t\t\t\t: j + 1;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _evaluateCommandMarkers(): void {\n\t\t// On Windows, use the gathered cursor move markers to correct the command start and\n\t\t// executed markers.\n\t\tif (this._hooks.commandMarkers.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tthis._hooks.commandMarkers = this._hooks.commandMarkers.sort(\n\t\t\t(a, b) => a.line - b.line,\n\t\t);\n\t\tthis._capability.currentCommand.commandStartMarker =\n\t\t\tthis._hooks.commandMarkers[0];\n\t\tif (this._capability.currentCommand.commandStartMarker) {\n\t\t\tconst line = this._terminal.buffer.active.getLine(\n\t\t\t\tthis._capability.currentCommand.commandStartMarker.line,\n\t\t\t);\n\t\t\tif (line) {\n\t\t\t\tthis._capability.currentCommand.commandStartLineContent =\n\t\t\t\t\tline.translateToString(true);\n\t\t\t}\n\t\t}\n\t\tthis._capability.currentCommand.commandExecutedMarker =\n\t\t\tthis._hooks.commandMarkers[this._hooks.commandMarkers.length - 1];\n\t\t// Fire this now to prevent issues like #197409\n\t\tthis._hooks.onCommandExecutedEmitter.fire(\n\t\t\tthis._capability.currentCommand as ITerminalCommand,\n\t\t);\n\t}\n\n\tprivate _cursorOnNextLine(): boolean {\n\t\tconst lastCommand = this._capability.commands.at(-1);\n\n\t\t// There is only a single command, so this check is unnecessary\n\t\tif (!lastCommand) {\n\t\t\treturn true;\n\t\t}\n\n\t\tconst cursorYAbsolute =\n\t\t\tthis._terminal.buffer.active.baseY +\n\t\t\tthis._terminal.buffer.active.cursorY;\n\t\t// If the cursor position is within the last command, we should poll.\n\t\tconst lastCommandYAbsolute =\n\t\t\t(lastCommand.endMarker\n\t\t\t\t? lastCommand.endMarker.line\n\t\t\t\t: lastCommand.marker?.line) ?? -1;\n\t\treturn cursorYAbsolute > lastCommandYAbsolute;\n\t}\n\n\tprivate _waitForCursorMove(): Promise<void> {\n\t\tconst cursorX = this._terminal.buffer.active.cursorX;\n\t\tconst cursorY = this._terminal.buffer.active.cursorY;\n\t\tlet totalDelay = 0;\n\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\tconst interval = setInterval(() => {\n\t\t\t\tif (\n\t\t\t\t\tcursorX !== this._terminal.buffer.active.cursorX ||\n\t\t\t\t\tcursorY !== this._terminal.buffer.active.cursorY\n\t\t\t\t) {\n\t\t\t\t\tresolve();\n\t\t\t\t\tclearInterval(interval);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttotalDelay += 10;\n\t\t\t\tif (totalDelay > 1000) {\n\t\t\t\t\tclearInterval(interval);\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t}, 10);\n\t\t});\n\t}\n\n\tprivate _getWindowsPrompt(\n\t\ty: number = this._terminal.buffer.active.baseY +\n\t\t\tthis._terminal.buffer.active.cursorY,\n\t): string | { prompt: string; likelySingleLine: true } | undefined {\n\t\tconst line = this._terminal.buffer.active.getLine(y);\n\t\tif (!line) {\n\t\t\treturn;\n\t\t}\n\t\tconst lineText = line.translateToString(true);\n\t\tif (!lineText) {\n\t\t\treturn;\n\t\t}\n\n\t\t// PowerShell\n\t\tconst pwshPrompt = lineText.match(/(?<prompt>(\\(.+\\)\\s)?(?:PS.+>\\s?))/)\n\t\t\t?.groups?.prompt;\n\t\tif (pwshPrompt) {\n\t\t\tconst adjustedPrompt = this._adjustPrompt(\n\t\t\t\tpwshPrompt,\n\t\t\t\tlineText,\n\t\t\t\t\">\",\n\t\t\t);\n\t\t\tif (adjustedPrompt) {\n\t\t\t\treturn {\n\t\t\t\t\tprompt: adjustedPrompt,\n\t\t\t\t\tlikelySingleLine: true,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t// Custom prompts like starship end in the common \\u276f character\n\t\tconst customPrompt = lineText.match(/.*\\u276f(?=[^\\u276f]*$)/g)?.[0];\n\t\tif (customPrompt) {\n\t\t\tconst adjustedPrompt = this._adjustPrompt(\n\t\t\t\tcustomPrompt,\n\t\t\t\tlineText,\n\t\t\t\t\"\\u276f\",\n\t\t\t);\n\t\t\tif (adjustedPrompt) {\n\t\t\t\treturn adjustedPrompt;\n\t\t\t}\n\t\t}\n\n\t\t// Bash Prompt\n\t\tconst bashPrompt = lineText.match(/^(?<prompt>\\$)/)?.groups?.prompt;\n\t\tif (bashPrompt) {\n\t\t\tconst adjustedPrompt = this._adjustPrompt(\n\t\t\t\tbashPrompt,\n\t\t\t\tlineText,\n\t\t\t\t\"$\",\n\t\t\t);\n\t\t\tif (adjustedPrompt) {\n\t\t\t\treturn adjustedPrompt;\n\t\t\t}\n\t\t}\n\n\t\t// Python Prompt\n\t\tconst pythonPrompt =\n\t\t\tlineText.match(/^(?<prompt>>>> )/g)?.groups?.prompt;\n\t\tif (pythonPrompt) {\n\t\t\treturn {\n\t\t\t\tprompt: pythonPrompt,\n\t\t\t\tlikelySingleLine: true,\n\t\t\t};\n\t\t}\n\n\t\t// Dynamic prompt detection\n\t\tif (\n\t\t\tthis._capability.promptTerminator &&\n\t\t\tlineText.trim().endsWith(this._capability.promptTerminator)\n\t\t) {\n\t\t\tconst adjustedPrompt = this._adjustPrompt(\n\t\t\t\tlineText,\n\t\t\t\tlineText,\n\t\t\t\tthis._capability.promptTerminator,\n\t\t\t);\n\t\t\tif (adjustedPrompt) {\n\t\t\t\treturn adjustedPrompt;\n\t\t\t}\n\t\t}\n\n\t\t// Command Prompt\n\t\tconst cmdMatch = lineText.match(\n\t\t\t/^(?<prompt>(\\(.+\\)\\s)?(?:[A-Z]:\\\\.*>))/,\n\t\t);\n\t\treturn cmdMatch?.groups?.prompt\n\t\t\t? {\n\t\t\t\t\tprompt: cmdMatch.groups.prompt,\n\t\t\t\t\tlikelySingleLine: true,\n\t\t\t\t}\n\t\t\t: undefined;\n\t}\n\n\tprivate _adjustPrompt(\n\t\tprompt: string | undefined,\n\t\tlineText: string,\n\t\tchar: string,\n\t): string | undefined {\n\t\tif (!prompt) {\n\t\t\treturn;\n\t\t}\n\t\t// Conpty may not 'render' the space at the end of the prompt\n\t\tif (lineText === prompt && prompt.endsWith(char)) {\n\t\t\tprompt += \" \";\n\t\t}\n\t\treturn prompt;\n\t}\n}\n\nexport function getLinesForCommand(\n\tbuffer: IBuffer,\n\tcommand: ITerminalCommand,\n\tcols: number,\n\toutputMatcher?: ITerminalOutputMatcher,\n): string[] | undefined {\n\tif (!outputMatcher) {\n\t\treturn undefined;\n\t}\n\tconst executedMarker = command.executedMarker;\n\tconst endMarker = command.endMarker;\n\tif (!executedMarker || !endMarker) {\n\t\treturn undefined;\n\t}\n\tconst startLine = executedMarker.line;\n\tconst endLine = endMarker.line;\n\n\tconst linesToCheck = outputMatcher.length;\n\tconst lines: string[] = [];\n\tif (outputMatcher.anchor === \"bottom\") {\n\t\tfor (\n\t\t\tlet i = endLine - (outputMatcher.offset || 0);\n\t\t\ti >= startLine;\n\t\t\ti--\n\t\t) {\n\t\t\tlet wrappedLineStart = i;\n\t\t\tconst wrappedLineEnd = i;\n\t\t\twhile (\n\t\t\t\twrappedLineStart >= startLine &&\n\t\t\t\tbuffer.getLine(wrappedLineStart)?.isWrapped\n\t\t\t) {\n\t\t\t\twrappedLineStart--;\n\t\t\t}\n\t\t\ti = wrappedLineStart;\n\t\t\tlines.unshift(\n\t\t\t\tgetXtermLineContent(\n\t\t\t\t\tbuffer,\n\t\t\t\t\twrappedLineStart,\n\t\t\t\t\twrappedLineEnd,\n\t\t\t\t\tcols,\n\t\t\t\t),\n\t\t\t);\n\t\t\tif (lines.length > linesToCheck) {\n\t\t\t\tlines.pop();\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (\n\t\t\tlet i = startLine + (outputMatcher.offset || 0);\n\t\t\ti < endLine;\n\t\t\ti++\n\t\t) {\n\t\t\tconst wrappedLineStart = i;\n\t\t\tlet wrappedLineEnd = i;\n\t\t\twhile (\n\t\t\t\twrappedLineEnd + 1 < endLine &&\n\t\t\t\tbuffer.getLine(wrappedLineEnd + 1)?.isWrapped\n\t\t\t) {\n\t\t\t\twrappedLineEnd++;\n\t\t\t}\n\t\t\ti = wrappedLineEnd;\n\t\t\tlines.push(\n\t\t\t\tgetXtermLineContent(\n\t\t\t\t\tbuffer,\n\t\t\t\t\twrappedLineStart,\n\t\t\t\t\twrappedLineEnd,\n\t\t\t\t\tcols,\n\t\t\t\t),\n\t\t\t);\n\t\t\tif (lines.length === linesToCheck) {\n\t\t\t\tlines.shift();\n\t\t\t}\n\t\t}\n\t}\n\treturn lines;\n}\n\nfunction getXtermLineContent(\n\tbuffer: IBuffer,\n\tlineStart: number,\n\tlineEnd: number,\n\tcols: number,\n): string {\n\t// Cap the maximum number of lines generated to prevent potential performance problems. This is\n\t// more of a sanity check as the wrapped line should already be trimmed down at this point.\n\tconst maxLineLength = Math.max((2048 / cols) * 2);\n\tlineEnd = Math.min(lineEnd, lineStart + maxLineLength);\n\tlet content = \"\";\n\tfor (let i = lineStart; i <= lineEnd; i++) {\n\t\t// Make sure only 0 to cols are considered as resizing when windows mode is enabled will\n\t\t// retain buffer data outside of the terminal width as reflow is disabled.\n\t\tconst line = buffer.getLine(i);\n\t\tif (line) {\n\t\t\tcontent += line.translateToString(true, 0, cols);\n\t\t}\n\t}\n\treturn content;\n}\n\nfunction cloneMarker(\n\txterm: Terminal,\n\tmarker: IXtermMarker,\n\toffset = 0,\n): IXtermMarker | undefined {\n\treturn xterm.registerMarker(\n\t\tmarker.line -\n\t\t\t(xterm.buffer.active.baseY + xterm.buffer.active.cursorY) +\n\t\t\toffset,\n\t);\n}\n"],
  "mappings": "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",
  "names": ["value", "AdjustCommandStartMarkerConstants"]
}
