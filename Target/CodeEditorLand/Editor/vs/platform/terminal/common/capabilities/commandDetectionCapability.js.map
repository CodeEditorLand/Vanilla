{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/terminal/common/capabilities/commandDetectionCapability.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\nimport { debounce } from '../../../../base/common/decorators.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable, MandatoryMutableDisposable, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { ILogService } from '../../../log/common/log.js';\nimport { CommandInvalidationReason, ICommandDetectionCapability, ICommandInvalidationRequest, IHandleCommandOptions, ISerializedCommandDetectionCapability, ISerializedTerminalCommand, ITerminalCommand, IXtermMarker, TerminalCapability } from './capabilities.js';\nimport { ITerminalOutputMatcher } from '../terminal.js';\nimport { ICurrentPartialCommand, PartialTerminalCommand, TerminalCommand } from './commandDetection/terminalCommand.js';\nimport { PromptInputModel, type IPromptInputModel } from './commandDetection/promptInputModel.js';\nimport type { IBuffer, IDisposable, IMarker, Terminal } from '@xterm/headless';\n\ninterface ITerminalDimensions {\n\tcols: number;\n\trows: number;\n}\n\nexport class CommandDetectionCapability extends Disposable implements ICommandDetectionCapability {\n\treadonly type = TerminalCapability.CommandDetection;\n\n\tprivate readonly _promptInputModel: PromptInputModel;\n\tget promptInputModel(): IPromptInputModel { return this._promptInputModel; }\n\n\tprotected _commands: TerminalCommand[] = [];\n\tprivate _cwd: string | undefined;\n\tprivate _promptTerminator: string | undefined;\n\tprivate _currentCommand: PartialTerminalCommand = new PartialTerminalCommand(this._terminal);\n\tprivate _commandMarkers: IMarker[] = [];\n\tprivate _dimensions: ITerminalDimensions;\n\tprivate __isCommandStorageDisabled: boolean = false;\n\tprivate _handleCommandStartOptions?: IHandleCommandOptions;\n\n\tprivate _commitCommandFinished?: RunOnceScheduler;\n\n\tprivate _ptyHeuristicsHooks: ICommandDetectionHeuristicsHooks;\n\tprivate readonly _ptyHeuristics: MandatoryMutableDisposable<IPtyHeuristics>;\n\n\tget commands(): readonly TerminalCommand[] { return this._commands; }\n\tget executingCommand(): string | undefined { return this._currentCommand.command; }\n\t// TODO: as is unsafe here and it duplicates behavor of executingCommand\n\tget executingCommandObject(): ITerminalCommand | undefined {\n\t\tif (this._currentCommand.commandStartMarker) {\n\t\t\treturn { marker: this._currentCommand.commandStartMarker } as ITerminalCommand;\n\t\t}\n\t\treturn undefined;\n\t}\n\tget currentCommand(): ICurrentPartialCommand {\n\t\treturn this._currentCommand;\n\t}\n\tget cwd(): string | undefined { return this._cwd; }\n\tget promptTerminator(): string | undefined { return this._promptTerminator; }\n\n\tprivate readonly _onCommandStarted = this._register(new Emitter<ITerminalCommand>());\n\treadonly onCommandStarted = this._onCommandStarted.event;\n\tprivate readonly _onBeforeCommandFinished = this._register(new Emitter<ITerminalCommand>());\n\treadonly onBeforeCommandFinished = this._onBeforeCommandFinished.event;\n\tprivate readonly _onCommandFinished = this._register(new Emitter<ITerminalCommand>());\n\treadonly onCommandFinished = this._onCommandFinished.event;\n\tprivate readonly _onCommandExecuted = this._register(new Emitter<ITerminalCommand>());\n\treadonly onCommandExecuted = this._onCommandExecuted.event;\n\tprivate readonly _onCommandInvalidated = this._register(new Emitter<ITerminalCommand[]>());\n\treadonly onCommandInvalidated = this._onCommandInvalidated.event;\n\tprivate readonly _onCurrentCommandInvalidated = this._register(new Emitter<ICommandInvalidationRequest>());\n\treadonly onCurrentCommandInvalidated = this._onCurrentCommandInvalidated.event;\n\n\tconstructor(\n\t\tprivate readonly _terminal: Terminal,\n\t\t@ILogService private readonly _logService: ILogService\n\t) {\n\t\tsuper();\n\n\t\tthis._promptInputModel = this._register(new PromptInputModel(this._terminal, this.onCommandStarted, this.onCommandExecuted, this._logService));\n\n\t\t// Pull command line from the buffer if it was not set explicitly\n\t\tthis._register(this.onCommandExecuted(command => {\n\t\t\tif (command.commandLineConfidence !== 'high') {\n\t\t\t\t// HACK: onCommandExecuted actually fired with PartialTerminalCommand\n\t\t\t\tconst typedCommand = (command as ITerminalCommand | PartialTerminalCommand);\n\t\t\t\tcommand.command = typedCommand.extractCommandLine();\n\t\t\t\tcommand.commandLineConfidence = 'low';\n\n\t\t\t\t// ITerminalCommand\n\t\t\t\tif ('getOutput' in typedCommand) {\n\t\t\t\t\tif (\n\t\t\t\t\t\t// Markers exist\n\t\t\t\t\t\ttypedCommand.promptStartMarker && typedCommand.marker && typedCommand.executedMarker &&\n\t\t\t\t\t\t// Single line command\n\t\t\t\t\t\tcommand.command.indexOf('\\n') === -1 &&\n\t\t\t\t\t\t// Start marker is not on the left-most column\n\t\t\t\t\t\ttypedCommand.startX !== undefined && typedCommand.startX > 0\n\t\t\t\t\t) {\n\t\t\t\t\t\tcommand.commandLineConfidence = 'medium';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// PartialTerminalCommand\n\t\t\t\telse {\n\t\t\t\t\tif (\n\t\t\t\t\t\t// Markers exist\n\t\t\t\t\t\ttypedCommand.promptStartMarker && typedCommand.commandStartMarker && typedCommand.commandExecutedMarker &&\n\t\t\t\t\t\t// Single line command\n\t\t\t\t\t\tcommand.command.indexOf('\\n') === -1 &&\n\t\t\t\t\t\t// Start marker is not on the left-most column\n\t\t\t\t\t\ttypedCommand.commandStartX !== undefined && typedCommand.commandStartX > 0\n\t\t\t\t\t) {\n\t\t\t\t\t\tcommand.commandLineConfidence = 'medium';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\n\t\t// Set up platform-specific behaviors\n\t\tconst that = this;\n\t\tthis._ptyHeuristicsHooks = new class implements ICommandDetectionHeuristicsHooks {\n\t\t\tget onCurrentCommandInvalidatedEmitter() { return that._onCurrentCommandInvalidated; }\n\t\t\tget onCommandStartedEmitter() { return that._onCommandStarted; }\n\t\t\tget onCommandExecutedEmitter() { return that._onCommandExecuted; }\n\t\t\tget dimensions() { return that._dimensions; }\n\t\t\tget isCommandStorageDisabled() { return that.__isCommandStorageDisabled; }\n\t\t\tget commandMarkers() { return that._commandMarkers; }\n\t\t\tset commandMarkers(value) { that._commandMarkers = value; }\n\t\t\tget clearCommandsInViewport() { return that._clearCommandsInViewport.bind(that); }\n\t\t\tcommitCommandFinished() {\n\t\t\t\tthat._commitCommandFinished?.flush();\n\t\t\t\tthat._commitCommandFinished = undefined;\n\t\t\t}\n\t\t};\n\t\tthis._ptyHeuristics = this._register(new MandatoryMutableDisposable(new UnixPtyHeuristics(this._terminal, this, this._ptyHeuristicsHooks, this._logService)));\n\n\t\tthis._dimensions = {\n\t\t\tcols: this._terminal.cols,\n\t\t\trows: this._terminal.rows\n\t\t};\n\t\tthis._register(this._terminal.onResize(e => this._handleResize(e)));\n\t\tthis._register(this._terminal.onCursorMove(() => this._handleCursorMove()));\n\t}\n\n\tprivate _handleResize(e: { cols: number; rows: number }) {\n\t\tthis._ptyHeuristics.value.preHandleResize?.(e);\n\t\tthis._dimensions.cols = e.cols;\n\t\tthis._dimensions.rows = e.rows;\n\t}\n\n\t@debounce(500)\n\tprivate _handleCursorMove() {\n\t\tif (this._store.isDisposed) {\n\t\t\treturn;\n\t\t}\n\t\t// Early versions of conpty do not have real support for an alt buffer, in addition certain\n\t\t// commands such as tsc watch will write to the top of the normal buffer. The following\n\t\t// checks when the cursor has moved while the normal buffer is empty and if it is above the\n\t\t// current command, all decorations within the viewport will be invalidated.\n\t\t//\n\t\t// This function is debounced so that the cursor is only checked when it is stable so\n\t\t// conpty's screen reprinting will not trigger decoration clearing.\n\t\t//\n\t\t// This is mostly a workaround for Windows but applies to all OS' because of the tsc watch\n\t\t// case.\n\t\tif (this._terminal.buffer.active === this._terminal.buffer.normal && this._currentCommand.commandStartMarker) {\n\t\t\tif (this._terminal.buffer.active.baseY + this._terminal.buffer.active.cursorY < this._currentCommand.commandStartMarker.line) {\n\t\t\t\tthis._clearCommandsInViewport();\n\t\t\t\tthis._currentCommand.isInvalid = true;\n\t\t\t\tthis._onCurrentCommandInvalidated.fire({ reason: CommandInvalidationReason.Windows });\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _clearCommandsInViewport(): void {\n\t\t// Find the number of commands on the tail end of the array that are within the viewport\n\t\tlet count = 0;\n\t\tfor (let i = this._commands.length - 1; i >= 0; i--) {\n\t\t\tconst line = this._commands[i].marker?.line;\n\t\t\tif (line && line < this._terminal.buffer.active.baseY) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\t// Remove them\n\t\tif (count > 0) {\n\t\t\tthis._onCommandInvalidated.fire(this._commands.splice(this._commands.length - count, count));\n\t\t}\n\t}\n\n\tsetContinuationPrompt(value: string): void {\n\t\tthis._promptInputModel.setContinuationPrompt(value);\n\t}\n\n\t// TODO: Simplify this, can everything work off the last line?\n\tsetPromptTerminator(promptTerminator: string, lastPromptLine: string) {\n\t\tthis._logService.debug('CommandDetectionCapability#setPromptTerminator', promptTerminator);\n\t\tthis._promptTerminator = promptTerminator;\n\t\tthis._promptInputModel.setLastPromptLine(lastPromptLine);\n\t}\n\n\tsetCwd(value: string) {\n\t\tthis._cwd = value;\n\t}\n\n\tsetIsWindowsPty(value: boolean) {\n\t\tif (value && !(this._ptyHeuristics.value instanceof WindowsPtyHeuristics)) {\n\t\t\tconst that = this;\n\t\t\tthis._ptyHeuristics.value = new WindowsPtyHeuristics(\n\t\t\t\tthis._terminal,\n\t\t\t\tthis,\n\t\t\t\tnew class {\n\t\t\t\t\tget onCurrentCommandInvalidatedEmitter() { return that._onCurrentCommandInvalidated; }\n\t\t\t\t\tget onCommandStartedEmitter() { return that._onCommandStarted; }\n\t\t\t\t\tget onCommandExecutedEmitter() { return that._onCommandExecuted; }\n\t\t\t\t\tget dimensions() { return that._dimensions; }\n\t\t\t\t\tget isCommandStorageDisabled() { return that.__isCommandStorageDisabled; }\n\t\t\t\t\tget commandMarkers() { return that._commandMarkers; }\n\t\t\t\t\tset commandMarkers(value) { that._commandMarkers = value; }\n\t\t\t\t\tget clearCommandsInViewport() { return that._clearCommandsInViewport.bind(that); }\n\t\t\t\t\tcommitCommandFinished() {\n\t\t\t\t\t\tthat._commitCommandFinished?.flush();\n\t\t\t\t\t\tthat._commitCommandFinished = undefined;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tthis._logService\n\t\t\t);\n\t\t} else if (!value && !(this._ptyHeuristics.value instanceof UnixPtyHeuristics)) {\n\t\t\tthis._ptyHeuristics.value = new UnixPtyHeuristics(this._terminal, this, this._ptyHeuristicsHooks, this._logService);\n\t\t}\n\t}\n\n\tsetIsCommandStorageDisabled(): void {\n\t\tthis.__isCommandStorageDisabled = true;\n\t}\n\n\tgetCommandForLine(line: number): ITerminalCommand | ICurrentPartialCommand | undefined {\n\t\t// Handle the current partial command first, anything below it's prompt is considered part\n\t\t// of the current command\n\t\tif (this._currentCommand.promptStartMarker && line >= this._currentCommand.promptStartMarker?.line) {\n\t\t\treturn this._currentCommand;\n\t\t}\n\n\t\t// No commands\n\t\tif (this._commands.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Line is before any registered commands\n\t\tif ((this._commands[0].promptStartMarker ?? this._commands[0].marker!).line > line) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Iterate backwards through commands to find the right one\n\t\tfor (let i = this.commands.length - 1; i >= 0; i--) {\n\t\t\tif ((this.commands[i].promptStartMarker ?? this.commands[i].marker!).line <= line) {\n\t\t\t\treturn this.commands[i];\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tgetCwdForLine(line: number): string | undefined {\n\t\t// Handle the current partial command first, anything below it's prompt is considered part\n\t\t// of the current command\n\t\tif (this._currentCommand.promptStartMarker && line >= this._currentCommand.promptStartMarker?.line) {\n\t\t\treturn this._cwd;\n\t\t}\n\n\t\tconst command = this.getCommandForLine(line);\n\t\tif (command && 'cwd' in command) {\n\t\t\treturn command.cwd;\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\thandlePromptStart(options?: IHandleCommandOptions): void {\n\t\t// Adjust the last command's finished marker when needed. The standard position for the\n\t\t// finished marker `D` to appear is at the same position as the following prompt started\n\t\t// `A`.\n\t\tconst lastCommand = this.commands.at(-1);\n\t\tif (lastCommand?.endMarker && lastCommand?.executedMarker && lastCommand.endMarker.line === lastCommand.executedMarker.line) {\n\t\t\tthis._logService.debug('CommandDetectionCapability#handlePromptStart adjusted commandFinished', `${lastCommand.endMarker.line} -> ${lastCommand.executedMarker.line + 1}`);\n\t\t\tlastCommand.endMarker = cloneMarker(this._terminal, lastCommand.executedMarker, 1);\n\t\t}\n\n\t\tthis._currentCommand.promptStartMarker = options?.marker || (lastCommand?.endMarker ? cloneMarker(this._terminal, lastCommand.endMarker) : this._terminal.registerMarker(0));\n\n\t\tthis._logService.debug('CommandDetectionCapability#handlePromptStart', this._terminal.buffer.active.cursorX, this._currentCommand.promptStartMarker?.line);\n\t}\n\n\thandleContinuationStart(): void {\n\t\tthis._currentCommand.currentContinuationMarker = this._terminal.registerMarker(0);\n\t\tthis._logService.debug('CommandDetectionCapability#handleContinuationStart', this._currentCommand.currentContinuationMarker);\n\t}\n\n\thandleContinuationEnd(): void {\n\t\tif (!this._currentCommand.currentContinuationMarker) {\n\t\t\tthis._logService.warn('CommandDetectionCapability#handleContinuationEnd Received continuation end without start');\n\t\t\treturn;\n\t\t}\n\t\tif (!this._currentCommand.continuations) {\n\t\t\tthis._currentCommand.continuations = [];\n\t\t}\n\t\tthis._currentCommand.continuations.push({\n\t\t\tmarker: this._currentCommand.currentContinuationMarker,\n\t\t\tend: this._terminal.buffer.active.cursorX\n\t\t});\n\t\tthis._currentCommand.currentContinuationMarker = undefined;\n\t\tthis._logService.debug('CommandDetectionCapability#handleContinuationEnd', this._currentCommand.continuations[this._currentCommand.continuations.length - 1]);\n\t}\n\n\thandleRightPromptStart(): void {\n\t\tthis._currentCommand.commandRightPromptStartX = this._terminal.buffer.active.cursorX;\n\t\tthis._logService.debug('CommandDetectionCapability#handleRightPromptStart', this._currentCommand.commandRightPromptStartX);\n\t}\n\n\thandleRightPromptEnd(): void {\n\t\tthis._currentCommand.commandRightPromptEndX = this._terminal.buffer.active.cursorX;\n\t\tthis._logService.debug('CommandDetectionCapability#handleRightPromptEnd', this._currentCommand.commandRightPromptEndX);\n\t}\n\n\thandleCommandStart(options?: IHandleCommandOptions): void {\n\t\tthis._handleCommandStartOptions = options;\n\t\tthis._currentCommand.cwd = this._cwd;\n\t\t// Only update the column if the line has already been set\n\t\tthis._currentCommand.commandStartMarker = options?.marker || this._currentCommand.commandStartMarker;\n\t\tif (this._currentCommand.commandStartMarker?.line === this._terminal.buffer.active.cursorY) {\n\t\t\tthis._currentCommand.commandStartX = this._terminal.buffer.active.cursorX;\n\t\t\tthis._logService.debug('CommandDetectionCapability#handleCommandStart', this._currentCommand.commandStartX, this._currentCommand.commandStartMarker?.line);\n\t\t\treturn;\n\t\t}\n\t\tthis._ptyHeuristics.value.handleCommandStart(options);\n\t}\n\n\thandleGenericCommand(options?: IHandleCommandOptions): void {\n\t\tif (options?.markProperties?.disableCommandStorage) {\n\t\t\tthis.setIsCommandStorageDisabled();\n\t\t}\n\t\tthis.handlePromptStart(options);\n\t\tthis.handleCommandStart(options);\n\t\tthis.handleCommandExecuted(options);\n\t\tthis.handleCommandFinished(undefined, options);\n\t}\n\n\thandleCommandExecuted(options?: IHandleCommandOptions): void {\n\t\tthis._ptyHeuristics.value.handleCommandExecuted(options);\n\t\tthis._currentCommand.markExecutedTime();\n\t}\n\n\thandleCommandFinished(exitCode: number | undefined, options?: IHandleCommandOptions): void {\n\t\tthis._currentCommand.markFinishedTime();\n\t\tthis._ptyHeuristics.value.preHandleCommandFinished?.();\n\n\t\tthis._logService.debug('CommandDetectionCapability#handleCommandFinished', this._terminal.buffer.active.cursorX, options?.marker?.line, this._currentCommand.command, this._currentCommand);\n\n\t\t// HACK: Handle a special case on some versions of bash where identical commands get merged\n\t\t// in the output of `history`, this detects that case and sets the exit code to the the last\n\t\t// command's exit code. This covered the majority of cases but will fail if the same command\n\t\t// runs with a different exit code, that will need a more robust fix where we send the\n\t\t// command ID and exit code over to the capability to adjust there.\n\t\tif (exitCode === undefined) {\n\t\t\tconst lastCommand = this.commands.length > 0 ? this.commands[this.commands.length - 1] : undefined;\n\t\t\tif (this._currentCommand.command && this._currentCommand.command.length > 0 && lastCommand?.command === this._currentCommand.command) {\n\t\t\t\texitCode = lastCommand.exitCode;\n\t\t\t}\n\t\t}\n\n\t\tif (this._currentCommand.commandStartMarker === undefined || !this._terminal.buffer.active) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._currentCommand.commandFinishedMarker = options?.marker || this._terminal.registerMarker(0);\n\n\t\tthis._ptyHeuristics.value.postHandleCommandFinished?.();\n\n\t\tconst newCommand = this._currentCommand.promoteToFullCommand(this._cwd, exitCode, this._handleCommandStartOptions?.ignoreCommandLine ?? false, options?.markProperties);\n\n\t\tif (newCommand) {\n\t\t\tthis._commands.push(newCommand);\n\t\t\tthis._commitCommandFinished = new RunOnceScheduler(() => {\n\t\t\t\tthis._onBeforeCommandFinished.fire(newCommand);\n\t\t\t\tif (!this._currentCommand.isInvalid) {\n\t\t\t\t\tthis._logService.debug('CommandDetectionCapability#onCommandFinished', newCommand);\n\t\t\t\t\tthis._onCommandFinished.fire(newCommand);\n\t\t\t\t}\n\t\t\t}, 50);\n\t\t\tthis._commitCommandFinished.schedule();\n\t\t}\n\t\tthis._currentCommand = new PartialTerminalCommand(this._terminal);\n\t\tthis._handleCommandStartOptions = undefined;\n\t}\n\n\tsetCommandLine(commandLine: string, isTrusted: boolean) {\n\t\tthis._logService.debug('CommandDetectionCapability#setCommandLine', commandLine, isTrusted);\n\t\tthis._currentCommand.command = commandLine;\n\t\tthis._currentCommand.commandLineConfidence = 'high';\n\t\tthis._currentCommand.isTrusted = isTrusted;\n\n\t\tif (isTrusted) {\n\t\t\tthis._promptInputModel.setConfidentCommandLine(commandLine);\n\t\t}\n\t}\n\n\tserialize(): ISerializedCommandDetectionCapability {\n\t\tconst commands: ISerializedTerminalCommand[] = this.commands.map(e => e.serialize(this.__isCommandStorageDisabled));\n\t\tconst partialCommand = this._currentCommand.serialize(this._cwd);\n\t\tif (partialCommand) {\n\t\t\tcommands.push(partialCommand);\n\t\t}\n\t\treturn {\n\t\t\tisWindowsPty: this._ptyHeuristics.value instanceof WindowsPtyHeuristics,\n\t\t\tcommands,\n\t\t\tpromptInputModel: this._promptInputModel.serialize(),\n\t\t};\n\t}\n\n\tdeserialize(serialized: ISerializedCommandDetectionCapability): void {\n\t\tif (serialized.isWindowsPty) {\n\t\t\tthis.setIsWindowsPty(serialized.isWindowsPty);\n\t\t}\n\t\tconst buffer = this._terminal.buffer.normal;\n\t\tfor (const e of serialized.commands) {\n\t\t\t// Partial command\n\t\t\tif (!e.endLine) {\n\t\t\t\t// Check for invalid command\n\t\t\t\tconst marker = e.startLine !== undefined ? this._terminal.registerMarker(e.startLine - (buffer.baseY + buffer.cursorY)) : undefined;\n\t\t\t\tif (!marker) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tthis._currentCommand.commandStartMarker = e.startLine !== undefined ? this._terminal.registerMarker(e.startLine - (buffer.baseY + buffer.cursorY)) : undefined;\n\t\t\t\tthis._currentCommand.commandStartX = e.startX;\n\t\t\t\tthis._currentCommand.promptStartMarker = e.promptStartLine !== undefined ? this._terminal.registerMarker(e.promptStartLine - (buffer.baseY + buffer.cursorY)) : undefined;\n\t\t\t\tthis._cwd = e.cwd;\n\t\t\t\tthis._onCommandStarted.fire({ marker } as ITerminalCommand);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Full command\n\t\t\tconst newCommand = TerminalCommand.deserialize(this._terminal, e, this.__isCommandStorageDisabled);\n\t\t\tif (!newCommand) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis._commands.push(newCommand);\n\t\t\tthis._logService.debug('CommandDetectionCapability#onCommandFinished', newCommand);\n\t\t\tthis._onCommandFinished.fire(newCommand);\n\t\t}\n\t\tif (serialized.promptInputModel) {\n\t\t\tthis._promptInputModel.deserialize(serialized.promptInputModel);\n\t\t}\n\t}\n}\n\n/**\n * Additional hooks to private methods on {@link CommandDetectionCapability} that are needed by the\n * heuristics objects.\n */\ninterface ICommandDetectionHeuristicsHooks {\n\treadonly onCurrentCommandInvalidatedEmitter: Emitter<ICommandInvalidationRequest>;\n\treadonly onCommandStartedEmitter: Emitter<ITerminalCommand>;\n\treadonly onCommandExecutedEmitter: Emitter<ITerminalCommand>;\n\treadonly dimensions: ITerminalDimensions;\n\treadonly isCommandStorageDisabled: boolean;\n\n\tcommandMarkers: IMarker[];\n\n\tclearCommandsInViewport(): void;\n\tcommitCommandFinished(): void;\n}\n\ntype IPtyHeuristics = (\n\t// All optional methods\n\tPartial<UnixPtyHeuristics> & Partial<WindowsPtyHeuristics> &\n\t// All common methods\n\t(UnixPtyHeuristics | WindowsPtyHeuristics) &\n\tIDisposable\n);\n\n/**\n * Non-Windows-specific behavior.\n */\nclass UnixPtyHeuristics extends Disposable {\n\tconstructor(\n\t\tprivate readonly _terminal: Terminal,\n\t\tprivate readonly _capability: CommandDetectionCapability,\n\t\tprivate readonly _hooks: ICommandDetectionHeuristicsHooks,\n\t\tprivate readonly _logService: ILogService\n\t) {\n\t\tsuper();\n\t\tthis._register(_terminal.parser.registerCsiHandler({ final: 'J' }, params => {\n\t\t\tif (params.length >= 1 && (params[0] === 2 || params[0] === 3)) {\n\t\t\t\t_hooks.clearCommandsInViewport();\n\t\t\t}\n\t\t\t// We don't want to override xterm.js' default behavior, just augment it\n\t\t\treturn false;\n\t\t}));\n\t}\n\n\thandleCommandStart(options?: IHandleCommandOptions) {\n\t\tthis._hooks.commitCommandFinished();\n\n\t\tconst currentCommand = this._capability.currentCommand;\n\t\tcurrentCommand.commandStartX = this._terminal.buffer.active.cursorX;\n\t\tcurrentCommand.commandStartMarker = options?.marker || this._terminal.registerMarker(0);\n\n\t\t// Clear executed as it must happen after command start\n\t\tcurrentCommand.commandExecutedMarker?.dispose();\n\t\tcurrentCommand.commandExecutedMarker = undefined;\n\t\tcurrentCommand.commandExecutedX = undefined;\n\t\tfor (const m of this._hooks.commandMarkers) {\n\t\t\tm.dispose();\n\t\t}\n\t\tthis._hooks.commandMarkers.length = 0;\n\n\t\tthis._hooks.onCommandStartedEmitter.fire({ marker: options?.marker || currentCommand.commandStartMarker, markProperties: options?.markProperties } as ITerminalCommand);\n\t\tthis._logService.debug('CommandDetectionCapability#handleCommandStart', currentCommand.commandStartX, currentCommand.commandStartMarker?.line);\n\t}\n\n\thandleCommandExecuted(options?: IHandleCommandOptions) {\n\t\tconst currentCommand = this._capability.currentCommand;\n\t\tcurrentCommand.commandExecutedMarker = options?.marker || this._terminal.registerMarker(0);\n\t\tcurrentCommand.commandExecutedX = this._terminal.buffer.active.cursorX;\n\t\tthis._logService.debug('CommandDetectionCapability#handleCommandExecuted', currentCommand.commandExecutedX, currentCommand.commandExecutedMarker?.line);\n\n\t\t// Sanity check optional props\n\t\tif (!currentCommand.commandStartMarker || !currentCommand.commandExecutedMarker || currentCommand.commandStartX === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Calculate the command\n\t\tcurrentCommand.command = this._hooks.isCommandStorageDisabled ? '' : this._terminal.buffer.active.getLine(currentCommand.commandStartMarker.line)?.translateToString(true, currentCommand.commandStartX, currentCommand.commandRightPromptStartX).trim();\n\t\tlet y = currentCommand.commandStartMarker.line + 1;\n\t\tconst commandExecutedLine = currentCommand.commandExecutedMarker.line;\n\t\tfor (; y < commandExecutedLine; y++) {\n\t\t\tconst line = this._terminal.buffer.active.getLine(y);\n\t\t\tif (line) {\n\t\t\t\tconst continuation = currentCommand.continuations?.find(e => e.marker.line === y);\n\t\t\t\tif (continuation) {\n\t\t\t\t\tcurrentCommand.command += '\\n';\n\t\t\t\t}\n\t\t\t\tconst startColumn = continuation?.end ?? 0;\n\t\t\t\tcurrentCommand.command += line.translateToString(true, startColumn);\n\t\t\t}\n\t\t}\n\t\tif (y === commandExecutedLine) {\n\t\t\tcurrentCommand.command += this._terminal.buffer.active.getLine(commandExecutedLine)?.translateToString(true, undefined, currentCommand.commandExecutedX) || '';\n\t\t}\n\t\tthis._hooks.onCommandExecutedEmitter.fire(currentCommand as ITerminalCommand);\n\t}\n}\n\nconst enum AdjustCommandStartMarkerConstants {\n\tMaxCheckLineCount = 10,\n\tInterval = 20,\n\tMaximumPollCount = 10,\n}\n\n/**\n * An object that integrated with and decorates the command detection capability to add heuristics\n * that adjust various markers to work better with Windows and ConPTY. This isn't depended upon the\n * frontend OS, or even the backend OS, but the `IsWindows` property which technically a non-Windows\n * client can emit (for example in tests).\n */\nclass WindowsPtyHeuristics extends Disposable {\n\n\tprivate readonly _onCursorMoveListener = this._register(new MutableDisposable());\n\n\tprivate _tryAdjustCommandStartMarkerScheduler?: RunOnceScheduler;\n\tprivate _tryAdjustCommandStartMarkerScannedLineCount: number = 0;\n\tprivate _tryAdjustCommandStartMarkerPollCount: number = 0;\n\n\tconstructor(\n\t\tprivate readonly _terminal: Terminal,\n\t\tprivate readonly _capability: CommandDetectionCapability,\n\t\tprivate readonly _hooks: ICommandDetectionHeuristicsHooks,\n\t\t@ILogService private readonly _logService: ILogService,\n\t) {\n\t\tsuper();\n\n\t\tthis._register(_terminal.parser.registerCsiHandler({ final: 'J' }, params => {\n\t\t\t// Clear commands when the viewport is cleared\n\t\t\tif (params.length >= 1 && (params[0] === 2 || params[0] === 3)) {\n\t\t\t\tthis._hooks.clearCommandsInViewport();\n\t\t\t}\n\t\t\t// We don't want to override xterm.js' default behavior, just augment it\n\t\t\treturn false;\n\t\t}));\n\n\t\tthis._register(this._capability.onBeforeCommandFinished(command => {\n\t\t\t// For older Windows backends we cannot listen to CSI J, instead we assume running clear\n\t\t\t// or cls will clear all commands in the viewport. This is not perfect but it's right\n\t\t\t// most of the time.\n\t\t\tif (command.command.trim().toLowerCase() === 'clear' || command.command.trim().toLowerCase() === 'cls') {\n\t\t\t\tthis._tryAdjustCommandStartMarkerScheduler?.cancel();\n\t\t\t\tthis._tryAdjustCommandStartMarkerScheduler = undefined;\n\t\t\t\tthis._hooks.clearCommandsInViewport();\n\t\t\t\tthis._capability.currentCommand.isInvalid = true;\n\t\t\t\tthis._hooks.onCurrentCommandInvalidatedEmitter.fire({ reason: CommandInvalidationReason.Windows });\n\t\t\t}\n\t\t}));\n\t}\n\n\tpreHandleResize(e: { cols: number; rows: number }) {\n\t\t// Resize behavior is different under conpty; instead of bringing parts of the scrollback\n\t\t// back into the viewport, new lines are inserted at the bottom (ie. the same behavior as if\n\t\t// there was no scrollback).\n\t\t//\n\t\t// On resize this workaround will wait for a conpty reprint to occur by waiting for the\n\t\t// cursor to move, it will then calculate the number of lines that the commands within the\n\t\t// viewport _may have_ shifted. After verifying the content of the current line is\n\t\t// incorrect, the line after shifting is checked and if that matches delete events are fired\n\t\t// on the xterm.js buffer to move the markers.\n\t\t//\n\t\t// While a bit hacky, this approach is quite safe and seems to work great at least for pwsh.\n\t\tconst baseY = this._terminal.buffer.active.baseY;\n\t\tconst rowsDifference = e.rows - this._hooks.dimensions.rows;\n\t\t// Only do when rows increase, do in the next frame as this needs to happen after\n\t\t// conpty reprints the screen\n\t\tif (rowsDifference > 0) {\n\t\t\tthis._waitForCursorMove().then(() => {\n\t\t\t\t// Calculate the number of lines the content may have shifted, this will max out at\n\t\t\t\t// scrollback count since the standard behavior will be used then\n\t\t\t\tconst potentialShiftedLineCount = Math.min(rowsDifference, baseY);\n\t\t\t\t// For each command within the viewport, assume commands are in the correct order\n\t\t\t\tfor (let i = this._capability.commands.length - 1; i >= 0; i--) {\n\t\t\t\t\tconst command = this._capability.commands[i];\n\t\t\t\t\tif (!command.marker || command.marker.line < baseY || command.commandStartLineContent === undefined) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst line = this._terminal.buffer.active.getLine(command.marker.line);\n\t\t\t\t\tif (!line || line.translateToString(true) === command.commandStartLineContent) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tconst shiftedY = command.marker.line - potentialShiftedLineCount;\n\t\t\t\t\tconst shiftedLine = this._terminal.buffer.active.getLine(shiftedY);\n\t\t\t\t\tif (shiftedLine?.translateToString(true) !== command.commandStartLineContent) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// HACK: xterm.js doesn't expose this by design as it's an internal core\n\t\t\t\t\t// function an embedder could easily do damage with. Additionally, this\n\t\t\t\t\t// can't really be upstreamed since the event relies on shell integration to\n\t\t\t\t\t// verify the shifting is necessary.\n\t\t\t\t\t(this._terminal as any)._core._bufferService.buffer.lines.onDeleteEmitter.fire({\n\t\t\t\t\t\tindex: this._terminal.buffer.active.baseY,\n\t\t\t\t\t\tamount: potentialShiftedLineCount\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\thandleCommandStart() {\n\t\tthis._capability.currentCommand.commandStartX = this._terminal.buffer.active.cursorX;\n\n\t\t// On Windows track all cursor movements after the command start sequence\n\t\tthis._hooks.commandMarkers.length = 0;\n\n\t\tconst initialCommandStartMarker = this._capability.currentCommand.commandStartMarker = (\n\t\t\tthis._capability.currentCommand.promptStartMarker\n\t\t\t\t? cloneMarker(this._terminal, this._capability.currentCommand.promptStartMarker)\n\t\t\t\t: this._terminal.registerMarker(0)\n\t\t)!;\n\t\tthis._capability.currentCommand.commandStartX = 0;\n\n\t\t// DEBUG: Add a decoration for the original unadjusted command start position\n\t\t// if ('registerDecoration' in this._terminal) {\n\t\t// \tconst d = (this._terminal as any).registerDecoration({\n\t\t// \t\tmarker: this._capability.currentCommand.commandStartMarker,\n\t\t// \t\tx: this._capability.currentCommand.commandStartX\n\t\t// \t});\n\t\t// \td?.onRender((e: HTMLElement) => {\n\t\t// \t\te.textContent = 'b';\n\t\t// \t\te.classList.add('xterm-sequence-decoration', 'top', 'right');\n\t\t// \t\te.title = 'Initial command start position';\n\t\t// \t});\n\t\t// }\n\n\t\t// The command started sequence may be printed before the actual prompt is, for example a\n\t\t// multi-line prompt will typically look like this where D, A and B signify the command\n\t\t// finished, prompt started and command started sequences respectively:\n\t\t//\n\t\t//     D/my/cwdB\n\t\t//     > C\n\t\t//\n\t\t// Due to this, it's likely that this will be called before the line has been parsed.\n\t\t// Unfortunately, it is also the case that the actual command start data may not be parsed\n\t\t// by the end of the task either, so a microtask cannot be used.\n\t\t//\n\t\t// The strategy used is to begin polling and scanning downwards for up to the next 5 lines.\n\t\t// If it looks like a prompt is found, the command started location is adjusted. If the\n\t\t// command executed sequences comes in before polling is done, polling is canceled and the\n\t\t// final polling task is executed synchronously.\n\t\tthis._tryAdjustCommandStartMarkerScannedLineCount = 0;\n\t\tthis._tryAdjustCommandStartMarkerPollCount = 0;\n\t\tthis._tryAdjustCommandStartMarkerScheduler = new RunOnceScheduler(() => this._tryAdjustCommandStartMarker(initialCommandStartMarker), AdjustCommandStartMarkerConstants.Interval);\n\t\tthis._tryAdjustCommandStartMarkerScheduler.schedule();\n\n\t\t// TODO: Cache details about polling for the future - eg. if it always fails, stop bothering\n\t}\n\n\tprivate _tryAdjustCommandStartMarker(start: IMarker) {\n\t\tif (this._store.isDisposed) {\n\t\t\treturn;\n\t\t}\n\t\tconst buffer = this._terminal.buffer.active;\n\t\tlet scannedLineCount = this._tryAdjustCommandStartMarkerScannedLineCount;\n\t\twhile (scannedLineCount < AdjustCommandStartMarkerConstants.MaxCheckLineCount && start.line + scannedLineCount < buffer.baseY + this._terminal.rows) {\n\t\t\tif (this._cursorOnNextLine()) {\n\t\t\t\tconst prompt = this._getWindowsPrompt(start.line + scannedLineCount);\n\t\t\t\tif (prompt) {\n\t\t\t\t\tconst adjustedPrompt = typeof prompt === 'string' ? prompt : prompt.prompt;\n\t\t\t\t\tthis._capability.currentCommand.commandStartMarker = this._terminal.registerMarker(0)!;\n\t\t\t\t\tif (typeof prompt === 'object' && prompt.likelySingleLine) {\n\t\t\t\t\t\tthis._logService.debug('CommandDetectionCapability#_tryAdjustCommandStartMarker adjusted promptStart', `${this._capability.currentCommand.promptStartMarker?.line} -> ${this._capability.currentCommand.commandStartMarker.line}`);\n\t\t\t\t\t\tthis._capability.currentCommand.promptStartMarker?.dispose();\n\t\t\t\t\t\tthis._capability.currentCommand.promptStartMarker = cloneMarker(this._terminal, this._capability.currentCommand.commandStartMarker);\n\t\t\t\t\t\t// Adjust the last command if it's not in the same position as the following\n\t\t\t\t\t\t// prompt start marker\n\t\t\t\t\t\tconst lastCommand = this._capability.commands.at(-1);\n\t\t\t\t\t\tif (lastCommand && this._capability.currentCommand.commandStartMarker.line !== lastCommand.endMarker?.line) {\n\t\t\t\t\t\t\tlastCommand.endMarker?.dispose();\n\t\t\t\t\t\t\tlastCommand.endMarker = cloneMarker(this._terminal, this._capability.currentCommand.commandStartMarker);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// use the regex to set the position as it's possible input has occurred\n\t\t\t\t\tthis._capability.currentCommand.commandStartX = adjustedPrompt.length;\n\t\t\t\t\tthis._logService.debug('CommandDetectionCapability#_tryAdjustCommandStartMarker adjusted commandStart', `${start.line} -> ${this._capability.currentCommand.commandStartMarker.line}:${this._capability.currentCommand.commandStartX}`);\n\t\t\t\t\tthis._flushPendingHandleCommandStartTask();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscannedLineCount++;\n\t\t}\n\t\tif (scannedLineCount < AdjustCommandStartMarkerConstants.MaxCheckLineCount) {\n\t\t\tthis._tryAdjustCommandStartMarkerScannedLineCount = scannedLineCount;\n\t\t\tif (++this._tryAdjustCommandStartMarkerPollCount < AdjustCommandStartMarkerConstants.MaximumPollCount) {\n\t\t\t\tthis._tryAdjustCommandStartMarkerScheduler?.schedule();\n\t\t\t} else {\n\t\t\t\tthis._flushPendingHandleCommandStartTask();\n\t\t\t}\n\t\t} else {\n\t\t\tthis._flushPendingHandleCommandStartTask();\n\t\t}\n\t}\n\n\tprivate _flushPendingHandleCommandStartTask() {\n\t\t// Perform final try adjust if necessary\n\t\tif (this._tryAdjustCommandStartMarkerScheduler) {\n\t\t\t// Max out poll count to ensure it's the last run\n\t\t\tthis._tryAdjustCommandStartMarkerPollCount = AdjustCommandStartMarkerConstants.MaximumPollCount;\n\t\t\tthis._tryAdjustCommandStartMarkerScheduler.flush();\n\t\t\tthis._tryAdjustCommandStartMarkerScheduler = undefined;\n\t\t}\n\n\t\tthis._hooks.commitCommandFinished();\n\n\t\tif (!this._capability.currentCommand.commandExecutedMarker) {\n\t\t\tthis._onCursorMoveListener.value = this._terminal.onCursorMove(() => {\n\t\t\t\tif (this._hooks.commandMarkers.length === 0 || this._hooks.commandMarkers[this._hooks.commandMarkers.length - 1].line !== this._terminal.buffer.active.cursorY) {\n\t\t\t\t\tconst marker = this._terminal.registerMarker(0);\n\t\t\t\t\tif (marker) {\n\t\t\t\t\t\tthis._hooks.commandMarkers.push(marker);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tif (this._capability.currentCommand.commandStartMarker) {\n\t\t\tconst line = this._terminal.buffer.active.getLine(this._capability.currentCommand.commandStartMarker.line);\n\t\t\tif (line) {\n\t\t\t\tthis._capability.currentCommand.commandStartLineContent = line.translateToString(true);\n\t\t\t}\n\t\t}\n\t\tthis._hooks.onCommandStartedEmitter.fire({ marker: this._capability.currentCommand.commandStartMarker } as ITerminalCommand);\n\t\tthis._logService.debug('CommandDetectionCapability#_handleCommandStartWindows', this._capability.currentCommand.commandStartX, this._capability.currentCommand.commandStartMarker?.line);\n\t}\n\n\thandleCommandExecuted(options: IHandleCommandOptions | undefined) {\n\t\tif (this._tryAdjustCommandStartMarkerScheduler) {\n\t\t\tthis._flushPendingHandleCommandStartTask();\n\t\t}\n\t\t// Use the gathered cursor move markers to correct the command start and executed markers\n\t\tthis._onCursorMoveListener.clear();\n\t\tthis._evaluateCommandMarkers();\n\t\tthis._capability.currentCommand.commandExecutedX = this._terminal.buffer.active.cursorX;\n\t\tthis._hooks.onCommandExecutedEmitter.fire(this._capability.currentCommand as ITerminalCommand);\n\t\tthis._logService.debug('CommandDetectionCapability#handleCommandExecuted', this._capability.currentCommand.commandExecutedX, this._capability.currentCommand.commandExecutedMarker?.line);\n\t}\n\n\tpreHandleCommandFinished() {\n\t\tif (this._capability.currentCommand.commandExecutedMarker) {\n\t\t\treturn;\n\t\t}\n\t\t// This is done on command finished just in case command executed never happens (for example\n\t\t// PSReadLine tab completion)\n\t\tif (this._hooks.commandMarkers.length === 0) {\n\t\t\t// If the command start timeout doesn't happen before command finished, just use the\n\t\t\t// current marker.\n\t\t\tif (!this._capability.currentCommand.commandStartMarker) {\n\t\t\t\tthis._capability.currentCommand.commandStartMarker = this._terminal.registerMarker(0);\n\t\t\t}\n\t\t\tif (this._capability.currentCommand.commandStartMarker) {\n\t\t\t\tthis._hooks.commandMarkers.push(this._capability.currentCommand.commandStartMarker);\n\t\t\t}\n\t\t}\n\t\tthis._evaluateCommandMarkers();\n\t}\n\n\tpostHandleCommandFinished(): void {\n\t\tconst currentCommand = this._capability.currentCommand;\n\t\tconst commandText = currentCommand.command;\n\t\tconst commandLine = currentCommand.commandStartMarker?.line;\n\t\tconst executedLine = currentCommand.commandExecutedMarker?.line;\n\t\tif (\n\t\t\t!commandText || commandText.length === 0 ||\n\t\t\tcommandLine === undefined || commandLine === -1 ||\n\t\t\texecutedLine === undefined || executedLine === -1\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Scan downwards from the command start line and search for every character in the actual\n\t\t// command line. This may end up matching the wrong characters, but it shouldn't matter at\n\t\t// least in the typical case as the entire command will still get matched.\n\t\tlet current = 0;\n\t\tlet found = false;\n\t\tfor (let i = commandLine; i <= executedLine; i++) {\n\t\t\tconst line = this._terminal.buffer.active.getLine(i);\n\t\t\tif (!line) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst text = line.translateToString(true);\n\t\t\tfor (let j = 0; j < text.length; j++) {\n\t\t\t\t// Skip whitespace in case it was not actually rendered or could be trimmed from the\n\t\t\t\t// end of the line\n\t\t\t\twhile (commandText.length < current && commandText[current] === ' ') {\n\t\t\t\t\tcurrent++;\n\t\t\t\t}\n\n\t\t\t\t// Character match\n\t\t\t\tif (text[j] === commandText[current]) {\n\t\t\t\t\tcurrent++;\n\t\t\t\t}\n\n\t\t\t\t// Full command match\n\t\t\t\tif (current === commandText.length) {\n\t\t\t\t\t// It's ambiguous whether the command executed marker should ideally appear at\n\t\t\t\t\t// the end of the line or at the beginning of the next line. Since it's more\n\t\t\t\t\t// useful for extracting the command at the end of the current line we go with\n\t\t\t\t\t// that.\n\t\t\t\t\tconst wrapsToNextLine = j >= this._terminal.cols - 1;\n\t\t\t\t\tcurrentCommand.commandExecutedMarker = this._terminal.registerMarker(i - (this._terminal.buffer.active.baseY + this._terminal.buffer.active.cursorY) + (wrapsToNextLine ? 1 : 0));\n\t\t\t\t\tcurrentCommand.commandExecutedX = wrapsToNextLine ? 0 : j + 1;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _evaluateCommandMarkers(): void {\n\t\t// On Windows, use the gathered cursor move markers to correct the command start and\n\t\t// executed markers.\n\t\tif (this._hooks.commandMarkers.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tthis._hooks.commandMarkers = this._hooks.commandMarkers.sort((a, b) => a.line - b.line);\n\t\tthis._capability.currentCommand.commandStartMarker = this._hooks.commandMarkers[0];\n\t\tif (this._capability.currentCommand.commandStartMarker) {\n\t\t\tconst line = this._terminal.buffer.active.getLine(this._capability.currentCommand.commandStartMarker.line);\n\t\t\tif (line) {\n\t\t\t\tthis._capability.currentCommand.commandStartLineContent = line.translateToString(true);\n\t\t\t}\n\t\t}\n\t\tthis._capability.currentCommand.commandExecutedMarker = this._hooks.commandMarkers[this._hooks.commandMarkers.length - 1];\n\t\t// Fire this now to prevent issues like #197409\n\t\tthis._hooks.onCommandExecutedEmitter.fire(this._capability.currentCommand as ITerminalCommand);\n\t}\n\n\tprivate _cursorOnNextLine(): boolean {\n\t\tconst lastCommand = this._capability.commands.at(-1);\n\n\t\t// There is only a single command, so this check is unnecessary\n\t\tif (!lastCommand) {\n\t\t\treturn true;\n\t\t}\n\n\t\tconst cursorYAbsolute = this._terminal.buffer.active.baseY + this._terminal.buffer.active.cursorY;\n\t\t// If the cursor position is within the last command, we should poll.\n\t\tconst lastCommandYAbsolute = (lastCommand.endMarker ? lastCommand.endMarker.line : lastCommand.marker?.line) ?? -1;\n\t\treturn cursorYAbsolute > lastCommandYAbsolute;\n\t}\n\n\tprivate _waitForCursorMove(): Promise<void> {\n\t\tconst cursorX = this._terminal.buffer.active.cursorX;\n\t\tconst cursorY = this._terminal.buffer.active.cursorY;\n\t\tlet totalDelay = 0;\n\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\tconst interval = setInterval(() => {\n\t\t\t\tif (cursorX !== this._terminal.buffer.active.cursorX || cursorY !== this._terminal.buffer.active.cursorY) {\n\t\t\t\t\tresolve();\n\t\t\t\t\tclearInterval(interval);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttotalDelay += 10;\n\t\t\t\tif (totalDelay > 1000) {\n\t\t\t\t\tclearInterval(interval);\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t}, 10);\n\t\t});\n\t}\n\n\tprivate _getWindowsPrompt(y: number = this._terminal.buffer.active.baseY + this._terminal.buffer.active.cursorY): string | { prompt: string; likelySingleLine: true } | undefined {\n\t\tconst line = this._terminal.buffer.active.getLine(y);\n\t\tif (!line) {\n\t\t\treturn;\n\t\t}\n\t\tconst lineText = line.translateToString(true);\n\t\tif (!lineText) {\n\t\t\treturn;\n\t\t}\n\n\t\t// PowerShell\n\t\tconst pwshPrompt = lineText.match(/(?<prompt>(\\(.+\\)\\s)?(?:PS.+>\\s?))/)?.groups?.prompt;\n\t\tif (pwshPrompt) {\n\t\t\tconst adjustedPrompt = this._adjustPrompt(pwshPrompt, lineText, '>');\n\t\t\tif (adjustedPrompt) {\n\t\t\t\treturn {\n\t\t\t\t\tprompt: adjustedPrompt,\n\t\t\t\t\tlikelySingleLine: true\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t// Custom prompts like starship end in the common \\u276f character\n\t\tconst customPrompt = lineText.match(/.*\\u276f(?=[^\\u276f]*$)/g)?.[0];\n\t\tif (customPrompt) {\n\t\t\tconst adjustedPrompt = this._adjustPrompt(customPrompt, lineText, '\\u276f');\n\t\t\tif (adjustedPrompt) {\n\t\t\t\treturn adjustedPrompt;\n\t\t\t}\n\t\t}\n\n\t\t// Bash Prompt\n\t\tconst bashPrompt = lineText.match(/^(?<prompt>\\$)/)?.groups?.prompt;\n\t\tif (bashPrompt) {\n\t\t\tconst adjustedPrompt = this._adjustPrompt(bashPrompt, lineText, '$');\n\t\t\tif (adjustedPrompt) {\n\t\t\t\treturn adjustedPrompt;\n\t\t\t}\n\t\t}\n\n\t\t// Python Prompt\n\t\tconst pythonPrompt = lineText.match(/^(?<prompt>>>> )/g)?.groups?.prompt;\n\t\tif (pythonPrompt) {\n\t\t\treturn {\n\t\t\t\tprompt: pythonPrompt,\n\t\t\t\tlikelySingleLine: true\n\t\t\t};\n\t\t}\n\n\t\t// Dynamic prompt detection\n\t\tif (this._capability.promptTerminator && lineText.trim().endsWith(this._capability.promptTerminator)) {\n\t\t\tconst adjustedPrompt = this._adjustPrompt(lineText, lineText, this._capability.promptTerminator);\n\t\t\tif (adjustedPrompt) {\n\t\t\t\treturn adjustedPrompt;\n\t\t\t}\n\t\t}\n\n\t\t// Command Prompt\n\t\tconst cmdMatch = lineText.match(/^(?<prompt>(\\(.+\\)\\s)?(?:[A-Z]:\\\\.*>))/);\n\t\treturn cmdMatch?.groups?.prompt ? {\n\t\t\tprompt: cmdMatch.groups.prompt,\n\t\t\tlikelySingleLine: true\n\t\t} : undefined;\n\t}\n\n\tprivate _adjustPrompt(prompt: string | undefined, lineText: string, char: string): string | undefined {\n\t\tif (!prompt) {\n\t\t\treturn;\n\t\t}\n\t\t// Conpty may not 'render' the space at the end of the prompt\n\t\tif (lineText === prompt && prompt.endsWith(char)) {\n\t\t\tprompt += ' ';\n\t\t}\n\t\treturn prompt;\n\t}\n}\n\nexport function getLinesForCommand(buffer: IBuffer, command: ITerminalCommand, cols: number, outputMatcher?: ITerminalOutputMatcher): string[] | undefined {\n\tif (!outputMatcher) {\n\t\treturn undefined;\n\t}\n\tconst executedMarker = command.executedMarker;\n\tconst endMarker = command.endMarker;\n\tif (!executedMarker || !endMarker) {\n\t\treturn undefined;\n\t}\n\tconst startLine = executedMarker.line;\n\tconst endLine = endMarker.line;\n\n\tconst linesToCheck = outputMatcher.length;\n\tconst lines: string[] = [];\n\tif (outputMatcher.anchor === 'bottom') {\n\t\tfor (let i = endLine - (outputMatcher.offset || 0); i >= startLine; i--) {\n\t\t\tlet wrappedLineStart = i;\n\t\t\tconst wrappedLineEnd = i;\n\t\t\twhile (wrappedLineStart >= startLine && buffer.getLine(wrappedLineStart)?.isWrapped) {\n\t\t\t\twrappedLineStart--;\n\t\t\t}\n\t\t\ti = wrappedLineStart;\n\t\t\tlines.unshift(getXtermLineContent(buffer, wrappedLineStart, wrappedLineEnd, cols));\n\t\t\tif (lines.length > linesToCheck) {\n\t\t\t\tlines.pop();\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (let i = startLine + (outputMatcher.offset || 0); i < endLine; i++) {\n\t\t\tconst wrappedLineStart = i;\n\t\t\tlet wrappedLineEnd = i;\n\t\t\twhile (wrappedLineEnd + 1 < endLine && buffer.getLine(wrappedLineEnd + 1)?.isWrapped) {\n\t\t\t\twrappedLineEnd++;\n\t\t\t}\n\t\t\ti = wrappedLineEnd;\n\t\t\tlines.push(getXtermLineContent(buffer, wrappedLineStart, wrappedLineEnd, cols));\n\t\t\tif (lines.length === linesToCheck) {\n\t\t\t\tlines.shift();\n\t\t\t}\n\t\t}\n\t}\n\treturn lines;\n}\n\nfunction getXtermLineContent(buffer: IBuffer, lineStart: number, lineEnd: number, cols: number): string {\n\t// Cap the maximum number of lines generated to prevent potential performance problems. This is\n\t// more of a sanity check as the wrapped line should already be trimmed down at this point.\n\tconst maxLineLength = Math.max(2048 / cols * 2);\n\tlineEnd = Math.min(lineEnd, lineStart + maxLineLength);\n\tlet content = '';\n\tfor (let i = lineStart; i <= lineEnd; i++) {\n\t\t// Make sure only 0 to cols are considered as resizing when windows mode is enabled will\n\t\t// retain buffer data outside of the terminal width as reflow is disabled.\n\t\tconst line = buffer.getLine(i);\n\t\tif (line) {\n\t\t\tcontent += line.translateToString(true, 0, cols);\n\t\t}\n\t}\n\treturn content;\n}\n\nfunction cloneMarker(xterm: Terminal, marker: IXtermMarker, offset: number = 0): IXtermMarker | undefined {\n\treturn xterm.registerMarker(marker.line - (xterm.buffer.active.baseY + xterm.buffer.active.cursorY) + offset);\n}\n"],
  "mappings": "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",
  "names": ["value", "AdjustCommandStartMarkerConstants"]
}
