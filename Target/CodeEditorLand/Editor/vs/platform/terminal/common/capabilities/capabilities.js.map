{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/terminal/common/capabilities/capabilities.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../../../base/common/event.js';\nimport { IDisposable } from '../../../../base/common/lifecycle.js';\nimport type { IPromptInputModel, ISerializedPromptInputModel } from './commandDetection/promptInputModel.js';\nimport { ICurrentPartialCommand } from './commandDetection/terminalCommand.js';\nimport { ITerminalOutputMatch, ITerminalOutputMatcher } from '../terminal.js';\nimport { ReplayEntry } from '../terminalProcess.js';\n\ninterface IEvent<T, U = void> {\n\t(listener: (arg1: T, arg2: U) => any): IDisposable;\n}\n\nexport interface IMarker extends IDisposable {\n\t/**\n\t * A unique identifier for this marker.\n\t */\n\treadonly id: number;\n\n\t/**\n\t * Whether this marker is disposed.\n\t */\n\treadonly isDisposed: boolean;\n\n\t/**\n\t * The actual line index in the buffer at this point in time. This is set to\n\t * -1 if the marker has been disposed.\n\t */\n\treadonly line: number;\n\n\t/**\n\t * Event listener to get notified when the marker gets disposed. Automatic disposal\n\t * might happen for a marker, that got invalidated by scrolling out or removal of\n\t * a line from the buffer.\n\t */\n\tonDispose: IEvent<void>;\n}\n\n\n/**\n * Primarily driven by the shell integration feature, a terminal capability is the mechanism for\n * progressively enhancing various features that may not be supported in all terminals/shells.\n */\nexport const enum TerminalCapability {\n\t/**\n\t * The terminal can reliably detect the current working directory as soon as the change happens\n\t * within the buffer.\n\t */\n\tCwdDetection,\n\t/**\n\t * The terminal can reliably detect the current working directory when requested.\n\t */\n\tNaiveCwdDetection,\n\t/**\n\t * The terminal can reliably identify prompts, commands and command outputs within the buffer.\n\t */\n\tCommandDetection,\n\t/**\n\t * The terminal can often identify prompts, commands and command outputs within the buffer. It\n\t * may not be so good at remembering the position of commands that ran in the past. This state\n\t * may be enabled when something goes wrong or when using conpty for example.\n\t */\n\tPartialCommandDetection,\n\n\t/**\n\t * Manages buffer marks that can be used for terminal navigation. The source of\n\t * the request (task, debug, etc) provides an ID, optional marker, hoverMessage, and hidden property. When\n\t * hidden is not provided, a generic decoration is added to the buffer and overview ruler.\n\t */\n\tBufferMarkDetection\n}\n\n/**\n * An object that keeps track of additional capabilities and their implementations for features that\n * are not available for all terminals.\n */\nexport interface ITerminalCapabilityStore {\n\t/**\n\t * An iterable of all capabilities in the store.\n\t */\n\treadonly items: IterableIterator<TerminalCapability>;\n\n\t/**\n\t * Fired when a capability is added. The event data for this is only the\n\t * {@link TerminalCapability} type, use {@link onDidAddCapability} to access the actual\n\t * capability.\n\t */\n\treadonly onDidAddCapabilityType: Event<TerminalCapability>;\n\n\t/**\n\t * Fired when a capability is removed. The event data for this is only the\n\t * {@link TerminalCapability} type, use {@link onDidAddCapability} to access the actual\n\t * capability.\n\t */\n\treadonly onDidRemoveCapabilityType: Event<TerminalCapability>;\n\n\t/**\n\t * Fired when a capability is added.\n\t */\n\treadonly onDidAddCapability: Event<TerminalCapabilityChangeEvent<any>>;\n\n\t/**\n\t * Fired when a capability is removed.\n\t */\n\treadonly onDidRemoveCapability: Event<TerminalCapabilityChangeEvent<any>>;\n\n\t/**\n\t * Gets whether the capability exists in the store.\n\t */\n\thas(capability: TerminalCapability): boolean;\n\n\t/**\n\t * Gets the implementation of a capability if it has been added to the store.\n\t */\n\tget<T extends TerminalCapability>(capability: T): ITerminalCapabilityImplMap[T] | undefined;\n}\n\nexport interface TerminalCapabilityChangeEvent<T extends TerminalCapability> {\n\tid: T;\n\tcapability: ITerminalCapabilityImplMap[T];\n}\n\n/**\n * Maps capability types to their implementation, enabling strongly typed fetching of\n * implementations.\n */\nexport interface ITerminalCapabilityImplMap {\n\t[TerminalCapability.CwdDetection]: ICwdDetectionCapability;\n\t[TerminalCapability.CommandDetection]: ICommandDetectionCapability;\n\t[TerminalCapability.NaiveCwdDetection]: INaiveCwdDetectionCapability;\n\t[TerminalCapability.PartialCommandDetection]: IPartialCommandDetectionCapability;\n\t[TerminalCapability.BufferMarkDetection]: IBufferMarkCapability;\n}\n\nexport interface ICwdDetectionCapability {\n\treadonly type: TerminalCapability.CwdDetection;\n\treadonly onDidChangeCwd: Event<string>;\n\treadonly cwds: string[];\n\tgetCwd(): string;\n\tupdateCwd(cwd: string): void;\n}\n\nexport const enum CommandInvalidationReason {\n\tWindows = 'windows',\n\tNoProblemsReported = 'noProblemsReported'\n}\n\nexport interface ICommandInvalidationRequest {\n\treason: CommandInvalidationReason;\n}\n\nexport interface IBufferMarkCapability {\n\ttype: TerminalCapability.BufferMarkDetection;\n\tmarkers(): IterableIterator<IMarker>;\n\tonMarkAdded: Event<IMarkProperties>;\n\taddMark(properties?: IMarkProperties): void;\n\tgetMark(id: string): IMarker | undefined;\n}\n\nexport interface ICommandDetectionCapability {\n\treadonly type: TerminalCapability.CommandDetection;\n\treadonly promptInputModel: IPromptInputModel;\n\treadonly commands: readonly ITerminalCommand[];\n\t/** The command currently being executed, otherwise undefined. */\n\treadonly executingCommand: string | undefined;\n\treadonly executingCommandObject: ITerminalCommand | undefined;\n\t/** The current cwd at the cursor's position. */\n\treadonly cwd: string | undefined;\n\treadonly currentCommand: ICurrentPartialCommand | undefined;\n\treadonly onCommandStarted: Event<ITerminalCommand>;\n\treadonly onCommandFinished: Event<ITerminalCommand>;\n\treadonly onCommandExecuted: Event<ITerminalCommand>;\n\treadonly onCommandInvalidated: Event<ITerminalCommand[]>;\n\treadonly onCurrentCommandInvalidated: Event<ICommandInvalidationRequest>;\n\tsetContinuationPrompt(value: string): void;\n\tsetPromptTerminator(value: string, lastPromptLine: string): void;\n\tsetCwd(value: string): void;\n\tsetIsWindowsPty(value: boolean): void;\n\tsetIsCommandStorageDisabled(): void;\n\t/**\n\t * Gets the working directory for a line, this will return undefined if it's unknown in which\n\t * case the terminal's initial cwd should be used.\n\t */\n\tgetCwdForLine(line: number): string | undefined;\n\tgetCommandForLine(line: number): ITerminalCommand | ICurrentPartialCommand | undefined;\n\thandlePromptStart(options?: IHandleCommandOptions): void;\n\thandleContinuationStart(): void;\n\thandleContinuationEnd(): void;\n\thandleRightPromptStart(): void;\n\thandleRightPromptEnd(): void;\n\thandleCommandStart(options?: IHandleCommandOptions): void;\n\thandleCommandExecuted(options?: IHandleCommandOptions): void;\n\thandleCommandFinished(exitCode?: number, options?: IHandleCommandOptions): void;\n\t/**\n\t * Set the command line explicitly.\n\t * @param commandLine The command line being set.\n\t * @param isTrusted Whether the command line is trusted via the optional nonce is send in order\n\t * to prevent spoofing. This is important as some interactions do not require verification\n\t * before re-running a command. Note that this is optional according to the spec, it should\n\t * always be present when running the _builtin_ SI scripts.\n\t */\n\tsetCommandLine(commandLine: string, isTrusted: boolean): void;\n\tserialize(): ISerializedCommandDetectionCapability;\n\tdeserialize(serialized: ISerializedCommandDetectionCapability): void;\n}\n\nexport interface IHandleCommandOptions {\n\t/**\n\t * Whether to allow an empty command to be registered. This should be used to support certain\n\t * shell integration scripts/features where tracking the command line may not be possible.\n\t */\n\tignoreCommandLine?: boolean;\n\t/**\n\t * The marker to use\n\t */\n\tmarker?: IMarker;\n\n\t/**\n\t * Properties for the mark\n\t */\n\tmarkProperties?: IMarkProperties;\n}\n\nexport interface INaiveCwdDetectionCapability {\n\treadonly type: TerminalCapability.NaiveCwdDetection;\n\treadonly onDidChangeCwd: Event<string>;\n\tgetCwd(): Promise<string>;\n}\n\nexport interface IPartialCommandDetectionCapability {\n\treadonly type: TerminalCapability.PartialCommandDetection;\n\treadonly commands: readonly IXtermMarker[];\n\treadonly onCommandFinished: Event<IXtermMarker>;\n}\n\ninterface IBaseTerminalCommand {\n\t// Mandatory\n\tcommand: string;\n\tcommandLineConfidence: 'low' | 'medium' | 'high';\n\tisTrusted: boolean;\n\ttimestamp: number;\n\tduration: number;\n\n\t// Optional serializable\n\tcwd: string | undefined;\n\texitCode: number | undefined;\n\tcommandStartLineContent: string | undefined;\n\tmarkProperties: IMarkProperties | undefined;\n\texecutedX: number | undefined;\n\tstartX: number | undefined;\n}\n\nexport interface ITerminalCommand extends IBaseTerminalCommand {\n\t// Optional non-serializable\n\treadonly promptStartMarker?: IMarker;\n\treadonly marker?: IXtermMarker;\n\tendMarker?: IXtermMarker;\n\treadonly executedMarker?: IXtermMarker;\n\treadonly aliases?: string[][];\n\treadonly wasReplayed?: boolean;\n\n\textractCommandLine(): string;\n\tgetOutput(): string | undefined;\n\tgetOutputMatch(outputMatcher: ITerminalOutputMatcher): ITerminalOutputMatch | undefined;\n\thasOutput(): boolean;\n\tgetPromptRowCount(): number;\n\tgetCommandRowCount(): number;\n}\n\nexport interface ISerializedTerminalCommand extends IBaseTerminalCommand {\n\t// Optional non-serializable converted for serialization\n\tstartLine: number | undefined;\n\tpromptStartLine: number | undefined;\n\tendLine: number | undefined;\n\texecutedLine: number | undefined;\n}\n\n/**\n * A clone of the IMarker from xterm which cannot be imported from common\n */\nexport interface IXtermMarker {\n\treadonly id: number;\n\treadonly isDisposed: boolean;\n\treadonly line: number;\n\tdispose(): void;\n\tonDispose: {\n\t\t(listener: () => any): { dispose(): void };\n\t};\n}\n\nexport interface IMarkProperties {\n\thoverMessage?: string;\n\tdisableCommandStorage?: boolean;\n\thidden?: boolean;\n\tmarker?: IMarker;\n\tid?: string;\n}\nexport interface ISerializedCommandDetectionCapability {\n\tisWindowsPty: boolean;\n\tcommands: ISerializedTerminalCommand[];\n\tpromptInputModel: ISerializedPromptInputModel | undefined;\n}\nexport interface IPtyHostProcessReplayEvent {\n\tevents: ReplayEntry[];\n\tcommands: ISerializedCommandDetectionCapability;\n}\n"],
  "mappings": "AAKA,SAAS,aAAa;AACtB,SAAS,mBAAmB;AAE5B,SAAS,8BAA8B;AACvC,SAAS,sBAAsB,8BAA8B;AAC7D,SAAS,mBAAmB;AAoCrB,IAAW,qBAAX,kBAAWA,wBAAX;AAKN,EAAAA,wCAAA;AAIA,EAAAA,wCAAA;AAIA,EAAAA,wCAAA;AAMA,EAAAA,wCAAA;AAOA,EAAAA,wCAAA;AA1BiB,SAAAA;AAAA,GAAA;AAmGX,IAAW,4BAAX,kBAAWC,+BAAX;AACN,EAAAA,2BAAA,aAAU;AACV,EAAAA,2BAAA,wBAAqB;AAFJ,SAAAA;AAAA,GAAA;",
  "names": ["TerminalCapability", "CommandInvalidationReason"]
}
