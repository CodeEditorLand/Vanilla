{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/terminal/common/capabilities/commandDetection/terminalCommand.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IMarkProperties, IMarker, ISerializedTerminalCommand, ITerminalCommand, IXtermMarker } from '../capabilities.js';\nimport { ITerminalOutputMatcher, ITerminalOutputMatch } from '../../terminal.js';\nimport type { IBuffer, IBufferLine, Terminal } from '@xterm/headless';\n\nexport interface ITerminalCommandProperties {\n\tcommand: string;\n\tcommandLineConfidence: 'low' | 'medium' | 'high';\n\tisTrusted: boolean;\n\ttimestamp: number;\n\tduration: number;\n\tmarker: IXtermMarker | undefined;\n\tcwd: string | undefined;\n\texitCode: number | undefined;\n\tcommandStartLineContent: string | undefined;\n\tmarkProperties: IMarkProperties | undefined;\n\texecutedX: number | undefined;\n\tstartX: number | undefined;\n\n\tpromptStartMarker?: IMarker | undefined;\n\tendMarker?: IXtermMarker | undefined;\n\texecutedMarker?: IXtermMarker | undefined;\n\taliases?: string[][] | undefined;\n\twasReplayed?: boolean | undefined;\n}\n\nexport class TerminalCommand implements ITerminalCommand {\n\n\tget command() { return this._properties.command; }\n\tget commandLineConfidence() { return this._properties.commandLineConfidence; }\n\tget isTrusted() { return this._properties.isTrusted; }\n\tget timestamp() { return this._properties.timestamp; }\n\tget duration() { return this._properties.duration; }\n\tget promptStartMarker() { return this._properties.promptStartMarker; }\n\tget marker() { return this._properties.marker; }\n\tget endMarker() { return this._properties.endMarker; }\n\tset endMarker(value: IXtermMarker | undefined) { this._properties.endMarker = value; }\n\tget executedMarker() { return this._properties.executedMarker; }\n\tget aliases() { return this._properties.aliases; }\n\tget wasReplayed() { return this._properties.wasReplayed; }\n\tget cwd() { return this._properties.cwd; }\n\tget exitCode() { return this._properties.exitCode; }\n\tget commandStartLineContent() { return this._properties.commandStartLineContent; }\n\tget markProperties() { return this._properties.markProperties; }\n\tget executedX() { return this._properties.executedX; }\n\tget startX() { return this._properties.startX; }\n\n\tconstructor(\n\t\tprivate readonly _xterm: Terminal,\n\t\tprivate readonly _properties: ITerminalCommandProperties,\n\t) {\n\t}\n\n\tstatic deserialize(xterm: Terminal, serialized: ISerializedTerminalCommand & Required<Pick<ISerializedTerminalCommand, 'endLine'>>, isCommandStorageDisabled: boolean): TerminalCommand | undefined {\n\t\tconst buffer = xterm.buffer.normal;\n\t\tconst marker = serialized.startLine !== undefined ? xterm.registerMarker(serialized.startLine - (buffer.baseY + buffer.cursorY)) : undefined;\n\n\t\t// Check for invalid command\n\t\tif (!marker) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst promptStartMarker = serialized.promptStartLine !== undefined ? xterm.registerMarker(serialized.promptStartLine - (buffer.baseY + buffer.cursorY)) : undefined;\n\n\t\t// Valid full command\n\t\tconst endMarker = serialized.endLine !== undefined ? xterm.registerMarker(serialized.endLine - (buffer.baseY + buffer.cursorY)) : undefined;\n\t\tconst executedMarker = serialized.executedLine !== undefined ? xterm.registerMarker(serialized.executedLine - (buffer.baseY + buffer.cursorY)) : undefined;\n\t\tconst newCommand = new TerminalCommand(xterm, {\n\t\t\tcommand: isCommandStorageDisabled ? '' : serialized.command,\n\t\t\tcommandLineConfidence: serialized.commandLineConfidence ?? 'low',\n\t\t\tisTrusted: serialized.isTrusted,\n\t\t\tpromptStartMarker,\n\t\t\tmarker,\n\t\t\tstartX: serialized.startX,\n\t\t\tendMarker,\n\t\t\texecutedMarker,\n\t\t\texecutedX: serialized.executedX,\n\t\t\ttimestamp: serialized.timestamp,\n\t\t\tduration: serialized.duration,\n\t\t\tcwd: serialized.cwd,\n\t\t\tcommandStartLineContent: serialized.commandStartLineContent,\n\t\t\texitCode: serialized.exitCode,\n\t\t\tmarkProperties: serialized.markProperties,\n\t\t\taliases: undefined,\n\t\t\twasReplayed: true\n\t\t});\n\t\treturn newCommand;\n\t}\n\n\tserialize(isCommandStorageDisabled: boolean): ISerializedTerminalCommand {\n\t\treturn {\n\t\t\tpromptStartLine: this.promptStartMarker?.line,\n\t\t\tstartLine: this.marker?.line,\n\t\t\tstartX: undefined,\n\t\t\tendLine: this.endMarker?.line,\n\t\t\texecutedLine: this.executedMarker?.line,\n\t\t\texecutedX: this.executedX,\n\t\t\tcommand: isCommandStorageDisabled ? '' : this.command,\n\t\t\tcommandLineConfidence: isCommandStorageDisabled ? 'low' : this.commandLineConfidence,\n\t\t\tisTrusted: this.isTrusted,\n\t\t\tcwd: this.cwd,\n\t\t\texitCode: this.exitCode,\n\t\t\tcommandStartLineContent: this.commandStartLineContent,\n\t\t\ttimestamp: this.timestamp,\n\t\t\tduration: this.duration,\n\t\t\tmarkProperties: this.markProperties,\n\t\t};\n\t}\n\n\textractCommandLine(): string {\n\t\treturn extractCommandLine(this._xterm.buffer.active, this._xterm.cols, this.marker, this.startX, this.executedMarker, this.executedX);\n\t}\n\n\tgetOutput(): string | undefined {\n\t\tif (!this.executedMarker || !this.endMarker) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst startLine = this.executedMarker.line;\n\t\tconst endLine = this.endMarker.line;\n\n\t\tif (startLine === endLine) {\n\t\t\treturn undefined;\n\t\t}\n\t\tlet output = '';\n\t\tlet line: IBufferLine | undefined;\n\t\tfor (let i = startLine; i < endLine; i++) {\n\t\t\tline = this._xterm.buffer.active.getLine(i);\n\t\t\tif (!line) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\toutput += line.translateToString(!line.isWrapped) + (line.isWrapped ? '' : '\\n');\n\t\t}\n\t\treturn output === '' ? undefined : output;\n\t}\n\n\tgetOutputMatch(outputMatcher: ITerminalOutputMatcher): ITerminalOutputMatch | undefined {\n\t\t// TODO: Add back this check? this._ptyHeuristics.value instanceof WindowsPtyHeuristics && (executedMarker?.line === endMarker?.line) ? this._currentCommand.commandStartMarker : executedMarker\n\t\tif (!this.executedMarker || !this.endMarker) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst endLine = this.endMarker.line;\n\t\tif (endLine === -1) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst buffer = this._xterm.buffer.active;\n\t\tconst startLine = Math.max(this.executedMarker.line, 0);\n\t\tconst matcher = outputMatcher.lineMatcher;\n\t\tconst linesToCheck = typeof matcher === 'string' ? 1 : outputMatcher.length || countNewLines(matcher);\n\t\tconst lines: string[] = [];\n\t\tlet match: RegExpMatchArray | null | undefined;\n\t\tif (outputMatcher.anchor === 'bottom') {\n\t\t\tfor (let i = endLine - (outputMatcher.offset || 0); i >= startLine; i--) {\n\t\t\t\tlet wrappedLineStart = i;\n\t\t\t\tconst wrappedLineEnd = i;\n\t\t\t\twhile (wrappedLineStart >= startLine && buffer.getLine(wrappedLineStart)?.isWrapped) {\n\t\t\t\t\twrappedLineStart--;\n\t\t\t\t}\n\t\t\t\ti = wrappedLineStart;\n\t\t\t\tlines.unshift(getXtermLineContent(buffer, wrappedLineStart, wrappedLineEnd, this._xterm.cols));\n\t\t\t\tif (!match) {\n\t\t\t\t\tmatch = lines[0].match(matcher);\n\t\t\t\t}\n\t\t\t\tif (lines.length >= linesToCheck) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = startLine + (outputMatcher.offset || 0); i < endLine; i++) {\n\t\t\t\tconst wrappedLineStart = i;\n\t\t\t\tlet wrappedLineEnd = i;\n\t\t\t\twhile (wrappedLineEnd + 1 < endLine && buffer.getLine(wrappedLineEnd + 1)?.isWrapped) {\n\t\t\t\t\twrappedLineEnd++;\n\t\t\t\t}\n\t\t\t\ti = wrappedLineEnd;\n\t\t\t\tlines.push(getXtermLineContent(buffer, wrappedLineStart, wrappedLineEnd, this._xterm.cols));\n\t\t\t\tif (!match) {\n\t\t\t\t\tmatch = lines[lines.length - 1].match(matcher);\n\t\t\t\t}\n\t\t\t\tif (lines.length >= linesToCheck) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn match ? { regexMatch: match, outputLines: lines } : undefined;\n\t}\n\n\thasOutput(): boolean {\n\t\treturn (\n\t\t\t!this.executedMarker?.isDisposed &&\n\t\t\t!this.endMarker?.isDisposed &&\n\t\t\t!!(\n\t\t\t\tthis.executedMarker &&\n\t\t\t\tthis.endMarker &&\n\t\t\t\tthis.executedMarker.line < this.endMarker.line\n\t\t\t)\n\t\t);\n\t}\n\n\tgetPromptRowCount(): number {\n\t\treturn getPromptRowCount(this, this._xterm.buffer.active);\n\t}\n\n\tgetCommandRowCount(): number {\n\t\treturn getCommandRowCount(this);\n\t}\n}\n\nexport interface ICurrentPartialCommand {\n\tpromptStartMarker?: IMarker;\n\n\tcommandStartMarker?: IMarker;\n\tcommandStartX?: number;\n\tcommandStartLineContent?: string;\n\n\tcommandRightPromptStartX?: number;\n\tcommandRightPromptEndX?: number;\n\n\tcommandLines?: IMarker;\n\n\tcommandExecutedMarker?: IMarker;\n\tcommandExecutedX?: number;\n\n\tcommandFinishedMarker?: IMarker;\n\n\tcurrentContinuationMarker?: IMarker;\n\tcontinuations?: { marker: IMarker; end: number }[];\n\n\tcommand?: string;\n\n\t/**\n\t * Whether the command line is trusted via a nonce.\n\t */\n\tisTrusted?: boolean;\n\n\t/**\n\t * Something invalidated the command before it finished, this will prevent the onCommandFinished\n\t * event from firing.\n\t */\n\tisInvalid?: boolean;\n\n\tgetPromptRowCount(): number;\n\tgetCommandRowCount(): number;\n}\n\nexport class PartialTerminalCommand implements ICurrentPartialCommand {\n\tpromptStartMarker?: IMarker;\n\n\tcommandStartMarker?: IMarker;\n\tcommandStartX?: number;\n\tcommandStartLineContent?: string;\n\n\tcommandRightPromptStartX?: number;\n\tcommandRightPromptEndX?: number;\n\n\tcommandLines?: IMarker;\n\n\tcommandExecutedMarker?: IMarker;\n\tcommandExecutedX?: number;\n\n\tprivate commandExecutedTimestamp?: number;\n\tprivate commandDuration?: number;\n\n\tcommandFinishedMarker?: IMarker;\n\n\tcurrentContinuationMarker?: IMarker;\n\tcontinuations?: { marker: IMarker; end: number }[];\n\n\tcwd?: string;\n\tcommand?: string;\n\tcommandLineConfidence?: 'low' | 'medium' | 'high';\n\n\tisTrusted?: boolean;\n\tisInvalid?: boolean;\n\n\tconstructor(\n\t\tprivate readonly _xterm: Terminal,\n\t) {\n\t}\n\n\tserialize(cwd: string | undefined): ISerializedTerminalCommand | undefined {\n\t\tif (!this.commandStartMarker) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn {\n\t\t\tpromptStartLine: this.promptStartMarker?.line,\n\t\t\tstartLine: this.commandStartMarker.line,\n\t\t\tstartX: this.commandStartX,\n\t\t\tendLine: undefined,\n\t\t\texecutedLine: undefined,\n\t\t\texecutedX: undefined,\n\t\t\tcommand: '',\n\t\t\tcommandLineConfidence: 'low',\n\t\t\tisTrusted: true,\n\t\t\tcwd,\n\t\t\texitCode: undefined,\n\t\t\tcommandStartLineContent: undefined,\n\t\t\ttimestamp: 0,\n\t\t\tduration: 0,\n\t\t\tmarkProperties: undefined\n\t\t};\n\t}\n\n\tpromoteToFullCommand(cwd: string | undefined, exitCode: number | undefined, ignoreCommandLine: boolean, markProperties: IMarkProperties | undefined): TerminalCommand | undefined {\n\t\t// When the command finishes and executed never fires the placeholder selector should be used.\n\t\tif (exitCode === undefined && this.command === undefined) {\n\t\t\tthis.command = '';\n\t\t}\n\n\t\tif ((this.command !== undefined && !this.command.startsWith('\\\\')) || ignoreCommandLine) {\n\t\t\treturn new TerminalCommand(this._xterm, {\n\t\t\t\tcommand: ignoreCommandLine ? '' : (this.command || ''),\n\t\t\t\tcommandLineConfidence: ignoreCommandLine ? 'low' : (this.commandLineConfidence || 'low'),\n\t\t\t\tisTrusted: !!this.isTrusted,\n\t\t\t\tpromptStartMarker: this.promptStartMarker,\n\t\t\t\tmarker: this.commandStartMarker,\n\t\t\t\tstartX: this.commandStartX,\n\t\t\t\tendMarker: this.commandFinishedMarker,\n\t\t\t\texecutedMarker: this.commandExecutedMarker,\n\t\t\t\texecutedX: this.commandExecutedX,\n\t\t\t\ttimestamp: Date.now(),\n\t\t\t\tduration: this.commandDuration || 0,\n\t\t\t\tcwd,\n\t\t\t\texitCode,\n\t\t\t\tcommandStartLineContent: this.commandStartLineContent,\n\t\t\t\tmarkProperties\n\t\t\t});\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tmarkExecutedTime() {\n\t\tif (this.commandExecutedTimestamp === undefined) {\n\t\t\tthis.commandExecutedTimestamp = Date.now();\n\t\t}\n\t}\n\n\tmarkFinishedTime() {\n\t\tif (this.commandDuration === undefined && this.commandExecutedTimestamp !== undefined) {\n\t\t\tthis.commandDuration = Date.now() - this.commandExecutedTimestamp;\n\t\t}\n\t}\n\n\textractCommandLine(): string {\n\t\treturn extractCommandLine(this._xterm.buffer.active, this._xterm.cols, this.commandStartMarker, this.commandStartX, this.commandExecutedMarker, this.commandExecutedX);\n\t}\n\n\tgetPromptRowCount(): number {\n\t\treturn getPromptRowCount(this, this._xterm.buffer.active);\n\t}\n\n\tgetCommandRowCount(): number {\n\t\treturn getCommandRowCount(this);\n\t}\n}\n\nfunction extractCommandLine(\n\tbuffer: IBuffer,\n\tcols: number,\n\tcommandStartMarker: IXtermMarker | undefined,\n\tcommandStartX: number | undefined,\n\tcommandExecutedMarker: IXtermMarker | undefined,\n\tcommandExecutedX: number | undefined\n): string {\n\tif (!commandStartMarker || !commandExecutedMarker || commandStartX === undefined || commandExecutedX === undefined) {\n\t\treturn '';\n\t}\n\tlet content = '';\n\tfor (let i = commandStartMarker.line; i <= commandExecutedMarker.line; i++) {\n\t\tconst line = buffer.getLine(i);\n\t\tif (line) {\n\t\t\tcontent += line.translateToString(true, i === commandStartMarker.line ? commandStartX : 0, i === commandExecutedMarker.line ? commandExecutedX : cols);\n\t\t}\n\t}\n\treturn content;\n}\n\nfunction getXtermLineContent(buffer: IBuffer, lineStart: number, lineEnd: number, cols: number): string {\n\t// Cap the maximum number of lines generated to prevent potential performance problems. This is\n\t// more of a sanity check as the wrapped line should already be trimmed down at this point.\n\tconst maxLineLength = Math.max(2048 / cols * 2);\n\tlineEnd = Math.min(lineEnd, lineStart + maxLineLength);\n\tlet content = '';\n\tfor (let i = lineStart; i <= lineEnd; i++) {\n\t\t// Make sure only 0 to cols are considered as resizing when windows mode is enabled will\n\t\t// retain buffer data outside of the terminal width as reflow is disabled.\n\t\tconst line = buffer.getLine(i);\n\t\tif (line) {\n\t\t\tcontent += line.translateToString(true, 0, cols);\n\t\t}\n\t}\n\treturn content;\n}\n\nfunction countNewLines(regex: RegExp): number {\n\tif (!regex.multiline) {\n\t\treturn 1;\n\t}\n\tconst source = regex.source;\n\tlet count = 1;\n\tlet i = source.indexOf('\\\\n');\n\twhile (i !== -1) {\n\t\tcount++;\n\t\ti = source.indexOf('\\\\n', i + 1);\n\t}\n\treturn count;\n}\n\nfunction getPromptRowCount(command: ITerminalCommand | ICurrentPartialCommand, buffer: IBuffer): number {\n\tconst marker = 'hasOutput' in command ? command.marker : command.commandStartMarker;\n\tif (!marker || !command.promptStartMarker) {\n\t\treturn 1;\n\t}\n\tlet promptRowCount = 1;\n\tlet promptStartLine = command.promptStartMarker.line;\n\t// Trim any leading whitespace-only lines to retain vertical space\n\twhile (promptStartLine < marker.line && (buffer.getLine(promptStartLine)?.translateToString(true) ?? '').length === 0) {\n\t\tpromptStartLine++;\n\t}\n\tpromptRowCount = marker.line - promptStartLine + 1;\n\treturn promptRowCount;\n}\n\nfunction getCommandRowCount(command: ITerminalCommand | ICurrentPartialCommand): number {\n\tconst marker = 'hasOutput' in command ? command.marker : command.commandStartMarker;\n\tconst executedMarker = 'hasOutput' in command ? command.executedMarker : command.commandExecutedMarker;\n\tif (!marker || !executedMarker) {\n\t\treturn 1;\n\t}\n\tconst commandExecutedLine = Math.max(executedMarker.line, marker.line);\n\tlet commandRowCount = commandExecutedLine - marker.line + 1;\n\t// Trim the last line if the cursor X is in the left-most cell\n\tconst executedX = 'hasOutput' in command ? command.executedX : command.commandExecutedX;\n\tif (executedX === 0) {\n\t\tcommandRowCount--;\n\t}\n\treturn commandRowCount;\n}\n"],
  "mappings": "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",
  "names": []
}
