{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/terminal/common/capabilities/commandDetection/terminalCommand.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { IBuffer, IBufferLine, Terminal } from \"@xterm/headless\";\nimport type {\n\tITerminalOutputMatch,\n\tITerminalOutputMatcher,\n} from \"../../terminal.js\";\nimport type {\n\tIMarkProperties,\n\tIMarker,\n\tISerializedTerminalCommand,\n\tITerminalCommand,\n\tIXtermMarker,\n} from \"../capabilities.js\";\n\nexport interface ITerminalCommandProperties {\n\tcommand: string;\n\tcommandLineConfidence: \"low\" | \"medium\" | \"high\";\n\tisTrusted: boolean;\n\ttimestamp: number;\n\tduration: number;\n\tmarker: IXtermMarker | undefined;\n\tcwd: string | undefined;\n\texitCode: number | undefined;\n\tcommandStartLineContent: string | undefined;\n\tmarkProperties: IMarkProperties | undefined;\n\texecutedX: number | undefined;\n\tstartX: number | undefined;\n\n\tpromptStartMarker?: IMarker | undefined;\n\tendMarker?: IXtermMarker | undefined;\n\texecutedMarker?: IXtermMarker | undefined;\n\taliases?: string[][] | undefined;\n\twasReplayed?: boolean | undefined;\n}\n\nexport class TerminalCommand implements ITerminalCommand {\n\tget command() {\n\t\treturn this._properties.command;\n\t}\n\tget commandLineConfidence() {\n\t\treturn this._properties.commandLineConfidence;\n\t}\n\tget isTrusted() {\n\t\treturn this._properties.isTrusted;\n\t}\n\tget timestamp() {\n\t\treturn this._properties.timestamp;\n\t}\n\tget duration() {\n\t\treturn this._properties.duration;\n\t}\n\tget promptStartMarker() {\n\t\treturn this._properties.promptStartMarker;\n\t}\n\tget marker() {\n\t\treturn this._properties.marker;\n\t}\n\tget endMarker() {\n\t\treturn this._properties.endMarker;\n\t}\n\tset endMarker(value: IXtermMarker | undefined) {\n\t\tthis._properties.endMarker = value;\n\t}\n\tget executedMarker() {\n\t\treturn this._properties.executedMarker;\n\t}\n\tget aliases() {\n\t\treturn this._properties.aliases;\n\t}\n\tget wasReplayed() {\n\t\treturn this._properties.wasReplayed;\n\t}\n\tget cwd() {\n\t\treturn this._properties.cwd;\n\t}\n\tget exitCode() {\n\t\treturn this._properties.exitCode;\n\t}\n\tget commandStartLineContent() {\n\t\treturn this._properties.commandStartLineContent;\n\t}\n\tget markProperties() {\n\t\treturn this._properties.markProperties;\n\t}\n\tget executedX() {\n\t\treturn this._properties.executedX;\n\t}\n\tget startX() {\n\t\treturn this._properties.startX;\n\t}\n\n\tconstructor(\n\t\tprivate readonly _xterm: Terminal,\n\t\tprivate readonly _properties: ITerminalCommandProperties,\n\t) {}\n\n\tstatic deserialize(\n\t\txterm: Terminal,\n\t\tserialized: ISerializedTerminalCommand &\n\t\t\tRequired<Pick<ISerializedTerminalCommand, \"endLine\">>,\n\t\tisCommandStorageDisabled: boolean,\n\t): TerminalCommand | undefined {\n\t\tconst buffer = xterm.buffer.normal;\n\t\tconst marker =\n\t\t\tserialized.startLine !== undefined\n\t\t\t\t? xterm.registerMarker(\n\t\t\t\t\t\tserialized.startLine - (buffer.baseY + buffer.cursorY),\n\t\t\t\t\t)\n\t\t\t\t: undefined;\n\n\t\t// Check for invalid command\n\t\tif (!marker) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst promptStartMarker =\n\t\t\tserialized.promptStartLine !== undefined\n\t\t\t\t? xterm.registerMarker(\n\t\t\t\t\t\tserialized.promptStartLine -\n\t\t\t\t\t\t\t(buffer.baseY + buffer.cursorY),\n\t\t\t\t\t)\n\t\t\t\t: undefined;\n\n\t\t// Valid full command\n\t\tconst endMarker =\n\t\t\tserialized.endLine !== undefined\n\t\t\t\t? xterm.registerMarker(\n\t\t\t\t\t\tserialized.endLine - (buffer.baseY + buffer.cursorY),\n\t\t\t\t\t)\n\t\t\t\t: undefined;\n\t\tconst executedMarker =\n\t\t\tserialized.executedLine !== undefined\n\t\t\t\t? xterm.registerMarker(\n\t\t\t\t\t\tserialized.executedLine -\n\t\t\t\t\t\t\t(buffer.baseY + buffer.cursorY),\n\t\t\t\t\t)\n\t\t\t\t: undefined;\n\t\tconst newCommand = new TerminalCommand(xterm, {\n\t\t\tcommand: isCommandStorageDisabled ? \"\" : serialized.command,\n\t\t\tcommandLineConfidence: serialized.commandLineConfidence ?? \"low\",\n\t\t\tisTrusted: serialized.isTrusted,\n\t\t\tpromptStartMarker,\n\t\t\tmarker,\n\t\t\tstartX: serialized.startX,\n\t\t\tendMarker,\n\t\t\texecutedMarker,\n\t\t\texecutedX: serialized.executedX,\n\t\t\ttimestamp: serialized.timestamp,\n\t\t\tduration: serialized.duration,\n\t\t\tcwd: serialized.cwd,\n\t\t\tcommandStartLineContent: serialized.commandStartLineContent,\n\t\t\texitCode: serialized.exitCode,\n\t\t\tmarkProperties: serialized.markProperties,\n\t\t\taliases: undefined,\n\t\t\twasReplayed: true,\n\t\t});\n\t\treturn newCommand;\n\t}\n\n\tserialize(isCommandStorageDisabled: boolean): ISerializedTerminalCommand {\n\t\treturn {\n\t\t\tpromptStartLine: this.promptStartMarker?.line,\n\t\t\tstartLine: this.marker?.line,\n\t\t\tstartX: undefined,\n\t\t\tendLine: this.endMarker?.line,\n\t\t\texecutedLine: this.executedMarker?.line,\n\t\t\texecutedX: this.executedX,\n\t\t\tcommand: isCommandStorageDisabled ? \"\" : this.command,\n\t\t\tcommandLineConfidence: isCommandStorageDisabled\n\t\t\t\t? \"low\"\n\t\t\t\t: this.commandLineConfidence,\n\t\t\tisTrusted: this.isTrusted,\n\t\t\tcwd: this.cwd,\n\t\t\texitCode: this.exitCode,\n\t\t\tcommandStartLineContent: this.commandStartLineContent,\n\t\t\ttimestamp: this.timestamp,\n\t\t\tduration: this.duration,\n\t\t\tmarkProperties: this.markProperties,\n\t\t};\n\t}\n\n\textractCommandLine(): string {\n\t\treturn extractCommandLine(\n\t\t\tthis._xterm.buffer.active,\n\t\t\tthis._xterm.cols,\n\t\t\tthis.marker,\n\t\t\tthis.startX,\n\t\t\tthis.executedMarker,\n\t\t\tthis.executedX,\n\t\t);\n\t}\n\n\tgetOutput(): string | undefined {\n\t\tif (!this.executedMarker || !this.endMarker) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst startLine = this.executedMarker.line;\n\t\tconst endLine = this.endMarker.line;\n\n\t\tif (startLine === endLine) {\n\t\t\treturn undefined;\n\t\t}\n\t\tlet output = \"\";\n\t\tlet line: IBufferLine | undefined;\n\t\tfor (let i = startLine; i < endLine; i++) {\n\t\t\tline = this._xterm.buffer.active.getLine(i);\n\t\t\tif (!line) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\toutput +=\n\t\t\t\tline.translateToString(!line.isWrapped) +\n\t\t\t\t(line.isWrapped ? \"\" : \"\\n\");\n\t\t}\n\t\treturn output === \"\" ? undefined : output;\n\t}\n\n\tgetOutputMatch(\n\t\toutputMatcher: ITerminalOutputMatcher,\n\t): ITerminalOutputMatch | undefined {\n\t\t// TODO: Add back this check? this._ptyHeuristics.value instanceof WindowsPtyHeuristics && (executedMarker?.line === endMarker?.line) ? this._currentCommand.commandStartMarker : executedMarker\n\t\tif (!this.executedMarker || !this.endMarker) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst endLine = this.endMarker.line;\n\t\tif (endLine === -1) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst buffer = this._xterm.buffer.active;\n\t\tconst startLine = Math.max(this.executedMarker.line, 0);\n\t\tconst matcher = outputMatcher.lineMatcher;\n\t\tconst linesToCheck =\n\t\t\ttypeof matcher === \"string\"\n\t\t\t\t? 1\n\t\t\t\t: outputMatcher.length || countNewLines(matcher);\n\t\tconst lines: string[] = [];\n\t\tlet match: RegExpMatchArray | null | undefined;\n\t\tif (outputMatcher.anchor === \"bottom\") {\n\t\t\tfor (\n\t\t\t\tlet i = endLine - (outputMatcher.offset || 0);\n\t\t\t\ti >= startLine;\n\t\t\t\ti--\n\t\t\t) {\n\t\t\t\tlet wrappedLineStart = i;\n\t\t\t\tconst wrappedLineEnd = i;\n\t\t\t\twhile (\n\t\t\t\t\twrappedLineStart >= startLine &&\n\t\t\t\t\tbuffer.getLine(wrappedLineStart)?.isWrapped\n\t\t\t\t) {\n\t\t\t\t\twrappedLineStart--;\n\t\t\t\t}\n\t\t\t\ti = wrappedLineStart;\n\t\t\t\tlines.unshift(\n\t\t\t\t\tgetXtermLineContent(\n\t\t\t\t\t\tbuffer,\n\t\t\t\t\t\twrappedLineStart,\n\t\t\t\t\t\twrappedLineEnd,\n\t\t\t\t\t\tthis._xterm.cols,\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t\tif (!match) {\n\t\t\t\t\tmatch = lines[0].match(matcher);\n\t\t\t\t}\n\t\t\t\tif (lines.length >= linesToCheck) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (\n\t\t\t\tlet i = startLine + (outputMatcher.offset || 0);\n\t\t\t\ti < endLine;\n\t\t\t\ti++\n\t\t\t) {\n\t\t\t\tconst wrappedLineStart = i;\n\t\t\t\tlet wrappedLineEnd = i;\n\t\t\t\twhile (\n\t\t\t\t\twrappedLineEnd + 1 < endLine &&\n\t\t\t\t\tbuffer.getLine(wrappedLineEnd + 1)?.isWrapped\n\t\t\t\t) {\n\t\t\t\t\twrappedLineEnd++;\n\t\t\t\t}\n\t\t\t\ti = wrappedLineEnd;\n\t\t\t\tlines.push(\n\t\t\t\t\tgetXtermLineContent(\n\t\t\t\t\t\tbuffer,\n\t\t\t\t\t\twrappedLineStart,\n\t\t\t\t\t\twrappedLineEnd,\n\t\t\t\t\t\tthis._xterm.cols,\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t\tif (!match) {\n\t\t\t\t\tmatch = lines[lines.length - 1].match(matcher);\n\t\t\t\t}\n\t\t\t\tif (lines.length >= linesToCheck) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn match ? { regexMatch: match, outputLines: lines } : undefined;\n\t}\n\n\thasOutput(): boolean {\n\t\treturn (\n\t\t\t!this.executedMarker?.isDisposed &&\n\t\t\t!this.endMarker?.isDisposed &&\n\t\t\t!!(\n\t\t\t\tthis.executedMarker &&\n\t\t\t\tthis.endMarker &&\n\t\t\t\tthis.executedMarker.line < this.endMarker.line\n\t\t\t)\n\t\t);\n\t}\n\n\tgetPromptRowCount(): number {\n\t\treturn getPromptRowCount(this, this._xterm.buffer.active);\n\t}\n\n\tgetCommandRowCount(): number {\n\t\treturn getCommandRowCount(this);\n\t}\n}\n\nexport interface ICurrentPartialCommand {\n\tpromptStartMarker?: IMarker;\n\n\tcommandStartMarker?: IMarker;\n\tcommandStartX?: number;\n\tcommandStartLineContent?: string;\n\n\tcommandRightPromptStartX?: number;\n\tcommandRightPromptEndX?: number;\n\n\tcommandLines?: IMarker;\n\n\tcommandExecutedMarker?: IMarker;\n\tcommandExecutedX?: number;\n\n\tcommandFinishedMarker?: IMarker;\n\n\tcurrentContinuationMarker?: IMarker;\n\tcontinuations?: { marker: IMarker; end: number }[];\n\n\tcommand?: string;\n\n\t/**\n\t * Whether the command line is trusted via a nonce.\n\t */\n\tisTrusted?: boolean;\n\n\t/**\n\t * Something invalidated the command before it finished, this will prevent the onCommandFinished\n\t * event from firing.\n\t */\n\tisInvalid?: boolean;\n\n\tgetPromptRowCount(): number;\n\tgetCommandRowCount(): number;\n}\n\nexport class PartialTerminalCommand implements ICurrentPartialCommand {\n\tpromptStartMarker?: IMarker;\n\n\tcommandStartMarker?: IMarker;\n\tcommandStartX?: number;\n\tcommandStartLineContent?: string;\n\n\tcommandRightPromptStartX?: number;\n\tcommandRightPromptEndX?: number;\n\n\tcommandLines?: IMarker;\n\n\tcommandExecutedMarker?: IMarker;\n\tcommandExecutedX?: number;\n\n\tprivate commandExecutedTimestamp?: number;\n\tprivate commandDuration?: number;\n\n\tcommandFinishedMarker?: IMarker;\n\n\tcurrentContinuationMarker?: IMarker;\n\tcontinuations?: { marker: IMarker; end: number }[];\n\n\tcwd?: string;\n\tcommand?: string;\n\tcommandLineConfidence?: \"low\" | \"medium\" | \"high\";\n\n\tisTrusted?: boolean;\n\tisInvalid?: boolean;\n\n\tconstructor(private readonly _xterm: Terminal) {}\n\n\tserialize(cwd: string | undefined): ISerializedTerminalCommand | undefined {\n\t\tif (!this.commandStartMarker) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn {\n\t\t\tpromptStartLine: this.promptStartMarker?.line,\n\t\t\tstartLine: this.commandStartMarker.line,\n\t\t\tstartX: this.commandStartX,\n\t\t\tendLine: undefined,\n\t\t\texecutedLine: undefined,\n\t\t\texecutedX: undefined,\n\t\t\tcommand: \"\",\n\t\t\tcommandLineConfidence: \"low\",\n\t\t\tisTrusted: true,\n\t\t\tcwd,\n\t\t\texitCode: undefined,\n\t\t\tcommandStartLineContent: undefined,\n\t\t\ttimestamp: 0,\n\t\t\tduration: 0,\n\t\t\tmarkProperties: undefined,\n\t\t};\n\t}\n\n\tpromoteToFullCommand(\n\t\tcwd: string | undefined,\n\t\texitCode: number | undefined,\n\t\tignoreCommandLine: boolean,\n\t\tmarkProperties: IMarkProperties | undefined,\n\t): TerminalCommand | undefined {\n\t\t// When the command finishes and executed never fires the placeholder selector should be used.\n\t\tif (exitCode === undefined && this.command === undefined) {\n\t\t\tthis.command = \"\";\n\t\t}\n\n\t\tif (\n\t\t\t(this.command !== undefined && !this.command.startsWith(\"\\\\\")) ||\n\t\t\tignoreCommandLine\n\t\t) {\n\t\t\treturn new TerminalCommand(this._xterm, {\n\t\t\t\tcommand: ignoreCommandLine ? \"\" : this.command || \"\",\n\t\t\t\tcommandLineConfidence: ignoreCommandLine\n\t\t\t\t\t? \"low\"\n\t\t\t\t\t: this.commandLineConfidence || \"low\",\n\t\t\t\tisTrusted: !!this.isTrusted,\n\t\t\t\tpromptStartMarker: this.promptStartMarker,\n\t\t\t\tmarker: this.commandStartMarker,\n\t\t\t\tstartX: this.commandStartX,\n\t\t\t\tendMarker: this.commandFinishedMarker,\n\t\t\t\texecutedMarker: this.commandExecutedMarker,\n\t\t\t\texecutedX: this.commandExecutedX,\n\t\t\t\ttimestamp: Date.now(),\n\t\t\t\tduration: this.commandDuration || 0,\n\t\t\t\tcwd,\n\t\t\t\texitCode,\n\t\t\t\tcommandStartLineContent: this.commandStartLineContent,\n\t\t\t\tmarkProperties,\n\t\t\t});\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tmarkExecutedTime() {\n\t\tif (this.commandExecutedTimestamp === undefined) {\n\t\t\tthis.commandExecutedTimestamp = Date.now();\n\t\t}\n\t}\n\n\tmarkFinishedTime() {\n\t\tif (\n\t\t\tthis.commandDuration === undefined &&\n\t\t\tthis.commandExecutedTimestamp !== undefined\n\t\t) {\n\t\t\tthis.commandDuration = Date.now() - this.commandExecutedTimestamp;\n\t\t}\n\t}\n\n\textractCommandLine(): string {\n\t\treturn extractCommandLine(\n\t\t\tthis._xterm.buffer.active,\n\t\t\tthis._xterm.cols,\n\t\t\tthis.commandStartMarker,\n\t\t\tthis.commandStartX,\n\t\t\tthis.commandExecutedMarker,\n\t\t\tthis.commandExecutedX,\n\t\t);\n\t}\n\n\tgetPromptRowCount(): number {\n\t\treturn getPromptRowCount(this, this._xterm.buffer.active);\n\t}\n\n\tgetCommandRowCount(): number {\n\t\treturn getCommandRowCount(this);\n\t}\n}\n\nfunction extractCommandLine(\n\tbuffer: IBuffer,\n\tcols: number,\n\tcommandStartMarker: IXtermMarker | undefined,\n\tcommandStartX: number | undefined,\n\tcommandExecutedMarker: IXtermMarker | undefined,\n\tcommandExecutedX: number | undefined,\n): string {\n\tif (\n\t\t!commandStartMarker ||\n\t\t!commandExecutedMarker ||\n\t\tcommandStartX === undefined ||\n\t\tcommandExecutedX === undefined\n\t) {\n\t\treturn \"\";\n\t}\n\tlet content = \"\";\n\tfor (\n\t\tlet i = commandStartMarker.line;\n\t\ti <= commandExecutedMarker.line;\n\t\ti++\n\t) {\n\t\tconst line = buffer.getLine(i);\n\t\tif (line) {\n\t\t\tcontent += line.translateToString(\n\t\t\t\ttrue,\n\t\t\t\ti === commandStartMarker.line ? commandStartX : 0,\n\t\t\t\ti === commandExecutedMarker.line ? commandExecutedX : cols,\n\t\t\t);\n\t\t}\n\t}\n\treturn content;\n}\n\nfunction getXtermLineContent(\n\tbuffer: IBuffer,\n\tlineStart: number,\n\tlineEnd: number,\n\tcols: number,\n): string {\n\t// Cap the maximum number of lines generated to prevent potential performance problems. This is\n\t// more of a sanity check as the wrapped line should already be trimmed down at this point.\n\tconst maxLineLength = Math.max((2048 / cols) * 2);\n\tlineEnd = Math.min(lineEnd, lineStart + maxLineLength);\n\tlet content = \"\";\n\tfor (let i = lineStart; i <= lineEnd; i++) {\n\t\t// Make sure only 0 to cols are considered as resizing when windows mode is enabled will\n\t\t// retain buffer data outside of the terminal width as reflow is disabled.\n\t\tconst line = buffer.getLine(i);\n\t\tif (line) {\n\t\t\tcontent += line.translateToString(true, 0, cols);\n\t\t}\n\t}\n\treturn content;\n}\n\nfunction countNewLines(regex: RegExp): number {\n\tif (!regex.multiline) {\n\t\treturn 1;\n\t}\n\tconst source = regex.source;\n\tlet count = 1;\n\tlet i = source.indexOf(\"\\\\n\");\n\twhile (i !== -1) {\n\t\tcount++;\n\t\ti = source.indexOf(\"\\\\n\", i + 1);\n\t}\n\treturn count;\n}\n\nfunction getPromptRowCount(\n\tcommand: ITerminalCommand | ICurrentPartialCommand,\n\tbuffer: IBuffer,\n): number {\n\tconst marker =\n\t\t\"hasOutput\" in command ? command.marker : command.commandStartMarker;\n\tif (!marker || !command.promptStartMarker) {\n\t\treturn 1;\n\t}\n\tlet promptRowCount = 1;\n\tlet promptStartLine = command.promptStartMarker.line;\n\t// Trim any leading whitespace-only lines to retain vertical space\n\twhile (\n\t\tpromptStartLine < marker.line &&\n\t\t(buffer.getLine(promptStartLine)?.translateToString(true) ?? \"\")\n\t\t\t.length === 0\n\t) {\n\t\tpromptStartLine++;\n\t}\n\tpromptRowCount = marker.line - promptStartLine + 1;\n\treturn promptRowCount;\n}\n\nfunction getCommandRowCount(\n\tcommand: ITerminalCommand | ICurrentPartialCommand,\n): number {\n\tconst marker =\n\t\t\"hasOutput\" in command ? command.marker : command.commandStartMarker;\n\tconst executedMarker =\n\t\t\"hasOutput\" in command\n\t\t\t? command.executedMarker\n\t\t\t: command.commandExecutedMarker;\n\tif (!marker || !executedMarker) {\n\t\treturn 1;\n\t}\n\tconst commandExecutedLine = Math.max(executedMarker.line, marker.line);\n\tlet commandRowCount = commandExecutedLine - marker.line + 1;\n\t// Trim the last line if the cursor X is in the left-most cell\n\tconst executedX =\n\t\t\"hasOutput\" in command ? command.executedX : command.commandExecutedX;\n\tif (executedX === 0) {\n\t\tcommandRowCount--;\n\t}\n\treturn commandRowCount;\n}\n"],
  "mappings": "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",
  "names": []
}
