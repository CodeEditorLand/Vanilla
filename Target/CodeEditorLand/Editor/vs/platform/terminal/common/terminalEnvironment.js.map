{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/terminal/common/terminalEnvironment.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { OS, OperatingSystem } from \"../../../base/common/platform.js\";\nimport type { IShellLaunchConfig } from \"./terminal.js\";\n\n/**\n * Aggressively escape non-windows paths to prepare for being sent to a shell. This will do some\n * escaping inaccurately to be careful about possible script injection via the file path. For\n * example, we're trying to prevent this sort of attack: `/foo/file$(echo evil)`.\n */\nexport function escapeNonWindowsPath(path: string): string {\n\tlet newPath = path;\n\tif (newPath.includes(\"\\\\\")) {\n\t\tnewPath = newPath.replace(/\\\\/g, \"\\\\\\\\\");\n\t}\n\tconst bannedChars = /[`$|&>~#!^*;<\"']/g;\n\tnewPath = newPath.replace(bannedChars, \"\");\n\treturn `'${newPath}'`;\n}\n\n/**\n * Collapses the user's home directory into `~` if it exists within the path, this gives a shorter\n * path that is more suitable within the context of a terminal.\n */\nexport function collapseTildePath(\n\tpath: string | undefined,\n\tuserHome: string | undefined,\n\tseparator: string,\n): string {\n\tif (!path) {\n\t\treturn \"\";\n\t}\n\tif (!userHome) {\n\t\treturn path;\n\t}\n\t// Trim the trailing separator from the end if it exists\n\tif (userHome.match(/[/\\\\]$/)) {\n\t\tuserHome = userHome.slice(0, userHome.length - 1);\n\t}\n\tconst normalizedPath = path.replace(/\\\\/g, \"/\").toLowerCase();\n\tconst normalizedUserHome = userHome.replace(/\\\\/g, \"/\").toLowerCase();\n\tif (!normalizedPath.includes(normalizedUserHome)) {\n\t\treturn path;\n\t}\n\treturn `~${separator}${path.slice(userHome.length + 1)}`;\n}\n\n/**\n * Sanitizes a cwd string, removing any wrapping quotes and making the Windows drive letter\n * uppercase.\n * @param cwd The directory to sanitize.\n */\nexport function sanitizeCwd(cwd: string): string {\n\t// Sanity check that the cwd is not wrapped in quotes (see #160109)\n\tif (cwd.match(/^['\"].*['\"]$/)) {\n\t\tcwd = cwd.substring(1, cwd.length - 1);\n\t}\n\t// Make the drive letter uppercase on Windows (see #9448)\n\tif (OS === OperatingSystem.Windows && cwd && cwd[1] === \":\") {\n\t\treturn cwd[0].toUpperCase() + cwd.substring(1);\n\t}\n\treturn cwd;\n}\n\n/**\n * Determines whether the given shell launch config should use the environment variable collection.\n * @param slc The shell launch config to check.\n */\nexport function shouldUseEnvironmentVariableCollection(\n\tslc: IShellLaunchConfig,\n): boolean {\n\treturn !slc.strictEnv;\n}\n"],
  "mappings": ";;AAKA,SAAS,IAAI,uBAAuB;AAQ7B,SAAS,qBAAqB,MAAsB;AAC1D,MAAI,UAAU;AACd,MAAI,QAAQ,SAAS,IAAI,GAAG;AAC3B,cAAU,QAAQ,QAAQ,OAAO,MAAM;AAAA,EACxC;AACA,QAAM,cAAc;AACpB,YAAU,QAAQ,QAAQ,aAAa,EAAE;AACzC,SAAO,IAAI,OAAO;AACnB;AARgB;AAcT,SAAS,kBACf,MACA,UACA,WACS;AACT,MAAI,CAAC,MAAM;AACV,WAAO;AAAA,EACR;AACA,MAAI,CAAC,UAAU;AACd,WAAO;AAAA,EACR;AAEA,MAAI,SAAS,MAAM,QAAQ,GAAG;AAC7B,eAAW,SAAS,MAAM,GAAG,SAAS,SAAS,CAAC;AAAA,EACjD;AACA,QAAM,iBAAiB,KAAK,QAAQ,OAAO,GAAG,EAAE,YAAY;AAC5D,QAAM,qBAAqB,SAAS,QAAQ,OAAO,GAAG,EAAE,YAAY;AACpE,MAAI,CAAC,eAAe,SAAS,kBAAkB,GAAG;AACjD,WAAO;AAAA,EACR;AACA,SAAO,IAAI,SAAS,GAAG,KAAK,MAAM,SAAS,SAAS,CAAC,CAAC;AACvD;AArBgB;AA4BT,SAAS,YAAY,KAAqB;AAEhD,MAAI,IAAI,MAAM,cAAc,GAAG;AAC9B,UAAM,IAAI,UAAU,GAAG,IAAI,SAAS,CAAC;AAAA,EACtC;AAEA,MAAI,OAAO,gBAAgB,WAAW,OAAO,IAAI,CAAC,MAAM,KAAK;AAC5D,WAAO,IAAI,CAAC,EAAE,YAAY,IAAI,IAAI,UAAU,CAAC;AAAA,EAC9C;AACA,SAAO;AACR;AAVgB;AAgBT,SAAS,uCACf,KACU;AACV,SAAO,CAAC,IAAI;AACb;AAJgB;",
  "names": []
}
