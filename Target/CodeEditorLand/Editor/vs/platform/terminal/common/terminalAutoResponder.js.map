{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/terminal/common/terminalAutoResponder.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { timeout } from '../../../base/common/async.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { isWindows } from '../../../base/common/platform.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { ITerminalChildProcess } from './terminal.js';\n\n/**\n * Tracks a terminal process's data stream and responds immediately when a matching string is\n * received. This is done in a low overhead way and is ideally run on the same process as the\n * where the process is handled to minimize latency.\n */\nexport class TerminalAutoResponder extends Disposable {\n\tprivate _pointer = 0;\n\tprivate _paused = false;\n\n\t/**\n\t * Each reply is throttled by a second to avoid resource starvation and responding to screen\n\t * reprints on Winodws.\n\t */\n\tprivate _throttled = false;\n\n\tconstructor(\n\t\tproc: ITerminalChildProcess,\n\t\tmatchWord: string,\n\t\tresponse: string,\n\t\tlogService: ILogService\n\t) {\n\t\tsuper();\n\n\t\tthis._register(proc.onProcessData(e => {\n\t\t\tif (this._paused || this._throttled) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst data = typeof e === 'string' ? e : e.data;\n\t\t\tfor (let i = 0; i < data.length; i++) {\n\t\t\t\tif (data[i] === matchWord[this._pointer]) {\n\t\t\t\t\tthis._pointer++;\n\t\t\t\t} else {\n\t\t\t\t\tthis._reset();\n\t\t\t\t}\n\t\t\t\t// Auto reply and reset\n\t\t\t\tif (this._pointer === matchWord.length) {\n\t\t\t\t\tlogService.debug(`Auto reply match: \"${matchWord}\", response: \"${response}\"`);\n\t\t\t\t\tproc.input(response);\n\t\t\t\t\tthis._throttled = true;\n\t\t\t\t\ttimeout(1000).then(() => this._throttled = false);\n\t\t\t\t\tthis._reset();\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\t}\n\n\tprivate _reset() {\n\t\tthis._pointer = 0;\n\t}\n\n\t/**\n\t * No auto response will happen after a resize on Windows in case the resize is a result of\n\t * reprinting the screen.\n\t */\n\thandleResize() {\n\t\tif (isWindows) {\n\t\t\tthis._paused = true;\n\t\t}\n\t}\n\n\thandleInput() {\n\t\tthis._paused = false;\n\t}\n}\n"],
  "mappings": ";;AAKA,SAAS,eAAe;AACxB,SAAS,kBAAkB;AAC3B,SAAS,iBAAiB;AAC1B,SAAS,mBAAmB;AAC5B,SAAS,6BAA6B;AAO/B,MAAM,8BAA8B,WAAW;AAAA,EAhBtD,OAgBsD;AAAA;AAAA;AAAA,EAC7C,WAAW;AAAA,EACX,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA,EAMV,aAAa;AAAA,EAErB,YACC,MACA,WACA,UACA,YACC;AACD,UAAM;AAEN,SAAK,UAAU,KAAK,cAAc,OAAK;AACtC,UAAI,KAAK,WAAW,KAAK,YAAY;AACpC;AAAA,MACD;AACA,YAAM,OAAO,OAAO,MAAM,WAAW,IAAI,EAAE;AAC3C,eAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACrC,YAAI,KAAK,CAAC,MAAM,UAAU,KAAK,QAAQ,GAAG;AACzC,eAAK;AAAA,QACN,OAAO;AACN,eAAK,OAAO;AAAA,QACb;AAEA,YAAI,KAAK,aAAa,UAAU,QAAQ;AACvC,qBAAW,MAAM,sBAAsB,SAAS,iBAAiB,QAAQ,GAAG;AAC5E,eAAK,MAAM,QAAQ;AACnB,eAAK,aAAa;AAClB,kBAAQ,GAAI,EAAE,KAAK,MAAM,KAAK,aAAa,KAAK;AAChD,eAAK,OAAO;AAAA,QACb;AAAA,MACD;AAAA,IACD,CAAC,CAAC;AAAA,EACH;AAAA,EAEQ,SAAS;AAChB,SAAK,WAAW;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,eAAe;AACd,QAAI,WAAW;AACd,WAAK,UAAU;AAAA,IAChB;AAAA,EACD;AAAA,EAEA,cAAc;AACb,SAAK,UAAU;AAAA,EAChB;AACD;",
  "names": []
}
