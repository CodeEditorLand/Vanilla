{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/terminal/common/environmentVariableCollection.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport {\n\ttype IProcessEnvironment,\n\tisWindows,\n} from \"../../../base/common/platform.js\";\nimport {\n\tEnvironmentVariableMutatorType,\n\ttype EnvironmentVariableScope,\n\ttype IEnvironmentVariableCollection,\n\ttype IExtensionOwnedEnvironmentDescriptionMutator,\n\ttype IExtensionOwnedEnvironmentVariableMutator,\n\ttype IMergedEnvironmentVariableCollection,\n\ttype IMergedEnvironmentVariableCollectionDiff,\n} from \"./environmentVariable.js\";\n\ntype VariableResolver = (str: string) => Promise<string>;\n\nconst mutatorTypeToLabelMap: Map<EnvironmentVariableMutatorType, string> =\n\tnew Map([\n\t\t[EnvironmentVariableMutatorType.Append, \"APPEND\"],\n\t\t[EnvironmentVariableMutatorType.Prepend, \"PREPEND\"],\n\t\t[EnvironmentVariableMutatorType.Replace, \"REPLACE\"],\n\t]);\n\nexport class MergedEnvironmentVariableCollection\n\timplements IMergedEnvironmentVariableCollection\n{\n\tprivate readonly map: Map<\n\t\tstring,\n\t\tIExtensionOwnedEnvironmentVariableMutator[]\n\t> = new Map();\n\tprivate readonly descriptionMap: Map<\n\t\tstring,\n\t\tIExtensionOwnedEnvironmentDescriptionMutator[]\n\t> = new Map();\n\n\tconstructor(\n\t\treadonly collections: ReadonlyMap<\n\t\t\tstring,\n\t\t\tIEnvironmentVariableCollection\n\t\t>,\n\t) {\n\t\tcollections.forEach((collection, extensionIdentifier) => {\n\t\t\tthis.populateDescriptionMap(collection, extensionIdentifier);\n\t\t\tconst it = collection.map.entries();\n\t\t\tlet next = it.next();\n\t\t\twhile (!next.done) {\n\t\t\t\tconst mutator = next.value[1];\n\t\t\t\tconst key = next.value[0];\n\t\t\t\tlet entry = this.map.get(key);\n\t\t\t\tif (!entry) {\n\t\t\t\t\tentry = [];\n\t\t\t\t\tthis.map.set(key, entry);\n\t\t\t\t}\n\n\t\t\t\t// If the first item in the entry is replace ignore any other entries as they would\n\t\t\t\t// just get replaced by this one.\n\t\t\t\tif (\n\t\t\t\t\tentry.length > 0 &&\n\t\t\t\t\tentry[0].type === EnvironmentVariableMutatorType.Replace\n\t\t\t\t) {\n\t\t\t\t\tnext = it.next();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst extensionMutator = {\n\t\t\t\t\textensionIdentifier,\n\t\t\t\t\tvalue: mutator.value,\n\t\t\t\t\ttype: mutator.type,\n\t\t\t\t\tscope: mutator.scope,\n\t\t\t\t\tvariable: mutator.variable,\n\t\t\t\t\toptions: mutator.options,\n\t\t\t\t};\n\t\t\t\tif (!extensionMutator.scope) {\n\t\t\t\t\tdelete extensionMutator.scope; // Convenient for tests\n\t\t\t\t}\n\t\t\t\t// Mutators get applied in the reverse order than they are created\n\t\t\t\tentry.unshift(extensionMutator);\n\n\t\t\t\tnext = it.next();\n\t\t\t}\n\t\t});\n\t}\n\n\tasync applyToProcessEnvironment(\n\t\tenv: IProcessEnvironment,\n\t\tscope: EnvironmentVariableScope | undefined,\n\t\tvariableResolver?: VariableResolver,\n\t): Promise<void> {\n\t\tlet lowerToActualVariableNames:\n\t\t\t| { [lowerKey: string]: string | undefined }\n\t\t\t| undefined;\n\t\tif (isWindows) {\n\t\t\tlowerToActualVariableNames = {};\n\t\t\tObject.keys(env).forEach(\n\t\t\t\t(e) => (lowerToActualVariableNames![e.toLowerCase()] = e),\n\t\t\t);\n\t\t}\n\t\tfor (const [variable, mutators] of this.getVariableMap(scope)) {\n\t\t\tconst actualVariable = isWindows\n\t\t\t\t? lowerToActualVariableNames![variable.toLowerCase()] ||\n\t\t\t\t\tvariable\n\t\t\t\t: variable;\n\t\t\tfor (const mutator of mutators) {\n\t\t\t\tconst value = variableResolver\n\t\t\t\t\t? await variableResolver(mutator.value)\n\t\t\t\t\t: mutator.value;\n\t\t\t\t// Default: true\n\t\t\t\tif (mutator.options?.applyAtProcessCreation ?? true) {\n\t\t\t\t\tswitch (mutator.type) {\n\t\t\t\t\t\tcase EnvironmentVariableMutatorType.Append:\n\t\t\t\t\t\t\tenv[actualVariable] =\n\t\t\t\t\t\t\t\t(env[actualVariable] || \"\") + value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase EnvironmentVariableMutatorType.Prepend:\n\t\t\t\t\t\t\tenv[actualVariable] =\n\t\t\t\t\t\t\t\tvalue + (env[actualVariable] || \"\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase EnvironmentVariableMutatorType.Replace:\n\t\t\t\t\t\t\tenv[actualVariable] = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Default: false\n\t\t\t\tif (mutator.options?.applyAtShellIntegration ?? false) {\n\t\t\t\t\tconst key = `VSCODE_ENV_${mutatorTypeToLabelMap.get(mutator.type)!}`;\n\t\t\t\t\tenv[key] =\n\t\t\t\t\t\t(env[key] ? env[key] + \":\" : \"\") +\n\t\t\t\t\t\tvariable +\n\t\t\t\t\t\t\"=\" +\n\t\t\t\t\t\tthis._encodeColons(value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _encodeColons(value: string): string {\n\t\treturn value.replaceAll(\":\", \"\\\\x3a\");\n\t}\n\n\tdiff(\n\t\tother: IMergedEnvironmentVariableCollection,\n\t\tscope: EnvironmentVariableScope | undefined,\n\t): IMergedEnvironmentVariableCollectionDiff | undefined {\n\t\tconst added: Map<string, IExtensionOwnedEnvironmentVariableMutator[]> =\n\t\t\tnew Map();\n\t\tconst changed: Map<\n\t\t\tstring,\n\t\t\tIExtensionOwnedEnvironmentVariableMutator[]\n\t\t> = new Map();\n\t\tconst removed: Map<\n\t\t\tstring,\n\t\t\tIExtensionOwnedEnvironmentVariableMutator[]\n\t\t> = new Map();\n\n\t\t// Find added\n\t\tother.getVariableMap(scope).forEach((otherMutators, variable) => {\n\t\t\tconst currentMutators = this.getVariableMap(scope).get(variable);\n\t\t\tconst result = getMissingMutatorsFromArray(\n\t\t\t\totherMutators,\n\t\t\t\tcurrentMutators,\n\t\t\t);\n\t\t\tif (result) {\n\t\t\t\tadded.set(variable, result);\n\t\t\t}\n\t\t});\n\n\t\t// Find removed\n\t\tthis.getVariableMap(scope).forEach((currentMutators, variable) => {\n\t\t\tconst otherMutators = other.getVariableMap(scope).get(variable);\n\t\t\tconst result = getMissingMutatorsFromArray(\n\t\t\t\tcurrentMutators,\n\t\t\t\totherMutators,\n\t\t\t);\n\t\t\tif (result) {\n\t\t\t\tremoved.set(variable, result);\n\t\t\t}\n\t\t});\n\n\t\t// Find changed\n\t\tthis.getVariableMap(scope).forEach((currentMutators, variable) => {\n\t\t\tconst otherMutators = other.getVariableMap(scope).get(variable);\n\t\t\tconst result = getChangedMutatorsFromArray(\n\t\t\t\tcurrentMutators,\n\t\t\t\totherMutators,\n\t\t\t);\n\t\t\tif (result) {\n\t\t\t\tchanged.set(variable, result);\n\t\t\t}\n\t\t});\n\n\t\tif (added.size === 0 && changed.size === 0 && removed.size === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn { added, changed, removed };\n\t}\n\n\tgetVariableMap(\n\t\tscope: EnvironmentVariableScope | undefined,\n\t): Map<string, IExtensionOwnedEnvironmentVariableMutator[]> {\n\t\tconst result = new Map<\n\t\t\tstring,\n\t\t\tIExtensionOwnedEnvironmentVariableMutator[]\n\t\t>();\n\t\tfor (const mutators of this.map.values()) {\n\t\t\tconst filteredMutators = mutators.filter((m) =>\n\t\t\t\tfilterScope(m, scope),\n\t\t\t);\n\t\t\tif (filteredMutators.length > 0) {\n\t\t\t\t// All of these mutators are for the same variable because they are in the same scope, hence choose anyone to form a key.\n\t\t\t\tresult.set(filteredMutators[0].variable, filteredMutators);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tgetDescriptionMap(\n\t\tscope: EnvironmentVariableScope | undefined,\n\t): Map<string, string | undefined> {\n\t\tconst result = new Map<string, string | undefined>();\n\t\tfor (const mutators of this.descriptionMap.values()) {\n\t\t\tconst filteredMutators = mutators.filter((m) =>\n\t\t\t\tfilterScope(m, scope, true),\n\t\t\t);\n\t\t\tfor (const mutator of filteredMutators) {\n\t\t\t\tresult.set(mutator.extensionIdentifier, mutator.description);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate populateDescriptionMap(\n\t\tcollection: IEnvironmentVariableCollection,\n\t\textensionIdentifier: string,\n\t): void {\n\t\tif (!collection.descriptionMap) {\n\t\t\treturn;\n\t\t}\n\t\tconst it = collection.descriptionMap.entries();\n\t\tlet next = it.next();\n\t\twhile (!next.done) {\n\t\t\tconst mutator = next.value[1];\n\t\t\tconst key = next.value[0];\n\t\t\tlet entry = this.descriptionMap.get(key);\n\t\t\tif (!entry) {\n\t\t\t\tentry = [];\n\t\t\t\tthis.descriptionMap.set(key, entry);\n\t\t\t}\n\t\t\tconst extensionMutator = {\n\t\t\t\textensionIdentifier,\n\t\t\t\tscope: mutator.scope,\n\t\t\t\tdescription: mutator.description,\n\t\t\t};\n\t\t\tif (!extensionMutator.scope) {\n\t\t\t\tdelete extensionMutator.scope; // Convenient for tests\n\t\t\t}\n\t\t\tentry.push(extensionMutator);\n\n\t\t\tnext = it.next();\n\t\t}\n\t}\n}\n\n/**\n * Returns whether a mutator matches with the scope provided.\n * @param mutator Mutator to filter\n * @param scope Scope to be used for querying\n * @param strictFilter If true, mutators with global scope is not returned when querying for workspace scope.\n * i.e whether mutator scope should always exactly match with query scope.\n */\nfunction filterScope(\n\tmutator:\n\t\t| IExtensionOwnedEnvironmentVariableMutator\n\t\t| IExtensionOwnedEnvironmentDescriptionMutator,\n\tscope: EnvironmentVariableScope | undefined,\n\tstrictFilter = false,\n): boolean {\n\tif (!mutator.scope) {\n\t\tif (strictFilter) {\n\t\t\treturn scope === mutator.scope;\n\t\t}\n\t\treturn true;\n\t}\n\t// If a mutator is scoped to a workspace folder, only apply it if the workspace\n\t// folder matches.\n\tif (\n\t\tmutator.scope.workspaceFolder &&\n\t\tscope?.workspaceFolder &&\n\t\tmutator.scope.workspaceFolder.index === scope.workspaceFolder.index\n\t) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nfunction getMissingMutatorsFromArray(\n\tcurrent: IExtensionOwnedEnvironmentVariableMutator[],\n\tother: IExtensionOwnedEnvironmentVariableMutator[] | undefined,\n): IExtensionOwnedEnvironmentVariableMutator[] | undefined {\n\t// If it doesn't exist, all are removed\n\tif (!other) {\n\t\treturn current;\n\t}\n\n\t// Create a map to help\n\tconst otherMutatorExtensions = new Set<string>();\n\tother.forEach((m) => otherMutatorExtensions.add(m.extensionIdentifier));\n\n\t// Find entries removed from other\n\tconst result: IExtensionOwnedEnvironmentVariableMutator[] = [];\n\tcurrent.forEach((mutator) => {\n\t\tif (!otherMutatorExtensions.has(mutator.extensionIdentifier)) {\n\t\t\tresult.push(mutator);\n\t\t}\n\t});\n\n\treturn result.length === 0 ? undefined : result;\n}\n\nfunction getChangedMutatorsFromArray(\n\tcurrent: IExtensionOwnedEnvironmentVariableMutator[],\n\tother: IExtensionOwnedEnvironmentVariableMutator[] | undefined,\n): IExtensionOwnedEnvironmentVariableMutator[] | undefined {\n\t// If it doesn't exist, none are changed (they are removed)\n\tif (!other) {\n\t\treturn undefined;\n\t}\n\n\t// Create a map to help\n\tconst otherMutatorExtensions = new Map<\n\t\tstring,\n\t\tIExtensionOwnedEnvironmentVariableMutator\n\t>();\n\tother.forEach((m) => otherMutatorExtensions.set(m.extensionIdentifier, m));\n\n\t// Find entries that exist in both but are not equal\n\tconst result: IExtensionOwnedEnvironmentVariableMutator[] = [];\n\tcurrent.forEach((mutator) => {\n\t\tconst otherMutator = otherMutatorExtensions.get(\n\t\t\tmutator.extensionIdentifier,\n\t\t);\n\t\tif (\n\t\t\totherMutator &&\n\t\t\t(mutator.type !== otherMutator.type ||\n\t\t\t\tmutator.value !== otherMutator.value ||\n\t\t\t\tmutator.scope?.workspaceFolder?.index !==\n\t\t\t\t\totherMutator.scope?.workspaceFolder?.index)\n\t\t) {\n\t\t\t// Return the new result, not the old one\n\t\t\tresult.push(otherMutator);\n\t\t}\n\t});\n\n\treturn result.length === 0 ? undefined : result;\n}\n"],
  "mappings": "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",
  "names": []
}
