{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/terminal/common/environmentVariableCollection.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IProcessEnvironment, isWindows } from '../../../base/common/platform.js';\nimport { EnvironmentVariableMutatorType, EnvironmentVariableScope, IEnvironmentVariableCollection, IExtensionOwnedEnvironmentDescriptionMutator, IExtensionOwnedEnvironmentVariableMutator, IMergedEnvironmentVariableCollection, IMergedEnvironmentVariableCollectionDiff } from './environmentVariable.js';\n\ntype VariableResolver = (str: string) => Promise<string>;\n\nconst mutatorTypeToLabelMap: Map<EnvironmentVariableMutatorType, string> = new Map([\n\t[EnvironmentVariableMutatorType.Append, 'APPEND'],\n\t[EnvironmentVariableMutatorType.Prepend, 'PREPEND'],\n\t[EnvironmentVariableMutatorType.Replace, 'REPLACE']\n]);\n\nexport class MergedEnvironmentVariableCollection implements IMergedEnvironmentVariableCollection {\n\tprivate readonly map: Map<string, IExtensionOwnedEnvironmentVariableMutator[]> = new Map();\n\tprivate readonly descriptionMap: Map<string, IExtensionOwnedEnvironmentDescriptionMutator[]> = new Map();\n\n\tconstructor(\n\t\treadonly collections: ReadonlyMap<string, IEnvironmentVariableCollection>,\n\t) {\n\t\tcollections.forEach((collection, extensionIdentifier) => {\n\t\t\tthis.populateDescriptionMap(collection, extensionIdentifier);\n\t\t\tconst it = collection.map.entries();\n\t\t\tlet next = it.next();\n\t\t\twhile (!next.done) {\n\t\t\t\tconst mutator = next.value[1];\n\t\t\t\tconst key = next.value[0];\n\t\t\t\tlet entry = this.map.get(key);\n\t\t\t\tif (!entry) {\n\t\t\t\t\tentry = [];\n\t\t\t\t\tthis.map.set(key, entry);\n\t\t\t\t}\n\n\t\t\t\t// If the first item in the entry is replace ignore any other entries as they would\n\t\t\t\t// just get replaced by this one.\n\t\t\t\tif (entry.length > 0 && entry[0].type === EnvironmentVariableMutatorType.Replace) {\n\t\t\t\t\tnext = it.next();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst extensionMutator = {\n\t\t\t\t\textensionIdentifier,\n\t\t\t\t\tvalue: mutator.value,\n\t\t\t\t\ttype: mutator.type,\n\t\t\t\t\tscope: mutator.scope,\n\t\t\t\t\tvariable: mutator.variable,\n\t\t\t\t\toptions: mutator.options\n\t\t\t\t};\n\t\t\t\tif (!extensionMutator.scope) {\n\t\t\t\t\tdelete extensionMutator.scope; // Convenient for tests\n\t\t\t\t}\n\t\t\t\t// Mutators get applied in the reverse order than they are created\n\t\t\t\tentry.unshift(extensionMutator);\n\n\t\t\t\tnext = it.next();\n\t\t\t}\n\t\t});\n\t}\n\n\tasync applyToProcessEnvironment(env: IProcessEnvironment, scope: EnvironmentVariableScope | undefined, variableResolver?: VariableResolver): Promise<void> {\n\t\tlet lowerToActualVariableNames: { [lowerKey: string]: string | undefined } | undefined;\n\t\tif (isWindows) {\n\t\t\tlowerToActualVariableNames = {};\n\t\t\tObject.keys(env).forEach(e => lowerToActualVariableNames![e.toLowerCase()] = e);\n\t\t}\n\t\tfor (const [variable, mutators] of this.getVariableMap(scope)) {\n\t\t\tconst actualVariable = isWindows ? lowerToActualVariableNames![variable.toLowerCase()] || variable : variable;\n\t\t\tfor (const mutator of mutators) {\n\t\t\t\tconst value = variableResolver ? await variableResolver(mutator.value) : mutator.value;\n\t\t\t\t// Default: true\n\t\t\t\tif (mutator.options?.applyAtProcessCreation ?? true) {\n\t\t\t\t\tswitch (mutator.type) {\n\t\t\t\t\t\tcase EnvironmentVariableMutatorType.Append:\n\t\t\t\t\t\t\tenv[actualVariable] = (env[actualVariable] || '') + value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase EnvironmentVariableMutatorType.Prepend:\n\t\t\t\t\t\t\tenv[actualVariable] = value + (env[actualVariable] || '');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase EnvironmentVariableMutatorType.Replace:\n\t\t\t\t\t\t\tenv[actualVariable] = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Default: false\n\t\t\t\tif (mutator.options?.applyAtShellIntegration ?? false) {\n\t\t\t\t\tconst key = `VSCODE_ENV_${mutatorTypeToLabelMap.get(mutator.type)!}`;\n\t\t\t\t\tenv[key] = (env[key] ? env[key] + ':' : '') + variable + '=' + this._encodeColons(value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _encodeColons(value: string): string {\n\t\treturn value.replaceAll(':', '\\\\x3a');\n\t}\n\n\tdiff(other: IMergedEnvironmentVariableCollection, scope: EnvironmentVariableScope | undefined): IMergedEnvironmentVariableCollectionDiff | undefined {\n\t\tconst added: Map<string, IExtensionOwnedEnvironmentVariableMutator[]> = new Map();\n\t\tconst changed: Map<string, IExtensionOwnedEnvironmentVariableMutator[]> = new Map();\n\t\tconst removed: Map<string, IExtensionOwnedEnvironmentVariableMutator[]> = new Map();\n\n\t\t// Find added\n\t\tother.getVariableMap(scope).forEach((otherMutators, variable) => {\n\t\t\tconst currentMutators = this.getVariableMap(scope).get(variable);\n\t\t\tconst result = getMissingMutatorsFromArray(otherMutators, currentMutators);\n\t\t\tif (result) {\n\t\t\t\tadded.set(variable, result);\n\t\t\t}\n\t\t});\n\n\t\t// Find removed\n\t\tthis.getVariableMap(scope).forEach((currentMutators, variable) => {\n\t\t\tconst otherMutators = other.getVariableMap(scope).get(variable);\n\t\t\tconst result = getMissingMutatorsFromArray(currentMutators, otherMutators);\n\t\t\tif (result) {\n\t\t\t\tremoved.set(variable, result);\n\t\t\t}\n\t\t});\n\n\t\t// Find changed\n\t\tthis.getVariableMap(scope).forEach((currentMutators, variable) => {\n\t\t\tconst otherMutators = other.getVariableMap(scope).get(variable);\n\t\t\tconst result = getChangedMutatorsFromArray(currentMutators, otherMutators);\n\t\t\tif (result) {\n\t\t\t\tchanged.set(variable, result);\n\t\t\t}\n\t\t});\n\n\t\tif (added.size === 0 && changed.size === 0 && removed.size === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn { added, changed, removed };\n\t}\n\n\tgetVariableMap(scope: EnvironmentVariableScope | undefined): Map<string, IExtensionOwnedEnvironmentVariableMutator[]> {\n\t\tconst result = new Map<string, IExtensionOwnedEnvironmentVariableMutator[]>();\n\t\tfor (const mutators of this.map.values()) {\n\t\t\tconst filteredMutators = mutators.filter(m => filterScope(m, scope));\n\t\t\tif (filteredMutators.length > 0) {\n\t\t\t\t// All of these mutators are for the same variable because they are in the same scope, hence choose anyone to form a key.\n\t\t\t\tresult.set(filteredMutators[0].variable, filteredMutators);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tgetDescriptionMap(scope: EnvironmentVariableScope | undefined): Map<string, string | undefined> {\n\t\tconst result = new Map<string, string | undefined>();\n\t\tfor (const mutators of this.descriptionMap.values()) {\n\t\t\tconst filteredMutators = mutators.filter(m => filterScope(m, scope, true));\n\t\t\tfor (const mutator of filteredMutators) {\n\t\t\t\tresult.set(mutator.extensionIdentifier, mutator.description);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate populateDescriptionMap(collection: IEnvironmentVariableCollection, extensionIdentifier: string): void {\n\t\tif (!collection.descriptionMap) {\n\t\t\treturn;\n\t\t}\n\t\tconst it = collection.descriptionMap.entries();\n\t\tlet next = it.next();\n\t\twhile (!next.done) {\n\t\t\tconst mutator = next.value[1];\n\t\t\tconst key = next.value[0];\n\t\t\tlet entry = this.descriptionMap.get(key);\n\t\t\tif (!entry) {\n\t\t\t\tentry = [];\n\t\t\t\tthis.descriptionMap.set(key, entry);\n\t\t\t}\n\t\t\tconst extensionMutator = {\n\t\t\t\textensionIdentifier,\n\t\t\t\tscope: mutator.scope,\n\t\t\t\tdescription: mutator.description\n\t\t\t};\n\t\t\tif (!extensionMutator.scope) {\n\t\t\t\tdelete extensionMutator.scope; // Convenient for tests\n\t\t\t}\n\t\t\tentry.push(extensionMutator);\n\n\t\t\tnext = it.next();\n\t\t}\n\n\t}\n}\n\n/**\n * Returns whether a mutator matches with the scope provided.\n * @param mutator Mutator to filter\n * @param scope Scope to be used for querying\n * @param strictFilter If true, mutators with global scope is not returned when querying for workspace scope.\n * i.e whether mutator scope should always exactly match with query scope.\n */\nfunction filterScope(\n\tmutator: IExtensionOwnedEnvironmentVariableMutator | IExtensionOwnedEnvironmentDescriptionMutator,\n\tscope: EnvironmentVariableScope | undefined,\n\tstrictFilter = false\n): boolean {\n\tif (!mutator.scope) {\n\t\tif (strictFilter) {\n\t\t\treturn scope === mutator.scope;\n\t\t}\n\t\treturn true;\n\t}\n\t// If a mutator is scoped to a workspace folder, only apply it if the workspace\n\t// folder matches.\n\tif (mutator.scope.workspaceFolder && scope?.workspaceFolder && mutator.scope.workspaceFolder.index === scope.workspaceFolder.index) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nfunction getMissingMutatorsFromArray(\n\tcurrent: IExtensionOwnedEnvironmentVariableMutator[],\n\tother: IExtensionOwnedEnvironmentVariableMutator[] | undefined\n): IExtensionOwnedEnvironmentVariableMutator[] | undefined {\n\t// If it doesn't exist, all are removed\n\tif (!other) {\n\t\treturn current;\n\t}\n\n\t// Create a map to help\n\tconst otherMutatorExtensions = new Set<string>();\n\tother.forEach(m => otherMutatorExtensions.add(m.extensionIdentifier));\n\n\t// Find entries removed from other\n\tconst result: IExtensionOwnedEnvironmentVariableMutator[] = [];\n\tcurrent.forEach(mutator => {\n\t\tif (!otherMutatorExtensions.has(mutator.extensionIdentifier)) {\n\t\t\tresult.push(mutator);\n\t\t}\n\t});\n\n\treturn result.length === 0 ? undefined : result;\n}\n\nfunction getChangedMutatorsFromArray(\n\tcurrent: IExtensionOwnedEnvironmentVariableMutator[],\n\tother: IExtensionOwnedEnvironmentVariableMutator[] | undefined\n): IExtensionOwnedEnvironmentVariableMutator[] | undefined {\n\t// If it doesn't exist, none are changed (they are removed)\n\tif (!other) {\n\t\treturn undefined;\n\t}\n\n\t// Create a map to help\n\tconst otherMutatorExtensions = new Map<string, IExtensionOwnedEnvironmentVariableMutator>();\n\tother.forEach(m => otherMutatorExtensions.set(m.extensionIdentifier, m));\n\n\t// Find entries that exist in both but are not equal\n\tconst result: IExtensionOwnedEnvironmentVariableMutator[] = [];\n\tcurrent.forEach(mutator => {\n\t\tconst otherMutator = otherMutatorExtensions.get(mutator.extensionIdentifier);\n\t\tif (otherMutator && (mutator.type !== otherMutator.type || mutator.value !== otherMutator.value || mutator.scope?.workspaceFolder?.index !== otherMutator.scope?.workspaceFolder?.index)) {\n\t\t\t// Return the new result, not the old one\n\t\t\tresult.push(otherMutator);\n\t\t}\n\t});\n\n\treturn result.length === 0 ? undefined : result;\n}\n"],
  "mappings": "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",
  "names": []
}
