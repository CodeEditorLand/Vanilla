{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/update/electron-main/abstractUpdateService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { timeout } from \"../../../base/common/async.js\";\nimport { CancellationToken } from \"../../../base/common/cancellation.js\";\nimport { Emitter, type Event } from \"../../../base/common/event.js\";\nimport { IConfigurationService } from \"../../configuration/common/configuration.js\";\nimport { IEnvironmentMainService } from \"../../environment/electron-main/environmentMainService.js\";\nimport {\n\tILifecycleMainService,\n\tLifecycleMainPhase,\n} from \"../../lifecycle/electron-main/lifecycleMainService.js\";\nimport { ILogService } from \"../../log/common/log.js\";\nimport { IProductService } from \"../../product/common/productService.js\";\nimport { IRequestService } from \"../../request/common/request.js\";\nimport {\n\ttype AvailableForDownload,\n\tDisablementReason,\n\ttype IUpdateService,\n\tState,\n\tStateType,\n\tUpdateType,\n} from \"../common/update.js\";\n\nexport function createUpdateURL(\n\tplatform: string,\n\tquality: string,\n\tproductService: IProductService,\n): string {\n\treturn `${productService.updateUrl}/api/update/${platform}/${quality}/${productService.commit}`;\n}\n\nexport type UpdateNotAvailableClassification = {\n\towner: \"joaomoreno\";\n\texplicit: {\n\t\tclassification: \"SystemMetaData\";\n\t\tpurpose: \"FeatureInsight\";\n\t\tcomment: \"Whether the user has manually checked for updates, or this was an automatic check.\";\n\t};\n\tcomment: \"This is used to understand how often VS Code pings the update server for an update and there's none available.\";\n};\n\nexport type UpdateErrorClassification = {\n\towner: \"joaomoreno\";\n\tmessageHash: {\n\t\tclassification: \"SystemMetaData\";\n\t\tpurpose: \"FeatureInsight\";\n\t\tcomment: \"The hash of the error message.\";\n\t};\n\tcomment: \"This is used to know how often VS Code updates have failed.\";\n};\n\nexport abstract class AbstractUpdateService implements IUpdateService {\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprotected url: string | undefined;\n\n\tprivate _state: State = State.Uninitialized;\n\n\tprivate readonly _onStateChange = new Emitter<State>();\n\treadonly onStateChange: Event<State> = this._onStateChange.event;\n\n\tget state(): State {\n\t\treturn this._state;\n\t}\n\n\tprotected setState(state: State): void {\n\t\tthis.logService.info(\"update#setState\", state.type);\n\t\tthis._state = state;\n\t\tthis._onStateChange.fire(state);\n\t}\n\n\tconstructor(\n\t\t@ILifecycleMainService\n\t\tprotected readonly lifecycleMainService: ILifecycleMainService,\n\t\t@IConfigurationService\n\t\tprotected configurationService: IConfigurationService,\n\t\t@IEnvironmentMainService\n\t\tprivate readonly environmentMainService: IEnvironmentMainService,\n\t\t@IRequestService protected requestService: IRequestService,\n\t\t@ILogService protected logService: ILogService,\n\t\t@IProductService protected readonly productService: IProductService,\n\t) {\n\t\tlifecycleMainService\n\t\t\t.when(LifecycleMainPhase.AfterWindowOpen)\n\t\t\t.finally(() => this.initialize());\n\t}\n\n\t/**\n\t * This must be called before any other call. This is a performance\n\t * optimization, to avoid using extra CPU cycles before first window open.\n\t * https://github.com/microsoft/vscode/issues/89784\n\t */\n\tprotected async initialize(): Promise<void> {\n\t\tif (!this.environmentMainService.isBuilt) {\n\t\t\tthis.setState(State.Disabled(DisablementReason.NotBuilt));\n\t\t\treturn; // updates are never enabled when running out of sources\n\t\t}\n\n\t\tif (this.environmentMainService.disableUpdates) {\n\t\t\tthis.setState(\n\t\t\t\tState.Disabled(DisablementReason.DisabledByEnvironment),\n\t\t\t);\n\t\t\tthis.logService.info(\n\t\t\t\t\"update#ctor - updates are disabled by the environment\",\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.productService.updateUrl || !this.productService.commit) {\n\t\t\tthis.setState(\n\t\t\t\tState.Disabled(DisablementReason.MissingConfiguration),\n\t\t\t);\n\t\t\tthis.logService.info(\n\t\t\t\t\"update#ctor - updates are disabled as there is no update URL\",\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tconst updateMode = this.configurationService.getValue<\n\t\t\t\"none\" | \"manual\" | \"start\" | \"default\"\n\t\t>(\"update.mode\");\n\t\tconst quality = this.getProductQuality(updateMode);\n\n\t\tif (!quality) {\n\t\t\tthis.setState(State.Disabled(DisablementReason.ManuallyDisabled));\n\t\t\tthis.logService.info(\n\t\t\t\t\"update#ctor - updates are disabled by user preference\",\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tthis.url = this.buildUpdateFeedUrl(quality);\n\t\tif (!this.url) {\n\t\t\tthis.setState(\n\t\t\t\tState.Disabled(DisablementReason.InvalidConfiguration),\n\t\t\t);\n\t\t\tthis.logService.info(\n\t\t\t\t\"update#ctor - updates are disabled as the update URL is badly formed\",\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\t// hidden setting\n\t\tif (this.configurationService.getValue<boolean>(\"_update.prss\")) {\n\t\t\tconst url = new URL(this.url);\n\t\t\turl.searchParams.set(\"prss\", \"true\");\n\t\t\tthis.url = url.toString();\n\t\t}\n\n\t\tthis.setState(State.Idle(this.getUpdateType()));\n\n\t\tif (updateMode === \"manual\") {\n\t\t\tthis.logService.info(\n\t\t\t\t\"update#ctor - manual checks only; automatic updates are disabled by user preference\",\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tif (updateMode === \"start\") {\n\t\t\tthis.logService.info(\n\t\t\t\t\"update#ctor - startup checks only; automatic updates are disabled by user preference\",\n\t\t\t);\n\n\t\t\t// Check for updates only once after 30 seconds\n\t\t\tsetTimeout(() => this.checkForUpdates(false), 30 * 1000);\n\t\t} else {\n\t\t\t// Start checking for updates after 30 seconds\n\t\t\tthis.scheduleCheckForUpdates(30 * 1000).then(undefined, (err) =>\n\t\t\t\tthis.logService.error(err),\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate getProductQuality(updateMode: string): string | undefined {\n\t\treturn updateMode === \"none\" ? undefined : this.productService.quality;\n\t}\n\n\tprivate scheduleCheckForUpdates(delay = 60 * 60 * 1000): Promise<void> {\n\t\treturn timeout(delay)\n\t\t\t.then(() => this.checkForUpdates(false))\n\t\t\t.then(() => {\n\t\t\t\t// Check again after 1 hour\n\t\t\t\treturn this.scheduleCheckForUpdates(60 * 60 * 1000);\n\t\t\t});\n\t}\n\n\tasync checkForUpdates(explicit: boolean): Promise<void> {\n\t\tthis.logService.trace(\n\t\t\t\"update#checkForUpdates, state = \",\n\t\t\tthis.state.type,\n\t\t);\n\n\t\tif (this.state.type !== StateType.Idle) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.doCheckForUpdates(explicit);\n\t}\n\n\tasync downloadUpdate(): Promise<void> {\n\t\tthis.logService.trace(\n\t\t\t\"update#downloadUpdate, state = \",\n\t\t\tthis.state.type,\n\t\t);\n\n\t\tif (this.state.type !== StateType.AvailableForDownload) {\n\t\t\treturn;\n\t\t}\n\n\t\tawait this.doDownloadUpdate(this.state);\n\t}\n\n\tprotected async doDownloadUpdate(\n\t\tstate: AvailableForDownload,\n\t): Promise<void> {\n\t\t// noop\n\t}\n\n\tasync applyUpdate(): Promise<void> {\n\t\tthis.logService.trace(\"update#applyUpdate, state = \", this.state.type);\n\n\t\tif (this.state.type !== StateType.Downloaded) {\n\t\t\treturn;\n\t\t}\n\n\t\tawait this.doApplyUpdate();\n\t}\n\n\tprotected async doApplyUpdate(): Promise<void> {\n\t\t// noop\n\t}\n\n\tquitAndInstall(): Promise<void> {\n\t\tthis.logService.trace(\n\t\t\t\"update#quitAndInstall, state = \",\n\t\t\tthis.state.type,\n\t\t);\n\n\t\tif (this.state.type !== StateType.Ready) {\n\t\t\treturn Promise.resolve(undefined);\n\t\t}\n\n\t\tthis.logService.trace(\n\t\t\t\"update#quitAndInstall(): before lifecycle quit()\",\n\t\t);\n\n\t\tthis.lifecycleMainService\n\t\t\t.quit(true /* will restart */)\n\t\t\t.then((vetod) => {\n\t\t\t\tthis.logService.trace(\n\t\t\t\t\t`update#quitAndInstall(): after lifecycle quit() with veto: ${vetod}`,\n\t\t\t\t);\n\t\t\t\tif (vetod) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.logService.trace(\n\t\t\t\t\t\"update#quitAndInstall(): running raw#quitAndInstall()\",\n\t\t\t\t);\n\t\t\t\tthis.doQuitAndInstall();\n\t\t\t});\n\n\t\treturn Promise.resolve(undefined);\n\t}\n\n\tasync isLatestVersion(): Promise<boolean | undefined> {\n\t\tif (!this.url) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst mode = this.configurationService.getValue<\n\t\t\t\"none\" | \"manual\" | \"start\" | \"default\"\n\t\t>(\"update.mode\");\n\n\t\tif (mode === \"none\") {\n\t\t\treturn false;\n\t\t}\n\n\t\ttry {\n\t\t\tconst context = await this.requestService.request(\n\t\t\t\t{ url: this.url },\n\t\t\t\tCancellationToken.None,\n\t\t\t);\n\t\t\t// The update server replies with 204 (No Content) when no\n\t\t\t// update is available - that's all we want to know.\n\t\t\treturn context.res.statusCode === 204;\n\t\t} catch (error) {\n\t\t\tthis.logService.error(\n\t\t\t\t\"update#isLatestVersion(): failed to check for updates\",\n\t\t\t);\n\t\t\tthis.logService.error(error);\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tasync _applySpecificUpdate(packagePath: string): Promise<void> {\n\t\t// noop\n\t}\n\n\tprotected getUpdateType(): UpdateType {\n\t\treturn UpdateType.Archive;\n\t}\n\n\tprotected doQuitAndInstall(): void {\n\t\t// noop\n\t}\n\n\tprotected abstract buildUpdateFeedUrl(quality: string): string | undefined;\n\tprotected abstract doCheckForUpdates(context: any): void;\n}\n"],
  "mappings": "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",
  "names": []
}
