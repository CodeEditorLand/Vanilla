{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/update/electron-main/updateService.darwin.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as electron from 'electron';\nimport { memoize } from '../../../base/common/decorators.js';\nimport { Event } from '../../../base/common/event.js';\nimport { hash } from '../../../base/common/hash.js';\nimport { DisposableStore } from '../../../base/common/lifecycle.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { IEnvironmentMainService } from '../../environment/electron-main/environmentMainService.js';\nimport { ILifecycleMainService, IRelaunchHandler, IRelaunchOptions } from '../../lifecycle/electron-main/lifecycleMainService.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { IProductService } from '../../product/common/productService.js';\nimport { IRequestService } from '../../request/common/request.js';\nimport { ITelemetryService } from '../../telemetry/common/telemetry.js';\nimport { IUpdate, State, StateType, UpdateType } from '../common/update.js';\nimport { AbstractUpdateService, createUpdateURL, UpdateErrorClassification, UpdateNotAvailableClassification } from './abstractUpdateService.js';\n\nexport class DarwinUpdateService extends AbstractUpdateService implements IRelaunchHandler {\n\n\tprivate readonly disposables = new DisposableStore();\n\n\t@memoize private get onRawError(): Event<string> { return Event.fromNodeEventEmitter(electron.autoUpdater, 'error', (_, message) => message); }\n\t@memoize private get onRawUpdateNotAvailable(): Event<void> { return Event.fromNodeEventEmitter<void>(electron.autoUpdater, 'update-not-available'); }\n\t@memoize private get onRawUpdateAvailable(): Event<void> { return Event.fromNodeEventEmitter(electron.autoUpdater, 'update-available'); }\n\t@memoize private get onRawUpdateDownloaded(): Event<IUpdate> { return Event.fromNodeEventEmitter(electron.autoUpdater, 'update-downloaded', (_, releaseNotes, version, timestamp) => ({ version, productVersion: version, timestamp })); }\n\n\tconstructor(\n\t\t@ILifecycleMainService lifecycleMainService: ILifecycleMainService,\n\t\t@IConfigurationService configurationService: IConfigurationService,\n\t\t@ITelemetryService private readonly telemetryService: ITelemetryService,\n\t\t@IEnvironmentMainService environmentMainService: IEnvironmentMainService,\n\t\t@IRequestService requestService: IRequestService,\n\t\t@ILogService logService: ILogService,\n\t\t@IProductService productService: IProductService\n\t) {\n\t\tsuper(lifecycleMainService, configurationService, environmentMainService, requestService, logService, productService);\n\n\t\tlifecycleMainService.setRelaunchHandler(this);\n\t}\n\n\thandleRelaunch(options?: IRelaunchOptions): boolean {\n\t\tif (options?.addArgs || options?.removeArgs) {\n\t\t\treturn false; // we cannot apply an update and restart with different args\n\t\t}\n\n\t\tif (this.state.type !== StateType.Ready) {\n\t\t\treturn false; // we only handle the relaunch when we have a pending update\n\t\t}\n\n\t\tthis.logService.trace('update#handleRelaunch(): running raw#quitAndInstall()');\n\t\tthis.doQuitAndInstall();\n\n\t\treturn true;\n\t}\n\n\tprotected override async initialize(): Promise<void> {\n\t\tawait super.initialize();\n\t\tthis.onRawError(this.onError, this, this.disposables);\n\t\tthis.onRawUpdateAvailable(this.onUpdateAvailable, this, this.disposables);\n\t\tthis.onRawUpdateDownloaded(this.onUpdateDownloaded, this, this.disposables);\n\t\tthis.onRawUpdateNotAvailable(this.onUpdateNotAvailable, this, this.disposables);\n\t}\n\n\tprivate onError(err: string): void {\n\t\tthis.telemetryService.publicLog2<{ messageHash: string }, UpdateErrorClassification>('update:error', { messageHash: String(hash(String(err))) });\n\t\tthis.logService.error('UpdateService error:', err);\n\n\t\t// only show message when explicitly checking for updates\n\t\tconst message = (this.state.type === StateType.CheckingForUpdates && this.state.explicit) ? err : undefined;\n\t\tthis.setState(State.Idle(UpdateType.Archive, message));\n\t}\n\n\tprotected buildUpdateFeedUrl(quality: string): string | undefined {\n\t\tlet assetID: string;\n\t\tif (!this.productService.darwinUniversalAssetId) {\n\t\t\tassetID = process.arch === 'x64' ? 'darwin' : 'darwin-arm64';\n\t\t} else {\n\t\t\tassetID = this.productService.darwinUniversalAssetId;\n\t\t}\n\t\tconst url = createUpdateURL(assetID, quality, this.productService);\n\t\ttry {\n\t\t\telectron.autoUpdater.setFeedURL({ url });\n\t\t} catch (e) {\n\t\t\t// application is very likely not signed\n\t\t\tthis.logService.error('Failed to set update feed URL', e);\n\t\t\treturn undefined;\n\t\t}\n\t\treturn url;\n\t}\n\n\tprotected doCheckForUpdates(context: any): void {\n\t\tthis.setState(State.CheckingForUpdates(context));\n\t\telectron.autoUpdater.checkForUpdates();\n\t}\n\n\tprivate onUpdateAvailable(): void {\n\t\tif (this.state.type !== StateType.CheckingForUpdates) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.setState(State.Downloading);\n\t}\n\n\tprivate onUpdateDownloaded(update: IUpdate): void {\n\t\tif (this.state.type !== StateType.Downloading) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.setState(State.Downloaded(update));\n\n\t\ttype UpdateDownloadedClassification = {\n\t\t\towner: 'joaomoreno';\n\t\t\tversion: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'The version number of the new VS Code that has been downloaded.' };\n\t\t\tcomment: 'This is used to know how often VS Code has successfully downloaded the update.';\n\t\t};\n\t\tthis.telemetryService.publicLog2<{ version: String }, UpdateDownloadedClassification>('update:downloaded', { version: update.version });\n\n\t\tthis.setState(State.Ready(update));\n\t}\n\n\tprivate onUpdateNotAvailable(): void {\n\t\tif (this.state.type !== StateType.CheckingForUpdates) {\n\t\t\treturn;\n\t\t}\n\t\tthis.telemetryService.publicLog2<{ explicit: boolean }, UpdateNotAvailableClassification>('update:notAvailable', { explicit: this.state.explicit });\n\n\t\tthis.setState(State.Idle(UpdateType.Archive));\n\t}\n\n\tprotected override doQuitAndInstall(): void {\n\t\tthis.logService.trace('update#quitAndInstall(): running raw#quitAndInstall()');\n\t\telectron.autoUpdater.quitAndInstall();\n\t}\n\n\tdispose(): void {\n\t\tthis.disposables.dispose();\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
