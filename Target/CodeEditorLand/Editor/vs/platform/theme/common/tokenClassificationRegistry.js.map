{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/theme/common/tokenClassificationRegistry.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { RunOnceScheduler } from \"../../../base/common/async.js\";\nimport { Color } from \"../../../base/common/color.js\";\nimport { Emitter, type Event } from \"../../../base/common/event.js\";\nimport type {\n\tIJSONSchema,\n\tIJSONSchemaMap,\n} from \"../../../base/common/jsonSchema.js\";\nimport * as nls from \"../../../nls.js\";\nimport {\n\ttype IJSONContributionRegistry,\n\tExtensions as JSONExtensions,\n} from \"../../jsonschemas/common/jsonContributionRegistry.js\";\nimport * as platform from \"../../registry/common/platform.js\";\nimport type { IColorTheme } from \"./themeService.js\";\n\nconst TOKEN_TYPE_WILDCARD = \"*\";\nconst TOKEN_CLASSIFIER_LANGUAGE_SEPARATOR = \":\";\nconst CLASSIFIER_MODIFIER_SEPARATOR = \".\";\n\n// qualified string [type|*](.modifier)*(/language)!\ntype TokenClassificationString = string;\n\nconst idPattern = \"\\\\w+[-_\\\\w+]*\";\nexport const typeAndModifierIdPattern = `^${idPattern}$`;\n\nconst selectorPattern = `^(${idPattern}|\\\\*)(\\\\${CLASSIFIER_MODIFIER_SEPARATOR}${idPattern})*(${TOKEN_CLASSIFIER_LANGUAGE_SEPARATOR}${idPattern})?$`;\n\nconst fontStylePattern = \"^(\\\\s*(italic|bold|underline|strikethrough))*\\\\s*$\";\n\nexport interface TokenSelector {\n\tmatch(type: string, modifiers: string[], language: string): number;\n\treadonly id: string;\n}\n\nexport interface TokenTypeOrModifierContribution {\n\treadonly num: number;\n\treadonly id: string;\n\treadonly superType?: string;\n\treadonly description: string;\n\treadonly deprecationMessage?: string;\n}\n\nexport interface TokenStyleData {\n\tforeground: Color | undefined;\n\tbold: boolean | undefined;\n\tunderline: boolean | undefined;\n\tstrikethrough: boolean | undefined;\n\titalic: boolean | undefined;\n}\n\nexport class TokenStyle implements Readonly<TokenStyleData> {\n\tconstructor(\n\t\tpublic readonly foreground: Color | undefined,\n\t\tpublic readonly bold: boolean | undefined,\n\t\tpublic readonly underline: boolean | undefined,\n\t\tpublic readonly strikethrough: boolean | undefined,\n\t\tpublic readonly italic: boolean | undefined,\n\t) {}\n}\n\nexport namespace TokenStyle {\n\texport function toJSONObject(style: TokenStyle): any {\n\t\treturn {\n\t\t\t_foreground:\n\t\t\t\tstyle.foreground === undefined\n\t\t\t\t\t? null\n\t\t\t\t\t: Color.Format.CSS.formatHexA(style.foreground, true),\n\t\t\t_bold: style.bold === undefined ? null : style.bold,\n\t\t\t_underline: style.underline === undefined ? null : style.underline,\n\t\t\t_italic: style.italic === undefined ? null : style.italic,\n\t\t\t_strikethrough:\n\t\t\t\tstyle.strikethrough === undefined ? null : style.strikethrough,\n\t\t};\n\t}\n\texport function fromJSONObject(obj: any): TokenStyle | undefined {\n\t\tif (obj) {\n\t\t\tconst boolOrUndef = (b: any) =>\n\t\t\t\ttypeof b === \"boolean\" ? b : undefined;\n\t\t\tconst colorOrUndef = (s: any) =>\n\t\t\t\ttypeof s === \"string\" ? Color.fromHex(s) : undefined;\n\t\t\treturn new TokenStyle(\n\t\t\t\tcolorOrUndef(obj._foreground),\n\t\t\t\tboolOrUndef(obj._bold),\n\t\t\t\tboolOrUndef(obj._underline),\n\t\t\t\tboolOrUndef(obj._strikethrough),\n\t\t\t\tboolOrUndef(obj._italic),\n\t\t\t);\n\t\t}\n\t\treturn undefined;\n\t}\n\texport function equals(s1: any, s2: any): boolean {\n\t\tif (s1 === s2) {\n\t\t\treturn true;\n\t\t}\n\t\treturn (\n\t\t\ts1 !== undefined &&\n\t\t\ts2 !== undefined &&\n\t\t\t(s1.foreground instanceof Color\n\t\t\t\t? s1.foreground.equals(s2.foreground)\n\t\t\t\t: s2.foreground === undefined) &&\n\t\t\ts1.bold === s2.bold &&\n\t\t\ts1.underline === s2.underline &&\n\t\t\ts1.strikethrough === s2.strikethrough &&\n\t\t\ts1.italic === s2.italic\n\t\t);\n\t}\n\texport function is(s: any): s is TokenStyle {\n\t\treturn s instanceof TokenStyle;\n\t}\n\texport function fromData(data: {\n\t\tforeground: Color | undefined;\n\t\tbold: boolean | undefined;\n\t\tunderline: boolean | undefined;\n\t\tstrikethrough: boolean | undefined;\n\t\titalic: boolean | undefined;\n\t}): TokenStyle {\n\t\treturn new TokenStyle(\n\t\t\tdata.foreground,\n\t\t\tdata.bold,\n\t\t\tdata.underline,\n\t\t\tdata.strikethrough,\n\t\t\tdata.italic,\n\t\t);\n\t}\n\texport function fromSettings(\n\t\tforeground: string | undefined,\n\t\tfontStyle: string | undefined,\n\t): TokenStyle;\n\texport function fromSettings(\n\t\tforeground: string | undefined,\n\t\tfontStyle: string | undefined,\n\t\tbold: boolean | undefined,\n\t\tunderline: boolean | undefined,\n\t\tstrikethrough: boolean | undefined,\n\t\titalic: boolean | undefined,\n\t): TokenStyle;\n\texport function fromSettings(\n\t\tforeground: string | undefined,\n\t\tfontStyle: string | undefined,\n\t\tbold?: boolean,\n\t\tunderline?: boolean,\n\t\tstrikethrough?: boolean,\n\t\titalic?: boolean,\n\t): TokenStyle {\n\t\tlet foregroundColor;\n\t\tif (foreground !== undefined) {\n\t\t\tforegroundColor = Color.fromHex(foreground);\n\t\t}\n\t\tif (fontStyle !== undefined) {\n\t\t\tbold = italic = underline = strikethrough = false;\n\t\t\tconst expression = /italic|bold|underline|strikethrough/g;\n\t\t\tlet match;\n\t\t\twhile ((match = expression.exec(fontStyle))) {\n\t\t\t\tswitch (match[0]) {\n\t\t\t\t\tcase \"bold\":\n\t\t\t\t\t\tbold = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"italic\":\n\t\t\t\t\t\titalic = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"underline\":\n\t\t\t\t\t\tunderline = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"strikethrough\":\n\t\t\t\t\t\tstrikethrough = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new TokenStyle(\n\t\t\tforegroundColor,\n\t\t\tbold,\n\t\t\tunderline,\n\t\t\tstrikethrough,\n\t\t\titalic,\n\t\t);\n\t}\n}\n\nexport type ProbeScope = string[];\n\nexport interface TokenStyleFunction {\n\t(theme: IColorTheme): TokenStyle | undefined;\n}\n\nexport interface TokenStyleDefaults {\n\tscopesToProbe?: ProbeScope[];\n\tlight?: TokenStyleValue;\n\tdark?: TokenStyleValue;\n\thcDark?: TokenStyleValue;\n\thcLight?: TokenStyleValue;\n}\n\nexport interface SemanticTokenDefaultRule {\n\tselector: TokenSelector;\n\tdefaults: TokenStyleDefaults;\n}\n\nexport interface SemanticTokenRule {\n\tstyle: TokenStyle;\n\tselector: TokenSelector;\n}\n\nexport namespace SemanticTokenRule {\n\texport function fromJSONObject(\n\t\tregistry: ITokenClassificationRegistry,\n\t\to: any,\n\t): SemanticTokenRule | undefined {\n\t\tif (o && typeof o._selector === \"string\" && o._style) {\n\t\t\tconst style = TokenStyle.fromJSONObject(o._style);\n\t\t\tif (style) {\n\t\t\t\ttry {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tselector: registry.parseTokenSelector(o._selector),\n\t\t\t\t\t\tstyle,\n\t\t\t\t\t};\n\t\t\t\t} catch (_ignore) {}\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\texport function toJSONObject(rule: SemanticTokenRule): any {\n\t\treturn {\n\t\t\t_selector: rule.selector.id,\n\t\t\t_style: TokenStyle.toJSONObject(rule.style),\n\t\t};\n\t}\n\texport function equals(\n\t\tr1: SemanticTokenRule | undefined,\n\t\tr2: SemanticTokenRule | undefined,\n\t) {\n\t\tif (r1 === r2) {\n\t\t\treturn true;\n\t\t}\n\t\treturn (\n\t\t\tr1 !== undefined &&\n\t\t\tr2 !== undefined &&\n\t\t\tr1.selector &&\n\t\t\tr2.selector &&\n\t\t\tr1.selector.id === r2.selector.id &&\n\t\t\tTokenStyle.equals(r1.style, r2.style)\n\t\t);\n\t}\n\texport function is(r: any): r is SemanticTokenRule {\n\t\treturn (\n\t\t\tr &&\n\t\t\tr.selector &&\n\t\t\ttypeof r.selector.id === \"string\" &&\n\t\t\tTokenStyle.is(r.style)\n\t\t);\n\t}\n}\n\n/**\n * A TokenStyle Value is either a token style literal, or a TokenClassificationString\n */\nexport type TokenStyleValue = TokenStyle | TokenClassificationString;\n\n// TokenStyle registry\nconst Extensions = {\n\tTokenClassificationContribution: \"base.contributions.tokenClassification\",\n};\n\nexport interface ITokenClassificationRegistry {\n\treadonly onDidChangeSchema: Event<void>;\n\n\t/**\n\t * Register a token type to the registry.\n\t * @param id The TokenType id as used in theme description files\n\t * @param description the description\n\t */\n\tregisterTokenType(\n\t\tid: string,\n\t\tdescription: string,\n\t\tsuperType?: string,\n\t\tdeprecationMessage?: string,\n\t): void;\n\n\t/**\n\t * Register a token modifier to the registry.\n\t * @param id The TokenModifier id as used in theme description files\n\t * @param description the description\n\t */\n\tregisterTokenModifier(id: string, description: string): void;\n\n\t/**\n\t * Parses a token selector from a selector string.\n\t * @param selectorString selector string in the form (*|type)(.modifier)*\n\t * @param language language to which the selector applies or undefined if the selector is for all languafe\n\t * @returns the parsesd selector\n\t * @throws an error if the string is not a valid selector\n\t */\n\tparseTokenSelector(\n\t\tselectorString: string,\n\t\tlanguage?: string,\n\t): TokenSelector;\n\n\t/**\n\t * Register a TokenStyle default to the registry.\n\t * @param selector The rule selector\n\t * @param defaults The default values\n\t */\n\tregisterTokenStyleDefault(\n\t\tselector: TokenSelector,\n\t\tdefaults: TokenStyleDefaults,\n\t): void;\n\n\t/**\n\t * Deregister a TokenStyle default to the registry.\n\t * @param selector The rule selector\n\t */\n\tderegisterTokenStyleDefault(selector: TokenSelector): void;\n\n\t/**\n\t * Deregister a TokenType from the registry.\n\t */\n\tderegisterTokenType(id: string): void;\n\n\t/**\n\t * Deregister a TokenModifier from the registry.\n\t */\n\tderegisterTokenModifier(id: string): void;\n\n\t/**\n\t * Get all TokenType contributions\n\t */\n\tgetTokenTypes(): TokenTypeOrModifierContribution[];\n\n\t/**\n\t * Get all TokenModifier contributions\n\t */\n\tgetTokenModifiers(): TokenTypeOrModifierContribution[];\n\n\t/**\n\t * The styling rules to used when a schema does not define any styling rules.\n\t */\n\tgetTokenStylingDefaultRules(): SemanticTokenDefaultRule[];\n\n\t/**\n\t * JSON schema for an object to assign styling to token classifications\n\t */\n\tgetTokenStylingSchema(): IJSONSchema;\n}\n\nclass TokenClassificationRegistry implements ITokenClassificationRegistry {\n\tprivate readonly _onDidChangeSchema = new Emitter<void>();\n\treadonly onDidChangeSchema: Event<void> = this._onDidChangeSchema.event;\n\n\tprivate currentTypeNumber = 0;\n\tprivate currentModifierBit = 1;\n\n\tprivate tokenTypeById: { [key: string]: TokenTypeOrModifierContribution };\n\tprivate tokenModifierById: {\n\t\t[key: string]: TokenTypeOrModifierContribution;\n\t};\n\n\tprivate tokenStylingDefaultRules: SemanticTokenDefaultRule[] = [];\n\n\tprivate typeHierarchy: { [id: string]: string[] };\n\n\tprivate tokenStylingSchema: IJSONSchema & {\n\t\tproperties: IJSONSchemaMap;\n\t\tpatternProperties: IJSONSchemaMap;\n\t} = {\n\t\ttype: \"object\",\n\t\tproperties: {},\n\t\tpatternProperties: {\n\t\t\t[selectorPattern]: getStylingSchemeEntry(),\n\t\t},\n\t\t//errorMessage: nls.localize('schema.token.errors', 'Valid token selectors have the form (*|tokenType)(.tokenModifier)*(:tokenLanguage)?.'),\n\t\tadditionalProperties: false,\n\t\tdefinitions: {\n\t\t\tstyle: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tdescription: nls.localize(\n\t\t\t\t\t\"schema.token.settings\",\n\t\t\t\t\t\"Colors and styles for the token.\",\n\t\t\t\t),\n\t\t\t\tproperties: {\n\t\t\t\t\tforeground: {\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tdescription: nls.localize(\n\t\t\t\t\t\t\t\"schema.token.foreground\",\n\t\t\t\t\t\t\t\"Foreground color for the token.\",\n\t\t\t\t\t\t),\n\t\t\t\t\t\tformat: \"color-hex\",\n\t\t\t\t\t\tdefault: \"#ff0000\",\n\t\t\t\t\t},\n\t\t\t\t\tbackground: {\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tdeprecationMessage: nls.localize(\n\t\t\t\t\t\t\t\"schema.token.background.warning\",\n\t\t\t\t\t\t\t\"Token background colors are currently not supported.\",\n\t\t\t\t\t\t),\n\t\t\t\t\t},\n\t\t\t\t\tfontStyle: {\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tdescription: nls.localize(\n\t\t\t\t\t\t\t\"schema.token.fontStyle\",\n\t\t\t\t\t\t\t\"Sets the all font styles of the rule: 'italic', 'bold', 'underline' or 'strikethrough' or a combination. All styles that are not listed are unset. The empty string unsets all styles.\",\n\t\t\t\t\t\t),\n\t\t\t\t\t\tpattern: fontStylePattern,\n\t\t\t\t\t\tpatternErrorMessage: nls.localize(\n\t\t\t\t\t\t\t\"schema.fontStyle.error\",\n\t\t\t\t\t\t\t\"Font style must be 'italic', 'bold', 'underline' or 'strikethrough' or a combination. The empty string unsets all styles.\",\n\t\t\t\t\t\t),\n\t\t\t\t\t\tdefaultSnippets: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlabel: nls.localize(\n\t\t\t\t\t\t\t\t\t\"schema.token.fontStyle.none\",\n\t\t\t\t\t\t\t\t\t\"None (clear inherited style)\",\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\tbodyText: '\"\"',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{ body: \"italic\" },\n\t\t\t\t\t\t\t{ body: \"bold\" },\n\t\t\t\t\t\t\t{ body: \"underline\" },\n\t\t\t\t\t\t\t{ body: \"strikethrough\" },\n\t\t\t\t\t\t\t{ body: \"italic bold\" },\n\t\t\t\t\t\t\t{ body: \"italic underline\" },\n\t\t\t\t\t\t\t{ body: \"italic strikethrough\" },\n\t\t\t\t\t\t\t{ body: \"bold underline\" },\n\t\t\t\t\t\t\t{ body: \"bold strikethrough\" },\n\t\t\t\t\t\t\t{ body: \"underline strikethrough\" },\n\t\t\t\t\t\t\t{ body: \"italic bold underline\" },\n\t\t\t\t\t\t\t{ body: \"italic bold strikethrough\" },\n\t\t\t\t\t\t\t{ body: \"italic underline strikethrough\" },\n\t\t\t\t\t\t\t{ body: \"bold underline strikethrough\" },\n\t\t\t\t\t\t\t{ body: \"italic bold underline strikethrough\" },\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t\tbold: {\n\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\tdescription: nls.localize(\n\t\t\t\t\t\t\t\"schema.token.bold\",\n\t\t\t\t\t\t\t\"Sets or unsets the font style to bold. Note, the presence of 'fontStyle' overrides this setting.\",\n\t\t\t\t\t\t),\n\t\t\t\t\t},\n\t\t\t\t\titalic: {\n\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\tdescription: nls.localize(\n\t\t\t\t\t\t\t\"schema.token.italic\",\n\t\t\t\t\t\t\t\"Sets or unsets the font style to italic. Note, the presence of 'fontStyle' overrides this setting.\",\n\t\t\t\t\t\t),\n\t\t\t\t\t},\n\t\t\t\t\tunderline: {\n\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\tdescription: nls.localize(\n\t\t\t\t\t\t\t\"schema.token.underline\",\n\t\t\t\t\t\t\t\"Sets or unsets the font style to underline. Note, the presence of 'fontStyle' overrides this setting.\",\n\t\t\t\t\t\t),\n\t\t\t\t\t},\n\t\t\t\t\tstrikethrough: {\n\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\tdescription: nls.localize(\n\t\t\t\t\t\t\t\"schema.token.strikethrough\",\n\t\t\t\t\t\t\t\"Sets or unsets the font style to strikethrough. Note, the presence of 'fontStyle' overrides this setting.\",\n\t\t\t\t\t\t),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefaultSnippets: [\n\t\t\t\t\t{\n\t\t\t\t\t\tbody: {\n\t\t\t\t\t\t\tforeground: \"${1:#FF0000}\",\n\t\t\t\t\t\t\tfontStyle: \"${2:bold}\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t},\n\t};\n\n\tconstructor() {\n\t\tthis.tokenTypeById = Object.create(null);\n\t\tthis.tokenModifierById = Object.create(null);\n\t\tthis.typeHierarchy = Object.create(null);\n\t}\n\n\tpublic registerTokenType(\n\t\tid: string,\n\t\tdescription: string,\n\t\tsuperType?: string,\n\t\tdeprecationMessage?: string,\n\t): void {\n\t\tif (!id.match(typeAndModifierIdPattern)) {\n\t\t\tthrow new Error(\"Invalid token type id.\");\n\t\t}\n\t\tif (superType && !superType.match(typeAndModifierIdPattern)) {\n\t\t\tthrow new Error(\"Invalid token super type id.\");\n\t\t}\n\n\t\tconst num = this.currentTypeNumber++;\n\t\tconst tokenStyleContribution: TokenTypeOrModifierContribution = {\n\t\t\tnum,\n\t\t\tid,\n\t\t\tsuperType,\n\t\t\tdescription,\n\t\t\tdeprecationMessage,\n\t\t};\n\t\tthis.tokenTypeById[id] = tokenStyleContribution;\n\n\t\tconst stylingSchemeEntry = getStylingSchemeEntry(\n\t\t\tdescription,\n\t\t\tdeprecationMessage,\n\t\t);\n\t\tthis.tokenStylingSchema.properties[id] = stylingSchemeEntry;\n\t\tthis.typeHierarchy = Object.create(null);\n\t}\n\n\tpublic registerTokenModifier(\n\t\tid: string,\n\t\tdescription: string,\n\t\tdeprecationMessage?: string,\n\t): void {\n\t\tif (!id.match(typeAndModifierIdPattern)) {\n\t\t\tthrow new Error(\"Invalid token modifier id.\");\n\t\t}\n\n\t\tconst num = this.currentModifierBit;\n\t\tthis.currentModifierBit = this.currentModifierBit * 2;\n\t\tconst tokenStyleContribution: TokenTypeOrModifierContribution = {\n\t\t\tnum,\n\t\t\tid,\n\t\t\tdescription,\n\t\t\tdeprecationMessage,\n\t\t};\n\t\tthis.tokenModifierById[id] = tokenStyleContribution;\n\n\t\tthis.tokenStylingSchema.properties[`*.${id}`] = getStylingSchemeEntry(\n\t\t\tdescription,\n\t\t\tdeprecationMessage,\n\t\t);\n\t}\n\n\tpublic parseTokenSelector(\n\t\tselectorString: string,\n\t\tlanguage?: string,\n\t): TokenSelector {\n\t\tconst selector = parseClassifierString(selectorString, language);\n\n\t\tif (!selector.type) {\n\t\t\treturn {\n\t\t\t\tmatch: () => -1,\n\t\t\t\tid: \"$invalid\",\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tmatch: (type: string, modifiers: string[], language: string) => {\n\t\t\t\tlet score = 0;\n\t\t\t\tif (selector.language !== undefined) {\n\t\t\t\t\tif (selector.language !== language) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tscore += 10;\n\t\t\t\t}\n\t\t\t\tif (selector.type !== TOKEN_TYPE_WILDCARD) {\n\t\t\t\t\tconst hierarchy = this.getTypeHierarchy(type);\n\t\t\t\t\tconst level = hierarchy.indexOf(selector.type);\n\t\t\t\t\tif (level === -1) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tscore += 100 - level;\n\t\t\t\t}\n\t\t\t\t// all selector modifiers must be present\n\t\t\t\tfor (const selectorModifier of selector.modifiers) {\n\t\t\t\t\tif (modifiers.indexOf(selectorModifier) === -1) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn score + selector.modifiers.length * 100;\n\t\t\t},\n\t\t\tid: `${[selector.type, ...selector.modifiers.sort()].join(\".\")}${selector.language !== undefined ? \":\" + selector.language : \"\"}`,\n\t\t};\n\t}\n\n\tpublic registerTokenStyleDefault(\n\t\tselector: TokenSelector,\n\t\tdefaults: TokenStyleDefaults,\n\t): void {\n\t\tthis.tokenStylingDefaultRules.push({ selector, defaults });\n\t}\n\n\tpublic deregisterTokenStyleDefault(selector: TokenSelector): void {\n\t\tconst selectorString = selector.id;\n\t\tthis.tokenStylingDefaultRules = this.tokenStylingDefaultRules.filter(\n\t\t\t(r) => r.selector.id !== selectorString,\n\t\t);\n\t}\n\n\tpublic deregisterTokenType(id: string): void {\n\t\tdelete this.tokenTypeById[id];\n\t\tdelete this.tokenStylingSchema.properties[id];\n\t\tthis.typeHierarchy = Object.create(null);\n\t}\n\n\tpublic deregisterTokenModifier(id: string): void {\n\t\tdelete this.tokenModifierById[id];\n\t\tdelete this.tokenStylingSchema.properties[`*.${id}`];\n\t}\n\n\tpublic getTokenTypes(): TokenTypeOrModifierContribution[] {\n\t\treturn Object.keys(this.tokenTypeById).map(\n\t\t\t(id) => this.tokenTypeById[id],\n\t\t);\n\t}\n\n\tpublic getTokenModifiers(): TokenTypeOrModifierContribution[] {\n\t\treturn Object.keys(this.tokenModifierById).map(\n\t\t\t(id) => this.tokenModifierById[id],\n\t\t);\n\t}\n\n\tpublic getTokenStylingSchema(): IJSONSchema {\n\t\treturn this.tokenStylingSchema;\n\t}\n\n\tpublic getTokenStylingDefaultRules(): SemanticTokenDefaultRule[] {\n\t\treturn this.tokenStylingDefaultRules;\n\t}\n\n\tprivate getTypeHierarchy(typeId: string): string[] {\n\t\tlet hierarchy = this.typeHierarchy[typeId];\n\t\tif (!hierarchy) {\n\t\t\tthis.typeHierarchy[typeId] = hierarchy = [typeId];\n\t\t\tlet type = this.tokenTypeById[typeId];\n\t\t\twhile (type && type.superType) {\n\t\t\t\thierarchy.push(type.superType);\n\t\t\t\ttype = this.tokenTypeById[type.superType];\n\t\t\t}\n\t\t}\n\t\treturn hierarchy;\n\t}\n\n\tpublic toString() {\n\t\tconst sorter = (a: string, b: string) => {\n\t\t\tconst cat1 = a.indexOf(\".\") === -1 ? 0 : 1;\n\t\t\tconst cat2 = b.indexOf(\".\") === -1 ? 0 : 1;\n\t\t\tif (cat1 !== cat2) {\n\t\t\t\treturn cat1 - cat2;\n\t\t\t}\n\t\t\treturn a.localeCompare(b);\n\t\t};\n\n\t\treturn Object.keys(this.tokenTypeById)\n\t\t\t.sort(sorter)\n\t\t\t.map((k) => `- \\`${k}\\`: ${this.tokenTypeById[k].description}`)\n\t\t\t.join(\"\\n\");\n\t}\n}\n\nconst CHAR_LANGUAGE = TOKEN_CLASSIFIER_LANGUAGE_SEPARATOR.charCodeAt(0);\nconst CHAR_MODIFIER = CLASSIFIER_MODIFIER_SEPARATOR.charCodeAt(0);\n\nexport function parseClassifierString(\n\ts: string,\n\tdefaultLanguage: string,\n): { type: string; modifiers: string[]; language: string };\nexport function parseClassifierString(\n\ts: string,\n\tdefaultLanguage?: string,\n): { type: string; modifiers: string[]; language: string | undefined };\nexport function parseClassifierString(\n\ts: string,\n\tdefaultLanguage: string | undefined,\n): { type: string; modifiers: string[]; language: string | undefined } {\n\tlet k = s.length;\n\tlet language: string | undefined = defaultLanguage;\n\tconst modifiers = [];\n\n\tfor (let i = k - 1; i >= 0; i--) {\n\t\tconst ch = s.charCodeAt(i);\n\t\tif (ch === CHAR_LANGUAGE || ch === CHAR_MODIFIER) {\n\t\t\tconst segment = s.substring(i + 1, k);\n\t\t\tk = i;\n\t\t\tif (ch === CHAR_LANGUAGE) {\n\t\t\t\tlanguage = segment;\n\t\t\t} else {\n\t\t\t\tmodifiers.push(segment);\n\t\t\t}\n\t\t}\n\t}\n\tconst type = s.substring(0, k);\n\treturn { type, modifiers, language };\n}\n\nconst tokenClassificationRegistry = createDefaultTokenClassificationRegistry();\nplatform.Registry.add(\n\tExtensions.TokenClassificationContribution,\n\ttokenClassificationRegistry,\n);\n\nfunction createDefaultTokenClassificationRegistry(): TokenClassificationRegistry {\n\tconst registry = new TokenClassificationRegistry();\n\n\tfunction registerTokenType(\n\t\tid: string,\n\t\tdescription: string,\n\t\tscopesToProbe: ProbeScope[] = [],\n\t\tsuperType?: string,\n\t\tdeprecationMessage?: string,\n\t): string {\n\t\tregistry.registerTokenType(\n\t\t\tid,\n\t\t\tdescription,\n\t\t\tsuperType,\n\t\t\tdeprecationMessage,\n\t\t);\n\t\tif (scopesToProbe) {\n\t\t\tregisterTokenStyleDefault(id, scopesToProbe);\n\t\t}\n\t\treturn id;\n\t}\n\n\tfunction registerTokenStyleDefault(\n\t\tselectorString: string,\n\t\tscopesToProbe: ProbeScope[],\n\t) {\n\t\ttry {\n\t\t\tconst selector = registry.parseTokenSelector(selectorString);\n\t\t\tregistry.registerTokenStyleDefault(selector, { scopesToProbe });\n\t\t} catch (e) {\n\t\t\tconsole.log(e);\n\t\t}\n\t}\n\n\t// default token types\n\n\tregisterTokenType(\n\t\t\"comment\",\n\t\tnls.localize(\"comment\", \"Style for comments.\"),\n\t\t[[\"comment\"]],\n\t);\n\tregisterTokenType(\"string\", nls.localize(\"string\", \"Style for strings.\"), [\n\t\t[\"string\"],\n\t]);\n\tregisterTokenType(\n\t\t\"keyword\",\n\t\tnls.localize(\"keyword\", \"Style for keywords.\"),\n\t\t[[\"keyword.control\"]],\n\t);\n\tregisterTokenType(\"number\", nls.localize(\"number\", \"Style for numbers.\"), [\n\t\t[\"constant.numeric\"],\n\t]);\n\tregisterTokenType(\n\t\t\"regexp\",\n\t\tnls.localize(\"regexp\", \"Style for expressions.\"),\n\t\t[[\"constant.regexp\"]],\n\t);\n\tregisterTokenType(\n\t\t\"operator\",\n\t\tnls.localize(\"operator\", \"Style for operators.\"),\n\t\t[[\"keyword.operator\"]],\n\t);\n\n\tregisterTokenType(\n\t\t\"namespace\",\n\t\tnls.localize(\"namespace\", \"Style for namespaces.\"),\n\t\t[[\"entity.name.namespace\"]],\n\t);\n\n\tregisterTokenType(\"type\", nls.localize(\"type\", \"Style for types.\"), [\n\t\t[\"entity.name.type\"],\n\t\t[\"support.type\"],\n\t]);\n\tregisterTokenType(\"struct\", nls.localize(\"struct\", \"Style for structs.\"), [\n\t\t[\"entity.name.type.struct\"],\n\t]);\n\tregisterTokenType(\"class\", nls.localize(\"class\", \"Style for classes.\"), [\n\t\t[\"entity.name.type.class\"],\n\t\t[\"support.class\"],\n\t]);\n\tregisterTokenType(\n\t\t\"interface\",\n\t\tnls.localize(\"interface\", \"Style for interfaces.\"),\n\t\t[[\"entity.name.type.interface\"]],\n\t);\n\tregisterTokenType(\"enum\", nls.localize(\"enum\", \"Style for enums.\"), [\n\t\t[\"entity.name.type.enum\"],\n\t]);\n\tregisterTokenType(\n\t\t\"typeParameter\",\n\t\tnls.localize(\"typeParameter\", \"Style for type parameters.\"),\n\t\t[[\"entity.name.type.parameter\"]],\n\t);\n\n\tregisterTokenType(\n\t\t\"function\",\n\t\tnls.localize(\"function\", \"Style for functions\"),\n\t\t[[\"entity.name.function\"], [\"support.function\"]],\n\t);\n\tregisterTokenType(\n\t\t\"member\",\n\t\tnls.localize(\"member\", \"Style for member functions\"),\n\t\t[],\n\t\t\"method\",\n\t\t\"Deprecated use `method` instead\",\n\t);\n\tregisterTokenType(\n\t\t\"method\",\n\t\tnls.localize(\"method\", \"Style for method (member functions)\"),\n\t\t[[\"entity.name.function.member\"], [\"support.function\"]],\n\t);\n\tregisterTokenType(\"macro\", nls.localize(\"macro\", \"Style for macros.\"), [\n\t\t[\"entity.name.function.preprocessor\"],\n\t]);\n\n\tregisterTokenType(\n\t\t\"variable\",\n\t\tnls.localize(\"variable\", \"Style for variables.\"),\n\t\t[[\"variable.other.readwrite\"], [\"entity.name.variable\"]],\n\t);\n\tregisterTokenType(\n\t\t\"parameter\",\n\t\tnls.localize(\"parameter\", \"Style for parameters.\"),\n\t\t[[\"variable.parameter\"]],\n\t);\n\tregisterTokenType(\n\t\t\"property\",\n\t\tnls.localize(\"property\", \"Style for properties.\"),\n\t\t[[\"variable.other.property\"]],\n\t);\n\tregisterTokenType(\n\t\t\"enumMember\",\n\t\tnls.localize(\"enumMember\", \"Style for enum members.\"),\n\t\t[[\"variable.other.enummember\"]],\n\t);\n\tregisterTokenType(\"event\", nls.localize(\"event\", \"Style for events.\"), [\n\t\t[\"variable.other.event\"],\n\t]);\n\tregisterTokenType(\n\t\t\"decorator\",\n\t\tnls.localize(\"decorator\", \"Style for decorators & annotations.\"),\n\t\t[[\"entity.name.decorator\"], [\"entity.name.function\"]],\n\t);\n\n\tregisterTokenType(\n\t\t\"label\",\n\t\tnls.localize(\"labels\", \"Style for labels. \"),\n\t\tundefined,\n\t);\n\n\t// default token modifiers\n\n\tregistry.registerTokenModifier(\n\t\t\"declaration\",\n\t\tnls.localize(\"declaration\", \"Style for all symbol declarations.\"),\n\t\tundefined,\n\t);\n\tregistry.registerTokenModifier(\n\t\t\"documentation\",\n\t\tnls.localize(\n\t\t\t\"documentation\",\n\t\t\t\"Style to use for references in documentation.\",\n\t\t),\n\t\tundefined,\n\t);\n\tregistry.registerTokenModifier(\n\t\t\"static\",\n\t\tnls.localize(\"static\", \"Style to use for symbols that are static.\"),\n\t\tundefined,\n\t);\n\tregistry.registerTokenModifier(\n\t\t\"abstract\",\n\t\tnls.localize(\"abstract\", \"Style to use for symbols that are abstract.\"),\n\t\tundefined,\n\t);\n\tregistry.registerTokenModifier(\n\t\t\"deprecated\",\n\t\tnls.localize(\n\t\t\t\"deprecated\",\n\t\t\t\"Style to use for symbols that are deprecated.\",\n\t\t),\n\t\tundefined,\n\t);\n\tregistry.registerTokenModifier(\n\t\t\"modification\",\n\t\tnls.localize(\"modification\", \"Style to use for write accesses.\"),\n\t\tundefined,\n\t);\n\tregistry.registerTokenModifier(\n\t\t\"async\",\n\t\tnls.localize(\"async\", \"Style to use for symbols that are async.\"),\n\t\tundefined,\n\t);\n\tregistry.registerTokenModifier(\n\t\t\"readonly\",\n\t\tnls.localize(\n\t\t\t\"readonly\",\n\t\t\t\"Style to use for symbols that are read-only.\",\n\t\t),\n\t\tundefined,\n\t);\n\n\tregisterTokenStyleDefault(\"variable.readonly\", [\n\t\t[\"variable.other.constant\"],\n\t]);\n\tregisterTokenStyleDefault(\"property.readonly\", [\n\t\t[\"variable.other.constant.property\"],\n\t]);\n\tregisterTokenStyleDefault(\"type.defaultLibrary\", [[\"support.type\"]]);\n\tregisterTokenStyleDefault(\"class.defaultLibrary\", [[\"support.class\"]]);\n\tregisterTokenStyleDefault(\"interface.defaultLibrary\", [[\"support.class\"]]);\n\tregisterTokenStyleDefault(\"variable.defaultLibrary\", [\n\t\t[\"support.variable\"],\n\t\t[\"support.other.variable\"],\n\t]);\n\tregisterTokenStyleDefault(\"variable.defaultLibrary.readonly\", [\n\t\t[\"support.constant\"],\n\t]);\n\tregisterTokenStyleDefault(\"property.defaultLibrary\", [\n\t\t[\"support.variable.property\"],\n\t]);\n\tregisterTokenStyleDefault(\"property.defaultLibrary.readonly\", [\n\t\t[\"support.constant.property\"],\n\t]);\n\tregisterTokenStyleDefault(\"function.defaultLibrary\", [\n\t\t[\"support.function\"],\n\t]);\n\tregisterTokenStyleDefault(\"member.defaultLibrary\", [[\"support.function\"]]);\n\treturn registry;\n}\n\nexport function getTokenClassificationRegistry(): ITokenClassificationRegistry {\n\treturn tokenClassificationRegistry;\n}\n\nfunction getStylingSchemeEntry(\n\tdescription?: string,\n\tdeprecationMessage?: string,\n): IJSONSchema {\n\treturn {\n\t\tdescription,\n\t\tdeprecationMessage,\n\t\tdefaultSnippets: [{ body: \"${1:#ff0000}\" }],\n\t\tanyOf: [\n\t\t\t{\n\t\t\t\ttype: \"string\",\n\t\t\t\tformat: \"color-hex\",\n\t\t\t},\n\t\t\t{\n\t\t\t\t$ref: \"#/definitions/style\",\n\t\t\t},\n\t\t],\n\t};\n}\n\nexport const tokenStylingSchemaId = \"vscode://schemas/token-styling\";\n\nconst schemaRegistry = platform.Registry.as<IJSONContributionRegistry>(\n\tJSONExtensions.JSONContribution,\n);\nschemaRegistry.registerSchema(\n\ttokenStylingSchemaId,\n\ttokenClassificationRegistry.getTokenStylingSchema(),\n);\n\nconst delayer = new RunOnceScheduler(\n\t() => schemaRegistry.notifySchemaChanged(tokenStylingSchemaId),\n\t200,\n);\ntokenClassificationRegistry.onDidChangeSchema(() => {\n\tif (!delayer.isScheduled()) {\n\t\tdelayer.schedule();\n\t}\n});\n"],
  "mappings": "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",
  "names": ["TokenStyle", "SemanticTokenRule", "language"]
}
