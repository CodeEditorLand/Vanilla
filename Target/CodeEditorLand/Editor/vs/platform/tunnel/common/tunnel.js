var I=Object.defineProperty;var x=Object.getOwnPropertyDescriptor;var b=(i,s,e,r)=>{for(var n=r>1?void 0:r?x(s,e):s,o=i.length-1,t;o>=0;o--)(t=i[o])&&(n=(r?t(s,e,n):t(n))||n);return r&&n&&I(s,e,n),n},m=(i,s)=>(e,r)=>s(e,r,i);import{Emitter as f}from"../../../base/common/event.js";import{Disposable as E}from"../../../base/common/lifecycle.js";import{OperatingSystem as y}from"../../../base/common/platform.js";import{URI as w}from"../../../base/common/uri.js";import{IConfigurationService as O}from"../../configuration/common/configuration.js";import{createDecorator as _}from"../../instantiation/common/instantiation.js";import{ILogService as C}from"../../log/common/log.js";const K=_("tunnelService"),X=_("sharedTunnelsService");var A=(e=>(e.Http="http",e.Https="https",e))(A||{}),D=(r=>(r.ConstantPrivate="constantPrivate",r.Private="private",r.Public="public",r))(D||{});function Y(i){return!!i.forwardPort}var M=(t=>(t[t.Notify=1]="Notify",t[t.OpenBrowser=2]="OpenBrowser",t[t.OpenPreview=3]="OpenPreview",t[t.Silent=4]="Silent",t[t.Ignore=5]="Ignore",t[t.OpenBrowserOnce=6]="OpenBrowserOnce",t))(M||{});function S(i){if(i.scheme!=="http"&&i.scheme!=="https")return;const s=/^(localhost|127\.0\.0\.1|0\.0\.0\.0):(\d+)$/.exec(i.authority);if(s)return{address:s[1],port:+s[2]}}function Z(i){if(i.scheme!=="http"&&i.scheme!=="https"||!i.query)return;const s=i.query.split("&");for(const e of s){const r=e.split("=")[1];if(/^https?:/.exec(r)){const n=S(w.parse(r));if(n)return n}}}const h=["localhost","127.0.0.1","0:0:0:0:0:0:0:1","::1"];function R(i){return h.indexOf(i)>=0}const T=["0.0.0.0","0:0:0:0:0:0:0:0","::"];function P(i){return T.indexOf(i)>=0}function ee(i,s,e,r){if(e===y.Windows)return!1;if(e===y.Macintosh&&P(s)){const n=/(\d+)\.(\d+)\.(\d+)/g.exec(r);if(n?.length===4&&parseInt(n[1])>=18)return!1}return i<1024}class ne{constructor(s,e,r){this.remoteAddress=s;this.localAddress=e;this._dispose=r}_onDispose=new f;onDidDispose=this._onDispose.event;dispose(){return this._onDispose.fire(),this._dispose()}}let g=class extends E{constructor(e,r){super();this.logService=e;this.configurationService=r}_onTunnelOpened=new f;onTunnelOpened=this._onTunnelOpened.event;_onTunnelClosed=new f;onTunnelClosed=this._onTunnelClosed.event;_onAddedTunnelProvider=new f;onAddedTunnelProvider=this._onAddedTunnelProvider.event;_tunnels=new Map;_tunnelProvider;_canElevate=!1;_canChangeProtocol=!0;_privacyOptions=[];_factoryInProgress=new Set;get hasTunnelProvider(){return!!this._tunnelProvider}get defaultTunnelHost(){const e=this.configurationService.getValue("remote.localPortHost");return!e||e==="localhost"?"127.0.0.1":"0.0.0.0"}setTunnelProvider(e){return this._tunnelProvider=e,e?(this._onAddedTunnelProvider.fire(),{dispose:()=>{this._tunnelProvider=void 0,this._canElevate=!1,this._privacyOptions=[]}}):(this._canElevate=!1,this._privacyOptions=[],this._onAddedTunnelProvider.fire(),{dispose:()=>{}})}setTunnelFeatures(e){this._canElevate=e.elevation,this._privacyOptions=e.privacyOptions,this._canChangeProtocol=e.protocol}get canChangeProtocol(){return this._canChangeProtocol}get canElevate(){return this._canElevate}get canChangePrivacy(){return this._privacyOptions.length>0}get privacyOptions(){return this._privacyOptions}get tunnels(){return this.getTunnels()}async getTunnels(){const e=[],r=Array.from(this._tunnels.values());for(const n of r){const o=Array.from(n.values());for(const t of o){const l=await t.value;l&&typeof l!="string"&&e.push(l)}}return e}async dispose(){super.dispose();for(const e of this._tunnels.values()){for(const{value:r}of e.values())await r.then(n=>typeof n!="string"?n?.dispose():void 0);e.clear()}this._tunnels.clear()}setEnvironmentTunnel(e,r,n,o,t){this.addTunnelToMap(e,r,Promise.resolve({tunnelRemoteHost:e,tunnelRemotePort:r,localAddress:n,privacy:o,protocol:t,dispose:()=>Promise.resolve()}))}async getExistingTunnel(e,r){(P(e)||R(e))&&(e=h[0]);const n=this.getTunnelFromMap(e,r);if(n)return++n.refcount,n.value}openTunnel(e,r,n,o,t,l=!1,d,c){this.logService.trace(`ForwardedPorts: (TunnelService) openTunnel request for ${r}:${n} on local port ${t}.`);const v=this._tunnelProvider??e;if(!v)return;if(r||(r="localhost"),o||(o=this.defaultTunnelHost),this._tunnelProvider&&this._factoryInProgress.has(n)){this.logService.debug("ForwardedPorts: (TunnelService) Another call to create a tunnel with the same address has occurred before the last one completed. This call will be ignored.");return}const p=this.retainOrCreateTunnel(v,r,n,o,t,l,d,c);return p?p.then(u=>{if(u){if(typeof u=="string")return this.logService.trace("ForwardedPorts: (TunnelService) The tunnel provider returned an error when creating the tunnel."),this.removeEmptyOrErrorTunnelFromMap(r,n),u}else{this.logService.trace("ForwardedPorts: (TunnelService) New tunnel is undefined."),this.removeEmptyOrErrorTunnelFromMap(r,n);return}this.logService.trace("ForwardedPorts: (TunnelService) New tunnel established.");const a=this.makeTunnel(u);return(u.tunnelRemoteHost!==r||u.tunnelRemotePort!==n)&&this.logService.warn("ForwardedPorts: (TunnelService) Created tunnel does not match requirements of requested tunnel. Host or port mismatch."),d&&u.privacy!==d&&this.logService.warn("ForwardedPorts: (TunnelService) Created tunnel does not match requirements of requested tunnel. Privacy mismatch."),this._onTunnelOpened.fire(a),a}):(this.logService.trace("ForwardedPorts: (TunnelService) Tunnel was not created."),p)}makeTunnel(e){return{tunnelRemotePort:e.tunnelRemotePort,tunnelRemoteHost:e.tunnelRemoteHost,tunnelLocalPort:e.tunnelLocalPort,localAddress:e.localAddress,privacy:e.privacy,protocol:e.protocol,dispose:async()=>{this.logService.trace(`ForwardedPorts: (TunnelService) dispose request for ${e.tunnelRemoteHost}:${e.tunnelRemotePort} `);const r=this._tunnels.get(e.tunnelRemoteHost);if(r){const n=r.get(e.tunnelRemotePort);n&&(n.refcount--,await this.tryDisposeTunnel(e.tunnelRemoteHost,e.tunnelRemotePort,n))}}}}async tryDisposeTunnel(e,r,n){if(n.refcount<=0){this.logService.trace(`ForwardedPorts: (TunnelService) Tunnel is being disposed ${e}:${r}.`);const o=n.value.then(async t=>{t&&typeof t!="string"&&(await t.dispose(!0),this._onTunnelClosed.fire({host:t.tunnelRemoteHost,port:t.tunnelRemotePort}))});return this._tunnels.has(e)&&this._tunnels.get(e).delete(r),o}}async closeTunnel(e,r){this.logService.trace(`ForwardedPorts: (TunnelService) close request for ${e}:${r} `);const n=this._tunnels.get(e);if(n&&n.has(r)){const o=n.get(r);o.refcount=0,await this.tryDisposeTunnel(e,r,o)}}addTunnelToMap(e,r,n){this._tunnels.has(e)||this._tunnels.set(e,new Map),this._tunnels.get(e).set(r,{refcount:1,value:n})}async removeEmptyOrErrorTunnelFromMap(e,r){const n=this._tunnels.get(e);if(n){const o=n.get(r),t=o?await o.value:void 0;(!t||typeof t=="string")&&n.delete(r),n.size===0&&this._tunnels.delete(e)}}getTunnelFromMap(e,r){const n=[e];R(e)?(n.push(...h),n.push(...T)):P(e)&&n.push(...T);const o=n.map(t=>this._tunnels.get(t));for(const t of o){const l=t?.get(r);if(l)return l}}canTunnel(e){return!!S(e)}createWithProvider(e,r,n,o,t,l,d){this.logService.trace(`ForwardedPorts: (TunnelService) Creating tunnel with provider ${r}:${n} on local port ${o}.`);const c=n;this._factoryInProgress.add(c);const v=o===void 0?n:o,p={elevationRequired:t?this.isPortPrivileged(v):!1},u={remoteAddress:{host:r,port:n},localAddressPort:o,privacy:l,public:l?l!=="private":void 0,protocol:d},a=e.forwardPort(u,p);return a?(this.addTunnelToMap(r,n,a),a.finally(()=>{this.logService.trace("ForwardedPorts: (TunnelService) Tunnel created by provider."),this._factoryInProgress.delete(c)})):this._factoryInProgress.delete(c),a}};g=b([m(0,C),m(1,O)],g);export{T as ALL_INTERFACES_ADDRESSES,g as AbstractTunnelService,ne as DisposableTunnel,X as ISharedTunnelsService,K as ITunnelService,h as LOCALHOST_ADDRESSES,M as ProvidedOnAutoForward,D as TunnelPrivacyId,A as TunnelProtocol,S as extractLocalHostUriMetaDataForPortMapping,Z as extractQueryLocalHostUriMetaDataForPortMapping,P as isAllInterfaces,R as isLocalhost,ee as isPortPrivileged,Y as isTunnelProvider};
