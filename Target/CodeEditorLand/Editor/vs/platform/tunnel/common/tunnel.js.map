{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/tunnel/common/tunnel.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { CancellationToken } from \"../../../base/common/cancellation.js\";\nimport { Emitter, type Event } from \"../../../base/common/event.js\";\nimport {\n\tDisposable,\n\ttype IDisposable,\n} from \"../../../base/common/lifecycle.js\";\nimport { OperatingSystem } from \"../../../base/common/platform.js\";\nimport { URI } from \"../../../base/common/uri.js\";\nimport { IConfigurationService } from \"../../configuration/common/configuration.js\";\nimport { createDecorator } from \"../../instantiation/common/instantiation.js\";\nimport { ILogService } from \"../../log/common/log.js\";\nimport type { IAddressProvider } from \"../../remote/common/remoteAgentConnection.js\";\nimport type { TunnelPrivacy } from \"../../remote/common/remoteAuthorityResolver.js\";\n\nexport const ITunnelService = createDecorator<ITunnelService>(\"tunnelService\");\nexport const ISharedTunnelsService = createDecorator<ISharedTunnelsService>(\n\t\"sharedTunnelsService\",\n);\n\nexport interface RemoteTunnel {\n\treadonly tunnelRemotePort: number;\n\treadonly tunnelRemoteHost: string;\n\treadonly tunnelLocalPort?: number;\n\treadonly localAddress: string;\n\treadonly privacy: string;\n\treadonly protocol?: string;\n\tdispose(silent?: boolean): Promise<void>;\n}\n\nexport interface TunnelOptions {\n\tremoteAddress: { port: number; host: string };\n\tlocalAddressPort?: number;\n\tlabel?: string;\n\tpublic?: boolean;\n\tprivacy?: string;\n\tprotocol?: string;\n}\n\nexport enum TunnelProtocol {\n\tHttp = \"http\",\n\tHttps = \"https\",\n}\n\nexport enum TunnelPrivacyId {\n\tConstantPrivate = \"constantPrivate\", // private, and changing is unsupported\n\tPrivate = \"private\",\n\tPublic = \"public\",\n}\n\nexport interface TunnelCreationOptions {\n\televationRequired?: boolean;\n}\n\nexport interface TunnelProviderFeatures {\n\televation: boolean;\n\t/**\n\t * @deprecated\n\t */\n\tpublic?: boolean;\n\tprivacyOptions: TunnelPrivacy[];\n\tprotocol: boolean;\n}\n\nexport interface ITunnelProvider {\n\tforwardPort(\n\t\ttunnelOptions: TunnelOptions,\n\t\ttunnelCreationOptions: TunnelCreationOptions,\n\t): Promise<RemoteTunnel | string | undefined> | undefined;\n}\n\nexport function isTunnelProvider(\n\taddressOrTunnelProvider: IAddressProvider | ITunnelProvider,\n): addressOrTunnelProvider is ITunnelProvider {\n\treturn !!(addressOrTunnelProvider as ITunnelProvider).forwardPort;\n}\n\nexport enum ProvidedOnAutoForward {\n\tNotify = 1,\n\tOpenBrowser = 2,\n\tOpenPreview = 3,\n\tSilent = 4,\n\tIgnore = 5,\n\tOpenBrowserOnce = 6,\n}\n\nexport interface ProvidedPortAttributes {\n\tport: number;\n\tautoForwardAction: ProvidedOnAutoForward;\n}\n\nexport interface PortAttributesProvider {\n\tprovidePortAttributes(\n\t\tports: number[],\n\t\tpid: number | undefined,\n\t\tcommandLine: string | undefined,\n\t\ttoken: CancellationToken,\n\t): Promise<ProvidedPortAttributes[]>;\n}\n\nexport interface ITunnel {\n\tremoteAddress: { port: number; host: string };\n\n\t/**\n\t * The complete local address(ex. localhost:1234)\n\t */\n\tlocalAddress: string;\n\n\t/**\n\t * @deprecated Use privacy instead\n\t */\n\tpublic?: boolean;\n\n\tprivacy?: string;\n\n\tprotocol?: string;\n\n\t/**\n\t * Implementers of Tunnel should fire onDidDispose when dispose is called.\n\t */\n\tonDidDispose: Event<void>;\n\n\tdispose(): Promise<void> | void;\n}\n\nexport interface ISharedTunnelsService {\n\treadonly _serviceBrand: undefined;\n\n\topenTunnel(\n\t\tauthority: string,\n\t\taddressProvider: IAddressProvider | undefined,\n\t\tremoteHost: string | undefined,\n\t\tremotePort: number,\n\t\tlocalHost: string,\n\t\tlocalPort?: number,\n\t\televateIfNeeded?: boolean,\n\t\tprivacy?: string,\n\t\tprotocol?: string,\n\t): Promise<RemoteTunnel | string | undefined> | undefined;\n}\n\nexport interface ITunnelService {\n\treadonly _serviceBrand: undefined;\n\n\treadonly tunnels: Promise<readonly RemoteTunnel[]>;\n\treadonly canChangePrivacy: boolean;\n\treadonly privacyOptions: TunnelPrivacy[];\n\treadonly onTunnelOpened: Event<RemoteTunnel>;\n\treadonly onTunnelClosed: Event<{ host: string; port: number }>;\n\treadonly canElevate: boolean;\n\treadonly canChangeProtocol: boolean;\n\treadonly hasTunnelProvider: boolean;\n\treadonly onAddedTunnelProvider: Event<void>;\n\n\tcanTunnel(uri: URI): boolean;\n\topenTunnel(\n\t\taddressProvider: IAddressProvider | undefined,\n\t\tremoteHost: string | undefined,\n\t\tremotePort: number,\n\t\tlocalHost?: string,\n\t\tlocalPort?: number,\n\t\televateIfNeeded?: boolean,\n\t\tprivacy?: string,\n\t\tprotocol?: string,\n\t): Promise<RemoteTunnel | string | undefined> | undefined;\n\tgetExistingTunnel(\n\t\tremoteHost: string,\n\t\tremotePort: number,\n\t): Promise<RemoteTunnel | string | undefined>;\n\tsetEnvironmentTunnel(\n\t\tremoteHost: string,\n\t\tremotePort: number,\n\t\tlocalAddress: string,\n\t\tprivacy: string,\n\t\tprotocol: string,\n\t): void;\n\tcloseTunnel(remoteHost: string, remotePort: number): Promise<void>;\n\tsetTunnelProvider(provider: ITunnelProvider | undefined): IDisposable;\n\tsetTunnelFeatures(features: TunnelProviderFeatures): void;\n\tisPortPrivileged(port: number): boolean;\n}\n\nexport function extractLocalHostUriMetaDataForPortMapping(\n\turi: URI,\n): { address: string; port: number } | undefined {\n\tif (uri.scheme !== \"http\" && uri.scheme !== \"https\") {\n\t\treturn undefined;\n\t}\n\tconst localhostMatch = /^(localhost|127\\.0\\.0\\.1|0\\.0\\.0\\.0):(\\d+)$/.exec(\n\t\turi.authority,\n\t);\n\tif (!localhostMatch) {\n\t\treturn undefined;\n\t}\n\treturn {\n\t\taddress: localhostMatch[1],\n\t\tport: +localhostMatch[2],\n\t};\n}\n\nexport function extractQueryLocalHostUriMetaDataForPortMapping(\n\turi: URI,\n): { address: string; port: number } | undefined {\n\tif ((uri.scheme !== \"http\" && uri.scheme !== \"https\") || !uri.query) {\n\t\treturn undefined;\n\t}\n\tconst keyvalues = uri.query.split(\"&\");\n\tfor (const keyvalue of keyvalues) {\n\t\tconst value = keyvalue.split(\"=\")[1];\n\t\tif (/^https?:/.exec(value)) {\n\t\t\tconst result = extractLocalHostUriMetaDataForPortMapping(\n\t\t\t\tURI.parse(value),\n\t\t\t);\n\t\t\tif (result) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t}\n\treturn undefined;\n}\n\nexport const LOCALHOST_ADDRESSES = [\n\t\"localhost\",\n\t\"127.0.0.1\",\n\t\"0:0:0:0:0:0:0:1\",\n\t\"::1\",\n];\nexport function isLocalhost(host: string): boolean {\n\treturn LOCALHOST_ADDRESSES.indexOf(host) >= 0;\n}\n\nexport const ALL_INTERFACES_ADDRESSES = [\"0.0.0.0\", \"0:0:0:0:0:0:0:0\", \"::\"];\nexport function isAllInterfaces(host: string): boolean {\n\treturn ALL_INTERFACES_ADDRESSES.indexOf(host) >= 0;\n}\n\nexport function isPortPrivileged(\n\tport: number,\n\thost: string,\n\tos: OperatingSystem,\n\tosRelease: string,\n): boolean {\n\tif (os === OperatingSystem.Windows) {\n\t\treturn false;\n\t}\n\tif (os === OperatingSystem.Macintosh) {\n\t\tif (isAllInterfaces(host)) {\n\t\t\tconst osVersion = /(\\d+)\\.(\\d+)\\.(\\d+)/g.exec(osRelease);\n\t\t\tif (osVersion?.length === 4) {\n\t\t\t\tconst major = Number.parseInt(osVersion[1]);\n\t\t\t\tif (\n\t\t\t\t\tmajor >= 18 /* since macOS Mojave, darwin version 18.0.0 */\n\t\t\t\t) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn port < 1024;\n}\n\nexport class DisposableTunnel {\n\tprivate _onDispose: Emitter<void> = new Emitter();\n\tonDidDispose: Event<void> = this._onDispose.event;\n\n\tconstructor(\n\t\tpublic readonly remoteAddress: { port: number; host: string },\n\t\tpublic readonly localAddress: { port: number; host: string } | string,\n\t\tprivate readonly _dispose: () => Promise<void>,\n\t) {}\n\n\tdispose(): Promise<void> {\n\t\tthis._onDispose.fire();\n\t\treturn this._dispose();\n\t}\n}\n\nexport abstract class AbstractTunnelService\n\textends Disposable\n\timplements ITunnelService\n{\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate _onTunnelOpened: Emitter<RemoteTunnel> = new Emitter();\n\tpublic onTunnelOpened: Event<RemoteTunnel> = this._onTunnelOpened.event;\n\tprivate _onTunnelClosed: Emitter<{ host: string; port: number }> =\n\t\tnew Emitter();\n\tpublic onTunnelClosed: Event<{ host: string; port: number }> =\n\t\tthis._onTunnelClosed.event;\n\tprivate _onAddedTunnelProvider: Emitter<void> = new Emitter();\n\tpublic onAddedTunnelProvider: Event<void> =\n\t\tthis._onAddedTunnelProvider.event;\n\tprotected readonly _tunnels = new Map<\n\t\t/*host*/ string,\n\t\tMap<\n\t\t\t/* port */ number,\n\t\t\t{\n\t\t\t\trefcount: number;\n\t\t\t\treadonly value: Promise<RemoteTunnel | string | undefined>;\n\t\t\t}\n\t\t>\n\t>();\n\tprotected _tunnelProvider: ITunnelProvider | undefined;\n\tprotected _canElevate = false;\n\tprivate _canChangeProtocol = true;\n\tprivate _privacyOptions: TunnelPrivacy[] = [];\n\tprivate _factoryInProgress: Set<number /*port*/> = new Set();\n\n\tpublic constructor(\n\t\t@ILogService protected readonly logService: ILogService,\n\t\t@IConfigurationService protected readonly configurationService: IConfigurationService\n\t) { super(); }\n\n\tget hasTunnelProvider(): boolean {\n\t\treturn !!this._tunnelProvider;\n\t}\n\n\tprotected get defaultTunnelHost(): string {\n\t\tconst settingValue = this.configurationService.getValue(\n\t\t\t\"remote.localPortHost\",\n\t\t);\n\t\treturn !settingValue || settingValue === \"localhost\"\n\t\t\t? \"127.0.0.1\"\n\t\t\t: \"0.0.0.0\";\n\t}\n\n\tsetTunnelProvider(provider: ITunnelProvider | undefined): IDisposable {\n\t\tthis._tunnelProvider = provider;\n\t\tif (!provider) {\n\t\t\t// clear features\n\t\t\tthis._canElevate = false;\n\t\t\tthis._privacyOptions = [];\n\t\t\tthis._onAddedTunnelProvider.fire();\n\t\t\treturn {\n\t\t\t\tdispose: () => {},\n\t\t\t};\n\t\t}\n\n\t\tthis._onAddedTunnelProvider.fire();\n\t\treturn {\n\t\t\tdispose: () => {\n\t\t\t\tthis._tunnelProvider = undefined;\n\t\t\t\tthis._canElevate = false;\n\t\t\t\tthis._privacyOptions = [];\n\t\t\t},\n\t\t};\n\t}\n\n\tsetTunnelFeatures(features: TunnelProviderFeatures): void {\n\t\tthis._canElevate = features.elevation;\n\t\tthis._privacyOptions = features.privacyOptions;\n\t\tthis._canChangeProtocol = features.protocol;\n\t}\n\n\tpublic get canChangeProtocol(): boolean {\n\t\treturn this._canChangeProtocol;\n\t}\n\n\tpublic get canElevate(): boolean {\n\t\treturn this._canElevate;\n\t}\n\n\tpublic get canChangePrivacy() {\n\t\treturn this._privacyOptions.length > 0;\n\t}\n\n\tpublic get privacyOptions() {\n\t\treturn this._privacyOptions;\n\t}\n\n\tpublic get tunnels(): Promise<readonly RemoteTunnel[]> {\n\t\treturn this.getTunnels();\n\t}\n\n\tprivate async getTunnels(): Promise<readonly RemoteTunnel[]> {\n\t\tconst tunnels: RemoteTunnel[] = [];\n\t\tconst tunnelArray = Array.from(this._tunnels.values());\n\t\tfor (const portMap of tunnelArray) {\n\t\t\tconst portArray = Array.from(portMap.values());\n\t\t\tfor (const x of portArray) {\n\t\t\t\tconst tunnelValue = await x.value;\n\t\t\t\tif (tunnelValue && typeof tunnelValue !== \"string\") {\n\t\t\t\t\ttunnels.push(tunnelValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn tunnels;\n\t}\n\n\toverride async dispose(): Promise<void> {\n\t\tsuper.dispose();\n\t\tfor (const portMap of this._tunnels.values()) {\n\t\t\tfor (const { value } of portMap.values()) {\n\t\t\t\tawait value.then((tunnel) =>\n\t\t\t\t\ttypeof tunnel !== \"string\" ? tunnel?.dispose() : undefined,\n\t\t\t\t);\n\t\t\t}\n\t\t\tportMap.clear();\n\t\t}\n\t\tthis._tunnels.clear();\n\t}\n\n\tsetEnvironmentTunnel(\n\t\tremoteHost: string,\n\t\tremotePort: number,\n\t\tlocalAddress: string,\n\t\tprivacy: string,\n\t\tprotocol: string,\n\t): void {\n\t\tthis.addTunnelToMap(\n\t\t\tremoteHost,\n\t\t\tremotePort,\n\t\t\tPromise.resolve({\n\t\t\t\ttunnelRemoteHost: remoteHost,\n\t\t\t\ttunnelRemotePort: remotePort,\n\t\t\t\tlocalAddress,\n\t\t\t\tprivacy,\n\t\t\t\tprotocol,\n\t\t\t\tdispose: () => Promise.resolve(),\n\t\t\t}),\n\t\t);\n\t}\n\n\tasync getExistingTunnel(\n\t\tremoteHost: string,\n\t\tremotePort: number,\n\t): Promise<RemoteTunnel | string | undefined> {\n\t\tif (isAllInterfaces(remoteHost) || isLocalhost(remoteHost)) {\n\t\t\tremoteHost = LOCALHOST_ADDRESSES[0];\n\t\t}\n\n\t\tconst existing = this.getTunnelFromMap(remoteHost, remotePort);\n\t\tif (existing) {\n\t\t\t++existing.refcount;\n\t\t\treturn existing.value;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\topenTunnel(\n\t\taddressProvider: IAddressProvider | undefined,\n\t\tremoteHost: string | undefined,\n\t\tremotePort: number,\n\t\tlocalHost?: string,\n\t\tlocalPort?: number,\n\t\televateIfNeeded = false,\n\t\tprivacy?: string,\n\t\tprotocol?: string,\n\t): Promise<RemoteTunnel | string | undefined> | undefined {\n\t\tthis.logService.trace(\n\t\t\t`ForwardedPorts: (TunnelService) openTunnel request for ${remoteHost}:${remotePort} on local port ${localPort}.`,\n\t\t);\n\t\tconst addressOrTunnelProvider = this._tunnelProvider ?? addressProvider;\n\t\tif (!addressOrTunnelProvider) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!remoteHost) {\n\t\t\tremoteHost = \"localhost\";\n\t\t}\n\t\tif (!localHost) {\n\t\t\tlocalHost = this.defaultTunnelHost;\n\t\t}\n\n\t\t// Prevent tunnel factories from calling openTunnel from within the factory\n\t\tif (this._tunnelProvider && this._factoryInProgress.has(remotePort)) {\n\t\t\tthis.logService.debug(\n\t\t\t\t`ForwardedPorts: (TunnelService) Another call to create a tunnel with the same address has occurred before the last one completed. This call will be ignored.`,\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tconst resolvedTunnel = this.retainOrCreateTunnel(\n\t\t\taddressOrTunnelProvider,\n\t\t\tremoteHost,\n\t\t\tremotePort,\n\t\t\tlocalHost,\n\t\t\tlocalPort,\n\t\t\televateIfNeeded,\n\t\t\tprivacy,\n\t\t\tprotocol,\n\t\t);\n\t\tif (!resolvedTunnel) {\n\t\t\tthis.logService.trace(\n\t\t\t\t`ForwardedPorts: (TunnelService) Tunnel was not created.`,\n\t\t\t);\n\t\t\treturn resolvedTunnel;\n\t\t}\n\n\t\treturn resolvedTunnel.then((tunnel) => {\n\t\t\tif (!tunnel) {\n\t\t\t\tthis.logService.trace(\n\t\t\t\t\t\"ForwardedPorts: (TunnelService) New tunnel is undefined.\",\n\t\t\t\t);\n\t\t\t\tthis.removeEmptyOrErrorTunnelFromMap(remoteHost, remotePort);\n\t\t\t\treturn undefined;\n\t\t\t} else if (typeof tunnel === \"string\") {\n\t\t\t\tthis.logService.trace(\n\t\t\t\t\t\"ForwardedPorts: (TunnelService) The tunnel provider returned an error when creating the tunnel.\",\n\t\t\t\t);\n\t\t\t\tthis.removeEmptyOrErrorTunnelFromMap(remoteHost, remotePort);\n\t\t\t\treturn tunnel;\n\t\t\t}\n\t\t\tthis.logService.trace(\n\t\t\t\t\"ForwardedPorts: (TunnelService) New tunnel established.\",\n\t\t\t);\n\t\t\tconst newTunnel = this.makeTunnel(tunnel);\n\t\t\tif (\n\t\t\t\ttunnel.tunnelRemoteHost !== remoteHost ||\n\t\t\t\ttunnel.tunnelRemotePort !== remotePort\n\t\t\t) {\n\t\t\t\tthis.logService.warn(\n\t\t\t\t\t\"ForwardedPorts: (TunnelService) Created tunnel does not match requirements of requested tunnel. Host or port mismatch.\",\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (privacy && tunnel.privacy !== privacy) {\n\t\t\t\tthis.logService.warn(\n\t\t\t\t\t\"ForwardedPorts: (TunnelService) Created tunnel does not match requirements of requested tunnel. Privacy mismatch.\",\n\t\t\t\t);\n\t\t\t}\n\t\t\tthis._onTunnelOpened.fire(newTunnel);\n\t\t\treturn newTunnel;\n\t\t});\n\t}\n\n\tprivate makeTunnel(tunnel: RemoteTunnel): RemoteTunnel {\n\t\treturn {\n\t\t\ttunnelRemotePort: tunnel.tunnelRemotePort,\n\t\t\ttunnelRemoteHost: tunnel.tunnelRemoteHost,\n\t\t\ttunnelLocalPort: tunnel.tunnelLocalPort,\n\t\t\tlocalAddress: tunnel.localAddress,\n\t\t\tprivacy: tunnel.privacy,\n\t\t\tprotocol: tunnel.protocol,\n\t\t\tdispose: async () => {\n\t\t\t\tthis.logService.trace(\n\t\t\t\t\t`ForwardedPorts: (TunnelService) dispose request for ${tunnel.tunnelRemoteHost}:${tunnel.tunnelRemotePort} `,\n\t\t\t\t);\n\t\t\t\tconst existingHost = this._tunnels.get(tunnel.tunnelRemoteHost);\n\t\t\t\tif (existingHost) {\n\t\t\t\t\tconst existing = existingHost.get(tunnel.tunnelRemotePort);\n\t\t\t\t\tif (existing) {\n\t\t\t\t\t\texisting.refcount--;\n\t\t\t\t\t\tawait this.tryDisposeTunnel(\n\t\t\t\t\t\t\ttunnel.tunnelRemoteHost,\n\t\t\t\t\t\t\ttunnel.tunnelRemotePort,\n\t\t\t\t\t\t\texisting,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t}\n\n\tprivate async tryDisposeTunnel(\n\t\tremoteHost: string,\n\t\tremotePort: number,\n\t\ttunnel: {\n\t\t\trefcount: number;\n\t\t\treadonly value: Promise<RemoteTunnel | string | undefined>;\n\t\t},\n\t): Promise<void> {\n\t\tif (tunnel.refcount <= 0) {\n\t\t\tthis.logService.trace(\n\t\t\t\t`ForwardedPorts: (TunnelService) Tunnel is being disposed ${remoteHost}:${remotePort}.`,\n\t\t\t);\n\t\t\tconst disposePromise: Promise<void> = tunnel.value.then(\n\t\t\t\tasync (tunnel) => {\n\t\t\t\t\tif (tunnel && typeof tunnel !== \"string\") {\n\t\t\t\t\t\tawait tunnel.dispose(true);\n\t\t\t\t\t\tthis._onTunnelClosed.fire({\n\t\t\t\t\t\t\thost: tunnel.tunnelRemoteHost,\n\t\t\t\t\t\t\tport: tunnel.tunnelRemotePort,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t);\n\t\t\tif (this._tunnels.has(remoteHost)) {\n\t\t\t\tthis._tunnels.get(remoteHost)!.delete(remotePort);\n\t\t\t}\n\t\t\treturn disposePromise;\n\t\t}\n\t}\n\n\tasync closeTunnel(remoteHost: string, remotePort: number): Promise<void> {\n\t\tthis.logService.trace(\n\t\t\t`ForwardedPorts: (TunnelService) close request for ${remoteHost}:${remotePort} `,\n\t\t);\n\t\tconst portMap = this._tunnels.get(remoteHost);\n\t\tif (portMap && portMap.has(remotePort)) {\n\t\t\tconst value = portMap.get(remotePort)!;\n\t\t\tvalue.refcount = 0;\n\t\t\tawait this.tryDisposeTunnel(remoteHost, remotePort, value);\n\t\t}\n\t}\n\n\tprotected addTunnelToMap(\n\t\tremoteHost: string,\n\t\tremotePort: number,\n\t\ttunnel: Promise<RemoteTunnel | string | undefined>,\n\t) {\n\t\tif (!this._tunnels.has(remoteHost)) {\n\t\t\tthis._tunnels.set(remoteHost, new Map());\n\t\t}\n\t\tthis._tunnels\n\t\t\t.get(remoteHost)!\n\t\t\t.set(remotePort, { refcount: 1, value: tunnel });\n\t}\n\n\tprivate async removeEmptyOrErrorTunnelFromMap(\n\t\tremoteHost: string,\n\t\tremotePort: number,\n\t) {\n\t\tconst hostMap = this._tunnels.get(remoteHost);\n\t\tif (hostMap) {\n\t\t\tconst tunnel = hostMap.get(remotePort);\n\t\t\tconst tunnelResult = tunnel ? await tunnel.value : undefined;\n\t\t\tif (!tunnelResult || typeof tunnelResult === \"string\") {\n\t\t\t\thostMap.delete(remotePort);\n\t\t\t}\n\t\t\tif (hostMap.size === 0) {\n\t\t\t\tthis._tunnels.delete(remoteHost);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected getTunnelFromMap(\n\t\tremoteHost: string,\n\t\tremotePort: number,\n\t):\n\t\t| {\n\t\t\t\trefcount: number;\n\t\t\t\treadonly value: Promise<RemoteTunnel | string | undefined>;\n\t\t  }\n\t\t| undefined {\n\t\tconst hosts = [remoteHost];\n\t\t// Order matters. We want the original host to be first.\n\t\tif (isLocalhost(remoteHost)) {\n\t\t\thosts.push(...LOCALHOST_ADDRESSES);\n\t\t\t// For localhost, we add the all interfaces hosts because if the tunnel is already available at all interfaces,\n\t\t\t// then of course it is available at localhost.\n\t\t\thosts.push(...ALL_INTERFACES_ADDRESSES);\n\t\t} else if (isAllInterfaces(remoteHost)) {\n\t\t\thosts.push(...ALL_INTERFACES_ADDRESSES);\n\t\t}\n\n\t\tconst existingPortMaps = hosts.map((host) => this._tunnels.get(host));\n\t\tfor (const map of existingPortMaps) {\n\t\t\tconst existingTunnel = map?.get(remotePort);\n\t\t\tif (existingTunnel) {\n\t\t\t\treturn existingTunnel;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tcanTunnel(uri: URI): boolean {\n\t\treturn !!extractLocalHostUriMetaDataForPortMapping(uri);\n\t}\n\n\tpublic abstract isPortPrivileged(port: number): boolean;\n\n\tprotected abstract retainOrCreateTunnel(\n\t\taddressProvider: IAddressProvider | ITunnelProvider,\n\t\tremoteHost: string,\n\t\tremotePort: number,\n\t\tlocalHost: string,\n\t\tlocalPort: number | undefined,\n\t\televateIfNeeded: boolean,\n\t\tprivacy?: string,\n\t\tprotocol?: string,\n\t): Promise<RemoteTunnel | string | undefined> | undefined;\n\n\tprotected createWithProvider(\n\t\ttunnelProvider: ITunnelProvider,\n\t\tremoteHost: string,\n\t\tremotePort: number,\n\t\tlocalPort: number | undefined,\n\t\televateIfNeeded: boolean,\n\t\tprivacy?: string,\n\t\tprotocol?: string,\n\t): Promise<RemoteTunnel | string | undefined> | undefined {\n\t\tthis.logService.trace(\n\t\t\t`ForwardedPorts: (TunnelService) Creating tunnel with provider ${remoteHost}:${remotePort} on local port ${localPort}.`,\n\t\t);\n\t\tconst key = remotePort;\n\t\tthis._factoryInProgress.add(key);\n\t\tconst preferredLocalPort =\n\t\t\tlocalPort === undefined ? remotePort : localPort;\n\t\tconst creationInfo = {\n\t\t\televationRequired: elevateIfNeeded\n\t\t\t\t? this.isPortPrivileged(preferredLocalPort)\n\t\t\t\t: false,\n\t\t};\n\t\tconst tunnelOptions: TunnelOptions = {\n\t\t\tremoteAddress: { host: remoteHost, port: remotePort },\n\t\t\tlocalAddressPort: localPort,\n\t\t\tprivacy,\n\t\t\tpublic: privacy ? privacy !== TunnelPrivacyId.Private : undefined,\n\t\t\tprotocol,\n\t\t};\n\t\tconst tunnel = tunnelProvider.forwardPort(tunnelOptions, creationInfo);\n\t\tif (tunnel) {\n\t\t\tthis.addTunnelToMap(remoteHost, remotePort, tunnel);\n\t\t\ttunnel.finally(() => {\n\t\t\t\tthis.logService.trace(\n\t\t\t\t\t\"ForwardedPorts: (TunnelService) Tunnel created by provider.\",\n\t\t\t\t);\n\t\t\t\tthis._factoryInProgress.delete(key);\n\t\t\t});\n\t\t} else {\n\t\t\tthis._factoryInProgress.delete(key);\n\t\t}\n\t\treturn tunnel;\n\t}\n}\n"],
  "mappings": ";;;;;;;;;;;;AAMA,SAAS,eAA2B;AACpC;AAAA,EACC;AAAA,OAEM;AACP,SAAS,uBAAuB;AAChC,SAAS,WAAW;AACpB,SAAS,6BAA6B;AACtC,SAAS,uBAAuB;AAChC,SAAS,mBAAmB;AAIrB,MAAM,iBAAiB,gBAAgC,eAAe;AACtE,MAAM,wBAAwB;AAAA,EACpC;AACD;AAqBO,IAAK,iBAAL,kBAAKA,oBAAL;AACN,EAAAA,gBAAA,UAAO;AACP,EAAAA,gBAAA,WAAQ;AAFG,SAAAA;AAAA,GAAA;AAKL,IAAK,kBAAL,kBAAKC,qBAAL;AACN,EAAAA,iBAAA,qBAAkB;AAClB,EAAAA,iBAAA,aAAU;AACV,EAAAA,iBAAA,YAAS;AAHE,SAAAA;AAAA,GAAA;AA2BL,SAAS,iBACf,yBAC6C;AAC7C,SAAO,CAAC,CAAE,wBAA4C;AACvD;AAJgB;AAMT,IAAK,wBAAL,kBAAKC,2BAAL;AACN,EAAAA,8CAAA,YAAS,KAAT;AACA,EAAAA,8CAAA,iBAAc,KAAd;AACA,EAAAA,8CAAA,iBAAc,KAAd;AACA,EAAAA,8CAAA,YAAS,KAAT;AACA,EAAAA,8CAAA,YAAS,KAAT;AACA,EAAAA,8CAAA,qBAAkB,KAAlB;AANW,SAAAA;AAAA,GAAA;AAyGL,SAAS,0CACf,KACgD;AAChD,MAAI,IAAI,WAAW,UAAU,IAAI,WAAW,SAAS;AACpD,WAAO;AAAA,EACR;AACA,QAAM,iBAAiB,8CAA8C;AAAA,IACpE,IAAI;AAAA,EACL;AACA,MAAI,CAAC,gBAAgB;AACpB,WAAO;AAAA,EACR;AACA,SAAO;AAAA,IACN,SAAS,eAAe,CAAC;AAAA,IACzB,MAAM,CAAC,eAAe,CAAC;AAAA,EACxB;AACD;AAhBgB;AAkBT,SAAS,+CACf,KACgD;AAChD,MAAK,IAAI,WAAW,UAAU,IAAI,WAAW,WAAY,CAAC,IAAI,OAAO;AACpE,WAAO;AAAA,EACR;AACA,QAAM,YAAY,IAAI,MAAM,MAAM,GAAG;AACrC,aAAW,YAAY,WAAW;AACjC,UAAM,QAAQ,SAAS,MAAM,GAAG,EAAE,CAAC;AACnC,QAAI,WAAW,KAAK,KAAK,GAAG;AAC3B,YAAM,SAAS;AAAA,QACd,IAAI,MAAM,KAAK;AAAA,MAChB;AACA,UAAI,QAAQ;AACX,eAAO;AAAA,MACR;AAAA,IACD;AAAA,EACD;AACA,SAAO;AACR;AAnBgB;AAqBT,MAAM,sBAAsB;AAAA,EAClC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACD;AACO,SAAS,YAAY,MAAuB;AAClD,SAAO,oBAAoB,QAAQ,IAAI,KAAK;AAC7C;AAFgB;AAIT,MAAM,2BAA2B,CAAC,WAAW,mBAAmB,IAAI;AACpE,SAAS,gBAAgB,MAAuB;AACtD,SAAO,yBAAyB,QAAQ,IAAI,KAAK;AAClD;AAFgB;AAIT,SAAS,iBACf,MACA,MACA,IACA,WACU;AACV,MAAI,OAAO,gBAAgB,SAAS;AACnC,WAAO;AAAA,EACR;AACA,MAAI,OAAO,gBAAgB,WAAW;AACrC,QAAI,gBAAgB,IAAI,GAAG;AAC1B,YAAM,YAAY,uBAAuB,KAAK,SAAS;AACvD,UAAI,WAAW,WAAW,GAAG;AAC5B,cAAM,QAAQ,OAAO,SAAS,UAAU,CAAC,CAAC;AAC1C,YACC,SAAS,IACR;AACD,iBAAO;AAAA,QACR;AAAA,MACD;AAAA,IACD;AAAA,EACD;AACA,SAAO,OAAO;AACf;AAvBgB;AAyBT,MAAM,iBAAiB;AAAA,EAI7B,YACiB,eACA,cACC,UAChB;AAHe;AACA;AACC;AAAA,EACf;AAAA,EAjRJ,OAyQ8B;AAAA;AAAA;AAAA,EACrB,aAA4B,IAAI,QAAQ;AAAA,EAChD,eAA4B,KAAK,WAAW;AAAA,EAQ5C,UAAyB;AACxB,SAAK,WAAW,KAAK;AACrB,WAAO,KAAK,SAAS;AAAA,EACtB;AACD;AAEO,IAAe,wBAAf,cACE,WAET;AAAA,EA4BQ,YAC0B,YACU,sBACzC;AAAE,UAAM;AAFuB;AACU;AAAA,EAC9B;AAAA,EA3Td,OA4RA;AAAA;AAAA;AAAA,EAGS,kBAAyC,IAAI,QAAQ;AAAA,EACtD,iBAAsC,KAAK,gBAAgB;AAAA,EAC1D,kBACP,IAAI,QAAQ;AAAA,EACN,iBACN,KAAK,gBAAgB;AAAA,EACd,yBAAwC,IAAI,QAAQ;AAAA,EACrD,wBACN,KAAK,uBAAuB;AAAA,EACV,WAAW,oBAAI,IAShC;AAAA,EACQ;AAAA,EACA,cAAc;AAAA,EAChB,qBAAqB;AAAA,EACrB,kBAAmC,CAAC;AAAA,EACpC,qBAA2C,oBAAI,IAAI;AAAA,EAO3D,IAAI,oBAA6B;AAChC,WAAO,CAAC,CAAC,KAAK;AAAA,EACf;AAAA,EAEA,IAAc,oBAA4B;AACzC,UAAM,eAAe,KAAK,qBAAqB;AAAA,MAC9C;AAAA,IACD;AACA,WAAO,CAAC,gBAAgB,iBAAiB,cACtC,cACA;AAAA,EACJ;AAAA,EAEA,kBAAkB,UAAoD;AACrE,SAAK,kBAAkB;AACvB,QAAI,CAAC,UAAU;AAEd,WAAK,cAAc;AACnB,WAAK,kBAAkB,CAAC;AACxB,WAAK,uBAAuB,KAAK;AACjC,aAAO;AAAA,QACN,SAAS,6BAAM;AAAA,QAAC,GAAP;AAAA,MACV;AAAA,IACD;AAEA,SAAK,uBAAuB,KAAK;AACjC,WAAO;AAAA,MACN,SAAS,6BAAM;AACd,aAAK,kBAAkB;AACvB,aAAK,cAAc;AACnB,aAAK,kBAAkB,CAAC;AAAA,MACzB,GAJS;AAAA,IAKV;AAAA,EACD;AAAA,EAEA,kBAAkB,UAAwC;AACzD,SAAK,cAAc,SAAS;AAC5B,SAAK,kBAAkB,SAAS;AAChC,SAAK,qBAAqB,SAAS;AAAA,EACpC;AAAA,EAEA,IAAW,oBAA6B;AACvC,WAAO,KAAK;AAAA,EACb;AAAA,EAEA,IAAW,aAAsB;AAChC,WAAO,KAAK;AAAA,EACb;AAAA,EAEA,IAAW,mBAAmB;AAC7B,WAAO,KAAK,gBAAgB,SAAS;AAAA,EACtC;AAAA,EAEA,IAAW,iBAAiB;AAC3B,WAAO,KAAK;AAAA,EACb;AAAA,EAEA,IAAW,UAA4C;AACtD,WAAO,KAAK,WAAW;AAAA,EACxB;AAAA,EAEA,MAAc,aAA+C;AAC5D,UAAM,UAA0B,CAAC;AACjC,UAAM,cAAc,MAAM,KAAK,KAAK,SAAS,OAAO,CAAC;AACrD,eAAW,WAAW,aAAa;AAClC,YAAM,YAAY,MAAM,KAAK,QAAQ,OAAO,CAAC;AAC7C,iBAAW,KAAK,WAAW;AAC1B,cAAM,cAAc,MAAM,EAAE;AAC5B,YAAI,eAAe,OAAO,gBAAgB,UAAU;AACnD,kBAAQ,KAAK,WAAW;AAAA,QACzB;AAAA,MACD;AAAA,IACD;AACA,WAAO;AAAA,EACR;AAAA,EAEA,MAAe,UAAyB;AACvC,UAAM,QAAQ;AACd,eAAW,WAAW,KAAK,SAAS,OAAO,GAAG;AAC7C,iBAAW,EAAE,MAAM,KAAK,QAAQ,OAAO,GAAG;AACzC,cAAM,MAAM;AAAA,UAAK,CAAC,WACjB,OAAO,WAAW,WAAW,QAAQ,QAAQ,IAAI;AAAA,QAClD;AAAA,MACD;AACA,cAAQ,MAAM;AAAA,IACf;AACA,SAAK,SAAS,MAAM;AAAA,EACrB;AAAA,EAEA,qBACC,YACA,YACA,cACA,SACA,UACO;AACP,SAAK;AAAA,MACJ;AAAA,MACA;AAAA,MACA,QAAQ,QAAQ;AAAA,QACf,kBAAkB;AAAA,QAClB,kBAAkB;AAAA,QAClB;AAAA,QACA;AAAA,QACA;AAAA,QACA,SAAS,6BAAM,QAAQ,QAAQ,GAAtB;AAAA,MACV,CAAC;AAAA,IACF;AAAA,EACD;AAAA,EAEA,MAAM,kBACL,YACA,YAC6C;AAC7C,QAAI,gBAAgB,UAAU,KAAK,YAAY,UAAU,GAAG;AAC3D,mBAAa,oBAAoB,CAAC;AAAA,IACnC;AAEA,UAAM,WAAW,KAAK,iBAAiB,YAAY,UAAU;AAC7D,QAAI,UAAU;AACb,QAAE,SAAS;AACX,aAAO,SAAS;AAAA,IACjB;AACA,WAAO;AAAA,EACR;AAAA,EAEA,WACC,iBACA,YACA,YACA,WACA,WACA,kBAAkB,OAClB,SACA,UACyD;AACzD,SAAK,WAAW;AAAA,MACf,0DAA0D,UAAU,IAAI,UAAU,kBAAkB,SAAS;AAAA,IAC9G;AACA,UAAM,0BAA0B,KAAK,mBAAmB;AACxD,QAAI,CAAC,yBAAyB;AAC7B,aAAO;AAAA,IACR;AAEA,QAAI,CAAC,YAAY;AAChB,mBAAa;AAAA,IACd;AACA,QAAI,CAAC,WAAW;AACf,kBAAY,KAAK;AAAA,IAClB;AAGA,QAAI,KAAK,mBAAmB,KAAK,mBAAmB,IAAI,UAAU,GAAG;AACpE,WAAK,WAAW;AAAA,QACf;AAAA,MACD;AACA;AAAA,IACD;AAEA,UAAM,iBAAiB,KAAK;AAAA,MAC3B;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACD;AACA,QAAI,CAAC,gBAAgB;AACpB,WAAK,WAAW;AAAA,QACf;AAAA,MACD;AACA,aAAO;AAAA,IACR;AAEA,WAAO,eAAe,KAAK,CAAC,WAAW;AACtC,UAAI,CAAC,QAAQ;AACZ,aAAK,WAAW;AAAA,UACf;AAAA,QACD;AACA,aAAK,gCAAgC,YAAY,UAAU;AAC3D,eAAO;AAAA,MACR,WAAW,OAAO,WAAW,UAAU;AACtC,aAAK,WAAW;AAAA,UACf;AAAA,QACD;AACA,aAAK,gCAAgC,YAAY,UAAU;AAC3D,eAAO;AAAA,MACR;AACA,WAAK,WAAW;AAAA,QACf;AAAA,MACD;AACA,YAAM,YAAY,KAAK,WAAW,MAAM;AACxC,UACC,OAAO,qBAAqB,cAC5B,OAAO,qBAAqB,YAC3B;AACD,aAAK,WAAW;AAAA,UACf;AAAA,QACD;AAAA,MACD;AACA,UAAI,WAAW,OAAO,YAAY,SAAS;AAC1C,aAAK,WAAW;AAAA,UACf;AAAA,QACD;AAAA,MACD;AACA,WAAK,gBAAgB,KAAK,SAAS;AACnC,aAAO;AAAA,IACR,CAAC;AAAA,EACF;AAAA,EAEQ,WAAW,QAAoC;AACtD,WAAO;AAAA,MACN,kBAAkB,OAAO;AAAA,MACzB,kBAAkB,OAAO;AAAA,MACzB,iBAAiB,OAAO;AAAA,MACxB,cAAc,OAAO;AAAA,MACrB,SAAS,OAAO;AAAA,MAChB,UAAU,OAAO;AAAA,MACjB,SAAS,mCAAY;AACpB,aAAK,WAAW;AAAA,UACf,uDAAuD,OAAO,gBAAgB,IAAI,OAAO,gBAAgB;AAAA,QAC1G;AACA,cAAM,eAAe,KAAK,SAAS,IAAI,OAAO,gBAAgB;AAC9D,YAAI,cAAc;AACjB,gBAAM,WAAW,aAAa,IAAI,OAAO,gBAAgB;AACzD,cAAI,UAAU;AACb,qBAAS;AACT,kBAAM,KAAK;AAAA,cACV,OAAO;AAAA,cACP,OAAO;AAAA,cACP;AAAA,YACD;AAAA,UACD;AAAA,QACD;AAAA,MACD,GAhBS;AAAA,IAiBV;AAAA,EACD;AAAA,EAEA,MAAc,iBACb,YACA,YACA,QAIgB;AAChB,QAAI,OAAO,YAAY,GAAG;AACzB,WAAK,WAAW;AAAA,QACf,4DAA4D,UAAU,IAAI,UAAU;AAAA,MACrF;AACA,YAAM,iBAAgC,OAAO,MAAM;AAAA,QAClD,OAAOC,YAAW;AACjB,cAAIA,WAAU,OAAOA,YAAW,UAAU;AACzC,kBAAMA,QAAO,QAAQ,IAAI;AACzB,iBAAK,gBAAgB,KAAK;AAAA,cACzB,MAAMA,QAAO;AAAA,cACb,MAAMA,QAAO;AAAA,YACd,CAAC;AAAA,UACF;AAAA,QACD;AAAA,MACD;AACA,UAAI,KAAK,SAAS,IAAI,UAAU,GAAG;AAClC,aAAK,SAAS,IAAI,UAAU,EAAG,OAAO,UAAU;AAAA,MACjD;AACA,aAAO;AAAA,IACR;AAAA,EACD;AAAA,EAEA,MAAM,YAAY,YAAoB,YAAmC;AACxE,SAAK,WAAW;AAAA,MACf,qDAAqD,UAAU,IAAI,UAAU;AAAA,IAC9E;AACA,UAAM,UAAU,KAAK,SAAS,IAAI,UAAU;AAC5C,QAAI,WAAW,QAAQ,IAAI,UAAU,GAAG;AACvC,YAAM,QAAQ,QAAQ,IAAI,UAAU;AACpC,YAAM,WAAW;AACjB,YAAM,KAAK,iBAAiB,YAAY,YAAY,KAAK;AAAA,IAC1D;AAAA,EACD;AAAA,EAEU,eACT,YACA,YACA,QACC;AACD,QAAI,CAAC,KAAK,SAAS,IAAI,UAAU,GAAG;AACnC,WAAK,SAAS,IAAI,YAAY,oBAAI,IAAI,CAAC;AAAA,IACxC;AACA,SAAK,SACH,IAAI,UAAU,EACd,IAAI,YAAY,EAAE,UAAU,GAAG,OAAO,OAAO,CAAC;AAAA,EACjD;AAAA,EAEA,MAAc,gCACb,YACA,YACC;AACD,UAAM,UAAU,KAAK,SAAS,IAAI,UAAU;AAC5C,QAAI,SAAS;AACZ,YAAM,SAAS,QAAQ,IAAI,UAAU;AACrC,YAAM,eAAe,SAAS,MAAM,OAAO,QAAQ;AACnD,UAAI,CAAC,gBAAgB,OAAO,iBAAiB,UAAU;AACtD,gBAAQ,OAAO,UAAU;AAAA,MAC1B;AACA,UAAI,QAAQ,SAAS,GAAG;AACvB,aAAK,SAAS,OAAO,UAAU;AAAA,MAChC;AAAA,IACD;AAAA,EACD;AAAA,EAEU,iBACT,YACA,YAMY;AACZ,UAAM,QAAQ,CAAC,UAAU;AAEzB,QAAI,YAAY,UAAU,GAAG;AAC5B,YAAM,KAAK,GAAG,mBAAmB;AAGjC,YAAM,KAAK,GAAG,wBAAwB;AAAA,IACvC,WAAW,gBAAgB,UAAU,GAAG;AACvC,YAAM,KAAK,GAAG,wBAAwB;AAAA,IACvC;AAEA,UAAM,mBAAmB,MAAM,IAAI,CAAC,SAAS,KAAK,SAAS,IAAI,IAAI,CAAC;AACpE,eAAW,OAAO,kBAAkB;AACnC,YAAM,iBAAiB,KAAK,IAAI,UAAU;AAC1C,UAAI,gBAAgB;AACnB,eAAO;AAAA,MACR;AAAA,IACD;AACA,WAAO;AAAA,EACR;AAAA,EAEA,UAAU,KAAmB;AAC5B,WAAO,CAAC,CAAC,0CAA0C,GAAG;AAAA,EACvD;AAAA,EAeU,mBACT,gBACA,YACA,YACA,WACA,iBACA,SACA,UACyD;AACzD,SAAK,WAAW;AAAA,MACf,iEAAiE,UAAU,IAAI,UAAU,kBAAkB,SAAS;AAAA,IACrH;AACA,UAAM,MAAM;AACZ,SAAK,mBAAmB,IAAI,GAAG;AAC/B,UAAM,qBACL,cAAc,SAAY,aAAa;AACxC,UAAM,eAAe;AAAA,MACpB,mBAAmB,kBAChB,KAAK,iBAAiB,kBAAkB,IACxC;AAAA,IACJ;AACA,UAAM,gBAA+B;AAAA,MACpC,eAAe,EAAE,MAAM,YAAY,MAAM,WAAW;AAAA,MACpD,kBAAkB;AAAA,MAClB;AAAA,MACA,QAAQ,UAAU,YAAY,0BAA0B;AAAA,MACxD;AAAA,IACD;AACA,UAAM,SAAS,eAAe,YAAY,eAAe,YAAY;AACrE,QAAI,QAAQ;AACX,WAAK,eAAe,YAAY,YAAY,MAAM;AAClD,aAAO,QAAQ,MAAM;AACpB,aAAK,WAAW;AAAA,UACf;AAAA,QACD;AACA,aAAK,mBAAmB,OAAO,GAAG;AAAA,MACnC,CAAC;AAAA,IACF,OAAO;AACN,WAAK,mBAAmB,OAAO,GAAG;AAAA,IACnC;AACA,WAAO;AAAA,EACR;AACD;AArbsB,wBAAf;AAAA,EAgCJ;AAAA,EACA;AAAA,GAjCmB;",
  "names": ["TunnelProtocol", "TunnelPrivacyId", "ProvidedOnAutoForward", "tunnel"]
}
