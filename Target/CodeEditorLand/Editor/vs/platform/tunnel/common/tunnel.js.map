{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/tunnel/common/tunnel.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { IDisposable, Disposable } from '../../../base/common/lifecycle.js';\nimport { OperatingSystem } from '../../../base/common/platform.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { IAddressProvider } from '../../remote/common/remoteAgentConnection.js';\nimport { TunnelPrivacy } from '../../remote/common/remoteAuthorityResolver.js';\n\nexport const ITunnelService = createDecorator<ITunnelService>('tunnelService');\nexport const ISharedTunnelsService = createDecorator<ISharedTunnelsService>('sharedTunnelsService');\n\nexport interface RemoteTunnel {\n\treadonly tunnelRemotePort: number;\n\treadonly tunnelRemoteHost: string;\n\treadonly tunnelLocalPort?: number;\n\treadonly localAddress: string;\n\treadonly privacy: string;\n\treadonly protocol?: string;\n\tdispose(silent?: boolean): Promise<void>;\n}\n\nexport interface TunnelOptions {\n\tremoteAddress: { port: number; host: string };\n\tlocalAddressPort?: number;\n\tlabel?: string;\n\tpublic?: boolean;\n\tprivacy?: string;\n\tprotocol?: string;\n}\n\nexport enum TunnelProtocol {\n\tHttp = 'http',\n\tHttps = 'https'\n}\n\nexport enum TunnelPrivacyId {\n\tConstantPrivate = 'constantPrivate', // private, and changing is unsupported\n\tPrivate = 'private',\n\tPublic = 'public'\n}\n\nexport interface TunnelCreationOptions {\n\televationRequired?: boolean;\n}\n\nexport interface TunnelProviderFeatures {\n\televation: boolean;\n\t/**\n\t * @deprecated\n\t */\n\tpublic?: boolean;\n\tprivacyOptions: TunnelPrivacy[];\n\tprotocol: boolean;\n}\n\nexport interface ITunnelProvider {\n\tforwardPort(tunnelOptions: TunnelOptions, tunnelCreationOptions: TunnelCreationOptions): Promise<RemoteTunnel | string | undefined> | undefined;\n}\n\nexport function isTunnelProvider(addressOrTunnelProvider: IAddressProvider | ITunnelProvider): addressOrTunnelProvider is ITunnelProvider {\n\treturn !!(addressOrTunnelProvider as ITunnelProvider).forwardPort;\n}\n\nexport enum ProvidedOnAutoForward {\n\tNotify = 1,\n\tOpenBrowser = 2,\n\tOpenPreview = 3,\n\tSilent = 4,\n\tIgnore = 5,\n\tOpenBrowserOnce = 6\n}\n\nexport interface ProvidedPortAttributes {\n\tport: number;\n\tautoForwardAction: ProvidedOnAutoForward;\n}\n\nexport interface PortAttributesProvider {\n\tprovidePortAttributes(ports: number[], pid: number | undefined, commandLine: string | undefined, token: CancellationToken): Promise<ProvidedPortAttributes[]>;\n}\n\nexport interface ITunnel {\n\tremoteAddress: { port: number; host: string };\n\n\t/**\n\t * The complete local address(ex. localhost:1234)\n\t */\n\tlocalAddress: string;\n\n\t/**\n\t * @deprecated Use privacy instead\n\t */\n\tpublic?: boolean;\n\n\tprivacy?: string;\n\n\tprotocol?: string;\n\n\t/**\n\t * Implementers of Tunnel should fire onDidDispose when dispose is called.\n\t */\n\tonDidDispose: Event<void>;\n\n\tdispose(): Promise<void> | void;\n}\n\nexport interface ISharedTunnelsService {\n\treadonly _serviceBrand: undefined;\n\n\topenTunnel(authority: string, addressProvider: IAddressProvider | undefined, remoteHost: string | undefined, remotePort: number, localHost: string, localPort?: number, elevateIfNeeded?: boolean, privacy?: string, protocol?: string): Promise<RemoteTunnel | string | undefined> | undefined;\n}\n\nexport interface ITunnelService {\n\treadonly _serviceBrand: undefined;\n\n\treadonly tunnels: Promise<readonly RemoteTunnel[]>;\n\treadonly canChangePrivacy: boolean;\n\treadonly privacyOptions: TunnelPrivacy[];\n\treadonly onTunnelOpened: Event<RemoteTunnel>;\n\treadonly onTunnelClosed: Event<{ host: string; port: number }>;\n\treadonly canElevate: boolean;\n\treadonly canChangeProtocol: boolean;\n\treadonly hasTunnelProvider: boolean;\n\treadonly onAddedTunnelProvider: Event<void>;\n\n\tcanTunnel(uri: URI): boolean;\n\topenTunnel(addressProvider: IAddressProvider | undefined, remoteHost: string | undefined, remotePort: number, localHost?: string, localPort?: number, elevateIfNeeded?: boolean, privacy?: string, protocol?: string): Promise<RemoteTunnel | string | undefined> | undefined;\n\tgetExistingTunnel(remoteHost: string, remotePort: number): Promise<RemoteTunnel | string | undefined>;\n\tsetEnvironmentTunnel(remoteHost: string, remotePort: number, localAddress: string, privacy: string, protocol: string): void;\n\tcloseTunnel(remoteHost: string, remotePort: number): Promise<void>;\n\tsetTunnelProvider(provider: ITunnelProvider | undefined): IDisposable;\n\tsetTunnelFeatures(features: TunnelProviderFeatures): void;\n\tisPortPrivileged(port: number): boolean;\n}\n\nexport function extractLocalHostUriMetaDataForPortMapping(uri: URI): { address: string; port: number } | undefined {\n\tif (uri.scheme !== 'http' && uri.scheme !== 'https') {\n\t\treturn undefined;\n\t}\n\tconst localhostMatch = /^(localhost|127\\.0\\.0\\.1|0\\.0\\.0\\.0):(\\d+)$/.exec(uri.authority);\n\tif (!localhostMatch) {\n\t\treturn undefined;\n\t}\n\treturn {\n\t\taddress: localhostMatch[1],\n\t\tport: +localhostMatch[2],\n\t};\n}\n\nexport function extractQueryLocalHostUriMetaDataForPortMapping(uri: URI): { address: string; port: number } | undefined {\n\tif (uri.scheme !== 'http' && uri.scheme !== 'https' || !uri.query) {\n\t\treturn undefined;\n\t}\n\tconst keyvalues = uri.query.split('&');\n\tfor (const keyvalue of keyvalues) {\n\t\tconst value = keyvalue.split('=')[1];\n\t\tif (/^https?:/.exec(value)) {\n\t\t\tconst result = extractLocalHostUriMetaDataForPortMapping(URI.parse(value));\n\t\t\tif (result) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t}\n\treturn undefined;\n}\n\nexport const LOCALHOST_ADDRESSES = ['localhost', '127.0.0.1', '0:0:0:0:0:0:0:1', '::1'];\nexport function isLocalhost(host: string): boolean {\n\treturn LOCALHOST_ADDRESSES.indexOf(host) >= 0;\n}\n\nexport const ALL_INTERFACES_ADDRESSES = ['0.0.0.0', '0:0:0:0:0:0:0:0', '::'];\nexport function isAllInterfaces(host: string): boolean {\n\treturn ALL_INTERFACES_ADDRESSES.indexOf(host) >= 0;\n}\n\nexport function isPortPrivileged(port: number, host: string, os: OperatingSystem, osRelease: string): boolean {\n\tif (os === OperatingSystem.Windows) {\n\t\treturn false;\n\t}\n\tif (os === OperatingSystem.Macintosh) {\n\t\tif (isAllInterfaces(host)) {\n\t\t\tconst osVersion = (/(\\d+)\\.(\\d+)\\.(\\d+)/g).exec(osRelease);\n\t\t\tif (osVersion?.length === 4) {\n\t\t\t\tconst major = parseInt(osVersion[1]);\n\t\t\t\tif (major >= 18 /* since macOS Mojave, darwin version 18.0.0 */) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn port < 1024;\n}\n\nexport class DisposableTunnel {\n\tprivate _onDispose: Emitter<void> = new Emitter();\n\tonDidDispose: Event<void> = this._onDispose.event;\n\n\tconstructor(\n\t\tpublic readonly remoteAddress: { port: number; host: string },\n\t\tpublic readonly localAddress: { port: number; host: string } | string,\n\t\tprivate readonly _dispose: () => Promise<void>) { }\n\n\tdispose(): Promise<void> {\n\t\tthis._onDispose.fire();\n\t\treturn this._dispose();\n\t}\n}\n\nexport abstract class AbstractTunnelService extends Disposable implements ITunnelService {\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate _onTunnelOpened: Emitter<RemoteTunnel> = new Emitter();\n\tpublic onTunnelOpened: Event<RemoteTunnel> = this._onTunnelOpened.event;\n\tprivate _onTunnelClosed: Emitter<{ host: string; port: number }> = new Emitter();\n\tpublic onTunnelClosed: Event<{ host: string; port: number }> = this._onTunnelClosed.event;\n\tprivate _onAddedTunnelProvider: Emitter<void> = new Emitter();\n\tpublic onAddedTunnelProvider: Event<void> = this._onAddedTunnelProvider.event;\n\tprotected readonly _tunnels = new Map</*host*/ string, Map</* port */ number, { refcount: number; readonly value: Promise<RemoteTunnel | string | undefined> }>>();\n\tprotected _tunnelProvider: ITunnelProvider | undefined;\n\tprotected _canElevate: boolean = false;\n\tprivate _canChangeProtocol: boolean = true;\n\tprivate _privacyOptions: TunnelPrivacy[] = [];\n\tprivate _factoryInProgress: Set<number/*port*/> = new Set();\n\n\tpublic constructor(\n\t\t@ILogService protected readonly logService: ILogService,\n\t\t@IConfigurationService protected readonly configurationService: IConfigurationService\n\t) { super(); }\n\n\tget hasTunnelProvider(): boolean {\n\t\treturn !!this._tunnelProvider;\n\t}\n\n\tprotected get defaultTunnelHost(): string {\n\t\tconst settingValue = this.configurationService.getValue('remote.localPortHost');\n\t\treturn (!settingValue || settingValue === 'localhost') ? '127.0.0.1' : '0.0.0.0';\n\t}\n\n\tsetTunnelProvider(provider: ITunnelProvider | undefined): IDisposable {\n\t\tthis._tunnelProvider = provider;\n\t\tif (!provider) {\n\t\t\t// clear features\n\t\t\tthis._canElevate = false;\n\t\t\tthis._privacyOptions = [];\n\t\t\tthis._onAddedTunnelProvider.fire();\n\t\t\treturn {\n\t\t\t\tdispose: () => { }\n\t\t\t};\n\t\t}\n\n\t\tthis._onAddedTunnelProvider.fire();\n\t\treturn {\n\t\t\tdispose: () => {\n\t\t\t\tthis._tunnelProvider = undefined;\n\t\t\t\tthis._canElevate = false;\n\t\t\t\tthis._privacyOptions = [];\n\t\t\t}\n\t\t};\n\t}\n\n\tsetTunnelFeatures(features: TunnelProviderFeatures): void {\n\t\tthis._canElevate = features.elevation;\n\t\tthis._privacyOptions = features.privacyOptions;\n\t\tthis._canChangeProtocol = features.protocol;\n\t}\n\n\tpublic get canChangeProtocol(): boolean {\n\t\treturn this._canChangeProtocol;\n\t}\n\n\tpublic get canElevate(): boolean {\n\t\treturn this._canElevate;\n\t}\n\n\tpublic get canChangePrivacy() {\n\t\treturn this._privacyOptions.length > 0;\n\t}\n\n\tpublic get privacyOptions() {\n\t\treturn this._privacyOptions;\n\t}\n\n\tpublic get tunnels(): Promise<readonly RemoteTunnel[]> {\n\t\treturn this.getTunnels();\n\t}\n\n\tprivate async getTunnels(): Promise<readonly RemoteTunnel[]> {\n\t\tconst tunnels: RemoteTunnel[] = [];\n\t\tconst tunnelArray = Array.from(this._tunnels.values());\n\t\tfor (const portMap of tunnelArray) {\n\t\t\tconst portArray = Array.from(portMap.values());\n\t\t\tfor (const x of portArray) {\n\t\t\t\tconst tunnelValue = await x.value;\n\t\t\t\tif (tunnelValue && (typeof tunnelValue !== 'string')) {\n\t\t\t\t\ttunnels.push(tunnelValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn tunnels;\n\t}\n\n\toverride async dispose(): Promise<void> {\n\t\tsuper.dispose();\n\t\tfor (const portMap of this._tunnels.values()) {\n\t\t\tfor (const { value } of portMap.values()) {\n\t\t\t\tawait value.then(tunnel => typeof tunnel !== 'string' ? tunnel?.dispose() : undefined);\n\t\t\t}\n\t\t\tportMap.clear();\n\t\t}\n\t\tthis._tunnels.clear();\n\t}\n\n\tsetEnvironmentTunnel(remoteHost: string, remotePort: number, localAddress: string, privacy: string, protocol: string): void {\n\t\tthis.addTunnelToMap(remoteHost, remotePort, Promise.resolve({\n\t\t\ttunnelRemoteHost: remoteHost,\n\t\t\ttunnelRemotePort: remotePort,\n\t\t\tlocalAddress,\n\t\t\tprivacy,\n\t\t\tprotocol,\n\t\t\tdispose: () => Promise.resolve()\n\t\t}));\n\t}\n\n\tasync getExistingTunnel(remoteHost: string, remotePort: number): Promise<RemoteTunnel | string | undefined> {\n\t\tif (isAllInterfaces(remoteHost) || isLocalhost(remoteHost)) {\n\t\t\tremoteHost = LOCALHOST_ADDRESSES[0];\n\t\t}\n\n\t\tconst existing = this.getTunnelFromMap(remoteHost, remotePort);\n\t\tif (existing) {\n\t\t\t++existing.refcount;\n\t\t\treturn existing.value;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\topenTunnel(addressProvider: IAddressProvider | undefined, remoteHost: string | undefined, remotePort: number, localHost?: string, localPort?: number, elevateIfNeeded: boolean = false, privacy?: string, protocol?: string): Promise<RemoteTunnel | string | undefined> | undefined {\n\t\tthis.logService.trace(`ForwardedPorts: (TunnelService) openTunnel request for ${remoteHost}:${remotePort} on local port ${localPort}.`);\n\t\tconst addressOrTunnelProvider = this._tunnelProvider ?? addressProvider;\n\t\tif (!addressOrTunnelProvider) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!remoteHost) {\n\t\t\tremoteHost = 'localhost';\n\t\t}\n\t\tif (!localHost) {\n\t\t\tlocalHost = this.defaultTunnelHost;\n\t\t}\n\n\t\t// Prevent tunnel factories from calling openTunnel from within the factory\n\t\tif (this._tunnelProvider && this._factoryInProgress.has(remotePort)) {\n\t\t\tthis.logService.debug(`ForwardedPorts: (TunnelService) Another call to create a tunnel with the same address has occurred before the last one completed. This call will be ignored.`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst resolvedTunnel = this.retainOrCreateTunnel(addressOrTunnelProvider, remoteHost, remotePort, localHost, localPort, elevateIfNeeded, privacy, protocol);\n\t\tif (!resolvedTunnel) {\n\t\t\tthis.logService.trace(`ForwardedPorts: (TunnelService) Tunnel was not created.`);\n\t\t\treturn resolvedTunnel;\n\t\t}\n\n\t\treturn resolvedTunnel.then(tunnel => {\n\t\t\tif (!tunnel) {\n\t\t\t\tthis.logService.trace('ForwardedPorts: (TunnelService) New tunnel is undefined.');\n\t\t\t\tthis.removeEmptyOrErrorTunnelFromMap(remoteHost, remotePort);\n\t\t\t\treturn undefined;\n\t\t\t} else if (typeof tunnel === 'string') {\n\t\t\t\tthis.logService.trace('ForwardedPorts: (TunnelService) The tunnel provider returned an error when creating the tunnel.');\n\t\t\t\tthis.removeEmptyOrErrorTunnelFromMap(remoteHost, remotePort);\n\t\t\t\treturn tunnel;\n\t\t\t}\n\t\t\tthis.logService.trace('ForwardedPorts: (TunnelService) New tunnel established.');\n\t\t\tconst newTunnel = this.makeTunnel(tunnel);\n\t\t\tif (tunnel.tunnelRemoteHost !== remoteHost || tunnel.tunnelRemotePort !== remotePort) {\n\t\t\t\tthis.logService.warn('ForwardedPorts: (TunnelService) Created tunnel does not match requirements of requested tunnel. Host or port mismatch.');\n\t\t\t}\n\t\t\tif (privacy && tunnel.privacy !== privacy) {\n\t\t\t\tthis.logService.warn('ForwardedPorts: (TunnelService) Created tunnel does not match requirements of requested tunnel. Privacy mismatch.');\n\t\t\t}\n\t\t\tthis._onTunnelOpened.fire(newTunnel);\n\t\t\treturn newTunnel;\n\t\t});\n\t}\n\n\tprivate makeTunnel(tunnel: RemoteTunnel): RemoteTunnel {\n\t\treturn {\n\t\t\ttunnelRemotePort: tunnel.tunnelRemotePort,\n\t\t\ttunnelRemoteHost: tunnel.tunnelRemoteHost,\n\t\t\ttunnelLocalPort: tunnel.tunnelLocalPort,\n\t\t\tlocalAddress: tunnel.localAddress,\n\t\t\tprivacy: tunnel.privacy,\n\t\t\tprotocol: tunnel.protocol,\n\t\t\tdispose: async () => {\n\t\t\t\tthis.logService.trace(`ForwardedPorts: (TunnelService) dispose request for ${tunnel.tunnelRemoteHost}:${tunnel.tunnelRemotePort} `);\n\t\t\t\tconst existingHost = this._tunnels.get(tunnel.tunnelRemoteHost);\n\t\t\t\tif (existingHost) {\n\t\t\t\t\tconst existing = existingHost.get(tunnel.tunnelRemotePort);\n\t\t\t\t\tif (existing) {\n\t\t\t\t\t\texisting.refcount--;\n\t\t\t\t\t\tawait this.tryDisposeTunnel(tunnel.tunnelRemoteHost, tunnel.tunnelRemotePort, existing);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\tprivate async tryDisposeTunnel(remoteHost: string, remotePort: number, tunnel: { refcount: number; readonly value: Promise<RemoteTunnel | string | undefined> }): Promise<void> {\n\t\tif (tunnel.refcount <= 0) {\n\t\t\tthis.logService.trace(`ForwardedPorts: (TunnelService) Tunnel is being disposed ${remoteHost}:${remotePort}.`);\n\t\t\tconst disposePromise: Promise<void> = tunnel.value.then(async (tunnel) => {\n\t\t\t\tif (tunnel && (typeof tunnel !== 'string')) {\n\t\t\t\t\tawait tunnel.dispose(true);\n\t\t\t\t\tthis._onTunnelClosed.fire({ host: tunnel.tunnelRemoteHost, port: tunnel.tunnelRemotePort });\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (this._tunnels.has(remoteHost)) {\n\t\t\t\tthis._tunnels.get(remoteHost)!.delete(remotePort);\n\t\t\t}\n\t\t\treturn disposePromise;\n\t\t}\n\t}\n\n\tasync closeTunnel(remoteHost: string, remotePort: number): Promise<void> {\n\t\tthis.logService.trace(`ForwardedPorts: (TunnelService) close request for ${remoteHost}:${remotePort} `);\n\t\tconst portMap = this._tunnels.get(remoteHost);\n\t\tif (portMap && portMap.has(remotePort)) {\n\t\t\tconst value = portMap.get(remotePort)!;\n\t\t\tvalue.refcount = 0;\n\t\t\tawait this.tryDisposeTunnel(remoteHost, remotePort, value);\n\t\t}\n\t}\n\n\tprotected addTunnelToMap(remoteHost: string, remotePort: number, tunnel: Promise<RemoteTunnel | string | undefined>) {\n\t\tif (!this._tunnels.has(remoteHost)) {\n\t\t\tthis._tunnels.set(remoteHost, new Map());\n\t\t}\n\t\tthis._tunnels.get(remoteHost)!.set(remotePort, { refcount: 1, value: tunnel });\n\t}\n\n\tprivate async removeEmptyOrErrorTunnelFromMap(remoteHost: string, remotePort: number) {\n\t\tconst hostMap = this._tunnels.get(remoteHost);\n\t\tif (hostMap) {\n\t\t\tconst tunnel = hostMap.get(remotePort);\n\t\t\tconst tunnelResult = tunnel ? await tunnel.value : undefined;\n\t\t\tif (!tunnelResult || (typeof tunnelResult === 'string')) {\n\t\t\t\thostMap.delete(remotePort);\n\t\t\t}\n\t\t\tif (hostMap.size === 0) {\n\t\t\t\tthis._tunnels.delete(remoteHost);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected getTunnelFromMap(remoteHost: string, remotePort: number): { refcount: number; readonly value: Promise<RemoteTunnel | string | undefined> } | undefined {\n\t\tconst hosts = [remoteHost];\n\t\t// Order matters. We want the original host to be first.\n\t\tif (isLocalhost(remoteHost)) {\n\t\t\thosts.push(...LOCALHOST_ADDRESSES);\n\t\t\t// For localhost, we add the all interfaces hosts because if the tunnel is already available at all interfaces,\n\t\t\t// then of course it is available at localhost.\n\t\t\thosts.push(...ALL_INTERFACES_ADDRESSES);\n\t\t} else if (isAllInterfaces(remoteHost)) {\n\t\t\thosts.push(...ALL_INTERFACES_ADDRESSES);\n\t\t}\n\n\t\tconst existingPortMaps = hosts.map(host => this._tunnels.get(host));\n\t\tfor (const map of existingPortMaps) {\n\t\t\tconst existingTunnel = map?.get(remotePort);\n\t\t\tif (existingTunnel) {\n\t\t\t\treturn existingTunnel;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tcanTunnel(uri: URI): boolean {\n\t\treturn !!extractLocalHostUriMetaDataForPortMapping(uri);\n\t}\n\n\tpublic abstract isPortPrivileged(port: number): boolean;\n\n\tprotected abstract retainOrCreateTunnel(addressProvider: IAddressProvider | ITunnelProvider, remoteHost: string, remotePort: number, localHost: string, localPort: number | undefined, elevateIfNeeded: boolean, privacy?: string, protocol?: string): Promise<RemoteTunnel | string | undefined> | undefined;\n\n\tprotected createWithProvider(tunnelProvider: ITunnelProvider, remoteHost: string, remotePort: number, localPort: number | undefined, elevateIfNeeded: boolean, privacy?: string, protocol?: string): Promise<RemoteTunnel | string | undefined> | undefined {\n\t\tthis.logService.trace(`ForwardedPorts: (TunnelService) Creating tunnel with provider ${remoteHost}:${remotePort} on local port ${localPort}.`);\n\t\tconst key = remotePort;\n\t\tthis._factoryInProgress.add(key);\n\t\tconst preferredLocalPort = localPort === undefined ? remotePort : localPort;\n\t\tconst creationInfo = { elevationRequired: elevateIfNeeded ? this.isPortPrivileged(preferredLocalPort) : false };\n\t\tconst tunnelOptions: TunnelOptions = { remoteAddress: { host: remoteHost, port: remotePort }, localAddressPort: localPort, privacy, public: privacy ? (privacy !== TunnelPrivacyId.Private) : undefined, protocol };\n\t\tconst tunnel = tunnelProvider.forwardPort(tunnelOptions, creationInfo);\n\t\tif (tunnel) {\n\t\t\tthis.addTunnelToMap(remoteHost, remotePort, tunnel);\n\t\t\ttunnel.finally(() => {\n\t\t\t\tthis.logService.trace('ForwardedPorts: (TunnelService) Tunnel created by provider.');\n\t\t\t\tthis._factoryInProgress.delete(key);\n\t\t\t});\n\t\t} else {\n\t\t\tthis._factoryInProgress.delete(key);\n\t\t}\n\t\treturn tunnel;\n\t}\n}\n"],
  "mappings": "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",
  "names": ["TunnelProtocol", "TunnelPrivacyId", "ProvidedOnAutoForward", "tunnel"]
}
