{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/tunnel/node/tunnelService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as net from 'net';\nimport * as os from 'os';\nimport { BROWSER_RESTRICTED_PORTS, findFreePortFaster } from '../../../base/node/ports.js';\nimport { NodeSocket } from '../../../base/parts/ipc/node/ipc.net.js';\n\nimport { Barrier } from '../../../base/common/async.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { OS } from '../../../base/common/platform.js';\nimport { ISocket } from '../../../base/parts/ipc/common/ipc.net.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { IProductService } from '../../product/common/productService.js';\nimport { IAddressProvider, IConnectionOptions, connectRemoteAgentTunnel } from '../../remote/common/remoteAgentConnection.js';\nimport { IRemoteSocketFactoryService } from '../../remote/common/remoteSocketFactoryService.js';\nimport { ISignService } from '../../sign/common/sign.js';\nimport { AbstractTunnelService, ISharedTunnelsService, ITunnelProvider, ITunnelService, RemoteTunnel, TunnelPrivacyId, isAllInterfaces, isLocalhost, isPortPrivileged, isTunnelProvider } from '../common/tunnel.js';\nimport { VSBuffer } from '../../../base/common/buffer.js';\n\nasync function createRemoteTunnel(options: IConnectionOptions, defaultTunnelHost: string, tunnelRemoteHost: string, tunnelRemotePort: number, tunnelLocalPort?: number): Promise<RemoteTunnel> {\n\tlet readyTunnel: NodeRemoteTunnel | undefined;\n\tfor (let attempts = 3; attempts; attempts--) {\n\t\treadyTunnel?.dispose();\n\t\tconst tunnel = new NodeRemoteTunnel(options, defaultTunnelHost, tunnelRemoteHost, tunnelRemotePort, tunnelLocalPort);\n\t\treadyTunnel = await tunnel.waitForReady();\n\t\tif ((tunnelLocalPort && BROWSER_RESTRICTED_PORTS[tunnelLocalPort]) || !BROWSER_RESTRICTED_PORTS[readyTunnel.tunnelLocalPort]) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn readyTunnel!;\n}\n\nexport class NodeRemoteTunnel extends Disposable implements RemoteTunnel {\n\n\tpublic readonly tunnelRemotePort: number;\n\tpublic tunnelLocalPort!: number;\n\tpublic tunnelRemoteHost: string;\n\tpublic localAddress!: string;\n\tpublic readonly privacy = TunnelPrivacyId.Private;\n\n\tprivate readonly _options: IConnectionOptions;\n\tprivate readonly _server: net.Server;\n\tprivate readonly _barrier: Barrier;\n\n\tprivate readonly _listeningListener: () => void;\n\tprivate readonly _connectionListener: (socket: net.Socket) => void;\n\tprivate readonly _errorListener: () => void;\n\n\tprivate readonly _socketsDispose: Map<string, () => void> = new Map();\n\n\tconstructor(options: IConnectionOptions, private readonly defaultTunnelHost: string, tunnelRemoteHost: string, tunnelRemotePort: number, private readonly suggestedLocalPort?: number) {\n\t\tsuper();\n\t\tthis._options = options;\n\t\tthis._server = net.createServer();\n\t\tthis._barrier = new Barrier();\n\n\t\tthis._listeningListener = () => this._barrier.open();\n\t\tthis._server.on('listening', this._listeningListener);\n\n\t\tthis._connectionListener = (socket) => this._onConnection(socket);\n\t\tthis._server.on('connection', this._connectionListener);\n\n\t\t// If there is no error listener and there is an error it will crash the whole window\n\t\tthis._errorListener = () => { };\n\t\tthis._server.on('error', this._errorListener);\n\n\t\tthis.tunnelRemotePort = tunnelRemotePort;\n\t\tthis.tunnelRemoteHost = tunnelRemoteHost;\n\t}\n\n\tpublic override async dispose(): Promise<void> {\n\t\tsuper.dispose();\n\t\tthis._server.removeListener('listening', this._listeningListener);\n\t\tthis._server.removeListener('connection', this._connectionListener);\n\t\tthis._server.removeListener('error', this._errorListener);\n\t\tthis._server.close();\n\t\tconst disposers = Array.from(this._socketsDispose.values());\n\t\tdisposers.forEach(disposer => {\n\t\t\tdisposer();\n\t\t});\n\t}\n\n\tpublic async waitForReady(): Promise<this> {\n\t\tconst startPort = this.suggestedLocalPort ?? this.tunnelRemotePort;\n\t\tconst hostname = isAllInterfaces(this.defaultTunnelHost) ? '0.0.0.0' : '127.0.0.1';\n\t\t// try to get the same port number as the remote port number...\n\t\tlet localPort = await findFreePortFaster(startPort, 2, 1000, hostname);\n\n\t\t// if that fails, the method above returns 0, which works out fine below...\n\t\tlet address: string | net.AddressInfo | null = null;\n\t\tthis._server.listen(localPort, this.defaultTunnelHost);\n\t\tawait this._barrier.wait();\n\t\taddress = <net.AddressInfo>this._server.address();\n\n\t\t// It is possible for findFreePortFaster to return a port that there is already a server listening on. This causes the previous listen call to error out.\n\t\tif (!address) {\n\t\t\tlocalPort = 0;\n\t\t\tthis._server.listen(localPort, this.defaultTunnelHost);\n\t\t\tawait this._barrier.wait();\n\t\t\taddress = <net.AddressInfo>this._server.address();\n\t\t}\n\n\t\tthis.tunnelLocalPort = address.port;\n\t\tthis.localAddress = `${this.tunnelRemoteHost === '127.0.0.1' ? '127.0.0.1' : 'localhost'}:${address.port}`;\n\t\treturn this;\n\t}\n\n\tprivate async _onConnection(localSocket: net.Socket): Promise<void> {\n\t\t// pause reading on the socket until we have a chance to forward its data\n\t\tlocalSocket.pause();\n\n\t\tconst tunnelRemoteHost = (isLocalhost(this.tunnelRemoteHost) || isAllInterfaces(this.tunnelRemoteHost)) ? 'localhost' : this.tunnelRemoteHost;\n\t\tconst protocol = await connectRemoteAgentTunnel(this._options, tunnelRemoteHost, this.tunnelRemotePort);\n\t\tconst remoteSocket = protocol.getSocket();\n\t\tconst dataChunk = protocol.readEntireBuffer();\n\t\tprotocol.dispose();\n\n\t\tif (dataChunk.byteLength > 0) {\n\t\t\tlocalSocket.write(dataChunk.buffer);\n\t\t}\n\n\t\tlocalSocket.on('end', () => {\n\t\t\tif (localSocket.localAddress) {\n\t\t\t\tthis._socketsDispose.delete(localSocket.localAddress);\n\t\t\t}\n\t\t\tremoteSocket.end();\n\t\t});\n\t\tlocalSocket.on('close', () => remoteSocket.end());\n\t\tlocalSocket.on('error', () => {\n\t\t\tif (localSocket.localAddress) {\n\t\t\t\tthis._socketsDispose.delete(localSocket.localAddress);\n\t\t\t}\n\t\t\tif (remoteSocket instanceof NodeSocket) {\n\t\t\t\tremoteSocket.socket.destroy();\n\t\t\t} else {\n\t\t\t\tremoteSocket.end();\n\t\t\t}\n\t\t});\n\n\t\tif (remoteSocket instanceof NodeSocket) {\n\t\t\tthis._mirrorNodeSocket(localSocket, remoteSocket);\n\t\t} else {\n\t\t\tthis._mirrorGenericSocket(localSocket, remoteSocket);\n\t\t}\n\n\t\tif (localSocket.localAddress) {\n\t\t\tthis._socketsDispose.set(localSocket.localAddress, () => {\n\t\t\t\t// Need to end instead of unpipe, otherwise whatever is connected locally could end up \"stuck\" with whatever state it had until manually exited.\n\t\t\t\tlocalSocket.end();\n\t\t\t\tremoteSocket.end();\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate _mirrorGenericSocket(localSocket: net.Socket, remoteSocket: ISocket) {\n\t\tremoteSocket.onClose(() => localSocket.destroy());\n\t\tremoteSocket.onEnd(() => localSocket.end());\n\t\tremoteSocket.onData(d => localSocket.write(d.buffer));\n\t\tlocalSocket.on('data', d => remoteSocket.write(VSBuffer.wrap(d)));\n\t\tlocalSocket.resume();\n\t}\n\n\tprivate _mirrorNodeSocket(localSocket: net.Socket, remoteNodeSocket: NodeSocket) {\n\t\tconst remoteSocket = remoteNodeSocket.socket;\n\t\tremoteSocket.on('end', () => localSocket.end());\n\t\tremoteSocket.on('close', () => localSocket.end());\n\t\tremoteSocket.on('error', () => {\n\t\t\tlocalSocket.destroy();\n\t\t});\n\n\t\tremoteSocket.pipe(localSocket);\n\t\tlocalSocket.pipe(remoteSocket);\n\t}\n}\n\nexport class BaseTunnelService extends AbstractTunnelService {\n\tpublic constructor(\n\t\t@IRemoteSocketFactoryService private readonly remoteSocketFactoryService: IRemoteSocketFactoryService,\n\t\t@ILogService logService: ILogService,\n\t\t@ISignService private readonly signService: ISignService,\n\t\t@IProductService private readonly productService: IProductService,\n\t\t@IConfigurationService configurationService: IConfigurationService\n\t) {\n\t\tsuper(logService, configurationService);\n\t}\n\n\tpublic isPortPrivileged(port: number): boolean {\n\t\treturn isPortPrivileged(port, this.defaultTunnelHost, OS, os.release());\n\t}\n\n\tprotected retainOrCreateTunnel(addressOrTunnelProvider: IAddressProvider | ITunnelProvider, remoteHost: string, remotePort: number, localHost: string, localPort: number | undefined, elevateIfNeeded: boolean, privacy?: string, protocol?: string): Promise<RemoteTunnel | string | undefined> | undefined {\n\t\tconst existing = this.getTunnelFromMap(remoteHost, remotePort);\n\t\tif (existing) {\n\t\t\t++existing.refcount;\n\t\t\treturn existing.value;\n\t\t}\n\n\t\tif (isTunnelProvider(addressOrTunnelProvider)) {\n\t\t\treturn this.createWithProvider(addressOrTunnelProvider, remoteHost, remotePort, localPort, elevateIfNeeded, privacy, protocol);\n\t\t} else {\n\t\t\tthis.logService.trace(`ForwardedPorts: (TunnelService) Creating tunnel without provider ${remoteHost}:${remotePort} on local port ${localPort}.`);\n\t\t\tconst options: IConnectionOptions = {\n\t\t\t\tcommit: this.productService.commit,\n\t\t\t\tquality: this.productService.quality,\n\t\t\t\taddressProvider: addressOrTunnelProvider,\n\t\t\t\tremoteSocketFactoryService: this.remoteSocketFactoryService,\n\t\t\t\tsignService: this.signService,\n\t\t\t\tlogService: this.logService,\n\t\t\t\tipcLogger: null\n\t\t\t};\n\n\t\t\tconst tunnel = createRemoteTunnel(options, localHost, remoteHost, remotePort, localPort);\n\t\t\tthis.logService.trace('ForwardedPorts: (TunnelService) Tunnel created without provider.');\n\t\t\tthis.addTunnelToMap(remoteHost, remotePort, tunnel);\n\t\t\treturn tunnel;\n\t\t}\n\t}\n}\n\nexport class TunnelService extends BaseTunnelService {\n\tpublic constructor(\n\t\t@IRemoteSocketFactoryService remoteSocketFactoryService: IRemoteSocketFactoryService,\n\t\t@ILogService logService: ILogService,\n\t\t@ISignService signService: ISignService,\n\t\t@IProductService productService: IProductService,\n\t\t@IConfigurationService configurationService: IConfigurationService\n\t) {\n\t\tsuper(remoteSocketFactoryService, logService, signService, productService, configurationService);\n\t}\n}\n\nexport class SharedTunnelsService extends Disposable implements ISharedTunnelsService {\n\tdeclare readonly _serviceBrand: undefined;\n\tprivate readonly _tunnelServices: Map<string, ITunnelService> = new Map();\n\n\tpublic constructor(\n\t\t@IRemoteSocketFactoryService protected readonly remoteSocketFactoryService: IRemoteSocketFactoryService,\n\t\t@ILogService protected readonly logService: ILogService,\n\t\t@IProductService private readonly productService: IProductService,\n\t\t@ISignService private readonly signService: ISignService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t) {\n\t\tsuper();\n\t}\n\n\tasync openTunnel(authority: string, addressProvider: IAddressProvider | undefined, remoteHost: string | undefined, remotePort: number, localHost: string, localPort?: number, elevateIfNeeded?: boolean, privacy?: string, protocol?: string): Promise<RemoteTunnel | string | undefined> {\n\t\tthis.logService.trace(`ForwardedPorts: (SharedTunnelService) openTunnel request for ${remoteHost}:${remotePort} on local port ${localPort}.`);\n\t\tif (!this._tunnelServices.has(authority)) {\n\t\t\tconst tunnelService = new TunnelService(this.remoteSocketFactoryService, this.logService, this.signService, this.productService, this.configurationService);\n\t\t\tthis._register(tunnelService);\n\t\t\tthis._tunnelServices.set(authority, tunnelService);\n\t\t\ttunnelService.onTunnelClosed(async () => {\n\t\t\t\tif ((await tunnelService.tunnels).length === 0) {\n\t\t\t\t\ttunnelService.dispose();\n\t\t\t\t\tthis._tunnelServices.delete(authority);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this._tunnelServices.get(authority)!.openTunnel(addressProvider, remoteHost, remotePort, localHost, localPort, elevateIfNeeded, privacy, protocol);\n\t}\n}\n"],
  "mappings": ";;;;;;;;;;;;AAKA,YAAY,SAAS;AACrB,YAAY,QAAQ;AACpB,SAAS,0BAA0B,0BAA0B;AAC7D,SAAS,kBAAkB;AAE3B,SAAS,eAAe;AACxB,SAAS,kBAAkB;AAC3B,SAAS,UAAU;AACnB,SAAS,eAAe;AACxB,SAAS,6BAA6B;AACtC,SAAS,mBAAmB;AAC5B,SAAS,uBAAuB;AAChC,SAAS,kBAAkB,oBAAoB,gCAAgC;AAC/E,SAAS,mCAAmC;AAC5C,SAAS,oBAAoB;AAC7B,SAAS,uBAAuB,uBAAuB,iBAAiB,gBAAgB,cAAc,iBAAiB,iBAAiB,aAAa,kBAAkB,wBAAwB;AAC/L,SAAS,gBAAgB;AAEzB,eAAe,mBAAmB,SAA6B,mBAA2B,kBAA0B,kBAA0B,iBAAiD;AAC9L,MAAI;AACJ,WAAS,WAAW,GAAG,UAAU,YAAY;AAC5C,iBAAa,QAAQ;AACrB,UAAM,SAAS,IAAI,iBAAiB,SAAS,mBAAmB,kBAAkB,kBAAkB,eAAe;AACnH,kBAAc,MAAM,OAAO,aAAa;AACxC,QAAK,mBAAmB,yBAAyB,eAAe,KAAM,CAAC,yBAAyB,YAAY,eAAe,GAAG;AAC7H;AAAA,IACD;AAAA,EACD;AACA,SAAO;AACR;AAXe;AAaR,MAAM,yBAAyB,WAAmC;AAAA,EAkBxE,YAAY,SAA8C,mBAA2B,kBAA0B,kBAA2C,oBAA6B;AACtL,UAAM;AADmD;AAAgG;AAEzJ,SAAK,WAAW;AAChB,SAAK,UAAU,IAAI,aAAa;AAChC,SAAK,WAAW,IAAI,QAAQ;AAE5B,SAAK,qBAAqB,MAAM,KAAK,SAAS,KAAK;AACnD,SAAK,QAAQ,GAAG,aAAa,KAAK,kBAAkB;AAEpD,SAAK,sBAAsB,CAAC,WAAW,KAAK,cAAc,MAAM;AAChE,SAAK,QAAQ,GAAG,cAAc,KAAK,mBAAmB;AAGtD,SAAK,iBAAiB,MAAM;AAAA,IAAE;AAC9B,SAAK,QAAQ,GAAG,SAAS,KAAK,cAAc;AAE5C,SAAK,mBAAmB;AACxB,SAAK,mBAAmB;AAAA,EACzB;AAAA,EAxED,OAoCyE;AAAA;AAAA;AAAA,EAExD;AAAA,EACT;AAAA,EACA;AAAA,EACA;AAAA,EACS,UAAU,gBAAgB;AAAA,EAEzB;AAAA,EACA;AAAA,EACA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EAEA,kBAA2C,oBAAI,IAAI;AAAA,EAsBpE,MAAsB,UAAyB;AAC9C,UAAM,QAAQ;AACd,SAAK,QAAQ,eAAe,aAAa,KAAK,kBAAkB;AAChE,SAAK,QAAQ,eAAe,cAAc,KAAK,mBAAmB;AAClE,SAAK,QAAQ,eAAe,SAAS,KAAK,cAAc;AACxD,SAAK,QAAQ,MAAM;AACnB,UAAM,YAAY,MAAM,KAAK,KAAK,gBAAgB,OAAO,CAAC;AAC1D,cAAU,QAAQ,cAAY;AAC7B,eAAS;AAAA,IACV,CAAC;AAAA,EACF;AAAA,EAEA,MAAa,eAA8B;AAC1C,UAAM,YAAY,KAAK,sBAAsB,KAAK;AAClD,UAAM,WAAW,gBAAgB,KAAK,iBAAiB,IAAI,YAAY;AAEvE,QAAI,YAAY,MAAM,mBAAmB,WAAW,GAAG,KAAM,QAAQ;AAGrE,QAAI,UAA2C;AAC/C,SAAK,QAAQ,OAAO,WAAW,KAAK,iBAAiB;AACrD,UAAM,KAAK,SAAS,KAAK;AACzB,cAA2B,KAAK,QAAQ,QAAQ;AAGhD,QAAI,CAAC,SAAS;AACb,kBAAY;AACZ,WAAK,QAAQ,OAAO,WAAW,KAAK,iBAAiB;AACrD,YAAM,KAAK,SAAS,KAAK;AACzB,gBAA2B,KAAK,QAAQ,QAAQ;AAAA,IACjD;AAEA,SAAK,kBAAkB,QAAQ;AAC/B,SAAK,eAAe,GAAG,KAAK,qBAAqB,cAAc,cAAc,WAAW,IAAI,QAAQ,IAAI;AACxG,WAAO;AAAA,EACR;AAAA,EAEA,MAAc,cAAc,aAAwC;AAEnE,gBAAY,MAAM;AAElB,UAAM,mBAAoB,YAAY,KAAK,gBAAgB,KAAK,gBAAgB,KAAK,gBAAgB,IAAK,cAAc,KAAK;AAC7H,UAAM,WAAW,MAAM,yBAAyB,KAAK,UAAU,kBAAkB,KAAK,gBAAgB;AACtG,UAAM,eAAe,SAAS,UAAU;AACxC,UAAM,YAAY,SAAS,iBAAiB;AAC5C,aAAS,QAAQ;AAEjB,QAAI,UAAU,aAAa,GAAG;AAC7B,kBAAY,MAAM,UAAU,MAAM;AAAA,IACnC;AAEA,gBAAY,GAAG,OAAO,MAAM;AAC3B,UAAI,YAAY,cAAc;AAC7B,aAAK,gBAAgB,OAAO,YAAY,YAAY;AAAA,MACrD;AACA,mBAAa,IAAI;AAAA,IAClB,CAAC;AACD,gBAAY,GAAG,SAAS,MAAM,aAAa,IAAI,CAAC;AAChD,gBAAY,GAAG,SAAS,MAAM;AAC7B,UAAI,YAAY,cAAc;AAC7B,aAAK,gBAAgB,OAAO,YAAY,YAAY;AAAA,MACrD;AACA,UAAI,wBAAwB,YAAY;AACvC,qBAAa,OAAO,QAAQ;AAAA,MAC7B,OAAO;AACN,qBAAa,IAAI;AAAA,MAClB;AAAA,IACD,CAAC;AAED,QAAI,wBAAwB,YAAY;AACvC,WAAK,kBAAkB,aAAa,YAAY;AAAA,IACjD,OAAO;AACN,WAAK,qBAAqB,aAAa,YAAY;AAAA,IACpD;AAEA,QAAI,YAAY,cAAc;AAC7B,WAAK,gBAAgB,IAAI,YAAY,cAAc,MAAM;AAExD,oBAAY,IAAI;AAChB,qBAAa,IAAI;AAAA,MAClB,CAAC;AAAA,IACF;AAAA,EACD;AAAA,EAEQ,qBAAqB,aAAyB,cAAuB;AAC5E,iBAAa,QAAQ,MAAM,YAAY,QAAQ,CAAC;AAChD,iBAAa,MAAM,MAAM,YAAY,IAAI,CAAC;AAC1C,iBAAa,OAAO,OAAK,YAAY,MAAM,EAAE,MAAM,CAAC;AACpD,gBAAY,GAAG,QAAQ,OAAK,aAAa,MAAM,SAAS,KAAK,CAAC,CAAC,CAAC;AAChE,gBAAY,OAAO;AAAA,EACpB;AAAA,EAEQ,kBAAkB,aAAyB,kBAA8B;AAChF,UAAM,eAAe,iBAAiB;AACtC,iBAAa,GAAG,OAAO,MAAM,YAAY,IAAI,CAAC;AAC9C,iBAAa,GAAG,SAAS,MAAM,YAAY,IAAI,CAAC;AAChD,iBAAa,GAAG,SAAS,MAAM;AAC9B,kBAAY,QAAQ;AAAA,IACrB,CAAC;AAED,iBAAa,KAAK,WAAW;AAC7B,gBAAY,KAAK,YAAY;AAAA,EAC9B;AACD;AAEO,IAAM,oBAAN,cAAgC,sBAAsB;AAAA,EACrD,YACwC,4BACjC,YACkB,aACG,gBACX,sBACtB;AACD,UAAM,YAAY,oBAAoB;AANQ;AAEf;AACG;AAAA,EAInC;AAAA,EA5LD,OAmL6D;AAAA;AAAA;AAAA,EAWrD,iBAAiB,MAAuB;AAC9C,WAAO,iBAAiB,MAAM,KAAK,mBAAmB,IAAI,GAAG,QAAQ,CAAC;AAAA,EACvE;AAAA,EAEU,qBAAqB,yBAA6D,YAAoB,YAAoB,WAAmB,WAA+B,iBAA0B,SAAkB,UAA2E;AAC5S,UAAM,WAAW,KAAK,iBAAiB,YAAY,UAAU;AAC7D,QAAI,UAAU;AACb,QAAE,SAAS;AACX,aAAO,SAAS;AAAA,IACjB;AAEA,QAAI,iBAAiB,uBAAuB,GAAG;AAC9C,aAAO,KAAK,mBAAmB,yBAAyB,YAAY,YAAY,WAAW,iBAAiB,SAAS,QAAQ;AAAA,IAC9H,OAAO;AACN,WAAK,WAAW,MAAM,oEAAoE,UAAU,IAAI,UAAU,kBAAkB,SAAS,GAAG;AAChJ,YAAM,UAA8B;AAAA,QACnC,QAAQ,KAAK,eAAe;AAAA,QAC5B,SAAS,KAAK,eAAe;AAAA,QAC7B,iBAAiB;AAAA,QACjB,4BAA4B,KAAK;AAAA,QACjC,aAAa,KAAK;AAAA,QAClB,YAAY,KAAK;AAAA,QACjB,WAAW;AAAA,MACZ;AAEA,YAAM,SAAS,mBAAmB,SAAS,WAAW,YAAY,YAAY,SAAS;AACvF,WAAK,WAAW,MAAM,kEAAkE;AACxF,WAAK,eAAe,YAAY,YAAY,MAAM;AAClD,aAAO;AAAA,IACR;AAAA,EACD;AACD;AA1Ca,oBAAN;AAAA,EAEJ;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,GANU;AA4CN,IAAM,gBAAN,cAA4B,kBAAkB;AAAA,EA/NrD,OA+NqD;AAAA;AAAA;AAAA,EAC7C,YACuB,4BAChB,YACC,aACG,gBACM,sBACtB;AACD,UAAM,4BAA4B,YAAY,aAAa,gBAAgB,oBAAoB;AAAA,EAChG;AACD;AAVa,gBAAN;AAAA,EAEJ;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,GANU;AAYN,IAAM,uBAAN,cAAmC,WAA4C;AAAA,EAI9E,YAC0C,4BAChB,YACE,gBACH,aACS,sBACvC;AACD,UAAM;AAN0C;AAChB;AACE;AACH;AACS;AAAA,EAGzC;AAAA,EAvPD,OA2OsF;AAAA;AAAA;AAAA,EAEpE,kBAA+C,oBAAI,IAAI;AAAA,EAYxE,MAAM,WAAW,WAAmB,iBAA+C,YAAgC,YAAoB,WAAmB,WAAoB,iBAA2B,SAAkB,UAA+D;AACzR,SAAK,WAAW,MAAM,gEAAgE,UAAU,IAAI,UAAU,kBAAkB,SAAS,GAAG;AAC5I,QAAI,CAAC,KAAK,gBAAgB,IAAI,SAAS,GAAG;AACzC,YAAM,gBAAgB,IAAI,cAAc,KAAK,4BAA4B,KAAK,YAAY,KAAK,aAAa,KAAK,gBAAgB,KAAK,oBAAoB;AAC1J,WAAK,UAAU,aAAa;AAC5B,WAAK,gBAAgB,IAAI,WAAW,aAAa;AACjD,oBAAc,eAAe,YAAY;AACxC,aAAK,MAAM,cAAc,SAAS,WAAW,GAAG;AAC/C,wBAAc,QAAQ;AACtB,eAAK,gBAAgB,OAAO,SAAS;AAAA,QACtC;AAAA,MACD,CAAC;AAAA,IACF;AACA,WAAO,KAAK,gBAAgB,IAAI,SAAS,EAAG,WAAW,iBAAiB,YAAY,YAAY,WAAW,WAAW,iBAAiB,SAAS,QAAQ;AAAA,EACzJ;AACD;AA7Ba,uBAAN;AAAA,EAKJ;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,GATU;",
  "names": []
}
