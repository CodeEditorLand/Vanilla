var g=Object.defineProperty;var v=Object.getOwnPropertyDescriptor;var h=(e,n,t,o)=>{for(var r=o>1?void 0:o?v(n,t):n,i=e.length-1,a;i>=0;i--)(a=e[i])&&(r=(o?a(n,t,r):a(r))||r);return o&&r&&g(n,t,r),r},l=(e,n)=>(t,o)=>n(t,o,e);import{parse as p}from"url";import{Promises as R}from"../../../base/common/async.js";import{streamToBufferReadableStream as S}from"../../../base/common/buffer.js";import{CancellationError as y,getErrorMessage as q}from"../../../base/common/errors.js";import{isBoolean as w,isNumber as C}from"../../../base/common/types.js";import{IConfigurationService as I}from"../../configuration/common/configuration.js";import{INativeEnvironmentService as x}from"../../environment/common/environment.js";import{getResolvedShellEnv as b}from"../../shell/node/shellEnv.js";import{ILogService as A}from"../../log/common/log.js";import{AbstractRequestService as L}from"../common/request.js";import{getProxyAgent as P}from"./proxy.js";import{createGunzip as z}from"zlib";let m=class extends L{constructor(t,o,r){super(r);this.configurationService=t;this.environmentService=o;this.configure(),this._register(t.onDidChangeConfiguration(i=>{i.affectsConfiguration("http")&&this.configure()}))}proxyUrl;strictSSL;authorization;shellEnvErrorLogged;configure(){const t=this.configurationService.getValue("http");this.proxyUrl=t?.proxy,this.strictSSL=!!t?.proxyStrictSSL,this.authorization=t?.proxyAuthorization}async request(t,o){const{proxyUrl:r,strictSSL:i}=this;let a;try{a=await b(this.configurationService,this.logService,this.environmentService.args,process.env)}catch(c){this.shellEnvErrorLogged||(this.shellEnvErrorLogged=!0,this.logService.error("resolving shell environment failed",q(c)))}const u={...process.env,...a},s=t.agent?t.agent:await P(t.url||"",u,{proxyUrl:r,strictSSL:i});return t.agent=s,t.strictSSL=i,this.authorization&&(t.headers={...t.headers||{},"Proxy-Authorization":this.authorization}),this.logAndRequest(t,()=>f(t,o))}async resolveProxy(t){}async lookupAuthorization(t){}async lookupKerberosAuthorization(t){try{const o=await import("kerberos"),r=new URL(t),i=this.configurationService.getValue("http.proxyKerberosServicePrincipal")||(process.platform==="win32"?`HTTP/${r.hostname}`:`HTTP@${r.hostname}`);return this.logService.debug("RequestService#lookupKerberosAuthorization Kerberos authentication lookup",`proxyURL:${r}`,`spn:${i}`),"Negotiate "+await(await o.initializeClient(i)).step("")}catch(o){this.logService.debug("RequestService#lookupKerberosAuthorization Kerberos authentication failed",o);return}}async loadCertificates(){return(await import("@vscode/proxy-agent")).loadSystemCertificates({log:this.logService})}};m=h([l(0,I),l(1,x),l(2,A)],m);async function E(e){return(p(e.url).protocol==="https:"?await import("https"):await import("http")).request}async function f(e,n){return R.withAsyncBody(async(t,o)=>{const r=p(e.url),i=e.getRawRequest?e.getRawRequest(e):await E(e),a={hostname:r.hostname,port:r.port?parseInt(r.port):r.protocol==="https:"?443:80,protocol:r.protocol,path:r.path,method:e.type||"GET",headers:e.headers,agent:e.agent,rejectUnauthorized:w(e.strictSSL)?e.strictSSL:!0};e.user&&e.password&&(a.auth=e.user+":"+e.password);const u=i(a,s=>{const c=C(e.followRedirects)?e.followRedirects:3;if(s.statusCode&&s.statusCode>=300&&s.statusCode<400&&c>0&&s.headers.location)f({...e,url:s.headers.location,followRedirects:c-1},n).then(t,o);else{let d=s;!e.isChromiumNetwork&&s.headers["content-encoding"]==="gzip"&&(d=s.pipe(z())),t({res:s,stream:S(d)})}});u.on("error",o),e.timeout&&u.setTimeout(e.timeout),e.isChromiumNetwork&&u.removeHeader("Content-Length"),e.data&&typeof e.data=="string"&&u.write(e.data),u.end(),n.onCancellationRequested(()=>{u.abort(),o(new y)})})}export{m as RequestService,f as nodeRequest};
