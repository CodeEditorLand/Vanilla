var f=Object.defineProperty;var v=Object.getOwnPropertyDescriptor;var h=(e,n,t,o)=>{for(var r=o>1?void 0:o?v(n,t):n,i=e.length-1,a;i>=0;i--)(a=e[i])&&(r=(o?a(n,t,r):a(r))||r);return o&&r&&f(n,t,r),r},l=(e,n)=>(t,o)=>n(t,o,e);import{parse as d}from"url";import{createGunzip as y}from"zlib";import{Promises as R}from"../../../base/common/async.js";import{streamToBufferReadableStream as S}from"../../../base/common/buffer.js";import{CancellationError as q,getErrorMessage as w}from"../../../base/common/errors.js";import{isBoolean as C,isNumber as I}from"../../../base/common/types.js";import{IConfigurationService as x}from"../../configuration/common/configuration.js";import{INativeEnvironmentService as b}from"../../environment/common/environment.js";import{ILogService as A}from"../../log/common/log.js";import{getResolvedShellEnv as L}from"../../shell/node/shellEnv.js";import{AbstractRequestService as P}from"../common/request.js";import{getProxyAgent as z}from"./proxy.js";let p=class extends P{constructor(t,o,r){super(r);this.configurationService=t;this.environmentService=o;this.configure(),this._register(t.onDidChangeConfiguration(i=>{i.affectsConfiguration("http")&&this.configure()}))}proxyUrl;strictSSL;authorization;shellEnvErrorLogged;configure(){const t=this.configurationService.getValue("http");this.proxyUrl=t?.proxy,this.strictSSL=!!t?.proxyStrictSSL,this.authorization=t?.proxyAuthorization}async request(t,o){const{proxyUrl:r,strictSSL:i}=this;let a;try{a=await L(this.configurationService,this.logService,this.environmentService.args,process.env)}catch(c){this.shellEnvErrorLogged||(this.shellEnvErrorLogged=!0,this.logService.error("resolving shell environment failed",w(c)))}const u={...process.env,...a},s=t.agent?t.agent:await z(t.url||"",u,{proxyUrl:r,strictSSL:i});return t.agent=s,t.strictSSL=i,this.authorization&&(t.headers={...t.headers||{},"Proxy-Authorization":this.authorization}),this.logAndRequest(t,()=>g(t,o))}async resolveProxy(t){}async lookupAuthorization(t){}async lookupKerberosAuthorization(t){try{const o=await import("kerberos"),r=new URL(t),i=this.configurationService.getValue("http.proxyKerberosServicePrincipal")||(process.platform==="win32"?`HTTP/${r.hostname}`:`HTTP@${r.hostname}`);return this.logService.debug("RequestService#lookupKerberosAuthorization Kerberos authentication lookup",`proxyURL:${r}`,`spn:${i}`),"Negotiate "+await(await o.initializeClient(i)).step("")}catch(o){this.logService.debug("RequestService#lookupKerberosAuthorization Kerberos authentication failed",o);return}}async loadCertificates(){return(await import("@vscode/proxy-agent")).loadSystemCertificates({log:this.logService})}};p=h([l(0,x),l(1,b),l(2,A)],p);async function E(e){return(d(e.url).protocol==="https:"?await import("https"):await import("http")).request}async function g(e,n){return R.withAsyncBody(async(t,o)=>{const r=d(e.url),i=e.getRawRequest?e.getRawRequest(e):await E(e),a={hostname:r.hostname,port:r.port?Number.parseInt(r.port):r.protocol==="https:"?443:80,protocol:r.protocol,path:r.path,method:e.type||"GET",headers:e.headers,agent:e.agent,rejectUnauthorized:C(e.strictSSL)?e.strictSSL:!0};e.user&&e.password&&(a.auth=e.user+":"+e.password);const u=i(a,s=>{const c=I(e.followRedirects)?e.followRedirects:3;if(s.statusCode&&s.statusCode>=300&&s.statusCode<400&&c>0&&s.headers.location)g({...e,url:s.headers.location,followRedirects:c-1},n).then(t,o);else{let m=s;!e.isChromiumNetwork&&s.headers["content-encoding"]==="gzip"&&(m=s.pipe(y())),t({res:s,stream:S(m)})}});u.on("error",o),e.timeout&&u.setTimeout(e.timeout),e.isChromiumNetwork&&u.removeHeader("Content-Length"),e.data&&typeof e.data=="string"&&u.write(e.data),u.end(),n.onCancellationRequested(()=>{u.abort(),o(new q)})})}export{p as RequestService,g as nodeRequest};
