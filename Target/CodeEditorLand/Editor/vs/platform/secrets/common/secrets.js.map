{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/secrets/common/secrets.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { SequencerByKey } from '../../../base/common/async.js';\nimport { IEncryptionService } from '../../encryption/common/encryptionService.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { IStorageService, InMemoryStorageService, StorageScope, StorageTarget } from '../../storage/common/storage.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { Disposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport { Lazy } from '../../../base/common/lazy.js';\n\nexport const ISecretStorageService = createDecorator<ISecretStorageService>('secretStorageService');\n\nexport interface ISecretStorageProvider {\n\ttype: 'in-memory' | 'persisted' | 'unknown';\n\tget(key: string): Promise<string | undefined>;\n\tset(key: string, value: string): Promise<void>;\n\tdelete(key: string): Promise<void>;\n}\n\nexport interface ISecretStorageService extends ISecretStorageProvider {\n\treadonly _serviceBrand: undefined;\n\tonDidChangeSecret: Event<string>;\n}\n\nexport class BaseSecretStorageService extends Disposable implements ISecretStorageService {\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly _storagePrefix = 'secret://';\n\n\tprotected readonly onDidChangeSecretEmitter = this._register(new Emitter<string>());\n\tonDidChangeSecret: Event<string> = this.onDidChangeSecretEmitter.event;\n\n\tprotected readonly _sequencer = new SequencerByKey<string>();\n\n\tprivate _type: 'in-memory' | 'persisted' | 'unknown' = 'unknown';\n\n\tprivate readonly _onDidChangeValueDisposable = this._register(new DisposableStore());\n\n\tconstructor(\n\t\tprivate readonly _useInMemoryStorage: boolean,\n\t\t@IStorageService private _storageService: IStorageService,\n\t\t@IEncryptionService protected _encryptionService: IEncryptionService,\n\t\t@ILogService protected readonly _logService: ILogService,\n\t) {\n\t\tsuper();\n\t}\n\n\t/**\n\t * @Note initialize must be called first so that this can be resolved properly\n\t * otherwise it will return 'unknown'.\n\t */\n\tget type() {\n\t\treturn this._type;\n\t}\n\n\tprivate _lazyStorageService: Lazy<Promise<IStorageService>> = new Lazy(() => this.initialize());\n\tprotected get resolvedStorageService() {\n\t\treturn this._lazyStorageService.value;\n\t}\n\n\tget(key: string): Promise<string | undefined> {\n\t\treturn this._sequencer.queue(key, async () => {\n\t\t\tconst storageService = await this.resolvedStorageService;\n\n\t\t\tconst fullKey = this.getKey(key);\n\t\t\tthis._logService.trace('[secrets] getting secret for key:', fullKey);\n\t\t\tconst encrypted = storageService.get(fullKey, StorageScope.APPLICATION);\n\t\t\tif (!encrypted) {\n\t\t\t\tthis._logService.trace('[secrets] no secret found for key:', fullKey);\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tthis._logService.trace('[secrets] decrypting gotten secret for key:', fullKey);\n\t\t\t\t// If the storage service is in-memory, we don't need to decrypt\n\t\t\t\tconst result = this._type === 'in-memory'\n\t\t\t\t\t? encrypted\n\t\t\t\t\t: await this._encryptionService.decrypt(encrypted);\n\t\t\t\tthis._logService.trace('[secrets] decrypted secret for key:', fullKey);\n\t\t\t\treturn result;\n\t\t\t} catch (e) {\n\t\t\t\tthis._logService.error(e);\n\t\t\t\tthis.delete(key);\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t});\n\t}\n\n\tset(key: string, value: string): Promise<void> {\n\t\treturn this._sequencer.queue(key, async () => {\n\t\t\tconst storageService = await this.resolvedStorageService;\n\n\t\t\tthis._logService.trace('[secrets] encrypting secret for key:', key);\n\t\t\tlet encrypted;\n\t\t\ttry {\n\t\t\t\t// If the storage service is in-memory, we don't need to encrypt\n\t\t\t\tencrypted = this._type === 'in-memory'\n\t\t\t\t\t? value\n\t\t\t\t\t: await this._encryptionService.encrypt(value);\n\t\t\t} catch (e) {\n\t\t\t\tthis._logService.error(e);\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\tconst fullKey = this.getKey(key);\n\t\t\tthis._logService.trace('[secrets] storing encrypted secret for key:', fullKey);\n\t\t\tstorageService.store(fullKey, encrypted, StorageScope.APPLICATION, StorageTarget.MACHINE);\n\t\t\tthis._logService.trace('[secrets] stored encrypted secret for key:', fullKey);\n\t\t});\n\t}\n\n\tdelete(key: string): Promise<void> {\n\t\treturn this._sequencer.queue(key, async () => {\n\t\t\tconst storageService = await this.resolvedStorageService;\n\n\t\t\tconst fullKey = this.getKey(key);\n\t\t\tthis._logService.trace('[secrets] deleting secret for key:', fullKey);\n\t\t\tstorageService.remove(fullKey, StorageScope.APPLICATION);\n\t\t\tthis._logService.trace('[secrets] deleted secret for key:', fullKey);\n\t\t});\n\t}\n\n\tprivate async initialize(): Promise<IStorageService> {\n\t\tlet storageService;\n\t\tif (!this._useInMemoryStorage && await this._encryptionService.isEncryptionAvailable()) {\n\t\t\tthis._logService.trace(`[SecretStorageService] Encryption is available, using persisted storage`);\n\t\t\tthis._type = 'persisted';\n\t\t\tstorageService = this._storageService;\n\t\t} else {\n\t\t\t// If we already have an in-memory storage service, we don't need to recreate it\n\t\t\tif (this._type === 'in-memory') {\n\t\t\t\treturn this._storageService;\n\t\t\t}\n\t\t\tthis._logService.trace('[SecretStorageService] Encryption is not available, falling back to in-memory storage');\n\t\t\tthis._type = 'in-memory';\n\t\t\tstorageService = this._register(new InMemoryStorageService());\n\t\t}\n\n\t\tthis._onDidChangeValueDisposable.clear();\n\t\tthis._onDidChangeValueDisposable.add(storageService.onDidChangeValue(StorageScope.APPLICATION, undefined, this._onDidChangeValueDisposable)(e => {\n\t\t\tthis.onDidChangeValue(e.key);\n\t\t}));\n\t\treturn storageService;\n\t}\n\n\tprotected reinitialize(): void {\n\t\tthis._lazyStorageService = new Lazy(() => this.initialize());\n\t}\n\n\tprivate onDidChangeValue(key: string): void {\n\t\tif (!key.startsWith(this._storagePrefix)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst secretKey = key.slice(this._storagePrefix.length);\n\n\t\tthis._logService.trace(`[SecretStorageService] Notifying change in value for secret: ${secretKey}`);\n\t\tthis.onDidChangeSecretEmitter.fire(secretKey);\n\t}\n\n\tprivate getKey(key: string): string {\n\t\treturn `${this._storagePrefix}${key}`;\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
