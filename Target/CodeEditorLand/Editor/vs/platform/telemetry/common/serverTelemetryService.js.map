{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/telemetry/common/serverTelemetryService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IConfigurationService } from \"../../configuration/common/configuration.js\";\nimport { refineServiceDecorator } from \"../../instantiation/common/instantiation.js\";\nimport { IProductService } from \"../../product/common/productService.js\";\nimport type {\n\tClassifiedEvent,\n\tIGDPRProperty,\n\tOmitMetadata,\n\tStrictPropertyCheck,\n} from \"./gdprTypings.js\";\nimport {\n\ttype ITelemetryData,\n\tITelemetryService,\n\tTelemetryLevel,\n} from \"./telemetry.js\";\nimport {\n\ttype ITelemetryServiceConfig,\n\tTelemetryService,\n} from \"./telemetryService.js\";\nimport { NullTelemetryServiceShape } from \"./telemetryUtils.js\";\n\nexport interface IServerTelemetryService extends ITelemetryService {\n\tupdateInjectedTelemetryLevel(telemetryLevel: TelemetryLevel): Promise<void>;\n}\n\nexport class ServerTelemetryService\n\textends TelemetryService\n\timplements IServerTelemetryService\n{\n\t// Because we cannot read the workspace config on the remote site\n\t// the ServerTelemetryService is responsible for knowing its telemetry level\n\t// this is done through IPC calls and initial value injections\n\tprivate _injectedTelemetryLevel: TelemetryLevel;\n\tconstructor(\n\t\tconfig: ITelemetryServiceConfig,\n\t\tinjectedTelemetryLevel: TelemetryLevel,\n\t\t@IConfigurationService _configurationService: IConfigurationService,\n\t\t@IProductService _productService: IProductService,\n\t) {\n\t\tsuper(config, _configurationService, _productService);\n\t\tthis._injectedTelemetryLevel = injectedTelemetryLevel;\n\t}\n\n\toverride publicLog(eventName: string, data?: ITelemetryData) {\n\t\tif (this._injectedTelemetryLevel < TelemetryLevel.USAGE) {\n\t\t\treturn;\n\t\t}\n\t\treturn super.publicLog(eventName, data);\n\t}\n\n\toverride publicLog2<\n\t\tE extends ClassifiedEvent<OmitMetadata<T>> = never,\n\t\tT extends IGDPRProperty = never,\n\t>(eventName: string, data?: StrictPropertyCheck<T, E>) {\n\t\treturn this.publicLog(eventName, data as ITelemetryData | undefined);\n\t}\n\n\toverride publicLogError(errorEventName: string, data?: ITelemetryData) {\n\t\tif (this._injectedTelemetryLevel < TelemetryLevel.ERROR) {\n\t\t\treturn Promise.resolve(undefined);\n\t\t}\n\t\treturn super.publicLogError(errorEventName, data);\n\t}\n\n\toverride publicLogError2<\n\t\tE extends ClassifiedEvent<OmitMetadata<T>> = never,\n\t\tT extends IGDPRProperty = never,\n\t>(eventName: string, data?: StrictPropertyCheck<T, E>) {\n\t\treturn this.publicLogError(\n\t\t\teventName,\n\t\t\tdata as ITelemetryData | undefined,\n\t\t);\n\t}\n\n\tasync updateInjectedTelemetryLevel(\n\t\ttelemetryLevel: TelemetryLevel,\n\t): Promise<void> {\n\t\tif (telemetryLevel === undefined) {\n\t\t\tthis._injectedTelemetryLevel = TelemetryLevel.NONE;\n\t\t\tthrow new Error(\n\t\t\t\t\"Telemetry level cannot be undefined. This will cause infinite looping!\",\n\t\t\t);\n\t\t}\n\t\t// We always take the most restrictive level because we don't want multiple clients to connect and send data when one client does not consent\n\t\tthis._injectedTelemetryLevel = this._injectedTelemetryLevel\n\t\t\t? Math.min(this._injectedTelemetryLevel, telemetryLevel)\n\t\t\t: telemetryLevel;\n\t\tif (this._injectedTelemetryLevel === TelemetryLevel.NONE) {\n\t\t\tthis.dispose();\n\t\t}\n\t}\n}\n\nexport const ServerNullTelemetryService = new (class\n\textends NullTelemetryServiceShape\n\timplements IServerTelemetryService\n{\n\tasync updateInjectedTelemetryLevel(): Promise<void> {\n\t\treturn;\n\t} // No-op, telemetry is already disabled\n})();\n\nexport const IServerTelemetryService = refineServiceDecorator<\n\tITelemetryService,\n\tIServerTelemetryService\n>(ITelemetryService);\n"],
  "mappings": ";;;;;;;;;;;;AAKA,SAAS,6BAA6B;AACtC,SAAS,8BAA8B;AACvC,SAAS,uBAAuB;AAOhC;AAAA,EAEC;AAAA,EACA;AAAA,OACM;AACP;AAAA,EAEC;AAAA,OACM;AACP,SAAS,iCAAiC;AAMnC,IAAM,yBAAN,cACE,iBAET;AAAA,EAhCA,OAgCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAIS;AAAA,EACR,YACC,QACA,wBACuB,uBACN,iBAChB;AACD,UAAM,QAAQ,uBAAuB,eAAe;AACpD,SAAK,0BAA0B;AAAA,EAChC;AAAA,EAES,UAAU,WAAmB,MAAuB;AAC5D,QAAI,KAAK,0BAA0B,eAAe,OAAO;AACxD;AAAA,IACD;AACA,WAAO,MAAM,UAAU,WAAW,IAAI;AAAA,EACvC;AAAA,EAES,WAGP,WAAmB,MAAkC;AACtD,WAAO,KAAK,UAAU,WAAW,IAAkC;AAAA,EACpE;AAAA,EAES,eAAe,gBAAwB,MAAuB;AACtE,QAAI,KAAK,0BAA0B,eAAe,OAAO;AACxD,aAAO,QAAQ,QAAQ,MAAS;AAAA,IACjC;AACA,WAAO,MAAM,eAAe,gBAAgB,IAAI;AAAA,EACjD;AAAA,EAES,gBAGP,WAAmB,MAAkC;AACtD,WAAO,KAAK;AAAA,MACX;AAAA,MACA;AAAA,IACD;AAAA,EACD;AAAA,EAEA,MAAM,6BACL,gBACgB;AAChB,QAAI,mBAAmB,QAAW;AACjC,WAAK,0BAA0B,eAAe;AAC9C,YAAM,IAAI;AAAA,QACT;AAAA,MACD;AAAA,IACD;AAEA,SAAK,0BAA0B,KAAK,0BACjC,KAAK,IAAI,KAAK,yBAAyB,cAAc,IACrD;AACH,QAAI,KAAK,4BAA4B,eAAe,MAAM;AACzD,WAAK,QAAQ;AAAA,IACd;AAAA,EACD;AACD;AAlEa,yBAAN;AAAA,EAWJ;AAAA,EACA;AAAA,GAZU;AAoEN,MAAM,6BAA6B,IAAK,cACtC,0BAET;AAAA,EACC,MAAM,+BAA8C;AACnD;AAAA,EACD;AAAA;AACD,EAAG;AAEI,MAAM,0BAA0B,uBAGrC,iBAAiB;",
  "names": []
}
