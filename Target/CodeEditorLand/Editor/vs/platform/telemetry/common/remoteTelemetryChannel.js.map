{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/telemetry/common/remoteTelemetryChannel.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { IServerChannel } from '../../../base/parts/ipc/common/ipc.js';\nimport { TelemetryLevel } from './telemetry.js';\nimport { ITelemetryAppender } from './telemetryUtils.js';\nimport { IServerTelemetryService } from './serverTelemetryService.js';\n\nexport class ServerTelemetryChannel extends Disposable implements IServerChannel {\n\tconstructor(\n\t\tprivate readonly telemetryService: IServerTelemetryService,\n\t\tprivate readonly telemetryAppender: ITelemetryAppender | null\n\t) {\n\t\tsuper();\n\t}\n\n\n\tasync call(_: any, command: string, arg?: any): Promise<any> {\n\t\tswitch (command) {\n\t\t\tcase 'updateTelemetryLevel': {\n\t\t\t\tconst { telemetryLevel } = arg;\n\t\t\t\treturn this.telemetryService.updateInjectedTelemetryLevel(telemetryLevel);\n\t\t\t}\n\n\t\t\tcase 'logTelemetry': {\n\t\t\t\tconst { eventName, data } = arg;\n\t\t\t\t// Logging is done directly to the appender instead of through the telemetry service\n\t\t\t\t// as the data sent from the client has already had common properties added to it and\n\t\t\t\t// has already been sent to the telemetry output channel\n\t\t\t\tif (this.telemetryAppender) {\n\t\t\t\t\treturn this.telemetryAppender.log(eventName, data);\n\t\t\t\t}\n\n\t\t\t\treturn Promise.resolve();\n\t\t\t}\n\n\t\t\tcase 'flushTelemetry': {\n\t\t\t\tif (this.telemetryAppender) {\n\t\t\t\t\treturn this.telemetryAppender.flush();\n\t\t\t\t}\n\n\t\t\t\treturn Promise.resolve();\n\t\t\t}\n\n\t\t\tcase 'ping': {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t// Command we cannot handle so we throw an error\n\t\tthrow new Error(`IPC Command ${command} not found`);\n\t}\n\n\tlisten(_: any, event: string, arg: any): Event<any> {\n\t\tthrow new Error('Not supported');\n\t}\n\n\t/**\n\t * Disposing the channel also disables the telemetryService as there is\n\t * no longer a way to control it\n\t */\n\tpublic override dispose(): void {\n\t\tthis.telemetryService.updateInjectedTelemetryLevel(TelemetryLevel.NONE);\n\t\tsuper.dispose();\n\t}\n}\n"],
  "mappings": ";;AAKA,SAAS,aAAa;AACtB,SAAS,kBAAkB;AAC3B,SAAS,sBAAsB;AAC/B,SAAS,sBAAsB;AAC/B,SAAS,0BAA0B;AACnC,SAAS,+BAA+B;AAEjC,MAAM,+BAA+B,WAAqC;AAAA,EAChF,YACkB,kBACA,mBAChB;AACD,UAAM;AAHW;AACA;AAAA,EAGlB;AAAA,EAlBD,OAYiF;AAAA;AAAA;AAAA,EAShF,MAAM,KAAK,GAAQ,SAAiB,KAAyB;AAC5D,YAAQ,SAAS;AAAA,MAChB,KAAK,wBAAwB;AAC5B,cAAM,EAAE,eAAe,IAAI;AAC3B,eAAO,KAAK,iBAAiB,6BAA6B,cAAc;AAAA,MACzE;AAAA,MAEA,KAAK,gBAAgB;AACpB,cAAM,EAAE,WAAW,KAAK,IAAI;AAI5B,YAAI,KAAK,mBAAmB;AAC3B,iBAAO,KAAK,kBAAkB,IAAI,WAAW,IAAI;AAAA,QAClD;AAEA,eAAO,QAAQ,QAAQ;AAAA,MACxB;AAAA,MAEA,KAAK,kBAAkB;AACtB,YAAI,KAAK,mBAAmB;AAC3B,iBAAO,KAAK,kBAAkB,MAAM;AAAA,QACrC;AAEA,eAAO,QAAQ,QAAQ;AAAA,MACxB;AAAA,MAEA,KAAK,QAAQ;AACZ;AAAA,MACD;AAAA,IACD;AAEA,UAAM,IAAI,MAAM,eAAe,OAAO,YAAY;AAAA,EACnD;AAAA,EAEA,OAAO,GAAQ,OAAe,KAAsB;AACnD,UAAM,IAAI,MAAM,eAAe;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMgB,UAAgB;AAC/B,SAAK,iBAAiB,6BAA6B,eAAe,IAAI;AACtE,UAAM,QAAQ;AAAA,EACf;AACD;",
  "names": []
}
