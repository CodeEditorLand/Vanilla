{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/telemetry/common/telemetryUtils.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { cloneAndChange, safeStringify } from '../../../base/common/objects.js';\nimport { isObject } from '../../../base/common/types.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { IEnvironmentService } from '../../environment/common/environment.js';\nimport { IProductService } from '../../product/common/productService.js';\nimport { getRemoteName } from '../../remote/common/remoteHosts.js';\nimport { verifyMicrosoftInternalDomain } from './commonProperties.js';\nimport { ICustomEndpointTelemetryService, ITelemetryData, ITelemetryEndpoint, ITelemetryService, TelemetryConfiguration, TelemetryLevel, TELEMETRY_CRASH_REPORTER_SETTING_ID, TELEMETRY_OLD_SETTING_ID, TELEMETRY_SETTING_ID } from './telemetry.js';\n\n/**\n * A special class used to denoting a telemetry value which should not be clean.\n * This is because that value is \"Trusted\" not to contain identifiable information such as paths.\n * NOTE: This is used as an API type as well, and should not be changed.\n */\nexport class TelemetryTrustedValue<T> {\n\t// This is merely used as an identifier as the instance will be lost during serialization over the exthost\n\tpublic readonly isTrustedTelemetryValue = true;\n\tconstructor(public readonly value: T) { }\n}\n\nexport class NullTelemetryServiceShape implements ITelemetryService {\n\tdeclare readonly _serviceBrand: undefined;\n\treadonly telemetryLevel = TelemetryLevel.NONE;\n\treadonly sessionId = 'someValue.sessionId';\n\treadonly machineId = 'someValue.machineId';\n\treadonly sqmId = 'someValue.sqmId';\n\treadonly devDeviceId = 'someValue.devDeviceId';\n\treadonly firstSessionDate = 'someValue.firstSessionDate';\n\treadonly sendErrorTelemetry = false;\n\tpublicLog() { }\n\tpublicLog2() { }\n\tpublicLogError() { }\n\tpublicLogError2() { }\n\tsetExperimentProperty() { }\n}\n\nexport const NullTelemetryService = new NullTelemetryServiceShape();\n\nexport class NullEndpointTelemetryService implements ICustomEndpointTelemetryService {\n\t_serviceBrand: undefined;\n\n\tasync publicLog(_endpoint: ITelemetryEndpoint, _eventName: string, _data?: ITelemetryData): Promise<void> {\n\t\t// noop\n\t}\n\n\tasync publicLogError(_endpoint: ITelemetryEndpoint, _errorEventName: string, _data?: ITelemetryData): Promise<void> {\n\t\t// noop\n\t}\n}\n\nexport const telemetryLogId = 'telemetry';\nexport const extensionTelemetryLogChannelId = 'extensionTelemetryLog';\n\nexport interface ITelemetryAppender {\n\tlog(eventName: string, data: any): void;\n\tflush(): Promise<any>;\n}\n\nexport const NullAppender: ITelemetryAppender = { log: () => null, flush: () => Promise.resolve(null) };\n\n\n/* __GDPR__FRAGMENT__\n\t\"URIDescriptor\" : {\n\t\t\"mimeType\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n\t\t\"scheme\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n\t\t\"ext\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n\t\t\"path\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n\t}\n*/\nexport interface URIDescriptor {\n\tmimeType?: string;\n\tscheme?: string;\n\text?: string;\n\tpath?: string;\n}\n\n/**\n * Determines whether or not we support logging telemetry.\n * This checks if the product is capable of collecting telemetry but not whether or not it can send it\n * For checking the user setting and what telemetry you can send please check `getTelemetryLevel`.\n * This returns true if `--disable-telemetry` wasn't used, the product.json allows for telemetry, and we're not testing an extension\n * If false telemetry is disabled throughout the product\n * @param productService\n * @param environmentService\n * @returns false - telemetry is completely disabled, true - telemetry is logged locally, but may not be sent\n */\nexport function supportsTelemetry(productService: IProductService, environmentService: IEnvironmentService): boolean {\n\t// If it's OSS and telemetry isn't disabled via the CLI we will allow it for logging only purposes\n\tif (!environmentService.isBuilt && !environmentService.disableTelemetry) {\n\t\treturn true;\n\t}\n\treturn !(environmentService.disableTelemetry || !productService.enableTelemetry);\n}\n\n/**\n * Checks to see if we're in logging only mode to debug telemetry.\n * This is if telemetry is enabled and we're in OSS, but no telemetry key is provided so it's not being sent just logged.\n * @param productService\n * @param environmentService\n * @returns True if telemetry is actually disabled and we're only logging for debug purposes\n */\nexport function isLoggingOnly(productService: IProductService, environmentService: IEnvironmentService): boolean {\n\t// If we're testing an extension, log telemetry for debug purposes\n\tif (environmentService.extensionTestsLocationURI) {\n\t\treturn true;\n\t}\n\t// Logging only mode is only for OSS\n\tif (environmentService.isBuilt) {\n\t\treturn false;\n\t}\n\n\tif (environmentService.disableTelemetry) {\n\t\treturn false;\n\t}\n\n\tif (productService.enableTelemetry && productService.aiConfig?.ariaKey) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/**\n * Determines how telemetry is handled based on the user's configuration.\n *\n * @param configurationService\n * @returns OFF, ERROR, ON\n */\nexport function getTelemetryLevel(configurationService: IConfigurationService): TelemetryLevel {\n\tconst newConfig = configurationService.getValue<TelemetryConfiguration>(TELEMETRY_SETTING_ID);\n\tconst crashReporterConfig = configurationService.getValue<boolean | undefined>(TELEMETRY_CRASH_REPORTER_SETTING_ID);\n\tconst oldConfig = configurationService.getValue<boolean | undefined>(TELEMETRY_OLD_SETTING_ID);\n\n\t// If `telemetry.enableCrashReporter` is false or `telemetry.enableTelemetry' is false, disable telemetry\n\tif (oldConfig === false || crashReporterConfig === false) {\n\t\treturn TelemetryLevel.NONE;\n\t}\n\n\t// Maps new telemetry setting to a telemetry level\n\tswitch (newConfig ?? TelemetryConfiguration.ON) {\n\t\tcase TelemetryConfiguration.ON:\n\t\t\treturn TelemetryLevel.USAGE;\n\t\tcase TelemetryConfiguration.ERROR:\n\t\t\treturn TelemetryLevel.ERROR;\n\t\tcase TelemetryConfiguration.CRASH:\n\t\t\treturn TelemetryLevel.CRASH;\n\t\tcase TelemetryConfiguration.OFF:\n\t\t\treturn TelemetryLevel.NONE;\n\t}\n}\n\nexport interface Properties {\n\t[key: string]: string;\n}\n\nexport interface Measurements {\n\t[key: string]: number;\n}\n\nexport function validateTelemetryData(data?: any): { properties: Properties; measurements: Measurements } {\n\n\tconst properties: Properties = {};\n\tconst measurements: Measurements = {};\n\n\tconst flat: Record<string, any> = {};\n\tflatten(data, flat);\n\n\tfor (let prop in flat) {\n\t\t// enforce property names less than 150 char, take the last 150 char\n\t\tprop = prop.length > 150 ? prop.substr(prop.length - 149) : prop;\n\t\tconst value = flat[prop];\n\n\t\tif (typeof value === 'number') {\n\t\t\tmeasurements[prop] = value;\n\n\t\t} else if (typeof value === 'boolean') {\n\t\t\tmeasurements[prop] = value ? 1 : 0;\n\n\t\t} else if (typeof value === 'string') {\n\t\t\tif (value.length > 8192) {\n\t\t\t\tconsole.warn(`Telemetry property: ${prop} has been trimmed to 8192, the original length is ${value.length}`);\n\t\t\t}\n\t\t\t//enforce property value to be less than 8192 char, take the first 8192 char\n\t\t\t// https://docs.microsoft.com/en-us/azure/azure-monitor/app/api-custom-events-metrics#limits\n\t\t\tproperties[prop] = value.substring(0, 8191);\n\n\t\t} else if (typeof value !== 'undefined' && value !== null) {\n\t\t\tproperties[prop] = value;\n\t\t}\n\t}\n\n\treturn {\n\t\tproperties,\n\t\tmeasurements\n\t};\n}\n\nconst telemetryAllowedAuthorities = new Set(['ssh-remote', 'dev-container', 'attached-container', 'wsl', 'tunnel', 'codespaces', 'amlext']);\n\nexport function cleanRemoteAuthority(remoteAuthority?: string): string {\n\tif (!remoteAuthority) {\n\t\treturn 'none';\n\t}\n\tconst remoteName = getRemoteName(remoteAuthority);\n\treturn telemetryAllowedAuthorities.has(remoteName) ? remoteName : 'other';\n}\n\nfunction flatten(obj: any, result: { [key: string]: any }, order: number = 0, prefix?: string): void {\n\tif (!obj) {\n\t\treturn;\n\t}\n\n\tfor (const item of Object.getOwnPropertyNames(obj)) {\n\t\tconst value = obj[item];\n\t\tconst index = prefix ? prefix + item : item;\n\n\t\tif (Array.isArray(value)) {\n\t\t\tresult[index] = safeStringify(value);\n\n\t\t} else if (value instanceof Date) {\n\t\t\t// TODO unsure why this is here and not in _getData\n\t\t\tresult[index] = value.toISOString();\n\n\t\t} else if (isObject(value)) {\n\t\t\tif (order < 2) {\n\t\t\t\tflatten(value, result, order + 1, index + '.');\n\t\t\t} else {\n\t\t\t\tresult[index] = safeStringify(value);\n\t\t\t}\n\t\t} else {\n\t\t\tresult[index] = value;\n\t\t}\n\t}\n}\n\n/**\n * Whether or not this is an internal user\n * @param productService The product service\n * @param configService The config servivce\n * @returns true if internal, false otherwise\n */\nexport function isInternalTelemetry(productService: IProductService, configService: IConfigurationService) {\n\tconst msftInternalDomains = productService.msftInternalDomains || [];\n\tconst internalTesting = configService.getValue<boolean>('telemetry.internalTesting');\n\treturn verifyMicrosoftInternalDomain(msftInternalDomains) || internalTesting;\n}\n\ninterface IPathEnvironment {\n\tappRoot: string;\n\textensionsPath: string;\n\tuserDataPath: string;\n\tuserHome: URI;\n\ttmpDir: URI;\n}\n\nexport function getPiiPathsFromEnvironment(paths: IPathEnvironment): string[] {\n\treturn [paths.appRoot, paths.extensionsPath, paths.userHome.fsPath, paths.tmpDir.fsPath, paths.userDataPath];\n}\n\n//#region Telemetry Cleaning\n\n/**\n * Cleans a given stack of possible paths\n * @param stack The stack to sanitize\n * @param cleanupPatterns Cleanup patterns to remove from the stack\n * @returns The cleaned stack\n */\nfunction anonymizeFilePaths(stack: string, cleanupPatterns: RegExp[]): string {\n\n\t// Fast check to see if it is a file path to avoid doing unnecessary heavy regex work\n\tif (!stack || (!stack.includes('/') && !stack.includes('\\\\'))) {\n\t\treturn stack;\n\t}\n\n\tlet updatedStack = stack;\n\n\tconst cleanUpIndexes: [number, number][] = [];\n\tfor (const regexp of cleanupPatterns) {\n\t\twhile (true) {\n\t\t\tconst result = regexp.exec(stack);\n\t\t\tif (!result) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcleanUpIndexes.push([result.index, regexp.lastIndex]);\n\t\t}\n\t}\n\n\tconst nodeModulesRegex = /^[\\\\\\/]?(node_modules|node_modules\\.asar)[\\\\\\/]/;\n\tconst fileRegex = /(file:\\/\\/)?([a-zA-Z]:(\\\\\\\\|\\\\|\\/)|(\\\\\\\\|\\\\|\\/))?([\\w-\\._]+(\\\\\\\\|\\\\|\\/))+[\\w-\\._]*/g;\n\tlet lastIndex = 0;\n\tupdatedStack = '';\n\n\twhile (true) {\n\t\tconst result = fileRegex.exec(stack);\n\t\tif (!result) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// Check to see if the any cleanupIndexes partially overlap with this match\n\t\tconst overlappingRange = cleanUpIndexes.some(([start, end]) => result.index < end && start < fileRegex.lastIndex);\n\n\t\t// anoynimize user file paths that do not need to be retained or cleaned up.\n\t\tif (!nodeModulesRegex.test(result[0]) && !overlappingRange) {\n\t\t\tupdatedStack += stack.substring(lastIndex, result.index) + '<REDACTED: user-file-path>';\n\t\t\tlastIndex = fileRegex.lastIndex;\n\t\t}\n\t}\n\tif (lastIndex < stack.length) {\n\t\tupdatedStack += stack.substr(lastIndex);\n\t}\n\n\treturn updatedStack;\n}\n\n/**\n * Attempts to remove commonly leaked PII\n * @param property The property which will be removed if it contains user data\n * @returns The new value for the property\n */\nfunction removePropertiesWithPossibleUserInfo(property: string): string {\n\t// If for some reason it is undefined we skip it (this shouldn't be possible);\n\tif (!property) {\n\t\treturn property;\n\t}\n\n\tconst userDataRegexes = [\n\t\t{ label: 'Google API Key', regex: /AIza[A-Za-z0-9_\\\\\\-]{35}/ },\n\t\t{ label: 'Slack Token', regex: /xox[pbar]\\-[A-Za-z0-9]/ },\n\t\t{ label: 'GitHub Token', regex: /(gh[psuro]_[a-zA-Z0-9]{36}|github_pat_[a-zA-Z0-9]{22}_[a-zA-Z0-9]{59})/ },\n\t\t{ label: 'Generic Secret', regex: /(key|token|sig|secret|signature|password|passwd|pwd|android:value)[^a-zA-Z0-9]/i },\n\t\t{ label: 'CLI Credentials', regex: /((login|psexec|(certutil|psexec)\\.exe).{1,50}(\\s-u(ser(name)?)?\\s+.{3,100})?\\s-(admin|user|vm|root)?p(ass(word)?)?\\s+[\"']?[^$\\-\\/\\s]|(^|[\\s\\r\\n\\\\])net(\\.exe)?.{1,5}(user\\s+|share\\s+\\/user:| user -? secrets ? set) \\s + [^ $\\s \\/])/ },\n\t\t{ label: 'Email', regex: /@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-]+/ } // Regex which matches @*.site\n\t];\n\n\t// Check for common user data in the telemetry events\n\tfor (const secretRegex of userDataRegexes) {\n\t\tif (secretRegex.regex.test(property)) {\n\t\t\treturn `<REDACTED: ${secretRegex.label}>`;\n\t\t}\n\t}\n\n\treturn property;\n}\n\n\n/**\n * Does a best possible effort to clean a data object from any possible PII.\n * @param data The data object to clean\n * @param paths Any additional patterns that should be removed from the data set\n * @returns A new object with the PII removed\n */\nexport function cleanData(data: Record<string, any>, cleanUpPatterns: RegExp[]): Record<string, any> {\n\treturn cloneAndChange(data, value => {\n\n\t\t// If it's a trusted value it means it's okay to skip cleaning so we don't clean it\n\t\tif (value instanceof TelemetryTrustedValue || Object.hasOwnProperty.call(value, 'isTrustedTelemetryValue')) {\n\t\t\treturn value.value;\n\t\t}\n\n\t\t// We only know how to clean strings\n\t\tif (typeof value === 'string') {\n\t\t\tlet updatedProperty = value.replaceAll('%20', ' ');\n\n\t\t\t// First we anonymize any possible file paths\n\t\t\tupdatedProperty = anonymizeFilePaths(updatedProperty, cleanUpPatterns);\n\n\t\t\t// Then we do a simple regex replace with the defined patterns\n\t\t\tfor (const regexp of cleanUpPatterns) {\n\t\t\t\tupdatedProperty = updatedProperty.replace(regexp, '');\n\t\t\t}\n\n\t\t\t// Lastly, remove commonly leaked PII\n\t\t\tupdatedProperty = removePropertiesWithPossibleUserInfo(updatedProperty);\n\n\t\t\treturn updatedProperty;\n\t\t}\n\t\treturn undefined;\n\t});\n}\n\n//#endregion\n"],
  "mappings": "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",
  "names": []
}
