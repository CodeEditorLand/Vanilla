{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/telemetry/common/errorTelemetry.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { binarySearch } from \"../../../base/common/arrays.js\";\nimport { ErrorNoTelemetry, errorHandler } from \"../../../base/common/errors.js\";\nimport {\n\tDisposableStore,\n\ttoDisposable,\n} from \"../../../base/common/lifecycle.js\";\nimport { safeStringify } from \"../../../base/common/objects.js\";\nimport { FileOperationError } from \"../../files/common/files.js\";\nimport type { ITelemetryService } from \"./telemetry.js\";\n\ntype ErrorEventFragment = {\n\towner: \"lramos15, sbatten\";\n\tcomment: \"Whenever an error in VS Code is thrown.\";\n\tcallstack: {\n\t\tclassification: \"CallstackOrException\";\n\t\tpurpose: \"PerformanceAndHealth\";\n\t\tcomment: \"The callstack of the error.\";\n\t};\n\tmsg?: {\n\t\tclassification: \"CallstackOrException\";\n\t\tpurpose: \"PerformanceAndHealth\";\n\t\tcomment: \"The message of the error. Normally the first line int the callstack.\";\n\t};\n\tfile?: {\n\t\tclassification: \"CallstackOrException\";\n\t\tpurpose: \"PerformanceAndHealth\";\n\t\tcomment: \"The file the error originated from.\";\n\t};\n\tline?: {\n\t\tclassification: \"CallstackOrException\";\n\t\tpurpose: \"PerformanceAndHealth\";\n\t\tcomment: \"The line the error originate on.\";\n\t};\n\tcolumn?: {\n\t\tclassification: \"CallstackOrException\";\n\t\tpurpose: \"PerformanceAndHealth\";\n\t\tcomment: \"The column of the line which the error orginated on.\";\n\t};\n\tuncaught_error_name?: {\n\t\tclassification: \"CallstackOrException\";\n\t\tpurpose: \"PerformanceAndHealth\";\n\t\tcomment: \"If the error is uncaught what is the error type\";\n\t};\n\tuncaught_error_msg?: {\n\t\tclassification: \"CallstackOrException\";\n\t\tpurpose: \"PerformanceAndHealth\";\n\t\tcomment: \"If the error is uncaught this is just msg but for uncaught errors.\";\n\t};\n\tcount?: {\n\t\tclassification: \"CallstackOrException\";\n\t\tpurpose: \"PerformanceAndHealth\";\n\t\tcomment: \"How many times this error has been thrown\";\n\t};\n};\nexport interface ErrorEvent {\n\tcallstack: string;\n\tmsg?: string;\n\tfile?: string;\n\tline?: number;\n\tcolumn?: number;\n\tuncaught_error_name?: string;\n\tuncaught_error_msg?: string;\n\tcount?: number;\n}\n\nexport namespace ErrorEvent {\n\texport function compare(a: ErrorEvent, b: ErrorEvent) {\n\t\tif (a.callstack < b.callstack) {\n\t\t\treturn -1;\n\t\t} else if (a.callstack > b.callstack) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n}\n\nexport default abstract class BaseErrorTelemetry {\n\tpublic static ERROR_FLUSH_TIMEOUT: number = 5 * 1000;\n\n\tprivate _telemetryService: ITelemetryService;\n\tprivate _flushDelay: number;\n\tprivate _flushHandle: any = -1;\n\tprivate _buffer: ErrorEvent[] = [];\n\tprotected readonly _disposables = new DisposableStore();\n\n\tconstructor(\n\t\ttelemetryService: ITelemetryService,\n\t\tflushDelay = BaseErrorTelemetry.ERROR_FLUSH_TIMEOUT,\n\t) {\n\t\tthis._telemetryService = telemetryService;\n\t\tthis._flushDelay = flushDelay;\n\n\t\t// (1) check for unexpected but handled errors\n\t\tconst unbind = errorHandler.addListener((err) =>\n\t\t\tthis._onErrorEvent(err),\n\t\t);\n\t\tthis._disposables.add(toDisposable(unbind));\n\n\t\t// (2) install implementation-specific error listeners\n\t\tthis.installErrorListeners();\n\t}\n\n\tdispose() {\n\t\tclearTimeout(this._flushHandle);\n\t\tthis._flushBuffer();\n\t\tthis._disposables.dispose();\n\t}\n\n\tprotected installErrorListeners(): void {\n\t\t// to override\n\t}\n\n\tprivate _onErrorEvent(err: any): void {\n\t\tif (!err || err.code) {\n\t\t\treturn;\n\t\t}\n\n\t\t// unwrap nested errors from loader\n\t\tif (err.detail && err.detail.stack) {\n\t\t\terr = err.detail;\n\t\t}\n\n\t\t// If it's the no telemetry error it doesn't get logged\n\t\t// TOOD @lramos15 hacking in FileOperation error because it's too messy to adopt ErrorNoTelemetry. A better solution should be found\n\t\tif (\n\t\t\tErrorNoTelemetry.isErrorNoTelemetry(err) ||\n\t\t\terr instanceof FileOperationError ||\n\t\t\t(typeof err?.message === \"string\" &&\n\t\t\t\terr.message.includes(\"Unable to read file\"))\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\t// work around behavior in workerServer.ts that breaks up Error.stack\n\t\tconst callstack = Array.isArray(err.stack)\n\t\t\t? err.stack.join(\"\\n\")\n\t\t\t: err.stack;\n\t\tconst msg = err.message ? err.message : safeStringify(err);\n\n\t\t// errors without a stack are not useful telemetry\n\t\tif (!callstack) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._enqueue({ msg, callstack });\n\t}\n\n\tprotected _enqueue(e: ErrorEvent): void {\n\t\tconst idx = binarySearch(this._buffer, e, ErrorEvent.compare);\n\t\tif (idx < 0) {\n\t\t\te.count = 1;\n\t\t\tthis._buffer.splice(~idx, 0, e);\n\t\t} else {\n\t\t\tif (!this._buffer[idx].count) {\n\t\t\t\tthis._buffer[idx].count = 0;\n\t\t\t}\n\t\t\tthis._buffer[idx].count! += 1;\n\t\t}\n\n\t\tif (this._flushHandle === -1) {\n\t\t\tthis._flushHandle = setTimeout(() => {\n\t\t\t\tthis._flushBuffer();\n\t\t\t\tthis._flushHandle = -1;\n\t\t\t}, this._flushDelay);\n\t\t}\n\t}\n\n\tprivate _flushBuffer(): void {\n\t\tfor (const error of this._buffer) {\n\t\t\ttype UnhandledErrorClassification = {} & ErrorEventFragment;\n\t\t\tthis._telemetryService.publicLogError2<\n\t\t\t\tErrorEvent,\n\t\t\t\tUnhandledErrorClassification\n\t\t\t>(\"UnhandledError\", error);\n\t\t}\n\t\tthis._buffer.length = 0;\n\t}\n}\n"],
  "mappings": ";;AAKA,SAAS,oBAAoB;AAC7B,SAAS,kBAAkB,oBAAoB;AAC/C;AAAA,EACC;AAAA,EACA;AAAA,OACM;AACP,SAAS,qBAAqB;AAC9B,SAAS,0BAA0B;AA0D5B,IAAU;AAAA,CAAV,CAAUA,gBAAV;AACC,WAAS,QAAQ,GAAe,GAAe;AACrD,QAAI,EAAE,YAAY,EAAE,WAAW;AAC9B,aAAO;AAAA,IACR,WAAW,EAAE,YAAY,EAAE,WAAW;AACrC,aAAO;AAAA,IACR;AACA,WAAO;AAAA,EACR;AAPO,EAAAA,YAAS;AAAA;AAAA,GADA;AAWjB,MAAO,mBAA0C;AAAA,EAjFjD,OAiFiD;AAAA;AAAA;AAAA,EAChD,OAAc,sBAA8B,IAAI;AAAA,EAExC;AAAA,EACA;AAAA,EACA,eAAoB;AAAA,EACpB,UAAwB,CAAC;AAAA,EACd,eAAe,IAAI,gBAAgB;AAAA,EAEtD,YACC,kBACA,aAAa,mBAAmB,qBAC/B;AACD,SAAK,oBAAoB;AACzB,SAAK,cAAc;AAGnB,UAAM,SAAS,aAAa;AAAA,MAAY,CAAC,QACxC,KAAK,cAAc,GAAG;AAAA,IACvB;AACA,SAAK,aAAa,IAAI,aAAa,MAAM,CAAC;AAG1C,SAAK,sBAAsB;AAAA,EAC5B;AAAA,EAEA,UAAU;AACT,iBAAa,KAAK,YAAY;AAC9B,SAAK,aAAa;AAClB,SAAK,aAAa,QAAQ;AAAA,EAC3B;AAAA,EAEU,wBAA8B;AAAA,EAExC;AAAA,EAEQ,cAAc,KAAgB;AACrC,QAAI,CAAC,OAAO,IAAI,MAAM;AACrB;AAAA,IACD;AAGA,QAAI,IAAI,UAAU,IAAI,OAAO,OAAO;AACnC,YAAM,IAAI;AAAA,IACX;AAIA,QACC,iBAAiB,mBAAmB,GAAG,KACvC,eAAe,sBACd,OAAO,KAAK,YAAY,YACxB,IAAI,QAAQ,SAAS,qBAAqB,GAC1C;AACD;AAAA,IACD;AAGA,UAAM,YAAY,MAAM,QAAQ,IAAI,KAAK,IACtC,IAAI,MAAM,KAAK,IAAI,IACnB,IAAI;AACP,UAAM,MAAM,IAAI,UAAU,IAAI,UAAU,cAAc,GAAG;AAGzD,QAAI,CAAC,WAAW;AACf;AAAA,IACD;AAEA,SAAK,SAAS,EAAE,KAAK,UAAU,CAAC;AAAA,EACjC;AAAA,EAEU,SAAS,GAAqB;AACvC,UAAM,MAAM,aAAa,KAAK,SAAS,GAAG,WAAW,OAAO;AAC5D,QAAI,MAAM,GAAG;AACZ,QAAE,QAAQ;AACV,WAAK,QAAQ,OAAO,CAAC,KAAK,GAAG,CAAC;AAAA,IAC/B,OAAO;AACN,UAAI,CAAC,KAAK,QAAQ,GAAG,EAAE,OAAO;AAC7B,aAAK,QAAQ,GAAG,EAAE,QAAQ;AAAA,MAC3B;AACA,WAAK,QAAQ,GAAG,EAAE,SAAU;AAAA,IAC7B;AAEA,QAAI,KAAK,iBAAiB,IAAI;AAC7B,WAAK,eAAe,WAAW,MAAM;AACpC,aAAK,aAAa;AAClB,aAAK,eAAe;AAAA,MACrB,GAAG,KAAK,WAAW;AAAA,IACpB;AAAA,EACD;AAAA,EAEQ,eAAqB;AAC5B,eAAW,SAAS,KAAK,SAAS;AAEjC,WAAK,kBAAkB,gBAGrB,kBAAkB,KAAK;AAAA,IAC1B;AACA,SAAK,QAAQ,SAAS;AAAA,EACvB;AACD;",
  "names": ["ErrorEvent"]
}
