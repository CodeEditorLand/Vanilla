var d=Object.defineProperty;var a=Object.getOwnPropertyDescriptor;var v=(l,e,r,i)=>{for(var t=i>1?void 0:i?a(e,r):e,m=l.length-1,c;m>=0;m--)(c=l[m])&&(t=(i?c(e,r,t):c(t))||t);return i&&t&&d(e,r,t),t},s=(l,e)=>(r,i)=>e(r,i,l);import{IConfigurationService as y}from"../../configuration/common/configuration.js";import{refineServiceDecorator as T}from"../../instantiation/common/instantiation.js";import{IProductService as p}from"../../product/common/productService.js";import"./gdprTypings.js";import{ITelemetryService as u,TelemetryLevel as n}from"./telemetry.js";import{TelemetryService as f}from"./telemetryService.js";import{NullTelemetryServiceShape as I}from"./telemetryUtils.js";let o=class extends f{_injectedTelemetryLevel;constructor(e,r,i,t){super(e,i,t),this._injectedTelemetryLevel=r}publicLog(e,r){if(!(this._injectedTelemetryLevel<n.USAGE))return super.publicLog(e,r)}publicLog2(e,r){return this.publicLog(e,r)}publicLogError(e,r){return this._injectedTelemetryLevel<n.ERROR?Promise.resolve(void 0):super.publicLogError(e,r)}publicLogError2(e,r){return this.publicLogError(e,r)}async updateInjectedTelemetryLevel(e){if(e===void 0)throw this._injectedTelemetryLevel=n.NONE,new Error("Telemetry level cannot be undefined. This will cause infinite looping!");this._injectedTelemetryLevel=this._injectedTelemetryLevel?Math.min(this._injectedTelemetryLevel,e):e,this._injectedTelemetryLevel===n.NONE&&this.dispose()}};o=v([s(2,y),s(3,p)],o);const R=new class extends I{async updateInjectedTelemetryLevel(){}},w=T(u);export{w as IServerTelemetryService,R as ServerNullTelemetryService,o as ServerTelemetryService};
