{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/keybinding/common/keybindingResolver.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport {\n\tContextKeyExprType,\n\ttype ContextKeyExpression,\n\ttype IContext,\n\ttype IContextKeyService,\n\texpressionsAreEqualWithConstantSubstitution,\n\timplies,\n} from \"../../contextkey/common/contextkey.js\";\nimport type { ResolvedKeybindingItem } from \"./resolvedKeybindingItem.js\";\n\n//#region resolution-result\n\nexport enum ResultKind {\n\t/** No keybinding found this sequence of chords */\n\tNoMatchingKb = 0,\n\n\t/** There're several keybindings that have the given sequence of chords as a prefix */\n\tMoreChordsNeeded = 1,\n\n\t/** A single keybinding found to be dispatched/invoked */\n\tKbFound = 2,\n}\n\nexport type ResolutionResult =\n\t| { kind: ResultKind.NoMatchingKb }\n\t| { kind: ResultKind.MoreChordsNeeded }\n\t| {\n\t\t\tkind: ResultKind.KbFound;\n\t\t\tcommandId: string | null;\n\t\t\tcommandArgs: any;\n\t\t\tisBubble: boolean;\n\t  };\n\n// util definitions to make working with the above types easier within this module:\n\nexport const NoMatchingKb: ResolutionResult = { kind: ResultKind.NoMatchingKb };\nconst MoreChordsNeeded: ResolutionResult = {\n\tkind: ResultKind.MoreChordsNeeded,\n};\nfunction KbFound(\n\tcommandId: string | null,\n\tcommandArgs: any,\n\tisBubble: boolean,\n): ResolutionResult {\n\treturn { kind: ResultKind.KbFound, commandId, commandArgs, isBubble };\n}\n\n//#endregion\n\n/**\n * Stores mappings from keybindings to commands and from commands to keybindings.\n * Given a sequence of chords, `resolve`s which keybinding it matches\n */\nexport class KeybindingResolver {\n\tprivate readonly _log: (str: string) => void;\n\tprivate readonly _defaultKeybindings: ResolvedKeybindingItem[];\n\tprivate readonly _keybindings: ResolvedKeybindingItem[];\n\tprivate readonly _defaultBoundCommands: Map<\n\t\t/* commandId */ string,\n\t\tboolean\n\t>;\n\tprivate readonly _map: Map<\n\t\t/* 1st chord's keypress */ string,\n\t\tResolvedKeybindingItem[]\n\t>;\n\tprivate readonly _lookupMap: Map<\n\t\t/* commandId */ string,\n\t\tResolvedKeybindingItem[]\n\t>;\n\n\tconstructor(\n\t\t/** built-in and extension-provided keybindings */\n\t\tdefaultKeybindings: ResolvedKeybindingItem[],\n\t\t/** user's keybindings */\n\t\toverrides: ResolvedKeybindingItem[],\n\t\tlog: (str: string) => void,\n\t) {\n\t\tthis._log = log;\n\t\tthis._defaultKeybindings = defaultKeybindings;\n\n\t\tthis._defaultBoundCommands = new Map<string, boolean>();\n\t\tfor (const defaultKeybinding of defaultKeybindings) {\n\t\t\tconst command = defaultKeybinding.command;\n\t\t\tif (command && command.charAt(0) !== \"-\") {\n\t\t\t\tthis._defaultBoundCommands.set(command, true);\n\t\t\t}\n\t\t}\n\n\t\tthis._map = new Map<string, ResolvedKeybindingItem[]>();\n\t\tthis._lookupMap = new Map<string, ResolvedKeybindingItem[]>();\n\n\t\tthis._keybindings = KeybindingResolver.handleRemovals(\n\t\t\t([] as ResolvedKeybindingItem[])\n\t\t\t\t.concat(defaultKeybindings)\n\t\t\t\t.concat(overrides),\n\t\t);\n\t\tfor (let i = 0, len = this._keybindings.length; i < len; i++) {\n\t\t\tconst k = this._keybindings[i];\n\t\t\tif (k.chords.length === 0) {\n\t\t\t\t// unbound\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// substitute with constants that are registered after startup - https://github.com/microsoft/vscode/issues/174218#issuecomment-1437972127\n\t\t\tconst when = k.when?.substituteConstants();\n\n\t\t\tif (when && when.type === ContextKeyExprType.False) {\n\t\t\t\t// when condition is false\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis._addKeyPress(k.chords[0], k);\n\t\t}\n\t}\n\n\tprivate static _isTargetedForRemoval(\n\t\tdefaultKb: ResolvedKeybindingItem,\n\t\tkeypress: string[] | null,\n\t\twhen: ContextKeyExpression | undefined,\n\t): boolean {\n\t\tif (keypress) {\n\t\t\tfor (let i = 0; i < keypress.length; i++) {\n\t\t\t\tif (keypress[i] !== defaultKb.chords[i]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// `true` means always, as does `undefined`\n\t\t// so we will treat `true` === `undefined`\n\t\tif (when && when.type !== ContextKeyExprType.True) {\n\t\t\tif (!defaultKb.when) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (\n\t\t\t\t!expressionsAreEqualWithConstantSubstitution(\n\t\t\t\t\twhen,\n\t\t\t\t\tdefaultKb.when,\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Looks for rules containing \"-commandId\" and removes them.\n\t */\n\tpublic static handleRemovals(\n\t\trules: ResolvedKeybindingItem[],\n\t): ResolvedKeybindingItem[] {\n\t\t// Do a first pass and construct a hash-map for removals\n\t\tconst removals = new Map<\n\t\t\t/* commandId */ string,\n\t\t\tResolvedKeybindingItem[]\n\t\t>();\n\t\tfor (let i = 0, len = rules.length; i < len; i++) {\n\t\t\tconst rule = rules[i];\n\t\t\tif (rule.command && rule.command.charAt(0) === \"-\") {\n\t\t\t\tconst command = rule.command.substring(1);\n\t\t\t\tif (removals.has(command)) {\n\t\t\t\t\tremovals.get(command)!.push(rule);\n\t\t\t\t} else {\n\t\t\t\t\tremovals.set(command, [rule]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (removals.size === 0) {\n\t\t\t// There are no removals\n\t\t\treturn rules;\n\t\t}\n\n\t\t// Do a second pass and keep only non-removed keybindings\n\t\tconst result: ResolvedKeybindingItem[] = [];\n\t\tfor (let i = 0, len = rules.length; i < len; i++) {\n\t\t\tconst rule = rules[i];\n\n\t\t\tif (!rule.command || rule.command.length === 0) {\n\t\t\t\tresult.push(rule);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (rule.command.charAt(0) === \"-\") {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst commandRemovals = removals.get(rule.command);\n\t\t\tif (!commandRemovals || !rule.isDefault) {\n\t\t\t\tresult.push(rule);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet isRemoved = false;\n\t\t\tfor (const commandRemoval of commandRemovals) {\n\t\t\t\tconst when = commandRemoval.when;\n\t\t\t\tif (\n\t\t\t\t\tthis._isTargetedForRemoval(\n\t\t\t\t\t\trule,\n\t\t\t\t\t\tcommandRemoval.chords,\n\t\t\t\t\t\twhen,\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tisRemoved = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!isRemoved) {\n\t\t\t\tresult.push(rule);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate _addKeyPress(keypress: string, item: ResolvedKeybindingItem): void {\n\t\tconst conflicts = this._map.get(keypress);\n\n\t\tif (typeof conflicts === \"undefined\") {\n\t\t\t// There is no conflict so far\n\t\t\tthis._map.set(keypress, [item]);\n\t\t\tthis._addToLookupMap(item);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let i = conflicts.length - 1; i >= 0; i--) {\n\t\t\tconst conflict = conflicts[i];\n\n\t\t\tif (conflict.command === item.command) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Test if the shorter keybinding is a prefix of the longer one.\n\t\t\t// If the shorter keybinding is a prefix, it effectively will shadow the longer one and is considered a conflict.\n\t\t\tlet isShorterKbPrefix = true;\n\t\t\tfor (\n\t\t\t\tlet i = 1;\n\t\t\t\ti < conflict.chords.length && i < item.chords.length;\n\t\t\t\ti++\n\t\t\t) {\n\t\t\t\tif (conflict.chords[i] !== item.chords[i]) {\n\t\t\t\t\t// The ith step does not conflict\n\t\t\t\t\tisShorterKbPrefix = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!isShorterKbPrefix) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tKeybindingResolver.whenIsEntirelyIncluded(\n\t\t\t\t\tconflict.when,\n\t\t\t\t\titem.when,\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\t// `item` completely overwrites `conflict`\n\t\t\t\t// Remove conflict from the lookupMap\n\t\t\t\tthis._removeFromLookupMap(conflict);\n\t\t\t}\n\t\t}\n\n\t\tconflicts.push(item);\n\t\tthis._addToLookupMap(item);\n\t}\n\n\tprivate _addToLookupMap(item: ResolvedKeybindingItem): void {\n\t\tif (!item.command) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet arr = this._lookupMap.get(item.command);\n\t\tif (typeof arr === \"undefined\") {\n\t\t\tarr = [item];\n\t\t\tthis._lookupMap.set(item.command, arr);\n\t\t} else {\n\t\t\tarr.push(item);\n\t\t}\n\t}\n\n\tprivate _removeFromLookupMap(item: ResolvedKeybindingItem): void {\n\t\tif (!item.command) {\n\t\t\treturn;\n\t\t}\n\t\tconst arr = this._lookupMap.get(item.command);\n\t\tif (typeof arr === \"undefined\") {\n\t\t\treturn;\n\t\t}\n\t\tfor (let i = 0, len = arr.length; i < len; i++) {\n\t\t\tif (arr[i] === item) {\n\t\t\t\tarr.splice(i, 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns true if it is provable `a` implies `b`.\n\t */\n\tpublic static whenIsEntirelyIncluded(\n\t\ta: ContextKeyExpression | null | undefined,\n\t\tb: ContextKeyExpression | null | undefined,\n\t): boolean {\n\t\tif (!b || b.type === ContextKeyExprType.True) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!a || a.type === ContextKeyExprType.True) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn implies(a, b);\n\t}\n\n\tpublic getDefaultBoundCommands(): Map<string, boolean> {\n\t\treturn this._defaultBoundCommands;\n\t}\n\n\tpublic getDefaultKeybindings(): readonly ResolvedKeybindingItem[] {\n\t\treturn this._defaultKeybindings;\n\t}\n\n\tpublic getKeybindings(): readonly ResolvedKeybindingItem[] {\n\t\treturn this._keybindings;\n\t}\n\n\tpublic lookupKeybindings(commandId: string): ResolvedKeybindingItem[] {\n\t\tconst items = this._lookupMap.get(commandId);\n\t\tif (typeof items === \"undefined\" || items.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// Reverse to get the most specific item first\n\t\tconst result: ResolvedKeybindingItem[] = [];\n\t\tlet resultLen = 0;\n\t\tfor (let i = items.length - 1; i >= 0; i--) {\n\t\t\tresult[resultLen++] = items[i];\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic lookupPrimaryKeybinding(\n\t\tcommandId: string,\n\t\tcontext: IContextKeyService,\n\t): ResolvedKeybindingItem | null {\n\t\tconst items = this._lookupMap.get(commandId);\n\t\tif (typeof items === \"undefined\" || items.length === 0) {\n\t\t\treturn null;\n\t\t}\n\t\tif (items.length === 1) {\n\t\t\treturn items[0];\n\t\t}\n\n\t\tfor (let i = items.length - 1; i >= 0; i--) {\n\t\t\tconst item = items[i];\n\t\t\tif (context.contextMatchesRules(item.when)) {\n\t\t\t\treturn item;\n\t\t\t}\n\t\t}\n\n\t\treturn items[items.length - 1];\n\t}\n\n\t/**\n\t * Looks up a keybinding trigged as a result of pressing a sequence of chords - `[...currentChords, keypress]`\n\t *\n\t * Example: resolving 3 chords pressed sequentially - `cmd+k cmd+p cmd+i`:\n\t * \t`currentChords = [ 'cmd+k' , 'cmd+p' ]` and `keypress = `cmd+i` - last pressed chord\n\t */\n\tpublic resolve(\n\t\tcontext: IContext,\n\t\tcurrentChords: string[],\n\t\tkeypress: string,\n\t): ResolutionResult {\n\t\tconst pressedChords = [...currentChords, keypress];\n\n\t\tthis._log(`| Resolving ${pressedChords}`);\n\n\t\tconst kbCandidates = this._map.get(pressedChords[0]);\n\t\tif (kbCandidates === undefined) {\n\t\t\t// No bindings with such 0-th chord\n\t\t\tthis._log(`\\\\ No keybinding entries.`);\n\t\t\treturn NoMatchingKb;\n\t\t}\n\n\t\tlet lookupMap: ResolvedKeybindingItem[] | null = null;\n\n\t\tif (pressedChords.length < 2) {\n\t\t\tlookupMap = kbCandidates;\n\t\t} else {\n\t\t\t// Fetch all chord bindings for `currentChords`\n\t\t\tlookupMap = [];\n\t\t\tfor (let i = 0, len = kbCandidates.length; i < len; i++) {\n\t\t\t\tconst candidate = kbCandidates[i];\n\n\t\t\t\tif (pressedChords.length > candidate.chords.length) {\n\t\t\t\t\t// # of pressed chords can't be less than # of chords in a keybinding to invoke\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet prefixMatches = true;\n\t\t\t\tfor (let i = 1; i < pressedChords.length; i++) {\n\t\t\t\t\tif (candidate.chords[i] !== pressedChords[i]) {\n\t\t\t\t\t\tprefixMatches = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (prefixMatches) {\n\t\t\t\t\tlookupMap.push(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// check there's a keybinding with a matching when clause\n\t\tconst result = this._findCommand(context, lookupMap);\n\t\tif (!result) {\n\t\t\tthis._log(\n\t\t\t\t`\\\\ From ${lookupMap.length} keybinding entries, no when clauses matched the context.`,\n\t\t\t);\n\t\t\treturn NoMatchingKb;\n\t\t}\n\n\t\t// check we got all chords necessary to be sure a particular keybinding needs to be invoked\n\t\tif (pressedChords.length < result.chords.length) {\n\t\t\t// The chord sequence is not complete\n\t\t\tthis._log(\n\t\t\t\t`\\\\ From ${lookupMap.length} keybinding entries, awaiting ${result.chords.length - pressedChords.length} more chord(s), when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`,\n\t\t\t);\n\t\t\treturn MoreChordsNeeded;\n\t\t}\n\n\t\tthis._log(\n\t\t\t`\\\\ From ${lookupMap.length} keybinding entries, matched ${result.command}, when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`,\n\t\t);\n\n\t\treturn KbFound(result.command, result.commandArgs, result.bubble);\n\t}\n\n\tprivate _findCommand(\n\t\tcontext: IContext,\n\t\tmatches: ResolvedKeybindingItem[],\n\t): ResolvedKeybindingItem | null {\n\t\tfor (let i = matches.length - 1; i >= 0; i--) {\n\t\t\tconst k = matches[i];\n\n\t\t\tif (!KeybindingResolver._contextMatchesRules(context, k.when)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treturn k;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _contextMatchesRules(\n\t\tcontext: IContext,\n\t\trules: ContextKeyExpression | null | undefined,\n\t): boolean {\n\t\tif (!rules) {\n\t\t\treturn true;\n\t\t}\n\t\treturn rules.evaluate(context);\n\t}\n}\n\nfunction printWhenExplanation(when: ContextKeyExpression | undefined): string {\n\tif (!when) {\n\t\treturn `no when condition`;\n\t}\n\treturn `${when.serialize()}`;\n}\n\nfunction printSourceExplanation(kb: ResolvedKeybindingItem): string {\n\treturn kb.extensionId\n\t\t? kb.isBuiltinExtension\n\t\t\t? `built-in extension ${kb.extensionId}`\n\t\t\t: `user extension ${kb.extensionId}`\n\t\t: kb.isDefault\n\t\t\t? `built-in`\n\t\t\t: `user`;\n}\n"],
  "mappings": "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",
  "names": ["ResultKind", "i"]
}
