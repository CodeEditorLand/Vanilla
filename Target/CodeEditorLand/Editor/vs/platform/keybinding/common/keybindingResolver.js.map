{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/keybinding/common/keybindingResolver.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { implies, ContextKeyExpression, ContextKeyExprType, IContext, IContextKeyService, expressionsAreEqualWithConstantSubstitution } from '../../contextkey/common/contextkey.js';\nimport { ResolvedKeybindingItem } from './resolvedKeybindingItem.js';\n\n//#region resolution-result\n\nexport const enum ResultKind {\n\t/** No keybinding found this sequence of chords */\n\tNoMatchingKb,\n\n\t/** There're several keybindings that have the given sequence of chords as a prefix */\n\tMoreChordsNeeded,\n\n\t/** A single keybinding found to be dispatched/invoked */\n\tKbFound\n}\n\nexport type ResolutionResult =\n\t| { kind: ResultKind.NoMatchingKb }\n\t| { kind: ResultKind.MoreChordsNeeded }\n\t| { kind: ResultKind.KbFound; commandId: string | null; commandArgs: any; isBubble: boolean };\n\n\n// util definitions to make working with the above types easier within this module:\n\nexport const NoMatchingKb: ResolutionResult = { kind: ResultKind.NoMatchingKb };\nconst MoreChordsNeeded: ResolutionResult = { kind: ResultKind.MoreChordsNeeded };\nfunction KbFound(commandId: string | null, commandArgs: any, isBubble: boolean): ResolutionResult {\n\treturn { kind: ResultKind.KbFound, commandId, commandArgs, isBubble };\n}\n\n//#endregion\n\n/**\n * Stores mappings from keybindings to commands and from commands to keybindings.\n * Given a sequence of chords, `resolve`s which keybinding it matches\n */\nexport class KeybindingResolver {\n\tprivate readonly _log: (str: string) => void;\n\tprivate readonly _defaultKeybindings: ResolvedKeybindingItem[];\n\tprivate readonly _keybindings: ResolvedKeybindingItem[];\n\tprivate readonly _defaultBoundCommands: Map</* commandId */ string, boolean>;\n\tprivate readonly _map: Map</* 1st chord's keypress */ string, ResolvedKeybindingItem[]>;\n\tprivate readonly _lookupMap: Map</* commandId */ string, ResolvedKeybindingItem[]>;\n\n\tconstructor(\n\t\t/** built-in and extension-provided keybindings */\n\t\tdefaultKeybindings: ResolvedKeybindingItem[],\n\t\t/** user's keybindings */\n\t\toverrides: ResolvedKeybindingItem[],\n\t\tlog: (str: string) => void\n\t) {\n\t\tthis._log = log;\n\t\tthis._defaultKeybindings = defaultKeybindings;\n\n\t\tthis._defaultBoundCommands = new Map<string, boolean>();\n\t\tfor (const defaultKeybinding of defaultKeybindings) {\n\t\t\tconst command = defaultKeybinding.command;\n\t\t\tif (command && command.charAt(0) !== '-') {\n\t\t\t\tthis._defaultBoundCommands.set(command, true);\n\t\t\t}\n\t\t}\n\n\t\tthis._map = new Map<string, ResolvedKeybindingItem[]>();\n\t\tthis._lookupMap = new Map<string, ResolvedKeybindingItem[]>();\n\n\t\tthis._keybindings = KeybindingResolver.handleRemovals(([] as ResolvedKeybindingItem[]).concat(defaultKeybindings).concat(overrides));\n\t\tfor (let i = 0, len = this._keybindings.length; i < len; i++) {\n\t\t\tconst k = this._keybindings[i];\n\t\t\tif (k.chords.length === 0) {\n\t\t\t\t// unbound\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// substitute with constants that are registered after startup - https://github.com/microsoft/vscode/issues/174218#issuecomment-1437972127\n\t\t\tconst when = k.when?.substituteConstants();\n\n\t\t\tif (when && when.type === ContextKeyExprType.False) {\n\t\t\t\t// when condition is false\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis._addKeyPress(k.chords[0], k);\n\t\t}\n\t}\n\n\tprivate static _isTargetedForRemoval(defaultKb: ResolvedKeybindingItem, keypress: string[] | null, when: ContextKeyExpression | undefined): boolean {\n\t\tif (keypress) {\n\t\t\tfor (let i = 0; i < keypress.length; i++) {\n\t\t\t\tif (keypress[i] !== defaultKb.chords[i]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// `true` means always, as does `undefined`\n\t\t// so we will treat `true` === `undefined`\n\t\tif (when && when.type !== ContextKeyExprType.True) {\n\t\t\tif (!defaultKb.when) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!expressionsAreEqualWithConstantSubstitution(when, defaultKb.when)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Looks for rules containing \"-commandId\" and removes them.\n\t */\n\tpublic static handleRemovals(rules: ResolvedKeybindingItem[]): ResolvedKeybindingItem[] {\n\t\t// Do a first pass and construct a hash-map for removals\n\t\tconst removals = new Map</* commandId */ string, ResolvedKeybindingItem[]>();\n\t\tfor (let i = 0, len = rules.length; i < len; i++) {\n\t\t\tconst rule = rules[i];\n\t\t\tif (rule.command && rule.command.charAt(0) === '-') {\n\t\t\t\tconst command = rule.command.substring(1);\n\t\t\t\tif (!removals.has(command)) {\n\t\t\t\t\tremovals.set(command, [rule]);\n\t\t\t\t} else {\n\t\t\t\t\tremovals.get(command)!.push(rule);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (removals.size === 0) {\n\t\t\t// There are no removals\n\t\t\treturn rules;\n\t\t}\n\n\t\t// Do a second pass and keep only non-removed keybindings\n\t\tconst result: ResolvedKeybindingItem[] = [];\n\t\tfor (let i = 0, len = rules.length; i < len; i++) {\n\t\t\tconst rule = rules[i];\n\n\t\t\tif (!rule.command || rule.command.length === 0) {\n\t\t\t\tresult.push(rule);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (rule.command.charAt(0) === '-') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst commandRemovals = removals.get(rule.command);\n\t\t\tif (!commandRemovals || !rule.isDefault) {\n\t\t\t\tresult.push(rule);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet isRemoved = false;\n\t\t\tfor (const commandRemoval of commandRemovals) {\n\t\t\t\tconst when = commandRemoval.when;\n\t\t\t\tif (this._isTargetedForRemoval(rule, commandRemoval.chords, when)) {\n\t\t\t\t\tisRemoved = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!isRemoved) {\n\t\t\t\tresult.push(rule);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate _addKeyPress(keypress: string, item: ResolvedKeybindingItem): void {\n\n\t\tconst conflicts = this._map.get(keypress);\n\n\t\tif (typeof conflicts === 'undefined') {\n\t\t\t// There is no conflict so far\n\t\t\tthis._map.set(keypress, [item]);\n\t\t\tthis._addToLookupMap(item);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let i = conflicts.length - 1; i >= 0; i--) {\n\t\t\tconst conflict = conflicts[i];\n\n\t\t\tif (conflict.command === item.command) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Test if the shorter keybinding is a prefix of the longer one.\n\t\t\t// If the shorter keybinding is a prefix, it effectively will shadow the longer one and is considered a conflict.\n\t\t\tlet isShorterKbPrefix = true;\n\t\t\tfor (let i = 1; i < conflict.chords.length && i < item.chords.length; i++) {\n\t\t\t\tif (conflict.chords[i] !== item.chords[i]) {\n\t\t\t\t\t// The ith step does not conflict\n\t\t\t\t\tisShorterKbPrefix = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!isShorterKbPrefix) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (KeybindingResolver.whenIsEntirelyIncluded(conflict.when, item.when)) {\n\t\t\t\t// `item` completely overwrites `conflict`\n\t\t\t\t// Remove conflict from the lookupMap\n\t\t\t\tthis._removeFromLookupMap(conflict);\n\t\t\t}\n\t\t}\n\n\t\tconflicts.push(item);\n\t\tthis._addToLookupMap(item);\n\t}\n\n\tprivate _addToLookupMap(item: ResolvedKeybindingItem): void {\n\t\tif (!item.command) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet arr = this._lookupMap.get(item.command);\n\t\tif (typeof arr === 'undefined') {\n\t\t\tarr = [item];\n\t\t\tthis._lookupMap.set(item.command, arr);\n\t\t} else {\n\t\t\tarr.push(item);\n\t\t}\n\t}\n\n\tprivate _removeFromLookupMap(item: ResolvedKeybindingItem): void {\n\t\tif (!item.command) {\n\t\t\treturn;\n\t\t}\n\t\tconst arr = this._lookupMap.get(item.command);\n\t\tif (typeof arr === 'undefined') {\n\t\t\treturn;\n\t\t}\n\t\tfor (let i = 0, len = arr.length; i < len; i++) {\n\t\t\tif (arr[i] === item) {\n\t\t\t\tarr.splice(i, 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns true if it is provable `a` implies `b`.\n\t */\n\tpublic static whenIsEntirelyIncluded(a: ContextKeyExpression | null | undefined, b: ContextKeyExpression | null | undefined): boolean {\n\t\tif (!b || b.type === ContextKeyExprType.True) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!a || a.type === ContextKeyExprType.True) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn implies(a, b);\n\t}\n\n\tpublic getDefaultBoundCommands(): Map<string, boolean> {\n\t\treturn this._defaultBoundCommands;\n\t}\n\n\tpublic getDefaultKeybindings(): readonly ResolvedKeybindingItem[] {\n\t\treturn this._defaultKeybindings;\n\t}\n\n\tpublic getKeybindings(): readonly ResolvedKeybindingItem[] {\n\t\treturn this._keybindings;\n\t}\n\n\tpublic lookupKeybindings(commandId: string): ResolvedKeybindingItem[] {\n\t\tconst items = this._lookupMap.get(commandId);\n\t\tif (typeof items === 'undefined' || items.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// Reverse to get the most specific item first\n\t\tconst result: ResolvedKeybindingItem[] = [];\n\t\tlet resultLen = 0;\n\t\tfor (let i = items.length - 1; i >= 0; i--) {\n\t\t\tresult[resultLen++] = items[i];\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic lookupPrimaryKeybinding(commandId: string, context: IContextKeyService): ResolvedKeybindingItem | null {\n\t\tconst items = this._lookupMap.get(commandId);\n\t\tif (typeof items === 'undefined' || items.length === 0) {\n\t\t\treturn null;\n\t\t}\n\t\tif (items.length === 1) {\n\t\t\treturn items[0];\n\t\t}\n\n\t\tfor (let i = items.length - 1; i >= 0; i--) {\n\t\t\tconst item = items[i];\n\t\t\tif (context.contextMatchesRules(item.when)) {\n\t\t\t\treturn item;\n\t\t\t}\n\t\t}\n\n\t\treturn items[items.length - 1];\n\t}\n\n\t/**\n\t * Looks up a keybinding trigged as a result of pressing a sequence of chords - `[...currentChords, keypress]`\n\t *\n\t * Example: resolving 3 chords pressed sequentially - `cmd+k cmd+p cmd+i`:\n\t * \t`currentChords = [ 'cmd+k' , 'cmd+p' ]` and `keypress = `cmd+i` - last pressed chord\n\t */\n\tpublic resolve(context: IContext, currentChords: string[], keypress: string): ResolutionResult {\n\n\t\tconst pressedChords = [...currentChords, keypress];\n\n\t\tthis._log(`| Resolving ${pressedChords}`);\n\n\t\tconst kbCandidates = this._map.get(pressedChords[0]);\n\t\tif (kbCandidates === undefined) {\n\t\t\t// No bindings with such 0-th chord\n\t\t\tthis._log(`\\\\ No keybinding entries.`);\n\t\t\treturn NoMatchingKb;\n\t\t}\n\n\t\tlet lookupMap: ResolvedKeybindingItem[] | null = null;\n\n\t\tif (pressedChords.length < 2) {\n\t\t\tlookupMap = kbCandidates;\n\t\t} else {\n\t\t\t// Fetch all chord bindings for `currentChords`\n\t\t\tlookupMap = [];\n\t\t\tfor (let i = 0, len = kbCandidates.length; i < len; i++) {\n\n\t\t\t\tconst candidate = kbCandidates[i];\n\n\t\t\t\tif (pressedChords.length > candidate.chords.length) { // # of pressed chords can't be less than # of chords in a keybinding to invoke\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet prefixMatches = true;\n\t\t\t\tfor (let i = 1; i < pressedChords.length; i++) {\n\t\t\t\t\tif (candidate.chords[i] !== pressedChords[i]) {\n\t\t\t\t\t\tprefixMatches = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (prefixMatches) {\n\t\t\t\t\tlookupMap.push(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// check there's a keybinding with a matching when clause\n\t\tconst result = this._findCommand(context, lookupMap);\n\t\tif (!result) {\n\t\t\tthis._log(`\\\\ From ${lookupMap.length} keybinding entries, no when clauses matched the context.`);\n\t\t\treturn NoMatchingKb;\n\t\t}\n\n\t\t// check we got all chords necessary to be sure a particular keybinding needs to be invoked\n\t\tif (pressedChords.length < result.chords.length) {\n\t\t\t// The chord sequence is not complete\n\t\t\tthis._log(`\\\\ From ${lookupMap.length} keybinding entries, awaiting ${result.chords.length - pressedChords.length} more chord(s), when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`);\n\t\t\treturn MoreChordsNeeded;\n\t\t}\n\n\t\tthis._log(`\\\\ From ${lookupMap.length} keybinding entries, matched ${result.command}, when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`);\n\n\t\treturn KbFound(result.command, result.commandArgs, result.bubble);\n\t}\n\n\tprivate _findCommand(context: IContext, matches: ResolvedKeybindingItem[]): ResolvedKeybindingItem | null {\n\t\tfor (let i = matches.length - 1; i >= 0; i--) {\n\t\t\tconst k = matches[i];\n\n\t\t\tif (!KeybindingResolver._contextMatchesRules(context, k.when)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treturn k;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _contextMatchesRules(context: IContext, rules: ContextKeyExpression | null | undefined): boolean {\n\t\tif (!rules) {\n\t\t\treturn true;\n\t\t}\n\t\treturn rules.evaluate(context);\n\t}\n}\n\nfunction printWhenExplanation(when: ContextKeyExpression | undefined): string {\n\tif (!when) {\n\t\treturn `no when condition`;\n\t}\n\treturn `${when.serialize()}`;\n}\n\nfunction printSourceExplanation(kb: ResolvedKeybindingItem): string {\n\treturn (\n\t\tkb.extensionId\n\t\t\t? (kb.isBuiltinExtension ? `built-in extension ${kb.extensionId}` : `user extension ${kb.extensionId}`)\n\t\t\t: (kb.isDefault ? `built-in` : `user`)\n\t);\n}\n"],
  "mappings": "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",
  "names": ["ResultKind", "i"]
}
