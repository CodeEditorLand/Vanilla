var N=Object.defineProperty;var M=Object.getOwnPropertyDescriptor;var D=(p,e,n,a)=>{for(var t=a>1?void 0:a?M(e,n):e,r=p.length-1,s;r>=0;r--)(s=p[r])&&(t=(a?s(e,n,t):s(t))||t);return a&&t&&N(e,n,t),t};import*as I from"child_process";import{memoize as W}from"../../../base/common/decorators.js";import{FileAccess as U}from"../../../base/common/network.js";import*as R from"../../../base/common/path.js";import*as C from"../../../base/common/platform.js";import{sanitizeProcessEnvironment as F}from"../../../base/common/processes.js";import*as y from"../../../base/node/pfs.js";import*as L from"../../../base/node/processes.js";import*as v from"../../../nls.js";import{DEFAULT_TERMINAL_OSX as P}from"../common/externalTerminal.js";const O=v.localize("console.title","VS Code Console");class A{_serviceBrand;async getDefaultTerminalForPlatforms(){return{windows:S.getDefaultTerminalWindows(),linux:await T.getDefaultTerminalLinuxReady(),osx:"xterm"}}}const E=class extends A{static CMD="cmd.exe";static _DEFAULT_TERMINAL_WINDOWS;openTerminal(e,n){return this.spawnTerminal(I,e,L.getWindowsShell(),n)}spawnTerminal(e,n,a,t){const r=n.windowsExec||E.getDefaultTerminalWindows();t&&t[1]===":"&&(t=t[0].toUpperCase()+t.substr(1));const s=R.basename(r,".exe").toLowerCase();if(s==="cmder")return e.spawn(r,t?[t]:void 0),Promise.resolve(void 0);const l=["/c","start","/wait"];return r.indexOf(" ")>=0&&l.push(r),l.push(r),s==="wt"&&l.push("-d ."),new Promise((m,o)=>{const g=h(process),c=e.spawn(a,l,{cwd:t,env:g,detached:!0});c.on("error",o),c.on("exit",()=>m())})}async runInTerminal(e,n,a,t,r){const s="windowsExec"in r&&r.windowsExec?r.windowsExec:E.getDefaultTerminalWindows(),l=await E.getWtExePath();return new Promise((m,o)=>{const g=`"${n} - ${O}"`,c=`"${a.join('" "')}" & pause`,f=Object.assign({},h(process),t);Object.keys(f).filter(w=>f[w]===null).forEach(w=>delete f[w]);const x={cwd:n,env:f,windowsVerbatimArguments:!0};let i,u;R.basename(s,".exe")==="wt"?(i=s,u=["-d",".",E.CMD,"/c",c]):l?(i=l,u=["-d",".",s,"/c",c]):(i=E.CMD,u=["/c","start",g,"/wait",s,"/c",`"${c}"`]),I.spawn(i,u,x).on("error",w=>{o(b(w))}),m(void 0)})}static getDefaultTerminalWindows(){if(!E._DEFAULT_TERMINAL_WINDOWS){const e=!!process.env.hasOwnProperty("PROCESSOR_ARCHITEW6432");E._DEFAULT_TERMINAL_WINDOWS=`${process.env.windir?process.env.windir:"C:\\Windows"}\\${e?"Sysnative":"System32"}\\cmd.exe`}return E._DEFAULT_TERMINAL_WINDOWS}static async getWtExePath(){try{const e=await L.win32.findExecutable("wt");return await y.Promises.exists(e)?e:void 0}catch{return}}};let S=E;D([W],S,"getWtExePath",1);class _ extends A{static OSASCRIPT="/usr/bin/osascript";openTerminal(e,n){return this.spawnTerminal(I,e,n)}runInTerminal(e,n,a,t,r){const s=r.osxExec||P;return new Promise((l,m)=>{if(s===P||s==="iTerm.app"){const o=s===P?"TerminalHelper":"iTermHelper",c=[U.asFileUri(`vs/workbench/contrib/externalTerminal/node/${o}.scpt`).fsPath,"-t",e||O,"-w",n];for(const i of a)c.push("-a"),c.push(i);if(t){const i=Object.assign({},h(process),t);for(const u in i){const d=i[u];d===null?(c.push("-u"),c.push(u)):(c.push("-e"),c.push(`${u}=${d}`))}}let f="";const x=I.spawn(_.OSASCRIPT,c);x.on("error",i=>{m(b(i))}),x.stderr.on("data",i=>{f+=i.toString()}),x.on("exit",i=>{if(i===0)l(void 0);else if(f){const u=f.split(`
`,1);m(new Error(u[0]))}else m(new Error(v.localize("mac.terminal.script.failed","Script '{0}' failed with exit code {1}",o,i)))})}else m(new Error(v.localize("mac.terminal.type.not.supported","'{0}' not supported",s)))})}spawnTerminal(e,n,a){const t=n.osxExec||P;return new Promise((r,s)=>{const l=["-a",t];a&&l.push(a);const m=h(process),o=e.spawn("/usr/bin/open",l,{cwd:a,env:m});o.on("error",s),o.on("exit",()=>r())})}}class T extends A{static WAIT_MESSAGE=v.localize("press.any.key","Press any key to continue...");openTerminal(e,n){return this.spawnTerminal(I,e,n)}runInTerminal(e,n,a,t,r){const s=r.linuxExec?Promise.resolve(r.linuxExec):T.getDefaultTerminalLinuxReady();return new Promise((l,m)=>{const o=[];s.then(g=>{g.indexOf("gnome-terminal")>=0?o.push("-x"):o.push("-e"),o.push("bash"),o.push("-c");const c=`${$(a)}; echo; read -p "${T.WAIT_MESSAGE}" -n1;`;o.push(`''${c}''`);const f=Object.assign({},h(process),t);Object.keys(f).filter(d=>f[d]===null).forEach(d=>delete f[d]);const x={cwd:n,env:f};let i="";const u=I.spawn(g,o,x);u.on("error",d=>{m(b(d))}),u.stderr.on("data",d=>{i+=d.toString()}),u.on("exit",d=>{if(d===0)l(void 0);else if(i){const w=i.split(`
`,1);m(new Error(w[0]))}else m(new Error(v.localize("linux.term.failed","'{0}' failed with exit code {1}",g,d)))})})})}static _DEFAULT_TERMINAL_LINUX_READY;static async getDefaultTerminalLinuxReady(){if(!T._DEFAULT_TERMINAL_LINUX_READY)if(!C.isLinux)T._DEFAULT_TERMINAL_LINUX_READY=Promise.resolve("xterm");else{const e=await y.Promises.exists("/etc/debian_version");T._DEFAULT_TERMINAL_LINUX_READY=new Promise(n=>{e?n("x-terminal-emulator"):process.env.DESKTOP_SESSION==="gnome"||process.env.DESKTOP_SESSION==="gnome-classic"?n("gnome-terminal"):process.env.DESKTOP_SESSION==="kde-plasma"?n("konsole"):process.env.COLORTERM?n(process.env.COLORTERM):process.env.TERM?n(process.env.TERM):n("xterm")})}return T._DEFAULT_TERMINAL_LINUX_READY}spawnTerminal(e,n,a){const t=n.linuxExec?Promise.resolve(n.linuxExec):T.getDefaultTerminalLinuxReady();return new Promise((r,s)=>{t.then(l=>{const m=h(process),o=e.spawn(l,[],{cwd:a,env:m});o.on("error",s),o.on("exit",()=>r())})})}}function h(p){const e={...p.env};return F(e),e}function b(p){return"errno"in p&&p.errno==="ENOENT"&&"path"in p&&typeof p.path=="string"?new Error(v.localize("ext.term.app.not.found","can't find terminal application '{0}'",p.path)):p}function $(p){let e="";for(const n of p)n.indexOf(" ")>=0?e+='"'+n+'"':e+=n,e+=" ";return e}export{T as LinuxExternalTerminalService,_ as MacExternalTerminalService,S as WindowsExternalTerminalService};
