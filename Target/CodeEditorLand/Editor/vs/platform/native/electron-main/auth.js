var C=Object.defineProperty;var w=Object.getOwnPropertyDescriptor;var S=(l,d,i,e)=>{for(var r=e>1?void 0:e?w(d,i):d,s=l.length-1,t;s>=0;s--)(t=l[s])&&(r=(e?t(d,i,r):t(r))||r);return e&&r&&C(d,i,r),r},c=(l,d)=>(i,e)=>d(i,e,l);import{app as P}from"electron";import{CancellationToken as E}from"../../../base/common/cancellation.js";import{Event as A}from"../../../base/common/event.js";import{hash as R}from"../../../base/common/hash.js";import{Disposable as I}from"../../../base/common/lifecycle.js";import{URI as L}from"../../../base/common/uri.js";import{generateUuid as M}from"../../../base/common/uuid.js";import{IConfigurationService as D}from"../../configuration/common/configuration.js";import{IEncryptionMainService as _}from"../../encryption/common/encryptionService.js";import{IEnvironmentMainService as b}from"../../environment/electron-main/environmentMainService.js";import{createDecorator as O}from"../../instantiation/common/instantiation.js";import{ILogService as T}from"../../log/common/log.js";import{StorageScope as x,StorageTarget as N}from"../../storage/common/storage.js";import{IApplicationStorageMainService as Y}from"../../storage/electron-main/storageMainService.js";import{IWindowsMainService as V}from"../../windows/electron-main/windows.js";const ae=O("proxyAuthService");let f=class extends I{constructor(i,e,r,s,t,o){super();this.logService=i;this.windowsMainService=e;this.encryptionMainService=r;this.applicationStorageMainService=s;this.configurationService=t;this.environmentMainService=o;this.registerListeners()}PROXY_CREDENTIALS_SERVICE_KEY="proxy-credentials://";pendingProxyResolves=new Map;currentDialog=void 0;cancelledAuthInfoHashes=new Set;sessionCredentials=new Map;registerListeners(){const i=A.fromNodeEventEmitter(P,"login",(e,r,s,t,o)=>({event:e,authInfo:{...t,attempt:s.firstAuthAttempt?1:2},callback:o}));this._register(i(this.onLogin,this))}async lookupAuthorization(i){return this.onLogin({authInfo:i})}async onLogin({event:i,authInfo:e,callback:r}){if(!e.isProxy)return;i?.preventDefault();const s=String(R({scheme:e.scheme,host:e.host,port:e.port}));let t,o=this.pendingProxyResolves.get(s);if(o)this.logService.trace("auth#onLogin (proxy) - pending proxy handling found"),t=await o;else{this.logService.trace("auth#onLogin (proxy) - no pending proxy handling found, starting new"),o=this.resolveProxyCredentials(e,s),this.pendingProxyResolves.set(s,o);try{t=await o}finally{this.pendingProxyResolves.delete(s)}}return r?.(t?.username,t?.password),t}async resolveProxyCredentials(i,e){this.logService.trace("auth#resolveProxyCredentials (proxy) - enter");try{const r=await this.doResolveProxyCredentials(i,e);if(r)return this.logService.trace("auth#resolveProxyCredentials (proxy) - got credentials"),r;this.logService.trace("auth#resolveProxyCredentials (proxy) - did not get credentials")}finally{this.logService.trace("auth#resolveProxyCredentials (proxy) - exit")}}async doResolveProxyCredentials(i,e){if(this.logService.trace("auth#doResolveProxyCredentials - enter",i),this.environmentMainService.extensionTestsLocationURI){const n=this.configurationService.getValue("integration-test.http.proxyAuth");if(n){const a=n.indexOf(":");return a!==-1?{username:n.substring(0,a),password:n.substring(a+1)}:{username:n,password:""}}return}const r=(this.configurationService.getValue("http.proxy")||"").trim()||(process.env.https_proxy||process.env.HTTPS_PROXY||process.env.http_proxy||process.env.HTTP_PROXY||"").trim()||void 0;if(r?.indexOf("@")!==-1){const n=L.parse(r),a=n.authority.indexOf("@");if(a!==-1){if(i.attempt>1){this.logService.trace("auth#doResolveProxyCredentials (proxy) - exit - ignoring previously used config/envvar credentials");return}this.logService.trace("auth#doResolveProxyCredentials (proxy) - exit - found config/envvar credentials to use");const u=n.authority.substring(0,a),v=u.indexOf(":");return v!==-1?{username:u.substring(0,v),password:u.substring(v+1)}:{username:u,password:""}}}const s=i.attempt===1&&this.sessionCredentials.get(e);if(s){this.logService.trace("auth#doResolveProxyCredentials (proxy) - exit - found session credentials to use");const{username:n,password:a}=s;return{username:n,password:a}}let t,o;try{const n=this.applicationStorageMainService.get(this.PROXY_CREDENTIALS_SERVICE_KEY+e,x.APPLICATION);if(n){const a=JSON.parse(await this.encryptionMainService.decrypt(n));t=a.username,o=a.password}}catch(n){this.logService.error(n)}if(i.attempt===1&&typeof t=="string"&&typeof o=="string")return this.logService.trace("auth#doResolveProxyCredentials (proxy) - exit - found stored credentials to use"),this.sessionCredentials.set(e,{username:t,password:o}),{username:t,password:o};const g=this.currentDialog,p=this.currentDialog=(async()=>{await g;const n=await this.showProxyCredentialsDialog(i,e,t,o);return this.currentDialog===p&&(this.currentDialog=void 0),n})();return p}async showProxyCredentialsDialog(i,e,r,s){if(this.cancelledAuthInfoHashes.has(e)){this.logService.trace("auth#doResolveProxyCredentials (proxy) - exit - login dialog was cancelled before, not showing again");return}const t=this.windowsMainService.getFocusedWindow()||this.windowsMainService.getLastActiveWindow();if(!t){this.logService.trace("auth#doResolveProxyCredentials (proxy) - exit - no opened window found to show dialog in");return}this.logService.trace(`auth#doResolveProxyCredentials (proxy) - asking window ${t.id} to handle proxy login`);const o=this.sessionCredentials.get(e),g={authInfo:i,username:o?.username??r,password:o?.password??s,replyChannel:`vscode:proxyAuthResponse:${M()}`};t.sendWhenReady("vscode:openProxyAuthenticationDialog",E.None,g);const p=await new Promise(n=>{const a=async(u,v,h)=>{if(v===g.replyChannel)if(this.logService.trace(`auth#doResolveProxyCredentials - exit - received credentials from window ${t.id}`),t.win?.webContents.off("ipc-message",a),h){const y={username:h.username,password:h.password};try{if(h.remember){const m=await this.encryptionMainService.encrypt(JSON.stringify(y));this.applicationStorageMainService.store(this.PROXY_CREDENTIALS_SERVICE_KEY+e,m,x.APPLICATION,N.MACHINE)}else this.applicationStorageMainService.remove(this.PROXY_CREDENTIALS_SERVICE_KEY+e,x.APPLICATION)}catch(m){this.logService.error(m)}n({username:y.username,password:y.password})}else this.cancelledAuthInfoHashes.add(e),n(void 0)};t.win?.webContents.on("ipc-message",a)});return this.sessionCredentials.set(e,p),p}};f=S([c(0,T),c(1,V),c(2,_),c(3,Y),c(4,D),c(5,b)],f);export{ae as IProxyAuthService,f as ProxyAuthService};
