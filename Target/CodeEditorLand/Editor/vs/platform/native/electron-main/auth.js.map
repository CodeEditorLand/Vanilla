{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/native/electron-main/auth.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { app, AuthenticationResponseDetails, AuthInfo as ElectronAuthInfo, Event as ElectronEvent, WebContents } from 'electron';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { Event } from '../../../base/common/event.js';\nimport { hash } from '../../../base/common/hash.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { generateUuid } from '../../../base/common/uuid.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { IEncryptionMainService } from '../../encryption/common/encryptionService.js';\nimport { IEnvironmentMainService } from '../../environment/electron-main/environmentMainService.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { AuthInfo, Credentials } from '../../request/common/request.js';\nimport { StorageScope, StorageTarget } from '../../storage/common/storage.js';\nimport { IApplicationStorageMainService } from '../../storage/electron-main/storageMainService.js';\nimport { IWindowsMainService } from '../../windows/electron-main/windows.js';\n\ninterface ElectronAuthenticationResponseDetails extends AuthenticationResponseDetails {\n\tfirstAuthAttempt?: boolean; // https://github.com/electron/electron/blob/84a42a050e7d45225e69df5bd2d2bf9f1037ea41/shell/browser/login_handler.cc#L70\n}\n\ntype LoginEvent = {\n\tevent?: ElectronEvent;\n\tauthInfo: AuthInfo;\n\tcallback?: (username?: string, password?: string) => void;\n};\n\nexport const IProxyAuthService = createDecorator<IProxyAuthService>('proxyAuthService');\n\nexport interface IProxyAuthService {\n\tlookupAuthorization(authInfo: AuthInfo): Promise<Credentials | undefined>;\n}\n\nexport class ProxyAuthService extends Disposable implements IProxyAuthService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly PROXY_CREDENTIALS_SERVICE_KEY = 'proxy-credentials://';\n\n\tprivate pendingProxyResolves = new Map<string, Promise<Credentials | undefined>>();\n\tprivate currentDialog: Promise<Credentials | undefined> | undefined = undefined;\n\n\tprivate cancelledAuthInfoHashes = new Set<string>();\n\n\tprivate sessionCredentials = new Map<string, Credentials | undefined>();\n\n\tconstructor(\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IWindowsMainService private readonly windowsMainService: IWindowsMainService,\n\t\t@IEncryptionMainService private readonly encryptionMainService: IEncryptionMainService,\n\t\t@IApplicationStorageMainService private readonly applicationStorageMainService: IApplicationStorageMainService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t\t@IEnvironmentMainService private readonly environmentMainService: IEnvironmentMainService,\n\t) {\n\t\tsuper();\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tconst onLogin = Event.fromNodeEventEmitter<LoginEvent>(app, 'login', (event: ElectronEvent, _webContents: WebContents, req: ElectronAuthenticationResponseDetails, authInfo: ElectronAuthInfo, callback) => ({ event, authInfo: { ...authInfo, attempt: req.firstAuthAttempt ? 1 : 2 }, callback } satisfies LoginEvent));\n\t\tthis._register(onLogin(this.onLogin, this));\n\t}\n\n\tasync lookupAuthorization(authInfo: AuthInfo): Promise<Credentials | undefined> {\n\t\treturn this.onLogin({ authInfo });\n\t}\n\n\tprivate async onLogin({ event, authInfo, callback }: LoginEvent): Promise<Credentials | undefined> {\n\t\tif (!authInfo.isProxy) {\n\t\t\treturn; // only for proxy\n\t\t}\n\n\t\t// Signal we handle this event on our own, otherwise\n\t\t// Electron will ignore our provided credentials.\n\t\tevent?.preventDefault();\n\n\t\t// Compute a hash over the authentication info to be used\n\t\t// with the credentials store to return the right credentials\n\t\t// given the properties of the auth request\n\t\t// (see https://github.com/microsoft/vscode/issues/109497)\n\t\tconst authInfoHash = String(hash({ scheme: authInfo.scheme, host: authInfo.host, port: authInfo.port }));\n\n\t\tlet credentials: Credentials | undefined = undefined;\n\t\tlet pendingProxyResolve = this.pendingProxyResolves.get(authInfoHash);\n\t\tif (!pendingProxyResolve) {\n\t\t\tthis.logService.trace('auth#onLogin (proxy) - no pending proxy handling found, starting new');\n\n\t\t\tpendingProxyResolve = this.resolveProxyCredentials(authInfo, authInfoHash);\n\t\t\tthis.pendingProxyResolves.set(authInfoHash, pendingProxyResolve);\n\t\t\ttry {\n\t\t\t\tcredentials = await pendingProxyResolve;\n\t\t\t} finally {\n\t\t\t\tthis.pendingProxyResolves.delete(authInfoHash);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.logService.trace('auth#onLogin (proxy) - pending proxy handling found');\n\n\t\t\tcredentials = await pendingProxyResolve;\n\t\t}\n\n\t\t// According to Electron docs, it is fine to call back without\n\t\t// username or password to signal that the authentication was handled\n\t\t// by us, even though without having credentials received:\n\t\t//\n\t\t// > If `callback` is called without a username or password, the authentication\n\t\t// > request will be cancelled and the authentication error will be returned to the\n\t\t// > page.\n\t\tcallback?.(credentials?.username, credentials?.password);\n\t\treturn credentials;\n\t}\n\n\tprivate async resolveProxyCredentials(authInfo: AuthInfo, authInfoHash: string): Promise<Credentials | undefined> {\n\t\tthis.logService.trace('auth#resolveProxyCredentials (proxy) - enter');\n\n\t\ttry {\n\t\t\tconst credentials = await this.doResolveProxyCredentials(authInfo, authInfoHash);\n\t\t\tif (credentials) {\n\t\t\t\tthis.logService.trace('auth#resolveProxyCredentials (proxy) - got credentials');\n\n\t\t\t\treturn credentials;\n\t\t\t} else {\n\t\t\t\tthis.logService.trace('auth#resolveProxyCredentials (proxy) - did not get credentials');\n\t\t\t}\n\t\t} finally {\n\t\t\tthis.logService.trace('auth#resolveProxyCredentials (proxy) - exit');\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate async doResolveProxyCredentials(authInfo: AuthInfo, authInfoHash: string): Promise<Credentials | undefined> {\n\t\tthis.logService.trace('auth#doResolveProxyCredentials - enter', authInfo);\n\n\t\t// For testing.\n\t\tif (this.environmentMainService.extensionTestsLocationURI) {\n\t\t\tconst credentials = this.configurationService.getValue<string>('integration-test.http.proxyAuth');\n\t\t\tif (credentials) {\n\t\t\t\tconst j = credentials.indexOf(':');\n\t\t\t\tif (j !== -1) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tusername: credentials.substring(0, j),\n\t\t\t\t\t\tpassword: credentials.substring(j + 1)\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tusername: credentials,\n\t\t\t\t\t\tpassword: ''\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Reply with manually supplied credentials. Fail if they are wrong.\n\t\tconst newHttpProxy = (this.configurationService.getValue<string>('http.proxy') || '').trim()\n\t\t\t|| (process.env['https_proxy'] || process.env['HTTPS_PROXY'] || process.env['http_proxy'] || process.env['HTTP_PROXY'] || '').trim()\n\t\t\t|| undefined;\n\n\t\tif (newHttpProxy?.indexOf('@') !== -1) {\n\t\t\tconst uri = URI.parse(newHttpProxy!);\n\t\t\tconst i = uri.authority.indexOf('@');\n\t\t\tif (i !== -1) {\n\t\t\t\tif (authInfo.attempt > 1) {\n\t\t\t\t\tthis.logService.trace('auth#doResolveProxyCredentials (proxy) - exit - ignoring previously used config/envvar credentials');\n\t\t\t\t\treturn undefined; // We tried already, let the user handle it.\n\t\t\t\t}\n\t\t\t\tthis.logService.trace('auth#doResolveProxyCredentials (proxy) - exit - found config/envvar credentials to use');\n\t\t\t\tconst credentials = uri.authority.substring(0, i);\n\t\t\t\tconst j = credentials.indexOf(':');\n\t\t\t\tif (j !== -1) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tusername: credentials.substring(0, j),\n\t\t\t\t\t\tpassword: credentials.substring(j + 1)\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tusername: credentials,\n\t\t\t\t\t\tpassword: ''\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Reply with session credentials unless we used them already.\n\t\t// In that case we need to show a login dialog again because\n\t\t// they seem invalid.\n\t\tconst sessionCredentials = authInfo.attempt === 1 && this.sessionCredentials.get(authInfoHash);\n\t\tif (sessionCredentials) {\n\t\t\tthis.logService.trace('auth#doResolveProxyCredentials (proxy) - exit - found session credentials to use');\n\n\t\t\tconst { username, password } = sessionCredentials;\n\t\t\treturn { username, password };\n\t\t}\n\n\t\tlet storedUsername: string | undefined;\n\t\tlet storedPassword: string | undefined;\n\t\ttry {\n\t\t\t// Try to find stored credentials for the given auth info\n\t\t\tconst encryptedValue = this.applicationStorageMainService.get(this.PROXY_CREDENTIALS_SERVICE_KEY + authInfoHash, StorageScope.APPLICATION);\n\t\t\tif (encryptedValue) {\n\t\t\t\tconst credentials: Credentials = JSON.parse(await this.encryptionMainService.decrypt(encryptedValue));\n\t\t\t\tstoredUsername = credentials.username;\n\t\t\t\tstoredPassword = credentials.password;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.logService.error(error); // handle errors by asking user for login via dialog\n\t\t}\n\n\t\t// Reply with stored credentials unless we used them already.\n\t\t// In that case we need to show a login dialog again because\n\t\t// they seem invalid.\n\t\tif (authInfo.attempt === 1 && typeof storedUsername === 'string' && typeof storedPassword === 'string') {\n\t\t\tthis.logService.trace('auth#doResolveProxyCredentials (proxy) - exit - found stored credentials to use');\n\n\t\t\tthis.sessionCredentials.set(authInfoHash, { username: storedUsername, password: storedPassword });\n\t\t\treturn { username: storedUsername, password: storedPassword };\n\t\t}\n\n\t\tconst previousDialog = this.currentDialog;\n\t\tconst currentDialog = this.currentDialog = (async () => {\n\t\t\tawait previousDialog;\n\t\t\tconst credentials = await this.showProxyCredentialsDialog(authInfo, authInfoHash, storedUsername, storedPassword);\n\t\t\tif (this.currentDialog === currentDialog!) {\n\t\t\t\tthis.currentDialog = undefined;\n\t\t\t}\n\t\t\treturn credentials;\n\t\t})();\n\t\treturn currentDialog;\n\t}\n\n\tprivate async showProxyCredentialsDialog(authInfo: AuthInfo, authInfoHash: string, storedUsername: string | undefined, storedPassword: string | undefined): Promise<Credentials | undefined> {\n\t\tif (this.cancelledAuthInfoHashes.has(authInfoHash)) {\n\t\t\tthis.logService.trace('auth#doResolveProxyCredentials (proxy) - exit - login dialog was cancelled before, not showing again');\n\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Find suitable window to show dialog: prefer to show it in the\n\t\t// active window because any other network request will wait on\n\t\t// the credentials and we want the user to present the dialog.\n\t\tconst window = this.windowsMainService.getFocusedWindow() || this.windowsMainService.getLastActiveWindow();\n\t\tif (!window) {\n\t\t\tthis.logService.trace('auth#doResolveProxyCredentials (proxy) - exit - no opened window found to show dialog in');\n\n\t\t\treturn undefined; // unexpected\n\t\t}\n\n\t\tthis.logService.trace(`auth#doResolveProxyCredentials (proxy) - asking window ${window.id} to handle proxy login`);\n\n\t\t// Open proxy dialog\n\t\tconst sessionCredentials = this.sessionCredentials.get(authInfoHash);\n\t\tconst payload = {\n\t\t\tauthInfo,\n\t\t\tusername: sessionCredentials?.username ?? storedUsername, // prefer to show already used username (if any) over stored\n\t\t\tpassword: sessionCredentials?.password ?? storedPassword, // prefer to show already used password (if any) over stored\n\t\t\treplyChannel: `vscode:proxyAuthResponse:${generateUuid()}`\n\t\t};\n\t\twindow.sendWhenReady('vscode:openProxyAuthenticationDialog', CancellationToken.None, payload);\n\n\t\t// Handle reply\n\t\tconst loginDialogCredentials = await new Promise<Credentials | undefined>(resolve => {\n\t\t\tconst proxyAuthResponseHandler = async (event: ElectronEvent, channel: string, reply: Credentials & { remember: boolean } | undefined /* canceled */) => {\n\t\t\t\tif (channel === payload.replyChannel) {\n\t\t\t\t\tthis.logService.trace(`auth#doResolveProxyCredentials - exit - received credentials from window ${window.id}`);\n\t\t\t\t\twindow.win?.webContents.off('ipc-message', proxyAuthResponseHandler);\n\n\t\t\t\t\t// We got credentials from the window\n\t\t\t\t\tif (reply) {\n\t\t\t\t\t\tconst credentials: Credentials = { username: reply.username, password: reply.password };\n\n\t\t\t\t\t\t// Update stored credentials based on `remember` flag\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (reply.remember) {\n\t\t\t\t\t\t\t\tconst encryptedSerializedCredentials = await this.encryptionMainService.encrypt(JSON.stringify(credentials));\n\t\t\t\t\t\t\t\tthis.applicationStorageMainService.store(\n\t\t\t\t\t\t\t\t\tthis.PROXY_CREDENTIALS_SERVICE_KEY + authInfoHash,\n\t\t\t\t\t\t\t\t\tencryptedSerializedCredentials,\n\t\t\t\t\t\t\t\t\tStorageScope.APPLICATION,\n\t\t\t\t\t\t\t\t\t// Always store in machine scope because we do not want these values to be synced\n\t\t\t\t\t\t\t\t\tStorageTarget.MACHINE\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.applicationStorageMainService.remove(this.PROXY_CREDENTIALS_SERVICE_KEY + authInfoHash, StorageScope.APPLICATION);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tthis.logService.error(error); // handle gracefully\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresolve({ username: credentials.username, password: credentials.password });\n\t\t\t\t\t}\n\n\t\t\t\t\t// We did not get any credentials from the window (e.g. cancelled)\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.cancelledAuthInfoHashes.add(authInfoHash);\n\t\t\t\t\t\tresolve(undefined);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\twindow.win?.webContents.on('ipc-message', proxyAuthResponseHandler);\n\t\t});\n\n\t\t// Remember credentials for the session in case\n\t\t// the credentials are wrong and we show the dialog\n\t\t// again\n\t\tthis.sessionCredentials.set(authInfoHash, loginDialogCredentials);\n\n\t\treturn loginDialogCredentials;\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
