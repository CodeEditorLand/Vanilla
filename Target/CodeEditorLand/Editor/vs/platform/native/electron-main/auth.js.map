{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/native/electron-main/auth.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport {\n\ttype AuthenticationResponseDetails,\n\ttype AuthInfo as ElectronAuthInfo,\n\ttype Event as ElectronEvent,\n\ttype WebContents,\n\tapp,\n} from \"electron\";\nimport { CancellationToken } from \"../../../base/common/cancellation.js\";\nimport { Event } from \"../../../base/common/event.js\";\nimport { hash } from \"../../../base/common/hash.js\";\nimport { Disposable } from \"../../../base/common/lifecycle.js\";\nimport { URI } from \"../../../base/common/uri.js\";\nimport { generateUuid } from \"../../../base/common/uuid.js\";\nimport { IConfigurationService } from \"../../configuration/common/configuration.js\";\nimport { IEncryptionMainService } from \"../../encryption/common/encryptionService.js\";\nimport { IEnvironmentMainService } from \"../../environment/electron-main/environmentMainService.js\";\nimport { createDecorator } from \"../../instantiation/common/instantiation.js\";\nimport { ILogService } from \"../../log/common/log.js\";\nimport type { AuthInfo, Credentials } from \"../../request/common/request.js\";\nimport { StorageScope, StorageTarget } from \"../../storage/common/storage.js\";\nimport { IApplicationStorageMainService } from \"../../storage/electron-main/storageMainService.js\";\nimport { IWindowsMainService } from \"../../windows/electron-main/windows.js\";\n\ninterface ElectronAuthenticationResponseDetails\n\textends AuthenticationResponseDetails {\n\tfirstAuthAttempt?: boolean; // https://github.com/electron/electron/blob/84a42a050e7d45225e69df5bd2d2bf9f1037ea41/shell/browser/login_handler.cc#L70\n}\n\ntype LoginEvent = {\n\tevent?: ElectronEvent;\n\tauthInfo: AuthInfo;\n\tcallback?: (username?: string, password?: string) => void;\n};\n\nexport const IProxyAuthService =\n\tcreateDecorator<IProxyAuthService>(\"proxyAuthService\");\n\nexport interface IProxyAuthService {\n\tlookupAuthorization(authInfo: AuthInfo): Promise<Credentials | undefined>;\n}\n\nexport class ProxyAuthService extends Disposable implements IProxyAuthService {\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly PROXY_CREDENTIALS_SERVICE_KEY = \"proxy-credentials://\";\n\n\tprivate pendingProxyResolves = new Map<\n\t\tstring,\n\t\tPromise<Credentials | undefined>\n\t>();\n\tprivate currentDialog: Promise<Credentials | undefined> | undefined =\n\t\tundefined;\n\n\tprivate cancelledAuthInfoHashes = new Set<string>();\n\n\tprivate sessionCredentials = new Map<string, Credentials | undefined>();\n\n\tconstructor(\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IWindowsMainService private readonly windowsMainService: IWindowsMainService,\n\t\t@IEncryptionMainService private readonly encryptionMainService: IEncryptionMainService,\n\t\t@IApplicationStorageMainService private readonly applicationStorageMainService: IApplicationStorageMainService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t\t@IEnvironmentMainService private readonly environmentMainService: IEnvironmentMainService,\n\t) {\n\t\tsuper();\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tconst onLogin = Event.fromNodeEventEmitter<LoginEvent>(\n\t\t\tapp,\n\t\t\t\"login\",\n\t\t\t(\n\t\t\t\tevent: ElectronEvent,\n\t\t\t\t_webContents: WebContents,\n\t\t\t\treq: ElectronAuthenticationResponseDetails,\n\t\t\t\tauthInfo: ElectronAuthInfo,\n\t\t\t\tcallback,\n\t\t\t) =>\n\t\t\t\t({\n\t\t\t\t\tevent,\n\t\t\t\t\tauthInfo: {\n\t\t\t\t\t\t...authInfo,\n\t\t\t\t\t\tattempt: req.firstAuthAttempt ? 1 : 2,\n\t\t\t\t\t},\n\t\t\t\t\tcallback,\n\t\t\t\t}) satisfies LoginEvent,\n\t\t);\n\t\tthis._register(onLogin(this.onLogin, this));\n\t}\n\n\tasync lookupAuthorization(\n\t\tauthInfo: AuthInfo,\n\t): Promise<Credentials | undefined> {\n\t\treturn this.onLogin({ authInfo });\n\t}\n\n\tprivate async onLogin({\n\t\tevent,\n\t\tauthInfo,\n\t\tcallback,\n\t}: LoginEvent): Promise<Credentials | undefined> {\n\t\tif (!authInfo.isProxy) {\n\t\t\treturn; // only for proxy\n\t\t}\n\n\t\t// Signal we handle this event on our own, otherwise\n\t\t// Electron will ignore our provided credentials.\n\t\tevent?.preventDefault();\n\n\t\t// Compute a hash over the authentication info to be used\n\t\t// with the credentials store to return the right credentials\n\t\t// given the properties of the auth request\n\t\t// (see https://github.com/microsoft/vscode/issues/109497)\n\t\tconst authInfoHash = String(\n\t\t\thash({\n\t\t\t\tscheme: authInfo.scheme,\n\t\t\t\thost: authInfo.host,\n\t\t\t\tport: authInfo.port,\n\t\t\t}),\n\t\t);\n\n\t\tlet credentials: Credentials | undefined;\n\t\tlet pendingProxyResolve = this.pendingProxyResolves.get(authInfoHash);\n\t\tif (pendingProxyResolve) {\n\t\t\tthis.logService.trace(\n\t\t\t\t\"auth#onLogin (proxy) - pending proxy handling found\",\n\t\t\t);\n\n\t\t\tcredentials = await pendingProxyResolve;\n\t\t} else {\n\t\t\tthis.logService.trace(\n\t\t\t\t\"auth#onLogin (proxy) - no pending proxy handling found, starting new\",\n\t\t\t);\n\n\t\t\tpendingProxyResolve = this.resolveProxyCredentials(\n\t\t\t\tauthInfo,\n\t\t\t\tauthInfoHash,\n\t\t\t);\n\t\t\tthis.pendingProxyResolves.set(authInfoHash, pendingProxyResolve);\n\t\t\ttry {\n\t\t\t\tcredentials = await pendingProxyResolve;\n\t\t\t} finally {\n\t\t\t\tthis.pendingProxyResolves.delete(authInfoHash);\n\t\t\t}\n\t\t}\n\n\t\t// According to Electron docs, it is fine to call back without\n\t\t// username or password to signal that the authentication was handled\n\t\t// by us, even though without having credentials received:\n\t\t//\n\t\t// > If `callback` is called without a username or password, the authentication\n\t\t// > request will be cancelled and the authentication error will be returned to the\n\t\t// > page.\n\t\tcallback?.(credentials?.username, credentials?.password);\n\t\treturn credentials;\n\t}\n\n\tprivate async resolveProxyCredentials(\n\t\tauthInfo: AuthInfo,\n\t\tauthInfoHash: string,\n\t): Promise<Credentials | undefined> {\n\t\tthis.logService.trace(\"auth#resolveProxyCredentials (proxy) - enter\");\n\n\t\ttry {\n\t\t\tconst credentials = await this.doResolveProxyCredentials(\n\t\t\t\tauthInfo,\n\t\t\t\tauthInfoHash,\n\t\t\t);\n\t\t\tif (credentials) {\n\t\t\t\tthis.logService.trace(\n\t\t\t\t\t\"auth#resolveProxyCredentials (proxy) - got credentials\",\n\t\t\t\t);\n\n\t\t\t\treturn credentials;\n\t\t\t} else {\n\t\t\t\tthis.logService.trace(\n\t\t\t\t\t\"auth#resolveProxyCredentials (proxy) - did not get credentials\",\n\t\t\t\t);\n\t\t\t}\n\t\t} finally {\n\t\t\tthis.logService.trace(\n\t\t\t\t\"auth#resolveProxyCredentials (proxy) - exit\",\n\t\t\t);\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate async doResolveProxyCredentials(\n\t\tauthInfo: AuthInfo,\n\t\tauthInfoHash: string,\n\t): Promise<Credentials | undefined> {\n\t\tthis.logService.trace(\n\t\t\t\"auth#doResolveProxyCredentials - enter\",\n\t\t\tauthInfo,\n\t\t);\n\n\t\t// For testing.\n\t\tif (this.environmentMainService.extensionTestsLocationURI) {\n\t\t\tconst credentials = this.configurationService.getValue<string>(\n\t\t\t\t\"integration-test.http.proxyAuth\",\n\t\t\t);\n\t\t\tif (credentials) {\n\t\t\t\tconst j = credentials.indexOf(\":\");\n\t\t\t\tif (j !== -1) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tusername: credentials.substring(0, j),\n\t\t\t\t\t\tpassword: credentials.substring(j + 1),\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tusername: credentials,\n\t\t\t\t\t\tpassword: \"\",\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Reply with manually supplied credentials. Fail if they are wrong.\n\t\tconst newHttpProxy =\n\t\t\t(\n\t\t\t\tthis.configurationService.getValue<string>(\"http.proxy\") || \"\"\n\t\t\t).trim() ||\n\t\t\t(\n\t\t\t\tprocess.env[\"https_proxy\"] ||\n\t\t\t\tprocess.env[\"HTTPS_PROXY\"] ||\n\t\t\t\tprocess.env[\"http_proxy\"] ||\n\t\t\t\tprocess.env[\"HTTP_PROXY\"] ||\n\t\t\t\t\"\"\n\t\t\t).trim() ||\n\t\t\tundefined;\n\n\t\tif (newHttpProxy?.indexOf(\"@\") !== -1) {\n\t\t\tconst uri = URI.parse(newHttpProxy!);\n\t\t\tconst i = uri.authority.indexOf(\"@\");\n\t\t\tif (i !== -1) {\n\t\t\t\tif (authInfo.attempt > 1) {\n\t\t\t\t\tthis.logService.trace(\n\t\t\t\t\t\t\"auth#doResolveProxyCredentials (proxy) - exit - ignoring previously used config/envvar credentials\",\n\t\t\t\t\t);\n\t\t\t\t\treturn undefined; // We tried already, let the user handle it.\n\t\t\t\t}\n\t\t\t\tthis.logService.trace(\n\t\t\t\t\t\"auth#doResolveProxyCredentials (proxy) - exit - found config/envvar credentials to use\",\n\t\t\t\t);\n\t\t\t\tconst credentials = uri.authority.substring(0, i);\n\t\t\t\tconst j = credentials.indexOf(\":\");\n\t\t\t\tif (j !== -1) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tusername: credentials.substring(0, j),\n\t\t\t\t\t\tpassword: credentials.substring(j + 1),\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tusername: credentials,\n\t\t\t\t\t\tpassword: \"\",\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Reply with session credentials unless we used them already.\n\t\t// In that case we need to show a login dialog again because\n\t\t// they seem invalid.\n\t\tconst sessionCredentials =\n\t\t\tauthInfo.attempt === 1 && this.sessionCredentials.get(authInfoHash);\n\t\tif (sessionCredentials) {\n\t\t\tthis.logService.trace(\n\t\t\t\t\"auth#doResolveProxyCredentials (proxy) - exit - found session credentials to use\",\n\t\t\t);\n\n\t\t\tconst { username, password } = sessionCredentials;\n\t\t\treturn { username, password };\n\t\t}\n\n\t\tlet storedUsername: string | undefined;\n\t\tlet storedPassword: string | undefined;\n\t\ttry {\n\t\t\t// Try to find stored credentials for the given auth info\n\t\t\tconst encryptedValue = this.applicationStorageMainService.get(\n\t\t\t\tthis.PROXY_CREDENTIALS_SERVICE_KEY + authInfoHash,\n\t\t\t\tStorageScope.APPLICATION,\n\t\t\t);\n\t\t\tif (encryptedValue) {\n\t\t\t\tconst credentials: Credentials = JSON.parse(\n\t\t\t\t\tawait this.encryptionMainService.decrypt(encryptedValue),\n\t\t\t\t);\n\t\t\t\tstoredUsername = credentials.username;\n\t\t\t\tstoredPassword = credentials.password;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.logService.error(error); // handle errors by asking user for login via dialog\n\t\t}\n\n\t\t// Reply with stored credentials unless we used them already.\n\t\t// In that case we need to show a login dialog again because\n\t\t// they seem invalid.\n\t\tif (\n\t\t\tauthInfo.attempt === 1 &&\n\t\t\ttypeof storedUsername === \"string\" &&\n\t\t\ttypeof storedPassword === \"string\"\n\t\t) {\n\t\t\tthis.logService.trace(\n\t\t\t\t\"auth#doResolveProxyCredentials (proxy) - exit - found stored credentials to use\",\n\t\t\t);\n\n\t\t\tthis.sessionCredentials.set(authInfoHash, {\n\t\t\t\tusername: storedUsername,\n\t\t\t\tpassword: storedPassword,\n\t\t\t});\n\t\t\treturn { username: storedUsername, password: storedPassword };\n\t\t}\n\n\t\tconst previousDialog = this.currentDialog;\n\t\tconst currentDialog = (this.currentDialog = (async () => {\n\t\t\tawait previousDialog;\n\t\t\tconst credentials = await this.showProxyCredentialsDialog(\n\t\t\t\tauthInfo,\n\t\t\t\tauthInfoHash,\n\t\t\t\tstoredUsername,\n\t\t\t\tstoredPassword,\n\t\t\t);\n\t\t\tif (this.currentDialog === currentDialog!) {\n\t\t\t\tthis.currentDialog = undefined;\n\t\t\t}\n\t\t\treturn credentials;\n\t\t})());\n\t\treturn currentDialog;\n\t}\n\n\tprivate async showProxyCredentialsDialog(\n\t\tauthInfo: AuthInfo,\n\t\tauthInfoHash: string,\n\t\tstoredUsername: string | undefined,\n\t\tstoredPassword: string | undefined,\n\t): Promise<Credentials | undefined> {\n\t\tif (this.cancelledAuthInfoHashes.has(authInfoHash)) {\n\t\t\tthis.logService.trace(\n\t\t\t\t\"auth#doResolveProxyCredentials (proxy) - exit - login dialog was cancelled before, not showing again\",\n\t\t\t);\n\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Find suitable window to show dialog: prefer to show it in the\n\t\t// active window because any other network request will wait on\n\t\t// the credentials and we want the user to present the dialog.\n\t\tconst window =\n\t\t\tthis.windowsMainService.getFocusedWindow() ||\n\t\t\tthis.windowsMainService.getLastActiveWindow();\n\t\tif (!window) {\n\t\t\tthis.logService.trace(\n\t\t\t\t\"auth#doResolveProxyCredentials (proxy) - exit - no opened window found to show dialog in\",\n\t\t\t);\n\n\t\t\treturn undefined; // unexpected\n\t\t}\n\n\t\tthis.logService.trace(\n\t\t\t`auth#doResolveProxyCredentials (proxy) - asking window ${window.id} to handle proxy login`,\n\t\t);\n\n\t\t// Open proxy dialog\n\t\tconst sessionCredentials = this.sessionCredentials.get(authInfoHash);\n\t\tconst payload = {\n\t\t\tauthInfo,\n\t\t\tusername: sessionCredentials?.username ?? storedUsername, // prefer to show already used username (if any) over stored\n\t\t\tpassword: sessionCredentials?.password ?? storedPassword, // prefer to show already used password (if any) over stored\n\t\t\treplyChannel: `vscode:proxyAuthResponse:${generateUuid()}`,\n\t\t};\n\t\twindow.sendWhenReady(\n\t\t\t\"vscode:openProxyAuthenticationDialog\",\n\t\t\tCancellationToken.None,\n\t\t\tpayload,\n\t\t);\n\n\t\t// Handle reply\n\t\tconst loginDialogCredentials = await new Promise<\n\t\t\tCredentials | undefined\n\t\t>((resolve) => {\n\t\t\tconst proxyAuthResponseHandler = async (\n\t\t\t\tevent: ElectronEvent,\n\t\t\t\tchannel: string,\n\t\t\t\treply:\n\t\t\t\t\t| (Credentials & { remember: boolean })\n\t\t\t\t\t| undefined /* canceled */,\n\t\t\t) => {\n\t\t\t\tif (channel === payload.replyChannel) {\n\t\t\t\t\tthis.logService.trace(\n\t\t\t\t\t\t`auth#doResolveProxyCredentials - exit - received credentials from window ${window.id}`,\n\t\t\t\t\t);\n\t\t\t\t\twindow.win?.webContents.off(\n\t\t\t\t\t\t\"ipc-message\",\n\t\t\t\t\t\tproxyAuthResponseHandler,\n\t\t\t\t\t);\n\n\t\t\t\t\t// We got credentials from the window\n\t\t\t\t\tif (reply) {\n\t\t\t\t\t\tconst credentials: Credentials = {\n\t\t\t\t\t\t\tusername: reply.username,\n\t\t\t\t\t\t\tpassword: reply.password,\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// Update stored credentials based on `remember` flag\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (reply.remember) {\n\t\t\t\t\t\t\t\tconst encryptedSerializedCredentials =\n\t\t\t\t\t\t\t\t\tawait this.encryptionMainService.encrypt(\n\t\t\t\t\t\t\t\t\t\tJSON.stringify(credentials),\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tthis.applicationStorageMainService.store(\n\t\t\t\t\t\t\t\t\tthis.PROXY_CREDENTIALS_SERVICE_KEY +\n\t\t\t\t\t\t\t\t\t\tauthInfoHash,\n\t\t\t\t\t\t\t\t\tencryptedSerializedCredentials,\n\t\t\t\t\t\t\t\t\tStorageScope.APPLICATION,\n\t\t\t\t\t\t\t\t\t// Always store in machine scope because we do not want these values to be synced\n\t\t\t\t\t\t\t\t\tStorageTarget.MACHINE,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.applicationStorageMainService.remove(\n\t\t\t\t\t\t\t\t\tthis.PROXY_CREDENTIALS_SERVICE_KEY +\n\t\t\t\t\t\t\t\t\t\tauthInfoHash,\n\t\t\t\t\t\t\t\t\tStorageScope.APPLICATION,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tthis.logService.error(error); // handle gracefully\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresolve({\n\t\t\t\t\t\t\tusername: credentials.username,\n\t\t\t\t\t\t\tpassword: credentials.password,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\t// We did not get any credentials from the window (e.g. cancelled)\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.cancelledAuthInfoHashes.add(authInfoHash);\n\t\t\t\t\t\tresolve(undefined);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\twindow.win?.webContents.on(\"ipc-message\", proxyAuthResponseHandler);\n\t\t});\n\n\t\t// Remember credentials for the session in case\n\t\t// the credentials are wrong and we show the dialog\n\t\t// again\n\t\tthis.sessionCredentials.set(authInfoHash, loginDialogCredentials);\n\n\t\treturn loginDialogCredentials;\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
