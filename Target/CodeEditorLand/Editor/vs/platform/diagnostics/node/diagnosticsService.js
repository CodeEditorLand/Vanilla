var A=Object.defineProperty;var B=Object.getOwnPropertyDescriptor;var C=(m,e,t,s)=>{for(var r=s>1?void 0:s?B(e,t):e,o=m.length-1,n;o>=0;o--)(n=m[o])&&(r=(s?n(e,t,r):n(r))||r);return s&&r&&A(e,t,r),r},k=(m,e)=>(t,s)=>e(t,s,m);import*as G from"fs";import*as p from"os";import{Promises as D}from"../../../base/common/async.js";import{getNodeType as H,parse as O}from"../../../base/common/json.js";import{Schemas as v}from"../../../base/common/network.js";import{basename as _,join as W}from"../../../base/common/path.js";import{isLinux as N,isWindows as E}from"../../../base/common/platform.js";import"../../../base/common/processes.js";import{StopWatch as V}from"../../../base/common/stopwatch.js";import{URI as M}from"../../../base/common/uri.js";import{virtualMachineHint as x}from"../../../base/node/id.js";import{Promises as K}from"../../../base/node/pfs.js";import{listProcesses as R}from"../../../base/node/ps.js";import{isRemoteDiagnosticError as T}from"../common/diagnostics.js";import{ByteSize as I}from"../../files/common/files.js";import{IProductService as X}from"../../product/common/productService.js";import{ITelemetryService as z}from"../../telemetry/common/telemetry.js";import"../../workspace/common/workspace.js";const L=new Map;async function j(m,e){const t=`${m}::${e.join(":")}`,s=L.get(t);if(s)return s;const r=[{tag:"grunt.js",filePattern:/^gruntfile\.js$/i},{tag:"gulp.js",filePattern:/^gulpfile\.js$/i},{tag:"tsconfig.json",filePattern:/^tsconfig\.json$/i},{tag:"package.json",filePattern:/^package\.json$/i},{tag:"jsconfig.json",filePattern:/^jsconfig\.json$/i},{tag:"tslint.json",filePattern:/^tslint\.json$/i},{tag:"eslint.json",filePattern:/^eslint\.json$/i},{tag:"tasks.json",filePattern:/^tasks\.json$/i},{tag:"launch.json",filePattern:/^launch\.json$/i},{tag:"settings.json",filePattern:/^settings\.json$/i},{tag:"webpack.config.js",filePattern:/^webpack\.config\.js$/i},{tag:"project.json",filePattern:/^project\.json$/i},{tag:"makefile",filePattern:/^makefile$/i},{tag:"sln",filePattern:/^.+\.sln$/i},{tag:"csproj",filePattern:/^.+\.csproj$/i},{tag:"cmake",filePattern:/^.+\.cmake$/i},{tag:"github-actions",filePattern:/^.+\.ya?ml$/i,relativePathPattern:/^\.github(?:\/|\\)workflows$/i},{tag:"devcontainer.json",filePattern:/^devcontainer\.json$/i},{tag:"dockerfile",filePattern:/^(dockerfile|docker\-compose\.ya?ml)$/i},{tag:"cursorrules",filePattern:/^\.cursorrules$/i}],o=new Map,n=new Map,a=2e4;function c(l,f,$,u){const U=f.substring(l.length+1);return D.withAsyncBody(async S=>{let d;u.readdirCount++;try{d=await K.readdir(f,{withFileTypes:!0})}catch{S();return}if(u.count>=a){u.count+=d.length,u.maxReached=!0,S();return}let y=d.length;if(y===0){S();return}let b=d;u.count+d.length>a&&(u.maxReached=!0,y=a-u.count,b=d.slice(0,y)),u.count+=d.length;for(const g of b)if(g.isDirectory()){if($.includes(g.name)||await c(l,W(f,g.name),$,u),--y===0){S();return}}else{const w=g.name.lastIndexOf(".");if(w>=0){const h=g.name.substring(w+1);h&&o.set(h,(o.get(h)??0)+1)}for(const h of r)h.relativePathPattern?.test(U)!==!1&&h.filePattern.test(g.name)&&n.set(h.tag,(n.get(h.tag)??0)+1);if(--y===0){S();return}}})}const i=D.withAsyncBody(async l=>{const f={count:0,maxReached:!1,readdirCount:0},$=new V(!0);await c(m,m,e,f);const u=await q(m);l({configFiles:F(n),fileTypes:F(o),fileCount:f.count,maxFilesReached:f.maxReached,launchConfigFiles:u,totalScanTime:$.elapsed(),totalReaddirCount:f.readdirCount})});return L.set(t,i),i}function F(m){return Array.from(m.entries(),([e,t])=>({name:e,count:t})).sort((e,t)=>t.count-e.count)}function Y(){const m={os:`${p.type()} ${p.arch()} ${p.release()}`,memory:`${(p.totalmem()/I.GB).toFixed(2)}GB (${(p.freemem()/I.GB).toFixed(2)}GB free)`,vmHint:`${Math.round(x.value()*100)}%`},e=p.cpus();return e&&e.length>0&&(m.cpus=`${e[0].model} (${e.length} x ${e[0].speed})`),m}async function q(m){try{const e=new Map,t=W(m,".vscode","launch.json"),s=await G.promises.readFile(t),r=[],o=O(s.toString(),r);if(r.length)return[];if(H(o)==="object"&&o.configurations)for(const n of o.configurations){const a=n.type;a&&(e.has(a)?e.set(a,e.get(a)+1):e.set(a,1))}return F(e)}catch{return[]}}let P=class{constructor(e,t){this.telemetryService=e;this.productService=t}formatMachineInfo(e){const t=[];return t.push(`OS Version:       ${e.os}`),t.push(`CPUs:             ${e.cpus}`),t.push(`Memory (System):  ${e.memory}`),t.push(`VM:               ${e.vmHint}`),t.join(`
`)}formatEnvironment(e){const t=[];t.push(`Version:          ${this.productService.nameShort} ${this.productService.version} (${this.productService.commit||"Commit unknown"}, ${this.productService.date||"Date unknown"})`),t.push(`OS Version:       ${p.type()} ${p.arch()} ${p.release()}`);const s=p.cpus();return s&&s.length>0&&t.push(`CPUs:             ${s[0].model} (${s.length} x ${s[0].speed})`),t.push(`Memory (System):  ${(p.totalmem()/I.GB).toFixed(2)}GB (${(p.freemem()/I.GB).toFixed(2)}GB free)`),E||t.push(`Load (avg):       ${p.loadavg().map(r=>Math.round(r)).join(", ")}`),t.push(`VM:               ${Math.round(x.value()*100)}%`),t.push(`Screen Reader:    ${e.screenReader?"yes":"no"}`),t.push(`Process Argv:     ${e.mainArguments.join(" ")}`),t.push(`GPU Status:       ${this.expandGPUFeatures(e.gpuFeatureStatus)}`),t.join(`
`)}async getPerformanceInfo(e,t){return Promise.all([R(e.mainPID),this.formatWorkspaceMetadata(e)]).then(async s=>{let[r,o]=s,n=this.formatProcessList(e,r);return t.forEach(a=>{if(T(a))n+=`
${a.errorMessage}`,o+=`
${a.errorMessage}`;else if(n+=`

Remote: ${a.hostName}`,a.processes&&(n+=`
${this.formatProcessList(e,a.processes)}`),a.workspaceMetadata){o+=`
|  Remote: ${a.hostName}`;for(const c of Object.keys(a.workspaceMetadata)){const i=a.workspaceMetadata[c];let l=`${i.fileCount} files`;i.maxFilesReached&&(l=`more than ${l}`),o+=`|    Folder (${c}): ${l}`,o+=this.formatWorkspaceStats(i)}}}),{processInfo:n,workspaceInfo:o}})}async getSystemInfo(e,t){const{memory:s,vmHint:r,os:o,cpus:n}=Y(),a={os:o,memory:s,cpus:n,vmHint:r,processArgs:`${e.mainArguments.join(" ")}`,gpuStatus:e.gpuFeatureStatus,screenReader:`${e.screenReader?"yes":"no"}`,remoteData:t};return E||(a.load=`${p.loadavg().map(c=>Math.round(c)).join(", ")}`),N&&(a.linuxEnv={desktopSession:process.env.DESKTOP_SESSION,xdgSessionDesktop:process.env.XDG_SESSION_DESKTOP,xdgCurrentDesktop:process.env.XDG_CURRENT_DESKTOP,xdgSessionType:process.env.XDG_SESSION_TYPE}),Promise.resolve(a)}async getDiagnostics(e,t){const s=[];return R(e.mainPID).then(async r=>(s.push(""),s.push(this.formatEnvironment(e)),s.push(""),s.push(this.formatProcessList(e,r)),e.windows.some(o=>o.folderURIs&&o.folderURIs.length>0&&!o.remoteAuthority)&&(s.push(""),s.push("Workspace Stats: "),s.push(await this.formatWorkspaceMetadata(e))),t.forEach(o=>{if(T(o))s.push(`
${o.errorMessage}`);else if(s.push(`

`),s.push(`Remote:           ${o.hostName}`),s.push(this.formatMachineInfo(o.machineInfo)),o.processes&&s.push(this.formatProcessList(e,o.processes)),o.workspaceMetadata)for(const n of Object.keys(o.workspaceMetadata)){const a=o.workspaceMetadata[n];let c=`${a.fileCount} files`;a.maxFilesReached&&(c=`more than ${c}`),s.push(`Folder (${n}): ${c}`),s.push(this.formatWorkspaceStats(a))}}),s.push(""),s.push(""),s.join(`
`)))}formatWorkspaceStats(e){const t=[];let r=0;const o=(i,l)=>{const f=` ${i}(${l})`;r+f.length>60?(t.push(n),n="|                 ",r=n.length):r+=f.length,n+=f};let n="|      File types:";const a=10,c=e.fileTypes.length>a?a:e.fileTypes.length;for(let i=0;i<c;i++){const l=e.fileTypes[i];o(l.name,l.count)}if(t.push(n),e.configFiles.length>=0&&(n="|      Conf files:",r=0,e.configFiles.forEach(i=>{o(i.name,i.count)}),t.push(n)),e.launchConfigFiles.length>0){let i="|      Launch Configs:";e.launchConfigFiles.forEach(l=>{const f=l.count>1?` ${l.name}(${l.count})`:` ${l.name}`;i+=f}),t.push(i)}return t.join(`
`)}expandGPUFeatures(e){const t=Math.max(...Object.keys(e).map(s=>s.length));return Object.keys(e).map(s=>`${s}:  ${" ".repeat(t-s.length)}  ${e[s]}`).join(`
                  `)}formatWorkspaceMetadata(e){const t=[],s=[];return e.windows.forEach(r=>{r.folderURIs.length===0||r.remoteAuthority||(t.push(`|  Window (${r.title})`),r.folderURIs.forEach(o=>{const n=M.revive(o);if(n.scheme===v.file){const a=n.fsPath;s.push(j(a,["node_modules",".git"]).then(c=>{let i=`${c.fileCount} files`;c.maxFilesReached&&(i=`more than ${i}`),t.push(`|    Folder (${_(a)}): ${i}`),t.push(this.formatWorkspaceStats(c))}).catch(c=>{t.push(`|      Error: Unable to collect workspace stats for folder ${a} (${c.toString()})`)}))}else t.push(`|    Folder (${n.toString()}): Workspace stats not available.`)}))}),Promise.all(s).then(r=>t.join(`
`)).catch(r=>`Unable to collect workspace stats: ${r}`)}formatProcessList(e,t){const s=new Map;e.windows.forEach(o=>s.set(o.pid,`window [${o.id}] (${o.title})`)),e.pidToNames.forEach(({pid:o,name:n})=>s.set(o,n));const r=[];return r.push("CPU %	Mem MB	   PID	Process"),t&&this.formatProcessItem(e.mainPID,s,r,t,0),r.join(`
`)}formatProcessItem(e,t,s,r,o){const n=o===0;let a;n?a=r.pid===e?`${this.productService.applicationName} main`:"remote agent":t.has(r.pid)?a=t.get(r.pid):a=`${"  ".repeat(o)} ${r.name}`;const c=process.platform==="win32"?r.mem:p.totalmem()*(r.mem/100);s.push(`${r.load.toFixed(0).padStart(5," ")}	${(c/I.MB).toFixed(0).padStart(6," ")}	${r.pid.toFixed(0).padStart(6," ")}	${a}`),Array.isArray(r.children)&&r.children.forEach(i=>this.formatProcessItem(e,t,s,i,o+1))}async getWorkspaceFileExtensions(e){const t=new Set;for(const{uri:s}of e.folders){const r=M.revive(s);if(r.scheme!==v.file)continue;const o=r.fsPath;try{(await j(o,["node_modules",".git"])).fileTypes.forEach(a=>t.add(a.name))}catch{}}return{extensions:[...t]}}async reportWorkspaceStats(e){for(const{uri:t}of e.folders){const s=M.revive(t);if(s.scheme!==v.file)continue;const r=s.fsPath;try{const o=await j(r,["node_modules",".git"]);this.telemetryService.publicLog2("workspace.stats",{"workspace.id":e.telemetryId,rendererSessionId:e.rendererSessionId}),o.fileTypes.forEach(n=>{this.telemetryService.publicLog2("workspace.stats.file",{rendererSessionId:e.rendererSessionId,type:n.name,count:n.count})}),o.launchConfigFiles.forEach(n=>{this.telemetryService.publicLog2("workspace.stats.launchConfigFile",{rendererSessionId:e.rendererSessionId,type:n.name,count:n.count})}),o.configFiles.forEach(n=>{this.telemetryService.publicLog2("workspace.stats.configFiles",{rendererSessionId:e.rendererSessionId,type:n.name,count:n.count})}),this.telemetryService.publicLog2("workspace.stats.metadata",{duration:o.totalScanTime,reachedLimit:o.maxFilesReached,fileCount:o.fileCount,readdirCount:o.totalReaddirCount})}catch{}}}};P=C([k(0,z),k(1,X)],P);export{P as DiagnosticsService,q as collectLaunchConfigs,j as collectWorkspaceStats,Y as getMachineInfo};
