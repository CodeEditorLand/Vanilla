var k=Object.defineProperty;var F=Object.getOwnPropertyDescriptor;var E=(l,o,e,n)=>{for(var t=n>1?void 0:n?F(o,e):o,u=l.length-1,s;u>=0;u--)(s=l[u])&&(t=(n?s(o,e,t):s(t))||t);return n&&t&&k(o,e,t),t},g=(l,o)=>(e,n)=>o(e,n,l);import{spawn as b}from"child_process";import{homedir as z,hostname as B}from"os";import{createCancelablePromise as U,Delayer as x}from"../../../base/common/async.js";import{Emitter as T}from"../../../base/common/event.js";import{Disposable as G}from"../../../base/common/lifecycle.js";import{dirname as N,join as L}from"../../../base/common/path.js";import{isMacintosh as V,isWindows as W}from"../../../base/common/platform.js";import{joinPath as j}from"../../../base/common/resources.js";import{isString as C}from"../../../base/common/types.js";import{StreamSplitter as M}from"../../../base/node/nodeStreams.js";import{localize as p}from"../../../nls.js";import{IConfigurationService as H}from"../../configuration/common/configuration.js";import{INativeEnvironmentService as J}from"../../environment/common/environment.js";import{ISharedProcessLifecycleService as K}from"../../lifecycle/node/sharedProcessLifecycleService.js";import{ILoggerService as q,LogLevelToString as I}from"../../log/common/log.js";import{IProductService as Y}from"../../product/common/productService.js";import{IStorageService as Q,StorageScope as v,StorageTarget as A}from"../../storage/common/storage.js";import{ITelemetryService as X}from"../../telemetry/common/telemetry.js";import{CONFIGURATION_KEY_HOST_NAME as O,CONFIGURATION_KEY_PREVENT_SLEEP as D,INACTIVE_TUNNEL_MODE as S,LOG_ID as R,LOGGER_NAME as Z,TunnelStates as d}from"../common/remoteTunnel.js";const ee=[O,D],P="remoteTunnelSession",y="remoteTunnelIsService";let _=class extends G{constructor(e,n,t,u,s,c,h){super();this.telemetryService=e;this.productService=n;this.environmentService=t;this.configurationService=c;this.storageService=h;this._logger=this._register(u.createLogger(j(t.logsHome,`${R}.log`),{id:R,name:Z})),this._startTunnelProcessDelayer=new x(100),this._register(this._logger.onDidChangeLogLevel(i=>this._logger.info("Log level changed to "+I(i)))),this._register(s.onWillShutdown(()=>{this._tunnelProcess?.cancel(),this._tunnelProcess=void 0,this.dispose()})),this._register(c.onDidChangeConfiguration(i=>{ee.some(r=>i.affectsConfiguration(r))&&this._startTunnelProcessDelayer.trigger(()=>this.updateTunnelProcess())})),this._mode=this._restoreMode(),this._tunnelStatus=d.uninitialized}_onDidTokenFailedEmitter=new T;onDidTokenFailed=this._onDidTokenFailedEmitter.event;_onDidChangeTunnelStatusEmitter=new T;onDidChangeTunnelStatus=this._onDidChangeTunnelStatusEmitter.event;_onDidChangeModeEmitter=new T;onDidChangeMode=this._onDidChangeModeEmitter.event;_logger;_mode=S;_tunnelProcess;_tunnelStatus;_startTunnelProcessDelayer;_tunnelCommand;_initialized=!1;async getTunnelStatus(){return this._tunnelStatus}setTunnelStatus(e){this._tunnelStatus=e,this._onDidChangeTunnelStatusEmitter.fire(e)}setMode(e){w(this._mode,e)||(this._mode=e,this._storeMode(e),this._onDidChangeModeEmitter.fire(this._mode),e.active?(this._logger.info(`Session updated: ${e.session.accountLabel} (${e.session.providerId}) (service=${e.asService})`),e.session.token&&this._logger.info(`Session token updated: ${e.session.accountLabel} (${e.session.providerId})`)):this._logger.info("Session reset"))}getMode(){return Promise.resolve(this._mode)}async initialize(e){if(this._initialized)return this._tunnelStatus;this._initialized=!0,this.setMode(e);try{await this._startTunnelProcessDelayer.trigger(()=>this.updateTunnelProcess())}catch(n){this._logger.error(n)}return this._tunnelStatus}defaultOnOutput=(e,n)=>{n?this._logger.error(e):this._logger.info(e)};getTunnelCommandLocation(){if(!this._tunnelCommand){let e;V?e=this.environmentService.appRoot:e=N(N(this.environmentService.appRoot)),this._tunnelCommand=L(e,"bin",`${this.productService.tunnelApplicationName}${W?".exe":""}`)}return this._tunnelCommand}async startTunnel(e){if(w(this._mode,e)&&this._tunnelStatus.type!=="disconnected")return this._tunnelStatus;this.setMode(e);try{await this._startTunnelProcessDelayer.trigger(()=>this.updateTunnelProcess())}catch(n){this._logger.error(n)}return this._tunnelStatus}async stopTunnel(){if(this._tunnelProcess&&(this._tunnelProcess.cancel(),this._tunnelProcess=void 0),this._mode.active){const e=this._mode.asService;this.setMode(S);try{e&&this.runCodeTunnelCommand("uninstallService",["service","uninstall"])}catch(n){this._logger.error(n)}}try{await this.runCodeTunnelCommand("stop",["kill"])}catch(e){this._logger.error(e)}this.setTunnelStatus(d.disconnected())}async updateTunnelProcess(){this.telemetryService.publicLog2("remoteTunnel.enablement",{enabled:this._mode.active,service:this._mode.active&&this._mode.asService}),this._tunnelProcess&&(this._tunnelProcess.cancel(),this._tunnelProcess=void 0);let e="",n=!1;const t=(r,a)=>{a?this._logger.error(r):e+=r,!this.environmentService.isBuilt&&r.startsWith("   Compiling")&&this.setTunnelStatus(d.connecting(p("remoteTunnelService.building","Building CLI from sources")))},u=this.runCodeTunnelCommand("status",["status"],t);this._tunnelProcess=u;try{if(await u,this._tunnelProcess!==u)return;let r;try{r=JSON.parse(e.trim().split(`
`).find(a=>a.startsWith("{")))}catch{this._logger.error(`Could not parse status output: ${JSON.stringify(e.trim())}`),this.setTunnelStatus(d.disconnected());return}if(n=r.service_installed,this._logger.info(r.tunnel?"Other tunnel running, attaching...":"No other tunnel running"),!r.tunnel&&!this._mode.active){this.setTunnelStatus(d.disconnected());return}}catch(r){this._logger.error(r),this.setTunnelStatus(d.disconnected());return}finally{this._tunnelProcess===u&&(this._tunnelProcess=void 0)}const s=this._mode.active?this._mode.session:void 0;if(s&&s.token){const r=s.token;this.setTunnelStatus(d.connecting(p({key:"remoteTunnelService.authorizing",comment:["{0} is a user account name, {1} a provider name (e.g. Github)"]},"Connecting as {0} ({1})",s.accountLabel,s.providerId)));const a=(f,$)=>{f=f.replaceAll(r,"*".repeat(4)),t(f,$)},m=this.runCodeTunnelCommand("login",["user","login","--provider",s.providerId,"--log",I(this._logger.getLevel())],a,{VSCODE_CLI_ACCESS_TOKEN:r});this._tunnelProcess=m;try{if(await m,this._tunnelProcess!==m)return}catch(f){this._logger.error(f),this._tunnelProcess=void 0,this._onDidTokenFailedEmitter.fire(s),this.setTunnelStatus(d.disconnected(s));return}}const c=this._getTunnelName();c?this.setTunnelStatus(d.connecting(p({key:"remoteTunnelService.openTunnelWithName",comment:["{0} is a tunnel name"]},"Opening tunnel {0}",c))):this.setTunnelStatus(d.connecting(p("remoteTunnelService.openTunnel","Opening tunnel")));const h=["--accept-server-license-terms","--log",I(this._logger.getLevel())];c?h.push("--name",c):h.push("--random-name");let i=!1;return this._mode.active&&this._mode.asService&&!n&&(i=await this.installTunnelService(h)===!1),this.serverOrAttachTunnel(s,h,i)}async installTunnelService(e){let n;try{n=await this.runCodeTunnelCommand("serviceInstall",["service","install",...e])}catch(t){this._logger.error(t),n=1}if(n!==0){const t=p("remoteTunnelService.serviceInstallFailed","Failed to install tunnel as a service, starting in session...");return this._logger.warn(t),this.setTunnelStatus(d.connecting(t)),!1}return!0}async serverOrAttachTunnel(e,n,t){n.push("--parent-process-id",String(process.pid)),this._preventSleep()&&n.push("--no-sleep");let u=!1;const s=this.runCodeTunnelCommand("tunnel",n,(c,h)=>{h?this._logger.error(c):this._logger.info(c),c.includes("Connected to an existing tunnel process")&&(u=!0);const i=c.match(/Open this link in your browser (https:\/\/([^\/\s]+)\/([^\/\s]+)\/([^\/\s]+))/);if(i){const r={link:i[1],domain:i[2],tunnelName:i[4],isAttached:u};this.setTunnelStatus(d.connected(r,t))}else c.match(/error refreshing token/)&&(s.cancel(),this._onDidTokenFailedEmitter.fire(e),this.setTunnelStatus(d.disconnected(e)))});this._tunnelProcess=s,s.finally(()=>{s===this._tunnelProcess&&(this._logger.info("tunnel process terminated"),this._tunnelProcess=void 0,this._mode=S,this.setTunnelStatus(d.disconnected()))})}runCodeTunnelCommand(e,n,t=this.defaultOnOutput,u){return U(s=>new Promise((c,h)=>{s.isCancellationRequested&&c(-1);let i;const r=["ignore","pipe","pipe"];if(s.onCancellationRequested(()=>{i&&(this._logger.info(`${e} terminating(${i.pid})`),i.kill())}),!this.environmentService.isBuilt)t(`Building tunnel CLI from sources and run
`,!1),t(`${e} Spawning: cargo run -- tunnel ${n.join(" ")}
`,!1),i=b("cargo",["run","--","tunnel",...n],{cwd:L(this.environmentService.appRoot,"cli"),stdio:r,env:{...process.env,RUST_BACKTRACE:"1",...u}});else{t(`Running tunnel CLI
`,!1);const a=this.getTunnelCommandLocation();t(`${e} Spawning: ${a} tunnel ${n.join(" ")}
`,!1),i=b(a,["tunnel",...n],{cwd:z(),stdio:r,env:{...process.env,...u}})}i.stdout.pipe(new M(`
`)).on("data",a=>{if(i){const m=a.toString();t(m,!1)}}),i.stderr.pipe(new M(`
`)).on("data",a=>{if(i){const m=a.toString();t(m,!0)}}),i.on("exit",a=>{i&&(t(`${e} exit(${i.pid}): + ${a} `,!1),i=void 0,c(a||0))}),i.on("error",a=>{i&&(t(`${e} error(${i.pid}): + ${a} `,!0),i=void 0,h())})}))}async getTunnelName(){return this._getTunnelName()}_preventSleep(){return!!this.configurationService.getValue(D)}_getTunnelName(){let e=this.configurationService.getValue(O)||B();return e=e.replace(/^-+/g,"").replace(/[^\w-]/g,"").substring(0,20),e||void 0}_restoreMode(){try{const e=this.storageService.get(P,v.APPLICATION),n=this.storageService.getBoolean(y,v.APPLICATION,!1);if(e){const t=JSON.parse(e);if(t&&C(t.accountLabel)&&C(t.sessionId)&&C(t.providerId))return{active:!0,session:t,asService:n};this._logger.error("Problems restoring session from storage, invalid format",t)}}catch(e){this._logger.error("Problems restoring session from storage",e)}return S}_storeMode(e){if(e.active){const n={providerId:e.session.providerId,sessionId:e.session.sessionId,accountLabel:e.session.accountLabel};this.storageService.store(P,JSON.stringify(n),v.APPLICATION,A.MACHINE),this.storageService.store(y,e.asService,v.APPLICATION,A.MACHINE)}else this.storageService.remove(P,v.APPLICATION),this.storageService.remove(y,v.APPLICATION)}};_=E([g(0,X),g(1,Y),g(2,J),g(3,q),g(4,K),g(5,H),g(6,Q)],_);function ne(l,o){return l&&o?l.sessionId===o.sessionId&&l.providerId===o.providerId&&l.token===o.token:l===o}const w=(l,o)=>l.active!==o.active?!1:l.active&&o.active?l.asService===o.asService&&ne(l.session,o.session):!0;export{_ as RemoteTunnelService};
