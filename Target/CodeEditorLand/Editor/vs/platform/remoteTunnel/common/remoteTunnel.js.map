{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/remoteTunnel/common/remoteTunnel.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { Event } from '../../../base/common/event.js';\nimport { localize } from '../../../nls.js';\n\nexport interface IRemoteTunnelSession {\n\treadonly providerId: string;\n\treadonly sessionId: string;\n\treadonly accountLabel: string;\n\treadonly token?: string;\n}\n\nexport const IRemoteTunnelService = createDecorator<IRemoteTunnelService>('IRemoteTunnelService');\nexport interface IRemoteTunnelService {\n\treadonly _serviceBrand: undefined;\n\n\treadonly onDidChangeTunnelStatus: Event<TunnelStatus>;\n\tgetTunnelStatus(): Promise<TunnelStatus>;\n\n\tgetMode(): Promise<TunnelMode>;\n\treadonly onDidChangeMode: Event<TunnelMode>;\n\n\treadonly onDidTokenFailed: Event<IRemoteTunnelSession | undefined>;\n\tinitialize(mode: TunnelMode): Promise<TunnelStatus>;\n\n\tstartTunnel(mode: ActiveTunnelMode): Promise<TunnelStatus>;\n\tstopTunnel(): Promise<void>;\n\tgetTunnelName(): Promise<string | undefined>;\n\n}\n\nexport interface ActiveTunnelMode {\n\treadonly active: true;\n\treadonly session: IRemoteTunnelSession;\n\treadonly asService: boolean;\n}\n\nexport interface InactiveTunnelMode {\n\treadonly active: false;\n}\n\nexport const INACTIVE_TUNNEL_MODE: InactiveTunnelMode = { active: false };\n\n/** Saved mode for the tunnel. */\nexport type TunnelMode = ActiveTunnelMode | InactiveTunnelMode;\n\nexport type TunnelStatus = TunnelStates.Connected | TunnelStates.Disconnected | TunnelStates.Connecting | TunnelStates.Uninitialized;\n\nexport namespace TunnelStates {\n\texport interface Uninitialized {\n\t\treadonly type: 'uninitialized';\n\t}\n\texport interface Connecting {\n\t\treadonly type: 'connecting';\n\t\treadonly progress?: string;\n\t}\n\texport interface Connected {\n\t\treadonly type: 'connected';\n\t\treadonly info: ConnectionInfo;\n\t\treadonly serviceInstallFailed: boolean;\n\t}\n\texport interface Disconnected {\n\t\treadonly type: 'disconnected';\n\t\treadonly onTokenFailed?: IRemoteTunnelSession;\n\t}\n\texport const disconnected = (onTokenFailed?: IRemoteTunnelSession): Disconnected => ({ type: 'disconnected', onTokenFailed });\n\texport const connected = (info: ConnectionInfo, serviceInstallFailed: boolean): Connected => ({ type: 'connected', info, serviceInstallFailed });\n\texport const connecting = (progress?: string): Connecting => ({ type: 'connecting', progress });\n\texport const uninitialized: Uninitialized = { type: 'uninitialized' };\n\n}\n\nexport interface ConnectionInfo {\n\tlink: string;\n\tdomain: string;\n\ttunnelName: string;\n\tisAttached: boolean;\n}\n\nexport const CONFIGURATION_KEY_PREFIX = 'remote.tunnels.access';\nexport const CONFIGURATION_KEY_HOST_NAME = CONFIGURATION_KEY_PREFIX + '.hostNameOverride';\nexport const CONFIGURATION_KEY_PREVENT_SLEEP = CONFIGURATION_KEY_PREFIX + '.preventSleep';\n\nexport const LOG_ID = 'remoteTunnelService';\nexport const LOGGER_NAME = localize('remoteTunnelLog', \"Remote Tunnel Service\");\n"],
  "mappings": ";;AAKA,SAAS,uBAAuB;AAChC,SAAS,aAAa;AACtB,SAAS,gBAAgB;AASlB,MAAM,uBAAuB,gBAAsC,sBAAsB;AA6BzF,MAAM,uBAA2C,EAAE,QAAQ,MAAM;AAOjE,IAAU;AAAA,CAAV,CAAUA,kBAAV;AAiBC,EAAMA,cAAA,eAAe,wBAAC,mBAAwD,EAAE,MAAM,gBAAgB,cAAc,IAA/F;AACrB,EAAMA,cAAA,YAAY,wBAAC,MAAsB,0BAA8C,EAAE,MAAM,aAAa,MAAM,qBAAqB,IAArH;AAClB,EAAMA,cAAA,aAAa,wBAAC,cAAmC,EAAE,MAAM,cAAc,SAAS,IAAnE;AACnB,EAAMA,cAAA,gBAA+B,EAAE,MAAM,gBAAgB;AAAA,GApBpD;AA+BV,MAAM,2BAA2B;AACjC,MAAM,8BAA8B,2BAA2B;AAC/D,MAAM,kCAAkC,2BAA2B;AAEnE,MAAM,SAAS;AACf,MAAM,cAAc,SAAS,mBAAmB,uBAAuB;",
  "names": ["TunnelStates"]
}
