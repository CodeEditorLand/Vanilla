{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/storage/common/storage.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport {\n\tPromises,\n\tRunOnceScheduler,\n\trunWhenGlobalIdle,\n} from \"../../../base/common/async.js\";\nimport {\n\tEmitter,\n\tEvent,\n\tPauseableEmitter,\n} from \"../../../base/common/event.js\";\nimport {\n\tDisposable,\n\ttype DisposableStore,\n\tMutableDisposable,\n\tdispose,\n} from \"../../../base/common/lifecycle.js\";\nimport { mark } from \"../../../base/common/performance.js\";\nimport { isUndefinedOrNull } from \"../../../base/common/types.js\";\nimport {\n\ttype IStorage,\n\ttype IStorageChangeEvent,\n\tInMemoryStorageDatabase,\n\tStorage,\n\tStorageHint,\n\ttype StorageValue,\n} from \"../../../base/parts/storage/common/storage.js\";\nimport { createDecorator } from \"../../instantiation/common/instantiation.js\";\nimport {\n\ttype IUserDataProfile,\n\tisUserDataProfile,\n} from \"../../userDataProfile/common/userDataProfile.js\";\nimport type { IAnyWorkspaceIdentifier } from \"../../workspace/common/workspace.js\";\n\nexport const IS_NEW_KEY = \"__$__isNewStorageMarker\";\nexport const TARGET_KEY = \"__$__targetStorageMarker\";\n\nexport const IStorageService =\n\tcreateDecorator<IStorageService>(\"storageService\");\n\nexport enum WillSaveStateReason {\n\t/**\n\t * No specific reason to save state.\n\t */\n\tNONE = 0,\n\n\t/**\n\t * A hint that the workbench is about to shutdown.\n\t */\n\tSHUTDOWN = 1,\n}\n\nexport interface IWillSaveStateEvent {\n\treadonly reason: WillSaveStateReason;\n}\n\nexport interface IStorageEntry {\n\treadonly key: string;\n\treadonly value: StorageValue;\n\treadonly scope: StorageScope;\n\treadonly target: StorageTarget;\n}\n\nexport interface IWorkspaceStorageValueChangeEvent\n\textends IStorageValueChangeEvent {\n\treadonly scope: StorageScope.WORKSPACE;\n}\n\nexport interface IProfileStorageValueChangeEvent\n\textends IStorageValueChangeEvent {\n\treadonly scope: StorageScope.PROFILE;\n}\n\nexport interface IApplicationStorageValueChangeEvent\n\textends IStorageValueChangeEvent {\n\treadonly scope: StorageScope.APPLICATION;\n}\n\nexport interface IStorageService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Emitted whenever data is updated or deleted on the given\n\t * scope and optional key.\n\t *\n\t * @param scope the `StorageScope` to listen to changes\n\t * @param key the optional key to filter for or all keys of\n\t * the scope if `undefined`\n\t */\n\tonDidChangeValue(\n\t\tscope: StorageScope.WORKSPACE,\n\t\tkey: string | undefined,\n\t\tdisposable: DisposableStore,\n\t): Event<IWorkspaceStorageValueChangeEvent>;\n\tonDidChangeValue(\n\t\tscope: StorageScope.PROFILE,\n\t\tkey: string | undefined,\n\t\tdisposable: DisposableStore,\n\t): Event<IProfileStorageValueChangeEvent>;\n\tonDidChangeValue(\n\t\tscope: StorageScope.APPLICATION,\n\t\tkey: string | undefined,\n\t\tdisposable: DisposableStore,\n\t): Event<IApplicationStorageValueChangeEvent>;\n\tonDidChangeValue(\n\t\tscope: StorageScope,\n\t\tkey: string | undefined,\n\t\tdisposable: DisposableStore,\n\t): Event<IStorageValueChangeEvent>;\n\n\t/**\n\t * Emitted whenever target of a storage entry changes.\n\t */\n\treadonly onDidChangeTarget: Event<IStorageTargetChangeEvent>;\n\n\t/**\n\t * Emitted when the storage is about to persist. This is the right time\n\t * to persist data to ensure it is stored before the application shuts\n\t * down.\n\t *\n\t * The will save state event allows to optionally ask for the reason of\n\t * saving the state, e.g. to find out if the state is saved due to a\n\t * shutdown.\n\t *\n\t * Note: this event may be fired many times, not only on shutdown to prevent\n\t * loss of state in situations where the shutdown is not sufficient to\n\t * persist the data properly.\n\t */\n\treadonly onWillSaveState: Event<IWillSaveStateEvent>;\n\n\t/**\n\t * Retrieve an element stored with the given key from storage. Use\n\t * the provided `defaultValue` if the element is `null` or `undefined`.\n\t *\n\t * @param scope allows to define the scope of the storage operation\n\t * to either the current workspace only, all workspaces or all profiles.\n\t */\n\tget(key: string, scope: StorageScope, fallbackValue: string): string;\n\tget(\n\t\tkey: string,\n\t\tscope: StorageScope,\n\t\tfallbackValue?: string,\n\t): string | undefined;\n\n\t/**\n\t * Retrieve an element stored with the given key from storage. Use\n\t * the provided `defaultValue` if the element is `null` or `undefined`.\n\t * The element will be converted to a `boolean`.\n\t *\n\t * @param scope allows to define the scope of the storage operation\n\t * to either the current workspace only, all workspaces or all profiles.\n\t */\n\tgetBoolean(\n\t\tkey: string,\n\t\tscope: StorageScope,\n\t\tfallbackValue: boolean,\n\t): boolean;\n\tgetBoolean(\n\t\tkey: string,\n\t\tscope: StorageScope,\n\t\tfallbackValue?: boolean,\n\t): boolean | undefined;\n\n\t/**\n\t * Retrieve an element stored with the given key from storage. Use\n\t * the provided `defaultValue` if the element is `null` or `undefined`.\n\t * The element will be converted to a `number` using `parseInt` with a\n\t * base of `10`.\n\t *\n\t * @param scope allows to define the scope of the storage operation\n\t * to either the current workspace only, all workspaces or all profiles.\n\t */\n\tgetNumber(key: string, scope: StorageScope, fallbackValue: number): number;\n\tgetNumber(\n\t\tkey: string,\n\t\tscope: StorageScope,\n\t\tfallbackValue?: number,\n\t): number | undefined;\n\n\t/**\n\t * Retrieve an element stored with the given key from storage. Use\n\t * the provided `defaultValue` if the element is `null` or `undefined`.\n\t * The element will be converted to a `object` using `JSON.parse`.\n\t *\n\t * @param scope allows to define the scope of the storage operation\n\t * to either the current workspace only, all workspaces or all profiles.\n\t */\n\tgetObject<T extends object>(\n\t\tkey: string,\n\t\tscope: StorageScope,\n\t\tfallbackValue: T,\n\t): T;\n\tgetObject<T extends object>(\n\t\tkey: string,\n\t\tscope: StorageScope,\n\t\tfallbackValue?: T,\n\t): T | undefined;\n\n\t/**\n\t * Store a value under the given key to storage. The value will be\n\t * converted to a `string`. Storing either `undefined` or `null` will\n\t * remove the entry under the key.\n\t *\n\t * @param scope allows to define the scope of the storage operation\n\t * to either the current workspace only, all workspaces or all profiles.\n\t *\n\t * @param target allows to define the target of the storage operation\n\t * to either the current machine or user.\n\t */\n\tstore(\n\t\tkey: string,\n\t\tvalue: StorageValue,\n\t\tscope: StorageScope,\n\t\ttarget: StorageTarget,\n\t): void;\n\n\t/**\n\t * Allows to store multiple values in a bulk operation. Events will only\n\t * be emitted when all values have been stored.\n\t *\n\t * @param external a hint to indicate the source of the operation is external,\n\t * such as settings sync or profile changes.\n\t */\n\tstoreAll(entries: Array<IStorageEntry>, external: boolean): void;\n\n\t/**\n\t * Delete an element stored under the provided key from storage.\n\t *\n\t * The scope argument allows to define the scope of the storage\n\t * operation to either the current workspace only, all workspaces\n\t * or all profiles.\n\t */\n\tremove(key: string, scope: StorageScope): void;\n\n\t/**\n\t * Returns all the keys used in the storage for the provided `scope`\n\t * and `target`.\n\t *\n\t * Note: this will NOT return all keys stored in the storage layer.\n\t * Some keys may not have an associated `StorageTarget` and thus\n\t * will be excluded from the results.\n\t *\n\t * @param scope allows to define the scope for the keys\n\t * to either the current workspace only, all workspaces or all profiles.\n\t *\n\t * @param target allows to define the target for the keys\n\t * to either the current machine or user.\n\t */\n\tkeys(scope: StorageScope, target: StorageTarget): string[];\n\n\t/**\n\t * Log the contents of the storage to the console.\n\t */\n\tlog(): void;\n\n\t/**\n\t * Returns true if the storage service handles the provided scope.\n\t */\n\thasScope(scope: IAnyWorkspaceIdentifier | IUserDataProfile): boolean;\n\n\t/**\n\t * Switch storage to another workspace or profile. Optionally preserve the\n\t * current data to the new storage.\n\t */\n\tswitch(\n\t\tto: IAnyWorkspaceIdentifier | IUserDataProfile,\n\t\tpreserveData: boolean,\n\t): Promise<void>;\n\n\t/**\n\t * Whether the storage for the given scope was created during this session or\n\t * existed before.\n\t */\n\tisNew(scope: StorageScope): boolean;\n\n\t/**\n\t * Attempts to reduce the DB size via optimization commands if supported.\n\t */\n\toptimize(scope: StorageScope): Promise<void>;\n\n\t/**\n\t * Allows to flush state, e.g. in cases where a shutdown is\n\t * imminent. This will send out the `onWillSaveState` to ask\n\t * everyone for latest state.\n\t *\n\t * @returns a `Promise` that can be awaited on when all updates\n\t * to the underlying storage have been flushed.\n\t */\n\tflush(reason?: WillSaveStateReason): Promise<void>;\n}\n\nexport enum StorageScope {\n\t/**\n\t * The stored data will be scoped to all workspaces across all profiles.\n\t */\n\tAPPLICATION = -1,\n\n\t/**\n\t * The stored data will be scoped to all workspaces of the same profile.\n\t */\n\tPROFILE = 0,\n\n\t/**\n\t * The stored data will be scoped to the current workspace.\n\t */\n\tWORKSPACE = 1,\n}\n\nexport enum StorageTarget {\n\t/**\n\t * The stored data is user specific and applies across machines.\n\t */\n\tUSER = 0,\n\n\t/**\n\t * The stored data is machine specific.\n\t */\n\tMACHINE = 1,\n}\n\nexport interface IStorageValueChangeEvent {\n\t/**\n\t * The scope for the storage entry that changed\n\t * or was removed.\n\t */\n\treadonly scope: StorageScope;\n\n\t/**\n\t * The `key` of the storage entry that was changed\n\t * or was removed.\n\t */\n\treadonly key: string;\n\n\t/**\n\t * The `target` can be `undefined` if a key is being\n\t * removed.\n\t */\n\treadonly target: StorageTarget | undefined;\n\n\t/**\n\t * A hint how the storage change event was triggered. If\n\t * `true`, the storage change was triggered by an external\n\t * source, such as:\n\t * - another process (for example another window)\n\t * - operations such as settings sync or profiles change\n\t */\n\treadonly external?: boolean;\n}\n\nexport interface IStorageTargetChangeEvent {\n\t/**\n\t * The scope for the target that changed. Listeners\n\t * should use `keys(scope, target)` to get an updated\n\t * list of keys for the given `scope` and `target`.\n\t */\n\treadonly scope: StorageScope;\n}\n\ninterface IKeyTargets {\n\t[key: string]: StorageTarget;\n}\n\nexport interface IStorageServiceOptions {\n\treadonly flushInterval: number;\n}\n\nexport function loadKeyTargets(storage: IStorage): IKeyTargets {\n\tconst keysRaw = storage.get(TARGET_KEY);\n\tif (keysRaw) {\n\t\ttry {\n\t\t\treturn JSON.parse(keysRaw);\n\t\t} catch (error) {\n\t\t\t// Fail gracefully\n\t\t}\n\t}\n\n\treturn Object.create(null);\n}\n\nexport abstract class AbstractStorageService\n\textends Disposable\n\timplements IStorageService\n{\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate static DEFAULT_FLUSH_INTERVAL = 60 * 1000; // every minute\n\n\tprivate readonly _onDidChangeValue = this._register(\n\t\tnew PauseableEmitter<IStorageValueChangeEvent>(),\n\t);\n\n\tprivate readonly _onDidChangeTarget = this._register(\n\t\tnew PauseableEmitter<IStorageTargetChangeEvent>(),\n\t);\n\treadonly onDidChangeTarget = this._onDidChangeTarget.event;\n\n\tprivate readonly _onWillSaveState = this._register(\n\t\tnew Emitter<IWillSaveStateEvent>(),\n\t);\n\treadonly onWillSaveState = this._onWillSaveState.event;\n\n\tprivate initializationPromise: Promise<void> | undefined;\n\n\tprivate readonly flushWhenIdleScheduler = this._register(\n\t\tnew RunOnceScheduler(\n\t\t\t() => this.doFlushWhenIdle(),\n\t\t\tthis.options.flushInterval,\n\t\t),\n\t);\n\tprivate readonly runFlushWhenIdle = this._register(new MutableDisposable());\n\n\tconstructor(\n\t\tprivate readonly options: IStorageServiceOptions = {\n\t\t\tflushInterval: AbstractStorageService.DEFAULT_FLUSH_INTERVAL,\n\t\t},\n\t) {\n\t\tsuper();\n\t}\n\n\tonDidChangeValue(\n\t\tscope: StorageScope.WORKSPACE,\n\t\tkey: string | undefined,\n\t\tdisposable: DisposableStore,\n\t): Event<IWorkspaceStorageValueChangeEvent>;\n\tonDidChangeValue(\n\t\tscope: StorageScope.PROFILE,\n\t\tkey: string | undefined,\n\t\tdisposable: DisposableStore,\n\t): Event<IProfileStorageValueChangeEvent>;\n\tonDidChangeValue(\n\t\tscope: StorageScope.APPLICATION,\n\t\tkey: string | undefined,\n\t\tdisposable: DisposableStore,\n\t): Event<IApplicationStorageValueChangeEvent>;\n\tonDidChangeValue(\n\t\tscope: StorageScope,\n\t\tkey: string | undefined,\n\t\tdisposable: DisposableStore,\n\t): Event<IStorageValueChangeEvent> {\n\t\treturn Event.filter(\n\t\t\tthis._onDidChangeValue.event,\n\t\t\t(e) => e.scope === scope && (key === undefined || e.key === key),\n\t\t\tdisposable,\n\t\t);\n\t}\n\n\tprivate doFlushWhenIdle(): void {\n\t\tthis.runFlushWhenIdle.value = runWhenGlobalIdle(() => {\n\t\t\tif (this.shouldFlushWhenIdle()) {\n\t\t\t\tthis.flush();\n\t\t\t}\n\n\t\t\t// repeat\n\t\t\tthis.flushWhenIdleScheduler.schedule();\n\t\t});\n\t}\n\n\tprotected shouldFlushWhenIdle(): boolean {\n\t\treturn true;\n\t}\n\n\tprotected stopFlushWhenIdle(): void {\n\t\tdispose([this.runFlushWhenIdle, this.flushWhenIdleScheduler]);\n\t}\n\n\tinitialize(): Promise<void> {\n\t\tif (!this.initializationPromise) {\n\t\t\tthis.initializationPromise = (async () => {\n\t\t\t\t// Init all storage locations\n\t\t\t\tmark(\"code/willInitStorage\");\n\t\t\t\ttry {\n\t\t\t\t\tawait this.doInitialize(); // Ask subclasses to initialize storage\n\t\t\t\t} finally {\n\t\t\t\t\tmark(\"code/didInitStorage\");\n\t\t\t\t}\n\n\t\t\t\t// On some OS we do not get enough time to persist state on shutdown (e.g. when\n\t\t\t\t// Windows restarts after applying updates). In other cases, VSCode might crash,\n\t\t\t\t// so we periodically save state to reduce the chance of loosing any state.\n\t\t\t\t// In the browser we do not have support for long running unload sequences. As such,\n\t\t\t\t// we cannot ask for saving state in that moment, because that would result in a\n\t\t\t\t// long running operation.\n\t\t\t\t// Instead, periodically ask customers to save save. The library will be clever enough\n\t\t\t\t// to only save state that has actually changed.\n\t\t\t\tthis.flushWhenIdleScheduler.schedule();\n\t\t\t})();\n\t\t}\n\n\t\treturn this.initializationPromise;\n\t}\n\n\tprotected emitDidChangeValue(\n\t\tscope: StorageScope,\n\t\tevent: IStorageChangeEvent,\n\t): void {\n\t\tconst { key, external } = event;\n\n\t\t// Specially handle `TARGET_KEY`\n\t\tif (key === TARGET_KEY) {\n\t\t\t// Clear our cached version which is now out of date\n\t\t\tswitch (scope) {\n\t\t\t\tcase StorageScope.APPLICATION:\n\t\t\t\t\tthis._applicationKeyTargets = undefined;\n\t\t\t\t\tbreak;\n\t\t\t\tcase StorageScope.PROFILE:\n\t\t\t\t\tthis._profileKeyTargets = undefined;\n\t\t\t\t\tbreak;\n\t\t\t\tcase StorageScope.WORKSPACE:\n\t\t\t\t\tthis._workspaceKeyTargets = undefined;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Emit as `didChangeTarget` event\n\t\t\tthis._onDidChangeTarget.fire({ scope });\n\t\t}\n\n\t\t// Emit any other key to outside\n\t\telse {\n\t\t\tthis._onDidChangeValue.fire({\n\t\t\t\tscope,\n\t\t\t\tkey,\n\t\t\t\ttarget: this.getKeyTargets(scope)[key],\n\t\t\t\texternal,\n\t\t\t});\n\t\t}\n\t}\n\n\tprotected emitWillSaveState(reason: WillSaveStateReason): void {\n\t\tthis._onWillSaveState.fire({ reason });\n\t}\n\n\tget(key: string, scope: StorageScope, fallbackValue: string): string;\n\tget(key: string, scope: StorageScope): string | undefined;\n\tget(\n\t\tkey: string,\n\t\tscope: StorageScope,\n\t\tfallbackValue?: string,\n\t): string | undefined {\n\t\treturn this.getStorage(scope)?.get(key, fallbackValue);\n\t}\n\n\tgetBoolean(\n\t\tkey: string,\n\t\tscope: StorageScope,\n\t\tfallbackValue: boolean,\n\t): boolean;\n\tgetBoolean(key: string, scope: StorageScope): boolean | undefined;\n\tgetBoolean(\n\t\tkey: string,\n\t\tscope: StorageScope,\n\t\tfallbackValue?: boolean,\n\t): boolean | undefined {\n\t\treturn this.getStorage(scope)?.getBoolean(key, fallbackValue);\n\t}\n\n\tgetNumber(key: string, scope: StorageScope, fallbackValue: number): number;\n\tgetNumber(key: string, scope: StorageScope): number | undefined;\n\tgetNumber(\n\t\tkey: string,\n\t\tscope: StorageScope,\n\t\tfallbackValue?: number,\n\t): number | undefined {\n\t\treturn this.getStorage(scope)?.getNumber(key, fallbackValue);\n\t}\n\n\tgetObject(key: string, scope: StorageScope, fallbackValue: object): object;\n\tgetObject(key: string, scope: StorageScope): object | undefined;\n\tgetObject(\n\t\tkey: string,\n\t\tscope: StorageScope,\n\t\tfallbackValue?: object,\n\t): object | undefined {\n\t\treturn this.getStorage(scope)?.getObject(key, fallbackValue);\n\t}\n\n\tstoreAll(entries: Array<IStorageEntry>, external: boolean): void {\n\t\tthis.withPausedEmitters(() => {\n\t\t\tfor (const entry of entries) {\n\t\t\t\tthis.store(\n\t\t\t\t\tentry.key,\n\t\t\t\t\tentry.value,\n\t\t\t\t\tentry.scope,\n\t\t\t\t\tentry.target,\n\t\t\t\t\texternal,\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\t}\n\n\tstore(\n\t\tkey: string,\n\t\tvalue: StorageValue,\n\t\tscope: StorageScope,\n\t\ttarget: StorageTarget,\n\t\texternal = false,\n\t): void {\n\t\t// We remove the key for undefined/null values\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\tthis.remove(key, scope, external);\n\t\t\treturn;\n\t\t}\n\n\t\t// Update our datastructures but send events only after\n\t\tthis.withPausedEmitters(() => {\n\t\t\t// Update key-target map\n\t\t\tthis.updateKeyTarget(key, scope, target);\n\n\t\t\t// Store actual value\n\t\t\tthis.getStorage(scope)?.set(key, value, external);\n\t\t});\n\t}\n\n\tremove(key: string, scope: StorageScope, external = false): void {\n\t\t// Update our datastructures but send events only after\n\t\tthis.withPausedEmitters(() => {\n\t\t\t// Update key-target map\n\t\t\tthis.updateKeyTarget(key, scope, undefined);\n\n\t\t\t// Remove actual key\n\t\t\tthis.getStorage(scope)?.delete(key, external);\n\t\t});\n\t}\n\n\tprivate withPausedEmitters(fn: Function): void {\n\t\t// Pause emitters\n\t\tthis._onDidChangeValue.pause();\n\t\tthis._onDidChangeTarget.pause();\n\n\t\ttry {\n\t\t\tfn();\n\t\t} finally {\n\t\t\t// Resume emitters\n\t\t\tthis._onDidChangeValue.resume();\n\t\t\tthis._onDidChangeTarget.resume();\n\t\t}\n\t}\n\n\tkeys(scope: StorageScope, target: StorageTarget): string[] {\n\t\tconst keys: string[] = [];\n\n\t\tconst keyTargets = this.getKeyTargets(scope);\n\t\tfor (const key of Object.keys(keyTargets)) {\n\t\t\tconst keyTarget = keyTargets[key];\n\t\t\tif (keyTarget === target) {\n\t\t\t\tkeys.push(key);\n\t\t\t}\n\t\t}\n\n\t\treturn keys;\n\t}\n\n\tprivate updateKeyTarget(\n\t\tkey: string,\n\t\tscope: StorageScope,\n\t\ttarget: StorageTarget | undefined,\n\t\texternal = false,\n\t): void {\n\t\t// Add\n\t\tconst keyTargets = this.getKeyTargets(scope);\n\t\tif (typeof target === \"number\") {\n\t\t\tif (keyTargets[key] !== target) {\n\t\t\t\tkeyTargets[key] = target;\n\t\t\t\tthis.getStorage(scope)?.set(\n\t\t\t\t\tTARGET_KEY,\n\t\t\t\t\tJSON.stringify(keyTargets),\n\t\t\t\t\texternal,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Remove\n\t\telse if (typeof keyTargets[key] === \"number\") {\n\t\t\tdelete keyTargets[key];\n\t\t\tthis.getStorage(scope)?.set(\n\t\t\t\tTARGET_KEY,\n\t\t\t\tJSON.stringify(keyTargets),\n\t\t\t\texternal,\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate _workspaceKeyTargets: IKeyTargets | undefined = undefined;\n\tprivate get workspaceKeyTargets(): IKeyTargets {\n\t\tif (!this._workspaceKeyTargets) {\n\t\t\tthis._workspaceKeyTargets = this.loadKeyTargets(\n\t\t\t\tStorageScope.WORKSPACE,\n\t\t\t);\n\t\t}\n\n\t\treturn this._workspaceKeyTargets;\n\t}\n\n\tprivate _profileKeyTargets: IKeyTargets | undefined = undefined;\n\tprivate get profileKeyTargets(): IKeyTargets {\n\t\tif (!this._profileKeyTargets) {\n\t\t\tthis._profileKeyTargets = this.loadKeyTargets(StorageScope.PROFILE);\n\t\t}\n\n\t\treturn this._profileKeyTargets;\n\t}\n\n\tprivate _applicationKeyTargets: IKeyTargets | undefined = undefined;\n\tprivate get applicationKeyTargets(): IKeyTargets {\n\t\tif (!this._applicationKeyTargets) {\n\t\t\tthis._applicationKeyTargets = this.loadKeyTargets(\n\t\t\t\tStorageScope.APPLICATION,\n\t\t\t);\n\t\t}\n\n\t\treturn this._applicationKeyTargets;\n\t}\n\n\tprivate getKeyTargets(scope: StorageScope): IKeyTargets {\n\t\tswitch (scope) {\n\t\t\tcase StorageScope.APPLICATION:\n\t\t\t\treturn this.applicationKeyTargets;\n\t\t\tcase StorageScope.PROFILE:\n\t\t\t\treturn this.profileKeyTargets;\n\t\t\tdefault:\n\t\t\t\treturn this.workspaceKeyTargets;\n\t\t}\n\t}\n\n\tprivate loadKeyTargets(scope: StorageScope): {\n\t\t[key: string]: StorageTarget;\n\t} {\n\t\tconst storage = this.getStorage(scope);\n\n\t\treturn storage ? loadKeyTargets(storage) : Object.create(null);\n\t}\n\n\tisNew(scope: StorageScope): boolean {\n\t\treturn this.getBoolean(IS_NEW_KEY, scope) === true;\n\t}\n\n\tasync flush(reason = WillSaveStateReason.NONE): Promise<void> {\n\t\t// Signal event to collect changes\n\t\tthis._onWillSaveState.fire({ reason });\n\n\t\tconst applicationStorage = this.getStorage(StorageScope.APPLICATION);\n\t\tconst profileStorage = this.getStorage(StorageScope.PROFILE);\n\t\tconst workspaceStorage = this.getStorage(StorageScope.WORKSPACE);\n\n\t\tswitch (reason) {\n\t\t\t// Unspecific reason: just wait when data is flushed\n\t\t\tcase WillSaveStateReason.NONE:\n\t\t\t\tawait Promises.settled([\n\t\t\t\t\tapplicationStorage?.whenFlushed() ?? Promise.resolve(),\n\t\t\t\t\tprofileStorage?.whenFlushed() ?? Promise.resolve(),\n\t\t\t\t\tworkspaceStorage?.whenFlushed() ?? Promise.resolve(),\n\t\t\t\t]);\n\t\t\t\tbreak;\n\n\t\t\t// Shutdown: we want to flush as soon as possible\n\t\t\t// and not hit any delays that might be there\n\t\t\tcase WillSaveStateReason.SHUTDOWN:\n\t\t\t\tawait Promises.settled([\n\t\t\t\t\tapplicationStorage?.flush(0) ?? Promise.resolve(),\n\t\t\t\t\tprofileStorage?.flush(0) ?? Promise.resolve(),\n\t\t\t\t\tworkspaceStorage?.flush(0) ?? Promise.resolve(),\n\t\t\t\t]);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tasync log(): Promise<void> {\n\t\tconst applicationItems =\n\t\t\tthis.getStorage(StorageScope.APPLICATION)?.items ??\n\t\t\tnew Map<string, string>();\n\t\tconst profileItems =\n\t\t\tthis.getStorage(StorageScope.PROFILE)?.items ??\n\t\t\tnew Map<string, string>();\n\t\tconst workspaceItems =\n\t\t\tthis.getStorage(StorageScope.WORKSPACE)?.items ??\n\t\t\tnew Map<string, string>();\n\n\t\treturn logStorage(\n\t\t\tapplicationItems,\n\t\t\tprofileItems,\n\t\t\tworkspaceItems,\n\t\t\tthis.getLogDetails(StorageScope.APPLICATION) ?? \"\",\n\t\t\tthis.getLogDetails(StorageScope.PROFILE) ?? \"\",\n\t\t\tthis.getLogDetails(StorageScope.WORKSPACE) ?? \"\",\n\t\t);\n\t}\n\n\tasync optimize(scope: StorageScope): Promise<void> {\n\t\t// Await pending data to be flushed to the DB\n\t\t// before attempting to optimize the DB\n\t\tawait this.flush();\n\n\t\treturn this.getStorage(scope)?.optimize();\n\t}\n\n\tasync switch(\n\t\tto: IAnyWorkspaceIdentifier | IUserDataProfile,\n\t\tpreserveData: boolean,\n\t): Promise<void> {\n\t\t// Signal as event so that clients can store data before we switch\n\t\tthis.emitWillSaveState(WillSaveStateReason.NONE);\n\n\t\tif (isUserDataProfile(to)) {\n\t\t\treturn this.switchToProfile(to, preserveData);\n\t\t}\n\n\t\treturn this.switchToWorkspace(to, preserveData);\n\t}\n\n\tprotected canSwitchProfile(\n\t\tfrom: IUserDataProfile,\n\t\tto: IUserDataProfile,\n\t): boolean {\n\t\tif (from.id === to.id) {\n\t\t\treturn false; // both profiles are same\n\t\t}\n\n\t\tif (\n\t\t\tisProfileUsingDefaultStorage(to) &&\n\t\t\tisProfileUsingDefaultStorage(from)\n\t\t) {\n\t\t\treturn false; // both profiles are using default\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprotected switchData(\n\t\toldStorage: Map<string, string>,\n\t\tnewStorage: IStorage,\n\t\tscope: StorageScope,\n\t): void {\n\t\tthis.withPausedEmitters(() => {\n\t\t\t// Signal storage keys that have changed\n\t\t\tconst handledkeys = new Set<string>();\n\t\t\tfor (const [key, oldValue] of oldStorage) {\n\t\t\t\thandledkeys.add(key);\n\n\t\t\t\tconst newValue = newStorage.get(key);\n\t\t\t\tif (newValue !== oldValue) {\n\t\t\t\t\tthis.emitDidChangeValue(scope, { key, external: true });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const [key] of newStorage.items) {\n\t\t\t\tif (!handledkeys.has(key)) {\n\t\t\t\t\tthis.emitDidChangeValue(scope, { key, external: true });\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t// --- abstract\n\n\tabstract hasScope(\n\t\tscope: IAnyWorkspaceIdentifier | IUserDataProfile,\n\t): boolean;\n\n\tprotected abstract doInitialize(): Promise<void>;\n\n\tprotected abstract getStorage(scope: StorageScope): IStorage | undefined;\n\n\tprotected abstract getLogDetails(scope: StorageScope): string | undefined;\n\n\tprotected abstract switchToProfile(\n\t\ttoProfile: IUserDataProfile,\n\t\tpreserveData: boolean,\n\t): Promise<void>;\n\tprotected abstract switchToWorkspace(\n\t\ttoWorkspace: IAnyWorkspaceIdentifier | IUserDataProfile,\n\t\tpreserveData: boolean,\n\t): Promise<void>;\n}\n\nexport function isProfileUsingDefaultStorage(\n\tprofile: IUserDataProfile,\n): boolean {\n\treturn profile.isDefault || !!profile.useDefaultFlags?.globalState;\n}\n\nexport class InMemoryStorageService extends AbstractStorageService {\n\tprivate readonly applicationStorage = this._register(\n\t\tnew Storage(new InMemoryStorageDatabase(), {\n\t\t\thint: StorageHint.STORAGE_IN_MEMORY,\n\t\t}),\n\t);\n\tprivate readonly profileStorage = this._register(\n\t\tnew Storage(new InMemoryStorageDatabase(), {\n\t\t\thint: StorageHint.STORAGE_IN_MEMORY,\n\t\t}),\n\t);\n\tprivate readonly workspaceStorage = this._register(\n\t\tnew Storage(new InMemoryStorageDatabase(), {\n\t\t\thint: StorageHint.STORAGE_IN_MEMORY,\n\t\t}),\n\t);\n\n\tconstructor() {\n\t\tsuper();\n\n\t\tthis._register(\n\t\t\tthis.workspaceStorage.onDidChangeStorage((e) =>\n\t\t\t\tthis.emitDidChangeValue(StorageScope.WORKSPACE, e),\n\t\t\t),\n\t\t);\n\t\tthis._register(\n\t\t\tthis.profileStorage.onDidChangeStorage((e) =>\n\t\t\t\tthis.emitDidChangeValue(StorageScope.PROFILE, e),\n\t\t\t),\n\t\t);\n\t\tthis._register(\n\t\t\tthis.applicationStorage.onDidChangeStorage((e) =>\n\t\t\t\tthis.emitDidChangeValue(StorageScope.APPLICATION, e),\n\t\t\t),\n\t\t);\n\t}\n\n\tprotected getStorage(scope: StorageScope): IStorage {\n\t\tswitch (scope) {\n\t\t\tcase StorageScope.APPLICATION:\n\t\t\t\treturn this.applicationStorage;\n\t\t\tcase StorageScope.PROFILE:\n\t\t\t\treturn this.profileStorage;\n\t\t\tdefault:\n\t\t\t\treturn this.workspaceStorage;\n\t\t}\n\t}\n\n\tprotected getLogDetails(scope: StorageScope): string | undefined {\n\t\tswitch (scope) {\n\t\t\tcase StorageScope.APPLICATION:\n\t\t\t\treturn \"inMemory (application)\";\n\t\t\tcase StorageScope.PROFILE:\n\t\t\t\treturn \"inMemory (profile)\";\n\t\t\tdefault:\n\t\t\t\treturn \"inMemory (workspace)\";\n\t\t}\n\t}\n\n\tprotected async doInitialize(): Promise<void> {}\n\n\tprotected async switchToProfile(): Promise<void> {\n\t\t// no-op when in-memory\n\t}\n\n\tprotected async switchToWorkspace(): Promise<void> {\n\t\t// no-op when in-memory\n\t}\n\n\tprotected override shouldFlushWhenIdle(): boolean {\n\t\treturn false;\n\t}\n\n\thasScope(scope: IAnyWorkspaceIdentifier | IUserDataProfile): boolean {\n\t\treturn false;\n\t}\n}\n\nexport async function logStorage(\n\tapplication: Map<string, string>,\n\tprofile: Map<string, string>,\n\tworkspace: Map<string, string>,\n\tapplicationPath: string,\n\tprofilePath: string,\n\tworkspacePath: string,\n): Promise<void> {\n\tconst safeParse = (value: string) => {\n\t\ttry {\n\t\t\treturn JSON.parse(value);\n\t\t} catch (error) {\n\t\t\treturn value;\n\t\t}\n\t};\n\n\tconst applicationItems = new Map<string, string>();\n\tconst applicationItemsParsed = new Map<string, string>();\n\tapplication.forEach((value, key) => {\n\t\tapplicationItems.set(key, value);\n\t\tapplicationItemsParsed.set(key, safeParse(value));\n\t});\n\n\tconst profileItems = new Map<string, string>();\n\tconst profileItemsParsed = new Map<string, string>();\n\tprofile.forEach((value, key) => {\n\t\tprofileItems.set(key, value);\n\t\tprofileItemsParsed.set(key, safeParse(value));\n\t});\n\n\tconst workspaceItems = new Map<string, string>();\n\tconst workspaceItemsParsed = new Map<string, string>();\n\tworkspace.forEach((value, key) => {\n\t\tworkspaceItems.set(key, value);\n\t\tworkspaceItemsParsed.set(key, safeParse(value));\n\t});\n\n\tif (applicationPath !== profilePath) {\n\t\tconsole.group(`Storage: Application (path: ${applicationPath})`);\n\t} else {\n\t\tconsole.group(\n\t\t\t`Storage: Application & Profile (path: ${applicationPath}, default profile)`,\n\t\t);\n\t}\n\tconst applicationValues: { key: string; value: string }[] = [];\n\tapplicationItems.forEach((value, key) => {\n\t\tapplicationValues.push({ key, value });\n\t});\n\tconsole.table(applicationValues);\n\tconsole.groupEnd();\n\n\tconsole.log(applicationItemsParsed);\n\n\tif (applicationPath !== profilePath) {\n\t\tconsole.group(\n\t\t\t`Storage: Profile (path: ${profilePath}, profile specific)`,\n\t\t);\n\t\tconst profileValues: { key: string; value: string }[] = [];\n\t\tprofileItems.forEach((value, key) => {\n\t\t\tprofileValues.push({ key, value });\n\t\t});\n\t\tconsole.table(profileValues);\n\t\tconsole.groupEnd();\n\n\t\tconsole.log(profileItemsParsed);\n\t}\n\n\tconsole.group(`Storage: Workspace (path: ${workspacePath})`);\n\tconst workspaceValues: { key: string; value: string }[] = [];\n\tworkspaceItems.forEach((value, key) => {\n\t\tworkspaceValues.push({ key, value });\n\t});\n\tconsole.table(workspaceValues);\n\tconsole.groupEnd();\n\n\tconsole.log(workspaceItemsParsed);\n}\n"],
  "mappings": "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",
  "names": ["WillSaveStateReason", "StorageScope", "StorageTarget"]
}
