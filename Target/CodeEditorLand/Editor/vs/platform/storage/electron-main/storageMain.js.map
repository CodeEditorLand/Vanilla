{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/storage/electron-main/storageMain.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport { top } from '../../../base/common/arrays.js';\nimport { DeferredPromise } from '../../../base/common/async.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { Disposable, IDisposable } from '../../../base/common/lifecycle.js';\nimport { join } from '../../../base/common/path.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { Promises } from '../../../base/node/pfs.js';\nimport { InMemoryStorageDatabase, IStorage, Storage, StorageHint, StorageState } from '../../../base/parts/storage/common/storage.js';\nimport { ISQLiteStorageDatabaseLoggingOptions, SQLiteStorageDatabase } from '../../../base/parts/storage/node/storage.js';\nimport { IEnvironmentService } from '../../environment/common/environment.js';\nimport { IFileService } from '../../files/common/files.js';\nimport { ILogService, LogLevel } from '../../log/common/log.js';\nimport { IS_NEW_KEY } from '../common/storage.js';\nimport { IUserDataProfile, IUserDataProfilesService } from '../../userDataProfile/common/userDataProfile.js';\nimport { currentSessionDateStorageKey, firstSessionDateStorageKey, lastSessionDateStorageKey } from '../../telemetry/common/telemetry.js';\nimport { isSingleFolderWorkspaceIdentifier, isWorkspaceIdentifier, IAnyWorkspaceIdentifier } from '../../workspace/common/workspace.js';\nimport { Schemas } from '../../../base/common/network.js';\n\nexport interface IStorageMainOptions {\n\n\t/**\n\t * If enabled, storage will not persist to disk\n\t * but into memory.\n\t */\n\treadonly useInMemoryStorage?: boolean;\n}\n\n/**\n * Provides access to application, profile and workspace storage from\n * the electron-main side that is the owner of all storage connections.\n */\nexport interface IStorageMain extends IDisposable {\n\n\t/**\n\t * Emitted whenever data is updated or deleted.\n\t */\n\treadonly onDidChangeStorage: Event<IStorageChangeEvent>;\n\n\t/**\n\t * Emitted when the storage is closed.\n\t */\n\treadonly onDidCloseStorage: Event<void>;\n\n\t/**\n\t * Access to all cached items of this storage service.\n\t */\n\treadonly items: Map<string, string>;\n\n\t/**\n\t * Allows to join on the `init` call having completed\n\t * to be able to safely use the storage.\n\t */\n\treadonly whenInit: Promise<void>;\n\n\t/**\n\t * Provides access to the `IStorage` implementation which will be\n\t * in-memory for as long as the storage has not been initialized.\n\t */\n\treadonly storage: IStorage;\n\n\t/**\n\t * The file path of the underlying storage file if any.\n\t */\n\treadonly path: string | undefined;\n\n\t/**\n\t * Required call to ensure the service can be used.\n\t */\n\tinit(): Promise<void>;\n\n\t/**\n\t * Retrieve an element stored with the given key from storage. Use\n\t * the provided defaultValue if the element is null or undefined.\n\t */\n\tget(key: string, fallbackValue: string): string;\n\tget(key: string, fallbackValue?: string): string | undefined;\n\n\t/**\n\t * Store a string value under the given key to storage. The value will\n\t * be converted to a string.\n\t */\n\tset(key: string, value: string | boolean | number | undefined | null): void;\n\n\t/**\n\t * Delete an element stored under the provided key from storage.\n\t */\n\tdelete(key: string): void;\n\n\t/**\n\t * Whether the storage is using in-memory persistence or not.\n\t */\n\tisInMemory(): boolean;\n\n\t/**\n\t * Attempts to reduce the DB size via optimization commands if supported.\n\t */\n\toptimize(): Promise<void>;\n\n\t/**\n\t * Close the storage connection.\n\t */\n\tclose(): Promise<void>;\n}\n\nexport interface IStorageChangeEvent {\n\treadonly key: string;\n}\n\nabstract class BaseStorageMain extends Disposable implements IStorageMain {\n\n\tprivate static readonly LOG_SLOW_CLOSE_THRESHOLD = 2000;\n\n\tprotected readonly _onDidChangeStorage = this._register(new Emitter<IStorageChangeEvent>());\n\treadonly onDidChangeStorage = this._onDidChangeStorage.event;\n\n\tprivate readonly _onDidCloseStorage = this._register(new Emitter<void>());\n\treadonly onDidCloseStorage = this._onDidCloseStorage.event;\n\n\tprivate _storage = this._register(new Storage(new InMemoryStorageDatabase(), { hint: StorageHint.STORAGE_IN_MEMORY })); // storage is in-memory until initialized\n\tget storage(): IStorage { return this._storage; }\n\n\tabstract get path(): string | undefined;\n\n\tprivate initializePromise: Promise<void> | undefined = undefined;\n\n\tprivate readonly whenInitPromise = new DeferredPromise<void>();\n\treadonly whenInit = this.whenInitPromise.p;\n\n\tprivate state = StorageState.None;\n\n\tconstructor(\n\t\tprotected readonly logService: ILogService,\n\t\tprivate readonly fileService: IFileService\n\t) {\n\t\tsuper();\n\t}\n\n\tisInMemory(): boolean {\n\t\treturn this._storage.isInMemory();\n\t}\n\n\tinit(): Promise<void> {\n\t\tif (!this.initializePromise) {\n\t\t\tthis.initializePromise = (async () => {\n\t\t\t\tif (this.state !== StorageState.None) {\n\t\t\t\t\treturn; // either closed or already initialized\n\t\t\t\t}\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// Create storage via subclasses\n\t\t\t\t\tconst storage = this._register(await this.doCreate());\n\n\t\t\t\t\t// Replace our in-memory storage with the real\n\t\t\t\t\t// once as soon as possible without awaiting\n\t\t\t\t\t// the init call.\n\t\t\t\t\tthis._storage.dispose();\n\t\t\t\t\tthis._storage = storage;\n\n\t\t\t\t\t// Re-emit storage changes via event\n\t\t\t\t\tthis._register(storage.onDidChangeStorage(e => this._onDidChangeStorage.fire(e)));\n\n\t\t\t\t\t// Await storage init\n\t\t\t\t\tawait this.doInit(storage);\n\n\t\t\t\t\t// Ensure we track whether storage is new or not\n\t\t\t\t\tconst isNewStorage = storage.getBoolean(IS_NEW_KEY);\n\t\t\t\t\tif (isNewStorage === undefined) {\n\t\t\t\t\t\tstorage.set(IS_NEW_KEY, true);\n\t\t\t\t\t} else if (isNewStorage) {\n\t\t\t\t\t\tstorage.set(IS_NEW_KEY, false);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.logService.error(`[storage main] initialize(): Unable to init storage due to ${error}`);\n\t\t\t\t} finally {\n\n\t\t\t\t\t// Update state\n\t\t\t\t\tthis.state = StorageState.Initialized;\n\n\t\t\t\t\t// Mark init promise as completed\n\t\t\t\t\tthis.whenInitPromise.complete();\n\t\t\t\t}\n\t\t\t})();\n\t\t}\n\n\t\treturn this.initializePromise;\n\t}\n\n\tprotected createLoggingOptions(): ISQLiteStorageDatabaseLoggingOptions {\n\t\treturn {\n\t\t\tlogTrace: (this.logService.getLevel() === LogLevel.Trace) ? msg => this.logService.trace(msg) : undefined,\n\t\t\tlogError: error => this.logService.error(error)\n\t\t};\n\t}\n\n\tprotected doInit(storage: IStorage): Promise<void> {\n\t\treturn storage.init();\n\t}\n\n\tprotected abstract doCreate(): Promise<Storage>;\n\n\tget items(): Map<string, string> { return this._storage.items; }\n\n\tget(key: string, fallbackValue: string): string;\n\tget(key: string, fallbackValue?: string): string | undefined;\n\tget(key: string, fallbackValue?: string): string | undefined {\n\t\treturn this._storage.get(key, fallbackValue);\n\t}\n\n\tset(key: string, value: string | boolean | number | undefined | null): Promise<void> {\n\t\treturn this._storage.set(key, value);\n\t}\n\n\tdelete(key: string): Promise<void> {\n\t\treturn this._storage.delete(key);\n\t}\n\n\toptimize(): Promise<void> {\n\t\treturn this._storage.optimize();\n\t}\n\n\tasync close(): Promise<void> {\n\n\t\t// Measure how long it takes to close storage\n\t\tconst watch = new StopWatch(false);\n\t\tawait this.doClose();\n\t\twatch.stop();\n\n\t\t// If close() is taking a long time, there is\n\t\t// a chance that the underlying DB is large\n\t\t// either on disk or in general. In that case\n\t\t// log some additional info to further diagnose\n\t\tif (watch.elapsed() > BaseStorageMain.LOG_SLOW_CLOSE_THRESHOLD) {\n\t\t\tawait this.logSlowClose(watch);\n\t\t}\n\n\t\t// Signal as event\n\t\tthis._onDidCloseStorage.fire();\n\t}\n\n\tprivate async logSlowClose(watch: StopWatch) {\n\t\tif (!this.path) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tconst largestEntries = top(Array.from(this._storage.items.entries())\n\t\t\t\t.map(([key, value]) => ({ key, length: value.length })), (entryA, entryB) => entryB.length - entryA.length, 5)\n\t\t\t\t.map(entry => `${entry.key}:${entry.length}`).join(', ');\n\t\t\tconst dbSize = (await this.fileService.stat(URI.file(this.path))).size;\n\n\t\t\tthis.logService.warn(`[storage main] detected slow close() operation: Time: ${watch.elapsed()}ms, DB size: ${dbSize}b, Large Keys: ${largestEntries}`);\n\t\t} catch (error) {\n\t\t\tthis.logService.error('[storage main] figuring out stats for slow DB on close() resulted in an error', error);\n\t\t}\n\t}\n\n\tprivate async doClose(): Promise<void> {\n\n\t\t// Ensure we are not accidentally leaving\n\t\t// a pending initialized storage behind in\n\t\t// case `close()` was called before `init()`\n\t\t// finishes.\n\t\tif (this.initializePromise) {\n\t\t\tawait this.initializePromise;\n\t\t}\n\n\t\t// Update state\n\t\tthis.state = StorageState.Closed;\n\n\t\t// Propagate to storage lib\n\t\tawait this._storage.close();\n\t}\n}\n\nclass BaseProfileAwareStorageMain extends BaseStorageMain {\n\n\tprivate static readonly STORAGE_NAME = 'state.vscdb';\n\n\tget path(): string | undefined {\n\t\tif (!this.options.useInMemoryStorage) {\n\t\t\treturn join(this.profile.globalStorageHome.with({ scheme: Schemas.file }).fsPath, BaseProfileAwareStorageMain.STORAGE_NAME);\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tconstructor(\n\t\tprivate readonly profile: IUserDataProfile,\n\t\tprivate readonly options: IStorageMainOptions,\n\t\tlogService: ILogService,\n\t\tfileService: IFileService\n\t) {\n\t\tsuper(logService, fileService);\n\t}\n\n\tprotected async doCreate(): Promise<Storage> {\n\t\treturn new Storage(new SQLiteStorageDatabase(this.path ?? SQLiteStorageDatabase.IN_MEMORY_PATH, {\n\t\t\tlogging: this.createLoggingOptions()\n\t\t}), !this.path ? { hint: StorageHint.STORAGE_IN_MEMORY } : undefined);\n\t}\n}\n\nexport class ProfileStorageMain extends BaseProfileAwareStorageMain {\n\n\tconstructor(\n\t\tprofile: IUserDataProfile,\n\t\toptions: IStorageMainOptions,\n\t\tlogService: ILogService,\n\t\tfileService: IFileService\n\t) {\n\t\tsuper(profile, options, logService, fileService);\n\t}\n}\n\nexport class ApplicationStorageMain extends BaseProfileAwareStorageMain {\n\n\tconstructor(\n\t\toptions: IStorageMainOptions,\n\t\tuserDataProfileService: IUserDataProfilesService,\n\t\tlogService: ILogService,\n\t\tfileService: IFileService\n\t) {\n\t\tsuper(userDataProfileService.defaultProfile, options, logService, fileService);\n\t}\n\n\tprotected override async doInit(storage: IStorage): Promise<void> {\n\t\tawait super.doInit(storage);\n\n\t\t// Apply telemetry values as part of the application storage initialization\n\t\tthis.updateTelemetryState(storage);\n\t}\n\n\tprivate updateTelemetryState(storage: IStorage): void {\n\n\t\t// First session date (once)\n\t\tconst firstSessionDate = storage.get(firstSessionDateStorageKey, undefined);\n\t\tif (firstSessionDate === undefined) {\n\t\t\tstorage.set(firstSessionDateStorageKey, new Date().toUTCString());\n\t\t}\n\n\t\t// Last / current session (always)\n\t\t// previous session date was the \"current\" one at that time\n\t\t// current session date is \"now\"\n\t\tconst lastSessionDate = storage.get(currentSessionDateStorageKey, undefined);\n\t\tconst currentSessionDate = new Date().toUTCString();\n\t\tstorage.set(lastSessionDateStorageKey, typeof lastSessionDate === 'undefined' ? null : lastSessionDate);\n\t\tstorage.set(currentSessionDateStorageKey, currentSessionDate);\n\t}\n}\n\nexport class WorkspaceStorageMain extends BaseStorageMain {\n\n\tprivate static readonly WORKSPACE_STORAGE_NAME = 'state.vscdb';\n\tprivate static readonly WORKSPACE_META_NAME = 'workspace.json';\n\n\tget path(): string | undefined {\n\t\tif (!this.options.useInMemoryStorage) {\n\t\t\treturn join(this.environmentService.workspaceStorageHome.with({ scheme: Schemas.file }).fsPath, this.workspace.id, WorkspaceStorageMain.WORKSPACE_STORAGE_NAME);\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tconstructor(\n\t\tprivate workspace: IAnyWorkspaceIdentifier,\n\t\tprivate readonly options: IStorageMainOptions,\n\t\tlogService: ILogService,\n\t\tprivate readonly environmentService: IEnvironmentService,\n\t\tfileService: IFileService\n\t) {\n\t\tsuper(logService, fileService);\n\t}\n\n\tprotected async doCreate(): Promise<Storage> {\n\t\tconst { storageFilePath, wasCreated } = await this.prepareWorkspaceStorageFolder();\n\n\t\treturn new Storage(new SQLiteStorageDatabase(storageFilePath, {\n\t\t\tlogging: this.createLoggingOptions()\n\t\t}), { hint: this.options.useInMemoryStorage ? StorageHint.STORAGE_IN_MEMORY : wasCreated ? StorageHint.STORAGE_DOES_NOT_EXIST : undefined });\n\t}\n\n\tprivate async prepareWorkspaceStorageFolder(): Promise<{ storageFilePath: string; wasCreated: boolean }> {\n\n\t\t// Return early if using inMemory storage\n\t\tif (this.options.useInMemoryStorage) {\n\t\t\treturn { storageFilePath: SQLiteStorageDatabase.IN_MEMORY_PATH, wasCreated: true };\n\t\t}\n\n\t\t// Otherwise, ensure the storage folder exists on disk\n\t\tconst workspaceStorageFolderPath = join(this.environmentService.workspaceStorageHome.with({ scheme: Schemas.file }).fsPath, this.workspace.id);\n\t\tconst workspaceStorageDatabasePath = join(workspaceStorageFolderPath, WorkspaceStorageMain.WORKSPACE_STORAGE_NAME);\n\n\t\tconst storageExists = await Promises.exists(workspaceStorageFolderPath);\n\t\tif (storageExists) {\n\t\t\treturn { storageFilePath: workspaceStorageDatabasePath, wasCreated: false };\n\t\t}\n\n\t\t// Ensure storage folder exists\n\t\tawait fs.promises.mkdir(workspaceStorageFolderPath, { recursive: true });\n\n\t\t// Write metadata into folder (but do not await)\n\t\tthis.ensureWorkspaceStorageFolderMeta(workspaceStorageFolderPath);\n\n\t\treturn { storageFilePath: workspaceStorageDatabasePath, wasCreated: true };\n\t}\n\n\tprivate async ensureWorkspaceStorageFolderMeta(workspaceStorageFolderPath: string): Promise<void> {\n\t\tlet meta: object | undefined = undefined;\n\t\tif (isSingleFolderWorkspaceIdentifier(this.workspace)) {\n\t\t\tmeta = { folder: this.workspace.uri.toString() };\n\t\t} else if (isWorkspaceIdentifier(this.workspace)) {\n\t\t\tmeta = { workspace: this.workspace.configPath.toString() };\n\t\t}\n\n\t\tif (meta) {\n\t\t\ttry {\n\t\t\t\tconst workspaceStorageMetaPath = join(workspaceStorageFolderPath, WorkspaceStorageMain.WORKSPACE_META_NAME);\n\t\t\t\tconst storageExists = await Promises.exists(workspaceStorageMetaPath);\n\t\t\t\tif (!storageExists) {\n\t\t\t\t\tawait Promises.writeFile(workspaceStorageMetaPath, JSON.stringify(meta, undefined, 2));\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.error(`[storage main] ensureWorkspaceStorageFolderMeta(): Unable to create workspace storage metadata due to ${error}`);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport class InMemoryStorageMain extends BaseStorageMain {\n\n\tget path(): string | undefined {\n\t\treturn undefined; // in-memory has no path\n\t}\n\n\tprotected async doCreate(): Promise<Storage> {\n\t\treturn new Storage(new InMemoryStorageDatabase(), { hint: StorageHint.STORAGE_IN_MEMORY });\n\t}\n}\n"],
  "mappings": ";;AAKA,YAAY,QAAQ;AACpB,SAAS,WAAW;AACpB,SAAS,uBAAuB;AAChC,SAAS,SAAS,aAAa;AAC/B,SAAS,YAAY,mBAAmB;AACxC,SAAS,YAAY;AACrB,SAAS,iBAAiB;AAC1B,SAAS,WAAW;AACpB,SAAS,gBAAgB;AACzB,SAAS,yBAAyB,UAAU,SAAS,aAAa,oBAAoB;AACtF,SAAS,sCAAsC,6BAA6B;AAC5E,SAAS,2BAA2B;AACpC,SAAS,oBAAoB;AAC7B,SAAS,aAAa,gBAAgB;AACtC,SAAS,kBAAkB;AAC3B,SAAS,kBAAkB,gCAAgC;AAC3D,SAAS,8BAA8B,4BAA4B,iCAAiC;AACpG,SAAS,mCAAmC,uBAAuB,+BAA+B;AAClG,SAAS,eAAe;AA4FxB,MAAe,wBAAwB,WAAmC;AAAA,EAsBzE,YACoB,YACF,aAChB;AACD,UAAM;AAHa;AACF;AAAA,EAGlB;AAAA,EA9ID,OAmH0E;AAAA;AAAA;AAAA,EAEzE,OAAwB,2BAA2B;AAAA,EAEhC,sBAAsB,KAAK,UAAU,IAAI,QAA6B,CAAC;AAAA,EACjF,qBAAqB,KAAK,oBAAoB;AAAA,EAEtC,qBAAqB,KAAK,UAAU,IAAI,QAAc,CAAC;AAAA,EAC/D,oBAAoB,KAAK,mBAAmB;AAAA,EAE7C,WAAW,KAAK,UAAU,IAAI,QAAQ,IAAI,wBAAwB,GAAG,EAAE,MAAM,YAAY,kBAAkB,CAAC,CAAC;AAAA;AAAA,EACrH,IAAI,UAAoB;AAAE,WAAO,KAAK;AAAA,EAAU;AAAA,EAIxC,oBAA+C;AAAA,EAEtC,kBAAkB,IAAI,gBAAsB;AAAA,EACpD,WAAW,KAAK,gBAAgB;AAAA,EAEjC,QAAQ,aAAa;AAAA,EAS7B,aAAsB;AACrB,WAAO,KAAK,SAAS,WAAW;AAAA,EACjC;AAAA,EAEA,OAAsB;AACrB,QAAI,CAAC,KAAK,mBAAmB;AAC5B,WAAK,qBAAqB,YAAY;AACrC,YAAI,KAAK,UAAU,aAAa,MAAM;AACrC;AAAA,QACD;AAEA,YAAI;AAGH,gBAAM,UAAU,KAAK,UAAU,MAAM,KAAK,SAAS,CAAC;AAKpD,eAAK,SAAS,QAAQ;AACtB,eAAK,WAAW;AAGhB,eAAK,UAAU,QAAQ,mBAAmB,OAAK,KAAK,oBAAoB,KAAK,CAAC,CAAC,CAAC;AAGhF,gBAAM,KAAK,OAAO,OAAO;AAGzB,gBAAM,eAAe,QAAQ,WAAW,UAAU;AAClD,cAAI,iBAAiB,QAAW;AAC/B,oBAAQ,IAAI,YAAY,IAAI;AAAA,UAC7B,WAAW,cAAc;AACxB,oBAAQ,IAAI,YAAY,KAAK;AAAA,UAC9B;AAAA,QACD,SAAS,OAAO;AACf,eAAK,WAAW,MAAM,8DAA8D,KAAK,EAAE;AAAA,QAC5F,UAAE;AAGD,eAAK,QAAQ,aAAa;AAG1B,eAAK,gBAAgB,SAAS;AAAA,QAC/B;AAAA,MACD,GAAG;AAAA,IACJ;AAEA,WAAO,KAAK;AAAA,EACb;AAAA,EAEU,uBAA6D;AACtE,WAAO;AAAA,MACN,UAAW,KAAK,WAAW,SAAS,MAAM,SAAS,QAAS,SAAO,KAAK,WAAW,MAAM,GAAG,IAAI;AAAA,MAChG,UAAU,kCAAS,KAAK,WAAW,MAAM,KAAK,GAApC;AAAA,IACX;AAAA,EACD;AAAA,EAEU,OAAO,SAAkC;AAClD,WAAO,QAAQ,KAAK;AAAA,EACrB;AAAA,EAIA,IAAI,QAA6B;AAAE,WAAO,KAAK,SAAS;AAAA,EAAO;AAAA,EAI/D,IAAI,KAAa,eAA4C;AAC5D,WAAO,KAAK,SAAS,IAAI,KAAK,aAAa;AAAA,EAC5C;AAAA,EAEA,IAAI,KAAa,OAAoE;AACpF,WAAO,KAAK,SAAS,IAAI,KAAK,KAAK;AAAA,EACpC;AAAA,EAEA,OAAO,KAA4B;AAClC,WAAO,KAAK,SAAS,OAAO,GAAG;AAAA,EAChC;AAAA,EAEA,WAA0B;AACzB,WAAO,KAAK,SAAS,SAAS;AAAA,EAC/B;AAAA,EAEA,MAAM,QAAuB;AAG5B,UAAM,QAAQ,IAAI,UAAU,KAAK;AACjC,UAAM,KAAK,QAAQ;AACnB,UAAM,KAAK;AAMX,QAAI,MAAM,QAAQ,IAAI,gBAAgB,0BAA0B;AAC/D,YAAM,KAAK,aAAa,KAAK;AAAA,IAC9B;AAGA,SAAK,mBAAmB,KAAK;AAAA,EAC9B;AAAA,EAEA,MAAc,aAAa,OAAkB;AAC5C,QAAI,CAAC,KAAK,MAAM;AACf;AAAA,IACD;AAEA,QAAI;AACH,YAAM,iBAAiB,IAAI,MAAM,KAAK,KAAK,SAAS,MAAM,QAAQ,CAAC,EACjE,IAAI,CAAC,CAAC,KAAK,KAAK,OAAO,EAAE,KAAK,QAAQ,MAAM,OAAO,EAAE,GAAG,CAAC,QAAQ,WAAW,OAAO,SAAS,OAAO,QAAQ,CAAC,EAC5G,IAAI,WAAS,GAAG,MAAM,GAAG,IAAI,MAAM,MAAM,EAAE,EAAE,KAAK,IAAI;AACxD,YAAM,UAAU,MAAM,KAAK,YAAY,KAAK,IAAI,KAAK,KAAK,IAAI,CAAC,GAAG;AAElE,WAAK,WAAW,KAAK,yDAAyD,MAAM,QAAQ,CAAC,gBAAgB,MAAM,kBAAkB,cAAc,EAAE;AAAA,IACtJ,SAAS,OAAO;AACf,WAAK,WAAW,MAAM,iFAAiF,KAAK;AAAA,IAC7G;AAAA,EACD;AAAA,EAEA,MAAc,UAAyB;AAMtC,QAAI,KAAK,mBAAmB;AAC3B,YAAM,KAAK;AAAA,IACZ;AAGA,SAAK,QAAQ,aAAa;AAG1B,UAAM,KAAK,SAAS,MAAM;AAAA,EAC3B;AACD;AAEA,MAAM,oCAAoC,gBAAgB;AAAA,EAYzD,YACkB,SACA,SACjB,YACA,aACC;AACD,UAAM,YAAY,WAAW;AALZ;AACA;AAAA,EAKlB;AAAA,EA7SD,OA0R0D;AAAA;AAAA;AAAA,EAEzD,OAAwB,eAAe;AAAA,EAEvC,IAAI,OAA2B;AAC9B,QAAI,CAAC,KAAK,QAAQ,oBAAoB;AACrC,aAAO,KAAK,KAAK,QAAQ,kBAAkB,KAAK,EAAE,QAAQ,QAAQ,KAAK,CAAC,EAAE,QAAQ,4BAA4B,YAAY;AAAA,IAC3H;AAEA,WAAO;AAAA,EACR;AAAA,EAWA,MAAgB,WAA6B;AAC5C,WAAO,IAAI,QAAQ,IAAI,sBAAsB,KAAK,QAAQ,sBAAsB,gBAAgB;AAAA,MAC/F,SAAS,KAAK,qBAAqB;AAAA,IACpC,CAAC,GAAG,CAAC,KAAK,OAAO,EAAE,MAAM,YAAY,kBAAkB,IAAI,MAAS;AAAA,EACrE;AACD;AAEO,MAAM,2BAA2B,4BAA4B;AAAA,EAtTpE,OAsToE;AAAA;AAAA;AAAA,EAEnE,YACC,SACA,SACA,YACA,aACC;AACD,UAAM,SAAS,SAAS,YAAY,WAAW;AAAA,EAChD;AACD;AAEO,MAAM,+BAA+B,4BAA4B;AAAA,EAlUxE,OAkUwE;AAAA;AAAA;AAAA,EAEvE,YACC,SACA,wBACA,YACA,aACC;AACD,UAAM,uBAAuB,gBAAgB,SAAS,YAAY,WAAW;AAAA,EAC9E;AAAA,EAEA,MAAyB,OAAO,SAAkC;AACjE,UAAM,MAAM,OAAO,OAAO;AAG1B,SAAK,qBAAqB,OAAO;AAAA,EAClC;AAAA,EAEQ,qBAAqB,SAAyB;AAGrD,UAAM,mBAAmB,QAAQ,IAAI,4BAA4B,MAAS;AAC1E,QAAI,qBAAqB,QAAW;AACnC,cAAQ,IAAI,6BAA4B,oBAAI,KAAK,GAAE,YAAY,CAAC;AAAA,IACjE;AAKA,UAAM,kBAAkB,QAAQ,IAAI,8BAA8B,MAAS;AAC3E,UAAM,sBAAqB,oBAAI,KAAK,GAAE,YAAY;AAClD,YAAQ,IAAI,2BAA2B,OAAO,oBAAoB,cAAc,OAAO,eAAe;AACtG,YAAQ,IAAI,8BAA8B,kBAAkB;AAAA,EAC7D;AACD;AAEO,MAAM,6BAA6B,gBAAgB;AAAA,EAazD,YACS,WACS,SACjB,YACiB,oBACjB,aACC;AACD,UAAM,YAAY,WAAW;AANrB;AACS;AAEA;AAAA,EAIlB;AAAA,EA3XD,OAsW0D;AAAA;AAAA;AAAA,EAEzD,OAAwB,yBAAyB;AAAA,EACjD,OAAwB,sBAAsB;AAAA,EAE9C,IAAI,OAA2B;AAC9B,QAAI,CAAC,KAAK,QAAQ,oBAAoB;AACrC,aAAO,KAAK,KAAK,mBAAmB,qBAAqB,KAAK,EAAE,QAAQ,QAAQ,KAAK,CAAC,EAAE,QAAQ,KAAK,UAAU,IAAI,qBAAqB,sBAAsB;AAAA,IAC/J;AAEA,WAAO;AAAA,EACR;AAAA,EAYA,MAAgB,WAA6B;AAC5C,UAAM,EAAE,iBAAiB,WAAW,IAAI,MAAM,KAAK,8BAA8B;AAEjF,WAAO,IAAI,QAAQ,IAAI,sBAAsB,iBAAiB;AAAA,MAC7D,SAAS,KAAK,qBAAqB;AAAA,IACpC,CAAC,GAAG,EAAE,MAAM,KAAK,QAAQ,qBAAqB,YAAY,oBAAoB,aAAa,YAAY,yBAAyB,OAAU,CAAC;AAAA,EAC5I;AAAA,EAEA,MAAc,gCAA2F;AAGxG,QAAI,KAAK,QAAQ,oBAAoB;AACpC,aAAO,EAAE,iBAAiB,sBAAsB,gBAAgB,YAAY,KAAK;AAAA,IAClF;AAGA,UAAM,6BAA6B,KAAK,KAAK,mBAAmB,qBAAqB,KAAK,EAAE,QAAQ,QAAQ,KAAK,CAAC,EAAE,QAAQ,KAAK,UAAU,EAAE;AAC7I,UAAM,+BAA+B,KAAK,4BAA4B,qBAAqB,sBAAsB;AAEjH,UAAM,gBAAgB,MAAM,SAAS,OAAO,0BAA0B;AACtE,QAAI,eAAe;AAClB,aAAO,EAAE,iBAAiB,8BAA8B,YAAY,MAAM;AAAA,IAC3E;AAGA,UAAM,GAAG,SAAS,MAAM,4BAA4B,EAAE,WAAW,KAAK,CAAC;AAGvE,SAAK,iCAAiC,0BAA0B;AAEhE,WAAO,EAAE,iBAAiB,8BAA8B,YAAY,KAAK;AAAA,EAC1E;AAAA,EAEA,MAAc,iCAAiC,4BAAmD;AACjG,QAAI,OAA2B;AAC/B,QAAI,kCAAkC,KAAK,SAAS,GAAG;AACtD,aAAO,EAAE,QAAQ,KAAK,UAAU,IAAI,SAAS,EAAE;AAAA,IAChD,WAAW,sBAAsB,KAAK,SAAS,GAAG;AACjD,aAAO,EAAE,WAAW,KAAK,UAAU,WAAW,SAAS,EAAE;AAAA,IAC1D;AAEA,QAAI,MAAM;AACT,UAAI;AACH,cAAM,2BAA2B,KAAK,4BAA4B,qBAAqB,mBAAmB;AAC1G,cAAM,gBAAgB,MAAM,SAAS,OAAO,wBAAwB;AACpE,YAAI,CAAC,eAAe;AACnB,gBAAM,SAAS,UAAU,0BAA0B,KAAK,UAAU,MAAM,QAAW,CAAC,CAAC;AAAA,QACtF;AAAA,MACD,SAAS,OAAO;AACf,aAAK,WAAW,MAAM,yGAAyG,KAAK,EAAE;AAAA,MACvI;AAAA,IACD;AAAA,EACD;AACD;AAEO,MAAM,4BAA4B,gBAAgB;AAAA,EApbzD,OAobyD;AAAA;AAAA;AAAA,EAExD,IAAI,OAA2B;AAC9B,WAAO;AAAA,EACR;AAAA,EAEA,MAAgB,WAA6B;AAC5C,WAAO,IAAI,QAAQ,IAAI,wBAAwB,GAAG,EAAE,MAAM,YAAY,kBAAkB,CAAC;AAAA,EAC1F;AACD;",
  "names": []
}
