var T=Object.defineProperty;var w=Object.getOwnPropertyDescriptor;var g=(n,e,t,r)=>{for(var s=r>1?void 0:r?w(e,t):e,i=n.length-1,o;i>=0;i--)(o=n[i])&&(s=(r?o(e,t,s):o(s))||s);return r&&s&&T(e,t,s),s},_=(n,e)=>(t,r)=>e(t,r,n);import{PauseableEmitter as A}from"../../../base/common/event.js";import{Iterable as h}from"../../../base/common/iterator.js";import{Disposable as D,MutableDisposable as N}from"../../../base/common/lifecycle.js";import"../../../base/common/marshalling.js";import{MarshalledId as R}from"../../../base/common/marshallingIds.js";import{cloneAndChange as k,distinct as b}from"../../../base/common/objects.js";import{TernarySearchTree as O}from"../../../base/common/ternarySearchTree.js";import{URI as m}from"../../../base/common/uri.js";import{localize as P}from"../../../nls.js";import{CommandsRegistry as p}from"../../commands/common/commands.js";import{ConfigurationTarget as M,IConfigurationService as L}from"../../configuration/common/configuration.js";import{IContextKeyService as j,RawContextKey as I}from"../common/contextkey.js";import"../../instantiation/common/instantiation.js";const c="data-keybinding-context";class x{_parent;_value;_id;constructor(e,t){this._id=e,this._parent=t,this._value=Object.create(null),this._value._contextId=e}get value(){return{...this._value}}setValue(e,t){return this._value[e]!==t?(this._value[e]=t,!0):!1}removeValue(e){return e in this._value?(delete this._value[e],!0):!1}getValue(e){const t=this._value[e];return typeof t>"u"&&this._parent?this._parent.getValue(e):t}updateParent(e){this._parent=e}collectAllValues(){let e=this._parent?this._parent.collectAllValues():Object.create(null);return e={...e,...this._value},delete e._contextId,e}}class a extends x{static INSTANCE=new a;constructor(){super(-1,null)}setValue(e,t){return!1}removeValue(e){return!1}getValue(e){}collectAllValues(){return Object.create(null)}}class C extends x{constructor(t,r,s){super(t,null);this._configurationService=r;this._listener=this._configurationService.onDidChangeConfiguration(i=>{if(i.source===M.DEFAULT){const o=Array.from(this._values,([l])=>l);this._values.clear(),s.fire(new y(o))}else{const o=[];for(const l of i.affectedKeys){const u=`config.${l}`,f=this._values.findSuperstr(u);f!==void 0&&(o.push(...h.map(f,([E])=>E)),this._values.deleteSuperstr(u)),this._values.has(u)&&(o.push(u),this._values.delete(u))}s.fire(new y(o))}})}static _keyPrefix="config.";_values=O.forConfigKeys();_listener;dispose(){this._listener.dispose()}getValue(t){if(t.indexOf(C._keyPrefix)!==0)return super.getValue(t);if(this._values.has(t))return this._values.get(t);const r=t.substr(C._keyPrefix.length),s=this._configurationService.getValue(r);let i;switch(typeof s){case"number":case"boolean":case"string":i=s;break;default:Array.isArray(s)?i=JSON.stringify(s):i=s}return this._values.set(t,i),i}setValue(t,r){return super.setValue(t,r)}removeValue(t){return super.removeValue(t)}collectAllValues(){const t=Object.create(null);return this._values.forEach((r,s)=>t[s]=r),{...t,...super.collectAllValues()}}}class U{_service;_key;_defaultValue;constructor(e,t,r){this._service=e,this._key=t,this._defaultValue=r,this.reset()}set(e){this._service.setContext(this._key,e)}reset(){typeof this._defaultValue>"u"?this._service.removeContext(this._key):this._service.setContext(this._key,this._defaultValue)}get(){return this._service.getContextKeyValue(this._key)}}class K{constructor(e){this.key=e}affectsSome(e){return e.has(this.key)}allKeysContainedIn(e){return this.affectsSome(e)}}class y{constructor(e){this.keys=e}affectsSome(e){for(const t of this.keys)if(e.has(t))return!0;return!1}allKeysContainedIn(e){return this.keys.every(t=>e.has(t))}}class B{constructor(e){this.events=e}affectsSome(e){for(const t of this.events)if(t.affectsSome(e))return!0;return!1}allKeysContainedIn(e){return this.events.every(t=>t.allKeysContainedIn(e))}}function F(n,e){return n.allKeysContainedIn(new Set(Object.keys(e)))}class S extends D{_isDisposed;_myContextId;_onDidChangeContext=this._register(new A({merge:e=>new B(e)}));onDidChangeContext=this._onDidChangeContext.event;constructor(e){super(),this._isDisposed=!1,this._myContextId=e}get contextId(){return this._myContextId}createKey(e,t){if(this._isDisposed)throw new Error("AbstractContextKeyService has been disposed");return new U(this,e,t)}bufferChangeEvents(e){this._onDidChangeContext.pause();try{e()}finally{this._onDidChangeContext.resume()}}createScoped(e){if(this._isDisposed)throw new Error("AbstractContextKeyService has been disposed");return new $(this,e)}createOverlay(e=h.empty()){if(this._isDisposed)throw new Error("AbstractContextKeyService has been disposed");return new v(this,e)}contextMatchesRules(e){if(this._isDisposed)throw new Error("AbstractContextKeyService has been disposed");const t=this.getContextValuesContainer(this._myContextId);return e?e.evaluate(t):!0}getContextKeyValue(e){if(!this._isDisposed)return this.getContextValuesContainer(this._myContextId).getValue(e)}setContext(e,t){if(this._isDisposed)return;const r=this.getContextValuesContainer(this._myContextId);r&&r.setValue(e,t)&&this._onDidChangeContext.fire(new K(e))}removeContext(e){this._isDisposed||this.getContextValuesContainer(this._myContextId).removeValue(e)&&this._onDidChangeContext.fire(new K(e))}getContext(e){return this._isDisposed?a.INSTANCE:this.getContextValuesContainer(H(e))}dispose(){super.dispose(),this._isDisposed=!0}}let d=class extends S{_lastContextId;_contexts=new Map;constructor(e){super(0),this._lastContextId=0;const t=this._register(new C(this._myContextId,e,this._onDidChangeContext));this._contexts.set(this._myContextId,t)}getContextValuesContainer(e){return this._isDisposed?a.INSTANCE:this._contexts.get(e)||a.INSTANCE}createChildContext(e=this._myContextId){if(this._isDisposed)throw new Error("ContextKeyService has been disposed");const t=++this._lastContextId;return this._contexts.set(t,new x(t,this.getContextValuesContainer(e))),t}disposeContext(e){this._isDisposed||this._contexts.delete(e)}updateParent(e){throw new Error("Cannot update parent of root ContextKeyService")}};d=g([_(0,L)],d);class $ extends S{_parent;_domNode;_parentChangeListener=this._register(new N);constructor(e,t){if(super(e.createChildContext()),this._parent=e,this._updateParentChangeListener(),this._domNode=t,this._domNode.hasAttribute(c)){let r="";this._domNode.classList&&(r=Array.from(this._domNode.classList.values()).join(", "))}this._domNode.setAttribute(c,String(this._myContextId))}_updateParentChangeListener(){this._parentChangeListener.value=this._parent.onDidChangeContext(e=>{const r=this._parent.getContextValuesContainer(this._myContextId).value;F(e,r)||this._onDidChangeContext.fire(e)})}dispose(){this._isDisposed||(this._parent.disposeContext(this._myContextId),this._domNode.removeAttribute(c),super.dispose())}getContextValuesContainer(e){return this._isDisposed?a.INSTANCE:this._parent.getContextValuesContainer(e)}createChildContext(e=this._myContextId){if(this._isDisposed)throw new Error("ScopedContextKeyService has been disposed");return this._parent.createChildContext(e)}disposeContext(e){this._isDisposed||this._parent.disposeContext(e)}updateParent(e){if(this._parent===e)return;const t=this._parent.getContextValuesContainer(this._myContextId),r=t.collectAllValues();this._parent=e,this._updateParentChangeListener();const s=this._parent.getContextValuesContainer(this._parent.contextId);t.updateParent(s);const i=t.collectAllValues(),o={...b(r,i),...b(i,r)},l=Object.keys(o);this._onDidChangeContext.fire(new y(l))}}class V{constructor(e,t){this.parent=e;this.overlay=t}getValue(e){return this.overlay.has(e)?this.overlay.get(e):this.parent.getValue(e)}}class v{constructor(e,t){this.parent=e;this.overlay=new Map(t)}overlay;get contextId(){return this.parent.contextId}get onDidChangeContext(){return this.parent.onDidChangeContext}bufferChangeEvents(e){this.parent.bufferChangeEvents(e)}createKey(){throw new Error("Not supported.")}getContext(e){return new V(this.parent.getContext(e),this.overlay)}getContextValuesContainer(e){const t=this.parent.getContextValuesContainer(e);return new V(t,this.overlay)}contextMatchesRules(e){const t=this.getContextValuesContainer(this.contextId);return e?e.evaluate(t):!0}getContextKeyValue(e){return this.overlay.has(e)?this.overlay.get(e):this.parent.getContextKeyValue(e)}createScoped(){throw new Error("Not supported.")}createOverlay(e=h.empty()){return new v(this,e)}updateParent(){throw new Error("Not supported.")}}function H(n){for(;n;){if(n.hasAttribute(c)){const e=n.getAttribute(c);return e?parseInt(e,10):NaN}n=n.parentElement}return 0}function J(n,e,t){n.get(j).createKey(String(e),z(t))}function z(n){return k(n,e=>{if(typeof e=="object"&&e.$mid===R.Uri)return m.revive(e).toString();if(e instanceof m)return e.toString()})}p.registerCommand("_setContext",J),p.registerCommand({id:"getContextKeyInfo",handler(){return[...I.all()].sort((n,e)=>n.key.localeCompare(e.key))},metadata:{description:P("getContextKeyInfo","A command that returns information about context keys"),args:[]}}),p.registerCommand("_generateContextKeyInfo",function(){const n=[],e=new Set;for(const t of I.all())e.has(t.key)||(e.add(t.key),n.push(t));n.sort((t,r)=>t.key.localeCompare(r.key))});export{S as AbstractContextKeyService,x as Context,d as ContextKeyService,J as setContext};
