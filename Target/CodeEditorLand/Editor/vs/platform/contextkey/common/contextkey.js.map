{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/contextkey/common/contextkey.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from \"../../../base/common/charCode.js\";\nimport { illegalArgument } from \"../../../base/common/errors.js\";\nimport type { Event } from \"../../../base/common/event.js\";\nimport type { IDisposable } from \"../../../base/common/lifecycle.js\";\nimport {\n\tisChrome,\n\tisEdge,\n\tisFirefox,\n\tisLinux,\n\tisMacintosh,\n\tisSafari,\n\tisWeb,\n\tisWindows,\n} from \"../../../base/common/platform.js\";\nimport { isFalsyOrWhitespace } from \"../../../base/common/strings.js\";\nimport { localize } from \"../../../nls.js\";\nimport { createDecorator } from \"../../instantiation/common/instantiation.js\";\nimport { type LexingError, Scanner, type Token, TokenType } from \"./scanner.js\";\n\nconst CONSTANT_VALUES = new Map<string, boolean>();\nCONSTANT_VALUES.set(\"false\", false);\nCONSTANT_VALUES.set(\"true\", true);\nCONSTANT_VALUES.set(\"isMac\", isMacintosh);\nCONSTANT_VALUES.set(\"isLinux\", isLinux);\nCONSTANT_VALUES.set(\"isWindows\", isWindows);\nCONSTANT_VALUES.set(\"isWeb\", isWeb);\nCONSTANT_VALUES.set(\"isMacNative\", isMacintosh && !isWeb);\nCONSTANT_VALUES.set(\"isEdge\", isEdge);\nCONSTANT_VALUES.set(\"isFirefox\", isFirefox);\nCONSTANT_VALUES.set(\"isChrome\", isChrome);\nCONSTANT_VALUES.set(\"isSafari\", isSafari);\n\n/** allow register constant context keys that are known only after startup; requires running `substituteConstants` on the context key - https://github.com/microsoft/vscode/issues/174218#issuecomment-1437972127 */\nexport function setConstant(key: string, value: boolean) {\n\tif (CONSTANT_VALUES.get(key) !== undefined) {\n\t\tthrow illegalArgument(\n\t\t\t\"contextkey.setConstant(k, v) invoked with already set constant `k`\",\n\t\t);\n\t}\n\n\tCONSTANT_VALUES.set(key, value);\n}\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nexport enum ContextKeyExprType {\n\tFalse = 0,\n\tTrue = 1,\n\tDefined = 2,\n\tNot = 3,\n\tEquals = 4,\n\tNotEquals = 5,\n\tAnd = 6,\n\tRegex = 7,\n\tNotRegex = 8,\n\tOr = 9,\n\tIn = 10,\n\tNotIn = 11,\n\tGreater = 12,\n\tGreaterEquals = 13,\n\tSmaller = 14,\n\tSmallerEquals = 15,\n}\n\nexport interface IContextKeyExprMapper {\n\tmapDefined(key: string): ContextKeyExpression;\n\tmapNot(key: string): ContextKeyExpression;\n\tmapEquals(key: string, value: any): ContextKeyExpression;\n\tmapNotEquals(key: string, value: any): ContextKeyExpression;\n\tmapGreater(key: string, value: any): ContextKeyExpression;\n\tmapGreaterEquals(key: string, value: any): ContextKeyExpression;\n\tmapSmaller(key: string, value: any): ContextKeyExpression;\n\tmapSmallerEquals(key: string, value: any): ContextKeyExpression;\n\tmapRegex(key: string, regexp: RegExp | null): ContextKeyRegexExpr;\n\tmapIn(key: string, valueKey: string): ContextKeyInExpr;\n\tmapNotIn(key: string, valueKey: string): ContextKeyNotInExpr;\n}\n\nexport interface IContextKeyExpression {\n\tcmp(other: ContextKeyExpression): number;\n\tequals(other: ContextKeyExpression): boolean;\n\tsubstituteConstants(): ContextKeyExpression | undefined;\n\tevaluate(context: IContext): boolean;\n\tserialize(): string;\n\tkeys(): string[];\n\tmap(mapFnc: IContextKeyExprMapper): ContextKeyExpression;\n\tnegate(): ContextKeyExpression;\n}\n\nexport type ContextKeyExpression =\n\t| ContextKeyFalseExpr\n\t| ContextKeyTrueExpr\n\t| ContextKeyDefinedExpr\n\t| ContextKeyNotExpr\n\t| ContextKeyEqualsExpr\n\t| ContextKeyNotEqualsExpr\n\t| ContextKeyRegexExpr\n\t| ContextKeyNotRegexExpr\n\t| ContextKeyAndExpr\n\t| ContextKeyOrExpr\n\t| ContextKeyInExpr\n\t| ContextKeyNotInExpr\n\t| ContextKeyGreaterExpr\n\t| ContextKeyGreaterEqualsExpr\n\t| ContextKeySmallerExpr\n\t| ContextKeySmallerEqualsExpr;\n\n/*\n\nSyntax grammar:\n\n```ebnf\n\nexpression ::= or\n\nor ::= and { '||' and }*\n\nand ::= term { '&&' term }*\n\nterm ::=\n\t| '!' (KEY | true | false | parenthesized)\n\t| primary\n\nprimary ::=\n\t| 'true'\n\t| 'false'\n\t| parenthesized\n\t| KEY '=~' REGEX\n\t| KEY [ ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'not' 'in' | 'in') value ]\n\nparenthesized ::=\n\t| '(' expression ')'\n\nvalue ::=\n\t| 'true'\n\t| 'false'\n\t| 'in'      \t// we support `in` as a value because there's an extension that uses it, ie \"when\": \"languageId == in\"\n\t| VALUE \t\t// matched by the same regex as KEY; consider putting the value in single quotes if it's a string (e.g., with spaces)\n\t| SINGLE_QUOTED_STR\n\t| EMPTY_STR  \t// this allows \"when\": \"foo == \" which's used by existing extensions\n\n```\n*/\n\nexport type ParserConfig = {\n\t/**\n\t * with this option enabled, the parser can recover from regex parsing errors, e.g., unescaped slashes: `/src//` is accepted as `/src\\//` would be\n\t */\n\tregexParsingWithErrorRecovery: boolean;\n};\n\nconst defaultConfig: ParserConfig = {\n\tregexParsingWithErrorRecovery: true,\n};\n\nexport type ParsingError = {\n\tmessage: string;\n\toffset: number;\n\tlexeme: string;\n\tadditionalInfo?: string;\n};\n\nconst errorEmptyString = localize(\n\t\"contextkey.parser.error.emptyString\",\n\t\"Empty context key expression\",\n);\nconst hintEmptyString = localize(\n\t\"contextkey.parser.error.emptyString.hint\",\n\t\"Did you forget to write an expression? You can also put 'false' or 'true' to always evaluate to false or true, respectively.\",\n);\nconst errorNoInAfterNot = localize(\n\t\"contextkey.parser.error.noInAfterNot\",\n\t\"'in' after 'not'.\",\n);\nconst errorClosingParenthesis = localize(\n\t\"contextkey.parser.error.closingParenthesis\",\n\t\"closing parenthesis ')'\",\n);\nconst errorUnexpectedToken = localize(\n\t\"contextkey.parser.error.unexpectedToken\",\n\t\"Unexpected token\",\n);\nconst hintUnexpectedToken = localize(\n\t\"contextkey.parser.error.unexpectedToken.hint\",\n\t\"Did you forget to put && or || before the token?\",\n);\nconst errorUnexpectedEOF = localize(\n\t\"contextkey.parser.error.unexpectedEOF\",\n\t\"Unexpected end of expression\",\n);\nconst hintUnexpectedEOF = localize(\n\t\"contextkey.parser.error.unexpectedEOF.hint\",\n\t\"Did you forget to put a context key?\",\n);\n\n/**\n * A parser for context key expressions.\n *\n * Example:\n * ```ts\n * const parser = new Parser();\n * const expr = parser.parse('foo == \"bar\" && baz == true');\n *\n * if (expr === undefined) {\n * \t// there were lexing or parsing errors\n * \t// process lexing errors with `parser.lexingErrors`\n *  // process parsing errors with `parser.parsingErrors`\n * } else {\n * \t// expr is a valid expression\n * }\n * ```\n */\nexport class Parser {\n\t// Note: this doesn't produce an exact syntax tree but a normalized one\n\t// ContextKeyExpression's that we use as AST nodes do not expose constructors that do not normalize\n\n\tprivate static _parseError = new Error();\n\n\t// lifetime note: `_scanner` lives as long as the parser does, i.e., is not reset between calls to `parse`\n\tprivate readonly _scanner = new Scanner();\n\n\t// lifetime note: `_tokens`, `_current`, and `_parsingErrors` must be reset between calls to `parse`\n\tprivate _tokens: Token[] = [];\n\tprivate _current = 0; // invariant: 0 <= this._current < this._tokens.length ; any incrementation of this value must first call `_isAtEnd`\n\tprivate _parsingErrors: ParsingError[] = [];\n\n\tget lexingErrors(): Readonly<LexingError[]> {\n\t\treturn this._scanner.errors;\n\t}\n\n\tget parsingErrors(): Readonly<ParsingError[]> {\n\t\treturn this._parsingErrors;\n\t}\n\n\tconstructor(private readonly _config: ParserConfig = defaultConfig) {}\n\n\t/**\n\t * Parse a context key expression.\n\t *\n\t * @param input the expression to parse\n\t * @returns the parsed expression or `undefined` if there's an error - call `lexingErrors` and `parsingErrors` to see the errors\n\t */\n\tparse(input: string): ContextKeyExpression | undefined {\n\t\tif (input === \"\") {\n\t\t\tthis._parsingErrors.push({\n\t\t\t\tmessage: errorEmptyString,\n\t\t\t\toffset: 0,\n\t\t\t\tlexeme: \"\",\n\t\t\t\tadditionalInfo: hintEmptyString,\n\t\t\t});\n\t\t\treturn undefined;\n\t\t}\n\n\t\tthis._tokens = this._scanner.reset(input).scan();\n\t\t// @ulugbekna: we do not stop parsing if there are lexing errors to be able to reconstruct regexes with unescaped slashes; TODO@ulugbekna: make this respect config option for recovery\n\n\t\tthis._current = 0;\n\t\tthis._parsingErrors = [];\n\n\t\ttry {\n\t\t\tconst expr = this._expr();\n\t\t\tif (!this._isAtEnd()) {\n\t\t\t\tconst peek = this._peek();\n\t\t\t\tconst additionalInfo =\n\t\t\t\t\tpeek.type === TokenType.Str\n\t\t\t\t\t\t? hintUnexpectedToken\n\t\t\t\t\t\t: undefined;\n\t\t\t\tthis._parsingErrors.push({\n\t\t\t\t\tmessage: errorUnexpectedToken,\n\t\t\t\t\toffset: peek.offset,\n\t\t\t\t\tlexeme: Scanner.getLexeme(peek),\n\t\t\t\t\tadditionalInfo,\n\t\t\t\t});\n\t\t\t\tthrow Parser._parseError;\n\t\t\t}\n\t\t\treturn expr;\n\t\t} catch (e) {\n\t\t\tif (!(e === Parser._parseError)) {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tprivate _expr(): ContextKeyExpression | undefined {\n\t\treturn this._or();\n\t}\n\n\tprivate _or(): ContextKeyExpression | undefined {\n\t\tconst expr = [this._and()];\n\n\t\twhile (this._matchOne(TokenType.Or)) {\n\t\t\tconst right = this._and();\n\t\t\texpr.push(right);\n\t\t}\n\n\t\treturn expr.length === 1 ? expr[0] : ContextKeyExpr.or(...expr);\n\t}\n\n\tprivate _and(): ContextKeyExpression | undefined {\n\t\tconst expr = [this._term()];\n\n\t\twhile (this._matchOne(TokenType.And)) {\n\t\t\tconst right = this._term();\n\t\t\texpr.push(right);\n\t\t}\n\n\t\treturn expr.length === 1 ? expr[0] : ContextKeyExpr.and(...expr);\n\t}\n\n\tprivate _term(): ContextKeyExpression | undefined {\n\t\tif (this._matchOne(TokenType.Neg)) {\n\t\t\tconst peek = this._peek();\n\t\t\tswitch (peek.type) {\n\t\t\t\tcase TokenType.True:\n\t\t\t\t\tthis._advance();\n\t\t\t\t\treturn ContextKeyFalseExpr.INSTANCE;\n\t\t\t\tcase TokenType.False:\n\t\t\t\t\tthis._advance();\n\t\t\t\t\treturn ContextKeyTrueExpr.INSTANCE;\n\t\t\t\tcase TokenType.LParen: {\n\t\t\t\t\tthis._advance();\n\t\t\t\t\tconst expr = this._expr();\n\t\t\t\t\tthis._consume(TokenType.RParen, errorClosingParenthesis);\n\t\t\t\t\treturn expr?.negate();\n\t\t\t\t}\n\t\t\t\tcase TokenType.Str:\n\t\t\t\t\tthis._advance();\n\t\t\t\t\treturn ContextKeyNotExpr.create(peek.lexeme);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow this._errExpectedButGot(\n\t\t\t\t\t\t`KEY | true | false | '(' expression ')'`,\n\t\t\t\t\t\tpeek,\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn this._primary();\n\t}\n\n\tprivate _primary(): ContextKeyExpression | undefined {\n\t\tconst peek = this._peek();\n\t\tswitch (peek.type) {\n\t\t\tcase TokenType.True:\n\t\t\t\tthis._advance();\n\t\t\t\treturn ContextKeyExpr.true();\n\n\t\t\tcase TokenType.False:\n\t\t\t\tthis._advance();\n\t\t\t\treturn ContextKeyExpr.false();\n\n\t\t\tcase TokenType.LParen: {\n\t\t\t\tthis._advance();\n\t\t\t\tconst expr = this._expr();\n\t\t\t\tthis._consume(TokenType.RParen, errorClosingParenthesis);\n\t\t\t\treturn expr;\n\t\t\t}\n\n\t\t\tcase TokenType.Str: {\n\t\t\t\t// KEY\n\t\t\t\tconst key = peek.lexeme;\n\t\t\t\tthis._advance();\n\n\t\t\t\t// =~ regex\n\t\t\t\tif (this._matchOne(TokenType.RegexOp)) {\n\t\t\t\t\t// @ulugbekna: we need to reconstruct the regex from the tokens because some extensions use unescaped slashes in regexes\n\t\t\t\t\tconst expr = this._peek();\n\n\t\t\t\t\tif (!this._config.regexParsingWithErrorRecovery) {\n\t\t\t\t\t\tthis._advance();\n\t\t\t\t\t\tif (expr.type !== TokenType.RegexStr) {\n\t\t\t\t\t\t\tthrow this._errExpectedButGot(`REGEX`, expr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst regexLexeme = expr.lexeme;\n\t\t\t\t\t\tconst closingSlashIndex = regexLexeme.lastIndexOf(\"/\");\n\t\t\t\t\t\tconst flags =\n\t\t\t\t\t\t\tclosingSlashIndex === regexLexeme.length - 1\n\t\t\t\t\t\t\t\t? undefined\n\t\t\t\t\t\t\t\t: this._removeFlagsGY(\n\t\t\t\t\t\t\t\t\t\tregexLexeme.substring(\n\t\t\t\t\t\t\t\t\t\t\tclosingSlashIndex + 1,\n\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\tlet regexp: RegExp | null;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tregexp = new RegExp(\n\t\t\t\t\t\t\t\tregexLexeme.substring(1, closingSlashIndex),\n\t\t\t\t\t\t\t\tflags,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tthrow this._errExpectedButGot(`REGEX`, expr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn ContextKeyRegexExpr.create(key, regexp);\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch (expr.type) {\n\t\t\t\t\t\tcase TokenType.RegexStr:\n\t\t\t\t\t\tcase TokenType.Error: {\n\t\t\t\t\t\t\t// also handle an ErrorToken in case of smth such as /(/file)/\n\t\t\t\t\t\t\tconst lexemeReconstruction = [expr.lexeme]; // /REGEX/ or /REGEX/FLAGS\n\t\t\t\t\t\t\tthis._advance();\n\n\t\t\t\t\t\t\tlet followingToken = this._peek();\n\t\t\t\t\t\t\tlet parenBalance = 0;\n\t\t\t\t\t\t\tfor (let i = 0; i < expr.lexeme.length; i++) {\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\texpr.lexeme.charCodeAt(i) ===\n\t\t\t\t\t\t\t\t\tCharCode.OpenParen\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tparenBalance++;\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\texpr.lexeme.charCodeAt(i) ===\n\t\t\t\t\t\t\t\t\tCharCode.CloseParen\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tparenBalance--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\twhile (\n\t\t\t\t\t\t\t\t!this._isAtEnd() &&\n\t\t\t\t\t\t\t\tfollowingToken.type !== TokenType.And &&\n\t\t\t\t\t\t\t\tfollowingToken.type !== TokenType.Or\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tswitch (followingToken.type) {\n\t\t\t\t\t\t\t\t\tcase TokenType.LParen:\n\t\t\t\t\t\t\t\t\t\tparenBalance++;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase TokenType.RParen:\n\t\t\t\t\t\t\t\t\t\tparenBalance--;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase TokenType.RegexStr:\n\t\t\t\t\t\t\t\t\tcase TokenType.QuotedStr:\n\t\t\t\t\t\t\t\t\t\tfor (\n\t\t\t\t\t\t\t\t\t\t\tlet i = 0;\n\t\t\t\t\t\t\t\t\t\t\ti < followingToken.lexeme.length;\n\t\t\t\t\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t\tfollowingToken.lexeme.charCodeAt(\n\t\t\t\t\t\t\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\t\t\t\t\t\t) === CharCode.OpenParen\n\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\tparenBalance++;\n\t\t\t\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\t\t\t\texpr.lexeme.charCodeAt(i) ===\n\t\t\t\t\t\t\t\t\t\t\t\tCharCode.CloseParen\n\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\tparenBalance--;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (parenBalance < 0) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlexemeReconstruction.push(\n\t\t\t\t\t\t\t\t\tScanner.getLexeme(followingToken),\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tthis._advance();\n\t\t\t\t\t\t\t\tfollowingToken = this._peek();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst regexLexeme = lexemeReconstruction.join(\"\");\n\t\t\t\t\t\t\tconst closingSlashIndex =\n\t\t\t\t\t\t\t\tregexLexeme.lastIndexOf(\"/\");\n\t\t\t\t\t\t\tconst flags =\n\t\t\t\t\t\t\t\tclosingSlashIndex === regexLexeme.length - 1\n\t\t\t\t\t\t\t\t\t? undefined\n\t\t\t\t\t\t\t\t\t: this._removeFlagsGY(\n\t\t\t\t\t\t\t\t\t\t\tregexLexeme.substring(\n\t\t\t\t\t\t\t\t\t\t\t\tclosingSlashIndex + 1,\n\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tlet regexp: RegExp | null;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tregexp = new RegExp(\n\t\t\t\t\t\t\t\t\tregexLexeme.substring(1, closingSlashIndex),\n\t\t\t\t\t\t\t\t\tflags,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\tthrow this._errExpectedButGot(`REGEX`, expr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn ContextKeyExpr.regex(key, regexp);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase TokenType.QuotedStr: {\n\t\t\t\t\t\t\tconst serializedValue = expr.lexeme;\n\t\t\t\t\t\t\tthis._advance();\n\t\t\t\t\t\t\t// replicate old regex parsing behavior\n\n\t\t\t\t\t\t\tlet regex: RegExp | null = null;\n\n\t\t\t\t\t\t\tif (!isFalsyOrWhitespace(serializedValue)) {\n\t\t\t\t\t\t\t\tconst start = serializedValue.indexOf(\"/\");\n\t\t\t\t\t\t\t\tconst end = serializedValue.lastIndexOf(\"/\");\n\t\t\t\t\t\t\t\tif (start !== end && start >= 0) {\n\t\t\t\t\t\t\t\t\tconst value = serializedValue.slice(\n\t\t\t\t\t\t\t\t\t\tstart + 1,\n\t\t\t\t\t\t\t\t\t\tend,\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tconst caseIgnoreFlag =\n\t\t\t\t\t\t\t\t\t\tserializedValue[end + 1] === \"i\"\n\t\t\t\t\t\t\t\t\t\t\t? \"i\"\n\t\t\t\t\t\t\t\t\t\t\t: \"\";\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tregex = new RegExp(\n\t\t\t\t\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\t\t\t\t\tcaseIgnoreFlag,\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t} catch (_e) {\n\t\t\t\t\t\t\t\t\t\tthrow this._errExpectedButGot(\n\t\t\t\t\t\t\t\t\t\t\t`REGEX`,\n\t\t\t\t\t\t\t\t\t\t\texpr,\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (regex === null) {\n\t\t\t\t\t\t\t\tthrow this._errExpectedButGot(\"REGEX\", expr);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn ContextKeyRegexExpr.create(key, regex);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow this._errExpectedButGot(\n\t\t\t\t\t\t\t\t\"REGEX\",\n\t\t\t\t\t\t\t\tthis._peek(),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// [ 'not' 'in' value ]\n\t\t\t\tif (this._matchOne(TokenType.Not)) {\n\t\t\t\t\tthis._consume(TokenType.In, errorNoInAfterNot);\n\t\t\t\t\tconst right = this._value();\n\t\t\t\t\treturn ContextKeyExpr.notIn(key, right);\n\t\t\t\t}\n\n\t\t\t\t// [ ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in') value ]\n\t\t\t\tconst maybeOp = this._peek().type;\n\t\t\t\tswitch (maybeOp) {\n\t\t\t\t\tcase TokenType.Eq: {\n\t\t\t\t\t\tthis._advance();\n\n\t\t\t\t\t\tconst right = this._value();\n\t\t\t\t\t\tif (this._previous().type === TokenType.QuotedStr) {\n\t\t\t\t\t\t\t// to preserve old parser behavior: \"foo == 'true'\" is preserved as \"foo == 'true'\", but \"foo == true\" is optimized as \"foo\"\n\t\t\t\t\t\t\treturn ContextKeyExpr.equals(key, right);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tswitch (right) {\n\t\t\t\t\t\t\tcase \"true\":\n\t\t\t\t\t\t\t\treturn ContextKeyExpr.has(key);\n\t\t\t\t\t\t\tcase \"false\":\n\t\t\t\t\t\t\t\treturn ContextKeyExpr.not(key);\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn ContextKeyExpr.equals(key, right);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcase TokenType.NotEq: {\n\t\t\t\t\t\tthis._advance();\n\n\t\t\t\t\t\tconst right = this._value();\n\t\t\t\t\t\tif (this._previous().type === TokenType.QuotedStr) {\n\t\t\t\t\t\t\t// same as above with \"foo != 'true'\"\n\t\t\t\t\t\t\treturn ContextKeyExpr.notEquals(key, right);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tswitch (right) {\n\t\t\t\t\t\t\tcase \"true\":\n\t\t\t\t\t\t\t\treturn ContextKeyExpr.not(key);\n\t\t\t\t\t\t\tcase \"false\":\n\t\t\t\t\t\t\t\treturn ContextKeyExpr.has(key);\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn ContextKeyExpr.notEquals(key, right);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// TODO: ContextKeyExpr.smaller(key, right) accepts only `number` as `right` AND during eval of this node, we just eval to `false` if `right` is not a number\n\t\t\t\t\t// consequently, package.json linter should _warn_ the user if they're passing undesired things to ops\n\t\t\t\t\tcase TokenType.Lt:\n\t\t\t\t\t\tthis._advance();\n\t\t\t\t\t\treturn ContextKeySmallerExpr.create(key, this._value());\n\n\t\t\t\t\tcase TokenType.LtEq:\n\t\t\t\t\t\tthis._advance();\n\t\t\t\t\t\treturn ContextKeySmallerEqualsExpr.create(\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tthis._value(),\n\t\t\t\t\t\t);\n\n\t\t\t\t\tcase TokenType.Gt:\n\t\t\t\t\t\tthis._advance();\n\t\t\t\t\t\treturn ContextKeyGreaterExpr.create(key, this._value());\n\n\t\t\t\t\tcase TokenType.GtEq:\n\t\t\t\t\t\tthis._advance();\n\t\t\t\t\t\treturn ContextKeyGreaterEqualsExpr.create(\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tthis._value(),\n\t\t\t\t\t\t);\n\n\t\t\t\t\tcase TokenType.In:\n\t\t\t\t\t\tthis._advance();\n\t\t\t\t\t\treturn ContextKeyExpr.in(key, this._value());\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn ContextKeyExpr.has(key);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcase TokenType.EOF:\n\t\t\t\tthis._parsingErrors.push({\n\t\t\t\t\tmessage: errorUnexpectedEOF,\n\t\t\t\t\toffset: peek.offset,\n\t\t\t\t\tlexeme: \"\",\n\t\t\t\t\tadditionalInfo: hintUnexpectedEOF,\n\t\t\t\t});\n\t\t\t\tthrow Parser._parseError;\n\n\t\t\tdefault:\n\t\t\t\tthrow this._errExpectedButGot(\n\t\t\t\t\t`true | false | KEY \\n\\t| KEY '=~' REGEX \\n\\t| KEY ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in') value`,\n\t\t\t\t\tthis._peek(),\n\t\t\t\t);\n\t\t}\n\t}\n\n\tprivate _value(): string {\n\t\tconst token = this._peek();\n\t\tswitch (token.type) {\n\t\t\tcase TokenType.Str:\n\t\t\tcase TokenType.QuotedStr:\n\t\t\t\tthis._advance();\n\t\t\t\treturn token.lexeme;\n\t\t\tcase TokenType.True:\n\t\t\t\tthis._advance();\n\t\t\t\treturn \"true\";\n\t\t\tcase TokenType.False:\n\t\t\t\tthis._advance();\n\t\t\t\treturn \"false\";\n\t\t\tcase TokenType.In: // we support `in` as a value, e.g., \"when\": \"languageId == in\" - exists in existing extensions\n\t\t\t\tthis._advance();\n\t\t\t\treturn \"in\";\n\t\t\tdefault:\n\t\t\t\t// this allows \"when\": \"foo == \" which's used by existing extensions\n\t\t\t\t// we do not call `_advance` on purpose - we don't want to eat unintended tokens\n\t\t\t\treturn \"\";\n\t\t}\n\t}\n\n\tprivate _flagsGYRe = /g|y/g;\n\tprivate _removeFlagsGY(flags: string): string {\n\t\treturn flags.replaceAll(this._flagsGYRe, \"\");\n\t}\n\n\t// careful: this can throw if current token is the initial one (ie index = 0)\n\tprivate _previous() {\n\t\treturn this._tokens[this._current - 1];\n\t}\n\n\tprivate _matchOne(token: TokenType) {\n\t\tif (this._check(token)) {\n\t\t\tthis._advance();\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate _advance() {\n\t\tif (!this._isAtEnd()) {\n\t\t\tthis._current++;\n\t\t}\n\t\treturn this._previous();\n\t}\n\n\tprivate _consume(type: TokenType, message: string) {\n\t\tif (this._check(type)) {\n\t\t\treturn this._advance();\n\t\t}\n\n\t\tthrow this._errExpectedButGot(message, this._peek());\n\t}\n\n\tprivate _errExpectedButGot(\n\t\texpected: string,\n\t\tgot: Token,\n\t\tadditionalInfo?: string,\n\t) {\n\t\tconst message = localize(\n\t\t\t\"contextkey.parser.error.expectedButGot\",\n\t\t\t\"Expected: {0}\\nReceived: '{1}'.\",\n\t\t\texpected,\n\t\t\tScanner.getLexeme(got),\n\t\t);\n\t\tconst offset = got.offset;\n\t\tconst lexeme = Scanner.getLexeme(got);\n\t\tthis._parsingErrors.push({ message, offset, lexeme, additionalInfo });\n\t\treturn Parser._parseError;\n\t}\n\n\tprivate _check(type: TokenType) {\n\t\treturn this._peek().type === type;\n\t}\n\n\tprivate _peek() {\n\t\treturn this._tokens[this._current];\n\t}\n\n\tprivate _isAtEnd() {\n\t\treturn this._peek().type === TokenType.EOF;\n\t}\n}\n\nexport abstract class ContextKeyExpr {\n\tpublic static false(): ContextKeyExpression {\n\t\treturn ContextKeyFalseExpr.INSTANCE;\n\t}\n\tpublic static true(): ContextKeyExpression {\n\t\treturn ContextKeyTrueExpr.INSTANCE;\n\t}\n\tpublic static has(key: string): ContextKeyExpression {\n\t\treturn ContextKeyDefinedExpr.create(key);\n\t}\n\tpublic static equals(key: string, value: any): ContextKeyExpression {\n\t\treturn ContextKeyEqualsExpr.create(key, value);\n\t}\n\tpublic static notEquals(key: string, value: any): ContextKeyExpression {\n\t\treturn ContextKeyNotEqualsExpr.create(key, value);\n\t}\n\tpublic static regex(key: string, value: RegExp): ContextKeyExpression {\n\t\treturn ContextKeyRegexExpr.create(key, value);\n\t}\n\tpublic static in(key: string, value: string): ContextKeyExpression {\n\t\treturn ContextKeyInExpr.create(key, value);\n\t}\n\tpublic static notIn(key: string, value: string): ContextKeyExpression {\n\t\treturn ContextKeyNotInExpr.create(key, value);\n\t}\n\tpublic static not(key: string): ContextKeyExpression {\n\t\treturn ContextKeyNotExpr.create(key);\n\t}\n\tpublic static and(\n\t\t...expr: Array<ContextKeyExpression | undefined | null>\n\t): ContextKeyExpression | undefined {\n\t\treturn ContextKeyAndExpr.create(expr, null, true);\n\t}\n\tpublic static or(\n\t\t...expr: Array<ContextKeyExpression | undefined | null>\n\t): ContextKeyExpression | undefined {\n\t\treturn ContextKeyOrExpr.create(expr, null, true);\n\t}\n\tpublic static greater(key: string, value: number): ContextKeyExpression {\n\t\treturn ContextKeyGreaterExpr.create(key, value);\n\t}\n\tpublic static greaterEquals(\n\t\tkey: string,\n\t\tvalue: number,\n\t): ContextKeyExpression {\n\t\treturn ContextKeyGreaterEqualsExpr.create(key, value);\n\t}\n\tpublic static smaller(key: string, value: number): ContextKeyExpression {\n\t\treturn ContextKeySmallerExpr.create(key, value);\n\t}\n\tpublic static smallerEquals(\n\t\tkey: string,\n\t\tvalue: number,\n\t): ContextKeyExpression {\n\t\treturn ContextKeySmallerEqualsExpr.create(key, value);\n\t}\n\n\tprivate static _parser = new Parser({\n\t\tregexParsingWithErrorRecovery: false,\n\t});\n\tpublic static deserialize(\n\t\tserialized: string | null | undefined,\n\t): ContextKeyExpression | undefined {\n\t\tif (serialized === undefined || serialized === null) {\n\t\t\t// an empty string needs to be handled by the parser to get a corresponding parsing error reported\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst expr = this._parser.parse(serialized);\n\t\treturn expr;\n\t}\n}\n\nexport function validateWhenClauses(whenClauses: string[]): any {\n\tconst parser = new Parser({ regexParsingWithErrorRecovery: false }); // we run with no recovery to guide users to use correct regexes\n\n\treturn whenClauses.map((whenClause) => {\n\t\tparser.parse(whenClause);\n\n\t\tif (parser.lexingErrors.length > 0) {\n\t\t\treturn parser.lexingErrors.map((se: LexingError) => ({\n\t\t\t\terrorMessage: se.additionalInfo\n\t\t\t\t\t? localize(\n\t\t\t\t\t\t\t\"contextkey.scanner.errorForLinterWithHint\",\n\t\t\t\t\t\t\t\"Unexpected token. Hint: {0}\",\n\t\t\t\t\t\t\tse.additionalInfo,\n\t\t\t\t\t\t)\n\t\t\t\t\t: localize(\n\t\t\t\t\t\t\t\"contextkey.scanner.errorForLinter\",\n\t\t\t\t\t\t\t\"Unexpected token.\",\n\t\t\t\t\t\t),\n\t\t\t\toffset: se.offset,\n\t\t\t\tlength: se.lexeme.length,\n\t\t\t}));\n\t\t} else if (parser.parsingErrors.length > 0) {\n\t\t\treturn parser.parsingErrors.map((pe: ParsingError) => ({\n\t\t\t\terrorMessage: pe.additionalInfo\n\t\t\t\t\t? `${pe.message}. ${pe.additionalInfo}`\n\t\t\t\t\t: pe.message,\n\t\t\t\toffset: pe.offset,\n\t\t\t\tlength: pe.lexeme.length,\n\t\t\t}));\n\t\t} else {\n\t\t\treturn [];\n\t\t}\n\t});\n}\n\nexport function expressionsAreEqualWithConstantSubstitution(\n\ta: ContextKeyExpression | null | undefined,\n\tb: ContextKeyExpression | null | undefined,\n): boolean {\n\tconst aExpr = a ? a.substituteConstants() : undefined;\n\tconst bExpr = b ? b.substituteConstants() : undefined;\n\tif (!aExpr && !bExpr) {\n\t\treturn true;\n\t}\n\tif (!aExpr || !bExpr) {\n\t\treturn false;\n\t}\n\treturn aExpr.equals(bExpr);\n}\n\nfunction cmp(a: ContextKeyExpression, b: ContextKeyExpression): number {\n\treturn a.cmp(b);\n}\n\nexport class ContextKeyFalseExpr implements IContextKeyExpression {\n\tpublic static INSTANCE = new ContextKeyFalseExpr();\n\n\tpublic readonly type = ContextKeyExprType.False;\n\n\tprotected constructor() {}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\treturn this.type - other.type;\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\treturn other.type === this.type;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\treturn false;\n\t}\n\n\tpublic serialize(): string {\n\t\treturn \"false\";\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn this;\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\treturn ContextKeyTrueExpr.INSTANCE;\n\t}\n}\n\nexport class ContextKeyTrueExpr implements IContextKeyExpression {\n\tpublic static INSTANCE = new ContextKeyTrueExpr();\n\n\tpublic readonly type = ContextKeyExprType.True;\n\n\tprotected constructor() {}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\treturn this.type - other.type;\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\treturn other.type === this.type;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\treturn true;\n\t}\n\n\tpublic serialize(): string {\n\t\treturn \"true\";\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn this;\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\treturn ContextKeyFalseExpr.INSTANCE;\n\t}\n}\n\nexport class ContextKeyDefinedExpr implements IContextKeyExpression {\n\tpublic static create(\n\t\tkey: string,\n\t\tnegated: ContextKeyExpression | null = null,\n\t): ContextKeyExpression {\n\t\tconst constantValue = CONSTANT_VALUES.get(key);\n\t\tif (typeof constantValue === \"boolean\") {\n\t\t\treturn constantValue\n\t\t\t\t? ContextKeyTrueExpr.INSTANCE\n\t\t\t\t: ContextKeyFalseExpr.INSTANCE;\n\t\t}\n\t\treturn new ContextKeyDefinedExpr(key, negated);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.Defined;\n\n\tprotected constructor(\n\t\treadonly key: string,\n\t\tprivate negated: ContextKeyExpression | null,\n\t) {}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp1(this.key, other.key);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn this.key === other.key;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\tconst constantValue = CONSTANT_VALUES.get(this.key);\n\t\tif (typeof constantValue === \"boolean\") {\n\t\t\treturn constantValue\n\t\t\t\t? ContextKeyTrueExpr.INSTANCE\n\t\t\t\t: ContextKeyFalseExpr.INSTANCE;\n\t\t}\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\treturn !!context.getValue(this.key);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn this.key;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapDefined(this.key);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyNotExpr.create(this.key, this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyEqualsExpr implements IContextKeyExpression {\n\tpublic static create(\n\t\tkey: string,\n\t\tvalue: any,\n\t\tnegated: ContextKeyExpression | null = null,\n\t): ContextKeyExpression {\n\t\tif (typeof value === \"boolean\") {\n\t\t\treturn value\n\t\t\t\t? ContextKeyDefinedExpr.create(key, negated)\n\t\t\t\t: ContextKeyNotExpr.create(key, negated);\n\t\t}\n\t\tconst constantValue = CONSTANT_VALUES.get(key);\n\t\tif (typeof constantValue === \"boolean\") {\n\t\t\tconst trueValue = constantValue ? \"true\" : \"false\";\n\t\t\treturn value === trueValue\n\t\t\t\t? ContextKeyTrueExpr.INSTANCE\n\t\t\t\t: ContextKeyFalseExpr.INSTANCE;\n\t\t}\n\t\treturn new ContextKeyEqualsExpr(key, value, negated);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.Equals;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly value: any,\n\t\tprivate negated: ContextKeyExpression | null,\n\t) {}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp2(this.key, this.value, other.key, other.value);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn this.key === other.key && this.value === other.value;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\tconst constantValue = CONSTANT_VALUES.get(this.key);\n\t\tif (typeof constantValue === \"boolean\") {\n\t\t\tconst trueValue = constantValue ? \"true\" : \"false\";\n\t\t\treturn this.value === trueValue\n\t\t\t\t? ContextKeyTrueExpr.INSTANCE\n\t\t\t\t: ContextKeyFalseExpr.INSTANCE;\n\t\t}\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\t// Intentional ==\n\t\t// eslint-disable-next-line eqeqeq\n\t\treturn context.getValue(this.key) == this.value;\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} == '${this.value}'`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapEquals(this.key, this.value);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyNotEqualsExpr.create(\n\t\t\t\tthis.key,\n\t\t\t\tthis.value,\n\t\t\t\tthis,\n\t\t\t);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyInExpr implements IContextKeyExpression {\n\tpublic static create(key: string, valueKey: string): ContextKeyInExpr {\n\t\treturn new ContextKeyInExpr(key, valueKey);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.In;\n\tprivate negated: ContextKeyExpression | null = null;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly valueKey: string,\n\t) {}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp2(this.key, this.valueKey, other.key, other.valueKey);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn this.key === other.key && this.valueKey === other.valueKey;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tconst source = context.getValue(this.valueKey);\n\n\t\tconst item = context.getValue(this.key);\n\n\t\tif (Array.isArray(source)) {\n\t\t\treturn source.includes(item as any);\n\t\t}\n\n\t\tif (\n\t\t\ttypeof item === \"string\" &&\n\t\t\ttypeof source === \"object\" &&\n\t\t\tsource !== null\n\t\t) {\n\t\t\treturn hasOwnProperty.call(source, item);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} in '${this.valueKey}'`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key, this.valueKey];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyInExpr {\n\t\treturn mapFnc.mapIn(this.key, this.valueKey);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyNotInExpr.create(this.key, this.valueKey);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyNotInExpr implements IContextKeyExpression {\n\tpublic static create(key: string, valueKey: string): ContextKeyNotInExpr {\n\t\treturn new ContextKeyNotInExpr(key, valueKey);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.NotIn;\n\n\tprivate readonly _negated: ContextKeyInExpr;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly valueKey: string,\n\t) {\n\t\tthis._negated = ContextKeyInExpr.create(key, valueKey);\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn this._negated.cmp(other._negated);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn this._negated.equals(other._negated);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\treturn !this._negated.evaluate(context);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} not in '${this.valueKey}'`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn this._negated.keys();\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapNotIn(this.key, this.valueKey);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\treturn this._negated;\n\t}\n}\n\nexport class ContextKeyNotEqualsExpr implements IContextKeyExpression {\n\tpublic static create(\n\t\tkey: string,\n\t\tvalue: any,\n\t\tnegated: ContextKeyExpression | null = null,\n\t): ContextKeyExpression {\n\t\tif (typeof value === \"boolean\") {\n\t\t\tif (value) {\n\t\t\t\treturn ContextKeyNotExpr.create(key, negated);\n\t\t\t}\n\t\t\treturn ContextKeyDefinedExpr.create(key, negated);\n\t\t}\n\t\tconst constantValue = CONSTANT_VALUES.get(key);\n\t\tif (typeof constantValue === \"boolean\") {\n\t\t\tconst falseValue = constantValue ? \"true\" : \"false\";\n\t\t\treturn value === falseValue\n\t\t\t\t? ContextKeyFalseExpr.INSTANCE\n\t\t\t\t: ContextKeyTrueExpr.INSTANCE;\n\t\t}\n\t\treturn new ContextKeyNotEqualsExpr(key, value, negated);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.NotEquals;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly value: any,\n\t\tprivate negated: ContextKeyExpression | null,\n\t) {}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp2(this.key, this.value, other.key, other.value);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn this.key === other.key && this.value === other.value;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\tconst constantValue = CONSTANT_VALUES.get(this.key);\n\t\tif (typeof constantValue === \"boolean\") {\n\t\t\tconst falseValue = constantValue ? \"true\" : \"false\";\n\t\t\treturn this.value === falseValue\n\t\t\t\t? ContextKeyFalseExpr.INSTANCE\n\t\t\t\t: ContextKeyTrueExpr.INSTANCE;\n\t\t}\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\t// Intentional !=\n\t\t// eslint-disable-next-line eqeqeq\n\t\treturn context.getValue(this.key) != this.value;\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} != '${this.value}'`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapNotEquals(this.key, this.value);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyEqualsExpr.create(\n\t\t\t\tthis.key,\n\t\t\t\tthis.value,\n\t\t\t\tthis,\n\t\t\t);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyNotExpr implements IContextKeyExpression {\n\tpublic static create(\n\t\tkey: string,\n\t\tnegated: ContextKeyExpression | null = null,\n\t): ContextKeyExpression {\n\t\tconst constantValue = CONSTANT_VALUES.get(key);\n\t\tif (typeof constantValue === \"boolean\") {\n\t\t\treturn constantValue\n\t\t\t\t? ContextKeyFalseExpr.INSTANCE\n\t\t\t\t: ContextKeyTrueExpr.INSTANCE;\n\t\t}\n\t\treturn new ContextKeyNotExpr(key, negated);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.Not;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate negated: ContextKeyExpression | null,\n\t) {}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp1(this.key, other.key);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn this.key === other.key;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\tconst constantValue = CONSTANT_VALUES.get(this.key);\n\t\tif (typeof constantValue === \"boolean\") {\n\t\t\treturn constantValue\n\t\t\t\t? ContextKeyFalseExpr.INSTANCE\n\t\t\t\t: ContextKeyTrueExpr.INSTANCE;\n\t\t}\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\treturn !context.getValue(this.key);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `!${this.key}`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapNot(this.key);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyDefinedExpr.create(this.key, this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nfunction withFloatOrStr<T extends ContextKeyExpression>(\n\tvalue: any,\n\tcallback: (value: number | string) => T,\n): T | ContextKeyFalseExpr {\n\tif (typeof value === \"string\") {\n\t\tconst n = Number.parseFloat(value);\n\t\tif (!isNaN(n)) {\n\t\t\tvalue = n;\n\t\t}\n\t}\n\tif (typeof value === \"string\" || typeof value === \"number\") {\n\t\treturn callback(value);\n\t}\n\treturn ContextKeyFalseExpr.INSTANCE;\n}\n\nexport class ContextKeyGreaterExpr implements IContextKeyExpression {\n\tpublic static create(\n\t\tkey: string,\n\t\t_value: any,\n\t\tnegated: ContextKeyExpression | null = null,\n\t): ContextKeyExpression {\n\t\treturn withFloatOrStr(\n\t\t\t_value,\n\t\t\t(value) => new ContextKeyGreaterExpr(key, value, negated),\n\t\t);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.Greater;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly value: number | string,\n\t\tprivate negated: ContextKeyExpression | null,\n\t) {}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp2(this.key, this.value, other.key, other.value);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn this.key === other.key && this.value === other.value;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tif (typeof this.value === \"string\") {\n\t\t\treturn false;\n\t\t}\n\t\treturn Number.parseFloat(<any>context.getValue(this.key)) > this.value;\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} > ${this.value}`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapGreater(this.key, this.value);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeySmallerEqualsExpr.create(\n\t\t\t\tthis.key,\n\t\t\t\tthis.value,\n\t\t\t\tthis,\n\t\t\t);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyGreaterEqualsExpr implements IContextKeyExpression {\n\tpublic static create(\n\t\tkey: string,\n\t\t_value: any,\n\t\tnegated: ContextKeyExpression | null = null,\n\t): ContextKeyExpression {\n\t\treturn withFloatOrStr(\n\t\t\t_value,\n\t\t\t(value) => new ContextKeyGreaterEqualsExpr(key, value, negated),\n\t\t);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.GreaterEquals;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly value: number | string,\n\t\tprivate negated: ContextKeyExpression | null,\n\t) {}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp2(this.key, this.value, other.key, other.value);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn this.key === other.key && this.value === other.value;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tif (typeof this.value === \"string\") {\n\t\t\treturn false;\n\t\t}\n\t\treturn Number.parseFloat(<any>context.getValue(this.key)) >= this.value;\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} >= ${this.value}`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapGreaterEquals(this.key, this.value);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeySmallerExpr.create(\n\t\t\t\tthis.key,\n\t\t\t\tthis.value,\n\t\t\t\tthis,\n\t\t\t);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeySmallerExpr implements IContextKeyExpression {\n\tpublic static create(\n\t\tkey: string,\n\t\t_value: any,\n\t\tnegated: ContextKeyExpression | null = null,\n\t): ContextKeyExpression {\n\t\treturn withFloatOrStr(\n\t\t\t_value,\n\t\t\t(value) => new ContextKeySmallerExpr(key, value, negated),\n\t\t);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.Smaller;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly value: number | string,\n\t\tprivate negated: ContextKeyExpression | null,\n\t) {}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp2(this.key, this.value, other.key, other.value);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn this.key === other.key && this.value === other.value;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tif (typeof this.value === \"string\") {\n\t\t\treturn false;\n\t\t}\n\t\treturn Number.parseFloat(<any>context.getValue(this.key)) < this.value;\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} < ${this.value}`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapSmaller(this.key, this.value);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyGreaterEqualsExpr.create(\n\t\t\t\tthis.key,\n\t\t\t\tthis.value,\n\t\t\t\tthis,\n\t\t\t);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeySmallerEqualsExpr implements IContextKeyExpression {\n\tpublic static create(\n\t\tkey: string,\n\t\t_value: any,\n\t\tnegated: ContextKeyExpression | null = null,\n\t): ContextKeyExpression {\n\t\treturn withFloatOrStr(\n\t\t\t_value,\n\t\t\t(value) => new ContextKeySmallerEqualsExpr(key, value, negated),\n\t\t);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.SmallerEquals;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly value: number | string,\n\t\tprivate negated: ContextKeyExpression | null,\n\t) {}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp2(this.key, this.value, other.key, other.value);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn this.key === other.key && this.value === other.value;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tif (typeof this.value === \"string\") {\n\t\t\treturn false;\n\t\t}\n\t\treturn Number.parseFloat(<any>context.getValue(this.key)) <= this.value;\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} <= ${this.value}`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapSmallerEquals(this.key, this.value);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyGreaterExpr.create(\n\t\t\t\tthis.key,\n\t\t\t\tthis.value,\n\t\t\t\tthis,\n\t\t\t);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyRegexExpr implements IContextKeyExpression {\n\tpublic static create(\n\t\tkey: string,\n\t\tregexp: RegExp | null,\n\t): ContextKeyRegexExpr {\n\t\treturn new ContextKeyRegexExpr(key, regexp);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.Regex;\n\tprivate negated: ContextKeyExpression | null = null;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly regexp: RegExp | null,\n\t) {\n\t\t//\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\tif (this.key < other.key) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (this.key > other.key) {\n\t\t\treturn 1;\n\t\t}\n\t\tconst thisSource = this.regexp ? this.regexp.source : \"\";\n\t\tconst otherSource = other.regexp ? other.regexp.source : \"\";\n\t\tif (thisSource < otherSource) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (thisSource > otherSource) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\tconst thisSource = this.regexp ? this.regexp.source : \"\";\n\t\t\tconst otherSource = other.regexp ? other.regexp.source : \"\";\n\t\t\treturn this.key === other.key && thisSource === otherSource;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tconst value = context.getValue<any>(this.key);\n\t\treturn this.regexp ? this.regexp.test(value) : false;\n\t}\n\n\tpublic serialize(): string {\n\t\tconst value = this.regexp\n\t\t\t? `/${this.regexp.source}/${this.regexp.flags}`\n\t\t\t: \"/invalid/\";\n\t\treturn `${this.key} =~ ${value}`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyRegexExpr {\n\t\treturn mapFnc.mapRegex(this.key, this.regexp);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyNotRegexExpr.create(this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyNotRegexExpr implements IContextKeyExpression {\n\tpublic static create(actual: ContextKeyRegexExpr): ContextKeyExpression {\n\t\treturn new ContextKeyNotRegexExpr(actual);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.NotRegex;\n\n\tprivate constructor(private readonly _actual: ContextKeyRegexExpr) {\n\t\t//\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn this._actual.cmp(other._actual);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn this._actual.equals(other._actual);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\treturn !this._actual.evaluate(context);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `!(${this._actual.serialize()})`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn this._actual.keys();\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn new ContextKeyNotRegexExpr(this._actual.map(mapFnc));\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\treturn this._actual;\n\t}\n}\n\n/**\n * @returns the same instance if nothing changed.\n */\nfunction eliminateConstantsInArray(\n\tarr: ContextKeyExpression[],\n): (ContextKeyExpression | undefined)[] {\n\t// Allocate array only if there is a difference\n\tlet newArr: (ContextKeyExpression | undefined)[] | null = null;\n\tfor (let i = 0, len = arr.length; i < len; i++) {\n\t\tconst newExpr = arr[i].substituteConstants();\n\n\t\tif (arr[i] !== newExpr) {\n\t\t\t// something has changed!\n\n\t\t\t// allocate array on first difference\n\t\t\tif (newArr === null) {\n\t\t\t\tnewArr = [];\n\t\t\t\tfor (let j = 0; j < i; j++) {\n\t\t\t\t\tnewArr[j] = arr[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (newArr !== null) {\n\t\t\tnewArr[i] = newExpr;\n\t\t}\n\t}\n\n\tif (newArr === null) {\n\t\treturn arr;\n\t}\n\treturn newArr;\n}\n\nexport class ContextKeyAndExpr implements IContextKeyExpression {\n\tpublic static create(\n\t\t_expr: ReadonlyArray<ContextKeyExpression | null | undefined>,\n\t\tnegated: ContextKeyExpression | null,\n\t\textraRedundantCheck: boolean,\n\t): ContextKeyExpression | undefined {\n\t\treturn ContextKeyAndExpr._normalizeArr(\n\t\t\t_expr,\n\t\t\tnegated,\n\t\t\textraRedundantCheck,\n\t\t);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.And;\n\n\tprivate constructor(\n\t\tpublic readonly expr: ContextKeyExpression[],\n\t\tprivate negated: ContextKeyExpression | null,\n\t) {}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\tif (this.expr.length < other.expr.length) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (this.expr.length > other.expr.length) {\n\t\t\treturn 1;\n\t\t}\n\t\tfor (let i = 0, len = this.expr.length; i < len; i++) {\n\t\t\tconst r = cmp(this.expr[i], other.expr[i]);\n\t\t\tif (r !== 0) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\tif (this.expr.length !== other.expr.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (let i = 0, len = this.expr.length; i < len; i++) {\n\t\t\t\tif (!this.expr[i].equals(other.expr[i])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\tconst exprArr = eliminateConstantsInArray(this.expr);\n\t\tif (exprArr === this.expr) {\n\t\t\t// no change\n\t\t\treturn this;\n\t\t}\n\t\treturn ContextKeyAndExpr.create(exprArr, this.negated, false);\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tfor (let i = 0, len = this.expr.length; i < len; i++) {\n\t\t\tif (!this.expr[i].evaluate(context)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate static _normalizeArr(\n\t\tarr: ReadonlyArray<ContextKeyExpression | null | undefined>,\n\t\tnegated: ContextKeyExpression | null,\n\t\textraRedundantCheck: boolean,\n\t): ContextKeyExpression | undefined {\n\t\tconst expr: ContextKeyExpression[] = [];\n\t\tlet hasTrue = false;\n\n\t\tfor (const e of arr) {\n\t\t\tif (!e) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (e.type === ContextKeyExprType.True) {\n\t\t\t\t// anything && true ==> anything\n\t\t\t\thasTrue = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (e.type === ContextKeyExprType.False) {\n\t\t\t\t// anything && false ==> false\n\t\t\t\treturn ContextKeyFalseExpr.INSTANCE;\n\t\t\t}\n\n\t\t\tif (e.type === ContextKeyExprType.And) {\n\t\t\t\texpr.push(...e.expr);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\texpr.push(e);\n\t\t}\n\n\t\tif (expr.length === 0 && hasTrue) {\n\t\t\treturn ContextKeyTrueExpr.INSTANCE;\n\t\t}\n\n\t\tif (expr.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (expr.length === 1) {\n\t\t\treturn expr[0];\n\t\t}\n\n\t\texpr.sort(cmp);\n\n\t\t// eliminate duplicate terms\n\t\tfor (let i = 1; i < expr.length; i++) {\n\t\t\tif (expr[i - 1].equals(expr[i])) {\n\t\t\t\texpr.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\n\t\tif (expr.length === 1) {\n\t\t\treturn expr[0];\n\t\t}\n\n\t\t// We must distribute any OR expression because we don't support parens\n\t\t// OR extensions will be at the end (due to sorting rules)\n\t\twhile (expr.length > 1) {\n\t\t\tconst lastElement = expr[expr.length - 1];\n\t\t\tif (lastElement.type !== ContextKeyExprType.Or) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// pop the last element\n\t\t\texpr.pop();\n\n\t\t\t// pop the second to last element\n\t\t\tconst secondToLastElement = expr.pop()!;\n\n\t\t\tconst isFinished = expr.length === 0;\n\n\t\t\t// distribute `lastElement` over `secondToLastElement`\n\t\t\tconst resultElement = ContextKeyOrExpr.create(\n\t\t\t\tlastElement.expr.map((el) =>\n\t\t\t\t\tContextKeyAndExpr.create(\n\t\t\t\t\t\t[el, secondToLastElement],\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\textraRedundantCheck,\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tnull,\n\t\t\t\tisFinished,\n\t\t\t);\n\n\t\t\tif (resultElement) {\n\t\t\t\texpr.push(resultElement);\n\t\t\t\texpr.sort(cmp);\n\t\t\t}\n\t\t}\n\n\t\tif (expr.length === 1) {\n\t\t\treturn expr[0];\n\t\t}\n\n\t\t// resolve false AND expressions\n\t\tif (extraRedundantCheck) {\n\t\t\tfor (let i = 0; i < expr.length; i++) {\n\t\t\t\tfor (let j = i + 1; j < expr.length; j++) {\n\t\t\t\t\tif (expr[i].negate().equals(expr[j])) {\n\t\t\t\t\t\t// A && !A case\n\t\t\t\t\t\treturn ContextKeyFalseExpr.INSTANCE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (expr.length === 1) {\n\t\t\t\treturn expr[0];\n\t\t\t}\n\t\t}\n\n\t\treturn new ContextKeyAndExpr(expr, negated);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn this.expr.map((e) => e.serialize()).join(\" && \");\n\t}\n\n\tpublic keys(): string[] {\n\t\tconst result: string[] = [];\n\t\tfor (const expr of this.expr) {\n\t\t\tresult.push(...expr.keys());\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn new ContextKeyAndExpr(\n\t\t\tthis.expr.map((expr) => expr.map(mapFnc)),\n\t\t\tnull,\n\t\t);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tconst result: ContextKeyExpression[] = [];\n\t\t\tfor (const expr of this.expr) {\n\t\t\t\tresult.push(expr.negate());\n\t\t\t}\n\t\t\tthis.negated = ContextKeyOrExpr.create(result, this, true)!;\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyOrExpr implements IContextKeyExpression {\n\tpublic static create(\n\t\t_expr: ReadonlyArray<ContextKeyExpression | null | undefined>,\n\t\tnegated: ContextKeyExpression | null,\n\t\textraRedundantCheck: boolean,\n\t): ContextKeyExpression | undefined {\n\t\treturn ContextKeyOrExpr._normalizeArr(\n\t\t\t_expr,\n\t\t\tnegated,\n\t\t\textraRedundantCheck,\n\t\t);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.Or;\n\n\tprivate constructor(\n\t\tpublic readonly expr: ContextKeyExpression[],\n\t\tprivate negated: ContextKeyExpression | null,\n\t) {}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\tif (this.expr.length < other.expr.length) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (this.expr.length > other.expr.length) {\n\t\t\treturn 1;\n\t\t}\n\t\tfor (let i = 0, len = this.expr.length; i < len; i++) {\n\t\t\tconst r = cmp(this.expr[i], other.expr[i]);\n\t\t\tif (r !== 0) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\tif (this.expr.length !== other.expr.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (let i = 0, len = this.expr.length; i < len; i++) {\n\t\t\t\tif (!this.expr[i].equals(other.expr[i])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\tconst exprArr = eliminateConstantsInArray(this.expr);\n\t\tif (exprArr === this.expr) {\n\t\t\t// no change\n\t\t\treturn this;\n\t\t}\n\t\treturn ContextKeyOrExpr.create(exprArr, this.negated, false);\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tfor (let i = 0, len = this.expr.length; i < len; i++) {\n\t\t\tif (this.expr[i].evaluate(context)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate static _normalizeArr(\n\t\tarr: ReadonlyArray<ContextKeyExpression | null | undefined>,\n\t\tnegated: ContextKeyExpression | null,\n\t\textraRedundantCheck: boolean,\n\t): ContextKeyExpression | undefined {\n\t\tlet expr: ContextKeyExpression[] = [];\n\t\tlet hasFalse = false;\n\n\t\tif (arr) {\n\t\t\tfor (let i = 0, len = arr.length; i < len; i++) {\n\t\t\t\tconst e = arr[i];\n\t\t\t\tif (!e) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (e.type === ContextKeyExprType.False) {\n\t\t\t\t\t// anything || false ==> anything\n\t\t\t\t\thasFalse = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (e.type === ContextKeyExprType.True) {\n\t\t\t\t\t// anything || true ==> true\n\t\t\t\t\treturn ContextKeyTrueExpr.INSTANCE;\n\t\t\t\t}\n\n\t\t\t\tif (e.type === ContextKeyExprType.Or) {\n\t\t\t\t\texpr = expr.concat(e.expr);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\texpr.push(e);\n\t\t\t}\n\n\t\t\tif (expr.length === 0 && hasFalse) {\n\t\t\t\treturn ContextKeyFalseExpr.INSTANCE;\n\t\t\t}\n\n\t\t\texpr.sort(cmp);\n\t\t}\n\n\t\tif (expr.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (expr.length === 1) {\n\t\t\treturn expr[0];\n\t\t}\n\n\t\t// eliminate duplicate terms\n\t\tfor (let i = 1; i < expr.length; i++) {\n\t\t\tif (expr[i - 1].equals(expr[i])) {\n\t\t\t\texpr.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\n\t\tif (expr.length === 1) {\n\t\t\treturn expr[0];\n\t\t}\n\n\t\t// resolve true OR expressions\n\t\tif (extraRedundantCheck) {\n\t\t\tfor (let i = 0; i < expr.length; i++) {\n\t\t\t\tfor (let j = i + 1; j < expr.length; j++) {\n\t\t\t\t\tif (expr[i].negate().equals(expr[j])) {\n\t\t\t\t\t\t// A || !A case\n\t\t\t\t\t\treturn ContextKeyTrueExpr.INSTANCE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (expr.length === 1) {\n\t\t\t\treturn expr[0];\n\t\t\t}\n\t\t}\n\n\t\treturn new ContextKeyOrExpr(expr, negated);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn this.expr.map((e) => e.serialize()).join(\" || \");\n\t}\n\n\tpublic keys(): string[] {\n\t\tconst result: string[] = [];\n\t\tfor (const expr of this.expr) {\n\t\t\tresult.push(...expr.keys());\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn new ContextKeyOrExpr(\n\t\t\tthis.expr.map((expr) => expr.map(mapFnc)),\n\t\t\tnull,\n\t\t);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tconst result: ContextKeyExpression[] = [];\n\t\t\tfor (const expr of this.expr) {\n\t\t\t\tresult.push(expr.negate());\n\t\t\t}\n\n\t\t\t// We don't support parens, so here we distribute the AND over the OR terminals\n\t\t\t// We always take the first 2 AND pairs and distribute them\n\t\t\twhile (result.length > 1) {\n\t\t\t\tconst LEFT = result.shift()!;\n\t\t\t\tconst RIGHT = result.shift()!;\n\n\t\t\t\tconst all: ContextKeyExpression[] = [];\n\t\t\t\tfor (const left of getTerminals(LEFT)) {\n\t\t\t\t\tfor (const right of getTerminals(RIGHT)) {\n\t\t\t\t\t\tall.push(\n\t\t\t\t\t\t\tContextKeyAndExpr.create(\n\t\t\t\t\t\t\t\t[left, right],\n\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t)!,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tresult.unshift(ContextKeyOrExpr.create(all, null, false)!);\n\t\t\t}\n\n\t\t\tthis.negated = ContextKeyOrExpr.create(result, this, true)!;\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport interface ContextKeyInfo {\n\treadonly key: string;\n\treadonly type?: string;\n\treadonly description?: string;\n}\n\nexport class RawContextKey<\n\tT extends ContextKeyValue,\n> extends ContextKeyDefinedExpr {\n\tprivate static _info: ContextKeyInfo[] = [];\n\n\tstatic all(): IterableIterator<ContextKeyInfo> {\n\t\treturn RawContextKey._info.values();\n\t}\n\n\tprivate readonly _defaultValue: T | undefined;\n\n\tconstructor(\n\t\tkey: string,\n\t\tdefaultValue: T | undefined,\n\t\tmetaOrHide?: string | true | { type: string; description: string },\n\t) {\n\t\tsuper(key, null);\n\t\tthis._defaultValue = defaultValue;\n\n\t\t// collect all context keys into a central place\n\t\tif (typeof metaOrHide === \"object\") {\n\t\t\tRawContextKey._info.push({ ...metaOrHide, key });\n\t\t} else if (metaOrHide !== true) {\n\t\t\tRawContextKey._info.push({\n\t\t\t\tkey,\n\t\t\t\tdescription: metaOrHide,\n\t\t\t\ttype:\n\t\t\t\t\tdefaultValue !== null && defaultValue !== undefined\n\t\t\t\t\t\t? typeof defaultValue\n\t\t\t\t\t\t: undefined,\n\t\t\t});\n\t\t}\n\t}\n\n\tpublic bindTo(target: IContextKeyService): IContextKey<T> {\n\t\treturn target.createKey(this.key, this._defaultValue);\n\t}\n\n\tpublic getValue(target: IContextKeyService): T | undefined {\n\t\treturn target.getContextKeyValue<T>(this.key);\n\t}\n\n\tpublic toNegated(): ContextKeyExpression {\n\t\treturn this.negate();\n\t}\n\n\tpublic isEqualTo(value: any): ContextKeyExpression {\n\t\treturn ContextKeyEqualsExpr.create(this.key, value);\n\t}\n\n\tpublic notEqualsTo(value: any): ContextKeyExpression {\n\t\treturn ContextKeyNotEqualsExpr.create(this.key, value);\n\t}\n}\n\nexport type ContextKeyValue =\n\t| null\n\t| undefined\n\t| boolean\n\t| number\n\t| string\n\t| Array<null | undefined | boolean | number | string>\n\t| Record<string, null | undefined | boolean | number | string>;\n\nexport interface IContext {\n\tgetValue<T extends ContextKeyValue = ContextKeyValue>(\n\t\tkey: string,\n\t): T | undefined;\n}\n\nexport interface IContextKey<T extends ContextKeyValue = ContextKeyValue> {\n\tset(value: T): void;\n\treset(): void;\n\tget(): T | undefined;\n}\n\nexport interface IContextKeyServiceTarget {\n\tparentElement: IContextKeyServiceTarget | null;\n\tsetAttribute(attr: string, value: string): void;\n\tremoveAttribute(attr: string): void;\n\thasAttribute(attr: string): boolean;\n\tgetAttribute(attr: string): string | null;\n}\n\nexport const IContextKeyService =\n\tcreateDecorator<IContextKeyService>(\"contextKeyService\");\n\nexport interface IReadableSet<T> {\n\thas(value: T): boolean;\n}\n\nexport interface IContextKeyChangeEvent {\n\taffectsSome(keys: IReadableSet<string>): boolean;\n\tallKeysContainedIn(keys: IReadableSet<string>): boolean;\n}\n\nexport type IScopedContextKeyService = IContextKeyService & IDisposable;\n\nexport interface IContextKeyService {\n\treadonly _serviceBrand: undefined;\n\n\tonDidChangeContext: Event<IContextKeyChangeEvent>;\n\tbufferChangeEvents(callback: Function): void;\n\n\tcreateKey<T extends ContextKeyValue>(\n\t\tkey: string,\n\t\tdefaultValue: T | undefined,\n\t): IContextKey<T>;\n\tcontextMatchesRules(rules: ContextKeyExpression | undefined): boolean;\n\tgetContextKeyValue<T>(key: string): T | undefined;\n\n\tcreateScoped(target: IContextKeyServiceTarget): IScopedContextKeyService;\n\tcreateOverlay(overlay: Iterable<[string, any]>): IContextKeyService;\n\tgetContext(target: IContextKeyServiceTarget | null): IContext;\n\n\tupdateParent(parentContextKeyService: IContextKeyService): void;\n}\n\nfunction cmp1(key1: string, key2: string): number {\n\tif (key1 < key2) {\n\t\treturn -1;\n\t}\n\tif (key1 > key2) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nfunction cmp2(key1: string, value1: any, key2: string, value2: any): number {\n\tif (key1 < key2) {\n\t\treturn -1;\n\t}\n\tif (key1 > key2) {\n\t\treturn 1;\n\t}\n\tif (value1 < value2) {\n\t\treturn -1;\n\t}\n\tif (value1 > value2) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/**\n * Returns true if it is provable `p` implies `q`.\n */\nexport function implies(\n\tp: ContextKeyExpression,\n\tq: ContextKeyExpression,\n): boolean {\n\tif (\n\t\tp.type === ContextKeyExprType.False ||\n\t\tq.type === ContextKeyExprType.True\n\t) {\n\t\t// false implies anything\n\t\t// anything implies true\n\t\treturn true;\n\t}\n\n\tif (p.type === ContextKeyExprType.Or) {\n\t\tif (q.type === ContextKeyExprType.Or) {\n\t\t\t// `a || b || c` can only imply something like `a || b || c || d`\n\t\t\treturn allElementsIncluded(p.expr, q.expr);\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (q.type === ContextKeyExprType.Or) {\n\t\tfor (const element of q.expr) {\n\t\t\tif (implies(p, element)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (p.type === ContextKeyExprType.And) {\n\t\tif (q.type === ContextKeyExprType.And) {\n\t\t\t// `a && b && c` implies `a && c`\n\t\t\treturn allElementsIncluded(q.expr, p.expr);\n\t\t}\n\t\tfor (const element of p.expr) {\n\t\t\tif (implies(element, q)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn p.equals(q);\n}\n\n/**\n * Returns true if all elements in `p` are also present in `q`.\n * The two arrays are assumed to be sorted\n */\nfunction allElementsIncluded(\n\tp: ContextKeyExpression[],\n\tq: ContextKeyExpression[],\n): boolean {\n\tlet pIndex = 0;\n\tlet qIndex = 0;\n\twhile (pIndex < p.length && qIndex < q.length) {\n\t\tconst cmp = p[pIndex].cmp(q[qIndex]);\n\n\t\tif (cmp < 0) {\n\t\t\t// an element from `p` is missing from `q`\n\t\t\treturn false;\n\t\t} else if (cmp === 0) {\n\t\t\tpIndex++;\n\t\t\tqIndex++;\n\t\t} else {\n\t\t\tqIndex++;\n\t\t}\n\t}\n\treturn pIndex === p.length;\n}\n\nfunction getTerminals(node: ContextKeyExpression) {\n\tif (node.type === ContextKeyExprType.Or) {\n\t\treturn node.expr;\n\t}\n\treturn [node];\n}\n"],
  "mappings": "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",
  "names": ["ContextKeyExprType", "cmp"]
}
