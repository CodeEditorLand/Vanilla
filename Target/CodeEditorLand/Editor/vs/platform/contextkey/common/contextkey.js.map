{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/contextkey/common/contextkey.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport { Event } from '../../../base/common/event.js';\nimport { isChrome, isEdge, isFirefox, isLinux, isMacintosh, isSafari, isWeb, isWindows } from '../../../base/common/platform.js';\nimport { isFalsyOrWhitespace } from '../../../base/common/strings.js';\nimport { Scanner, LexingError, Token, TokenType } from './scanner.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { localize } from '../../../nls.js';\nimport { IDisposable } from '../../../base/common/lifecycle.js';\nimport { illegalArgument } from '../../../base/common/errors.js';\n\nconst CONSTANT_VALUES = new Map<string, boolean>();\nCONSTANT_VALUES.set('false', false);\nCONSTANT_VALUES.set('true', true);\nCONSTANT_VALUES.set('isMac', isMacintosh);\nCONSTANT_VALUES.set('isLinux', isLinux);\nCONSTANT_VALUES.set('isWindows', isWindows);\nCONSTANT_VALUES.set('isWeb', isWeb);\nCONSTANT_VALUES.set('isMacNative', isMacintosh && !isWeb);\nCONSTANT_VALUES.set('isEdge', isEdge);\nCONSTANT_VALUES.set('isFirefox', isFirefox);\nCONSTANT_VALUES.set('isChrome', isChrome);\nCONSTANT_VALUES.set('isSafari', isSafari);\n\n/** allow register constant context keys that are known only after startup; requires running `substituteConstants` on the context key - https://github.com/microsoft/vscode/issues/174218#issuecomment-1437972127 */\nexport function setConstant(key: string, value: boolean) {\n\tif (CONSTANT_VALUES.get(key) !== undefined) { throw illegalArgument('contextkey.setConstant(k, v) invoked with already set constant `k`'); }\n\n\tCONSTANT_VALUES.set(key, value);\n}\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nexport const enum ContextKeyExprType {\n\tFalse = 0,\n\tTrue = 1,\n\tDefined = 2,\n\tNot = 3,\n\tEquals = 4,\n\tNotEquals = 5,\n\tAnd = 6,\n\tRegex = 7,\n\tNotRegex = 8,\n\tOr = 9,\n\tIn = 10,\n\tNotIn = 11,\n\tGreater = 12,\n\tGreaterEquals = 13,\n\tSmaller = 14,\n\tSmallerEquals = 15,\n}\n\nexport interface IContextKeyExprMapper {\n\tmapDefined(key: string): ContextKeyExpression;\n\tmapNot(key: string): ContextKeyExpression;\n\tmapEquals(key: string, value: any): ContextKeyExpression;\n\tmapNotEquals(key: string, value: any): ContextKeyExpression;\n\tmapGreater(key: string, value: any): ContextKeyExpression;\n\tmapGreaterEquals(key: string, value: any): ContextKeyExpression;\n\tmapSmaller(key: string, value: any): ContextKeyExpression;\n\tmapSmallerEquals(key: string, value: any): ContextKeyExpression;\n\tmapRegex(key: string, regexp: RegExp | null): ContextKeyRegexExpr;\n\tmapIn(key: string, valueKey: string): ContextKeyInExpr;\n\tmapNotIn(key: string, valueKey: string): ContextKeyNotInExpr;\n}\n\nexport interface IContextKeyExpression {\n\tcmp(other: ContextKeyExpression): number;\n\tequals(other: ContextKeyExpression): boolean;\n\tsubstituteConstants(): ContextKeyExpression | undefined;\n\tevaluate(context: IContext): boolean;\n\tserialize(): string;\n\tkeys(): string[];\n\tmap(mapFnc: IContextKeyExprMapper): ContextKeyExpression;\n\tnegate(): ContextKeyExpression;\n\n}\n\nexport type ContextKeyExpression = (\n\tContextKeyFalseExpr | ContextKeyTrueExpr | ContextKeyDefinedExpr | ContextKeyNotExpr\n\t| ContextKeyEqualsExpr | ContextKeyNotEqualsExpr | ContextKeyRegexExpr\n\t| ContextKeyNotRegexExpr | ContextKeyAndExpr | ContextKeyOrExpr | ContextKeyInExpr\n\t| ContextKeyNotInExpr | ContextKeyGreaterExpr | ContextKeyGreaterEqualsExpr\n\t| ContextKeySmallerExpr | ContextKeySmallerEqualsExpr\n);\n\n\n/*\n\nSyntax grammar:\n\n```ebnf\n\nexpression ::= or\n\nor ::= and { '||' and }*\n\nand ::= term { '&&' term }*\n\nterm ::=\n\t| '!' (KEY | true | false | parenthesized)\n\t| primary\n\nprimary ::=\n\t| 'true'\n\t| 'false'\n\t| parenthesized\n\t| KEY '=~' REGEX\n\t| KEY [ ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'not' 'in' | 'in') value ]\n\nparenthesized ::=\n\t| '(' expression ')'\n\nvalue ::=\n\t| 'true'\n\t| 'false'\n\t| 'in'      \t// we support `in` as a value because there's an extension that uses it, ie \"when\": \"languageId == in\"\n\t| VALUE \t\t// matched by the same regex as KEY; consider putting the value in single quotes if it's a string (e.g., with spaces)\n\t| SINGLE_QUOTED_STR\n\t| EMPTY_STR  \t// this allows \"when\": \"foo == \" which's used by existing extensions\n\n```\n*/\n\nexport type ParserConfig = {\n\t/**\n\t * with this option enabled, the parser can recover from regex parsing errors, e.g., unescaped slashes: `/src//` is accepted as `/src\\//` would be\n\t */\n\tregexParsingWithErrorRecovery: boolean;\n};\n\nconst defaultConfig: ParserConfig = {\n\tregexParsingWithErrorRecovery: true\n};\n\nexport type ParsingError = {\n\tmessage: string;\n\toffset: number;\n\tlexeme: string;\n\tadditionalInfo?: string;\n};\n\nconst errorEmptyString = localize('contextkey.parser.error.emptyString', \"Empty context key expression\");\nconst hintEmptyString = localize('contextkey.parser.error.emptyString.hint', \"Did you forget to write an expression? You can also put 'false' or 'true' to always evaluate to false or true, respectively.\");\nconst errorNoInAfterNot = localize('contextkey.parser.error.noInAfterNot', \"'in' after 'not'.\");\nconst errorClosingParenthesis = localize('contextkey.parser.error.closingParenthesis', \"closing parenthesis ')'\");\nconst errorUnexpectedToken = localize('contextkey.parser.error.unexpectedToken', \"Unexpected token\");\nconst hintUnexpectedToken = localize('contextkey.parser.error.unexpectedToken.hint', \"Did you forget to put && or || before the token?\");\nconst errorUnexpectedEOF = localize('contextkey.parser.error.unexpectedEOF', \"Unexpected end of expression\");\nconst hintUnexpectedEOF = localize('contextkey.parser.error.unexpectedEOF.hint', \"Did you forget to put a context key?\");\n\n/**\n * A parser for context key expressions.\n *\n * Example:\n * ```ts\n * const parser = new Parser();\n * const expr = parser.parse('foo == \"bar\" && baz == true');\n *\n * if (expr === undefined) {\n * \t// there were lexing or parsing errors\n * \t// process lexing errors with `parser.lexingErrors`\n *  // process parsing errors with `parser.parsingErrors`\n * } else {\n * \t// expr is a valid expression\n * }\n * ```\n */\nexport class Parser {\n\t// Note: this doesn't produce an exact syntax tree but a normalized one\n\t// ContextKeyExpression's that we use as AST nodes do not expose constructors that do not normalize\n\n\tprivate static _parseError = new Error();\n\n\t// lifetime note: `_scanner` lives as long as the parser does, i.e., is not reset between calls to `parse`\n\tprivate readonly _scanner = new Scanner();\n\n\t// lifetime note: `_tokens`, `_current`, and `_parsingErrors` must be reset between calls to `parse`\n\tprivate _tokens: Token[] = [];\n\tprivate _current = 0; \t\t\t\t\t// invariant: 0 <= this._current < this._tokens.length ; any incrementation of this value must first call `_isAtEnd`\n\tprivate _parsingErrors: ParsingError[] = [];\n\n\tget lexingErrors(): Readonly<LexingError[]> {\n\t\treturn this._scanner.errors;\n\t}\n\n\tget parsingErrors(): Readonly<ParsingError[]> {\n\t\treturn this._parsingErrors;\n\t}\n\n\tconstructor(private readonly _config: ParserConfig = defaultConfig) {\n\t}\n\n\t/**\n\t * Parse a context key expression.\n\t *\n\t * @param input the expression to parse\n\t * @returns the parsed expression or `undefined` if there's an error - call `lexingErrors` and `parsingErrors` to see the errors\n\t */\n\tparse(input: string): ContextKeyExpression | undefined {\n\n\t\tif (input === '') {\n\t\t\tthis._parsingErrors.push({ message: errorEmptyString, offset: 0, lexeme: '', additionalInfo: hintEmptyString });\n\t\t\treturn undefined;\n\t\t}\n\n\t\tthis._tokens = this._scanner.reset(input).scan();\n\t\t// @ulugbekna: we do not stop parsing if there are lexing errors to be able to reconstruct regexes with unescaped slashes; TODO@ulugbekna: make this respect config option for recovery\n\n\t\tthis._current = 0;\n\t\tthis._parsingErrors = [];\n\n\t\ttry {\n\t\t\tconst expr = this._expr();\n\t\t\tif (!this._isAtEnd()) {\n\t\t\t\tconst peek = this._peek();\n\t\t\t\tconst additionalInfo = peek.type === TokenType.Str ? hintUnexpectedToken : undefined;\n\t\t\t\tthis._parsingErrors.push({ message: errorUnexpectedToken, offset: peek.offset, lexeme: Scanner.getLexeme(peek), additionalInfo });\n\t\t\t\tthrow Parser._parseError;\n\t\t\t}\n\t\t\treturn expr;\n\t\t} catch (e) {\n\t\t\tif (!(e === Parser._parseError)) {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tprivate _expr(): ContextKeyExpression | undefined {\n\t\treturn this._or();\n\t}\n\n\tprivate _or(): ContextKeyExpression | undefined {\n\t\tconst expr = [this._and()];\n\n\t\twhile (this._matchOne(TokenType.Or)) {\n\t\t\tconst right = this._and();\n\t\t\texpr.push(right);\n\t\t}\n\n\t\treturn expr.length === 1 ? expr[0] : ContextKeyExpr.or(...expr);\n\t}\n\n\tprivate _and(): ContextKeyExpression | undefined {\n\t\tconst expr = [this._term()];\n\n\t\twhile (this._matchOne(TokenType.And)) {\n\t\t\tconst right = this._term();\n\t\t\texpr.push(right);\n\t\t}\n\n\t\treturn expr.length === 1 ? expr[0] : ContextKeyExpr.and(...expr);\n\t}\n\n\tprivate _term(): ContextKeyExpression | undefined {\n\t\tif (this._matchOne(TokenType.Neg)) {\n\t\t\tconst peek = this._peek();\n\t\t\tswitch (peek.type) {\n\t\t\t\tcase TokenType.True:\n\t\t\t\t\tthis._advance();\n\t\t\t\t\treturn ContextKeyFalseExpr.INSTANCE;\n\t\t\t\tcase TokenType.False:\n\t\t\t\t\tthis._advance();\n\t\t\t\t\treturn ContextKeyTrueExpr.INSTANCE;\n\t\t\t\tcase TokenType.LParen: {\n\t\t\t\t\tthis._advance();\n\t\t\t\t\tconst expr = this._expr();\n\t\t\t\t\tthis._consume(TokenType.RParen, errorClosingParenthesis);\n\t\t\t\t\treturn expr?.negate();\n\t\t\t\t}\n\t\t\t\tcase TokenType.Str:\n\t\t\t\t\tthis._advance();\n\t\t\t\t\treturn ContextKeyNotExpr.create(peek.lexeme);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow this._errExpectedButGot(`KEY | true | false | '(' expression ')'`, peek);\n\t\t\t}\n\t\t}\n\t\treturn this._primary();\n\t}\n\n\tprivate _primary(): ContextKeyExpression | undefined {\n\n\t\tconst peek = this._peek();\n\t\tswitch (peek.type) {\n\t\t\tcase TokenType.True:\n\t\t\t\tthis._advance();\n\t\t\t\treturn ContextKeyExpr.true();\n\n\t\t\tcase TokenType.False:\n\t\t\t\tthis._advance();\n\t\t\t\treturn ContextKeyExpr.false();\n\n\t\t\tcase TokenType.LParen: {\n\t\t\t\tthis._advance();\n\t\t\t\tconst expr = this._expr();\n\t\t\t\tthis._consume(TokenType.RParen, errorClosingParenthesis);\n\t\t\t\treturn expr;\n\t\t\t}\n\n\t\t\tcase TokenType.Str: {\n\t\t\t\t// KEY\n\t\t\t\tconst key = peek.lexeme;\n\t\t\t\tthis._advance();\n\n\t\t\t\t// =~ regex\n\t\t\t\tif (this._matchOne(TokenType.RegexOp)) {\n\n\t\t\t\t\t// @ulugbekna: we need to reconstruct the regex from the tokens because some extensions use unescaped slashes in regexes\n\t\t\t\t\tconst expr = this._peek();\n\n\t\t\t\t\tif (!this._config.regexParsingWithErrorRecovery) {\n\t\t\t\t\t\tthis._advance();\n\t\t\t\t\t\tif (expr.type !== TokenType.RegexStr) {\n\t\t\t\t\t\t\tthrow this._errExpectedButGot(`REGEX`, expr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst regexLexeme = expr.lexeme;\n\t\t\t\t\t\tconst closingSlashIndex = regexLexeme.lastIndexOf('/');\n\t\t\t\t\t\tconst flags = closingSlashIndex === regexLexeme.length - 1 ? undefined : this._removeFlagsGY(regexLexeme.substring(closingSlashIndex + 1));\n\t\t\t\t\t\tlet regexp: RegExp | null;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tregexp = new RegExp(regexLexeme.substring(1, closingSlashIndex), flags);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tthrow this._errExpectedButGot(`REGEX`, expr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn ContextKeyRegexExpr.create(key, regexp);\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch (expr.type) {\n\t\t\t\t\t\tcase TokenType.RegexStr:\n\t\t\t\t\t\tcase TokenType.Error: { // also handle an ErrorToken in case of smth such as /(/file)/\n\t\t\t\t\t\t\tconst lexemeReconstruction = [expr.lexeme]; // /REGEX/ or /REGEX/FLAGS\n\t\t\t\t\t\t\tthis._advance();\n\n\t\t\t\t\t\t\tlet followingToken = this._peek();\n\t\t\t\t\t\t\tlet parenBalance = 0;\n\t\t\t\t\t\t\tfor (let i = 0; i < expr.lexeme.length; i++) {\n\t\t\t\t\t\t\t\tif (expr.lexeme.charCodeAt(i) === CharCode.OpenParen) {\n\t\t\t\t\t\t\t\t\tparenBalance++;\n\t\t\t\t\t\t\t\t} else if (expr.lexeme.charCodeAt(i) === CharCode.CloseParen) {\n\t\t\t\t\t\t\t\t\tparenBalance--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\twhile (!this._isAtEnd() && followingToken.type !== TokenType.And && followingToken.type !== TokenType.Or) {\n\t\t\t\t\t\t\t\tswitch (followingToken.type) {\n\t\t\t\t\t\t\t\t\tcase TokenType.LParen:\n\t\t\t\t\t\t\t\t\t\tparenBalance++;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase TokenType.RParen:\n\t\t\t\t\t\t\t\t\t\tparenBalance--;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase TokenType.RegexStr:\n\t\t\t\t\t\t\t\t\tcase TokenType.QuotedStr:\n\t\t\t\t\t\t\t\t\t\tfor (let i = 0; i < followingToken.lexeme.length; i++) {\n\t\t\t\t\t\t\t\t\t\t\tif (followingToken.lexeme.charCodeAt(i) === CharCode.OpenParen) {\n\t\t\t\t\t\t\t\t\t\t\t\tparenBalance++;\n\t\t\t\t\t\t\t\t\t\t\t} else if (expr.lexeme.charCodeAt(i) === CharCode.CloseParen) {\n\t\t\t\t\t\t\t\t\t\t\t\tparenBalance--;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (parenBalance < 0) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlexemeReconstruction.push(Scanner.getLexeme(followingToken));\n\t\t\t\t\t\t\t\tthis._advance();\n\t\t\t\t\t\t\t\tfollowingToken = this._peek();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst regexLexeme = lexemeReconstruction.join('');\n\t\t\t\t\t\t\tconst closingSlashIndex = regexLexeme.lastIndexOf('/');\n\t\t\t\t\t\t\tconst flags = closingSlashIndex === regexLexeme.length - 1 ? undefined : this._removeFlagsGY(regexLexeme.substring(closingSlashIndex + 1));\n\t\t\t\t\t\t\tlet regexp: RegExp | null;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tregexp = new RegExp(regexLexeme.substring(1, closingSlashIndex), flags);\n\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\tthrow this._errExpectedButGot(`REGEX`, expr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn ContextKeyExpr.regex(key, regexp);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase TokenType.QuotedStr: {\n\t\t\t\t\t\t\tconst serializedValue = expr.lexeme;\n\t\t\t\t\t\t\tthis._advance();\n\t\t\t\t\t\t\t// replicate old regex parsing behavior\n\n\t\t\t\t\t\t\tlet regex: RegExp | null = null;\n\n\t\t\t\t\t\t\tif (!isFalsyOrWhitespace(serializedValue)) {\n\t\t\t\t\t\t\t\tconst start = serializedValue.indexOf('/');\n\t\t\t\t\t\t\t\tconst end = serializedValue.lastIndexOf('/');\n\t\t\t\t\t\t\t\tif (start !== end && start >= 0) {\n\n\t\t\t\t\t\t\t\t\tconst value = serializedValue.slice(start + 1, end);\n\t\t\t\t\t\t\t\t\tconst caseIgnoreFlag = serializedValue[end + 1] === 'i' ? 'i' : '';\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tregex = new RegExp(value, caseIgnoreFlag);\n\t\t\t\t\t\t\t\t\t} catch (_e) {\n\t\t\t\t\t\t\t\t\t\tthrow this._errExpectedButGot(`REGEX`, expr);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (regex === null) {\n\t\t\t\t\t\t\t\tthrow this._errExpectedButGot('REGEX', expr);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn ContextKeyRegexExpr.create(key, regex);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow this._errExpectedButGot('REGEX', this._peek());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// [ 'not' 'in' value ]\n\t\t\t\tif (this._matchOne(TokenType.Not)) {\n\t\t\t\t\tthis._consume(TokenType.In, errorNoInAfterNot);\n\t\t\t\t\tconst right = this._value();\n\t\t\t\t\treturn ContextKeyExpr.notIn(key, right);\n\t\t\t\t}\n\n\t\t\t\t// [ ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in') value ]\n\t\t\t\tconst maybeOp = this._peek().type;\n\t\t\t\tswitch (maybeOp) {\n\t\t\t\t\tcase TokenType.Eq: {\n\t\t\t\t\t\tthis._advance();\n\n\t\t\t\t\t\tconst right = this._value();\n\t\t\t\t\t\tif (this._previous().type === TokenType.QuotedStr) { // to preserve old parser behavior: \"foo == 'true'\" is preserved as \"foo == 'true'\", but \"foo == true\" is optimized as \"foo\"\n\t\t\t\t\t\t\treturn ContextKeyExpr.equals(key, right);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tswitch (right) {\n\t\t\t\t\t\t\tcase 'true':\n\t\t\t\t\t\t\t\treturn ContextKeyExpr.has(key);\n\t\t\t\t\t\t\tcase 'false':\n\t\t\t\t\t\t\t\treturn ContextKeyExpr.not(key);\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn ContextKeyExpr.equals(key, right);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcase TokenType.NotEq: {\n\t\t\t\t\t\tthis._advance();\n\n\t\t\t\t\t\tconst right = this._value();\n\t\t\t\t\t\tif (this._previous().type === TokenType.QuotedStr) { // same as above with \"foo != 'true'\"\n\t\t\t\t\t\t\treturn ContextKeyExpr.notEquals(key, right);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tswitch (right) {\n\t\t\t\t\t\t\tcase 'true':\n\t\t\t\t\t\t\t\treturn ContextKeyExpr.not(key);\n\t\t\t\t\t\t\tcase 'false':\n\t\t\t\t\t\t\t\treturn ContextKeyExpr.has(key);\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn ContextKeyExpr.notEquals(key, right);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// TODO: ContextKeyExpr.smaller(key, right) accepts only `number` as `right` AND during eval of this node, we just eval to `false` if `right` is not a number\n\t\t\t\t\t// consequently, package.json linter should _warn_ the user if they're passing undesired things to ops\n\t\t\t\t\tcase TokenType.Lt:\n\t\t\t\t\t\tthis._advance();\n\t\t\t\t\t\treturn ContextKeySmallerExpr.create(key, this._value());\n\n\t\t\t\t\tcase TokenType.LtEq:\n\t\t\t\t\t\tthis._advance();\n\t\t\t\t\t\treturn ContextKeySmallerEqualsExpr.create(key, this._value());\n\n\t\t\t\t\tcase TokenType.Gt:\n\t\t\t\t\t\tthis._advance();\n\t\t\t\t\t\treturn ContextKeyGreaterExpr.create(key, this._value());\n\n\t\t\t\t\tcase TokenType.GtEq:\n\t\t\t\t\t\tthis._advance();\n\t\t\t\t\t\treturn ContextKeyGreaterEqualsExpr.create(key, this._value());\n\n\t\t\t\t\tcase TokenType.In:\n\t\t\t\t\t\tthis._advance();\n\t\t\t\t\t\treturn ContextKeyExpr.in(key, this._value());\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn ContextKeyExpr.has(key);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcase TokenType.EOF:\n\t\t\t\tthis._parsingErrors.push({ message: errorUnexpectedEOF, offset: peek.offset, lexeme: '', additionalInfo: hintUnexpectedEOF });\n\t\t\t\tthrow Parser._parseError;\n\n\t\t\tdefault:\n\t\t\t\tthrow this._errExpectedButGot(`true | false | KEY \\n\\t| KEY '=~' REGEX \\n\\t| KEY ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in') value`, this._peek());\n\n\t\t}\n\t}\n\n\tprivate _value(): string {\n\t\tconst token = this._peek();\n\t\tswitch (token.type) {\n\t\t\tcase TokenType.Str:\n\t\t\tcase TokenType.QuotedStr:\n\t\t\t\tthis._advance();\n\t\t\t\treturn token.lexeme;\n\t\t\tcase TokenType.True:\n\t\t\t\tthis._advance();\n\t\t\t\treturn 'true';\n\t\t\tcase TokenType.False:\n\t\t\t\tthis._advance();\n\t\t\t\treturn 'false';\n\t\t\tcase TokenType.In: // we support `in` as a value, e.g., \"when\": \"languageId == in\" - exists in existing extensions\n\t\t\t\tthis._advance();\n\t\t\t\treturn 'in';\n\t\t\tdefault:\n\t\t\t\t// this allows \"when\": \"foo == \" which's used by existing extensions\n\t\t\t\t// we do not call `_advance` on purpose - we don't want to eat unintended tokens\n\t\t\t\treturn '';\n\t\t}\n\t}\n\n\tprivate _flagsGYRe = /g|y/g;\n\tprivate _removeFlagsGY(flags: string): string {\n\t\treturn flags.replaceAll(this._flagsGYRe, '');\n\t}\n\n\t// careful: this can throw if current token is the initial one (ie index = 0)\n\tprivate _previous() {\n\t\treturn this._tokens[this._current - 1];\n\t}\n\n\tprivate _matchOne(token: TokenType) {\n\t\tif (this._check(token)) {\n\t\t\tthis._advance();\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate _advance() {\n\t\tif (!this._isAtEnd()) {\n\t\t\tthis._current++;\n\t\t}\n\t\treturn this._previous();\n\t}\n\n\tprivate _consume(type: TokenType, message: string) {\n\t\tif (this._check(type)) {\n\t\t\treturn this._advance();\n\t\t}\n\n\t\tthrow this._errExpectedButGot(message, this._peek());\n\t}\n\n\tprivate _errExpectedButGot(expected: string, got: Token, additionalInfo?: string) {\n\t\tconst message = localize('contextkey.parser.error.expectedButGot', \"Expected: {0}\\nReceived: '{1}'.\", expected, Scanner.getLexeme(got));\n\t\tconst offset = got.offset;\n\t\tconst lexeme = Scanner.getLexeme(got);\n\t\tthis._parsingErrors.push({ message, offset, lexeme, additionalInfo });\n\t\treturn Parser._parseError;\n\t}\n\n\tprivate _check(type: TokenType) {\n\t\treturn this._peek().type === type;\n\t}\n\n\tprivate _peek() {\n\t\treturn this._tokens[this._current];\n\t}\n\n\tprivate _isAtEnd() {\n\t\treturn this._peek().type === TokenType.EOF;\n\t}\n}\n\nexport abstract class ContextKeyExpr {\n\n\tpublic static false(): ContextKeyExpression {\n\t\treturn ContextKeyFalseExpr.INSTANCE;\n\t}\n\tpublic static true(): ContextKeyExpression {\n\t\treturn ContextKeyTrueExpr.INSTANCE;\n\t}\n\tpublic static has(key: string): ContextKeyExpression {\n\t\treturn ContextKeyDefinedExpr.create(key);\n\t}\n\tpublic static equals(key: string, value: any): ContextKeyExpression {\n\t\treturn ContextKeyEqualsExpr.create(key, value);\n\t}\n\tpublic static notEquals(key: string, value: any): ContextKeyExpression {\n\t\treturn ContextKeyNotEqualsExpr.create(key, value);\n\t}\n\tpublic static regex(key: string, value: RegExp): ContextKeyExpression {\n\t\treturn ContextKeyRegexExpr.create(key, value);\n\t}\n\tpublic static in(key: string, value: string): ContextKeyExpression {\n\t\treturn ContextKeyInExpr.create(key, value);\n\t}\n\tpublic static notIn(key: string, value: string): ContextKeyExpression {\n\t\treturn ContextKeyNotInExpr.create(key, value);\n\t}\n\tpublic static not(key: string): ContextKeyExpression {\n\t\treturn ContextKeyNotExpr.create(key);\n\t}\n\tpublic static and(...expr: Array<ContextKeyExpression | undefined | null>): ContextKeyExpression | undefined {\n\t\treturn ContextKeyAndExpr.create(expr, null, true);\n\t}\n\tpublic static or(...expr: Array<ContextKeyExpression | undefined | null>): ContextKeyExpression | undefined {\n\t\treturn ContextKeyOrExpr.create(expr, null, true);\n\t}\n\tpublic static greater(key: string, value: number): ContextKeyExpression {\n\t\treturn ContextKeyGreaterExpr.create(key, value);\n\t}\n\tpublic static greaterEquals(key: string, value: number): ContextKeyExpression {\n\t\treturn ContextKeyGreaterEqualsExpr.create(key, value);\n\t}\n\tpublic static smaller(key: string, value: number): ContextKeyExpression {\n\t\treturn ContextKeySmallerExpr.create(key, value);\n\t}\n\tpublic static smallerEquals(key: string, value: number): ContextKeyExpression {\n\t\treturn ContextKeySmallerEqualsExpr.create(key, value);\n\t}\n\n\tprivate static _parser = new Parser({ regexParsingWithErrorRecovery: false });\n\tpublic static deserialize(serialized: string | null | undefined): ContextKeyExpression | undefined {\n\t\tif (serialized === undefined || serialized === null) { // an empty string needs to be handled by the parser to get a corresponding parsing error reported\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst expr = this._parser.parse(serialized);\n\t\treturn expr;\n\t}\n\n}\n\n\nexport function validateWhenClauses(whenClauses: string[]): any {\n\n\tconst parser = new Parser({ regexParsingWithErrorRecovery: false }); // we run with no recovery to guide users to use correct regexes\n\n\treturn whenClauses.map(whenClause => {\n\t\tparser.parse(whenClause);\n\n\t\tif (parser.lexingErrors.length > 0) {\n\t\t\treturn parser.lexingErrors.map((se: LexingError) => ({\n\t\t\t\terrorMessage: se.additionalInfo ?\n\t\t\t\t\tlocalize('contextkey.scanner.errorForLinterWithHint', \"Unexpected token. Hint: {0}\", se.additionalInfo) :\n\t\t\t\t\tlocalize('contextkey.scanner.errorForLinter', \"Unexpected token.\"),\n\t\t\t\toffset: se.offset,\n\t\t\t\tlength: se.lexeme.length,\n\t\t\t}));\n\t\t} else if (parser.parsingErrors.length > 0) {\n\t\t\treturn parser.parsingErrors.map((pe: ParsingError) => ({\n\t\t\t\terrorMessage: pe.additionalInfo ? `${pe.message}. ${pe.additionalInfo}` : pe.message,\n\t\t\t\toffset: pe.offset,\n\t\t\t\tlength: pe.lexeme.length,\n\t\t\t}));\n\t\t} else {\n\t\t\treturn [];\n\t\t}\n\t});\n}\n\nexport function expressionsAreEqualWithConstantSubstitution(a: ContextKeyExpression | null | undefined, b: ContextKeyExpression | null | undefined): boolean {\n\tconst aExpr = a ? a.substituteConstants() : undefined;\n\tconst bExpr = b ? b.substituteConstants() : undefined;\n\tif (!aExpr && !bExpr) {\n\t\treturn true;\n\t}\n\tif (!aExpr || !bExpr) {\n\t\treturn false;\n\t}\n\treturn aExpr.equals(bExpr);\n}\n\nfunction cmp(a: ContextKeyExpression, b: ContextKeyExpression): number {\n\treturn a.cmp(b);\n}\n\nexport class ContextKeyFalseExpr implements IContextKeyExpression {\n\tpublic static INSTANCE = new ContextKeyFalseExpr();\n\n\tpublic readonly type = ContextKeyExprType.False;\n\n\tprotected constructor() {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\treturn this.type - other.type;\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\treturn (other.type === this.type);\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\treturn false;\n\t}\n\n\tpublic serialize(): string {\n\t\treturn 'false';\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn this;\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\treturn ContextKeyTrueExpr.INSTANCE;\n\t}\n}\n\nexport class ContextKeyTrueExpr implements IContextKeyExpression {\n\tpublic static INSTANCE = new ContextKeyTrueExpr();\n\n\tpublic readonly type = ContextKeyExprType.True;\n\n\tprotected constructor() {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\treturn this.type - other.type;\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\treturn (other.type === this.type);\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\treturn true;\n\t}\n\n\tpublic serialize(): string {\n\t\treturn 'true';\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn this;\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\treturn ContextKeyFalseExpr.INSTANCE;\n\t}\n}\n\nexport class ContextKeyDefinedExpr implements IContextKeyExpression {\n\tpublic static create(key: string, negated: ContextKeyExpression | null = null): ContextKeyExpression {\n\t\tconst constantValue = CONSTANT_VALUES.get(key);\n\t\tif (typeof constantValue === 'boolean') {\n\t\t\treturn constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n\t\t}\n\t\treturn new ContextKeyDefinedExpr(key, negated);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.Defined;\n\n\tprotected constructor(\n\t\treadonly key: string,\n\t\tprivate negated: ContextKeyExpression | null\n\t) {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp1(this.key, other.key);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn (this.key === other.key);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\tconst constantValue = CONSTANT_VALUES.get(this.key);\n\t\tif (typeof constantValue === 'boolean') {\n\t\t\treturn constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n\t\t}\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\treturn (!!context.getValue(this.key));\n\t}\n\n\tpublic serialize(): string {\n\t\treturn this.key;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapDefined(this.key);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyNotExpr.create(this.key, this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyEqualsExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, value: any, negated: ContextKeyExpression | null = null): ContextKeyExpression {\n\t\tif (typeof value === 'boolean') {\n\t\t\treturn (value ? ContextKeyDefinedExpr.create(key, negated) : ContextKeyNotExpr.create(key, negated));\n\t\t}\n\t\tconst constantValue = CONSTANT_VALUES.get(key);\n\t\tif (typeof constantValue === 'boolean') {\n\t\t\tconst trueValue = constantValue ? 'true' : 'false';\n\t\t\treturn (value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE);\n\t\t}\n\t\treturn new ContextKeyEqualsExpr(key, value, negated);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.Equals;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly value: any,\n\t\tprivate negated: ContextKeyExpression | null\n\t) {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp2(this.key, this.value, other.key, other.value);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn (this.key === other.key && this.value === other.value);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\tconst constantValue = CONSTANT_VALUES.get(this.key);\n\t\tif (typeof constantValue === 'boolean') {\n\t\t\tconst trueValue = constantValue ? 'true' : 'false';\n\t\t\treturn (this.value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE);\n\t\t}\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\t// Intentional ==\n\t\t// eslint-disable-next-line eqeqeq\n\t\treturn (context.getValue(this.key) == this.value);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} == '${this.value}'`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapEquals(this.key, this.value);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyNotEqualsExpr.create(this.key, this.value, this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyInExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, valueKey: string): ContextKeyInExpr {\n\t\treturn new ContextKeyInExpr(key, valueKey);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.In;\n\tprivate negated: ContextKeyExpression | null = null;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly valueKey: string,\n\t) {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp2(this.key, this.valueKey, other.key, other.valueKey);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn (this.key === other.key && this.valueKey === other.valueKey);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tconst source = context.getValue(this.valueKey);\n\n\t\tconst item = context.getValue(this.key);\n\n\t\tif (Array.isArray(source)) {\n\t\t\treturn source.includes(item as any);\n\t\t}\n\n\t\tif (typeof item === 'string' && typeof source === 'object' && source !== null) {\n\t\t\treturn hasOwnProperty.call(source, item);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} in '${this.valueKey}'`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key, this.valueKey];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyInExpr {\n\t\treturn mapFnc.mapIn(this.key, this.valueKey);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyNotInExpr.create(this.key, this.valueKey);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyNotInExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, valueKey: string): ContextKeyNotInExpr {\n\t\treturn new ContextKeyNotInExpr(key, valueKey);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.NotIn;\n\n\tprivate readonly _negated: ContextKeyInExpr;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly valueKey: string,\n\t) {\n\t\tthis._negated = ContextKeyInExpr.create(key, valueKey);\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn this._negated.cmp(other._negated);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn this._negated.equals(other._negated);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\treturn !this._negated.evaluate(context);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} not in '${this.valueKey}'`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn this._negated.keys();\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapNotIn(this.key, this.valueKey);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\treturn this._negated;\n\t}\n}\n\nexport class ContextKeyNotEqualsExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, value: any, negated: ContextKeyExpression | null = null): ContextKeyExpression {\n\t\tif (typeof value === 'boolean') {\n\t\t\tif (value) {\n\t\t\t\treturn ContextKeyNotExpr.create(key, negated);\n\t\t\t}\n\t\t\treturn ContextKeyDefinedExpr.create(key, negated);\n\t\t}\n\t\tconst constantValue = CONSTANT_VALUES.get(key);\n\t\tif (typeof constantValue === 'boolean') {\n\t\t\tconst falseValue = constantValue ? 'true' : 'false';\n\t\t\treturn (value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n\t\t}\n\t\treturn new ContextKeyNotEqualsExpr(key, value, negated);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.NotEquals;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly value: any,\n\t\tprivate negated: ContextKeyExpression | null\n\t) {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp2(this.key, this.value, other.key, other.value);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn (this.key === other.key && this.value === other.value);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\tconst constantValue = CONSTANT_VALUES.get(this.key);\n\t\tif (typeof constantValue === 'boolean') {\n\t\t\tconst falseValue = constantValue ? 'true' : 'false';\n\t\t\treturn (this.value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n\t\t}\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\t// Intentional !=\n\t\t// eslint-disable-next-line eqeqeq\n\t\treturn (context.getValue(this.key) != this.value);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} != '${this.value}'`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapNotEquals(this.key, this.value);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyEqualsExpr.create(this.key, this.value, this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyNotExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, negated: ContextKeyExpression | null = null): ContextKeyExpression {\n\t\tconst constantValue = CONSTANT_VALUES.get(key);\n\t\tif (typeof constantValue === 'boolean') {\n\t\t\treturn (constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n\t\t}\n\t\treturn new ContextKeyNotExpr(key, negated);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.Not;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate negated: ContextKeyExpression | null\n\t) {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp1(this.key, other.key);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn (this.key === other.key);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\tconst constantValue = CONSTANT_VALUES.get(this.key);\n\t\tif (typeof constantValue === 'boolean') {\n\t\t\treturn (constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n\t\t}\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\treturn (!context.getValue(this.key));\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `!${this.key}`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapNot(this.key);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyDefinedExpr.create(this.key, this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nfunction withFloatOrStr<T extends ContextKeyExpression>(value: any, callback: (value: number | string) => T): T | ContextKeyFalseExpr {\n\tif (typeof value === 'string') {\n\t\tconst n = parseFloat(value);\n\t\tif (!isNaN(n)) {\n\t\t\tvalue = n;\n\t\t}\n\t}\n\tif (typeof value === 'string' || typeof value === 'number') {\n\t\treturn callback(value);\n\t}\n\treturn ContextKeyFalseExpr.INSTANCE;\n}\n\nexport class ContextKeyGreaterExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, _value: any, negated: ContextKeyExpression | null = null): ContextKeyExpression {\n\t\treturn withFloatOrStr(_value, (value) => new ContextKeyGreaterExpr(key, value, negated));\n\t}\n\n\tpublic readonly type = ContextKeyExprType.Greater;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly value: number | string,\n\t\tprivate negated: ContextKeyExpression | null\n\t) { }\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp2(this.key, this.value, other.key, other.value);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn (this.key === other.key && this.value === other.value);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tif (typeof this.value === 'string') {\n\t\t\treturn false;\n\t\t}\n\t\treturn (parseFloat(<any>context.getValue(this.key)) > this.value);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} > ${this.value}`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapGreater(this.key, this.value);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeySmallerEqualsExpr.create(this.key, this.value, this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyGreaterEqualsExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, _value: any, negated: ContextKeyExpression | null = null): ContextKeyExpression {\n\t\treturn withFloatOrStr(_value, (value) => new ContextKeyGreaterEqualsExpr(key, value, negated));\n\t}\n\n\tpublic readonly type = ContextKeyExprType.GreaterEquals;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly value: number | string,\n\t\tprivate negated: ContextKeyExpression | null\n\t) { }\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp2(this.key, this.value, other.key, other.value);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn (this.key === other.key && this.value === other.value);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tif (typeof this.value === 'string') {\n\t\t\treturn false;\n\t\t}\n\t\treturn (parseFloat(<any>context.getValue(this.key)) >= this.value);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} >= ${this.value}`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapGreaterEquals(this.key, this.value);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeySmallerExpr.create(this.key, this.value, this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeySmallerExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, _value: any, negated: ContextKeyExpression | null = null): ContextKeyExpression {\n\t\treturn withFloatOrStr(_value, (value) => new ContextKeySmallerExpr(key, value, negated));\n\t}\n\n\tpublic readonly type = ContextKeyExprType.Smaller;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly value: number | string,\n\t\tprivate negated: ContextKeyExpression | null\n\t) {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp2(this.key, this.value, other.key, other.value);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn (this.key === other.key && this.value === other.value);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tif (typeof this.value === 'string') {\n\t\t\treturn false;\n\t\t}\n\t\treturn (parseFloat(<any>context.getValue(this.key)) < this.value);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} < ${this.value}`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapSmaller(this.key, this.value);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyGreaterEqualsExpr.create(this.key, this.value, this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeySmallerEqualsExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, _value: any, negated: ContextKeyExpression | null = null): ContextKeyExpression {\n\t\treturn withFloatOrStr(_value, (value) => new ContextKeySmallerEqualsExpr(key, value, negated));\n\t}\n\n\tpublic readonly type = ContextKeyExprType.SmallerEquals;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly value: number | string,\n\t\tprivate negated: ContextKeyExpression | null\n\t) {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp2(this.key, this.value, other.key, other.value);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn (this.key === other.key && this.value === other.value);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tif (typeof this.value === 'string') {\n\t\t\treturn false;\n\t\t}\n\t\treturn (parseFloat(<any>context.getValue(this.key)) <= this.value);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} <= ${this.value}`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapSmallerEquals(this.key, this.value);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyGreaterExpr.create(this.key, this.value, this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyRegexExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, regexp: RegExp | null): ContextKeyRegexExpr {\n\t\treturn new ContextKeyRegexExpr(key, regexp);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.Regex;\n\tprivate negated: ContextKeyExpression | null = null;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly regexp: RegExp | null\n\t) {\n\t\t//\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\tif (this.key < other.key) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (this.key > other.key) {\n\t\t\treturn 1;\n\t\t}\n\t\tconst thisSource = this.regexp ? this.regexp.source : '';\n\t\tconst otherSource = other.regexp ? other.regexp.source : '';\n\t\tif (thisSource < otherSource) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (thisSource > otherSource) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\tconst thisSource = this.regexp ? this.regexp.source : '';\n\t\t\tconst otherSource = other.regexp ? other.regexp.source : '';\n\t\t\treturn (this.key === other.key && thisSource === otherSource);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tconst value = context.getValue<any>(this.key);\n\t\treturn this.regexp ? this.regexp.test(value) : false;\n\t}\n\n\tpublic serialize(): string {\n\t\tconst value = this.regexp\n\t\t\t? `/${this.regexp.source}/${this.regexp.flags}`\n\t\t\t: '/invalid/';\n\t\treturn `${this.key} =~ ${value}`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyRegexExpr {\n\t\treturn mapFnc.mapRegex(this.key, this.regexp);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyNotRegexExpr.create(this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyNotRegexExpr implements IContextKeyExpression {\n\n\tpublic static create(actual: ContextKeyRegexExpr): ContextKeyExpression {\n\t\treturn new ContextKeyNotRegexExpr(actual);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.NotRegex;\n\n\tprivate constructor(private readonly _actual: ContextKeyRegexExpr) {\n\t\t//\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn this._actual.cmp(other._actual);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn this._actual.equals(other._actual);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\treturn !this._actual.evaluate(context);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `!(${this._actual.serialize()})`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn this._actual.keys();\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn new ContextKeyNotRegexExpr(this._actual.map(mapFnc));\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\treturn this._actual;\n\t}\n}\n\n/**\n * @returns the same instance if nothing changed.\n */\nfunction eliminateConstantsInArray(arr: ContextKeyExpression[]): (ContextKeyExpression | undefined)[] {\n\t// Allocate array only if there is a difference\n\tlet newArr: (ContextKeyExpression | undefined)[] | null = null;\n\tfor (let i = 0, len = arr.length; i < len; i++) {\n\t\tconst newExpr = arr[i].substituteConstants();\n\n\t\tif (arr[i] !== newExpr) {\n\t\t\t// something has changed!\n\n\t\t\t// allocate array on first difference\n\t\t\tif (newArr === null) {\n\t\t\t\tnewArr = [];\n\t\t\t\tfor (let j = 0; j < i; j++) {\n\t\t\t\t\tnewArr[j] = arr[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (newArr !== null) {\n\t\t\tnewArr[i] = newExpr;\n\t\t}\n\t}\n\n\tif (newArr === null) {\n\t\treturn arr;\n\t}\n\treturn newArr;\n}\n\nexport class ContextKeyAndExpr implements IContextKeyExpression {\n\n\tpublic static create(_expr: ReadonlyArray<ContextKeyExpression | null | undefined>, negated: ContextKeyExpression | null, extraRedundantCheck: boolean): ContextKeyExpression | undefined {\n\t\treturn ContextKeyAndExpr._normalizeArr(_expr, negated, extraRedundantCheck);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.And;\n\n\tprivate constructor(\n\t\tpublic readonly expr: ContextKeyExpression[],\n\t\tprivate negated: ContextKeyExpression | null\n\t) {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\tif (this.expr.length < other.expr.length) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (this.expr.length > other.expr.length) {\n\t\t\treturn 1;\n\t\t}\n\t\tfor (let i = 0, len = this.expr.length; i < len; i++) {\n\t\t\tconst r = cmp(this.expr[i], other.expr[i]);\n\t\t\tif (r !== 0) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\tif (this.expr.length !== other.expr.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (let i = 0, len = this.expr.length; i < len; i++) {\n\t\t\t\tif (!this.expr[i].equals(other.expr[i])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\tconst exprArr = eliminateConstantsInArray(this.expr);\n\t\tif (exprArr === this.expr) {\n\t\t\t// no change\n\t\t\treturn this;\n\t\t}\n\t\treturn ContextKeyAndExpr.create(exprArr, this.negated, false);\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tfor (let i = 0, len = this.expr.length; i < len; i++) {\n\t\t\tif (!this.expr[i].evaluate(context)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate static _normalizeArr(arr: ReadonlyArray<ContextKeyExpression | null | undefined>, negated: ContextKeyExpression | null, extraRedundantCheck: boolean): ContextKeyExpression | undefined {\n\t\tconst expr: ContextKeyExpression[] = [];\n\t\tlet hasTrue = false;\n\n\t\tfor (const e of arr) {\n\t\t\tif (!e) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (e.type === ContextKeyExprType.True) {\n\t\t\t\t// anything && true ==> anything\n\t\t\t\thasTrue = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (e.type === ContextKeyExprType.False) {\n\t\t\t\t// anything && false ==> false\n\t\t\t\treturn ContextKeyFalseExpr.INSTANCE;\n\t\t\t}\n\n\t\t\tif (e.type === ContextKeyExprType.And) {\n\t\t\t\texpr.push(...e.expr);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\texpr.push(e);\n\t\t}\n\n\t\tif (expr.length === 0 && hasTrue) {\n\t\t\treturn ContextKeyTrueExpr.INSTANCE;\n\t\t}\n\n\t\tif (expr.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (expr.length === 1) {\n\t\t\treturn expr[0];\n\t\t}\n\n\t\texpr.sort(cmp);\n\n\t\t// eliminate duplicate terms\n\t\tfor (let i = 1; i < expr.length; i++) {\n\t\t\tif (expr[i - 1].equals(expr[i])) {\n\t\t\t\texpr.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\n\t\tif (expr.length === 1) {\n\t\t\treturn expr[0];\n\t\t}\n\n\t\t// We must distribute any OR expression because we don't support parens\n\t\t// OR extensions will be at the end (due to sorting rules)\n\t\twhile (expr.length > 1) {\n\t\t\tconst lastElement = expr[expr.length - 1];\n\t\t\tif (lastElement.type !== ContextKeyExprType.Or) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// pop the last element\n\t\t\texpr.pop();\n\n\t\t\t// pop the second to last element\n\t\t\tconst secondToLastElement = expr.pop()!;\n\n\t\t\tconst isFinished = (expr.length === 0);\n\n\t\t\t// distribute `lastElement` over `secondToLastElement`\n\t\t\tconst resultElement = ContextKeyOrExpr.create(\n\t\t\t\tlastElement.expr.map(el => ContextKeyAndExpr.create([el, secondToLastElement], null, extraRedundantCheck)),\n\t\t\t\tnull,\n\t\t\t\tisFinished\n\t\t\t);\n\n\t\t\tif (resultElement) {\n\t\t\t\texpr.push(resultElement);\n\t\t\t\texpr.sort(cmp);\n\t\t\t}\n\t\t}\n\n\t\tif (expr.length === 1) {\n\t\t\treturn expr[0];\n\t\t}\n\n\t\t// resolve false AND expressions\n\t\tif (extraRedundantCheck) {\n\t\t\tfor (let i = 0; i < expr.length; i++) {\n\t\t\t\tfor (let j = i + 1; j < expr.length; j++) {\n\t\t\t\t\tif (expr[i].negate().equals(expr[j])) {\n\t\t\t\t\t\t// A && !A case\n\t\t\t\t\t\treturn ContextKeyFalseExpr.INSTANCE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (expr.length === 1) {\n\t\t\t\treturn expr[0];\n\t\t\t}\n\t\t}\n\n\t\treturn new ContextKeyAndExpr(expr, negated);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn this.expr.map(e => e.serialize()).join(' && ');\n\t}\n\n\tpublic keys(): string[] {\n\t\tconst result: string[] = [];\n\t\tfor (const expr of this.expr) {\n\t\t\tresult.push(...expr.keys());\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn new ContextKeyAndExpr(this.expr.map(expr => expr.map(mapFnc)), null);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tconst result: ContextKeyExpression[] = [];\n\t\t\tfor (const expr of this.expr) {\n\t\t\t\tresult.push(expr.negate());\n\t\t\t}\n\t\t\tthis.negated = ContextKeyOrExpr.create(result, this, true)!;\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyOrExpr implements IContextKeyExpression {\n\n\tpublic static create(_expr: ReadonlyArray<ContextKeyExpression | null | undefined>, negated: ContextKeyExpression | null, extraRedundantCheck: boolean): ContextKeyExpression | undefined {\n\t\treturn ContextKeyOrExpr._normalizeArr(_expr, negated, extraRedundantCheck);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.Or;\n\n\tprivate constructor(\n\t\tpublic readonly expr: ContextKeyExpression[],\n\t\tprivate negated: ContextKeyExpression | null\n\t) {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\tif (this.expr.length < other.expr.length) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (this.expr.length > other.expr.length) {\n\t\t\treturn 1;\n\t\t}\n\t\tfor (let i = 0, len = this.expr.length; i < len; i++) {\n\t\t\tconst r = cmp(this.expr[i], other.expr[i]);\n\t\t\tif (r !== 0) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\tif (this.expr.length !== other.expr.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (let i = 0, len = this.expr.length; i < len; i++) {\n\t\t\t\tif (!this.expr[i].equals(other.expr[i])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\tconst exprArr = eliminateConstantsInArray(this.expr);\n\t\tif (exprArr === this.expr) {\n\t\t\t// no change\n\t\t\treturn this;\n\t\t}\n\t\treturn ContextKeyOrExpr.create(exprArr, this.negated, false);\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tfor (let i = 0, len = this.expr.length; i < len; i++) {\n\t\t\tif (this.expr[i].evaluate(context)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate static _normalizeArr(arr: ReadonlyArray<ContextKeyExpression | null | undefined>, negated: ContextKeyExpression | null, extraRedundantCheck: boolean): ContextKeyExpression | undefined {\n\t\tlet expr: ContextKeyExpression[] = [];\n\t\tlet hasFalse = false;\n\n\t\tif (arr) {\n\t\t\tfor (let i = 0, len = arr.length; i < len; i++) {\n\t\t\t\tconst e = arr[i];\n\t\t\t\tif (!e) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (e.type === ContextKeyExprType.False) {\n\t\t\t\t\t// anything || false ==> anything\n\t\t\t\t\thasFalse = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (e.type === ContextKeyExprType.True) {\n\t\t\t\t\t// anything || true ==> true\n\t\t\t\t\treturn ContextKeyTrueExpr.INSTANCE;\n\t\t\t\t}\n\n\t\t\t\tif (e.type === ContextKeyExprType.Or) {\n\t\t\t\t\texpr = expr.concat(e.expr);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\texpr.push(e);\n\t\t\t}\n\n\t\t\tif (expr.length === 0 && hasFalse) {\n\t\t\t\treturn ContextKeyFalseExpr.INSTANCE;\n\t\t\t}\n\n\t\t\texpr.sort(cmp);\n\t\t}\n\n\t\tif (expr.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (expr.length === 1) {\n\t\t\treturn expr[0];\n\t\t}\n\n\t\t// eliminate duplicate terms\n\t\tfor (let i = 1; i < expr.length; i++) {\n\t\t\tif (expr[i - 1].equals(expr[i])) {\n\t\t\t\texpr.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\n\t\tif (expr.length === 1) {\n\t\t\treturn expr[0];\n\t\t}\n\n\t\t// resolve true OR expressions\n\t\tif (extraRedundantCheck) {\n\t\t\tfor (let i = 0; i < expr.length; i++) {\n\t\t\t\tfor (let j = i + 1; j < expr.length; j++) {\n\t\t\t\t\tif (expr[i].negate().equals(expr[j])) {\n\t\t\t\t\t\t// A || !A case\n\t\t\t\t\t\treturn ContextKeyTrueExpr.INSTANCE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (expr.length === 1) {\n\t\t\t\treturn expr[0];\n\t\t\t}\n\t\t}\n\n\t\treturn new ContextKeyOrExpr(expr, negated);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn this.expr.map(e => e.serialize()).join(' || ');\n\t}\n\n\tpublic keys(): string[] {\n\t\tconst result: string[] = [];\n\t\tfor (const expr of this.expr) {\n\t\t\tresult.push(...expr.keys());\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn new ContextKeyOrExpr(this.expr.map(expr => expr.map(mapFnc)), null);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tconst result: ContextKeyExpression[] = [];\n\t\t\tfor (const expr of this.expr) {\n\t\t\t\tresult.push(expr.negate());\n\t\t\t}\n\n\t\t\t// We don't support parens, so here we distribute the AND over the OR terminals\n\t\t\t// We always take the first 2 AND pairs and distribute them\n\t\t\twhile (result.length > 1) {\n\t\t\t\tconst LEFT = result.shift()!;\n\t\t\t\tconst RIGHT = result.shift()!;\n\n\t\t\t\tconst all: ContextKeyExpression[] = [];\n\t\t\t\tfor (const left of getTerminals(LEFT)) {\n\t\t\t\t\tfor (const right of getTerminals(RIGHT)) {\n\t\t\t\t\t\tall.push(ContextKeyAndExpr.create([left, right], null, false)!);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tresult.unshift(ContextKeyOrExpr.create(all, null, false)!);\n\t\t\t}\n\n\t\t\tthis.negated = ContextKeyOrExpr.create(result, this, true)!;\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport interface ContextKeyInfo {\n\treadonly key: string;\n\treadonly type?: string;\n\treadonly description?: string;\n}\n\nexport class RawContextKey<T extends ContextKeyValue> extends ContextKeyDefinedExpr {\n\n\tprivate static _info: ContextKeyInfo[] = [];\n\n\tstatic all(): IterableIterator<ContextKeyInfo> {\n\t\treturn RawContextKey._info.values();\n\t}\n\n\tprivate readonly _defaultValue: T | undefined;\n\n\tconstructor(key: string, defaultValue: T | undefined, metaOrHide?: string | true | { type: string; description: string }) {\n\t\tsuper(key, null);\n\t\tthis._defaultValue = defaultValue;\n\n\t\t// collect all context keys into a central place\n\t\tif (typeof metaOrHide === 'object') {\n\t\t\tRawContextKey._info.push({ ...metaOrHide, key });\n\t\t} else if (metaOrHide !== true) {\n\t\t\tRawContextKey._info.push({ key, description: metaOrHide, type: defaultValue !== null && defaultValue !== undefined ? typeof defaultValue : undefined });\n\t\t}\n\t}\n\n\tpublic bindTo(target: IContextKeyService): IContextKey<T> {\n\t\treturn target.createKey(this.key, this._defaultValue);\n\t}\n\n\tpublic getValue(target: IContextKeyService): T | undefined {\n\t\treturn target.getContextKeyValue<T>(this.key);\n\t}\n\n\tpublic toNegated(): ContextKeyExpression {\n\t\treturn this.negate();\n\t}\n\n\tpublic isEqualTo(value: any): ContextKeyExpression {\n\t\treturn ContextKeyEqualsExpr.create(this.key, value);\n\t}\n\n\tpublic notEqualsTo(value: any): ContextKeyExpression {\n\t\treturn ContextKeyNotEqualsExpr.create(this.key, value);\n\t}\n}\n\nexport type ContextKeyValue = null | undefined | boolean | number | string\n\t| Array<null | undefined | boolean | number | string>\n\t| Record<string, null | undefined | boolean | number | string>;\n\nexport interface IContext {\n\tgetValue<T extends ContextKeyValue = ContextKeyValue>(key: string): T | undefined;\n}\n\nexport interface IContextKey<T extends ContextKeyValue = ContextKeyValue> {\n\tset(value: T): void;\n\treset(): void;\n\tget(): T | undefined;\n}\n\nexport interface IContextKeyServiceTarget {\n\tparentElement: IContextKeyServiceTarget | null;\n\tsetAttribute(attr: string, value: string): void;\n\tremoveAttribute(attr: string): void;\n\thasAttribute(attr: string): boolean;\n\tgetAttribute(attr: string): string | null;\n}\n\nexport const IContextKeyService = createDecorator<IContextKeyService>('contextKeyService');\n\nexport interface IReadableSet<T> {\n\thas(value: T): boolean;\n}\n\nexport interface IContextKeyChangeEvent {\n\taffectsSome(keys: IReadableSet<string>): boolean;\n\tallKeysContainedIn(keys: IReadableSet<string>): boolean;\n}\n\nexport type IScopedContextKeyService = IContextKeyService & IDisposable;\n\nexport interface IContextKeyService {\n\treadonly _serviceBrand: undefined;\n\n\tonDidChangeContext: Event<IContextKeyChangeEvent>;\n\tbufferChangeEvents(callback: Function): void;\n\n\tcreateKey<T extends ContextKeyValue>(key: string, defaultValue: T | undefined): IContextKey<T>;\n\tcontextMatchesRules(rules: ContextKeyExpression | undefined): boolean;\n\tgetContextKeyValue<T>(key: string): T | undefined;\n\n\tcreateScoped(target: IContextKeyServiceTarget): IScopedContextKeyService;\n\tcreateOverlay(overlay: Iterable<[string, any]>): IContextKeyService;\n\tgetContext(target: IContextKeyServiceTarget | null): IContext;\n\n\tupdateParent(parentContextKeyService: IContextKeyService): void;\n}\n\nfunction cmp1(key1: string, key2: string): number {\n\tif (key1 < key2) {\n\t\treturn -1;\n\t}\n\tif (key1 > key2) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nfunction cmp2(key1: string, value1: any, key2: string, value2: any): number {\n\tif (key1 < key2) {\n\t\treturn -1;\n\t}\n\tif (key1 > key2) {\n\t\treturn 1;\n\t}\n\tif (value1 < value2) {\n\t\treturn -1;\n\t}\n\tif (value1 > value2) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/**\n * Returns true if it is provable `p` implies `q`.\n */\nexport function implies(p: ContextKeyExpression, q: ContextKeyExpression): boolean {\n\n\tif (p.type === ContextKeyExprType.False || q.type === ContextKeyExprType.True) {\n\t\t// false implies anything\n\t\t// anything implies true\n\t\treturn true;\n\t}\n\n\tif (p.type === ContextKeyExprType.Or) {\n\t\tif (q.type === ContextKeyExprType.Or) {\n\t\t\t// `a || b || c` can only imply something like `a || b || c || d`\n\t\t\treturn allElementsIncluded(p.expr, q.expr);\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (q.type === ContextKeyExprType.Or) {\n\t\tfor (const element of q.expr) {\n\t\t\tif (implies(p, element)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (p.type === ContextKeyExprType.And) {\n\t\tif (q.type === ContextKeyExprType.And) {\n\t\t\t// `a && b && c` implies `a && c`\n\t\t\treturn allElementsIncluded(q.expr, p.expr);\n\t\t}\n\t\tfor (const element of p.expr) {\n\t\t\tif (implies(element, q)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn p.equals(q);\n}\n\n/**\n * Returns true if all elements in `p` are also present in `q`.\n * The two arrays are assumed to be sorted\n */\nfunction allElementsIncluded(p: ContextKeyExpression[], q: ContextKeyExpression[]): boolean {\n\tlet pIndex = 0;\n\tlet qIndex = 0;\n\twhile (pIndex < p.length && qIndex < q.length) {\n\t\tconst cmp = p[pIndex].cmp(q[qIndex]);\n\n\t\tif (cmp < 0) {\n\t\t\t// an element from `p` is missing from `q`\n\t\t\treturn false;\n\t\t} else if (cmp === 0) {\n\t\t\tpIndex++;\n\t\t\tqIndex++;\n\t\t} else {\n\t\t\tqIndex++;\n\t\t}\n\t}\n\treturn (pIndex === p.length);\n}\n\nfunction getTerminals(node: ContextKeyExpression) {\n\tif (node.type === ContextKeyExprType.Or) {\n\t\treturn node.expr;\n\t}\n\treturn [node];\n}\n"],
  "mappings": "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",
  "names": ["ContextKeyExprType", "cmp"]
}
