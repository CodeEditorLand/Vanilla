{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/contextkey/common/scanner.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from \"../../../base/common/charCode.js\";\nimport { illegalState } from \"../../../base/common/errors.js\";\nimport { localize } from \"../../../nls.js\";\n\nexport enum TokenType {\n\tLParen = 0,\n\tRParen = 1,\n\tNeg = 2,\n\tEq = 3,\n\tNotEq = 4,\n\tLt = 5,\n\tLtEq = 6,\n\tGt = 7,\n\tGtEq = 8,\n\tRegexOp = 9,\n\tRegexStr = 10,\n\tTrue = 11,\n\tFalse = 12,\n\tIn = 13,\n\tNot = 14,\n\tAnd = 15,\n\tOr = 16,\n\tStr = 17,\n\tQuotedStr = 18,\n\tError = 19,\n\tEOF = 20,\n}\n\nexport type Token =\n\t| { type: TokenType.LParen; offset: number }\n\t| { type: TokenType.RParen; offset: number }\n\t| { type: TokenType.Neg; offset: number }\n\t| { type: TokenType.Eq; offset: number; isTripleEq: boolean }\n\t| { type: TokenType.NotEq; offset: number; isTripleEq: boolean }\n\t| { type: TokenType.Lt; offset: number }\n\t| { type: TokenType.LtEq; offset: number }\n\t| { type: TokenType.Gt; offset: number }\n\t| { type: TokenType.GtEq; offset: number }\n\t| { type: TokenType.RegexOp; offset: number }\n\t| { type: TokenType.RegexStr; offset: number; lexeme: string }\n\t| { type: TokenType.True; offset: number }\n\t| { type: TokenType.False; offset: number }\n\t| { type: TokenType.In; offset: number }\n\t| { type: TokenType.Not; offset: number }\n\t| { type: TokenType.And; offset: number }\n\t| { type: TokenType.Or; offset: number }\n\t| { type: TokenType.Str; offset: number; lexeme: string }\n\t| { type: TokenType.QuotedStr; offset: number; lexeme: string }\n\t| { type: TokenType.Error; offset: number; lexeme: string }\n\t| { type: TokenType.EOF; offset: number };\n\ntype KeywordTokenType =\n\t| TokenType.Not\n\t| TokenType.In\n\t| TokenType.False\n\t| TokenType.True;\ntype TokenTypeWithoutLexeme =\n\t| TokenType.LParen\n\t| TokenType.RParen\n\t| TokenType.Neg\n\t| TokenType.Lt\n\t| TokenType.LtEq\n\t| TokenType.Gt\n\t| TokenType.GtEq\n\t| TokenType.RegexOp\n\t| TokenType.True\n\t| TokenType.False\n\t| TokenType.In\n\t| TokenType.Not\n\t| TokenType.And\n\t| TokenType.Or\n\t| TokenType.EOF;\n\n/**\n * Example:\n * `foo == bar'` - note how single quote doesn't have a corresponding closing quote,\n * so it's reported as unexpected\n */\nexport type LexingError = {\n\toffset: number /** note that this doesn't take into account escape characters from the original encoding of the string, e.g., within an extension manifest file's JSON encoding  */;\n\tlexeme: string;\n\tadditionalInfo?: string;\n};\n\nfunction hintDidYouMean(...meant: string[]) {\n\tswitch (meant.length) {\n\t\tcase 1:\n\t\t\treturn localize(\n\t\t\t\t\"contextkey.scanner.hint.didYouMean1\",\n\t\t\t\t\"Did you mean {0}?\",\n\t\t\t\tmeant[0],\n\t\t\t);\n\t\tcase 2:\n\t\t\treturn localize(\n\t\t\t\t\"contextkey.scanner.hint.didYouMean2\",\n\t\t\t\t\"Did you mean {0} or {1}?\",\n\t\t\t\tmeant[0],\n\t\t\t\tmeant[1],\n\t\t\t);\n\t\tcase 3:\n\t\t\treturn localize(\n\t\t\t\t\"contextkey.scanner.hint.didYouMean3\",\n\t\t\t\t\"Did you mean {0}, {1} or {2}?\",\n\t\t\t\tmeant[0],\n\t\t\t\tmeant[1],\n\t\t\t\tmeant[2],\n\t\t\t);\n\t\tdefault: // we just don't expect that many\n\t\t\treturn undefined;\n\t}\n}\n\nconst hintDidYouForgetToOpenOrCloseQuote = localize(\n\t\"contextkey.scanner.hint.didYouForgetToOpenOrCloseQuote\",\n\t\"Did you forget to open or close the quote?\",\n);\nconst hintDidYouForgetToEscapeSlash = localize(\n\t\"contextkey.scanner.hint.didYouForgetToEscapeSlash\",\n\t\"Did you forget to escape the '/' (slash) character? Put two backslashes before it to escape, e.g., '\\\\\\\\/'.\",\n);\n\n/**\n * A simple scanner for context keys.\n *\n * Example:\n *\n * ```ts\n * const scanner = new Scanner().reset('resourceFileName =~ /docker/ && !config.docker.enabled');\n * const tokens = [...scanner];\n * if (scanner.errorTokens.length > 0) {\n *     scanner.errorTokens.forEach(err => console.error(`Unexpected token at ${err.offset}: ${err.lexeme}\\nHint: ${err.additional}`));\n * } else {\n *     // process tokens\n * }\n * ```\n */\nexport class Scanner {\n\tstatic getLexeme(token: Token): string {\n\t\tswitch (token.type) {\n\t\t\tcase TokenType.LParen:\n\t\t\t\treturn \"(\";\n\t\t\tcase TokenType.RParen:\n\t\t\t\treturn \")\";\n\t\t\tcase TokenType.Neg:\n\t\t\t\treturn \"!\";\n\t\t\tcase TokenType.Eq:\n\t\t\t\treturn token.isTripleEq ? \"===\" : \"==\";\n\t\t\tcase TokenType.NotEq:\n\t\t\t\treturn token.isTripleEq ? \"!==\" : \"!=\";\n\t\t\tcase TokenType.Lt:\n\t\t\t\treturn \"<\";\n\t\t\tcase TokenType.LtEq:\n\t\t\t\treturn \"<=\";\n\t\t\tcase TokenType.Gt:\n\t\t\t\treturn \">=\";\n\t\t\tcase TokenType.GtEq:\n\t\t\t\treturn \">=\";\n\t\t\tcase TokenType.RegexOp:\n\t\t\t\treturn \"=~\";\n\t\t\tcase TokenType.RegexStr:\n\t\t\t\treturn token.lexeme;\n\t\t\tcase TokenType.True:\n\t\t\t\treturn \"true\";\n\t\t\tcase TokenType.False:\n\t\t\t\treturn \"false\";\n\t\t\tcase TokenType.In:\n\t\t\t\treturn \"in\";\n\t\t\tcase TokenType.Not:\n\t\t\t\treturn \"not\";\n\t\t\tcase TokenType.And:\n\t\t\t\treturn \"&&\";\n\t\t\tcase TokenType.Or:\n\t\t\t\treturn \"||\";\n\t\t\tcase TokenType.Str:\n\t\t\t\treturn token.lexeme;\n\t\t\tcase TokenType.QuotedStr:\n\t\t\t\treturn token.lexeme;\n\t\t\tcase TokenType.Error:\n\t\t\t\treturn token.lexeme;\n\t\t\tcase TokenType.EOF:\n\t\t\t\treturn \"EOF\";\n\t\t\tdefault:\n\t\t\t\tthrow illegalState(\n\t\t\t\t\t`unhandled token type: ${JSON.stringify(token)}; have you forgotten to add a case?`,\n\t\t\t\t);\n\t\t}\n\t}\n\n\tprivate static _regexFlags = new Set(\n\t\t[\"i\", \"g\", \"s\", \"m\", \"y\", \"u\"].map((ch) => ch.charCodeAt(0)),\n\t);\n\n\tprivate static _keywords = new Map<string, KeywordTokenType>([\n\t\t[\"not\", TokenType.Not],\n\t\t[\"in\", TokenType.In],\n\t\t[\"false\", TokenType.False],\n\t\t[\"true\", TokenType.True],\n\t]);\n\n\tprivate _input = \"\";\n\tprivate _start = 0;\n\tprivate _current = 0;\n\tprivate _tokens: Token[] = [];\n\tprivate _errors: LexingError[] = [];\n\n\tget errors(): Readonly<LexingError[]> {\n\t\treturn this._errors;\n\t}\n\n\treset(value: string) {\n\t\tthis._input = value;\n\n\t\tthis._start = 0;\n\t\tthis._current = 0;\n\t\tthis._tokens = [];\n\t\tthis._errors = [];\n\n\t\treturn this;\n\t}\n\n\tscan() {\n\t\twhile (!this._isAtEnd()) {\n\t\t\tthis._start = this._current;\n\n\t\t\tconst ch = this._advance();\n\t\t\tswitch (ch) {\n\t\t\t\tcase CharCode.OpenParen:\n\t\t\t\t\tthis._addToken(TokenType.LParen);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CharCode.CloseParen:\n\t\t\t\t\tthis._addToken(TokenType.RParen);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CharCode.ExclamationMark:\n\t\t\t\t\tif (this._match(CharCode.Equals)) {\n\t\t\t\t\t\tconst isTripleEq = this._match(CharCode.Equals); // eat last `=` if `!==`\n\t\t\t\t\t\tthis._tokens.push({\n\t\t\t\t\t\t\ttype: TokenType.NotEq,\n\t\t\t\t\t\t\toffset: this._start,\n\t\t\t\t\t\t\tisTripleEq,\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._addToken(TokenType.Neg);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CharCode.SingleQuote:\n\t\t\t\t\tthis._quotedString();\n\t\t\t\t\tbreak;\n\t\t\t\tcase CharCode.Slash:\n\t\t\t\t\tthis._regex();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CharCode.Equals:\n\t\t\t\t\tif (this._match(CharCode.Equals)) {\n\t\t\t\t\t\t// support `==`\n\t\t\t\t\t\tconst isTripleEq = this._match(CharCode.Equals); // eat last `=` if `===`\n\t\t\t\t\t\tthis._tokens.push({\n\t\t\t\t\t\t\ttype: TokenType.Eq,\n\t\t\t\t\t\t\toffset: this._start,\n\t\t\t\t\t\t\tisTripleEq,\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (this._match(CharCode.Tilde)) {\n\t\t\t\t\t\tthis._addToken(TokenType.RegexOp);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._error(hintDidYouMean(\"==\", \"=~\"));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CharCode.LessThan:\n\t\t\t\t\tthis._addToken(\n\t\t\t\t\t\tthis._match(CharCode.Equals)\n\t\t\t\t\t\t\t? TokenType.LtEq\n\t\t\t\t\t\t\t: TokenType.Lt,\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CharCode.GreaterThan:\n\t\t\t\t\tthis._addToken(\n\t\t\t\t\t\tthis._match(CharCode.Equals)\n\t\t\t\t\t\t\t? TokenType.GtEq\n\t\t\t\t\t\t\t: TokenType.Gt,\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CharCode.Ampersand:\n\t\t\t\t\tif (this._match(CharCode.Ampersand)) {\n\t\t\t\t\t\tthis._addToken(TokenType.And);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._error(hintDidYouMean(\"&&\"));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CharCode.Pipe:\n\t\t\t\t\tif (this._match(CharCode.Pipe)) {\n\t\t\t\t\t\tthis._addToken(TokenType.Or);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._error(hintDidYouMean(\"||\"));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\t// TODO@ulugbekna: 1) rewrite using a regex 2) reconsider what characters are considered whitespace, including unicode, nbsp, etc.\n\t\t\t\tcase CharCode.Space:\n\t\t\t\tcase CharCode.CarriageReturn:\n\t\t\t\tcase CharCode.Tab:\n\t\t\t\tcase CharCode.LineFeed:\n\t\t\t\tcase CharCode.NoBreakSpace: // &nbsp\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthis._string();\n\t\t\t}\n\t\t}\n\n\t\tthis._start = this._current;\n\t\tthis._addToken(TokenType.EOF);\n\n\t\treturn Array.from(this._tokens);\n\t}\n\n\tprivate _match(expected: number): boolean {\n\t\tif (this._isAtEnd()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this._input.charCodeAt(this._current) !== expected) {\n\t\t\treturn false;\n\t\t}\n\t\tthis._current++;\n\t\treturn true;\n\t}\n\n\tprivate _advance(): number {\n\t\treturn this._input.charCodeAt(this._current++);\n\t}\n\n\tprivate _peek(): number {\n\t\treturn this._isAtEnd()\n\t\t\t? CharCode.Null\n\t\t\t: this._input.charCodeAt(this._current);\n\t}\n\n\tprivate _addToken(type: TokenTypeWithoutLexeme) {\n\t\tthis._tokens.push({ type, offset: this._start });\n\t}\n\n\tprivate _error(additional?: string) {\n\t\tconst offset = this._start;\n\t\tconst lexeme = this._input.substring(this._start, this._current);\n\t\tconst errToken: Token = {\n\t\t\ttype: TokenType.Error,\n\t\t\toffset: this._start,\n\t\t\tlexeme,\n\t\t};\n\t\tthis._errors.push({ offset, lexeme, additionalInfo: additional });\n\t\tthis._tokens.push(errToken);\n\t}\n\n\t// u - unicode, y - sticky // TODO@ulugbekna: we accept double quotes as part of the string rather than as a delimiter (to preserve old parser's behavior)\n\tprivate stringRe = /[a-zA-Z0-9_<>\\-./\\\\:*?+[\\]^,#@;\"%$\\p{L}-]+/uy;\n\tprivate _string() {\n\t\tthis.stringRe.lastIndex = this._start;\n\t\tconst match = this.stringRe.exec(this._input);\n\t\tif (match) {\n\t\t\tthis._current = this._start + match[0].length;\n\t\t\tconst lexeme = this._input.substring(this._start, this._current);\n\t\t\tconst keyword = Scanner._keywords.get(lexeme);\n\t\t\tif (keyword) {\n\t\t\t\tthis._addToken(keyword);\n\t\t\t} else {\n\t\t\t\tthis._tokens.push({\n\t\t\t\t\ttype: TokenType.Str,\n\t\t\t\t\tlexeme,\n\t\t\t\t\toffset: this._start,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\t// captures the lexeme without the leading and trailing '\n\tprivate _quotedString() {\n\t\twhile (this._peek() !== CharCode.SingleQuote && !this._isAtEnd()) {\n\t\t\t// TODO@ulugbekna: add support for escaping ' ?\n\t\t\tthis._advance();\n\t\t}\n\n\t\tif (this._isAtEnd()) {\n\t\t\tthis._error(hintDidYouForgetToOpenOrCloseQuote);\n\t\t\treturn;\n\t\t}\n\n\t\t// consume the closing '\n\t\tthis._advance();\n\n\t\tthis._tokens.push({\n\t\t\ttype: TokenType.QuotedStr,\n\t\t\tlexeme: this._input.substring(this._start + 1, this._current - 1),\n\t\t\toffset: this._start + 1,\n\t\t});\n\t}\n\n\t/*\n\t * Lexing a regex expression: /.../[igsmyu]*\n\t * Based on https://github.com/microsoft/TypeScript/blob/9247ef115e617805983740ba795d7a8164babf89/src/compiler/scanner.ts#L2129-L2181\n\t *\n\t * Note that we want slashes within a regex to be escaped, e.g., /file:\\\\/\\\\/\\\\// should match `file:///`\n\t */\n\tprivate _regex() {\n\t\tlet p = this._current;\n\n\t\tlet inEscape = false;\n\t\tlet inCharacterClass = false;\n\t\twhile (true) {\n\t\t\tif (p >= this._input.length) {\n\t\t\t\tthis._current = p;\n\t\t\t\tthis._error(hintDidYouForgetToEscapeSlash);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst ch = this._input.charCodeAt(p);\n\n\t\t\tif (inEscape) {\n\t\t\t\t// parsing an escape character\n\t\t\t\tinEscape = false;\n\t\t\t} else if (ch === CharCode.Slash && !inCharacterClass) {\n\t\t\t\t// end of regex\n\t\t\t\tp++;\n\t\t\t\tbreak;\n\t\t\t} else if (ch === CharCode.OpenSquareBracket) {\n\t\t\t\tinCharacterClass = true;\n\t\t\t} else if (ch === CharCode.Backslash) {\n\t\t\t\tinEscape = true;\n\t\t\t} else if (ch === CharCode.CloseSquareBracket) {\n\t\t\t\tinCharacterClass = false;\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\n\t\t// Consume flags // TODO@ulugbekna: use regex instead\n\t\twhile (\n\t\t\tp < this._input.length &&\n\t\t\tScanner._regexFlags.has(this._input.charCodeAt(p))\n\t\t) {\n\t\t\tp++;\n\t\t}\n\n\t\tthis._current = p;\n\n\t\tconst lexeme = this._input.substring(this._start, this._current);\n\t\tthis._tokens.push({\n\t\t\ttype: TokenType.RegexStr,\n\t\t\tlexeme,\n\t\t\toffset: this._start,\n\t\t});\n\t}\n\n\tprivate _isAtEnd() {\n\t\treturn this._current >= this._input.length;\n\t}\n}\n"],
  "mappings": "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",
  "names": ["TokenType"]
}
