{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/instantiation/common/instantiation.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { DisposableStore } from \"../../../base/common/lifecycle.js\";\nimport type * as descriptors from \"./descriptors.js\";\nimport type { ServiceCollection } from \"./serviceCollection.js\";\n\n// ------ internal util\n\nexport namespace _util {\n\texport const serviceIds = new Map<string, ServiceIdentifier<any>>();\n\n\texport const DI_TARGET = \"$di$target\";\n\texport const DI_DEPENDENCIES = \"$di$dependencies\";\n\n\texport function getServiceDependencies(\n\t\tctor: any,\n\t): { id: ServiceIdentifier<any>; index: number }[] {\n\t\treturn ctor[DI_DEPENDENCIES] || [];\n\t}\n}\n\n// --- interfaces ------\n\nexport type BrandedService = { _serviceBrand: undefined };\n\nexport interface IConstructorSignature<T, Args extends any[] = []> {\n\tnew <Services extends BrandedService[]>(...args: [...Args, ...Services]): T;\n}\n\nexport interface ServicesAccessor {\n\tget<T>(id: ServiceIdentifier<T>): T;\n}\n\nexport const IInstantiationService = createDecorator<IInstantiationService>(\n\t\"instantiationService\",\n);\n\n/**\n * Given a list of arguments as a tuple, attempt to extract the leading, non-service arguments\n * to their own tuple.\n */\nexport type GetLeadingNonServiceArgs<TArgs extends any[]> = TArgs extends []\n\t? []\n\t: TArgs extends [...infer TFirst, BrandedService]\n\t\t? GetLeadingNonServiceArgs<TFirst>\n\t\t: TArgs;\n\nexport interface IInstantiationService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Synchronously creates an instance that is denoted by the descriptor\n\t */\n\tcreateInstance<T>(descriptor: descriptors.SyncDescriptor0<T>): T;\n\tcreateInstance<\n\t\tCtor extends new (...args: any[]) => any,\n\t\tR extends InstanceType<Ctor>,\n\t>(\n\t\tctor: Ctor,\n\t\t...args: GetLeadingNonServiceArgs<ConstructorParameters<Ctor>>\n\t): R;\n\n\t/**\n\t * Calls a function with a service accessor.\n\t */\n\tinvokeFunction<R, TS extends any[] = []>(\n\t\tfn: (accessor: ServicesAccessor, ...args: TS) => R,\n\t\t...args: TS\n\t): R;\n\n\t/**\n\t * Creates a child of this service which inherits all current services\n\t * and adds/overwrites the given services.\n\t *\n\t * NOTE that the returned child is `disposable` and should be disposed when not used\n\t * anymore. This will also dispose all the services that this service has created.\n\t */\n\tcreateChild(\n\t\tservices: ServiceCollection,\n\t\tstore?: DisposableStore,\n\t): IInstantiationService;\n\n\t/**\n\t * Disposes this instantiation service.\n\t *\n\t * - Will dispose all services that this instantiation service has created.\n\t * - Will dispose all its children but not its parent.\n\t * - Will NOT dispose services-instances that this service has been created with\n\t * - Will NOT dispose consumer-instances this service has created\n\t */\n\tdispose(): void;\n}\n\n/**\n * Identifies a service of type `T`.\n */\nexport interface ServiceIdentifier<T> {\n\t(...args: any[]): void;\n\ttype: T;\n}\n\nfunction storeServiceDependency(\n\tid: Function,\n\ttarget: Function,\n\tindex: number,\n): void {\n\tif ((target as any)[_util.DI_TARGET] === target) {\n\t\t(target as any)[_util.DI_DEPENDENCIES].push({ id, index });\n\t} else {\n\t\t(target as any)[_util.DI_DEPENDENCIES] = [{ id, index }];\n\t\t(target as any)[_util.DI_TARGET] = target;\n\t}\n}\n\n/**\n * The *only* valid way to create a {{ServiceIdentifier}}.\n */\nexport function createDecorator<T>(serviceId: string): ServiceIdentifier<T> {\n\tif (_util.serviceIds.has(serviceId)) {\n\t\treturn _util.serviceIds.get(serviceId)!;\n\t}\n\n\tconst id = <any>((target: Function, key: string, index: number): any => {\n\t\tif (arguments.length !== 3) {\n\t\t\tthrow new Error(\n\t\t\t\t\"@IServiceName-decorator can only be used to decorate a parameter\",\n\t\t\t);\n\t\t}\n\t\tstoreServiceDependency(id, target, index);\n\t});\n\n\tid.toString = () => serviceId;\n\n\t_util.serviceIds.set(serviceId, id);\n\treturn id;\n}\n\nexport function refineServiceDecorator<T1, T extends T1>(\n\tserviceIdentifier: ServiceIdentifier<T1>,\n): ServiceIdentifier<T> {\n\treturn <ServiceIdentifier<T>>serviceIdentifier;\n}\n"],
  "mappings": ";;AAWO,IAAU;AAAA,CAAV,CAAUA,WAAV;AACC,EAAMA,OAAA,aAAa,oBAAI,IAAoC;AAE3D,EAAMA,OAAA,YAAY;AAClB,EAAMA,OAAA,kBAAkB;AAExB,WAAS,uBACf,MACkD;AAClD,WAAO,KAAKA,OAAA,eAAe,KAAK,CAAC;AAAA,EAClC;AAJO,EAAAA,OAAS;AAAA;AAAA,GANA;AAyBV,MAAM,wBAAwB;AAAA,EACpC;AACD;AAkEA,SAAS,uBACR,IACA,QACA,OACO;AACP,MAAK,OAAe,MAAM,SAAS,MAAM,QAAQ;AAChD,IAAC,OAAe,MAAM,eAAe,EAAE,KAAK,EAAE,IAAI,MAAM,CAAC;AAAA,EAC1D,OAAO;AACN,IAAC,OAAe,MAAM,eAAe,IAAI,CAAC,EAAE,IAAI,MAAM,CAAC;AACvD,IAAC,OAAe,MAAM,SAAS,IAAI;AAAA,EACpC;AACD;AAXS;AAgBF,SAAS,gBAAmB,WAAyC;AAC3E,MAAI,MAAM,WAAW,IAAI,SAAS,GAAG;AACpC,WAAO,MAAM,WAAW,IAAI,SAAS;AAAA,EACtC;AAEA,QAAM,KAAW,wBAAC,QAAkB,KAAa,UAAuB;AACvE,QAAI,UAAU,WAAW,GAAG;AAC3B,YAAM,IAAI;AAAA,QACT;AAAA,MACD;AAAA,IACD;AACA,2BAAuB,IAAI,QAAQ,KAAK;AAAA,EACzC,GAPiB;AASjB,KAAG,WAAW,MAAM;AAEpB,QAAM,WAAW,IAAI,WAAW,EAAE;AAClC,SAAO;AACR;AAlBgB;AAoBT,SAAS,uBACf,mBACuB;AACvB,SAA6B;AAC9B;AAJgB;",
  "names": ["_util"]
}
