var s=class{constructor(e,n){this.key=e;this.data=n}incoming=new Map;outgoing=new Map},r=class{constructor(e){this._hashFn=e}_nodes=new Map;roots(){let e=[];for(let n of this._nodes.values())n.outgoing.size===0&&e.push(n);return e}insertEdge(e,n){let o=this.lookupOrInsertNode(e),t=this.lookupOrInsertNode(n);o.outgoing.set(t.key,t),t.incoming.set(o.key,o)}removeNode(e){let n=this._hashFn(e);this._nodes.delete(n);for(let o of this._nodes.values())o.outgoing.delete(n),o.incoming.delete(n)}lookupOrInsertNode(e){let n=this._hashFn(e),o=this._nodes.get(n);return o||(o=new s(n,e),this._nodes.set(n,o)),o}lookup(e){return this._nodes.get(this._hashFn(e))}isEmpty(){return this._nodes.size===0}toString(){let e=[];for(let[n,o]of this._nodes)e.push(`${n}
	(-> incoming)[${[...o.incoming.keys()].join(", ")}]
	(outgoing ->)[${[...o.outgoing.keys()].join(",")}]
`);return e.join(`
`)}findCycleSlow(){for(let[e,n]of this._nodes){let o=new Set([e]),t=this._findCycle(n,o);if(t)return t}}_findCycle(e,n){for(let[o,t]of e.outgoing){if(n.has(o))return[...n,o].join(" -> ");n.add(o);let i=this._findCycle(t,n);if(i)return i;n.delete(o)}}};export{r as Graph,s as Node};
