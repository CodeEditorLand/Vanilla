class r{constructor(n,o){this.key=n;this.data=o}incoming=new Map;outgoing=new Map}class d{constructor(n){this._hashFn=n}_nodes=new Map;roots(){const n=[];for(const o of this._nodes.values())o.outgoing.size===0&&n.push(o);return n}insertEdge(n,o){const e=this.lookupOrInsertNode(n),t=this.lookupOrInsertNode(o);e.outgoing.set(t.key,t),t.incoming.set(e.key,e)}removeNode(n){const o=this._hashFn(n);this._nodes.delete(o);for(const e of this._nodes.values())e.outgoing.delete(o),e.incoming.delete(o)}lookupOrInsertNode(n){const o=this._hashFn(n);let e=this._nodes.get(o);return e||(e=new r(o,n),this._nodes.set(o,e)),e}lookup(n){return this._nodes.get(this._hashFn(n))}isEmpty(){return this._nodes.size===0}toString(){const n=[];for(const[o,e]of this._nodes)n.push(`${o}
	(-> incoming)[${[...e.incoming.keys()].join(", ")}]
	(outgoing ->)[${[...e.outgoing.keys()].join(",")}]
`);return n.join(`
`)}findCycleSlow(){for(const[n,o]of this._nodes){const e=new Set([n]),t=this._findCycle(o,e);if(t)return t}}_findCycle(n,o){for(const[e,t]of n.outgoing){if(o.has(e))return[...o,e].join(" -> ");o.add(e);const s=this._findCycle(t,o);if(s)return s;o.delete(e)}}}export{d as Graph,r as Node};
