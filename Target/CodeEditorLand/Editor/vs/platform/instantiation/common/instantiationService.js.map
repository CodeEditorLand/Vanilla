{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/instantiation/common/instantiationService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { GlobalIdleValue } from '../../../base/common/async.js';\nimport { Event } from '../../../base/common/event.js';\nimport { illegalState } from '../../../base/common/errors.js';\nimport { DisposableStore, dispose, IDisposable, isDisposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { SyncDescriptor, SyncDescriptor0 } from './descriptors.js';\nimport { Graph } from './graph.js';\nimport { GetLeadingNonServiceArgs, IInstantiationService, ServiceIdentifier, ServicesAccessor, _util } from './instantiation.js';\nimport { ServiceCollection } from './serviceCollection.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\n\n// TRACING\nconst _enableAllTracing = false\n\t// || \"TRUE\" // DO NOT CHECK IN!\n\t;\n\nclass CyclicDependencyError extends Error {\n\tconstructor(graph: Graph<any>) {\n\t\tsuper('cyclic dependency between services');\n\t\tthis.message = graph.findCycleSlow() ?? `UNABLE to detect cycle, dumping graph: \\n${graph.toString()}`;\n\t}\n}\n\nexport class InstantiationService implements IInstantiationService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\treadonly _globalGraph?: Graph<string>;\n\tprivate _globalGraphImplicitDependency?: string;\n\n\tprivate _isDisposed = false;\n\tprivate readonly _servicesToMaybeDispose = new Set<any>();\n\tprivate readonly _children = new Set<InstantiationService>();\n\n\tconstructor(\n\t\tprivate readonly _services: ServiceCollection = new ServiceCollection(),\n\t\tprivate readonly _strict: boolean = false,\n\t\tprivate readonly _parent?: InstantiationService,\n\t\tprivate readonly _enableTracing: boolean = _enableAllTracing\n\t) {\n\n\t\tthis._services.set(IInstantiationService, this);\n\t\tthis._globalGraph = _enableTracing ? _parent?._globalGraph ?? new Graph(e => e) : undefined;\n\t}\n\n\tdispose(): void {\n\t\tif (!this._isDisposed) {\n\t\t\tthis._isDisposed = true;\n\t\t\t// dispose all child services\n\t\t\tdispose(this._children);\n\t\t\tthis._children.clear();\n\n\t\t\t// dispose all services created by this service\n\t\t\tfor (const candidate of this._servicesToMaybeDispose) {\n\t\t\t\tif (isDisposable(candidate)) {\n\t\t\t\t\tcandidate.dispose();\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._servicesToMaybeDispose.clear();\n\t\t}\n\t}\n\n\tprivate _throwIfDisposed(): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new Error('InstantiationService has been disposed');\n\t\t}\n\t}\n\n\tcreateChild(services: ServiceCollection, store?: DisposableStore): IInstantiationService {\n\t\tthis._throwIfDisposed();\n\n\t\tconst that = this;\n\t\tconst result = new class extends InstantiationService {\n\t\t\toverride dispose(): void {\n\t\t\t\tthat._children.delete(result);\n\t\t\t\tsuper.dispose();\n\t\t\t}\n\t\t}(services, this._strict, this, this._enableTracing);\n\t\tthis._children.add(result);\n\n\t\tstore?.add(result);\n\t\treturn result;\n\t}\n\n\tinvokeFunction<R, TS extends any[] = []>(fn: (accessor: ServicesAccessor, ...args: TS) => R, ...args: TS): R {\n\t\tthis._throwIfDisposed();\n\n\t\tconst _trace = Trace.traceInvocation(this._enableTracing, fn);\n\t\tlet _done = false;\n\t\ttry {\n\t\t\tconst accessor: ServicesAccessor = {\n\t\t\t\tget: <T>(id: ServiceIdentifier<T>) => {\n\n\t\t\t\t\tif (_done) {\n\t\t\t\t\t\tthrow illegalState('service accessor is only valid during the invocation of its target method');\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = this._getOrCreateServiceInstance(id, _trace);\n\t\t\t\t\tif (!result) {\n\t\t\t\t\t\tthrow new Error(`[invokeFunction] unknown service '${id}'`);\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn fn(accessor, ...args);\n\t\t} finally {\n\t\t\t_done = true;\n\t\t\t_trace.stop();\n\t\t}\n\t}\n\n\tcreateInstance<T>(descriptor: SyncDescriptor0<T>): T;\n\tcreateInstance<Ctor extends new (...args: any[]) => any, R extends InstanceType<Ctor>>(ctor: Ctor, ...args: GetLeadingNonServiceArgs<ConstructorParameters<Ctor>>): R;\n\tcreateInstance(ctorOrDescriptor: any | SyncDescriptor<any>, ...rest: any[]): any {\n\t\tthis._throwIfDisposed();\n\n\t\tlet _trace: Trace;\n\t\tlet result: any;\n\t\tif (ctorOrDescriptor instanceof SyncDescriptor) {\n\t\t\t_trace = Trace.traceCreation(this._enableTracing, ctorOrDescriptor.ctor);\n\t\t\tresult = this._createInstance(ctorOrDescriptor.ctor, ctorOrDescriptor.staticArguments.concat(rest), _trace);\n\t\t} else {\n\t\t\t_trace = Trace.traceCreation(this._enableTracing, ctorOrDescriptor);\n\t\t\tresult = this._createInstance(ctorOrDescriptor, rest, _trace);\n\t\t}\n\t\t_trace.stop();\n\t\treturn result;\n\t}\n\n\tprivate _createInstance<T>(ctor: any, args: any[] = [], _trace: Trace): T {\n\n\t\t// arguments defined by service decorators\n\t\tconst serviceDependencies = _util.getServiceDependencies(ctor).sort((a, b) => a.index - b.index);\n\t\tconst serviceArgs: any[] = [];\n\t\tfor (const dependency of serviceDependencies) {\n\t\t\tconst service = this._getOrCreateServiceInstance(dependency.id, _trace);\n\t\t\tif (!service) {\n\t\t\t\tthis._throwIfStrict(`[createInstance] ${ctor.name} depends on UNKNOWN service ${dependency.id}.`, false);\n\t\t\t}\n\t\t\tserviceArgs.push(service);\n\t\t}\n\n\t\tconst firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : args.length;\n\n\t\t// check for argument mismatches, adjust static args if needed\n\t\tif (args.length !== firstServiceArgPos) {\n\t\t\tconsole.trace(`[createInstance] First service dependency of ${ctor.name} at position ${firstServiceArgPos + 1} conflicts with ${args.length} static arguments`);\n\n\t\t\tconst delta = firstServiceArgPos - args.length;\n\t\t\tif (delta > 0) {\n\t\t\t\targs = args.concat(new Array(delta));\n\t\t\t} else {\n\t\t\t\targs = args.slice(0, firstServiceArgPos);\n\t\t\t}\n\t\t}\n\n\t\t// now create the instance\n\t\treturn Reflect.construct<any, T>(ctor, args.concat(serviceArgs));\n\t}\n\n\tprivate _setCreatedServiceInstance<T>(id: ServiceIdentifier<T>, instance: T): void {\n\t\tif (this._services.get(id) instanceof SyncDescriptor) {\n\t\t\tthis._services.set(id, instance);\n\t\t} else if (this._parent) {\n\t\t\tthis._parent._setCreatedServiceInstance(id, instance);\n\t\t} else {\n\t\t\tthrow new Error('illegalState - setting UNKNOWN service instance');\n\t\t}\n\t}\n\n\tprivate _getServiceInstanceOrDescriptor<T>(id: ServiceIdentifier<T>): T | SyncDescriptor<T> {\n\t\tconst instanceOrDesc = this._services.get(id);\n\t\tif (!instanceOrDesc && this._parent) {\n\t\t\treturn this._parent._getServiceInstanceOrDescriptor(id);\n\t\t} else {\n\t\t\treturn instanceOrDesc;\n\t\t}\n\t}\n\n\tprotected _getOrCreateServiceInstance<T>(id: ServiceIdentifier<T>, _trace: Trace): T {\n\t\tif (this._globalGraph && this._globalGraphImplicitDependency) {\n\t\t\tthis._globalGraph.insertEdge(this._globalGraphImplicitDependency, String(id));\n\t\t}\n\t\tconst thing = this._getServiceInstanceOrDescriptor(id);\n\t\tif (thing instanceof SyncDescriptor) {\n\t\t\treturn this._safeCreateAndCacheServiceInstance(id, thing, _trace.branch(id, true));\n\t\t} else {\n\t\t\t_trace.branch(id, false);\n\t\t\treturn thing;\n\t\t}\n\t}\n\n\tprivate readonly _activeInstantiations = new Set<ServiceIdentifier<any>>();\n\n\n\tprivate _safeCreateAndCacheServiceInstance<T>(id: ServiceIdentifier<T>, desc: SyncDescriptor<T>, _trace: Trace): T {\n\t\tif (this._activeInstantiations.has(id)) {\n\t\t\tthrow new Error(`illegal state - RECURSIVELY instantiating service '${id}'`);\n\t\t}\n\t\tthis._activeInstantiations.add(id);\n\t\ttry {\n\t\t\treturn this._createAndCacheServiceInstance(id, desc, _trace);\n\t\t} finally {\n\t\t\tthis._activeInstantiations.delete(id);\n\t\t}\n\t}\n\n\tprivate _createAndCacheServiceInstance<T>(id: ServiceIdentifier<T>, desc: SyncDescriptor<T>, _trace: Trace): T {\n\n\t\ttype Triple = { id: ServiceIdentifier<any>; desc: SyncDescriptor<any>; _trace: Trace };\n\t\tconst graph = new Graph<Triple>(data => data.id.toString());\n\n\t\tlet cycleCount = 0;\n\t\tconst stack = [{ id, desc, _trace }];\n\t\tconst seen = new Set<string>();\n\t\twhile (stack.length) {\n\t\t\tconst item = stack.pop()!;\n\n\t\t\tif (seen.has(String(item.id))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tseen.add(String(item.id));\n\n\t\t\tgraph.lookupOrInsertNode(item);\n\n\t\t\t// a weak but working heuristic for cycle checks\n\t\t\tif (cycleCount++ > 1000) {\n\t\t\t\tthrow new CyclicDependencyError(graph);\n\t\t\t}\n\n\t\t\t// check all dependencies for existence and if they need to be created first\n\t\t\tfor (const dependency of _util.getServiceDependencies(item.desc.ctor)) {\n\n\t\t\t\tconst instanceOrDesc = this._getServiceInstanceOrDescriptor(dependency.id);\n\t\t\t\tif (!instanceOrDesc) {\n\t\t\t\t\tthis._throwIfStrict(`[createInstance] ${id} depends on ${dependency.id} which is NOT registered.`, true);\n\t\t\t\t}\n\n\t\t\t\t// take note of all service dependencies\n\t\t\t\tthis._globalGraph?.insertEdge(String(item.id), String(dependency.id));\n\n\t\t\t\tif (instanceOrDesc instanceof SyncDescriptor) {\n\t\t\t\t\tconst d = { id: dependency.id, desc: instanceOrDesc, _trace: item._trace.branch(dependency.id, true) };\n\t\t\t\t\tgraph.insertEdge(item, d);\n\t\t\t\t\tstack.push(d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile (true) {\n\t\t\tconst roots = graph.roots();\n\n\t\t\t// if there is no more roots but still\n\t\t\t// nodes in the graph we have a cycle\n\t\t\tif (roots.length === 0) {\n\t\t\t\tif (!graph.isEmpty()) {\n\t\t\t\t\tthrow new CyclicDependencyError(graph);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (const { data } of roots) {\n\t\t\t\t// Repeat the check for this still being a service sync descriptor. That's because\n\t\t\t\t// instantiating a dependency might have side-effect and recursively trigger instantiation\n\t\t\t\t// so that some dependencies are now fullfilled already.\n\t\t\t\tconst instanceOrDesc = this._getServiceInstanceOrDescriptor(data.id);\n\t\t\t\tif (instanceOrDesc instanceof SyncDescriptor) {\n\t\t\t\t\t// create instance and overwrite the service collections\n\t\t\t\t\tconst instance = this._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);\n\t\t\t\t\tthis._setCreatedServiceInstance(data.id, instance);\n\t\t\t\t}\n\t\t\t\tgraph.removeNode(data);\n\t\t\t}\n\t\t}\n\t\treturn <T>this._getServiceInstanceOrDescriptor(id);\n\t}\n\n\tprivate _createServiceInstanceWithOwner<T>(id: ServiceIdentifier<T>, ctor: any, args: any[] = [], supportsDelayedInstantiation: boolean, _trace: Trace): T {\n\t\tif (this._services.get(id) instanceof SyncDescriptor) {\n\t\t\treturn this._createServiceInstance(id, ctor, args, supportsDelayedInstantiation, _trace, this._servicesToMaybeDispose);\n\t\t} else if (this._parent) {\n\t\t\treturn this._parent._createServiceInstanceWithOwner(id, ctor, args, supportsDelayedInstantiation, _trace);\n\t\t} else {\n\t\t\tthrow new Error(`illegalState - creating UNKNOWN service instance ${ctor.name}`);\n\t\t}\n\t}\n\n\tprivate _createServiceInstance<T>(id: ServiceIdentifier<T>, ctor: any, args: any[] = [], supportsDelayedInstantiation: boolean, _trace: Trace, disposeBucket: Set<any>): T {\n\t\tif (!supportsDelayedInstantiation) {\n\t\t\t// eager instantiation\n\t\t\tconst result = this._createInstance<T>(ctor, args, _trace);\n\t\t\tdisposeBucket.add(result);\n\t\t\treturn result;\n\n\t\t} else {\n\t\t\tconst child = new InstantiationService(undefined, this._strict, this, this._enableTracing);\n\t\t\tchild._globalGraphImplicitDependency = String(id);\n\n\t\t\ttype EaryListenerData = {\n\t\t\t\tlistener: Parameters<Event<any>>;\n\t\t\t\tdisposable?: IDisposable;\n\t\t\t};\n\n\t\t\t// Return a proxy object that's backed by an idle value. That\n\t\t\t// strategy is to instantiate services in our idle time or when actually\n\t\t\t// needed but not when injected into a consumer\n\n\t\t\t// return \"empty events\" when the service isn't instantiated yet\n\t\t\tconst earlyListeners = new Map<string, LinkedList<EaryListenerData>>();\n\n\t\t\tconst idle = new GlobalIdleValue<any>(() => {\n\t\t\t\tconst result = child._createInstance<T>(ctor, args, _trace);\n\n\t\t\t\t// early listeners that we kept are now being subscribed to\n\t\t\t\t// the real service\n\t\t\t\tfor (const [key, values] of earlyListeners) {\n\t\t\t\t\tconst candidate = <Event<any>>(<any>result)[key];\n\t\t\t\t\tif (typeof candidate === 'function') {\n\t\t\t\t\t\tfor (const value of values) {\n\t\t\t\t\t\t\tvalue.disposable = candidate.apply(result, value.listener);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tearlyListeners.clear();\n\t\t\t\tdisposeBucket.add(result);\n\t\t\t\treturn result;\n\t\t\t});\n\t\t\treturn <T>new Proxy(Object.create(null), {\n\t\t\t\tget(target: any, key: PropertyKey): any {\n\n\t\t\t\t\tif (!idle.isInitialized) {\n\t\t\t\t\t\t// looks like an event\n\t\t\t\t\t\tif (typeof key === 'string' && (key.startsWith('onDid') || key.startsWith('onWill'))) {\n\t\t\t\t\t\t\tlet list = earlyListeners.get(key);\n\t\t\t\t\t\t\tif (!list) {\n\t\t\t\t\t\t\t\tlist = new LinkedList();\n\t\t\t\t\t\t\t\tearlyListeners.set(key, list);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst event: Event<any> = (callback, thisArg, disposables) => {\n\t\t\t\t\t\t\t\tif (idle.isInitialized) {\n\t\t\t\t\t\t\t\t\treturn idle.value[key](callback, thisArg, disposables);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tconst entry: EaryListenerData = { listener: [callback, thisArg, disposables], disposable: undefined };\n\t\t\t\t\t\t\t\t\tconst rm = list.push(entry);\n\t\t\t\t\t\t\t\t\tconst result = toDisposable(() => {\n\t\t\t\t\t\t\t\t\t\trm();\n\t\t\t\t\t\t\t\t\t\tentry.disposable?.dispose();\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\treturn event;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// value already exists\n\t\t\t\t\tif (key in target) {\n\t\t\t\t\t\treturn target[key];\n\t\t\t\t\t}\n\n\t\t\t\t\t// create value\n\t\t\t\t\tconst obj = idle.value;\n\t\t\t\t\tlet prop = obj[key];\n\t\t\t\t\tif (typeof prop !== 'function') {\n\t\t\t\t\t\treturn prop;\n\t\t\t\t\t}\n\t\t\t\t\tprop = prop.bind(obj);\n\t\t\t\t\ttarget[key] = prop;\n\t\t\t\t\treturn prop;\n\t\t\t\t},\n\t\t\t\tset(_target: T, p: PropertyKey, value: any): boolean {\n\t\t\t\t\tidle.value[p] = value;\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\tgetPrototypeOf(_target: T) {\n\t\t\t\t\treturn ctor.prototype;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate _throwIfStrict(msg: string, printWarning: boolean): void {\n\t\tif (printWarning) {\n\t\t\tconsole.warn(msg);\n\t\t}\n\t\tif (this._strict) {\n\t\t\tthrow new Error(msg);\n\t\t}\n\t}\n}\n\n//#region -- tracing ---\n\nconst enum TraceType {\n\tNone = 0,\n\tCreation = 1,\n\tInvocation = 2,\n\tBranch = 3,\n}\n\nexport class Trace {\n\n\tstatic all = new Set<string>();\n\n\tprivate static readonly _None = new class extends Trace {\n\t\tconstructor() { super(TraceType.None, null); }\n\t\toverride stop() { }\n\t\toverride branch() { return this; }\n\t};\n\n\tstatic traceInvocation(_enableTracing: boolean, ctor: any): Trace {\n\t\treturn !_enableTracing ? Trace._None : new Trace(TraceType.Invocation, ctor.name || new Error().stack!.split('\\n').slice(3, 4).join('\\n'));\n\t}\n\n\tstatic traceCreation(_enableTracing: boolean, ctor: any): Trace {\n\t\treturn !_enableTracing ? Trace._None : new Trace(TraceType.Creation, ctor.name);\n\t}\n\n\tprivate static _totals: number = 0;\n\tprivate readonly _start: number = Date.now();\n\tprivate readonly _dep: [ServiceIdentifier<any>, boolean, Trace?][] = [];\n\n\tprivate constructor(\n\t\treadonly type: TraceType,\n\t\treadonly name: string | null\n\t) { }\n\n\tbranch(id: ServiceIdentifier<any>, first: boolean): Trace {\n\t\tconst child = new Trace(TraceType.Branch, id.toString());\n\t\tthis._dep.push([id, first, child]);\n\t\treturn child;\n\t}\n\n\tstop() {\n\t\tconst dur = Date.now() - this._start;\n\t\tTrace._totals += dur;\n\n\t\tlet causedCreation = false;\n\n\t\tfunction printChild(n: number, trace: Trace) {\n\t\t\tconst res: string[] = [];\n\t\t\tconst prefix = new Array(n + 1).join('\\t');\n\t\t\tfor (const [id, first, child] of trace._dep) {\n\t\t\t\tif (first && child) {\n\t\t\t\t\tcausedCreation = true;\n\t\t\t\t\tres.push(`${prefix}CREATES -> ${id}`);\n\t\t\t\t\tconst nested = printChild(n + 1, child);\n\t\t\t\t\tif (nested) {\n\t\t\t\t\t\tres.push(nested);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tres.push(`${prefix}uses -> ${id}`);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res.join('\\n');\n\t\t}\n\n\t\tconst lines = [\n\t\t\t`${this.type === TraceType.Creation ? 'CREATE' : 'CALL'} ${this.name}`,\n\t\t\t`${printChild(1, this)}`,\n\t\t\t`DONE, took ${dur.toFixed(2)}ms (grand total ${Trace._totals.toFixed(2)}ms)`\n\t\t];\n\n\t\tif (dur > 2 || causedCreation) {\n\t\t\tTrace.all.add(lines.join('\\n'));\n\t\t}\n\t}\n}\n\n//#endregion\n"],
  "mappings": "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",
  "names": ["TraceType"]
}
