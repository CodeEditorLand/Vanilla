{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/instantiation/common/instantiationService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { GlobalIdleValue } from \"../../../base/common/async.js\";\nimport { illegalState } from \"../../../base/common/errors.js\";\nimport type { Event } from \"../../../base/common/event.js\";\nimport {\n\ttype DisposableStore,\n\ttype IDisposable,\n\tdispose,\n\tisDisposable,\n\ttoDisposable,\n} from \"../../../base/common/lifecycle.js\";\nimport { LinkedList } from \"../../../base/common/linkedList.js\";\nimport { SyncDescriptor, type SyncDescriptor0 } from \"./descriptors.js\";\nimport { Graph } from \"./graph.js\";\nimport {\n\ttype GetLeadingNonServiceArgs,\n\tIInstantiationService,\n\ttype ServiceIdentifier,\n\ttype ServicesAccessor,\n\t_util,\n} from \"./instantiation.js\";\nimport { ServiceCollection } from \"./serviceCollection.js\";\n\n// TRACING\nconst _enableAllTracing = false;\n// || \"TRUE\" // DO NOT CHECK IN!\n\nclass CyclicDependencyError extends Error {\n\tconstructor(graph: Graph<any>) {\n\t\tsuper(\"cyclic dependency between services\");\n\t\tthis.message =\n\t\t\tgraph.findCycleSlow() ??\n\t\t\t`UNABLE to detect cycle, dumping graph: \\n${graph.toString()}`;\n\t}\n}\n\nexport class InstantiationService implements IInstantiationService {\n\tdeclare readonly _serviceBrand: undefined;\n\n\treadonly _globalGraph?: Graph<string>;\n\tprivate _globalGraphImplicitDependency?: string;\n\n\tprivate _isDisposed = false;\n\tprivate readonly _servicesToMaybeDispose = new Set<any>();\n\tprivate readonly _children = new Set<InstantiationService>();\n\n\tconstructor(\n\t\tprivate readonly _services: ServiceCollection = new ServiceCollection(),\n\t\tprivate readonly _strict: boolean = false,\n\t\tprivate readonly _parent?: InstantiationService,\n\t\tprivate readonly _enableTracing: boolean = _enableAllTracing,\n\t) {\n\t\tthis._services.set(IInstantiationService, this);\n\t\tthis._globalGraph = _enableTracing\n\t\t\t? (_parent?._globalGraph ?? new Graph((e) => e))\n\t\t\t: undefined;\n\t}\n\n\tdispose(): void {\n\t\tif (!this._isDisposed) {\n\t\t\tthis._isDisposed = true;\n\t\t\t// dispose all child services\n\t\t\tdispose(this._children);\n\t\t\tthis._children.clear();\n\n\t\t\t// dispose all services created by this service\n\t\t\tfor (const candidate of this._servicesToMaybeDispose) {\n\t\t\t\tif (isDisposable(candidate)) {\n\t\t\t\t\tcandidate.dispose();\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._servicesToMaybeDispose.clear();\n\t\t}\n\t}\n\n\tprivate _throwIfDisposed(): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new Error(\"InstantiationService has been disposed\");\n\t\t}\n\t}\n\n\tcreateChild(\n\t\tservices: ServiceCollection,\n\t\tstore?: DisposableStore,\n\t): IInstantiationService {\n\t\tthis._throwIfDisposed();\n\n\t\tconst that = this;\n\t\tconst result = new (class extends InstantiationService {\n\t\t\toverride dispose(): void {\n\t\t\t\tthat._children.delete(result);\n\t\t\t\tsuper.dispose();\n\t\t\t}\n\t\t})(services, this._strict, this, this._enableTracing);\n\t\tthis._children.add(result);\n\n\t\tstore?.add(result);\n\t\treturn result;\n\t}\n\n\tinvokeFunction<R, TS extends any[] = []>(\n\t\tfn: (accessor: ServicesAccessor, ...args: TS) => R,\n\t\t...args: TS\n\t): R {\n\t\tthis._throwIfDisposed();\n\n\t\tconst _trace = Trace.traceInvocation(this._enableTracing, fn);\n\t\tlet _done = false;\n\t\ttry {\n\t\t\tconst accessor: ServicesAccessor = {\n\t\t\t\tget: <T>(id: ServiceIdentifier<T>) => {\n\t\t\t\t\tif (_done) {\n\t\t\t\t\t\tthrow illegalState(\n\t\t\t\t\t\t\t\"service accessor is only valid during the invocation of its target method\",\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = this._getOrCreateServiceInstance(id, _trace);\n\t\t\t\t\tif (!result) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`[invokeFunction] unknown service '${id}'`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn fn(accessor, ...args);\n\t\t} finally {\n\t\t\t_done = true;\n\t\t\t_trace.stop();\n\t\t}\n\t}\n\n\tcreateInstance<T>(descriptor: SyncDescriptor0<T>): T;\n\tcreateInstance<\n\t\tCtor extends new (\n\t\t\t...args: any[]\n\t\t) => any,\n\t\tR extends InstanceType<Ctor>,\n\t>(\n\t\tctor: Ctor,\n\t\t...args: GetLeadingNonServiceArgs<ConstructorParameters<Ctor>>\n\t): R;\n\tcreateInstance(\n\t\tctorOrDescriptor: any | SyncDescriptor<any>,\n\t\t...rest: any[]\n\t): any {\n\t\tthis._throwIfDisposed();\n\n\t\tlet _trace: Trace;\n\t\tlet result: any;\n\t\tif (ctorOrDescriptor instanceof SyncDescriptor) {\n\t\t\t_trace = Trace.traceCreation(\n\t\t\t\tthis._enableTracing,\n\t\t\t\tctorOrDescriptor.ctor,\n\t\t\t);\n\t\t\tresult = this._createInstance(\n\t\t\t\tctorOrDescriptor.ctor,\n\t\t\t\tctorOrDescriptor.staticArguments.concat(rest),\n\t\t\t\t_trace,\n\t\t\t);\n\t\t} else {\n\t\t\t_trace = Trace.traceCreation(this._enableTracing, ctorOrDescriptor);\n\t\t\tresult = this._createInstance(ctorOrDescriptor, rest, _trace);\n\t\t}\n\t\t_trace.stop();\n\t\treturn result;\n\t}\n\n\tprivate _createInstance<T>(ctor: any, args: any[] = [], _trace: Trace): T {\n\t\t// arguments defined by service decorators\n\t\tconst serviceDependencies = _util\n\t\t\t.getServiceDependencies(ctor)\n\t\t\t.sort((a, b) => a.index - b.index);\n\t\tconst serviceArgs: any[] = [];\n\t\tfor (const dependency of serviceDependencies) {\n\t\t\tconst service = this._getOrCreateServiceInstance(\n\t\t\t\tdependency.id,\n\t\t\t\t_trace,\n\t\t\t);\n\t\t\tif (!service) {\n\t\t\t\tthis._throwIfStrict(\n\t\t\t\t\t`[createInstance] ${ctor.name} depends on UNKNOWN service ${dependency.id}.`,\n\t\t\t\t\tfalse,\n\t\t\t\t);\n\t\t\t}\n\t\t\tserviceArgs.push(service);\n\t\t}\n\n\t\tconst firstServiceArgPos =\n\t\t\tserviceDependencies.length > 0\n\t\t\t\t? serviceDependencies[0].index\n\t\t\t\t: args.length;\n\n\t\t// check for argument mismatches, adjust static args if needed\n\t\tif (args.length !== firstServiceArgPos) {\n\t\t\tconsole.trace(\n\t\t\t\t`[createInstance] First service dependency of ${ctor.name} at position ${firstServiceArgPos + 1} conflicts with ${args.length} static arguments`,\n\t\t\t);\n\n\t\t\tconst delta = firstServiceArgPos - args.length;\n\t\t\tif (delta > 0) {\n\t\t\t\targs = args.concat(new Array(delta));\n\t\t\t} else {\n\t\t\t\targs = args.slice(0, firstServiceArgPos);\n\t\t\t}\n\t\t}\n\n\t\t// now create the instance\n\t\treturn Reflect.construct<any, T>(ctor, args.concat(serviceArgs));\n\t}\n\n\tprivate _setCreatedServiceInstance<T>(\n\t\tid: ServiceIdentifier<T>,\n\t\tinstance: T,\n\t): void {\n\t\tif (this._services.get(id) instanceof SyncDescriptor) {\n\t\t\tthis._services.set(id, instance);\n\t\t} else if (this._parent) {\n\t\t\tthis._parent._setCreatedServiceInstance(id, instance);\n\t\t} else {\n\t\t\tthrow new Error(\"illegalState - setting UNKNOWN service instance\");\n\t\t}\n\t}\n\n\tprivate _getServiceInstanceOrDescriptor<T>(\n\t\tid: ServiceIdentifier<T>,\n\t): T | SyncDescriptor<T> {\n\t\tconst instanceOrDesc = this._services.get(id);\n\t\tif (!instanceOrDesc && this._parent) {\n\t\t\treturn this._parent._getServiceInstanceOrDescriptor(id);\n\t\t} else {\n\t\t\treturn instanceOrDesc;\n\t\t}\n\t}\n\n\tprotected _getOrCreateServiceInstance<T>(\n\t\tid: ServiceIdentifier<T>,\n\t\t_trace: Trace,\n\t): T {\n\t\tif (this._globalGraph && this._globalGraphImplicitDependency) {\n\t\t\tthis._globalGraph.insertEdge(\n\t\t\t\tthis._globalGraphImplicitDependency,\n\t\t\t\tString(id),\n\t\t\t);\n\t\t}\n\t\tconst thing = this._getServiceInstanceOrDescriptor(id);\n\t\tif (thing instanceof SyncDescriptor) {\n\t\t\treturn this._safeCreateAndCacheServiceInstance(\n\t\t\t\tid,\n\t\t\t\tthing,\n\t\t\t\t_trace.branch(id, true),\n\t\t\t);\n\t\t} else {\n\t\t\t_trace.branch(id, false);\n\t\t\treturn thing;\n\t\t}\n\t}\n\n\tprivate readonly _activeInstantiations = new Set<ServiceIdentifier<any>>();\n\n\tprivate _safeCreateAndCacheServiceInstance<T>(\n\t\tid: ServiceIdentifier<T>,\n\t\tdesc: SyncDescriptor<T>,\n\t\t_trace: Trace,\n\t): T {\n\t\tif (this._activeInstantiations.has(id)) {\n\t\t\tthrow new Error(\n\t\t\t\t`illegal state - RECURSIVELY instantiating service '${id}'`,\n\t\t\t);\n\t\t}\n\t\tthis._activeInstantiations.add(id);\n\t\ttry {\n\t\t\treturn this._createAndCacheServiceInstance(id, desc, _trace);\n\t\t} finally {\n\t\t\tthis._activeInstantiations.delete(id);\n\t\t}\n\t}\n\n\tprivate _createAndCacheServiceInstance<T>(\n\t\tid: ServiceIdentifier<T>,\n\t\tdesc: SyncDescriptor<T>,\n\t\t_trace: Trace,\n\t): T {\n\t\ttype Triple = {\n\t\t\tid: ServiceIdentifier<any>;\n\t\t\tdesc: SyncDescriptor<any>;\n\t\t\t_trace: Trace;\n\t\t};\n\t\tconst graph = new Graph<Triple>((data) => data.id.toString());\n\n\t\tlet cycleCount = 0;\n\t\tconst stack = [{ id, desc, _trace }];\n\t\tconst seen = new Set<string>();\n\t\twhile (stack.length) {\n\t\t\tconst item = stack.pop()!;\n\n\t\t\tif (seen.has(String(item.id))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tseen.add(String(item.id));\n\n\t\t\tgraph.lookupOrInsertNode(item);\n\n\t\t\t// a weak but working heuristic for cycle checks\n\t\t\tif (cycleCount++ > 1000) {\n\t\t\t\tthrow new CyclicDependencyError(graph);\n\t\t\t}\n\n\t\t\t// check all dependencies for existence and if they need to be created first\n\t\t\tfor (const dependency of _util.getServiceDependencies(\n\t\t\t\titem.desc.ctor,\n\t\t\t)) {\n\t\t\t\tconst instanceOrDesc = this._getServiceInstanceOrDescriptor(\n\t\t\t\t\tdependency.id,\n\t\t\t\t);\n\t\t\t\tif (!instanceOrDesc) {\n\t\t\t\t\tthis._throwIfStrict(\n\t\t\t\t\t\t`[createInstance] ${id} depends on ${dependency.id} which is NOT registered.`,\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// take note of all service dependencies\n\t\t\t\tthis._globalGraph?.insertEdge(\n\t\t\t\t\tString(item.id),\n\t\t\t\t\tString(dependency.id),\n\t\t\t\t);\n\n\t\t\t\tif (instanceOrDesc instanceof SyncDescriptor) {\n\t\t\t\t\tconst d = {\n\t\t\t\t\t\tid: dependency.id,\n\t\t\t\t\t\tdesc: instanceOrDesc,\n\t\t\t\t\t\t_trace: item._trace.branch(dependency.id, true),\n\t\t\t\t\t};\n\t\t\t\t\tgraph.insertEdge(item, d);\n\t\t\t\t\tstack.push(d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile (true) {\n\t\t\tconst roots = graph.roots();\n\n\t\t\t// if there is no more roots but still\n\t\t\t// nodes in the graph we have a cycle\n\t\t\tif (roots.length === 0) {\n\t\t\t\tif (!graph.isEmpty()) {\n\t\t\t\t\tthrow new CyclicDependencyError(graph);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (const { data } of roots) {\n\t\t\t\t// Repeat the check for this still being a service sync descriptor. That's because\n\t\t\t\t// instantiating a dependency might have side-effect and recursively trigger instantiation\n\t\t\t\t// so that some dependencies are now fullfilled already.\n\t\t\t\tconst instanceOrDesc = this._getServiceInstanceOrDescriptor(\n\t\t\t\t\tdata.id,\n\t\t\t\t);\n\t\t\t\tif (instanceOrDesc instanceof SyncDescriptor) {\n\t\t\t\t\t// create instance and overwrite the service collections\n\t\t\t\t\tconst instance = this._createServiceInstanceWithOwner(\n\t\t\t\t\t\tdata.id,\n\t\t\t\t\t\tdata.desc.ctor,\n\t\t\t\t\t\tdata.desc.staticArguments,\n\t\t\t\t\t\tdata.desc.supportsDelayedInstantiation,\n\t\t\t\t\t\tdata._trace,\n\t\t\t\t\t);\n\t\t\t\t\tthis._setCreatedServiceInstance(data.id, instance);\n\t\t\t\t}\n\t\t\t\tgraph.removeNode(data);\n\t\t\t}\n\t\t}\n\t\treturn <T>this._getServiceInstanceOrDescriptor(id);\n\t}\n\n\tprivate _createServiceInstanceWithOwner<T>(\n\t\tid: ServiceIdentifier<T>,\n\t\tctor: any,\n\t\targs: any[] = [],\n\t\tsupportsDelayedInstantiation: boolean,\n\t\t_trace: Trace,\n\t): T {\n\t\tif (this._services.get(id) instanceof SyncDescriptor) {\n\t\t\treturn this._createServiceInstance(\n\t\t\t\tid,\n\t\t\t\tctor,\n\t\t\t\targs,\n\t\t\t\tsupportsDelayedInstantiation,\n\t\t\t\t_trace,\n\t\t\t\tthis._servicesToMaybeDispose,\n\t\t\t);\n\t\t} else if (this._parent) {\n\t\t\treturn this._parent._createServiceInstanceWithOwner(\n\t\t\t\tid,\n\t\t\t\tctor,\n\t\t\t\targs,\n\t\t\t\tsupportsDelayedInstantiation,\n\t\t\t\t_trace,\n\t\t\t);\n\t\t} else {\n\t\t\tthrow new Error(\n\t\t\t\t`illegalState - creating UNKNOWN service instance ${ctor.name}`,\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate _createServiceInstance<T>(\n\t\tid: ServiceIdentifier<T>,\n\t\tctor: any,\n\t\targs: any[] = [],\n\t\tsupportsDelayedInstantiation: boolean,\n\t\t_trace: Trace,\n\t\tdisposeBucket: Set<any>,\n\t): T {\n\t\tif (supportsDelayedInstantiation) {\n\t\t\tconst child = new InstantiationService(\n\t\t\t\tundefined,\n\t\t\t\tthis._strict,\n\t\t\t\tthis,\n\t\t\t\tthis._enableTracing,\n\t\t\t);\n\t\t\tchild._globalGraphImplicitDependency = String(id);\n\n\t\t\ttype EaryListenerData = {\n\t\t\t\tlistener: Parameters<Event<any>>;\n\t\t\t\tdisposable?: IDisposable;\n\t\t\t};\n\n\t\t\t// Return a proxy object that's backed by an idle value. That\n\t\t\t// strategy is to instantiate services in our idle time or when actually\n\t\t\t// needed but not when injected into a consumer\n\n\t\t\t// return \"empty events\" when the service isn't instantiated yet\n\t\t\tconst earlyListeners = new Map<\n\t\t\t\tstring,\n\t\t\t\tLinkedList<EaryListenerData>\n\t\t\t>();\n\n\t\t\tconst idle = new GlobalIdleValue<any>(() => {\n\t\t\t\tconst result = child._createInstance<T>(ctor, args, _trace);\n\n\t\t\t\t// early listeners that we kept are now being subscribed to\n\t\t\t\t// the real service\n\t\t\t\tfor (const [key, values] of earlyListeners) {\n\t\t\t\t\tconst candidate = <Event<any>>(<any>result)[key];\n\t\t\t\t\tif (typeof candidate === \"function\") {\n\t\t\t\t\t\tfor (const value of values) {\n\t\t\t\t\t\t\tvalue.disposable = candidate.apply(\n\t\t\t\t\t\t\t\tresult,\n\t\t\t\t\t\t\t\tvalue.listener,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tearlyListeners.clear();\n\t\t\t\tdisposeBucket.add(result);\n\t\t\t\treturn result;\n\t\t\t});\n\t\t\treturn <T>new Proxy(Object.create(null), {\n\t\t\t\tget(target: any, key: PropertyKey): any {\n\t\t\t\t\tif (!idle.isInitialized) {\n\t\t\t\t\t\t// looks like an event\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\ttypeof key === \"string\" &&\n\t\t\t\t\t\t\t(key.startsWith(\"onDid\") ||\n\t\t\t\t\t\t\t\tkey.startsWith(\"onWill\"))\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tlet list = earlyListeners.get(key);\n\t\t\t\t\t\t\tif (!list) {\n\t\t\t\t\t\t\t\tlist = new LinkedList();\n\t\t\t\t\t\t\t\tearlyListeners.set(key, list);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst event: Event<any> = (\n\t\t\t\t\t\t\t\tcallback,\n\t\t\t\t\t\t\t\tthisArg,\n\t\t\t\t\t\t\t\tdisposables,\n\t\t\t\t\t\t\t) => {\n\t\t\t\t\t\t\t\tif (idle.isInitialized) {\n\t\t\t\t\t\t\t\t\treturn idle.value[key](\n\t\t\t\t\t\t\t\t\t\tcallback,\n\t\t\t\t\t\t\t\t\t\tthisArg,\n\t\t\t\t\t\t\t\t\t\tdisposables,\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tconst entry: EaryListenerData = {\n\t\t\t\t\t\t\t\t\t\tlistener: [\n\t\t\t\t\t\t\t\t\t\t\tcallback,\n\t\t\t\t\t\t\t\t\t\t\tthisArg,\n\t\t\t\t\t\t\t\t\t\t\tdisposables,\n\t\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t\tdisposable: undefined,\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tconst rm = list.push(entry);\n\t\t\t\t\t\t\t\t\tconst result = toDisposable(() => {\n\t\t\t\t\t\t\t\t\t\trm();\n\t\t\t\t\t\t\t\t\t\tentry.disposable?.dispose();\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\treturn event;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// value already exists\n\t\t\t\t\tif (key in target) {\n\t\t\t\t\t\treturn target[key];\n\t\t\t\t\t}\n\n\t\t\t\t\t// create value\n\t\t\t\t\tconst obj = idle.value;\n\t\t\t\t\tlet prop = obj[key];\n\t\t\t\t\tif (typeof prop !== \"function\") {\n\t\t\t\t\t\treturn prop;\n\t\t\t\t\t}\n\t\t\t\t\tprop = prop.bind(obj);\n\t\t\t\t\ttarget[key] = prop;\n\t\t\t\t\treturn prop;\n\t\t\t\t},\n\t\t\t\tset(_target: T, p: PropertyKey, value: any): boolean {\n\t\t\t\t\tidle.value[p] = value;\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\tgetPrototypeOf(_target: T) {\n\t\t\t\t\treturn ctor.prototype;\n\t\t\t\t},\n\t\t\t});\n\t\t} else {\n\t\t\t// eager instantiation\n\t\t\tconst result = this._createInstance<T>(ctor, args, _trace);\n\t\t\tdisposeBucket.add(result);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tprivate _throwIfStrict(msg: string, printWarning: boolean): void {\n\t\tif (printWarning) {\n\t\t\tconsole.warn(msg);\n\t\t}\n\t\tif (this._strict) {\n\t\t\tthrow new Error(msg);\n\t\t}\n\t}\n}\n\n//#region -- tracing ---\n\nenum TraceType {\n\tNone = 0,\n\tCreation = 1,\n\tInvocation = 2,\n\tBranch = 3,\n}\n\nexport class Trace {\n\tstatic all = new Set<string>();\n\n\tprivate static readonly _None = new (class extends Trace {\n\t\tconstructor() {\n\t\t\tsuper(TraceType.None, null);\n\t\t}\n\t\toverride stop() {}\n\t\toverride branch() {\n\t\t\treturn this;\n\t\t}\n\t})();\n\n\tstatic traceInvocation(_enableTracing: boolean, ctor: any): Trace {\n\t\treturn _enableTracing\n\t\t\t? new Trace(\n\t\t\t\t\tTraceType.Invocation,\n\t\t\t\t\tctor.name ||\n\t\t\t\t\t\tnew Error().stack!.split(\"\\n\").slice(3, 4).join(\"\\n\"),\n\t\t\t\t)\n\t\t\t: Trace._None;\n\t}\n\n\tstatic traceCreation(_enableTracing: boolean, ctor: any): Trace {\n\t\treturn _enableTracing\n\t\t\t? new Trace(TraceType.Creation, ctor.name)\n\t\t\t: Trace._None;\n\t}\n\n\tprivate static _totals = 0;\n\tprivate readonly _start: number = Date.now();\n\tprivate readonly _dep: [ServiceIdentifier<any>, boolean, Trace?][] = [];\n\n\tprivate constructor(\n\t\treadonly type: TraceType,\n\t\treadonly name: string | null,\n\t) {}\n\n\tbranch(id: ServiceIdentifier<any>, first: boolean): Trace {\n\t\tconst child = new Trace(TraceType.Branch, id.toString());\n\t\tthis._dep.push([id, first, child]);\n\t\treturn child;\n\t}\n\n\tstop() {\n\t\tconst dur = Date.now() - this._start;\n\t\tTrace._totals += dur;\n\n\t\tlet causedCreation = false;\n\n\t\tfunction printChild(n: number, trace: Trace) {\n\t\t\tconst res: string[] = [];\n\t\t\tconst prefix = new Array(n + 1).join(\"\\t\");\n\t\t\tfor (const [id, first, child] of trace._dep) {\n\t\t\t\tif (first && child) {\n\t\t\t\t\tcausedCreation = true;\n\t\t\t\t\tres.push(`${prefix}CREATES -> ${id}`);\n\t\t\t\t\tconst nested = printChild(n + 1, child);\n\t\t\t\t\tif (nested) {\n\t\t\t\t\t\tres.push(nested);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tres.push(`${prefix}uses -> ${id}`);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res.join(\"\\n\");\n\t\t}\n\n\t\tconst lines = [\n\t\t\t`${this.type === TraceType.Creation ? \"CREATE\" : \"CALL\"} ${this.name}`,\n\t\t\t`${printChild(1, this)}`,\n\t\t\t`DONE, took ${dur.toFixed(2)}ms (grand total ${Trace._totals.toFixed(2)}ms)`,\n\t\t];\n\n\t\tif (dur > 2 || causedCreation) {\n\t\t\tTrace.all.add(lines.join(\"\\n\"));\n\t\t}\n\t}\n}\n\n//#endregion\n"],
  "mappings": "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",
  "names": ["TraceType"]
}
