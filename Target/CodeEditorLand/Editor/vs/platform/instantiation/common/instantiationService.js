import{GlobalIdleValue as D}from"../../../base/common/async.js";import"../../../base/common/event.js";import{illegalState as C}from"../../../base/common/errors.js";import{dispose as E,isDisposable as N,toDisposable as A}from"../../../base/common/lifecycle.js";import{SyncDescriptor as u}from"./descriptors.js";import{Graph as w}from"./graph.js";import{IInstantiationService as $,_util as T}from"./instantiation.js";import{ServiceCollection as O}from"./serviceCollection.js";import{LinkedList as G}from"../../../base/common/linkedList.js";const x=!1;class b extends Error{constructor(e){super("cyclic dependency between services"),this.message=e.findCycleSlow()??`UNABLE to detect cycle, dumping graph: 
${e.toString()}`}}class y{constructor(e=new O,t=!1,r,n=x){this._services=e;this._strict=t;this._parent=r;this._enableTracing=n;this._services.set($,this),this._globalGraph=n?r?._globalGraph??new w(l=>l):void 0}_globalGraph;_globalGraphImplicitDependency;_isDisposed=!1;_servicesToMaybeDispose=new Set;_children=new Set;dispose(){if(!this._isDisposed){this._isDisposed=!0,E(this._children),this._children.clear();for(const e of this._servicesToMaybeDispose)N(e)&&e.dispose();this._servicesToMaybeDispose.clear()}}_throwIfDisposed(){if(this._isDisposed)throw new Error("InstantiationService has been disposed")}createChild(e,t){this._throwIfDisposed();const r=this,n=new class extends y{dispose(){r._children.delete(n),super.dispose()}}(e,this._strict,this,this._enableTracing);return this._children.add(n),t?.add(n),n}invokeFunction(e,...t){this._throwIfDisposed();const r=p.traceInvocation(this._enableTracing,e);let n=!1;try{return e({get:d=>{if(n)throw C("service accessor is only valid during the invocation of its target method");const s=this._getOrCreateServiceInstance(d,r);if(!s)throw new Error(`[invokeFunction] unknown service '${d}'`);return s}},...t)}finally{n=!0,r.stop()}}createInstance(e,...t){this._throwIfDisposed();let r,n;return e instanceof u?(r=p.traceCreation(this._enableTracing,e.ctor),n=this._createInstance(e.ctor,e.staticArguments.concat(t),r)):(r=p.traceCreation(this._enableTracing,e),n=this._createInstance(e,t,r)),r.stop(),n}_createInstance(e,t=[],r){const n=T.getServiceDependencies(e).sort((s,i)=>s.index-i.index),l=[];for(const s of n){const i=this._getOrCreateServiceInstance(s.id,r);i||this._throwIfStrict(`[createInstance] ${e.name} depends on UNKNOWN service ${s.id}.`,!1),l.push(i)}const d=n.length>0?n[0].index:t.length;if(t.length!==d){const s=d-t.length;s>0?t=t.concat(new Array(s)):t=t.slice(0,d)}return Reflect.construct(e,t.concat(l))}_setCreatedServiceInstance(e,t){if(this._services.get(e)instanceof u)this._services.set(e,t);else if(this._parent)this._parent._setCreatedServiceInstance(e,t);else throw new Error("illegalState - setting UNKNOWN service instance")}_getServiceInstanceOrDescriptor(e){const t=this._services.get(e);return!t&&this._parent?this._parent._getServiceInstanceOrDescriptor(e):t}_getOrCreateServiceInstance(e,t){this._globalGraph&&this._globalGraphImplicitDependency&&this._globalGraph.insertEdge(this._globalGraphImplicitDependency,String(e));const r=this._getServiceInstanceOrDescriptor(e);return r instanceof u?this._safeCreateAndCacheServiceInstance(e,r,t.branch(e,!0)):(t.branch(e,!1),r)}_activeInstantiations=new Set;_safeCreateAndCacheServiceInstance(e,t,r){if(this._activeInstantiations.has(e))throw new Error(`illegal state - RECURSIVELY instantiating service '${e}'`);this._activeInstantiations.add(e);try{return this._createAndCacheServiceInstance(e,t,r)}finally{this._activeInstantiations.delete(e)}}_createAndCacheServiceInstance(e,t,r){const n=new w(i=>i.id.toString());let l=0;const d=[{id:e,desc:t,_trace:r}],s=new Set;for(;d.length;){const i=d.pop();if(!s.has(String(i.id))){if(s.add(String(i.id)),n.lookupOrInsertNode(i),l++>1e3)throw new b(n);for(const a of T.getServiceDependencies(i.desc.ctor)){const o=this._getServiceInstanceOrDescriptor(a.id);if(o||this._throwIfStrict(`[createInstance] ${e} depends on ${a.id} which is NOT registered.`,!0),this._globalGraph?.insertEdge(String(i.id),String(a.id)),o instanceof u){const c={id:a.id,desc:o,_trace:i._trace.branch(a.id,!0)};n.insertEdge(i,c),d.push(c)}}}}for(;;){const i=n.roots();if(i.length===0){if(!n.isEmpty())throw new b(n);break}for(const{data:a}of i){if(this._getServiceInstanceOrDescriptor(a.id)instanceof u){const c=this._createServiceInstanceWithOwner(a.id,a.desc.ctor,a.desc.staticArguments,a.desc.supportsDelayedInstantiation,a._trace);this._setCreatedServiceInstance(a.id,c)}n.removeNode(a)}}return this._getServiceInstanceOrDescriptor(e)}_createServiceInstanceWithOwner(e,t,r=[],n,l){if(this._services.get(e)instanceof u)return this._createServiceInstance(e,t,r,n,l,this._servicesToMaybeDispose);if(this._parent)return this._parent._createServiceInstanceWithOwner(e,t,r,n,l);throw new Error(`illegalState - creating UNKNOWN service instance ${t.name}`)}_createServiceInstance(e,t,r=[],n,l,d){if(n){const s=new y(void 0,this._strict,this,this._enableTracing);s._globalGraphImplicitDependency=String(e);const i=new Map,a=new D(()=>{const o=s._createInstance(t,r,l);for(const[c,h]of i){const v=o[c];if(typeof v=="function")for(const f of h)f.disposable=v.apply(o,f.listener)}return i.clear(),d.add(o),o});return new Proxy(Object.create(null),{get(o,c){if(!a.isInitialized&&typeof c=="string"&&(c.startsWith("onDid")||c.startsWith("onWill"))){let f=i.get(c);return f||(f=new G,i.set(c,f)),(_,S,g)=>{if(a.isInitialized)return a.value[c](_,S,g);{const I={listener:[_,S,g],disposable:void 0},m=f.push(I);return A(()=>{m(),I.disposable?.dispose()})}}}if(c in o)return o[c];const h=a.value;let v=h[c];return typeof v!="function"||(v=v.bind(h),o[c]=v),v},set(o,c,h){return a.value[c]=h,!0},getPrototypeOf(o){return t.prototype}})}else{const s=this._createInstance(t,r,l);return d.add(s),s}}_throwIfStrict(e,t){if(this._strict)throw new Error(e)}}var L=(n=>(n[n.None=0]="None",n[n.Creation=1]="Creation",n[n.Invocation=2]="Invocation",n[n.Branch=3]="Branch",n))(L||{});class p{constructor(e,t){this.type=e;this.name=t}static all=new Set;static _None=new class extends p{constructor(){super(0,null)}stop(){}branch(){return this}};static traceInvocation(e,t){return e?new p(2,t.name||new Error().stack.split(`
`).slice(3,4).join(`
`)):p._None}static traceCreation(e,t){return e?new p(1,t.name):p._None}static _totals=0;_start=Date.now();_dep=[];branch(e,t){const r=new p(3,e.toString());return this._dep.push([e,t,r]),r}stop(){const e=Date.now()-this._start;p._totals+=e;let t=!1;function r(l,d){const s=[],i=new Array(l+1).join("	");for(const[a,o,c]of d._dep)if(o&&c){t=!0,s.push(`${i}CREATES -> ${a}`);const h=r(l+1,c);h&&s.push(h)}else s.push(`${i}uses -> ${a}`);return s.join(`
`)}const n=[`${this.type===1?"CREATE":"CALL"} ${this.name}`,`${r(1,this)}`,`DONE, took ${e.toFixed(2)}ms (grand total ${p._totals.toFixed(2)}ms)`];(e>2||t)&&p.all.add(n.join(`
`))}}export{y as InstantiationService,p as Trace};
