{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/commands/common/commands.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, type Event } from \"../../../base/common/event.js\";\nimport { Iterable } from \"../../../base/common/iterator.js\";\nimport type { IJSONSchema } from \"../../../base/common/jsonSchema.js\";\nimport {\n\ttype IDisposable,\n\ttoDisposable,\n} from \"../../../base/common/lifecycle.js\";\nimport { LinkedList } from \"../../../base/common/linkedList.js\";\nimport {\n\ttype TypeConstraint,\n\tvalidateConstraints,\n} from \"../../../base/common/types.js\";\nimport type { ILocalizedString } from \"../../action/common/action.js\";\nimport {\n\ttype ServicesAccessor,\n\tcreateDecorator,\n} from \"../../instantiation/common/instantiation.js\";\n\nexport const ICommandService =\n\tcreateDecorator<ICommandService>(\"commandService\");\n\nexport interface ICommandEvent {\n\tcommandId: string;\n\targs: any[];\n}\n\nexport interface ICommandService {\n\treadonly _serviceBrand: undefined;\n\tonWillExecuteCommand: Event<ICommandEvent>;\n\tonDidExecuteCommand: Event<ICommandEvent>;\n\texecuteCommand<T = any>(\n\t\tcommandId: string,\n\t\t...args: any[]\n\t): Promise<T | undefined>;\n}\n\nexport type ICommandsMap = Map<string, ICommand>;\n\nexport interface ICommandHandler {\n\t(accessor: ServicesAccessor, ...args: any[]): void;\n}\n\nexport interface ICommand {\n\tid: string;\n\thandler: ICommandHandler;\n\tmetadata?: ICommandMetadata | null;\n}\n\nexport interface ICommandMetadata {\n\t/**\n\t * NOTE: Please use an ILocalizedString. string is in the type for backcompat for now.\n\t * A short summary of what the command does. This will be used in:\n\t * - API commands\n\t * - when showing keybindings that have no other UX\n\t * - when searching for commands in the Command Palette\n\t */\n\treadonly description: ILocalizedString | string;\n\treadonly args?: ReadonlyArray<{\n\t\treadonly name: string;\n\t\treadonly isOptional?: boolean;\n\t\treadonly description?: string;\n\t\treadonly constraint?: TypeConstraint;\n\t\treadonly schema?: IJSONSchema;\n\t}>;\n\treadonly returns?: string;\n}\n\nexport interface ICommandRegistry {\n\tonDidRegisterCommand: Event<string>;\n\tregisterCommand(id: string, command: ICommandHandler): IDisposable;\n\tregisterCommand(command: ICommand): IDisposable;\n\tregisterCommandAlias(oldId: string, newId: string): IDisposable;\n\tgetCommand(id: string): ICommand | undefined;\n\tgetCommands(): ICommandsMap;\n}\n\nexport const CommandsRegistry: ICommandRegistry = new (class\n\timplements ICommandRegistry\n{\n\tprivate readonly _commands = new Map<string, LinkedList<ICommand>>();\n\n\tprivate readonly _onDidRegisterCommand = new Emitter<string>();\n\treadonly onDidRegisterCommand: Event<string> =\n\t\tthis._onDidRegisterCommand.event;\n\n\tregisterCommand(\n\t\tidOrCommand: string | ICommand,\n\t\thandler?: ICommandHandler,\n\t): IDisposable {\n\t\tif (!idOrCommand) {\n\t\t\tthrow new Error(`invalid command`);\n\t\t}\n\n\t\tif (typeof idOrCommand === \"string\") {\n\t\t\tif (!handler) {\n\t\t\t\tthrow new Error(`invalid command`);\n\t\t\t}\n\t\t\treturn this.registerCommand({ id: idOrCommand, handler });\n\t\t}\n\n\t\t// add argument validation if rich command metadata is provided\n\t\tif (idOrCommand.metadata && Array.isArray(idOrCommand.metadata.args)) {\n\t\t\tconst constraints: Array<TypeConstraint | undefined> = [];\n\t\t\tfor (const arg of idOrCommand.metadata.args) {\n\t\t\t\tconstraints.push(arg.constraint);\n\t\t\t}\n\t\t\tconst actualHandler = idOrCommand.handler;\n\t\t\tidOrCommand.handler = (accessor, ...args: any[]) => {\n\t\t\t\tvalidateConstraints(args, constraints);\n\t\t\t\treturn actualHandler(accessor, ...args);\n\t\t\t};\n\t\t}\n\n\t\t// find a place to store the command\n\t\tconst { id } = idOrCommand;\n\n\t\tlet commands = this._commands.get(id);\n\t\tif (!commands) {\n\t\t\tcommands = new LinkedList<ICommand>();\n\t\t\tthis._commands.set(id, commands);\n\t\t}\n\n\t\tconst removeFn = commands.unshift(idOrCommand);\n\n\t\tconst ret = toDisposable(() => {\n\t\t\tremoveFn();\n\t\t\tconst command = this._commands.get(id);\n\t\t\tif (command?.isEmpty()) {\n\t\t\t\tthis._commands.delete(id);\n\t\t\t}\n\t\t});\n\n\t\t// tell the world about this command\n\t\tthis._onDidRegisterCommand.fire(id);\n\n\t\treturn ret;\n\t}\n\n\tregisterCommandAlias(oldId: string, newId: string): IDisposable {\n\t\treturn CommandsRegistry.registerCommand(oldId, (accessor, ...args) =>\n\t\t\taccessor.get(ICommandService).executeCommand(newId, ...args),\n\t\t);\n\t}\n\n\tgetCommand(id: string): ICommand | undefined {\n\t\tconst list = this._commands.get(id);\n\t\tif (!list || list.isEmpty()) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn Iterable.first(list);\n\t}\n\n\tgetCommands(): ICommandsMap {\n\t\tconst result = new Map<string, ICommand>();\n\t\tfor (const key of this._commands.keys()) {\n\t\t\tconst command = this.getCommand(key);\n\t\t\tif (command) {\n\t\t\t\tresult.set(key, command);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n})();\n\nCommandsRegistry.registerCommand(\"noop\", () => {});\n"],
  "mappings": "AAKA,SAAS,eAA2B;AACpC,SAAS,gBAAgB;AAEzB;AAAA,EAEC;AAAA,OACM;AACP,SAAS,kBAAkB;AAC3B;AAAA,EAEC;AAAA,OACM;AAEP;AAAA,EAEC;AAAA,OACM;AAEA,MAAM,kBACZ,gBAAiC,gBAAgB;AAyD3C,MAAM,mBAAqC,IAAK,MAEvD;AAAA,EACkB,YAAY,oBAAI,IAAkC;AAAA,EAElD,wBAAwB,IAAI,QAAgB;AAAA,EACpD,uBACR,KAAK,sBAAsB;AAAA,EAE5B,gBACC,aACA,SACc;AACd,QAAI,CAAC,aAAa;AACjB,YAAM,IAAI,MAAM,iBAAiB;AAAA,IAClC;AAEA,QAAI,OAAO,gBAAgB,UAAU;AACpC,UAAI,CAAC,SAAS;AACb,cAAM,IAAI,MAAM,iBAAiB;AAAA,MAClC;AACA,aAAO,KAAK,gBAAgB,EAAE,IAAI,aAAa,QAAQ,CAAC;AAAA,IACzD;AAGA,QAAI,YAAY,YAAY,MAAM,QAAQ,YAAY,SAAS,IAAI,GAAG;AACrE,YAAM,cAAiD,CAAC;AACxD,iBAAW,OAAO,YAAY,SAAS,MAAM;AAC5C,oBAAY,KAAK,IAAI,UAAU;AAAA,MAChC;AACA,YAAM,gBAAgB,YAAY;AAClC,kBAAY,UAAU,CAAC,aAAa,SAAgB;AACnD,4BAAoB,MAAM,WAAW;AACrC,eAAO,cAAc,UAAU,GAAG,IAAI;AAAA,MACvC;AAAA,IACD;AAGA,UAAM,EAAE,GAAG,IAAI;AAEf,QAAI,WAAW,KAAK,UAAU,IAAI,EAAE;AACpC,QAAI,CAAC,UAAU;AACd,iBAAW,IAAI,WAAqB;AACpC,WAAK,UAAU,IAAI,IAAI,QAAQ;AAAA,IAChC;AAEA,UAAM,WAAW,SAAS,QAAQ,WAAW;AAE7C,UAAM,MAAM,aAAa,MAAM;AAC9B,eAAS;AACT,YAAM,UAAU,KAAK,UAAU,IAAI,EAAE;AACrC,UAAI,SAAS,QAAQ,GAAG;AACvB,aAAK,UAAU,OAAO,EAAE;AAAA,MACzB;AAAA,IACD,CAAC;AAGD,SAAK,sBAAsB,KAAK,EAAE;AAElC,WAAO;AAAA,EACR;AAAA,EAEA,qBAAqB,OAAe,OAA4B;AAC/D,WAAO,iBAAiB;AAAA,MAAgB;AAAA,MAAO,CAAC,aAAa,SAC5D,SAAS,IAAI,eAAe,EAAE,eAAe,OAAO,GAAG,IAAI;AAAA,IAC5D;AAAA,EACD;AAAA,EAEA,WAAW,IAAkC;AAC5C,UAAM,OAAO,KAAK,UAAU,IAAI,EAAE;AAClC,QAAI,CAAC,QAAQ,KAAK,QAAQ,GAAG;AAC5B,aAAO;AAAA,IACR;AACA,WAAO,SAAS,MAAM,IAAI;AAAA,EAC3B;AAAA,EAEA,cAA4B;AAC3B,UAAM,SAAS,oBAAI,IAAsB;AACzC,eAAW,OAAO,KAAK,UAAU,KAAK,GAAG;AACxC,YAAM,UAAU,KAAK,WAAW,GAAG;AACnC,UAAI,SAAS;AACZ,eAAO,IAAI,KAAK,OAAO;AAAA,MACxB;AAAA,IACD;AACA,WAAO;AAAA,EACR;AACD,EAAG;AAEH,iBAAiB,gBAAgB,QAAQ,MAAM;AAAC,CAAC;",
  "names": []
}
