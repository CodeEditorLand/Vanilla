import{timeout as S}from"../../../../vs/base/common/async.js";import{CancellationTokenSource as D}from"../../../../vs/base/common/cancellation.js";import{Disposable as w,DisposableStore as R,MutableDisposable as E}from"../../../../vs/base/common/lifecycle.js";import{isFunction as O}from"../../../../vs/base/common/types.js";import"../../../../vs/platform/quickinput/common/quickAccess.js";import"../../../../vs/platform/quickinput/common/quickInput.js";var F=(s=>(s[s.NO_ACTION=0]="NO_ACTION",s[s.CLOSE_PICKER=1]="CLOSE_PICKER",s[s.REFRESH_PICKER=2]="REFRESH_PICKER",s[s.REMOVE_ITEM=3]="REMOVE_ITEM",s))(F||{});function g(p){const P=p;return Array.isArray(P.items)}function x(p){const P=p;return!!P.picks&&P.additionalPicks instanceof Promise}class Y extends w{constructor(e,I){super();this.prefix=e;this.options=I}provide(e,I,s){const l=new R;e.canAcceptInBackground=!!this.options?.canAcceptInBackground,e.matchOnLabel=e.matchOnDescription=e.matchOnDetail=e.sortByLabel=!1;let T;const C=l.add(new E),y=async()=>{const o=C.value=new R;T?.dispose(!0),e.busy=!1,T=new D(I);const t=T.token;let r=e.value.substring(this.prefix.length);this.options?.shouldSkipTrimPickFilter||(r=r.trim());const c=this._getPicks(r,o,t,s),d=(i,u)=>{let n,a;if(g(i)?(n=i.items,a=i.active):n=i,n.length===0){if(u)return!1;(r.length>0||e.hideInput)&&this.options?.noResultsPick&&(O(this.options.noResultsPick)?n=[this.options.noResultsPick(r)]:n=[this.options.noResultsPick])}return e.items=n,a&&(e.activeItems=[a]),!0},f=async i=>{let u=!1,n=!1;await Promise.all([(async()=>{typeof i.mergeDelay=="number"&&(await S(i.mergeDelay),t.isCancellationRequested)||n||(u=d(i.picks,!0))})(),(async()=>{e.busy=!0;try{const a=await i.additionalPicks;if(t.isCancellationRequested)return;let k,b;g(i.picks)?(k=i.picks.items,b=i.picks.active):k=i.picks;let m,v;if(g(a)?(m=a.items,v=a.active):m=a,m.length>0||!u){let Q;if(!b&&!v){const A=e.activeItems[0];A&&k.indexOf(A)!==-1&&(Q=A)}d({items:[...k,...m],active:b||v||Q})}}finally{t.isCancellationRequested||(e.busy=!1),n=!0}})()])};if(c!==null)if(x(c))await f(c);else if(!(c instanceof Promise))d(c);else{e.busy=!0;try{const i=await c;if(t.isCancellationRequested)return;x(i)?await f(i):d(i)}finally{t.isCancellationRequested||(e.busy=!1)}}};l.add(e.onDidChangeValue(()=>y())),y(),l.add(e.onDidAccept(o=>{if(s?.handleAccept){o.inBackground||e.hide(),s.handleAccept?.(e.activeItems[0]);return}const[t]=e.selectedItems;typeof t?.accept=="function"&&(o.inBackground||e.hide(),t.accept(e.keyMods,o))}));const h=async(o,t)=>{if(typeof t.trigger!="function")return;const r=t.buttons?.indexOf(o)??-1;if(r>=0){const c=t.trigger(r,e.keyMods),d=typeof c=="number"?c:await c;if(I.isCancellationRequested)return;switch(d){case 0:break;case 1:e.hide();break;case 2:y();break;case 3:{const f=e.items.indexOf(t);if(f!==-1){const i=e.items.slice(),u=i.splice(f,1),n=e.activeItems.filter(k=>k!==u[0]),a=e.keepScrollPosition;e.keepScrollPosition=!0,e.items=i,n&&(e.activeItems=n),e.keepScrollPosition=a}break}}}};return l.add(e.onDidTriggerItemButton(({button:o,item:t})=>h(o,t))),l.add(e.onDidTriggerSeparatorButton(({button:o,separator:t})=>h(o,t))),l}}export{Y as PickerQuickAccessProvider,F as TriggerAction};
