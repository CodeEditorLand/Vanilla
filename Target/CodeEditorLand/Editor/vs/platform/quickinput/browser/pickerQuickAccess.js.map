{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/quickinput/browser/pickerQuickAccess.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { timeout } from \"../../../base/common/async.js\";\nimport {\n\ttype CancellationToken,\n\tCancellationTokenSource,\n} from \"../../../base/common/cancellation.js\";\nimport {\n\tDisposable,\n\tDisposableStore,\n\ttype IDisposable,\n\tMutableDisposable,\n} from \"../../../base/common/lifecycle.js\";\nimport { isFunction } from \"../../../base/common/types.js\";\nimport type {\n\tIQuickAccessProvider,\n\tIQuickAccessProviderRunOptions,\n} from \"../common/quickAccess.js\";\nimport type {\n\tIKeyMods,\n\tIQuickInputButton,\n\tIQuickPick,\n\tIQuickPickDidAcceptEvent,\n\tIQuickPickItem,\n\tIQuickPickSeparator,\n} from \"../common/quickInput.js\";\n\nexport enum TriggerAction {\n\t/**\n\t * Do nothing after the button was clicked.\n\t */\n\tNO_ACTION = 0,\n\n\t/**\n\t * Close the picker.\n\t */\n\tCLOSE_PICKER = 1,\n\n\t/**\n\t * Update the results of the picker.\n\t */\n\tREFRESH_PICKER = 2,\n\n\t/**\n\t * Remove the item from the picker.\n\t */\n\tREMOVE_ITEM = 3,\n}\n\nexport interface IPickerQuickAccessItem extends IQuickPickItem {\n\t/**\n\t * A method that will be executed when the pick item is accepted from\n\t * the picker. The picker will close automatically before running this.\n\t *\n\t * @param keyMods the state of modifier keys when the item was accepted.\n\t * @param event the underlying event that caused the accept to trigger.\n\t */\n\taccept?(keyMods: IKeyMods, event: IQuickPickDidAcceptEvent): void;\n\n\t/**\n\t * A method that will be executed when a button of the pick item was\n\t * clicked on.\n\t *\n\t * @param buttonIndex index of the button of the item that\n\t * was clicked.\n\t *\n\t * @param the state of modifier keys when the button was triggered.\n\t *\n\t * @returns a value that indicates what should happen after the trigger\n\t * which can be a `Promise` for long running operations.\n\t */\n\ttrigger?(\n\t\tbuttonIndex: number,\n\t\tkeyMods: IKeyMods,\n\t): TriggerAction | Promise<TriggerAction>;\n}\n\nexport interface IPickerQuickAccessSeparator extends IQuickPickSeparator {\n\t/**\n\t * A method that will be executed when a button of the pick item was\n\t * clicked on.\n\t *\n\t * @param buttonIndex index of the button of the item that\n\t * was clicked.\n\t *\n\t * @param the state of modifier keys when the button was triggered.\n\t *\n\t * @returns a value that indicates what should happen after the trigger\n\t * which can be a `Promise` for long running operations.\n\t */\n\ttrigger?(\n\t\tbuttonIndex: number,\n\t\tkeyMods: IKeyMods,\n\t): TriggerAction | Promise<TriggerAction>;\n}\n\nexport interface IPickerQuickAccessProviderOptions<\n\tT extends IPickerQuickAccessItem,\n> {\n\t/**\n\t * Enables support for opening picks in the background via gesture.\n\t */\n\treadonly canAcceptInBackground?: boolean;\n\n\t/**\n\t * Enables to show a pick entry when no results are returned from a search.\n\t */\n\treadonly noResultsPick?: T | ((filter: string) => T);\n\n\t/** Whether to skip trimming the pick filter string */\n\treadonly shouldSkipTrimPickFilter?: boolean;\n}\n\nexport type Pick<T> = T | IQuickPickSeparator;\nexport type PicksWithActive<T> = { items: readonly Pick<T>[]; active?: T };\nexport type Picks<T> = readonly Pick<T>[] | PicksWithActive<T>;\nexport type FastAndSlowPicks<T> = {\n\t/**\n\t * Picks that will show instantly or after a short delay\n\t * based on the `mergeDelay` property to reduce flicker.\n\t */\n\treadonly picks: Picks<T>;\n\n\t/**\n\t * Picks that will show after they have been resolved.\n\t */\n\treadonly additionalPicks: Promise<Picks<T>>;\n\n\t/**\n\t * A delay in milliseconds to wait before showing the\n\t * `picks` to give a chance to merge with `additionalPicks`\n\t * for reduced flicker.\n\t */\n\treadonly mergeDelay?: number;\n};\n\nfunction isPicksWithActive<T>(obj: unknown): obj is PicksWithActive<T> {\n\tconst candidate = obj as PicksWithActive<T>;\n\n\treturn Array.isArray(candidate.items);\n}\n\nfunction isFastAndSlowPicks<T>(obj: unknown): obj is FastAndSlowPicks<T> {\n\tconst candidate = obj as FastAndSlowPicks<T>;\n\n\treturn !!candidate.picks && candidate.additionalPicks instanceof Promise;\n}\n\nexport abstract class PickerQuickAccessProvider<\n\t\tT extends IPickerQuickAccessItem,\n\t>\n\textends Disposable\n\timplements IQuickAccessProvider\n{\n\tconstructor(\n\t\tprivate prefix: string,\n\t\tprotected options?: IPickerQuickAccessProviderOptions<T>,\n\t) {\n\t\tsuper();\n\t}\n\n\tprovide(\n\t\tpicker: IQuickPick<T, { useSeparators: true }>,\n\t\ttoken: CancellationToken,\n\t\trunOptions?: IQuickAccessProviderRunOptions,\n\t): IDisposable {\n\t\tconst disposables = new DisposableStore();\n\n\t\t// Apply options if any\n\t\tpicker.canAcceptInBackground = !!this.options?.canAcceptInBackground;\n\n\t\t// Disable filtering & sorting, we control the results\n\t\tpicker.matchOnLabel =\n\t\t\tpicker.matchOnDescription =\n\t\t\tpicker.matchOnDetail =\n\t\t\tpicker.sortByLabel =\n\t\t\t\tfalse;\n\n\t\t// Set initial picks and update on type\n\t\tlet picksCts: CancellationTokenSource | undefined;\n\t\tconst picksDisposable = disposables.add(new MutableDisposable());\n\t\tconst updatePickerItems = async () => {\n\t\t\tconst picksDisposables = (picksDisposable.value =\n\t\t\t\tnew DisposableStore());\n\n\t\t\t// Cancel any previous ask for picks and busy\n\t\t\tpicksCts?.dispose(true);\n\t\t\tpicker.busy = false;\n\n\t\t\t// Create new cancellation source for this run\n\t\t\tpicksCts = new CancellationTokenSource(token);\n\n\t\t\t// Collect picks and support both long running and short or combined\n\t\t\tconst picksToken = picksCts.token;\n\t\t\tlet picksFilter = picker.value.substring(this.prefix.length);\n\n\t\t\tif (!this.options?.shouldSkipTrimPickFilter) {\n\t\t\t\tpicksFilter = picksFilter.trim();\n\t\t\t}\n\n\t\t\tconst providedPicks = this._getPicks(\n\t\t\t\tpicksFilter,\n\t\t\t\tpicksDisposables,\n\t\t\t\tpicksToken,\n\t\t\t\trunOptions,\n\t\t\t);\n\n\t\t\tconst applyPicks = (\n\t\t\t\tpicks: Picks<T>,\n\t\t\t\tskipEmpty?: boolean,\n\t\t\t): boolean => {\n\t\t\t\tlet items: readonly Pick<T>[];\n\t\t\t\tlet activeItem: T | undefined;\n\n\t\t\t\tif (isPicksWithActive(picks)) {\n\t\t\t\t\titems = picks.items;\n\t\t\t\t\tactiveItem = picks.active;\n\t\t\t\t} else {\n\t\t\t\t\titems = picks;\n\t\t\t\t}\n\n\t\t\t\tif (items.length === 0) {\n\t\t\t\t\tif (skipEmpty) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\t// We show the no results pick if we have no input to prevent completely empty pickers #172613\n\t\t\t\t\tif (\n\t\t\t\t\t\t(picksFilter.length > 0 || picker.hideInput) &&\n\t\t\t\t\t\tthis.options?.noResultsPick\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (isFunction(this.options.noResultsPick)) {\n\t\t\t\t\t\t\titems = [this.options.noResultsPick(picksFilter)];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\titems = [this.options.noResultsPick];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpicker.items = items;\n\t\t\t\tif (activeItem) {\n\t\t\t\t\tpicker.activeItems = [activeItem];\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t};\n\n\t\t\tconst applyFastAndSlowPicks = async (\n\t\t\t\tfastAndSlowPicks: FastAndSlowPicks<T>,\n\t\t\t): Promise<void> => {\n\t\t\t\tlet fastPicksApplied = false;\n\t\t\t\tlet slowPicksApplied = false;\n\n\t\t\t\tawait Promise.all([\n\t\t\t\t\t// Fast Picks: if `mergeDelay` is configured, in order to reduce\n\t\t\t\t\t// amount of flicker, we race against the slow picks over some delay\n\t\t\t\t\t// and then set the fast picks.\n\t\t\t\t\t// If the slow picks are faster, we reduce the flicker by only\n\t\t\t\t\t// setting the items once.\n\n\t\t\t\t\t(async () => {\n\t\t\t\t\t\tif (typeof fastAndSlowPicks.mergeDelay === \"number\") {\n\t\t\t\t\t\t\tawait timeout(fastAndSlowPicks.mergeDelay);\n\t\t\t\t\t\t\tif (picksToken.isCancellationRequested) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!slowPicksApplied) {\n\t\t\t\t\t\t\tfastPicksApplied = applyPicks(\n\t\t\t\t\t\t\t\tfastAndSlowPicks.picks,\n\t\t\t\t\t\t\t\ttrue /* skip over empty to reduce flicker */,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t})(),\n\n\t\t\t\t\t// Slow Picks: we await the slow picks and then set them at\n\t\t\t\t\t// once together with the fast picks, but only if we actually\n\t\t\t\t\t// have additional results.\n\n\t\t\t\t\t(async () => {\n\t\t\t\t\t\tpicker.busy = true;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst awaitedAdditionalPicks =\n\t\t\t\t\t\t\t\tawait fastAndSlowPicks.additionalPicks;\n\t\t\t\t\t\t\tif (picksToken.isCancellationRequested) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlet picks: readonly Pick<T>[];\n\t\t\t\t\t\t\tlet activePick: Pick<T> | undefined;\n\t\t\t\t\t\t\tif (isPicksWithActive(fastAndSlowPicks.picks)) {\n\t\t\t\t\t\t\t\tpicks = fastAndSlowPicks.picks.items;\n\t\t\t\t\t\t\t\tactivePick = fastAndSlowPicks.picks.active;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tpicks = fastAndSlowPicks.picks;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlet additionalPicks: readonly Pick<T>[];\n\t\t\t\t\t\t\tlet additionalActivePick: Pick<T> | undefined;\n\t\t\t\t\t\t\tif (isPicksWithActive(awaitedAdditionalPicks)) {\n\t\t\t\t\t\t\t\tadditionalPicks = awaitedAdditionalPicks.items;\n\t\t\t\t\t\t\t\tadditionalActivePick =\n\t\t\t\t\t\t\t\t\tawaitedAdditionalPicks.active;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tadditionalPicks = awaitedAdditionalPicks;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tadditionalPicks.length > 0 ||\n\t\t\t\t\t\t\t\t!fastPicksApplied\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t// If we do not have any activePick or additionalActivePick\n\t\t\t\t\t\t\t\t// we try to preserve the currently active pick from the\n\t\t\t\t\t\t\t\t// fast results. This fixes an issue where the user might\n\t\t\t\t\t\t\t\t// have made a pick active before the additional results\n\t\t\t\t\t\t\t\t// kick in.\n\t\t\t\t\t\t\t\t// See https://github.com/microsoft/vscode/issues/102480\n\t\t\t\t\t\t\t\tlet fallbackActivePick: Pick<T> | undefined;\n\t\t\t\t\t\t\t\tif (!activePick && !additionalActivePick) {\n\t\t\t\t\t\t\t\t\tconst fallbackActivePickCandidate =\n\t\t\t\t\t\t\t\t\t\tpicker.activeItems[0];\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tfallbackActivePickCandidate &&\n\t\t\t\t\t\t\t\t\t\tpicks.indexOf(\n\t\t\t\t\t\t\t\t\t\t\tfallbackActivePickCandidate,\n\t\t\t\t\t\t\t\t\t\t) !== -1\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tfallbackActivePick =\n\t\t\t\t\t\t\t\t\t\t\tfallbackActivePickCandidate;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tapplyPicks({\n\t\t\t\t\t\t\t\t\titems: [...picks, ...additionalPicks],\n\t\t\t\t\t\t\t\t\tactive:\n\t\t\t\t\t\t\t\t\t\tactivePick ||\n\t\t\t\t\t\t\t\t\t\tadditionalActivePick ||\n\t\t\t\t\t\t\t\t\t\tfallbackActivePick,\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tif (!picksToken.isCancellationRequested) {\n\t\t\t\t\t\t\t\tpicker.busy = false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tslowPicksApplied = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t})(),\n\t\t\t\t]);\n\t\t\t};\n\n\t\t\t// No Picks\n\t\t\tif (providedPicks === null) {\n\t\t\t\t// Ignore\n\t\t\t}\n\n\t\t\t// Fast and Slow Picks\n\t\t\telse if (isFastAndSlowPicks(providedPicks)) {\n\t\t\t\tawait applyFastAndSlowPicks(providedPicks);\n\t\t\t}\n\n\t\t\t// Fast Picks\n\t\t\telse if (providedPicks instanceof Promise) {\n\t\t\t\tpicker.busy = true;\n\t\t\t\ttry {\n\t\t\t\t\tconst awaitedPicks = await providedPicks;\n\t\t\t\t\tif (picksToken.isCancellationRequested) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isFastAndSlowPicks(awaitedPicks)) {\n\t\t\t\t\t\tawait applyFastAndSlowPicks(awaitedPicks);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tapplyPicks(awaitedPicks);\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (!picksToken.isCancellationRequested) {\n\t\t\t\t\t\tpicker.busy = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tapplyPicks(providedPicks);\n\t\t\t}\n\t\t};\n\t\tdisposables.add(picker.onDidChangeValue(() => updatePickerItems()));\n\t\tupdatePickerItems();\n\n\t\t// Accept the pick on accept and hide picker\n\t\tdisposables.add(\n\t\t\tpicker.onDidAccept((event) => {\n\t\t\t\tif (runOptions?.handleAccept) {\n\t\t\t\t\tif (!event.inBackground) {\n\t\t\t\t\t\tpicker.hide(); // hide picker unless we accept in background\n\t\t\t\t\t}\n\t\t\t\t\trunOptions.handleAccept?.(picker.activeItems[0]);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst [item] = picker.selectedItems;\n\t\t\t\tif (typeof item?.accept === \"function\") {\n\t\t\t\t\tif (!event.inBackground) {\n\t\t\t\t\t\tpicker.hide(); // hide picker unless we accept in background\n\t\t\t\t\t}\n\n\t\t\t\t\titem.accept(picker.keyMods, event);\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\n\t\tconst buttonTrigger = async (\n\t\t\tbutton: IQuickInputButton,\n\t\t\titem: T | IPickerQuickAccessSeparator,\n\t\t) => {\n\t\t\tif (typeof item.trigger !== \"function\") {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst buttonIndex = item.buttons?.indexOf(button) ?? -1;\n\t\t\tif (buttonIndex >= 0) {\n\t\t\t\tconst result = item.trigger(buttonIndex, picker.keyMods);\n\t\t\t\tconst action =\n\t\t\t\t\ttypeof result === \"number\" ? result : await result;\n\n\t\t\t\tif (token.isCancellationRequested) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tswitch (action) {\n\t\t\t\t\tcase TriggerAction.NO_ACTION:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TriggerAction.CLOSE_PICKER:\n\t\t\t\t\t\tpicker.hide();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TriggerAction.REFRESH_PICKER:\n\t\t\t\t\t\tupdatePickerItems();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TriggerAction.REMOVE_ITEM: {\n\t\t\t\t\t\tconst index = picker.items.indexOf(item);\n\t\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\t\tconst items = picker.items.slice();\n\t\t\t\t\t\t\tconst removed = items.splice(index, 1);\n\t\t\t\t\t\t\tconst activeItems = picker.activeItems.filter(\n\t\t\t\t\t\t\t\t(activeItem) => activeItem !== removed[0],\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst keepScrollPositionBefore =\n\t\t\t\t\t\t\t\tpicker.keepScrollPosition;\n\t\t\t\t\t\t\tpicker.keepScrollPosition = true;\n\t\t\t\t\t\t\tpicker.items = items;\n\t\t\t\t\t\t\tif (activeItems) {\n\t\t\t\t\t\t\t\tpicker.activeItems = activeItems;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpicker.keepScrollPosition =\n\t\t\t\t\t\t\t\tkeepScrollPositionBefore;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// Trigger the pick with button index if button triggered\n\t\tdisposables.add(\n\t\t\tpicker.onDidTriggerItemButton(({ button, item }) =>\n\t\t\t\tbuttonTrigger(button, item),\n\t\t\t),\n\t\t);\n\t\tdisposables.add(\n\t\t\tpicker.onDidTriggerSeparatorButton(({ button, separator }) =>\n\t\t\t\tbuttonTrigger(button, separator),\n\t\t\t),\n\t\t);\n\n\t\treturn disposables;\n\t}\n\n\t/**\n\t * Returns an array of picks and separators as needed. If the picks are resolved\n\t * long running, the provided cancellation token should be used to cancel the\n\t * operation when the token signals this.\n\t *\n\t * The implementor is responsible for filtering and sorting the picks given the\n\t * provided `filter`.\n\t *\n\t * @param filter a filter to apply to the picks.\n\t * @param disposables can be used to register disposables that should be cleaned\n\t * up when the picker closes.\n\t * @param token for long running tasks, implementors need to check on cancellation\n\t * through this token.\n\t * @returns the picks either directly, as promise or combined fast and slow results.\n\t * Pickers can return `null` to signal that no change in picks is needed.\n\t */\n\tprotected abstract _getPicks(\n\t\tfilter: string,\n\t\tdisposables: DisposableStore,\n\t\ttoken: CancellationToken,\n\t\trunOptions?: IQuickAccessProviderRunOptions,\n\t):\n\t\t| Picks<T>\n\t\t| Promise<Picks<T> | FastAndSlowPicks<T>>\n\t\t| FastAndSlowPicks<T>\n\t\t| null;\n}\n"],
  "mappings": "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",
  "names": ["TriggerAction"]
}
