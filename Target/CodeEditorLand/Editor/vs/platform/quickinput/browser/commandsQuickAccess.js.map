{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/quickinput/browser/commandsQuickAccess.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type {\n\tWorkbenchActionExecutedClassification,\n\tWorkbenchActionExecutedEvent,\n} from \"../../../base/common/actions.js\";\nimport type { CancellationToken } from \"../../../base/common/cancellation.js\";\nimport { toErrorMessage } from \"../../../base/common/errorMessage.js\";\nimport { isCancellationError } from \"../../../base/common/errors.js\";\nimport {\n\tmatchesContiguousSubString,\n\tmatchesPrefix,\n\tmatchesWords,\n\tor,\n} from \"../../../base/common/filters.js\";\nimport { createSingleCallFunction } from \"../../../base/common/functional.js\";\nimport {\n\tDisposable,\n\ttype DisposableStore,\n\ttype IDisposable,\n} from \"../../../base/common/lifecycle.js\";\nimport { LRUCache } from \"../../../base/common/map.js\";\nimport {\n\tTfIdfCalculator,\n\tnormalizeTfIdfScores,\n} from \"../../../base/common/tfIdf.js\";\nimport { localize } from \"../../../nls.js\";\nimport type { ILocalizedString } from \"../../action/common/action.js\";\nimport { ICommandService } from \"../../commands/common/commands.js\";\nimport {\n\ttype IConfigurationChangeEvent,\n\tIConfigurationService,\n} from \"../../configuration/common/configuration.js\";\nimport { IDialogService } from \"../../dialogs/common/dialogs.js\";\nimport { IInstantiationService } from \"../../instantiation/common/instantiation.js\";\nimport { IKeybindingService } from \"../../keybinding/common/keybinding.js\";\nimport { ILogService } from \"../../log/common/log.js\";\nimport {\n\tIStorageService,\n\tStorageScope,\n\tStorageTarget,\n\tWillSaveStateReason,\n} from \"../../storage/common/storage.js\";\nimport { ITelemetryService } from \"../../telemetry/common/telemetry.js\";\nimport type { IQuickAccessProviderRunOptions } from \"../common/quickAccess.js\";\nimport type { IQuickPickSeparator } from \"../common/quickInput.js\";\nimport {\n\ttype FastAndSlowPicks,\n\ttype IPickerQuickAccessItem,\n\ttype IPickerQuickAccessProviderOptions,\n\tPickerQuickAccessProvider,\n\ttype Picks,\n} from \"./pickerQuickAccess.js\";\n\nexport interface ICommandQuickPick extends IPickerQuickAccessItem {\n\treadonly commandId: string;\n\treadonly commandWhen?: string;\n\treadonly commandAlias?: string;\n\treadonly commandDescription?: ILocalizedString;\n\ttfIdfScore?: number;\n\treadonly args?: any[];\n}\n\nexport interface ICommandsQuickAccessOptions\n\textends IPickerQuickAccessProviderOptions<ICommandQuickPick> {\n\treadonly showAlias: boolean;\n\tsuggestedCommandIds?: Set<string>;\n}\n\nexport abstract class AbstractCommandsQuickAccessProvider\n\textends PickerQuickAccessProvider<ICommandQuickPick>\n\timplements IDisposable\n{\n\tstatic PREFIX = \">\";\n\n\tprivate static readonly TFIDF_THRESHOLD = 0.5;\n\tprivate static readonly TFIDF_MAX_RESULTS = 5;\n\n\tprivate static WORD_FILTER = or(\n\t\tmatchesPrefix,\n\t\tmatchesWords,\n\t\tmatchesContiguousSubString,\n\t);\n\n\tprivate readonly commandsHistory = this._register(\n\t\tthis.instantiationService.createInstance(CommandsHistory),\n\t);\n\n\tprotected override readonly options: ICommandsQuickAccessOptions;\n\n\tconstructor(\n\t\toptions: ICommandsQuickAccessOptions,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService,\n\t\t@IKeybindingService protected readonly keybindingService: IKeybindingService,\n\t\t@ICommandService private readonly commandService: ICommandService,\n\t\t@ITelemetryService private readonly telemetryService: ITelemetryService,\n\t\t@IDialogService private readonly dialogService: IDialogService\n\t) {\n\t\tsuper(AbstractCommandsQuickAccessProvider.PREFIX, options);\n\n\t\tthis.options = options;\n\t}\n\n\tprotected async _getPicks(\n\t\tfilter: string,\n\t\t_disposables: DisposableStore,\n\t\ttoken: CancellationToken,\n\t\trunOptions?: IQuickAccessProviderRunOptions,\n\t): Promise<Picks<ICommandQuickPick> | FastAndSlowPicks<ICommandQuickPick>> {\n\t\t// Ask subclass for all command picks\n\t\tconst allCommandPicks = await this.getCommandPicks(token);\n\n\t\tif (token.isCancellationRequested) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst runTfidf = createSingleCallFunction(() => {\n\t\t\tconst tfidf = new TfIdfCalculator();\n\t\t\ttfidf.updateDocuments(\n\t\t\t\tallCommandPicks.map((commandPick) => ({\n\t\t\t\t\tkey: commandPick.commandId,\n\t\t\t\t\ttextChunks: [this.getTfIdfChunk(commandPick)],\n\t\t\t\t})),\n\t\t\t);\n\t\t\tconst result = tfidf.calculateScores(filter, token);\n\n\t\t\treturn normalizeTfIdfScores(result)\n\t\t\t\t.filter(\n\t\t\t\t\t(score) =>\n\t\t\t\t\t\tscore.score >\n\t\t\t\t\t\tAbstractCommandsQuickAccessProvider.TFIDF_THRESHOLD,\n\t\t\t\t)\n\t\t\t\t.slice(\n\t\t\t\t\t0,\n\t\t\t\t\tAbstractCommandsQuickAccessProvider.TFIDF_MAX_RESULTS,\n\t\t\t\t);\n\t\t});\n\n\t\t// Filter\n\t\tconst filteredCommandPicks: ICommandQuickPick[] = [];\n\t\tfor (const commandPick of allCommandPicks) {\n\t\t\tconst labelHighlights =\n\t\t\t\tAbstractCommandsQuickAccessProvider.WORD_FILTER(\n\t\t\t\t\tfilter,\n\t\t\t\t\tcommandPick.label,\n\t\t\t\t) ?? undefined;\n\t\t\tconst aliasHighlights = commandPick.commandAlias\n\t\t\t\t? (AbstractCommandsQuickAccessProvider.WORD_FILTER(\n\t\t\t\t\t\tfilter,\n\t\t\t\t\t\tcommandPick.commandAlias,\n\t\t\t\t\t) ?? undefined)\n\t\t\t\t: undefined;\n\n\t\t\t// Add if matching in label or alias\n\t\t\tif (labelHighlights || aliasHighlights) {\n\t\t\t\tcommandPick.highlights = {\n\t\t\t\t\tlabel: labelHighlights,\n\t\t\t\t\tdetail: this.options.showAlias\n\t\t\t\t\t\t? aliasHighlights\n\t\t\t\t\t\t: undefined,\n\t\t\t\t};\n\n\t\t\t\tfilteredCommandPicks.push(commandPick);\n\t\t\t}\n\n\t\t\t// Also add if we have a 100% command ID match\n\t\t\telse if (filter === commandPick.commandId) {\n\t\t\t\tfilteredCommandPicks.push(commandPick);\n\t\t\t}\n\n\t\t\t// Handle tf-idf scoring for the rest if there's a filter\n\t\t\telse if (filter.length >= 3) {\n\t\t\t\tconst tfidf = runTfidf();\n\t\t\t\tif (token.isCancellationRequested) {\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\n\t\t\t\t// Add if we have a tf-idf score\n\t\t\t\tconst tfidfScore = tfidf.find(\n\t\t\t\t\t(score) => score.key === commandPick.commandId,\n\t\t\t\t);\n\t\t\t\tif (tfidfScore) {\n\t\t\t\t\tcommandPick.tfIdfScore = tfidfScore.score;\n\t\t\t\t\tfilteredCommandPicks.push(commandPick);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add description to commands that have duplicate labels\n\t\tconst mapLabelToCommand = new Map<string, ICommandQuickPick>();\n\t\tfor (const commandPick of filteredCommandPicks) {\n\t\t\tconst existingCommandForLabel = mapLabelToCommand.get(\n\t\t\t\tcommandPick.label,\n\t\t\t);\n\t\t\tif (existingCommandForLabel) {\n\t\t\t\tcommandPick.description = commandPick.commandId;\n\t\t\t\texistingCommandForLabel.description =\n\t\t\t\t\texistingCommandForLabel.commandId;\n\t\t\t} else {\n\t\t\t\tmapLabelToCommand.set(commandPick.label, commandPick);\n\t\t\t}\n\t\t}\n\n\t\t// Sort by MRU order and fallback to name otherwise\n\t\tfilteredCommandPicks.sort((commandPickA, commandPickB) => {\n\t\t\t// If a result came from tf-idf, we want to put that towards the bottom\n\t\t\tif (commandPickA.tfIdfScore && commandPickB.tfIdfScore) {\n\t\t\t\tif (commandPickA.tfIdfScore === commandPickB.tfIdfScore) {\n\t\t\t\t\treturn commandPickA.label.localeCompare(commandPickB.label); // prefer lexicographically smaller command\n\t\t\t\t}\n\t\t\t\treturn commandPickB.tfIdfScore - commandPickA.tfIdfScore; // prefer higher tf-idf score\n\t\t\t} else if (commandPickA.tfIdfScore) {\n\t\t\t\treturn 1; // first command has a score but other doesn't so other wins\n\t\t\t} else if (commandPickB.tfIdfScore) {\n\t\t\t\treturn -1; // other command has a score but first doesn't so first wins\n\t\t\t}\n\n\t\t\tconst commandACounter = this.commandsHistory.peek(\n\t\t\t\tcommandPickA.commandId,\n\t\t\t);\n\t\t\tconst commandBCounter = this.commandsHistory.peek(\n\t\t\t\tcommandPickB.commandId,\n\t\t\t);\n\n\t\t\tif (commandACounter && commandBCounter) {\n\t\t\t\treturn commandACounter > commandBCounter ? -1 : 1; // use more recently used command before older\n\t\t\t}\n\n\t\t\tif (commandACounter) {\n\t\t\t\treturn -1; // first command was used, so it wins over the non used one\n\t\t\t}\n\n\t\t\tif (commandBCounter) {\n\t\t\t\treturn 1; // other command was used so it wins over the command\n\t\t\t}\n\n\t\t\tif (this.options.suggestedCommandIds) {\n\t\t\t\tconst commandASuggestion = this.options.suggestedCommandIds.has(\n\t\t\t\t\tcommandPickA.commandId,\n\t\t\t\t);\n\t\t\t\tconst commandBSuggestion = this.options.suggestedCommandIds.has(\n\t\t\t\t\tcommandPickB.commandId,\n\t\t\t\t);\n\t\t\t\tif (commandASuggestion && commandBSuggestion) {\n\t\t\t\t\treturn 0; // honor the order of the array\n\t\t\t\t}\n\n\t\t\t\tif (commandASuggestion) {\n\t\t\t\t\treturn -1; // first command was suggested, so it wins over the non suggested one\n\t\t\t\t}\n\n\t\t\t\tif (commandBSuggestion) {\n\t\t\t\t\treturn 1; // other command was suggested so it wins over the command\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// both commands were never used, so we sort by name\n\t\t\treturn commandPickA.label.localeCompare(commandPickB.label);\n\t\t});\n\n\t\tconst commandPicks: Array<ICommandQuickPick | IQuickPickSeparator> = [];\n\n\t\tlet addOtherSeparator = false;\n\t\tlet addSuggestedSeparator = true;\n\t\tlet addCommonlyUsedSeparator = !!this.options.suggestedCommandIds;\n\t\tfor (let i = 0; i < filteredCommandPicks.length; i++) {\n\t\t\tconst commandPick = filteredCommandPicks[i];\n\n\t\t\t// Separator: recently used\n\t\t\tif (i === 0 && this.commandsHistory.peek(commandPick.commandId)) {\n\t\t\t\tcommandPicks.push({\n\t\t\t\t\ttype: \"separator\",\n\t\t\t\t\tlabel: localize(\"recentlyUsed\", \"recently used\"),\n\t\t\t\t});\n\t\t\t\taddOtherSeparator = true;\n\t\t\t}\n\n\t\t\tif (addSuggestedSeparator && commandPick.tfIdfScore !== undefined) {\n\t\t\t\tcommandPicks.push({\n\t\t\t\t\ttype: \"separator\",\n\t\t\t\t\tlabel: localize(\"suggested\", \"similar commands\"),\n\t\t\t\t});\n\t\t\t\taddSuggestedSeparator = false;\n\t\t\t}\n\n\t\t\t// Separator: commonly used\n\t\t\tif (\n\t\t\t\taddCommonlyUsedSeparator &&\n\t\t\t\tcommandPick.tfIdfScore === undefined &&\n\t\t\t\t!this.commandsHistory.peek(commandPick.commandId) &&\n\t\t\t\tthis.options.suggestedCommandIds?.has(commandPick.commandId)\n\t\t\t) {\n\t\t\t\tcommandPicks.push({\n\t\t\t\t\ttype: \"separator\",\n\t\t\t\t\tlabel: localize(\"commonlyUsed\", \"commonly used\"),\n\t\t\t\t});\n\t\t\t\taddOtherSeparator = true;\n\t\t\t\taddCommonlyUsedSeparator = false;\n\t\t\t}\n\n\t\t\t// Separator: other commands\n\t\t\tif (\n\t\t\t\taddOtherSeparator &&\n\t\t\t\tcommandPick.tfIdfScore === undefined &&\n\t\t\t\t!this.commandsHistory.peek(commandPick.commandId) &&\n\t\t\t\t!this.options.suggestedCommandIds?.has(commandPick.commandId)\n\t\t\t) {\n\t\t\t\tcommandPicks.push({\n\t\t\t\t\ttype: \"separator\",\n\t\t\t\t\tlabel: localize(\"morecCommands\", \"other commands\"),\n\t\t\t\t});\n\t\t\t\taddOtherSeparator = false;\n\t\t\t}\n\n\t\t\t// Command\n\t\t\tcommandPicks.push(this.toCommandPick(commandPick, runOptions));\n\t\t}\n\n\t\tif (!this.hasAdditionalCommandPicks(filter, token)) {\n\t\t\treturn commandPicks;\n\t\t}\n\n\t\treturn {\n\t\t\tpicks: commandPicks,\n\t\t\tadditionalPicks: (async (): Promise<Picks<ICommandQuickPick>> => {\n\t\t\t\tconst additionalCommandPicks =\n\t\t\t\t\tawait this.getAdditionalCommandPicks(\n\t\t\t\t\t\tallCommandPicks,\n\t\t\t\t\t\tfilteredCommandPicks,\n\t\t\t\t\t\tfilter,\n\t\t\t\t\t\ttoken,\n\t\t\t\t\t);\n\t\t\t\tif (token.isCancellationRequested) {\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\n\t\t\t\tconst commandPicks: Array<\n\t\t\t\t\tICommandQuickPick | IQuickPickSeparator\n\t\t\t\t> = additionalCommandPicks.map((commandPick) =>\n\t\t\t\t\tthis.toCommandPick(commandPick, runOptions),\n\t\t\t\t);\n\t\t\t\t// Basically, if we haven't already added a separator, we add one before the additional picks so long\n\t\t\t\t// as one hasn't been added to the start of the array.\n\t\t\t\tif (\n\t\t\t\t\taddSuggestedSeparator &&\n\t\t\t\t\tcommandPicks[0]?.type !== \"separator\"\n\t\t\t\t) {\n\t\t\t\t\tcommandPicks.unshift({\n\t\t\t\t\t\ttype: \"separator\",\n\t\t\t\t\t\tlabel: localize(\"suggested\", \"similar commands\"),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn commandPicks;\n\t\t\t})(),\n\t\t};\n\t}\n\n\tprivate toCommandPick(\n\t\tcommandPick: ICommandQuickPick | IQuickPickSeparator,\n\t\trunOptions?: IQuickAccessProviderRunOptions,\n\t): ICommandQuickPick | IQuickPickSeparator {\n\t\tif (commandPick.type === \"separator\") {\n\t\t\treturn commandPick;\n\t\t}\n\n\t\tconst keybinding = this.keybindingService.lookupKeybinding(\n\t\t\tcommandPick.commandId,\n\t\t);\n\t\tconst ariaLabel = keybinding\n\t\t\t? localize(\n\t\t\t\t\t\"commandPickAriaLabelWithKeybinding\",\n\t\t\t\t\t\"{0}, {1}\",\n\t\t\t\t\tcommandPick.label,\n\t\t\t\t\tkeybinding.getAriaLabel(),\n\t\t\t\t)\n\t\t\t: commandPick.label;\n\n\t\treturn {\n\t\t\t...commandPick,\n\t\t\tariaLabel,\n\t\t\tdetail:\n\t\t\t\tthis.options.showAlias &&\n\t\t\t\tcommandPick.commandAlias !== commandPick.label\n\t\t\t\t\t? commandPick.commandAlias\n\t\t\t\t\t: undefined,\n\t\t\tkeybinding,\n\t\t\taccept: async () => {\n\t\t\t\t// Add to history\n\t\t\t\tthis.commandsHistory.push(commandPick.commandId);\n\n\t\t\t\t// Telementry\n\t\t\t\tthis.telemetryService.publicLog2<\n\t\t\t\t\tWorkbenchActionExecutedEvent,\n\t\t\t\t\tWorkbenchActionExecutedClassification\n\t\t\t\t>(\"workbenchActionExecuted\", {\n\t\t\t\t\tid: commandPick.commandId,\n\t\t\t\t\tfrom: runOptions?.from ?? \"quick open\",\n\t\t\t\t});\n\n\t\t\t\t// Run\n\t\t\t\ttry {\n\t\t\t\t\tcommandPick.args?.length\n\t\t\t\t\t\t? await this.commandService.executeCommand(\n\t\t\t\t\t\t\t\tcommandPick.commandId,\n\t\t\t\t\t\t\t\t...commandPick.args,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t: await this.commandService.executeCommand(\n\t\t\t\t\t\t\t\tcommandPick.commandId,\n\t\t\t\t\t\t\t);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (!isCancellationError(error)) {\n\t\t\t\t\t\tthis.dialogService.error(\n\t\t\t\t\t\t\tlocalize(\n\t\t\t\t\t\t\t\t\"canNotRun\",\n\t\t\t\t\t\t\t\t\"Command '{0}' resulted in an error\",\n\t\t\t\t\t\t\t\tcommandPick.label,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\ttoErrorMessage(error),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t}\n\n\t// TF-IDF string to be indexed\n\tprivate getTfIdfChunk({\n\t\tlabel,\n\t\tcommandAlias,\n\t\tcommandDescription,\n\t}: ICommandQuickPick) {\n\t\tlet chunk = label;\n\t\tif (commandAlias && commandAlias !== label) {\n\t\t\tchunk += ` - ${commandAlias}`;\n\t\t}\n\t\tif (commandDescription && commandDescription.value !== label) {\n\t\t\t// If the original is the same as the value, don't add it\n\t\t\tchunk += ` - ${commandDescription.value === commandDescription.original ? commandDescription.value : `${commandDescription.value} (${commandDescription.original})`}`;\n\t\t}\n\t\treturn chunk;\n\t}\n\n\tprotected abstract getCommandPicks(\n\t\ttoken: CancellationToken,\n\t): Promise<Array<ICommandQuickPick>>;\n\n\tprotected abstract hasAdditionalCommandPicks(\n\t\tfilter: string,\n\t\ttoken: CancellationToken,\n\t): boolean;\n\tprotected abstract getAdditionalCommandPicks(\n\t\tallPicks: ICommandQuickPick[],\n\t\tpicksSoFar: ICommandQuickPick[],\n\t\tfilter: string,\n\t\ttoken: CancellationToken,\n\t): Promise<Array<ICommandQuickPick | IQuickPickSeparator>>;\n}\n\ninterface ISerializedCommandHistory {\n\treadonly usesLRU?: boolean;\n\treadonly entries: { key: string; value: number }[];\n}\n\ninterface ICommandsQuickAccessConfiguration {\n\treadonly workbench: {\n\t\treadonly commandPalette: {\n\t\t\treadonly history: number;\n\t\t\treadonly preserveInput: boolean;\n\t\t};\n\t};\n}\n\nexport class CommandsHistory extends Disposable {\n\tstatic readonly DEFAULT_COMMANDS_HISTORY_LENGTH = 50;\n\n\tprivate static readonly PREF_KEY_CACHE = \"commandPalette.mru.cache\";\n\tprivate static readonly PREF_KEY_COUNTER = \"commandPalette.mru.counter\";\n\n\tprivate static cache: LRUCache<string, number> | undefined;\n\tprivate static counter = 1;\n\tprivate static hasChanges = false;\n\n\tprivate configuredCommandsHistoryLength = 0;\n\n\tconstructor(\n\t\t@IStorageService private readonly storageService: IStorageService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t\t@ILogService private readonly logService: ILogService\n\t) {\n\t\tsuper();\n\n\t\tthis.updateConfiguration();\n\t\tthis.load();\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tthis._register(\n\t\t\tthis.configurationService.onDidChangeConfiguration((e) =>\n\t\t\t\tthis.updateConfiguration(e),\n\t\t\t),\n\t\t);\n\t\tthis._register(\n\t\t\tthis.storageService.onWillSaveState((e) => {\n\t\t\t\tif (e.reason === WillSaveStateReason.SHUTDOWN) {\n\t\t\t\t\t// Commands history is very dynamic and so we limit impact\n\t\t\t\t\t// on storage to only save on shutdown. This helps reduce\n\t\t\t\t\t// the overhead of syncing this data across machines.\n\t\t\t\t\tthis.saveState();\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\t}\n\n\tprivate updateConfiguration(e?: IConfigurationChangeEvent): void {\n\t\tif (e && !e.affectsConfiguration(\"workbench.commandPalette.history\")) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.configuredCommandsHistoryLength =\n\t\t\tCommandsHistory.getConfiguredCommandHistoryLength(\n\t\t\t\tthis.configurationService,\n\t\t\t);\n\n\t\tif (\n\t\t\tCommandsHistory.cache &&\n\t\t\tCommandsHistory.cache.limit !== this.configuredCommandsHistoryLength\n\t\t) {\n\t\t\tCommandsHistory.cache.limit = this.configuredCommandsHistoryLength;\n\t\t\tCommandsHistory.hasChanges = true;\n\t\t}\n\t}\n\n\tprivate load(): void {\n\t\tconst raw = this.storageService.get(\n\t\t\tCommandsHistory.PREF_KEY_CACHE,\n\t\t\tStorageScope.PROFILE,\n\t\t);\n\t\tlet serializedCache: ISerializedCommandHistory | undefined;\n\t\tif (raw) {\n\t\t\ttry {\n\t\t\t\tserializedCache = JSON.parse(raw);\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.error(\n\t\t\t\t\t`[CommandsHistory] invalid data: ${error}`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tconst cache = (CommandsHistory.cache = new LRUCache<string, number>(\n\t\t\tthis.configuredCommandsHistoryLength,\n\t\t\t1,\n\t\t));\n\t\tif (serializedCache) {\n\t\t\tlet entries: { key: string; value: number }[];\n\t\t\tif (serializedCache.usesLRU) {\n\t\t\t\tentries = serializedCache.entries;\n\t\t\t} else {\n\t\t\t\tentries = serializedCache.entries.sort(\n\t\t\t\t\t(a, b) => a.value - b.value,\n\t\t\t\t);\n\t\t\t}\n\t\t\tentries.forEach((entry) => cache.set(entry.key, entry.value));\n\t\t}\n\n\t\tCommandsHistory.counter = this.storageService.getNumber(\n\t\t\tCommandsHistory.PREF_KEY_COUNTER,\n\t\t\tStorageScope.PROFILE,\n\t\t\tCommandsHistory.counter,\n\t\t);\n\t}\n\n\tpush(commandId: string): void {\n\t\tif (!CommandsHistory.cache) {\n\t\t\treturn;\n\t\t}\n\n\t\tCommandsHistory.cache.set(commandId, CommandsHistory.counter++); // set counter to command\n\t\tCommandsHistory.hasChanges = true;\n\t}\n\n\tpeek(commandId: string): number | undefined {\n\t\treturn CommandsHistory.cache?.peek(commandId);\n\t}\n\n\tprivate saveState(): void {\n\t\tif (!CommandsHistory.cache) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!CommandsHistory.hasChanges) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst serializedCache: ISerializedCommandHistory = {\n\t\t\tusesLRU: true,\n\t\t\tentries: [],\n\t\t};\n\t\tCommandsHistory.cache.forEach((value, key) =>\n\t\t\tserializedCache.entries.push({ key, value }),\n\t\t);\n\n\t\tthis.storageService.store(\n\t\t\tCommandsHistory.PREF_KEY_CACHE,\n\t\t\tJSON.stringify(serializedCache),\n\t\t\tStorageScope.PROFILE,\n\t\t\tStorageTarget.USER,\n\t\t);\n\t\tthis.storageService.store(\n\t\t\tCommandsHistory.PREF_KEY_COUNTER,\n\t\t\tCommandsHistory.counter,\n\t\t\tStorageScope.PROFILE,\n\t\t\tStorageTarget.USER,\n\t\t);\n\t\tCommandsHistory.hasChanges = false;\n\t}\n\n\tstatic getConfiguredCommandHistoryLength(\n\t\tconfigurationService: IConfigurationService,\n\t): number {\n\t\tconst config = <ICommandsQuickAccessConfiguration>(\n\t\t\tconfigurationService.getValue()\n\t\t);\n\n\t\tconst configuredCommandHistoryLength =\n\t\t\tconfig.workbench?.commandPalette?.history;\n\t\tif (typeof configuredCommandHistoryLength === \"number\") {\n\t\t\treturn configuredCommandHistoryLength;\n\t\t}\n\n\t\treturn CommandsHistory.DEFAULT_COMMANDS_HISTORY_LENGTH;\n\t}\n\n\tstatic clearHistory(\n\t\tconfigurationService: IConfigurationService,\n\t\tstorageService: IStorageService,\n\t): void {\n\t\tconst commandHistoryLength =\n\t\t\tCommandsHistory.getConfiguredCommandHistoryLength(\n\t\t\t\tconfigurationService,\n\t\t\t);\n\t\tCommandsHistory.cache = new LRUCache<string, number>(\n\t\t\tcommandHistoryLength,\n\t\t);\n\t\tCommandsHistory.counter = 1;\n\n\t\tCommandsHistory.hasChanges = true;\n\t}\n}\n"],
  "mappings": "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",
  "names": ["commandPicks"]
}
