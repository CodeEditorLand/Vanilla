{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/quickinput/browser/quickPickPin.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Codicon } from \"../../../base/common/codicons.js\";\nimport {\n\tDisposableStore,\n\ttype IDisposable,\n} from \"../../../base/common/lifecycle.js\";\nimport { ThemeIcon } from \"../../../base/common/themables.js\";\nimport { localize } from \"../../../nls.js\";\nimport {\n\ttype IStorageService,\n\tStorageScope,\n\tStorageTarget,\n} from \"../../storage/common/storage.js\";\nimport type {\n\tIQuickPick,\n\tIQuickPickItem,\n\tQuickPickItem,\n} from \"../common/quickInput.js\";\n\nconst pinButtonClass = ThemeIcon.asClassName(Codicon.pin);\nconst pinnedButtonClass = ThemeIcon.asClassName(Codicon.pinned);\nconst buttonClasses = [pinButtonClass, pinnedButtonClass];\n/**\n * Initially, adds pin buttons to all @param quickPick items.\n * When pinned, a copy of the item will be moved to the end of the pinned list and any duplicate within the pinned list will\n * be removed if @param filterDupliates has been provided. Pin and pinned button events trigger updates to the underlying storage.\n * Shows the quickpick once formatted.\n */\nexport function showWithPinnedItems(\n\tstorageService: IStorageService,\n\tstorageKey: string,\n\tquickPick: IQuickPick<IQuickPickItem, { useSeparators: true }>,\n\tfilterDuplicates?: boolean,\n): IDisposable {\n\tconst itemsWithoutPinned = quickPick.items;\n\tlet itemsWithPinned = _formatPinnedItems(\n\t\tstorageKey,\n\t\tquickPick,\n\t\tstorageService,\n\t\tundefined,\n\t\tfilterDuplicates,\n\t);\n\tconst disposables = new DisposableStore();\n\tdisposables.add(\n\t\tquickPick.onDidTriggerItemButton(async (buttonEvent) => {\n\t\t\tconst expectedButton =\n\t\t\t\tbuttonEvent.button.iconClass &&\n\t\t\t\tbuttonClasses.includes(buttonEvent.button.iconClass);\n\t\t\tif (expectedButton) {\n\t\t\t\tquickPick.items = itemsWithoutPinned;\n\t\t\t\titemsWithPinned = _formatPinnedItems(\n\t\t\t\t\tstorageKey,\n\t\t\t\t\tquickPick,\n\t\t\t\t\tstorageService,\n\t\t\t\t\tbuttonEvent.item,\n\t\t\t\t\tfilterDuplicates,\n\t\t\t\t);\n\t\t\t\tquickPick.items = quickPick.value\n\t\t\t\t\t? itemsWithoutPinned\n\t\t\t\t\t: itemsWithPinned;\n\t\t\t}\n\t\t}),\n\t);\n\tdisposables.add(\n\t\tquickPick.onDidChangeValue(async (value) => {\n\t\t\tif (quickPick.items === itemsWithPinned && value) {\n\t\t\t\tquickPick.items = itemsWithoutPinned;\n\t\t\t} else if (quickPick.items === itemsWithoutPinned && !value) {\n\t\t\t\tquickPick.items = itemsWithPinned;\n\t\t\t}\n\t\t}),\n\t);\n\n\tquickPick.items = quickPick.value ? itemsWithoutPinned : itemsWithPinned;\n\tquickPick.show();\n\treturn disposables;\n}\n\nfunction _formatPinnedItems(\n\tstorageKey: string,\n\tquickPick: IQuickPick<IQuickPickItem, { useSeparators: true }>,\n\tstorageService: IStorageService,\n\tchangedItem?: IQuickPickItem,\n\tfilterDuplicates?: boolean,\n): QuickPickItem[] {\n\tconst formattedItems: QuickPickItem[] = [];\n\tlet pinnedItems;\n\tif (changedItem) {\n\t\tpinnedItems = updatePinnedItems(\n\t\t\tstorageKey,\n\t\t\tchangedItem,\n\t\t\tstorageService,\n\t\t);\n\t} else {\n\t\tpinnedItems = getPinnedItems(storageKey, storageService);\n\t}\n\tif (pinnedItems.length) {\n\t\tformattedItems.push({\n\t\t\ttype: \"separator\",\n\t\t\tlabel: localize(\"terminal.commands.pinned\", \"pinned\"),\n\t\t});\n\t}\n\tconst pinnedIds = new Set();\n\tfor (const itemToFind of pinnedItems) {\n\t\tconst itemToPin = quickPick.items.find((item) =>\n\t\t\titemsMatch(item, itemToFind),\n\t\t);\n\t\tif (itemToPin) {\n\t\t\tconst pinnedItemId = getItemIdentifier(itemToPin);\n\t\t\tconst pinnedItem: IQuickPickItem = Object.assign(\n\t\t\t\t{} as IQuickPickItem,\n\t\t\t\titemToPin,\n\t\t\t);\n\t\t\tif (!filterDuplicates || !pinnedIds.has(pinnedItemId)) {\n\t\t\t\tpinnedIds.add(pinnedItemId);\n\t\t\t\tupdateButtons(pinnedItem, false);\n\t\t\t\tformattedItems.push(pinnedItem);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (const item of quickPick.items) {\n\t\tupdateButtons(item, true);\n\t\tformattedItems.push(item);\n\t}\n\treturn formattedItems;\n}\n\nfunction getItemIdentifier(item: QuickPickItem): string {\n\treturn item.type === \"separator\"\n\t\t? \"\"\n\t\t: item.id || `${item.label}${item.description}${item.detail}}`;\n}\n\nfunction updateButtons(item: QuickPickItem, removePin: boolean): void {\n\tif (item.type === \"separator\") {\n\t\treturn;\n\t}\n\n\t// remove button classes before adding the new one\n\tconst newButtons =\n\t\titem.buttons?.filter(\n\t\t\t(button) =>\n\t\t\t\tbutton.iconClass && !buttonClasses.includes(button.iconClass),\n\t\t) ?? [];\n\tnewButtons.unshift({\n\t\ticonClass: removePin ? pinButtonClass : pinnedButtonClass,\n\t\ttooltip: removePin\n\t\t\t? localize(\"pinCommand\", \"Pin command\")\n\t\t\t: localize(\"pinnedCommand\", \"Pinned command\"),\n\t\talwaysVisible: false,\n\t});\n\titem.buttons = newButtons;\n}\n\nfunction itemsMatch(itemA: QuickPickItem, itemB: QuickPickItem): boolean {\n\treturn getItemIdentifier(itemA) === getItemIdentifier(itemB);\n}\n\nfunction updatePinnedItems(\n\tstorageKey: string,\n\tchangedItem: IQuickPickItem,\n\tstorageService: IStorageService,\n): IQuickPickItem[] {\n\tconst removePin = changedItem.buttons?.find(\n\t\t(b) => b.iconClass === pinnedButtonClass,\n\t);\n\tlet items = getPinnedItems(storageKey, storageService);\n\tif (removePin) {\n\t\titems = items.filter(\n\t\t\t(item) =>\n\t\t\t\tgetItemIdentifier(item) !== getItemIdentifier(changedItem),\n\t\t);\n\t} else {\n\t\titems.push(changedItem);\n\t}\n\tstorageService.store(\n\t\tstorageKey,\n\t\tJSON.stringify(items),\n\t\tStorageScope.WORKSPACE,\n\t\tStorageTarget.MACHINE,\n\t);\n\treturn items;\n}\n\nfunction getPinnedItems(\n\tstorageKey: string,\n\tstorageService: IStorageService,\n): IQuickPickItem[] {\n\tconst items = storageService.get(storageKey, StorageScope.WORKSPACE);\n\treturn items ? JSON.parse(items) : [];\n}\n"],
  "mappings": "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",
  "names": []
}
