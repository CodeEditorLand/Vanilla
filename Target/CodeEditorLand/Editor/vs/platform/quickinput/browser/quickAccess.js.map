{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/quickinput/browser/quickAccess.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DeferredPromise } from \"../../../base/common/async.js\";\nimport { CancellationTokenSource } from \"../../../base/common/cancellation.js\";\nimport { Event } from \"../../../base/common/event.js\";\nimport {\n\tDisposable,\n\tDisposableStore,\n\ttype IDisposable,\n\ttoDisposable,\n} from \"../../../base/common/lifecycle.js\";\nimport { IInstantiationService } from \"../../instantiation/common/instantiation.js\";\nimport { Registry } from \"../../registry/common/platform.js\";\nimport {\n\tDefaultQuickAccessFilterValue,\n\tExtensions,\n\ttype IQuickAccessController,\n\ttype IQuickAccessOptions,\n\ttype IQuickAccessProvider,\n\ttype IQuickAccessProviderDescriptor,\n\ttype IQuickAccessRegistry,\n} from \"../common/quickAccess.js\";\nimport {\n\tIQuickInputService,\n\ttype IQuickPick,\n\ttype IQuickPickItem,\n\tItemActivation,\n} from \"../common/quickInput.js\";\n\nexport class QuickAccessController\n\textends Disposable\n\timplements IQuickAccessController\n{\n\tprivate readonly registry = Registry.as<IQuickAccessRegistry>(\n\t\tExtensions.Quickaccess,\n\t);\n\tprivate readonly mapProviderToDescriptor = new Map<\n\t\tIQuickAccessProviderDescriptor,\n\t\tIQuickAccessProvider\n\t>();\n\n\tprivate readonly lastAcceptedPickerValues = new Map<\n\t\tIQuickAccessProviderDescriptor,\n\t\tstring\n\t>();\n\n\tprivate visibleQuickAccess:\n\t\t| {\n\t\t\t\treadonly picker: IQuickPick<\n\t\t\t\t\tIQuickPickItem,\n\t\t\t\t\t{ useSeparators: true }\n\t\t\t\t>;\n\t\t\t\treadonly descriptor: IQuickAccessProviderDescriptor | undefined;\n\t\t\t\treadonly value: string;\n\t\t  }\n\t\t| undefined = undefined;\n\n\tconstructor(\n\t\t@IQuickInputService\n\t\tprivate readonly quickInputService: IQuickInputService,\n\t\t@IInstantiationService\n\t\tprivate readonly instantiationService: IInstantiationService,\n\t) {\n\t\tsuper();\n\t}\n\n\tpick(\n\t\tvalue = \"\",\n\t\toptions?: IQuickAccessOptions,\n\t): Promise<IQuickPickItem[] | undefined> {\n\t\treturn this.doShowOrPick(value, true, options);\n\t}\n\n\tshow(value = \"\", options?: IQuickAccessOptions): void {\n\t\tthis.doShowOrPick(value, false, options);\n\t}\n\n\tprivate doShowOrPick(\n\t\tvalue: string,\n\t\tpick: true,\n\t\toptions?: IQuickAccessOptions,\n\t): Promise<IQuickPickItem[] | undefined>;\n\tprivate doShowOrPick(\n\t\tvalue: string,\n\t\tpick: false,\n\t\toptions?: IQuickAccessOptions,\n\t): void;\n\tprivate doShowOrPick(\n\t\tvalue: string,\n\t\tpick: boolean,\n\t\toptions?: IQuickAccessOptions,\n\t): Promise<IQuickPickItem[] | undefined> | void {\n\t\t// Find provider for the value to show\n\t\tconst [provider, descriptor] = this.getOrInstantiateProvider(\n\t\t\tvalue,\n\t\t\toptions?.enabledProviderPrefixes,\n\t\t);\n\n\t\t// Return early if quick access is already showing on that same prefix\n\t\tconst visibleQuickAccess = this.visibleQuickAccess;\n\t\tconst visibleDescriptor = visibleQuickAccess?.descriptor;\n\t\tif (\n\t\t\tvisibleQuickAccess &&\n\t\t\tdescriptor &&\n\t\t\tvisibleDescriptor === descriptor\n\t\t) {\n\t\t\t// Apply value only if it is more specific than the prefix\n\t\t\t// from the provider and we are not instructed to preserve\n\t\t\tif (value !== descriptor.prefix && !options?.preserveValue) {\n\t\t\t\tvisibleQuickAccess.picker.value = value;\n\t\t\t}\n\n\t\t\t// Always adjust selection\n\t\t\tthis.adjustValueSelection(\n\t\t\t\tvisibleQuickAccess.picker,\n\t\t\t\tdescriptor,\n\t\t\t\toptions,\n\t\t\t);\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Rewrite the filter value based on certain rules unless disabled\n\t\tif (descriptor && !options?.preserveValue) {\n\t\t\tlet newValue: string | undefined;\n\n\t\t\t// If we have a visible provider with a value, take it's filter value but\n\t\t\t// rewrite to new provider prefix in case they differ\n\t\t\tif (\n\t\t\t\tvisibleQuickAccess &&\n\t\t\t\tvisibleDescriptor &&\n\t\t\t\tvisibleDescriptor !== descriptor\n\t\t\t) {\n\t\t\t\tconst newValueCandidateWithoutPrefix =\n\t\t\t\t\tvisibleQuickAccess.value.substr(\n\t\t\t\t\t\tvisibleDescriptor.prefix.length,\n\t\t\t\t\t);\n\t\t\t\tif (newValueCandidateWithoutPrefix) {\n\t\t\t\t\tnewValue = `${descriptor.prefix}${newValueCandidateWithoutPrefix}`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Otherwise, take a default value as instructed\n\t\t\tif (!newValue) {\n\t\t\t\tconst defaultFilterValue = provider?.defaultFilterValue;\n\t\t\t\tif (defaultFilterValue === DefaultQuickAccessFilterValue.LAST) {\n\t\t\t\t\tnewValue = this.lastAcceptedPickerValues.get(descriptor);\n\t\t\t\t} else if (typeof defaultFilterValue === \"string\") {\n\t\t\t\t\tnewValue = `${descriptor.prefix}${defaultFilterValue}`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (typeof newValue === \"string\") {\n\t\t\t\tvalue = newValue;\n\t\t\t}\n\t\t}\n\n\t\t// Store the existing selection if there was one.\n\t\tconst visibleSelection = visibleQuickAccess?.picker?.valueSelection;\n\t\tconst visibleValue = visibleQuickAccess?.picker?.value;\n\n\t\t// Create a picker for the provider to use with the initial value\n\t\t// and adjust the filtering to exclude the prefix from filtering\n\t\tconst disposables = new DisposableStore();\n\t\tconst picker = disposables.add(\n\t\t\tthis.quickInputService.createQuickPick({ useSeparators: true }),\n\t\t);\n\t\tpicker.value = value;\n\t\tthis.adjustValueSelection(picker, descriptor, options);\n\t\tpicker.placeholder = options?.placeholder ?? descriptor?.placeholder;\n\t\tpicker.quickNavigate = options?.quickNavigateConfiguration;\n\t\tpicker.hideInput = !!picker.quickNavigate && !visibleQuickAccess; // only hide input if there was no picker opened already\n\t\tif (\n\t\t\ttypeof options?.itemActivation === \"number\" ||\n\t\t\toptions?.quickNavigateConfiguration\n\t\t) {\n\t\t\tpicker.itemActivation =\n\t\t\t\toptions?.itemActivation ??\n\t\t\t\tItemActivation.SECOND /* quick nav is always second */;\n\t\t}\n\t\tpicker.contextKey = descriptor?.contextKey;\n\t\tpicker.filterValue = (value: string) =>\n\t\t\tvalue.substring(descriptor ? descriptor.prefix.length : 0);\n\n\t\t// Pick mode: setup a promise that can be resolved\n\t\t// with the selected items and prevent execution\n\t\tlet pickPromise: DeferredPromise<IQuickPickItem[]> | undefined;\n\t\tif (pick) {\n\t\t\tpickPromise = new DeferredPromise<IQuickPickItem[]>();\n\t\t\tdisposables.add(\n\t\t\t\tEvent.once(picker.onWillAccept)((e) => {\n\t\t\t\t\te.veto();\n\t\t\t\t\tpicker.hide();\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\t// Register listeners\n\t\tdisposables.add(\n\t\t\tthis.registerPickerListeners(\n\t\t\t\tpicker,\n\t\t\t\tprovider,\n\t\t\t\tdescriptor,\n\t\t\t\tvalue,\n\t\t\t\toptions,\n\t\t\t),\n\t\t);\n\n\t\t// Ask provider to fill the picker as needed if we have one\n\t\t// and pass over a cancellation token that will indicate when\n\t\t// the picker is hiding without a pick being made.\n\t\tconst cts = disposables.add(new CancellationTokenSource());\n\t\tif (provider) {\n\t\t\tdisposables.add(\n\t\t\t\tprovider.provide(picker, cts.token, options?.providerOptions),\n\t\t\t);\n\t\t}\n\n\t\t// Finally, trigger disposal and cancellation when the picker\n\t\t// hides depending on items selected or not.\n\t\tEvent.once(picker.onDidHide)(() => {\n\t\t\tif (picker.selectedItems.length === 0) {\n\t\t\t\tcts.cancel();\n\t\t\t}\n\n\t\t\t// Start to dispose once picker hides\n\t\t\tdisposables.dispose();\n\n\t\t\t// Resolve pick promise with selected items\n\t\t\tpickPromise?.complete(picker.selectedItems.slice(0));\n\t\t});\n\n\t\t// Finally, show the picker. This is important because a provider\n\t\t// may not call this and then our disposables would leak that rely\n\t\t// on the onDidHide event.\n\t\tpicker.show();\n\n\t\t// If the previous picker had a selection and the value is unchanged, we should set that in the new picker.\n\t\tif (visibleSelection && visibleValue === value) {\n\t\t\tpicker.valueSelection = visibleSelection;\n\t\t}\n\n\t\t// Pick mode: return with promise\n\t\tif (pick) {\n\t\t\treturn pickPromise?.p;\n\t\t}\n\t}\n\n\tprivate adjustValueSelection(\n\t\tpicker: IQuickPick<IQuickPickItem, { useSeparators: true }>,\n\t\tdescriptor?: IQuickAccessProviderDescriptor,\n\t\toptions?: IQuickAccessOptions,\n\t): void {\n\t\tlet valueSelection: [number, number];\n\n\t\t// Preserve: just always put the cursor at the end\n\t\tif (options?.preserveValue) {\n\t\t\tvalueSelection = [picker.value.length, picker.value.length];\n\t\t}\n\n\t\t// Otherwise: select the value up until the prefix\n\t\telse {\n\t\t\tvalueSelection = [\n\t\t\t\tdescriptor?.prefix.length ?? 0,\n\t\t\t\tpicker.value.length,\n\t\t\t];\n\t\t}\n\n\t\tpicker.valueSelection = valueSelection;\n\t}\n\n\tprivate registerPickerListeners(\n\t\tpicker: IQuickPick<IQuickPickItem, { useSeparators: true }>,\n\t\tprovider: IQuickAccessProvider | undefined,\n\t\tdescriptor: IQuickAccessProviderDescriptor | undefined,\n\t\tvalue: string,\n\t\toptions?: IQuickAccessOptions,\n\t): IDisposable {\n\t\tconst disposables = new DisposableStore();\n\n\t\t// Remember as last visible picker and clean up once picker get's disposed\n\t\tconst visibleQuickAccess = (this.visibleQuickAccess = {\n\t\t\tpicker,\n\t\t\tdescriptor,\n\t\t\tvalue,\n\t\t});\n\t\tdisposables.add(\n\t\t\ttoDisposable(() => {\n\t\t\t\tif (visibleQuickAccess === this.visibleQuickAccess) {\n\t\t\t\t\tthis.visibleQuickAccess = undefined;\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\n\t\t// Whenever the value changes, check if the provider has\n\t\t// changed and if so - re-create the picker from the beginning\n\t\tdisposables.add(\n\t\t\tpicker.onDidChangeValue((value) => {\n\t\t\t\tconst [providerForValue] = this.getOrInstantiateProvider(\n\t\t\t\t\tvalue,\n\t\t\t\t\toptions?.enabledProviderPrefixes,\n\t\t\t\t);\n\t\t\t\tif (providerForValue !== provider) {\n\t\t\t\t\tthis.show(value, {\n\t\t\t\t\t\tenabledProviderPrefixes:\n\t\t\t\t\t\t\toptions?.enabledProviderPrefixes,\n\t\t\t\t\t\t// do not rewrite value from user typing!\n\t\t\t\t\t\tpreserveValue: true,\n\t\t\t\t\t\t// persist the value of the providerOptions from the original showing\n\t\t\t\t\t\tproviderOptions: options?.providerOptions,\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tvisibleQuickAccess.value = value; // remember the value in our visible one\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\n\t\t// Remember picker input for future use when accepting\n\t\tif (descriptor) {\n\t\t\tdisposables.add(\n\t\t\t\tpicker.onDidAccept(() => {\n\t\t\t\t\tthis.lastAcceptedPickerValues.set(descriptor, picker.value);\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\treturn disposables;\n\t}\n\n\tprivate getOrInstantiateProvider(\n\t\tvalue: string,\n\t\tenabledProviderPrefixes?: string[],\n\t): [\n\t\tIQuickAccessProvider | undefined,\n\t\tIQuickAccessProviderDescriptor | undefined,\n\t] {\n\t\tconst providerDescriptor = this.registry.getQuickAccessProvider(value);\n\t\tif (\n\t\t\t!providerDescriptor ||\n\t\t\t(enabledProviderPrefixes &&\n\t\t\t\t!enabledProviderPrefixes?.includes(providerDescriptor.prefix))\n\t\t) {\n\t\t\treturn [undefined, undefined];\n\t\t}\n\n\t\tlet provider = this.mapProviderToDescriptor.get(providerDescriptor);\n\t\tif (!provider) {\n\t\t\tprovider = this.instantiationService.createInstance(\n\t\t\t\tproviderDescriptor.ctor,\n\t\t\t);\n\t\t\tthis.mapProviderToDescriptor.set(providerDescriptor, provider);\n\t\t}\n\n\t\treturn [provider, providerDescriptor];\n\t}\n}\n"],
  "mappings": "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",
  "names": ["value"]
}
