import{distinct as z}from"../../../base/common/arrays.js";import"../../../base/common/collections.js";import{parse as g,visit as U}from"../../../base/common/json.js";import{applyEdits as D,setProperty as J,withFormatting as G}from"../../../base/common/jsonEdit.js";import{getEOL as H}from"../../../base/common/jsonFormatter.js";import*as B from"../../../base/common/objects.js";import"../../configuration/common/configuration.js";import*as h from"./content.js";import{getDisallowedIgnoredSettings as Q}from"./userDataSync.js";function ae(n,t,e){let r=[];e?r=X(e):r=R(t);const c=[],u=[...Q()];if(Array.isArray(r))for(const i of r)i.startsWith("-")?u.push(i.substring(1)):c.push(i);return z([...n,...c].filter(i=>!u.includes(i)))}function R(n){let t=n.inspect("settingsSync.ignoredSettings").userValue;return t!==void 0||(t=n.inspect("sync.ignoredSettings").userValue,t!==void 0)?t:n.getValue("settingsSync.ignoredSettings")||[]}function X(n){const t=g(n);return t?t["settingsSync.ignoredSettings"]||t["sync.ignoredSettings"]||[]:[]}function ge(n,t){const e=g(n)||{};let r="{}";for(const c of Object.keys(e)){const u=J(r,[c],e[c],t);r=D(r,u)}return r}function C(n,t,e,r){if(e.length){const c=I(t),u=g(t)||{},i=g(n);if(!i)return n;const d=[];for(const s of e){const o=u[s],l=i[s];o===void 0?n=h.edit(n,[s],void 0,r):l!==void 0?n=h.edit(n,[s],o,r):d.push(O(s,c))}d.sort((s,o)=>s.startOffset-o.startOffset),d.forEach(s=>n=L(s.setting.key,t,n,r))}return n}function me(n,t,e,r,c,u){const i=C(n,t,r,u),d=e!==i,s=e!==t;if(!d&&!s)return{conflictsSettings:[],localContent:null,remoteContent:null,hasConflicts:!1};if(d&&!s)return{conflictsSettings:[],localContent:null,remoteContent:i,hasConflicts:!1};if(s&&!d)return{conflictsSettings:[],localContent:C(t,n,r,u),remoteContent:null,hasConflicts:!1};if(e===null&&Y(n)){const f=A(n,t,r)?null:C(t,n,r,u);return{conflictsSettings:[],localContent:f,remoteContent:null,hasConflicts:!1}}let o=n,l=t;const a=g(n),m=g(t),b=e?g(e):null,E=r.reduce((f,v)=>(f.add(v),f),new Set),k=j(a,m,E),y=j(b,a,E),S=j(b,m,E),V=new Map,N=new Set,p=f=>{N.add(f);const v=c.filter(({key:$})=>$===f)[0];v?(o=h.edit(o,[f],v.value,u),l=h.edit(l,[f],v.value,u)):V.set(f,{key:f,localValue:a[f],remoteValue:m[f]})};for(const f of y.removed.values())S.updated.has(f)?p(f):l=h.edit(l,[f],void 0,u);for(const f of S.removed.values())N.has(f)||(y.updated.has(f)?p(f):o=h.edit(o,[f],void 0,u));for(const f of y.updated.values())N.has(f)||(S.updated.has(f)?k.updated.has(f)&&p(f):l=h.edit(l,[f],a[f],u));for(const f of S.updated.values())N.has(f)||(y.updated.has(f)?k.updated.has(f)&&p(f):o=h.edit(o,[f],m[f],u));for(const f of y.added.values())N.has(f)||(S.added.has(f)?k.updated.has(f)&&p(f):l=L(f,o,l,u));for(const f of S.added.values())N.has(f)||(y.added.has(f)?k.updated.has(f)&&p(f):o=L(f,l,o,u));const P=V.size>0||!A(o,l,r),q=P||!A(o,n,[]),W=P||!A(l,t,[]);return{localContent:q?o:null,remoteContent:W?l:null,conflictsSettings:[...V.values()],hasConflicts:P}}function A(n,t,e){if(n===t)return!0;const r=g(n),c=g(t),u=e.reduce((s,o)=>(s.add(o),s),new Set),i=I(n).filter(s=>!(s.setting&&u.has(s.setting.key))),d=I(t).filter(s=>!(s.setting&&u.has(s.setting.key)));if(i.length!==d.length)return!1;for(let s=0;s<i.length;s++){const o=i[s],l=d[s];if(o.setting&&l.setting){if(o.setting.key!==l.setting.key||!B.equals(r[o.setting.key],c[o.setting.key]))return!1}else if(!o.setting&&!l.setting){if(o.value!==l.value)return!1}else return!1}return!0}function Y(n){return n?I(n).length===0:!0}function j(n,t,e){const r=n?Object.keys(n).filter(s=>!e.has(s)):[],c=Object.keys(t).filter(s=>!e.has(s)),u=c.filter(s=>!r.includes(s)).reduce((s,o)=>(s.add(o),s),new Set),i=r.filter(s=>!c.includes(s)).reduce((s,o)=>(s.add(o),s),new Set),d=new Set;if(n)for(const s of r){if(i.has(s))continue;const o=n[s],l=t[s];B.equals(o,l)||d.add(s)}return{added:u,removed:i,updated:d}}function L(n,t,e,r){const c=g(t),u=I(t),i=I(e),d=Z(n,u,i);return _(e,n,c[n],d,i,r)}function Z(n,t,e){const r=t.findIndex(u=>u.setting?.key===n),c=t[r-1];if(c){if(c.setting){const i=O(c.setting.key,e);if(i)return{index:e.indexOf(i),insertAfter:!0}}else{const i=M(r,t);if(i){const d=O(i.setting.key,e);if(d){const s=w(e.indexOf(d),e),o=x(t,i,t[r]);if(s){const l=x(e,d,s),a=F(o,l);return a?{index:e.indexOf(a),insertAfter:!0}:{index:e.indexOf(s),insertAfter:!1}}else{const l=x(e,d,e[e.length-1]),a=F(o,l);return a?{index:e.indexOf(a),insertAfter:!0}:{index:e.length-1,insertAfter:!0}}}}}const u=t[r+1];if(u)if(u.setting){const i=O(u.setting.key,e);if(i)return{index:e.indexOf(i),insertAfter:!1}}else{const i=w(r,t);if(i){const d=O(i.setting.key,e);if(d){const s=M(e.indexOf(d),e),o=x(t,t[r],i);if(s){const l=x(e,s,d),a=F(o.reverse(),l.reverse());return a?{index:e.indexOf(a),insertAfter:!1}:{index:e.indexOf(s),insertAfter:!0}}else{const l=x(e,e[0],d),a=F(o.reverse(),l.reverse());return a?{index:e.indexOf(a),insertAfter:!1}:{index:0,insertAfter:!1}}}}}}return{index:e.length-1,insertAfter:!0}}function _(n,t,e,r,c,u){let i;return r.index===-1?i=J(n,[t],e,u):i=K(n,t,e,r,c,u).map(d=>G(n,d,u)[0]),D(n,i)}function K(n,t,e,r,c,u){const i=`${JSON.stringify(t)}: ${JSON.stringify(e)}`,d=H(u,n),s=c[r.index];if(r.insertAfter){const o=[];if(s.setting)o.push({offset:s.endOffset,length:0,content:","+i});else{const l=w(r.index,c),a=M(r.index,c),m=a?.setting?.commaOffset;a&&m===void 0&&o.push({offset:a.endOffset,length:0,content:","});const b=m!==void 0&&m>s.endOffset;o.push({offset:b?m+1:s.endOffset,length:0,content:l?d+i+",":d+i})}return o}else{if(s.setting)return[{offset:s.startOffset,length:0,content:i+","}];const o=(c[r.index-1]&&!c[r.index-1].setting?d:"")+i+(w(r.index,c)?",":"")+d;return[{offset:s.startOffset,length:0,content:o}]}}function O(n,t){return t.filter(e=>e.setting?.key===n)[0]}function M(n,t){for(let e=n-1;e>=0;e--)if(t[e].setting)return t[e]}function w(n,t){for(let e=n+1;e<t.length;e++)if(t[e].setting)return t[e]}function x(n,t,e){const r=n.indexOf(t),c=n.indexOf(e);return n.filter((u,i)=>r<i&&i<c)}function F(n,t){if(n.length&&t.length){let e=0;for(;e<t.length&&e<n.length;e++)if(n[e].value!==t[e].value)return t[e-1];return t[e-1]}}function I(n){const t=[];let e=-1,r,c;return U(n,{onObjectBegin:i=>{e++},onObjectProperty:(i,d,s)=>{e===0&&(r=d,c=i)},onObjectEnd:(i,d)=>{e--,e===0&&t.push({startOffset:r,endOffset:i+d,value:n.substring(r,i+d),setting:{key:c,commaOffset:void 0}})},onArrayBegin:(i,d)=>{e++},onArrayEnd:(i,d)=>{e--,e===0&&t.push({startOffset:r,endOffset:i+d,value:n.substring(r,i+d),setting:{key:c,commaOffset:void 0}})},onLiteralValue:(i,d,s)=>{e===0&&t.push({startOffset:r,endOffset:d+s,value:n.substring(r,d+s),setting:{key:c,commaOffset:void 0}})},onSeparator:(i,d,s)=>{if(e===0&&i===","){let o=t.length-1;for(;o>=0&&!t[o].setting;o--);const l=t[o];l&&t.splice(o,1,{startOffset:l.startOffset,endOffset:l.endOffset,value:l.value,setting:{key:l.setting.key,commaOffset:d}})}},onComment:(i,d)=>{e===0&&t.push({startOffset:i,endOffset:i+d,value:n.substring(i,i+d)})}}),t}export{L as addSetting,ae as getIgnoredSettings,Y as isEmpty,me as merge,ge as removeComments,C as updateIgnoredSettings};
