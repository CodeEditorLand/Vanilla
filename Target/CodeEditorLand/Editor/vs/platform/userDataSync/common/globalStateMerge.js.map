{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/userDataSync/common/globalStateMerge.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IStringDictionary } from '../../../base/common/collections.js';\nimport * as objects from '../../../base/common/objects.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { IStorageValue, SYNC_SERVICE_URL_TYPE } from './userDataSync.js';\n\nexport interface IMergeResult {\n\tlocal: { added: IStringDictionary<IStorageValue>; removed: string[]; updated: IStringDictionary<IStorageValue> };\n\tremote: { added: string[]; removed: string[]; updated: string[]; all: IStringDictionary<IStorageValue> | null };\n}\n\nexport function merge(localStorage: IStringDictionary<IStorageValue>, remoteStorage: IStringDictionary<IStorageValue> | null, baseStorage: IStringDictionary<IStorageValue> | null, storageKeys: { machine: ReadonlyArray<string>; unregistered: ReadonlyArray<string> }, logService: ILogService): IMergeResult {\n\tif (!remoteStorage) {\n\t\treturn { remote: { added: Object.keys(localStorage), removed: [], updated: [], all: Object.keys(localStorage).length > 0 ? localStorage : null }, local: { added: {}, removed: [], updated: {} } };\n\t}\n\n\tconst localToRemote = compare(localStorage, remoteStorage);\n\tif (localToRemote.added.size === 0 && localToRemote.removed.size === 0 && localToRemote.updated.size === 0) {\n\t\t// No changes found between local and remote.\n\t\treturn { remote: { added: [], removed: [], updated: [], all: null }, local: { added: {}, removed: [], updated: {} } };\n\t}\n\n\tconst baseToRemote = baseStorage ? compare(baseStorage, remoteStorage) : { added: Object.keys(remoteStorage).reduce((r, k) => { r.add(k); return r; }, new Set<string>()), removed: new Set<string>(), updated: new Set<string>() };\n\tconst baseToLocal = baseStorage ? compare(baseStorage, localStorage) : { added: Object.keys(localStorage).reduce((r, k) => { r.add(k); return r; }, new Set<string>()), removed: new Set<string>(), updated: new Set<string>() };\n\n\tconst local: { added: IStringDictionary<IStorageValue>; removed: string[]; updated: IStringDictionary<IStorageValue> } = { added: {}, removed: [], updated: {} };\n\tconst remote: IStringDictionary<IStorageValue> = objects.deepClone(remoteStorage);\n\n\tconst isFirstTimeSync = !baseStorage;\n\n\t// Added in local\n\tfor (const key of baseToLocal.added.values()) {\n\t\t// If syncing for first time remote value gets precedence always,\n\t\t// except for sync service type key - local value takes precedence for this key\n\t\tif (key !== SYNC_SERVICE_URL_TYPE && isFirstTimeSync && baseToRemote.added.has(key)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tremote[key] = localStorage[key];\n\t}\n\n\t// Updated in local\n\tfor (const key of baseToLocal.updated.values()) {\n\t\tremote[key] = localStorage[key];\n\t}\n\n\t// Removed in local\n\tfor (const key of baseToLocal.removed.values()) {\n\t\t// Do not remove from remote if key is not registered.\n\t\tif (storageKeys.unregistered.includes(key)) {\n\t\t\tcontinue;\n\t\t}\n\t\tdelete remote[key];\n\t}\n\n\t// Added in remote\n\tfor (const key of baseToRemote.added.values()) {\n\t\tconst remoteValue = remoteStorage[key];\n\t\tif (storageKeys.machine.includes(key)) {\n\t\t\tlogService.info(`GlobalState: Skipped adding ${key} in local storage because it is declared as machine scoped.`);\n\t\t\tcontinue;\n\t\t}\n\t\t// Skip if the value is also added in local from the time it is last synced\n\t\tif (baseStorage && baseToLocal.added.has(key)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst localValue = localStorage[key];\n\t\tif (localValue && localValue.value === remoteValue.value) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Local sync service type value takes precedence if syncing for first time\n\t\tif (key === SYNC_SERVICE_URL_TYPE && isFirstTimeSync && baseToLocal.added.has(key)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (localValue) {\n\t\t\tlocal.updated[key] = remoteValue;\n\t\t} else {\n\t\t\tlocal.added[key] = remoteValue;\n\t\t}\n\t}\n\n\t// Updated in Remote\n\tfor (const key of baseToRemote.updated.values()) {\n\t\tconst remoteValue = remoteStorage[key];\n\t\tif (storageKeys.machine.includes(key)) {\n\t\t\tlogService.info(`GlobalState: Skipped updating ${key} in local storage because it is declared as machine scoped.`);\n\t\t\tcontinue;\n\t\t}\n\t\t// Skip if the value is also updated or removed in local\n\t\tif (baseToLocal.updated.has(key) || baseToLocal.removed.has(key)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst localValue = localStorage[key];\n\t\tif (localValue && localValue.value === remoteValue.value) {\n\t\t\tcontinue;\n\t\t}\n\t\tlocal.updated[key] = remoteValue;\n\t}\n\n\t// Removed in remote\n\tfor (const key of baseToRemote.removed.values()) {\n\t\tif (storageKeys.machine.includes(key)) {\n\t\t\tlogService.trace(`GlobalState: Skipped removing ${key} in local storage because it is declared as machine scoped.`);\n\t\t\tcontinue;\n\t\t}\n\t\t// Skip if the value is also updated or removed in local\n\t\tif (baseToLocal.updated.has(key) || baseToLocal.removed.has(key)) {\n\t\t\tcontinue;\n\t\t}\n\t\tlocal.removed.push(key);\n\t}\n\n\tconst result = compare(remoteStorage, remote);\n\treturn { local, remote: { added: [...result.added], updated: [...result.updated], removed: [...result.removed], all: result.added.size === 0 && result.removed.size === 0 && result.updated.size === 0 ? null : remote } };\n}\n\nfunction compare(from: IStringDictionary<any>, to: IStringDictionary<any>): { added: Set<string>; removed: Set<string>; updated: Set<string> } {\n\tconst fromKeys = Object.keys(from);\n\tconst toKeys = Object.keys(to);\n\tconst added = toKeys.filter(key => !fromKeys.includes(key)).reduce((r, key) => { r.add(key); return r; }, new Set<string>());\n\tconst removed = fromKeys.filter(key => !toKeys.includes(key)).reduce((r, key) => { r.add(key); return r; }, new Set<string>());\n\tconst updated: Set<string> = new Set<string>();\n\n\tfor (const key of fromKeys) {\n\t\tif (removed.has(key)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst value1 = from[key];\n\t\tconst value2 = to[key];\n\t\tif (!objects.equals(value1, value2)) {\n\t\t\tupdated.add(key);\n\t\t}\n\t}\n\n\treturn { added, removed, updated };\n}\n"],
  "mappings": "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",
  "names": []
}
