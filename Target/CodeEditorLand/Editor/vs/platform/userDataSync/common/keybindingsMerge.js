import{equals as v}from"../../../base/common/arrays.js";import{parse as x}from"../../../base/common/json.js";import*as D from"../../../base/common/objects.js";import{ContextKeyExpr as M}from"../../contextkey/common/contextkey.js";import*as K from"./content.js";function w(t){return x(t)||[]}async function W(t,i,n,r,d){const a=w(t),s=w(i),e=n?w(n):null,o=[...a,...s,...e||[]].map(u=>u.key),g=await d.resolveUserBindings(o),c=j(a,s,e,g);if(!c.hasLocalForwarded&&!c.hasRemoteForwarded)return{mergeContent:t,hasChanges:!1,hasConflicts:!1};if(!c.hasLocalForwarded&&c.hasRemoteForwarded)return{mergeContent:i,hasChanges:!0,hasConflicts:!1};if(c.hasLocalForwarded&&!c.hasRemoteForwarded)return{mergeContent:t,hasChanges:!0,hasConflicts:!1};const l=k(a),m=k(s),S=e?k(e):null,I=B(l,m,g),p=S?B(S,l,g):{added:[...l.keys()].reduce((u,y)=>(u.add(y),u),new Set),removed:new Set,updated:new Set},b=S?B(S,m,g):{added:[...m.keys()].reduce((u,y)=>(u.add(y),u),new Set),removed:new Set,updated:new Set},f=z(I,p,b);let h=t;for(const u of f.removed.values())f.conflicts.has(u)||(h=q(h,u,r));for(const u of f.added.values()){if(f.conflicts.has(u))continue;const y=m.get(u);if(y.some(F=>F.command!==`-${u}`&&c.conflicts.has(g[F.key]))){f.conflicts.add(u);continue}h=$(h,y,r)}for(const u of f.updated.values()){if(f.conflicts.has(u))continue;const y=m.get(u);if(y.some(F=>F.command!==`-${u}`&&c.conflicts.has(g[F.key]))){f.conflicts.add(u);continue}h=O(h,u,y,r)}return{mergeContent:h,hasChanges:!0,hasConflicts:f.conflicts.size>0}}function z(t,i,n){const r=new Set,d=new Set,a=new Set,s=new Set;for(const e of i.removed.values())n.updated.has(e)&&s.add(e);for(const e of n.removed.values())s.has(e)||(i.updated.has(e)?s.add(e):d.add(e));for(const e of i.added.values())s.has(e)||n.added.has(e)&&t.updated.has(e)&&s.add(e);for(const e of n.added.values())s.has(e)||(i.added.has(e)?t.updated.has(e)&&s.add(e):r.add(e));for(const e of i.updated.values())s.has(e)||n.updated.has(e)&&t.updated.has(e)&&s.add(e);for(const e of n.updated.values())s.has(e)||(i.updated.has(e)?t.updated.has(e)&&s.add(e):a.add(e));return{added:r,removed:d,updated:a,conflicts:s}}function j(t,i,n,r){const d=new Set,a=U(t,r),s=U(i,r),e=n?U(n,r):null,o=C(a,s);if(o.added.size===0&&o.removed.size===0&&o.updated.size===0)return{hasLocalForwarded:!1,hasRemoteForwarded:!1,added:d,removed:d,updated:d,conflicts:d};const g=e?C(e,a):{added:[...a.keys()].reduce((p,b)=>(p.add(b),p),new Set),removed:new Set,updated:new Set};if(g.added.size===0&&g.removed.size===0&&g.updated.size===0)return{hasLocalForwarded:!1,hasRemoteForwarded:!0,added:d,removed:d,updated:d,conflicts:d};const c=e?C(e,s):{added:[...s.keys()].reduce((p,b)=>(p.add(b),p),new Set),removed:new Set,updated:new Set};if(c.added.size===0&&c.removed.size===0&&c.updated.size===0)return{hasLocalForwarded:!0,hasRemoteForwarded:!1,added:d,removed:d,updated:d,conflicts:d};const{added:l,removed:m,updated:S,conflicts:I}=z(o,g,c);return{hasLocalForwarded:!0,hasRemoteForwarded:!0,added:l,removed:m,updated:S,conflicts:I}}function U(t,i){const n=new Map;for(const r of t){const d=i[r.key];let a=n.get(d);a||(a=[],n.set(d,a)),a.push(r)}return n}function k(t){const i=new Map;for(const n of t){const r=n.command[0]==="-"?n.command.substring(1):n.command;let d=i.get(r);d||(d=[],i.set(r,d)),d.push(n)}return i}function C(t,i){const n=[...t.keys()],r=[...i.keys()],d=r.filter(e=>!n.includes(e)).reduce((e,o)=>(e.add(o),e),new Set),a=n.filter(e=>!r.includes(e)).reduce((e,o)=>(e.add(o),e),new Set),s=new Set;for(const e of n){if(a.has(e))continue;const o=t.get(e).map(c=>({...c,key:e})),g=i.get(e).map(c=>({...c,key:e}));v(o,g,(c,l)=>R(c,l))||s.add(e)}return{added:d,removed:a,updated:s}}function B(t,i,n){const r=[...t.keys()],d=[...i.keys()],a=d.filter(o=>!r.includes(o)).reduce((o,g)=>(o.add(g),o),new Set),s=r.filter(o=>!d.includes(o)).reduce((o,g)=>(o.add(g),o),new Set),e=new Set;for(const o of r){if(s.has(o))continue;const g=t.get(o).map(l=>({...l,key:n[l.key]})),c=i.get(o).map(l=>({...l,key:n[l.key]}));L(g,c)||e.add(o)}return{added:a,removed:s,updated:e}}function L(t,i){return!(!v(t.filter(({command:n})=>n[0]!=="-"),i.filter(({command:n})=>n[0]!=="-"),(n,r)=>R(n,r))||!v(t.filter(({command:n})=>n[0]==="-"),i.filter(({command:n})=>n[0]==="-"),(n,r)=>R(n,r)))}function R(t,i){if(t.command!==i.command||t.key!==i.key)return!1;const n=M.deserialize(t.when),r=M.deserialize(i.when);return!(n&&!r||!n&&r||n&&r&&!n.equals(r)||!D.equals(t.args,i.args))}function $(t,i,n){for(const r of i)t=K.edit(t,[-1],r,n);return t}function q(t,i,n){const r=w(t);for(let d=r.length-1;d>=0;d--)(r[d].command===i||r[d].command===`-${i}`)&&(t=K.edit(t,[d],void 0,n));return t}function O(t,i,n,r){const d=w(t),a=d.findIndex(s=>s.command===i||s.command===`-${i}`);for(let s=d.length-1;s>=0;s--)(d[s].command===i||d[s].command===`-${i}`)&&(t=K.edit(t,[s],void 0,r));for(let s=n.length-1;s>=0;s--)t=K.edit(t,[a],n[s],r);return t}export{W as merge};
