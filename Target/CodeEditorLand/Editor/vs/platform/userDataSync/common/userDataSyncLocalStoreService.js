var g=Object.defineProperty;var y=Object.getOwnPropertyDescriptor;var f=(l,s,r,e)=>{for(var i=e>1?void 0:e?y(s,r):s,n=l.length-1,t;n>=0;n--)(t=l[n])&&(i=(e?t(s,r,i):t(i))||i);return e&&i&&g(s,r,i),i},a=(l,s)=>(r,e)=>s(r,e,l);import{Promises as d}from"../../../base/common/async.js";import{VSBuffer as I}from"../../../base/common/buffer.js";import{toLocalISOString as R}from"../../../base/common/date.js";import{Disposable as D}from"../../../base/common/lifecycle.js";import{joinPath as m}from"../../../base/common/resources.js";import{IConfigurationService as b}from"../../configuration/common/configuration.js";import{IEnvironmentService as U}from"../../environment/common/environment.js";import{FileOperationResult as p,IFileService as w,toFileOperationResult as v}from"../../files/common/files.js";import{IUserDataProfilesService as F}from"../../userDataProfile/common/userDataProfile.js";import{ALL_SYNC_RESOURCES as S,IUserDataSyncLogService as P}from"./userDataSync.js";let u=class extends D{constructor(r,e,i,n,t){super();this.environmentService=r;this.fileService=e;this.configurationService=i;this.logService=n;this.userDataProfilesService=t;this.cleanUp()}_serviceBrand;async cleanUp(){for(const e of this.userDataProfilesService.profiles)for(const i of S)try{await this.cleanUpBackup(this.getResourceBackupHome(i,e.isDefault?void 0:e.id))}catch(n){this.logService.error(n)}let r;try{r=await this.fileService.resolve(this.environmentService.userDataSyncHome)}catch(e){v(e)!==p.FILE_NOT_FOUND&&this.logService.error(e);return}if(r.children){for(const e of r.children)if(e.isDirectory&&!S.includes(e.name)&&!this.userDataProfilesService.profiles.some(i=>i.id===e.name))try{this.logService.info("Deleting non existing profile from backup",e.resource.path),await this.fileService.del(e.resource,{recursive:!0})}catch(i){this.logService.error(i)}}}async getAllResourceRefs(r,e,i){const n=this.getResourceBackupHome(r,e,i);try{const t=await this.fileService.resolve(n);if(t.children)return t.children.filter(o=>o.isFile&&!o.name.startsWith("lastSync")).sort().reverse().map(o=>({ref:o.name,created:this.getCreationTime(o)}))}catch(t){if(v(t)!==p.FILE_NOT_FOUND)throw t}return[]}async resolveResourceContent(r,e,i,n){const t=this.getResourceBackupHome(r,i,n),c=m(t,e);try{return(await this.fileService.readFile(c)).value.toString()}catch(o){return this.logService.error(o),null}}async writeResource(r,e,i,n,t){const c=this.getResourceBackupHome(r,n,t),o=m(c,`${R(i).replace(/-|:|\.\d+Z$/g,"")}.json`);try{await this.fileService.writeFile(o,I.fromString(e))}catch(h){this.logService.error(h)}}getResourceBackupHome(r,e,i=this.environmentService.userDataSyncHome){return m(i,...e?[e,r]:[r])}async cleanUpBackup(r){try{try{if(!await this.fileService.exists(r))return}catch{return}const e=await this.fileService.resolve(r);if(e.children){const i=e.children.filter(o=>o.isFile&&/^\d{8}T\d{6}(\.json)?$/.test(o.name)).sort(),n=1e3*60*60*24*(this.configurationService.getValue("sync.localBackupDuration")||30);let t=i.filter(o=>Date.now()-this.getCreationTime(o)>n);const c=i.length-t.length;c<10&&(t=t.slice(10-c)),await d.settled(t.map(async o=>{this.logService.info("Deleting from backup",o.resource.path),await this.fileService.del(o.resource)}))}}catch(e){this.logService.error(e)}}getCreationTime(r){return new Date(Number.parseInt(r.name.substring(0,4)),Number.parseInt(r.name.substring(4,6))-1,Number.parseInt(r.name.substring(6,8)),Number.parseInt(r.name.substring(9,11)),Number.parseInt(r.name.substring(11,13)),Number.parseInt(r.name.substring(13,15))).getTime()}};u=f([a(0,U),a(1,w),a(2,b),a(3,P),a(4,F)],u);export{u as UserDataSyncLocalStoreService};
