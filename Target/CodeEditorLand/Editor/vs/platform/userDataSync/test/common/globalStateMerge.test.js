import e from"assert";import{ensureNoDisposablesAreLeakedInTestSuite as n}from"../../../../base/test/common/utils.js";import{NullLogService as r}from"../../../log/common/log.js";import{merge as c}from"../../common/globalStateMerge.js";suite("GlobalStateMerge",()=>{n(),test("merge when local and remote are same with one value and local is not synced yet",async()=>{const a=c({a:{version:1,value:"a"}},{a:{version:1,value:"a"}},null,{machine:[],unregistered:[]},new r);e.deepStrictEqual(a.local.added,{}),e.deepStrictEqual(a.local.updated,{}),e.deepStrictEqual(a.local.removed,[]),e.deepStrictEqual(a.remote.all,null)}),test("merge when local and remote are same with multiple entries and local is not synced yet",async()=>{const a=c({a:{version:1,value:"a"},b:{version:1,value:"b"}},{a:{version:1,value:"a"},b:{version:1,value:"b"}},null,{machine:[],unregistered:[]},new r);e.deepStrictEqual(a.local.added,{}),e.deepStrictEqual(a.local.updated,{}),e.deepStrictEqual(a.local.removed,[]),e.deepStrictEqual(a.remote.all,null)}),test("merge when local and remote are same with multiple entries in different order and local is not synced yet",async()=>{const a=c({a:{version:1,value:"a"},b:{version:1,value:"b"}},{b:{version:1,value:"b"},a:{version:1,value:"a"}},null,{machine:[],unregistered:[]},new r);e.deepStrictEqual(a.local.added,{}),e.deepStrictEqual(a.local.updated,{}),e.deepStrictEqual(a.local.removed,[]),e.deepStrictEqual(a.remote.all,null)}),test("merge when local and remote are same with different base content",async()=>{const o=c({a:{version:1,value:"a"},b:{version:1,value:"b"}},{b:{version:1,value:"b"},a:{version:1,value:"a"}},{b:{version:1,value:"a"}},{machine:[],unregistered:[]},new r);e.deepStrictEqual(o.local.added,{}),e.deepStrictEqual(o.local.updated,{}),e.deepStrictEqual(o.local.removed,[]),e.deepStrictEqual(o.remote.all,null)}),test("merge when a new entry is added to remote and local has not synced yet",async()=>{const a=c({a:{version:1,value:"a"}},{b:{version:1,value:"b"},a:{version:1,value:"a"}},null,{machine:[],unregistered:[]},new r);e.deepStrictEqual(a.local.added,{b:{version:1,value:"b"}}),e.deepStrictEqual(a.local.updated,{}),e.deepStrictEqual(a.local.removed,[]),e.deepStrictEqual(a.remote.all,null)}),test("merge when multiple new entries are added to remote and local is not synced yet",async()=>{const a=c({},{b:{version:1,value:"b"},a:{version:1,value:"a"}},null,{machine:[],unregistered:[]},new r);e.deepStrictEqual(a.local.added,{b:{version:1,value:"b"},a:{version:1,value:"a"}}),e.deepStrictEqual(a.local.updated,{}),e.deepStrictEqual(a.local.removed,[]),e.deepStrictEqual(a.remote.all,null)}),test("merge when new entry is added to remote from base and local has not changed",async()=>{const l={a:{version:1,value:"a"}},a=c(l,{b:{version:1,value:"b"},a:{version:1,value:"a"}},l,{machine:[],unregistered:[]},new r);e.deepStrictEqual(a.local.added,{b:{version:1,value:"b"}}),e.deepStrictEqual(a.local.updated,{}),e.deepStrictEqual(a.local.removed,[]),e.deepStrictEqual(a.remote.all,null)}),test("merge when an entry is removed from remote from base and local has not changed",async()=>{const l={b:{version:1,value:"b"},a:{version:1,value:"a"}},a=c(l,{a:{version:1,value:"a"}},l,{machine:[],unregistered:[]},new r);e.deepStrictEqual(a.local.added,{}),e.deepStrictEqual(a.local.updated,{}),e.deepStrictEqual(a.local.removed,["b"]),e.deepStrictEqual(a.remote.all,null)}),test("merge when all entries are removed from base and local has not changed",async()=>{const l={b:{version:1,value:"b"},a:{version:1,value:"a"}},a=c(l,{},l,{machine:[],unregistered:[]},new r);e.deepStrictEqual(a.local.added,{}),e.deepStrictEqual(a.local.updated,{}),e.deepStrictEqual(a.local.removed,["b","a"]),e.deepStrictEqual(a.remote.all,null)}),test("merge when an entry is updated in remote from base and local has not changed",async()=>{const l={a:{version:1,value:"a"}},a=c(l,{a:{version:1,value:"b"}},l,{machine:[],unregistered:[]},new r);e.deepStrictEqual(a.local.added,{}),e.deepStrictEqual(a.local.updated,{a:{version:1,value:"b"}}),e.deepStrictEqual(a.local.removed,[]),e.deepStrictEqual(a.remote.all,null)}),test("merge when remote has moved forwarded with multiple changes and local stays with base",async()=>{const l={a:{version:1,value:"a"},b:{version:1,value:"b"}},a=c(l,{a:{version:1,value:"d"},c:{version:1,value:"c"}},l,{machine:[],unregistered:[]},new r);e.deepStrictEqual(a.local.added,{c:{version:1,value:"c"}}),e.deepStrictEqual(a.local.updated,{a:{version:1,value:"d"}}),e.deepStrictEqual(a.local.removed,["b"]),e.deepStrictEqual(a.remote.all,null)}),test("merge when new entries are added to local and local is not synced yet",async()=>{const l={a:{version:1,value:"a"},b:{version:1,value:"b"}},a=c(l,{a:{version:1,value:"a"}},null,{machine:[],unregistered:[]},new r);e.deepStrictEqual(a.local.added,{}),e.deepStrictEqual(a.local.updated,{}),e.deepStrictEqual(a.local.removed,[]),e.deepStrictEqual(a.remote.all,l)}),test("merge when multiple new entries are added to local from base and remote is not changed",async()=>{const l={a:{version:1,value:"a"},b:{version:1,value:"b"},c:{version:1,value:"c"}},t={a:{version:1,value:"a"}},a=c(l,t,t,{machine:[],unregistered:[]},new r);e.deepStrictEqual(a.local.added,{}),e.deepStrictEqual(a.local.updated,{}),e.deepStrictEqual(a.local.removed,[]),e.deepStrictEqual(a.remote.all,l)}),test("merge when an entry is removed from local from base and remote has not changed",async()=>{const l={a:{version:1,value:"a"}},t={a:{version:1,value:"a"},b:{version:1,value:"b"}},a=c(l,t,t,{machine:[],unregistered:[]},new r);e.deepStrictEqual(a.local.added,{}),e.deepStrictEqual(a.local.updated,{}),e.deepStrictEqual(a.local.removed,[]),e.deepStrictEqual(a.remote.all,l)}),test("merge when an entry is updated in local from base and remote has not changed",async()=>{const l={a:{version:1,value:"b"}},t={a:{version:1,value:"a"}},a=c(l,t,t,{machine:[],unregistered:[]},new r);e.deepStrictEqual(a.local.added,{}),e.deepStrictEqual(a.local.updated,{}),e.deepStrictEqual(a.local.removed,[]),e.deepStrictEqual(a.remote.all,l)}),test("merge when local has moved forwarded with multiple changes and remote stays with base",async()=>{const l={a:{version:1,value:"d"},b:{version:1,value:"b"}},t={a:{version:1,value:"a"},c:{version:1,value:"c"}},a=c(l,t,t,{machine:[],unregistered:[]},new r);e.deepStrictEqual(a.local.added,{}),e.deepStrictEqual(a.local.updated,{}),e.deepStrictEqual(a.local.removed,[]),e.deepStrictEqual(a.remote.all,l)}),test("merge when local and remote with one entry but different value and local is not synced yet",async()=>{const a=c({a:{version:1,value:"a"}},{a:{version:1,value:"b"}},null,{machine:[],unregistered:[]},new r);e.deepStrictEqual(a.local.added,{}),e.deepStrictEqual(a.local.updated,{a:{version:1,value:"b"}}),e.deepStrictEqual(a.local.removed,[]),e.deepStrictEqual(a.remote.all,null)}),test("merge when the entry is removed in remote but updated in local and a new entry is added in remote",async()=>{const o=c({a:{version:1,value:"a"},b:{version:1,value:"d"}},{a:{version:1,value:"a"},c:{version:1,value:"c"}},{a:{version:1,value:"a"},b:{version:1,value:"b"}},{machine:[],unregistered:[]},new r);e.deepStrictEqual(o.local.added,{c:{version:1,value:"c"}}),e.deepStrictEqual(o.local.updated,{}),e.deepStrictEqual(o.local.removed,[]),e.deepStrictEqual(o.remote.all,{a:{version:1,value:"a"},c:{version:1,value:"c"},b:{version:1,value:"d"}})}),test("merge with single entry and local is empty",async()=>{const l={a:{version:1,value:"a"}},t={},o=c(t,{a:{version:1,value:"b"}},l,{machine:[],unregistered:[]},new r);e.deepStrictEqual(o.local.added,{}),e.deepStrictEqual(o.local.updated,{}),e.deepStrictEqual(o.local.removed,[]),e.deepStrictEqual(o.remote.all,t)}),test("merge when local and remote has moved forward with conflicts",async()=>{const l={a:{version:1,value:"a"}},t={a:{version:1,value:"d"}},o=c(t,{a:{version:1,value:"b"}},l,{machine:[],unregistered:[]},new r);e.deepStrictEqual(o.local.added,{}),e.deepStrictEqual(o.local.updated,{}),e.deepStrictEqual(o.local.removed,[]),e.deepStrictEqual(o.remote.all,t)}),test("merge when a new entry is added to remote but scoped to machine locally and local is not synced yet",async()=>{const a=c({a:{version:1,value:"a"}},{b:{version:1,value:"b"},a:{version:1,value:"a"}},null,{machine:["b"],unregistered:[]},new r);e.deepStrictEqual(a.local.added,{}),e.deepStrictEqual(a.local.updated,{}),e.deepStrictEqual(a.local.removed,[]),e.deepStrictEqual(a.remote.all,null)}),test("merge when an entry is updated to remote but scoped to machine locally",async()=>{const l={a:{version:1,value:"a"}},a=c(l,{a:{version:1,value:"b"}},l,{machine:["a"],unregistered:[]},new r);e.deepStrictEqual(a.local.added,{}),e.deepStrictEqual(a.local.updated,{}),e.deepStrictEqual(a.local.removed,[]),e.deepStrictEqual(a.remote.all,null)}),test("merge when a local value is removed and scoped to machine locally",async()=>{const l={a:{version:1,value:"a"},b:{version:1,value:"b"}},t={a:{version:1,value:"a"}},o=c(t,{b:{version:1,value:"b"},a:{version:1,value:"a"}},l,{machine:["b"],unregistered:[]},new r);e.deepStrictEqual(o.local.added,{}),e.deepStrictEqual(o.local.updated,{}),e.deepStrictEqual(o.local.removed,[]),e.deepStrictEqual(o.remote.all,t)}),test("merge when local moved forwared by changing a key to machine scope",async()=>{const l={a:{version:1,value:"a"},b:{version:1,value:"b"}},t={a:{version:1,value:"a"},b:{version:1,value:"b"}},a={a:{version:1,value:"a"}},o=c(a,t,l,{machine:["b"],unregistered:[]},new r);e.deepStrictEqual(o.local.added,{}),e.deepStrictEqual(o.local.updated,{}),e.deepStrictEqual(o.local.removed,[]),e.deepStrictEqual(o.remote.all,a)}),test("merge should not remove remote keys if not registered",async()=>{const o=c({a:{version:1,value:"a"},b:{version:1,value:"b"}},{a:{version:1,value:"a"},c:{version:1,value:"c"}},{a:{version:1,value:"a"},c:{version:1,value:"c"}},{machine:[],unregistered:["c"]},new r);e.deepStrictEqual(o.local.added,{}),e.deepStrictEqual(o.local.updated,{}),e.deepStrictEqual(o.local.removed,[]),e.deepStrictEqual(o.remote.all,{a:{version:1,value:"a"},b:{version:1,value:"b"},c:{version:1,value:"c"}})})});
