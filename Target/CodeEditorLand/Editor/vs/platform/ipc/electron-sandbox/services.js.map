{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/ipc/electron-sandbox/services.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IChannel, ProxyChannel } from '../../../base/parts/ipc/common/ipc.js';\nimport { SyncDescriptor } from '../../instantiation/common/descriptors.js';\nimport { registerSingleton } from '../../instantiation/common/extensions.js';\nimport { createDecorator, IInstantiationService, ServiceIdentifier } from '../../instantiation/common/instantiation.js';\nimport { IMainProcessService } from '../common/mainProcessService.js';\nimport { IRemoteService } from '../common/services.js';\n\ntype ChannelClientCtor<T> = { new(channel: IChannel, ...args: any[]): T };\ntype Remote = { getChannel(channelName: string): IChannel };\n\nabstract class RemoteServiceStub<T extends object> {\n\tconstructor(\n\t\tchannelName: string,\n\t\toptions: IRemoteServiceWithChannelClientOptions<T> | IRemoteServiceWithProxyOptions | undefined,\n\t\tremote: Remote,\n\t\tinstantiationService: IInstantiationService\n\t) {\n\t\tconst channel = remote.getChannel(channelName);\n\n\t\tif (isRemoteServiceWithChannelClientOptions(options)) {\n\t\t\treturn instantiationService.createInstance(new SyncDescriptor(options.channelClientCtor, [channel]));\n\t\t}\n\n\t\treturn ProxyChannel.toService(channel, options?.proxyOptions);\n\t}\n}\n\nexport interface IRemoteServiceWithChannelClientOptions<T> {\n\treadonly channelClientCtor: ChannelClientCtor<T>;\n}\n\nexport interface IRemoteServiceWithProxyOptions {\n\treadonly proxyOptions?: ProxyChannel.ICreateProxyServiceOptions;\n}\n\nfunction isRemoteServiceWithChannelClientOptions<T>(obj: unknown): obj is IRemoteServiceWithChannelClientOptions<T> {\n\tconst candidate = obj as IRemoteServiceWithChannelClientOptions<T> | undefined;\n\n\treturn !!candidate?.channelClientCtor;\n}\n\n//#region Main Process\n\nclass MainProcessRemoteServiceStub<T extends object> extends RemoteServiceStub<T> {\n\tconstructor(channelName: string, options: IRemoteServiceWithChannelClientOptions<T> | IRemoteServiceWithProxyOptions | undefined, @IMainProcessService ipcService: IMainProcessService, @IInstantiationService instantiationService: IInstantiationService) {\n\t\tsuper(channelName, options, ipcService, instantiationService);\n\t}\n}\n\nexport function registerMainProcessRemoteService<T>(id: ServiceIdentifier<T>, channelName: string, options?: IRemoteServiceWithChannelClientOptions<T> | IRemoteServiceWithProxyOptions): void {\n\tregisterSingleton(id, new SyncDescriptor(MainProcessRemoteServiceStub, [channelName, options], true));\n}\n\n//#endregion\n\n//#region Shared Process\n\nexport const ISharedProcessService = createDecorator<ISharedProcessService>('sharedProcessService');\n\nexport interface ISharedProcessService extends IRemoteService {\n\n\t/**\n\t * Allows to create a `MessagePort` connection between the\n\t * shared process and the renderer process.\n\t *\n\t * Use this only when you need raw IPC to the shared process\n\t * via `postMessage` and `on('message')` of special data structures\n\t * like typed arrays.\n\t *\n\t * Callers have to call `port.start()` after having installed\n\t * listeners to enable the data flow.\n\t */\n\tcreateRawConnection(): Promise<MessagePort>;\n\n\tnotifyRestored(): void;\n}\n\nclass SharedProcessRemoteServiceStub<T extends object> extends RemoteServiceStub<T> {\n\tconstructor(channelName: string, options: IRemoteServiceWithChannelClientOptions<T> | IRemoteServiceWithProxyOptions | undefined, @ISharedProcessService ipcService: ISharedProcessService, @IInstantiationService instantiationService: IInstantiationService) {\n\t\tsuper(channelName, options, ipcService, instantiationService);\n\t}\n}\n\nexport function registerSharedProcessRemoteService<T>(id: ServiceIdentifier<T>, channelName: string, options?: IRemoteServiceWithChannelClientOptions<T> | IRemoteServiceWithProxyOptions): void {\n\tregisterSingleton(id, new SyncDescriptor(SharedProcessRemoteServiceStub, [channelName, options], true));\n}\n\n//#endregion\n"],
  "mappings": ";;;;;;;;;;;;AAKA,SAAS,UAAU,oBAAoB;AACvC,SAAS,sBAAsB;AAC/B,SAAS,yBAAyB;AAClC,SAAS,iBAAiB,uBAAuB,yBAAyB;AAC1E,SAAS,2BAA2B;AACpC,SAAS,sBAAsB;AAK/B,MAAe,kBAAoC;AAAA,EAfnD,OAemD;AAAA;AAAA;AAAA,EAClD,YACC,aACA,SACA,QACA,sBACC;AACD,UAAM,UAAU,OAAO,WAAW,WAAW;AAE7C,QAAI,wCAAwC,OAAO,GAAG;AACrD,aAAO,qBAAqB,eAAe,IAAI,eAAe,QAAQ,mBAAmB,CAAC,OAAO,CAAC,CAAC;AAAA,IACpG;AAEA,WAAO,aAAa,UAAU,SAAS,SAAS,YAAY;AAAA,EAC7D;AACD;AAUA,SAAS,wCAA2C,KAAgE;AACnH,QAAM,YAAY;AAElB,SAAO,CAAC,CAAC,WAAW;AACrB;AAJS;AAQT,IAAM,+BAAN,cAA6D,kBAAqB;AAAA,EAhDlF,OAgDkF;AAAA;AAAA;AAAA,EACjF,YAAY,aAAqB,SAAsH,YAAwD,sBAA6C;AAC3P,UAAM,aAAa,SAAS,YAAY,oBAAoB;AAAA,EAC7D;AACD;AAJM,+BAAN;AAAA,EACoI;AAAA,EAAsD;AAAA,GADpL;AAMC,SAAS,iCAAoC,IAA0B,aAAqB,SAA4F;AAC9L,oBAAkB,IAAI,IAAI,eAAe,8BAA8B,CAAC,aAAa,OAAO,GAAG,IAAI,CAAC;AACrG;AAFgB;AAQT,MAAM,wBAAwB,gBAAuC,sBAAsB;AAoBlG,IAAM,iCAAN,cAA+D,kBAAqB;AAAA,EAlFpF,OAkFoF;AAAA;AAAA;AAAA,EACnF,YAAY,aAAqB,SAAwH,YAA0D,sBAA6C;AAC/P,UAAM,aAAa,SAAS,YAAY,oBAAoB;AAAA,EAC7D;AACD;AAJM,iCAAN;AAAA,EACoI;AAAA,EAA0D;AAAA,GADxL;AAMC,SAAS,mCAAsC,IAA0B,aAAqB,SAA4F;AAChM,oBAAkB,IAAI,IAAI,eAAe,gCAAgC,CAAC,aAAa,OAAO,GAAG,IAAI,CAAC;AACvG;AAFgB;",
  "names": []
}
