{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/ipc/electron-sandbox/services.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport {\n\ttype IChannel,\n\tProxyChannel,\n} from \"../../../base/parts/ipc/common/ipc.js\";\nimport { SyncDescriptor } from \"../../instantiation/common/descriptors.js\";\nimport { registerSingleton } from \"../../instantiation/common/extensions.js\";\nimport {\n\tIInstantiationService,\n\ttype ServiceIdentifier,\n\tcreateDecorator,\n} from \"../../instantiation/common/instantiation.js\";\nimport { IMainProcessService } from \"../common/mainProcessService.js\";\nimport type { IRemoteService } from \"../common/services.js\";\n\ntype ChannelClientCtor<T> = { new (channel: IChannel, ...args: any[]): T };\ntype Remote = { getChannel(channelName: string): IChannel };\n\nabstract class RemoteServiceStub<T extends object> {\n\tconstructor(\n\t\tchannelName: string,\n\t\toptions:\n\t\t\t| IRemoteServiceWithChannelClientOptions<T>\n\t\t\t| IRemoteServiceWithProxyOptions\n\t\t\t| undefined,\n\t\tremote: Remote,\n\t\tinstantiationService: IInstantiationService,\n\t) {\n\t\tconst channel = remote.getChannel(channelName);\n\n\t\tif (isRemoteServiceWithChannelClientOptions(options)) {\n\t\t\treturn instantiationService.createInstance(\n\t\t\t\tnew SyncDescriptor(options.channelClientCtor, [channel]),\n\t\t\t);\n\t\t}\n\n\t\treturn ProxyChannel.toService(channel, options?.proxyOptions);\n\t}\n}\n\nexport interface IRemoteServiceWithChannelClientOptions<T> {\n\treadonly channelClientCtor: ChannelClientCtor<T>;\n}\n\nexport interface IRemoteServiceWithProxyOptions {\n\treadonly proxyOptions?: ProxyChannel.ICreateProxyServiceOptions;\n}\n\nfunction isRemoteServiceWithChannelClientOptions<T>(\n\tobj: unknown,\n): obj is IRemoteServiceWithChannelClientOptions<T> {\n\tconst candidate = obj as\n\t\t| IRemoteServiceWithChannelClientOptions<T>\n\t\t| undefined;\n\n\treturn !!candidate?.channelClientCtor;\n}\n\n//#region Main Process\n\nclass MainProcessRemoteServiceStub<\n\tT extends object,\n> extends RemoteServiceStub<T> {\n\tconstructor(\n\t\tchannelName: string,\n\t\toptions:\n\t\t\t| IRemoteServiceWithChannelClientOptions<T>\n\t\t\t| IRemoteServiceWithProxyOptions\n\t\t\t| undefined,\n\t\t@IMainProcessService ipcService: IMainProcessService,\n\t\t@IInstantiationService instantiationService: IInstantiationService,\n\t) {\n\t\tsuper(channelName, options, ipcService, instantiationService);\n\t}\n}\n\nexport function registerMainProcessRemoteService<T>(\n\tid: ServiceIdentifier<T>,\n\tchannelName: string,\n\toptions?:\n\t\t| IRemoteServiceWithChannelClientOptions<T>\n\t\t| IRemoteServiceWithProxyOptions,\n): void {\n\tregisterSingleton(\n\t\tid,\n\t\tnew SyncDescriptor(\n\t\t\tMainProcessRemoteServiceStub,\n\t\t\t[channelName, options],\n\t\t\ttrue,\n\t\t),\n\t);\n}\n\n//#endregion\n\n//#region Shared Process\n\nexport const ISharedProcessService = createDecorator<ISharedProcessService>(\n\t\"sharedProcessService\",\n);\n\nexport interface ISharedProcessService extends IRemoteService {\n\t/**\n\t * Allows to create a `MessagePort` connection between the\n\t * shared process and the renderer process.\n\t *\n\t * Use this only when you need raw IPC to the shared process\n\t * via `postMessage` and `on('message')` of special data structures\n\t * like typed arrays.\n\t *\n\t * Callers have to call `port.start()` after having installed\n\t * listeners to enable the data flow.\n\t */\n\tcreateRawConnection(): Promise<MessagePort>;\n\n\tnotifyRestored(): void;\n}\n\nclass SharedProcessRemoteServiceStub<\n\tT extends object,\n> extends RemoteServiceStub<T> {\n\tconstructor(\n\t\tchannelName: string,\n\t\toptions:\n\t\t\t| IRemoteServiceWithChannelClientOptions<T>\n\t\t\t| IRemoteServiceWithProxyOptions\n\t\t\t| undefined,\n\t\t@ISharedProcessService ipcService: ISharedProcessService,\n\t\t@IInstantiationService instantiationService: IInstantiationService,\n\t) {\n\t\tsuper(channelName, options, ipcService, instantiationService);\n\t}\n}\n\nexport function registerSharedProcessRemoteService<T>(\n\tid: ServiceIdentifier<T>,\n\tchannelName: string,\n\toptions?:\n\t\t| IRemoteServiceWithChannelClientOptions<T>\n\t\t| IRemoteServiceWithProxyOptions,\n): void {\n\tregisterSingleton(\n\t\tid,\n\t\tnew SyncDescriptor(\n\t\t\tSharedProcessRemoteServiceStub,\n\t\t\t[channelName, options],\n\t\t\ttrue,\n\t\t),\n\t);\n}\n\n//#endregion\n"],
  "mappings": ";;;;;;;;;;;;AAKA;AAAA,EAEC;AAAA,OACM;AACP,SAAS,sBAAsB;AAC/B,SAAS,yBAAyB;AAClC;AAAA,EACC;AAAA,EAEA;AAAA,OACM;AACP,SAAS,2BAA2B;AAMpC,MAAe,kBAAoC;AAAA,EAtBnD,OAsBmD;AAAA;AAAA;AAAA,EAClD,YACC,aACA,SAIA,QACA,sBACC;AACD,UAAM,UAAU,OAAO,WAAW,WAAW;AAE7C,QAAI,wCAAwC,OAAO,GAAG;AACrD,aAAO,qBAAqB;AAAA,QAC3B,IAAI,eAAe,QAAQ,mBAAmB,CAAC,OAAO,CAAC;AAAA,MACxD;AAAA,IACD;AAEA,WAAO,aAAa,UAAU,SAAS,SAAS,YAAY;AAAA,EAC7D;AACD;AAUA,SAAS,wCACR,KACmD;AACnD,QAAM,YAAY;AAIlB,SAAO,CAAC,CAAC,WAAW;AACrB;AARS;AAYT,IAAM,+BAAN,cAEU,kBAAqB;AAAA,EAlE/B,OAkE+B;AAAA;AAAA;AAAA,EAC9B,YACC,aACA,SAIqB,YACE,sBACtB;AACD,UAAM,aAAa,SAAS,YAAY,oBAAoB;AAAA,EAC7D;AACD;AAdM,+BAAN;AAAA,EASG;AAAA,EACA;AAAA,GAVG;AAgBC,SAAS,iCACf,IACA,aACA,SAGO;AACP;AAAA,IACC;AAAA,IACA,IAAI;AAAA,MACH;AAAA,MACA,CAAC,aAAa,OAAO;AAAA,MACrB;AAAA,IACD;AAAA,EACD;AACD;AAfgB;AAqBT,MAAM,wBAAwB;AAAA,EACpC;AACD;AAmBA,IAAM,iCAAN,cAEU,kBAAqB;AAAA,EA5H/B,OA4H+B;AAAA;AAAA;AAAA,EAC9B,YACC,aACA,SAIuB,YACA,sBACtB;AACD,UAAM,aAAa,SAAS,YAAY,oBAAoB;AAAA,EAC7D;AACD;AAdM,iCAAN;AAAA,EASG;AAAA,EACA;AAAA,GAVG;AAgBC,SAAS,mCACf,IACA,aACA,SAGO;AACP;AAAA,IACC;AAAA,IACA,IAAI;AAAA,MACH;AAAA,MACA,CAAC,aAAa,OAAO;AAAA,MACrB;AAAA,IACD;AAAA,EACD;AACD;AAfgB;",
  "names": []
}
