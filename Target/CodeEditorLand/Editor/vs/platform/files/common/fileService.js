var G=Object.defineProperty;var K=Object.getOwnPropertyDescriptor;var N=(E,v,e,i)=>{for(var t=i>1?void 0:i?K(v,e):v,r=E.length-1,a;r>=0;r--)(a=E[r])&&(t=(i?a(v,e,t):a(t))||t);return i&&t&&G(v,e,t),t},Q=(E,v)=>(e,i)=>v(e,i,E);import{coalesce as J}from"../../../base/common/arrays.js";import{Promises as b,ResourceQueue as X}from"../../../base/common/async.js";import{VSBuffer as h,bufferToReadable as ee,bufferedStreamToBuffer as ie,newWriteableBufferStream as te,readableToBuffer as re,streamToBuffer as D}from"../../../base/common/buffer.js";import{CancellationToken as ae,CancellationTokenSource as oe}from"../../../base/common/cancellation.js";import{ErrorNoTelemetry as se}from"../../../base/common/errors.js";import{Emitter as m}from"../../../base/common/event.js";import{hash as ne}from"../../../base/common/hash.js";import{Iterable as le}from"../../../base/common/iterator.js";import{Disposable as de,DisposableStore as q,dispose as C,toDisposable as O}from"../../../base/common/lifecycle.js";import{Schemas as he}from"../../../base/common/network.js";import{mark as fe}from"../../../base/common/performance.js";import{extUri as pe,extUriIgnorePathCase as ce,isAbsolutePath as ye}from"../../../base/common/resources.js";import{consumeStream as me,isReadableBufferedStream as g,isReadableStream as B,listenStream as Fe,newWriteableStream as ue,peekReadable as Ie,peekStream as ve,transform as we}from"../../../base/common/stream.js";import{TernarySearchTree as Re}from"../../../base/common/ternarySearchTree.js";import{localize as d}from"../../../nls.js";import{ILogService as Se}from"../../log/common/log.js";import{ETAG_DISABLED as T,FileChangesEvent as be,FileOperation as F,FileOperationError as p,FileOperationEvent as w,FileOperationResult as c,FilePermission as _,FileSystemProviderCapabilities as u,FileSystemProviderErrorCode as x,FileType as P,NotModifiedSinceFileOperationError as M,TooLargeFileOperationError as V,ensureFileSystemProviderError as R,etag as z,hasFileAtomicDeleteCapability as Ce,hasFileAtomicReadCapability as A,hasFileAtomicWriteCapability as H,hasFileCloneCapability as Pe,hasFileFolderCopyCapability as j,hasFileReadStreamCapability as k,hasOpenReadWriteCloseCapability as I,hasReadWriteCapability as y,toFileOperationResult as Y,toFileSystemProviderErrorCode as L}from"./files.js";import{readFileIntoStream as Ee}from"./io.js";let S=class extends de{constructor(e){super();this.logService=e}BUFFER_SIZE=256*1024;_onDidChangeFileSystemProviderRegistrations=this._register(new m);onDidChangeFileSystemProviderRegistrations=this._onDidChangeFileSystemProviderRegistrations.event;_onWillActivateFileSystemProvider=this._register(new m);onWillActivateFileSystemProvider=this._onWillActivateFileSystemProvider.event;_onDidChangeFileSystemProviderCapabilities=this._register(new m);onDidChangeFileSystemProviderCapabilities=this._onDidChangeFileSystemProviderCapabilities.event;provider=new Map;registerProvider(e,i){if(this.provider.has(e))throw new Error(`A filesystem provider for the scheme '${e}' is already registered.`);fe(`code/registerFilesystem/${e}`);const t=new q;return this.provider.set(e,i),this._onDidChangeFileSystemProviderRegistrations.fire({added:!0,scheme:e,provider:i}),t.add(i.onDidChangeFile(r=>{const a=new be(r,!this.isPathCaseSensitive(i));this.internalOnDidFilesChange.fire(a),a.hasCorrelation()||this._onDidUncorrelatedFilesChange.fire(a)})),typeof i.onDidWatchError=="function"&&t.add(i.onDidWatchError(r=>this._onDidWatchError.fire(new Error(r)))),t.add(i.onDidChangeCapabilities(()=>this._onDidChangeFileSystemProviderCapabilities.fire({provider:i,scheme:e}))),O(()=>{this._onDidChangeFileSystemProviderRegistrations.fire({added:!1,scheme:e,provider:i}),this.provider.delete(e),C(t)})}getProvider(e){return this.provider.get(e)}async activateProvider(e){const i=[];this._onWillActivateFileSystemProvider.fire({scheme:e,join(t){i.push(t)}}),!this.provider.has(e)&&await b.settled(i)}async canHandleResource(e){return await this.activateProvider(e.scheme),this.hasProvider(e)}hasProvider(e){return this.provider.has(e.scheme)}hasCapability(e,i){const t=this.provider.get(e.scheme);return!!(t&&t.capabilities&i)}listCapabilities(){return le.map(this.provider,([e,i])=>({scheme:e,capabilities:i.capabilities}))}async withProvider(e){if(!ye(e))throw new p(d("invalidPath","Unable to resolve filesystem provider with relative file path '{0}'",this.resourceForError(e)),c.FILE_INVALID_PATH);await this.activateProvider(e.scheme);const i=this.provider.get(e.scheme);if(!i){const t=new se;throw t.message=d("noProviderFound","ENOPRO: No file system provider found for resource '{0}'",e.toString()),t}return i}async withReadProvider(e){const i=await this.withProvider(e);if(I(i)||y(i)||k(i))return i;throw new Error(`Filesystem provider for scheme '${e.scheme}' neither has FileReadWrite, FileReadStream nor FileOpenReadWriteClose capability which is needed for the read operation.`)}async withWriteProvider(e){const i=await this.withProvider(e);if(I(i)||y(i))return i;throw new Error(`Filesystem provider for scheme '${e.scheme}' neither has FileReadWrite nor FileOpenReadWriteClose capability which is needed for the write operation.`)}_onDidRunOperation=this._register(new m);onDidRunOperation=this._onDidRunOperation.event;async resolve(e,i){try{return await this.doResolveFile(e,i)}catch(t){throw L(t)===x.FileNotFound?new p(d("fileNotFoundError","Unable to resolve nonexistent file '{0}'",this.resourceForError(e)),c.FILE_NOT_FOUND):R(t)}}async doResolveFile(e,i){const t=await this.withProvider(e),r=this.isPathCaseSensitive(t),a=i?.resolveTo,o=i?.resolveSingleChildDescendants,s=i?.resolveMetadata,n=await t.stat(e);let l;return this.toFileStat(t,e,n,void 0,!!s,(f,W)=>(l||(l=Re.forUris(()=>!r),l.set(e,!0),a&&l.fill(!0,a)),l.get(f.resource)||l.findSuperstr(f.resource.with({query:null,fragment:null}))?!0:f.isDirectory&&o?W===1:!1))}async toFileStat(e,i,t,r,a,o){const{providerExtUri:s}=this.getExtUri(e),n={resource:i,name:s.basename(i),isFile:(t.type&P.File)!==0,isDirectory:(t.type&P.Directory)!==0,isSymbolicLink:(t.type&P.SymbolicLink)!==0,mtime:t.mtime,ctime:t.ctime,size:t.size,readonly:!!((t.permissions??0)&_.Readonly)||!!(e.capabilities&u.Readonly),locked:!!((t.permissions??0)&_.Locked),etag:z({mtime:t.mtime,size:t.size}),children:void 0};if(n.isDirectory&&o(n,r)){try{const l=await e.readdir(i),f=await b.settled(l.map(async([W,$])=>{try{const U=s.joinPath(i,W),Z=a?await e.stat(U):{type:$};return await this.toFileStat(e,U,Z,l.length,a,o)}catch(U){return this.logService.trace(U),null}}));n.children=J(f)}catch(l){this.logService.trace(l),n.children=[]}return n}return n}async resolveAll(e){return b.settled(e.map(async i=>{try{return{stat:await this.doResolveFile(i.resource,i.options),success:!0}}catch(t){return this.logService.trace(t),{stat:void 0,success:!1}}}))}async stat(e){const i=await this.withProvider(e),t=await i.stat(e);return this.toFileStat(i,e,t,void 0,!0,()=>!1)}async exists(e){const i=await this.withProvider(e);try{return!!await i.stat(e)}catch{return!1}}async canCreateFile(e,i){try{await this.doValidateCreateFile(e,i)}catch(t){return t}return!0}async doValidateCreateFile(e,i){if(!i?.overwrite&&await this.exists(e))throw new p(d("fileExists","Unable to create file '{0}' that already exists when overwrite flag is not set",this.resourceForError(e)),c.FILE_MODIFIED_SINCE,i)}async createFile(e,i=h.fromString(""),t){await this.doValidateCreateFile(e,t);const r=await this.writeFile(e,i);return this._onDidRunOperation.fire(new w(e,F.CREATE,r)),r}async writeFile(e,i,t){const r=this.throwIfFileSystemIsReadonly(await this.withWriteProvider(e),e),{providerExtUri:a}=this.getExtUri(r);let o=t;if(H(r)&&!o?.atomic){const s=r.enforceAtomicWriteFile?.(e);s&&(o={...t,atomic:s})}try{await this.validateWriteFile(r,e,o)||await this.mkdirp(r,a.dirname(e));let n;if(y(r)&&!(i instanceof h))if(B(i)){const l=await ve(i,3);l.ended?n=h.concat(l.buffer):n=l}else n=Ie(i,l=>h.concat(l),3);else n=i;!I(r)||y(r)&&n instanceof h||y(r)&&H(r)&&o?.atomic?await this.doWriteUnbuffered(r,e,o,n):await this.doWriteBuffered(r,e,o,n instanceof h?ee(n):n),this._onDidRunOperation.fire(new w(e,F.WRITE))}catch(s){throw new p(d("err.write","Unable to write file '{0}' ({1})",this.resourceForError(e),R(s).toString()),Y(s),o)}return this.resolve(e,{resolveMetadata:!0})}async validateWriteFile(e,i,t){const r=!!t?.unlock;if(r&&!(e.capabilities&u.FileWriteUnlock))throw new Error(d("writeFailedUnlockUnsupported","Unable to unlock file '{0}' because provider does not support it.",this.resourceForError(i)));if(!!t?.atomic){if(!(e.capabilities&u.FileAtomicWrite))throw new Error(d("writeFailedAtomicUnsupported1","Unable to atomically write file '{0}' because provider does not support it.",this.resourceForError(i)));if(!(e.capabilities&u.FileReadWrite))throw new Error(d("writeFailedAtomicUnsupported2","Unable to atomically write file '{0}' because provider does not support unbuffered writes.",this.resourceForError(i)));if(r)throw new Error(d("writeFailedAtomicUnlock","Unable to unlock file '{0}' because atomic write is enabled.",this.resourceForError(i)))}let o;try{o=await e.stat(i)}catch{return}if(o.type&P.Directory)throw new p(d("fileIsDirectoryWriteError","Unable to write file '{0}' that is actually a directory",this.resourceForError(i)),c.FILE_IS_DIRECTORY,t);if(this.throwIfFileIsReadonly(i,o),typeof t?.mtime=="number"&&typeof t.etag=="string"&&t.etag!==T&&typeof o.mtime=="number"&&typeof o.size=="number"&&t.mtime<o.mtime&&t.etag!==z({mtime:t.mtime,size:o.size}))throw new p(d("fileModifiedError","File Modified Since"),c.FILE_MODIFIED_SINCE,t);return o}async readFile(e,i,t){const r=await this.withReadProvider(e);return i?.atomic?this.doReadFileAtomic(r,e,i,t):this.doReadFile(r,e,i,t)}async doReadFileAtomic(e,i,t,r){return new Promise((a,o)=>{this.writeQueue.queueFor(i,async()=>{try{const s=await this.doReadFile(e,i,t,r);a(s)}catch(s){o(s)}},this.getExtUri(e).providerExtUri)})}async doReadFile(e,i,t,r){const a=await this.doReadFileStream(e,i,{...t,preferUnbuffered:!0},r);return{...a,value:await D(a.value)}}async readFileStream(e,i,t){const r=await this.withReadProvider(e);return this.doReadFileStream(r,e,i,t)}async doReadFileStream(e,i,t,r){const a=new oe(r);let o=t;A(e)&&e.enforceAtomicReadFile?.(i)&&(o={...t,atomic:!0});const s=this.validateReadFile(i,o).then(l=>l,l=>{throw a.dispose(!0),l});let n;try{return typeof o?.etag=="string"&&o.etag!==T&&await s,o?.atomic&&A(e)||!(I(e)||k(e))||y(e)&&o?.preferUnbuffered?n=this.readFileUnbuffered(e,i,o):k(e)?n=this.readFileStreamed(e,i,a.token,o):n=this.readFileBuffered(e,i,a.token,o),n.on("end",()=>a.dispose()),n.on("error",()=>a.dispose()),{...await s,value:n}}catch(l){throw n&&await me(n),this.restoreReadError(l,i,o)}}restoreReadError(e,i,t){const r=d("err.read","Unable to read file '{0}' ({1})",this.resourceForError(i),R(e).toString());return e instanceof M?new M(r,e.stat,t):e instanceof V?new V(r,e.fileOperationResult,e.size,e.options):new p(r,Y(e),t)}readFileStreamed(e,i,t,r=Object.create(null)){const a=e.readFileStream(i,r,t);return we(a,{data:o=>o instanceof h?o:h.wrap(o),error:o=>this.restoreReadError(o,i,r)},o=>h.concat(o))}readFileBuffered(e,i,t,r=Object.create(null)){const a=te();return Ee(e,i,a,o=>o,{...r,bufferSize:this.BUFFER_SIZE,errorTransformer:o=>this.restoreReadError(o,i,r)},t),a}readFileUnbuffered(e,i,t){const r=ue(a=>h.concat(a));return(async()=>{try{let a;t?.atomic&&A(e)?a=await e.readFile(i,{atomic:!0}):a=await e.readFile(i),typeof t?.position=="number"&&(a=a.slice(t.position)),typeof t?.length=="number"&&(a=a.slice(0,t.length)),this.validateReadFileLimits(i,a.byteLength,t),r.end(h.wrap(a))}catch(a){r.error(a),r.end()}})(),r}async validateReadFile(e,i){const t=await this.resolve(e,{resolveMetadata:!0});if(t.isDirectory)throw new p(d("fileIsDirectoryReadError","Unable to read file '{0}' that is actually a directory",this.resourceForError(e)),c.FILE_IS_DIRECTORY,i);if(typeof i?.etag=="string"&&i.etag!==T&&i.etag===t.etag)throw new M(d("fileNotModifiedError","File not modified since"),t,i);return this.validateReadFileLimits(e,t.size,i),t}validateReadFileLimits(e,i,t){if(typeof t?.limits?.size=="number"&&i>t.limits.size)throw new V(d("fileTooLargeError","Unable to read file '{0}' that is too large to open",this.resourceForError(e)),c.FILE_TOO_LARGE,i,t)}async canMove(e,i,t){return this.doCanMoveCopy(e,i,"move",t)}async canCopy(e,i,t){return this.doCanMoveCopy(e,i,"copy",t)}async doCanMoveCopy(e,i,t,r){if(e.toString()!==i.toString())try{const a=t==="move"?this.throwIfFileSystemIsReadonly(await this.withWriteProvider(e),e):await this.withReadProvider(e),o=this.throwIfFileSystemIsReadonly(await this.withWriteProvider(i),i);await this.doValidateMoveCopy(a,e,o,i,t,r)}catch(a){return a}return!0}async move(e,i,t){const r=this.throwIfFileSystemIsReadonly(await this.withWriteProvider(e),e),a=this.throwIfFileSystemIsReadonly(await this.withWriteProvider(i),i),o=await this.doMoveCopy(r,e,a,i,"move",!!t),s=await this.resolve(i,{resolveMetadata:!0});return this._onDidRunOperation.fire(new w(e,o==="move"?F.MOVE:F.COPY,s)),s}async copy(e,i,t){const r=await this.withReadProvider(e),a=this.throwIfFileSystemIsReadonly(await this.withWriteProvider(i),i),o=await this.doMoveCopy(r,e,a,i,"copy",!!t),s=await this.resolve(i,{resolveMetadata:!0});return this._onDidRunOperation.fire(new w(e,o==="copy"?F.COPY:F.MOVE,s)),s}async doMoveCopy(e,i,t,r,a,o){if(i.toString()===r.toString())return a;const{exists:s,isSameResourceWithDifferentPathCase:n}=await this.doValidateMoveCopy(e,i,t,r,a,o);if(s&&!n&&o&&await this.del(r,{recursive:!0}),await this.mkdirp(t,this.getExtUri(t).providerExtUri.dirname(r)),a==="copy"){if(e===t&&j(e))await e.copy(i,r,{overwrite:o});else{const l=await this.resolve(i);l.isDirectory?await this.doCopyFolder(e,l,t,r):await this.doCopyFile(e,i,t,r)}return a}else return e===t?(await e.rename(i,r,{overwrite:o}),a):(await this.doMoveCopy(e,i,t,r,"copy",o),await this.del(i,{recursive:!0}),"copy")}async doCopyFile(e,i,t,r){if(I(e)&&I(t))return this.doPipeBuffered(e,i,t,r);if(I(e)&&y(t))return this.doPipeBufferedToUnbuffered(e,i,t,r);if(y(e)&&I(t))return this.doPipeUnbufferedToBuffered(e,i,t,r);if(y(e)&&y(t))return this.doPipeUnbuffered(e,i,t,r)}async doCopyFolder(e,i,t,r){await t.mkdir(r),Array.isArray(i.children)&&await b.settled(i.children.map(async a=>{const o=this.getExtUri(t).providerExtUri.joinPath(r,a.name);return a.isDirectory?this.doCopyFolder(e,await this.resolve(a.resource),t,o):this.doCopyFile(e,a.resource,t,o)}))}async doValidateMoveCopy(e,i,t,r,a,o){let s=!1;if(e===t){const{providerExtUri:l,isPathCaseSensitive:f}=this.getExtUri(e);if(f||(s=l.isEqual(i,r)),s&&a==="copy")throw new Error(d("unableToMoveCopyError1","Unable to copy when source '{0}' is same as target '{1}' with different path case on a case insensitive file system",this.resourceForError(i),this.resourceForError(r)));if(!s&&l.isEqualOrParent(r,i))throw new Error(d("unableToMoveCopyError2","Unable to move/copy when source '{0}' is parent of target '{1}'.",this.resourceForError(i),this.resourceForError(r)))}const n=await this.exists(r);if(n&&!s){if(!o)throw new p(d("unableToMoveCopyError3","Unable to move/copy '{0}' because target '{1}' already exists at destination.",this.resourceForError(i),this.resourceForError(r)),c.FILE_MOVE_CONFLICT);if(e===t){const{providerExtUri:l}=this.getExtUri(e);if(l.isEqualOrParent(i,r))throw new Error(d("unableToMoveCopyError4","Unable to move/copy '{0}' into '{1}' since a file would replace the folder it is contained in.",this.resourceForError(i),this.resourceForError(r)))}}return{exists:n,isSameResourceWithDifferentPathCase:s}}getExtUri(e){const i=this.isPathCaseSensitive(e);return{providerExtUri:i?pe:ce,isPathCaseSensitive:i}}isPathCaseSensitive(e){return!!(e.capabilities&u.PathCaseSensitive)}async createFolder(e){const i=this.throwIfFileSystemIsReadonly(await this.withProvider(e),e);await this.mkdirp(i,e);const t=await this.resolve(e,{resolveMetadata:!0});return this._onDidRunOperation.fire(new w(e,F.CREATE,t)),t}async mkdirp(e,i){const t=[],{providerExtUri:r}=this.getExtUri(e);for(;!r.isEqual(i,r.dirname(i));)try{if(!((await e.stat(i)).type&P.Directory))throw new Error(d("mkdirExistsError","Unable to create folder '{0}' that already exists but is not a directory",this.resourceForError(i)));break}catch(a){if(L(a)!==x.FileNotFound)throw a;t.push(r.basename(i)),i=r.dirname(i)}for(let a=t.length-1;a>=0;a--){i=r.joinPath(i,t[a]);try{await e.mkdir(i)}catch(o){if(L(o)!==x.FileExists)throw o}}}async canDelete(e,i){try{await this.doValidateDelete(e,i)}catch(t){return t}return!0}async doValidateDelete(e,i){const t=this.throwIfFileSystemIsReadonly(await this.withProvider(e),e),r=!!i?.useTrash;if(r&&!(t.capabilities&u.Trash))throw new Error(d("deleteFailedTrashUnsupported","Unable to delete file '{0}' via trash because provider does not support it.",this.resourceForError(e)));const a=i?.atomic;if(a&&!(t.capabilities&u.FileAtomicDelete))throw new Error(d("deleteFailedAtomicUnsupported","Unable to delete file '{0}' atomically because provider does not support it.",this.resourceForError(e)));if(r&&a)throw new Error(d("deleteFailedTrashAndAtomicUnsupported","Unable to atomically delete file '{0}' because using trash is enabled.",this.resourceForError(e)));let o;try{o=await t.stat(e)}catch{}if(o)this.throwIfFileIsReadonly(e,o);else throw new p(d("deleteFailedNotFound","Unable to delete nonexistent file '{0}'",this.resourceForError(e)),c.FILE_NOT_FOUND);if(!!!i?.recursive){const n=await this.resolve(e);if(n.isDirectory&&Array.isArray(n.children)&&n.children.length>0)throw new Error(d("deleteFailedNonEmptyFolder","Unable to delete non-empty folder '{0}'.",this.resourceForError(e)))}return t}async del(e,i){const t=await this.doValidateDelete(e,i);let r=i;if(Ce(t)&&!r?.atomic){const n=t.enforceAtomicDelete?.(e);n&&(r={...i,atomic:n})}const a=!!r?.useTrash,o=!!r?.recursive,s=r?.atomic??!1;await t.delete(e,{recursive:o,useTrash:a,atomic:s}),this._onDidRunOperation.fire(new w(e,F.DELETE))}async cloneFile(e,i){const t=await this.withProvider(e),r=this.throwIfFileSystemIsReadonly(await this.withWriteProvider(i),i);if(!(t===r&&this.getExtUri(t).providerExtUri.isEqual(e,i)))return t===r&&Pe(t)?t.cloneFile(e,i):(await this.mkdirp(r,this.getExtUri(r).providerExtUri.dirname(i)),t===r&&j(t)?this.writeQueue.queueFor(e,()=>t.copy(e,i,{overwrite:!0}),this.getExtUri(t).providerExtUri):this.writeQueue.queueFor(e,()=>this.doCopyFile(t,e,r,i),this.getExtUri(t).providerExtUri))}internalOnDidFilesChange=this._register(new m);_onDidUncorrelatedFilesChange=this._register(new m);onDidFilesChange=this._onDidUncorrelatedFilesChange.event;_onDidWatchError=this._register(new m);onDidWatchError=this._onDidWatchError.event;activeWatchers=new Map;static WATCHER_CORRELATION_IDS=0;createWatcher(e,i){return this.watch(e,{...i,correlationId:S.WATCHER_CORRELATION_IDS++})}watch(e,i={recursive:!1,excludes:[]}){const t=new q;let r=!1,a=()=>{r=!0};t.add(O(()=>a())),(async()=>{try{const s=await this.doWatch(e,i);r?C(s):a=()=>C(s)}catch(s){this.logService.error(s)}})();const o=i.correlationId;if(typeof o=="number"){const s=t.add(new m);return t.add(this.internalOnDidFilesChange.event(l=>{l.correlates(o)&&s.fire(l)})),{onDidChange:s.event,dispose:()=>t.dispose()}}return t}async doWatch(e,i){const t=await this.withProvider(e),r=ne([this.getExtUri(t).providerExtUri.getComparisonKey(e),i]);let a=this.activeWatchers.get(r);return a||(a={count:0,disposable:t.watch(e,i)},this.activeWatchers.set(r,a)),a.count+=1,O(()=>{a&&(a.count--,a.count===0&&(C(a.disposable),this.activeWatchers.delete(r)))})}dispose(){super.dispose();for(const[,e]of this.activeWatchers)C(e.disposable);this.activeWatchers.clear()}writeQueue=this._register(new X);async doWriteBuffered(e,i,t,r){return this.writeQueue.queueFor(i,async()=>{const a=await e.open(i,{create:!0,unlock:t?.unlock??!1});try{B(r)||g(r)?await this.doWriteStreamBufferedQueued(e,a,r):await this.doWriteReadableBufferedQueued(e,a,r)}catch(o){throw R(o)}finally{await e.close(a)}},this.getExtUri(e).providerExtUri)}async doWriteStreamBufferedQueued(e,i,t){let r=0,a;if(g(t)){if(t.buffer.length>0){const o=h.concat(t.buffer);await this.doWriteBuffer(e,i,o,o.byteLength,r,0),r+=o.byteLength}if(t.ended)return;a=t.stream}else a=t;return new Promise((o,s)=>{Fe(a,{onData:async n=>{a.pause();try{await this.doWriteBuffer(e,i,n,n.byteLength,r,0)}catch(l){return s(l)}r+=n.byteLength,setTimeout(()=>a.resume())},onError:n=>s(n),onEnd:()=>o()})})}async doWriteReadableBufferedQueued(e,i,t){let r=0,a;for(;(a=t.read())!==null;)await this.doWriteBuffer(e,i,a,a.byteLength,r,0),r+=a.byteLength}async doWriteBuffer(e,i,t,r,a,o){let s=0;for(;s<r;){const n=await e.write(i,a+s,t.buffer,o+s,r-s);s+=n}}async doWriteUnbuffered(e,i,t,r){return this.writeQueue.queueFor(i,()=>this.doWriteUnbufferedQueued(e,i,t,r),this.getExtUri(e).providerExtUri)}async doWriteUnbufferedQueued(e,i,t,r){let a;r instanceof h?a=r:B(r)?a=await D(r):g(r)?a=await ie(r):a=re(r),await e.writeFile(i,a.buffer,{create:!0,overwrite:!0,unlock:t?.unlock??!1,atomic:t?.atomic??!1})}async doPipeBuffered(e,i,t,r){return this.writeQueue.queueFor(r,()=>this.doPipeBufferedQueued(e,i,t,r),this.getExtUri(t).providerExtUri)}async doPipeBufferedQueued(e,i,t,r){let a,o;try{a=await e.open(i,{create:!1}),o=await t.open(r,{create:!0,unlock:!1});const s=h.alloc(this.BUFFER_SIZE);let n=0,l=0,f=0;do f=await e.read(a,n,s.buffer,l,s.byteLength-l),await this.doWriteBuffer(t,o,s,f,n,l),n+=f,l+=f,l===s.byteLength&&(l=0);while(f>0)}catch(s){throw R(s)}finally{await b.settled([typeof a=="number"?e.close(a):Promise.resolve(),typeof o=="number"?t.close(o):Promise.resolve()])}}async doPipeUnbuffered(e,i,t,r){return this.writeQueue.queueFor(r,()=>this.doPipeUnbufferedQueued(e,i,t,r),this.getExtUri(t).providerExtUri)}async doPipeUnbufferedQueued(e,i,t,r){return t.writeFile(r,await e.readFile(i),{create:!0,overwrite:!0,unlock:!1,atomic:!1})}async doPipeUnbufferedToBuffered(e,i,t,r){return this.writeQueue.queueFor(r,()=>this.doPipeUnbufferedToBufferedQueued(e,i,t,r),this.getExtUri(t).providerExtUri)}async doPipeUnbufferedToBufferedQueued(e,i,t,r){const a=await t.open(r,{create:!0,unlock:!1});try{const o=await e.readFile(i);await this.doWriteBuffer(t,a,h.wrap(o),o.byteLength,0,0)}catch(o){throw R(o)}finally{await t.close(a)}}async doPipeBufferedToUnbuffered(e,i,t,r){const a=await D(this.readFileBuffered(e,i,ae.None));await this.doWriteUnbuffered(t,r,void 0,a)}throwIfFileSystemIsReadonly(e,i){if(e.capabilities&u.Readonly)throw new p(d("err.readonly","Unable to modify read-only file '{0}'",this.resourceForError(i)),c.FILE_PERMISSION_DENIED);return e}throwIfFileIsReadonly(e,i){if((i.permissions??0)&_.Readonly)throw new p(d("err.readonly","Unable to modify read-only file '{0}'",this.resourceForError(e)),c.FILE_PERMISSION_DENIED)}resourceForError(e){return e.scheme===he.file?e.fsPath:e.toString(!0)}};S=N([Q(0,Se)],S);export{S as FileService};
