{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/files/common/fileService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { coalesce } from \"../../../base/common/arrays.js\";\nimport { Promises, ResourceQueue } from \"../../../base/common/async.js\";\nimport {\n\tVSBuffer,\n\ttype VSBufferReadable,\n\ttype VSBufferReadableBufferedStream,\n\ttype VSBufferReadableStream,\n\tbufferToReadable,\n\tbufferedStreamToBuffer,\n\tnewWriteableBufferStream,\n\treadableToBuffer,\n\tstreamToBuffer,\n} from \"../../../base/common/buffer.js\";\nimport {\n\tCancellationToken,\n\tCancellationTokenSource,\n} from \"../../../base/common/cancellation.js\";\nimport { ErrorNoTelemetry } from \"../../../base/common/errors.js\";\nimport { Emitter } from \"../../../base/common/event.js\";\nimport { hash } from \"../../../base/common/hash.js\";\nimport { Iterable } from \"../../../base/common/iterator.js\";\nimport {\n\tDisposable,\n\tDisposableStore,\n\ttype IDisposable,\n\tdispose,\n\ttoDisposable,\n} from \"../../../base/common/lifecycle.js\";\nimport { Schemas } from \"../../../base/common/network.js\";\nimport { mark } from \"../../../base/common/performance.js\";\nimport {\n\ttype IExtUri,\n\textUri,\n\textUriIgnorePathCase,\n\tisAbsolutePath,\n} from \"../../../base/common/resources.js\";\nimport {\n\tconsumeStream,\n\tisReadableBufferedStream,\n\tisReadableStream,\n\tlistenStream,\n\tnewWriteableStream,\n\tpeekReadable,\n\tpeekStream,\n\ttransform,\n} from \"../../../base/common/stream.js\";\nimport { TernarySearchTree } from \"../../../base/common/ternarySearchTree.js\";\nimport type { URI } from \"../../../base/common/uri.js\";\nimport { localize } from \"../../../nls.js\";\nimport { ILogService } from \"../../log/common/log.js\";\nimport {\n\tETAG_DISABLED,\n\tFileChangesEvent,\n\tFileOperation,\n\tFileOperationError,\n\tFileOperationEvent,\n\tFileOperationResult,\n\tFilePermission,\n\tFileSystemProviderCapabilities,\n\tFileSystemProviderErrorCode,\n\tFileType,\n\ttype ICreateFileOptions,\n\ttype IFileContent,\n\ttype IFileDeleteOptions,\n\ttype IFileService,\n\ttype IFileStat,\n\ttype IFileStatResult,\n\ttype IFileStatResultWithMetadata,\n\ttype IFileStatWithMetadata,\n\ttype IFileStatWithPartialMetadata,\n\ttype IFileStreamContent,\n\ttype IFileSystemProvider,\n\ttype IFileSystemProviderActivationEvent,\n\ttype IFileSystemProviderCapabilitiesChangeEvent,\n\ttype IFileSystemProviderRegistrationEvent,\n\ttype IFileSystemProviderWithFileAtomicReadCapability,\n\ttype IFileSystemProviderWithFileReadStreamCapability,\n\ttype IFileSystemProviderWithFileReadWriteCapability,\n\ttype IFileSystemProviderWithOpenReadWriteCloseCapability,\n\ttype IFileSystemWatcher,\n\ttype IReadFileOptions,\n\ttype IReadFileStreamOptions,\n\ttype IResolveFileOptions,\n\ttype IResolveMetadataFileOptions,\n\ttype IStat,\n\ttype IWatchOptions,\n\ttype IWatchOptionsWithCorrelation,\n\ttype IWatchOptionsWithoutCorrelation,\n\ttype IWriteFileOptions,\n\tNotModifiedSinceFileOperationError,\n\tTooLargeFileOperationError,\n\tensureFileSystemProviderError,\n\tetag,\n\thasFileAtomicDeleteCapability,\n\thasFileAtomicReadCapability,\n\thasFileAtomicWriteCapability,\n\thasFileCloneCapability,\n\thasFileFolderCopyCapability,\n\thasFileReadStreamCapability,\n\thasOpenReadWriteCloseCapability,\n\thasReadWriteCapability,\n\ttoFileOperationResult,\n\ttoFileSystemProviderErrorCode,\n} from \"./files.js\";\nimport { readFileIntoStream } from \"./io.js\";\n\nexport class FileService extends Disposable implements IFileService {\n\tdeclare readonly _serviceBrand: undefined;\n\n\t// Choose a buffer size that is a balance between memory needs and\n\t// manageable IPC overhead. The larger the buffer size, the less\n\t// roundtrips we have to do for reading/writing data.\n\tprivate readonly BUFFER_SIZE = 256 * 1024;\n\n\tconstructor(@ILogService private readonly logService: ILogService) {\n\t\tsuper();\n\t}\n\n\t//#region File System Provider\n\n\tprivate readonly _onDidChangeFileSystemProviderRegistrations =\n\t\tthis._register(new Emitter<IFileSystemProviderRegistrationEvent>());\n\treadonly onDidChangeFileSystemProviderRegistrations =\n\t\tthis._onDidChangeFileSystemProviderRegistrations.event;\n\n\tprivate readonly _onWillActivateFileSystemProvider = this._register(\n\t\tnew Emitter<IFileSystemProviderActivationEvent>(),\n\t);\n\treadonly onWillActivateFileSystemProvider =\n\t\tthis._onWillActivateFileSystemProvider.event;\n\n\tprivate readonly _onDidChangeFileSystemProviderCapabilities =\n\t\tthis._register(\n\t\t\tnew Emitter<IFileSystemProviderCapabilitiesChangeEvent>(),\n\t\t);\n\treadonly onDidChangeFileSystemProviderCapabilities =\n\t\tthis._onDidChangeFileSystemProviderCapabilities.event;\n\n\tprivate readonly provider = new Map<string, IFileSystemProvider>();\n\n\tregisterProvider(\n\t\tscheme: string,\n\t\tprovider: IFileSystemProvider,\n\t): IDisposable {\n\t\tif (this.provider.has(scheme)) {\n\t\t\tthrow new Error(\n\t\t\t\t`A filesystem provider for the scheme '${scheme}' is already registered.`,\n\t\t\t);\n\t\t}\n\n\t\tmark(`code/registerFilesystem/${scheme}`);\n\n\t\tconst providerDisposables = new DisposableStore();\n\n\t\t// Add provider with event\n\t\tthis.provider.set(scheme, provider);\n\t\tthis._onDidChangeFileSystemProviderRegistrations.fire({\n\t\t\tadded: true,\n\t\t\tscheme,\n\t\t\tprovider,\n\t\t});\n\n\t\t// Forward events from provider\n\t\tproviderDisposables.add(\n\t\t\tprovider.onDidChangeFile((changes) => {\n\t\t\t\tconst event = new FileChangesEvent(\n\t\t\t\t\tchanges,\n\t\t\t\t\t!this.isPathCaseSensitive(provider),\n\t\t\t\t);\n\n\t\t\t\t// Always emit any event internally\n\t\t\t\tthis.internalOnDidFilesChange.fire(event);\n\n\t\t\t\t// Only emit uncorrelated events in the global `onDidFilesChange` event\n\t\t\t\tif (!event.hasCorrelation()) {\n\t\t\t\t\tthis._onDidUncorrelatedFilesChange.fire(event);\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\t\tif (typeof provider.onDidWatchError === \"function\") {\n\t\t\tproviderDisposables.add(\n\t\t\t\tprovider.onDidWatchError((error) =>\n\t\t\t\t\tthis._onDidWatchError.fire(new Error(error)),\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\t\tproviderDisposables.add(\n\t\t\tprovider.onDidChangeCapabilities(() =>\n\t\t\t\tthis._onDidChangeFileSystemProviderCapabilities.fire({\n\t\t\t\t\tprovider,\n\t\t\t\t\tscheme,\n\t\t\t\t}),\n\t\t\t),\n\t\t);\n\n\t\treturn toDisposable(() => {\n\t\t\tthis._onDidChangeFileSystemProviderRegistrations.fire({\n\t\t\t\tadded: false,\n\t\t\t\tscheme,\n\t\t\t\tprovider,\n\t\t\t});\n\t\t\tthis.provider.delete(scheme);\n\n\t\t\tdispose(providerDisposables);\n\t\t});\n\t}\n\n\tgetProvider(scheme: string): IFileSystemProvider | undefined {\n\t\treturn this.provider.get(scheme);\n\t}\n\n\tasync activateProvider(scheme: string): Promise<void> {\n\t\t// Emit an event that we are about to activate a provider with the given scheme.\n\t\t// Listeners can participate in the activation by registering a provider for it.\n\t\tconst joiners: Promise<void>[] = [];\n\t\tthis._onWillActivateFileSystemProvider.fire({\n\t\t\tscheme,\n\t\t\tjoin(promise) {\n\t\t\t\tjoiners.push(promise);\n\t\t\t},\n\t\t});\n\n\t\tif (this.provider.has(scheme)) {\n\t\t\treturn; // provider is already here so we can return directly\n\t\t}\n\n\t\t// If the provider is not yet there, make sure to join on the listeners assuming\n\t\t// that it takes a bit longer to register the file system provider.\n\t\tawait Promises.settled(joiners);\n\t}\n\n\tasync canHandleResource(resource: URI): Promise<boolean> {\n\t\t// Await activation of potentially extension contributed providers\n\t\tawait this.activateProvider(resource.scheme);\n\n\t\treturn this.hasProvider(resource);\n\t}\n\n\thasProvider(resource: URI): boolean {\n\t\treturn this.provider.has(resource.scheme);\n\t}\n\n\thasCapability(\n\t\tresource: URI,\n\t\tcapability: FileSystemProviderCapabilities,\n\t): boolean {\n\t\tconst provider = this.provider.get(resource.scheme);\n\n\t\treturn !!(provider && provider.capabilities & capability);\n\t}\n\n\tlistCapabilities(): Iterable<{\n\t\tscheme: string;\n\t\tcapabilities: FileSystemProviderCapabilities;\n\t}> {\n\t\treturn Iterable.map(this.provider, ([scheme, provider]) => ({\n\t\t\tscheme,\n\t\t\tcapabilities: provider.capabilities,\n\t\t}));\n\t}\n\n\tprotected async withProvider(resource: URI): Promise<IFileSystemProvider> {\n\t\t// Assert path is absolute\n\t\tif (!isAbsolutePath(resource)) {\n\t\t\tthrow new FileOperationError(\n\t\t\t\tlocalize(\n\t\t\t\t\t\"invalidPath\",\n\t\t\t\t\t\"Unable to resolve filesystem provider with relative file path '{0}'\",\n\t\t\t\t\tthis.resourceForError(resource),\n\t\t\t\t),\n\t\t\t\tFileOperationResult.FILE_INVALID_PATH,\n\t\t\t);\n\t\t}\n\n\t\t// Activate provider\n\t\tawait this.activateProvider(resource.scheme);\n\n\t\t// Assert provider\n\t\tconst provider = this.provider.get(resource.scheme);\n\t\tif (!provider) {\n\t\t\tconst error = new ErrorNoTelemetry();\n\t\t\terror.message = localize(\n\t\t\t\t\"noProviderFound\",\n\t\t\t\t\"ENOPRO: No file system provider found for resource '{0}'\",\n\t\t\t\tresource.toString(),\n\t\t\t);\n\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn provider;\n\t}\n\n\tprivate async withReadProvider(\n\t\tresource: URI,\n\t): Promise<\n\t\t| IFileSystemProviderWithFileReadWriteCapability\n\t\t| IFileSystemProviderWithOpenReadWriteCloseCapability\n\t\t| IFileSystemProviderWithFileReadStreamCapability\n\t> {\n\t\tconst provider = await this.withProvider(resource);\n\n\t\tif (\n\t\t\thasOpenReadWriteCloseCapability(provider) ||\n\t\t\thasReadWriteCapability(provider) ||\n\t\t\thasFileReadStreamCapability(provider)\n\t\t) {\n\t\t\treturn provider;\n\t\t}\n\n\t\tthrow new Error(\n\t\t\t`Filesystem provider for scheme '${resource.scheme}' neither has FileReadWrite, FileReadStream nor FileOpenReadWriteClose capability which is needed for the read operation.`,\n\t\t);\n\t}\n\n\tprivate async withWriteProvider(\n\t\tresource: URI,\n\t): Promise<\n\t\t| IFileSystemProviderWithFileReadWriteCapability\n\t\t| IFileSystemProviderWithOpenReadWriteCloseCapability\n\t> {\n\t\tconst provider = await this.withProvider(resource);\n\n\t\tif (\n\t\t\thasOpenReadWriteCloseCapability(provider) ||\n\t\t\thasReadWriteCapability(provider)\n\t\t) {\n\t\t\treturn provider;\n\t\t}\n\n\t\tthrow new Error(\n\t\t\t`Filesystem provider for scheme '${resource.scheme}' neither has FileReadWrite nor FileOpenReadWriteClose capability which is needed for the write operation.`,\n\t\t);\n\t}\n\n\t//#endregion\n\n\t//#region Operation events\n\n\tprivate readonly _onDidRunOperation = this._register(\n\t\tnew Emitter<FileOperationEvent>(),\n\t);\n\treadonly onDidRunOperation = this._onDidRunOperation.event;\n\n\t//#endregion\n\n\t//#region File Metadata Resolving\n\n\tasync resolve(\n\t\tresource: URI,\n\t\toptions: IResolveMetadataFileOptions,\n\t): Promise<IFileStatWithMetadata>;\n\tasync resolve(\n\t\tresource: URI,\n\t\toptions?: IResolveFileOptions,\n\t): Promise<IFileStat>;\n\tasync resolve(\n\t\tresource: URI,\n\t\toptions?: IResolveFileOptions,\n\t): Promise<IFileStat> {\n\t\ttry {\n\t\t\treturn await this.doResolveFile(resource, options);\n\t\t} catch (error) {\n\t\t\t// Specially handle file not found case as file operation result\n\t\t\tif (\n\t\t\t\ttoFileSystemProviderErrorCode(error) ===\n\t\t\t\tFileSystemProviderErrorCode.FileNotFound\n\t\t\t) {\n\t\t\t\tthrow new FileOperationError(\n\t\t\t\t\tlocalize(\n\t\t\t\t\t\t\"fileNotFoundError\",\n\t\t\t\t\t\t\"Unable to resolve nonexistent file '{0}'\",\n\t\t\t\t\t\tthis.resourceForError(resource),\n\t\t\t\t\t),\n\t\t\t\t\tFileOperationResult.FILE_NOT_FOUND,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Bubble up any other error as is\n\t\t\tthrow ensureFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tprivate async doResolveFile(\n\t\tresource: URI,\n\t\toptions: IResolveMetadataFileOptions,\n\t): Promise<IFileStatWithMetadata>;\n\tprivate async doResolveFile(\n\t\tresource: URI,\n\t\toptions?: IResolveFileOptions,\n\t): Promise<IFileStat>;\n\tprivate async doResolveFile(\n\t\tresource: URI,\n\t\toptions?: IResolveFileOptions,\n\t): Promise<IFileStat> {\n\t\tconst provider = await this.withProvider(resource);\n\t\tconst isPathCaseSensitive = this.isPathCaseSensitive(provider);\n\n\t\tconst resolveTo = options?.resolveTo;\n\t\tconst resolveSingleChildDescendants =\n\t\t\toptions?.resolveSingleChildDescendants;\n\t\tconst resolveMetadata = options?.resolveMetadata;\n\n\t\tconst stat = await provider.stat(resource);\n\n\t\tlet trie: TernarySearchTree<URI, boolean> | undefined;\n\n\t\treturn this.toFileStat(\n\t\t\tprovider,\n\t\t\tresource,\n\t\t\tstat,\n\t\t\tundefined,\n\t\t\t!!resolveMetadata,\n\t\t\t(stat, siblings) => {\n\t\t\t\t// lazy trie to check for recursive resolving\n\t\t\t\tif (!trie) {\n\t\t\t\t\ttrie = TernarySearchTree.forUris<true>(\n\t\t\t\t\t\t() => !isPathCaseSensitive,\n\t\t\t\t\t);\n\t\t\t\t\ttrie.set(resource, true);\n\t\t\t\t\tif (resolveTo) {\n\t\t\t\t\t\ttrie.fill(true, resolveTo);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// check for recursive resolving\n\t\t\t\tif (\n\t\t\t\t\ttrie.get(stat.resource) ||\n\t\t\t\t\ttrie.findSuperstr(\n\t\t\t\t\t\tstat.resource.with(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tquery: null,\n\t\t\t\t\t\t\t\tfragment: null,\n\t\t\t\t\t\t\t} /* required for https://github.com/microsoft/vscode/issues/128151 */,\n\t\t\t\t\t\t),\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// check for resolving single child folders\n\t\t\t\tif (stat.isDirectory && resolveSingleChildDescendants) {\n\t\t\t\t\treturn siblings === 1;\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t},\n\t\t);\n\t}\n\n\tprivate async toFileStat(\n\t\tprovider: IFileSystemProvider,\n\t\tresource: URI,\n\t\tstat: IStat | ({ type: FileType } & Partial<IStat>),\n\t\tsiblings: number | undefined,\n\t\tresolveMetadata: boolean,\n\t\trecurse: (stat: IFileStat, siblings?: number) => boolean,\n\t): Promise<IFileStat>;\n\tprivate async toFileStat(\n\t\tprovider: IFileSystemProvider,\n\t\tresource: URI,\n\t\tstat: IStat,\n\t\tsiblings: number | undefined,\n\t\tresolveMetadata: true,\n\t\trecurse: (stat: IFileStat, siblings?: number) => boolean,\n\t): Promise<IFileStatWithMetadata>;\n\tprivate async toFileStat(\n\t\tprovider: IFileSystemProvider,\n\t\tresource: URI,\n\t\tstat: IStat | ({ type: FileType } & Partial<IStat>),\n\t\tsiblings: number | undefined,\n\t\tresolveMetadata: boolean,\n\t\trecurse: (stat: IFileStat, siblings?: number) => boolean,\n\t): Promise<IFileStat> {\n\t\tconst { providerExtUri } = this.getExtUri(provider);\n\n\t\t// convert to file stat\n\t\tconst fileStat: IFileStat = {\n\t\t\tresource,\n\t\t\tname: providerExtUri.basename(resource),\n\t\t\tisFile: (stat.type & FileType.File) !== 0,\n\t\t\tisDirectory: (stat.type & FileType.Directory) !== 0,\n\t\t\tisSymbolicLink: (stat.type & FileType.SymbolicLink) !== 0,\n\t\t\tmtime: stat.mtime,\n\t\t\tctime: stat.ctime,\n\t\t\tsize: stat.size,\n\t\t\treadonly:\n\t\t\t\tBoolean((stat.permissions ?? 0) & FilePermission.Readonly) ||\n\t\t\t\tBoolean(\n\t\t\t\t\tprovider.capabilities &\n\t\t\t\t\t\tFileSystemProviderCapabilities.Readonly,\n\t\t\t\t),\n\t\t\tlocked: Boolean((stat.permissions ?? 0) & FilePermission.Locked),\n\t\t\tetag: etag({ mtime: stat.mtime, size: stat.size }),\n\t\t\tchildren: undefined,\n\t\t};\n\n\t\t// check to recurse for directories\n\t\tif (fileStat.isDirectory && recurse(fileStat, siblings)) {\n\t\t\ttry {\n\t\t\t\tconst entries = await provider.readdir(resource);\n\t\t\t\tconst resolvedEntries = await Promises.settled(\n\t\t\t\t\tentries.map(async ([name, type]) => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst childResource = providerExtUri.joinPath(\n\t\t\t\t\t\t\t\tresource,\n\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst childStat = resolveMetadata\n\t\t\t\t\t\t\t\t? await provider.stat(childResource)\n\t\t\t\t\t\t\t\t: { type };\n\n\t\t\t\t\t\t\treturn await this.toFileStat(\n\t\t\t\t\t\t\t\tprovider,\n\t\t\t\t\t\t\t\tchildResource,\n\t\t\t\t\t\t\t\tchildStat,\n\t\t\t\t\t\t\t\tentries.length,\n\t\t\t\t\t\t\t\tresolveMetadata,\n\t\t\t\t\t\t\t\trecurse,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tthis.logService.trace(error);\n\n\t\t\t\t\t\t\treturn null; // can happen e.g. due to permission errors\n\t\t\t\t\t\t}\n\t\t\t\t\t}),\n\t\t\t\t);\n\n\t\t\t\t// make sure to get rid of null values that signal a failure to resolve a particular entry\n\t\t\t\tfileStat.children = coalesce(resolvedEntries);\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.trace(error);\n\n\t\t\t\tfileStat.children = []; // gracefully handle errors, we may not have permissions to read\n\t\t\t}\n\n\t\t\treturn fileStat;\n\t\t}\n\n\t\treturn fileStat;\n\t}\n\n\tasync resolveAll(\n\t\ttoResolve: { resource: URI; options?: IResolveFileOptions }[],\n\t): Promise<IFileStatResult[]>;\n\tasync resolveAll(\n\t\ttoResolve: { resource: URI; options: IResolveMetadataFileOptions }[],\n\t): Promise<IFileStatResultWithMetadata[]>;\n\tasync resolveAll(\n\t\ttoResolve: { resource: URI; options?: IResolveFileOptions }[],\n\t): Promise<IFileStatResult[]> {\n\t\treturn Promises.settled(\n\t\t\ttoResolve.map(async (entry) => {\n\t\t\t\ttry {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tstat: await this.doResolveFile(\n\t\t\t\t\t\t\tentry.resource,\n\t\t\t\t\t\t\tentry.options,\n\t\t\t\t\t\t),\n\t\t\t\t\t\tsuccess: true,\n\t\t\t\t\t};\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.logService.trace(error);\n\n\t\t\t\t\treturn { stat: undefined, success: false };\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\t}\n\n\tasync stat(resource: URI): Promise<IFileStatWithPartialMetadata> {\n\t\tconst provider = await this.withProvider(resource);\n\n\t\tconst stat = await provider.stat(resource);\n\n\t\treturn this.toFileStat(\n\t\t\tprovider,\n\t\t\tresource,\n\t\t\tstat,\n\t\t\tundefined,\n\t\t\ttrue,\n\t\t\t() => false /* Do not resolve any children */,\n\t\t);\n\t}\n\n\tasync exists(resource: URI): Promise<boolean> {\n\t\tconst provider = await this.withProvider(resource);\n\n\t\ttry {\n\t\t\tconst stat = await provider.stat(resource);\n\n\t\t\treturn !!stat;\n\t\t} catch (error) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region File Reading/Writing\n\n\tasync canCreateFile(\n\t\tresource: URI,\n\t\toptions?: ICreateFileOptions,\n\t): Promise<Error | true> {\n\t\ttry {\n\t\t\tawait this.doValidateCreateFile(resource, options);\n\t\t} catch (error) {\n\t\t\treturn error;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate async doValidateCreateFile(\n\t\tresource: URI,\n\t\toptions?: ICreateFileOptions,\n\t): Promise<void> {\n\t\t// validate overwrite\n\t\tif (!options?.overwrite && (await this.exists(resource))) {\n\t\t\tthrow new FileOperationError(\n\t\t\t\tlocalize(\n\t\t\t\t\t\"fileExists\",\n\t\t\t\t\t\"Unable to create file '{0}' that already exists when overwrite flag is not set\",\n\t\t\t\t\tthis.resourceForError(resource),\n\t\t\t\t),\n\t\t\t\tFileOperationResult.FILE_MODIFIED_SINCE,\n\t\t\t\toptions,\n\t\t\t);\n\t\t}\n\t}\n\n\tasync createFile(\n\t\tresource: URI,\n\t\tbufferOrReadableOrStream:\n\t\t\t| VSBuffer\n\t\t\t| VSBufferReadable\n\t\t\t| VSBufferReadableStream = VSBuffer.fromString(\"\"),\n\t\toptions?: ICreateFileOptions,\n\t): Promise<IFileStatWithMetadata> {\n\t\t// validate\n\t\tawait this.doValidateCreateFile(resource, options);\n\n\t\t// do write into file (this will create it too)\n\t\tconst fileStat = await this.writeFile(\n\t\t\tresource,\n\t\t\tbufferOrReadableOrStream,\n\t\t);\n\n\t\t// events\n\t\tthis._onDidRunOperation.fire(\n\t\t\tnew FileOperationEvent(resource, FileOperation.CREATE, fileStat),\n\t\t);\n\n\t\treturn fileStat;\n\t}\n\n\tasync writeFile(\n\t\tresource: URI,\n\t\tbufferOrReadableOrStream:\n\t\t\t| VSBuffer\n\t\t\t| VSBufferReadable\n\t\t\t| VSBufferReadableStream,\n\t\toptions?: IWriteFileOptions,\n\t): Promise<IFileStatWithMetadata> {\n\t\tconst provider = this.throwIfFileSystemIsReadonly(\n\t\t\tawait this.withWriteProvider(resource),\n\t\t\tresource,\n\t\t);\n\t\tconst { providerExtUri } = this.getExtUri(provider);\n\n\t\tlet writeFileOptions = options;\n\t\tif (\n\t\t\thasFileAtomicWriteCapability(provider) &&\n\t\t\t!writeFileOptions?.atomic\n\t\t) {\n\t\t\tconst enforcedAtomicWrite =\n\t\t\t\tprovider.enforceAtomicWriteFile?.(resource);\n\t\t\tif (enforcedAtomicWrite) {\n\t\t\t\twriteFileOptions = { ...options, atomic: enforcedAtomicWrite };\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\t// validate write\n\t\t\tconst stat = await this.validateWriteFile(\n\t\t\t\tprovider,\n\t\t\t\tresource,\n\t\t\t\twriteFileOptions,\n\t\t\t);\n\n\t\t\t// mkdir recursively as needed\n\t\t\tif (!stat) {\n\t\t\t\tawait this.mkdirp(provider, providerExtUri.dirname(resource));\n\t\t\t}\n\n\t\t\t// optimization: if the provider has unbuffered write capability and the data\n\t\t\t// to write is not a buffer, we consume up to 3 chunks and try to write the data\n\t\t\t// unbuffered to reduce the overhead. If the stream or readable has more data\n\t\t\t// to provide we continue to write buffered.\n\t\t\tlet bufferOrReadableOrStreamOrBufferedStream:\n\t\t\t\t| VSBuffer\n\t\t\t\t| VSBufferReadable\n\t\t\t\t| VSBufferReadableStream\n\t\t\t\t| VSBufferReadableBufferedStream;\n\t\t\tif (\n\t\t\t\thasReadWriteCapability(provider) &&\n\t\t\t\t!(bufferOrReadableOrStream instanceof VSBuffer)\n\t\t\t) {\n\t\t\t\tif (isReadableStream(bufferOrReadableOrStream)) {\n\t\t\t\t\tconst bufferedStream = await peekStream(\n\t\t\t\t\t\tbufferOrReadableOrStream,\n\t\t\t\t\t\t3,\n\t\t\t\t\t);\n\t\t\t\t\tif (bufferedStream.ended) {\n\t\t\t\t\t\tbufferOrReadableOrStreamOrBufferedStream =\n\t\t\t\t\t\t\tVSBuffer.concat(bufferedStream.buffer);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbufferOrReadableOrStreamOrBufferedStream =\n\t\t\t\t\t\t\tbufferedStream;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbufferOrReadableOrStreamOrBufferedStream = peekReadable(\n\t\t\t\t\t\tbufferOrReadableOrStream,\n\t\t\t\t\t\t(data) => VSBuffer.concat(data),\n\t\t\t\t\t\t3,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbufferOrReadableOrStreamOrBufferedStream =\n\t\t\t\t\tbufferOrReadableOrStream;\n\t\t\t}\n\n\t\t\t// write file: unbuffered\n\t\t\tif (\n\t\t\t\t!hasOpenReadWriteCloseCapability(provider) || // buffered writing is unsupported\n\t\t\t\t(hasReadWriteCapability(provider) &&\n\t\t\t\t\tbufferOrReadableOrStreamOrBufferedStream instanceof\n\t\t\t\t\t\tVSBuffer) || // data is a full buffer already\n\t\t\t\t(hasReadWriteCapability(provider) &&\n\t\t\t\t\thasFileAtomicWriteCapability(provider) &&\n\t\t\t\t\twriteFileOptions?.atomic) // atomic write forces unbuffered write if the provider supports it\n\t\t\t) {\n\t\t\t\tawait this.doWriteUnbuffered(\n\t\t\t\t\tprovider,\n\t\t\t\t\tresource,\n\t\t\t\t\twriteFileOptions,\n\t\t\t\t\tbufferOrReadableOrStreamOrBufferedStream,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// write file: buffered\n\t\t\telse {\n\t\t\t\tawait this.doWriteBuffered(\n\t\t\t\t\tprovider,\n\t\t\t\t\tresource,\n\t\t\t\t\twriteFileOptions,\n\t\t\t\t\tbufferOrReadableOrStreamOrBufferedStream instanceof VSBuffer\n\t\t\t\t\t\t? bufferToReadable(\n\t\t\t\t\t\t\t\tbufferOrReadableOrStreamOrBufferedStream,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t: bufferOrReadableOrStreamOrBufferedStream,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// events\n\t\t\tthis._onDidRunOperation.fire(\n\t\t\t\tnew FileOperationEvent(resource, FileOperation.WRITE),\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tthrow new FileOperationError(\n\t\t\t\tlocalize(\n\t\t\t\t\t\"err.write\",\n\t\t\t\t\t\"Unable to write file '{0}' ({1})\",\n\t\t\t\t\tthis.resourceForError(resource),\n\t\t\t\t\tensureFileSystemProviderError(error).toString(),\n\t\t\t\t),\n\t\t\t\ttoFileOperationResult(error),\n\t\t\t\twriteFileOptions,\n\t\t\t);\n\t\t}\n\n\t\treturn this.resolve(resource, { resolveMetadata: true });\n\t}\n\n\tprivate async validateWriteFile(\n\t\tprovider: IFileSystemProvider,\n\t\tresource: URI,\n\t\toptions?: IWriteFileOptions,\n\t): Promise<IStat | undefined> {\n\t\t// Validate unlock support\n\t\tconst unlock = !!options?.unlock;\n\t\tif (\n\t\t\tunlock &&\n\t\t\t!(\n\t\t\t\tprovider.capabilities &\n\t\t\t\tFileSystemProviderCapabilities.FileWriteUnlock\n\t\t\t)\n\t\t) {\n\t\t\tthrow new Error(\n\t\t\t\tlocalize(\n\t\t\t\t\t\"writeFailedUnlockUnsupported\",\n\t\t\t\t\t\"Unable to unlock file '{0}' because provider does not support it.\",\n\t\t\t\t\tthis.resourceForError(resource),\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\n\t\t// Validate atomic support\n\t\tconst atomic = !!options?.atomic;\n\t\tif (atomic) {\n\t\t\tif (\n\t\t\t\t!(\n\t\t\t\t\tprovider.capabilities &\n\t\t\t\t\tFileSystemProviderCapabilities.FileAtomicWrite\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\tlocalize(\n\t\t\t\t\t\t\"writeFailedAtomicUnsupported1\",\n\t\t\t\t\t\t\"Unable to atomically write file '{0}' because provider does not support it.\",\n\t\t\t\t\t\tthis.resourceForError(resource),\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t!(\n\t\t\t\t\tprovider.capabilities &\n\t\t\t\t\tFileSystemProviderCapabilities.FileReadWrite\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\tlocalize(\n\t\t\t\t\t\t\"writeFailedAtomicUnsupported2\",\n\t\t\t\t\t\t\"Unable to atomically write file '{0}' because provider does not support unbuffered writes.\",\n\t\t\t\t\t\tthis.resourceForError(resource),\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (unlock) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\tlocalize(\n\t\t\t\t\t\t\"writeFailedAtomicUnlock\",\n\t\t\t\t\t\t\"Unable to unlock file '{0}' because atomic write is enabled.\",\n\t\t\t\t\t\tthis.resourceForError(resource),\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Validate via file stat meta data\n\t\tlet stat: IStat | undefined;\n\t\ttry {\n\t\t\tstat = await provider.stat(resource);\n\t\t} catch (error) {\n\t\t\treturn undefined; // file might not exist\n\t\t}\n\n\t\t// File cannot be directory\n\t\tif ((stat.type & FileType.Directory) !== 0) {\n\t\t\tthrow new FileOperationError(\n\t\t\t\tlocalize(\n\t\t\t\t\t\"fileIsDirectoryWriteError\",\n\t\t\t\t\t\"Unable to write file '{0}' that is actually a directory\",\n\t\t\t\t\tthis.resourceForError(resource),\n\t\t\t\t),\n\t\t\t\tFileOperationResult.FILE_IS_DIRECTORY,\n\t\t\t\toptions,\n\t\t\t);\n\t\t}\n\n\t\t// File cannot be readonly\n\t\tthis.throwIfFileIsReadonly(resource, stat);\n\n\t\t// Dirty write prevention: if the file on disk has been changed and does not match our expected\n\t\t// mtime and etag, we bail out to prevent dirty writing.\n\t\t//\n\t\t// First, we check for a mtime that is in the future before we do more checks. The assumption is\n\t\t// that only the mtime is an indicator for a file that has changed on disk.\n\t\t//\n\t\t// Second, if the mtime has advanced, we compare the size of the file on disk with our previous\n\t\t// one using the etag() function. Relying only on the mtime check has prooven to produce false\n\t\t// positives due to file system weirdness (especially around remote file systems). As such, the\n\t\t// check for size is a weaker check because it can return a false negative if the file has changed\n\t\t// but to the same length. This is a compromise we take to avoid having to produce checksums of\n\t\t// the file content for comparison which would be much slower to compute.\n\t\tif (\n\t\t\ttypeof options?.mtime === \"number\" &&\n\t\t\ttypeof options.etag === \"string\" &&\n\t\t\toptions.etag !== ETAG_DISABLED &&\n\t\t\ttypeof stat.mtime === \"number\" &&\n\t\t\ttypeof stat.size === \"number\" &&\n\t\t\toptions.mtime < stat.mtime &&\n\t\t\toptions.etag !==\n\t\t\t\tetag({\n\t\t\t\t\tmtime: options.mtime /* not using stat.mtime for a reason, see above */,\n\t\t\t\t\tsize: stat.size,\n\t\t\t\t})\n\t\t) {\n\t\t\tthrow new FileOperationError(\n\t\t\t\tlocalize(\"fileModifiedError\", \"File Modified Since\"),\n\t\t\t\tFileOperationResult.FILE_MODIFIED_SINCE,\n\t\t\t\toptions,\n\t\t\t);\n\t\t}\n\n\t\treturn stat;\n\t}\n\n\tasync readFile(\n\t\tresource: URI,\n\t\toptions?: IReadFileOptions,\n\t\ttoken?: CancellationToken,\n\t): Promise<IFileContent> {\n\t\tconst provider = await this.withReadProvider(resource);\n\n\t\tif (options?.atomic) {\n\t\t\treturn this.doReadFileAtomic(provider, resource, options, token);\n\t\t}\n\n\t\treturn this.doReadFile(provider, resource, options, token);\n\t}\n\n\tprivate async doReadFileAtomic(\n\t\tprovider:\n\t\t\t| IFileSystemProviderWithFileReadWriteCapability\n\t\t\t| IFileSystemProviderWithOpenReadWriteCloseCapability\n\t\t\t| IFileSystemProviderWithFileReadStreamCapability,\n\t\tresource: URI,\n\t\toptions?: IReadFileOptions,\n\t\ttoken?: CancellationToken,\n\t): Promise<IFileContent> {\n\t\treturn new Promise<IFileContent>((resolve, reject) => {\n\t\t\tthis.writeQueue.queueFor(\n\t\t\t\tresource,\n\t\t\t\tasync () => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst content = await this.doReadFile(\n\t\t\t\t\t\t\tprovider,\n\t\t\t\t\t\t\tresource,\n\t\t\t\t\t\t\toptions,\n\t\t\t\t\t\t\ttoken,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tresolve(content);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tthis.getExtUri(provider).providerExtUri,\n\t\t\t);\n\t\t});\n\t}\n\n\tprivate async doReadFile(\n\t\tprovider:\n\t\t\t| IFileSystemProviderWithFileReadWriteCapability\n\t\t\t| IFileSystemProviderWithOpenReadWriteCloseCapability\n\t\t\t| IFileSystemProviderWithFileReadStreamCapability,\n\t\tresource: URI,\n\t\toptions?: IReadFileOptions,\n\t\ttoken?: CancellationToken,\n\t): Promise<IFileContent> {\n\t\tconst stream = await this.doReadFileStream(\n\t\t\tprovider,\n\t\t\tresource,\n\t\t\t{\n\t\t\t\t...options,\n\t\t\t\t// optimization: since we know that the caller does not\n\t\t\t\t// care about buffering, we indicate this to the reader.\n\t\t\t\t// this reduces all the overhead the buffered reading\n\t\t\t\t// has (open, read, close) if the provider supports\n\t\t\t\t// unbuffered reading.\n\t\t\t\tpreferUnbuffered: true,\n\t\t\t},\n\t\t\ttoken,\n\t\t);\n\n\t\treturn {\n\t\t\t...stream,\n\t\t\tvalue: await streamToBuffer(stream.value),\n\t\t};\n\t}\n\n\tasync readFileStream(\n\t\tresource: URI,\n\t\toptions?: IReadFileStreamOptions,\n\t\ttoken?: CancellationToken,\n\t): Promise<IFileStreamContent> {\n\t\tconst provider = await this.withReadProvider(resource);\n\n\t\treturn this.doReadFileStream(provider, resource, options, token);\n\t}\n\n\tprivate async doReadFileStream(\n\t\tprovider:\n\t\t\t| IFileSystemProviderWithFileReadWriteCapability\n\t\t\t| IFileSystemProviderWithOpenReadWriteCloseCapability\n\t\t\t| IFileSystemProviderWithFileReadStreamCapability,\n\t\tresource: URI,\n\t\toptions?: IReadFileOptions &\n\t\t\tIReadFileStreamOptions & { preferUnbuffered?: boolean },\n\t\ttoken?: CancellationToken,\n\t): Promise<IFileStreamContent> {\n\t\t// install a cancellation token that gets cancelled\n\t\t// when any error occurs. this allows us to resolve\n\t\t// the content of the file while resolving metadata\n\t\t// but still cancel the operation in certain cases.\n\t\t//\n\t\t// in addition, we pass the optional token in that\n\t\t// we got from the outside to even allow for external\n\t\t// cancellation of the read operation.\n\t\tconst cancellableSource = new CancellationTokenSource(token);\n\n\t\tlet readFileOptions = options;\n\t\tif (\n\t\t\thasFileAtomicReadCapability(provider) &&\n\t\t\tprovider.enforceAtomicReadFile?.(resource)\n\t\t) {\n\t\t\treadFileOptions = { ...options, atomic: true };\n\t\t}\n\n\t\t// validate read operation\n\t\tconst statPromise = this.validateReadFile(\n\t\t\tresource,\n\t\t\treadFileOptions,\n\t\t).then(\n\t\t\t(stat) => stat,\n\t\t\t(error) => {\n\t\t\t\tcancellableSource.dispose(true);\n\n\t\t\t\tthrow error;\n\t\t\t},\n\t\t);\n\n\t\tlet fileStream: VSBufferReadableStream | undefined;\n\t\ttry {\n\t\t\t// if the etag is provided, we await the result of the validation\n\t\t\t// due to the likelihood of hitting a NOT_MODIFIED_SINCE result.\n\t\t\t// otherwise, we let it run in parallel to the file reading for\n\t\t\t// optimal startup performance.\n\t\t\tif (\n\t\t\t\ttypeof readFileOptions?.etag === \"string\" &&\n\t\t\t\treadFileOptions.etag !== ETAG_DISABLED\n\t\t\t) {\n\t\t\t\tawait statPromise;\n\t\t\t}\n\n\t\t\t// read unbuffered\n\t\t\tif (\n\t\t\t\t(readFileOptions?.atomic &&\n\t\t\t\t\thasFileAtomicReadCapability(provider)) || // atomic reads are always unbuffered\n\t\t\t\t!(\n\t\t\t\t\thasOpenReadWriteCloseCapability(provider) ||\n\t\t\t\t\thasFileReadStreamCapability(provider)\n\t\t\t\t) || // provider has no buffered capability\n\t\t\t\t(hasReadWriteCapability(provider) &&\n\t\t\t\t\treadFileOptions?.preferUnbuffered) // unbuffered read is preferred\n\t\t\t) {\n\t\t\t\tfileStream = this.readFileUnbuffered(\n\t\t\t\t\tprovider,\n\t\t\t\t\tresource,\n\t\t\t\t\treadFileOptions,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// read streamed (always prefer over primitive buffered read)\n\t\t\telse if (hasFileReadStreamCapability(provider)) {\n\t\t\t\tfileStream = this.readFileStreamed(\n\t\t\t\t\tprovider,\n\t\t\t\t\tresource,\n\t\t\t\t\tcancellableSource.token,\n\t\t\t\t\treadFileOptions,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// read buffered\n\t\t\telse {\n\t\t\t\tfileStream = this.readFileBuffered(\n\t\t\t\t\tprovider,\n\t\t\t\t\tresource,\n\t\t\t\t\tcancellableSource.token,\n\t\t\t\t\treadFileOptions,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tfileStream.on(\"end\", () => cancellableSource.dispose());\n\t\t\tfileStream.on(\"error\", () => cancellableSource.dispose());\n\n\t\t\tconst fileStat = await statPromise;\n\n\t\t\treturn {\n\t\t\t\t...fileStat,\n\t\t\t\tvalue: fileStream,\n\t\t\t};\n\t\t} catch (error) {\n\t\t\t// Await the stream to finish so that we exit this method\n\t\t\t// in a consistent state with file handles closed\n\t\t\t// (https://github.com/microsoft/vscode/issues/114024)\n\t\t\tif (fileStream) {\n\t\t\t\tawait consumeStream(fileStream);\n\t\t\t}\n\n\t\t\t// Re-throw errors as file operation errors but preserve\n\t\t\t// specific errors (such as not modified since)\n\t\t\tthrow this.restoreReadError(error, resource, readFileOptions);\n\t\t}\n\t}\n\n\tprivate restoreReadError(\n\t\terror: Error,\n\t\tresource: URI,\n\t\toptions?: IReadFileStreamOptions,\n\t): FileOperationError {\n\t\tconst message = localize(\n\t\t\t\"err.read\",\n\t\t\t\"Unable to read file '{0}' ({1})\",\n\t\t\tthis.resourceForError(resource),\n\t\t\tensureFileSystemProviderError(error).toString(),\n\t\t);\n\n\t\tif (error instanceof NotModifiedSinceFileOperationError) {\n\t\t\treturn new NotModifiedSinceFileOperationError(\n\t\t\t\tmessage,\n\t\t\t\terror.stat,\n\t\t\t\toptions,\n\t\t\t);\n\t\t}\n\n\t\tif (error instanceof TooLargeFileOperationError) {\n\t\t\treturn new TooLargeFileOperationError(\n\t\t\t\tmessage,\n\t\t\t\terror.fileOperationResult,\n\t\t\t\terror.size,\n\t\t\t\terror.options as IReadFileOptions,\n\t\t\t);\n\t\t}\n\n\t\treturn new FileOperationError(\n\t\t\tmessage,\n\t\t\ttoFileOperationResult(error),\n\t\t\toptions,\n\t\t);\n\t}\n\n\tprivate readFileStreamed(\n\t\tprovider: IFileSystemProviderWithFileReadStreamCapability,\n\t\tresource: URI,\n\t\ttoken: CancellationToken,\n\t\toptions: IReadFileStreamOptions = Object.create(null),\n\t): VSBufferReadableStream {\n\t\tconst fileStream = provider.readFileStream(resource, options, token);\n\n\t\treturn transform(\n\t\t\tfileStream,\n\t\t\t{\n\t\t\t\tdata: (data) =>\n\t\t\t\t\tdata instanceof VSBuffer ? data : VSBuffer.wrap(data),\n\t\t\t\terror: (error) =>\n\t\t\t\t\tthis.restoreReadError(error, resource, options),\n\t\t\t},\n\t\t\t(data) => VSBuffer.concat(data),\n\t\t);\n\t}\n\n\tprivate readFileBuffered(\n\t\tprovider: IFileSystemProviderWithOpenReadWriteCloseCapability,\n\t\tresource: URI,\n\t\ttoken: CancellationToken,\n\t\toptions: IReadFileStreamOptions = Object.create(null),\n\t): VSBufferReadableStream {\n\t\tconst stream = newWriteableBufferStream();\n\n\t\treadFileIntoStream(\n\t\t\tprovider,\n\t\t\tresource,\n\t\t\tstream,\n\t\t\t(data) => data,\n\t\t\t{\n\t\t\t\t...options,\n\t\t\t\tbufferSize: this.BUFFER_SIZE,\n\t\t\t\terrorTransformer: (error) =>\n\t\t\t\t\tthis.restoreReadError(error, resource, options),\n\t\t\t},\n\t\t\ttoken,\n\t\t);\n\n\t\treturn stream;\n\t}\n\n\tprivate readFileUnbuffered(\n\t\tprovider:\n\t\t\t| IFileSystemProviderWithFileReadWriteCapability\n\t\t\t| IFileSystemProviderWithFileAtomicReadCapability,\n\t\tresource: URI,\n\t\toptions?: IReadFileOptions & IReadFileStreamOptions,\n\t): VSBufferReadableStream {\n\t\tconst stream = newWriteableStream<VSBuffer>((data) =>\n\t\t\tVSBuffer.concat(data),\n\t\t);\n\n\t\t// Read the file into the stream async but do not wait for\n\t\t// this to complete because streams work via events\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tlet buffer: Uint8Array;\n\t\t\t\tif (options?.atomic && hasFileAtomicReadCapability(provider)) {\n\t\t\t\t\tbuffer = await provider.readFile(resource, {\n\t\t\t\t\t\tatomic: true,\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tbuffer = await provider.readFile(resource);\n\t\t\t\t}\n\n\t\t\t\t// respect position option\n\t\t\t\tif (typeof options?.position === \"number\") {\n\t\t\t\t\tbuffer = buffer.slice(options.position);\n\t\t\t\t}\n\n\t\t\t\t// respect length option\n\t\t\t\tif (typeof options?.length === \"number\") {\n\t\t\t\t\tbuffer = buffer.slice(0, options.length);\n\t\t\t\t}\n\n\t\t\t\t// Throw if file is too large to load\n\t\t\t\tthis.validateReadFileLimits(\n\t\t\t\t\tresource,\n\t\t\t\t\tbuffer.byteLength,\n\t\t\t\t\toptions,\n\t\t\t\t);\n\n\t\t\t\t// End stream with data\n\t\t\t\tstream.end(VSBuffer.wrap(buffer));\n\t\t\t} catch (err) {\n\t\t\t\tstream.error(err);\n\t\t\t\tstream.end();\n\t\t\t}\n\t\t})();\n\n\t\treturn stream;\n\t}\n\n\tprivate async validateReadFile(\n\t\tresource: URI,\n\t\toptions?: IReadFileStreamOptions,\n\t): Promise<IFileStatWithMetadata> {\n\t\tconst stat = await this.resolve(resource, { resolveMetadata: true });\n\n\t\t// Throw if resource is a directory\n\t\tif (stat.isDirectory) {\n\t\t\tthrow new FileOperationError(\n\t\t\t\tlocalize(\n\t\t\t\t\t\"fileIsDirectoryReadError\",\n\t\t\t\t\t\"Unable to read file '{0}' that is actually a directory\",\n\t\t\t\t\tthis.resourceForError(resource),\n\t\t\t\t),\n\t\t\t\tFileOperationResult.FILE_IS_DIRECTORY,\n\t\t\t\toptions,\n\t\t\t);\n\t\t}\n\n\t\t// Throw if file not modified since (unless disabled)\n\t\tif (\n\t\t\ttypeof options?.etag === \"string\" &&\n\t\t\toptions.etag !== ETAG_DISABLED &&\n\t\t\toptions.etag === stat.etag\n\t\t) {\n\t\t\tthrow new NotModifiedSinceFileOperationError(\n\t\t\t\tlocalize(\"fileNotModifiedError\", \"File not modified since\"),\n\t\t\t\tstat,\n\t\t\t\toptions,\n\t\t\t);\n\t\t}\n\n\t\t// Throw if file is too large to load\n\t\tthis.validateReadFileLimits(resource, stat.size, options);\n\n\t\treturn stat;\n\t}\n\n\tprivate validateReadFileLimits(\n\t\tresource: URI,\n\t\tsize: number,\n\t\toptions?: IReadFileStreamOptions,\n\t): void {\n\t\tif (\n\t\t\ttypeof options?.limits?.size === \"number\" &&\n\t\t\tsize > options.limits.size\n\t\t) {\n\t\t\tthrow new TooLargeFileOperationError(\n\t\t\t\tlocalize(\n\t\t\t\t\t\"fileTooLargeError\",\n\t\t\t\t\t\"Unable to read file '{0}' that is too large to open\",\n\t\t\t\t\tthis.resourceForError(resource),\n\t\t\t\t),\n\t\t\t\tFileOperationResult.FILE_TOO_LARGE,\n\t\t\t\tsize,\n\t\t\t\toptions,\n\t\t\t);\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region Move/Copy/Delete/Create Folder\n\n\tasync canMove(\n\t\tsource: URI,\n\t\ttarget: URI,\n\t\toverwrite?: boolean,\n\t): Promise<Error | true> {\n\t\treturn this.doCanMoveCopy(source, target, \"move\", overwrite);\n\t}\n\n\tasync canCopy(\n\t\tsource: URI,\n\t\ttarget: URI,\n\t\toverwrite?: boolean,\n\t): Promise<Error | true> {\n\t\treturn this.doCanMoveCopy(source, target, \"copy\", overwrite);\n\t}\n\n\tprivate async doCanMoveCopy(\n\t\tsource: URI,\n\t\ttarget: URI,\n\t\tmode: \"move\" | \"copy\",\n\t\toverwrite?: boolean,\n\t): Promise<Error | true> {\n\t\tif (source.toString() !== target.toString()) {\n\t\t\ttry {\n\t\t\t\tconst sourceProvider =\n\t\t\t\t\tmode === \"move\"\n\t\t\t\t\t\t? this.throwIfFileSystemIsReadonly(\n\t\t\t\t\t\t\t\tawait this.withWriteProvider(source),\n\t\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t: await this.withReadProvider(source);\n\t\t\t\tconst targetProvider = this.throwIfFileSystemIsReadonly(\n\t\t\t\t\tawait this.withWriteProvider(target),\n\t\t\t\t\ttarget,\n\t\t\t\t);\n\n\t\t\t\tawait this.doValidateMoveCopy(\n\t\t\t\t\tsourceProvider,\n\t\t\t\t\tsource,\n\t\t\t\t\ttargetProvider,\n\t\t\t\t\ttarget,\n\t\t\t\t\tmode,\n\t\t\t\t\toverwrite,\n\t\t\t\t);\n\t\t\t} catch (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tasync move(\n\t\tsource: URI,\n\t\ttarget: URI,\n\t\toverwrite?: boolean,\n\t): Promise<IFileStatWithMetadata> {\n\t\tconst sourceProvider = this.throwIfFileSystemIsReadonly(\n\t\t\tawait this.withWriteProvider(source),\n\t\t\tsource,\n\t\t);\n\t\tconst targetProvider = this.throwIfFileSystemIsReadonly(\n\t\t\tawait this.withWriteProvider(target),\n\t\t\ttarget,\n\t\t);\n\n\t\t// move\n\t\tconst mode = await this.doMoveCopy(\n\t\t\tsourceProvider,\n\t\t\tsource,\n\t\t\ttargetProvider,\n\t\t\ttarget,\n\t\t\t\"move\",\n\t\t\t!!overwrite,\n\t\t);\n\n\t\t// resolve and send events\n\t\tconst fileStat = await this.resolve(target, { resolveMetadata: true });\n\t\tthis._onDidRunOperation.fire(\n\t\t\tnew FileOperationEvent(\n\t\t\t\tsource,\n\t\t\t\tmode === \"move\" ? FileOperation.MOVE : FileOperation.COPY,\n\t\t\t\tfileStat,\n\t\t\t),\n\t\t);\n\n\t\treturn fileStat;\n\t}\n\n\tasync copy(\n\t\tsource: URI,\n\t\ttarget: URI,\n\t\toverwrite?: boolean,\n\t): Promise<IFileStatWithMetadata> {\n\t\tconst sourceProvider = await this.withReadProvider(source);\n\t\tconst targetProvider = this.throwIfFileSystemIsReadonly(\n\t\t\tawait this.withWriteProvider(target),\n\t\t\ttarget,\n\t\t);\n\n\t\t// copy\n\t\tconst mode = await this.doMoveCopy(\n\t\t\tsourceProvider,\n\t\t\tsource,\n\t\t\ttargetProvider,\n\t\t\ttarget,\n\t\t\t\"copy\",\n\t\t\t!!overwrite,\n\t\t);\n\n\t\t// resolve and send events\n\t\tconst fileStat = await this.resolve(target, { resolveMetadata: true });\n\t\tthis._onDidRunOperation.fire(\n\t\t\tnew FileOperationEvent(\n\t\t\t\tsource,\n\t\t\t\tmode === \"copy\" ? FileOperation.COPY : FileOperation.MOVE,\n\t\t\t\tfileStat,\n\t\t\t),\n\t\t);\n\n\t\treturn fileStat;\n\t}\n\n\tprivate async doMoveCopy(\n\t\tsourceProvider: IFileSystemProvider,\n\t\tsource: URI,\n\t\ttargetProvider: IFileSystemProvider,\n\t\ttarget: URI,\n\t\tmode: \"move\" | \"copy\",\n\t\toverwrite: boolean,\n\t): Promise<\"move\" | \"copy\"> {\n\t\tif (source.toString() === target.toString()) {\n\t\t\treturn mode; // simulate node.js behaviour here and do a no-op if paths match\n\t\t}\n\n\t\t// validation\n\t\tconst { exists, isSameResourceWithDifferentPathCase } =\n\t\t\tawait this.doValidateMoveCopy(\n\t\t\t\tsourceProvider,\n\t\t\t\tsource,\n\t\t\t\ttargetProvider,\n\t\t\t\ttarget,\n\t\t\t\tmode,\n\t\t\t\toverwrite,\n\t\t\t);\n\n\t\t// delete as needed (unless target is same resurce with different path case)\n\t\tif (exists && !isSameResourceWithDifferentPathCase && overwrite) {\n\t\t\tawait this.del(target, { recursive: true });\n\t\t}\n\n\t\t// create parent folders\n\t\tawait this.mkdirp(\n\t\t\ttargetProvider,\n\t\t\tthis.getExtUri(targetProvider).providerExtUri.dirname(target),\n\t\t);\n\n\t\t// copy source => target\n\t\tif (mode === \"copy\") {\n\t\t\t// same provider with fast copy: leverage copy() functionality\n\t\t\tif (\n\t\t\t\tsourceProvider === targetProvider &&\n\t\t\t\thasFileFolderCopyCapability(sourceProvider)\n\t\t\t) {\n\t\t\t\tawait sourceProvider.copy(source, target, { overwrite });\n\t\t\t}\n\n\t\t\t// when copying via buffer/unbuffered, we have to manually\n\t\t\t// traverse the source if it is a folder and not a file\n\t\t\telse {\n\t\t\t\tconst sourceFile = await this.resolve(source);\n\t\t\t\tif (sourceFile.isDirectory) {\n\t\t\t\t\tawait this.doCopyFolder(\n\t\t\t\t\t\tsourceProvider,\n\t\t\t\t\t\tsourceFile,\n\t\t\t\t\t\ttargetProvider,\n\t\t\t\t\t\ttarget,\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tawait this.doCopyFile(\n\t\t\t\t\t\tsourceProvider,\n\t\t\t\t\t\tsource,\n\t\t\t\t\t\ttargetProvider,\n\t\t\t\t\t\ttarget,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn mode;\n\t\t}\n\n\t\t// move source => target\n\t\telse {\n\t\t\t// same provider: leverage rename() functionality\n\t\t\tif (sourceProvider === targetProvider) {\n\t\t\t\tawait sourceProvider.rename(source, target, { overwrite });\n\n\t\t\t\treturn mode;\n\t\t\t}\n\n\t\t\t// across providers: copy to target & delete at source\n\t\t\telse {\n\t\t\t\tawait this.doMoveCopy(\n\t\t\t\t\tsourceProvider,\n\t\t\t\t\tsource,\n\t\t\t\t\ttargetProvider,\n\t\t\t\t\ttarget,\n\t\t\t\t\t\"copy\",\n\t\t\t\t\toverwrite,\n\t\t\t\t);\n\t\t\t\tawait this.del(source, { recursive: true });\n\n\t\t\t\treturn \"copy\";\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async doCopyFile(\n\t\tsourceProvider: IFileSystemProvider,\n\t\tsource: URI,\n\t\ttargetProvider: IFileSystemProvider,\n\t\ttarget: URI,\n\t): Promise<void> {\n\t\t// copy: source (buffered) => target (buffered)\n\t\tif (\n\t\t\thasOpenReadWriteCloseCapability(sourceProvider) &&\n\t\t\thasOpenReadWriteCloseCapability(targetProvider)\n\t\t) {\n\t\t\treturn this.doPipeBuffered(\n\t\t\t\tsourceProvider,\n\t\t\t\tsource,\n\t\t\t\ttargetProvider,\n\t\t\t\ttarget,\n\t\t\t);\n\t\t}\n\n\t\t// copy: source (buffered) => target (unbuffered)\n\t\tif (\n\t\t\thasOpenReadWriteCloseCapability(sourceProvider) &&\n\t\t\thasReadWriteCapability(targetProvider)\n\t\t) {\n\t\t\treturn this.doPipeBufferedToUnbuffered(\n\t\t\t\tsourceProvider,\n\t\t\t\tsource,\n\t\t\t\ttargetProvider,\n\t\t\t\ttarget,\n\t\t\t);\n\t\t}\n\n\t\t// copy: source (unbuffered) => target (buffered)\n\t\tif (\n\t\t\thasReadWriteCapability(sourceProvider) &&\n\t\t\thasOpenReadWriteCloseCapability(targetProvider)\n\t\t) {\n\t\t\treturn this.doPipeUnbufferedToBuffered(\n\t\t\t\tsourceProvider,\n\t\t\t\tsource,\n\t\t\t\ttargetProvider,\n\t\t\t\ttarget,\n\t\t\t);\n\t\t}\n\n\t\t// copy: source (unbuffered) => target (unbuffered)\n\t\tif (\n\t\t\thasReadWriteCapability(sourceProvider) &&\n\t\t\thasReadWriteCapability(targetProvider)\n\t\t) {\n\t\t\treturn this.doPipeUnbuffered(\n\t\t\t\tsourceProvider,\n\t\t\t\tsource,\n\t\t\t\ttargetProvider,\n\t\t\t\ttarget,\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate async doCopyFolder(\n\t\tsourceProvider: IFileSystemProvider,\n\t\tsourceFolder: IFileStat,\n\t\ttargetProvider: IFileSystemProvider,\n\t\ttargetFolder: URI,\n\t): Promise<void> {\n\t\t// create folder in target\n\t\tawait targetProvider.mkdir(targetFolder);\n\n\t\t// create children in target\n\t\tif (Array.isArray(sourceFolder.children)) {\n\t\t\tawait Promises.settled(\n\t\t\t\tsourceFolder.children.map(async (sourceChild) => {\n\t\t\t\t\tconst targetChild = this.getExtUri(\n\t\t\t\t\t\ttargetProvider,\n\t\t\t\t\t).providerExtUri.joinPath(targetFolder, sourceChild.name);\n\t\t\t\t\tif (sourceChild.isDirectory) {\n\t\t\t\t\t\treturn this.doCopyFolder(\n\t\t\t\t\t\t\tsourceProvider,\n\t\t\t\t\t\t\tawait this.resolve(sourceChild.resource),\n\t\t\t\t\t\t\ttargetProvider,\n\t\t\t\t\t\t\ttargetChild,\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn this.doCopyFile(\n\t\t\t\t\t\t\tsourceProvider,\n\t\t\t\t\t\t\tsourceChild.resource,\n\t\t\t\t\t\t\ttargetProvider,\n\t\t\t\t\t\t\ttargetChild,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate async doValidateMoveCopy(\n\t\tsourceProvider: IFileSystemProvider,\n\t\tsource: URI,\n\t\ttargetProvider: IFileSystemProvider,\n\t\ttarget: URI,\n\t\tmode: \"move\" | \"copy\",\n\t\toverwrite?: boolean,\n\t): Promise<{\n\t\texists: boolean;\n\t\tisSameResourceWithDifferentPathCase: boolean;\n\t}> {\n\t\tlet isSameResourceWithDifferentPathCase = false;\n\n\t\t// Check if source is equal or parent to target (requires providers to be the same)\n\t\tif (sourceProvider === targetProvider) {\n\t\t\tconst { providerExtUri, isPathCaseSensitive } =\n\t\t\t\tthis.getExtUri(sourceProvider);\n\t\t\tif (!isPathCaseSensitive) {\n\t\t\t\tisSameResourceWithDifferentPathCase = providerExtUri.isEqual(\n\t\t\t\t\tsource,\n\t\t\t\t\ttarget,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (isSameResourceWithDifferentPathCase && mode === \"copy\") {\n\t\t\t\tthrow new Error(\n\t\t\t\t\tlocalize(\n\t\t\t\t\t\t\"unableToMoveCopyError1\",\n\t\t\t\t\t\t\"Unable to copy when source '{0}' is same as target '{1}' with different path case on a case insensitive file system\",\n\t\t\t\t\t\tthis.resourceForError(source),\n\t\t\t\t\t\tthis.resourceForError(target),\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t!isSameResourceWithDifferentPathCase &&\n\t\t\t\tproviderExtUri.isEqualOrParent(target, source)\n\t\t\t) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\tlocalize(\n\t\t\t\t\t\t\"unableToMoveCopyError2\",\n\t\t\t\t\t\t\"Unable to move/copy when source '{0}' is parent of target '{1}'.\",\n\t\t\t\t\t\tthis.resourceForError(source),\n\t\t\t\t\t\tthis.resourceForError(target),\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Extra checks if target exists and this is not a rename\n\t\tconst exists = await this.exists(target);\n\t\tif (exists && !isSameResourceWithDifferentPathCase) {\n\t\t\t// Bail out if target exists and we are not about to overwrite\n\t\t\tif (!overwrite) {\n\t\t\t\tthrow new FileOperationError(\n\t\t\t\t\tlocalize(\n\t\t\t\t\t\t\"unableToMoveCopyError3\",\n\t\t\t\t\t\t\"Unable to move/copy '{0}' because target '{1}' already exists at destination.\",\n\t\t\t\t\t\tthis.resourceForError(source),\n\t\t\t\t\t\tthis.resourceForError(target),\n\t\t\t\t\t),\n\t\t\t\t\tFileOperationResult.FILE_MOVE_CONFLICT,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Special case: if the target is a parent of the source, we cannot delete\n\t\t\t// it as it would delete the source as well. In this case we have to throw\n\t\t\tif (sourceProvider === targetProvider) {\n\t\t\t\tconst { providerExtUri } = this.getExtUri(sourceProvider);\n\t\t\t\tif (providerExtUri.isEqualOrParent(source, target)) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\tlocalize(\n\t\t\t\t\t\t\t\"unableToMoveCopyError4\",\n\t\t\t\t\t\t\t\"Unable to move/copy '{0}' into '{1}' since a file would replace the folder it is contained in.\",\n\t\t\t\t\t\t\tthis.resourceForError(source),\n\t\t\t\t\t\t\tthis.resourceForError(target),\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn { exists, isSameResourceWithDifferentPathCase };\n\t}\n\n\tprivate getExtUri(provider: IFileSystemProvider): {\n\t\tproviderExtUri: IExtUri;\n\t\tisPathCaseSensitive: boolean;\n\t} {\n\t\tconst isPathCaseSensitive = this.isPathCaseSensitive(provider);\n\n\t\treturn {\n\t\t\tproviderExtUri: isPathCaseSensitive ? extUri : extUriIgnorePathCase,\n\t\t\tisPathCaseSensitive,\n\t\t};\n\t}\n\n\tprivate isPathCaseSensitive(provider: IFileSystemProvider): boolean {\n\t\treturn !!(\n\t\t\tprovider.capabilities &\n\t\t\tFileSystemProviderCapabilities.PathCaseSensitive\n\t\t);\n\t}\n\n\tasync createFolder(resource: URI): Promise<IFileStatWithMetadata> {\n\t\tconst provider = this.throwIfFileSystemIsReadonly(\n\t\t\tawait this.withProvider(resource),\n\t\t\tresource,\n\t\t);\n\n\t\t// mkdir recursively\n\t\tawait this.mkdirp(provider, resource);\n\n\t\t// events\n\t\tconst fileStat = await this.resolve(resource, {\n\t\t\tresolveMetadata: true,\n\t\t});\n\t\tthis._onDidRunOperation.fire(\n\t\t\tnew FileOperationEvent(resource, FileOperation.CREATE, fileStat),\n\t\t);\n\n\t\treturn fileStat;\n\t}\n\n\tprivate async mkdirp(\n\t\tprovider: IFileSystemProvider,\n\t\tdirectory: URI,\n\t): Promise<void> {\n\t\tconst directoriesToCreate: string[] = [];\n\n\t\t// mkdir until we reach root\n\t\tconst { providerExtUri } = this.getExtUri(provider);\n\t\twhile (\n\t\t\t!providerExtUri.isEqual(\n\t\t\t\tdirectory,\n\t\t\t\tproviderExtUri.dirname(directory),\n\t\t\t)\n\t\t) {\n\t\t\ttry {\n\t\t\t\tconst stat = await provider.stat(directory);\n\t\t\t\tif ((stat.type & FileType.Directory) === 0) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\tlocalize(\n\t\t\t\t\t\t\t\"mkdirExistsError\",\n\t\t\t\t\t\t\t\"Unable to create folder '{0}' that already exists but is not a directory\",\n\t\t\t\t\t\t\tthis.resourceForError(directory),\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tbreak; // we have hit a directory that exists -> good\n\t\t\t} catch (error) {\n\t\t\t\t// Bubble up any other error that is not file not found\n\t\t\t\tif (\n\t\t\t\t\ttoFileSystemProviderErrorCode(error) !==\n\t\t\t\t\tFileSystemProviderErrorCode.FileNotFound\n\t\t\t\t) {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\n\t\t\t\t// Upon error, remember directories that need to be created\n\t\t\t\tdirectoriesToCreate.push(providerExtUri.basename(directory));\n\n\t\t\t\t// Continue up\n\t\t\t\tdirectory = providerExtUri.dirname(directory);\n\t\t\t}\n\t\t}\n\n\t\t// Create directories as needed\n\t\tfor (let i = directoriesToCreate.length - 1; i >= 0; i--) {\n\t\t\tdirectory = providerExtUri.joinPath(\n\t\t\t\tdirectory,\n\t\t\t\tdirectoriesToCreate[i],\n\t\t\t);\n\n\t\t\ttry {\n\t\t\t\tawait provider.mkdir(directory);\n\t\t\t} catch (error) {\n\t\t\t\tif (\n\t\t\t\t\ttoFileSystemProviderErrorCode(error) !==\n\t\t\t\t\tFileSystemProviderErrorCode.FileExists\n\t\t\t\t) {\n\t\t\t\t\t// For mkdirp() we tolerate that the mkdir() call fails\n\t\t\t\t\t// in case the folder already exists. This follows node.js\n\t\t\t\t\t// own implementation of fs.mkdir({ recursive: true }) and\n\t\t\t\t\t// reduces the chances of race conditions leading to errors\n\t\t\t\t\t// if multiple calls try to create the same folders\n\t\t\t\t\t// As such, we only throw an error here if it is other than\n\t\t\t\t\t// the fact that the file already exists.\n\t\t\t\t\t// (see also https://github.com/microsoft/vscode/issues/89834)\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tasync canDelete(\n\t\tresource: URI,\n\t\toptions?: Partial<IFileDeleteOptions>,\n\t): Promise<Error | true> {\n\t\ttry {\n\t\t\tawait this.doValidateDelete(resource, options);\n\t\t} catch (error) {\n\t\t\treturn error;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate async doValidateDelete(\n\t\tresource: URI,\n\t\toptions?: Partial<IFileDeleteOptions>,\n\t): Promise<IFileSystemProvider> {\n\t\tconst provider = this.throwIfFileSystemIsReadonly(\n\t\t\tawait this.withProvider(resource),\n\t\t\tresource,\n\t\t);\n\n\t\t// Validate trash support\n\t\tconst useTrash = !!options?.useTrash;\n\t\tif (\n\t\t\tuseTrash &&\n\t\t\t!(provider.capabilities & FileSystemProviderCapabilities.Trash)\n\t\t) {\n\t\t\tthrow new Error(\n\t\t\t\tlocalize(\n\t\t\t\t\t\"deleteFailedTrashUnsupported\",\n\t\t\t\t\t\"Unable to delete file '{0}' via trash because provider does not support it.\",\n\t\t\t\t\tthis.resourceForError(resource),\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\n\t\t// Validate atomic support\n\t\tconst atomic = options?.atomic;\n\t\tif (\n\t\t\tatomic &&\n\t\t\t!(\n\t\t\t\tprovider.capabilities &\n\t\t\t\tFileSystemProviderCapabilities.FileAtomicDelete\n\t\t\t)\n\t\t) {\n\t\t\tthrow new Error(\n\t\t\t\tlocalize(\n\t\t\t\t\t\"deleteFailedAtomicUnsupported\",\n\t\t\t\t\t\"Unable to delete file '{0}' atomically because provider does not support it.\",\n\t\t\t\t\tthis.resourceForError(resource),\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\n\t\tif (useTrash && atomic) {\n\t\t\tthrow new Error(\n\t\t\t\tlocalize(\n\t\t\t\t\t\"deleteFailedTrashAndAtomicUnsupported\",\n\t\t\t\t\t\"Unable to atomically delete file '{0}' because using trash is enabled.\",\n\t\t\t\t\tthis.resourceForError(resource),\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\n\t\t// Validate delete\n\t\tlet stat: IStat | undefined;\n\t\ttry {\n\t\t\tstat = await provider.stat(resource);\n\t\t} catch (error) {\n\t\t\t// Handled later\n\t\t}\n\n\t\tif (stat) {\n\t\t\tthis.throwIfFileIsReadonly(resource, stat);\n\t\t} else {\n\t\t\tthrow new FileOperationError(\n\t\t\t\tlocalize(\n\t\t\t\t\t\"deleteFailedNotFound\",\n\t\t\t\t\t\"Unable to delete nonexistent file '{0}'\",\n\t\t\t\t\tthis.resourceForError(resource),\n\t\t\t\t),\n\t\t\t\tFileOperationResult.FILE_NOT_FOUND,\n\t\t\t);\n\t\t}\n\n\t\t// Validate recursive\n\t\tconst recursive = !!options?.recursive;\n\t\tif (!recursive) {\n\t\t\tconst stat = await this.resolve(resource);\n\t\t\tif (\n\t\t\t\tstat.isDirectory &&\n\t\t\t\tArray.isArray(stat.children) &&\n\t\t\t\tstat.children.length > 0\n\t\t\t) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\tlocalize(\n\t\t\t\t\t\t\"deleteFailedNonEmptyFolder\",\n\t\t\t\t\t\t\"Unable to delete non-empty folder '{0}'.\",\n\t\t\t\t\t\tthis.resourceForError(resource),\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn provider;\n\t}\n\n\tasync del(\n\t\tresource: URI,\n\t\toptions?: Partial<IFileDeleteOptions>,\n\t): Promise<void> {\n\t\tconst provider = await this.doValidateDelete(resource, options);\n\n\t\tlet deleteFileOptions = options;\n\t\tif (\n\t\t\thasFileAtomicDeleteCapability(provider) &&\n\t\t\t!deleteFileOptions?.atomic\n\t\t) {\n\t\t\tconst enforcedAtomicDelete =\n\t\t\t\tprovider.enforceAtomicDelete?.(resource);\n\t\t\tif (enforcedAtomicDelete) {\n\t\t\t\tdeleteFileOptions = {\n\t\t\t\t\t...options,\n\t\t\t\t\tatomic: enforcedAtomicDelete,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tconst useTrash = !!deleteFileOptions?.useTrash;\n\t\tconst recursive = !!deleteFileOptions?.recursive;\n\t\tconst atomic = deleteFileOptions?.atomic ?? false;\n\n\t\t// Delete through provider\n\t\tawait provider.delete(resource, { recursive, useTrash, atomic });\n\n\t\t// Events\n\t\tthis._onDidRunOperation.fire(\n\t\t\tnew FileOperationEvent(resource, FileOperation.DELETE),\n\t\t);\n\t}\n\n\t//#endregion\n\n\t//#region Clone File\n\n\tasync cloneFile(source: URI, target: URI): Promise<void> {\n\t\tconst sourceProvider = await this.withProvider(source);\n\t\tconst targetProvider = this.throwIfFileSystemIsReadonly(\n\t\t\tawait this.withWriteProvider(target),\n\t\t\ttarget,\n\t\t);\n\n\t\tif (\n\t\t\tsourceProvider === targetProvider &&\n\t\t\tthis.getExtUri(sourceProvider).providerExtUri.isEqual(\n\t\t\t\tsource,\n\t\t\t\ttarget,\n\t\t\t)\n\t\t) {\n\t\t\treturn; // return early if paths are equal\n\t\t}\n\n\t\t// same provider, use `cloneFile` when native support is provided\n\t\tif (\n\t\t\tsourceProvider === targetProvider &&\n\t\t\thasFileCloneCapability(sourceProvider)\n\t\t) {\n\t\t\treturn sourceProvider.cloneFile(source, target);\n\t\t}\n\n\t\t// otherwise, either providers are different or there is no native\n\t\t// `cloneFile` support, then we fallback to emulate a clone as best\n\t\t// as we can with the other primitives\n\n\t\t// create parent folders\n\t\tawait this.mkdirp(\n\t\t\ttargetProvider,\n\t\t\tthis.getExtUri(targetProvider).providerExtUri.dirname(target),\n\t\t);\n\n\t\t// leverage `copy` method if provided and providers are identical\n\t\t// queue on the source to ensure atomic read\n\t\tif (\n\t\t\tsourceProvider === targetProvider &&\n\t\t\thasFileFolderCopyCapability(sourceProvider)\n\t\t) {\n\t\t\treturn this.writeQueue.queueFor(\n\t\t\t\tsource,\n\t\t\t\t() => sourceProvider.copy(source, target, { overwrite: true }),\n\t\t\t\tthis.getExtUri(sourceProvider).providerExtUri,\n\t\t\t);\n\t\t}\n\n\t\t// otherwise copy via buffer/unbuffered and use a write queue\n\t\t// on the source to ensure atomic operation as much as possible\n\t\treturn this.writeQueue.queueFor(\n\t\t\tsource,\n\t\t\t() =>\n\t\t\t\tthis.doCopyFile(sourceProvider, source, targetProvider, target),\n\t\t\tthis.getExtUri(sourceProvider).providerExtUri,\n\t\t);\n\t}\n\n\t//#endregion\n\n\t//#region File Watching\n\n\tprivate readonly internalOnDidFilesChange = this._register(\n\t\tnew Emitter<FileChangesEvent>(),\n\t);\n\n\tprivate readonly _onDidUncorrelatedFilesChange = this._register(\n\t\tnew Emitter<FileChangesEvent>(),\n\t);\n\treadonly onDidFilesChange = this._onDidUncorrelatedFilesChange.event; // global `onDidFilesChange` skips correlated events\n\n\tprivate readonly _onDidWatchError = this._register(new Emitter<Error>());\n\treadonly onDidWatchError = this._onDidWatchError.event;\n\n\tprivate readonly activeWatchers = new Map<\n\t\tnumber /* watch request hash */,\n\t\t{ disposable: IDisposable; count: number }\n\t>();\n\n\tprivate static WATCHER_CORRELATION_IDS = 0;\n\n\tcreateWatcher(\n\t\tresource: URI,\n\t\toptions: IWatchOptionsWithoutCorrelation,\n\t): IFileSystemWatcher {\n\t\treturn this.watch(resource, {\n\t\t\t...options,\n\t\t\t// Explicitly set a correlation id so that file events that originate\n\t\t\t// from requests from extensions are exclusively routed back to the\n\t\t\t// extension host and not into the workbench.\n\t\t\tcorrelationId: FileService.WATCHER_CORRELATION_IDS++,\n\t\t});\n\t}\n\n\twatch(\n\t\tresource: URI,\n\t\toptions: IWatchOptionsWithCorrelation,\n\t): IFileSystemWatcher;\n\twatch(\n\t\tresource: URI,\n\t\toptions?: IWatchOptionsWithoutCorrelation,\n\t): IDisposable;\n\twatch(\n\t\tresource: URI,\n\t\toptions: IWatchOptions = { recursive: false, excludes: [] },\n\t): IFileSystemWatcher | IDisposable {\n\t\tconst disposables = new DisposableStore();\n\n\t\t// Forward watch request to provider and wire in disposables\n\t\tlet watchDisposed = false;\n\t\tlet disposeWatch = () => {\n\t\t\twatchDisposed = true;\n\t\t};\n\t\tdisposables.add(toDisposable(() => disposeWatch()));\n\n\t\t// Watch and wire in disposable which is async but\n\t\t// check if we got disposed meanwhile and forward\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tconst disposable = await this.doWatch(resource, options);\n\t\t\t\tif (watchDisposed) {\n\t\t\t\t\tdispose(disposable);\n\t\t\t\t} else {\n\t\t\t\t\tdisposeWatch = () => dispose(disposable);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.error(error);\n\t\t\t}\n\t\t})();\n\n\t\t// When a correlation identifier is set, return a specific\n\t\t// watcher that only emits events matching that correalation.\n\t\tconst correlationId = options.correlationId;\n\t\tif (typeof correlationId === \"number\") {\n\t\t\tconst fileChangeEmitter = disposables.add(\n\t\t\t\tnew Emitter<FileChangesEvent>(),\n\t\t\t);\n\t\t\tdisposables.add(\n\t\t\t\tthis.internalOnDidFilesChange.event((e) => {\n\t\t\t\t\tif (e.correlates(correlationId)) {\n\t\t\t\t\t\tfileChangeEmitter.fire(e);\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\tconst watcher: IFileSystemWatcher = {\n\t\t\t\tonDidChange: fileChangeEmitter.event,\n\t\t\t\tdispose: () => disposables.dispose(),\n\t\t\t};\n\n\t\t\treturn watcher;\n\t\t}\n\n\t\treturn disposables;\n\t}\n\n\tprivate async doWatch(\n\t\tresource: URI,\n\t\toptions: IWatchOptions,\n\t): Promise<IDisposable> {\n\t\tconst provider = await this.withProvider(resource);\n\n\t\t// Deduplicate identical watch requests\n\t\tconst watchHash = hash([\n\t\t\tthis.getExtUri(provider).providerExtUri.getComparisonKey(resource),\n\t\t\toptions,\n\t\t]);\n\t\tlet watcher = this.activeWatchers.get(watchHash);\n\t\tif (!watcher) {\n\t\t\twatcher = {\n\t\t\t\tcount: 0,\n\t\t\t\tdisposable: provider.watch(resource, options),\n\t\t\t};\n\n\t\t\tthis.activeWatchers.set(watchHash, watcher);\n\t\t}\n\n\t\t// Increment usage counter\n\t\twatcher.count += 1;\n\n\t\treturn toDisposable(() => {\n\t\t\tif (watcher) {\n\t\t\t\t// Unref\n\t\t\t\twatcher.count--;\n\n\t\t\t\t// Dispose only when last user is reached\n\t\t\t\tif (watcher.count === 0) {\n\t\t\t\t\tdispose(watcher.disposable);\n\t\t\t\t\tthis.activeWatchers.delete(watchHash);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\tfor (const [, watcher] of this.activeWatchers) {\n\t\t\tdispose(watcher.disposable);\n\t\t}\n\n\t\tthis.activeWatchers.clear();\n\t}\n\n\t//#endregion\n\n\t//#region Helpers\n\n\tprivate readonly writeQueue = this._register(new ResourceQueue());\n\n\tprivate async doWriteBuffered(\n\t\tprovider: IFileSystemProviderWithOpenReadWriteCloseCapability,\n\t\tresource: URI,\n\t\toptions: IWriteFileOptions | undefined,\n\t\treadableOrStreamOrBufferedStream:\n\t\t\t| VSBufferReadable\n\t\t\t| VSBufferReadableStream\n\t\t\t| VSBufferReadableBufferedStream,\n\t): Promise<void> {\n\t\treturn this.writeQueue.queueFor(\n\t\t\tresource,\n\t\t\tasync () => {\n\t\t\t\t// open handle\n\t\t\t\tconst handle = await provider.open(resource, {\n\t\t\t\t\tcreate: true,\n\t\t\t\t\tunlock: options?.unlock ?? false,\n\t\t\t\t});\n\n\t\t\t\t// write into handle until all bytes from buffer have been written\n\t\t\t\ttry {\n\t\t\t\t\tif (\n\t\t\t\t\t\tisReadableStream(readableOrStreamOrBufferedStream) ||\n\t\t\t\t\t\tisReadableBufferedStream(\n\t\t\t\t\t\t\treadableOrStreamOrBufferedStream,\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tawait this.doWriteStreamBufferedQueued(\n\t\t\t\t\t\t\tprovider,\n\t\t\t\t\t\t\thandle,\n\t\t\t\t\t\t\treadableOrStreamOrBufferedStream,\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tawait this.doWriteReadableBufferedQueued(\n\t\t\t\t\t\t\tprovider,\n\t\t\t\t\t\t\thandle,\n\t\t\t\t\t\t\treadableOrStreamOrBufferedStream,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthrow ensureFileSystemProviderError(error);\n\t\t\t\t} finally {\n\t\t\t\t\t// close handle always\n\t\t\t\t\tawait provider.close(handle);\n\t\t\t\t}\n\t\t\t},\n\t\t\tthis.getExtUri(provider).providerExtUri,\n\t\t);\n\t}\n\n\tprivate async doWriteStreamBufferedQueued(\n\t\tprovider: IFileSystemProviderWithOpenReadWriteCloseCapability,\n\t\thandle: number,\n\t\tstreamOrBufferedStream:\n\t\t\t| VSBufferReadableStream\n\t\t\t| VSBufferReadableBufferedStream,\n\t): Promise<void> {\n\t\tlet posInFile = 0;\n\t\tlet stream: VSBufferReadableStream;\n\n\t\t// Buffered stream: consume the buffer first by writing\n\t\t// it to the target before reading from the stream.\n\t\tif (isReadableBufferedStream(streamOrBufferedStream)) {\n\t\t\tif (streamOrBufferedStream.buffer.length > 0) {\n\t\t\t\tconst chunk = VSBuffer.concat(streamOrBufferedStream.buffer);\n\t\t\t\tawait this.doWriteBuffer(\n\t\t\t\t\tprovider,\n\t\t\t\t\thandle,\n\t\t\t\t\tchunk,\n\t\t\t\t\tchunk.byteLength,\n\t\t\t\t\tposInFile,\n\t\t\t\t\t0,\n\t\t\t\t);\n\n\t\t\t\tposInFile += chunk.byteLength;\n\t\t\t}\n\n\t\t\t// If the stream has been consumed, return early\n\t\t\tif (streamOrBufferedStream.ended) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tstream = streamOrBufferedStream.stream;\n\t\t}\n\n\t\t// Unbuffered stream - just take as is\n\t\telse {\n\t\t\tstream = streamOrBufferedStream;\n\t\t}\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tlistenStream(stream, {\n\t\t\t\tonData: async (chunk) => {\n\t\t\t\t\t// pause stream to perform async write operation\n\t\t\t\t\tstream.pause();\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait this.doWriteBuffer(\n\t\t\t\t\t\t\tprovider,\n\t\t\t\t\t\t\thandle,\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tchunk.byteLength,\n\t\t\t\t\t\t\tposInFile,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\treturn reject(error);\n\t\t\t\t\t}\n\n\t\t\t\t\tposInFile += chunk.byteLength;\n\n\t\t\t\t\t// resume stream now that we have successfully written\n\t\t\t\t\t// run this on the next tick to prevent increasing the\n\t\t\t\t\t// execution stack because resume() may call the event\n\t\t\t\t\t// handler again before finishing.\n\t\t\t\t\tsetTimeout(() => stream.resume());\n\t\t\t\t},\n\t\t\t\tonError: (error) => reject(error),\n\t\t\t\tonEnd: () => resolve(),\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate async doWriteReadableBufferedQueued(\n\t\tprovider: IFileSystemProviderWithOpenReadWriteCloseCapability,\n\t\thandle: number,\n\t\treadable: VSBufferReadable,\n\t): Promise<void> {\n\t\tlet posInFile = 0;\n\n\t\tlet chunk: VSBuffer | null;\n\t\twhile ((chunk = readable.read()) !== null) {\n\t\t\tawait this.doWriteBuffer(\n\t\t\t\tprovider,\n\t\t\t\thandle,\n\t\t\t\tchunk,\n\t\t\t\tchunk.byteLength,\n\t\t\t\tposInFile,\n\t\t\t\t0,\n\t\t\t);\n\n\t\t\tposInFile += chunk.byteLength;\n\t\t}\n\t}\n\n\tprivate async doWriteBuffer(\n\t\tprovider: IFileSystemProviderWithOpenReadWriteCloseCapability,\n\t\thandle: number,\n\t\tbuffer: VSBuffer,\n\t\tlength: number,\n\t\tposInFile: number,\n\t\tposInBuffer: number,\n\t): Promise<void> {\n\t\tlet totalBytesWritten = 0;\n\t\twhile (totalBytesWritten < length) {\n\t\t\t// Write through the provider\n\t\t\tconst bytesWritten = await provider.write(\n\t\t\t\thandle,\n\t\t\t\tposInFile + totalBytesWritten,\n\t\t\t\tbuffer.buffer,\n\t\t\t\tposInBuffer + totalBytesWritten,\n\t\t\t\tlength - totalBytesWritten,\n\t\t\t);\n\t\t\ttotalBytesWritten += bytesWritten;\n\t\t}\n\t}\n\n\tprivate async doWriteUnbuffered(\n\t\tprovider: IFileSystemProviderWithFileReadWriteCapability,\n\t\tresource: URI,\n\t\toptions: IWriteFileOptions | undefined,\n\t\tbufferOrReadableOrStreamOrBufferedStream:\n\t\t\t| VSBuffer\n\t\t\t| VSBufferReadable\n\t\t\t| VSBufferReadableStream\n\t\t\t| VSBufferReadableBufferedStream,\n\t): Promise<void> {\n\t\treturn this.writeQueue.queueFor(\n\t\t\tresource,\n\t\t\t() =>\n\t\t\t\tthis.doWriteUnbufferedQueued(\n\t\t\t\t\tprovider,\n\t\t\t\t\tresource,\n\t\t\t\t\toptions,\n\t\t\t\t\tbufferOrReadableOrStreamOrBufferedStream,\n\t\t\t\t),\n\t\t\tthis.getExtUri(provider).providerExtUri,\n\t\t);\n\t}\n\n\tprivate async doWriteUnbufferedQueued(\n\t\tprovider: IFileSystemProviderWithFileReadWriteCapability,\n\t\tresource: URI,\n\t\toptions: IWriteFileOptions | undefined,\n\t\tbufferOrReadableOrStreamOrBufferedStream:\n\t\t\t| VSBuffer\n\t\t\t| VSBufferReadable\n\t\t\t| VSBufferReadableStream\n\t\t\t| VSBufferReadableBufferedStream,\n\t): Promise<void> {\n\t\tlet buffer: VSBuffer;\n\t\tif (bufferOrReadableOrStreamOrBufferedStream instanceof VSBuffer) {\n\t\t\tbuffer = bufferOrReadableOrStreamOrBufferedStream;\n\t\t} else if (isReadableStream(bufferOrReadableOrStreamOrBufferedStream)) {\n\t\t\tbuffer = await streamToBuffer(\n\t\t\t\tbufferOrReadableOrStreamOrBufferedStream,\n\t\t\t);\n\t\t} else if (\n\t\t\tisReadableBufferedStream(bufferOrReadableOrStreamOrBufferedStream)\n\t\t) {\n\t\t\tbuffer = await bufferedStreamToBuffer(\n\t\t\t\tbufferOrReadableOrStreamOrBufferedStream,\n\t\t\t);\n\t\t} else {\n\t\t\tbuffer = readableToBuffer(bufferOrReadableOrStreamOrBufferedStream);\n\t\t}\n\n\t\t// Write through the provider\n\t\tawait provider.writeFile(resource, buffer.buffer, {\n\t\t\tcreate: true,\n\t\t\toverwrite: true,\n\t\t\tunlock: options?.unlock ?? false,\n\t\t\tatomic: options?.atomic ?? false,\n\t\t});\n\t}\n\n\tprivate async doPipeBuffered(\n\t\tsourceProvider: IFileSystemProviderWithOpenReadWriteCloseCapability,\n\t\tsource: URI,\n\t\ttargetProvider: IFileSystemProviderWithOpenReadWriteCloseCapability,\n\t\ttarget: URI,\n\t): Promise<void> {\n\t\treturn this.writeQueue.queueFor(\n\t\t\ttarget,\n\t\t\t() =>\n\t\t\t\tthis.doPipeBufferedQueued(\n\t\t\t\t\tsourceProvider,\n\t\t\t\t\tsource,\n\t\t\t\t\ttargetProvider,\n\t\t\t\t\ttarget,\n\t\t\t\t),\n\t\t\tthis.getExtUri(targetProvider).providerExtUri,\n\t\t);\n\t}\n\n\tprivate async doPipeBufferedQueued(\n\t\tsourceProvider: IFileSystemProviderWithOpenReadWriteCloseCapability,\n\t\tsource: URI,\n\t\ttargetProvider: IFileSystemProviderWithOpenReadWriteCloseCapability,\n\t\ttarget: URI,\n\t): Promise<void> {\n\t\tlet sourceHandle: number | undefined;\n\t\tlet targetHandle: number | undefined;\n\n\t\ttry {\n\t\t\t// Open handles\n\t\t\tsourceHandle = await sourceProvider.open(source, { create: false });\n\t\t\ttargetHandle = await targetProvider.open(target, {\n\t\t\t\tcreate: true,\n\t\t\t\tunlock: false,\n\t\t\t});\n\n\t\t\tconst buffer = VSBuffer.alloc(this.BUFFER_SIZE);\n\n\t\t\tlet posInFile = 0;\n\t\t\tlet posInBuffer = 0;\n\t\t\tlet bytesRead = 0;\n\t\t\tdo {\n\t\t\t\t// read from source (sourceHandle) at current position (posInFile) into buffer (buffer) at\n\t\t\t\t// buffer position (posInBuffer) up to the size of the buffer (buffer.byteLength).\n\t\t\t\tbytesRead = await sourceProvider.read(\n\t\t\t\t\tsourceHandle,\n\t\t\t\t\tposInFile,\n\t\t\t\t\tbuffer.buffer,\n\t\t\t\t\tposInBuffer,\n\t\t\t\t\tbuffer.byteLength - posInBuffer,\n\t\t\t\t);\n\n\t\t\t\t// write into target (targetHandle) at current position (posInFile) from buffer (buffer) at\n\t\t\t\t// buffer position (posInBuffer) all bytes we read (bytesRead).\n\t\t\t\tawait this.doWriteBuffer(\n\t\t\t\t\ttargetProvider,\n\t\t\t\t\ttargetHandle,\n\t\t\t\t\tbuffer,\n\t\t\t\t\tbytesRead,\n\t\t\t\t\tposInFile,\n\t\t\t\t\tposInBuffer,\n\t\t\t\t);\n\n\t\t\t\tposInFile += bytesRead;\n\t\t\t\tposInBuffer += bytesRead;\n\n\t\t\t\t// when buffer full, fill it again from the beginning\n\t\t\t\tif (posInBuffer === buffer.byteLength) {\n\t\t\t\t\tposInBuffer = 0;\n\t\t\t\t}\n\t\t\t} while (bytesRead > 0);\n\t\t} catch (error) {\n\t\t\tthrow ensureFileSystemProviderError(error);\n\t\t} finally {\n\t\t\tawait Promises.settled([\n\t\t\t\ttypeof sourceHandle === \"number\"\n\t\t\t\t\t? sourceProvider.close(sourceHandle)\n\t\t\t\t\t: Promise.resolve(),\n\t\t\t\ttypeof targetHandle === \"number\"\n\t\t\t\t\t? targetProvider.close(targetHandle)\n\t\t\t\t\t: Promise.resolve(),\n\t\t\t]);\n\t\t}\n\t}\n\n\tprivate async doPipeUnbuffered(\n\t\tsourceProvider: IFileSystemProviderWithFileReadWriteCapability,\n\t\tsource: URI,\n\t\ttargetProvider: IFileSystemProviderWithFileReadWriteCapability,\n\t\ttarget: URI,\n\t): Promise<void> {\n\t\treturn this.writeQueue.queueFor(\n\t\t\ttarget,\n\t\t\t() =>\n\t\t\t\tthis.doPipeUnbufferedQueued(\n\t\t\t\t\tsourceProvider,\n\t\t\t\t\tsource,\n\t\t\t\t\ttargetProvider,\n\t\t\t\t\ttarget,\n\t\t\t\t),\n\t\t\tthis.getExtUri(targetProvider).providerExtUri,\n\t\t);\n\t}\n\n\tprivate async doPipeUnbufferedQueued(\n\t\tsourceProvider: IFileSystemProviderWithFileReadWriteCapability,\n\t\tsource: URI,\n\t\ttargetProvider: IFileSystemProviderWithFileReadWriteCapability,\n\t\ttarget: URI,\n\t): Promise<void> {\n\t\treturn targetProvider.writeFile(\n\t\t\ttarget,\n\t\t\tawait sourceProvider.readFile(source),\n\t\t\t{ create: true, overwrite: true, unlock: false, atomic: false },\n\t\t);\n\t}\n\n\tprivate async doPipeUnbufferedToBuffered(\n\t\tsourceProvider: IFileSystemProviderWithFileReadWriteCapability,\n\t\tsource: URI,\n\t\ttargetProvider: IFileSystemProviderWithOpenReadWriteCloseCapability,\n\t\ttarget: URI,\n\t): Promise<void> {\n\t\treturn this.writeQueue.queueFor(\n\t\t\ttarget,\n\t\t\t() =>\n\t\t\t\tthis.doPipeUnbufferedToBufferedQueued(\n\t\t\t\t\tsourceProvider,\n\t\t\t\t\tsource,\n\t\t\t\t\ttargetProvider,\n\t\t\t\t\ttarget,\n\t\t\t\t),\n\t\t\tthis.getExtUri(targetProvider).providerExtUri,\n\t\t);\n\t}\n\n\tprivate async doPipeUnbufferedToBufferedQueued(\n\t\tsourceProvider: IFileSystemProviderWithFileReadWriteCapability,\n\t\tsource: URI,\n\t\ttargetProvider: IFileSystemProviderWithOpenReadWriteCloseCapability,\n\t\ttarget: URI,\n\t): Promise<void> {\n\t\t// Open handle\n\t\tconst targetHandle = await targetProvider.open(target, {\n\t\t\tcreate: true,\n\t\t\tunlock: false,\n\t\t});\n\n\t\t// Read entire buffer from source and write buffered\n\t\ttry {\n\t\t\tconst buffer = await sourceProvider.readFile(source);\n\t\t\tawait this.doWriteBuffer(\n\t\t\t\ttargetProvider,\n\t\t\t\ttargetHandle,\n\t\t\t\tVSBuffer.wrap(buffer),\n\t\t\t\tbuffer.byteLength,\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tthrow ensureFileSystemProviderError(error);\n\t\t} finally {\n\t\t\tawait targetProvider.close(targetHandle);\n\t\t}\n\t}\n\n\tprivate async doPipeBufferedToUnbuffered(\n\t\tsourceProvider: IFileSystemProviderWithOpenReadWriteCloseCapability,\n\t\tsource: URI,\n\t\ttargetProvider: IFileSystemProviderWithFileReadWriteCapability,\n\t\ttarget: URI,\n\t): Promise<void> {\n\t\t// Read buffer via stream buffered\n\t\tconst buffer = await streamToBuffer(\n\t\t\tthis.readFileBuffered(\n\t\t\t\tsourceProvider,\n\t\t\t\tsource,\n\t\t\t\tCancellationToken.None,\n\t\t\t),\n\t\t);\n\n\t\t// Write buffer into target at once\n\t\tawait this.doWriteUnbuffered(targetProvider, target, undefined, buffer);\n\t}\n\n\tprotected throwIfFileSystemIsReadonly<T extends IFileSystemProvider>(\n\t\tprovider: T,\n\t\tresource: URI,\n\t): T {\n\t\tif (provider.capabilities & FileSystemProviderCapabilities.Readonly) {\n\t\t\tthrow new FileOperationError(\n\t\t\t\tlocalize(\n\t\t\t\t\t\"err.readonly\",\n\t\t\t\t\t\"Unable to modify read-only file '{0}'\",\n\t\t\t\t\tthis.resourceForError(resource),\n\t\t\t\t),\n\t\t\t\tFileOperationResult.FILE_PERMISSION_DENIED,\n\t\t\t);\n\t\t}\n\n\t\treturn provider;\n\t}\n\n\tprivate throwIfFileIsReadonly(resource: URI, stat: IStat): void {\n\t\tif ((stat.permissions ?? 0) & FilePermission.Readonly) {\n\t\t\tthrow new FileOperationError(\n\t\t\t\tlocalize(\n\t\t\t\t\t\"err.readonly\",\n\t\t\t\t\t\"Unable to modify read-only file '{0}'\",\n\t\t\t\t\tthis.resourceForError(resource),\n\t\t\t\t),\n\t\t\t\tFileOperationResult.FILE_PERMISSION_DENIED,\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate resourceForError(resource: URI): string {\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\treturn resource.fsPath;\n\t\t}\n\n\t\treturn resource.toString(true);\n\t}\n\n\t//#endregion\n}\n"],
  "mappings": "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",
  "names": ["stat"]
}
