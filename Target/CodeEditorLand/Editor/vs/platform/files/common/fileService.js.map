{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/files/common/fileService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { coalesce } from '../../../base/common/arrays.js';\nimport { Promises, ResourceQueue } from '../../../base/common/async.js';\nimport { bufferedStreamToBuffer, bufferToReadable, newWriteableBufferStream, readableToBuffer, streamToBuffer, VSBuffer, VSBufferReadable, VSBufferReadableBufferedStream, VSBufferReadableStream } from '../../../base/common/buffer.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { hash } from '../../../base/common/hash.js';\nimport { Iterable } from '../../../base/common/iterator.js';\nimport { Disposable, DisposableStore, dispose, IDisposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { TernarySearchTree } from '../../../base/common/ternarySearchTree.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { mark } from '../../../base/common/performance.js';\nimport { extUri, extUriIgnorePathCase, IExtUri, isAbsolutePath } from '../../../base/common/resources.js';\nimport { consumeStream, isReadableBufferedStream, isReadableStream, listenStream, newWriteableStream, peekReadable, peekStream, transform } from '../../../base/common/stream.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { localize } from '../../../nls.js';\nimport { ensureFileSystemProviderError, etag, ETAG_DISABLED, FileChangesEvent, IFileDeleteOptions, FileOperation, FileOperationError, FileOperationEvent, FileOperationResult, FilePermission, FileSystemProviderCapabilities, FileSystemProviderErrorCode, FileType, hasFileAtomicReadCapability, hasFileFolderCopyCapability, hasFileReadStreamCapability, hasOpenReadWriteCloseCapability, hasReadWriteCapability, ICreateFileOptions, IFileContent, IFileService, IFileStat, IFileStatWithMetadata, IFileStreamContent, IFileSystemProvider, IFileSystemProviderActivationEvent, IFileSystemProviderCapabilitiesChangeEvent, IFileSystemProviderRegistrationEvent, IFileSystemProviderWithFileAtomicReadCapability, IFileSystemProviderWithFileReadStreamCapability, IFileSystemProviderWithFileReadWriteCapability, IFileSystemProviderWithOpenReadWriteCloseCapability, IReadFileOptions, IReadFileStreamOptions, IResolveFileOptions, IFileStatResult, IFileStatResultWithMetadata, IResolveMetadataFileOptions, IStat, IFileStatWithPartialMetadata, IWatchOptions, IWriteFileOptions, NotModifiedSinceFileOperationError, toFileOperationResult, toFileSystemProviderErrorCode, hasFileCloneCapability, TooLargeFileOperationError, hasFileAtomicDeleteCapability, hasFileAtomicWriteCapability, IWatchOptionsWithCorrelation, IFileSystemWatcher, IWatchOptionsWithoutCorrelation } from './files.js';\nimport { readFileIntoStream } from './io.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { ErrorNoTelemetry } from '../../../base/common/errors.js';\n\nexport class FileService extends Disposable implements IFileService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\t// Choose a buffer size that is a balance between memory needs and\n\t// manageable IPC overhead. The larger the buffer size, the less\n\t// roundtrips we have to do for reading/writing data.\n\tprivate readonly BUFFER_SIZE = 256 * 1024;\n\n\tconstructor(@ILogService private readonly logService: ILogService) {\n\t\tsuper();\n\t}\n\n\t//#region File System Provider\n\n\tprivate readonly _onDidChangeFileSystemProviderRegistrations = this._register(new Emitter<IFileSystemProviderRegistrationEvent>());\n\treadonly onDidChangeFileSystemProviderRegistrations = this._onDidChangeFileSystemProviderRegistrations.event;\n\n\tprivate readonly _onWillActivateFileSystemProvider = this._register(new Emitter<IFileSystemProviderActivationEvent>());\n\treadonly onWillActivateFileSystemProvider = this._onWillActivateFileSystemProvider.event;\n\n\tprivate readonly _onDidChangeFileSystemProviderCapabilities = this._register(new Emitter<IFileSystemProviderCapabilitiesChangeEvent>());\n\treadonly onDidChangeFileSystemProviderCapabilities = this._onDidChangeFileSystemProviderCapabilities.event;\n\n\tprivate readonly provider = new Map<string, IFileSystemProvider>();\n\n\tregisterProvider(scheme: string, provider: IFileSystemProvider): IDisposable {\n\t\tif (this.provider.has(scheme)) {\n\t\t\tthrow new Error(`A filesystem provider for the scheme '${scheme}' is already registered.`);\n\t\t}\n\n\t\tmark(`code/registerFilesystem/${scheme}`);\n\n\t\tconst providerDisposables = new DisposableStore();\n\n\t\t// Add provider with event\n\t\tthis.provider.set(scheme, provider);\n\t\tthis._onDidChangeFileSystemProviderRegistrations.fire({ added: true, scheme, provider });\n\n\t\t// Forward events from provider\n\t\tproviderDisposables.add(provider.onDidChangeFile(changes => {\n\t\t\tconst event = new FileChangesEvent(changes, !this.isPathCaseSensitive(provider));\n\n\t\t\t// Always emit any event internally\n\t\t\tthis.internalOnDidFilesChange.fire(event);\n\n\t\t\t// Only emit uncorrelated events in the global `onDidFilesChange` event\n\t\t\tif (!event.hasCorrelation()) {\n\t\t\t\tthis._onDidUncorrelatedFilesChange.fire(event);\n\t\t\t}\n\t\t}));\n\t\tif (typeof provider.onDidWatchError === 'function') {\n\t\t\tproviderDisposables.add(provider.onDidWatchError(error => this._onDidWatchError.fire(new Error(error))));\n\t\t}\n\t\tproviderDisposables.add(provider.onDidChangeCapabilities(() => this._onDidChangeFileSystemProviderCapabilities.fire({ provider, scheme })));\n\n\t\treturn toDisposable(() => {\n\t\t\tthis._onDidChangeFileSystemProviderRegistrations.fire({ added: false, scheme, provider });\n\t\t\tthis.provider.delete(scheme);\n\n\t\t\tdispose(providerDisposables);\n\t\t});\n\t}\n\n\tgetProvider(scheme: string): IFileSystemProvider | undefined {\n\t\treturn this.provider.get(scheme);\n\t}\n\n\tasync activateProvider(scheme: string): Promise<void> {\n\n\t\t// Emit an event that we are about to activate a provider with the given scheme.\n\t\t// Listeners can participate in the activation by registering a provider for it.\n\t\tconst joiners: Promise<void>[] = [];\n\t\tthis._onWillActivateFileSystemProvider.fire({\n\t\t\tscheme,\n\t\t\tjoin(promise) {\n\t\t\t\tjoiners.push(promise);\n\t\t\t},\n\t\t});\n\n\t\tif (this.provider.has(scheme)) {\n\t\t\treturn; // provider is already here so we can return directly\n\t\t}\n\n\t\t// If the provider is not yet there, make sure to join on the listeners assuming\n\t\t// that it takes a bit longer to register the file system provider.\n\t\tawait Promises.settled(joiners);\n\t}\n\n\tasync canHandleResource(resource: URI): Promise<boolean> {\n\n\t\t// Await activation of potentially extension contributed providers\n\t\tawait this.activateProvider(resource.scheme);\n\n\t\treturn this.hasProvider(resource);\n\t}\n\n\thasProvider(resource: URI): boolean {\n\t\treturn this.provider.has(resource.scheme);\n\t}\n\n\thasCapability(resource: URI, capability: FileSystemProviderCapabilities): boolean {\n\t\tconst provider = this.provider.get(resource.scheme);\n\n\t\treturn !!(provider && (provider.capabilities & capability));\n\t}\n\n\tlistCapabilities(): Iterable<{ scheme: string; capabilities: FileSystemProviderCapabilities }> {\n\t\treturn Iterable.map(this.provider, ([scheme, provider]) => ({ scheme, capabilities: provider.capabilities }));\n\t}\n\n\tprotected async withProvider(resource: URI): Promise<IFileSystemProvider> {\n\n\t\t// Assert path is absolute\n\t\tif (!isAbsolutePath(resource)) {\n\t\t\tthrow new FileOperationError(localize('invalidPath', \"Unable to resolve filesystem provider with relative file path '{0}'\", this.resourceForError(resource)), FileOperationResult.FILE_INVALID_PATH);\n\t\t}\n\n\t\t// Activate provider\n\t\tawait this.activateProvider(resource.scheme);\n\n\t\t// Assert provider\n\t\tconst provider = this.provider.get(resource.scheme);\n\t\tif (!provider) {\n\t\t\tconst error = new ErrorNoTelemetry();\n\t\t\terror.message = localize('noProviderFound', \"ENOPRO: No file system provider found for resource '{0}'\", resource.toString());\n\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn provider;\n\t}\n\n\tprivate async withReadProvider(resource: URI): Promise<IFileSystemProviderWithFileReadWriteCapability | IFileSystemProviderWithOpenReadWriteCloseCapability | IFileSystemProviderWithFileReadStreamCapability> {\n\t\tconst provider = await this.withProvider(resource);\n\n\t\tif (hasOpenReadWriteCloseCapability(provider) || hasReadWriteCapability(provider) || hasFileReadStreamCapability(provider)) {\n\t\t\treturn provider;\n\t\t}\n\n\t\tthrow new Error(`Filesystem provider for scheme '${resource.scheme}' neither has FileReadWrite, FileReadStream nor FileOpenReadWriteClose capability which is needed for the read operation.`);\n\t}\n\n\tprivate async withWriteProvider(resource: URI): Promise<IFileSystemProviderWithFileReadWriteCapability | IFileSystemProviderWithOpenReadWriteCloseCapability> {\n\t\tconst provider = await this.withProvider(resource);\n\n\t\tif (hasOpenReadWriteCloseCapability(provider) || hasReadWriteCapability(provider)) {\n\t\t\treturn provider;\n\t\t}\n\n\t\tthrow new Error(`Filesystem provider for scheme '${resource.scheme}' neither has FileReadWrite nor FileOpenReadWriteClose capability which is needed for the write operation.`);\n\t}\n\n\t//#endregion\n\n\t//#region Operation events\n\n\tprivate readonly _onDidRunOperation = this._register(new Emitter<FileOperationEvent>());\n\treadonly onDidRunOperation = this._onDidRunOperation.event;\n\n\t//#endregion\n\n\t//#region File Metadata Resolving\n\n\tasync resolve(resource: URI, options: IResolveMetadataFileOptions): Promise<IFileStatWithMetadata>;\n\tasync resolve(resource: URI, options?: IResolveFileOptions): Promise<IFileStat>;\n\tasync resolve(resource: URI, options?: IResolveFileOptions): Promise<IFileStat> {\n\t\ttry {\n\t\t\treturn await this.doResolveFile(resource, options);\n\t\t} catch (error) {\n\n\t\t\t// Specially handle file not found case as file operation result\n\t\t\tif (toFileSystemProviderErrorCode(error) === FileSystemProviderErrorCode.FileNotFound) {\n\t\t\t\tthrow new FileOperationError(localize('fileNotFoundError', \"Unable to resolve nonexistent file '{0}'\", this.resourceForError(resource)), FileOperationResult.FILE_NOT_FOUND);\n\t\t\t}\n\n\t\t\t// Bubble up any other error as is\n\t\t\tthrow ensureFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tprivate async doResolveFile(resource: URI, options: IResolveMetadataFileOptions): Promise<IFileStatWithMetadata>;\n\tprivate async doResolveFile(resource: URI, options?: IResolveFileOptions): Promise<IFileStat>;\n\tprivate async doResolveFile(resource: URI, options?: IResolveFileOptions): Promise<IFileStat> {\n\t\tconst provider = await this.withProvider(resource);\n\t\tconst isPathCaseSensitive = this.isPathCaseSensitive(provider);\n\n\t\tconst resolveTo = options?.resolveTo;\n\t\tconst resolveSingleChildDescendants = options?.resolveSingleChildDescendants;\n\t\tconst resolveMetadata = options?.resolveMetadata;\n\n\t\tconst stat = await provider.stat(resource);\n\n\t\tlet trie: TernarySearchTree<URI, boolean> | undefined;\n\n\t\treturn this.toFileStat(provider, resource, stat, undefined, !!resolveMetadata, (stat, siblings) => {\n\n\t\t\t// lazy trie to check for recursive resolving\n\t\t\tif (!trie) {\n\t\t\t\ttrie = TernarySearchTree.forUris<true>(() => !isPathCaseSensitive);\n\t\t\t\ttrie.set(resource, true);\n\t\t\t\tif (resolveTo) {\n\t\t\t\t\ttrie.fill(true, resolveTo);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// check for recursive resolving\n\t\t\tif (trie.get(stat.resource) || trie.findSuperstr(stat.resource.with({ query: null, fragment: null } /* required for https://github.com/microsoft/vscode/issues/128151 */))) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// check for resolving single child folders\n\t\t\tif (stat.isDirectory && resolveSingleChildDescendants) {\n\t\t\t\treturn siblings === 1;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t});\n\t}\n\n\tprivate async toFileStat(provider: IFileSystemProvider, resource: URI, stat: IStat | { type: FileType } & Partial<IStat>, siblings: number | undefined, resolveMetadata: boolean, recurse: (stat: IFileStat, siblings?: number) => boolean): Promise<IFileStat>;\n\tprivate async toFileStat(provider: IFileSystemProvider, resource: URI, stat: IStat, siblings: number | undefined, resolveMetadata: true, recurse: (stat: IFileStat, siblings?: number) => boolean): Promise<IFileStatWithMetadata>;\n\tprivate async toFileStat(provider: IFileSystemProvider, resource: URI, stat: IStat | { type: FileType } & Partial<IStat>, siblings: number | undefined, resolveMetadata: boolean, recurse: (stat: IFileStat, siblings?: number) => boolean): Promise<IFileStat> {\n\t\tconst { providerExtUri } = this.getExtUri(provider);\n\n\t\t// convert to file stat\n\t\tconst fileStat: IFileStat = {\n\t\t\tresource,\n\t\t\tname: providerExtUri.basename(resource),\n\t\t\tisFile: (stat.type & FileType.File) !== 0,\n\t\t\tisDirectory: (stat.type & FileType.Directory) !== 0,\n\t\t\tisSymbolicLink: (stat.type & FileType.SymbolicLink) !== 0,\n\t\t\tmtime: stat.mtime,\n\t\t\tctime: stat.ctime,\n\t\t\tsize: stat.size,\n\t\t\treadonly: Boolean((stat.permissions ?? 0) & FilePermission.Readonly) || Boolean(provider.capabilities & FileSystemProviderCapabilities.Readonly),\n\t\t\tlocked: Boolean((stat.permissions ?? 0) & FilePermission.Locked),\n\t\t\tetag: etag({ mtime: stat.mtime, size: stat.size }),\n\t\t\tchildren: undefined\n\t\t};\n\n\t\t// check to recurse for directories\n\t\tif (fileStat.isDirectory && recurse(fileStat, siblings)) {\n\t\t\ttry {\n\t\t\t\tconst entries = await provider.readdir(resource);\n\t\t\t\tconst resolvedEntries = await Promises.settled(entries.map(async ([name, type]) => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst childResource = providerExtUri.joinPath(resource, name);\n\t\t\t\t\t\tconst childStat = resolveMetadata ? await provider.stat(childResource) : { type };\n\n\t\t\t\t\t\treturn await this.toFileStat(provider, childResource, childStat, entries.length, resolveMetadata, recurse);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tthis.logService.trace(error);\n\n\t\t\t\t\t\treturn null; // can happen e.g. due to permission errors\n\t\t\t\t\t}\n\t\t\t\t}));\n\n\t\t\t\t// make sure to get rid of null values that signal a failure to resolve a particular entry\n\t\t\t\tfileStat.children = coalesce(resolvedEntries);\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.trace(error);\n\n\t\t\t\tfileStat.children = []; // gracefully handle errors, we may not have permissions to read\n\t\t\t}\n\n\t\t\treturn fileStat;\n\t\t}\n\n\t\treturn fileStat;\n\t}\n\n\tasync resolveAll(toResolve: { resource: URI; options?: IResolveFileOptions }[]): Promise<IFileStatResult[]>;\n\tasync resolveAll(toResolve: { resource: URI; options: IResolveMetadataFileOptions }[]): Promise<IFileStatResultWithMetadata[]>;\n\tasync resolveAll(toResolve: { resource: URI; options?: IResolveFileOptions }[]): Promise<IFileStatResult[]> {\n\t\treturn Promises.settled(toResolve.map(async entry => {\n\t\t\ttry {\n\t\t\t\treturn { stat: await this.doResolveFile(entry.resource, entry.options), success: true };\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.trace(error);\n\n\t\t\t\treturn { stat: undefined, success: false };\n\t\t\t}\n\t\t}));\n\t}\n\n\tasync stat(resource: URI): Promise<IFileStatWithPartialMetadata> {\n\t\tconst provider = await this.withProvider(resource);\n\n\t\tconst stat = await provider.stat(resource);\n\n\t\treturn this.toFileStat(provider, resource, stat, undefined, true, () => false /* Do not resolve any children */);\n\t}\n\n\tasync exists(resource: URI): Promise<boolean> {\n\t\tconst provider = await this.withProvider(resource);\n\n\t\ttry {\n\t\t\tconst stat = await provider.stat(resource);\n\n\t\t\treturn !!stat;\n\t\t} catch (error) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region File Reading/Writing\n\n\tasync canCreateFile(resource: URI, options?: ICreateFileOptions): Promise<Error | true> {\n\t\ttry {\n\t\t\tawait this.doValidateCreateFile(resource, options);\n\t\t} catch (error) {\n\t\t\treturn error;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate async doValidateCreateFile(resource: URI, options?: ICreateFileOptions): Promise<void> {\n\n\t\t// validate overwrite\n\t\tif (!options?.overwrite && await this.exists(resource)) {\n\t\t\tthrow new FileOperationError(localize('fileExists', \"Unable to create file '{0}' that already exists when overwrite flag is not set\", this.resourceForError(resource)), FileOperationResult.FILE_MODIFIED_SINCE, options);\n\t\t}\n\t}\n\n\tasync createFile(resource: URI, bufferOrReadableOrStream: VSBuffer | VSBufferReadable | VSBufferReadableStream = VSBuffer.fromString(''), options?: ICreateFileOptions): Promise<IFileStatWithMetadata> {\n\n\t\t// validate\n\t\tawait this.doValidateCreateFile(resource, options);\n\n\t\t// do write into file (this will create it too)\n\t\tconst fileStat = await this.writeFile(resource, bufferOrReadableOrStream);\n\n\t\t// events\n\t\tthis._onDidRunOperation.fire(new FileOperationEvent(resource, FileOperation.CREATE, fileStat));\n\n\t\treturn fileStat;\n\t}\n\n\tasync writeFile(resource: URI, bufferOrReadableOrStream: VSBuffer | VSBufferReadable | VSBufferReadableStream, options?: IWriteFileOptions): Promise<IFileStatWithMetadata> {\n\t\tconst provider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(resource), resource);\n\t\tconst { providerExtUri } = this.getExtUri(provider);\n\n\t\tlet writeFileOptions = options;\n\t\tif (hasFileAtomicWriteCapability(provider) && !writeFileOptions?.atomic) {\n\t\t\tconst enforcedAtomicWrite = provider.enforceAtomicWriteFile?.(resource);\n\t\t\tif (enforcedAtomicWrite) {\n\t\t\t\twriteFileOptions = { ...options, atomic: enforcedAtomicWrite };\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\n\t\t\t// validate write\n\t\t\tconst stat = await this.validateWriteFile(provider, resource, writeFileOptions);\n\n\t\t\t// mkdir recursively as needed\n\t\t\tif (!stat) {\n\t\t\t\tawait this.mkdirp(provider, providerExtUri.dirname(resource));\n\t\t\t}\n\n\t\t\t// optimization: if the provider has unbuffered write capability and the data\n\t\t\t// to write is not a buffer, we consume up to 3 chunks and try to write the data\n\t\t\t// unbuffered to reduce the overhead. If the stream or readable has more data\n\t\t\t// to provide we continue to write buffered.\n\t\t\tlet bufferOrReadableOrStreamOrBufferedStream: VSBuffer | VSBufferReadable | VSBufferReadableStream | VSBufferReadableBufferedStream;\n\t\t\tif (hasReadWriteCapability(provider) && !(bufferOrReadableOrStream instanceof VSBuffer)) {\n\t\t\t\tif (isReadableStream(bufferOrReadableOrStream)) {\n\t\t\t\t\tconst bufferedStream = await peekStream(bufferOrReadableOrStream, 3);\n\t\t\t\t\tif (bufferedStream.ended) {\n\t\t\t\t\t\tbufferOrReadableOrStreamOrBufferedStream = VSBuffer.concat(bufferedStream.buffer);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbufferOrReadableOrStreamOrBufferedStream = bufferedStream;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbufferOrReadableOrStreamOrBufferedStream = peekReadable(bufferOrReadableOrStream, data => VSBuffer.concat(data), 3);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbufferOrReadableOrStreamOrBufferedStream = bufferOrReadableOrStream;\n\t\t\t}\n\n\t\t\t// write file: unbuffered\n\t\t\tif (\n\t\t\t\t!hasOpenReadWriteCloseCapability(provider) ||\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// buffered writing is unsupported\n\t\t\t\t(hasReadWriteCapability(provider) && bufferOrReadableOrStreamOrBufferedStream instanceof VSBuffer) ||\t\t// data is a full buffer already\n\t\t\t\t(hasReadWriteCapability(provider) && hasFileAtomicWriteCapability(provider) && writeFileOptions?.atomic)\t// atomic write forces unbuffered write if the provider supports it\n\t\t\t) {\n\t\t\t\tawait this.doWriteUnbuffered(provider, resource, writeFileOptions, bufferOrReadableOrStreamOrBufferedStream);\n\t\t\t}\n\n\t\t\t// write file: buffered\n\t\t\telse {\n\t\t\t\tawait this.doWriteBuffered(provider, resource, writeFileOptions, bufferOrReadableOrStreamOrBufferedStream instanceof VSBuffer ? bufferToReadable(bufferOrReadableOrStreamOrBufferedStream) : bufferOrReadableOrStreamOrBufferedStream);\n\t\t\t}\n\n\t\t\t// events\n\t\t\tthis._onDidRunOperation.fire(new FileOperationEvent(resource, FileOperation.WRITE));\n\t\t} catch (error) {\n\t\t\tthrow new FileOperationError(localize('err.write', \"Unable to write file '{0}' ({1})\", this.resourceForError(resource), ensureFileSystemProviderError(error).toString()), toFileOperationResult(error), writeFileOptions);\n\t\t}\n\n\t\treturn this.resolve(resource, { resolveMetadata: true });\n\t}\n\n\tprivate async validateWriteFile(provider: IFileSystemProvider, resource: URI, options?: IWriteFileOptions): Promise<IStat | undefined> {\n\n\t\t// Validate unlock support\n\t\tconst unlock = !!options?.unlock;\n\t\tif (unlock && !(provider.capabilities & FileSystemProviderCapabilities.FileWriteUnlock)) {\n\t\t\tthrow new Error(localize('writeFailedUnlockUnsupported', \"Unable to unlock file '{0}' because provider does not support it.\", this.resourceForError(resource)));\n\t\t}\n\n\t\t// Validate atomic support\n\t\tconst atomic = !!options?.atomic;\n\t\tif (atomic) {\n\t\t\tif (!(provider.capabilities & FileSystemProviderCapabilities.FileAtomicWrite)) {\n\t\t\t\tthrow new Error(localize('writeFailedAtomicUnsupported1', \"Unable to atomically write file '{0}' because provider does not support it.\", this.resourceForError(resource)));\n\t\t\t}\n\n\t\t\tif (!(provider.capabilities & FileSystemProviderCapabilities.FileReadWrite)) {\n\t\t\t\tthrow new Error(localize('writeFailedAtomicUnsupported2', \"Unable to atomically write file '{0}' because provider does not support unbuffered writes.\", this.resourceForError(resource)));\n\t\t\t}\n\n\t\t\tif (unlock) {\n\t\t\t\tthrow new Error(localize('writeFailedAtomicUnlock', \"Unable to unlock file '{0}' because atomic write is enabled.\", this.resourceForError(resource)));\n\t\t\t}\n\t\t}\n\n\t\t// Validate via file stat meta data\n\t\tlet stat: IStat | undefined = undefined;\n\t\ttry {\n\t\t\tstat = await provider.stat(resource);\n\t\t} catch (error) {\n\t\t\treturn undefined; // file might not exist\n\t\t}\n\n\t\t// File cannot be directory\n\t\tif ((stat.type & FileType.Directory) !== 0) {\n\t\t\tthrow new FileOperationError(localize('fileIsDirectoryWriteError', \"Unable to write file '{0}' that is actually a directory\", this.resourceForError(resource)), FileOperationResult.FILE_IS_DIRECTORY, options);\n\t\t}\n\n\t\t// File cannot be readonly\n\t\tthis.throwIfFileIsReadonly(resource, stat);\n\n\t\t// Dirty write prevention: if the file on disk has been changed and does not match our expected\n\t\t// mtime and etag, we bail out to prevent dirty writing.\n\t\t//\n\t\t// First, we check for a mtime that is in the future before we do more checks. The assumption is\n\t\t// that only the mtime is an indicator for a file that has changed on disk.\n\t\t//\n\t\t// Second, if the mtime has advanced, we compare the size of the file on disk with our previous\n\t\t// one using the etag() function. Relying only on the mtime check has prooven to produce false\n\t\t// positives due to file system weirdness (especially around remote file systems). As such, the\n\t\t// check for size is a weaker check because it can return a false negative if the file has changed\n\t\t// but to the same length. This is a compromise we take to avoid having to produce checksums of\n\t\t// the file content for comparison which would be much slower to compute.\n\t\tif (\n\t\t\ttypeof options?.mtime === 'number' && typeof options.etag === 'string' && options.etag !== ETAG_DISABLED &&\n\t\t\ttypeof stat.mtime === 'number' && typeof stat.size === 'number' &&\n\t\t\toptions.mtime < stat.mtime && options.etag !== etag({ mtime: options.mtime /* not using stat.mtime for a reason, see above */, size: stat.size })\n\t\t) {\n\t\t\tthrow new FileOperationError(localize('fileModifiedError', \"File Modified Since\"), FileOperationResult.FILE_MODIFIED_SINCE, options);\n\t\t}\n\n\t\treturn stat;\n\t}\n\n\tasync readFile(resource: URI, options?: IReadFileOptions, token?: CancellationToken): Promise<IFileContent> {\n\t\tconst provider = await this.withReadProvider(resource);\n\n\t\tif (options?.atomic) {\n\t\t\treturn this.doReadFileAtomic(provider, resource, options, token);\n\t\t}\n\n\t\treturn this.doReadFile(provider, resource, options, token);\n\t}\n\n\tprivate async doReadFileAtomic(provider: IFileSystemProviderWithFileReadWriteCapability | IFileSystemProviderWithOpenReadWriteCloseCapability | IFileSystemProviderWithFileReadStreamCapability, resource: URI, options?: IReadFileOptions, token?: CancellationToken): Promise<IFileContent> {\n\t\treturn new Promise<IFileContent>((resolve, reject) => {\n\t\t\tthis.writeQueue.queueFor(resource, async () => {\n\t\t\t\ttry {\n\t\t\t\t\tconst content = await this.doReadFile(provider, resource, options, token);\n\t\t\t\t\tresolve(content);\n\t\t\t\t} catch (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\t\t\t}, this.getExtUri(provider).providerExtUri);\n\t\t});\n\t}\n\n\tprivate async doReadFile(provider: IFileSystemProviderWithFileReadWriteCapability | IFileSystemProviderWithOpenReadWriteCloseCapability | IFileSystemProviderWithFileReadStreamCapability, resource: URI, options?: IReadFileOptions, token?: CancellationToken): Promise<IFileContent> {\n\t\tconst stream = await this.doReadFileStream(provider, resource, {\n\t\t\t...options,\n\t\t\t// optimization: since we know that the caller does not\n\t\t\t// care about buffering, we indicate this to the reader.\n\t\t\t// this reduces all the overhead the buffered reading\n\t\t\t// has (open, read, close) if the provider supports\n\t\t\t// unbuffered reading.\n\t\t\tpreferUnbuffered: true\n\t\t}, token);\n\n\t\treturn {\n\t\t\t...stream,\n\t\t\tvalue: await streamToBuffer(stream.value)\n\t\t};\n\t}\n\n\tasync readFileStream(resource: URI, options?: IReadFileStreamOptions, token?: CancellationToken): Promise<IFileStreamContent> {\n\t\tconst provider = await this.withReadProvider(resource);\n\n\t\treturn this.doReadFileStream(provider, resource, options, token);\n\t}\n\n\tprivate async doReadFileStream(provider: IFileSystemProviderWithFileReadWriteCapability | IFileSystemProviderWithOpenReadWriteCloseCapability | IFileSystemProviderWithFileReadStreamCapability, resource: URI, options?: IReadFileOptions & IReadFileStreamOptions & { preferUnbuffered?: boolean }, token?: CancellationToken): Promise<IFileStreamContent> {\n\n\t\t// install a cancellation token that gets cancelled\n\t\t// when any error occurs. this allows us to resolve\n\t\t// the content of the file while resolving metadata\n\t\t// but still cancel the operation in certain cases.\n\t\t//\n\t\t// in addition, we pass the optional token in that\n\t\t// we got from the outside to even allow for external\n\t\t// cancellation of the read operation.\n\t\tconst cancellableSource = new CancellationTokenSource(token);\n\n\t\tlet readFileOptions = options;\n\t\tif (hasFileAtomicReadCapability(provider) && provider.enforceAtomicReadFile?.(resource)) {\n\t\t\treadFileOptions = { ...options, atomic: true };\n\t\t}\n\n\t\t// validate read operation\n\t\tconst statPromise = this.validateReadFile(resource, readFileOptions).then(stat => stat, error => {\n\t\t\tcancellableSource.dispose(true);\n\n\t\t\tthrow error;\n\t\t});\n\n\t\tlet fileStream: VSBufferReadableStream | undefined = undefined;\n\t\ttry {\n\n\t\t\t// if the etag is provided, we await the result of the validation\n\t\t\t// due to the likelihood of hitting a NOT_MODIFIED_SINCE result.\n\t\t\t// otherwise, we let it run in parallel to the file reading for\n\t\t\t// optimal startup performance.\n\t\t\tif (typeof readFileOptions?.etag === 'string' && readFileOptions.etag !== ETAG_DISABLED) {\n\t\t\t\tawait statPromise;\n\t\t\t}\n\n\t\t\t// read unbuffered\n\t\t\tif (\n\t\t\t\t(readFileOptions?.atomic && hasFileAtomicReadCapability(provider)) ||\t\t\t\t\t\t\t\t// atomic reads are always unbuffered\n\t\t\t\t!(hasOpenReadWriteCloseCapability(provider) || hasFileReadStreamCapability(provider)) ||\t// provider has no buffered capability\n\t\t\t\t(hasReadWriteCapability(provider) && readFileOptions?.preferUnbuffered)\t\t\t\t\t\t\t\t// unbuffered read is preferred\n\t\t\t) {\n\t\t\t\tfileStream = this.readFileUnbuffered(provider, resource, readFileOptions);\n\t\t\t}\n\n\t\t\t// read streamed (always prefer over primitive buffered read)\n\t\t\telse if (hasFileReadStreamCapability(provider)) {\n\t\t\t\tfileStream = this.readFileStreamed(provider, resource, cancellableSource.token, readFileOptions);\n\t\t\t}\n\n\t\t\t// read buffered\n\t\t\telse {\n\t\t\t\tfileStream = this.readFileBuffered(provider, resource, cancellableSource.token, readFileOptions);\n\t\t\t}\n\n\t\t\tfileStream.on('end', () => cancellableSource.dispose());\n\t\t\tfileStream.on('error', () => cancellableSource.dispose());\n\n\t\t\tconst fileStat = await statPromise;\n\n\t\t\treturn {\n\t\t\t\t...fileStat,\n\t\t\t\tvalue: fileStream\n\t\t\t};\n\t\t} catch (error) {\n\n\t\t\t// Await the stream to finish so that we exit this method\n\t\t\t// in a consistent state with file handles closed\n\t\t\t// (https://github.com/microsoft/vscode/issues/114024)\n\t\t\tif (fileStream) {\n\t\t\t\tawait consumeStream(fileStream);\n\t\t\t}\n\n\t\t\t// Re-throw errors as file operation errors but preserve\n\t\t\t// specific errors (such as not modified since)\n\t\t\tthrow this.restoreReadError(error, resource, readFileOptions);\n\t\t}\n\t}\n\n\tprivate restoreReadError(error: Error, resource: URI, options?: IReadFileStreamOptions): FileOperationError {\n\t\tconst message = localize('err.read', \"Unable to read file '{0}' ({1})\", this.resourceForError(resource), ensureFileSystemProviderError(error).toString());\n\n\t\tif (error instanceof NotModifiedSinceFileOperationError) {\n\t\t\treturn new NotModifiedSinceFileOperationError(message, error.stat, options);\n\t\t}\n\n\t\tif (error instanceof TooLargeFileOperationError) {\n\t\t\treturn new TooLargeFileOperationError(message, error.fileOperationResult, error.size, error.options as IReadFileOptions);\n\t\t}\n\n\t\treturn new FileOperationError(message, toFileOperationResult(error), options);\n\t}\n\n\tprivate readFileStreamed(provider: IFileSystemProviderWithFileReadStreamCapability, resource: URI, token: CancellationToken, options: IReadFileStreamOptions = Object.create(null)): VSBufferReadableStream {\n\t\tconst fileStream = provider.readFileStream(resource, options, token);\n\n\t\treturn transform(fileStream, {\n\t\t\tdata: data => data instanceof VSBuffer ? data : VSBuffer.wrap(data),\n\t\t\terror: error => this.restoreReadError(error, resource, options)\n\t\t}, data => VSBuffer.concat(data));\n\t}\n\n\tprivate readFileBuffered(provider: IFileSystemProviderWithOpenReadWriteCloseCapability, resource: URI, token: CancellationToken, options: IReadFileStreamOptions = Object.create(null)): VSBufferReadableStream {\n\t\tconst stream = newWriteableBufferStream();\n\n\t\treadFileIntoStream(provider, resource, stream, data => data, {\n\t\t\t...options,\n\t\t\tbufferSize: this.BUFFER_SIZE,\n\t\t\terrorTransformer: error => this.restoreReadError(error, resource, options)\n\t\t}, token);\n\n\t\treturn stream;\n\t}\n\n\tprivate readFileUnbuffered(provider: IFileSystemProviderWithFileReadWriteCapability | IFileSystemProviderWithFileAtomicReadCapability, resource: URI, options?: IReadFileOptions & IReadFileStreamOptions): VSBufferReadableStream {\n\t\tconst stream = newWriteableStream<VSBuffer>(data => VSBuffer.concat(data));\n\n\t\t// Read the file into the stream async but do not wait for\n\t\t// this to complete because streams work via events\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tlet buffer: Uint8Array;\n\t\t\t\tif (options?.atomic && hasFileAtomicReadCapability(provider)) {\n\t\t\t\t\tbuffer = await provider.readFile(resource, { atomic: true });\n\t\t\t\t} else {\n\t\t\t\t\tbuffer = await provider.readFile(resource);\n\t\t\t\t}\n\n\t\t\t\t// respect position option\n\t\t\t\tif (typeof options?.position === 'number') {\n\t\t\t\t\tbuffer = buffer.slice(options.position);\n\t\t\t\t}\n\n\t\t\t\t// respect length option\n\t\t\t\tif (typeof options?.length === 'number') {\n\t\t\t\t\tbuffer = buffer.slice(0, options.length);\n\t\t\t\t}\n\n\t\t\t\t// Throw if file is too large to load\n\t\t\t\tthis.validateReadFileLimits(resource, buffer.byteLength, options);\n\n\t\t\t\t// End stream with data\n\t\t\t\tstream.end(VSBuffer.wrap(buffer));\n\t\t\t} catch (err) {\n\t\t\t\tstream.error(err);\n\t\t\t\tstream.end();\n\t\t\t}\n\t\t})();\n\n\t\treturn stream;\n\t}\n\n\tprivate async validateReadFile(resource: URI, options?: IReadFileStreamOptions): Promise<IFileStatWithMetadata> {\n\t\tconst stat = await this.resolve(resource, { resolveMetadata: true });\n\n\t\t// Throw if resource is a directory\n\t\tif (stat.isDirectory) {\n\t\t\tthrow new FileOperationError(localize('fileIsDirectoryReadError', \"Unable to read file '{0}' that is actually a directory\", this.resourceForError(resource)), FileOperationResult.FILE_IS_DIRECTORY, options);\n\t\t}\n\n\t\t// Throw if file not modified since (unless disabled)\n\t\tif (typeof options?.etag === 'string' && options.etag !== ETAG_DISABLED && options.etag === stat.etag) {\n\t\t\tthrow new NotModifiedSinceFileOperationError(localize('fileNotModifiedError', \"File not modified since\"), stat, options);\n\t\t}\n\n\t\t// Throw if file is too large to load\n\t\tthis.validateReadFileLimits(resource, stat.size, options);\n\n\t\treturn stat;\n\t}\n\n\tprivate validateReadFileLimits(resource: URI, size: number, options?: IReadFileStreamOptions): void {\n\t\tif (typeof options?.limits?.size === 'number' && size > options.limits.size) {\n\t\t\tthrow new TooLargeFileOperationError(localize('fileTooLargeError', \"Unable to read file '{0}' that is too large to open\", this.resourceForError(resource)), FileOperationResult.FILE_TOO_LARGE, size, options);\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region Move/Copy/Delete/Create Folder\n\n\tasync canMove(source: URI, target: URI, overwrite?: boolean): Promise<Error | true> {\n\t\treturn this.doCanMoveCopy(source, target, 'move', overwrite);\n\t}\n\n\tasync canCopy(source: URI, target: URI, overwrite?: boolean): Promise<Error | true> {\n\t\treturn this.doCanMoveCopy(source, target, 'copy', overwrite);\n\t}\n\n\tprivate async doCanMoveCopy(source: URI, target: URI, mode: 'move' | 'copy', overwrite?: boolean): Promise<Error | true> {\n\t\tif (source.toString() !== target.toString()) {\n\t\t\ttry {\n\t\t\t\tconst sourceProvider = mode === 'move' ? this.throwIfFileSystemIsReadonly(await this.withWriteProvider(source), source) : await this.withReadProvider(source);\n\t\t\t\tconst targetProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(target), target);\n\n\t\t\t\tawait this.doValidateMoveCopy(sourceProvider, source, targetProvider, target, mode, overwrite);\n\t\t\t} catch (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tasync move(source: URI, target: URI, overwrite?: boolean): Promise<IFileStatWithMetadata> {\n\t\tconst sourceProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(source), source);\n\t\tconst targetProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(target), target);\n\n\t\t// move\n\t\tconst mode = await this.doMoveCopy(sourceProvider, source, targetProvider, target, 'move', !!overwrite);\n\n\t\t// resolve and send events\n\t\tconst fileStat = await this.resolve(target, { resolveMetadata: true });\n\t\tthis._onDidRunOperation.fire(new FileOperationEvent(source, mode === 'move' ? FileOperation.MOVE : FileOperation.COPY, fileStat));\n\n\t\treturn fileStat;\n\t}\n\n\tasync copy(source: URI, target: URI, overwrite?: boolean): Promise<IFileStatWithMetadata> {\n\t\tconst sourceProvider = await this.withReadProvider(source);\n\t\tconst targetProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(target), target);\n\n\t\t// copy\n\t\tconst mode = await this.doMoveCopy(sourceProvider, source, targetProvider, target, 'copy', !!overwrite);\n\n\t\t// resolve and send events\n\t\tconst fileStat = await this.resolve(target, { resolveMetadata: true });\n\t\tthis._onDidRunOperation.fire(new FileOperationEvent(source, mode === 'copy' ? FileOperation.COPY : FileOperation.MOVE, fileStat));\n\n\t\treturn fileStat;\n\t}\n\n\tprivate async doMoveCopy(sourceProvider: IFileSystemProvider, source: URI, targetProvider: IFileSystemProvider, target: URI, mode: 'move' | 'copy', overwrite: boolean): Promise<'move' | 'copy'> {\n\t\tif (source.toString() === target.toString()) {\n\t\t\treturn mode; // simulate node.js behaviour here and do a no-op if paths match\n\t\t}\n\n\t\t// validation\n\t\tconst { exists, isSameResourceWithDifferentPathCase } = await this.doValidateMoveCopy(sourceProvider, source, targetProvider, target, mode, overwrite);\n\n\t\t// delete as needed (unless target is same resurce with different path case)\n\t\tif (exists && !isSameResourceWithDifferentPathCase && overwrite) {\n\t\t\tawait this.del(target, { recursive: true });\n\t\t}\n\n\t\t// create parent folders\n\t\tawait this.mkdirp(targetProvider, this.getExtUri(targetProvider).providerExtUri.dirname(target));\n\n\t\t// copy source => target\n\t\tif (mode === 'copy') {\n\n\t\t\t// same provider with fast copy: leverage copy() functionality\n\t\t\tif (sourceProvider === targetProvider && hasFileFolderCopyCapability(sourceProvider)) {\n\t\t\t\tawait sourceProvider.copy(source, target, { overwrite });\n\t\t\t}\n\n\t\t\t// when copying via buffer/unbuffered, we have to manually\n\t\t\t// traverse the source if it is a folder and not a file\n\t\t\telse {\n\t\t\t\tconst sourceFile = await this.resolve(source);\n\t\t\t\tif (sourceFile.isDirectory) {\n\t\t\t\t\tawait this.doCopyFolder(sourceProvider, sourceFile, targetProvider, target);\n\t\t\t\t} else {\n\t\t\t\t\tawait this.doCopyFile(sourceProvider, source, targetProvider, target);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn mode;\n\t\t}\n\n\t\t// move source => target\n\t\telse {\n\n\t\t\t// same provider: leverage rename() functionality\n\t\t\tif (sourceProvider === targetProvider) {\n\t\t\t\tawait sourceProvider.rename(source, target, { overwrite });\n\n\t\t\t\treturn mode;\n\t\t\t}\n\n\t\t\t// across providers: copy to target & delete at source\n\t\t\telse {\n\t\t\t\tawait this.doMoveCopy(sourceProvider, source, targetProvider, target, 'copy', overwrite);\n\t\t\t\tawait this.del(source, { recursive: true });\n\n\t\t\t\treturn 'copy';\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async doCopyFile(sourceProvider: IFileSystemProvider, source: URI, targetProvider: IFileSystemProvider, target: URI): Promise<void> {\n\n\t\t// copy: source (buffered) => target (buffered)\n\t\tif (hasOpenReadWriteCloseCapability(sourceProvider) && hasOpenReadWriteCloseCapability(targetProvider)) {\n\t\t\treturn this.doPipeBuffered(sourceProvider, source, targetProvider, target);\n\t\t}\n\n\t\t// copy: source (buffered) => target (unbuffered)\n\t\tif (hasOpenReadWriteCloseCapability(sourceProvider) && hasReadWriteCapability(targetProvider)) {\n\t\t\treturn this.doPipeBufferedToUnbuffered(sourceProvider, source, targetProvider, target);\n\t\t}\n\n\t\t// copy: source (unbuffered) => target (buffered)\n\t\tif (hasReadWriteCapability(sourceProvider) && hasOpenReadWriteCloseCapability(targetProvider)) {\n\t\t\treturn this.doPipeUnbufferedToBuffered(sourceProvider, source, targetProvider, target);\n\t\t}\n\n\t\t// copy: source (unbuffered) => target (unbuffered)\n\t\tif (hasReadWriteCapability(sourceProvider) && hasReadWriteCapability(targetProvider)) {\n\t\t\treturn this.doPipeUnbuffered(sourceProvider, source, targetProvider, target);\n\t\t}\n\t}\n\n\tprivate async doCopyFolder(sourceProvider: IFileSystemProvider, sourceFolder: IFileStat, targetProvider: IFileSystemProvider, targetFolder: URI): Promise<void> {\n\n\t\t// create folder in target\n\t\tawait targetProvider.mkdir(targetFolder);\n\n\t\t// create children in target\n\t\tif (Array.isArray(sourceFolder.children)) {\n\t\t\tawait Promises.settled(sourceFolder.children.map(async sourceChild => {\n\t\t\t\tconst targetChild = this.getExtUri(targetProvider).providerExtUri.joinPath(targetFolder, sourceChild.name);\n\t\t\t\tif (sourceChild.isDirectory) {\n\t\t\t\t\treturn this.doCopyFolder(sourceProvider, await this.resolve(sourceChild.resource), targetProvider, targetChild);\n\t\t\t\t} else {\n\t\t\t\t\treturn this.doCopyFile(sourceProvider, sourceChild.resource, targetProvider, targetChild);\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\t}\n\n\tprivate async doValidateMoveCopy(sourceProvider: IFileSystemProvider, source: URI, targetProvider: IFileSystemProvider, target: URI, mode: 'move' | 'copy', overwrite?: boolean): Promise<{ exists: boolean; isSameResourceWithDifferentPathCase: boolean }> {\n\t\tlet isSameResourceWithDifferentPathCase = false;\n\n\t\t// Check if source is equal or parent to target (requires providers to be the same)\n\t\tif (sourceProvider === targetProvider) {\n\t\t\tconst { providerExtUri, isPathCaseSensitive } = this.getExtUri(sourceProvider);\n\t\t\tif (!isPathCaseSensitive) {\n\t\t\t\tisSameResourceWithDifferentPathCase = providerExtUri.isEqual(source, target);\n\t\t\t}\n\n\t\t\tif (isSameResourceWithDifferentPathCase && mode === 'copy') {\n\t\t\t\tthrow new Error(localize('unableToMoveCopyError1', \"Unable to copy when source '{0}' is same as target '{1}' with different path case on a case insensitive file system\", this.resourceForError(source), this.resourceForError(target)));\n\t\t\t}\n\n\t\t\tif (!isSameResourceWithDifferentPathCase && providerExtUri.isEqualOrParent(target, source)) {\n\t\t\t\tthrow new Error(localize('unableToMoveCopyError2', \"Unable to move/copy when source '{0}' is parent of target '{1}'.\", this.resourceForError(source), this.resourceForError(target)));\n\t\t\t}\n\t\t}\n\n\t\t// Extra checks if target exists and this is not a rename\n\t\tconst exists = await this.exists(target);\n\t\tif (exists && !isSameResourceWithDifferentPathCase) {\n\n\t\t\t// Bail out if target exists and we are not about to overwrite\n\t\t\tif (!overwrite) {\n\t\t\t\tthrow new FileOperationError(localize('unableToMoveCopyError3', \"Unable to move/copy '{0}' because target '{1}' already exists at destination.\", this.resourceForError(source), this.resourceForError(target)), FileOperationResult.FILE_MOVE_CONFLICT);\n\t\t\t}\n\n\t\t\t// Special case: if the target is a parent of the source, we cannot delete\n\t\t\t// it as it would delete the source as well. In this case we have to throw\n\t\t\tif (sourceProvider === targetProvider) {\n\t\t\t\tconst { providerExtUri } = this.getExtUri(sourceProvider);\n\t\t\t\tif (providerExtUri.isEqualOrParent(source, target)) {\n\t\t\t\t\tthrow new Error(localize('unableToMoveCopyError4', \"Unable to move/copy '{0}' into '{1}' since a file would replace the folder it is contained in.\", this.resourceForError(source), this.resourceForError(target)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn { exists, isSameResourceWithDifferentPathCase };\n\t}\n\n\tprivate getExtUri(provider: IFileSystemProvider): { providerExtUri: IExtUri; isPathCaseSensitive: boolean } {\n\t\tconst isPathCaseSensitive = this.isPathCaseSensitive(provider);\n\n\t\treturn {\n\t\t\tproviderExtUri: isPathCaseSensitive ? extUri : extUriIgnorePathCase,\n\t\t\tisPathCaseSensitive\n\t\t};\n\t}\n\n\tprivate isPathCaseSensitive(provider: IFileSystemProvider): boolean {\n\t\treturn !!(provider.capabilities & FileSystemProviderCapabilities.PathCaseSensitive);\n\t}\n\n\tasync createFolder(resource: URI): Promise<IFileStatWithMetadata> {\n\t\tconst provider = this.throwIfFileSystemIsReadonly(await this.withProvider(resource), resource);\n\n\t\t// mkdir recursively\n\t\tawait this.mkdirp(provider, resource);\n\n\t\t// events\n\t\tconst fileStat = await this.resolve(resource, { resolveMetadata: true });\n\t\tthis._onDidRunOperation.fire(new FileOperationEvent(resource, FileOperation.CREATE, fileStat));\n\n\t\treturn fileStat;\n\t}\n\n\tprivate async mkdirp(provider: IFileSystemProvider, directory: URI): Promise<void> {\n\t\tconst directoriesToCreate: string[] = [];\n\n\t\t// mkdir until we reach root\n\t\tconst { providerExtUri } = this.getExtUri(provider);\n\t\twhile (!providerExtUri.isEqual(directory, providerExtUri.dirname(directory))) {\n\t\t\ttry {\n\t\t\t\tconst stat = await provider.stat(directory);\n\t\t\t\tif ((stat.type & FileType.Directory) === 0) {\n\t\t\t\t\tthrow new Error(localize('mkdirExistsError', \"Unable to create folder '{0}' that already exists but is not a directory\", this.resourceForError(directory)));\n\t\t\t\t}\n\n\t\t\t\tbreak; // we have hit a directory that exists -> good\n\t\t\t} catch (error) {\n\n\t\t\t\t// Bubble up any other error that is not file not found\n\t\t\t\tif (toFileSystemProviderErrorCode(error) !== FileSystemProviderErrorCode.FileNotFound) {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\n\t\t\t\t// Upon error, remember directories that need to be created\n\t\t\t\tdirectoriesToCreate.push(providerExtUri.basename(directory));\n\n\t\t\t\t// Continue up\n\t\t\t\tdirectory = providerExtUri.dirname(directory);\n\t\t\t}\n\t\t}\n\n\t\t// Create directories as needed\n\t\tfor (let i = directoriesToCreate.length - 1; i >= 0; i--) {\n\t\t\tdirectory = providerExtUri.joinPath(directory, directoriesToCreate[i]);\n\n\t\t\ttry {\n\t\t\t\tawait provider.mkdir(directory);\n\t\t\t} catch (error) {\n\t\t\t\tif (toFileSystemProviderErrorCode(error) !== FileSystemProviderErrorCode.FileExists) {\n\t\t\t\t\t// For mkdirp() we tolerate that the mkdir() call fails\n\t\t\t\t\t// in case the folder already exists. This follows node.js\n\t\t\t\t\t// own implementation of fs.mkdir({ recursive: true }) and\n\t\t\t\t\t// reduces the chances of race conditions leading to errors\n\t\t\t\t\t// if multiple calls try to create the same folders\n\t\t\t\t\t// As such, we only throw an error here if it is other than\n\t\t\t\t\t// the fact that the file already exists.\n\t\t\t\t\t// (see also https://github.com/microsoft/vscode/issues/89834)\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tasync canDelete(resource: URI, options?: Partial<IFileDeleteOptions>): Promise<Error | true> {\n\t\ttry {\n\t\t\tawait this.doValidateDelete(resource, options);\n\t\t} catch (error) {\n\t\t\treturn error;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate async doValidateDelete(resource: URI, options?: Partial<IFileDeleteOptions>): Promise<IFileSystemProvider> {\n\t\tconst provider = this.throwIfFileSystemIsReadonly(await this.withProvider(resource), resource);\n\n\t\t// Validate trash support\n\t\tconst useTrash = !!options?.useTrash;\n\t\tif (useTrash && !(provider.capabilities & FileSystemProviderCapabilities.Trash)) {\n\t\t\tthrow new Error(localize('deleteFailedTrashUnsupported', \"Unable to delete file '{0}' via trash because provider does not support it.\", this.resourceForError(resource)));\n\t\t}\n\n\t\t// Validate atomic support\n\t\tconst atomic = options?.atomic;\n\t\tif (atomic && !(provider.capabilities & FileSystemProviderCapabilities.FileAtomicDelete)) {\n\t\t\tthrow new Error(localize('deleteFailedAtomicUnsupported', \"Unable to delete file '{0}' atomically because provider does not support it.\", this.resourceForError(resource)));\n\t\t}\n\n\t\tif (useTrash && atomic) {\n\t\t\tthrow new Error(localize('deleteFailedTrashAndAtomicUnsupported', \"Unable to atomically delete file '{0}' because using trash is enabled.\", this.resourceForError(resource)));\n\t\t}\n\n\t\t// Validate delete\n\t\tlet stat: IStat | undefined = undefined;\n\t\ttry {\n\t\t\tstat = await provider.stat(resource);\n\t\t} catch (error) {\n\t\t\t// Handled later\n\t\t}\n\n\t\tif (stat) {\n\t\t\tthis.throwIfFileIsReadonly(resource, stat);\n\t\t} else {\n\t\t\tthrow new FileOperationError(localize('deleteFailedNotFound', \"Unable to delete nonexistent file '{0}'\", this.resourceForError(resource)), FileOperationResult.FILE_NOT_FOUND);\n\t\t}\n\n\t\t// Validate recursive\n\t\tconst recursive = !!options?.recursive;\n\t\tif (!recursive) {\n\t\t\tconst stat = await this.resolve(resource);\n\t\t\tif (stat.isDirectory && Array.isArray(stat.children) && stat.children.length > 0) {\n\t\t\t\tthrow new Error(localize('deleteFailedNonEmptyFolder', \"Unable to delete non-empty folder '{0}'.\", this.resourceForError(resource)));\n\t\t\t}\n\t\t}\n\n\t\treturn provider;\n\t}\n\n\tasync del(resource: URI, options?: Partial<IFileDeleteOptions>): Promise<void> {\n\t\tconst provider = await this.doValidateDelete(resource, options);\n\n\t\tlet deleteFileOptions = options;\n\t\tif (hasFileAtomicDeleteCapability(provider) && !deleteFileOptions?.atomic) {\n\t\t\tconst enforcedAtomicDelete = provider.enforceAtomicDelete?.(resource);\n\t\t\tif (enforcedAtomicDelete) {\n\t\t\t\tdeleteFileOptions = { ...options, atomic: enforcedAtomicDelete };\n\t\t\t}\n\t\t}\n\n\t\tconst useTrash = !!deleteFileOptions?.useTrash;\n\t\tconst recursive = !!deleteFileOptions?.recursive;\n\t\tconst atomic = deleteFileOptions?.atomic ?? false;\n\n\t\t// Delete through provider\n\t\tawait provider.delete(resource, { recursive, useTrash, atomic });\n\n\t\t// Events\n\t\tthis._onDidRunOperation.fire(new FileOperationEvent(resource, FileOperation.DELETE));\n\t}\n\n\t//#endregion\n\n\t//#region Clone File\n\n\tasync cloneFile(source: URI, target: URI): Promise<void> {\n\t\tconst sourceProvider = await this.withProvider(source);\n\t\tconst targetProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(target), target);\n\n\t\tif (sourceProvider === targetProvider && this.getExtUri(sourceProvider).providerExtUri.isEqual(source, target)) {\n\t\t\treturn; // return early if paths are equal\n\t\t}\n\n\t\t// same provider, use `cloneFile` when native support is provided\n\t\tif (sourceProvider === targetProvider && hasFileCloneCapability(sourceProvider)) {\n\t\t\treturn sourceProvider.cloneFile(source, target);\n\t\t}\n\n\t\t// otherwise, either providers are different or there is no native\n\t\t// `cloneFile` support, then we fallback to emulate a clone as best\n\t\t// as we can with the other primitives\n\n\t\t// create parent folders\n\t\tawait this.mkdirp(targetProvider, this.getExtUri(targetProvider).providerExtUri.dirname(target));\n\n\t\t// leverage `copy` method if provided and providers are identical\n\t\t// queue on the source to ensure atomic read\n\t\tif (sourceProvider === targetProvider && hasFileFolderCopyCapability(sourceProvider)) {\n\t\t\treturn this.writeQueue.queueFor(source, () => sourceProvider.copy(source, target, { overwrite: true }), this.getExtUri(sourceProvider).providerExtUri);\n\t\t}\n\n\t\t// otherwise copy via buffer/unbuffered and use a write queue\n\t\t// on the source to ensure atomic operation as much as possible\n\t\treturn this.writeQueue.queueFor(source, () => this.doCopyFile(sourceProvider, source, targetProvider, target), this.getExtUri(sourceProvider).providerExtUri);\n\t}\n\n\t//#endregion\n\n\t//#region File Watching\n\n\tprivate readonly internalOnDidFilesChange = this._register(new Emitter<FileChangesEvent>());\n\n\tprivate readonly _onDidUncorrelatedFilesChange = this._register(new Emitter<FileChangesEvent>());\n\treadonly onDidFilesChange = this._onDidUncorrelatedFilesChange.event; // global `onDidFilesChange` skips correlated events\n\n\tprivate readonly _onDidWatchError = this._register(new Emitter<Error>());\n\treadonly onDidWatchError = this._onDidWatchError.event;\n\n\tprivate readonly activeWatchers = new Map<number /* watch request hash */, { disposable: IDisposable; count: number }>();\n\n\tprivate static WATCHER_CORRELATION_IDS = 0;\n\n\tcreateWatcher(resource: URI, options: IWatchOptionsWithoutCorrelation): IFileSystemWatcher {\n\t\treturn this.watch(resource, {\n\t\t\t...options,\n\t\t\t// Explicitly set a correlation id so that file events that originate\n\t\t\t// from requests from extensions are exclusively routed back to the\n\t\t\t// extension host and not into the workbench.\n\t\t\tcorrelationId: FileService.WATCHER_CORRELATION_IDS++\n\t\t});\n\t}\n\n\twatch(resource: URI, options: IWatchOptionsWithCorrelation): IFileSystemWatcher;\n\twatch(resource: URI, options?: IWatchOptionsWithoutCorrelation): IDisposable;\n\twatch(resource: URI, options: IWatchOptions = { recursive: false, excludes: [] }): IFileSystemWatcher | IDisposable {\n\t\tconst disposables = new DisposableStore();\n\n\t\t// Forward watch request to provider and wire in disposables\n\t\tlet watchDisposed = false;\n\t\tlet disposeWatch = () => { watchDisposed = true; };\n\t\tdisposables.add(toDisposable(() => disposeWatch()));\n\n\t\t// Watch and wire in disposable which is async but\n\t\t// check if we got disposed meanwhile and forward\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tconst disposable = await this.doWatch(resource, options);\n\t\t\t\tif (watchDisposed) {\n\t\t\t\t\tdispose(disposable);\n\t\t\t\t} else {\n\t\t\t\t\tdisposeWatch = () => dispose(disposable);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.error(error);\n\t\t\t}\n\t\t})();\n\n\t\t// When a correlation identifier is set, return a specific\n\t\t// watcher that only emits events matching that correalation.\n\t\tconst correlationId = options.correlationId;\n\t\tif (typeof correlationId === 'number') {\n\t\t\tconst fileChangeEmitter = disposables.add(new Emitter<FileChangesEvent>());\n\t\t\tdisposables.add(this.internalOnDidFilesChange.event(e => {\n\t\t\t\tif (e.correlates(correlationId)) {\n\t\t\t\t\tfileChangeEmitter.fire(e);\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tconst watcher: IFileSystemWatcher = {\n\t\t\t\tonDidChange: fileChangeEmitter.event,\n\t\t\t\tdispose: () => disposables.dispose()\n\t\t\t};\n\n\t\t\treturn watcher;\n\t\t}\n\n\t\treturn disposables;\n\t}\n\n\tprivate async doWatch(resource: URI, options: IWatchOptions): Promise<IDisposable> {\n\t\tconst provider = await this.withProvider(resource);\n\n\t\t// Deduplicate identical watch requests\n\t\tconst watchHash = hash([this.getExtUri(provider).providerExtUri.getComparisonKey(resource), options]);\n\t\tlet watcher = this.activeWatchers.get(watchHash);\n\t\tif (!watcher) {\n\t\t\twatcher = {\n\t\t\t\tcount: 0,\n\t\t\t\tdisposable: provider.watch(resource, options)\n\t\t\t};\n\n\t\t\tthis.activeWatchers.set(watchHash, watcher);\n\t\t}\n\n\t\t// Increment usage counter\n\t\twatcher.count += 1;\n\n\t\treturn toDisposable(() => {\n\t\t\tif (watcher) {\n\n\t\t\t\t// Unref\n\t\t\t\twatcher.count--;\n\n\t\t\t\t// Dispose only when last user is reached\n\t\t\t\tif (watcher.count === 0) {\n\t\t\t\t\tdispose(watcher.disposable);\n\t\t\t\t\tthis.activeWatchers.delete(watchHash);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\tfor (const [, watcher] of this.activeWatchers) {\n\t\t\tdispose(watcher.disposable);\n\t\t}\n\n\t\tthis.activeWatchers.clear();\n\t}\n\n\t//#endregion\n\n\t//#region Helpers\n\n\tprivate readonly writeQueue = this._register(new ResourceQueue());\n\n\tprivate async doWriteBuffered(provider: IFileSystemProviderWithOpenReadWriteCloseCapability, resource: URI, options: IWriteFileOptions | undefined, readableOrStreamOrBufferedStream: VSBufferReadable | VSBufferReadableStream | VSBufferReadableBufferedStream): Promise<void> {\n\t\treturn this.writeQueue.queueFor(resource, async () => {\n\n\t\t\t// open handle\n\t\t\tconst handle = await provider.open(resource, { create: true, unlock: options?.unlock ?? false });\n\n\t\t\t// write into handle until all bytes from buffer have been written\n\t\t\ttry {\n\t\t\t\tif (isReadableStream(readableOrStreamOrBufferedStream) || isReadableBufferedStream(readableOrStreamOrBufferedStream)) {\n\t\t\t\t\tawait this.doWriteStreamBufferedQueued(provider, handle, readableOrStreamOrBufferedStream);\n\t\t\t\t} else {\n\t\t\t\t\tawait this.doWriteReadableBufferedQueued(provider, handle, readableOrStreamOrBufferedStream);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tthrow ensureFileSystemProviderError(error);\n\t\t\t} finally {\n\n\t\t\t\t// close handle always\n\t\t\t\tawait provider.close(handle);\n\t\t\t}\n\t\t}, this.getExtUri(provider).providerExtUri);\n\t}\n\n\tprivate async doWriteStreamBufferedQueued(provider: IFileSystemProviderWithOpenReadWriteCloseCapability, handle: number, streamOrBufferedStream: VSBufferReadableStream | VSBufferReadableBufferedStream): Promise<void> {\n\t\tlet posInFile = 0;\n\t\tlet stream: VSBufferReadableStream;\n\n\t\t// Buffered stream: consume the buffer first by writing\n\t\t// it to the target before reading from the stream.\n\t\tif (isReadableBufferedStream(streamOrBufferedStream)) {\n\t\t\tif (streamOrBufferedStream.buffer.length > 0) {\n\t\t\t\tconst chunk = VSBuffer.concat(streamOrBufferedStream.buffer);\n\t\t\t\tawait this.doWriteBuffer(provider, handle, chunk, chunk.byteLength, posInFile, 0);\n\n\t\t\t\tposInFile += chunk.byteLength;\n\t\t\t}\n\n\t\t\t// If the stream has been consumed, return early\n\t\t\tif (streamOrBufferedStream.ended) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tstream = streamOrBufferedStream.stream;\n\t\t}\n\n\t\t// Unbuffered stream - just take as is\n\t\telse {\n\t\t\tstream = streamOrBufferedStream;\n\t\t}\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tlistenStream(stream, {\n\t\t\t\tonData: async chunk => {\n\n\t\t\t\t\t// pause stream to perform async write operation\n\t\t\t\t\tstream.pause();\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait this.doWriteBuffer(provider, handle, chunk, chunk.byteLength, posInFile, 0);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\treturn reject(error);\n\t\t\t\t\t}\n\n\t\t\t\t\tposInFile += chunk.byteLength;\n\n\t\t\t\t\t// resume stream now that we have successfully written\n\t\t\t\t\t// run this on the next tick to prevent increasing the\n\t\t\t\t\t// execution stack because resume() may call the event\n\t\t\t\t\t// handler again before finishing.\n\t\t\t\t\tsetTimeout(() => stream.resume());\n\t\t\t\t},\n\t\t\t\tonError: error => reject(error),\n\t\t\t\tonEnd: () => resolve()\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate async doWriteReadableBufferedQueued(provider: IFileSystemProviderWithOpenReadWriteCloseCapability, handle: number, readable: VSBufferReadable): Promise<void> {\n\t\tlet posInFile = 0;\n\n\t\tlet chunk: VSBuffer | null;\n\t\twhile ((chunk = readable.read()) !== null) {\n\t\t\tawait this.doWriteBuffer(provider, handle, chunk, chunk.byteLength, posInFile, 0);\n\n\t\t\tposInFile += chunk.byteLength;\n\t\t}\n\t}\n\n\tprivate async doWriteBuffer(provider: IFileSystemProviderWithOpenReadWriteCloseCapability, handle: number, buffer: VSBuffer, length: number, posInFile: number, posInBuffer: number): Promise<void> {\n\t\tlet totalBytesWritten = 0;\n\t\twhile (totalBytesWritten < length) {\n\n\t\t\t// Write through the provider\n\t\t\tconst bytesWritten = await provider.write(handle, posInFile + totalBytesWritten, buffer.buffer, posInBuffer + totalBytesWritten, length - totalBytesWritten);\n\t\t\ttotalBytesWritten += bytesWritten;\n\t\t}\n\t}\n\n\tprivate async doWriteUnbuffered(provider: IFileSystemProviderWithFileReadWriteCapability, resource: URI, options: IWriteFileOptions | undefined, bufferOrReadableOrStreamOrBufferedStream: VSBuffer | VSBufferReadable | VSBufferReadableStream | VSBufferReadableBufferedStream): Promise<void> {\n\t\treturn this.writeQueue.queueFor(resource, () => this.doWriteUnbufferedQueued(provider, resource, options, bufferOrReadableOrStreamOrBufferedStream), this.getExtUri(provider).providerExtUri);\n\t}\n\n\tprivate async doWriteUnbufferedQueued(provider: IFileSystemProviderWithFileReadWriteCapability, resource: URI, options: IWriteFileOptions | undefined, bufferOrReadableOrStreamOrBufferedStream: VSBuffer | VSBufferReadable | VSBufferReadableStream | VSBufferReadableBufferedStream): Promise<void> {\n\t\tlet buffer: VSBuffer;\n\t\tif (bufferOrReadableOrStreamOrBufferedStream instanceof VSBuffer) {\n\t\t\tbuffer = bufferOrReadableOrStreamOrBufferedStream;\n\t\t} else if (isReadableStream(bufferOrReadableOrStreamOrBufferedStream)) {\n\t\t\tbuffer = await streamToBuffer(bufferOrReadableOrStreamOrBufferedStream);\n\t\t} else if (isReadableBufferedStream(bufferOrReadableOrStreamOrBufferedStream)) {\n\t\t\tbuffer = await bufferedStreamToBuffer(bufferOrReadableOrStreamOrBufferedStream);\n\t\t} else {\n\t\t\tbuffer = readableToBuffer(bufferOrReadableOrStreamOrBufferedStream);\n\t\t}\n\n\t\t// Write through the provider\n\t\tawait provider.writeFile(resource, buffer.buffer, { create: true, overwrite: true, unlock: options?.unlock ?? false, atomic: options?.atomic ?? false });\n\t}\n\n\tprivate async doPipeBuffered(sourceProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, source: URI, targetProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\n\t\treturn this.writeQueue.queueFor(target, () => this.doPipeBufferedQueued(sourceProvider, source, targetProvider, target), this.getExtUri(targetProvider).providerExtUri);\n\t}\n\n\tprivate async doPipeBufferedQueued(sourceProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, source: URI, targetProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\n\t\tlet sourceHandle: number | undefined = undefined;\n\t\tlet targetHandle: number | undefined = undefined;\n\n\t\ttry {\n\n\t\t\t// Open handles\n\t\t\tsourceHandle = await sourceProvider.open(source, { create: false });\n\t\t\ttargetHandle = await targetProvider.open(target, { create: true, unlock: false });\n\n\t\t\tconst buffer = VSBuffer.alloc(this.BUFFER_SIZE);\n\n\t\t\tlet posInFile = 0;\n\t\t\tlet posInBuffer = 0;\n\t\t\tlet bytesRead = 0;\n\t\t\tdo {\n\t\t\t\t// read from source (sourceHandle) at current position (posInFile) into buffer (buffer) at\n\t\t\t\t// buffer position (posInBuffer) up to the size of the buffer (buffer.byteLength).\n\t\t\t\tbytesRead = await sourceProvider.read(sourceHandle, posInFile, buffer.buffer, posInBuffer, buffer.byteLength - posInBuffer);\n\n\t\t\t\t// write into target (targetHandle) at current position (posInFile) from buffer (buffer) at\n\t\t\t\t// buffer position (posInBuffer) all bytes we read (bytesRead).\n\t\t\t\tawait this.doWriteBuffer(targetProvider, targetHandle, buffer, bytesRead, posInFile, posInBuffer);\n\n\t\t\t\tposInFile += bytesRead;\n\t\t\t\tposInBuffer += bytesRead;\n\n\t\t\t\t// when buffer full, fill it again from the beginning\n\t\t\t\tif (posInBuffer === buffer.byteLength) {\n\t\t\t\t\tposInBuffer = 0;\n\t\t\t\t}\n\t\t\t} while (bytesRead > 0);\n\t\t} catch (error) {\n\t\t\tthrow ensureFileSystemProviderError(error);\n\t\t} finally {\n\t\t\tawait Promises.settled([\n\t\t\t\ttypeof sourceHandle === 'number' ? sourceProvider.close(sourceHandle) : Promise.resolve(),\n\t\t\t\ttypeof targetHandle === 'number' ? targetProvider.close(targetHandle) : Promise.resolve(),\n\t\t\t]);\n\t\t}\n\t}\n\n\tprivate async doPipeUnbuffered(sourceProvider: IFileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: IFileSystemProviderWithFileReadWriteCapability, target: URI): Promise<void> {\n\t\treturn this.writeQueue.queueFor(target, () => this.doPipeUnbufferedQueued(sourceProvider, source, targetProvider, target), this.getExtUri(targetProvider).providerExtUri);\n\t}\n\n\tprivate async doPipeUnbufferedQueued(sourceProvider: IFileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: IFileSystemProviderWithFileReadWriteCapability, target: URI): Promise<void> {\n\t\treturn targetProvider.writeFile(target, await sourceProvider.readFile(source), { create: true, overwrite: true, unlock: false, atomic: false });\n\t}\n\n\tprivate async doPipeUnbufferedToBuffered(sourceProvider: IFileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\n\t\treturn this.writeQueue.queueFor(target, () => this.doPipeUnbufferedToBufferedQueued(sourceProvider, source, targetProvider, target), this.getExtUri(targetProvider).providerExtUri);\n\t}\n\n\tprivate async doPipeUnbufferedToBufferedQueued(sourceProvider: IFileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\n\n\t\t// Open handle\n\t\tconst targetHandle = await targetProvider.open(target, { create: true, unlock: false });\n\n\t\t// Read entire buffer from source and write buffered\n\t\ttry {\n\t\t\tconst buffer = await sourceProvider.readFile(source);\n\t\t\tawait this.doWriteBuffer(targetProvider, targetHandle, VSBuffer.wrap(buffer), buffer.byteLength, 0, 0);\n\t\t} catch (error) {\n\t\t\tthrow ensureFileSystemProviderError(error);\n\t\t} finally {\n\t\t\tawait targetProvider.close(targetHandle);\n\t\t}\n\t}\n\n\tprivate async doPipeBufferedToUnbuffered(sourceProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, source: URI, targetProvider: IFileSystemProviderWithFileReadWriteCapability, target: URI): Promise<void> {\n\n\t\t// Read buffer via stream buffered\n\t\tconst buffer = await streamToBuffer(this.readFileBuffered(sourceProvider, source, CancellationToken.None));\n\n\t\t// Write buffer into target at once\n\t\tawait this.doWriteUnbuffered(targetProvider, target, undefined, buffer);\n\t}\n\n\tprotected throwIfFileSystemIsReadonly<T extends IFileSystemProvider>(provider: T, resource: URI): T {\n\t\tif (provider.capabilities & FileSystemProviderCapabilities.Readonly) {\n\t\t\tthrow new FileOperationError(localize('err.readonly', \"Unable to modify read-only file '{0}'\", this.resourceForError(resource)), FileOperationResult.FILE_PERMISSION_DENIED);\n\t\t}\n\n\t\treturn provider;\n\t}\n\n\tprivate throwIfFileIsReadonly(resource: URI, stat: IStat): void {\n\t\tif ((stat.permissions ?? 0) & FilePermission.Readonly) {\n\t\t\tthrow new FileOperationError(localize('err.readonly', \"Unable to modify read-only file '{0}'\", this.resourceForError(resource)), FileOperationResult.FILE_PERMISSION_DENIED);\n\t\t}\n\t}\n\n\tprivate resourceForError(resource: URI): string {\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\treturn resource.fsPath;\n\t\t}\n\n\t\treturn resource.toString(true);\n\t}\n\n\t//#endregion\n}\n"],
  "mappings": "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",
  "names": ["stat"]
}
