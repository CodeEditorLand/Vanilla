{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/files/common/io.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { canceled } from '../../../base/common/errors.js';\nimport { IDataTransformer, IErrorTransformer, WriteableStream } from '../../../base/common/stream.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { localize } from '../../../nls.js';\nimport { createFileSystemProviderError, ensureFileSystemProviderError, IFileReadStreamOptions, FileSystemProviderErrorCode, IFileSystemProviderWithOpenReadWriteCloseCapability } from './files.js';\n\nexport interface ICreateReadStreamOptions extends IFileReadStreamOptions {\n\n\t/**\n\t * The size of the buffer to use before sending to the stream.\n\t */\n\treadonly bufferSize: number;\n\n\t/**\n\t * Allows to massage any possibly error that happens during reading.\n\t */\n\treadonly errorTransformer?: IErrorTransformer;\n}\n\n/**\n * A helper to read a file from a provider with open/read/close capability into a stream.\n */\nexport async function readFileIntoStream<T>(\n\tprovider: IFileSystemProviderWithOpenReadWriteCloseCapability,\n\tresource: URI,\n\ttarget: WriteableStream<T>,\n\ttransformer: IDataTransformer<VSBuffer, T>,\n\toptions: ICreateReadStreamOptions,\n\ttoken: CancellationToken\n): Promise<void> {\n\tlet error: Error | undefined = undefined;\n\n\ttry {\n\t\tawait doReadFileIntoStream(provider, resource, target, transformer, options, token);\n\t} catch (err) {\n\t\terror = err;\n\t} finally {\n\t\tif (error && options.errorTransformer) {\n\t\t\terror = options.errorTransformer(error);\n\t\t}\n\n\t\tif (typeof error !== 'undefined') {\n\t\t\ttarget.error(error);\n\t\t}\n\n\t\ttarget.end();\n\t}\n}\n\nasync function doReadFileIntoStream<T>(provider: IFileSystemProviderWithOpenReadWriteCloseCapability, resource: URI, target: WriteableStream<T>, transformer: IDataTransformer<VSBuffer, T>, options: ICreateReadStreamOptions, token: CancellationToken): Promise<void> {\n\n\t// Check for cancellation\n\tthrowIfCancelled(token);\n\n\t// open handle through provider\n\tconst handle = await provider.open(resource, { create: false });\n\n\ttry {\n\n\t\t// Check for cancellation\n\t\tthrowIfCancelled(token);\n\n\t\tlet totalBytesRead = 0;\n\t\tlet bytesRead = 0;\n\t\tlet allowedRemainingBytes = (options && typeof options.length === 'number') ? options.length : undefined;\n\n\t\tlet buffer = VSBuffer.alloc(Math.min(options.bufferSize, typeof allowedRemainingBytes === 'number' ? allowedRemainingBytes : options.bufferSize));\n\n\t\tlet posInFile = options && typeof options.position === 'number' ? options.position : 0;\n\t\tlet posInBuffer = 0;\n\t\tdo {\n\t\t\t// read from source (handle) at current position (pos) into buffer (buffer) at\n\t\t\t// buffer position (posInBuffer) up to the size of the buffer (buffer.byteLength).\n\t\t\tbytesRead = await provider.read(handle, posInFile, buffer.buffer, posInBuffer, buffer.byteLength - posInBuffer);\n\n\t\t\tposInFile += bytesRead;\n\t\t\tposInBuffer += bytesRead;\n\t\t\ttotalBytesRead += bytesRead;\n\n\t\t\tif (typeof allowedRemainingBytes === 'number') {\n\t\t\t\tallowedRemainingBytes -= bytesRead;\n\t\t\t}\n\n\t\t\t// when buffer full, create a new one and emit it through stream\n\t\t\tif (posInBuffer === buffer.byteLength) {\n\t\t\t\tawait target.write(transformer(buffer));\n\n\t\t\t\tbuffer = VSBuffer.alloc(Math.min(options.bufferSize, typeof allowedRemainingBytes === 'number' ? allowedRemainingBytes : options.bufferSize));\n\n\t\t\t\tposInBuffer = 0;\n\t\t\t}\n\t\t} while (bytesRead > 0 && (typeof allowedRemainingBytes !== 'number' || allowedRemainingBytes > 0) && throwIfCancelled(token) && throwIfTooLarge(totalBytesRead, options));\n\n\t\t// wrap up with last buffer (also respect maxBytes if provided)\n\t\tif (posInBuffer > 0) {\n\t\t\tlet lastChunkLength = posInBuffer;\n\t\t\tif (typeof allowedRemainingBytes === 'number') {\n\t\t\t\tlastChunkLength = Math.min(posInBuffer, allowedRemainingBytes);\n\t\t\t}\n\n\t\t\ttarget.write(transformer(buffer.slice(0, lastChunkLength)));\n\t\t}\n\t} catch (error) {\n\t\tthrow ensureFileSystemProviderError(error);\n\t} finally {\n\t\tawait provider.close(handle);\n\t}\n}\n\nfunction throwIfCancelled(token: CancellationToken): boolean {\n\tif (token.isCancellationRequested) {\n\t\tthrow canceled();\n\t}\n\n\treturn true;\n}\n\nfunction throwIfTooLarge(totalBytesRead: number, options: ICreateReadStreamOptions): boolean {\n\n\t// Return early if file is too large to load and we have configured limits\n\tif (typeof options?.limits?.size === 'number' && totalBytesRead > options.limits.size) {\n\t\tthrow createFileSystemProviderError(localize('fileTooLargeError', \"File is too large to open\"), FileSystemProviderErrorCode.FileTooLarge);\n\t}\n\n\treturn true;\n}\n"],
  "mappings": ";;AAKA,SAAS,gBAAgB;AACzB,SAAS,yBAAyB;AAClC,SAAS,gBAAgB;AACzB,SAAS,kBAAkB,mBAAmB,uBAAuB;AACrE,SAAS,WAAW;AACpB,SAAS,gBAAgB;AACzB,SAAS,+BAA+B,+BAA+B,wBAAwB,6BAA6B,2DAA2D;AAkBvL,eAAsB,mBACrB,UACA,UACA,QACA,aACA,SACA,OACgB;AAChB,MAAI,QAA2B;AAE/B,MAAI;AACH,UAAM,qBAAqB,UAAU,UAAU,QAAQ,aAAa,SAAS,KAAK;AAAA,EACnF,SAAS,KAAK;AACb,YAAQ;AAAA,EACT,UAAE;AACD,QAAI,SAAS,QAAQ,kBAAkB;AACtC,cAAQ,QAAQ,iBAAiB,KAAK;AAAA,IACvC;AAEA,QAAI,OAAO,UAAU,aAAa;AACjC,aAAO,MAAM,KAAK;AAAA,IACnB;AAEA,WAAO,IAAI;AAAA,EACZ;AACD;AAzBsB;AA2BtB,eAAe,qBAAwB,UAA+D,UAAe,QAA4B,aAA4C,SAAmC,OAAyC;AAGxQ,mBAAiB,KAAK;AAGtB,QAAM,SAAS,MAAM,SAAS,KAAK,UAAU,EAAE,QAAQ,MAAM,CAAC;AAE9D,MAAI;AAGH,qBAAiB,KAAK;AAEtB,QAAI,iBAAiB;AACrB,QAAI,YAAY;AAChB,QAAI,wBAAyB,WAAW,OAAO,QAAQ,WAAW,WAAY,QAAQ,SAAS;AAE/F,QAAI,SAAS,SAAS,MAAM,KAAK,IAAI,QAAQ,YAAY,OAAO,0BAA0B,WAAW,wBAAwB,QAAQ,UAAU,CAAC;AAEhJ,QAAI,YAAY,WAAW,OAAO,QAAQ,aAAa,WAAW,QAAQ,WAAW;AACrF,QAAI,cAAc;AAClB,OAAG;AAGF,kBAAY,MAAM,SAAS,KAAK,QAAQ,WAAW,OAAO,QAAQ,aAAa,OAAO,aAAa,WAAW;AAE9G,mBAAa;AACb,qBAAe;AACf,wBAAkB;AAElB,UAAI,OAAO,0BAA0B,UAAU;AAC9C,iCAAyB;AAAA,MAC1B;AAGA,UAAI,gBAAgB,OAAO,YAAY;AACtC,cAAM,OAAO,MAAM,YAAY,MAAM,CAAC;AAEtC,iBAAS,SAAS,MAAM,KAAK,IAAI,QAAQ,YAAY,OAAO,0BAA0B,WAAW,wBAAwB,QAAQ,UAAU,CAAC;AAE5I,sBAAc;AAAA,MACf;AAAA,IACD,SAAS,YAAY,MAAM,OAAO,0BAA0B,YAAY,wBAAwB,MAAM,iBAAiB,KAAK,KAAK,gBAAgB,gBAAgB,OAAO;AAGxK,QAAI,cAAc,GAAG;AACpB,UAAI,kBAAkB;AACtB,UAAI,OAAO,0BAA0B,UAAU;AAC9C,0BAAkB,KAAK,IAAI,aAAa,qBAAqB;AAAA,MAC9D;AAEA,aAAO,MAAM,YAAY,OAAO,MAAM,GAAG,eAAe,CAAC,CAAC;AAAA,IAC3D;AAAA,EACD,SAAS,OAAO;AACf,UAAM,8BAA8B,KAAK;AAAA,EAC1C,UAAE;AACD,UAAM,SAAS,MAAM,MAAM;AAAA,EAC5B;AACD;AA1De;AA4Df,SAAS,iBAAiB,OAAmC;AAC5D,MAAI,MAAM,yBAAyB;AAClC,UAAM,SAAS;AAAA,EAChB;AAEA,SAAO;AACR;AANS;AAQT,SAAS,gBAAgB,gBAAwB,SAA4C;AAG5F,MAAI,OAAO,SAAS,QAAQ,SAAS,YAAY,iBAAiB,QAAQ,OAAO,MAAM;AACtF,UAAM,8BAA8B,SAAS,qBAAqB,2BAA2B,GAAG,4BAA4B,YAAY;AAAA,EACzI;AAEA,SAAO;AACR;AARS;",
  "names": []
}
