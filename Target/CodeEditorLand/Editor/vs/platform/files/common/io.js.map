{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/files/common/io.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { VSBuffer } from \"../../../base/common/buffer.js\";\nimport type { CancellationToken } from \"../../../base/common/cancellation.js\";\nimport { canceled } from \"../../../base/common/errors.js\";\nimport type {\n\tIDataTransformer,\n\tIErrorTransformer,\n\tWriteableStream,\n} from \"../../../base/common/stream.js\";\nimport type { URI } from \"../../../base/common/uri.js\";\nimport { localize } from \"../../../nls.js\";\nimport {\n\tFileSystemProviderErrorCode,\n\ttype IFileReadStreamOptions,\n\ttype IFileSystemProviderWithOpenReadWriteCloseCapability,\n\tcreateFileSystemProviderError,\n\tensureFileSystemProviderError,\n} from \"./files.js\";\n\nexport interface ICreateReadStreamOptions extends IFileReadStreamOptions {\n\t/**\n\t * The size of the buffer to use before sending to the stream.\n\t */\n\treadonly bufferSize: number;\n\n\t/**\n\t * Allows to massage any possibly error that happens during reading.\n\t */\n\treadonly errorTransformer?: IErrorTransformer;\n}\n\n/**\n * A helper to read a file from a provider with open/read/close capability into a stream.\n */\nexport async function readFileIntoStream<T>(\n\tprovider: IFileSystemProviderWithOpenReadWriteCloseCapability,\n\tresource: URI,\n\ttarget: WriteableStream<T>,\n\ttransformer: IDataTransformer<VSBuffer, T>,\n\toptions: ICreateReadStreamOptions,\n\ttoken: CancellationToken,\n): Promise<void> {\n\tlet error: Error | undefined;\n\n\ttry {\n\t\tawait doReadFileIntoStream(\n\t\t\tprovider,\n\t\t\tresource,\n\t\t\ttarget,\n\t\t\ttransformer,\n\t\t\toptions,\n\t\t\ttoken,\n\t\t);\n\t} catch (err) {\n\t\terror = err;\n\t} finally {\n\t\tif (error && options.errorTransformer) {\n\t\t\terror = options.errorTransformer(error);\n\t\t}\n\n\t\tif (typeof error !== \"undefined\") {\n\t\t\ttarget.error(error);\n\t\t}\n\n\t\ttarget.end();\n\t}\n}\n\nasync function doReadFileIntoStream<T>(\n\tprovider: IFileSystemProviderWithOpenReadWriteCloseCapability,\n\tresource: URI,\n\ttarget: WriteableStream<T>,\n\ttransformer: IDataTransformer<VSBuffer, T>,\n\toptions: ICreateReadStreamOptions,\n\ttoken: CancellationToken,\n): Promise<void> {\n\t// Check for cancellation\n\tthrowIfCancelled(token);\n\n\t// open handle through provider\n\tconst handle = await provider.open(resource, { create: false });\n\n\ttry {\n\t\t// Check for cancellation\n\t\tthrowIfCancelled(token);\n\n\t\tlet totalBytesRead = 0;\n\t\tlet bytesRead = 0;\n\t\tlet allowedRemainingBytes =\n\t\t\toptions && typeof options.length === \"number\"\n\t\t\t\t? options.length\n\t\t\t\t: undefined;\n\n\t\tlet buffer = VSBuffer.alloc(\n\t\t\tMath.min(\n\t\t\t\toptions.bufferSize,\n\t\t\t\ttypeof allowedRemainingBytes === \"number\"\n\t\t\t\t\t? allowedRemainingBytes\n\t\t\t\t\t: options.bufferSize,\n\t\t\t),\n\t\t);\n\n\t\tlet posInFile =\n\t\t\toptions && typeof options.position === \"number\"\n\t\t\t\t? options.position\n\t\t\t\t: 0;\n\t\tlet posInBuffer = 0;\n\t\tdo {\n\t\t\t// read from source (handle) at current position (pos) into buffer (buffer) at\n\t\t\t// buffer position (posInBuffer) up to the size of the buffer (buffer.byteLength).\n\t\t\tbytesRead = await provider.read(\n\t\t\t\thandle,\n\t\t\t\tposInFile,\n\t\t\t\tbuffer.buffer,\n\t\t\t\tposInBuffer,\n\t\t\t\tbuffer.byteLength - posInBuffer,\n\t\t\t);\n\n\t\t\tposInFile += bytesRead;\n\t\t\tposInBuffer += bytesRead;\n\t\t\ttotalBytesRead += bytesRead;\n\n\t\t\tif (typeof allowedRemainingBytes === \"number\") {\n\t\t\t\tallowedRemainingBytes -= bytesRead;\n\t\t\t}\n\n\t\t\t// when buffer full, create a new one and emit it through stream\n\t\t\tif (posInBuffer === buffer.byteLength) {\n\t\t\t\tawait target.write(transformer(buffer));\n\n\t\t\t\tbuffer = VSBuffer.alloc(\n\t\t\t\t\tMath.min(\n\t\t\t\t\t\toptions.bufferSize,\n\t\t\t\t\t\ttypeof allowedRemainingBytes === \"number\"\n\t\t\t\t\t\t\t? allowedRemainingBytes\n\t\t\t\t\t\t\t: options.bufferSize,\n\t\t\t\t\t),\n\t\t\t\t);\n\n\t\t\t\tposInBuffer = 0;\n\t\t\t}\n\t\t} while (\n\t\t\tbytesRead > 0 &&\n\t\t\t(typeof allowedRemainingBytes !== \"number\" ||\n\t\t\t\tallowedRemainingBytes > 0) &&\n\t\t\tthrowIfCancelled(token) &&\n\t\t\tthrowIfTooLarge(totalBytesRead, options)\n\t\t);\n\n\t\t// wrap up with last buffer (also respect maxBytes if provided)\n\t\tif (posInBuffer > 0) {\n\t\t\tlet lastChunkLength = posInBuffer;\n\t\t\tif (typeof allowedRemainingBytes === \"number\") {\n\t\t\t\tlastChunkLength = Math.min(posInBuffer, allowedRemainingBytes);\n\t\t\t}\n\n\t\t\ttarget.write(transformer(buffer.slice(0, lastChunkLength)));\n\t\t}\n\t} catch (error) {\n\t\tthrow ensureFileSystemProviderError(error);\n\t} finally {\n\t\tawait provider.close(handle);\n\t}\n}\n\nfunction throwIfCancelled(token: CancellationToken): boolean {\n\tif (token.isCancellationRequested) {\n\t\tthrow canceled();\n\t}\n\n\treturn true;\n}\n\nfunction throwIfTooLarge(\n\ttotalBytesRead: number,\n\toptions: ICreateReadStreamOptions,\n): boolean {\n\t// Return early if file is too large to load and we have configured limits\n\tif (\n\t\ttypeof options?.limits?.size === \"number\" &&\n\t\ttotalBytesRead > options.limits.size\n\t) {\n\t\tthrow createFileSystemProviderError(\n\t\t\tlocalize(\"fileTooLargeError\", \"File is too large to open\"),\n\t\t\tFileSystemProviderErrorCode.FileTooLarge,\n\t\t);\n\t}\n\n\treturn true;\n}\n"],
  "mappings": ";;AAKA,SAAS,gBAAgB;AAEzB,SAAS,gBAAgB;AAOzB,SAAS,gBAAgB;AACzB;AAAA,EACC;AAAA,EAGA;AAAA,EACA;AAAA,OACM;AAiBP,eAAsB,mBACrB,UACA,UACA,QACA,aACA,SACA,OACgB;AAChB,MAAI;AAEJ,MAAI;AACH,UAAM;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACD;AAAA,EACD,SAAS,KAAK;AACb,YAAQ;AAAA,EACT,UAAE;AACD,QAAI,SAAS,QAAQ,kBAAkB;AACtC,cAAQ,QAAQ,iBAAiB,KAAK;AAAA,IACvC;AAEA,QAAI,OAAO,UAAU,aAAa;AACjC,aAAO,MAAM,KAAK;AAAA,IACnB;AAEA,WAAO,IAAI;AAAA,EACZ;AACD;AAhCsB;AAkCtB,eAAe,qBACd,UACA,UACA,QACA,aACA,SACA,OACgB;AAEhB,mBAAiB,KAAK;AAGtB,QAAM,SAAS,MAAM,SAAS,KAAK,UAAU,EAAE,QAAQ,MAAM,CAAC;AAE9D,MAAI;AAEH,qBAAiB,KAAK;AAEtB,QAAI,iBAAiB;AACrB,QAAI,YAAY;AAChB,QAAI,wBACH,WAAW,OAAO,QAAQ,WAAW,WAClC,QAAQ,SACR;AAEJ,QAAI,SAAS,SAAS;AAAA,MACrB,KAAK;AAAA,QACJ,QAAQ;AAAA,QACR,OAAO,0BAA0B,WAC9B,wBACA,QAAQ;AAAA,MACZ;AAAA,IACD;AAEA,QAAI,YACH,WAAW,OAAO,QAAQ,aAAa,WACpC,QAAQ,WACR;AACJ,QAAI,cAAc;AAClB,OAAG;AAGF,kBAAY,MAAM,SAAS;AAAA,QAC1B;AAAA,QACA;AAAA,QACA,OAAO;AAAA,QACP;AAAA,QACA,OAAO,aAAa;AAAA,MACrB;AAEA,mBAAa;AACb,qBAAe;AACf,wBAAkB;AAElB,UAAI,OAAO,0BAA0B,UAAU;AAC9C,iCAAyB;AAAA,MAC1B;AAGA,UAAI,gBAAgB,OAAO,YAAY;AACtC,cAAM,OAAO,MAAM,YAAY,MAAM,CAAC;AAEtC,iBAAS,SAAS;AAAA,UACjB,KAAK;AAAA,YACJ,QAAQ;AAAA,YACR,OAAO,0BAA0B,WAC9B,wBACA,QAAQ;AAAA,UACZ;AAAA,QACD;AAEA,sBAAc;AAAA,MACf;AAAA,IACD,SACC,YAAY,MACX,OAAO,0BAA0B,YACjC,wBAAwB,MACzB,iBAAiB,KAAK,KACtB,gBAAgB,gBAAgB,OAAO;AAIxC,QAAI,cAAc,GAAG;AACpB,UAAI,kBAAkB;AACtB,UAAI,OAAO,0BAA0B,UAAU;AAC9C,0BAAkB,KAAK,IAAI,aAAa,qBAAqB;AAAA,MAC9D;AAEA,aAAO,MAAM,YAAY,OAAO,MAAM,GAAG,eAAe,CAAC,CAAC;AAAA,IAC3D;AAAA,EACD,SAAS,OAAO;AACf,UAAM,8BAA8B,KAAK;AAAA,EAC1C,UAAE;AACD,UAAM,SAAS,MAAM,MAAM;AAAA,EAC5B;AACD;AA/Fe;AAiGf,SAAS,iBAAiB,OAAmC;AAC5D,MAAI,MAAM,yBAAyB;AAClC,UAAM,SAAS;AAAA,EAChB;AAEA,SAAO;AACR;AANS;AAQT,SAAS,gBACR,gBACA,SACU;AAEV,MACC,OAAO,SAAS,QAAQ,SAAS,YACjC,iBAAiB,QAAQ,OAAO,MAC/B;AACD,UAAM;AAAA,MACL,SAAS,qBAAqB,2BAA2B;AAAA,MACzD,4BAA4B;AAAA,IAC7B;AAAA,EACD;AAEA,SAAO;AACR;AAhBS;",
  "names": []
}
