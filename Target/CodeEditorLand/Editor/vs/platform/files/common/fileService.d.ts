import { VSBuffer, VSBufferReadable, VSBufferReadableStream } from "vs/base/common/buffer";
import { CancellationToken } from "vs/base/common/cancellation";
import { Iterable } from "vs/base/common/iterator";
import { Disposable, IDisposable } from "vs/base/common/lifecycle";
import { URI } from "vs/base/common/uri";
import { FileSystemProviderCapabilities, ICreateFileOptions, IFileContent, IFileDeleteOptions, IFileService, IFileStat, IFileStatResult, IFileStatResultWithMetadata, IFileStatWithMetadata, IFileStatWithPartialMetadata, IFileStreamContent, IFileSystemProvider, IFileSystemWatcher, IReadFileOptions, IReadFileStreamOptions, IResolveFileOptions, IResolveMetadataFileOptions, IWatchOptionsWithCorrelation, IWatchOptionsWithoutCorrelation, IWriteFileOptions } from "vs/platform/files/common/files";
import { ILogService } from "vs/platform/log/common/log";
export declare class FileService extends Disposable implements IFileService {
    private readonly logService;
    readonly _serviceBrand: undefined;
    private readonly BUFFER_SIZE;
    constructor(logService: ILogService);
    private readonly _onDidChangeFileSystemProviderRegistrations;
    readonly onDidChangeFileSystemProviderRegistrations: any;
    private readonly _onWillActivateFileSystemProvider;
    readonly onWillActivateFileSystemProvider: any;
    private readonly _onDidChangeFileSystemProviderCapabilities;
    readonly onDidChangeFileSystemProviderCapabilities: any;
    private readonly provider;
    registerProvider(scheme: string, provider: IFileSystemProvider): IDisposable;
    getProvider(scheme: string): IFileSystemProvider | undefined;
    activateProvider(scheme: string): Promise<void>;
    canHandleResource(resource: URI): Promise<boolean>;
    hasProvider(resource: URI): boolean;
    hasCapability(resource: URI, capability: FileSystemProviderCapabilities): boolean;
    listCapabilities(): Iterable<{
        scheme: string;
        capabilities: FileSystemProviderCapabilities;
    }>;
    protected withProvider(resource: URI): Promise<IFileSystemProvider>;
    private withReadProvider;
    private withWriteProvider;
    private readonly _onDidRunOperation;
    readonly onDidRunOperation: any;
    resolve(resource: URI, options: IResolveMetadataFileOptions): Promise<IFileStatWithMetadata>;
    resolve(resource: URI, options?: IResolveFileOptions): Promise<IFileStat>;
    private doResolveFile;
    private toFileStat;
    resolveAll(toResolve: {
        resource: URI;
        options?: IResolveFileOptions;
    }[]): Promise<IFileStatResult[]>;
    resolveAll(toResolve: {
        resource: URI;
        options: IResolveMetadataFileOptions;
    }[]): Promise<IFileStatResultWithMetadata[]>;
    stat(resource: URI): Promise<IFileStatWithPartialMetadata>;
    exists(resource: URI): Promise<boolean>;
    canCreateFile(resource: URI, options?: ICreateFileOptions): Promise<Error | true>;
    private doValidateCreateFile;
    createFile(resource: URI, bufferOrReadableOrStream?: VSBuffer | VSBufferReadable | VSBufferReadableStream, options?: ICreateFileOptions): Promise<IFileStatWithMetadata>;
    writeFile(resource: URI, bufferOrReadableOrStream: VSBuffer | VSBufferReadable | VSBufferReadableStream, options?: IWriteFileOptions): Promise<IFileStatWithMetadata>;
    private validateWriteFile;
    readFile(resource: URI, options?: IReadFileOptions, token?: CancellationToken): Promise<IFileContent>;
    private doReadFileAtomic;
    private doReadFile;
    readFileStream(resource: URI, options?: IReadFileStreamOptions, token?: CancellationToken): Promise<IFileStreamContent>;
    private doReadFileStream;
    private restoreReadError;
    private readFileStreamed;
    private readFileBuffered;
    private readFileUnbuffered;
    private validateReadFile;
    private validateReadFileLimits;
    canMove(source: URI, target: URI, overwrite?: boolean): Promise<Error | true>;
    canCopy(source: URI, target: URI, overwrite?: boolean): Promise<Error | true>;
    private doCanMoveCopy;
    move(source: URI, target: URI, overwrite?: boolean): Promise<IFileStatWithMetadata>;
    copy(source: URI, target: URI, overwrite?: boolean): Promise<IFileStatWithMetadata>;
    private doMoveCopy;
    private doCopyFile;
    private doCopyFolder;
    private doValidateMoveCopy;
    private getExtUri;
    private isPathCaseSensitive;
    createFolder(resource: URI): Promise<IFileStatWithMetadata>;
    private mkdirp;
    canDelete(resource: URI, options?: Partial<IFileDeleteOptions>): Promise<Error | true>;
    private doValidateDelete;
    del(resource: URI, options?: Partial<IFileDeleteOptions>): Promise<void>;
    cloneFile(source: URI, target: URI): Promise<void>;
    private readonly internalOnDidFilesChange;
    private readonly _onDidUncorrelatedFilesChange;
    readonly onDidFilesChange: any;
    private readonly _onDidWatchError;
    readonly onDidWatchError: any;
    private readonly activeWatchers;
    private static WATCHER_CORRELATION_IDS;
    createWatcher(resource: URI, options: IWatchOptionsWithoutCorrelation): IFileSystemWatcher;
    watch(resource: URI, options: IWatchOptionsWithCorrelation): IFileSystemWatcher;
    watch(resource: URI, options?: IWatchOptionsWithoutCorrelation): IDisposable;
    private doWatch;
    dispose(): void;
    private readonly writeQueue;
    private doWriteBuffered;
    private doWriteStreamBufferedQueued;
    private doWriteReadableBufferedQueued;
    private doWriteBuffer;
    private doWriteUnbuffered;
    private doWriteUnbufferedQueued;
    private doPipeBuffered;
    private doPipeBufferedQueued;
    private doPipeUnbuffered;
    private doPipeUnbufferedQueued;
    private doPipeUnbufferedToBuffered;
    private doPipeUnbufferedToBufferedQueued;
    private doPipeBufferedToUnbuffered;
    protected throwIfFileSystemIsReadonly<T extends IFileSystemProvider>(provider: T, resource: URI): T;
    private throwIfFileIsReadonly;
    private resourceForError;
}
