{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/files/common/watcher.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { Event } from \"../../../base/common/event.js\";\nimport {\n\tGLOBSTAR,\n\ttype IRelativePattern,\n\ttype ParsedPattern,\n\tparse,\n} from \"../../../base/common/glob.js\";\nimport {\n\tDisposable,\n\tDisposableStore,\n\ttype IDisposable,\n\tMutableDisposable,\n} from \"../../../base/common/lifecycle.js\";\nimport { isAbsolute } from \"../../../base/common/path.js\";\nimport { isLinux } from \"../../../base/common/platform.js\";\nimport { URI } from \"../../../base/common/uri.js\";\nimport {\n\tFileChangeFilter,\n\tFileChangeType,\n\ttype IFileChange,\n\tisParent,\n} from \"./files.js\";\n\ninterface IWatchRequest {\n\t/**\n\t * The path to watch.\n\t */\n\treadonly path: string;\n\n\t/**\n\t * Whether to watch recursively or not.\n\t */\n\treadonly recursive: boolean;\n\n\t/**\n\t * A set of glob patterns or paths to exclude from watching.\n\t */\n\treadonly excludes: string[];\n\n\t/**\n\t * An optional set of glob patterns or paths to include for\n\t * watching. If not provided, all paths are considered for\n\t * events.\n\t */\n\treadonly includes?: Array<string | IRelativePattern>;\n\n\t/**\n\t * If provided, file change events from the watcher that\n\t * are a result of this watch request will carry the same\n\t * id.\n\t */\n\treadonly correlationId?: number;\n\n\t/**\n\t * If provided, allows to filter the events that the watcher should consider\n\t * for emitting. If not provided, all events are emitted.\n\t *\n\t * For example, to emit added and updated events, set to:\n\t * `FileChangeFilter.ADDED | FileChangeFilter.UPDATED`.\n\t */\n\treadonly filter?: FileChangeFilter;\n}\n\nexport interface IWatchRequestWithCorrelation extends IWatchRequest {\n\treadonly correlationId: number;\n}\n\nexport function isWatchRequestWithCorrelation(\n\trequest: IWatchRequest,\n): request is IWatchRequestWithCorrelation {\n\treturn typeof request.correlationId === \"number\";\n}\n\nexport interface INonRecursiveWatchRequest extends IWatchRequest {\n\t/**\n\t * The watcher will be non-recursive.\n\t */\n\treadonly recursive: false;\n}\n\nexport interface IRecursiveWatchRequest extends IWatchRequest {\n\t/**\n\t * The watcher will be recursive.\n\t */\n\treadonly recursive: true;\n\n\t/**\n\t * @deprecated this only exists for WSL1 support and should never\n\t * be used in any other case.\n\t */\n\tpollingInterval?: number;\n}\n\nexport function isRecursiveWatchRequest(\n\trequest: IWatchRequest,\n): request is IRecursiveWatchRequest {\n\treturn request.recursive === true;\n}\n\nexport type IUniversalWatchRequest =\n\t| IRecursiveWatchRequest\n\t| INonRecursiveWatchRequest;\n\nexport interface IWatcherErrorEvent {\n\treadonly error: string;\n\treadonly request?: IUniversalWatchRequest;\n}\n\nexport interface IWatcher {\n\t/**\n\t * A normalized file change event from the raw events\n\t * the watcher emits.\n\t */\n\treadonly onDidChangeFile: Event<IFileChange[]>;\n\n\t/**\n\t * An event to indicate a message that should get logged.\n\t */\n\treadonly onDidLogMessage: Event<ILogMessage>;\n\n\t/**\n\t * An event to indicate an error occurred from the watcher\n\t * that is unrecoverable. Listeners should restart the\n\t * watcher if possible.\n\t */\n\treadonly onDidError: Event<IWatcherErrorEvent>;\n\n\t/**\n\t * Configures the watcher to watch according to the\n\t * requests. Any existing watched path that is not\n\t * in the array, will be removed from watching and\n\t * any new path will be added to watching.\n\t */\n\twatch(requests: IWatchRequest[]): Promise<void>;\n\n\t/**\n\t * Enable verbose logging in the watcher.\n\t */\n\tsetVerboseLogging(enabled: boolean): Promise<void>;\n\n\t/**\n\t * Stop all watchers.\n\t */\n\tstop(): Promise<void>;\n}\n\nexport interface IRecursiveWatcher extends IWatcher {\n\twatch(requests: IRecursiveWatchRequest[]): Promise<void>;\n}\n\nexport interface IRecursiveWatcherWithSubscribe extends IRecursiveWatcher {\n\t/**\n\t * Subscribe to file events for the given path. The callback is called\n\t * whenever a file event occurs for the path. If the watcher failed,\n\t * the error parameter is set to `true`.\n\t *\n\t * @returns an `IDisposable` to stop listening to events or `undefined`\n\t * if no events can be watched for the path given the current set of\n\t * recursive watch requests.\n\t */\n\tsubscribe(\n\t\tpath: string,\n\t\tcallback: (error: true | null, change?: IFileChange) => void,\n\t): IDisposable | undefined;\n}\n\nexport interface IRecursiveWatcherOptions {\n\t/**\n\t * If `true`, will enable polling for all watchers, otherwise\n\t * will enable it for paths included in the string array.\n\t *\n\t * @deprecated this only exists for WSL1 support and should never\n\t * be used in any other case.\n\t */\n\treadonly usePolling: boolean | string[];\n\n\t/**\n\t * If polling is enabled (via `usePolling`), defines the duration\n\t * in which the watcher will poll for changes.\n\t *\n\t * @deprecated this only exists for WSL1 support and should never\n\t * be used in any other case.\n\t */\n\treadonly pollingInterval?: number;\n}\n\nexport interface INonRecursiveWatcher extends IWatcher {\n\twatch(requests: INonRecursiveWatchRequest[]): Promise<void>;\n}\n\nexport interface IUniversalWatcher extends IWatcher {\n\twatch(requests: IUniversalWatchRequest[]): Promise<void>;\n}\n\nexport abstract class AbstractWatcherClient extends Disposable {\n\tprivate static readonly MAX_RESTARTS = 5;\n\n\tprivate watcher: IWatcher | undefined;\n\tprivate readonly watcherDisposables = this._register(\n\t\tnew MutableDisposable(),\n\t);\n\n\tprivate requests: IWatchRequest[] | undefined = undefined;\n\n\tprivate restartCounter = 0;\n\n\tconstructor(\n\t\tprivate readonly onFileChanges: (changes: IFileChange[]) => void,\n\t\tprivate readonly onLogMessage: (msg: ILogMessage) => void,\n\t\tprivate verboseLogging: boolean,\n\t\tprivate options: {\n\t\t\treadonly type: string;\n\t\t\treadonly restartOnError: boolean;\n\t\t},\n\t) {\n\t\tsuper();\n\t}\n\n\tprotected abstract createWatcher(disposables: DisposableStore): IWatcher;\n\n\tprotected init(): void {\n\t\t// Associate disposables to the watcher\n\t\tconst disposables = new DisposableStore();\n\t\tthis.watcherDisposables.value = disposables;\n\n\t\t// Ask implementors to create the watcher\n\t\tthis.watcher = this.createWatcher(disposables);\n\t\tthis.watcher.setVerboseLogging(this.verboseLogging);\n\n\t\t// Wire in event handlers\n\t\tdisposables.add(\n\t\t\tthis.watcher.onDidChangeFile((changes) =>\n\t\t\t\tthis.onFileChanges(changes),\n\t\t\t),\n\t\t);\n\t\tdisposables.add(\n\t\t\tthis.watcher.onDidLogMessage((msg) => this.onLogMessage(msg)),\n\t\t);\n\t\tdisposables.add(\n\t\t\tthis.watcher.onDidError((e) => this.onError(e.error, e.request)),\n\t\t);\n\t}\n\n\tprotected onError(\n\t\terror: string,\n\t\tfailedRequest?: IUniversalWatchRequest,\n\t): void {\n\t\t// Restart on error (up to N times, if possible)\n\t\tif (this.canRestart(error, failedRequest)) {\n\t\t\tif (\n\t\t\t\tthis.restartCounter < AbstractWatcherClient.MAX_RESTARTS &&\n\t\t\t\tthis.requests\n\t\t\t) {\n\t\t\t\tthis.error(\n\t\t\t\t\t`restarting watcher after unexpected error: ${error}`,\n\t\t\t\t);\n\t\t\t\tthis.restart(this.requests);\n\t\t\t} else {\n\t\t\t\tthis.error(\n\t\t\t\t\t`gave up attempting to restart watcher after unexpected error: ${error}`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Do not attempt to restart otherwise, report the error\n\t\telse {\n\t\t\tthis.error(error);\n\t\t}\n\t}\n\n\tprivate canRestart(\n\t\terror: string,\n\t\tfailedRequest?: IUniversalWatchRequest,\n\t): boolean {\n\t\tif (!this.options.restartOnError) {\n\t\t\treturn false; // disabled by options\n\t\t}\n\n\t\tif (failedRequest) {\n\t\t\t// do not treat a failing request as a reason to restart the entire\n\t\t\t// watcher. it is possible that from a large amount of watch requests\n\t\t\t// some fail and we would constantly restart all requests only because\n\t\t\t// of that. rather, continue the watcher and leave the failed request\n\t\t\treturn false;\n\t\t}\n\n\t\tif (\n\t\t\terror.indexOf(\"No space left on device\") !== -1 ||\n\t\t\terror.indexOf(\"EMFILE\") !== -1\n\t\t) {\n\t\t\t// do not restart when the error indicates that the system is running\n\t\t\t// out of handles for file watching. this is not recoverable anyway\n\t\t\t// and needs changes to the system before continuing\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate restart(requests: IUniversalWatchRequest[]): void {\n\t\tthis.restartCounter++;\n\n\t\tthis.init();\n\t\tthis.watch(requests);\n\t}\n\n\tasync watch(requests: IUniversalWatchRequest[]): Promise<void> {\n\t\tthis.requests = requests;\n\n\t\tawait this.watcher?.watch(requests);\n\t}\n\n\tasync setVerboseLogging(verboseLogging: boolean): Promise<void> {\n\t\tthis.verboseLogging = verboseLogging;\n\n\t\tawait this.watcher?.setVerboseLogging(verboseLogging);\n\t}\n\n\tprivate error(message: string) {\n\t\tthis.onLogMessage({\n\t\t\ttype: \"error\",\n\t\t\tmessage: `[File Watcher (${this.options.type})] ${message}`,\n\t\t});\n\t}\n\n\tprotected trace(message: string) {\n\t\tthis.onLogMessage({\n\t\t\ttype: \"trace\",\n\t\t\tmessage: `[File Watcher (${this.options.type})] ${message}`,\n\t\t});\n\t}\n\n\toverride dispose(): void {\n\t\t// Render the watcher invalid from here\n\t\tthis.watcher = undefined;\n\n\t\treturn super.dispose();\n\t}\n}\n\nexport abstract class AbstractNonRecursiveWatcherClient extends AbstractWatcherClient {\n\tconstructor(\n\t\tonFileChanges: (changes: IFileChange[]) => void,\n\t\tonLogMessage: (msg: ILogMessage) => void,\n\t\tverboseLogging: boolean,\n\t) {\n\t\tsuper(onFileChanges, onLogMessage, verboseLogging, {\n\t\t\ttype: \"node.js\",\n\t\t\trestartOnError: false,\n\t\t});\n\t}\n\n\tprotected abstract override createWatcher(\n\t\tdisposables: DisposableStore,\n\t): INonRecursiveWatcher;\n}\n\nexport abstract class AbstractUniversalWatcherClient extends AbstractWatcherClient {\n\tconstructor(\n\t\tonFileChanges: (changes: IFileChange[]) => void,\n\t\tonLogMessage: (msg: ILogMessage) => void,\n\t\tverboseLogging: boolean,\n\t) {\n\t\tsuper(onFileChanges, onLogMessage, verboseLogging, {\n\t\t\ttype: \"universal\",\n\t\t\trestartOnError: true,\n\t\t});\n\t}\n\n\tprotected abstract override createWatcher(\n\t\tdisposables: DisposableStore,\n\t): IUniversalWatcher;\n}\n\nexport interface ILogMessage {\n\treadonly type: \"trace\" | \"warn\" | \"error\" | \"info\" | \"debug\";\n\treadonly message: string;\n}\n\nexport function reviveFileChanges(changes: IFileChange[]): IFileChange[] {\n\treturn changes.map((change) => ({\n\t\ttype: change.type,\n\t\tresource: URI.revive(change.resource),\n\t\tcId: change.cId,\n\t}));\n}\n\nexport function coalesceEvents(changes: IFileChange[]): IFileChange[] {\n\t// Build deltas\n\tconst coalescer = new EventCoalescer();\n\tfor (const event of changes) {\n\t\tcoalescer.processEvent(event);\n\t}\n\n\treturn coalescer.coalesce();\n}\n\nexport function normalizeWatcherPattern(\n\tpath: string,\n\tpattern: string | IRelativePattern,\n): string | IRelativePattern {\n\t// Patterns are always matched on the full absolute path\n\t// of the event. As such, if the pattern is not absolute\n\t// and is a string and does not start with a leading\n\t// `**`, we have to convert it to a relative pattern with\n\t// the given `base`\n\n\tif (\n\t\ttypeof pattern === \"string\" &&\n\t\t!pattern.startsWith(GLOBSTAR) &&\n\t\t!isAbsolute(pattern)\n\t) {\n\t\treturn { base: path, pattern };\n\t}\n\n\treturn pattern;\n}\n\nexport function parseWatcherPatterns(\n\tpath: string,\n\tpatterns: Array<string | IRelativePattern>,\n): ParsedPattern[] {\n\tconst parsedPatterns: ParsedPattern[] = [];\n\n\tfor (const pattern of patterns) {\n\t\tparsedPatterns.push(parse(normalizeWatcherPattern(path, pattern)));\n\t}\n\n\treturn parsedPatterns;\n}\n\nclass EventCoalescer {\n\tprivate readonly coalesced = new Set<IFileChange>();\n\tprivate readonly mapPathToChange = new Map<string, IFileChange>();\n\n\tprivate toKey(event: IFileChange): string {\n\t\tif (isLinux) {\n\t\t\treturn event.resource.fsPath;\n\t\t}\n\n\t\treturn event.resource.fsPath.toLowerCase(); // normalise to file system case sensitivity\n\t}\n\n\tprocessEvent(event: IFileChange): void {\n\t\tconst existingEvent = this.mapPathToChange.get(this.toKey(event));\n\n\t\tlet keepEvent = false;\n\n\t\t// Event path already exists\n\t\tif (existingEvent) {\n\t\t\tconst currentChangeType = existingEvent.type;\n\t\t\tconst newChangeType = event.type;\n\n\t\t\t// macOS/Windows: track renames to different case\n\t\t\t// by keeping both CREATE and DELETE events\n\t\t\tif (\n\t\t\t\texistingEvent.resource.fsPath !== event.resource.fsPath &&\n\t\t\t\t(event.type === FileChangeType.DELETED ||\n\t\t\t\t\tevent.type === FileChangeType.ADDED)\n\t\t\t) {\n\t\t\t\tkeepEvent = true;\n\t\t\t}\n\n\t\t\t// Ignore CREATE followed by DELETE in one go\n\t\t\telse if (\n\t\t\t\tcurrentChangeType === FileChangeType.ADDED &&\n\t\t\t\tnewChangeType === FileChangeType.DELETED\n\t\t\t) {\n\t\t\t\tthis.mapPathToChange.delete(this.toKey(event));\n\t\t\t\tthis.coalesced.delete(existingEvent);\n\t\t\t}\n\n\t\t\t// Flatten DELETE followed by CREATE into CHANGE\n\t\t\telse if (\n\t\t\t\tcurrentChangeType === FileChangeType.DELETED &&\n\t\t\t\tnewChangeType === FileChangeType.ADDED\n\t\t\t) {\n\t\t\t\texistingEvent.type = FileChangeType.UPDATED;\n\t\t\t}\n\n\t\t\t// Do nothing. Keep the created event\n\t\t\telse if (\n\t\t\t\tcurrentChangeType === FileChangeType.ADDED &&\n\t\t\t\tnewChangeType === FileChangeType.UPDATED\n\t\t\t) {\n\t\t\t}\n\n\t\t\t// Otherwise apply change type\n\t\t\telse {\n\t\t\t\texistingEvent.type = newChangeType;\n\t\t\t}\n\t\t}\n\n\t\t// Otherwise keep\n\t\telse {\n\t\t\tkeepEvent = true;\n\t\t}\n\n\t\tif (keepEvent) {\n\t\t\tthis.coalesced.add(event);\n\t\t\tthis.mapPathToChange.set(this.toKey(event), event);\n\t\t}\n\t}\n\n\tcoalesce(): IFileChange[] {\n\t\tconst addOrChangeEvents: IFileChange[] = [];\n\t\tconst deletedPaths: string[] = [];\n\n\t\t// This algorithm will remove all DELETE events up to the root folder\n\t\t// that got deleted if any. This ensures that we are not producing\n\t\t// DELETE events for each file inside a folder that gets deleted.\n\t\t//\n\t\t// 1.) split ADD/CHANGE and DELETED events\n\t\t// 2.) sort short deleted paths to the top\n\t\t// 3.) for each DELETE, check if there is a deleted parent and ignore the event in that case\n\t\treturn Array.from(this.coalesced)\n\t\t\t.filter((e) => {\n\t\t\t\tif (e.type !== FileChangeType.DELETED) {\n\t\t\t\t\taddOrChangeEvents.push(e);\n\n\t\t\t\t\treturn false; // remove ADD / CHANGE\n\t\t\t\t}\n\n\t\t\t\treturn true; // keep DELETE\n\t\t\t})\n\t\t\t.sort((e1, e2) => {\n\t\t\t\treturn e1.resource.fsPath.length - e2.resource.fsPath.length; // shortest path first\n\t\t\t})\n\t\t\t.filter((e) => {\n\t\t\t\tif (\n\t\t\t\t\tdeletedPaths.some((deletedPath) =>\n\t\t\t\t\t\tisParent(\n\t\t\t\t\t\t\te.resource.fsPath,\n\t\t\t\t\t\t\tdeletedPath,\n\t\t\t\t\t\t\t!isLinux /* ignorecase */,\n\t\t\t\t\t\t),\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\treturn false; // DELETE is ignored if parent is deleted already\n\t\t\t\t}\n\n\t\t\t\t// otherwise mark as deleted\n\t\t\t\tdeletedPaths.push(e.resource.fsPath);\n\n\t\t\t\treturn true;\n\t\t\t})\n\t\t\t.concat(addOrChangeEvents);\n\t}\n}\n\nexport function isFiltered(\n\tevent: IFileChange,\n\tfilter: FileChangeFilter | undefined,\n): boolean {\n\tif (typeof filter === \"number\") {\n\t\tswitch (event.type) {\n\t\t\tcase FileChangeType.ADDED:\n\t\t\t\treturn (filter & FileChangeFilter.ADDED) === 0;\n\t\t\tcase FileChangeType.DELETED:\n\t\t\t\treturn (filter & FileChangeFilter.DELETED) === 0;\n\t\t\tcase FileChangeType.UPDATED:\n\t\t\t\treturn (filter & FileChangeFilter.UPDATED) === 0;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport function requestFilterToString(\n\tfilter: FileChangeFilter | undefined,\n): string {\n\tif (typeof filter === \"number\") {\n\t\tconst filters = [];\n\t\tif (filter & FileChangeFilter.ADDED) {\n\t\t\tfilters.push(\"Added\");\n\t\t}\n\t\tif (filter & FileChangeFilter.DELETED) {\n\t\t\tfilters.push(\"Deleted\");\n\t\t}\n\t\tif (filter & FileChangeFilter.UPDATED) {\n\t\t\tfilters.push(\"Updated\");\n\t\t}\n\n\t\tif (filters.length === 0) {\n\t\t\treturn \"<all>\";\n\t\t}\n\n\t\treturn `[${filters.join(\", \")}]`;\n\t}\n\n\treturn \"<none>\";\n}\n"],
  "mappings": "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",
  "names": []
}
