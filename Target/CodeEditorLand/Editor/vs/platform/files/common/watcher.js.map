{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/files/common/watcher.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../../base/common/event.js';\nimport { GLOBSTAR, IRelativePattern, parse, ParsedPattern } from '../../../base/common/glob.js';\nimport { Disposable, DisposableStore, IDisposable, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { isAbsolute } from '../../../base/common/path.js';\nimport { isLinux } from '../../../base/common/platform.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { FileChangeFilter, FileChangeType, IFileChange, isParent } from './files.js';\n\ninterface IWatchRequest {\n\n\t/**\n\t * The path to watch.\n\t */\n\treadonly path: string;\n\n\t/**\n\t * Whether to watch recursively or not.\n\t */\n\treadonly recursive: boolean;\n\n\t/**\n\t * A set of glob patterns or paths to exclude from watching.\n\t */\n\treadonly excludes: string[];\n\n\t/**\n\t * An optional set of glob patterns or paths to include for\n\t * watching. If not provided, all paths are considered for\n\t * events.\n\t */\n\treadonly includes?: Array<string | IRelativePattern>;\n\n\t/**\n\t * If provided, file change events from the watcher that\n\t * are a result of this watch request will carry the same\n\t * id.\n\t */\n\treadonly correlationId?: number;\n\n\t/**\n\t * If provided, allows to filter the events that the watcher should consider\n\t * for emitting. If not provided, all events are emitted.\n\t *\n\t * For example, to emit added and updated events, set to:\n\t * `FileChangeFilter.ADDED | FileChangeFilter.UPDATED`.\n\t */\n\treadonly filter?: FileChangeFilter;\n}\n\nexport interface IWatchRequestWithCorrelation extends IWatchRequest {\n\treadonly correlationId: number;\n}\n\nexport function isWatchRequestWithCorrelation(request: IWatchRequest): request is IWatchRequestWithCorrelation {\n\treturn typeof request.correlationId === 'number';\n}\n\nexport interface INonRecursiveWatchRequest extends IWatchRequest {\n\n\t/**\n\t * The watcher will be non-recursive.\n\t */\n\treadonly recursive: false;\n}\n\nexport interface IRecursiveWatchRequest extends IWatchRequest {\n\n\t/**\n\t * The watcher will be recursive.\n\t */\n\treadonly recursive: true;\n\n\t/**\n\t * @deprecated this only exists for WSL1 support and should never\n\t * be used in any other case.\n\t */\n\tpollingInterval?: number;\n\n\t/**\n\t * TODO@bpasero Temporary flag to test the new watcher implementation\n\t */\n\tuseNext?: boolean;\n}\n\nexport function isRecursiveWatchRequest(request: IWatchRequest): request is IRecursiveWatchRequest {\n\treturn request.recursive === true;\n}\n\nexport type IUniversalWatchRequest = IRecursiveWatchRequest | INonRecursiveWatchRequest;\n\nexport interface IWatcherErrorEvent {\n\treadonly error: string;\n\treadonly request?: IUniversalWatchRequest;\n}\n\nexport interface IWatcher {\n\n\t/**\n\t * A normalized file change event from the raw events\n\t * the watcher emits.\n\t */\n\treadonly onDidChangeFile: Event<IFileChange[]>;\n\n\t/**\n\t * An event to indicate a message that should get logged.\n\t */\n\treadonly onDidLogMessage: Event<ILogMessage>;\n\n\t/**\n\t * An event to indicate an error occurred from the watcher\n\t * that is unrecoverable. Listeners should restart the\n\t * watcher if possible.\n\t */\n\treadonly onDidError: Event<IWatcherErrorEvent>;\n\n\t/**\n\t * Configures the watcher to watch according to the\n\t * requests. Any existing watched path that is not\n\t * in the array, will be removed from watching and\n\t * any new path will be added to watching.\n\t */\n\twatch(requests: IWatchRequest[]): Promise<void>;\n\n\t/**\n\t * Enable verbose logging in the watcher.\n\t */\n\tsetVerboseLogging(enabled: boolean): Promise<void>;\n\n\t/**\n\t * Stop all watchers.\n\t */\n\tstop(): Promise<void>;\n}\n\nexport interface IRecursiveWatcher extends IWatcher {\n\twatch(requests: IRecursiveWatchRequest[]): Promise<void>;\n}\n\nexport interface IRecursiveWatcherWithSubscribe extends IRecursiveWatcher {\n\n\t/**\n\t * Subscribe to file events for the given path. The callback is called\n\t * whenever a file event occurs for the path. If the watcher failed,\n\t * the error parameter is set to `true`.\n\t *\n\t * @returns an `IDisposable` to stop listening to events or `undefined`\n\t * if no events can be watched for the path given the current set of\n\t * recursive watch requests.\n\t */\n\tsubscribe(path: string, callback: (error: true | null, change?: IFileChange) => void): IDisposable | undefined;\n}\n\nexport interface IRecursiveWatcherOptions {\n\n\t/**\n\t * If `true`, will enable polling for all watchers, otherwise\n\t * will enable it for paths included in the string array.\n\t *\n\t * @deprecated this only exists for WSL1 support and should never\n\t * be used in any other case.\n\t */\n\treadonly usePolling: boolean | string[];\n\n\t/**\n\t * If polling is enabled (via `usePolling`), defines the duration\n\t * in which the watcher will poll for changes.\n\t *\n\t * @deprecated this only exists for WSL1 support and should never\n\t * be used in any other case.\n\t */\n\treadonly pollingInterval?: number;\n\n\t/**\n\t * TODO@bpasero Temporary flag to test the new watcher implementation\n\t */\n\treadonly useNext?: boolean;\n}\n\nexport interface INonRecursiveWatcher extends IWatcher {\n\twatch(requests: INonRecursiveWatchRequest[]): Promise<void>;\n}\n\nexport interface IUniversalWatcher extends IWatcher {\n\twatch(requests: IUniversalWatchRequest[]): Promise<void>;\n}\n\nexport abstract class AbstractWatcherClient extends Disposable {\n\n\tprivate static readonly MAX_RESTARTS = 5;\n\n\tprivate watcher: IWatcher | undefined;\n\tprivate readonly watcherDisposables = this._register(new MutableDisposable());\n\n\tprivate requests: IWatchRequest[] | undefined = undefined;\n\n\tprivate restartCounter = 0;\n\n\tconstructor(\n\t\tprivate readonly onFileChanges: (changes: IFileChange[]) => void,\n\t\tprivate readonly onLogMessage: (msg: ILogMessage) => void,\n\t\tprivate verboseLogging: boolean,\n\t\tprivate options: {\n\t\t\treadonly type: string;\n\t\t\treadonly restartOnError: boolean;\n\t\t}\n\t) {\n\t\tsuper();\n\t}\n\n\tprotected abstract createWatcher(disposables: DisposableStore): IWatcher;\n\n\tprotected init(): void {\n\n\t\t// Associate disposables to the watcher\n\t\tconst disposables = new DisposableStore();\n\t\tthis.watcherDisposables.value = disposables;\n\n\t\t// Ask implementors to create the watcher\n\t\tthis.watcher = this.createWatcher(disposables);\n\t\tthis.watcher.setVerboseLogging(this.verboseLogging);\n\n\t\t// Wire in event handlers\n\t\tdisposables.add(this.watcher.onDidChangeFile(changes => this.onFileChanges(changes)));\n\t\tdisposables.add(this.watcher.onDidLogMessage(msg => this.onLogMessage(msg)));\n\t\tdisposables.add(this.watcher.onDidError(e => this.onError(e.error, e.request)));\n\t}\n\n\tprotected onError(error: string, failedRequest?: IUniversalWatchRequest): void {\n\n\t\t// Restart on error (up to N times, if possible)\n\t\tif (this.canRestart(error, failedRequest)) {\n\t\t\tif (this.restartCounter < AbstractWatcherClient.MAX_RESTARTS && this.requests) {\n\t\t\t\tthis.error(`restarting watcher after unexpected error: ${error}`);\n\t\t\t\tthis.restart(this.requests);\n\t\t\t} else {\n\t\t\t\tthis.error(`gave up attempting to restart watcher after unexpected error: ${error}`);\n\t\t\t}\n\t\t}\n\n\t\t// Do not attempt to restart otherwise, report the error\n\t\telse {\n\t\t\tthis.error(error);\n\t\t}\n\t}\n\n\tprivate canRestart(error: string, failedRequest?: IUniversalWatchRequest): boolean {\n\t\tif (!this.options.restartOnError) {\n\t\t\treturn false; // disabled by options\n\t\t}\n\n\t\tif (failedRequest) {\n\t\t\t// do not treat a failing request as a reason to restart the entire\n\t\t\t// watcher. it is possible that from a large amount of watch requests\n\t\t\t// some fail and we would constantly restart all requests only because\n\t\t\t// of that. rather, continue the watcher and leave the failed request\n\t\t\treturn false;\n\t\t}\n\n\t\tif (\n\t\t\terror.indexOf('No space left on device') !== -1 ||\n\t\t\terror.indexOf('EMFILE') !== -1\n\t\t) {\n\t\t\t// do not restart when the error indicates that the system is running\n\t\t\t// out of handles for file watching. this is not recoverable anyway\n\t\t\t// and needs changes to the system before continuing\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate restart(requests: IUniversalWatchRequest[]): void {\n\t\tthis.restartCounter++;\n\n\t\tthis.init();\n\t\tthis.watch(requests);\n\t}\n\n\tasync watch(requests: IUniversalWatchRequest[]): Promise<void> {\n\t\tthis.requests = requests;\n\n\t\tawait this.watcher?.watch(requests);\n\t}\n\n\tasync setVerboseLogging(verboseLogging: boolean): Promise<void> {\n\t\tthis.verboseLogging = verboseLogging;\n\n\t\tawait this.watcher?.setVerboseLogging(verboseLogging);\n\t}\n\n\tprivate error(message: string) {\n\t\tthis.onLogMessage({ type: 'error', message: `[File Watcher (${this.options.type})] ${message}` });\n\t}\n\n\tprotected trace(message: string) {\n\t\tthis.onLogMessage({ type: 'trace', message: `[File Watcher (${this.options.type})] ${message}` });\n\t}\n\n\toverride dispose(): void {\n\n\t\t// Render the watcher invalid from here\n\t\tthis.watcher = undefined;\n\n\t\treturn super.dispose();\n\t}\n}\n\nexport abstract class AbstractNonRecursiveWatcherClient extends AbstractWatcherClient {\n\n\tconstructor(\n\t\tonFileChanges: (changes: IFileChange[]) => void,\n\t\tonLogMessage: (msg: ILogMessage) => void,\n\t\tverboseLogging: boolean\n\t) {\n\t\tsuper(onFileChanges, onLogMessage, verboseLogging, { type: 'node.js', restartOnError: false });\n\t}\n\n\tprotected abstract override createWatcher(disposables: DisposableStore): INonRecursiveWatcher;\n}\n\nexport abstract class AbstractUniversalWatcherClient extends AbstractWatcherClient {\n\n\tconstructor(\n\t\tonFileChanges: (changes: IFileChange[]) => void,\n\t\tonLogMessage: (msg: ILogMessage) => void,\n\t\tverboseLogging: boolean\n\t) {\n\t\tsuper(onFileChanges, onLogMessage, verboseLogging, { type: 'universal', restartOnError: true });\n\t}\n\n\tprotected abstract override createWatcher(disposables: DisposableStore): IUniversalWatcher;\n}\n\nexport interface ILogMessage {\n\treadonly type: 'trace' | 'warn' | 'error' | 'info' | 'debug';\n\treadonly message: string;\n}\n\nexport function reviveFileChanges(changes: IFileChange[]): IFileChange[] {\n\treturn changes.map(change => ({\n\t\ttype: change.type,\n\t\tresource: URI.revive(change.resource),\n\t\tcId: change.cId\n\t}));\n}\n\nexport function coalesceEvents(changes: IFileChange[]): IFileChange[] {\n\n\t// Build deltas\n\tconst coalescer = new EventCoalescer();\n\tfor (const event of changes) {\n\t\tcoalescer.processEvent(event);\n\t}\n\n\treturn coalescer.coalesce();\n}\n\nexport function normalizeWatcherPattern(path: string, pattern: string | IRelativePattern): string | IRelativePattern {\n\n\t// Patterns are always matched on the full absolute path\n\t// of the event. As such, if the pattern is not absolute\n\t// and is a string and does not start with a leading\n\t// `**`, we have to convert it to a relative pattern with\n\t// the given `base`\n\n\tif (typeof pattern === 'string' && !pattern.startsWith(GLOBSTAR) && !isAbsolute(pattern)) {\n\t\treturn { base: path, pattern };\n\t}\n\n\treturn pattern;\n}\n\nexport function parseWatcherPatterns(path: string, patterns: Array<string | IRelativePattern>): ParsedPattern[] {\n\tconst parsedPatterns: ParsedPattern[] = [];\n\n\tfor (const pattern of patterns) {\n\t\tparsedPatterns.push(parse(normalizeWatcherPattern(path, pattern)));\n\t}\n\n\treturn parsedPatterns;\n}\n\nclass EventCoalescer {\n\n\tprivate readonly coalesced = new Set<IFileChange>();\n\tprivate readonly mapPathToChange = new Map<string, IFileChange>();\n\n\tprivate toKey(event: IFileChange): string {\n\t\tif (isLinux) {\n\t\t\treturn event.resource.fsPath;\n\t\t}\n\n\t\treturn event.resource.fsPath.toLowerCase(); // normalise to file system case sensitivity\n\t}\n\n\tprocessEvent(event: IFileChange): void {\n\t\tconst existingEvent = this.mapPathToChange.get(this.toKey(event));\n\n\t\tlet keepEvent = false;\n\n\t\t// Event path already exists\n\t\tif (existingEvent) {\n\t\t\tconst currentChangeType = existingEvent.type;\n\t\t\tconst newChangeType = event.type;\n\n\t\t\t// macOS/Windows: track renames to different case\n\t\t\t// by keeping both CREATE and DELETE events\n\t\t\tif (existingEvent.resource.fsPath !== event.resource.fsPath && (event.type === FileChangeType.DELETED || event.type === FileChangeType.ADDED)) {\n\t\t\t\tkeepEvent = true;\n\t\t\t}\n\n\t\t\t// Ignore CREATE followed by DELETE in one go\n\t\t\telse if (currentChangeType === FileChangeType.ADDED && newChangeType === FileChangeType.DELETED) {\n\t\t\t\tthis.mapPathToChange.delete(this.toKey(event));\n\t\t\t\tthis.coalesced.delete(existingEvent);\n\t\t\t}\n\n\t\t\t// Flatten DELETE followed by CREATE into CHANGE\n\t\t\telse if (currentChangeType === FileChangeType.DELETED && newChangeType === FileChangeType.ADDED) {\n\t\t\t\texistingEvent.type = FileChangeType.UPDATED;\n\t\t\t}\n\n\t\t\t// Do nothing. Keep the created event\n\t\t\telse if (currentChangeType === FileChangeType.ADDED && newChangeType === FileChangeType.UPDATED) { }\n\n\t\t\t// Otherwise apply change type\n\t\t\telse {\n\t\t\t\texistingEvent.type = newChangeType;\n\t\t\t}\n\t\t}\n\n\t\t// Otherwise keep\n\t\telse {\n\t\t\tkeepEvent = true;\n\t\t}\n\n\t\tif (keepEvent) {\n\t\t\tthis.coalesced.add(event);\n\t\t\tthis.mapPathToChange.set(this.toKey(event), event);\n\t\t}\n\t}\n\n\tcoalesce(): IFileChange[] {\n\t\tconst addOrChangeEvents: IFileChange[] = [];\n\t\tconst deletedPaths: string[] = [];\n\n\t\t// This algorithm will remove all DELETE events up to the root folder\n\t\t// that got deleted if any. This ensures that we are not producing\n\t\t// DELETE events for each file inside a folder that gets deleted.\n\t\t//\n\t\t// 1.) split ADD/CHANGE and DELETED events\n\t\t// 2.) sort short deleted paths to the top\n\t\t// 3.) for each DELETE, check if there is a deleted parent and ignore the event in that case\n\t\treturn Array.from(this.coalesced).filter(e => {\n\t\t\tif (e.type !== FileChangeType.DELETED) {\n\t\t\t\taddOrChangeEvents.push(e);\n\n\t\t\t\treturn false; // remove ADD / CHANGE\n\t\t\t}\n\n\t\t\treturn true; // keep DELETE\n\t\t}).sort((e1, e2) => {\n\t\t\treturn e1.resource.fsPath.length - e2.resource.fsPath.length; // shortest path first\n\t\t}).filter(e => {\n\t\t\tif (deletedPaths.some(deletedPath => isParent(e.resource.fsPath, deletedPath, !isLinux /* ignorecase */))) {\n\t\t\t\treturn false; // DELETE is ignored if parent is deleted already\n\t\t\t}\n\n\t\t\t// otherwise mark as deleted\n\t\t\tdeletedPaths.push(e.resource.fsPath);\n\n\t\t\treturn true;\n\t\t}).concat(addOrChangeEvents);\n\t}\n}\n\nexport function isFiltered(event: IFileChange, filter: FileChangeFilter | undefined): boolean {\n\tif (typeof filter === 'number') {\n\t\tswitch (event.type) {\n\t\t\tcase FileChangeType.ADDED:\n\t\t\t\treturn (filter & FileChangeFilter.ADDED) === 0;\n\t\t\tcase FileChangeType.DELETED:\n\t\t\t\treturn (filter & FileChangeFilter.DELETED) === 0;\n\t\t\tcase FileChangeType.UPDATED:\n\t\t\t\treturn (filter & FileChangeFilter.UPDATED) === 0;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport function requestFilterToString(filter: FileChangeFilter | undefined): string {\n\tif (typeof filter === 'number') {\n\t\tconst filters = [];\n\t\tif (filter & FileChangeFilter.ADDED) {\n\t\t\tfilters.push('Added');\n\t\t}\n\t\tif (filter & FileChangeFilter.DELETED) {\n\t\t\tfilters.push('Deleted');\n\t\t}\n\t\tif (filter & FileChangeFilter.UPDATED) {\n\t\t\tfilters.push('Updated');\n\t\t}\n\n\t\tif (filters.length === 0) {\n\t\t\treturn '<all>';\n\t\t}\n\n\t\treturn `[${filters.join(', ')}]`;\n\t}\n\n\treturn '<none>';\n}\n"],
  "mappings": "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",
  "names": []
}
