{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/files/common/diskFileSystemProviderClient.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { toErrorMessage } from '../../../base/common/errorMessage.js';\nimport { canceled } from '../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { Disposable, DisposableStore, IDisposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { newWriteableStream, ReadableStreamEventPayload, ReadableStreamEvents } from '../../../base/common/stream.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { generateUuid } from '../../../base/common/uuid.js';\nimport { IChannel } from '../../../base/parts/ipc/common/ipc.js';\nimport { createFileSystemProviderError, IFileAtomicReadOptions, IFileDeleteOptions, IFileOpenOptions, IFileOverwriteOptions, IFileReadStreamOptions, FileSystemProviderCapabilities, FileSystemProviderErrorCode, FileType, IFileWriteOptions, IFileChange, IFileSystemProviderWithFileAtomicReadCapability, IFileSystemProviderWithFileCloneCapability, IFileSystemProviderWithFileFolderCopyCapability, IFileSystemProviderWithFileReadStreamCapability, IFileSystemProviderWithFileReadWriteCapability, IFileSystemProviderWithOpenReadWriteCloseCapability, IStat, IWatchOptions, IFileSystemProviderError } from './files.js';\nimport { reviveFileChanges } from './watcher.js';\n\nexport const LOCAL_FILE_SYSTEM_CHANNEL_NAME = 'localFilesystem';\n\n/**\n * An implementation of a local disk file system provider\n * that is backed by a `IChannel` and thus implemented via\n * IPC on a different process.\n */\nexport class DiskFileSystemProviderClient extends Disposable implements\n\tIFileSystemProviderWithFileReadWriteCapability,\n\tIFileSystemProviderWithOpenReadWriteCloseCapability,\n\tIFileSystemProviderWithFileReadStreamCapability,\n\tIFileSystemProviderWithFileFolderCopyCapability,\n\tIFileSystemProviderWithFileAtomicReadCapability,\n\tIFileSystemProviderWithFileCloneCapability {\n\n\tconstructor(\n\t\tprivate readonly channel: IChannel,\n\t\tprivate readonly extraCapabilities: { trash?: boolean; pathCaseSensitive?: boolean }\n\t) {\n\t\tsuper();\n\n\t\tthis.registerFileChangeListeners();\n\t}\n\n\t//#region File Capabilities\n\n\treadonly onDidChangeCapabilities: Event<void> = Event.None;\n\n\tprivate _capabilities: FileSystemProviderCapabilities | undefined;\n\tget capabilities(): FileSystemProviderCapabilities {\n\t\tif (!this._capabilities) {\n\t\t\tthis._capabilities =\n\t\t\t\tFileSystemProviderCapabilities.FileReadWrite |\n\t\t\t\tFileSystemProviderCapabilities.FileOpenReadWriteClose |\n\t\t\t\tFileSystemProviderCapabilities.FileReadStream |\n\t\t\t\tFileSystemProviderCapabilities.FileFolderCopy |\n\t\t\t\tFileSystemProviderCapabilities.FileWriteUnlock |\n\t\t\t\tFileSystemProviderCapabilities.FileAtomicRead |\n\t\t\t\tFileSystemProviderCapabilities.FileAtomicWrite |\n\t\t\t\tFileSystemProviderCapabilities.FileAtomicDelete |\n\t\t\t\tFileSystemProviderCapabilities.FileClone;\n\n\t\t\tif (this.extraCapabilities.pathCaseSensitive) {\n\t\t\t\tthis._capabilities |= FileSystemProviderCapabilities.PathCaseSensitive;\n\t\t\t}\n\n\t\t\tif (this.extraCapabilities.trash) {\n\t\t\t\tthis._capabilities |= FileSystemProviderCapabilities.Trash;\n\t\t\t}\n\t\t}\n\n\t\treturn this._capabilities;\n\t}\n\n\t//#endregion\n\n\t//#region File Metadata Resolving\n\n\tstat(resource: URI): Promise<IStat> {\n\t\treturn this.channel.call('stat', [resource]);\n\t}\n\n\treaddir(resource: URI): Promise<[string, FileType][]> {\n\t\treturn this.channel.call('readdir', [resource]);\n\t}\n\n\t//#endregion\n\n\t//#region File Reading/Writing\n\n\tasync readFile(resource: URI, opts?: IFileAtomicReadOptions): Promise<Uint8Array> {\n\t\tconst { buffer } = await this.channel.call('readFile', [resource, opts]) as VSBuffer;\n\n\t\treturn buffer;\n\t}\n\n\treadFileStream(resource: URI, opts: IFileReadStreamOptions, token: CancellationToken): ReadableStreamEvents<Uint8Array> {\n\t\tconst stream = newWriteableStream<Uint8Array>(data => VSBuffer.concat(data.map(data => VSBuffer.wrap(data))).buffer);\n\t\tconst disposables = new DisposableStore();\n\n\t\t// Reading as file stream goes through an event to the remote side\n\t\tdisposables.add(this.channel.listen<ReadableStreamEventPayload<VSBuffer>>('readFileStream', [resource, opts])(dataOrErrorOrEnd => {\n\n\t\t\t// data\n\t\t\tif (dataOrErrorOrEnd instanceof VSBuffer) {\n\t\t\t\tstream.write(dataOrErrorOrEnd.buffer);\n\t\t\t}\n\n\t\t\t// end or error\n\t\t\telse {\n\t\t\t\tif (dataOrErrorOrEnd === 'end') {\n\t\t\t\t\tstream.end();\n\t\t\t\t} else {\n\t\t\t\t\tlet error: Error;\n\n\t\t\t\t\t// Take Error as is if type matches\n\t\t\t\t\tif (dataOrErrorOrEnd instanceof Error) {\n\t\t\t\t\t\terror = dataOrErrorOrEnd;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Otherwise, try to deserialize into an error.\n\t\t\t\t\t// Since we communicate via IPC, we cannot be sure\n\t\t\t\t\t// that Error objects are properly serialized.\n\t\t\t\t\telse {\n\t\t\t\t\t\tconst errorCandidate = dataOrErrorOrEnd as IFileSystemProviderError;\n\n\t\t\t\t\t\terror = createFileSystemProviderError(errorCandidate.message ?? toErrorMessage(errorCandidate), errorCandidate.code ?? FileSystemProviderErrorCode.Unknown);\n\t\t\t\t\t}\n\n\t\t\t\t\tstream.error(error);\n\t\t\t\t\tstream.end();\n\t\t\t\t}\n\n\t\t\t\t// Signal to the remote side that we no longer listen\n\t\t\t\tdisposables.dispose();\n\t\t\t}\n\t\t}));\n\n\t\t// Support cancellation\n\t\tdisposables.add(token.onCancellationRequested(() => {\n\n\t\t\t// Ensure to end the stream properly with an error\n\t\t\t// to indicate the cancellation.\n\t\t\tstream.error(canceled());\n\t\t\tstream.end();\n\n\t\t\t// Ensure to dispose the listener upon cancellation. This will\n\t\t\t// bubble through the remote side as event and allows to stop\n\t\t\t// reading the file.\n\t\t\tdisposables.dispose();\n\t\t}));\n\n\t\treturn stream;\n\t}\n\n\twriteFile(resource: URI, content: Uint8Array, opts: IFileWriteOptions): Promise<void> {\n\t\treturn this.channel.call('writeFile', [resource, VSBuffer.wrap(content), opts]);\n\t}\n\n\topen(resource: URI, opts: IFileOpenOptions): Promise<number> {\n\t\treturn this.channel.call('open', [resource, opts]);\n\t}\n\n\tclose(fd: number): Promise<void> {\n\t\treturn this.channel.call('close', [fd]);\n\t}\n\n\tasync read(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number> {\n\t\tconst [bytes, bytesRead]: [VSBuffer, number] = await this.channel.call('read', [fd, pos, length]);\n\n\t\t// copy back the data that was written into the buffer on the remote\n\t\t// side. we need to do this because buffers are not referenced by\n\t\t// pointer, but only by value and as such cannot be directly written\n\t\t// to from the other process.\n\t\tdata.set(bytes.buffer.slice(0, bytesRead), offset);\n\n\t\treturn bytesRead;\n\t}\n\n\twrite(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number> {\n\t\treturn this.channel.call('write', [fd, pos, VSBuffer.wrap(data), offset, length]);\n\t}\n\n\t//#endregion\n\n\t//#region Move/Copy/Delete/Create Folder\n\n\tmkdir(resource: URI): Promise<void> {\n\t\treturn this.channel.call('mkdir', [resource]);\n\t}\n\n\tdelete(resource: URI, opts: IFileDeleteOptions): Promise<void> {\n\t\treturn this.channel.call('delete', [resource, opts]);\n\t}\n\n\trename(resource: URI, target: URI, opts: IFileOverwriteOptions): Promise<void> {\n\t\treturn this.channel.call('rename', [resource, target, opts]);\n\t}\n\n\tcopy(resource: URI, target: URI, opts: IFileOverwriteOptions): Promise<void> {\n\t\treturn this.channel.call('copy', [resource, target, opts]);\n\t}\n\n\t//#endregion\n\n\t//#region Clone File\n\n\tcloneFile(resource: URI, target: URI): Promise<void> {\n\t\treturn this.channel.call('cloneFile', [resource, target]);\n\t}\n\n\t//#endregion\n\n\t//#region File Watching\n\n\tprivate readonly _onDidChange = this._register(new Emitter<readonly IFileChange[]>());\n\treadonly onDidChangeFile = this._onDidChange.event;\n\n\tprivate readonly _onDidWatchError = this._register(new Emitter<string>());\n\treadonly onDidWatchError = this._onDidWatchError.event;\n\n\t// The contract for file watching via remote is to identify us\n\t// via a unique but readonly session ID. Since the remote is\n\t// managing potentially many watchers from different clients,\n\t// this helps the server to properly partition events to the right\n\t// clients.\n\tprivate readonly sessionId = generateUuid();\n\n\tprivate registerFileChangeListeners(): void {\n\n\t\t// The contract for file changes is that there is one listener\n\t\t// for both events and errors from the watcher. So we need to\n\t\t// unwrap the event from the remote and emit through the proper\n\t\t// emitter.\n\t\tthis._register(this.channel.listen<IFileChange[] | string>('fileChange', [this.sessionId])(eventsOrError => {\n\t\t\tif (Array.isArray(eventsOrError)) {\n\t\t\t\tconst events = eventsOrError;\n\t\t\t\tthis._onDidChange.fire(reviveFileChanges(events));\n\t\t\t} else {\n\t\t\t\tconst error = eventsOrError;\n\t\t\t\tthis._onDidWatchError.fire(error);\n\t\t\t}\n\t\t}));\n\t}\n\n\twatch(resource: URI, opts: IWatchOptions): IDisposable {\n\n\t\t// Generate a request UUID to correlate the watcher\n\t\t// back to us when we ask to dispose the watcher later.\n\t\tconst req = generateUuid();\n\n\t\tthis.channel.call('watch', [this.sessionId, req, resource, opts]);\n\n\t\treturn toDisposable(() => this.channel.call('unwatch', [this.sessionId, req]));\n\t}\n\n\t//#endregion\n}\n"],
  "mappings": "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",
  "names": ["data"]
}
