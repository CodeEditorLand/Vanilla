import e from"assert";import{createReadStream as ue,existsSync as E,readdirSync as z,readFileSync as p,statSync as fe,writeFileSync as de,promises as S}from"fs";import{tmpdir as qe}from"os";import{timeout as me}from"../../../../base/common/async.js";import{bufferToReadable as Se,bufferToStream as ke,streamToBuffer as be,streamToBufferReadableStream as he,VSBuffer as y}from"../../../../base/common/buffer.js";import{DisposableStore as Re}from"../../../../base/common/lifecycle.js";import{FileAccess as O,Schemas as Fe}from"../../../../base/common/network.js";import{basename as q,dirname as b,join as u,posix as I}from"../../../../base/common/path.js";import{isLinux as T,isWindows as _}from"../../../../base/common/platform.js";import{joinPath as Z}from"../../../../base/common/resources.js";import{URI as l}from"../../../../base/common/uri.js";import{Promises as ye}from"../../../../base/node/pfs.js";import{flakySuite as Oe,getRandomTestPath as xe}from"../../../../base/test/node/testUtils.js";import{etag as pe,FileOperation as v,FileOperationError as Ce,FileOperationResult as D,FilePermission as We,FileSystemProviderCapabilities as f,hasFileAtomicReadCapability as we,hasOpenReadWriteCloseCapability as B,NotModifiedSinceFileOperationError as Ie,TooLargeFileOperationError as De}from"../../common/files.js";import{FileService as Ee}from"../../common/fileService.js";import{DiskFileSystemProvider as A}from"../../node/diskFileSystemProvider.js";import{NullLogService as ge}from"../../../log/common/log.js";import{isESM as Le}from"../../../../base/common/amd.js";function L(R,a){if(R.children!==void 0)return R.children.find(c=>c.name===a)}function ve(R){let a=R.split(`
`);return a=a.map((c,P)=>P===0?c:`
`+c),{read(){const c=a.shift();return typeof c=="string"?y.fromString(c):null}}}class Pe extends A{totalBytesRead=0;invalidStatSize=!1;smallStatSize=!1;readonly=!1;_testCapabilities;get capabilities(){return this._testCapabilities||(this._testCapabilities=f.FileReadWrite|f.FileOpenReadWriteClose|f.FileReadStream|f.Trash|f.FileFolderCopy|f.FileWriteUnlock|f.FileAtomicRead|f.FileAtomicWrite|f.FileAtomicDelete|f.FileClone,T&&(this._testCapabilities|=f.PathCaseSensitive)),this._testCapabilities}set capabilities(a){this._testCapabilities=a}setInvalidStatSize(a){this.invalidStatSize=a}setSmallStatSize(a){this.smallStatSize=a}setReadonly(a){this.readonly=a}async stat(a){const c=await super.stat(a);return this.invalidStatSize?c.size=String(c.size):this.smallStatSize?c.size=1:this.readonly&&(c.permissions=We.Readonly),c}async read(a,c,P,n,w){const N=await super.read(a,c,P,n,w);return this.totalBytesRead+=N,N}async readFile(a,c){const P=await super.readFile(a,c);return this.totalBytesRead+=P.byteLength,P}}A.configureFlushOnWrite(!1),(Le?Oe:suite.skip)("Disk File Service",function(){const R="test";let a,c,P,n;const w=new Re;setup(async()=>{const r=new ge;a=w.add(new Ee(r)),c=w.add(new Pe(r)),w.add(a.registerProvider(Fe.file,c)),P=w.add(new Pe(r)),w.add(a.registerProvider(R,P)),n=xe(qe(),"vsctests","diskfileservice");const t=O.asFileUri("vs/platform/files/test/node/fixtures/service").fsPath;await ye.copy(t,n,{preserveSymlinks:!1})}),teardown(()=>(w.clear(),ye.rm(n))),test("createFolder",async()=>{let r;w.add(a.onDidRunOperation(o=>r=o));const t=await a.resolve(l.file(n)),i=l.file(u(t.resource.fsPath,"newFolder")),s=await a.createFolder(i);e.strictEqual(s.name,"newFolder"),e.strictEqual(E(s.resource.fsPath),!0),e.ok(r),e.strictEqual(r.resource.fsPath,i.fsPath),e.strictEqual(r.operation,v.CREATE),e.strictEqual(r.target.resource.fsPath,i.fsPath),e.strictEqual(r.target.isDirectory,!0)}),test("createFolder: creating multiple folders at once",async()=>{let r;w.add(a.onDidRunOperation(h=>r=h));const t=["a","couple","of","folders"],i=await a.resolve(l.file(n)),s=l.file(u(i.resource.fsPath,...t)),o=await a.createFolder(s),d=t[t.length-1];e.strictEqual(o.name,d),e.strictEqual(E(o.resource.fsPath),!0),e.ok(r),e.strictEqual(r.resource.fsPath,s.fsPath),e.strictEqual(r.operation,v.CREATE),e.strictEqual(r.target.resource.fsPath,s.fsPath),e.strictEqual(r.target.isDirectory,!0)}),test("exists",async()=>{let r=await a.exists(l.file(n));e.strictEqual(r,!0),r=await a.exists(l.file(n+"something")),e.strictEqual(r,!1)}),test("resolve - file",async()=>{const r=O.asFileUri("vs/platform/files/test/node/fixtures/resolver/index.html"),t=await a.resolve(r);e.strictEqual(t.name,"index.html"),e.strictEqual(t.isFile,!0),e.strictEqual(t.isDirectory,!1),e.strictEqual(t.readonly,!1),e.strictEqual(t.isSymbolicLink,!1),e.strictEqual(t.resource.toString(),r.toString()),e.strictEqual(t.children,void 0),e.ok(t.mtime>0),e.ok(t.ctime>0),e.ok(t.size>0)}),test("resolve - directory",async()=>{const r=["examples","other","index.html","site.css"],t=O.asFileUri("vs/platform/files/test/node/fixtures/resolver"),i=await a.resolve(t);e.ok(i),e.strictEqual(i.resource.toString(),t.toString()),e.strictEqual(i.name,"resolver"),e.ok(i.children),e.ok(i.children.length>0),e.ok(i.isDirectory),e.strictEqual(i.readonly,!1),e.ok(i.mtime>0),e.ok(i.ctime>0),e.strictEqual(i.children.length,r.length),e.ok(i.children.every(s=>r.some(o=>q(s.resource.fsPath)===o))),i.children.forEach(s=>{e.ok(q(s.resource.fsPath)),["examples","other"].indexOf(q(s.resource.fsPath))>=0?(e.ok(s.isDirectory),e.strictEqual(s.mtime,void 0),e.strictEqual(s.ctime,void 0)):q(s.resource.fsPath)==="index.html"?(e.ok(!s.isDirectory),e.ok(!s.children),e.strictEqual(s.mtime,void 0),e.strictEqual(s.ctime,void 0)):q(s.resource.fsPath)==="site.css"?(e.ok(!s.isDirectory),e.ok(!s.children),e.strictEqual(s.mtime,void 0),e.strictEqual(s.ctime,void 0)):e.fail("Unexpected value "+q(s.resource.fsPath))})}),test("resolve - directory - with metadata",async()=>{const r=["examples","other","index.html","site.css"],t=await a.resolve(O.asFileUri("vs/platform/files/test/node/fixtures/resolver"),{resolveMetadata:!0});e.ok(t),e.strictEqual(t.name,"resolver"),e.ok(t.children),e.ok(t.children.length>0),e.ok(t.isDirectory),e.ok(t.mtime>0),e.ok(t.ctime>0),e.strictEqual(t.children.length,r.length),e.ok(t.children.every(i=>r.some(s=>q(i.resource.fsPath)===s))),e.ok(t.children.every(i=>i.etag.length>0)),t.children.forEach(i=>{e.ok(q(i.resource.fsPath)),["examples","other"].indexOf(q(i.resource.fsPath))>=0?(e.ok(i.isDirectory),e.ok(i.mtime>0),e.ok(i.ctime>0)):q(i.resource.fsPath)==="index.html"?(e.ok(!i.isDirectory),e.ok(!i.children),e.ok(i.mtime>0),e.ok(i.ctime>0)):q(i.resource.fsPath)==="site.css"?(e.ok(!i.isDirectory),e.ok(!i.children),e.ok(i.mtime>0),e.ok(i.ctime>0)):e.fail("Unexpected value "+q(i.resource.fsPath))})}),test("resolve - directory with resolveTo",async()=>{const r=await a.resolve(l.file(n),{resolveTo:[l.file(u(n,"deep"))]});e.strictEqual(r.children.length,8);const t=L(r,"deep");e.strictEqual(t.children.length,4)}),test("resolve - directory - resolveTo single directory",async()=>{const r=O.asFileUri("vs/platform/files/test/node/fixtures/resolver").fsPath,t=await a.resolve(l.file(r),{resolveTo:[l.file(u(r,"other/deep"))]});e.ok(t),e.ok(t.children),e.ok(t.children.length>0),e.ok(t.isDirectory);const i=t.children;e.strictEqual(i.length,4);const s=L(t,"other");e.ok(s),e.ok(s.children.length>0);const o=L(s,"deep");e.ok(o),e.ok(o.children.length>0),e.strictEqual(o.children.length,4)}),test("resolve directory - resolveTo multiple directories",()=>N(!1)),test("resolve directory - resolveTo with a URI that has query parameter (https://github.com/microsoft/vscode/issues/128151)",()=>N(!0));async function N(r){const t=O.asFileUri("vs/platform/files/test/node/fixtures/resolver").fsPath,i=await a.resolve(l.file(t).with({query:r?"test":void 0}),{resolveTo:[l.file(u(t,"other/deep")).with({query:r?"test":void 0}),l.file(u(t,"examples")).with({query:r?"test":void 0})]});e.ok(i),e.ok(i.children),e.ok(i.children.length>0),e.ok(i.isDirectory);const s=i.children;e.strictEqual(s.length,4);const o=L(i,"other");e.ok(o),e.ok(o.children.length>0);const d=L(o,"deep");e.ok(d),e.ok(d.children.length>0),e.strictEqual(d.children.length,4);const h=L(i,"examples");e.ok(h),e.ok(h.children.length>0),e.strictEqual(h.children.length,4)}test("resolve directory - resolveSingleChildFolders",async()=>{const r=O.asFileUri("vs/platform/files/test/node/fixtures/resolver/other").fsPath,t=await a.resolve(l.file(r),{resolveSingleChildDescendants:!0});e.ok(t),e.ok(t.children),e.ok(t.children.length>0),e.ok(t.isDirectory);const i=t.children;e.strictEqual(i.length,1);const s=L(t,"deep");e.ok(s),e.ok(s.children.length>0),e.strictEqual(s.children.length,4)}),test("resolves",async()=>{const r=await a.resolveAll([{resource:l.file(n),options:{resolveTo:[l.file(u(n,"deep"))]}},{resource:l.file(u(n,"deep"))}]),t=r[0].stat;e.strictEqual(t.children.length,8);const i=L(t,"deep");e.strictEqual(i.children.length,4);const s=r[1].stat;e.strictEqual(s.children.length,4),e.strictEqual(s.name,"deep")}),test("resolve - folder symbolic link",async()=>{const r=l.file(u(n,"deep-link"));await S.symlink(u(n,"deep"),r.fsPath,"junction");const t=await a.resolve(r);e.strictEqual(t.children.length,4),e.strictEqual(t.isDirectory,!0),e.strictEqual(t.isSymbolicLink,!0)}),(_?test.skip:test)("resolve - file symbolic link",async()=>{const r=l.file(u(n,"lorem.txt-linked"));await S.symlink(u(n,"lorem.txt"),r.fsPath);const t=await a.resolve(r);e.strictEqual(t.isDirectory,!1),e.strictEqual(t.isSymbolicLink,!0)}),test("resolve - symbolic link pointing to nonexistent file does not break",async()=>{await S.symlink(u(n,"foo"),u(n,"bar"),"junction");const r=await a.resolve(l.file(n));e.strictEqual(r.isDirectory,!0),e.strictEqual(r.children.length,9);const t=r.children?.find(i=>i.name==="bar"&&i.isSymbolicLink);e.ok(t),e.ok(!t?.isDirectory),e.ok(!t?.isFile)}),test("stat - file",async()=>{const r=O.asFileUri("vs/platform/files/test/node/fixtures/resolver/index.html"),t=await a.stat(r);e.strictEqual(t.name,"index.html"),e.strictEqual(t.isFile,!0),e.strictEqual(t.isDirectory,!1),e.strictEqual(t.readonly,!1),e.strictEqual(t.isSymbolicLink,!1),e.strictEqual(t.resource.toString(),r.toString()),e.ok(t.mtime>0),e.ok(t.ctime>0),e.ok(t.size>0)}),test("stat - directory",async()=>{const r=O.asFileUri("vs/platform/files/test/node/fixtures/resolver"),t=await a.stat(r);e.ok(t),e.strictEqual(t.resource.toString(),r.toString()),e.strictEqual(t.name,"resolver"),e.ok(t.isDirectory),e.strictEqual(t.readonly,!1),e.ok(t.mtime>0),e.ok(t.ctime>0)}),test("deleteFile (non recursive)",async()=>Q(!1,!1)),test("deleteFile (recursive)",async()=>Q(!1,!0)),(T?test.skip:test)("deleteFile (useTrash)",async()=>Q(!0,!1));async function Q(r,t){let i;w.add(a.onDidRunOperation(h=>i=h));const s=l.file(u(n,"deep","conway.js")),o=await a.resolve(s);e.strictEqual(await a.canDelete(o.resource,{useTrash:r,recursive:t}),!0),await a.del(o.resource,{useTrash:r,recursive:t}),e.strictEqual(E(o.resource.fsPath),!1),e.ok(i),e.strictEqual(i.resource.fsPath,s.fsPath),e.strictEqual(i.operation,v.DELETE);let d;try{await a.del(o.resource,{useTrash:r,recursive:t})}catch(h){d=h}e.ok(d),e.strictEqual(d.fileOperationResult,D.FILE_NOT_FOUND)}(_?test.skip:test)("deleteFile - symbolic link (exists)",async()=>{const r=l.file(u(n,"lorem.txt")),t=l.file(u(n,"lorem.txt-linked"));await S.symlink(r.fsPath,t.fsPath);const i=await a.resolve(t);let s;w.add(a.onDidRunOperation(o=>s=o)),e.strictEqual(await a.canDelete(i.resource),!0),await a.del(i.resource),e.strictEqual(E(i.resource.fsPath),!1),e.ok(s),e.strictEqual(s.resource.fsPath,t.fsPath),e.strictEqual(s.operation,v.DELETE),e.strictEqual(E(r.fsPath),!0)}),(_?test.skip:test)("deleteFile - symbolic link (pointing to nonexistent file)",async()=>{const r=l.file(u(n,"foo")),t=l.file(u(n,"bar"));await S.symlink(r.fsPath,t.fsPath);let i;w.add(a.onDidRunOperation(s=>i=s)),e.strictEqual(await a.canDelete(t),!0),await a.del(t),e.strictEqual(E(t.fsPath),!1),e.ok(i),e.strictEqual(i.resource.fsPath,t.fsPath),e.strictEqual(i.operation,v.DELETE)}),test("deleteFolder (recursive)",async()=>ee(!1,!1)),test("deleteFolder (recursive, atomic)",async()=>ee(!1,{postfix:".vsctmp"})),(T?test.skip:test)("deleteFolder (recursive, useTrash)",async()=>ee(!0,!1));async function ee(r,t){let i;w.add(a.onDidRunOperation(d=>i=d));const s=l.file(u(n,"deep")),o=await a.resolve(s);e.strictEqual(await a.canDelete(o.resource,{recursive:!0,useTrash:r,atomic:t}),!0),await a.del(o.resource,{recursive:!0,useTrash:r,atomic:t}),e.strictEqual(E(o.resource.fsPath),!1),e.ok(i),e.strictEqual(i.resource.fsPath,s.fsPath),e.strictEqual(i.operation,v.DELETE)}test("deleteFolder (non recursive)",async()=>{const r=l.file(u(n,"deep")),t=await a.resolve(r);e.ok(await a.canDelete(t.resource)instanceof Error);let i;try{await a.del(t.resource)}catch(s){i=s}e.ok(i)}),test("deleteFolder empty folder (recursive)",()=>le(!0)),test("deleteFolder empty folder (non recursive)",()=>le(!1));async function le(r){const{resource:t}=await a.createFolder(l.file(u(n,"deep","empty")));await a.del(t,{recursive:r}),e.strictEqual(await a.exists(t),!1)}test("move",async()=>{let r;w.add(a.onDidRunOperation(h=>r=h));const t=l.file(u(n,"index.html")),i=p(t.fsPath),s=l.file(u(b(t.fsPath),"other.html"));e.strictEqual(await a.canMove(t,s),!0);const o=await a.move(t,s);e.strictEqual(E(o.resource.fsPath),!0),e.strictEqual(E(t.fsPath),!1),e.ok(r),e.strictEqual(r.resource.fsPath,t.fsPath),e.strictEqual(r.operation,v.MOVE),e.strictEqual(r.target.resource.fsPath,o.resource.fsPath);const d=p(s.fsPath);e.strictEqual(i.byteLength,d.byteLength),e.strictEqual(i.toString(),d.toString())}),test("move - across providers (buffered => buffered)",async()=>(m(c,f.FileOpenReadWriteClose),m(P,f.FileOpenReadWriteClose),x())),test("move - across providers (unbuffered => unbuffered)",async()=>(m(c,f.FileReadWrite),m(P,f.FileReadWrite),x())),test("move - across providers (buffered => unbuffered)",async()=>(m(c,f.FileOpenReadWriteClose),m(P,f.FileReadWrite),x())),test("move - across providers (unbuffered => buffered)",async()=>(m(c,f.FileReadWrite),m(P,f.FileOpenReadWriteClose),x())),test("move - across providers - large (buffered => buffered)",async()=>(m(c,f.FileOpenReadWriteClose),m(P,f.FileOpenReadWriteClose),x("lorem.txt"))),test("move - across providers - large (unbuffered => unbuffered)",async()=>(m(c,f.FileReadWrite),m(P,f.FileReadWrite),x("lorem.txt"))),test("move - across providers - large (buffered => unbuffered)",async()=>(m(c,f.FileOpenReadWriteClose),m(P,f.FileReadWrite),x("lorem.txt"))),test("move - across providers - large (unbuffered => buffered)",async()=>(m(c,f.FileReadWrite),m(P,f.FileOpenReadWriteClose),x("lorem.txt")));async function x(r="index.html"){let t;w.add(a.onDidRunOperation(F=>t=F));const i=l.file(u(n,r)),s=p(i.fsPath),o=l.file(u(b(i.fsPath),"other.html")).with({scheme:R});e.strictEqual(await a.canMove(i,o),!0);const d=await a.move(i,o);e.strictEqual(E(d.resource.fsPath),!0),e.strictEqual(E(i.fsPath),!1),e.ok(t),e.strictEqual(t.resource.fsPath,i.fsPath),e.strictEqual(t.operation,v.COPY),e.strictEqual(t.target.resource.fsPath,d.resource.fsPath);const h=p(o.fsPath);e.strictEqual(s.byteLength,h.byteLength),e.strictEqual(s.toString(),h.toString())}test("move - multi folder",async()=>{let r;w.add(a.onDidRunOperation(d=>r=d));const i=u(...["a","couple","of","folders"],"other.html"),s=l.file(u(n,"index.html"));e.strictEqual(await a.canMove(s,l.file(u(b(s.fsPath),i))),!0);const o=await a.move(s,l.file(u(b(s.fsPath),i)));e.strictEqual(E(o.resource.fsPath),!0),e.strictEqual(E(s.fsPath),!1),e.ok(r),e.strictEqual(r.resource.fsPath,s.fsPath),e.strictEqual(r.operation,v.MOVE),e.strictEqual(r.target.resource.fsPath,o.resource.fsPath)}),test("move - directory",async()=>{let r;w.add(a.onDidRunOperation(s=>r=s));const t=l.file(u(n,"deep"));e.strictEqual(await a.canMove(t,l.file(u(b(t.fsPath),"deeper"))),!0);const i=await a.move(t,l.file(u(b(t.fsPath),"deeper")));e.strictEqual(E(i.resource.fsPath),!0),e.strictEqual(E(t.fsPath),!1),e.ok(r),e.strictEqual(r.resource.fsPath,t.fsPath),e.strictEqual(r.operation,v.MOVE),e.strictEqual(r.target.resource.fsPath,i.resource.fsPath)}),test("move - directory - across providers (buffered => buffered)",async()=>(m(c,f.FileOpenReadWriteClose),m(P,f.FileOpenReadWriteClose),j())),test("move - directory - across providers (unbuffered => unbuffered)",async()=>(m(c,f.FileReadWrite),m(P,f.FileReadWrite),j())),test("move - directory - across providers (buffered => unbuffered)",async()=>(m(c,f.FileOpenReadWriteClose),m(P,f.FileReadWrite),j())),test("move - directory - across providers (unbuffered => buffered)",async()=>(m(c,f.FileReadWrite),m(P,f.FileOpenReadWriteClose),j()));async function j(){let r;w.add(a.onDidRunOperation(h=>r=h));const t=l.file(u(n,"deep")),i=z(t.fsPath),s=l.file(u(b(t.fsPath),"deeper")).with({scheme:R});e.strictEqual(await a.canMove(t,s),!0);const o=await a.move(t,s);e.strictEqual(E(o.resource.fsPath),!0),e.strictEqual(E(t.fsPath),!1),e.ok(r),e.strictEqual(r.resource.fsPath,t.fsPath),e.strictEqual(r.operation,v.COPY),e.strictEqual(r.target.resource.fsPath,o.resource.fsPath);const d=z(s.fsPath);e.strictEqual(i.length,d.length);for(let h=0;h<i.length;h++)e.strictEqual(i[h],d[h])}test("move - MIX CASE",async()=>{let r;w.add(a.onDidRunOperation(o=>r=o));const t=await a.resolve(l.file(u(n,"index.html")),{resolveMetadata:!0});e.ok(t.size>0);const i=l.file(u(b(t.resource.fsPath),"INDEX.html"));e.strictEqual(await a.canMove(t.resource,i),!0);let s=await a.move(t.resource,i);e.strictEqual(E(i.fsPath),!0),e.strictEqual(q(i.fsPath),"INDEX.html"),e.ok(r),e.strictEqual(r.resource.fsPath,t.resource.fsPath),e.strictEqual(r.operation,v.MOVE),e.strictEqual(r.target.resource.fsPath,i.fsPath),s=await a.resolve(i,{resolveMetadata:!0}),e.strictEqual(t.size,s.size)}),test("move - same file",async()=>{let r;w.add(a.onDidRunOperation(s=>r=s));const t=await a.resolve(l.file(u(n,"index.html")),{resolveMetadata:!0});e.ok(t.size>0),e.strictEqual(await a.canMove(t.resource,l.file(t.resource.fsPath)),!0);let i=await a.move(t.resource,l.file(t.resource.fsPath));e.strictEqual(E(i.resource.fsPath),!0),e.strictEqual(q(i.resource.fsPath),"index.html"),e.ok(r),e.strictEqual(r.resource.fsPath,t.resource.fsPath),e.strictEqual(r.operation,v.MOVE),e.strictEqual(r.target.resource.fsPath,i.resource.fsPath),i=await a.resolve(i.resource,{resolveMetadata:!0}),e.strictEqual(t.size,i.size)}),test("move - same file #2",async()=>{let r;w.add(a.onDidRunOperation(d=>r=d));const t=await a.resolve(l.file(u(n,"index.html")),{resolveMetadata:!0});e.ok(t.size>0);const i=l.file(n),s=i.with({path:I.join(i.path,I.basename(t.resource.path))});e.strictEqual(await a.canMove(t.resource,s),!0);let o=await a.move(t.resource,s);e.strictEqual(E(o.resource.fsPath),!0),e.strictEqual(q(o.resource.fsPath),"index.html"),e.ok(r),e.strictEqual(r.resource.fsPath,t.resource.fsPath),e.strictEqual(r.operation,v.MOVE),e.strictEqual(r.target.resource.fsPath,o.resource.fsPath),o=await a.resolve(o.resource,{resolveMetadata:!0}),e.strictEqual(t.size,o.size)}),test("move - source parent of target",async()=>{let r;w.add(a.onDidRunOperation(o=>r=o));let t=await a.resolve(l.file(u(n,"index.html")),{resolveMetadata:!0});const i=t.size;e.ok(i>0),e.ok(await a.canMove(l.file(n),l.file(u(n,"binary.txt")))instanceof Error);let s;try{await a.move(l.file(n),l.file(u(n,"binary.txt")))}catch(o){s=o}e.ok(s),e.ok(!r),t=await a.resolve(t.resource,{resolveMetadata:!0}),e.strictEqual(i,t.size)}),test("move - FILE_MOVE_CONFLICT",async()=>{let r;w.add(a.onDidRunOperation(o=>r=o));let t=await a.resolve(l.file(u(n,"index.html")),{resolveMetadata:!0});const i=t.size;e.ok(i>0),e.ok(await a.canMove(t.resource,l.file(u(n,"binary.txt")))instanceof Error);let s;try{await a.move(t.resource,l.file(u(n,"binary.txt")))}catch(o){s=o}e.strictEqual(s.fileOperationResult,D.FILE_MOVE_CONFLICT),e.ok(!r),t=await a.resolve(t.resource,{resolveMetadata:!0}),e.strictEqual(i,t.size)}),test("move - overwrite folder with file",async()=>{let r,t,i;w.add(a.onDidRunOperation(g=>{g.operation===v.CREATE?r=g:g.operation===v.DELETE?i=g:g.operation===v.MOVE&&(t=g)}));const s=await a.resolve(l.file(n)),o=l.file(u(s.resource.fsPath,"conway.js")),d=await a.createFolder(o),h=l.file(u(n,"deep","conway.js"));e.strictEqual(await a.canMove(h,d.resource,!0),!0);const F=await a.move(h,d.resource,!0);e.strictEqual(E(F.resource.fsPath),!0),e.ok(fe(F.resource.fsPath).isFile),e.ok(r),e.ok(i),e.ok(t),e.strictEqual(t.resource.fsPath,h.fsPath),e.strictEqual(t.target.resource.fsPath,F.resource.fsPath),e.strictEqual(i.resource.fsPath,o.fsPath)}),test("copy",async()=>{await U()}),test("copy - unbuffered (FileSystemProviderCapabilities.FileReadWrite)",async()=>{m(c,f.FileReadWrite),await U()}),test("copy - unbuffered large (FileSystemProviderCapabilities.FileReadWrite)",async()=>{m(c,f.FileReadWrite),await U("lorem.txt")}),test("copy - buffered (FileSystemProviderCapabilities.FileOpenReadWriteClose)",async()=>{m(c,f.FileOpenReadWriteClose),await U()}),test("copy - buffered large (FileSystemProviderCapabilities.FileOpenReadWriteClose)",async()=>{m(c,f.FileOpenReadWriteClose),await U("lorem.txt")});function m(r,t){r.capabilities=t,T&&(r.capabilities|=f.PathCaseSensitive)}async function U(r="index.html"){let t;w.add(a.onDidRunOperation(F=>t=F));const i=await a.resolve(l.file(u(n,r))),s=l.file(u(n,"other.html"));e.strictEqual(await a.canCopy(i.resource,s),!0);const o=await a.copy(i.resource,s);e.strictEqual(E(o.resource.fsPath),!0),e.strictEqual(E(i.resource.fsPath),!0),e.ok(t),e.strictEqual(t.resource.fsPath,i.resource.fsPath),e.strictEqual(t.operation,v.COPY),e.strictEqual(t.target.resource.fsPath,o.resource.fsPath);const d=p(i.resource.fsPath),h=p(s.fsPath);e.strictEqual(d.byteLength,h.byteLength),e.strictEqual(d.toString(),h.toString())}test("copy - overwrite folder with file",async()=>{let r,t,i;w.add(a.onDidRunOperation(g=>{g.operation===v.CREATE?r=g:g.operation===v.DELETE?i=g:g.operation===v.COPY&&(t=g)}));const s=await a.resolve(l.file(n)),o=l.file(u(s.resource.fsPath,"conway.js")),d=await a.createFolder(o),h=l.file(u(n,"deep","conway.js"));e.strictEqual(await a.canCopy(h,d.resource,!0),!0);const F=await a.copy(h,d.resource,!0);e.strictEqual(E(F.resource.fsPath),!0),e.ok(fe(F.resource.fsPath).isFile),e.ok(r),e.ok(i),e.ok(t),e.strictEqual(t.resource.fsPath,h.fsPath),e.strictEqual(t.target.resource.fsPath,F.resource.fsPath),e.strictEqual(i.resource.fsPath,o.fsPath)}),test("copy - MIX CASE same target - no overwrite",async()=>{let r=await a.resolve(l.file(u(n,"index.html")),{resolveMetadata:!0});const t=r.size;e.ok(t>0);const i=l.file(u(b(r.resource.fsPath),"INDEX.html")),s=await a.canCopy(r.resource,i);let o,d;try{d=await a.copy(r.resource,i)}catch(h){o=h}T?(e.ok(!o),e.strictEqual(s,!0),e.strictEqual(E(d.resource.fsPath),!0),e.ok(z(n).some(h=>h==="INDEX.html")),e.strictEqual(r.size,d.size)):(e.ok(o),e.ok(s instanceof Error),r=await a.resolve(r.resource,{resolveMetadata:!0}),e.strictEqual(t,r.size))}),test("copy - MIX CASE same target - overwrite",async()=>{let r=await a.resolve(l.file(u(n,"index.html")),{resolveMetadata:!0});const t=r.size;e.ok(t>0);const i=l.file(u(b(r.resource.fsPath),"INDEX.html")),s=await a.canCopy(r.resource,i,!0);let o,d;try{d=await a.copy(r.resource,i,!0)}catch(h){o=h}T?(e.ok(!o),e.strictEqual(s,!0),e.strictEqual(E(d.resource.fsPath),!0),e.ok(z(n).some(h=>h==="INDEX.html")),e.strictEqual(r.size,d.size)):(e.ok(o),e.ok(s instanceof Error),r=await a.resolve(r.resource,{resolveMetadata:!0}),e.strictEqual(t,r.size))}),test("copy - MIX CASE different target - overwrite",async()=>{const r=await a.resolve(l.file(u(n,"index.html")),{resolveMetadata:!0});e.ok(r.size>0);const t=await a.move(r.resource,l.file(u(b(r.resource.fsPath),"CONWAY.js")));e.strictEqual(E(t.resource.fsPath),!0),e.ok(z(n).some(d=>d==="CONWAY.js")),e.strictEqual(r.size,t.size);const i=await a.resolve(l.file(u(n,"deep","conway.js")),{resolveMetadata:!0}),s=l.file(u(n,q(i.resource.path)));e.strictEqual(await a.canCopy(i.resource,s,!0),!0);const o=await a.copy(i.resource,s,!0);e.strictEqual(E(o.resource.fsPath),!0),e.ok(z(n).some(d=>d==="conway.js")),e.strictEqual(i.size,o.size)}),test("copy - same file",async()=>{let r;w.add(a.onDidRunOperation(s=>r=s));const t=await a.resolve(l.file(u(n,"index.html")),{resolveMetadata:!0});e.ok(t.size>0),e.strictEqual(await a.canCopy(t.resource,l.file(t.resource.fsPath)),!0);let i=await a.copy(t.resource,l.file(t.resource.fsPath));e.strictEqual(E(i.resource.fsPath),!0),e.strictEqual(q(i.resource.fsPath),"index.html"),e.ok(r),e.strictEqual(r.resource.fsPath,t.resource.fsPath),e.strictEqual(r.operation,v.COPY),e.strictEqual(r.target.resource.fsPath,i.resource.fsPath),i=await a.resolve(t.resource,{resolveMetadata:!0}),e.strictEqual(t.size,i.size)}),test("copy - same file #2",async()=>{let r;w.add(a.onDidRunOperation(d=>r=d));const t=await a.resolve(l.file(u(n,"index.html")),{resolveMetadata:!0});e.ok(t.size>0);const i=l.file(n),s=i.with({path:I.join(i.path,I.basename(t.resource.path))});e.strictEqual(await a.canCopy(t.resource,l.file(s.fsPath)),!0);let o=await a.copy(t.resource,l.file(s.fsPath));e.strictEqual(E(o.resource.fsPath),!0),e.strictEqual(q(o.resource.fsPath),"index.html"),e.ok(r),e.strictEqual(r.resource.fsPath,t.resource.fsPath),e.strictEqual(r.operation,v.COPY),e.strictEqual(r.target.resource.fsPath,o.resource.fsPath),o=await a.resolve(t.resource,{resolveMetadata:!0}),e.strictEqual(t.size,o.size)}),test("cloneFile - basics",()=>te()),test("cloneFile - via copy capability",()=>(m(c,f.FileOpenReadWriteClose|f.FileFolderCopy),te())),test("cloneFile - via pipe",()=>(m(c,f.FileOpenReadWriteClose),te()));async function te(){const r=l.file(u(n,"index.html")),t=(await a.resolve(r,{resolveMetadata:!0})).size,i=l.file(u(n,"lorem.txt")),s=(await a.resolve(i,{resolveMetadata:!0})).size,o=l.file(n);await a.cloneFile(r,r);const d=o.with({path:I.join(o.path,`${I.basename(r.path)}-clone`)});await a.cloneFile(r,l.file(d.fsPath)),e.strictEqual(E(d.fsPath),!0),e.strictEqual(q(d.fsPath),"index.html-clone");let h=(await a.resolve(d,{resolveMetadata:!0})).size;e.strictEqual(t,h),await a.cloneFile(i,l.file(d.fsPath)),h=(await a.resolve(d,{resolveMetadata:!0})).size,e.strictEqual(s,h),e.notStrictEqual(t,h);const F=o.with({path:I.join(o.path,"foo","bar",`${I.basename(r.path)}-clone`)});await a.cloneFile(r,l.file(F.fsPath)),e.strictEqual(E(F.fsPath),!0),e.strictEqual(q(F.fsPath),"index.html-clone");const g=(await a.resolve(F,{resolveMetadata:!0})).size;e.strictEqual(t,g)}test("readFile - small file - default",()=>k(l.file(u(n,"small.txt")))),test("readFile - small file - buffered",()=>(m(c,f.FileOpenReadWriteClose),k(l.file(u(n,"small.txt"))))),test("readFile - small file - buffered / readonly",()=>(m(c,f.FileOpenReadWriteClose|f.Readonly),k(l.file(u(n,"small.txt"))))),test("readFile - small file - unbuffered",async()=>(m(c,f.FileReadWrite),k(l.file(u(n,"small.txt"))))),test("readFile - small file - unbuffered / readonly",async()=>(m(c,f.FileReadWrite|f.Readonly),k(l.file(u(n,"small.txt"))))),test("readFile - small file - streamed",async()=>(m(c,f.FileReadStream),k(l.file(u(n,"small.txt"))))),test("readFile - small file - streamed / readonly",async()=>(m(c,f.FileReadStream|f.Readonly),k(l.file(u(n,"small.txt"))))),test("readFile - large file - default",async()=>k(l.file(u(n,"lorem.txt")))),test("readFile - large file - buffered",async()=>(m(c,f.FileOpenReadWriteClose),k(l.file(u(n,"lorem.txt"))))),test("readFile - large file - unbuffered",async()=>(m(c,f.FileReadWrite),k(l.file(u(n,"lorem.txt"))))),test("readFile - large file - streamed",async()=>(m(c,f.FileReadStream),k(l.file(u(n,"lorem.txt"))))),test("readFile - atomic (emulated on service level)",async()=>(m(c,f.FileReadStream),k(l.file(u(n,"lorem.txt")),{atomic:!0}))),test("readFile - atomic (natively supported)",async()=>(m(c,f.FileReadWrite&f.FileAtomicRead),k(l.file(u(n,"lorem.txt")),{atomic:!0})));async function k(r,t){const i=await a.readFile(r,t);e.strictEqual(i.value.toString(),p(r.fsPath).toString())}test("readFileStream - small file - default",()=>V(l.file(u(n,"small.txt")))),test("readFileStream - small file - buffered",()=>(m(c,f.FileOpenReadWriteClose),V(l.file(u(n,"small.txt"))))),test("readFileStream - small file - unbuffered",async()=>(m(c,f.FileReadWrite),V(l.file(u(n,"small.txt"))))),test("readFileStream - small file - streamed",async()=>(m(c,f.FileReadStream),V(l.file(u(n,"small.txt")))));async function V(r){const t=await a.readFileStream(r);e.strictEqual((await be(t.value)).toString(),p(r.fsPath).toString())}test("readFile - Files are intermingled #38331 - default",async()=>Y()),test("readFile - Files are intermingled #38331 - buffered",async()=>(m(c,f.FileOpenReadWriteClose),Y())),test("readFile - Files are intermingled #38331 - unbuffered",async()=>(m(c,f.FileReadWrite),Y())),test("readFile - Files are intermingled #38331 - streamed",async()=>(m(c,f.FileReadStream),Y()));async function Y(){const r=l.file(u(n,"lorem.txt")),t=l.file(u(n,"some_utf16le.css")),i=await a.readFile(r),s=await a.readFile(t),o=await Promise.all([a.readFile(r),a.readFile(t)]);e.strictEqual(o[0].value.toString(),i.value.toString()),e.strictEqual(o[1].value.toString(),s.value.toString())}test("readFile - from position (ASCII) - default",async()=>X()),test("readFile - from position (ASCII) - buffered",async()=>(m(c,f.FileOpenReadWriteClose),X())),test("readFile - from position (ASCII) - unbuffered",async()=>(m(c,f.FileReadWrite),X())),test("readFile - from position (ASCII) - streamed",async()=>(m(c,f.FileReadStream),X()));async function X(){const r=l.file(u(n,"small.txt")),t=await a.readFile(r,{position:6});e.strictEqual(t.value.toString(),"File")}test("readFile - from position (with umlaut) - default",async()=>H()),test("readFile - from position (with umlaut) - buffered",async()=>(m(c,f.FileOpenReadWriteClose),H())),test("readFile - from position (with umlaut) - unbuffered",async()=>(m(c,f.FileReadWrite),H())),test("readFile - from position (with umlaut) - streamed",async()=>(m(c,f.FileReadStream),H()));async function H(){const r=l.file(u(n,"small_umlaut.txt")),t=await a.readFile(r,{position:Buffer.from("Small File with \xDC").length});e.strictEqual(t.value.toString(),"mlaut")}test("readFile - 3 bytes (ASCII) - default",async()=>$()),test("readFile - 3 bytes (ASCII) - buffered",async()=>(m(c,f.FileOpenReadWriteClose),$())),test("readFile - 3 bytes (ASCII) - unbuffered",async()=>(m(c,f.FileReadWrite),$())),test("readFile - 3 bytes (ASCII) - streamed",async()=>(m(c,f.FileReadStream),$()));async function $(){const r=l.file(u(n,"small.txt")),t=await a.readFile(r,{length:3});e.strictEqual(t.value.toString(),"Sma")}test("readFile - 20000 bytes (large) - default",async()=>C(2e4)),test("readFile - 20000 bytes (large) - buffered",async()=>(m(c,f.FileOpenReadWriteClose),C(2e4))),test("readFile - 20000 bytes (large) - unbuffered",async()=>(m(c,f.FileReadWrite),C(2e4))),test("readFile - 20000 bytes (large) - streamed",async()=>(m(c,f.FileReadStream),C(2e4))),test("readFile - 80000 bytes (large) - default",async()=>C(8e4)),test("readFile - 80000 bytes (large) - buffered",async()=>(m(c,f.FileOpenReadWriteClose),C(8e4))),test("readFile - 80000 bytes (large) - unbuffered",async()=>(m(c,f.FileReadWrite),C(8e4))),test("readFile - 80000 bytes (large) - streamed",async()=>(m(c,f.FileReadStream),C(8e4)));async function C(r){const t=l.file(u(n,"lorem.txt")),i=await a.readFile(t,{length:r});e.strictEqual(i.value.byteLength,r)}test("readFile - FILE_IS_DIRECTORY",async()=>{const r=l.file(u(n,"deep"));let t;try{await a.readFile(r)}catch(i){t=i}e.ok(t),e.strictEqual(t.fileOperationResult,D.FILE_IS_DIRECTORY)}),(_?test.skip:test)("readFile - FILE_NOT_DIRECTORY",async()=>{const r=l.file(u(n,"lorem.txt","file.txt"));let t;try{await a.readFile(r)}catch(i){t=i}e.ok(t),e.strictEqual(t.fileOperationResult,D.FILE_NOT_DIRECTORY)}),test("readFile - FILE_NOT_FOUND",async()=>{const r=l.file(u(n,"404.html"));let t;try{await a.readFile(r)}catch(i){t=i}e.ok(t),e.strictEqual(t.fileOperationResult,D.FILE_NOT_FOUND)}),test("readFile - FILE_NOT_MODIFIED_SINCE - default",async()=>G()),test("readFile - FILE_NOT_MODIFIED_SINCE - buffered",async()=>(m(c,f.FileOpenReadWriteClose),G())),test("readFile - FILE_NOT_MODIFIED_SINCE - unbuffered",async()=>(m(c,f.FileReadWrite),G())),test("readFile - FILE_NOT_MODIFIED_SINCE - streamed",async()=>(m(c,f.FileReadStream),G()));async function G(){const r=l.file(u(n,"index.html")),t=await a.readFile(r);c.totalBytesRead=0;let i;try{await a.readFile(r,{etag:t.etag})}catch(s){i=s}e.ok(i),e.strictEqual(i.fileOperationResult,D.FILE_NOT_MODIFIED_SINCE),e.ok(i instanceof Ie&&i.stat),e.strictEqual(c.totalBytesRead,0)}test("readFile - FILE_NOT_MODIFIED_SINCE does not fire wrongly - https://github.com/microsoft/vscode/issues/72909",async()=>{c.setInvalidStatSize(!0);const r=l.file(u(n,"index.html"));await a.readFile(r);let t;try{await a.readFile(r,{etag:void 0})}catch(i){t=i}e.ok(!t)}),test("readFile - FILE_TOO_LARGE - default",async()=>J()),test("readFile - FILE_TOO_LARGE - buffered",async()=>(m(c,f.FileOpenReadWriteClose),J())),test("readFile - FILE_TOO_LARGE - unbuffered",async()=>(m(c,f.FileReadWrite),J())),test("readFile - FILE_TOO_LARGE - streamed",async()=>(m(c,f.FileReadStream),J()));async function J(){return await ne(!1),c.setSmallStatSize(!0),ne(!0)}async function ne(r){const t=l.file(u(n,"index.html"));let i;try{await a.readFile(t,{limits:{size:10}})}catch(s){i=s}r||(e.ok(i instanceof De),e.ok(typeof i.size=="number")),e.strictEqual(i.fileOperationResult,D.FILE_TOO_LARGE)}(_?test.skip:test)("readFile - dangling symbolic link - https://github.com/microsoft/vscode/issues/116049",async()=>{const r=l.file(u(n,"small.js-link"));await S.symlink(u(n,"small.js"),r.fsPath);let t;try{await a.readFile(r)}catch(i){t=i}e.ok(t)}),test("createFile",async()=>re(r=>y.fromString(r))),test("createFile (readable)",async()=>re(r=>Se(y.fromString(r)))),test("createFile (stream)",async()=>re(r=>ke(y.fromString(r))));async function re(r){let t;w.add(a.onDidRunOperation(d=>t=d));const i="Hello World",s=l.file(u(n,"test.txt"));e.strictEqual(await a.canCreateFile(s),!0);const o=await a.createFile(s,r(i));e.strictEqual(o.name,"test.txt"),e.strictEqual(E(o.resource.fsPath),!0),e.strictEqual(p(o.resource.fsPath).toString(),i),e.ok(t),e.strictEqual(t.resource.fsPath,s.fsPath),e.strictEqual(t.operation,v.CREATE),e.strictEqual(t.target.resource.fsPath,s.fsPath)}test("createFile (does not overwrite by default)",async()=>{const r="Hello World",t=l.file(u(n,"test.txt"));de(t.fsPath,""),e.ok(await a.canCreateFile(t)instanceof Error);let i;try{await a.createFile(t,y.fromString(r))}catch(s){i=s}e.ok(i)}),test("createFile (allows to overwrite existing)",async()=>{let r;w.add(a.onDidRunOperation(o=>r=o));const t="Hello World",i=l.file(u(n,"test.txt"));de(i.fsPath,""),e.strictEqual(await a.canCreateFile(i,{overwrite:!0}),!0);const s=await a.createFile(i,y.fromString(t),{overwrite:!0});e.strictEqual(s.name,"test.txt"),e.strictEqual(E(s.resource.fsPath),!0),e.strictEqual(p(s.resource.fsPath).toString(),t),e.ok(r),e.strictEqual(r.resource.fsPath,i.fsPath),e.strictEqual(r.operation,v.CREATE),e.strictEqual(r.target.resource.fsPath,i.fsPath)}),test("writeFile - default",async()=>W(!1)),test("writeFile - flush on write",async()=>{A.configureFlushOnWrite(!0);try{return await W(!1)}finally{A.configureFlushOnWrite(!1)}}),test("writeFile - buffered",async()=>(m(c,f.FileOpenReadWriteClose),W(!1))),test("writeFile - unbuffered",async()=>(m(c,f.FileReadWrite),W(!1))),test("writeFile - default (atomic)",async()=>W(!0)),test("writeFile - flush on write (atomic)",async()=>{A.configureFlushOnWrite(!0);try{return await W(!0)}finally{A.configureFlushOnWrite(!1)}}),test("writeFile - buffered (atomic)",async()=>{m(c,f.FileOpenReadWriteClose|f.FileAtomicWrite);let r;try{await W(!0)}catch(t){r=t}e.ok(r)}),test("writeFile - unbuffered (atomic)",async()=>(m(c,f.FileReadWrite|f.FileAtomicWrite),W(!0))),(_?test.skip:test)("writeFile - atomic writing does not break symlinks",async()=>{const r=l.file(u(n,"lorem.txt-linked"));await S.symlink(u(n,"lorem.txt"),r.fsPath);const t="Updates to the lorem file";await a.writeFile(r,y.fromString(t),{atomic:{postfix:".vsctmp"}}),e.strictEqual(p(r.fsPath).toString(),t);const i=await a.resolve(r);e.strictEqual(i.isSymbolicLink,!0)});async function W(r){let t;w.add(a.onDidRunOperation(d=>t=d));const i=l.file(u(n,"small.txt")),s=p(i.fsPath).toString();e.strictEqual(s,"Small File");const o="Updates to the small file";await a.writeFile(i,y.fromString(o),{atomic:r?{postfix:".vsctmp"}:!1}),e.ok(t),e.strictEqual(t.resource.fsPath,i.fsPath),e.strictEqual(t.operation,v.WRITE),e.strictEqual(p(i.fsPath).toString(),o)}test("writeFile (large file) - default",async()=>M(!1)),test("writeFile (large file) - buffered",async()=>(m(c,f.FileOpenReadWriteClose),M(!1))),test("writeFile (large file) - unbuffered",async()=>(m(c,f.FileReadWrite),M(!1))),test("writeFile (large file) - default (atomic)",async()=>M(!0)),test("writeFile (large file) - buffered (atomic)",async()=>{m(c,f.FileOpenReadWriteClose|f.FileAtomicWrite);let r;try{await M(!0)}catch(t){r=t}e.ok(r)}),test("writeFile (large file) - unbuffered (atomic)",async()=>(m(c,f.FileReadWrite|f.FileAtomicWrite),M(!0)));async function M(r){const t=l.file(u(n,"lorem.txt")),i=p(t.fsPath),s=i.toString()+i.toString(),o=await a.writeFile(t,y.fromString(s),{atomic:r?{postfix:".vsctmp"}:!1});e.strictEqual(o.name,"lorem.txt"),e.strictEqual(p(t.fsPath).toString(),s)}test("writeFile (large file) - unbuffered (atomic) - concurrent writes with multiple services",async()=>{m(c,f.FileReadWrite|f.FileAtomicWrite);const r=l.file(u(n,"lorem.txt")),t=p(r.fsPath),i=t.toString()+t.toString(),s=[];let o=0;for(let d=0;d<10;d++){const h=w.add(new Ee(new ge));w.add(h.registerProvider(Fe.file,c)),s.push(h.writeFile(r,y.fromString(`${i}${++o}`),{atomic:{postfix:".vsctmp"}})),await me(0)}await Promise.allSettled(s),e.strictEqual(p(r.fsPath).toString(),`${i}${o}`)}),test("writeFile - buffered - readonly throws",async()=>(m(c,f.FileOpenReadWriteClose|f.Readonly),ce())),test("writeFile - unbuffered - readonly throws",async()=>(m(c,f.FileReadWrite|f.Readonly),ce()));async function ce(){const r=l.file(u(n,"small.txt")),t=p(r.fsPath).toString();e.strictEqual(t,"Small File");const i="Updates to the small file";let s;try{await a.writeFile(r,y.fromString(i))}catch(o){s=o}e.ok(s)}test("writeFile (large file) - multiple parallel writes queue up and atomic read support (via file service)",async()=>{const r=l.file(u(n,"lorem.txt")),t=p(r.fsPath),i=t.toString()+t.toString(),s=Promise.all(["0","00","000","0000","00000"].map(async d=>{const h=await a.writeFile(r,y.fromString(d+i));e.strictEqual(h.name,"lorem.txt")})),o=Promise.all(["0","00","000","0000","00000"].map(async()=>{const d=await a.readFile(r,{atomic:!0});e.ok(d.value.byteLength>0)}));await Promise.all([s,o])}),test("provider - write barrier prevents dirty writes",async()=>{const r=l.file(u(n,"lorem.txt")),t=p(r.fsPath),i=t.toString()+t.toString(),s=a.getProvider(r.scheme);e.ok(s),e.ok(B(s));const o=Promise.all(["0","00","000","0000","00000"].map(async d=>{const h=d+i,F=y.fromString(h).buffer,g=await s.open(r,{create:!0,unlock:!1});try{await s.write(g,0,y.fromString(h).buffer,0,F.byteLength),e.strictEqual((await S.readFile(r.fsPath)).toString(),h)}finally{await s.close(g)}}));await Promise.all([o])}),test("provider - write barrier is partitioned per resource",async()=>{const r=l.file(u(n,"lorem.txt")),t=l.file(u(n,"test.txt")),i=a.getProvider(r.scheme);e.ok(i),e.ok(B(i));const s=await i.open(r,{create:!0,unlock:!1}),o=await i.open(t,{create:!0,unlock:!1}),d="Hello World";try{await i.write(s,0,y.fromString(d).buffer,0,y.fromString(d).buffer.byteLength),e.strictEqual((await S.readFile(r.fsPath)).toString(),d),await i.write(o,0,y.fromString(d).buffer,0,y.fromString(d).buffer.byteLength),e.strictEqual((await S.readFile(t.fsPath)).toString(),d)}finally{await Promise.allSettled([await i.close(s),await i.close(o)])}}),test("provider - write barrier not becoming stale",async()=>{const r=u(n,"new-folder"),t=l.file(u(r,"lorem.txt")),i=a.getProvider(t.scheme);e.ok(i),e.ok(B(i));let s;try{await i.open(t,{create:!0,unlock:!1})}catch(g){s=g}e.ok(s),await S.mkdir(r);const o=p(l.file(u(n,"lorem.txt")).fsPath),d=o.toString()+o.toString(),h=y.fromString(d).buffer,F=await i.open(t,{create:!0,unlock:!1});try{await i.write(F,0,h,0,h.byteLength),e.strictEqual((await S.readFile(t.fsPath)).toString(),d)}finally{await i.close(F)}}),test("provider - atomic reads (write pending when read starts)",async()=>{const r=l.file(u(n,"lorem.txt")),t=p(r.fsPath),i=t.toString()+t.toString(),s=y.fromString(i).buffer,o=a.getProvider(r.scheme);e.ok(o),e.ok(B(o)),e.ok(we(o));let d;const h=await o.open(r,{create:!0,unlock:!1});try{d=o.readFile(r,{atomic:!0}),await me(20),await o.write(h,0,s,0,s.byteLength)}finally{await o.close(h)}e.ok(d);const F=await d;e.strictEqual(F.byteLength,s.byteLength)}),test("provider - atomic reads (read pending when write starts)",async()=>{const r=l.file(u(n,"lorem.txt")),t=p(r.fsPath),i=t.toString()+t.toString(),s=y.fromString(i).buffer,o=a.getProvider(r.scheme);e.ok(o),e.ok(B(o)),e.ok(we(o));let d=o.readFile(r,{atomic:!0});const h=o.open(r,{create:!0,unlock:!1}).then(async g=>{try{return await o.write(g,0,s,0,s.byteLength)}finally{await o.close(g)}});let F=await d;e.strictEqual(F.byteLength,t.byteLength),await h,d=o.readFile(r,{atomic:!0}),F=await d,e.strictEqual(F.byteLength,s.byteLength)}),test("writeFile (readable) - default",async()=>ie()),test("writeFile (readable) - buffered",async()=>(m(c,f.FileOpenReadWriteClose),ie())),test("writeFile (readable) - unbuffered",async()=>(m(c,f.FileReadWrite),ie()));async function ie(){const r=l.file(u(n,"small.txt")),t=p(r.fsPath).toString();e.strictEqual(t,"Small File");const i="Updates to the small file";await a.writeFile(r,ve(i)),e.strictEqual(p(r.fsPath).toString(),i)}test("writeFile (large file - readable) - default",async()=>ae()),test("writeFile (large file - readable) - buffered",async()=>(m(c,f.FileOpenReadWriteClose),ae())),test("writeFile (large file - readable) - unbuffered",async()=>(m(c,f.FileReadWrite),ae()));async function ae(){const r=l.file(u(n,"lorem.txt")),t=p(r.fsPath),i=t.toString()+t.toString(),s=await a.writeFile(r,ve(i));e.strictEqual(s.name,"lorem.txt"),e.strictEqual(p(r.fsPath).toString(),i)}test("writeFile (stream) - default",async()=>se()),test("writeFile (stream) - buffered",async()=>(m(c,f.FileOpenReadWriteClose),se())),test("writeFile (stream) - unbuffered",async()=>(m(c,f.FileReadWrite),se()));async function se(){const r=l.file(u(n,"small.txt")),t=l.file(u(n,"small-copy.txt")),i=await a.writeFile(t,he(ue(r.fsPath)));e.strictEqual(i.name,"small-copy.txt");const s=p(t.fsPath).toString();e.strictEqual(p(r.fsPath).toString(),s)}test("writeFile (large file - stream) - default",async()=>oe()),test("writeFile (large file - stream) - buffered",async()=>(m(c,f.FileOpenReadWriteClose),oe())),test("writeFile (large file - stream) - unbuffered",async()=>(m(c,f.FileReadWrite),oe()));async function oe(){const r=l.file(u(n,"lorem.txt")),t=l.file(u(n,"lorem-copy.txt")),i=await a.writeFile(t,he(ue(r.fsPath)));e.strictEqual(i.name,"lorem-copy.txt");const s=p(t.fsPath).toString();e.strictEqual(p(r.fsPath).toString(),s)}test("writeFile (file is created including parents)",async()=>{const r=l.file(u(n,"other","newfile.txt")),t="File is created including parent",i=await a.writeFile(r,y.fromString(t));e.strictEqual(i.name,"newfile.txt"),e.strictEqual(p(r.fsPath).toString(),t)}),test("writeFile - locked files and unlocking",async()=>(m(c,f.FileReadWrite|f.FileWriteUnlock),K(!1))),test("writeFile (stream) - locked files and unlocking",async()=>(m(c,f.FileOpenReadWriteClose|f.FileWriteUnlock),K(!1))),test("writeFile - locked files and unlocking throws error when missing capability",async()=>(m(c,f.FileReadWrite),K(!0))),test("writeFile (stream) - locked files and unlocking throws error when missing capability",async()=>(m(c,f.FileOpenReadWriteClose),K(!0)));async function K(r){const t=l.file(u(n,"my-locked-file")),i=await a.writeFile(t,y.fromString("Locked File"));e.strictEqual(i.locked,!1);const s=await S.stat(t.fsPath);await S.chmod(t.fsPath,s.mode&-129);let o=await a.stat(t);e.strictEqual(o.locked,!0);let d;const h="Updates to locked file";try{await a.writeFile(t,y.fromString(h))}catch(F){d=F}if(e.ok(d),d=void 0,r){try{await a.writeFile(t,y.fromString(h),{unlock:!0})}catch(F){d=F}e.ok(d)}else await a.writeFile(t,y.fromString(h),{unlock:!0}),e.strictEqual(p(t.fsPath).toString(),h),o=await a.stat(t),e.strictEqual(o.locked,!1)}test("writeFile (error when folder is encountered)",async()=>{const r=l.file(n);let t;try{await a.writeFile(r,y.fromString("File is created including parent"))}catch(i){t=i}e.ok(t)}),test("writeFile (no error when providing up to date etag)",async()=>{const r=l.file(u(n,"small.txt")),t=await a.resolve(r),i=p(r.fsPath).toString();e.strictEqual(i,"Small File");const s="Updates to the small file";await a.writeFile(r,y.fromString(s),{etag:t.etag,mtime:t.mtime}),e.strictEqual(p(r.fsPath).toString(),s)}),test("writeFile - error when writing to file that has been updated meanwhile",async()=>{const r=l.file(u(n,"small.txt")),t=await a.resolve(r),i=p(r.fsPath).toString();e.strictEqual(i,"Small File");const s="Updates to the small file";await a.writeFile(r,y.fromString(s),{etag:t.etag,mtime:t.mtime});const o=s+s,d=1e3,h=1e3;let F;try{await a.writeFile(r,y.fromString(o),{etag:pe({mtime:d,size:h}),mtime:d})}catch(g){F=g}e.ok(F),e.ok(F instanceof Ce),e.strictEqual(F.fileOperationResult,D.FILE_MODIFIED_SINCE)}),test("writeFile - no error when writing to file where size is the same",async()=>{const r=l.file(u(n,"small.txt")),t=await a.resolve(r),i=p(r.fsPath).toString();e.strictEqual(i,"Small File");const s=i;await a.writeFile(r,y.fromString(s),{etag:t.etag,mtime:t.mtime});const o=s,d=1e3,h=s.length;let F;try{await a.writeFile(r,y.fromString(o),{etag:pe({mtime:d,size:h}),mtime:d})}catch(g){F=g}e.ok(!F)}),test("writeFile - no error when writing to same nonexistent folder multiple times different new files",async()=>{const r=l.file(u(n,"some","new","folder")),t=Z(r,"file-1"),i=Z(r,"file-2"),s=Z(r,"file-3"),o="Updates to the small file";await Promise.all([a.writeFile(t,y.fromString(o)),a.writeFile(i,y.fromString(o)),a.writeFile(s,y.fromString(o))]),e.ok(a.exists(t)),e.ok(a.exists(i)),e.ok(a.exists(s))}),test("writeFile - error when writing to folder that is a file",async()=>{const r=l.file(u(n,"my-file"));await a.createFile(r);const t=Z(r,"file-1");let i;const s="Updates to the small file";try{await a.writeFile(t,y.fromString(s))}catch(o){i=o}e.ok(i)}),test("read - mixed positions",async()=>{const r=l.file(u(n,"lorem.txt"));let t=y.alloc(1024),i=await c.open(r,{create:!1});for(let o=0;o<3;o++)await c.read(i,0,t.buffer,0,26),e.strictEqual(t.slice(0,26).toString(),"Lorem ipsum dolor sit amet");await c.close(i),t=y.alloc(1024),i=await c.open(r,{create:!1});let s=0;await c.read(i,s,t.buffer,0,26),e.strictEqual(t.slice(0,26).toString(),"Lorem ipsum dolor sit amet"),s+=26,await c.read(i,s,t.buffer,0,1),e.strictEqual(t.slice(0,1).toString(),","),s+=1,await c.read(i,s,t.buffer,0,12),e.strictEqual(t.slice(0,12).toString()," consectetur"),s+=12,await c.read(i,98,t.buffer,0,9),e.strictEqual(t.slice(0,9).toString(),"fermentum"),await c.read(i,27,t.buffer,0,12),e.strictEqual(t.slice(0,12).toString()," consectetur"),await c.read(i,26,t.buffer,0,1),e.strictEqual(t.slice(0,1).toString(),","),await c.read(i,0,t.buffer,0,26),e.strictEqual(t.slice(0,26).toString(),"Lorem ipsum dolor sit amet"),await c.read(i,s,t.buffer,0,11),e.strictEqual(t.slice(0,11).toString()," adipiscing"),await c.close(i)}),test("write - mixed positions",async()=>{const r=l.file(u(n,"lorem.txt")),t=y.alloc(1024),i=await c.open(r,{create:!0,unlock:!1}),s=await c.open(r,{create:!1});let o=0,d=0;const h=y.fromString("Lorem ipsum dolor sit amet");await c.write(i,o,h.buffer,0,h.byteLength),o+=h.byteLength,await c.read(s,d,t.buffer,0,26),e.strictEqual(t.slice(0,26).toString(),"Lorem ipsum dolor sit amet"),d+=26;const F=y.fromString("Hello World");await c.write(i,o,F.buffer,0,F.byteLength),o+=F.byteLength,await c.read(s,d,t.buffer,0,F.byteLength),e.strictEqual(t.slice(0,F.byteLength).toString(),"Hello World"),d+=F.byteLength,await c.write(i,6,F.buffer,0,F.byteLength),await c.read(s,0,t.buffer,0,11),e.strictEqual(t.slice(0,11).toString(),"Lorem Hello"),await c.write(i,o,F.buffer,0,F.byteLength),o+=F.byteLength,await c.read(s,o-F.byteLength,t.buffer,0,F.byteLength),e.strictEqual(t.slice(0,F.byteLength).toString(),"Hello World"),await c.close(i),await c.close(s)}),test("readonly - is handled properly for a single resource",async()=>{c.setReadonly(!0);const r=l.file(u(n,"index.html")),t=await a.resolve(r);e.strictEqual(t.readonly,!0);const i=await a.readFile(r);e.strictEqual(i.readonly,!0);let s;try{await a.writeFile(r,y.fromString("Hello Test"))}catch(d){s=d}e.ok(s);let o;try{await a.del(r)}catch(d){o=d}e.ok(o)})});export{Pe as TestDiskFileSystemProvider};
