import{Throttler as C}from"../../../base/common/async.js";import{VSBuffer as E}from"../../../base/common/buffer.js";import{Emitter as v,Event as T}from"../../../base/common/event.js";import{Disposable as x}from"../../../base/common/lifecycle.js";import{ExtUri as N}from"../../../base/common/resources.js";import{isString as S}from"../../../base/common/types.js";import{URI as b}from"../../../base/common/uri.js";import{localize as p}from"../../../nls.js";import{createFileSystemProviderError as y,FileChangeType as B,FileSystemProviderCapabilities as R,FileSystemProviderError as _,FileSystemProviderErrorCode as c,FileType as o}from"../common/files.js";import{DBClosedError as A}from"../../../base/browser/indexedDB.js";import{BroadcastDataChannel as O}from"../../../base/browser/broadcast.js";const I=y(p("fileNotExists","File does not exist"),c.FileNotFound),W=y(p("fileIsDirectory","File is Directory"),c.FileIsADirectory),U=y(p("fileNotDirectory","File is not a directory"),c.FileNotADirectory),M=y(p("dirIsNotEmpty","Directory is not empty"),c.Unknown),P=y(p("fileExceedsStorageQuota","File exceeds available storage quota"),c.FileExceedsStorageQuota),a=u=>y(p("internal","Internal error occurred in IndexedDB File System Provider. ({0})",u),c.Unknown);class m{constructor(n){this.entry=n;this.type=n.type}type;read(n){return this.doRead(n.split("/").filter(e=>e.length))}doRead(n){if(n.length===0)return this.entry;if(this.entry.type!==o.Directory)throw a("Internal error reading from IndexedDBFSNode -- expected directory at "+this.entry.path);const e=this.entry.children.get(n[0]);if(e)return e.doRead(n.slice(1))}delete(n){const e=n.split("/").filter(t=>t.length);if(e.length===0){if(this.entry.type!==o.Directory)throw a("Internal error deleting from IndexedDBFSNode. Expected root entry to be directory");this.entry.children.clear()}else return this.doDelete(e,n)}doDelete(n,e){if(n.length===0)throw a(`Internal error deleting from IndexedDBFSNode -- got no deletion path parts (encountered while deleting ${e})`);if(this.entry.type!==o.Directory)throw a("Internal error deleting from IndexedDBFSNode -- expected directory at "+this.entry.path);if(n.length===1)this.entry.children.delete(n[0]);else{const t=this.entry.children.get(n[0]);if(!t)throw a("Internal error deleting from IndexedDBFSNode -- expected entry at "+this.entry.path+"/"+t);t.doDelete(n.slice(1),e)}}add(n,e){this.doAdd(n.split("/").filter(t=>t.length),e,n)}doAdd(n,e,t){if(n.length===0)throw a(`Internal error creating IndexedDBFSNode -- adding empty path (encountered while adding ${t})`);if(this.entry.type!==o.Directory)throw a(`Internal error creating IndexedDBFSNode -- parent is not a directory (encountered while adding ${t})`);if(n.length===1){const r=n[0],i=this.entry.children.get(r);if(e.type==="dir"){if(i?.entry.type===o.File)throw a(`Internal error creating IndexedDBFSNode -- overwriting file with directory: ${this.entry.path}/${r} (encountered while adding ${t})`);this.entry.children.set(r,i??new m({type:o.Directory,path:this.entry.path+"/"+r,children:new Map}))}else{if(i?.entry.type===o.Directory)throw a(`Internal error creating IndexedDBFSNode -- overwriting directory with file: ${this.entry.path}/${r} (encountered while adding ${t})`);this.entry.children.set(r,new m({type:o.File,path:this.entry.path+"/"+r,size:e.size}))}}else if(n.length>1){const r=n[0];let i=this.entry.children.get(r);if(!i)i=new m({children:new Map,path:this.entry.path+"/"+r,type:o.Directory}),this.entry.children.set(r,i);else if(i.type===o.File)throw a(`Internal error creating IndexedDBFSNode -- overwriting file entry with directory: ${this.entry.path}/${r} (encountered while adding ${t})`);i.doAdd(n.slice(1),e,t)}}print(n=""){this.entry.type===o.Directory&&this.entry.children.forEach(e=>e.print(n+" "))}}class se extends x{constructor(e,t,r,i){super();this.scheme=e;this.indexedDB=t;this.store=r;this.writeManyThrottler=new C,i&&(this.changesBroadcastChannel=this._register(new O(`vscode.indexedDB.${e}.changes`)),this._register(this.changesBroadcastChannel.onDidReceiveData(s=>{this._onDidChangeFile.fire(s.map(d=>({type:d.type,resource:b.revive(d.resource)})))})))}capabilities=R.FileReadWrite|R.PathCaseSensitive;onDidChangeCapabilities=T.None;extUri=new N(()=>!1);changesBroadcastChannel;_onDidChangeFile=this._register(new v);onDidChangeFile=this._onDidChangeFile.event;_onReportError=this._register(new v);onReportError=this._onReportError.event;mtimes=new Map;cachedFiletree;writeManyThrottler;watch(e,t){return x.None}async mkdir(e){try{if((await this.stat(e)).type===o.File)throw U}catch{}(await this.getFiletree()).add(e.path,{type:"dir"})}async stat(e){const t=(await this.getFiletree()).read(e.path);if(t?.type===o.File)return{type:o.File,ctime:0,mtime:this.mtimes.get(e.toString())||0,size:t.size??(await this.readFile(e)).byteLength};if(t?.type===o.Directory)return{type:o.Directory,ctime:0,mtime:0,size:0};throw I}async readdir(e){try{const t=(await this.getFiletree()).read(e.path);if(!t)return[];if(t.type!==o.Directory)throw U;return[...t.children.entries()].map(([r,i])=>[r,i.type])}catch(t){throw this.reportError("readDir",t),t}}async readFile(e){try{const t=await this.indexedDB.runInTransaction(this.store,"readonly",s=>s.get(e.path));if(t===void 0)throw I;const r=t instanceof Uint8Array?t:S(t)?E.fromString(t).buffer:void 0;if(r===void 0)throw a(`IndexedDB entry at "${e.path}" in unexpected format`);return(await this.getFiletree()).add(e.path,{type:"file",size:r.byteLength}),r}catch(t){throw this.reportError("readFile",t),t}}async writeFile(e,t,r){try{if((await this.stat(e).catch(()=>{}))?.type===o.Directory)throw W;await this.bulkWrite([[e,t]])}catch(i){throw this.reportError("writeFile",i),i}}async rename(e,t,r){const i=await this.getFiletree(),s=i.read(e.path);if(!s)throw I;const d=i.read(t.path);if(d){if(!r.overwrite)throw y("file exists already",c.FileExists);if(d.type!==s.type)throw y("Cannot rename files with different types",c.Unknown);await this.delete(t,{recursive:!0,useTrash:!1,atomic:!1})}const f=l=>this.extUri.joinPath(t,this.extUri.relativePath(e,e.with({path:l}))||""),F=await this.tree(e),g=[];for(const l of F)l[1]===o.File?g.push(l):l[1]===o.Directory&&i.add(f(l[0]).path,{type:"dir"});if(g.length){const l=[],w=await this.indexedDB.runInTransaction(this.store,"readonly",h=>g.map(([D])=>h.get(D)));for(let h=0;h<g.length;h++){const D=w[h]instanceof Uint8Array?w[h]:S(w[h])?E.fromString(w[h]).buffer:void 0;D&&l.push([f(g[h][0]),D])}await this.bulkWrite(l)}await this.delete(e,{recursive:!0,useTrash:!1,atomic:!1})}async delete(e,t){let r;try{r=await this.stat(e)}catch(s){if(s.code===c.FileNotFound)return;throw s}let i;if(t.recursive)i=(await this.tree(e)).map(([d])=>d);else{if(r.type===o.Directory&&(await this.readdir(e)).length)throw M;i=[e.path]}await this.deleteKeys(i),(await this.getFiletree()).delete(e.path),i.forEach(s=>this.mtimes.delete(s)),this.triggerChanges(i.map(s=>({resource:e.with({path:s}),type:B.DELETED})))}async tree(e){const t=await this.stat(e),r=[[e.path,t.type]];if(t.type===o.Directory){const i=await this.readdir(e);for(const[s,d]of i){const f=this.extUri.joinPath(e,s);if(r.push([f.path,d]),d===o.Directory){const F=await this.tree(f);r.push(...F)}}}return r}triggerChanges(e){e.length&&(this._onDidChangeFile.fire(e),this.changesBroadcastChannel?.postData(e))}getFiletree(){return this.cachedFiletree||(this.cachedFiletree=(async()=>{const e=new m({children:new Map,path:"",type:o.Directory});return(await this.indexedDB.runInTransaction(this.store,"readonly",i=>i.getAllKeys())).map(i=>i.toString()).forEach(i=>e.add(i,{type:"file"})),e})()),this.cachedFiletree}async bulkWrite(e){e.forEach(([r,i])=>this.fileWriteBatch.push({content:i,resource:r})),await this.writeManyThrottler.queue(()=>this.writeMany());const t=await this.getFiletree();for(const[r,i]of e)t.add(r.path,{type:"file",size:i.byteLength}),this.mtimes.set(r.toString(),Date.now());this.triggerChanges(e.map(([r])=>({resource:r,type:B.UPDATED})))}fileWriteBatch=[];async writeMany(){if(this.fileWriteBatch.length){const e=this.fileWriteBatch.splice(0,this.fileWriteBatch.length);try{await this.indexedDB.runInTransaction(this.store,"readwrite",t=>e.map(r=>t.put(r.content,r.resource.path)))}catch(t){throw t instanceof DOMException&&t.name==="QuotaExceededError"?P:t}}}async deleteKeys(e){e.length&&await this.indexedDB.runInTransaction(this.store,"readwrite",t=>e.map(r=>t.delete(r)))}async reset(){await this.indexedDB.runInTransaction(this.store,"readwrite",e=>e.clear())}reportError(e,t){this._onReportError.fire({scheme:this.scheme,operation:e,code:t instanceof _||t instanceof A?t.code:"unknown"})}}export{se as IndexedDBFileSystemProvider};
