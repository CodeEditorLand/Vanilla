{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/files/browser/htmlFileSystemProvider.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { localize } from '../../../nls.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { Event } from '../../../base/common/event.js';\nimport { Disposable, IDisposable } from '../../../base/common/lifecycle.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { basename, extname, normalize } from '../../../base/common/path.js';\nimport { isLinux } from '../../../base/common/platform.js';\nimport { extUri, extUriIgnorePathCase } from '../../../base/common/resources.js';\nimport { newWriteableStream, ReadableStreamEvents } from '../../../base/common/stream.js';\nimport { createFileSystemProviderError, IFileDeleteOptions, IFileOverwriteOptions, IFileReadStreamOptions, FileSystemProviderCapabilities, FileSystemProviderError, FileSystemProviderErrorCode, FileType, IFileWriteOptions, IFileSystemProviderWithFileReadStreamCapability, IFileSystemProviderWithFileReadWriteCapability, IStat, IWatchOptions } from '../common/files.js';\nimport { WebFileSystemAccess } from './webFileSystemAccess.js';\nimport { IndexedDB } from '../../../base/browser/indexedDB.js';\nimport { ILogService } from '../../log/common/log.js';\n\nexport class HTMLFileSystemProvider implements IFileSystemProviderWithFileReadWriteCapability, IFileSystemProviderWithFileReadStreamCapability {\n\n\t//#region Events (unsupported)\n\n\treadonly onDidChangeCapabilities = Event.None;\n\treadonly onDidChangeFile = Event.None;\n\n\t//#endregion\n\n\t//#region File Capabilities\n\n\tprivate extUri = isLinux ? extUri : extUriIgnorePathCase;\n\n\tprivate _capabilities: FileSystemProviderCapabilities | undefined;\n\tget capabilities(): FileSystemProviderCapabilities {\n\t\tif (!this._capabilities) {\n\t\t\tthis._capabilities =\n\t\t\t\tFileSystemProviderCapabilities.FileReadWrite |\n\t\t\t\tFileSystemProviderCapabilities.FileReadStream;\n\n\t\t\tif (isLinux) {\n\t\t\t\tthis._capabilities |= FileSystemProviderCapabilities.PathCaseSensitive;\n\t\t\t}\n\t\t}\n\n\t\treturn this._capabilities;\n\t}\n\n\t//#endregion\n\n\n\tconstructor(\n\t\tprivate indexedDB: IndexedDB | undefined,\n\t\tprivate readonly store: string,\n\t\tprivate logService: ILogService\n\t) { }\n\n\t//#region File Metadata Resolving\n\n\tasync stat(resource: URI): Promise<IStat> {\n\t\ttry {\n\t\t\tconst handle = await this.getHandle(resource);\n\t\t\tif (!handle) {\n\t\t\t\tthrow this.createFileSystemProviderError(resource, 'No such file or directory, stat', FileSystemProviderErrorCode.FileNotFound);\n\t\t\t}\n\n\t\t\tif (WebFileSystemAccess.isFileSystemFileHandle(handle)) {\n\t\t\t\tconst file = await handle.getFile();\n\n\t\t\t\treturn {\n\t\t\t\t\ttype: FileType.File,\n\t\t\t\t\tmtime: file.lastModified,\n\t\t\t\t\tctime: 0,\n\t\t\t\t\tsize: file.size\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\ttype: FileType.Directory,\n\t\t\t\tmtime: 0,\n\t\t\t\tctime: 0,\n\t\t\t\tsize: 0\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tasync readdir(resource: URI): Promise<[string, FileType][]> {\n\t\ttry {\n\t\t\tconst handle = await this.getDirectoryHandle(resource);\n\t\t\tif (!handle) {\n\t\t\t\tthrow this.createFileSystemProviderError(resource, 'No such file or directory, readdir', FileSystemProviderErrorCode.FileNotFound);\n\t\t\t}\n\n\t\t\tconst result: [string, FileType][] = [];\n\n\t\t\tfor await (const [name, child] of handle) {\n\t\t\t\tresult.push([name, WebFileSystemAccess.isFileSystemFileHandle(child) ? FileType.File : FileType.Directory]);\n\t\t\t}\n\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region File Reading/Writing\n\n\treadFileStream(resource: URI, opts: IFileReadStreamOptions, token: CancellationToken): ReadableStreamEvents<Uint8Array> {\n\t\tconst stream = newWriteableStream<Uint8Array>(data => VSBuffer.concat(data.map(data => VSBuffer.wrap(data))).buffer, {\n\t\t\t// Set a highWaterMark to prevent the stream\n\t\t\t// for file upload to produce large buffers\n\t\t\t// in-memory\n\t\t\thighWaterMark: 10\n\t\t});\n\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tconst handle = await this.getFileHandle(resource);\n\t\t\t\tif (!handle) {\n\t\t\t\t\tthrow this.createFileSystemProviderError(resource, 'No such file or directory, readFile', FileSystemProviderErrorCode.FileNotFound);\n\t\t\t\t}\n\n\t\t\t\tconst file = await handle.getFile();\n\n\t\t\t\t// Partial file: implemented simply via `readFile`\n\t\t\t\tif (typeof opts.length === 'number' || typeof opts.position === 'number') {\n\t\t\t\t\tlet buffer = new Uint8Array(await file.arrayBuffer());\n\n\t\t\t\t\tif (typeof opts?.position === 'number') {\n\t\t\t\t\t\tbuffer = buffer.slice(opts.position);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (typeof opts?.length === 'number') {\n\t\t\t\t\t\tbuffer = buffer.slice(0, opts.length);\n\t\t\t\t\t}\n\n\t\t\t\t\tstream.end(buffer);\n\t\t\t\t}\n\n\t\t\t\t// Entire file\n\t\t\t\telse {\n\t\t\t\t\tconst reader: ReadableStreamDefaultReader<Uint8Array> = file.stream().getReader();\n\n\t\t\t\t\tlet res = await reader.read();\n\t\t\t\t\twhile (!res.done) {\n\t\t\t\t\t\tif (token.isCancellationRequested) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Write buffer into stream but make sure to wait\n\t\t\t\t\t\t// in case the `highWaterMark` is reached\n\t\t\t\t\t\tawait stream.write(res.value);\n\n\t\t\t\t\t\tif (token.isCancellationRequested) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tres = await reader.read();\n\t\t\t\t\t}\n\t\t\t\t\tstream.end(undefined);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tstream.error(this.toFileSystemProviderError(error));\n\t\t\t\tstream.end();\n\t\t\t}\n\t\t})();\n\n\t\treturn stream;\n\t}\n\n\tasync readFile(resource: URI): Promise<Uint8Array> {\n\t\ttry {\n\t\t\tconst handle = await this.getFileHandle(resource);\n\t\t\tif (!handle) {\n\t\t\t\tthrow this.createFileSystemProviderError(resource, 'No such file or directory, readFile', FileSystemProviderErrorCode.FileNotFound);\n\t\t\t}\n\n\t\t\tconst file = await handle.getFile();\n\n\t\t\treturn new Uint8Array(await file.arrayBuffer());\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tasync writeFile(resource: URI, content: Uint8Array, opts: IFileWriteOptions): Promise<void> {\n\t\ttry {\n\t\t\tlet handle = await this.getFileHandle(resource);\n\n\t\t\t// Validate target unless { create: true, overwrite: true }\n\t\t\tif (!opts.create || !opts.overwrite) {\n\t\t\t\tif (handle) {\n\t\t\t\t\tif (!opts.overwrite) {\n\t\t\t\t\t\tthrow this.createFileSystemProviderError(resource, 'File already exists, writeFile', FileSystemProviderErrorCode.FileExists);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!opts.create) {\n\t\t\t\t\t\tthrow this.createFileSystemProviderError(resource, 'No such file, writeFile', FileSystemProviderErrorCode.FileNotFound);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Create target as needed\n\t\t\tif (!handle) {\n\t\t\t\tconst parent = await this.getDirectoryHandle(this.extUri.dirname(resource));\n\t\t\t\tif (!parent) {\n\t\t\t\t\tthrow this.createFileSystemProviderError(resource, 'No such parent directory, writeFile', FileSystemProviderErrorCode.FileNotFound);\n\t\t\t\t}\n\n\t\t\t\thandle = await parent.getFileHandle(this.extUri.basename(resource), { create: true });\n\t\t\t\tif (!handle) {\n\t\t\t\t\tthrow this.createFileSystemProviderError(resource, 'Unable to create file , writeFile', FileSystemProviderErrorCode.Unknown);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Write to target overwriting any existing contents\n\t\t\tconst writable = await handle.createWritable();\n\t\t\tawait writable.write(content);\n\t\t\tawait writable.close();\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region Move/Copy/Delete/Create Folder\n\n\tasync mkdir(resource: URI): Promise<void> {\n\t\ttry {\n\t\t\tconst parent = await this.getDirectoryHandle(this.extUri.dirname(resource));\n\t\t\tif (!parent) {\n\t\t\t\tthrow this.createFileSystemProviderError(resource, 'No such parent directory, mkdir', FileSystemProviderErrorCode.FileNotFound);\n\t\t\t}\n\n\t\t\tawait parent.getDirectoryHandle(this.extUri.basename(resource), { create: true });\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tasync delete(resource: URI, opts: IFileDeleteOptions): Promise<void> {\n\t\ttry {\n\t\t\tconst parent = await this.getDirectoryHandle(this.extUri.dirname(resource));\n\t\t\tif (!parent) {\n\t\t\t\tthrow this.createFileSystemProviderError(resource, 'No such parent directory, delete', FileSystemProviderErrorCode.FileNotFound);\n\t\t\t}\n\n\t\t\treturn parent.removeEntry(this.extUri.basename(resource), { recursive: opts.recursive });\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tasync rename(from: URI, to: URI, opts: IFileOverwriteOptions): Promise<void> {\n\t\ttry {\n\t\t\tif (this.extUri.isEqual(from, to)) {\n\t\t\t\treturn; // no-op if the paths are the same\n\t\t\t}\n\n\t\t\t// Implement file rename by write + delete\n\t\t\tconst fileHandle = await this.getFileHandle(from);\n\t\t\tif (fileHandle) {\n\t\t\t\tconst file = await fileHandle.getFile();\n\t\t\t\tconst contents = new Uint8Array(await file.arrayBuffer());\n\n\t\t\t\tawait this.writeFile(to, contents, { create: true, overwrite: opts.overwrite, unlock: false, atomic: false });\n\t\t\t\tawait this.delete(from, { recursive: false, useTrash: false, atomic: false });\n\t\t\t}\n\n\t\t\t// File API does not support any real rename otherwise\n\t\t\telse {\n\t\t\t\tthrow this.createFileSystemProviderError(from, localize('fileSystemRenameError', \"Rename is only supported for files.\"), FileSystemProviderErrorCode.Unavailable);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region File Watching (unsupported)\n\n\twatch(resource: URI, opts: IWatchOptions): IDisposable {\n\t\treturn Disposable.None;\n\t}\n\n\t//#endregion\n\n\t//#region File/Directoy Handle Registry\n\n\tprivate readonly _files = new Map<string, FileSystemFileHandle>();\n\tprivate readonly _directories = new Map<string, FileSystemDirectoryHandle>();\n\n\tregisterFileHandle(handle: FileSystemFileHandle): Promise<URI> {\n\t\treturn this.registerHandle(handle, this._files);\n\t}\n\n\tregisterDirectoryHandle(handle: FileSystemDirectoryHandle): Promise<URI> {\n\t\treturn this.registerHandle(handle, this._directories);\n\t}\n\n\tget directories(): Iterable<FileSystemDirectoryHandle> {\n\t\treturn this._directories.values();\n\t}\n\n\tprivate async registerHandle(handle: FileSystemHandle, map: Map<string, FileSystemHandle>): Promise<URI> {\n\t\tlet handleId = `/${handle.name}`;\n\n\t\t// Compute a valid handle ID in case this exists already\n\t\tif (map.has(handleId) && !await map.get(handleId)?.isSameEntry(handle)) {\n\t\t\tconst fileExt = extname(handle.name);\n\t\t\tconst fileName = basename(handle.name, fileExt);\n\n\t\t\tlet handleIdCounter = 1;\n\t\t\tdo {\n\t\t\t\thandleId = `/${fileName}-${handleIdCounter++}${fileExt}`;\n\t\t\t} while (map.has(handleId) && !await map.get(handleId)?.isSameEntry(handle));\n\t\t}\n\n\t\tmap.set(handleId, handle);\n\n\t\t// Remember in IndexDB for future lookup\n\t\ttry {\n\t\t\tawait this.indexedDB?.runInTransaction(this.store, 'readwrite', objectStore => objectStore.put(handle, handleId));\n\t\t} catch (error) {\n\t\t\tthis.logService.error(error);\n\t\t}\n\n\t\treturn URI.from({ scheme: Schemas.file, path: handleId });\n\t}\n\n\tasync getHandle(resource: URI): Promise<FileSystemHandle | undefined> {\n\n\t\t// First: try to find a well known handle first\n\t\tlet handle = await this.doGetHandle(resource);\n\n\t\t// Second: walk up parent directories and resolve handle if possible\n\t\tif (!handle) {\n\t\t\tconst parent = await this.getDirectoryHandle(this.extUri.dirname(resource));\n\t\t\tif (parent) {\n\t\t\t\tconst name = extUri.basename(resource);\n\t\t\t\ttry {\n\t\t\t\t\thandle = await parent.getFileHandle(name);\n\t\t\t\t} catch (error) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\thandle = await parent.getDirectoryHandle(name);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t// Ignore\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn handle;\n\t}\n\n\tprivate async getFileHandle(resource: URI): Promise<FileSystemFileHandle | undefined> {\n\t\tconst handle = await this.doGetHandle(resource);\n\t\tif (handle instanceof FileSystemFileHandle) {\n\t\t\treturn handle;\n\t\t}\n\n\t\tconst parent = await this.getDirectoryHandle(this.extUri.dirname(resource));\n\n\t\ttry {\n\t\t\treturn await parent?.getFileHandle(extUri.basename(resource));\n\t\t} catch (error) {\n\t\t\treturn undefined; // guard against possible DOMException\n\t\t}\n\t}\n\n\tprivate async getDirectoryHandle(resource: URI): Promise<FileSystemDirectoryHandle | undefined> {\n\t\tconst handle = await this.doGetHandle(resource);\n\t\tif (handle instanceof FileSystemDirectoryHandle) {\n\t\t\treturn handle;\n\t\t}\n\n\t\tconst parentUri = this.extUri.dirname(resource);\n\t\tif (this.extUri.isEqual(parentUri, resource)) {\n\t\t\treturn undefined; // return when root is reached to prevent infinite recursion\n\t\t}\n\n\t\tconst parent = await this.getDirectoryHandle(parentUri);\n\n\t\ttry {\n\t\t\treturn await parent?.getDirectoryHandle(extUri.basename(resource));\n\t\t} catch (error) {\n\t\t\treturn undefined; // guard against possible DOMException\n\t\t}\n\t}\n\n\tprivate async doGetHandle(resource: URI): Promise<FileSystemHandle | undefined> {\n\n\t\t// We store file system handles with the `handle.name`\n\t\t// and as such require the resource to be on the root\n\t\tif (this.extUri.dirname(resource).path !== '/') {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst handleId = resource.path.replace(/\\/$/, ''); // remove potential slash from the end of the path\n\n\t\t// First: check if we have a known handle stored in memory\n\t\tconst inMemoryHandle = this._files.get(handleId) ?? this._directories.get(handleId);\n\t\tif (inMemoryHandle) {\n\t\t\treturn inMemoryHandle;\n\t\t}\n\n\t\t// Second: check if we have a persisted handle in IndexedDB\n\t\tconst persistedHandle = await this.indexedDB?.runInTransaction(this.store, 'readonly', store => store.get(handleId));\n\t\tif (WebFileSystemAccess.isFileSystemHandle(persistedHandle)) {\n\t\t\tlet hasPermissions = await persistedHandle.queryPermission() === 'granted';\n\t\t\ttry {\n\t\t\t\tif (!hasPermissions) {\n\t\t\t\t\thasPermissions = await persistedHandle.requestPermission() === 'granted';\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.error(error); // this can fail with a DOMException\n\t\t\t}\n\n\t\t\tif (hasPermissions) {\n\t\t\t\tif (WebFileSystemAccess.isFileSystemFileHandle(persistedHandle)) {\n\t\t\t\t\tthis._files.set(handleId, persistedHandle);\n\t\t\t\t} else if (WebFileSystemAccess.isFileSystemDirectoryHandle(persistedHandle)) {\n\t\t\t\t\tthis._directories.set(handleId, persistedHandle);\n\t\t\t\t}\n\n\t\t\t\treturn persistedHandle;\n\t\t\t}\n\t\t}\n\n\t\t// Third: fail with an error\n\t\tthrow this.createFileSystemProviderError(resource, 'No file system handle registered', FileSystemProviderErrorCode.Unavailable);\n\t}\n\n\t//#endregion\n\n\tprivate toFileSystemProviderError(error: Error): FileSystemProviderError {\n\t\tif (error instanceof FileSystemProviderError) {\n\t\t\treturn error; // avoid double conversion\n\t\t}\n\n\t\tlet code = FileSystemProviderErrorCode.Unknown;\n\t\tif (error.name === 'NotAllowedError') {\n\t\t\terror = new Error(localize('fileSystemNotAllowedError', \"Insufficient permissions. Please retry and allow the operation.\"));\n\t\t\tcode = FileSystemProviderErrorCode.Unavailable;\n\t\t}\n\n\t\treturn createFileSystemProviderError(error, code);\n\t}\n\n\tprivate createFileSystemProviderError(resource: URI, msg: string, code: FileSystemProviderErrorCode): FileSystemProviderError {\n\t\treturn createFileSystemProviderError(new Error(`${msg} (${normalize(resource.path)})`), code);\n\t}\n}\n"],
  "mappings": "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",
  "names": ["data", "error"]
}
