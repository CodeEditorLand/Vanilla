import{promises as h}from"fs";import{Barrier as R,retry as C}from"../../../base/common/async.js";import{VSBuffer as S}from"../../../base/common/buffer.js";import{Event as g}from"../../../base/common/event.js";import{isEqual as k}from"../../../base/common/extpath.js";import{DisposableStore as I,toDisposable as W}from"../../../base/common/lifecycle.js";import{ResourceMap as L}from"../../../base/common/map.js";import{basename as F,dirname as P,join as U}from"../../../base/common/path.js";import{isLinux as O,isWindows as T}from"../../../base/common/platform.js";import{extUriBiasedIgnorePathCase as A,joinPath as E,basename as D,dirname as N}from"../../../base/common/resources.js";import{newWriteableStream as x}from"../../../base/common/stream.js";import{Promises as m,RimRafMode as H,SymlinkSupport as u}from"../../../base/node/pfs.js";import{localize as d}from"../../../nls.js";import{AbstractDiskFileSystemProvider as M}from"../common/diskFileSystemProvider.js";import{FilePermission as $,FileSystemProviderCapabilities as c,FileSystemProviderError as _,FileSystemProviderErrorCode as n,FileType as y,createFileSystemProviderError as p,isFileOpenForWriteOptions as v}from"../common/files.js";import{readFileIntoStream as z}from"../common/io.js";import{NodeJSWatcherClient as B}from"./watcher/nodejs/nodejsClient.js";import{UniversalWatcherClient as j}from"./watcher/watcherClient.js";class f extends M{static TRACE_LOG_RESOURCE_LOCKS=!1;constructor(e,t){super(e,t)}onDidChangeCapabilities=g.None;_capabilities;get capabilities(){return this._capabilities||(this._capabilities=c.FileReadWrite|c.FileOpenReadWriteClose|c.FileReadStream|c.FileFolderCopy|c.FileWriteUnlock|c.FileAtomicRead|c.FileAtomicWrite|c.FileAtomicDelete|c.FileClone,O&&(this._capabilities|=c.PathCaseSensitive)),this._capabilities}async stat(e){try{const{stat:t,symbolicLink:i}=await u.stat(this.toFilePath(e));return{type:this.toType(t,i),ctime:t.birthtime.getTime(),mtime:t.mtime.getTime(),size:t.size,permissions:t.mode&128?void 0:$.Locked}}catch(t){throw this.toFileSystemProviderError(t)}}async statIgnoreError(e){try{return await this.stat(e)}catch{return}}async readdir(e){try{const t=await m.readdir(this.toFilePath(e),{withFileTypes:!0}),i=[];return await Promise.all(t.map(async r=>{try{let o;r.isSymbolicLink()?o=(await this.stat(E(e,r.name))).type:o=this.toType(r),i.push([r.name,o])}catch(o){this.logService.trace(o)}})),i}catch(t){throw this.toFileSystemProviderError(t)}}toType(e,t){let i;return t?.dangling?i=y.Unknown:e.isFile()?i=y.File:e.isDirectory()?i=y.Directory:i=y.Unknown,t&&(i|=y.SymbolicLink),i}resourceLocks=new L(e=>A.getComparisonKey(e));async createResourceLock(e){const t=this.toFilePath(e);this.traceLock(`[Disk FileSystemProvider]: createResourceLock() - request to acquire resource lock (${t})`);let i;for(;i=this.resourceLocks.get(e);)this.traceLock(`[Disk FileSystemProvider]: createResourceLock() - waiting for resource lock to be released (${t})`),await i.wait();const r=new R;return this.resourceLocks.set(e,r),this.traceLock(`[Disk FileSystemProvider]: createResourceLock() - new resource lock created (${t})`),W(()=>{this.traceLock(`[Disk FileSystemProvider]: createResourceLock() - resource lock dispose() (${t})`),this.resourceLocks.get(e)===r&&(this.traceLock(`[Disk FileSystemProvider]: createResourceLock() - resource lock removed from resource-lock map (${t})`),this.resourceLocks.delete(e)),this.traceLock(`[Disk FileSystemProvider]: createResourceLock() - resource lock barrier open() (${t})`),r.open()})}async readFile(e,t){let i;try{t?.atomic&&(this.traceLock(`[Disk FileSystemProvider]: atomic read operation started (${this.toFilePath(e)})`),i=await this.createResourceLock(e));const r=this.toFilePath(e);return await h.readFile(r)}catch(r){throw this.toFileSystemProviderError(r)}finally{i?.dispose()}}traceLock(e){f.TRACE_LOG_RESOURCE_LOCKS&&this.logService.trace(e)}readFileStream(e,t,i){const r=x(o=>S.concat(o.map(a=>S.wrap(a))).buffer);return z(this,e,r,o=>o.buffer,{...t,bufferSize:256*1024},i),r}async writeFile(e,t,i){return i?.atomic!==!1&&i?.atomic?.postfix&&await this.canWriteFileAtomic(e)?this.doWriteFileAtomic(e,E(N(e),`${D(e)}${i.atomic.postfix}`),t,i):this.doWriteFile(e,t,i)}async canWriteFileAtomic(e){try{const t=this.toFilePath(e),{symbolicLink:i}=await u.stat(t);if(i)return!1}catch{}return!0}async doWriteFileAtomic(e,t,i,r){const o=new I;try{o.add(await this.createResourceLock(e)),o.add(await this.createResourceLock(t)),await this.doWriteFile(t,i,r,!0);try{await this.rename(t,e,{overwrite:!0})}catch(a){try{await this.delete(t,{recursive:!1,useTrash:!1,atomic:!1})}catch{}throw a}}finally{o.dispose()}}async doWriteFile(e,t,i,r){let o;try{const a=this.toFilePath(e);if(!i.create||!i.overwrite){if(await m.exists(a)){if(!i.overwrite)throw p(d("fileExists","File already exists"),n.FileExists)}else if(!i.create)throw p(d("fileNotExists","File does not exist"),n.FileNotFound)}o=await this.open(e,{create:!0,unlock:i.unlock},r),await this.write(o,0,t,0,t.byteLength)}catch(a){throw await this.toFileSystemProviderWriteError(e,a)}finally{typeof o=="number"&&await this.close(o)}}mapHandleToPos=new Map;mapHandleToLock=new Map;writeHandles=new Map;static canFlush=!0;static configureFlushOnWrite(e){f.canFlush=e}async open(e,t,i){const r=this.toFilePath(e);let o;v(t)&&!i&&(o=await this.createResourceLock(e));let a;try{if(v(t)&&t.unlock)try{const{stat:l}=await u.stat(r);l.mode&128||await h.chmod(r,l.mode|128)}catch(l){l.code!=="ENOENT"&&this.logService.trace(l)}let s;if(v(t)){if(T)try{await h.truncate(r,0),s="r+"}catch(l){l.code!=="ENOENT"&&this.logService.trace(l)}s||(s="w")}else s="r";a=await m.open(r,s)}catch(s){throw o?.dispose(),v(t)?await this.toFileSystemProviderWriteError(e,s):this.toFileSystemProviderError(s)}if(this.mapHandleToPos.set(a,0),v(t)&&this.writeHandles.set(a,e),o){const s=this.mapHandleToLock.get(a);this.traceLock(`[Disk FileSystemProvider]: open() - storing lock for handle ${a} (${r})`),this.mapHandleToLock.set(a,o),s&&(this.traceLock(`[Disk FileSystemProvider]: open() - disposing a previous lock that was still stored on same handle ${a} (${r})`),s.dispose())}return a}async close(e){const t=this.mapHandleToLock.get(e);try{if(this.mapHandleToPos.delete(e),this.writeHandles.delete(e)&&f.canFlush)try{await m.fdatasync(e)}catch(i){f.configureFlushOnWrite(!1),this.logService.error(i)}return await m.close(e)}catch(i){throw this.toFileSystemProviderError(i)}finally{t&&(this.mapHandleToLock.get(e)===t&&(this.traceLock(`[Disk FileSystemProvider]: close() - resource lock removed from handle-lock map ${e}`),this.mapHandleToLock.delete(e)),this.traceLock(`[Disk FileSystemProvider]: close() - disposing lock for handle ${e}`),t.dispose())}}async read(e,t,i,r,o){const a=this.normalizePos(e,t);let s=null;try{s=(await m.read(e,i,r,o,a)).bytesRead}catch(l){throw this.toFileSystemProviderError(l)}finally{this.updatePos(e,a,s)}return s}normalizePos(e,t){return t===this.mapHandleToPos.get(e)?null:t}updatePos(e,t,i){const r=this.mapHandleToPos.get(e);typeof r=="number"&&(typeof t=="number"||(typeof i=="number"?this.mapHandleToPos.set(e,r+i):this.mapHandleToPos.delete(e)))}async write(e,t,i,r,o){return C(()=>this.doWrite(e,t,i,r,o),100,3)}async doWrite(e,t,i,r,o){const a=this.normalizePos(e,t);let s=null;try{s=(await m.write(e,i,r,o,a)).bytesWritten}catch(l){throw await this.toFileSystemProviderWriteError(this.writeHandles.get(e),l)}finally{this.updatePos(e,a,s)}return s}async mkdir(e){try{await h.mkdir(this.toFilePath(e))}catch(t){throw this.toFileSystemProviderError(t)}}async delete(e,t){try{const i=this.toFilePath(e);if(t.recursive){let r;t?.atomic!==!1&&t.atomic.postfix&&(r=U(P(i),`${F(i)}${t.atomic.postfix}`)),await m.rm(i,H.MOVE,r)}else try{await h.unlink(i)}catch(r){if(r.code==="EPERM"||r.code==="EISDIR"){let o=!1;try{const{stat:a,symbolicLink:s}=await u.stat(i);o=a.isDirectory()&&!s}catch{}if(o)await h.rmdir(i);else throw r}else throw r}}catch(i){throw this.toFileSystemProviderError(i)}}async rename(e,t,i){const r=this.toFilePath(e),o=this.toFilePath(t);if(r!==o)try{await this.validateMoveCopy(e,t,"move",i.overwrite),await m.rename(r,o)}catch(a){throw(a.code==="EINVAL"||a.code==="EBUSY"||a.code==="ENAMETOOLONG")&&(a=new Error(d("moveError","Unable to move '{0}' into '{1}' ({2}).",F(r),F(P(o)),a.toString()))),this.toFileSystemProviderError(a)}}async copy(e,t,i){const r=this.toFilePath(e),o=this.toFilePath(t);if(r!==o)try{await this.validateMoveCopy(e,t,"copy",i.overwrite),await m.copy(r,o,{preserveSymlinks:!0})}catch(a){throw(a.code==="EINVAL"||a.code==="EBUSY"||a.code==="ENAMETOOLONG")&&(a=new Error(d("copyError","Unable to copy '{0}' into '{1}' ({2}).",F(r),F(P(o)),a.toString()))),this.toFileSystemProviderError(a)}}async validateMoveCopy(e,t,i,r){const o=this.toFilePath(e),a=this.toFilePath(t);let s=!1;if(!!(this.capabilities&c.PathCaseSensitive)||(s=k(o,a,!0)),s){if(i==="copy")throw p(d("fileCopyErrorPathCase","File cannot be copied to same path with different path case"),n.FileExists);if(i==="move")return}const w=await this.statIgnoreError(e);if(!w)throw p(d("fileMoveCopyErrorNotFound","File to move/copy does not exist"),n.FileNotFound);const b=await this.statIgnoreError(t);if(b){if(!r)throw p(d("fileMoveCopyErrorExists","File at target already exists and thus will not be moved/copied to unless overwrite is specified"),n.FileExists);w.type&y.File&&b.type&y.File||await this.delete(t,{recursive:!0,useTrash:!1,atomic:!1})}}async cloneFile(e,t){return this.doCloneFile(e,t,!1)}async doCloneFile(e,t,i){const r=this.toFilePath(e),o=this.toFilePath(t),a=!!(this.capabilities&c.PathCaseSensitive);if(k(r,o,!a))return;const s=new I;try{s.add(await this.createResourceLock(e)),s.add(await this.createResourceLock(t)),i&&await h.mkdir(P(o),{recursive:!0}),await h.copyFile(r,o)}catch(l){if(l.code==="ENOENT"&&!i)return this.doCloneFile(e,t,!0);throw this.toFileSystemProviderError(l)}finally{s.dispose()}}createUniversalWatcher(e,t,i){return new j(r=>e(r),r=>t(r),i)}createNonRecursiveWatcher(e,t,i){return new B(r=>e(r),r=>t(r),i)}toFileSystemProviderError(e){if(e instanceof _)return e;let t=e,i;switch(e.code){case"ENOENT":i=n.FileNotFound;break;case"EISDIR":i=n.FileIsADirectory;break;case"ENOTDIR":i=n.FileNotADirectory;break;case"EEXIST":i=n.FileExists;break;case"EPERM":case"EACCES":i=n.NoPermissions;break;case"ERR_UNC_HOST_NOT_ALLOWED":t=`${e.message}. Please update the 'security.allowedUNCHosts' setting if you want to allow this host.`,i=n.Unknown;break;default:i=n.Unknown}return p(t,i)}async toFileSystemProviderWriteError(e,t){let i=this.toFileSystemProviderError(t);if(e&&i.code===n.NoPermissions)try{const{stat:r}=await u.stat(this.toFilePath(e));r.mode&128||(i=p(t,n.FileWriteLocked))}catch(r){this.logService.trace(r)}return i}}export{f as DiskFileSystemProvider};
