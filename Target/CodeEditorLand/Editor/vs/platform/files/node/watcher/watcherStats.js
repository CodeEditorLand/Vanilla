import{isRecursiveWatchRequest as I,requestFilterToString as w}from"../../common/watcher.js";import"./nodejs/nodejsWatcher.js";import"./parcel/parcelWatcher.js";function k(s,i,t,n){const e=[],r=R(s.filter(a=>I(a))),c=r.filter(a=>t.isSuspended(a)===!1),o=r.filter(a=>t.isSuspended(a)==="polling"),g=r.filter(a=>t.isSuspended(a)===!0),u=P(r,t),l=m(t),d=R(s.filter(a=>!I(a))),x=d.filter(a=>n.isSuspended(a)===!1),y=d.filter(a=>n.isSuspended(a)==="polling"),J=d.filter(a=>n.isSuspended(a)===!0),h=P(d,n),p=N(n);e.push("[Summary]"),e.push(`- Recursive Requests:     total: ${r.length}, suspended: ${u.suspended}, polling: ${u.polling}, failed: ${i}`),e.push(`- Non-Recursive Requests: total: ${d.length}, suspended: ${h.suspended}, polling: ${h.polling}`),e.push(`- Recursive Watchers:     total: ${t.watchers.size}, active: ${l.active}, failed: ${l.failed}, stopped: ${l.stopped}`),e.push(`- Non-Recursive Watchers: total: ${n.watchers.size}, active: ${p.active}, failed: ${p.failed}, reusing: ${p.reusing}`),e.push(`- I/O Handles Impact:     total: ${u.polling+h.polling+l.active+p.active}`),e.push(`
[Recursive Requests (${r.length}, suspended: ${u.suspended}, polling: ${u.polling})]:`);const $=[];for(const a of[c,o,g].flat())b($,a,t);e.push(...f($));const W=[];E(W,t),e.push(...f(W)),e.push(`
[Non-Recursive Requests (${d.length}, suspended: ${h.suspended}, polling: ${h.polling})]:`);const S=[];for(const a of[x,y,J].flat())b(S,a,n);e.push(...f(S));const q=[];return D(q,n),e.push(...f(q)),`

[File Watcher] request stats:

${e.join(`
`)}

`}function f(s){let i=0;for(const t of s)i=Math.max(i,t.split("	")[0].length);for(let t=0;t<s.length;t++){const e=s[t].split("	");if(e.length===2){const r=" ".repeat(i-e[0].length);s[t]=`${e[0]}${r}	${e[1]}`}}return s}function P(s,i){let t=0,n=0;for(const e of s){const r=i.isSuspended(e);r!==!1&&(n++,r==="polling"&&t++)}return{suspended:n,polling:t}}function m(s){let i=0,t=0,n=0;for(const e of s.watchers.values())!e.failed&&!e.stopped&&i++,e.failed&&t++,e.stopped&&n++;return{active:i,failed:t,stopped:n}}function N(s){let i=0,t=0,n=0;for(const e of s.watchers)!e.instance.failed&&!e.instance.isReusingRecursiveWatcher&&i++,e.instance.failed&&t++,e.instance.isReusingRecursiveWatcher&&n++;return{active:i,failed:t,reusing:n}}function R(s){return s.sort((i,t)=>{const n=U(i)?i.path:i.request.path,e=U(t)?t.path:t.request.path,r=Math.min(n.length,e.length);for(let c=0;c<r;c++)if(n[c]!==e[c])return n[c]<e[c]?-1:1;return n.length-e.length}),s}function U(s){return typeof s?.path=="string"}function b(s,i,t){const n=[],e=t.isSuspended(i);e!==!1&&(e==="polling"?n.push("[SUSPENDED <polling>]"):n.push("[SUSPENDED <non-polling>]")),s.push(` ${i.path}	${n.length>0?n.join(" ")+" ":""}(${v(i)})`)}function v(s){return`excludes: ${s.excludes.length>0?s.excludes:"<none>"}, includes: ${s.includes&&s.includes.length>0?JSON.stringify(s.includes):"<all>"}, filter: ${w(s.filter)}, correlationId: ${typeof s.correlationId=="number"?s.correlationId:"<none>"}`}function E(s,i){const t=R(Array.from(i.watchers.values())),{active:n,failed:e,stopped:r}=m(i);s.push(`
[Recursive Watchers (${t.length}, active: ${n}, failed: ${e}, stopped: ${r})]:`);for(const c of t){const o=[];c.failed&&o.push("[FAILED]"),c.stopped&&o.push("[STOPPED]"),c.subscriptionsCount>0&&o.push(`[SUBSCRIBED:${c.subscriptionsCount}]`),c.restarts>0&&o.push(`[RESTARTED:${c.restarts}]`),s.push(` ${c.request.path}	${o.length>0?o.join(" ")+" ":""}(${v(c.request)})`)}}function D(s,i){const t=R(Array.from(i.watchers.values())),n=t.filter(u=>!u.instance.failed&&!u.instance.isReusingRecursiveWatcher),e=t.filter(u=>u.instance.failed),r=t.filter(u=>u.instance.isReusingRecursiveWatcher),{active:c,failed:o,reusing:g}=N(i);s.push(`
[Non-Recursive Watchers (${t.length}, active: ${c}, failed: ${o}, reusing: ${g})]:`);for(const u of[n,e,r].flat()){const l=[];u.instance.failed&&l.push("[FAILED]"),u.instance.isReusingRecursiveWatcher&&l.push("[REUSING]"),s.push(` ${u.request.path}	${l.length>0?l.join(" ")+" ":""}(${v(u.request)})`)}}export{k as computeStats};
