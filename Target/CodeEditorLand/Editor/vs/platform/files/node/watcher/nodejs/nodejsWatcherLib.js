import{watch as I,promises as k}from"fs";import{RunOnceWorker as $,ThrottledWorker as A}from"../../../../../base/common/async.js";import{CancellationTokenSource as C}from"../../../../../base/common/cancellation.js";import{isEqualOrParent as T}from"../../../../../base/common/extpath.js";import{Disposable as x,DisposableStore as W,toDisposable as m}from"../../../../../base/common/lifecycle.js";import{normalizeNFC as P}from"../../../../../base/common/normalization.js";import{basename as R,dirname as _,join as N}from"../../../../../base/common/path.js";import{isLinux as S,isMacintosh as b}from"../../../../../base/common/platform.js";import{joinPath as F}from"../../../../../base/common/resources.js";import{URI as q}from"../../../../../base/common/uri.js";import{realcase as H}from"../../../../../base/node/extpath.js";import{Promises as u}from"../../../../../base/node/pfs.js";import{FileChangeType as h}from"../../../common/files.js";import{coalesceEvents as U,parseWatcherPatterns as L,isFiltered as M,isWatchRequestWithCorrelation as j}from"../../../common/watcher.js";class v extends x{constructor(e,t,i,o,r,n){super();this.request=e;this.recursiveWatcher=t;this.onDidFilesChange=i;this.onDidWatchFail=o;this.onLogMessage=r;this.verboseLogging=n}static FILE_DELETE_HANDLER_DELAY=100;static FILE_CHANGES_HANDLER_DELAY=75;throttledFileChangesEmitter=this._register(new A({maxWorkChunkSize:100,throttleDelay:200,maxBufferedWork:1e4},e=>this.onDidFilesChange(e)));fileChangesAggregator=this._register(new $(e=>this.handleFileChanges(e),v.FILE_CHANGES_HANDLER_DELAY));excludes=L(this.request.path,this.request.excludes);includes=this.request.includes?L(this.request.path,this.request.includes):void 0;filter=j(this.request)?this.request.filter:void 0;cts=new C;ready=this.watch();_isReusingRecursiveWatcher=!1;get isReusingRecursiveWatcher(){return this._isReusingRecursiveWatcher}didFail=!1;get failed(){return this.didFail}async watch(){try{const e=await this.normalizePath(this.request);if(this.cts.token.isCancellationRequested)return;const t=await k.stat(e);if(this.cts.token.isCancellationRequested)return;this._register(await this.doWatch(e,t.isDirectory()))}catch(e){e.code!=="ENOENT"?this.error(e):this.trace(`ignoring a path for watching who's stat info failed to resolve: ${this.request.path} (error: ${e})`),this.notifyWatchFailed()}}notifyWatchFailed(){this.didFail=!0,this.onDidWatchFail?.()}async normalizePath(e){let t=e.path;try{t=await u.realpath(e.path),e.path===t&&(t=await H(e.path,this.cts.token)??e.path),e.path!==t&&this.trace(`correcting a path to watch that seems to be a symbolic link or wrong casing (original: ${e.path}, real: ${t})`)}catch{}return t}async doWatch(e,t){const i=new W;return this.doWatchWithExistingWatcher(e,t,i)?(this.trace(`reusing an existing recursive watcher for ${this.request.path}`),this._isReusingRecursiveWatcher=!0):(this._isReusingRecursiveWatcher=!1,await this.doWatchWithNodeJS(e,t,i)),i}doWatchWithExistingWatcher(e,t,i){if(t)return!1;const o=q.file(this.request.path),r=this.recursiveWatcher?.subscribe(this.request.path,async(n,c)=>{if(!i.isDisposed)if(n){const l=await this.doWatch(e,t);i.isDisposed?l.dispose():i.add(l)}else c&&(typeof c.cId=="number"||typeof this.request.correlationId=="number")&&this.onFileChange({resource:o,type:c.type,cId:this.request.correlationId},!0)});return r?(i.add(r),!0):!1}async doWatchWithNodeJS(e,t,i){if(b&&T(e,"/Volumes/",!0)){this.error(`Refusing to watch ${e} for changes using fs.watch() for possibly being a network share where watching is unreliable and unstable.`);return}const o=new C(this.cts.token);i.add(m(()=>o.dispose(!0)));const r=new W;i.add(r);try{const n=q.file(this.request.path),c=R(e),l=I(e);r.add(m(()=>{l.removeAllListeners(),l.close()})),this.trace(`Started watching: '${e}'`);const g=new Set;if(t)try{for(const a of await u.readdir(e))g.add(a)}catch(a){this.error(a)}if(o.token.isCancellationRequested)return;const f=new Map;r.add(m(()=>{for(const[,a]of f)a.dispose();f.clear()})),l.on("error",(a,d)=>{o.token.isCancellationRequested||(this.error(`Failed to watch ${e} for changes using fs.watch() (${a}, ${d})`),this.notifyWatchFailed())}),l.on("change",(a,d)=>{if(o.token.isCancellationRequested)return;this.verboseLogging&&this.traceWithCorrelation(`[raw] ["${a}"] ${d}`);let s="";if(d&&(s=d.toString(),b&&(s=P(s))),!(!s||a!=="change"&&a!=="rename"))if(t)if(a==="rename"){f.get(s)?.dispose();const p=setTimeout(async()=>{if(f.delete(s),s===c&&!await u.exists(e)){this.onWatchedPathDeleted(n);return}if(o.token.isCancellationRequested)return;const E=await this.existsChildStrictCase(N(e,s));if(o.token.isCancellationRequested)return;let D;E?g.has(s)?D=h.UPDATED:(D=h.ADDED,g.add(s)):(g.delete(s),D=h.DELETED),this.onFileChange({resource:F(n,s),type:D,cId:this.request.correlationId})},v.FILE_DELETE_HANDLER_DELAY);f.set(s,m(()=>clearTimeout(p)))}else{let p;g.has(s)?p=h.UPDATED:(p=h.ADDED,g.add(s)),this.onFileChange({resource:F(n,s),type:p,cId:this.request.correlationId})}else if(a==="rename"||s!==c){const p=setTimeout(async()=>{const E=await u.exists(e);o.token.isCancellationRequested||(E?(this.onFileChange({resource:n,type:h.UPDATED,cId:this.request.correlationId},!0),r.add(await this.doWatch(e,!1))):this.onWatchedPathDeleted(n))},v.FILE_DELETE_HANDLER_DELAY);r.clear(),r.add(m(()=>clearTimeout(p)))}else this.onFileChange({resource:n,type:h.UPDATED,cId:this.request.correlationId},!0)})}catch(n){o.token.isCancellationRequested||this.error(`Failed to watch ${e} for changes using fs.watch() (${n.toString()})`),this.notifyWatchFailed()}}onWatchedPathDeleted(e){this.warn("Watcher shutdown because watched path got deleted"),this.onFileChange({resource:e,type:h.DELETED,cId:this.request.correlationId},!0),this.fileChangesAggregator.flush(),this.notifyWatchFailed()}onFileChange(e,t=!1){this.cts.token.isCancellationRequested||(this.verboseLogging&&this.traceWithCorrelation(`${e.type===h.ADDED?"[ADDED]":e.type===h.DELETED?"[DELETED]":"[CHANGED]"} ${e.resource.fsPath}`),!t&&this.excludes.some(i=>i(e.resource.fsPath))?this.verboseLogging&&this.traceWithCorrelation(` >> ignored (excluded) ${e.resource.fsPath}`):!t&&this.includes&&this.includes.length>0&&!this.includes.some(i=>i(e.resource.fsPath))?this.verboseLogging&&this.traceWithCorrelation(` >> ignored (not included) ${e.resource.fsPath}`):this.fileChangesAggregator.work(e))}handleFileChanges(e){const t=U(e),i=[];for(const r of t){if(M(r,this.filter)){this.verboseLogging&&this.traceWithCorrelation(` >> ignored (filtered) ${r.resource.fsPath}`);continue}i.push(r)}if(i.length===0)return;if(this.verboseLogging)for(const r of i)this.traceWithCorrelation(` >> normalized ${r.type===h.ADDED?"[ADDED]":r.type===h.DELETED?"[DELETED]":"[CHANGED]"} ${r.resource.fsPath}`);this.throttledFileChangesEmitter.work(i)?this.throttledFileChangesEmitter.pending>0&&this.trace(`started throttling events due to large amount of file change events at once (pending: ${this.throttledFileChangesEmitter.pending}, most recent change: ${i[0].resource.fsPath}). Use 'files.watcherExclude' setting to exclude folders with lots of changing files (e.g. compilation output).`):this.warn(`started ignoring events due to too many file change events at once (incoming: ${i.length}, most recent change: ${i[0].resource.fsPath}). Use 'files.watcherExclude' setting to exclude folders with lots of changing files (e.g. compilation output).`)}async existsChildStrictCase(e){if(S)return u.exists(e);try{const t=R(e);return(await u.readdir(_(e))).some(o=>o===t)}catch(t){return this.trace(t),!1}}setVerboseLogging(e){this.verboseLogging=e}error(e){this.cts.token.isCancellationRequested||this.onLogMessage?.({type:"error",message:`[File Watcher (node.js)] ${e}`})}warn(e){this.cts.token.isCancellationRequested||this.onLogMessage?.({type:"warn",message:`[File Watcher (node.js)] ${e}`})}trace(e){!this.cts.token.isCancellationRequested&&this.verboseLogging&&this.onLogMessage?.({type:"trace",message:`[File Watcher (node.js)] ${e}`})}traceWithCorrelation(e){!this.cts.token.isCancellationRequested&&this.verboseLogging&&this.trace(`${e}${typeof this.request.correlationId=="number"?` <${this.request.correlationId}> `:""}`)}dispose(){this.cts.dispose(!0),super.dispose()}}async function ce(w,y,e,t,i=512){const o=await u.open(w,"r"),r=Buffer.allocUnsafe(i),n=new C(t);let c,l=!1;const g={path:w,excludes:[],recursive:!1},f=new v(g,void 0,a=>{(async()=>{for(const{type:d}of a)if(d===h.UPDATED){if(l)return;l=!0;try{for(;!n.token.isCancellationRequested;){const{bytesRead:s}=await u.read(o,r,0,i,null);if(!s||n.token.isCancellationRequested)break;y(r.slice(0,s))}}catch(s){c=new Error(s),n.dispose(!0)}finally{l=!1}}})()});return await f.ready,e(),new Promise((a,d)=>{n.token.onCancellationRequested(async()=>{f.dispose();try{await u.close(o)}catch(s){c=new Error(s)}c?d(c):a()})})}export{v as NodeJSFileWatcherLibrary,ce as watchFileContents};
