{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/files/node/watcher/watcherClient.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { DisposableStore } from \"../../../../base/common/lifecycle.js\";\nimport { FileAccess } from \"../../../../base/common/network.js\";\nimport {\n\tProxyChannel,\n\tgetNextTickChannel,\n} from \"../../../../base/parts/ipc/common/ipc.js\";\nimport { Client } from \"../../../../base/parts/ipc/node/ipc.cp.js\";\nimport type { IFileChange } from \"../../common/files.js\";\nimport {\n\tAbstractUniversalWatcherClient,\n\ttype ILogMessage,\n\ttype IUniversalWatcher,\n} from \"../../common/watcher.js\";\n\nexport class UniversalWatcherClient extends AbstractUniversalWatcherClient {\n\tconstructor(\n\t\tonFileChanges: (changes: IFileChange[]) => void,\n\t\tonLogMessage: (msg: ILogMessage) => void,\n\t\tverboseLogging: boolean,\n\t) {\n\t\tsuper(onFileChanges, onLogMessage, verboseLogging);\n\n\t\tthis.init();\n\t}\n\n\tprotected override createWatcher(\n\t\tdisposables: DisposableStore,\n\t): IUniversalWatcher {\n\t\t// Fork the universal file watcher and build a client around\n\t\t// its server for passing over requests and receiving events.\n\t\tconst client = disposables.add(\n\t\t\tnew Client(FileAccess.asFileUri(\"bootstrap-fork\").fsPath, {\n\t\t\t\tserverName: \"File Watcher\",\n\t\t\t\targs: [\"--type=fileWatcher\"],\n\t\t\t\tenv: {\n\t\t\t\t\tVSCODE_AMD_ENTRYPOINT:\n\t\t\t\t\t\t\"vs/platform/files/node/watcher/watcherMain\",\n\t\t\t\t\tVSCODE_PIPE_LOGGING: \"true\",\n\t\t\t\t\tVSCODE_VERBOSE_LOGGING: \"true\", // transmit console logs from server to client\n\t\t\t\t},\n\t\t\t}),\n\t\t);\n\n\t\t// React on unexpected termination of the watcher process\n\t\tdisposables.add(\n\t\t\tclient.onDidProcessExit(({ code, signal }) =>\n\t\t\t\tthis.onError(\n\t\t\t\t\t`terminated by itself with code ${code}, signal: ${signal} (ETERM)`,\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\n\t\treturn ProxyChannel.toService<IUniversalWatcher>(\n\t\t\tgetNextTickChannel(client.getChannel(\"watcher\")),\n\t\t);\n\t}\n}\n"],
  "mappings": ";;AAMA,SAAS,kBAAkB;AAC3B;AAAA,EACC;AAAA,EACA;AAAA,OACM;AACP,SAAS,cAAc;AAEvB;AAAA,EACC;AAAA,OAGM;AAEA,MAAM,+BAA+B,+BAA+B;AAAA,EAnB3E,OAmB2E;AAAA;AAAA;AAAA,EAC1E,YACC,eACA,cACA,gBACC;AACD,UAAM,eAAe,cAAc,cAAc;AAEjD,SAAK,KAAK;AAAA,EACX;AAAA,EAEmB,cAClB,aACoB;AAGpB,UAAM,SAAS,YAAY;AAAA,MAC1B,IAAI,OAAO,WAAW,UAAU,gBAAgB,EAAE,QAAQ;AAAA,QACzD,YAAY;AAAA,QACZ,MAAM,CAAC,oBAAoB;AAAA,QAC3B,KAAK;AAAA,UACJ,uBACC;AAAA,UACD,qBAAqB;AAAA,UACrB,wBAAwB;AAAA;AAAA,QACzB;AAAA,MACD,CAAC;AAAA,IACF;AAGA,gBAAY;AAAA,MACX,OAAO;AAAA,QAAiB,CAAC,EAAE,MAAM,OAAO,MACvC,KAAK;AAAA,UACJ,kCAAkC,IAAI,aAAa,MAAM;AAAA,QAC1D;AAAA,MACD;AAAA,IACD;AAEA,WAAO,aAAa;AAAA,MACnB,mBAAmB,OAAO,WAAW,SAAS,CAAC;AAAA,IAChD;AAAA,EACD;AACD;",
  "names": []
}
