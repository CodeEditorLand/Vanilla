import{Disposable as o}from"../../../../base/common/lifecycle.js";import{isRecursiveWatchRequest as i}from"../../common/watcher.js";import{Emitter as c,Event as t}from"../../../../base/common/event.js";import{ParcelWatcher as h}from"./parcel/parcelWatcher.js";import{NodeJSWatcher as n}from"./nodejs/nodejsWatcher.js";import{Promises as a}from"../../../../base/common/async.js";import{computeStats as v}from"./watcherStats.js";class q extends o{recursiveWatcher=this._register(new h);nonRecursiveWatcher=this._register(new n(this.recursiveWatcher));onDidChangeFile=t.any(this.recursiveWatcher.onDidChangeFile,this.nonRecursiveWatcher.onDidChangeFile);onDidError=t.any(this.recursiveWatcher.onDidError,this.nonRecursiveWatcher.onDidError);_onDidLogMessage=this._register(new c);onDidLogMessage=t.any(this._onDidLogMessage.event,this.recursiveWatcher.onDidLogMessage,this.nonRecursiveWatcher.onDidLogMessage);requests=[];failedRecursiveRequests=0;constructor(){super(),this._register(this.recursiveWatcher.onDidError(e=>{e.request&&this.failedRecursiveRequests++}))}async watch(e){this.requests=e,this.failedRecursiveRequests=0;let s;try{await this.recursiveWatcher.watch(e.filter(r=>i(r)))}catch(r){s=r}try{await this.nonRecursiveWatcher.watch(e.filter(r=>!i(r)))}catch(r){s||(s=r)}if(s)throw s}async setVerboseLogging(e){e&&this.requests.length>0&&this._onDidLogMessage.fire({type:"trace",message:v(this.requests,this.failedRecursiveRequests,this.recursiveWatcher,this.nonRecursiveWatcher)}),await a.settled([this.recursiveWatcher.setVerboseLogging(e),this.nonRecursiveWatcher.setVerboseLogging(e)])}async stop(){await a.settled([this.recursiveWatcher.stop(),this.nonRecursiveWatcher.stop()])}}export{q as UniversalWatcher};
