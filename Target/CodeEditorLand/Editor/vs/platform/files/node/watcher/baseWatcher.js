import{unwatchFile as p,watchFile as u}from"fs";import{DeferredPromise as h,ThrottledDelayer as W}from"../../../../base/common/async.js";import{Emitter as o}from"../../../../base/common/event.js";import{Disposable as g,DisposableMap as v,DisposableStore as I,toDisposable as R}from"../../../../base/common/lifecycle.js";import{URI as f}from"../../../../base/common/uri.js";import{FileChangeType as s}from"../../common/files.js";import{isWatchRequestWithCorrelation as D,requestFilterToString as m}from"../../common/watcher.js";class $ extends g{_onDidChangeFile=this._register(new o);onDidChangeFile=this._onDidChangeFile.event;_onDidLogMessage=this._register(new o);onDidLogMessage=this._onDidLogMessage.event;_onDidWatchFail=this._register(new o);onDidWatchFail=this._onDidWatchFail.event;allNonCorrelatedWatchRequests=new Set;allCorrelatedWatchRequests=new Map;suspendedWatchRequests=this._register(new v);suspendedWatchRequestsWithPolling=new Set;updateWatchersDelayer=this._register(new W(this.getUpdateWatchersDelay()));suspendedWatchRequestPollingInterval=5007;joinWatch=new h;constructor(){super(),this._register(this.onDidWatchFail(e=>this.handleDidWatchFail(e)))}handleDidWatchFail(e){this.isCorrelated(e)&&this.suspendWatchRequest(e)}isCorrelated(e){return D(e)}async watch(e){this.joinWatch.isSettled||this.joinWatch.complete(),this.joinWatch=new h;try{this.allCorrelatedWatchRequests.clear(),this.allNonCorrelatedWatchRequests.clear();for(const t of e)this.isCorrelated(t)?this.allCorrelatedWatchRequests.set(t.correlationId,t):this.allNonCorrelatedWatchRequests.add(t);for(const[t]of this.suspendedWatchRequests)this.allCorrelatedWatchRequests.has(t)||(this.suspendedWatchRequests.deleteAndDispose(t),this.suspendedWatchRequestsWithPolling.delete(t));return await this.updateWatchers(!1)}finally{this.joinWatch.complete()}}updateWatchers(e){return this.updateWatchersDelayer.trigger(()=>this.doWatch([...this.allNonCorrelatedWatchRequests,...Array.from(this.allCorrelatedWatchRequests.values()).filter(t=>!this.suspendedWatchRequests.has(t.correlationId))]),e?this.getUpdateWatchersDelay():0)}getUpdateWatchersDelay(){return 800}isSuspended(e){return typeof e.correlationId!="number"?!1:this.suspendedWatchRequestsWithPolling.has(e.correlationId)?"polling":this.suspendedWatchRequests.has(e.correlationId)}async suspendWatchRequest(e){if(this.suspendedWatchRequests.has(e.correlationId))return;const t=new I;this.suspendedWatchRequests.set(e.correlationId,t),await this.joinWatch.p,!t.isDisposed&&(this.monitorSuspendedWatchRequest(e,t),this.updateWatchers(!0))}resumeWatchRequest(e){this.suspendedWatchRequests.deleteAndDispose(e.correlationId),this.suspendedWatchRequestsWithPolling.delete(e.correlationId),this.updateWatchers(!1)}monitorSuspendedWatchRequest(e,t){this.doMonitorWithExistingWatcher(e,t)?(this.trace(`reusing an existing recursive watcher to monitor ${e.path}`),this.suspendedWatchRequestsWithPolling.delete(e.correlationId)):(this.doMonitorWithNodeJS(e,t),this.suspendedWatchRequestsWithPolling.add(e.correlationId))}doMonitorWithExistingWatcher(e,t){const i=this.recursiveWatcher?.subscribe(e.path,(a,r)=>{t.isDisposed||(a?this.monitorSuspendedWatchRequest(e,t):r?.type===s.ADDED&&this.onMonitoredPathAdded(e))});return i?(t.add(i),!0):!1}doMonitorWithNodeJS(e,t){let i=!1;const a=(r,d)=>{if(t.isDisposed)return;const n=this.isPathNotFound(r),l=this.isPathNotFound(d),c=i;i=n,!n&&(l||c)&&this.onMonitoredPathAdded(e)};this.trace(`starting fs.watchFile() on ${e.path} (correlationId: ${e.correlationId})`);try{u(e.path,{persistent:!1,interval:this.suspendedWatchRequestPollingInterval},a)}catch(r){this.warn(`fs.watchFile() failed with error ${r} on path ${e.path} (correlationId: ${e.correlationId})`)}t.add(R(()=>{this.trace(`stopping fs.watchFile() on ${e.path} (correlationId: ${e.correlationId})`);try{p(e.path,a)}catch(r){this.warn(`fs.unwatchFile() failed with error ${r} on path ${e.path} (correlationId: ${e.correlationId})`)}}))}onMonitoredPathAdded(e){this.trace(`detected ${e.path} exists again, resuming watcher (correlationId: ${e.correlationId})`);const t={resource:f.file(e.path),type:s.ADDED,cId:e.correlationId};this._onDidChangeFile.fire([t]),this.traceEvent(t,e),this.resumeWatchRequest(e)}isPathNotFound(e){return e.ctimeMs===0&&e.ino===0}async stop(){this.suspendedWatchRequests.clearAndDisposeAll(),this.suspendedWatchRequestsWithPolling.clear()}traceEvent(e,t){if(this.verboseLogging){const i=` >> normalized ${e.type===s.ADDED?"[ADDED]":e.type===s.DELETED?"[DELETED]":"[CHANGED]"} ${e.resource.fsPath}`;this.traceWithCorrelation(i,t)}}traceWithCorrelation(e,t){this.verboseLogging&&this.trace(`${e}${typeof t.correlationId=="number"?` <${t.correlationId}> `:""}`)}requestToString(e){return`${e.path} (excludes: ${e.excludes.length>0?e.excludes:"<none>"}, includes: ${e.includes&&e.includes.length>0?JSON.stringify(e.includes):"<all>"}, filter: ${m(e.filter)}, correlationId: ${typeof e.correlationId=="number"?e.correlationId:"<none>"})`}verboseLogging=!1;async setVerboseLogging(e){this.verboseLogging=e}}export{$ as BaseWatcher};
