import{watchFile as u,unwatchFile as p}from"fs";import{Disposable as W,DisposableMap as g,DisposableStore as v,toDisposable as I}from"../../../../base/common/lifecycle.js";import{isWatchRequestWithCorrelation as R,requestFilterToString as f}from"../../common/watcher.js";import{Emitter as o}from"../../../../base/common/event.js";import{FileChangeType as r}from"../../common/files.js";import{URI as m}from"../../../../base/common/uri.js";import{DeferredPromise as d,ThrottledDelayer as D}from"../../../../base/common/async.js";import{hash as b}from"../../../../base/common/hash.js";class J extends W{_onDidChangeFile=this._register(new o);onDidChangeFile=this._onDidChangeFile.event;_onDidLogMessage=this._register(new o);onDidLogMessage=this._onDidLogMessage.event;_onDidWatchFail=this._register(new o);onDidWatchFail=this._onDidWatchFail.event;correlatedWatchRequests=new Map;nonCorrelatedWatchRequests=new Map;suspendedWatchRequests=this._register(new g);suspendedWatchRequestsWithPolling=new Set;updateWatchersDelayer=this._register(new D(this.getUpdateWatchersDelay()));suspendedWatchRequestPollingInterval=5007;joinWatch=new d;constructor(){super(),this._register(this.onDidWatchFail(e=>this.suspendWatchRequest({id:this.computeId(e),correlationId:this.isCorrelated(e)?e.correlationId:void 0,path:e.path})))}isCorrelated(e){return R(e)}computeId(e){return this.isCorrelated(e)?e.correlationId:b(e)}async watch(e){this.joinWatch.isSettled||this.joinWatch.complete(),this.joinWatch=new d;try{this.correlatedWatchRequests.clear(),this.nonCorrelatedWatchRequests.clear();for(const t of e)this.isCorrelated(t)?this.correlatedWatchRequests.set(t.correlationId,t):this.nonCorrelatedWatchRequests.set(this.computeId(t),t);for(const[t]of this.suspendedWatchRequests)!this.nonCorrelatedWatchRequests.has(t)&&!this.correlatedWatchRequests.has(t)&&(this.suspendedWatchRequests.deleteAndDispose(t),this.suspendedWatchRequestsWithPolling.delete(t));return await this.updateWatchers(!1)}finally{this.joinWatch.complete()}}updateWatchers(e){const t=[];for(const[s,a]of[...this.nonCorrelatedWatchRequests,...this.correlatedWatchRequests])this.suspendedWatchRequests.has(s)||t.push(a);return this.updateWatchersDelayer.trigger(()=>this.doWatch(t),e?this.getUpdateWatchersDelay():0)}getUpdateWatchersDelay(){return 800}isSuspended(e){const t=this.computeId(e);return this.suspendedWatchRequestsWithPolling.has(t)?"polling":this.suspendedWatchRequests.has(t)}async suspendWatchRequest(e){if(this.suspendedWatchRequests.has(e.id))return;const t=new v;this.suspendedWatchRequests.set(e.id,t),await this.joinWatch.p,!t.isDisposed&&(this.monitorSuspendedWatchRequest(e,t),this.updateWatchers(!0))}resumeWatchRequest(e){this.suspendedWatchRequests.deleteAndDispose(e.id),this.suspendedWatchRequestsWithPolling.delete(e.id),this.updateWatchers(!1)}monitorSuspendedWatchRequest(e,t){this.doMonitorWithExistingWatcher(e,t)?(this.trace(`reusing an existing recursive watcher to monitor ${e.path}`),this.suspendedWatchRequestsWithPolling.delete(e.id)):(this.doMonitorWithNodeJS(e,t),this.suspendedWatchRequestsWithPolling.add(e.id))}doMonitorWithExistingWatcher(e,t){const s=this.recursiveWatcher?.subscribe(e.path,(a,i)=>{t.isDisposed||(a?this.monitorSuspendedWatchRequest(e,t):i?.type===r.ADDED&&this.onMonitoredPathAdded(e))});return s?(t.add(s),!0):!1}doMonitorWithNodeJS(e,t){let s=!1;const a=(i,h)=>{if(t.isDisposed)return;const n=this.isPathNotFound(i),c=this.isPathNotFound(h),l=s;s=n,!n&&(c||l)&&this.onMonitoredPathAdded(e)};this.trace(`starting fs.watchFile() on ${e.path} (correlationId: ${e.correlationId})`);try{u(e.path,{persistent:!1,interval:this.suspendedWatchRequestPollingInterval},a)}catch(i){this.warn(`fs.watchFile() failed with error ${i} on path ${e.path} (correlationId: ${e.correlationId})`)}t.add(I(()=>{this.trace(`stopping fs.watchFile() on ${e.path} (correlationId: ${e.correlationId})`);try{p(e.path,a)}catch(i){this.warn(`fs.unwatchFile() failed with error ${i} on path ${e.path} (correlationId: ${e.correlationId})`)}}))}onMonitoredPathAdded(e){this.trace(`detected ${e.path} exists again, resuming watcher (correlationId: ${e.correlationId})`);const t={resource:m.file(e.path),type:r.ADDED,cId:e.correlationId};this._onDidChangeFile.fire([t]),this.traceEvent(t,e),this.resumeWatchRequest(e)}isPathNotFound(e){return e.ctimeMs===0&&e.ino===0}async stop(){this.suspendedWatchRequests.clearAndDisposeAll(),this.suspendedWatchRequestsWithPolling.clear()}traceEvent(e,t){if(this.verboseLogging){const s=` >> normalized ${e.type===r.ADDED?"[ADDED]":e.type===r.DELETED?"[DELETED]":"[CHANGED]"} ${e.resource.fsPath}`;this.traceWithCorrelation(s,t)}}traceWithCorrelation(e,t){this.verboseLogging&&this.trace(`${e}${typeof t.correlationId=="number"?` <${t.correlationId}> `:""}`)}requestToString(e){return`${e.path} (excludes: ${e.excludes.length>0?e.excludes:"<none>"}, includes: ${e.includes&&e.includes.length>0?JSON.stringify(e.includes):"<all>"}, filter: ${f(e.filter)}, correlationId: ${typeof e.correlationId=="number"?e.correlationId:"<none>"})`}verboseLogging=!1;async setVerboseLogging(e){this.verboseLogging=e}}export{J as BaseWatcher};
