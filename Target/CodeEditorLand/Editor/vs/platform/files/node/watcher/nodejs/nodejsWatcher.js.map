{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/files/node/watcher/nodejs/nodejsWatcher.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from \"../../../../../base/common/event.js\";\nimport { isEqual } from \"../../../../../base/common/extpath.js\";\nimport { patternsEquals } from \"../../../../../base/common/glob.js\";\nimport { isLinux } from \"../../../../../base/common/platform.js\";\nimport type {\n\tINonRecursiveWatchRequest,\n\tINonRecursiveWatcher,\n\tIRecursiveWatcherWithSubscribe,\n} from \"../../../common/watcher.js\";\nimport { BaseWatcher } from \"../baseWatcher.js\";\nimport { NodeJSFileWatcherLibrary } from \"./nodejsWatcherLib.js\";\n\nexport interface INodeJSWatcherInstance {\n\t/**\n\t * The watcher instance.\n\t */\n\treadonly instance: NodeJSFileWatcherLibrary;\n\n\t/**\n\t * The watch request associated to the watcher.\n\t */\n\treadonly request: INonRecursiveWatchRequest;\n}\n\nexport class NodeJSWatcher extends BaseWatcher implements INonRecursiveWatcher {\n\treadonly onDidError = Event.None;\n\n\treadonly watchers = new Set<INodeJSWatcherInstance>();\n\n\tconstructor(\n\t\tprotected readonly recursiveWatcher:\n\t\t\t| IRecursiveWatcherWithSubscribe\n\t\t\t| undefined,\n\t) {\n\t\tsuper();\n\t}\n\n\tprotected override async doWatch(\n\t\trequests: INonRecursiveWatchRequest[],\n\t): Promise<void> {\n\t\t// Figure out duplicates to remove from the requests\n\t\trequests = this.removeDuplicateRequests(requests);\n\n\t\t// Figure out which watchers to start and which to stop\n\t\tconst requestsToStart: INonRecursiveWatchRequest[] = [];\n\t\tconst watchersToStop = new Set(Array.from(this.watchers));\n\t\tfor (const request of requests) {\n\t\t\tconst watcher = this.findWatcher(request);\n\t\t\tif (\n\t\t\t\twatcher &&\n\t\t\t\tpatternsEquals(watcher.request.excludes, request.excludes) &&\n\t\t\t\tpatternsEquals(watcher.request.includes, request.includes)\n\t\t\t) {\n\t\t\t\twatchersToStop.delete(watcher); // keep watcher\n\t\t\t} else {\n\t\t\t\trequestsToStart.push(request); // start watching\n\t\t\t}\n\t\t}\n\n\t\t// Logging\n\n\t\tif (requestsToStart.length) {\n\t\t\tthis.trace(\n\t\t\t\t`Request to start watching: ${requestsToStart.map((request) => this.requestToString(request)).join(\",\")}`,\n\t\t\t);\n\t\t}\n\n\t\tif (watchersToStop.size) {\n\t\t\tthis.trace(\n\t\t\t\t`Request to stop watching: ${Array.from(watchersToStop)\n\t\t\t\t\t.map((watcher) => this.requestToString(watcher.request))\n\t\t\t\t\t.join(\",\")}`,\n\t\t\t);\n\t\t}\n\n\t\t// Stop watching as instructed\n\t\tfor (const watcher of watchersToStop) {\n\t\t\tthis.stopWatching(watcher);\n\t\t}\n\n\t\t// Start watching as instructed\n\t\tfor (const request of requestsToStart) {\n\t\t\tthis.startWatching(request);\n\t\t}\n\t}\n\n\tprivate findWatcher(\n\t\trequest: INonRecursiveWatchRequest,\n\t): INodeJSWatcherInstance | undefined {\n\t\tfor (const watcher of this.watchers) {\n\t\t\t// Requests or watchers with correlation always match on that\n\t\t\tif (\n\t\t\t\ttypeof request.correlationId === \"number\" ||\n\t\t\t\ttypeof watcher.request.correlationId === \"number\"\n\t\t\t) {\n\t\t\t\tif (watcher.request.correlationId === request.correlationId) {\n\t\t\t\t\treturn watcher;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Non-correlated requests or watchers match on path\n\t\t\telse if (\n\t\t\t\tisEqual(\n\t\t\t\t\twatcher.request.path,\n\t\t\t\t\trequest.path,\n\t\t\t\t\t!isLinux /* ignorecase */,\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\treturn watcher;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate startWatching(request: INonRecursiveWatchRequest): void {\n\t\t// Start via node.js lib\n\t\tconst instance = new NodeJSFileWatcherLibrary(\n\t\t\trequest,\n\t\t\tthis.recursiveWatcher,\n\t\t\t(changes) => this._onDidChangeFile.fire(changes),\n\t\t\t() => this._onDidWatchFail.fire(request),\n\t\t\t(msg) => this._onDidLogMessage.fire(msg),\n\t\t\tthis.verboseLogging,\n\t\t);\n\n\t\t// Remember as watcher instance\n\t\tconst watcher: INodeJSWatcherInstance = { request, instance };\n\t\tthis.watchers.add(watcher);\n\t}\n\n\toverride async stop(): Promise<void> {\n\t\tawait super.stop();\n\n\t\tfor (const watcher of this.watchers) {\n\t\t\tthis.stopWatching(watcher);\n\t\t}\n\t}\n\n\tprivate stopWatching(watcher: INodeJSWatcherInstance): void {\n\t\tthis.trace(`stopping file watcher`, watcher);\n\n\t\tthis.watchers.delete(watcher);\n\n\t\twatcher.instance.dispose();\n\t}\n\n\tprivate removeDuplicateRequests(\n\t\trequests: INonRecursiveWatchRequest[],\n\t): INonRecursiveWatchRequest[] {\n\t\tconst mapCorrelationtoRequests = new Map<\n\t\t\tnumber | undefined /* correlation */,\n\t\t\tMap<string, INonRecursiveWatchRequest>\n\t\t>();\n\n\t\t// Ignore requests for the same paths that have the same correlation\n\t\tfor (const request of requests) {\n\t\t\tconst path = isLinux ? request.path : request.path.toLowerCase(); // adjust for case sensitivity\n\n\t\t\tlet requestsForCorrelation = mapCorrelationtoRequests.get(\n\t\t\t\trequest.correlationId,\n\t\t\t);\n\t\t\tif (!requestsForCorrelation) {\n\t\t\t\trequestsForCorrelation = new Map<\n\t\t\t\t\tstring,\n\t\t\t\t\tINonRecursiveWatchRequest\n\t\t\t\t>();\n\t\t\t\tmapCorrelationtoRequests.set(\n\t\t\t\t\trequest.correlationId,\n\t\t\t\t\trequestsForCorrelation,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (requestsForCorrelation.has(path)) {\n\t\t\t\tthis.trace(\n\t\t\t\t\t`ignoring a request for watching who's path is already watched: ${this.requestToString(request)}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\trequestsForCorrelation.set(path, request);\n\t\t}\n\n\t\treturn Array.from(mapCorrelationtoRequests.values()).flatMap(\n\t\t\t(requests) => Array.from(requests.values()),\n\t\t);\n\t}\n\n\toverride async setVerboseLogging(enabled: boolean): Promise<void> {\n\t\tsuper.setVerboseLogging(enabled);\n\n\t\tfor (const watcher of this.watchers) {\n\t\t\twatcher.instance.setVerboseLogging(enabled);\n\t\t}\n\t}\n\n\tprotected trace(message: string, watcher?: INodeJSWatcherInstance): void {\n\t\tif (this.verboseLogging) {\n\t\t\tthis._onDidLogMessage.fire({\n\t\t\t\ttype: \"trace\",\n\t\t\t\tmessage: this.toMessage(message, watcher),\n\t\t\t});\n\t\t}\n\t}\n\n\tprotected warn(message: string): void {\n\t\tthis._onDidLogMessage.fire({\n\t\t\ttype: \"warn\",\n\t\t\tmessage: this.toMessage(message),\n\t\t});\n\t}\n\n\tprivate toMessage(\n\t\tmessage: string,\n\t\twatcher?: INodeJSWatcherInstance,\n\t): string {\n\t\treturn watcher\n\t\t\t? `[File Watcher (node.js)] ${message} (${this.requestToString(watcher.request)})`\n\t\t\t: `[File Watcher (node.js)] ${message}`;\n\t}\n}\n"],
  "mappings": "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",
  "names": ["requests"]
}
