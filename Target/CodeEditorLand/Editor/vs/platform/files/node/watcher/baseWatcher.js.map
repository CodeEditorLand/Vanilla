{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/files/node/watcher/baseWatcher.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { type Stats, unwatchFile, watchFile } from \"fs\";\nimport {\n\tDeferredPromise,\n\tThrottledDelayer,\n} from \"../../../../base/common/async.js\";\nimport { Emitter, type Event } from \"../../../../base/common/event.js\";\nimport {\n\tDisposable,\n\tDisposableMap,\n\tDisposableStore,\n\ttoDisposable,\n} from \"../../../../base/common/lifecycle.js\";\nimport { URI } from \"../../../../base/common/uri.js\";\nimport { FileChangeType, type IFileChange } from \"../../common/files.js\";\nimport {\n\ttype ILogMessage,\n\ttype IRecursiveWatcherWithSubscribe,\n\ttype IUniversalWatchRequest,\n\ttype IWatchRequestWithCorrelation,\n\ttype IWatcher,\n\ttype IWatcherErrorEvent,\n\tisWatchRequestWithCorrelation,\n\trequestFilterToString,\n} from \"../../common/watcher.js\";\n\nexport abstract class BaseWatcher extends Disposable implements IWatcher {\n\tprotected readonly _onDidChangeFile = this._register(\n\t\tnew Emitter<IFileChange[]>(),\n\t);\n\treadonly onDidChangeFile = this._onDidChangeFile.event;\n\n\tprotected readonly _onDidLogMessage = this._register(\n\t\tnew Emitter<ILogMessage>(),\n\t);\n\treadonly onDidLogMessage = this._onDidLogMessage.event;\n\n\tprotected readonly _onDidWatchFail = this._register(\n\t\tnew Emitter<IUniversalWatchRequest>(),\n\t);\n\tprivate readonly onDidWatchFail = this._onDidWatchFail.event;\n\n\tprivate readonly allNonCorrelatedWatchRequests =\n\t\tnew Set<IUniversalWatchRequest>();\n\tprivate readonly allCorrelatedWatchRequests = new Map<\n\t\tnumber /* correlation ID */,\n\t\tIWatchRequestWithCorrelation\n\t>();\n\n\tprivate readonly suspendedWatchRequests = this._register(\n\t\tnew DisposableMap<number /* correlation ID */>(),\n\t);\n\tprivate readonly suspendedWatchRequestsWithPolling =\n\t\tnew Set<number /* correlation ID */>();\n\n\tprivate readonly updateWatchersDelayer = this._register(\n\t\tnew ThrottledDelayer<void>(this.getUpdateWatchersDelay()),\n\t);\n\n\tprotected readonly suspendedWatchRequestPollingInterval: number = 5007; // node.js default\n\n\tprivate joinWatch = new DeferredPromise<void>();\n\n\tconstructor() {\n\t\tsuper();\n\n\t\tthis._register(\n\t\t\tthis.onDidWatchFail((request) => this.handleDidWatchFail(request)),\n\t\t);\n\t}\n\n\tprivate handleDidWatchFail(request: IUniversalWatchRequest): void {\n\t\tif (!this.isCorrelated(request)) {\n\t\t\t// For now, limit failed watch monitoring to requests with a correlationId\n\t\t\t// to experiment with this feature in a controlled way. Monitoring requests\n\t\t\t// requires us to install polling watchers (via `fs.watchFile()`) and thus\n\t\t\t// should be used sparingly.\n\t\t\t//\n\t\t\t// TODO@bpasero revisit this in the future to have a more general approach\n\t\t\t// for suspend/resume and drop the `legacyMonitorRequest` in parcel.\n\t\t\t// One issue is that we need to be able to uniquely identify a request and\n\t\t\t// without correlation that is actually harder...\n\n\t\t\treturn;\n\t\t}\n\n\t\tthis.suspendWatchRequest(request);\n\t}\n\n\tprotected isCorrelated(\n\t\trequest: IUniversalWatchRequest,\n\t): request is IWatchRequestWithCorrelation {\n\t\treturn isWatchRequestWithCorrelation(request);\n\t}\n\n\tasync watch(requests: IUniversalWatchRequest[]): Promise<void> {\n\t\tif (!this.joinWatch.isSettled) {\n\t\t\tthis.joinWatch.complete();\n\t\t}\n\t\tthis.joinWatch = new DeferredPromise<void>();\n\n\t\ttry {\n\t\t\tthis.allCorrelatedWatchRequests.clear();\n\t\t\tthis.allNonCorrelatedWatchRequests.clear();\n\n\t\t\t// Figure out correlated vs. non-correlated requests\n\t\t\tfor (const request of requests) {\n\t\t\t\tif (this.isCorrelated(request)) {\n\t\t\t\t\tthis.allCorrelatedWatchRequests.set(\n\t\t\t\t\t\trequest.correlationId,\n\t\t\t\t\t\trequest,\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tthis.allNonCorrelatedWatchRequests.add(request);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove all suspended correlated watch requests that are no longer watched\n\t\t\tfor (const [correlationId] of this.suspendedWatchRequests) {\n\t\t\t\tif (!this.allCorrelatedWatchRequests.has(correlationId)) {\n\t\t\t\t\tthis.suspendedWatchRequests.deleteAndDispose(correlationId);\n\t\t\t\t\tthis.suspendedWatchRequestsWithPolling.delete(\n\t\t\t\t\t\tcorrelationId,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn await this.updateWatchers(false /* not delayed */);\n\t\t} finally {\n\t\t\tthis.joinWatch.complete();\n\t\t}\n\t}\n\n\tprivate updateWatchers(delayed: boolean): Promise<void> {\n\t\treturn this.updateWatchersDelayer.trigger(\n\t\t\t() =>\n\t\t\t\tthis.doWatch([\n\t\t\t\t\t...this.allNonCorrelatedWatchRequests,\n\t\t\t\t\t...Array.from(\n\t\t\t\t\t\tthis.allCorrelatedWatchRequests.values(),\n\t\t\t\t\t).filter(\n\t\t\t\t\t\t(request) =>\n\t\t\t\t\t\t\t!this.suspendedWatchRequests.has(\n\t\t\t\t\t\t\t\trequest.correlationId,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t]),\n\t\t\tdelayed ? this.getUpdateWatchersDelay() : 0,\n\t\t);\n\t}\n\n\tprotected getUpdateWatchersDelay(): number {\n\t\treturn 800;\n\t}\n\n\tisSuspended(request: IUniversalWatchRequest): \"polling\" | boolean {\n\t\tif (typeof request.correlationId !== \"number\") {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this.suspendedWatchRequestsWithPolling.has(request.correlationId)\n\t\t\t? \"polling\"\n\t\t\t: this.suspendedWatchRequests.has(request.correlationId);\n\t}\n\n\tprivate async suspendWatchRequest(\n\t\trequest: IWatchRequestWithCorrelation,\n\t): Promise<void> {\n\t\tif (this.suspendedWatchRequests.has(request.correlationId)) {\n\t\t\treturn; // already suspended\n\t\t}\n\n\t\tconst disposables = new DisposableStore();\n\t\tthis.suspendedWatchRequests.set(request.correlationId, disposables);\n\n\t\t// It is possible that a watch request fails right during watch()\n\t\t// phase while other requests succeed. To increase the chance of\n\t\t// reusing another watcher for suspend/resume tracking, we await\n\t\t// all watch requests having processed.\n\n\t\tawait this.joinWatch.p;\n\n\t\tif (disposables.isDisposed) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.monitorSuspendedWatchRequest(request, disposables);\n\n\t\tthis.updateWatchers(\n\t\t\ttrue /* delay this call as we might accumulate many failing watch requests on startup */,\n\t\t);\n\t}\n\n\tprivate resumeWatchRequest(request: IWatchRequestWithCorrelation): void {\n\t\tthis.suspendedWatchRequests.deleteAndDispose(request.correlationId);\n\t\tthis.suspendedWatchRequestsWithPolling.delete(request.correlationId);\n\n\t\tthis.updateWatchers(false);\n\t}\n\n\tprivate monitorSuspendedWatchRequest(\n\t\trequest: IWatchRequestWithCorrelation,\n\t\tdisposables: DisposableStore,\n\t): void {\n\t\tif (this.doMonitorWithExistingWatcher(request, disposables)) {\n\t\t\tthis.trace(\n\t\t\t\t`reusing an existing recursive watcher to monitor ${request.path}`,\n\t\t\t);\n\t\t\tthis.suspendedWatchRequestsWithPolling.delete(\n\t\t\t\trequest.correlationId,\n\t\t\t);\n\t\t} else {\n\t\t\tthis.doMonitorWithNodeJS(request, disposables);\n\t\t\tthis.suspendedWatchRequestsWithPolling.add(request.correlationId);\n\t\t}\n\t}\n\n\tprivate doMonitorWithExistingWatcher(\n\t\trequest: IWatchRequestWithCorrelation,\n\t\tdisposables: DisposableStore,\n\t): boolean {\n\t\tconst subscription = this.recursiveWatcher?.subscribe(\n\t\t\trequest.path,\n\t\t\t(error, change) => {\n\t\t\t\tif (disposables.isDisposed) {\n\t\t\t\t\treturn; // return early if already disposed\n\t\t\t\t}\n\n\t\t\t\tif (error) {\n\t\t\t\t\tthis.monitorSuspendedWatchRequest(request, disposables);\n\t\t\t\t} else if (change?.type === FileChangeType.ADDED) {\n\t\t\t\t\tthis.onMonitoredPathAdded(request);\n\t\t\t\t}\n\t\t\t},\n\t\t);\n\n\t\tif (subscription) {\n\t\t\tdisposables.add(subscription);\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate doMonitorWithNodeJS(\n\t\trequest: IWatchRequestWithCorrelation,\n\t\tdisposables: DisposableStore,\n\t): void {\n\t\tlet pathNotFound = false;\n\n\t\tconst watchFileCallback: (curr: Stats, prev: Stats) => void = (\n\t\t\tcurr,\n\t\t\tprev,\n\t\t) => {\n\t\t\tif (disposables.isDisposed) {\n\t\t\t\treturn; // return early if already disposed\n\t\t\t}\n\n\t\t\tconst currentPathNotFound = this.isPathNotFound(curr);\n\t\t\tconst previousPathNotFound = this.isPathNotFound(prev);\n\t\t\tconst oldPathNotFound = pathNotFound;\n\t\t\tpathNotFound = currentPathNotFound;\n\n\t\t\t// Watch path created: resume watching request\n\t\t\tif (\n\t\t\t\t!currentPathNotFound &&\n\t\t\t\t(previousPathNotFound || oldPathNotFound)\n\t\t\t) {\n\t\t\t\tthis.onMonitoredPathAdded(request);\n\t\t\t}\n\t\t};\n\n\t\tthis.trace(\n\t\t\t`starting fs.watchFile() on ${request.path} (correlationId: ${request.correlationId})`,\n\t\t);\n\t\ttry {\n\t\t\twatchFile(\n\t\t\t\trequest.path,\n\t\t\t\t{\n\t\t\t\t\tpersistent: false,\n\t\t\t\t\tinterval: this.suspendedWatchRequestPollingInterval,\n\t\t\t\t},\n\t\t\t\twatchFileCallback,\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tthis.warn(\n\t\t\t\t`fs.watchFile() failed with error ${error} on path ${request.path} (correlationId: ${request.correlationId})`,\n\t\t\t);\n\t\t}\n\n\t\tdisposables.add(\n\t\t\ttoDisposable(() => {\n\t\t\t\tthis.trace(\n\t\t\t\t\t`stopping fs.watchFile() on ${request.path} (correlationId: ${request.correlationId})`,\n\t\t\t\t);\n\n\t\t\t\ttry {\n\t\t\t\t\tunwatchFile(request.path, watchFileCallback);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.warn(\n\t\t\t\t\t\t`fs.unwatchFile() failed with error ${error} on path ${request.path} (correlationId: ${request.correlationId})`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\t}\n\n\tprivate onMonitoredPathAdded(request: IWatchRequestWithCorrelation) {\n\t\tthis.trace(\n\t\t\t`detected ${request.path} exists again, resuming watcher (correlationId: ${request.correlationId})`,\n\t\t);\n\n\t\t// Emit as event\n\t\tconst event: IFileChange = {\n\t\t\tresource: URI.file(request.path),\n\t\t\ttype: FileChangeType.ADDED,\n\t\t\tcId: request.correlationId,\n\t\t};\n\t\tthis._onDidChangeFile.fire([event]);\n\t\tthis.traceEvent(event, request);\n\n\t\t// Resume watching\n\t\tthis.resumeWatchRequest(request);\n\t}\n\n\tprivate isPathNotFound(stats: Stats): boolean {\n\t\treturn stats.ctimeMs === 0 && stats.ino === 0;\n\t}\n\n\tasync stop(): Promise<void> {\n\t\tthis.suspendedWatchRequests.clearAndDisposeAll();\n\t\tthis.suspendedWatchRequestsWithPolling.clear();\n\t}\n\n\tprotected traceEvent(\n\t\tevent: IFileChange,\n\t\trequest: IUniversalWatchRequest,\n\t): void {\n\t\tif (this.verboseLogging) {\n\t\t\tconst traceMsg = ` >> normalized ${event.type === FileChangeType.ADDED ? \"[ADDED]\" : event.type === FileChangeType.DELETED ? \"[DELETED]\" : \"[CHANGED]\"} ${event.resource.fsPath}`;\n\t\t\tthis.traceWithCorrelation(traceMsg, request);\n\t\t}\n\t}\n\n\tprotected traceWithCorrelation(\n\t\tmessage: string,\n\t\trequest: IUniversalWatchRequest,\n\t): void {\n\t\tif (this.verboseLogging) {\n\t\t\tthis.trace(\n\t\t\t\t`${message}${typeof request.correlationId === \"number\" ? ` <${request.correlationId}> ` : ``}`,\n\t\t\t);\n\t\t}\n\t}\n\n\tprotected requestToString(request: IUniversalWatchRequest): string {\n\t\treturn `${request.path} (excludes: ${request.excludes.length > 0 ? request.excludes : \"<none>\"}, includes: ${request.includes && request.includes.length > 0 ? JSON.stringify(request.includes) : \"<all>\"}, filter: ${requestFilterToString(request.filter)}, correlationId: ${typeof request.correlationId === \"number\" ? request.correlationId : \"<none>\"})`;\n\t}\n\n\tprotected abstract doWatch(\n\t\trequests: IUniversalWatchRequest[],\n\t): Promise<void>;\n\n\tprotected abstract readonly recursiveWatcher:\n\t\t| IRecursiveWatcherWithSubscribe\n\t\t| undefined;\n\n\tprotected abstract trace(message: string): void;\n\tprotected abstract warn(message: string): void;\n\n\tabstract onDidError: Event<IWatcherErrorEvent>;\n\n\tprotected verboseLogging = false;\n\n\tasync setVerboseLogging(enabled: boolean): Promise<void> {\n\t\tthis.verboseLogging = enabled;\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
