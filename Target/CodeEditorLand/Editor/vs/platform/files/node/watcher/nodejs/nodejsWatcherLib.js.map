{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/files/node/watcher/nodejs/nodejsWatcherLib.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { promises, watch } from \"fs\";\nimport {\n\tRunOnceWorker,\n\tThrottledWorker,\n} from \"../../../../../base/common/async.js\";\nimport {\n\ttype CancellationToken,\n\tCancellationTokenSource,\n} from \"../../../../../base/common/cancellation.js\";\nimport { isEqualOrParent } from \"../../../../../base/common/extpath.js\";\nimport {\n\tDisposable,\n\tDisposableStore,\n\ttype IDisposable,\n\ttoDisposable,\n} from \"../../../../../base/common/lifecycle.js\";\nimport { normalizeNFC } from \"../../../../../base/common/normalization.js\";\nimport { basename, dirname, join } from \"../../../../../base/common/path.js\";\nimport { isLinux, isMacintosh } from \"../../../../../base/common/platform.js\";\nimport { joinPath } from \"../../../../../base/common/resources.js\";\nimport { URI } from \"../../../../../base/common/uri.js\";\nimport { realcase } from \"../../../../../base/node/extpath.js\";\nimport { Promises } from \"../../../../../base/node/pfs.js\";\nimport { FileChangeType, type IFileChange } from \"../../../common/files.js\";\nimport {\n\ttype ILogMessage,\n\ttype INonRecursiveWatchRequest,\n\ttype IRecursiveWatcherWithSubscribe,\n\tcoalesceEvents,\n\tisFiltered,\n\tisWatchRequestWithCorrelation,\n\tparseWatcherPatterns,\n} from \"../../../common/watcher.js\";\n\nexport class NodeJSFileWatcherLibrary extends Disposable {\n\t// A delay in reacting to file deletes to support\n\t// atomic save operations where a tool may chose\n\t// to delete a file before creating it again for\n\t// an update.\n\tprivate static readonly FILE_DELETE_HANDLER_DELAY = 100;\n\n\t// A delay for collecting file changes from node.js\n\t// before collecting them for coalescing and emitting\n\t// Same delay as used for the recursive watcher.\n\tprivate static readonly FILE_CHANGES_HANDLER_DELAY = 75;\n\n\t// Reduce likelyhood of spam from file events via throttling.\n\t// These numbers are a bit more aggressive compared to the\n\t// recursive watcher because we can have many individual\n\t// node.js watchers per request.\n\t// (https://github.com/microsoft/vscode/issues/124723)\n\tprivate readonly throttledFileChangesEmitter = this._register(\n\t\tnew ThrottledWorker<IFileChange>(\n\t\t\t{\n\t\t\t\tmaxWorkChunkSize: 100, // only process up to 100 changes at once before...\n\t\t\t\tthrottleDelay: 200, // ...resting for 200ms until we process events again...\n\t\t\t\tmaxBufferedWork: 10000, // ...but never buffering more than 10000 events in memory\n\t\t\t},\n\t\t\t(events) => this.onDidFilesChange(events),\n\t\t),\n\t);\n\n\t// Aggregate file changes over FILE_CHANGES_HANDLER_DELAY\n\t// to coalesce events and reduce spam.\n\tprivate readonly fileChangesAggregator = this._register(\n\t\tnew RunOnceWorker<IFileChange>(\n\t\t\t(events) => this.handleFileChanges(events),\n\t\t\tNodeJSFileWatcherLibrary.FILE_CHANGES_HANDLER_DELAY,\n\t\t),\n\t);\n\n\tprivate readonly excludes = parseWatcherPatterns(\n\t\tthis.request.path,\n\t\tthis.request.excludes,\n\t);\n\tprivate readonly includes = this.request.includes\n\t\t? parseWatcherPatterns(this.request.path, this.request.includes)\n\t\t: undefined;\n\tprivate readonly filter = isWatchRequestWithCorrelation(this.request)\n\t\t? this.request.filter\n\t\t: undefined; // TODO@bpasero filtering for now is only enabled when correlating because watchers are otherwise potentially reused\n\n\tprivate readonly cts = new CancellationTokenSource();\n\n\treadonly ready = this.watch();\n\n\tprivate _isReusingRecursiveWatcher = false;\n\tget isReusingRecursiveWatcher(): boolean {\n\t\treturn this._isReusingRecursiveWatcher;\n\t}\n\n\tprivate didFail = false;\n\tget failed(): boolean {\n\t\treturn this.didFail;\n\t}\n\n\tconstructor(\n\t\tprivate readonly request: INonRecursiveWatchRequest,\n\t\tprivate readonly recursiveWatcher:\n\t\t\t| IRecursiveWatcherWithSubscribe\n\t\t\t| undefined,\n\t\tprivate readonly onDidFilesChange: (changes: IFileChange[]) => void,\n\t\tprivate readonly onDidWatchFail?: () => void,\n\t\tprivate readonly onLogMessage?: (msg: ILogMessage) => void,\n\t\tprivate verboseLogging?: boolean,\n\t) {\n\t\tsuper();\n\t}\n\n\tprivate async watch(): Promise<void> {\n\t\ttry {\n\t\t\tconst realPath = await this.normalizePath(this.request);\n\n\t\t\tif (this.cts.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst stat = await promises.stat(realPath);\n\n\t\t\tif (this.cts.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._register(await this.doWatch(realPath, stat.isDirectory()));\n\t\t} catch (error) {\n\t\t\tif (error.code !== \"ENOENT\") {\n\t\t\t\tthis.error(error);\n\t\t\t} else {\n\t\t\t\tthis.trace(\n\t\t\t\t\t`ignoring a path for watching who's stat info failed to resolve: ${this.request.path} (error: ${error})`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis.notifyWatchFailed();\n\t\t}\n\t}\n\n\tprivate notifyWatchFailed(): void {\n\t\tthis.didFail = true;\n\n\t\tthis.onDidWatchFail?.();\n\t}\n\n\tprivate async normalizePath(\n\t\trequest: INonRecursiveWatchRequest,\n\t): Promise<string> {\n\t\tlet realPath = request.path;\n\n\t\ttry {\n\t\t\t// First check for symbolic link\n\t\t\trealPath = await Promises.realpath(request.path);\n\n\t\t\t// Second check for casing difference\n\t\t\t// Note: this will be a no-op on Linux platforms\n\t\t\tif (request.path === realPath) {\n\t\t\t\trealPath =\n\t\t\t\t\t(await realcase(request.path, this.cts.token)) ??\n\t\t\t\t\trequest.path;\n\t\t\t}\n\n\t\t\t// Correct watch path as needed\n\t\t\tif (request.path !== realPath) {\n\t\t\t\tthis.trace(\n\t\t\t\t\t`correcting a path to watch that seems to be a symbolic link or wrong casing (original: ${request.path}, real: ${realPath})`,\n\t\t\t\t);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// ignore\n\t\t}\n\n\t\treturn realPath;\n\t}\n\n\tprivate async doWatch(\n\t\trealPath: string,\n\t\tisDirectory: boolean,\n\t): Promise<IDisposable> {\n\t\tconst disposables = new DisposableStore();\n\n\t\tif (\n\t\t\tthis.doWatchWithExistingWatcher(realPath, isDirectory, disposables)\n\t\t) {\n\t\t\tthis.trace(\n\t\t\t\t`reusing an existing recursive watcher for ${this.request.path}`,\n\t\t\t);\n\t\t\tthis._isReusingRecursiveWatcher = true;\n\t\t} else {\n\t\t\tthis._isReusingRecursiveWatcher = false;\n\t\t\tawait this.doWatchWithNodeJS(realPath, isDirectory, disposables);\n\t\t}\n\n\t\treturn disposables;\n\t}\n\n\tprivate doWatchWithExistingWatcher(\n\t\trealPath: string,\n\t\tisDirectory: boolean,\n\t\tdisposables: DisposableStore,\n\t): boolean {\n\t\tif (isDirectory) {\n\t\t\t// TODO@bpasero recursive watcher re-use is currently not enabled\n\t\t\t// for when folders are watched. this is because the dispatching\n\t\t\t// in the recursive watcher for non-recurive requests is optimized\n\t\t\t// for file changes  where we really only match on the exact path\n\t\t\t// and not child paths.\n\t\t\treturn false;\n\t\t}\n\n\t\tconst resource = URI.file(this.request.path);\n\t\tconst subscription = this.recursiveWatcher?.subscribe(\n\t\t\tthis.request.path,\n\t\t\tasync (error, change) => {\n\t\t\t\tif (disposables.isDisposed) {\n\t\t\t\t\treturn; // return early if already disposed\n\t\t\t\t}\n\n\t\t\t\tif (error) {\n\t\t\t\t\tconst watchDisposable = await this.doWatch(\n\t\t\t\t\t\trealPath,\n\t\t\t\t\t\tisDirectory,\n\t\t\t\t\t);\n\t\t\t\t\tif (disposables.isDisposed) {\n\t\t\t\t\t\twatchDisposable.dispose();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdisposables.add(watchDisposable);\n\t\t\t\t\t}\n\t\t\t\t} else if (change) {\n\t\t\t\t\tif (\n\t\t\t\t\t\ttypeof change.cId === \"number\" ||\n\t\t\t\t\t\ttypeof this.request.correlationId === \"number\"\n\t\t\t\t\t) {\n\t\t\t\t\t\t// Re-emit this change with the correlation id of the request\n\t\t\t\t\t\t// so that the client can correlate the event with the request\n\t\t\t\t\t\t// properly. Without correlation, we do not have to do that\n\t\t\t\t\t\t// because the event will appear on the global listener already.\n\t\t\t\t\t\tthis.onFileChange(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tresource,\n\t\t\t\t\t\t\t\ttype: change.type,\n\t\t\t\t\t\t\t\tcId: this.request.correlationId,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\ttrue /* skip excludes/includes (file is explicitly watched) */,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t);\n\n\t\tif (subscription) {\n\t\t\tdisposables.add(subscription);\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate async doWatchWithNodeJS(\n\t\trealPath: string,\n\t\tisDirectory: boolean,\n\t\tdisposables: DisposableStore,\n\t): Promise<void> {\n\t\t// macOS: watching samba shares can crash VSCode so we do\n\t\t// a simple check for the file path pointing to /Volumes\n\t\t// (https://github.com/microsoft/vscode/issues/106879)\n\t\t// TODO@electron this needs a revisit when the crash is\n\t\t// fixed or mitigated upstream.\n\t\tif (isMacintosh && isEqualOrParent(realPath, \"/Volumes/\", true)) {\n\t\t\tthis.error(\n\t\t\t\t`Refusing to watch ${realPath} for changes using fs.watch() for possibly being a network share where watching is unreliable and unstable.`,\n\t\t\t);\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst cts = new CancellationTokenSource(this.cts.token);\n\t\tdisposables.add(toDisposable(() => cts.dispose(true)));\n\n\t\tconst watcherDisposables = new DisposableStore(); // we need a separate disposable store because we re-create the watcher from within in some cases\n\t\tdisposables.add(watcherDisposables);\n\n\t\ttry {\n\t\t\tconst requestResource = URI.file(this.request.path);\n\t\t\tconst pathBasename = basename(realPath);\n\n\t\t\t// Creating watcher can fail with an exception\n\t\t\tconst watcher = watch(realPath);\n\t\t\twatcherDisposables.add(\n\t\t\t\ttoDisposable(() => {\n\t\t\t\t\twatcher.removeAllListeners();\n\t\t\t\t\twatcher.close();\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\tthis.trace(`Started watching: '${realPath}'`);\n\n\t\t\t// Folder: resolve children to emit proper events\n\t\t\tconst folderChildren = new Set<string>();\n\t\t\tif (isDirectory) {\n\t\t\t\ttry {\n\t\t\t\t\tfor (const child of await Promises.readdir(realPath)) {\n\t\t\t\t\t\tfolderChildren.add(child);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.error(error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst mapPathToStatDisposable = new Map<string, IDisposable>();\n\t\t\twatcherDisposables.add(\n\t\t\t\ttoDisposable(() => {\n\t\t\t\t\tfor (const [, disposable] of mapPathToStatDisposable) {\n\t\t\t\t\t\tdisposable.dispose();\n\t\t\t\t\t}\n\t\t\t\t\tmapPathToStatDisposable.clear();\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\twatcher.on(\"error\", (code: number, signal: string) => {\n\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.error(\n\t\t\t\t\t`Failed to watch ${realPath} for changes using fs.watch() (${code}, ${signal})`,\n\t\t\t\t);\n\n\t\t\t\tthis.notifyWatchFailed();\n\t\t\t});\n\n\t\t\twatcher.on(\"change\", (type, raw) => {\n\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\treturn; // ignore if already disposed\n\t\t\t\t}\n\n\t\t\t\tif (this.verboseLogging) {\n\t\t\t\t\tthis.traceWithCorrelation(`[raw] [\"${type}\"] ${raw}`);\n\t\t\t\t}\n\n\t\t\t\t// Normalize file name\n\t\t\t\tlet changedFileName = \"\";\n\t\t\t\tif (raw) {\n\t\t\t\t\t// https://github.com/microsoft/vscode/issues/38191\n\t\t\t\t\tchangedFileName = raw.toString();\n\t\t\t\t\tif (isMacintosh) {\n\t\t\t\t\t\t// Mac: uses NFD unicode form on disk, but we want NFC\n\t\t\t\t\t\t// See also https://github.com/nodejs/node/issues/2165\n\t\t\t\t\t\tchangedFileName = normalizeNFC(changedFileName);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t!changedFileName ||\n\t\t\t\t\t(type !== \"change\" && type !== \"rename\")\n\t\t\t\t) {\n\t\t\t\t\treturn; // ignore unexpected events\n\t\t\t\t}\n\n\t\t\t\t// Folder\n\t\t\t\tif (isDirectory) {\n\t\t\t\t\t// Folder child added/deleted\n\t\t\t\t\tif (type === \"rename\") {\n\t\t\t\t\t\t// Cancel any previous stats for this file if existing\n\t\t\t\t\t\tmapPathToStatDisposable.get(changedFileName)?.dispose();\n\n\t\t\t\t\t\t// Wait a bit and try see if the file still exists on disk\n\t\t\t\t\t\t// to decide on the resulting event\n\t\t\t\t\t\tconst timeoutHandle = setTimeout(async () => {\n\t\t\t\t\t\t\tmapPathToStatDisposable.delete(changedFileName);\n\n\t\t\t\t\t\t\t// Depending on the OS the watcher runs on, there\n\t\t\t\t\t\t\t// is different behaviour for when the watched\n\t\t\t\t\t\t\t// folder path is being deleted:\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t// -   macOS: not reported but events continue to\n\t\t\t\t\t\t\t//            work even when the folder is brought\n\t\t\t\t\t\t\t//            back, though it seems every change\n\t\t\t\t\t\t\t//            to a file is reported as \"rename\"\n\t\t\t\t\t\t\t// -   Linux: \"rename\" event is reported with the\n\t\t\t\t\t\t\t//            name of the folder and events stop\n\t\t\t\t\t\t\t//            working\n\t\t\t\t\t\t\t// - Windows: an EPERM error is thrown that we\n\t\t\t\t\t\t\t//            handle from the `on('error')` event\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t// We do not re-attach the watcher after timeout\n\t\t\t\t\t\t\t// though as we do for file watches because for\n\t\t\t\t\t\t\t// file watching specifically we want to handle\n\t\t\t\t\t\t\t// the atomic-write cases where the file is being\n\t\t\t\t\t\t\t// deleted and recreated with different contents.\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tchangedFileName === pathBasename &&\n\t\t\t\t\t\t\t\t!(await Promises.exists(realPath))\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tthis.onWatchedPathDeleted(requestResource);\n\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// In order to properly detect renames on a case-insensitive\n\t\t\t\t\t\t\t// file system, we need to use `existsChildStrictCase` helper\n\t\t\t\t\t\t\t// because otherwise we would wrongly assume a file exists\n\t\t\t\t\t\t\t// when it was renamed to same name but different case.\n\t\t\t\t\t\t\tconst fileExists = await this.existsChildStrictCase(\n\t\t\t\t\t\t\t\tjoin(realPath, changedFileName),\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\t\t\t\treturn; // ignore if disposed by now\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Figure out the correct event type:\n\t\t\t\t\t\t\t// File Exists: either 'added' or 'updated' if known before\n\t\t\t\t\t\t\t// File Does not Exist: always 'deleted'\n\t\t\t\t\t\t\tlet type: FileChangeType;\n\t\t\t\t\t\t\tif (fileExists) {\n\t\t\t\t\t\t\t\tif (folderChildren.has(changedFileName)) {\n\t\t\t\t\t\t\t\t\ttype = FileChangeType.UPDATED;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ttype = FileChangeType.ADDED;\n\t\t\t\t\t\t\t\t\tfolderChildren.add(changedFileName);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfolderChildren.delete(changedFileName);\n\t\t\t\t\t\t\t\ttype = FileChangeType.DELETED;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.onFileChange({\n\t\t\t\t\t\t\t\tresource: joinPath(\n\t\t\t\t\t\t\t\t\trequestResource,\n\t\t\t\t\t\t\t\t\tchangedFileName,\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\ttype,\n\t\t\t\t\t\t\t\tcId: this.request.correlationId,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}, NodeJSFileWatcherLibrary.FILE_DELETE_HANDLER_DELAY);\n\n\t\t\t\t\t\tmapPathToStatDisposable.set(\n\t\t\t\t\t\t\tchangedFileName,\n\t\t\t\t\t\t\ttoDisposable(() => clearTimeout(timeoutHandle)),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Folder child changed\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Figure out the correct event type: if this is the\n\t\t\t\t\t\t// first time we see this child, it can only be added\n\t\t\t\t\t\tlet type: FileChangeType;\n\t\t\t\t\t\tif (folderChildren.has(changedFileName)) {\n\t\t\t\t\t\t\ttype = FileChangeType.UPDATED;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttype = FileChangeType.ADDED;\n\t\t\t\t\t\t\tfolderChildren.add(changedFileName);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.onFileChange({\n\t\t\t\t\t\t\tresource: joinPath(\n\t\t\t\t\t\t\t\trequestResource,\n\t\t\t\t\t\t\t\tchangedFileName,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\ttype,\n\t\t\t\t\t\t\tcId: this.request.correlationId,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// File\n\t\t\t\telse {\n\t\t\t\t\t// File added/deleted\n\t\t\t\t\tif (type === \"rename\" || changedFileName !== pathBasename) {\n\t\t\t\t\t\t// Depending on the OS the watcher runs on, there\n\t\t\t\t\t\t// is different behaviour for when the watched\n\t\t\t\t\t\t// file path is being deleted:\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// -   macOS: \"rename\" event is reported and events\n\t\t\t\t\t\t//            stop working\n\t\t\t\t\t\t// -   Linux: \"rename\" event is reported and events\n\t\t\t\t\t\t//            stop working\n\t\t\t\t\t\t// - Windows: \"rename\" event is reported and events\n\t\t\t\t\t\t//            continue to work when file is restored\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// As opposed to folder watching, we re-attach the\n\t\t\t\t\t\t// watcher after brief timeout to support \"atomic save\"\n\t\t\t\t\t\t// operations where a tool may decide to delete a file\n\t\t\t\t\t\t// and then create it with the updated contents.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Different to folder watching, we emit a delete event\n\t\t\t\t\t\t// though we never detect when the file is brought back\n\t\t\t\t\t\t// because the watcher is disposed then.\n\n\t\t\t\t\t\tconst timeoutHandle = setTimeout(async () => {\n\t\t\t\t\t\t\tconst fileExists = await Promises.exists(realPath);\n\n\t\t\t\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\t\t\t\treturn; // ignore if disposed by now\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// File still exists, so emit as change event and reapply the watcher\n\t\t\t\t\t\t\tif (fileExists) {\n\t\t\t\t\t\t\t\tthis.onFileChange(\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tresource: requestResource,\n\t\t\t\t\t\t\t\t\t\ttype: FileChangeType.UPDATED,\n\t\t\t\t\t\t\t\t\t\tcId: this.request.correlationId,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttrue /* skip excludes/includes (file is explicitly watched) */,\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\twatcherDisposables.add(\n\t\t\t\t\t\t\t\t\tawait this.doWatch(realPath, false),\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// File seems to be really gone, so emit a deleted and failed event\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tthis.onWatchedPathDeleted(requestResource);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, NodeJSFileWatcherLibrary.FILE_DELETE_HANDLER_DELAY);\n\n\t\t\t\t\t\t// Very important to dispose the watcher which now points to a stale inode\n\t\t\t\t\t\t// and wire in a new disposable that tracks our timeout that is installed\n\t\t\t\t\t\twatcherDisposables.clear();\n\t\t\t\t\t\twatcherDisposables.add(\n\t\t\t\t\t\t\ttoDisposable(() => clearTimeout(timeoutHandle)),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\t// File changed\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.onFileChange(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tresource: requestResource,\n\t\t\t\t\t\t\t\ttype: FileChangeType.UPDATED,\n\t\t\t\t\t\t\t\tcId: this.request.correlationId,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\ttrue /* skip excludes/includes (file is explicitly watched) */,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tif (!cts.token.isCancellationRequested) {\n\t\t\t\tthis.error(\n\t\t\t\t\t`Failed to watch ${realPath} for changes using fs.watch() (${error.toString()})`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis.notifyWatchFailed();\n\t\t}\n\t}\n\n\tprivate onWatchedPathDeleted(resource: URI): void {\n\t\tthis.warn(\"Watcher shutdown because watched path got deleted\");\n\n\t\t// Emit events and flush in case the watcher gets disposed\n\t\tthis.onFileChange(\n\t\t\t{\n\t\t\t\tresource,\n\t\t\t\ttype: FileChangeType.DELETED,\n\t\t\t\tcId: this.request.correlationId,\n\t\t\t},\n\t\t\ttrue /* skip excludes/includes (file is explicitly watched) */,\n\t\t);\n\t\tthis.fileChangesAggregator.flush();\n\n\t\tthis.notifyWatchFailed();\n\t}\n\n\tprivate onFileChange(\n\t\tevent: IFileChange,\n\t\tskipIncludeExcludeChecks = false,\n\t): void {\n\t\tif (this.cts.token.isCancellationRequested) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Logging\n\t\tif (this.verboseLogging) {\n\t\t\tthis.traceWithCorrelation(\n\t\t\t\t`${event.type === FileChangeType.ADDED ? \"[ADDED]\" : event.type === FileChangeType.DELETED ? \"[DELETED]\" : \"[CHANGED]\"} ${event.resource.fsPath}`,\n\t\t\t);\n\t\t}\n\n\t\t// Add to aggregator unless excluded or not included (not if explicitly disabled)\n\t\tif (\n\t\t\t!skipIncludeExcludeChecks &&\n\t\t\tthis.excludes.some((exclude) => exclude(event.resource.fsPath))\n\t\t) {\n\t\t\tif (this.verboseLogging) {\n\t\t\t\tthis.traceWithCorrelation(\n\t\t\t\t\t` >> ignored (excluded) ${event.resource.fsPath}`,\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (\n\t\t\t!skipIncludeExcludeChecks &&\n\t\t\tthis.includes &&\n\t\t\tthis.includes.length > 0 &&\n\t\t\t!this.includes.some((include) => include(event.resource.fsPath))\n\t\t) {\n\t\t\tif (this.verboseLogging) {\n\t\t\t\tthis.traceWithCorrelation(\n\t\t\t\t\t` >> ignored (not included) ${event.resource.fsPath}`,\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.fileChangesAggregator.work(event);\n\t\t}\n\t}\n\n\tprivate handleFileChanges(fileChanges: IFileChange[]): void {\n\t\t// Coalesce events: merge events of same kind\n\t\tconst coalescedFileChanges = coalesceEvents(fileChanges);\n\n\t\t// Filter events: based on request filter property\n\t\tconst filteredEvents: IFileChange[] = [];\n\t\tfor (const event of coalescedFileChanges) {\n\t\t\tif (isFiltered(event, this.filter)) {\n\t\t\t\tif (this.verboseLogging) {\n\t\t\t\t\tthis.traceWithCorrelation(\n\t\t\t\t\t\t` >> ignored (filtered) ${event.resource.fsPath}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfilteredEvents.push(event);\n\t\t}\n\n\t\tif (filteredEvents.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Logging\n\t\tif (this.verboseLogging) {\n\t\t\tfor (const event of filteredEvents) {\n\t\t\t\tthis.traceWithCorrelation(\n\t\t\t\t\t` >> normalized ${event.type === FileChangeType.ADDED ? \"[ADDED]\" : event.type === FileChangeType.DELETED ? \"[DELETED]\" : \"[CHANGED]\"} ${event.resource.fsPath}`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Broadcast to clients via throttled emitter\n\t\tconst worked = this.throttledFileChangesEmitter.work(filteredEvents);\n\n\t\t// Logging\n\t\tif (worked) {\n\t\t\tif (this.throttledFileChangesEmitter.pending > 0) {\n\t\t\t\tthis.trace(\n\t\t\t\t\t`started throttling events due to large amount of file change events at once (pending: ${this.throttledFileChangesEmitter.pending}, most recent change: ${filteredEvents[0].resource.fsPath}). Use 'files.watcherExclude' setting to exclude folders with lots of changing files (e.g. compilation output).`,\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.warn(\n\t\t\t\t`started ignoring events due to too many file change events at once (incoming: ${filteredEvents.length}, most recent change: ${filteredEvents[0].resource.fsPath}). Use 'files.watcherExclude' setting to exclude folders with lots of changing files (e.g. compilation output).`,\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate async existsChildStrictCase(path: string): Promise<boolean> {\n\t\tif (isLinux) {\n\t\t\treturn Promises.exists(path);\n\t\t}\n\n\t\ttry {\n\t\t\tconst pathBasename = basename(path);\n\t\t\tconst children = await Promises.readdir(dirname(path));\n\n\t\t\treturn children.some((child) => child === pathBasename);\n\t\t} catch (error) {\n\t\t\tthis.trace(error);\n\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tsetVerboseLogging(verboseLogging: boolean): void {\n\t\tthis.verboseLogging = verboseLogging;\n\t}\n\n\tprivate error(error: string): void {\n\t\tif (!this.cts.token.isCancellationRequested) {\n\t\t\tthis.onLogMessage?.({\n\t\t\t\ttype: \"error\",\n\t\t\t\tmessage: `[File Watcher (node.js)] ${error}`,\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate warn(message: string): void {\n\t\tif (!this.cts.token.isCancellationRequested) {\n\t\t\tthis.onLogMessage?.({\n\t\t\t\ttype: \"warn\",\n\t\t\t\tmessage: `[File Watcher (node.js)] ${message}`,\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate trace(message: string): void {\n\t\tif (!this.cts.token.isCancellationRequested && this.verboseLogging) {\n\t\t\tthis.onLogMessage?.({\n\t\t\t\ttype: \"trace\",\n\t\t\t\tmessage: `[File Watcher (node.js)] ${message}`,\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate traceWithCorrelation(message: string): void {\n\t\tif (!this.cts.token.isCancellationRequested && this.verboseLogging) {\n\t\t\tthis.trace(\n\t\t\t\t`${message}${typeof this.request.correlationId === \"number\" ? ` <${this.request.correlationId}> ` : ``}`,\n\t\t\t);\n\t\t}\n\t}\n\n\toverride dispose(): void {\n\t\tthis.cts.dispose(true);\n\n\t\tsuper.dispose();\n\t}\n}\n\n/**\n * Watch the provided `path` for changes and return\n * the data in chunks of `Uint8Array` for further use.\n */\nexport async function watchFileContents(\n\tpath: string,\n\tonData: (chunk: Uint8Array) => void,\n\tonReady: () => void,\n\ttoken: CancellationToken,\n\tbufferSize = 512,\n): Promise<void> {\n\tconst handle = await Promises.open(path, \"r\");\n\tconst buffer = Buffer.allocUnsafe(bufferSize);\n\n\tconst cts = new CancellationTokenSource(token);\n\n\tlet error: Error | undefined;\n\tlet isReading = false;\n\n\tconst request: INonRecursiveWatchRequest = {\n\t\tpath,\n\t\texcludes: [],\n\t\trecursive: false,\n\t};\n\tconst watcher = new NodeJSFileWatcherLibrary(\n\t\trequest,\n\t\tundefined,\n\t\t(changes) => {\n\t\t\t(async () => {\n\t\t\t\tfor (const { type } of changes) {\n\t\t\t\t\tif (type === FileChangeType.UPDATED) {\n\t\t\t\t\t\tif (isReading) {\n\t\t\t\t\t\t\treturn; // return early if we are already reading the output\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tisReading = true;\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// Consume the new contents of the file until finished\n\t\t\t\t\t\t\t// everytime there is a change event signalling a change\n\t\t\t\t\t\t\twhile (!cts.token.isCancellationRequested) {\n\t\t\t\t\t\t\t\tconst { bytesRead } = await Promises.read(\n\t\t\t\t\t\t\t\t\thandle,\n\t\t\t\t\t\t\t\t\tbuffer,\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t\tbufferSize,\n\t\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t!bytesRead ||\n\t\t\t\t\t\t\t\t\tcts.token.isCancellationRequested\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tonData(buffer.slice(0, bytesRead));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\terror = new Error(err);\n\t\t\t\t\t\t\tcts.dispose(true);\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tisReading = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})();\n\t\t},\n\t);\n\n\tawait watcher.ready;\n\tonReady();\n\n\treturn new Promise<void>((resolve, reject) => {\n\t\tcts.token.onCancellationRequested(async () => {\n\t\t\twatcher.dispose();\n\n\t\t\ttry {\n\t\t\t\tawait Promises.close(handle);\n\t\t\t} catch (err) {\n\t\t\t\terror = new Error(err);\n\t\t\t}\n\n\t\t\tif (error) {\n\t\t\t\treject(error);\n\t\t\t} else {\n\t\t\t\tresolve();\n\t\t\t}\n\t\t});\n\t});\n}\n"],
  "mappings": "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",
  "names": ["type"]
}
