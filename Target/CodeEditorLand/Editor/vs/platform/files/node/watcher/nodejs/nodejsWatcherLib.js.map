{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/files/node/watcher/nodejs/nodejsWatcherLib.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { watch, promises } from 'fs';\nimport { RunOnceWorker, ThrottledWorker } from '../../../../../base/common/async.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../../../base/common/cancellation.js';\nimport { isEqualOrParent } from '../../../../../base/common/extpath.js';\nimport { Disposable, DisposableStore, IDisposable, toDisposable } from '../../../../../base/common/lifecycle.js';\nimport { normalizeNFC } from '../../../../../base/common/normalization.js';\nimport { basename, dirname, join } from '../../../../../base/common/path.js';\nimport { isLinux, isMacintosh } from '../../../../../base/common/platform.js';\nimport { joinPath } from '../../../../../base/common/resources.js';\nimport { URI } from '../../../../../base/common/uri.js';\nimport { realcase } from '../../../../../base/node/extpath.js';\nimport { Promises } from '../../../../../base/node/pfs.js';\nimport { FileChangeType, IFileChange } from '../../../common/files.js';\nimport { ILogMessage, coalesceEvents, INonRecursiveWatchRequest, parseWatcherPatterns, IRecursiveWatcherWithSubscribe, isFiltered, isWatchRequestWithCorrelation } from '../../../common/watcher.js';\n\nexport class NodeJSFileWatcherLibrary extends Disposable {\n\n\t// A delay in reacting to file deletes to support\n\t// atomic save operations where a tool may chose\n\t// to delete a file before creating it again for\n\t// an update.\n\tprivate static readonly FILE_DELETE_HANDLER_DELAY = 100;\n\n\t// A delay for collecting file changes from node.js\n\t// before collecting them for coalescing and emitting\n\t// Same delay as used for the recursive watcher.\n\tprivate static readonly FILE_CHANGES_HANDLER_DELAY = 75;\n\n\t// Reduce likelyhood of spam from file events via throttling.\n\t// These numbers are a bit more aggressive compared to the\n\t// recursive watcher because we can have many individual\n\t// node.js watchers per request.\n\t// (https://github.com/microsoft/vscode/issues/124723)\n\tprivate readonly throttledFileChangesEmitter = this._register(new ThrottledWorker<IFileChange>(\n\t\t{\n\t\t\tmaxWorkChunkSize: 100,\t// only process up to 100 changes at once before...\n\t\t\tthrottleDelay: 200,\t  \t// ...resting for 200ms until we process events again...\n\t\t\tmaxBufferedWork: 10000 \t// ...but never buffering more than 10000 events in memory\n\t\t},\n\t\tevents => this.onDidFilesChange(events)\n\t));\n\n\t// Aggregate file changes over FILE_CHANGES_HANDLER_DELAY\n\t// to coalesce events and reduce spam.\n\tprivate readonly fileChangesAggregator = this._register(new RunOnceWorker<IFileChange>(events => this.handleFileChanges(events), NodeJSFileWatcherLibrary.FILE_CHANGES_HANDLER_DELAY));\n\n\tprivate readonly excludes = parseWatcherPatterns(this.request.path, this.request.excludes);\n\tprivate readonly includes = this.request.includes ? parseWatcherPatterns(this.request.path, this.request.includes) : undefined;\n\tprivate readonly filter = isWatchRequestWithCorrelation(this.request) ? this.request.filter : undefined; // TODO@bpasero filtering for now is only enabled when correlating because watchers are otherwise potentially reused\n\n\tprivate readonly cts = new CancellationTokenSource();\n\n\treadonly ready = this.watch();\n\n\tprivate _isReusingRecursiveWatcher = false;\n\tget isReusingRecursiveWatcher(): boolean { return this._isReusingRecursiveWatcher; }\n\n\tprivate didFail = false;\n\tget failed(): boolean { return this.didFail; }\n\n\tconstructor(\n\t\tprivate readonly request: INonRecursiveWatchRequest,\n\t\tprivate readonly recursiveWatcher: IRecursiveWatcherWithSubscribe | undefined,\n\t\tprivate readonly onDidFilesChange: (changes: IFileChange[]) => void,\n\t\tprivate readonly onDidWatchFail?: () => void,\n\t\tprivate readonly onLogMessage?: (msg: ILogMessage) => void,\n\t\tprivate verboseLogging?: boolean\n\t) {\n\t\tsuper();\n\t}\n\n\tprivate async watch(): Promise<void> {\n\t\ttry {\n\t\t\tconst realPath = await this.normalizePath(this.request);\n\n\t\t\tif (this.cts.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst stat = await promises.stat(realPath);\n\n\t\t\tif (this.cts.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._register(await this.doWatch(realPath, stat.isDirectory()));\n\t\t} catch (error) {\n\t\t\tif (error.code !== 'ENOENT') {\n\t\t\t\tthis.error(error);\n\t\t\t} else {\n\t\t\t\tthis.trace(`ignoring a path for watching who's stat info failed to resolve: ${this.request.path} (error: ${error})`);\n\t\t\t}\n\n\t\t\tthis.notifyWatchFailed();\n\t\t}\n\t}\n\n\tprivate notifyWatchFailed(): void {\n\t\tthis.didFail = true;\n\n\t\tthis.onDidWatchFail?.();\n\t}\n\n\tprivate async normalizePath(request: INonRecursiveWatchRequest): Promise<string> {\n\t\tlet realPath = request.path;\n\n\t\ttry {\n\n\t\t\t// First check for symbolic link\n\t\t\trealPath = await Promises.realpath(request.path);\n\n\t\t\t// Second check for casing difference\n\t\t\t// Note: this will be a no-op on Linux platforms\n\t\t\tif (request.path === realPath) {\n\t\t\t\trealPath = await realcase(request.path, this.cts.token) ?? request.path;\n\t\t\t}\n\n\t\t\t// Correct watch path as needed\n\t\t\tif (request.path !== realPath) {\n\t\t\t\tthis.trace(`correcting a path to watch that seems to be a symbolic link or wrong casing (original: ${request.path}, real: ${realPath})`);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// ignore\n\t\t}\n\n\t\treturn realPath;\n\t}\n\n\tprivate async doWatch(realPath: string, isDirectory: boolean): Promise<IDisposable> {\n\t\tconst disposables = new DisposableStore();\n\n\t\tif (this.doWatchWithExistingWatcher(realPath, isDirectory, disposables)) {\n\t\t\tthis.trace(`reusing an existing recursive watcher for ${this.request.path}`);\n\t\t\tthis._isReusingRecursiveWatcher = true;\n\t\t} else {\n\t\t\tthis._isReusingRecursiveWatcher = false;\n\t\t\tawait this.doWatchWithNodeJS(realPath, isDirectory, disposables);\n\t\t}\n\n\t\treturn disposables;\n\t}\n\n\tprivate doWatchWithExistingWatcher(realPath: string, isDirectory: boolean, disposables: DisposableStore): boolean {\n\t\tif (isDirectory) {\n\t\t\t// TODO@bpasero recursive watcher re-use is currently not enabled\n\t\t\t// for when folders are watched. this is because the dispatching\n\t\t\t// in the recursive watcher for non-recurive requests is optimized\n\t\t\t// for file changes  where we really only match on the exact path\n\t\t\t// and not child paths.\n\t\t\treturn false;\n\t\t}\n\n\t\tconst resource = URI.file(this.request.path);\n\t\tconst subscription = this.recursiveWatcher?.subscribe(this.request.path, async (error, change) => {\n\t\t\tif (disposables.isDisposed) {\n\t\t\t\treturn; // return early if already disposed\n\t\t\t}\n\n\t\t\tif (error) {\n\t\t\t\tconst watchDisposable = await this.doWatch(realPath, isDirectory);\n\t\t\t\tif (!disposables.isDisposed) {\n\t\t\t\t\tdisposables.add(watchDisposable);\n\t\t\t\t} else {\n\t\t\t\t\twatchDisposable.dispose();\n\t\t\t\t}\n\t\t\t} else if (change) {\n\t\t\t\tif (typeof change.cId === 'number' || typeof this.request.correlationId === 'number') {\n\t\t\t\t\t// Re-emit this change with the correlation id of the request\n\t\t\t\t\t// so that the client can correlate the event with the request\n\t\t\t\t\t// properly. Without correlation, we do not have to do that\n\t\t\t\t\t// because the event will appear on the global listener already.\n\t\t\t\t\tthis.onFileChange({ resource, type: change.type, cId: this.request.correlationId }, true /* skip excludes/includes (file is explicitly watched) */);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (subscription) {\n\t\t\tdisposables.add(subscription);\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate async doWatchWithNodeJS(realPath: string, isDirectory: boolean, disposables: DisposableStore): Promise<void> {\n\n\t\t// macOS: watching samba shares can crash VSCode so we do\n\t\t// a simple check for the file path pointing to /Volumes\n\t\t// (https://github.com/microsoft/vscode/issues/106879)\n\t\t// TODO@electron this needs a revisit when the crash is\n\t\t// fixed or mitigated upstream.\n\t\tif (isMacintosh && isEqualOrParent(realPath, '/Volumes/', true)) {\n\t\t\tthis.error(`Refusing to watch ${realPath} for changes using fs.watch() for possibly being a network share where watching is unreliable and unstable.`);\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst cts = new CancellationTokenSource(this.cts.token);\n\t\tdisposables.add(toDisposable(() => cts.dispose(true)));\n\n\t\tconst watcherDisposables = new DisposableStore(); // we need a separate disposable store because we re-create the watcher from within in some cases\n\t\tdisposables.add(watcherDisposables);\n\n\t\ttry {\n\t\t\tconst requestResource = URI.file(this.request.path);\n\t\t\tconst pathBasename = basename(realPath);\n\n\t\t\t// Creating watcher can fail with an exception\n\t\t\tconst watcher = watch(realPath);\n\t\t\twatcherDisposables.add(toDisposable(() => {\n\t\t\t\twatcher.removeAllListeners();\n\t\t\t\twatcher.close();\n\t\t\t}));\n\n\t\t\tthis.trace(`Started watching: '${realPath}'`);\n\n\t\t\t// Folder: resolve children to emit proper events\n\t\t\tconst folderChildren = new Set<string>();\n\t\t\tif (isDirectory) {\n\t\t\t\ttry {\n\t\t\t\t\tfor (const child of await Promises.readdir(realPath)) {\n\t\t\t\t\t\tfolderChildren.add(child);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.error(error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst mapPathToStatDisposable = new Map<string, IDisposable>();\n\t\t\twatcherDisposables.add(toDisposable(() => {\n\t\t\t\tfor (const [, disposable] of mapPathToStatDisposable) {\n\t\t\t\t\tdisposable.dispose();\n\t\t\t\t}\n\t\t\t\tmapPathToStatDisposable.clear();\n\t\t\t}));\n\n\t\t\twatcher.on('error', (code: number, signal: string) => {\n\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.error(`Failed to watch ${realPath} for changes using fs.watch() (${code}, ${signal})`);\n\n\t\t\t\tthis.notifyWatchFailed();\n\t\t\t});\n\n\t\t\twatcher.on('change', (type, raw) => {\n\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\treturn; // ignore if already disposed\n\t\t\t\t}\n\n\t\t\t\tif (this.verboseLogging) {\n\t\t\t\t\tthis.traceWithCorrelation(`[raw] [\"${type}\"] ${raw}`);\n\t\t\t\t}\n\n\t\t\t\t// Normalize file name\n\t\t\t\tlet changedFileName = '';\n\t\t\t\tif (raw) { // https://github.com/microsoft/vscode/issues/38191\n\t\t\t\t\tchangedFileName = raw.toString();\n\t\t\t\t\tif (isMacintosh) {\n\t\t\t\t\t\t// Mac: uses NFD unicode form on disk, but we want NFC\n\t\t\t\t\t\t// See also https://github.com/nodejs/node/issues/2165\n\t\t\t\t\t\tchangedFileName = normalizeNFC(changedFileName);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!changedFileName || (type !== 'change' && type !== 'rename')) {\n\t\t\t\t\treturn; // ignore unexpected events\n\t\t\t\t}\n\n\t\t\t\t// Folder\n\t\t\t\tif (isDirectory) {\n\n\t\t\t\t\t// Folder child added/deleted\n\t\t\t\t\tif (type === 'rename') {\n\n\t\t\t\t\t\t// Cancel any previous stats for this file if existing\n\t\t\t\t\t\tmapPathToStatDisposable.get(changedFileName)?.dispose();\n\n\t\t\t\t\t\t// Wait a bit and try see if the file still exists on disk\n\t\t\t\t\t\t// to decide on the resulting event\n\t\t\t\t\t\tconst timeoutHandle = setTimeout(async () => {\n\t\t\t\t\t\t\tmapPathToStatDisposable.delete(changedFileName);\n\n\t\t\t\t\t\t\t// Depending on the OS the watcher runs on, there\n\t\t\t\t\t\t\t// is different behaviour for when the watched\n\t\t\t\t\t\t\t// folder path is being deleted:\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t// -   macOS: not reported but events continue to\n\t\t\t\t\t\t\t//            work even when the folder is brought\n\t\t\t\t\t\t\t//            back, though it seems every change\n\t\t\t\t\t\t\t//            to a file is reported as \"rename\"\n\t\t\t\t\t\t\t// -   Linux: \"rename\" event is reported with the\n\t\t\t\t\t\t\t//            name of the folder and events stop\n\t\t\t\t\t\t\t//            working\n\t\t\t\t\t\t\t// - Windows: an EPERM error is thrown that we\n\t\t\t\t\t\t\t//            handle from the `on('error')` event\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t// We do not re-attach the watcher after timeout\n\t\t\t\t\t\t\t// though as we do for file watches because for\n\t\t\t\t\t\t\t// file watching specifically we want to handle\n\t\t\t\t\t\t\t// the atomic-write cases where the file is being\n\t\t\t\t\t\t\t// deleted and recreated with different contents.\n\t\t\t\t\t\t\tif (changedFileName === pathBasename && !await Promises.exists(realPath)) {\n\t\t\t\t\t\t\t\tthis.onWatchedPathDeleted(requestResource);\n\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// In order to properly detect renames on a case-insensitive\n\t\t\t\t\t\t\t// file system, we need to use `existsChildStrictCase` helper\n\t\t\t\t\t\t\t// because otherwise we would wrongly assume a file exists\n\t\t\t\t\t\t\t// when it was renamed to same name but different case.\n\t\t\t\t\t\t\tconst fileExists = await this.existsChildStrictCase(join(realPath, changedFileName));\n\n\t\t\t\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\t\t\t\treturn; // ignore if disposed by now\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Figure out the correct event type:\n\t\t\t\t\t\t\t// File Exists: either 'added' or 'updated' if known before\n\t\t\t\t\t\t\t// File Does not Exist: always 'deleted'\n\t\t\t\t\t\t\tlet type: FileChangeType;\n\t\t\t\t\t\t\tif (fileExists) {\n\t\t\t\t\t\t\t\tif (folderChildren.has(changedFileName)) {\n\t\t\t\t\t\t\t\t\ttype = FileChangeType.UPDATED;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ttype = FileChangeType.ADDED;\n\t\t\t\t\t\t\t\t\tfolderChildren.add(changedFileName);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfolderChildren.delete(changedFileName);\n\t\t\t\t\t\t\t\ttype = FileChangeType.DELETED;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.onFileChange({ resource: joinPath(requestResource, changedFileName), type, cId: this.request.correlationId });\n\t\t\t\t\t\t}, NodeJSFileWatcherLibrary.FILE_DELETE_HANDLER_DELAY);\n\n\t\t\t\t\t\tmapPathToStatDisposable.set(changedFileName, toDisposable(() => clearTimeout(timeoutHandle)));\n\t\t\t\t\t}\n\n\t\t\t\t\t// Folder child changed\n\t\t\t\t\telse {\n\n\t\t\t\t\t\t// Figure out the correct event type: if this is the\n\t\t\t\t\t\t// first time we see this child, it can only be added\n\t\t\t\t\t\tlet type: FileChangeType;\n\t\t\t\t\t\tif (folderChildren.has(changedFileName)) {\n\t\t\t\t\t\t\ttype = FileChangeType.UPDATED;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttype = FileChangeType.ADDED;\n\t\t\t\t\t\t\tfolderChildren.add(changedFileName);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.onFileChange({ resource: joinPath(requestResource, changedFileName), type, cId: this.request.correlationId });\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// File\n\t\t\t\telse {\n\n\t\t\t\t\t// File added/deleted\n\t\t\t\t\tif (type === 'rename' || changedFileName !== pathBasename) {\n\n\t\t\t\t\t\t// Depending on the OS the watcher runs on, there\n\t\t\t\t\t\t// is different behaviour for when the watched\n\t\t\t\t\t\t// file path is being deleted:\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// -   macOS: \"rename\" event is reported and events\n\t\t\t\t\t\t//            stop working\n\t\t\t\t\t\t// -   Linux: \"rename\" event is reported and events\n\t\t\t\t\t\t//            stop working\n\t\t\t\t\t\t// - Windows: \"rename\" event is reported and events\n\t\t\t\t\t\t//            continue to work when file is restored\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// As opposed to folder watching, we re-attach the\n\t\t\t\t\t\t// watcher after brief timeout to support \"atomic save\"\n\t\t\t\t\t\t// operations where a tool may decide to delete a file\n\t\t\t\t\t\t// and then create it with the updated contents.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Different to folder watching, we emit a delete event\n\t\t\t\t\t\t// though we never detect when the file is brought back\n\t\t\t\t\t\t// because the watcher is disposed then.\n\n\t\t\t\t\t\tconst timeoutHandle = setTimeout(async () => {\n\t\t\t\t\t\t\tconst fileExists = await Promises.exists(realPath);\n\n\t\t\t\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\t\t\t\treturn; // ignore if disposed by now\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// File still exists, so emit as change event and reapply the watcher\n\t\t\t\t\t\t\tif (fileExists) {\n\t\t\t\t\t\t\t\tthis.onFileChange({ resource: requestResource, type: FileChangeType.UPDATED, cId: this.request.correlationId }, true /* skip excludes/includes (file is explicitly watched) */);\n\n\t\t\t\t\t\t\t\twatcherDisposables.add(await this.doWatch(realPath, false));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// File seems to be really gone, so emit a deleted and failed event\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tthis.onWatchedPathDeleted(requestResource);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, NodeJSFileWatcherLibrary.FILE_DELETE_HANDLER_DELAY);\n\n\t\t\t\t\t\t// Very important to dispose the watcher which now points to a stale inode\n\t\t\t\t\t\t// and wire in a new disposable that tracks our timeout that is installed\n\t\t\t\t\t\twatcherDisposables.clear();\n\t\t\t\t\t\twatcherDisposables.add(toDisposable(() => clearTimeout(timeoutHandle)));\n\t\t\t\t\t}\n\n\t\t\t\t\t// File changed\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.onFileChange({ resource: requestResource, type: FileChangeType.UPDATED, cId: this.request.correlationId }, true /* skip excludes/includes (file is explicitly watched) */);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tif (!cts.token.isCancellationRequested) {\n\t\t\t\tthis.error(`Failed to watch ${realPath} for changes using fs.watch() (${error.toString()})`);\n\t\t\t}\n\n\t\t\tthis.notifyWatchFailed();\n\t\t}\n\t}\n\n\tprivate onWatchedPathDeleted(resource: URI): void {\n\t\tthis.warn('Watcher shutdown because watched path got deleted');\n\n\t\t// Emit events and flush in case the watcher gets disposed\n\t\tthis.onFileChange({ resource, type: FileChangeType.DELETED, cId: this.request.correlationId }, true /* skip excludes/includes (file is explicitly watched) */);\n\t\tthis.fileChangesAggregator.flush();\n\n\t\tthis.notifyWatchFailed();\n\t}\n\n\tprivate onFileChange(event: IFileChange, skipIncludeExcludeChecks = false): void {\n\t\tif (this.cts.token.isCancellationRequested) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Logging\n\t\tif (this.verboseLogging) {\n\t\t\tthis.traceWithCorrelation(`${event.type === FileChangeType.ADDED ? '[ADDED]' : event.type === FileChangeType.DELETED ? '[DELETED]' : '[CHANGED]'} ${event.resource.fsPath}`);\n\t\t}\n\n\t\t// Add to aggregator unless excluded or not included (not if explicitly disabled)\n\t\tif (!skipIncludeExcludeChecks && this.excludes.some(exclude => exclude(event.resource.fsPath))) {\n\t\t\tif (this.verboseLogging) {\n\t\t\t\tthis.traceWithCorrelation(` >> ignored (excluded) ${event.resource.fsPath}`);\n\t\t\t}\n\t\t} else if (!skipIncludeExcludeChecks && this.includes && this.includes.length > 0 && !this.includes.some(include => include(event.resource.fsPath))) {\n\t\t\tif (this.verboseLogging) {\n\t\t\t\tthis.traceWithCorrelation(` >> ignored (not included) ${event.resource.fsPath}`);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.fileChangesAggregator.work(event);\n\t\t}\n\t}\n\n\tprivate handleFileChanges(fileChanges: IFileChange[]): void {\n\n\t\t// Coalesce events: merge events of same kind\n\t\tconst coalescedFileChanges = coalesceEvents(fileChanges);\n\n\t\t// Filter events: based on request filter property\n\t\tconst filteredEvents: IFileChange[] = [];\n\t\tfor (const event of coalescedFileChanges) {\n\t\t\tif (isFiltered(event, this.filter)) {\n\t\t\t\tif (this.verboseLogging) {\n\t\t\t\t\tthis.traceWithCorrelation(` >> ignored (filtered) ${event.resource.fsPath}`);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfilteredEvents.push(event);\n\t\t}\n\n\t\tif (filteredEvents.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Logging\n\t\tif (this.verboseLogging) {\n\t\t\tfor (const event of filteredEvents) {\n\t\t\t\tthis.traceWithCorrelation(` >> normalized ${event.type === FileChangeType.ADDED ? '[ADDED]' : event.type === FileChangeType.DELETED ? '[DELETED]' : '[CHANGED]'} ${event.resource.fsPath}`);\n\t\t\t}\n\t\t}\n\n\t\t// Broadcast to clients via throttled emitter\n\t\tconst worked = this.throttledFileChangesEmitter.work(filteredEvents);\n\n\t\t// Logging\n\t\tif (!worked) {\n\t\t\tthis.warn(`started ignoring events due to too many file change events at once (incoming: ${filteredEvents.length}, most recent change: ${filteredEvents[0].resource.fsPath}). Use 'files.watcherExclude' setting to exclude folders with lots of changing files (e.g. compilation output).`);\n\t\t} else {\n\t\t\tif (this.throttledFileChangesEmitter.pending > 0) {\n\t\t\t\tthis.trace(`started throttling events due to large amount of file change events at once (pending: ${this.throttledFileChangesEmitter.pending}, most recent change: ${filteredEvents[0].resource.fsPath}). Use 'files.watcherExclude' setting to exclude folders with lots of changing files (e.g. compilation output).`);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async existsChildStrictCase(path: string): Promise<boolean> {\n\t\tif (isLinux) {\n\t\t\treturn Promises.exists(path);\n\t\t}\n\n\t\ttry {\n\t\t\tconst pathBasename = basename(path);\n\t\t\tconst children = await Promises.readdir(dirname(path));\n\n\t\t\treturn children.some(child => child === pathBasename);\n\t\t} catch (error) {\n\t\t\tthis.trace(error);\n\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tsetVerboseLogging(verboseLogging: boolean): void {\n\t\tthis.verboseLogging = verboseLogging;\n\t}\n\n\tprivate error(error: string): void {\n\t\tif (!this.cts.token.isCancellationRequested) {\n\t\t\tthis.onLogMessage?.({ type: 'error', message: `[File Watcher (node.js)] ${error}` });\n\t\t}\n\t}\n\n\tprivate warn(message: string): void {\n\t\tif (!this.cts.token.isCancellationRequested) {\n\t\t\tthis.onLogMessage?.({ type: 'warn', message: `[File Watcher (node.js)] ${message}` });\n\t\t}\n\t}\n\n\tprivate trace(message: string): void {\n\t\tif (!this.cts.token.isCancellationRequested && this.verboseLogging) {\n\t\t\tthis.onLogMessage?.({ type: 'trace', message: `[File Watcher (node.js)] ${message}` });\n\t\t}\n\t}\n\n\tprivate traceWithCorrelation(message: string): void {\n\t\tif (!this.cts.token.isCancellationRequested && this.verboseLogging) {\n\t\t\tthis.trace(`${message}${typeof this.request.correlationId === 'number' ? ` <${this.request.correlationId}> ` : ``}`);\n\t\t}\n\t}\n\n\toverride dispose(): void {\n\t\tthis.cts.dispose(true);\n\n\t\tsuper.dispose();\n\t}\n}\n\n/**\n * Watch the provided `path` for changes and return\n * the data in chunks of `Uint8Array` for further use.\n */\nexport async function watchFileContents(path: string, onData: (chunk: Uint8Array) => void, onReady: () => void, token: CancellationToken, bufferSize = 512): Promise<void> {\n\tconst handle = await Promises.open(path, 'r');\n\tconst buffer = Buffer.allocUnsafe(bufferSize);\n\n\tconst cts = new CancellationTokenSource(token);\n\n\tlet error: Error | undefined = undefined;\n\tlet isReading = false;\n\n\tconst request: INonRecursiveWatchRequest = { path, excludes: [], recursive: false };\n\tconst watcher = new NodeJSFileWatcherLibrary(request, undefined, changes => {\n\t\t(async () => {\n\t\t\tfor (const { type } of changes) {\n\t\t\t\tif (type === FileChangeType.UPDATED) {\n\n\t\t\t\t\tif (isReading) {\n\t\t\t\t\t\treturn; // return early if we are already reading the output\n\t\t\t\t\t}\n\n\t\t\t\t\tisReading = true;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Consume the new contents of the file until finished\n\t\t\t\t\t\t// everytime there is a change event signalling a change\n\t\t\t\t\t\twhile (!cts.token.isCancellationRequested) {\n\t\t\t\t\t\t\tconst { bytesRead } = await Promises.read(handle, buffer, 0, bufferSize, null);\n\t\t\t\t\t\t\tif (!bytesRead || cts.token.isCancellationRequested) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tonData(buffer.slice(0, bytesRead));\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\terror = new Error(err);\n\t\t\t\t\t\tcts.dispose(true);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tisReading = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})();\n\t});\n\n\tawait watcher.ready;\n\tonReady();\n\n\treturn new Promise<void>((resolve, reject) => {\n\t\tcts.token.onCancellationRequested(async () => {\n\t\t\twatcher.dispose();\n\n\t\t\ttry {\n\t\t\t\tawait Promises.close(handle);\n\t\t\t} catch (err) {\n\t\t\t\terror = new Error(err);\n\t\t\t}\n\n\t\t\tif (error) {\n\t\t\t\treject(error);\n\t\t\t} else {\n\t\t\t\tresolve();\n\t\t\t}\n\t\t});\n\t});\n}\n"],
  "mappings": "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",
  "names": ["type"]
}
