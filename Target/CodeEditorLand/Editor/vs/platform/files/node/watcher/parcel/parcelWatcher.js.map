{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/files/node/watcher/parcel/parcelWatcher.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { existsSync, statSync, unlinkSync } from \"fs\";\nimport { homedir, tmpdir } from \"os\";\nimport * as parcelWatcher2 from \"@bpasero/watcher\";\nimport * as parcelWatcher from \"@parcel/watcher\";\nimport {\n\tDeferredPromise,\n\tRunOnceScheduler,\n\tRunOnceWorker,\n\tThrottledWorker,\n} from \"../../../../../base/common/async.js\";\nimport {\n\ttype CancellationToken,\n\tCancellationTokenSource,\n} from \"../../../../../base/common/cancellation.js\";\nimport { toErrorMessage } from \"../../../../../base/common/errorMessage.js\";\nimport { Emitter, Event } from \"../../../../../base/common/event.js\";\nimport {\n\tisEqual,\n\tisEqualOrParent,\n\trandomPath,\n} from \"../../../../../base/common/extpath.js\";\nimport { GLOBSTAR, patternsEquals } from \"../../../../../base/common/glob.js\";\nimport {\n\tDisposable,\n\tDisposableStore,\n\ttype IDisposable,\n\ttoDisposable,\n} from \"../../../../../base/common/lifecycle.js\";\nimport { normalizeNFC } from \"../../../../../base/common/normalization.js\";\nimport { dirname, join, normalize } from \"../../../../../base/common/path.js\";\nimport {\n\tisLinux,\n\tisMacintosh,\n\tisWindows,\n} from \"../../../../../base/common/platform.js\";\nimport { TernarySearchTree } from \"../../../../../base/common/ternarySearchTree.js\";\nimport { URI } from \"../../../../../base/common/uri.js\";\nimport {\n\trealcaseSync,\n\trealpathSync,\n} from \"../../../../../base/node/extpath.js\";\nimport { FileChangeType, type IFileChange } from \"../../../common/files.js\";\nimport {\n\ttype IRecursiveWatchRequest,\n\ttype IRecursiveWatcherWithSubscribe,\n\ttype IWatcherErrorEvent,\n\tcoalesceEvents,\n\tisFiltered,\n\tparseWatcherPatterns,\n} from \"../../../common/watcher.js\";\nimport { BaseWatcher } from \"../baseWatcher.js\";\nimport { NodeJSFileWatcherLibrary } from \"../nodejs/nodejsWatcherLib.js\";\n\nexport class ParcelWatcherInstance extends Disposable {\n\tprivate readonly _onDidStop = this._register(\n\t\tnew Emitter<{ joinRestart?: Promise<void> }>(),\n\t);\n\treadonly onDidStop = this._onDidStop.event;\n\n\tprivate readonly _onDidFail = this._register(new Emitter<void>());\n\treadonly onDidFail = this._onDidFail.event;\n\n\tprivate didFail = false;\n\tget failed(): boolean {\n\t\treturn this.didFail;\n\t}\n\n\tprivate didStop = false;\n\tget stopped(): boolean {\n\t\treturn this.didStop;\n\t}\n\n\tprivate readonly includes = this.request.includes\n\t\t? parseWatcherPatterns(this.request.path, this.request.includes)\n\t\t: undefined;\n\tprivate readonly excludes = this.request.excludes\n\t\t? parseWatcherPatterns(this.request.path, this.request.excludes)\n\t\t: undefined;\n\n\tprivate readonly subscriptions = new Map<\n\t\tstring,\n\t\tSet<(change: IFileChange) => void>\n\t>();\n\n\tconstructor(\n\t\t/**\n\t\t * Signals when the watcher is ready to watch.\n\t\t */\n\t\treadonly ready: Promise<unknown>,\n\t\treadonly request: IRecursiveWatchRequest,\n\t\t/**\n\t\t * How often this watcher has been restarted in case of an unexpected\n\t\t * shutdown.\n\t\t */\n\t\treadonly restarts: number,\n\t\t/**\n\t\t * The cancellation token associated with the lifecycle of the watcher.\n\t\t */\n\t\treadonly token: CancellationToken,\n\t\t/**\n\t\t * An event aggregator to coalesce events and reduce duplicates.\n\t\t */\n\t\treadonly worker: RunOnceWorker<IFileChange>,\n\t\tprivate readonly stopFn: () => Promise<void>,\n\t) {\n\t\tsuper();\n\n\t\tthis._register(toDisposable(() => this.subscriptions.clear()));\n\t}\n\n\tsubscribe(\n\t\tpath: string,\n\t\tcallback: (change: IFileChange) => void,\n\t): IDisposable {\n\t\tpath = URI.file(path).fsPath; // make sure to store the path in `fsPath` form to match it with events later\n\n\t\tlet subscriptions = this.subscriptions.get(path);\n\t\tif (!subscriptions) {\n\t\t\tsubscriptions = new Set();\n\t\t\tthis.subscriptions.set(path, subscriptions);\n\t\t}\n\n\t\tsubscriptions.add(callback);\n\n\t\treturn toDisposable(() => {\n\t\t\tconst subscriptions = this.subscriptions.get(path);\n\t\t\tif (subscriptions) {\n\t\t\t\tsubscriptions.delete(callback);\n\n\t\t\t\tif (subscriptions.size === 0) {\n\t\t\t\t\tthis.subscriptions.delete(path);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tget subscriptionsCount(): number {\n\t\treturn this.subscriptions.size;\n\t}\n\n\tnotifyFileChange(path: string, change: IFileChange): void {\n\t\tconst subscriptions = this.subscriptions.get(path);\n\t\tif (subscriptions) {\n\t\t\tfor (const subscription of subscriptions) {\n\t\t\t\tsubscription(change);\n\t\t\t}\n\t\t}\n\t}\n\n\tnotifyWatchFailed(): void {\n\t\tthis.didFail = true;\n\n\t\tthis._onDidFail.fire();\n\t}\n\n\tinclude(path: string): boolean {\n\t\tif (!this.includes || this.includes.length === 0) {\n\t\t\treturn true; // no specific includes defined, include all\n\t\t}\n\n\t\treturn this.includes.some((include) => include(path));\n\t}\n\n\texclude(path: string): boolean {\n\t\treturn Boolean(this.excludes?.some((exclude) => exclude(path)));\n\t}\n\n\tasync stop(joinRestart: Promise<void> | undefined): Promise<void> {\n\t\tthis.didStop = true;\n\n\t\ttry {\n\t\t\tawait this.stopFn();\n\t\t} finally {\n\t\t\tthis._onDidStop.fire({ joinRestart });\n\t\t\tthis.dispose();\n\t\t}\n\t}\n}\n\nexport class ParcelWatcher\n\textends BaseWatcher\n\timplements IRecursiveWatcherWithSubscribe\n{\n\tprivate static readonly MAP_PARCEL_WATCHER_ACTION_TO_FILE_CHANGE = new Map<\n\t\tparcelWatcher.EventType,\n\t\tnumber\n\t>([\n\t\t[\"create\", FileChangeType.ADDED],\n\t\t[\"update\", FileChangeType.UPDATED],\n\t\t[\"delete\", FileChangeType.DELETED],\n\t]);\n\n\tprivate static readonly PREDEFINED_EXCLUDES: {\n\t\t[platform: string]: string[];\n\t} = {\n\t\twin32: [],\n\t\tdarwin: [\n\t\t\tjoin(homedir(), \"Library\", \"Containers\"), // Triggers access dialog from macOS 14 (https://github.com/microsoft/vscode/issues/208105)\n\t\t],\n\t\tlinux: [],\n\t};\n\n\tprivate static readonly PARCEL_WATCHER_BACKEND = isWindows\n\t\t? \"windows\"\n\t\t: isLinux\n\t\t\t? \"inotify\"\n\t\t\t: \"fs-events\";\n\n\tprivate readonly _onDidError = this._register(\n\t\tnew Emitter<IWatcherErrorEvent>(),\n\t);\n\treadonly onDidError = this._onDidError.event;\n\n\treadonly watchers = new Set<ParcelWatcherInstance>();\n\n\t// A delay for collecting file changes from Parcel\n\t// before collecting them for coalescing and emitting.\n\t// Parcel internally uses 50ms as delay, so we use 75ms,\n\t// to schedule sufficiently after Parcel.\n\t//\n\t// Note: since Parcel 2.0.7, the very first event is\n\t// emitted without delay if no events occured over a\n\t// duration of 500ms. But we always want to aggregate\n\t// events to apply our coleasing logic.\n\t//\n\tprivate static readonly FILE_CHANGES_HANDLER_DELAY = 75;\n\n\t// Reduce likelyhood of spam from file events via throttling.\n\t// (https://github.com/microsoft/vscode/issues/124723)\n\tprivate readonly throttledFileChangesEmitter = this._register(\n\t\tnew ThrottledWorker<IFileChange>(\n\t\t\t{\n\t\t\t\tmaxWorkChunkSize: 500, // only process up to 500 changes at once before...\n\t\t\t\tthrottleDelay: 200, // ...resting for 200ms until we process events again...\n\t\t\t\tmaxBufferedWork: 30000, // ...but never buffering more than 30000 events in memory\n\t\t\t},\n\t\t\t(events) => this._onDidChangeFile.fire(events),\n\t\t),\n\t);\n\n\tprivate enospcErrorLogged = false;\n\n\tconstructor() {\n\t\tsuper();\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\t// Error handling on process\n\t\tprocess.on(\"uncaughtException\", (error) =>\n\t\t\tthis.onUnexpectedError(error),\n\t\t);\n\t\tprocess.on(\"unhandledRejection\", (error) =>\n\t\t\tthis.onUnexpectedError(error),\n\t\t);\n\t}\n\n\tprotected override async doWatch(\n\t\trequests: IRecursiveWatchRequest[],\n\t): Promise<void> {\n\t\t// Figure out duplicates to remove from the requests\n\t\trequests = this.removeDuplicateRequests(requests);\n\n\t\t// Figure out which watchers to start and which to stop\n\t\tconst requestsToStart: IRecursiveWatchRequest[] = [];\n\t\tconst watchersToStop = new Set(Array.from(this.watchers));\n\t\tfor (const request of requests) {\n\t\t\tconst watcher = this.findWatcher(request);\n\t\t\tif (\n\t\t\t\twatcher &&\n\t\t\t\tpatternsEquals(watcher.request.excludes, request.excludes) &&\n\t\t\t\tpatternsEquals(watcher.request.includes, request.includes) &&\n\t\t\t\twatcher.request.pollingInterval === request.pollingInterval\n\t\t\t) {\n\t\t\t\twatchersToStop.delete(watcher); // keep watcher\n\t\t\t} else {\n\t\t\t\trequestsToStart.push(request); // start watching\n\t\t\t}\n\t\t}\n\n\t\t// Logging\n\t\tif (requestsToStart.length) {\n\t\t\tthis.trace(\n\t\t\t\t`Request to start watching: ${requestsToStart.map((request) => this.requestToString(request)).join(\",\")}`,\n\t\t\t);\n\t\t}\n\n\t\tif (watchersToStop.size) {\n\t\t\tthis.trace(\n\t\t\t\t`Request to stop watching: ${Array.from(watchersToStop)\n\t\t\t\t\t.map((watcher) => this.requestToString(watcher.request))\n\t\t\t\t\t.join(\",\")}`,\n\t\t\t);\n\t\t}\n\n\t\t// Stop watching as instructed\n\t\tfor (const watcher of watchersToStop) {\n\t\t\tawait this.stopWatching(watcher);\n\t\t}\n\n\t\t// Start watching as instructed\n\t\tfor (const request of requestsToStart) {\n\t\t\tif (request.pollingInterval) {\n\t\t\t\tthis.startPolling(request, request.pollingInterval);\n\t\t\t} else {\n\t\t\t\tawait this.startWatching(request);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate findWatcher(\n\t\trequest: IRecursiveWatchRequest,\n\t): ParcelWatcherInstance | undefined {\n\t\tfor (const watcher of this.watchers) {\n\t\t\t// Requests or watchers with correlation always match on that\n\t\t\tif (\n\t\t\t\tthis.isCorrelated(request) ||\n\t\t\t\tthis.isCorrelated(watcher.request)\n\t\t\t) {\n\t\t\t\tif (watcher.request.correlationId === request.correlationId) {\n\t\t\t\t\treturn watcher;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Non-correlated requests or watchers match on path\n\t\t\telse if (\n\t\t\t\tisEqual(\n\t\t\t\t\twatcher.request.path,\n\t\t\t\t\trequest.path,\n\t\t\t\t\t!isLinux /* ignorecase */,\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\treturn watcher;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate startPolling(\n\t\trequest: IRecursiveWatchRequest,\n\t\tpollingInterval: number,\n\t\trestarts = 0,\n\t): void {\n\t\tconst cts = new CancellationTokenSource();\n\n\t\tconst instance = new DeferredPromise<void>();\n\n\t\tconst snapshotFile = randomPath(tmpdir(), \"vscode-watcher-snapshot\");\n\n\t\t// Remember as watcher instance\n\t\tconst watcher: ParcelWatcherInstance = new ParcelWatcherInstance(\n\t\t\tinstance.p,\n\t\t\trequest,\n\t\t\trestarts,\n\t\t\tcts.token,\n\t\t\tnew RunOnceWorker<IFileChange>(\n\t\t\t\t(events) => this.handleParcelEvents(events, watcher),\n\t\t\t\tParcelWatcher.FILE_CHANGES_HANDLER_DELAY,\n\t\t\t),\n\t\t\tasync () => {\n\t\t\t\tcts.dispose(true);\n\n\t\t\t\twatcher.worker.flush();\n\t\t\t\twatcher.worker.dispose();\n\n\t\t\t\tpollingWatcher.dispose();\n\t\t\t\tunlinkSync(snapshotFile);\n\t\t\t},\n\t\t);\n\t\tthis.watchers.add(watcher);\n\n\t\t// Path checks for symbolic links / wrong casing\n\t\tconst { realPath, realPathDiffers, realPathLength } =\n\t\t\tthis.normalizePath(request);\n\n\t\tthis.trace(\n\t\t\t`Started watching: '${realPath}' with polling interval '${pollingInterval}' and version '${request.useNext ? \"next\" : \"stable\"}'`,\n\t\t);\n\n\t\tlet counter = 0;\n\n\t\tconst pollingWatcher = new RunOnceScheduler(async () => {\n\t\t\tcounter++;\n\n\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// We already ran before, check for events since\n\t\t\tconst parcelWatcherLib = request.useNext\n\t\t\t\t? parcelWatcher2\n\t\t\t\t: parcelWatcher;\n\t\t\tif (counter > 1) {\n\t\t\t\tconst parcelEvents = await parcelWatcherLib.getEventsSince(\n\t\t\t\t\trealPath,\n\t\t\t\t\tsnapshotFile,\n\t\t\t\t\t{\n\t\t\t\t\t\tignore: this.addPredefinedExcludes(request.excludes),\n\t\t\t\t\t\tbackend: ParcelWatcher.PARCEL_WATCHER_BACKEND,\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Handle & emit events\n\t\t\t\tthis.onParcelEvents(\n\t\t\t\t\tparcelEvents,\n\t\t\t\t\twatcher,\n\t\t\t\t\trealPathDiffers,\n\t\t\t\t\trealPathLength,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Store a snapshot of files to the snapshot file\n\t\t\tawait parcelWatcherLib.writeSnapshot(realPath, snapshotFile, {\n\t\t\t\tignore: this.addPredefinedExcludes(request.excludes),\n\t\t\t\tbackend: ParcelWatcher.PARCEL_WATCHER_BACKEND,\n\t\t\t});\n\n\t\t\t// Signal we are ready now when the first snapshot was written\n\t\t\tif (counter === 1) {\n\t\t\t\tinstance.complete();\n\t\t\t}\n\n\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Schedule again at the next interval\n\t\t\tpollingWatcher.schedule();\n\t\t}, pollingInterval);\n\t\tpollingWatcher.schedule(0);\n\t}\n\n\tprivate async startWatching(\n\t\trequest: IRecursiveWatchRequest,\n\t\trestarts = 0,\n\t): Promise<void> {\n\t\tconst cts = new CancellationTokenSource();\n\n\t\tconst instance = new DeferredPromise<\n\t\t\tparcelWatcher.AsyncSubscription | undefined\n\t\t>();\n\n\t\t// Remember as watcher instance\n\t\tconst watcher: ParcelWatcherInstance = new ParcelWatcherInstance(\n\t\t\tinstance.p,\n\t\t\trequest,\n\t\t\trestarts,\n\t\t\tcts.token,\n\t\t\tnew RunOnceWorker<IFileChange>(\n\t\t\t\t(events) => this.handleParcelEvents(events, watcher),\n\t\t\t\tParcelWatcher.FILE_CHANGES_HANDLER_DELAY,\n\t\t\t),\n\t\t\tasync () => {\n\t\t\t\tcts.dispose(true);\n\n\t\t\t\twatcher.worker.flush();\n\t\t\t\twatcher.worker.dispose();\n\n\t\t\t\tconst watcherInstance = await instance.p;\n\t\t\t\tawait watcherInstance?.unsubscribe();\n\t\t\t},\n\t\t);\n\t\tthis.watchers.add(watcher);\n\n\t\t// Path checks for symbolic links / wrong casing\n\t\tconst { realPath, realPathDiffers, realPathLength } =\n\t\t\tthis.normalizePath(request);\n\n\t\ttry {\n\t\t\tconst parcelWatcherLib = request.useNext\n\t\t\t\t? parcelWatcher2\n\t\t\t\t: parcelWatcher;\n\t\t\tconst parcelWatcherInstance = await parcelWatcherLib.subscribe(\n\t\t\t\trealPath,\n\t\t\t\t(error, parcelEvents) => {\n\t\t\t\t\tif (watcher.token.isCancellationRequested) {\n\t\t\t\t\t\treturn; // return early when disposed\n\t\t\t\t\t}\n\n\t\t\t\t\t// In any case of an error, treat this like a unhandled exception\n\t\t\t\t\t// that might require the watcher to restart. We do not really know\n\t\t\t\t\t// the state of parcel at this point and as such will try to restart\n\t\t\t\t\t// up to our maximum of restarts.\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tthis.onUnexpectedError(error, request);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Handle & emit events\n\t\t\t\t\tthis.onParcelEvents(\n\t\t\t\t\t\tparcelEvents,\n\t\t\t\t\t\twatcher,\n\t\t\t\t\t\trealPathDiffers,\n\t\t\t\t\t\trealPathLength,\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tbackend: ParcelWatcher.PARCEL_WATCHER_BACKEND,\n\t\t\t\t\tignore: this.addPredefinedExcludes(\n\t\t\t\t\t\twatcher.request.excludes,\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tthis.trace(\n\t\t\t\t`Started watching: '${realPath}' with backend '${ParcelWatcher.PARCEL_WATCHER_BACKEND}' and version '${request.useNext ? \"next\" : \"stable\"}'`,\n\t\t\t);\n\n\t\t\tinstance.complete(parcelWatcherInstance);\n\t\t} catch (error) {\n\t\t\tthis.onUnexpectedError(error, request);\n\n\t\t\tinstance.complete(undefined);\n\n\t\t\twatcher.notifyWatchFailed();\n\t\t\tthis._onDidWatchFail.fire(request);\n\t\t}\n\t}\n\n\tprivate addPredefinedExcludes(initialExcludes: string[]): string[] {\n\t\tconst excludes = [...initialExcludes];\n\n\t\tconst predefinedExcludes =\n\t\t\tParcelWatcher.PREDEFINED_EXCLUDES[process.platform];\n\t\tif (Array.isArray(predefinedExcludes)) {\n\t\t\tfor (const exclude of predefinedExcludes) {\n\t\t\t\tif (!excludes.includes(exclude)) {\n\t\t\t\t\texcludes.push(exclude);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn excludes;\n\t}\n\n\tprivate onParcelEvents(\n\t\tparcelEvents: parcelWatcher.Event[],\n\t\twatcher: ParcelWatcherInstance,\n\t\trealPathDiffers: boolean,\n\t\trealPathLength: number,\n\t): void {\n\t\tif (parcelEvents.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Normalize events: handle NFC normalization and symlinks\n\t\t// It is important to do this before checking for includes\n\t\t// to check on the original path.\n\t\tthis.normalizeEvents(\n\t\t\tparcelEvents,\n\t\t\twatcher.request,\n\t\t\trealPathDiffers,\n\t\t\trealPathLength,\n\t\t);\n\n\t\t// Check for includes\n\t\tconst includedEvents = this.handleIncludes(watcher, parcelEvents);\n\n\t\t// Add to event aggregator for later processing\n\t\tfor (const includedEvent of includedEvents) {\n\t\t\twatcher.worker.work(includedEvent);\n\t\t}\n\t}\n\n\tprivate handleIncludes(\n\t\twatcher: ParcelWatcherInstance,\n\t\tparcelEvents: parcelWatcher.Event[],\n\t): IFileChange[] {\n\t\tconst events: IFileChange[] = [];\n\n\t\tfor (const { path, type: parcelEventType } of parcelEvents) {\n\t\t\tconst type =\n\t\t\t\tParcelWatcher.MAP_PARCEL_WATCHER_ACTION_TO_FILE_CHANGE.get(\n\t\t\t\t\tparcelEventType,\n\t\t\t\t)!;\n\t\t\tif (this.verboseLogging) {\n\t\t\t\tthis.traceWithCorrelation(\n\t\t\t\t\t`${type === FileChangeType.ADDED ? \"[ADDED]\" : type === FileChangeType.DELETED ? \"[DELETED]\" : \"[CHANGED]\"} ${path}`,\n\t\t\t\t\twatcher.request,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Apply include filter if any\n\t\t\tif (watcher.include(path)) {\n\t\t\t\tevents.push({\n\t\t\t\t\ttype,\n\t\t\t\t\tresource: URI.file(path),\n\t\t\t\t\tcId: watcher.request.correlationId,\n\t\t\t\t});\n\t\t\t} else if (this.verboseLogging) {\n\t\t\t\tthis.traceWithCorrelation(\n\t\t\t\t\t` >> ignored (not included) ${path}`,\n\t\t\t\t\twatcher.request,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn events;\n\t}\n\n\tprivate handleParcelEvents(\n\t\tparcelEvents: IFileChange[],\n\t\twatcher: ParcelWatcherInstance,\n\t): void {\n\t\t// Coalesce events: merge events of same kind\n\t\tconst coalescedEvents = coalesceEvents(parcelEvents);\n\n\t\t// Filter events: check for specific events we want to exclude\n\t\tconst { events: filteredEvents, rootDeleted } = this.filterEvents(\n\t\t\tcoalescedEvents,\n\t\t\twatcher,\n\t\t);\n\n\t\t// Broadcast to clients\n\t\tthis.emitEvents(filteredEvents, watcher);\n\n\t\t// Handle root path deletes\n\t\tif (rootDeleted) {\n\t\t\tthis.onWatchedPathDeleted(watcher);\n\t\t}\n\t}\n\n\tprivate emitEvents(\n\t\tevents: IFileChange[],\n\t\twatcher: ParcelWatcherInstance,\n\t): void {\n\t\tif (events.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Broadcast to clients via throttler\n\t\tconst worked = this.throttledFileChangesEmitter.work(events);\n\n\t\t// Logging\n\t\tif (worked) {\n\t\t\tif (this.throttledFileChangesEmitter.pending > 0) {\n\t\t\t\tthis.trace(\n\t\t\t\t\t`started throttling events due to large amount of file change events at once (pending: ${this.throttledFileChangesEmitter.pending}, most recent change: ${events[0].resource.fsPath}). Use 'files.watcherExclude' setting to exclude folders with lots of changing files (e.g. compilation output).`,\n\t\t\t\t\twatcher,\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.warn(\n\t\t\t\t`started ignoring events due to too many file change events at once (incoming: ${events.length}, most recent change: ${events[0].resource.fsPath}). Use 'files.watcherExclude' setting to exclude folders with lots of changing files (e.g. compilation output).`,\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate normalizePath(request: IRecursiveWatchRequest): {\n\t\trealPath: string;\n\t\trealPathDiffers: boolean;\n\t\trealPathLength: number;\n\t} {\n\t\tlet realPath = request.path;\n\t\tlet realPathDiffers = false;\n\t\tlet realPathLength = request.path.length;\n\n\t\ttry {\n\t\t\t// First check for symbolic link\n\t\t\trealPath = realpathSync(request.path);\n\n\t\t\t// Second check for casing difference\n\t\t\t// Note: this will be a no-op on Linux platforms\n\t\t\tif (request.path === realPath) {\n\t\t\t\trealPath = realcaseSync(request.path) ?? request.path;\n\t\t\t}\n\n\t\t\t// Correct watch path as needed\n\t\t\tif (request.path !== realPath) {\n\t\t\t\trealPathLength = realPath.length;\n\t\t\t\trealPathDiffers = true;\n\n\t\t\t\tthis.trace(\n\t\t\t\t\t`correcting a path to watch that seems to be a symbolic link or wrong casing (original: ${request.path}, real: ${realPath})`,\n\t\t\t\t);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// ignore\n\t\t}\n\n\t\treturn { realPath, realPathDiffers, realPathLength };\n\t}\n\n\tprivate normalizeEvents(\n\t\tevents: parcelWatcher.Event[],\n\t\trequest: IRecursiveWatchRequest,\n\t\trealPathDiffers: boolean,\n\t\trealPathLength: number,\n\t): void {\n\t\tfor (const event of events) {\n\t\t\t// Mac uses NFD unicode form on disk, but we want NFC\n\t\t\tif (isMacintosh) {\n\t\t\t\tevent.path = normalizeNFC(event.path);\n\t\t\t}\n\n\t\t\t// Workaround for https://github.com/parcel-bundler/watcher/issues/68\n\t\t\t// where watching root drive letter adds extra backslashes.\n\t\t\tif (isWindows) {\n\t\t\t\tif (request.path.length <= 3) {\n\t\t\t\t\t// for ex. c:, C:\\\n\t\t\t\t\tevent.path = normalize(event.path);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Convert paths back to original form in case it differs\n\t\t\tif (realPathDiffers) {\n\t\t\t\tevent.path = request.path + event.path.substr(realPathLength);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate filterEvents(\n\t\tevents: IFileChange[],\n\t\twatcher: ParcelWatcherInstance,\n\t): { events: IFileChange[]; rootDeleted?: boolean } {\n\t\tconst filteredEvents: IFileChange[] = [];\n\t\tlet rootDeleted = false;\n\n\t\tconst filter = this.isCorrelated(watcher.request)\n\t\t\t? watcher.request.filter\n\t\t\t: undefined; // TODO@bpasero filtering for now is only enabled when correlating because watchers are otherwise potentially reused\n\t\tfor (const event of events) {\n\t\t\t// Emit to instance subscriptions if any before filtering\n\t\t\tif (watcher.subscriptionsCount > 0) {\n\t\t\t\twatcher.notifyFileChange(event.resource.fsPath, event);\n\t\t\t}\n\n\t\t\t// Filtering\n\t\t\trootDeleted =\n\t\t\t\tevent.type === FileChangeType.DELETED &&\n\t\t\t\tisEqual(event.resource.fsPath, watcher.request.path, !isLinux);\n\t\t\tif (\n\t\t\t\tisFiltered(event, filter) ||\n\t\t\t\t// Explicitly exclude changes to root if we have any\n\t\t\t\t// to avoid VS Code closing all opened editors which\n\t\t\t\t// can happen e.g. in case of network connectivity\n\t\t\t\t// issues\n\t\t\t\t// (https://github.com/microsoft/vscode/issues/136673)\n\t\t\t\t//\n\t\t\t\t// Update 2024: with the new correlated events, we\n\t\t\t\t// really do not want to skip over file events any\n\t\t\t\t// more, so we only ignore this event for non-correlated\n\t\t\t\t// watch requests.\n\t\t\t\t(rootDeleted && !this.isCorrelated(watcher.request))\n\t\t\t) {\n\t\t\t\tif (this.verboseLogging) {\n\t\t\t\t\tthis.traceWithCorrelation(\n\t\t\t\t\t\t` >> ignored (filtered) ${event.resource.fsPath}`,\n\t\t\t\t\t\twatcher.request,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Logging\n\t\t\tthis.traceEvent(event, watcher.request);\n\n\t\t\tfilteredEvents.push(event);\n\t\t}\n\n\t\treturn { events: filteredEvents, rootDeleted };\n\t}\n\n\tprivate onWatchedPathDeleted(watcher: ParcelWatcherInstance): void {\n\t\tthis.warn(\"Watcher shutdown because watched path got deleted\", watcher);\n\n\t\tlet legacyMonitored = false;\n\t\tif (!this.isCorrelated(watcher.request)) {\n\t\t\t// Do monitoring of the request path parent unless this request\n\t\t\t// can be handled via suspend/resume in the super class\n\t\t\tlegacyMonitored = this.legacyMonitorRequest(watcher);\n\t\t}\n\n\t\tif (!legacyMonitored) {\n\t\t\twatcher.notifyWatchFailed();\n\t\t\tthis._onDidWatchFail.fire(watcher.request);\n\t\t}\n\t}\n\n\tprivate legacyMonitorRequest(watcher: ParcelWatcherInstance): boolean {\n\t\tconst parentPath = dirname(watcher.request.path);\n\t\tif (existsSync(parentPath)) {\n\t\t\tthis.trace(\n\t\t\t\t\"Trying to watch on the parent path to restart the watcher...\",\n\t\t\t\twatcher,\n\t\t\t);\n\n\t\t\tconst nodeWatcher = new NodeJSFileWatcherLibrary(\n\t\t\t\t{\n\t\t\t\t\tpath: parentPath,\n\t\t\t\t\texcludes: [],\n\t\t\t\t\trecursive: false,\n\t\t\t\t\tcorrelationId: watcher.request.correlationId,\n\t\t\t\t},\n\t\t\t\tundefined,\n\t\t\t\t(changes) => {\n\t\t\t\t\tif (watcher.token.isCancellationRequested) {\n\t\t\t\t\t\treturn; // return early when disposed\n\t\t\t\t\t}\n\n\t\t\t\t\t// Watcher path came back! Restart watching...\n\t\t\t\t\tfor (const { resource, type } of changes) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tisEqual(\n\t\t\t\t\t\t\t\tresource.fsPath,\n\t\t\t\t\t\t\t\twatcher.request.path,\n\t\t\t\t\t\t\t\t!isLinux,\n\t\t\t\t\t\t\t) &&\n\t\t\t\t\t\t\t(type === FileChangeType.ADDED ||\n\t\t\t\t\t\t\t\ttype === FileChangeType.UPDATED)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tif (this.isPathValid(watcher.request.path)) {\n\t\t\t\t\t\t\t\tthis.warn(\n\t\t\t\t\t\t\t\t\t\"Watcher restarts because watched path got created again\",\n\t\t\t\t\t\t\t\t\twatcher,\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t// Stop watching that parent folder\n\t\t\t\t\t\t\t\tnodeWatcher.dispose();\n\n\t\t\t\t\t\t\t\t// Restart the file watching\n\t\t\t\t\t\t\t\tthis.restartWatching(watcher);\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tundefined,\n\t\t\t\t(msg) => this._onDidLogMessage.fire(msg),\n\t\t\t\tthis.verboseLogging,\n\t\t\t);\n\n\t\t\t// Make sure to stop watching when the watcher is disposed\n\t\t\twatcher.token.onCancellationRequested(() => nodeWatcher.dispose());\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate onUnexpectedError(\n\t\terror: unknown,\n\t\trequest?: IRecursiveWatchRequest,\n\t): void {\n\t\tconst msg = toErrorMessage(error);\n\n\t\t// Specially handle ENOSPC errors that can happen when\n\t\t// the watcher consumes so many file descriptors that\n\t\t// we are running into a limit. We only want to warn\n\t\t// once in this case to avoid log spam.\n\t\t// See https://github.com/microsoft/vscode/issues/7950\n\t\tif (msg.indexOf(\"No space left on device\") !== -1) {\n\t\t\tif (!this.enospcErrorLogged) {\n\t\t\t\tthis.error(\"Inotify limit reached (ENOSPC)\", request);\n\n\t\t\t\tthis.enospcErrorLogged = true;\n\t\t\t}\n\t\t}\n\n\t\t// Any other error is unexpected and we should try to\n\t\t// restart the watcher as a result to get into healthy\n\t\t// state again if possible and if not attempted too much\n\t\telse {\n\t\t\tthis.error(`Unexpected error: ${msg} (EUNKNOWN)`, request);\n\n\t\t\tthis._onDidError.fire({ request, error: msg });\n\t\t}\n\t}\n\n\toverride async stop(): Promise<void> {\n\t\tawait super.stop();\n\n\t\tfor (const watcher of this.watchers) {\n\t\t\tawait this.stopWatching(watcher);\n\t\t}\n\t}\n\n\tprotected restartWatching(\n\t\twatcher: ParcelWatcherInstance,\n\t\tdelay = 800,\n\t): void {\n\t\t// Restart watcher delayed to accomodate for\n\t\t// changes on disk that have triggered the\n\t\t// need for a restart in the first place.\n\t\tconst scheduler = new RunOnceScheduler(async () => {\n\t\t\tif (watcher.token.isCancellationRequested) {\n\t\t\t\treturn; // return early when disposed\n\t\t\t}\n\n\t\t\tconst restartPromise = new DeferredPromise<void>();\n\t\t\ttry {\n\t\t\t\t// Await the watcher having stopped, as this is\n\t\t\t\t// needed to properly re-watch the same path\n\t\t\t\tawait this.stopWatching(watcher, restartPromise.p);\n\n\t\t\t\t// Start watcher again counting the restarts\n\t\t\t\tif (watcher.request.pollingInterval) {\n\t\t\t\t\tthis.startPolling(\n\t\t\t\t\t\twatcher.request,\n\t\t\t\t\t\twatcher.request.pollingInterval,\n\t\t\t\t\t\twatcher.restarts + 1,\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tawait this.startWatching(\n\t\t\t\t\t\twatcher.request,\n\t\t\t\t\t\twatcher.restarts + 1,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\trestartPromise.complete();\n\t\t\t}\n\t\t}, delay);\n\n\t\tscheduler.schedule();\n\t\twatcher.token.onCancellationRequested(() => scheduler.dispose());\n\t}\n\n\tprivate async stopWatching(\n\t\twatcher: ParcelWatcherInstance,\n\t\tjoinRestart?: Promise<void>,\n\t): Promise<void> {\n\t\tthis.trace(`stopping file watcher`, watcher);\n\n\t\tthis.watchers.delete(watcher);\n\n\t\ttry {\n\t\t\tawait watcher.stop(joinRestart);\n\t\t} catch (error) {\n\t\t\tthis.error(\n\t\t\t\t`Unexpected error stopping watcher: ${toErrorMessage(error)}`,\n\t\t\t\twatcher.request,\n\t\t\t);\n\t\t}\n\t}\n\n\tprotected removeDuplicateRequests(\n\t\trequests: IRecursiveWatchRequest[],\n\t\tvalidatePaths = true,\n\t): IRecursiveWatchRequest[] {\n\t\t// Sort requests by path length to have shortest first\n\t\t// to have a way to prevent children to be watched if\n\t\t// parents exist.\n\t\trequests.sort(\n\t\t\t(requestA, requestB) => requestA.path.length - requestB.path.length,\n\t\t);\n\n\t\t// Ignore requests for the same paths that have the same correlation\n\t\tconst mapCorrelationtoRequests = new Map<\n\t\t\tnumber | undefined /* correlation */,\n\t\t\tMap<string, IRecursiveWatchRequest>\n\t\t>();\n\t\tfor (const request of requests) {\n\t\t\tif (request.excludes.includes(GLOBSTAR)) {\n\t\t\t\tcontinue; // path is ignored entirely (via `**` glob exclude)\n\t\t\t}\n\n\t\t\tconst path = isLinux ? request.path : request.path.toLowerCase(); // adjust for case sensitivity\n\n\t\t\tlet requestsForCorrelation = mapCorrelationtoRequests.get(\n\t\t\t\trequest.correlationId,\n\t\t\t);\n\t\t\tif (!requestsForCorrelation) {\n\t\t\t\trequestsForCorrelation = new Map<\n\t\t\t\t\tstring,\n\t\t\t\t\tIRecursiveWatchRequest\n\t\t\t\t>();\n\t\t\t\tmapCorrelationtoRequests.set(\n\t\t\t\t\trequest.correlationId,\n\t\t\t\t\trequestsForCorrelation,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (requestsForCorrelation.has(path)) {\n\t\t\t\tthis.trace(\n\t\t\t\t\t`ignoring a request for watching who's path is already watched: ${this.requestToString(request)}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\trequestsForCorrelation.set(path, request);\n\t\t}\n\n\t\tconst normalizedRequests: IRecursiveWatchRequest[] = [];\n\n\t\tfor (const requestsForCorrelation of mapCorrelationtoRequests.values()) {\n\t\t\t// Only consider requests for watching that are not\n\t\t\t// a child of an existing request path to prevent\n\t\t\t// duplication. In addition, drop any request where\n\t\t\t// everything is excluded (via `**` glob).\n\t\t\t//\n\t\t\t// However, allow explicit requests to watch folders\n\t\t\t// that are symbolic links because the Parcel watcher\n\t\t\t// does not allow to recursively watch symbolic links.\n\n\t\t\tconst requestTrie =\n\t\t\t\tTernarySearchTree.forPaths<IRecursiveWatchRequest>(!isLinux);\n\n\t\t\tfor (const request of requestsForCorrelation.values()) {\n\t\t\t\t// Check for overlapping requests\n\t\t\t\tif (requestTrie.findSubstr(request.path)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst realpath = realpathSync(request.path);\n\t\t\t\t\t\tif (realpath === request.path) {\n\t\t\t\t\t\t\tthis.trace(\n\t\t\t\t\t\t\t\t`ignoring a request for watching who's parent is already watched: ${this.requestToString(request)}`,\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tthis.trace(\n\t\t\t\t\t\t\t`ignoring a request for watching who's realpath failed to resolve: ${this.requestToString(request)} (error: ${error})`,\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tthis._onDidWatchFail.fire(request);\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Check for invalid paths\n\t\t\t\tif (validatePaths && !this.isPathValid(request.path)) {\n\t\t\t\t\tthis._onDidWatchFail.fire(request);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\trequestTrie.set(request.path, request);\n\t\t\t}\n\n\t\t\tnormalizedRequests.push(\n\t\t\t\t...Array.from(requestTrie).map(([, request]) => request),\n\t\t\t);\n\t\t}\n\n\t\treturn normalizedRequests;\n\t}\n\n\tprivate isPathValid(path: string): boolean {\n\t\ttry {\n\t\t\tconst stat = statSync(path);\n\t\t\tif (!stat.isDirectory()) {\n\t\t\t\tthis.trace(\n\t\t\t\t\t`ignoring a path for watching that is a file and not a folder: ${path}`,\n\t\t\t\t);\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.trace(\n\t\t\t\t`ignoring a path for watching who's stat info failed to resolve: ${path} (error: ${error})`,\n\t\t\t);\n\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tsubscribe(\n\t\tpath: string,\n\t\tcallback: (error: true | null, change?: IFileChange) => void,\n\t): IDisposable | undefined {\n\t\tfor (const watcher of this.watchers) {\n\t\t\tif (watcher.failed) {\n\t\t\t\tcontinue; // watcher has already failed\n\t\t\t}\n\n\t\t\tif (!isEqualOrParent(path, watcher.request.path, !isLinux)) {\n\t\t\t\tcontinue; // watcher does not consider this path\n\t\t\t}\n\n\t\t\tif (watcher.exclude(path) || !watcher.include(path)) {\n\t\t\t\tcontinue; // parcel instance does not consider this path\n\t\t\t}\n\n\t\t\tconst disposables = new DisposableStore();\n\n\t\t\tdisposables.add(\n\t\t\t\tEvent.once(watcher.onDidStop)(async (e) => {\n\t\t\t\t\tawait e.joinRestart; // if we are restarting, await that so that we can possibly reuse this watcher again\n\t\t\t\t\tif (disposables.isDisposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tcallback(true /* error */);\n\t\t\t\t}),\n\t\t\t);\n\t\t\tdisposables.add(\n\t\t\t\tEvent.once(watcher.onDidFail)(() => callback(true /* error */)),\n\t\t\t);\n\t\t\tdisposables.add(\n\t\t\t\twatcher.subscribe(path, (change) => callback(null, change)),\n\t\t\t);\n\n\t\t\treturn disposables;\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprotected trace(message: string, watcher?: ParcelWatcherInstance): void {\n\t\tif (this.verboseLogging) {\n\t\t\tthis._onDidLogMessage.fire({\n\t\t\t\ttype: \"trace\",\n\t\t\t\tmessage: this.toMessage(message, watcher?.request),\n\t\t\t});\n\t\t}\n\t}\n\n\tprotected warn(message: string, watcher?: ParcelWatcherInstance) {\n\t\tthis._onDidLogMessage.fire({\n\t\t\ttype: \"warn\",\n\t\t\tmessage: this.toMessage(message, watcher?.request),\n\t\t});\n\t}\n\n\tprivate error(message: string, request?: IRecursiveWatchRequest) {\n\t\tthis._onDidLogMessage.fire({\n\t\t\ttype: \"error\",\n\t\t\tmessage: this.toMessage(message, request),\n\t\t});\n\t}\n\n\tprivate toMessage(\n\t\tmessage: string,\n\t\trequest?: IRecursiveWatchRequest,\n\t): string {\n\t\treturn request\n\t\t\t? `[File Watcher (${request.useNext ? \"parcel-next\" : \"parcel-classic\"})] ${message} (path: ${request.path})`\n\t\t\t: `[File Watcher ('parcel')] ${message}`;\n\t}\n\n\tprotected get recursiveWatcher() {\n\t\treturn this;\n\t}\n}\n"],
  "mappings": "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",
  "names": ["subscriptions"]
}
