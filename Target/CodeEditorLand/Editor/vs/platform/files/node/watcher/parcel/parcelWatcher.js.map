{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/files/node/watcher/parcel/parcelWatcher.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as parcelWatcher from '@parcel/watcher';\nimport * as parcelWatcher2 from '@bpasero/watcher';\nimport { existsSync, statSync, unlinkSync } from 'fs';\nimport { tmpdir, homedir } from 'os';\nimport { URI } from '../../../../../base/common/uri.js';\nimport { DeferredPromise, RunOnceScheduler, RunOnceWorker, ThrottledWorker } from '../../../../../base/common/async.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../../../base/common/cancellation.js';\nimport { toErrorMessage } from '../../../../../base/common/errorMessage.js';\nimport { Emitter, Event } from '../../../../../base/common/event.js';\nimport { randomPath, isEqual, isEqualOrParent } from '../../../../../base/common/extpath.js';\nimport { GLOBSTAR, patternsEquals } from '../../../../../base/common/glob.js';\nimport { BaseWatcher } from '../baseWatcher.js';\nimport { TernarySearchTree } from '../../../../../base/common/ternarySearchTree.js';\nimport { normalizeNFC } from '../../../../../base/common/normalization.js';\nimport { dirname, normalize, join } from '../../../../../base/common/path.js';\nimport { isLinux, isMacintosh, isWindows } from '../../../../../base/common/platform.js';\nimport { realcaseSync, realpathSync } from '../../../../../base/node/extpath.js';\nimport { NodeJSFileWatcherLibrary } from '../nodejs/nodejsWatcherLib.js';\nimport { FileChangeType, IFileChange } from '../../../common/files.js';\nimport { coalesceEvents, IRecursiveWatchRequest, parseWatcherPatterns, IRecursiveWatcherWithSubscribe, isFiltered, IWatcherErrorEvent } from '../../../common/watcher.js';\nimport { Disposable, DisposableStore, IDisposable, toDisposable } from '../../../../../base/common/lifecycle.js';\n\nexport class ParcelWatcherInstance extends Disposable {\n\n\tprivate readonly _onDidStop = this._register(new Emitter<{ joinRestart?: Promise<void> }>());\n\treadonly onDidStop = this._onDidStop.event;\n\n\tprivate readonly _onDidFail = this._register(new Emitter<void>());\n\treadonly onDidFail = this._onDidFail.event;\n\n\tprivate didFail = false;\n\tget failed(): boolean { return this.didFail; }\n\n\tprivate didStop = false;\n\tget stopped(): boolean { return this.didStop; }\n\n\tprivate readonly includes = this.request.includes ? parseWatcherPatterns(this.request.path, this.request.includes) : undefined;\n\tprivate readonly excludes = this.request.excludes ? parseWatcherPatterns(this.request.path, this.request.excludes) : undefined;\n\n\tprivate readonly subscriptions = new Map<string, Set<(change: IFileChange) => void>>();\n\n\tconstructor(\n\t\t/**\n\t\t * Signals when the watcher is ready to watch.\n\t\t */\n\t\treadonly ready: Promise<unknown>,\n\t\treadonly request: IRecursiveWatchRequest,\n\t\t/**\n\t\t * How often this watcher has been restarted in case of an unexpected\n\t\t * shutdown.\n\t\t */\n\t\treadonly restarts: number,\n\t\t/**\n\t\t * The cancellation token associated with the lifecycle of the watcher.\n\t\t */\n\t\treadonly token: CancellationToken,\n\t\t/**\n\t\t * An event aggregator to coalesce events and reduce duplicates.\n\t\t */\n\t\treadonly worker: RunOnceWorker<IFileChange>,\n\t\tprivate readonly stopFn: () => Promise<void>\n\t) {\n\t\tsuper();\n\n\t\tthis._register(toDisposable(() => this.subscriptions.clear()));\n\t}\n\n\tsubscribe(path: string, callback: (change: IFileChange) => void): IDisposable {\n\t\tpath = URI.file(path).fsPath; // make sure to store the path in `fsPath` form to match it with events later\n\n\t\tlet subscriptions = this.subscriptions.get(path);\n\t\tif (!subscriptions) {\n\t\t\tsubscriptions = new Set();\n\t\t\tthis.subscriptions.set(path, subscriptions);\n\t\t}\n\n\t\tsubscriptions.add(callback);\n\n\t\treturn toDisposable(() => {\n\t\t\tconst subscriptions = this.subscriptions.get(path);\n\t\t\tif (subscriptions) {\n\t\t\t\tsubscriptions.delete(callback);\n\n\t\t\t\tif (subscriptions.size === 0) {\n\t\t\t\t\tthis.subscriptions.delete(path);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tget subscriptionsCount(): number {\n\t\treturn this.subscriptions.size;\n\t}\n\n\tnotifyFileChange(path: string, change: IFileChange): void {\n\t\tconst subscriptions = this.subscriptions.get(path);\n\t\tif (subscriptions) {\n\t\t\tfor (const subscription of subscriptions) {\n\t\t\t\tsubscription(change);\n\t\t\t}\n\t\t}\n\t}\n\n\tnotifyWatchFailed(): void {\n\t\tthis.didFail = true;\n\n\t\tthis._onDidFail.fire();\n\t}\n\n\tinclude(path: string): boolean {\n\t\tif (!this.includes || this.includes.length === 0) {\n\t\t\treturn true; // no specific includes defined, include all\n\t\t}\n\n\t\treturn this.includes.some(include => include(path));\n\t}\n\n\texclude(path: string): boolean {\n\t\treturn Boolean(this.excludes?.some(exclude => exclude(path)));\n\t}\n\n\tasync stop(joinRestart: Promise<void> | undefined): Promise<void> {\n\t\tthis.didStop = true;\n\n\t\ttry {\n\t\t\tawait this.stopFn();\n\t\t} finally {\n\t\t\tthis._onDidStop.fire({ joinRestart });\n\t\t\tthis.dispose();\n\t\t}\n\t}\n}\n\nexport class ParcelWatcher extends BaseWatcher implements IRecursiveWatcherWithSubscribe {\n\n\tprivate static readonly MAP_PARCEL_WATCHER_ACTION_TO_FILE_CHANGE = new Map<parcelWatcher.EventType, number>(\n\t\t[\n\t\t\t['create', FileChangeType.ADDED],\n\t\t\t['update', FileChangeType.UPDATED],\n\t\t\t['delete', FileChangeType.DELETED]\n\t\t]\n\t);\n\n\tprivate static readonly PREDEFINED_EXCLUDES: { [platform: string]: string[] } = {\n\t\t'win32': [],\n\t\t'darwin': [\n\t\t\tjoin(homedir(), 'Library', 'Containers') // Triggers access dialog from macOS 14 (https://github.com/microsoft/vscode/issues/208105)\n\t\t],\n\t\t'linux': []\n\t};\n\n\tprivate static readonly PARCEL_WATCHER_BACKEND = isWindows ? 'windows' : isLinux ? 'inotify' : 'fs-events';\n\n\tprivate readonly _onDidError = this._register(new Emitter<IWatcherErrorEvent>());\n\treadonly onDidError = this._onDidError.event;\n\n\treadonly watchers = new Set<ParcelWatcherInstance>();\n\n\t// A delay for collecting file changes from Parcel\n\t// before collecting them for coalescing and emitting.\n\t// Parcel internally uses 50ms as delay, so we use 75ms,\n\t// to schedule sufficiently after Parcel.\n\t//\n\t// Note: since Parcel 2.0.7, the very first event is\n\t// emitted without delay if no events occured over a\n\t// duration of 500ms. But we always want to aggregate\n\t// events to apply our coleasing logic.\n\t//\n\tprivate static readonly FILE_CHANGES_HANDLER_DELAY = 75;\n\n\t// Reduce likelyhood of spam from file events via throttling.\n\t// (https://github.com/microsoft/vscode/issues/124723)\n\tprivate readonly throttledFileChangesEmitter = this._register(new ThrottledWorker<IFileChange>(\n\t\t{\n\t\t\tmaxWorkChunkSize: 500,\t// only process up to 500 changes at once before...\n\t\t\tthrottleDelay: 200,\t  \t// ...resting for 200ms until we process events again...\n\t\t\tmaxBufferedWork: 30000 \t// ...but never buffering more than 30000 events in memory\n\t\t},\n\t\tevents => this._onDidChangeFile.fire(events)\n\t));\n\n\tprivate enospcErrorLogged = false;\n\n\tconstructor() {\n\t\tsuper();\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\n\t\t// Error handling on process\n\t\tprocess.on('uncaughtException', error => this.onUnexpectedError(error));\n\t\tprocess.on('unhandledRejection', error => this.onUnexpectedError(error));\n\t}\n\n\tprotected override async doWatch(requests: IRecursiveWatchRequest[]): Promise<void> {\n\n\t\t// Figure out duplicates to remove from the requests\n\t\trequests = this.removeDuplicateRequests(requests);\n\n\t\t// Figure out which watchers to start and which to stop\n\t\tconst requestsToStart: IRecursiveWatchRequest[] = [];\n\t\tconst watchersToStop = new Set(Array.from(this.watchers));\n\t\tfor (const request of requests) {\n\t\t\tconst watcher = this.findWatcher(request);\n\t\t\tif (watcher && patternsEquals(watcher.request.excludes, request.excludes) && patternsEquals(watcher.request.includes, request.includes) && watcher.request.pollingInterval === request.pollingInterval) {\n\t\t\t\twatchersToStop.delete(watcher); // keep watcher\n\t\t\t} else {\n\t\t\t\trequestsToStart.push(request); // start watching\n\t\t\t}\n\t\t}\n\n\t\t// Logging\n\t\tif (requestsToStart.length) {\n\t\t\tthis.trace(`Request to start watching: ${requestsToStart.map(request => this.requestToString(request)).join(',')}`);\n\t\t}\n\n\t\tif (watchersToStop.size) {\n\t\t\tthis.trace(`Request to stop watching: ${Array.from(watchersToStop).map(watcher => this.requestToString(watcher.request)).join(',')}`);\n\t\t}\n\n\t\t// Stop watching as instructed\n\t\tfor (const watcher of watchersToStop) {\n\t\t\tawait this.stopWatching(watcher);\n\t\t}\n\n\t\t// Start watching as instructed\n\t\tfor (const request of requestsToStart) {\n\t\t\tif (request.pollingInterval) {\n\t\t\t\tthis.startPolling(request, request.pollingInterval);\n\t\t\t} else {\n\t\t\t\tawait this.startWatching(request);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate findWatcher(request: IRecursiveWatchRequest): ParcelWatcherInstance | undefined {\n\t\tfor (const watcher of this.watchers) {\n\n\t\t\t// Requests or watchers with correlation always match on that\n\t\t\tif (this.isCorrelated(request) || this.isCorrelated(watcher.request)) {\n\t\t\t\tif (watcher.request.correlationId === request.correlationId) {\n\t\t\t\t\treturn watcher;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Non-correlated requests or watchers match on path\n\t\t\telse {\n\t\t\t\tif (isEqual(watcher.request.path, request.path, !isLinux /* ignorecase */)) {\n\t\t\t\t\treturn watcher;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate startPolling(request: IRecursiveWatchRequest, pollingInterval: number, restarts = 0): void {\n\t\tconst cts = new CancellationTokenSource();\n\n\t\tconst instance = new DeferredPromise<void>();\n\n\t\tconst snapshotFile = randomPath(tmpdir(), 'vscode-watcher-snapshot');\n\n\t\t// Remember as watcher instance\n\t\tconst watcher: ParcelWatcherInstance = new ParcelWatcherInstance(\n\t\t\tinstance.p,\n\t\t\trequest,\n\t\t\trestarts,\n\t\t\tcts.token,\n\t\t\tnew RunOnceWorker<IFileChange>(events => this.handleParcelEvents(events, watcher), ParcelWatcher.FILE_CHANGES_HANDLER_DELAY),\n\t\t\tasync () => {\n\t\t\t\tcts.dispose(true);\n\n\t\t\t\twatcher.worker.flush();\n\t\t\t\twatcher.worker.dispose();\n\n\t\t\t\tpollingWatcher.dispose();\n\t\t\t\tunlinkSync(snapshotFile);\n\t\t\t}\n\t\t);\n\t\tthis.watchers.add(watcher);\n\n\t\t// Path checks for symbolic links / wrong casing\n\t\tconst { realPath, realPathDiffers, realPathLength } = this.normalizePath(request);\n\n\t\tthis.trace(`Started watching: '${realPath}' with polling interval '${pollingInterval}' and version '${request.useNext ? 'next' : 'stable'}'`);\n\n\t\tlet counter = 0;\n\n\t\tconst pollingWatcher = new RunOnceScheduler(async () => {\n\t\t\tcounter++;\n\n\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// We already ran before, check for events since\n\t\t\tconst parcelWatcherLib = request.useNext ? parcelWatcher2 : parcelWatcher;\n\t\t\tif (counter > 1) {\n\t\t\t\tconst parcelEvents = await parcelWatcherLib.getEventsSince(realPath, snapshotFile, { ignore: this.addPredefinedExcludes(request.excludes), backend: ParcelWatcher.PARCEL_WATCHER_BACKEND });\n\n\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Handle & emit events\n\t\t\t\tthis.onParcelEvents(parcelEvents, watcher, realPathDiffers, realPathLength);\n\t\t\t}\n\n\t\t\t// Store a snapshot of files to the snapshot file\n\t\t\tawait parcelWatcherLib.writeSnapshot(realPath, snapshotFile, { ignore: this.addPredefinedExcludes(request.excludes), backend: ParcelWatcher.PARCEL_WATCHER_BACKEND });\n\n\t\t\t// Signal we are ready now when the first snapshot was written\n\t\t\tif (counter === 1) {\n\t\t\t\tinstance.complete();\n\t\t\t}\n\n\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Schedule again at the next interval\n\t\t\tpollingWatcher.schedule();\n\t\t}, pollingInterval);\n\t\tpollingWatcher.schedule(0);\n\t}\n\n\tprivate async startWatching(request: IRecursiveWatchRequest, restarts = 0): Promise<void> {\n\t\tconst cts = new CancellationTokenSource();\n\n\t\tconst instance = new DeferredPromise<parcelWatcher.AsyncSubscription | undefined>();\n\n\t\t// Remember as watcher instance\n\t\tconst watcher: ParcelWatcherInstance = new ParcelWatcherInstance(\n\t\t\tinstance.p,\n\t\t\trequest,\n\t\t\trestarts,\n\t\t\tcts.token,\n\t\t\tnew RunOnceWorker<IFileChange>(events => this.handleParcelEvents(events, watcher), ParcelWatcher.FILE_CHANGES_HANDLER_DELAY),\n\t\t\tasync () => {\n\t\t\t\tcts.dispose(true);\n\n\t\t\t\twatcher.worker.flush();\n\t\t\t\twatcher.worker.dispose();\n\n\t\t\t\tconst watcherInstance = await instance.p;\n\t\t\t\tawait watcherInstance?.unsubscribe();\n\t\t\t}\n\t\t);\n\t\tthis.watchers.add(watcher);\n\n\t\t// Path checks for symbolic links / wrong casing\n\t\tconst { realPath, realPathDiffers, realPathLength } = this.normalizePath(request);\n\n\t\ttry {\n\t\t\tconst parcelWatcherLib = request.useNext ? parcelWatcher2 : parcelWatcher;\n\t\t\tconst parcelWatcherInstance = await parcelWatcherLib.subscribe(realPath, (error, parcelEvents) => {\n\t\t\t\tif (watcher.token.isCancellationRequested) {\n\t\t\t\t\treturn; // return early when disposed\n\t\t\t\t}\n\n\t\t\t\t// In any case of an error, treat this like a unhandled exception\n\t\t\t\t// that might require the watcher to restart. We do not really know\n\t\t\t\t// the state of parcel at this point and as such will try to restart\n\t\t\t\t// up to our maximum of restarts.\n\t\t\t\tif (error) {\n\t\t\t\t\tthis.onUnexpectedError(error, request);\n\t\t\t\t}\n\n\t\t\t\t// Handle & emit events\n\t\t\t\tthis.onParcelEvents(parcelEvents, watcher, realPathDiffers, realPathLength);\n\t\t\t}, {\n\t\t\t\tbackend: ParcelWatcher.PARCEL_WATCHER_BACKEND,\n\t\t\t\tignore: this.addPredefinedExcludes(watcher.request.excludes)\n\t\t\t});\n\n\t\t\tthis.trace(`Started watching: '${realPath}' with backend '${ParcelWatcher.PARCEL_WATCHER_BACKEND}' and version '${request.useNext ? 'next' : 'stable'}'`);\n\n\t\t\tinstance.complete(parcelWatcherInstance);\n\t\t} catch (error) {\n\t\t\tthis.onUnexpectedError(error, request);\n\n\t\t\tinstance.complete(undefined);\n\n\t\t\twatcher.notifyWatchFailed();\n\t\t\tthis._onDidWatchFail.fire(request);\n\t\t}\n\t}\n\n\tprivate addPredefinedExcludes(initialExcludes: string[]): string[] {\n\t\tconst excludes = [...initialExcludes];\n\n\t\tconst predefinedExcludes = ParcelWatcher.PREDEFINED_EXCLUDES[process.platform];\n\t\tif (Array.isArray(predefinedExcludes)) {\n\t\t\tfor (const exclude of predefinedExcludes) {\n\t\t\t\tif (!excludes.includes(exclude)) {\n\t\t\t\t\texcludes.push(exclude);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn excludes;\n\t}\n\n\tprivate onParcelEvents(parcelEvents: parcelWatcher.Event[], watcher: ParcelWatcherInstance, realPathDiffers: boolean, realPathLength: number): void {\n\t\tif (parcelEvents.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Normalize events: handle NFC normalization and symlinks\n\t\t// It is important to do this before checking for includes\n\t\t// to check on the original path.\n\t\tthis.normalizeEvents(parcelEvents, watcher.request, realPathDiffers, realPathLength);\n\n\t\t// Check for includes\n\t\tconst includedEvents = this.handleIncludes(watcher, parcelEvents);\n\n\t\t// Add to event aggregator for later processing\n\t\tfor (const includedEvent of includedEvents) {\n\t\t\twatcher.worker.work(includedEvent);\n\t\t}\n\t}\n\n\tprivate handleIncludes(watcher: ParcelWatcherInstance, parcelEvents: parcelWatcher.Event[]): IFileChange[] {\n\t\tconst events: IFileChange[] = [];\n\n\t\tfor (const { path, type: parcelEventType } of parcelEvents) {\n\t\t\tconst type = ParcelWatcher.MAP_PARCEL_WATCHER_ACTION_TO_FILE_CHANGE.get(parcelEventType)!;\n\t\t\tif (this.verboseLogging) {\n\t\t\t\tthis.traceWithCorrelation(`${type === FileChangeType.ADDED ? '[ADDED]' : type === FileChangeType.DELETED ? '[DELETED]' : '[CHANGED]'} ${path}`, watcher.request);\n\t\t\t}\n\n\t\t\t// Apply include filter if any\n\t\t\tif (!watcher.include(path)) {\n\t\t\t\tif (this.verboseLogging) {\n\t\t\t\t\tthis.traceWithCorrelation(` >> ignored (not included) ${path}`, watcher.request);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tevents.push({ type, resource: URI.file(path), cId: watcher.request.correlationId });\n\t\t\t}\n\t\t}\n\n\t\treturn events;\n\t}\n\n\tprivate handleParcelEvents(parcelEvents: IFileChange[], watcher: ParcelWatcherInstance): void {\n\n\t\t// Coalesce events: merge events of same kind\n\t\tconst coalescedEvents = coalesceEvents(parcelEvents);\n\n\t\t// Filter events: check for specific events we want to exclude\n\t\tconst { events: filteredEvents, rootDeleted } = this.filterEvents(coalescedEvents, watcher);\n\n\t\t// Broadcast to clients\n\t\tthis.emitEvents(filteredEvents, watcher);\n\n\t\t// Handle root path deletes\n\t\tif (rootDeleted) {\n\t\t\tthis.onWatchedPathDeleted(watcher);\n\t\t}\n\t}\n\n\tprivate emitEvents(events: IFileChange[], watcher: ParcelWatcherInstance): void {\n\t\tif (events.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Broadcast to clients via throttler\n\t\tconst worked = this.throttledFileChangesEmitter.work(events);\n\n\t\t// Logging\n\t\tif (!worked) {\n\t\t\tthis.warn(`started ignoring events due to too many file change events at once (incoming: ${events.length}, most recent change: ${events[0].resource.fsPath}). Use 'files.watcherExclude' setting to exclude folders with lots of changing files (e.g. compilation output).`);\n\t\t} else {\n\t\t\tif (this.throttledFileChangesEmitter.pending > 0) {\n\t\t\t\tthis.trace(`started throttling events due to large amount of file change events at once (pending: ${this.throttledFileChangesEmitter.pending}, most recent change: ${events[0].resource.fsPath}). Use 'files.watcherExclude' setting to exclude folders with lots of changing files (e.g. compilation output).`, watcher);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate normalizePath(request: IRecursiveWatchRequest): { realPath: string; realPathDiffers: boolean; realPathLength: number } {\n\t\tlet realPath = request.path;\n\t\tlet realPathDiffers = false;\n\t\tlet realPathLength = request.path.length;\n\n\t\ttry {\n\n\t\t\t// First check for symbolic link\n\t\t\trealPath = realpathSync(request.path);\n\n\t\t\t// Second check for casing difference\n\t\t\t// Note: this will be a no-op on Linux platforms\n\t\t\tif (request.path === realPath) {\n\t\t\t\trealPath = realcaseSync(request.path) ?? request.path;\n\t\t\t}\n\n\t\t\t// Correct watch path as needed\n\t\t\tif (request.path !== realPath) {\n\t\t\t\trealPathLength = realPath.length;\n\t\t\t\trealPathDiffers = true;\n\n\t\t\t\tthis.trace(`correcting a path to watch that seems to be a symbolic link or wrong casing (original: ${request.path}, real: ${realPath})`);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// ignore\n\t\t}\n\n\t\treturn { realPath, realPathDiffers, realPathLength };\n\t}\n\n\tprivate normalizeEvents(events: parcelWatcher.Event[], request: IRecursiveWatchRequest, realPathDiffers: boolean, realPathLength: number): void {\n\t\tfor (const event of events) {\n\n\t\t\t// Mac uses NFD unicode form on disk, but we want NFC\n\t\t\tif (isMacintosh) {\n\t\t\t\tevent.path = normalizeNFC(event.path);\n\t\t\t}\n\n\t\t\t// Workaround for https://github.com/parcel-bundler/watcher/issues/68\n\t\t\t// where watching root drive letter adds extra backslashes.\n\t\t\tif (isWindows) {\n\t\t\t\tif (request.path.length <= 3) { // for ex. c:, C:\\\n\t\t\t\t\tevent.path = normalize(event.path);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Convert paths back to original form in case it differs\n\t\t\tif (realPathDiffers) {\n\t\t\t\tevent.path = request.path + event.path.substr(realPathLength);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate filterEvents(events: IFileChange[], watcher: ParcelWatcherInstance): { events: IFileChange[]; rootDeleted?: boolean } {\n\t\tconst filteredEvents: IFileChange[] = [];\n\t\tlet rootDeleted = false;\n\n\t\tconst filter = this.isCorrelated(watcher.request) ? watcher.request.filter : undefined; // TODO@bpasero filtering for now is only enabled when correlating because watchers are otherwise potentially reused\n\t\tfor (const event of events) {\n\n\t\t\t// Emit to instance subscriptions if any before filtering\n\t\t\tif (watcher.subscriptionsCount > 0) {\n\t\t\t\twatcher.notifyFileChange(event.resource.fsPath, event);\n\t\t\t}\n\n\t\t\t// Filtering\n\t\t\trootDeleted = event.type === FileChangeType.DELETED && isEqual(event.resource.fsPath, watcher.request.path, !isLinux);\n\t\t\tif (\n\t\t\t\tisFiltered(event, filter) ||\n\t\t\t\t// Explicitly exclude changes to root if we have any\n\t\t\t\t// to avoid VS Code closing all opened editors which\n\t\t\t\t// can happen e.g. in case of network connectivity\n\t\t\t\t// issues\n\t\t\t\t// (https://github.com/microsoft/vscode/issues/136673)\n\t\t\t\t//\n\t\t\t\t// Update 2024: with the new correlated events, we\n\t\t\t\t// really do not want to skip over file events any\n\t\t\t\t// more, so we only ignore this event for non-correlated\n\t\t\t\t// watch requests.\n\t\t\t\t(rootDeleted && !this.isCorrelated(watcher.request))\n\t\t\t) {\n\t\t\t\tif (this.verboseLogging) {\n\t\t\t\t\tthis.traceWithCorrelation(` >> ignored (filtered) ${event.resource.fsPath}`, watcher.request);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Logging\n\t\t\tthis.traceEvent(event, watcher.request);\n\n\t\t\tfilteredEvents.push(event);\n\t\t}\n\n\t\treturn { events: filteredEvents, rootDeleted };\n\t}\n\n\tprivate onWatchedPathDeleted(watcher: ParcelWatcherInstance): void {\n\t\tthis.warn('Watcher shutdown because watched path got deleted', watcher);\n\n\t\tlet legacyMonitored = false;\n\t\tif (!this.isCorrelated(watcher.request)) {\n\t\t\t// Do monitoring of the request path parent unless this request\n\t\t\t// can be handled via suspend/resume in the super class\n\t\t\tlegacyMonitored = this.legacyMonitorRequest(watcher);\n\t\t}\n\n\t\tif (!legacyMonitored) {\n\t\t\twatcher.notifyWatchFailed();\n\t\t\tthis._onDidWatchFail.fire(watcher.request);\n\t\t}\n\t}\n\n\tprivate legacyMonitorRequest(watcher: ParcelWatcherInstance): boolean {\n\t\tconst parentPath = dirname(watcher.request.path);\n\t\tif (existsSync(parentPath)) {\n\t\t\tthis.trace('Trying to watch on the parent path to restart the watcher...', watcher);\n\n\t\t\tconst nodeWatcher = new NodeJSFileWatcherLibrary({ path: parentPath, excludes: [], recursive: false, correlationId: watcher.request.correlationId }, undefined, changes => {\n\t\t\t\tif (watcher.token.isCancellationRequested) {\n\t\t\t\t\treturn; // return early when disposed\n\t\t\t\t}\n\n\t\t\t\t// Watcher path came back! Restart watching...\n\t\t\t\tfor (const { resource, type } of changes) {\n\t\t\t\t\tif (isEqual(resource.fsPath, watcher.request.path, !isLinux) && (type === FileChangeType.ADDED || type === FileChangeType.UPDATED)) {\n\t\t\t\t\t\tif (this.isPathValid(watcher.request.path)) {\n\t\t\t\t\t\t\tthis.warn('Watcher restarts because watched path got created again', watcher);\n\n\t\t\t\t\t\t\t// Stop watching that parent folder\n\t\t\t\t\t\t\tnodeWatcher.dispose();\n\n\t\t\t\t\t\t\t// Restart the file watching\n\t\t\t\t\t\t\tthis.restartWatching(watcher);\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, undefined, msg => this._onDidLogMessage.fire(msg), this.verboseLogging);\n\n\t\t\t// Make sure to stop watching when the watcher is disposed\n\t\t\twatcher.token.onCancellationRequested(() => nodeWatcher.dispose());\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate onUnexpectedError(error: unknown, request?: IRecursiveWatchRequest): void {\n\t\tconst msg = toErrorMessage(error);\n\n\t\t// Specially handle ENOSPC errors that can happen when\n\t\t// the watcher consumes so many file descriptors that\n\t\t// we are running into a limit. We only want to warn\n\t\t// once in this case to avoid log spam.\n\t\t// See https://github.com/microsoft/vscode/issues/7950\n\t\tif (msg.indexOf('No space left on device') !== -1) {\n\t\t\tif (!this.enospcErrorLogged) {\n\t\t\t\tthis.error('Inotify limit reached (ENOSPC)', request);\n\n\t\t\t\tthis.enospcErrorLogged = true;\n\t\t\t}\n\t\t}\n\n\t\t// Any other error is unexpected and we should try to\n\t\t// restart the watcher as a result to get into healthy\n\t\t// state again if possible and if not attempted too much\n\t\telse {\n\t\t\tthis.error(`Unexpected error: ${msg} (EUNKNOWN)`, request);\n\n\t\t\tthis._onDidError.fire({ request, error: msg });\n\t\t}\n\t}\n\n\toverride async stop(): Promise<void> {\n\t\tawait super.stop();\n\n\t\tfor (const watcher of this.watchers) {\n\t\t\tawait this.stopWatching(watcher);\n\t\t}\n\t}\n\n\tprotected restartWatching(watcher: ParcelWatcherInstance, delay = 800): void {\n\n\t\t// Restart watcher delayed to accomodate for\n\t\t// changes on disk that have triggered the\n\t\t// need for a restart in the first place.\n\t\tconst scheduler = new RunOnceScheduler(async () => {\n\t\t\tif (watcher.token.isCancellationRequested) {\n\t\t\t\treturn; // return early when disposed\n\t\t\t}\n\n\t\t\tconst restartPromise = new DeferredPromise<void>();\n\t\t\ttry {\n\n\t\t\t\t// Await the watcher having stopped, as this is\n\t\t\t\t// needed to properly re-watch the same path\n\t\t\t\tawait this.stopWatching(watcher, restartPromise.p);\n\n\t\t\t\t// Start watcher again counting the restarts\n\t\t\t\tif (watcher.request.pollingInterval) {\n\t\t\t\t\tthis.startPolling(watcher.request, watcher.request.pollingInterval, watcher.restarts + 1);\n\t\t\t\t} else {\n\t\t\t\t\tawait this.startWatching(watcher.request, watcher.restarts + 1);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\trestartPromise.complete();\n\t\t\t}\n\t\t}, delay);\n\n\t\tscheduler.schedule();\n\t\twatcher.token.onCancellationRequested(() => scheduler.dispose());\n\t}\n\n\tprivate async stopWatching(watcher: ParcelWatcherInstance, joinRestart?: Promise<void>): Promise<void> {\n\t\tthis.trace(`stopping file watcher`, watcher);\n\n\t\tthis.watchers.delete(watcher);\n\n\t\ttry {\n\t\t\tawait watcher.stop(joinRestart);\n\t\t} catch (error) {\n\t\t\tthis.error(`Unexpected error stopping watcher: ${toErrorMessage(error)}`, watcher.request);\n\t\t}\n\t}\n\n\tprotected removeDuplicateRequests(requests: IRecursiveWatchRequest[], validatePaths = true): IRecursiveWatchRequest[] {\n\n\t\t// Sort requests by path length to have shortest first\n\t\t// to have a way to prevent children to be watched if\n\t\t// parents exist.\n\t\trequests.sort((requestA, requestB) => requestA.path.length - requestB.path.length);\n\n\t\t// Ignore requests for the same paths that have the same correlation\n\t\tconst mapCorrelationtoRequests = new Map<number | undefined /* correlation */, Map<string, IRecursiveWatchRequest>>();\n\t\tfor (const request of requests) {\n\t\t\tif (request.excludes.includes(GLOBSTAR)) {\n\t\t\t\tcontinue; // path is ignored entirely (via `**` glob exclude)\n\t\t\t}\n\n\t\t\tconst path = isLinux ? request.path : request.path.toLowerCase(); // adjust for case sensitivity\n\n\t\t\tlet requestsForCorrelation = mapCorrelationtoRequests.get(request.correlationId);\n\t\t\tif (!requestsForCorrelation) {\n\t\t\t\trequestsForCorrelation = new Map<string, IRecursiveWatchRequest>();\n\t\t\t\tmapCorrelationtoRequests.set(request.correlationId, requestsForCorrelation);\n\t\t\t}\n\n\t\t\tif (requestsForCorrelation.has(path)) {\n\t\t\t\tthis.trace(`ignoring a request for watching who's path is already watched: ${this.requestToString(request)}`);\n\t\t\t}\n\n\t\t\trequestsForCorrelation.set(path, request);\n\t\t}\n\n\t\tconst normalizedRequests: IRecursiveWatchRequest[] = [];\n\n\t\tfor (const requestsForCorrelation of mapCorrelationtoRequests.values()) {\n\n\t\t\t// Only consider requests for watching that are not\n\t\t\t// a child of an existing request path to prevent\n\t\t\t// duplication. In addition, drop any request where\n\t\t\t// everything is excluded (via `**` glob).\n\t\t\t//\n\t\t\t// However, allow explicit requests to watch folders\n\t\t\t// that are symbolic links because the Parcel watcher\n\t\t\t// does not allow to recursively watch symbolic links.\n\n\t\t\tconst requestTrie = TernarySearchTree.forPaths<IRecursiveWatchRequest>(!isLinux);\n\n\t\t\tfor (const request of requestsForCorrelation.values()) {\n\n\t\t\t\t// Check for overlapping requests\n\t\t\t\tif (requestTrie.findSubstr(request.path)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst realpath = realpathSync(request.path);\n\t\t\t\t\t\tif (realpath === request.path) {\n\t\t\t\t\t\t\tthis.trace(`ignoring a request for watching who's parent is already watched: ${this.requestToString(request)}`);\n\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tthis.trace(`ignoring a request for watching who's realpath failed to resolve: ${this.requestToString(request)} (error: ${error})`);\n\n\t\t\t\t\t\tthis._onDidWatchFail.fire(request);\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Check for invalid paths\n\t\t\t\tif (validatePaths && !this.isPathValid(request.path)) {\n\t\t\t\t\tthis._onDidWatchFail.fire(request);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\trequestTrie.set(request.path, request);\n\t\t\t}\n\n\t\t\tnormalizedRequests.push(...Array.from(requestTrie).map(([, request]) => request));\n\t\t}\n\n\t\treturn normalizedRequests;\n\t}\n\n\tprivate isPathValid(path: string): boolean {\n\t\ttry {\n\t\t\tconst stat = statSync(path);\n\t\t\tif (!stat.isDirectory()) {\n\t\t\t\tthis.trace(`ignoring a path for watching that is a file and not a folder: ${path}`);\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.trace(`ignoring a path for watching who's stat info failed to resolve: ${path} (error: ${error})`);\n\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tsubscribe(path: string, callback: (error: true | null, change?: IFileChange) => void): IDisposable | undefined {\n\t\tfor (const watcher of this.watchers) {\n\t\t\tif (watcher.failed) {\n\t\t\t\tcontinue; // watcher has already failed\n\t\t\t}\n\n\t\t\tif (!isEqualOrParent(path, watcher.request.path, !isLinux)) {\n\t\t\t\tcontinue; // watcher does not consider this path\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\twatcher.exclude(path) ||\n\t\t\t\t!watcher.include(path)\n\t\t\t) {\n\t\t\t\tcontinue; // parcel instance does not consider this path\n\t\t\t}\n\n\t\t\tconst disposables = new DisposableStore();\n\n\t\t\tdisposables.add(Event.once(watcher.onDidStop)(async e => {\n\t\t\t\tawait e.joinRestart; // if we are restarting, await that so that we can possibly reuse this watcher again\n\t\t\t\tif (disposables.isDisposed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tcallback(true /* error */);\n\t\t\t}));\n\t\t\tdisposables.add(Event.once(watcher.onDidFail)(() => callback(true /* error */)));\n\t\t\tdisposables.add(watcher.subscribe(path, change => callback(null, change)));\n\n\t\t\treturn disposables;\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprotected trace(message: string, watcher?: ParcelWatcherInstance): void {\n\t\tif (this.verboseLogging) {\n\t\t\tthis._onDidLogMessage.fire({ type: 'trace', message: this.toMessage(message, watcher?.request) });\n\t\t}\n\t}\n\n\tprotected warn(message: string, watcher?: ParcelWatcherInstance) {\n\t\tthis._onDidLogMessage.fire({ type: 'warn', message: this.toMessage(message, watcher?.request) });\n\t}\n\n\tprivate error(message: string, request?: IRecursiveWatchRequest) {\n\t\tthis._onDidLogMessage.fire({ type: 'error', message: this.toMessage(message, request) });\n\t}\n\n\tprivate toMessage(message: string, request?: IRecursiveWatchRequest): string {\n\t\treturn request ? `[File Watcher (${request.useNext ? 'parcel-next' : 'parcel-classic'})] ${message} (path: ${request.path})` : `[File Watcher ('parcel')] ${message}`;\n\t}\n\n\tprotected get recursiveWatcher() { return this; }\n}\n"],
  "mappings": "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",
  "names": ["subscriptions"]
}
