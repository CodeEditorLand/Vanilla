{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/files/node/diskFileSystemProviderServer.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { VSBuffer } from \"../../../base/common/buffer.js\";\nimport { CancellationTokenSource } from \"../../../base/common/cancellation.js\";\nimport { Emitter, type Event } from \"../../../base/common/event.js\";\nimport {\n\tDisposable,\n\ttype IDisposable,\n\tdispose,\n\ttoDisposable,\n} from \"../../../base/common/lifecycle.js\";\nimport {\n\ttype ReadableStreamEventPayload,\n\tlistenStream,\n} from \"../../../base/common/stream.js\";\nimport type { URI, UriComponents } from \"../../../base/common/uri.js\";\nimport type { IURITransformer } from \"../../../base/common/uriIpc.js\";\nimport type { IServerChannel } from \"../../../base/parts/ipc/common/ipc.js\";\nimport type { IConfigurationService } from \"../../configuration/common/configuration.js\";\nimport type { IEnvironmentService } from \"../../environment/common/environment.js\";\nimport type { ILogService } from \"../../log/common/log.js\";\nimport type {\n\tFileType,\n\tIFileAtomicReadOptions,\n\tIFileChange,\n\tIFileDeleteOptions,\n\tIFileOpenOptions,\n\tIFileOverwriteOptions,\n\tIFileReadStreamOptions,\n\tIFileWriteOptions,\n\tIStat,\n\tIWatchOptions,\n} from \"../common/files.js\";\nimport type { IRecursiveWatcherOptions } from \"../common/watcher.js\";\nimport { DiskFileSystemProvider } from \"./diskFileSystemProvider.js\";\n\nexport interface ISessionFileWatcher extends IDisposable {\n\twatch(req: number, resource: URI, opts: IWatchOptions): IDisposable;\n}\n\n/**\n * A server implementation for a IPC based file system provider client.\n */\nexport abstract class AbstractDiskFileSystemProviderChannel<T>\n\textends Disposable\n\timplements IServerChannel<T>\n{\n\tconstructor(\n\t\tprotected readonly provider: DiskFileSystemProvider,\n\t\tprotected readonly logService: ILogService,\n\t) {\n\t\tsuper();\n\t}\n\n\tcall(ctx: T, command: string, arg?: any): Promise<any> {\n\t\tconst uriTransformer = this.getUriTransformer(ctx);\n\n\t\tswitch (command) {\n\t\t\tcase \"stat\":\n\t\t\t\treturn this.stat(uriTransformer, arg[0]);\n\t\t\tcase \"readdir\":\n\t\t\t\treturn this.readdir(uriTransformer, arg[0]);\n\t\t\tcase \"open\":\n\t\t\t\treturn this.open(uriTransformer, arg[0], arg[1]);\n\t\t\tcase \"close\":\n\t\t\t\treturn this.close(arg[0]);\n\t\t\tcase \"read\":\n\t\t\t\treturn this.read(arg[0], arg[1], arg[2]);\n\t\t\tcase \"readFile\":\n\t\t\t\treturn this.readFile(uriTransformer, arg[0], arg[1]);\n\t\t\tcase \"write\":\n\t\t\t\treturn this.write(arg[0], arg[1], arg[2], arg[3], arg[4]);\n\t\t\tcase \"writeFile\":\n\t\t\t\treturn this.writeFile(uriTransformer, arg[0], arg[1], arg[2]);\n\t\t\tcase \"rename\":\n\t\t\t\treturn this.rename(uriTransformer, arg[0], arg[1], arg[2]);\n\t\t\tcase \"copy\":\n\t\t\t\treturn this.copy(uriTransformer, arg[0], arg[1], arg[2]);\n\t\t\tcase \"cloneFile\":\n\t\t\t\treturn this.cloneFile(uriTransformer, arg[0], arg[1]);\n\t\t\tcase \"mkdir\":\n\t\t\t\treturn this.mkdir(uriTransformer, arg[0]);\n\t\t\tcase \"delete\":\n\t\t\t\treturn this.delete(uriTransformer, arg[0], arg[1]);\n\t\t\tcase \"watch\":\n\t\t\t\treturn this.watch(\n\t\t\t\t\turiTransformer,\n\t\t\t\t\targ[0],\n\t\t\t\t\targ[1],\n\t\t\t\t\targ[2],\n\t\t\t\t\targ[3],\n\t\t\t\t);\n\t\t\tcase \"unwatch\":\n\t\t\t\treturn this.unwatch(arg[0], arg[1]);\n\t\t}\n\n\t\tthrow new Error(`IPC Command ${command} not found`);\n\t}\n\n\tlisten(ctx: T, event: string, arg: any): Event<any> {\n\t\tconst uriTransformer = this.getUriTransformer(ctx);\n\n\t\tswitch (event) {\n\t\t\tcase \"fileChange\":\n\t\t\t\treturn this.onFileChange(uriTransformer, arg[0]);\n\t\t\tcase \"readFileStream\":\n\t\t\t\treturn this.onReadFileStream(uriTransformer, arg[0], arg[1]);\n\t\t}\n\n\t\tthrow new Error(`Unknown event ${event}`);\n\t}\n\n\tprotected abstract getUriTransformer(ctx: T): IURITransformer;\n\n\tprotected abstract transformIncoming(\n\t\turiTransformer: IURITransformer,\n\t\t_resource: UriComponents,\n\t\tsupportVSCodeResource?: boolean,\n\t): URI;\n\n\t//#region File Metadata Resolving\n\n\tprivate stat(\n\t\turiTransformer: IURITransformer,\n\t\t_resource: UriComponents,\n\t): Promise<IStat> {\n\t\tconst resource = this.transformIncoming(\n\t\t\turiTransformer,\n\t\t\t_resource,\n\t\t\ttrue,\n\t\t);\n\n\t\treturn this.provider.stat(resource);\n\t}\n\n\tprivate readdir(\n\t\turiTransformer: IURITransformer,\n\t\t_resource: UriComponents,\n\t): Promise<[string, FileType][]> {\n\t\tconst resource = this.transformIncoming(uriTransformer, _resource);\n\n\t\treturn this.provider.readdir(resource);\n\t}\n\n\t//#endregion\n\n\t//#region File Reading/Writing\n\n\tprivate async readFile(\n\t\turiTransformer: IURITransformer,\n\t\t_resource: UriComponents,\n\t\topts?: IFileAtomicReadOptions,\n\t): Promise<VSBuffer> {\n\t\tconst resource = this.transformIncoming(\n\t\t\turiTransformer,\n\t\t\t_resource,\n\t\t\ttrue,\n\t\t);\n\t\tconst buffer = await this.provider.readFile(resource, opts);\n\n\t\treturn VSBuffer.wrap(buffer);\n\t}\n\n\tprivate onReadFileStream(\n\t\turiTransformer: IURITransformer,\n\t\t_resource: URI,\n\t\topts: IFileReadStreamOptions,\n\t): Event<ReadableStreamEventPayload<VSBuffer>> {\n\t\tconst resource = this.transformIncoming(\n\t\t\turiTransformer,\n\t\t\t_resource,\n\t\t\ttrue,\n\t\t);\n\t\tconst cts = new CancellationTokenSource();\n\n\t\tconst emitter = new Emitter<ReadableStreamEventPayload<VSBuffer>>({\n\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\t// Ensure to cancel the read operation when there is no more\n\t\t\t\t// listener on the other side to prevent unneeded work.\n\t\t\t\tcts.cancel();\n\t\t\t},\n\t\t});\n\n\t\tconst fileStream = this.provider.readFileStream(\n\t\t\tresource,\n\t\t\topts,\n\t\t\tcts.token,\n\t\t);\n\t\tlistenStream(fileStream, {\n\t\t\tonData: (chunk) => emitter.fire(VSBuffer.wrap(chunk)),\n\t\t\tonError: (error) => emitter.fire(error),\n\t\t\tonEnd: () => {\n\t\t\t\t// Forward event\n\t\t\t\temitter.fire(\"end\");\n\n\t\t\t\t// Cleanup\n\t\t\t\temitter.dispose();\n\t\t\t\tcts.dispose();\n\t\t\t},\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\tprivate writeFile(\n\t\turiTransformer: IURITransformer,\n\t\t_resource: UriComponents,\n\t\tcontent: VSBuffer,\n\t\topts: IFileWriteOptions,\n\t): Promise<void> {\n\t\tconst resource = this.transformIncoming(uriTransformer, _resource);\n\n\t\treturn this.provider.writeFile(resource, content.buffer, opts);\n\t}\n\n\tprivate open(\n\t\turiTransformer: IURITransformer,\n\t\t_resource: UriComponents,\n\t\topts: IFileOpenOptions,\n\t): Promise<number> {\n\t\tconst resource = this.transformIncoming(\n\t\t\turiTransformer,\n\t\t\t_resource,\n\t\t\ttrue,\n\t\t);\n\n\t\treturn this.provider.open(resource, opts);\n\t}\n\n\tprivate close(fd: number): Promise<void> {\n\t\treturn this.provider.close(fd);\n\t}\n\n\tprivate async read(\n\t\tfd: number,\n\t\tpos: number,\n\t\tlength: number,\n\t): Promise<[VSBuffer, number]> {\n\t\tconst buffer = VSBuffer.alloc(length);\n\t\tconst bufferOffset = 0; // offset is 0 because we create a buffer to read into for each call\n\t\tconst bytesRead = await this.provider.read(\n\t\t\tfd,\n\t\t\tpos,\n\t\t\tbuffer.buffer,\n\t\t\tbufferOffset,\n\t\t\tlength,\n\t\t);\n\n\t\treturn [buffer, bytesRead];\n\t}\n\n\tprivate write(\n\t\tfd: number,\n\t\tpos: number,\n\t\tdata: VSBuffer,\n\t\toffset: number,\n\t\tlength: number,\n\t): Promise<number> {\n\t\treturn this.provider.write(fd, pos, data.buffer, offset, length);\n\t}\n\n\t//#endregion\n\n\t//#region Move/Copy/Delete/Create Folder\n\n\tprivate mkdir(\n\t\turiTransformer: IURITransformer,\n\t\t_resource: UriComponents,\n\t): Promise<void> {\n\t\tconst resource = this.transformIncoming(uriTransformer, _resource);\n\n\t\treturn this.provider.mkdir(resource);\n\t}\n\n\tprotected delete(\n\t\turiTransformer: IURITransformer,\n\t\t_resource: UriComponents,\n\t\topts: IFileDeleteOptions,\n\t): Promise<void> {\n\t\tconst resource = this.transformIncoming(uriTransformer, _resource);\n\n\t\treturn this.provider.delete(resource, opts);\n\t}\n\n\tprivate rename(\n\t\turiTransformer: IURITransformer,\n\t\t_source: UriComponents,\n\t\t_target: UriComponents,\n\t\topts: IFileOverwriteOptions,\n\t): Promise<void> {\n\t\tconst source = this.transformIncoming(uriTransformer, _source);\n\t\tconst target = this.transformIncoming(uriTransformer, _target);\n\n\t\treturn this.provider.rename(source, target, opts);\n\t}\n\n\tprivate copy(\n\t\turiTransformer: IURITransformer,\n\t\t_source: UriComponents,\n\t\t_target: UriComponents,\n\t\topts: IFileOverwriteOptions,\n\t): Promise<void> {\n\t\tconst source = this.transformIncoming(uriTransformer, _source);\n\t\tconst target = this.transformIncoming(uriTransformer, _target);\n\n\t\treturn this.provider.copy(source, target, opts);\n\t}\n\n\t//#endregion\n\n\t//#region Clone File\n\n\tprivate cloneFile(\n\t\turiTransformer: IURITransformer,\n\t\t_source: UriComponents,\n\t\t_target: UriComponents,\n\t): Promise<void> {\n\t\tconst source = this.transformIncoming(uriTransformer, _source);\n\t\tconst target = this.transformIncoming(uriTransformer, _target);\n\n\t\treturn this.provider.cloneFile(source, target);\n\t}\n\n\t//#endregion\n\n\t//#region File Watching\n\n\tprivate readonly sessionToWatcher = new Map<\n\t\tstring /* session ID */,\n\t\tISessionFileWatcher\n\t>();\n\tprivate readonly watchRequests = new Map<\n\t\tstring /* session ID + request ID */,\n\t\tIDisposable\n\t>();\n\n\tprivate onFileChange(\n\t\turiTransformer: IURITransformer,\n\t\tsessionId: string,\n\t): Event<IFileChange[] | string> {\n\t\t// We want a specific emitter for the given session so that events\n\t\t// from the one session do not end up on the other session. As such\n\t\t// we create a `SessionFileWatcher` and a `Emitter` for that session.\n\n\t\tconst emitter = new Emitter<IFileChange[] | string>({\n\t\t\tonWillAddFirstListener: () => {\n\t\t\t\tthis.sessionToWatcher.set(\n\t\t\t\t\tsessionId,\n\t\t\t\t\tthis.createSessionFileWatcher(uriTransformer, emitter),\n\t\t\t\t);\n\t\t\t},\n\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\tdispose(this.sessionToWatcher.get(sessionId));\n\t\t\t\tthis.sessionToWatcher.delete(sessionId);\n\t\t\t},\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\tprivate async watch(\n\t\turiTransformer: IURITransformer,\n\t\tsessionId: string,\n\t\treq: number,\n\t\t_resource: UriComponents,\n\t\topts: IWatchOptions,\n\t): Promise<void> {\n\t\tconst watcher = this.sessionToWatcher.get(sessionId);\n\t\tif (watcher) {\n\t\t\tconst resource = this.transformIncoming(uriTransformer, _resource);\n\t\t\tconst disposable = watcher.watch(req, resource, opts);\n\t\t\tthis.watchRequests.set(sessionId + req, disposable);\n\t\t}\n\t}\n\n\tprivate async unwatch(sessionId: string, req: number): Promise<void> {\n\t\tconst id = sessionId + req;\n\t\tconst disposable = this.watchRequests.get(id);\n\t\tif (disposable) {\n\t\t\tdispose(disposable);\n\t\t\tthis.watchRequests.delete(id);\n\t\t}\n\t}\n\n\tprotected abstract createSessionFileWatcher(\n\t\turiTransformer: IURITransformer,\n\t\temitter: Emitter<IFileChange[] | string>,\n\t): ISessionFileWatcher;\n\n\t//#endregion\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\tfor (const [, disposable] of this.watchRequests) {\n\t\t\tdisposable.dispose();\n\t\t}\n\t\tthis.watchRequests.clear();\n\n\t\tfor (const [, disposable] of this.sessionToWatcher) {\n\t\t\tdisposable.dispose();\n\t\t}\n\t\tthis.sessionToWatcher.clear();\n\t}\n}\n\nexport abstract class AbstractSessionFileWatcher\n\textends Disposable\n\timplements ISessionFileWatcher\n{\n\tprivate readonly watcherRequests = new Map<number, IDisposable>();\n\n\t// To ensure we use one file watcher per session, we keep a\n\t// disk file system provider instantiated for this session.\n\t// The provider is cheap and only stateful when file watching\n\t// starts.\n\t//\n\t// This is important because we want to ensure that we only\n\t// forward events from the watched paths for this session and\n\t// not other clients that asked to watch other paths.\n\tprivate readonly fileWatcher = this._register(\n\t\tnew DiskFileSystemProvider(this.logService, {\n\t\t\twatcher: {\n\t\t\t\trecursive: this.getRecursiveWatcherOptions(\n\t\t\t\t\tthis.environmentService,\n\t\t\t\t),\n\t\t\t},\n\t\t}),\n\t);\n\n\tconstructor(\n\t\tprivate readonly uriTransformer: IURITransformer,\n\t\tsessionEmitter: Emitter<IFileChange[] | string>,\n\t\tprivate readonly logService: ILogService,\n\t\tprivate readonly environmentService: IEnvironmentService,\n\t\tprivate readonly configurationService: IConfigurationService,\n\t) {\n\t\tsuper();\n\n\t\tthis.registerListeners(sessionEmitter);\n\t}\n\n\tprivate registerListeners(\n\t\tsessionEmitter: Emitter<IFileChange[] | string>,\n\t): void {\n\t\tconst localChangeEmitter = this._register(\n\t\t\tnew Emitter<readonly IFileChange[]>(),\n\t\t);\n\n\t\tthis._register(\n\t\t\tlocalChangeEmitter.event((events) => {\n\t\t\t\tsessionEmitter.fire(\n\t\t\t\t\tevents.map((e) => ({\n\t\t\t\t\t\tresource: this.uriTransformer.transformOutgoingURI(\n\t\t\t\t\t\t\te.resource,\n\t\t\t\t\t\t),\n\t\t\t\t\t\ttype: e.type,\n\t\t\t\t\t\tcId: e.cId,\n\t\t\t\t\t})),\n\t\t\t\t);\n\t\t\t}),\n\t\t);\n\n\t\tthis._register(\n\t\t\tthis.fileWatcher.onDidChangeFile((events) =>\n\t\t\t\tlocalChangeEmitter.fire(events),\n\t\t\t),\n\t\t);\n\t\tthis._register(\n\t\t\tthis.fileWatcher.onDidWatchError((error) =>\n\t\t\t\tsessionEmitter.fire(error),\n\t\t\t),\n\t\t);\n\t}\n\n\tprotected getRecursiveWatcherOptions(\n\t\tenvironmentService: IEnvironmentService,\n\t): IRecursiveWatcherOptions | undefined {\n\t\tif (\n\t\t\tthis.configurationService.getValue<boolean>(\n\t\t\t\t\"files.experimentalWatcherNext\",\n\t\t\t) === true\n\t\t) {\n\t\t\treturn { useNext: true, usePolling: false };\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprotected getExtraExcludes(\n\t\tenvironmentService: IEnvironmentService,\n\t): string[] | undefined {\n\t\treturn undefined; // subclasses can override\n\t}\n\n\twatch(req: number, resource: URI, opts: IWatchOptions): IDisposable {\n\t\tconst extraExcludes = this.getExtraExcludes(this.environmentService);\n\t\tif (Array.isArray(extraExcludes)) {\n\t\t\topts.excludes = [...opts.excludes, ...extraExcludes];\n\t\t}\n\n\t\tthis.watcherRequests.set(req, this.fileWatcher.watch(resource, opts));\n\n\t\treturn toDisposable(() => {\n\t\t\tdispose(this.watcherRequests.get(req));\n\t\t\tthis.watcherRequests.delete(req);\n\t\t});\n\t}\n\n\toverride dispose(): void {\n\t\tfor (const [, disposable] of this.watcherRequests) {\n\t\t\tdisposable.dispose();\n\t\t}\n\t\tthis.watcherRequests.clear();\n\n\t\tsuper.dispose();\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
