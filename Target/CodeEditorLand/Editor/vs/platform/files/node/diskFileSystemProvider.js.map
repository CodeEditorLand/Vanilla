{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/files/node/diskFileSystemProvider.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { type Stats, promises } from \"fs\";\nimport { Barrier, retry } from \"../../../base/common/async.js\";\nimport { VSBuffer } from \"../../../base/common/buffer.js\";\nimport type { CancellationToken } from \"../../../base/common/cancellation.js\";\nimport { Event } from \"../../../base/common/event.js\";\nimport { isEqual } from \"../../../base/common/extpath.js\";\nimport {\n\tDisposableStore,\n\ttype IDisposable,\n\ttoDisposable,\n} from \"../../../base/common/lifecycle.js\";\nimport { ResourceMap } from \"../../../base/common/map.js\";\nimport { basename, dirname, join } from \"../../../base/common/path.js\";\nimport { isLinux, isWindows } from \"../../../base/common/platform.js\";\nimport {\n\textUriBiasedIgnorePathCase,\n\tjoinPath,\n\tbasename as resourcesBasename,\n\tdirname as resourcesDirname,\n} from \"../../../base/common/resources.js\";\nimport {\n\ttype ReadableStreamEvents,\n\tnewWriteableStream,\n} from \"../../../base/common/stream.js\";\nimport type { URI } from \"../../../base/common/uri.js\";\nimport {\n\ttype IDirent,\n\tPromises,\n\tRimRafMode,\n\tSymlinkSupport,\n} from \"../../../base/node/pfs.js\";\nimport { localize } from \"../../../nls.js\";\nimport type { ILogService } from \"../../log/common/log.js\";\nimport {\n\tAbstractDiskFileSystemProvider,\n\ttype IDiskFileSystemProviderOptions,\n} from \"../common/diskFileSystemProvider.js\";\nimport {\n\tFilePermission,\n\tFileSystemProviderCapabilities,\n\tFileSystemProviderError,\n\tFileSystemProviderErrorCode,\n\tFileType,\n\ttype IFileAtomicReadOptions,\n\ttype IFileChange,\n\ttype IFileDeleteOptions,\n\ttype IFileOpenOptions,\n\ttype IFileOverwriteOptions,\n\ttype IFileReadStreamOptions,\n\ttype IFileSystemProviderWithFileAtomicDeleteCapability,\n\ttype IFileSystemProviderWithFileAtomicReadCapability,\n\ttype IFileSystemProviderWithFileAtomicWriteCapability,\n\ttype IFileSystemProviderWithFileCloneCapability,\n\ttype IFileSystemProviderWithFileFolderCopyCapability,\n\ttype IFileSystemProviderWithFileReadStreamCapability,\n\ttype IFileSystemProviderWithFileReadWriteCapability,\n\ttype IFileSystemProviderWithOpenReadWriteCloseCapability,\n\ttype IFileWriteOptions,\n\ttype IStat,\n\tcreateFileSystemProviderError,\n\tisFileOpenForWriteOptions,\n} from \"../common/files.js\";\nimport { readFileIntoStream } from \"../common/io.js\";\nimport type {\n\tAbstractNonRecursiveWatcherClient,\n\tAbstractUniversalWatcherClient,\n\tILogMessage,\n} from \"../common/watcher.js\";\nimport { NodeJSWatcherClient } from \"./watcher/nodejs/nodejsClient.js\";\nimport { UniversalWatcherClient } from \"./watcher/watcherClient.js\";\n\nexport class DiskFileSystemProvider\n\textends AbstractDiskFileSystemProvider\n\timplements\n\t\tIFileSystemProviderWithFileReadWriteCapability,\n\t\tIFileSystemProviderWithOpenReadWriteCloseCapability,\n\t\tIFileSystemProviderWithFileReadStreamCapability,\n\t\tIFileSystemProviderWithFileFolderCopyCapability,\n\t\tIFileSystemProviderWithFileAtomicReadCapability,\n\t\tIFileSystemProviderWithFileAtomicWriteCapability,\n\t\tIFileSystemProviderWithFileAtomicDeleteCapability,\n\t\tIFileSystemProviderWithFileCloneCapability\n{\n\tprivate static TRACE_LOG_RESOURCE_LOCKS = false; // not enabled by default because very spammy\n\n\tconstructor(\n\t\tlogService: ILogService,\n\t\toptions?: IDiskFileSystemProviderOptions,\n\t) {\n\t\tsuper(logService, options);\n\t}\n\n\t//#region File Capabilities\n\n\treadonly onDidChangeCapabilities = Event.None;\n\n\tprivate _capabilities: FileSystemProviderCapabilities | undefined;\n\tget capabilities(): FileSystemProviderCapabilities {\n\t\tif (!this._capabilities) {\n\t\t\tthis._capabilities =\n\t\t\t\tFileSystemProviderCapabilities.FileReadWrite |\n\t\t\t\tFileSystemProviderCapabilities.FileOpenReadWriteClose |\n\t\t\t\tFileSystemProviderCapabilities.FileReadStream |\n\t\t\t\tFileSystemProviderCapabilities.FileFolderCopy |\n\t\t\t\tFileSystemProviderCapabilities.FileWriteUnlock |\n\t\t\t\tFileSystemProviderCapabilities.FileAtomicRead |\n\t\t\t\tFileSystemProviderCapabilities.FileAtomicWrite |\n\t\t\t\tFileSystemProviderCapabilities.FileAtomicDelete |\n\t\t\t\tFileSystemProviderCapabilities.FileClone;\n\n\t\t\tif (isLinux) {\n\t\t\t\tthis._capabilities |=\n\t\t\t\t\tFileSystemProviderCapabilities.PathCaseSensitive;\n\t\t\t}\n\t\t}\n\n\t\treturn this._capabilities;\n\t}\n\n\t//#endregion\n\n\t//#region File Metadata Resolving\n\n\tasync stat(resource: URI): Promise<IStat> {\n\t\ttry {\n\t\t\tconst { stat, symbolicLink } = await SymlinkSupport.stat(\n\t\t\t\tthis.toFilePath(resource),\n\t\t\t); // cannot use fs.stat() here to support links properly\n\n\t\t\treturn {\n\t\t\t\ttype: this.toType(stat, symbolicLink),\n\t\t\t\tctime: stat.birthtime.getTime(), // intentionally not using ctime here, we want the creation time\n\t\t\t\tmtime: stat.mtime.getTime(),\n\t\t\t\tsize: stat.size,\n\t\t\t\tpermissions:\n\t\t\t\t\t(stat.mode & 0o200) === 0\n\t\t\t\t\t\t? FilePermission.Locked\n\t\t\t\t\t\t: undefined,\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tprivate async statIgnoreError(resource: URI): Promise<IStat | undefined> {\n\t\ttry {\n\t\t\treturn await this.stat(resource);\n\t\t} catch (error) {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tasync readdir(resource: URI): Promise<[string, FileType][]> {\n\t\ttry {\n\t\t\tconst children = await Promises.readdir(this.toFilePath(resource), {\n\t\t\t\twithFileTypes: true,\n\t\t\t});\n\n\t\t\tconst result: [string, FileType][] = [];\n\t\t\tawait Promise.all(\n\t\t\t\tchildren.map(async (child) => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet type: FileType;\n\t\t\t\t\t\tif (child.isSymbolicLink()) {\n\t\t\t\t\t\t\ttype = (\n\t\t\t\t\t\t\t\tawait this.stat(joinPath(resource, child.name))\n\t\t\t\t\t\t\t).type; // always resolve target the link points to if any\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttype = this.toType(child);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresult.push([child.name, type]);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tthis.logService.trace(error); // ignore errors for individual entries that can arise from permission denied\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tprivate toType(\n\t\tentry: Stats | IDirent,\n\t\tsymbolicLink?: { dangling: boolean },\n\t): FileType {\n\t\t// Signal file type by checking for file / directory, except:\n\t\t// - symbolic links pointing to nonexistent files are FileType.Unknown\n\t\t// - files that are neither file nor directory are FileType.Unknown\n\t\tlet type: FileType;\n\t\tif (symbolicLink?.dangling) {\n\t\t\ttype = FileType.Unknown;\n\t\t} else if (entry.isFile()) {\n\t\t\ttype = FileType.File;\n\t\t} else if (entry.isDirectory()) {\n\t\t\ttype = FileType.Directory;\n\t\t} else {\n\t\t\ttype = FileType.Unknown;\n\t\t}\n\n\t\t// Always signal symbolic link as file type additionally\n\t\tif (symbolicLink) {\n\t\t\ttype |= FileType.SymbolicLink;\n\t\t}\n\n\t\treturn type;\n\t}\n\n\t//#endregion\n\n\t//#region File Reading/Writing\n\n\tprivate readonly resourceLocks = new ResourceMap<Barrier>((resource) =>\n\t\textUriBiasedIgnorePathCase.getComparisonKey(resource),\n\t);\n\n\tprivate async createResourceLock(resource: URI): Promise<IDisposable> {\n\t\tconst filePath = this.toFilePath(resource);\n\t\tthis.traceLock(\n\t\t\t`[Disk FileSystemProvider]: createResourceLock() - request to acquire resource lock (${filePath})`,\n\t\t);\n\n\t\t// Await pending locks for resource. It is possible for a new lock being\n\t\t// added right after opening, so we have to loop over locks until no lock\n\t\t// remains.\n\t\tlet existingLock: Barrier | undefined;\n\t\twhile ((existingLock = this.resourceLocks.get(resource))) {\n\t\t\tthis.traceLock(\n\t\t\t\t`[Disk FileSystemProvider]: createResourceLock() - waiting for resource lock to be released (${filePath})`,\n\t\t\t);\n\t\t\tawait existingLock.wait();\n\t\t}\n\n\t\t// Store new\n\t\tconst newLock = new Barrier();\n\t\tthis.resourceLocks.set(resource, newLock);\n\n\t\tthis.traceLock(\n\t\t\t`[Disk FileSystemProvider]: createResourceLock() - new resource lock created (${filePath})`,\n\t\t);\n\n\t\treturn toDisposable(() => {\n\t\t\tthis.traceLock(\n\t\t\t\t`[Disk FileSystemProvider]: createResourceLock() - resource lock dispose() (${filePath})`,\n\t\t\t);\n\n\t\t\t// Delete lock if it is still ours\n\t\t\tif (this.resourceLocks.get(resource) === newLock) {\n\t\t\t\tthis.traceLock(\n\t\t\t\t\t`[Disk FileSystemProvider]: createResourceLock() - resource lock removed from resource-lock map (${filePath})`,\n\t\t\t\t);\n\t\t\t\tthis.resourceLocks.delete(resource);\n\t\t\t}\n\n\t\t\t// Open lock\n\t\t\tthis.traceLock(\n\t\t\t\t`[Disk FileSystemProvider]: createResourceLock() - resource lock barrier open() (${filePath})`,\n\t\t\t);\n\t\t\tnewLock.open();\n\t\t});\n\t}\n\n\tasync readFile(\n\t\tresource: URI,\n\t\toptions?: IFileAtomicReadOptions,\n\t): Promise<Uint8Array> {\n\t\tlet lock: IDisposable | undefined;\n\t\ttry {\n\t\t\tif (options?.atomic) {\n\t\t\t\tthis.traceLock(\n\t\t\t\t\t`[Disk FileSystemProvider]: atomic read operation started (${this.toFilePath(resource)})`,\n\t\t\t\t);\n\n\t\t\t\t// When the read should be atomic, make sure\n\t\t\t\t// to await any pending locks for the resource\n\t\t\t\t// and lock for the duration of the read.\n\t\t\t\tlock = await this.createResourceLock(resource);\n\t\t\t}\n\n\t\t\tconst filePath = this.toFilePath(resource);\n\n\t\t\treturn await promises.readFile(filePath);\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t} finally {\n\t\t\tlock?.dispose();\n\t\t}\n\t}\n\n\tprivate traceLock(msg: string): void {\n\t\tif (DiskFileSystemProvider.TRACE_LOG_RESOURCE_LOCKS) {\n\t\t\tthis.logService.trace(msg);\n\t\t}\n\t}\n\n\treadFileStream(\n\t\tresource: URI,\n\t\topts: IFileReadStreamOptions,\n\t\ttoken: CancellationToken,\n\t): ReadableStreamEvents<Uint8Array> {\n\t\tconst stream = newWriteableStream<Uint8Array>(\n\t\t\t(data) =>\n\t\t\t\tVSBuffer.concat(data.map((data) => VSBuffer.wrap(data))).buffer,\n\t\t);\n\n\t\treadFileIntoStream(\n\t\t\tthis,\n\t\t\tresource,\n\t\t\tstream,\n\t\t\t(data) => data.buffer,\n\t\t\t{\n\t\t\t\t...opts,\n\t\t\t\tbufferSize: 256 * 1024, // read into chunks of 256kb each to reduce IPC overhead\n\t\t\t},\n\t\t\ttoken,\n\t\t);\n\n\t\treturn stream;\n\t}\n\n\tasync writeFile(\n\t\tresource: URI,\n\t\tcontent: Uint8Array,\n\t\topts: IFileWriteOptions,\n\t): Promise<void> {\n\t\tif (\n\t\t\topts?.atomic !== false &&\n\t\t\topts?.atomic?.postfix &&\n\t\t\t(await this.canWriteFileAtomic(resource))\n\t\t) {\n\t\t\treturn this.doWriteFileAtomic(\n\t\t\t\tresource,\n\t\t\t\tjoinPath(\n\t\t\t\t\tresourcesDirname(resource),\n\t\t\t\t\t`${resourcesBasename(resource)}${opts.atomic.postfix}`,\n\t\t\t\t),\n\t\t\t\tcontent,\n\t\t\t\topts,\n\t\t\t);\n\t\t} else {\n\t\t\treturn this.doWriteFile(resource, content, opts);\n\t\t}\n\t}\n\n\tprivate async canWriteFileAtomic(resource: URI): Promise<boolean> {\n\t\ttry {\n\t\t\tconst filePath = this.toFilePath(resource);\n\t\t\tconst { symbolicLink } = await SymlinkSupport.stat(filePath);\n\t\t\tif (symbolicLink) {\n\t\t\t\t// atomic writes are unsupported for symbolic links because\n\t\t\t\t// we need to ensure that the `rename` operation is atomic\n\t\t\t\t// and that only works if the link is on the same disk.\n\t\t\t\t// Since we do not know where the symbolic link points to\n\t\t\t\t// we refuse to write atomically.\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// ignore stat errors here and just proceed trying to write\n\t\t}\n\n\t\treturn true; // atomic writing supported\n\t}\n\n\tprivate async doWriteFileAtomic(\n\t\tresource: URI,\n\t\ttempResource: URI,\n\t\tcontent: Uint8Array,\n\t\topts: IFileWriteOptions,\n\t): Promise<void> {\n\t\t// Ensure to create locks for all resources involved\n\t\t// since atomic write involves mutiple disk operations\n\t\t// and resources.\n\n\t\tconst locks = new DisposableStore();\n\n\t\ttry {\n\t\t\tlocks.add(await this.createResourceLock(resource));\n\t\t\tlocks.add(await this.createResourceLock(tempResource));\n\n\t\t\t// Write to temp resource first\n\t\t\tawait this.doWriteFile(\n\t\t\t\ttempResource,\n\t\t\t\tcontent,\n\t\t\t\topts,\n\t\t\t\ttrue /* disable write lock */,\n\t\t\t);\n\n\t\t\ttry {\n\t\t\t\t// Rename over existing to ensure atomic replace\n\t\t\t\tawait this.rename(tempResource, resource, { overwrite: true });\n\t\t\t} catch (error) {\n\t\t\t\t// Cleanup in case of rename error\n\t\t\t\ttry {\n\t\t\t\t\tawait this.delete(tempResource, {\n\t\t\t\t\t\trecursive: false,\n\t\t\t\t\t\tuseTrash: false,\n\t\t\t\t\t\tatomic: false,\n\t\t\t\t\t});\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// ignore - we want the outer error to bubble up\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t} finally {\n\t\t\tlocks.dispose();\n\t\t}\n\t}\n\n\tprivate async doWriteFile(\n\t\tresource: URI,\n\t\tcontent: Uint8Array,\n\t\topts: IFileWriteOptions,\n\t\tdisableWriteLock?: boolean,\n\t): Promise<void> {\n\t\tlet handle: number | undefined;\n\t\ttry {\n\t\t\tconst filePath = this.toFilePath(resource);\n\n\t\t\t// Validate target unless { create: true, overwrite: true }\n\t\t\tif (!opts.create || !opts.overwrite) {\n\t\t\t\tconst fileExists = await Promises.exists(filePath);\n\t\t\t\tif (fileExists) {\n\t\t\t\t\tif (!opts.overwrite) {\n\t\t\t\t\t\tthrow createFileSystemProviderError(\n\t\t\t\t\t\t\tlocalize(\"fileExists\", \"File already exists\"),\n\t\t\t\t\t\t\tFileSystemProviderErrorCode.FileExists,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else if (!opts.create) {\n\t\t\t\t\tthrow createFileSystemProviderError(\n\t\t\t\t\t\tlocalize(\"fileNotExists\", \"File does not exist\"),\n\t\t\t\t\t\tFileSystemProviderErrorCode.FileNotFound,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Open\n\t\t\thandle = await this.open(\n\t\t\t\tresource,\n\t\t\t\t{ create: true, unlock: opts.unlock },\n\t\t\t\tdisableWriteLock,\n\t\t\t);\n\n\t\t\t// Write content at once\n\t\t\tawait this.write(handle, 0, content, 0, content.byteLength);\n\t\t} catch (error) {\n\t\t\tthrow await this.toFileSystemProviderWriteError(resource, error);\n\t\t} finally {\n\t\t\tif (typeof handle === \"number\") {\n\t\t\t\tawait this.close(handle);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate readonly mapHandleToPos = new Map<number, number>();\n\tprivate readonly mapHandleToLock = new Map<number, IDisposable>();\n\n\tprivate readonly writeHandles = new Map<number, URI>();\n\n\tprivate static canFlush = true;\n\n\tstatic configureFlushOnWrite(enabled: boolean): void {\n\t\tDiskFileSystemProvider.canFlush = enabled;\n\t}\n\n\tasync open(\n\t\tresource: URI,\n\t\topts: IFileOpenOptions,\n\t\tdisableWriteLock?: boolean,\n\t): Promise<number> {\n\t\tconst filePath = this.toFilePath(resource);\n\n\t\t// Writes: guard multiple writes to the same resource\n\t\t// behind a single lock to prevent races when writing\n\t\t// from multiple places at the same time to the same file\n\t\tlet lock: IDisposable | undefined;\n\t\tif (isFileOpenForWriteOptions(opts) && !disableWriteLock) {\n\t\t\tlock = await this.createResourceLock(resource);\n\t\t}\n\n\t\tlet fd: number | undefined;\n\t\ttry {\n\t\t\t// Determine whether to unlock the file (write only)\n\t\t\tif (isFileOpenForWriteOptions(opts) && opts.unlock) {\n\t\t\t\ttry {\n\t\t\t\t\tconst { stat } = await SymlinkSupport.stat(filePath);\n\t\t\t\t\tif (\n\t\t\t\t\t\t!(\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\tstat.mode & 0o200\n\t\t\t\t\t\t\t) /* File mode indicating writable by owner */\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tawait promises.chmod(filePath, stat.mode | 0o200);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (error.code !== \"ENOENT\") {\n\t\t\t\t\t\tthis.logService.trace(error); // ignore any errors here and try to just write\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Determine file flags for opening (read vs write)\n\t\t\tlet flags: string | undefined;\n\t\t\tif (isFileOpenForWriteOptions(opts)) {\n\t\t\t\tif (isWindows) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// On Windows and if the file exists, we use a different strategy of saving the file\n\t\t\t\t\t\t// by first truncating the file and then writing with r+ flag. This helps to save hidden files on Windows\n\t\t\t\t\t\t// (see https://github.com/microsoft/vscode/issues/931) and prevent removing alternate data streams\n\t\t\t\t\t\t// (see https://github.com/microsoft/vscode/issues/6363)\n\t\t\t\t\t\tawait promises.truncate(filePath, 0);\n\n\t\t\t\t\t\t// After a successful truncate() the flag can be set to 'r+' which will not truncate.\n\t\t\t\t\t\tflags = \"r+\";\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tif (error.code !== \"ENOENT\") {\n\t\t\t\t\t\t\tthis.logService.trace(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// We take opts.create as a hint that the file is opened for writing\n\t\t\t\t// as such we use 'w' to truncate an existing or create the\n\t\t\t\t// file otherwise. we do not allow reading.\n\t\t\t\tif (!flags) {\n\t\t\t\t\tflags = \"w\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Otherwise we assume the file is opened for reading\n\t\t\t\t// as such we use 'r' to neither truncate, nor create\n\t\t\t\t// the file.\n\t\t\t\tflags = \"r\";\n\t\t\t}\n\n\t\t\t// Finally open handle to file path\n\t\t\tfd = await Promises.open(filePath, flags);\n\t\t} catch (error) {\n\t\t\t// Release lock because we have no valid handle\n\t\t\t// if we did open a lock during this operation\n\t\t\tlock?.dispose();\n\n\t\t\t// Rethrow as file system provider error\n\t\t\tif (isFileOpenForWriteOptions(opts)) {\n\t\t\t\tthrow await this.toFileSystemProviderWriteError(\n\t\t\t\t\tresource,\n\t\t\t\t\terror,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t\t}\n\t\t}\n\n\t\t// Remember this handle to track file position of the handle\n\t\t// we init the position to 0 since the file descriptor was\n\t\t// just created and the position was not moved so far (see\n\t\t// also http://man7.org/linux/man-pages/man2/open.2.html -\n\t\t// \"The file offset is set to the beginning of the file.\")\n\t\tthis.mapHandleToPos.set(fd, 0);\n\n\t\t// remember that this handle was used for writing\n\t\tif (isFileOpenForWriteOptions(opts)) {\n\t\t\tthis.writeHandles.set(fd, resource);\n\t\t}\n\n\t\tif (lock) {\n\t\t\tconst previousLock = this.mapHandleToLock.get(fd);\n\n\t\t\t// Remember that this handle has an associated lock\n\t\t\tthis.traceLock(\n\t\t\t\t`[Disk FileSystemProvider]: open() - storing lock for handle ${fd} (${filePath})`,\n\t\t\t);\n\t\t\tthis.mapHandleToLock.set(fd, lock);\n\n\t\t\t// There is a slight chance that a resource lock for a\n\t\t\t// handle was not yet disposed when we acquire a new\n\t\t\t// lock, so we must ensure to dispose the previous lock\n\t\t\t// before storing a new one for the same handle, other\n\t\t\t// wise we end up in a deadlock situation\n\t\t\t// https://github.com/microsoft/vscode/issues/142462\n\t\t\tif (previousLock) {\n\t\t\t\tthis.traceLock(\n\t\t\t\t\t`[Disk FileSystemProvider]: open() - disposing a previous lock that was still stored on same handle ${fd} (${filePath})`,\n\t\t\t\t);\n\t\t\t\tpreviousLock.dispose();\n\t\t\t}\n\t\t}\n\n\t\treturn fd;\n\t}\n\n\tasync close(fd: number): Promise<void> {\n\t\t// It is very important that we keep any associated lock\n\t\t// for the file handle before attempting to call `fs.close(fd)`\n\t\t// because of a possible race condition: as soon as a file\n\t\t// handle is released, the OS may assign the same handle to\n\t\t// the next `fs.open` call and as such it is possible that our\n\t\t// lock is getting overwritten\n\t\tconst lockForHandle = this.mapHandleToLock.get(fd);\n\n\t\ttry {\n\t\t\t// Remove this handle from map of positions\n\t\t\tthis.mapHandleToPos.delete(fd);\n\n\t\t\t// If a handle is closed that was used for writing, ensure\n\t\t\t// to flush the contents to disk if possible.\n\t\t\tif (\n\t\t\t\tthis.writeHandles.delete(fd) &&\n\t\t\t\tDiskFileSystemProvider.canFlush\n\t\t\t) {\n\t\t\t\ttry {\n\t\t\t\t\tawait Promises.fdatasync(fd); // https://github.com/microsoft/vscode/issues/9589\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// In some exotic setups it is well possible that node fails to sync\n\t\t\t\t\t// In that case we disable flushing and log the error to our logger\n\t\t\t\t\tDiskFileSystemProvider.configureFlushOnWrite(false);\n\t\t\t\t\tthis.logService.error(error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn await Promises.close(fd);\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t} finally {\n\t\t\tif (lockForHandle) {\n\t\t\t\tif (this.mapHandleToLock.get(fd) === lockForHandle) {\n\t\t\t\t\tthis.traceLock(\n\t\t\t\t\t\t`[Disk FileSystemProvider]: close() - resource lock removed from handle-lock map ${fd}`,\n\t\t\t\t\t);\n\t\t\t\t\tthis.mapHandleToLock.delete(fd); // only delete from map if this is still our lock!\n\t\t\t\t}\n\n\t\t\t\tthis.traceLock(\n\t\t\t\t\t`[Disk FileSystemProvider]: close() - disposing lock for handle ${fd}`,\n\t\t\t\t);\n\t\t\t\tlockForHandle.dispose();\n\t\t\t}\n\t\t}\n\t}\n\n\tasync read(\n\t\tfd: number,\n\t\tpos: number,\n\t\tdata: Uint8Array,\n\t\toffset: number,\n\t\tlength: number,\n\t): Promise<number> {\n\t\tconst normalizedPos = this.normalizePos(fd, pos);\n\n\t\tlet bytesRead: number | null = null;\n\t\ttry {\n\t\t\tbytesRead = (\n\t\t\t\tawait Promises.read(fd, data, offset, length, normalizedPos)\n\t\t\t).bytesRead;\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t} finally {\n\t\t\tthis.updatePos(fd, normalizedPos, bytesRead);\n\t\t}\n\n\t\treturn bytesRead;\n\t}\n\n\tprivate normalizePos(fd: number, pos: number): number | null {\n\t\t// When calling fs.read/write we try to avoid passing in the \"pos\" argument and\n\t\t// rather prefer to pass in \"null\" because this avoids an extra seek(pos)\n\t\t// call that in some cases can even fail (e.g. when opening a file over FTP -\n\t\t// see https://github.com/microsoft/vscode/issues/73884).\n\t\t//\n\t\t// as such, we compare the passed in position argument with our last known\n\t\t// position for the file descriptor and use \"null\" if they match.\n\t\tif (pos === this.mapHandleToPos.get(fd)) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn pos;\n\t}\n\n\tprivate updatePos(\n\t\tfd: number,\n\t\tpos: number | null,\n\t\tbytesLength: number | null,\n\t): void {\n\t\tconst lastKnownPos = this.mapHandleToPos.get(fd);\n\t\tif (typeof lastKnownPos === \"number\") {\n\t\t\t// pos !== null signals that previously a position was used that is\n\t\t\t// not null. node.js documentation explains, that in this case\n\t\t\t// the internal file pointer is not moving and as such we do not move\n\t\t\t// our position pointer.\n\t\t\t//\n\t\t\t// Docs: \"If position is null, data will be read from the current file position,\n\t\t\t// and the file position will be updated. If position is an integer, the file position\n\t\t\t// will remain unchanged.\"\n\t\t\tif (typeof pos === \"number\") {\n\t\t\t\t// do not modify the position\n\t\t\t}\n\n\t\t\t// bytesLength = number is a signal that the read/write operation was\n\t\t\t// successful and as such we need to advance the position in the Map\n\t\t\t//\n\t\t\t// Docs (http://man7.org/linux/man-pages/man2/read.2.html):\n\t\t\t// \"On files that support seeking, the read operation commences at the\n\t\t\t// file offset, and the file offset is incremented by the number of\n\t\t\t// bytes read.\"\n\t\t\t//\n\t\t\t// Docs (http://man7.org/linux/man-pages/man2/write.2.html):\n\t\t\t// \"For a seekable file (i.e., one to which lseek(2) may be applied, for\n\t\t\t// example, a regular file) writing takes place at the file offset, and\n\t\t\t// the file offset is incremented by the number of bytes actually\n\t\t\t// written.\"\n\t\t\telse if (typeof bytesLength === \"number\") {\n\t\t\t\tthis.mapHandleToPos.set(fd, lastKnownPos + bytesLength);\n\t\t\t}\n\n\t\t\t// bytesLength = null signals an error in the read/write operation\n\t\t\t// and as such we drop the handle from the Map because the position\n\t\t\t// is unspecificed at this point.\n\t\t\telse {\n\t\t\t\tthis.mapHandleToPos.delete(fd);\n\t\t\t}\n\t\t}\n\t}\n\n\tasync write(\n\t\tfd: number,\n\t\tpos: number,\n\t\tdata: Uint8Array,\n\t\toffset: number,\n\t\tlength: number,\n\t): Promise<number> {\n\t\t// We know at this point that the file to write to is truncated and thus empty\n\t\t// if the write now fails, the file remains empty. as such we really try hard\n\t\t// to ensure the write succeeds by retrying up to three times.\n\t\treturn retry(\n\t\t\t() => this.doWrite(fd, pos, data, offset, length),\n\t\t\t100 /* ms delay */,\n\t\t\t3 /* retries */,\n\t\t);\n\t}\n\n\tprivate async doWrite(\n\t\tfd: number,\n\t\tpos: number,\n\t\tdata: Uint8Array,\n\t\toffset: number,\n\t\tlength: number,\n\t): Promise<number> {\n\t\tconst normalizedPos = this.normalizePos(fd, pos);\n\n\t\tlet bytesWritten: number | null = null;\n\t\ttry {\n\t\t\tbytesWritten = (\n\t\t\t\tawait Promises.write(fd, data, offset, length, normalizedPos)\n\t\t\t).bytesWritten;\n\t\t} catch (error) {\n\t\t\tthrow await this.toFileSystemProviderWriteError(\n\t\t\t\tthis.writeHandles.get(fd),\n\t\t\t\terror,\n\t\t\t);\n\t\t} finally {\n\t\t\tthis.updatePos(fd, normalizedPos, bytesWritten);\n\t\t}\n\n\t\treturn bytesWritten;\n\t}\n\n\t//#endregion\n\n\t//#region Move/Copy/Delete/Create Folder\n\n\tasync mkdir(resource: URI): Promise<void> {\n\t\ttry {\n\t\t\tawait promises.mkdir(this.toFilePath(resource));\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tasync delete(resource: URI, opts: IFileDeleteOptions): Promise<void> {\n\t\ttry {\n\t\t\tconst filePath = this.toFilePath(resource);\n\t\t\tif (opts.recursive) {\n\t\t\t\tlet rmMoveToPath: string | undefined;\n\t\t\t\tif (opts?.atomic !== false && opts.atomic.postfix) {\n\t\t\t\t\trmMoveToPath = join(\n\t\t\t\t\t\tdirname(filePath),\n\t\t\t\t\t\t`${basename(filePath)}${opts.atomic.postfix}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tawait Promises.rm(filePath, RimRafMode.MOVE, rmMoveToPath);\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tawait promises.unlink(filePath);\n\t\t\t\t} catch (unlinkError) {\n\t\t\t\t\t// `fs.unlink` will throw when used on directories\n\t\t\t\t\t// we try to detect this error and then see if the\n\t\t\t\t\t// provided resource is actually a directory. in that\n\t\t\t\t\t// case we use `fs.rmdir` to delete the directory.\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tunlinkError.code === \"EPERM\" ||\n\t\t\t\t\t\tunlinkError.code === \"EISDIR\"\n\t\t\t\t\t) {\n\t\t\t\t\t\tlet isDirectory = false;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst { stat, symbolicLink } =\n\t\t\t\t\t\t\t\tawait SymlinkSupport.stat(filePath);\n\t\t\t\t\t\t\tisDirectory = stat.isDirectory() && !symbolicLink;\n\t\t\t\t\t\t} catch (statError) {\n\t\t\t\t\t\t\t// ignore\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (isDirectory) {\n\t\t\t\t\t\t\tawait promises.rmdir(filePath);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow unlinkError;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow unlinkError;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tasync rename(\n\t\tfrom: URI,\n\t\tto: URI,\n\t\topts: IFileOverwriteOptions,\n\t): Promise<void> {\n\t\tconst fromFilePath = this.toFilePath(from);\n\t\tconst toFilePath = this.toFilePath(to);\n\n\t\tif (fromFilePath === toFilePath) {\n\t\t\treturn; // simulate node.js behaviour here and do a no-op if paths match\n\t\t}\n\n\t\ttry {\n\t\t\t// Validate the move operation can perform\n\t\t\tawait this.validateMoveCopy(from, to, \"move\", opts.overwrite);\n\n\t\t\t// Rename\n\t\t\tawait Promises.rename(fromFilePath, toFilePath);\n\t\t} catch (error) {\n\t\t\t// Rewrite some typical errors that can happen especially around symlinks\n\t\t\t// to something the user can better understand\n\t\t\tif (\n\t\t\t\terror.code === \"EINVAL\" ||\n\t\t\t\terror.code === \"EBUSY\" ||\n\t\t\t\terror.code === \"ENAMETOOLONG\"\n\t\t\t) {\n\t\t\t\terror = new Error(\n\t\t\t\t\tlocalize(\n\t\t\t\t\t\t\"moveError\",\n\t\t\t\t\t\t\"Unable to move '{0}' into '{1}' ({2}).\",\n\t\t\t\t\t\tbasename(fromFilePath),\n\t\t\t\t\t\tbasename(dirname(toFilePath)),\n\t\t\t\t\t\terror.toString(),\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tasync copy(from: URI, to: URI, opts: IFileOverwriteOptions): Promise<void> {\n\t\tconst fromFilePath = this.toFilePath(from);\n\t\tconst toFilePath = this.toFilePath(to);\n\n\t\tif (fromFilePath === toFilePath) {\n\t\t\treturn; // simulate node.js behaviour here and do a no-op if paths match\n\t\t}\n\n\t\ttry {\n\t\t\t// Validate the copy operation can perform\n\t\t\tawait this.validateMoveCopy(from, to, \"copy\", opts.overwrite);\n\n\t\t\t// Copy\n\t\t\tawait Promises.copy(fromFilePath, toFilePath, {\n\t\t\t\tpreserveSymlinks: true,\n\t\t\t});\n\t\t} catch (error) {\n\t\t\t// Rewrite some typical errors that can happen especially around symlinks\n\t\t\t// to something the user can better understand\n\t\t\tif (\n\t\t\t\terror.code === \"EINVAL\" ||\n\t\t\t\terror.code === \"EBUSY\" ||\n\t\t\t\terror.code === \"ENAMETOOLONG\"\n\t\t\t) {\n\t\t\t\terror = new Error(\n\t\t\t\t\tlocalize(\n\t\t\t\t\t\t\"copyError\",\n\t\t\t\t\t\t\"Unable to copy '{0}' into '{1}' ({2}).\",\n\t\t\t\t\t\tbasename(fromFilePath),\n\t\t\t\t\t\tbasename(dirname(toFilePath)),\n\t\t\t\t\t\terror.toString(),\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tprivate async validateMoveCopy(\n\t\tfrom: URI,\n\t\tto: URI,\n\t\tmode: \"move\" | \"copy\",\n\t\toverwrite?: boolean,\n\t): Promise<void> {\n\t\tconst fromFilePath = this.toFilePath(from);\n\t\tconst toFilePath = this.toFilePath(to);\n\n\t\tlet isSameResourceWithDifferentPathCase = false;\n\t\tconst isPathCaseSensitive = !!(\n\t\t\tthis.capabilities & FileSystemProviderCapabilities.PathCaseSensitive\n\t\t);\n\t\tif (!isPathCaseSensitive) {\n\t\t\tisSameResourceWithDifferentPathCase = isEqual(\n\t\t\t\tfromFilePath,\n\t\t\t\ttoFilePath,\n\t\t\t\ttrue /* ignore case */,\n\t\t\t);\n\t\t}\n\n\t\tif (isSameResourceWithDifferentPathCase) {\n\t\t\t// You cannot copy the same file to the same location with different\n\t\t\t// path case unless you are on a case sensitive file system\n\t\t\tif (mode === \"copy\") {\n\t\t\t\tthrow createFileSystemProviderError(\n\t\t\t\t\tlocalize(\n\t\t\t\t\t\t\"fileCopyErrorPathCase\",\n\t\t\t\t\t\t\"File cannot be copied to same path with different path case\",\n\t\t\t\t\t),\n\t\t\t\t\tFileSystemProviderErrorCode.FileExists,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// You can move the same file to the same location with different\n\t\t\t// path case on case insensitive file systems\n\t\t\telse if (mode === \"move\") {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Here we have to see if the target to move/copy to exists or not.\n\t\t// We need to respect the `overwrite` option to throw in case the\n\t\t// target exists.\n\n\t\tconst fromStat = await this.statIgnoreError(from);\n\t\tif (!fromStat) {\n\t\t\tthrow createFileSystemProviderError(\n\t\t\t\tlocalize(\n\t\t\t\t\t\"fileMoveCopyErrorNotFound\",\n\t\t\t\t\t\"File to move/copy does not exist\",\n\t\t\t\t),\n\t\t\t\tFileSystemProviderErrorCode.FileNotFound,\n\t\t\t);\n\t\t}\n\n\t\tconst toStat = await this.statIgnoreError(to);\n\t\tif (!toStat) {\n\t\t\treturn; // target does not exist so we are good\n\t\t}\n\n\t\tif (!overwrite) {\n\t\t\tthrow createFileSystemProviderError(\n\t\t\t\tlocalize(\n\t\t\t\t\t\"fileMoveCopyErrorExists\",\n\t\t\t\t\t\"File at target already exists and thus will not be moved/copied to unless overwrite is specified\",\n\t\t\t\t),\n\t\t\t\tFileSystemProviderErrorCode.FileExists,\n\t\t\t);\n\t\t}\n\n\t\t// Handle existing target for move/copy\n\t\tif (\n\t\t\t(fromStat.type & FileType.File) !== 0 &&\n\t\t\t(toStat.type & FileType.File) !== 0\n\t\t) {\n\t\t\treturn; // node.js can move/copy a file over an existing file without having to delete it first\n\t\t} else {\n\t\t\tawait this.delete(to, {\n\t\t\t\trecursive: true,\n\t\t\t\tuseTrash: false,\n\t\t\t\tatomic: false,\n\t\t\t});\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region Clone File\n\n\tasync cloneFile(from: URI, to: URI): Promise<void> {\n\t\treturn this.doCloneFile(\n\t\t\tfrom,\n\t\t\tto,\n\t\t\tfalse /* optimistically assume parent folders exist */,\n\t\t);\n\t}\n\n\tprivate async doCloneFile(\n\t\tfrom: URI,\n\t\tto: URI,\n\t\tmkdir: boolean,\n\t): Promise<void> {\n\t\tconst fromFilePath = this.toFilePath(from);\n\t\tconst toFilePath = this.toFilePath(to);\n\n\t\tconst isPathCaseSensitive = !!(\n\t\t\tthis.capabilities & FileSystemProviderCapabilities.PathCaseSensitive\n\t\t);\n\t\tif (isEqual(fromFilePath, toFilePath, !isPathCaseSensitive)) {\n\t\t\treturn; // cloning is only supported `from` and `to` are different files\n\t\t}\n\n\t\t// Implement clone by using `fs.copyFile`, however setup locks\n\t\t// for both `from` and `to` because node.js does not ensure\n\t\t// this to be an atomic operation\n\n\t\tconst locks = new DisposableStore();\n\n\t\ttry {\n\t\t\tlocks.add(await this.createResourceLock(from));\n\t\t\tlocks.add(await this.createResourceLock(to));\n\n\t\t\tif (mkdir) {\n\t\t\t\tawait promises.mkdir(dirname(toFilePath), { recursive: true });\n\t\t\t}\n\n\t\t\tawait promises.copyFile(fromFilePath, toFilePath);\n\t\t} catch (error) {\n\t\t\tif (error.code === \"ENOENT\" && !mkdir) {\n\t\t\t\treturn this.doCloneFile(from, to, true);\n\t\t\t}\n\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t} finally {\n\t\t\tlocks.dispose();\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region File Watching\n\n\tprotected createUniversalWatcher(\n\t\tonChange: (changes: IFileChange[]) => void,\n\t\tonLogMessage: (msg: ILogMessage) => void,\n\t\tverboseLogging: boolean,\n\t): AbstractUniversalWatcherClient {\n\t\treturn new UniversalWatcherClient(\n\t\t\t(changes) => onChange(changes),\n\t\t\t(msg) => onLogMessage(msg),\n\t\t\tverboseLogging,\n\t\t);\n\t}\n\n\tprotected createNonRecursiveWatcher(\n\t\tonChange: (changes: IFileChange[]) => void,\n\t\tonLogMessage: (msg: ILogMessage) => void,\n\t\tverboseLogging: boolean,\n\t): AbstractNonRecursiveWatcherClient {\n\t\treturn new NodeJSWatcherClient(\n\t\t\t(changes) => onChange(changes),\n\t\t\t(msg) => onLogMessage(msg),\n\t\t\tverboseLogging,\n\t\t);\n\t}\n\n\t//#endregion\n\n\t//#region Helpers\n\n\tprivate toFileSystemProviderError(\n\t\terror: NodeJS.ErrnoException,\n\t): FileSystemProviderError {\n\t\tif (error instanceof FileSystemProviderError) {\n\t\t\treturn error; // avoid double conversion\n\t\t}\n\n\t\tlet resultError: Error | string = error;\n\t\tlet code: FileSystemProviderErrorCode;\n\t\tswitch (error.code) {\n\t\t\tcase \"ENOENT\":\n\t\t\t\tcode = FileSystemProviderErrorCode.FileNotFound;\n\t\t\t\tbreak;\n\t\t\tcase \"EISDIR\":\n\t\t\t\tcode = FileSystemProviderErrorCode.FileIsADirectory;\n\t\t\t\tbreak;\n\t\t\tcase \"ENOTDIR\":\n\t\t\t\tcode = FileSystemProviderErrorCode.FileNotADirectory;\n\t\t\t\tbreak;\n\t\t\tcase \"EEXIST\":\n\t\t\t\tcode = FileSystemProviderErrorCode.FileExists;\n\t\t\t\tbreak;\n\t\t\tcase \"EPERM\":\n\t\t\tcase \"EACCES\":\n\t\t\t\tcode = FileSystemProviderErrorCode.NoPermissions;\n\t\t\t\tbreak;\n\t\t\tcase \"ERR_UNC_HOST_NOT_ALLOWED\":\n\t\t\t\tresultError = `${error.message}. Please update the 'security.allowedUNCHosts' setting if you want to allow this host.`;\n\t\t\t\tcode = FileSystemProviderErrorCode.Unknown;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcode = FileSystemProviderErrorCode.Unknown;\n\t\t}\n\n\t\treturn createFileSystemProviderError(resultError, code);\n\t}\n\n\tprivate async toFileSystemProviderWriteError(\n\t\tresource: URI | undefined,\n\t\terror: NodeJS.ErrnoException,\n\t): Promise<FileSystemProviderError> {\n\t\tlet fileSystemProviderWriteError =\n\t\t\tthis.toFileSystemProviderError(error);\n\n\t\t// If the write error signals permission issues, we try\n\t\t// to read the file's mode to see if the file is write\n\t\t// locked.\n\t\tif (\n\t\t\tresource &&\n\t\t\tfileSystemProviderWriteError.code ===\n\t\t\t\tFileSystemProviderErrorCode.NoPermissions\n\t\t) {\n\t\t\ttry {\n\t\t\t\tconst { stat } = await SymlinkSupport.stat(\n\t\t\t\t\tthis.toFilePath(resource),\n\t\t\t\t);\n\t\t\t\tif (\n\t\t\t\t\t!(\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tstat.mode & 0o200\n\t\t\t\t\t\t) /* File mode indicating writable by owner */\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tfileSystemProviderWriteError =\n\t\t\t\t\t\tcreateFileSystemProviderError(\n\t\t\t\t\t\t\terror,\n\t\t\t\t\t\t\tFileSystemProviderErrorCode.FileWriteLocked,\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.trace(error); // ignore - return original error\n\t\t\t}\n\t\t}\n\n\t\treturn fileSystemProviderWriteError;\n\t}\n\n\t//#endregion\n}\n"],
  "mappings": ";;AAKA,SAAqB,gBAAgB;AACrC,SAAS,SAAS,aAAa;AAC/B,SAAS,gBAAgB;AAEzB,SAAS,aAAa;AACtB,SAAS,eAAe;AACxB;AAAA,EACC;AAAA,EAEA;AAAA,OACM;AACP,SAAS,mBAAmB;AAC5B,SAAS,UAAU,SAAS,YAAY;AACxC,SAAS,SAAS,iBAAiB;AACnC;AAAA,EACC;AAAA,EACA;AAAA,EACA,YAAY;AAAA,EACZ,WAAW;AAAA,OACL;AACP;AAAA,EAEC;AAAA,OACM;AAEP;AAAA,EAEC;AAAA,EACA;AAAA,EACA;AAAA,OACM;AACP,SAAS,gBAAgB;AAEzB;AAAA,EACC;AAAA,OAEM;AACP;AAAA,EACC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAiBA;AAAA,EACA;AAAA,OACM;AACP,SAAS,0BAA0B;AAMnC,SAAS,2BAA2B;AACpC,SAAS,8BAA8B;AAEhC,MAAM,+BACJ,+BAUT;AAAA,EAvFA,OAuFA;AAAA;AAAA;AAAA,EACC,OAAe,2BAA2B;AAAA;AAAA,EAE1C,YACC,YACA,SACC;AACD,UAAM,YAAY,OAAO;AAAA,EAC1B;AAAA;AAAA,EAIS,0BAA0B,MAAM;AAAA,EAEjC;AAAA,EACR,IAAI,eAA+C;AAClD,QAAI,CAAC,KAAK,eAAe;AACxB,WAAK,gBACJ,+BAA+B,gBAC/B,+BAA+B,yBAC/B,+BAA+B,iBAC/B,+BAA+B,iBAC/B,+BAA+B,kBAC/B,+BAA+B,iBAC/B,+BAA+B,kBAC/B,+BAA+B,mBAC/B,+BAA+B;AAEhC,UAAI,SAAS;AACZ,aAAK,iBACJ,+BAA+B;AAAA,MACjC;AAAA,IACD;AAEA,WAAO,KAAK;AAAA,EACb;AAAA;AAAA;AAAA,EAMA,MAAM,KAAK,UAA+B;AACzC,QAAI;AACH,YAAM,EAAE,MAAM,aAAa,IAAI,MAAM,eAAe;AAAA,QACnD,KAAK,WAAW,QAAQ;AAAA,MACzB;AAEA,aAAO;AAAA,QACN,MAAM,KAAK,OAAO,MAAM,YAAY;AAAA,QACpC,OAAO,KAAK,UAAU,QAAQ;AAAA;AAAA,QAC9B,OAAO,KAAK,MAAM,QAAQ;AAAA,QAC1B,MAAM,KAAK;AAAA,QACX,cACE,KAAK,OAAO,SAAW,IACrB,eAAe,SACf;AAAA,MACL;AAAA,IACD,SAAS,OAAO;AACf,YAAM,KAAK,0BAA0B,KAAK;AAAA,IAC3C;AAAA,EACD;AAAA,EAEA,MAAc,gBAAgB,UAA2C;AACxE,QAAI;AACH,aAAO,MAAM,KAAK,KAAK,QAAQ;AAAA,IAChC,SAAS,OAAO;AACf,aAAO;AAAA,IACR;AAAA,EACD;AAAA,EAEA,MAAM,QAAQ,UAA8C;AAC3D,QAAI;AACH,YAAM,WAAW,MAAM,SAAS,QAAQ,KAAK,WAAW,QAAQ,GAAG;AAAA,QAClE,eAAe;AAAA,MAChB,CAAC;AAED,YAAM,SAA+B,CAAC;AACtC,YAAM,QAAQ;AAAA,QACb,SAAS,IAAI,OAAO,UAAU;AAC7B,cAAI;AACH,gBAAI;AACJ,gBAAI,MAAM,eAAe,GAAG;AAC3B,sBACC,MAAM,KAAK,KAAK,SAAS,UAAU,MAAM,IAAI,CAAC,GAC7C;AAAA,YACH,OAAO;AACN,qBAAO,KAAK,OAAO,KAAK;AAAA,YACzB;AAEA,mBAAO,KAAK,CAAC,MAAM,MAAM,IAAI,CAAC;AAAA,UAC/B,SAAS,OAAO;AACf,iBAAK,WAAW,MAAM,KAAK;AAAA,UAC5B;AAAA,QACD,CAAC;AAAA,MACF;AAEA,aAAO;AAAA,IACR,SAAS,OAAO;AACf,YAAM,KAAK,0BAA0B,KAAK;AAAA,IAC3C;AAAA,EACD;AAAA,EAEQ,OACP,OACA,cACW;AAIX,QAAI;AACJ,QAAI,cAAc,UAAU;AAC3B,aAAO,SAAS;AAAA,IACjB,WAAW,MAAM,OAAO,GAAG;AAC1B,aAAO,SAAS;AAAA,IACjB,WAAW,MAAM,YAAY,GAAG;AAC/B,aAAO,SAAS;AAAA,IACjB,OAAO;AACN,aAAO,SAAS;AAAA,IACjB;AAGA,QAAI,cAAc;AACjB,cAAQ,SAAS;AAAA,IAClB;AAEA,WAAO;AAAA,EACR;AAAA;AAAA;AAAA,EAMiB,gBAAgB,IAAI;AAAA,IAAqB,CAAC,aAC1D,2BAA2B,iBAAiB,QAAQ;AAAA,EACrD;AAAA,EAEA,MAAc,mBAAmB,UAAqC;AACrE,UAAM,WAAW,KAAK,WAAW,QAAQ;AACzC,SAAK;AAAA,MACJ,uFAAuF,QAAQ;AAAA,IAChG;AAKA,QAAI;AACJ,WAAQ,eAAe,KAAK,cAAc,IAAI,QAAQ,GAAI;AACzD,WAAK;AAAA,QACJ,+FAA+F,QAAQ;AAAA,MACxG;AACA,YAAM,aAAa,KAAK;AAAA,IACzB;AAGA,UAAM,UAAU,IAAI,QAAQ;AAC5B,SAAK,cAAc,IAAI,UAAU,OAAO;AAExC,SAAK;AAAA,MACJ,gFAAgF,QAAQ;AAAA,IACzF;AAEA,WAAO,aAAa,MAAM;AACzB,WAAK;AAAA,QACJ,8EAA8E,QAAQ;AAAA,MACvF;AAGA,UAAI,KAAK,cAAc,IAAI,QAAQ,MAAM,SAAS;AACjD,aAAK;AAAA,UACJ,mGAAmG,QAAQ;AAAA,QAC5G;AACA,aAAK,cAAc,OAAO,QAAQ;AAAA,MACnC;AAGA,WAAK;AAAA,QACJ,mFAAmF,QAAQ;AAAA,MAC5F;AACA,cAAQ,KAAK;AAAA,IACd,CAAC;AAAA,EACF;AAAA,EAEA,MAAM,SACL,UACA,SACsB;AACtB,QAAI;AACJ,QAAI;AACH,UAAI,SAAS,QAAQ;AACpB,aAAK;AAAA,UACJ,6DAA6D,KAAK,WAAW,QAAQ,CAAC;AAAA,QACvF;AAKA,eAAO,MAAM,KAAK,mBAAmB,QAAQ;AAAA,MAC9C;AAEA,YAAM,WAAW,KAAK,WAAW,QAAQ;AAEzC,aAAO,MAAM,SAAS,SAAS,QAAQ;AAAA,IACxC,SAAS,OAAO;AACf,YAAM,KAAK,0BAA0B,KAAK;AAAA,IAC3C,UAAE;AACD,YAAM,QAAQ;AAAA,IACf;AAAA,EACD;AAAA,EAEQ,UAAU,KAAmB;AACpC,QAAI,uBAAuB,0BAA0B;AACpD,WAAK,WAAW,MAAM,GAAG;AAAA,IAC1B;AAAA,EACD;AAAA,EAEA,eACC,UACA,MACA,OACmC;AACnC,UAAM,SAAS;AAAA,MACd,CAAC,SACA,SAAS,OAAO,KAAK,IAAI,CAACA,UAAS,SAAS,KAAKA,KAAI,CAAC,CAAC,EAAE;AAAA,IAC3D;AAEA;AAAA,MACC;AAAA,MACA;AAAA,MACA;AAAA,MACA,CAAC,SAAS,KAAK;AAAA,MACf;AAAA,QACC,GAAG;AAAA,QACH,YAAY,MAAM;AAAA;AAAA,MACnB;AAAA,MACA;AAAA,IACD;AAEA,WAAO;AAAA,EACR;AAAA,EAEA,MAAM,UACL,UACA,SACA,MACgB;AAChB,QACC,MAAM,WAAW,SACjB,MAAM,QAAQ,WACb,MAAM,KAAK,mBAAmB,QAAQ,GACtC;AACD,aAAO,KAAK;AAAA,QACX;AAAA,QACA;AAAA,UACC,iBAAiB,QAAQ;AAAA,UACzB,GAAG,kBAAkB,QAAQ,CAAC,GAAG,KAAK,OAAO,OAAO;AAAA,QACrD;AAAA,QACA;AAAA,QACA;AAAA,MACD;AAAA,IACD,OAAO;AACN,aAAO,KAAK,YAAY,UAAU,SAAS,IAAI;AAAA,IAChD;AAAA,EACD;AAAA,EAEA,MAAc,mBAAmB,UAAiC;AACjE,QAAI;AACH,YAAM,WAAW,KAAK,WAAW,QAAQ;AACzC,YAAM,EAAE,aAAa,IAAI,MAAM,eAAe,KAAK,QAAQ;AAC3D,UAAI,cAAc;AAMjB,eAAO;AAAA,MACR;AAAA,IACD,SAAS,OAAO;AAAA,IAEhB;AAEA,WAAO;AAAA,EACR;AAAA,EAEA,MAAc,kBACb,UACA,cACA,SACA,MACgB;AAKhB,UAAM,QAAQ,IAAI,gBAAgB;AAElC,QAAI;AACH,YAAM,IAAI,MAAM,KAAK,mBAAmB,QAAQ,CAAC;AACjD,YAAM,IAAI,MAAM,KAAK,mBAAmB,YAAY,CAAC;AAGrD,YAAM,KAAK;AAAA,QACV;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACD;AAEA,UAAI;AAEH,cAAM,KAAK,OAAO,cAAc,UAAU,EAAE,WAAW,KAAK,CAAC;AAAA,MAC9D,SAAS,OAAO;AAEf,YAAI;AACH,gBAAM,KAAK,OAAO,cAAc;AAAA,YAC/B,WAAW;AAAA,YACX,UAAU;AAAA,YACV,QAAQ;AAAA,UACT,CAAC;AAAA,QACF,SAASC,QAAO;AAAA,QAEhB;AAEA,cAAM;AAAA,MACP;AAAA,IACD,UAAE;AACD,YAAM,QAAQ;AAAA,IACf;AAAA,EACD;AAAA,EAEA,MAAc,YACb,UACA,SACA,MACA,kBACgB;AAChB,QAAI;AACJ,QAAI;AACH,YAAM,WAAW,KAAK,WAAW,QAAQ;AAGzC,UAAI,CAAC,KAAK,UAAU,CAAC,KAAK,WAAW;AACpC,cAAM,aAAa,MAAM,SAAS,OAAO,QAAQ;AACjD,YAAI,YAAY;AACf,cAAI,CAAC,KAAK,WAAW;AACpB,kBAAM;AAAA,cACL,SAAS,cAAc,qBAAqB;AAAA,cAC5C,4BAA4B;AAAA,YAC7B;AAAA,UACD;AAAA,QACD,WAAW,CAAC,KAAK,QAAQ;AACxB,gBAAM;AAAA,YACL,SAAS,iBAAiB,qBAAqB;AAAA,YAC/C,4BAA4B;AAAA,UAC7B;AAAA,QACD;AAAA,MACD;AAGA,eAAS,MAAM,KAAK;AAAA,QACnB;AAAA,QACA,EAAE,QAAQ,MAAM,QAAQ,KAAK,OAAO;AAAA,QACpC;AAAA,MACD;AAGA,YAAM,KAAK,MAAM,QAAQ,GAAG,SAAS,GAAG,QAAQ,UAAU;AAAA,IAC3D,SAAS,OAAO;AACf,YAAM,MAAM,KAAK,+BAA+B,UAAU,KAAK;AAAA,IAChE,UAAE;AACD,UAAI,OAAO,WAAW,UAAU;AAC/B,cAAM,KAAK,MAAM,MAAM;AAAA,MACxB;AAAA,IACD;AAAA,EACD;AAAA,EAEiB,iBAAiB,oBAAI,IAAoB;AAAA,EACzC,kBAAkB,oBAAI,IAAyB;AAAA,EAE/C,eAAe,oBAAI,IAAiB;AAAA,EAErD,OAAe,WAAW;AAAA,EAE1B,OAAO,sBAAsB,SAAwB;AACpD,2BAAuB,WAAW;AAAA,EACnC;AAAA,EAEA,MAAM,KACL,UACA,MACA,kBACkB;AAClB,UAAM,WAAW,KAAK,WAAW,QAAQ;AAKzC,QAAI;AACJ,QAAI,0BAA0B,IAAI,KAAK,CAAC,kBAAkB;AACzD,aAAO,MAAM,KAAK,mBAAmB,QAAQ;AAAA,IAC9C;AAEA,QAAI;AACJ,QAAI;AAEH,UAAI,0BAA0B,IAAI,KAAK,KAAK,QAAQ;AACnD,YAAI;AACH,gBAAM,EAAE,KAAK,IAAI,MAAM,eAAe,KAAK,QAAQ;AACnD,cACC,EAEE,KAAK,OAAO,MAGb;AACD,kBAAM,SAAS,MAAM,UAAU,KAAK,OAAO,GAAK;AAAA,UACjD;AAAA,QACD,SAAS,OAAO;AACf,cAAI,MAAM,SAAS,UAAU;AAC5B,iBAAK,WAAW,MAAM,KAAK;AAAA,UAC5B;AAAA,QACD;AAAA,MACD;AAGA,UAAI;AACJ,UAAI,0BAA0B,IAAI,GAAG;AACpC,YAAI,WAAW;AACd,cAAI;AAKH,kBAAM,SAAS,SAAS,UAAU,CAAC;AAGnC,oBAAQ;AAAA,UACT,SAAS,OAAO;AACf,gBAAI,MAAM,SAAS,UAAU;AAC5B,mBAAK,WAAW,MAAM,KAAK;AAAA,YAC5B;AAAA,UACD;AAAA,QACD;AAKA,YAAI,CAAC,OAAO;AACX,kBAAQ;AAAA,QACT;AAAA,MACD,OAAO;AAIN,gBAAQ;AAAA,MACT;AAGA,WAAK,MAAM,SAAS,KAAK,UAAU,KAAK;AAAA,IACzC,SAAS,OAAO;AAGf,YAAM,QAAQ;AAGd,UAAI,0BAA0B,IAAI,GAAG;AACpC,cAAM,MAAM,KAAK;AAAA,UAChB;AAAA,UACA;AAAA,QACD;AAAA,MACD,OAAO;AACN,cAAM,KAAK,0BAA0B,KAAK;AAAA,MAC3C;AAAA,IACD;AAOA,SAAK,eAAe,IAAI,IAAI,CAAC;AAG7B,QAAI,0BAA0B,IAAI,GAAG;AACpC,WAAK,aAAa,IAAI,IAAI,QAAQ;AAAA,IACnC;AAEA,QAAI,MAAM;AACT,YAAM,eAAe,KAAK,gBAAgB,IAAI,EAAE;AAGhD,WAAK;AAAA,QACJ,+DAA+D,EAAE,KAAK,QAAQ;AAAA,MAC/E;AACA,WAAK,gBAAgB,IAAI,IAAI,IAAI;AAQjC,UAAI,cAAc;AACjB,aAAK;AAAA,UACJ,sGAAsG,EAAE,KAAK,QAAQ;AAAA,QACtH;AACA,qBAAa,QAAQ;AAAA,MACtB;AAAA,IACD;AAEA,WAAO;AAAA,EACR;AAAA,EAEA,MAAM,MAAM,IAA2B;AAOtC,UAAM,gBAAgB,KAAK,gBAAgB,IAAI,EAAE;AAEjD,QAAI;AAEH,WAAK,eAAe,OAAO,EAAE;AAI7B,UACC,KAAK,aAAa,OAAO,EAAE,KAC3B,uBAAuB,UACtB;AACD,YAAI;AACH,gBAAM,SAAS,UAAU,EAAE;AAAA,QAC5B,SAAS,OAAO;AAGf,iCAAuB,sBAAsB,KAAK;AAClD,eAAK,WAAW,MAAM,KAAK;AAAA,QAC5B;AAAA,MACD;AAEA,aAAO,MAAM,SAAS,MAAM,EAAE;AAAA,IAC/B,SAAS,OAAO;AACf,YAAM,KAAK,0BAA0B,KAAK;AAAA,IAC3C,UAAE;AACD,UAAI,eAAe;AAClB,YAAI,KAAK,gBAAgB,IAAI,EAAE,MAAM,eAAe;AACnD,eAAK;AAAA,YACJ,mFAAmF,EAAE;AAAA,UACtF;AACA,eAAK,gBAAgB,OAAO,EAAE;AAAA,QAC/B;AAEA,aAAK;AAAA,UACJ,kEAAkE,EAAE;AAAA,QACrE;AACA,sBAAc,QAAQ;AAAA,MACvB;AAAA,IACD;AAAA,EACD;AAAA,EAEA,MAAM,KACL,IACA,KACA,MACA,QACA,QACkB;AAClB,UAAM,gBAAgB,KAAK,aAAa,IAAI,GAAG;AAE/C,QAAI,YAA2B;AAC/B,QAAI;AACH,mBACC,MAAM,SAAS,KAAK,IAAI,MAAM,QAAQ,QAAQ,aAAa,GAC1D;AAAA,IACH,SAAS,OAAO;AACf,YAAM,KAAK,0BAA0B,KAAK;AAAA,IAC3C,UAAE;AACD,WAAK,UAAU,IAAI,eAAe,SAAS;AAAA,IAC5C;AAEA,WAAO;AAAA,EACR;AAAA,EAEQ,aAAa,IAAY,KAA4B;AAQ5D,QAAI,QAAQ,KAAK,eAAe,IAAI,EAAE,GAAG;AACxC,aAAO;AAAA,IACR;AAEA,WAAO;AAAA,EACR;AAAA,EAEQ,UACP,IACA,KACA,aACO;AACP,UAAM,eAAe,KAAK,eAAe,IAAI,EAAE;AAC/C,QAAI,OAAO,iBAAiB,UAAU;AASrC,UAAI,OAAO,QAAQ,UAAU;AAAA,MAE7B,WAeS,OAAO,gBAAgB,UAAU;AACzC,aAAK,eAAe,IAAI,IAAI,eAAe,WAAW;AAAA,MACvD,OAKK;AACJ,aAAK,eAAe,OAAO,EAAE;AAAA,MAC9B;AAAA,IACD;AAAA,EACD;AAAA,EAEA,MAAM,MACL,IACA,KACA,MACA,QACA,QACkB;AAIlB,WAAO;AAAA,MACN,MAAM,KAAK,QAAQ,IAAI,KAAK,MAAM,QAAQ,MAAM;AAAA,MAChD;AAAA,MACA;AAAA,IACD;AAAA,EACD;AAAA,EAEA,MAAc,QACb,IACA,KACA,MACA,QACA,QACkB;AAClB,UAAM,gBAAgB,KAAK,aAAa,IAAI,GAAG;AAE/C,QAAI,eAA8B;AAClC,QAAI;AACH,sBACC,MAAM,SAAS,MAAM,IAAI,MAAM,QAAQ,QAAQ,aAAa,GAC3D;AAAA,IACH,SAAS,OAAO;AACf,YAAM,MAAM,KAAK;AAAA,QAChB,KAAK,aAAa,IAAI,EAAE;AAAA,QACxB;AAAA,MACD;AAAA,IACD,UAAE;AACD,WAAK,UAAU,IAAI,eAAe,YAAY;AAAA,IAC/C;AAEA,WAAO;AAAA,EACR;AAAA;AAAA;AAAA,EAMA,MAAM,MAAM,UAA8B;AACzC,QAAI;AACH,YAAM,SAAS,MAAM,KAAK,WAAW,QAAQ,CAAC;AAAA,IAC/C,SAAS,OAAO;AACf,YAAM,KAAK,0BAA0B,KAAK;AAAA,IAC3C;AAAA,EACD;AAAA,EAEA,MAAM,OAAO,UAAe,MAAyC;AACpE,QAAI;AACH,YAAM,WAAW,KAAK,WAAW,QAAQ;AACzC,UAAI,KAAK,WAAW;AACnB,YAAI;AACJ,YAAI,MAAM,WAAW,SAAS,KAAK,OAAO,SAAS;AAClD,yBAAe;AAAA,YACd,QAAQ,QAAQ;AAAA,YAChB,GAAG,SAAS,QAAQ,CAAC,GAAG,KAAK,OAAO,OAAO;AAAA,UAC5C;AAAA,QACD;AAEA,cAAM,SAAS,GAAG,UAAU,WAAW,MAAM,YAAY;AAAA,MAC1D,OAAO;AACN,YAAI;AACH,gBAAM,SAAS,OAAO,QAAQ;AAAA,QAC/B,SAAS,aAAa;AAMrB,cACC,YAAY,SAAS,WACrB,YAAY,SAAS,UACpB;AACD,gBAAI,cAAc;AAClB,gBAAI;AACH,oBAAM,EAAE,MAAM,aAAa,IAC1B,MAAM,eAAe,KAAK,QAAQ;AACnC,4BAAc,KAAK,YAAY,KAAK,CAAC;AAAA,YACtC,SAAS,WAAW;AAAA,YAEpB;AAEA,gBAAI,aAAa;AAChB,oBAAM,SAAS,MAAM,QAAQ;AAAA,YAC9B,OAAO;AACN,oBAAM;AAAA,YACP;AAAA,UACD,OAAO;AACN,kBAAM;AAAA,UACP;AAAA,QACD;AAAA,MACD;AAAA,IACD,SAAS,OAAO;AACf,YAAM,KAAK,0BAA0B,KAAK;AAAA,IAC3C;AAAA,EACD;AAAA,EAEA,MAAM,OACL,MACA,IACA,MACgB;AAChB,UAAM,eAAe,KAAK,WAAW,IAAI;AACzC,UAAM,aAAa,KAAK,WAAW,EAAE;AAErC,QAAI,iBAAiB,YAAY;AAChC;AAAA,IACD;AAEA,QAAI;AAEH,YAAM,KAAK,iBAAiB,MAAM,IAAI,QAAQ,KAAK,SAAS;AAG5D,YAAM,SAAS,OAAO,cAAc,UAAU;AAAA,IAC/C,SAAS,OAAO;AAGf,UACC,MAAM,SAAS,YACf,MAAM,SAAS,WACf,MAAM,SAAS,gBACd;AACD,gBAAQ,IAAI;AAAA,UACX;AAAA,YACC;AAAA,YACA;AAAA,YACA,SAAS,YAAY;AAAA,YACrB,SAAS,QAAQ,UAAU,CAAC;AAAA,YAC5B,MAAM,SAAS;AAAA,UAChB;AAAA,QACD;AAAA,MACD;AAEA,YAAM,KAAK,0BAA0B,KAAK;AAAA,IAC3C;AAAA,EACD;AAAA,EAEA,MAAM,KAAK,MAAW,IAAS,MAA4C;AAC1E,UAAM,eAAe,KAAK,WAAW,IAAI;AACzC,UAAM,aAAa,KAAK,WAAW,EAAE;AAErC,QAAI,iBAAiB,YAAY;AAChC;AAAA,IACD;AAEA,QAAI;AAEH,YAAM,KAAK,iBAAiB,MAAM,IAAI,QAAQ,KAAK,SAAS;AAG5D,YAAM,SAAS,KAAK,cAAc,YAAY;AAAA,QAC7C,kBAAkB;AAAA,MACnB,CAAC;AAAA,IACF,SAAS,OAAO;AAGf,UACC,MAAM,SAAS,YACf,MAAM,SAAS,WACf,MAAM,SAAS,gBACd;AACD,gBAAQ,IAAI;AAAA,UACX;AAAA,YACC;AAAA,YACA;AAAA,YACA,SAAS,YAAY;AAAA,YACrB,SAAS,QAAQ,UAAU,CAAC;AAAA,YAC5B,MAAM,SAAS;AAAA,UAChB;AAAA,QACD;AAAA,MACD;AAEA,YAAM,KAAK,0BAA0B,KAAK;AAAA,IAC3C;AAAA,EACD;AAAA,EAEA,MAAc,iBACb,MACA,IACA,MACA,WACgB;AAChB,UAAM,eAAe,KAAK,WAAW,IAAI;AACzC,UAAM,aAAa,KAAK,WAAW,EAAE;AAErC,QAAI,sCAAsC;AAC1C,UAAM,sBAAsB,CAAC,EAC5B,KAAK,eAAe,+BAA+B;AAEpD,QAAI,CAAC,qBAAqB;AACzB,4CAAsC;AAAA,QACrC;AAAA,QACA;AAAA,QACA;AAAA,MACD;AAAA,IACD;AAEA,QAAI,qCAAqC;AAGxC,UAAI,SAAS,QAAQ;AACpB,cAAM;AAAA,UACL;AAAA,YACC;AAAA,YACA;AAAA,UACD;AAAA,UACA,4BAA4B;AAAA,QAC7B;AAAA,MACD,WAIS,SAAS,QAAQ;AACzB;AAAA,MACD;AAAA,IACD;AAMA,UAAM,WAAW,MAAM,KAAK,gBAAgB,IAAI;AAChD,QAAI,CAAC,UAAU;AACd,YAAM;AAAA,QACL;AAAA,UACC;AAAA,UACA;AAAA,QACD;AAAA,QACA,4BAA4B;AAAA,MAC7B;AAAA,IACD;AAEA,UAAM,SAAS,MAAM,KAAK,gBAAgB,EAAE;AAC5C,QAAI,CAAC,QAAQ;AACZ;AAAA,IACD;AAEA,QAAI,CAAC,WAAW;AACf,YAAM;AAAA,QACL;AAAA,UACC;AAAA,UACA;AAAA,QACD;AAAA,QACA,4BAA4B;AAAA,MAC7B;AAAA,IACD;AAGA,SACE,SAAS,OAAO,SAAS,UAAU,MACnC,OAAO,OAAO,SAAS,UAAU,GACjC;AACD;AAAA,IACD,OAAO;AACN,YAAM,KAAK,OAAO,IAAI;AAAA,QACrB,WAAW;AAAA,QACX,UAAU;AAAA,QACV,QAAQ;AAAA,MACT,CAAC;AAAA,IACF;AAAA,EACD;AAAA;AAAA;AAAA,EAMA,MAAM,UAAU,MAAW,IAAwB;AAClD,WAAO,KAAK;AAAA,MACX;AAAA,MACA;AAAA,MACA;AAAA,IACD;AAAA,EACD;AAAA,EAEA,MAAc,YACb,MACA,IACA,OACgB;AAChB,UAAM,eAAe,KAAK,WAAW,IAAI;AACzC,UAAM,aAAa,KAAK,WAAW,EAAE;AAErC,UAAM,sBAAsB,CAAC,EAC5B,KAAK,eAAe,+BAA+B;AAEpD,QAAI,QAAQ,cAAc,YAAY,CAAC,mBAAmB,GAAG;AAC5D;AAAA,IACD;AAMA,UAAM,QAAQ,IAAI,gBAAgB;AAElC,QAAI;AACH,YAAM,IAAI,MAAM,KAAK,mBAAmB,IAAI,CAAC;AAC7C,YAAM,IAAI,MAAM,KAAK,mBAAmB,EAAE,CAAC;AAE3C,UAAI,OAAO;AACV,cAAM,SAAS,MAAM,QAAQ,UAAU,GAAG,EAAE,WAAW,KAAK,CAAC;AAAA,MAC9D;AAEA,YAAM,SAAS,SAAS,cAAc,UAAU;AAAA,IACjD,SAAS,OAAO;AACf,UAAI,MAAM,SAAS,YAAY,CAAC,OAAO;AACtC,eAAO,KAAK,YAAY,MAAM,IAAI,IAAI;AAAA,MACvC;AAEA,YAAM,KAAK,0BAA0B,KAAK;AAAA,IAC3C,UAAE;AACD,YAAM,QAAQ;AAAA,IACf;AAAA,EACD;AAAA;AAAA;AAAA,EAMU,uBACT,UACA,cACA,gBACiC;AACjC,WAAO,IAAI;AAAA,MACV,CAAC,YAAY,SAAS,OAAO;AAAA,MAC7B,CAAC,QAAQ,aAAa,GAAG;AAAA,MACzB;AAAA,IACD;AAAA,EACD;AAAA,EAEU,0BACT,UACA,cACA,gBACoC;AACpC,WAAO,IAAI;AAAA,MACV,CAAC,YAAY,SAAS,OAAO;AAAA,MAC7B,CAAC,QAAQ,aAAa,GAAG;AAAA,MACzB;AAAA,IACD;AAAA,EACD;AAAA;AAAA;AAAA,EAMQ,0BACP,OAC0B;AAC1B,QAAI,iBAAiB,yBAAyB;AAC7C,aAAO;AAAA,IACR;AAEA,QAAI,cAA8B;AAClC,QAAI;AACJ,YAAQ,MAAM,MAAM;AAAA,MACnB,KAAK;AACJ,eAAO,4BAA4B;AACnC;AAAA,MACD,KAAK;AACJ,eAAO,4BAA4B;AACnC;AAAA,MACD,KAAK;AACJ,eAAO,4BAA4B;AACnC;AAAA,MACD,KAAK;AACJ,eAAO,4BAA4B;AACnC;AAAA,MACD,KAAK;AAAA,MACL,KAAK;AACJ,eAAO,4BAA4B;AACnC;AAAA,MACD,KAAK;AACJ,sBAAc,GAAG,MAAM,OAAO;AAC9B,eAAO,4BAA4B;AACnC;AAAA,MACD;AACC,eAAO,4BAA4B;AAAA,IACrC;AAEA,WAAO,8BAA8B,aAAa,IAAI;AAAA,EACvD;AAAA,EAEA,MAAc,+BACb,UACA,OACmC;AACnC,QAAI,+BACH,KAAK,0BAA0B,KAAK;AAKrC,QACC,YACA,6BAA6B,SAC5B,4BAA4B,eAC5B;AACD,UAAI;AACH,cAAM,EAAE,KAAK,IAAI,MAAM,eAAe;AAAA,UACrC,KAAK,WAAW,QAAQ;AAAA,QACzB;AACA,YACC,EAEE,KAAK,OAAO,MAGb;AACD,yCACC;AAAA,YACC;AAAA,YACA,4BAA4B;AAAA,UAC7B;AAAA,QACF;AAAA,MACD,SAASA,QAAO;AACf,aAAK,WAAW,MAAMA,MAAK;AAAA,MAC5B;AAAA,IACD;AAEA,WAAO;AAAA,EACR;AAAA;AAGD;",
  "names": ["data", "error"]
}
