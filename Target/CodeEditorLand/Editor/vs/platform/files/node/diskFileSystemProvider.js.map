{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/files/node/diskFileSystemProvider.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Stats, promises } from 'fs';\nimport { Barrier, retry } from '../../../base/common/async.js';\nimport { ResourceMap } from '../../../base/common/map.js';\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { Event } from '../../../base/common/event.js';\nimport { isEqual } from '../../../base/common/extpath.js';\nimport { DisposableStore, IDisposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { basename, dirname, join } from '../../../base/common/path.js';\nimport { isLinux, isWindows } from '../../../base/common/platform.js';\nimport { extUriBiasedIgnorePathCase, joinPath, basename as resourcesBasename, dirname as resourcesDirname } from '../../../base/common/resources.js';\nimport { newWriteableStream, ReadableStreamEvents } from '../../../base/common/stream.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { IDirent, Promises, RimRafMode, SymlinkSupport } from '../../../base/node/pfs.js';\nimport { localize } from '../../../nls.js';\nimport { createFileSystemProviderError, IFileAtomicReadOptions, IFileDeleteOptions, IFileOpenOptions, IFileOverwriteOptions, IFileReadStreamOptions, FileSystemProviderCapabilities, FileSystemProviderError, FileSystemProviderErrorCode, FileType, IFileWriteOptions, IFileSystemProviderWithFileAtomicReadCapability, IFileSystemProviderWithFileCloneCapability, IFileSystemProviderWithFileFolderCopyCapability, IFileSystemProviderWithFileReadStreamCapability, IFileSystemProviderWithFileReadWriteCapability, IFileSystemProviderWithOpenReadWriteCloseCapability, isFileOpenForWriteOptions, IStat, FilePermission, IFileSystemProviderWithFileAtomicWriteCapability, IFileSystemProviderWithFileAtomicDeleteCapability, IFileChange } from '../common/files.js';\nimport { readFileIntoStream } from '../common/io.js';\nimport { AbstractNonRecursiveWatcherClient, AbstractUniversalWatcherClient, ILogMessage } from '../common/watcher.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { AbstractDiskFileSystemProvider, IDiskFileSystemProviderOptions } from '../common/diskFileSystemProvider.js';\nimport { UniversalWatcherClient } from './watcher/watcherClient.js';\nimport { NodeJSWatcherClient } from './watcher/nodejs/nodejsClient.js';\n\nexport class DiskFileSystemProvider extends AbstractDiskFileSystemProvider implements\n\tIFileSystemProviderWithFileReadWriteCapability,\n\tIFileSystemProviderWithOpenReadWriteCloseCapability,\n\tIFileSystemProviderWithFileReadStreamCapability,\n\tIFileSystemProviderWithFileFolderCopyCapability,\n\tIFileSystemProviderWithFileAtomicReadCapability,\n\tIFileSystemProviderWithFileAtomicWriteCapability,\n\tIFileSystemProviderWithFileAtomicDeleteCapability,\n\tIFileSystemProviderWithFileCloneCapability {\n\n\tprivate static TRACE_LOG_RESOURCE_LOCKS = false; // not enabled by default because very spammy\n\n\tconstructor(\n\t\tlogService: ILogService,\n\t\toptions?: IDiskFileSystemProviderOptions\n\t) {\n\t\tsuper(logService, options);\n\t}\n\n\t//#region File Capabilities\n\n\treadonly onDidChangeCapabilities = Event.None;\n\n\tprivate _capabilities: FileSystemProviderCapabilities | undefined;\n\tget capabilities(): FileSystemProviderCapabilities {\n\t\tif (!this._capabilities) {\n\t\t\tthis._capabilities =\n\t\t\t\tFileSystemProviderCapabilities.FileReadWrite |\n\t\t\t\tFileSystemProviderCapabilities.FileOpenReadWriteClose |\n\t\t\t\tFileSystemProviderCapabilities.FileReadStream |\n\t\t\t\tFileSystemProviderCapabilities.FileFolderCopy |\n\t\t\t\tFileSystemProviderCapabilities.FileWriteUnlock |\n\t\t\t\tFileSystemProviderCapabilities.FileAtomicRead |\n\t\t\t\tFileSystemProviderCapabilities.FileAtomicWrite |\n\t\t\t\tFileSystemProviderCapabilities.FileAtomicDelete |\n\t\t\t\tFileSystemProviderCapabilities.FileClone;\n\n\t\t\tif (isLinux) {\n\t\t\t\tthis._capabilities |= FileSystemProviderCapabilities.PathCaseSensitive;\n\t\t\t}\n\t\t}\n\n\t\treturn this._capabilities;\n\t}\n\n\t//#endregion\n\n\t//#region File Metadata Resolving\n\n\tasync stat(resource: URI): Promise<IStat> {\n\t\ttry {\n\t\t\tconst { stat, symbolicLink } = await SymlinkSupport.stat(this.toFilePath(resource)); // cannot use fs.stat() here to support links properly\n\n\t\t\treturn {\n\t\t\t\ttype: this.toType(stat, symbolicLink),\n\t\t\t\tctime: stat.birthtime.getTime(), // intentionally not using ctime here, we want the creation time\n\t\t\t\tmtime: stat.mtime.getTime(),\n\t\t\t\tsize: stat.size,\n\t\t\t\tpermissions: (stat.mode & 0o200) === 0 ? FilePermission.Locked : undefined\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tprivate async statIgnoreError(resource: URI): Promise<IStat | undefined> {\n\t\ttry {\n\t\t\treturn await this.stat(resource);\n\t\t} catch (error) {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tasync readdir(resource: URI): Promise<[string, FileType][]> {\n\t\ttry {\n\t\t\tconst children = await Promises.readdir(this.toFilePath(resource), { withFileTypes: true });\n\n\t\t\tconst result: [string, FileType][] = [];\n\t\t\tawait Promise.all(children.map(async child => {\n\t\t\t\ttry {\n\t\t\t\t\tlet type: FileType;\n\t\t\t\t\tif (child.isSymbolicLink()) {\n\t\t\t\t\t\ttype = (await this.stat(joinPath(resource, child.name))).type; // always resolve target the link points to if any\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttype = this.toType(child);\n\t\t\t\t\t}\n\n\t\t\t\t\tresult.push([child.name, type]);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.logService.trace(error); // ignore errors for individual entries that can arise from permission denied\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tprivate toType(entry: Stats | IDirent, symbolicLink?: { dangling: boolean }): FileType {\n\n\t\t// Signal file type by checking for file / directory, except:\n\t\t// - symbolic links pointing to nonexistent files are FileType.Unknown\n\t\t// - files that are neither file nor directory are FileType.Unknown\n\t\tlet type: FileType;\n\t\tif (symbolicLink?.dangling) {\n\t\t\ttype = FileType.Unknown;\n\t\t} else if (entry.isFile()) {\n\t\t\ttype = FileType.File;\n\t\t} else if (entry.isDirectory()) {\n\t\t\ttype = FileType.Directory;\n\t\t} else {\n\t\t\ttype = FileType.Unknown;\n\t\t}\n\n\t\t// Always signal symbolic link as file type additionally\n\t\tif (symbolicLink) {\n\t\t\ttype |= FileType.SymbolicLink;\n\t\t}\n\n\t\treturn type;\n\t}\n\n\t//#endregion\n\n\t//#region File Reading/Writing\n\n\tprivate readonly resourceLocks = new ResourceMap<Barrier>(resource => extUriBiasedIgnorePathCase.getComparisonKey(resource));\n\n\tprivate async createResourceLock(resource: URI): Promise<IDisposable> {\n\t\tconst filePath = this.toFilePath(resource);\n\t\tthis.traceLock(`[Disk FileSystemProvider]: createResourceLock() - request to acquire resource lock (${filePath})`);\n\n\t\t// Await pending locks for resource. It is possible for a new lock being\n\t\t// added right after opening, so we have to loop over locks until no lock\n\t\t// remains.\n\t\tlet existingLock: Barrier | undefined = undefined;\n\t\twhile (existingLock = this.resourceLocks.get(resource)) {\n\t\t\tthis.traceLock(`[Disk FileSystemProvider]: createResourceLock() - waiting for resource lock to be released (${filePath})`);\n\t\t\tawait existingLock.wait();\n\t\t}\n\n\t\t// Store new\n\t\tconst newLock = new Barrier();\n\t\tthis.resourceLocks.set(resource, newLock);\n\n\t\tthis.traceLock(`[Disk FileSystemProvider]: createResourceLock() - new resource lock created (${filePath})`);\n\n\t\treturn toDisposable(() => {\n\t\t\tthis.traceLock(`[Disk FileSystemProvider]: createResourceLock() - resource lock dispose() (${filePath})`);\n\n\t\t\t// Delete lock if it is still ours\n\t\t\tif (this.resourceLocks.get(resource) === newLock) {\n\t\t\t\tthis.traceLock(`[Disk FileSystemProvider]: createResourceLock() - resource lock removed from resource-lock map (${filePath})`);\n\t\t\t\tthis.resourceLocks.delete(resource);\n\t\t\t}\n\n\t\t\t// Open lock\n\t\t\tthis.traceLock(`[Disk FileSystemProvider]: createResourceLock() - resource lock barrier open() (${filePath})`);\n\t\t\tnewLock.open();\n\t\t});\n\t}\n\n\tasync readFile(resource: URI, options?: IFileAtomicReadOptions): Promise<Uint8Array> {\n\t\tlet lock: IDisposable | undefined = undefined;\n\t\ttry {\n\t\t\tif (options?.atomic) {\n\t\t\t\tthis.traceLock(`[Disk FileSystemProvider]: atomic read operation started (${this.toFilePath(resource)})`);\n\n\t\t\t\t// When the read should be atomic, make sure\n\t\t\t\t// to await any pending locks for the resource\n\t\t\t\t// and lock for the duration of the read.\n\t\t\t\tlock = await this.createResourceLock(resource);\n\t\t\t}\n\n\t\t\tconst filePath = this.toFilePath(resource);\n\n\t\t\treturn await promises.readFile(filePath);\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t} finally {\n\t\t\tlock?.dispose();\n\t\t}\n\t}\n\n\tprivate traceLock(msg: string): void {\n\t\tif (DiskFileSystemProvider.TRACE_LOG_RESOURCE_LOCKS) {\n\t\t\tthis.logService.trace(msg);\n\t\t}\n\t}\n\n\treadFileStream(resource: URI, opts: IFileReadStreamOptions, token: CancellationToken): ReadableStreamEvents<Uint8Array> {\n\t\tconst stream = newWriteableStream<Uint8Array>(data => VSBuffer.concat(data.map(data => VSBuffer.wrap(data))).buffer);\n\n\t\treadFileIntoStream(this, resource, stream, data => data.buffer, {\n\t\t\t...opts,\n\t\t\tbufferSize: 256 * 1024 // read into chunks of 256kb each to reduce IPC overhead\n\t\t}, token);\n\n\t\treturn stream;\n\t}\n\n\tasync writeFile(resource: URI, content: Uint8Array, opts: IFileWriteOptions): Promise<void> {\n\t\tif (opts?.atomic !== false && opts?.atomic?.postfix && await this.canWriteFileAtomic(resource)) {\n\t\t\treturn this.doWriteFileAtomic(resource, joinPath(resourcesDirname(resource), `${resourcesBasename(resource)}${opts.atomic.postfix}`), content, opts);\n\t\t} else {\n\t\t\treturn this.doWriteFile(resource, content, opts);\n\t\t}\n\t}\n\n\tprivate async canWriteFileAtomic(resource: URI): Promise<boolean> {\n\t\ttry {\n\t\t\tconst filePath = this.toFilePath(resource);\n\t\t\tconst { symbolicLink } = await SymlinkSupport.stat(filePath);\n\t\t\tif (symbolicLink) {\n\t\t\t\t// atomic writes are unsupported for symbolic links because\n\t\t\t\t// we need to ensure that the `rename` operation is atomic\n\t\t\t\t// and that only works if the link is on the same disk.\n\t\t\t\t// Since we do not know where the symbolic link points to\n\t\t\t\t// we refuse to write atomically.\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// ignore stat errors here and just proceed trying to write\n\t\t}\n\n\t\treturn true; // atomic writing supported\n\t}\n\n\tprivate async doWriteFileAtomic(resource: URI, tempResource: URI, content: Uint8Array, opts: IFileWriteOptions): Promise<void> {\n\n\t\t// Ensure to create locks for all resources involved\n\t\t// since atomic write involves mutiple disk operations\n\t\t// and resources.\n\n\t\tconst locks = new DisposableStore();\n\n\t\ttry {\n\t\t\tlocks.add(await this.createResourceLock(resource));\n\t\t\tlocks.add(await this.createResourceLock(tempResource));\n\n\t\t\t// Write to temp resource first\n\t\t\tawait this.doWriteFile(tempResource, content, opts, true /* disable write lock */);\n\n\t\t\ttry {\n\n\t\t\t\t// Rename over existing to ensure atomic replace\n\t\t\t\tawait this.rename(tempResource, resource, { overwrite: true });\n\n\t\t\t} catch (error) {\n\n\t\t\t\t// Cleanup in case of rename error\n\t\t\t\ttry {\n\t\t\t\t\tawait this.delete(tempResource, { recursive: false, useTrash: false, atomic: false });\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// ignore - we want the outer error to bubble up\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t} finally {\n\t\t\tlocks.dispose();\n\t\t}\n\t}\n\n\tprivate async doWriteFile(resource: URI, content: Uint8Array, opts: IFileWriteOptions, disableWriteLock?: boolean): Promise<void> {\n\t\tlet handle: number | undefined = undefined;\n\t\ttry {\n\t\t\tconst filePath = this.toFilePath(resource);\n\n\t\t\t// Validate target unless { create: true, overwrite: true }\n\t\t\tif (!opts.create || !opts.overwrite) {\n\t\t\t\tconst fileExists = await Promises.exists(filePath);\n\t\t\t\tif (fileExists) {\n\t\t\t\t\tif (!opts.overwrite) {\n\t\t\t\t\t\tthrow createFileSystemProviderError(localize('fileExists', \"File already exists\"), FileSystemProviderErrorCode.FileExists);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!opts.create) {\n\t\t\t\t\t\tthrow createFileSystemProviderError(localize('fileNotExists', \"File does not exist\"), FileSystemProviderErrorCode.FileNotFound);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Open\n\t\t\thandle = await this.open(resource, { create: true, unlock: opts.unlock }, disableWriteLock);\n\n\t\t\t// Write content at once\n\t\t\tawait this.write(handle, 0, content, 0, content.byteLength);\n\t\t} catch (error) {\n\t\t\tthrow await this.toFileSystemProviderWriteError(resource, error);\n\t\t} finally {\n\t\t\tif (typeof handle === 'number') {\n\t\t\t\tawait this.close(handle);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate readonly mapHandleToPos = new Map<number, number>();\n\tprivate readonly mapHandleToLock = new Map<number, IDisposable>();\n\n\tprivate readonly writeHandles = new Map<number, URI>();\n\n\tprivate static canFlush: boolean = true;\n\n\tstatic configureFlushOnWrite(enabled: boolean): void {\n\t\tDiskFileSystemProvider.canFlush = enabled;\n\t}\n\n\tasync open(resource: URI, opts: IFileOpenOptions, disableWriteLock?: boolean): Promise<number> {\n\t\tconst filePath = this.toFilePath(resource);\n\n\t\t// Writes: guard multiple writes to the same resource\n\t\t// behind a single lock to prevent races when writing\n\t\t// from multiple places at the same time to the same file\n\t\tlet lock: IDisposable | undefined = undefined;\n\t\tif (isFileOpenForWriteOptions(opts) && !disableWriteLock) {\n\t\t\tlock = await this.createResourceLock(resource);\n\t\t}\n\n\t\tlet fd: number | undefined = undefined;\n\t\ttry {\n\n\t\t\t// Determine whether to unlock the file (write only)\n\t\t\tif (isFileOpenForWriteOptions(opts) && opts.unlock) {\n\t\t\t\ttry {\n\t\t\t\t\tconst { stat } = await SymlinkSupport.stat(filePath);\n\t\t\t\t\tif (!(stat.mode & 0o200 /* File mode indicating writable by owner */)) {\n\t\t\t\t\t\tawait promises.chmod(filePath, stat.mode | 0o200);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (error.code !== 'ENOENT') {\n\t\t\t\t\t\tthis.logService.trace(error); // ignore any errors here and try to just write\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Determine file flags for opening (read vs write)\n\t\t\tlet flags: string | undefined = undefined;\n\t\t\tif (isFileOpenForWriteOptions(opts)) {\n\t\t\t\tif (isWindows) {\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\t// On Windows and if the file exists, we use a different strategy of saving the file\n\t\t\t\t\t\t// by first truncating the file and then writing with r+ flag. This helps to save hidden files on Windows\n\t\t\t\t\t\t// (see https://github.com/microsoft/vscode/issues/931) and prevent removing alternate data streams\n\t\t\t\t\t\t// (see https://github.com/microsoft/vscode/issues/6363)\n\t\t\t\t\t\tawait promises.truncate(filePath, 0);\n\n\t\t\t\t\t\t// After a successful truncate() the flag can be set to 'r+' which will not truncate.\n\t\t\t\t\t\tflags = 'r+';\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tif (error.code !== 'ENOENT') {\n\t\t\t\t\t\t\tthis.logService.trace(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// We take opts.create as a hint that the file is opened for writing\n\t\t\t\t// as such we use 'w' to truncate an existing or create the\n\t\t\t\t// file otherwise. we do not allow reading.\n\t\t\t\tif (!flags) {\n\t\t\t\t\tflags = 'w';\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// Otherwise we assume the file is opened for reading\n\t\t\t\t// as such we use 'r' to neither truncate, nor create\n\t\t\t\t// the file.\n\t\t\t\tflags = 'r';\n\t\t\t}\n\n\t\t\t// Finally open handle to file path\n\t\t\tfd = await Promises.open(filePath, flags);\n\n\t\t} catch (error) {\n\n\t\t\t// Release lock because we have no valid handle\n\t\t\t// if we did open a lock during this operation\n\t\t\tlock?.dispose();\n\n\t\t\t// Rethrow as file system provider error\n\t\t\tif (isFileOpenForWriteOptions(opts)) {\n\t\t\t\tthrow await this.toFileSystemProviderWriteError(resource, error);\n\t\t\t} else {\n\t\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t\t}\n\t\t}\n\n\t\t// Remember this handle to track file position of the handle\n\t\t// we init the position to 0 since the file descriptor was\n\t\t// just created and the position was not moved so far (see\n\t\t// also http://man7.org/linux/man-pages/man2/open.2.html -\n\t\t// \"The file offset is set to the beginning of the file.\")\n\t\tthis.mapHandleToPos.set(fd, 0);\n\n\t\t// remember that this handle was used for writing\n\t\tif (isFileOpenForWriteOptions(opts)) {\n\t\t\tthis.writeHandles.set(fd, resource);\n\t\t}\n\n\t\tif (lock) {\n\t\t\tconst previousLock = this.mapHandleToLock.get(fd);\n\n\t\t\t// Remember that this handle has an associated lock\n\t\t\tthis.traceLock(`[Disk FileSystemProvider]: open() - storing lock for handle ${fd} (${filePath})`);\n\t\t\tthis.mapHandleToLock.set(fd, lock);\n\n\t\t\t// There is a slight chance that a resource lock for a\n\t\t\t// handle was not yet disposed when we acquire a new\n\t\t\t// lock, so we must ensure to dispose the previous lock\n\t\t\t// before storing a new one for the same handle, other\n\t\t\t// wise we end up in a deadlock situation\n\t\t\t// https://github.com/microsoft/vscode/issues/142462\n\t\t\tif (previousLock) {\n\t\t\t\tthis.traceLock(`[Disk FileSystemProvider]: open() - disposing a previous lock that was still stored on same handle ${fd} (${filePath})`);\n\t\t\t\tpreviousLock.dispose();\n\t\t\t}\n\t\t}\n\n\t\treturn fd;\n\t}\n\n\tasync close(fd: number): Promise<void> {\n\n\t\t// It is very important that we keep any associated lock\n\t\t// for the file handle before attempting to call `fs.close(fd)`\n\t\t// because of a possible race condition: as soon as a file\n\t\t// handle is released, the OS may assign the same handle to\n\t\t// the next `fs.open` call and as such it is possible that our\n\t\t// lock is getting overwritten\n\t\tconst lockForHandle = this.mapHandleToLock.get(fd);\n\n\t\ttry {\n\n\t\t\t// Remove this handle from map of positions\n\t\t\tthis.mapHandleToPos.delete(fd);\n\n\t\t\t// If a handle is closed that was used for writing, ensure\n\t\t\t// to flush the contents to disk if possible.\n\t\t\tif (this.writeHandles.delete(fd) && DiskFileSystemProvider.canFlush) {\n\t\t\t\ttry {\n\t\t\t\t\tawait Promises.fdatasync(fd); // https://github.com/microsoft/vscode/issues/9589\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// In some exotic setups it is well possible that node fails to sync\n\t\t\t\t\t// In that case we disable flushing and log the error to our logger\n\t\t\t\t\tDiskFileSystemProvider.configureFlushOnWrite(false);\n\t\t\t\t\tthis.logService.error(error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn await Promises.close(fd);\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t} finally {\n\t\t\tif (lockForHandle) {\n\t\t\t\tif (this.mapHandleToLock.get(fd) === lockForHandle) {\n\t\t\t\t\tthis.traceLock(`[Disk FileSystemProvider]: close() - resource lock removed from handle-lock map ${fd}`);\n\t\t\t\t\tthis.mapHandleToLock.delete(fd); // only delete from map if this is still our lock!\n\t\t\t\t}\n\n\t\t\t\tthis.traceLock(`[Disk FileSystemProvider]: close() - disposing lock for handle ${fd}`);\n\t\t\t\tlockForHandle.dispose();\n\t\t\t}\n\t\t}\n\t}\n\n\tasync read(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number> {\n\t\tconst normalizedPos = this.normalizePos(fd, pos);\n\n\t\tlet bytesRead: number | null = null;\n\t\ttry {\n\t\t\tbytesRead = (await Promises.read(fd, data, offset, length, normalizedPos)).bytesRead;\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t} finally {\n\t\t\tthis.updatePos(fd, normalizedPos, bytesRead);\n\t\t}\n\n\t\treturn bytesRead;\n\t}\n\n\tprivate normalizePos(fd: number, pos: number): number | null {\n\n\t\t// When calling fs.read/write we try to avoid passing in the \"pos\" argument and\n\t\t// rather prefer to pass in \"null\" because this avoids an extra seek(pos)\n\t\t// call that in some cases can even fail (e.g. when opening a file over FTP -\n\t\t// see https://github.com/microsoft/vscode/issues/73884).\n\t\t//\n\t\t// as such, we compare the passed in position argument with our last known\n\t\t// position for the file descriptor and use \"null\" if they match.\n\t\tif (pos === this.mapHandleToPos.get(fd)) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn pos;\n\t}\n\n\tprivate updatePos(fd: number, pos: number | null, bytesLength: number | null): void {\n\t\tconst lastKnownPos = this.mapHandleToPos.get(fd);\n\t\tif (typeof lastKnownPos === 'number') {\n\n\t\t\t// pos !== null signals that previously a position was used that is\n\t\t\t// not null. node.js documentation explains, that in this case\n\t\t\t// the internal file pointer is not moving and as such we do not move\n\t\t\t// our position pointer.\n\t\t\t//\n\t\t\t// Docs: \"If position is null, data will be read from the current file position,\n\t\t\t// and the file position will be updated. If position is an integer, the file position\n\t\t\t// will remain unchanged.\"\n\t\t\tif (typeof pos === 'number') {\n\t\t\t\t// do not modify the position\n\t\t\t}\n\n\t\t\t// bytesLength = number is a signal that the read/write operation was\n\t\t\t// successful and as such we need to advance the position in the Map\n\t\t\t//\n\t\t\t// Docs (http://man7.org/linux/man-pages/man2/read.2.html):\n\t\t\t// \"On files that support seeking, the read operation commences at the\n\t\t\t// file offset, and the file offset is incremented by the number of\n\t\t\t// bytes read.\"\n\t\t\t//\n\t\t\t// Docs (http://man7.org/linux/man-pages/man2/write.2.html):\n\t\t\t// \"For a seekable file (i.e., one to which lseek(2) may be applied, for\n\t\t\t// example, a regular file) writing takes place at the file offset, and\n\t\t\t// the file offset is incremented by the number of bytes actually\n\t\t\t// written.\"\n\t\t\telse if (typeof bytesLength === 'number') {\n\t\t\t\tthis.mapHandleToPos.set(fd, lastKnownPos + bytesLength);\n\t\t\t}\n\n\t\t\t// bytesLength = null signals an error in the read/write operation\n\t\t\t// and as such we drop the handle from the Map because the position\n\t\t\t// is unspecificed at this point.\n\t\t\telse {\n\t\t\t\tthis.mapHandleToPos.delete(fd);\n\t\t\t}\n\t\t}\n\t}\n\n\tasync write(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number> {\n\n\t\t// We know at this point that the file to write to is truncated and thus empty\n\t\t// if the write now fails, the file remains empty. as such we really try hard\n\t\t// to ensure the write succeeds by retrying up to three times.\n\t\treturn retry(() => this.doWrite(fd, pos, data, offset, length), 100 /* ms delay */, 3 /* retries */);\n\t}\n\n\tprivate async doWrite(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number> {\n\t\tconst normalizedPos = this.normalizePos(fd, pos);\n\n\t\tlet bytesWritten: number | null = null;\n\t\ttry {\n\t\t\tbytesWritten = (await Promises.write(fd, data, offset, length, normalizedPos)).bytesWritten;\n\t\t} catch (error) {\n\t\t\tthrow await this.toFileSystemProviderWriteError(this.writeHandles.get(fd), error);\n\t\t} finally {\n\t\t\tthis.updatePos(fd, normalizedPos, bytesWritten);\n\t\t}\n\n\t\treturn bytesWritten;\n\t}\n\n\t//#endregion\n\n\t//#region Move/Copy/Delete/Create Folder\n\n\tasync mkdir(resource: URI): Promise<void> {\n\t\ttry {\n\t\t\tawait promises.mkdir(this.toFilePath(resource));\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tasync delete(resource: URI, opts: IFileDeleteOptions): Promise<void> {\n\t\ttry {\n\t\t\tconst filePath = this.toFilePath(resource);\n\t\t\tif (opts.recursive) {\n\t\t\t\tlet rmMoveToPath: string | undefined = undefined;\n\t\t\t\tif (opts?.atomic !== false && opts.atomic.postfix) {\n\t\t\t\t\trmMoveToPath = join(dirname(filePath), `${basename(filePath)}${opts.atomic.postfix}`);\n\t\t\t\t}\n\n\t\t\t\tawait Promises.rm(filePath, RimRafMode.MOVE, rmMoveToPath);\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tawait promises.unlink(filePath);\n\t\t\t\t} catch (unlinkError) {\n\n\t\t\t\t\t// `fs.unlink` will throw when used on directories\n\t\t\t\t\t// we try to detect this error and then see if the\n\t\t\t\t\t// provided resource is actually a directory. in that\n\t\t\t\t\t// case we use `fs.rmdir` to delete the directory.\n\n\t\t\t\t\tif (unlinkError.code === 'EPERM' || unlinkError.code === 'EISDIR') {\n\t\t\t\t\t\tlet isDirectory = false;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst { stat, symbolicLink } = await SymlinkSupport.stat(filePath);\n\t\t\t\t\t\t\tisDirectory = stat.isDirectory() && !symbolicLink;\n\t\t\t\t\t\t} catch (statError) {\n\t\t\t\t\t\t\t// ignore\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (isDirectory) {\n\t\t\t\t\t\t\tawait promises.rmdir(filePath);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow unlinkError;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow unlinkError;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tasync rename(from: URI, to: URI, opts: IFileOverwriteOptions): Promise<void> {\n\t\tconst fromFilePath = this.toFilePath(from);\n\t\tconst toFilePath = this.toFilePath(to);\n\n\t\tif (fromFilePath === toFilePath) {\n\t\t\treturn; // simulate node.js behaviour here and do a no-op if paths match\n\t\t}\n\n\t\ttry {\n\n\t\t\t// Validate the move operation can perform\n\t\t\tawait this.validateMoveCopy(from, to, 'move', opts.overwrite);\n\n\t\t\t// Rename\n\t\t\tawait Promises.rename(fromFilePath, toFilePath);\n\t\t} catch (error) {\n\n\t\t\t// Rewrite some typical errors that can happen especially around symlinks\n\t\t\t// to something the user can better understand\n\t\t\tif (error.code === 'EINVAL' || error.code === 'EBUSY' || error.code === 'ENAMETOOLONG') {\n\t\t\t\terror = new Error(localize('moveError', \"Unable to move '{0}' into '{1}' ({2}).\", basename(fromFilePath), basename(dirname(toFilePath)), error.toString()));\n\t\t\t}\n\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tasync copy(from: URI, to: URI, opts: IFileOverwriteOptions): Promise<void> {\n\t\tconst fromFilePath = this.toFilePath(from);\n\t\tconst toFilePath = this.toFilePath(to);\n\n\t\tif (fromFilePath === toFilePath) {\n\t\t\treturn; // simulate node.js behaviour here and do a no-op if paths match\n\t\t}\n\n\t\ttry {\n\n\t\t\t// Validate the copy operation can perform\n\t\t\tawait this.validateMoveCopy(from, to, 'copy', opts.overwrite);\n\n\t\t\t// Copy\n\t\t\tawait Promises.copy(fromFilePath, toFilePath, { preserveSymlinks: true });\n\t\t} catch (error) {\n\n\t\t\t// Rewrite some typical errors that can happen especially around symlinks\n\t\t\t// to something the user can better understand\n\t\t\tif (error.code === 'EINVAL' || error.code === 'EBUSY' || error.code === 'ENAMETOOLONG') {\n\t\t\t\terror = new Error(localize('copyError', \"Unable to copy '{0}' into '{1}' ({2}).\", basename(fromFilePath), basename(dirname(toFilePath)), error.toString()));\n\t\t\t}\n\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tprivate async validateMoveCopy(from: URI, to: URI, mode: 'move' | 'copy', overwrite?: boolean): Promise<void> {\n\t\tconst fromFilePath = this.toFilePath(from);\n\t\tconst toFilePath = this.toFilePath(to);\n\n\t\tlet isSameResourceWithDifferentPathCase = false;\n\t\tconst isPathCaseSensitive = !!(this.capabilities & FileSystemProviderCapabilities.PathCaseSensitive);\n\t\tif (!isPathCaseSensitive) {\n\t\t\tisSameResourceWithDifferentPathCase = isEqual(fromFilePath, toFilePath, true /* ignore case */);\n\t\t}\n\n\t\tif (isSameResourceWithDifferentPathCase) {\n\n\t\t\t// You cannot copy the same file to the same location with different\n\t\t\t// path case unless you are on a case sensitive file system\n\t\t\tif (mode === 'copy') {\n\t\t\t\tthrow createFileSystemProviderError(localize('fileCopyErrorPathCase', \"File cannot be copied to same path with different path case\"), FileSystemProviderErrorCode.FileExists);\n\t\t\t}\n\n\t\t\t// You can move the same file to the same location with different\n\t\t\t// path case on case insensitive file systems\n\t\t\telse if (mode === 'move') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Here we have to see if the target to move/copy to exists or not.\n\t\t// We need to respect the `overwrite` option to throw in case the\n\t\t// target exists.\n\n\t\tconst fromStat = await this.statIgnoreError(from);\n\t\tif (!fromStat) {\n\t\t\tthrow createFileSystemProviderError(localize('fileMoveCopyErrorNotFound', \"File to move/copy does not exist\"), FileSystemProviderErrorCode.FileNotFound);\n\t\t}\n\n\t\tconst toStat = await this.statIgnoreError(to);\n\t\tif (!toStat) {\n\t\t\treturn; // target does not exist so we are good\n\t\t}\n\n\t\tif (!overwrite) {\n\t\t\tthrow createFileSystemProviderError(localize('fileMoveCopyErrorExists', \"File at target already exists and thus will not be moved/copied to unless overwrite is specified\"), FileSystemProviderErrorCode.FileExists);\n\t\t}\n\n\t\t// Handle existing target for move/copy\n\t\tif ((fromStat.type & FileType.File) !== 0 && (toStat.type & FileType.File) !== 0) {\n\t\t\treturn; // node.js can move/copy a file over an existing file without having to delete it first\n\t\t} else {\n\t\t\tawait this.delete(to, { recursive: true, useTrash: false, atomic: false });\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region Clone File\n\n\tasync cloneFile(from: URI, to: URI): Promise<void> {\n\t\treturn this.doCloneFile(from, to, false /* optimistically assume parent folders exist */);\n\t}\n\n\tprivate async doCloneFile(from: URI, to: URI, mkdir: boolean): Promise<void> {\n\t\tconst fromFilePath = this.toFilePath(from);\n\t\tconst toFilePath = this.toFilePath(to);\n\n\t\tconst isPathCaseSensitive = !!(this.capabilities & FileSystemProviderCapabilities.PathCaseSensitive);\n\t\tif (isEqual(fromFilePath, toFilePath, !isPathCaseSensitive)) {\n\t\t\treturn; // cloning is only supported `from` and `to` are different files\n\t\t}\n\n\t\t// Implement clone by using `fs.copyFile`, however setup locks\n\t\t// for both `from` and `to` because node.js does not ensure\n\t\t// this to be an atomic operation\n\n\t\tconst locks = new DisposableStore();\n\n\t\ttry {\n\t\t\tlocks.add(await this.createResourceLock(from));\n\t\t\tlocks.add(await this.createResourceLock(to));\n\n\t\t\tif (mkdir) {\n\t\t\t\tawait promises.mkdir(dirname(toFilePath), { recursive: true });\n\t\t\t}\n\n\t\t\tawait promises.copyFile(fromFilePath, toFilePath);\n\t\t} catch (error) {\n\t\t\tif (error.code === 'ENOENT' && !mkdir) {\n\t\t\t\treturn this.doCloneFile(from, to, true);\n\t\t\t}\n\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t} finally {\n\t\t\tlocks.dispose();\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region File Watching\n\n\tprotected createUniversalWatcher(\n\t\tonChange: (changes: IFileChange[]) => void,\n\t\tonLogMessage: (msg: ILogMessage) => void,\n\t\tverboseLogging: boolean\n\t): AbstractUniversalWatcherClient {\n\t\treturn new UniversalWatcherClient(changes => onChange(changes), msg => onLogMessage(msg), verboseLogging);\n\t}\n\n\tprotected createNonRecursiveWatcher(\n\t\tonChange: (changes: IFileChange[]) => void,\n\t\tonLogMessage: (msg: ILogMessage) => void,\n\t\tverboseLogging: boolean\n\t): AbstractNonRecursiveWatcherClient {\n\t\treturn new NodeJSWatcherClient(changes => onChange(changes), msg => onLogMessage(msg), verboseLogging);\n\t}\n\n\t//#endregion\n\n\t//#region Helpers\n\n\tprivate toFileSystemProviderError(error: NodeJS.ErrnoException): FileSystemProviderError {\n\t\tif (error instanceof FileSystemProviderError) {\n\t\t\treturn error; // avoid double conversion\n\t\t}\n\n\t\tlet resultError: Error | string = error;\n\t\tlet code: FileSystemProviderErrorCode;\n\t\tswitch (error.code) {\n\t\t\tcase 'ENOENT':\n\t\t\t\tcode = FileSystemProviderErrorCode.FileNotFound;\n\t\t\t\tbreak;\n\t\t\tcase 'EISDIR':\n\t\t\t\tcode = FileSystemProviderErrorCode.FileIsADirectory;\n\t\t\t\tbreak;\n\t\t\tcase 'ENOTDIR':\n\t\t\t\tcode = FileSystemProviderErrorCode.FileNotADirectory;\n\t\t\t\tbreak;\n\t\t\tcase 'EEXIST':\n\t\t\t\tcode = FileSystemProviderErrorCode.FileExists;\n\t\t\t\tbreak;\n\t\t\tcase 'EPERM':\n\t\t\tcase 'EACCES':\n\t\t\t\tcode = FileSystemProviderErrorCode.NoPermissions;\n\t\t\t\tbreak;\n\t\t\tcase 'ERR_UNC_HOST_NOT_ALLOWED':\n\t\t\t\tresultError = `${error.message}. Please update the 'security.allowedUNCHosts' setting if you want to allow this host.`;\n\t\t\t\tcode = FileSystemProviderErrorCode.Unknown;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcode = FileSystemProviderErrorCode.Unknown;\n\t\t}\n\n\t\treturn createFileSystemProviderError(resultError, code);\n\t}\n\n\tprivate async toFileSystemProviderWriteError(resource: URI | undefined, error: NodeJS.ErrnoException): Promise<FileSystemProviderError> {\n\t\tlet fileSystemProviderWriteError = this.toFileSystemProviderError(error);\n\n\t\t// If the write error signals permission issues, we try\n\t\t// to read the file's mode to see if the file is write\n\t\t// locked.\n\t\tif (resource && fileSystemProviderWriteError.code === FileSystemProviderErrorCode.NoPermissions) {\n\t\t\ttry {\n\t\t\t\tconst { stat } = await SymlinkSupport.stat(this.toFilePath(resource));\n\t\t\t\tif (!(stat.mode & 0o200 /* File mode indicating writable by owner */)) {\n\t\t\t\t\tfileSystemProviderWriteError = createFileSystemProviderError(error, FileSystemProviderErrorCode.FileWriteLocked);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.trace(error); // ignore - return original error\n\t\t\t}\n\t\t}\n\n\t\treturn fileSystemProviderWriteError;\n\t}\n\n\t//#endregion\n}\n"],
  "mappings": ";;AAKA,SAAS,OAAO,gBAAgB;AAChC,SAAS,SAAS,aAAa;AAC/B,SAAS,mBAAmB;AAC5B,SAAS,gBAAgB;AACzB,SAAS,yBAAyB;AAClC,SAAS,aAAa;AACtB,SAAS,eAAe;AACxB,SAAS,iBAAiB,aAAa,oBAAoB;AAC3D,SAAS,UAAU,SAAS,YAAY;AACxC,SAAS,SAAS,iBAAiB;AACnC,SAAS,4BAA4B,UAAU,YAAY,mBAAmB,WAAW,wBAAwB;AACjH,SAAS,oBAAoB,4BAA4B;AACzD,SAAS,WAAW;AACpB,SAAS,SAAS,UAAU,YAAY,sBAAsB;AAC9D,SAAS,gBAAgB;AACzB,SAAS,+BAA+B,wBAAwB,oBAAoB,kBAAkB,uBAAuB,wBAAwB,gCAAgC,yBAAyB,6BAA6B,UAAU,mBAAmB,iDAAiD,4CAA4C,iDAAiD,iDAAiD,gDAAgD,qDAAqD,2BAA2B,OAAO,gBAAgB,kDAAkD,mDAAmD,mBAAmB;AACttB,SAAS,0BAA0B;AACnC,SAAS,mCAAmC,gCAAgC,mBAAmB;AAC/F,SAAS,mBAAmB;AAC5B,SAAS,gCAAgC,sCAAsC;AAC/E,SAAS,8BAA8B;AACvC,SAAS,2BAA2B;AAE7B,MAAM,+BAA+B,+BAQA;AAAA,EApC5C,OAoC4C;AAAA;AAAA;AAAA,EAE3C,OAAe,2BAA2B;AAAA;AAAA,EAE1C,YACC,YACA,SACC;AACD,UAAM,YAAY,OAAO;AAAA,EAC1B;AAAA;AAAA,EAIS,0BAA0B,MAAM;AAAA,EAEjC;AAAA,EACR,IAAI,eAA+C;AAClD,QAAI,CAAC,KAAK,eAAe;AACxB,WAAK,gBACJ,+BAA+B,gBAC/B,+BAA+B,yBAC/B,+BAA+B,iBAC/B,+BAA+B,iBAC/B,+BAA+B,kBAC/B,+BAA+B,iBAC/B,+BAA+B,kBAC/B,+BAA+B,mBAC/B,+BAA+B;AAEhC,UAAI,SAAS;AACZ,aAAK,iBAAiB,+BAA+B;AAAA,MACtD;AAAA,IACD;AAEA,WAAO,KAAK;AAAA,EACb;AAAA;AAAA;AAAA,EAMA,MAAM,KAAK,UAA+B;AACzC,QAAI;AACH,YAAM,EAAE,MAAM,aAAa,IAAI,MAAM,eAAe,KAAK,KAAK,WAAW,QAAQ,CAAC;AAElF,aAAO;AAAA,QACN,MAAM,KAAK,OAAO,MAAM,YAAY;AAAA,QACpC,OAAO,KAAK,UAAU,QAAQ;AAAA;AAAA,QAC9B,OAAO,KAAK,MAAM,QAAQ;AAAA,QAC1B,MAAM,KAAK;AAAA,QACX,cAAc,KAAK,OAAO,SAAW,IAAI,eAAe,SAAS;AAAA,MAClE;AAAA,IACD,SAAS,OAAO;AACf,YAAM,KAAK,0BAA0B,KAAK;AAAA,IAC3C;AAAA,EACD;AAAA,EAEA,MAAc,gBAAgB,UAA2C;AACxE,QAAI;AACH,aAAO,MAAM,KAAK,KAAK,QAAQ;AAAA,IAChC,SAAS,OAAO;AACf,aAAO;AAAA,IACR;AAAA,EACD;AAAA,EAEA,MAAM,QAAQ,UAA8C;AAC3D,QAAI;AACH,YAAM,WAAW,MAAM,SAAS,QAAQ,KAAK,WAAW,QAAQ,GAAG,EAAE,eAAe,KAAK,CAAC;AAE1F,YAAM,SAA+B,CAAC;AACtC,YAAM,QAAQ,IAAI,SAAS,IAAI,OAAM,UAAS;AAC7C,YAAI;AACH,cAAI;AACJ,cAAI,MAAM,eAAe,GAAG;AAC3B,oBAAQ,MAAM,KAAK,KAAK,SAAS,UAAU,MAAM,IAAI,CAAC,GAAG;AAAA,UAC1D,OAAO;AACN,mBAAO,KAAK,OAAO,KAAK;AAAA,UACzB;AAEA,iBAAO,KAAK,CAAC,MAAM,MAAM,IAAI,CAAC;AAAA,QAC/B,SAAS,OAAO;AACf,eAAK,WAAW,MAAM,KAAK;AAAA,QAC5B;AAAA,MACD,CAAC,CAAC;AAEF,aAAO;AAAA,IACR,SAAS,OAAO;AACf,YAAM,KAAK,0BAA0B,KAAK;AAAA,IAC3C;AAAA,EACD;AAAA,EAEQ,OAAO,OAAwB,cAAgD;AAKtF,QAAI;AACJ,QAAI,cAAc,UAAU;AAC3B,aAAO,SAAS;AAAA,IACjB,WAAW,MAAM,OAAO,GAAG;AAC1B,aAAO,SAAS;AAAA,IACjB,WAAW,MAAM,YAAY,GAAG;AAC/B,aAAO,SAAS;AAAA,IACjB,OAAO;AACN,aAAO,SAAS;AAAA,IACjB;AAGA,QAAI,cAAc;AACjB,cAAQ,SAAS;AAAA,IAClB;AAEA,WAAO;AAAA,EACR;AAAA;AAAA;AAAA,EAMiB,gBAAgB,IAAI,YAAqB,cAAY,2BAA2B,iBAAiB,QAAQ,CAAC;AAAA,EAE3H,MAAc,mBAAmB,UAAqC;AACrE,UAAM,WAAW,KAAK,WAAW,QAAQ;AACzC,SAAK,UAAU,uFAAuF,QAAQ,GAAG;AAKjH,QAAI,eAAoC;AACxC,WAAO,eAAe,KAAK,cAAc,IAAI,QAAQ,GAAG;AACvD,WAAK,UAAU,+FAA+F,QAAQ,GAAG;AACzH,YAAM,aAAa,KAAK;AAAA,IACzB;AAGA,UAAM,UAAU,IAAI,QAAQ;AAC5B,SAAK,cAAc,IAAI,UAAU,OAAO;AAExC,SAAK,UAAU,gFAAgF,QAAQ,GAAG;AAE1G,WAAO,aAAa,MAAM;AACzB,WAAK,UAAU,8EAA8E,QAAQ,GAAG;AAGxG,UAAI,KAAK,cAAc,IAAI,QAAQ,MAAM,SAAS;AACjD,aAAK,UAAU,mGAAmG,QAAQ,GAAG;AAC7H,aAAK,cAAc,OAAO,QAAQ;AAAA,MACnC;AAGA,WAAK,UAAU,mFAAmF,QAAQ,GAAG;AAC7G,cAAQ,KAAK;AAAA,IACd,CAAC;AAAA,EACF;AAAA,EAEA,MAAM,SAAS,UAAe,SAAuD;AACpF,QAAI,OAAgC;AACpC,QAAI;AACH,UAAI,SAAS,QAAQ;AACpB,aAAK,UAAU,6DAA6D,KAAK,WAAW,QAAQ,CAAC,GAAG;AAKxG,eAAO,MAAM,KAAK,mBAAmB,QAAQ;AAAA,MAC9C;AAEA,YAAM,WAAW,KAAK,WAAW,QAAQ;AAEzC,aAAO,MAAM,SAAS,SAAS,QAAQ;AAAA,IACxC,SAAS,OAAO;AACf,YAAM,KAAK,0BAA0B,KAAK;AAAA,IAC3C,UAAE;AACD,YAAM,QAAQ;AAAA,IACf;AAAA,EACD;AAAA,EAEQ,UAAU,KAAmB;AACpC,QAAI,uBAAuB,0BAA0B;AACpD,WAAK,WAAW,MAAM,GAAG;AAAA,IAC1B;AAAA,EACD;AAAA,EAEA,eAAe,UAAe,MAA8B,OAA4D;AACvH,UAAM,SAAS,mBAA+B,UAAQ,SAAS,OAAO,KAAK,IAAI,CAAAA,UAAQ,SAAS,KAAKA,KAAI,CAAC,CAAC,EAAE,MAAM;AAEnH,uBAAmB,MAAM,UAAU,QAAQ,UAAQ,KAAK,QAAQ;AAAA,MAC/D,GAAG;AAAA,MACH,YAAY,MAAM;AAAA;AAAA,IACnB,GAAG,KAAK;AAER,WAAO;AAAA,EACR;AAAA,EAEA,MAAM,UAAU,UAAe,SAAqB,MAAwC;AAC3F,QAAI,MAAM,WAAW,SAAS,MAAM,QAAQ,WAAW,MAAM,KAAK,mBAAmB,QAAQ,GAAG;AAC/F,aAAO,KAAK,kBAAkB,UAAU,SAAS,iBAAiB,QAAQ,GAAG,GAAG,kBAAkB,QAAQ,CAAC,GAAG,KAAK,OAAO,OAAO,EAAE,GAAG,SAAS,IAAI;AAAA,IACpJ,OAAO;AACN,aAAO,KAAK,YAAY,UAAU,SAAS,IAAI;AAAA,IAChD;AAAA,EACD;AAAA,EAEA,MAAc,mBAAmB,UAAiC;AACjE,QAAI;AACH,YAAM,WAAW,KAAK,WAAW,QAAQ;AACzC,YAAM,EAAE,aAAa,IAAI,MAAM,eAAe,KAAK,QAAQ;AAC3D,UAAI,cAAc;AAMjB,eAAO;AAAA,MACR;AAAA,IACD,SAAS,OAAO;AAAA,IAEhB;AAEA,WAAO;AAAA,EACR;AAAA,EAEA,MAAc,kBAAkB,UAAe,cAAmB,SAAqB,MAAwC;AAM9H,UAAM,QAAQ,IAAI,gBAAgB;AAElC,QAAI;AACH,YAAM,IAAI,MAAM,KAAK,mBAAmB,QAAQ,CAAC;AACjD,YAAM,IAAI,MAAM,KAAK,mBAAmB,YAAY,CAAC;AAGrD,YAAM,KAAK;AAAA,QAAY;AAAA,QAAc;AAAA,QAAS;AAAA,QAAM;AAAA;AAAA,MAA6B;AAEjF,UAAI;AAGH,cAAM,KAAK,OAAO,cAAc,UAAU,EAAE,WAAW,KAAK,CAAC;AAAA,MAE9D,SAAS,OAAO;AAGf,YAAI;AACH,gBAAM,KAAK,OAAO,cAAc,EAAE,WAAW,OAAO,UAAU,OAAO,QAAQ,MAAM,CAAC;AAAA,QACrF,SAASC,QAAO;AAAA,QAEhB;AAEA,cAAM;AAAA,MACP;AAAA,IACD,UAAE;AACD,YAAM,QAAQ;AAAA,IACf;AAAA,EACD;AAAA,EAEA,MAAc,YAAY,UAAe,SAAqB,MAAyB,kBAA2C;AACjI,QAAI,SAA6B;AACjC,QAAI;AACH,YAAM,WAAW,KAAK,WAAW,QAAQ;AAGzC,UAAI,CAAC,KAAK,UAAU,CAAC,KAAK,WAAW;AACpC,cAAM,aAAa,MAAM,SAAS,OAAO,QAAQ;AACjD,YAAI,YAAY;AACf,cAAI,CAAC,KAAK,WAAW;AACpB,kBAAM,8BAA8B,SAAS,cAAc,qBAAqB,GAAG,4BAA4B,UAAU;AAAA,UAC1H;AAAA,QACD,OAAO;AACN,cAAI,CAAC,KAAK,QAAQ;AACjB,kBAAM,8BAA8B,SAAS,iBAAiB,qBAAqB,GAAG,4BAA4B,YAAY;AAAA,UAC/H;AAAA,QACD;AAAA,MACD;AAGA,eAAS,MAAM,KAAK,KAAK,UAAU,EAAE,QAAQ,MAAM,QAAQ,KAAK,OAAO,GAAG,gBAAgB;AAG1F,YAAM,KAAK,MAAM,QAAQ,GAAG,SAAS,GAAG,QAAQ,UAAU;AAAA,IAC3D,SAAS,OAAO;AACf,YAAM,MAAM,KAAK,+BAA+B,UAAU,KAAK;AAAA,IAChE,UAAE;AACD,UAAI,OAAO,WAAW,UAAU;AAC/B,cAAM,KAAK,MAAM,MAAM;AAAA,MACxB;AAAA,IACD;AAAA,EACD;AAAA,EAEiB,iBAAiB,oBAAI,IAAoB;AAAA,EACzC,kBAAkB,oBAAI,IAAyB;AAAA,EAE/C,eAAe,oBAAI,IAAiB;AAAA,EAErD,OAAe,WAAoB;AAAA,EAEnC,OAAO,sBAAsB,SAAwB;AACpD,2BAAuB,WAAW;AAAA,EACnC;AAAA,EAEA,MAAM,KAAK,UAAe,MAAwB,kBAA6C;AAC9F,UAAM,WAAW,KAAK,WAAW,QAAQ;AAKzC,QAAI,OAAgC;AACpC,QAAI,0BAA0B,IAAI,KAAK,CAAC,kBAAkB;AACzD,aAAO,MAAM,KAAK,mBAAmB,QAAQ;AAAA,IAC9C;AAEA,QAAI,KAAyB;AAC7B,QAAI;AAGH,UAAI,0BAA0B,IAAI,KAAK,KAAK,QAAQ;AACnD,YAAI;AACH,gBAAM,EAAE,KAAK,IAAI,MAAM,eAAe,KAAK,QAAQ;AACnD,cAAI,EAAE,KAAK,OAAO,MAAqD;AACtE,kBAAM,SAAS,MAAM,UAAU,KAAK,OAAO,GAAK;AAAA,UACjD;AAAA,QACD,SAAS,OAAO;AACf,cAAI,MAAM,SAAS,UAAU;AAC5B,iBAAK,WAAW,MAAM,KAAK;AAAA,UAC5B;AAAA,QACD;AAAA,MACD;AAGA,UAAI,QAA4B;AAChC,UAAI,0BAA0B,IAAI,GAAG;AACpC,YAAI,WAAW;AACd,cAAI;AAMH,kBAAM,SAAS,SAAS,UAAU,CAAC;AAGnC,oBAAQ;AAAA,UACT,SAAS,OAAO;AACf,gBAAI,MAAM,SAAS,UAAU;AAC5B,mBAAK,WAAW,MAAM,KAAK;AAAA,YAC5B;AAAA,UACD;AAAA,QACD;AAKA,YAAI,CAAC,OAAO;AACX,kBAAQ;AAAA,QACT;AAAA,MACD,OAAO;AAKN,gBAAQ;AAAA,MACT;AAGA,WAAK,MAAM,SAAS,KAAK,UAAU,KAAK;AAAA,IAEzC,SAAS,OAAO;AAIf,YAAM,QAAQ;AAGd,UAAI,0BAA0B,IAAI,GAAG;AACpC,cAAM,MAAM,KAAK,+BAA+B,UAAU,KAAK;AAAA,MAChE,OAAO;AACN,cAAM,KAAK,0BAA0B,KAAK;AAAA,MAC3C;AAAA,IACD;AAOA,SAAK,eAAe,IAAI,IAAI,CAAC;AAG7B,QAAI,0BAA0B,IAAI,GAAG;AACpC,WAAK,aAAa,IAAI,IAAI,QAAQ;AAAA,IACnC;AAEA,QAAI,MAAM;AACT,YAAM,eAAe,KAAK,gBAAgB,IAAI,EAAE;AAGhD,WAAK,UAAU,+DAA+D,EAAE,KAAK,QAAQ,GAAG;AAChG,WAAK,gBAAgB,IAAI,IAAI,IAAI;AAQjC,UAAI,cAAc;AACjB,aAAK,UAAU,sGAAsG,EAAE,KAAK,QAAQ,GAAG;AACvI,qBAAa,QAAQ;AAAA,MACtB;AAAA,IACD;AAEA,WAAO;AAAA,EACR;AAAA,EAEA,MAAM,MAAM,IAA2B;AAQtC,UAAM,gBAAgB,KAAK,gBAAgB,IAAI,EAAE;AAEjD,QAAI;AAGH,WAAK,eAAe,OAAO,EAAE;AAI7B,UAAI,KAAK,aAAa,OAAO,EAAE,KAAK,uBAAuB,UAAU;AACpE,YAAI;AACH,gBAAM,SAAS,UAAU,EAAE;AAAA,QAC5B,SAAS,OAAO;AAGf,iCAAuB,sBAAsB,KAAK;AAClD,eAAK,WAAW,MAAM,KAAK;AAAA,QAC5B;AAAA,MACD;AAEA,aAAO,MAAM,SAAS,MAAM,EAAE;AAAA,IAC/B,SAAS,OAAO;AACf,YAAM,KAAK,0BAA0B,KAAK;AAAA,IAC3C,UAAE;AACD,UAAI,eAAe;AAClB,YAAI,KAAK,gBAAgB,IAAI,EAAE,MAAM,eAAe;AACnD,eAAK,UAAU,mFAAmF,EAAE,EAAE;AACtG,eAAK,gBAAgB,OAAO,EAAE;AAAA,QAC/B;AAEA,aAAK,UAAU,kEAAkE,EAAE,EAAE;AACrF,sBAAc,QAAQ;AAAA,MACvB;AAAA,IACD;AAAA,EACD;AAAA,EAEA,MAAM,KAAK,IAAY,KAAa,MAAkB,QAAgB,QAAiC;AACtG,UAAM,gBAAgB,KAAK,aAAa,IAAI,GAAG;AAE/C,QAAI,YAA2B;AAC/B,QAAI;AACH,mBAAa,MAAM,SAAS,KAAK,IAAI,MAAM,QAAQ,QAAQ,aAAa,GAAG;AAAA,IAC5E,SAAS,OAAO;AACf,YAAM,KAAK,0BAA0B,KAAK;AAAA,IAC3C,UAAE;AACD,WAAK,UAAU,IAAI,eAAe,SAAS;AAAA,IAC5C;AAEA,WAAO;AAAA,EACR;AAAA,EAEQ,aAAa,IAAY,KAA4B;AAS5D,QAAI,QAAQ,KAAK,eAAe,IAAI,EAAE,GAAG;AACxC,aAAO;AAAA,IACR;AAEA,WAAO;AAAA,EACR;AAAA,EAEQ,UAAU,IAAY,KAAoB,aAAkC;AACnF,UAAM,eAAe,KAAK,eAAe,IAAI,EAAE;AAC/C,QAAI,OAAO,iBAAiB,UAAU;AAUrC,UAAI,OAAO,QAAQ,UAAU;AAAA,MAE7B,WAeS,OAAO,gBAAgB,UAAU;AACzC,aAAK,eAAe,IAAI,IAAI,eAAe,WAAW;AAAA,MACvD,OAKK;AACJ,aAAK,eAAe,OAAO,EAAE;AAAA,MAC9B;AAAA,IACD;AAAA,EACD;AAAA,EAEA,MAAM,MAAM,IAAY,KAAa,MAAkB,QAAgB,QAAiC;AAKvG,WAAO;AAAA,MAAM,MAAM,KAAK,QAAQ,IAAI,KAAK,MAAM,QAAQ,MAAM;AAAA,MAAG;AAAA,MAAoB;AAAA;AAAA,IAAe;AAAA,EACpG;AAAA,EAEA,MAAc,QAAQ,IAAY,KAAa,MAAkB,QAAgB,QAAiC;AACjH,UAAM,gBAAgB,KAAK,aAAa,IAAI,GAAG;AAE/C,QAAI,eAA8B;AAClC,QAAI;AACH,sBAAgB,MAAM,SAAS,MAAM,IAAI,MAAM,QAAQ,QAAQ,aAAa,GAAG;AAAA,IAChF,SAAS,OAAO;AACf,YAAM,MAAM,KAAK,+BAA+B,KAAK,aAAa,IAAI,EAAE,GAAG,KAAK;AAAA,IACjF,UAAE;AACD,WAAK,UAAU,IAAI,eAAe,YAAY;AAAA,IAC/C;AAEA,WAAO;AAAA,EACR;AAAA;AAAA;AAAA,EAMA,MAAM,MAAM,UAA8B;AACzC,QAAI;AACH,YAAM,SAAS,MAAM,KAAK,WAAW,QAAQ,CAAC;AAAA,IAC/C,SAAS,OAAO;AACf,YAAM,KAAK,0BAA0B,KAAK;AAAA,IAC3C;AAAA,EACD;AAAA,EAEA,MAAM,OAAO,UAAe,MAAyC;AACpE,QAAI;AACH,YAAM,WAAW,KAAK,WAAW,QAAQ;AACzC,UAAI,KAAK,WAAW;AACnB,YAAI,eAAmC;AACvC,YAAI,MAAM,WAAW,SAAS,KAAK,OAAO,SAAS;AAClD,yBAAe,KAAK,QAAQ,QAAQ,GAAG,GAAG,SAAS,QAAQ,CAAC,GAAG,KAAK,OAAO,OAAO,EAAE;AAAA,QACrF;AAEA,cAAM,SAAS,GAAG,UAAU,WAAW,MAAM,YAAY;AAAA,MAC1D,OAAO;AACN,YAAI;AACH,gBAAM,SAAS,OAAO,QAAQ;AAAA,QAC/B,SAAS,aAAa;AAOrB,cAAI,YAAY,SAAS,WAAW,YAAY,SAAS,UAAU;AAClE,gBAAI,cAAc;AAClB,gBAAI;AACH,oBAAM,EAAE,MAAM,aAAa,IAAI,MAAM,eAAe,KAAK,QAAQ;AACjE,4BAAc,KAAK,YAAY,KAAK,CAAC;AAAA,YACtC,SAAS,WAAW;AAAA,YAEpB;AAEA,gBAAI,aAAa;AAChB,oBAAM,SAAS,MAAM,QAAQ;AAAA,YAC9B,OAAO;AACN,oBAAM;AAAA,YACP;AAAA,UACD,OAAO;AACN,kBAAM;AAAA,UACP;AAAA,QACD;AAAA,MACD;AAAA,IACD,SAAS,OAAO;AACf,YAAM,KAAK,0BAA0B,KAAK;AAAA,IAC3C;AAAA,EACD;AAAA,EAEA,MAAM,OAAO,MAAW,IAAS,MAA4C;AAC5E,UAAM,eAAe,KAAK,WAAW,IAAI;AACzC,UAAM,aAAa,KAAK,WAAW,EAAE;AAErC,QAAI,iBAAiB,YAAY;AAChC;AAAA,IACD;AAEA,QAAI;AAGH,YAAM,KAAK,iBAAiB,MAAM,IAAI,QAAQ,KAAK,SAAS;AAG5D,YAAM,SAAS,OAAO,cAAc,UAAU;AAAA,IAC/C,SAAS,OAAO;AAIf,UAAI,MAAM,SAAS,YAAY,MAAM,SAAS,WAAW,MAAM,SAAS,gBAAgB;AACvF,gBAAQ,IAAI,MAAM,SAAS,aAAa,0CAA0C,SAAS,YAAY,GAAG,SAAS,QAAQ,UAAU,CAAC,GAAG,MAAM,SAAS,CAAC,CAAC;AAAA,MAC3J;AAEA,YAAM,KAAK,0BAA0B,KAAK;AAAA,IAC3C;AAAA,EACD;AAAA,EAEA,MAAM,KAAK,MAAW,IAAS,MAA4C;AAC1E,UAAM,eAAe,KAAK,WAAW,IAAI;AACzC,UAAM,aAAa,KAAK,WAAW,EAAE;AAErC,QAAI,iBAAiB,YAAY;AAChC;AAAA,IACD;AAEA,QAAI;AAGH,YAAM,KAAK,iBAAiB,MAAM,IAAI,QAAQ,KAAK,SAAS;AAG5D,YAAM,SAAS,KAAK,cAAc,YAAY,EAAE,kBAAkB,KAAK,CAAC;AAAA,IACzE,SAAS,OAAO;AAIf,UAAI,MAAM,SAAS,YAAY,MAAM,SAAS,WAAW,MAAM,SAAS,gBAAgB;AACvF,gBAAQ,IAAI,MAAM,SAAS,aAAa,0CAA0C,SAAS,YAAY,GAAG,SAAS,QAAQ,UAAU,CAAC,GAAG,MAAM,SAAS,CAAC,CAAC;AAAA,MAC3J;AAEA,YAAM,KAAK,0BAA0B,KAAK;AAAA,IAC3C;AAAA,EACD;AAAA,EAEA,MAAc,iBAAiB,MAAW,IAAS,MAAuB,WAAoC;AAC7G,UAAM,eAAe,KAAK,WAAW,IAAI;AACzC,UAAM,aAAa,KAAK,WAAW,EAAE;AAErC,QAAI,sCAAsC;AAC1C,UAAM,sBAAsB,CAAC,EAAE,KAAK,eAAe,+BAA+B;AAClF,QAAI,CAAC,qBAAqB;AACzB,4CAAsC;AAAA,QAAQ;AAAA,QAAc;AAAA,QAAY;AAAA;AAAA,MAAsB;AAAA,IAC/F;AAEA,QAAI,qCAAqC;AAIxC,UAAI,SAAS,QAAQ;AACpB,cAAM,8BAA8B,SAAS,yBAAyB,6DAA6D,GAAG,4BAA4B,UAAU;AAAA,MAC7K,WAIS,SAAS,QAAQ;AACzB;AAAA,MACD;AAAA,IACD;AAMA,UAAM,WAAW,MAAM,KAAK,gBAAgB,IAAI;AAChD,QAAI,CAAC,UAAU;AACd,YAAM,8BAA8B,SAAS,6BAA6B,kCAAkC,GAAG,4BAA4B,YAAY;AAAA,IACxJ;AAEA,UAAM,SAAS,MAAM,KAAK,gBAAgB,EAAE;AAC5C,QAAI,CAAC,QAAQ;AACZ;AAAA,IACD;AAEA,QAAI,CAAC,WAAW;AACf,YAAM,8BAA8B,SAAS,2BAA2B,kGAAkG,GAAG,4BAA4B,UAAU;AAAA,IACpN;AAGA,SAAK,SAAS,OAAO,SAAS,UAAU,MAAM,OAAO,OAAO,SAAS,UAAU,GAAG;AACjF;AAAA,IACD,OAAO;AACN,YAAM,KAAK,OAAO,IAAI,EAAE,WAAW,MAAM,UAAU,OAAO,QAAQ,MAAM,CAAC;AAAA,IAC1E;AAAA,EACD;AAAA;AAAA;AAAA,EAMA,MAAM,UAAU,MAAW,IAAwB;AAClD,WAAO,KAAK;AAAA,MAAY;AAAA,MAAM;AAAA,MAAI;AAAA;AAAA,IAAsD;AAAA,EACzF;AAAA,EAEA,MAAc,YAAY,MAAW,IAAS,OAA+B;AAC5E,UAAM,eAAe,KAAK,WAAW,IAAI;AACzC,UAAM,aAAa,KAAK,WAAW,EAAE;AAErC,UAAM,sBAAsB,CAAC,EAAE,KAAK,eAAe,+BAA+B;AAClF,QAAI,QAAQ,cAAc,YAAY,CAAC,mBAAmB,GAAG;AAC5D;AAAA,IACD;AAMA,UAAM,QAAQ,IAAI,gBAAgB;AAElC,QAAI;AACH,YAAM,IAAI,MAAM,KAAK,mBAAmB,IAAI,CAAC;AAC7C,YAAM,IAAI,MAAM,KAAK,mBAAmB,EAAE,CAAC;AAE3C,UAAI,OAAO;AACV,cAAM,SAAS,MAAM,QAAQ,UAAU,GAAG,EAAE,WAAW,KAAK,CAAC;AAAA,MAC9D;AAEA,YAAM,SAAS,SAAS,cAAc,UAAU;AAAA,IACjD,SAAS,OAAO;AACf,UAAI,MAAM,SAAS,YAAY,CAAC,OAAO;AACtC,eAAO,KAAK,YAAY,MAAM,IAAI,IAAI;AAAA,MACvC;AAEA,YAAM,KAAK,0BAA0B,KAAK;AAAA,IAC3C,UAAE;AACD,YAAM,QAAQ;AAAA,IACf;AAAA,EACD;AAAA;AAAA;AAAA,EAMU,uBACT,UACA,cACA,gBACiC;AACjC,WAAO,IAAI,uBAAuB,aAAW,SAAS,OAAO,GAAG,SAAO,aAAa,GAAG,GAAG,cAAc;AAAA,EACzG;AAAA,EAEU,0BACT,UACA,cACA,gBACoC;AACpC,WAAO,IAAI,oBAAoB,aAAW,SAAS,OAAO,GAAG,SAAO,aAAa,GAAG,GAAG,cAAc;AAAA,EACtG;AAAA;AAAA;AAAA,EAMQ,0BAA0B,OAAuD;AACxF,QAAI,iBAAiB,yBAAyB;AAC7C,aAAO;AAAA,IACR;AAEA,QAAI,cAA8B;AAClC,QAAI;AACJ,YAAQ,MAAM,MAAM;AAAA,MACnB,KAAK;AACJ,eAAO,4BAA4B;AACnC;AAAA,MACD,KAAK;AACJ,eAAO,4BAA4B;AACnC;AAAA,MACD,KAAK;AACJ,eAAO,4BAA4B;AACnC;AAAA,MACD,KAAK;AACJ,eAAO,4BAA4B;AACnC;AAAA,MACD,KAAK;AAAA,MACL,KAAK;AACJ,eAAO,4BAA4B;AACnC;AAAA,MACD,KAAK;AACJ,sBAAc,GAAG,MAAM,OAAO;AAC9B,eAAO,4BAA4B;AACnC;AAAA,MACD;AACC,eAAO,4BAA4B;AAAA,IACrC;AAEA,WAAO,8BAA8B,aAAa,IAAI;AAAA,EACvD;AAAA,EAEA,MAAc,+BAA+B,UAA2B,OAAgE;AACvI,QAAI,+BAA+B,KAAK,0BAA0B,KAAK;AAKvE,QAAI,YAAY,6BAA6B,SAAS,4BAA4B,eAAe;AAChG,UAAI;AACH,cAAM,EAAE,KAAK,IAAI,MAAM,eAAe,KAAK,KAAK,WAAW,QAAQ,CAAC;AACpE,YAAI,EAAE,KAAK,OAAO,MAAqD;AACtE,yCAA+B,8BAA8B,OAAO,4BAA4B,eAAe;AAAA,QAChH;AAAA,MACD,SAASA,QAAO;AACf,aAAK,WAAW,MAAMA,MAAK;AAAA,MAC5B;AAAA,IACD;AAEA,WAAO;AAAA,EACR;AAAA;AAGD;",
  "names": ["data", "error"]
}
