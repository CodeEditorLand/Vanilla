import s from"assert";import{VSBuffer as u}from"../../../../base/common/buffer.js";import"../../../../base/common/cancellation.js";import{Emitter as P,Event as b}from"../../../../base/common/event.js";import{Disposable as x}from"../../../../base/common/lifecycle.js";import{Schemas as m}from"../../../../base/common/network.js";import{dirname as I,isEqual as g,joinPath as r}from"../../../../base/common/resources.js";import"../../../../base/common/stream.js";import{URI as R}from"../../../../base/common/uri.js";import{ensureNoDisposablesAreLeakedInTestSuite as v}from"../../../../base/test/common/utils.js";import"../../../environment/common/environment.js";import{AbstractNativeEnvironmentService as q}from"../../../environment/common/environmentService.js";import{FileService as F}from"../../../files/common/fileService.js";import{FileChangeType as p,FileSystemProviderCapabilities as U}from"../../../files/common/files.js";import{InMemoryFileSystemProvider as k}from"../../../files/common/inMemoryFilesystemProvider.js";import{NullLogService as S}from"../../../log/common/log.js";import H from"../../../product/common/product.js";import{UriIdentityService as y}from"../../../uriIdentity/common/uriIdentityService.js";import{FileUserDataProvider as E}from"../../common/fileUserDataProvider.js";import{UserDataProfilesService as D}from"../../../userDataProfile/common/userDataProfile.js";const w=R.file("tests").with({scheme:"vscode-tests"});class j extends q{constructor(n){super(Object.create(null),Object.create(null),{_serviceBrand:void 0,...H});this._appSettingsHome=n}get userRoamingDataHome(){return this._appSettingsHome.with({scheme:m.vscodeUserData})}get cacheHome(){return this.userRoamingDataHome}}suite("FileUserDataProvider",()=>{let e,i,n,c,o;const l=v();let d;setup(async()=>{const t=new S;e=l.add(new F(t));const a=l.add(new k);l.add(e.registerProvider(w.scheme,a)),i=r(w,"User");const f=r(w,"Backups");n=r(f,"workspaceId"),await e.createFolder(i),await e.createFolder(n),c=new j(i);const h=l.add(new y(e));o=l.add(new D(c,e,h,t)),d=l.add(new E(w.scheme,a,m.vscodeUserData,o,h,t)),l.add(d),l.add(e.registerProvider(m.vscodeUserData,d))}),test("exists return false when file does not exist",async()=>{const t=await e.exists(o.defaultProfile.settingsResource);s.strictEqual(t,!1)}),test("read file throws error if not exist",async()=>{try{await e.readFile(o.defaultProfile.settingsResource),s.fail("Should fail since file does not exist")}catch{}}),test("read existing file",async()=>{await e.writeFile(r(i,"settings.json"),u.fromString("{}"));const t=await e.readFile(o.defaultProfile.settingsResource);s.strictEqual(t.value.toString(),"{}")}),test("create file",async()=>{const t=o.defaultProfile.settingsResource,a=await e.createFile(t,u.fromString("{}"));s.strictEqual(a.resource.toString(),t.toString());const f=await e.readFile(r(i,"settings.json"));s.strictEqual(f.value.toString(),"{}")}),test("write file creates the file if not exist",async()=>{const t=o.defaultProfile.settingsResource,a=await e.writeFile(t,u.fromString("{}"));s.strictEqual(a.resource.toString(),t.toString());const f=await e.readFile(r(i,"settings.json"));s.strictEqual(f.value.toString(),"{}")}),test("write to existing file",async()=>{const t=o.defaultProfile.settingsResource;await e.writeFile(r(i,"settings.json"),u.fromString("{}"));const a=await e.writeFile(t,u.fromString("{a:1}"));s.strictEqual(a.resource.toString(),t.toString());const f=await e.readFile(r(i,"settings.json"));s.strictEqual(f.value.toString(),"{a:1}")}),test("delete file",async()=>{await e.writeFile(r(i,"settings.json"),u.fromString("")),await e.del(o.defaultProfile.settingsResource);const t=await e.exists(r(i,"settings.json"));s.strictEqual(!1,t)}),test("resolve file",async()=>{await e.writeFile(r(i,"settings.json"),u.fromString(""));const t=await e.resolve(o.defaultProfile.settingsResource);s.ok(!t.isDirectory),s.ok(t.children===void 0)}),test("exists return false for folder that does not exist",async()=>{const t=await e.exists(o.defaultProfile.snippetsHome);s.strictEqual(t,!1)}),test("exists return true for folder that exists",async()=>{await e.createFolder(r(i,"snippets"));const t=await e.exists(o.defaultProfile.snippetsHome);s.strictEqual(t,!0)}),test("read file throws error for folder",async()=>{await e.createFolder(r(i,"snippets"));try{await e.readFile(o.defaultProfile.snippetsHome),s.fail("Should fail since read file is not supported for folders")}catch{}}),test("read file under folder",async()=>{await e.createFolder(r(i,"snippets")),await e.writeFile(r(i,"snippets","settings.json"),u.fromString("{}"));const t=r(o.defaultProfile.snippetsHome,"settings.json"),a=await e.readFile(t);s.strictEqual(a.resource.toString(),t.toString()),s.strictEqual(a.value.toString(),"{}")}),test("read file under sub folder",async()=>{await e.createFolder(r(i,"snippets","java")),await e.writeFile(r(i,"snippets","java","settings.json"),u.fromString("{}"));const t=r(o.defaultProfile.snippetsHome,"java/settings.json"),a=await e.readFile(t);s.strictEqual(a.resource.toString(),t.toString()),s.strictEqual(a.value.toString(),"{}")}),test("create file under folder that exists",async()=>{await e.createFolder(r(i,"snippets"));const t=r(o.defaultProfile.snippetsHome,"settings.json"),a=await e.createFile(t,u.fromString("{}"));s.strictEqual(a.resource.toString(),t.toString());const f=await e.readFile(r(i,"snippets","settings.json"));s.strictEqual(f.value.toString(),"{}")}),test("create file under folder that does not exist",async()=>{const t=r(o.defaultProfile.snippetsHome,"settings.json"),a=await e.createFile(t,u.fromString("{}"));s.strictEqual(a.resource.toString(),t.toString());const f=await e.readFile(r(i,"snippets","settings.json"));s.strictEqual(f.value.toString(),"{}")}),test("write to not existing file under container that exists",async()=>{await e.createFolder(r(i,"snippets"));const t=r(o.defaultProfile.snippetsHome,"settings.json"),a=await e.writeFile(t,u.fromString("{}"));s.strictEqual(a.resource.toString(),t.toString());const f=await e.readFile(r(i,"snippets","settings.json"));s.strictEqual(f.value.toString(),"{}")}),test("write to not existing file under container that does not exists",async()=>{const t=r(o.defaultProfile.snippetsHome,"settings.json"),a=await e.writeFile(t,u.fromString("{}"));s.strictEqual(a.resource.toString(),t.toString());const f=await e.readFile(r(i,"snippets","settings.json"));s.strictEqual(f.value.toString(),"{}")}),test("write to existing file under container",async()=>{await e.createFolder(r(i,"snippets")),await e.writeFile(r(i,"snippets","settings.json"),u.fromString("{}"));const t=r(o.defaultProfile.snippetsHome,"settings.json"),a=await e.writeFile(t,u.fromString("{a:1}"));s.strictEqual(a.resource.toString(),t.toString());const f=await e.readFile(r(i,"snippets","settings.json"));s.strictEqual(f.value.toString(),"{a:1}")}),test("write file under sub container",async()=>{const t=r(o.defaultProfile.snippetsHome,"java/settings.json"),a=await e.writeFile(t,u.fromString("{}"));s.strictEqual(a.resource.toString(),t.toString());const f=await e.readFile(r(i,"snippets","java","settings.json"));s.strictEqual(f.value.toString(),"{}")}),test("delete throws error for folder that does not exist",async()=>{try{await e.del(o.defaultProfile.snippetsHome),s.fail("Should fail the folder does not exist")}catch{}}),test("delete not existing file under container that exists",async()=>{await e.createFolder(r(i,"snippets"));try{await e.del(r(o.defaultProfile.snippetsHome,"settings.json")),s.fail("Should fail since file does not exist")}catch{}}),test("delete not existing file under container that does not exists",async()=>{try{await e.del(r(o.defaultProfile.snippetsHome,"settings.json")),s.fail("Should fail since file does not exist")}catch{}}),test("delete existing file under folder",async()=>{await e.createFolder(r(i,"snippets")),await e.writeFile(r(i,"snippets","settings.json"),u.fromString("{}")),await e.del(r(o.defaultProfile.snippetsHome,"settings.json"));const t=await e.exists(r(i,"snippets","settings.json"));s.strictEqual(t,!1)}),test("resolve folder",async()=>{await e.createFolder(r(i,"snippets")),await e.writeFile(r(i,"snippets","settings.json"),u.fromString("{}"));const t=await e.resolve(o.defaultProfile.snippetsHome);s.ok(t.isDirectory),s.ok(t.children!==void 0),s.strictEqual(t.children.length,1),s.strictEqual(t.children[0].resource.toString(),r(o.defaultProfile.snippetsHome,"settings.json").toString())}),test("read backup file",async()=>{await e.writeFile(r(n,"backup.json"),u.fromString("{}"));const t=await e.readFile(r(n.with({scheme:c.userRoamingDataHome.scheme}),"backup.json"));s.strictEqual(t.value.toString(),"{}")}),test("create backup file",async()=>{await e.createFile(r(n.with({scheme:c.userRoamingDataHome.scheme}),"backup.json"),u.fromString("{}"));const t=await e.readFile(r(n,"backup.json"));s.strictEqual(t.value.toString(),"{}")}),test("write backup file",async()=>{await e.writeFile(r(n,"backup.json"),u.fromString("{}")),await e.writeFile(r(n.with({scheme:c.userRoamingDataHome.scheme}),"backup.json"),u.fromString("{a:1}"));const t=await e.readFile(r(n,"backup.json"));s.strictEqual(t.value.toString(),"{a:1}")}),test("resolve backups folder",async()=>{await e.writeFile(r(n,"backup.json"),u.fromString("{}"));const t=await e.resolve(n.with({scheme:c.userRoamingDataHome.scheme}));s.ok(t.isDirectory),s.ok(t.children!==void 0),s.strictEqual(t.children.length,1),s.strictEqual(t.children[0].resource.toString(),r(n.with({scheme:c.userRoamingDataHome.scheme}),"backup.json").toString())})});class C{constructor(i){this.onDidChangeFile=i}capabilities=U.FileReadWrite;onDidChangeCapabilities=b.None;watch(){return x.None}stat(){throw new Error("Not Supported")}mkdir(i){throw new Error("Not Supported")}rename(){throw new Error("Not Supported")}readFile(i){throw new Error("Not Supported")}readdir(i){throw new Error("Not Supported")}writeFile(){throw new Error("Not Supported")}delete(){throw new Error("Not Supported")}open(i,n){throw new Error("Not Supported")}close(i){throw new Error("Not Supported")}read(i,n,c,o,l){throw new Error("Not Supported")}write(i,n,c,o,l){throw new Error("Not Supported")}readFileStream(i,n,c){throw new Error("Method not implemented.")}}suite("FileUserDataProvider - Watching",()=>{let e;const i=v(),n=r(w,"User"),c=n.with({scheme:m.vscodeUserData});let o;setup(()=>{const l=new S,d=i.add(new F(l)),t=new j(n),a=i.add(new y(d)),f=i.add(new D(t,d,a,l));o=i.add(new P),e=i.add(new E(n.scheme,new C(o.event),m.vscodeUserData,f,a,new S))}),test("file added change event",l=>{i.add(e.watch(c,{excludes:[],recursive:!1}));const d=r(c,"settings.json"),t=r(n,"settings.json");i.add(e.onDidChangeFile(a=>{g(a[0].resource,d)&&a[0].type===p.ADDED&&l()})),o.fire([{resource:t,type:p.ADDED}])}),test("file updated change event",l=>{i.add(e.watch(c,{excludes:[],recursive:!1}));const d=r(c,"settings.json"),t=r(n,"settings.json");i.add(e.onDidChangeFile(a=>{g(a[0].resource,d)&&a[0].type===p.UPDATED&&l()})),o.fire([{resource:t,type:p.UPDATED}])}),test("file deleted change event",l=>{i.add(e.watch(c,{excludes:[],recursive:!1}));const d=r(c,"settings.json"),t=r(n,"settings.json");i.add(e.onDidChangeFile(a=>{g(a[0].resource,d)&&a[0].type===p.DELETED&&l()})),o.fire([{resource:t,type:p.DELETED}])}),test("file under folder created change event",l=>{i.add(e.watch(c,{excludes:[],recursive:!1}));const d=r(c,"snippets","settings.json"),t=r(n,"snippets","settings.json");i.add(e.onDidChangeFile(a=>{g(a[0].resource,d)&&a[0].type===p.ADDED&&l()})),o.fire([{resource:t,type:p.ADDED}])}),test("file under folder updated change event",l=>{i.add(e.watch(c,{excludes:[],recursive:!1}));const d=r(c,"snippets","settings.json"),t=r(n,"snippets","settings.json");i.add(e.onDidChangeFile(a=>{g(a[0].resource,d)&&a[0].type===p.UPDATED&&l()})),o.fire([{resource:t,type:p.UPDATED}])}),test("file under folder deleted change event",l=>{i.add(e.watch(c,{excludes:[],recursive:!1}));const d=r(c,"snippets","settings.json"),t=r(n,"snippets","settings.json");i.add(e.onDidChangeFile(a=>{g(a[0].resource,d)&&a[0].type===p.DELETED&&l()})),o.fire([{resource:t,type:p.DELETED}])}),test("event is not triggered if not watched",async()=>{const l=r(n,"settings.json");let d=!1;i.add(e.onDidChangeFile(()=>d=!0)),o.fire([{resource:l,type:p.DELETED}]),d&&s.fail("event should not be triggered")}),test("event is not triggered if not watched 2",async()=>{i.add(e.watch(c,{excludes:[],recursive:!1}));const l=r(I(n),"settings.json");let d=!1;i.add(e.onDidChangeFile(()=>d=!0)),o.fire([{resource:l,type:p.DELETED}]),d&&s.fail("event should not be triggered")})});
