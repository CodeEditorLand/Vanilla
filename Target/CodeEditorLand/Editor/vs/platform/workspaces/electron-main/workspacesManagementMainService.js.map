{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/workspaces/electron-main/workspacesManagementMainService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from \"fs\";\nimport electron from \"electron\";\nimport { Emitter, type Event } from \"../../../base/common/event.js\";\nimport { parse } from \"../../../base/common/json.js\";\nimport { Disposable } from \"../../../base/common/lifecycle.js\";\nimport { Schemas } from \"../../../base/common/network.js\";\nimport { dirname, join } from \"../../../base/common/path.js\";\nimport {\n\tbasename,\n\textUriBiasedIgnorePathCase,\n\tjoinPath,\n\toriginalFSPath,\n} from \"../../../base/common/resources.js\";\nimport type { URI } from \"../../../base/common/uri.js\";\nimport { Promises } from \"../../../base/node/pfs.js\";\nimport { localize } from \"../../../nls.js\";\nimport { IBackupMainService } from \"../../backup/electron-main/backup.js\";\nimport { IDialogMainService } from \"../../dialogs/electron-main/dialogMainService.js\";\nimport { IEnvironmentMainService } from \"../../environment/electron-main/environmentMainService.js\";\nimport { createDecorator } from \"../../instantiation/common/instantiation.js\";\nimport { ILogService } from \"../../log/common/log.js\";\nimport { IUserDataProfilesMainService } from \"../../userDataProfile/electron-main/userDataProfile.js\";\nimport type { ICodeWindow } from \"../../window/electron-main/window.js\";\nimport { findWindowOnWorkspaceOrFolder } from \"../../windows/electron-main/windowsFinder.js\";\nimport {\n\ttype IResolvedWorkspace,\n\ttype IWorkspaceIdentifier,\n\tUNTITLED_WORKSPACE_NAME,\n\thasWorkspaceFileExtension,\n\tisUntitledWorkspace,\n\tisWorkspaceIdentifier,\n} from \"../../workspace/common/workspace.js\";\nimport {\n\ttype IEnterWorkspaceResult,\n\ttype IStoredWorkspace,\n\ttype IStoredWorkspaceFolder,\n\ttype IUntitledWorkspaceInfo,\n\ttype IWorkspaceFolderCreationData,\n\tgetStoredWorkspaceFolder,\n\tisStoredWorkspaceFolder,\n\ttoWorkspaceFolders,\n} from \"../common/workspaces.js\";\nimport { getWorkspaceIdentifier } from \"../node/workspaces.js\";\n\nexport const IWorkspacesManagementMainService =\n\tcreateDecorator<IWorkspacesManagementMainService>(\n\t\t\"workspacesManagementMainService\",\n\t);\n\nexport interface IWorkspaceEnteredEvent {\n\treadonly window: ICodeWindow;\n\treadonly workspace: IWorkspaceIdentifier;\n}\n\nexport interface IWorkspacesManagementMainService {\n\treadonly _serviceBrand: undefined;\n\n\treadonly onDidDeleteUntitledWorkspace: Event<IWorkspaceIdentifier>;\n\treadonly onDidEnterWorkspace: Event<IWorkspaceEnteredEvent>;\n\n\tenterWorkspace(\n\t\tintoWindow: ICodeWindow,\n\t\topenedWindows: ICodeWindow[],\n\t\tpath: URI,\n\t): Promise<IEnterWorkspaceResult | undefined>;\n\n\tcreateUntitledWorkspace(\n\t\tfolders?: IWorkspaceFolderCreationData[],\n\t\tremoteAuthority?: string,\n\t): Promise<IWorkspaceIdentifier>;\n\n\tdeleteUntitledWorkspace(workspace: IWorkspaceIdentifier): Promise<void>;\n\n\tgetUntitledWorkspaces(): IUntitledWorkspaceInfo[];\n\tisUntitledWorkspace(workspace: IWorkspaceIdentifier): boolean;\n\n\tresolveLocalWorkspace(path: URI): Promise<IResolvedWorkspace | undefined>;\n\n\tgetWorkspaceIdentifier(workspacePath: URI): Promise<IWorkspaceIdentifier>;\n}\n\nexport class WorkspacesManagementMainService\n\textends Disposable\n\timplements IWorkspacesManagementMainService\n{\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly _onDidDeleteUntitledWorkspace = this._register(\n\t\tnew Emitter<IWorkspaceIdentifier>(),\n\t);\n\treadonly onDidDeleteUntitledWorkspace: Event<IWorkspaceIdentifier> =\n\t\tthis._onDidDeleteUntitledWorkspace.event;\n\n\tprivate readonly _onDidEnterWorkspace = this._register(\n\t\tnew Emitter<IWorkspaceEnteredEvent>(),\n\t);\n\treadonly onDidEnterWorkspace: Event<IWorkspaceEnteredEvent> =\n\t\tthis._onDidEnterWorkspace.event;\n\n\tprivate readonly untitledWorkspacesHome =\n\t\tthis.environmentMainService.untitledWorkspacesHome; // local URI that contains all untitled workspaces\n\n\tprivate untitledWorkspaces: IUntitledWorkspaceInfo[] = [];\n\n\tconstructor(\n\t\t@IEnvironmentMainService\n\t\tprivate readonly environmentMainService: IEnvironmentMainService,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IUserDataProfilesMainService\n\t\tprivate readonly userDataProfilesMainService: IUserDataProfilesMainService,\n\t\t@IBackupMainService\n\t\tprivate readonly backupMainService: IBackupMainService,\n\t\t@IDialogMainService\n\t\tprivate readonly dialogMainService: IDialogMainService,\n\t) {\n\t\tsuper();\n\t}\n\n\tasync initialize(): Promise<void> {\n\t\t// Reset\n\t\tthis.untitledWorkspaces = [];\n\n\t\t// Resolve untitled workspaces\n\t\ttry {\n\t\t\tconst untitledWorkspacePaths = (\n\t\t\t\tawait Promises.readdir(\n\t\t\t\t\tthis.untitledWorkspacesHome.with({ scheme: Schemas.file })\n\t\t\t\t\t\t.fsPath,\n\t\t\t\t)\n\t\t\t).map((folder) =>\n\t\t\t\tjoinPath(\n\t\t\t\t\tthis.untitledWorkspacesHome,\n\t\t\t\t\tfolder,\n\t\t\t\t\tUNTITLED_WORKSPACE_NAME,\n\t\t\t\t),\n\t\t\t);\n\t\t\tfor (const untitledWorkspacePath of untitledWorkspacePaths) {\n\t\t\t\tconst workspace = getWorkspaceIdentifier(untitledWorkspacePath);\n\t\t\t\tconst resolvedWorkspace = await this.resolveLocalWorkspace(\n\t\t\t\t\tuntitledWorkspacePath,\n\t\t\t\t);\n\t\t\t\tif (resolvedWorkspace) {\n\t\t\t\t\tthis.untitledWorkspaces.push({\n\t\t\t\t\t\tworkspace,\n\t\t\t\t\t\tremoteAuthority: resolvedWorkspace.remoteAuthority,\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tawait this.deleteUntitledWorkspace(workspace);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tif (error.code !== \"ENOENT\") {\n\t\t\t\tthis.logService.warn(\n\t\t\t\t\t`Unable to read folders in ${this.untitledWorkspacesHome} (${error}).`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tresolveLocalWorkspace(uri: URI): Promise<IResolvedWorkspace | undefined> {\n\t\treturn this.doResolveLocalWorkspace(uri, (path) =>\n\t\t\tfs.promises.readFile(path, \"utf8\"),\n\t\t);\n\t}\n\n\tprivate doResolveLocalWorkspace(\n\t\turi: URI,\n\t\tcontentsFn: (path: string) => string,\n\t): IResolvedWorkspace | undefined;\n\tprivate doResolveLocalWorkspace(\n\t\turi: URI,\n\t\tcontentsFn: (path: string) => Promise<string>,\n\t): Promise<IResolvedWorkspace | undefined>;\n\tprivate doResolveLocalWorkspace(\n\t\turi: URI,\n\t\tcontentsFn: (path: string) => string | Promise<string>,\n\t):\n\t\t| IResolvedWorkspace\n\t\t| undefined\n\t\t| Promise<IResolvedWorkspace | undefined> {\n\t\tif (!this.isWorkspacePath(uri)) {\n\t\t\treturn undefined; // does not look like a valid workspace config file\n\t\t}\n\n\t\tif (uri.scheme !== Schemas.file) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\ttry {\n\t\t\tconst contents = contentsFn(uri.fsPath);\n\t\t\tif (contents instanceof Promise) {\n\t\t\t\treturn contents.then(\n\t\t\t\t\t(value) => this.doResolveWorkspace(uri, value),\n\t\t\t\t\t(error) => undefined /* invalid workspace */,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\treturn this.doResolveWorkspace(uri, contents);\n\t\t\t}\n\t\t} catch {\n\t\t\treturn undefined; // invalid workspace\n\t\t}\n\t}\n\n\tprivate isWorkspacePath(uri: URI): boolean {\n\t\treturn (\n\t\t\tisUntitledWorkspace(uri, this.environmentMainService) ||\n\t\t\thasWorkspaceFileExtension(uri)\n\t\t);\n\t}\n\n\tprivate doResolveWorkspace(\n\t\tpath: URI,\n\t\tcontents: string,\n\t): IResolvedWorkspace | undefined {\n\t\ttry {\n\t\t\tconst workspace = this.doParseStoredWorkspace(path, contents);\n\t\t\tconst workspaceIdentifier = getWorkspaceIdentifier(path);\n\t\t\treturn {\n\t\t\t\tid: workspaceIdentifier.id,\n\t\t\t\tconfigPath: workspaceIdentifier.configPath,\n\t\t\t\tfolders: toWorkspaceFolders(\n\t\t\t\t\tworkspace.folders,\n\t\t\t\t\tworkspaceIdentifier.configPath,\n\t\t\t\t\textUriBiasedIgnorePathCase,\n\t\t\t\t),\n\t\t\t\tremoteAuthority: workspace.remoteAuthority,\n\t\t\t\ttransient: workspace.transient,\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tthis.logService.warn(error.toString());\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate doParseStoredWorkspace(\n\t\tpath: URI,\n\t\tcontents: string,\n\t): IStoredWorkspace {\n\t\t// Parse workspace file\n\t\tconst storedWorkspace: IStoredWorkspace = parse(contents); // use fault tolerant parser\n\n\t\t// Filter out folders which do not have a path or uri set\n\t\tif (storedWorkspace && Array.isArray(storedWorkspace.folders)) {\n\t\t\tstoredWorkspace.folders = storedWorkspace.folders.filter((folder) =>\n\t\t\t\tisStoredWorkspaceFolder(folder),\n\t\t\t);\n\t\t} else {\n\t\t\tthrow new Error(\n\t\t\t\t`${path.toString(true)} looks like an invalid workspace file.`,\n\t\t\t);\n\t\t}\n\n\t\treturn storedWorkspace;\n\t}\n\n\tasync createUntitledWorkspace(\n\t\tfolders?: IWorkspaceFolderCreationData[],\n\t\tremoteAuthority?: string,\n\t): Promise<IWorkspaceIdentifier> {\n\t\tconst { workspace, storedWorkspace } = this.newUntitledWorkspace(\n\t\t\tfolders,\n\t\t\tremoteAuthority,\n\t\t);\n\t\tconst configPath = workspace.configPath.fsPath;\n\n\t\tawait fs.promises.mkdir(dirname(configPath), { recursive: true });\n\t\tawait Promises.writeFile(\n\t\t\tconfigPath,\n\t\t\tJSON.stringify(storedWorkspace, null, \"\\t\"),\n\t\t);\n\n\t\tthis.untitledWorkspaces.push({ workspace, remoteAuthority });\n\n\t\treturn workspace;\n\t}\n\n\tprivate newUntitledWorkspace(\n\t\tfolders: IWorkspaceFolderCreationData[] = [],\n\t\tremoteAuthority?: string,\n\t): { workspace: IWorkspaceIdentifier; storedWorkspace: IStoredWorkspace } {\n\t\tconst randomId = (\n\t\t\tDate.now() + Math.round(Math.random() * 1000)\n\t\t).toString();\n\t\tconst untitledWorkspaceConfigFolder = joinPath(\n\t\t\tthis.untitledWorkspacesHome,\n\t\t\trandomId,\n\t\t);\n\t\tconst untitledWorkspaceConfigPath = joinPath(\n\t\t\tuntitledWorkspaceConfigFolder,\n\t\t\tUNTITLED_WORKSPACE_NAME,\n\t\t);\n\n\t\tconst storedWorkspaceFolder: IStoredWorkspaceFolder[] = [];\n\n\t\tfor (const folder of folders) {\n\t\t\tstoredWorkspaceFolder.push(\n\t\t\t\tgetStoredWorkspaceFolder(\n\t\t\t\t\tfolder.uri,\n\t\t\t\t\ttrue,\n\t\t\t\t\tfolder.name,\n\t\t\t\t\tuntitledWorkspaceConfigFolder,\n\t\t\t\t\textUriBiasedIgnorePathCase,\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\n\t\treturn {\n\t\t\tworkspace: getWorkspaceIdentifier(untitledWorkspaceConfigPath),\n\t\t\tstoredWorkspace: {\n\t\t\t\tfolders: storedWorkspaceFolder,\n\t\t\t\tremoteAuthority,\n\t\t\t},\n\t\t};\n\t}\n\n\tasync getWorkspaceIdentifier(\n\t\tconfigPath: URI,\n\t): Promise<IWorkspaceIdentifier> {\n\t\treturn getWorkspaceIdentifier(configPath);\n\t}\n\n\tisUntitledWorkspace(workspace: IWorkspaceIdentifier): boolean {\n\t\treturn isUntitledWorkspace(\n\t\t\tworkspace.configPath,\n\t\t\tthis.environmentMainService,\n\t\t);\n\t}\n\n\tasync deleteUntitledWorkspace(\n\t\tworkspace: IWorkspaceIdentifier,\n\t): Promise<void> {\n\t\tif (!this.isUntitledWorkspace(workspace)) {\n\t\t\treturn; // only supported for untitled workspaces\n\t\t}\n\n\t\t// Delete from disk\n\t\tawait this.doDeleteUntitledWorkspace(workspace);\n\n\t\t// unset workspace from profiles\n\t\tif (this.userDataProfilesMainService.isEnabled()) {\n\t\t\tthis.userDataProfilesMainService.unsetWorkspace(workspace);\n\t\t}\n\n\t\t// Event\n\t\tthis._onDidDeleteUntitledWorkspace.fire(workspace);\n\t}\n\n\tprivate async doDeleteUntitledWorkspace(\n\t\tworkspace: IWorkspaceIdentifier,\n\t): Promise<void> {\n\t\tconst configPath = originalFSPath(workspace.configPath);\n\t\ttry {\n\t\t\t// Delete Workspace\n\t\t\tawait Promises.rm(dirname(configPath));\n\n\t\t\t// Mark Workspace Storage to be deleted\n\t\t\tconst workspaceStoragePath = join(\n\t\t\t\tthis.environmentMainService.workspaceStorageHome.with({\n\t\t\t\t\tscheme: Schemas.file,\n\t\t\t\t}).fsPath,\n\t\t\t\tworkspace.id,\n\t\t\t);\n\t\t\tif (await Promises.exists(workspaceStoragePath)) {\n\t\t\t\tawait Promises.writeFile(\n\t\t\t\t\tjoin(workspaceStoragePath, \"obsolete\"),\n\t\t\t\t\t\"\",\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Remove from list\n\t\t\tthis.untitledWorkspaces = this.untitledWorkspaces.filter(\n\t\t\t\t(untitledWorkspace) =>\n\t\t\t\t\tuntitledWorkspace.workspace.id !== workspace.id,\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tthis.logService.warn(\n\t\t\t\t`Unable to delete untitled workspace ${configPath} (${error}).`,\n\t\t\t);\n\t\t}\n\t}\n\n\tgetUntitledWorkspaces(): IUntitledWorkspaceInfo[] {\n\t\treturn this.untitledWorkspaces;\n\t}\n\n\tasync enterWorkspace(\n\t\twindow: ICodeWindow,\n\t\twindows: ICodeWindow[],\n\t\tpath: URI,\n\t): Promise<IEnterWorkspaceResult | undefined> {\n\t\tif (!window || !window.win || !window.isReady) {\n\t\t\treturn undefined; // return early if the window is not ready or disposed\n\t\t}\n\n\t\tconst isValid = await this.isValidTargetWorkspacePath(\n\t\t\twindow,\n\t\t\twindows,\n\t\t\tpath,\n\t\t);\n\t\tif (!isValid) {\n\t\t\treturn undefined; // return early if the workspace is not valid\n\t\t}\n\n\t\tconst result = await this.doEnterWorkspace(\n\t\t\twindow,\n\t\t\tgetWorkspaceIdentifier(path),\n\t\t);\n\t\tif (!result) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Emit as event\n\t\tthis._onDidEnterWorkspace.fire({ window, workspace: result.workspace });\n\n\t\treturn result;\n\t}\n\n\tprivate async isValidTargetWorkspacePath(\n\t\twindow: ICodeWindow,\n\t\twindows: ICodeWindow[],\n\t\tworkspacePath?: URI,\n\t): Promise<boolean> {\n\t\tif (!workspacePath) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (\n\t\t\tisWorkspaceIdentifier(window.openedWorkspace) &&\n\t\t\textUriBiasedIgnorePathCase.isEqual(\n\t\t\t\twindow.openedWorkspace.configPath,\n\t\t\t\tworkspacePath,\n\t\t\t)\n\t\t) {\n\t\t\treturn false; // window is already opened on a workspace with that path\n\t\t}\n\n\t\t// Prevent overwriting a workspace that is currently opened in another window\n\t\tif (findWindowOnWorkspaceOrFolder(windows, workspacePath)) {\n\t\t\tawait this.dialogMainService.showMessageBox(\n\t\t\t\t{\n\t\t\t\t\ttype: \"info\",\n\t\t\t\t\tbuttons: [\n\t\t\t\t\t\tlocalize(\n\t\t\t\t\t\t\t{ key: \"ok\", comment: [\"&& denotes a mnemonic\"] },\n\t\t\t\t\t\t\t\"&&OK\",\n\t\t\t\t\t\t),\n\t\t\t\t\t],\n\t\t\t\t\tmessage: localize(\n\t\t\t\t\t\t\"workspaceOpenedMessage\",\n\t\t\t\t\t\t\"Unable to save workspace '{0}'\",\n\t\t\t\t\t\tbasename(workspacePath),\n\t\t\t\t\t),\n\t\t\t\t\tdetail: localize(\n\t\t\t\t\t\t\"workspaceOpenedDetail\",\n\t\t\t\t\t\t\"The workspace is already opened in another window. Please close that window first and then try again.\",\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t\telectron.BrowserWindow.getFocusedWindow() ?? undefined,\n\t\t\t);\n\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true; // OK\n\t}\n\n\tprivate async doEnterWorkspace(\n\t\twindow: ICodeWindow,\n\t\tworkspace: IWorkspaceIdentifier,\n\t): Promise<IEnterWorkspaceResult | undefined> {\n\t\tif (!window.config) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\twindow.focus();\n\n\t\t// Register window for backups and migrate current backups over\n\t\tlet backupPath: string | undefined;\n\t\tif (!window.config.extensionDevelopmentPath) {\n\t\t\tif (window.config.backupPath) {\n\t\t\t\tbackupPath =\n\t\t\t\t\tawait this.backupMainService.registerWorkspaceBackup(\n\t\t\t\t\t\t{ workspace, remoteAuthority: window.remoteAuthority },\n\t\t\t\t\t\twindow.config.backupPath,\n\t\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tbackupPath = this.backupMainService.registerWorkspaceBackup({\n\t\t\t\t\tworkspace,\n\t\t\t\t\tremoteAuthority: window.remoteAuthority,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// if the window was opened on an untitled workspace, delete it.\n\t\tif (\n\t\t\tisWorkspaceIdentifier(window.openedWorkspace) &&\n\t\t\tthis.isUntitledWorkspace(window.openedWorkspace)\n\t\t) {\n\t\t\tawait this.deleteUntitledWorkspace(window.openedWorkspace);\n\t\t}\n\n\t\t// Update window configuration properly based on transition to workspace\n\t\twindow.config.workspace = workspace;\n\t\twindow.config.backupPath = backupPath;\n\n\t\treturn { workspace, backupPath };\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
