{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/workspaces/electron-main/workspacesManagementMainService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport electron from 'electron';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { parse } from '../../../base/common/json.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { dirname, join } from '../../../base/common/path.js';\nimport { basename, extUriBiasedIgnorePathCase, joinPath, originalFSPath } from '../../../base/common/resources.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { Promises } from '../../../base/node/pfs.js';\nimport { localize } from '../../../nls.js';\nimport { IBackupMainService } from '../../backup/electron-main/backup.js';\nimport { IDialogMainService } from '../../dialogs/electron-main/dialogMainService.js';\nimport { IEnvironmentMainService } from '../../environment/electron-main/environmentMainService.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { IUserDataProfilesMainService } from '../../userDataProfile/electron-main/userDataProfile.js';\nimport { ICodeWindow } from '../../window/electron-main/window.js';\nimport { findWindowOnWorkspaceOrFolder } from '../../windows/electron-main/windowsFinder.js';\nimport { isWorkspaceIdentifier, IWorkspaceIdentifier, IResolvedWorkspace, hasWorkspaceFileExtension, UNTITLED_WORKSPACE_NAME, isUntitledWorkspace } from '../../workspace/common/workspace.js';\nimport { getStoredWorkspaceFolder, IEnterWorkspaceResult, isStoredWorkspaceFolder, IStoredWorkspace, IStoredWorkspaceFolder, IUntitledWorkspaceInfo, IWorkspaceFolderCreationData, toWorkspaceFolders } from '../common/workspaces.js';\nimport { getWorkspaceIdentifier } from '../node/workspaces.js';\n\nexport const IWorkspacesManagementMainService = createDecorator<IWorkspacesManagementMainService>('workspacesManagementMainService');\n\nexport interface IWorkspaceEnteredEvent {\n\treadonly window: ICodeWindow;\n\treadonly workspace: IWorkspaceIdentifier;\n}\n\nexport interface IWorkspacesManagementMainService {\n\n\treadonly _serviceBrand: undefined;\n\n\treadonly onDidDeleteUntitledWorkspace: Event<IWorkspaceIdentifier>;\n\treadonly onDidEnterWorkspace: Event<IWorkspaceEnteredEvent>;\n\n\tenterWorkspace(intoWindow: ICodeWindow, openedWindows: ICodeWindow[], path: URI): Promise<IEnterWorkspaceResult | undefined>;\n\n\tcreateUntitledWorkspace(folders?: IWorkspaceFolderCreationData[], remoteAuthority?: string): Promise<IWorkspaceIdentifier>;\n\n\tdeleteUntitledWorkspace(workspace: IWorkspaceIdentifier): Promise<void>;\n\n\tgetUntitledWorkspaces(): IUntitledWorkspaceInfo[];\n\tisUntitledWorkspace(workspace: IWorkspaceIdentifier): boolean;\n\n\tresolveLocalWorkspace(path: URI): Promise<IResolvedWorkspace | undefined>;\n\n\tgetWorkspaceIdentifier(workspacePath: URI): Promise<IWorkspaceIdentifier>;\n}\n\nexport class WorkspacesManagementMainService extends Disposable implements IWorkspacesManagementMainService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly _onDidDeleteUntitledWorkspace = this._register(new Emitter<IWorkspaceIdentifier>());\n\treadonly onDidDeleteUntitledWorkspace: Event<IWorkspaceIdentifier> = this._onDidDeleteUntitledWorkspace.event;\n\n\tprivate readonly _onDidEnterWorkspace = this._register(new Emitter<IWorkspaceEnteredEvent>());\n\treadonly onDidEnterWorkspace: Event<IWorkspaceEnteredEvent> = this._onDidEnterWorkspace.event;\n\n\tprivate readonly untitledWorkspacesHome = this.environmentMainService.untitledWorkspacesHome; // local URI that contains all untitled workspaces\n\n\tprivate untitledWorkspaces: IUntitledWorkspaceInfo[] = [];\n\n\tconstructor(\n\t\t@IEnvironmentMainService private readonly environmentMainService: IEnvironmentMainService,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IUserDataProfilesMainService private readonly userDataProfilesMainService: IUserDataProfilesMainService,\n\t\t@IBackupMainService private readonly backupMainService: IBackupMainService,\n\t\t@IDialogMainService private readonly dialogMainService: IDialogMainService\n\t) {\n\t\tsuper();\n\t}\n\n\tasync initialize(): Promise<void> {\n\n\t\t// Reset\n\t\tthis.untitledWorkspaces = [];\n\n\t\t// Resolve untitled workspaces\n\t\ttry {\n\t\t\tconst untitledWorkspacePaths = (await Promises.readdir(this.untitledWorkspacesHome.with({ scheme: Schemas.file }).fsPath)).map(folder => joinPath(this.untitledWorkspacesHome, folder, UNTITLED_WORKSPACE_NAME));\n\t\t\tfor (const untitledWorkspacePath of untitledWorkspacePaths) {\n\t\t\t\tconst workspace = getWorkspaceIdentifier(untitledWorkspacePath);\n\t\t\t\tconst resolvedWorkspace = await this.resolveLocalWorkspace(untitledWorkspacePath);\n\t\t\t\tif (!resolvedWorkspace) {\n\t\t\t\t\tawait this.deleteUntitledWorkspace(workspace);\n\t\t\t\t} else {\n\t\t\t\t\tthis.untitledWorkspaces.push({ workspace, remoteAuthority: resolvedWorkspace.remoteAuthority });\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tif (error.code !== 'ENOENT') {\n\t\t\t\tthis.logService.warn(`Unable to read folders in ${this.untitledWorkspacesHome} (${error}).`);\n\t\t\t}\n\t\t}\n\t}\n\n\tresolveLocalWorkspace(uri: URI): Promise<IResolvedWorkspace | undefined> {\n\t\treturn this.doResolveLocalWorkspace(uri, path => fs.promises.readFile(path, 'utf8'));\n\t}\n\n\tprivate doResolveLocalWorkspace(uri: URI, contentsFn: (path: string) => string): IResolvedWorkspace | undefined;\n\tprivate doResolveLocalWorkspace(uri: URI, contentsFn: (path: string) => Promise<string>): Promise<IResolvedWorkspace | undefined>;\n\tprivate doResolveLocalWorkspace(uri: URI, contentsFn: (path: string) => string | Promise<string>): IResolvedWorkspace | undefined | Promise<IResolvedWorkspace | undefined> {\n\t\tif (!this.isWorkspacePath(uri)) {\n\t\t\treturn undefined; // does not look like a valid workspace config file\n\t\t}\n\n\t\tif (uri.scheme !== Schemas.file) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\ttry {\n\t\t\tconst contents = contentsFn(uri.fsPath);\n\t\t\tif (contents instanceof Promise) {\n\t\t\t\treturn contents.then(value => this.doResolveWorkspace(uri, value), error => undefined /* invalid workspace */);\n\t\t\t} else {\n\t\t\t\treturn this.doResolveWorkspace(uri, contents);\n\t\t\t}\n\t\t} catch {\n\t\t\treturn undefined; // invalid workspace\n\t\t}\n\t}\n\n\tprivate isWorkspacePath(uri: URI): boolean {\n\t\treturn isUntitledWorkspace(uri, this.environmentMainService) || hasWorkspaceFileExtension(uri);\n\t}\n\n\tprivate doResolveWorkspace(path: URI, contents: string): IResolvedWorkspace | undefined {\n\t\ttry {\n\t\t\tconst workspace = this.doParseStoredWorkspace(path, contents);\n\t\t\tconst workspaceIdentifier = getWorkspaceIdentifier(path);\n\t\t\treturn {\n\t\t\t\tid: workspaceIdentifier.id,\n\t\t\t\tconfigPath: workspaceIdentifier.configPath,\n\t\t\t\tfolders: toWorkspaceFolders(workspace.folders, workspaceIdentifier.configPath, extUriBiasedIgnorePathCase),\n\t\t\t\tremoteAuthority: workspace.remoteAuthority,\n\t\t\t\ttransient: workspace.transient\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tthis.logService.warn(error.toString());\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate doParseStoredWorkspace(path: URI, contents: string): IStoredWorkspace {\n\n\t\t// Parse workspace file\n\t\tconst storedWorkspace: IStoredWorkspace = parse(contents); // use fault tolerant parser\n\n\t\t// Filter out folders which do not have a path or uri set\n\t\tif (storedWorkspace && Array.isArray(storedWorkspace.folders)) {\n\t\t\tstoredWorkspace.folders = storedWorkspace.folders.filter(folder => isStoredWorkspaceFolder(folder));\n\t\t} else {\n\t\t\tthrow new Error(`${path.toString(true)} looks like an invalid workspace file.`);\n\t\t}\n\n\t\treturn storedWorkspace;\n\t}\n\n\tasync createUntitledWorkspace(folders?: IWorkspaceFolderCreationData[], remoteAuthority?: string): Promise<IWorkspaceIdentifier> {\n\t\tconst { workspace, storedWorkspace } = this.newUntitledWorkspace(folders, remoteAuthority);\n\t\tconst configPath = workspace.configPath.fsPath;\n\n\t\tawait fs.promises.mkdir(dirname(configPath), { recursive: true });\n\t\tawait Promises.writeFile(configPath, JSON.stringify(storedWorkspace, null, '\\t'));\n\n\t\tthis.untitledWorkspaces.push({ workspace, remoteAuthority });\n\n\t\treturn workspace;\n\t}\n\n\tprivate newUntitledWorkspace(folders: IWorkspaceFolderCreationData[] = [], remoteAuthority?: string): { workspace: IWorkspaceIdentifier; storedWorkspace: IStoredWorkspace } {\n\t\tconst randomId = (Date.now() + Math.round(Math.random() * 1000)).toString();\n\t\tconst untitledWorkspaceConfigFolder = joinPath(this.untitledWorkspacesHome, randomId);\n\t\tconst untitledWorkspaceConfigPath = joinPath(untitledWorkspaceConfigFolder, UNTITLED_WORKSPACE_NAME);\n\n\t\tconst storedWorkspaceFolder: IStoredWorkspaceFolder[] = [];\n\n\t\tfor (const folder of folders) {\n\t\t\tstoredWorkspaceFolder.push(getStoredWorkspaceFolder(folder.uri, true, folder.name, untitledWorkspaceConfigFolder, extUriBiasedIgnorePathCase));\n\t\t}\n\n\t\treturn {\n\t\t\tworkspace: getWorkspaceIdentifier(untitledWorkspaceConfigPath),\n\t\t\tstoredWorkspace: { folders: storedWorkspaceFolder, remoteAuthority }\n\t\t};\n\t}\n\n\tasync getWorkspaceIdentifier(configPath: URI): Promise<IWorkspaceIdentifier> {\n\t\treturn getWorkspaceIdentifier(configPath);\n\t}\n\n\tisUntitledWorkspace(workspace: IWorkspaceIdentifier): boolean {\n\t\treturn isUntitledWorkspace(workspace.configPath, this.environmentMainService);\n\t}\n\n\tasync deleteUntitledWorkspace(workspace: IWorkspaceIdentifier): Promise<void> {\n\t\tif (!this.isUntitledWorkspace(workspace)) {\n\t\t\treturn; // only supported for untitled workspaces\n\t\t}\n\n\t\t// Delete from disk\n\t\tawait this.doDeleteUntitledWorkspace(workspace);\n\n\t\t// unset workspace from profiles\n\t\tif (this.userDataProfilesMainService.isEnabled()) {\n\t\t\tthis.userDataProfilesMainService.unsetWorkspace(workspace);\n\t\t}\n\n\t\t// Event\n\t\tthis._onDidDeleteUntitledWorkspace.fire(workspace);\n\t}\n\n\tprivate async doDeleteUntitledWorkspace(workspace: IWorkspaceIdentifier): Promise<void> {\n\t\tconst configPath = originalFSPath(workspace.configPath);\n\t\ttry {\n\n\t\t\t// Delete Workspace\n\t\t\tawait Promises.rm(dirname(configPath));\n\n\t\t\t// Mark Workspace Storage to be deleted\n\t\t\tconst workspaceStoragePath = join(this.environmentMainService.workspaceStorageHome.with({ scheme: Schemas.file }).fsPath, workspace.id);\n\t\t\tif (await Promises.exists(workspaceStoragePath)) {\n\t\t\t\tawait Promises.writeFile(join(workspaceStoragePath, 'obsolete'), '');\n\t\t\t}\n\n\t\t\t// Remove from list\n\t\t\tthis.untitledWorkspaces = this.untitledWorkspaces.filter(untitledWorkspace => untitledWorkspace.workspace.id !== workspace.id);\n\t\t} catch (error) {\n\t\t\tthis.logService.warn(`Unable to delete untitled workspace ${configPath} (${error}).`);\n\t\t}\n\t}\n\n\tgetUntitledWorkspaces(): IUntitledWorkspaceInfo[] {\n\t\treturn this.untitledWorkspaces;\n\t}\n\n\tasync enterWorkspace(window: ICodeWindow, windows: ICodeWindow[], path: URI): Promise<IEnterWorkspaceResult | undefined> {\n\t\tif (!window || !window.win || !window.isReady) {\n\t\t\treturn undefined; // return early if the window is not ready or disposed\n\t\t}\n\n\t\tconst isValid = await this.isValidTargetWorkspacePath(window, windows, path);\n\t\tif (!isValid) {\n\t\t\treturn undefined; // return early if the workspace is not valid\n\t\t}\n\n\t\tconst result = await this.doEnterWorkspace(window, getWorkspaceIdentifier(path));\n\t\tif (!result) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Emit as event\n\t\tthis._onDidEnterWorkspace.fire({ window, workspace: result.workspace });\n\n\t\treturn result;\n\t}\n\n\tprivate async isValidTargetWorkspacePath(window: ICodeWindow, windows: ICodeWindow[], workspacePath?: URI): Promise<boolean> {\n\t\tif (!workspacePath) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (isWorkspaceIdentifier(window.openedWorkspace) && extUriBiasedIgnorePathCase.isEqual(window.openedWorkspace.configPath, workspacePath)) {\n\t\t\treturn false; // window is already opened on a workspace with that path\n\t\t}\n\n\t\t// Prevent overwriting a workspace that is currently opened in another window\n\t\tif (findWindowOnWorkspaceOrFolder(windows, workspacePath)) {\n\t\t\tawait this.dialogMainService.showMessageBox({\n\t\t\t\ttype: 'info',\n\t\t\t\tbuttons: [localize({ key: 'ok', comment: ['&& denotes a mnemonic'] }, \"&&OK\")],\n\t\t\t\tmessage: localize('workspaceOpenedMessage', \"Unable to save workspace '{0}'\", basename(workspacePath)),\n\t\t\t\tdetail: localize('workspaceOpenedDetail', \"The workspace is already opened in another window. Please close that window first and then try again.\")\n\t\t\t}, electron.BrowserWindow.getFocusedWindow() ?? undefined);\n\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true; // OK\n\t}\n\n\tprivate async doEnterWorkspace(window: ICodeWindow, workspace: IWorkspaceIdentifier): Promise<IEnterWorkspaceResult | undefined> {\n\t\tif (!window.config) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\twindow.focus();\n\n\t\t// Register window for backups and migrate current backups over\n\t\tlet backupPath: string | undefined;\n\t\tif (!window.config.extensionDevelopmentPath) {\n\t\t\tif (window.config.backupPath) {\n\t\t\t\tbackupPath = await this.backupMainService.registerWorkspaceBackup({ workspace, remoteAuthority: window.remoteAuthority }, window.config.backupPath);\n\t\t\t} else {\n\t\t\t\tbackupPath = this.backupMainService.registerWorkspaceBackup({ workspace, remoteAuthority: window.remoteAuthority });\n\t\t\t}\n\t\t}\n\n\t\t// if the window was opened on an untitled workspace, delete it.\n\t\tif (isWorkspaceIdentifier(window.openedWorkspace) && this.isUntitledWorkspace(window.openedWorkspace)) {\n\t\t\tawait this.deleteUntitledWorkspace(window.openedWorkspace);\n\t\t}\n\n\t\t// Update window configuration properly based on transition to workspace\n\t\twindow.config.workspace = workspace;\n\t\twindow.config.backupPath = backupPath;\n\n\t\treturn { workspace, backupPath };\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
