{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/workspaces/common/workspaces.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../../base/common/event.js';\nimport { isUNC, toSlashes } from '../../../base/common/extpath.js';\nimport * as json from '../../../base/common/json.js';\nimport * as jsonEdit from '../../../base/common/jsonEdit.js';\nimport { FormattingOptions } from '../../../base/common/jsonFormatter.js';\nimport { normalizeDriveLetter } from '../../../base/common/labels.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { isAbsolute, posix } from '../../../base/common/path.js';\nimport { isLinux, isMacintosh, isWindows } from '../../../base/common/platform.js';\nimport { IExtUri, isEqualAuthority } from '../../../base/common/resources.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { IWorkspaceBackupInfo, IFolderBackupInfo } from '../../backup/common/backup.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { getRemoteAuthority } from '../../remote/common/remoteHosts.js';\nimport { IBaseWorkspace, IRawFileWorkspaceFolder, IRawUriWorkspaceFolder, IWorkspaceIdentifier, WorkspaceFolder } from '../../workspace/common/workspace.js';\n\nexport const IWorkspacesService = createDecorator<IWorkspacesService>('workspacesService');\n\nexport interface IWorkspacesService {\n\n\treadonly _serviceBrand: undefined;\n\n\t// Workspaces Management\n\tenterWorkspace(workspaceUri: URI): Promise<IEnterWorkspaceResult | undefined>;\n\tcreateUntitledWorkspace(folders?: IWorkspaceFolderCreationData[], remoteAuthority?: string): Promise<IWorkspaceIdentifier>;\n\tdeleteUntitledWorkspace(workspace: IWorkspaceIdentifier): Promise<void>;\n\tgetWorkspaceIdentifier(workspaceUri: URI): Promise<IWorkspaceIdentifier>;\n\n\t// Workspaces History\n\treadonly onDidChangeRecentlyOpened: Event<void>;\n\taddRecentlyOpened(recents: IRecent[]): Promise<void>;\n\tremoveRecentlyOpened(workspaces: URI[]): Promise<void>;\n\tclearRecentlyOpened(): Promise<void>;\n\tgetRecentlyOpened(): Promise<IRecentlyOpened>;\n\n\t// Dirty Workspaces\n\tgetDirtyWorkspaces(): Promise<Array<IWorkspaceBackupInfo | IFolderBackupInfo>>;\n}\n\n//#region Workspaces Recently Opened\n\nexport interface IRecentlyOpened {\n\tworkspaces: Array<IRecentWorkspace | IRecentFolder>;\n\tfiles: IRecentFile[];\n}\n\nexport type IRecent = IRecentWorkspace | IRecentFolder | IRecentFile;\n\nexport interface IRecentWorkspace {\n\treadonly workspace: IWorkspaceIdentifier;\n\tlabel?: string;\n\treadonly remoteAuthority?: string;\n}\n\nexport interface IRecentFolder {\n\treadonly folderUri: URI;\n\tlabel?: string;\n\treadonly remoteAuthority?: string;\n}\n\nexport interface IRecentFile {\n\treadonly fileUri: URI;\n\tlabel?: string;\n\treadonly remoteAuthority?: string;\n}\n\nexport function isRecentWorkspace(curr: IRecent): curr is IRecentWorkspace {\n\treturn curr.hasOwnProperty('workspace');\n}\n\nexport function isRecentFolder(curr: IRecent): curr is IRecentFolder {\n\treturn curr.hasOwnProperty('folderUri');\n}\n\nexport function isRecentFile(curr: IRecent): curr is IRecentFile {\n\treturn curr.hasOwnProperty('fileUri');\n}\n\n//#endregion\n\n//#region Workspace File Utilities\n\nexport function isStoredWorkspaceFolder(obj: unknown): obj is IStoredWorkspaceFolder {\n\treturn isRawFileWorkspaceFolder(obj) || isRawUriWorkspaceFolder(obj);\n}\n\nfunction isRawFileWorkspaceFolder(obj: unknown): obj is IRawFileWorkspaceFolder {\n\tconst candidate = obj as IRawFileWorkspaceFolder | undefined;\n\n\treturn typeof candidate?.path === 'string' && (!candidate.name || typeof candidate.name === 'string');\n}\n\nfunction isRawUriWorkspaceFolder(obj: unknown): obj is IRawUriWorkspaceFolder {\n\tconst candidate = obj as IRawUriWorkspaceFolder | undefined;\n\n\treturn typeof candidate?.uri === 'string' && (!candidate.name || typeof candidate.name === 'string');\n}\n\nexport type IStoredWorkspaceFolder = IRawFileWorkspaceFolder | IRawUriWorkspaceFolder;\n\nexport interface IStoredWorkspace extends IBaseWorkspace {\n\tfolders: IStoredWorkspaceFolder[];\n}\n\nexport interface IWorkspaceFolderCreationData {\n\treadonly uri: URI;\n\treadonly name?: string;\n}\n\nexport interface IUntitledWorkspaceInfo {\n\treadonly workspace: IWorkspaceIdentifier;\n\treadonly remoteAuthority?: string;\n}\n\nexport interface IEnterWorkspaceResult {\n\treadonly workspace: IWorkspaceIdentifier;\n\treadonly backupPath?: string;\n}\n\n/**\n * Given a folder URI and the workspace config folder, computes the `IStoredWorkspaceFolder`\n * using a relative or absolute path or a uri.\n * Undefined is returned if the `folderURI` and the `targetConfigFolderURI` don't have the\n * same schema or authority.\n *\n * @param folderURI a workspace folder\n * @param forceAbsolute if set, keep the path absolute\n * @param folderName a workspace name\n * @param targetConfigFolderURI the folder where the workspace is living in\n */\nexport function getStoredWorkspaceFolder(folderURI: URI, forceAbsolute: boolean, folderName: string | undefined, targetConfigFolderURI: URI, extUri: IExtUri): IStoredWorkspaceFolder {\n\n\t// Scheme mismatch: use full absolute URI as `uri`\n\tif (folderURI.scheme !== targetConfigFolderURI.scheme) {\n\t\treturn { name: folderName, uri: folderURI.toString(true) };\n\t}\n\n\t// Always prefer a relative path if possible unless\n\t// prevented to make the workspace file shareable\n\t// with other users\n\tlet folderPath = !forceAbsolute ? extUri.relativePath(targetConfigFolderURI, folderURI) : undefined;\n\tif (folderPath !== undefined) {\n\t\tif (folderPath.length === 0) {\n\t\t\tfolderPath = '.';\n\t\t} else {\n\t\t\tif (isWindows) {\n\t\t\t\tfolderPath = massagePathForWindows(folderPath);\n\t\t\t}\n\t\t}\n\t}\n\n\t// We could not resolve a relative path\n\telse {\n\n\t\t// Local file: use `fsPath`\n\t\tif (folderURI.scheme === Schemas.file) {\n\t\t\tfolderPath = folderURI.fsPath;\n\t\t\tif (isWindows) {\n\t\t\t\tfolderPath = massagePathForWindows(folderPath);\n\t\t\t}\n\t\t}\n\n\t\t// Different authority: use full absolute URI\n\t\telse if (!extUri.isEqualAuthority(folderURI.authority, targetConfigFolderURI.authority)) {\n\t\t\treturn { name: folderName, uri: folderURI.toString(true) };\n\t\t}\n\n\t\t// Non-local file: use `path` of URI\n\t\telse {\n\t\t\tfolderPath = folderURI.path;\n\t\t}\n\t}\n\n\treturn { name: folderName, path: folderPath };\n}\n\nfunction massagePathForWindows(folderPath: string) {\n\n\t// Drive letter should be upper case\n\tfolderPath = normalizeDriveLetter(folderPath);\n\n\t// Always prefer slash over backslash unless\n\t// we deal with UNC paths where backslash is\n\t// mandatory.\n\tif (!isUNC(folderPath)) {\n\t\tfolderPath = toSlashes(folderPath);\n\t}\n\n\treturn folderPath;\n}\n\nexport function toWorkspaceFolders(configuredFolders: IStoredWorkspaceFolder[], workspaceConfigFile: URI, extUri: IExtUri): WorkspaceFolder[] {\n\tconst result: WorkspaceFolder[] = [];\n\tconst seen: Set<string> = new Set();\n\n\tconst relativeTo = extUri.dirname(workspaceConfigFile);\n\tfor (const configuredFolder of configuredFolders) {\n\t\tlet uri: URI | undefined = undefined;\n\t\tif (isRawFileWorkspaceFolder(configuredFolder)) {\n\t\t\tif (configuredFolder.path) {\n\t\t\t\turi = extUri.resolvePath(relativeTo, configuredFolder.path);\n\t\t\t}\n\t\t} else if (isRawUriWorkspaceFolder(configuredFolder)) {\n\t\t\ttry {\n\t\t\t\turi = URI.parse(configuredFolder.uri);\n\t\t\t\tif (uri.path[0] !== posix.sep) {\n\t\t\t\t\turi = uri.with({ path: posix.sep + uri.path }); // this makes sure all workspace folder are absolute\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tconsole.warn(e); // ignore\n\t\t\t}\n\t\t}\n\n\t\tif (uri) {\n\n\t\t\t// remove duplicates\n\t\t\tconst comparisonKey = extUri.getComparisonKey(uri);\n\t\t\tif (!seen.has(comparisonKey)) {\n\t\t\t\tseen.add(comparisonKey);\n\n\t\t\t\tconst name = configuredFolder.name || extUri.basenameOrAuthority(uri);\n\t\t\t\tresult.push(new WorkspaceFolder({ uri, name, index: result.length }, configuredFolder));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Rewrites the content of a workspace file to be saved at a new location.\n * Throws an exception if file is not a valid workspace file\n */\nexport function rewriteWorkspaceFileForNewLocation(rawWorkspaceContents: string, configPathURI: URI, isFromUntitledWorkspace: boolean, targetConfigPathURI: URI, extUri: IExtUri) {\n\tconst storedWorkspace = doParseStoredWorkspace(configPathURI, rawWorkspaceContents);\n\n\tconst sourceConfigFolder = extUri.dirname(configPathURI);\n\tconst targetConfigFolder = extUri.dirname(targetConfigPathURI);\n\n\tconst rewrittenFolders: IStoredWorkspaceFolder[] = [];\n\n\tfor (const folder of storedWorkspace.folders) {\n\t\tconst folderURI = isRawFileWorkspaceFolder(folder) ? extUri.resolvePath(sourceConfigFolder, folder.path) : URI.parse(folder.uri);\n\t\tlet absolute;\n\t\tif (isFromUntitledWorkspace) {\n\t\t\tabsolute = false; // if it was an untitled workspace, try to make paths relative\n\t\t} else {\n\t\t\tabsolute = !isRawFileWorkspaceFolder(folder) || isAbsolute(folder.path); // for existing workspaces, preserve whether a path was absolute or relative\n\t\t}\n\t\trewrittenFolders.push(getStoredWorkspaceFolder(folderURI, absolute, folder.name, targetConfigFolder, extUri));\n\t}\n\n\t// Preserve as much of the existing workspace as possible by using jsonEdit\n\t// and only changing the folders portion.\n\tconst formattingOptions: FormattingOptions = { insertSpaces: false, tabSize: 4, eol: (isLinux || isMacintosh) ? '\\n' : '\\r\\n' };\n\tconst edits = jsonEdit.setProperty(rawWorkspaceContents, ['folders'], rewrittenFolders, formattingOptions);\n\tlet newContent = jsonEdit.applyEdits(rawWorkspaceContents, edits);\n\n\tif (isEqualAuthority(storedWorkspace.remoteAuthority, getRemoteAuthority(targetConfigPathURI))) {\n\t\t// unsaved remote workspaces have the remoteAuthority set. Remove it when no longer nexessary.\n\t\tnewContent = jsonEdit.applyEdits(newContent, jsonEdit.removeProperty(newContent, ['remoteAuthority'], formattingOptions));\n\t}\n\n\treturn newContent;\n}\n\nfunction doParseStoredWorkspace(path: URI, contents: string): IStoredWorkspace {\n\n\t// Parse workspace file\n\tconst storedWorkspace: IStoredWorkspace = json.parse(contents); // use fault tolerant parser\n\n\t// Filter out folders which do not have a path or uri set\n\tif (storedWorkspace && Array.isArray(storedWorkspace.folders)) {\n\t\tstoredWorkspace.folders = storedWorkspace.folders.filter(folder => isStoredWorkspaceFolder(folder));\n\t} else {\n\t\tthrow new Error(`${path} looks like an invalid workspace file.`);\n\t}\n\n\treturn storedWorkspace;\n}\n\n//#endregion\n\n//#region Workspace Storage\n\ninterface ISerializedRecentWorkspace {\n\treadonly workspace: {\n\t\tid: string;\n\t\tconfigPath: string;\n\t};\n\treadonly label?: string;\n\treadonly remoteAuthority?: string;\n}\n\ninterface ISerializedRecentFolder {\n\treadonly folderUri: string;\n\treadonly label?: string;\n\treadonly remoteAuthority?: string;\n}\n\ninterface ISerializedRecentFile {\n\treadonly fileUri: string;\n\treadonly label?: string;\n\treadonly remoteAuthority?: string;\n}\n\ninterface ISerializedRecentlyOpened {\n\treadonly entries: Array<ISerializedRecentWorkspace | ISerializedRecentFolder | ISerializedRecentFile>; // since 1.55\n}\n\nexport type RecentlyOpenedStorageData = object;\n\nfunction isSerializedRecentWorkspace(data: any): data is ISerializedRecentWorkspace {\n\treturn data.workspace && typeof data.workspace === 'object' && typeof data.workspace.id === 'string' && typeof data.workspace.configPath === 'string';\n}\n\nfunction isSerializedRecentFolder(data: any): data is ISerializedRecentFolder {\n\treturn typeof data.folderUri === 'string';\n}\n\nfunction isSerializedRecentFile(data: any): data is ISerializedRecentFile {\n\treturn typeof data.fileUri === 'string';\n}\n\nexport function restoreRecentlyOpened(data: RecentlyOpenedStorageData | undefined, logService: ILogService): IRecentlyOpened {\n\tconst result: IRecentlyOpened = { workspaces: [], files: [] };\n\tif (data) {\n\t\tconst restoreGracefully = function <T>(entries: T[], onEntry: (entry: T, index: number) => void) {\n\t\t\tfor (let i = 0; i < entries.length; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tonEntry(entries[i], i);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tlogService.warn(`Error restoring recent entry ${JSON.stringify(entries[i])}: ${e.toString()}. Skip entry.`);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tconst storedRecents = data as ISerializedRecentlyOpened;\n\t\tif (Array.isArray(storedRecents.entries)) {\n\t\t\trestoreGracefully(storedRecents.entries, entry => {\n\t\t\t\tconst label = entry.label;\n\t\t\t\tconst remoteAuthority = entry.remoteAuthority;\n\n\t\t\t\tif (isSerializedRecentWorkspace(entry)) {\n\t\t\t\t\tresult.workspaces.push({ label, remoteAuthority, workspace: { id: entry.workspace.id, configPath: URI.parse(entry.workspace.configPath) } });\n\t\t\t\t} else if (isSerializedRecentFolder(entry)) {\n\t\t\t\t\tresult.workspaces.push({ label, remoteAuthority, folderUri: URI.parse(entry.folderUri) });\n\t\t\t\t} else if (isSerializedRecentFile(entry)) {\n\t\t\t\t\tresult.files.push({ label, remoteAuthority, fileUri: URI.parse(entry.fileUri) });\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport function toStoreData(recents: IRecentlyOpened): RecentlyOpenedStorageData {\n\tconst serialized: ISerializedRecentlyOpened = { entries: [] };\n\n\tfor (const recent of recents.workspaces) {\n\t\tif (isRecentFolder(recent)) {\n\t\t\tserialized.entries.push({ folderUri: recent.folderUri.toString(), label: recent.label, remoteAuthority: recent.remoteAuthority });\n\t\t} else {\n\t\t\tserialized.entries.push({ workspace: { id: recent.workspace.id, configPath: recent.workspace.configPath.toString() }, label: recent.label, remoteAuthority: recent.remoteAuthority });\n\t\t}\n\t}\n\n\tfor (const recent of recents.files) {\n\t\tserialized.entries.push({ fileUri: recent.fileUri.toString(), label: recent.label, remoteAuthority: recent.remoteAuthority });\n\t}\n\n\treturn serialized;\n}\n\n//#endregion\n"],
  "mappings": "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",
  "names": []
}
