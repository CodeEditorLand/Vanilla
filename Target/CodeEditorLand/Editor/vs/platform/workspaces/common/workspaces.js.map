{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/workspaces/common/workspaces.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { Event } from \"../../../base/common/event.js\";\nimport { isUNC, toSlashes } from \"../../../base/common/extpath.js\";\nimport * as json from \"../../../base/common/json.js\";\nimport * as jsonEdit from \"../../../base/common/jsonEdit.js\";\nimport type { FormattingOptions } from \"../../../base/common/jsonFormatter.js\";\nimport { normalizeDriveLetter } from \"../../../base/common/labels.js\";\nimport { Schemas } from \"../../../base/common/network.js\";\nimport { isAbsolute, posix } from \"../../../base/common/path.js\";\nimport {\n\tisLinux,\n\tisMacintosh,\n\tisWindows,\n} from \"../../../base/common/platform.js\";\nimport {\n\ttype IExtUri,\n\tisEqualAuthority,\n} from \"../../../base/common/resources.js\";\nimport { URI } from \"../../../base/common/uri.js\";\nimport type {\n\tIFolderBackupInfo,\n\tIWorkspaceBackupInfo,\n} from \"../../backup/common/backup.js\";\nimport { createDecorator } from \"../../instantiation/common/instantiation.js\";\nimport type { ILogService } from \"../../log/common/log.js\";\nimport { getRemoteAuthority } from \"../../remote/common/remoteHosts.js\";\nimport {\n\ttype IBaseWorkspace,\n\ttype IRawFileWorkspaceFolder,\n\ttype IRawUriWorkspaceFolder,\n\ttype IWorkspaceIdentifier,\n\tWorkspaceFolder,\n} from \"../../workspace/common/workspace.js\";\n\nexport const IWorkspacesService =\n\tcreateDecorator<IWorkspacesService>(\"workspacesService\");\n\nexport interface IWorkspacesService {\n\treadonly _serviceBrand: undefined;\n\n\t// Workspaces Management\n\tenterWorkspace(\n\t\tworkspaceUri: URI,\n\t): Promise<IEnterWorkspaceResult | undefined>;\n\tcreateUntitledWorkspace(\n\t\tfolders?: IWorkspaceFolderCreationData[],\n\t\tremoteAuthority?: string,\n\t): Promise<IWorkspaceIdentifier>;\n\tdeleteUntitledWorkspace(workspace: IWorkspaceIdentifier): Promise<void>;\n\tgetWorkspaceIdentifier(workspaceUri: URI): Promise<IWorkspaceIdentifier>;\n\n\t// Workspaces History\n\treadonly onDidChangeRecentlyOpened: Event<void>;\n\taddRecentlyOpened(recents: IRecent[]): Promise<void>;\n\tremoveRecentlyOpened(workspaces: URI[]): Promise<void>;\n\tclearRecentlyOpened(): Promise<void>;\n\tgetRecentlyOpened(): Promise<IRecentlyOpened>;\n\n\t// Dirty Workspaces\n\tgetDirtyWorkspaces(): Promise<\n\t\tArray<IWorkspaceBackupInfo | IFolderBackupInfo>\n\t>;\n}\n\n//#region Workspaces Recently Opened\n\nexport interface IRecentlyOpened {\n\tworkspaces: Array<IRecentWorkspace | IRecentFolder>;\n\tfiles: IRecentFile[];\n}\n\nexport type IRecent = IRecentWorkspace | IRecentFolder | IRecentFile;\n\nexport interface IRecentWorkspace {\n\treadonly workspace: IWorkspaceIdentifier;\n\tlabel?: string;\n\treadonly remoteAuthority?: string;\n}\n\nexport interface IRecentFolder {\n\treadonly folderUri: URI;\n\tlabel?: string;\n\treadonly remoteAuthority?: string;\n}\n\nexport interface IRecentFile {\n\treadonly fileUri: URI;\n\tlabel?: string;\n\treadonly remoteAuthority?: string;\n}\n\nexport function isRecentWorkspace(curr: IRecent): curr is IRecentWorkspace {\n\treturn curr.hasOwnProperty(\"workspace\");\n}\n\nexport function isRecentFolder(curr: IRecent): curr is IRecentFolder {\n\treturn curr.hasOwnProperty(\"folderUri\");\n}\n\nexport function isRecentFile(curr: IRecent): curr is IRecentFile {\n\treturn curr.hasOwnProperty(\"fileUri\");\n}\n\n//#endregion\n\n//#region Workspace File Utilities\n\nexport function isStoredWorkspaceFolder(\n\tobj: unknown,\n): obj is IStoredWorkspaceFolder {\n\treturn isRawFileWorkspaceFolder(obj) || isRawUriWorkspaceFolder(obj);\n}\n\nfunction isRawFileWorkspaceFolder(\n\tobj: unknown,\n): obj is IRawFileWorkspaceFolder {\n\tconst candidate = obj as IRawFileWorkspaceFolder | undefined;\n\n\treturn (\n\t\ttypeof candidate?.path === \"string\" &&\n\t\t(!candidate.name || typeof candidate.name === \"string\")\n\t);\n}\n\nfunction isRawUriWorkspaceFolder(obj: unknown): obj is IRawUriWorkspaceFolder {\n\tconst candidate = obj as IRawUriWorkspaceFolder | undefined;\n\n\treturn (\n\t\ttypeof candidate?.uri === \"string\" &&\n\t\t(!candidate.name || typeof candidate.name === \"string\")\n\t);\n}\n\nexport type IStoredWorkspaceFolder =\n\t| IRawFileWorkspaceFolder\n\t| IRawUriWorkspaceFolder;\n\nexport interface IStoredWorkspace extends IBaseWorkspace {\n\tfolders: IStoredWorkspaceFolder[];\n}\n\nexport interface IWorkspaceFolderCreationData {\n\treadonly uri: URI;\n\treadonly name?: string;\n}\n\nexport interface IUntitledWorkspaceInfo {\n\treadonly workspace: IWorkspaceIdentifier;\n\treadonly remoteAuthority?: string;\n}\n\nexport interface IEnterWorkspaceResult {\n\treadonly workspace: IWorkspaceIdentifier;\n\treadonly backupPath?: string;\n}\n\n/**\n * Given a folder URI and the workspace config folder, computes the `IStoredWorkspaceFolder`\n * using a relative or absolute path or a uri.\n * Undefined is returned if the `folderURI` and the `targetConfigFolderURI` don't have the\n * same schema or authority.\n *\n * @param folderURI a workspace folder\n * @param forceAbsolute if set, keep the path absolute\n * @param folderName a workspace name\n * @param targetConfigFolderURI the folder where the workspace is living in\n */\nexport function getStoredWorkspaceFolder(\n\tfolderURI: URI,\n\tforceAbsolute: boolean,\n\tfolderName: string | undefined,\n\ttargetConfigFolderURI: URI,\n\textUri: IExtUri,\n): IStoredWorkspaceFolder {\n\t// Scheme mismatch: use full absolute URI as `uri`\n\tif (folderURI.scheme !== targetConfigFolderURI.scheme) {\n\t\treturn { name: folderName, uri: folderURI.toString(true) };\n\t}\n\n\t// Always prefer a relative path if possible unless\n\t// prevented to make the workspace file shareable\n\t// with other users\n\tlet folderPath = forceAbsolute\n\t\t? undefined\n\t\t: extUri.relativePath(targetConfigFolderURI, folderURI);\n\tif (folderPath !== undefined) {\n\t\tif (folderPath.length === 0) {\n\t\t\tfolderPath = \".\";\n\t\t} else if (isWindows) {\n\t\t\tfolderPath = massagePathForWindows(folderPath);\n\t\t}\n\t}\n\n\t// We could not resolve a relative path\n\telse {\n\t\t// Local file: use `fsPath`\n\t\tif (folderURI.scheme === Schemas.file) {\n\t\t\tfolderPath = folderURI.fsPath;\n\t\t\tif (isWindows) {\n\t\t\t\tfolderPath = massagePathForWindows(folderPath);\n\t\t\t}\n\t\t}\n\n\t\t// Different authority: use full absolute URI\n\t\telse if (\n\t\t\textUri.isEqualAuthority(\n\t\t\t\tfolderURI.authority,\n\t\t\t\ttargetConfigFolderURI.authority,\n\t\t\t)\n\t\t) {\n\t\t\tfolderPath = folderURI.path;\n\t\t} else {\n\t\t\treturn { name: folderName, uri: folderURI.toString(true) };\n\t\t}\n\t}\n\n\treturn { name: folderName, path: folderPath };\n}\n\nfunction massagePathForWindows(folderPath: string) {\n\t// Drive letter should be upper case\n\tfolderPath = normalizeDriveLetter(folderPath);\n\n\t// Always prefer slash over backslash unless\n\t// we deal with UNC paths where backslash is\n\t// mandatory.\n\tif (!isUNC(folderPath)) {\n\t\tfolderPath = toSlashes(folderPath);\n\t}\n\n\treturn folderPath;\n}\n\nexport function toWorkspaceFolders(\n\tconfiguredFolders: IStoredWorkspaceFolder[],\n\tworkspaceConfigFile: URI,\n\textUri: IExtUri,\n): WorkspaceFolder[] {\n\tconst result: WorkspaceFolder[] = [];\n\tconst seen: Set<string> = new Set();\n\n\tconst relativeTo = extUri.dirname(workspaceConfigFile);\n\tfor (const configuredFolder of configuredFolders) {\n\t\tlet uri: URI | undefined;\n\t\tif (isRawFileWorkspaceFolder(configuredFolder)) {\n\t\t\tif (configuredFolder.path) {\n\t\t\t\turi = extUri.resolvePath(relativeTo, configuredFolder.path);\n\t\t\t}\n\t\t} else if (isRawUriWorkspaceFolder(configuredFolder)) {\n\t\t\ttry {\n\t\t\t\turi = URI.parse(configuredFolder.uri);\n\t\t\t\tif (uri.path[0] !== posix.sep) {\n\t\t\t\t\turi = uri.with({ path: posix.sep + uri.path }); // this makes sure all workspace folder are absolute\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tconsole.warn(e); // ignore\n\t\t\t}\n\t\t}\n\n\t\tif (uri) {\n\t\t\t// remove duplicates\n\t\t\tconst comparisonKey = extUri.getComparisonKey(uri);\n\t\t\tif (!seen.has(comparisonKey)) {\n\t\t\t\tseen.add(comparisonKey);\n\n\t\t\t\tconst name =\n\t\t\t\t\tconfiguredFolder.name || extUri.basenameOrAuthority(uri);\n\t\t\t\tresult.push(\n\t\t\t\t\tnew WorkspaceFolder(\n\t\t\t\t\t\t{ uri, name, index: result.length },\n\t\t\t\t\t\tconfiguredFolder,\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Rewrites the content of a workspace file to be saved at a new location.\n * Throws an exception if file is not a valid workspace file\n */\nexport function rewriteWorkspaceFileForNewLocation(\n\trawWorkspaceContents: string,\n\tconfigPathURI: URI,\n\tisFromUntitledWorkspace: boolean,\n\ttargetConfigPathURI: URI,\n\textUri: IExtUri,\n) {\n\tconst storedWorkspace = doParseStoredWorkspace(\n\t\tconfigPathURI,\n\t\trawWorkspaceContents,\n\t);\n\n\tconst sourceConfigFolder = extUri.dirname(configPathURI);\n\tconst targetConfigFolder = extUri.dirname(targetConfigPathURI);\n\n\tconst rewrittenFolders: IStoredWorkspaceFolder[] = [];\n\n\tfor (const folder of storedWorkspace.folders) {\n\t\tconst folderURI = isRawFileWorkspaceFolder(folder)\n\t\t\t? extUri.resolvePath(sourceConfigFolder, folder.path)\n\t\t\t: URI.parse(folder.uri);\n\t\tlet absolute;\n\t\tif (isFromUntitledWorkspace) {\n\t\t\tabsolute = false; // if it was an untitled workspace, try to make paths relative\n\t\t} else {\n\t\t\tabsolute =\n\t\t\t\t!isRawFileWorkspaceFolder(folder) || isAbsolute(folder.path); // for existing workspaces, preserve whether a path was absolute or relative\n\t\t}\n\t\trewrittenFolders.push(\n\t\t\tgetStoredWorkspaceFolder(\n\t\t\t\tfolderURI,\n\t\t\t\tabsolute,\n\t\t\t\tfolder.name,\n\t\t\t\ttargetConfigFolder,\n\t\t\t\textUri,\n\t\t\t),\n\t\t);\n\t}\n\n\t// Preserve as much of the existing workspace as possible by using jsonEdit\n\t// and only changing the folders portion.\n\tconst formattingOptions: FormattingOptions = {\n\t\tinsertSpaces: false,\n\t\ttabSize: 4,\n\t\teol: isLinux || isMacintosh ? \"\\n\" : \"\\r\\n\",\n\t};\n\tconst edits = jsonEdit.setProperty(\n\t\trawWorkspaceContents,\n\t\t[\"folders\"],\n\t\trewrittenFolders,\n\t\tformattingOptions,\n\t);\n\tlet newContent = jsonEdit.applyEdits(rawWorkspaceContents, edits);\n\n\tif (\n\t\tisEqualAuthority(\n\t\t\tstoredWorkspace.remoteAuthority,\n\t\t\tgetRemoteAuthority(targetConfigPathURI),\n\t\t)\n\t) {\n\t\t// unsaved remote workspaces have the remoteAuthority set. Remove it when no longer nexessary.\n\t\tnewContent = jsonEdit.applyEdits(\n\t\t\tnewContent,\n\t\t\tjsonEdit.removeProperty(\n\t\t\t\tnewContent,\n\t\t\t\t[\"remoteAuthority\"],\n\t\t\t\tformattingOptions,\n\t\t\t),\n\t\t);\n\t}\n\n\treturn newContent;\n}\n\nfunction doParseStoredWorkspace(path: URI, contents: string): IStoredWorkspace {\n\t// Parse workspace file\n\tconst storedWorkspace: IStoredWorkspace = json.parse(contents); // use fault tolerant parser\n\n\t// Filter out folders which do not have a path or uri set\n\tif (storedWorkspace && Array.isArray(storedWorkspace.folders)) {\n\t\tstoredWorkspace.folders = storedWorkspace.folders.filter((folder) =>\n\t\t\tisStoredWorkspaceFolder(folder),\n\t\t);\n\t} else {\n\t\tthrow new Error(`${path} looks like an invalid workspace file.`);\n\t}\n\n\treturn storedWorkspace;\n}\n\n//#endregion\n\n//#region Workspace Storage\n\ninterface ISerializedRecentWorkspace {\n\treadonly workspace: {\n\t\tid: string;\n\t\tconfigPath: string;\n\t};\n\treadonly label?: string;\n\treadonly remoteAuthority?: string;\n}\n\ninterface ISerializedRecentFolder {\n\treadonly folderUri: string;\n\treadonly label?: string;\n\treadonly remoteAuthority?: string;\n}\n\ninterface ISerializedRecentFile {\n\treadonly fileUri: string;\n\treadonly label?: string;\n\treadonly remoteAuthority?: string;\n}\n\ninterface ISerializedRecentlyOpened {\n\treadonly entries: Array<\n\t\t| ISerializedRecentWorkspace\n\t\t| ISerializedRecentFolder\n\t\t| ISerializedRecentFile\n\t>; // since 1.55\n}\n\nexport type RecentlyOpenedStorageData = object;\n\nfunction isSerializedRecentWorkspace(\n\tdata: any,\n): data is ISerializedRecentWorkspace {\n\treturn (\n\t\tdata.workspace &&\n\t\ttypeof data.workspace === \"object\" &&\n\t\ttypeof data.workspace.id === \"string\" &&\n\t\ttypeof data.workspace.configPath === \"string\"\n\t);\n}\n\nfunction isSerializedRecentFolder(data: any): data is ISerializedRecentFolder {\n\treturn typeof data.folderUri === \"string\";\n}\n\nfunction isSerializedRecentFile(data: any): data is ISerializedRecentFile {\n\treturn typeof data.fileUri === \"string\";\n}\n\nexport function restoreRecentlyOpened(\n\tdata: RecentlyOpenedStorageData | undefined,\n\tlogService: ILogService,\n): IRecentlyOpened {\n\tconst result: IRecentlyOpened = { workspaces: [], files: [] };\n\tif (data) {\n\t\tconst restoreGracefully = <T>(\n\t\t\tentries: T[],\n\t\t\tonEntry: (entry: T, index: number) => void,\n\t\t) => {\n\t\t\tfor (let i = 0; i < entries.length; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tonEntry(entries[i], i);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tlogService.warn(\n\t\t\t\t\t\t`Error restoring recent entry ${JSON.stringify(entries[i])}: ${e.toString()}. Skip entry.`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tconst storedRecents = data as ISerializedRecentlyOpened;\n\t\tif (Array.isArray(storedRecents.entries)) {\n\t\t\trestoreGracefully(storedRecents.entries, (entry) => {\n\t\t\t\tconst label = entry.label;\n\t\t\t\tconst remoteAuthority = entry.remoteAuthority;\n\n\t\t\t\tif (isSerializedRecentWorkspace(entry)) {\n\t\t\t\t\tresult.workspaces.push({\n\t\t\t\t\t\tlabel,\n\t\t\t\t\t\tremoteAuthority,\n\t\t\t\t\t\tworkspace: {\n\t\t\t\t\t\t\tid: entry.workspace.id,\n\t\t\t\t\t\t\tconfigPath: URI.parse(entry.workspace.configPath),\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t} else if (isSerializedRecentFolder(entry)) {\n\t\t\t\t\tresult.workspaces.push({\n\t\t\t\t\t\tlabel,\n\t\t\t\t\t\tremoteAuthority,\n\t\t\t\t\t\tfolderUri: URI.parse(entry.folderUri),\n\t\t\t\t\t});\n\t\t\t\t} else if (isSerializedRecentFile(entry)) {\n\t\t\t\t\tresult.files.push({\n\t\t\t\t\t\tlabel,\n\t\t\t\t\t\tremoteAuthority,\n\t\t\t\t\t\tfileUri: URI.parse(entry.fileUri),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport function toStoreData(\n\trecents: IRecentlyOpened,\n): RecentlyOpenedStorageData {\n\tconst serialized: ISerializedRecentlyOpened = { entries: [] };\n\n\tfor (const recent of recents.workspaces) {\n\t\tif (isRecentFolder(recent)) {\n\t\t\tserialized.entries.push({\n\t\t\t\tfolderUri: recent.folderUri.toString(),\n\t\t\t\tlabel: recent.label,\n\t\t\t\tremoteAuthority: recent.remoteAuthority,\n\t\t\t});\n\t\t} else {\n\t\t\tserialized.entries.push({\n\t\t\t\tworkspace: {\n\t\t\t\t\tid: recent.workspace.id,\n\t\t\t\t\tconfigPath: recent.workspace.configPath.toString(),\n\t\t\t\t},\n\t\t\t\tlabel: recent.label,\n\t\t\t\tremoteAuthority: recent.remoteAuthority,\n\t\t\t});\n\t\t}\n\t}\n\n\tfor (const recent of recents.files) {\n\t\tserialized.entries.push({\n\t\t\tfileUri: recent.fileUri.toString(),\n\t\t\tlabel: recent.label,\n\t\t\tremoteAuthority: recent.remoteAuthority,\n\t\t});\n\t}\n\n\treturn serialized;\n}\n\n//#endregion\n"],
  "mappings": ";;AAMA,SAAS,OAAO,iBAAiB;AACjC,YAAY,UAAU;AACtB,YAAY,cAAc;AAE1B,SAAS,4BAA4B;AACrC,SAAS,eAAe;AACxB,SAAS,YAAY,aAAa;AAClC;AAAA,EACC;AAAA,EACA;AAAA,EACA;AAAA,OACM;AACP;AAAA,EAEC;AAAA,OACM;AACP,SAAS,WAAW;AAKpB,SAAS,uBAAuB;AAEhC,SAAS,0BAA0B;AACnC;AAAA,EAKC;AAAA,OACM;AAEA,MAAM,qBACZ,gBAAoC,mBAAmB;AAwDjD,SAAS,kBAAkB,MAAyC;AAC1E,SAAO,KAAK,eAAe,WAAW;AACvC;AAFgB;AAIT,SAAS,eAAe,MAAsC;AACpE,SAAO,KAAK,eAAe,WAAW;AACvC;AAFgB;AAIT,SAAS,aAAa,MAAoC;AAChE,SAAO,KAAK,eAAe,SAAS;AACrC;AAFgB;AAQT,SAAS,wBACf,KACgC;AAChC,SAAO,yBAAyB,GAAG,KAAK,wBAAwB,GAAG;AACpE;AAJgB;AAMhB,SAAS,yBACR,KACiC;AACjC,QAAM,YAAY;AAElB,SACC,OAAO,WAAW,SAAS,aAC1B,CAAC,UAAU,QAAQ,OAAO,UAAU,SAAS;AAEhD;AATS;AAWT,SAAS,wBAAwB,KAA6C;AAC7E,QAAM,YAAY;AAElB,SACC,OAAO,WAAW,QAAQ,aACzB,CAAC,UAAU,QAAQ,OAAO,UAAU,SAAS;AAEhD;AAPS;AA2CF,SAAS,yBACf,WACA,eACA,YACA,uBACA,QACyB;AAEzB,MAAI,UAAU,WAAW,sBAAsB,QAAQ;AACtD,WAAO,EAAE,MAAM,YAAY,KAAK,UAAU,SAAS,IAAI,EAAE;AAAA,EAC1D;AAKA,MAAI,aAAa,gBACd,SACA,OAAO,aAAa,uBAAuB,SAAS;AACvD,MAAI,eAAe,QAAW;AAC7B,QAAI,WAAW,WAAW,GAAG;AAC5B,mBAAa;AAAA,IACd,WAAW,WAAW;AACrB,mBAAa,sBAAsB,UAAU;AAAA,IAC9C;AAAA,EACD,OAGK;AAEJ,QAAI,UAAU,WAAW,QAAQ,MAAM;AACtC,mBAAa,UAAU;AACvB,UAAI,WAAW;AACd,qBAAa,sBAAsB,UAAU;AAAA,MAC9C;AAAA,IACD,WAIC,OAAO;AAAA,MACN,UAAU;AAAA,MACV,sBAAsB;AAAA,IACvB,GACC;AACD,mBAAa,UAAU;AAAA,IACxB,OAAO;AACN,aAAO,EAAE,MAAM,YAAY,KAAK,UAAU,SAAS,IAAI,EAAE;AAAA,IAC1D;AAAA,EACD;AAEA,SAAO,EAAE,MAAM,YAAY,MAAM,WAAW;AAC7C;AAlDgB;AAoDhB,SAAS,sBAAsB,YAAoB;AAElD,eAAa,qBAAqB,UAAU;AAK5C,MAAI,CAAC,MAAM,UAAU,GAAG;AACvB,iBAAa,UAAU,UAAU;AAAA,EAClC;AAEA,SAAO;AACR;AAZS;AAcF,SAAS,mBACf,mBACA,qBACA,QACoB;AACpB,QAAM,SAA4B,CAAC;AACnC,QAAM,OAAoB,oBAAI,IAAI;AAElC,QAAM,aAAa,OAAO,QAAQ,mBAAmB;AACrD,aAAW,oBAAoB,mBAAmB;AACjD,QAAI;AACJ,QAAI,yBAAyB,gBAAgB,GAAG;AAC/C,UAAI,iBAAiB,MAAM;AAC1B,cAAM,OAAO,YAAY,YAAY,iBAAiB,IAAI;AAAA,MAC3D;AAAA,IACD,WAAW,wBAAwB,gBAAgB,GAAG;AACrD,UAAI;AACH,cAAM,IAAI,MAAM,iBAAiB,GAAG;AACpC,YAAI,IAAI,KAAK,CAAC,MAAM,MAAM,KAAK;AAC9B,gBAAM,IAAI,KAAK,EAAE,MAAM,MAAM,MAAM,IAAI,KAAK,CAAC;AAAA,QAC9C;AAAA,MACD,SAAS,GAAG;AACX,gBAAQ,KAAK,CAAC;AAAA,MACf;AAAA,IACD;AAEA,QAAI,KAAK;AAER,YAAM,gBAAgB,OAAO,iBAAiB,GAAG;AACjD,UAAI,CAAC,KAAK,IAAI,aAAa,GAAG;AAC7B,aAAK,IAAI,aAAa;AAEtB,cAAM,OACL,iBAAiB,QAAQ,OAAO,oBAAoB,GAAG;AACxD,eAAO;AAAA,UACN,IAAI;AAAA,YACH,EAAE,KAAK,MAAM,OAAO,OAAO,OAAO;AAAA,YAClC;AAAA,UACD;AAAA,QACD;AAAA,MACD;AAAA,IACD;AAAA,EACD;AAEA,SAAO;AACR;AA7CgB;AAmDT,SAAS,mCACf,sBACA,eACA,yBACA,qBACA,QACC;AACD,QAAM,kBAAkB;AAAA,IACvB;AAAA,IACA;AAAA,EACD;AAEA,QAAM,qBAAqB,OAAO,QAAQ,aAAa;AACvD,QAAM,qBAAqB,OAAO,QAAQ,mBAAmB;AAE7D,QAAM,mBAA6C,CAAC;AAEpD,aAAW,UAAU,gBAAgB,SAAS;AAC7C,UAAM,YAAY,yBAAyB,MAAM,IAC9C,OAAO,YAAY,oBAAoB,OAAO,IAAI,IAClD,IAAI,MAAM,OAAO,GAAG;AACvB,QAAI;AACJ,QAAI,yBAAyB;AAC5B,iBAAW;AAAA,IACZ,OAAO;AACN,iBACC,CAAC,yBAAyB,MAAM,KAAK,WAAW,OAAO,IAAI;AAAA,IAC7D;AACA,qBAAiB;AAAA,MAChB;AAAA,QACC;AAAA,QACA;AAAA,QACA,OAAO;AAAA,QACP;AAAA,QACA;AAAA,MACD;AAAA,IACD;AAAA,EACD;AAIA,QAAM,oBAAuC;AAAA,IAC5C,cAAc;AAAA,IACd,SAAS;AAAA,IACT,KAAK,WAAW,cAAc,OAAO;AAAA,EACtC;AACA,QAAM,QAAQ,SAAS;AAAA,IACtB;AAAA,IACA,CAAC,SAAS;AAAA,IACV;AAAA,IACA;AAAA,EACD;AACA,MAAI,aAAa,SAAS,WAAW,sBAAsB,KAAK;AAEhE,MACC;AAAA,IACC,gBAAgB;AAAA,IAChB,mBAAmB,mBAAmB;AAAA,EACvC,GACC;AAED,iBAAa,SAAS;AAAA,MACrB;AAAA,MACA,SAAS;AAAA,QACR;AAAA,QACA,CAAC,iBAAiB;AAAA,QAClB;AAAA,MACD;AAAA,IACD;AAAA,EACD;AAEA,SAAO;AACR;AAxEgB;AA0EhB,SAAS,uBAAuB,MAAW,UAAoC;AAE9E,QAAM,kBAAoC,KAAK,MAAM,QAAQ;AAG7D,MAAI,mBAAmB,MAAM,QAAQ,gBAAgB,OAAO,GAAG;AAC9D,oBAAgB,UAAU,gBAAgB,QAAQ;AAAA,MAAO,CAAC,WACzD,wBAAwB,MAAM;AAAA,IAC/B;AAAA,EACD,OAAO;AACN,UAAM,IAAI,MAAM,GAAG,IAAI,wCAAwC;AAAA,EAChE;AAEA,SAAO;AACR;AAdS;AAmDT,SAAS,4BACR,MACqC;AACrC,SACC,KAAK,aACL,OAAO,KAAK,cAAc,YAC1B,OAAO,KAAK,UAAU,OAAO,YAC7B,OAAO,KAAK,UAAU,eAAe;AAEvC;AATS;AAWT,SAAS,yBAAyB,MAA4C;AAC7E,SAAO,OAAO,KAAK,cAAc;AAClC;AAFS;AAIT,SAAS,uBAAuB,MAA0C;AACzE,SAAO,OAAO,KAAK,YAAY;AAChC;AAFS;AAIF,SAAS,sBACf,MACA,YACkB;AAClB,QAAM,SAA0B,EAAE,YAAY,CAAC,GAAG,OAAO,CAAC,EAAE;AAC5D,MAAI,MAAM;AACT,UAAM,oBAAoB,wBACzB,SACA,YACI;AACJ,eAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACxC,YAAI;AACH,kBAAQ,QAAQ,CAAC,GAAG,CAAC;AAAA,QACtB,SAAS,GAAG;AACX,qBAAW;AAAA,YACV,gCAAgC,KAAK,UAAU,QAAQ,CAAC,CAAC,CAAC,KAAK,EAAE,SAAS,CAAC;AAAA,UAC5E;AAAA,QACD;AAAA,MACD;AAAA,IACD,GAb0B;AAe1B,UAAM,gBAAgB;AACtB,QAAI,MAAM,QAAQ,cAAc,OAAO,GAAG;AACzC,wBAAkB,cAAc,SAAS,CAAC,UAAU;AACnD,cAAM,QAAQ,MAAM;AACpB,cAAM,kBAAkB,MAAM;AAE9B,YAAI,4BAA4B,KAAK,GAAG;AACvC,iBAAO,WAAW,KAAK;AAAA,YACtB;AAAA,YACA;AAAA,YACA,WAAW;AAAA,cACV,IAAI,MAAM,UAAU;AAAA,cACpB,YAAY,IAAI,MAAM,MAAM,UAAU,UAAU;AAAA,YACjD;AAAA,UACD,CAAC;AAAA,QACF,WAAW,yBAAyB,KAAK,GAAG;AAC3C,iBAAO,WAAW,KAAK;AAAA,YACtB;AAAA,YACA;AAAA,YACA,WAAW,IAAI,MAAM,MAAM,SAAS;AAAA,UACrC,CAAC;AAAA,QACF,WAAW,uBAAuB,KAAK,GAAG;AACzC,iBAAO,MAAM,KAAK;AAAA,YACjB;AAAA,YACA;AAAA,YACA,SAAS,IAAI,MAAM,MAAM,OAAO;AAAA,UACjC,CAAC;AAAA,QACF;AAAA,MACD,CAAC;AAAA,IACF;AAAA,EACD;AAEA,SAAO;AACR;AAtDgB;AAwDT,SAAS,YACf,SAC4B;AAC5B,QAAM,aAAwC,EAAE,SAAS,CAAC,EAAE;AAE5D,aAAW,UAAU,QAAQ,YAAY;AACxC,QAAI,eAAe,MAAM,GAAG;AAC3B,iBAAW,QAAQ,KAAK;AAAA,QACvB,WAAW,OAAO,UAAU,SAAS;AAAA,QACrC,OAAO,OAAO;AAAA,QACd,iBAAiB,OAAO;AAAA,MACzB,CAAC;AAAA,IACF,OAAO;AACN,iBAAW,QAAQ,KAAK;AAAA,QACvB,WAAW;AAAA,UACV,IAAI,OAAO,UAAU;AAAA,UACrB,YAAY,OAAO,UAAU,WAAW,SAAS;AAAA,QAClD;AAAA,QACA,OAAO,OAAO;AAAA,QACd,iBAAiB,OAAO;AAAA,MACzB,CAAC;AAAA,IACF;AAAA,EACD;AAEA,aAAW,UAAU,QAAQ,OAAO;AACnC,eAAW,QAAQ,KAAK;AAAA,MACvB,SAAS,OAAO,QAAQ,SAAS;AAAA,MACjC,OAAO,OAAO;AAAA,MACd,iBAAiB,OAAO;AAAA,IACzB,CAAC;AAAA,EACF;AAEA,SAAO;AACR;AAjCgB;",
  "names": []
}
