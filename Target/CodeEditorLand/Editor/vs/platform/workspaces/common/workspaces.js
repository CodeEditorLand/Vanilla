import{isUNC as F,toSlashes as w}from"../../../base/common/extpath.js";import*as S from"../../../base/common/json.js";import*as u from"../../../base/common/jsonEdit.js";import{normalizeDriveLetter as b}from"../../../base/common/labels.js";import{Schemas as A}from"../../../base/common/network.js";import{isAbsolute as U,posix as m}from"../../../base/common/path.js";import{isLinux as O,isMacintosh as v,isWindows as I}from"../../../base/common/platform.js";import{isEqualAuthority as x}from"../../../base/common/resources.js";import{URI as l}from"../../../base/common/uri.js";import{createDecorator as P}from"../../instantiation/common/instantiation.js";import{getRemoteAuthority as z}from"../../remote/common/remoteHosts.js";import{WorkspaceFolder as E}from"../../workspace/common/workspace.js";const X=P("workspacesService");function Y(e){return e.hasOwnProperty("workspace")}function j(e){return e.hasOwnProperty("folderUri")}function Z(e){return e.hasOwnProperty("fileUri")}function D(e){return y(e)||R(e)}function y(e){const t=e;return typeof t?.path=="string"&&(!t.name||typeof t.name=="string")}function R(e){const t=e;return typeof t?.uri=="string"&&(!t.name||typeof t.name=="string")}function B(e,t,r,s,a){if(e.scheme!==s.scheme)return{name:r,uri:e.toString(!0)};let o=t?void 0:a.relativePath(s,e);if(o!==void 0)o.length===0?o=".":I&&(o=h(o));else if(e.scheme===A.file)o=e.fsPath,I&&(o=h(o));else if(a.isEqualAuthority(e.authority,s.authority))o=e.path;else return{name:r,uri:e.toString(!0)};return{name:r,path:o}}function h(e){return e=b(e),F(e)||(e=w(e)),e}function ee(e,t,r){const s=[],a=new Set,o=r.dirname(t);for(const n of e){let i;if(y(n))n.path&&(i=r.resolvePath(o,n.path));else if(R(n))try{i=l.parse(n.uri),i.path[0]!==m.sep&&(i=i.with({path:m.sep+i.path}))}catch{}if(i){const c=r.getComparisonKey(i);if(!a.has(c)){a.add(c);const d=n.name||r.basenameOrAuthority(i);s.push(new E({uri:i,name:d,index:s.length},n))}}}return s}function re(e,t,r,s,a){const o=L(t,e),n=a.dirname(t),i=a.dirname(s),c=[];for(const p of o.folders){const W=y(p)?a.resolvePath(n,p.path):l.parse(p.uri);let k;r?k=!1:k=!y(p)||U(p.path),c.push(B(W,k,p.name,i,a))}const d={insertSpaces:!1,tabSize:4,eol:O||v?`
`:`\r
`},g=u.setProperty(e,["folders"],c,d);let f=u.applyEdits(e,g);return x(o.remoteAuthority,z(s))&&(f=u.applyEdits(f,u.removeProperty(f,["remoteAuthority"],d))),f}function L(e,t){const r=S.parse(t);if(r&&Array.isArray(r.folders))r.folders=r.folders.filter(s=>D(s));else throw new Error(`${e} looks like an invalid workspace file.`);return r}function T(e){return e.workspace&&typeof e.workspace=="object"&&typeof e.workspace.id=="string"&&typeof e.workspace.configPath=="string"}function C(e){return typeof e.folderUri=="string"}function $(e){return typeof e.fileUri=="string"}function oe(e,t){const r={workspaces:[],files:[]};if(e){const s=(o,n)=>{for(let i=0;i<o.length;i++)try{n(o[i],i)}catch(c){t.warn(`Error restoring recent entry ${JSON.stringify(o[i])}: ${c.toString()}. Skip entry.`)}},a=e;Array.isArray(a.entries)&&s(a.entries,o=>{const n=o.label,i=o.remoteAuthority;T(o)?r.workspaces.push({label:n,remoteAuthority:i,workspace:{id:o.workspace.id,configPath:l.parse(o.workspace.configPath)}}):C(o)?r.workspaces.push({label:n,remoteAuthority:i,folderUri:l.parse(o.folderUri)}):$(o)&&r.files.push({label:n,remoteAuthority:i,fileUri:l.parse(o.fileUri)})})}return r}function te(e){const t={entries:[]};for(const r of e.workspaces)j(r)?t.entries.push({folderUri:r.folderUri.toString(),label:r.label,remoteAuthority:r.remoteAuthority}):t.entries.push({workspace:{id:r.workspace.id,configPath:r.workspace.configPath.toString()},label:r.label,remoteAuthority:r.remoteAuthority});for(const r of e.files)t.entries.push({fileUri:r.fileUri.toString(),label:r.label,remoteAuthority:r.remoteAuthority});return t}export{X as IWorkspacesService,B as getStoredWorkspaceFolder,Z as isRecentFile,j as isRecentFolder,Y as isRecentWorkspace,D as isStoredWorkspaceFolder,oe as restoreRecentlyOpened,re as rewriteWorkspaceFileForNewLocation,te as toStoreData,ee as toWorkspaceFolders};
