{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/remote/common/managedSocket.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { VSBuffer, encodeBase64 } from \"../../../base/common/buffer.js\";\nimport {\n\tEmitter,\n\ttype Event,\n\tPauseableEmitter,\n} from \"../../../base/common/event.js\";\nimport { Disposable, DisposableStore } from \"../../../base/common/lifecycle.js\";\nimport {\n\ttype ISocket,\n\ttype SocketCloseEvent,\n\tSocketDiagnostics,\n\ttype SocketDiagnosticsEventType,\n} from \"../../../base/parts/ipc/common/ipc.net.js\";\n\nexport const makeRawSocketHeaders = (\n\tpath: string,\n\tquery: string,\n\tdeubgLabel: string,\n) => {\n\t// https://tools.ietf.org/html/rfc6455#section-4\n\tconst buffer = new Uint8Array(16);\n\tfor (let i = 0; i < 16; i++) {\n\t\tbuffer[i] = Math.round(Math.random() * 256);\n\t}\n\tconst nonce = encodeBase64(VSBuffer.wrap(buffer));\n\n\tconst headers = [\n\t\t`GET ws://localhost${path}?${query}&skipWebSocketFrames=true HTTP/1.1`,\n\t\t`Connection: Upgrade`,\n\t\t`Upgrade: websocket`,\n\t\t`Sec-WebSocket-Key: ${nonce}`,\n\t];\n\n\treturn headers.join(\"\\r\\n\") + \"\\r\\n\\r\\n\";\n};\n\nexport const socketRawEndHeaderSequence = VSBuffer.fromString(\"\\r\\n\\r\\n\");\n\nexport interface RemoteSocketHalf {\n\tonData: Emitter<VSBuffer>;\n\tonClose: Emitter<SocketCloseEvent>;\n\tonEnd: Emitter<void>;\n}\n\n/** Should be called immediately after making a ManagedSocket to make it ready for data flow. */\nexport async function connectManagedSocket<T extends ManagedSocket>(\n\tsocket: T,\n\tpath: string,\n\tquery: string,\n\tdebugLabel: string,\n\thalf: RemoteSocketHalf,\n): Promise<T> {\n\tsocket.write(\n\t\tVSBuffer.fromString(makeRawSocketHeaders(path, query, debugLabel)),\n\t);\n\n\tconst d = new DisposableStore();\n\ttry {\n\t\treturn await new Promise<T>((resolve, reject) => {\n\t\t\tlet dataSoFar: VSBuffer | undefined;\n\t\t\td.add(\n\t\t\t\tsocket.onData((d_1) => {\n\t\t\t\t\tif (dataSoFar) {\n\t\t\t\t\t\tdataSoFar = VSBuffer.concat(\n\t\t\t\t\t\t\t[dataSoFar, d_1],\n\t\t\t\t\t\t\tdataSoFar.byteLength + d_1.byteLength,\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdataSoFar = d_1;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst index = dataSoFar.indexOf(socketRawEndHeaderSequence);\n\t\t\t\t\tif (index === -1) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve(socket);\n\t\t\t\t\t// pause data events until the socket consumer is hooked up. We may\n\t\t\t\t\t// immediately emit remaining data, but if not there may still be\n\t\t\t\t\t// microtasks queued which would fire data into the abyss.\n\t\t\t\t\tsocket.pauseData();\n\n\t\t\t\t\tconst rest = dataSoFar.slice(\n\t\t\t\t\t\tindex + socketRawEndHeaderSequence.byteLength,\n\t\t\t\t\t);\n\t\t\t\t\tif (rest.byteLength) {\n\t\t\t\t\t\thalf.onData.fire(rest);\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\td.add(\n\t\t\t\tsocket.onClose((err) =>\n\t\t\t\t\treject(err ?? new Error(\"socket closed\")),\n\t\t\t\t),\n\t\t\t);\n\t\t\td.add(socket.onEnd(() => reject(new Error(\"socket ended\"))));\n\t\t});\n\t} catch (e) {\n\t\tsocket.dispose();\n\t\tthrow e;\n\t} finally {\n\t\td.dispose();\n\t}\n}\n\nexport abstract class ManagedSocket extends Disposable implements ISocket {\n\tprivate readonly pausableDataEmitter = this._register(\n\t\tnew PauseableEmitter<VSBuffer>(),\n\t);\n\n\tpublic onData: Event<VSBuffer> = (...args) => {\n\t\tif (this.pausableDataEmitter.isPaused) {\n\t\t\tqueueMicrotask(() => this.pausableDataEmitter.resume());\n\t\t}\n\t\treturn this.pausableDataEmitter.event(...args);\n\t};\n\tpublic onClose: Event<SocketCloseEvent>;\n\tpublic onEnd: Event<void>;\n\n\tprivate readonly didDisposeEmitter = this._register(new Emitter<void>());\n\tpublic onDidDispose = this.didDisposeEmitter.event;\n\n\tprivate ended = false;\n\n\tprotected constructor(\n\t\tprivate readonly debugLabel: string,\n\t\thalf: RemoteSocketHalf,\n\t) {\n\t\tsuper();\n\n\t\tthis._register(half.onData);\n\t\tthis._register(\n\t\t\thalf.onData.event((data) => this.pausableDataEmitter.fire(data)),\n\t\t);\n\n\t\tthis.onClose = this._register(half.onClose).event;\n\t\tthis.onEnd = this._register(half.onEnd).event;\n\t}\n\n\t/** Pauses data events until a new listener comes in onData() */\n\tpublic pauseData() {\n\t\tthis.pausableDataEmitter.pause();\n\t}\n\n\t/** Flushes data to the socket. */\n\tpublic drain(): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n\n\t/** Ends the remote socket. */\n\tpublic end(): void {\n\t\tthis.ended = true;\n\t\tthis.closeRemote();\n\t}\n\n\tpublic abstract write(buffer: VSBuffer): void;\n\tprotected abstract closeRemote(): void;\n\n\ttraceSocketEvent(type: SocketDiagnosticsEventType, data?: any): void {\n\t\tSocketDiagnostics.traceSocketEvent(this, this.debugLabel, type, data);\n\t}\n\n\toverride dispose(): void {\n\t\tif (!this.ended) {\n\t\t\tthis.closeRemote();\n\t\t}\n\n\t\tthis.didDisposeEmitter.fire();\n\t\tsuper.dispose();\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
