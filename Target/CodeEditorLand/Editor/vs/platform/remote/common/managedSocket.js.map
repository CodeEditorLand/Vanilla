{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/remote/common/managedSocket.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { VSBuffer, encodeBase64 } from '../../../base/common/buffer.js';\nimport { Emitter, Event, PauseableEmitter } from '../../../base/common/event.js';\nimport { Disposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport { ISocket, SocketCloseEvent, SocketDiagnostics, SocketDiagnosticsEventType } from '../../../base/parts/ipc/common/ipc.net.js';\n\nexport const makeRawSocketHeaders = (path: string, query: string, deubgLabel: string) => {\n\t// https://tools.ietf.org/html/rfc6455#section-4\n\tconst buffer = new Uint8Array(16);\n\tfor (let i = 0; i < 16; i++) {\n\t\tbuffer[i] = Math.round(Math.random() * 256);\n\t}\n\tconst nonce = encodeBase64(VSBuffer.wrap(buffer));\n\n\tconst headers = [\n\t\t`GET ws://localhost${path}?${query}&skipWebSocketFrames=true HTTP/1.1`,\n\t\t`Connection: Upgrade`,\n\t\t`Upgrade: websocket`,\n\t\t`Sec-WebSocket-Key: ${nonce}`\n\t];\n\n\treturn headers.join('\\r\\n') + '\\r\\n\\r\\n';\n};\n\nexport const socketRawEndHeaderSequence = VSBuffer.fromString('\\r\\n\\r\\n');\n\nexport interface RemoteSocketHalf {\n\tonData: Emitter<VSBuffer>;\n\tonClose: Emitter<SocketCloseEvent>;\n\tonEnd: Emitter<void>;\n}\n\n/** Should be called immediately after making a ManagedSocket to make it ready for data flow. */\nexport async function connectManagedSocket<T extends ManagedSocket>(\n\tsocket: T,\n\tpath: string, query: string, debugLabel: string,\n\thalf: RemoteSocketHalf\n): Promise<T> {\n\tsocket.write(VSBuffer.fromString(makeRawSocketHeaders(path, query, debugLabel)));\n\n\tconst d = new DisposableStore();\n\ttry {\n\t\treturn await new Promise<T>((resolve, reject) => {\n\t\t\tlet dataSoFar: VSBuffer | undefined;\n\t\t\td.add(socket.onData(d_1 => {\n\t\t\t\tif (!dataSoFar) {\n\t\t\t\t\tdataSoFar = d_1;\n\t\t\t\t} else {\n\t\t\t\t\tdataSoFar = VSBuffer.concat([dataSoFar, d_1], dataSoFar.byteLength + d_1.byteLength);\n\t\t\t\t}\n\n\t\t\t\tconst index = dataSoFar.indexOf(socketRawEndHeaderSequence);\n\t\t\t\tif (index === -1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tresolve(socket);\n\t\t\t\t// pause data events until the socket consumer is hooked up. We may\n\t\t\t\t// immediately emit remaining data, but if not there may still be\n\t\t\t\t// microtasks queued which would fire data into the abyss.\n\t\t\t\tsocket.pauseData();\n\n\t\t\t\tconst rest = dataSoFar.slice(index + socketRawEndHeaderSequence.byteLength);\n\t\t\t\tif (rest.byteLength) {\n\t\t\t\t\thalf.onData.fire(rest);\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\td.add(socket.onClose(err => reject(err ?? new Error('socket closed'))));\n\t\t\td.add(socket.onEnd(() => reject(new Error('socket ended'))));\n\t\t});\n\t} catch (e) {\n\t\tsocket.dispose();\n\t\tthrow e;\n\t} finally {\n\t\td.dispose();\n\t}\n}\n\nexport abstract class ManagedSocket extends Disposable implements ISocket {\n\tprivate readonly pausableDataEmitter = this._register(new PauseableEmitter<VSBuffer>());\n\n\tpublic onData: Event<VSBuffer> = (...args) => {\n\t\tif (this.pausableDataEmitter.isPaused) {\n\t\t\tqueueMicrotask(() => this.pausableDataEmitter.resume());\n\t\t}\n\t\treturn this.pausableDataEmitter.event(...args);\n\t};\n\tpublic onClose: Event<SocketCloseEvent>;\n\tpublic onEnd: Event<void>;\n\n\tprivate readonly didDisposeEmitter = this._register(new Emitter<void>());\n\tpublic onDidDispose = this.didDisposeEmitter.event;\n\n\tprivate ended = false;\n\n\tprotected constructor(\n\t\tprivate readonly debugLabel: string,\n\t\thalf: RemoteSocketHalf,\n\t) {\n\t\tsuper();\n\n\t\tthis._register(half.onData);\n\t\tthis._register(half.onData.event(data => this.pausableDataEmitter.fire(data)));\n\n\t\tthis.onClose = this._register(half.onClose).event;\n\t\tthis.onEnd = this._register(half.onEnd).event;\n\t}\n\n\t/** Pauses data events until a new listener comes in onData() */\n\tpublic pauseData() {\n\t\tthis.pausableDataEmitter.pause();\n\t}\n\n\t/** Flushes data to the socket. */\n\tpublic drain(): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n\n\t/** Ends the remote socket. */\n\tpublic end(): void {\n\t\tthis.ended = true;\n\t\tthis.closeRemote();\n\t}\n\n\tpublic abstract write(buffer: VSBuffer): void;\n\tprotected abstract closeRemote(): void;\n\n\ttraceSocketEvent(type: SocketDiagnosticsEventType, data?: any): void {\n\t\tSocketDiagnostics.traceSocketEvent(this, this.debugLabel, type, data);\n\t}\n\n\toverride dispose(): void {\n\t\tif (!this.ended) {\n\t\t\tthis.closeRemote();\n\t\t}\n\n\t\tthis.didDisposeEmitter.fire();\n\t\tsuper.dispose();\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
