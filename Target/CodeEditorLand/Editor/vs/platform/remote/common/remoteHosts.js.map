{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/remote/common/remoteHosts.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Schemas } from '../../../base/common/network.js';\nimport { URI } from '../../../base/common/uri.js';\n\nexport function getRemoteAuthority(uri: URI): string | undefined {\n\treturn uri.scheme === Schemas.vscodeRemote ? uri.authority : undefined;\n}\n\nexport function getRemoteName(authority: string): string;\nexport function getRemoteName(authority: undefined): undefined;\nexport function getRemoteName(authority: string | undefined): string | undefined;\nexport function getRemoteName(authority: string | undefined): string | undefined {\n\tif (!authority) {\n\t\treturn undefined;\n\t}\n\tconst pos = authority.indexOf('+');\n\tif (pos < 0) {\n\t\t// e.g. localhost:8000\n\t\treturn authority;\n\t}\n\treturn authority.substr(0, pos);\n}\n\nexport function parseAuthorityWithPort(authority: string): { host: string; port: number } {\n\tconst { host, port } = parseAuthority(authority);\n\tif (typeof port === 'undefined') {\n\t\tthrow new Error(`Invalid remote authority: ${authority}. It must either be a remote of form <remoteName>+<arg> or a remote host of form <host>:<port>.`);\n\t}\n\treturn { host, port };\n}\n\nexport function parseAuthorityWithOptionalPort(authority: string, defaultPort: number): { host: string; port: number } {\n\tlet { host, port } = parseAuthority(authority);\n\tif (typeof port === 'undefined') {\n\t\tport = defaultPort;\n\t}\n\treturn { host, port };\n}\n\nfunction parseAuthority(authority: string): { host: string; port: number | undefined } {\n\t// check for ipv6 with port\n\tconst m1 = authority.match(/^(\\[[0-9a-z:]+\\]):(\\d+)$/);\n\tif (m1) {\n\t\treturn { host: m1[1], port: parseInt(m1[2], 10) };\n\t}\n\n\t// check for ipv6 without port\n\tconst m2 = authority.match(/^(\\[[0-9a-z:]+\\])$/);\n\tif (m2) {\n\t\treturn { host: m2[1], port: undefined };\n\t}\n\n\t// anything with a trailing port\n\tconst m3 = authority.match(/(.*):(\\d+)$/);\n\tif (m3) {\n\t\treturn { host: m3[1], port: parseInt(m3[2], 10) };\n\t}\n\n\t// doesn't contain a port\n\treturn { host: authority, port: undefined };\n}\n"],
  "mappings": ";;AAKA,SAAS,eAAe;AACxB,SAAS,WAAW;AAEb,SAAS,mBAAmB,KAA8B;AAChE,SAAO,IAAI,WAAW,QAAQ,eAAe,IAAI,YAAY;AAC9D;AAFgB;AAOT,SAAS,cAAc,WAAmD;AAChF,MAAI,CAAC,WAAW;AACf,WAAO;AAAA,EACR;AACA,QAAM,MAAM,UAAU,QAAQ,GAAG;AACjC,MAAI,MAAM,GAAG;AAEZ,WAAO;AAAA,EACR;AACA,SAAO,UAAU,OAAO,GAAG,GAAG;AAC/B;AAVgB;AAYT,SAAS,uBAAuB,WAAmD;AACzF,QAAM,EAAE,MAAM,KAAK,IAAI,eAAe,SAAS;AAC/C,MAAI,OAAO,SAAS,aAAa;AAChC,UAAM,IAAI,MAAM,6BAA6B,SAAS,iGAAiG;AAAA,EACxJ;AACA,SAAO,EAAE,MAAM,KAAK;AACrB;AANgB;AAQT,SAAS,+BAA+B,WAAmB,aAAqD;AACtH,MAAI,EAAE,MAAM,KAAK,IAAI,eAAe,SAAS;AAC7C,MAAI,OAAO,SAAS,aAAa;AAChC,WAAO;AAAA,EACR;AACA,SAAO,EAAE,MAAM,KAAK;AACrB;AANgB;AAQhB,SAAS,eAAe,WAA+D;AAEtF,QAAM,KAAK,UAAU,MAAM,0BAA0B;AACrD,MAAI,IAAI;AACP,WAAO,EAAE,MAAM,GAAG,CAAC,GAAG,MAAM,SAAS,GAAG,CAAC,GAAG,EAAE,EAAE;AAAA,EACjD;AAGA,QAAM,KAAK,UAAU,MAAM,oBAAoB;AAC/C,MAAI,IAAI;AACP,WAAO,EAAE,MAAM,GAAG,CAAC,GAAG,MAAM,OAAU;AAAA,EACvC;AAGA,QAAM,KAAK,UAAU,MAAM,aAAa;AACxC,MAAI,IAAI;AACP,WAAO,EAAE,MAAM,GAAG,CAAC,GAAG,MAAM,SAAS,GAAG,CAAC,GAAG,EAAE,EAAE;AAAA,EACjD;AAGA,SAAO,EAAE,MAAM,WAAW,MAAM,OAAU;AAC3C;AArBS;",
  "names": []
}
