{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/remote/common/remoteHosts.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Schemas } from \"../../../base/common/network.js\";\nimport type { URI } from \"../../../base/common/uri.js\";\n\nexport function getRemoteAuthority(uri: URI): string | undefined {\n\treturn uri.scheme === Schemas.vscodeRemote ? uri.authority : undefined;\n}\n\nexport function getRemoteName(authority: string): string;\nexport function getRemoteName(authority: undefined): undefined;\nexport function getRemoteName(\n\tauthority: string | undefined,\n): string | undefined;\nexport function getRemoteName(\n\tauthority: string | undefined,\n): string | undefined {\n\tif (!authority) {\n\t\treturn undefined;\n\t}\n\tconst pos = authority.indexOf(\"+\");\n\tif (pos < 0) {\n\t\t// e.g. localhost:8000\n\t\treturn authority;\n\t}\n\treturn authority.substr(0, pos);\n}\n\nexport function parseAuthorityWithPort(authority: string): {\n\thost: string;\n\tport: number;\n} {\n\tconst { host, port } = parseAuthority(authority);\n\tif (typeof port === \"undefined\") {\n\t\tthrow new Error(\n\t\t\t`Invalid remote authority: ${authority}. It must either be a remote of form <remoteName>+<arg> or a remote host of form <host>:<port>.`,\n\t\t);\n\t}\n\treturn { host, port };\n}\n\nexport function parseAuthorityWithOptionalPort(\n\tauthority: string,\n\tdefaultPort: number,\n): { host: string; port: number } {\n\tlet { host, port } = parseAuthority(authority);\n\tif (typeof port === \"undefined\") {\n\t\tport = defaultPort;\n\t}\n\treturn { host, port };\n}\n\nfunction parseAuthority(authority: string): {\n\thost: string;\n\tport: number | undefined;\n} {\n\t// check for ipv6 with port\n\tconst m1 = authority.match(/^(\\[[0-9a-z:]+\\]):(\\d+)$/);\n\tif (m1) {\n\t\treturn { host: m1[1], port: Number.parseInt(m1[2], 10) };\n\t}\n\n\t// check for ipv6 without port\n\tconst m2 = authority.match(/^(\\[[0-9a-z:]+\\])$/);\n\tif (m2) {\n\t\treturn { host: m2[1], port: undefined };\n\t}\n\n\t// anything with a trailing port\n\tconst m3 = authority.match(/(.*):(\\d+)$/);\n\tif (m3) {\n\t\treturn { host: m3[1], port: Number.parseInt(m3[2], 10) };\n\t}\n\n\t// doesn't contain a port\n\treturn { host: authority, port: undefined };\n}\n"],
  "mappings": ";;AAKA,SAAS,eAAe;AAGjB,SAAS,mBAAmB,KAA8B;AAChE,SAAO,IAAI,WAAW,QAAQ,eAAe,IAAI,YAAY;AAC9D;AAFgB;AAST,SAAS,cACf,WACqB;AACrB,MAAI,CAAC,WAAW;AACf,WAAO;AAAA,EACR;AACA,QAAM,MAAM,UAAU,QAAQ,GAAG;AACjC,MAAI,MAAM,GAAG;AAEZ,WAAO;AAAA,EACR;AACA,SAAO,UAAU,OAAO,GAAG,GAAG;AAC/B;AAZgB;AAcT,SAAS,uBAAuB,WAGrC;AACD,QAAM,EAAE,MAAM,KAAK,IAAI,eAAe,SAAS;AAC/C,MAAI,OAAO,SAAS,aAAa;AAChC,UAAM,IAAI;AAAA,MACT,6BAA6B,SAAS;AAAA,IACvC;AAAA,EACD;AACA,SAAO,EAAE,MAAM,KAAK;AACrB;AAXgB;AAaT,SAAS,+BACf,WACA,aACiC;AACjC,MAAI,EAAE,MAAM,KAAK,IAAI,eAAe,SAAS;AAC7C,MAAI,OAAO,SAAS,aAAa;AAChC,WAAO;AAAA,EACR;AACA,SAAO,EAAE,MAAM,KAAK;AACrB;AATgB;AAWhB,SAAS,eAAe,WAGtB;AAED,QAAM,KAAK,UAAU,MAAM,0BAA0B;AACrD,MAAI,IAAI;AACP,WAAO,EAAE,MAAM,GAAG,CAAC,GAAG,MAAM,OAAO,SAAS,GAAG,CAAC,GAAG,EAAE,EAAE;AAAA,EACxD;AAGA,QAAM,KAAK,UAAU,MAAM,oBAAoB;AAC/C,MAAI,IAAI;AACP,WAAO,EAAE,MAAM,GAAG,CAAC,GAAG,MAAM,OAAU;AAAA,EACvC;AAGA,QAAM,KAAK,UAAU,MAAM,aAAa;AACxC,MAAI,IAAI;AACP,WAAO,EAAE,MAAM,GAAG,CAAC,GAAG,MAAM,OAAO,SAAS,GAAG,CAAC,GAAG,EAAE,EAAE;AAAA,EACxD;AAGA,SAAO,EAAE,MAAM,WAAW,MAAM,OAAU;AAC3C;AAxBS;",
  "names": []
}
