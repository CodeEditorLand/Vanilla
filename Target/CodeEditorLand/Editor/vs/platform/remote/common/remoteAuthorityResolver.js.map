{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/remote/common/remoteAuthorityResolver.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ErrorNoTelemetry } from \"../../../base/common/errors.js\";\nimport type { Event } from \"../../../base/common/event.js\";\nimport type { URI } from \"../../../base/common/uri.js\";\nimport { createDecorator } from \"../../instantiation/common/instantiation.js\";\n\nexport const IRemoteAuthorityResolverService =\n\tcreateDecorator<IRemoteAuthorityResolverService>(\n\t\t\"remoteAuthorityResolverService\",\n\t);\n\nexport enum RemoteConnectionType {\n\tWebSocket = 0,\n\tManaged = 1,\n}\n\nexport class ManagedRemoteConnection {\n\tpublic readonly type = RemoteConnectionType.Managed;\n\n\tconstructor(public readonly id: number) {}\n\n\tpublic toString(): string {\n\t\treturn `Managed(${this.id})`;\n\t}\n}\n\nexport class WebSocketRemoteConnection {\n\tpublic readonly type = RemoteConnectionType.WebSocket;\n\n\tconstructor(\n\t\tpublic readonly host: string,\n\t\tpublic readonly port: number,\n\t) {}\n\n\tpublic toString(): string {\n\t\treturn `WebSocket(${this.host}:${this.port})`;\n\t}\n}\n\nexport type RemoteConnection =\n\t| WebSocketRemoteConnection\n\t| ManagedRemoteConnection;\n\nexport type RemoteConnectionOfType<T extends RemoteConnectionType> =\n\tRemoteConnection & { type: T };\n\nexport interface ResolvedAuthority {\n\treadonly authority: string;\n\treadonly connectTo: RemoteConnection;\n\treadonly connectionToken: string | undefined;\n}\n\nexport interface ResolvedOptions {\n\treadonly extensionHostEnv?: { [key: string]: string | null };\n\treadonly isTrusted?: boolean;\n\treadonly authenticationSession?: { id: string; providerId: string };\n}\n\nexport interface TunnelDescription {\n\tremoteAddress: { port: number; host: string };\n\tlocalAddress: { port: number; host: string } | string;\n\tprivacy?: string;\n\tprotocol?: string;\n}\nexport interface TunnelPrivacy {\n\tthemeIcon: string;\n\tid: string;\n\tlabel: string;\n}\nexport interface TunnelInformation {\n\tenvironmentTunnels?: TunnelDescription[];\n\tfeatures?: {\n\t\televation: boolean;\n\t\tpublic?: boolean;\n\t\tprivacyOptions: TunnelPrivacy[];\n\t\tprotocol: boolean;\n\t};\n}\n\nexport interface ResolverResult {\n\tauthority: ResolvedAuthority;\n\toptions?: ResolvedOptions;\n\ttunnelInformation?: TunnelInformation;\n}\n\nexport interface IRemoteConnectionData {\n\tconnectTo: RemoteConnection;\n\tconnectionToken: string | undefined;\n}\n\nexport enum RemoteAuthorityResolverErrorCode {\n\tUnknown = \"Unknown\",\n\tNotAvailable = \"NotAvailable\",\n\tTemporarilyNotAvailable = \"TemporarilyNotAvailable\",\n\tNoResolverFound = \"NoResolverFound\",\n\tInvalidAuthority = \"InvalidAuthority\",\n}\n\nexport class RemoteAuthorityResolverError extends ErrorNoTelemetry {\n\tpublic static isNotAvailable(err: any): boolean {\n\t\treturn (\n\t\t\terr instanceof RemoteAuthorityResolverError &&\n\t\t\terr._code === RemoteAuthorityResolverErrorCode.NotAvailable\n\t\t);\n\t}\n\n\tpublic static isTemporarilyNotAvailable(err: any): boolean {\n\t\treturn (\n\t\t\terr instanceof RemoteAuthorityResolverError &&\n\t\t\terr._code ===\n\t\t\t\tRemoteAuthorityResolverErrorCode.TemporarilyNotAvailable\n\t\t);\n\t}\n\n\tpublic static isNoResolverFound(\n\t\terr: any,\n\t): err is RemoteAuthorityResolverError {\n\t\treturn (\n\t\t\terr instanceof RemoteAuthorityResolverError &&\n\t\t\terr._code === RemoteAuthorityResolverErrorCode.NoResolverFound\n\t\t);\n\t}\n\n\tpublic static isInvalidAuthority(err: any): boolean {\n\t\treturn (\n\t\t\terr instanceof RemoteAuthorityResolverError &&\n\t\t\terr._code === RemoteAuthorityResolverErrorCode.InvalidAuthority\n\t\t);\n\t}\n\n\tpublic static isHandled(err: any): boolean {\n\t\treturn err instanceof RemoteAuthorityResolverError && err.isHandled;\n\t}\n\n\tpublic readonly _message: string | undefined;\n\tpublic readonly _code: RemoteAuthorityResolverErrorCode;\n\tpublic readonly _detail: any;\n\n\tpublic isHandled: boolean;\n\n\tconstructor(\n\t\tmessage?: string,\n\t\tcode: RemoteAuthorityResolverErrorCode = RemoteAuthorityResolverErrorCode.Unknown,\n\t\tdetail?: any,\n\t) {\n\t\tsuper(message);\n\n\t\tthis._message = message;\n\t\tthis._code = code;\n\t\tthis._detail = detail;\n\n\t\tthis.isHandled =\n\t\t\tcode === RemoteAuthorityResolverErrorCode.NotAvailable &&\n\t\t\tdetail === true;\n\n\t\t// workaround when extending builtin objects and when compiling to ES5, see:\n\t\t// https://github.com/microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n\t\tObject.setPrototypeOf(this, RemoteAuthorityResolverError.prototype);\n\t}\n}\n\nexport interface IRemoteAuthorityResolverService {\n\treadonly _serviceBrand: undefined;\n\n\treadonly onDidChangeConnectionData: Event<void>;\n\n\tresolveAuthority(authority: string): Promise<ResolverResult>;\n\tgetConnectionData(authority: string): IRemoteConnectionData | null;\n\t/**\n\t * Get the canonical URI for a `vscode-remote://` URI.\n\t *\n\t * **NOTE**: This can throw e.g. in cases where there is no resolver installed for the specific remote authority.\n\t *\n\t * @param uri The `vscode-remote://` URI\n\t */\n\tgetCanonicalURI(uri: URI): Promise<URI>;\n\n\t_clearResolvedAuthority(authority: string): void;\n\t_setResolvedAuthority(\n\t\tresolvedAuthority: ResolvedAuthority,\n\t\tresolvedOptions?: ResolvedOptions,\n\t): void;\n\t_setResolvedAuthorityError(authority: string, err: any): void;\n\t_setAuthorityConnectionToken(\n\t\tauthority: string,\n\t\tconnectionToken: string,\n\t): void;\n\t_setCanonicalURIProvider(provider: (uri: URI) => Promise<URI>): void;\n}\n\nexport function getRemoteAuthorityPrefix(remoteAuthority: string): string {\n\tconst plusIndex = remoteAuthority.indexOf(\"+\");\n\tif (plusIndex === -1) {\n\t\treturn remoteAuthority;\n\t}\n\treturn remoteAuthority.substring(0, plusIndex);\n}\n"],
  "mappings": ";;AAKA,SAAS,wBAAwB;AAGjC,SAAS,uBAAuB;AAEzB,MAAM,kCACZ;AAAA,EACC;AACD;AAEM,IAAK,uBAAL,kBAAKA,0BAAL;AACN,EAAAA,4CAAA,eAAY,KAAZ;AACA,EAAAA,4CAAA,aAAU,KAAV;AAFW,SAAAA;AAAA,GAAA;AAKL,MAAM,wBAAwB;AAAA,EAGpC,YAA4B,IAAY;AAAZ;AAAA,EAAa;AAAA,EAvB1C,OAoBqC;AAAA;AAAA;AAAA,EACpB,OAAO;AAAA,EAIhB,WAAmB;AACzB,WAAO,WAAW,KAAK,EAAE;AAAA,EAC1B;AACD;AAEO,MAAM,0BAA0B;AAAA,EAGtC,YACiB,MACA,MACf;AAFe;AACA;AAAA,EACd;AAAA,EApCJ,OA8BuC;AAAA;AAAA;AAAA,EACtB,OAAO;AAAA,EAOhB,WAAmB;AACzB,WAAO,aAAa,KAAK,IAAI,IAAI,KAAK,IAAI;AAAA,EAC3C;AACD;AAqDO,IAAK,mCAAL,kBAAKC,sCAAL;AACN,EAAAA,kCAAA,aAAU;AACV,EAAAA,kCAAA,kBAAe;AACf,EAAAA,kCAAA,6BAA0B;AAC1B,EAAAA,kCAAA,qBAAkB;AAClB,EAAAA,kCAAA,sBAAmB;AALR,SAAAA;AAAA,GAAA;AAQL,MAAM,qCAAqC,iBAAiB;AAAA,EAtGnE,OAsGmE;AAAA;AAAA;AAAA,EAClE,OAAc,eAAe,KAAmB;AAC/C,WACC,eAAe,gCACf,IAAI,UAAU;AAAA,EAEhB;AAAA,EAEA,OAAc,0BAA0B,KAAmB;AAC1D,WACC,eAAe,gCACf,IAAI,UACH;AAAA,EAEH;AAAA,EAEA,OAAc,kBACb,KACsC;AACtC,WACC,eAAe,gCACf,IAAI,UAAU;AAAA,EAEhB;AAAA,EAEA,OAAc,mBAAmB,KAAmB;AACnD,WACC,eAAe,gCACf,IAAI,UAAU;AAAA,EAEhB;AAAA,EAEA,OAAc,UAAU,KAAmB;AAC1C,WAAO,eAAe,gCAAgC,IAAI;AAAA,EAC3D;AAAA,EAEgB;AAAA,EACA;AAAA,EACA;AAAA,EAET;AAAA,EAEP,YACC,SACA,OAAyC,yBACzC,QACC;AACD,UAAM,OAAO;AAEb,SAAK,WAAW;AAChB,SAAK,QAAQ;AACb,SAAK,UAAU;AAEf,SAAK,YACJ,SAAS,qCACT,WAAW;AAIZ,WAAO,eAAe,MAAM,6BAA6B,SAAS;AAAA,EACnE;AACD;AA+BO,SAAS,yBAAyB,iBAAiC;AACzE,QAAM,YAAY,gBAAgB,QAAQ,GAAG;AAC7C,MAAI,cAAc,IAAI;AACrB,WAAO;AAAA,EACR;AACA,SAAO,gBAAgB,UAAU,GAAG,SAAS;AAC9C;AANgB;",
  "names": ["RemoteConnectionType", "RemoteAuthorityResolverErrorCode"]
}
