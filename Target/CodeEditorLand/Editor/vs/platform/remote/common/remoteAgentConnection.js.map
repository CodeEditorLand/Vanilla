{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/remote/common/remoteAgentConnection.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancelablePromise, createCancelablePromise, promiseWithResolvers } from '../../../base/common/async.js';\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { isCancellationError, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, DisposableStore, IDisposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { RemoteAuthorities } from '../../../base/common/network.js';\nimport * as performance from '../../../base/common/performance.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { generateUuid } from '../../../base/common/uuid.js';\nimport { IIPCLogger } from '../../../base/parts/ipc/common/ipc.js';\nimport { Client, ISocket, PersistentProtocol, SocketCloseEventType } from '../../../base/parts/ipc/common/ipc.net.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { RemoteAgentConnectionContext } from './remoteAgentEnvironment.js';\nimport { RemoteAuthorityResolverError, RemoteConnection } from './remoteAuthorityResolver.js';\nimport { IRemoteSocketFactoryService } from './remoteSocketFactoryService.js';\nimport { ISignService } from '../../sign/common/sign.js';\n\nconst RECONNECT_TIMEOUT = 30 * 1000 /* 30s */;\n\nexport const enum ConnectionType {\n\tManagement = 1,\n\tExtensionHost = 2,\n\tTunnel = 3,\n}\n\nfunction connectionTypeToString(connectionType: ConnectionType): string {\n\tswitch (connectionType) {\n\t\tcase ConnectionType.Management:\n\t\t\treturn 'Management';\n\t\tcase ConnectionType.ExtensionHost:\n\t\t\treturn 'ExtensionHost';\n\t\tcase ConnectionType.Tunnel:\n\t\t\treturn 'Tunnel';\n\t}\n}\n\nexport interface AuthRequest {\n\ttype: 'auth';\n\tauth: string;\n\tdata: string;\n}\n\nexport interface SignRequest {\n\ttype: 'sign';\n\tdata: string;\n\tsignedData: string;\n}\n\nexport interface ConnectionTypeRequest {\n\ttype: 'connectionType';\n\tcommit?: string;\n\tsignedData: string;\n\tdesiredConnectionType?: ConnectionType;\n\targs?: any;\n}\n\nexport interface ErrorMessage {\n\ttype: 'error';\n\treason: string;\n}\n\nexport interface OKMessage {\n\ttype: 'ok';\n}\n\nexport type HandshakeMessage = AuthRequest | SignRequest | ConnectionTypeRequest | ErrorMessage | OKMessage;\n\n\ninterface ISimpleConnectionOptions<T extends RemoteConnection = RemoteConnection> {\n\tcommit: string | undefined;\n\tquality: string | undefined;\n\tconnectTo: T;\n\tconnectionToken: string | undefined;\n\treconnectionToken: string;\n\treconnectionProtocol: PersistentProtocol | null;\n\tremoteSocketFactoryService: IRemoteSocketFactoryService;\n\tsignService: ISignService;\n\tlogService: ILogService;\n}\n\nfunction createTimeoutCancellation(millis: number): CancellationToken {\n\tconst source = new CancellationTokenSource();\n\tsetTimeout(() => source.cancel(), millis);\n\treturn source.token;\n}\n\nfunction combineTimeoutCancellation(a: CancellationToken, b: CancellationToken): CancellationToken {\n\tif (a.isCancellationRequested || b.isCancellationRequested) {\n\t\treturn CancellationToken.Cancelled;\n\t}\n\tconst source = new CancellationTokenSource();\n\ta.onCancellationRequested(() => source.cancel());\n\tb.onCancellationRequested(() => source.cancel());\n\treturn source.token;\n}\n\nclass PromiseWithTimeout<T> {\n\n\tprivate _state: 'pending' | 'resolved' | 'rejected' | 'timedout';\n\tprivate readonly _disposables: DisposableStore;\n\tpublic readonly promise: Promise<T>;\n\tprivate readonly _resolvePromise: (value: T) => void;\n\tprivate readonly _rejectPromise: (err: any) => void;\n\n\tpublic get didTimeout(): boolean {\n\t\treturn (this._state === 'timedout');\n\t}\n\n\tconstructor(timeoutCancellationToken: CancellationToken) {\n\t\tthis._state = 'pending';\n\t\tthis._disposables = new DisposableStore();\n\n\t\t({ promise: this.promise, resolve: this._resolvePromise, reject: this._rejectPromise } = promiseWithResolvers<T>());\n\n\t\tif (timeoutCancellationToken.isCancellationRequested) {\n\t\t\tthis._timeout();\n\t\t} else {\n\t\t\tthis._disposables.add(timeoutCancellationToken.onCancellationRequested(() => this._timeout()));\n\t\t}\n\t}\n\n\tpublic registerDisposable(disposable: IDisposable): void {\n\t\tif (this._state === 'pending') {\n\t\t\tthis._disposables.add(disposable);\n\t\t} else {\n\t\t\tdisposable.dispose();\n\t\t}\n\t}\n\n\tprivate _timeout(): void {\n\t\tif (this._state !== 'pending') {\n\t\t\treturn;\n\t\t}\n\t\tthis._disposables.dispose();\n\t\tthis._state = 'timedout';\n\t\tthis._rejectPromise(this._createTimeoutError());\n\t}\n\n\tprivate _createTimeoutError(): Error {\n\t\tconst err: any = new Error('Time limit reached');\n\t\terr.code = 'ETIMEDOUT';\n\t\terr.syscall = 'connect';\n\t\treturn err;\n\t}\n\n\tpublic resolve(value: T): void {\n\t\tif (this._state !== 'pending') {\n\t\t\treturn;\n\t\t}\n\t\tthis._disposables.dispose();\n\t\tthis._state = 'resolved';\n\t\tthis._resolvePromise(value);\n\t}\n\n\tpublic reject(err: any): void {\n\t\tif (this._state !== 'pending') {\n\t\t\treturn;\n\t\t}\n\t\tthis._disposables.dispose();\n\t\tthis._state = 'rejected';\n\t\tthis._rejectPromise(err);\n\t}\n}\n\nfunction readOneControlMessage<T>(protocol: PersistentProtocol, timeoutCancellationToken: CancellationToken): Promise<T> {\n\tconst result = new PromiseWithTimeout<T>(timeoutCancellationToken);\n\tresult.registerDisposable(protocol.onControlMessage(raw => {\n\t\tconst msg: T = JSON.parse(raw.toString());\n\t\tconst error = getErrorFromMessage(msg);\n\t\tif (error) {\n\t\t\tresult.reject(error);\n\t\t} else {\n\t\t\tresult.resolve(msg);\n\t\t}\n\t}));\n\treturn result.promise;\n}\n\nfunction createSocket<T extends RemoteConnection>(logService: ILogService, remoteSocketFactoryService: IRemoteSocketFactoryService, connectTo: T, path: string, query: string, debugConnectionType: string, debugLabel: string, timeoutCancellationToken: CancellationToken): Promise<ISocket> {\n\tconst result = new PromiseWithTimeout<ISocket>(timeoutCancellationToken);\n\tconst sw = StopWatch.create(false);\n\tlogService.info(`Creating a socket (${debugLabel})...`);\n\tperformance.mark(`code/willCreateSocket/${debugConnectionType}`);\n\n\tremoteSocketFactoryService.connect(connectTo, path, query, debugLabel).then((socket) => {\n\t\tif (result.didTimeout) {\n\t\t\tperformance.mark(`code/didCreateSocketError/${debugConnectionType}`);\n\t\t\tlogService.info(`Creating a socket (${debugLabel}) finished after ${sw.elapsed()} ms, but this is too late and has timed out already.`);\n\t\t\tsocket?.dispose();\n\t\t} else {\n\t\t\tperformance.mark(`code/didCreateSocketOK/${debugConnectionType}`);\n\t\t\tlogService.info(`Creating a socket (${debugLabel}) was successful after ${sw.elapsed()} ms.`);\n\t\t\tresult.resolve(socket);\n\t\t}\n\t}, (err) => {\n\t\tperformance.mark(`code/didCreateSocketError/${debugConnectionType}`);\n\t\tlogService.info(`Creating a socket (${debugLabel}) returned an error after ${sw.elapsed()} ms.`);\n\t\tlogService.error(err);\n\t\tresult.reject(err);\n\t});\n\n\treturn result.promise;\n}\n\nfunction raceWithTimeoutCancellation<T>(promise: Promise<T>, timeoutCancellationToken: CancellationToken): Promise<T> {\n\tconst result = new PromiseWithTimeout<T>(timeoutCancellationToken);\n\tpromise.then(\n\t\t(res) => {\n\t\t\tif (!result.didTimeout) {\n\t\t\t\tresult.resolve(res);\n\t\t\t}\n\t\t},\n\t\t(err) => {\n\t\t\tif (!result.didTimeout) {\n\t\t\t\tresult.reject(err);\n\t\t\t}\n\t\t}\n\t);\n\treturn result.promise;\n}\n\nasync function connectToRemoteExtensionHostAgent<T extends RemoteConnection>(options: ISimpleConnectionOptions<T>, connectionType: ConnectionType, args: any | undefined, timeoutCancellationToken: CancellationToken): Promise<{ protocol: PersistentProtocol; ownsProtocol: boolean }> {\n\tconst logPrefix = connectLogPrefix(options, connectionType);\n\n\toptions.logService.trace(`${logPrefix} 1/6. invoking socketFactory.connect().`);\n\n\tlet socket: ISocket;\n\ttry {\n\t\tsocket = await createSocket(options.logService, options.remoteSocketFactoryService, options.connectTo, RemoteAuthorities.getServerRootPath(), `reconnectionToken=${options.reconnectionToken}&reconnection=${options.reconnectionProtocol ? 'true' : 'false'}`, connectionTypeToString(connectionType), `renderer-${connectionTypeToString(connectionType)}-${options.reconnectionToken}`, timeoutCancellationToken);\n\t} catch (error) {\n\t\toptions.logService.error(`${logPrefix} socketFactory.connect() failed or timed out. Error:`);\n\t\toptions.logService.error(error);\n\t\tthrow error;\n\t}\n\n\toptions.logService.trace(`${logPrefix} 2/6. socketFactory.connect() was successful.`);\n\n\tlet protocol: PersistentProtocol;\n\tlet ownsProtocol: boolean;\n\tif (options.reconnectionProtocol) {\n\t\toptions.reconnectionProtocol.beginAcceptReconnection(socket, null);\n\t\tprotocol = options.reconnectionProtocol;\n\t\townsProtocol = false;\n\t} else {\n\t\tprotocol = new PersistentProtocol({ socket });\n\t\townsProtocol = true;\n\t}\n\n\toptions.logService.trace(`${logPrefix} 3/6. sending AuthRequest control message.`);\n\tconst message = await raceWithTimeoutCancellation(options.signService.createNewMessage(generateUuid()), timeoutCancellationToken);\n\n\tconst authRequest: AuthRequest = {\n\t\ttype: 'auth',\n\t\tauth: options.connectionToken || '00000000000000000000',\n\t\tdata: message.data\n\t};\n\tprotocol.sendControl(VSBuffer.fromString(JSON.stringify(authRequest)));\n\n\ttry {\n\t\tconst msg = await readOneControlMessage<HandshakeMessage>(protocol, combineTimeoutCancellation(timeoutCancellationToken, createTimeoutCancellation(10000)));\n\n\t\tif (msg.type !== 'sign' || typeof msg.data !== 'string') {\n\t\t\tconst error: any = new Error('Unexpected handshake message');\n\t\t\terror.code = 'VSCODE_CONNECTION_ERROR';\n\t\t\tthrow error;\n\t\t}\n\n\t\toptions.logService.trace(`${logPrefix} 4/6. received SignRequest control message.`);\n\n\t\tconst isValid = await raceWithTimeoutCancellation(options.signService.validate(message, msg.signedData), timeoutCancellationToken);\n\t\tif (!isValid) {\n\t\t\tconst error: any = new Error('Refused to connect to unsupported server');\n\t\t\terror.code = 'VSCODE_CONNECTION_ERROR';\n\t\t\tthrow error;\n\t\t}\n\n\t\tconst signed = await raceWithTimeoutCancellation(options.signService.sign(msg.data), timeoutCancellationToken);\n\t\tconst connTypeRequest: ConnectionTypeRequest = {\n\t\t\ttype: 'connectionType',\n\t\t\tcommit: options.commit,\n\t\t\tsignedData: signed,\n\t\t\tdesiredConnectionType: connectionType\n\t\t};\n\t\tif (args) {\n\t\t\tconnTypeRequest.args = args;\n\t\t}\n\n\t\toptions.logService.trace(`${logPrefix} 5/6. sending ConnectionTypeRequest control message.`);\n\t\tprotocol.sendControl(VSBuffer.fromString(JSON.stringify(connTypeRequest)));\n\n\t\treturn { protocol, ownsProtocol };\n\n\t} catch (error) {\n\t\tif (error && error.code === 'ETIMEDOUT') {\n\t\t\toptions.logService.error(`${logPrefix} the handshake timed out. Error:`);\n\t\t\toptions.logService.error(error);\n\t\t}\n\t\tif (error && error.code === 'VSCODE_CONNECTION_ERROR') {\n\t\t\toptions.logService.error(`${logPrefix} received error control message when negotiating connection. Error:`);\n\t\t\toptions.logService.error(error);\n\t\t}\n\t\tif (ownsProtocol) {\n\t\t\tsafeDisposeProtocolAndSocket(protocol);\n\t\t}\n\t\tthrow error;\n\t}\n}\n\ninterface IManagementConnectionResult {\n\tprotocol: PersistentProtocol;\n}\n\nasync function connectToRemoteExtensionHostAgentAndReadOneMessage<T>(options: ISimpleConnectionOptions, connectionType: ConnectionType, args: any | undefined, timeoutCancellationToken: CancellationToken): Promise<{ protocol: PersistentProtocol; firstMessage: T }> {\n\tconst startTime = Date.now();\n\tconst logPrefix = connectLogPrefix(options, connectionType);\n\tconst { protocol, ownsProtocol } = await connectToRemoteExtensionHostAgent(options, connectionType, args, timeoutCancellationToken);\n\tconst result = new PromiseWithTimeout<{ protocol: PersistentProtocol; firstMessage: T }>(timeoutCancellationToken);\n\tresult.registerDisposable(protocol.onControlMessage(raw => {\n\t\tconst msg: T = JSON.parse(raw.toString());\n\t\tconst error = getErrorFromMessage(msg);\n\t\tif (error) {\n\t\t\toptions.logService.error(`${logPrefix} received error control message when negotiating connection. Error:`);\n\t\t\toptions.logService.error(error);\n\t\t\tif (ownsProtocol) {\n\t\t\t\tsafeDisposeProtocolAndSocket(protocol);\n\t\t\t}\n\t\t\tresult.reject(error);\n\t\t} else {\n\t\t\toptions.reconnectionProtocol?.endAcceptReconnection();\n\t\t\toptions.logService.trace(`${logPrefix} 6/6. handshake finished, connection is up and running after ${logElapsed(startTime)}!`);\n\t\t\tresult.resolve({ protocol, firstMessage: msg });\n\t\t}\n\t}));\n\treturn result.promise;\n}\n\nasync function doConnectRemoteAgentManagement(options: ISimpleConnectionOptions, timeoutCancellationToken: CancellationToken): Promise<IManagementConnectionResult> {\n\tconst { protocol } = await connectToRemoteExtensionHostAgentAndReadOneMessage(options, ConnectionType.Management, undefined, timeoutCancellationToken);\n\treturn { protocol };\n}\n\nexport interface IRemoteExtensionHostStartParams {\n\tlanguage: string;\n\tdebugId?: string;\n\tbreak?: boolean;\n\tport?: number | null;\n\tenv?: { [key: string]: string | null };\n}\n\ninterface IExtensionHostConnectionResult {\n\tprotocol: PersistentProtocol;\n\tdebugPort?: number;\n}\n\nasync function doConnectRemoteAgentExtensionHost(options: ISimpleConnectionOptions, startArguments: IRemoteExtensionHostStartParams, timeoutCancellationToken: CancellationToken): Promise<IExtensionHostConnectionResult> {\n\tconst { protocol, firstMessage } = await connectToRemoteExtensionHostAgentAndReadOneMessage<{ debugPort?: number }>(options, ConnectionType.ExtensionHost, startArguments, timeoutCancellationToken);\n\tconst debugPort = firstMessage && firstMessage.debugPort;\n\treturn { protocol, debugPort };\n}\n\nexport interface ITunnelConnectionStartParams {\n\thost: string;\n\tport: number;\n}\n\nasync function doConnectRemoteAgentTunnel(options: ISimpleConnectionOptions, startParams: ITunnelConnectionStartParams, timeoutCancellationToken: CancellationToken): Promise<PersistentProtocol> {\n\tconst startTime = Date.now();\n\tconst logPrefix = connectLogPrefix(options, ConnectionType.Tunnel);\n\tconst { protocol } = await connectToRemoteExtensionHostAgent(options, ConnectionType.Tunnel, startParams, timeoutCancellationToken);\n\toptions.logService.trace(`${logPrefix} 6/6. handshake finished, connection is up and running after ${logElapsed(startTime)}!`);\n\treturn protocol;\n}\n\nexport interface IConnectionOptions<T extends RemoteConnection = RemoteConnection> {\n\tcommit: string | undefined;\n\tquality: string | undefined;\n\taddressProvider: IAddressProvider<T>;\n\tremoteSocketFactoryService: IRemoteSocketFactoryService;\n\tsignService: ISignService;\n\tlogService: ILogService;\n\tipcLogger: IIPCLogger | null;\n}\n\nasync function resolveConnectionOptions<T extends RemoteConnection>(options: IConnectionOptions<T>, reconnectionToken: string, reconnectionProtocol: PersistentProtocol | null): Promise<ISimpleConnectionOptions<T>> {\n\tconst { connectTo, connectionToken } = await options.addressProvider.getAddress();\n\treturn {\n\t\tcommit: options.commit,\n\t\tquality: options.quality,\n\t\tconnectTo,\n\t\tconnectionToken: connectionToken,\n\t\treconnectionToken: reconnectionToken,\n\t\treconnectionProtocol: reconnectionProtocol,\n\t\tremoteSocketFactoryService: options.remoteSocketFactoryService,\n\t\tsignService: options.signService,\n\t\tlogService: options.logService\n\t};\n}\n\nexport interface IAddress<T extends RemoteConnection = RemoteConnection> {\n\tconnectTo: T;\n\tconnectionToken: string | undefined;\n}\n\nexport interface IAddressProvider<T extends RemoteConnection = RemoteConnection> {\n\tgetAddress(): Promise<IAddress<T>>;\n}\n\nexport async function connectRemoteAgentManagement(options: IConnectionOptions, remoteAuthority: string, clientId: string): Promise<ManagementPersistentConnection> {\n\treturn createInitialConnection(\n\t\toptions,\n\t\tasync (simpleOptions) => {\n\t\t\tconst { protocol } = await doConnectRemoteAgentManagement(simpleOptions, CancellationToken.None);\n\t\t\treturn new ManagementPersistentConnection(options, remoteAuthority, clientId, simpleOptions.reconnectionToken, protocol);\n\t\t}\n\t);\n}\n\nexport async function connectRemoteAgentExtensionHost(options: IConnectionOptions, startArguments: IRemoteExtensionHostStartParams): Promise<ExtensionHostPersistentConnection> {\n\treturn createInitialConnection(\n\t\toptions,\n\t\tasync (simpleOptions) => {\n\t\t\tconst { protocol, debugPort } = await doConnectRemoteAgentExtensionHost(simpleOptions, startArguments, CancellationToken.None);\n\t\t\treturn new ExtensionHostPersistentConnection(options, startArguments, simpleOptions.reconnectionToken, protocol, debugPort);\n\t\t}\n\t);\n}\n\n/**\n * Will attempt to connect 5 times. If it fails 5 consecutive times, it will give up.\n */\nasync function createInitialConnection<T extends PersistentConnection, O extends RemoteConnection>(options: IConnectionOptions<O>, connectionFactory: (simpleOptions: ISimpleConnectionOptions<O>) => Promise<T>): Promise<T> {\n\tconst MAX_ATTEMPTS = 5;\n\n\tfor (let attempt = 1; ; attempt++) {\n\t\ttry {\n\t\t\tconst reconnectionToken = generateUuid();\n\t\t\tconst simpleOptions = await resolveConnectionOptions(options, reconnectionToken, null);\n\t\t\tconst result = await connectionFactory(simpleOptions);\n\t\t\treturn result;\n\t\t} catch (err) {\n\t\t\tif (attempt < MAX_ATTEMPTS) {\n\t\t\t\toptions.logService.error(`[remote-connection][attempt ${attempt}] An error occurred in initial connection! Will retry... Error:`);\n\t\t\t\toptions.logService.error(err);\n\t\t\t} else {\n\t\t\t\toptions.logService.error(`[remote-connection][attempt ${attempt}]  An error occurred in initial connection! It will be treated as a permanent error. Error:`);\n\t\t\t\toptions.logService.error(err);\n\t\t\t\tPersistentConnection.triggerPermanentFailure(0, 0, RemoteAuthorityResolverError.isHandled(err));\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport async function connectRemoteAgentTunnel(options: IConnectionOptions, tunnelRemoteHost: string, tunnelRemotePort: number): Promise<PersistentProtocol> {\n\tconst simpleOptions = await resolveConnectionOptions(options, generateUuid(), null);\n\tconst protocol = await doConnectRemoteAgentTunnel(simpleOptions, { host: tunnelRemoteHost, port: tunnelRemotePort }, CancellationToken.None);\n\treturn protocol;\n}\n\nfunction sleep(seconds: number): CancelablePromise<void> {\n\treturn createCancelablePromise(token => {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst timeout = setTimeout(resolve, seconds * 1000);\n\t\t\ttoken.onCancellationRequested(() => {\n\t\t\t\tclearTimeout(timeout);\n\t\t\t\tresolve();\n\t\t\t});\n\t\t});\n\t});\n}\n\nexport const enum PersistentConnectionEventType {\n\tConnectionLost,\n\tReconnectionWait,\n\tReconnectionRunning,\n\tReconnectionPermanentFailure,\n\tConnectionGain\n}\nexport class ConnectionLostEvent {\n\tpublic readonly type = PersistentConnectionEventType.ConnectionLost;\n\tconstructor(\n\t\tpublic readonly reconnectionToken: string,\n\t\tpublic readonly millisSinceLastIncomingData: number\n\t) { }\n}\nexport class ReconnectionWaitEvent {\n\tpublic readonly type = PersistentConnectionEventType.ReconnectionWait;\n\tconstructor(\n\t\tpublic readonly reconnectionToken: string,\n\t\tpublic readonly millisSinceLastIncomingData: number,\n\t\tpublic readonly durationSeconds: number,\n\t\tprivate readonly cancellableTimer: CancelablePromise<void>\n\t) { }\n\n\tpublic skipWait(): void {\n\t\tthis.cancellableTimer.cancel();\n\t}\n}\nexport class ReconnectionRunningEvent {\n\tpublic readonly type = PersistentConnectionEventType.ReconnectionRunning;\n\tconstructor(\n\t\tpublic readonly reconnectionToken: string,\n\t\tpublic readonly millisSinceLastIncomingData: number,\n\t\tpublic readonly attempt: number\n\t) { }\n}\nexport class ConnectionGainEvent {\n\tpublic readonly type = PersistentConnectionEventType.ConnectionGain;\n\tconstructor(\n\t\tpublic readonly reconnectionToken: string,\n\t\tpublic readonly millisSinceLastIncomingData: number,\n\t\tpublic readonly attempt: number\n\t) { }\n}\nexport class ReconnectionPermanentFailureEvent {\n\tpublic readonly type = PersistentConnectionEventType.ReconnectionPermanentFailure;\n\tconstructor(\n\t\tpublic readonly reconnectionToken: string,\n\t\tpublic readonly millisSinceLastIncomingData: number,\n\t\tpublic readonly attempt: number,\n\t\tpublic readonly handled: boolean\n\t) { }\n}\nexport type PersistentConnectionEvent = ConnectionGainEvent | ConnectionLostEvent | ReconnectionWaitEvent | ReconnectionRunningEvent | ReconnectionPermanentFailureEvent;\n\nexport abstract class PersistentConnection extends Disposable {\n\n\tpublic static triggerPermanentFailure(millisSinceLastIncomingData: number, attempt: number, handled: boolean): void {\n\t\tthis._permanentFailure = true;\n\t\tthis._permanentFailureMillisSinceLastIncomingData = millisSinceLastIncomingData;\n\t\tthis._permanentFailureAttempt = attempt;\n\t\tthis._permanentFailureHandled = handled;\n\t\tthis._instances.forEach(instance => instance._gotoPermanentFailure(this._permanentFailureMillisSinceLastIncomingData, this._permanentFailureAttempt, this._permanentFailureHandled));\n\t}\n\n\tpublic static debugTriggerReconnection() {\n\t\tthis._instances.forEach(instance => instance._beginReconnecting());\n\t}\n\n\tpublic static debugPauseSocketWriting() {\n\t\tthis._instances.forEach(instance => instance._pauseSocketWriting());\n\t}\n\n\tprivate static _permanentFailure: boolean = false;\n\tprivate static _permanentFailureMillisSinceLastIncomingData: number = 0;\n\tprivate static _permanentFailureAttempt: number = 0;\n\tprivate static _permanentFailureHandled: boolean = false;\n\tprivate static _instances: PersistentConnection[] = [];\n\n\tprivate readonly _onDidStateChange = this._register(new Emitter<PersistentConnectionEvent>());\n\tpublic readonly onDidStateChange = this._onDidStateChange.event;\n\n\tprivate _permanentFailure: boolean = false;\n\tprivate get _isPermanentFailure(): boolean {\n\t\treturn this._permanentFailure || PersistentConnection._permanentFailure;\n\t}\n\n\tprivate _isReconnecting: boolean = false;\n\tprivate _isDisposed: boolean = false;\n\n\tconstructor(\n\t\tprivate readonly _connectionType: ConnectionType,\n\t\tprotected readonly _options: IConnectionOptions,\n\t\tpublic readonly reconnectionToken: string,\n\t\tpublic readonly protocol: PersistentProtocol,\n\t\tprivate readonly _reconnectionFailureIsFatal: boolean\n\t) {\n\t\tsuper();\n\n\t\tthis._onDidStateChange.fire(new ConnectionGainEvent(this.reconnectionToken, 0, 0));\n\n\t\tthis._register(protocol.onSocketClose((e) => {\n\t\t\tconst logPrefix = commonLogPrefix(this._connectionType, this.reconnectionToken, true);\n\t\t\tif (!e) {\n\t\t\t\tthis._options.logService.info(`${logPrefix} received socket close event.`);\n\t\t\t} else if (e.type === SocketCloseEventType.NodeSocketCloseEvent) {\n\t\t\t\tthis._options.logService.info(`${logPrefix} received socket close event (hadError: ${e.hadError}).`);\n\t\t\t\tif (e.error) {\n\t\t\t\t\tthis._options.logService.error(e.error);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._options.logService.info(`${logPrefix} received socket close event (wasClean: ${e.wasClean}, code: ${e.code}, reason: ${e.reason}).`);\n\t\t\t\tif (e.event) {\n\t\t\t\t\tthis._options.logService.error(e.event);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._beginReconnecting();\n\t\t}));\n\t\tthis._register(protocol.onSocketTimeout((e) => {\n\t\t\tconst logPrefix = commonLogPrefix(this._connectionType, this.reconnectionToken, true);\n\t\t\tthis._options.logService.info(`${logPrefix} received socket timeout event (unacknowledgedMsgCount: ${e.unacknowledgedMsgCount}, timeSinceOldestUnacknowledgedMsg: ${e.timeSinceOldestUnacknowledgedMsg}, timeSinceLastReceivedSomeData: ${e.timeSinceLastReceivedSomeData}).`);\n\t\t\tthis._beginReconnecting();\n\t\t}));\n\n\t\tPersistentConnection._instances.push(this);\n\t\tthis._register(toDisposable(() => {\n\t\t\tconst myIndex = PersistentConnection._instances.indexOf(this);\n\t\t\tif (myIndex >= 0) {\n\t\t\t\tPersistentConnection._instances.splice(myIndex, 1);\n\t\t\t}\n\t\t}));\n\n\t\tif (this._isPermanentFailure) {\n\t\t\tthis._gotoPermanentFailure(PersistentConnection._permanentFailureMillisSinceLastIncomingData, PersistentConnection._permanentFailureAttempt, PersistentConnection._permanentFailureHandled);\n\t\t}\n\t}\n\n\tpublic override dispose(): void {\n\t\tsuper.dispose();\n\t\tthis._isDisposed = true;\n\t}\n\n\tprivate async _beginReconnecting(): Promise<void> {\n\t\t// Only have one reconnection loop active at a time.\n\t\tif (this._isReconnecting) {\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\tthis._isReconnecting = true;\n\t\t\tawait this._runReconnectingLoop();\n\t\t} finally {\n\t\t\tthis._isReconnecting = false;\n\t\t}\n\t}\n\n\tprivate async _runReconnectingLoop(): Promise<void> {\n\t\tif (this._isPermanentFailure || this._isDisposed) {\n\t\t\t// no more attempts!\n\t\t\treturn;\n\t\t}\n\t\tconst logPrefix = commonLogPrefix(this._connectionType, this.reconnectionToken, true);\n\t\tthis._options.logService.info(`${logPrefix} starting reconnecting loop. You can get more information with the trace log level.`);\n\t\tthis._onDidStateChange.fire(new ConnectionLostEvent(this.reconnectionToken, this.protocol.getMillisSinceLastIncomingData()));\n\t\tconst TIMES = [0, 5, 5, 10, 10, 10, 10, 10, 30];\n\t\tlet attempt = -1;\n\t\tdo {\n\t\t\tattempt++;\n\t\t\tconst waitTime = (attempt < TIMES.length ? TIMES[attempt] : TIMES[TIMES.length - 1]);\n\t\t\ttry {\n\t\t\t\tif (waitTime > 0) {\n\t\t\t\t\tconst sleepPromise = sleep(waitTime);\n\t\t\t\t\tthis._onDidStateChange.fire(new ReconnectionWaitEvent(this.reconnectionToken, this.protocol.getMillisSinceLastIncomingData(), waitTime, sleepPromise));\n\n\t\t\t\t\tthis._options.logService.info(`${logPrefix} waiting for ${waitTime} seconds before reconnecting...`);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait sleepPromise;\n\t\t\t\t\t} catch { } // User canceled timer\n\t\t\t\t}\n\n\t\t\t\tif (this._isPermanentFailure) {\n\t\t\t\t\tthis._options.logService.error(`${logPrefix} permanent failure occurred while running the reconnecting loop.`);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// connection was lost, let's try to re-establish it\n\t\t\t\tthis._onDidStateChange.fire(new ReconnectionRunningEvent(this.reconnectionToken, this.protocol.getMillisSinceLastIncomingData(), attempt + 1));\n\t\t\t\tthis._options.logService.info(`${logPrefix} resolving connection...`);\n\t\t\t\tconst simpleOptions = await resolveConnectionOptions(this._options, this.reconnectionToken, this.protocol);\n\t\t\t\tthis._options.logService.info(`${logPrefix} connecting to ${simpleOptions.connectTo}...`);\n\t\t\t\tawait this._reconnect(simpleOptions, createTimeoutCancellation(RECONNECT_TIMEOUT));\n\t\t\t\tthis._options.logService.info(`${logPrefix} reconnected!`);\n\t\t\t\tthis._onDidStateChange.fire(new ConnectionGainEvent(this.reconnectionToken, this.protocol.getMillisSinceLastIncomingData(), attempt + 1));\n\n\t\t\t\tbreak;\n\t\t\t} catch (err) {\n\t\t\t\tif (err.code === 'VSCODE_CONNECTION_ERROR') {\n\t\t\t\t\tthis._options.logService.error(`${logPrefix} A permanent error occurred in the reconnecting loop! Will give up now! Error:`);\n\t\t\t\t\tthis._options.logService.error(err);\n\t\t\t\t\tthis._onReconnectionPermanentFailure(this.protocol.getMillisSinceLastIncomingData(), attempt + 1, false);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (attempt > 360) {\n\t\t\t\t\t// ReconnectionGraceTime is 3hrs, with 30s between attempts that yields a maximum of 360 attempts\n\t\t\t\t\tthis._options.logService.error(`${logPrefix} An error occurred while reconnecting, but it will be treated as a permanent error because the reconnection grace time has expired! Will give up now! Error:`);\n\t\t\t\t\tthis._options.logService.error(err);\n\t\t\t\t\tthis._onReconnectionPermanentFailure(this.protocol.getMillisSinceLastIncomingData(), attempt + 1, false);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (RemoteAuthorityResolverError.isTemporarilyNotAvailable(err)) {\n\t\t\t\t\tthis._options.logService.info(`${logPrefix} A temporarily not available error occurred while trying to reconnect, will try again...`);\n\t\t\t\t\tthis._options.logService.trace(err);\n\t\t\t\t\t// try again!\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ((err.code === 'ETIMEDOUT' || err.code === 'ENETUNREACH' || err.code === 'ECONNREFUSED' || err.code === 'ECONNRESET') && err.syscall === 'connect') {\n\t\t\t\t\tthis._options.logService.info(`${logPrefix} A network error occurred while trying to reconnect, will try again...`);\n\t\t\t\t\tthis._options.logService.trace(err);\n\t\t\t\t\t// try again!\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (isCancellationError(err)) {\n\t\t\t\t\tthis._options.logService.info(`${logPrefix} A promise cancelation error occurred while trying to reconnect, will try again...`);\n\t\t\t\t\tthis._options.logService.trace(err);\n\t\t\t\t\t// try again!\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (err instanceof RemoteAuthorityResolverError) {\n\t\t\t\t\tthis._options.logService.error(`${logPrefix} A RemoteAuthorityResolverError occurred while trying to reconnect. Will give up now! Error:`);\n\t\t\t\t\tthis._options.logService.error(err);\n\t\t\t\t\tthis._onReconnectionPermanentFailure(this.protocol.getMillisSinceLastIncomingData(), attempt + 1, RemoteAuthorityResolverError.isHandled(err));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tthis._options.logService.error(`${logPrefix} An unknown error occurred while trying to reconnect, since this is an unknown case, it will be treated as a permanent error! Will give up now! Error:`);\n\t\t\t\tthis._options.logService.error(err);\n\t\t\t\tthis._onReconnectionPermanentFailure(this.protocol.getMillisSinceLastIncomingData(), attempt + 1, false);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (!this._isPermanentFailure && !this._isDisposed);\n\t}\n\n\tprivate _onReconnectionPermanentFailure(millisSinceLastIncomingData: number, attempt: number, handled: boolean): void {\n\t\tif (this._reconnectionFailureIsFatal) {\n\t\t\tPersistentConnection.triggerPermanentFailure(millisSinceLastIncomingData, attempt, handled);\n\t\t} else {\n\t\t\tthis._gotoPermanentFailure(millisSinceLastIncomingData, attempt, handled);\n\t\t}\n\t}\n\n\tprivate _gotoPermanentFailure(millisSinceLastIncomingData: number, attempt: number, handled: boolean): void {\n\t\tthis._onDidStateChange.fire(new ReconnectionPermanentFailureEvent(this.reconnectionToken, millisSinceLastIncomingData, attempt, handled));\n\t\tsafeDisposeProtocolAndSocket(this.protocol);\n\t}\n\n\tprivate _pauseSocketWriting(): void {\n\t\tthis.protocol.pauseSocketWriting();\n\t}\n\n\tprotected abstract _reconnect(options: ISimpleConnectionOptions, timeoutCancellationToken: CancellationToken): Promise<void>;\n}\n\nexport class ManagementPersistentConnection extends PersistentConnection {\n\n\tpublic readonly client: Client<RemoteAgentConnectionContext>;\n\n\tconstructor(options: IConnectionOptions, remoteAuthority: string, clientId: string, reconnectionToken: string, protocol: PersistentProtocol) {\n\t\tsuper(ConnectionType.Management, options, reconnectionToken, protocol, /*reconnectionFailureIsFatal*/true);\n\t\tthis.client = this._register(new Client<RemoteAgentConnectionContext>(protocol, {\n\t\t\tremoteAuthority: remoteAuthority,\n\t\t\tclientId: clientId\n\t\t}, options.ipcLogger));\n\t}\n\n\tprotected async _reconnect(options: ISimpleConnectionOptions, timeoutCancellationToken: CancellationToken): Promise<void> {\n\t\tawait doConnectRemoteAgentManagement(options, timeoutCancellationToken);\n\t}\n}\n\nexport class ExtensionHostPersistentConnection extends PersistentConnection {\n\n\tprivate readonly _startArguments: IRemoteExtensionHostStartParams;\n\tpublic readonly debugPort: number | undefined;\n\n\tconstructor(options: IConnectionOptions, startArguments: IRemoteExtensionHostStartParams, reconnectionToken: string, protocol: PersistentProtocol, debugPort: number | undefined) {\n\t\tsuper(ConnectionType.ExtensionHost, options, reconnectionToken, protocol, /*reconnectionFailureIsFatal*/false);\n\t\tthis._startArguments = startArguments;\n\t\tthis.debugPort = debugPort;\n\t}\n\n\tprotected async _reconnect(options: ISimpleConnectionOptions, timeoutCancellationToken: CancellationToken): Promise<void> {\n\t\tawait doConnectRemoteAgentExtensionHost(options, this._startArguments, timeoutCancellationToken);\n\t}\n}\n\nfunction safeDisposeProtocolAndSocket(protocol: PersistentProtocol): void {\n\ttry {\n\t\tprotocol.acceptDisconnect();\n\t\tconst socket = protocol.getSocket();\n\t\tprotocol.dispose();\n\t\tsocket.dispose();\n\t} catch (err) {\n\t\tonUnexpectedError(err);\n\t}\n}\n\nfunction getErrorFromMessage(msg: any): Error | null {\n\tif (msg && msg.type === 'error') {\n\t\tconst error = new Error(`Connection error: ${msg.reason}`);\n\t\t(<any>error).code = 'VSCODE_CONNECTION_ERROR';\n\t\treturn error;\n\t}\n\treturn null;\n}\n\nfunction stringRightPad(str: string, len: number): string {\n\twhile (str.length < len) {\n\t\tstr += ' ';\n\t}\n\treturn str;\n}\n\nfunction _commonLogPrefix(connectionType: ConnectionType, reconnectionToken: string): string {\n\treturn `[remote-connection][${stringRightPad(connectionTypeToString(connectionType), 13)}][${reconnectionToken.substr(0, 5)}\u2026]`;\n}\n\nfunction commonLogPrefix(connectionType: ConnectionType, reconnectionToken: string, isReconnect: boolean): string {\n\treturn `${_commonLogPrefix(connectionType, reconnectionToken)}[${isReconnect ? 'reconnect' : 'initial'}]`;\n}\n\nfunction connectLogPrefix(options: ISimpleConnectionOptions, connectionType: ConnectionType): string {\n\treturn `${commonLogPrefix(connectionType, options.reconnectionToken, !!options.reconnectionProtocol)}[${options.connectTo}]`;\n}\n\nfunction logElapsed(startTime: number): string {\n\treturn `${Date.now() - startTime} ms`;\n}\n"],
  "mappings": "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",
  "names": ["ConnectionType", "PersistentConnectionEventType"]
}
