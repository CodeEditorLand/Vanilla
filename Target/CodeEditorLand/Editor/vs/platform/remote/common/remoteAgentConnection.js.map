{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/remote/common/remoteAgentConnection.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport {\n\ttype CancelablePromise,\n\tcreateCancelablePromise,\n\tpromiseWithResolvers,\n} from \"../../../base/common/async.js\";\nimport { VSBuffer } from \"../../../base/common/buffer.js\";\nimport {\n\tCancellationToken,\n\tCancellationTokenSource,\n} from \"../../../base/common/cancellation.js\";\nimport {\n\tisCancellationError,\n\tonUnexpectedError,\n} from \"../../../base/common/errors.js\";\nimport { Emitter } from \"../../../base/common/event.js\";\nimport {\n\tDisposable,\n\tDisposableStore,\n\ttype IDisposable,\n\ttoDisposable,\n} from \"../../../base/common/lifecycle.js\";\nimport { RemoteAuthorities } from \"../../../base/common/network.js\";\nimport * as performance from \"../../../base/common/performance.js\";\nimport { StopWatch } from \"../../../base/common/stopwatch.js\";\nimport { generateUuid } from \"../../../base/common/uuid.js\";\nimport type { IIPCLogger } from \"../../../base/parts/ipc/common/ipc.js\";\nimport {\n\tClient,\n\ttype ISocket,\n\tPersistentProtocol,\n\tSocketCloseEventType,\n} from \"../../../base/parts/ipc/common/ipc.net.js\";\nimport type { ILogService } from \"../../log/common/log.js\";\nimport type { ISignService } from \"../../sign/common/sign.js\";\nimport type { RemoteAgentConnectionContext } from \"./remoteAgentEnvironment.js\";\nimport {\n\tRemoteAuthorityResolverError,\n\ttype RemoteConnection,\n} from \"./remoteAuthorityResolver.js\";\nimport type { IRemoteSocketFactoryService } from \"./remoteSocketFactoryService.js\";\n\nconst RECONNECT_TIMEOUT = 30 * 1000; /* 30s */\n\nexport enum ConnectionType {\n\tManagement = 1,\n\tExtensionHost = 2,\n\tTunnel = 3,\n}\n\nfunction connectionTypeToString(connectionType: ConnectionType): string {\n\tswitch (connectionType) {\n\t\tcase ConnectionType.Management:\n\t\t\treturn \"Management\";\n\t\tcase ConnectionType.ExtensionHost:\n\t\t\treturn \"ExtensionHost\";\n\t\tcase ConnectionType.Tunnel:\n\t\t\treturn \"Tunnel\";\n\t}\n}\n\nexport interface AuthRequest {\n\ttype: \"auth\";\n\tauth: string;\n\tdata: string;\n}\n\nexport interface SignRequest {\n\ttype: \"sign\";\n\tdata: string;\n\tsignedData: string;\n}\n\nexport interface ConnectionTypeRequest {\n\ttype: \"connectionType\";\n\tcommit?: string;\n\tsignedData: string;\n\tdesiredConnectionType?: ConnectionType;\n\targs?: any;\n}\n\nexport interface ErrorMessage {\n\ttype: \"error\";\n\treason: string;\n}\n\nexport interface OKMessage {\n\ttype: \"ok\";\n}\n\nexport type HandshakeMessage =\n\t| AuthRequest\n\t| SignRequest\n\t| ConnectionTypeRequest\n\t| ErrorMessage\n\t| OKMessage;\n\ninterface ISimpleConnectionOptions<\n\tT extends RemoteConnection = RemoteConnection,\n> {\n\tcommit: string | undefined;\n\tquality: string | undefined;\n\tconnectTo: T;\n\tconnectionToken: string | undefined;\n\treconnectionToken: string;\n\treconnectionProtocol: PersistentProtocol | null;\n\tremoteSocketFactoryService: IRemoteSocketFactoryService;\n\tsignService: ISignService;\n\tlogService: ILogService;\n}\n\nfunction createTimeoutCancellation(millis: number): CancellationToken {\n\tconst source = new CancellationTokenSource();\n\tsetTimeout(() => source.cancel(), millis);\n\treturn source.token;\n}\n\nfunction combineTimeoutCancellation(\n\ta: CancellationToken,\n\tb: CancellationToken,\n): CancellationToken {\n\tif (a.isCancellationRequested || b.isCancellationRequested) {\n\t\treturn CancellationToken.Cancelled;\n\t}\n\tconst source = new CancellationTokenSource();\n\ta.onCancellationRequested(() => source.cancel());\n\tb.onCancellationRequested(() => source.cancel());\n\treturn source.token;\n}\n\nclass PromiseWithTimeout<T> {\n\tprivate _state: \"pending\" | \"resolved\" | \"rejected\" | \"timedout\";\n\tprivate readonly _disposables: DisposableStore;\n\tpublic readonly promise: Promise<T>;\n\tprivate readonly _resolvePromise: (value: T) => void;\n\tprivate readonly _rejectPromise: (err: any) => void;\n\n\tpublic get didTimeout(): boolean {\n\t\treturn this._state === \"timedout\";\n\t}\n\n\tconstructor(timeoutCancellationToken: CancellationToken) {\n\t\tthis._state = \"pending\";\n\t\tthis._disposables = new DisposableStore();\n\n\t\t({\n\t\t\tpromise: this.promise,\n\t\t\tresolve: this._resolvePromise,\n\t\t\treject: this._rejectPromise,\n\t\t} = promiseWithResolvers<T>());\n\n\t\tif (timeoutCancellationToken.isCancellationRequested) {\n\t\t\tthis._timeout();\n\t\t} else {\n\t\t\tthis._disposables.add(\n\t\t\t\ttimeoutCancellationToken.onCancellationRequested(() =>\n\t\t\t\t\tthis._timeout(),\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\t}\n\n\tpublic registerDisposable(disposable: IDisposable): void {\n\t\tif (this._state === \"pending\") {\n\t\t\tthis._disposables.add(disposable);\n\t\t} else {\n\t\t\tdisposable.dispose();\n\t\t}\n\t}\n\n\tprivate _timeout(): void {\n\t\tif (this._state !== \"pending\") {\n\t\t\treturn;\n\t\t}\n\t\tthis._disposables.dispose();\n\t\tthis._state = \"timedout\";\n\t\tthis._rejectPromise(this._createTimeoutError());\n\t}\n\n\tprivate _createTimeoutError(): Error {\n\t\tconst err: any = new Error(\"Time limit reached\");\n\t\terr.code = \"ETIMEDOUT\";\n\t\terr.syscall = \"connect\";\n\t\treturn err;\n\t}\n\n\tpublic resolve(value: T): void {\n\t\tif (this._state !== \"pending\") {\n\t\t\treturn;\n\t\t}\n\t\tthis._disposables.dispose();\n\t\tthis._state = \"resolved\";\n\t\tthis._resolvePromise(value);\n\t}\n\n\tpublic reject(err: any): void {\n\t\tif (this._state !== \"pending\") {\n\t\t\treturn;\n\t\t}\n\t\tthis._disposables.dispose();\n\t\tthis._state = \"rejected\";\n\t\tthis._rejectPromise(err);\n\t}\n}\n\nfunction readOneControlMessage<T>(\n\tprotocol: PersistentProtocol,\n\ttimeoutCancellationToken: CancellationToken,\n): Promise<T> {\n\tconst result = new PromiseWithTimeout<T>(timeoutCancellationToken);\n\tresult.registerDisposable(\n\t\tprotocol.onControlMessage((raw) => {\n\t\t\tconst msg: T = JSON.parse(raw.toString());\n\t\t\tconst error = getErrorFromMessage(msg);\n\t\t\tif (error) {\n\t\t\t\tresult.reject(error);\n\t\t\t} else {\n\t\t\t\tresult.resolve(msg);\n\t\t\t}\n\t\t}),\n\t);\n\treturn result.promise;\n}\n\nfunction createSocket<T extends RemoteConnection>(\n\tlogService: ILogService,\n\tremoteSocketFactoryService: IRemoteSocketFactoryService,\n\tconnectTo: T,\n\tpath: string,\n\tquery: string,\n\tdebugConnectionType: string,\n\tdebugLabel: string,\n\ttimeoutCancellationToken: CancellationToken,\n): Promise<ISocket> {\n\tconst result = new PromiseWithTimeout<ISocket>(timeoutCancellationToken);\n\tconst sw = StopWatch.create(false);\n\tlogService.info(`Creating a socket (${debugLabel})...`);\n\tperformance.mark(`code/willCreateSocket/${debugConnectionType}`);\n\n\tremoteSocketFactoryService.connect(connectTo, path, query, debugLabel).then(\n\t\t(socket) => {\n\t\t\tif (result.didTimeout) {\n\t\t\t\tperformance.mark(\n\t\t\t\t\t`code/didCreateSocketError/${debugConnectionType}`,\n\t\t\t\t);\n\t\t\t\tlogService.info(\n\t\t\t\t\t`Creating a socket (${debugLabel}) finished after ${sw.elapsed()} ms, but this is too late and has timed out already.`,\n\t\t\t\t);\n\t\t\t\tsocket?.dispose();\n\t\t\t} else {\n\t\t\t\tperformance.mark(\n\t\t\t\t\t`code/didCreateSocketOK/${debugConnectionType}`,\n\t\t\t\t);\n\t\t\t\tlogService.info(\n\t\t\t\t\t`Creating a socket (${debugLabel}) was successful after ${sw.elapsed()} ms.`,\n\t\t\t\t);\n\t\t\t\tresult.resolve(socket);\n\t\t\t}\n\t\t},\n\t\t(err) => {\n\t\t\tperformance.mark(\n\t\t\t\t`code/didCreateSocketError/${debugConnectionType}`,\n\t\t\t);\n\t\t\tlogService.info(\n\t\t\t\t`Creating a socket (${debugLabel}) returned an error after ${sw.elapsed()} ms.`,\n\t\t\t);\n\t\t\tlogService.error(err);\n\t\t\tresult.reject(err);\n\t\t},\n\t);\n\n\treturn result.promise;\n}\n\nfunction raceWithTimeoutCancellation<T>(\n\tpromise: Promise<T>,\n\ttimeoutCancellationToken: CancellationToken,\n): Promise<T> {\n\tconst result = new PromiseWithTimeout<T>(timeoutCancellationToken);\n\tpromise.then(\n\t\t(res) => {\n\t\t\tif (!result.didTimeout) {\n\t\t\t\tresult.resolve(res);\n\t\t\t}\n\t\t},\n\t\t(err) => {\n\t\t\tif (!result.didTimeout) {\n\t\t\t\tresult.reject(err);\n\t\t\t}\n\t\t},\n\t);\n\treturn result.promise;\n}\n\nasync function connectToRemoteExtensionHostAgent<T extends RemoteConnection>(\n\toptions: ISimpleConnectionOptions<T>,\n\tconnectionType: ConnectionType,\n\targs: any | undefined,\n\ttimeoutCancellationToken: CancellationToken,\n): Promise<{ protocol: PersistentProtocol; ownsProtocol: boolean }> {\n\tconst logPrefix = connectLogPrefix(options, connectionType);\n\n\toptions.logService.trace(\n\t\t`${logPrefix} 1/6. invoking socketFactory.connect().`,\n\t);\n\n\tlet socket: ISocket;\n\ttry {\n\t\tsocket = await createSocket(\n\t\t\toptions.logService,\n\t\t\toptions.remoteSocketFactoryService,\n\t\t\toptions.connectTo,\n\t\t\tRemoteAuthorities.getServerRootPath(),\n\t\t\t`reconnectionToken=${options.reconnectionToken}&reconnection=${options.reconnectionProtocol ? \"true\" : \"false\"}`,\n\t\t\tconnectionTypeToString(connectionType),\n\t\t\t`renderer-${connectionTypeToString(connectionType)}-${options.reconnectionToken}`,\n\t\t\ttimeoutCancellationToken,\n\t\t);\n\t} catch (error) {\n\t\toptions.logService.error(\n\t\t\t`${logPrefix} socketFactory.connect() failed or timed out. Error:`,\n\t\t);\n\t\toptions.logService.error(error);\n\t\tthrow error;\n\t}\n\n\toptions.logService.trace(\n\t\t`${logPrefix} 2/6. socketFactory.connect() was successful.`,\n\t);\n\n\tlet protocol: PersistentProtocol;\n\tlet ownsProtocol: boolean;\n\tif (options.reconnectionProtocol) {\n\t\toptions.reconnectionProtocol.beginAcceptReconnection(socket, null);\n\t\tprotocol = options.reconnectionProtocol;\n\t\townsProtocol = false;\n\t} else {\n\t\tprotocol = new PersistentProtocol({ socket });\n\t\townsProtocol = true;\n\t}\n\n\toptions.logService.trace(\n\t\t`${logPrefix} 3/6. sending AuthRequest control message.`,\n\t);\n\tconst message = await raceWithTimeoutCancellation(\n\t\toptions.signService.createNewMessage(generateUuid()),\n\t\ttimeoutCancellationToken,\n\t);\n\n\tconst authRequest: AuthRequest = {\n\t\ttype: \"auth\",\n\t\tauth: options.connectionToken || \"00000000000000000000\",\n\t\tdata: message.data,\n\t};\n\tprotocol.sendControl(VSBuffer.fromString(JSON.stringify(authRequest)));\n\n\ttry {\n\t\tconst msg = await readOneControlMessage<HandshakeMessage>(\n\t\t\tprotocol,\n\t\t\tcombineTimeoutCancellation(\n\t\t\t\ttimeoutCancellationToken,\n\t\t\t\tcreateTimeoutCancellation(10000),\n\t\t\t),\n\t\t);\n\n\t\tif (msg.type !== \"sign\" || typeof msg.data !== \"string\") {\n\t\t\tconst error: any = new Error(\"Unexpected handshake message\");\n\t\t\terror.code = \"VSCODE_CONNECTION_ERROR\";\n\t\t\tthrow error;\n\t\t}\n\n\t\toptions.logService.trace(\n\t\t\t`${logPrefix} 4/6. received SignRequest control message.`,\n\t\t);\n\n\t\tconst isValid = await raceWithTimeoutCancellation(\n\t\t\toptions.signService.validate(message, msg.signedData),\n\t\t\ttimeoutCancellationToken,\n\t\t);\n\t\tif (!isValid) {\n\t\t\tconst error: any = new Error(\n\t\t\t\t\"Refused to connect to unsupported server\",\n\t\t\t);\n\t\t\terror.code = \"VSCODE_CONNECTION_ERROR\";\n\t\t\tthrow error;\n\t\t}\n\n\t\tconst signed = await raceWithTimeoutCancellation(\n\t\t\toptions.signService.sign(msg.data),\n\t\t\ttimeoutCancellationToken,\n\t\t);\n\t\tconst connTypeRequest: ConnectionTypeRequest = {\n\t\t\ttype: \"connectionType\",\n\t\t\tcommit: options.commit,\n\t\t\tsignedData: signed,\n\t\t\tdesiredConnectionType: connectionType,\n\t\t};\n\t\tif (args) {\n\t\t\tconnTypeRequest.args = args;\n\t\t}\n\n\t\toptions.logService.trace(\n\t\t\t`${logPrefix} 5/6. sending ConnectionTypeRequest control message.`,\n\t\t);\n\t\tprotocol.sendControl(\n\t\t\tVSBuffer.fromString(JSON.stringify(connTypeRequest)),\n\t\t);\n\n\t\treturn { protocol, ownsProtocol };\n\t} catch (error) {\n\t\tif (error && error.code === \"ETIMEDOUT\") {\n\t\t\toptions.logService.error(\n\t\t\t\t`${logPrefix} the handshake timed out. Error:`,\n\t\t\t);\n\t\t\toptions.logService.error(error);\n\t\t}\n\t\tif (error && error.code === \"VSCODE_CONNECTION_ERROR\") {\n\t\t\toptions.logService.error(\n\t\t\t\t`${logPrefix} received error control message when negotiating connection. Error:`,\n\t\t\t);\n\t\t\toptions.logService.error(error);\n\t\t}\n\t\tif (ownsProtocol) {\n\t\t\tsafeDisposeProtocolAndSocket(protocol);\n\t\t}\n\t\tthrow error;\n\t}\n}\n\ninterface IManagementConnectionResult {\n\tprotocol: PersistentProtocol;\n}\n\nasync function connectToRemoteExtensionHostAgentAndReadOneMessage<T>(\n\toptions: ISimpleConnectionOptions,\n\tconnectionType: ConnectionType,\n\targs: any | undefined,\n\ttimeoutCancellationToken: CancellationToken,\n): Promise<{ protocol: PersistentProtocol; firstMessage: T }> {\n\tconst startTime = Date.now();\n\tconst logPrefix = connectLogPrefix(options, connectionType);\n\tconst { protocol, ownsProtocol } = await connectToRemoteExtensionHostAgent(\n\t\toptions,\n\t\tconnectionType,\n\t\targs,\n\t\ttimeoutCancellationToken,\n\t);\n\tconst result = new PromiseWithTimeout<{\n\t\tprotocol: PersistentProtocol;\n\t\tfirstMessage: T;\n\t}>(timeoutCancellationToken);\n\tresult.registerDisposable(\n\t\tprotocol.onControlMessage((raw) => {\n\t\t\tconst msg: T = JSON.parse(raw.toString());\n\t\t\tconst error = getErrorFromMessage(msg);\n\t\t\tif (error) {\n\t\t\t\toptions.logService.error(\n\t\t\t\t\t`${logPrefix} received error control message when negotiating connection. Error:`,\n\t\t\t\t);\n\t\t\t\toptions.logService.error(error);\n\t\t\t\tif (ownsProtocol) {\n\t\t\t\t\tsafeDisposeProtocolAndSocket(protocol);\n\t\t\t\t}\n\t\t\t\tresult.reject(error);\n\t\t\t} else {\n\t\t\t\toptions.reconnectionProtocol?.endAcceptReconnection();\n\t\t\t\toptions.logService.trace(\n\t\t\t\t\t`${logPrefix} 6/6. handshake finished, connection is up and running after ${logElapsed(startTime)}!`,\n\t\t\t\t);\n\t\t\t\tresult.resolve({ protocol, firstMessage: msg });\n\t\t\t}\n\t\t}),\n\t);\n\treturn result.promise;\n}\n\nasync function doConnectRemoteAgentManagement(\n\toptions: ISimpleConnectionOptions,\n\ttimeoutCancellationToken: CancellationToken,\n): Promise<IManagementConnectionResult> {\n\tconst { protocol } =\n\t\tawait connectToRemoteExtensionHostAgentAndReadOneMessage(\n\t\t\toptions,\n\t\t\tConnectionType.Management,\n\t\t\tundefined,\n\t\t\ttimeoutCancellationToken,\n\t\t);\n\treturn { protocol };\n}\n\nexport interface IRemoteExtensionHostStartParams {\n\tlanguage: string;\n\tdebugId?: string;\n\tbreak?: boolean;\n\tport?: number | null;\n\tenv?: { [key: string]: string | null };\n}\n\ninterface IExtensionHostConnectionResult {\n\tprotocol: PersistentProtocol;\n\tdebugPort?: number;\n}\n\nasync function doConnectRemoteAgentExtensionHost(\n\toptions: ISimpleConnectionOptions,\n\tstartArguments: IRemoteExtensionHostStartParams,\n\ttimeoutCancellationToken: CancellationToken,\n): Promise<IExtensionHostConnectionResult> {\n\tconst { protocol, firstMessage } =\n\t\tawait connectToRemoteExtensionHostAgentAndReadOneMessage<{\n\t\t\tdebugPort?: number;\n\t\t}>(\n\t\t\toptions,\n\t\t\tConnectionType.ExtensionHost,\n\t\t\tstartArguments,\n\t\t\ttimeoutCancellationToken,\n\t\t);\n\tconst debugPort = firstMessage && firstMessage.debugPort;\n\treturn { protocol, debugPort };\n}\n\nexport interface ITunnelConnectionStartParams {\n\thost: string;\n\tport: number;\n}\n\nasync function doConnectRemoteAgentTunnel(\n\toptions: ISimpleConnectionOptions,\n\tstartParams: ITunnelConnectionStartParams,\n\ttimeoutCancellationToken: CancellationToken,\n): Promise<PersistentProtocol> {\n\tconst startTime = Date.now();\n\tconst logPrefix = connectLogPrefix(options, ConnectionType.Tunnel);\n\tconst { protocol } = await connectToRemoteExtensionHostAgent(\n\t\toptions,\n\t\tConnectionType.Tunnel,\n\t\tstartParams,\n\t\ttimeoutCancellationToken,\n\t);\n\toptions.logService.trace(\n\t\t`${logPrefix} 6/6. handshake finished, connection is up and running after ${logElapsed(startTime)}!`,\n\t);\n\treturn protocol;\n}\n\nexport interface IConnectionOptions<\n\tT extends RemoteConnection = RemoteConnection,\n> {\n\tcommit: string | undefined;\n\tquality: string | undefined;\n\taddressProvider: IAddressProvider<T>;\n\tremoteSocketFactoryService: IRemoteSocketFactoryService;\n\tsignService: ISignService;\n\tlogService: ILogService;\n\tipcLogger: IIPCLogger | null;\n}\n\nasync function resolveConnectionOptions<T extends RemoteConnection>(\n\toptions: IConnectionOptions<T>,\n\treconnectionToken: string,\n\treconnectionProtocol: PersistentProtocol | null,\n): Promise<ISimpleConnectionOptions<T>> {\n\tconst { connectTo, connectionToken } =\n\t\tawait options.addressProvider.getAddress();\n\treturn {\n\t\tcommit: options.commit,\n\t\tquality: options.quality,\n\t\tconnectTo,\n\t\tconnectionToken: connectionToken,\n\t\treconnectionToken: reconnectionToken,\n\t\treconnectionProtocol: reconnectionProtocol,\n\t\tremoteSocketFactoryService: options.remoteSocketFactoryService,\n\t\tsignService: options.signService,\n\t\tlogService: options.logService,\n\t};\n}\n\nexport interface IAddress<T extends RemoteConnection = RemoteConnection> {\n\tconnectTo: T;\n\tconnectionToken: string | undefined;\n}\n\nexport interface IAddressProvider<\n\tT extends RemoteConnection = RemoteConnection,\n> {\n\tgetAddress(): Promise<IAddress<T>>;\n}\n\nexport async function connectRemoteAgentManagement(\n\toptions: IConnectionOptions,\n\tremoteAuthority: string,\n\tclientId: string,\n): Promise<ManagementPersistentConnection> {\n\treturn createInitialConnection(options, async (simpleOptions) => {\n\t\tconst { protocol } = await doConnectRemoteAgentManagement(\n\t\t\tsimpleOptions,\n\t\t\tCancellationToken.None,\n\t\t);\n\t\treturn new ManagementPersistentConnection(\n\t\t\toptions,\n\t\t\tremoteAuthority,\n\t\t\tclientId,\n\t\t\tsimpleOptions.reconnectionToken,\n\t\t\tprotocol,\n\t\t);\n\t});\n}\n\nexport async function connectRemoteAgentExtensionHost(\n\toptions: IConnectionOptions,\n\tstartArguments: IRemoteExtensionHostStartParams,\n): Promise<ExtensionHostPersistentConnection> {\n\treturn createInitialConnection(options, async (simpleOptions) => {\n\t\tconst { protocol, debugPort } = await doConnectRemoteAgentExtensionHost(\n\t\t\tsimpleOptions,\n\t\t\tstartArguments,\n\t\t\tCancellationToken.None,\n\t\t);\n\t\treturn new ExtensionHostPersistentConnection(\n\t\t\toptions,\n\t\t\tstartArguments,\n\t\t\tsimpleOptions.reconnectionToken,\n\t\t\tprotocol,\n\t\t\tdebugPort,\n\t\t);\n\t});\n}\n\n/**\n * Will attempt to connect 5 times. If it fails 5 consecutive times, it will give up.\n */\nasync function createInitialConnection<\n\tT extends PersistentConnection,\n\tO extends RemoteConnection,\n>(\n\toptions: IConnectionOptions<O>,\n\tconnectionFactory: (\n\t\tsimpleOptions: ISimpleConnectionOptions<O>,\n\t) => Promise<T>,\n): Promise<T> {\n\tconst MAX_ATTEMPTS = 5;\n\n\tfor (let attempt = 1; ; attempt++) {\n\t\ttry {\n\t\t\tconst reconnectionToken = generateUuid();\n\t\t\tconst simpleOptions = await resolveConnectionOptions(\n\t\t\t\toptions,\n\t\t\t\treconnectionToken,\n\t\t\t\tnull,\n\t\t\t);\n\t\t\tconst result = await connectionFactory(simpleOptions);\n\t\t\treturn result;\n\t\t} catch (err) {\n\t\t\tif (attempt < MAX_ATTEMPTS) {\n\t\t\t\toptions.logService.error(\n\t\t\t\t\t`[remote-connection][attempt ${attempt}] An error occurred in initial connection! Will retry... Error:`,\n\t\t\t\t);\n\t\t\t\toptions.logService.error(err);\n\t\t\t} else {\n\t\t\t\toptions.logService.error(\n\t\t\t\t\t`[remote-connection][attempt ${attempt}]  An error occurred in initial connection! It will be treated as a permanent error. Error:`,\n\t\t\t\t);\n\t\t\t\toptions.logService.error(err);\n\t\t\t\tPersistentConnection.triggerPermanentFailure(\n\t\t\t\t\t0,\n\t\t\t\t\t0,\n\t\t\t\t\tRemoteAuthorityResolverError.isHandled(err),\n\t\t\t\t);\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport async function connectRemoteAgentTunnel(\n\toptions: IConnectionOptions,\n\ttunnelRemoteHost: string,\n\ttunnelRemotePort: number,\n): Promise<PersistentProtocol> {\n\tconst simpleOptions = await resolveConnectionOptions(\n\t\toptions,\n\t\tgenerateUuid(),\n\t\tnull,\n\t);\n\tconst protocol = await doConnectRemoteAgentTunnel(\n\t\tsimpleOptions,\n\t\t{ host: tunnelRemoteHost, port: tunnelRemotePort },\n\t\tCancellationToken.None,\n\t);\n\treturn protocol;\n}\n\nfunction sleep(seconds: number): CancelablePromise<void> {\n\treturn createCancelablePromise((token) => {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst timeout = setTimeout(resolve, seconds * 1000);\n\t\t\ttoken.onCancellationRequested(() => {\n\t\t\t\tclearTimeout(timeout);\n\t\t\t\tresolve();\n\t\t\t});\n\t\t});\n\t});\n}\n\nexport enum PersistentConnectionEventType {\n\tConnectionLost = 0,\n\tReconnectionWait = 1,\n\tReconnectionRunning = 2,\n\tReconnectionPermanentFailure = 3,\n\tConnectionGain = 4,\n}\nexport class ConnectionLostEvent {\n\tpublic readonly type = PersistentConnectionEventType.ConnectionLost;\n\tconstructor(\n\t\tpublic readonly reconnectionToken: string,\n\t\tpublic readonly millisSinceLastIncomingData: number,\n\t) {}\n}\nexport class ReconnectionWaitEvent {\n\tpublic readonly type = PersistentConnectionEventType.ReconnectionWait;\n\tconstructor(\n\t\tpublic readonly reconnectionToken: string,\n\t\tpublic readonly millisSinceLastIncomingData: number,\n\t\tpublic readonly durationSeconds: number,\n\t\tprivate readonly cancellableTimer: CancelablePromise<void>,\n\t) {}\n\n\tpublic skipWait(): void {\n\t\tthis.cancellableTimer.cancel();\n\t}\n}\nexport class ReconnectionRunningEvent {\n\tpublic readonly type = PersistentConnectionEventType.ReconnectionRunning;\n\tconstructor(\n\t\tpublic readonly reconnectionToken: string,\n\t\tpublic readonly millisSinceLastIncomingData: number,\n\t\tpublic readonly attempt: number,\n\t) {}\n}\nexport class ConnectionGainEvent {\n\tpublic readonly type = PersistentConnectionEventType.ConnectionGain;\n\tconstructor(\n\t\tpublic readonly reconnectionToken: string,\n\t\tpublic readonly millisSinceLastIncomingData: number,\n\t\tpublic readonly attempt: number,\n\t) {}\n}\nexport class ReconnectionPermanentFailureEvent {\n\tpublic readonly type =\n\t\tPersistentConnectionEventType.ReconnectionPermanentFailure;\n\tconstructor(\n\t\tpublic readonly reconnectionToken: string,\n\t\tpublic readonly millisSinceLastIncomingData: number,\n\t\tpublic readonly attempt: number,\n\t\tpublic readonly handled: boolean,\n\t) {}\n}\nexport type PersistentConnectionEvent =\n\t| ConnectionGainEvent\n\t| ConnectionLostEvent\n\t| ReconnectionWaitEvent\n\t| ReconnectionRunningEvent\n\t| ReconnectionPermanentFailureEvent;\n\nexport abstract class PersistentConnection extends Disposable {\n\tpublic static triggerPermanentFailure(\n\t\tmillisSinceLastIncomingData: number,\n\t\tattempt: number,\n\t\thandled: boolean,\n\t): void {\n\t\tthis._permanentFailure = true;\n\t\tthis._permanentFailureMillisSinceLastIncomingData =\n\t\t\tmillisSinceLastIncomingData;\n\t\tthis._permanentFailureAttempt = attempt;\n\t\tthis._permanentFailureHandled = handled;\n\t\tthis._instances.forEach((instance) =>\n\t\t\tinstance._gotoPermanentFailure(\n\t\t\t\tthis._permanentFailureMillisSinceLastIncomingData,\n\t\t\t\tthis._permanentFailureAttempt,\n\t\t\t\tthis._permanentFailureHandled,\n\t\t\t),\n\t\t);\n\t}\n\n\tpublic static debugTriggerReconnection() {\n\t\tthis._instances.forEach((instance) => instance._beginReconnecting());\n\t}\n\n\tpublic static debugPauseSocketWriting() {\n\t\tthis._instances.forEach((instance) => instance._pauseSocketWriting());\n\t}\n\n\tprivate static _permanentFailure = false;\n\tprivate static _permanentFailureMillisSinceLastIncomingData = 0;\n\tprivate static _permanentFailureAttempt = 0;\n\tprivate static _permanentFailureHandled = false;\n\tprivate static _instances: PersistentConnection[] = [];\n\n\tprivate readonly _onDidStateChange = this._register(\n\t\tnew Emitter<PersistentConnectionEvent>(),\n\t);\n\tpublic readonly onDidStateChange = this._onDidStateChange.event;\n\n\tprivate _permanentFailure = false;\n\tprivate get _isPermanentFailure(): boolean {\n\t\treturn this._permanentFailure || PersistentConnection._permanentFailure;\n\t}\n\n\tprivate _isReconnecting = false;\n\tprivate _isDisposed = false;\n\n\tconstructor(\n\t\tprivate readonly _connectionType: ConnectionType,\n\t\tprotected readonly _options: IConnectionOptions,\n\t\tpublic readonly reconnectionToken: string,\n\t\tpublic readonly protocol: PersistentProtocol,\n\t\tprivate readonly _reconnectionFailureIsFatal: boolean,\n\t) {\n\t\tsuper();\n\n\t\tthis._onDidStateChange.fire(\n\t\t\tnew ConnectionGainEvent(this.reconnectionToken, 0, 0),\n\t\t);\n\n\t\tthis._register(\n\t\t\tprotocol.onSocketClose((e) => {\n\t\t\t\tconst logPrefix = commonLogPrefix(\n\t\t\t\t\tthis._connectionType,\n\t\t\t\t\tthis.reconnectionToken,\n\t\t\t\t\ttrue,\n\t\t\t\t);\n\t\t\t\tif (!e) {\n\t\t\t\t\tthis._options.logService.info(\n\t\t\t\t\t\t`${logPrefix} received socket close event.`,\n\t\t\t\t\t);\n\t\t\t\t} else if (\n\t\t\t\t\te.type === SocketCloseEventType.NodeSocketCloseEvent\n\t\t\t\t) {\n\t\t\t\t\tthis._options.logService.info(\n\t\t\t\t\t\t`${logPrefix} received socket close event (hadError: ${e.hadError}).`,\n\t\t\t\t\t);\n\t\t\t\t\tif (e.error) {\n\t\t\t\t\t\tthis._options.logService.error(e.error);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis._options.logService.info(\n\t\t\t\t\t\t`${logPrefix} received socket close event (wasClean: ${e.wasClean}, code: ${e.code}, reason: ${e.reason}).`,\n\t\t\t\t\t);\n\t\t\t\t\tif (e.event) {\n\t\t\t\t\t\tthis._options.logService.error(e.event);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis._beginReconnecting();\n\t\t\t}),\n\t\t);\n\t\tthis._register(\n\t\t\tprotocol.onSocketTimeout((e) => {\n\t\t\t\tconst logPrefix = commonLogPrefix(\n\t\t\t\t\tthis._connectionType,\n\t\t\t\t\tthis.reconnectionToken,\n\t\t\t\t\ttrue,\n\t\t\t\t);\n\t\t\t\tthis._options.logService.info(\n\t\t\t\t\t`${logPrefix} received socket timeout event (unacknowledgedMsgCount: ${e.unacknowledgedMsgCount}, timeSinceOldestUnacknowledgedMsg: ${e.timeSinceOldestUnacknowledgedMsg}, timeSinceLastReceivedSomeData: ${e.timeSinceLastReceivedSomeData}).`,\n\t\t\t\t);\n\t\t\t\tthis._beginReconnecting();\n\t\t\t}),\n\t\t);\n\n\t\tPersistentConnection._instances.push(this);\n\t\tthis._register(\n\t\t\ttoDisposable(() => {\n\t\t\t\tconst myIndex = PersistentConnection._instances.indexOf(this);\n\t\t\t\tif (myIndex >= 0) {\n\t\t\t\t\tPersistentConnection._instances.splice(myIndex, 1);\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\n\t\tif (this._isPermanentFailure) {\n\t\t\tthis._gotoPermanentFailure(\n\t\t\t\tPersistentConnection._permanentFailureMillisSinceLastIncomingData,\n\t\t\t\tPersistentConnection._permanentFailureAttempt,\n\t\t\t\tPersistentConnection._permanentFailureHandled,\n\t\t\t);\n\t\t}\n\t}\n\n\tpublic override dispose(): void {\n\t\tsuper.dispose();\n\t\tthis._isDisposed = true;\n\t}\n\n\tprivate async _beginReconnecting(): Promise<void> {\n\t\t// Only have one reconnection loop active at a time.\n\t\tif (this._isReconnecting) {\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\tthis._isReconnecting = true;\n\t\t\tawait this._runReconnectingLoop();\n\t\t} finally {\n\t\t\tthis._isReconnecting = false;\n\t\t}\n\t}\n\n\tprivate async _runReconnectingLoop(): Promise<void> {\n\t\tif (this._isPermanentFailure || this._isDisposed) {\n\t\t\t// no more attempts!\n\t\t\treturn;\n\t\t}\n\t\tconst logPrefix = commonLogPrefix(\n\t\t\tthis._connectionType,\n\t\t\tthis.reconnectionToken,\n\t\t\ttrue,\n\t\t);\n\t\tthis._options.logService.info(\n\t\t\t`${logPrefix} starting reconnecting loop. You can get more information with the trace log level.`,\n\t\t);\n\t\tthis._onDidStateChange.fire(\n\t\t\tnew ConnectionLostEvent(\n\t\t\t\tthis.reconnectionToken,\n\t\t\t\tthis.protocol.getMillisSinceLastIncomingData(),\n\t\t\t),\n\t\t);\n\t\tconst TIMES = [0, 5, 5, 10, 10, 10, 10, 10, 30];\n\t\tlet attempt = -1;\n\t\tdo {\n\t\t\tattempt++;\n\t\t\tconst waitTime =\n\t\t\t\tattempt < TIMES.length\n\t\t\t\t\t? TIMES[attempt]\n\t\t\t\t\t: TIMES[TIMES.length - 1];\n\t\t\ttry {\n\t\t\t\tif (waitTime > 0) {\n\t\t\t\t\tconst sleepPromise = sleep(waitTime);\n\t\t\t\t\tthis._onDidStateChange.fire(\n\t\t\t\t\t\tnew ReconnectionWaitEvent(\n\t\t\t\t\t\t\tthis.reconnectionToken,\n\t\t\t\t\t\t\tthis.protocol.getMillisSinceLastIncomingData(),\n\t\t\t\t\t\t\twaitTime,\n\t\t\t\t\t\t\tsleepPromise,\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\n\t\t\t\t\tthis._options.logService.info(\n\t\t\t\t\t\t`${logPrefix} waiting for ${waitTime} seconds before reconnecting...`,\n\t\t\t\t\t);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait sleepPromise;\n\t\t\t\t\t} catch {} // User canceled timer\n\t\t\t\t}\n\n\t\t\t\tif (this._isPermanentFailure) {\n\t\t\t\t\tthis._options.logService.error(\n\t\t\t\t\t\t`${logPrefix} permanent failure occurred while running the reconnecting loop.`,\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// connection was lost, let's try to re-establish it\n\t\t\t\tthis._onDidStateChange.fire(\n\t\t\t\t\tnew ReconnectionRunningEvent(\n\t\t\t\t\t\tthis.reconnectionToken,\n\t\t\t\t\t\tthis.protocol.getMillisSinceLastIncomingData(),\n\t\t\t\t\t\tattempt + 1,\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t\tthis._options.logService.info(\n\t\t\t\t\t`${logPrefix} resolving connection...`,\n\t\t\t\t);\n\t\t\t\tconst simpleOptions = await resolveConnectionOptions(\n\t\t\t\t\tthis._options,\n\t\t\t\t\tthis.reconnectionToken,\n\t\t\t\t\tthis.protocol,\n\t\t\t\t);\n\t\t\t\tthis._options.logService.info(\n\t\t\t\t\t`${logPrefix} connecting to ${simpleOptions.connectTo}...`,\n\t\t\t\t);\n\t\t\t\tawait this._reconnect(\n\t\t\t\t\tsimpleOptions,\n\t\t\t\t\tcreateTimeoutCancellation(RECONNECT_TIMEOUT),\n\t\t\t\t);\n\t\t\t\tthis._options.logService.info(`${logPrefix} reconnected!`);\n\t\t\t\tthis._onDidStateChange.fire(\n\t\t\t\t\tnew ConnectionGainEvent(\n\t\t\t\t\t\tthis.reconnectionToken,\n\t\t\t\t\t\tthis.protocol.getMillisSinceLastIncomingData(),\n\t\t\t\t\t\tattempt + 1,\n\t\t\t\t\t),\n\t\t\t\t);\n\n\t\t\t\tbreak;\n\t\t\t} catch (err) {\n\t\t\t\tif (err.code === \"VSCODE_CONNECTION_ERROR\") {\n\t\t\t\t\tthis._options.logService.error(\n\t\t\t\t\t\t`${logPrefix} A permanent error occurred in the reconnecting loop! Will give up now! Error:`,\n\t\t\t\t\t);\n\t\t\t\t\tthis._options.logService.error(err);\n\t\t\t\t\tthis._onReconnectionPermanentFailure(\n\t\t\t\t\t\tthis.protocol.getMillisSinceLastIncomingData(),\n\t\t\t\t\t\tattempt + 1,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (attempt > 360) {\n\t\t\t\t\t// ReconnectionGraceTime is 3hrs, with 30s between attempts that yields a maximum of 360 attempts\n\t\t\t\t\tthis._options.logService.error(\n\t\t\t\t\t\t`${logPrefix} An error occurred while reconnecting, but it will be treated as a permanent error because the reconnection grace time has expired! Will give up now! Error:`,\n\t\t\t\t\t);\n\t\t\t\t\tthis._options.logService.error(err);\n\t\t\t\t\tthis._onReconnectionPermanentFailure(\n\t\t\t\t\t\tthis.protocol.getMillisSinceLastIncomingData(),\n\t\t\t\t\t\tattempt + 1,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\tRemoteAuthorityResolverError.isTemporarilyNotAvailable(err)\n\t\t\t\t) {\n\t\t\t\t\tthis._options.logService.info(\n\t\t\t\t\t\t`${logPrefix} A temporarily not available error occurred while trying to reconnect, will try again...`,\n\t\t\t\t\t);\n\t\t\t\t\tthis._options.logService.trace(err);\n\t\t\t\t\t// try again!\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\t(err.code === \"ETIMEDOUT\" ||\n\t\t\t\t\t\terr.code === \"ENETUNREACH\" ||\n\t\t\t\t\t\terr.code === \"ECONNREFUSED\" ||\n\t\t\t\t\t\terr.code === \"ECONNRESET\") &&\n\t\t\t\t\terr.syscall === \"connect\"\n\t\t\t\t) {\n\t\t\t\t\tthis._options.logService.info(\n\t\t\t\t\t\t`${logPrefix} A network error occurred while trying to reconnect, will try again...`,\n\t\t\t\t\t);\n\t\t\t\t\tthis._options.logService.trace(err);\n\t\t\t\t\t// try again!\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (isCancellationError(err)) {\n\t\t\t\t\tthis._options.logService.info(\n\t\t\t\t\t\t`${logPrefix} A promise cancelation error occurred while trying to reconnect, will try again...`,\n\t\t\t\t\t);\n\t\t\t\t\tthis._options.logService.trace(err);\n\t\t\t\t\t// try again!\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (err instanceof RemoteAuthorityResolverError) {\n\t\t\t\t\tthis._options.logService.error(\n\t\t\t\t\t\t`${logPrefix} A RemoteAuthorityResolverError occurred while trying to reconnect. Will give up now! Error:`,\n\t\t\t\t\t);\n\t\t\t\t\tthis._options.logService.error(err);\n\t\t\t\t\tthis._onReconnectionPermanentFailure(\n\t\t\t\t\t\tthis.protocol.getMillisSinceLastIncomingData(),\n\t\t\t\t\t\tattempt + 1,\n\t\t\t\t\t\tRemoteAuthorityResolverError.isHandled(err),\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tthis._options.logService.error(\n\t\t\t\t\t`${logPrefix} An unknown error occurred while trying to reconnect, since this is an unknown case, it will be treated as a permanent error! Will give up now! Error:`,\n\t\t\t\t);\n\t\t\t\tthis._options.logService.error(err);\n\t\t\t\tthis._onReconnectionPermanentFailure(\n\t\t\t\t\tthis.protocol.getMillisSinceLastIncomingData(),\n\t\t\t\t\tattempt + 1,\n\t\t\t\t\tfalse,\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (!this._isPermanentFailure && !this._isDisposed);\n\t}\n\n\tprivate _onReconnectionPermanentFailure(\n\t\tmillisSinceLastIncomingData: number,\n\t\tattempt: number,\n\t\thandled: boolean,\n\t): void {\n\t\tif (this._reconnectionFailureIsFatal) {\n\t\t\tPersistentConnection.triggerPermanentFailure(\n\t\t\t\tmillisSinceLastIncomingData,\n\t\t\t\tattempt,\n\t\t\t\thandled,\n\t\t\t);\n\t\t} else {\n\t\t\tthis._gotoPermanentFailure(\n\t\t\t\tmillisSinceLastIncomingData,\n\t\t\t\tattempt,\n\t\t\t\thandled,\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate _gotoPermanentFailure(\n\t\tmillisSinceLastIncomingData: number,\n\t\tattempt: number,\n\t\thandled: boolean,\n\t): void {\n\t\tthis._onDidStateChange.fire(\n\t\t\tnew ReconnectionPermanentFailureEvent(\n\t\t\t\tthis.reconnectionToken,\n\t\t\t\tmillisSinceLastIncomingData,\n\t\t\t\tattempt,\n\t\t\t\thandled,\n\t\t\t),\n\t\t);\n\t\tsafeDisposeProtocolAndSocket(this.protocol);\n\t}\n\n\tprivate _pauseSocketWriting(): void {\n\t\tthis.protocol.pauseSocketWriting();\n\t}\n\n\tprotected abstract _reconnect(\n\t\toptions: ISimpleConnectionOptions,\n\t\ttimeoutCancellationToken: CancellationToken,\n\t): Promise<void>;\n}\n\nexport class ManagementPersistentConnection extends PersistentConnection {\n\tpublic readonly client: Client<RemoteAgentConnectionContext>;\n\n\tconstructor(\n\t\toptions: IConnectionOptions,\n\t\tremoteAuthority: string,\n\t\tclientId: string,\n\t\treconnectionToken: string,\n\t\tprotocol: PersistentProtocol,\n\t) {\n\t\tsuper(\n\t\t\tConnectionType.Management,\n\t\t\toptions,\n\t\t\treconnectionToken,\n\t\t\tprotocol,\n\t\t\t/*reconnectionFailureIsFatal*/ true,\n\t\t);\n\t\tthis.client = this._register(\n\t\t\tnew Client<RemoteAgentConnectionContext>(\n\t\t\t\tprotocol,\n\t\t\t\t{\n\t\t\t\t\tremoteAuthority: remoteAuthority,\n\t\t\t\t\tclientId: clientId,\n\t\t\t\t},\n\t\t\t\toptions.ipcLogger,\n\t\t\t),\n\t\t);\n\t}\n\n\tprotected async _reconnect(\n\t\toptions: ISimpleConnectionOptions,\n\t\ttimeoutCancellationToken: CancellationToken,\n\t): Promise<void> {\n\t\tawait doConnectRemoteAgentManagement(options, timeoutCancellationToken);\n\t}\n}\n\nexport class ExtensionHostPersistentConnection extends PersistentConnection {\n\tprivate readonly _startArguments: IRemoteExtensionHostStartParams;\n\tpublic readonly debugPort: number | undefined;\n\n\tconstructor(\n\t\toptions: IConnectionOptions,\n\t\tstartArguments: IRemoteExtensionHostStartParams,\n\t\treconnectionToken: string,\n\t\tprotocol: PersistentProtocol,\n\t\tdebugPort: number | undefined,\n\t) {\n\t\tsuper(\n\t\t\tConnectionType.ExtensionHost,\n\t\t\toptions,\n\t\t\treconnectionToken,\n\t\t\tprotocol,\n\t\t\t/*reconnectionFailureIsFatal*/ false,\n\t\t);\n\t\tthis._startArguments = startArguments;\n\t\tthis.debugPort = debugPort;\n\t}\n\n\tprotected async _reconnect(\n\t\toptions: ISimpleConnectionOptions,\n\t\ttimeoutCancellationToken: CancellationToken,\n\t): Promise<void> {\n\t\tawait doConnectRemoteAgentExtensionHost(\n\t\t\toptions,\n\t\t\tthis._startArguments,\n\t\t\ttimeoutCancellationToken,\n\t\t);\n\t}\n}\n\nfunction safeDisposeProtocolAndSocket(protocol: PersistentProtocol): void {\n\ttry {\n\t\tprotocol.acceptDisconnect();\n\t\tconst socket = protocol.getSocket();\n\t\tprotocol.dispose();\n\t\tsocket.dispose();\n\t} catch (err) {\n\t\tonUnexpectedError(err);\n\t}\n}\n\nfunction getErrorFromMessage(msg: any): Error | null {\n\tif (msg && msg.type === \"error\") {\n\t\tconst error = new Error(`Connection error: ${msg.reason}`);\n\t\t(<any>error).code = \"VSCODE_CONNECTION_ERROR\";\n\t\treturn error;\n\t}\n\treturn null;\n}\n\nfunction stringRightPad(str: string, len: number): string {\n\twhile (str.length < len) {\n\t\tstr += \" \";\n\t}\n\treturn str;\n}\n\nfunction _commonLogPrefix(\n\tconnectionType: ConnectionType,\n\treconnectionToken: string,\n): string {\n\treturn `[remote-connection][${stringRightPad(connectionTypeToString(connectionType), 13)}][${reconnectionToken.substr(0, 5)}\u2026]`;\n}\n\nfunction commonLogPrefix(\n\tconnectionType: ConnectionType,\n\treconnectionToken: string,\n\tisReconnect: boolean,\n): string {\n\treturn `${_commonLogPrefix(connectionType, reconnectionToken)}[${isReconnect ? \"reconnect\" : \"initial\"}]`;\n}\n\nfunction connectLogPrefix(\n\toptions: ISimpleConnectionOptions,\n\tconnectionType: ConnectionType,\n): string {\n\treturn `${commonLogPrefix(connectionType, options.reconnectionToken, !!options.reconnectionProtocol)}[${options.connectTo}]`;\n}\n\nfunction logElapsed(startTime: number): string {\n\treturn `${Date.now() - startTime} ms`;\n}\n"],
  "mappings": "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",
  "names": ["ConnectionType", "PersistentConnectionEventType"]
}
