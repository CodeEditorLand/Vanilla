import{encodeBase64 as f,VSBuffer as c}from"../../../../vs/base/common/buffer.js";import{Emitter as b,PauseableEmitter as E}from"../../../../vs/base/common/event.js";import{Disposable as v,DisposableStore as S}from"../../../../vs/base/common/lifecycle.js";import{SocketDiagnostics as g}from"../../../../vs/base/parts/ipc/common/ipc.net.js";const h=(t,d,r)=>{const e=new Uint8Array(16);for(let o=0;o<16;o++)e[o]=Math.round(Math.random()*256);const s=f(c.wrap(e));return[`GET ws://localhost${t}?${d}&skipWebSocketFrames=true HTTP/1.1`,"Connection: Upgrade","Upgrade: websocket",`Sec-WebSocket-Key: ${s}`].join(`\r
`)+`\r
\r
`},m=c.fromString(`\r
\r
`);async function B(t,d,r,e,s){t.write(c.fromString(h(d,r,e)));const n=new S;try{return await new Promise((o,p)=>{let i;n.add(t.onData(a=>{i?i=c.concat([i,a],i.byteLength+a.byteLength):i=a;const l=i.indexOf(m);if(l===-1)return;o(t),t.pauseData();const u=i.slice(l+m.byteLength);u.byteLength&&s.onData.fire(u)})),n.add(t.onClose(a=>p(a??new Error("socket closed")))),n.add(t.onEnd(()=>p(new Error("socket ended"))))})}catch(o){throw t.dispose(),o}finally{n.dispose()}}class L extends v{constructor(r,e){super();this.debugLabel=r;this._register(e.onData),this._register(e.onData.event(s=>this.pausableDataEmitter.fire(s))),this.onClose=this._register(e.onClose).event,this.onEnd=this._register(e.onEnd).event}pausableDataEmitter=this._register(new E);onData=(...r)=>(this.pausableDataEmitter.isPaused&&queueMicrotask(()=>this.pausableDataEmitter.resume()),this.pausableDataEmitter.event(...r));onClose;onEnd;didDisposeEmitter=this._register(new b);onDidDispose=this.didDisposeEmitter.event;ended=!1;pauseData(){this.pausableDataEmitter.pause()}drain(){return Promise.resolve()}end(){this.ended=!0,this.closeRemote()}traceSocketEvent(r,e){g.traceSocketEvent(this,this.debugLabel,r,e)}dispose(){this.ended||this.closeRemote(),this.didDisposeEmitter.fire(),super.dispose()}}export{L as ManagedSocket,B as connectManagedSocket,h as makeRawSocketHeaders,m as socketRawEndHeaderSequence};
