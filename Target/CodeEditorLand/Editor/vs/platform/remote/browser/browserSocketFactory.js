import*as f from"../../../base/browser/dom.js";import{RunOnceScheduler as h}from"../../../base/common/async.js";import{VSBuffer as S}from"../../../base/common/buffer.js";import{Emitter as u}from"../../../base/common/event.js";import{Disposable as p}from"../../../base/common/lifecycle.js";import{SocketCloseEventType as _,SocketDiagnostics as v,SocketDiagnosticsEventType as n}from"../../../base/parts/ipc/common/ipc.net.js";import{RemoteAuthorityResolverError as y,RemoteAuthorityResolverErrorCode as b}from"../common/remoteAuthorityResolver.js";import{mainWindow as E}from"../../../base/browser/window.js";class g extends p{_onData=new u;onData=this._onData.event;_onOpen=this._register(new u);onOpen=this._onOpen.event;_onClose=this._register(new u);onClose=this._onClose.event;_onError=this._register(new u);onError=this._onError.event;_debugLabel;_socket;_fileReader;_queue;_isReading;_isClosed;_socketMessageListener;traceSocketEvent(t,o){v.traceSocketEvent(this._socket,this._debugLabel,t,o)}constructor(t,o){super(),this._debugLabel=o,this._socket=new WebSocket(t),this.traceSocketEvent(n.Created,{type:"BrowserWebSocket",url:t}),this._fileReader=new FileReader,this._queue=[],this._isReading=!1,this._isClosed=!1,this._fileReader.onload=e=>{this._isReading=!1;const s=e.target.result;this.traceSocketEvent(n.Read,s),this._onData.fire(s),this._queue.length>0&&r(this._queue.shift())};const r=e=>{if(this._isReading){this._queue.push(e);return}this._isReading=!0,this._fileReader.readAsArrayBuffer(e)};this._socketMessageListener=e=>{const s=e.data;this.traceSocketEvent(n.BrowserWebSocketBlobReceived,{type:s.type,size:s.size}),r(s)},this._socket.addEventListener("message",this._socketMessageListener),this._register(f.addDisposableListener(this._socket,"open",e=>{this.traceSocketEvent(n.Open),this._onOpen.fire()}));let i=null;const a=()=>{const e=i;i=null,this._onError.fire(e)},c=this._register(new h(a,0)),k=e=>{c.cancel(),i=e,c.schedule()},d=e=>{c.cancel(),i=e,a()};this._register(f.addDisposableListener(this._socket,"close",e=>{this.traceSocketEvent(n.Close,{code:e.code,reason:e.reason,wasClean:e.wasClean}),this._isClosed=!0,i&&(navigator.onLine?e.wasClean?(c.cancel(),a()):d(new y(e.reason||`WebSocket close with status code ${e.code}`,b.TemporarilyNotAvailable,e)):d(new y("Browser is offline",b.TemporarilyNotAvailable,e))),this._onClose.fire({code:e.code,reason:e.reason,wasClean:e.wasClean,event:e})})),this._register(f.addDisposableListener(this._socket,"error",e=>{this.traceSocketEvent(n.Error,{message:e?.message}),k(e)}))}send(t){this._isClosed||(this.traceSocketEvent(n.Write,t),this._socket.send(t))}close(){this._isClosed=!0,this.traceSocketEvent(n.Close),this._socket.close(),this._socket.removeEventListener("message",this._socketMessageListener),this.dispose()}}const m=new class{create(l,t){return new g(l,t)}};class w{socket;debugLabel;traceSocketEvent(t,o){typeof this.socket.traceSocketEvent=="function"?this.socket.traceSocketEvent(t,o):v.traceSocketEvent(this.socket,this.debugLabel,t,o)}constructor(t,o){this.socket=t,this.debugLabel=o}dispose(){this.socket.close()}onData(t){return this.socket.onData(o=>t(S.wrap(new Uint8Array(o))))}onClose(t){const o=r=>{t(typeof r>"u"?r:{type:_.WebSocketCloseEvent,code:r.code,reason:r.reason,wasClean:r.wasClean,event:r.event})};return this.socket.onClose(o)}onEnd(t){return p.None}write(t){this.socket.send(t.buffer)}end(){this.socket.close()}drain(){return Promise.resolve()}}class x{_webSocketFactory;constructor(t){this._webSocketFactory=t||m}supports(t){return!0}connect({host:t,port:o},r,i,a){return new Promise((c,k)=>{const d=/^https:/.test(E.location.href)?"wss":"ws",e=this._webSocketFactory.create(`${d}://${/:/.test(t)&&!/\[/.test(t)?`[${t}]`:t}:${o}${r}?${i}&skipWebSocketFrames=false`,a),s=e.onError(k);e.onOpen(()=>{s.dispose(),c(new w(e,a))})})}}export{x as BrowserSocketFactory};
