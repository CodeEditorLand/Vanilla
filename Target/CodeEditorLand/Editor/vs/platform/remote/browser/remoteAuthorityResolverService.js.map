{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/remote/browser/remoteAuthorityResolverService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { mainWindow } from '../../../base/browser/window.js';\nimport { DeferredPromise } from '../../../base/common/async.js';\nimport * as errors from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { RemoteAuthorities } from '../../../base/common/network.js';\nimport * as performance from '../../../base/common/performance.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { IProductService } from '../../product/common/productService.js';\nimport { IRemoteAuthorityResolverService, IRemoteConnectionData, RemoteConnectionType, ResolvedAuthority, ResolvedOptions, ResolverResult, WebSocketRemoteConnection, getRemoteAuthorityPrefix } from '../common/remoteAuthorityResolver.js';\nimport { parseAuthorityWithOptionalPort } from '../common/remoteHosts.js';\n\nexport class RemoteAuthorityResolverService extends Disposable implements IRemoteAuthorityResolverService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly _onDidChangeConnectionData = this._register(new Emitter<void>());\n\tpublic readonly onDidChangeConnectionData = this._onDidChangeConnectionData.event;\n\n\tprivate readonly _resolveAuthorityRequests = new Map<string, DeferredPromise<ResolverResult>>();\n\tprivate readonly _cache = new Map<string, ResolverResult>();\n\tprivate readonly _connectionToken: Promise<string> | string | undefined;\n\tprivate readonly _connectionTokens: Map<string, string>;\n\tprivate readonly _isWorkbenchOptionsBasedResolution: boolean;\n\n\tconstructor(\n\t\tisWorkbenchOptionsBasedResolution: boolean,\n\t\tconnectionToken: Promise<string> | string | undefined,\n\t\tresourceUriProvider: ((uri: URI) => URI) | undefined,\n\t\tserverBasePath: string | undefined,\n\t\t@IProductService productService: IProductService,\n\t\t@ILogService private readonly _logService: ILogService,\n\t) {\n\t\tsuper();\n\t\tthis._connectionToken = connectionToken;\n\t\tthis._connectionTokens = new Map<string, string>();\n\t\tthis._isWorkbenchOptionsBasedResolution = isWorkbenchOptionsBasedResolution;\n\t\tif (resourceUriProvider) {\n\t\t\tRemoteAuthorities.setDelegate(resourceUriProvider);\n\t\t}\n\t\tRemoteAuthorities.setServerRootPath(productService, serverBasePath);\n\t}\n\n\tasync resolveAuthority(authority: string): Promise<ResolverResult> {\n\t\tlet result = this._resolveAuthorityRequests.get(authority);\n\t\tif (!result) {\n\t\t\tresult = new DeferredPromise<ResolverResult>();\n\t\t\tthis._resolveAuthorityRequests.set(authority, result);\n\t\t\tif (this._isWorkbenchOptionsBasedResolution) {\n\t\t\t\tthis._doResolveAuthority(authority).then(v => result!.complete(v), (err) => result!.error(err));\n\t\t\t}\n\t\t}\n\n\t\treturn result.p;\n\t}\n\n\tasync getCanonicalURI(uri: URI): Promise<URI> {\n\t\t// todo@connor4312 make this work for web\n\t\treturn uri;\n\t}\n\n\tgetConnectionData(authority: string): IRemoteConnectionData | null {\n\t\tif (!this._cache.has(authority)) {\n\t\t\treturn null;\n\t\t}\n\t\tconst resolverResult = this._cache.get(authority)!;\n\t\tconst connectionToken = this._connectionTokens.get(authority) || resolverResult.authority.connectionToken;\n\t\treturn {\n\t\t\tconnectTo: resolverResult.authority.connectTo,\n\t\t\tconnectionToken: connectionToken\n\t\t};\n\t}\n\n\tprivate async _doResolveAuthority(authority: string): Promise<ResolverResult> {\n\t\tconst authorityPrefix = getRemoteAuthorityPrefix(authority);\n\t\tconst sw = StopWatch.create(false);\n\t\tthis._logService.info(`Resolving connection token (${authorityPrefix})...`);\n\t\tperformance.mark(`code/willResolveConnectionToken/${authorityPrefix}`);\n\t\tconst connectionToken = await Promise.resolve(this._connectionTokens.get(authority) || this._connectionToken);\n\t\tperformance.mark(`code/didResolveConnectionToken/${authorityPrefix}`);\n\t\tthis._logService.info(`Resolved connection token (${authorityPrefix}) after ${sw.elapsed()} ms`);\n\t\tconst defaultPort = (/^https:/.test(mainWindow.location.href) ? 443 : 80);\n\t\tconst { host, port } = parseAuthorityWithOptionalPort(authority, defaultPort);\n\t\tconst result: ResolverResult = { authority: { authority, connectTo: new WebSocketRemoteConnection(host, port), connectionToken } };\n\t\tRemoteAuthorities.set(authority, host, port);\n\t\tthis._cache.set(authority, result);\n\t\tthis._onDidChangeConnectionData.fire();\n\t\treturn result;\n\t}\n\n\n\t_clearResolvedAuthority(authority: string): void {\n\t\tif (this._resolveAuthorityRequests.has(authority)) {\n\t\t\tthis._resolveAuthorityRequests.get(authority)!.cancel();\n\t\t\tthis._resolveAuthorityRequests.delete(authority);\n\t\t}\n\t}\n\n\t_setResolvedAuthority(resolvedAuthority: ResolvedAuthority, options?: ResolvedOptions): void {\n\t\tif (this._resolveAuthorityRequests.has(resolvedAuthority.authority)) {\n\t\t\tconst request = this._resolveAuthorityRequests.get(resolvedAuthority.authority)!;\n\t\t\t// For non-websocket types, it's expected the embedder passes a `remoteResourceProvider`\n\t\t\t// which is wrapped to a `IResourceUriProvider` and is not handled here.\n\t\t\tif (resolvedAuthority.connectTo.type === RemoteConnectionType.WebSocket) {\n\t\t\t\tRemoteAuthorities.set(resolvedAuthority.authority, resolvedAuthority.connectTo.host, resolvedAuthority.connectTo.port);\n\t\t\t}\n\t\t\tif (resolvedAuthority.connectionToken) {\n\t\t\t\tRemoteAuthorities.setConnectionToken(resolvedAuthority.authority, resolvedAuthority.connectionToken);\n\t\t\t}\n\t\t\trequest.complete({ authority: resolvedAuthority, options });\n\t\t\tthis._onDidChangeConnectionData.fire();\n\t\t}\n\t}\n\n\t_setResolvedAuthorityError(authority: string, err: any): void {\n\t\tif (this._resolveAuthorityRequests.has(authority)) {\n\t\t\tconst request = this._resolveAuthorityRequests.get(authority)!;\n\t\t\t// Avoid that this error makes it to telemetry\n\t\t\trequest.error(errors.ErrorNoTelemetry.fromError(err));\n\t\t}\n\t}\n\n\t_setAuthorityConnectionToken(authority: string, connectionToken: string): void {\n\t\tthis._connectionTokens.set(authority, connectionToken);\n\t\tRemoteAuthorities.setConnectionToken(authority, connectionToken);\n\t\tthis._onDidChangeConnectionData.fire();\n\t}\n\n\t_setCanonicalURIProvider(provider: (uri: URI) => Promise<URI>): void {\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
