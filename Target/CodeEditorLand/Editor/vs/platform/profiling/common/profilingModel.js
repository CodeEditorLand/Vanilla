const f=(o,i)=>{const n=i[o];if(n.aggregateTime)return n.aggregateTime;let l=n.selfTime;for(const e of n.children)l+=f(e,i);return n.aggregateTime=l},g=o=>{let i=0;const n=new Map,l=e=>{const c=[e.functionName,e.url,e.scriptId,e.lineNumber,e.columnNumber].join(":"),s=n.get(c);if(s)return s.id;const a=i++;return n.set(c,{id:a,callFrame:e,location:{lineNumber:e.lineNumber+1,columnNumber:e.columnNumber+1}}),a};for(const e of o.nodes)e.locationId=l(e.callFrame),e.positionTicks=e.positionTicks?.map(c=>({...c,startLocationId:l({...e.callFrame,lineNumber:c.line-1,columnNumber:0}),endLocationId:l({...e.callFrame,lineNumber:c.line,columnNumber:0})}));return[...n.values()].sort((e,c)=>e.id-c.id).map(e=>({locations:[e.location],callFrame:e.callFrame}))},T=o=>{if(!o.timeDeltas||!o.samples)return{nodes:[],locations:[],samples:o.samples||[],timeDeltas:o.timeDeltas||[],duration:o.endTime-o.startTime};const{samples:i,timeDeltas:n}=o,e=g(o).map((t,r)=>{const m=t.locations[0];return{id:r,selfTime:0,aggregateTime:0,ticks:0,callFrame:t.callFrame,src:m}}),c=new Map,s=t=>{let r=c.get(t);return r===void 0&&(r=c.size,c.set(t,r)),r},a=new Array(o.nodes.length);for(let t=0;t<o.nodes.length;t++){const r=o.nodes[t],m=s(r.id);a[m]={id:m,selfTime:0,aggregateTime:0,locationId:r.locationId,children:r.children?.map(s)||[]};for(const d of r.positionTicks||[])d.startLocationId&&(e[d.startLocationId].ticks+=d.ticks)}for(const t of a)for(const r of t.children)a[r].parent=t.id;const b=o.endTime-o.startTime;let u=b-n[0];for(let t=0;t<n.length-1;t++){const r=n[t+1];a[s(i[t])].selfTime+=r,u-=r}a.length&&(a[s(i[n.length-1])].selfTime+=u,n.push(u));for(let t=0;t<a.length;t++){const r=a[t],m=e[r.locationId];m.aggregateTime+=f(t,a),m.selfTime+=r.selfTime}return{nodes:a,locations:e,samples:i.map(s),timeDeltas:n,duration:b}};class p{constructor(i,n){this.location=i;this.parent=n}static root(){return new p({id:-1,selfTime:0,aggregateTime:0,ticks:0,callFrame:{functionName:"(root)",lineNumber:-1,columnNumber:-1,scriptId:"0",url:""}})}children={};aggregateTime=0;selfTime=0;ticks=0;childrenSize=0;get id(){return this.location.id}get callFrame(){return this.location.callFrame}get src(){return this.location.src}addNode(i){this.selfTime+=i.selfTime,this.aggregateTime+=i.aggregateTime}}const I=(o,i,n,l=i)=>{let e=o.children[i.locationId];e||(e=new p(n.locations[i.locationId],o),o.childrenSize++,o.children[i.locationId]=e),e.addNode(l),i.parent&&I(e,n.nodes[i.parent],n,l)};export{p as BottomUpNode,T as buildModel,I as processNode};
