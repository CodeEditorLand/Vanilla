{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/profiling/common/profilingModel.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { IV8Profile, IV8ProfileNode } from \"./profiling.js\";\n\n// #region\n// https://github.com/microsoft/vscode-js-profile-visualizer/blob/6e7401128ee860be113a916f80fcfe20ac99418e/packages/vscode-js-profile-core/src/cpu/model.ts#L4\n\nexport interface IProfileModel {\n\tnodes: ReadonlyArray<IComputedNode>;\n\tlocations: ReadonlyArray<ILocation>;\n\tsamples: ReadonlyArray<number>;\n\ttimeDeltas: ReadonlyArray<number>;\n\trootPath?: string;\n\tduration: number;\n}\n\nexport interface IComputedNode {\n\tid: number;\n\tselfTime: number;\n\taggregateTime: number;\n\tchildren: number[];\n\tparent?: number;\n\tlocationId: number;\n}\n\nexport interface ISourceLocation {\n\tlineNumber: number;\n\tcolumnNumber: number;\n\t//   source: Dap.Source;\n\trelativePath?: string;\n}\n\nexport interface CdpCallFrame {\n\tfunctionName: string;\n\tscriptId: string;\n\turl: string;\n\tlineNumber: number;\n\tcolumnNumber: number;\n}\n\nexport interface CdpPositionTickInfo {\n\tline: number;\n\tticks: number;\n}\n\nexport interface INode {\n\tid: number;\n\t//   category: Category;\n\tcallFrame: CdpCallFrame;\n\tsrc?: ISourceLocation;\n}\n\nexport interface ILocation extends INode {\n\tselfTime: number;\n\taggregateTime: number;\n\tticks: number;\n}\n\nexport interface IAnnotationLocation {\n\tcallFrame: CdpCallFrame;\n\tlocations: ISourceLocation[];\n}\n\nexport interface IProfileNode extends IV8ProfileNode {\n\tlocationId?: number;\n\tpositionTicks?: (CdpPositionTickInfo & {\n\t\tstartLocationId?: number;\n\t\tendLocationId?: number;\n\t})[];\n}\n\nexport interface ICpuProfileRaw extends IV8Profile {\n\t//   $vscode?: IJsDebugAnnotations;\n\tnodes: IProfileNode[];\n}\n\n/**\n * Recursive function that computes and caches the aggregate time for the\n * children of the computed now.\n */\nconst computeAggregateTime = (\n\tindex: number,\n\tnodes: IComputedNode[],\n): number => {\n\tconst row = nodes[index];\n\tif (row.aggregateTime) {\n\t\treturn row.aggregateTime;\n\t}\n\n\tlet total = row.selfTime;\n\tfor (const child of row.children) {\n\t\ttotal += computeAggregateTime(child, nodes);\n\t}\n\n\treturn (row.aggregateTime = total);\n};\n\nconst ensureSourceLocations = (\n\tprofile: ICpuProfileRaw,\n): ReadonlyArray<IAnnotationLocation> => {\n\tlet locationIdCounter = 0;\n\tconst locationsByRef = new Map<\n\t\tstring,\n\t\t{ id: number; callFrame: CdpCallFrame; location: ISourceLocation }\n\t>();\n\n\tconst getLocationIdFor = (callFrame: CdpCallFrame) => {\n\t\tconst ref = [\n\t\t\tcallFrame.functionName,\n\t\t\tcallFrame.url,\n\t\t\tcallFrame.scriptId,\n\t\t\tcallFrame.lineNumber,\n\t\t\tcallFrame.columnNumber,\n\t\t].join(\":\");\n\n\t\tconst existing = locationsByRef.get(ref);\n\t\tif (existing) {\n\t\t\treturn existing.id;\n\t\t}\n\t\tconst id = locationIdCounter++;\n\t\tlocationsByRef.set(ref, {\n\t\t\tid,\n\t\t\tcallFrame,\n\t\t\tlocation: {\n\t\t\t\tlineNumber: callFrame.lineNumber + 1,\n\t\t\t\tcolumnNumber: callFrame.columnNumber + 1,\n\t\t\t\t// source: {\n\t\t\t\t// \tname: maybeFileUrlToPath(callFrame.url),\n\t\t\t\t// \tpath: maybeFileUrlToPath(callFrame.url),\n\t\t\t\t// \tsourceReference: 0,\n\t\t\t\t// },\n\t\t\t},\n\t\t});\n\n\t\treturn id;\n\t};\n\n\tfor (const node of profile.nodes) {\n\t\tnode.locationId = getLocationIdFor(node.callFrame);\n\t\tnode.positionTicks = node.positionTicks?.map((tick) => ({\n\t\t\t...tick,\n\t\t\t// weirdly, line numbers here are 1-based, not 0-based. The position tick\n\t\t\t// only gives line-level granularity, so 'mark' the entire range of source\n\t\t\t// code the tick refers to\n\t\t\tstartLocationId: getLocationIdFor({\n\t\t\t\t...node.callFrame,\n\t\t\t\tlineNumber: tick.line - 1,\n\t\t\t\tcolumnNumber: 0,\n\t\t\t}),\n\t\t\tendLocationId: getLocationIdFor({\n\t\t\t\t...node.callFrame,\n\t\t\t\tlineNumber: tick.line,\n\t\t\t\tcolumnNumber: 0,\n\t\t\t}),\n\t\t}));\n\t}\n\n\treturn [...locationsByRef.values()]\n\t\t.sort((a, b) => a.id - b.id)\n\t\t.map((l) => ({ locations: [l.location], callFrame: l.callFrame }));\n};\n\n/**\n * Computes the model for the given profile.\n */\nexport const buildModel = (profile: ICpuProfileRaw): IProfileModel => {\n\tif (!profile.timeDeltas || !profile.samples) {\n\t\treturn {\n\t\t\tnodes: [],\n\t\t\tlocations: [],\n\t\t\tsamples: profile.samples || [],\n\t\t\ttimeDeltas: profile.timeDeltas || [],\n\t\t\t// rootPath: profile.$vscode?.rootPath,\n\t\t\tduration: profile.endTime - profile.startTime,\n\t\t};\n\t}\n\n\tconst { samples, timeDeltas } = profile;\n\tconst sourceLocations = ensureSourceLocations(profile);\n\tconst locations: ILocation[] = sourceLocations.map((l, id) => {\n\t\tconst src = l.locations[0]; //getBestLocation(profile, l.locations);\n\n\t\treturn {\n\t\t\tid,\n\t\t\tselfTime: 0,\n\t\t\taggregateTime: 0,\n\t\t\tticks: 0,\n\t\t\t// category: categorize(l.callFrame, src),\n\t\t\tcallFrame: l.callFrame,\n\t\t\tsrc,\n\t\t};\n\t});\n\n\tconst idMap = new Map<\n\t\tnumber /* id in profile */,\n\t\tnumber /* incrementing ID */\n\t>();\n\tconst mapId = (nodeId: number) => {\n\t\tlet id = idMap.get(nodeId);\n\t\tif (id === undefined) {\n\t\t\tid = idMap.size;\n\t\t\tidMap.set(nodeId, id);\n\t\t}\n\n\t\treturn id;\n\t};\n\n\t// 1. Created a sorted list of nodes. It seems that the profile always has\n\t// incrementing IDs, although they are just not initially sorted.\n\tconst nodes = new Array<IComputedNode>(profile.nodes.length);\n\tfor (let i = 0; i < profile.nodes.length; i++) {\n\t\tconst node = profile.nodes[i];\n\n\t\t// make them 0-based:\n\t\tconst id = mapId(node.id);\n\t\tnodes[id] = {\n\t\t\tid,\n\t\t\tselfTime: 0,\n\t\t\taggregateTime: 0,\n\t\t\tlocationId: node.locationId as number,\n\t\t\tchildren: node.children?.map(mapId) || [],\n\t\t};\n\n\t\tfor (const child of node.positionTicks || []) {\n\t\t\tif (child.startLocationId) {\n\t\t\t\tlocations[child.startLocationId].ticks += child.ticks;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (const node of nodes) {\n\t\tfor (const child of node.children) {\n\t\t\tnodes[child].parent = node.id;\n\t\t}\n\t}\n\n\t// 2. The profile samples are the 'bottom-most' node, the currently running\n\t// code. Sum of these in the self time.\n\tconst duration = profile.endTime - profile.startTime;\n\tlet lastNodeTime = duration - timeDeltas[0];\n\tfor (let i = 0; i < timeDeltas.length - 1; i++) {\n\t\tconst d = timeDeltas[i + 1];\n\t\tnodes[mapId(samples[i])].selfTime += d;\n\t\tlastNodeTime -= d;\n\t}\n\n\t// Add in an extra time delta for the last sample. `timeDeltas[0]` is the\n\t// time before the first sample, and the time of the last sample is only\n\t// derived (approximately) by the missing time in the sum of deltas. Save\n\t// some work by calculating it here.\n\tif (nodes.length) {\n\t\tnodes[mapId(samples[timeDeltas.length - 1])].selfTime += lastNodeTime;\n\t\ttimeDeltas.push(lastNodeTime);\n\t}\n\n\t// 3. Add the aggregate times for all node children and locations\n\tfor (let i = 0; i < nodes.length; i++) {\n\t\tconst node = nodes[i];\n\t\tconst location = locations[node.locationId];\n\t\tlocation.aggregateTime += computeAggregateTime(i, nodes);\n\t\tlocation.selfTime += node.selfTime;\n\t}\n\n\treturn {\n\t\tnodes,\n\t\tlocations,\n\t\tsamples: samples.map(mapId),\n\t\ttimeDeltas,\n\t\t// rootPath: profile.$vscode?.rootPath,\n\t\tduration,\n\t};\n};\n\nexport class BottomUpNode {\n\tpublic static root() {\n\t\treturn new BottomUpNode({\n\t\t\tid: -1,\n\t\t\tselfTime: 0,\n\t\t\taggregateTime: 0,\n\t\t\tticks: 0,\n\t\t\tcallFrame: {\n\t\t\t\tfunctionName: \"(root)\",\n\t\t\t\tlineNumber: -1,\n\t\t\t\tcolumnNumber: -1,\n\t\t\t\tscriptId: \"0\",\n\t\t\t\turl: \"\",\n\t\t\t},\n\t\t});\n\t}\n\n\tpublic children: { [id: number]: BottomUpNode } = {};\n\tpublic aggregateTime = 0;\n\tpublic selfTime = 0;\n\tpublic ticks = 0;\n\tpublic childrenSize = 0;\n\n\tpublic get id() {\n\t\treturn this.location.id;\n\t}\n\n\tpublic get callFrame() {\n\t\treturn this.location.callFrame;\n\t}\n\n\tpublic get src() {\n\t\treturn this.location.src;\n\t}\n\n\tconstructor(\n\t\tpublic readonly location: ILocation,\n\t\tpublic readonly parent?: BottomUpNode,\n\t) {}\n\n\tpublic addNode(node: IComputedNode) {\n\t\tthis.selfTime += node.selfTime;\n\t\tthis.aggregateTime += node.aggregateTime;\n\t}\n}\n\nexport const processNode = (\n\taggregate: BottomUpNode,\n\tnode: IComputedNode,\n\tmodel: IProfileModel,\n\tinitialNode = node,\n) => {\n\tlet child = aggregate.children[node.locationId];\n\tif (!child) {\n\t\tchild = new BottomUpNode(model.locations[node.locationId], aggregate);\n\t\taggregate.childrenSize++;\n\t\taggregate.children[node.locationId] = child;\n\t}\n\n\tchild.addNode(initialNode);\n\n\tif (node.parent) {\n\t\tprocessNode(child, model.nodes[node.parent], model, initialNode);\n\t}\n};\n\n//#endregion\n\nexport interface BottomUpSample {\n\tselfTime: number;\n\ttotalTime: number;\n\tlocation: string;\n\tabsLocation: string;\n\turl: string;\n\tcaller: { percentage: number; absLocation: string; location: string }[];\n\tpercentage: number;\n\tisSpecial: boolean;\n}\n"],
  "mappings": "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",
  "names": []
}
