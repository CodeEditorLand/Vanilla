{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/observable/common/wrapInReloadableClass.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { isHotReloadEnabled } from '../../../base/common/hotReload.js';\nimport { readHotReloadableExport } from '../../../base/common/hotReloadHelpers.js';\nimport { IDisposable } from '../../../base/common/lifecycle.js';\nimport { autorunWithStore } from '../../../base/common/observable.js';\nimport { BrandedService, GetLeadingNonServiceArgs, IInstantiationService } from '../../instantiation/common/instantiation.js';\n\n/**\n * Wrap a class in a reloadable wrapper.\n * When the wrapper is created, the original class is created.\n * When the original class changes, the instance is re-created.\n*/\nexport function wrapInReloadableClass0<TArgs extends BrandedService[]>(getClass: () => Result<TArgs>): Result<GetLeadingNonServiceArgs<TArgs>> {\n\treturn !isHotReloadEnabled() ? getClass() : createWrapper(getClass, BaseClass0);\n}\n\ntype Result<TArgs extends any[]> = new (...args: TArgs) => IDisposable;\n\nclass BaseClass {\n\tconstructor(\n\t\tpublic readonly instantiationService: IInstantiationService,\n\t) { }\n\n\tpublic init(...params: any[]): void { }\n}\n\nfunction createWrapper<T extends any[]>(getClass: () => any, B: new (...args: T) => BaseClass) {\n\treturn (class ReloadableWrapper extends B {\n\t\tprivate _autorun: IDisposable | undefined = undefined;\n\n\t\toverride init(...params: any[]) {\n\t\t\tthis._autorun = autorunWithStore((reader, store) => {\n\t\t\t\tconst clazz = readHotReloadableExport(getClass(), reader);\n\t\t\t\tstore.add(this.instantiationService.createInstance(clazz as any, ...params) as IDisposable);\n\t\t\t});\n\t\t}\n\n\t\tdispose(): void {\n\t\t\tthis._autorun?.dispose();\n\t\t}\n\t}) as any;\n}\n\nclass BaseClass0 extends BaseClass {\n\tconstructor(@IInstantiationService i: IInstantiationService) { super(i); this.init(); }\n}\n\n/**\n * Wrap a class in a reloadable wrapper.\n * When the wrapper is created, the original class is created.\n * When the original class changes, the instance is re-created.\n*/\nexport function wrapInReloadableClass1<TArgs extends [any, ...BrandedService[]]>(getClass: () => Result<TArgs>): Result<GetLeadingNonServiceArgs<TArgs>> {\n\treturn !isHotReloadEnabled() ? getClass() as any : createWrapper(getClass, BaseClass1);\n}\n\nclass BaseClass1 extends BaseClass {\n\tconstructor(param1: any, @IInstantiationService i: IInstantiationService,) { super(i); this.init(param1); }\n}\n"],
  "mappings": ";;;;;;;;;;;;AAIA,SAAS,0BAA0B;AACnC,SAAS,+BAA+B;AACxC,SAAS,mBAAmB;AAC5B,SAAS,wBAAwB;AACjC,SAAS,gBAAgB,0BAA0B,6BAA6B;AAOzE,SAAS,uBAAuD,UAAwE;AAC9I,SAAO,CAAC,mBAAmB,IAAI,SAAS,IAAI,cAAc,UAAU,UAAU;AAC/E;AAFgB;AAMhB,MAAM,UAAU;AAAA,EACf,YACiB,sBACf;AADe;AAAA,EACb;AAAA,EAxBL,OAqBgB;AAAA;AAAA;AAAA,EAKR,QAAQ,QAAqB;AAAA,EAAE;AACvC;AAEA,SAAS,cAA+B,UAAqB,GAAkC;AAC9F,SAAQ,MAAM,0BAA0B,EAAE;AAAA,IA9B3C,OA8B2C;AAAA;AAAA;AAAA,IACjC,WAAoC;AAAA,IAEnC,QAAQ,QAAe;AAC/B,WAAK,WAAW,iBAAiB,CAAC,QAAQ,UAAU;AACnD,cAAM,QAAQ,wBAAwB,SAAS,GAAG,MAAM;AACxD,cAAM,IAAI,KAAK,qBAAqB,eAAe,OAAc,GAAG,MAAM,CAAgB;AAAA,MAC3F,CAAC;AAAA,IACF;AAAA,IAEA,UAAgB;AACf,WAAK,UAAU,QAAQ;AAAA,IACxB;AAAA,EACD;AACD;AAfS;AAiBT,IAAM,aAAN,cAAyB,UAAU;AAAA,EA9CnC,OA8CmC;AAAA;AAAA;AAAA,EAClC,YAAmC,GAA0B;AAAE,UAAM,CAAC;AAAG,SAAK,KAAK;AAAA,EAAG;AACvF;AAFM,aAAN;AAAA,EACc;AAAA,GADR;AASC,SAAS,uBAAiE,UAAwE;AACxJ,SAAO,CAAC,mBAAmB,IAAI,SAAS,IAAW,cAAc,UAAU,UAAU;AACtF;AAFgB;AAIhB,IAAM,aAAN,cAAyB,UAAU;AAAA,EA3DnC,OA2DmC;AAAA;AAAA;AAAA,EAClC,YAAY,QAAoC,GAA2B;AAAE,UAAM,CAAC;AAAG,SAAK,KAAK,MAAM;AAAA,EAAG;AAC3G;AAFM,aAAN;AAAA,EAC2B;AAAA,GADrB;",
  "names": []
}
