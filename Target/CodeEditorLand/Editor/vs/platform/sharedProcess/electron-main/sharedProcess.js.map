{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/platform/sharedProcess/electron-main/sharedProcess.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IpcMainEvent, MessagePortMain } from 'electron';\nimport { validatedIpcMain } from '../../../base/parts/ipc/electron-main/ipcMain.js';\nimport { Barrier, DeferredPromise } from '../../../base/common/async.js';\nimport { Disposable, IDisposable } from '../../../base/common/lifecycle.js';\nimport { IEnvironmentMainService } from '../../environment/electron-main/environmentMainService.js';\nimport { ILifecycleMainService } from '../../lifecycle/electron-main/lifecycleMainService.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { ISharedProcessConfiguration } from '../node/sharedProcess.js';\nimport { IUserDataProfilesService } from '../../userDataProfile/common/userDataProfile.js';\nimport { IPolicyService } from '../../policy/common/policy.js';\nimport { ILoggerMainService } from '../../log/electron-main/loggerService.js';\nimport { UtilityProcess } from '../../utilityProcess/electron-main/utilityProcess.js';\nimport { NullTelemetryService } from '../../telemetry/common/telemetryUtils.js';\nimport { parseSharedProcessDebugPort } from '../../environment/node/environmentService.js';\nimport { assertIsDefined } from '../../../base/common/types.js';\nimport { SharedProcessChannelConnection, SharedProcessRawConnection, SharedProcessLifecycle } from '../common/sharedProcess.js';\nimport { Emitter } from '../../../base/common/event.js';\n\nexport class SharedProcess extends Disposable {\n\n\tprivate readonly firstWindowConnectionBarrier = new Barrier();\n\n\tprivate utilityProcess: UtilityProcess | undefined = undefined;\n\tprivate utilityProcessLogListener: IDisposable | undefined = undefined;\n\n\tprivate readonly _onDidCrash = this._register(new Emitter<void>());\n\treadonly onDidCrash = this._onDidCrash.event;\n\n\tconstructor(\n\t\tprivate readonly machineId: string,\n\t\tprivate readonly sqmId: string,\n\t\tprivate readonly devDeviceId: string,\n\t\t@IEnvironmentMainService private readonly environmentMainService: IEnvironmentMainService,\n\t\t@IUserDataProfilesService private readonly userDataProfilesService: IUserDataProfilesService,\n\t\t@ILifecycleMainService private readonly lifecycleMainService: ILifecycleMainService,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@ILoggerMainService private readonly loggerMainService: ILoggerMainService,\n\t\t@IPolicyService private readonly policyService: IPolicyService\n\t) {\n\t\tsuper();\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\n\t\t// Shared process channel connections from workbench windows\n\t\tvalidatedIpcMain.on(SharedProcessChannelConnection.request, (e, nonce: string) => this.onWindowConnection(e, nonce, SharedProcessChannelConnection.response));\n\n\t\t// Shared process raw connections from workbench windows\n\t\tvalidatedIpcMain.on(SharedProcessRawConnection.request, (e, nonce: string) => this.onWindowConnection(e, nonce, SharedProcessRawConnection.response));\n\n\t\t// Lifecycle\n\t\tthis._register(this.lifecycleMainService.onWillShutdown(() => this.onWillShutdown()));\n\t}\n\n\tprivate async onWindowConnection(e: IpcMainEvent, nonce: string, responseChannel: string): Promise<void> {\n\t\tthis.logService.trace(`[SharedProcess] onWindowConnection for: ${responseChannel}`);\n\n\t\t// release barrier if this is the first window connection\n\t\tif (!this.firstWindowConnectionBarrier.isOpen()) {\n\t\t\tthis.firstWindowConnectionBarrier.open();\n\t\t}\n\n\t\t// await the shared process to be overall ready\n\t\t// we do not just wait for IPC ready because the\n\t\t// workbench window will communicate directly\n\n\t\tawait this.whenReady();\n\n\t\t// connect to the shared process passing the responseChannel\n\t\t// as payload to give a hint what the connection is about\n\n\t\tconst port = await this.connect(responseChannel);\n\n\t\t// Check back if the requesting window meanwhile closed\n\t\t// Since shared process is delayed on startup there is\n\t\t// a chance that the window close before the shared process\n\t\t// was ready for a connection.\n\n\t\tif (e.sender.isDestroyed()) {\n\t\t\treturn port.close();\n\t\t}\n\n\t\t// send the port back to the requesting window\n\t\te.sender.postMessage(responseChannel, nonce, [port]);\n\t}\n\n\tprivate onWillShutdown(): void {\n\t\tthis.logService.trace('[SharedProcess] onWillShutdown');\n\n\t\tthis.utilityProcess?.postMessage(SharedProcessLifecycle.exit);\n\t\tthis.utilityProcess = undefined;\n\t}\n\n\tprivate _whenReady: Promise<void> | undefined = undefined;\n\twhenReady(): Promise<void> {\n\t\tif (!this._whenReady) {\n\t\t\tthis._whenReady = (async () => {\n\n\t\t\t\t// Wait for shared process being ready to accept connection\n\t\t\t\tawait this.whenIpcReady;\n\n\t\t\t\t// Overall signal that the shared process was loaded and\n\t\t\t\t// all services within have been created.\n\n\t\t\t\tconst whenReady = new DeferredPromise<void>();\n\t\t\t\tthis.utilityProcess?.once(SharedProcessLifecycle.initDone, () => whenReady.complete());\n\n\t\t\t\tawait whenReady.p;\n\t\t\t\tthis.utilityProcessLogListener?.dispose();\n\t\t\t\tthis.logService.trace('[SharedProcess] Overall ready');\n\t\t\t})();\n\t\t}\n\n\t\treturn this._whenReady;\n\t}\n\n\tprivate _whenIpcReady: Promise<void> | undefined = undefined;\n\tprivate get whenIpcReady() {\n\t\tif (!this._whenIpcReady) {\n\t\t\tthis._whenIpcReady = (async () => {\n\n\t\t\t\t// Always wait for first window asking for connection\n\t\t\t\tawait this.firstWindowConnectionBarrier.wait();\n\n\t\t\t\t// Spawn shared process\n\t\t\t\tthis.createUtilityProcess();\n\n\t\t\t\t// Wait for shared process indicating that IPC connections are accepted\n\t\t\t\tconst sharedProcessIpcReady = new DeferredPromise<void>();\n\t\t\t\tthis.utilityProcess?.once(SharedProcessLifecycle.ipcReady, () => sharedProcessIpcReady.complete());\n\n\t\t\t\tawait sharedProcessIpcReady.p;\n\t\t\t\tthis.logService.trace('[SharedProcess] IPC ready');\n\t\t\t})();\n\t\t}\n\n\t\treturn this._whenIpcReady;\n\t}\n\n\tprivate createUtilityProcess(): void {\n\t\tthis.utilityProcess = this._register(new UtilityProcess(this.logService, NullTelemetryService, this.lifecycleMainService));\n\n\t\t// Install a log listener for very early shared process warnings and errors\n\t\tthis.utilityProcessLogListener = this.utilityProcess.onMessage((e: any) => {\n\t\t\tif (typeof e.warning === 'string') {\n\t\t\t\tthis.logService.warn(e.warning);\n\t\t\t} else if (typeof e.error === 'string') {\n\t\t\t\tthis.logService.error(e.error);\n\t\t\t}\n\t\t});\n\n\t\tconst inspectParams = parseSharedProcessDebugPort(this.environmentMainService.args, this.environmentMainService.isBuilt);\n\t\tlet execArgv: string[] | undefined = undefined;\n\t\tif (inspectParams.port) {\n\t\t\texecArgv = ['--nolazy'];\n\t\t\tif (inspectParams.break) {\n\t\t\t\texecArgv.push(`--inspect-brk=${inspectParams.port}`);\n\t\t\t} else {\n\t\t\t\texecArgv.push(`--inspect=${inspectParams.port}`);\n\t\t\t}\n\t\t}\n\n\t\tthis.utilityProcess.start({\n\t\t\ttype: 'shared-process',\n\t\t\tentryPoint: 'vs/code/electron-utility/sharedProcess/sharedProcessMain',\n\t\t\tpayload: this.createSharedProcessConfiguration(),\n\t\t\trespondToAuthRequestsFromMainProcess: true,\n\t\t\texecArgv\n\t\t});\n\n\t\tthis._register(this.utilityProcess.onCrash(() => this._onDidCrash.fire()));\n\t}\n\n\tprivate createSharedProcessConfiguration(): ISharedProcessConfiguration {\n\t\treturn {\n\t\t\tmachineId: this.machineId,\n\t\t\tsqmId: this.sqmId,\n\t\t\tdevDeviceId: this.devDeviceId,\n\t\t\tcodeCachePath: this.environmentMainService.codeCachePath,\n\t\t\tprofiles: {\n\t\t\t\thome: this.userDataProfilesService.profilesHome,\n\t\t\t\tall: this.userDataProfilesService.profiles,\n\t\t\t},\n\t\t\targs: this.environmentMainService.args,\n\t\t\tlogLevel: this.loggerMainService.getLogLevel(),\n\t\t\tloggers: this.loggerMainService.getRegisteredLoggers(),\n\t\t\tpoliciesData: this.policyService.serialize()\n\t\t};\n\t}\n\n\tasync connect(payload?: unknown): Promise<MessagePortMain> {\n\n\t\t// Wait for shared process being ready to accept connection\n\t\tawait this.whenIpcReady;\n\n\t\t// Connect and return message port\n\t\tconst utilityProcess = assertIsDefined(this.utilityProcess);\n\t\treturn utilityProcess.connect(payload);\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
