import*as a from"fs";import*as m from"../../../base/common/path.js";import{URI as w}from"../../../base/common/uri.js";import{ExtensionStoragePaths as L}from"../common/extHostStoragePaths.js";import{Disposable as y}from"../../../base/common/lifecycle.js";import{Schemas as g}from"../../../base/common/network.js";import{IntervalTimer as $,timeout as k}from"../../../base/common/async.js";import"../../../platform/log/common/log.js";import{Promises as d}from"../../../base/node/pfs.js";class U extends L{_workspaceStorageLock=null;async _getWorkspaceStorageURI(e){const o=await super._getWorkspaceStorageURI(e);if(o.scheme!==g.file)return o;if(this._environment.skipWorkspaceStorageLock)return this._logService.info(`Skipping acquiring lock for ${o.fsPath}.`),o;const r=o.fsPath;let s=0;do{let n;s===0?n=r:n=/[/\\]$/.test(r)?`${r.substr(0,r.length-1)}-${s}`:`${r}-${s}`,await I(n);const l=m.join(n,"vscode.lock"),i=await h(this._logService,l,!1);if(i)return this._workspaceStorageLock=i,process.on("exit",()=>{i.dispose()}),w.file(n);s++}while(s<10);return o}onWillDeactivateAll(){this._workspaceStorageLock?.setWillRelease(6e3)}}async function I(t){try{await a.promises.stat(t);return}catch{}try{await a.promises.mkdir(t,{recursive:!0})}catch{}}const T=1e3,f=10*60*1e3;class _ extends y{constructor(o,r){super();this.logService=o;this.filename=r;this._timer=this._register(new $),this._timer.cancelAndSet(async()=>{const s=await u(o,r);(!s||s.pid!==process.pid)&&(o.info(`Lock '${r}': The lock was lost unexpectedly.`),this._timer.cancel());try{await a.promises.utimes(r,new Date,new Date)}catch(n){o.error(n),o.info(`Lock '${r}': Could not update mtime.`)}},T)}_timer;dispose(){super.dispose();try{a.unlinkSync(this.filename)}catch{}}async setWillRelease(o){this.logService.info(`Lock '${this.filename}': Marking the lockfile as scheduled to be released in ${o} ms.`);try{const r={pid:process.pid,willReleaseAt:Date.now()+o};await d.writeFile(this.filename,JSON.stringify(r),{flag:"w"})}catch(r){this.logService.error(r)}}}async function h(t,e,o){try{const s={pid:process.pid,willReleaseAt:0};await d.writeFile(e,JSON.stringify(s),{flag:"wx"})}catch(s){t.error(s)}const r=await u(t,e);return!r||r.pid!==process.pid?o?(t.info(`Lock '${e}': Could not acquire lock, giving up.`),null):(t.info(`Lock '${e}': Could not acquire lock, checking if the file is stale.`),b(t,e)):(t.info(`Lock '${e}': Lock acquired.`),new _(t,e))}async function u(t,e){let o;try{o=await a.promises.readFile(e)}catch(r){return t.error(r),null}try{return JSON.parse(String(o))}catch(r){return t.error(r),null}}async function p(t,e){let o;try{o=await a.promises.stat(e)}catch(r){return t.error(r),0}return o.mtime.getTime()}function P(t){try{return process.kill(t,0),!0}catch{return!1}}async function b(t,e){const o=await u(t,e);if(!o)return t.info(`Lock '${e}': Could not read pid of lock holder.`),c(t,e);if(o.willReleaseAt){let i=o.willReleaseAt-Date.now();if(i<5e3){for(i>0?t.info(`Lock '${e}': The lockfile is scheduled to be released in ${i} ms.`):t.info(`Lock '${e}': The lockfile is scheduled to have been released.`);i>0;){if(await k(Math.min(100,i)),await p(t,e)===0)return c(t,e);i=o.willReleaseAt-Date.now()}return c(t,e)}}if(!P(o.pid))return t.info(`Lock '${e}': The pid ${o.pid} appears to be gone.`),c(t,e);const r=await p(t,e),s=Date.now()-r;if(s<=f)return t.info(`Lock '${e}': The lock does not look stale, elapsed: ${s} ms, giving up.`),null;t.info(`Lock '${e}': The lock looks stale, waiting for 2s.`),await k(2e3);const n=await p(t,e),l=Date.now()-n;return l<=f?(t.info(`Lock '${e}': The lock does not look stale, elapsed: ${l} ms, giving up.`),null):(t.info(`Lock '${e}': The lock looks stale even after waiting for 2s.`),c(t,e))}async function c(t,e){t.info(`Lock '${e}': Deleting a stale lock.`);try{await a.promises.unlink(e)}catch{}return h(t,e,!0)}export{U as ExtensionStoragePaths};
