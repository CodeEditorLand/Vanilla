var E=Object.defineProperty;var M=Object.getOwnPropertyDescriptor;var k=(i,n,e,o)=>{for(var t=o>1?void 0:o?M(n,e):n,r=i.length-1,s;r>=0;r--)(s=i[r])&&(t=(o?s(n,e,t):s(t))||t);return o&&t&&E(n,e,t),t},f=(i,n)=>(e,o)=>n(e,o,i);import*as g from"fs";import{exec as y}from"child_process";import{VSBuffer as I}from"../../../base/common/buffer.js";import{Emitter as v}from"../../../base/common/event.js";import{DisposableStore as F}from"../../../base/common/lifecycle.js";import{MovingAverage as _}from"../../../base/common/numbers.js";import{isLinux as A}from"../../../base/common/platform.js";import*as w from"../../../base/common/resources.js";import{URI as T}from"../../../base/common/uri.js";import*as D from"../../../base/node/pfs.js";import{SocketCloseEventType as H}from"../../../base/parts/ipc/common/ipc.net.js";import{ILogService as $}from"../../../platform/log/common/log.js";import{ManagedSocket as N,connectManagedSocket as j}from"../../../platform/remote/common/managedSocket.js";import{ManagedRemoteConnection as L}from"../../../platform/remote/common/remoteAuthorityResolver.js";import{ISignService as V}from"../../../platform/sign/common/sign.js";import{isAllInterfaces as q,isLocalhost as B}from"../../../platform/tunnel/common/tunnel.js";import{NodeRemoteTunnel as U}from"../../../platform/tunnel/node/tunnelService.js";import{IExtHostInitDataService as J}from"../common/extHostInitDataService.js";import{IExtHostRpcService as O}from"../common/extHostRpcService.js";import{ExtHostTunnelService as z}from"../common/extHostTunnelService.js";import{parseAddress as W}from"../../services/remote/common/tunnelModel.js";import"vscode";function X(i){const n=i.trim().split(`
`),e=[];return n.forEach(t=>{const r=/\/proc\/(\d+)\/fd\/\d+ -> socket:\[(\d+)\]/.exec(t);r&&r.length>=3&&e.push({pid:parseInt(r[1],10),socket:parseInt(r[2],10)})}),e.reduce((t,r)=>(t[r.socket]=r,t),{})}function Z(...i){const n=[].concat(...i.map(K));return[...new Map(n.filter(e=>e.st==="0A").map(e=>{const o=e.local_address.split(":");return{socket:parseInt(e.inode,10),ip:G(o[0]),port:parseInt(o[1],16)}}).map(e=>[e.ip+":"+e.port,e])).values()]}function G(i){let n="";if(i.length===8)for(let e=i.length-2;e>=0;e-=2)n+=parseInt(i.substr(e,2),16),e!==0&&(n+=".");else for(let e=0;e<i.length;e+=8){const o=i.substring(e,e+8);let t="";for(let r=8;r>=2;r-=2)t+=o.substring(r-2,r),(r===6||r===2)&&(t=parseInt(t,16).toString(16),n+=`${t}`,t="",e+r!==i.length-6&&(n+=":"))}return n}function K(i){const n=i.trim().split(`
`),e=n.shift().trim().split(/\s+/).filter(t=>t!=="rx_queue"&&t!=="tm->when");return n.map(t=>t.trim().split(/\s+/).reduce((r,s,c)=>(r[e[c]||c]=s,r),{}))}function Q(i){return!!i.match(/.*\.vscode-server-[a-zA-Z]+\/bin.*/)||i.indexOf("out/server-main.js")!==-1||i.indexOf("_productName=VSCode")!==-1}function Y(i){const n=i.trim().split(`
`),e=[];return n.forEach(o=>{const t=/^\d+\s+\D+\s+root\s+(\d+)\s+(\d+).+\d+\:\d+\:\d+\s+(.+)$/.exec(o);t&&t.length>=4&&e.push({pid:parseInt(t[1],10),ppid:parseInt(t[2]),cmd:t[3]})}),e}async function ee(i,n,e){const o=e.reduce((r,s)=>(r[s.pid]=s,r),{}),t=[];return i.forEach(({socket:r,ip:s,port:c})=>{const d=n[r]?n[r].pid:void 0,a=d?o[d]?.cmd:void 0;d&&a&&!Q(a)&&t.push({host:s,port:c,detail:a,pid:d})}),t}function te(i,n,e){const o=new Map,t=Y(n);for(const r of i){const s=e.get(r.port);if(s){o.set(r.port,s);continue}const c=t.find(d=>d.cmd.includes(`${r.port}`));if(c){let d=c,a;do a=t.find(m=>m.ppid===d.pid),a&&(d=a);while(a);o.set(r.port,{host:r.ip,port:r.port,pid:d.pid,detail:d.cmd,ppid:d.ppid})}else o.set(r.port,{host:r.ip,port:r.port,ppid:Number.MAX_VALUE})}return o}let P=class extends z{constructor(e,o,t,r){super(e,o,t);this.initData=o;this.signService=r;A&&o.remote.isRemote&&o.remote.authority&&(this._proxy.$setRemoteTunnelService(process.pid),this.setInitialCandidates())}_initialCandidates=void 0;_foundRootPorts=new Map;_candidateFindingEnabled=!1;async $registerCandidateFinder(e){if(e&&this._candidateFindingEnabled)return;this._candidateFindingEnabled=e;let o;this._initialCandidates&&(o=this._initialCandidates,await this._proxy.$onFoundNewCandidates(this._initialCandidates));const t=new _;let r=0;for(;this._candidateFindingEnabled;){const s=new Date().getTime(),c=(await this.findCandidatePorts()).filter(m=>B(m.host)||q(m.host));this.logService.trace(`ForwardedPorts: (ExtHostTunnelService) found candidate ports ${c.map(m=>m.port).join(", ")}`);const d=new Date().getTime()-s;this.logService.trace(`ForwardedPorts: (ExtHostTunnelService) candidate port scan took ${d} ms.`),r++>3&&t.update(d),(!o||JSON.stringify(o)!==JSON.stringify(c))&&(o=c,await this._proxy.$onFoundNewCandidates(o));const a=this.calculateDelay(t.value);this.logService.trace(`ForwardedPorts: (ExtHostTunnelService) next candidate port scan in ${a} ms.`),await new Promise(m=>setTimeout(()=>m(),a))}}calculateDelay(e){return Math.max(e*20,2e3)}async setInitialCandidates(){this._initialCandidates=await this.findCandidatePorts(),this.logService.trace(`ForwardedPorts: (ExtHostTunnelService) Initial candidates found: ${this._initialCandidates.map(e=>e.port).join(", ")}`)}async findCandidatePorts(){let e="",o="";try{e=await g.promises.readFile("/proc/net/tcp","utf8"),o=await g.promises.readFile("/proc/net/tcp6","utf8")}catch{}const t=Z(e,o),r=await new Promise(p=>{y("ls -l /proc/[0-9]*/fd/[0-9]* | grep socket:",(l,u,b)=>{p(u)})}),s=X(r),c=await D.Promises.readdir("/proc"),d=[];for(const p of c)try{const l=Number(p),u=w.joinPath(T.file("/proc"),p);if((await g.promises.stat(u.fsPath)).isDirectory()&&!isNaN(l)){const C=await g.promises.readlink(w.joinPath(u,"cwd").fsPath),x=await g.promises.readFile(w.joinPath(u,"cmdline").fsPath,"utf8");d.push({pid:l,cwd:C,cmd:x})}}catch{}const a=[],m=t.filter(p=>{const l=s[p.socket];return l||a.push(p),l}),R=ee(m,s,d);let h;if(this.logService.trace(`ForwardedPorts: (ExtHostTunnelService) number of possible root ports ${a.length}`),a.length>0){const p=await new Promise(l=>{y("ps -F -A -l | grep root",(u,b,C)=>{l(b)})});this._foundRootPorts=te(a,p,this._foundRootPorts),h=Array.from(this._foundRootPorts.values()),this.logService.trace(`ForwardedPorts: (ExtHostTunnelService) heuristic ports ${h.map(l=>l.port).join(", ")}`)}return R.then(p=>h?p.concat(h):p)}makeManagedTunnelFactory(e){return async o=>{const t=new U({commit:this.initData.commit,quality:this.initData.quality,logService:this.logService,ipcLogger:null,remoteSocketFactoryService:{_serviceBrand:void 0,async connect(s,c,d,a){const m=await e.makeConnection();return S.connect(m,c,d,a)},register(){throw new Error("not implemented")}},addressProvider:{getAddress(){return Promise.resolve({connectTo:new L(0),connectionToken:e.connectionToken})}},signService:this.signService},"localhost",o.remoteAddress.host||"localhost",o.remoteAddress.port,o.localAddressPort);await t.waitForReady();const r=new v;return{localAddress:W(t.localAddress)??t.localAddress,remoteAddress:{port:t.tunnelRemotePort,host:t.tunnelRemoteHost},onDidDispose:r.event,dispose:()=>{t.dispose(),r.fire(),r.dispose()}}}}};P=k([f(0,O),f(1,J),f(2,$),f(3,V)],P);class S extends N{constructor(e,o,t){super(o,t);this.passing=e}static connect(e,o,t,r){const s=new F,c={onClose:s.add(new v),onData:s.add(new v),onEnd:s.add(new v)};s.add(e.onDidReceiveMessage(a=>c.onData.fire(I.wrap(a)))),s.add(e.onDidEnd(()=>c.onEnd.fire())),s.add(e.onDidClose(a=>c.onClose.fire({type:H.NodeSocketCloseEvent,error:a,hadError:!!a})));const d=new S(e,r,c);return d._register(s),j(d,o,t,r,c)}write(e){this.passing.send(e.buffer)}closeRemote(){this.passing.end()}async drain(){await this.passing.drain?.()}}export{P as NodeExtHostTunnelService,ee as findPorts,Y as getRootProcesses,X as getSockets,K as loadConnectionTable,Z as loadListeningPorts,G as parseIpAddress,te as tryFindRootPorts};
