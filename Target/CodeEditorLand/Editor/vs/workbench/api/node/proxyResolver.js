import*as T from"http";import*as b from"https";import*as E from"net";import*as R from"tls";import{createHttpPatch as k,createNetPatch as w,createProxyResolver as M,createTlsPatch as S,loadSystemCertificates as D,LogLevel as y}from"@vscode/proxy-agent";import{URI as B}from"../../../../vs/base/common/uri.js";import"../../../../vs/platform/extensions/common/extensions.js";import{LogLevel as g}from"../../../../vs/platform/log/common/log.js";import"../../../../vs/platform/request/common/request.js";import"../../../../vs/workbench/api/common/extHost.protocol.js";import"../../../../vs/workbench/api/common/extHostConfiguration.js";import"../../../../vs/workbench/api/common/extHostWorkspace.js";import"../../../../vs/workbench/api/node/extHostExtensionService.js";import"../../../../vs/workbench/services/extensions/common/extensionHostProtocol.js";const I=!1;function ce(o,e,c,r,p,u){const a=u.environment.useHostProxy,h=typeof a=="boolean"?a:!u.remote.isRemote,t={resolveProxy:s=>o.resolveProxy(s),lookupProxyAuthorization:_.bind(void 0,o,r,p,e,{},{},u.remote.isRemote,h),getProxyURL:()=>e.getConfiguration("http").get("proxy"),getProxySupport:()=>e.getConfiguration("http").get("proxySupport")||"off",getNoProxyConfig:()=>e.getConfiguration("http").get("noProxy")||[],addCertificatesV1:()=>V(e),addCertificatesV2:()=>K(e),log:r,getLogLevel:()=>{const s=r.getLevel();switch(s){case g.Trace:return y.Trace;case g.Debug:return y.Debug;case g.Info:return y.Info;case g.Warning:return y.Warning;case g.Error:return y.Error;case g.Off:return y.Off;default:return f(s)}function f(d){return r.error("Unknown log level",d),y.Debug}},proxyResolveTelemetry:()=>{},useHostProxy:h,loadAdditionalCertificates:async()=>{const s=[];if(u.remote.isRemote&&s.push(D({log:r})),h){r.trace("ProxyResolver#loadAdditionalCertificates: Loading certificates from main process");const f=o.loadCertificates();f.then(d=>r.trace("ProxyResolver#loadAdditionalCertificates: Loaded certificates from main process",d.length)),s.push(f)}return u.environment.extensionTestsLocationURI&&b.globalAgent.testCertificates?.length&&(r.trace("ProxyResolver#loadAdditionalCertificates: Loading test certificates"),s.push(Promise.resolve(b.globalAgent.testCertificates))),(await Promise.all(s)).flat()},env:process.env},l=M(t),n=N(t,l);return O(c,n)}function N(o,e){function c(r,p){return Object.assign(r.default||r,p)}return{http:c(T,k(o,T,e)),https:c(b,k(o,b,e)),net:c(E,w(o,E)),tls:c(R,S(o,R))}}function V(o){const e=o.getConfiguration("http");return!e.get("experimental.systemCertificatesV2",I)&&!!e.get("systemCertificates")}function K(o){const e=o.getConfiguration("http");return!!e.get("experimental.systemCertificatesV2",I)&&!!e.get("systemCertificates")}const $=new Map;function O(o,e){return o.getExtensionPathIndex().then(c=>{const r=globalThis._VSCODE_NODE_MODULES.module,p=r._load;r._load=function(a,h,t){if(a==="net")return e.net;if(a==="tls")return e.tls;if(a!=="http"&&a!=="https")return p.apply(this,arguments);const l=c.findSubstr(B.file(h.filename));let n=$.get(l);if(n||$.set(l,n={}),!n[a]){const s=e[a];n[a]={...s}}return n[a]}})}async function _(o,e,c,r,p,u,a,h,t,l,n){const s=p[t];l&&(p[t]=l),e.trace("ProxyResolver#lookupProxyAuthorization callback",`proxyURL:${t}`,`proxyAuthenticate:${l}`,`proxyAuthenticateCache:${s}`);const f=l||s,d=Array.isArray(f)?f:typeof f=="string"?[f]:[];if(H(c,d,a),d.some(i=>/^(Negotiate|Kerberos)( |$)/i.test(i))&&!n.kerberosRequested){n.kerberosRequested=!0;try{const i=await import("kerberos"),m=new URL(t),P=r.getConfiguration("http").get("proxyKerberosServicePrincipal")||(process.platform==="win32"?`HTTP/${m.hostname}`:`HTTP@${m.hostname}`);return e.debug("ProxyResolver#lookupProxyAuthorization Kerberos authentication lookup",`proxyURL:${t}`,`spn:${P}`),"Negotiate "+await(await i.initializeClient(P)).step("")}catch(i){e.debug("ProxyResolver#lookupProxyAuthorization Kerberos authentication failed",i)}if(a&&h){e.debug("ProxyResolver#lookupProxyAuthorization Kerberos authentication lookup on host",`proxyURL:${t}`);const i=await o.lookupKerberosAuthorization(t);if(i)return"Negotiate "+i}}const A=d.find(i=>/^Basic( |$)/i.test(i));if(A)try{const i=u[t];if(i)if(n.basicAuthCacheUsed)e.debug("ProxyResolver#lookupProxyAuthorization Basic authentication deleting cached credentials",`proxyURL:${t}`),delete u[t];else return e.debug("ProxyResolver#lookupProxyAuthorization Basic authentication using cached credentials",`proxyURL:${t}`),n.basicAuthCacheUsed=!0,i;n.basicAuthAttempt=(n.basicAuthAttempt||0)+1;const m=/ realm="([^"]+)"/i.exec(A)?.[1];e.debug("ProxyResolver#lookupProxyAuthorization Basic authentication lookup",`proxyURL:${t}`,`realm:${m}`);const P=new URL(t),v={scheme:"basic",host:P.hostname,port:Number(P.port),realm:m||"",isProxy:!0,attempt:n.basicAuthAttempt},x=await o.lookupAuthorization(v);if(x){e.debug("ProxyResolver#lookupProxyAuthorization Basic authentication received credentials",`proxyURL:${t}`,`realm:${m}`);const C="Basic "+Buffer.from(`${x.username}:${x.password}`).toString("base64");return u[t]=C,C}else e.debug("ProxyResolver#lookupProxyAuthorization Basic authentication received no credentials",`proxyURL:${t}`,`realm:${m}`)}catch(i){e.error("ProxyResolver#lookupProxyAuthorization Basic authentication failed",i)}}let z=!1;function H(o,e,c){z||!e.length||(z=!0,o.$publicLog2("proxyAuthenticationRequest",{authenticationType:e.map(r=>r.split(" ")[0]).join(","),extensionHostType:c?"remote":"local"}))}export{ce as connectProxyResolver};
