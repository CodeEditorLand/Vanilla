{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/api/node/extensionHostProcess.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport minimist from 'minimist';\nimport * as nativeWatchdog from 'native-watchdog';\nimport * as net from 'net';\nimport { ProcessTimeRunOnceScheduler } from '../../../base/common/async.js';\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport { isCancellationError, isSigPipeError, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Event } from '../../../base/common/event.js';\nimport * as performance from '../../../base/common/performance.js';\nimport { IURITransformer } from '../../../base/common/uriIpc.js';\nimport { realpath } from '../../../base/node/extpath.js';\nimport { Promises } from '../../../base/node/pfs.js';\nimport { IMessagePassingProtocol } from '../../../base/parts/ipc/common/ipc.js';\nimport { BufferedEmitter, PersistentProtocol, ProtocolConstants } from '../../../base/parts/ipc/common/ipc.net.js';\nimport { NodeSocket, WebSocketNodeSocket } from '../../../base/parts/ipc/node/ipc.net.js';\nimport type { MessagePortMain } from '../../../base/parts/sandbox/node/electronTypes.js';\nimport { boolean } from '../../../editor/common/config/editorOptions.js';\nimport product from '../../../platform/product/common/product.js';\nimport { ExtensionHostMain, IExitFn } from '../common/extensionHostMain.js';\nimport { IHostUtils } from '../common/extHostExtensionService.js';\nimport { createURITransformer } from './uriTransformer.js';\nimport { ExtHostConnectionType, readExtHostConnection } from '../../services/extensions/common/extensionHostEnv.js';\nimport { ExtensionHostExitCode, IExtHostReadyMessage, IExtHostReduceGraceTimeMessage, IExtHostSocketMessage, IExtensionHostInitData, MessageType, createMessageOfType, isMessageOfType } from '../../services/extensions/common/extensionHostProtocol.js';\nimport { IDisposable } from '../../../base/common/lifecycle.js';\nimport '../common/extHost.common.services.js';\nimport './extHost.node.services.js';\n// ESM-uncomment-begin\nimport { createRequire } from 'node:module';\nconst require = createRequire(import.meta.url);\n// ESM-uncomment-end\n\ninterface ParsedExtHostArgs {\n\ttransformURIs?: boolean;\n\tskipWorkspaceStorageLock?: boolean;\n\tuseHostProxy?: 'true' | 'false'; // use a string, as undefined is also a valid value\n}\n\n// workaround for https://github.com/microsoft/vscode/issues/85490\n// remove --inspect-port=0 after start so that it doesn't trigger LSP debugging\n(function removeInspectPort() {\n\tfor (let i = 0; i < process.execArgv.length; i++) {\n\t\tif (process.execArgv[i] === '--inspect-port=0') {\n\t\t\tprocess.execArgv.splice(i, 1);\n\t\t\ti--;\n\t\t}\n\t}\n})();\n\nconst args = minimist(process.argv.slice(2), {\n\tboolean: [\n\t\t'transformURIs',\n\t\t'skipWorkspaceStorageLock'\n\t],\n\tstring: [\n\t\t'useHostProxy' // 'true' | 'false' | undefined\n\t]\n}) as ParsedExtHostArgs;\n\n// With Electron 2.x and node.js 8.x the \"natives\" module\n// can cause a native crash (see https://github.com/nodejs/node/issues/19891 and\n// https://github.com/electron/electron/issues/10905). To prevent this from\n// happening we essentially blocklist this module from getting loaded in any\n// extension by patching the node require() function.\n(function () {\n\tconst Module = require('module');\n\tconst originalLoad = Module._load;\n\n\tModule._load = function (request: string) {\n\t\tif (request === 'natives') {\n\t\t\tthrow new Error('Either the extension or an NPM dependency is using the [unsupported \"natives\" node module](https://go.microsoft.com/fwlink/?linkid=871887).');\n\t\t}\n\n\t\treturn originalLoad.apply(this, arguments);\n\t};\n})();\n\n// custom process.exit logic...\nconst nativeExit: IExitFn = process.exit.bind(process);\nconst nativeOn = process.on.bind(process);\nfunction patchProcess(allowExit: boolean) {\n\tprocess.exit = function (code?: number) {\n\t\tif (allowExit) {\n\t\t\tnativeExit(code);\n\t\t} else {\n\t\t\tconst err = new Error('An extension called process.exit() and this was prevented.');\n\t\t\tconsole.warn(err.stack);\n\t\t}\n\t} as (code?: number) => never;\n\n\t// override Electron's process.crash() method\n\tprocess.crash = function () {\n\t\tconst err = new Error('An extension called process.crash() and this was prevented.');\n\t\tconsole.warn(err.stack);\n\t};\n\n\t// Set ELECTRON_RUN_AS_NODE environment variable for extensions that use\n\t// child_process.spawn with process.execPath and expect to run as node process\n\t// on the desktop.\n\t// Refs https://github.com/microsoft/vscode/issues/151012#issuecomment-1156593228\n\tprocess.env['ELECTRON_RUN_AS_NODE'] = '1';\n\n\tprocess.on = <any>function (event: string, listener: (...args: any[]) => void) {\n\t\tif (event === 'uncaughtException') {\n\t\t\tlistener = function () {\n\t\t\t\ttry {\n\t\t\t\t\treturn listener.call(undefined, arguments);\n\t\t\t\t} catch {\n\t\t\t\t\t// DO NOT HANDLE NOR PRINT the error here because this can and will lead to\n\t\t\t\t\t// more errors which will cause error handling to be reentrant and eventually\n\t\t\t\t\t// overflowing the stack. Do not be sad, we do handle and annotate uncaught\n\t\t\t\t\t// errors properly in 'extensionHostMain'\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\tnativeOn(event, listener);\n\t};\n\n}\n\ninterface IRendererConnection {\n\tprotocol: IMessagePassingProtocol;\n\tinitData: IExtensionHostInitData;\n}\n\n// This calls exit directly in case the initialization is not finished and we need to exit\n// Otherwise, if initialization completed we go to extensionHostMain.terminate()\nlet onTerminate = function (reason: string) {\n\tnativeExit();\n};\n\nfunction _createExtHostProtocol(): Promise<IMessagePassingProtocol> {\n\tconst extHostConnection = readExtHostConnection(process.env);\n\n\tif (extHostConnection.type === ExtHostConnectionType.MessagePort) {\n\n\t\treturn new Promise<IMessagePassingProtocol>((resolve, reject) => {\n\n\t\t\tconst withPorts = (ports: MessagePortMain[]) => {\n\t\t\t\tconst port = ports[0];\n\t\t\t\tconst onMessage = new BufferedEmitter<VSBuffer>();\n\t\t\t\tport.on('message', (e) => onMessage.fire(VSBuffer.wrap(e.data)));\n\t\t\t\tport.on('close', () => {\n\t\t\t\t\tonTerminate('renderer closed the MessagePort');\n\t\t\t\t});\n\t\t\t\tport.start();\n\n\t\t\t\tresolve({\n\t\t\t\t\tonMessage: onMessage.event,\n\t\t\t\t\tsend: message => port.postMessage(message.buffer)\n\t\t\t\t});\n\t\t\t};\n\n\t\t\tprocess.parentPort.on('message', (e: Electron.MessageEvent) => withPorts(e.ports));\n\t\t});\n\n\t} else if (extHostConnection.type === ExtHostConnectionType.Socket) {\n\n\t\treturn new Promise<PersistentProtocol>((resolve, reject) => {\n\n\t\t\tlet protocol: PersistentProtocol | null = null;\n\n\t\t\tconst timer = setTimeout(() => {\n\t\t\t\tonTerminate('VSCODE_EXTHOST_IPC_SOCKET timeout');\n\t\t\t}, 60000);\n\n\t\t\tconst reconnectionGraceTime = ProtocolConstants.ReconnectionGraceTime;\n\t\t\tconst reconnectionShortGraceTime = ProtocolConstants.ReconnectionShortGraceTime;\n\t\t\tconst disconnectRunner1 = new ProcessTimeRunOnceScheduler(() => onTerminate('renderer disconnected for too long (1)'), reconnectionGraceTime);\n\t\t\tconst disconnectRunner2 = new ProcessTimeRunOnceScheduler(() => onTerminate('renderer disconnected for too long (2)'), reconnectionShortGraceTime);\n\n\t\t\tprocess.on('message', (msg: IExtHostSocketMessage | IExtHostReduceGraceTimeMessage, handle: net.Socket) => {\n\t\t\t\tif (msg && msg.type === 'VSCODE_EXTHOST_IPC_SOCKET') {\n\t\t\t\t\t// Disable Nagle's algorithm. We also do this on the server process,\n\t\t\t\t\t// but nodejs doesn't document if this option is transferred with the socket\n\t\t\t\t\thandle.setNoDelay(true);\n\n\t\t\t\t\tconst initialDataChunk = VSBuffer.wrap(Buffer.from(msg.initialDataChunk, 'base64'));\n\t\t\t\t\tlet socket: NodeSocket | WebSocketNodeSocket;\n\t\t\t\t\tif (msg.skipWebSocketFrames) {\n\t\t\t\t\t\tsocket = new NodeSocket(handle, 'extHost-socket');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst inflateBytes = VSBuffer.wrap(Buffer.from(msg.inflateBytes, 'base64'));\n\t\t\t\t\t\tsocket = new WebSocketNodeSocket(new NodeSocket(handle, 'extHost-socket'), msg.permessageDeflate, inflateBytes, false);\n\t\t\t\t\t}\n\t\t\t\t\tif (protocol) {\n\t\t\t\t\t\t// reconnection case\n\t\t\t\t\t\tdisconnectRunner1.cancel();\n\t\t\t\t\t\tdisconnectRunner2.cancel();\n\t\t\t\t\t\tprotocol.beginAcceptReconnection(socket, initialDataChunk);\n\t\t\t\t\t\tprotocol.endAcceptReconnection();\n\t\t\t\t\t\tprotocol.sendResume();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclearTimeout(timer);\n\t\t\t\t\t\tprotocol = new PersistentProtocol({ socket, initialChunk: initialDataChunk });\n\t\t\t\t\t\tprotocol.sendResume();\n\t\t\t\t\t\tprotocol.onDidDispose(() => onTerminate('renderer disconnected'));\n\t\t\t\t\t\tresolve(protocol);\n\n\t\t\t\t\t\t// Wait for rich client to reconnect\n\t\t\t\t\t\tprotocol.onSocketClose(() => {\n\t\t\t\t\t\t\t// The socket has closed, let's give the renderer a certain amount of time to reconnect\n\t\t\t\t\t\t\tdisconnectRunner1.schedule();\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (msg && msg.type === 'VSCODE_EXTHOST_IPC_REDUCE_GRACE_TIME') {\n\t\t\t\t\tif (disconnectRunner2.isScheduled()) {\n\t\t\t\t\t\t// we are disconnected and already running the short reconnection timer\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (disconnectRunner1.isScheduled()) {\n\t\t\t\t\t\t// we are disconnected and running the long reconnection timer\n\t\t\t\t\t\tdisconnectRunner2.schedule();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Now that we have managed to install a message listener, ask the other side to send us the socket\n\t\t\tconst req: IExtHostReadyMessage = { type: 'VSCODE_EXTHOST_IPC_READY' };\n\t\t\tprocess.send?.(req);\n\t\t});\n\n\t} else {\n\n\t\tconst pipeName = extHostConnection.pipeName;\n\n\t\treturn new Promise<PersistentProtocol>((resolve, reject) => {\n\n\t\t\tconst socket = net.createConnection(pipeName, () => {\n\t\t\t\tsocket.removeListener('error', reject);\n\t\t\t\tconst protocol = new PersistentProtocol({ socket: new NodeSocket(socket, 'extHost-renderer') });\n\t\t\t\tprotocol.sendResume();\n\t\t\t\tresolve(protocol);\n\t\t\t});\n\t\t\tsocket.once('error', reject);\n\n\t\t\tsocket.on('close', () => {\n\t\t\t\tonTerminate('renderer closed the socket');\n\t\t\t});\n\t\t});\n\t}\n}\n\nasync function createExtHostProtocol(): Promise<IMessagePassingProtocol> {\n\n\tconst protocol = await _createExtHostProtocol();\n\n\treturn new class implements IMessagePassingProtocol {\n\n\t\tprivate readonly _onMessage = new BufferedEmitter<VSBuffer>();\n\t\treadonly onMessage: Event<VSBuffer> = this._onMessage.event;\n\n\t\tprivate _terminating: boolean;\n\t\tprivate _protocolListener: IDisposable;\n\n\t\tconstructor() {\n\t\t\tthis._terminating = false;\n\t\t\tthis._protocolListener = protocol.onMessage((msg) => {\n\t\t\t\tif (isMessageOfType(msg, MessageType.Terminate)) {\n\t\t\t\t\tthis._terminating = true;\n\t\t\t\t\tthis._protocolListener.dispose();\n\t\t\t\t\tonTerminate('received terminate message from renderer');\n\t\t\t\t} else {\n\t\t\t\t\tthis._onMessage.fire(msg);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tsend(msg: any): void {\n\t\t\tif (!this._terminating) {\n\t\t\t\tprotocol.send(msg);\n\t\t\t}\n\t\t}\n\n\t\tasync drain(): Promise<void> {\n\t\t\tif (protocol.drain) {\n\t\t\t\treturn protocol.drain();\n\t\t\t}\n\t\t}\n\t};\n}\n\nfunction connectToRenderer(protocol: IMessagePassingProtocol): Promise<IRendererConnection> {\n\treturn new Promise<IRendererConnection>((c) => {\n\n\t\t// Listen init data message\n\t\tconst first = protocol.onMessage(raw => {\n\t\t\tfirst.dispose();\n\n\t\t\tconst initData = <IExtensionHostInitData>JSON.parse(raw.toString());\n\n\t\t\tconst rendererCommit = initData.commit;\n\t\t\tconst myCommit = product.commit;\n\n\t\t\tif (rendererCommit && myCommit) {\n\t\t\t\t// Running in the built version where commits are defined\n\t\t\t\tif (rendererCommit !== myCommit) {\n\t\t\t\t\tnativeExit(ExtensionHostExitCode.VersionMismatch);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (initData.parentPid) {\n\t\t\t\t// Kill oneself if one's parent dies. Much drama.\n\t\t\t\tlet epermErrors = 0;\n\t\t\t\tsetInterval(function () {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tprocess.kill(initData.parentPid, 0); // throws an exception if the main process doesn't exist anymore.\n\t\t\t\t\t\tepermErrors = 0;\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif (e && e.code === 'EPERM') {\n\t\t\t\t\t\t\t// Even if the parent process is still alive,\n\t\t\t\t\t\t\t// some antivirus software can lead to an EPERM error to be thrown here.\n\t\t\t\t\t\t\t// Let's terminate only if we get 3 consecutive EPERM errors.\n\t\t\t\t\t\t\tepermErrors++;\n\t\t\t\t\t\t\tif (epermErrors >= 3) {\n\t\t\t\t\t\t\t\tonTerminate(`parent process ${initData.parentPid} does not exist anymore (3 x EPERM): ${e.message} (code: ${e.code}) (errno: ${e.errno})`);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tonTerminate(`parent process ${initData.parentPid} does not exist anymore: ${e.message} (code: ${e.code}) (errno: ${e.errno})`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, 1000);\n\n\t\t\t\t// In certain cases, the event loop can become busy and never yield\n\t\t\t\t// e.g. while-true or process.nextTick endless loops\n\t\t\t\t// So also use the native node module to do it from a separate thread\n\t\t\t\tlet watchdog: typeof nativeWatchdog;\n\t\t\t\ttry {\n\t\t\t\t\twatchdog = require('native-watchdog');\n\t\t\t\t\twatchdog.start(initData.parentPid);\n\t\t\t\t} catch (err) {\n\t\t\t\t\t// no problem...\n\t\t\t\t\tonUnexpectedError(err);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Tell the outside that we are initialized\n\t\t\tprotocol.send(createMessageOfType(MessageType.Initialized));\n\n\t\t\tc({ protocol, initData });\n\t\t});\n\n\t\t// Tell the outside that we are ready to receive messages\n\t\tprotocol.send(createMessageOfType(MessageType.Ready));\n\t});\n}\n\nasync function startExtensionHostProcess(): Promise<void> {\n\n\t// Print a console message when rejection isn't handled within N seconds. For details:\n\t// see https://nodejs.org/api/process.html#process_event_unhandledrejection\n\t// and https://nodejs.org/api/process.html#process_event_rejectionhandled\n\tconst unhandledPromises: Promise<any>[] = [];\n\tprocess.on('unhandledRejection', (reason: any, promise: Promise<any>) => {\n\t\tunhandledPromises.push(promise);\n\t\tsetTimeout(() => {\n\t\t\tconst idx = unhandledPromises.indexOf(promise);\n\t\t\tif (idx >= 0) {\n\t\t\t\tpromise.catch(e => {\n\t\t\t\t\tunhandledPromises.splice(idx, 1);\n\t\t\t\t\tif (!isCancellationError(e)) {\n\t\t\t\t\t\tconsole.warn(`rejected promise not handled within 1 second: ${e}`);\n\t\t\t\t\t\tif (e && e.stack) {\n\t\t\t\t\t\t\tconsole.warn(`stack trace: ${e.stack}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (reason) {\n\t\t\t\t\t\t\tonUnexpectedError(reason);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}, 1000);\n\t});\n\n\tprocess.on('rejectionHandled', (promise: Promise<any>) => {\n\t\tconst idx = unhandledPromises.indexOf(promise);\n\t\tif (idx >= 0) {\n\t\t\tunhandledPromises.splice(idx, 1);\n\t\t}\n\t});\n\n\t// Print a console message when an exception isn't handled.\n\tprocess.on('uncaughtException', function (err: Error) {\n\t\tif (!isSigPipeError(err)) {\n\t\t\tonUnexpectedError(err);\n\t\t}\n\t});\n\n\tperformance.mark(`code/extHost/willConnectToRenderer`);\n\tconst protocol = await createExtHostProtocol();\n\tperformance.mark(`code/extHost/didConnectToRenderer`);\n\tconst renderer = await connectToRenderer(protocol);\n\tperformance.mark(`code/extHost/didWaitForInitData`);\n\tconst { initData } = renderer;\n\t// setup things\n\tpatchProcess(!!initData.environment.extensionTestsLocationURI); // to support other test frameworks like Jasmin that use process.exit (https://github.com/microsoft/vscode/issues/37708)\n\tinitData.environment.useHostProxy = args.useHostProxy !== undefined ? args.useHostProxy !== 'false' : undefined;\n\tinitData.environment.skipWorkspaceStorageLock = boolean(args.skipWorkspaceStorageLock, false);\n\n\t// host abstraction\n\tconst hostUtils = new class NodeHost implements IHostUtils {\n\t\tdeclare readonly _serviceBrand: undefined;\n\t\tpublic readonly pid = process.pid;\n\t\texit(code: number) { nativeExit(code); }\n\t\tfsExists(path: string) { return Promises.exists(path); }\n\t\tfsRealpath(path: string) { return realpath(path); }\n\t};\n\n\t// Attempt to load uri transformer\n\tlet uriTransformer: IURITransformer | null = null;\n\tif (initData.remote.authority && args.transformURIs) {\n\t\turiTransformer = createURITransformer(initData.remote.authority);\n\t}\n\n\tconst extensionHostMain = new ExtensionHostMain(\n\t\trenderer.protocol,\n\t\tinitData,\n\t\thostUtils,\n\t\turiTransformer\n\t);\n\n\t// rewrite onTerminate-function to be a proper shutdown\n\tonTerminate = (reason: string) => extensionHostMain.terminate(reason);\n}\n\nstartExtensionHostProcess().catch((err) => console.log(err));\n"],
  "mappings": "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",
  "names": ["require"]
}
