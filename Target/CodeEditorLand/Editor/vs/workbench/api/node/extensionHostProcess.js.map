{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/api/node/extensionHostProcess.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as net from \"net\";\nimport minimist from \"minimist\";\nimport type * as nativeWatchdog from \"native-watchdog\";\nimport { ProcessTimeRunOnceScheduler } from \"../../../base/common/async.js\";\nimport { VSBuffer } from \"../../../base/common/buffer.js\";\nimport {\n\tisCancellationError,\n\tisSigPipeError,\n\tonUnexpectedError,\n} from \"../../../base/common/errors.js\";\nimport type { Event } from \"../../../base/common/event.js\";\nimport type { IDisposable } from \"../../../base/common/lifecycle.js\";\nimport * as performance from \"../../../base/common/performance.js\";\nimport type { IURITransformer } from \"../../../base/common/uriIpc.js\";\nimport { realpath } from \"../../../base/node/extpath.js\";\nimport { Promises } from \"../../../base/node/pfs.js\";\nimport type { IMessagePassingProtocol } from \"../../../base/parts/ipc/common/ipc.js\";\nimport {\n\tBufferedEmitter,\n\tPersistentProtocol,\n\tProtocolConstants,\n} from \"../../../base/parts/ipc/common/ipc.net.js\";\nimport {\n\tNodeSocket,\n\tWebSocketNodeSocket,\n} from \"../../../base/parts/ipc/node/ipc.net.js\";\nimport type { MessagePortMain } from \"../../../base/parts/sandbox/node/electronTypes.js\";\nimport { boolean } from \"../../../editor/common/config/editorOptions.js\";\nimport product from \"../../../platform/product/common/product.js\";\nimport {\n\tExtHostConnectionType,\n\treadExtHostConnection,\n} from \"../../services/extensions/common/extensionHostEnv.js\";\nimport {\n\tExtensionHostExitCode,\n\ttype IExtHostReadyMessage,\n\ttype IExtHostReduceGraceTimeMessage,\n\ttype IExtHostSocketMessage,\n\ttype IExtensionHostInitData,\n\tMessageType,\n\tcreateMessageOfType,\n\tisMessageOfType,\n} from \"../../services/extensions/common/extensionHostProtocol.js\";\nimport type { IHostUtils } from \"../common/extHostExtensionService.js\";\nimport {\n\tExtensionHostMain,\n\ttype IExitFn,\n} from \"../common/extensionHostMain.js\";\nimport { createURITransformer } from \"./uriTransformer.js\";\nimport \"../common/extHost.common.services.js\";\nimport \"./extHost.node.services.js\";\n// ESM-uncomment-begin\nimport { createRequire } from \"node:module\";\nconst require = createRequire(import.meta.url);\n// ESM-uncomment-end\n\ninterface ParsedExtHostArgs {\n\ttransformURIs?: boolean;\n\tskipWorkspaceStorageLock?: boolean;\n\tuseHostProxy?: \"true\" | \"false\"; // use a string, as undefined is also a valid value\n}\n\n// workaround for https://github.com/microsoft/vscode/issues/85490\n// remove --inspect-port=0 after start so that it doesn't trigger LSP debugging\n(function removeInspectPort() {\n\tfor (let i = 0; i < process.execArgv.length; i++) {\n\t\tif (process.execArgv[i] === \"--inspect-port=0\") {\n\t\t\tprocess.execArgv.splice(i, 1);\n\t\t\ti--;\n\t\t}\n\t}\n})();\n\nconst args = minimist(process.argv.slice(2), {\n\tboolean: [\"transformURIs\", \"skipWorkspaceStorageLock\"],\n\tstring: [\n\t\t\"useHostProxy\", // 'true' | 'false' | undefined\n\t],\n}) as ParsedExtHostArgs;\n\n// With Electron 2.x and node.js 8.x the \"natives\" module\n// can cause a native crash (see https://github.com/nodejs/node/issues/19891 and\n// https://github.com/electron/electron/issues/10905). To prevent this from\n// happening we essentially blocklist this module from getting loaded in any\n// extension by patching the node require() function.\n(() => {\n\tconst Module = require(\"module\");\n\tconst originalLoad = Module._load;\n\n\tModule._load = function (request: string) {\n\t\tif (request === \"natives\") {\n\t\t\tthrow new Error(\n\t\t\t\t'Either the extension or an NPM dependency is using the [unsupported \"natives\" node module](https://go.microsoft.com/fwlink/?linkid=871887).',\n\t\t\t);\n\t\t}\n\n\t\treturn originalLoad.apply(this, arguments);\n\t};\n})();\n\n// custom process.exit logic...\nconst nativeExit: IExitFn = process.exit.bind(process);\nconst nativeOn = process.on.bind(process);\nfunction patchProcess(allowExit: boolean) {\n\tprocess.exit = ((code?: number) => {\n\t\tif (allowExit) {\n\t\t\tnativeExit(code);\n\t\t} else {\n\t\t\tconst err = new Error(\n\t\t\t\t\"An extension called process.exit() and this was prevented.\",\n\t\t\t);\n\t\t\tconsole.warn(err.stack);\n\t\t}\n\t}) as (code?: number) => never;\n\n\t// override Electron's process.crash() method\n\tprocess.crash = () => {\n\t\tconst err = new Error(\n\t\t\t\"An extension called process.crash() and this was prevented.\",\n\t\t);\n\t\tconsole.warn(err.stack);\n\t};\n\n\t// Set ELECTRON_RUN_AS_NODE environment variable for extensions that use\n\t// child_process.spawn with process.execPath and expect to run as node process\n\t// on the desktop.\n\t// Refs https://github.com/microsoft/vscode/issues/151012#issuecomment-1156593228\n\tprocess.env[\"ELECTRON_RUN_AS_NODE\"] = \"1\";\n\n\tprocess.on = <any>((event: string, listener: (...args: any[]) => void) => {\n\t\tif (event === \"uncaughtException\") {\n\t\t\tlistener = () => {\n\t\t\t\ttry {\n\t\t\t\t\treturn listener.call(undefined, arguments);\n\t\t\t\t} catch {\n\t\t\t\t\t// DO NOT HANDLE NOR PRINT the error here because this can and will lead to\n\t\t\t\t\t// more errors which will cause error handling to be reentrant and eventually\n\t\t\t\t\t// overflowing the stack. Do not be sad, we do handle and annotate uncaught\n\t\t\t\t\t// errors properly in 'extensionHostMain'\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\tnativeOn(event, listener);\n\t});\n}\n\ninterface IRendererConnection {\n\tprotocol: IMessagePassingProtocol;\n\tinitData: IExtensionHostInitData;\n}\n\n// This calls exit directly in case the initialization is not finished and we need to exit\n// Otherwise, if initialization completed we go to extensionHostMain.terminate()\nlet onTerminate = (reason: string) => {\n\tnativeExit();\n};\n\nfunction _createExtHostProtocol(): Promise<IMessagePassingProtocol> {\n\tconst extHostConnection = readExtHostConnection(process.env);\n\n\tif (extHostConnection.type === ExtHostConnectionType.MessagePort) {\n\t\treturn new Promise<IMessagePassingProtocol>((resolve, reject) => {\n\t\t\tconst withPorts = (ports: MessagePortMain[]) => {\n\t\t\t\tconst port = ports[0];\n\t\t\t\tconst onMessage = new BufferedEmitter<VSBuffer>();\n\t\t\t\tport.on(\"message\", (e) =>\n\t\t\t\t\tonMessage.fire(VSBuffer.wrap(e.data)),\n\t\t\t\t);\n\t\t\t\tport.on(\"close\", () => {\n\t\t\t\t\tonTerminate(\"renderer closed the MessagePort\");\n\t\t\t\t});\n\t\t\t\tport.start();\n\n\t\t\t\tresolve({\n\t\t\t\t\tonMessage: onMessage.event,\n\t\t\t\t\tsend: (message) => port.postMessage(message.buffer),\n\t\t\t\t});\n\t\t\t};\n\n\t\t\tprocess.parentPort.on(\"message\", (e: Electron.MessageEvent) =>\n\t\t\t\twithPorts(e.ports),\n\t\t\t);\n\t\t});\n\t} else if (extHostConnection.type === ExtHostConnectionType.Socket) {\n\t\treturn new Promise<PersistentProtocol>((resolve, reject) => {\n\t\t\tlet protocol: PersistentProtocol | null = null;\n\n\t\t\tconst timer = setTimeout(() => {\n\t\t\t\tonTerminate(\"VSCODE_EXTHOST_IPC_SOCKET timeout\");\n\t\t\t}, 60000);\n\n\t\t\tconst reconnectionGraceTime =\n\t\t\t\tProtocolConstants.ReconnectionGraceTime;\n\t\t\tconst reconnectionShortGraceTime =\n\t\t\t\tProtocolConstants.ReconnectionShortGraceTime;\n\t\t\tconst disconnectRunner1 = new ProcessTimeRunOnceScheduler(\n\t\t\t\t() => onTerminate(\"renderer disconnected for too long (1)\"),\n\t\t\t\treconnectionGraceTime,\n\t\t\t);\n\t\t\tconst disconnectRunner2 = new ProcessTimeRunOnceScheduler(\n\t\t\t\t() => onTerminate(\"renderer disconnected for too long (2)\"),\n\t\t\t\treconnectionShortGraceTime,\n\t\t\t);\n\n\t\t\tprocess.on(\n\t\t\t\t\"message\",\n\t\t\t\t(\n\t\t\t\t\tmsg: IExtHostSocketMessage | IExtHostReduceGraceTimeMessage,\n\t\t\t\t\thandle: net.Socket,\n\t\t\t\t) => {\n\t\t\t\t\tif (msg && msg.type === \"VSCODE_EXTHOST_IPC_SOCKET\") {\n\t\t\t\t\t\t// Disable Nagle's algorithm. We also do this on the server process,\n\t\t\t\t\t\t// but nodejs doesn't document if this option is transferred with the socket\n\t\t\t\t\t\thandle.setNoDelay(true);\n\n\t\t\t\t\t\tconst initialDataChunk = VSBuffer.wrap(\n\t\t\t\t\t\t\tBuffer.from(msg.initialDataChunk, \"base64\"),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tlet socket: NodeSocket | WebSocketNodeSocket;\n\t\t\t\t\t\tif (msg.skipWebSocketFrames) {\n\t\t\t\t\t\t\tsocket = new NodeSocket(handle, \"extHost-socket\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst inflateBytes = VSBuffer.wrap(\n\t\t\t\t\t\t\t\tBuffer.from(msg.inflateBytes, \"base64\"),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tsocket = new WebSocketNodeSocket(\n\t\t\t\t\t\t\t\tnew NodeSocket(handle, \"extHost-socket\"),\n\t\t\t\t\t\t\t\tmsg.permessageDeflate,\n\t\t\t\t\t\t\t\tinflateBytes,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (protocol) {\n\t\t\t\t\t\t\t// reconnection case\n\t\t\t\t\t\t\tdisconnectRunner1.cancel();\n\t\t\t\t\t\t\tdisconnectRunner2.cancel();\n\t\t\t\t\t\t\tprotocol.beginAcceptReconnection(\n\t\t\t\t\t\t\t\tsocket,\n\t\t\t\t\t\t\t\tinitialDataChunk,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tprotocol.endAcceptReconnection();\n\t\t\t\t\t\t\tprotocol.sendResume();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclearTimeout(timer);\n\t\t\t\t\t\t\tprotocol = new PersistentProtocol({\n\t\t\t\t\t\t\t\tsocket,\n\t\t\t\t\t\t\t\tinitialChunk: initialDataChunk,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tprotocol.sendResume();\n\t\t\t\t\t\t\tprotocol.onDidDispose(() =>\n\t\t\t\t\t\t\t\tonTerminate(\"renderer disconnected\"),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tresolve(protocol);\n\n\t\t\t\t\t\t\t// Wait for rich client to reconnect\n\t\t\t\t\t\t\tprotocol.onSocketClose(() => {\n\t\t\t\t\t\t\t\t// The socket has closed, let's give the renderer a certain amount of time to reconnect\n\t\t\t\t\t\t\t\tdisconnectRunner1.schedule();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\tmsg &&\n\t\t\t\t\t\tmsg.type === \"VSCODE_EXTHOST_IPC_REDUCE_GRACE_TIME\"\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (disconnectRunner2.isScheduled()) {\n\t\t\t\t\t\t\t// we are disconnected and already running the short reconnection timer\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (disconnectRunner1.isScheduled()) {\n\t\t\t\t\t\t\t// we are disconnected and running the long reconnection timer\n\t\t\t\t\t\t\tdisconnectRunner2.schedule();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t);\n\n\t\t\t// Now that we have managed to install a message listener, ask the other side to send us the socket\n\t\t\tconst req: IExtHostReadyMessage = {\n\t\t\t\ttype: \"VSCODE_EXTHOST_IPC_READY\",\n\t\t\t};\n\t\t\tprocess.send?.(req);\n\t\t});\n\t} else {\n\t\tconst pipeName = extHostConnection.pipeName;\n\n\t\treturn new Promise<PersistentProtocol>((resolve, reject) => {\n\t\t\tconst socket = net.createConnection(pipeName, () => {\n\t\t\t\tsocket.removeListener(\"error\", reject);\n\t\t\t\tconst protocol = new PersistentProtocol({\n\t\t\t\t\tsocket: new NodeSocket(socket, \"extHost-renderer\"),\n\t\t\t\t});\n\t\t\t\tprotocol.sendResume();\n\t\t\t\tresolve(protocol);\n\t\t\t});\n\t\t\tsocket.once(\"error\", reject);\n\n\t\t\tsocket.on(\"close\", () => {\n\t\t\t\tonTerminate(\"renderer closed the socket\");\n\t\t\t});\n\t\t});\n\t}\n}\n\nasync function createExtHostProtocol(): Promise<IMessagePassingProtocol> {\n\tconst protocol = await _createExtHostProtocol();\n\n\treturn new (class implements IMessagePassingProtocol {\n\t\tprivate readonly _onMessage = new BufferedEmitter<VSBuffer>();\n\t\treadonly onMessage: Event<VSBuffer> = this._onMessage.event;\n\n\t\tprivate _terminating: boolean;\n\t\tprivate _protocolListener: IDisposable;\n\n\t\tconstructor() {\n\t\t\tthis._terminating = false;\n\t\t\tthis._protocolListener = protocol.onMessage((msg) => {\n\t\t\t\tif (isMessageOfType(msg, MessageType.Terminate)) {\n\t\t\t\t\tthis._terminating = true;\n\t\t\t\t\tthis._protocolListener.dispose();\n\t\t\t\t\tonTerminate(\"received terminate message from renderer\");\n\t\t\t\t} else {\n\t\t\t\t\tthis._onMessage.fire(msg);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tsend(msg: any): void {\n\t\t\tif (!this._terminating) {\n\t\t\t\tprotocol.send(msg);\n\t\t\t}\n\t\t}\n\n\t\tasync drain(): Promise<void> {\n\t\t\tif (protocol.drain) {\n\t\t\t\treturn protocol.drain();\n\t\t\t}\n\t\t}\n\t})();\n}\n\nfunction connectToRenderer(\n\tprotocol: IMessagePassingProtocol,\n): Promise<IRendererConnection> {\n\treturn new Promise<IRendererConnection>((c) => {\n\t\t// Listen init data message\n\t\tconst first = protocol.onMessage((raw) => {\n\t\t\tfirst.dispose();\n\n\t\t\tconst initData = <IExtensionHostInitData>JSON.parse(raw.toString());\n\n\t\t\tconst rendererCommit = initData.commit;\n\t\t\tconst myCommit = product.commit;\n\n\t\t\tif (rendererCommit && myCommit) {\n\t\t\t\t// Running in the built version where commits are defined\n\t\t\t\tif (rendererCommit !== myCommit) {\n\t\t\t\t\tnativeExit(ExtensionHostExitCode.VersionMismatch);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (initData.parentPid) {\n\t\t\t\t// Kill oneself if one's parent dies. Much drama.\n\t\t\t\tlet epermErrors = 0;\n\t\t\t\tsetInterval(() => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tprocess.kill(initData.parentPid, 0); // throws an exception if the main process doesn't exist anymore.\n\t\t\t\t\t\tepermErrors = 0;\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif (e && e.code === \"EPERM\") {\n\t\t\t\t\t\t\t// Even if the parent process is still alive,\n\t\t\t\t\t\t\t// some antivirus software can lead to an EPERM error to be thrown here.\n\t\t\t\t\t\t\t// Let's terminate only if we get 3 consecutive EPERM errors.\n\t\t\t\t\t\t\tepermErrors++;\n\t\t\t\t\t\t\tif (epermErrors >= 3) {\n\t\t\t\t\t\t\t\tonTerminate(\n\t\t\t\t\t\t\t\t\t`parent process ${initData.parentPid} does not exist anymore (3 x EPERM): ${e.message} (code: ${e.code}) (errno: ${e.errno})`,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tonTerminate(\n\t\t\t\t\t\t\t\t`parent process ${initData.parentPid} does not exist anymore: ${e.message} (code: ${e.code}) (errno: ${e.errno})`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, 1000);\n\n\t\t\t\t// In certain cases, the event loop can become busy and never yield\n\t\t\t\t// e.g. while-true or process.nextTick endless loops\n\t\t\t\t// So also use the native node module to do it from a separate thread\n\t\t\t\tlet watchdog: typeof nativeWatchdog;\n\t\t\t\ttry {\n\t\t\t\t\twatchdog = require(\"native-watchdog\");\n\t\t\t\t\twatchdog.start(initData.parentPid);\n\t\t\t\t} catch (err) {\n\t\t\t\t\t// no problem...\n\t\t\t\t\tonUnexpectedError(err);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Tell the outside that we are initialized\n\t\t\tprotocol.send(createMessageOfType(MessageType.Initialized));\n\n\t\t\tc({ protocol, initData });\n\t\t});\n\n\t\t// Tell the outside that we are ready to receive messages\n\t\tprotocol.send(createMessageOfType(MessageType.Ready));\n\t});\n}\n\nasync function startExtensionHostProcess(): Promise<void> {\n\t// Print a console message when rejection isn't handled within N seconds. For details:\n\t// see https://nodejs.org/api/process.html#process_event_unhandledrejection\n\t// and https://nodejs.org/api/process.html#process_event_rejectionhandled\n\tconst unhandledPromises: Promise<any>[] = [];\n\tprocess.on(\"unhandledRejection\", (reason: any, promise: Promise<any>) => {\n\t\tunhandledPromises.push(promise);\n\t\tsetTimeout(() => {\n\t\t\tconst idx = unhandledPromises.indexOf(promise);\n\t\t\tif (idx >= 0) {\n\t\t\t\tpromise.catch((e) => {\n\t\t\t\t\tunhandledPromises.splice(idx, 1);\n\t\t\t\t\tif (!isCancellationError(e)) {\n\t\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t\t`rejected promise not handled within 1 second: ${e}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (e && e.stack) {\n\t\t\t\t\t\t\tconsole.warn(`stack trace: ${e.stack}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (reason) {\n\t\t\t\t\t\t\tonUnexpectedError(reason);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}, 1000);\n\t});\n\n\tprocess.on(\"rejectionHandled\", (promise: Promise<any>) => {\n\t\tconst idx = unhandledPromises.indexOf(promise);\n\t\tif (idx >= 0) {\n\t\t\tunhandledPromises.splice(idx, 1);\n\t\t}\n\t});\n\n\t// Print a console message when an exception isn't handled.\n\tprocess.on(\"uncaughtException\", (err: Error) => {\n\t\tif (!isSigPipeError(err)) {\n\t\t\tonUnexpectedError(err);\n\t\t}\n\t});\n\n\tperformance.mark(`code/extHost/willConnectToRenderer`);\n\tconst protocol = await createExtHostProtocol();\n\tperformance.mark(`code/extHost/didConnectToRenderer`);\n\tconst renderer = await connectToRenderer(protocol);\n\tperformance.mark(`code/extHost/didWaitForInitData`);\n\tconst { initData } = renderer;\n\t// setup things\n\tpatchProcess(!!initData.environment.extensionTestsLocationURI); // to support other test frameworks like Jasmin that use process.exit (https://github.com/microsoft/vscode/issues/37708)\n\tinitData.environment.useHostProxy =\n\t\targs.useHostProxy !== undefined\n\t\t\t? args.useHostProxy !== \"false\"\n\t\t\t: undefined;\n\tinitData.environment.skipWorkspaceStorageLock = boolean(\n\t\targs.skipWorkspaceStorageLock,\n\t\tfalse,\n\t);\n\n\t// host abstraction\n\tconst hostUtils = new (class NodeHost implements IHostUtils {\n\t\tdeclare readonly _serviceBrand: undefined;\n\t\tpublic readonly pid = process.pid;\n\t\texit(code: number) {\n\t\t\tnativeExit(code);\n\t\t}\n\t\tfsExists(path: string) {\n\t\t\treturn Promises.exists(path);\n\t\t}\n\t\tfsRealpath(path: string) {\n\t\t\treturn realpath(path);\n\t\t}\n\t})();\n\n\t// Attempt to load uri transformer\n\tlet uriTransformer: IURITransformer | null = null;\n\tif (initData.remote.authority && args.transformURIs) {\n\t\turiTransformer = createURITransformer(initData.remote.authority);\n\t}\n\n\tconst extensionHostMain = new ExtensionHostMain(\n\t\trenderer.protocol,\n\t\tinitData,\n\t\thostUtils,\n\t\turiTransformer,\n\t);\n\n\t// rewrite onTerminate-function to be a proper shutdown\n\tonTerminate = (reason: string) => extensionHostMain.terminate(reason);\n}\n\nstartExtensionHostProcess().catch((err) => console.log(err));\n"],
  "mappings": "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",
  "names": ["require"]
}
