{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/api/node/extHostConsoleForwarder.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { AbstractExtHostConsoleForwarder } from '../common/extHostConsoleForwarder.js';\nimport { IExtHostInitDataService } from '../common/extHostInitDataService.js';\nimport { IExtHostRpcService } from '../common/extHostRpcService.js';\nimport { NativeLogMarkers } from '../../services/extensions/common/extensionHostProtocol.js';\n\nconst MAX_STREAM_BUFFER_LENGTH = 1024 * 1024;\n\nexport class ExtHostConsoleForwarder extends AbstractExtHostConsoleForwarder {\n\n\tprivate _isMakingConsoleCall: boolean = false;\n\n\tconstructor(\n\t\t@IExtHostRpcService extHostRpc: IExtHostRpcService,\n\t\t@IExtHostInitDataService initData: IExtHostInitDataService,\n\t) {\n\t\tsuper(extHostRpc, initData);\n\n\t\tthis._wrapStream('stderr', 'error');\n\t\tthis._wrapStream('stdout', 'log');\n\t}\n\n\tprotected override _nativeConsoleLogMessage(method: 'log' | 'info' | 'warn' | 'error' | 'debug', original: (...args: any[]) => void, args: IArguments) {\n\t\tconst stream = method === 'error' || method === 'warn' ? process.stderr : process.stdout;\n\t\tthis._isMakingConsoleCall = true;\n\t\tstream.write(`\\n${NativeLogMarkers.Start}\\n`);\n\t\toriginal.apply(console, args as any);\n\t\tstream.write(`\\n${NativeLogMarkers.End}\\n`);\n\t\tthis._isMakingConsoleCall = false;\n\t}\n\n\t/**\n\t * Wraps process.stderr/stdout.write() so that it is transmitted to the\n\t * renderer or CLI. It both calls through to the original method as well\n\t * as to console.log with complete lines so that they're made available\n\t * to the debugger/CLI.\n\t */\n\tprivate _wrapStream(streamName: 'stdout' | 'stderr', severity: 'log' | 'warn' | 'error') {\n\t\tconst stream = process[streamName];\n\t\tconst original = stream.write;\n\n\t\tlet buf = '';\n\n\t\tObject.defineProperty(stream, 'write', {\n\t\t\tset: () => { },\n\t\t\tget: () => (chunk: Uint8Array | string, encoding?: BufferEncoding, callback?: (err?: Error) => void) => {\n\t\t\t\tif (!this._isMakingConsoleCall) {\n\t\t\t\t\tbuf += (chunk as any).toString(encoding);\n\t\t\t\t\tconst eol = buf.length > MAX_STREAM_BUFFER_LENGTH ? buf.length : buf.lastIndexOf('\\n');\n\t\t\t\t\tif (eol !== -1) {\n\t\t\t\t\t\tconsole[severity](buf.slice(0, eol));\n\t\t\t\t\t\tbuf = buf.slice(eol + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\toriginal.call(stream, chunk, encoding, callback);\n\t\t\t},\n\t\t});\n\t}\n}\n"],
  "mappings": ";;;;;;;;;;;;AAKA,SAAS,uCAAuC;AAChD,SAAS,+BAA+B;AACxC,SAAS,0BAA0B;AACnC,SAAS,wBAAwB;AAEjC,MAAM,2BAA2B,OAAO;AAEjC,IAAM,0BAAN,cAAsC,gCAAgC;AAAA,EAZ7E,OAY6E;AAAA;AAAA;AAAA,EAEpE,uBAAgC;AAAA,EAExC,YACqB,YACK,UACxB;AACD,UAAM,YAAY,QAAQ;AAE1B,SAAK,YAAY,UAAU,OAAO;AAClC,SAAK,YAAY,UAAU,KAAK;AAAA,EACjC;AAAA,EAEmB,yBAAyB,QAAqD,UAAoC,MAAkB;AACtJ,UAAM,SAAS,WAAW,WAAW,WAAW,SAAS,QAAQ,SAAS,QAAQ;AAClF,SAAK,uBAAuB;AAC5B,WAAO,MAAM;AAAA,EAAK,iBAAiB,KAAK;AAAA,CAAI;AAC5C,aAAS,MAAM,SAAS,IAAW;AACnC,WAAO,MAAM;AAAA,EAAK,iBAAiB,GAAG;AAAA,CAAI;AAC1C,SAAK,uBAAuB;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,YAAY,YAAiC,UAAoC;AACxF,UAAM,SAAS,QAAQ,UAAU;AACjC,UAAM,WAAW,OAAO;AAExB,QAAI,MAAM;AAEV,WAAO,eAAe,QAAQ,SAAS;AAAA,MACtC,KAAK,6BAAM;AAAA,MAAE,GAAR;AAAA,MACL,KAAK,6BAAM,CAAC,OAA4B,UAA2B,aAAqC;AACvG,YAAI,CAAC,KAAK,sBAAsB;AAC/B,iBAAQ,MAAc,SAAS,QAAQ;AACvC,gBAAM,MAAM,IAAI,SAAS,2BAA2B,IAAI,SAAS,IAAI,YAAY,IAAI;AACrF,cAAI,QAAQ,IAAI;AACf,oBAAQ,QAAQ,EAAE,IAAI,MAAM,GAAG,GAAG,CAAC;AACnC,kBAAM,IAAI,MAAM,MAAM,CAAC;AAAA,UACxB;AAAA,QACD;AAEA,iBAAS,KAAK,QAAQ,OAAO,UAAU,QAAQ;AAAA,MAChD,GAXK;AAAA,IAYN,CAAC;AAAA,EACF;AACD;AAnDa,0BAAN;AAAA,EAKJ;AAAA,EACA;AAAA,GANU;",
  "names": []
}
