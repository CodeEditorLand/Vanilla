{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/api/node/extHostTunnelService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport { exec } from 'child_process';\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { DisposableStore } from '../../../base/common/lifecycle.js';\nimport { MovingAverage } from '../../../base/common/numbers.js';\nimport { isLinux } from '../../../base/common/platform.js';\nimport * as resources from '../../../base/common/resources.js';\nimport { URI } from '../../../base/common/uri.js';\nimport * as pfs from '../../../base/node/pfs.js';\nimport { ISocket, SocketCloseEventType } from '../../../base/parts/ipc/common/ipc.net.js';\nimport { ILogService } from '../../../platform/log/common/log.js';\nimport { ManagedSocket, RemoteSocketHalf, connectManagedSocket } from '../../../platform/remote/common/managedSocket.js';\nimport { ManagedRemoteConnection } from '../../../platform/remote/common/remoteAuthorityResolver.js';\nimport { ISignService } from '../../../platform/sign/common/sign.js';\nimport { isAllInterfaces, isLocalhost } from '../../../platform/tunnel/common/tunnel.js';\nimport { NodeRemoteTunnel } from '../../../platform/tunnel/node/tunnelService.js';\nimport { IExtHostInitDataService } from '../common/extHostInitDataService.js';\nimport { IExtHostRpcService } from '../common/extHostRpcService.js';\nimport { ExtHostTunnelService } from '../common/extHostTunnelService.js';\nimport { CandidatePort, parseAddress } from '../../services/remote/common/tunnelModel.js';\nimport * as vscode from 'vscode';\n\nexport function getSockets(stdout: string): Record<string, { pid: number; socket: number }> {\n\tconst lines = stdout.trim().split('\\n');\n\tconst mapped: { pid: number; socket: number }[] = [];\n\tlines.forEach(line => {\n\t\tconst match = /\\/proc\\/(\\d+)\\/fd\\/\\d+ -> socket:\\[(\\d+)\\]/.exec(line)!;\n\t\tif (match && match.length >= 3) {\n\t\t\tmapped.push({\n\t\t\t\tpid: parseInt(match[1], 10),\n\t\t\t\tsocket: parseInt(match[2], 10)\n\t\t\t});\n\t\t}\n\t});\n\tconst socketMap = mapped.reduce((m: Record<string, typeof mapped[0]>, socket) => {\n\t\tm[socket.socket] = socket;\n\t\treturn m;\n\t}, {});\n\treturn socketMap;\n}\n\nexport function loadListeningPorts(...stdouts: string[]): { socket: number; ip: string; port: number }[] {\n\tconst table = ([] as Record<string, string>[]).concat(...stdouts.map(loadConnectionTable));\n\treturn [\n\t\t...new Map(\n\t\t\ttable.filter(row => row.st === '0A')\n\t\t\t\t.map(row => {\n\t\t\t\t\tconst address = row.local_address.split(':');\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsocket: parseInt(row.inode, 10),\n\t\t\t\t\t\tip: parseIpAddress(address[0]),\n\t\t\t\t\t\tport: parseInt(address[1], 16)\n\t\t\t\t\t};\n\t\t\t\t}).map(port => [port.ip + ':' + port.port, port])\n\t\t).values()\n\t];\n}\n\nexport function parseIpAddress(hex: string): string {\n\tlet result = '';\n\tif (hex.length === 8) {\n\t\tfor (let i = hex.length - 2; i >= 0; i -= 2) {\n\t\t\tresult += parseInt(hex.substr(i, 2), 16);\n\t\t\tif (i !== 0) {\n\t\t\t\tresult += '.';\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Nice explanation of host format in tcp6 file: https://serverfault.com/questions/592574/why-does-proc-net-tcp6-represents-1-as-1000\n\t\tfor (let i = 0; i < hex.length; i += 8) {\n\t\t\tconst word = hex.substring(i, i + 8);\n\t\t\tlet subWord = '';\n\t\t\tfor (let j = 8; j >= 2; j -= 2) {\n\t\t\t\tsubWord += word.substring(j - 2, j);\n\t\t\t\tif ((j === 6) || (j === 2)) {\n\t\t\t\t\t// Trim leading zeros\n\t\t\t\t\tsubWord = parseInt(subWord, 16).toString(16);\n\t\t\t\t\tresult += `${subWord}`;\n\t\t\t\t\tsubWord = '';\n\t\t\t\t\tif (i + j !== hex.length - 6) {\n\t\t\t\t\t\tresult += ':';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nexport function loadConnectionTable(stdout: string): Record<string, string>[] {\n\tconst lines = stdout.trim().split('\\n');\n\tconst names = lines.shift()!.trim().split(/\\s+/)\n\t\t.filter(name => name !== 'rx_queue' && name !== 'tm->when');\n\tconst table = lines.map(line => line.trim().split(/\\s+/).reduce((obj: Record<string, string>, value, i) => {\n\t\tobj[names[i] || i] = value;\n\t\treturn obj;\n\t}, {}));\n\treturn table;\n}\n\nfunction knownExcludeCmdline(command: string): boolean {\n\treturn !!command.match(/.*\\.vscode-server-[a-zA-Z]+\\/bin.*/)\n\t\t|| (command.indexOf('out/server-main.js') !== -1)\n\t\t|| (command.indexOf('_productName=VSCode') !== -1);\n}\n\nexport function getRootProcesses(stdout: string) {\n\tconst lines = stdout.trim().split('\\n');\n\tconst mapped: { pid: number; cmd: string; ppid: number }[] = [];\n\tlines.forEach(line => {\n\t\tconst match = /^\\d+\\s+\\D+\\s+root\\s+(\\d+)\\s+(\\d+).+\\d+\\:\\d+\\:\\d+\\s+(.+)$/.exec(line)!;\n\t\tif (match && match.length >= 4) {\n\t\t\tmapped.push({\n\t\t\t\tpid: parseInt(match[1], 10),\n\t\t\t\tppid: parseInt(match[2]),\n\t\t\t\tcmd: match[3]\n\t\t\t});\n\t\t}\n\t});\n\treturn mapped;\n}\n\nexport async function findPorts(connections: { socket: number; ip: string; port: number }[], socketMap: Record<string, { pid: number; socket: number }>, processes: { pid: number; cwd: string; cmd: string }[]): Promise<CandidatePort[]> {\n\tconst processMap = processes.reduce((m: Record<string, typeof processes[0]>, process) => {\n\t\tm[process.pid] = process;\n\t\treturn m;\n\t}, {});\n\n\tconst ports: CandidatePort[] = [];\n\tconnections.forEach(({ socket, ip, port }) => {\n\t\tconst pid = socketMap[socket] ? socketMap[socket].pid : undefined;\n\t\tconst command: string | undefined = pid ? processMap[pid]?.cmd : undefined;\n\t\tif (pid && command && !knownExcludeCmdline(command)) {\n\t\t\tports.push({ host: ip, port, detail: command, pid });\n\t\t}\n\t});\n\treturn ports;\n}\n\nexport function tryFindRootPorts(connections: { socket: number; ip: string; port: number }[], rootProcessesStdout: string, previousPorts: Map<number, CandidatePort & { ppid: number }>): Map<number, CandidatePort & { ppid: number }> {\n\tconst ports: Map<number, CandidatePort & { ppid: number }> = new Map();\n\tconst rootProcesses = getRootProcesses(rootProcessesStdout);\n\n\tfor (const connection of connections) {\n\t\tconst previousPort = previousPorts.get(connection.port);\n\t\tif (previousPort) {\n\t\t\tports.set(connection.port, previousPort);\n\t\t\tcontinue;\n\t\t}\n\t\tconst rootProcessMatch = rootProcesses.find((value) => value.cmd.includes(`${connection.port}`));\n\t\tif (rootProcessMatch) {\n\t\t\tlet bestMatch = rootProcessMatch;\n\t\t\t// There are often several processes that \"look\" like they could match the port.\n\t\t\t// The one we want is usually the child of the other. Find the most child process.\n\t\t\tlet mostChild: { pid: number; cmd: string; ppid: number } | undefined;\n\t\t\tdo {\n\t\t\t\tmostChild = rootProcesses.find(value => value.ppid === bestMatch.pid);\n\t\t\t\tif (mostChild) {\n\t\t\t\t\tbestMatch = mostChild;\n\t\t\t\t}\n\t\t\t} while (mostChild);\n\t\t\tports.set(connection.port, { host: connection.ip, port: connection.port, pid: bestMatch.pid, detail: bestMatch.cmd, ppid: bestMatch.ppid });\n\t\t} else {\n\t\t\tports.set(connection.port, { host: connection.ip, port: connection.port, ppid: Number.MAX_VALUE });\n\t\t}\n\t}\n\n\treturn ports;\n}\n\nexport class NodeExtHostTunnelService extends ExtHostTunnelService {\n\tprivate _initialCandidates: CandidatePort[] | undefined = undefined;\n\tprivate _foundRootPorts: Map<number, CandidatePort & { ppid: number }> = new Map();\n\tprivate _candidateFindingEnabled: boolean = false;\n\n\tconstructor(\n\t\t@IExtHostRpcService extHostRpc: IExtHostRpcService,\n\t\t@IExtHostInitDataService private readonly initData: IExtHostInitDataService,\n\t\t@ILogService logService: ILogService,\n\t\t@ISignService private readonly signService: ISignService,\n\t) {\n\t\tsuper(extHostRpc, initData, logService);\n\t\tif (isLinux && initData.remote.isRemote && initData.remote.authority) {\n\t\t\tthis._proxy.$setRemoteTunnelService(process.pid);\n\t\t\tthis.setInitialCandidates();\n\t\t}\n\t}\n\n\toverride async $registerCandidateFinder(enable: boolean): Promise<void> {\n\t\tif (enable && this._candidateFindingEnabled) {\n\t\t\t// already enabled\n\t\t\treturn;\n\t\t}\n\n\t\tthis._candidateFindingEnabled = enable;\n\t\tlet oldPorts: { host: string; port: number; detail?: string }[] | undefined = undefined;\n\n\t\t// If we already have found initial candidates send those immediately.\n\t\tif (this._initialCandidates) {\n\t\t\toldPorts = this._initialCandidates;\n\t\t\tawait this._proxy.$onFoundNewCandidates(this._initialCandidates);\n\t\t}\n\n\t\t// Regularly scan to see if the candidate ports have changed.\n\t\tconst movingAverage = new MovingAverage();\n\t\tlet scanCount = 0;\n\t\twhile (this._candidateFindingEnabled) {\n\t\t\tconst startTime = new Date().getTime();\n\t\t\tconst newPorts = (await this.findCandidatePorts()).filter(candidate => (isLocalhost(candidate.host) || isAllInterfaces(candidate.host)));\n\t\t\tthis.logService.trace(`ForwardedPorts: (ExtHostTunnelService) found candidate ports ${newPorts.map(port => port.port).join(', ')}`);\n\t\t\tconst timeTaken = new Date().getTime() - startTime;\n\t\t\tthis.logService.trace(`ForwardedPorts: (ExtHostTunnelService) candidate port scan took ${timeTaken} ms.`);\n\t\t\t// Do not count the first few scans towards the moving average as they are likely to be slower.\n\t\t\tif (scanCount++ > 3) {\n\t\t\t\tmovingAverage.update(timeTaken);\n\t\t\t}\n\t\t\tif (!oldPorts || (JSON.stringify(oldPorts) !== JSON.stringify(newPorts))) {\n\t\t\t\toldPorts = newPorts;\n\t\t\t\tawait this._proxy.$onFoundNewCandidates(oldPorts);\n\t\t\t}\n\t\t\tconst delay = this.calculateDelay(movingAverage.value);\n\t\t\tthis.logService.trace(`ForwardedPorts: (ExtHostTunnelService) next candidate port scan in ${delay} ms.`);\n\t\t\tawait (new Promise<void>(resolve => setTimeout(() => resolve(), delay)));\n\t\t}\n\t}\n\n\tprivate calculateDelay(movingAverage: number) {\n\t\t// Some local testing indicated that the moving average might be between 50-100 ms.\n\t\treturn Math.max(movingAverage * 20, 2000);\n\t}\n\n\tprivate async setInitialCandidates(): Promise<void> {\n\t\tthis._initialCandidates = await this.findCandidatePorts();\n\t\tthis.logService.trace(`ForwardedPorts: (ExtHostTunnelService) Initial candidates found: ${this._initialCandidates.map(c => c.port).join(', ')}`);\n\t}\n\n\tprivate async findCandidatePorts(): Promise<CandidatePort[]> {\n\t\tlet tcp: string = '';\n\t\tlet tcp6: string = '';\n\t\ttry {\n\t\t\ttcp = await fs.promises.readFile('/proc/net/tcp', 'utf8');\n\t\t\ttcp6 = await fs.promises.readFile('/proc/net/tcp6', 'utf8');\n\t\t} catch (e) {\n\t\t\t// File reading error. No additional handling needed.\n\t\t}\n\t\tconst connections: { socket: number; ip: string; port: number }[] = loadListeningPorts(tcp, tcp6);\n\n\t\tconst procSockets: string = await (new Promise(resolve => {\n\t\t\texec('ls -l /proc/[0-9]*/fd/[0-9]* | grep socket:', (error, stdout, stderr) => {\n\t\t\t\tresolve(stdout);\n\t\t\t});\n\t\t}));\n\t\tconst socketMap = getSockets(procSockets);\n\n\t\tconst procChildren = await pfs.Promises.readdir('/proc');\n\t\tconst processes: {\n\t\t\tpid: number; cwd: string; cmd: string;\n\t\t}[] = [];\n\t\tfor (const childName of procChildren) {\n\t\t\ttry {\n\t\t\t\tconst pid: number = Number(childName);\n\t\t\t\tconst childUri = resources.joinPath(URI.file('/proc'), childName);\n\t\t\t\tconst childStat = await fs.promises.stat(childUri.fsPath);\n\t\t\t\tif (childStat.isDirectory() && !isNaN(pid)) {\n\t\t\t\t\tconst cwd = await fs.promises.readlink(resources.joinPath(childUri, 'cwd').fsPath);\n\t\t\t\t\tconst cmd = await fs.promises.readFile(resources.joinPath(childUri, 'cmdline').fsPath, 'utf8');\n\t\t\t\t\tprocesses.push({ pid, cwd, cmd });\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t//\n\t\t\t}\n\t\t}\n\n\t\tconst unFoundConnections: { socket: number; ip: string; port: number }[] = [];\n\t\tconst filteredConnections = connections.filter((connection => {\n\t\t\tconst foundConnection = socketMap[connection.socket];\n\t\t\tif (!foundConnection) {\n\t\t\t\tunFoundConnections.push(connection);\n\t\t\t}\n\t\t\treturn foundConnection;\n\t\t}));\n\n\t\tconst foundPorts = findPorts(filteredConnections, socketMap, processes);\n\t\tlet heuristicPorts: CandidatePort[] | undefined;\n\t\tthis.logService.trace(`ForwardedPorts: (ExtHostTunnelService) number of possible root ports ${unFoundConnections.length}`);\n\t\tif (unFoundConnections.length > 0) {\n\t\t\tconst rootProcesses: string = await (new Promise(resolve => {\n\t\t\t\texec('ps -F -A -l | grep root', (error, stdout, stderr) => {\n\t\t\t\t\tresolve(stdout);\n\t\t\t\t});\n\t\t\t}));\n\t\t\tthis._foundRootPorts = tryFindRootPorts(unFoundConnections, rootProcesses, this._foundRootPorts);\n\t\t\theuristicPorts = Array.from(this._foundRootPorts.values());\n\t\t\tthis.logService.trace(`ForwardedPorts: (ExtHostTunnelService) heuristic ports ${heuristicPorts.map(heuristicPort => heuristicPort.port).join(', ')}`);\n\n\t\t}\n\t\treturn foundPorts.then(foundCandidates => {\n\t\t\tif (heuristicPorts) {\n\t\t\t\treturn foundCandidates.concat(heuristicPorts);\n\t\t\t} else {\n\t\t\t\treturn foundCandidates;\n\t\t\t}\n\t\t});\n\t}\n\n\tprotected override makeManagedTunnelFactory(authority: vscode.ManagedResolvedAuthority): vscode.RemoteAuthorityResolver['tunnelFactory'] {\n\t\treturn async (tunnelOptions) => {\n\t\t\tconst t = new NodeRemoteTunnel(\n\t\t\t\t{\n\t\t\t\t\tcommit: this.initData.commit,\n\t\t\t\t\tquality: this.initData.quality,\n\t\t\t\t\tlogService: this.logService,\n\t\t\t\t\tipcLogger: null,\n\t\t\t\t\t// services and address providers have stubs since we don't need\n\t\t\t\t\t// the connection identification that the renderer process uses\n\t\t\t\t\tremoteSocketFactoryService: {\n\t\t\t\t\t\t_serviceBrand: undefined,\n\t\t\t\t\t\tasync connect(_connectTo: ManagedRemoteConnection, path: string, query: string, debugLabel: string): Promise<ISocket> {\n\t\t\t\t\t\t\tconst result = await authority.makeConnection();\n\t\t\t\t\t\t\treturn ExtHostManagedSocket.connect(result, path, query, debugLabel);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tregister() {\n\t\t\t\t\t\t\tthrow new Error('not implemented');\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\taddressProvider: {\n\t\t\t\t\t\tgetAddress() {\n\t\t\t\t\t\t\treturn Promise.resolve({\n\t\t\t\t\t\t\t\tconnectTo: new ManagedRemoteConnection(0),\n\t\t\t\t\t\t\t\tconnectionToken: authority.connectionToken,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tsignService: this.signService,\n\t\t\t\t},\n\t\t\t\t'localhost',\n\t\t\t\ttunnelOptions.remoteAddress.host || 'localhost',\n\t\t\t\ttunnelOptions.remoteAddress.port,\n\t\t\t\ttunnelOptions.localAddressPort,\n\t\t\t);\n\n\t\t\tawait t.waitForReady();\n\n\t\t\tconst disposeEmitter = new Emitter<void>();\n\n\t\t\treturn {\n\t\t\t\tlocalAddress: parseAddress(t.localAddress) ?? t.localAddress,\n\t\t\t\tremoteAddress: { port: t.tunnelRemotePort, host: t.tunnelRemoteHost },\n\t\t\t\tonDidDispose: disposeEmitter.event,\n\t\t\t\tdispose: () => {\n\t\t\t\t\tt.dispose();\n\t\t\t\t\tdisposeEmitter.fire();\n\t\t\t\t\tdisposeEmitter.dispose();\n\t\t\t\t},\n\t\t\t};\n\t\t};\n\t}\n}\n\nclass ExtHostManagedSocket extends ManagedSocket {\n\tpublic static connect(\n\t\tpassing: vscode.ManagedMessagePassing,\n\t\tpath: string, query: string, debugLabel: string,\n\t): Promise<ExtHostManagedSocket> {\n\t\tconst d = new DisposableStore();\n\t\tconst half: RemoteSocketHalf = {\n\t\t\tonClose: d.add(new Emitter()),\n\t\t\tonData: d.add(new Emitter()),\n\t\t\tonEnd: d.add(new Emitter()),\n\t\t};\n\n\t\td.add(passing.onDidReceiveMessage(d => half.onData.fire(VSBuffer.wrap(d))));\n\t\td.add(passing.onDidEnd(() => half.onEnd.fire()));\n\t\td.add(passing.onDidClose(error => half.onClose.fire({\n\t\t\ttype: SocketCloseEventType.NodeSocketCloseEvent,\n\t\t\terror,\n\t\t\thadError: !!error\n\t\t})));\n\n\t\tconst socket = new ExtHostManagedSocket(passing, debugLabel, half);\n\t\tsocket._register(d);\n\t\treturn connectManagedSocket(socket, path, query, debugLabel, half);\n\t}\n\n\tconstructor(\n\t\tprivate readonly passing: vscode.ManagedMessagePassing,\n\t\tdebugLabel: string,\n\t\thalf: RemoteSocketHalf,\n\t) {\n\t\tsuper(debugLabel, half);\n\t}\n\n\tpublic override write(buffer: VSBuffer): void {\n\t\tthis.passing.send(buffer.buffer);\n\t}\n\tprotected override closeRemote(): void {\n\t\tthis.passing.end();\n\t}\n\n\tpublic override async drain(): Promise<void> {\n\t\tawait this.passing.drain?.();\n\t}\n}\n"],
  "mappings": "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",
  "names": ["process", "d"]
}
