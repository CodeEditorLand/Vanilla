{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/api/node/extHostStoragePaths.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport * as path from '../../../base/common/path.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { ExtensionStoragePaths as CommonExtensionStoragePaths } from '../common/extHostStoragePaths.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { IntervalTimer, timeout } from '../../../base/common/async.js';\nimport { ILogService } from '../../../platform/log/common/log.js';\nimport { Promises } from '../../../base/node/pfs.js';\n\nexport class ExtensionStoragePaths extends CommonExtensionStoragePaths {\n\n\tprivate _workspaceStorageLock: Lock | null = null;\n\n\tprotected override async _getWorkspaceStorageURI(storageName: string): Promise<URI> {\n\t\tconst workspaceStorageURI = await super._getWorkspaceStorageURI(storageName);\n\t\tif (workspaceStorageURI.scheme !== Schemas.file) {\n\t\t\treturn workspaceStorageURI;\n\t\t}\n\n\t\tif (this._environment.skipWorkspaceStorageLock) {\n\t\t\tthis._logService.info(`Skipping acquiring lock for ${workspaceStorageURI.fsPath}.`);\n\t\t\treturn workspaceStorageURI;\n\t\t}\n\n\t\tconst workspaceStorageBase = workspaceStorageURI.fsPath;\n\t\tlet attempt = 0;\n\t\tdo {\n\t\t\tlet workspaceStoragePath: string;\n\t\t\tif (attempt === 0) {\n\t\t\t\tworkspaceStoragePath = workspaceStorageBase;\n\t\t\t} else {\n\t\t\t\tworkspaceStoragePath = (\n\t\t\t\t\t/[/\\\\]$/.test(workspaceStorageBase)\n\t\t\t\t\t\t? `${workspaceStorageBase.substr(0, workspaceStorageBase.length - 1)}-${attempt}`\n\t\t\t\t\t\t: `${workspaceStorageBase}-${attempt}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tawait mkdir(workspaceStoragePath);\n\n\t\t\tconst lockfile = path.join(workspaceStoragePath, 'vscode.lock');\n\t\t\tconst lock = await tryAcquireLock(this._logService, lockfile, false);\n\t\t\tif (lock) {\n\t\t\t\tthis._workspaceStorageLock = lock;\n\t\t\t\tprocess.on('exit', () => {\n\t\t\t\t\tlock.dispose();\n\t\t\t\t});\n\t\t\t\treturn URI.file(workspaceStoragePath);\n\t\t\t}\n\n\t\t\tattempt++;\n\t\t} while (attempt < 10);\n\n\t\t// just give up\n\t\treturn workspaceStorageURI;\n\t}\n\n\toverride onWillDeactivateAll(): void {\n\t\t// the lock will be released soon\n\t\tthis._workspaceStorageLock?.setWillRelease(6000);\n\t}\n}\n\nasync function mkdir(dir: string): Promise<void> {\n\ttry {\n\t\tawait fs.promises.stat(dir);\n\t\treturn;\n\t} catch {\n\t\t// doesn't exist, that's OK\n\t}\n\n\ttry {\n\t\tawait fs.promises.mkdir(dir, { recursive: true });\n\t} catch {\n\t}\n}\n\nconst MTIME_UPDATE_TIME = 1000; // 1s\nconst STALE_LOCK_TIME = 10 * 60 * 1000; // 10 minutes\n\nclass Lock extends Disposable {\n\n\tprivate readonly _timer: IntervalTimer;\n\n\tconstructor(\n\t\tprivate readonly logService: ILogService,\n\t\tprivate readonly filename: string\n\t) {\n\t\tsuper();\n\n\t\tthis._timer = this._register(new IntervalTimer());\n\t\tthis._timer.cancelAndSet(async () => {\n\t\t\tconst contents = await readLockfileContents(logService, filename);\n\t\t\tif (!contents || contents.pid !== process.pid) {\n\t\t\t\t// we don't hold the lock anymore ...\n\t\t\t\tlogService.info(`Lock '${filename}': The lock was lost unexpectedly.`);\n\t\t\t\tthis._timer.cancel();\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tawait fs.promises.utimes(filename, new Date(), new Date());\n\t\t\t} catch (err) {\n\t\t\t\tlogService.error(err);\n\t\t\t\tlogService.info(`Lock '${filename}': Could not update mtime.`);\n\t\t\t}\n\t\t}, MTIME_UPDATE_TIME);\n\t}\n\n\tpublic override dispose(): void {\n\t\tsuper.dispose();\n\t\ttry { fs.unlinkSync(this.filename); } catch (err) { }\n\t}\n\n\tpublic async setWillRelease(timeUntilReleaseMs: number): Promise<void> {\n\t\tthis.logService.info(`Lock '${this.filename}': Marking the lockfile as scheduled to be released in ${timeUntilReleaseMs} ms.`);\n\t\ttry {\n\t\t\tconst contents: ILockfileContents = {\n\t\t\t\tpid: process.pid,\n\t\t\t\twillReleaseAt: Date.now() + timeUntilReleaseMs\n\t\t\t};\n\t\t\tawait Promises.writeFile(this.filename, JSON.stringify(contents), { flag: 'w' });\n\t\t} catch (err) {\n\t\t\tthis.logService.error(err);\n\t\t}\n\t}\n}\n\n/**\n * Attempt to acquire a lock on a directory.\n * This does not use the real `flock`, but uses a file.\n * @returns a disposable if the lock could be acquired or null if it could not.\n */\nasync function tryAcquireLock(logService: ILogService, filename: string, isSecondAttempt: boolean): Promise<Lock | null> {\n\ttry {\n\t\tconst contents: ILockfileContents = {\n\t\t\tpid: process.pid,\n\t\t\twillReleaseAt: 0\n\t\t};\n\t\tawait Promises.writeFile(filename, JSON.stringify(contents), { flag: 'wx' });\n\t} catch (err) {\n\t\tlogService.error(err);\n\t}\n\n\t// let's see if we got the lock\n\tconst contents = await readLockfileContents(logService, filename);\n\tif (!contents || contents.pid !== process.pid) {\n\t\t// we didn't get the lock\n\t\tif (isSecondAttempt) {\n\t\t\tlogService.info(`Lock '${filename}': Could not acquire lock, giving up.`);\n\t\t\treturn null;\n\t\t}\n\t\tlogService.info(`Lock '${filename}': Could not acquire lock, checking if the file is stale.`);\n\t\treturn checkStaleAndTryAcquireLock(logService, filename);\n\t}\n\n\t// we got the lock\n\tlogService.info(`Lock '${filename}': Lock acquired.`);\n\treturn new Lock(logService, filename);\n}\n\ninterface ILockfileContents {\n\tpid: number;\n\twillReleaseAt: number | undefined;\n}\n\n/**\n * @returns 0 if the pid cannot be read\n */\nasync function readLockfileContents(logService: ILogService, filename: string): Promise<ILockfileContents | null> {\n\tlet contents: Buffer;\n\ttry {\n\t\tcontents = await fs.promises.readFile(filename);\n\t} catch (err) {\n\t\t// cannot read the file\n\t\tlogService.error(err);\n\t\treturn null;\n\t}\n\n\ttry {\n\t\treturn JSON.parse(String(contents));\n\t} catch (err) {\n\t\t// cannot parse the file\n\t\tlogService.error(err);\n\t\treturn null;\n\t}\n}\n\n/**\n * @returns 0 if the mtime cannot be read\n */\nasync function readmtime(logService: ILogService, filename: string): Promise<number> {\n\tlet stats: fs.Stats;\n\ttry {\n\t\tstats = await fs.promises.stat(filename);\n\t} catch (err) {\n\t\t// cannot read the file stats to check if it is stale or not\n\t\tlogService.error(err);\n\t\treturn 0;\n\t}\n\treturn stats.mtime.getTime();\n}\n\nfunction processExists(pid: number): boolean {\n\ttry {\n\t\tprocess.kill(pid, 0); // throws an exception if the process doesn't exist anymore.\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n}\n\nasync function checkStaleAndTryAcquireLock(logService: ILogService, filename: string): Promise<Lock | null> {\n\tconst contents = await readLockfileContents(logService, filename);\n\tif (!contents) {\n\t\tlogService.info(`Lock '${filename}': Could not read pid of lock holder.`);\n\t\treturn tryDeleteAndAcquireLock(logService, filename);\n\t}\n\n\tif (contents.willReleaseAt) {\n\t\tlet timeUntilRelease = contents.willReleaseAt - Date.now();\n\t\tif (timeUntilRelease < 5000) {\n\t\t\tif (timeUntilRelease > 0) {\n\t\t\t\tlogService.info(`Lock '${filename}': The lockfile is scheduled to be released in ${timeUntilRelease} ms.`);\n\t\t\t} else {\n\t\t\t\tlogService.info(`Lock '${filename}': The lockfile is scheduled to have been released.`);\n\t\t\t}\n\n\t\t\twhile (timeUntilRelease > 0) {\n\t\t\t\tawait timeout(Math.min(100, timeUntilRelease));\n\t\t\t\tconst mtime = await readmtime(logService, filename);\n\t\t\t\tif (mtime === 0) {\n\t\t\t\t\t// looks like the lock was released\n\t\t\t\t\treturn tryDeleteAndAcquireLock(logService, filename);\n\t\t\t\t}\n\t\t\t\ttimeUntilRelease = contents.willReleaseAt - Date.now();\n\t\t\t}\n\n\t\t\treturn tryDeleteAndAcquireLock(logService, filename);\n\t\t}\n\t}\n\n\tif (!processExists(contents.pid)) {\n\t\tlogService.info(`Lock '${filename}': The pid ${contents.pid} appears to be gone.`);\n\t\treturn tryDeleteAndAcquireLock(logService, filename);\n\t}\n\n\tconst mtime1 = await readmtime(logService, filename);\n\tconst elapsed1 = Date.now() - mtime1;\n\tif (elapsed1 <= STALE_LOCK_TIME) {\n\t\t// the lock does not look stale\n\t\tlogService.info(`Lock '${filename}': The lock does not look stale, elapsed: ${elapsed1} ms, giving up.`);\n\t\treturn null;\n\t}\n\n\t// the lock holder updates the mtime every 1s.\n\t// let's give it a chance to update the mtime\n\t// in case of a wake from sleep or something similar\n\tlogService.info(`Lock '${filename}': The lock looks stale, waiting for 2s.`);\n\tawait timeout(2000);\n\n\tconst mtime2 = await readmtime(logService, filename);\n\tconst elapsed2 = Date.now() - mtime2;\n\tif (elapsed2 <= STALE_LOCK_TIME) {\n\t\t// the lock does not look stale\n\t\tlogService.info(`Lock '${filename}': The lock does not look stale, elapsed: ${elapsed2} ms, giving up.`);\n\t\treturn null;\n\t}\n\n\t// the lock looks stale\n\tlogService.info(`Lock '${filename}': The lock looks stale even after waiting for 2s.`);\n\treturn tryDeleteAndAcquireLock(logService, filename);\n}\n\nasync function tryDeleteAndAcquireLock(logService: ILogService, filename: string): Promise<Lock | null> {\n\tlogService.info(`Lock '${filename}': Deleting a stale lock.`);\n\ttry {\n\t\tawait fs.promises.unlink(filename);\n\t} catch (err) {\n\t\t// cannot delete the file\n\t\t// maybe the file is already deleted\n\t}\n\treturn tryAcquireLock(logService, filename, true);\n}\n"],
  "mappings": "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",
  "names": ["contents"]
}
