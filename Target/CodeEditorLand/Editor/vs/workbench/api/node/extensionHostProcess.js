import*as C from"net";import _ from"minimist";import{ProcessTimeRunOnceScheduler as k}from"../../../base/common/async.js";import{VSBuffer as P}from"../../../base/common/buffer.js";import{isCancellationError as b,isSigPipeError as D,onUnexpectedError as E}from"../../../base/common/errors.js";import*as x from"../../../base/common/performance.js";import{realpath as O}from"../../../base/node/extpath.js";import{Promises as N}from"../../../base/node/pfs.js";import{BufferedEmitter as w,PersistentProtocol as H,ProtocolConstants as M}from"../../../base/parts/ipc/common/ipc.net.js";import{NodeSocket as y,WebSocketNodeSocket as U}from"../../../base/parts/ipc/node/ipc.net.js";import{boolean as A}from"../../../editor/common/config/editorOptions.js";import L from"../../../platform/product/common/product.js";import{ExtHostConnectionType as S,readExtHostConnection as j}from"../../services/extensions/common/extensionHostEnv.js";import{ExtensionHostExitCode as B,MessageType as h,createMessageOfType as v,isMessageOfType as W}from"../../services/extensions/common/extensionHostProtocol.js";import{ExtensionHostMain as $}from"../common/extensionHostMain.js";import{createURITransformer as V}from"./uriTransformer.js";import"../common/extHost.common.services.js";import"./extHost.node.services.js";import{createRequire as G}from"node:module";const R=G(import.meta.url);(function(){for(let e=0;e<process.execArgv.length;e++)process.execArgv[e]==="--inspect-port=0"&&(process.execArgv.splice(e,1),e--)})();const f=_(process.argv.slice(2),{boolean:["transformURIs","skipWorkspaceStorageLock"],string:["useHostProxy"]});(()=>{const o=R("module"),e=o._load;o._load=function(i){if(i==="natives")throw new Error('Either the extension or an NPM dependency is using the [unsupported "natives" node module](https://go.microsoft.com/fwlink/?linkid=871887).');return e.apply(this,arguments)}})();const u=process.exit.bind(process),F=process.on.bind(process);function X(o){process.exit=e=>{if(o)u(e);else{const i=new Error("An extension called process.exit() and this was prevented.")}},process.crash=()=>{const e=new Error("An extension called process.crash() and this was prevented.")},process.env.ELECTRON_RUN_AS_NODE="1",process.on=(e,i)=>{e==="uncaughtException"&&(i=()=>{try{return i.call(void 0,arguments)}catch{}}),F(e,i)}}let m=o=>{u()};function q(){const o=j(process.env);if(o.type===S.MessagePort)return new Promise((e,i)=>{const t=r=>{const c=r[0],d=new w;c.on("message",s=>d.fire(P.wrap(s.data))),c.on("close",()=>{m("renderer closed the MessagePort")}),c.start(),e({onMessage:d.event,send:s=>c.postMessage(s.buffer)})};process.parentPort.on("message",r=>t(r.ports))});if(o.type===S.Socket)return new Promise((e,i)=>{let t=null;const r=setTimeout(()=>{m("VSCODE_EXTHOST_IPC_SOCKET timeout")},6e4),c=M.ReconnectionGraceTime,d=M.ReconnectionShortGraceTime,s=new k(()=>m("renderer disconnected for too long (1)"),c),n=new k(()=>m("renderer disconnected for too long (2)"),d);process.on("message",(p,g)=>{if(p&&p.type==="VSCODE_EXTHOST_IPC_SOCKET"){g.setNoDelay(!0);const I=P.wrap(Buffer.from(p.initialDataChunk,"base64"));let l;if(p.skipWebSocketFrames)l=new y(g,"extHost-socket");else{const T=P.wrap(Buffer.from(p.inflateBytes,"base64"));l=new U(new y(g,"extHost-socket"),p.permessageDeflate,T,!1)}t?(s.cancel(),n.cancel(),t.beginAcceptReconnection(l,I),t.endAcceptReconnection(),t.sendResume()):(clearTimeout(r),t=new H({socket:l,initialChunk:I}),t.sendResume(),t.onDidDispose(()=>m("renderer disconnected")),e(t),t.onSocketClose(()=>{s.schedule()}))}if(p&&p.type==="VSCODE_EXTHOST_IPC_REDUCE_GRACE_TIME"){if(n.isScheduled())return;s.isScheduled()&&n.schedule()}});const a={type:"VSCODE_EXTHOST_IPC_READY"};process.send?.(a)});{const e=o.pipeName;return new Promise((i,t)=>{const r=C.createConnection(e,()=>{r.removeListener("error",t);const c=new H({socket:new y(r,"extHost-renderer")});c.sendResume(),i(c)});r.once("error",t),r.on("close",()=>{m("renderer closed the socket")})})}}async function K(){const o=await q();return new class{_onMessage=new w;onMessage=this._onMessage.event;_terminating;_protocolListener;constructor(){this._terminating=!1,this._protocolListener=o.onMessage(e=>{W(e,h.Terminate)?(this._terminating=!0,this._protocolListener.dispose(),m("received terminate message from renderer")):this._onMessage.fire(e)})}send(e){this._terminating||o.send(e)}async drain(){if(o.drain)return o.drain()}}}function z(o){return new Promise(e=>{const i=o.onMessage(t=>{i.dispose();const r=JSON.parse(t.toString()),c=r.commit,d=L.commit;if(c&&d&&c!==d&&u(B.VersionMismatch),r.parentPid){let s=0;setInterval(()=>{try{process.kill(r.parentPid,0),s=0}catch(a){a&&a.code==="EPERM"?(s++,s>=3&&m(`parent process ${r.parentPid} does not exist anymore (3 x EPERM): ${a.message} (code: ${a.code}) (errno: ${a.errno})`)):m(`parent process ${r.parentPid} does not exist anymore: ${a.message} (code: ${a.code}) (errno: ${a.errno})`)}},1e3);let n;try{n=R("native-watchdog"),n.start(r.parentPid)}catch(a){E(a)}}o.send(v(h.Initialized)),e({protocol:o,initData:r})});o.send(v(h.Ready))})}async function J(){const o=[];process.on("unhandledRejection",(s,n)=>{o.push(n),setTimeout(()=>{const a=o.indexOf(n);a>=0&&n.catch(p=>{o.splice(a,1),b(p)||(p&&p.stack,s&&E(s))})},1e3)}),process.on("rejectionHandled",s=>{const n=o.indexOf(s);n>=0&&o.splice(n,1)}),process.on("uncaughtException",s=>{D(s)||E(s)}),x.mark("code/extHost/willConnectToRenderer");const e=await K();x.mark("code/extHost/didConnectToRenderer");const i=await z(e);x.mark("code/extHost/didWaitForInitData");const{initData:t}=i;X(!!t.environment.extensionTestsLocationURI),t.environment.useHostProxy=f.useHostProxy!==void 0?f.useHostProxy!=="false":void 0,t.environment.skipWorkspaceStorageLock=A(f.skipWorkspaceStorageLock,!1);const r=new class{pid=process.pid;exit(n){u(n)}fsExists(n){return N.exists(n)}fsRealpath(n){return O(n)}};let c=null;t.remote.authority&&f.transformURIs&&(c=V(t.remote.authority));const d=new $(i.protocol,t,r,c);m=s=>d.terminate(s)}J().catch(o=>{});
