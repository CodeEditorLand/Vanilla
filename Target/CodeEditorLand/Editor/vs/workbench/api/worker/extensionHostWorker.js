import{VSBuffer as k}from"../../../../vs/base/common/buffer.js";import{Emitter as U}from"../../../../vs/base/common/event.js";import*as g from"../../../../vs/base/common/path.js";import*as u from"vs/base/common/performance";import"../../../../vs/base/parts/ipc/common/ipc.js";import{ExtensionHostMain as x}from"../../../../vs/workbench/api/common/extensionHostMain.js";import"../../../../vs/workbench/api/common/extHostExtensionService.js";import{createMessageOfType as y,isMessageOfType as F,MessageType as l}from"../../../../vs/workbench/services/extensions/common/extensionHostProtocol.js";import{NestedWorker as H}from"../../../../vs/workbench/services/extensions/worker/polyfillNestedWorker.js";import"../../../../vs/workbench/api/common/extHost.common.services.js";import"../../../../vs/workbench/api/worker/extHost.worker.services.js";import{FileAccess as P}from"../../../../vs/base/common/network.js";import{URI as d}from"../../../../vs/base/common/uri.js";const b=self.close.bind(self);self.close=()=>console.trace("'close' has been blocked");const S=postMessage.bind(self);self.postMessage=()=>console.trace("'postMessage' has been blocked");function R(t){return/^(file|vscode-remote):/i.test(t)}const M=fetch.bind(self);function E(t){self.fetch=async function(e,n){return e instanceof Request||R(String(e))&&(e=(await t(d.parse(String(e)))).toString(!0)),M(e,n)},self.XMLHttpRequest=class extends XMLHttpRequest{open(e,n,i,s,o){(async()=>(R(n.toString())&&(n=(await t(d.parse(n.toString()))).toString(!0)),super.open(e,n,i??!0,s,o)))()}}}if(self.importScripts=()=>{throw new Error("'importScripts' has been blocked")},self.addEventListener=()=>console.trace("'addEventListener' has been blocked"),self.AMDLoader=void 0,self.NLSLoaderPlugin=void 0,self.define=void 0,self.require=void 0,self.webkitRequestFileSystem=void 0,self.webkitRequestFileSystemSync=void 0,self.webkitResolveLocalFileSystemSyncURL=void 0,self.webkitResolveLocalFileSystemURL=void 0,self.Worker){const t=self.Worker;Worker=function(e,n){if(/^file:/i.test(e.toString()))e=P.uriToBrowserUri(d.parse(e.toString())).toString(!0);else if(/^vscode-remote:/i.test(e.toString()))throw new Error("Creating workers from remote extensions is currently not supported.");const s=`(${function(v){function f(r){return typeof r=="string"||r instanceof URL?String(r).replace(/^file:\/\//i,"vscode-file://vscode-app"):r}const p=fetch.bind(self);self.fetch=function(r,c){return r instanceof Request?p(r,c):p(f(r),c)},self.XMLHttpRequest=class extends XMLHttpRequest{open(r,c,L,I,w){return super.open(r,f(c),L??!0,I,w)}};const m=importScripts.bind(self);self.importScripts=(...r)=>{m(...r.map(f))},m(v)}.toString()}('${e}'))`;n=n||{},n.name=`${name} -> ${n.name||g.basename(e.toString())}`;const o=new Blob([s],{type:"application/javascript"}),a=URL.createObjectURL(o);return new t(a,n)}}else self.Worker=class extends H{constructor(t,e){super(S,t,{name:g.basename(t.toString()),...e})}};const W=new class{pid=void 0;exit(t){b()}};class T{protocol;constructor(){const e=new MessageChannel,n=new U;let i=!1;S(e.port2,[e.port2]),e.port1.onmessage=s=>{const{data:o}=s;if(!(o instanceof ArrayBuffer)){console.warn("UNKNOWN data received",o);return}const a=k.wrap(new Uint8Array(o,0,o.byteLength));if(F(a,l.Terminate)){i=!0,h("received terminate message from renderer");return}n.fire(a)},this.protocol={onMessage:n.event,send:s=>{if(!i){const o=s.buffer.buffer.slice(s.buffer.byteOffset,s.buffer.byteOffset+s.buffer.byteLength);e.port1.postMessage(o,[o])}}}}}function q(t){return new Promise(e=>{const n=t.onMessage(i=>{n.dispose();const s=JSON.parse(i.toString());t.send(y(l.Initialized)),e({protocol:t,initData:s})});t.send(y(l.Ready))})}let h=t=>b();function D(t){return!!t&&typeof t=="object"&&t.type==="vscode.init"&&t.data instanceof Map}function Y(){u.mark("code/extHost/willConnectToRenderer");const t=new T;return{onmessage(e){D(e)&&q(t.protocol).then(n=>{u.mark("code/extHost/didWaitForInitData");const i=new x(n.protocol,n.initData,W,null,e.data);E(s=>i.asBrowserUri(s)),h=s=>i.terminate(s)})}}}export{Y as create};
