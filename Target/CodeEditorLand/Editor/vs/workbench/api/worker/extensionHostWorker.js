import"../../../base/parts/ipc/common/ipc.js";import{VSBuffer as k}from"../../../base/common/buffer.js";import{Emitter as U}from"../../../base/common/event.js";import{isMessageOfType as x,MessageType as l,createMessageOfType as g}from"../../services/extensions/common/extensionHostProtocol.js";import{ExtensionHostMain as F}from"../common/extensionHostMain.js";import"../common/extHostExtensionService.js";import{NestedWorker as H}from"../../services/extensions/worker/polyfillNestedWorker.js";import*as u from"../../../base/common/path.js";import*as y from"../../../base/common/performance.js";import"../common/extHost.common.services.js";import"./extHost.worker.services.js";import{FileAccess as P}from"../../../base/common/network.js";import{URI as d}from"../../../base/common/uri.js";const b=self.close.bind(self);self.close=()=>{};const S=postMessage.bind(self);self.postMessage=()=>{};function R(t){return/^(file|vscode-remote):/i.test(t)}const M=fetch.bind(self);function E(t){self.fetch=async function(e,n){return e instanceof Request||R(String(e))&&(e=(await t(d.parse(String(e)))).toString(!0)),M(e,n)},self.XMLHttpRequest=class extends XMLHttpRequest{open(e,n,o,s,i){(async()=>(R(n.toString())&&(n=(await t(d.parse(n.toString()))).toString(!0)),super.open(e,n,o??!0,s,i)))()}}}if(self.importScripts=()=>{throw new Error("'importScripts' has been blocked")},self.addEventListener=()=>{},self.AMDLoader=void 0,self.NLSLoaderPlugin=void 0,self.define=void 0,self.require=void 0,self.webkitRequestFileSystem=void 0,self.webkitRequestFileSystemSync=void 0,self.webkitResolveLocalFileSystemSyncURL=void 0,self.webkitResolveLocalFileSystemURL=void 0,self.Worker){const t=self.Worker;Worker=function(e,n){if(/^file:/i.test(e.toString()))e=P.uriToBrowserUri(d.parse(e.toString())).toString(!0);else if(/^vscode-remote:/i.test(e.toString()))throw new Error("Creating workers from remote extensions is currently not supported.");const s=`(${function(v){function f(r){return typeof r=="string"||r instanceof URL?String(r).replace(/^file:\/\//i,"vscode-file://vscode-app"):r}const p=fetch.bind(self);self.fetch=function(r,c){return r instanceof Request?p(r,c):p(f(r),c)},self.XMLHttpRequest=class extends XMLHttpRequest{open(r,c,L,I,w){return super.open(r,f(c),L??!0,I,w)}};const m=importScripts.bind(self);self.importScripts=(...r)=>{m(...r.map(f))},m(v)}.toString()}('${e}'))`;n=n||{},n.name=`${name} -> ${n.name||u.basename(e.toString())}`;const i=new Blob([s],{type:"application/javascript"}),a=URL.createObjectURL(i);return new t(a,n)}}else self.Worker=class extends H{constructor(t,e){super(S,t,{name:u.basename(t.toString()),...e})}};const W=new class{pid=void 0;exit(t){b()}};class T{protocol;constructor(){const e=new MessageChannel,n=new U;let o=!1;S(e.port2,[e.port2]),e.port1.onmessage=s=>{const{data:i}=s;if(!(i instanceof ArrayBuffer))return;const a=k.wrap(new Uint8Array(i,0,i.byteLength));if(x(a,l.Terminate)){o=!0,h("received terminate message from renderer");return}n.fire(a)},this.protocol={onMessage:n.event,send:s=>{if(!o){const i=s.buffer.buffer.slice(s.buffer.byteOffset,s.buffer.byteOffset+s.buffer.byteLength);e.port1.postMessage(i,[i])}}}}}function q(t){return new Promise(e=>{const n=t.onMessage(o=>{n.dispose();const s=JSON.parse(o.toString());t.send(g(l.Initialized)),e({protocol:t,initData:s})});t.send(g(l.Ready))})}let h=t=>b();function D(t){return!!t&&typeof t=="object"&&t.type==="vscode.init"&&t.data instanceof Map}function Y(){y.mark("code/extHost/willConnectToRenderer");const t=new T;return{onmessage(e){D(e)&&q(t.protocol).then(n=>{y.mark("code/extHost/didWaitForInitData");const o=new F(n.protocol,n.initData,W,null,e.data);E(s=>o.asBrowserUri(s)),h=s=>o.terminate(s)})}}}export{Y as create};
