import r from"assert";import*as v from"sinon";import{Emitter as q}from"../../../../base/common/event.js";import{ExtHostTreeViews as O}from"../../common/extHostTreeViews.js";import{ExtHostCommands as W}from"../../common/extHostCommands.js";import{MainContext as j}from"../../common/extHost.protocol.js";import"vscode";import{TestRPCProtocol as A}from"../common/testRPCProtocol.js";import{mock as k}from"../../../../base/test/common/mock.js";import{TreeItemCollapsibleState as s}from"../../../common/views.js";import{NullLogService as N}from"../../../../platform/log/common/log.js";import{nullExtensionDescription as p}from"../../../services/extensions/common/extensions.js";import{runWithFakedTimers as M}from"../../../../base/test/common/timeTravelScheduler.js";import"../../common/extHostTelemetry.js";import{ensureNoDisposablesAreLeakedInTestSuite as K}from"../../../../base/test/common/utils.js";suite("ExtHostTreeView",function(){const b=K();class $ extends k(){onRefresh=new q;async $registerTreeViewDataProvider(t){}$refresh(t,a){return Promise.resolve(null).then(()=>{this.onRefresh.fire(a)})}$reveal(t,a,c){return Promise.resolve()}$disposeTree(t){return Promise.resolve()}}let l,o,n,E,u,f,y;setup(()=>{u={a:{aa:{},ab:{}},b:{ba:{},bb:{}}},f={},y={};const e=new A;return e.set(j.MainThreadCommands,new class extends k(){$registerCommand(){}}),o=new $,l=b.add(new O(o,new W(e,new N,new class extends k(){onExtensionError(){return!0}}),new N)),n=new q,E=new q,l.createTreeView("testNodeTreeProvider",{treeDataProvider:w()},p),l.createTreeView("testNodeWithIdTreeProvider",{treeDataProvider:x()},p),l.createTreeView("testNodeWithHighlightsTreeProvider",{treeDataProvider:V()},p),T("testNodeTreeProvider")}),test("construct node tree",()=>l.$getChildren("testNodeTreeProvider").then(e=>{const t=e?.map(a=>a.handle);return r.deepStrictEqual(t,["0/0:a","0/0:b"]),Promise.all([l.$getChildren("testNodeTreeProvider","0/0:a").then(a=>{const c=a?.map(d=>d.handle);return r.deepStrictEqual(c,["0/0:a/0:aa","0/0:a/0:ab"]),Promise.all([l.$getChildren("testNodeTreeProvider","0/0:a/0:aa").then(d=>r.strictEqual(d?.length,0)),l.$getChildren("testNodeTreeProvider","0/0:a/0:ab").then(d=>r.strictEqual(d?.length,0))])}),l.$getChildren("testNodeTreeProvider","0/0:b").then(a=>{const c=a?.map(d=>d.handle);return r.deepStrictEqual(c,["0/0:b/0:ba","0/0:b/0:bb"]),Promise.all([l.$getChildren("testNodeTreeProvider","0/0:b/0:ba").then(d=>r.strictEqual(d?.length,0)),l.$getChildren("testNodeTreeProvider","0/0:b/0:bb").then(d=>r.strictEqual(d?.length,0))])})])})),test("construct id tree",()=>l.$getChildren("testNodeWithIdTreeProvider").then(e=>{const t=e?.map(a=>a.handle);return r.deepStrictEqual(t,["1/a","1/b"]),Promise.all([l.$getChildren("testNodeWithIdTreeProvider","1/a").then(a=>{const c=a?.map(d=>d.handle);return r.deepStrictEqual(c,["1/aa","1/ab"]),Promise.all([l.$getChildren("testNodeWithIdTreeProvider","1/aa").then(d=>r.strictEqual(d?.length,0)),l.$getChildren("testNodeWithIdTreeProvider","1/ab").then(d=>r.strictEqual(d?.length,0))])}),l.$getChildren("testNodeWithIdTreeProvider","1/b").then(a=>{const c=a?.map(d=>d.handle);return r.deepStrictEqual(c,["1/ba","1/bb"]),Promise.all([l.$getChildren("testNodeWithIdTreeProvider","1/ba").then(d=>r.strictEqual(d?.length,0)),l.$getChildren("testNodeWithIdTreeProvider","1/bb").then(d=>r.strictEqual(d?.length,0))])})])})),test("construct highlights tree",()=>l.$getChildren("testNodeWithHighlightsTreeProvider").then(e=>(r.deepStrictEqual(h(e),[{handle:"1/a",label:{label:"a",highlights:[[0,2],[3,5]]},collapsibleState:s.Collapsed},{handle:"1/b",label:{label:"b",highlights:[[0,2],[3,5]]},collapsibleState:s.Collapsed}]),Promise.all([l.$getChildren("testNodeWithHighlightsTreeProvider","1/a").then(t=>{r.deepStrictEqual(h(t),[{handle:"1/aa",parentHandle:"1/a",label:{label:"aa",highlights:[[0,2],[3,5]]},collapsibleState:s.None},{handle:"1/ab",parentHandle:"1/a",label:{label:"ab",highlights:[[0,2],[3,5]]},collapsibleState:s.None}])}),l.$getChildren("testNodeWithHighlightsTreeProvider","1/b").then(t=>{r.deepStrictEqual(h(t),[{handle:"1/ba",parentHandle:"1/b",label:{label:"ba",highlights:[[0,2],[3,5]]},collapsibleState:s.None},{handle:"1/bb",parentHandle:"1/b",label:{label:"bb",highlights:[[0,2],[3,5]]},collapsibleState:s.None}])})])))),test("error is thrown if id is not unique",e=>{u.a={aa:{}},u.b={aa:{},ba:{}};let t=!1;b.add(o.onRefresh.event(()=>{l.$getChildren("testNodeWithIdTreeProvider").then(a=>{const c=a?.map(d=>d.handle);return r.deepStrictEqual(c,["1/a","1/b"]),l.$getChildren("testNodeWithIdTreeProvider","1/a").then(()=>l.$getChildren("testNodeWithIdTreeProvider","1/b")).then(()=>r.fail("Should fail with duplicate id")).catch(()=>t=!0).finally(()=>t?e():r.fail("Expected duplicate id error not thrown."))})})),n.fire(void 0)}),test("refresh root",function(e){b.add(o.onRefresh.event(t=>{r.strictEqual(void 0,t),e()})),n.fire(void 0)}),test("refresh a parent node",()=>new Promise((e,t)=>{b.add(o.onRefresh.event(a=>{r.deepStrictEqual(["0/0:b"],Object.keys(a)),r.deepStrictEqual(h(a["0/0:b"]),{handle:"0/0:b",label:{label:"b"},collapsibleState:s.Collapsed}),e(void 0)})),n.fire(i("b"))})),test("refresh a leaf node",function(e){b.add(o.onRefresh.event(t=>{r.deepStrictEqual(["0/0:b/0:bb"],Object.keys(t)),r.deepStrictEqual(h(t["0/0:b/0:bb"]),{handle:"0/0:b/0:bb",parentHandle:"0/0:b",label:{label:"bb"},collapsibleState:s.None}),e()})),n.fire(i("bb"))});async function g(e){await M({},async()=>{await new Promise(t=>{let a;a=o.onRefresh.event(()=>{a.dispose(),t()}),n.fire(i("b"))}),await new Promise(e)})}test("refresh parent and child node trigger refresh only on parent - scenario 1",async()=>g(e=>{b.add(o.onRefresh.event(t=>{r.deepStrictEqual(["0/0:b","0/0:a/0:aa"],Object.keys(t)),r.deepStrictEqual(h(t["0/0:b"]),{handle:"0/0:b",label:{label:"b"},collapsibleState:s.Collapsed}),r.deepStrictEqual(h(t["0/0:a/0:aa"]),{handle:"0/0:a/0:aa",parentHandle:"0/0:a",label:{label:"aa"},collapsibleState:s.None}),e()})),n.fire(i("b")),n.fire(i("aa")),n.fire(i("bb"))})),test("refresh parent and child node trigger refresh only on parent - scenario 2",async()=>g(e=>{b.add(o.onRefresh.event(t=>{r.deepStrictEqual(["0/0:a/0:aa","0/0:b"],Object.keys(t)),r.deepStrictEqual(h(t["0/0:b"]),{handle:"0/0:b",label:{label:"b"},collapsibleState:s.Collapsed}),r.deepStrictEqual(h(t["0/0:a/0:aa"]),{handle:"0/0:a/0:aa",parentHandle:"0/0:a",label:{label:"aa"},collapsibleState:s.None}),e()})),n.fire(i("bb")),n.fire(i("aa")),n.fire(i("b"))})),test("refresh an element for label change",function(e){f.a="aa",b.add(o.onRefresh.event(t=>{r.deepStrictEqual(["0/0:a"],Object.keys(t)),r.deepStrictEqual(h(t["0/0:a"]),{handle:"0/0:aa",label:{label:"aa"},collapsibleState:s.Collapsed}),e()})),n.fire(i("a"))}),test("refresh calls are throttled on roots",()=>g(e=>{b.add(o.onRefresh.event(t=>{r.strictEqual(void 0,t),e()})),n.fire(void 0),n.fire(void 0),n.fire(void 0),n.fire(void 0)})),test("refresh calls are throttled on elements",()=>g(e=>{b.add(o.onRefresh.event(t=>{r.deepStrictEqual(["0/0:a","0/0:b"],Object.keys(t)),e()})),n.fire(i("a")),n.fire(i("b")),n.fire(i("b")),n.fire(i("a"))})),test("refresh calls are throttled on unknown elements",()=>g(e=>{b.add(o.onRefresh.event(t=>{r.deepStrictEqual(["0/0:a","0/0:b"],Object.keys(t)),e()})),n.fire(i("a")),n.fire(i("b")),n.fire(i("g")),n.fire(i("a"))})),test("refresh calls are throttled on unknown elements and root",()=>g(e=>{b.add(o.onRefresh.event(t=>{r.strictEqual(void 0,t),e()})),n.fire(i("a")),n.fire(i("b")),n.fire(i("g")),n.fire(void 0)})),test("refresh calls are throttled on elements and root",()=>g(e=>{b.add(o.onRefresh.event(t=>{r.strictEqual(void 0,t),e()})),n.fire(i("a")),n.fire(i("b")),n.fire(void 0),n.fire(i("a"))})),test("generate unique handles from labels by escaping them",e=>{u={"a/0:b":{}},b.add(o.onRefresh.event(()=>{l.$getChildren("testNodeTreeProvider").then(t=>{r.deepStrictEqual(t?.map(a=>a.handle),["0/0:a//0:b"]),e()})})),n.fire(void 0)}),test("tree with duplicate labels",e=>{const t={adup1:"c",adup2:"g",bdup1:"e",hdup1:"i",hdup2:"l",jdup1:"k"};f.c="a",f.e="b",f.g="a",f.i="h",f.l="h",f.k="j",u[t.adup1]={},u.d={};const a={};a.h={},a[t.hdup1]={},a.j={},a[t.jdup1]={},a[t.hdup2]={},u[t.bdup1]=a,u.f={},u[t.adup2]={},b.add(o.onRefresh.event(()=>{l.$getChildren("testNodeTreeProvider").then(c=>{const d=c?.map(C=>C.handle);return r.deepStrictEqual(d,["0/0:a","0/0:b","0/1:a","0/0:d","0/1:b","0/0:f","0/2:a"]),l.$getChildren("testNodeTreeProvider","0/1:b").then(C=>{const H=C?.map(R=>R.handle);r.deepStrictEqual(H,["0/1:b/0:h","0/1:b/1:h","0/1:b/0:j","0/1:b/1:j","0/1:b/2:h"]),e()})})})),n.fire(void 0)}),test("getChildren is not returned from cache if refreshed",e=>{u={c:{}},b.add(o.onRefresh.event(()=>{l.$getChildren("testNodeTreeProvider").then(t=>{r.deepStrictEqual(t?.map(a=>a.handle),["0/0:c"]),e()})})),n.fire(void 0)}),test("getChildren is returned from cache if not refreshed",()=>(u={c:{}},l.$getChildren("testNodeTreeProvider").then(e=>{r.deepStrictEqual(e?.map(t=>t.handle),["0/0:a","0/0:b"])}))),test("reveal will throw an error if getParent is not implemented",()=>l.createTreeView("treeDataProvider",{treeDataProvider:w()},p).reveal({key:"a"}).then(()=>r.fail("Reveal should throw an error as getParent is not implemented"),()=>null)),test("reveal will return empty array for root element",()=>{const e=v.spy(o,"$reveal"),t=l.createTreeView("treeDataProvider",{treeDataProvider:m()},p),a={item:{handle:"0/0:a",label:{label:"a"},collapsibleState:s.Collapsed},parentChain:[]};return t.reveal({key:"a"}).then(()=>{r.ok(e.calledOnce),r.deepStrictEqual("treeDataProvider",e.args[0][0]),r.deepStrictEqual(a,h(e.args[0][1])),r.deepStrictEqual({select:!0,focus:!1,expand:!1},e.args[0][2])})}),test("reveal will return parents array for an element when hierarchy is not loaded",()=>{const e=v.spy(o,"$reveal"),t=l.createTreeView("treeDataProvider",{treeDataProvider:m()},p),a={item:{handle:"0/0:a/0:aa",label:{label:"aa"},collapsibleState:s.None,parentHandle:"0/0:a"},parentChain:[{handle:"0/0:a",label:{label:"a"},collapsibleState:s.Collapsed}]};return t.reveal({key:"aa"}).then(()=>{r.ok(e.calledOnce),r.deepStrictEqual("treeDataProvider",e.args[0][0]),r.deepStrictEqual(a.item,h(e.args[0][1].item)),r.deepStrictEqual(a.parentChain,e.args[0][1].parentChain.map(c=>h(c))),r.deepStrictEqual({select:!0,focus:!1,expand:!1},e.args[0][2])})}),test("reveal will return parents array for an element when hierarchy is loaded",()=>{const e=v.spy(o,"$reveal"),t=l.createTreeView("treeDataProvider",{treeDataProvider:m()},p),a={item:{handle:"0/0:a/0:aa",label:{label:"aa"},collapsibleState:s.None,parentHandle:"0/0:a"},parentChain:[{handle:"0/0:a",label:{label:"a"},collapsibleState:s.Collapsed}]};return l.$getChildren("treeDataProvider").then(()=>l.$getChildren("treeDataProvider","0/0:a")).then(()=>t.reveal({key:"aa"}).then(()=>{r.ok(e.calledOnce),r.deepStrictEqual("treeDataProvider",e.args[0][0]),r.deepStrictEqual(a.item,h(e.args[0][1].item)),r.deepStrictEqual(a.parentChain,e.args[0][1].parentChain.map(c=>h(c))),r.deepStrictEqual({select:!0,focus:!1,expand:!1},e.args[0][2])}))}),test("reveal will return parents array for deeper element with no selection",()=>{u={b:{ba:{bac:{}}}};const e=v.spy(o,"$reveal"),t=l.createTreeView("treeDataProvider",{treeDataProvider:m()},p),a={item:{handle:"0/0:b/0:ba/0:bac",label:{label:"bac"},collapsibleState:s.None,parentHandle:"0/0:b/0:ba"},parentChain:[{handle:"0/0:b",label:{label:"b"},collapsibleState:s.Collapsed},{handle:"0/0:b/0:ba",label:{label:"ba"},collapsibleState:s.Collapsed,parentHandle:"0/0:b"}]};return t.reveal({key:"bac"},{select:!1,focus:!1,expand:!1}).then(()=>{r.ok(e.calledOnce),r.deepStrictEqual("treeDataProvider",e.args[0][0]),r.deepStrictEqual(a.item,h(e.args[0][1].item)),r.deepStrictEqual(a.parentChain,e.args[0][1].parentChain.map(c=>h(c))),r.deepStrictEqual({select:!1,focus:!1,expand:!1},e.args[0][2])})}),test("reveal after first udpate",()=>{const e=v.spy(o,"$reveal"),t=l.createTreeView("treeDataProvider",{treeDataProvider:m()},p),a={item:{handle:"0/0:a/0:ac",label:{label:"ac"},collapsibleState:s.None,parentHandle:"0/0:a"},parentChain:[{handle:"0/0:a",label:{label:"a"},collapsibleState:s.Collapsed}]};return T("treeDataProvider").then(()=>(u={a:{aa:{},ac:{}},b:{ba:{},bb:{}}},n.fire(i("a")),t.reveal({key:"ac"}).then(()=>{r.ok(e.calledOnce),r.deepStrictEqual("treeDataProvider",e.args[0][0]),r.deepStrictEqual(a.item,h(e.args[0][1].item)),r.deepStrictEqual(a.parentChain,e.args[0][1].parentChain.map(c=>h(c))),r.deepStrictEqual({select:!0,focus:!1,expand:!1},e.args[0][2])})))}),test("reveal after second udpate",()=>{const e=v.spy(o,"$reveal"),t=l.createTreeView("treeDataProvider",{treeDataProvider:m()},p);return T("treeDataProvider").then(()=>g(a=>{u={a:{aa:{},ac:{}},b:{ba:{},bb:{}}},n.fire(i("a")),u={a:{aa:{},ac:{}},b:{ba:{},bc:{}}},n.fire(i("b")),a()}).then(()=>t.reveal({key:"bc"}).then(()=>{r.ok(e.calledOnce),r.deepStrictEqual("treeDataProvider",e.args[0][0]),r.deepStrictEqual({handle:"0/0:b/0:bc",label:{label:"bc"},collapsibleState:s.None,parentHandle:"0/0:b"},h(e.args[0][1].item)),r.deepStrictEqual([{handle:"0/0:b",label:{label:"b"},collapsibleState:s.Collapsed}],e.args[0][1].parentChain.map(a=>h(a))),r.deepStrictEqual({select:!0,focus:!1,expand:!1},e.args[0][2])})))});function T(e,t){return l.$getChildren(e,t).then(a=>a?.map(c=>T(e,c.handle))).then(()=>null)}function h(e){if(Array.isArray(e))return e.map(t=>h(t));if(typeof e=="object"){const t={};for(const a of Object.keys(e))e[a]!==void 0&&(t[a]=h(e[a]));return t}return e}function w(){return{getChildren:e=>P(e?e.key:void 0).map(t=>i(t)),getTreeItem:e=>S(e.key),onDidChangeTreeData:n.event}}function m(){return{getChildren:e=>P(e?e.key:void 0).map(t=>i(t)),getTreeItem:e=>S(e.key),getParent:({key:e})=>{const t=e.substring(0,e.length-1);return t?new I(t):void 0},onDidChangeTreeData:n.event}}function x(){return{getChildren:e=>P(e?e.key:void 0).map(t=>i(t)),getTreeItem:e=>{const t=S(e.key);return t.id=e.key,t},onDidChangeTreeData:E.event}}function V(){return{getChildren:e=>P(e?e.key:void 0).map(t=>i(t)),getTreeItem:e=>{const t=S(e.key,[[0,2],[3,5]]);return t.id=e.key,t},onDidChangeTreeData:E.event}}function D(e){let t=u;for(let a=0;a<e.length;a++)if(t=t[e.substring(0,a+1)],!t)return null;return t}function P(e){if(!e)return Object.keys(u);const t=D(e);return t?Object.keys(t):[]}function S(e,t){const a=D(e);return{label:{label:f[e]||e,highlights:t},collapsibleState:a&&Object.keys(a).length?s.Collapsed:s.None}}function i(e){return y[e]||(y[e]=new I(e)),y[e]}class I{constructor(t){this.key=t}}});
