import t from"assert";import{URI as a}from"../../../../base/common/uri.js";import{DiagnosticCollection as w,ExtHostDiagnostics as b}from"../../common/extHostDiagnostics.js";import{Diagnostic as c,DiagnosticSeverity as I,Range as r,DiagnosticRelatedInformation as x,Location as M}from"../../common/extHostTypes.js";import"../../common/extHost.protocol.js";import{MarkerSeverity as q}from"../../../../platform/markers/common/markers.js";import{mock as E}from"../../../../base/test/common/mock.js";import{Emitter as m,Event as f}from"../../../../base/common/event.js";import{NullLogService as D}from"../../../../platform/log/common/log.js";import{nullExtensionDescription as v}from"../../../services/extensions/common/extensions.js";import{ExtUri as C,extUri as u}from"../../../../base/common/resources.js";import"../../common/extHostFileSystemInfo.js";import{runWithFakedTimers as U}from"../../../../base/test/common/timeTravelScheduler.js";import"../../common/extHostDocumentsAndEditors.js";import{ensureNoDisposablesAreLeakedInTestSuite as S}from"../../../../base/test/common/utils.js";suite("ExtHostDiagnostics",()=>{class d extends E(){$changeMany(s,n){}$clear(s){}}const y=new class extends E(){extUri=u},p=e=>{},k=S();test("disposeCheck",()=>{const e=new w("test","test",100,100,p,u,new d,new m);e.dispose(),e.dispose(),t.throws(()=>e.name),t.throws(()=>e.clear()),t.throws(()=>e.delete(a.parse("aa:bb"))),t.throws(()=>e.forEach(()=>{})),t.throws(()=>e.get(a.parse("aa:bb"))),t.throws(()=>e.has(a.parse("aa:bb"))),t.throws(()=>e.set(a.parse("aa:bb"),[])),t.throws(()=>e.set(a.parse("aa:bb"),void 0))}),test("diagnostic collection, forEach, clear, has",function(){let e=new w("test","test",100,100,p,u,new d,new m);t.strictEqual(e.name,"test"),e.dispose(),t.throws(()=>e.name);let s=0;e=new w("test","test",100,100,p,u,new d,new m),e.forEach(()=>s++),t.strictEqual(s,0),e.set(a.parse("foo:bar"),[new c(new r(0,0,1,1),"message-1"),new c(new r(0,0,1,1),"message-2")]),e.forEach(()=>s++),t.strictEqual(s,1),s=0,e.clear(),e.forEach(()=>s++),t.strictEqual(s,0),e.set(a.parse("foo:bar1"),[new c(new r(0,0,1,1),"message-1"),new c(new r(0,0,1,1),"message-2")]),e.set(a.parse("foo:bar2"),[new c(new r(0,0,1,1),"message-1"),new c(new r(0,0,1,1),"message-2")]),e.forEach(()=>s++),t.strictEqual(s,2),t.ok(e.has(a.parse("foo:bar1"))),t.ok(e.has(a.parse("foo:bar2"))),t.ok(!e.has(a.parse("foo:bar3"))),e.delete(a.parse("foo:bar1")),t.ok(!e.has(a.parse("foo:bar1"))),e.dispose()}),test("diagnostic collection, immutable read",function(){const e=new w("test","test",100,100,p,u,new d,new m);e.set(a.parse("foo:bar"),[new c(new r(0,0,1,1),"message-1"),new c(new r(0,0,1,1),"message-2")]);let s=e.get(a.parse("foo:bar"));t.throws(()=>s.length=0),t.throws(()=>s.pop()),t.throws(()=>s[0]=new c(new r(0,0,0,0),"evil")),e.forEach((n,i)=>{t.throws(()=>i.length=0),t.throws(()=>i.pop()),t.throws(()=>i[0]=new c(new r(0,0,0,0),"evil"))}),s=e.get(a.parse("foo:bar")),t.strictEqual(s.length,2),e.dispose()}),test("diagnostics collection, set with dupliclated tuples",function(){const e=new w("test","test",100,100,p,u,new d,new m),s=a.parse("sc:hightower");e.set([[s,[new c(new r(0,0,0,1),"message-1")]],[a.parse("some:thing"),[new c(new r(0,0,1,1),"something")]],[s,[new c(new r(0,0,0,1),"message-2")]]]);let n=e.get(s);t.strictEqual(n.length,2);let[i,o]=n;t.strictEqual(i.message,"message-1"),t.strictEqual(o.message,"message-2"),e.delete(s),t.ok(!e.has(s)),e.set([[s,[new c(new r(0,0,0,1),"message-1")]],[a.parse("some:thing"),[new c(new r(0,0,1,1),"something")]],[s,void 0]]),t.ok(!e.has(s)),e.delete(s),t.ok(!e.has(s)),e.set([[s,[new c(new r(0,0,0,1),"message-1")]],[a.parse("some:thing"),[new c(new r(0,0,1,1),"something")]],[s,void 0],[s,[new c(new r(0,0,0,1),"message-2")]],[s,[new c(new r(0,0,0,1),"message-3")]]]),n=e.get(s),t.strictEqual(n.length,2),[i,o]=n,t.strictEqual(i.message,"message-2"),t.strictEqual(o.message,"message-3"),e.dispose()}),test("diagnostics collection, set tuple overrides, #11547",function(){let e;const s=new w("test","test",100,100,p,u,new class extends d{$changeMany(g,l){return e=l,super.$changeMany(g,l)}},new m),n=a.parse("sc:hightower");s.set([[n,[new c(new r(0,0,1,1),"error")]]]),t.strictEqual(s.get(n).length,1),t.strictEqual(s.get(n)[0].message,"error"),t.strictEqual(e.length,1);const[[,i]]=e;t.strictEqual(i.length,1),t.strictEqual(i[0].message,"error"),e=void 0,s.set([[n,[new c(new r(0,0,1,1),"warning")]]]),t.strictEqual(s.get(n).length,1),t.strictEqual(s.get(n)[0].message,"warning"),t.strictEqual(e.length,1);const[[,o]]=e;t.strictEqual(o.length,1),t.strictEqual(o[0].message,"warning"),e=void 0}),test("do send message when not making a change",function(){let e=0,s=0;const n=new m;k.add(n.event(l=>s+=1));const i=new w("test","test",100,100,p,u,new class extends d{$changeMany(){e+=1}},n),o=a.parse("sc:hightower"),g=new c(new r(0,0,0,1),"ffff");i.set(o,[g]),t.strictEqual(e,1),t.strictEqual(s,1),i.set(o,[g]),t.strictEqual(e,2),t.strictEqual(s,2)}),test("diagnostics collection, tuples and undefined (small array), #15585",function(){const e=new w("test","test",100,100,p,u,new d,new m),s=a.parse("sc:hightower"),n=a.parse("sc:nomad"),i=new c(new r(0,0,0,1),"ffff");e.set([[s,[i,i,i]],[s,void 0],[s,[i]],[n,[i,i]],[n,void 0],[n,[i]]]),t.strictEqual(e.get(s).length,1),t.strictEqual(e.get(n).length,1)}),test("diagnostics collection, tuples and undefined (large array), #15585",function(){const e=new w("test","test",100,100,p,u,new d,new m),s=[];for(let n=0;n<500;n++){const i=a.parse("sc:hightower#"+n),o=new c(new r(0,0,0,1),n.toString());s.push([i,[o,o,o]]),s.push([i,void 0]),s.push([i,[o]])}e.set(s);for(let n=0;n<500;n++){const i=a.parse("sc:hightower#"+n);t.strictEqual(e.has(i),!0),t.strictEqual(e.get(i).length,1)}}),test("diagnostic capping (max per file)",function(){let e;const s=new w("test","test",100,250,p,u,new class extends d{$changeMany(o,g){return e=g,super.$changeMany(o,g)}},new m),n=a.parse("aa:bb"),i=[];for(let o=0;o<500;o++)i.push(new c(new r(o,0,o+1,0),`error#${o}`,o<300?I.Warning:I.Error));s.set(n,i),t.strictEqual(s.get(n).length,500),t.strictEqual(e.length,1),t.strictEqual(e[0][1].length,251),t.strictEqual(e[0][1][0].severity,q.Error),t.strictEqual(e[0][1][200].severity,q.Warning),t.strictEqual(e[0][1][250].severity,q.Info)}),test("diagnostic capping (max files)",function(){let e;const s=new w("test","test",2,1,p,u,new class extends d{$changeMany(i,o){return e=o,super.$changeMany(i,o)}},new m),n=new c(new r(0,0,1,1),"Hello");s.set([[a.parse("aa:bb1"),[n]],[a.parse("aa:bb2"),[n]],[a.parse("aa:bb3"),[n]],[a.parse("aa:bb4"),[n]]]),t.strictEqual(e.length,3)}),test("diagnostic eventing",async function(){const e=new m,s=new w("ddd","test",100,100,p,u,new d,e),n=new c(new r(1,1,2,3),"diag1"),i=new c(new r(1,1,2,3),"diag2"),o=new c(new r(1,1,2,3),"diag3");let g=f.toPromise(e.event).then(l=>{t.strictEqual(l.length,1),t.strictEqual(l[0].toString(),"aa:bb"),t.ok(a.isUri(l[0]))});s.set(a.parse("aa:bb"),[]),await g,g=f.toPromise(e.event).then(l=>{t.strictEqual(l.length,2),t.ok(a.isUri(l[0])),t.ok(a.isUri(l[1])),t.strictEqual(l[0].toString(),"aa:bb"),t.strictEqual(l[1].toString(),"aa:cc")}),s.set([[a.parse("aa:bb"),[n]],[a.parse("aa:cc"),[i,o]]]),await g,g=f.toPromise(e.event).then(l=>{t.strictEqual(l.length,2),t.ok(a.isUri(l[0])),t.ok(a.isUri(l[1]))}),s.clear(),await g}),test("vscode.languages.onDidChangeDiagnostics Does Not Provide Document URI #49582",async function(){const e=new m,s=new w("ddd","test",100,100,p,u,new d,e),n=new c(new r(1,1,2,3),"diag1");s.set(a.parse("aa:bb"),[n]);let i=f.toPromise(e.event).then(o=>{t.strictEqual(o[0].toString(),"aa:bb")});s.delete(a.parse("aa:bb")),await i,s.set(a.parse("aa:bb"),[n]),i=f.toPromise(e.event).then(o=>{t.strictEqual(o[0].toString(),"aa:bb")}),s.set(a.parse("aa:bb"),void 0),await i}),test("diagnostics with related information",function(e){const s=new w("ddd","test",100,100,p,u,new class extends d{$changeMany(i,o){const[[,g]]=o;t.strictEqual(o.length,1),t.strictEqual(g.length,1);const[l]=g;t.strictEqual(l.relatedInformation.length,2),t.strictEqual(l.relatedInformation[0].message,"more1"),t.strictEqual(l.relatedInformation[1].message,"more2"),e()}},new m),n=new c(new r(0,0,1,1),"Foo");n.relatedInformation=[new x(new M(a.parse("cc:dd"),new r(0,0,0,0)),"more1"),new x(new M(a.parse("cc:ee"),new r(0,0,0,0)),"more2")],s.set(a.parse("aa:bb"),[n])}),test("vscode.languages.getDiagnostics appears to return old diagnostics in some circumstances #54359",function(){const e=[],s=new b(new class{getProxy(o){return new class{$clear(l){e.push(l)}}}set(){return null}dispose(){}assertRegistered(){}drain(){}},new D,y,new class extends E(){getDocument(){}}),n=s.createDiagnosticCollection(v.identifier,"foo"),i=s.createDiagnosticCollection(v.identifier,"foo");n.clear(),i.clear(),t.strictEqual(e.length,2),t.strictEqual(e[0],"foo"),t.strictEqual(e[1],"foo0")}),test("Error updating diagnostics from extension #60394",function(){let e=0;const s=new w("ddd","test",100,100,p,u,new class extends d{$changeMany(g,l){e+=1}},new m),n=[],i=new c(new r(0,0,1,1),"Foo"),o=new c(new r(0,0,1,1),"Bar");n.push(i,o),s.set(a.parse("test:me"),n),t.strictEqual(e,1),s.set(a.parse("test:me"),n),t.strictEqual(e,2),n.push(o),s.set(a.parse("test:me"),n),t.strictEqual(e,3)}),test("Version id is set whenever possible",function(){const e=[],s=new w("ddd","test",100,100,l=>7,u,new class extends d{$changeMany(l,h){e.push(...h)}},new m),n=[],i=new c(new r(0,0,1,1),"Foo"),o=new c(new r(0,0,1,1),"Bar");n.push(i,o),s.set(a.parse("test:one"),n),s.set(a.parse("test:two"),[i]),s.set(a.parse("test:three"),[o]);const g=e.map(l=>l[1].map(h=>h.modelVersionId)).flat();t.deepStrictEqual(g,[7,7,7,7])}),test("Diagnostics created by tasks aren't accessible to extensions #47292",async function(){return U({},async function(){const e=new b(new class{getProxy(g){return{}}set(){return null}dispose(){}assertRegistered(){}drain(){}},new D,y,new class extends E(){getDocument(){}}),s=a.parse("foo:bar"),n=[{message:"message",startLineNumber:1,startColumn:1,endLineNumber:1,endColumn:1,severity:q.Info}],i=f.toPromise(e.onDidChangeDiagnostics);e.$acceptMarkersChange([[s,n]]),await i,t.strictEqual(e.getDiagnostics(s).length,1);const o=f.toPromise(e.onDidChangeDiagnostics);e.$acceptMarkersChange([[s,[]]]),await o,t.strictEqual(e.getDiagnostics(s).length,0)})}),test("languages.getDiagnostics doesn't handle case insensitivity correctly #128198",function(){const e=new b(new class{getProxy(h){return new d}set(){return null}dispose(){}assertRegistered(){}drain(){}},new D,new class extends E(){extUri=new C(h=>h.scheme==="insensitive")},new class extends E(){getDocument(){}}),s=e.createDiagnosticCollection(v.identifier),n=a.from({scheme:"foo",path:"/SOME/path"}),i=n.with({path:n.path.toUpperCase()}),o=a.from({scheme:"insensitive",path:"/SOME/path"}),g=o.with({path:o.path.toUpperCase()});s.set(n,[new c(new r(0,0,0,0),"sensitive")]),s.set(o,[new c(new r(0,0,0,0),"insensitive")]),t.strictEqual(s.get(n)?.length,1),t.strictEqual(s.get(i)?.length,0),t.strictEqual(s.get(o)?.length,1),t.strictEqual(s.get(g)?.length,1),t.strictEqual(e.getDiagnostics(n)?.length,1),t.strictEqual(e.getDiagnostics(i)?.length,0),t.strictEqual(e.getDiagnostics(o)?.length,1),t.strictEqual(e.getDiagnostics(g)?.length,1);const l=[];s.forEach(h=>l.push(h)),t.strictEqual(l.length,2),t.strictEqual(l[0].toString(),n.toString()),t.strictEqual(l[1].toString(),o.toString())})});
