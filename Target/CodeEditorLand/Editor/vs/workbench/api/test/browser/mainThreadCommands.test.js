import e from"assert";import{MainThreadCommands as i}from"../../browser/mainThreadCommands.js";import{CommandsRegistry as o}from"../../../../platform/commands/common/commands.js";import{SingleProxyRPCProtocol as m}from"../common/testRPCProtocol.js";import"../../../services/extensions/common/extensions.js";import{mock as a}from"../../../../base/test/common/mock.js";import{ensureNoDisposablesAreLeakedInTestSuite as d}from"../../../../base/test/common/utils.js";suite("MainThreadCommands",function(){d(),test("dispose on unregister",function(){const n=new i(m(null),void 0,new class extends a(){});e.strictEqual(o.getCommand("foo"),void 0),n.$registerCommand("foo"),e.ok(o.getCommand("foo")),n.$unregisterCommand("foo"),e.strictEqual(o.getCommand("foo"),void 0),n.dispose()}),test("unregister all on dispose",function(){const n=new i(m(null),void 0,new class extends a(){});e.strictEqual(o.getCommand("foo"),void 0),n.$registerCommand("foo"),n.$registerCommand("bar"),e.ok(o.getCommand("foo")),e.ok(o.getCommand("bar")),n.dispose(),e.strictEqual(o.getCommand("foo"),void 0),e.strictEqual(o.getCommand("bar"),void 0)}),test("activate and throw when needed",async function(){const n=[],t=[],s=new i(m(null),new class extends a(){executeCommand(r){return t.push(r),Promise.resolve(void 0)}},new class extends a(){activateByEvent(r){return n.push(r),Promise.resolve()}});try{n.length=0,await s.$executeCommand("bazz",[1,2,{n:3}],!0),e.ok(!1)}catch(r){e.deepStrictEqual(n,["onCommand:bazz"]),e.strictEqual(r.message,"$executeCommand:retry")}t.length=0,await s.$executeCommand("bazz",[],!0),e.deepStrictEqual(t,["bazz"]),t.length=0,await s.$executeCommand("bazz",[1,2,!0],!1),e.deepStrictEqual(t,["bazz"]),s.dispose()})});
