var x=Object.defineProperty;var O=Object.getOwnPropertyDescriptor;var c=(a,n,e,t)=>{for(var r=t>1?void 0:t?O(n,e):n,i=a.length-1,o;i>=0;i--)(o=a[i])&&(r=(t?o(n,e,r):o(r))||r);return t&&r&&x(n,e,r),r},s=(a,n)=>(e,t)=>n(e,t,a);import{Action as f}from"../../../base/common/actions.js";import{isCancellationError as v}from"../../../base/common/errors.js";import{Disposable as S}from"../../../base/common/lifecycle.js";import{Schemas as m}from"../../../base/common/network.js";import"../../../base/common/uri.js";import{localize as h}from"../../../nls.js";import"../../../platform/extensions/common/extensions.js";import{INotificationService as g,Severity as E}from"../../../platform/notification/common/notification.js";import{IOpenerService as u}from"../../../platform/opener/common/opener.js";import{IStorageService as y}from"../../../platform/storage/common/storage.js";import{ExtHostContext as I,MainContext as U}from"../common/extHost.protocol.js";import{defaultExternalUriOpenerId as b}from"../../contrib/externalUriOpener/common/configuration.js";import{ContributedExternalUriOpenersStore as w}from"../../contrib/externalUriOpener/common/contributedOpeners.js";import{IExternalUriOpenerService as _}from"../../contrib/externalUriOpener/common/externalUriOpenerService.js";import{IExtensionService as C}from"../../services/extensions/common/extensions.js";import{extHostNamedCustomer as H}from"../../services/extensions/common/extHostCustomers.js";let p=class extends S{constructor(e,t,r,i,o,l){super();this.extensionService=i;this.openerService=o;this.notificationService=l;this.proxy=e.getProxy(I.ExtHostUriOpeners),this._register(r.registerExternalOpenerProvider(this)),this._contributedExternalUriOpenersStore=this._register(new w(t,i))}proxy;_registeredOpeners=new Map;_contributedExternalUriOpenersStore;async*getOpeners(e){if(!(e.scheme!==m.http&&e.scheme!==m.https)){await this.extensionService.activateByEvent(`onOpenExternalUri:${e.scheme}`);for(const[t,r]of this._registeredOpeners)r.schemes.has(e.scheme)&&(yield this.createOpener(t,r))}}createOpener(e,t){return{id:e,label:t.label,canOpen:(r,i)=>this.proxy.$canOpenUri(e,r,i),openExternalUri:async(r,i,o)=>{try{await this.proxy.$openUri(e,{resolvedUri:r,sourceUri:i.sourceUri},o)}catch(l){if(!v(l)){const d=new f("default",h("openerFailedUseDefault","Open using default opener"),void 0,void 0,async()=>{await this.openerService.open(r,{allowTunneling:!1,allowContributedOpeners:b})});d.tooltip=r.toString(),this.notificationService.notify({severity:E.Error,message:h({key:"openerFailedMessage",comment:["{0} is the id of the opener. {1} is the url being opened."]},"Could not open uri with '{0}': {1}",e,l.toString()),actions:{primary:[d]}})}}return!0}}}async $registerUriOpener(e,t,r,i){if(this._registeredOpeners.has(e))throw new Error(`Opener with id '${e}' already registered`);this._registeredOpeners.set(e,{schemes:new Set(t),label:i,extensionId:r}),this._contributedExternalUriOpenersStore.didRegisterOpener(e,r.value)}async $unregisterUriOpener(e){this._registeredOpeners.delete(e),this._contributedExternalUriOpenersStore.delete(e)}dispose(){super.dispose(),this._registeredOpeners.clear()}};p=c([H(U.MainThreadUriOpeners),s(1,y),s(2,_),s(3,C),s(4,u),s(5,g)],p);export{p as MainThreadUriOpeners};
