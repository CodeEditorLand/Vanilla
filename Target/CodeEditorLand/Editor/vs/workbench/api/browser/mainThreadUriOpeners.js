var f=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var d=(a,n,e,t)=>{for(var r=t>1?void 0:t?h(n,e):n,i=a.length-1,o;i>=0;i--)(o=a[i])&&(r=(t?o(n,e,r):o(r))||r);return t&&r&&f(n,e,r),r},s=(a,n)=>(e,t)=>n(e,t,a);import{Action as O}from"../../../base/common/actions.js";import{isCancellationError as y}from"../../../base/common/errors.js";import{Disposable as v}from"../../../base/common/lifecycle.js";import{Schemas as m}from"../../../base/common/network.js";import{localize as x}from"../../../nls.js";import{INotificationService as S,Severity as g}from"../../../platform/notification/common/notification.js";import{IOpenerService as u}from"../../../platform/opener/common/opener.js";import{IStorageService as E}from"../../../platform/storage/common/storage.js";import{defaultExternalUriOpenerId as I}from"../../contrib/externalUriOpener/common/configuration.js";import{ContributedExternalUriOpenersStore as U}from"../../contrib/externalUriOpener/common/contributedOpeners.js";import{IExternalUriOpenerService as b}from"../../contrib/externalUriOpener/common/externalUriOpenerService.js";import{extHostNamedCustomer as w}from"../../services/extensions/common/extHostCustomers.js";import{IExtensionService as _}from"../../services/extensions/common/extensions.js";import{ExtHostContext as C,MainContext as H}from"../common/extHost.protocol.js";let p=class extends v{constructor(e,t,r,i,o,l){super();this.extensionService=i;this.openerService=o;this.notificationService=l;this.proxy=e.getProxy(C.ExtHostUriOpeners),this._register(r.registerExternalOpenerProvider(this)),this._contributedExternalUriOpenersStore=this._register(new U(t,i))}proxy;_registeredOpeners=new Map;_contributedExternalUriOpenersStore;async*getOpeners(e){if(!(e.scheme!==m.http&&e.scheme!==m.https)){await this.extensionService.activateByEvent(`onOpenExternalUri:${e.scheme}`);for(const[t,r]of this._registeredOpeners)r.schemes.has(e.scheme)&&(yield this.createOpener(t,r))}}createOpener(e,t){return{id:e,label:t.label,canOpen:(r,i)=>this.proxy.$canOpenUri(e,r,i),openExternalUri:async(r,i,o)=>{try{await this.proxy.$openUri(e,{resolvedUri:r,sourceUri:i.sourceUri},o)}catch(l){if(!y(l)){const c=new O("default",x("openerFailedUseDefault","Open using default opener"),void 0,void 0,async()=>{await this.openerService.open(r,{allowTunneling:!1,allowContributedOpeners:I})});c.tooltip=r.toString(),this.notificationService.notify({severity:g.Error,message:x({key:"openerFailedMessage",comment:["{0} is the id of the opener. {1} is the url being opened."]},"Could not open uri with '{0}': {1}",e,l.toString()),actions:{primary:[c]}})}}return!0}}}async $registerUriOpener(e,t,r,i){if(this._registeredOpeners.has(e))throw new Error(`Opener with id '${e}' already registered`);this._registeredOpeners.set(e,{schemes:new Set(t),label:i,extensionId:r}),this._contributedExternalUriOpenersStore.didRegisterOpener(e,r.value)}async $unregisterUriOpener(e){this._registeredOpeners.delete(e),this._contributedExternalUriOpenersStore.delete(e)}dispose(){super.dispose(),this._registeredOpeners.clear()}};p=d([w(H.MainThreadUriOpeners),s(1,E),s(2,b),s(3,_),s(4,u),s(5,S)],p);export{p as MainThreadUriOpeners};
