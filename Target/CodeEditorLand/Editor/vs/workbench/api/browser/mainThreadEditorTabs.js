var E=Object.defineProperty;var D=Object.getOwnPropertyDescriptor;var g=(b,e,t,i)=>{for(var r=i>1?void 0:i?D(e,t):e,o=b.length-1,n;o>=0;o--)(n=b[o])&&(r=(i?n(e,t,r):n(r))||r);return i&&r&&E(e,t,r),r},l=(b,e)=>(t,i)=>e(t,i,b);import{Event as k}from"../../../../vs/base/common/event.js";import{DisposableMap as G,DisposableStore as S}from"../../../../vs/base/common/lifecycle.js";import{isEqual as y}from"../../../../vs/base/common/resources.js";import{URI as x}from"../../../../vs/base/common/uri.js";import{IConfigurationService as M}from"../../../../vs/platform/configuration/common/configuration.js";import{ILogService as L}from"../../../../vs/platform/log/common/log.js";import{ExtHostContext as A,MainContext as O,TabInputKind as s,TabModelOperationKind as c}from"../../../../vs/workbench/api/common/extHost.protocol.js";import{EditorResourceAccessor as C,GroupModelChangeKind as p,SideBySideEditor as w}from"../../../../vs/workbench/common/editor.js";import{DiffEditorInput as v}from"../../../../vs/workbench/common/editor/diffEditorInput.js";import{isGroupEditorMoveEvent as P}from"../../../../vs/workbench/common/editor/editorGroupModel.js";import"../../../../vs/workbench/common/editor/editorInput.js";import{SideBySideEditorInput as R}from"../../../../vs/workbench/common/editor/sideBySideEditorInput.js";import{AbstractTextResourceEditorInput as h}from"../../../../vs/workbench/common/editor/textResourceEditorInput.js";import{ChatEditorInput as $}from"../../../../vs/workbench/contrib/chat/browser/chatEditorInput.js";import{CustomEditorInput as U}from"../../../../vs/workbench/contrib/customEditor/browser/customEditorInput.js";import{InteractiveEditorInput as B}from"../../../../vs/workbench/contrib/interactive/browser/interactiveEditorInput.js";import{MergeEditorInput as N}from"../../../../vs/workbench/contrib/mergeEditor/browser/mergeEditorInput.js";import{MultiDiffEditorInput as I}from"../../../../vs/workbench/contrib/multiDiffEditor/browser/multiDiffEditorInput.js";import{NotebookEditorInput as T}from"../../../../vs/workbench/contrib/notebook/common/notebookEditorInput.js";import{TerminalEditorInput as H}from"../../../../vs/workbench/contrib/terminal/browser/terminalEditorInput.js";import{WebviewInput as j}from"../../../../vs/workbench/contrib/webviewPanel/browser/webviewEditorInput.js";import{columnToEditorGroup as K,editorGroupToColumn as V}from"../../../../vs/workbench/services/editor/common/editorGroupColumn.js";import{GroupDirection as F,IEditorGroupsService as W,preferredSideBySideGroupDirection as Y}from"../../../../vs/workbench/services/editor/common/editorGroupsService.js";import{IEditorService as q,SIDE_GROUP as z}from"../../../../vs/workbench/services/editor/common/editorService.js";import{extHostNamedCustomer as J}from"../../../../vs/workbench/services/extensions/common/extHostCustomers.js";let _=class{constructor(e,t,i,r,o){this._editorGroupsService=t;this._configurationService=i;this._logService=r;this._proxy=e.getProxy(A.ExtHostEditorTabs),this._dispoables.add(o.onDidEditorsChange(n=>{try{this._updateTabsModel(n)}catch{this._logService.error("Failed to update model, rebuilding"),this._createTabsModel()}})),this._dispoables.add(this._multiDiffEditorInputListeners),this._dispoables.add(this._editorGroupsService.onDidAddGroup(()=>this._createTabsModel())),this._dispoables.add(this._editorGroupsService.onDidRemoveGroup(()=>this._createTabsModel())),this._editorGroupsService.whenReady.then(()=>this._createTabsModel())}_dispoables=new S;_proxy;_tabGroupModel=[];_groupLookup=new Map;_tabInfoLookup=new Map;_multiDiffEditorInputListeners=new G;dispose(){this._groupLookup.clear(),this._tabInfoLookup.clear(),this._dispoables.dispose()}_buildTabObject(e,t,i){const r=t.editorId;return{id:this._generateTabId(t,e.id),label:t.getName(),editorId:r,input:this._editorInputToDto(t),isPinned:e.isSticky(i),isPreview:!e.isPinned(i),isActive:e.isActive(t),isDirty:t.isDirty()}}_editorInputToDto(e){if(e instanceof N)return{kind:s.TextMergeInput,base:e.base,input1:e.input1.uri,input2:e.input2.uri,result:e.resource};if(e instanceof h)return{kind:s.TextInput,uri:e.resource};if(e instanceof R&&!(e instanceof v)){const t=e.primary.resource,i=e.secondary.resource;return e.primary instanceof h&&e.secondary instanceof h&&y(t,i)&&t&&i?{kind:s.TextInput,uri:t}:{kind:s.UnknownInput}}if(e instanceof T)return{kind:s.NotebookInput,notebookType:e.viewType,uri:e.resource};if(e instanceof U)return{kind:s.CustomEditorInput,viewType:e.viewType,uri:e.resource};if(e instanceof j)return{kind:s.WebviewEditorInput,viewType:e.viewType};if(e instanceof H)return{kind:s.TerminalEditorInput};if(e instanceof v){if(e.modified instanceof h&&e.original instanceof h)return{kind:s.TextDiffInput,modified:e.modified.resource,original:e.original.resource};if(e.modified instanceof T&&e.original instanceof T)return{kind:s.NotebookDiffInput,notebookType:e.original.viewType,modified:e.modified.resource,original:e.original.resource}}if(e instanceof B)return{kind:s.InteractiveEditorInput,uri:e.resource,inputBoxUri:e.inputResource};if(e instanceof $)return{kind:s.ChatEditorInput};if(e instanceof I){const t=[];for(const i of e?.resources.get()??[])i.originalUri&&i.modifiedUri&&t.push({kind:s.TextDiffInput,original:i.originalUri,modified:i.modifiedUri});return{kind:s.MultiDiffEditorInput,diffEditors:t}}return{kind:s.UnknownInput}}_generateTabId(e,t){let i;const r=C.getCanonicalUri(e,{supportSideBySide:w.BOTH});return r instanceof x?i=r.toString():i=`${r?.primary?.toString()}-${r?.secondary?.toString()}`,`${t}~${e.editorId}-${e.typeId}-${i} `}_onDidGroupActivate(){const e=this._editorGroupsService.activeGroup.id,t=this._groupLookup.get(e);t&&(t.isActive=!0,this._proxy.$acceptTabGroupUpdate(t))}_onDidTabLabelChange(e,t,i){const r=this._generateTabId(t,e),o=this._tabInfoLookup.get(r);o?(o.tab.label=t.getName(),this._proxy.$acceptTabOperation({groupId:e,index:i,tabDto:o.tab,kind:c.TAB_UPDATE})):(this._logService.error("Invalid model for label change, rebuilding"),this._createTabsModel())}_onDidTabOpen(e,t,i){const r=this._editorGroupsService.getGroup(e),o=this._groupLookup.get(e)!==void 0;if(!r||!o){this._createTabsModel();return}const n=this._groupLookup.get(e)?.tabs;if(!n)return;const a=this._buildTabObject(r,t,i);n.splice(i,0,a);const d=this._generateTabId(t,e);this._tabInfoLookup.set(d,{group:r,editorInput:t,tab:a}),t instanceof I&&this._multiDiffEditorInputListeners.set(t,k.fromObservableLight(t.resources)(()=>{const u=this._tabInfoLookup.get(d);u&&(u.tab=this._buildTabObject(r,t,i),this._proxy.$acceptTabOperation({groupId:e,index:i,tabDto:u.tab,kind:c.TAB_UPDATE}))})),this._proxy.$acceptTabOperation({groupId:e,index:i,tabDto:a,kind:c.TAB_OPEN})}_onDidTabClose(e,t){const i=this._editorGroupsService.getGroup(e),r=this._groupLookup.get(e)?.tabs;if(!i||!r){this._createTabsModel();return}const o=r.splice(t,1);o.length!==0&&(this._tabInfoLookup.delete(o[0]?.id??""),o[0]?.input instanceof I&&this._multiDiffEditorInputListeners.deleteAndDispose(o[0]?.input),this._proxy.$acceptTabOperation({groupId:e,index:t,tabDto:o[0],kind:c.TAB_CLOSE}))}_onDidTabActiveChange(e,t){const i=this._groupLookup.get(e)?.tabs;if(!i)return;const r=i[t];r.isActive=!0,this._proxy.$acceptTabOperation({groupId:e,index:t,tabDto:r,kind:c.TAB_UPDATE})}_onDidTabDirty(e,t,i){const r=this._generateTabId(i,e),o=this._tabInfoLookup.get(r);if(!o){this._logService.error("Invalid model for dirty change, rebuilding"),this._createTabsModel();return}o.tab.isDirty=i.isDirty(),this._proxy.$acceptTabOperation({groupId:e,index:t,tabDto:o.tab,kind:c.TAB_UPDATE})}_onDidTabPinChange(e,t,i){const r=this._generateTabId(i,e),o=this._tabInfoLookup.get(r),n=o?.group,a=o?.tab;if(!n||!a){this._logService.error("Invalid model for sticky change, rebuilding"),this._createTabsModel();return}a.isPinned=n.isSticky(t),this._proxy.$acceptTabOperation({groupId:e,index:t,tabDto:a,kind:c.TAB_UPDATE})}_onDidTabPreviewChange(e,t,i){const r=this._generateTabId(i,e),o=this._tabInfoLookup.get(r),n=o?.group,a=o?.tab;if(!n||!a){this._logService.error("Invalid model for sticky change, rebuilding"),this._createTabsModel();return}a.isPreview=!n.isPinned(t),this._proxy.$acceptTabOperation({kind:c.TAB_UPDATE,groupId:e,tabDto:a,index:t})}_onDidTabMove(e,t,i,r){const o=this._groupLookup.get(e)?.tabs;if(!o){this._logService.error("Invalid model for move change, rebuilding"),this._createTabsModel();return}const n=o.splice(i,1);n.length!==0&&(o.splice(t,0,n[0]),this._proxy.$acceptTabOperation({kind:c.TAB_MOVE,groupId:e,tabDto:n[0],index:t,oldIndex:i}))}_createTabsModel(){if(this._editorGroupsService.groups.length===0)return;this._tabGroupModel=[],this._groupLookup.clear(),this._tabInfoLookup.clear();let e=[];for(const t of this._editorGroupsService.groups){const i={groupId:t.id,isActive:t.id===this._editorGroupsService.activeGroup.id,viewColumn:V(this._editorGroupsService,t),tabs:[]};t.editors.forEach((r,o)=>{const n=this._buildTabObject(t,r,o);e.push(n),this._tabInfoLookup.set(this._generateTabId(r,t.id),{group:t,tab:n,editorInput:r})}),i.tabs=e,this._tabGroupModel.push(i),this._groupLookup.set(t.id,i),e=[]}this._proxy.$acceptEditorTabModel(this._tabGroupModel)}_updateTabsModel(e){const t=e.event,i=e.groupId;switch(t.kind){case p.GROUP_ACTIVE:if(i===this._editorGroupsService.activeGroup.id){this._onDidGroupActivate();break}else return;case p.EDITOR_LABEL:if(t.editor!==void 0&&t.editorIndex!==void 0){this._onDidTabLabelChange(i,t.editor,t.editorIndex);break}case p.EDITOR_OPEN:if(t.editor!==void 0&&t.editorIndex!==void 0){this._onDidTabOpen(i,t.editor,t.editorIndex);break}case p.EDITOR_CLOSE:if(t.editorIndex!==void 0){this._onDidTabClose(i,t.editorIndex);break}case p.EDITOR_ACTIVE:if(t.editorIndex!==void 0){this._onDidTabActiveChange(i,t.editorIndex);break}case p.EDITOR_DIRTY:if(t.editorIndex!==void 0&&t.editor!==void 0){this._onDidTabDirty(i,t.editorIndex,t.editor);break}case p.EDITOR_STICKY:if(t.editorIndex!==void 0&&t.editor!==void 0){this._onDidTabPinChange(i,t.editorIndex,t.editor);break}case p.EDITOR_PIN:if(t.editorIndex!==void 0&&t.editor!==void 0){this._onDidTabPreviewChange(i,t.editorIndex,t.editor);break}case p.EDITOR_TRANSIENT:break;case p.EDITOR_MOVE:if(P(t)&&t.editor&&t.editorIndex!==void 0&&t.oldEditorIndex!==void 0){this._onDidTabMove(i,t.editorIndex,t.oldEditorIndex,t.editor);break}default:this._createTabsModel()}}$moveTab(e,t,i,r){const o=K(this._editorGroupsService,this._configurationService,i),n=this._tabInfoLookup.get(e);if(!n?.tab)throw new Error(`Attempted to close tab with id ${e} which does not exist`);let d;const u=this._editorGroupsService.getGroup(n.group.id);if(!u)return;if(this._groupLookup.get(o)===void 0){let m=F.RIGHT;i===z&&(m=Y(this._configurationService)),d=this._editorGroupsService.addGroup(this._editorGroupsService.groups[this._editorGroupsService.groups.length-1],m)}else d=this._editorGroupsService.getGroup(o);if(!d)return;(t<0||t>d.editors.length)&&(t=d.editors.length);const f=n?.editorInput;f&&u.moveEditor(f,d,{index:t,preserveFocus:r})}async $closeTab(e,t){const i=new Map;for(const o of e){const n=this._tabInfoLookup.get(o),a=n?.tab,d=n?.group,u=n?.editorInput;if(!d||!a||!n||!u)continue;const f=i.get(d);f?f.push(u):i.set(d,[u])}const r=[];for(const[o,n]of i)r.push(await o.closeEditors(n,{preserveFocus:t}));return r.every(o=>o)}async $closeGroup(e,t){const i=[];for(const r of e){const o=this._editorGroupsService.getGroup(r);o&&(i.push(await o.closeAllEditors()),o.count===0&&this._editorGroupsService.getGroup(o.id)&&this._editorGroupsService.removeGroup(o))}return i.every(r=>r)}};_=g([J(O.MainThreadEditorTabs),l(1,W),l(2,M),l(3,L),l(4,q)],_);export{_ as MainThreadEditorTabs};
