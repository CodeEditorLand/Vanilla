{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/api/browser/mainThreadAuthentication.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Disposable, DisposableMap } from '../../../base/common/lifecycle.js';\nimport * as nls from '../../../nls.js';\nimport { extHostNamedCustomer, IExtHostContext } from '../../services/extensions/common/extHostCustomers.js';\nimport { IAuthenticationCreateSessionOptions, AuthenticationSession, AuthenticationSessionsChangeEvent, IAuthenticationProvider, IAuthenticationService, IAuthenticationExtensionsService, INTERNAL_AUTH_PROVIDER_PREFIX as INTERNAL_MODEL_AUTH_PROVIDER_PREFIX, AuthenticationSessionAccount, IAuthenticationProviderSessionOptions } from '../../services/authentication/common/authentication.js';\nimport { ExtHostAuthenticationShape, ExtHostContext, MainContext, MainThreadAuthenticationShape } from '../common/extHost.protocol.js';\nimport { IDialogService, IPromptButton } from '../../../platform/dialogs/common/dialogs.js';\nimport Severity from '../../../base/common/severity.js';\nimport { INotificationService } from '../../../platform/notification/common/notification.js';\nimport { ActivationKind, IExtensionService } from '../../services/extensions/common/extensions.js';\nimport { ITelemetryService } from '../../../platform/telemetry/common/telemetry.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { IAuthenticationAccessService } from '../../services/authentication/browser/authenticationAccessService.js';\nimport { IAuthenticationUsageService } from '../../services/authentication/browser/authenticationUsageService.js';\nimport { getAuthenticationProviderActivationEvent } from '../../services/authentication/browser/authenticationService.js';\nimport { URI, UriComponents } from '../../../base/common/uri.js';\nimport { IOpenerService } from '../../../platform/opener/common/opener.js';\nimport { CancellationError } from '../../../base/common/errors.js';\n\ninterface AuthenticationForceNewSessionOptions {\n\tdetail?: string;\n\tlearnMore?: UriComponents;\n\tsessionToRecreate?: AuthenticationSession;\n}\n\ninterface AuthenticationGetSessionOptions {\n\tclearSessionPreference?: boolean;\n\tcreateIfNone?: boolean;\n\tforceNewSession?: boolean | AuthenticationForceNewSessionOptions;\n\tsilent?: boolean;\n\taccount?: AuthenticationSessionAccount;\n}\n\nexport class MainThreadAuthenticationProvider extends Disposable implements IAuthenticationProvider {\n\n\treadonly onDidChangeSessions: Event<AuthenticationSessionsChangeEvent>;\n\n\tconstructor(\n\t\tprivate readonly _proxy: ExtHostAuthenticationShape,\n\t\tpublic readonly id: string,\n\t\tpublic readonly label: string,\n\t\tpublic readonly supportsMultipleAccounts: boolean,\n\t\tprivate readonly notificationService: INotificationService,\n\t\tonDidChangeSessionsEmitter: Emitter<AuthenticationSessionsChangeEvent>,\n\t) {\n\t\tsuper();\n\t\tthis.onDidChangeSessions = onDidChangeSessionsEmitter.event;\n\t}\n\n\tasync getSessions(scopes: string[] | undefined, options: IAuthenticationProviderSessionOptions) {\n\t\treturn this._proxy.$getSessions(this.id, scopes, options);\n\t}\n\n\tcreateSession(scopes: string[], options: IAuthenticationCreateSessionOptions): Promise<AuthenticationSession> {\n\t\treturn this._proxy.$createSession(this.id, scopes, options);\n\t}\n\n\tasync removeSession(sessionId: string): Promise<void> {\n\t\tawait this._proxy.$removeSession(this.id, sessionId);\n\t\tthis.notificationService.info(nls.localize('signedOut', \"Successfully signed out.\"));\n\t}\n}\n\n@extHostNamedCustomer(MainContext.MainThreadAuthentication)\nexport class MainThreadAuthentication extends Disposable implements MainThreadAuthenticationShape {\n\tprivate readonly _proxy: ExtHostAuthenticationShape;\n\n\tprivate readonly _registrations = this._register(new DisposableMap<string>());\n\n\tconstructor(\n\t\textHostContext: IExtHostContext,\n\t\t@IAuthenticationService private readonly authenticationService: IAuthenticationService,\n\t\t@IAuthenticationExtensionsService private readonly authenticationExtensionsService: IAuthenticationExtensionsService,\n\t\t@IAuthenticationAccessService private readonly authenticationAccessService: IAuthenticationAccessService,\n\t\t@IAuthenticationUsageService private readonly authenticationUsageService: IAuthenticationUsageService,\n\t\t@IDialogService private readonly dialogService: IDialogService,\n\t\t@INotificationService private readonly notificationService: INotificationService,\n\t\t@IExtensionService private readonly extensionService: IExtensionService,\n\t\t@ITelemetryService private readonly telemetryService: ITelemetryService,\n\t\t@IOpenerService private readonly openerService: IOpenerService\n\t) {\n\t\tsuper();\n\t\tthis._proxy = extHostContext.getProxy(ExtHostContext.ExtHostAuthentication);\n\n\t\tthis._register(this.authenticationService.onDidChangeSessions(e => {\n\t\t\tthis._proxy.$onDidChangeAuthenticationSessions(e.providerId, e.label);\n\t\t}));\n\t}\n\n\tasync $registerAuthenticationProvider(id: string, label: string, supportsMultipleAccounts: boolean): Promise<void> {\n\t\tconst emitter = new Emitter<AuthenticationSessionsChangeEvent>();\n\t\tthis._registrations.set(id, emitter);\n\t\tconst provider = new MainThreadAuthenticationProvider(this._proxy, id, label, supportsMultipleAccounts, this.notificationService, emitter);\n\t\tthis.authenticationService.registerAuthenticationProvider(id, provider);\n\t}\n\n\t$unregisterAuthenticationProvider(id: string): void {\n\t\tthis._registrations.deleteAndDispose(id);\n\t\tthis.authenticationService.unregisterAuthenticationProvider(id);\n\t}\n\n\tasync $ensureProvider(id: string): Promise<void> {\n\t\tif (!this.authenticationService.isAuthenticationProviderRegistered(id)) {\n\t\t\treturn await this.extensionService.activateByEvent(getAuthenticationProviderActivationEvent(id), ActivationKind.Immediate);\n\t\t}\n\t}\n\n\t$sendDidChangeSessions(providerId: string, event: AuthenticationSessionsChangeEvent): void {\n\t\tconst obj = this._registrations.get(providerId);\n\t\tif (obj instanceof Emitter) {\n\t\t\tobj.fire(event);\n\t\t}\n\t}\n\n\t$removeSession(providerId: string, sessionId: string): Promise<void> {\n\t\treturn this.authenticationService.removeSession(providerId, sessionId);\n\t}\n\tprivate async loginPrompt(provider: IAuthenticationProvider, extensionName: string, recreatingSession: boolean, options?: AuthenticationForceNewSessionOptions): Promise<boolean> {\n\t\tlet message: string;\n\n\t\t// An internal provider is a special case which is for model access only.\n\t\tif (provider.id.startsWith(INTERNAL_MODEL_AUTH_PROVIDER_PREFIX)) {\n\t\t\tmessage = nls.localize('confirmModelAccess', \"The extension '{0}' wants to access the language models provided by {1}.\", extensionName, provider.label);\n\t\t} else {\n\t\t\tmessage = recreatingSession\n\t\t\t\t? nls.localize('confirmRelogin', \"The extension '{0}' wants you to sign in again using {1}.\", extensionName, provider.label)\n\t\t\t\t: nls.localize('confirmLogin', \"The extension '{0}' wants to sign in using {1}.\", extensionName, provider.label);\n\t\t}\n\n\t\tconst buttons: IPromptButton<boolean | undefined>[] = [\n\t\t\t{\n\t\t\t\tlabel: nls.localize({ key: 'allow', comment: ['&& denotes a mnemonic'] }, \"&&Allow\"),\n\t\t\t\trun() {\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t}\n\t\t];\n\t\tif (options?.learnMore) {\n\t\t\tbuttons.push({\n\t\t\t\tlabel: nls.localize('learnMore', \"Learn more\"),\n\t\t\t\trun: async () => {\n\t\t\t\t\tconst result = this.loginPrompt(provider, extensionName, recreatingSession, options);\n\t\t\t\t\tawait this.openerService.open(URI.revive(options.learnMore!), { allowCommands: true });\n\t\t\t\t\treturn await result;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tconst { result } = await this.dialogService.prompt({\n\t\t\ttype: Severity.Info,\n\t\t\tmessage,\n\t\t\tbuttons,\n\t\t\tdetail: options?.detail,\n\t\t\tcancelButton: true,\n\t\t});\n\n\t\treturn result ?? false;\n\t}\n\n\tprivate async continueWithIncorrectAccountPrompt(chosenAccountLabel: string, requestedAccountLabel: string): Promise<boolean> {\n\t\tconst result = await this.dialogService.prompt({\n\t\t\tmessage: nls.localize('incorrectAccount', \"Incorrect account detected\"),\n\t\t\tdetail: nls.localize('incorrectAccountDetail', \"The chosen account, {0}, does not match the requested account, {1}.\", chosenAccountLabel, requestedAccountLabel),\n\t\t\ttype: Severity.Warning,\n\t\t\tcancelButton: true,\n\t\t\tbuttons: [\n\t\t\t\t{\n\t\t\t\t\tlabel: nls.localize('keep', 'Keep {0}', chosenAccountLabel),\n\t\t\t\t\trun: () => chosenAccountLabel\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tlabel: nls.localize('loginWith', 'Login with {0}', requestedAccountLabel),\n\t\t\t\t\trun: () => requestedAccountLabel\n\t\t\t\t}\n\t\t\t],\n\t\t});\n\n\t\tif (!result.result) {\n\t\t\tthrow new CancellationError();\n\t\t}\n\n\t\treturn result.result === chosenAccountLabel;\n\t}\n\n\tprivate async doGetSession(providerId: string, scopes: string[], extensionId: string, extensionName: string, options: AuthenticationGetSessionOptions): Promise<AuthenticationSession | undefined> {\n\t\tconst sessions = await this.authenticationService.getSessions(providerId, scopes, options.account, true);\n\t\tconst provider = this.authenticationService.getProvider(providerId);\n\n\t\t// Error cases\n\t\tif (options.forceNewSession && options.createIfNone) {\n\t\t\tthrow new Error('Invalid combination of options. Please remove one of the following: forceNewSession, createIfNone');\n\t\t}\n\t\tif (options.forceNewSession && options.silent) {\n\t\t\tthrow new Error('Invalid combination of options. Please remove one of the following: forceNewSession, silent');\n\t\t}\n\t\tif (options.createIfNone && options.silent) {\n\t\t\tthrow new Error('Invalid combination of options. Please remove one of the following: createIfNone, silent');\n\t\t}\n\n\t\tif (options.clearSessionPreference) {\n\t\t\t// Clearing the session preference is usually paired with createIfNone, so just remove the preference and\n\t\t\t// defer to the rest of the logic in this function to choose the session.\n\t\t\tthis.authenticationExtensionsService.removeSessionPreference(providerId, extensionId, scopes);\n\t\t}\n\n\t\t// Check if the sessions we have are valid\n\t\tif (!options.forceNewSession && sessions.length) {\n\t\t\tif (provider.supportsMultipleAccounts) {\n\t\t\t\t// If we have an existing session preference, use that. If not, we'll return any valid session at the end of this function.\n\t\t\t\tconst existingSessionPreference = this.authenticationExtensionsService.getSessionPreference(providerId, extensionId, scopes);\n\t\t\t\tif (existingSessionPreference) {\n\t\t\t\t\tconst matchingSession = sessions.find(session => session.id === existingSessionPreference);\n\t\t\t\t\tif (matchingSession && this.authenticationAccessService.isAccessAllowed(providerId, matchingSession.account.label, extensionId)) {\n\t\t\t\t\t\treturn matchingSession;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (this.authenticationAccessService.isAccessAllowed(providerId, sessions[0].account.label, extensionId)) {\n\t\t\t\treturn sessions[0];\n\t\t\t}\n\t\t}\n\n\t\t// We may need to prompt because we don't have a valid session\n\t\t// modal flows\n\t\tif (options.createIfNone || options.forceNewSession) {\n\t\t\tlet uiOptions: AuthenticationForceNewSessionOptions | undefined;\n\t\t\tif (typeof options.forceNewSession === 'object') {\n\t\t\t\tuiOptions = options.forceNewSession;\n\t\t\t}\n\n\t\t\t// We only want to show the \"recreating session\" prompt if we are using forceNewSession & there are sessions\n\t\t\t// that we will be \"forcing through\".\n\t\t\tconst recreatingSession = !!(options.forceNewSession && sessions.length);\n\t\t\tconst isAllowed = await this.loginPrompt(provider, extensionName, recreatingSession, uiOptions);\n\t\t\tif (!isAllowed) {\n\t\t\t\tthrow new Error('User did not consent to login.');\n\t\t\t}\n\n\t\t\tlet session: AuthenticationSession;\n\t\t\tif (sessions?.length && !options.forceNewSession) {\n\t\t\t\tsession = provider.supportsMultipleAccounts && !options.account\n\t\t\t\t\t? await this.authenticationExtensionsService.selectSession(providerId, extensionId, extensionName, scopes, sessions)\n\t\t\t\t\t: sessions[0];\n\t\t\t} else {\n\t\t\t\tlet accountToCreate: AuthenticationSessionAccount | undefined = options.account;\n\t\t\t\tif (!accountToCreate) {\n\t\t\t\t\tconst sessionIdToRecreate = this.authenticationExtensionsService.getSessionPreference(providerId, extensionId, scopes);\n\t\t\t\t\taccountToCreate = sessionIdToRecreate ? sessions.find(session => session.id === sessionIdToRecreate)?.account : undefined;\n\t\t\t\t}\n\n\t\t\t\tdo {\n\t\t\t\t\tsession = await this.authenticationService.createSession(providerId, scopes, { activateImmediate: true, account: accountToCreate });\n\t\t\t\t} while (\n\t\t\t\t\taccountToCreate\n\t\t\t\t\t&& accountToCreate.label !== session.account.label\n\t\t\t\t\t&& !await this.continueWithIncorrectAccountPrompt(session.account.label, accountToCreate.label)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis.authenticationAccessService.updateAllowedExtensions(providerId, session.account.label, [{ id: extensionId, name: extensionName, allowed: true }]);\n\t\t\tthis.authenticationExtensionsService.updateSessionPreference(providerId, extensionId, session);\n\t\t\treturn session;\n\t\t}\n\n\t\t// For the silent flows, if we have a session, even though it may not be the user's preference, we'll return it anyway because it might be for a specific\n\t\t// set of scopes.\n\t\tconst validSession = sessions.find(session => this.authenticationAccessService.isAccessAllowed(providerId, session.account.label, extensionId));\n\t\tif (validSession) {\n\t\t\treturn validSession;\n\t\t}\n\n\t\t// passive flows (silent or default)\n\t\tif (!options.silent) {\n\t\t\t// If there is a potential session, but the extension doesn't have access to it, use the \"grant access\" flow,\n\t\t\t// otherwise request a new one.\n\t\t\tsessions.length\n\t\t\t\t? this.authenticationExtensionsService.requestSessionAccess(providerId, extensionId, extensionName, scopes, sessions)\n\t\t\t\t: await this.authenticationExtensionsService.requestNewSession(providerId, scopes, extensionId, extensionName);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tasync $getSession(providerId: string, scopes: string[], extensionId: string, extensionName: string, options: AuthenticationGetSessionOptions): Promise<AuthenticationSession | undefined> {\n\t\tconst session = await this.doGetSession(providerId, scopes, extensionId, extensionName, options);\n\n\t\tif (session) {\n\t\t\tthis.sendProviderUsageTelemetry(extensionId, providerId);\n\t\t\tthis.authenticationUsageService.addAccountUsage(providerId, session.account.label, extensionId, extensionName);\n\t\t}\n\n\t\treturn session;\n\t}\n\n\tasync $getAccounts(providerId: string): Promise<ReadonlyArray<AuthenticationSessionAccount>> {\n\t\tconst accounts = await this.authenticationService.getAccounts(providerId);\n\t\treturn accounts;\n\t}\n\n\tprivate sendProviderUsageTelemetry(extensionId: string, providerId: string): void {\n\t\ttype AuthProviderUsageClassification = {\n\t\t\towner: 'TylerLeonhardt';\n\t\t\tcomment: 'Used to see which extensions are using which providers';\n\t\t\textensionId: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'The extension id.' };\n\t\t\tproviderId: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'The provider id.' };\n\t\t};\n\t\tthis.telemetryService.publicLog2<{ extensionId: string; providerId: string }, AuthProviderUsageClassification>('authentication.providerUsage', { providerId, extensionId });\n\t}\n}\n"],
  "mappings": "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",
  "names": ["result", "session"]
}
