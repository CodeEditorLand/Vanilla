{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/api/browser/mainThreadNotebookDocuments.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DisposableStore, dispose } from '../../../base/common/lifecycle.js';\nimport { ResourceMap } from '../../../base/common/map.js';\nimport { URI, UriComponents } from '../../../base/common/uri.js';\nimport { BoundModelReferenceCollection } from './mainThreadDocuments.js';\nimport { NotebookTextModel } from '../../contrib/notebook/common/model/notebookTextModel.js';\nimport { NotebookCellsChangeType } from '../../contrib/notebook/common/notebookCommon.js';\nimport { INotebookEditorModelResolverService } from '../../contrib/notebook/common/notebookEditorModelResolverService.js';\nimport { IUriIdentityService } from '../../../platform/uriIdentity/common/uriIdentity.js';\nimport { ExtHostContext, ExtHostNotebookDocumentsShape, MainThreadNotebookDocumentsShape, NotebookCellDto, NotebookCellsChangedEventDto, NotebookDataDto } from '../common/extHost.protocol.js';\nimport { NotebookDto } from './mainThreadNotebookDto.js';\nimport { SerializableObjectWithBuffers } from '../../services/extensions/common/proxyIdentifier.js';\nimport { IExtHostContext } from '../../services/extensions/common/extHostCustomers.js';\n\nexport class MainThreadNotebookDocuments implements MainThreadNotebookDocumentsShape {\n\n\tprivate readonly _disposables = new DisposableStore();\n\n\tprivate readonly _proxy: ExtHostNotebookDocumentsShape;\n\tprivate readonly _documentEventListenersMapping = new ResourceMap<DisposableStore>();\n\tprivate readonly _modelReferenceCollection: BoundModelReferenceCollection;\n\n\tconstructor(\n\t\textHostContext: IExtHostContext,\n\t\t@INotebookEditorModelResolverService private readonly _notebookEditorModelResolverService: INotebookEditorModelResolverService,\n\t\t@IUriIdentityService private readonly _uriIdentityService: IUriIdentityService\n\t) {\n\t\tthis._proxy = extHostContext.getProxy(ExtHostContext.ExtHostNotebookDocuments);\n\t\tthis._modelReferenceCollection = new BoundModelReferenceCollection(this._uriIdentityService.extUri);\n\n\t\t// forward dirty and save events\n\t\tthis._disposables.add(this._notebookEditorModelResolverService.onDidChangeDirty(model => this._proxy.$acceptDirtyStateChanged(model.resource, model.isDirty())));\n\t\tthis._disposables.add(this._notebookEditorModelResolverService.onDidSaveNotebook(e => this._proxy.$acceptModelSaved(e)));\n\n\t\t// when a conflict is going to happen RELEASE references that are held by extensions\n\t\tthis._disposables.add(_notebookEditorModelResolverService.onWillFailWithConflict(e => {\n\t\t\tthis._modelReferenceCollection.remove(e.resource);\n\t\t}));\n\t}\n\n\tdispose(): void {\n\t\tthis._disposables.dispose();\n\t\tthis._modelReferenceCollection.dispose();\n\t\tdispose(this._documentEventListenersMapping.values());\n\t}\n\n\thandleNotebooksAdded(notebooks: readonly NotebookTextModel[]): void {\n\n\t\tfor (const textModel of notebooks) {\n\t\t\tconst disposableStore = new DisposableStore();\n\t\t\tdisposableStore.add(textModel.onDidChangeContent(event => {\n\n\t\t\t\tconst eventDto: NotebookCellsChangedEventDto = {\n\t\t\t\t\tversionId: event.versionId,\n\t\t\t\t\trawEvents: []\n\t\t\t\t};\n\n\t\t\t\tfor (const e of event.rawEvents) {\n\n\t\t\t\t\tswitch (e.kind) {\n\t\t\t\t\t\tcase NotebookCellsChangeType.ModelChange:\n\t\t\t\t\t\t\teventDto.rawEvents.push({\n\t\t\t\t\t\t\t\tkind: e.kind,\n\t\t\t\t\t\t\t\tchanges: e.changes.map(diff => [diff[0], diff[1], diff[2].map(cell => NotebookDto.toNotebookCellDto(cell))] as [number, number, NotebookCellDto[]])\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase NotebookCellsChangeType.Move:\n\t\t\t\t\t\t\teventDto.rawEvents.push({\n\t\t\t\t\t\t\t\tkind: e.kind,\n\t\t\t\t\t\t\t\tindex: e.index,\n\t\t\t\t\t\t\t\tlength: e.length,\n\t\t\t\t\t\t\t\tnewIdx: e.newIdx,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase NotebookCellsChangeType.Output:\n\t\t\t\t\t\t\teventDto.rawEvents.push({\n\t\t\t\t\t\t\t\tkind: e.kind,\n\t\t\t\t\t\t\t\tindex: e.index,\n\t\t\t\t\t\t\t\toutputs: e.outputs.map(NotebookDto.toNotebookOutputDto)\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase NotebookCellsChangeType.OutputItem:\n\t\t\t\t\t\t\teventDto.rawEvents.push({\n\t\t\t\t\t\t\t\tkind: e.kind,\n\t\t\t\t\t\t\t\tindex: e.index,\n\t\t\t\t\t\t\t\toutputId: e.outputId,\n\t\t\t\t\t\t\t\toutputItems: e.outputItems.map(NotebookDto.toNotebookOutputItemDto),\n\t\t\t\t\t\t\t\tappend: e.append\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase NotebookCellsChangeType.ChangeCellLanguage:\n\t\t\t\t\t\tcase NotebookCellsChangeType.ChangeCellContent:\n\t\t\t\t\t\tcase NotebookCellsChangeType.ChangeCellMetadata:\n\t\t\t\t\t\tcase NotebookCellsChangeType.ChangeCellInternalMetadata:\n\t\t\t\t\t\t\teventDto.rawEvents.push(e);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst hasDocumentMetadataChangeEvent = event.rawEvents.find(e => e.kind === NotebookCellsChangeType.ChangeDocumentMetadata);\n\n\t\t\t\t// using the model resolver service to know if the model is dirty or not.\n\t\t\t\t// assuming this is the first listener it can mean that at first the model\n\t\t\t\t// is marked as dirty and that another event is fired\n\t\t\t\tthis._proxy.$acceptModelChanged(\n\t\t\t\t\ttextModel.uri,\n\t\t\t\t\tnew SerializableObjectWithBuffers(eventDto),\n\t\t\t\t\tthis._notebookEditorModelResolverService.isDirty(textModel.uri),\n\t\t\t\t\thasDocumentMetadataChangeEvent ? textModel.metadata : undefined\n\t\t\t\t);\n\t\t\t}));\n\n\t\t\tthis._documentEventListenersMapping.set(textModel.uri, disposableStore);\n\t\t}\n\t}\n\n\thandleNotebooksRemoved(uris: URI[]): void {\n\t\tfor (const uri of uris) {\n\t\t\tthis._documentEventListenersMapping.get(uri)?.dispose();\n\t\t\tthis._documentEventListenersMapping.delete(uri);\n\t\t}\n\t}\n\n\tasync $tryCreateNotebook(options: { viewType: string; content?: NotebookDataDto }): Promise<UriComponents> {\n\t\tif (options.content) {\n\t\t\tconst ref = await this._notebookEditorModelResolverService.resolve({ untitledResource: undefined }, options.viewType);\n\n\t\t\t// untitled notebooks are disposed when they get saved. we should not hold a reference\n\t\t\t// to such a disposed notebook and therefore dispose the reference as well\n\t\t\tref.object.notebook.onWillDispose(() => {\n\t\t\t\tref.dispose();\n\t\t\t});\n\n\t\t\t// untitled notebooks with content are dirty by default\n\t\t\tthis._proxy.$acceptDirtyStateChanged(ref.object.resource, true);\n\n\t\t\t// apply content changes... slightly HACKY -> this triggers a change event\n\t\t\tif (options.content) {\n\t\t\t\tconst data = NotebookDto.fromNotebookDataDto(options.content);\n\t\t\t\tref.object.notebook.reset(data.cells, data.metadata, ref.object.notebook.transientOptions);\n\t\t\t}\n\t\t\treturn ref.object.notebook.uri;\n\t\t} else {\n\t\t\t// If we aren't adding content, we don't need to resolve the full editor model yet.\n\t\t\t// This will allow us to adjust settings when the editor is opened, e.g. scratchpad\n\t\t\tconst notebook = await this._notebookEditorModelResolverService.createUntitledNotebookTextModel(options.viewType);\n\t\t\treturn notebook.uri;\n\t\t}\n\t}\n\n\tasync $tryOpenNotebook(uriComponents: UriComponents): Promise<URI> {\n\t\tconst uri = URI.revive(uriComponents);\n\t\tconst ref = await this._notebookEditorModelResolverService.resolve(uri, undefined);\n\n\t\tif (uriComponents.scheme === 'untitled') {\n\t\t\t// untitled notebooks are disposed when they get saved. we should not hold a reference\n\t\t\t// to such a disposed notebook and therefore dispose the reference as well\n\t\t\tref.object.notebook.onWillDispose(() => {\n\t\t\t\tref.dispose();\n\t\t\t});\n\t\t}\n\n\t\tthis._modelReferenceCollection.add(uri, ref);\n\t\treturn uri;\n\t}\n\n\tasync $trySaveNotebook(uriComponents: UriComponents) {\n\t\tconst uri = URI.revive(uriComponents);\n\n\t\tconst ref = await this._notebookEditorModelResolverService.resolve(uri);\n\t\tconst saveResult = await ref.object.save();\n\t\tref.dispose();\n\t\treturn saveResult;\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
