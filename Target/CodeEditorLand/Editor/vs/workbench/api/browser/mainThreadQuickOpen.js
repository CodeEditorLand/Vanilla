var h=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var k=(u,e,i,o)=>{for(var r=o>1?void 0:o?f(e,i):e,s=u.length-1,t;s>=0;s--)(t=u[s])&&(r=(o?t(e,i,r):t(r))||r);return o&&r&&h(e,i,r),r},l=(u,e)=>(i,o)=>e(i,o,u);import"../../../../vs/base/common/cancellation.js";import{DisposableStore as v}from"../../../../vs/base/common/lifecycle.js";import{URI as I}from"../../../../vs/base/common/uri.js";import{IQuickInputService as P}from"../../../../vs/platform/quickinput/common/quickInput.js";import{ExtHostContext as Q,MainContext as S}from"../../../../vs/workbench/api/common/extHost.protocol.js";import{extHostNamedCustomer as T}from"../../../../vs/workbench/services/extensions/common/extHostCustomers.js";function m(u){u.dark=I.revive(u.dark),u.light&&(u.light=I.revive(u.light))}let d=class{_proxy;_quickInputService;_items={};constructor(e,i){this._proxy=e.getProxy(Q.ExtHostQuickOpen),this._quickInputService=i}dispose(){for(const[e,i]of this.sessions)i.store.dispose()}$show(e,i,o){const r=new Promise((s,t)=>{this._items[e]={resolve:s,reject:t}});return i={...i,onDidFocus:s=>{s&&this._proxy.$onItemSelected(s.handle)}},i.canPickMany?this._quickInputService.pick(r,i,o).then(s=>{if(s)return s.map(t=>t.handle)}):this._quickInputService.pick(r,i,o).then(s=>{if(s)return s.handle})}$setItems(e,i){return this._items[e]&&(this._items[e].resolve(i),delete this._items[e]),Promise.resolve()}$setError(e,i){return this._items[e]&&(this._items[e].reject(i),delete this._items[e]),Promise.resolve()}$input(e,i,o){const r=Object.create(null);return e&&(r.title=e.title,r.password=e.password,r.placeHolder=e.placeHolder,r.valueSelection=e.valueSelection,r.prompt=e.prompt,r.value=e.value,r.ignoreFocusLost=e.ignoreFocusOut),i&&(r.validateInput=s=>this._proxy.$validateInput(s)),this._quickInputService.input(r,o)}sessions=new Map;$createOrUpdate(e){const i=e.id;let o=this.sessions.get(i);if(!o){const t=new v,n=e.type==="quickPick"?this._quickInputService.createQuickPick():this._quickInputService.createInputBox();if(t.add(n),t.add(n.onDidAccept(()=>{this._proxy.$onDidAccept(i)})),t.add(n.onDidTriggerButton(c=>{this._proxy.$onDidTriggerButton(i,c.handle)})),t.add(n.onDidChangeValue(c=>{this._proxy.$onDidChangeValue(i,c)})),t.add(n.onDidHide(()=>{this._proxy.$onDidHide(i)})),e.type==="quickPick"){const c=n;t.add(c.onDidChangeActive(a=>{this._proxy.$onDidChangeActive(i,a.map(p=>p.handle))})),t.add(c.onDidChangeSelection(a=>{this._proxy.$onDidChangeSelection(i,a.map(p=>p.handle))})),t.add(c.onDidTriggerItemButton(a=>{this._proxy.$onDidTriggerItemButton(i,a.item.handle,a.button.handle)}))}o={input:n,handlesToItems:new Map,store:t},this.sessions.set(i,o)}const{input:r,handlesToItems:s}=o;for(const t in e)t==="id"||t==="type"||(t==="visible"?e.visible?r.show():r.hide():t==="items"?(s.clear(),e[t].forEach(n=>{n.type!=="separator"&&(n.buttons&&(n.buttons=n.buttons.map(c=>(c.iconPath&&m(c.iconPath),c))),s.set(n.handle,n))}),r[t]=e[t]):t==="activeItems"||t==="selectedItems"?r[t]=e[t].filter(n=>s.has(n)).map(n=>s.get(n)):t==="buttons"?r[t]=e.buttons.map(n=>n.handle===-1?this._quickInputService.backButton:(n.iconPath&&m(n.iconPath),n)):r[t]=e[t]);return Promise.resolve(void 0)}$dispose(e){const i=this.sessions.get(e);return i&&(i.store.dispose(),this.sessions.delete(e)),Promise.resolve(void 0)}};d=k([T(S.MainThreadQuickOpen),l(1,P)],d);export{d as MainThreadQuickOpen};
