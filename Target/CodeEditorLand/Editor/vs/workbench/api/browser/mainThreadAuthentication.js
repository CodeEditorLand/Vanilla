var b=Object.defineProperty;var I=Object.getOwnPropertyDescriptor;var A=(h,c,e,t)=>{for(var i=t>1?void 0:t?I(c,e):c,o=h.length-1,n;o>=0;o--)(n=h[o])&&(i=(t?n(c,e,i):n(i))||i);return t&&i&&b(c,e,i),i},r=(h,c)=>(e,t)=>c(e,t,h);import{CancellationError as x}from"../../../base/common/errors.js";import{Emitter as y}from"../../../base/common/event.js";import{Disposable as w,DisposableMap as C}from"../../../base/common/lifecycle.js";import P from"../../../base/common/severity.js";import{URI as N}from"../../../base/common/uri.js";import*as a from"../../../nls.js";import{IDialogService as _}from"../../../platform/dialogs/common/dialogs.js";import{INotificationService as T}from"../../../platform/notification/common/notification.js";import{IOpenerService as O}from"../../../platform/opener/common/opener.js";import{ITelemetryService as U}from"../../../platform/telemetry/common/telemetry.js";import{IAuthenticationAccessService as D}from"../../services/authentication/browser/authenticationAccessService.js";import{getAuthenticationProviderActivationEvent as M}from"../../services/authentication/browser/authenticationService.js";import{IAuthenticationUsageService as R}from"../../services/authentication/browser/authenticationUsageService.js";import{IAuthenticationExtensionsService as $,IAuthenticationService as z,INTERNAL_AUTH_PROVIDER_PREFIX as H}from"../../services/authentication/common/authentication.js";import{extHostNamedCustomer as F}from"../../services/extensions/common/extHostCustomers.js";import{ActivationKind as B,IExtensionService as G}from"../../services/extensions/common/extensions.js";import{ExtHostContext as W,MainContext as L}from"../common/extHost.protocol.js";class j extends w{constructor(e,t,i,o,n,s){super();this._proxy=e;this.id=t;this.label=i;this.supportsMultipleAccounts=o;this.notificationService=n;this.onDidChangeSessions=s.event}onDidChangeSessions;async getSessions(e,t){return this._proxy.$getSessions(this.id,e,t)}createSession(e,t){return this._proxy.$createSession(this.id,e,t)}async removeSession(e){await this._proxy.$removeSession(this.id,e),this.notificationService.info(a.localize("signedOut","Successfully signed out."))}}let d=class extends w{constructor(e,t,i,o,n,s,S,f,l,v){super();this.authenticationService=t;this.authenticationExtensionsService=i;this.authenticationAccessService=o;this.authenticationUsageService=n;this.dialogService=s;this.notificationService=S;this.extensionService=f;this.telemetryService=l;this.openerService=v;this._proxy=e.getProxy(W.ExtHostAuthentication),this._register(this.authenticationService.onDidChangeSessions(m=>{this._proxy.$onDidChangeAuthenticationSessions(m.providerId,m.label)}))}_proxy;_registrations=this._register(new C);async $registerAuthenticationProvider(e,t,i){const o=new y;this._registrations.set(e,o);const n=new j(this._proxy,e,t,i,this.notificationService,o);this.authenticationService.registerAuthenticationProvider(e,n)}$unregisterAuthenticationProvider(e){this._registrations.deleteAndDispose(e),this.authenticationService.unregisterAuthenticationProvider(e)}async $ensureProvider(e){if(!this.authenticationService.isAuthenticationProviderRegistered(e))return await this.extensionService.activateByEvent(M(e),B.Immediate)}$sendDidChangeSessions(e,t){const i=this._registrations.get(e);i instanceof y&&i.fire(t)}$removeSession(e,t){return this.authenticationService.removeSession(e,t)}async loginPrompt(e,t,i,o){let n;e.id.startsWith(H)?n=a.localize("confirmModelAccess","The extension '{0}' wants to access the language models provided by {1}.",t,e.label):n=i?a.localize("confirmRelogin","The extension '{0}' wants you to sign in again using {1}.",t,e.label):a.localize("confirmLogin","The extension '{0}' wants to sign in using {1}.",t,e.label);const s=[{label:a.localize({key:"allow",comment:["&& denotes a mnemonic"]},"&&Allow"),run(){return!0}}];o?.learnMore&&s.push({label:a.localize("learnMore","Learn more"),run:async()=>{const f=this.loginPrompt(e,t,i,o);return await this.openerService.open(N.revive(o.learnMore),{allowCommands:!0}),await f}});const{result:S}=await this.dialogService.prompt({type:P.Info,message:n,buttons:s,detail:o?.detail,cancelButton:!0});return S??!1}async continueWithIncorrectAccountPrompt(e,t){const i=await this.dialogService.prompt({message:a.localize("incorrectAccount","Incorrect account detected"),detail:a.localize("incorrectAccountDetail","The chosen account, {0}, does not match the requested account, {1}.",e,t),type:P.Warning,cancelButton:!0,buttons:[{label:a.localize("keep","Keep {0}",e),run:()=>e},{label:a.localize("loginWith","Login with {0}",t),run:()=>t}]});if(!i.result)throw new x;return i.result===e}async doGetSession(e,t,i,o,n){const s=await this.authenticationService.getSessions(e,t,n.account,!0),S=this.authenticationService.getProvider(e);if(n.forceNewSession&&n.createIfNone)throw new Error("Invalid combination of options. Please remove one of the following: forceNewSession, createIfNone");if(n.forceNewSession&&n.silent)throw new Error("Invalid combination of options. Please remove one of the following: forceNewSession, silent");if(n.createIfNone&&n.silent)throw new Error("Invalid combination of options. Please remove one of the following: createIfNone, silent");if(n.clearSessionPreference&&this.authenticationExtensionsService.removeSessionPreference(e,i,t),!n.forceNewSession&&s.length){if(S.supportsMultipleAccounts){const l=this.authenticationExtensionsService.getSessionPreference(e,i,t);if(l){const v=s.find(m=>m.id===l);if(v&&this.authenticationAccessService.isAccessAllowed(e,v.account.label,i))return v}}else if(this.authenticationAccessService.isAccessAllowed(e,s[0].account.label,i))return s[0]}if(n.createIfNone||n.forceNewSession){let l;typeof n.forceNewSession=="object"&&(l=n.forceNewSession);const v=!!(n.forceNewSession&&s.length);if(!await this.loginPrompt(S,o,v,l))throw new Error("User did not consent to login.");let u;if(s?.length&&!n.forceNewSession)u=S.supportsMultipleAccounts&&!n.account?await this.authenticationExtensionsService.selectSession(e,i,o,t,s):s[0];else{let g=n.account;if(!g){const p=this.authenticationExtensionsService.getSessionPreference(e,i,t);g=p?s.find(E=>E.id===p)?.account:void 0}do u=await this.authenticationService.createSession(e,t,{activateImmediate:!0,account:g});while(g&&g.label!==u.account.label&&!await this.continueWithIncorrectAccountPrompt(u.account.label,g.label))}return this.authenticationAccessService.updateAllowedExtensions(e,u.account.label,[{id:i,name:o,allowed:!0}]),this.authenticationExtensionsService.updateSessionPreference(e,i,u),u}const f=s.find(l=>this.authenticationAccessService.isAccessAllowed(e,l.account.label,i));if(f)return f;n.silent||(s.length?this.authenticationExtensionsService.requestSessionAccess(e,i,o,t,s):await this.authenticationExtensionsService.requestNewSession(e,t,i,o))}async $getSession(e,t,i,o,n){const s=await this.doGetSession(e,t,i,o,n);return s&&(this.sendProviderUsageTelemetry(i,e),this.authenticationUsageService.addAccountUsage(e,s.account.label,i,o)),s}async $getAccounts(e){return await this.authenticationService.getAccounts(e)}sendProviderUsageTelemetry(e,t){this.telemetryService.publicLog2("authentication.providerUsage",{providerId:t,extensionId:e})}};d=A([F(L.MainThreadAuthentication),r(1,z),r(2,$),r(3,D),r(4,R),r(5,_),r(6,T),r(7,G),r(8,U),r(9,O)],d);export{d as MainThreadAuthentication,j as MainThreadAuthenticationProvider};
