var _=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var v=(h,e,s,t)=>{for(var i=t>1?void 0:t?f(e,s):e,o=h.length-1,r;o>=0;o--)(r=h[o])&&(i=(t?r(e,s,i):r(i))||i);return t&&i&&_(e,s,i),i},d=(h,e)=>(s,t)=>e(s,t,h);import{AsyncIterableSource as C,DeferredPromise as A}from"../../../base/common/async.js";import{transformErrorForSerialization as m,transformErrorFromSerialization as y}from"../../../base/common/errors.js";import{Emitter as M}from"../../../base/common/event.js";import{Disposable as E,DisposableMap as P,DisposableStore as u,toDisposable as L}from"../../../base/common/lifecycle.js";import{localize as x}from"../../../nls.js";import{ILogService as I}from"../../../platform/log/common/log.js";import{ExtHostContext as R,MainContext as b}from"../common/extHost.protocol.js";import{ILanguageModelStatsService as D}from"../../contrib/chat/common/languageModelStats.js";import{ILanguageModelsService as w}from"../../contrib/chat/common/languageModels.js";import{IAuthenticationAccessService as T}from"../../services/authentication/browser/authenticationAccessService.js";import{IAuthenticationService as $,INTERNAL_AUTH_PROVIDER_PREFIX as H}from"../../services/authentication/common/authentication.js";import{extHostNamedCustomer as k}from"../../services/extensions/common/extHostCustomers.js";import{IExtensionService as F}from"../../services/extensions/common/extensions.js";let g=class{constructor(e,s,t,i,o,r,c){this._chatProviderService=s;this._languageModelStatsService=t;this._logService=i;this._authenticationService=o;this._authenticationAccessService=r;this._extensionService=c;this._proxy=e.getProxy(R.ExtHostChatProvider),this._proxy.$acceptChatModelMetadata({added:s.getLanguageModelIds().map(a=>({identifier:a,metadata:s.lookupLanguageModel(a)}))}),this._store.add(s.onDidChangeLanguageModels(this._proxy.$acceptChatModelMetadata,this._proxy))}_proxy;_store=new u;_providerRegistrations=new P;_pendingProgress=new Map;dispose(){this._providerRegistrations.dispose(),this._store.dispose()}$registerLanguageModelProvider(e,s,t){const i=new u;i.add(this._chatProviderService.registerLanguageModelChat(s,{metadata:t,sendChatRequest:async(o,r,c,a)=>{const n=Math.random()*1e6|0,l=new A,p=new C;try{this._pendingProgress.set(n,{defer:l,stream:p}),await this._proxy.$startChatRequest(e,n,r,o,c,a)}catch(S){throw this._pendingProgress.delete(n),S}return{result:l.p,stream:p.asyncIterable}},provideTokenCount:(o,r)=>this._proxy.$provideTokenLength(e,o,r)})),t.auth&&i.add(this._registerAuthenticationProvider(t.extension,t.auth)),this._providerRegistrations.set(e,i)}async $reportResponsePart(e,s){const t=this._pendingProgress.get(e);this._logService.trace("[LM] report response PART",!!t,e,s),t&&t.stream.emitOne(s)}async $reportResponseDone(e,s){const t=this._pendingProgress.get(e);if(this._logService.trace("[LM] report response DONE",!!t,e,s),t)if(this._pendingProgress.delete(e),s){const i=y(s);t.stream.reject(i),t.defer.error(i)}else t.stream.resolve(),t.defer.complete(void 0)}$unregisterProvider(e){this._providerRegistrations.deleteAndDispose(e)}$selectChatModels(e){return this._chatProviderService.selectLanguageModels(e)}$whenLanguageModelChatRequestMade(e,s,t,i){this._languageModelStatsService.update(e,s,t,i)}async $tryStartChatRequest(e,s,t,i,o,r){this._logService.trace("[CHAT] request STARTED",e.value,t);const c=await this._chatProviderService.sendChatRequest(s,e,i,o,r),a=(async()=>{try{for await(const n of c.stream)this._logService.trace("[CHAT] request PART",e.value,t,n),await this._proxy.$acceptResponsePart(t,n);this._logService.trace("[CHAT] request DONE",e.value,t)}catch(n){this._logService.error("[CHAT] extension request ERRORED in STREAM",n,e.value,t),this._proxy.$acceptResponseDone(t,m(n))}})();Promise.allSettled([c.result,a]).then(()=>{this._logService.debug("[CHAT] extension request DONE",e.value,t),this._proxy.$acceptResponseDone(t,void 0)},n=>{this._logService.error("[CHAT] extension request ERRORED",n,e.value,t),this._proxy.$acceptResponseDone(t,m(n))})}$countTokens(e,s,t){return this._chatProviderService.computeTokenLength(e,s,t)}_registerAuthenticationProvider(e,s){const t=H+e.value;if(this._authenticationService.getProviderIds().includes(t))return E.None;const i=s.accountLabel??x("languageModelsAccountId","Language Models"),o=new u;return this._authenticationService.registerAuthenticationProvider(t,new N(t,s.providerLabel,i)),o.add(L(()=>{this._authenticationService.unregisterAuthenticationProvider(t)})),o.add(this._authenticationAccessService.onDidChangeExtensionSessionAccess(async r=>{const c=this._authenticationAccessService.readAllowedExtensions(t,i),a=[];for(const n of c){const l=await this._extensionService.getExtension(n.id);l&&a.push({from:l.identifier,to:e,enabled:n.allowed??!0})}this._proxy.$updateModelAccesslist(a)})),o}};g=v([k(b.MainThreadLanguageModels),d(1,w),d(2,D),d(3,I),d(4,$),d(5,T),d(6,F)],g);class N{constructor(e,s,t){this.id=e;this.label=s;this._accountLabel=t}supportsMultipleAccounts=!1;_onDidChangeSessions=new M;onDidChangeSessions=this._onDidChangeSessions.event;_session;async getSessions(e){return e===void 0&&!this._session?[]:this._session?[this._session]:[await this.createSession(e||[])]}async createSession(e){return this._session=this._createFakeSession(e),this._onDidChangeSessions.fire({added:[this._session],changed:[],removed:[]}),this._session}removeSession(e){return this._session&&(this._onDidChangeSessions.fire({added:[],changed:[],removed:[this._session]}),this._session=void 0),Promise.resolve()}_createFakeSession(e){return{id:"fake-session",account:{id:this.id,label:this._accountLabel},accessToken:"fake-access-token",scopes:e}}}export{g as MainThreadLanguageModels};
