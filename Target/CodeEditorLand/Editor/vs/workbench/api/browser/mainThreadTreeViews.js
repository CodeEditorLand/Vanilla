var I=Object.defineProperty;var w=Object.getOwnPropertyDescriptor;var T=(o,s,e,r)=>{for(var t=r>1?void 0:r?w(s,e):s,i=o.length-1,a;i>=0;i--)(a=o[i])&&(t=(r?a(s,e,t):a(t))||t);return r&&t&&I(s,e,t),t},c=(o,s)=>(e,r)=>s(e,r,o);import{distinct as D}from"../../../base/common/arrays.js";import{VSDataTransfer as x,createStringDataTransferItem as S}from"../../../base/common/dataTransfer.js";import{Disposable as C,DisposableMap as b,DisposableStore as M}from"../../../base/common/lifecycle.js";import{isNumber as V,isUndefinedOrNull as y}from"../../../base/common/types.js";import{ILogService as P}from"../../../platform/log/common/log.js";import{INotificationService as _}from"../../../platform/notification/common/notification.js";import{Registry as $}from"../../../platform/registry/common/platform.js";import{Extensions as E,NoTreeViewError as H,ResolvableTreeItem as v}from"../../common/views.js";import{extHostNamedCustomer as R}from"../../services/extensions/common/extHostCustomers.js";import{IExtensionService as k}from"../../services/extensions/common/extensions.js";import{IViewsService as A}from"../../services/views/common/viewsService.js";import{ExtHostContext as F,MainContext as N}from"../common/extHost.protocol.js";import*as O from"../common/extHostTypeConverters.js";import{DataTransferFileCache as j}from"../common/shared/dataTransferCache.js";let f=class extends C{constructor(e,r,t,i,a){super();this.viewsService=r;this.notificationService=t;this.extensionService=i;this.logService=a;this._proxy=e.getProxy(F.ExtHostTreeViews)}_proxy;_dataProviders=this._register(new b);_dndControllers=new Map;async $registerTreeViewDataProvider(e,r){this.logService.trace("MainThreadTreeViews#$registerTreeViewDataProvider",e,r),this.extensionService.whenInstalledExtensionsRegistered().then(()=>{const t=new L(e,this._proxy,this.notificationService),i=new M;this._dataProviders.set(e,{dataProvider:t,dispose:()=>i.dispose()});const a=r.hasHandleDrag||r.hasHandleDrop?new B(e,r.dropMimeTypes,r.dragMimeTypes,r.hasHandleDrag,this._proxy):void 0,n=this.getTreeView(e);n?(n.showCollapseAllAction=r.showCollapseAll,n.canSelectMany=r.canSelectMany,n.manuallyManageCheckboxes=r.manuallyManageCheckboxes,n.dragAndDropController=a,a&&this._dndControllers.set(e,a),n.dataProvider=t,this.registerListeners(e,n,i),this._proxy.$setVisible(e,n.visible)):this.notificationService.error("No view is registered with id: "+e)})}$reveal(e,r,t){return this.logService.trace("MainThreadTreeViews#$reveal",e,r?.item,r?.parentChain,t),this.viewsService.openView(e,t.focus).then(()=>{const i=this.getTreeView(e);if(i&&r)return this.reveal(i,this._dataProviders.get(e).dataProvider,r.item,r.parentChain,t)})}$refresh(e,r){this.logService.trace("MainThreadTreeViews#$refresh",e,r);const t=this.getTreeView(e),i=this._dataProviders.get(e);if(t&&i){const a=i.dataProvider.getItemsToRefresh(r);return t.refresh(a.length?a:void 0)}return Promise.resolve()}$setMessage(e,r){this.logService.trace("MainThreadTreeViews#$setMessage",e,r.toString());const t=this.getTreeView(e);t&&(t.message=r)}$setTitle(e,r,t){this.logService.trace("MainThreadTreeViews#$setTitle",e,r,t);const i=this.getTreeView(e);i&&(i.title=r,i.description=t)}$setBadge(e,r){this.logService.trace("MainThreadTreeViews#$setBadge",e,r?.value,r?.tooltip);const t=this.getTreeView(e);t&&(t.badge=r)}$resolveDropFileData(e,r,t){const i=this._dndControllers.get(e);if(!i)throw new Error("Unknown tree");return i.resolveDropFileData(r,t)}async $disposeTree(e){const r=this.getTreeView(e);r&&(r.dataProvider=void 0),this._dataProviders.deleteAndDispose(e)}async reveal(e,r,t,i,a){a=a||{select:!1,focus:!1};const n=y(a.select)?!1:a.select,h=y(a.focus)?!1:a.focus;let g=Math.min(V(a.expand)?a.expand:a.expand===!0?1:0,3);r.isEmpty()&&await e.refresh();for(const d of i){const p=r.getItem(d.handle);p&&await e.expand(p)}const l=r.getItem(t.handle);if(l){await e.reveal(l),n&&e.setSelection([l]),h===!1?e.setFocus():h&&e.setFocus(l);let d=[l];for(;d.length>0&&g>0;g--)await e.expand(d),d=d.reduce((p,u)=>{const m=r.getItem(u.handle);return m&&m.children&&m.children.length&&p.push(...m.children),p},[])}}registerListeners(e,r,t){t.add(r.onDidExpandItem(i=>this._proxy.$setExpanded(e,i.handle,!0))),t.add(r.onDidCollapseItem(i=>this._proxy.$setExpanded(e,i.handle,!1))),t.add(r.onDidChangeSelectionAndFocus(i=>this._proxy.$setSelectionAndFocus(e,i.selection.map(({handle:a})=>a),i.focus.handle))),t.add(r.onDidChangeVisibility(i=>this._proxy.$setVisible(e,i))),t.add(r.onDidChangeCheckboxState(i=>{this._proxy.$changeCheckboxState(e,i.map(a=>({treeItemHandle:a.handle,newState:a.checkbox?.isChecked??!1})))}))}getTreeView(e){const r=$.as(E.ViewsRegistry).getView(e);return r?r.treeView:null}dispose(){for(const e of this._dataProviders){const r=this.getTreeView(e[0]);r&&(r.dataProvider=void 0)}this._dataProviders.dispose(),this._dndControllers.clear(),super.dispose()}};f=T([R(N.MainThreadTreeViews),c(1,A),c(2,_),c(3,k),c(4,P)],f);class B{constructor(s,e,r,t,i){this.treeViewId=s;this.dropMimeTypes=e;this.dragMimeTypes=r;this.hasWillDrop=t;this._proxy=i}dataTransfersCache=new j;async handleDrop(s,e,r,t,i,a){const n=this.dataTransfersCache.add(s);try{const h=await O.DataTransfer.from(s);return r.isCancellationRequested?void 0:await this._proxy.$handleDrop(this.treeViewId,n.id,h,e?.handle,r,t,i,a)}finally{n.dispose()}}async handleDrag(s,e,r){if(!this.hasWillDrop)return;const t=await this._proxy.$handleDrag(this.treeViewId,s,e,r);if(!t)return;const i=new x;return t.items.forEach(([a,n])=>{i.replace(a,S(n.asString))}),i}resolveDropFileData(s,e){return this.dataTransfersCache.resolveFileData(s,e)}}class L{constructor(s,e,r){this.treeViewId=s;this._proxy=e;this.notificationService=r;this.hasResolve=this._proxy.$hasResolve(this.treeViewId)}itemsMap=new Map;hasResolve;getChildren(s){return s||this.itemsMap.clear(),this._proxy.$getChildren(this.treeViewId,s?s.handle:void 0).then(e=>this.postGetChildren(e),e=>(H.is(e)||this.notificationService.error(e),[]))}getItemsToRefresh(s){const e=[];if(s)for(const r of Object.keys(s)){const t=this.getItem(r);if(t){const i=s[r];if(this.updateTreeItem(t,i),r===i.handle)e.push(t);else{this.itemsMap.delete(r),this.itemsMap.set(t.handle,t);const a=i.parentHandle?this.itemsMap.get(i.parentHandle):null;a&&e.push(a)}}}return e}getItem(s){return this.itemsMap.get(s)}isEmpty(){return this.itemsMap.size===0}async postGetChildren(s){if(s===void 0)return;const e=[],r=await this.hasResolve;if(s)for(const t of s){const i=new v(t,r?a=>this._proxy.$resolve(this.treeViewId,t.handle,a):void 0);this.itemsMap.set(t.handle,i),e.push(i)}return e}updateTreeItem(s,e){if(e.children=e.children?e.children:void 0,s){const r=D([...Object.keys(s instanceof v?s.asTreeItem():s),...Object.keys(e)]);for(const t of r)s[t]=e[t];s instanceof v&&s.resetResolve()}}}export{f as MainThreadTreeViews};
