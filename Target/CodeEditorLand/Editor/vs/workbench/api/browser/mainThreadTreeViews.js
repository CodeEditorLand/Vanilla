var y=Object.defineProperty;var w=Object.getOwnPropertyDescriptor;var T=(o,s,e,r)=>{for(var t=r>1?void 0:r?w(s,e):s,i=o.length-1,a;i>=0;i--)(a=o[i])&&(t=(r?a(s,e,t):a(t))||t);return r&&t&&y(s,e,t),t},c=(o,s)=>(e,r)=>s(e,r,o);import{distinct as D}from"../../../../vs/base/common/arrays.js";import"../../../../vs/base/common/buffer.js";import"../../../../vs/base/common/cancellation.js";import{createStringDataTransferItem as x,VSDataTransfer as S}from"../../../../vs/base/common/dataTransfer.js";import"../../../../vs/base/common/htmlContent.js";import{Disposable as C,DisposableMap as M,DisposableStore as V}from"../../../../vs/base/common/lifecycle.js";import{isNumber as P,isUndefinedOrNull as u}from"../../../../vs/base/common/types.js";import{ILogService as b}from"../../../../vs/platform/log/common/log.js";import{INotificationService as _}from"../../../../vs/platform/notification/common/notification.js";import{Registry as $}from"../../../../vs/platform/registry/common/platform.js";import{ExtHostContext as E,MainContext as H}from"../../../../vs/workbench/api/common/extHost.protocol.js";import*as R from"../../../../vs/workbench/api/common/extHostTypeConverters.js";import{DataTransferFileCache as k}from"../../../../vs/workbench/api/common/shared/dataTransferCache.js";import{Extensions as A,NoTreeViewError as F,ResolvableTreeItem as m}from"../../../../vs/workbench/common/views.js";import{IExtensionService as N}from"../../../../vs/workbench/services/extensions/common/extensions.js";import{extHostNamedCustomer as O}from"../../../../vs/workbench/services/extensions/common/extHostCustomers.js";import{IViewsService as B}from"../../../../vs/workbench/services/views/common/viewsService.js";let v=class extends C{constructor(e,r,t,i,a){super();this.viewsService=r;this.notificationService=t;this.extensionService=i;this.logService=a;this._proxy=e.getProxy(E.ExtHostTreeViews)}_proxy;_dataProviders=this._register(new M);_dndControllers=new Map;async $registerTreeViewDataProvider(e,r){this.logService.trace("MainThreadTreeViews#$registerTreeViewDataProvider",e,r),this.extensionService.whenInstalledExtensionsRegistered().then(()=>{const t=new U(e,this._proxy,this.notificationService),i=new V;this._dataProviders.set(e,{dataProvider:t,dispose:()=>i.dispose()});const a=r.hasHandleDrag||r.hasHandleDrop?new L(e,r.dropMimeTypes,r.dragMimeTypes,r.hasHandleDrag,this._proxy):void 0,n=this.getTreeView(e);n?(n.showCollapseAllAction=r.showCollapseAll,n.canSelectMany=r.canSelectMany,n.manuallyManageCheckboxes=r.manuallyManageCheckboxes,n.dragAndDropController=a,a&&this._dndControllers.set(e,a),n.dataProvider=t,this.registerListeners(e,n,i),this._proxy.$setVisible(e,n.visible)):this.notificationService.error("No view is registered with id: "+e)})}$reveal(e,r,t){return this.logService.trace("MainThreadTreeViews#$reveal",e,r?.item,r?.parentChain,t),this.viewsService.openView(e,t.focus).then(()=>{const i=this.getTreeView(e);if(i&&r)return this.reveal(i,this._dataProviders.get(e).dataProvider,r.item,r.parentChain,t)})}$refresh(e,r){this.logService.trace("MainThreadTreeViews#$refresh",e,r);const t=this.getTreeView(e),i=this._dataProviders.get(e);if(t&&i){const a=i.dataProvider.getItemsToRefresh(r);return t.refresh(a.length?a:void 0)}return Promise.resolve()}$setMessage(e,r){this.logService.trace("MainThreadTreeViews#$setMessage",e,r.toString());const t=this.getTreeView(e);t&&(t.message=r)}$setTitle(e,r,t){this.logService.trace("MainThreadTreeViews#$setTitle",e,r,t);const i=this.getTreeView(e);i&&(i.title=r,i.description=t)}$setBadge(e,r){this.logService.trace("MainThreadTreeViews#$setBadge",e,r?.value,r?.tooltip);const t=this.getTreeView(e);t&&(t.badge=r)}$resolveDropFileData(e,r,t){const i=this._dndControllers.get(e);if(!i)throw new Error("Unknown tree");return i.resolveDropFileData(r,t)}async $disposeTree(e){const r=this.getTreeView(e);r&&(r.dataProvider=void 0),this._dataProviders.deleteAndDispose(e)}async reveal(e,r,t,i,a){a=a||{select:!1,focus:!1};const n=u(a.select)?!1:a.select,p=u(a.focus)?!1:a.focus;let g=Math.min(P(a.expand)?a.expand:a.expand===!0?1:0,3);r.isEmpty()&&await e.refresh();for(const d of i){const h=r.getItem(d.handle);h&&await e.expand(h)}const l=r.getItem(t.handle);if(l){await e.reveal(l),n&&e.setSelection([l]),p===!1?e.setFocus():p&&e.setFocus(l);let d=[l];for(;d.length>0&&g>0;g--)await e.expand(d),d=d.reduce((h,I)=>{const f=r.getItem(I.handle);return f&&f.children&&f.children.length&&h.push(...f.children),h},[])}}registerListeners(e,r,t){t.add(r.onDidExpandItem(i=>this._proxy.$setExpanded(e,i.handle,!0))),t.add(r.onDidCollapseItem(i=>this._proxy.$setExpanded(e,i.handle,!1))),t.add(r.onDidChangeSelectionAndFocus(i=>this._proxy.$setSelectionAndFocus(e,i.selection.map(({handle:a})=>a),i.focus.handle))),t.add(r.onDidChangeVisibility(i=>this._proxy.$setVisible(e,i))),t.add(r.onDidChangeCheckboxState(i=>{this._proxy.$changeCheckboxState(e,i.map(a=>({treeItemHandle:a.handle,newState:a.checkbox?.isChecked??!1})))}))}getTreeView(e){const r=$.as(A.ViewsRegistry).getView(e);return r?r.treeView:null}dispose(){for(const e of this._dataProviders){const r=this.getTreeView(e[0]);r&&(r.dataProvider=void 0)}this._dataProviders.dispose(),this._dndControllers.clear(),super.dispose()}};v=T([O(H.MainThreadTreeViews),c(1,B),c(2,_),c(3,N),c(4,b)],v);class L{constructor(s,e,r,t,i){this.treeViewId=s;this.dropMimeTypes=e;this.dragMimeTypes=r;this.hasWillDrop=t;this._proxy=i}dataTransfersCache=new k;async handleDrop(s,e,r,t,i,a){const n=this.dataTransfersCache.add(s);try{const p=await R.DataTransfer.from(s);return r.isCancellationRequested?void 0:await this._proxy.$handleDrop(this.treeViewId,n.id,p,e?.handle,r,t,i,a)}finally{n.dispose()}}async handleDrag(s,e,r){if(!this.hasWillDrop)return;const t=await this._proxy.$handleDrag(this.treeViewId,s,e,r);if(!t)return;const i=new S;return t.items.forEach(([a,n])=>{i.replace(a,x(n.asString))}),i}resolveDropFileData(s,e){return this.dataTransfersCache.resolveFileData(s,e)}}class U{constructor(s,e,r){this.treeViewId=s;this._proxy=e;this.notificationService=r;this.hasResolve=this._proxy.$hasResolve(this.treeViewId)}itemsMap=new Map;hasResolve;getChildren(s){return s||this.itemsMap.clear(),this._proxy.$getChildren(this.treeViewId,s?s.handle:void 0).then(e=>this.postGetChildren(e),e=>(F.is(e)||this.notificationService.error(e),[]))}getItemsToRefresh(s){const e=[];if(s)for(const r of Object.keys(s)){const t=this.getItem(r);if(t){const i=s[r];if(this.updateTreeItem(t,i),r===i.handle)e.push(t);else{this.itemsMap.delete(r),this.itemsMap.set(t.handle,t);const a=i.parentHandle?this.itemsMap.get(i.parentHandle):null;a&&e.push(a)}}}return e}getItem(s){return this.itemsMap.get(s)}isEmpty(){return this.itemsMap.size===0}async postGetChildren(s){if(s===void 0)return;const e=[],r=await this.hasResolve;if(s)for(const t of s){const i=new m(t,r?a=>this._proxy.$resolve(this.treeViewId,t.handle,a):void 0);this.itemsMap.set(t.handle,i),e.push(i)}return e}updateTreeItem(s,e){if(e.children=e.children?e.children:void 0,s){const r=D([...Object.keys(s instanceof m?s.asTreeItem():s),...Object.keys(e)]);for(const t of r)s[t]=e[t];s instanceof m&&s.resetResolve()}}}export{v as MainThreadTreeViews};
