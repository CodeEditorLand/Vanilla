var T=Object.defineProperty;var c=Object.getOwnPropertyDescriptor;var i=(s,l,o,t)=>{for(var e=t>1?void 0:t?c(l,o):l,n=s.length-1,a;n>=0;n--)(a=s[n])&&(e=(t?a(l,o,e):a(e))||e);return t&&e&&T(l,o,e),e},g=(s,l)=>(o,t)=>l(o,t,s);import"../../../base/common/cancellation.js";import{Disposable as u,DisposableMap as p}from"../../../base/common/lifecycle.js";import{ILanguageModelToolsService as d}from"../../contrib/chat/common/languageModelToolsService.js";import{extHostNamedCustomer as h}from"../../services/extensions/common/extHostCustomers.js";import{ExtHostContext as v,MainContext as k}from"../common/extHost.protocol.js";let r=class extends u{constructor(o,t){super();this._languageModelToolsService=t;this._proxy=o.getProxy(v.ExtHostLanguageModelTools),this._register(this._languageModelToolsService.onDidChangeTools(e=>this._proxy.$onDidChangeTools([...this._languageModelToolsService.getTools()])))}_proxy;_tools=this._register(new p);_countTokenCallbacks=new Map;async $getTools(){return Array.from(this._languageModelToolsService.getTools())}$invokeTool(o,t){return this._languageModelToolsService.invokeTool(o,(e,n)=>this._proxy.$countTokensForInvocation(o.callId,e,n),t)}$countTokensForInvocation(o,t,e){const n=this._countTokenCallbacks.get(o);if(!n)throw new Error(`Tool invocation call ${o} not found`);return n(t,e)}$registerTool(o){const t=this._languageModelToolsService.registerToolImplementation(o,{invoke:async(e,n,a)=>{try{return this._countTokenCallbacks.set(e.callId,n),await this._proxy.$invokeTool(e,a)}finally{this._countTokenCallbacks.delete(e.callId)}}});this._tools.set(o,t)}$unregisterTool(o){this._tools.deleteAndDispose(o)}};r=i([h(k.MainThreadLanguageModelTools),g(1,d)],r);export{r as MainThreadLanguageModelTools};
