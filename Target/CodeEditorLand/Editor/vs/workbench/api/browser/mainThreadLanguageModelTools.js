var T=Object.defineProperty;var c=Object.getOwnPropertyDescriptor;var r=(a,s,o,n)=>{for(var e=n>1?void 0:n?c(s,o):s,t=a.length-1,l;t>=0;t--)(l=a[t])&&(e=(n?l(s,o,e):l(e))||e);return n&&e&&T(s,o,e),e},g=(a,s)=>(o,n)=>s(o,n,a);import"../../../base/common/cancellation.js";import{Disposable as p,DisposableMap as u}from"../../../base/common/lifecycle.js";import{ILanguageModelToolsService as v}from"../../contrib/chat/common/languageModelToolsService.js";import{extHostNamedCustomer as d}from"../../services/extensions/common/extHostCustomers.js";import{ExtHostContext as h,MainContext as m}from"../common/extHost.protocol.js";let i=class extends p{constructor(o,n){super();this._languageModelToolsService=n;this._proxy=o.getProxy(h.ExtHostLanguageModelTools),this._register(this._languageModelToolsService.onDidChangeTools(e=>this._proxy.$onDidChangeTools([...this._languageModelToolsService.getTools()])))}_proxy;_tools=this._register(new u);_countTokenCallbacks=new Map;async $getTools(){return Array.from(this._languageModelToolsService.getTools())}async $invokeTool(o,n){return await this._languageModelToolsService.invokeTool(o,(e,t)=>this._proxy.$countTokensForInvocation(o.callId,e,t),n)}$countTokensForInvocation(o,n,e){const t=this._countTokenCallbacks.get(o);if(!t)throw new Error(`Tool invocation call ${o} not found`);return t(n,e)}$registerTool(o){const n=this._languageModelToolsService.registerToolImplementation(o,{invoke:async(e,t,l)=>{try{return this._countTokenCallbacks.set(e.callId,t),await this._proxy.$invokeTool(e,l)}finally{this._countTokenCallbacks.delete(e.callId)}},provideToolConfirmationMessages:(e,t,l)=>this._proxy.$provideToolConfirmationMessages(o,e,t,l),provideToolInvocationMessage:(e,t)=>this._proxy.$provideToolInvocationMessage(o,e,t)});this._tools.set(o,n)}$unregisterTool(o){this._tools.deleteAndDispose(o)}};i=r([d(m.MainThreadLanguageModelTools),g(1,v)],i);export{i as MainThreadLanguageModelTools};
