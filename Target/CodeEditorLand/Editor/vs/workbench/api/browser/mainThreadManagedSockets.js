var v=Object.defineProperty;var x=Object.getOwnPropertyDescriptor;var l=(s,n,e,t)=>{for(var o=t>1?void 0:t?x(n,e):n,r=s.length-1,i;r>=0;r--)(i=s[r])&&(o=(t?i(n,e,o):i(o))||o);return t&&o&&v(n,e,o),o},f=(s,n)=>(e,t)=>n(e,t,s);import{Emitter as k}from"../../../base/common/event.js";import{Disposable as M}from"../../../base/common/lifecycle.js";import{SocketCloseEventType as E}from"../../../base/parts/ipc/common/ipc.net.js";import{ManagedSocket as b,connectManagedSocket as _}from"../../../platform/remote/common/managedSocket.js";import{RemoteConnectionType as C}from"../../../platform/remote/common/remoteAuthorityResolver.js";import{IRemoteSocketFactoryService as H}from"../../../platform/remote/common/remoteSocketFactoryService.js";import{extHostNamedCustomer as R}from"../../services/extensions/common/extHostCustomers.js";import{ExtHostContext as D,MainContext as w}from"../common/extHost.protocol.js";let p=class extends M{constructor(e,t){super();this._remoteSocketFactoryService=t;this._proxy=e.getProxy(D.ExtHostManagedSockets)}_proxy;_registrations=new Map;_remoteSockets=new Map;async $registerSocketFactory(e){const t=this,o=new class{supports(r){return r.id===e}connect(r,i,a,d){return new Promise((u,S)=>{if(r.id!==e)return S(new Error("Invalid connectTo"));const h=r.id;t._proxy.$openRemoteSocket(h).then(c=>{const g={onClose:new k,onData:new k,onEnd:new k};t._remoteSockets.set(c,g),y.connect(c,t._proxy,i,a,d,g).then(m=>{m.onDidDispose(()=>t._remoteSockets.delete(c)),u(m)},m=>{t._remoteSockets.delete(c),S(m)})}).catch(S)})}};this._registrations.set(e,this._remoteSocketFactoryService.register(C.Managed,o))}async $unregisterSocketFactory(e){this._registrations.get(e)?.dispose()}$onDidManagedSocketHaveData(e,t){this._remoteSockets.get(e)?.onData.fire(t)}$onDidManagedSocketClose(e,t){this._remoteSockets.get(e)?.onClose.fire({type:E.NodeSocketCloseEvent,error:t?new Error(t):void 0,hadError:!!t}),this._remoteSockets.delete(e)}$onDidManagedSocketEnd(e){this._remoteSockets.get(e)?.onEnd.fire()}};p=l([R(w.MainThreadManagedSockets),f(1,H)],p);class y extends b{constructor(e,t,o,r){super(o,r);this.socketId=e;this.proxy=t}static connect(e,t,o,r,i,a){const d=new y(e,t,i,a);return _(d,o,r,i,a)}write(e){this.proxy.$remoteSocketWrite(this.socketId,e)}closeRemote(){this.proxy.$remoteSocketEnd(this.socketId)}drain(){return this.proxy.$remoteSocketDrain(this.socketId)}}export{y as MainThreadManagedSocket,p as MainThreadManagedSockets};
