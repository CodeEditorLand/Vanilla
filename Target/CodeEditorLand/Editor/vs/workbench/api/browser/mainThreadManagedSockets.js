var v=Object.defineProperty;var x=Object.getOwnPropertyDescriptor;var y=(s,n,e,t)=>{for(var o=t>1?void 0:t?x(n,e):n,r=s.length-1,i;r>=0;r--)(i=s[r])&&(o=(t?i(n,e,o):i(o))||o);return t&&o&&v(n,e,o),o},u=(s,n)=>(e,t)=>n(e,t,s);import"../../../base/common/buffer.js";import{Emitter as k}from"../../../base/common/event.js";import{Disposable as M}from"../../../base/common/lifecycle.js";import{SocketCloseEventType as E}from"../../../base/parts/ipc/common/ipc.net.js";import{ManagedSocket as _,connectManagedSocket as C}from"../../../platform/remote/common/managedSocket.js";import{RemoteConnectionType as H}from"../../../platform/remote/common/remoteAuthorityResolver.js";import{IRemoteSocketFactoryService as b}from"../../../platform/remote/common/remoteSocketFactoryService.js";import{ExtHostContext as R,MainContext as D}from"../common/extHost.protocol.js";import{extHostNamedCustomer as w}from"../../services/extensions/common/extHostCustomers.js";let d=class extends M{constructor(e,t){super();this._remoteSocketFactoryService=t;this._proxy=e.getProxy(R.ExtHostManagedSockets)}_proxy;_registrations=new Map;_remoteSockets=new Map;async $registerSocketFactory(e){const t=this,o=new class{supports(r){return r.id===e}connect(r,i,a,p){return new Promise((f,S)=>{if(r.id!==e)return S(new Error("Invalid connectTo"));const h=r.id;t._proxy.$openRemoteSocket(h).then(c=>{const l={onClose:new k,onData:new k,onEnd:new k};t._remoteSockets.set(c,l),g.connect(c,t._proxy,i,a,p,l).then(m=>{m.onDidDispose(()=>t._remoteSockets.delete(c)),f(m)},m=>{t._remoteSockets.delete(c),S(m)})}).catch(S)})}};this._registrations.set(e,this._remoteSocketFactoryService.register(H.Managed,o))}async $unregisterSocketFactory(e){this._registrations.get(e)?.dispose()}$onDidManagedSocketHaveData(e,t){this._remoteSockets.get(e)?.onData.fire(t)}$onDidManagedSocketClose(e,t){this._remoteSockets.get(e)?.onClose.fire({type:E.NodeSocketCloseEvent,error:t?new Error(t):void 0,hadError:!!t}),this._remoteSockets.delete(e)}$onDidManagedSocketEnd(e){this._remoteSockets.get(e)?.onEnd.fire()}};d=y([w(D.MainThreadManagedSockets),u(1,b)],d);class g extends _{constructor(e,t,o,r){super(o,r);this.socketId=e;this.proxy=t}static connect(e,t,o,r,i,a){const p=new g(e,t,i,a);return C(p,o,r,i,a)}write(e){this.proxy.$remoteSocketWrite(this.socketId,e)}closeRemote(){this.proxy.$remoteSocketEnd(this.socketId)}drain(){return this.proxy.$remoteSocketDrain(this.socketId)}}export{g as MainThreadManagedSocket,d as MainThreadManagedSockets};
