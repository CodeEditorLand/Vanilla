var b=Object.defineProperty;var R=Object.getOwnPropertyDescriptor;var h=(c,d,e,o)=>{for(var r=o>1?void 0:o?R(d,e):d,n=c.length-1,s;n>=0;n--)(s=c[n])&&(r=(o?s(d,e,r):s(r))||r);return o&&r&&b(d,e,r),r},a=(c,d)=>(e,o)=>d(e,o,c);import{Disposable as E}from"../../../base/common/lifecycle.js";import*as P from"../../../nls.js";import{IConfigurationService as _}from"../../../platform/configuration/common/configuration.js";import{Extensions as p}from"../../../platform/configuration/common/configurationRegistry.js";import{IContextKeyService as I}from"../../../platform/contextkey/common/contextkey.js";import{ILogService as F}from"../../../platform/log/common/log.js";import{INotificationService as w,Severity as $}from"../../../platform/notification/common/notification.js";import{Registry as m}from"../../../platform/registry/common/platform.js";import{ITunnelService as H,TunnelProtocol as D}from"../../../platform/tunnel/common/tunnel.js";import{extHostNamedCustomer as N}from"../../services/extensions/common/extHostCustomers.js";import{IRemoteAgentService as O}from"../../services/remote/common/remoteAgentService.js";import{IRemoteExplorerService as U,PORT_AUTO_FORWARD_SETTING as y,PORT_AUTO_SOURCE_SETTING as g,PORT_AUTO_SOURCE_SETTING_HYBRID as k,PORT_AUTO_SOURCE_SETTING_OUTPUT as S}from"../../services/remote/common/remoteExplorerService.js";import{TunnelCloseReason as T,TunnelSource as A,forwardedPortsViewEnabled as M,makeAddress as K}from"../../services/remote/common/tunnelModel.js";import{CandidatePortSource as v,ExtHostContext as G,MainContext as V}from"../common/extHost.protocol.js";import{TunnelDtoConverter as z}from"../common/extHostTunnelService.js";let u=class extends E{constructor(e,o,r,n,s,i,t,l){super();this.remoteExplorerService=o;this.tunnelService=r;this.notificationService=n;this.configurationService=s;this.logService=i;this.remoteAgentService=t;this.contextKeyService=l;this._proxy=e.getProxy(G.ExtHostTunnelService),this._register(r.onTunnelOpened(()=>this._proxy.$onDidTunnelsChange())),this._register(r.onTunnelClosed(()=>this._proxy.$onDidTunnelsChange()))}_proxy;elevateionRetry=!1;portsAttributesProviders=new Map;processFindingEnabled(){return(!!this.configurationService.getValue(y)||this.tunnelService.hasTunnelProvider)&&this.configurationService.getValue(g)!==S}async $setRemoteTunnelService(e){this.remoteExplorerService.namedProcesses.set(e,"Code Extension Host"),this.remoteExplorerService.portsFeaturesEnabled?this._proxy.$registerCandidateFinder(this.processFindingEnabled()):this._register(this.remoteExplorerService.onEnabledPortsFeatures(()=>this._proxy.$registerCandidateFinder(this.processFindingEnabled()))),this._register(this.configurationService.onDidChangeConfiguration(async o=>{if(this.remoteExplorerService.portsFeaturesEnabled&&(o.affectsConfiguration(y)||o.affectsConfiguration(g)))return this._proxy.$registerCandidateFinder(this.processFindingEnabled())})),this._register(this.tunnelService.onAddedTunnelProvider(async()=>{if(this.remoteExplorerService.portsFeaturesEnabled)return this._proxy.$registerCandidateFinder(this.processFindingEnabled())}))}_alreadyRegistered=!1;async $registerPortsAttributesProvider(e,o){this.portsAttributesProviders.set(o,e),this._alreadyRegistered||(this.remoteExplorerService.tunnelModel.addAttributesProvider(this),this._alreadyRegistered=!0)}async $unregisterPortsAttributesProvider(e){this.portsAttributesProviders.delete(e)}async providePortAttributes(e,o,r,n){if(this.portsAttributesProviders.size===0)return[];const s=Array.from(this.portsAttributesProviders.entries()).filter(i=>{const t=i[1],l=typeof t.portRange=="number"?[t.portRange,t.portRange+1]:t.portRange,C=l?e.some(f=>l[0]<=f&&f<l[1]):!0,x=!t.commandPattern||r&&r.match(t.commandPattern);return C&&x}).map(i=>i[0]);return s.length===0?[]:this._proxy.$providePortAttributes(s,e,o,r,n)}async $openTunnel(e,o){const r=await this.remoteExplorerService.forward({remote:e.remoteAddress,local:e.localAddressPort,name:e.label,source:{source:A.Extension,description:o},elevateIfNeeded:!1});if(!(!r||typeof r=="string"))return!this.elevateionRetry&&e.localAddressPort!==void 0&&r.tunnelLocalPort!==void 0&&this.tunnelService.isPortPrivileged(e.localAddressPort)&&r.tunnelLocalPort!==e.localAddressPort&&this.tunnelService.canElevate&&this.elevationPrompt(e,r,o),z.fromServiceTunnel(r)}async elevationPrompt(e,o,r){return this.notificationService.prompt($.Info,P.localize("remote.tunnel.openTunnel","The extension {0} has forwarded port {1}. You'll need to run as superuser to use port {2} locally.",r,e.remoteAddress.port,e.localAddressPort),[{label:P.localize("remote.tunnelsView.elevationButton","Use Port {0} as Sudo...",o.tunnelRemotePort),run:async()=>{this.elevateionRetry=!0,await this.remoteExplorerService.close({host:o.tunnelRemoteHost,port:o.tunnelRemotePort},T.Other),await this.remoteExplorerService.forward({remote:e.remoteAddress,local:e.localAddressPort,name:e.label,source:{source:A.Extension,description:r},elevateIfNeeded:!0}),this.elevateionRetry=!1}}])}async $closeTunnel(e){return this.remoteExplorerService.close(e,T.Other)}async $getTunnels(){return(await this.tunnelService.tunnels).map(e=>({remoteAddress:{port:e.tunnelRemotePort,host:e.tunnelRemoteHost},localAddress:e.localAddress,privacy:e.privacy,protocol:e.protocol}))}async $onFoundNewCandidates(e){this.remoteExplorerService.onFoundNewCandidates(e)}async $setTunnelProvider(e){const o={forwardPort:(r,n)=>this._proxy.$forwardPort(r,n).then(i=>{if(i){if(typeof i=="string")return i}else return;const t=i;return this.logService.trace(`ForwardedPorts: (MainThreadTunnelService) New tunnel established by tunnel provider: ${t?.remoteAddress.host}:${t?.remoteAddress.port}`),{tunnelRemotePort:t.remoteAddress.port,tunnelRemoteHost:t.remoteAddress.host,localAddress:typeof t.localAddress=="string"?t.localAddress:K(t.localAddress.host,t.localAddress.port),tunnelLocalPort:typeof t.localAddress!="string"?t.localAddress.port:void 0,public:t.public,privacy:t.privacy,protocol:t.protocol??D.Http,dispose:async l=>(this.logService.trace(`ForwardedPorts: (MainThreadTunnelService) Closing tunnel from tunnel provider: ${t?.remoteAddress.host}:${t?.remoteAddress.port}`),this._proxy.$closeTunnel({host:t.remoteAddress.host,port:t.remoteAddress.port},l))}})};e&&this.tunnelService.setTunnelFeatures(e),this.tunnelService.setTunnelProvider(o),this.contextKeyService.createKey(M.key,!0)}async $setCandidateFilter(){this.remoteExplorerService.setCandidateFilter(e=>this._proxy.$applyCandidateFilter(e))}async $setCandidatePortSource(e){this.remoteAgentService.getEnvironment().then(()=>{switch(e){case v.None:{m.as(p.Configuration).registerDefaultConfigurations([{overrides:{"remote.autoForwardPorts":!1}}]);break}case v.Output:{m.as(p.Configuration).registerDefaultConfigurations([{overrides:{"remote.autoForwardPortsSource":S}}]);break}case v.Hybrid:{m.as(p.Configuration).registerDefaultConfigurations([{overrides:{"remote.autoForwardPortsSource":k}}]);break}default:}}).catch(()=>{})}};u=h([N(V.MainThreadTunnelService),a(1,U),a(2,H),a(3,w),a(4,_),a(5,F),a(6,O),a(7,I)],u);export{u as MainThreadTunnelService};
