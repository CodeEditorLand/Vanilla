var R=Object.defineProperty;var E=Object.getOwnPropertyDescriptor;var g=(l,d,e,t)=>{for(var r=t>1?void 0:t?E(d,e):d,s=l.length-1,n;s>=0;s--)(n=l[s])&&(r=(t?n(d,e,r):n(r))||r);return t&&r&&R(d,e,r),r},a=(l,d)=>(e,t)=>d(e,t,l);import*as S from"../../../nls.js";import{MainContext as _,ExtHostContext as F,CandidatePortSource as m}from"../common/extHost.protocol.js";import{TunnelDtoConverter as I}from"../common/extHostTunnelService.js";import{extHostNamedCustomer as $}from"../../services/extensions/common/extHostCustomers.js";import{IRemoteExplorerService as w,PORT_AUTO_FORWARD_SETTING as y,PORT_AUTO_SOURCE_SETTING as T,PORT_AUTO_SOURCE_SETTING_HYBRID as H,PORT_AUTO_SOURCE_SETTING_OUTPUT as A,PortsEnablement as v}from"../../services/remote/common/remoteExplorerService.js";import{ITunnelService as D,TunnelProtocol as N}from"../../../platform/tunnel/common/tunnel.js";import{Disposable as O}from"../../../base/common/lifecycle.js";import{INotificationService as U,Severity as k}from"../../../platform/notification/common/notification.js";import{IConfigurationService as M}from"../../../platform/configuration/common/configuration.js";import{ILogService as K}from"../../../platform/log/common/log.js";import{IRemoteAgentService as G}from"../../services/remote/common/remoteAgentService.js";import"../../../base/common/cancellation.js";import{Registry as f}from"../../../platform/registry/common/platform.js";import{Extensions as h}from"../../../platform/configuration/common/configurationRegistry.js";import{IContextKeyService as z}from"../../../platform/contextkey/common/contextkey.js";import{TunnelCloseReason as C,TunnelSource as b,forwardedPortsFeaturesEnabled as L,makeAddress as V}from"../../services/remote/common/tunnelModel.js";let c=class extends O{constructor(e,t,r,s,n,u,i,o){super();this.remoteExplorerService=t;this.tunnelService=r;this.notificationService=s;this.configurationService=n;this.logService=u;this.remoteAgentService=i;this.contextKeyService=o;this._proxy=e.getProxy(F.ExtHostTunnelService),this._register(r.onTunnelOpened(()=>this._proxy.$onDidTunnelsChange())),this._register(r.onTunnelClosed(()=>this._proxy.$onDidTunnelsChange()))}_proxy;elevateionRetry=!1;portsAttributesProviders=new Map;processFindingEnabled(){return(!!this.configurationService.getValue(y)||this.tunnelService.hasTunnelProvider)&&this.configurationService.getValue(T)!==A}async $setRemoteTunnelService(e){this.remoteExplorerService.namedProcesses.set(e,"Code Extension Host"),this.remoteExplorerService.portsFeaturesEnabled===v.AdditionalFeatures?this._proxy.$registerCandidateFinder(this.processFindingEnabled()):this._register(this.remoteExplorerService.onEnabledPortsFeatures(()=>this._proxy.$registerCandidateFinder(this.processFindingEnabled()))),this._register(this.configurationService.onDidChangeConfiguration(async t=>{if(this.remoteExplorerService.portsFeaturesEnabled===v.AdditionalFeatures&&(t.affectsConfiguration(y)||t.affectsConfiguration(T)))return this._proxy.$registerCandidateFinder(this.processFindingEnabled())})),this._register(this.tunnelService.onAddedTunnelProvider(async()=>{if(this.remoteExplorerService.portsFeaturesEnabled===v.AdditionalFeatures)return this._proxy.$registerCandidateFinder(this.processFindingEnabled())}))}_alreadyRegistered=!1;async $registerPortsAttributesProvider(e,t){this.portsAttributesProviders.set(t,e),this._alreadyRegistered||(this.remoteExplorerService.tunnelModel.addAttributesProvider(this),this._alreadyRegistered=!0)}async $unregisterPortsAttributesProvider(e){this.portsAttributesProviders.delete(e)}async providePortAttributes(e,t,r,s){if(this.portsAttributesProviders.size===0)return[];const n=Array.from(this.portsAttributesProviders.entries()).filter(u=>{const i=u[1],o=typeof i.portRange=="number"?[i.portRange,i.portRange+1]:i.portRange,p=o?e.some(P=>o[0]<=P&&P<o[1]):!0,x=!i.commandPattern||r&&r.match(i.commandPattern);return p&&x}).map(u=>u[0]);return n.length===0?[]:this._proxy.$providePortAttributes(n,e,t,r,s)}async $openTunnel(e,t){const r=await this.remoteExplorerService.forward({remote:e.remoteAddress,local:e.localAddressPort,name:e.label,source:{source:b.Extension,description:t},elevateIfNeeded:!1});if(!(!r||typeof r=="string"))return!this.elevateionRetry&&e.localAddressPort!==void 0&&r.tunnelLocalPort!==void 0&&this.tunnelService.isPortPrivileged(e.localAddressPort)&&r.tunnelLocalPort!==e.localAddressPort&&this.tunnelService.canElevate&&this.elevationPrompt(e,r,t),I.fromServiceTunnel(r)}async elevationPrompt(e,t,r){return this.notificationService.prompt(k.Info,S.localize("remote.tunnel.openTunnel","The extension {0} has forwarded port {1}. You'll need to run as superuser to use port {2} locally.",r,e.remoteAddress.port,e.localAddressPort),[{label:S.localize("remote.tunnelsView.elevationButton","Use Port {0} as Sudo...",t.tunnelRemotePort),run:async()=>{this.elevateionRetry=!0,await this.remoteExplorerService.close({host:t.tunnelRemoteHost,port:t.tunnelRemotePort},C.Other),await this.remoteExplorerService.forward({remote:e.remoteAddress,local:e.localAddressPort,name:e.label,source:{source:b.Extension,description:r},elevateIfNeeded:!0}),this.elevateionRetry=!1}}])}async $closeTunnel(e){return this.remoteExplorerService.close(e,C.Other)}async $getTunnels(){return(await this.tunnelService.tunnels).map(e=>({remoteAddress:{port:e.tunnelRemotePort,host:e.tunnelRemoteHost},localAddress:e.localAddress,privacy:e.privacy,protocol:e.protocol}))}async $onFoundNewCandidates(e){this.remoteExplorerService.onFoundNewCandidates(e)}async $setTunnelProvider(e,t){const r={forwardPort:(s,n)=>this._proxy.$forwardPort(s,n).then(i=>{if(i){if(typeof i=="string")return i}else return;const o=i;return this.logService.trace(`ForwardedPorts: (MainThreadTunnelService) New tunnel established by tunnel provider: ${o?.remoteAddress.host}:${o?.remoteAddress.port}`),{tunnelRemotePort:o.remoteAddress.port,tunnelRemoteHost:o.remoteAddress.host,localAddress:typeof o.localAddress=="string"?o.localAddress:V(o.localAddress.host,o.localAddress.port),tunnelLocalPort:typeof o.localAddress!="string"?o.localAddress.port:void 0,public:o.public,privacy:o.privacy,protocol:o.protocol??N.Http,dispose:async p=>(this.logService.trace(`ForwardedPorts: (MainThreadTunnelService) Closing tunnel from tunnel provider: ${o?.remoteAddress.host}:${o?.remoteAddress.port}`),this._proxy.$closeTunnel({host:o.remoteAddress.host,port:o.remoteAddress.port},p))}})};e&&this.tunnelService.setTunnelFeatures(e),this.tunnelService.setTunnelProvider(r),t&&this.contextKeyService.createKey(L.key,!0)}async $setCandidateFilter(){this.remoteExplorerService.setCandidateFilter(e=>this._proxy.$applyCandidateFilter(e))}async $setCandidatePortSource(e){this.remoteAgentService.getEnvironment().then(()=>{switch(e){case m.None:{f.as(h.Configuration).registerDefaultConfigurations([{overrides:{"remote.autoForwardPorts":!1}}]);break}case m.Output:{f.as(h.Configuration).registerDefaultConfigurations([{overrides:{"remote.autoForwardPortsSource":A}}]);break}case m.Hybrid:{f.as(h.Configuration).registerDefaultConfigurations([{overrides:{"remote.autoForwardPortsSource":H}}]);break}default:}}).catch(()=>{})}};c=g([$(_.MainThreadTunnelService),a(1,w),a(2,D),a(3,U),a(4,M),a(5,K),a(6,G),a(7,z)],c);export{c as MainThreadTunnelService};
