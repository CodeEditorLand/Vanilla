var u=Object.defineProperty;var I=Object.getOwnPropertyDescriptor;var v=(d,e,i,r)=>{for(var t=r>1?void 0:r?I(e,i):e,s=d.length-1,a;s>=0;s--)(a=d[s])&&(t=(r?a(e,i,t):a(t))||t);return r&&t&&u(e,i,t),t},c=(d,e)=>(i,r)=>e(i,r,d);import{VSBuffer as y}from"../../../base/common/buffer.js";import{Emitter as _,Event as f}from"../../../base/common/event.js";import"../../../base/common/htmlContent.js";import{DisposableMap as C,DisposableStore as P,toDisposable as b}from"../../../base/common/lifecycle.js";import{URI as n}from"../../../base/common/uri.js";import{FileOperationError as S,FileOperationResult as p,FilePermission as g,FileSystemProviderErrorCode as l,FileType as h,IFileService as E,toFileSystemProviderErrorCode as w}from"../../../platform/files/common/files.js";import{extHostNamedCustomer as x}from"../../services/extensions/common/extHostCustomers.js";import{ExtHostContext as F,MainContext as O}from"../common/extHost.protocol.js";let o=class{constructor(e,i){this._fileService=i;this._proxy=e.getProxy(F.ExtHostFileSystem);const r=e.getProxy(F.ExtHostFileSystemInfo);for(const t of i.listCapabilities())r.$acceptProviderInfos(n.from({scheme:t.scheme,path:"/dummy"}),t.capabilities);this._disposables.add(i.onDidChangeFileSystemProviderRegistrations(t=>r.$acceptProviderInfos(n.from({scheme:t.scheme,path:"/dummy"}),t.provider?.capabilities??null))),this._disposables.add(i.onDidChangeFileSystemProviderCapabilities(t=>r.$acceptProviderInfos(n.from({scheme:t.scheme,path:"/dummy"}),t.provider.capabilities)))}_proxy;_fileProvider=new C;_disposables=new P;dispose(){this._disposables.dispose(),this._fileProvider.dispose()}async $registerFileSystemProvider(e,i,r,t){this._fileProvider.set(e,new m(this._fileService,i,r,t,e,this._proxy))}$unregisterProvider(e){this._fileProvider.deleteAndDispose(e)}$onFileSystemChange(e,i){const r=this._fileProvider.get(e);if(!r)throw new Error("Unknown file provider");r.$onFileSystemChange(i)}$stat(e){return this._fileService.stat(n.revive(e)).then(i=>({ctime:i.ctime,mtime:i.mtime,size:i.size,permissions:i.readonly?g.Readonly:void 0,type:o._asFileType(i)})).catch(o._handleError)}$readdir(e){return this._fileService.resolve(n.revive(e),{resolveMetadata:!1}).then(i=>{if(!i.isDirectory){const r=new Error(i.name);throw r.name=l.FileNotADirectory,r}return i.children?i.children.map(r=>[r.name,o._asFileType(r)]):[]}).catch(o._handleError)}static _asFileType(e){let i=0;return e.isFile?i+=h.File:e.isDirectory&&(i+=h.Directory),e.isSymbolicLink&&(i+=h.SymbolicLink),i}$readFile(e){return this._fileService.readFile(n.revive(e)).then(i=>i.value).catch(o._handleError)}$writeFile(e,i){return this._fileService.writeFile(n.revive(e),i).then(()=>{}).catch(o._handleError)}$rename(e,i,r){return this._fileService.move(n.revive(e),n.revive(i),r.overwrite).then(()=>{}).catch(o._handleError)}$copy(e,i,r){return this._fileService.copy(n.revive(e),n.revive(i),r.overwrite).then(()=>{}).catch(o._handleError)}$mkdir(e){return this._fileService.createFolder(n.revive(e)).then(()=>{}).catch(o._handleError)}$delete(e,i){return this._fileService.del(n.revive(e),i).catch(o._handleError)}static _handleError(e){if(e instanceof S)switch(e.fileOperationResult){case p.FILE_NOT_FOUND:e.name=l.FileNotFound;break;case p.FILE_IS_DIRECTORY:e.name=l.FileIsADirectory;break;case p.FILE_PERMISSION_DENIED:e.name=l.NoPermissions;break;case p.FILE_MOVE_CONFLICT:e.name=l.FileExists;break}else if(e instanceof Error){const i=w(e);i!==l.Unknown&&(e.name=i)}throw e}$ensureActivation(e){return this._fileService.activateProvider(e)}};o=v([x(O.MainThreadFileSystem),c(1,E)],o);class m{constructor(e,i,r,t,s,a){this.readOnlyMessage=t;this._handle=s;this._proxy=a;this.capabilities=r,this._registration=e.registerProvider(i,this)}_onDidChange=new _;_registration;onDidChangeFile=this._onDidChange.event;capabilities;onDidChangeCapabilities=f.None;dispose(){this._registration.dispose(),this._onDidChange.dispose()}watch(e,i){const r=Math.random();return this._proxy.$watch(this._handle,r,e,i),b(()=>{this._proxy.$unwatch(this._handle,r)})}$onFileSystemChange(e){this._onDidChange.fire(e.map(m._createFileChange))}static _createFileChange(e){return{resource:n.revive(e.resource),type:e.type}}stat(e){return this._proxy.$stat(this._handle,e).then(void 0,i=>{throw i})}readFile(e){return this._proxy.$readFile(this._handle,e).then(i=>i.buffer)}writeFile(e,i,r){return this._proxy.$writeFile(this._handle,e,y.wrap(i),r)}delete(e,i){return this._proxy.$delete(this._handle,e,i)}mkdir(e){return this._proxy.$mkdir(this._handle,e)}readdir(e){return this._proxy.$readdir(this._handle,e)}rename(e,i,r){return this._proxy.$rename(this._handle,e,i,r)}copy(e,i,r){return this._proxy.$copy(this._handle,e,i,r)}open(e,i){return this._proxy.$open(this._handle,e,i)}close(e){return this._proxy.$close(this._handle,e)}read(e,i,r,t,s){return this._proxy.$read(this._handle,e,i,s).then(a=>(r.set(a.buffer,t),a.byteLength))}write(e,i,r,t,s){return this._proxy.$write(this._handle,e,i,y.wrap(r).slice(t,t+s))}}export{o as MainThreadFileSystem};
