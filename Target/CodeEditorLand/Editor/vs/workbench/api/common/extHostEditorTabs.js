var l=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var h=(d,t,i,e)=>{for(var o=e>1?void 0:e?g(t,i):t,r=d.length-1,u;r>=0;r--)(u=d[r])&&(o=(e?u(t,i,o):u(o))||o);return e&&o&&l(t,i,o),o},f=(d,t)=>(i,e)=>t(i,e,d);import{diffSets as x}from"../../../base/common/collections.js";import{Emitter as _}from"../../../base/common/event.js";import{assertIsDefined as I}from"../../../base/common/types.js";import{URI as a}from"../../../base/common/uri.js";import{createDecorator as m}from"../../../platform/instantiation/common/instantiation.js";import{MainContext as w,TabInputKind as n,TabModelOperationKind as p}from"./extHost.protocol.js";import{IExtHostRpcService as O}from"./extHostRpcService.js";import*as D from"./extHostTypeConverters.js";import{ChatEditorTabInput as j,CustomEditorTabInput as y,InteractiveWindowInput as H,NotebookDiffEditorTabInput as C,NotebookEditorTabInput as A,TerminalEditorTabInput as k,TextDiffTabInput as E,TextMergeTabInput as M,TextMultiDiffTabInput as P,TextTabInput as B,WebviewEditorTabInput as S}from"./extHostTypes.js";const J=m("IExtHostEditorTabs");class G{_apiObject;_dto;_input;_parentGroup;_activeTabIdGetter;constructor(t,i,e){this._activeTabIdGetter=e,this._parentGroup=i,this.acceptDtoUpdate(t)}get apiObject(){if(!this._apiObject){const t=this,i={get isActive(){return t._dto.id===t._activeTabIdGetter()},get label(){return t._dto.label},get input(){return t._input},get isDirty(){return t._dto.isDirty},get isPinned(){return t._dto.isPinned},get isPreview(){return t._dto.isPreview},get group(){return t._parentGroup.apiObject}};this._apiObject=Object.freeze(i)}return this._apiObject}get tabId(){return this._dto.id}acceptDtoUpdate(t){this._dto=t,this._input=this._initInput()}_initInput(){switch(this._dto.input.kind){case n.TextInput:return new B(a.revive(this._dto.input.uri));case n.TextDiffInput:return new E(a.revive(this._dto.input.original),a.revive(this._dto.input.modified));case n.TextMergeInput:return new M(a.revive(this._dto.input.base),a.revive(this._dto.input.input1),a.revive(this._dto.input.input2),a.revive(this._dto.input.result));case n.CustomEditorInput:return new y(a.revive(this._dto.input.uri),this._dto.input.viewType);case n.WebviewEditorInput:return new S(this._dto.input.viewType);case n.NotebookInput:return new A(a.revive(this._dto.input.uri),this._dto.input.notebookType);case n.NotebookDiffInput:return new C(a.revive(this._dto.input.original),a.revive(this._dto.input.modified),this._dto.input.notebookType);case n.TerminalEditorInput:return new k;case n.InteractiveEditorInput:return new H(a.revive(this._dto.input.uri),a.revive(this._dto.input.inputBoxUri));case n.ChatEditorInput:return new j;case n.MultiDiffEditorInput:return new P(this._dto.input.diffEditors.map(t=>new E(a.revive(t.original),a.revive(t.modified))));default:return}}}class U{_apiObject;_dto;_tabs=[];_activeTabId="";_activeGroupIdGetter;constructor(t,i){this._dto=t,this._activeGroupIdGetter=i;for(const e of t.tabs)e.isActive&&(this._activeTabId=e.id),this._tabs.push(new G(e,this,()=>this.activeTabId()))}get apiObject(){if(!this._apiObject){const t=this,i={get isActive(){return t._dto.groupId===t._activeGroupIdGetter()},get viewColumn(){return D.ViewColumn.to(t._dto.viewColumn)},get activeTab(){return t._tabs.find(e=>e.tabId===t._activeTabId)?.apiObject},get tabs(){return Object.freeze(t._tabs.map(e=>e.apiObject))}};this._apiObject=Object.freeze(i)}return this._apiObject}get groupId(){return this._dto.groupId}get tabs(){return this._tabs}acceptGroupDtoUpdate(t){this._dto=t}acceptTabOperation(t){if(t.kind===p.TAB_OPEN){const e=new G(t.tabDto,this,()=>this.activeTabId());return this._tabs.splice(t.index,0,e),t.tabDto.isActive&&(this._activeTabId=e.tabId),e}else if(t.kind===p.TAB_CLOSE){const e=this._tabs.splice(t.index,1)[0];if(!e)throw new Error(`Tab close updated received for index ${t.index} which does not exist`);return e.tabId===this._activeTabId&&(this._activeTabId=""),e}else if(t.kind===p.TAB_MOVE){if(t.oldIndex===void 0)throw new Error("Invalid old index on move IPC");const e=this._tabs.splice(t.oldIndex,1)[0];if(!e)throw new Error(`Tab move updated received for index ${t.oldIndex} which does not exist`);return this._tabs.splice(t.index,0,e),e}const i=this._tabs.find(e=>e.tabId===t.tabDto.id);if(!i)throw new Error("INVALID tab");return t.tabDto.isActive?this._activeTabId=t.tabDto.id:this._activeTabId===t.tabDto.id&&!t.tabDto.isActive&&(this._activeTabId=""),i.acceptDtoUpdate(t.tabDto),i}activeTabId(){return this._activeTabId}}let c=class{_serviceBrand;_proxy;_onDidChangeTabs=new _;_onDidChangeTabGroups=new _;_activeGroupId;_extHostTabGroups=[];_apiObject;constructor(t){this._proxy=t.getProxy(w.MainThreadEditorTabs)}get tabGroups(){if(!this._apiObject){const t=this,i={onDidChangeTabGroups:t._onDidChangeTabGroups.event,onDidChangeTabs:t._onDidChangeTabs.event,get all(){return Object.freeze(t._extHostTabGroups.map(e=>e.apiObject))},get activeTabGroup(){const e=t._activeGroupId;return I(t._extHostTabGroups.find(r=>r.groupId===e)?.apiObject)},close:async(e,o)=>{const r=Array.isArray(e)?e:[e];return r.length?z(r[0])?this._closeGroups(r,o):this._closeTabs(r,o):!0}};this._apiObject=Object.freeze(i)}return this._apiObject}$acceptEditorTabModel(t){const i=new Set(this._extHostTabGroups.map(s=>s.groupId)),e=new Set(t.map(s=>s.groupId)),o=x(i,e),r=this._extHostTabGroups.filter(s=>o.removed.includes(s.groupId)).map(s=>s.apiObject),u=[],v=[];this._extHostTabGroups=t.map(s=>{const b=new U(s,()=>this._activeGroupId);return o.added.includes(b.groupId)?u.push(b.apiObject):v.push(b.apiObject),b});const T=I(t.find(s=>s.isActive===!0)?.groupId);T!==void 0&&this._activeGroupId!==T&&(this._activeGroupId=T),this._onDidChangeTabGroups.fire(Object.freeze({opened:u,closed:r,changed:v}))}$acceptTabGroupUpdate(t){const i=this._extHostTabGroups.find(e=>e.groupId===t.groupId);if(!i)throw new Error("Update Group IPC call received before group creation.");i.acceptGroupDtoUpdate(t),t.isActive&&(this._activeGroupId=t.groupId),this._onDidChangeTabGroups.fire(Object.freeze({changed:[i.apiObject],opened:[],closed:[]}))}$acceptTabOperation(t){const i=this._extHostTabGroups.find(o=>o.groupId===t.groupId);if(!i)throw new Error("Update Tabs IPC call received before group creation.");const e=i.acceptTabOperation(t);switch(t.kind){case p.TAB_OPEN:this._onDidChangeTabs.fire(Object.freeze({opened:[e.apiObject],closed:[],changed:[]}));return;case p.TAB_CLOSE:this._onDidChangeTabs.fire(Object.freeze({opened:[],closed:[e.apiObject],changed:[]}));return;case p.TAB_MOVE:case p.TAB_UPDATE:this._onDidChangeTabs.fire(Object.freeze({opened:[],closed:[],changed:[e.apiObject]}));return}}_findExtHostTabFromApi(t){for(const i of this._extHostTabGroups)for(const e of i.tabs)if(e.apiObject===t)return e}_findExtHostTabGroupFromApi(t){return this._extHostTabGroups.find(i=>i.apiObject===t)}async _closeTabs(t,i){const e=[];for(const o of t){const r=this._findExtHostTabFromApi(o);if(!r)throw new Error("Tab close: Invalid tab not found!");e.push(r.tabId)}return this._proxy.$closeTab(e,i)}async _closeGroups(t,i){const e=[];for(const o of t){const r=this._findExtHostTabGroupFromApi(o);if(!r)throw new Error("Group close: Invalid group not found!");e.push(r.groupId)}return this._proxy.$closeGroup(e,i)}};c=h([f(0,O)],c);function z(d){return d.tabs!==void 0}export{c as ExtHostEditorTabs,J as IExtHostEditorTabs};
