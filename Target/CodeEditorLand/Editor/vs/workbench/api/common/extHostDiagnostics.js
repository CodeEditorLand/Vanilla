var I=Object.defineProperty;var x=Object.getOwnPropertyDescriptor;var D=(h,e,i,o)=>{for(var s=o>1?void 0:o?x(e,i):e,c=h.length-1,r;c>=0;c--)(r=h[c])&&(s=(o?r(e,i,s):r(s))||s);return o&&s&&I(e,i,s),s},u=(h,e)=>(i,o)=>e(i,o,h);import{DebounceEmitter as A,Event as C}from"../../../base/common/event.js";import{ResourceMap as _}from"../../../base/common/map.js";import{URI as U}from"../../../base/common/uri.js";import{localize as S}from"../../../nls.js";import{ILogService as R}from"../../../platform/log/common/log.js";import{MarkerSeverity as M}from"../../../platform/markers/common/markers.js";import{MainContext as k}from"./extHost.protocol.js";import{IExtHostFileSystemInfo as E}from"./extHostFileSystemInfo.js";import*as f from"./extHostTypeConverters.js";import{DiagnosticSeverity as m}from"./extHostTypes.js";class y{constructor(e,i,o,s,c,r,t,n){this._name=e;this._owner=i;this._maxDiagnosticsTotal=o;this._maxDiagnosticsPerFile=s;this._modelVersionIdProvider=c;this._maxDiagnosticsTotal=Math.max(s,o),this.#e=new _(d=>r.getComparisonKey(d)),this.#i=t,this.#o=n}#i;#o;#e;_isDisposed=!1;dispose(){this._isDisposed||(this.#o.fire([...this.#e.keys()]),this.#i?.$clear(this._owner),this.#e.clear(),this._isDisposed=!0)}get name(){return this._checkDisposed(),this._name}set(e,i){if(!e){this.clear();return}this._checkDisposed();let o=[];if(U.isUri(e)){if(!i){this.delete(e);return}this.#e.set(e,i.slice()),o=[e]}else if(Array.isArray(e)){o=[];let r;e=[...e].sort(y._compareIndexedTuplesByUri);for(const t of e){const[n,d]=t;if((!r||n.toString()!==r.toString())&&(r&&this.#e.get(r).length===0&&this.#e.delete(r),r=n,o.push(n),this.#e.set(n,[])),d)this.#e.get(n)?.push(...d);else{const a=this.#e.get(n);a&&(a.length=0)}}}if(this.#o.fire(o),!this.#i)return;const s=[];let c=0;for(const r of o){let t=[];const n=this.#e.get(r);if(n)if(n.length>this._maxDiagnosticsPerFile){t=[];const d=[m.Error,m.Warning,m.Information,m.Hint];e:for(let a=0;a<4;a++)for(const p of n)if(p.severity===d[a]&&t.push({...f.Diagnostic.from(p),modelVersionId:this._modelVersionIdProvider(r)})===this._maxDiagnosticsPerFile)break e;t.push({severity:M.Info,message:S({key:"limitHit",comment:["amount of errors/warning skipped due to limits"]},"Not showing {0} further errors and warnings.",n.length-this._maxDiagnosticsPerFile),startLineNumber:t[t.length-1].startLineNumber,startColumn:t[t.length-1].startColumn,endLineNumber:t[t.length-1].endLineNumber,endColumn:t[t.length-1].endColumn})}else t=n.map(d=>({...f.Diagnostic.from(d),modelVersionId:this._modelVersionIdProvider(r)}));if(s.push([r,t]),c+=t.length,c>this._maxDiagnosticsTotal)break}this.#i.$changeMany(this._owner,s)}delete(e){this._checkDisposed(),this.#o.fire([e]),this.#e.delete(e),this.#i?.$changeMany(this._owner,[[e,void 0]])}clear(){this._checkDisposed(),this.#o.fire([...this.#e.keys()]),this.#e.clear(),this.#i?.$clear(this._owner)}forEach(e,i){this._checkDisposed();for(const[o,s]of this)e.call(i,o,s,this)}*[Symbol.iterator](){this._checkDisposed();for(const e of this.#e.keys())yield[e,this.get(e)]}get(e){this._checkDisposed();const i=this.#e.get(e);return Array.isArray(i)?Object.freeze(i.slice(0)):[]}has(e){return this._checkDisposed(),Array.isArray(this.#e.get(e))}_checkDisposed(){if(this._isDisposed)throw new Error("illegal state - object is disposed")}static _compareIndexedTuplesByUri(e,i){return e[0].toString()<i[0].toString()?-1:e[0].toString()>i[0].toString()?1:0}}let l=class{constructor(e,i,o,s){this._logService=i;this._fileSystemInfoService=o;this._extHostDocumentsAndEditors=s;this._proxy=e.getProxy(k.MainThreadDiagnostics)}static _idPool=0;static _maxDiagnosticsPerFile=1e3;static _maxDiagnosticsTotal=1.1*this._maxDiagnosticsPerFile;_proxy;_collections=new Map;_onDidChangeDiagnostics=new A({merge:e=>e.flat(),delay:50});static _mapper(e){const i=new _;for(const o of e)i.set(o,o);return{uris:Object.freeze(Array.from(i.values()))}}onDidChangeDiagnostics=C.map(this._onDidChangeDiagnostics.event,l._mapper);createDiagnosticCollection(e,i){const{_collections:o,_proxy:s,_onDidChangeDiagnostics:c,_logService:r,_fileSystemInfoService:t,_extHostDocumentsAndEditors:n}=this,d=new class{$changeMany(g,v){s.$changeMany(g,v),r.trace("[DiagnosticCollection] change many (extension, owner, uris)",e.value,g,v.length===0?"CLEARING":v)}$clear(g){s.$clear(g),r.trace("[DiagnosticCollection] remove all (extension, owner)",e.value,g)}dispose(){s.dispose()}};let a;if(!i)i="_generated_diagnostic_collection_name_#"+l._idPool++,a=i;else if(o.has(i)){this._logService.warn(`DiagnosticCollection with name '${i}' does already exist.`);do a=i+l._idPool++;while(o.has(a))}else a=i;return new class extends y{constructor(){super(i,a,l._maxDiagnosticsTotal,l._maxDiagnosticsPerFile,g=>n.getDocument(g)?.version,t.extUri,d,c),o.set(a,this)}dispose(){super.dispose(),o.delete(a)}}}getDiagnostics(e){if(e)return this._getDiagnostics(e);{const i=new Map,o=[];for(const s of this._collections.values())s.forEach((c,r)=>{let t=i.get(c.toString());typeof t>"u"&&(t=o.length,i.set(c.toString(),t),o.push([c,[]])),o[t][1]=o[t][1].concat(...r)});return o}}_getDiagnostics(e){let i=[];for(const o of this._collections.values())o.has(e)&&(i=i.concat(o.get(e)));return i}_mirrorCollection;$acceptMarkersChange(e){if(!this._mirrorCollection){const i="_generated_mirror",o=new y(i,i,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,s=>{},this._fileSystemInfoService.extUri,void 0,this._onDidChangeDiagnostics);this._collections.set(i,o),this._mirrorCollection=o}for(const[i,o]of e)this._mirrorCollection.set(U.revive(i),o.map(f.Diagnostic.to))}};l=D([u(1,R),u(2,E)],l);export{y as DiagnosticCollection,l as ExtHostDiagnostics};
