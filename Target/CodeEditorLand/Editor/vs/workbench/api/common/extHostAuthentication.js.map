{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/api/common/extHostAuthentication.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type * as vscode from 'vscode';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { MainContext, MainThreadAuthenticationShape, ExtHostAuthenticationShape } from './extHost.protocol.js';\nimport { Disposable } from './extHostTypes.js';\nimport { IExtensionDescription, ExtensionIdentifier } from '../../../platform/extensions/common/extensions.js';\nimport { INTERNAL_AUTH_PROVIDER_PREFIX } from '../../services/authentication/common/authentication.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\n\nexport interface IExtHostAuthentication extends ExtHostAuthentication { }\nexport const IExtHostAuthentication = createDecorator<IExtHostAuthentication>('IExtHostAuthentication');\n\ninterface ProviderWithMetadata {\n\tlabel: string;\n\tprovider: vscode.AuthenticationProvider;\n\toptions: vscode.AuthenticationProviderOptions;\n}\n\nexport class ExtHostAuthentication implements ExtHostAuthenticationShape {\n\n\tdeclare _serviceBrand: undefined;\n\n\tprivate _proxy: MainThreadAuthenticationShape;\n\tprivate _authenticationProviders: Map<string, ProviderWithMetadata> = new Map<string, ProviderWithMetadata>();\n\n\tprivate _onDidChangeSessions = new Emitter<vscode.AuthenticationSessionsChangeEvent>();\n\treadonly onDidChangeSessions: Event<vscode.AuthenticationSessionsChangeEvent> = this._onDidChangeSessions.event;\n\n\tprivate _getSessionTaskSingler = new TaskSingler<vscode.AuthenticationSession | undefined>();\n\n\tconstructor(\n\t\t@IExtHostRpcService extHostRpc: IExtHostRpcService\n\t) {\n\t\tthis._proxy = extHostRpc.getProxy(MainContext.MainThreadAuthentication);\n\t}\n\n\tasync getSession(requestingExtension: IExtensionDescription, providerId: string, scopes: readonly string[], options: vscode.AuthenticationGetSessionOptions & ({ createIfNone: true } | { forceNewSession: true } | { forceNewSession: vscode.AuthenticationForceNewSessionOptions })): Promise<vscode.AuthenticationSession>;\n\tasync getSession(requestingExtension: IExtensionDescription, providerId: string, scopes: readonly string[], options: vscode.AuthenticationGetSessionOptions & { forceNewSession: true }): Promise<vscode.AuthenticationSession>;\n\tasync getSession(requestingExtension: IExtensionDescription, providerId: string, scopes: readonly string[], options: vscode.AuthenticationGetSessionOptions & { forceNewSession: vscode.AuthenticationForceNewSessionOptions }): Promise<vscode.AuthenticationSession>;\n\tasync getSession(requestingExtension: IExtensionDescription, providerId: string, scopes: readonly string[], options: vscode.AuthenticationGetSessionOptions): Promise<vscode.AuthenticationSession | undefined>;\n\tasync getSession(requestingExtension: IExtensionDescription, providerId: string, scopes: readonly string[], options: vscode.AuthenticationGetSessionOptions = {}): Promise<vscode.AuthenticationSession | undefined> {\n\t\tconst extensionId = ExtensionIdentifier.toKey(requestingExtension.identifier);\n\t\tconst sortedScopes = [...scopes].sort().join(' ');\n\t\treturn await this._getSessionTaskSingler.getOrCreate(`${extensionId} ${providerId} ${sortedScopes}`, async () => {\n\t\t\tawait this._proxy.$ensureProvider(providerId);\n\t\t\tconst extensionName = requestingExtension.displayName || requestingExtension.name;\n\t\t\treturn this._proxy.$getSession(providerId, scopes, extensionId, extensionName, options);\n\t\t});\n\t}\n\n\tasync getAccounts(providerId: string) {\n\t\tawait this._proxy.$ensureProvider(providerId);\n\t\treturn await this._proxy.$getAccounts(providerId);\n\t}\n\n\tasync removeSession(providerId: string, sessionId: string): Promise<void> {\n\t\tconst providerData = this._authenticationProviders.get(providerId);\n\t\tif (!providerData) {\n\t\t\treturn this._proxy.$removeSession(providerId, sessionId);\n\t\t}\n\n\t\treturn providerData.provider.removeSession(sessionId);\n\t}\n\n\tregisterAuthenticationProvider(id: string, label: string, provider: vscode.AuthenticationProvider, options?: vscode.AuthenticationProviderOptions): vscode.Disposable {\n\t\tif (this._authenticationProviders.get(id)) {\n\t\t\tthrow new Error(`An authentication provider with id '${id}' is already registered.`);\n\t\t}\n\n\t\tthis._authenticationProviders.set(id, { label, provider, options: options ?? { supportsMultipleAccounts: false } });\n\t\tconst listener = provider.onDidChangeSessions(e => this._proxy.$sendDidChangeSessions(id, e));\n\t\tthis._proxy.$registerAuthenticationProvider(id, label, options?.supportsMultipleAccounts ?? false);\n\n\t\treturn new Disposable(() => {\n\t\t\tlistener.dispose();\n\t\t\tthis._authenticationProviders.delete(id);\n\t\t\tthis._proxy.$unregisterAuthenticationProvider(id);\n\t\t});\n\t}\n\n\tasync $createSession(providerId: string, scopes: string[], options: vscode.AuthenticationProviderSessionOptions): Promise<vscode.AuthenticationSession> {\n\t\tconst providerData = this._authenticationProviders.get(providerId);\n\t\tif (providerData) {\n\t\t\treturn await providerData.provider.createSession(scopes, options);\n\t\t}\n\n\t\tthrow new Error(`Unable to find authentication provider with handle: ${providerId}`);\n\t}\n\n\tasync $removeSession(providerId: string, sessionId: string): Promise<void> {\n\t\tconst providerData = this._authenticationProviders.get(providerId);\n\t\tif (providerData) {\n\t\t\treturn await providerData.provider.removeSession(sessionId);\n\t\t}\n\n\t\tthrow new Error(`Unable to find authentication provider with handle: ${providerId}`);\n\t}\n\n\tasync $getSessions(providerId: string, scopes: ReadonlyArray<string> | undefined, options: vscode.AuthenticationProviderSessionOptions): Promise<ReadonlyArray<vscode.AuthenticationSession>> {\n\t\tconst providerData = this._authenticationProviders.get(providerId);\n\t\tif (providerData) {\n\t\t\treturn await providerData.provider.getSessions(scopes, options);\n\t\t}\n\n\t\tthrow new Error(`Unable to find authentication provider with handle: ${providerId}`);\n\t}\n\n\t$onDidChangeAuthenticationSessions(id: string, label: string) {\n\t\t// Don't fire events for the internal auth providers\n\t\tif (!id.startsWith(INTERNAL_AUTH_PROVIDER_PREFIX)) {\n\t\t\tthis._onDidChangeSessions.fire({ provider: { id, label } });\n\t\t}\n\t\treturn Promise.resolve();\n\t}\n}\n\nclass TaskSingler<T> {\n\tprivate _inFlightPromises = new Map<string, Promise<T>>();\n\tgetOrCreate(key: string, promiseFactory: () => Promise<T>) {\n\t\tconst inFlight = this._inFlightPromises.get(key);\n\t\tif (inFlight) {\n\t\t\treturn inFlight;\n\t\t}\n\n\t\tconst promise = promiseFactory().finally(() => this._inFlightPromises.delete(key));\n\t\tthis._inFlightPromises.set(key, promise);\n\n\t\treturn promise;\n\t}\n}\n"],
  "mappings": ";;;;;;;;;;;;AAMA,SAAS,SAAS,aAAa;AAC/B,SAAS,aAAa,+BAA+B,kCAAkC;AACvF,SAAS,kBAAkB;AAC3B,SAAS,uBAAuB,2BAA2B;AAC3D,SAAS,qCAAqC;AAC9C,SAAS,uBAAuB;AAChC,SAAS,0BAA0B;AAG5B,MAAM,yBAAyB,gBAAwC,wBAAwB;AAQ/F,IAAM,wBAAN,MAAkE;AAAA,EAvBzE,OAuByE;AAAA;AAAA;AAAA,EAIhE;AAAA,EACA,2BAA8D,oBAAI,IAAkC;AAAA,EAEpG,uBAAuB,IAAI,QAAkD;AAAA,EAC5E,sBAAuE,KAAK,qBAAqB;AAAA,EAElG,yBAAyB,IAAI,YAAsD;AAAA,EAE3F,YACqB,YACnB;AACD,SAAK,SAAS,WAAW,SAAS,YAAY,wBAAwB;AAAA,EACvE;AAAA,EAMA,MAAM,WAAW,qBAA4C,YAAoB,QAA2B,UAAkD,CAAC,GAAsD;AACpN,UAAM,cAAc,oBAAoB,MAAM,oBAAoB,UAAU;AAC5E,UAAM,eAAe,CAAC,GAAG,MAAM,EAAE,KAAK,EAAE,KAAK,GAAG;AAChD,WAAO,MAAM,KAAK,uBAAuB,YAAY,GAAG,WAAW,IAAI,UAAU,IAAI,YAAY,IAAI,YAAY;AAChH,YAAM,KAAK,OAAO,gBAAgB,UAAU;AAC5C,YAAM,gBAAgB,oBAAoB,eAAe,oBAAoB;AAC7E,aAAO,KAAK,OAAO,YAAY,YAAY,QAAQ,aAAa,eAAe,OAAO;AAAA,IACvF,CAAC;AAAA,EACF;AAAA,EAEA,MAAM,YAAY,YAAoB;AACrC,UAAM,KAAK,OAAO,gBAAgB,UAAU;AAC5C,WAAO,MAAM,KAAK,OAAO,aAAa,UAAU;AAAA,EACjD;AAAA,EAEA,MAAM,cAAc,YAAoB,WAAkC;AACzE,UAAM,eAAe,KAAK,yBAAyB,IAAI,UAAU;AACjE,QAAI,CAAC,cAAc;AAClB,aAAO,KAAK,OAAO,eAAe,YAAY,SAAS;AAAA,IACxD;AAEA,WAAO,aAAa,SAAS,cAAc,SAAS;AAAA,EACrD;AAAA,EAEA,+BAA+B,IAAY,OAAe,UAAyC,SAAmE;AACrK,QAAI,KAAK,yBAAyB,IAAI,EAAE,GAAG;AAC1C,YAAM,IAAI,MAAM,uCAAuC,EAAE,0BAA0B;AAAA,IACpF;AAEA,SAAK,yBAAyB,IAAI,IAAI,EAAE,OAAO,UAAU,SAAS,WAAW,EAAE,0BAA0B,MAAM,EAAE,CAAC;AAClH,UAAM,WAAW,SAAS,oBAAoB,OAAK,KAAK,OAAO,uBAAuB,IAAI,CAAC,CAAC;AAC5F,SAAK,OAAO,gCAAgC,IAAI,OAAO,SAAS,4BAA4B,KAAK;AAEjG,WAAO,IAAI,WAAW,MAAM;AAC3B,eAAS,QAAQ;AACjB,WAAK,yBAAyB,OAAO,EAAE;AACvC,WAAK,OAAO,kCAAkC,EAAE;AAAA,IACjD,CAAC;AAAA,EACF;AAAA,EAEA,MAAM,eAAe,YAAoB,QAAkB,SAA6F;AACvJ,UAAM,eAAe,KAAK,yBAAyB,IAAI,UAAU;AACjE,QAAI,cAAc;AACjB,aAAO,MAAM,aAAa,SAAS,cAAc,QAAQ,OAAO;AAAA,IACjE;AAEA,UAAM,IAAI,MAAM,uDAAuD,UAAU,EAAE;AAAA,EACpF;AAAA,EAEA,MAAM,eAAe,YAAoB,WAAkC;AAC1E,UAAM,eAAe,KAAK,yBAAyB,IAAI,UAAU;AACjE,QAAI,cAAc;AACjB,aAAO,MAAM,aAAa,SAAS,cAAc,SAAS;AAAA,IAC3D;AAEA,UAAM,IAAI,MAAM,uDAAuD,UAAU,EAAE;AAAA,EACpF;AAAA,EAEA,MAAM,aAAa,YAAoB,QAA2C,SAA4G;AAC7L,UAAM,eAAe,KAAK,yBAAyB,IAAI,UAAU;AACjE,QAAI,cAAc;AACjB,aAAO,MAAM,aAAa,SAAS,YAAY,QAAQ,OAAO;AAAA,IAC/D;AAEA,UAAM,IAAI,MAAM,uDAAuD,UAAU,EAAE;AAAA,EACpF;AAAA,EAEA,mCAAmC,IAAY,OAAe;AAE7D,QAAI,CAAC,GAAG,WAAW,6BAA6B,GAAG;AAClD,WAAK,qBAAqB,KAAK,EAAE,UAAU,EAAE,IAAI,MAAM,EAAE,CAAC;AAAA,IAC3D;AACA,WAAO,QAAQ,QAAQ;AAAA,EACxB;AACD;AAhGa,wBAAN;AAAA,EAaJ;AAAA,GAbU;AAkGb,MAAM,YAAe;AAAA,EAzHrB,OAyHqB;AAAA;AAAA;AAAA,EACZ,oBAAoB,oBAAI,IAAwB;AAAA,EACxD,YAAY,KAAa,gBAAkC;AAC1D,UAAM,WAAW,KAAK,kBAAkB,IAAI,GAAG;AAC/C,QAAI,UAAU;AACb,aAAO;AAAA,IACR;AAEA,UAAM,UAAU,eAAe,EAAE,QAAQ,MAAM,KAAK,kBAAkB,OAAO,GAAG,CAAC;AACjF,SAAK,kBAAkB,IAAI,KAAK,OAAO;AAEvC,WAAO;AAAA,EACR;AACD;",
  "names": []
}
