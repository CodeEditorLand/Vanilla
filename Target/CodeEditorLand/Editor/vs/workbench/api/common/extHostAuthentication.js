var p=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var c=(r,e,i,t)=>{for(var n=t>1?void 0:t?u(e,i):e,s=r.length-1,o;s>=0;s--)(o=r[s])&&(n=(t?o(e,i,n):o(n))||n);return t&&n&&p(e,i,n),n},d=(r,e)=>(i,t)=>e(i,t,r);import{Emitter as v,Event as g}from"../../../base/common/event.js";import{MainContext as S}from"./extHost.protocol.js";import{Disposable as l}from"./extHostTypes.js";import{ExtensionIdentifier as m}from"../../../platform/extensions/common/extensions.js";import{INTERNAL_AUTH_PROVIDER_PREFIX as A}from"../../services/authentication/common/authentication.js";import{createDecorator as P}from"../../../platform/instantiation/common/instantiation.js";import{IExtHostRpcService as x}from"./extHostRpcService.js";const N=P("IExtHostAuthentication");let a=class{_proxy;_authenticationProviders=new Map;_onDidChangeSessions=new v;_getSessionTaskSingler=new f;constructor(e){this._proxy=e.getProxy(S.MainThreadAuthentication)}getExtensionScopedSessionsEvent(e){const i=e.toLowerCase();return g.chain(this._onDidChangeSessions.event,t=>t.filter(n=>!n.extensionIdFilter||n.extensionIdFilter.includes(i)).map(n=>({provider:n.provider})))}async getSession(e,i,t,n={}){const s=m.toKey(e.identifier),o=[...t].sort().join(" ");return await this._getSessionTaskSingler.getOrCreate(`${s} ${i} ${o}`,async()=>{await this._proxy.$ensureProvider(i);const h=e.displayName||e.name;return this._proxy.$getSession(i,t,s,h,n)})}async getAccounts(e){return await this._proxy.$ensureProvider(e),await this._proxy.$getAccounts(e)}async removeSession(e,i){const t=this._authenticationProviders.get(e);return t?t.provider.removeSession(i):this._proxy.$removeSession(e,i)}registerAuthenticationProvider(e,i,t,n){if(this._authenticationProviders.get(e))throw new Error(`An authentication provider with id '${e}' is already registered.`);this._authenticationProviders.set(e,{label:i,provider:t,options:n??{supportsMultipleAccounts:!1}});const s=t.onDidChangeSessions(o=>this._proxy.$sendDidChangeSessions(e,o));return this._proxy.$registerAuthenticationProvider(e,i,n?.supportsMultipleAccounts??!1),new l(()=>{s.dispose(),this._authenticationProviders.delete(e),this._proxy.$unregisterAuthenticationProvider(e)})}async $createSession(e,i,t){const n=this._authenticationProviders.get(e);if(n)return await n.provider.createSession(i,t);throw new Error(`Unable to find authentication provider with handle: ${e}`)}async $removeSession(e,i){const t=this._authenticationProviders.get(e);if(t)return await t.provider.removeSession(i);throw new Error(`Unable to find authentication provider with handle: ${e}`)}async $getSessions(e,i,t){const n=this._authenticationProviders.get(e);if(n)return await n.provider.getSessions(i,t);throw new Error(`Unable to find authentication provider with handle: ${e}`)}$onDidChangeAuthenticationSessions(e,i,t){return e.startsWith(A)||this._onDidChangeSessions.fire({provider:{id:e,label:i},extensionIdFilter:t}),Promise.resolve()}};a=c([d(0,x)],a);class f{_inFlightPromises=new Map;getOrCreate(e,i){const t=this._inFlightPromises.get(e);if(t)return t;const n=i().finally(()=>this._inFlightPromises.delete(e));return this._inFlightPromises.set(e,n),n}}export{a as ExtHostAuthentication,N as IExtHostAuthentication};
