var p=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var c=(r,e,t,i)=>{for(var n=i>1?void 0:i?u(e,t):e,s=r.length-1,o;s>=0;s--)(o=r[s])&&(n=(i?o(e,t,n):o(n))||n);return i&&n&&p(e,t,n),n},h=(r,e)=>(t,i)=>e(t,i,r);import{Emitter as v}from"../../../base/common/event.js";import{ExtensionIdentifier as g}from"../../../platform/extensions/common/extensions.js";import{createDecorator as S}from"../../../platform/instantiation/common/instantiation.js";import{INTERNAL_AUTH_PROVIDER_PREFIX as m}from"../../services/authentication/common/authentication.js";import{MainContext as A}from"./extHost.protocol.js";import{IExtHostRpcService as l}from"./extHostRpcService.js";import{Disposable as P}from"./extHostTypes.js";const O=S("IExtHostAuthentication");let a=class{_proxy;_authenticationProviders=new Map;_onDidChangeSessions=new v;onDidChangeSessions=this._onDidChangeSessions.event;_getSessionTaskSingler=new y;constructor(e){this._proxy=e.getProxy(A.MainThreadAuthentication)}async getSession(e,t,i,n={}){const s=g.toKey(e.identifier),o=[...i].sort().join(" ");return await this._getSessionTaskSingler.getOrCreate(`${s} ${t} ${o}`,async()=>{await this._proxy.$ensureProvider(t);const d=e.displayName||e.name;return this._proxy.$getSession(t,i,s,d,n)})}async getAccounts(e){return await this._proxy.$ensureProvider(e),await this._proxy.$getAccounts(e)}async removeSession(e,t){const i=this._authenticationProviders.get(e);return i?i.provider.removeSession(t):this._proxy.$removeSession(e,t)}registerAuthenticationProvider(e,t,i,n){if(this._authenticationProviders.get(e))throw new Error(`An authentication provider with id '${e}' is already registered.`);this._authenticationProviders.set(e,{label:t,provider:i,options:n??{supportsMultipleAccounts:!1}});const s=i.onDidChangeSessions(o=>this._proxy.$sendDidChangeSessions(e,o));return this._proxy.$registerAuthenticationProvider(e,t,n?.supportsMultipleAccounts??!1),new P(()=>{s.dispose(),this._authenticationProviders.delete(e),this._proxy.$unregisterAuthenticationProvider(e)})}async $createSession(e,t,i){const n=this._authenticationProviders.get(e);if(n)return await n.provider.createSession(t,i);throw new Error(`Unable to find authentication provider with handle: ${e}`)}async $removeSession(e,t){const i=this._authenticationProviders.get(e);if(i)return await i.provider.removeSession(t);throw new Error(`Unable to find authentication provider with handle: ${e}`)}async $getSessions(e,t,i){const n=this._authenticationProviders.get(e);if(n)return await n.provider.getSessions(t,i);throw new Error(`Unable to find authentication provider with handle: ${e}`)}$onDidChangeAuthenticationSessions(e,t){return e.startsWith(m)||this._onDidChangeSessions.fire({provider:{id:e,label:t}}),Promise.resolve()}};a=c([h(0,l)],a);class y{_inFlightPromises=new Map;getOrCreate(e,t){const i=this._inFlightPromises.get(e);if(i)return i;const n=t().finally(()=>this._inFlightPromises.delete(e));return this._inFlightPromises.set(e,n),n}}export{a as ExtHostAuthentication,O as IExtHostAuthentication};
