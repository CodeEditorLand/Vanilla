{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/api/common/extHostSpeech.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type * as vscode from \"vscode\";\nimport { CancellationTokenSource } from \"../../../base/common/cancellation.js\";\nimport {\n\tDisposableStore,\n\ttype IDisposable,\n\ttoDisposable,\n} from \"../../../base/common/lifecycle.js\";\nimport type { ExtensionIdentifier } from \"../../../platform/extensions/common/extensions.js\";\nimport {\n\ttype ExtHostSpeechShape,\n\ttype IMainContext,\n\tMainContext,\n\ttype MainThreadSpeechShape,\n} from \"./extHost.protocol.js\";\n\nexport class ExtHostSpeech implements ExtHostSpeechShape {\n\tprivate static ID_POOL = 1;\n\n\tprivate readonly proxy: MainThreadSpeechShape;\n\n\tprivate readonly providers = new Map<number, vscode.SpeechProvider>();\n\tprivate readonly sessions = new Map<number, CancellationTokenSource>();\n\tprivate readonly synthesizers = new Map<\n\t\tnumber,\n\t\tvscode.TextToSpeechSession\n\t>();\n\n\tconstructor(mainContext: IMainContext) {\n\t\tthis.proxy = mainContext.getProxy(MainContext.MainThreadSpeech);\n\t}\n\n\tasync $createSpeechToTextSession(\n\t\thandle: number,\n\t\tsession: number,\n\t\tlanguage?: string,\n\t): Promise<void> {\n\t\tconst provider = this.providers.get(handle);\n\t\tif (!provider) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst disposables = new DisposableStore();\n\n\t\tconst cts = new CancellationTokenSource();\n\t\tthis.sessions.set(session, cts);\n\n\t\tconst speechToTextSession = await provider.provideSpeechToTextSession(\n\t\t\tcts.token,\n\t\t\tlanguage ? { language } : undefined,\n\t\t);\n\t\tif (!speechToTextSession) {\n\t\t\treturn;\n\t\t}\n\n\t\tdisposables.add(\n\t\t\tspeechToTextSession.onDidChange((e) => {\n\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.proxy.$emitSpeechToTextEvent(session, e);\n\t\t\t}),\n\t\t);\n\n\t\tdisposables.add(\n\t\t\tcts.token.onCancellationRequested(() => disposables.dispose()),\n\t\t);\n\t}\n\n\tasync $cancelSpeechToTextSession(session: number): Promise<void> {\n\t\tthis.sessions.get(session)?.dispose(true);\n\t\tthis.sessions.delete(session);\n\t}\n\n\tasync $createTextToSpeechSession(\n\t\thandle: number,\n\t\tsession: number,\n\t\tlanguage?: string,\n\t): Promise<void> {\n\t\tconst provider = this.providers.get(handle);\n\t\tif (!provider) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst disposables = new DisposableStore();\n\n\t\tconst cts = new CancellationTokenSource();\n\t\tthis.sessions.set(session, cts);\n\n\t\tconst textToSpeech = await provider.provideTextToSpeechSession(\n\t\t\tcts.token,\n\t\t\tlanguage ? { language } : undefined,\n\t\t);\n\t\tif (!textToSpeech) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.synthesizers.set(session, textToSpeech);\n\n\t\tdisposables.add(\n\t\t\ttextToSpeech.onDidChange((e) => {\n\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.proxy.$emitTextToSpeechEvent(session, e);\n\t\t\t}),\n\t\t);\n\n\t\tdisposables.add(\n\t\t\tcts.token.onCancellationRequested(() => disposables.dispose()),\n\t\t);\n\t}\n\n\tasync $synthesizeSpeech(session: number, text: string): Promise<void> {\n\t\tthis.synthesizers.get(session)?.synthesize(text);\n\t}\n\n\tasync $cancelTextToSpeechSession(session: number): Promise<void> {\n\t\tthis.sessions.get(session)?.dispose(true);\n\t\tthis.sessions.delete(session);\n\t\tthis.synthesizers.delete(session);\n\t}\n\n\tasync $createKeywordRecognitionSession(\n\t\thandle: number,\n\t\tsession: number,\n\t): Promise<void> {\n\t\tconst provider = this.providers.get(handle);\n\t\tif (!provider) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst disposables = new DisposableStore();\n\n\t\tconst cts = new CancellationTokenSource();\n\t\tthis.sessions.set(session, cts);\n\n\t\tconst keywordRecognitionSession =\n\t\t\tawait provider.provideKeywordRecognitionSession(cts.token);\n\t\tif (!keywordRecognitionSession) {\n\t\t\treturn;\n\t\t}\n\n\t\tdisposables.add(\n\t\t\tkeywordRecognitionSession.onDidChange((e) => {\n\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.proxy.$emitKeywordRecognitionEvent(session, e);\n\t\t\t}),\n\t\t);\n\n\t\tdisposables.add(\n\t\t\tcts.token.onCancellationRequested(() => disposables.dispose()),\n\t\t);\n\t}\n\n\tasync $cancelKeywordRecognitionSession(session: number): Promise<void> {\n\t\tthis.sessions.get(session)?.dispose(true);\n\t\tthis.sessions.delete(session);\n\t}\n\n\tregisterProvider(\n\t\textension: ExtensionIdentifier,\n\t\tidentifier: string,\n\t\tprovider: vscode.SpeechProvider,\n\t): IDisposable {\n\t\tconst handle = ExtHostSpeech.ID_POOL++;\n\n\t\tthis.providers.set(handle, provider);\n\t\tthis.proxy.$registerProvider(handle, identifier, {\n\t\t\textension,\n\t\t\tdisplayName: extension.value,\n\t\t});\n\n\t\treturn toDisposable(() => {\n\t\t\tthis.proxy.$unregisterProvider(handle);\n\t\t\tthis.providers.delete(handle);\n\t\t});\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
