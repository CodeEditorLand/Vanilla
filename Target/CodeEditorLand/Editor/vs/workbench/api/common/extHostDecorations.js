var y=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var f=(d,r,t,e)=>{for(var i=e>1?void 0:e?u(r,t):r,a=d.length-1,n;a>=0;a--)(n=d[a])&&(i=(e?n(r,t,i):n(i))||i);return e&&i&&y(r,t,i),i},v=(d,r)=>(t,e)=>r(t,e,d);import{asArray as g,groupBy as x}from"../../../base/common/arrays.js";import{dirname as _}from"../../../base/common/path.js";import{compare as I,count as P}from"../../../base/common/strings.js";import{URI as S}from"../../../base/common/uri.js";import{createDecorator as b}from"../../../platform/instantiation/common/instantiation.js";import{ILogService as E}from"../../../platform/log/common/log.js";import{checkProposedApiEnabled as C}from"../../services/extensions/common/extensions.js";import{MainContext as R}from"./extHost.protocol.js";import{IExtHostRpcService as k}from"./extHostRpcService.js";import{Disposable as $,FileDecoration as F}from"./extHostTypes.js";let s=class{constructor(r,t){this._logService=t;this._proxy=r.getProxy(R.MainThreadDecorations)}static _handlePool=0;static _maxEventSize=250;_serviceBrand;_provider=new Map;_proxy;registerFileDecorationProvider(r,t){const e=s._handlePool++;this._provider.set(e,{provider:r,extensionDescription:t}),this._proxy.$registerDecorationProvider(e,t.identifier.value);const i=r.onDidChangeFileDecorations&&r.onDidChangeFileDecorations(a=>{if(!a){this._proxy.$onDidChange(e,null);return}const n=g(a);if(n.length<=s._maxEventSize){this._proxy.$onDidChange(e,n);return}this._logService.warn("[Decorations] CAPPING events from decorations provider",t.identifier.value,n.length);const m=n.map(o=>({uri:o,rank:P(o.path,"/")})),p=x(m,(o,c)=>o.rank-c.rank||I(o.uri.path,c.uri.path)),l=[];e:for(const o of p){let c;for(const D of o){const h=_(D.uri.path);if(c!==h&&(c=h,l.push(D.uri)>=s._maxEventSize))break e}}this._proxy.$onDidChange(e,l)});return new $(()=>{i?.dispose(),this._proxy.$unregisterDecorationProvider(e),this._provider.delete(e)})}async $provideDecorations(r,t,e){if(!this._provider.has(r))return Object.create(null);const i=Object.create(null),{provider:a,extensionDescription:n}=this._provider.get(r);return await Promise.all(t.map(async m=>{try{const{uri:p,id:l}=m,o=await Promise.resolve(a.provideFileDecoration(S.revive(p),e));if(!o)return;try{F.validate(o),o.badge&&typeof o.badge!="string"&&C(n,"codiconDecoration"),i[l]=[o.propagate,o.tooltip,o.badge,o.color]}catch(c){this._logService.warn(`INVALID decoration from extension '${n.identifier.value}': ${c}`)}}catch(p){this._logService.error(p)}})),i}};s=f([v(0,k),v(1,E)],s);const O=b("IExtHostDecorations");export{s as ExtHostDecorations,O as IExtHostDecorations};
