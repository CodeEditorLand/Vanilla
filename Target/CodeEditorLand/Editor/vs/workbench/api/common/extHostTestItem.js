import{URI as f}from"../../../../vs/base/common/uri.js";import*as g from"../../../../vs/editor/common/core/range.js";import"../../../../vs/workbench/api/common/extHostDocumentsAndEditors.js";import{createPrivateApiFor as b,getPrivateApiFor as p}from"../../../../vs/workbench/api/common/extHostTestingPrivateApi.js";import*as l from"../../../../vs/workbench/api/common/extHostTypeConverters.js";import{TestId as v,TestIdPathParts as x}from"../../../../vs/workbench/contrib/testing/common/testId.js";import{createTestItemChildren as h,TestItemCollection as y,TestItemEventOp as c}from"../../../../vs/workbench/contrib/testing/common/testItemCollection.js";import{denamespaceTestTag as C}from"../../../../vs/workbench/contrib/testing/common/testTypes.js";const d=(t,r,e,n)=>{let s=r;return{enumerable:!0,configurable:!1,get(){return s},set(o){if(!e(s,o)){const T=s;s=o,t.listener?.(n(o,T))}}}},a=(t,r)=>t===r,i={range:(t,r)=>t===r?!0:!t||!r?!1:t.isEqual(r),label:a,description:a,sortText:a,busy:a,error:a,canResolveChildren:a,tags:(t,r)=>!(t.length!==r.length||t.some(e=>!r.find(n=>e.id===n.id)))},m=t=>r=>({op:c.SetProp,update:t(r)}),R=(t,r)=>({range:(()=>{let e;const n=m(s=>({range:g.Range.lift(l.Range.from(s))}));return{enumerable:!0,configurable:!1,get(){return e},set(s){t.listener?.({op:c.DocumentSynced}),i.range(e,s)||(e=s,t.listener?.(n(s)))}}})(),label:d(t,r,i.label,m(e=>({label:e}))),description:d(t,void 0,i.description,m(e=>({description:e}))),sortText:d(t,void 0,i.sortText,m(e=>({sortText:e}))),canResolveChildren:d(t,!1,i.canResolveChildren,e=>({op:c.UpdateCanResolveChildren,state:e})),busy:d(t,!1,i.busy,m(e=>({busy:e}))),error:d(t,void 0,i.error,m(e=>({error:l.MarkdownString.fromStrict(e)||null}))),tags:d(t,[],i.tags,(e,n)=>({op:c.SetTags,new:e.map(l.TestTag.from),old:n.map(l.TestTag.from)}))}),E=t=>{const r=v.fromString(t.extId),e=new u(r.controllerId,r.localId,t.label,f.revive(t.uri)||void 0);return e.range=l.Range.to(t.range||void 0),e.description=t.description||void 0,e.sortText=t.sortText||void 0,e.tags=t.tags.map(n=>l.TestTag.to({id:C(n).tagId})),e},M=t=>{let r;for(const e of t.tests){const n=E(e.item);p(n).parent=r,r=n}return r};class u{id;uri;children;parent;range;description;sortText;label;error;busy;canResolveChildren;tags;constructor(r,e,n,s){if(e.includes(x.Delimiter))throw new Error(`Test IDs may not include the ${JSON.stringify(e)} symbol`);const o=b(this,r);Object.defineProperties(this,{id:{value:e,enumerable:!0,writable:!1},uri:{value:s,enumerable:!0,writable:!1},parent:{enumerable:!1,get(){return o.parent instanceof I?void 0:o.parent}},children:{value:h(o,p,u),enumerable:!0,writable:!1},...R(o,n)})}}class I extends u{_isRoot=!0;constructor(r,e){super(r,r,e,void 0)}}class V extends y{constructor(r,e,n){super({controllerId:r,getDocumentVersion:s=>s&&n.getDocument(s)?.version,getApiFor:p,getChildren:s=>s.children,root:new I(r,e),toITestItem:l.TestItem.from})}}export{V as ExtHostTestItemCollection,u as TestItemImpl,I as TestItemRootImpl,M as toItemFromContext};
