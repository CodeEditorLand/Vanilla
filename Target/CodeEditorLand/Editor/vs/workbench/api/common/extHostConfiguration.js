var R=Object.defineProperty;var $=Object.getOwnPropertyDescriptor;var P=(r,e,t,o)=>{for(var n=o>1?void 0:o?$(e,t):e,a=r.length-1,d;a>=0;a--)(d=r[a])&&(n=(o?d(e,t,n):d(n))||n);return o&&n&&R(e,t,n),n},E=(r,e)=>(t,o)=>e(t,o,r);import{mixin as O,deepClone as g}from"../../../base/common/objects.js";import{Emitter as V}from"../../../base/common/event.js";import{IExtHostWorkspace as D}from"./extHostWorkspace.js";import{MainContext as L}from"./extHost.protocol.js";import{ConfigurationTarget as m}from"./extHostTypes.js";import{ConfigurationTarget as y}from"../../../platform/configuration/common/configuration.js";import{Configuration as W,ConfigurationChangeEvent as M}from"../../../platform/configuration/common/configurationModels.js";import{ConfigurationScope as w,OVERRIDE_PROPERTY_REGEX as j}from"../../../platform/configuration/common/configurationRegistry.js";import{isObject as H}from"../../../base/common/types.js";import"../../../platform/extensions/common/extensions.js";import{Barrier as K}from"../../../base/common/async.js";import{createDecorator as A}from"../../../platform/instantiation/common/instantiation.js";import{IExtHostRpcService as F}from"./extHostRpcService.js";import{ILogService as U}from"../../../platform/log/common/log.js";import"../../../platform/workspace/common/workspace.js";import{URI as T}from"../../../base/common/uri.js";function h(r,e){if(e){const t=e.split(".");let o=r;for(let n=0;o&&n<t.length;n++)o=o[t[n]];return o}}function z(r){return r instanceof T}function B(r){return r&&r.uri instanceof T&&r.languageId&&typeof r.languageId=="string"}function G(r){return r&&!r.uri&&r.languageId&&typeof r.languageId=="string"}function N(r){return r&&r.uri instanceof T&&(!r.name||typeof r.name=="string")&&(!r.index||typeof r.index=="number")}function b(r){if(z(r))return{resource:r};if(B(r))return{resource:r.uri,overrideIdentifier:r.languageId};if(G(r))return{overrideIdentifier:r.languageId};if(N(r))return{resource:r.uri};if(r===null)return{resource:null}}let I=class{_serviceBrand;_proxy;_logService;_extHostWorkspace;_barrier;_actual;constructor(e,t,o){this._proxy=e.getProxy(L.MainThreadConfiguration),this._extHostWorkspace=t,this._logService=o,this._barrier=new K,this._actual=null}getConfigProvider(){return this._barrier.wait().then(e=>this._actual)}$initializeConfiguration(e){this._actual=new X(this._proxy,this._extHostWorkspace,e,this._logService),this._barrier.open()}$acceptConfigurationChanged(e,t){this.getConfigProvider().then(o=>o.$acceptConfigurationChanged(e,t))}};I=P([E(0,F),E(1,D),E(2,U)],I);class X{_onDidChangeConfiguration=new V;_proxy;_extHostWorkspace;_configurationScopes;_configuration;_logService;constructor(e,t,o,n){this._proxy=e,this._logService=n,this._extHostWorkspace=t,this._configuration=W.parse(o,n),this._configurationScopes=this._toMap(o.configurationScopes)}get onDidChangeConfiguration(){return this._onDidChangeConfiguration&&this._onDidChangeConfiguration.event}$acceptConfigurationChanged(e,t){const o={data:this._configuration.toData(),workspace:this._extHostWorkspace.workspace};this._configuration=W.parse(e,this._logService),this._configurationScopes=this._toMap(e.configurationScopes),this._onDidChangeConfiguration.fire(this._toConfigurationChangeEvent(t,o))}getConfiguration(e,t,o){const n=b(t)||{},a=this._toReadonlyValue(e?h(this._configuration.getValue(void 0,n,this._extHostWorkspace.workspace),e):this._configuration.getValue(void 0,n,this._extHostWorkspace.workspace));e&&this._validateConfigurationAccess(e,n,o?.identifier);function d(i){if(i==null)return null;if(typeof i=="boolean")return i?y.USER:y.WORKSPACE;switch(i){case m.Global:return y.USER;case m.Workspace:return y.WORKSPACE;case m.WorkspaceFolder:return y.WORKSPACE_FOLDER}}const k={has(i){return typeof h(a,i)<"u"},get:(i,u)=>{this._validateConfigurationAccess(e?`${e}.${i}`:i,n,o?.identifier);let p=h(a,i);if(typeof p>"u")p=u;else{let c;const C=(v,S)=>{if(H(v)){let s;const _=()=>{c=c||g(a),s=s||h(c,S)};return new Proxy(v,{get:(x,f)=>{if(typeof f=="string"&&f.toLowerCase()==="tojson")return _(),()=>s;if(c)return s=s||h(c,S),s[f];const l=x[f];return typeof f=="string"?C(l,`${S}.${f}`):l},set:(x,f,l)=>(_(),s&&(s[f]=l),!0),deleteProperty:(x,f)=>(_(),s&&delete s[f],!0),defineProperty:(x,f,l)=>(_(),s&&Object.defineProperty(s,f,l),!0)})}return Array.isArray(v)?g(v):v};p=C(p,i)}return p},update:(i,u,p,c)=>{i=e?`${e}.${i}`:i;const C=d(p);return u!==void 0?this._proxy.$updateConfigurationOption(C,i,u,n,c):this._proxy.$removeConfigurationOption(C,i,n,c)},inspect:i=>{i=e?`${e}.${i}`:i;const u=this._configuration.inspect(i,n,this._extHostWorkspace.workspace);if(u)return{key:i,defaultValue:g(u.policy?.value??u.default?.value),globalValue:g(u.user?.value??u.application?.value),workspaceValue:g(u.workspace?.value),workspaceFolderValue:g(u.workspaceFolder?.value),defaultLanguageValue:g(u.default?.override),globalLanguageValue:g(u.user?.override??u.application?.override),workspaceLanguageValue:g(u.workspace?.override),workspaceFolderLanguageValue:g(u.workspaceFolder?.override),languageIds:g(u.overrideIdentifiers)}}};return typeof a=="object"&&O(k,a,!1),Object.freeze(k)}_toReadonlyValue(e){const t=o=>H(o)?new Proxy(o,{get:(n,a)=>t(n[a]),set:(n,a,d)=>{throw new Error(`TypeError: Cannot assign to read only property '${String(a)}' of object`)},deleteProperty:(n,a)=>{throw new Error(`TypeError: Cannot delete read only property '${String(a)}' of object`)},defineProperty:(n,a)=>{throw new Error(`TypeError: Cannot define property '${String(a)}' for a readonly object`)},setPrototypeOf:n=>{throw new Error("TypeError: Cannot set prototype for a readonly object")},isExtensible:()=>!1,preventExtensions:()=>!0}):o;return t(e)}_validateConfigurationAccess(e,t,o){const n=j.test(e)?w.RESOURCE:this._configurationScopes.get(e),a=o?`[${o.value}] `:"";if(w.RESOURCE===n){typeof t?.resource>"u"&&this._logService.warn(`${a}Accessing a resource scoped configuration without providing a resource is not expected. To get the effective value for '${e}', provide the URI of a resource or 'null' for any resource.`);return}if(w.WINDOW===n){t?.resource&&this._logService.warn(`${a}Accessing a window scoped configuration for a resource is not expected. To associate '${e}' to a resource, define its scope to 'resource' in configuration contributions in 'package.json'.`);return}}_toConfigurationChangeEvent(e,t){const o=new M(e,t,this._configuration,this._extHostWorkspace.workspace,this._logService);return Object.freeze({affectsConfiguration:(n,a)=>o.affectsConfiguration(n,b(a))})}_toMap(e){return e.reduce((t,o)=>(t.set(o[0],o[1]),t),new Map)}}const Se=A("IExtHostConfiguration");export{X as ExtHostConfigProvider,I as ExtHostConfiguration,Se as IExtHostConfiguration};
