import{raceCancellation as l}from"../../../base/common/async.js";import{CancellationToken as g}from"../../../base/common/cancellation.js";import{CancellationError as c}from"../../../base/common/errors.js";import{toDisposable as u}from"../../../base/common/lifecycle.js";import{revive as T}from"../../../base/common/marshalling.js";import{generateUuid as d}from"../../../base/common/uuid.js";import"../../../platform/extensions/common/extensions.js";import{MainContext as p}from"./extHost.protocol.js";import*as a from"./extHostTypeConverters.js";import"../../contrib/chat/common/languageModelToolsService.js";class F{_registeredTools=new Map;_proxy;_tokenCountFuncs=new Map;_allTools=new Map;constructor(o){this._proxy=o.getProxy(p.MainThreadLanguageModelTools),this._proxy.$getTools().then(e=>{for(const n of e)this._allTools.set(n.id,T(n))})}async $countTokensForInvocation(o,e,n){const t=this._tokenCountFuncs.get(o);if(!t)throw new Error(`Tool invocation call ${o} not found`);return await t(e,n)}async invokeTool(o,e,n){if(!e.requestedContentTypes?.length)throw new Error("LanguageModelToolInvocationOptions.requestedContentTypes is required to be set");const t=d();e.tokenOptions&&this._tokenCountFuncs.set(t,e.tokenOptions.countTokens);try{return await this._proxy.$invokeTool({toolId:o,callId:t,parameters:e.parameters,tokenBudget:e.tokenOptions?.tokenBudget,context:e.toolInvocationToken,requestedContentTypes:e.requestedContentTypes},n)}finally{this._tokenCountFuncs.delete(t)}}$onDidChangeTools(o){this._allTools.clear();for(const e of o)this._allTools.set(e.id,e)}get tools(){return Array.from(this._allTools.values()).map(o=>a.LanguageModelToolDescription.to(o))}async $invokeTool(o,e){const n=this._registeredTools.get(o.toolId);if(!n)throw new Error(`Unknown tool ${o.toolId}`);const t={parameters:o.parameters,toolInvocationToken:o.context,requestedContentTypes:o.requestedContentTypes};o.tokenBudget!==void 0&&(t.tokenOptions={tokenBudget:o.tokenBudget,countTokens:this._tokenCountFuncs.get(o.callId)||((s,i=g.None)=>this._proxy.$countTokensForInvocation(o.callId,s,i))});const r=await l(Promise.resolve(n.tool.invoke(t,e)),e);if(!r)throw new c;for(const s of Object.keys(r)){if(r[s]instanceof Promise)throw new Error(`Tool result for '${s}' cannot be a Promise`);if(!t.requestedContentTypes.includes(s)&&s!=="toString")throw new Error(`Tool result for '${s}' was not requested from ${o.toolId}.`)}return r}async $provideToolConfirmationMessages(o,e,n,t){const r=this._registeredTools.get(o);if(!r)throw new Error(`Unknown tool ${o}`);if(!r.tool.provideToolConfirmationMessages)return;const s=await r.tool.provideToolConfirmationMessages({participantName:e,parameters:n},t);if(s)return{title:s.title,message:typeof s.message=="string"?s.message:a.MarkdownString.from(s.message)}}async $provideToolInvocationMessage(o,e,n){const t=this._registeredTools.get(o);if(!t)throw new Error(`Unknown tool ${o}`);if(t.tool.provideToolInvocationMessage)return await t.tool.provideToolInvocationMessage(e,n)}registerTool(o,e,n){return this._registeredTools.set(e,{extension:o,tool:n}),this._proxy.$registerTool(e),u(()=>{this._registeredTools.delete(e),this._proxy.$unregisterTool(e)})}}export{F as ExtHostLanguageModelTools};
