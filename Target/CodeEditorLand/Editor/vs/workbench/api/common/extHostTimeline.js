import{DisposableStore as v,toDisposable as x}from"../../../base/common/lifecycle.js";import{MarshalledId as M}from"../../../base/common/marshallingIds.js";import{isString as h}from"../../../base/common/types.js";import{URI as u}from"../../../base/common/uri.js";import{ExtensionIdentifier as C}from"../../../platform/extensions/common/extensions.js";import{createDecorator as U}from"../../../platform/instantiation/common/instantiation.js";import{MainContext as S}from"./extHost.protocol.js";import{MarkdownString as g}from"./extHostTypeConverters.js";import{MarkdownString as I,ThemeIcon as _}from"./extHostTypes.js";const $=U("IExtHostTimeline");class R{_proxy;_providers=new Map;_itemsBySourceAndUriMap=new Map;constructor(e,i){this._proxy=e.getProxy(S.MainThreadTimeline),i.registerArgumentProcessor({processArgument:(o,r)=>{if(o&&o.$mid===M.TimelineActionContext)if(this._providers.get(o.source)&&C.equals(r,this._providers.get(o.source)?.extension)){const m=o.uri===void 0?void 0:u.revive(o.uri);return this._itemsBySourceAndUriMap.get(o.source)?.get(y(m))?.get(o.handle)}else return;return o}})}async $getTimeline(e,i,o,r){return this._providers.get(e)?.provider.provideTimeline(u.revive(i),o,r)}registerTimelineProvider(e,i,o,r){const m=new v,a=this.convertTimelineItem(i.id,r,m).bind(this);let n;i.onDidChange&&(n=i.onDidChange(t=>this._proxy.$emitTimelineChangeEvent({uri:void 0,reset:!0,...t,id:i.id}),this));const s=this._itemsBySourceAndUriMap;return this.registerTimelineProviderCore({...i,scheme:e,onDidChange:void 0,async provideTimeline(t,l,c){l?.resetCache&&(m.clear(),s.get(i.id)?.clear());const d=await i.provideTimeline(t,l,c);if(d==null)return;const f=a(t,l);return{...d,source:i.id,items:d.items.map(f)}},dispose(){for(const t of s.values())t.get(i.id)?.clear();n?.dispose(),m.dispose()}},o)}convertTimelineItem(e,i,o){return(r,m)=>{let a;if(m?.cacheResults){let n=this._itemsBySourceAndUriMap.get(e);n===void 0&&(n=new Map,this._itemsBySourceAndUriMap.set(e,n));const s=y(r);a=n.get(s),a===void 0&&(a=new Map,n.set(s,a))}return n=>{const{iconPath:s,...t}=n,l=`${e}|${n.id??n.timestamp}`;a?.set(l,n);let c,d,f;n.iconPath&&(s instanceof _?f={id:s.id,color:s.color}:u.isUri(s)?(c=s,d=s):{light:c,dark:d}=s);let p;return I.isMarkdownString(t.tooltip)?p=g.from(t.tooltip):h(t.tooltip)?p=t.tooltip:I.isMarkdownString(t.detail)?p=g.from(t.detail):h(t.detail)&&(p=t.detail),{...t,id:t.id??void 0,handle:l,source:e,command:n.command?i.toInternal(n.command,o):void 0,icon:c,iconDark:d,themeIcon:f,tooltip:p,accessibilityInformation:n.accessibilityInformation}}}}registerTimelineProviderCore(e,i){if(this._providers.get(e.id))throw new Error(`Timeline Provider ${e.id} already exists.`);return this._proxy.$registerTimelineProvider({id:e.id,label:e.label,scheme:e.scheme}),this._providers.set(e.id,{provider:e,extension:i}),x(()=>{for(const r of this._itemsBySourceAndUriMap.values())r.get(e.id)?.clear();this._providers.delete(e.id),this._proxy.$unregisterTimelineProvider(e.id),e.dispose()})}}function y(T){return T?.toString()}export{R as ExtHostTimeline,$ as IExtHostTimeline};
