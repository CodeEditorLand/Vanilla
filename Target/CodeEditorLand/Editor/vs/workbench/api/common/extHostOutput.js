var L=Object.defineProperty;var x=Object.getOwnPropertyDescriptor;var v=(p,i,e,t)=>{for(var r=t>1?void 0:t?x(i,e):i,o=p.length-1,s;o>=0;o--)(s=p[o])&&(r=(t?s(i,e,r):s(r))||r);return t&&r&&L(i,e,r),r},u=(p,i)=>(e,t)=>i(e,t,p);import{MainContext as y}from"./extHost.protocol.js";import{createDecorator as m}from"../../../platform/instantiation/common/instantiation.js";import{IExtHostRpcService as C}from"./extHostRpcService.js";import{ExtensionIdentifier as I}from"../../../platform/extensions/common/extensions.js";import{AbstractMessageLogger as S,ILoggerService as E,ILogService as H,log as b,parseLogLevel as O}from"../../../platform/log/common/log.js";import{OutputChannelUpdateMode as h}from"../../services/output/common/output.js";import{IExtHostConsumerFileSystem as D}from"./extHostFileSystemConsumer.js";import{IExtHostInitDataService as w}from"./extHostInitDataService.js";import{IExtHostFileSystemInfo as F}from"./extHostFileSystemInfo.js";import{toLocalISOString as $}from"../../../base/common/date.js";import{VSBuffer as U}from"../../../base/common/buffer.js";import{isString as c}from"../../../base/common/types.js";import{FileSystemProviderErrorCode as P,toFileSystemProviderErrorCode as M}from"../../../platform/files/common/files.js";import{Emitter as R}from"../../../base/common/event.js";import{DisposableStore as _}from"../../../base/common/lifecycle.js";class f extends S{constructor(e,t,r,o,s){super();this.id=e;this.name=t;this.logger=r;this.proxy=o;this.extension=s;this.setLevel(r.getLevel()),this._register(r.onDidChangeLogLevel(l=>this.setLevel(l)))}offset=0;_disposed=!1;get disposed(){return this._disposed}visible=!1;get logLevel(){return this.getLevel()}appendLine(e){this.append(e+`
`)}append(e){this.info(e)}clear(){const e=this.offset;this.logger.flush(),this.proxy.$update(this.id,h.Clear,e)}replace(e){const t=this.offset;this.info(e),this.proxy.$update(this.id,h.Replace,t),this.visible&&this.logger.flush()}show(e,t){this.logger.flush(),this.proxy.$reveal(this.id,!!(typeof e=="boolean"?e:t))}hide(){this.proxy.$close(this.id)}log(e,t){this.offset+=U.fromString(t).byteLength,b(this.logger,e,t),this.visible&&(this.logger.flush(),this.proxy.$update(this.id,h.Append))}dispose(){super.dispose(),this._disposed||(this.proxy.$dispose(this.id),this._disposed=!0)}}class T extends f{appendLine(i){this.append(i)}}let g=class{constructor(i,e,t,r,o,s){this.initData=e;this.extHostFileSystem=t;this.extHostFileSystemInfo=r;this.loggerService=o;this.logService=s;this.proxy=i.getProxy(y.MainThreadOutputService),this.outputsLocation=this.extHostFileSystemInfo.extUri.joinPath(e.logsLocation,`output_logging_${$(new Date).replace(/-|:|\.\d+Z$/g,"")}`)}_serviceBrand;proxy;outputsLocation;outputDirectoryPromise;extensionLogDirectoryPromise=new Map;namePool=1;channels=new Map;visibleChannelId=null;$setVisibleChannel(i){this.visibleChannelId=i;for(const[e,t]of this.channels)t.visible=e===this.visibleChannelId}createOutputChannel(i,e,t){if(i=i.trim(),!i)throw new Error("illegal argument `name`. must not be falsy");const r=typeof e=="object"&&e.log,o=c(e)?e:void 0;if(c(o)&&!o.trim())throw new Error("illegal argument `languageId`. must not be empty");let s;const l=this.initData.environment.extensionLogLevel?.find(([a])=>I.equals(t.identifier,a))?.[1];l&&(s=O(l));const n=r?this.doCreateLogOutputChannel(i,s,t):this.doCreateOutputChannel(i,o,t);return n.then(a=>{this.channels.set(a.id,a),a.visible=a.id===this.visibleChannelId}),r?this.createExtHostLogOutputChannel(i,s??this.logService.getLevel(),n):this.createExtHostOutputChannel(i,n)}async doCreateOutputChannel(i,e,t){this.outputDirectoryPromise||(this.outputDirectoryPromise=this.extHostFileSystem.value.createDirectory(this.outputsLocation).then(()=>this.outputsLocation));const r=await this.outputDirectoryPromise,o=this.extHostFileSystemInfo.extUri.joinPath(r,`${this.namePool++}-${i.replace(/[\\/:\*\?"<>\|]/g,"")}.log`),s=this.loggerService.createLogger(o,{logLevel:"always",donotRotate:!0,donotUseFormatters:!0,hidden:!0}),l=await this.proxy.$register(i,o,e,t.identifier.value);return new f(l,i,s,this.proxy,t)}async doCreateLogOutputChannel(i,e,t){const r=await this.createExtensionLogDirectory(t),o=i.replace(/[\\/:\*\?"<>\|]/g,""),s=this.extHostFileSystemInfo.extUri.joinPath(r,`${o}.log`),l=`${t.identifier.value}.${o}`,n=this.loggerService.createLogger(s,{id:l,name:i,logLevel:e,extensionId:t.identifier.value});return new T(l,i,n,this.proxy,t)}createExtensionLogDirectory(i){let e=this.extensionLogDirectoryPromise.get(i.identifier.value);if(!e){const t=this.extHostFileSystemInfo.extUri.joinPath(this.initData.logsLocation,i.identifier.value);this.extensionLogDirectoryPromise.set(i.identifier.value,e=(async()=>{try{await this.extHostFileSystem.value.createDirectory(t)}catch(r){if(M(r)!==P.FileExists)throw r}return t})())}return e}createExtHostOutputChannel(i,e){let t=!1;const r=()=>{if(t)throw new Error("Channel has been closed")};return{get name(){return i},append(o){r(),e.then(s=>s.append(o))},appendLine(o){r(),e.then(s=>s.appendLine(o))},clear(){r(),e.then(o=>o.clear())},replace(o){r(),e.then(s=>s.replace(o))},show(o,s){r(),e.then(l=>l.show(o,s))},hide(){r(),e.then(o=>o.hide())},dispose(){t=!0,e.then(o=>o.dispose())}}}createExtHostLogOutputChannel(i,e,t){const r=new _,o=()=>{if(r.isDisposed)throw new Error("Channel has been closed")},s=r.add(new R);function l(n){e=n,s.fire(n)}return t.then(n=>{r.add(n),n.logLevel!==e&&l(n.logLevel),r.add(n.onDidChangeLogLevel(a=>l(a)))}),{...this.createExtHostOutputChannel(i,t),get logLevel(){return e},onDidChangeLogLevel:s.event,trace(n,...a){o(),t.then(d=>d.trace(n,...a))},debug(n,...a){o(),t.then(d=>d.debug(n,...a))},info(n,...a){o(),t.then(d=>d.info(n,...a))},warn(n,...a){o(),t.then(d=>d.warn(n,...a))},error(n,...a){o(),t.then(d=>d.error(n,...a))},dispose(){r.dispose()}}}};g=v([u(0,C),u(1,w),u(2,D),u(3,F),u(4,E),u(5,H)],g);const ae=m("IExtHostOutputService");export{g as ExtHostOutputService,ae as IExtHostOutputService};
