import{URI as n}from"../../../base/common/uri.js";import{MainContext as w}from"./extHost.protocol.js";import*as l from"../../../platform/files/common/files.js";import{toDisposable as S}from"../../../base/common/lifecycle.js";import{FileChangeType as h}from"./extHostTypes.js";import*as _ from"./extHostTypeConverters.js";import"./extHostLanguageFeatures.js";import{State as m,StateMachine as b,LinkComputer as C}from"../../../editor/common/languages/linkComputer.js";import{commonPrefixLength as E}from"../../../base/common/strings.js";import{CharCode as y}from"../../../base/common/charCode.js";import{VSBuffer as P}from"../../../base/common/buffer.js";import"../../../platform/extensions/common/extensions.js";import{checkProposedApiEnabled as D}from"../../services/extensions/common/extensions.js";import{isMarkdownString as k}from"../../../base/common/htmlContent.js";class I{_schemes=[];_stateMachine;add(r){this._stateMachine=void 0,this._schemes.push(r)}delete(r){const e=this._schemes.indexOf(r);e>=0&&(this._schemes.splice(e,1),this._stateMachine=void 0)}_initStateMachine(){if(!this._stateMachine){const r=this._schemes.sort(),e=[];let i,t,o=m.LastKnownState,s=m.LastKnownState;for(const a of r){let d=i?E(i,a):0;for(d===0?t=m.Start:t=s;d<a.length;d++)d+1===a.length?(o=s,s=m.BeforeColon):s+=1,e.push([t,a.toUpperCase().charCodeAt(d),s]),e.push([t,a.toLowerCase().charCodeAt(d),s]),t=s;i=a,s=o}e.push([m.BeforeColon,y.Colon,m.AfterColon]),e.push([m.AfterColon,y.Slash,m.End]),this._stateMachine=new b(e)}}provideDocumentLinks(r){this._initStateMachine();const e=[],i=C.computeLinks({getLineContent(t){return r.lineAt(t-1).text},getLineCount(){return r.lineCount}},this._stateMachine);for(const t of i){const o=_.DocumentLink.to(t);o.target&&e.push(o)}return e}}class c{constructor(r,e){this._extHostLanguageFeatures=e;this._proxy=r.getProxy(w.MainThreadFileSystem)}_proxy;_linkProvider=new I;_fsProvider=new Map;_registeredSchemes=new Set;_watches=new Map;_linkProviderRegistration;_handlePool=0;dispose(){this._linkProviderRegistration?.dispose()}registerFileSystemProvider(r,e,i,t={}){if(c._validateFileSystemProvider(i),this._registeredSchemes.has(e))throw new Error(`a provider for the scheme '${e}' is already registered`);this._linkProviderRegistration||(this._linkProviderRegistration=this._extHostLanguageFeatures.registerDocumentLinkProvider(r,"*",this._linkProvider));const o=this._handlePool++;this._linkProvider.add(e),this._registeredSchemes.add(e),this._fsProvider.set(o,i);let s=l.FileSystemProviderCapabilities.FileReadWrite;t.isCaseSensitive&&(s+=l.FileSystemProviderCapabilities.PathCaseSensitive),t.isReadonly&&(s+=l.FileSystemProviderCapabilities.Readonly),typeof i.copy=="function"&&(s+=l.FileSystemProviderCapabilities.FileFolderCopy),typeof i.open=="function"&&typeof i.close=="function"&&typeof i.read=="function"&&typeof i.write=="function"&&(D(r,"fsChunks"),s+=l.FileSystemProviderCapabilities.FileOpenReadWriteClose);let a;t.isReadonly&&k(t.isReadonly)&&t.isReadonly.value!==""&&(a={value:t.isReadonly.value,isTrusted:t.isReadonly.isTrusted,supportThemeIcons:t.isReadonly.supportThemeIcons,supportHtml:t.isReadonly.supportHtml,baseUri:t.isReadonly.baseUri,uris:t.isReadonly.uris}),this._proxy.$registerFileSystemProvider(o,e,s,a).catch(v=>{console.error(`FAILED to register filesystem provider of ${r.identifier.value}-extension for the scheme ${e}`),console.error(v)});const d=i.onDidChangeFile(v=>{const f=[];for(const g of v){const{uri:u,type:F}=g;if(u.scheme!==e)continue;let p;switch(F){case h.Changed:p=l.FileChangeType.UPDATED;break;case h.Created:p=l.FileChangeType.ADDED;break;case h.Deleted:p=l.FileChangeType.DELETED;break;default:throw new Error("Unknown FileChangeType")}f.push({resource:u,type:p})}this._proxy.$onFileSystemChange(o,f)});return S(()=>{d.dispose(),this._linkProvider.delete(e),this._registeredSchemes.delete(e),this._fsProvider.delete(o),this._proxy.$unregisterProvider(o)})}static _validateFileSystemProvider(r){if(!r)throw new Error("MISSING provider");if(typeof r.watch!="function")throw new Error("Provider does NOT implement watch");if(typeof r.stat!="function")throw new Error("Provider does NOT implement stat");if(typeof r.readDirectory!="function")throw new Error("Provider does NOT implement readDirectory");if(typeof r.createDirectory!="function")throw new Error("Provider does NOT implement createDirectory");if(typeof r.readFile!="function")throw new Error("Provider does NOT implement readFile");if(typeof r.writeFile!="function")throw new Error("Provider does NOT implement writeFile");if(typeof r.delete!="function")throw new Error("Provider does NOT implement delete");if(typeof r.rename!="function")throw new Error("Provider does NOT implement rename")}static _asIStat(r){const{type:e,ctime:i,mtime:t,size:o,permissions:s}=r;return{type:e,ctime:i,mtime:t,size:o,permissions:s}}$stat(r,e){return Promise.resolve(this._getFsProvider(r).stat(n.revive(e))).then(i=>c._asIStat(i))}$readdir(r,e){return Promise.resolve(this._getFsProvider(r).readDirectory(n.revive(e)))}$readFile(r,e){return Promise.resolve(this._getFsProvider(r).readFile(n.revive(e))).then(i=>P.wrap(i))}$writeFile(r,e,i,t){return Promise.resolve(this._getFsProvider(r).writeFile(n.revive(e),i.buffer,t))}$delete(r,e,i){return Promise.resolve(this._getFsProvider(r).delete(n.revive(e),i))}$rename(r,e,i,t){return Promise.resolve(this._getFsProvider(r).rename(n.revive(e),n.revive(i),t))}$copy(r,e,i,t){const o=this._getFsProvider(r);if(!o.copy)throw new Error('FileSystemProvider does not implement "copy"');return Promise.resolve(o.copy(n.revive(e),n.revive(i),t))}$mkdir(r,e){return Promise.resolve(this._getFsProvider(r).createDirectory(n.revive(e)))}$watch(r,e,i,t){const o=this._getFsProvider(r).watch(n.revive(i),t);this._watches.set(e,o)}$unwatch(r,e){const i=this._watches.get(e);i&&(i.dispose(),this._watches.delete(e))}$open(r,e,i){const t=this._getFsProvider(r);if(!t.open)throw new Error('FileSystemProvider does not implement "open"');return Promise.resolve(t.open(n.revive(e),i))}$close(r,e){const i=this._getFsProvider(r);if(!i.close)throw new Error('FileSystemProvider does not implement "close"');return Promise.resolve(i.close(e))}$read(r,e,i,t){const o=this._getFsProvider(r);if(!o.read)throw new Error('FileSystemProvider does not implement "read"');const s=P.alloc(t);return Promise.resolve(o.read(e,i,s.buffer,0,t)).then(a=>s.slice(0,a))}$write(r,e,i,t){const o=this._getFsProvider(r);if(!o.write)throw new Error('FileSystemProvider does not implement "write"');return Promise.resolve(o.write(e,i,t.buffer,0,t.byteLength))}_getFsProvider(r){const e=this._fsProvider.get(r);if(!e){const i=new Error;throw i.name="ENOPRO",i.message="no provider",i}return e}}export{c as ExtHostFileSystem};
