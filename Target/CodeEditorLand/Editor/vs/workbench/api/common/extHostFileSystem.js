import{VSBuffer as y}from"../../../base/common/buffer.js";import{CharCode as P}from"../../../base/common/charCode.js";import{isMarkdownString as w}from"../../../base/common/htmlContent.js";import{toDisposable as S}from"../../../base/common/lifecycle.js";import{commonPrefixLength as _}from"../../../base/common/strings.js";import{URI as n}from"../../../base/common/uri.js";import{LinkComputer as C,State as d,StateMachine as b}from"../../../editor/common/languages/linkComputer.js";import*as m from"../../../platform/files/common/files.js";import{checkProposedApiEnabled as E}from"../../services/extensions/common/extensions.js";import{MainContext as D}from"./extHost.protocol.js";import*as k from"./extHostTypeConverters.js";import{FileChangeType as v}from"./extHostTypes.js";class x{_schemes=[];_stateMachine;add(r){this._stateMachine=void 0,this._schemes.push(r)}delete(r){const e=this._schemes.indexOf(r);e>=0&&(this._schemes.splice(e,1),this._stateMachine=void 0)}_initStateMachine(){if(!this._stateMachine){const r=this._schemes.sort(),e=[];let t,i,o=d.LastKnownState,s=d.LastKnownState;for(const a of r){let l=t?_(t,a):0;for(l===0?i=d.Start:i=s;l<a.length;l++)l+1===a.length?(o=s,s=d.BeforeColon):s+=1,e.push([i,a.toUpperCase().charCodeAt(l),s]),e.push([i,a.toLowerCase().charCodeAt(l),s]),i=s;t=a,s=o}e.push([d.BeforeColon,P.Colon,d.AfterColon]),e.push([d.AfterColon,P.Slash,d.End]),this._stateMachine=new b(e)}}provideDocumentLinks(r){this._initStateMachine();const e=[],t=C.computeLinks({getLineContent(i){return r.lineAt(i-1).text},getLineCount(){return r.lineCount}},this._stateMachine);for(const i of t){const o=k.DocumentLink.to(i);o.target&&e.push(o)}return e}}class h{constructor(r,e){this._extHostLanguageFeatures=e;this._proxy=r.getProxy(D.MainThreadFileSystem)}_proxy;_linkProvider=new x;_fsProvider=new Map;_registeredSchemes=new Set;_watches=new Map;_linkProviderRegistration;_handlePool=0;dispose(){this._linkProviderRegistration?.dispose()}registerFileSystemProvider(r,e,t,i={}){if(h._validateFileSystemProvider(t),this._registeredSchemes.has(e))throw new Error(`a provider for the scheme '${e}' is already registered`);this._linkProviderRegistration||(this._linkProviderRegistration=this._extHostLanguageFeatures.registerDocumentLinkProvider(r,"*",this._linkProvider));const o=this._handlePool++;this._linkProvider.add(e),this._registeredSchemes.add(e),this._fsProvider.set(o,t);let s=m.FileSystemProviderCapabilities.FileReadWrite;i.isCaseSensitive&&(s+=m.FileSystemProviderCapabilities.PathCaseSensitive),i.isReadonly&&(s+=m.FileSystemProviderCapabilities.Readonly),typeof t.copy=="function"&&(s+=m.FileSystemProviderCapabilities.FileFolderCopy),typeof t.open=="function"&&typeof t.close=="function"&&typeof t.read=="function"&&typeof t.write=="function"&&(E(r,"fsChunks"),s+=m.FileSystemProviderCapabilities.FileOpenReadWriteClose);let a;i.isReadonly&&w(i.isReadonly)&&i.isReadonly.value!==""&&(a={value:i.isReadonly.value,isTrusted:i.isReadonly.isTrusted,supportThemeIcons:i.isReadonly.supportThemeIcons,supportHtml:i.isReadonly.supportHtml,baseUri:i.isReadonly.baseUri,uris:i.isReadonly.uris}),this._proxy.$registerFileSystemProvider(o,e,s,a).catch(c=>{});const l=t.onDidChangeFile(c=>{const f=[];for(const g of c){const{uri:u,type:F}=g;if(u.scheme!==e)continue;let p;switch(F){case v.Changed:p=m.FileChangeType.UPDATED;break;case v.Created:p=m.FileChangeType.ADDED;break;case v.Deleted:p=m.FileChangeType.DELETED;break;default:throw new Error("Unknown FileChangeType")}f.push({resource:u,type:p})}this._proxy.$onFileSystemChange(o,f)});return S(()=>{l.dispose(),this._linkProvider.delete(e),this._registeredSchemes.delete(e),this._fsProvider.delete(o),this._proxy.$unregisterProvider(o)})}static _validateFileSystemProvider(r){if(!r)throw new Error("MISSING provider");if(typeof r.watch!="function")throw new Error("Provider does NOT implement watch");if(typeof r.stat!="function")throw new Error("Provider does NOT implement stat");if(typeof r.readDirectory!="function")throw new Error("Provider does NOT implement readDirectory");if(typeof r.createDirectory!="function")throw new Error("Provider does NOT implement createDirectory");if(typeof r.readFile!="function")throw new Error("Provider does NOT implement readFile");if(typeof r.writeFile!="function")throw new Error("Provider does NOT implement writeFile");if(typeof r.delete!="function")throw new Error("Provider does NOT implement delete");if(typeof r.rename!="function")throw new Error("Provider does NOT implement rename")}static _asIStat(r){const{type:e,ctime:t,mtime:i,size:o,permissions:s}=r;return{type:e,ctime:t,mtime:i,size:o,permissions:s}}$stat(r,e){return Promise.resolve(this._getFsProvider(r).stat(n.revive(e))).then(t=>h._asIStat(t))}$readdir(r,e){return Promise.resolve(this._getFsProvider(r).readDirectory(n.revive(e)))}$readFile(r,e){return Promise.resolve(this._getFsProvider(r).readFile(n.revive(e))).then(t=>y.wrap(t))}$writeFile(r,e,t,i){return Promise.resolve(this._getFsProvider(r).writeFile(n.revive(e),t.buffer,i))}$delete(r,e,t){return Promise.resolve(this._getFsProvider(r).delete(n.revive(e),t))}$rename(r,e,t,i){return Promise.resolve(this._getFsProvider(r).rename(n.revive(e),n.revive(t),i))}$copy(r,e,t,i){const o=this._getFsProvider(r);if(!o.copy)throw new Error('FileSystemProvider does not implement "copy"');return Promise.resolve(o.copy(n.revive(e),n.revive(t),i))}$mkdir(r,e){return Promise.resolve(this._getFsProvider(r).createDirectory(n.revive(e)))}$watch(r,e,t,i){const o=this._getFsProvider(r).watch(n.revive(t),i);this._watches.set(e,o)}$unwatch(r,e){const t=this._watches.get(e);t&&(t.dispose(),this._watches.delete(e))}$open(r,e,t){const i=this._getFsProvider(r);if(!i.open)throw new Error('FileSystemProvider does not implement "open"');return Promise.resolve(i.open(n.revive(e),t))}$close(r,e){const t=this._getFsProvider(r);if(!t.close)throw new Error('FileSystemProvider does not implement "close"');return Promise.resolve(t.close(e))}$read(r,e,t,i){const o=this._getFsProvider(r);if(!o.read)throw new Error('FileSystemProvider does not implement "read"');const s=y.alloc(i);return Promise.resolve(o.read(e,t,s.buffer,0,i)).then(a=>s.slice(0,a))}$write(r,e,t,i){const o=this._getFsProvider(r);if(!o.write)throw new Error('FileSystemProvider does not implement "write"');return Promise.resolve(o.write(e,t,i.buffer,0,i.byteLength))}_getFsProvider(r){const e=this._fsProvider.get(r);if(!e){const t=new Error;throw t.name="ENOPRO",t.message="no provider",t}return e}}export{h as ExtHostFileSystem};
