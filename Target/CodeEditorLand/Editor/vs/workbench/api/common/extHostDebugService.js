var U=Object.defineProperty;var W=Object.getOwnPropertyDescriptor;var C=(p,n,e,i)=>{for(var t=i>1?void 0:i?W(n,e):n,o=p.length-1,r;o>=0;o--)(r=p[o])&&(t=(i?r(n,e,t):r(t))||t);return i&&t&&U(n,e,t),t},c=(p,n)=>(e,i)=>n(e,i,p);import{coalesce as N}from"../../../../vs/base/common/arrays.js";import{asPromise as h}from"../../../../vs/base/common/async.js";import"../../../../vs/base/common/cancellation.js";import{Emitter as v}from"../../../../vs/base/common/event.js";import{Disposable as q,toDisposable as k}from"../../../../vs/base/common/lifecycle.js";import{ThemeIcon as O}from"../../../../vs/base/common/themables.js";import{URI as b}from"../../../../vs/base/common/uri.js";import{ExtensionIdentifier as E}from"../../../../vs/platform/extensions/common/extensions.js";import{createDecorator as K}from"../../../../vs/platform/instantiation/common/instantiation.js";import"../../../../vs/platform/sign/common/sign.js";import"../../../../vs/platform/workspace/common/workspace.js";import{MainContext as j}from"../../../../vs/workbench/api/common/extHost.protocol.js";import{IExtHostCommands as P}from"../../../../vs/workbench/api/common/extHostCommands.js";import{IExtHostEditorTabs as T}from"../../../../vs/workbench/api/common/extHostEditorTabs.js";import{IExtHostExtensionService as x}from"../../../../vs/workbench/api/common/extHostExtensionService.js";import{IExtHostRpcService as w}from"../../../../vs/workbench/api/common/extHostRpcService.js";import{IExtHostTesting as z}from"../../../../vs/workbench/api/common/extHostTesting.js";import*as L from"../../../../vs/workbench/api/common/extHostTypeConverters.js";import{DataBreakpoint as A,DebugAdapterExecutable as G,DebugAdapterInlineImplementation as J,DebugAdapterNamedPipeServer as Q,DebugAdapterServer as V,DebugConsoleMode as X,DebugStackFrame as Y,DebugThread as Z,Disposable as D,FunctionBreakpoint as S,Location as F,Position as M,setBreakpointId as ee,SourceBreakpoint as y,ThemeIcon as ie}from"../../../../vs/workbench/api/common/extHostTypes.js";import{IExtHostWorkspace as B}from"../../../../vs/workbench/api/common/extHostWorkspace.js";import{AbstractDebugAdapter as te}from"../../../../vs/workbench/contrib/debug/common/abstractDebugAdapter.js";import{DebugVisualizationType as $}from"../../../../vs/workbench/contrib/debug/common/debug.js";import{convertToDAPaths as re,convertToVSCPaths as oe,isDebuggerMainContribution as se}from"../../../../vs/workbench/contrib/debug/common/debugUtils.js";import"../../../../vs/workbench/services/extensions/common/extensionDescriptionRegistry.js";import"../../../../vs/workbench/services/extensions/common/proxyIdentifier.js";import{IExtHostConfiguration as R}from"../common/extHostConfiguration.js";import{IExtHostVariableResolverProvider as H}from"./extHostVariableResolverService.js";const pi=K("IExtHostDebugService");let m=class extends q{constructor(e,i,t,o,r,s,a,g){super();this._workspaceService=i;this._extensionService=t;this._configurationService=o;this._editorTabs=r;this._variableResolver=s;this._commands=a;this._testing=g;this._configProviderHandleCounter=0,this._configProviders=[],this._adapterFactoryHandleCounter=0,this._adapterFactories=[],this._trackerFactoryHandleCounter=0,this._trackerFactories=[],this._debugAdapters=new Map,this._debugAdaptersTrackers=new Map,this._onDidStartDebugSession=this._register(new v),this._onDidTerminateDebugSession=this._register(new v),this._onDidChangeActiveDebugSession=this._register(new v),this._onDidReceiveDebugSessionCustomEvent=this._register(new v),this._debugServiceProxy=e.getProxy(j.MainThreadDebugService),this._onDidChangeBreakpoints=this._register(new v),this._onDidChangeActiveStackItem=this._register(new v),this._activeDebugConsole=new ae(this._debugServiceProxy),this._breakpoints=new Map,this._extensionService.getExtensionRegistry().then(u=>{this._register(u.onDidChange(d=>{this.registerAllDebugTypes(u)})),this.registerAllDebugTypes(u)})}_serviceBrand;_configProviderHandleCounter;_configProviders;_adapterFactoryHandleCounter;_adapterFactories;_trackerFactoryHandleCounter;_trackerFactories;_debugServiceProxy;_debugSessions=new Map;_onDidStartDebugSession;get onDidStartDebugSession(){return this._onDidStartDebugSession.event}_onDidTerminateDebugSession;get onDidTerminateDebugSession(){return this._onDidTerminateDebugSession.event}_onDidChangeActiveDebugSession;get onDidChangeActiveDebugSession(){return this._onDidChangeActiveDebugSession.event}_activeDebugSession;get activeDebugSession(){return this._activeDebugSession?.api}_onDidReceiveDebugSessionCustomEvent;get onDidReceiveDebugSessionCustomEvent(){return this._onDidReceiveDebugSessionCustomEvent.event}_activeDebugConsole;get activeDebugConsole(){return this._activeDebugConsole.value}_breakpoints;_onDidChangeBreakpoints;_activeStackItem;_onDidChangeActiveStackItem;_debugAdapters;_debugAdaptersTrackers;_debugVisualizationTreeItemIdsCounter=0;_debugVisualizationProviders=new Map;_debugVisualizationTrees=new Map;_debugVisualizationTreeItemIds=new WeakMap;_debugVisualizationElements=new Map;_signService;_visualizers=new Map;_visualizerIdCounter=0;async $getVisualizerTreeItem(e,i){const t=this.hydrateVisualizationContext(i);if(!t)return;const o=await this._debugVisualizationTrees.get(e)?.getTreeItem?.(t);return o?this.convertVisualizerTreeItem(e,o):void 0}registerDebugVisualizationTree(e,i,t){const o=E.toKey(e.identifier),r=this.extensionVisKey(o,i);if(this._debugVisualizationProviders.has(r))throw new Error(`A debug visualization provider with id '${i}' is already registered`);return this._debugVisualizationTrees.set(r,t),this._debugServiceProxy.$registerDebugVisualizerTree(r,!!t.editItem),k(()=>{this._debugServiceProxy.$unregisterDebugVisualizerTree(r),this._debugVisualizationTrees.delete(i)})}async $getVisualizerTreeItemChildren(e,i){const t=this._debugVisualizationElements.get(i)?.item;return t?(await this._debugVisualizationTrees.get(e)?.getChildren?.(t))?.map(r=>this.convertVisualizerTreeItem(e,r))||[]:[]}async $editVisualizerTreeItem(e,i){const t=this._debugVisualizationElements.get(e);if(!t)return;const o=await this._debugVisualizationTrees.get(t.provider)?.editItem?.(t.item,i);return this.convertVisualizerTreeItem(t.provider,o||t.item)}$disposeVisualizedTree(e){const i=this._debugVisualizationElements.get(e);if(!i)return;const t=[i.children];for(const o of t)if(o)for(const r of o)t.push(this._debugVisualizationElements.get(r)?.children),this._debugVisualizationElements.delete(r)}convertVisualizerTreeItem(e,i){let t=this._debugVisualizationTreeItemIds.get(i);return t||(t=this._debugVisualizationTreeItemIdsCounter++,this._debugVisualizationTreeItemIds.set(i,t),this._debugVisualizationElements.set(t,{provider:e,item:i})),L.DebugTreeItem.from(i,t)}asDebugSourceUri(e,i){const t=e;if(typeof t.sourceReference=="number"&&t.sourceReference>0){let o=`debug:${encodeURIComponent(t.path||"")}`,r="?";return i&&(o+=`${r}session=${encodeURIComponent(i.id)}`,r="&"),o+=`${r}ref=${t.sourceReference}`,b.parse(o)}else{if(t.path)return b.file(t.path);throw new Error("cannot create uri from DAP 'source' object; properties 'path' and 'sourceReference' are both missing.")}}registerAllDebugTypes(e){const i=[];for(const t of e.getAllExtensionDescriptions())if(t.contributes){const o=t.contributes.debuggers;if(o&&o.length>0)for(const r of o)se(r)&&i.push(r.type)}this._debugServiceProxy.$registerDebugTypes(i)}get activeStackItem(){return this._activeStackItem}get onDidChangeActiveStackItem(){return this._onDidChangeActiveStackItem.event}get onDidChangeBreakpoints(){return this._onDidChangeBreakpoints.event}get breakpoints(){const e=[];return this._breakpoints.forEach(i=>e.push(i)),e}async $resolveDebugVisualizer(e,i){const t=this._visualizers.get(e);if(!t)throw new Error(`No debug visualizer found with id '${e}'`);let{v:o,provider:r,extensionId:s}=t;if(o.visualization||(o=await r.resolveDebugVisualization?.(o,i)||o,t.v=o),!o.visualization)throw new Error(`No visualization returned from resolveDebugVisualization in '${r}'`);return this.serializeVisualization(s,o.visualization)}async $executeDebugVisualizerCommand(e){const i=this._visualizers.get(e);if(!i)throw new Error(`No debug visualizer found with id '${e}'`);const t=i.v.visualization;t&&"command"in t&&this._commands.executeCommand(t.command,...t.arguments||[])}hydrateVisualizationContext(e){const i=this._debugSessions.get(e.sessionId);return i&&{session:i.api,variable:e.variable,containerId:e.containerId,frameId:e.frameId,threadId:e.threadId}}async $provideDebugVisualizers(e,i,t,o){const r=this.hydrateVisualizationContext(t),s=this.extensionVisKey(e,i),a=this._debugVisualizationProviders.get(s);if(!r||!a)return[];const g=await a.provideDebugVisualization(r,o);return g?g.map(u=>{const d=++this._visualizerIdCounter;this._visualizers.set(d,{v:u,provider:a,extensionId:e});const l=u.iconPath?this.getIconPathOrClass(u.iconPath):void 0;return{id:d,name:u.name,iconClass:l?.iconClass,iconPath:l?.iconPath,visualization:this.serializeVisualization(e,u.visualization)}}):[]}$disposeDebugVisualizers(e){for(const i of e)this._visualizers.delete(i)}registerDebugVisualizationProvider(e,i,t){if(!e.contributes?.debugVisualizers?.some(s=>s.id===i))throw new Error(`Extensions may only call registerDebugVisualizationProvider() for renderers they contribute (got ${i})`);const o=E.toKey(e.identifier),r=this.extensionVisKey(o,i);if(this._debugVisualizationProviders.has(r))throw new Error(`A debug visualization provider with id '${i}' is already registered`);return this._debugVisualizationProviders.set(r,t),this._debugServiceProxy.$registerDebugVisualizer(o,i),k(()=>{this._debugServiceProxy.$unregisterDebugVisualizer(o,i),this._debugVisualizationProviders.delete(i)})}addBreakpoints(e){const i=e.filter(r=>{const s=r.id;return this._breakpoints.has(s)?!1:(this._breakpoints.set(s,r),!0)});this.fireBreakpointChanges(i,[],[]);const t=[],o=new Map;for(const r of i)if(r instanceof y){let s=o.get(r.location.uri.toString());s||(s={type:"sourceMulti",uri:r.location.uri,lines:[]},o.set(r.location.uri.toString(),s),t.push(s)),s.lines.push({id:r.id,enabled:r.enabled,condition:r.condition,hitCondition:r.hitCondition,logMessage:r.logMessage,line:r.location.range.start.line,character:r.location.range.start.character,mode:r.mode})}else r instanceof S&&t.push({type:"function",id:r.id,enabled:r.enabled,hitCondition:r.hitCondition,logMessage:r.logMessage,condition:r.condition,functionName:r.functionName,mode:r.mode});return this._debugServiceProxy.$registerBreakpoints(t)}removeBreakpoints(e){const i=e.filter(s=>this._breakpoints.delete(s.id));this.fireBreakpointChanges([],i,[]);const t=i.filter(s=>s instanceof y).map(s=>s.id),o=i.filter(s=>s instanceof S).map(s=>s.id),r=i.filter(s=>s instanceof A).map(s=>s.id);return this._debugServiceProxy.$unregisterBreakpoints(t,o,r)}startDebugging(e,i,t){const o=t.testRun&&this._testing.getMetadataForRun(t.testRun);return this._debugServiceProxy.$startDebugging(e?e.uri:void 0,i,{parentSessionID:t.parentSession?t.parentSession.id:void 0,lifecycleManagedByParent:t.lifecycleManagedByParent,repl:t.consoleMode===X.MergeWithParent?"mergeWithParent":"separate",noDebug:t.noDebug,compact:t.compact,suppressSaveBeforeStart:t.suppressSaveBeforeStart,testRun:o&&{runId:o.runId,taskId:o.taskId},suppressDebugStatusbar:t.suppressDebugStatusbar??t.debugUI?.simple,suppressDebugToolbar:t.suppressDebugToolbar??t.debugUI?.simple,suppressDebugView:t.suppressDebugView??t.debugUI?.simple})}stopDebugging(e){return this._debugServiceProxy.$stopDebugging(e?e.id:void 0)}registerDebugConfigurationProvider(e,i,t){if(!i)return new D(()=>{});const o=this._configProviderHandleCounter++;return this._configProviders.push({type:e,handle:o,provider:i}),this._debugServiceProxy.$registerDebugConfigurationProvider(e,t,!!i.provideDebugConfigurations,!!i.resolveDebugConfiguration,!!i.resolveDebugConfigurationWithSubstitutedVariables,o),new D(()=>{this._configProviders=this._configProviders.filter(r=>r.provider!==i),this._debugServiceProxy.$unregisterDebugConfigurationProvider(o)})}registerDebugAdapterDescriptorFactory(e,i,t){if(!t)return new D(()=>{});if(!this.definesDebugType(e,i))throw new Error(`a DebugAdapterDescriptorFactory can only be registered from the extension that defines the '${i}' debugger.`);if(this.getAdapterDescriptorFactoryByType(i))throw new Error("a DebugAdapterDescriptorFactory can only be registered once per a type.");const o=this._adapterFactoryHandleCounter++;return this._adapterFactories.push({type:i,handle:o,factory:t}),this._debugServiceProxy.$registerDebugAdapterDescriptorFactory(i,o),new D(()=>{this._adapterFactories=this._adapterFactories.filter(r=>r.factory!==t),this._debugServiceProxy.$unregisterDebugAdapterDescriptorFactory(o)})}registerDebugAdapterTrackerFactory(e,i){if(!i)return new D(()=>{});const t=this._trackerFactoryHandleCounter++;return this._trackerFactories.push({type:e,handle:t,factory:i}),new D(()=>{this._trackerFactories=this._trackerFactories.filter(o=>o.factory!==i)})}async $runInTerminal(e,i){return Promise.resolve(void 0)}async $substituteVariables(e,i){let t;const o=await this.getFolder(e);return o&&(t={uri:o.uri,name:o.name,index:o.index,toResource:()=>{throw new Error("Not implemented")}}),(await this._variableResolver.getResolver()).resolveAnyAsync(t,i)}createDebugAdapter(e,i){if(e.type==="implementation")return new de(e.implementation)}createSignService(){}async $startDASession(e,i){const t=this,o=await this.getSession(i);return this.getAdapterDescriptor(this.getAdapterDescriptorFactoryByType(o.type),o).then(r=>{if(!r)throw new Error(`Couldn't find a debug adapter descriptor for debug type '${o.type}' (extension might have failed to activate)`);const s=this.convertToDto(r),a=this.createDebugAdapter(s,o);if(!a)throw new Error(`Couldn't create a debug adapter for type '${o.type}'.`);const g=a;return this._debugAdapters.set(e,g),this.getDebugAdapterTrackers(o).then(u=>(u&&this._debugAdaptersTrackers.set(e,u),g.onMessage(async d=>{if(d.type==="request"&&d.command==="handshake"){const l=d,f={type:"response",seq:0,command:l.command,request_seq:l.seq,success:!0};this._signService||(this._signService=this.createSignService());try{if(this._signService){const I=await this._signService.sign(l.arguments.value);f.body={signature:I},g.sendResponse(f)}else throw new Error("no signer")}catch(I){f.success=!1,f.message=I.message,g.sendResponse(f)}}else u&&u.onDidSendMessage&&u.onDidSendMessage(d),d=oe(d,!0),t._debugServiceProxy.$acceptDAMessage(e,d)}),g.onError(d=>{u&&u.onError&&u.onError(d),this._debugServiceProxy.$acceptDAError(e,d.name,d.message,d.stack)}),g.onExit(d=>{u&&u.onExit&&u.onExit(d??void 0,void 0),this._debugServiceProxy.$acceptDAExit(e,d??void 0,void 0)}),u&&u.onWillStartSession&&u.onWillStartSession(),g.startSession()))})}$sendDAMessage(e,i){i=re(i,!1);const t=this._debugAdaptersTrackers.get(e);t&&t.onWillReceiveMessage&&t.onWillReceiveMessage(i),this._debugAdapters.get(e)?.sendMessage(i)}$stopDASession(e){const i=this._debugAdaptersTrackers.get(e);this._debugAdaptersTrackers.delete(e),i&&i.onWillStopSession&&i.onWillStopSession();const t=this._debugAdapters.get(e);return this._debugAdapters.delete(e),t?t.stopSession():Promise.resolve(void 0)}$acceptBreakpointsDelta(e){const i=[],t=[],o=[];if(e.added)for(const r of e.added){const s=r.id;if(s&&!this._breakpoints.has(s)){let a;if(r.type==="function")a=new S(r.functionName,r.enabled,r.condition,r.hitCondition,r.logMessage,r.mode);else if(r.type==="data")a=new A(r.label,r.dataId,r.canPersist,r.enabled,r.hitCondition,r.condition,r.logMessage,r.mode);else{const g=b.revive(r.uri);a=new y(new F(g,new M(r.line,r.character)),r.enabled,r.condition,r.hitCondition,r.logMessage,r.mode)}ee(a,s),this._breakpoints.set(s,a),i.push(a)}}if(e.removed)for(const r of e.removed){const s=this._breakpoints.get(r);s&&(this._breakpoints.delete(r),t.push(s))}if(e.changed){for(const r of e.changed)if(r.id){const s=this._breakpoints.get(r.id);if(s){if(s instanceof S&&r.type==="function"){const a=s;a.enabled=r.enabled,a.condition=r.condition,a.hitCondition=r.hitCondition,a.logMessage=r.logMessage,a.functionName=r.functionName}else if(s instanceof y&&r.type==="source"){const a=s;a.enabled=r.enabled,a.condition=r.condition,a.hitCondition=r.hitCondition,a.logMessage=r.logMessage,a.location=new F(b.revive(r.uri),new M(r.line,r.character))}o.push(s)}}}this.fireBreakpointChanges(i,t,o)}async $acceptStackFrameFocus(e){let i;if(e){const t=await this.getSession(e.sessionId);e.kind==="thread"?i=new Z(t.api,e.threadId):i=new Y(t.api,e.threadId,e.frameId)}this._activeStackItem=i,this._onDidChangeActiveStackItem.fire(this._activeStackItem)}$provideDebugConfigurations(e,i,t){return h(async()=>{const o=this.getConfigProviderByHandle(e);if(!o)throw new Error("no DebugConfigurationProvider found");if(!o.provideDebugConfigurations)throw new Error("DebugConfigurationProvider has no method provideDebugConfigurations");const r=await this.getFolder(i);return o.provideDebugConfigurations(r,t)}).then(o=>{if(!o)throw new Error("nothing returned from DebugConfigurationProvider.provideDebugConfigurations");return o})}$resolveDebugConfiguration(e,i,t,o){return h(async()=>{const r=this.getConfigProviderByHandle(e);if(!r)throw new Error("no DebugConfigurationProvider found");if(!r.resolveDebugConfiguration)throw new Error("DebugConfigurationProvider has no method resolveDebugConfiguration");const s=await this.getFolder(i);return r.resolveDebugConfiguration(s,t,o)})}$resolveDebugConfigurationWithSubstitutedVariables(e,i,t,o){return h(async()=>{const r=this.getConfigProviderByHandle(e);if(!r)throw new Error("no DebugConfigurationProvider found");if(!r.resolveDebugConfigurationWithSubstitutedVariables)throw new Error("DebugConfigurationProvider has no method resolveDebugConfigurationWithSubstitutedVariables");const s=await this.getFolder(i);return r.resolveDebugConfigurationWithSubstitutedVariables(s,t,o)})}async $provideDebugAdapter(e,i){const t=this.getAdapterDescriptorFactoryByHandle(e);if(!t)return Promise.reject(new Error("no adapter descriptor factory found for handle"));const o=await this.getSession(i);return this.getAdapterDescriptor(t,o).then(r=>{if(!r)throw new Error(`Couldn't find a debug adapter descriptor for debug type '${o.type}'`);return this.convertToDto(r)})}async $acceptDebugSessionStarted(e){const i=await this.getSession(e);this._onDidStartDebugSession.fire(i.api)}async $acceptDebugSessionTerminated(e){const i=await this.getSession(e);i&&(this._onDidTerminateDebugSession.fire(i.api),this._debugSessions.delete(i.id))}async $acceptDebugSessionActiveChanged(e){this._activeDebugSession=e?await this.getSession(e):void 0,this._onDidChangeActiveDebugSession.fire(this._activeDebugSession?.api)}async $acceptDebugSessionNameChanged(e,i){(await this.getSession(e))?._acceptNameChanged(i)}async $acceptDebugSessionCustomEvent(e,i){const o={session:(await this.getSession(e)).api,event:i.event,body:i.body};this._onDidReceiveDebugSessionCustomEvent.fire(o)}convertToDto(e){if(e instanceof G)return{type:"executable",command:e.command,args:e.args,options:e.options};if(e instanceof V)return{type:"server",port:e.port,host:e.host};if(e instanceof Q)return{type:"pipeServer",path:e.path};if(e instanceof J)return{type:"implementation",implementation:e.implementation};throw new Error("convertToDto unexpected type")}getAdapterDescriptorFactoryByType(e){const i=this._adapterFactories.filter(t=>t.type===e);if(i.length>0)return i[0].factory}getAdapterDescriptorFactoryByHandle(e){const i=this._adapterFactories.filter(t=>t.handle===e);if(i.length>0)return i[0].factory}getConfigProviderByHandle(e){const i=this._configProviders.filter(t=>t.handle===e);if(i.length>0)return i[0].provider}definesDebugType(e,i){if(e.contributes){const t=e.contributes.debuggers;if(t&&t.length>0){for(const o of t)if(o.label&&o.type&&o.type===i)return!0}}return!1}getDebugAdapterTrackers(e){const t=e.configuration.type,o=this._trackerFactories.filter(r=>r.type===t||r.type==="*").map(r=>h(()=>r.factory.createDebugAdapterTracker(e.api)).then(s=>s,s=>null));return Promise.race([Promise.all(o).then(r=>{const s=N(r);if(s.length>0)return new ue(s)}),new Promise(r=>setTimeout(()=>r(void 0),1e3))]).catch(r=>{})}async getAdapterDescriptor(e,i){const t=i.configuration.debugServer;if(typeof t=="number")return Promise.resolve(new V(t));if(e){const r=await this._extensionService.getExtensionRegistry();return h(()=>e.createDebugAdapterDescriptor(i.api,this.daExecutableFromPackage(i,r))).then(s=>{if(s)return s})}const o=await this._extensionService.getExtensionRegistry();return Promise.resolve(this.daExecutableFromPackage(i,o))}daExecutableFromPackage(e,i){}fireBreakpointChanges(e,i,t){(e.length>0||i.length>0||t.length>0)&&this._onDidChangeBreakpoints.fire(Object.freeze({added:e,removed:i,changed:t}))}async getSession(e){if(e)if(typeof e=="string"){const i=this._debugSessions.get(e);if(i)return i}else{let i=this._debugSessions.get(e.id);if(!i){const t=await this.getFolder(e.folderUri),o=e.parent?this._debugSessions.get(e.parent):void 0;i=new ne(this._debugServiceProxy,e.id,e.type,e.name,t,e.configuration,o?.api),this._debugSessions.set(i.id,i),this._debugServiceProxy.$sessionCached(i.id)}return i}throw new Error("cannot find session")}getFolder(e){if(e){const i=b.revive(e);return this._workspaceService.resolveWorkspaceFolder(i)}return Promise.resolve(void 0)}extensionVisKey(e,i){return`${e}\0${i}`}serializeVisualization(e,i){if(i){if("title"in i&&"command"in i)return{type:$.Command};if("treeId"in i)return{type:$.Tree,id:`${e}\0${i.treeId}`};throw new Error("Unsupported debug visualization type")}}getIconPathOrClass(e){const i=this.getIconUris(e);let t,o;return"id"in i?o=O.asClassName(i):t=i,{iconPath:t,iconClass:o}}getIconUris(e){if(e instanceof ie)return{id:e.id};const i=typeof e=="object"&&"dark"in e?e.dark:e,t=typeof e=="object"&&"light"in e?e.light:e;return{dark:typeof i=="string"?b.file(i):i,light:typeof t=="string"?b.file(t):t}}};m=C([c(0,w),c(1,B),c(2,x),c(3,R),c(4,T),c(5,H),c(6,P),c(7,z)],m);class ne{constructor(n,e,i,t,o,r,s){this._debugServiceProxy=n;this._id=e;this._type=i;this._name=t;this._workspaceFolder=o;this._configuration=r;this._parentSession=s}apiSession;get api(){const n=this;return this.apiSession??=Object.freeze({id:n._id,type:n._type,get name(){return n._name},set name(e){n._name=e,n._debugServiceProxy.$setDebugSessionName(n._id,e)},parentSession:n._parentSession,workspaceFolder:n._workspaceFolder,configuration:n._configuration,customRequest(e,i){return n._debugServiceProxy.$customDebugAdapterRequest(n._id,e,i)},getDebugProtocolBreakpoint(e){return n._debugServiceProxy.$getDebugProtocolBreakpoint(n._id,e.id)}})}get id(){return this._id}get type(){return this._type}_acceptNameChanged(n){this._name=n}get configuration(){return this._configuration}}class ae{value;constructor(n){this.value=Object.freeze({append(e){n.$appendDebugConsole(e)},appendLine(e){this.append(e+`
`)}})}}class ue{constructor(n){this.trackers=n}onWillStartSession(){this.trackers.forEach(n=>n.onWillStartSession?n.onWillStartSession():void 0)}onWillReceiveMessage(n){this.trackers.forEach(e=>e.onWillReceiveMessage?e.onWillReceiveMessage(n):void 0)}onDidSendMessage(n){this.trackers.forEach(e=>e.onDidSendMessage?e.onDidSendMessage(n):void 0)}onWillStopSession(){this.trackers.forEach(n=>n.onWillStopSession?n.onWillStopSession():void 0)}onError(n){this.trackers.forEach(e=>e.onError?e.onError(n):void 0)}onExit(n,e){this.trackers.forEach(i=>i.onExit?i.onExit(n,e):void 0)}}class de extends te{constructor(e){super();this.implementation=e;e.onDidSendMessage(i=>{this.acceptMessage(i)})}startSession(){return Promise.resolve(void 0)}sendMessage(e){this.implementation.handleMessage(e)}stopSession(){return this.implementation.dispose(),Promise.resolve(void 0)}}let _=class extends m{constructor(n,e,i,t,o,r,s,a){super(n,e,i,t,o,r,s,a)}};_=C([c(0,w),c(1,B),c(2,x),c(3,R),c(4,T),c(5,H),c(6,P),c(7,z)],_);export{ae as ExtHostDebugConsole,m as ExtHostDebugServiceBase,ne as ExtHostDebugSession,pi as IExtHostDebugService,_ as WorkerExtHostDebugService};
