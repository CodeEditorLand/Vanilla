var f=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var l=(o,e,i,t)=>{for(var r=t>1?void 0:t?h(e,i):e,n=o.length-1,a;n>=0;n--)(a=o[n])&&(r=(t?a(e,i,r):a(r))||r);return t&&r&&f(e,i,r),r},s=(o,e)=>(i,t)=>e(i,t,o);import{LANGUAGE_DEFAULT as p}from"../../../../vs/base/common/platform.js";import{format2 as g}from"../../../../vs/base/common/strings.js";import{URI as d}from"../../../../vs/base/common/uri.js";import"../../../../vs/platform/extensions/common/extensions.js";import{createDecorator as m}from"../../../../vs/platform/instantiation/common/instantiation.js";import{ILogService as v}from"../../../../vs/platform/log/common/log.js";import{MainContext as L}from"../../../../vs/workbench/api/common/extHost.protocol.js";import{IExtHostInitDataService as I}from"../../../../vs/workbench/api/common/extHostInitDataService.js";import{IExtHostRpcService as y}from"../../../../vs/workbench/api/common/extHostRpcService.js";let u=class{constructor(e,i,t){this.logService=t;this._proxy=i.getProxy(L.MainThreadLocalization),this.currentLanguage=e.environment.appLanguage,this.isDefaultLanguage=this.currentLanguage===p}_serviceBrand;_proxy;currentLanguage;isDefaultLanguage;bundleCache=new Map;getMessage(e,i){const{message:t,args:r,comment:n}=i;if(this.isDefaultLanguage)return g(t,r??{});let a=t;n&&n.length>0&&(a+=`/${Array.isArray(n)?n.join(""):n}`);const c=this.bundleCache.get(e)?.contents[a];return c||this.logService.warn(`Using default string since no string found in i18n bundle that has the key: ${a}`),g(c??t,r??{})}getBundle(e){return this.bundleCache.get(e)?.contents}getBundleUri(e){return this.bundleCache.get(e)?.uri}async initializeLocalizedMessages(e){if(this.isDefaultLanguage||!e.l10n&&!e.isBuiltin||this.bundleCache.has(e.identifier.value))return;let i;const t=await this.getBundleLocation(e);if(!t){this.logService.error(`No bundle location found for extension ${e.identifier.value}`);return}try{const r=await this._proxy.$fetchBundleContents(t),n=JSON.parse(r);i=e.isBuiltin?n.contents?.bundle:n}catch(r){this.logService.error(`Failed to load translations for ${e.identifier.value} from ${t}: ${r.message}`);return}i&&this.bundleCache.set(e.identifier.value,{contents:i,uri:t})}async getBundleLocation(e){if(e.isBuiltin){const i=await this._proxy.$fetchBuiltInBundleUri(e.identifier.value,this.currentLanguage);return d.revive(i)}return e.l10n?d.joinPath(e.extensionLocation,e.l10n,`bundle.l10n.${this.currentLanguage}.json`):void 0}};u=l([s(0,I),s(1,y),s(2,v)],u);const k=m("IExtHostLocalizationService");export{u as ExtHostLocalizationService,k as IExtHostLocalizationService};
