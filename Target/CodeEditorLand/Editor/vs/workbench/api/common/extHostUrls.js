import{onUnexpectedError as s}from"../../../base/common/errors.js";import{toDisposable as a}from"../../../base/common/lifecycle.js";import{URI as n}from"../../../base/common/uri.js";import{ExtensionIdentifierSet as d}from"../../../platform/extensions/common/extensions.js";import{MainContext as l}from"./extHost.protocol.js";class o{static HandlePool=0;_proxy;handles=new d;handlers=new Map;constructor(e){this._proxy=e.getProxy(l.MainThreadUrls)}registerUriHandler(e,i){const r=e.identifier;if(this.handles.has(r))throw new Error(`Protocol handler already registered for extension ${r}`);const t=o.HandlePool++;return this.handles.add(r),this.handlers.set(t,i),this._proxy.$registerUriHandler(t,r,e.displayName||e.name),a(()=>{this.handles.delete(r),this.handlers.delete(t),this._proxy.$unregisterUriHandler(t)})}$handleExternalUri(e,i){const r=this.handlers.get(e);if(!r)return Promise.resolve(void 0);try{r.handleUri(n.revive(i))}catch(t){s(t)}return Promise.resolve(void 0)}async createAppUri(e){return n.revive(await this._proxy.$createAppUri(e))}}export{o as ExtHostUrls};
