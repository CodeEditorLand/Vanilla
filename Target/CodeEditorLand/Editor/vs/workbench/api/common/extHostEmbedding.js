import{CancellationToken as t}from"../../../base/common/cancellation.js";import{Emitter as s}from"../../../base/common/event.js";import{toDisposable as d}from"../../../base/common/lifecycle.js";import{MainContext as a}from"./extHost.protocol.js";class c{_proxy;_provider=new Map;_onDidChange=new s;onDidChange=this._onDidChange.event;_allKnownModels=new Set;_handlePool=0;constructor(i){this._proxy=i.getProxy(a.MainThreadEmbeddings)}registerEmbeddingsProvider(i,e,o){if(this._allKnownModels.has(e))throw new Error("An embeddings provider for this model is already registered");const n=this._handlePool++;return this._proxy.$registerEmbeddingProvider(n,e),this._provider.set(n,{id:e,provider:o}),d(()=>{this._allKnownModels.delete(e),this._proxy.$unregisterEmbeddingProvider(n),this._provider.delete(n)})}async computeEmbeddings(i,e,o){o??=t.None;let n=!1;typeof e=="string"&&(e=[e],n=!0);const r=await this._proxy.$computeEmbeddings(i,e,o);if(r.length!==e.length)throw new Error;if(n){if(r.length!==1)throw new Error;return r[0]}return r}async $provideEmbeddings(i,e,o){const n=this._provider.get(i);if(!n)return[];const r=await n.provider.provideEmbeddings(e,o);return r||[]}get embeddingsModels(){return Array.from(this._allKnownModels)}$acceptEmbeddingModels(i){this._allKnownModels=new Set(i),this._onDidChange.fire()}}export{c as ExtHostEmbeddings};
