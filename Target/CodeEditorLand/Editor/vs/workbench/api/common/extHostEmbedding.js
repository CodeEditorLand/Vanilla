import{CancellationToken as t}from"../../../base/common/cancellation.js";import{Emitter as s}from"../../../base/common/event.js";import{toDisposable as d}from"../../../base/common/lifecycle.js";import"../../../platform/extensions/common/extensions.js";import{MainContext as a}from"./extHost.protocol.js";class y{_proxy;_provider=new Map;_onDidChange=new s;onDidChange=this._onDidChange.event;_allKnownModels=new Set;_handlePool=0;constructor(r){this._proxy=r.getProxy(a.MainThreadEmbeddings)}registerEmbeddingsProvider(r,e,o){if(this._allKnownModels.has(e))throw new Error("An embeddings provider for this model is already registered");const n=this._handlePool++;return this._proxy.$registerEmbeddingProvider(n,e),this._provider.set(n,{id:e,provider:o}),d(()=>{this._allKnownModels.delete(e),this._proxy.$unregisterEmbeddingProvider(n),this._provider.delete(n)})}async computeEmbeddings(r,e,o){o??=t.None;let n=!1;typeof e=="string"&&(e=[e],n=!0);const i=await this._proxy.$computeEmbeddings(r,e,o);if(i.length!==e.length)throw new Error;if(n){if(i.length!==1)throw new Error;return i[0]}return i}async $provideEmbeddings(r,e,o){const n=this._provider.get(r);if(!n)return[];const i=await n.provider.provideEmbeddings(e,o);return i||[]}get embeddingsModels(){return Array.from(this._allKnownModels)}$acceptEmbeddingModels(r){this._allKnownModels=new Set(r),this._onDidChange.fire()}}export{y as ExtHostEmbeddings};
