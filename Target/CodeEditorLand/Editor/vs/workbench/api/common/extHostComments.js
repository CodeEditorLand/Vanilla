var V=Object.defineProperty;var w=Object.getOwnPropertyDescriptor;var S=(y,T,b,d)=>{for(var c=d>1?void 0:d?w(T,b):T,u=y.length-1,_;u>=0;u--)(_=y[u])&&(c=(d?_(T,b,c):_(c))||c);return d&&c&&V(T,b,c),c};import{asPromise as D}from"../../../base/common/async.js";import{debounce as j}from"../../../base/common/decorators.js";import{Emitter as O}from"../../../base/common/event.js";import{DisposableStore as I,MutableDisposable as B}from"../../../base/common/lifecycle.js";import{MarshalledId as v}from"../../../base/common/marshallingIds.js";import{URI as x}from"../../../base/common/uri.js";import*as h from"../../../editor/common/languages.js";import{ExtensionIdentifierMap as F}from"../../../platform/extensions/common/extensions.js";import{checkProposedApiEnabled as C}from"../../services/extensions/common/extensions.js";import{MainContext as N}from"./extHost.protocol.js";import*as g from"./extHostTypeConverters.js";import*as p from"./extHostTypes.js";function Z(y,T,b){const d=y.getProxy(N.MainThreadComments);class c{static handlePool=0;_commentControllers=new Map;_commentControllersByExtension=new F;constructor(){T.registerArgumentProcessor({processArgument:e=>{if(e&&e.$mid===v.CommentController){const t=this._commentControllers.get(e.handle);return t?t.value:e}else if(e&&e.$mid===v.CommentThread){const t=e,n=this._commentControllers.get(t.commentControlHandle);if(!n)return t;const o=n.getCommentThread(t.commentThreadHandle);return o?o.value:t}else if(e&&(e.$mid===v.CommentThreadReply||e.$mid===v.CommentThreadInstance)){const t=this._commentControllers.get(e.thread.commentControlHandle);if(!t)return e;const n=t.getCommentThread(e.thread.commentThreadHandle);return n?e.$mid===v.CommentThreadInstance?n.value:{thread:n.value,text:e.text}:e}else if(e&&e.$mid===v.CommentNode){const t=this._commentControllers.get(e.thread.commentControlHandle);if(!t)return e;const n=t.getCommentThread(e.thread.commentThreadHandle);if(!n)return e;const o=e.commentUniqueId,a=n.getCommentByUniqueId(o);return a||e}else if(e&&e.$mid===v.CommentThreadNode){const t=this._commentControllers.get(e.thread.commentControlHandle);if(!t)return e;const n=t.getCommentThread(e.thread.commentThreadHandle);if(!n)return e;const o=e.text,a=e.commentUniqueId,i=n.getCommentByUniqueId(a);return i?(typeof i.body=="string"?i.body=o:i.body=new p.MarkdownString(o),i):e}return e}})}createCommentController(e,t,n){const o=c.handlePool++,a=new _(e,o,t,n);this._commentControllers.set(a.handle,a);const i=this._commentControllersByExtension.get(e.identifier)||[];return i.push(a),this._commentControllersByExtension.set(e.identifier,i),a.value}async $createCommentThreadTemplate(e,t,n,o){const a=this._commentControllers.get(e);a&&a.$createCommentThreadTemplate(t,n,o)}async $setActiveComment(e,t){const n=this._commentControllers.get(e);n&&n.$setActiveComment(t??void 0)}async $updateCommentThreadTemplate(e,t,n){const o=this._commentControllers.get(e);o&&o.$updateCommentThreadTemplate(t,n)}$deleteCommentThread(e,t){this._commentControllers.get(e)?.$deleteCommentThread(t)}async $provideCommentingRanges(e,t,n){const o=this._commentControllers.get(e);if(!o||!o.commentingRangeProvider)return Promise.resolve(void 0);const a=await b.ensureDocumentData(x.revive(t));return D(async()=>{const i=await o.commentingRangeProvider.provideCommentingRanges(a.document,n);let l;return Array.isArray(i)?l={ranges:i,fileComments:!1}:i?l={ranges:i.ranges||[],fileComments:i.enableFileComments||!1}:l=i??void 0,l}).then(i=>{let l;return i&&(l={ranges:i.ranges.map(f=>g.Range.from(f)),fileComments:i.fileComments}),l})}$toggleReaction(e,t,n,o,a){const i=this._commentControllers.get(e);return!i||!i.reactionHandler?Promise.resolve(void 0):D(()=>{const l=i.getCommentThread(t);if(l){const f=l.getCommentByUniqueId(o.uniqueIdInThread);if(i!==void 0&&f&&i.reactionHandler)return i.reactionHandler(f,E(a))}return Promise.resolve(void 0)})}}const R=class R{constructor(e,t,n,o,a,i,l,f,A){this._commentControllerHandle=t;this._id=n;this._uri=o;this._range=a;this._comments=i;this.extensionDescription=l;this._isTemplate=f;this._acceptInputDisposables.value=new I,this._id===void 0&&(this._id=`${e}.${this.handle}`),d.$createCommentThread(t,this.handle,this._id,this._uri,g.Range.from(this._range),this._comments.map(m=>H(this,m,this._commentsMap,this.extensionDescription)),l.identifier,this._isTemplate,A),this._localDisposables=[],this._isDiposed=!1,this._localDisposables.push(this.onDidUpdateCommentThread(()=>{this.eventuallyUpdateCommentThread()})),this._localDisposables.push({dispose:()=>{d.$deleteCommentThread(t,this.handle)}});const r=this;this.value={get uri(){return r.uri},get range(){return r.range},set range(m){r.range=m},get comments(){return r.comments},set comments(m){r.comments=m},get collapsibleState(){return r.collapsibleState},set collapsibleState(m){r.collapsibleState=m},get canReply(){return r.canReply},set canReply(m){r.canReply=m},get contextValue(){return r.contextValue},set contextValue(m){r.contextValue=m},get label(){return r.label},set label(m){r.label=m},get state(){return r.state},set state(m){r.state=m},reveal:(m,q)=>r.reveal(m,q),hide:()=>r.hide(),dispose:()=>{r.dispose()}}}static _handlePool=0;handle=R._handlePool++;commentHandle=0;modifications=Object.create(null);set threadId(e){this._id=e}get threadId(){return this._id}get id(){return this._id}get resource(){return this._uri}get uri(){return this._uri}_onDidUpdateCommentThread=new O;onDidUpdateCommentThread=this._onDidUpdateCommentThread.event;set range(e){(e===void 0!=(this._range===void 0)||!e||!this._range||!e.isEqual(this._range))&&(this._range=e,this.modifications.range=e,this._onDidUpdateCommentThread.fire())}get range(){return this._range}_canReply=!0;set canReply(e){this._canReply!==e&&(this._canReply=e,this.modifications.canReply=e,this._onDidUpdateCommentThread.fire())}get canReply(){return this._canReply}_label;get label(){return this._label}set label(e){this._label=e,this.modifications.label=e,this._onDidUpdateCommentThread.fire()}_contextValue;get contextValue(){return this._contextValue}set contextValue(e){this._contextValue=e,this.modifications.contextValue=e,this._onDidUpdateCommentThread.fire()}get comments(){return this._comments}set comments(e){this._comments=e,this.modifications.comments=e,this._onDidUpdateCommentThread.fire()}_collapseState;get collapsibleState(){return this._collapseState}set collapsibleState(e){this._collapseState=e,this.modifications.collapsibleState=e,this._onDidUpdateCommentThread.fire()}_state;get state(){return this._state}set state(e){this._state=e,typeof e=="object"?(C(this.extensionDescription,"commentThreadApplicability"),this.modifications.state=e.resolved,this.modifications.applicability=e.applicability):this.modifications.state=e,this._onDidUpdateCommentThread.fire()}_localDisposables;_isDiposed;get isDisposed(){return this._isDiposed}_commentsMap=new Map;_acceptInputDisposables=new B;value;updateIsTemplate(){this._isTemplate&&(this._isTemplate=!1,this.modifications.isTemplate=!1)}eventuallyUpdateCommentThread(){if(this._isDiposed)return;this.updateIsTemplate(),this._acceptInputDisposables.value||(this._acceptInputDisposables.value=new I);const e=n=>Object.prototype.hasOwnProperty.call(this.modifications,n),t={};e("range")&&(t.range=g.Range.from(this._range)),e("label")&&(t.label=this.label),e("contextValue")&&(t.contextValue=this.contextValue??null),e("comments")&&(t.comments=this._comments.map(n=>H(this,n,this._commentsMap,this.extensionDescription))),e("collapsibleState")&&(t.collapseState=U(this._collapseState)),e("canReply")&&(t.canReply=this.canReply),e("state")&&(t.state=$(this._state)),e("applicability")&&(t.applicability=M(this._state)),e("isTemplate")&&(t.isTemplate=this._isTemplate),this.modifications={},d.$updateCommentThread(this._commentControllerHandle,this.handle,this._id,this._uri,t)}getCommentByUniqueId(e){for(const t of this._commentsMap){const n=t[0],o=t[1];if(e===o)return n}}async reveal(e,t){C(this.extensionDescription,"commentReveal");let n;e&&e.body!==void 0?n=e:t=t??e;let o=n?this._commentsMap.get(n):void 0;o??=this._commentsMap.get(this._comments[0]);let a=!0,i=!1;return t?.focus===p.CommentThreadFocus.Reply?(i=!0,a=!1):t?.focus===p.CommentThreadFocus.Comment&&(a=!1),d.$revealCommentThread(this._commentControllerHandle,this.handle,o,{preserveFocus:a,focusReply:i})}async hide(){return d.$hideCommentThread(this._commentControllerHandle,this.handle)}dispose(){this._isDiposed=!0,this._acceptInputDisposables.dispose(),this._localDisposables.forEach(e=>e.dispose())}};S([j(100)],R.prototype,"eventuallyUpdateCommentThread",1);let u=R;class _{constructor(e,t,n,o){this._extension=e;this._handle=t;this._id=n;this._label=o;d.$registerCommentController(this.handle,n,o,this._extension.identifier.value);const a=this;this.value=Object.freeze({id:a.id,label:a.label,get options(){return a.options},set options(i){a.options=i},get commentingRangeProvider(){return a.commentingRangeProvider},set commentingRangeProvider(i){a.commentingRangeProvider=i},get reactionHandler(){return a.reactionHandler},set reactionHandler(i){a.reactionHandler=i},get activeCommentThread(){return a.activeCommentThread},createCommentThread(i,l,f){return a.createCommentThread(i,l,f).value},dispose:()=>{a.dispose()}}),this._localDisposables=[],this._localDisposables.push({dispose:()=>{d.$unregisterCommentController(this.handle)}})}get id(){return this._id}get label(){return this._label}get handle(){return this._handle}_threads=new Map;_commentingRangeProvider;get commentingRangeProvider(){return this._commentingRangeProvider}set commentingRangeProvider(e){this._commentingRangeProvider=e,e?.resourceHints&&C(this._extension,"commentingRangeHint"),d.$updateCommentingRanges(this.handle,e?.resourceHints)}_reactionHandler;get reactionHandler(){return this._reactionHandler}set reactionHandler(e){this._reactionHandler=e,d.$updateCommentControllerFeatures(this.handle,{reactionHandler:!!e})}_options;get options(){return this._options}set options(e){this._options=e,d.$updateCommentControllerFeatures(this.handle,{options:this._options})}_activeComment;get activeComment(){return C(this._extension,"activeComment"),this._activeComment}_activeThread;get activeCommentThread(){return C(this._extension,"activeComment"),this._activeThread?.value}_localDisposables;value;createCommentThread(e,t,n){t===void 0&&C(this._extension,"fileComments");const o=new u(this.id,this.handle,void 0,e,t,n,this._extension,!1);return this._threads.set(o.handle,o),o}$setActiveComment(e){if(!e){this._activeComment=void 0,this._activeThread=void 0;return}const t=this._threads.get(e.commentThreadHandle);t&&(this._activeComment=e.uniqueIdInThread?t.getCommentByUniqueId(e.uniqueIdInThread):void 0,this._activeThread=t)}$createCommentThreadTemplate(e,t,n){const o=new u(this.id,this.handle,void 0,x.revive(e),g.Range.to(t),[],this._extension,!0,n);return o.collapsibleState=h.CommentThreadCollapsibleState.Expanded,this._threads.set(o.handle,o),o}$updateCommentThreadTemplate(e,t){const n=this._threads.get(e);n&&(n.range=g.Range.to(t))}$deleteCommentThread(e){this._threads.get(e)?.dispose(),this._threads.delete(e)}getCommentThread(e){return this._threads.get(e)}dispose(){this._threads.forEach(e=>{e.dispose()}),this._localDisposables.forEach(e=>e.dispose())}}function H(s,e,t,n){let o=t.get(e);return o||(o=++s.commentHandle,t.set(e,o)),e.state!==void 0&&C(n,"commentsDraftState"),e.reactions?.some(a=>a.reactors!==void 0)&&C(n,"commentReactor"),{mode:e.mode,contextValue:e.contextValue,uniqueIdInThread:o,body:typeof e.body=="string"?e.body:g.MarkdownString.from(e.body),userName:e.author.name,userIconPath:e.author.iconPath,label:e.label,commentReactions:e.reactions?e.reactions.map(a=>P(a)):void 0,state:e.state,timestamp:e.timestamp?.toJSON()}}function P(s){return{label:s.label,iconPath:s.iconPath?g.pathOrURIToURI(s.iconPath):void 0,count:s.count,hasReacted:s.authorHasReacted,reactors:s.reactors&&s.reactors.length>0&&typeof s.reactors[0]!="string"?s.reactors.map(e=>e.name):s.reactors}}function E(s){return{label:s.label||"",count:s.count||0,iconPath:s.iconPath?x.revive(s.iconPath):"",authorHasReacted:s.hasReacted||!1,reactors:s.reactors?.map(e=>({name:e}))}}function U(s){if(s!==void 0)switch(s){case p.CommentThreadCollapsibleState.Expanded:return h.CommentThreadCollapsibleState.Expanded;case p.CommentThreadCollapsibleState.Collapsed:return h.CommentThreadCollapsibleState.Collapsed}return h.CommentThreadCollapsibleState.Collapsed}function $(s){let e;if(typeof s=="object"?e=s.resolved:e=s,e!==void 0)switch(e){case p.CommentThreadState.Unresolved:return h.CommentThreadState.Unresolved;case p.CommentThreadState.Resolved:return h.CommentThreadState.Resolved}return h.CommentThreadState.Unresolved}function M(s){let e;if(typeof s=="object"&&(e=s.applicability),e!==void 0)switch(e){case p.CommentThreadApplicability.Current:return h.CommentThreadApplicability.Current;case p.CommentThreadApplicability.Outdated:return h.CommentThreadApplicability.Outdated}return h.CommentThreadApplicability.Current}return new c}export{Z as createExtHostComments};
