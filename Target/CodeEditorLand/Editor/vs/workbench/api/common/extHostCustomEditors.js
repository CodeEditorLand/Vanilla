import{CancellationToken as P}from"../../../base/common/cancellation.js";import{hash as g}from"../../../base/common/hash.js";import{DisposableStore as f}from"../../../base/common/lifecycle.js";import{Schemas as E}from"../../../base/common/network.js";import{joinPath as x}from"../../../base/common/resources.js";import{URI as u}from"../../../base/common/uri.js";import{Cache as b}from"./cache.js";import*as D from"./extHost.protocol.js";import*as w from"./extHostTypeConverters.js";import*as p from"./extHostTypes.js";import{shouldSerializeBuffersForPostMessage as h,toExtensionData as y}from"./extHostWebview.js";class _{constructor(o,t){this.document=o;this._storagePath=t}_backupCounter=1;_edits=new b("custom documents");_backup;addEdit(o){return this._edits.add([o])}async undo(o,t){await this.getEdit(o).undo(),t||this.disposeBackup()}async redo(o,t){await this.getEdit(o).redo(),t||this.disposeBackup()}disposeEdits(o){for(const t of o)this._edits.delete(t)}getNewBackupUri(){if(!this._storagePath)throw new Error("Backup requires a valid storage path");const o=I(this.document.uri)+this._backupCounter++;return x(this._storagePath,o)}updateBackup(o){this._backup?.delete(),this._backup=o}disposeBackup(){this._backup?.delete(),this._backup=void 0}getEdit(o){const t=this._edits.get(o,0);if(!t)throw new Error("No edit found");return t}}class k{_documents=new Map;get(o,t){return this._documents.get(this.key(o,t))}add(o,t,e){const r=this.key(o,t.uri);if(this._documents.has(r))throw new Error(`Document already exists for viewType:${o} resource:${t.uri}`);const s=new _(t,e);return this._documents.set(r,s),s}delete(o,t){const e=this.key(o,t.uri);this._documents.delete(e)}key(o,t){return`${o}@@@${t}`}}var H=(t=>(t[t.Text=0]="Text",t[t.Custom=1]="Custom",t))(H||{});class ${_providers=new Map;addTextProvider(o,t,e){return this.add(o,{type:0,extension:t,provider:e})}addCustomProvider(o,t,e){return this.add(o,{type:1,extension:t,provider:e})}get(o){return this._providers.get(o)}add(o,t){if(this._providers.has(o))throw new Error(`Provider for viewType:${o} already registered`);return this._providers.set(o,t),new p.Disposable(()=>this._providers.delete(o))}}class V{constructor(o,t,e,r,s){this._extHostDocuments=t;this._extensionStoragePaths=e;this._extHostWebview=r;this._extHostWebviewPanels=s;this._proxy=o.getProxy(D.MainContext.MainThreadCustomEditors)}_proxy;_editorProviders=new $;_documents=new k;registerCustomEditorProvider(o,t,e,r){const s=new f;return U(e)?(s.add(this._editorProviders.addTextProvider(t,o,e)),this._proxy.$registerTextEditorProvider(y(o),t,r.webviewOptions||{},{supportsMove:!!e.moveCustomTextEditor},h(o))):(s.add(this._editorProviders.addCustomProvider(t,o,e)),a(e)&&s.add(e.onDidChangeCustomDocument(i=>{const d=this.getCustomDocumentEntry(t,i.document.uri);if(S(i)){const m=d.addEdit(i);this._proxy.$onDidEdit(i.document.uri,t,m,i.label)}else this._proxy.$onContentChange(i.document.uri,t)})),this._proxy.$registerCustomEditorProvider(y(o),t,r.webviewOptions||{},!!r.supportsMultipleEditorsPerDocument,h(o))),p.Disposable.from(s,new p.Disposable(()=>{this._proxy.$unregisterEditorProvider(t)}))}async $createCustomDocument(o,t,e,r,s){const i=this._editorProviders.get(t);if(!i)throw new Error(`No provider found for '${t}'`);if(i.type!==1)throw new Error(`Invalid provide type for '${t}'`);const d=u.revive(o),m=await i.provider.openCustomDocument(d,{backupId:e,untitledDocumentData:r?.buffer},s);let c;return a(i.provider)&&this._extensionStoragePaths&&(c=this._extensionStoragePaths.workspaceValue(i.extension)??this._extensionStoragePaths.globalValue(i.extension)),this._documents.add(t,m,c),{editable:a(i.provider)}}async $disposeCustomDocument(o,t){const e=this._editorProviders.get(t);if(!e)throw new Error(`No provider found for '${t}'`);if(e.type!==1)throw new Error(`Invalid provider type for '${t}'`);const r=u.revive(o),{document:s}=this.getCustomDocumentEntry(t,r);this._documents.delete(t,s),s.dispose()}async $resolveCustomEditor(o,t,e,r,s,i){const d=this._editorProviders.get(e);if(!d)throw new Error(`No provider found for '${e}'`);const m=w.ViewColumn.to(s),c=this._extHostWebview.createNewWebview(t,r.contentOptions,d.extension),C=this._extHostWebviewPanels.createNewWebviewPanel(t,e,r.title,m,r.options,c,r.active),l=u.revive(o);switch(d.type){case 1:{const{document:v}=this.getCustomDocumentEntry(e,l);return d.provider.resolveCustomEditor(v,C,i)}case 0:{const v=this._extHostDocuments.getDocument(l);return d.provider.resolveCustomTextEditor(v,C,i)}default:throw new Error("Unknown webview provider type")}}$disposeEdits(o,t,e){this.getCustomDocumentEntry(t,o).disposeEdits(e)}async $onMoveCustomEditor(o,t,e){const r=this._editorProviders.get(e);if(!r)throw new Error(`No provider found for '${e}'`);if(!r.provider.moveCustomTextEditor)throw new Error(`Provider does not implement move '${e}'`);const s=this._extHostWebviewPanels.getWebviewPanel(o);if(!s)throw new Error("No webview found");const i=u.revive(t),d=this._extHostDocuments.getDocument(i);await r.provider.moveCustomTextEditor(d,s,P.None)}async $undo(o,t,e,r){return this.getCustomDocumentEntry(t,o).undo(e,r)}async $redo(o,t,e,r){return this.getCustomDocumentEntry(t,o).redo(e,r)}async $revert(o,t,e){const r=this.getCustomDocumentEntry(t,o);await this.getCustomEditorProvider(t).revertCustomDocument(r.document,e),r.disposeBackup()}async $onSave(o,t,e){const r=this.getCustomDocumentEntry(t,o);await this.getCustomEditorProvider(t).saveCustomDocument(r.document,e),r.disposeBackup()}async $onSaveAs(o,t,e,r){const s=this.getCustomDocumentEntry(t,o);return this.getCustomEditorProvider(t).saveCustomDocumentAs(s.document,u.revive(e),r)}async $backup(o,t,e){const r=this.getCustomDocumentEntry(t,o),i=await this.getCustomEditorProvider(t).backupCustomDocument(r.document,{destination:r.getNewBackupUri()},e);return r.updateBackup(i),i.id}getCustomDocumentEntry(o,t){const e=this._documents.get(o,u.revive(t));if(!e)throw new Error("No custom document found");return e}getCustomEditorProvider(o){const e=this._editorProviders.get(o)?.provider;if(!e||!a(e))throw new Error("Custom document is not editable");return e}}function a(n){return!!n.onDidChangeCustomDocument}function U(n){return typeof n.resolveCustomTextEditor=="function"}function S(n){return typeof n.undo=="function"&&typeof n.redo=="function"}function I(n){const o=n.scheme===E.file||n.scheme===E.untitled?n.fsPath:n.toString();return g(o)+""}export{V as ExtHostCustomEditors};
