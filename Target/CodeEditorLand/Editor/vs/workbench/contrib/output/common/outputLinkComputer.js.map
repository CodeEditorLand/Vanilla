{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/output/common/outputLinkComputer.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as extpath from \"../../../../base/common/extpath.js\";\nimport { Schemas } from \"../../../../base/common/network.js\";\nimport { isWindows } from \"../../../../base/common/platform.js\";\nimport * as resources from \"../../../../base/common/resources.js\";\nimport * as strings from \"../../../../base/common/strings.js\";\nimport { URI } from \"../../../../base/common/uri.js\";\nimport type {\n\tIRequestHandler,\n\tIWorkerServer,\n} from \"../../../../base/common/worker/simpleWorker.js\";\nimport { Range } from \"../../../../editor/common/core/range.js\";\nimport type { ILink } from \"../../../../editor/common/languages.js\";\nimport {\n\ttype ICommonModel,\n\tWorkerTextModelSyncServer,\n} from \"../../../../editor/common/services/textModelSync/textModelSync.impl.js\";\n\nexport interface IResourceCreator {\n\ttoResource: (folderRelativePath: string) => URI | null;\n}\n\nexport class OutputLinkComputer implements IRequestHandler {\n\t_requestHandlerBrand: any;\n\n\tprivate readonly workerTextModelSyncServer =\n\t\tnew WorkerTextModelSyncServer();\n\tprivate patterns = new Map<URI /* folder uri */, RegExp[]>();\n\n\tconstructor(workerServer: IWorkerServer) {\n\t\tthis.workerTextModelSyncServer.bindToServer(workerServer);\n\t}\n\n\t$setWorkspaceFolders(workspaceFolders: string[]) {\n\t\tthis.computePatterns(workspaceFolders);\n\t}\n\n\tprivate computePatterns(_workspaceFolders: string[]): void {\n\t\t// Produce patterns for each workspace root we are configured with\n\t\t// This means that we will be able to detect links for paths that\n\t\t// contain any of the workspace roots as segments.\n\t\tconst workspaceFolders = _workspaceFolders\n\t\t\t.sort(\n\t\t\t\t(resourceStrA, resourceStrB) =>\n\t\t\t\t\tresourceStrB.length - resourceStrA.length,\n\t\t\t) // longest paths first (for https://github.com/microsoft/vscode/issues/88121)\n\t\t\t.map((resourceStr) => URI.parse(resourceStr));\n\n\t\tfor (const workspaceFolder of workspaceFolders) {\n\t\t\tconst patterns = OutputLinkComputer.createPatterns(workspaceFolder);\n\t\t\tthis.patterns.set(workspaceFolder, patterns);\n\t\t}\n\t}\n\n\tprivate getModel(uri: string): ICommonModel | undefined {\n\t\treturn this.workerTextModelSyncServer.getModel(uri);\n\t}\n\n\t$computeLinks(uri: string): ILink[] {\n\t\tconst model = this.getModel(uri);\n\t\tif (!model) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst links: ILink[] = [];\n\t\tconst lines = strings.splitLines(model.getValue());\n\n\t\t// For each workspace root patterns\n\t\tfor (const [folderUri, folderPatterns] of this.patterns) {\n\t\t\tconst resourceCreator: IResourceCreator = {\n\t\t\t\ttoResource: (folderRelativePath: string): URI | null => {\n\t\t\t\t\tif (typeof folderRelativePath === \"string\") {\n\t\t\t\t\t\treturn resources.joinPath(\n\t\t\t\t\t\t\tfolderUri,\n\t\t\t\t\t\t\tfolderRelativePath,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t},\n\t\t\t};\n\n\t\t\tfor (let i = 0, len = lines.length; i < len; i++) {\n\t\t\t\tlinks.push(\n\t\t\t\t\t...OutputLinkComputer.detectLinks(\n\t\t\t\t\t\tlines[i],\n\t\t\t\t\t\ti + 1,\n\t\t\t\t\t\tfolderPatterns,\n\t\t\t\t\t\tresourceCreator,\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn links;\n\t}\n\n\tstatic createPatterns(workspaceFolder: URI): RegExp[] {\n\t\tconst patterns: RegExp[] = [];\n\n\t\tconst workspaceFolderPath =\n\t\t\tworkspaceFolder.scheme === Schemas.file\n\t\t\t\t? workspaceFolder.fsPath\n\t\t\t\t: workspaceFolder.path;\n\t\tconst workspaceFolderVariants = [workspaceFolderPath];\n\t\tif (isWindows && workspaceFolder.scheme === Schemas.file) {\n\t\t\tworkspaceFolderVariants.push(\n\t\t\t\textpath.toSlashes(workspaceFolderPath),\n\t\t\t);\n\t\t}\n\n\t\tfor (const workspaceFolderVariant of workspaceFolderVariants) {\n\t\t\tconst validPathCharacterPattern = \"[^\\\\s\\\\(\\\\):<>'\\\"]\";\n\t\t\tconst validPathCharacterOrSpacePattern = `(?:${validPathCharacterPattern}| ${validPathCharacterPattern})`;\n\t\t\tconst pathPattern = `${validPathCharacterOrSpacePattern}+\\\\.${validPathCharacterPattern}+`;\n\t\t\tconst strictPathPattern = `${validPathCharacterPattern}+`;\n\n\t\t\t// Example: /workspaces/express/server.js on line 8, column 13\n\t\t\tpatterns.push(\n\t\t\t\tnew RegExp(\n\t\t\t\t\tstrings.escapeRegExpCharacters(workspaceFolderVariant) +\n\t\t\t\t\t\t`(${pathPattern}) on line ((\\\\d+)(, column (\\\\d+))?)`,\n\t\t\t\t\t\"gi\",\n\t\t\t\t),\n\t\t\t);\n\n\t\t\t// Example: /workspaces/express/server.js:line 8, column 13\n\t\t\tpatterns.push(\n\t\t\t\tnew RegExp(\n\t\t\t\t\tstrings.escapeRegExpCharacters(workspaceFolderVariant) +\n\t\t\t\t\t\t`(${pathPattern}):line ((\\\\d+)(, column (\\\\d+))?)`,\n\t\t\t\t\t\"gi\",\n\t\t\t\t),\n\t\t\t);\n\n\t\t\t// Example: /workspaces/mankala/Features.ts(45): error\n\t\t\t// Example: /workspaces/mankala/Features.ts (45): error\n\t\t\t// Example: /workspaces/mankala/Features.ts(45,18): error\n\t\t\t// Example: /workspaces/mankala/Features.ts (45,18): error\n\t\t\t// Example: /workspaces/mankala/Features Special.ts (45,18): error\n\t\t\tpatterns.push(\n\t\t\t\tnew RegExp(\n\t\t\t\t\tstrings.escapeRegExpCharacters(workspaceFolderVariant) +\n\t\t\t\t\t\t`(${pathPattern})(\\\\s?\\\\((\\\\d+)(,(\\\\d+))?)\\\\)`,\n\t\t\t\t\t\"gi\",\n\t\t\t\t),\n\t\t\t);\n\n\t\t\t// Example: at /workspaces/mankala/Game.ts\n\t\t\t// Example: at /workspaces/mankala/Game.ts:336\n\t\t\t// Example: at /workspaces/mankala/Game.ts:336:9\n\t\t\tpatterns.push(\n\t\t\t\tnew RegExp(\n\t\t\t\t\tstrings.escapeRegExpCharacters(workspaceFolderVariant) +\n\t\t\t\t\t\t`(${strictPathPattern})(:(\\\\d+))?(:(\\\\d+))?`,\n\t\t\t\t\t\"gi\",\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\n\t\treturn patterns;\n\t}\n\n\t/**\n\t * Detect links. Made static to allow for tests.\n\t */\n\tstatic detectLinks(\n\t\tline: string,\n\t\tlineIndex: number,\n\t\tpatterns: RegExp[],\n\t\tresourceCreator: IResourceCreator,\n\t): ILink[] {\n\t\tconst links: ILink[] = [];\n\n\t\tpatterns.forEach((pattern) => {\n\t\t\tpattern.lastIndex = 0; // the holy grail of software development\n\n\t\t\tlet match: RegExpExecArray | null;\n\t\t\tlet offset = 0;\n\t\t\twhile ((match = pattern.exec(line)) !== null) {\n\t\t\t\t// Convert the relative path information to a resource that we can use in links\n\t\t\t\tconst folderRelativePath = strings\n\t\t\t\t\t.rtrim(match[1], \".\")\n\t\t\t\t\t.replace(/\\\\/g, \"/\"); // remove trailing \".\" that likely indicate end of sentence\n\t\t\t\tlet resourceString: string | undefined;\n\t\t\t\ttry {\n\t\t\t\t\tconst resource =\n\t\t\t\t\t\tresourceCreator.toResource(folderRelativePath);\n\t\t\t\t\tif (resource) {\n\t\t\t\t\t\tresourceString = resource.toString();\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tcontinue; // we might find an invalid URI and then we dont want to loose all other links\n\t\t\t\t}\n\n\t\t\t\t// Append line/col information to URI if matching\n\t\t\t\tif (match[3]) {\n\t\t\t\t\tconst lineNumber = match[3];\n\n\t\t\t\t\tif (match[5]) {\n\t\t\t\t\t\tconst columnNumber = match[5];\n\t\t\t\t\t\tresourceString = strings.format(\n\t\t\t\t\t\t\t\"{0}#{1},{2}\",\n\t\t\t\t\t\t\tresourceString,\n\t\t\t\t\t\t\tlineNumber,\n\t\t\t\t\t\t\tcolumnNumber,\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresourceString = strings.format(\n\t\t\t\t\t\t\t\"{0}#{1}\",\n\t\t\t\t\t\t\tresourceString,\n\t\t\t\t\t\t\tlineNumber,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst fullMatch = strings.rtrim(match[0], \".\"); // remove trailing \".\" that likely indicate end of sentence\n\n\t\t\t\tconst index = line.indexOf(fullMatch, offset);\n\t\t\t\toffset = index + fullMatch.length;\n\n\t\t\t\tconst linkRange = {\n\t\t\t\t\tstartColumn: index + 1,\n\t\t\t\t\tstartLineNumber: lineIndex,\n\t\t\t\t\tendColumn: index + 1 + fullMatch.length,\n\t\t\t\t\tendLineNumber: lineIndex,\n\t\t\t\t};\n\n\t\t\t\tif (\n\t\t\t\t\tlinks.some((link) =>\n\t\t\t\t\t\tRange.areIntersectingOrTouching(link.range, linkRange),\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\treturn; // Do not detect duplicate links\n\t\t\t\t}\n\n\t\t\t\tlinks.push({\n\t\t\t\t\trange: linkRange,\n\t\t\t\t\turl: resourceString,\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\treturn links;\n\t}\n}\n\n/**\n * Defines the worker entry point. Must be exported and named `create`.\n * @skipMangle\n */\nexport function create(workerServer: IWorkerServer): OutputLinkComputer {\n\treturn new OutputLinkComputer(workerServer);\n}\n"],
  "mappings": "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",
  "names": []
}
