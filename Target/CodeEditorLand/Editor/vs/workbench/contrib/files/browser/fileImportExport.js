var Y=Object.defineProperty;var j=Object.getOwnPropertyDescriptor;var P=(w,r,o,t)=>{for(var e=t>1?void 0:t?j(r,o):r,i=w.length-1,a;i>=0;i--)(a=w[i])&&(e=(t?a(r,o,e):a(e))||e);return t&&e&&Y(r,o,e),e},u=(w,r)=>(o,t)=>r(o,t,w);import{localize as l}from"../../../../nls.js";import{CancellationTokenSource as C}from"../../../../base/common/cancellation.js";import{getFileNamesMessage as Q,IDialogService as q,IFileDialogService as $}from"../../../../platform/dialogs/common/dialogs.js";import{ByteSize as v,FileSystemProviderCapabilities as J,IFileService as T}from"../../../../platform/files/common/files.js";import{INotificationService as Z,Severity as ee}from"../../../../platform/notification/common/notification.js";import{IProgressService as R,ProgressLocation as D}from"../../../../platform/progress/common/progress.js";import{IExplorerService as k}from"./files.js";import{UndoConfirmLevel as M,VIEW_ID as U}from"../common/files.js";import{IEditorService as z}from"../../../services/editor/common/editorService.js";import{Limiter as _,Promises as B,RunOnceWorker as N}from"../../../../base/common/async.js";import{newWriteableBufferStream as re,VSBuffer as H}from"../../../../base/common/buffer.js";import{basename as g,dirname as ie,joinPath as F}from"../../../../base/common/resources.js";import{ResourceFileEdit as W}from"../../../../editor/browser/services/bulkEditService.js";import{ExplorerItem as te}from"../common/explorerModel.js";import{URI as oe}from"../../../../base/common/uri.js";import{IHostService as ae}from"../../../services/host/browser/host.js";import{IWorkspaceContextService as se}from"../../../../platform/workspace/common/workspace.js";import{extractEditorsAndFilesDropData as ne}from"../../../../platform/dnd/browser/dnd.js";import{IWorkspaceEditingService as le}from"../../../services/workspaces/common/workspaceEditing.js";import{isWeb as G}from"../../../../base/common/platform.js";import{getActiveWindow as de,isDragEvent as ce,triggerDownload as fe}from"../../../../base/browser/dom.js";import{ILogService as me}from"../../../../platform/log/common/log.js";import{FileAccess as ue,Schemas as A}from"../../../../base/common/network.js";import{mnemonicButtonLabel as pe}from"../../../../base/common/labels.js";import{listenStream as ve}from"../../../../base/common/stream.js";import{DisposableStore as we,toDisposable as he}from"../../../../base/common/lifecycle.js";import{createSingleCallFunction as Se}from"../../../../base/common/functional.js";import{coalesce as L}from"../../../../base/common/arrays.js";import{canceled as ge}from"../../../../base/common/errors.js";import{IConfigurationService as ye}from"../../../../platform/configuration/common/configuration.js";import{WebFileSystemAccess as Ie}from"../../../../platform/files/browser/webFileSystemAccess.js";import{IInstantiationService as be}from"../../../../platform/instantiation/common/instantiation.js";import{IStorageService as De,StorageScope as V,StorageTarget as Fe}from"../../../../platform/storage/common/storage.js";let y=class{constructor(r,o,t,e,i){this.progressService=r;this.dialogService=o;this.explorerService=t;this.editorService=e;this.fileService=i}static MAX_PARALLEL_UPLOADS=20;upload(r,o){const t=new C,e=this.progressService.withProgress({location:D.Window,delay:800,cancellable:!0,title:l("uploadingFiles","Uploading")},async i=>this.doUpload(r,this.toTransfer(o),i,t.token),()=>t.dispose(!0));return this.progressService.withProgress({location:U,delay:500},()=>e),e}toTransfer(r){if(ce(r))return r.dataTransfer;const o={items:[]};for(const t of r)o.items.push({webkitGetAsEntry:()=>({name:t.name,isDirectory:!1,isFile:!0,createReader:()=>{throw new Error("Unsupported for files")},file:e=>e(t)})});return o}async doUpload(r,o,t,e){const i=o.items,a=[];for(const f of i)a.push(f.webkitGetAsEntry());const c=[],s={startTime:Date.now(),progressScheduler:new N(f=>{t.report(f[f.length-1])},1e3),filesTotal:a.length,filesUploaded:0,totalBytesUploaded:0},n=new _(y.MAX_PARALLEL_UPLOADS);await B.settled(a.map(f=>n.queue(async()=>{if(e.isCancellationRequested)return;if(r&&f.name&&r.getChild(f.name)){const{confirmed:p}=await this.dialogService.confirm(O(f.name));if(!p||(await this.explorerService.applyBulkEdit([new W(F(r.resource,f.name),void 0,{recursive:!0,folder:r.getChild(f.name)?.isDirectory})],{undoLabel:l("overwrite","Overwrite {0}",f.name),progressLabel:l("overwriting","Overwriting {0}",f.name)}),e.isCancellationRequested))return}const m=await this.doUploadEntry(f,r.resource,r,t,s,e);m&&c.push(m)}))),s.progressScheduler.dispose();const d=c[0];!e.isCancellationRequested&&d?.isFile&&await this.editorService.openEditor({resource:d.resource,options:{pinned:!0}})}async doUploadEntry(r,o,t,e,i,a){if(a.isCancellationRequested||!r.name||!r.isFile&&!r.isDirectory)return;let c=0;const s=(d,f)=>{c+=f,i.totalBytesUploaded+=f;const m=i.totalBytesUploaded/((Date.now()-i.startTime)/1e3);let p;d<v.MB?i.filesTotal===1?p=`${r.name}`:p=l("uploadProgressSmallMany","{0} of {1} files ({2}/s)",i.filesUploaded,i.filesTotal,v.formatSize(m)):p=l("uploadProgressLarge","{0} ({1} of {2}, {3}/s)",r.name,v.formatSize(c),v.formatSize(d),v.formatSize(m)),i.progressScheduler.work({message:p})};i.filesUploaded++,s(0,0);const n=F(o,r.name);if(r.isFile){const d=await new Promise((f,m)=>r.file(f,m));return a.isCancellationRequested?void 0:(typeof d.stream=="function"&&d.size>v.MB?await this.doUploadFileBuffered(n,d,s,a):await this.doUploadFileUnbuffered(n,d,s),{isFile:!0,resource:n})}else{if(await this.fileService.createFolder(n),a.isCancellationRequested)return;const d=r.createReader(),f=[];let m=!1;do{const h=await new Promise((K,X)=>d.readEntries(K,X));h.length>0?f.push(...h):m=!0}while(!m&&!a.isCancellationRequested);i.filesTotal+=f.length;const p=t&&t.getChild(r.name)||void 0,S=[],x=[];for(const h of f)h.isFile?S.push(h):h.isDirectory&&x.push(h);const b=new _(y.MAX_PARALLEL_UPLOADS);await B.settled(S.map(h=>b.queue(()=>this.doUploadEntry(h,n,p,e,i,a))));for(const h of x)await this.doUploadEntry(h,n,p,e,i,a);return{isFile:!1,resource:n}}}async doUploadFileBuffered(r,o,t,e){const i=re({highWaterMark:10}),a=this.fileService.writeFile(r,i);try{const c=o.stream().getReader();let s=await c.read();for(;!s.done&&!e.isCancellationRequested;){const n=H.wrap(s.value);if(await i.write(n),e.isCancellationRequested)break;t(o.size,n.byteLength),s=await c.read()}i.end(void 0)}catch(c){i.error(c),i.end()}e.isCancellationRequested||await a}doUploadFileUnbuffered(r,o,t){return new Promise((e,i)=>{const a=new FileReader;a.onload=async c=>{try{if(c.target?.result instanceof ArrayBuffer){const s=H.wrap(new Uint8Array(c.target.result));await this.fileService.writeFile(r,s),t(o.size,s.byteLength)}else throw new Error("Could not read from dropped file.");e()}catch(s){i(s)}},a.readAsArrayBuffer(o)})}};y=P([u(0,R),u(1,q),u(2,k),u(3,z),u(4,T)],y);let E=class{constructor(r,o,t,e,i,a,c,s,n,d,f){this.fileService=r;this.hostService=o;this.contextService=t;this.configurationService=e;this.dialogService=i;this.workspaceEditingService=a;this.explorerService=c;this.editorService=s;this.progressService=n;this.notificationService=d;this.instantiationService=f}async import(r,o,t){const e=new C,i=this.progressService.withProgress({location:D.Window,delay:800,cancellable:!0,title:l("copyingFiles","Copying...")},async()=>await this.doImport(r,o,t,e.token),()=>e.dispose(!0));return this.progressService.withProgress({location:U,delay:500},()=>i),i}async doImport(r,o,t,e){const i=L((await this.instantiationService.invokeFunction(n=>ne(n,o))).map(n=>n.resource));await Promise.all(i.map(n=>this.fileService.activateProvider(n.scheme)));const a=L(i.filter(n=>this.fileService.hasProvider(n))),c=await this.fileService.resolveAll(a.map(n=>({resource:n})));if(e.isCancellationRequested)return;this.hostService.focus(t);const s=c.filter(n=>n.success&&n.stat?.isDirectory).map(n=>({uri:n.stat.resource}));if(s.length>0&&r.isRoot){let n;(b=>(b[b.Copy=1]="Copy",b[b.Add=2]="Add"))(n||={});const d=[{label:s.length>1?l("copyFolders","&&Copy Folders"):l("copyFolder","&&Copy Folder"),run:()=>1}];let f;const m=this.contextService.getWorkspace().folders.map(S=>S.uri.scheme);s.some(S=>m.indexOf(S.uri.scheme)>=0)?(d.unshift({label:s.length>1?l("addFolders","&&Add Folders to Workspace"):l("addFolder","&&Add Folder to Workspace"),run:()=>2}),f=s.length>1?l("dropFolders","Do you want to copy the folders or add the folders to the workspace?"):l("dropFolder","Do you want to copy '{0}' or add '{0}' as a folder to the workspace?",g(s[0].uri))):f=s.length>1?l("copyfolders","Are you sure to want to copy folders?"):l("copyfolder","Are you sure to want to copy '{0}'?",g(s[0].uri));const{result:p}=await this.dialogService.prompt({type:ee.Info,message:f,buttons:d,cancelButton:!0});if(p===2)return this.workspaceEditingService.addFolders(s);if(p===1)return this.importResources(r,a,e)}else if(r instanceof te)return this.importResources(r,a,e)}async importResources(r,o,t){if(o&&o.length>0){const e=await this.fileService.resolve(r.resource);if(t.isCancellationRequested)return;const i=new Set,a=this.fileService.hasCapability(r.resource,J.PathCaseSensitive);e.children&&e.children.forEach(m=>{i.add(a?m.name:m.name.toLowerCase())});let c=0;const s=L(await B.settled(o.map(async m=>{if(!await this.fileService.exists(m)){c++;return}if(!(i.has(a?g(m):g(m).toLowerCase())&&!(await this.dialogService.confirm(O(g(m)))).confirmed))return m})));c>0&&this.notificationService.error(c>1?l("filesInaccessible","Some or all of the dropped files could not be accessed for import."):l("fileInaccessible","The dropped file could not be accessed for import."));const n=s.map(m=>{const p=g(m),S=F(r.resource,p);return new W(m,S,{overwrite:!0,copy:!0})}),d=this.configurationService.getValue().explorer.confirmUndo;if(await this.explorerService.applyBulkEdit(n,{undoLabel:s.length===1?l({comment:["substitution will be the name of the file that was imported"],key:"importFile"},"Import {0}",g(s[0])):l({comment:["substitution will be the number of files that were imported"],key:"importnFile"},"Import {0} resources",s.length),progressLabel:s.length===1?l({comment:["substitution will be the name of the file that was copied"],key:"copyingFile"},"Copying {0}",g(s[0])):l({comment:["substitution will be the number of files that were copied"],key:"copyingnFile"},"Copying {0} resources",s.length),progressLocation:D.Window,confirmBeforeUndo:d===M.Verbose||d===M.Default}),this.configurationService.getValue().explorer.autoOpenDroppedFile&&n.length===1){const m=this.explorerService.findClosest(n[0].newResource);m&&!m.isDirectory&&this.editorService.openEditor({resource:m.resource,options:{pinned:!0}})}}}};E=P([u(0,T),u(1,ae),u(2,se),u(3,ye),u(4,q),u(5,le),u(6,k),u(7,z),u(8,R),u(9,Z),u(10,be)],E);let I=class{constructor(r,o,t,e,i,a){this.fileService=r;this.explorerService=o;this.progressService=t;this.logService=e;this.fileDialogService=i;this.storageService=a}static LAST_USED_DOWNLOAD_PATH_STORAGE_KEY="workbench.explorer.downloadPath";download(r){const o=new C,t=this.progressService.withProgress({location:D.Window,delay:800,cancellable:G,title:l("downloadingFiles","Downloading")},async e=>this.doDownload(r,e,o),()=>o.dispose(!0));return this.progressService.withProgress({location:U,delay:500},()=>t),t}async doDownload(r,o,t){for(const e of r){if(t.token.isCancellationRequested)return;G?await this.doDownloadBrowser(e.resource,o,t):await this.doDownloadNative(e,o,t)}}async doDownloadBrowser(r,o,t){const e=await this.fileService.resolve(r,{resolveMetadata:!0});if(t.token.isCancellationRequested)return;const i=32*v.MB,a=e.isDirectory||e.size>i,c=de();if(a&&Ie.supported(c))try{const s=await c.showDirectoryPicker(),n={startTime:Date.now(),progressScheduler:new N(d=>{o.report(d[d.length-1])},1e3),filesTotal:e.isDirectory?0:1,filesDownloaded:0,totalBytesDownloaded:0,fileBytesDownloaded:0};if(e.isDirectory){const d=await s.getDirectoryHandle(e.name,{create:!0});await this.downloadFolderBrowser(e,d,n,t.token)}else await this.downloadFileBrowser(s,e,n,t.token);n.progressScheduler.dispose()}catch(s){this.logService.warn(s),t.cancel()}else if(e.isFile){let s;try{s=(await this.fileService.readFile(e.resource,{limits:{size:i}},t.token)).value.buffer}catch{s=ue.uriToBrowserUri(e.resource)}t.token.isCancellationRequested||fe(s,e.name)}}async downloadFileBufferedBrowser(r,o,t,e){const i=await this.fileService.readFileStream(r,void 0,e);if(e.isCancellationRequested){o.close();return}return new Promise((a,c)=>{const s=i.value,n=new we;n.add(he(()=>o.close())),n.add(Se(e.onCancellationRequested)(()=>{n.dispose(),c(ge())})),ve(s,{onData:d=>{o.write(d.buffer),this.reportProgress(i.name,i.size,d.byteLength,t)},onError:d=>{n.dispose(),c(d)},onEnd:()=>{n.dispose(),a()}},e)})}async downloadFileUnbufferedBrowser(r,o,t,e){const i=await this.fileService.readFile(r,void 0,e);e.isCancellationRequested||(o.write(i.value.buffer),this.reportProgress(i.name,i.size,i.value.byteLength,t)),o.close()}async downloadFileBrowser(r,o,t,e){t.filesDownloaded++,t.fileBytesDownloaded=0,this.reportProgress(o.name,0,0,t);const a=await(await r.getFileHandle(o.name,{create:!0})).createWritable();return o.size>v.MB?this.downloadFileBufferedBrowser(o.resource,a,t,e):this.downloadFileUnbufferedBrowser(o.resource,a,t,e)}async downloadFolderBrowser(r,o,t,e){if(r.children){t.filesTotal+=r.children.map(i=>i.isFile).length;for(const i of r.children){if(e.isCancellationRequested)return;if(i.isFile)await this.downloadFileBrowser(o,i,t,e);else{const a=await o.getDirectoryHandle(i.name,{create:!0}),c=await this.fileService.resolve(i.resource,{resolveMetadata:!0});await this.downloadFolderBrowser(c,a,t,e)}}}}reportProgress(r,o,t,e){e.fileBytesDownloaded+=t,e.totalBytesDownloaded+=t;const i=e.totalBytesDownloaded/((Date.now()-e.startTime)/1e3);let a;o<v.MB?e.filesTotal===1?a=r:a=l("downloadProgressSmallMany","{0} of {1} files ({2}/s)",e.filesDownloaded,e.filesTotal,v.formatSize(i)):a=l("downloadProgressLarge","{0} ({1} of {2}, {3}/s)",r,v.formatSize(e.fileBytesDownloaded),v.formatSize(o),v.formatSize(i)),e.progressScheduler.work({message:a})}async doDownloadNative(r,o,t){o.report({message:r.name});let e;const i=this.storageService.get(I.LAST_USED_DOWNLOAD_PATH_STORAGE_KEY,V.APPLICATION);i?e=F(oe.file(i),r.name):e=F(r.isDirectory?await this.fileDialogService.defaultFolderPath(A.file):await this.fileDialogService.defaultFilePath(A.file),r.name);const a=await this.fileDialogService.showSaveDialog({availableFileSystems:[A.file],saveLabel:pe(l("downloadButton","Download")),title:l("chooseWhereToDownload","Choose Where to Download"),defaultUri:e});a?(this.storageService.store(I.LAST_USED_DOWNLOAD_PATH_STORAGE_KEY,ie(a).fsPath,V.APPLICATION,Fe.MACHINE),await this.explorerService.applyBulkEdit([new W(r.resource,a,{overwrite:!0,copy:!0})],{undoLabel:l("downloadBulkEdit","Download {0}",r.name),progressLabel:l("downloadingBulkEdit","Downloading {0}",r.name),progressLocation:D.Window})):t.cancel()}};I=P([u(0,T),u(1,k),u(2,R),u(3,me),u(4,$),u(5,De)],I);function O(w){return{message:l("confirmOverwrite","A file or folder with the name '{0}' already exists in the destination folder. Do you want to replace it?",w),detail:l("irreversible","This action is irreversible!"),primaryButton:l({key:"replaceButtonLabel",comment:["&& denotes a mnemonic"]},"&&Replace"),type:"warning"}}function mr(w){return w.length>1?{message:l("confirmManyOverwrites","The following {0} files and/or folders already exist in the destination folder. Do you want to replace them?",w.length),detail:Q(w)+`
`+l("irreversible","This action is irreversible!"),primaryButton:l({key:"replaceButtonLabel",comment:["&& denotes a mnemonic"]},"&&Replace"),type:"warning"}:O(g(w[0]))}export{y as BrowserFileUpload,E as ExternalFileImport,I as FileDownload,O as getFileOverwriteConfirm,mr as getMultipleFilesOverwriteConfirm};
