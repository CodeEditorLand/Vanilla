{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/files/browser/fileImportExport.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { localize } from '../../../../nls.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { getFileNamesMessage, IConfirmation, IDialogService, IFileDialogService, IPromptButton } from '../../../../platform/dialogs/common/dialogs.js';\nimport { ByteSize, FileSystemProviderCapabilities, IFileService, IFileStatWithMetadata } from '../../../../platform/files/common/files.js';\nimport { INotificationService, Severity } from '../../../../platform/notification/common/notification.js';\nimport { IProgress, IProgressService, IProgressStep, ProgressLocation } from '../../../../platform/progress/common/progress.js';\nimport { IExplorerService } from './files.js';\nimport { IFilesConfiguration, UndoConfirmLevel, VIEW_ID } from '../common/files.js';\nimport { IEditorService } from '../../../services/editor/common/editorService.js';\nimport { Limiter, Promises, RunOnceWorker } from '../../../../base/common/async.js';\nimport { newWriteableBufferStream, VSBuffer } from '../../../../base/common/buffer.js';\nimport { basename, dirname, joinPath } from '../../../../base/common/resources.js';\nimport { ResourceFileEdit } from '../../../../editor/browser/services/bulkEditService.js';\nimport { ExplorerItem } from '../common/explorerModel.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IHostService } from '../../../services/host/browser/host.js';\nimport { IWorkspaceContextService } from '../../../../platform/workspace/common/workspace.js';\nimport { extractEditorsAndFilesDropData } from '../../../../platform/dnd/browser/dnd.js';\nimport { IWorkspaceEditingService } from '../../../services/workspaces/common/workspaceEditing.js';\nimport { isWeb } from '../../../../base/common/platform.js';\nimport { getActiveWindow, isDragEvent, triggerDownload } from '../../../../base/browser/dom.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { FileAccess, Schemas } from '../../../../base/common/network.js';\nimport { mnemonicButtonLabel } from '../../../../base/common/labels.js';\nimport { listenStream } from '../../../../base/common/stream.js';\nimport { DisposableStore, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { createSingleCallFunction } from '../../../../base/common/functional.js';\nimport { coalesce } from '../../../../base/common/arrays.js';\nimport { canceled } from '../../../../base/common/errors.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { WebFileSystemAccess } from '../../../../platform/files/browser/webFileSystemAccess.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IStorageService, StorageScope, StorageTarget } from '../../../../platform/storage/common/storage.js';\n\n//#region Browser File Upload (drag and drop, input element)\n\ninterface IBrowserUploadOperation {\n\tstartTime: number;\n\tprogressScheduler: RunOnceWorker<IProgressStep>;\n\n\tfilesTotal: number;\n\tfilesUploaded: number;\n\n\ttotalBytesUploaded: number;\n}\n\ninterface IWebkitDataTransfer {\n\titems: IWebkitDataTransferItem[];\n}\n\ninterface IWebkitDataTransferItem {\n\twebkitGetAsEntry(): IWebkitDataTransferItemEntry;\n}\n\ninterface IWebkitDataTransferItemEntry {\n\tname: string | undefined;\n\tisFile: boolean;\n\tisDirectory: boolean;\n\n\tfile(resolve: (file: File) => void, reject: () => void): void;\n\tcreateReader(): IWebkitDataTransferItemEntryReader;\n}\n\ninterface IWebkitDataTransferItemEntryReader {\n\treadEntries(resolve: (file: IWebkitDataTransferItemEntry[]) => void, reject: () => void): void;\n}\n\nexport class BrowserFileUpload {\n\n\tprivate static readonly MAX_PARALLEL_UPLOADS = 20;\n\n\tconstructor(\n\t\t@IProgressService private readonly progressService: IProgressService,\n\t\t@IDialogService private readonly dialogService: IDialogService,\n\t\t@IExplorerService private readonly explorerService: IExplorerService,\n\t\t@IEditorService private readonly editorService: IEditorService,\n\t\t@IFileService private readonly fileService: IFileService\n\t) {\n\t}\n\n\tupload(target: ExplorerItem, source: DragEvent | FileList): Promise<void> {\n\t\tconst cts = new CancellationTokenSource();\n\n\t\t// Indicate progress globally\n\t\tconst uploadPromise = this.progressService.withProgress(\n\t\t\t{\n\t\t\t\tlocation: ProgressLocation.Window,\n\t\t\t\tdelay: 800,\n\t\t\t\tcancellable: true,\n\t\t\t\ttitle: localize('uploadingFiles', \"Uploading\")\n\t\t\t},\n\t\t\tasync progress => this.doUpload(target, this.toTransfer(source), progress, cts.token),\n\t\t\t() => cts.dispose(true)\n\t\t);\n\n\t\t// Also indicate progress in the files view\n\t\tthis.progressService.withProgress({ location: VIEW_ID, delay: 500 }, () => uploadPromise);\n\n\t\treturn uploadPromise;\n\t}\n\n\tprivate toTransfer(source: DragEvent | FileList): IWebkitDataTransfer {\n\t\tif (isDragEvent(source)) {\n\t\t\treturn source.dataTransfer as unknown as IWebkitDataTransfer;\n\t\t}\n\n\t\tconst transfer: IWebkitDataTransfer = { items: [] };\n\n\t\t// We want to reuse the same code for uploading from\n\t\t// Drag & Drop as well as input element based upload\n\t\t// so we convert into webkit data transfer when the\n\t\t// input element approach is used (simplified).\n\t\tfor (const file of source) {\n\t\t\ttransfer.items.push({\n\t\t\t\twebkitGetAsEntry: () => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: file.name,\n\t\t\t\t\t\tisDirectory: false,\n\t\t\t\t\t\tisFile: true,\n\t\t\t\t\t\tcreateReader: () => { throw new Error('Unsupported for files'); },\n\t\t\t\t\t\tfile: resolve => resolve(file)\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn transfer;\n\t}\n\n\tprivate async doUpload(target: ExplorerItem, source: IWebkitDataTransfer, progress: IProgress<IProgressStep>, token: CancellationToken): Promise<void> {\n\t\tconst items = source.items;\n\n\t\t// Somehow the items thing is being modified at random, maybe as a security\n\t\t// measure since this is a DND operation. As such, we copy the items into\n\t\t// an array we own as early as possible before using it.\n\t\tconst entries: IWebkitDataTransferItemEntry[] = [];\n\t\tfor (const item of items) {\n\t\t\tentries.push(item.webkitGetAsEntry());\n\t\t}\n\n\t\tconst results: { isFile: boolean; resource: URI }[] = [];\n\t\tconst operation: IBrowserUploadOperation = {\n\t\t\tstartTime: Date.now(),\n\t\t\tprogressScheduler: new RunOnceWorker<IProgressStep>(steps => { progress.report(steps[steps.length - 1]); }, 1000),\n\n\t\t\tfilesTotal: entries.length,\n\t\t\tfilesUploaded: 0,\n\n\t\t\ttotalBytesUploaded: 0\n\t\t};\n\n\t\t// Upload all entries in parallel up to a\n\t\t// certain maximum leveraging the `Limiter`\n\t\tconst uploadLimiter = new Limiter(BrowserFileUpload.MAX_PARALLEL_UPLOADS);\n\t\tawait Promises.settled(entries.map(entry => {\n\t\t\treturn uploadLimiter.queue(async () => {\n\t\t\t\tif (token.isCancellationRequested) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Confirm overwrite as needed\n\t\t\t\tif (target && entry.name && target.getChild(entry.name)) {\n\t\t\t\t\tconst { confirmed } = await this.dialogService.confirm(getFileOverwriteConfirm(entry.name));\n\t\t\t\t\tif (!confirmed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tawait this.explorerService.applyBulkEdit([new ResourceFileEdit(joinPath(target.resource, entry.name), undefined, { recursive: true, folder: target.getChild(entry.name)?.isDirectory })], {\n\t\t\t\t\t\tundoLabel: localize('overwrite', \"Overwrite {0}\", entry.name),\n\t\t\t\t\t\tprogressLabel: localize('overwriting', \"Overwriting {0}\", entry.name),\n\t\t\t\t\t});\n\n\t\t\t\t\tif (token.isCancellationRequested) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Upload entry\n\t\t\t\tconst result = await this.doUploadEntry(entry, target.resource, target, progress, operation, token);\n\t\t\t\tif (result) {\n\t\t\t\t\tresults.push(result);\n\t\t\t\t}\n\t\t\t});\n\t\t}));\n\n\t\toperation.progressScheduler.dispose();\n\n\t\t// Open uploaded file in editor only if we upload just one\n\t\tconst firstUploadedFile = results[0];\n\t\tif (!token.isCancellationRequested && firstUploadedFile?.isFile) {\n\t\t\tawait this.editorService.openEditor({ resource: firstUploadedFile.resource, options: { pinned: true } });\n\t\t}\n\t}\n\n\tprivate async doUploadEntry(entry: IWebkitDataTransferItemEntry, parentResource: URI, target: ExplorerItem | undefined, progress: IProgress<IProgressStep>, operation: IBrowserUploadOperation, token: CancellationToken): Promise<{ isFile: boolean; resource: URI } | undefined> {\n\t\tif (token.isCancellationRequested || !entry.name || (!entry.isFile && !entry.isDirectory)) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Report progress\n\t\tlet fileBytesUploaded = 0;\n\t\tconst reportProgress = (fileSize: number, bytesUploaded: number): void => {\n\t\t\tfileBytesUploaded += bytesUploaded;\n\t\t\toperation.totalBytesUploaded += bytesUploaded;\n\n\t\t\tconst bytesUploadedPerSecond = operation.totalBytesUploaded / ((Date.now() - operation.startTime) / 1000);\n\n\t\t\t// Small file\n\t\t\tlet message: string;\n\t\t\tif (fileSize < ByteSize.MB) {\n\t\t\t\tif (operation.filesTotal === 1) {\n\t\t\t\t\tmessage = `${entry.name}`;\n\t\t\t\t} else {\n\t\t\t\t\tmessage = localize('uploadProgressSmallMany', \"{0} of {1} files ({2}/s)\", operation.filesUploaded, operation.filesTotal, ByteSize.formatSize(bytesUploadedPerSecond));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Large file\n\t\t\telse {\n\t\t\t\tmessage = localize('uploadProgressLarge', \"{0} ({1} of {2}, {3}/s)\", entry.name, ByteSize.formatSize(fileBytesUploaded), ByteSize.formatSize(fileSize), ByteSize.formatSize(bytesUploadedPerSecond));\n\t\t\t}\n\n\t\t\t// Report progress but limit to update only once per second\n\t\t\toperation.progressScheduler.work({ message });\n\t\t};\n\t\toperation.filesUploaded++;\n\t\treportProgress(0, 0);\n\n\t\t// Handle file upload\n\t\tconst resource = joinPath(parentResource, entry.name);\n\t\tif (entry.isFile) {\n\t\t\tconst file = await new Promise<File>((resolve, reject) => entry.file(resolve, reject));\n\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\t// Chrome/Edge/Firefox support stream method, but only use it for\n\t\t\t// larger files to reduce the overhead of the streaming approach\n\t\t\tif (typeof file.stream === 'function' && file.size > ByteSize.MB) {\n\t\t\t\tawait this.doUploadFileBuffered(resource, file, reportProgress, token);\n\t\t\t}\n\n\t\t\t// Fallback to unbuffered upload for other browsers or small files\n\t\t\telse {\n\t\t\t\tawait this.doUploadFileUnbuffered(resource, file, reportProgress);\n\t\t\t}\n\n\t\t\treturn { isFile: true, resource };\n\t\t}\n\n\t\t// Handle folder upload\n\t\telse {\n\n\t\t\t// Create target folder\n\t\t\tawait this.fileService.createFolder(resource);\n\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\t// Recursive upload files in this directory\n\t\t\tconst dirReader = entry.createReader();\n\t\t\tconst childEntries: IWebkitDataTransferItemEntry[] = [];\n\t\t\tlet done = false;\n\t\t\tdo {\n\t\t\t\tconst childEntriesChunk = await new Promise<IWebkitDataTransferItemEntry[]>((resolve, reject) => dirReader.readEntries(resolve, reject));\n\t\t\t\tif (childEntriesChunk.length > 0) {\n\t\t\t\t\tchildEntries.push(...childEntriesChunk);\n\t\t\t\t} else {\n\t\t\t\t\tdone = true; // an empty array is a signal that all entries have been read\n\t\t\t\t}\n\t\t\t} while (!done && !token.isCancellationRequested);\n\n\t\t\t// Update operation total based on new counts\n\t\t\toperation.filesTotal += childEntries.length;\n\n\t\t\t// Split up files from folders to upload\n\t\t\tconst folderTarget = target && target.getChild(entry.name) || undefined;\n\t\t\tconst fileChildEntries: IWebkitDataTransferItemEntry[] = [];\n\t\t\tconst folderChildEntries: IWebkitDataTransferItemEntry[] = [];\n\t\t\tfor (const childEntry of childEntries) {\n\t\t\t\tif (childEntry.isFile) {\n\t\t\t\t\tfileChildEntries.push(childEntry);\n\t\t\t\t} else if (childEntry.isDirectory) {\n\t\t\t\t\tfolderChildEntries.push(childEntry);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Upload files (up to `MAX_PARALLEL_UPLOADS` in parallel)\n\t\t\tconst fileUploadQueue = new Limiter(BrowserFileUpload.MAX_PARALLEL_UPLOADS);\n\t\t\tawait Promises.settled(fileChildEntries.map(fileChildEntry => {\n\t\t\t\treturn fileUploadQueue.queue(() => this.doUploadEntry(fileChildEntry, resource, folderTarget, progress, operation, token));\n\t\t\t}));\n\n\t\t\t// Upload folders (sequentially give we don't know their sizes)\n\t\t\tfor (const folderChildEntry of folderChildEntries) {\n\t\t\t\tawait this.doUploadEntry(folderChildEntry, resource, folderTarget, progress, operation, token);\n\t\t\t}\n\n\t\t\treturn { isFile: false, resource };\n\t\t}\n\t}\n\n\tprivate async doUploadFileBuffered(resource: URI, file: File, progressReporter: (fileSize: number, bytesUploaded: number) => void, token: CancellationToken): Promise<void> {\n\t\tconst writeableStream = newWriteableBufferStream({\n\t\t\t// Set a highWaterMark to prevent the stream\n\t\t\t// for file upload to produce large buffers\n\t\t\t// in-memory\n\t\t\thighWaterMark: 10\n\t\t});\n\t\tconst writeFilePromise = this.fileService.writeFile(resource, writeableStream);\n\n\t\t// Read the file in chunks using File.stream() web APIs\n\t\ttry {\n\t\t\tconst reader: ReadableStreamDefaultReader<Uint8Array> = file.stream().getReader();\n\n\t\t\tlet res = await reader.read();\n\t\t\twhile (!res.done) {\n\t\t\t\tif (token.isCancellationRequested) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Write buffer into stream but make sure to wait\n\t\t\t\t// in case the `highWaterMark` is reached\n\t\t\t\tconst buffer = VSBuffer.wrap(res.value);\n\t\t\t\tawait writeableStream.write(buffer);\n\n\t\t\t\tif (token.isCancellationRequested) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Report progress\n\t\t\t\tprogressReporter(file.size, buffer.byteLength);\n\n\t\t\t\tres = await reader.read();\n\t\t\t}\n\t\t\twriteableStream.end(undefined);\n\t\t} catch (error) {\n\t\t\twriteableStream.error(error);\n\t\t\twriteableStream.end();\n\t\t}\n\n\t\tif (token.isCancellationRequested) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Wait for file being written to target\n\t\tawait writeFilePromise;\n\t}\n\n\tprivate doUploadFileUnbuffered(resource: URI, file: File, progressReporter: (fileSize: number, bytesUploaded: number) => void): Promise<void> {\n\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\tconst reader = new FileReader();\n\t\t\treader.onload = async event => {\n\t\t\t\ttry {\n\t\t\t\t\tif (event.target?.result instanceof ArrayBuffer) {\n\t\t\t\t\t\tconst buffer = VSBuffer.wrap(new Uint8Array(event.target.result));\n\t\t\t\t\t\tawait this.fileService.writeFile(resource, buffer);\n\n\t\t\t\t\t\t// Report progress\n\t\t\t\t\t\tprogressReporter(file.size, buffer.byteLength);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error('Could not read from dropped file.');\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve();\n\t\t\t\t} catch (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Start reading the file to trigger `onload`\n\t\t\treader.readAsArrayBuffer(file);\n\t\t});\n\t}\n}\n\n//#endregion\n\n//#region External File Import (drag and drop)\n\nexport class ExternalFileImport {\n\n\tconstructor(\n\t\t@IFileService private readonly fileService: IFileService,\n\t\t@IHostService private readonly hostService: IHostService,\n\t\t@IWorkspaceContextService private readonly contextService: IWorkspaceContextService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t\t@IDialogService private readonly dialogService: IDialogService,\n\t\t@IWorkspaceEditingService private readonly workspaceEditingService: IWorkspaceEditingService,\n\t\t@IExplorerService private readonly explorerService: IExplorerService,\n\t\t@IEditorService private readonly editorService: IEditorService,\n\t\t@IProgressService private readonly progressService: IProgressService,\n\t\t@INotificationService private readonly notificationService: INotificationService,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService\n\t) {\n\t}\n\n\tasync import(target: ExplorerItem, source: DragEvent, targetWindow: Window): Promise<void> {\n\t\tconst cts = new CancellationTokenSource();\n\n\t\t// Indicate progress globally\n\t\tconst importPromise = this.progressService.withProgress(\n\t\t\t{\n\t\t\t\tlocation: ProgressLocation.Window,\n\t\t\t\tdelay: 800,\n\t\t\t\tcancellable: true,\n\t\t\t\ttitle: localize('copyingFiles', \"Copying...\")\n\t\t\t},\n\t\t\tasync () => await this.doImport(target, source, targetWindow, cts.token),\n\t\t\t() => cts.dispose(true)\n\t\t);\n\n\t\t// Also indicate progress in the files view\n\t\tthis.progressService.withProgress({ location: VIEW_ID, delay: 500 }, () => importPromise);\n\n\t\treturn importPromise;\n\t}\n\n\tprivate async doImport(target: ExplorerItem, source: DragEvent, targetWindow: Window, token: CancellationToken): Promise<void> {\n\n\t\t// Activate all providers for the resources dropped\n\t\tconst candidateFiles = coalesce((await this.instantiationService.invokeFunction(accessor => extractEditorsAndFilesDropData(accessor, source))).map(editor => editor.resource));\n\t\tawait Promise.all(candidateFiles.map(resource => this.fileService.activateProvider(resource.scheme)));\n\n\t\t// Check for dropped external files to be folders\n\t\tconst files = coalesce(candidateFiles.filter(resource => this.fileService.hasProvider(resource)));\n\t\tconst resolvedFiles = await this.fileService.resolveAll(files.map(file => ({ resource: file })));\n\n\t\tif (token.isCancellationRequested) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Pass focus to window\n\t\tthis.hostService.focus(targetWindow);\n\n\t\t// Handle folders by adding to workspace if we are in workspace context and if dropped on top\n\t\tconst folders = resolvedFiles.filter(resolvedFile => resolvedFile.success && resolvedFile.stat?.isDirectory).map(resolvedFile => ({ uri: resolvedFile.stat!.resource }));\n\t\tif (folders.length > 0 && target.isRoot) {\n\t\t\tenum ImportChoice {\n\t\t\t\tCopy = 1,\n\t\t\t\tAdd = 2\n\t\t\t}\n\n\t\t\tconst buttons: IPromptButton<ImportChoice | undefined>[] = [\n\t\t\t\t{\n\t\t\t\t\tlabel: folders.length > 1 ?\n\t\t\t\t\t\tlocalize('copyFolders', \"&&Copy Folders\") :\n\t\t\t\t\t\tlocalize('copyFolder', \"&&Copy Folder\"),\n\t\t\t\t\trun: () => ImportChoice.Copy\n\t\t\t\t}\n\t\t\t];\n\n\t\t\tlet message: string;\n\n\t\t\t// We only allow to add a folder to the workspace if there is already a workspace folder with that scheme\n\t\t\tconst workspaceFolderSchemas = this.contextService.getWorkspace().folders.map(folder => folder.uri.scheme);\n\t\t\tif (folders.some(folder => workspaceFolderSchemas.indexOf(folder.uri.scheme) >= 0)) {\n\t\t\t\tbuttons.unshift({\n\t\t\t\t\tlabel: folders.length > 1 ?\n\t\t\t\t\t\tlocalize('addFolders', \"&&Add Folders to Workspace\") :\n\t\t\t\t\t\tlocalize('addFolder', \"&&Add Folder to Workspace\"),\n\t\t\t\t\trun: () => ImportChoice.Add\n\t\t\t\t});\n\t\t\t\tmessage = folders.length > 1 ?\n\t\t\t\t\tlocalize('dropFolders', \"Do you want to copy the folders or add the folders to the workspace?\") :\n\t\t\t\t\tlocalize('dropFolder', \"Do you want to copy '{0}' or add '{0}' as a folder to the workspace?\", basename(folders[0].uri));\n\t\t\t} else {\n\t\t\t\tmessage = folders.length > 1 ?\n\t\t\t\t\tlocalize('copyfolders', \"Are you sure to want to copy folders?\") :\n\t\t\t\t\tlocalize('copyfolder', \"Are you sure to want to copy '{0}'?\", basename(folders[0].uri));\n\t\t\t}\n\n\t\t\tconst { result } = await this.dialogService.prompt({\n\t\t\t\ttype: Severity.Info,\n\t\t\t\tmessage,\n\t\t\t\tbuttons,\n\t\t\t\tcancelButton: true\n\t\t\t});\n\n\t\t\t// Add folders\n\t\t\tif (result === ImportChoice.Add) {\n\t\t\t\treturn this.workspaceEditingService.addFolders(folders);\n\t\t\t}\n\n\t\t\t// Copy resources\n\t\t\tif (result === ImportChoice.Copy) {\n\t\t\t\treturn this.importResources(target, files, token);\n\t\t\t}\n\t\t}\n\n\t\t// Handle dropped files (only support FileStat as target)\n\t\telse if (target instanceof ExplorerItem) {\n\t\t\treturn this.importResources(target, files, token);\n\t\t}\n\t}\n\n\tprivate async importResources(target: ExplorerItem, resources: URI[], token: CancellationToken): Promise<void> {\n\t\tif (resources && resources.length > 0) {\n\n\t\t\t// Resolve target to check for name collisions and ask user\n\t\t\tconst targetStat = await this.fileService.resolve(target.resource);\n\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Check for name collisions\n\t\t\tconst targetNames = new Set<string>();\n\t\t\tconst caseSensitive = this.fileService.hasCapability(target.resource, FileSystemProviderCapabilities.PathCaseSensitive);\n\t\t\tif (targetStat.children) {\n\t\t\t\ttargetStat.children.forEach(child => {\n\t\t\t\t\ttargetNames.add(caseSensitive ? child.name : child.name.toLowerCase());\n\t\t\t\t});\n\t\t\t}\n\n\n\t\t\tlet inaccessibleFileCount = 0;\n\t\t\tconst resourcesFiltered = coalesce((await Promises.settled(resources.map(async resource => {\n\t\t\t\tconst fileDoesNotExist = !(await this.fileService.exists(resource));\n\t\t\t\tif (fileDoesNotExist) {\n\t\t\t\t\tinaccessibleFileCount++;\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\tif (targetNames.has(caseSensitive ? basename(resource) : basename(resource).toLowerCase())) {\n\t\t\t\t\tconst confirmationResult = await this.dialogService.confirm(getFileOverwriteConfirm(basename(resource)));\n\t\t\t\t\tif (!confirmationResult.confirmed) {\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn resource;\n\t\t\t}))));\n\n\t\t\tif (inaccessibleFileCount > 0) {\n\t\t\t\tthis.notificationService.error(inaccessibleFileCount > 1 ? localize('filesInaccessible', \"Some or all of the dropped files could not be accessed for import.\") : localize('fileInaccessible', \"The dropped file could not be accessed for import.\"));\n\t\t\t}\n\n\t\t\t// Copy resources through bulk edit API\n\t\t\tconst resourceFileEdits = resourcesFiltered.map(resource => {\n\t\t\t\tconst sourceFileName = basename(resource);\n\t\t\t\tconst targetFile = joinPath(target.resource, sourceFileName);\n\n\t\t\t\treturn new ResourceFileEdit(resource, targetFile, { overwrite: true, copy: true });\n\t\t\t});\n\n\t\t\tconst undoLevel = this.configurationService.getValue<IFilesConfiguration>().explorer.confirmUndo;\n\t\t\tawait this.explorerService.applyBulkEdit(resourceFileEdits, {\n\t\t\t\tundoLabel: resourcesFiltered.length === 1 ?\n\t\t\t\t\tlocalize({ comment: ['substitution will be the name of the file that was imported'], key: 'importFile' }, \"Import {0}\", basename(resourcesFiltered[0])) :\n\t\t\t\t\tlocalize({ comment: ['substitution will be the number of files that were imported'], key: 'importnFile' }, \"Import {0} resources\", resourcesFiltered.length),\n\t\t\t\tprogressLabel: resourcesFiltered.length === 1 ?\n\t\t\t\t\tlocalize({ comment: ['substitution will be the name of the file that was copied'], key: 'copyingFile' }, \"Copying {0}\", basename(resourcesFiltered[0])) :\n\t\t\t\t\tlocalize({ comment: ['substitution will be the number of files that were copied'], key: 'copyingnFile' }, \"Copying {0} resources\", resourcesFiltered.length),\n\t\t\t\tprogressLocation: ProgressLocation.Window,\n\t\t\t\tconfirmBeforeUndo: undoLevel === UndoConfirmLevel.Verbose || undoLevel === UndoConfirmLevel.Default,\n\t\t\t});\n\n\t\t\t// if we only add one file, just open it directly\n\t\t\tconst autoOpen = this.configurationService.getValue<IFilesConfiguration>().explorer.autoOpenDroppedFile;\n\t\t\tif (autoOpen && resourceFileEdits.length === 1) {\n\t\t\t\tconst item = this.explorerService.findClosest(resourceFileEdits[0].newResource!);\n\t\t\t\tif (item && !item.isDirectory) {\n\t\t\t\t\tthis.editorService.openEditor({ resource: item.resource, options: { pinned: true } });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n//#endregion\n\n//#region Download (web, native)\n\ninterface IDownloadOperation {\n\tstartTime: number;\n\tprogressScheduler: RunOnceWorker<IProgressStep>;\n\n\tfilesTotal: number;\n\tfilesDownloaded: number;\n\n\ttotalBytesDownloaded: number;\n\tfileBytesDownloaded: number;\n}\n\nexport class FileDownload {\n\n\tprivate static readonly LAST_USED_DOWNLOAD_PATH_STORAGE_KEY = 'workbench.explorer.downloadPath';\n\n\tconstructor(\n\t\t@IFileService private readonly fileService: IFileService,\n\t\t@IExplorerService private readonly explorerService: IExplorerService,\n\t\t@IProgressService private readonly progressService: IProgressService,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IFileDialogService private readonly fileDialogService: IFileDialogService,\n\t\t@IStorageService private readonly storageService: IStorageService\n\t) {\n\t}\n\n\tdownload(source: ExplorerItem[]): Promise<void> {\n\t\tconst cts = new CancellationTokenSource();\n\n\t\t// Indicate progress globally\n\t\tconst downloadPromise = this.progressService.withProgress(\n\t\t\t{\n\t\t\t\tlocation: ProgressLocation.Window,\n\t\t\t\tdelay: 800,\n\t\t\t\tcancellable: isWeb,\n\t\t\t\ttitle: localize('downloadingFiles', \"Downloading\")\n\t\t\t},\n\t\t\tasync progress => this.doDownload(source, progress, cts),\n\t\t\t() => cts.dispose(true)\n\t\t);\n\n\t\t// Also indicate progress in the files view\n\t\tthis.progressService.withProgress({ location: VIEW_ID, delay: 500 }, () => downloadPromise);\n\n\t\treturn downloadPromise;\n\t}\n\n\tprivate async doDownload(sources: ExplorerItem[], progress: IProgress<IProgressStep>, cts: CancellationTokenSource): Promise<void> {\n\t\tfor (const source of sources) {\n\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Web: use DOM APIs to download files with optional support\n\t\t\t// for folders and large files\n\t\t\tif (isWeb) {\n\t\t\t\tawait this.doDownloadBrowser(source.resource, progress, cts);\n\t\t\t}\n\n\t\t\t// Native: use working copy file service to get at the contents\n\t\t\telse {\n\t\t\t\tawait this.doDownloadNative(source, progress, cts);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async doDownloadBrowser(resource: URI, progress: IProgress<IProgressStep>, cts: CancellationTokenSource): Promise<void> {\n\t\tconst stat = await this.fileService.resolve(resource, { resolveMetadata: true });\n\n\t\tif (cts.token.isCancellationRequested) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst maxBlobDownloadSize = 32 * ByteSize.MB; // avoid to download via blob-trick >32MB to avoid memory pressure\n\t\tconst preferFileSystemAccessWebApis = stat.isDirectory || stat.size > maxBlobDownloadSize;\n\n\t\t// Folder: use FS APIs to download files and folders if available and preferred\n\t\tconst activeWindow = getActiveWindow();\n\t\tif (preferFileSystemAccessWebApis && WebFileSystemAccess.supported(activeWindow)) {\n\t\t\ttry {\n\t\t\t\tconst parentFolder: FileSystemDirectoryHandle = await activeWindow.showDirectoryPicker();\n\t\t\t\tconst operation: IDownloadOperation = {\n\t\t\t\t\tstartTime: Date.now(),\n\t\t\t\t\tprogressScheduler: new RunOnceWorker<IProgressStep>(steps => { progress.report(steps[steps.length - 1]); }, 1000),\n\n\t\t\t\t\tfilesTotal: stat.isDirectory ? 0 : 1, // folders increment filesTotal within downloadFolder method\n\t\t\t\t\tfilesDownloaded: 0,\n\n\t\t\t\t\ttotalBytesDownloaded: 0,\n\t\t\t\t\tfileBytesDownloaded: 0\n\t\t\t\t};\n\n\t\t\t\tif (stat.isDirectory) {\n\t\t\t\t\tconst targetFolder = await parentFolder.getDirectoryHandle(stat.name, { create: true });\n\t\t\t\t\tawait this.downloadFolderBrowser(stat, targetFolder, operation, cts.token);\n\t\t\t\t} else {\n\t\t\t\t\tawait this.downloadFileBrowser(parentFolder, stat, operation, cts.token);\n\t\t\t\t}\n\n\t\t\t\toperation.progressScheduler.dispose();\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.warn(error);\n\t\t\t\tcts.cancel(); // `showDirectoryPicker` will throw an error when the user cancels\n\t\t\t}\n\t\t}\n\n\t\t// File: use traditional download to circumvent browser limitations\n\t\telse if (stat.isFile) {\n\t\t\tlet bufferOrUri: Uint8Array | URI;\n\t\t\ttry {\n\t\t\t\tbufferOrUri = (await this.fileService.readFile(stat.resource, { limits: { size: maxBlobDownloadSize } }, cts.token)).value.buffer;\n\t\t\t} catch (error) {\n\t\t\t\tbufferOrUri = FileAccess.uriToBrowserUri(stat.resource);\n\t\t\t}\n\n\t\t\tif (!cts.token.isCancellationRequested) {\n\t\t\t\ttriggerDownload(bufferOrUri, stat.name);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async downloadFileBufferedBrowser(resource: URI, target: FileSystemWritableFileStream, operation: IDownloadOperation, token: CancellationToken): Promise<void> {\n\t\tconst contents = await this.fileService.readFileStream(resource, undefined, token);\n\t\tif (token.isCancellationRequested) {\n\t\t\ttarget.close();\n\t\t\treturn;\n\t\t}\n\n\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\tconst sourceStream = contents.value;\n\n\t\t\tconst disposables = new DisposableStore();\n\t\t\tdisposables.add(toDisposable(() => target.close()));\n\n\t\t\tdisposables.add(createSingleCallFunction(token.onCancellationRequested)(() => {\n\t\t\t\tdisposables.dispose();\n\t\t\t\treject(canceled());\n\t\t\t}));\n\n\t\t\tlistenStream(sourceStream, {\n\t\t\t\tonData: data => {\n\t\t\t\t\ttarget.write(data.buffer);\n\t\t\t\t\tthis.reportProgress(contents.name, contents.size, data.byteLength, operation);\n\t\t\t\t},\n\t\t\t\tonError: error => {\n\t\t\t\t\tdisposables.dispose();\n\t\t\t\t\treject(error);\n\t\t\t\t},\n\t\t\t\tonEnd: () => {\n\t\t\t\t\tdisposables.dispose();\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t}, token);\n\t\t});\n\t}\n\n\tprivate async downloadFileUnbufferedBrowser(resource: URI, target: FileSystemWritableFileStream, operation: IDownloadOperation, token: CancellationToken): Promise<void> {\n\t\tconst contents = await this.fileService.readFile(resource, undefined, token);\n\t\tif (!token.isCancellationRequested) {\n\t\t\ttarget.write(contents.value.buffer);\n\t\t\tthis.reportProgress(contents.name, contents.size, contents.value.byteLength, operation);\n\t\t}\n\n\t\ttarget.close();\n\t}\n\n\tprivate async downloadFileBrowser(targetFolder: FileSystemDirectoryHandle, file: IFileStatWithMetadata, operation: IDownloadOperation, token: CancellationToken): Promise<void> {\n\n\t\t// Report progress\n\t\toperation.filesDownloaded++;\n\t\toperation.fileBytesDownloaded = 0; // reset for this file\n\t\tthis.reportProgress(file.name, 0, 0, operation);\n\n\t\t// Start to download\n\t\tconst targetFile = await targetFolder.getFileHandle(file.name, { create: true });\n\t\tconst targetFileWriter = await targetFile.createWritable();\n\n\t\t// For large files, write buffered using streams\n\t\tif (file.size > ByteSize.MB) {\n\t\t\treturn this.downloadFileBufferedBrowser(file.resource, targetFileWriter, operation, token);\n\t\t}\n\n\t\t// For small files prefer to write unbuffered to reduce overhead\n\t\treturn this.downloadFileUnbufferedBrowser(file.resource, targetFileWriter, operation, token);\n\t}\n\n\tprivate async downloadFolderBrowser(folder: IFileStatWithMetadata, targetFolder: FileSystemDirectoryHandle, operation: IDownloadOperation, token: CancellationToken): Promise<void> {\n\t\tif (folder.children) {\n\t\t\toperation.filesTotal += (folder.children.map(child => child.isFile)).length;\n\n\t\t\tfor (const child of folder.children) {\n\t\t\t\tif (token.isCancellationRequested) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (child.isFile) {\n\t\t\t\t\tawait this.downloadFileBrowser(targetFolder, child, operation, token);\n\t\t\t\t} else {\n\t\t\t\t\tconst childFolder = await targetFolder.getDirectoryHandle(child.name, { create: true });\n\t\t\t\t\tconst resolvedChildFolder = await this.fileService.resolve(child.resource, { resolveMetadata: true });\n\n\t\t\t\t\tawait this.downloadFolderBrowser(resolvedChildFolder, childFolder, operation, token);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate reportProgress(name: string, fileSize: number, bytesDownloaded: number, operation: IDownloadOperation): void {\n\t\toperation.fileBytesDownloaded += bytesDownloaded;\n\t\toperation.totalBytesDownloaded += bytesDownloaded;\n\n\t\tconst bytesDownloadedPerSecond = operation.totalBytesDownloaded / ((Date.now() - operation.startTime) / 1000);\n\n\t\t// Small file\n\t\tlet message: string;\n\t\tif (fileSize < ByteSize.MB) {\n\t\t\tif (operation.filesTotal === 1) {\n\t\t\t\tmessage = name;\n\t\t\t} else {\n\t\t\t\tmessage = localize('downloadProgressSmallMany', \"{0} of {1} files ({2}/s)\", operation.filesDownloaded, operation.filesTotal, ByteSize.formatSize(bytesDownloadedPerSecond));\n\t\t\t}\n\t\t}\n\n\t\t// Large file\n\t\telse {\n\t\t\tmessage = localize('downloadProgressLarge', \"{0} ({1} of {2}, {3}/s)\", name, ByteSize.formatSize(operation.fileBytesDownloaded), ByteSize.formatSize(fileSize), ByteSize.formatSize(bytesDownloadedPerSecond));\n\t\t}\n\n\t\t// Report progress but limit to update only once per second\n\t\toperation.progressScheduler.work({ message });\n\t}\n\n\tprivate async doDownloadNative(explorerItem: ExplorerItem, progress: IProgress<IProgressStep>, cts: CancellationTokenSource): Promise<void> {\n\t\tprogress.report({ message: explorerItem.name });\n\n\t\tlet defaultUri: URI;\n\t\tconst lastUsedDownloadPath = this.storageService.get(FileDownload.LAST_USED_DOWNLOAD_PATH_STORAGE_KEY, StorageScope.APPLICATION);\n\t\tif (lastUsedDownloadPath) {\n\t\t\tdefaultUri = joinPath(URI.file(lastUsedDownloadPath), explorerItem.name);\n\t\t} else {\n\t\t\tdefaultUri = joinPath(\n\t\t\t\texplorerItem.isDirectory ?\n\t\t\t\t\tawait this.fileDialogService.defaultFolderPath(Schemas.file) :\n\t\t\t\t\tawait this.fileDialogService.defaultFilePath(Schemas.file),\n\t\t\t\texplorerItem.name\n\t\t\t);\n\t\t}\n\n\t\tconst destination = await this.fileDialogService.showSaveDialog({\n\t\t\tavailableFileSystems: [Schemas.file],\n\t\t\tsaveLabel: mnemonicButtonLabel(localize('downloadButton', \"Download\")),\n\t\t\ttitle: localize('chooseWhereToDownload', \"Choose Where to Download\"),\n\t\t\tdefaultUri\n\t\t});\n\n\t\tif (destination) {\n\n\t\t\t// Remember as last used download folder\n\t\t\tthis.storageService.store(FileDownload.LAST_USED_DOWNLOAD_PATH_STORAGE_KEY, dirname(destination).fsPath, StorageScope.APPLICATION, StorageTarget.MACHINE);\n\n\t\t\t// Perform download\n\t\t\tawait this.explorerService.applyBulkEdit([new ResourceFileEdit(explorerItem.resource, destination, { overwrite: true, copy: true })], {\n\t\t\t\tundoLabel: localize('downloadBulkEdit', \"Download {0}\", explorerItem.name),\n\t\t\t\tprogressLabel: localize('downloadingBulkEdit', \"Downloading {0}\", explorerItem.name),\n\t\t\t\tprogressLocation: ProgressLocation.Window\n\t\t\t});\n\t\t} else {\n\t\t\tcts.cancel(); // User canceled a download. In case there were multiple files selected we should cancel the remainder of the prompts #86100\n\t\t}\n\t}\n}\n\n//#endregion\n\n//#region Helpers\n\nexport function getFileOverwriteConfirm(name: string): IConfirmation {\n\treturn {\n\t\tmessage: localize('confirmOverwrite', \"A file or folder with the name '{0}' already exists in the destination folder. Do you want to replace it?\", name),\n\t\tdetail: localize('irreversible', \"This action is irreversible!\"),\n\t\tprimaryButton: localize({ key: 'replaceButtonLabel', comment: ['&& denotes a mnemonic'] }, \"&&Replace\"),\n\t\ttype: 'warning'\n\t};\n}\n\nexport function getMultipleFilesOverwriteConfirm(files: URI[]): IConfirmation {\n\tif (files.length > 1) {\n\t\treturn {\n\t\t\tmessage: localize('confirmManyOverwrites', \"The following {0} files and/or folders already exist in the destination folder. Do you want to replace them?\", files.length),\n\t\t\tdetail: getFileNamesMessage(files) + '\\n' + localize('irreversible', \"This action is irreversible!\"),\n\t\t\tprimaryButton: localize({ key: 'replaceButtonLabel', comment: ['&& denotes a mnemonic'] }, \"&&Replace\"),\n\t\t\ttype: 'warning'\n\t\t};\n\t}\n\n\treturn getFileOverwriteConfirm(basename(files[0]));\n}\n\n//#endregion\n"],
  "mappings": "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",
  "names": ["ImportChoice"]
}
