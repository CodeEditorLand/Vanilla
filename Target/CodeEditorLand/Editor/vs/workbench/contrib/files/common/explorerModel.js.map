{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/files/common/explorerModel.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from '../../../../base/common/uri.js';\nimport { isEqual } from '../../../../base/common/extpath.js';\nimport { posix } from '../../../../base/common/path.js';\nimport { ResourceMap } from '../../../../base/common/map.js';\nimport { IFileStat, IFileService, FileSystemProviderCapabilities } from '../../../../platform/files/common/files.js';\nimport { rtrim, startsWithIgnoreCase, equalsIgnoreCase } from '../../../../base/common/strings.js';\nimport { coalesce } from '../../../../base/common/arrays.js';\nimport { IWorkspaceContextService } from '../../../../platform/workspace/common/workspace.js';\nimport { IDisposable, dispose } from '../../../../base/common/lifecycle.js';\nimport { memoize } from '../../../../base/common/decorators.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { joinPath, isEqualOrParent, basenameOrAuthority } from '../../../../base/common/resources.js';\nimport { IFilesConfiguration, SortOrder } from './files.js';\nimport { IUriIdentityService } from '../../../../platform/uriIdentity/common/uriIdentity.js';\nimport { ExplorerFileNestingTrie } from './explorerFileNestingTrie.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { assertIsDefined } from '../../../../base/common/types.js';\nimport { IFilesConfigurationService } from '../../../services/filesConfiguration/common/filesConfigurationService.js';\nimport { IMarkdownString } from '../../../../base/common/htmlContent.js';\n\nexport class ExplorerModel implements IDisposable {\n\n\tprivate _roots!: ExplorerItem[];\n\tprivate _listener: IDisposable;\n\tprivate readonly _onDidChangeRoots = new Emitter<void>();\n\n\tconstructor(\n\t\tprivate readonly contextService: IWorkspaceContextService,\n\t\tprivate readonly uriIdentityService: IUriIdentityService,\n\t\tfileService: IFileService,\n\t\tconfigService: IConfigurationService,\n\t\tfilesConfigService: IFilesConfigurationService,\n\t) {\n\t\tconst setRoots = () => this._roots = this.contextService.getWorkspace().folders\n\t\t\t.map(folder => new ExplorerItem(folder.uri, fileService, configService, filesConfigService, undefined, true, false, false, false, folder.name));\n\t\tsetRoots();\n\n\t\tthis._listener = this.contextService.onDidChangeWorkspaceFolders(() => {\n\t\t\tsetRoots();\n\t\t\tthis._onDidChangeRoots.fire();\n\t\t});\n\t}\n\n\tget roots(): ExplorerItem[] {\n\t\treturn this._roots;\n\t}\n\n\tget onDidChangeRoots(): Event<void> {\n\t\treturn this._onDidChangeRoots.event;\n\t}\n\n\t/**\n\t * Returns an array of child stat from this stat that matches with the provided path.\n\t * Starts matching from the first root.\n\t * Will return empty array in case the FileStat does not exist.\n\t */\n\tfindAll(resource: URI): ExplorerItem[] {\n\t\treturn coalesce(this.roots.map(root => root.find(resource)));\n\t}\n\n\t/**\n\t * Returns a FileStat that matches the passed resource.\n\t * In case multiple FileStat are matching the resource (same folder opened multiple times) returns the FileStat that has the closest root.\n\t * Will return undefined in case the FileStat does not exist.\n\t */\n\tfindClosest(resource: URI): ExplorerItem | null {\n\t\tconst folder = this.contextService.getWorkspaceFolder(resource);\n\t\tif (folder) {\n\t\t\tconst root = this.roots.find(r => this.uriIdentityService.extUri.isEqual(r.resource, folder.uri));\n\t\t\tif (root) {\n\t\t\t\treturn root.find(resource);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tdispose(): void {\n\t\tdispose(this._listener);\n\t}\n}\n\nexport class ExplorerItem {\n\t_isDirectoryResolved: boolean; // used in tests\n\tpublic error: Error | undefined = undefined;\n\tprivate _isExcluded = false;\n\n\tpublic nestedParent: ExplorerItem | undefined;\n\tpublic nestedChildren: ExplorerItem[] | undefined;\n\n\tconstructor(\n\t\tpublic resource: URI,\n\t\tprivate readonly fileService: IFileService,\n\t\tprivate readonly configService: IConfigurationService,\n\t\tprivate readonly filesConfigService: IFilesConfigurationService,\n\t\tprivate _parent: ExplorerItem | undefined,\n\t\tprivate _isDirectory?: boolean,\n\t\tprivate _isSymbolicLink?: boolean,\n\t\tprivate _readonly?: boolean,\n\t\tprivate _locked?: boolean,\n\t\tprivate _name: string = basenameOrAuthority(resource),\n\t\tprivate _mtime?: number,\n\t\tprivate _unknown = false\n\t) {\n\t\tthis._isDirectoryResolved = false;\n\t}\n\n\tget isExcluded(): boolean {\n\t\tif (this._isExcluded) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!this._parent) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this._parent.isExcluded;\n\t}\n\n\tset isExcluded(value: boolean) {\n\t\tthis._isExcluded = value;\n\t}\n\n\thasChildren(filter: (stat: ExplorerItem) => boolean): boolean {\n\t\tif (this.hasNests) {\n\t\t\treturn this.nestedChildren?.some(c => filter(c)) ?? false;\n\t\t} else {\n\t\t\treturn this.isDirectory;\n\t\t}\n\t}\n\n\tget hasNests() {\n\t\treturn !!(this.nestedChildren?.length);\n\t}\n\n\tget isDirectoryResolved(): boolean {\n\t\treturn this._isDirectoryResolved;\n\t}\n\n\tget isSymbolicLink(): boolean {\n\t\treturn !!this._isSymbolicLink;\n\t}\n\n\tget isDirectory(): boolean {\n\t\treturn !!this._isDirectory;\n\t}\n\n\tget isReadonly(): boolean | IMarkdownString {\n\t\treturn this.filesConfigService.isReadonly(this.resource, { resource: this.resource, name: this.name, readonly: this._readonly, locked: this._locked });\n\t}\n\n\tget mtime(): number | undefined {\n\t\treturn this._mtime;\n\t}\n\n\tget name(): string {\n\t\treturn this._name;\n\t}\n\n\tget isUnknown(): boolean {\n\t\treturn this._unknown;\n\t}\n\n\tget parent(): ExplorerItem | undefined {\n\t\treturn this._parent;\n\t}\n\n\tget root(): ExplorerItem {\n\t\tif (!this._parent) {\n\t\t\treturn this;\n\t\t}\n\n\t\treturn this._parent.root;\n\t}\n\n\t@memoize get children(): Map<string, ExplorerItem> {\n\t\treturn new Map<string, ExplorerItem>();\n\t}\n\n\tprivate updateName(value: string): void {\n\t\t// Re-add to parent since the parent has a name map to children and the name might have changed\n\t\tthis._parent?.removeChild(this);\n\t\tthis._name = value;\n\t\tthis._parent?.addChild(this);\n\t}\n\n\tgetId(): string {\n\t\treturn this.root.resource.toString() + '::' + this.resource.toString();\n\t}\n\n\ttoString(): string {\n\t\treturn `ExplorerItem: ${this.name}`;\n\t}\n\n\tget isRoot(): boolean {\n\t\treturn this === this.root;\n\t}\n\n\tstatic create(fileService: IFileService, configService: IConfigurationService, filesConfigService: IFilesConfigurationService, raw: IFileStat, parent: ExplorerItem | undefined, resolveTo?: readonly URI[]): ExplorerItem {\n\t\tconst stat = new ExplorerItem(raw.resource, fileService, configService, filesConfigService, parent, raw.isDirectory, raw.isSymbolicLink, raw.readonly, raw.locked, raw.name, raw.mtime, !raw.isFile && !raw.isDirectory);\n\n\t\t// Recursively add children if present\n\t\tif (stat.isDirectory) {\n\n\t\t\t// isDirectoryResolved is a very important indicator in the stat model that tells if the folder was fully resolved\n\t\t\t// the folder is fully resolved if either it has a list of children or the client requested this by using the resolveTo\n\t\t\t// array of resource path to resolve.\n\t\t\tstat._isDirectoryResolved = !!raw.children || (!!resolveTo && resolveTo.some((r) => {\n\t\t\t\treturn isEqualOrParent(r, stat.resource);\n\t\t\t}));\n\n\t\t\t// Recurse into children\n\t\t\tif (raw.children) {\n\t\t\t\tfor (let i = 0, len = raw.children.length; i < len; i++) {\n\t\t\t\t\tconst child = ExplorerItem.create(fileService, configService, filesConfigService, raw.children[i], stat, resolveTo);\n\t\t\t\t\tstat.addChild(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn stat;\n\t}\n\n\t/**\n\t * Merges the stat which was resolved from the disk with the local stat by copying over properties\n\t * and children. The merge will only consider resolved stat elements to avoid overwriting data which\n\t * exists locally.\n\t */\n\tstatic mergeLocalWithDisk(disk: ExplorerItem, local: ExplorerItem): void {\n\t\tif (disk.resource.toString() !== local.resource.toString()) {\n\t\t\treturn; // Merging only supported for stats with the same resource\n\t\t}\n\n\t\t// Stop merging when a folder is not resolved to avoid loosing local data\n\t\tconst mergingDirectories = disk.isDirectory || local.isDirectory;\n\t\tif (mergingDirectories && local._isDirectoryResolved && !disk._isDirectoryResolved) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Properties\n\t\tlocal.resource = disk.resource;\n\t\tif (!local.isRoot) {\n\t\t\tlocal.updateName(disk.name);\n\t\t}\n\t\tlocal._isDirectory = disk.isDirectory;\n\t\tlocal._mtime = disk.mtime;\n\t\tlocal._isDirectoryResolved = disk._isDirectoryResolved;\n\t\tlocal._isSymbolicLink = disk.isSymbolicLink;\n\t\tlocal.error = disk.error;\n\n\t\t// Merge Children if resolved\n\t\tif (mergingDirectories && disk._isDirectoryResolved) {\n\n\t\t\t// Map resource => stat\n\t\t\tconst oldLocalChildren = new ResourceMap<ExplorerItem>();\n\t\t\tlocal.children.forEach(child => {\n\t\t\t\toldLocalChildren.set(child.resource, child);\n\t\t\t});\n\n\t\t\t// Clear current children\n\t\t\tlocal.children.clear();\n\n\t\t\t// Merge received children\n\t\t\tdisk.children.forEach(diskChild => {\n\t\t\t\tconst formerLocalChild = oldLocalChildren.get(diskChild.resource);\n\t\t\t\t// Existing child: merge\n\t\t\t\tif (formerLocalChild) {\n\t\t\t\t\tExplorerItem.mergeLocalWithDisk(diskChild, formerLocalChild);\n\t\t\t\t\tlocal.addChild(formerLocalChild);\n\t\t\t\t\toldLocalChildren.delete(diskChild.resource);\n\t\t\t\t}\n\n\t\t\t\t// New child: add\n\t\t\t\telse {\n\t\t\t\t\tlocal.addChild(diskChild);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\toldLocalChildren.forEach(oldChild => {\n\t\t\t\tif (oldChild instanceof NewExplorerItem) {\n\t\t\t\t\tlocal.addChild(oldChild);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Adds a child element to this folder.\n\t */\n\taddChild(child: ExplorerItem): void {\n\t\t// Inherit some parent properties to child\n\t\tchild._parent = this;\n\t\tchild.updateResource(false);\n\t\tthis.children.set(this.getPlatformAwareName(child.name), child);\n\t}\n\n\tgetChild(name: string): ExplorerItem | undefined {\n\t\treturn this.children.get(this.getPlatformAwareName(name));\n\t}\n\n\tfetchChildren(sortOrder: SortOrder): ExplorerItem[] | Promise<ExplorerItem[]> {\n\t\tconst nestingConfig = this.configService.getValue<IFilesConfiguration>({ resource: this.root.resource }).explorer.fileNesting;\n\n\t\t// fast path when the children can be resolved sync\n\t\tif (nestingConfig.enabled && this.nestedChildren) {\n\t\t\treturn this.nestedChildren;\n\t\t}\n\n\t\treturn (async () => {\n\t\t\tif (!this._isDirectoryResolved) {\n\t\t\t\t// Resolve metadata only when the mtime is needed since this can be expensive\n\t\t\t\t// Mtime is only used when the sort order is 'modified'\n\t\t\t\tconst resolveMetadata = sortOrder === SortOrder.Modified;\n\t\t\t\tthis.error = undefined;\n\t\t\t\ttry {\n\t\t\t\t\tconst stat = await this.fileService.resolve(this.resource, { resolveSingleChildDescendants: true, resolveMetadata });\n\t\t\t\t\tconst resolved = ExplorerItem.create(this.fileService, this.configService, this.filesConfigService, stat, this);\n\t\t\t\t\tExplorerItem.mergeLocalWithDisk(resolved, this);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthis.error = e;\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t\tthis._isDirectoryResolved = true;\n\t\t\t}\n\n\t\t\tconst items: ExplorerItem[] = [];\n\t\t\tif (nestingConfig.enabled) {\n\t\t\t\tconst fileChildren: [string, ExplorerItem][] = [];\n\t\t\t\tconst dirChildren: [string, ExplorerItem][] = [];\n\t\t\t\tfor (const child of this.children.entries()) {\n\t\t\t\t\tchild[1].nestedParent = undefined;\n\t\t\t\t\tif (child[1].isDirectory) {\n\t\t\t\t\t\tdirChildren.push(child);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfileChildren.push(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst nested = this.fileNester.nest(\n\t\t\t\t\tfileChildren.map(([name]) => name),\n\t\t\t\t\tthis.getPlatformAwareName(this.name));\n\n\t\t\t\tfor (const [fileEntryName, fileEntryItem] of fileChildren) {\n\t\t\t\t\tconst nestedItems = nested.get(fileEntryName);\n\t\t\t\t\tif (nestedItems !== undefined) {\n\t\t\t\t\t\tfileEntryItem.nestedChildren = [];\n\t\t\t\t\t\tfor (const name of nestedItems.keys()) {\n\t\t\t\t\t\t\tconst child = assertIsDefined(this.children.get(name));\n\t\t\t\t\t\t\tfileEntryItem.nestedChildren.push(child);\n\t\t\t\t\t\t\tchild.nestedParent = fileEntryItem;\n\t\t\t\t\t\t}\n\t\t\t\t\t\titems.push(fileEntryItem);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfileEntryItem.nestedChildren = undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (const [_, dirEntryItem] of dirChildren.values()) {\n\t\t\t\t\titems.push(dirEntryItem);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.children.forEach(child => {\n\t\t\t\t\titems.push(child);\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn items;\n\t\t})();\n\t}\n\n\tprivate _fileNester: ExplorerFileNestingTrie | undefined;\n\tprivate get fileNester(): ExplorerFileNestingTrie {\n\t\tif (!this.root._fileNester) {\n\t\t\tconst nestingConfig = this.configService.getValue<IFilesConfiguration>({ resource: this.root.resource }).explorer.fileNesting;\n\t\t\tconst patterns = Object.entries(nestingConfig.patterns)\n\t\t\t\t.filter(entry =>\n\t\t\t\t\ttypeof (entry[0]) === 'string' && typeof (entry[1]) === 'string' && entry[0] && entry[1])\n\t\t\t\t.map(([parentPattern, childrenPatterns]) =>\n\t\t\t\t\t[\n\t\t\t\t\t\tthis.getPlatformAwareName(parentPattern.trim()),\n\t\t\t\t\t\tchildrenPatterns.split(',').map(p => this.getPlatformAwareName(p.trim().replace(/\\u200b/g, '').trim()))\n\t\t\t\t\t\t\t.filter(p => p !== '')\n\t\t\t\t\t] as [string, string[]]);\n\n\t\t\tthis.root._fileNester = new ExplorerFileNestingTrie(patterns);\n\t\t}\n\t\treturn this.root._fileNester;\n\t}\n\n\t/**\n\t * Removes a child element from this folder.\n\t */\n\tremoveChild(child: ExplorerItem): void {\n\t\tthis.nestedChildren = undefined;\n\t\tthis.children.delete(this.getPlatformAwareName(child.name));\n\t}\n\n\tforgetChildren(): void {\n\t\tthis.children.clear();\n\t\tthis.nestedChildren = undefined;\n\t\tthis._isDirectoryResolved = false;\n\t\tthis._fileNester = undefined;\n\t}\n\n\tprivate getPlatformAwareName(name: string): string {\n\t\treturn this.fileService.hasCapability(this.resource, FileSystemProviderCapabilities.PathCaseSensitive) ? name : name.toLowerCase();\n\t}\n\n\t/**\n\t * Moves this element under a new parent element.\n\t */\n\tmove(newParent: ExplorerItem): void {\n\t\tthis.nestedParent?.removeChild(this);\n\t\tthis._parent?.removeChild(this);\n\t\tnewParent.removeChild(this); // make sure to remove any previous version of the file if any\n\t\tnewParent.addChild(this);\n\t\tthis.updateResource(true);\n\t}\n\n\tprivate updateResource(recursive: boolean): void {\n\t\tif (this._parent) {\n\t\t\tthis.resource = joinPath(this._parent.resource, this.name);\n\t\t}\n\n\t\tif (recursive) {\n\t\t\tif (this.isDirectory) {\n\t\t\t\tthis.children.forEach(child => {\n\t\t\t\t\tchild.updateResource(true);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Tells this stat that it was renamed. This requires changes to all children of this stat (if any)\n\t * so that the path property can be updated properly.\n\t */\n\trename(renamedStat: { name: string; mtime?: number }): void {\n\n\t\t// Merge a subset of Properties that can change on rename\n\t\tthis.updateName(renamedStat.name);\n\t\tthis._mtime = renamedStat.mtime;\n\n\t\t// Update Paths including children\n\t\tthis.updateResource(true);\n\t}\n\n\t/**\n\t * Returns a child stat from this stat that matches with the provided path.\n\t * Will return \"null\" in case the child does not exist.\n\t */\n\tfind(resource: URI): ExplorerItem | null {\n\t\t// Return if path found\n\t\t// For performance reasons try to do the comparison as fast as possible\n\t\tconst ignoreCase = !this.fileService.hasCapability(resource, FileSystemProviderCapabilities.PathCaseSensitive);\n\t\tif (resource && this.resource.scheme === resource.scheme && equalsIgnoreCase(this.resource.authority, resource.authority) &&\n\t\t\t(ignoreCase ? startsWithIgnoreCase(resource.path, this.resource.path) : resource.path.startsWith(this.resource.path))) {\n\t\t\treturn this.findByPath(rtrim(resource.path, posix.sep), this.resource.path.length, ignoreCase);\n\t\t}\n\n\t\treturn null; //Unable to find\n\t}\n\n\tprivate findByPath(path: string, index: number, ignoreCase: boolean): ExplorerItem | null {\n\t\tif (isEqual(rtrim(this.resource.path, posix.sep), path, ignoreCase)) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif (this.isDirectory) {\n\t\t\t// Ignore separtor to more easily deduct the next name to search\n\t\t\twhile (index < path.length && path[index] === posix.sep) {\n\t\t\t\tindex++;\n\t\t\t}\n\n\t\t\tlet indexOfNextSep = path.indexOf(posix.sep, index);\n\t\t\tif (indexOfNextSep === -1) {\n\t\t\t\t// If there is no separator take the remainder of the path\n\t\t\t\tindexOfNextSep = path.length;\n\t\t\t}\n\t\t\t// The name to search is between two separators\n\t\t\tconst name = path.substring(index, indexOfNextSep);\n\n\t\t\tconst child = this.children.get(this.getPlatformAwareName(name));\n\n\t\t\tif (child) {\n\t\t\t\t// We found a child with the given name, search inside it\n\t\t\t\treturn child.findByPath(path, indexOfNextSep, ignoreCase);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n}\n\nexport class NewExplorerItem extends ExplorerItem {\n\tconstructor(fileService: IFileService, configService: IConfigurationService, filesConfigService: IFilesConfigurationService, parent: ExplorerItem, isDirectory: boolean) {\n\t\tsuper(URI.file(''), fileService, configService, filesConfigService, parent, isDirectory);\n\t\tthis._isDirectoryResolved = true;\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
