{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/webviewView/browser/webviewViewService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { promiseWithResolvers } from '../../../../base/common/async.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { Disposable, IDisposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IViewBadge } from '../../../common/views.js';\nimport { IOverlayWebview } from '../../webview/browser/webview.js';\n\n/**\n * A webview shown in a view pane.\n */\nexport interface WebviewView {\n\t/**\n\t * The text displayed in the view's title.\n\t */\n\ttitle?: string;\n\n\t/**\n\t * Additional text shown for this view.\n\t */\n\tdescription?: string;\n\n\t/**\n\t * The badge shown for this view.\n\t */\n\tbadge?: IViewBadge;\n\n\t/**\n\t * The webview associated with this webview view.\n\t */\n\treadonly webview: IOverlayWebview;\n\n\t/**\n\t * Fired when the visibility of the webview view changes.\n\t *\n\t * This can happen when the view itself is hidden, when the view is collapsed, or when the user switches away from\n\t * the view.\n\t */\n\treadonly onDidChangeVisibility: Event<boolean>;\n\n\t/**\n\t * Fired when the webview view has been disposed of.\n\t */\n\treadonly onDispose: Event<void>;\n\n\t/**\n\t * Dispose of the webview view and clean up any associated resources.\n\t */\n\tdispose(): void;\n\n\t/**\n\t * Force the webview view to show.\n\t */\n\tshow(preserveFocus: boolean): void;\n}\n\n/**\n * Fill in the contents of a newly created webview view.\n */\ninterface IWebviewViewResolver {\n\t/**\n\t * Fill in the contents of a webview view.\n\t */\n\tresolve(webviewView: WebviewView, cancellation: CancellationToken): Promise<void>;\n}\n\nexport const IWebviewViewService = createDecorator<IWebviewViewService>('webviewViewService');\n\nexport interface IWebviewViewService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Fired when a resolver has been registered\n\t */\n\treadonly onNewResolverRegistered: Event<{ readonly viewType: string }>;\n\n\t/**\n\t * Register a new {@link IWebviewViewResolver webview view resolver}.\n\t */\n\tregister(viewType: string, resolver: IWebviewViewResolver): IDisposable;\n\n\t/**\n\t * Try to resolve a webview view. The promise will not resolve until a resolver for the webview has been registered\n\t * and run\n\t */\n\tresolve(viewType: string, webview: WebviewView, cancellation: CancellationToken): Promise<void>;\n}\n\nexport class WebviewViewService extends Disposable implements IWebviewViewService {\n\n\treadonly _serviceBrand: undefined;\n\n\tprivate readonly _resolvers = new Map<string, IWebviewViewResolver>();\n\n\tprivate readonly _awaitingRevival = new Map<string, { readonly webview: WebviewView; readonly resolve: () => void }>();\n\n\tprivate readonly _onNewResolverRegistered = this._register(new Emitter<{ readonly viewType: string }>());\n\tpublic readonly onNewResolverRegistered = this._onNewResolverRegistered.event;\n\n\tregister(viewType: string, resolver: IWebviewViewResolver): IDisposable {\n\t\tif (this._resolvers.has(viewType)) {\n\t\t\tthrow new Error(`View resolver already registered for ${viewType}`);\n\t\t}\n\n\t\tthis._resolvers.set(viewType, resolver);\n\t\tthis._onNewResolverRegistered.fire({ viewType: viewType });\n\n\t\tconst pending = this._awaitingRevival.get(viewType);\n\t\tif (pending) {\n\t\t\tresolver.resolve(pending.webview, CancellationToken.None).then(() => {\n\t\t\t\tthis._awaitingRevival.delete(viewType);\n\t\t\t\tpending.resolve();\n\t\t\t});\n\t\t}\n\n\t\treturn toDisposable(() => {\n\t\t\tthis._resolvers.delete(viewType);\n\t\t});\n\t}\n\n\tresolve(viewType: string, webview: WebviewView, cancellation: CancellationToken): Promise<void> {\n\t\tconst resolver = this._resolvers.get(viewType);\n\t\tif (!resolver) {\n\t\t\tif (this._awaitingRevival.has(viewType)) {\n\t\t\t\tthrow new Error('View already awaiting revival');\n\t\t\t}\n\n\t\t\tconst { promise, resolve } = promiseWithResolvers<void>();\n\t\t\tthis._awaitingRevival.set(viewType, { webview, resolve });\n\t\t\treturn promise;\n\t\t}\n\n\t\treturn resolver.resolve(webview, cancellation);\n\t}\n}\n"],
  "mappings": ";;AAKA,SAAS,4BAA4B;AACrC,SAAS,yBAAyB;AAClC,SAAS,SAAS,aAAa;AAC/B,SAAS,YAAY,aAAa,oBAAoB;AACtD,SAAS,uBAAuB;AAChC,SAAS,kBAAkB;AAC3B,SAAS,uBAAuB;AA4DzB,MAAM,sBAAsB,gBAAqC,oBAAoB;AAuBrF,MAAM,2BAA2B,WAA0C;AAAA,EA9FlF,OA8FkF;AAAA;AAAA;AAAA,EAExE;AAAA,EAEQ,aAAa,oBAAI,IAAkC;AAAA,EAEnD,mBAAmB,oBAAI,IAA6E;AAAA,EAEpG,2BAA2B,KAAK,UAAU,IAAI,QAAuC,CAAC;AAAA,EACvF,0BAA0B,KAAK,yBAAyB;AAAA,EAExE,SAAS,UAAkB,UAA6C;AACvE,QAAI,KAAK,WAAW,IAAI,QAAQ,GAAG;AAClC,YAAM,IAAI,MAAM,wCAAwC,QAAQ,EAAE;AAAA,IACnE;AAEA,SAAK,WAAW,IAAI,UAAU,QAAQ;AACtC,SAAK,yBAAyB,KAAK,EAAE,SAAmB,CAAC;AAEzD,UAAM,UAAU,KAAK,iBAAiB,IAAI,QAAQ;AAClD,QAAI,SAAS;AACZ,eAAS,QAAQ,QAAQ,SAAS,kBAAkB,IAAI,EAAE,KAAK,MAAM;AACpE,aAAK,iBAAiB,OAAO,QAAQ;AACrC,gBAAQ,QAAQ;AAAA,MACjB,CAAC;AAAA,IACF;AAEA,WAAO,aAAa,MAAM;AACzB,WAAK,WAAW,OAAO,QAAQ;AAAA,IAChC,CAAC;AAAA,EACF;AAAA,EAEA,QAAQ,UAAkB,SAAsB,cAAgD;AAC/F,UAAM,WAAW,KAAK,WAAW,IAAI,QAAQ;AAC7C,QAAI,CAAC,UAAU;AACd,UAAI,KAAK,iBAAiB,IAAI,QAAQ,GAAG;AACxC,cAAM,IAAI,MAAM,+BAA+B;AAAA,MAChD;AAEA,YAAM,EAAE,SAAS,QAAQ,IAAI,qBAA2B;AACxD,WAAK,iBAAiB,IAAI,UAAU,EAAE,SAAS,QAAQ,CAAC;AACxD,aAAO;AAAA,IACR;AAEA,WAAO,SAAS,QAAQ,SAAS,YAAY;AAAA,EAC9C;AACD;",
  "names": []
}
