{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/webviewView/browser/webviewViewService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { promiseWithResolvers } from \"../../../../base/common/async.js\";\nimport { CancellationToken } from \"../../../../base/common/cancellation.js\";\nimport { Emitter, type Event } from \"../../../../base/common/event.js\";\nimport {\n\tDisposable,\n\ttype IDisposable,\n\ttoDisposable,\n} from \"../../../../base/common/lifecycle.js\";\nimport { createDecorator } from \"../../../../platform/instantiation/common/instantiation.js\";\nimport type { IViewBadge } from \"../../../common/views.js\";\nimport type { IOverlayWebview } from \"../../webview/browser/webview.js\";\n\n/**\n * A webview shown in a view pane.\n */\nexport interface WebviewView {\n\t/**\n\t * The text displayed in the view's title.\n\t */\n\ttitle?: string;\n\n\t/**\n\t * Additional text shown for this view.\n\t */\n\tdescription?: string;\n\n\t/**\n\t * The badge shown for this view.\n\t */\n\tbadge?: IViewBadge;\n\n\t/**\n\t * The webview associated with this webview view.\n\t */\n\treadonly webview: IOverlayWebview;\n\n\t/**\n\t * Fired when the visibility of the webview view changes.\n\t *\n\t * This can happen when the view itself is hidden, when the view is collapsed, or when the user switches away from\n\t * the view.\n\t */\n\treadonly onDidChangeVisibility: Event<boolean>;\n\n\t/**\n\t * Fired when the webview view has been disposed of.\n\t */\n\treadonly onDispose: Event<void>;\n\n\t/**\n\t * Dispose of the webview view and clean up any associated resources.\n\t */\n\tdispose(): void;\n\n\t/**\n\t * Force the webview view to show.\n\t */\n\tshow(preserveFocus: boolean): void;\n}\n\n/**\n * Fill in the contents of a newly created webview view.\n */\ninterface IWebviewViewResolver {\n\t/**\n\t * Fill in the contents of a webview view.\n\t */\n\tresolve(\n\t\twebviewView: WebviewView,\n\t\tcancellation: CancellationToken,\n\t): Promise<void>;\n}\n\nexport const IWebviewViewService =\n\tcreateDecorator<IWebviewViewService>(\"webviewViewService\");\n\nexport interface IWebviewViewService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Fired when a resolver has been registered\n\t */\n\treadonly onNewResolverRegistered: Event<{ readonly viewType: string }>;\n\n\t/**\n\t * Register a new {@link IWebviewViewResolver webview view resolver}.\n\t */\n\tregister(viewType: string, resolver: IWebviewViewResolver): IDisposable;\n\n\t/**\n\t * Try to resolve a webview view. The promise will not resolve until a resolver for the webview has been registered\n\t * and run\n\t */\n\tresolve(\n\t\tviewType: string,\n\t\twebview: WebviewView,\n\t\tcancellation: CancellationToken,\n\t): Promise<void>;\n}\n\nexport class WebviewViewService\n\textends Disposable\n\timplements IWebviewViewService\n{\n\treadonly _serviceBrand: undefined;\n\n\tprivate readonly _resolvers = new Map<string, IWebviewViewResolver>();\n\n\tprivate readonly _awaitingRevival = new Map<\n\t\tstring,\n\t\t{ readonly webview: WebviewView; readonly resolve: () => void }\n\t>();\n\n\tprivate readonly _onNewResolverRegistered = this._register(\n\t\tnew Emitter<{ readonly viewType: string }>(),\n\t);\n\tpublic readonly onNewResolverRegistered =\n\t\tthis._onNewResolverRegistered.event;\n\n\tregister(viewType: string, resolver: IWebviewViewResolver): IDisposable {\n\t\tif (this._resolvers.has(viewType)) {\n\t\t\tthrow new Error(`View resolver already registered for ${viewType}`);\n\t\t}\n\n\t\tthis._resolvers.set(viewType, resolver);\n\t\tthis._onNewResolverRegistered.fire({ viewType: viewType });\n\n\t\tconst pending = this._awaitingRevival.get(viewType);\n\t\tif (pending) {\n\t\t\tresolver\n\t\t\t\t.resolve(pending.webview, CancellationToken.None)\n\t\t\t\t.then(() => {\n\t\t\t\t\tthis._awaitingRevival.delete(viewType);\n\t\t\t\t\tpending.resolve();\n\t\t\t\t});\n\t\t}\n\n\t\treturn toDisposable(() => {\n\t\t\tthis._resolvers.delete(viewType);\n\t\t});\n\t}\n\n\tresolve(\n\t\tviewType: string,\n\t\twebview: WebviewView,\n\t\tcancellation: CancellationToken,\n\t): Promise<void> {\n\t\tconst resolver = this._resolvers.get(viewType);\n\t\tif (!resolver) {\n\t\t\tif (this._awaitingRevival.has(viewType)) {\n\t\t\t\tthrow new Error(\"View already awaiting revival\");\n\t\t\t}\n\n\t\t\tconst { promise, resolve } = promiseWithResolvers<void>();\n\t\t\tthis._awaitingRevival.set(viewType, { webview, resolve });\n\t\t\treturn promise;\n\t\t}\n\n\t\treturn resolver.resolve(webview, cancellation);\n\t}\n}\n"],
  "mappings": ";;AAKA,SAAS,4BAA4B;AACrC,SAAS,yBAAyB;AAClC,SAAS,eAA2B;AACpC;AAAA,EACC;AAAA,EAEA;AAAA,OACM;AACP,SAAS,uBAAuB;AAiEzB,MAAM,sBACZ,gBAAqC,oBAAoB;AA0BnD,MAAM,2BACJ,WAET;AAAA,EA5GA,OA4GA;AAAA;AAAA;AAAA,EACU;AAAA,EAEQ,aAAa,oBAAI,IAAkC;AAAA,EAEnD,mBAAmB,oBAAI,IAGtC;AAAA,EAEe,2BAA2B,KAAK;AAAA,IAChD,IAAI,QAAuC;AAAA,EAC5C;AAAA,EACgB,0BACf,KAAK,yBAAyB;AAAA,EAE/B,SAAS,UAAkB,UAA6C;AACvE,QAAI,KAAK,WAAW,IAAI,QAAQ,GAAG;AAClC,YAAM,IAAI,MAAM,wCAAwC,QAAQ,EAAE;AAAA,IACnE;AAEA,SAAK,WAAW,IAAI,UAAU,QAAQ;AACtC,SAAK,yBAAyB,KAAK,EAAE,SAAmB,CAAC;AAEzD,UAAM,UAAU,KAAK,iBAAiB,IAAI,QAAQ;AAClD,QAAI,SAAS;AACZ,eACE,QAAQ,QAAQ,SAAS,kBAAkB,IAAI,EAC/C,KAAK,MAAM;AACX,aAAK,iBAAiB,OAAO,QAAQ;AACrC,gBAAQ,QAAQ;AAAA,MACjB,CAAC;AAAA,IACH;AAEA,WAAO,aAAa,MAAM;AACzB,WAAK,WAAW,OAAO,QAAQ;AAAA,IAChC,CAAC;AAAA,EACF;AAAA,EAEA,QACC,UACA,SACA,cACgB;AAChB,UAAM,WAAW,KAAK,WAAW,IAAI,QAAQ;AAC7C,QAAI,CAAC,UAAU;AACd,UAAI,KAAK,iBAAiB,IAAI,QAAQ,GAAG;AACxC,cAAM,IAAI,MAAM,+BAA+B;AAAA,MAChD;AAEA,YAAM,EAAE,SAAS,QAAQ,IAAI,qBAA2B;AACxD,WAAK,iBAAiB,IAAI,UAAU,EAAE,SAAS,QAAQ,CAAC;AACxD,aAAO;AAAA,IACR;AAEA,WAAO,SAAS,QAAQ,SAAS,YAAY;AAAA,EAC9C;AACD;",
  "names": []
}
