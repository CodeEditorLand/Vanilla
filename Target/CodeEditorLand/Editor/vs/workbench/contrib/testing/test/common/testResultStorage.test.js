import m from"assert";import{range as a}from"../../../../../base/common/arrays.js";import{DisposableStore as l}from"../../../../../base/common/lifecycle.js";import{ensureNoDisposablesAreLeakedInTestSuite as d}from"../../../../../base/test/common/utils.js";import{NullLogService as c}from"../../../../../platform/log/common/log.js";import{NullTelemetryService as p}from"../../../../../platform/telemetry/common/telemetryUtils.js";import"../../../../../platform/uriIdentity/common/uriIdentity.js";import{LiveTestResult as u}from"../../common/testResult.js";import{InMemoryResultStorage as w,RETAIN_MAX_RESULTS as g}from"../../common/testResultStorage.js";import{TestRunProfileBitset as y}from"../../common/testTypes.js";import{testStubs as I}from"./testStubs.js";import{TestStorageService as S}from"../../../../test/common/workbenchTestServices.js";suite("Workbench - Test Result Storage",()=>{let s,i;const r=(t="t")=>{const e=i.add(new u("",!0,{targets:[],group:y.Run},p));e.addTask({id:t,name:"n",running:!0,ctrlId:"ctrlId"});const n=i.add(I.nested());return n.expand(n.root.id,1/0),e.addTestChainToRun("ctrlId",[n.root.toTestItem(),n.root.children.get("id-a").toTestItem(),n.root.children.get("id-a").children.get("id-aa").toTestItem()]),e.markComplete(),e},o=async t=>m.deepStrictEqual((await s.read()).map(e=>e.id),t.map(e=>e.id));setup(async()=>{i=new l,s=i.add(new w({asCanonicalUri(t){return t}},i.add(new S),new c))}),teardown(()=>i.dispose()),d(),test("stores a single result",async()=>{const t=a(5).map(()=>r());await s.persist(t),await o(t)}),test("deletes old results",async()=>{const t=a(5).map(()=>r());await s.persist(t);const e=[r(),...t.slice(0,3)];await s.persist(e),await o(e)}),test("limits stored results",async()=>{const t=a(100).map(()=>r());await s.persist(t),await o(t.slice(0,g))}),test("limits stored result by budget",async()=>{const t=a(100).map(()=>r("a".repeat(2048)));await s.persist(t);const e=(await s.read()).length;m.strictEqual(!0,e<50)}),test("always stores the min number of results",async()=>{const t=a(20).map(()=>r("a".repeat(10240)));await s.persist(t),await o(t.slice(0,16))}),test("takes into account existing stored bytes",async()=>{const t=a(10).map(()=>r("a".repeat(10240)));await s.persist(t),await o(t);const e=[...t,...a(10).map(()=>r("a".repeat(1024*10)))];await s.persist(e),await o(e.slice(0,16))})});
