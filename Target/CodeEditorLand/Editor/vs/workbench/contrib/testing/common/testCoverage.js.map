{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/testing/common/testCoverage.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from \"../../../../base/common/cancellation.js\";\nimport { ResourceMap } from \"../../../../base/common/map.js\";\nimport { deepClone } from \"../../../../base/common/objects.js\";\nimport {\n\ttype ITransaction,\n\tobservableSignal,\n} from \"../../../../base/common/observable.js\";\nimport {\n\ttype IPrefixTreeNode,\n\tWellDefinedPrefixTree,\n} from \"../../../../base/common/prefixTree.js\";\nimport { URI } from \"../../../../base/common/uri.js\";\nimport type { IUriIdentityService } from \"../../../../platform/uriIdentity/common/uriIdentity.js\";\nimport type { TestId } from \"./testId.js\";\nimport type { LiveTestResult } from \"./testResult.js\";\nimport {\n\ttype CoverageDetails,\n\tDetailType,\n\tICoverageCount,\n\ttype IFileCoverage,\n} from \"./testTypes.js\";\n\nexport interface ICoverageAccessor {\n\tgetCoverageDetails: (\n\t\tid: string,\n\t\ttestId: string | undefined,\n\t\ttoken: CancellationToken,\n\t) => Promise<CoverageDetails[]>;\n}\n\nlet incId = 0;\n\n/**\n * Class that exposese coverage information for a run.\n */\nexport class TestCoverage {\n\tprivate readonly fileCoverage = new ResourceMap<FileCoverage>();\n\tpublic readonly didAddCoverage =\n\t\tobservableSignal<IPrefixTreeNode<AbstractFileCoverage>[]>(this);\n\tpublic readonly tree = new WellDefinedPrefixTree<AbstractFileCoverage>();\n\tpublic readonly associatedData = new Map<unknown, unknown>();\n\n\tconstructor(\n\t\tpublic readonly result: LiveTestResult,\n\t\tpublic readonly fromTaskId: string,\n\t\tprivate readonly uriIdentityService: IUriIdentityService,\n\t\tprivate readonly accessor: ICoverageAccessor,\n\t) {}\n\n\t/** Gets all test IDs that were included in this test run. */\n\tpublic *allPerTestIDs() {\n\t\tconst seen = new Set<string>();\n\t\tfor (const root of this.tree.nodes) {\n\t\t\tif (root.value && root.value.perTestData) {\n\t\t\t\tfor (const id of root.value.perTestData) {\n\t\t\t\t\tif (!seen.has(id)) {\n\t\t\t\t\t\tseen.add(id);\n\t\t\t\t\t\tyield id;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic append(coverage: IFileCoverage, tx: ITransaction | undefined) {\n\t\tconst previous = this.getComputedForUri(coverage.uri);\n\t\tconst result = this.result;\n\t\tconst applyDelta = (\n\t\t\tkind: \"statement\" | \"branch\" | \"declaration\",\n\t\t\tnode: ComputedFileCoverage,\n\t\t) => {\n\t\t\tif (node[kind]) {\n\t\t\t\tnode[kind]!.covered +=\n\t\t\t\t\t(coverage[kind]?.covered || 0) -\n\t\t\t\t\t(previous?.[kind]?.covered || 0);\n\t\t\t\tnode[kind]!.total +=\n\t\t\t\t\t(coverage[kind]?.total || 0) -\n\t\t\t\t\t(previous?.[kind]?.total || 0);\n\t\t\t} else if (coverage[kind]) {\n\t\t\t\tnode[kind] = { ...coverage[kind]! };\n\t\t\t}\n\t\t};\n\n\t\t// We insert using the non-canonical path to normalize for casing differences\n\t\t// between URIs, but when inserting an intermediate node always use 'a' canonical\n\t\t// version.\n\t\tconst canonical = [\n\t\t\t...this.treePathForUri(coverage.uri, /* canonical = */ true),\n\t\t];\n\t\tconst chain: IPrefixTreeNode<AbstractFileCoverage>[] = [];\n\n\t\tthis.tree.mutatePath(\n\t\t\tthis.treePathForUri(coverage.uri, /* canonical = */ false),\n\t\t\t(node) => {\n\t\t\t\tchain.push(node);\n\n\t\t\t\tif (chain.length === canonical.length) {\n\t\t\t\t\t// we reached our destination node, apply the coverage as necessary:\n\t\t\t\t\tif (node.value) {\n\t\t\t\t\t\tconst v = node.value;\n\t\t\t\t\t\t// if ID was generated from a test-specific coverage, reassign it to get its real ID in the extension host.\n\t\t\t\t\t\tv.id = coverage.id;\n\t\t\t\t\t\tv.statement = coverage.statement;\n\t\t\t\t\t\tv.branch = coverage.branch;\n\t\t\t\t\t\tv.declaration = coverage.declaration;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst v = (node.value = new FileCoverage(\n\t\t\t\t\t\t\tcoverage,\n\t\t\t\t\t\t\tresult,\n\t\t\t\t\t\t\tthis.accessor,\n\t\t\t\t\t\t));\n\t\t\t\t\t\tthis.fileCoverage.set(coverage.uri, v);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Otherwise, if this is not a partial per-test coverage, merge the\n\t\t\t\t\t// coverage changes into the chain. Per-test coverages are not complete\n\t\t\t\t\t// and we don't want to consider them for computation.\n\t\t\t\t\tif (node.value) {\n\t\t\t\t\t\tapplyDelta(\"statement\", node.value);\n\t\t\t\t\t\tapplyDelta(\"branch\", node.value);\n\t\t\t\t\t\tapplyDelta(\"declaration\", node.value);\n\t\t\t\t\t\tnode.value.didChange.trigger(tx);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// clone because later intersertions can modify the counts:\n\t\t\t\t\t\tconst intermediate = deepClone(coverage);\n\t\t\t\t\t\tintermediate.id = String(incId++);\n\t\t\t\t\t\tintermediate.uri = this.treePathToUri(\n\t\t\t\t\t\t\tcanonical.slice(0, chain.length),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tnode.value = new ComputedFileCoverage(\n\t\t\t\t\t\t\tintermediate,\n\t\t\t\t\t\t\tresult,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (coverage.testIds) {\n\t\t\t\t\tnode.value!.perTestData ??= new Set();\n\t\t\t\t\tfor (const id of coverage.testIds) {\n\t\t\t\t\t\tnode.value!.perTestData.add(id);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t);\n\n\t\tif (chain) {\n\t\t\tthis.didAddCoverage.trigger(tx, chain);\n\t\t}\n\t}\n\n\t/**\n\t * Builds a new tree filtered to per-test coverage data for the given ID.\n\t */\n\tpublic filterTreeForTest(testId: TestId) {\n\t\tconst tree = new WellDefinedPrefixTree<AbstractFileCoverage>();\n\t\tfor (const node of this.tree.values()) {\n\t\t\tif (node instanceof FileCoverage) {\n\t\t\t\tif (!node.perTestData?.has(testId.toString())) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst canonical = [\n\t\t\t\t\t...this.treePathForUri(node.uri, /* canonical = */ true),\n\t\t\t\t];\n\t\t\t\tconst chain: IPrefixTreeNode<AbstractFileCoverage>[] = [];\n\t\t\t\ttree.mutatePath(\n\t\t\t\t\tthis.treePathForUri(node.uri, /* canonical = */ false),\n\t\t\t\t\t(n) => {\n\t\t\t\t\t\tchain.push(n);\n\t\t\t\t\t\tn.value ??= new BypassedFileCoverage(\n\t\t\t\t\t\t\tthis.treePathToUri(\n\t\t\t\t\t\t\t\tcanonical.slice(0, chain.length),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tnode.fromResult,\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn tree;\n\t}\n\n\t/**\n\t * Gets coverage information for all files.\n\t */\n\tpublic getAllFiles() {\n\t\treturn this.fileCoverage;\n\t}\n\n\t/**\n\t * Gets coverage information for a specific file.\n\t */\n\tpublic getUri(uri: URI) {\n\t\treturn this.fileCoverage.get(uri);\n\t}\n\n\t/**\n\t * Gets computed information for a file, including DFS-computed information\n\t * from child tests.\n\t */\n\tpublic getComputedForUri(uri: URI) {\n\t\treturn this.tree.find(\n\t\t\tthis.treePathForUri(uri, /* canonical = */ false),\n\t\t);\n\t}\n\n\tprivate *treePathForUri(uri: URI, canconicalPath: boolean) {\n\t\tyield uri.scheme;\n\t\tyield uri.authority;\n\n\t\tconst path =\n\t\t\t!canconicalPath &&\n\t\t\tthis.uriIdentityService.extUri.ignorePathCasing(uri)\n\t\t\t\t? uri.path.toLowerCase()\n\t\t\t\t: uri.path;\n\t\tyield* path.split(\"/\");\n\t}\n\n\tprivate treePathToUri(path: string[]) {\n\t\treturn URI.from({\n\t\t\tscheme: path[0],\n\t\t\tauthority: path[1],\n\t\t\tpath: path.slice(2).join(\"/\"),\n\t\t});\n\t}\n}\n\nexport const getTotalCoveragePercent = (\n\tstatement: ICoverageCount,\n\tbranch: ICoverageCount | undefined,\n\tfunction_: ICoverageCount | undefined,\n) => {\n\tlet numerator = statement.covered;\n\tlet denominator = statement.total;\n\n\tif (branch) {\n\t\tnumerator += branch.covered;\n\t\tdenominator += branch.total;\n\t}\n\n\tif (function_) {\n\t\tnumerator += function_.covered;\n\t\tdenominator += function_.total;\n\t}\n\n\treturn denominator === 0 ? 1 : numerator / denominator;\n};\n\nexport abstract class AbstractFileCoverage {\n\tpublic id: string;\n\tpublic readonly uri: URI;\n\tpublic statement: ICoverageCount;\n\tpublic branch?: ICoverageCount;\n\tpublic declaration?: ICoverageCount;\n\tpublic readonly didChange = observableSignal(this);\n\n\t/**\n\t * Gets the total coverage percent based on information provided.\n\t * This is based on the Clover total coverage formula\n\t */\n\tpublic get tpc() {\n\t\treturn getTotalCoveragePercent(\n\t\t\tthis.statement,\n\t\t\tthis.branch,\n\t\t\tthis.declaration,\n\t\t);\n\t}\n\n\t/**\n\t * Per-test coverage data for this file, if available.\n\t */\n\tpublic perTestData?: Set<string>;\n\n\tconstructor(\n\t\tcoverage: IFileCoverage,\n\t\tpublic readonly fromResult: LiveTestResult,\n\t) {\n\t\tthis.id = coverage.id;\n\t\tthis.uri = coverage.uri;\n\t\tthis.statement = coverage.statement;\n\t\tthis.branch = coverage.branch;\n\t\tthis.declaration = coverage.declaration;\n\t}\n}\n\n/**\n * File coverage info computed from children in the tree, not provided by the\n * extension.\n */\nexport class ComputedFileCoverage extends AbstractFileCoverage {}\n\n/**\n * A virtual node that doesn't have any added coverage info.\n */\nexport class BypassedFileCoverage extends ComputedFileCoverage {\n\tconstructor(uri: URI, result: LiveTestResult) {\n\t\tsuper(\n\t\t\t{ id: String(incId++), uri, statement: { covered: 0, total: 0 } },\n\t\t\tresult,\n\t\t);\n\t}\n}\n\nexport class FileCoverage extends AbstractFileCoverage {\n\tprivate _details?: Promise<CoverageDetails[]>;\n\tprivate resolved?: boolean;\n\tprivate _detailsForTest?: Map<string, Promise<CoverageDetails[]>>;\n\n\t/** Gets whether details are synchronously available */\n\tpublic get hasSynchronousDetails() {\n\t\treturn this._details instanceof Array || this.resolved;\n\t}\n\n\tconstructor(\n\t\tcoverage: IFileCoverage,\n\t\tfromResult: LiveTestResult,\n\t\tprivate readonly accessor: ICoverageAccessor,\n\t) {\n\t\tsuper(coverage, fromResult);\n\t}\n\n\t/**\n\t * Gets per-line coverage details.\n\t */\n\tpublic async detailsForTest(\n\t\t_testId: TestId,\n\t\ttoken = CancellationToken.None,\n\t) {\n\t\tthis._detailsForTest ??= new Map();\n\t\tconst testId = _testId.toString();\n\t\tconst prev = this._detailsForTest.get(testId);\n\t\tif (prev) {\n\t\t\treturn prev;\n\t\t}\n\n\t\tconst promise = (async () => {\n\t\t\ttry {\n\t\t\t\treturn await this.accessor.getCoverageDetails(\n\t\t\t\t\tthis.id,\n\t\t\t\t\ttestId,\n\t\t\t\t\ttoken,\n\t\t\t\t);\n\t\t\t} catch (e) {\n\t\t\t\tthis._detailsForTest?.delete(testId);\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t})();\n\n\t\tthis._detailsForTest.set(testId, promise);\n\t\treturn promise;\n\t}\n\n\t/**\n\t * Gets per-line coverage details.\n\t */\n\tpublic async details(token = CancellationToken.None) {\n\t\tthis._details ??= this.accessor.getCoverageDetails(\n\t\t\tthis.id,\n\t\t\tundefined,\n\t\t\ttoken,\n\t\t);\n\n\t\ttry {\n\t\t\tconst d = await this._details;\n\t\t\tthis.resolved = true;\n\t\t\treturn d;\n\t\t} catch (e) {\n\t\t\tthis._details = undefined;\n\t\t\tthrow e;\n\t\t}\n\t}\n}\n\nexport const totalFromCoverageDetails = (\n\turi: URI,\n\tdetails: CoverageDetails[],\n): IFileCoverage => {\n\tconst fc: IFileCoverage = {\n\t\tid: \"\",\n\t\turi,\n\t\tstatement: ICoverageCount.empty(),\n\t};\n\n\tfor (const detail of details) {\n\t\tif (detail.type === DetailType.Statement) {\n\t\t\tfc.statement.total++;\n\t\t\tfc.statement.total += detail.count ? 1 : 0;\n\n\t\t\tfor (const branch of detail.branches || []) {\n\t\t\t\tfc.branch ??= ICoverageCount.empty();\n\t\t\t\tfc.branch.total++;\n\t\t\t\tfc.branch.covered += branch.count ? 1 : 0;\n\t\t\t}\n\t\t} else {\n\t\t\tfc.declaration ??= ICoverageCount.empty();\n\t\t\tfc.declaration.total++;\n\t\t\tfc.declaration.covered += detail.count ? 1 : 0;\n\t\t}\n\t}\n\n\treturn fc;\n};\n"],
  "mappings": "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",
  "names": []
}
