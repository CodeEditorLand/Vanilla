{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/testing/common/testCoverage.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { ResourceMap } from '../../../../base/common/map.js';\nimport { deepClone } from '../../../../base/common/objects.js';\nimport { ITransaction, observableSignal } from '../../../../base/common/observable.js';\nimport { IPrefixTreeNode, WellDefinedPrefixTree } from '../../../../base/common/prefixTree.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IUriIdentityService } from '../../../../platform/uriIdentity/common/uriIdentity.js';\nimport { TestId } from './testId.js';\nimport { LiveTestResult } from './testResult.js';\nimport { CoverageDetails, DetailType, ICoverageCount, IFileCoverage } from './testTypes.js';\n\nexport interface ICoverageAccessor {\n\tgetCoverageDetails: (id: string, testId: string | undefined, token: CancellationToken) => Promise<CoverageDetails[]>;\n}\n\nlet incId = 0;\n\n/**\n * Class that exposese coverage information for a run.\n */\nexport class TestCoverage {\n\tprivate readonly fileCoverage = new ResourceMap<FileCoverage>();\n\tpublic readonly didAddCoverage = observableSignal<IPrefixTreeNode<AbstractFileCoverage>[]>(this);\n\tpublic readonly tree = new WellDefinedPrefixTree<AbstractFileCoverage>();\n\tpublic readonly associatedData = new Map<unknown, unknown>();\n\n\tconstructor(\n\t\tpublic readonly result: LiveTestResult,\n\t\tpublic readonly fromTaskId: string,\n\t\tprivate readonly uriIdentityService: IUriIdentityService,\n\t\tprivate readonly accessor: ICoverageAccessor,\n\t) { }\n\n\t/** Gets all test IDs that were included in this test run. */\n\tpublic *allPerTestIDs() {\n\t\tconst seen = new Set<string>();\n\t\tfor (const root of this.tree.nodes) {\n\t\t\tif (root.value && root.value.perTestData) {\n\t\t\t\tfor (const id of root.value.perTestData) {\n\t\t\t\t\tif (!seen.has(id)) {\n\t\t\t\t\t\tseen.add(id);\n\t\t\t\t\t\tyield id;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic append(coverage: IFileCoverage, tx: ITransaction | undefined) {\n\t\tconst previous = this.getComputedForUri(coverage.uri);\n\t\tconst result = this.result;\n\t\tconst applyDelta = (kind: 'statement' | 'branch' | 'declaration', node: ComputedFileCoverage) => {\n\t\t\tif (!node[kind]) {\n\t\t\t\tif (coverage[kind]) {\n\t\t\t\t\tnode[kind] = { ...coverage[kind]! };\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode[kind]!.covered += (coverage[kind]?.covered || 0) - (previous?.[kind]?.covered || 0);\n\t\t\t\tnode[kind]!.total += (coverage[kind]?.total || 0) - (previous?.[kind]?.total || 0);\n\t\t\t}\n\t\t};\n\n\t\t// We insert using the non-canonical path to normalize for casing differences\n\t\t// between URIs, but when inserting an intermediate node always use 'a' canonical\n\t\t// version.\n\t\tconst canonical = [...this.treePathForUri(coverage.uri, /* canonical = */ true)];\n\t\tconst chain: IPrefixTreeNode<AbstractFileCoverage>[] = [];\n\n\t\tthis.tree.mutatePath(this.treePathForUri(coverage.uri, /* canonical = */ false), node => {\n\t\t\tchain.push(node);\n\n\t\t\tif (chain.length === canonical.length) {\n\t\t\t\t// we reached our destination node, apply the coverage as necessary:\n\t\t\t\tif (node.value) {\n\t\t\t\t\tconst v = node.value;\n\t\t\t\t\t// if ID was generated from a test-specific coverage, reassign it to get its real ID in the extension host.\n\t\t\t\t\tv.id = coverage.id;\n\t\t\t\t\tv.statement = coverage.statement;\n\t\t\t\t\tv.branch = coverage.branch;\n\t\t\t\t\tv.declaration = coverage.declaration;\n\t\t\t\t} else {\n\t\t\t\t\tconst v = node.value = new FileCoverage(coverage, result, this.accessor);\n\t\t\t\t\tthis.fileCoverage.set(coverage.uri, v);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Otherwise, if this is not a partial per-test coverage, merge the\n\t\t\t\t// coverage changes into the chain. Per-test coverages are not complete\n\t\t\t\t// and we don't want to consider them for computation.\n\t\t\t\tif (!node.value) {\n\t\t\t\t\t// clone because later intersertions can modify the counts:\n\t\t\t\t\tconst intermediate = deepClone(coverage);\n\t\t\t\t\tintermediate.id = String(incId++);\n\t\t\t\t\tintermediate.uri = this.treePathToUri(canonical.slice(0, chain.length));\n\t\t\t\t\tnode.value = new ComputedFileCoverage(intermediate, result);\n\t\t\t\t} else {\n\t\t\t\t\tapplyDelta('statement', node.value);\n\t\t\t\t\tapplyDelta('branch', node.value);\n\t\t\t\t\tapplyDelta('declaration', node.value);\n\t\t\t\t\tnode.value.didChange.trigger(tx);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (coverage.testIds) {\n\t\t\t\tnode.value!.perTestData ??= new Set();\n\t\t\t\tfor (const id of coverage.testIds) {\n\t\t\t\t\tnode.value!.perTestData.add(id);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (chain) {\n\t\t\tthis.didAddCoverage.trigger(tx, chain);\n\t\t}\n\t}\n\n\t/**\n\t * Builds a new tree filtered to per-test coverage data for the given ID.\n\t */\n\tpublic filterTreeForTest(testId: TestId) {\n\t\tconst tree = new WellDefinedPrefixTree<AbstractFileCoverage>();\n\t\tfor (const node of this.tree.values()) {\n\t\t\tif (node instanceof FileCoverage) {\n\t\t\t\tif (!node.perTestData?.has(testId.toString())) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst canonical = [...this.treePathForUri(node.uri, /* canonical = */ true)];\n\t\t\t\tconst chain: IPrefixTreeNode<AbstractFileCoverage>[] = [];\n\t\t\t\ttree.mutatePath(this.treePathForUri(node.uri, /* canonical = */ false), n => {\n\t\t\t\t\tchain.push(n);\n\t\t\t\t\tn.value ??= new BypassedFileCoverage(this.treePathToUri(canonical.slice(0, chain.length)), node.fromResult);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn tree;\n\t}\n\n\t/**\n\t * Gets coverage information for all files.\n\t */\n\tpublic getAllFiles() {\n\t\treturn this.fileCoverage;\n\t}\n\n\t/**\n\t * Gets coverage information for a specific file.\n\t */\n\tpublic getUri(uri: URI) {\n\t\treturn this.fileCoverage.get(uri);\n\t}\n\n\t/**\n\t * Gets computed information for a file, including DFS-computed information\n\t * from child tests.\n\t */\n\tpublic getComputedForUri(uri: URI) {\n\t\treturn this.tree.find(this.treePathForUri(uri, /* canonical = */ false));\n\t}\n\n\tprivate *treePathForUri(uri: URI, canconicalPath: boolean) {\n\t\tyield uri.scheme;\n\t\tyield uri.authority;\n\n\t\tconst path = !canconicalPath && this.uriIdentityService.extUri.ignorePathCasing(uri) ? uri.path.toLowerCase() : uri.path;\n\t\tyield* path.split('/');\n\t}\n\n\tprivate treePathToUri(path: string[]) {\n\t\treturn URI.from({ scheme: path[0], authority: path[1], path: path.slice(2).join('/') });\n\t}\n}\n\nexport const getTotalCoveragePercent = (statement: ICoverageCount, branch: ICoverageCount | undefined, function_: ICoverageCount | undefined) => {\n\tlet numerator = statement.covered;\n\tlet denominator = statement.total;\n\n\tif (branch) {\n\t\tnumerator += branch.covered;\n\t\tdenominator += branch.total;\n\t}\n\n\tif (function_) {\n\t\tnumerator += function_.covered;\n\t\tdenominator += function_.total;\n\t}\n\n\treturn denominator === 0 ? 1 : numerator / denominator;\n};\n\nexport abstract class AbstractFileCoverage {\n\tpublic id: string;\n\tpublic readonly uri: URI;\n\tpublic statement: ICoverageCount;\n\tpublic branch?: ICoverageCount;\n\tpublic declaration?: ICoverageCount;\n\tpublic readonly didChange = observableSignal(this);\n\n\t/**\n\t * Gets the total coverage percent based on information provided.\n\t * This is based on the Clover total coverage formula\n\t */\n\tpublic get tpc() {\n\t\treturn getTotalCoveragePercent(this.statement, this.branch, this.declaration);\n\t}\n\n\t/**\n\t * Per-test coverage data for this file, if available.\n\t */\n\tpublic perTestData?: Set<string>;\n\n\tconstructor(coverage: IFileCoverage, public readonly fromResult: LiveTestResult) {\n\t\tthis.id = coverage.id;\n\t\tthis.uri = coverage.uri;\n\t\tthis.statement = coverage.statement;\n\t\tthis.branch = coverage.branch;\n\t\tthis.declaration = coverage.declaration;\n\t}\n}\n\n/**\n * File coverage info computed from children in the tree, not provided by the\n * extension.\n */\nexport class ComputedFileCoverage extends AbstractFileCoverage { }\n\n/**\n * A virtual node that doesn't have any added coverage info.\n */\nexport class BypassedFileCoverage extends ComputedFileCoverage {\n\tconstructor(uri: URI, result: LiveTestResult) {\n\t\tsuper({ id: String(incId++), uri, statement: { covered: 0, total: 0 } }, result);\n\t}\n}\n\nexport class FileCoverage extends AbstractFileCoverage {\n\tprivate _details?: Promise<CoverageDetails[]>;\n\tprivate resolved?: boolean;\n\tprivate _detailsForTest?: Map<string, Promise<CoverageDetails[]>>;\n\n\t/** Gets whether details are synchronously available */\n\tpublic get hasSynchronousDetails() {\n\t\treturn this._details instanceof Array || this.resolved;\n\t}\n\n\tconstructor(coverage: IFileCoverage, fromResult: LiveTestResult, private readonly accessor: ICoverageAccessor) {\n\t\tsuper(coverage, fromResult);\n\t}\n\n\t/**\n\t * Gets per-line coverage details.\n\t */\n\tpublic async detailsForTest(_testId: TestId, token = CancellationToken.None) {\n\t\tthis._detailsForTest ??= new Map();\n\t\tconst testId = _testId.toString();\n\t\tconst prev = this._detailsForTest.get(testId);\n\t\tif (prev) {\n\t\t\treturn prev;\n\t\t}\n\n\t\tconst promise = (async () => {\n\t\t\ttry {\n\t\t\t\treturn await this.accessor.getCoverageDetails(this.id, testId, token);\n\t\t\t} catch (e) {\n\t\t\t\tthis._detailsForTest?.delete(testId);\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t})();\n\n\t\tthis._detailsForTest.set(testId, promise);\n\t\treturn promise;\n\t}\n\n\t/**\n\t * Gets per-line coverage details.\n\t */\n\tpublic async details(token = CancellationToken.None) {\n\t\tthis._details ??= this.accessor.getCoverageDetails(this.id, undefined, token);\n\n\t\ttry {\n\t\t\tconst d = await this._details;\n\t\t\tthis.resolved = true;\n\t\t\treturn d;\n\t\t} catch (e) {\n\t\t\tthis._details = undefined;\n\t\t\tthrow e;\n\t\t}\n\t}\n}\n\nexport const totalFromCoverageDetails = (uri: URI, details: CoverageDetails[]): IFileCoverage => {\n\tconst fc: IFileCoverage = {\n\t\tid: '',\n\t\turi,\n\t\tstatement: ICoverageCount.empty(),\n\t};\n\n\tfor (const detail of details) {\n\t\tif (detail.type === DetailType.Statement) {\n\t\t\tfc.statement.total++;\n\t\t\tfc.statement.total += detail.count ? 1 : 0;\n\n\t\t\tfor (const branch of detail.branches || []) {\n\t\t\t\tfc.branch ??= ICoverageCount.empty();\n\t\t\t\tfc.branch.total++;\n\t\t\t\tfc.branch.covered += branch.count ? 1 : 0;\n\t\t\t}\n\t\t} else {\n\t\t\tfc.declaration ??= ICoverageCount.empty();\n\t\t\tfc.declaration.total++;\n\t\t\tfc.declaration.covered += detail.count ? 1 : 0;\n\t\t}\n\t}\n\n\treturn fc;\n};\n"],
  "mappings": "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",
  "names": []
}
