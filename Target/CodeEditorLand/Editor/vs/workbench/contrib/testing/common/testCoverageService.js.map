{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/testing/common/testCoverageService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { Iterable } from '../../../../base/common/iterator.js';\nimport { Disposable, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { IObservable, ISettableObservable, observableValue, transaction } from '../../../../base/common/observable.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { bindContextKey, observableConfigValue } from '../../../../platform/observable/common/platformObservableUtils.js';\nimport { TestingConfigKeys } from './configuration.js';\nimport { Testing } from './constants.js';\nimport { TestCoverage } from './testCoverage.js';\nimport { TestId } from './testId.js';\nimport { ITestRunTaskResults } from './testResult.js';\nimport { ITestResultService } from './testResultService.js';\nimport { TestingContextKeys } from './testingContextKeys.js';\nimport { IViewsService } from '../../../services/views/common/viewsService.js';\n\nexport const ITestCoverageService = createDecorator<ITestCoverageService>('testCoverageService');\n\nexport interface ITestCoverageService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Settable observable that can be used to show the test coverage instance\n\t * currently in the editor.\n\t */\n\treadonly selected: IObservable<TestCoverage | undefined>;\n\n\t/**\n\t * Filter to per-test coverage from the given test ID.\n\t */\n\treadonly filterToTest: ISettableObservable<TestId | undefined>;\n\n\t/**\n\t * Whether inline coverage is shown.\n\t */\n\treadonly showInline: ISettableObservable<boolean>;\n\n\t/**\n\t * Opens a test coverage report from a task, optionally focusing it in the editor.\n\t */\n\topenCoverage(task: ITestRunTaskResults, focus?: boolean): Promise<void>;\n\n\t/**\n\t * Closes any open coverage.\n\t */\n\tcloseCoverage(): void;\n}\n\nexport class TestCoverageService extends Disposable implements ITestCoverageService {\n\tdeclare readonly _serviceBrand: undefined;\n\tprivate readonly lastOpenCts = this._register(new MutableDisposable<CancellationTokenSource>());\n\n\tpublic readonly selected = observableValue<TestCoverage | undefined>('testCoverage', undefined);\n\tpublic readonly filterToTest = observableValue<TestId | undefined>('filterToTest', undefined);\n\tpublic readonly showInline = observableValue('inlineCoverage', false);\n\n\tconstructor(\n\t\t@IContextKeyService contextKeyService: IContextKeyService,\n\t\t@ITestResultService resultService: ITestResultService,\n\t\t@IConfigurationService configService: IConfigurationService,\n\t\t@IViewsService private readonly viewsService: IViewsService,\n\t) {\n\t\tsuper();\n\n\t\tconst toolbarConfig = observableConfigValue(TestingConfigKeys.CoverageToolbarEnabled, true, configService);\n\t\tthis._register(bindContextKey(\n\t\t\tTestingContextKeys.coverageToolbarEnabled,\n\t\t\tcontextKeyService,\n\t\t\treader => toolbarConfig.read(reader),\n\t\t));\n\n\t\tthis._register(bindContextKey(\n\t\t\tTestingContextKeys.inlineCoverageEnabled,\n\t\t\tcontextKeyService,\n\t\t\treader => this.showInline.read(reader),\n\t\t));\n\n\t\tthis._register(bindContextKey(\n\t\t\tTestingContextKeys.isTestCoverageOpen,\n\t\t\tcontextKeyService,\n\t\t\treader => !!this.selected.read(reader),\n\t\t));\n\n\t\tthis._register(bindContextKey(\n\t\t\tTestingContextKeys.hasPerTestCoverage,\n\t\t\tcontextKeyService,\n\t\t\treader => !Iterable.isEmpty(this.selected.read(reader)?.allPerTestIDs()),\n\t\t));\n\n\t\tthis._register(bindContextKey(\n\t\t\tTestingContextKeys.isCoverageFilteredToTest,\n\t\t\tcontextKeyService,\n\t\t\treader => !!this.filterToTest.read(reader),\n\t\t));\n\n\t\tthis._register(resultService.onResultsChanged(evt => {\n\t\t\tif ('completed' in evt) {\n\t\t\t\tconst coverage = evt.completed.tasks.find(t => t.coverage.get());\n\t\t\t\tif (coverage) {\n\t\t\t\t\tthis.openCoverage(coverage, false);\n\t\t\t\t} else {\n\t\t\t\t\tthis.closeCoverage();\n\t\t\t\t}\n\t\t\t} else if ('removed' in evt && this.selected.get()) {\n\t\t\t\tconst taskId = this.selected.get()?.fromTaskId;\n\t\t\t\tif (evt.removed.some(e => e.tasks.some(t => t.id === taskId))) {\n\t\t\t\t\tthis.closeCoverage();\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\t}\n\n\t/** @inheritdoc */\n\tpublic async openCoverage(task: ITestRunTaskResults, focus = true) {\n\t\tthis.lastOpenCts.value?.cancel();\n\t\tconst cts = this.lastOpenCts.value = new CancellationTokenSource();\n\t\tconst coverage = task.coverage.get();\n\t\tif (!coverage) {\n\t\t\treturn;\n\t\t}\n\n\t\ttransaction(tx => {\n\t\t\t// todo: may want to preserve this if coverage for that test in the new run?\n\t\t\tthis.filterToTest.set(undefined, tx);\n\t\t\tthis.selected.set(coverage, tx);\n\t\t});\n\n\t\tif (focus && !cts.token.isCancellationRequested) {\n\t\t\tthis.viewsService.openView(Testing.CoverageViewId, true);\n\t\t}\n\t}\n\n\t/** @inheritdoc */\n\tpublic closeCoverage() {\n\t\tthis.selected.set(undefined, undefined);\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
