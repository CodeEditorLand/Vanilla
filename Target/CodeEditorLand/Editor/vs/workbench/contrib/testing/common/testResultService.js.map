{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/testing/common/testResultService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { findFirstIdxMonotonousOrArrLen } from \"../../../../base/common/arraysFind.js\";\nimport { RunOnceScheduler } from \"../../../../base/common/async.js\";\nimport { Emitter, type Event } from \"../../../../base/common/event.js\";\nimport { createSingleCallFunction } from \"../../../../base/common/functional.js\";\nimport {\n\tDisposable,\n\tDisposableStore,\n\tdispose,\n\ttoDisposable,\n} from \"../../../../base/common/lifecycle.js\";\nimport { generateUuid } from \"../../../../base/common/uuid.js\";\nimport {\n\ttype IContextKey,\n\tIContextKeyService,\n} from \"../../../../platform/contextkey/common/contextkey.js\";\nimport { createDecorator } from \"../../../../platform/instantiation/common/instantiation.js\";\nimport { ITelemetryService } from \"../../../../platform/telemetry/common/telemetry.js\";\nimport { ITestProfileService } from \"./testProfileService.js\";\nimport {\n\ttype ITestResult,\n\tLiveTestResult,\n\ttype TestResultItemChange,\n\tTestResultItemChangeReason,\n} from \"./testResult.js\";\nimport { ITestResultStorage, RETAIN_MAX_RESULTS } from \"./testResultStorage.js\";\nimport {\n\ttype ExtensionRunTestsRequest,\n\ttype ITestRunProfile,\n\ttype ResolvedTestRunRequest,\n\ttype TestResultItem,\n\tTestResultState,\n\tTestRunProfileBitset,\n} from \"./testTypes.js\";\nimport { TestingContextKeys } from \"./testingContextKeys.js\";\n\nexport type ResultChangeEvent =\n\t| { completed: LiveTestResult }\n\t| { started: LiveTestResult }\n\t| { inserted: ITestResult }\n\t| { removed: ITestResult[] };\n\nexport interface ITestResultService {\n\treadonly _serviceBrand: undefined;\n\t/**\n\t * Fired after any results are added, removed, or completed.\n\t */\n\treadonly onResultsChanged: Event<ResultChangeEvent>;\n\n\t/**\n\t * Fired when a test changed it state, or its computed state is updated.\n\t */\n\treadonly onTestChanged: Event<TestResultItemChange>;\n\n\t/**\n\t * List of known test results.\n\t */\n\treadonly results: ReadonlyArray<ITestResult>;\n\n\t/**\n\t * Discards all completed test results.\n\t */\n\tclear(): void;\n\n\t/**\n\t * Creates a new, live test result.\n\t */\n\tcreateLiveResult(\n\t\treq: ResolvedTestRunRequest | ExtensionRunTestsRequest,\n\t): LiveTestResult;\n\n\t/**\n\t * Adds a new test result to the collection.\n\t */\n\tpush<T extends ITestResult>(result: T): T;\n\n\t/**\n\t * Looks up a set of test results by ID.\n\t */\n\tgetResult(resultId: string): ITestResult | undefined;\n\n\t/**\n\t * Looks up a test's most recent state, by its extension-assigned ID.\n\t */\n\tgetStateById(\n\t\textId: string,\n\t): [results: ITestResult, item: TestResultItem] | undefined;\n}\n\nconst isRunningTests = (service: ITestResultService) =>\n\tservice.results.length > 0 && service.results[0].completedAt === undefined;\n\nexport const ITestResultService =\n\tcreateDecorator<ITestResultService>(\"testResultService\");\n\nexport class TestResultService\n\textends Disposable\n\timplements ITestResultService\n{\n\tdeclare _serviceBrand: undefined;\n\tprivate changeResultEmitter = this._register(\n\t\tnew Emitter<ResultChangeEvent>(),\n\t);\n\tprivate _results: ITestResult[] = [];\n\tprivate readonly _resultsDisposables: DisposableStore[] = [];\n\tprivate testChangeEmitter = this._register(\n\t\tnew Emitter<TestResultItemChange>(),\n\t);\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic get results() {\n\t\tthis.loadResults();\n\t\treturn this._results;\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic readonly onResultsChanged = this.changeResultEmitter.event;\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic readonly onTestChanged = this.testChangeEmitter.event;\n\n\tprivate readonly isRunning: IContextKey<boolean>;\n\tprivate readonly hasAnyResults: IContextKey<boolean>;\n\tprivate readonly loadResults = createSingleCallFunction(() =>\n\t\tthis.storage.read().then((loaded) => {\n\t\t\tfor (let i = loaded.length - 1; i >= 0; i--) {\n\t\t\t\tthis.push(loaded[i]);\n\t\t\t}\n\t\t}),\n\t);\n\n\tprotected readonly persistScheduler = new RunOnceScheduler(\n\t\t() => this.persistImmediately(),\n\t\t500,\n\t);\n\n\tconstructor(\n\t\t@IContextKeyService contextKeyService: IContextKeyService,\n\t\t@ITestResultStorage private readonly storage: ITestResultStorage,\n\t\t@ITestProfileService private readonly testProfiles: ITestProfileService,\n\t\t@ITelemetryService private readonly telemetryService: ITelemetryService,\n\t) {\n\t\tsuper();\n\t\tthis._register(toDisposable(() => dispose(this._resultsDisposables)));\n\t\tthis.isRunning = TestingContextKeys.isRunning.bindTo(contextKeyService);\n\t\tthis.hasAnyResults = TestingContextKeys.hasAnyResults.bindTo(contextKeyService);\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic getStateById(\n\t\textId: string,\n\t): [results: ITestResult, item: TestResultItem] | undefined {\n\t\tfor (const result of this.results) {\n\t\t\tconst lookup = result.getStateById(extId);\n\t\t\tif (lookup && lookup.computedState !== TestResultState.Unset) {\n\t\t\t\treturn [result, lookup];\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic createLiveResult(\n\t\treq: ResolvedTestRunRequest | ExtensionRunTestsRequest,\n\t) {\n\t\tif (\"targets\" in req) {\n\t\t\tconst id = generateUuid();\n\t\t\treturn this.push(\n\t\t\t\tnew LiveTestResult(id, true, req, this.telemetryService),\n\t\t\t);\n\t\t}\n\n\t\tlet profile: ITestRunProfile | undefined;\n\t\tif (req.profile) {\n\t\t\tconst profiles = this.testProfiles.getControllerProfiles(\n\t\t\t\treq.controllerId,\n\t\t\t);\n\t\t\tprofile = profiles.find((c) => c.profileId === req.profile!.id);\n\t\t}\n\n\t\tconst resolved: ResolvedTestRunRequest = {\n\t\t\tpreserveFocus: req.preserveFocus,\n\t\t\ttargets: [],\n\t\t\texclude: req.exclude,\n\t\t\tcontinuous: req.continuous,\n\t\t\tgroup: profile?.group ?? TestRunProfileBitset.Run,\n\t\t};\n\n\t\tif (profile) {\n\t\t\tresolved.targets.push({\n\t\t\t\tprofileId: profile.profileId,\n\t\t\t\tcontrollerId: req.controllerId,\n\t\t\t\ttestIds: req.include,\n\t\t\t});\n\t\t}\n\n\t\treturn this.push(\n\t\t\tnew LiveTestResult(\n\t\t\t\treq.id,\n\t\t\t\treq.persist,\n\t\t\t\tresolved,\n\t\t\t\tthis.telemetryService,\n\t\t\t),\n\t\t);\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic push<T extends ITestResult>(result: T): T {\n\t\tif (result.completedAt === undefined) {\n\t\t\tthis.results.unshift(result);\n\t\t} else {\n\t\t\tconst index = findFirstIdxMonotonousOrArrLen(\n\t\t\t\tthis.results,\n\t\t\t\t(r) =>\n\t\t\t\t\tr.completedAt !== undefined &&\n\t\t\t\t\tr.completedAt <= result.completedAt!,\n\t\t\t);\n\t\t\tthis.results.splice(index, 0, result);\n\t\t\tthis.persistScheduler.schedule();\n\t\t}\n\n\t\tthis.hasAnyResults.set(true);\n\t\tif (this.results.length > RETAIN_MAX_RESULTS) {\n\t\t\tthis.results.pop();\n\t\t\tthis._resultsDisposables.pop()?.dispose();\n\t\t}\n\n\t\tconst ds = new DisposableStore();\n\t\tthis._resultsDisposables.push(ds);\n\n\t\tif (result instanceof LiveTestResult) {\n\t\t\tds.add(result);\n\t\t\tds.add(result.onComplete(() => this.onComplete(result)));\n\t\t\tds.add(\n\t\t\t\tresult.onChange(\n\t\t\t\t\tthis.testChangeEmitter.fire,\n\t\t\t\t\tthis.testChangeEmitter,\n\t\t\t\t),\n\t\t\t);\n\t\t\tthis.isRunning.set(true);\n\t\t\tthis.changeResultEmitter.fire({ started: result });\n\t\t} else {\n\t\t\tthis.changeResultEmitter.fire({ inserted: result });\n\t\t\t// If this is not a new result, go through each of its tests. For each\n\t\t\t// test for which the new result is the most recently inserted, fir\n\t\t\t// a change event so that UI updates.\n\t\t\tfor (const item of result.tests) {\n\t\t\t\tfor (const otherResult of this.results) {\n\t\t\t\t\tif (otherResult === result) {\n\t\t\t\t\t\tthis.testChangeEmitter.fire({\n\t\t\t\t\t\t\titem,\n\t\t\t\t\t\t\tresult,\n\t\t\t\t\t\t\treason: TestResultItemChangeReason.ComputedStateChange,\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (\n\t\t\t\t\t\totherResult.getStateById(item.item.extId) !== undefined\n\t\t\t\t\t) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic getResult(id: string) {\n\t\treturn this.results.find((r) => r.id === id);\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic clear() {\n\t\tconst keep: ITestResult[] = [];\n\t\tconst removed: ITestResult[] = [];\n\t\tfor (const result of this.results) {\n\t\t\tif (result.completedAt !== undefined) {\n\t\t\t\tremoved.push(result);\n\t\t\t} else {\n\t\t\t\tkeep.push(result);\n\t\t\t}\n\t\t}\n\n\t\tthis._results = keep;\n\t\tthis.persistScheduler.schedule();\n\t\tif (keep.length === 0) {\n\t\t\tthis.hasAnyResults.set(false);\n\t\t}\n\t\tthis.changeResultEmitter.fire({ removed });\n\t}\n\n\tprivate onComplete(result: LiveTestResult) {\n\t\tthis.resort();\n\t\tthis.updateIsRunning();\n\t\tthis.persistScheduler.schedule();\n\t\tthis.changeResultEmitter.fire({ completed: result });\n\t}\n\n\tprivate resort() {\n\t\tthis.results.sort(\n\t\t\t(a, b) =>\n\t\t\t\t(b.completedAt ?? Number.MAX_SAFE_INTEGER) -\n\t\t\t\t(a.completedAt ?? Number.MAX_SAFE_INTEGER),\n\t\t);\n\t}\n\n\tprivate updateIsRunning() {\n\t\tthis.isRunning.set(isRunningTests(this));\n\t}\n\n\tprotected async persistImmediately() {\n\t\t// ensure results are loaded before persisting to avoid deleting once\n\t\t// that we don't have yet.\n\t\tawait this.loadResults();\n\t\tthis.storage.persist(this.results);\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
