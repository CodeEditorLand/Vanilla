var H=Object.defineProperty;var K=Object.getOwnPropertyDescriptor;var S=(f,d,e,t)=>{for(var o=t>1?void 0:t?K(d,e):d,a=f.length-1,s;a>=0;a--)(s=f[a])&&(o=(t?s(d,e,o):s(o))||o);return t&&o&&H(d,e,o),o},c=(f,d)=>(e,t)=>d(e,t,f);import{groupBy as T}from"../../../../base/common/arrays.js";import{CancellationToken as I,CancellationTokenSource as y}from"../../../../base/common/cancellation.js";import{Emitter as C}from"../../../../base/common/event.js";import{Iterable as E}from"../../../../base/common/iterator.js";import{Disposable as F,toDisposable as P}from"../../../../base/common/lifecycle.js";import{observableValue as A}from"../../../../base/common/observable.js";import{isDefined as R}from"../../../../base/common/types.js";import{localize as h}from"../../../../nls.js";import{IConfigurationService as B}from"../../../../platform/configuration/common/configuration.js";import{IContextKeyService as N}from"../../../../platform/contextkey/common/contextkey.js";import{IInstantiationService as j}from"../../../../platform/instantiation/common/instantiation.js";import{INotificationService as U}from"../../../../platform/notification/common/notification.js";import{bindContextKey as D}from"../../../../platform/observable/common/platformObservableUtils.js";import{IStorageService as W,StorageScope as _,StorageTarget as O}from"../../../../platform/storage/common/storage.js";import{IUriIdentityService as V}from"../../../../platform/uriIdentity/common/uriIdentity.js";import{IWorkspaceTrustRequestService as z}from"../../../../platform/workspace/common/workspaceTrust.js";import{IEditorService as L}from"../../../services/editor/common/editorService.js";import{TestingConfigKeys as G,getTestingConfiguration as q}from"./configuration.js";import{MainThreadTestCollection as J}from"./mainThreadTestCollection.js";import{MutableObservableValue as Q}from"./observableValue.js";import{StoredValue as X}from"./storedValue.js";import{TestExclusions as Y}from"./testExclusions.js";import{TestId as Z}from"./testId.js";import{ITestProfileService as $,canUseProfileWithTest as b}from"./testProfileService.js";import{ITestResultService as ee}from"./testResultService.js";import{TestControllerCapability as x,TestDiffOpType as te}from"./testTypes.js";import{TestingContextKeys as p}from"./testingContextKeys.js";let g=class extends F{constructor(e,t,o,a,s,n,i,l,r,u){super();this.uriIdentityService=o;this.storage=a;this.editorService=s;this.testProfiles=n;this.notificationService=i;this.configurationService=l;this.testResults=r;this.workspaceTrustRequestService=u;this.excluded=t.createInstance(Y),this.isRefreshingTests=p.isRefreshingTests.bindTo(e),this.activeEditorHasTests=p.activeEditorHasTests.bindTo(e),this._register(D(p.providerCount,e,v=>this.testControllers.read(v).size));const m=(v,k)=>this._register(D(v,e,w=>E.some(this.testControllers.read(w).values(),M=>!!(M.capabilities.read(w)&k))));m(p.canRefreshTests,x.Refresh),m(p.canGoToRelatedCode,x.CodeRelatedToTest),m(p.canGoToRelatedTest,x.TestRelatedToCode),this._register(s.onDidActiveEditorChange(()=>this.updateEditorContextKeys()))}testControllers=A("testControllers",new Map);testExtHosts=new Set;cancelExtensionTestRunEmitter=new C;willProcessDiffEmitter=new C;didProcessDiffEmitter=new C;testRefreshCancellations=new Set;isRefreshingTests;activeEditorHasTests;uiRunningTests=new Map;onWillProcessDiff=this.willProcessDiffEmitter.event;onDidProcessDiff=this.didProcessDiffEmitter.event;onDidCancelTestRun=this.cancelExtensionTestRunEmitter.event;collection=new J(this.uriIdentityService,this.expandTest.bind(this));excluded;showInlineOutput=this._register(Q.stored(new X({key:"inlineTestOutputVisible",scope:_.WORKSPACE,target:O.USER},this.storage),!0));async expandTest(e,t){await this.testControllers.get().get(Z.fromString(e).controllerId)?.expandTest(e,t)}cancelTestRun(e,t){if(this.cancelExtensionTestRunEmitter.fire({runId:e,taskId:t}),e===void 0)for(const o of this.uiRunningTests.values())o.cancel();else t||this.uiRunningTests.get(e)?.cancel()}async runTests(e,t=I.None){const o=[];for(const s of e.tests){const n=o.find(r=>b(r.profile,s));if(n){n.tests.push(s);continue}const i=this.testProfiles.getControllerProfiles(s.controllerId).filter(r=>(r.group&e.group)!==0&&b(r,s)),l=i.find(r=>r.isDefault)||i[0];l&&o.push({profile:l,tests:[s]})}const a={targets:o.map(({profile:s,tests:n})=>({profileId:s.profileId,controllerId:n[0].controllerId,testIds:n.map(i=>i.item.extId)})),group:e.group,exclude:e.exclude?.map(s=>s.item.extId),continuous:e.continuous};if(a.targets.length===0)for(const s of T(e.tests,(n,i)=>n.controllerId===i.controllerId?0:1)){const n=this.testProfiles.getControllerProfiles(s[0].controllerId),i=s.map(l=>({profile:n.find(r=>r.group===e.group&&b(r,l)),test:l}));for(const l of T(i,(r,u)=>r.profile===u.profile?0:1)){const r=l[0].profile;r&&a.targets.push({testIds:l.map(u=>u.test.item.extId),profileId:r.profileId,controllerId:r.controllerId})}}return this.runResolvedTests(a,t)}async startContinuousRun(e,t){if(e.exclude||(e.exclude=[...this.excluded.all]),!await this.workspaceTrustRequestService.requestWorkspaceTrust({message:h("testTrust","Running tests may execute code in your workspace.")}))return;const s=T(e.targets,(n,i)=>n.controllerId.localeCompare(i.controllerId)).map(n=>this.getTestController(n[0].controllerId)?.startContinuousRun(n.map(i=>({excludeExtIds:e.exclude.filter(l=>!i.testIds.includes(l)),profileId:i.profileId,controllerId:i.controllerId,testIds:i.testIds})),t).then(i=>{const l=i.map(r=>r.error).filter(R);l.length&&this.notificationService.error(h("testError","An error occurred attempting to run tests: {0}",l.join(" ")))}));await Promise.all(s)}async runResolvedTests(e,t=I.None){e.exclude||(e.exclude=[...this.excluded.all]);const o=this.testResults.createLiveResult(e);if(!await this.workspaceTrustRequestService.requestWorkspaceTrust({message:h("testTrust","Running tests may execute code in your workspace.")}))return o.markComplete(),o;try{const s=new y(t);this.uiRunningTests.set(o.id,s);const i=T(e.targets,(l,r)=>l.controllerId.localeCompare(r.controllerId)).map(l=>this.getTestController(l[0].controllerId)?.runTests(l.map(r=>({runId:o.id,excludeExtIds:e.exclude.filter(u=>!r.testIds.includes(u)),profileId:r.profileId,controllerId:r.controllerId,testIds:r.testIds})),s.token).then(r=>{const u=r.map(m=>m.error).filter(R);u.length&&this.notificationService.error(h("testError","An error occurred attempting to run tests: {0}",u.join(" ")))}));return await this.saveAllBeforeTest(e),await Promise.all(i),o}finally{this.uiRunningTests.delete(o.id),o.markComplete()}}async provideTestFollowups(e,t){const o=await Promise.all([...this.testExtHosts].map(async s=>({ctrl:s,followups:await s.provideTestFollowups(e,t)}))),a={followups:o.flatMap(({ctrl:s,followups:n})=>n.map(i=>({message:i.title,execute:()=>s.executeTestFollowup(i.id)}))),dispose:()=>{for(const{ctrl:s,followups:n}of o)s.disposeTestFollowups(n.map(i=>i.id))}};return t.isCancellationRequested&&a.dispose(),a}publishDiff(e,t){this.willProcessDiffEmitter.fire(t),this.collection.apply(t),this.updateEditorContextKeys(),this.didProcessDiffEmitter.fire(t)}getTestController(e){return this.testControllers.get().get(e)}async syncTests(){const e=new y;try{await Promise.all([...this.testControllers.get().values()].map(t=>t.syncTests(e.token)))}finally{e.dispose(!0)}}async refreshTests(e){const t=new y;this.testRefreshCancellations.add(t),this.isRefreshingTests.set(!0);try{e?await this.getTestController(e)?.refreshTests(t.token):await Promise.all([...this.testControllers.get().values()].map(o=>o.refreshTests(t.token)))}finally{this.testRefreshCancellations.delete(t),this.isRefreshingTests.set(this.testRefreshCancellations.size>0),t.dispose(!0)}}cancelRefreshTests(){for(const e of this.testRefreshCancellations)e.cancel();this.testRefreshCancellations.clear(),this.isRefreshingTests.set(!1)}registerExtHost(e){return this.testExtHosts.add(e),P(()=>this.testExtHosts.delete(e))}async getTestsRelatedToCode(e,t,o=I.None){return(await Promise.all([...this.testExtHosts.values()].map(s=>s.getTestsRelatedToCode(e,t,o)))).flatMap(s=>s.map(n=>this.collection.getNodeById(n))).filter(R)}registerTestController(e,t){return this.testControllers.set(new Map(this.testControllers.get()).set(e,t),void 0),P(()=>{const o=[];for(const s of this.collection.rootItems)s.controllerId===e&&o.push({op:te.Remove,itemId:s.item.extId});this.publishDiff(e,o);const a=new Map(this.testControllers.get());a.delete(e),this.testControllers.set(a,void 0)})}async getCodeRelatedToTest(e,t=I.None){return await this.testControllers.get().get(e.controllerId)?.getRelatedCode(e.item.extId,t)||[]}updateEditorContextKeys(){const e=this.editorService.activeEditor?.resource;e?this.activeEditorHasTests.set(!E.isEmpty(this.collection.getNodeByUrl(e))):this.activeEditorHasTests.set(!1)}async saveAllBeforeTest(e,t=this.configurationService,o=this.editorService){if(e.preserveFocus===!0)return;q(this.configurationService,G.SaveBeforeTest)&&await o.saveAll()}};g=S([c(0,N),c(1,j),c(2,V),c(3,W),c(4,L),c(5,$),c(6,U),c(7,B),c(8,ee),c(9,z)],g);export{g as TestService};
