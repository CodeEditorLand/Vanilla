{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/testing/common/testResultStorage.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport {\n\tVSBuffer,\n\ttype VSBufferReadableStream,\n\ttype VSBufferWriteableStream,\n\tbufferToStream,\n\tnewWriteableBufferStream,\n} from \"../../../../base/common/buffer.js\";\nimport { Disposable } from \"../../../../base/common/lifecycle.js\";\nimport { isDefined } from \"../../../../base/common/types.js\";\nimport { URI } from \"../../../../base/common/uri.js\";\nimport { IEnvironmentService } from \"../../../../platform/environment/common/environment.js\";\nimport { IFileService } from \"../../../../platform/files/common/files.js\";\nimport { createDecorator } from \"../../../../platform/instantiation/common/instantiation.js\";\nimport { ILogService } from \"../../../../platform/log/common/log.js\";\nimport {\n\tIStorageService,\n\tStorageScope,\n\tStorageTarget,\n} from \"../../../../platform/storage/common/storage.js\";\nimport { IUriIdentityService } from \"../../../../platform/uriIdentity/common/uriIdentity.js\";\nimport { IWorkspaceContextService } from \"../../../../platform/workspace/common/workspace.js\";\nimport { StoredValue } from \"./storedValue.js\";\nimport { HydratedTestResult, type ITestResult } from \"./testResult.js\";\nimport type { ISerializedTestResults } from \"./testTypes.js\";\n\nexport const RETAIN_MAX_RESULTS = 128;\nconst RETAIN_MIN_RESULTS = 16;\nconst RETAIN_MAX_BYTES = 1024 * 128;\nconst CLEANUP_PROBABILITY = 0.2;\n\nexport interface ITestResultStorage {\n\t_serviceBrand: undefined;\n\n\t/**\n\t * Retrieves the list of stored test results.\n\t */\n\tread(): Promise<HydratedTestResult[]>;\n\n\t/**\n\t * Persists the list of test results.\n\t */\n\tpersist(results: ReadonlyArray<ITestResult>): Promise<void>;\n}\n\nexport const ITestResultStorage = createDecorator(\"ITestResultStorage\");\n\n/**\n * Data revision this version of VS Code deals with. Should be bumped whenever\n * a breaking change is made to the stored results, which will cause previous\n * revisions to be discarded.\n */\nconst currentRevision = 1;\n\nexport abstract class BaseTestResultStorage\n\textends Disposable\n\timplements ITestResultStorage\n{\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprotected readonly stored = this._register(\n\t\tnew StoredValue<\n\t\t\tReadonlyArray<{ rev: number; id: string; bytes: number }>\n\t\t>(\n\t\t\t{\n\t\t\t\tkey: \"storedTestResults\",\n\t\t\t\tscope: StorageScope.WORKSPACE,\n\t\t\t\ttarget: StorageTarget.MACHINE,\n\t\t\t},\n\t\t\tthis.storageService,\n\t\t),\n\t);\n\n\tconstructor(\n\t\t@IUriIdentityService\n\t\tprivate readonly uriIdentityService: IUriIdentityService,\n\t\t@IStorageService private readonly storageService: IStorageService,\n\t\t@ILogService private readonly logService: ILogService,\n\t) {\n\t\tsuper();\n\t}\n\n\t/**\n\t * @override\n\t */\n\tpublic async read(): Promise<HydratedTestResult[]> {\n\t\tconst results = await Promise.all(\n\t\t\tthis.stored.get([]).map(async ({ id, rev }) => {\n\t\t\t\tif (rev !== currentRevision) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tconst contents = await this.readForResultId(id);\n\t\t\t\t\tif (!contents) {\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn new HydratedTestResult(\n\t\t\t\t\t\tthis.uriIdentityService,\n\t\t\t\t\t\tcontents,\n\t\t\t\t\t);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthis.logService.warn(\n\t\t\t\t\t\t`Error deserializing stored test result ${id}`,\n\t\t\t\t\t\te,\n\t\t\t\t\t);\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\n\t\treturn results.filter(isDefined);\n\t}\n\n\t/**\n\t * @override\n\t */\n\tpublic getResultOutputWriter(resultId: string) {\n\t\tconst stream = newWriteableBufferStream();\n\t\tthis.storeOutputForResultId(resultId, stream);\n\t\treturn stream;\n\t}\n\n\t/**\n\t * @override\n\t */\n\tpublic async persist(results: ReadonlyArray<ITestResult>): Promise<void> {\n\t\tconst toDelete = new Map(\n\t\t\tthis.stored.get([]).map(({ id, bytes }) => [id, bytes]),\n\t\t);\n\t\tconst toStore: { rev: number; id: string; bytes: number }[] = [];\n\t\tconst todo: Promise<unknown>[] = [];\n\t\tlet budget = RETAIN_MAX_BYTES;\n\n\t\t// Run until either:\n\t\t// 1. We store all results\n\t\t// 2. We store the max results\n\t\t// 3. We store the min results, and have no more byte budget\n\t\tfor (\n\t\t\tlet i = 0;\n\t\t\ti < results.length &&\n\t\t\ti < RETAIN_MAX_RESULTS &&\n\t\t\t(budget > 0 || toStore.length < RETAIN_MIN_RESULTS);\n\t\t\ti++\n\t\t) {\n\t\t\tconst result = results[i];\n\t\t\tconst existingBytes = toDelete.get(result.id);\n\t\t\tif (existingBytes !== undefined) {\n\t\t\t\ttoDelete.delete(result.id);\n\t\t\t\ttoStore.push({\n\t\t\t\t\tid: result.id,\n\t\t\t\t\trev: currentRevision,\n\t\t\t\t\tbytes: existingBytes,\n\t\t\t\t});\n\t\t\t\tbudget -= existingBytes;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst obj = result.toJSON();\n\t\t\tif (!obj) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst contents = VSBuffer.fromString(JSON.stringify(obj));\n\t\t\ttodo.push(this.storeForResultId(result.id, obj));\n\t\t\ttoStore.push({\n\t\t\t\tid: result.id,\n\t\t\t\trev: currentRevision,\n\t\t\t\tbytes: contents.byteLength,\n\t\t\t});\n\t\t\tbudget -= contents.byteLength;\n\t\t}\n\n\t\tfor (const id of toDelete.keys()) {\n\t\t\ttodo.push(this.deleteForResultId(id).catch(() => undefined));\n\t\t}\n\n\t\tthis.stored.store(toStore);\n\t\tawait Promise.all(todo);\n\t}\n\n\t/**\n\t * Reads serialized results for the test. Is allowed to throw.\n\t */\n\tprotected abstract readForResultId(\n\t\tid: string,\n\t): Promise<ISerializedTestResults | undefined>;\n\n\t/**\n\t * Reads output as a stream for the test.\n\t */\n\tprotected abstract readOutputForResultId(\n\t\tid: string,\n\t): Promise<VSBufferReadableStream>;\n\n\t/**\n\t * Reads an output range for the test.\n\t */\n\tprotected abstract readOutputRangeForResultId(\n\t\tid: string,\n\t\toffset: number,\n\t\tlength: number,\n\t): Promise<VSBuffer>;\n\n\t/**\n\t * Deletes serialized results for the test.\n\t */\n\tprotected abstract deleteForResultId(id: string): Promise<unknown>;\n\n\t/**\n\t * Stores test results by ID.\n\t */\n\tprotected abstract storeForResultId(\n\t\tid: string,\n\t\tdata: ISerializedTestResults,\n\t): Promise<unknown>;\n\n\t/**\n\t * Reads serialized results for the test. Is allowed to throw.\n\t */\n\tprotected abstract storeOutputForResultId(\n\t\tid: string,\n\t\tinput: VSBufferWriteableStream,\n\t): Promise<void>;\n}\n\nexport class InMemoryResultStorage extends BaseTestResultStorage {\n\tpublic readonly cache = new Map<string, ISerializedTestResults>();\n\n\tprotected async readForResultId(id: string) {\n\t\treturn Promise.resolve(this.cache.get(id));\n\t}\n\n\tprotected storeForResultId(id: string, contents: ISerializedTestResults) {\n\t\tthis.cache.set(id, contents);\n\t\treturn Promise.resolve();\n\t}\n\n\tprotected deleteForResultId(id: string) {\n\t\tthis.cache.delete(id);\n\t\treturn Promise.resolve();\n\t}\n\n\tprotected readOutputForResultId(\n\t\tid: string,\n\t): Promise<VSBufferReadableStream> {\n\t\tthrow new Error(\"Method not implemented.\");\n\t}\n\n\tprotected storeOutputForResultId(\n\t\tid: string,\n\t\tinput: VSBufferWriteableStream,\n\t): Promise<void> {\n\t\tthrow new Error(\"Method not implemented.\");\n\t}\n\n\tprotected readOutputRangeForResultId(\n\t\tid: string,\n\t\toffset: number,\n\t\tlength: number,\n\t): Promise<VSBuffer> {\n\t\tthrow new Error(\"Method not implemented.\");\n\t}\n}\n\nexport class TestResultStorage extends BaseTestResultStorage {\n\tprivate readonly directory: URI;\n\n\tconstructor(\n\t\t@IUriIdentityService uriIdentityService: IUriIdentityService,\n\t\t@IStorageService storageService: IStorageService,\n\t\t@ILogService logService: ILogService,\n\t\t@IWorkspaceContextService workspaceContext: IWorkspaceContextService,\n\t\t@IFileService private readonly fileService: IFileService,\n\t\t@IEnvironmentService environmentService: IEnvironmentService,\n\t) {\n\t\tsuper(uriIdentityService, storageService, logService);\n\t\tthis.directory = URI.joinPath(\n\t\t\tenvironmentService.workspaceStorageHome,\n\t\t\tworkspaceContext.getWorkspace().id,\n\t\t\t\"testResults\",\n\t\t);\n\t}\n\n\tprotected async readForResultId(id: string) {\n\t\tconst contents = await this.fileService.readFile(\n\t\t\tthis.getResultJsonPath(id),\n\t\t);\n\t\treturn JSON.parse(contents.value.toString());\n\t}\n\n\tprotected storeForResultId(id: string, contents: ISerializedTestResults) {\n\t\treturn this.fileService.writeFile(\n\t\t\tthis.getResultJsonPath(id),\n\t\t\tVSBuffer.fromString(JSON.stringify(contents)),\n\t\t);\n\t}\n\n\tprotected deleteForResultId(id: string) {\n\t\treturn this.fileService\n\t\t\t.del(this.getResultJsonPath(id))\n\t\t\t.catch(() => undefined);\n\t}\n\n\tprotected async readOutputRangeForResultId(\n\t\tid: string,\n\t\toffset: number,\n\t\tlength: number,\n\t): Promise<VSBuffer> {\n\t\ttry {\n\t\t\tconst { value } = await this.fileService.readFile(\n\t\t\t\tthis.getResultOutputPath(id),\n\t\t\t\t{ position: offset, length },\n\t\t\t);\n\t\t\treturn value;\n\t\t} catch {\n\t\t\treturn VSBuffer.alloc(0);\n\t\t}\n\t}\n\n\tprotected async readOutputForResultId(\n\t\tid: string,\n\t): Promise<VSBufferReadableStream> {\n\t\ttry {\n\t\t\tconst { value } = await this.fileService.readFileStream(\n\t\t\t\tthis.getResultOutputPath(id),\n\t\t\t);\n\t\t\treturn value;\n\t\t} catch {\n\t\t\treturn bufferToStream(VSBuffer.alloc(0));\n\t\t}\n\t}\n\n\tprotected async storeOutputForResultId(\n\t\tid: string,\n\t\tinput: VSBufferWriteableStream,\n\t) {\n\t\tawait this.fileService.createFile(this.getResultOutputPath(id), input);\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic override async persist(results: ReadonlyArray<ITestResult>) {\n\t\tawait super.persist(results);\n\t\tif (Math.random() < CLEANUP_PROBABILITY) {\n\t\t\tawait this.cleanupDereferenced();\n\t\t}\n\t}\n\n\t/**\n\t * Cleans up orphaned files. For instance, output can get orphaned if it's\n\t * written but the editor is closed before the test run is complete.\n\t */\n\tprivate async cleanupDereferenced() {\n\t\tconst { children } = await this.fileService.resolve(this.directory);\n\t\tif (!children) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst stored = new Set(\n\t\t\tthis.stored\n\t\t\t\t.get([])\n\t\t\t\t.filter((s) => s.rev === currentRevision)\n\t\t\t\t.map((s) => s.id),\n\t\t);\n\n\t\tawait Promise.all(\n\t\t\tchildren\n\t\t\t\t.filter(\n\t\t\t\t\t(child) => !stored.has(child.name.replace(/\\.[a-z]+$/, \"\")),\n\t\t\t\t)\n\t\t\t\t.map((child) =>\n\t\t\t\t\tthis.fileService.del(child.resource).catch(() => undefined),\n\t\t\t\t),\n\t\t);\n\t}\n\n\tprivate getResultJsonPath(id: string) {\n\t\treturn URI.joinPath(this.directory, `${id}.json`);\n\t}\n\n\tprivate getResultOutputPath(id: string) {\n\t\treturn URI.joinPath(this.directory, `${id}.output`);\n\t}\n}\n"],
  "mappings": ";;;;;;;;;;;;AAKA;AAAA,EACC;AAAA,EAGA;AAAA,EACA;AAAA,OACM;AACP,SAAS,kBAAkB;AAC3B,SAAS,iBAAiB;AAC1B,SAAS,WAAW;AACpB,SAAS,2BAA2B;AACpC,SAAS,oBAAoB;AAC7B,SAAS,uBAAuB;AAChC,SAAS,mBAAmB;AAC5B;AAAA,EACC;AAAA,EACA;AAAA,EACA;AAAA,OACM;AACP,SAAS,2BAA2B;AACpC,SAAS,gCAAgC;AACzC,SAAS,mBAAmB;AAC5B,SAAS,0BAA4C;AAG9C,MAAM,qBAAqB;AAClC,MAAM,qBAAqB;AAC3B,MAAM,mBAAmB,OAAO;AAChC,MAAM,sBAAsB;AAgBrB,MAAM,qBAAqB,gBAAgB,oBAAoB;AAOtE,MAAM,kBAAkB;AAEjB,IAAe,wBAAf,cACE,WAET;AAAA,EAgBC,YAEkB,oBACiB,gBACJ,YAC7B;AACD,UAAM;AAJW;AACiB;AACJ;AAAA,EAG/B;AAAA,EApFD,OA6DA;AAAA;AAAA;AAAA,EAGoB,SAAS,KAAK;AAAA,IAChC,IAAI;AAAA,MAGH;AAAA,QACC,KAAK;AAAA,QACL,OAAO,aAAa;AAAA,QACpB,QAAQ,cAAc;AAAA,MACvB;AAAA,MACA,KAAK;AAAA,IACN;AAAA,EACD;AAAA;AAAA;AAAA;AAAA,EAcA,MAAa,OAAsC;AAClD,UAAM,UAAU,MAAM,QAAQ;AAAA,MAC7B,KAAK,OAAO,IAAI,CAAC,CAAC,EAAE,IAAI,OAAO,EAAE,IAAI,IAAI,MAAM;AAC9C,YAAI,QAAQ,iBAAiB;AAC5B,iBAAO;AAAA,QACR;AAEA,YAAI;AACH,gBAAM,WAAW,MAAM,KAAK,gBAAgB,EAAE;AAC9C,cAAI,CAAC,UAAU;AACd,mBAAO;AAAA,UACR;AAEA,iBAAO,IAAI;AAAA,YACV,KAAK;AAAA,YACL;AAAA,UACD;AAAA,QACD,SAAS,GAAG;AACX,eAAK,WAAW;AAAA,YACf,0CAA0C,EAAE;AAAA,YAC5C;AAAA,UACD;AACA,iBAAO;AAAA,QACR;AAAA,MACD,CAAC;AAAA,IACF;AAEA,WAAO,QAAQ,OAAO,SAAS;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA,EAKO,sBAAsB,UAAkB;AAC9C,UAAM,SAAS,yBAAyB;AACxC,SAAK,uBAAuB,UAAU,MAAM;AAC5C,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA,EAKA,MAAa,QAAQ,SAAoD;AACxE,UAAM,WAAW,IAAI;AAAA,MACpB,KAAK,OAAO,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC,EAAE,IAAI,MAAM,MAAM,CAAC,IAAI,KAAK,CAAC;AAAA,IACvD;AACA,UAAM,UAAwD,CAAC;AAC/D,UAAM,OAA2B,CAAC;AAClC,QAAI,SAAS;AAMb,aACK,IAAI,GACR,IAAI,QAAQ,UACZ,IAAI,uBACH,SAAS,KAAK,QAAQ,SAAS,qBAChC,KACC;AACD,YAAM,SAAS,QAAQ,CAAC;AACxB,YAAM,gBAAgB,SAAS,IAAI,OAAO,EAAE;AAC5C,UAAI,kBAAkB,QAAW;AAChC,iBAAS,OAAO,OAAO,EAAE;AACzB,gBAAQ,KAAK;AAAA,UACZ,IAAI,OAAO;AAAA,UACX,KAAK;AAAA,UACL,OAAO;AAAA,QACR,CAAC;AACD,kBAAU;AACV;AAAA,MACD;AAEA,YAAM,MAAM,OAAO,OAAO;AAC1B,UAAI,CAAC,KAAK;AACT;AAAA,MACD;AAEA,YAAM,WAAW,SAAS,WAAW,KAAK,UAAU,GAAG,CAAC;AACxD,WAAK,KAAK,KAAK,iBAAiB,OAAO,IAAI,GAAG,CAAC;AAC/C,cAAQ,KAAK;AAAA,QACZ,IAAI,OAAO;AAAA,QACX,KAAK;AAAA,QACL,OAAO,SAAS;AAAA,MACjB,CAAC;AACD,gBAAU,SAAS;AAAA,IACpB;AAEA,eAAW,MAAM,SAAS,KAAK,GAAG;AACjC,WAAK,KAAK,KAAK,kBAAkB,EAAE,EAAE,MAAM,MAAM,MAAS,CAAC;AAAA,IAC5D;AAEA,SAAK,OAAO,MAAM,OAAO;AACzB,UAAM,QAAQ,IAAI,IAAI;AAAA,EACvB;AA6CD;AA3KsB,wBAAf;AAAA,EAoBJ;AAAA,EAEA;AAAA,EACA;AAAA,GAvBmB;AA6Kf,MAAM,8BAA8B,sBAAsB;AAAA,EAvOjE,OAuOiE;AAAA;AAAA;AAAA,EAChD,QAAQ,oBAAI,IAAoC;AAAA,EAEhE,MAAgB,gBAAgB,IAAY;AAC3C,WAAO,QAAQ,QAAQ,KAAK,MAAM,IAAI,EAAE,CAAC;AAAA,EAC1C;AAAA,EAEU,iBAAiB,IAAY,UAAkC;AACxE,SAAK,MAAM,IAAI,IAAI,QAAQ;AAC3B,WAAO,QAAQ,QAAQ;AAAA,EACxB;AAAA,EAEU,kBAAkB,IAAY;AACvC,SAAK,MAAM,OAAO,EAAE;AACpB,WAAO,QAAQ,QAAQ;AAAA,EACxB;AAAA,EAEU,sBACT,IACkC;AAClC,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC1C;AAAA,EAEU,uBACT,IACA,OACgB;AAChB,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC1C;AAAA,EAEU,2BACT,IACA,QACA,QACoB;AACpB,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC1C;AACD;AAEO,IAAM,oBAAN,cAAgC,sBAAsB;AAAA,EAG5D,YACsB,oBACJ,gBACJ,YACa,kBACK,aACV,oBACpB;AACD,UAAM,oBAAoB,gBAAgB,UAAU;AAHrB;AAI/B,SAAK,YAAY,IAAI;AAAA,MACpB,mBAAmB;AAAA,MACnB,iBAAiB,aAAa,EAAE;AAAA,MAChC;AAAA,IACD;AAAA,EACD;AAAA,EA/RD,OA8Q6D;AAAA;AAAA;AAAA,EAC3C;AAAA,EAkBjB,MAAgB,gBAAgB,IAAY;AAC3C,UAAM,WAAW,MAAM,KAAK,YAAY;AAAA,MACvC,KAAK,kBAAkB,EAAE;AAAA,IAC1B;AACA,WAAO,KAAK,MAAM,SAAS,MAAM,SAAS,CAAC;AAAA,EAC5C;AAAA,EAEU,iBAAiB,IAAY,UAAkC;AACxE,WAAO,KAAK,YAAY;AAAA,MACvB,KAAK,kBAAkB,EAAE;AAAA,MACzB,SAAS,WAAW,KAAK,UAAU,QAAQ,CAAC;AAAA,IAC7C;AAAA,EACD;AAAA,EAEU,kBAAkB,IAAY;AACvC,WAAO,KAAK,YACV,IAAI,KAAK,kBAAkB,EAAE,CAAC,EAC9B,MAAM,MAAM,MAAS;AAAA,EACxB;AAAA,EAEA,MAAgB,2BACf,IACA,QACA,QACoB;AACpB,QAAI;AACH,YAAM,EAAE,MAAM,IAAI,MAAM,KAAK,YAAY;AAAA,QACxC,KAAK,oBAAoB,EAAE;AAAA,QAC3B,EAAE,UAAU,QAAQ,OAAO;AAAA,MAC5B;AACA,aAAO;AAAA,IACR,QAAQ;AACP,aAAO,SAAS,MAAM,CAAC;AAAA,IACxB;AAAA,EACD;AAAA,EAEA,MAAgB,sBACf,IACkC;AAClC,QAAI;AACH,YAAM,EAAE,MAAM,IAAI,MAAM,KAAK,YAAY;AAAA,QACxC,KAAK,oBAAoB,EAAE;AAAA,MAC5B;AACA,aAAO;AAAA,IACR,QAAQ;AACP,aAAO,eAAe,SAAS,MAAM,CAAC,CAAC;AAAA,IACxC;AAAA,EACD;AAAA,EAEA,MAAgB,uBACf,IACA,OACC;AACD,UAAM,KAAK,YAAY,WAAW,KAAK,oBAAoB,EAAE,GAAG,KAAK;AAAA,EACtE;AAAA;AAAA;AAAA;AAAA,EAKA,MAAsB,QAAQ,SAAqC;AAClE,UAAM,MAAM,QAAQ,OAAO;AAC3B,QAAI,KAAK,OAAO,IAAI,qBAAqB;AACxC,YAAM,KAAK,oBAAoB;AAAA,IAChC;AAAA,EACD;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAc,sBAAsB;AACnC,UAAM,EAAE,SAAS,IAAI,MAAM,KAAK,YAAY,QAAQ,KAAK,SAAS;AAClE,QAAI,CAAC,UAAU;AACd;AAAA,IACD;AAEA,UAAM,SAAS,IAAI;AAAA,MAClB,KAAK,OACH,IAAI,CAAC,CAAC,EACN,OAAO,CAAC,MAAM,EAAE,QAAQ,eAAe,EACvC,IAAI,CAAC,MAAM,EAAE,EAAE;AAAA,IAClB;AAEA,UAAM,QAAQ;AAAA,MACb,SACE;AAAA,QACA,CAAC,UAAU,CAAC,OAAO,IAAI,MAAM,KAAK,QAAQ,aAAa,EAAE,CAAC;AAAA,MAC3D,EACC;AAAA,QAAI,CAAC,UACL,KAAK,YAAY,IAAI,MAAM,QAAQ,EAAE,MAAM,MAAM,MAAS;AAAA,MAC3D;AAAA,IACF;AAAA,EACD;AAAA,EAEQ,kBAAkB,IAAY;AACrC,WAAO,IAAI,SAAS,KAAK,WAAW,GAAG,EAAE,OAAO;AAAA,EACjD;AAAA,EAEQ,oBAAoB,IAAY;AACvC,WAAO,IAAI,SAAS,KAAK,WAAW,GAAG,EAAE,SAAS;AAAA,EACnD;AACD;AAxHa,oBAAN;AAAA,EAIJ;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,GATU;",
  "names": []
}
