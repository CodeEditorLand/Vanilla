{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/testing/common/testService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { assert } from \"../../../../base/common/assert.js\";\nimport { CancellationToken } from \"../../../../base/common/cancellation.js\";\nimport type { Event } from \"../../../../base/common/event.js\";\nimport { Iterable } from \"../../../../base/common/iterator.js\";\nimport type { IDisposable } from \"../../../../base/common/lifecycle.js\";\nimport { MarshalledId } from \"../../../../base/common/marshallingIds.js\";\nimport type { IObservable } from \"../../../../base/common/observable.js\";\nimport {\n\ttype IPrefixTreeNode,\n\tWellDefinedPrefixTree,\n} from \"../../../../base/common/prefixTree.js\";\nimport type { URI } from \"../../../../base/common/uri.js\";\nimport type { Position } from \"../../../../editor/common/core/position.js\";\nimport type { Location } from \"../../../../editor/common/languages.js\";\nimport { createDecorator } from \"../../../../platform/instantiation/common/instantiation.js\";\nimport type { IUriIdentityService } from \"../../../../platform/uriIdentity/common/uriIdentity.js\";\nimport type { MutableObservableValue } from \"./observableValue.js\";\nimport type { TestExclusions } from \"./testExclusions.js\";\nimport { TestId } from \"./testId.js\";\nimport type { ITestResult } from \"./testResult.js\";\nimport {\n\ttype AbstractIncrementalTestCollection,\n\ttype ICallProfileRunHandler,\n\ttype IStartControllerTests,\n\ttype IStartControllerTestsResult,\n\ttype ITestItemContext,\n\ttype IncrementalTestCollectionItem,\n\ttype InternalTestItem,\n\ttype ResolvedTestRunRequest,\n\ttype TestControllerCapability,\n\tTestItemExpandState,\n\ttype TestMessageFollowupRequest,\n\ttype TestMessageFollowupResponse,\n\ttype TestRunProfileBitset,\n\ttype TestsDiff,\n} from \"./testTypes.js\";\n\nexport const ITestService = createDecorator<ITestService>(\"testService\");\n\nexport interface IMainThreadTestController {\n\treadonly id: string;\n\treadonly label: IObservable<string>;\n\treadonly capabilities: IObservable<TestControllerCapability>;\n\tsyncTests(token: CancellationToken): Promise<void>;\n\trefreshTests(token: CancellationToken): Promise<void>;\n\tconfigureRunProfile(profileId: number): void;\n\texpandTest(id: string, levels: number): Promise<void>;\n\tgetRelatedCode(\n\t\ttestId: string,\n\t\ttoken: CancellationToken,\n\t): Promise<Location[]>;\n\tstartContinuousRun(\n\t\trequest: ICallProfileRunHandler[],\n\t\ttoken: CancellationToken,\n\t): Promise<IStartControllerTestsResult[]>;\n\trunTests(\n\t\trequest: IStartControllerTests[],\n\t\ttoken: CancellationToken,\n\t): Promise<IStartControllerTestsResult[]>;\n}\n\nexport interface IMainThreadTestHostProxy {\n\tprovideTestFollowups(\n\t\treq: TestMessageFollowupRequest,\n\t\ttoken: CancellationToken,\n\t): Promise<TestMessageFollowupResponse[]>;\n\tgetTestsRelatedToCode(\n\t\turi: URI,\n\t\tposition: Position,\n\t\ttoken: CancellationToken,\n\t): Promise<string[]>;\n\texecuteTestFollowup(id: number): Promise<void>;\n\tdisposeTestFollowups(ids: number[]): void;\n}\n\nexport interface IMainThreadTestCollection\n\textends AbstractIncrementalTestCollection<IncrementalTestCollectionItem> {\n\tonBusyProvidersChange: Event<number>;\n\n\t/**\n\t * Number of providers working to discover tests.\n\t */\n\tbusyProviders: number;\n\n\t/**\n\t * Root item IDs.\n\t */\n\trootIds: Iterable<string>;\n\n\t/**\n\t * Root items, correspond to registered controllers.\n\t */\n\trootItems: Iterable<IncrementalTestCollectionItem>;\n\n\t/**\n\t * Iterates over every test in the collection, in strictly descending\n\t * order of depth.\n\t */\n\tall: Iterable<IncrementalTestCollectionItem>;\n\n\t/**\n\t * Gets a node in the collection by ID.\n\t */\n\tgetNodeById(id: string): IncrementalTestCollectionItem | undefined;\n\n\t/**\n\t * Gets all tests that have the given URL. Tests returned from this\n\t * method are *not* in any particular order.\n\t */\n\tgetNodeByUrl(uri: URI): Iterable<IncrementalTestCollectionItem>;\n\n\t/**\n\t * Requests that children be revealed for the given test. \"Levels\" may\n\t * be infinite.\n\t */\n\texpand(testId: string, levels: number): Promise<void>;\n\n\t/**\n\t * Gets a diff that adds all items currently in the tree to a new collection,\n\t * allowing it to fully hydrate.\n\t */\n\tgetReviverDiff(): TestsDiff;\n}\n\nexport const testCollectionIsEmpty = (collection: IMainThreadTestCollection) =>\n\t!Iterable.some(collection.rootItems, (r) => r.children.size > 0);\n\nexport const getContextForTestItem = (\n\tcollection: IMainThreadTestCollection,\n\tid: string | TestId,\n) => {\n\tif (typeof id === \"string\") {\n\t\tid = TestId.fromString(id);\n\t}\n\n\tif (id.isRoot) {\n\t\treturn { controller: id.toString() };\n\t}\n\n\tconst context: ITestItemContext = {\n\t\t$mid: MarshalledId.TestItemContext,\n\t\ttests: [],\n\t};\n\tfor (const i of id.idsFromRoot()) {\n\t\tif (!i.isRoot) {\n\t\t\tconst test = collection.getNodeById(i.toString());\n\t\t\tif (test) {\n\t\t\t\tcontext.tests.push(test);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn context;\n};\n\n/**\n * Ensures the test with the given ID exists in the collection, if possible.\n * If cancellation is requested, or the test cannot be found, it will return\n * undefined.\n */\nexport const expandAndGetTestById = async (\n\tcollection: IMainThreadTestCollection,\n\tid: string,\n\tct = CancellationToken.None,\n) => {\n\tconst idPath = [...TestId.fromString(id).idsFromRoot()];\n\n\tlet expandToLevel = 0;\n\tfor (\n\t\tlet i = idPath.length - 1;\n\t\t!ct.isCancellationRequested && i >= expandToLevel;\n\t) {\n\t\tconst id = idPath[i].toString();\n\t\tconst existing = collection.getNodeById(id);\n\t\tif (!existing) {\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (i === idPath.length - 1) {\n\t\t\treturn existing;\n\t\t}\n\n\t\t// expand children only if it looks like it's necessary\n\t\tif (!existing.children.has(idPath[i + 1].toString())) {\n\t\t\tawait collection.expand(id, 0);\n\t\t}\n\n\t\texpandToLevel = i + 1; // avoid an infinite loop if the test does not exist\n\t\ti = idPath.length - 1;\n\t}\n\treturn undefined;\n};\n\n/**\n * Waits for the test to no longer be in the \"busy\" state.\n */\nconst waitForTestToBeIdle = (\n\ttestService: ITestService,\n\ttest: IncrementalTestCollectionItem,\n) => {\n\tif (!test.item.busy) {\n\t\treturn;\n\t}\n\n\treturn new Promise<void>((resolve) => {\n\t\tconst l = testService.onDidProcessDiff(() => {\n\t\t\tif (\n\t\t\t\ttestService.collection.getNodeById(test.item.extId)?.item\n\t\t\t\t\t.busy !== true\n\t\t\t) {\n\t\t\t\tresolve(); // removed, or no longer busy\n\t\t\t\tl.dispose();\n\t\t\t}\n\t\t});\n\t});\n};\n\n/**\n * Iterator that expands to and iterates through tests in the file. Iterates\n * in strictly descending order.\n */\nexport const testsInFile = async function* (\n\ttestService: ITestService,\n\tident: IUriIdentityService,\n\turi: URI,\n\twaitForIdle = true,\n): AsyncIterable<IncrementalTestCollectionItem> {\n\tfor (const test of testService.collection.all) {\n\t\tif (!test.item.uri) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ident.extUri.isEqual(uri, test.item.uri)) {\n\t\t\tyield test;\n\t\t}\n\n\t\tif (ident.extUri.isEqualOrParent(uri, test.item.uri)) {\n\t\t\tif (test.expand === TestItemExpandState.Expandable) {\n\t\t\t\tawait testService.collection.expand(test.item.extId, 1);\n\t\t\t}\n\t\t\tif (waitForIdle) {\n\t\t\t\tawait waitForTestToBeIdle(testService, test);\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Iterator that iterates to the top-level children of tests under the given\n * the URI.\n */\nexport const testsUnderUri = async function* (\n\ttestService: ITestService,\n\tident: IUriIdentityService,\n\turi: URI,\n\twaitForIdle = true,\n): AsyncIterable<IncrementalTestCollectionItem> {\n\tconst queue = [testService.collection.rootIds];\n\twhile (queue.length) {\n\t\tfor (const testId of queue.pop()!) {\n\t\t\tconst test = testService.collection.getNodeById(testId);\n\n\t\t\t// Expand tests with URIs that are parent of the item, add tests\n\t\t\t// that are within the URI. Don't add their children, since those\n\t\t\t// tests already encompass their children.\n\t\t\tif (!test) {\n\t\t\t\t// no-op\n\t\t\t} else if (\n\t\t\t\ttest.item.uri &&\n\t\t\t\tident.extUri.isEqualOrParent(test.item.uri, uri)\n\t\t\t) {\n\t\t\t\tyield test;\n\t\t\t} else if (\n\t\t\t\t!test.item.uri ||\n\t\t\t\tident.extUri.isEqualOrParent(uri, test.item.uri)\n\t\t\t) {\n\t\t\t\tif (test.expand === TestItemExpandState.Expandable) {\n\t\t\t\t\tawait testService.collection.expand(test.item.extId, 1);\n\t\t\t\t}\n\t\t\t\tif (waitForIdle) {\n\t\t\t\t\tawait waitForTestToBeIdle(testService, test);\n\t\t\t\t}\n\t\t\t\tqueue.push(test.children.values());\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Simplifies the array of tests by preferring test item parents if all of\n * their children are included.\n */\nexport const simplifyTestsToExecute = (\n\tcollection: IMainThreadTestCollection,\n\ttests: IncrementalTestCollectionItem[],\n): IncrementalTestCollectionItem[] => {\n\tif (tests.length < 2) {\n\t\treturn tests;\n\t}\n\n\tconst tree = new WellDefinedPrefixTree<IncrementalTestCollectionItem>();\n\tfor (const test of tests) {\n\t\ttree.insert(TestId.fromString(test.item.extId).path, test);\n\t}\n\n\tconst out: IncrementalTestCollectionItem[] = [];\n\n\t// Returns the node if it and any children should be included. Otherwise\n\t// pushes into the `out` any individual children that should be included.\n\tconst process = (\n\t\tcurrentId: string[],\n\t\tnode: IPrefixTreeNode<IncrementalTestCollectionItem>,\n\t) => {\n\t\t// directly included, don't try to over-specify, and children should be ignored\n\t\tif (node.value) {\n\t\t\treturn node.value;\n\t\t}\n\n\t\tassert(!!node.children, \"expect to have children\");\n\n\t\tconst thisChildren: IncrementalTestCollectionItem[] = [];\n\t\tfor (const [part, child] of node.children) {\n\t\t\tcurrentId.push(part);\n\t\t\tconst c = process(currentId, child);\n\t\t\tif (c) {\n\t\t\t\tthisChildren.push(c);\n\t\t\t}\n\t\t\tcurrentId.pop();\n\t\t}\n\n\t\tif (!thisChildren.length) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are multiple children and we have all of them, then tell the\n\t\t// parent this node should be included. Otherwise include children individually.\n\t\tconst id = new TestId(currentId);\n\t\tconst test = collection.getNodeById(id.toString());\n\t\tif (test?.children.size === thisChildren.length) {\n\t\t\treturn test;\n\t\t}\n\n\t\tout.push(...thisChildren);\n\t\treturn;\n\t};\n\n\tfor (const [id, node] of tree.entries) {\n\t\tconst n = process([id], node);\n\t\tif (n) {\n\t\t\tout.push(n);\n\t\t}\n\t}\n\n\treturn out;\n};\n\n/**\n * A run request that expresses the intent of the request and allows the\n * test service to resolve the specifics of the group.\n */\nexport interface AmbiguousRunTestsRequest {\n\t/** Group to run */\n\tgroup: TestRunProfileBitset;\n\t/** Tests to run. Allowed to be from different controllers */\n\ttests: readonly InternalTestItem[];\n\t/** Tests to exclude. If not given, the current UI excluded tests are used */\n\texclude?: InternalTestItem[];\n\t/** Whether this was triggered from an auto run. */\n\tcontinuous?: boolean;\n}\n\nexport interface ITestFollowup {\n\tmessage: string;\n\texecute(): Promise<void>;\n}\n\nexport interface ITestFollowups extends IDisposable {\n\tfollowups: ITestFollowup[];\n}\n\nexport interface ITestService {\n\treadonly _serviceBrand: undefined;\n\t/**\n\t * Fires when the user requests to cancel a test run -- or all runs, if no\n\t * runId is given.\n\t */\n\treadonly onDidCancelTestRun: Event<{\n\t\trunId: string | undefined;\n\t\ttaskId: string | undefined;\n\t}>;\n\n\t/**\n\t * Event that fires when the excluded tests change.\n\t */\n\treadonly excluded: TestExclusions;\n\n\t/**\n\t * Test collection instance.\n\t */\n\treadonly collection: IMainThreadTestCollection;\n\n\t/**\n\t * Event that fires immediately before a diff is processed.\n\t */\n\treadonly onWillProcessDiff: Event<TestsDiff>;\n\n\t/**\n\t * Event that fires after a diff is processed.\n\t */\n\treadonly onDidProcessDiff: Event<TestsDiff>;\n\n\t/**\n\t * Whether inline editor decorations should be visible.\n\t */\n\treadonly showInlineOutput: MutableObservableValue<boolean>;\n\n\t/**\n\t * Registers an interface that represents an extension host..\n\t */\n\tregisterExtHost(controller: IMainThreadTestHostProxy): IDisposable;\n\n\t/**\n\t * Registers an interface that runs tests for the given provider ID.\n\t */\n\tregisterTestController(\n\t\tproviderId: string,\n\t\tcontroller: IMainThreadTestController,\n\t): IDisposable;\n\n\t/**\n\t * Gets a registered test controller by ID.\n\t */\n\tgetTestController(\n\t\tcontrollerId: string,\n\t): IMainThreadTestController | undefined;\n\n\t/**\n\t * Refreshes tests for the controller, or all controllers if no ID is given.\n\t */\n\trefreshTests(controllerId?: string): Promise<void>;\n\n\t/**\n\t * Cancels any ongoing test refreshes.\n\t */\n\tcancelRefreshTests(): void;\n\n\t/**\n\t * Requests that tests be executed continuously, until the token is cancelled.\n\t */\n\tstartContinuousRun(\n\t\treq: ResolvedTestRunRequest,\n\t\ttoken: CancellationToken,\n\t): Promise<void>;\n\n\t/**\n\t * Requests that tests be executed.\n\t */\n\trunTests(\n\t\treq: AmbiguousRunTestsRequest,\n\t\ttoken?: CancellationToken,\n\t): Promise<ITestResult>;\n\n\t/**\n\t * Requests that tests be executed.\n\t */\n\trunResolvedTests(\n\t\treq: ResolvedTestRunRequest,\n\t\ttoken?: CancellationToken,\n\t): Promise<ITestResult>;\n\n\t/**\n\t * Provides followup actions for a test run.\n\t */\n\tprovideTestFollowups(\n\t\treq: TestMessageFollowupRequest,\n\t\ttoken: CancellationToken,\n\t): Promise<ITestFollowups>;\n\n\t/**\n\t * Ensures the test diff from the remote ext host is flushed and waits for\n\t * any \"busy\" tests to become idle before resolving.\n\t */\n\tsyncTests(): Promise<void>;\n\n\t/**\n\t * Cancels an ongoing test run by its ID, or all runs if no ID is given.\n\t */\n\tcancelTestRun(runId?: string, taskId?: string): void;\n\n\t/**\n\t * Publishes a test diff for a controller.\n\t */\n\tpublishDiff(controllerId: string, diff: TestsDiff): void;\n\n\t/**\n\t * Gets all tests related to the given code position.\n\t */\n\tgetTestsRelatedToCode(\n\t\turi: URI,\n\t\tposition: Position,\n\t\ttoken?: CancellationToken,\n\t): Promise<InternalTestItem[]>;\n\n\t/**\n\t * Gets code related to the given test item.\n\t */\n\tgetCodeRelatedToTest(\n\t\ttest: InternalTestItem,\n\t\ttoken?: CancellationToken,\n\t): Promise<Location[]>;\n}\n"],
  "mappings": "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",
  "names": ["id"]
}
