var T=Object.defineProperty;var C=Object.getOwnPropertyDescriptor;var u=(n,i,t,r)=>{for(var s=r>1?void 0:r?C(i,t):i,a=n.length-1,o;a>=0;a--)(o=n[a])&&(s=(r?o(i,t,s):o(s))||s);return r&&s&&T(i,t,s),s},l=(n,i)=>(t,r)=>i(t,r,n);import{CancellationTokenSource as b}from"../../../../../vs/base/common/cancellation.js";import{Iterable as I}from"../../../../../vs/base/common/iterator.js";import{Disposable as h,MutableDisposable as y}from"../../../../../vs/base/common/lifecycle.js";import{observableValue as m,transaction as S}from"../../../../../vs/base/common/observable.js";import{IConfigurationService as k}from"../../../../../vs/platform/configuration/common/configuration.js";import{IContextKeyService as w}from"../../../../../vs/platform/contextkey/common/contextkey.js";import{createDecorator as R}from"../../../../../vs/platform/instantiation/common/instantiation.js";import{bindContextKey as d,observableConfigValue as O}from"../../../../../vs/platform/observable/common/platformObservableUtils.js";import{TestingConfigKeys as _}from"../../../../../vs/workbench/contrib/testing/common/configuration.js";import{Testing as V}from"../../../../../vs/workbench/contrib/testing/common/constants.js";import"../../../../../vs/workbench/contrib/testing/common/testCoverage.js";import"../../../../../vs/workbench/contrib/testing/common/testId.js";import{TestingContextKeys as c}from"../../../../../vs/workbench/contrib/testing/common/testingContextKeys.js";import"../../../../../vs/workbench/contrib/testing/common/testResult.js";import{ITestResultService as D}from"../../../../../vs/workbench/contrib/testing/common/testResultService.js";import{IViewsService as E}from"../../../../../vs/workbench/services/views/common/viewsService.js";const ee=R("testCoverageService");let v=class extends h{constructor(t,r,s,a){super();this.viewsService=a;const o=O(_.CoverageToolbarEnabled,!0,s);this._register(d(c.coverageToolbarEnabled,t,e=>o.read(e))),this._register(d(c.inlineCoverageEnabled,t,e=>this.showInline.read(e))),this._register(d(c.isTestCoverageOpen,t,e=>!!this.selected.read(e))),this._register(d(c.hasPerTestCoverage,t,e=>!I.isEmpty(this.selected.read(e)?.allPerTestIDs()))),this._register(d(c.isCoverageFilteredToTest,t,e=>!!this.filterToTest.read(e))),this._register(r.onResultsChanged(e=>{if("completed"in e){const f=e.completed.tasks.find(g=>g.coverage.get());f?this.openCoverage(f,!1):this.closeCoverage()}else if("removed"in e&&this.selected.get()){const f=this.selected.get()?.fromTaskId;e.removed.some(g=>g.tasks.some(p=>p.id===f))&&this.closeCoverage()}}))}lastOpenCts=this._register(new y);selected=m("testCoverage",void 0);filterToTest=m("filterToTest",void 0);showInline=m("inlineCoverage",!1);async openCoverage(t,r=!0){this.lastOpenCts.value?.cancel();const s=this.lastOpenCts.value=new b,a=t.coverage.get();a&&(S(o=>{this.filterToTest.set(void 0,o),this.selected.set(a,o)}),r&&!s.token.isCancellationRequested&&this.viewsService.openView(V.CoverageViewId,!0))}closeCoverage(){this.selected.set(void 0,void 0)}};v=u([l(0,w),l(1,D),l(2,k),l(3,E)],v);export{ee as ITestCoverageService,v as TestCoverageService};
