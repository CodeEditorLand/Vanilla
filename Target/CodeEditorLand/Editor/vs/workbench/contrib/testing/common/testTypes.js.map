{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/testing/common/testTypes.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { IMarkdownString } from \"../../../../base/common/htmlContent.js\";\nimport type { MarshalledId } from \"../../../../base/common/marshallingIds.js\";\nimport { URI, type UriComponents } from \"../../../../base/common/uri.js\";\nimport {\n\ttype IPosition,\n\tPosition,\n} from \"../../../../editor/common/core/position.js\";\nimport { type IRange, Range } from \"../../../../editor/common/core/range.js\";\nimport { TestId } from \"./testId.js\";\n\nexport enum TestResultState {\n\tUnset = 0,\n\tQueued = 1,\n\tRunning = 2,\n\tPassed = 3,\n\tFailed = 4,\n\tSkipped = 5,\n\tErrored = 6,\n}\n\nexport const testResultStateToContextValues: {\n\t[K in TestResultState]: string;\n} = {\n\t[TestResultState.Unset]: \"unset\",\n\t[TestResultState.Queued]: \"queued\",\n\t[TestResultState.Running]: \"running\",\n\t[TestResultState.Passed]: \"passed\",\n\t[TestResultState.Failed]: \"failed\",\n\t[TestResultState.Skipped]: \"skipped\",\n\t[TestResultState.Errored]: \"errored\",\n};\n\n/** note: keep in sync with TestRunProfileKind in vscode.d.ts */\nexport enum ExtTestRunProfileKind {\n\tRun = 1,\n\tDebug = 2,\n\tCoverage = 3,\n}\n\nexport enum TestControllerCapability {\n\tRefresh = 1 << 1,\n\tCodeRelatedToTest = 1 << 2,\n\tTestRelatedToCode = 1 << 3,\n}\n\nexport enum TestRunProfileBitset {\n\tRun = 1 << 1,\n\tDebug = 1 << 2,\n\tCoverage = 1 << 3,\n\tHasNonDefaultProfile = 1 << 4,\n\tHasConfigurable = 1 << 5,\n\tSupportsContinuousRun = 1 << 6,\n}\n\n/**\n * List of all test run profile bitset values.\n */\nexport const testRunProfileBitsetList = [\n\tTestRunProfileBitset.Run,\n\tTestRunProfileBitset.Debug,\n\tTestRunProfileBitset.Coverage,\n\tTestRunProfileBitset.HasNonDefaultProfile,\n\tTestRunProfileBitset.HasConfigurable,\n\tTestRunProfileBitset.SupportsContinuousRun,\n];\n\n/**\n * DTO for a controller's run profiles.\n */\nexport interface ITestRunProfile {\n\tcontrollerId: string;\n\tprofileId: number;\n\tlabel: string;\n\tgroup: TestRunProfileBitset;\n\tisDefault: boolean;\n\ttag: string | null;\n\thasConfigurationHandler: boolean;\n\tsupportsContinuousRun: boolean;\n}\n\n/**\n * A fully-resolved request to run tests, passsed between the main thread\n * and extension host.\n */\nexport interface ResolvedTestRunRequest {\n\tgroup: TestRunProfileBitset;\n\ttargets: {\n\t\ttestIds: string[];\n\t\tcontrollerId: string;\n\t\tprofileId: number;\n\t}[];\n\texclude?: string[];\n\t/** Whether this is a continuous test run */\n\tcontinuous?: boolean;\n\t/** Whether this was trigged by a user action in UI. Default=true */\n\tpreserveFocus?: boolean;\n}\n\n/**\n * Request to the main thread to run a set of tests.\n */\nexport interface ExtensionRunTestsRequest {\n\tid: string;\n\tinclude: string[];\n\texclude: string[];\n\tcontrollerId: string;\n\tprofile?: { group: TestRunProfileBitset; id: number };\n\tpersist: boolean;\n\tpreserveFocus: boolean;\n\t/** Whether this is a result of a continuous test run request */\n\tcontinuous: boolean;\n}\n\n/**\n * Request parameters a controller run handler. This is different than\n * {@link IStartControllerTests}. The latter is used to ask for one or more test\n * runs tracked directly by the renderer.\n *\n * This alone can be used to start an autorun, without a specific associated runId.\n */\nexport interface ICallProfileRunHandler {\n\tcontrollerId: string;\n\tprofileId: number;\n\texcludeExtIds: string[];\n\ttestIds: string[];\n}\n\nexport const isStartControllerTests = (\n\tt: ICallProfileRunHandler | IStartControllerTests,\n): t is IStartControllerTests => (\"runId\" as keyof IStartControllerTests) in t;\n\n/**\n * Request from the main thread to run tests for a single controller.\n */\nexport interface IStartControllerTests extends ICallProfileRunHandler {\n\trunId: string;\n}\n\nexport interface IStartControllerTestsResult {\n\terror?: string;\n}\n\n/**\n * Location with a fully-instantiated Range and URI.\n */\nexport interface IRichLocation {\n\trange: Range;\n\turi: URI;\n}\n\n/** Subset of the IUriIdentityService */\nexport interface ITestUriCanonicalizer {\n\t/** @link import('vs/platform/uriIdentity/common/uriIdentity').IUriIdentityService */\n\tasCanonicalUri(uri: URI): URI;\n}\n\nexport namespace IRichLocation {\n\texport interface Serialize {\n\t\trange: IRange;\n\t\turi: UriComponents;\n\t}\n\n\texport const serialize = (\n\t\tlocation: Readonly<IRichLocation>,\n\t): Serialize => ({\n\t\trange: location.range.toJSON(),\n\t\turi: location.uri.toJSON(),\n\t});\n\n\texport const deserialize = (\n\t\turiIdentity: ITestUriCanonicalizer,\n\t\tlocation: Serialize,\n\t): IRichLocation => ({\n\t\trange: Range.lift(location.range),\n\t\turi: uriIdentity.asCanonicalUri(URI.revive(location.uri)),\n\t});\n}\n\nexport enum TestMessageType {\n\tError = 0,\n\tOutput = 1,\n}\n\nexport interface ITestMessageStackFrame {\n\tlabel: string;\n\turi: URI | undefined;\n\tposition: Position | undefined;\n}\n\nexport namespace ITestMessageStackFrame {\n\texport interface Serialized {\n\t\tlabel: string;\n\t\turi: UriComponents | undefined;\n\t\tposition: IPosition | undefined;\n\t}\n\n\texport const serialize = (\n\t\tstack: Readonly<ITestMessageStackFrame>,\n\t): Serialized => ({\n\t\tlabel: stack.label,\n\t\turi: stack.uri?.toJSON(),\n\t\tposition: stack.position?.toJSON(),\n\t});\n\n\texport const deserialize = (\n\t\turiIdentity: ITestUriCanonicalizer,\n\t\tstack: Serialized,\n\t): ITestMessageStackFrame => ({\n\t\tlabel: stack.label,\n\t\turi: stack.uri\n\t\t\t? uriIdentity.asCanonicalUri(URI.revive(stack.uri))\n\t\t\t: undefined,\n\t\tposition: stack.position ? Position.lift(stack.position) : undefined,\n\t});\n}\n\nexport interface ITestErrorMessage {\n\tmessage: string | IMarkdownString;\n\ttype: TestMessageType.Error;\n\texpected: string | undefined;\n\tactual: string | undefined;\n\tcontextValue: string | undefined;\n\tlocation: IRichLocation | undefined;\n\tstackTrace: undefined | ITestMessageStackFrame[];\n}\n\nexport namespace ITestErrorMessage {\n\texport interface Serialized {\n\t\tmessage: string | IMarkdownString;\n\t\ttype: TestMessageType.Error;\n\t\texpected: string | undefined;\n\t\tactual: string | undefined;\n\t\tcontextValue: string | undefined;\n\t\tlocation: IRichLocation.Serialize | undefined;\n\t\tstackTrace: undefined | ITestMessageStackFrame.Serialized[];\n\t}\n\n\texport const serialize = (\n\t\tmessage: Readonly<ITestErrorMessage>,\n\t): Serialized => ({\n\t\tmessage: message.message,\n\t\ttype: TestMessageType.Error,\n\t\texpected: message.expected,\n\t\tactual: message.actual,\n\t\tcontextValue: message.contextValue,\n\t\tlocation: message.location && IRichLocation.serialize(message.location),\n\t\tstackTrace: message.stackTrace?.map(ITestMessageStackFrame.serialize),\n\t});\n\n\texport const deserialize = (\n\t\turiIdentity: ITestUriCanonicalizer,\n\t\tmessage: Serialized,\n\t): ITestErrorMessage => ({\n\t\tmessage: message.message,\n\t\ttype: TestMessageType.Error,\n\t\texpected: message.expected,\n\t\tactual: message.actual,\n\t\tcontextValue: message.contextValue,\n\t\tlocation:\n\t\t\tmessage.location &&\n\t\t\tIRichLocation.deserialize(uriIdentity, message.location),\n\t\tstackTrace:\n\t\t\tmessage.stackTrace &&\n\t\t\tmessage.stackTrace.map((s) =>\n\t\t\t\tITestMessageStackFrame.deserialize(uriIdentity, s),\n\t\t\t),\n\t});\n}\n\nexport interface ITestOutputMessage {\n\tmessage: string;\n\ttype: TestMessageType.Output;\n\toffset: number;\n\tlength: number;\n\tmarker?: number;\n\tlocation: IRichLocation | undefined;\n}\n\n/**\n * Gets the TTY marker ID for either starting or ending\n * an ITestOutputMessage.marker of the given ID.\n */\nexport const getMarkId = (marker: number, start: boolean) =>\n\t`${start ? \"s\" : \"e\"}${marker}`;\n\nexport namespace ITestOutputMessage {\n\texport interface Serialized {\n\t\tmessage: string;\n\t\toffset: number;\n\t\tlength: number;\n\t\ttype: TestMessageType.Output;\n\t\tlocation: IRichLocation.Serialize | undefined;\n\t}\n\n\texport const serialize = (\n\t\tmessage: Readonly<ITestOutputMessage>,\n\t): Serialized => ({\n\t\tmessage: message.message,\n\t\ttype: TestMessageType.Output,\n\t\toffset: message.offset,\n\t\tlength: message.length,\n\t\tlocation: message.location && IRichLocation.serialize(message.location),\n\t});\n\n\texport const deserialize = (\n\t\turiIdentity: ITestUriCanonicalizer,\n\t\tmessage: Serialized,\n\t): ITestOutputMessage => ({\n\t\tmessage: message.message,\n\t\ttype: TestMessageType.Output,\n\t\toffset: message.offset,\n\t\tlength: message.length,\n\t\tlocation:\n\t\t\tmessage.location &&\n\t\t\tIRichLocation.deserialize(uriIdentity, message.location),\n\t});\n}\n\nexport type ITestMessage = ITestErrorMessage | ITestOutputMessage;\n\nexport namespace ITestMessage {\n\texport type Serialized =\n\t\t| ITestErrorMessage.Serialized\n\t\t| ITestOutputMessage.Serialized;\n\n\texport const serialize = (message: Readonly<ITestMessage>): Serialized =>\n\t\tmessage.type === TestMessageType.Error\n\t\t\t? ITestErrorMessage.serialize(message)\n\t\t\t: ITestOutputMessage.serialize(message);\n\n\texport const deserialize = (\n\t\turiIdentity: ITestUriCanonicalizer,\n\t\tmessage: Serialized,\n\t): ITestMessage =>\n\t\tmessage.type === TestMessageType.Error\n\t\t\t? ITestErrorMessage.deserialize(uriIdentity, message)\n\t\t\t: ITestOutputMessage.deserialize(uriIdentity, message);\n\n\texport const isDiffable = (\n\t\tmessage: ITestMessage,\n\t): message is ITestErrorMessage & { actual: string; expected: string } =>\n\t\tmessage.type === TestMessageType.Error &&\n\t\tmessage.actual !== undefined &&\n\t\tmessage.expected !== undefined;\n}\n\nexport interface ITestTaskState {\n\tstate: TestResultState;\n\tduration: number | undefined;\n\tmessages: ITestMessage[];\n}\n\nexport namespace ITestTaskState {\n\texport interface Serialized {\n\t\tstate: TestResultState;\n\t\tduration: number | undefined;\n\t\tmessages: ITestMessage.Serialized[];\n\t}\n\n\texport const serializeWithoutMessages = (\n\t\tstate: ITestTaskState,\n\t): Serialized => ({\n\t\tstate: state.state,\n\t\tduration: state.duration,\n\t\tmessages: [],\n\t});\n\n\texport const serialize = (state: Readonly<ITestTaskState>): Serialized => ({\n\t\tstate: state.state,\n\t\tduration: state.duration,\n\t\tmessages: state.messages.map(ITestMessage.serialize),\n\t});\n\n\texport const deserialize = (\n\t\turiIdentity: ITestUriCanonicalizer,\n\t\tstate: Serialized,\n\t): ITestTaskState => ({\n\t\tstate: state.state,\n\t\tduration: state.duration,\n\t\tmessages: state.messages.map((m) =>\n\t\t\tITestMessage.deserialize(uriIdentity, m),\n\t\t),\n\t});\n}\n\nexport interface ITestRunTask {\n\tid: string;\n\tname: string;\n\trunning: boolean;\n\tctrlId: string;\n}\n\nexport interface ITestTag {\n\treadonly id: string;\n}\n\nconst testTagDelimiter = \"\\0\";\n\nexport const namespaceTestTag = (ctrlId: string, tagId: string) =>\n\tctrlId + testTagDelimiter + tagId;\n\nexport const denamespaceTestTag = (namespaced: string) => {\n\tconst index = namespaced.indexOf(testTagDelimiter);\n\treturn {\n\t\tctrlId: namespaced.slice(0, index),\n\t\ttagId: namespaced.slice(index + 1),\n\t};\n};\n\nexport interface ITestTagDisplayInfo {\n\tid: string;\n}\n\n/**\n * The TestItem from .d.ts, as a plain object without children.\n */\nexport interface ITestItem {\n\t/** ID of the test given by the test controller */\n\textId: string;\n\tlabel: string;\n\ttags: string[];\n\tbusy: boolean;\n\tchildren?: never;\n\turi: URI | undefined;\n\trange: Range | null;\n\tdescription: string | null;\n\terror: string | IMarkdownString | null;\n\tsortText: string | null;\n}\n\nexport namespace ITestItem {\n\texport interface Serialized {\n\t\textId: string;\n\t\tlabel: string;\n\t\ttags: string[];\n\t\tbusy: boolean;\n\t\tchildren?: never;\n\t\turi: UriComponents | undefined;\n\t\trange: IRange | null;\n\t\tdescription: string | null;\n\t\terror: string | IMarkdownString | null;\n\t\tsortText: string | null;\n\t}\n\n\texport const serialize = (item: Readonly<ITestItem>): Serialized => ({\n\t\textId: item.extId,\n\t\tlabel: item.label,\n\t\ttags: item.tags,\n\t\tbusy: item.busy,\n\t\tchildren: undefined,\n\t\turi: item.uri?.toJSON(),\n\t\trange: item.range?.toJSON() || null,\n\t\tdescription: item.description,\n\t\terror: item.error,\n\t\tsortText: item.sortText,\n\t});\n\n\texport const deserialize = (\n\t\turiIdentity: ITestUriCanonicalizer,\n\t\tserialized: Serialized,\n\t): ITestItem => ({\n\t\textId: serialized.extId,\n\t\tlabel: serialized.label,\n\t\ttags: serialized.tags,\n\t\tbusy: serialized.busy,\n\t\tchildren: undefined,\n\t\turi: serialized.uri\n\t\t\t? uriIdentity.asCanonicalUri(URI.revive(serialized.uri))\n\t\t\t: undefined,\n\t\trange: serialized.range ? Range.lift(serialized.range) : null,\n\t\tdescription: serialized.description,\n\t\terror: serialized.error,\n\t\tsortText: serialized.sortText,\n\t});\n}\n\nexport enum TestItemExpandState {\n\tNotExpandable = 0,\n\tExpandable = 1,\n\tBusyExpanding = 2,\n\tExpanded = 3,\n}\n\n/**\n * TestItem-like shape, but with an ID and children as strings.\n */\nexport interface InternalTestItem {\n\t/** Controller ID from whence this test came */\n\tcontrollerId: string;\n\t/** Expandability state */\n\texpand: TestItemExpandState;\n\t/** Raw test item properties */\n\titem: ITestItem;\n}\n\nexport namespace InternalTestItem {\n\texport interface Serialized {\n\t\texpand: TestItemExpandState;\n\t\titem: ITestItem.Serialized;\n\t}\n\n\texport const serialize = (\n\t\titem: Readonly<InternalTestItem>,\n\t): Serialized => ({\n\t\texpand: item.expand,\n\t\titem: ITestItem.serialize(item.item),\n\t});\n\n\texport const deserialize = (\n\t\turiIdentity: ITestUriCanonicalizer,\n\t\tserialized: Serialized,\n\t): InternalTestItem => ({\n\t\t// the `controllerId` is derived from the test.item.extId. It's redundant\n\t\t// in the non-serialized InternalTestItem too, but there just because it's\n\t\t// checked against in many hot paths.\n\t\tcontrollerId: TestId.root(serialized.item.extId),\n\t\texpand: serialized.expand,\n\t\titem: ITestItem.deserialize(uriIdentity, serialized.item),\n\t});\n}\n\n/**\n * A partial update made to an existing InternalTestItem.\n */\nexport interface ITestItemUpdate {\n\textId: string;\n\texpand?: TestItemExpandState;\n\titem?: Partial<ITestItem>;\n}\n\nexport namespace ITestItemUpdate {\n\texport interface Serialized {\n\t\textId: string;\n\t\texpand?: TestItemExpandState;\n\t\titem?: Partial<ITestItem.Serialized>;\n\t}\n\n\texport const serialize = (u: Readonly<ITestItemUpdate>): Serialized => {\n\t\tlet item: Partial<ITestItem.Serialized> | undefined;\n\t\tif (u.item) {\n\t\t\titem = {};\n\t\t\tif (u.item.label !== undefined) {\n\t\t\t\titem.label = u.item.label;\n\t\t\t}\n\t\t\tif (u.item.tags !== undefined) {\n\t\t\t\titem.tags = u.item.tags;\n\t\t\t}\n\t\t\tif (u.item.busy !== undefined) {\n\t\t\t\titem.busy = u.item.busy;\n\t\t\t}\n\t\t\tif (u.item.uri !== undefined) {\n\t\t\t\titem.uri = u.item.uri?.toJSON();\n\t\t\t}\n\t\t\tif (u.item.range !== undefined) {\n\t\t\t\titem.range = u.item.range?.toJSON();\n\t\t\t}\n\t\t\tif (u.item.description !== undefined) {\n\t\t\t\titem.description = u.item.description;\n\t\t\t}\n\t\t\tif (u.item.error !== undefined) {\n\t\t\t\titem.error = u.item.error;\n\t\t\t}\n\t\t\tif (u.item.sortText !== undefined) {\n\t\t\t\titem.sortText = u.item.sortText;\n\t\t\t}\n\t\t}\n\n\t\treturn { extId: u.extId, expand: u.expand, item };\n\t};\n\n\texport const deserialize = (u: Serialized): ITestItemUpdate => {\n\t\tlet item: Partial<ITestItem> | undefined;\n\t\tif (u.item) {\n\t\t\titem = {};\n\t\t\tif (u.item.label !== undefined) {\n\t\t\t\titem.label = u.item.label;\n\t\t\t}\n\t\t\tif (u.item.tags !== undefined) {\n\t\t\t\titem.tags = u.item.tags;\n\t\t\t}\n\t\t\tif (u.item.busy !== undefined) {\n\t\t\t\titem.busy = u.item.busy;\n\t\t\t}\n\t\t\tif (u.item.range !== undefined) {\n\t\t\t\titem.range = u.item.range ? Range.lift(u.item.range) : null;\n\t\t\t}\n\t\t\tif (u.item.description !== undefined) {\n\t\t\t\titem.description = u.item.description;\n\t\t\t}\n\t\t\tif (u.item.error !== undefined) {\n\t\t\t\titem.error = u.item.error;\n\t\t\t}\n\t\t\tif (u.item.sortText !== undefined) {\n\t\t\t\titem.sortText = u.item.sortText;\n\t\t\t}\n\t\t}\n\n\t\treturn { extId: u.extId, expand: u.expand, item };\n\t};\n}\n\nexport const applyTestItemUpdate = (\n\tinternal: InternalTestItem | ITestItemUpdate,\n\tpatch: ITestItemUpdate,\n) => {\n\tif (patch.expand !== undefined) {\n\t\tinternal.expand = patch.expand;\n\t}\n\tif (patch.item !== undefined) {\n\t\tinternal.item = internal.item\n\t\t\t? Object.assign(internal.item, patch.item)\n\t\t\t: patch.item;\n\t}\n};\n\n/** Request to an ext host to get followup messages for a test failure. */\nexport interface TestMessageFollowupRequest {\n\tresultId: string;\n\textId: string;\n\ttaskIndex: number;\n\tmessageIndex: number;\n}\n\n/** Request to an ext host to get followup messages for a test failure. */\nexport interface TestMessageFollowupResponse {\n\tid: number;\n\ttitle: string;\n}\n\n/**\n * Test result item used in the main thread.\n */\nexport interface TestResultItem extends InternalTestItem {\n\t/** State of this test in various tasks */\n\ttasks: ITestTaskState[];\n\t/** State of this test as a computation of its tasks */\n\townComputedState: TestResultState;\n\t/** Computed state based on children */\n\tcomputedState: TestResultState;\n\t/** Max duration of the item's tasks (if run directly) */\n\townDuration?: number;\n\t/** Whether this test item is outdated */\n\tretired?: boolean;\n}\n\nexport namespace TestResultItem {\n\t/**\n\t * Serialized version of the TestResultItem. Note that 'retired' is not\n\t * included since all hydrated items are automatically retired.\n\t */\n\texport interface Serialized extends InternalTestItem.Serialized {\n\t\ttasks: ITestTaskState.Serialized[];\n\t\townComputedState: TestResultState;\n\t\tcomputedState: TestResultState;\n\t}\n\n\texport const serializeWithoutMessages = (\n\t\toriginal: TestResultItem,\n\t): Serialized => ({\n\t\t...InternalTestItem.serialize(original),\n\t\townComputedState: original.ownComputedState,\n\t\tcomputedState: original.computedState,\n\t\ttasks: original.tasks.map(ITestTaskState.serializeWithoutMessages),\n\t});\n\n\texport const serialize = (\n\t\toriginal: Readonly<TestResultItem>,\n\t): Serialized => ({\n\t\t...InternalTestItem.serialize(original),\n\t\townComputedState: original.ownComputedState,\n\t\tcomputedState: original.computedState,\n\t\ttasks: original.tasks.map(ITestTaskState.serialize),\n\t});\n\n\texport const deserialize = (\n\t\turiIdentity: ITestUriCanonicalizer,\n\t\tserialized: Serialized,\n\t): TestResultItem => ({\n\t\t...InternalTestItem.deserialize(uriIdentity, serialized),\n\t\townComputedState: serialized.ownComputedState,\n\t\tcomputedState: serialized.computedState,\n\t\ttasks: serialized.tasks.map((m) =>\n\t\t\tITestTaskState.deserialize(uriIdentity, m),\n\t\t),\n\t\tretired: true,\n\t});\n}\n\nexport interface ISerializedTestResults {\n\t/** ID of these test results */\n\tid: string;\n\t/** Time the results were compelted */\n\tcompletedAt: number;\n\t/** Subset of test result items */\n\titems: TestResultItem.Serialized[];\n\t/** Tasks involved in the run. */\n\ttasks: {\n\t\tid: string;\n\t\tname: string | undefined;\n\t\tctrlId: string;\n\t\thasCoverage: boolean;\n\t}[];\n\t/** Human-readable name of the test run. */\n\tname: string;\n\t/** Test trigger informaton */\n\trequest: ResolvedTestRunRequest;\n}\n\nexport interface ITestCoverage {\n\tfiles: IFileCoverage[];\n}\n\nexport interface ICoverageCount {\n\tcovered: number;\n\ttotal: number;\n}\n\nexport namespace ICoverageCount {\n\texport const empty = (): ICoverageCount => ({ covered: 0, total: 0 });\n\texport const sum = (\n\t\ttarget: ICoverageCount,\n\t\tsrc: Readonly<ICoverageCount>,\n\t) => {\n\t\ttarget.covered += src.covered;\n\t\ttarget.total += src.total;\n\t};\n}\n\nexport interface IFileCoverage {\n\tid: string;\n\turi: URI;\n\ttestIds?: string[];\n\tstatement: ICoverageCount;\n\tbranch?: ICoverageCount;\n\tdeclaration?: ICoverageCount;\n}\n\nexport namespace IFileCoverage {\n\texport interface Serialized {\n\t\tid: string;\n\t\turi: UriComponents;\n\t\ttestIds: string[] | undefined;\n\t\tstatement: ICoverageCount;\n\t\tbranch?: ICoverageCount;\n\t\tdeclaration?: ICoverageCount;\n\t}\n\n\texport const serialize = (\n\t\toriginal: Readonly<IFileCoverage>,\n\t): Serialized => ({\n\t\tid: original.id,\n\t\tstatement: original.statement,\n\t\tbranch: original.branch,\n\t\tdeclaration: original.declaration,\n\t\ttestIds: original.testIds,\n\t\turi: original.uri.toJSON(),\n\t});\n\n\texport const deserialize = (\n\t\turiIdentity: ITestUriCanonicalizer,\n\t\tserialized: Serialized,\n\t): IFileCoverage => ({\n\t\tid: serialized.id,\n\t\tstatement: serialized.statement,\n\t\tbranch: serialized.branch,\n\t\tdeclaration: serialized.declaration,\n\t\ttestIds: serialized.testIds,\n\t\turi: uriIdentity.asCanonicalUri(URI.revive(serialized.uri)),\n\t});\n\n\texport const empty = (id: string, uri: URI): IFileCoverage => ({\n\t\tid,\n\t\turi,\n\t\tstatement: ICoverageCount.empty(),\n\t});\n}\n\nfunction serializeThingWithLocation<T extends { location?: Range | Position }>(\n\tserialized: T,\n): T & { location?: IRange | IPosition } {\n\treturn {\n\t\t...serialized,\n\t\tlocation: serialized.location?.toJSON(),\n\t};\n}\n\nfunction deserializeThingWithLocation<\n\tT extends { location?: IRange | IPosition },\n>(serialized: T): T & { location?: Range | Position } {\n\tserialized.location = serialized.location\n\t\t? Position.isIPosition(serialized.location)\n\t\t\t? Position.lift(serialized.location)\n\t\t\t: Range.lift(serialized.location)\n\t\t: undefined;\n\treturn serialized as T & { location?: Range | Position };\n}\n\n/** Number of recent runs in which coverage reports should be retained. */\nexport const KEEP_N_LAST_COVERAGE_REPORTS = 3;\n\nexport enum DetailType {\n\tDeclaration = 0,\n\tStatement = 1,\n\tBranch = 2,\n}\n\nexport type CoverageDetails = IDeclarationCoverage | IStatementCoverage;\n\nexport namespace CoverageDetails {\n\texport type Serialized =\n\t\t| IDeclarationCoverage.Serialized\n\t\t| IStatementCoverage.Serialized;\n\n\texport const serialize = (\n\t\toriginal: Readonly<CoverageDetails>,\n\t): Serialized =>\n\t\toriginal.type === DetailType.Declaration\n\t\t\t? IDeclarationCoverage.serialize(original)\n\t\t\t: IStatementCoverage.serialize(original);\n\n\texport const deserialize = (serialized: Serialized): CoverageDetails =>\n\t\tserialized.type === DetailType.Declaration\n\t\t\t? IDeclarationCoverage.deserialize(serialized)\n\t\t\t: IStatementCoverage.deserialize(serialized);\n}\n\nexport interface IBranchCoverage {\n\tcount: number | boolean;\n\tlabel?: string;\n\tlocation?: Range | Position;\n}\n\nexport namespace IBranchCoverage {\n\texport interface Serialized {\n\t\tcount: number | boolean;\n\t\tlabel?: string;\n\t\tlocation?: IRange | IPosition;\n\t}\n\n\texport const serialize: (original: IBranchCoverage) => Serialized =\n\t\tserializeThingWithLocation;\n\texport const deserialize: (original: Serialized) => IBranchCoverage =\n\t\tdeserializeThingWithLocation;\n}\n\nexport interface IDeclarationCoverage {\n\ttype: DetailType.Declaration;\n\tname: string;\n\tcount: number | boolean;\n\tlocation: Range | Position;\n}\n\nexport namespace IDeclarationCoverage {\n\texport interface Serialized {\n\t\ttype: DetailType.Declaration;\n\t\tname: string;\n\t\tcount: number | boolean;\n\t\tlocation: IRange | IPosition;\n\t}\n\n\texport const serialize: (original: IDeclarationCoverage) => Serialized =\n\t\tserializeThingWithLocation;\n\texport const deserialize: (original: Serialized) => IDeclarationCoverage =\n\t\tdeserializeThingWithLocation;\n}\n\nexport interface IStatementCoverage {\n\ttype: DetailType.Statement;\n\tcount: number | boolean;\n\tlocation: Range | Position;\n\tbranches?: IBranchCoverage[];\n}\n\nexport namespace IStatementCoverage {\n\texport interface Serialized {\n\t\ttype: DetailType.Statement;\n\t\tcount: number | boolean;\n\t\tlocation: IRange | IPosition;\n\t\tbranches?: IBranchCoverage.Serialized[];\n\t}\n\n\texport const serialize = (\n\t\toriginal: Readonly<IStatementCoverage>,\n\t): Serialized => ({\n\t\t...serializeThingWithLocation(original),\n\t\tbranches: original.branches?.map(IBranchCoverage.serialize),\n\t});\n\n\texport const deserialize = (\n\t\tserialized: Serialized,\n\t): IStatementCoverage => ({\n\t\t...deserializeThingWithLocation(serialized),\n\t\tbranches: serialized.branches?.map(IBranchCoverage.deserialize),\n\t});\n}\n\nexport enum TestDiffOpType {\n\t/** Adds a new test (with children) */\n\tAdd = 0,\n\t/** Shallow-updates an existing test */\n\tUpdate = 1,\n\t/** Ranges of some tests in a document were synced, so it should be considered up-to-date */\n\tDocumentSynced = 2,\n\t/** Removes a test (and all its children) */\n\tRemove = 3,\n\t/** Changes the number of controllers who are yet to publish their collection roots. */\n\tIncrementPendingExtHosts = 4,\n\t/** Retires a test/result */\n\tRetire = 5,\n\t/** Add a new test tag */\n\tAddTag = 6,\n\t/** Remove a test tag */\n\tRemoveTag = 7,\n}\n\nexport type TestsDiffOp =\n\t| { op: TestDiffOpType.Add; item: InternalTestItem }\n\t| { op: TestDiffOpType.Update; item: ITestItemUpdate }\n\t| { op: TestDiffOpType.Remove; itemId: string }\n\t| { op: TestDiffOpType.Retire; itemId: string }\n\t| { op: TestDiffOpType.IncrementPendingExtHosts; amount: number }\n\t| { op: TestDiffOpType.AddTag; tag: ITestTagDisplayInfo }\n\t| { op: TestDiffOpType.RemoveTag; id: string }\n\t| { op: TestDiffOpType.DocumentSynced; uri: URI; docv?: number };\n\nexport namespace TestsDiffOp {\n\texport type Serialized =\n\t\t| { op: TestDiffOpType.Add; item: InternalTestItem.Serialized }\n\t\t| { op: TestDiffOpType.Update; item: ITestItemUpdate.Serialized }\n\t\t| { op: TestDiffOpType.Remove; itemId: string }\n\t\t| { op: TestDiffOpType.Retire; itemId: string }\n\t\t| { op: TestDiffOpType.IncrementPendingExtHosts; amount: number }\n\t\t| { op: TestDiffOpType.AddTag; tag: ITestTagDisplayInfo }\n\t\t| { op: TestDiffOpType.RemoveTag; id: string }\n\t\t| {\n\t\t\t\top: TestDiffOpType.DocumentSynced;\n\t\t\t\turi: UriComponents;\n\t\t\t\tdocv?: number;\n\t\t  };\n\n\texport const deserialize = (\n\t\turiIdentity: ITestUriCanonicalizer,\n\t\tu: Serialized,\n\t): TestsDiffOp => {\n\t\tif (u.op === TestDiffOpType.Add) {\n\t\t\treturn {\n\t\t\t\top: u.op,\n\t\t\t\titem: InternalTestItem.deserialize(uriIdentity, u.item),\n\t\t\t};\n\t\t} else if (u.op === TestDiffOpType.Update) {\n\t\t\treturn { op: u.op, item: ITestItemUpdate.deserialize(u.item) };\n\t\t} else if (u.op === TestDiffOpType.DocumentSynced) {\n\t\t\treturn {\n\t\t\t\top: u.op,\n\t\t\t\turi: uriIdentity.asCanonicalUri(URI.revive(u.uri)),\n\t\t\t\tdocv: u.docv,\n\t\t\t};\n\t\t} else {\n\t\t\treturn u;\n\t\t}\n\t};\n\n\texport const serialize = (u: Readonly<TestsDiffOp>): Serialized => {\n\t\tif (u.op === TestDiffOpType.Add) {\n\t\t\treturn { op: u.op, item: InternalTestItem.serialize(u.item) };\n\t\t} else if (u.op === TestDiffOpType.Update) {\n\t\t\treturn { op: u.op, item: ITestItemUpdate.serialize(u.item) };\n\t\t} else {\n\t\t\treturn u;\n\t\t}\n\t};\n}\n\n/**\n * Context for actions taken in the test explorer view.\n */\nexport interface ITestItemContext {\n\t/** Marshalling marker */\n\t$mid: MarshalledId.TestItemContext;\n\t/** Tests and parents from the root to the current items */\n\ttests: InternalTestItem.Serialized[];\n}\n\n/**\n * Context for actions taken in the test explorer view.\n */\nexport interface ITestMessageMenuArgs {\n\t/** Marshalling marker */\n\t$mid: MarshalledId.TestMessageMenuArgs;\n\t/** Tests ext ID */\n\ttest: InternalTestItem.Serialized;\n\t/** Serialized test message */\n\tmessage: ITestMessage.Serialized;\n}\n\n/**\n * Request from the ext host or main thread to indicate that tests have\n * changed. It's assumed that any item upserted *must* have its children\n * previously also upserted, or upserted as part of the same operation.\n * Children that no longer exist in an upserted item will be removed.\n */\nexport type TestsDiff = TestsDiffOp[];\n\n/**\n * @private\n */\nexport interface IncrementalTestCollectionItem extends InternalTestItem {\n\tchildren: Set<string>;\n}\n\n/**\n * The IncrementalChangeCollector is used in the IncrementalTestCollection\n * and called with diff changes as they're applied. This is used in the\n * ext host to create a cohesive change event from a diff.\n */\nexport interface IncrementalChangeCollector<T> {\n\t/**\n\t * A node was added.\n\t */\n\tadd?(node: T): void;\n\n\t/**\n\t * A node in the collection was updated.\n\t */\n\tupdate?(node: T): void;\n\n\t/**\n\t * A node was removed.\n\t */\n\tremove?(node: T, isNestedOperation: boolean): void;\n\n\t/**\n\t * Called when the diff has been applied.\n\t */\n\tcomplete?(): void;\n}\n\n/**\n * Maintains tests in this extension host sent from the main thread.\n */\nexport abstract class AbstractIncrementalTestCollection<\n\tT extends IncrementalTestCollectionItem,\n> {\n\tprivate readonly _tags = new Map<string, ITestTagDisplayInfo>();\n\n\t/**\n\t * Map of item IDs to test item objects.\n\t */\n\tprotected readonly items = new Map<string, T>();\n\n\t/**\n\t * ID of test root items.\n\t */\n\tprotected readonly roots = new Set<T>();\n\n\t/**\n\t * Number of 'busy' controllers.\n\t */\n\tprotected busyControllerCount = 0;\n\n\t/**\n\t * Number of pending roots.\n\t */\n\tprotected pendingRootCount = 0;\n\n\t/**\n\t * Known test tags.\n\t */\n\tpublic readonly tags: ReadonlyMap<string, ITestTagDisplayInfo> = this._tags;\n\n\tconstructor(private readonly uriIdentity: ITestUriCanonicalizer) {}\n\n\t/**\n\t * Applies the diff to the collection.\n\t */\n\tpublic apply(diff: TestsDiff) {\n\t\tconst changes = this.createChangeCollector();\n\n\t\tfor (const op of diff) {\n\t\t\tswitch (op.op) {\n\t\t\t\tcase TestDiffOpType.Add:\n\t\t\t\t\tthis.add(\n\t\t\t\t\t\tInternalTestItem.deserialize(this.uriIdentity, op.item),\n\t\t\t\t\t\tchanges,\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TestDiffOpType.Update:\n\t\t\t\t\tthis.update(ITestItemUpdate.deserialize(op.item), changes);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TestDiffOpType.Remove:\n\t\t\t\t\tthis.remove(op.itemId, changes);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TestDiffOpType.Retire:\n\t\t\t\t\tthis.retireTest(op.itemId);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TestDiffOpType.IncrementPendingExtHosts:\n\t\t\t\t\tthis.updatePendingRoots(op.amount);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TestDiffOpType.AddTag:\n\t\t\t\t\tthis._tags.set(op.tag.id, op.tag);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TestDiffOpType.RemoveTag:\n\t\t\t\t\tthis._tags.delete(op.id);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tchanges.complete?.();\n\t}\n\n\tprotected add(\n\t\titem: InternalTestItem,\n\t\tchanges: IncrementalChangeCollector<T>,\n\t) {\n\t\tconst parentId = TestId.parentId(item.item.extId)?.toString();\n\t\tlet created: T;\n\t\tif (!parentId) {\n\t\t\tcreated = this.createItem(item);\n\t\t\tthis.roots.add(created);\n\t\t\tthis.items.set(item.item.extId, created);\n\t\t} else if (this.items.has(parentId)) {\n\t\t\tconst parent = this.items.get(parentId)!;\n\t\t\tparent.children.add(item.item.extId);\n\t\t\tcreated = this.createItem(item, parent);\n\t\t\tthis.items.set(item.item.extId, created);\n\t\t} else {\n\t\t\tconsole.error(\n\t\t\t\t`Test with unknown parent ID: ${JSON.stringify(item)}`,\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tchanges.add?.(created);\n\t\tif (item.expand === TestItemExpandState.BusyExpanding) {\n\t\t\tthis.busyControllerCount++;\n\t\t}\n\n\t\treturn created;\n\t}\n\n\tprotected update(\n\t\tpatch: ITestItemUpdate,\n\t\tchanges: IncrementalChangeCollector<T>,\n\t) {\n\t\tconst existing = this.items.get(patch.extId);\n\t\tif (!existing) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (patch.expand !== undefined) {\n\t\t\tif (existing.expand === TestItemExpandState.BusyExpanding) {\n\t\t\t\tthis.busyControllerCount--;\n\t\t\t}\n\t\t\tif (patch.expand === TestItemExpandState.BusyExpanding) {\n\t\t\t\tthis.busyControllerCount++;\n\t\t\t}\n\t\t}\n\n\t\tapplyTestItemUpdate(existing, patch);\n\t\tchanges.update?.(existing);\n\t\treturn existing;\n\t}\n\n\tprotected remove(itemId: string, changes: IncrementalChangeCollector<T>) {\n\t\tconst toRemove = this.items.get(itemId);\n\t\tif (!toRemove) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst parentId = TestId.parentId(toRemove.item.extId)?.toString();\n\t\tif (parentId) {\n\t\t\tconst parent = this.items.get(parentId)!;\n\t\t\tparent.children.delete(toRemove.item.extId);\n\t\t} else {\n\t\t\tthis.roots.delete(toRemove);\n\t\t}\n\n\t\tconst queue: Iterable<string>[] = [[itemId]];\n\t\twhile (queue.length) {\n\t\t\tfor (const itemId of queue.pop()!) {\n\t\t\t\tconst existing = this.items.get(itemId);\n\t\t\t\tif (existing) {\n\t\t\t\t\tqueue.push(existing.children);\n\t\t\t\t\tthis.items.delete(itemId);\n\t\t\t\t\tchanges.remove?.(existing, existing !== toRemove);\n\n\t\t\t\t\tif (existing.expand === TestItemExpandState.BusyExpanding) {\n\t\t\t\t\t\tthis.busyControllerCount--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Called when the extension signals a test result should be retired.\n\t */\n\tprotected retireTest(testId: string) {\n\t\t// no-op\n\t}\n\n\t/**\n\t * Updates the number of test root sources who are yet to report. When\n\t * the total pending test roots reaches 0, the roots for all controllers\n\t * will exist in the collection.\n\t */\n\tpublic updatePendingRoots(delta: number) {\n\t\tthis.pendingRootCount += delta;\n\t}\n\n\t/**\n\t * Called before a diff is applied to create a new change collector.\n\t */\n\tprotected createChangeCollector(): IncrementalChangeCollector<T> {\n\t\treturn {};\n\t}\n\n\t/**\n\t * Creates a new item for the collection from the internal test item.\n\t */\n\tprotected abstract createItem(internal: InternalTestItem, parent?: T): T;\n}\n"],
  "mappings": "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",
  "names": ["TestResultState", "ExtTestRunProfileKind", "TestControllerCapability", "TestRunProfileBitset", "IRichLocation", "TestMessageType", "ITestMessageStackFrame", "ITestErrorMessage", "ITestOutputMessage", "ITestMessage", "ITestTaskState", "ITestItem", "TestItemExpandState", "InternalTestItem", "ITestItemUpdate", "TestResultItem", "ICoverageCount", "IFileCoverage", "DetailType", "CoverageDetails", "IBranchCoverage", "IDeclarationCoverage", "IStatementCoverage", "TestDiffOpType", "TestsDiffOp", "itemId"]
}
