{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/testing/common/testTypes.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IMarkdownString } from '../../../../base/common/htmlContent.js';\nimport { MarshalledId } from '../../../../base/common/marshallingIds.js';\nimport { URI, UriComponents } from '../../../../base/common/uri.js';\nimport { IPosition, Position } from '../../../../editor/common/core/position.js';\nimport { IRange, Range } from '../../../../editor/common/core/range.js';\nimport { TestId } from './testId.js';\n\nexport const enum TestResultState {\n\tUnset = 0,\n\tQueued = 1,\n\tRunning = 2,\n\tPassed = 3,\n\tFailed = 4,\n\tSkipped = 5,\n\tErrored = 6\n}\n\nexport const testResultStateToContextValues: { [K in TestResultState]: string } = {\n\t[TestResultState.Unset]: 'unset',\n\t[TestResultState.Queued]: 'queued',\n\t[TestResultState.Running]: 'running',\n\t[TestResultState.Passed]: 'passed',\n\t[TestResultState.Failed]: 'failed',\n\t[TestResultState.Skipped]: 'skipped',\n\t[TestResultState.Errored]: 'errored',\n};\n\n/** note: keep in sync with TestRunProfileKind in vscode.d.ts */\nexport const enum ExtTestRunProfileKind {\n\tRun = 1,\n\tDebug = 2,\n\tCoverage = 3,\n}\n\nexport const enum TestControllerCapability {\n\tRefresh = 1 << 1,\n\tCodeRelatedToTest = 1 << 2,\n\tTestRelatedToCode = 1 << 3,\n}\n\nexport const enum TestRunProfileBitset {\n\tRun = 1 << 1,\n\tDebug = 1 << 2,\n\tCoverage = 1 << 3,\n\tHasNonDefaultProfile = 1 << 4,\n\tHasConfigurable = 1 << 5,\n\tSupportsContinuousRun = 1 << 6,\n}\n\n/**\n * List of all test run profile bitset values.\n */\nexport const testRunProfileBitsetList = [\n\tTestRunProfileBitset.Run,\n\tTestRunProfileBitset.Debug,\n\tTestRunProfileBitset.Coverage,\n\tTestRunProfileBitset.HasNonDefaultProfile,\n\tTestRunProfileBitset.HasConfigurable,\n\tTestRunProfileBitset.SupportsContinuousRun,\n];\n\n/**\n * DTO for a controller's run profiles.\n */\nexport interface ITestRunProfile {\n\tcontrollerId: string;\n\tprofileId: number;\n\tlabel: string;\n\tgroup: TestRunProfileBitset;\n\tisDefault: boolean;\n\ttag: string | null;\n\thasConfigurationHandler: boolean;\n\tsupportsContinuousRun: boolean;\n}\n\n/**\n * A fully-resolved request to run tests, passsed between the main thread\n * and extension host.\n */\nexport interface ResolvedTestRunRequest {\n\tgroup: TestRunProfileBitset;\n\ttargets: {\n\t\ttestIds: string[];\n\t\tcontrollerId: string;\n\t\tprofileId: number;\n\t}[];\n\texclude?: string[];\n\t/** Whether this is a continuous test run */\n\tcontinuous?: boolean;\n\t/** Whether this was trigged by a user action in UI. Default=true */\n\tpreserveFocus?: boolean;\n}\n\n/**\n * Request to the main thread to run a set of tests.\n */\nexport interface ExtensionRunTestsRequest {\n\tid: string;\n\tinclude: string[];\n\texclude: string[];\n\tcontrollerId: string;\n\tprofile?: { group: TestRunProfileBitset; id: number };\n\tpersist: boolean;\n\tpreserveFocus: boolean;\n\t/** Whether this is a result of a continuous test run request */\n\tcontinuous: boolean;\n}\n\n/**\n * Request parameters a controller run handler. This is different than\n * {@link IStartControllerTests}. The latter is used to ask for one or more test\n * runs tracked directly by the renderer.\n *\n * This alone can be used to start an autorun, without a specific associated runId.\n */\nexport interface ICallProfileRunHandler {\n\tcontrollerId: string;\n\tprofileId: number;\n\texcludeExtIds: string[];\n\ttestIds: string[];\n}\n\nexport const isStartControllerTests = (t: ICallProfileRunHandler | IStartControllerTests): t is IStartControllerTests => ('runId' as keyof IStartControllerTests) in t;\n\n/**\n * Request from the main thread to run tests for a single controller.\n */\nexport interface IStartControllerTests extends ICallProfileRunHandler {\n\trunId: string;\n}\n\nexport interface IStartControllerTestsResult {\n\terror?: string;\n}\n\n/**\n * Location with a fully-instantiated Range and URI.\n */\nexport interface IRichLocation {\n\trange: Range;\n\turi: URI;\n}\n\n/** Subset of the IUriIdentityService */\nexport interface ITestUriCanonicalizer {\n\t/** @link import('vs/platform/uriIdentity/common/uriIdentity').IUriIdentityService */\n\tasCanonicalUri(uri: URI): URI;\n}\n\nexport namespace IRichLocation {\n\texport interface Serialize {\n\t\trange: IRange;\n\t\turi: UriComponents;\n\t}\n\n\texport const serialize = (location: Readonly<IRichLocation>): Serialize => ({\n\t\trange: location.range.toJSON(),\n\t\turi: location.uri.toJSON(),\n\t});\n\n\texport const deserialize = (uriIdentity: ITestUriCanonicalizer, location: Serialize): IRichLocation => ({\n\t\trange: Range.lift(location.range),\n\t\turi: uriIdentity.asCanonicalUri(URI.revive(location.uri)),\n\t});\n}\n\nexport const enum TestMessageType {\n\tError,\n\tOutput\n}\n\nexport interface ITestMessageStackFrame {\n\tlabel: string;\n\turi: URI | undefined;\n\tposition: Position | undefined;\n}\n\nexport namespace ITestMessageStackFrame {\n\texport interface Serialized {\n\t\tlabel: string;\n\t\turi: UriComponents | undefined;\n\t\tposition: IPosition | undefined;\n\t}\n\n\texport const serialize = (stack: Readonly<ITestMessageStackFrame>): Serialized => ({\n\t\tlabel: stack.label,\n\t\turi: stack.uri?.toJSON(),\n\t\tposition: stack.position?.toJSON(),\n\t});\n\n\texport const deserialize = (uriIdentity: ITestUriCanonicalizer, stack: Serialized): ITestMessageStackFrame => ({\n\t\tlabel: stack.label,\n\t\turi: stack.uri ? uriIdentity.asCanonicalUri(URI.revive(stack.uri)) : undefined,\n\t\tposition: stack.position ? Position.lift(stack.position) : undefined,\n\t});\n}\n\nexport interface ITestErrorMessage {\n\tmessage: string | IMarkdownString;\n\ttype: TestMessageType.Error;\n\texpected: string | undefined;\n\tactual: string | undefined;\n\tcontextValue: string | undefined;\n\tlocation: IRichLocation | undefined;\n\tstackTrace: undefined | ITestMessageStackFrame[];\n}\n\nexport namespace ITestErrorMessage {\n\texport interface Serialized {\n\t\tmessage: string | IMarkdownString;\n\t\ttype: TestMessageType.Error;\n\t\texpected: string | undefined;\n\t\tactual: string | undefined;\n\t\tcontextValue: string | undefined;\n\t\tlocation: IRichLocation.Serialize | undefined;\n\t\tstackTrace: undefined | ITestMessageStackFrame.Serialized[];\n\t}\n\n\texport const serialize = (message: Readonly<ITestErrorMessage>): Serialized => ({\n\t\tmessage: message.message,\n\t\ttype: TestMessageType.Error,\n\t\texpected: message.expected,\n\t\tactual: message.actual,\n\t\tcontextValue: message.contextValue,\n\t\tlocation: message.location && IRichLocation.serialize(message.location),\n\t\tstackTrace: message.stackTrace?.map(ITestMessageStackFrame.serialize),\n\t});\n\n\texport const deserialize = (uriIdentity: ITestUriCanonicalizer, message: Serialized): ITestErrorMessage => ({\n\t\tmessage: message.message,\n\t\ttype: TestMessageType.Error,\n\t\texpected: message.expected,\n\t\tactual: message.actual,\n\t\tcontextValue: message.contextValue,\n\t\tlocation: message.location && IRichLocation.deserialize(uriIdentity, message.location),\n\t\tstackTrace: message.stackTrace && message.stackTrace.map(s => ITestMessageStackFrame.deserialize(uriIdentity, s)),\n\t});\n}\n\nexport interface ITestOutputMessage {\n\tmessage: string;\n\ttype: TestMessageType.Output;\n\toffset: number;\n\tlength: number;\n\tmarker?: number;\n\tlocation: IRichLocation | undefined;\n}\n\n/**\n * Gets the TTY marker ID for either starting or ending\n * an ITestOutputMessage.marker of the given ID.\n */\nexport const getMarkId = (marker: number, start: boolean) => `${start ? 's' : 'e'}${marker}`;\n\nexport namespace ITestOutputMessage {\n\texport interface Serialized {\n\t\tmessage: string;\n\t\toffset: number;\n\t\tlength: number;\n\t\ttype: TestMessageType.Output;\n\t\tlocation: IRichLocation.Serialize | undefined;\n\t}\n\n\texport const serialize = (message: Readonly<ITestOutputMessage>): Serialized => ({\n\t\tmessage: message.message,\n\t\ttype: TestMessageType.Output,\n\t\toffset: message.offset,\n\t\tlength: message.length,\n\t\tlocation: message.location && IRichLocation.serialize(message.location),\n\t});\n\n\texport const deserialize = (uriIdentity: ITestUriCanonicalizer, message: Serialized): ITestOutputMessage => ({\n\t\tmessage: message.message,\n\t\ttype: TestMessageType.Output,\n\t\toffset: message.offset,\n\t\tlength: message.length,\n\t\tlocation: message.location && IRichLocation.deserialize(uriIdentity, message.location),\n\t});\n}\n\nexport type ITestMessage = ITestErrorMessage | ITestOutputMessage;\n\nexport namespace ITestMessage {\n\texport type Serialized = ITestErrorMessage.Serialized | ITestOutputMessage.Serialized;\n\n\texport const serialize = (message: Readonly<ITestMessage>): Serialized =>\n\t\tmessage.type === TestMessageType.Error ? ITestErrorMessage.serialize(message) : ITestOutputMessage.serialize(message);\n\n\texport const deserialize = (uriIdentity: ITestUriCanonicalizer, message: Serialized): ITestMessage =>\n\t\tmessage.type === TestMessageType.Error ? ITestErrorMessage.deserialize(uriIdentity, message) : ITestOutputMessage.deserialize(uriIdentity, message);\n\n\texport const isDiffable = (message: ITestMessage): message is ITestErrorMessage & { actual: string; expected: string } =>\n\t\tmessage.type === TestMessageType.Error && message.actual !== undefined && message.expected !== undefined;\n}\n\nexport interface ITestTaskState {\n\tstate: TestResultState;\n\tduration: number | undefined;\n\tmessages: ITestMessage[];\n}\n\nexport namespace ITestTaskState {\n\texport interface Serialized {\n\t\tstate: TestResultState;\n\t\tduration: number | undefined;\n\t\tmessages: ITestMessage.Serialized[];\n\t}\n\n\texport const serializeWithoutMessages = (state: ITestTaskState): Serialized => ({\n\t\tstate: state.state,\n\t\tduration: state.duration,\n\t\tmessages: [],\n\t});\n\n\texport const serialize = (state: Readonly<ITestTaskState>): Serialized => ({\n\t\tstate: state.state,\n\t\tduration: state.duration,\n\t\tmessages: state.messages.map(ITestMessage.serialize),\n\t});\n\n\texport const deserialize = (uriIdentity: ITestUriCanonicalizer, state: Serialized): ITestTaskState => ({\n\t\tstate: state.state,\n\t\tduration: state.duration,\n\t\tmessages: state.messages.map(m => ITestMessage.deserialize(uriIdentity, m)),\n\t});\n}\n\nexport interface ITestRunTask {\n\tid: string;\n\tname: string;\n\trunning: boolean;\n\tctrlId: string;\n}\n\nexport interface ITestTag {\n\treadonly id: string;\n}\n\nconst testTagDelimiter = '\\0';\n\nexport const namespaceTestTag =\n\t(ctrlId: string, tagId: string) => ctrlId + testTagDelimiter + tagId;\n\nexport const denamespaceTestTag = (namespaced: string) => {\n\tconst index = namespaced.indexOf(testTagDelimiter);\n\treturn { ctrlId: namespaced.slice(0, index), tagId: namespaced.slice(index + 1) };\n};\n\nexport interface ITestTagDisplayInfo {\n\tid: string;\n}\n\n/**\n * The TestItem from .d.ts, as a plain object without children.\n */\nexport interface ITestItem {\n\t/** ID of the test given by the test controller */\n\textId: string;\n\tlabel: string;\n\ttags: string[];\n\tbusy: boolean;\n\tchildren?: never;\n\turi: URI | undefined;\n\trange: Range | null;\n\tdescription: string | null;\n\terror: string | IMarkdownString | null;\n\tsortText: string | null;\n}\n\nexport namespace ITestItem {\n\texport interface Serialized {\n\t\textId: string;\n\t\tlabel: string;\n\t\ttags: string[];\n\t\tbusy: boolean;\n\t\tchildren?: never;\n\t\turi: UriComponents | undefined;\n\t\trange: IRange | null;\n\t\tdescription: string | null;\n\t\terror: string | IMarkdownString | null;\n\t\tsortText: string | null;\n\t}\n\n\texport const serialize = (item: Readonly<ITestItem>): Serialized => ({\n\t\textId: item.extId,\n\t\tlabel: item.label,\n\t\ttags: item.tags,\n\t\tbusy: item.busy,\n\t\tchildren: undefined,\n\t\turi: item.uri?.toJSON(),\n\t\trange: item.range?.toJSON() || null,\n\t\tdescription: item.description,\n\t\terror: item.error,\n\t\tsortText: item.sortText\n\t});\n\n\texport const deserialize = (uriIdentity: ITestUriCanonicalizer, serialized: Serialized): ITestItem => ({\n\t\textId: serialized.extId,\n\t\tlabel: serialized.label,\n\t\ttags: serialized.tags,\n\t\tbusy: serialized.busy,\n\t\tchildren: undefined,\n\t\turi: serialized.uri ? uriIdentity.asCanonicalUri(URI.revive(serialized.uri)) : undefined,\n\t\trange: serialized.range ? Range.lift(serialized.range) : null,\n\t\tdescription: serialized.description,\n\t\terror: serialized.error,\n\t\tsortText: serialized.sortText\n\t});\n}\n\nexport const enum TestItemExpandState {\n\tNotExpandable,\n\tExpandable,\n\tBusyExpanding,\n\tExpanded,\n}\n\n/**\n * TestItem-like shape, but with an ID and children as strings.\n */\nexport interface InternalTestItem {\n\t/** Controller ID from whence this test came */\n\tcontrollerId: string;\n\t/** Expandability state */\n\texpand: TestItemExpandState;\n\t/** Raw test item properties */\n\titem: ITestItem;\n}\n\nexport namespace InternalTestItem {\n\texport interface Serialized {\n\t\texpand: TestItemExpandState;\n\t\titem: ITestItem.Serialized;\n\t}\n\n\texport const serialize = (item: Readonly<InternalTestItem>): Serialized => ({\n\t\texpand: item.expand,\n\t\titem: ITestItem.serialize(item.item)\n\t});\n\n\texport const deserialize = (uriIdentity: ITestUriCanonicalizer, serialized: Serialized): InternalTestItem => ({\n\t\t// the `controllerId` is derived from the test.item.extId. It's redundant\n\t\t// in the non-serialized InternalTestItem too, but there just because it's\n\t\t// checked against in many hot paths.\n\t\tcontrollerId: TestId.root(serialized.item.extId),\n\t\texpand: serialized.expand,\n\t\titem: ITestItem.deserialize(uriIdentity, serialized.item)\n\t});\n}\n\n/**\n * A partial update made to an existing InternalTestItem.\n */\nexport interface ITestItemUpdate {\n\textId: string;\n\texpand?: TestItemExpandState;\n\titem?: Partial<ITestItem>;\n}\n\nexport namespace ITestItemUpdate {\n\texport interface Serialized {\n\t\textId: string;\n\t\texpand?: TestItemExpandState;\n\t\titem?: Partial<ITestItem.Serialized>;\n\t}\n\n\texport const serialize = (u: Readonly<ITestItemUpdate>): Serialized => {\n\t\tlet item: Partial<ITestItem.Serialized> | undefined;\n\t\tif (u.item) {\n\t\t\titem = {};\n\t\t\tif (u.item.label !== undefined) { item.label = u.item.label; }\n\t\t\tif (u.item.tags !== undefined) { item.tags = u.item.tags; }\n\t\t\tif (u.item.busy !== undefined) { item.busy = u.item.busy; }\n\t\t\tif (u.item.uri !== undefined) { item.uri = u.item.uri?.toJSON(); }\n\t\t\tif (u.item.range !== undefined) { item.range = u.item.range?.toJSON(); }\n\t\t\tif (u.item.description !== undefined) { item.description = u.item.description; }\n\t\t\tif (u.item.error !== undefined) { item.error = u.item.error; }\n\t\t\tif (u.item.sortText !== undefined) { item.sortText = u.item.sortText; }\n\t\t}\n\n\t\treturn { extId: u.extId, expand: u.expand, item };\n\t};\n\n\texport const deserialize = (u: Serialized): ITestItemUpdate => {\n\t\tlet item: Partial<ITestItem> | undefined;\n\t\tif (u.item) {\n\t\t\titem = {};\n\t\t\tif (u.item.label !== undefined) { item.label = u.item.label; }\n\t\t\tif (u.item.tags !== undefined) { item.tags = u.item.tags; }\n\t\t\tif (u.item.busy !== undefined) { item.busy = u.item.busy; }\n\t\t\tif (u.item.range !== undefined) { item.range = u.item.range ? Range.lift(u.item.range) : null; }\n\t\t\tif (u.item.description !== undefined) { item.description = u.item.description; }\n\t\t\tif (u.item.error !== undefined) { item.error = u.item.error; }\n\t\t\tif (u.item.sortText !== undefined) { item.sortText = u.item.sortText; }\n\t\t}\n\n\t\treturn { extId: u.extId, expand: u.expand, item };\n\t};\n\n}\n\nexport const applyTestItemUpdate = (internal: InternalTestItem | ITestItemUpdate, patch: ITestItemUpdate) => {\n\tif (patch.expand !== undefined) {\n\t\tinternal.expand = patch.expand;\n\t}\n\tif (patch.item !== undefined) {\n\t\tinternal.item = internal.item ? Object.assign(internal.item, patch.item) : patch.item;\n\t}\n};\n\n/** Request to an ext host to get followup messages for a test failure. */\nexport interface TestMessageFollowupRequest {\n\tresultId: string;\n\textId: string;\n\ttaskIndex: number;\n\tmessageIndex: number;\n}\n\n/** Request to an ext host to get followup messages for a test failure. */\nexport interface TestMessageFollowupResponse {\n\tid: number;\n\ttitle: string;\n}\n\n/**\n * Test result item used in the main thread.\n */\nexport interface TestResultItem extends InternalTestItem {\n\t/** State of this test in various tasks */\n\ttasks: ITestTaskState[];\n\t/** State of this test as a computation of its tasks */\n\townComputedState: TestResultState;\n\t/** Computed state based on children */\n\tcomputedState: TestResultState;\n\t/** Max duration of the item's tasks (if run directly) */\n\townDuration?: number;\n\t/** Whether this test item is outdated */\n\tretired?: boolean;\n}\n\nexport namespace TestResultItem {\n\t/**\n\t * Serialized version of the TestResultItem. Note that 'retired' is not\n\t * included since all hydrated items are automatically retired.\n\t */\n\texport interface Serialized extends InternalTestItem.Serialized {\n\t\ttasks: ITestTaskState.Serialized[];\n\t\townComputedState: TestResultState;\n\t\tcomputedState: TestResultState;\n\t}\n\n\texport const serializeWithoutMessages = (original: TestResultItem): Serialized => ({\n\t\t...InternalTestItem.serialize(original),\n\t\townComputedState: original.ownComputedState,\n\t\tcomputedState: original.computedState,\n\t\ttasks: original.tasks.map(ITestTaskState.serializeWithoutMessages),\n\t});\n\n\texport const serialize = (original: Readonly<TestResultItem>): Serialized => ({\n\t\t...InternalTestItem.serialize(original),\n\t\townComputedState: original.ownComputedState,\n\t\tcomputedState: original.computedState,\n\t\ttasks: original.tasks.map(ITestTaskState.serialize),\n\t});\n\n\texport const deserialize = (uriIdentity: ITestUriCanonicalizer, serialized: Serialized): TestResultItem => ({\n\t\t...InternalTestItem.deserialize(uriIdentity, serialized),\n\t\townComputedState: serialized.ownComputedState,\n\t\tcomputedState: serialized.computedState,\n\t\ttasks: serialized.tasks.map(m => ITestTaskState.deserialize(uriIdentity, m)),\n\t\tretired: true,\n\t});\n}\n\nexport interface ISerializedTestResults {\n\t/** ID of these test results */\n\tid: string;\n\t/** Time the results were compelted */\n\tcompletedAt: number;\n\t/** Subset of test result items */\n\titems: TestResultItem.Serialized[];\n\t/** Tasks involved in the run. */\n\ttasks: { id: string; name: string | undefined; ctrlId: string; hasCoverage: boolean }[];\n\t/** Human-readable name of the test run. */\n\tname: string;\n\t/** Test trigger informaton */\n\trequest: ResolvedTestRunRequest;\n}\n\nexport interface ITestCoverage {\n\tfiles: IFileCoverage[];\n}\n\nexport interface ICoverageCount {\n\tcovered: number;\n\ttotal: number;\n}\n\nexport namespace ICoverageCount {\n\texport const empty = (): ICoverageCount => ({ covered: 0, total: 0 });\n\texport const sum = (target: ICoverageCount, src: Readonly<ICoverageCount>) => {\n\t\ttarget.covered += src.covered;\n\t\ttarget.total += src.total;\n\t};\n}\n\nexport interface IFileCoverage {\n\tid: string;\n\turi: URI;\n\ttestIds?: string[];\n\tstatement: ICoverageCount;\n\tbranch?: ICoverageCount;\n\tdeclaration?: ICoverageCount;\n}\n\nexport namespace IFileCoverage {\n\texport interface Serialized {\n\t\tid: string;\n\t\turi: UriComponents;\n\t\ttestIds: string[] | undefined;\n\t\tstatement: ICoverageCount;\n\t\tbranch?: ICoverageCount;\n\t\tdeclaration?: ICoverageCount;\n\t}\n\n\texport const serialize = (original: Readonly<IFileCoverage>): Serialized => ({\n\t\tid: original.id,\n\t\tstatement: original.statement,\n\t\tbranch: original.branch,\n\t\tdeclaration: original.declaration,\n\t\ttestIds: original.testIds,\n\t\turi: original.uri.toJSON(),\n\t});\n\n\texport const deserialize = (uriIdentity: ITestUriCanonicalizer, serialized: Serialized): IFileCoverage => ({\n\t\tid: serialized.id,\n\t\tstatement: serialized.statement,\n\t\tbranch: serialized.branch,\n\t\tdeclaration: serialized.declaration,\n\t\ttestIds: serialized.testIds,\n\t\turi: uriIdentity.asCanonicalUri(URI.revive(serialized.uri)),\n\t});\n\n\texport const empty = (id: string, uri: URI): IFileCoverage => ({\n\t\tid,\n\t\turi,\n\t\tstatement: ICoverageCount.empty(),\n\t});\n}\n\nfunction serializeThingWithLocation<T extends { location?: Range | Position }>(serialized: T): T & { location?: IRange | IPosition } {\n\treturn {\n\t\t...serialized,\n\t\tlocation: serialized.location?.toJSON(),\n\t};\n}\n\nfunction deserializeThingWithLocation<T extends { location?: IRange | IPosition }>(serialized: T): T & { location?: Range | Position } {\n\tserialized.location = serialized.location ? (Position.isIPosition(serialized.location) ? Position.lift(serialized.location) : Range.lift(serialized.location)) : undefined;\n\treturn serialized as T & { location?: Range | Position };\n}\n\n/** Number of recent runs in which coverage reports should be retained. */\nexport const KEEP_N_LAST_COVERAGE_REPORTS = 3;\n\nexport const enum DetailType {\n\tDeclaration,\n\tStatement,\n\tBranch,\n}\n\nexport type CoverageDetails = IDeclarationCoverage | IStatementCoverage;\n\nexport namespace CoverageDetails {\n\texport type Serialized = IDeclarationCoverage.Serialized | IStatementCoverage.Serialized;\n\n\texport const serialize = (original: Readonly<CoverageDetails>): Serialized =>\n\t\toriginal.type === DetailType.Declaration ? IDeclarationCoverage.serialize(original) : IStatementCoverage.serialize(original);\n\n\texport const deserialize = (serialized: Serialized): CoverageDetails =>\n\t\tserialized.type === DetailType.Declaration ? IDeclarationCoverage.deserialize(serialized) : IStatementCoverage.deserialize(serialized);\n}\n\nexport interface IBranchCoverage {\n\tcount: number | boolean;\n\tlabel?: string;\n\tlocation?: Range | Position;\n}\n\nexport namespace IBranchCoverage {\n\texport interface Serialized {\n\t\tcount: number | boolean;\n\t\tlabel?: string;\n\t\tlocation?: IRange | IPosition;\n\t}\n\n\texport const serialize: (original: IBranchCoverage) => Serialized = serializeThingWithLocation;\n\texport const deserialize: (original: Serialized) => IBranchCoverage = deserializeThingWithLocation;\n}\n\nexport interface IDeclarationCoverage {\n\ttype: DetailType.Declaration;\n\tname: string;\n\tcount: number | boolean;\n\tlocation: Range | Position;\n}\n\nexport namespace IDeclarationCoverage {\n\texport interface Serialized {\n\t\ttype: DetailType.Declaration;\n\t\tname: string;\n\t\tcount: number | boolean;\n\t\tlocation: IRange | IPosition;\n\t}\n\n\texport const serialize: (original: IDeclarationCoverage) => Serialized = serializeThingWithLocation;\n\texport const deserialize: (original: Serialized) => IDeclarationCoverage = deserializeThingWithLocation;\n}\n\nexport interface IStatementCoverage {\n\ttype: DetailType.Statement;\n\tcount: number | boolean;\n\tlocation: Range | Position;\n\tbranches?: IBranchCoverage[];\n}\n\nexport namespace IStatementCoverage {\n\texport interface Serialized {\n\t\ttype: DetailType.Statement;\n\t\tcount: number | boolean;\n\t\tlocation: IRange | IPosition;\n\t\tbranches?: IBranchCoverage.Serialized[];\n\t}\n\n\texport const serialize = (original: Readonly<IStatementCoverage>): Serialized => ({\n\t\t...serializeThingWithLocation(original),\n\t\tbranches: original.branches?.map(IBranchCoverage.serialize),\n\t});\n\n\texport const deserialize = (serialized: Serialized): IStatementCoverage => ({\n\t\t...deserializeThingWithLocation(serialized),\n\t\tbranches: serialized.branches?.map(IBranchCoverage.deserialize),\n\t});\n}\n\nexport const enum TestDiffOpType {\n\t/** Adds a new test (with children) */\n\tAdd,\n\t/** Shallow-updates an existing test */\n\tUpdate,\n\t/** Ranges of some tests in a document were synced, so it should be considered up-to-date */\n\tDocumentSynced,\n\t/** Removes a test (and all its children) */\n\tRemove,\n\t/** Changes the number of controllers who are yet to publish their collection roots. */\n\tIncrementPendingExtHosts,\n\t/** Retires a test/result */\n\tRetire,\n\t/** Add a new test tag */\n\tAddTag,\n\t/** Remove a test tag */\n\tRemoveTag,\n}\n\nexport type TestsDiffOp =\n\t| { op: TestDiffOpType.Add; item: InternalTestItem }\n\t| { op: TestDiffOpType.Update; item: ITestItemUpdate }\n\t| { op: TestDiffOpType.Remove; itemId: string }\n\t| { op: TestDiffOpType.Retire; itemId: string }\n\t| { op: TestDiffOpType.IncrementPendingExtHosts; amount: number }\n\t| { op: TestDiffOpType.AddTag; tag: ITestTagDisplayInfo }\n\t| { op: TestDiffOpType.RemoveTag; id: string }\n\t| { op: TestDiffOpType.DocumentSynced; uri: URI; docv?: number };\n\nexport namespace TestsDiffOp {\n\texport type Serialized =\n\t\t| { op: TestDiffOpType.Add; item: InternalTestItem.Serialized }\n\t\t| { op: TestDiffOpType.Update; item: ITestItemUpdate.Serialized }\n\t\t| { op: TestDiffOpType.Remove; itemId: string }\n\t\t| { op: TestDiffOpType.Retire; itemId: string }\n\t\t| { op: TestDiffOpType.IncrementPendingExtHosts; amount: number }\n\t\t| { op: TestDiffOpType.AddTag; tag: ITestTagDisplayInfo }\n\t\t| { op: TestDiffOpType.RemoveTag; id: string }\n\t\t| { op: TestDiffOpType.DocumentSynced; uri: UriComponents; docv?: number };\n\n\texport const deserialize = (uriIdentity: ITestUriCanonicalizer, u: Serialized): TestsDiffOp => {\n\t\tif (u.op === TestDiffOpType.Add) {\n\t\t\treturn { op: u.op, item: InternalTestItem.deserialize(uriIdentity, u.item) };\n\t\t} else if (u.op === TestDiffOpType.Update) {\n\t\t\treturn { op: u.op, item: ITestItemUpdate.deserialize(u.item) };\n\t\t} else if (u.op === TestDiffOpType.DocumentSynced) {\n\t\t\treturn { op: u.op, uri: uriIdentity.asCanonicalUri(URI.revive(u.uri)), docv: u.docv };\n\t\t} else {\n\t\t\treturn u;\n\t\t}\n\t};\n\n\texport const serialize = (u: Readonly<TestsDiffOp>): Serialized => {\n\t\tif (u.op === TestDiffOpType.Add) {\n\t\t\treturn { op: u.op, item: InternalTestItem.serialize(u.item) };\n\t\t} else if (u.op === TestDiffOpType.Update) {\n\t\t\treturn { op: u.op, item: ITestItemUpdate.serialize(u.item) };\n\t\t} else {\n\t\t\treturn u;\n\t\t}\n\t};\n}\n\n/**\n * Context for actions taken in the test explorer view.\n */\nexport interface ITestItemContext {\n\t/** Marshalling marker */\n\t$mid: MarshalledId.TestItemContext;\n\t/** Tests and parents from the root to the current items */\n\ttests: InternalTestItem.Serialized[];\n}\n\n/**\n * Context for actions taken in the test explorer view.\n */\nexport interface ITestMessageMenuArgs {\n\t/** Marshalling marker */\n\t$mid: MarshalledId.TestMessageMenuArgs;\n\t/** Tests ext ID */\n\ttest: InternalTestItem.Serialized;\n\t/** Serialized test message */\n\tmessage: ITestMessage.Serialized;\n}\n\n/**\n * Request from the ext host or main thread to indicate that tests have\n * changed. It's assumed that any item upserted *must* have its children\n * previously also upserted, or upserted as part of the same operation.\n * Children that no longer exist in an upserted item will be removed.\n */\nexport type TestsDiff = TestsDiffOp[];\n\n/**\n * @private\n */\nexport interface IncrementalTestCollectionItem extends InternalTestItem {\n\tchildren: Set<string>;\n}\n\n/**\n * The IncrementalChangeCollector is used in the IncrementalTestCollection\n * and called with diff changes as they're applied. This is used in the\n * ext host to create a cohesive change event from a diff.\n */\nexport interface IncrementalChangeCollector<T> {\n\t/**\n\t * A node was added.\n\t */\n\tadd?(node: T): void;\n\n\t/**\n\t * A node in the collection was updated.\n\t */\n\tupdate?(node: T): void;\n\n\t/**\n\t * A node was removed.\n\t */\n\tremove?(node: T, isNestedOperation: boolean): void;\n\n\t/**\n\t * Called when the diff has been applied.\n\t */\n\tcomplete?(): void;\n}\n\n/**\n * Maintains tests in this extension host sent from the main thread.\n */\nexport abstract class AbstractIncrementalTestCollection<T extends IncrementalTestCollectionItem> {\n\tprivate readonly _tags = new Map<string, ITestTagDisplayInfo>();\n\n\t/**\n\t * Map of item IDs to test item objects.\n\t */\n\tprotected readonly items = new Map<string, T>();\n\n\t/**\n\t * ID of test root items.\n\t */\n\tprotected readonly roots = new Set<T>();\n\n\t/**\n\t * Number of 'busy' controllers.\n\t */\n\tprotected busyControllerCount = 0;\n\n\t/**\n\t * Number of pending roots.\n\t */\n\tprotected pendingRootCount = 0;\n\n\t/**\n\t * Known test tags.\n\t */\n\tpublic readonly tags: ReadonlyMap<string, ITestTagDisplayInfo> = this._tags;\n\n\tconstructor(private readonly uriIdentity: ITestUriCanonicalizer) { }\n\n\t/**\n\t * Applies the diff to the collection.\n\t */\n\tpublic apply(diff: TestsDiff) {\n\t\tconst changes = this.createChangeCollector();\n\n\t\tfor (const op of diff) {\n\t\t\tswitch (op.op) {\n\t\t\t\tcase TestDiffOpType.Add:\n\t\t\t\t\tthis.add(InternalTestItem.deserialize(this.uriIdentity, op.item), changes);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TestDiffOpType.Update:\n\t\t\t\t\tthis.update(ITestItemUpdate.deserialize(op.item), changes);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TestDiffOpType.Remove:\n\t\t\t\t\tthis.remove(op.itemId, changes);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TestDiffOpType.Retire:\n\t\t\t\t\tthis.retireTest(op.itemId);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TestDiffOpType.IncrementPendingExtHosts:\n\t\t\t\t\tthis.updatePendingRoots(op.amount);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TestDiffOpType.AddTag:\n\t\t\t\t\tthis._tags.set(op.tag.id, op.tag);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TestDiffOpType.RemoveTag:\n\t\t\t\t\tthis._tags.delete(op.id);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tchanges.complete?.();\n\t}\n\n\tprotected add(item: InternalTestItem, changes: IncrementalChangeCollector<T>\n\t) {\n\t\tconst parentId = TestId.parentId(item.item.extId)?.toString();\n\t\tlet created: T;\n\t\tif (!parentId) {\n\t\t\tcreated = this.createItem(item);\n\t\t\tthis.roots.add(created);\n\t\t\tthis.items.set(item.item.extId, created);\n\t\t} else if (this.items.has(parentId)) {\n\t\t\tconst parent = this.items.get(parentId)!;\n\t\t\tparent.children.add(item.item.extId);\n\t\t\tcreated = this.createItem(item, parent);\n\t\t\tthis.items.set(item.item.extId, created);\n\t\t} else {\n\t\t\tconsole.error(`Test with unknown parent ID: ${JSON.stringify(item)}`);\n\t\t\treturn;\n\t\t}\n\n\t\tchanges.add?.(created);\n\t\tif (item.expand === TestItemExpandState.BusyExpanding) {\n\t\t\tthis.busyControllerCount++;\n\t\t}\n\n\t\treturn created;\n\t}\n\n\tprotected update(patch: ITestItemUpdate, changes: IncrementalChangeCollector<T>\n\t) {\n\t\tconst existing = this.items.get(patch.extId);\n\t\tif (!existing) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (patch.expand !== undefined) {\n\t\t\tif (existing.expand === TestItemExpandState.BusyExpanding) {\n\t\t\t\tthis.busyControllerCount--;\n\t\t\t}\n\t\t\tif (patch.expand === TestItemExpandState.BusyExpanding) {\n\t\t\t\tthis.busyControllerCount++;\n\t\t\t}\n\t\t}\n\n\t\tapplyTestItemUpdate(existing, patch);\n\t\tchanges.update?.(existing);\n\t\treturn existing;\n\t}\n\n\tprotected remove(itemId: string, changes: IncrementalChangeCollector<T>) {\n\t\tconst toRemove = this.items.get(itemId);\n\t\tif (!toRemove) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst parentId = TestId.parentId(toRemove.item.extId)?.toString();\n\t\tif (parentId) {\n\t\t\tconst parent = this.items.get(parentId)!;\n\t\t\tparent.children.delete(toRemove.item.extId);\n\t\t} else {\n\t\t\tthis.roots.delete(toRemove);\n\t\t}\n\n\t\tconst queue: Iterable<string>[] = [[itemId]];\n\t\twhile (queue.length) {\n\t\t\tfor (const itemId of queue.pop()!) {\n\t\t\t\tconst existing = this.items.get(itemId);\n\t\t\t\tif (existing) {\n\t\t\t\t\tqueue.push(existing.children);\n\t\t\t\t\tthis.items.delete(itemId);\n\t\t\t\t\tchanges.remove?.(existing, existing !== toRemove);\n\n\t\t\t\t\tif (existing.expand === TestItemExpandState.BusyExpanding) {\n\t\t\t\t\t\tthis.busyControllerCount--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Called when the extension signals a test result should be retired.\n\t */\n\tprotected retireTest(testId: string) {\n\t\t// no-op\n\t}\n\n\t/**\n\t * Updates the number of test root sources who are yet to report. When\n\t * the total pending test roots reaches 0, the roots for all controllers\n\t * will exist in the collection.\n\t */\n\tpublic updatePendingRoots(delta: number) {\n\t\tthis.pendingRootCount += delta;\n\t}\n\n\t/**\n\t * Called before a diff is applied to create a new change collector.\n\t */\n\tprotected createChangeCollector(): IncrementalChangeCollector<T> {\n\t\treturn {};\n\t}\n\n\t/**\n\t * Creates a new item for the collection from the internal test item.\n\t */\n\tprotected abstract createItem(internal: InternalTestItem, parent?: T): T;\n}\n"],
  "mappings": "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",
  "names": ["TestResultState", "ExtTestRunProfileKind", "TestControllerCapability", "TestRunProfileBitset", "IRichLocation", "TestMessageType", "ITestMessageStackFrame", "ITestErrorMessage", "ITestOutputMessage", "ITestMessage", "ITestTaskState", "ITestItem", "TestItemExpandState", "InternalTestItem", "ITestItemUpdate", "TestResultItem", "ICoverageCount", "IFileCoverage", "DetailType", "CoverageDetails", "IBranchCoverage", "IDeclarationCoverage", "IStatementCoverage", "TestDiffOpType", "TestsDiffOp", "itemId"]
}
