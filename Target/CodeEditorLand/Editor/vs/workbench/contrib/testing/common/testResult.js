var M=Object.defineProperty;var B=Object.getOwnPropertyDescriptor;var y=(a,n,e,s)=>{for(var t=s>1?void 0:s?B(n,e):n,r=a.length-1,i;r>=0;r--)(i=a[r])&&(t=(s?i(n,e,t):i(t))||t);return s&&t&&M(n,e,t),t},S=(a,n)=>(e,s)=>n(e,s,a);import{DeferredPromise as E}from"../../../../../vs/base/common/async.js";import{VSBuffer as c}from"../../../../../vs/base/common/buffer.js";import{Emitter as h,Event as O}from"../../../../../vs/base/common/event.js";import{Lazy as R}from"../../../../../vs/base/common/lazy.js";import{Disposable as A}from"../../../../../vs/base/common/lifecycle.js";import{observableValue as k}from"../../../../../vs/base/common/observable.js";import{language as D}from"../../../../../vs/base/common/platform.js";import"../../../../../vs/base/common/prefixTree.js";import{localize as v}from"../../../../../vs/nls.js";import{ITelemetryService as L}from"../../../../../vs/platform/telemetry/common/telemetry.js";import"../../../../../vs/platform/uriIdentity/common/uriIdentity.js";import{refreshComputedState as N}from"../../../../../vs/workbench/contrib/testing/common/getComputedState.js";import"../../../../../vs/workbench/contrib/testing/common/testCoverage.js";import{TestId as T}from"../../../../../vs/workbench/contrib/testing/common/testId.js";import{makeEmptyCounts as C,maxPriority as P,statesInOrder as W,terminalStatePriorities as w}from"../../../../../vs/workbench/contrib/testing/common/testingStates.js";import{getMarkId as z,TestItemExpandState as U,TestMessageType as q,TestResultItem as b,TestResultState as l}from"../../../../../vs/workbench/contrib/testing/common/testTypes.js";const V={buffers:[],length:0,onDidWriteData:O.None,endPromise:Promise.resolve(),getRange:()=>c.alloc(0),getRangeIter:()=>[]};class F{writeDataEmitter=new h;endDeferred=new E;offset=0;onDidWriteData=this.writeDataEmitter.event;endPromise=this.endDeferred.p;buffers=[];get length(){return this.offset}getRange(n,e){const s=c.alloc(e);let t=0;for(const r of this.getRangeIter(n,e))s.buffer.set(r.buffer,t),t+=r.byteLength;return t<e?s.slice(0,t):s}*getRangeIter(n,e){let s=0,t=0;for(const r of this.buffers){if(t+r.byteLength<=n){t+=r.byteLength;continue}const i=Math.max(0,n-t),o=Math.min(r.byteLength,i+e-s);if(yield r.slice(i,o),s+=o-i,t+=r.byteLength,s===e)break}}append(n,e){const s=this.offset;let t=n.byteLength;if(e===void 0)return this.push(n),{offset:s,length:t};let r;(p=>(p[p.CR=13]="CR",p[p.LF=10]="LF"))(r||={});const i=c.fromString(x(e,!0)),o=c.fromString(x(e,!1));t+=i.byteLength+o.byteLength,this.push(i);let u=n.byteLength;for(;u>0;u--){const d=n.buffer[u-1];if(d!==13&&d!==10)break}return this.push(n.slice(0,u)),this.push(o),this.push(n.slice(u)),{offset:s,length:t}}push(n){n.byteLength!==0&&(this.buffers.push(n),this.writeDataEmitter.fire(n),this.offset+=n.byteLength)}end(){this.endDeferred.complete()}}const Re=function*(a,n){for(const e of T.fromString(n.item.extId).idsToRoot())yield a.getStateById(e.toString())},ke=a=>{for(const n of W)if(a[n]>0)return n;return l.Unset},x=(a,n)=>`\x1B]633;SetMark;Id=${z(a,n)};Hidden\x07`,_=(a,n,e)=>({controllerId:a,expand:U.NotExpandable,item:{...n},children:[],tasks:[],ownComputedState:l.Unset,computedState:l.Unset});var J=(s=>(s[s.ComputedStateChange=0]="ComputedStateChange",s[s.OwnStateChange=1]="OwnStateChange",s[s.NewMessage=2]="NewMessage",s))(J||{});let f=class extends A{constructor(e,s,t,r){super();this.id=e;this.persist=s;this.request=t;this.telemetry=r}completeEmitter=this._register(new h);newTaskEmitter=this._register(new h);endTaskEmitter=this._register(new h);changeEmitter=this._register(new h);testById=new Map;testMarkerCounter=0;_completedAt;startedAt=Date.now();onChange=this.changeEmitter.event;onComplete=this.completeEmitter.event;onNewTask=this.newTaskEmitter.event;onEndTask=this.endTaskEmitter.event;tasks=[];name=v("runFinished","Test run at {0}",new Date().toLocaleString(D));get completedAt(){return this._completedAt}counts=C();get tests(){return this.testById.values()}getTestById(e){return this.testById.get(e)?.item}computedStateAccessor={getOwnState:e=>e.ownComputedState,getCurrentComputedState:e=>e.computedState,setComputedState:(e,s)=>e.computedState=s,getChildren:e=>e.children,getParents:e=>{const{testById:s}=this;return function*(){const t=T.fromString(e.item.extId).parentId;if(t)for(const r of t.idsToRoot())yield s.get(r.toString())}()}};getStateById(e){return this.testById.get(e)}appendOutput(e,s,t,r){const i=e.byteLength>100?e.slice(0,100).toString()+"\u2026":e.toString();let o;(r||t)&&(o=this.testMarkerCounter++);const u=this.mustGetTaskIndex(s),d=this.tasks[u],{offset:m,length:p}=d.output.append(e,o),g={location:t,message:i,offset:m,length:p,marker:o,type:q.Output},I=r&&this.testById.get(r);I?(I.tasks[u].messages.push(g),this.changeEmitter.fire({item:I,result:this,reason:2,message:g})):d.otherMessages.push(g)}addTask(e){this.tasks.push({...e,coverage:k(this,void 0),otherMessages:[],output:new F});for(const s of this.tests)s.tasks.push({duration:void 0,messages:[],state:l.Unset});this.newTaskEmitter.fire(this.tasks.length-1)}addTestChainToRun(e,s){let t=this.testById.get(s[0].extId);t||(t=this.addTestToRun(e,s[0],null));for(let r=1;r<s.length;r++)t=this.addTestToRun(e,s[r],t.item.extId)}updateState(e,s,t,r){const i=this.testById.get(e);if(!i)return;const o=this.mustGetTaskIndex(s),u=w[i.tasks[o].state],d=w[t];u!==void 0&&(d===void 0||d<u)||this.fireUpdateAndRefresh(i,o,t,r)}appendMessage(e,s,t){const r=this.testById.get(e);r&&(r.tasks[this.mustGetTaskIndex(s)].messages.push(t),this.changeEmitter.fire({item:r,result:this,reason:2,message:t}))}markTaskComplete(e){const s=this.mustGetTaskIndex(e),t=this.tasks[s];t.running=!1,t.output.end(),this.setAllToState(l.Unset,e,r=>r.state===l.Queued||r.state===l.Running),this.endTaskEmitter.fire(s)}markComplete(){if(this._completedAt!==void 0)throw new Error("cannot complete a test result multiple times");for(const e of this.tasks)e.running&&this.markTaskComplete(e.id);this._completedAt=Date.now(),this.completeEmitter.fire(),this.telemetry.publicLog2("test.outcomes",{failures:this.counts[l.Errored]+this.counts[l.Failed],passes:this.counts[l.Passed],controller:this.request.targets.map(e=>e.controllerId).join(",")})}markRetired(e){for(const[s,t]of this.testById)!t.retired&&(!e||e.hasKeyOrParent(T.fromString(s).path))&&(t.retired=!0,this.changeEmitter.fire({reason:0,item:t,result:this}))}toJSON(){return this.completedAt&&this.persist?this.doSerialize.value:void 0}toJSONWithMessages(){return this.completedAt&&this.persist?this.doSerializeWithMessages.value:void 0}setAllToState(e,s,t){const r=this.mustGetTaskIndex(s);for(const i of this.testById.values())t(i.tasks[r],i)&&this.fireUpdateAndRefresh(i,r,e)}fireUpdateAndRefresh(e,s,t,r){const i=e.ownComputedState,o=e.ownDuration,u={item:e,result:this,reason:1,previousState:i,previousOwnDuration:o};e.tasks[s].state=t,r!==void 0&&(e.tasks[s].duration=r,e.ownDuration=Math.max(e.ownDuration||0,r));const d=P(...e.tasks.map(m=>m.state));if(d===i){r!==o&&this.changeEmitter.fire(u);return}e.ownComputedState=d,this.counts[i]--,this.counts[d]++,N(this.computedStateAccessor,e).forEach(m=>this.changeEmitter.fire(m===e?u:{item:m,result:this,reason:0}))}addTestToRun(e,s,t){const r=_(e,s,t);if(this.testById.set(s.extId,r),this.counts[l.Unset]++,t&&this.testById.get(t)?.children.push(r),this.tasks.length)for(let i=0;i<this.tasks.length;i++)r.tasks.push({duration:void 0,messages:[],state:l.Unset});return r}mustGetTaskIndex(e){const s=this.tasks.findIndex(t=>t.id===e);if(s===-1)throw new Error(`Unknown task ${e} in updateState`);return s}doSerialize=new R(()=>({id:this.id,completedAt:this.completedAt,tasks:this.tasks.map(e=>({id:e.id,name:e.name,ctrlId:e.ctrlId,hasCoverage:!!e.coverage.get()})),name:this.name,request:this.request,items:[...this.testById.values()].map(b.serializeWithoutMessages)}));doSerializeWithMessages=new R(()=>({id:this.id,completedAt:this.completedAt,tasks:this.tasks.map(e=>({id:e.id,name:e.name,ctrlId:e.ctrlId,hasCoverage:!!e.coverage.get()})),name:this.name,request:this.request,items:[...this.testById.values()].map(b.serialize)}))};f=y([S(3,L)],f);class ve{constructor(n,e,s=!0){this.serialized=e;this.persist=s;this.id=e.id,this.completedAt=e.completedAt,this.tasks=e.tasks.map((t,r)=>({id:t.id,name:t.name||v("testUnnamedTask","Unnamed Task"),ctrlId:t.ctrlId,running:!1,coverage:k(this,void 0),output:V,otherMessages:[]})),this.name=e.name,this.request=e.request;for(const t of e.items){const r=b.deserialize(n,t);this.counts[r.ownComputedState]++,this.testById.set(t.item.extId,r)}}counts=C();id;completedAt;tasks;get tests(){return this.testById.values()}name;request;testById=new Map;getStateById(n){return this.testById.get(n)}toJSON(){return this.persist?this.serialized:void 0}toJSONWithMessages(){return this.toJSON()}}export{ve as HydratedTestResult,f as LiveTestResult,F as TaskRawOutput,J as TestResultItemChangeReason,ke as maxCountPriority,Re as resultItemParents};
