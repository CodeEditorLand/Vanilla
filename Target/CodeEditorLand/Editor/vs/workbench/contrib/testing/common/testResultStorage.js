var b=Object.defineProperty;var P=Object.getOwnPropertyDescriptor;var h=(u,i,e,t)=>{for(var r=t>1?void 0:t?P(i,e):i,s=u.length-1,a;s>=0;s--)(a=u[s])&&(r=(t?a(i,e,r):a(r))||r);return t&&r&&b(i,e,r),r},n=(u,i)=>(e,t)=>i(e,t,u);import{bufferToStream as w,newWriteableBufferStream as F,VSBuffer as l}from"../../../../../vs/base/common/buffer.js";import{Disposable as O}from"../../../../../vs/base/common/lifecycle.js";import{isDefined as T}from"../../../../../vs/base/common/types.js";import{URI as g}from"../../../../../vs/base/common/uri.js";import{IEnvironmentService as B}from"../../../../../vs/platform/environment/common/environment.js";import{IFileService as E}from"../../../../../vs/platform/files/common/files.js";import{createDecorator as A}from"../../../../../vs/platform/instantiation/common/instantiation.js";import{ILogService as R}from"../../../../../vs/platform/log/common/log.js";import{IStorageService as v,StorageScope as V,StorageTarget as x}from"../../../../../vs/platform/storage/common/storage.js";import{IUriIdentityService as y}from"../../../../../vs/platform/uriIdentity/common/uriIdentity.js";import{IWorkspaceContextService as M}from"../../../../../vs/platform/workspace/common/workspace.js";import{StoredValue as N}from"../../../../../vs/workbench/contrib/testing/common/storedValue.js";import{HydratedTestResult as W}from"../../../../../vs/workbench/contrib/testing/common/testResult.js";import"../../../../../vs/workbench/contrib/testing/common/testTypes.js";const _=128,k=16,L=1024*128,z=.2,oe=A("ITestResultStorage"),p=1;let c=class extends O{constructor(e,t,r){super();this.uriIdentityService=e;this.storageService=t;this.logService=r}stored=this._register(new N({key:"storedTestResults",scope:V.WORKSPACE,target:x.MACHINE},this.storageService));async read(){return(await Promise.all(this.stored.get([]).map(async({id:t,rev:r})=>{if(r===p)try{const s=await this.readForResultId(t);return s?new W(this.uriIdentityService,s):void 0}catch(s){this.logService.warn(`Error deserializing stored test result ${t}`,s);return}}))).filter(T)}getResultOutputWriter(e){const t=F();return this.storeOutputForResultId(e,t),t}async persist(e){const t=new Map(this.stored.get([]).map(({id:o,bytes:d})=>[o,d])),r=[],s=[];let a=L;for(let o=0;o<e.length&&o<_&&(a>0||r.length<k);o++){const d=e[o],f=t.get(d.id);if(f!==void 0){t.delete(d.id),r.push({id:d.id,rev:p,bytes:f}),a-=f;continue}const S=d.toJSON();if(!S)continue;const I=l.fromString(JSON.stringify(S));s.push(this.storeForResultId(d.id,S)),r.push({id:d.id,rev:p,bytes:I.byteLength}),a-=I.byteLength}for(const o of t.keys())s.push(this.deleteForResultId(o).catch(()=>{}));this.stored.store(r),await Promise.all(s)}};c=h([n(0,y),n(1,v),n(2,R)],c);class ne extends c{cache=new Map;async readForResultId(i){return Promise.resolve(this.cache.get(i))}storeForResultId(i,e){return this.cache.set(i,e),Promise.resolve()}deleteForResultId(i){return this.cache.delete(i),Promise.resolve()}readOutputForResultId(i){throw new Error("Method not implemented.")}storeOutputForResultId(i,e){throw new Error("Method not implemented.")}readOutputRangeForResultId(i,e,t){throw new Error("Method not implemented.")}}let m=class extends c{constructor(e,t,r,s,a,o){super(e,t,r);this.fileService=a;this.directory=g.joinPath(o.workspaceStorageHome,s.getWorkspace().id,"testResults")}directory;async readForResultId(e){const t=await this.fileService.readFile(this.getResultJsonPath(e));return JSON.parse(t.value.toString())}storeForResultId(e,t){return this.fileService.writeFile(this.getResultJsonPath(e),l.fromString(JSON.stringify(t)))}deleteForResultId(e){return this.fileService.del(this.getResultJsonPath(e)).catch(()=>{})}async readOutputRangeForResultId(e,t,r){try{const{value:s}=await this.fileService.readFile(this.getResultOutputPath(e),{position:t,length:r});return s}catch{return l.alloc(0)}}async readOutputForResultId(e){try{const{value:t}=await this.fileService.readFileStream(this.getResultOutputPath(e));return t}catch{return w(l.alloc(0))}}async storeOutputForResultId(e,t){await this.fileService.createFile(this.getResultOutputPath(e),t)}async persist(e){await super.persist(e),Math.random()<z&&await this.cleanupDereferenced()}async cleanupDereferenced(){const{children:e}=await this.fileService.resolve(this.directory);if(!e)return;const t=new Set(this.stored.get([]).filter(r=>r.rev===p).map(r=>r.id));await Promise.all(e.filter(r=>!t.has(r.name.replace(/\.[a-z]+$/,""))).map(r=>this.fileService.del(r.resource).catch(()=>{})))}getResultJsonPath(e){return g.joinPath(this.directory,`${e}.json`)}getResultOutputPath(e){return g.joinPath(this.directory,`${e}.output`)}};m=h([n(0,y),n(1,v),n(2,R),n(3,M),n(4,E),n(5,B)],m);export{c as BaseTestResultStorage,oe as ITestResultStorage,ne as InMemoryResultStorage,_ as RETAIN_MAX_RESULTS,m as TestResultStorage};
