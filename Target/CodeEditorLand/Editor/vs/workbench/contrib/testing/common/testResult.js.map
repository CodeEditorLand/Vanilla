{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/testing/common/testResult.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DeferredPromise } from \"../../../../base/common/async.js\";\nimport { VSBuffer } from \"../../../../base/common/buffer.js\";\nimport { Emitter, Event } from \"../../../../base/common/event.js\";\nimport { Lazy } from \"../../../../base/common/lazy.js\";\nimport { Disposable } from \"../../../../base/common/lifecycle.js\";\nimport {\n\ttype IObservable,\n\tobservableValue,\n} from \"../../../../base/common/observable.js\";\nimport { language } from \"../../../../base/common/platform.js\";\nimport type { WellDefinedPrefixTree } from \"../../../../base/common/prefixTree.js\";\nimport { localize } from \"../../../../nls.js\";\nimport { ITelemetryService } from \"../../../../platform/telemetry/common/telemetry.js\";\nimport type { IUriIdentityService } from \"../../../../platform/uriIdentity/common/uriIdentity.js\";\nimport {\n\ttype IComputedStateAccessor,\n\trefreshComputedState,\n} from \"./getComputedState.js\";\nimport type { TestCoverage } from \"./testCoverage.js\";\nimport { TestId } from \"./testId.js\";\nimport {\n\ttype IRichLocation,\n\ttype ISerializedTestResults,\n\ttype ITestItem,\n\ttype ITestMessage,\n\ttype ITestOutputMessage,\n\ttype ITestRunTask,\n\ttype ITestTaskState,\n\ttype ResolvedTestRunRequest,\n\tTestItemExpandState,\n\tTestMessageType,\n\tTestResultItem,\n\tTestResultState,\n\tgetMarkId,\n} from \"./testTypes.js\";\nimport {\n\ttype TestStateCount,\n\tmakeEmptyCounts,\n\tmaxPriority,\n\tstatesInOrder,\n\tterminalStatePriorities,\n} from \"./testingStates.js\";\n\nexport interface ITestRunTaskResults extends ITestRunTask {\n\t/**\n\t * Contains test coverage for the result, if it's available.\n\t */\n\treadonly coverage: IObservable<TestCoverage | undefined>;\n\n\t/**\n\t * Messages from the task not associated with any specific test.\n\t */\n\treadonly otherMessages: ITestOutputMessage[];\n\n\t/**\n\t * Test results output for the task.\n\t */\n\treadonly output: ITaskRawOutput;\n}\n\nexport interface ITestResult {\n\t/**\n\t * Count of the number of tests in each run state.\n\t */\n\treadonly counts: Readonly<TestStateCount>;\n\n\t/**\n\t * Unique ID of this set of test results.\n\t */\n\treadonly id: string;\n\n\t/**\n\t * If the test is completed, the unix milliseconds time at which it was\n\t * completed. If undefined, the test is still running.\n\t */\n\treadonly completedAt: number | undefined;\n\n\t/**\n\t * Whether this test result is triggered from an auto run.\n\t */\n\treadonly request: ResolvedTestRunRequest;\n\n\t/**\n\t * Human-readable name of the test result.\n\t */\n\treadonly name: string;\n\n\t/**\n\t * Gets all tests involved in the run.\n\t */\n\ttests: IterableIterator<TestResultItem>;\n\n\t/**\n\t * List of this result's subtasks.\n\t */\n\ttasks: ReadonlyArray<ITestRunTaskResults>;\n\n\t/**\n\t * Gets the state of the test by its extension-assigned ID.\n\t */\n\tgetStateById(testExtId: string): TestResultItem | undefined;\n\n\t/**\n\t * Serializes the test result. Used to save and restore results\n\t * in the workspace.\n\t */\n\ttoJSON(): ISerializedTestResults | undefined;\n\n\t/**\n\t * Serializes the test result, includes messages. Used to send the test states to the extension host.\n\t */\n\ttoJSONWithMessages(): ISerializedTestResults | undefined;\n}\n\n/**\n * Output type exposed from live test results.\n */\nexport interface ITaskRawOutput {\n\treadonly onDidWriteData: Event<VSBuffer>;\n\treadonly endPromise: Promise<void>;\n\treadonly buffers: VSBuffer[];\n\treadonly length: number;\n\n\t/** Gets a continuous buffer for the desired range */\n\tgetRange(start: number, length: number): VSBuffer;\n\t/** Gets an iterator of buffers for the range; may avoid allocation of getRange() */\n\tgetRangeIter(start: number, length: number): Iterable<VSBuffer>;\n}\n\nconst emptyRawOutput: ITaskRawOutput = {\n\tbuffers: [],\n\tlength: 0,\n\tonDidWriteData: Event.None,\n\tendPromise: Promise.resolve(),\n\tgetRange: () => VSBuffer.alloc(0),\n\tgetRangeIter: () => [],\n};\n\nexport class TaskRawOutput implements ITaskRawOutput {\n\tprivate readonly writeDataEmitter = new Emitter<VSBuffer>();\n\tprivate readonly endDeferred = new DeferredPromise<void>();\n\tprivate offset = 0;\n\n\t/** @inheritdoc */\n\tpublic readonly onDidWriteData = this.writeDataEmitter.event;\n\n\t/** @inheritdoc */\n\tpublic readonly endPromise = this.endDeferred.p;\n\n\t/** @inheritdoc */\n\tpublic readonly buffers: VSBuffer[] = [];\n\n\t/** @inheritdoc */\n\tpublic get length() {\n\t\treturn this.offset;\n\t}\n\n\t/** @inheritdoc */\n\tgetRange(start: number, length: number): VSBuffer {\n\t\tconst buf = VSBuffer.alloc(length);\n\t\tlet bufLastWrite = 0;\n\t\tfor (const chunk of this.getRangeIter(start, length)) {\n\t\t\tbuf.buffer.set(chunk.buffer, bufLastWrite);\n\t\t\tbufLastWrite += chunk.byteLength;\n\t\t}\n\n\t\treturn bufLastWrite < length ? buf.slice(0, bufLastWrite) : buf;\n\t}\n\n\t/** @inheritdoc */\n\t*getRangeIter(start: number, length: number) {\n\t\tlet soFar = 0;\n\t\tlet internalLastRead = 0;\n\t\tfor (const b of this.buffers) {\n\t\t\tif (internalLastRead + b.byteLength <= start) {\n\t\t\t\tinternalLastRead += b.byteLength;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst bstart = Math.max(0, start - internalLastRead);\n\t\t\tconst bend = Math.min(b.byteLength, bstart + length - soFar);\n\n\t\t\tyield b.slice(bstart, bend);\n\t\t\tsoFar += bend - bstart;\n\t\t\tinternalLastRead += b.byteLength;\n\n\t\t\tif (soFar === length) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Appends data to the output, returning the byte range where the data can be found.\n\t */\n\tpublic append(data: VSBuffer, marker?: number) {\n\t\tconst offset = this.offset;\n\t\tlet length = data.byteLength;\n\t\tif (marker === undefined) {\n\t\t\tthis.push(data);\n\t\t\treturn { offset, length };\n\t\t}\n\n\t\t// Bytes that should be 'trimmed' off the end of data. This is done because\n\t\t// selections in the terminal are based on the entire line, and commonly\n\t\t// the interesting marked range has a trailing new line. We don't want to\n\t\t// select the trailing line (which might have other data)\n\t\t// so we place the marker before all trailing trimbytes.\n\t\tenum TrimBytes {\n\t\t\tCR = 13,\n\t\t\tLF = 10,\n\t\t}\n\n\t\tconst start = VSBuffer.fromString(getMarkCode(marker, true));\n\t\tconst end = VSBuffer.fromString(getMarkCode(marker, false));\n\t\tlength += start.byteLength + end.byteLength;\n\n\t\tthis.push(start);\n\t\tlet trimLen = data.byteLength;\n\t\tfor (; trimLen > 0; trimLen--) {\n\t\t\tconst last = data.buffer[trimLen - 1];\n\t\t\tif (last !== TrimBytes.CR && last !== TrimBytes.LF) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tthis.push(data.slice(0, trimLen));\n\t\tthis.push(end);\n\t\tthis.push(data.slice(trimLen));\n\n\t\treturn { offset, length };\n\t}\n\n\tprivate push(data: VSBuffer) {\n\t\tif (data.byteLength === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.buffers.push(data);\n\t\tthis.writeDataEmitter.fire(data);\n\t\tthis.offset += data.byteLength;\n\t}\n\n\t/** Signals the output has ended. */\n\tpublic end() {\n\t\tthis.endDeferred.complete();\n\t}\n}\n\nexport const resultItemParents = function* (\n\tresults: ITestResult,\n\titem: TestResultItem,\n) {\n\tfor (const id of TestId.fromString(item.item.extId).idsToRoot()) {\n\t\tyield results.getStateById(id.toString())!;\n\t}\n};\n\nexport const maxCountPriority = (counts: Readonly<TestStateCount>) => {\n\tfor (const state of statesInOrder) {\n\t\tif (counts[state] > 0) {\n\t\t\treturn state;\n\t\t}\n\t}\n\n\treturn TestResultState.Unset;\n};\n\nconst getMarkCode = (marker: number, start: boolean) =>\n\t`\\x1b]633;SetMark;Id=${getMarkId(marker, start)};Hidden\\x07`;\n\ninterface TestResultItemWithChildren extends TestResultItem {\n\t/** Children in the run */\n\tchildren: TestResultItemWithChildren[];\n}\n\nconst itemToNode = (\n\tcontrollerId: string,\n\titem: ITestItem,\n\tparent: string | null,\n): TestResultItemWithChildren => ({\n\tcontrollerId,\n\texpand: TestItemExpandState.NotExpandable,\n\titem: { ...item },\n\tchildren: [],\n\ttasks: [],\n\townComputedState: TestResultState.Unset,\n\tcomputedState: TestResultState.Unset,\n});\n\nexport enum TestResultItemChangeReason {\n\tComputedStateChange = 0,\n\tOwnStateChange = 1,\n\tNewMessage = 2,\n}\n\nexport type TestResultItemChange = {\n\titem: TestResultItem;\n\tresult: ITestResult;\n} & (\n\t| { reason: TestResultItemChangeReason.ComputedStateChange }\n\t| {\n\t\t\treason: TestResultItemChangeReason.OwnStateChange;\n\t\t\tpreviousState: TestResultState;\n\t\t\tpreviousOwnDuration: number | undefined;\n\t  }\n\t| { reason: TestResultItemChangeReason.NewMessage; message: ITestMessage }\n);\n\n/**\n * Results of a test. These are created when the test initially started running\n * and marked as \"complete\" when the run finishes.\n */\nexport class LiveTestResult extends Disposable implements ITestResult {\n\tprivate readonly completeEmitter = this._register(new Emitter<void>());\n\tprivate readonly newTaskEmitter = this._register(new Emitter<number>());\n\tprivate readonly endTaskEmitter = this._register(new Emitter<number>());\n\tprivate readonly changeEmitter = this._register(\n\t\tnew Emitter<TestResultItemChange>(),\n\t);\n\t/** todo@connor4312: convert to a WellDefinedPrefixTree */\n\tprivate readonly testById = new Map<string, TestResultItemWithChildren>();\n\tprivate testMarkerCounter = 0;\n\tprivate _completedAt?: number;\n\n\tpublic readonly startedAt = Date.now();\n\tpublic readonly onChange = this.changeEmitter.event;\n\tpublic readonly onComplete = this.completeEmitter.event;\n\tpublic readonly onNewTask = this.newTaskEmitter.event;\n\tpublic readonly onEndTask = this.endTaskEmitter.event;\n\tpublic readonly tasks: (ITestRunTaskResults & { output: TaskRawOutput })[] =\n\t\t[];\n\tpublic readonly name = localize(\n\t\t\"runFinished\",\n\t\t\"Test run at {0}\",\n\t\tnew Date().toLocaleString(language),\n\t);\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic get completedAt() {\n\t\treturn this._completedAt;\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic readonly counts = makeEmptyCounts();\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic get tests() {\n\t\treturn this.testById.values();\n\t}\n\n\t/** Gets an included test item by ID. */\n\tpublic getTestById(id: string) {\n\t\treturn this.testById.get(id)?.item;\n\t}\n\n\tprivate readonly computedStateAccessor: IComputedStateAccessor<TestResultItemWithChildren> =\n\t\t{\n\t\t\tgetOwnState: (i) => i.ownComputedState,\n\t\t\tgetCurrentComputedState: (i) => i.computedState,\n\t\t\tsetComputedState: (i, s) => (i.computedState = s),\n\t\t\tgetChildren: (i) => i.children,\n\t\t\tgetParents: (i) => {\n\t\t\t\tconst { testById: testByExtId } = this;\n\t\t\t\treturn (function* () {\n\t\t\t\t\tconst parentId = TestId.fromString(i.item.extId).parentId;\n\t\t\t\t\tif (parentId) {\n\t\t\t\t\t\tfor (const id of parentId.idsToRoot()) {\n\t\t\t\t\t\t\tyield testByExtId.get(id.toString())!;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})();\n\t\t\t},\n\t\t};\n\n\tconstructor(\n\t\tpublic readonly id: string,\n\t\tpublic readonly persist: boolean,\n\t\tpublic readonly request: ResolvedTestRunRequest,\n\t\t@ITelemetryService private readonly telemetry: ITelemetryService,\n\t) {\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic getStateById(extTestId: string) {\n\t\treturn this.testById.get(extTestId);\n\t}\n\n\t/**\n\t * Appends output that occurred during the test run.\n\t */\n\tpublic appendOutput(\n\t\toutput: VSBuffer,\n\t\ttaskId: string,\n\t\tlocation?: IRichLocation,\n\t\ttestId?: string,\n\t): void {\n\t\tconst preview =\n\t\t\toutput.byteLength > 100\n\t\t\t\t? output.slice(0, 100).toString() + \"\u2026\"\n\t\t\t\t: output.toString();\n\t\tlet marker: number | undefined;\n\n\t\t// currently, the UI only exposes jump-to-message from tests or locations,\n\t\t// so no need to mark outputs that don't come from either of those.\n\t\tif (testId || location) {\n\t\t\tmarker = this.testMarkerCounter++;\n\t\t}\n\n\t\tconst index = this.mustGetTaskIndex(taskId);\n\t\tconst task = this.tasks[index];\n\n\t\tconst { offset, length } = task.output.append(output, marker);\n\t\tconst message: ITestOutputMessage = {\n\t\t\tlocation,\n\t\t\tmessage: preview,\n\t\t\toffset,\n\t\t\tlength,\n\t\t\tmarker,\n\t\t\ttype: TestMessageType.Output,\n\t\t};\n\n\t\tconst test = testId && this.testById.get(testId);\n\t\tif (test) {\n\t\t\ttest.tasks[index].messages.push(message);\n\t\t\tthis.changeEmitter.fire({\n\t\t\t\titem: test,\n\t\t\t\tresult: this,\n\t\t\t\treason: TestResultItemChangeReason.NewMessage,\n\t\t\t\tmessage,\n\t\t\t});\n\t\t} else {\n\t\t\ttask.otherMessages.push(message);\n\t\t}\n\t}\n\n\t/**\n\t * Adds a new run task to the results.\n\t */\n\tpublic addTask(task: ITestRunTask) {\n\t\tthis.tasks.push({\n\t\t\t...task,\n\t\t\tcoverage: observableValue(this, undefined),\n\t\t\totherMessages: [],\n\t\t\toutput: new TaskRawOutput(),\n\t\t});\n\n\t\tfor (const test of this.tests) {\n\t\t\ttest.tasks.push({\n\t\t\t\tduration: undefined,\n\t\t\t\tmessages: [],\n\t\t\t\tstate: TestResultState.Unset,\n\t\t\t});\n\t\t}\n\n\t\tthis.newTaskEmitter.fire(this.tasks.length - 1);\n\t}\n\n\t/**\n\t * Add the chain of tests to the run. The first test in the chain should\n\t * be either a test root, or a previously-known test.\n\t */\n\tpublic addTestChainToRun(\n\t\tcontrollerId: string,\n\t\tchain: ReadonlyArray<ITestItem>,\n\t) {\n\t\tlet parent = this.testById.get(chain[0].extId);\n\t\tif (!parent) {\n\t\t\t// must be a test root\n\t\t\tparent = this.addTestToRun(controllerId, chain[0], null);\n\t\t}\n\n\t\tfor (let i = 1; i < chain.length; i++) {\n\t\t\tparent = this.addTestToRun(\n\t\t\t\tcontrollerId,\n\t\t\t\tchain[i],\n\t\t\t\tparent.item.extId,\n\t\t\t);\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Updates the state of the test by its internal ID.\n\t */\n\tpublic updateState(\n\t\ttestId: string,\n\t\ttaskId: string,\n\t\tstate: TestResultState,\n\t\tduration?: number,\n\t) {\n\t\tconst entry = this.testById.get(testId);\n\t\tif (!entry) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst index = this.mustGetTaskIndex(taskId);\n\n\t\tconst oldTerminalStatePrio =\n\t\t\tterminalStatePriorities[entry.tasks[index].state];\n\t\tconst newTerminalStatePrio = terminalStatePriorities[state];\n\n\t\t// Ignore requests to set the state from one terminal state back to a\n\t\t// \"lower\" one, e.g. from failed back to passed:\n\t\tif (\n\t\t\toldTerminalStatePrio !== undefined &&\n\t\t\t(newTerminalStatePrio === undefined ||\n\t\t\t\tnewTerminalStatePrio < oldTerminalStatePrio)\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.fireUpdateAndRefresh(entry, index, state, duration);\n\t}\n\n\t/**\n\t * Appends a message for the test in the run.\n\t */\n\tpublic appendMessage(\n\t\ttestId: string,\n\t\ttaskId: string,\n\t\tmessage: ITestMessage,\n\t) {\n\t\tconst entry = this.testById.get(testId);\n\t\tif (!entry) {\n\t\t\treturn;\n\t\t}\n\n\t\tentry.tasks[this.mustGetTaskIndex(taskId)].messages.push(message);\n\t\tthis.changeEmitter.fire({\n\t\t\titem: entry,\n\t\t\tresult: this,\n\t\t\treason: TestResultItemChangeReason.NewMessage,\n\t\t\tmessage,\n\t\t});\n\t}\n\n\t/**\n\t * Marks the task in the test run complete.\n\t */\n\tpublic markTaskComplete(taskId: string) {\n\t\tconst index = this.mustGetTaskIndex(taskId);\n\t\tconst task = this.tasks[index];\n\t\ttask.running = false;\n\t\ttask.output.end();\n\n\t\tthis.setAllToState(\n\t\t\tTestResultState.Unset,\n\t\t\ttaskId,\n\t\t\t(t) =>\n\t\t\t\tt.state === TestResultState.Queued ||\n\t\t\t\tt.state === TestResultState.Running,\n\t\t);\n\n\t\tthis.endTaskEmitter.fire(index);\n\t}\n\n\t/**\n\t * Notifies the service that all tests are complete.\n\t */\n\tpublic markComplete() {\n\t\tif (this._completedAt !== undefined) {\n\t\t\tthrow new Error(\"cannot complete a test result multiple times\");\n\t\t}\n\n\t\tfor (const task of this.tasks) {\n\t\t\tif (task.running) {\n\t\t\t\tthis.markTaskComplete(task.id);\n\t\t\t}\n\t\t}\n\n\t\tthis._completedAt = Date.now();\n\t\tthis.completeEmitter.fire();\n\n\t\tthis.telemetry.publicLog2<\n\t\t\t{ failures: number; passes: number; controller: string },\n\t\t\t{\n\t\t\t\towner: \"connor4312\";\n\t\t\t\tcomment: \"Test outcome metrics. This helps us understand magnitude of feature use and how to build fix suggestions.\";\n\t\t\t\tfailures: {\n\t\t\t\t\tcomment: \"Number of test failures\";\n\t\t\t\t\tclassification: \"SystemMetaData\";\n\t\t\t\t\tpurpose: \"FeatureInsight\";\n\t\t\t\t};\n\t\t\t\tpasses: {\n\t\t\t\t\tcomment: \"Number of test failures\";\n\t\t\t\t\tclassification: \"SystemMetaData\";\n\t\t\t\t\tpurpose: \"FeatureInsight\";\n\t\t\t\t};\n\t\t\t\tcontroller: {\n\t\t\t\t\tcomment: \"The test controller being used\";\n\t\t\t\t\tclassification: \"SystemMetaData\";\n\t\t\t\t\tpurpose: \"FeatureInsight\";\n\t\t\t\t};\n\t\t\t}\n\t\t>(\"test.outcomes\", {\n\t\t\tfailures:\n\t\t\t\tthis.counts[TestResultState.Errored] +\n\t\t\t\tthis.counts[TestResultState.Failed],\n\t\t\tpasses: this.counts[TestResultState.Passed],\n\t\t\tcontroller: this.request.targets\n\t\t\t\t.map((t) => t.controllerId)\n\t\t\t\t.join(\",\"),\n\t\t});\n\t}\n\n\t/**\n\t * Marks the test and all of its children in the run as retired.\n\t */\n\tpublic markRetired(testIds: WellDefinedPrefixTree<undefined> | undefined) {\n\t\tfor (const [id, test] of this.testById) {\n\t\t\tif (\n\t\t\t\t!test.retired &&\n\t\t\t\t(!testIds || testIds.hasKeyOrParent(TestId.fromString(id).path))\n\t\t\t) {\n\t\t\t\ttest.retired = true;\n\t\t\t\tthis.changeEmitter.fire({\n\t\t\t\t\treason: TestResultItemChangeReason.ComputedStateChange,\n\t\t\t\t\titem: test,\n\t\t\t\t\tresult: this,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic toJSON(): ISerializedTestResults | undefined {\n\t\treturn this.completedAt && this.persist\n\t\t\t? this.doSerialize.value\n\t\t\t: undefined;\n\t}\n\n\tpublic toJSONWithMessages(): ISerializedTestResults | undefined {\n\t\treturn this.completedAt && this.persist\n\t\t\t? this.doSerializeWithMessages.value\n\t\t\t: undefined;\n\t}\n\n\t/**\n\t * Updates all tests in the collection to the given state.\n\t */\n\tprotected setAllToState(\n\t\tstate: TestResultState,\n\t\ttaskId: string,\n\t\twhen: (task: ITestTaskState, item: TestResultItem) => boolean,\n\t) {\n\t\tconst index = this.mustGetTaskIndex(taskId);\n\t\tfor (const test of this.testById.values()) {\n\t\t\tif (when(test.tasks[index], test)) {\n\t\t\t\tthis.fireUpdateAndRefresh(test, index, state);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate fireUpdateAndRefresh(\n\t\tentry: TestResultItem,\n\t\ttaskIndex: number,\n\t\tnewState: TestResultState,\n\t\tnewOwnDuration?: number,\n\t) {\n\t\tconst previousOwnComputed = entry.ownComputedState;\n\t\tconst previousOwnDuration = entry.ownDuration;\n\t\tconst changeEvent: TestResultItemChange = {\n\t\t\titem: entry,\n\t\t\tresult: this,\n\t\t\treason: TestResultItemChangeReason.OwnStateChange,\n\t\t\tpreviousState: previousOwnComputed,\n\t\t\tpreviousOwnDuration: previousOwnDuration,\n\t\t};\n\n\t\tentry.tasks[taskIndex].state = newState;\n\t\tif (newOwnDuration !== undefined) {\n\t\t\tentry.tasks[taskIndex].duration = newOwnDuration;\n\t\t\tentry.ownDuration = Math.max(\n\t\t\t\tentry.ownDuration || 0,\n\t\t\t\tnewOwnDuration,\n\t\t\t);\n\t\t}\n\n\t\tconst newOwnComputed = maxPriority(...entry.tasks.map((t) => t.state));\n\t\tif (newOwnComputed === previousOwnComputed) {\n\t\t\tif (newOwnDuration !== previousOwnDuration) {\n\t\t\t\tthis.changeEmitter.fire(changeEvent); // fire manually since state change won't do it\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tentry.ownComputedState = newOwnComputed;\n\t\tthis.counts[previousOwnComputed]--;\n\t\tthis.counts[newOwnComputed]++;\n\t\trefreshComputedState(this.computedStateAccessor, entry).forEach((t) =>\n\t\t\tthis.changeEmitter.fire(\n\t\t\t\tt === entry\n\t\t\t\t\t? changeEvent\n\t\t\t\t\t: {\n\t\t\t\t\t\t\titem: t,\n\t\t\t\t\t\t\tresult: this,\n\t\t\t\t\t\t\treason: TestResultItemChangeReason.ComputedStateChange,\n\t\t\t\t\t\t},\n\t\t\t),\n\t\t);\n\t}\n\n\tprivate addTestToRun(\n\t\tcontrollerId: string,\n\t\titem: ITestItem,\n\t\tparent: string | null,\n\t) {\n\t\tconst node = itemToNode(controllerId, item, parent);\n\t\tthis.testById.set(item.extId, node);\n\t\tthis.counts[TestResultState.Unset]++;\n\n\t\tif (parent) {\n\t\t\tthis.testById.get(parent)?.children.push(node);\n\t\t}\n\n\t\tif (this.tasks.length) {\n\t\t\tfor (let i = 0; i < this.tasks.length; i++) {\n\t\t\t\tnode.tasks.push({\n\t\t\t\t\tduration: undefined,\n\t\t\t\t\tmessages: [],\n\t\t\t\t\tstate: TestResultState.Unset,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tprivate mustGetTaskIndex(taskId: string) {\n\t\tconst index = this.tasks.findIndex((t) => t.id === taskId);\n\t\tif (index === -1) {\n\t\t\tthrow new Error(`Unknown task ${taskId} in updateState`);\n\t\t}\n\n\t\treturn index;\n\t}\n\n\tprivate readonly doSerialize = new Lazy(\n\t\t(): ISerializedTestResults => ({\n\t\t\tid: this.id,\n\t\t\tcompletedAt: this.completedAt!,\n\t\t\ttasks: this.tasks.map((t) => ({\n\t\t\t\tid: t.id,\n\t\t\t\tname: t.name,\n\t\t\t\tctrlId: t.ctrlId,\n\t\t\t\thasCoverage: !!t.coverage.get(),\n\t\t\t})),\n\t\t\tname: this.name,\n\t\t\trequest: this.request,\n\t\t\titems: [...this.testById.values()].map(\n\t\t\t\tTestResultItem.serializeWithoutMessages,\n\t\t\t),\n\t\t}),\n\t);\n\n\tprivate readonly doSerializeWithMessages = new Lazy(\n\t\t(): ISerializedTestResults => ({\n\t\t\tid: this.id,\n\t\t\tcompletedAt: this.completedAt!,\n\t\t\ttasks: this.tasks.map((t) => ({\n\t\t\t\tid: t.id,\n\t\t\t\tname: t.name,\n\t\t\t\tctrlId: t.ctrlId,\n\t\t\t\thasCoverage: !!t.coverage.get(),\n\t\t\t})),\n\t\t\tname: this.name,\n\t\t\trequest: this.request,\n\t\t\titems: [...this.testById.values()].map(TestResultItem.serialize),\n\t\t}),\n\t);\n}\n\n/**\n * Test results hydrated from a previously-serialized test run.\n */\nexport class HydratedTestResult implements ITestResult {\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic readonly counts = makeEmptyCounts();\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic readonly id: string;\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic readonly completedAt: number;\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic readonly tasks: ITestRunTaskResults[];\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic get tests() {\n\t\treturn this.testById.values();\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic readonly name: string;\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic readonly request: ResolvedTestRunRequest;\n\n\tprivate readonly testById = new Map<string, TestResultItem>();\n\n\tconstructor(\n\t\tidentity: IUriIdentityService,\n\t\tprivate readonly serialized: ISerializedTestResults,\n\t\tprivate readonly persist = true,\n\t) {\n\t\tthis.id = serialized.id;\n\t\tthis.completedAt = serialized.completedAt;\n\t\tthis.tasks = serialized.tasks.map((task, i) => ({\n\t\t\tid: task.id,\n\t\t\tname: task.name || localize(\"testUnnamedTask\", \"Unnamed Task\"),\n\t\t\tctrlId: task.ctrlId,\n\t\t\trunning: false,\n\t\t\tcoverage: observableValue(this, undefined),\n\t\t\toutput: emptyRawOutput,\n\t\t\totherMessages: [],\n\t\t}));\n\t\tthis.name = serialized.name;\n\t\tthis.request = serialized.request;\n\n\t\tfor (const item of serialized.items) {\n\t\t\tconst de = TestResultItem.deserialize(identity, item);\n\t\t\tthis.counts[de.ownComputedState]++;\n\t\t\tthis.testById.set(item.item.extId, de);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic getStateById(extTestId: string) {\n\t\treturn this.testById.get(extTestId);\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic toJSON(): ISerializedTestResults | undefined {\n\t\treturn this.persist ? this.serialized : undefined;\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic toJSONWithMessages(): ISerializedTestResults | undefined {\n\t\treturn this.toJSON();\n\t}\n}\n"],
  "mappings": "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",
  "names": ["TrimBytes", "TestResultItemChangeReason"]
}
