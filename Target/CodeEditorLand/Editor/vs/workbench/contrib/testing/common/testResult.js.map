{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/testing/common/testResult.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DeferredPromise } from '../../../../base/common/async.js';\nimport { VSBuffer } from '../../../../base/common/buffer.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { Lazy } from '../../../../base/common/lazy.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { IObservable, observableValue } from '../../../../base/common/observable.js';\nimport { language } from '../../../../base/common/platform.js';\nimport { WellDefinedPrefixTree } from '../../../../base/common/prefixTree.js';\nimport { localize } from '../../../../nls.js';\nimport { ITelemetryService } from '../../../../platform/telemetry/common/telemetry.js';\nimport { IUriIdentityService } from '../../../../platform/uriIdentity/common/uriIdentity.js';\nimport { IComputedStateAccessor, refreshComputedState } from './getComputedState.js';\nimport { TestCoverage } from './testCoverage.js';\nimport { TestId } from './testId.js';\nimport { makeEmptyCounts, maxPriority, statesInOrder, terminalStatePriorities, TestStateCount } from './testingStates.js';\nimport { getMarkId, IRichLocation, ISerializedTestResults, ITestItem, ITestMessage, ITestOutputMessage, ITestRunTask, ITestTaskState, ResolvedTestRunRequest, TestItemExpandState, TestMessageType, TestResultItem, TestResultState } from './testTypes.js';\n\nexport interface ITestRunTaskResults extends ITestRunTask {\n\t/**\n\t * Contains test coverage for the result, if it's available.\n\t */\n\treadonly coverage: IObservable<TestCoverage | undefined>;\n\n\t/**\n\t * Messages from the task not associated with any specific test.\n\t */\n\treadonly otherMessages: ITestOutputMessage[];\n\n\t/**\n\t * Test results output for the task.\n\t */\n\treadonly output: ITaskRawOutput;\n}\n\nexport interface ITestResult {\n\t/**\n\t * Count of the number of tests in each run state.\n\t */\n\treadonly counts: Readonly<TestStateCount>;\n\n\t/**\n\t * Unique ID of this set of test results.\n\t */\n\treadonly id: string;\n\n\t/**\n\t * If the test is completed, the unix milliseconds time at which it was\n\t * completed. If undefined, the test is still running.\n\t */\n\treadonly completedAt: number | undefined;\n\n\t/**\n\t * Whether this test result is triggered from an auto run.\n\t */\n\treadonly request: ResolvedTestRunRequest;\n\n\t/**\n\t * Human-readable name of the test result.\n\t */\n\treadonly name: string;\n\n\t/**\n\t * Gets all tests involved in the run.\n\t */\n\ttests: IterableIterator<TestResultItem>;\n\n\t/**\n\t * List of this result's subtasks.\n\t */\n\ttasks: ReadonlyArray<ITestRunTaskResults>;\n\n\t/**\n\t * Gets the state of the test by its extension-assigned ID.\n\t */\n\tgetStateById(testExtId: string): TestResultItem | undefined;\n\n\t/**\n\t * Serializes the test result. Used to save and restore results\n\t * in the workspace.\n\t */\n\ttoJSON(): ISerializedTestResults | undefined;\n\n\t/**\n\t * Serializes the test result, includes messages. Used to send the test states to the extension host.\n\t */\n\ttoJSONWithMessages(): ISerializedTestResults | undefined;\n}\n\n/**\n * Output type exposed from live test results.\n */\nexport interface ITaskRawOutput {\n\treadonly onDidWriteData: Event<VSBuffer>;\n\treadonly endPromise: Promise<void>;\n\treadonly buffers: VSBuffer[];\n\treadonly length: number;\n\n\t/** Gets a continuous buffer for the desired range */\n\tgetRange(start: number, length: number): VSBuffer;\n\t/** Gets an iterator of buffers for the range; may avoid allocation of getRange() */\n\tgetRangeIter(start: number, length: number): Iterable<VSBuffer>;\n}\n\nconst emptyRawOutput: ITaskRawOutput = {\n\tbuffers: [],\n\tlength: 0,\n\tonDidWriteData: Event.None,\n\tendPromise: Promise.resolve(),\n\tgetRange: () => VSBuffer.alloc(0),\n\tgetRangeIter: () => [],\n};\n\nexport class TaskRawOutput implements ITaskRawOutput {\n\tprivate readonly writeDataEmitter = new Emitter<VSBuffer>();\n\tprivate readonly endDeferred = new DeferredPromise<void>();\n\tprivate offset = 0;\n\n\t/** @inheritdoc */\n\tpublic readonly onDidWriteData = this.writeDataEmitter.event;\n\n\t/** @inheritdoc */\n\tpublic readonly endPromise = this.endDeferred.p;\n\n\t/** @inheritdoc */\n\tpublic readonly buffers: VSBuffer[] = [];\n\n\t/** @inheritdoc */\n\tpublic get length() {\n\t\treturn this.offset;\n\t}\n\n\t/** @inheritdoc */\n\tgetRange(start: number, length: number): VSBuffer {\n\t\tconst buf = VSBuffer.alloc(length);\n\t\tlet bufLastWrite = 0;\n\t\tfor (const chunk of this.getRangeIter(start, length)) {\n\t\t\tbuf.buffer.set(chunk.buffer, bufLastWrite);\n\t\t\tbufLastWrite += chunk.byteLength;\n\t\t}\n\n\t\treturn bufLastWrite < length ? buf.slice(0, bufLastWrite) : buf;\n\t}\n\n\t/** @inheritdoc */\n\t*getRangeIter(start: number, length: number) {\n\t\tlet soFar = 0;\n\t\tlet internalLastRead = 0;\n\t\tfor (const b of this.buffers) {\n\t\t\tif (internalLastRead + b.byteLength <= start) {\n\t\t\t\tinternalLastRead += b.byteLength;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst bstart = Math.max(0, start - internalLastRead);\n\t\t\tconst bend = Math.min(b.byteLength, bstart + length - soFar);\n\n\t\t\tyield b.slice(bstart, bend);\n\t\t\tsoFar += bend - bstart;\n\t\t\tinternalLastRead += b.byteLength;\n\n\t\t\tif (soFar === length) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Appends data to the output, returning the byte range where the data can be found.\n\t */\n\tpublic append(data: VSBuffer, marker?: number) {\n\t\tconst offset = this.offset;\n\t\tlet length = data.byteLength;\n\t\tif (marker === undefined) {\n\t\t\tthis.push(data);\n\t\t\treturn { offset, length };\n\t\t}\n\n\t\t// Bytes that should be 'trimmed' off the end of data. This is done because\n\t\t// selections in the terminal are based on the entire line, and commonly\n\t\t// the interesting marked range has a trailing new line. We don't want to\n\t\t// select the trailing line (which might have other data)\n\t\t// so we place the marker before all trailing trimbytes.\n\t\tconst enum TrimBytes {\n\t\t\tCR = 13,\n\t\t\tLF = 10,\n\t\t}\n\n\t\tconst start = VSBuffer.fromString(getMarkCode(marker, true));\n\t\tconst end = VSBuffer.fromString(getMarkCode(marker, false));\n\t\tlength += start.byteLength + end.byteLength;\n\n\t\tthis.push(start);\n\t\tlet trimLen = data.byteLength;\n\t\tfor (; trimLen > 0; trimLen--) {\n\t\t\tconst last = data.buffer[trimLen - 1];\n\t\t\tif (last !== TrimBytes.CR && last !== TrimBytes.LF) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tthis.push(data.slice(0, trimLen));\n\t\tthis.push(end);\n\t\tthis.push(data.slice(trimLen));\n\n\n\t\treturn { offset, length };\n\t}\n\n\tprivate push(data: VSBuffer) {\n\t\tif (data.byteLength === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.buffers.push(data);\n\t\tthis.writeDataEmitter.fire(data);\n\t\tthis.offset += data.byteLength;\n\t}\n\n\t/** Signals the output has ended. */\n\tpublic end() {\n\t\tthis.endDeferred.complete();\n\t}\n}\n\nexport const resultItemParents = function* (results: ITestResult, item: TestResultItem) {\n\tfor (const id of TestId.fromString(item.item.extId).idsToRoot()) {\n\t\tyield results.getStateById(id.toString())!;\n\t}\n};\n\nexport const maxCountPriority = (counts: Readonly<TestStateCount>) => {\n\tfor (const state of statesInOrder) {\n\t\tif (counts[state] > 0) {\n\t\t\treturn state;\n\t\t}\n\t}\n\n\treturn TestResultState.Unset;\n};\n\nconst getMarkCode = (marker: number, start: boolean) => `\\x1b]633;SetMark;Id=${getMarkId(marker, start)};Hidden\\x07`;\n\ninterface TestResultItemWithChildren extends TestResultItem {\n\t/** Children in the run */\n\tchildren: TestResultItemWithChildren[];\n}\n\nconst itemToNode = (controllerId: string, item: ITestItem, parent: string | null): TestResultItemWithChildren => ({\n\tcontrollerId,\n\texpand: TestItemExpandState.NotExpandable,\n\titem: { ...item },\n\tchildren: [],\n\ttasks: [],\n\townComputedState: TestResultState.Unset,\n\tcomputedState: TestResultState.Unset,\n});\n\nexport const enum TestResultItemChangeReason {\n\tComputedStateChange,\n\tOwnStateChange,\n\tNewMessage,\n}\n\nexport type TestResultItemChange = { item: TestResultItem; result: ITestResult } & (\n\t| { reason: TestResultItemChangeReason.ComputedStateChange }\n\t| { reason: TestResultItemChangeReason.OwnStateChange; previousState: TestResultState; previousOwnDuration: number | undefined }\n\t| { reason: TestResultItemChangeReason.NewMessage; message: ITestMessage }\n);\n\n/**\n * Results of a test. These are created when the test initially started running\n * and marked as \"complete\" when the run finishes.\n */\nexport class LiveTestResult extends Disposable implements ITestResult {\n\tprivate readonly completeEmitter = this._register(new Emitter<void>());\n\tprivate readonly newTaskEmitter = this._register(new Emitter<number>());\n\tprivate readonly endTaskEmitter = this._register(new Emitter<number>());\n\tprivate readonly changeEmitter = this._register(new Emitter<TestResultItemChange>());\n\t/** todo@connor4312: convert to a WellDefinedPrefixTree */\n\tprivate readonly testById = new Map<string, TestResultItemWithChildren>();\n\tprivate testMarkerCounter = 0;\n\tprivate _completedAt?: number;\n\n\tpublic readonly startedAt = Date.now();\n\tpublic readonly onChange = this.changeEmitter.event;\n\tpublic readonly onComplete = this.completeEmitter.event;\n\tpublic readonly onNewTask = this.newTaskEmitter.event;\n\tpublic readonly onEndTask = this.endTaskEmitter.event;\n\tpublic readonly tasks: (ITestRunTaskResults & { output: TaskRawOutput })[] = [];\n\tpublic readonly name = localize('runFinished', 'Test run at {0}', new Date().toLocaleString(language));\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic get completedAt() {\n\t\treturn this._completedAt;\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic readonly counts = makeEmptyCounts();\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic get tests() {\n\t\treturn this.testById.values();\n\t}\n\n\t/** Gets an included test item by ID. */\n\tpublic getTestById(id: string) {\n\t\treturn this.testById.get(id)?.item;\n\t}\n\n\tprivate readonly computedStateAccessor: IComputedStateAccessor<TestResultItemWithChildren> = {\n\t\tgetOwnState: i => i.ownComputedState,\n\t\tgetCurrentComputedState: i => i.computedState,\n\t\tsetComputedState: (i, s) => i.computedState = s,\n\t\tgetChildren: i => i.children,\n\t\tgetParents: i => {\n\t\t\tconst { testById: testByExtId } = this;\n\t\t\treturn (function* () {\n\t\t\t\tconst parentId = TestId.fromString(i.item.extId).parentId;\n\t\t\t\tif (parentId) {\n\t\t\t\t\tfor (const id of parentId.idsToRoot()) {\n\t\t\t\t\t\tyield testByExtId.get(id.toString())!;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})();\n\t\t},\n\t};\n\n\tconstructor(\n\t\tpublic readonly id: string,\n\t\tpublic readonly persist: boolean,\n\t\tpublic readonly request: ResolvedTestRunRequest,\n\t\t@ITelemetryService private readonly telemetry: ITelemetryService,\n\t) {\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic getStateById(extTestId: string) {\n\t\treturn this.testById.get(extTestId);\n\t}\n\n\t/**\n\t * Appends output that occurred during the test run.\n\t */\n\tpublic appendOutput(output: VSBuffer, taskId: string, location?: IRichLocation, testId?: string): void {\n\t\tconst preview = output.byteLength > 100 ? output.slice(0, 100).toString() + '\u2026' : output.toString();\n\t\tlet marker: number | undefined;\n\n\t\t// currently, the UI only exposes jump-to-message from tests or locations,\n\t\t// so no need to mark outputs that don't come from either of those.\n\t\tif (testId || location) {\n\t\t\tmarker = this.testMarkerCounter++;\n\t\t}\n\n\t\tconst index = this.mustGetTaskIndex(taskId);\n\t\tconst task = this.tasks[index];\n\n\t\tconst { offset, length } = task.output.append(output, marker);\n\t\tconst message: ITestOutputMessage = {\n\t\t\tlocation,\n\t\t\tmessage: preview,\n\t\t\toffset,\n\t\t\tlength,\n\t\t\tmarker,\n\t\t\ttype: TestMessageType.Output,\n\t\t};\n\n\t\tconst test = testId && this.testById.get(testId);\n\t\tif (test) {\n\t\t\ttest.tasks[index].messages.push(message);\n\t\t\tthis.changeEmitter.fire({ item: test, result: this, reason: TestResultItemChangeReason.NewMessage, message });\n\t\t} else {\n\t\t\ttask.otherMessages.push(message);\n\t\t}\n\t}\n\n\t/**\n\t * Adds a new run task to the results.\n\t */\n\tpublic addTask(task: ITestRunTask) {\n\t\tthis.tasks.push({ ...task, coverage: observableValue(this, undefined), otherMessages: [], output: new TaskRawOutput() });\n\n\t\tfor (const test of this.tests) {\n\t\t\ttest.tasks.push({ duration: undefined, messages: [], state: TestResultState.Unset });\n\t\t}\n\n\t\tthis.newTaskEmitter.fire(this.tasks.length - 1);\n\t}\n\n\t/**\n\t * Add the chain of tests to the run. The first test in the chain should\n\t * be either a test root, or a previously-known test.\n\t */\n\tpublic addTestChainToRun(controllerId: string, chain: ReadonlyArray<ITestItem>) {\n\t\tlet parent = this.testById.get(chain[0].extId);\n\t\tif (!parent) { // must be a test root\n\t\t\tparent = this.addTestToRun(controllerId, chain[0], null);\n\t\t}\n\n\t\tfor (let i = 1; i < chain.length; i++) {\n\t\t\tparent = this.addTestToRun(controllerId, chain[i], parent.item.extId);\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Updates the state of the test by its internal ID.\n\t */\n\tpublic updateState(testId: string, taskId: string, state: TestResultState, duration?: number) {\n\t\tconst entry = this.testById.get(testId);\n\t\tif (!entry) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst index = this.mustGetTaskIndex(taskId);\n\n\t\tconst oldTerminalStatePrio = terminalStatePriorities[entry.tasks[index].state];\n\t\tconst newTerminalStatePrio = terminalStatePriorities[state];\n\n\t\t// Ignore requests to set the state from one terminal state back to a\n\t\t// \"lower\" one, e.g. from failed back to passed:\n\t\tif (oldTerminalStatePrio !== undefined &&\n\t\t\t(newTerminalStatePrio === undefined || newTerminalStatePrio < oldTerminalStatePrio)) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.fireUpdateAndRefresh(entry, index, state, duration);\n\t}\n\n\t/**\n\t * Appends a message for the test in the run.\n\t */\n\tpublic appendMessage(testId: string, taskId: string, message: ITestMessage) {\n\t\tconst entry = this.testById.get(testId);\n\t\tif (!entry) {\n\t\t\treturn;\n\t\t}\n\n\t\tentry.tasks[this.mustGetTaskIndex(taskId)].messages.push(message);\n\t\tthis.changeEmitter.fire({ item: entry, result: this, reason: TestResultItemChangeReason.NewMessage, message });\n\t}\n\n\t/**\n\t * Marks the task in the test run complete.\n\t */\n\tpublic markTaskComplete(taskId: string) {\n\t\tconst index = this.mustGetTaskIndex(taskId);\n\t\tconst task = this.tasks[index];\n\t\ttask.running = false;\n\t\ttask.output.end();\n\n\t\tthis.setAllToState(\n\t\t\tTestResultState.Unset,\n\t\t\ttaskId,\n\t\t\tt => t.state === TestResultState.Queued || t.state === TestResultState.Running,\n\t\t);\n\n\t\tthis.endTaskEmitter.fire(index);\n\t}\n\n\t/**\n\t * Notifies the service that all tests are complete.\n\t */\n\tpublic markComplete() {\n\t\tif (this._completedAt !== undefined) {\n\t\t\tthrow new Error('cannot complete a test result multiple times');\n\t\t}\n\n\t\tfor (const task of this.tasks) {\n\t\t\tif (task.running) {\n\t\t\t\tthis.markTaskComplete(task.id);\n\t\t\t}\n\t\t}\n\n\t\tthis._completedAt = Date.now();\n\t\tthis.completeEmitter.fire();\n\n\t\tthis.telemetry.publicLog2<\n\t\t\t{ failures: number; passes: number; controller: string },\n\t\t\t{\n\t\t\t\towner: 'connor4312';\n\t\t\t\tcomment: 'Test outcome metrics. This helps us understand magnitude of feature use and how to build fix suggestions.';\n\t\t\t\tfailures: { comment: 'Number of test failures'; classification: 'SystemMetaData'; purpose: 'FeatureInsight' };\n\t\t\t\tpasses: { comment: 'Number of test failures'; classification: 'SystemMetaData'; purpose: 'FeatureInsight' };\n\t\t\t\tcontroller: { comment: 'The test controller being used'; classification: 'SystemMetaData'; purpose: 'FeatureInsight' };\n\t\t\t}\n\t\t>('test.outcomes', {\n\t\t\tfailures: this.counts[TestResultState.Errored] + this.counts[TestResultState.Failed],\n\t\t\tpasses: this.counts[TestResultState.Passed],\n\t\t\tcontroller: this.request.targets.map(t => t.controllerId).join(',')\n\t\t});\n\t}\n\n\t/**\n\t * Marks the test and all of its children in the run as retired.\n\t */\n\tpublic markRetired(testIds: WellDefinedPrefixTree<undefined> | undefined) {\n\t\tfor (const [id, test] of this.testById) {\n\t\t\tif (!test.retired && (!testIds || testIds.hasKeyOrParent(TestId.fromString(id).path))) {\n\t\t\t\ttest.retired = true;\n\t\t\t\tthis.changeEmitter.fire({ reason: TestResultItemChangeReason.ComputedStateChange, item: test, result: this });\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic toJSON(): ISerializedTestResults | undefined {\n\t\treturn this.completedAt && this.persist ? this.doSerialize.value : undefined;\n\t}\n\n\tpublic toJSONWithMessages(): ISerializedTestResults | undefined {\n\t\treturn this.completedAt && this.persist ? this.doSerializeWithMessages.value : undefined;\n\t}\n\n\t/**\n\t * Updates all tests in the collection to the given state.\n\t */\n\tprotected setAllToState(state: TestResultState, taskId: string, when: (task: ITestTaskState, item: TestResultItem) => boolean) {\n\t\tconst index = this.mustGetTaskIndex(taskId);\n\t\tfor (const test of this.testById.values()) {\n\t\t\tif (when(test.tasks[index], test)) {\n\t\t\t\tthis.fireUpdateAndRefresh(test, index, state);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate fireUpdateAndRefresh(entry: TestResultItem, taskIndex: number, newState: TestResultState, newOwnDuration?: number) {\n\t\tconst previousOwnComputed = entry.ownComputedState;\n\t\tconst previousOwnDuration = entry.ownDuration;\n\t\tconst changeEvent: TestResultItemChange = {\n\t\t\titem: entry,\n\t\t\tresult: this,\n\t\t\treason: TestResultItemChangeReason.OwnStateChange,\n\t\t\tpreviousState: previousOwnComputed,\n\t\t\tpreviousOwnDuration: previousOwnDuration,\n\t\t};\n\n\t\tentry.tasks[taskIndex].state = newState;\n\t\tif (newOwnDuration !== undefined) {\n\t\t\tentry.tasks[taskIndex].duration = newOwnDuration;\n\t\t\tentry.ownDuration = Math.max(entry.ownDuration || 0, newOwnDuration);\n\t\t}\n\n\t\tconst newOwnComputed = maxPriority(...entry.tasks.map(t => t.state));\n\t\tif (newOwnComputed === previousOwnComputed) {\n\t\t\tif (newOwnDuration !== previousOwnDuration) {\n\t\t\t\tthis.changeEmitter.fire(changeEvent); // fire manually since state change won't do it\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tentry.ownComputedState = newOwnComputed;\n\t\tthis.counts[previousOwnComputed]--;\n\t\tthis.counts[newOwnComputed]++;\n\t\trefreshComputedState(this.computedStateAccessor, entry).forEach(t =>\n\t\t\tthis.changeEmitter.fire(t === entry ? changeEvent : {\n\t\t\t\titem: t,\n\t\t\t\tresult: this,\n\t\t\t\treason: TestResultItemChangeReason.ComputedStateChange,\n\t\t\t}),\n\t\t);\n\t}\n\n\tprivate addTestToRun(controllerId: string, item: ITestItem, parent: string | null) {\n\t\tconst node = itemToNode(controllerId, item, parent);\n\t\tthis.testById.set(item.extId, node);\n\t\tthis.counts[TestResultState.Unset]++;\n\n\t\tif (parent) {\n\t\t\tthis.testById.get(parent)?.children.push(node);\n\t\t}\n\n\t\tif (this.tasks.length) {\n\t\t\tfor (let i = 0; i < this.tasks.length; i++) {\n\t\t\t\tnode.tasks.push({ duration: undefined, messages: [], state: TestResultState.Unset });\n\t\t\t}\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tprivate mustGetTaskIndex(taskId: string) {\n\t\tconst index = this.tasks.findIndex(t => t.id === taskId);\n\t\tif (index === -1) {\n\t\t\tthrow new Error(`Unknown task ${taskId} in updateState`);\n\t\t}\n\n\t\treturn index;\n\t}\n\n\tprivate readonly doSerialize = new Lazy((): ISerializedTestResults => ({\n\t\tid: this.id,\n\t\tcompletedAt: this.completedAt!,\n\t\ttasks: this.tasks.map(t => ({ id: t.id, name: t.name, ctrlId: t.ctrlId, hasCoverage: !!t.coverage.get() })),\n\t\tname: this.name,\n\t\trequest: this.request,\n\t\titems: [...this.testById.values()].map(TestResultItem.serializeWithoutMessages),\n\t}));\n\n\tprivate readonly doSerializeWithMessages = new Lazy((): ISerializedTestResults => ({\n\t\tid: this.id,\n\t\tcompletedAt: this.completedAt!,\n\t\ttasks: this.tasks.map(t => ({ id: t.id, name: t.name, ctrlId: t.ctrlId, hasCoverage: !!t.coverage.get() })),\n\t\tname: this.name,\n\t\trequest: this.request,\n\t\titems: [...this.testById.values()].map(TestResultItem.serialize),\n\t}));\n}\n\n/**\n * Test results hydrated from a previously-serialized test run.\n */\nexport class HydratedTestResult implements ITestResult {\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic readonly counts = makeEmptyCounts();\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic readonly id: string;\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic readonly completedAt: number;\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic readonly tasks: ITestRunTaskResults[];\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic get tests() {\n\t\treturn this.testById.values();\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic readonly name: string;\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic readonly request: ResolvedTestRunRequest;\n\n\tprivate readonly testById = new Map<string, TestResultItem>();\n\n\tconstructor(\n\t\tidentity: IUriIdentityService,\n\t\tprivate readonly serialized: ISerializedTestResults,\n\t\tprivate readonly persist = true,\n\t) {\n\t\tthis.id = serialized.id;\n\t\tthis.completedAt = serialized.completedAt;\n\t\tthis.tasks = serialized.tasks.map((task, i) => ({\n\t\t\tid: task.id,\n\t\t\tname: task.name || localize('testUnnamedTask', 'Unnamed Task'),\n\t\t\tctrlId: task.ctrlId,\n\t\t\trunning: false,\n\t\t\tcoverage: observableValue(this, undefined),\n\t\t\toutput: emptyRawOutput,\n\t\t\totherMessages: []\n\t\t}));\n\t\tthis.name = serialized.name;\n\t\tthis.request = serialized.request;\n\n\t\tfor (const item of serialized.items) {\n\t\t\tconst de = TestResultItem.deserialize(identity, item);\n\t\t\tthis.counts[de.ownComputedState]++;\n\t\t\tthis.testById.set(item.item.extId, de);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic getStateById(extTestId: string) {\n\t\treturn this.testById.get(extTestId);\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic toJSON(): ISerializedTestResults | undefined {\n\t\treturn this.persist ? this.serialized : undefined;\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic toJSONWithMessages(): ISerializedTestResults | undefined {\n\t\treturn this.toJSON();\n\t}\n}\n"],
  "mappings": "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",
  "names": ["TrimBytes", "TestResultItemChangeReason"]
}
