var v=Object.defineProperty;var T=Object.getOwnPropertyDescriptor;var y=(u,o,n,e)=>{for(var s=e>1?void 0:e?T(o,n):o,i=u.length-1,r;i>=0;i--)(r=u[i])&&(s=(e?r(o,n,s):r(s))||s);return e&&s&&v(o,n,s),s},l=(u,o)=>(n,e)=>o(n,e,u);import{VSBuffer as b}from"../../../../base/common/buffer.js";import{DisposableStore as h}from"../../../../base/common/lifecycle.js";import{removeAnsiEscapeCodes as m}from"../../../../base/common/strings.js";import{ILanguageService as M}from"../../../../editor/common/languages/language.js";import{IModelService as E}from"../../../../editor/common/services/model.js";import{ITextModelService as R}from"../../../../editor/common/services/resolverService.js";import{localize as N}from"../../../../nls.js";import{ITestResultService as O}from"./testResultService.js";import{TestMessageType as g}from"./testTypes.js";import{TEST_DATA_SCHEME as C,TestUriType as p,parseTestUri as D}from"./testingUri.js";let f=class{constructor(o,n,e,s){this.languageService=n;this.modelService=e;this.resultService=s;o.registerTextModelContentProvider(C,this)}async provideTextContent(o){const n=this.modelService.getModel(o);if(n&&!n.isDisposed())return n;const e=D(o);if(!e)return null;const s=this.resultService.getResult(e.resultId);if(!s)return null;if(e.type===p.TaskOutput){const t=s.tasks[e.taskIndex],a=this.modelService.createModel("",null,o,!1),I=c=>a.applyEdits([{range:{startColumn:1,endColumn:1,startLineNumber:Number.POSITIVE_INFINITY,endLineNumber:Number.POSITIVE_INFINITY},text:c}]),x=b.concat(t.output.buffers,t.output.length).toString();I(m(x));let k=x.length>0;const d=new h;return d.add(t.output.onDidWriteData(c=>{k||=c.byteLength>0,I(m(c.toString()))})),t.output.endPromise.then(()=>{d.isDisposed||k||(I(N("runNoOutout","The test run did not record any output.")),d.dispose())}),a.onWillDispose(()=>d.dispose()),a}const i=s?.getStateById(e.testExtId);if(!i)return null;let r,S=null;switch(e.type){case p.ResultActualOutput:{const t=i.tasks[e.taskIndex].messages[e.messageIndex];t?.type===g.Error&&(r=t.actual);break}case p.TestOutput:{r="";const t=s.tasks[e.taskIndex].output;for(const a of i.tasks[e.taskIndex].messages)a.type===g.Output&&(r+=m(t.getRange(a.offset,a.length).toString()));break}case p.ResultExpectedOutput:{const t=i.tasks[e.taskIndex].messages[e.messageIndex];t?.type===g.Error&&(r=t.expected);break}case p.ResultMessage:{const t=i.tasks[e.taskIndex].messages[e.messageIndex];if(!t)break;if(t.type===g.Output){const a=s.tasks[e.taskIndex].output.getRange(t.offset,t.length);r=m(a.toString())}else typeof t.message=="string"?r=m(t.message):(r=t.message.value,S=this.languageService.createById("markdown"))}}return r===void 0?null:this.modelService.createModel(r,S,o,!1)}};f=y([l(0,R),l(1,M),l(2,E),l(3,O)],f);export{f as TestingContentProvider};
