var y=Object.defineProperty;var T=Object.getOwnPropertyDescriptor;var v=(u,o,n,e)=>{for(var s=e>1?void 0:e?T(o,n):o,i=u.length-1,r;i>=0;i--)(r=u[i])&&(s=(e?r(o,n,s):r(s))||s);return e&&s&&y(o,n,s),s},l=(u,o)=>(n,e)=>o(n,e,u);import{VSBuffer as h}from"../../../../base/common/buffer.js";import{DisposableStore as M}from"../../../../base/common/lifecycle.js";import{removeAnsiEscapeCodes as d}from"../../../../base/common/strings.js";import{ILanguageService as b}from"../../../../editor/common/languages/language.js";import{IModelService as R}from"../../../../editor/common/services/model.js";import{ITextModelService as E}from"../../../../editor/common/services/resolverService.js";import{localize as C}from"../../../../nls.js";import{ITestResultService as D}from"./testResultService.js";import{TestMessageType as g}from"./testTypes.js";import{TEST_DATA_SCHEME as L,TestUriType as p,parseTestUri as O}from"./testingUri.js";let f=class{constructor(o,n,e,s){this.languageService=n;this.modelService=e;this.resultService=s;o.registerTextModelContentProvider(L,this)}async provideTextContent(o){const n=this.modelService.getModel(o);if(n&&!n.isDisposed())return n;const e=O(o);if(!e)return null;const s=this.resultService.getResult(e.resultId);if(!s)return null;if(e.type===p.TaskOutput){const t=s.tasks[e.taskIndex],a=this.modelService.createModel("",null,o,!1),I=m=>a.applyEdits([{range:{startColumn:1,endColumn:1,startLineNumber:1/0,endLineNumber:1/0},text:m}]),x=h.concat(t.output.buffers,t.output.length).toString();I(d(x));let k=x.length>0;const c=new M;return c.add(t.output.onDidWriteData(m=>{k||=m.byteLength>0,I(d(m.toString()))})),t.output.endPromise.then(()=>{c.isDisposed||k||(I(C("runNoOutout","The test run did not record any output.")),c.dispose())}),a.onWillDispose(()=>c.dispose()),a}const i=s?.getStateById(e.testExtId);if(!i)return null;let r,S=null;switch(e.type){case p.ResultActualOutput:{const t=i.tasks[e.taskIndex].messages[e.messageIndex];t?.type===g.Error&&(r=t.actual);break}case p.TestOutput:{r="";const t=s.tasks[e.taskIndex].output;for(const a of i.tasks[e.taskIndex].messages)a.type===g.Output&&(r+=d(t.getRange(a.offset,a.length).toString()));break}case p.ResultExpectedOutput:{const t=i.tasks[e.taskIndex].messages[e.messageIndex];t?.type===g.Error&&(r=t.expected);break}case p.ResultMessage:{const t=i.tasks[e.taskIndex].messages[e.messageIndex];if(!t)break;if(t.type===g.Output){const a=s.tasks[e.taskIndex].output.getRange(t.offset,t.length);r=d(a.toString())}else typeof t.message=="string"?r=d(t.message):(r=t.message.value,S=this.languageService.createById("markdown"))}}return r===void 0?null:this.modelService.createModel(r,S,o,!1)}};f=v([l(0,E),l(1,b),l(2,R),l(3,D)],f);export{f as TestingContentProvider};
