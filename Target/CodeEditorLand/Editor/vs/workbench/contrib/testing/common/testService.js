import{assert as p}from"../../../../../vs/base/common/assert.js";import{CancellationToken as C}from"../../../../../vs/base/common/cancellation.js";import"../../../../../vs/base/common/event.js";import{Iterable as g}from"../../../../../vs/base/common/iterator.js";import"../../../../../vs/base/common/lifecycle.js";import{MarshalledId as x}from"../../../../../vs/base/common/marshallingIds.js";import"../../../../../vs/base/common/observable.js";import{WellDefinedPrefixTree as R}from"../../../../../vs/base/common/prefixTree.js";import"../../../../../vs/base/common/uri.js";import"../../../../../vs/editor/common/core/position.js";import"../../../../../vs/editor/common/languages.js";import{createDecorator as v}from"../../../../../vs/platform/instantiation/common/instantiation.js";import"../../../../../vs/platform/uriIdentity/common/uriIdentity.js";import"../../../../../vs/workbench/contrib/testing/common/observableValue.js";import"../../../../../vs/workbench/contrib/testing/common/testExclusions.js";import{TestId as a}from"../../../../../vs/workbench/contrib/testing/common/testId.js";import"../../../../../vs/workbench/contrib/testing/common/testResult.js";import{TestItemExpandState as I}from"../../../../../vs/workbench/contrib/testing/common/testTypes.js";const de=v("testService"),Ie=t=>!g.some(t.rootItems,e=>e.children.size>0),Te=(t,e)=>{if(typeof e=="string"&&(e=a.fromString(e)),e.isRoot)return{controller:e.toString()};const i={$mid:x.TestItemContext,tests:[]};for(const r of e.idsFromRoot())if(!r.isRoot){const o=t.getNodeById(r.toString());o&&i.tests.push(o)}return i},ue=async(t,e,i=C.None)=>{const r=[...a.fromString(e).idsFromRoot()];let o=0;for(let s=r.length-1;!i.isCancellationRequested&&s>=o;){const n=r[s].toString(),l=t.getNodeById(n);if(!l){s--;continue}if(s===r.length-1)return l;l.children.has(r[s+1].toString())||await t.expand(n,0),o=s+1,s=r.length-1}},T=(t,e)=>{if(e.item.busy)return new Promise(i=>{const r=t.onDidProcessDiff(()=>{t.collection.getNodeById(e.item.extId)?.item.busy!==!0&&(i(),r.dispose())})})},me=async function*(t,e,i,r=!0){for(const o of t.collection.all)o.item.uri&&(e.extUri.isEqual(i,o.item.uri)&&(yield o),e.extUri.isEqualOrParent(i,o.item.uri)&&(o.expand===I.Expandable&&await t.collection.expand(o.item.extId,1),r&&await T(t,o)))},fe=async function*(t,e,i,r=!0){const o=[t.collection.rootIds];for(;o.length;)for(const s of o.pop()){const n=t.collection.getNodeById(s);n&&(n.item.uri&&e.extUri.isEqualOrParent(n.item.uri,i)?yield n:(!n.item.uri||e.extUri.isEqualOrParent(i,n.item.uri))&&(n.expand===I.Expandable&&await t.collection.expand(n.item.extId,1),r&&await T(t,n),o.push(n.children.values())))}},pe=(t,e)=>{if(e.length<2)return e;const i=new R;for(const s of e)i.insert(a.fromString(s.item.extId).path,s);const r=[],o=(s,n)=>{if(n.value)return n.value;p(!!n.children,"expect to have children");const l=[];for(const[m,f]of n.children){s.push(m);const d=o(s,f);d&&l.push(d),s.pop()}if(!l.length)return;const u=new a(s),c=t.getNodeById(u.toString());if(c?.children.size===l.length)return c;r.push(...l)};for(const[s,n]of i.entries){const l=o([s],n);l&&r.push(l)}return r};export{de as ITestService,ue as expandAndGetTestById,Te as getContextForTestItem,pe as simplifyTestsToExecute,Ie as testCollectionIsEmpty,me as testsInFile,fe as testsUnderUri};
