import{assert as f}from"../../../../base/common/assert.js";import{CancellationToken as y}from"../../../../base/common/cancellation.js";import{Iterable as C}from"../../../../base/common/iterator.js";import{MarshalledId as g}from"../../../../base/common/marshallingIds.js";import{WellDefinedPrefixTree as x}from"../../../../base/common/prefixTree.js";import{createDecorator as b}from"../../../../platform/instantiation/common/instantiation.js";import{TestId as a}from"./testId.js";import{TestItemExpandState as m}from"./testTypes.js";const M=b("testService"),E=t=>!C.some(t.rootItems,e=>e.children.size>0),F=(t,e)=>{if(typeof e=="string"&&(e=a.fromString(e)),e.isRoot)return{controller:e.toString()};const i={$mid:g.TestItemContext,tests:[]};for(const r of e.idsFromRoot())if(!r.isRoot){const o=t.getNodeById(r.toString());o&&i.tests.push(o)}return i},S=async(t,e,i=y.None)=>{const r=[...a.fromString(e).idsFromRoot()];let o=0;for(let s=r.length-1;!i.isCancellationRequested&&s>=o;){const n=r[s].toString(),l=t.getNodeById(n);if(!l){s--;continue}if(s===r.length-1)return l;l.children.has(r[s+1].toString())||await t.expand(n,0),o=s+1,s=r.length-1}},I=(t,e)=>{if(e.item.busy)return new Promise(i=>{const r=t.onDidProcessDiff(()=>{t.collection.getNodeById(e.item.extId)?.item.busy!==!0&&(i(),r.dispose())})})},U=async function*(t,e,i,r=!0){for(const o of t.collection.all)o.item.uri&&(e.extUri.isEqual(i,o.item.uri)&&(yield o),e.extUri.isEqualOrParent(i,o.item.uri)&&(o.expand===m.Expandable&&await t.collection.expand(o.item.extId,1),r&&await I(t,o)))},B=async function*(t,e,i,r=!0){const o=[t.collection.rootIds];for(;o.length;)for(const s of o.pop()){const n=t.collection.getNodeById(s);n&&(n.item.uri&&e.extUri.isEqualOrParent(n.item.uri,i)?yield n:(!n.item.uri||e.extUri.isEqualOrParent(i,n.item.uri))&&(n.expand===m.Expandable&&await t.collection.expand(n.item.extId,1),r&&await I(t,n),o.push(n.children.values())))}},j=(t,e)=>{if(e.length<2)return e;const i=new x;for(const s of e)i.insert(a.fromString(s.item.extId).path,s);const r=[],o=(s,n)=>{if(n.value)return n.value;f(!!n.children,"expect to have children");const l=[];for(const[T,p]of n.children){s.push(T);const d=o(s,p);d&&l.push(d),s.pop()}if(!l.length)return;const u=new a(s),c=t.getNodeById(u.toString());if(c?.children.size===l.length)return c;r.push(...l)};for(const[s,n]of i.entries){const l=o([s],n);l&&r.push(l)}return r};export{M as ITestService,S as expandAndGetTestById,F as getContextForTestItem,j as simplifyTestsToExecute,E as testCollectionIsEmpty,U as testsInFile,B as testsUnderUri};
