{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/testing/common/getComputedState.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Iterable } from '../../../../base/common/iterator.js';\nimport { TestResultState } from './testTypes.js';\nimport { makeEmptyCounts, maxPriority, statePriority } from './testingStates.js';\n\n/**\n * Accessor for nodes in get and refresh computed state.\n */\nexport interface IComputedStateAccessor<T> {\n\tgetOwnState(item: T): TestResultState | undefined;\n\tgetCurrentComputedState(item: T): TestResultState;\n\tsetComputedState(item: T, state: TestResultState): void;\n\tgetChildren(item: T): Iterable<T>;\n\tgetParents(item: T): Iterable<T>;\n}\n\nexport interface IComputedStateAndDurationAccessor<T> extends IComputedStateAccessor<T> {\n\tgetOwnDuration(item: T): number | undefined;\n\tgetCurrentComputedDuration(item: T): number | undefined;\n\tsetComputedDuration(item: T, duration: number | undefined): void;\n}\n\nconst isDurationAccessor = <T>(accessor: IComputedStateAccessor<T>): accessor is IComputedStateAndDurationAccessor<T> => 'getOwnDuration' in accessor;\n\n/**\n * Gets the computed state for the node.\n * @param force whether to refresh the computed state for this node, even\n * if it was previously set.\n */\n\nconst getComputedState = <T extends object>(accessor: IComputedStateAccessor<T>, node: T, force = false) => {\n\tlet computed = accessor.getCurrentComputedState(node);\n\tif (computed === undefined || force) {\n\t\tcomputed = accessor.getOwnState(node) ?? TestResultState.Unset;\n\n\t\tlet childrenCount = 0;\n\t\tconst stateMap = makeEmptyCounts();\n\n\t\tfor (const child of accessor.getChildren(node)) {\n\t\t\tconst childComputed = getComputedState(accessor, child);\n\t\t\tchildrenCount++;\n\t\t\tstateMap[childComputed]++;\n\n\t\t\t// If all children are skipped, make the current state skipped too if unset (#131537)\n\t\t\tcomputed = childComputed === TestResultState.Skipped && computed === TestResultState.Unset\n\t\t\t\t? TestResultState.Skipped : maxPriority(computed, childComputed);\n\t\t}\n\n\t\tif (childrenCount > LARGE_NODE_THRESHOLD) {\n\t\t\tlargeNodeChildrenStates.set(node, stateMap);\n\t\t}\n\n\t\taccessor.setComputedState(node, computed);\n\t}\n\n\treturn computed;\n};\n\nconst getComputedDuration = <T>(accessor: IComputedStateAndDurationAccessor<T>, node: T, force = false): number | undefined => {\n\tlet computed = accessor.getCurrentComputedDuration(node);\n\tif (computed === undefined || force) {\n\t\tconst own = accessor.getOwnDuration(node);\n\t\tif (own !== undefined) {\n\t\t\tcomputed = own;\n\t\t} else {\n\t\t\tcomputed = undefined;\n\t\t\tfor (const child of accessor.getChildren(node)) {\n\t\t\t\tconst d = getComputedDuration(accessor, child);\n\t\t\t\tif (d !== undefined) {\n\t\t\t\t\tcomputed = (computed || 0) + d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\taccessor.setComputedDuration(node, computed);\n\t}\n\n\treturn computed;\n};\n\nconst LARGE_NODE_THRESHOLD = 64;\n\n/**\n * Map of how many nodes have in each state. This is used to optimize state\n * computation in large nodes with children above the `LARGE_NODE_THRESHOLD`.\n */\nconst largeNodeChildrenStates = new WeakMap<object, { [K in TestResultState]: number }>();\n\n/**\n * Refreshes the computed state for the node and its parents. Any changes\n * elements cause `addUpdated` to be called.\n */\nexport const refreshComputedState = <T extends object>(\n\taccessor: IComputedStateAccessor<T>,\n\tnode: T,\n\texplicitNewComputedState?: TestResultState,\n\trefreshDuration = true,\n) => {\n\tconst oldState = accessor.getCurrentComputedState(node);\n\tconst oldPriority = statePriority[oldState];\n\tconst newState = explicitNewComputedState ?? getComputedState(accessor, node, true);\n\tconst newPriority = statePriority[newState];\n\tconst toUpdate = new Set<T>();\n\n\tif (newPriority !== oldPriority) {\n\t\taccessor.setComputedState(node, newState);\n\t\ttoUpdate.add(node);\n\n\t\tlet moveFromState = oldState;\n\t\tlet moveToState = newState;\n\n\t\tfor (const parent of accessor.getParents(node)) {\n\t\t\tconst lnm = largeNodeChildrenStates.get(parent);\n\t\t\tif (lnm) {\n\t\t\t\tlnm[moveFromState]--;\n\t\t\t\tlnm[moveToState]++;\n\t\t\t}\n\n\t\t\tconst prev = accessor.getCurrentComputedState(parent);\n\t\t\tif (newPriority > oldPriority) {\n\t\t\t\t// Update all parents to ensure they're at least this priority.\n\t\t\t\tif (prev !== undefined && statePriority[prev] >= newPriority) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (lnm && lnm[moveToState] > 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// moveToState remains the same, the new higher priority node state\n\t\t\t\taccessor.setComputedState(parent, newState);\n\t\t\t\ttoUpdate.add(parent);\n\t\t\t} else /* newProirity < oldPriority */ {\n\t\t\t\t// Update all parts whose statese might have been based on this one\n\t\t\t\tif (prev === undefined || statePriority[prev] > oldPriority) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (lnm && lnm[moveFromState] > 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tmoveToState = getComputedState(accessor, parent, true);\n\t\t\t\taccessor.setComputedState(parent, moveToState);\n\t\t\t\ttoUpdate.add(parent);\n\t\t\t}\n\n\t\t\tmoveFromState = prev;\n\t\t}\n\t}\n\n\tif (isDurationAccessor(accessor) && refreshDuration) {\n\t\tfor (const parent of Iterable.concat(Iterable.single(node), accessor.getParents(node))) {\n\t\t\tconst oldDuration = accessor.getCurrentComputedDuration(parent);\n\t\t\tconst newDuration = getComputedDuration(accessor, parent, true);\n\t\t\tif (oldDuration === newDuration) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\taccessor.setComputedDuration(parent, newDuration);\n\t\t\ttoUpdate.add(parent);\n\t\t}\n\t}\n\n\treturn toUpdate;\n};\n"],
  "mappings": "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",
  "names": []
}
