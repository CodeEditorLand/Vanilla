{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/testing/common/testItemCollection.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { assertNever } from \"../../../../base/common/assert.js\";\nimport {\n\tBarrier,\n\tRunOnceScheduler,\n\tisThenable,\n} from \"../../../../base/common/async.js\";\nimport { Emitter } from \"../../../../base/common/event.js\";\nimport { Disposable } from \"../../../../base/common/lifecycle.js\";\nimport type { URI } from \"../../../../base/common/uri.js\";\nimport { TestId } from \"./testId.js\";\nimport {\n\ttype ITestItem,\n\ttype ITestTag,\n\tTestDiffOpType,\n\tTestItemExpandState,\n\ttype TestsDiff,\n\ttype TestsDiffOp,\n\tapplyTestItemUpdate,\n\tnamespaceTestTag,\n} from \"./testTypes.js\";\n\n/**\n * @private\n */\ninterface CollectionItem<T> {\n\treadonly fullId: TestId;\n\tactual: T;\n\texpand: TestItemExpandState;\n\t/**\n\t * Number of levels of items below this one that are expanded. May be infinite.\n\t */\n\texpandLevels?: number;\n\tresolveBarrier?: Barrier;\n}\n\nexport enum TestItemEventOp {\n\tUpsert = 0,\n\tSetTags = 1,\n\tUpdateCanResolveChildren = 2,\n\tRemoveChild = 3,\n\tSetProp = 4,\n\tBulk = 5,\n\tDocumentSynced = 6,\n}\n\nexport interface ITestItemUpsertChild {\n\top: TestItemEventOp.Upsert;\n\titem: ITestItemLike;\n}\n\nexport interface ITestItemUpdateCanResolveChildren {\n\top: TestItemEventOp.UpdateCanResolveChildren;\n\tstate: boolean;\n}\n\nexport interface ITestItemSetTags {\n\top: TestItemEventOp.SetTags;\n\tnew: ITestTag[];\n\told: ITestTag[];\n}\n\nexport interface ITestItemRemoveChild {\n\top: TestItemEventOp.RemoveChild;\n\tid: string;\n}\n\nexport interface ITestItemSetProp {\n\top: TestItemEventOp.SetProp;\n\tupdate: Partial<ITestItem>;\n}\nexport interface ITestItemBulkReplace {\n\top: TestItemEventOp.Bulk;\n\tops: (ITestItemUpsertChild | ITestItemRemoveChild)[];\n}\n\nexport interface ITestItemDocumentSynced {\n\top: TestItemEventOp.DocumentSynced;\n}\n\nexport type ExtHostTestItemEvent =\n\t| ITestItemSetTags\n\t| ITestItemUpsertChild\n\t| ITestItemRemoveChild\n\t| ITestItemUpdateCanResolveChildren\n\t| ITestItemSetProp\n\t| ITestItemBulkReplace\n\t| ITestItemDocumentSynced;\n\nexport interface ITestItemApi<T> {\n\tcontrollerId: string;\n\tparent?: T;\n\tlistener?: (evt: ExtHostTestItemEvent) => void;\n}\n\nexport interface ITestItemCollectionOptions<T> {\n\t/** Controller ID to use to prefix these test items. */\n\tcontrollerId: string;\n\n\t/** Gets the document version at the given URI, if it's open */\n\tgetDocumentVersion(uri: URI | undefined): number | undefined;\n\n\t/** Gets API for the given test item, used to listen for events and set parents. */\n\tgetApiFor(item: T): ITestItemApi<T>;\n\n\t/** Converts the full test item to the common interface. */\n\ttoITestItem(item: T): ITestItem;\n\n\t/** Gets children for the item. */\n\tgetChildren(item: T): ITestChildrenLike<T>;\n\n\t/** Root to use for the new test collection. */\n\troot: T;\n}\n\nconst strictEqualComparator = <T>(a: T, b: T) => a === b;\nconst diffableProps: {\n\t[K in keyof ITestItem]?: (a: ITestItem[K], b: ITestItem[K]) => boolean;\n} = {\n\trange: (a, b) => {\n\t\tif (a === b) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!a || !b) {\n\t\t\treturn false;\n\t\t}\n\t\treturn a.equalsRange(b);\n\t},\n\tbusy: strictEqualComparator,\n\tlabel: strictEqualComparator,\n\tdescription: strictEqualComparator,\n\terror: strictEqualComparator,\n\tsortText: strictEqualComparator,\n\ttags: (a, b) => {\n\t\tif (a.length !== b.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (a.some((t1) => !b.includes(t1))) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t},\n};\n\nconst diffableEntries = Object.entries(diffableProps) as readonly [\n\tkeyof ITestItem,\n\t(a: any, b: any) => boolean,\n][];\n\nconst diffTestItems = (a: ITestItem, b: ITestItem) => {\n\tlet output: Record<string, unknown> | undefined;\n\tfor (const [key, cmp] of diffableEntries) {\n\t\tif (!cmp(a[key], b[key])) {\n\t\t\tif (output) {\n\t\t\t\toutput[key] = b[key];\n\t\t\t} else {\n\t\t\t\toutput = { [key]: b[key] };\n\t\t\t}\n\t\t}\n\t}\n\n\treturn output as Partial<ITestItem> | undefined;\n};\n\nexport interface ITestChildrenLike<T> extends Iterable<[string, T]> {\n\tget(id: string): T | undefined;\n\tdelete(id: string): void;\n}\n\nexport interface ITestItemLike {\n\tid: string;\n\ttags: readonly ITestTag[];\n\turi?: URI;\n\tcanResolveChildren: boolean;\n}\n\n/**\n * Maintains a collection of test items for a single controller.\n */\nexport class TestItemCollection<T extends ITestItemLike> extends Disposable {\n\tprivate readonly debounceSendDiff = this._register(\n\t\tnew RunOnceScheduler(() => this.flushDiff(), 200),\n\t);\n\tprivate readonly diffOpEmitter = this._register(new Emitter<TestsDiff>());\n\tprivate _resolveHandler?: (item: T | undefined) => Promise<void> | void;\n\n\tpublic get root() {\n\t\treturn this.options.root;\n\t}\n\n\tpublic readonly tree = new Map<\n\t\t/* full test id */ string,\n\t\tCollectionItem<T>\n\t>();\n\tprivate readonly tags = new Map<\n\t\tstring,\n\t\t{ label?: string; refCount: number }\n\t>();\n\n\tprotected diff: TestsDiff = [];\n\n\tconstructor(private readonly options: ITestItemCollectionOptions<T>) {\n\t\tsuper();\n\t\tthis.root.canResolveChildren = true;\n\t\tthis.upsertItem(this.root, undefined);\n\t}\n\n\t/**\n\t * Handler used for expanding test items.\n\t */\n\tpublic set resolveHandler(handler:\n\t\t| undefined\n\t\t| ((item: T | undefined) => void)) {\n\t\tthis._resolveHandler = handler;\n\t\tfor (const test of this.tree.values()) {\n\t\t\tthis.updateExpandability(test);\n\t\t}\n\t}\n\n\tpublic get resolveHandler() {\n\t\treturn this._resolveHandler;\n\t}\n\n\t/**\n\t * Fires when an operation happens that should result in a diff.\n\t */\n\tpublic readonly onDidGenerateDiff = this.diffOpEmitter.event;\n\n\t/**\n\t * Gets a diff of all changes that have been made, and clears the diff queue.\n\t */\n\tpublic collectDiff() {\n\t\tconst diff = this.diff;\n\t\tthis.diff = [];\n\t\treturn diff;\n\t}\n\n\t/**\n\t * Pushes a new diff entry onto the collected diff list.\n\t */\n\tpublic pushDiff(diff: TestsDiffOp) {\n\t\tswitch (diff.op) {\n\t\t\tcase TestDiffOpType.DocumentSynced: {\n\t\t\t\tfor (const existing of this.diff) {\n\t\t\t\t\tif (\n\t\t\t\t\t\texisting.op === TestDiffOpType.DocumentSynced &&\n\t\t\t\t\t\texisting.uri === diff.uri\n\t\t\t\t\t) {\n\t\t\t\t\t\texisting.docv = diff.docv;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase TestDiffOpType.Update: {\n\t\t\t\t// Try to merge updates, since they're invoked per-property\n\t\t\t\tconst last = this.diff[this.diff.length - 1];\n\t\t\t\tif (last) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tlast.op === TestDiffOpType.Update &&\n\t\t\t\t\t\tlast.item.extId === diff.item.extId\n\t\t\t\t\t) {\n\t\t\t\t\t\tapplyTestItemUpdate(last.item, diff.item);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tlast.op === TestDiffOpType.Add &&\n\t\t\t\t\t\tlast.item.item.extId === diff.item.extId\n\t\t\t\t\t) {\n\t\t\t\t\t\tapplyTestItemUpdate(last.item, diff.item);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tthis.diff.push(diff);\n\n\t\tif (!this.debounceSendDiff.isScheduled()) {\n\t\t\tthis.debounceSendDiff.schedule();\n\t\t}\n\t}\n\n\t/**\n\t * Expands the test and the given number of `levels` of children. If levels\n\t * is < 0, then all children will be expanded. If it's 0, then only this\n\t * item will be expanded.\n\t */\n\tpublic expand(testId: string, levels: number): Promise<void> | void {\n\t\tconst internal = this.tree.get(testId);\n\t\tif (!internal) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (\n\t\t\tinternal.expandLevels === undefined ||\n\t\t\tlevels > internal.expandLevels\n\t\t) {\n\t\t\tinternal.expandLevels = levels;\n\t\t}\n\n\t\t// try to avoid awaiting things if the provider returns synchronously in\n\t\t// order to keep everything in a single diff and DOM update.\n\t\tif (internal.expand === TestItemExpandState.Expandable) {\n\t\t\tconst r = this.resolveChildren(internal);\n\t\t\treturn r.isOpen()\n\t\t\t\t? this.expandChildren(internal, levels - 1)\n\t\t\t\t: r\n\t\t\t\t\t\t.wait()\n\t\t\t\t\t\t.then(() => this.expandChildren(internal, levels - 1));\n\t\t} else if (internal.expand === TestItemExpandState.Expanded) {\n\t\t\treturn internal.resolveBarrier?.isOpen() === false\n\t\t\t\t? internal.resolveBarrier\n\t\t\t\t\t\t.wait()\n\t\t\t\t\t\t.then(() => this.expandChildren(internal, levels - 1))\n\t\t\t\t: this.expandChildren(internal, levels - 1);\n\t\t}\n\t}\n\n\tpublic override dispose() {\n\t\tfor (const item of this.tree.values()) {\n\t\t\tthis.options.getApiFor(item.actual).listener = undefined;\n\t\t}\n\n\t\tthis.tree.clear();\n\t\tthis.diff = [];\n\t\tsuper.dispose();\n\t}\n\n\tprivate onTestItemEvent(\n\t\tinternal: CollectionItem<T>,\n\t\tevt: ExtHostTestItemEvent,\n\t) {\n\t\tswitch (evt.op) {\n\t\t\tcase TestItemEventOp.RemoveChild:\n\t\t\t\tthis.removeItem(TestId.joinToString(internal.fullId, evt.id));\n\t\t\t\tbreak;\n\n\t\t\tcase TestItemEventOp.Upsert:\n\t\t\t\tthis.upsertItem(evt.item as T, internal);\n\t\t\t\tbreak;\n\n\t\t\tcase TestItemEventOp.Bulk:\n\t\t\t\tfor (const op of evt.ops) {\n\t\t\t\t\tthis.onTestItemEvent(internal, op);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase TestItemEventOp.SetTags:\n\t\t\t\tthis.diffTagRefs(evt.new, evt.old, internal.fullId.toString());\n\t\t\t\tbreak;\n\n\t\t\tcase TestItemEventOp.UpdateCanResolveChildren:\n\t\t\t\tthis.updateExpandability(internal);\n\t\t\t\tbreak;\n\n\t\t\tcase TestItemEventOp.SetProp:\n\t\t\t\tthis.pushDiff({\n\t\t\t\t\top: TestDiffOpType.Update,\n\t\t\t\t\titem: {\n\t\t\t\t\t\textId: internal.fullId.toString(),\n\t\t\t\t\t\titem: evt.update,\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\tcase TestItemEventOp.DocumentSynced:\n\t\t\t\tthis.documentSynced(internal.actual.uri);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tassertNever(evt);\n\t\t}\n\t}\n\n\tprivate documentSynced(uri: URI | undefined) {\n\t\tif (uri) {\n\t\t\tthis.pushDiff({\n\t\t\t\top: TestDiffOpType.DocumentSynced,\n\t\t\t\turi,\n\t\t\t\tdocv: this.options.getDocumentVersion(uri),\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate upsertItem(actual: T, parent: CollectionItem<T> | undefined): void {\n\t\tconst fullId = TestId.fromExtHostTestItem(\n\t\t\tactual,\n\t\t\tthis.root.id,\n\t\t\tparent?.actual,\n\t\t);\n\n\t\t// If this test item exists elsewhere in the tree already (exists at an\n\t\t// old ID with an existing parent), remove that old item.\n\t\tconst privateApi = this.options.getApiFor(actual);\n\t\tif (privateApi.parent && privateApi.parent !== parent?.actual) {\n\t\t\tthis.options.getChildren(privateApi.parent).delete(actual.id);\n\t\t}\n\n\t\tlet internal = this.tree.get(fullId.toString());\n\t\t// Case 1: a brand new item\n\t\tif (!internal) {\n\t\t\tinternal = {\n\t\t\t\tfullId,\n\t\t\t\tactual,\n\t\t\t\texpandLevels:\n\t\t\t\t\tparent?.expandLevels /* intentionally undefined or 0 */\n\t\t\t\t\t\t? parent.expandLevels - 1\n\t\t\t\t\t\t: undefined,\n\t\t\t\texpand: TestItemExpandState.NotExpandable, // updated by `connectItemAndChildren`\n\t\t\t};\n\n\t\t\tactual.tags.forEach(this.incrementTagRefs, this);\n\t\t\tthis.tree.set(internal.fullId.toString(), internal);\n\t\t\tthis.setItemParent(actual, parent);\n\t\t\tthis.pushDiff({\n\t\t\t\top: TestDiffOpType.Add,\n\t\t\t\titem: {\n\t\t\t\t\tcontrollerId: this.options.controllerId,\n\t\t\t\t\texpand: internal.expand,\n\t\t\t\t\titem: this.options.toITestItem(actual),\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tthis.connectItemAndChildren(actual, internal, parent);\n\t\t\treturn;\n\t\t}\n\n\t\t// Case 2: re-insertion of an existing item, no-op\n\t\tif (internal.actual === actual) {\n\t\t\tthis.connectItem(actual, internal, parent); // re-connect in case the parent changed\n\t\t\treturn; // no-op\n\t\t}\n\n\t\t// Case 3: upsert of an existing item by ID, with a new instance\n\t\tif (internal.actual.uri?.toString() !== actual.uri?.toString()) {\n\t\t\t// If the item has a new URI, re-insert it; we don't support updating\n\t\t\t// URIs on existing test items.\n\t\t\tthis.removeItem(fullId.toString());\n\t\t\treturn this.upsertItem(actual, parent);\n\t\t}\n\t\tconst oldChildren = this.options.getChildren(internal.actual);\n\t\tconst oldActual = internal.actual;\n\t\tconst update = diffTestItems(\n\t\t\tthis.options.toITestItem(oldActual),\n\t\t\tthis.options.toITestItem(actual),\n\t\t);\n\t\tthis.options.getApiFor(oldActual).listener = undefined;\n\n\t\tinternal.actual = actual;\n\t\tinternal.resolveBarrier = undefined;\n\t\tinternal.expand = TestItemExpandState.NotExpandable; // updated by `connectItemAndChildren`\n\n\t\tif (update) {\n\t\t\t// tags are handled in a special way\n\t\t\tif (update.hasOwnProperty(\"tags\")) {\n\t\t\t\tthis.diffTagRefs(\n\t\t\t\t\tactual.tags,\n\t\t\t\t\toldActual.tags,\n\t\t\t\t\tfullId.toString(),\n\t\t\t\t);\n\t\t\t\tdelete update.tags;\n\t\t\t}\n\t\t\tthis.onTestItemEvent(internal, {\n\t\t\t\top: TestItemEventOp.SetProp,\n\t\t\t\tupdate,\n\t\t\t});\n\t\t}\n\n\t\tthis.connectItemAndChildren(actual, internal, parent);\n\n\t\t// Remove any orphaned children.\n\t\tfor (const [_, child] of oldChildren) {\n\t\t\tif (!this.options.getChildren(actual).get(child.id)) {\n\t\t\t\tthis.removeItem(TestId.joinToString(fullId, child.id));\n\t\t\t}\n\t\t}\n\n\t\t// Re-expand the element if it was previous expanded (#207574)\n\t\tconst expandLevels = internal.expandLevels;\n\t\tif (expandLevels !== undefined) {\n\t\t\t// Wait until a microtask to allow the extension to finish setting up\n\t\t\t// properties of the element and children before we ask it to expand.\n\t\t\tqueueMicrotask(() => {\n\t\t\t\tif (internal.expand === TestItemExpandState.Expandable) {\n\t\t\t\t\tinternal.expandLevels = undefined;\n\t\t\t\t\tthis.expand(fullId.toString(), expandLevels);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Mark ranges in the document as synced (#161320)\n\t\tthis.documentSynced(internal.actual.uri);\n\t}\n\n\tprivate diffTagRefs(\n\t\tnewTags: readonly ITestTag[],\n\t\toldTags: readonly ITestTag[],\n\t\textId: string,\n\t) {\n\t\tconst toDelete = new Set(oldTags.map((t) => t.id));\n\t\tfor (const tag of newTags) {\n\t\t\tif (!toDelete.delete(tag.id)) {\n\t\t\t\tthis.incrementTagRefs(tag);\n\t\t\t}\n\t\t}\n\n\t\tthis.pushDiff({\n\t\t\top: TestDiffOpType.Update,\n\t\t\titem: {\n\t\t\t\textId,\n\t\t\t\titem: {\n\t\t\t\t\ttags: newTags.map((v) =>\n\t\t\t\t\t\tnamespaceTestTag(this.options.controllerId, v.id),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\n\t\ttoDelete.forEach(this.decrementTagRefs, this);\n\t}\n\n\tprivate incrementTagRefs(tag: ITestTag) {\n\t\tconst existing = this.tags.get(tag.id);\n\t\tif (existing) {\n\t\t\texisting.refCount++;\n\t\t} else {\n\t\t\tthis.tags.set(tag.id, { refCount: 1 });\n\t\t\tthis.pushDiff({\n\t\t\t\top: TestDiffOpType.AddTag,\n\t\t\t\ttag: {\n\t\t\t\t\tid: namespaceTestTag(this.options.controllerId, tag.id),\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate decrementTagRefs(tagId: string) {\n\t\tconst existing = this.tags.get(tagId);\n\t\tif (existing && !--existing.refCount) {\n\t\t\tthis.tags.delete(tagId);\n\t\t\tthis.pushDiff({\n\t\t\t\top: TestDiffOpType.RemoveTag,\n\t\t\t\tid: namespaceTestTag(this.options.controllerId, tagId),\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate setItemParent(actual: T, parent: CollectionItem<T> | undefined) {\n\t\tthis.options.getApiFor(actual).parent =\n\t\t\tparent && parent.actual !== this.root ? parent.actual : undefined;\n\t}\n\n\tprivate connectItem(\n\t\tactual: T,\n\t\tinternal: CollectionItem<T>,\n\t\tparent: CollectionItem<T> | undefined,\n\t) {\n\t\tthis.setItemParent(actual, parent);\n\t\tconst api = this.options.getApiFor(actual);\n\t\tapi.parent = parent?.actual;\n\t\tapi.listener = (evt) => this.onTestItemEvent(internal, evt);\n\t\tthis.updateExpandability(internal);\n\t}\n\n\tprivate connectItemAndChildren(\n\t\tactual: T,\n\t\tinternal: CollectionItem<T>,\n\t\tparent: CollectionItem<T> | undefined,\n\t) {\n\t\tthis.connectItem(actual, internal, parent);\n\n\t\t// Discover any existing children that might have already been added\n\t\tfor (const [_, child] of this.options.getChildren(actual)) {\n\t\t\tthis.upsertItem(child, internal);\n\t\t}\n\t}\n\n\t/**\n\t * Updates the `expand` state of the item. Should be called whenever the\n\t * resolved state of the item changes. Can automatically expand the item\n\t * if requested by a consumer.\n\t */\n\tprivate updateExpandability(internal: CollectionItem<T>) {\n\t\tlet newState: TestItemExpandState;\n\t\tif (!this._resolveHandler) {\n\t\t\tnewState = TestItemExpandState.NotExpandable;\n\t\t} else if (internal.resolveBarrier) {\n\t\t\tnewState = internal.resolveBarrier.isOpen()\n\t\t\t\t? TestItemExpandState.Expanded\n\t\t\t\t: TestItemExpandState.BusyExpanding;\n\t\t} else {\n\t\t\tnewState = internal.actual.canResolveChildren\n\t\t\t\t? TestItemExpandState.Expandable\n\t\t\t\t: TestItemExpandState.NotExpandable;\n\t\t}\n\n\t\tif (newState === internal.expand) {\n\t\t\treturn;\n\t\t}\n\n\t\tinternal.expand = newState;\n\t\tthis.pushDiff({\n\t\t\top: TestDiffOpType.Update,\n\t\t\titem: { extId: internal.fullId.toString(), expand: newState },\n\t\t});\n\n\t\tif (\n\t\t\tnewState === TestItemExpandState.Expandable &&\n\t\t\tinternal.expandLevels !== undefined\n\t\t) {\n\t\t\tthis.resolveChildren(internal);\n\t\t}\n\t}\n\n\t/**\n\t * Expands all children of the item, \"levels\" deep. If levels is 0, only\n\t * the children will be expanded. If it's 1, the children and their children\n\t * will be expanded. If it's <0, it's a no-op.\n\t */\n\tprivate expandChildren(\n\t\tinternal: CollectionItem<T>,\n\t\tlevels: number,\n\t): Promise<void> | void {\n\t\tif (levels < 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst expandRequests: Promise<void>[] = [];\n\t\tfor (const [_, child] of this.options.getChildren(internal.actual)) {\n\t\t\tconst promise = this.expand(\n\t\t\t\tTestId.joinToString(internal.fullId, child.id),\n\t\t\t\tlevels,\n\t\t\t);\n\t\t\tif (isThenable(promise)) {\n\t\t\t\texpandRequests.push(promise);\n\t\t\t}\n\t\t}\n\n\t\tif (expandRequests.length) {\n\t\t\treturn Promise.all(expandRequests).then(() => {});\n\t\t}\n\t}\n\n\t/**\n\t * Calls `discoverChildren` on the item, refreshing all its tests.\n\t */\n\tprivate resolveChildren(internal: CollectionItem<T>) {\n\t\tif (internal.resolveBarrier) {\n\t\t\treturn internal.resolveBarrier;\n\t\t}\n\n\t\tif (!this._resolveHandler) {\n\t\t\tconst b = new Barrier();\n\t\t\tb.open();\n\t\t\treturn b;\n\t\t}\n\n\t\tinternal.expand = TestItemExpandState.BusyExpanding;\n\t\tthis.pushExpandStateUpdate(internal);\n\n\t\tconst barrier = (internal.resolveBarrier = new Barrier());\n\t\tconst applyError = (err: Error) => {\n\t\t\tconsole.error(\n\t\t\t\t`Unhandled error in resolveHandler of test controller \"${this.options.controllerId}\"`,\n\t\t\t\terr,\n\t\t\t);\n\t\t};\n\n\t\tlet r: Thenable<void> | undefined | void;\n\t\ttry {\n\t\t\tr = this._resolveHandler(\n\t\t\t\tinternal.actual === this.root ? undefined : internal.actual,\n\t\t\t);\n\t\t} catch (err) {\n\t\t\tapplyError(err);\n\t\t}\n\n\t\tif (isThenable(r)) {\n\t\t\tr.catch(applyError).then(() => {\n\t\t\t\tbarrier.open();\n\t\t\t\tthis.updateExpandability(internal);\n\t\t\t});\n\t\t} else {\n\t\t\tbarrier.open();\n\t\t\tthis.updateExpandability(internal);\n\t\t}\n\n\t\treturn internal.resolveBarrier;\n\t}\n\n\tprivate pushExpandStateUpdate(internal: CollectionItem<T>) {\n\t\tthis.pushDiff({\n\t\t\top: TestDiffOpType.Update,\n\t\t\titem: {\n\t\t\t\textId: internal.fullId.toString(),\n\t\t\t\texpand: internal.expand,\n\t\t\t},\n\t\t});\n\t}\n\n\tprivate removeItem(childId: string) {\n\t\tconst childItem = this.tree.get(childId);\n\t\tif (!childItem) {\n\t\t\tthrow new Error(\"attempting to remove non-existent child\");\n\t\t}\n\n\t\tthis.pushDiff({ op: TestDiffOpType.Remove, itemId: childId });\n\n\t\tconst queue: (CollectionItem<T> | undefined)[] = [childItem];\n\t\twhile (queue.length) {\n\t\t\tconst item = queue.pop();\n\t\t\tif (!item) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis.options.getApiFor(item.actual).listener = undefined;\n\n\t\t\tfor (const tag of item.actual.tags) {\n\t\t\t\tthis.decrementTagRefs(tag.id);\n\t\t\t}\n\n\t\t\tthis.tree.delete(item.fullId.toString());\n\t\t\tfor (const [_, child] of this.options.getChildren(item.actual)) {\n\t\t\t\tqueue.push(\n\t\t\t\t\tthis.tree.get(TestId.joinToString(item.fullId, child.id)),\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Immediately emits any pending diffs on the collection.\n\t */\n\tpublic flushDiff() {\n\t\tconst diff = this.collectDiff();\n\t\tif (diff.length) {\n\t\t\tthis.diffOpEmitter.fire(diff);\n\t\t}\n\t}\n}\n\n/** Implementation of vscode.TestItemCollection */\nexport interface ITestItemChildren<T extends ITestItemLike>\n\textends Iterable<[string, T]> {\n\treadonly size: number;\n\treplace(items: readonly T[]): void;\n\tforEach(\n\t\tcallback: (item: T, collection: this) => unknown,\n\t\tthisArg?: unknown,\n\t): void;\n\tadd(item: T): void;\n\tdelete(itemId: string): void;\n\tget(itemId: string): T | undefined;\n\n\ttoJSON(): readonly T[];\n}\n\nexport class DuplicateTestItemError extends Error {\n\tconstructor(id: string) {\n\t\tsuper(`Attempted to insert a duplicate test item ID ${id}`);\n\t}\n}\n\nexport class InvalidTestItemError extends Error {\n\tconstructor(id: string) {\n\t\tsuper(\n\t\t\t`TestItem with ID \"${id}\" is invalid. Make sure to create it from the createTestItem method.`,\n\t\t);\n\t}\n}\n\nexport class MixedTestItemController extends Error {\n\tconstructor(id: string, ctrlA: string, ctrlB: string) {\n\t\tsuper(\n\t\t\t`TestItem with ID \"${id}\" is from controller \"${ctrlA}\" and cannot be added as a child of an item from controller \"${ctrlB}\".`,\n\t\t);\n\t}\n}\n\nexport const createTestItemChildren = <T extends ITestItemLike>(\n\tapi: ITestItemApi<T>,\n\tgetApi: (item: T) => ITestItemApi<T>,\n\tcheckCtor: Function,\n): ITestItemChildren<T> => {\n\tlet mapped = new Map<string, T>();\n\n\treturn {\n\t\t/** @inheritdoc */\n\t\tget size() {\n\t\t\treturn mapped.size;\n\t\t},\n\n\t\t/** @inheritdoc */\n\t\tforEach(\n\t\t\tcallback: (item: T, collection: ITestItemChildren<T>) => unknown,\n\t\t\tthisArg?: unknown,\n\t\t) {\n\t\t\tfor (const item of mapped.values()) {\n\t\t\t\tcallback.call(thisArg, item, this);\n\t\t\t}\n\t\t},\n\n\t\t/** @inheritdoc */\n\t\t[Symbol.iterator](): IterableIterator<[string, T]> {\n\t\t\treturn mapped.entries();\n\t\t},\n\n\t\t/** @inheritdoc */\n\t\treplace(items: Iterable<T>) {\n\t\t\tconst newMapped = new Map<string, T>();\n\t\t\tconst toDelete = new Set(mapped.keys());\n\t\t\tconst bulk: ITestItemBulkReplace = {\n\t\t\t\top: TestItemEventOp.Bulk,\n\t\t\t\tops: [],\n\t\t\t};\n\n\t\t\tfor (const item of items) {\n\t\t\t\tif (!(item instanceof checkCtor)) {\n\t\t\t\t\tthrow new InvalidTestItemError((item as ITestItemLike).id);\n\t\t\t\t}\n\n\t\t\t\tconst itemController = getApi(item).controllerId;\n\t\t\t\tif (itemController !== api.controllerId) {\n\t\t\t\t\tthrow new MixedTestItemController(\n\t\t\t\t\t\titem.id,\n\t\t\t\t\t\titemController,\n\t\t\t\t\t\tapi.controllerId,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (newMapped.has(item.id)) {\n\t\t\t\t\tthrow new DuplicateTestItemError(item.id);\n\t\t\t\t}\n\n\t\t\t\tnewMapped.set(item.id, item);\n\t\t\t\ttoDelete.delete(item.id);\n\t\t\t\tbulk.ops.push({ op: TestItemEventOp.Upsert, item });\n\t\t\t}\n\n\t\t\tfor (const id of toDelete.keys()) {\n\t\t\t\tbulk.ops.push({ op: TestItemEventOp.RemoveChild, id });\n\t\t\t}\n\n\t\t\tapi.listener?.(bulk);\n\n\t\t\t// important mutations come after firing, so if an error happens no\n\t\t\t// changes will be \"saved\":\n\t\t\tmapped = newMapped;\n\t\t},\n\n\t\t/** @inheritdoc */\n\t\tadd(item: T) {\n\t\t\tif (!(item instanceof checkCtor)) {\n\t\t\t\tthrow new InvalidTestItemError((item as ITestItemLike).id);\n\t\t\t}\n\n\t\t\tmapped.set(item.id, item);\n\t\t\tapi.listener?.({ op: TestItemEventOp.Upsert, item });\n\t\t},\n\n\t\t/** @inheritdoc */\n\t\tdelete(id: string) {\n\t\t\tif (mapped.delete(id)) {\n\t\t\t\tapi.listener?.({ op: TestItemEventOp.RemoveChild, id });\n\t\t\t}\n\t\t},\n\n\t\t/** @inheritdoc */\n\t\tget(itemId: string) {\n\t\t\treturn mapped.get(itemId);\n\t\t},\n\n\t\t/** JSON serialization function. */\n\t\ttoJSON() {\n\t\t\treturn Array.from(mapped.values());\n\t\t},\n\t};\n};\n"],
  "mappings": "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",
  "names": ["TestItemEventOp"]
}
