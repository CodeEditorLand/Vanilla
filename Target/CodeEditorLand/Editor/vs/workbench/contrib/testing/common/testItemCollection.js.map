{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/testing/common/testItemCollection.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Barrier, isThenable, RunOnceScheduler } from '../../../../base/common/async.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { assertNever } from '../../../../base/common/assert.js';\nimport { applyTestItemUpdate, ITestItem, ITestTag, namespaceTestTag, TestDiffOpType, TestItemExpandState, TestsDiff, TestsDiffOp } from './testTypes.js';\nimport { TestId } from './testId.js';\nimport { URI } from '../../../../base/common/uri.js';\n\n/**\n * @private\n */\ninterface CollectionItem<T> {\n\treadonly fullId: TestId;\n\tactual: T;\n\texpand: TestItemExpandState;\n\t/**\n\t * Number of levels of items below this one that are expanded. May be infinite.\n\t */\n\texpandLevels?: number;\n\tresolveBarrier?: Barrier;\n}\n\nexport const enum TestItemEventOp {\n\tUpsert,\n\tSetTags,\n\tUpdateCanResolveChildren,\n\tRemoveChild,\n\tSetProp,\n\tBulk,\n\tDocumentSynced,\n}\n\nexport interface ITestItemUpsertChild {\n\top: TestItemEventOp.Upsert;\n\titem: ITestItemLike;\n}\n\nexport interface ITestItemUpdateCanResolveChildren {\n\top: TestItemEventOp.UpdateCanResolveChildren;\n\tstate: boolean;\n}\n\nexport interface ITestItemSetTags {\n\top: TestItemEventOp.SetTags;\n\tnew: ITestTag[];\n\told: ITestTag[];\n}\n\nexport interface ITestItemRemoveChild {\n\top: TestItemEventOp.RemoveChild;\n\tid: string;\n}\n\nexport interface ITestItemSetProp {\n\top: TestItemEventOp.SetProp;\n\tupdate: Partial<ITestItem>;\n}\nexport interface ITestItemBulkReplace {\n\top: TestItemEventOp.Bulk;\n\tops: (ITestItemUpsertChild | ITestItemRemoveChild)[];\n}\n\nexport interface ITestItemDocumentSynced {\n\top: TestItemEventOp.DocumentSynced;\n}\n\nexport type ExtHostTestItemEvent =\n\t| ITestItemSetTags\n\t| ITestItemUpsertChild\n\t| ITestItemRemoveChild\n\t| ITestItemUpdateCanResolveChildren\n\t| ITestItemSetProp\n\t| ITestItemBulkReplace\n\t| ITestItemDocumentSynced;\n\nexport interface ITestItemApi<T> {\n\tcontrollerId: string;\n\tparent?: T;\n\tlistener?: (evt: ExtHostTestItemEvent) => void;\n}\n\nexport interface ITestItemCollectionOptions<T> {\n\t/** Controller ID to use to prefix these test items. */\n\tcontrollerId: string;\n\n\t/** Gets the document version at the given URI, if it's open */\n\tgetDocumentVersion(uri: URI | undefined): number | undefined;\n\n\t/** Gets API for the given test item, used to listen for events and set parents. */\n\tgetApiFor(item: T): ITestItemApi<T>;\n\n\t/** Converts the full test item to the common interface. */\n\ttoITestItem(item: T): ITestItem;\n\n\t/** Gets children for the item. */\n\tgetChildren(item: T): ITestChildrenLike<T>;\n\n\t/** Root to use for the new test collection. */\n\troot: T;\n}\n\nconst strictEqualComparator = <T>(a: T, b: T) => a === b;\nconst diffableProps: { [K in keyof ITestItem]?: (a: ITestItem[K], b: ITestItem[K]) => boolean } = {\n\trange: (a, b) => {\n\t\tif (a === b) { return true; }\n\t\tif (!a || !b) { return false; }\n\t\treturn a.equalsRange(b);\n\t},\n\tbusy: strictEqualComparator,\n\tlabel: strictEqualComparator,\n\tdescription: strictEqualComparator,\n\terror: strictEqualComparator,\n\tsortText: strictEqualComparator,\n\ttags: (a, b) => {\n\t\tif (a.length !== b.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (a.some(t1 => !b.includes(t1))) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t},\n};\n\nconst diffableEntries = Object.entries(diffableProps) as readonly [keyof ITestItem, (a: any, b: any) => boolean][];\n\nconst diffTestItems = (a: ITestItem, b: ITestItem) => {\n\tlet output: Record<string, unknown> | undefined;\n\tfor (const [key, cmp] of diffableEntries) {\n\t\tif (!cmp(a[key], b[key])) {\n\t\t\tif (output) {\n\t\t\t\toutput[key] = b[key];\n\t\t\t} else {\n\t\t\t\toutput = { [key]: b[key] };\n\t\t\t}\n\t\t}\n\t}\n\n\treturn output as Partial<ITestItem> | undefined;\n};\n\nexport interface ITestChildrenLike<T> extends Iterable<[string, T]> {\n\tget(id: string): T | undefined;\n\tdelete(id: string): void;\n}\n\nexport interface ITestItemLike {\n\tid: string;\n\ttags: readonly ITestTag[];\n\turi?: URI;\n\tcanResolveChildren: boolean;\n}\n\n/**\n * Maintains a collection of test items for a single controller.\n */\nexport class TestItemCollection<T extends ITestItemLike> extends Disposable {\n\tprivate readonly debounceSendDiff = this._register(new RunOnceScheduler(() => this.flushDiff(), 200));\n\tprivate readonly diffOpEmitter = this._register(new Emitter<TestsDiff>());\n\tprivate _resolveHandler?: (item: T | undefined) => Promise<void> | void;\n\n\tpublic get root() {\n\t\treturn this.options.root;\n\t}\n\n\tpublic readonly tree = new Map</* full test id */string, CollectionItem<T>>();\n\tprivate readonly tags = new Map<string, { label?: string; refCount: number }>();\n\n\tprotected diff: TestsDiff = [];\n\n\tconstructor(private readonly options: ITestItemCollectionOptions<T>) {\n\t\tsuper();\n\t\tthis.root.canResolveChildren = true;\n\t\tthis.upsertItem(this.root, undefined);\n\t}\n\n\t/**\n\t * Handler used for expanding test items.\n\t */\n\tpublic set resolveHandler(handler: undefined | ((item: T | undefined) => void)) {\n\t\tthis._resolveHandler = handler;\n\t\tfor (const test of this.tree.values()) {\n\t\t\tthis.updateExpandability(test);\n\t\t}\n\t}\n\n\tpublic get resolveHandler() {\n\t\treturn this._resolveHandler;\n\t}\n\n\t/**\n\t * Fires when an operation happens that should result in a diff.\n\t */\n\tpublic readonly onDidGenerateDiff = this.diffOpEmitter.event;\n\n\t/**\n\t * Gets a diff of all changes that have been made, and clears the diff queue.\n\t */\n\tpublic collectDiff() {\n\t\tconst diff = this.diff;\n\t\tthis.diff = [];\n\t\treturn diff;\n\t}\n\n\t/**\n\t * Pushes a new diff entry onto the collected diff list.\n\t */\n\tpublic pushDiff(diff: TestsDiffOp) {\n\t\tswitch (diff.op) {\n\t\t\tcase TestDiffOpType.DocumentSynced: {\n\t\t\t\tfor (const existing of this.diff) {\n\t\t\t\t\tif (existing.op === TestDiffOpType.DocumentSynced && existing.uri === diff.uri) {\n\t\t\t\t\t\texisting.docv = diff.docv;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase TestDiffOpType.Update: {\n\t\t\t\t// Try to merge updates, since they're invoked per-property\n\t\t\t\tconst last = this.diff[this.diff.length - 1];\n\t\t\t\tif (last) {\n\t\t\t\t\tif (last.op === TestDiffOpType.Update && last.item.extId === diff.item.extId) {\n\t\t\t\t\t\tapplyTestItemUpdate(last.item, diff.item);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (last.op === TestDiffOpType.Add && last.item.item.extId === diff.item.extId) {\n\t\t\t\t\t\tapplyTestItemUpdate(last.item, diff.item);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tthis.diff.push(diff);\n\n\t\tif (!this.debounceSendDiff.isScheduled()) {\n\t\t\tthis.debounceSendDiff.schedule();\n\t\t}\n\t}\n\n\t/**\n\t * Expands the test and the given number of `levels` of children. If levels\n\t * is < 0, then all children will be expanded. If it's 0, then only this\n\t * item will be expanded.\n\t */\n\tpublic expand(testId: string, levels: number): Promise<void> | void {\n\t\tconst internal = this.tree.get(testId);\n\t\tif (!internal) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (internal.expandLevels === undefined || levels > internal.expandLevels) {\n\t\t\tinternal.expandLevels = levels;\n\t\t}\n\n\t\t// try to avoid awaiting things if the provider returns synchronously in\n\t\t// order to keep everything in a single diff and DOM update.\n\t\tif (internal.expand === TestItemExpandState.Expandable) {\n\t\t\tconst r = this.resolveChildren(internal);\n\t\t\treturn !r.isOpen()\n\t\t\t\t? r.wait().then(() => this.expandChildren(internal, levels - 1))\n\t\t\t\t: this.expandChildren(internal, levels - 1);\n\t\t} else if (internal.expand === TestItemExpandState.Expanded) {\n\t\t\treturn internal.resolveBarrier?.isOpen() === false\n\t\t\t\t? internal.resolveBarrier.wait().then(() => this.expandChildren(internal, levels - 1))\n\t\t\t\t: this.expandChildren(internal, levels - 1);\n\t\t}\n\t}\n\n\tpublic override dispose() {\n\t\tfor (const item of this.tree.values()) {\n\t\t\tthis.options.getApiFor(item.actual).listener = undefined;\n\t\t}\n\n\t\tthis.tree.clear();\n\t\tthis.diff = [];\n\t\tsuper.dispose();\n\t}\n\n\tprivate onTestItemEvent(internal: CollectionItem<T>, evt: ExtHostTestItemEvent) {\n\t\tswitch (evt.op) {\n\t\t\tcase TestItemEventOp.RemoveChild:\n\t\t\t\tthis.removeItem(TestId.joinToString(internal.fullId, evt.id));\n\t\t\t\tbreak;\n\n\t\t\tcase TestItemEventOp.Upsert:\n\t\t\t\tthis.upsertItem(evt.item as T, internal);\n\t\t\t\tbreak;\n\n\t\t\tcase TestItemEventOp.Bulk:\n\t\t\t\tfor (const op of evt.ops) {\n\t\t\t\t\tthis.onTestItemEvent(internal, op);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase TestItemEventOp.SetTags:\n\t\t\t\tthis.diffTagRefs(evt.new, evt.old, internal.fullId.toString());\n\t\t\t\tbreak;\n\n\t\t\tcase TestItemEventOp.UpdateCanResolveChildren:\n\t\t\t\tthis.updateExpandability(internal);\n\t\t\t\tbreak;\n\n\t\t\tcase TestItemEventOp.SetProp:\n\t\t\t\tthis.pushDiff({\n\t\t\t\t\top: TestDiffOpType.Update,\n\t\t\t\t\titem: {\n\t\t\t\t\t\textId: internal.fullId.toString(),\n\t\t\t\t\t\titem: evt.update,\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\tcase TestItemEventOp.DocumentSynced:\n\t\t\t\tthis.documentSynced(internal.actual.uri);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tassertNever(evt);\n\t\t}\n\t}\n\n\tprivate documentSynced(uri: URI | undefined) {\n\t\tif (uri) {\n\t\t\tthis.pushDiff({\n\t\t\t\top: TestDiffOpType.DocumentSynced,\n\t\t\t\turi,\n\t\t\t\tdocv: this.options.getDocumentVersion(uri)\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate upsertItem(actual: T, parent: CollectionItem<T> | undefined): void {\n\t\tconst fullId = TestId.fromExtHostTestItem(actual, this.root.id, parent?.actual);\n\n\t\t// If this test item exists elsewhere in the tree already (exists at an\n\t\t// old ID with an existing parent), remove that old item.\n\t\tconst privateApi = this.options.getApiFor(actual);\n\t\tif (privateApi.parent && privateApi.parent !== parent?.actual) {\n\t\t\tthis.options.getChildren(privateApi.parent).delete(actual.id);\n\t\t}\n\n\t\tlet internal = this.tree.get(fullId.toString());\n\t\t// Case 1: a brand new item\n\t\tif (!internal) {\n\t\t\tinternal = {\n\t\t\t\tfullId,\n\t\t\t\tactual,\n\t\t\t\texpandLevels: parent?.expandLevels /* intentionally undefined or 0 */ ? parent.expandLevels - 1 : undefined,\n\t\t\t\texpand: TestItemExpandState.NotExpandable, // updated by `connectItemAndChildren`\n\t\t\t};\n\n\t\t\tactual.tags.forEach(this.incrementTagRefs, this);\n\t\t\tthis.tree.set(internal.fullId.toString(), internal);\n\t\t\tthis.setItemParent(actual, parent);\n\t\t\tthis.pushDiff({\n\t\t\t\top: TestDiffOpType.Add,\n\t\t\t\titem: {\n\t\t\t\t\tcontrollerId: this.options.controllerId,\n\t\t\t\t\texpand: internal.expand,\n\t\t\t\t\titem: this.options.toITestItem(actual),\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tthis.connectItemAndChildren(actual, internal, parent);\n\t\t\treturn;\n\t\t}\n\n\t\t// Case 2: re-insertion of an existing item, no-op\n\t\tif (internal.actual === actual) {\n\t\t\tthis.connectItem(actual, internal, parent); // re-connect in case the parent changed\n\t\t\treturn; // no-op\n\t\t}\n\n\t\t// Case 3: upsert of an existing item by ID, with a new instance\n\t\tif (internal.actual.uri?.toString() !== actual.uri?.toString()) {\n\t\t\t// If the item has a new URI, re-insert it; we don't support updating\n\t\t\t// URIs on existing test items.\n\t\t\tthis.removeItem(fullId.toString());\n\t\t\treturn this.upsertItem(actual, parent);\n\t\t}\n\t\tconst oldChildren = this.options.getChildren(internal.actual);\n\t\tconst oldActual = internal.actual;\n\t\tconst update = diffTestItems(this.options.toITestItem(oldActual), this.options.toITestItem(actual));\n\t\tthis.options.getApiFor(oldActual).listener = undefined;\n\n\t\tinternal.actual = actual;\n\t\tinternal.resolveBarrier = undefined;\n\t\tinternal.expand = TestItemExpandState.NotExpandable; // updated by `connectItemAndChildren`\n\n\t\tif (update) {\n\t\t\t// tags are handled in a special way\n\t\t\tif (update.hasOwnProperty('tags')) {\n\t\t\t\tthis.diffTagRefs(actual.tags, oldActual.tags, fullId.toString());\n\t\t\t\tdelete update.tags;\n\t\t\t}\n\t\t\tthis.onTestItemEvent(internal, { op: TestItemEventOp.SetProp, update });\n\t\t}\n\n\t\tthis.connectItemAndChildren(actual, internal, parent);\n\n\t\t// Remove any orphaned children.\n\t\tfor (const [_, child] of oldChildren) {\n\t\t\tif (!this.options.getChildren(actual).get(child.id)) {\n\t\t\t\tthis.removeItem(TestId.joinToString(fullId, child.id));\n\t\t\t}\n\t\t}\n\n\t\t// Re-expand the element if it was previous expanded (#207574)\n\t\tconst expandLevels = internal.expandLevels;\n\t\tif (expandLevels !== undefined) {\n\t\t\t// Wait until a microtask to allow the extension to finish setting up\n\t\t\t// properties of the element and children before we ask it to expand.\n\t\t\tqueueMicrotask(() => {\n\t\t\t\tif (internal.expand === TestItemExpandState.Expandable) {\n\t\t\t\t\tinternal.expandLevels = undefined;\n\t\t\t\t\tthis.expand(fullId.toString(), expandLevels);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Mark ranges in the document as synced (#161320)\n\t\tthis.documentSynced(internal.actual.uri);\n\t}\n\n\tprivate diffTagRefs(newTags: readonly ITestTag[], oldTags: readonly ITestTag[], extId: string) {\n\t\tconst toDelete = new Set(oldTags.map(t => t.id));\n\t\tfor (const tag of newTags) {\n\t\t\tif (!toDelete.delete(tag.id)) {\n\t\t\t\tthis.incrementTagRefs(tag);\n\t\t\t}\n\t\t}\n\n\t\tthis.pushDiff({\n\t\t\top: TestDiffOpType.Update,\n\t\t\titem: { extId, item: { tags: newTags.map(v => namespaceTestTag(this.options.controllerId, v.id)) } }\n\t\t});\n\n\t\ttoDelete.forEach(this.decrementTagRefs, this);\n\t}\n\n\tprivate incrementTagRefs(tag: ITestTag) {\n\t\tconst existing = this.tags.get(tag.id);\n\t\tif (existing) {\n\t\t\texisting.refCount++;\n\t\t} else {\n\t\t\tthis.tags.set(tag.id, { refCount: 1 });\n\t\t\tthis.pushDiff({\n\t\t\t\top: TestDiffOpType.AddTag, tag: {\n\t\t\t\t\tid: namespaceTestTag(this.options.controllerId, tag.id),\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate decrementTagRefs(tagId: string) {\n\t\tconst existing = this.tags.get(tagId);\n\t\tif (existing && !--existing.refCount) {\n\t\t\tthis.tags.delete(tagId);\n\t\t\tthis.pushDiff({ op: TestDiffOpType.RemoveTag, id: namespaceTestTag(this.options.controllerId, tagId) });\n\t\t}\n\t}\n\n\tprivate setItemParent(actual: T, parent: CollectionItem<T> | undefined) {\n\t\tthis.options.getApiFor(actual).parent = parent && parent.actual !== this.root ? parent.actual : undefined;\n\t}\n\n\tprivate connectItem(actual: T, internal: CollectionItem<T>, parent: CollectionItem<T> | undefined) {\n\t\tthis.setItemParent(actual, parent);\n\t\tconst api = this.options.getApiFor(actual);\n\t\tapi.parent = parent?.actual;\n\t\tapi.listener = evt => this.onTestItemEvent(internal, evt);\n\t\tthis.updateExpandability(internal);\n\t}\n\n\tprivate connectItemAndChildren(actual: T, internal: CollectionItem<T>, parent: CollectionItem<T> | undefined) {\n\t\tthis.connectItem(actual, internal, parent);\n\n\t\t// Discover any existing children that might have already been added\n\t\tfor (const [_, child] of this.options.getChildren(actual)) {\n\t\t\tthis.upsertItem(child, internal);\n\t\t}\n\t}\n\n\t/**\n\t * Updates the `expand` state of the item. Should be called whenever the\n\t * resolved state of the item changes. Can automatically expand the item\n\t * if requested by a consumer.\n\t */\n\tprivate updateExpandability(internal: CollectionItem<T>) {\n\t\tlet newState: TestItemExpandState;\n\t\tif (!this._resolveHandler) {\n\t\t\tnewState = TestItemExpandState.NotExpandable;\n\t\t} else if (internal.resolveBarrier) {\n\t\t\tnewState = internal.resolveBarrier.isOpen()\n\t\t\t\t? TestItemExpandState.Expanded\n\t\t\t\t: TestItemExpandState.BusyExpanding;\n\t\t} else {\n\t\t\tnewState = internal.actual.canResolveChildren\n\t\t\t\t? TestItemExpandState.Expandable\n\t\t\t\t: TestItemExpandState.NotExpandable;\n\t\t}\n\n\t\tif (newState === internal.expand) {\n\t\t\treturn;\n\t\t}\n\n\t\tinternal.expand = newState;\n\t\tthis.pushDiff({ op: TestDiffOpType.Update, item: { extId: internal.fullId.toString(), expand: newState } });\n\n\t\tif (newState === TestItemExpandState.Expandable && internal.expandLevels !== undefined) {\n\t\t\tthis.resolveChildren(internal);\n\t\t}\n\t}\n\n\t/**\n\t * Expands all children of the item, \"levels\" deep. If levels is 0, only\n\t * the children will be expanded. If it's 1, the children and their children\n\t * will be expanded. If it's <0, it's a no-op.\n\t */\n\tprivate expandChildren(internal: CollectionItem<T>, levels: number): Promise<void> | void {\n\t\tif (levels < 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst expandRequests: Promise<void>[] = [];\n\t\tfor (const [_, child] of this.options.getChildren(internal.actual)) {\n\t\t\tconst promise = this.expand(TestId.joinToString(internal.fullId, child.id), levels);\n\t\t\tif (isThenable(promise)) {\n\t\t\t\texpandRequests.push(promise);\n\t\t\t}\n\t\t}\n\n\t\tif (expandRequests.length) {\n\t\t\treturn Promise.all(expandRequests).then(() => { });\n\t\t}\n\t}\n\n\t/**\n\t * Calls `discoverChildren` on the item, refreshing all its tests.\n\t */\n\tprivate resolveChildren(internal: CollectionItem<T>) {\n\t\tif (internal.resolveBarrier) {\n\t\t\treturn internal.resolveBarrier;\n\t\t}\n\n\t\tif (!this._resolveHandler) {\n\t\t\tconst b = new Barrier();\n\t\t\tb.open();\n\t\t\treturn b;\n\t\t}\n\n\t\tinternal.expand = TestItemExpandState.BusyExpanding;\n\t\tthis.pushExpandStateUpdate(internal);\n\n\t\tconst barrier = internal.resolveBarrier = new Barrier();\n\t\tconst applyError = (err: Error) => {\n\t\t\tconsole.error(`Unhandled error in resolveHandler of test controller \"${this.options.controllerId}\"`, err);\n\t\t};\n\n\t\tlet r: Thenable<void> | undefined | void;\n\t\ttry {\n\t\t\tr = this._resolveHandler(internal.actual === this.root ? undefined : internal.actual);\n\t\t} catch (err) {\n\t\t\tapplyError(err);\n\t\t}\n\n\t\tif (isThenable(r)) {\n\t\t\tr.catch(applyError).then(() => {\n\t\t\t\tbarrier.open();\n\t\t\t\tthis.updateExpandability(internal);\n\t\t\t});\n\t\t} else {\n\t\t\tbarrier.open();\n\t\t\tthis.updateExpandability(internal);\n\t\t}\n\n\t\treturn internal.resolveBarrier;\n\t}\n\n\tprivate pushExpandStateUpdate(internal: CollectionItem<T>) {\n\t\tthis.pushDiff({ op: TestDiffOpType.Update, item: { extId: internal.fullId.toString(), expand: internal.expand } });\n\t}\n\n\tprivate removeItem(childId: string) {\n\t\tconst childItem = this.tree.get(childId);\n\t\tif (!childItem) {\n\t\t\tthrow new Error('attempting to remove non-existent child');\n\t\t}\n\n\t\tthis.pushDiff({ op: TestDiffOpType.Remove, itemId: childId });\n\n\t\tconst queue: (CollectionItem<T> | undefined)[] = [childItem];\n\t\twhile (queue.length) {\n\t\t\tconst item = queue.pop();\n\t\t\tif (!item) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis.options.getApiFor(item.actual).listener = undefined;\n\n\t\t\tfor (const tag of item.actual.tags) {\n\t\t\t\tthis.decrementTagRefs(tag.id);\n\t\t\t}\n\n\t\t\tthis.tree.delete(item.fullId.toString());\n\t\t\tfor (const [_, child] of this.options.getChildren(item.actual)) {\n\t\t\t\tqueue.push(this.tree.get(TestId.joinToString(item.fullId, child.id)));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Immediately emits any pending diffs on the collection.\n\t */\n\tpublic flushDiff() {\n\t\tconst diff = this.collectDiff();\n\t\tif (diff.length) {\n\t\t\tthis.diffOpEmitter.fire(diff);\n\t\t}\n\t}\n}\n\n/** Implementation of vscode.TestItemCollection */\nexport interface ITestItemChildren<T extends ITestItemLike> extends Iterable<[string, T]> {\n\treadonly size: number;\n\treplace(items: readonly T[]): void;\n\tforEach(callback: (item: T, collection: this) => unknown, thisArg?: unknown): void;\n\tadd(item: T): void;\n\tdelete(itemId: string): void;\n\tget(itemId: string): T | undefined;\n\n\ttoJSON(): readonly T[];\n}\n\nexport class DuplicateTestItemError extends Error {\n\tconstructor(id: string) {\n\t\tsuper(`Attempted to insert a duplicate test item ID ${id}`);\n\t}\n}\n\nexport class InvalidTestItemError extends Error {\n\tconstructor(id: string) {\n\t\tsuper(`TestItem with ID \"${id}\" is invalid. Make sure to create it from the createTestItem method.`);\n\t}\n}\n\nexport class MixedTestItemController extends Error {\n\tconstructor(id: string, ctrlA: string, ctrlB: string) {\n\t\tsuper(`TestItem with ID \"${id}\" is from controller \"${ctrlA}\" and cannot be added as a child of an item from controller \"${ctrlB}\".`);\n\t}\n}\n\nexport const createTestItemChildren = <T extends ITestItemLike>(api: ITestItemApi<T>, getApi: (item: T) => ITestItemApi<T>, checkCtor: Function): ITestItemChildren<T> => {\n\tlet mapped = new Map<string, T>();\n\n\treturn {\n\t\t/** @inheritdoc */\n\t\tget size() {\n\t\t\treturn mapped.size;\n\t\t},\n\n\t\t/** @inheritdoc */\n\t\tforEach(callback: (item: T, collection: ITestItemChildren<T>) => unknown, thisArg?: unknown) {\n\t\t\tfor (const item of mapped.values()) {\n\t\t\t\tcallback.call(thisArg, item, this);\n\t\t\t}\n\t\t},\n\n\t\t/** @inheritdoc */\n\t\t[Symbol.iterator](): IterableIterator<[string, T]> {\n\t\t\treturn mapped.entries();\n\t\t},\n\n\t\t/** @inheritdoc */\n\t\treplace(items: Iterable<T>) {\n\t\t\tconst newMapped = new Map<string, T>();\n\t\t\tconst toDelete = new Set(mapped.keys());\n\t\t\tconst bulk: ITestItemBulkReplace = { op: TestItemEventOp.Bulk, ops: [] };\n\n\t\t\tfor (const item of items) {\n\t\t\t\tif (!(item instanceof checkCtor)) {\n\t\t\t\t\tthrow new InvalidTestItemError((item as ITestItemLike).id);\n\t\t\t\t}\n\n\t\t\t\tconst itemController = getApi(item).controllerId;\n\t\t\t\tif (itemController !== api.controllerId) {\n\t\t\t\t\tthrow new MixedTestItemController(item.id, itemController, api.controllerId);\n\t\t\t\t}\n\n\t\t\t\tif (newMapped.has(item.id)) {\n\t\t\t\t\tthrow new DuplicateTestItemError(item.id);\n\t\t\t\t}\n\n\t\t\t\tnewMapped.set(item.id, item);\n\t\t\t\ttoDelete.delete(item.id);\n\t\t\t\tbulk.ops.push({ op: TestItemEventOp.Upsert, item });\n\t\t\t}\n\n\t\t\tfor (const id of toDelete.keys()) {\n\t\t\t\tbulk.ops.push({ op: TestItemEventOp.RemoveChild, id });\n\t\t\t}\n\n\t\t\tapi.listener?.(bulk);\n\n\t\t\t// important mutations come after firing, so if an error happens no\n\t\t\t// changes will be \"saved\":\n\t\t\tmapped = newMapped;\n\t\t},\n\n\n\t\t/** @inheritdoc */\n\t\tadd(item: T) {\n\t\t\tif (!(item instanceof checkCtor)) {\n\t\t\t\tthrow new InvalidTestItemError((item as ITestItemLike).id);\n\t\t\t}\n\n\t\t\tmapped.set(item.id, item);\n\t\t\tapi.listener?.({ op: TestItemEventOp.Upsert, item });\n\t\t},\n\n\t\t/** @inheritdoc */\n\t\tdelete(id: string) {\n\t\t\tif (mapped.delete(id)) {\n\t\t\t\tapi.listener?.({ op: TestItemEventOp.RemoveChild, id });\n\t\t\t}\n\t\t},\n\n\t\t/** @inheritdoc */\n\t\tget(itemId: string) {\n\t\t\treturn mapped.get(itemId);\n\t\t},\n\n\t\t/** JSON serialization function. */\n\t\ttoJSON() {\n\t\t\treturn Array.from(mapped.values());\n\t\t},\n\t};\n};\n"],
  "mappings": "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",
  "names": ["TestItemEventOp"]
}
