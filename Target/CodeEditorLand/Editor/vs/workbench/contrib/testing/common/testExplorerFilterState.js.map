{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/testing/common/testExplorerFilterState.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { splitGlobAware } from '../../../../base/common/glob.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IStorageService, StorageScope, StorageTarget } from '../../../../platform/storage/common/storage.js';\nimport { IObservableValue, MutableObservableValue } from './observableValue.js';\nimport { StoredValue } from './storedValue.js';\nimport { namespaceTestTag } from './testTypes.js';\n\nexport interface ITestExplorerFilterState {\n\t_serviceBrand: undefined;\n\n\t/** Current filter text */\n\treadonly text: IObservableValue<string>;\n\n\t/** Test ID the user wants to reveal in the explorer */\n\treadonly reveal: MutableObservableValue<string | undefined>;\n\n\t/** Event that fires when {@link focusInput} is invoked. */\n\treadonly onDidRequestInputFocus: Event<void>;\n\n\t/**\n\t * Glob list to filter for based on the {@link text}\n\t */\n\treadonly globList: readonly { include: boolean; text: string }[];\n\n\t/**\n\t * The user requested to filter including tags.\n\t */\n\treadonly includeTags: ReadonlySet<string>;\n\n\t/**\n\t * The user requested to filter excluding tags.\n\t */\n\treadonly excludeTags: ReadonlySet<string>;\n\n\t/**\n\t * Whether fuzzy searching is enabled.\n\t */\n\treadonly fuzzy: MutableObservableValue<boolean>;\n\n\t/**\n\t * Focuses the filter input in the test explorer view.\n\t */\n\tfocusInput(): void;\n\n\t/**\n\t * Replaces the filter {@link text}.\n\t */\n\tsetText(text: string): void;\n\n\t/**\n\t * Sets whether the {@link text} is filtering for a special term.\n\t */\n\tisFilteringFor(term: TestFilterTerm): boolean;\n\n\t/**\n\t * Sets whether the {@link text} includes a special filter term.\n\t */\n\ttoggleFilteringFor(term: TestFilterTerm, shouldFilter?: boolean): void;\n}\n\nexport const ITestExplorerFilterState = createDecorator<ITestExplorerFilterState>('testingFilterState');\n\nconst tagRe = /!?@([^ ,:]+)/g;\nconst trimExtraWhitespace = (str: string) => str.replace(/\\s\\s+/g, ' ').trim();\n\nexport class TestExplorerFilterState extends Disposable implements ITestExplorerFilterState {\n\tdeclare _serviceBrand: undefined;\n\tprivate readonly focusEmitter = new Emitter<void>();\n\t/**\n\t * Mapping of terms to whether they're included in the text.\n\t */\n\tprivate termFilterState: { [K in TestFilterTerm]?: true } = {};\n\n\t/** @inheritdoc */\n\tpublic globList: { include: boolean; text: string }[] = [];\n\n\t/** @inheritdoc */\n\tpublic includeTags = new Set<string>();\n\n\t/** @inheritdoc */\n\tpublic excludeTags = new Set<string>();\n\n\t/** @inheritdoc */\n\tpublic readonly text = this._register(new MutableObservableValue(''));\n\n\t/** @inheritdoc */\n\tpublic readonly fuzzy = this._register(MutableObservableValue.stored(new StoredValue<boolean>({\n\t\tkey: 'testHistoryFuzzy',\n\t\tscope: StorageScope.PROFILE,\n\t\ttarget: StorageTarget.USER,\n\t}, this.storageService), false));\n\n\tpublic readonly reveal = this._register(new MutableObservableValue</* test ID */string | undefined>(undefined));\n\n\tpublic readonly onDidRequestInputFocus = this.focusEmitter.event;\n\n\tconstructor(@IStorageService private readonly storageService: IStorageService) {\n\t\tsuper();\n\t}\n\n\t/** @inheritdoc */\n\tpublic focusInput() {\n\t\tthis.focusEmitter.fire();\n\t}\n\n\t/** @inheritdoc */\n\tpublic setText(text: string) {\n\t\tif (text === this.text.value) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.termFilterState = {};\n\t\tthis.globList = [];\n\t\tthis.includeTags.clear();\n\t\tthis.excludeTags.clear();\n\n\t\tlet globText = '';\n\t\tlet lastIndex = 0;\n\t\tfor (const match of text.matchAll(tagRe)) {\n\t\t\tlet nextIndex = match.index + match[0].length;\n\n\t\t\tconst tag = match[0];\n\t\t\tif (allTestFilterTerms.includes(tag as TestFilterTerm)) {\n\t\t\t\tthis.termFilterState[tag as TestFilterTerm] = true;\n\t\t\t}\n\n\t\t\t// recognize and parse @ctrlId:tagId or quoted like @ctrlId:\"tag \\\\\"id\"\n\t\t\tif (text[nextIndex] === ':') {\n\t\t\t\tnextIndex++;\n\n\t\t\t\tlet delimiter = text[nextIndex];\n\t\t\t\tif (delimiter !== `\"` && delimiter !== `'`) {\n\t\t\t\t\tdelimiter = ' ';\n\t\t\t\t} else {\n\t\t\t\t\tnextIndex++;\n\t\t\t\t}\n\n\t\t\t\tlet tagId = '';\n\t\t\t\twhile (nextIndex < text.length && text[nextIndex] !== delimiter) {\n\t\t\t\t\tif (text[nextIndex] === '\\\\') {\n\t\t\t\t\t\ttagId += text[nextIndex + 1];\n\t\t\t\t\t\tnextIndex += 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttagId += text[nextIndex];\n\t\t\t\t\t\tnextIndex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (match[0].startsWith('!')) {\n\t\t\t\t\tthis.excludeTags.add(namespaceTestTag(match[1], tagId));\n\t\t\t\t} else {\n\t\t\t\t\tthis.includeTags.add(namespaceTestTag(match[1], tagId));\n\t\t\t\t}\n\t\t\t\tnextIndex++;\n\t\t\t}\n\n\t\t\tglobText += text.slice(lastIndex, match.index);\n\t\t\tlastIndex = nextIndex;\n\t\t}\n\n\t\tglobText += text.slice(lastIndex).trim();\n\n\t\tif (globText.length) {\n\t\t\tfor (const filter of splitGlobAware(globText, ',').map(s => s.trim()).filter(s => !!s.length)) {\n\t\t\t\tif (filter.startsWith('!')) {\n\t\t\t\t\tthis.globList.push({ include: false, text: filter.slice(1).toLowerCase() });\n\t\t\t\t} else {\n\t\t\t\t\tthis.globList.push({ include: true, text: filter.toLowerCase() });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.text.value = text; // purposely afterwards so everything is updated when the change event happen\n\t}\n\n\t/** @inheritdoc */\n\tpublic isFilteringFor(term: TestFilterTerm) {\n\t\treturn !!this.termFilterState[term];\n\t}\n\n\t/** @inheritdoc */\n\tpublic toggleFilteringFor(term: TestFilterTerm, shouldFilter?: boolean) {\n\t\tconst text = this.text.value.trim();\n\t\tif (shouldFilter !== false && !this.termFilterState[term]) {\n\t\t\tthis.setText(text ? `${text} ${term}` : term);\n\t\t} else if (shouldFilter !== true && this.termFilterState[term]) {\n\t\t\tthis.setText(trimExtraWhitespace(text.replace(term, '')));\n\t\t}\n\t}\n}\n\nexport const enum TestFilterTerm {\n\tFailed = '@failed',\n\tExecuted = '@executed',\n\tCurrentDoc = '@doc',\n\tOpenedFiles = '@openedFiles',\n\tHidden = '@hidden',\n}\n\nconst allTestFilterTerms: readonly TestFilterTerm[] = [\n\tTestFilterTerm.Failed,\n\tTestFilterTerm.Executed,\n\tTestFilterTerm.CurrentDoc,\n\tTestFilterTerm.OpenedFiles,\n\tTestFilterTerm.Hidden,\n];\n"],
  "mappings": "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",
  "names": ["TestFilterTerm"]
}
