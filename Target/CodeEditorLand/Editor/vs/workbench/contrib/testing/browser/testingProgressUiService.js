var g=Object.defineProperty;var S=Object.getOwnPropertyDescriptor;var d=(n,i,e,s)=>{for(var t=s>1?void 0:s?S(i,e):i,o=n.length-1,r;o>=0;o--)(r=n[o])&&(t=(s?r(i,e,t):r(t))||t);return s&&t&&g(i,e,t),t},l=(n,i)=>(e,s)=>i(e,s,n);import{Disposable as R,DisposableStore as h}from"../../../../../vs/base/common/lifecycle.js";import{autorun as C}from"../../../../../vs/base/common/observable.js";import{localize as c}from"../../../../../vs/nls.js";import{IConfigurationService as w}from"../../../../../vs/platform/configuration/common/configuration.js";import{ExplorerTestCoverageBars as T}from"../../../../../vs/workbench/contrib/testing/browser/testCoverageBars.js";import{AutoOpenTesting as m,getTestingConfiguration as I,TestingConfigKeys as x}from"../../../../../vs/workbench/contrib/testing/common/configuration.js";import{Testing as v}from"../../../../../vs/workbench/contrib/testing/common/constants.js";import{ITestCoverageService as V}from"../../../../../vs/workbench/contrib/testing/common/testCoverageService.js";import{isFailedState as y}from"../../../../../vs/workbench/contrib/testing/common/testingStates.js";import{TestResultItemChangeReason as O}from"../../../../../vs/workbench/contrib/testing/common/testResult.js";import{ITestResultService as P}from"../../../../../vs/workbench/contrib/testing/common/testResultService.js";import{TestResultState as u}from"../../../../../vs/workbench/contrib/testing/common/testTypes.js";import{IViewsService as b}from"../../../../../vs/workbench/services/views/common/viewsService.js";let f=class extends R{constructor(e,s,t,o){super();this.configurationService=t;this.viewsService=o;this._register(e.onResultsChanged(p=>{"started"in p&&this.attachAutoOpenForNewResults(p.started)}));const r=C(p=>{s.selected.read(p)&&(r.dispose(),T.register())});this._register(r)}attachAutoOpenForNewResults(e){if(e.request.preserveFocus===!0)return;const s=I(this.configurationService,x.OpenTesting);if(s===m.NeverOpen)return;if(s===m.OpenExplorerOnTestStart)return this.openExplorerView();if(s===m.OpenOnTestStart)return this.openResultsView();const t=new h;t.add(e.onComplete(()=>t.dispose())),t.add(e.onChange(o=>{o.reason===O.OwnStateChange&&y(o.item.ownComputedState)&&(this.openResultsView(),t.dispose())}))}openExplorerView(){this.viewsService.openView(v.ExplorerViewId,!1)}openResultsView(){this.viewsService.openView(v.ResultsViewId,!1)}};f=d([l(0,P),l(1,V),l(2,w),l(3,b)],f);const G=(n,i)=>{let e=0,s=0,t=0,o=0,r=0;for(const p of i){const a=p.counts;s+=a[u.Errored]+a[u.Failed],e+=a[u.Passed],t+=a[u.Skipped],o+=a[u.Running],r+=a[u.Queued]}return{isRunning:n,passed:e,failed:s,runSoFar:e+s,totalWillBeRun:e+s+r+o,skipped:t}},H=({isRunning:n,passed:i,runSoFar:e,totalWillBeRun:s,skipped:t,failed:o})=>{let r=i/e*100;return o>0?r=Math.min(r,99.9):e===0&&(r=0),n?e===0?c("testProgress.runningInitial","Running tests..."):t===0?c("testProgress.running","Running tests, {0}/{1} passed ({2}%)",i,s,r.toPrecision(3)):c("testProgressWithSkip.running","Running tests, {0}/{1} tests passed ({2}%, {3} skipped)",i,s,r.toPrecision(3),t):t===0?c("testProgress.completed","{0}/{1} tests passed ({2}%)",i,e,r.toPrecision(3)):c("testProgressWithSkip.completed","{0}/{1} tests passed ({2}%, {3} skipped)",i,e,r.toPrecision(3),t)};export{f as TestingProgressTrigger,G as collectTestStateCounts,H as getTestProgressText};
