import"../../../../../base/browser/ui/list/list.js";import"../../../../../base/browser/ui/tree/objectTree.js";import{ObjectTreeElementCollapseState as l}from"../../../../../base/browser/ui/tree/tree.js";import{Emitter as m}from"../../../../../base/common/event.js";import"../../../../../base/common/filters.js";import"../../../../../base/common/htmlContent.js";import{Iterable as c}from"../../../../../base/common/iterator.js";import"../../../../../base/common/lifecycle.js";import{MarshalledId as T}from"../../../../../base/common/marshallingIds.js";import{InternalTestItem as o,TestItemExpandState as i,TestResultState as I}from"../../common/testTypes.js";import{isCollapsedInSerializedTestTree as u}from"./testingViewState.js";let E=0;const a=()=>String(E++);class A{constructor(n,r=null){this.test=n;this.parent=r}changeEmitter=new m;onChange=this.changeEmitter.event;children=new Set;treeId=a();depth=this.parent?this.parent.depth+1:0;retired=!1;state=I.Unset;duration;toJSON(){if(this.depth===0)return{controllerId:this.test.controllerId};const n={$mid:T.TestItemContext,tests:[o.serialize(this.test)]};for(let r=this.parent;r&&r.depth>0;r=r.parent)n.tests.unshift(o.serialize(r.test));return n}}class p{constructor(n,r){this.message=n;this.parent=r}treeId=a();children=new Set;get description(){return typeof this.message=="string"?this.message:this.message.value}}const B={getId(t){const n=t instanceof p?"error":t.test.expand===i.NotExpandable?!!t.children.size:t.test.expand;return t.treeId+"\0"+n}},d=(t,n,r)=>{let s;if(r===null){const e=[...n];if(e.length===1)return d(t,e,e[0]);s=e}else s=r.children;return c.map(s,e=>e instanceof p?{element:e}:{element:e,collapsible:e.test.expand!==i.NotExpandable,collapsed:e.test.item.error?l.PreserveOrExpanded:u(t,e.test.item.extId)??e.depth>0?l.PreserveOrCollapsed:l.PreserveOrExpanded,children:d(t,n,e)})};export{A as TestItemTreeElement,p as TestTreeErrorMessage,d as getChildrenForParent,B as testIdentityProvider};
