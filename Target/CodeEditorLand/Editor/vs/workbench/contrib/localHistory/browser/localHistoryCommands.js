import{localize as a,localize2 as m}from"../../../../nls.js";import{URI as re}from"../../../../base/common/uri.js";import{Event as ie}from"../../../../base/common/event.js";import{Schemas as ne}from"../../../../base/common/network.js";import{toErrorMessage as se}from"../../../../base/common/errorMessage.js";import{CancellationToken as H,CancellationTokenSource as K}from"../../../../base/common/cancellation.js";import{IWorkingCopyHistoryService as g}from"../../../services/workingCopy/common/workingCopyHistory.js";import{API_OPEN_DIFF_EDITOR_COMMAND_ID as R}from"../../../browser/parts/editor/editorCommands.js";import{LocalHistoryFileSystemProvider as E}from"./localHistoryFileSystemProvider.js";import{ContextKeyExpr as W,IContextKeyService as ce,RawContextKey as ae}from"../../../../platform/contextkey/common/contextkey.js";import{registerAction2 as u,Action2 as d,MenuId as S,MenuRegistry as le}from"../../../../platform/actions/common/actions.js";import{basename as Q,basenameOrAuthority as q,dirname as me}from"../../../../base/common/resources.js";import{ICommandService as T}from"../../../../platform/commands/common/commands.js";import{EditorResourceAccessor as ue,SaveSourceRegistry as h,SideBySideEditor as $}from"../../../common/editor.js";import{IFileService as z}from"../../../../platform/files/common/files.js";import{IWorkingCopyService as de}from"../../../services/workingCopy/common/workingCopyService.js";import{IDialogService as B}from"../../../../platform/dialogs/common/dialogs.js";import{IEditorService as A}from"../../../services/editor/common/editorService.js";import{ActiveEditorContext as ye,ResourceContextKey as pe}from"../../../common/contextkeys.js";import{IQuickInputService as U}from"../../../../platform/quickinput/common/quickInput.js";import{getIconClasses as ge}from"../../../../editor/common/services/getIconClasses.js";import{IModelService as fe}from"../../../../editor/common/services/model.js";import{ILanguageService as we}from"../../../../editor/common/languages/language.js";import{ILabelService as X}from"../../../../platform/label/common/label.js";import{coalesce as Se}from"../../../../base/common/arrays.js";import{getLocalHistoryDateFormatter as ve,LOCAL_HISTORY_ICON_RESTORE as Ce,LOCAL_HISTORY_MENU_CONTEXT_KEY as k}from"./localHistory.js";import{IPathService as ke}from"../../../services/path/common/pathService.js";import{ResourceSet as G}from"../../../../base/common/map.js";import{IHistoryService as Ie}from"../../../services/history/common/history.js";import{DisposableStore as x}from"../../../../base/common/lifecycle.js";const M=m("localHistory.category","Local History"),D=W.has("config.workbench.localHistory.enabled"),he=m("localHistory.compareWithFile","Compare with File");u(class extends d{constructor(){super({id:"workbench.action.localHistory.compareWithFile",title:he,menu:{id:S.TimelineItemContext,group:"1_compare",order:1,when:k}})}async run(e,o){const t=e.get(T),r=e.get(g),{entry:n}=await v(r,o);if(n)return t.executeCommand(R,..._(n,n.workingCopy.resource))}}),u(class extends d{constructor(){super({id:"workbench.action.localHistory.compareWithPrevious",title:m("localHistory.compareWithPrevious","Compare with Previous"),menu:{id:S.TimelineItemContext,group:"1_compare",order:2,when:k}})}async run(e,o){const t=e.get(T),r=e.get(g),n=e.get(A),{entry:s,previous:i}=await v(r,o);if(s)return i?t.executeCommand(R,..._(i,s)):Y(s,n)}});let N;const j=new ae("localHistoryItemSelectedForCompare",!1,!0);u(class extends d{constructor(){super({id:"workbench.action.localHistory.selectForCompare",title:m("localHistory.selectForCompare","Select for Compare"),menu:{id:S.TimelineItemContext,group:"2_compare_with",order:2,when:k}})}async run(e,o){const t=e.get(g),r=e.get(ce),{entry:n}=await v(t,o);n&&(N=o,j.bindTo(r).set(!0))}}),u(class extends d{constructor(){super({id:"workbench.action.localHistory.compareWithSelected",title:m("localHistory.compareWithSelected","Compare with Selected"),menu:{id:S.TimelineItemContext,group:"2_compare_with",order:1,when:W.and(k,j)}})}async run(e,o){const t=e.get(g),r=e.get(T);if(!N)return;const n=(await v(t,N)).entry;if(!n)return;const{entry:s}=await v(t,o);if(s)return r.executeCommand(R,..._(n,s))}}),u(class extends d{constructor(){super({id:"workbench.action.localHistory.open",title:m("localHistory.open","Show Contents"),menu:{id:S.TimelineItemContext,group:"3_contents",order:1,when:k}})}async run(e,o){const t=e.get(g),r=e.get(A),{entry:n}=await v(t,o);if(n)return Y(n,r)}});const J=m("localHistory.restore","Restore Contents");u(class extends d{constructor(){super({id:"workbench.action.localHistory.restoreViaEditor",title:J,menu:{id:S.EditorTitle,group:"navigation",order:-10,when:pe.Scheme.isEqualTo(E.SCHEMA)},icon:Ce})}async run(e,o){const{associatedResource:t,location:r}=E.fromLocalHistoryFileSystem(o);return Z(e,{uri:t,handle:q(r)})}}),u(class extends d{constructor(){super({id:"workbench.action.localHistory.restore",title:J,menu:{id:S.TimelineItemContext,group:"3_contents",order:2,when:k}})}async run(e,o){return Z(e,o)}});const He=h.registerSource("localHistoryRestore.source",a("localHistoryRestore.source","File Restored"));async function Z(e,o){const t=e.get(z),r=e.get(B),n=e.get(de),s=e.get(g),i=e.get(A),{entry:l}=await v(s,o);if(l){const{confirmed:y}=await r.confirm({type:"warning",message:a("confirmRestoreMessage","Do you want to restore the contents of '{0}'?",Q(l.workingCopy.resource)),detail:a("confirmRestoreDetail","Restoring will discard any unsaved changes."),primaryButton:a({key:"restoreButtonLabel",comment:["&& denotes a mnemonic"]},"&&Restore")});if(!y)return;const C=n.getAll(l.workingCopy.resource);if(C)for(const f of C)f.isDirty()&&await f.revert({soft:!0});try{await t.cloneFile(l.location,l.workingCopy.resource)}catch(f){await r.error(a("unableToRestore","Unable to restore '{0}'.",Q(l.workingCopy.resource)),se(f));return}if(C)for(const f of C)await f.revert({force:!0});await i.openEditor({resource:l.workingCopy.resource}),await s.addEntry({resource:l.workingCopy.resource,source:He},H.None),await ee(l,i)}}u(class extends d{constructor(){super({id:"workbench.action.localHistory.restoreViaPicker",title:m("localHistory.restoreViaPicker","Find Entry to Restore"),f1:!0,category:M,precondition:D})}async run(e){const o=e.get(g),t=e.get(U),r=e.get(fe),n=e.get(we),s=e.get(X),i=e.get(A),l=e.get(z),y=e.get(T),C=e.get(Ie),f=new x,w=f.add(t.createQuickPick());let L=new K;f.add(w.onDidHide(()=>L.dispose(!0))),w.busy=!0,w.show();const O=new G(await o.getAll(L.token)),oe=new G(Se(C.getHistory().map(({resource:c})=>c))),F=[];for(const c of oe)O.has(c)&&(F.push(c),O.delete(c));F.push(...[...O].sort((c,I)=>c.fsPath<I.fsPath?-1:1)),w.busy=!1,w.placeholder=a("restoreViaPicker.filePlaceholder","Select the file to show local history for"),w.matchOnLabel=!0,w.matchOnDescription=!0,w.items=[...F].map(c=>({resource:c,label:q(c),description:s.getUriLabel(me(c),{relative:!0}),iconClasses:ge(r,n,c)})),await ie.toPromise(w.onDidAccept),f.dispose();const V=w.selectedItems.at(0)?.resource;if(!V)return;const P=new x,p=P.add(t.createQuickPick());L=new K,P.add(p.onDidHide(()=>L.dispose(!0))),p.busy=!0,p.show();const te=await o.getEntries(V,L.token);p.busy=!1,p.canAcceptInBackground=!0,p.placeholder=a("restoreViaPicker.entryPlaceholder","Select the local history entry to open"),p.matchOnLabel=!0,p.matchOnDescription=!0,p.items=Array.from(te).reverse().map(c=>({entry:c,label:`$(circle-outline) ${h.getSourceLabel(c.source)}`,description:b(c.timestamp)})),P.add(p.onDidAccept(async c=>{c.inBackground||P.dispose();const I=p.selectedItems.at(0);return I?await l.exists(I.entry.workingCopy.resource)?y.executeCommand(R,..._(I.entry,I.entry.workingCopy.resource,{preserveFocus:c.inBackground})):Y(I.entry,i,{preserveFocus:c.inBackground}):void 0}))}}),le.appendMenuItem(S.TimelineTitle,{command:{id:"workbench.action.localHistory.restoreViaPicker",title:m("localHistory.restoreViaPickerMenu","Local History: Find Entry to Restore...")},group:"submenu",order:1,when:D}),u(class extends d{constructor(){super({id:"workbench.action.localHistory.rename",title:m("localHistory.rename","Rename"),menu:{id:S.TimelineItemContext,group:"5_edit",order:1,when:k}})}async run(e,o){const t=e.get(g),r=e.get(U),{entry:n}=await v(t,o);if(n){const s=new x,i=s.add(r.createInputBox());i.title=a("renameLocalHistoryEntryTitle","Rename Local History Entry"),i.ignoreFocusOut=!0,i.placeholder=a("renameLocalHistoryPlaceholder","Enter the new name of the local history entry"),i.value=h.getSourceLabel(n.source),i.show(),s.add(i.onDidAccept(()=>{i.value&&t.updateEntry(n,{source:i.value},H.None),s.dispose()}))}}}),u(class extends d{constructor(){super({id:"workbench.action.localHistory.delete",title:m("localHistory.delete","Delete"),menu:{id:S.TimelineItemContext,group:"5_edit",order:2,when:k}})}async run(e,o){const t=e.get(g),r=e.get(A),n=e.get(B),{entry:s}=await v(t,o);if(s){const{confirmed:i}=await n.confirm({type:"warning",message:a("confirmDeleteMessage","Do you want to delete the local history entry of '{0}' from {1}?",s.workingCopy.name,b(s.timestamp)),detail:a("confirmDeleteDetail","This action is irreversible!"),primaryButton:a({key:"deleteButtonLabel",comment:["&& denotes a mnemonic"]},"&&Delete")});if(!i)return;await t.removeEntry(s,H.None),await ee(s,r)}}}),u(class extends d{constructor(){super({id:"workbench.action.localHistory.deleteAll",title:m("localHistory.deleteAll","Delete All"),f1:!0,category:M,precondition:D})}async run(e){const o=e.get(B),t=e.get(g),{confirmed:r}=await o.confirm({type:"warning",message:a("confirmDeleteAllMessage","Do you want to delete all entries of all files in local history?"),detail:a("confirmDeleteAllDetail","This action is irreversible!"),primaryButton:a({key:"deleteAllButtonLabel",comment:["&& denotes a mnemonic"]},"&&Delete All")});r&&await t.removeAll(H.None)}}),u(class extends d{constructor(){super({id:"workbench.action.localHistory.create",title:m("localHistory.create","Create Entry"),f1:!0,category:M,precondition:W.and(D,ye)})}async run(e){const o=e.get(g),t=e.get(U),r=e.get(A),n=e.get(X),s=e.get(ke),i=ue.getOriginalUri(r.activeEditor,{supportSideBySide:$.PRIMARY});if(i?.scheme!==s.defaultUriScheme&&i?.scheme!==ne.vscodeUserData)return;const l=new x,y=l.add(t.createInputBox());y.title=a("createLocalHistoryEntryTitle","Create Local History Entry"),y.ignoreFocusOut=!0,y.placeholder=a("createLocalHistoryPlaceholder","Enter the new name of the local history entry for '{0}'",n.getUriBasenameLabel(i)),y.show(),l.add(y.onDidAccept(async()=>{const C=y.value;l.dispose(),C&&await o.addEntry({resource:i,source:y.value},H.None)}))}});async function Y(e,o,t){const r=E.toLocalHistoryFileSystem({location:e.location,associatedResource:e.workingCopy.resource});await o.openEditor({resource:r,label:a("localHistoryEditorLabel","{0} ({1} \u2022 {2})",e.workingCopy.name,h.getSourceLabel(e.source),b(e.timestamp)),options:t})}async function ee(e,o){const t=E.toLocalHistoryFileSystem({location:e.location,associatedResource:e.workingCopy.resource}),r=o.findEditors(t,{supportSideBySide:$.ANY});await o.closeEditors(r,{preserveFocus:!0})}function _(e,o,t){const r=E.toLocalHistoryFileSystem({location:e.location,associatedResource:e.workingCopy.resource});let n,s;if(re.isUri(o))s=o,n=a("localHistoryCompareToFileEditorLabel","{0} ({1} \u2022 {2}) \u2194 {3}",e.workingCopy.name,h.getSourceLabel(e.source),b(e.timestamp),e.workingCopy.name);else{const i=o;s=E.toLocalHistoryFileSystem({location:i.location,associatedResource:i.workingCopy.resource}),n=a("localHistoryCompareToPreviousEditorLabel","{0} ({1} \u2022 {2}) \u2194 {3} ({4} \u2022 {5})",e.workingCopy.name,h.getSourceLabel(e.source),b(e.timestamp),i.workingCopy.name,h.getSourceLabel(i.source),b(i.timestamp))}return[r,s,n,t?[void 0,t]:void 0]}async function v(e,o){const t=await e.getEntries(o.uri,H.None);let r,n;for(let s=0;s<t.length;s++){const i=t[s];if(i.id===o.handle){r=i,n=t[s-1];break}}return{entry:r,previous:n}}const Ee=/\//g;function b(e){return`${ve().format(e).replace(Ee,"-")}`}export{he as COMPARE_WITH_FILE_LABEL,v as findLocalHistoryEntry,_ as toDiffEditorArguments};
