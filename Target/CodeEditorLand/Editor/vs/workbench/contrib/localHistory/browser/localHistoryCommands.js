import{coalesce as re}from"../../../../base/common/arrays.js";import{CancellationToken as E,CancellationTokenSource as K}from"../../../../base/common/cancellation.js";import{toErrorMessage as ie}from"../../../../base/common/errorMessage.js";import{Event as ne}from"../../../../base/common/event.js";import{DisposableStore as R}from"../../../../base/common/lifecycle.js";import{ResourceSet as Q}from"../../../../base/common/map.js";import{Schemas as se}from"../../../../base/common/network.js";import{basename as q,basenameOrAuthority as $,dirname as ce}from"../../../../base/common/resources.js";import{URI as ae}from"../../../../base/common/uri.js";import{ILanguageService as le}from"../../../../editor/common/languages/language.js";import{getIconClasses as me}from"../../../../editor/common/services/getIconClasses.js";import{IModelService as ue}from"../../../../editor/common/services/model.js";import{localize as a,localize2 as m}from"../../../../nls.js";import{Action2 as u,MenuId as S,MenuRegistry as de,registerAction2 as d}from"../../../../platform/actions/common/actions.js";import{ICommandService as T}from"../../../../platform/commands/common/commands.js";import{ContextKeyExpr as W,IContextKeyService as ye,RawContextKey as pe}from"../../../../platform/contextkey/common/contextkey.js";import{IDialogService as B}from"../../../../platform/dialogs/common/dialogs.js";import{IFileService as j}from"../../../../platform/files/common/files.js";import{ILabelService as z}from"../../../../platform/label/common/label.js";import{IQuickInputService as U}from"../../../../platform/quickinput/common/quickInput.js";import{API_OPEN_DIFF_EDITOR_COMMAND_ID as x}from"../../../browser/parts/editor/editorCommands.js";import{ActiveEditorContext as ge,ResourceContextKey as fe}from"../../../common/contextkeys.js";import{EditorResourceAccessor as we,SaveSourceRegistry as h,SideBySideEditor as X}from"../../../common/editor.js";import{IEditorService as H}from"../../../services/editor/common/editorService.js";import{IHistoryService as Se}from"../../../services/history/common/history.js";import{IPathService as ve}from"../../../services/path/common/pathService.js";import{IWorkingCopyHistoryService as g}from"../../../services/workingCopy/common/workingCopyHistory.js";import{IWorkingCopyService as Ce}from"../../../services/workingCopy/common/workingCopyService.js";import{LOCAL_HISTORY_ICON_RESTORE as ke,LOCAL_HISTORY_MENU_CONTEXT_KEY as k,getLocalHistoryDateFormatter as Ie}from"./localHistory.js";import{LocalHistoryFileSystemProvider as A}from"./localHistoryFileSystemProvider.js";const M=m("localHistory.category","Local History"),D=W.has("config.workbench.localHistory.enabled"),he=m("localHistory.compareWithFile","Compare with File");d(class extends u{constructor(){super({id:"workbench.action.localHistory.compareWithFile",title:he,menu:{id:S.TimelineItemContext,group:"1_compare",order:1,when:k}})}async run(e,o){const t=e.get(T),r=e.get(g),{entry:n}=await v(r,o);if(n)return t.executeCommand(x,..._(n,n.workingCopy.resource))}}),d(class extends u{constructor(){super({id:"workbench.action.localHistory.compareWithPrevious",title:m("localHistory.compareWithPrevious","Compare with Previous"),menu:{id:S.TimelineItemContext,group:"1_compare",order:2,when:k}})}async run(e,o){const t=e.get(T),r=e.get(g),n=e.get(H),{entry:s,previous:i}=await v(r,o);if(s)return i?t.executeCommand(x,..._(i,s)):Y(s,n)}});let N;const G=new pe("localHistoryItemSelectedForCompare",!1,!0);d(class extends u{constructor(){super({id:"workbench.action.localHistory.selectForCompare",title:m("localHistory.selectForCompare","Select for Compare"),menu:{id:S.TimelineItemContext,group:"2_compare_with",order:2,when:k}})}async run(e,o){const t=e.get(g),r=e.get(ye),{entry:n}=await v(t,o);n&&(N=o,G.bindTo(r).set(!0))}}),d(class extends u{constructor(){super({id:"workbench.action.localHistory.compareWithSelected",title:m("localHistory.compareWithSelected","Compare with Selected"),menu:{id:S.TimelineItemContext,group:"2_compare_with",order:1,when:W.and(k,G)}})}async run(e,o){const t=e.get(g),r=e.get(T);if(!N)return;const n=(await v(t,N)).entry;if(!n)return;const{entry:s}=await v(t,o);if(s)return r.executeCommand(x,..._(n,s))}}),d(class extends u{constructor(){super({id:"workbench.action.localHistory.open",title:m("localHistory.open","Show Contents"),menu:{id:S.TimelineItemContext,group:"3_contents",order:1,when:k}})}async run(e,o){const t=e.get(g),r=e.get(H),{entry:n}=await v(t,o);if(n)return Y(n,r)}});const J=m("localHistory.restore","Restore Contents");d(class extends u{constructor(){super({id:"workbench.action.localHistory.restoreViaEditor",title:J,menu:{id:S.EditorTitle,group:"navigation",order:-10,when:fe.Scheme.isEqualTo(A.SCHEMA)},icon:ke})}async run(e,o){const{associatedResource:t,location:r}=A.fromLocalHistoryFileSystem(o);return Z(e,{uri:t,handle:$(r)})}}),d(class extends u{constructor(){super({id:"workbench.action.localHistory.restore",title:J,menu:{id:S.TimelineItemContext,group:"3_contents",order:2,when:k}})}async run(e,o){return Z(e,o)}});const Ee=h.registerSource("localHistoryRestore.source",a("localHistoryRestore.source","File Restored"));async function Z(e,o){const t=e.get(j),r=e.get(B),n=e.get(Ce),s=e.get(g),i=e.get(H),{entry:l}=await v(s,o);if(l){const{confirmed:y}=await r.confirm({type:"warning",message:a("confirmRestoreMessage","Do you want to restore the contents of '{0}'?",q(l.workingCopy.resource)),detail:a("confirmRestoreDetail","Restoring will discard any unsaved changes."),primaryButton:a({key:"restoreButtonLabel",comment:["&& denotes a mnemonic"]},"&&Restore")});if(!y)return;const C=n.getAll(l.workingCopy.resource);if(C)for(const f of C)f.isDirty()&&await f.revert({soft:!0});try{await t.cloneFile(l.location,l.workingCopy.resource)}catch(f){await r.error(a("unableToRestore","Unable to restore '{0}'.",q(l.workingCopy.resource)),ie(f));return}if(C)for(const f of C)await f.revert({force:!0});await i.openEditor({resource:l.workingCopy.resource}),await s.addEntry({resource:l.workingCopy.resource,source:Ee},E.None),await ee(l,i)}}d(class extends u{constructor(){super({id:"workbench.action.localHistory.restoreViaPicker",title:m("localHistory.restoreViaPicker","Find Entry to Restore"),f1:!0,category:M,precondition:D})}async run(e){const o=e.get(g),t=e.get(U),r=e.get(ue),n=e.get(le),s=e.get(z),i=e.get(H),l=e.get(j),y=e.get(T),C=e.get(Se),f=new R,w=f.add(t.createQuickPick());let L=new K;f.add(w.onDidHide(()=>L.dispose(!0))),w.busy=!0,w.show();const O=new Q(await o.getAll(L.token)),oe=new Q(re(C.getHistory().map(({resource:c})=>c))),F=[];for(const c of oe)O.has(c)&&(F.push(c),O.delete(c));F.push(...[...O].sort((c,I)=>c.fsPath<I.fsPath?-1:1)),w.busy=!1,w.placeholder=a("restoreViaPicker.filePlaceholder","Select the file to show local history for"),w.matchOnLabel=!0,w.matchOnDescription=!0,w.items=[...F].map(c=>({resource:c,label:$(c),description:s.getUriLabel(ce(c),{relative:!0}),iconClasses:me(r,n,c)})),await ne.toPromise(w.onDidAccept),f.dispose();const V=w.selectedItems.at(0)?.resource;if(!V)return;const P=new R,p=P.add(t.createQuickPick());L=new K,P.add(p.onDidHide(()=>L.dispose(!0))),p.busy=!0,p.show();const te=await o.getEntries(V,L.token);p.busy=!1,p.canAcceptInBackground=!0,p.placeholder=a("restoreViaPicker.entryPlaceholder","Select the local history entry to open"),p.matchOnLabel=!0,p.matchOnDescription=!0,p.items=Array.from(te).reverse().map(c=>({entry:c,label:`$(circle-outline) ${h.getSourceLabel(c.source)}`,description:b(c.timestamp)})),P.add(p.onDidAccept(async c=>{c.inBackground||P.dispose();const I=p.selectedItems.at(0);return I?await l.exists(I.entry.workingCopy.resource)?y.executeCommand(x,..._(I.entry,I.entry.workingCopy.resource,{preserveFocus:c.inBackground})):Y(I.entry,i,{preserveFocus:c.inBackground}):void 0}))}}),de.appendMenuItem(S.TimelineTitle,{command:{id:"workbench.action.localHistory.restoreViaPicker",title:m("localHistory.restoreViaPickerMenu","Local History: Find Entry to Restore...")},group:"submenu",order:1,when:D}),d(class extends u{constructor(){super({id:"workbench.action.localHistory.rename",title:m("localHistory.rename","Rename"),menu:{id:S.TimelineItemContext,group:"5_edit",order:1,when:k}})}async run(e,o){const t=e.get(g),r=e.get(U),{entry:n}=await v(t,o);if(n){const s=new R,i=s.add(r.createInputBox());i.title=a("renameLocalHistoryEntryTitle","Rename Local History Entry"),i.ignoreFocusOut=!0,i.placeholder=a("renameLocalHistoryPlaceholder","Enter the new name of the local history entry"),i.value=h.getSourceLabel(n.source),i.show(),s.add(i.onDidAccept(()=>{i.value&&t.updateEntry(n,{source:i.value},E.None),s.dispose()}))}}}),d(class extends u{constructor(){super({id:"workbench.action.localHistory.delete",title:m("localHistory.delete","Delete"),menu:{id:S.TimelineItemContext,group:"5_edit",order:2,when:k}})}async run(e,o){const t=e.get(g),r=e.get(H),n=e.get(B),{entry:s}=await v(t,o);if(s){const{confirmed:i}=await n.confirm({type:"warning",message:a("confirmDeleteMessage","Do you want to delete the local history entry of '{0}' from {1}?",s.workingCopy.name,b(s.timestamp)),detail:a("confirmDeleteDetail","This action is irreversible!"),primaryButton:a({key:"deleteButtonLabel",comment:["&& denotes a mnemonic"]},"&&Delete")});if(!i)return;await t.removeEntry(s,E.None),await ee(s,r)}}}),d(class extends u{constructor(){super({id:"workbench.action.localHistory.deleteAll",title:m("localHistory.deleteAll","Delete All"),f1:!0,category:M,precondition:D})}async run(e){const o=e.get(B),t=e.get(g),{confirmed:r}=await o.confirm({type:"warning",message:a("confirmDeleteAllMessage","Do you want to delete all entries of all files in local history?"),detail:a("confirmDeleteAllDetail","This action is irreversible!"),primaryButton:a({key:"deleteAllButtonLabel",comment:["&& denotes a mnemonic"]},"&&Delete All")});r&&await t.removeAll(E.None)}}),d(class extends u{constructor(){super({id:"workbench.action.localHistory.create",title:m("localHistory.create","Create Entry"),f1:!0,category:M,precondition:W.and(D,ge)})}async run(e){const o=e.get(g),t=e.get(U),r=e.get(H),n=e.get(z),s=e.get(ve),i=we.getOriginalUri(r.activeEditor,{supportSideBySide:X.PRIMARY});if(i?.scheme!==s.defaultUriScheme&&i?.scheme!==se.vscodeUserData)return;const l=new R,y=l.add(t.createInputBox());y.title=a("createLocalHistoryEntryTitle","Create Local History Entry"),y.ignoreFocusOut=!0,y.placeholder=a("createLocalHistoryPlaceholder","Enter the new name of the local history entry for '{0}'",n.getUriBasenameLabel(i)),y.show(),l.add(y.onDidAccept(async()=>{const C=y.value;l.dispose(),C&&await o.addEntry({resource:i,source:y.value},E.None)}))}});async function Y(e,o,t){const r=A.toLocalHistoryFileSystem({location:e.location,associatedResource:e.workingCopy.resource});await o.openEditor({resource:r,label:a("localHistoryEditorLabel","{0} ({1} \u2022 {2})",e.workingCopy.name,h.getSourceLabel(e.source),b(e.timestamp)),options:t})}async function ee(e,o){const t=A.toLocalHistoryFileSystem({location:e.location,associatedResource:e.workingCopy.resource}),r=o.findEditors(t,{supportSideBySide:X.ANY});await o.closeEditors(r,{preserveFocus:!0})}function _(e,o,t){const r=A.toLocalHistoryFileSystem({location:e.location,associatedResource:e.workingCopy.resource});let n,s;if(ae.isUri(o))s=o,n=a("localHistoryCompareToFileEditorLabel","{0} ({1} \u2022 {2}) \u2194 {3}",e.workingCopy.name,h.getSourceLabel(e.source),b(e.timestamp),e.workingCopy.name);else{const i=o;s=A.toLocalHistoryFileSystem({location:i.location,associatedResource:i.workingCopy.resource}),n=a("localHistoryCompareToPreviousEditorLabel","{0} ({1} \u2022 {2}) \u2194 {3} ({4} \u2022 {5})",e.workingCopy.name,h.getSourceLabel(e.source),b(e.timestamp),i.workingCopy.name,h.getSourceLabel(i.source),b(i.timestamp))}return[r,s,n,t?[void 0,t]:void 0]}async function v(e,o){const t=await e.getEntries(o.uri,E.None);let r,n;for(let s=0;s<t.length;s++){const i=t[s];if(i.id===o.handle){r=i,n=t[s-1];break}}return{entry:r,previous:n}}const He=/\//g;function b(e){return`${Ie().format(e).replace(He,"-")}`}export{he as COMPARE_WITH_FILE_LABEL,v as findLocalHistoryEntry,_ as toDiffEditorArguments};
