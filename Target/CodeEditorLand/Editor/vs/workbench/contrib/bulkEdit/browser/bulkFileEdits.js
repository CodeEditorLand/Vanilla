var U=Object.defineProperty;var R=Object.getOwnPropertyDescriptor;var p=(d,e,n,r)=>{for(var o=r>1?void 0:r?R(e,n):e,t=d.length-1,i;t>=0;t--)(i=d[t])&&(o=(r?i(e,n,o):i(o))||o);return r&&o&&U(e,n,o),o},a=(d,e)=>(n,r)=>e(n,r,d);import{tail as F}from"../../../../base/common/arrays.js";import{CancellationToken as C}from"../../../../base/common/cancellation.js";import{Schemas as k}from"../../../../base/common/network.js";import{IConfigurationService as E}from"../../../../platform/configuration/common/configuration.js";import{FileSystemProviderCapabilities as b,IFileService as h}from"../../../../platform/files/common/files.js";import{IInstantiationService as I}from"../../../../platform/instantiation/common/instantiation.js";import{ILogService as O}from"../../../../platform/log/common/log.js";import{IUndoRedoService as x,UndoRedoElementType as W}from"../../../../platform/undoRedo/common/undoRedo.js";import{ITextFileService as T}from"../../../services/textfile/common/textfiles.js";import{IWorkingCopyFileService as m}from"../../../services/workingCopy/common/workingCopyFileService.js";class y{uris=[];async perform(){return this}toString(){return"(noop)"}}class w{constructor(e,n,r){this.newUri=e;this.oldUri=n;this.options=r}type="rename"}let c=class{constructor(e,n,r,o){this._edits=e;this._undoRedoInfo=n;this._workingCopyFileService=r;this._fileService=o}get uris(){return this._edits.flatMap(e=>[e.newUri,e.oldUri])}async perform(e){const n=[],r=[];for(const o of this._edits)o.options.overwrite===void 0&&o.options.ignoreIfExists&&await this._fileService.exists(o.newUri)||(n.push({file:{source:o.oldUri,target:o.newUri},overwrite:o.options.overwrite}),r.push(new w(o.oldUri,o.newUri,o.options)));return n.length===0?new y:(await this._workingCopyFileService.move(n,e,this._undoRedoInfo),new c(r,{isUndoing:!0},this._workingCopyFileService,this._fileService))}toString(){return`(rename ${this._edits.map(e=>`${e.oldUri} to ${e.newUri}`).join(", ")})`}};c=p([a(2,m),a(3,h)],c);class ${constructor(e,n,r){this.newUri=e;this.oldUri=n;this.options=r}type="copy"}let v=class{constructor(e,n,r,o,t){this._edits=e;this._undoRedoInfo=n;this._workingCopyFileService=r;this._fileService=o;this._instaService=t}get uris(){return this._edits.flatMap(e=>[e.newUri,e.oldUri])}async perform(e){const n=[];for(const t of this._edits)t.options.overwrite===void 0&&t.options.ignoreIfExists&&await this._fileService.exists(t.newUri)||n.push({file:{source:t.oldUri,target:t.newUri},overwrite:t.options.overwrite});if(n.length===0)return new y;const r=await this._workingCopyFileService.copy(n,e,this._undoRedoInfo),o=[];for(let t=0;t<r.length;t++){const i=r[t],s=this._edits[t];o.push(new S(i.resource,{recursive:!0,folder:this._edits[t].options.folder||i.isDirectory,...s.options},!1))}return this._instaService.createInstance(l,o,{isUndoing:!0})}toString(){return`(copy ${this._edits.map(e=>`${e.oldUri} to ${e.newUri}`).join(", ")})`}};v=p([a(2,m),a(3,h),a(4,I)],v);class g{constructor(e,n,r){this.newUri=e;this.options=n;this.contents=r}type="create"}let u=class{constructor(e,n,r,o,t,i){this._edits=e;this._undoRedoInfo=n;this._fileService=r;this._workingCopyFileService=o;this._instaService=t;this._textFileService=i}get uris(){return this._edits.map(e=>e.newUri)}async perform(e){const n=[],r=[],o=[];for(const t of this._edits)if(t.newUri.scheme!==k.untitled&&!(t.options.overwrite===void 0&&t.options.ignoreIfExists&&await this._fileService.exists(t.newUri))){if(t.options.folder)n.push({resource:t.newUri});else{const i=typeof t.contents<"u"?t.contents:await this._textFileService.getEncodedReadable(t.newUri);r.push({resource:t.newUri,contents:i,overwrite:t.options.overwrite})}o.push(new S(t.newUri,t.options,!t.options.folder&&!t.contents))}return n.length===0&&r.length===0?new y:(await this._workingCopyFileService.createFolder(n,e,this._undoRedoInfo),await this._workingCopyFileService.create(r,e,this._undoRedoInfo),this._instaService.createInstance(l,o,{isUndoing:!0}))}toString(){return`(create ${this._edits.map(e=>e.options.folder?`folder ${e.newUri}`:`file ${e.newUri} with ${e.contents?.byteLength||0} bytes`).join(", ")})`}};u=p([a(2,h),a(3,m),a(4,I),a(5,T)],u);class S{constructor(e,n,r){this.oldUri=e;this.options=n;this.undoesCreate=r}type="delete"}let l=class{constructor(e,n,r,o,t,i,s){this._edits=e;this._undoRedoInfo=n;this._workingCopyFileService=r;this._fileService=o;this._configurationService=t;this._instaService=i;this._logService=s}get uris(){return this._edits.map(e=>e.oldUri)}async perform(e){const n=[],r=[];for(const o of this._edits){let t;try{t=await this._fileService.resolve(o.oldUri,{resolveMetadata:!0})}catch{if(!o.options.ignoreIfNotExists)throw new Error(`${o.oldUri} does not exist and can not be deleted`);continue}n.push({resource:o.oldUri,recursive:o.options.recursive,useTrash:!o.options.skipTrashBin&&this._fileService.hasCapability(o.oldUri,b.Trash)&&this._configurationService.getValue("files.enableTrash")});let i;if(!o.undoesCreate&&!o.options.folder&&!(typeof o.options.maxSize=="number"&&t.size>o.options.maxSize))try{i=await this._fileService.readFile(o.oldUri)}catch(s){this._logService.error(s)}i!==void 0&&r.push(new g(o.oldUri,o.options,i.value))}return n.length===0?new y:(await this._workingCopyFileService.delete(n,e,this._undoRedoInfo),r.length===0?new y:this._instaService.createInstance(u,r,{isUndoing:!0}))}toString(){return`(delete ${this._edits.map(e=>e.oldUri).join(", ")})`}};l=p([a(2,m),a(3,h),a(4,E),a(5,I),a(6,O)],l);class P{constructor(e,n,r,o){this.label=e;this.code=n;this.operations=r;this.confirmBeforeUndo=o;this.resources=r.flatMap(t=>t.uris)}type=W.Workspace;resources;async undo(){await this._reverse()}async redo(){await this._reverse()}async _reverse(){for(let e=0;e<this.operations.length;e++){const r=await this.operations[e].perform(C.None);this.operations[e]=r}}toString(){return this.operations.map(e=>String(e)).join(", ")}}let _=class{constructor(e,n,r,o,t,i,s,f,j,M){this._label=e;this._code=n;this._undoRedoGroup=r;this._undoRedoSource=o;this._confirmBeforeUndo=t;this._progress=i;this._token=s;this._edits=f;this._instaService=j;this._undoRedoService=M}async apply(){const e=[],n={undoRedoGroupId:this._undoRedoGroup.id},r=[];for(const i of this._edits)i.newResource&&i.oldResource&&!i.options?.copy?r.push(new w(i.newResource,i.oldResource,i.options??{})):i.newResource&&i.oldResource&&i.options?.copy?r.push(new $(i.newResource,i.oldResource,i.options??{})):!i.newResource&&i.oldResource?r.push(new S(i.oldResource,i.options??{},!1)):i.newResource&&!i.oldResource&&r.push(new g(i.newResource,i.options??{},await i.options.contents));if(r.length===0)return[];const o=[];o[0]=[r[0]];for(let i=1;i<r.length;i++){const s=r[i],f=F(o);f?.[0].type===s.type?f.push(s):o.push([s])}for(const i of o){if(this._token.isCancellationRequested)break;let s;switch(i[0].type){case"rename":s=this._instaService.createInstance(c,i,n);break;case"copy":s=this._instaService.createInstance(v,i,n);break;case"delete":s=this._instaService.createInstance(l,i,n);break;case"create":s=this._instaService.createInstance(u,i,n);break}if(s){const f=await s.perform(this._token);e.push(f)}this._progress.report(void 0)}const t=new P(this._label,this._code,e,this._confirmBeforeUndo);return this._undoRedoService.pushElement(t,this._undoRedoGroup,this._undoRedoSource),t.resources}};_=p([a(8,I),a(9,x)],_);export{_ as BulkFileEdits};
