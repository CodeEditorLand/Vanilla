var y=Object.defineProperty;var b=Object.getOwnPropertyDescriptor;var m=(s,o,n,a)=>{for(var r=a>1?void 0:a?b(o,n):o,t=s.length-1,e;t>=0;t--)(e=s[t])&&(r=(a?e(o,n,r):e(r))||r);return a&&r&&y(o,n,r),r},h=(s,o)=>(n,a)=>o(n,a,s);import{DisposableMap as w}from"../../../../../base/common/lifecycle.js";import{joinPath as d}from"../../../../../base/common/resources.js";import{ThemeIcon as I}from"../../../../../base/common/themables.js";import{localize as i}from"../../../../../nls.js";import{ContextKeyExpr as v}from"../../../../../platform/contextkey/common/contextkey.js";import{ILogService as k}from"../../../../../platform/log/common/log.js";import*as x from"../../../../services/extensions/common/extensionsRegistry.js";import{ILanguageModelToolsService as D}from"../languageModelToolsService.js";const N=x.ExtensionsRegistry.registerExtensionPoint({extensionPoint:"languageModelTools",activationEventsGenerator:(s,o)=>{for(const n of s)o.push(`onLanguageModelTool:${n.id}`)},jsonSchema:{description:i("vscode.extension.contributes.tools","Contributes a tool that can be invoked by a language model."),type:"array",items:{additionalProperties:!1,type:"object",defaultSnippets:[{body:{name:"",description:""}}],required:["id","modelDescription"],properties:{id:{description:i("toolId","A unique id for this tool."),type:"string",pattern:"^[\\w-]+$"},name:{description:i("toolName","If {0} is enabled for this tool, the user may use '#' with this name to invoke the tool in a query. Otherwise, the name is not required. Name must not contain whitespace.","`canBeInvokedManually`"),type:"string",pattern:"^[\\w-]+$"},displayName:{description:i("toolDisplayName","A human-readable name for this tool that may be used to describe it in the UI."),type:"string"},userDescription:{description:i("toolUserDescription","A description of this tool that may be shown to the user."),type:"string"},modelDescription:{description:i("toolModelDescription","A description of this tool that may be passed to a language model."),type:"string"},parametersSchema:{description:i("parametersSchema","A JSON schema for the parameters this tool accepts."),type:"object",$ref:"http://json-schema.org/draft-07/schema#"},canBeInvokedManually:{description:i("canBeInvokedManually","Whether this tool can be invoked manually by the user through the chat UX."),type:"boolean"},icon:{description:i("icon","An icon that represents this tool. Either a file path, an object with file paths for dark and light themes, or a theme icon reference, like `\\$(zap)`"),anyOf:[{type:"string"},{type:"object",properties:{light:{description:i("icon.light","Icon path when a light theme is used"),type:"string"},dark:{description:i("icon.dark","Icon path when a dark theme is used"),type:"string"}}}]},when:{markdownDescription:i("condition","Condition which must be true for this tool to be enabled. Note that a tool may still be invoked by another extension even when its `when` condition is false."),type:"string"}}}}});function f(s,o){return`${s.value}/${o}`}let l=class{static ID="workbench.contrib.toolsExtensionPointHandler";_registrationDisposables=new w;constructor(o,n){N.setHandler((a,r)=>{for(const t of r.added)for(const e of t.value){if(!e.id||!e.modelDescription){n.error(`Extension '${t.description.identifier.value}' CANNOT register tool without name and modelDescription: ${JSON.stringify(e)}`);continue}if(!e.id.match(/^[\w-]+$/)){n.error(`Extension '${t.description.identifier.value}' CANNOT register tool with invalid id: ${e.id}. The id must match /^[\\w-]+$/.`);continue}if(e.canBeInvokedManually&&!e.name){n.error(`Extension '${t.description.identifier.value}' CANNOT register tool with 'canBeInvokedManually' set without a name: ${JSON.stringify(e)}`);continue}const c=e.icon;let p;typeof c=="string"?p=I.fromString(c)??{dark:d(t.description.extensionLocation,c),light:d(t.description.extensionLocation,c)}:c&&(p={dark:d(t.description.extensionLocation,c.dark),light:d(t.description.extensionLocation,c.light)});const u={...e,icon:p,when:e.when?v.deserialize(e.when):void 0},g=o.registerToolData(u);this._registrationDisposables.set(f(t.description.identifier,e.id),g)}for(const t of r.removed)for(const e of t.value)this._registrationDisposables.deleteAndDispose(f(t.description.identifier,e.id))})}};l=m([h(0,D),h(1,k)],l);export{l as LanguageModelToolsExtensionPointHandler};
