var h=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var l=(s,e,n,r)=>{for(var t=r>1?void 0:r?p(e,n):e,a=s.length-1,o;a>=0;a--)(o=s[a])&&(t=(r?o(e,n,t):o(t))||t);return r&&t&&h(e,n,t),t},g=(s,e)=>(n,r)=>e(n,r,s);import"../../../../../vs/base/common/cancellation.js";import{Emitter as c}from"../../../../../vs/base/common/event.js";import{Iterable as v}from"../../../../../vs/base/common/iterator.js";import"../../../../../vs/base/common/jsonSchema.js";import{DisposableStore as m,toDisposable as f}from"../../../../../vs/base/common/lifecycle.js";import{isFalsyOrWhitespace as y}from"../../../../../vs/base/common/strings.js";import{localize as i}from"../../../../../vs/nls.js";import{ExtensionIdentifier as I}from"../../../../../vs/platform/extensions/common/extensions.js";import{createDecorator as C}from"../../../../../vs/platform/instantiation/common/instantiation.js";import{ILogService as M}from"../../../../../vs/platform/log/common/log.js";import{IExtensionService as x,isProposedApiEnabled as L}from"../../../../../vs/workbench/services/extensions/common/extensions.js";import{ExtensionsRegistry as _}from"../../../../../vs/workbench/services/extensions/common/extensionsRegistry.js";var P=(r=>(r[r.System=0]="System",r[r.User=1]="User",r[r.Assistant=2]="Assistant",r))(P||{});const V=C("ILanguageModelsService"),u={type:"object",properties:{vendor:{type:"string",description:i("vscode.extension.contributes.languageModels.vendor","A globally unique vendor of language models.")}}},b=_.registerExtensionPoint({extensionPoint:"languageModels",jsonSchema:{description:i("vscode.extension.contributes.languageModels","Contribute language models of a specific vendor."),oneOf:[u,{type:"array",items:u}]},activationEventsGenerator:(s,e)=>{for(const n of s)e.push(`onLanguageModelChat:${n.vendor}`)}});let d=class{constructor(e,n){this._extensionService=e;this._logService=n;this._store.add(b.setHandler(r=>{this._vendors.clear();for(const a of r){if(!L(a.description,"chatProvider")){a.collector.error(i("vscode.extension.contributes.languageModels.chatProviderRequired","This contribution point requires the 'chatProvider' proposal."));continue}for(const o of v.wrap(a.value)){if(this._vendors.has(o.vendor)){a.collector.error(i("vscode.extension.contributes.languageModels.vendorAlreadyRegistered","The vendor '{0}' is already registered and cannot be registered twice",o.vendor));continue}if(y(o.vendor)){a.collector.error(i("vscode.extension.contributes.languageModels.emptyVendor","The vendor field cannot be empty."));continue}if(o.vendor.trim()!==o.vendor){a.collector.error(i("vscode.extension.contributes.languageModels.whitespaceVendor","The vendor field cannot start or end with whitespace."));continue}this._vendors.add(o.vendor)}}const t=[];for(const[a,o]of this._providers)this._vendors.has(o.metadata.vendor)||(this._providers.delete(a),t.push(a));t.length>0&&this._onDidChangeProviders.fire({removed:t})}))}_serviceBrand;_store=new m;_providers=new Map;_vendors=new Set;_onDidChangeProviders=this._store.add(new c);onDidChangeLanguageModels=this._onDidChangeProviders.event;dispose(){this._store.dispose(),this._providers.clear()}getLanguageModelIds(){return Array.from(this._providers.keys())}lookupLanguageModel(e){return this._providers.get(e)?.metadata}async selectLanguageModels(e){if(e.vendor)await this._extensionService.activateByEvent(`onLanguageModelChat:${e.vendor}}`);else{const r=Array.from(this._vendors).map(t=>this._extensionService.activateByEvent(`onLanguageModelChat:${t}`));await Promise.all(r)}const n=[];for(const[r,t]of this._providers)(e.vendor===void 0||t.metadata.vendor===e.vendor)&&(e.family===void 0||t.metadata.family===e.family)&&(e.version===void 0||t.metadata.version===e.version)&&(e.identifier===void 0||t.metadata.id===e.identifier)&&(!t.metadata.targetExtensions||t.metadata.targetExtensions.some(a=>I.equals(a,e.extension)))&&n.push(r);return this._logService.trace("[LM] selected language models",e,n),n}registerLanguageModelChat(e,n){if(this._logService.trace("[LM] registering language model chat",e,n.metadata),!this._vendors.has(n.metadata.vendor))throw new Error(`Chat response provider uses UNKNOWN vendor ${n.metadata.vendor}.`);if(this._providers.has(e))throw new Error(`Chat response provider with identifier ${e} is already registered.`);return this._providers.set(e,n),this._onDidChangeProviders.fire({added:[{identifier:e,metadata:n.metadata}]}),f(()=>{this._providers.delete(e)&&(this._onDidChangeProviders.fire({removed:[e]}),this._logService.trace("[LM] UNregistered language model chat",e,n.metadata))})}async sendChatRequest(e,n,r,t,a){const o=this._providers.get(e);if(!o)throw new Error(`Chat response provider with identifier ${e} is not registered.`);return o.sendChatRequest(r,n,t,a)}computeTokenLength(e,n,r){const t=this._providers.get(e);if(!t)throw new Error(`Chat response provider with identifier ${e} is not registered.`);return t.provideTokenCount(n,r)}};d=l([g(0,x),g(1,M)],d);export{P as ChatMessageRole,V as ILanguageModelsService,d as LanguageModelsService,b as languageModelExtensionPoint};
