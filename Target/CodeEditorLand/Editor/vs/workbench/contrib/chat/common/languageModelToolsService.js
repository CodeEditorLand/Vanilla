var h=Object.defineProperty;var I=Object.getOwnPropertyDescriptor;var d=(r,i,e,o)=>{for(var t=o>1?void 0:o?I(i,e):i,n=r.length-1,s;n>=0;n--)(s=r[n])&&(t=(o?s(i,e,t):s(t))||t);return o&&t&&h(i,e,t),t},a=(r,i)=>(e,o)=>i(e,o,r);import{RunOnceScheduler as m}from"../../../../../vs/base/common/async.js";import"../../../../../vs/base/common/cancellation.js";import{Emitter as p}from"../../../../../vs/base/common/event.js";import{Iterable as c}from"../../../../../vs/base/common/iterator.js";import"../../../../../vs/base/common/jsonSchema.js";import{Disposable as g,toDisposable as T}from"../../../../../vs/base/common/lifecycle.js";import"../../../../../vs/base/common/themables.js";import"../../../../../vs/base/common/uri.js";import{IContextKeyService as u}from"../../../../../vs/platform/contextkey/common/contextkey.js";import{createDecorator as f}from"../../../../../vs/platform/instantiation/common/instantiation.js";import{IExtensionService as v}from"../../../../../vs/workbench/services/extensions/common/extensions.js";const U=f("ILanguageModelToolsService");let l=class extends g{constructor(e,o){super();this._extensionService=e;this._contextKeyService=o;this._register(this._contextKeyService.onDidChangeContext(t=>{t.affectsSome(this._toolContextKeys)&&this._onDidChangeToolsScheduler.schedule()}))}_serviceBrand;_onDidChangeTools=new p;onDidChangeTools=this._onDidChangeTools.event;_onDidChangeToolsScheduler=new m(()=>this._onDidChangeTools.fire(),750);_tools=new Map;_toolContextKeys=new Set;registerToolData(e){if(this._tools.has(e.id))throw new Error(`Tool "${e.id}" is already registered.`);return this._tools.set(e.id,{data:e}),this._onDidChangeToolsScheduler.schedule(),e.when?.keys().forEach(o=>this._toolContextKeys.add(o)),T(()=>{this._tools.delete(e.id),this._refreshAllToolContextKeys(),this._onDidChangeToolsScheduler.schedule()})}_refreshAllToolContextKeys(){this._toolContextKeys.clear();for(const e of this._tools.values())e.data.when?.keys().forEach(o=>this._toolContextKeys.add(o))}registerToolImplementation(e,o){const t=this._tools.get(e);if(!t)throw new Error(`Tool "${e}" was not contributed.`);if(t.impl)throw new Error(`Tool "${e}" already has an implementation.`);return t.impl=o,T(()=>{t.impl=void 0})}getTools(){const e=c.map(this._tools.values(),o=>o.data);return c.filter(e,o=>!o.when||this._contextKeyService.contextMatchesRules(o.when))}getTool(e){return this._getToolEntry(e)?.data}_getToolEntry(e){const o=this._tools.get(e);if(o&&(!o.data.when||this._contextKeyService.contextMatchesRules(o.data.when)))return o}getToolByName(e){for(const o of this.getTools())if(o.name===e)return o}async invokeTool(e,o,t){let n=this._tools.get(e.toolId);if(!n)throw new Error(`Tool ${e.toolId} was not contributed`);if(!n.impl&&(await this._extensionService.activateByEvent(`onLanguageModelTool:${e.toolId}`),n=this._tools.get(e.toolId),!n?.impl))throw new Error(`Tool ${e.toolId} does not have an implementation registered.`);return n.impl.invoke(e,o,t)}};l=d([a(0,v),a(1,u)],l);export{U as ILanguageModelToolsService,l as LanguageModelToolsService};
