import{TypeHierarchyDirection as s,TypeHierarchyModel as y}from"../common/typeHierarchy.js";import{CancellationToken as c}from"../../../../base/common/cancellation.js";import{createMatches as d}from"../../../../base/common/filters.js";import{IconLabel as u}from"../../../../base/browser/ui/iconLabel/iconLabel.js";import{SymbolKinds as T,SymbolTag as g}from"../../../../editor/common/languages.js";import{compare as h}from"../../../../base/common/strings.js";import{Range as I}from"../../../../editor/common/core/range.js";import{localize as a}from"../../../../nls.js";import{ThemeIcon as b}from"../../../../base/common/themables.js";class o{constructor(e,r,t){this.item=e;this.model=r;this.parent=t}static compare(e,r){let t=h(e.item.uri.toString(),r.item.uri.toString());return t===0&&(t=I.compareRangesUsingStarts(e.item.range,r.item.range)),t}}class K{constructor(e){this.getDirection=e}hasChildren(){return!0}async getChildren(e){if(e instanceof y)return e.roots.map(i=>new o(i,e,void 0));const{model:r,item:t}=e;return this.getDirection()===s.Supertypes?(await r.provideSupertypes(t,c.None)).map(i=>new o(i,r,e)):(await r.provideSubtypes(t,c.None)).map(i=>new o(i,r,e))}}class U{compare(e,r){return o.compare(e,r)}}class W{constructor(e){this.getDirection=e}getId(e){let r=this.getDirection()+JSON.stringify(e.item.uri)+JSON.stringify(e.item.range);return e.parent&&(r+=this.getId(e.parent)),r}}class f{constructor(e,r){this.icon=e;this.label=r}}class p{static id="TypeRenderer";templateId=p.id;renderTemplate(e){e.classList.add("typehierarchy-element");const r=document.createElement("div");e.appendChild(r);const t=new u(e,{supportHighlights:!0});return new f(r,t)}renderElement(e,r,t){const{element:i,filterData:l}=e,m=i.item.tags?.includes(g.Deprecated);t.icon.classList.add("inline",...b.asClassNameArray(T.toIcon(i.item.kind))),t.label.setLabel(i.item.name,i.item.detail,{labelEscapeNewLines:!0,matches:d(l),strikethrough:m})}disposeTemplate(e){e.label.dispose()}}class j{getHeight(e){return 22}getTemplateId(e){return p.id}}class q{constructor(e){this.getDirection=e}getWidgetAriaLabel(){return a("tree.aria","Type Hierarchy")}getAriaLabel(e){return this.getDirection()===s.Supertypes?a("supertypes","supertypes of {0}",e.item.name):a("subtypes","subtypes of {0}",e.item.name)}}export{q as AccessibilityProvider,K as DataSource,W as IdentityProvider,U as Sorter,o as Type,p as TypeRenderer,j as VirtualDelegate};
