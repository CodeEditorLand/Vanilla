import{IconLabel as m}from"../../../../base/browser/ui/iconLabel/iconLabel.js";import{CancellationToken as p}from"../../../../base/common/cancellation.js";import{createMatches as d}from"../../../../base/common/filters.js";import{compare as u}from"../../../../base/common/strings.js";import{ThemeIcon as T}from"../../../../base/common/themables.js";import{Range as g}from"../../../../editor/common/core/range.js";import{SymbolKinds as b,SymbolTag as h}from"../../../../editor/common/languages.js";import{localize as s}from"../../../../nls.js";import{TypeHierarchyDirection as c,TypeHierarchyModel as I}from"../common/typeHierarchy.js";class n{constructor(e,r,t){this.item=e;this.model=r;this.parent=t}static compare(e,r){let t=u(e.item.uri.toString(),r.item.uri.toString());return t===0&&(t=g.compareRangesUsingStarts(e.item.range,r.item.range)),t}}class N{constructor(e){this.getDirection=e}hasChildren(){return!0}async getChildren(e){if(e instanceof I)return e.roots.map(i=>new n(i,e,void 0));const{model:r,item:t}=e;return this.getDirection()===c.Supertypes?(await r.provideSupertypes(t,p.None)).map(i=>new n(i,r,e)):(await r.provideSubtypes(t,p.None)).map(i=>new n(i,r,e))}}class z{compare(e,r){return n.compare(e,r)}}class M{constructor(e){this.getDirection=e}getId(e){let r=this.getDirection()+JSON.stringify(e.item.uri)+JSON.stringify(e.item.range);return e.parent&&(r+=this.getId(e.parent)),r}}class f{constructor(e,r){this.icon=e;this.label=r}}class a{static id="TypeRenderer";templateId=a.id;renderTemplate(e){e.classList.add("typehierarchy-element");const r=document.createElement("div");e.appendChild(r);const t=new m(e,{supportHighlights:!0});return new f(r,t)}renderElement(e,r,t){const{element:i,filterData:l}=e,y=i.item.tags?.includes(h.Deprecated);t.icon.classList.add("inline",...T.asClassNameArray(b.toIcon(i.item.kind))),t.label.setLabel(i.item.name,i.item.detail,{labelEscapeNewLines:!0,matches:d(l),strikethrough:y})}disposeTemplate(e){e.label.dispose()}}class P{getHeight(e){return 22}getTemplateId(e){return a.id}}class C{constructor(e){this.getDirection=e}getWidgetAriaLabel(){return s("tree.aria","Type Hierarchy")}getAriaLabel(e){return this.getDirection()===c.Supertypes?s("supertypes","supertypes of {0}",e.item.name):s("subtypes","subtypes of {0}",e.item.name)}}export{C as AccessibilityProvider,N as DataSource,M as IdentityProvider,z as Sorter,n as Type,a as TypeRenderer,P as VirtualDelegate};
