var y=Object.defineProperty;var x=Object.getOwnPropertyDescriptor;var f=(i,e,r,t)=>{for(var o=t>1?void 0:t?x(e,r):e,n=i.length-1,a;n>=0;n--)(a=i[n])&&(o=(t?a(e,r,o):a(o))||o);return t&&o&&y(e,r,o),o},s=(i,e)=>(r,t)=>e(r,t,i);import"../../../../base/common/uri.js";import{ITextModelService as T}from"../../../../editor/common/services/resolverService.js";import{IModelService as w}from"../../../../editor/common/services/model.js";import{DefaultEndOfLine as k,EndOfLinePreference as M}from"../../../../editor/common/model.js";import{ILanguageService as C}from"../../../../editor/common/languages/language.js";import"../../../common/contributions.js";import*as m from"../../../../base/common/marked/marked.js";import{Schemas as P}from"../../../../base/common/network.js";import{Range as R}from"../../../../editor/common/core/range.js";import{createTextBufferFactory as B}from"../../../../editor/common/model/textModel.js";import{assertIsDefined as F}from"../../../../base/common/types.js";import{IInstantiationService as L}from"../../../../platform/instantiation/common/instantiation.js";class b{providers=new Map;registerProvider(e,r){this.providers.set(e,r)}getProvider(e){return this.providers.get(e)}}const W=new b;async function E(i,e){if(!e.query)throw new Error("Walkthrough: invalid resource");const r=JSON.parse(e.query);if(!r.moduleId)throw new Error("Walkthrough: invalid resource");const t=W.getProvider(r.moduleId);if(!t)throw new Error(`Walkthrough: no provider registered for ${r.moduleId}`);return i.invokeFunction(t)}let d=class{constructor(e,r,t,o){this.textModelResolverService=e;this.languageService=r;this.modelService=t;this.instantiationService=o;this.textModelResolverService.registerTextModelContentProvider(P.walkThroughSnippet,this)}static ID="workbench.contrib.walkThroughSnippetContentProvider";loads=new Map;async textBufferFactoryFromResource(e){let r=this.loads.get(e.toString());return r||(r=E(this.instantiationService,e).then(t=>B(t)).finally(()=>this.loads.delete(e.toString())),this.loads.set(e.toString(),r)),r}async provideTextContent(e){const r=await this.textBufferFactoryFromResource(e.with({fragment:""}));let t=this.modelService.getModel(e);if(!t){const o=parseInt(e.fragment);let n=0;const a=new m.marked.Renderer;a.code=({text:h,lang:l})=>{n++;const I=typeof l=="string"&&this.languageService.getLanguageIdByLanguageName(l)||"",p=this.languageService.createById(I),S=this.modelService.createModel(h,p,e.with({fragment:`${n}.${l}`}));return n===o&&(t=S),""};const c=r.create(k.LF).textBuffer,g=c.getLineCount(),v=new R(1,1,g,c.getLineLength(g)+1),u=c.getValueInRange(v,M.TextDefined);m.marked(u,{renderer:a})}return F(t)}};d=f([s(0,T),s(1,C),s(2,w),s(3,L)],d);export{d as WalkThroughSnippetContentProvider,E as moduleToContent,W as walkThroughContentRegistry};
