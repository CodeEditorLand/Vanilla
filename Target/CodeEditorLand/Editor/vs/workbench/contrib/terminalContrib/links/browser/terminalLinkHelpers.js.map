{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/terminalContrib/links/browser/terminalLinkHelpers.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type {\n\tIBuffer,\n\tIBufferCellPosition,\n\tIBufferLine,\n\tIBufferRange,\n\tIViewportRange,\n} from \"@xterm/xterm\";\nimport { type IPath, posix, win32 } from \"../../../../../base/common/path.js\";\nimport { OperatingSystem } from \"../../../../../base/common/platform.js\";\nimport type { IRange } from \"../../../../../editor/common/core/range.js\";\nimport {\n\ttype ITerminalCapabilityStore,\n\tTerminalCapability,\n} from \"../../../../../platform/terminal/common/capabilities/capabilities.js\";\nimport type { ITerminalLogService } from \"../../../../../platform/terminal/common/terminal.js\";\n\n/**\n * Converts a possibly wrapped link's range (comprised of string indices) into a buffer range that plays nicely with xterm.js\n *\n * @param lines A single line (not the entire buffer)\n * @param bufferWidth The number of columns in the terminal\n * @param range The link range - string indices\n * @param startLine The absolute y position (on the buffer) of the line\n */\nexport function convertLinkRangeToBuffer(\n\tlines: IBufferLine[],\n\tbufferWidth: number,\n\trange: IRange,\n\tstartLine: number,\n): IBufferRange {\n\tconst bufferRange: IBufferRange = {\n\t\tstart: {\n\t\t\tx: range.startColumn,\n\t\t\ty: range.startLineNumber + startLine,\n\t\t},\n\t\tend: {\n\t\t\tx: range.endColumn - 1,\n\t\t\ty: range.endLineNumber + startLine,\n\t\t},\n\t};\n\n\t// Shift start range right for each wide character before the link\n\tlet startOffset = 0;\n\tconst startWrappedLineCount = Math.ceil(range.startColumn / bufferWidth);\n\tfor (let y = 0; y < Math.min(startWrappedLineCount); y++) {\n\t\tconst lineLength = Math.min(\n\t\t\tbufferWidth,\n\t\t\trange.startColumn - 1 - y * bufferWidth,\n\t\t);\n\t\tlet lineOffset = 0;\n\t\tconst line = lines[y];\n\t\t// Sanity check for line, apparently this can happen but it's not clear under what\n\t\t// circumstances this happens. Continue on, skipping the remainder of start offset if this\n\t\t// happens to minimize impact.\n\t\tif (!line) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (\n\t\t\tlet x = 0;\n\t\t\tx < Math.min(bufferWidth, lineLength + lineOffset);\n\t\t\tx++\n\t\t) {\n\t\t\tconst cell = line.getCell(x);\n\t\t\t// This is unexpected but it means the character doesn't exist, so we shouldn't add to\n\t\t\t// the offset\n\t\t\tif (!cell) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst width = cell.getWidth();\n\t\t\tif (width === 2) {\n\t\t\t\tlineOffset++;\n\t\t\t}\n\t\t\tconst char = cell.getChars();\n\t\t\tif (char.length > 1) {\n\t\t\t\tlineOffset -= char.length - 1;\n\t\t\t}\n\t\t}\n\t\tstartOffset += lineOffset;\n\t}\n\n\t// Shift end range right for each wide character inside the link\n\tlet endOffset = 0;\n\tconst endWrappedLineCount = Math.ceil(range.endColumn / bufferWidth);\n\tfor (\n\t\tlet y = Math.max(0, startWrappedLineCount - 1);\n\t\ty < endWrappedLineCount;\n\t\ty++\n\t) {\n\t\tconst start =\n\t\t\ty === startWrappedLineCount - 1\n\t\t\t\t? (range.startColumn - 1 + startOffset) % bufferWidth\n\t\t\t\t: 0;\n\t\tconst lineLength = Math.min(\n\t\t\tbufferWidth,\n\t\t\trange.endColumn + startOffset - y * bufferWidth,\n\t\t);\n\t\tlet lineOffset = 0;\n\t\tconst line = lines[y];\n\t\t// Sanity check for line, apparently this can happen but it's not clear under what\n\t\t// circumstances this happens. Continue on, skipping the remainder of start offset if this\n\t\t// happens to minimize impact.\n\t\tif (!line) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (\n\t\t\tlet x = start;\n\t\t\tx < Math.min(bufferWidth, lineLength + lineOffset);\n\t\t\tx++\n\t\t) {\n\t\t\tconst cell = line.getCell(x);\n\t\t\t// This is unexpected but it means the character doesn't exist, so we shouldn't add to\n\t\t\t// the offset\n\t\t\tif (!cell) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst width = cell.getWidth();\n\t\t\tconst chars = cell.getChars();\n\t\t\t// Offset for null cells following wide characters\n\t\t\tif (width === 2) {\n\t\t\t\tlineOffset++;\n\t\t\t}\n\t\t\t// Offset for early wrapping when the last cell in row is a wide character\n\t\t\tif (x === bufferWidth - 1 && chars === \"\") {\n\t\t\t\tlineOffset++;\n\t\t\t}\n\t\t\t// Offset multi-code characters like emoji\n\t\t\tif (chars.length > 1) {\n\t\t\t\tlineOffset -= chars.length - 1;\n\t\t\t}\n\t\t}\n\t\tendOffset += lineOffset;\n\t}\n\n\t// Apply the width character offsets to the result\n\tbufferRange.start.x += startOffset;\n\tbufferRange.end.x += startOffset + endOffset;\n\n\t// Convert back to wrapped lines\n\twhile (bufferRange.start.x > bufferWidth) {\n\t\tbufferRange.start.x -= bufferWidth;\n\t\tbufferRange.start.y++;\n\t}\n\twhile (bufferRange.end.x > bufferWidth) {\n\t\tbufferRange.end.x -= bufferWidth;\n\t\tbufferRange.end.y++;\n\t}\n\n\treturn bufferRange;\n}\n\nexport function convertBufferRangeToViewport(\n\tbufferRange: IBufferRange,\n\tviewportY: number,\n): IViewportRange {\n\treturn {\n\t\tstart: {\n\t\t\tx: bufferRange.start.x - 1,\n\t\t\ty: bufferRange.start.y - viewportY - 1,\n\t\t},\n\t\tend: {\n\t\t\tx: bufferRange.end.x - 1,\n\t\t\ty: bufferRange.end.y - viewportY - 1,\n\t\t},\n\t};\n}\n\nexport function getXtermLineContent(\n\tbuffer: IBuffer,\n\tlineStart: number,\n\tlineEnd: number,\n\tcols: number,\n): string {\n\t// Cap the maximum number of lines generated to prevent potential performance problems. This is\n\t// more of a sanity check as the wrapped line should already be trimmed down at this point.\n\tconst maxLineLength = Math.max(2048, cols * 2);\n\tlineEnd = Math.min(lineEnd, lineStart + maxLineLength);\n\tlet content = \"\";\n\tfor (let i = lineStart; i <= lineEnd; i++) {\n\t\t// Make sure only 0 to cols are considered as resizing when windows mode is enabled will\n\t\t// retain buffer data outside of the terminal width as reflow is disabled.\n\t\tconst line = buffer.getLine(i);\n\t\tif (line) {\n\t\t\tcontent += line.translateToString(true, 0, cols);\n\t\t}\n\t}\n\treturn content;\n}\n\nexport function getXtermRangesByAttr(\n\tbuffer: IBuffer,\n\tlineStart: number,\n\tlineEnd: number,\n\tcols: number,\n): IBufferRange[] {\n\tlet bufferRangeStart: IBufferCellPosition | undefined;\n\tlet lastFgAttr = -1;\n\tlet lastBgAttr = -1;\n\tconst ranges: IBufferRange[] = [];\n\tfor (let y = lineStart; y <= lineEnd; y++) {\n\t\tconst line = buffer.getLine(y);\n\t\tif (!line) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (let x = 0; x < cols; x++) {\n\t\t\tconst cell = line.getCell(x);\n\t\t\tif (!cell) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// HACK: Re-construct the attributes from fg and bg, this is hacky as it relies\n\t\t\t// upon the internal buffer bit layout\n\t\t\tconst thisFgAttr =\n\t\t\t\tcell.isBold() |\n\t\t\t\tcell.isInverse() |\n\t\t\t\tcell.isStrikethrough() |\n\t\t\t\tcell.isUnderline();\n\t\t\tconst thisBgAttr = cell.isDim() | cell.isItalic();\n\t\t\tif (lastFgAttr === -1 || lastBgAttr === -1) {\n\t\t\t\tbufferRangeStart = { x, y };\n\t\t\t} else if (lastFgAttr !== thisFgAttr || lastBgAttr !== thisBgAttr) {\n\t\t\t\t// TODO: x overflow\n\t\t\t\tconst bufferRangeEnd = { x, y };\n\t\t\t\tranges.push({\n\t\t\t\t\tstart: bufferRangeStart!,\n\t\t\t\t\tend: bufferRangeEnd,\n\t\t\t\t});\n\t\t\t\tbufferRangeStart = { x, y };\n\t\t\t}\n\t\t\tlastFgAttr = thisFgAttr;\n\t\t\tlastBgAttr = thisBgAttr;\n\t\t}\n\t}\n\treturn ranges;\n}\n\n// export function positionIsInRange(position: IBufferCellPosition, range: IBufferRange): boolean {\n// \tif (position.y < range.start.y || position.y > range.end.y) {\n// \t\treturn false;\n// \t}\n// \tif (position.y === range.start.y && position.x < range.start.x) {\n// \t\treturn false;\n// \t}\n// \tif (position.y === range.end.y && position.x > range.end.x) {\n// \t\treturn false;\n// \t}\n// \treturn true;\n// }\n\n/**\n * For shells with the CommandDetection capability, the cwd for a command relative to the line of\n * the particular link can be used to narrow down the result for an exact file match.\n */\nexport function updateLinkWithRelativeCwd(\n\tcapabilities: ITerminalCapabilityStore,\n\ty: number,\n\ttext: string,\n\tosPath: IPath,\n\tlogService: ITerminalLogService,\n): string[] | undefined {\n\tconst cwd = capabilities\n\t\t.get(TerminalCapability.CommandDetection)\n\t\t?.getCwdForLine(y);\n\tlogService.trace(\"terminalLinkHelpers#updateLinkWithRelativeCwd cwd\", cwd);\n\tif (!cwd) {\n\t\treturn undefined;\n\t}\n\tconst result: string[] = [];\n\tconst sep = osPath.sep;\n\tif (text.includes(sep)) {\n\t\tlet commonDirs = 0;\n\t\tlet i = 0;\n\t\tconst cwdPath = cwd.split(sep).reverse();\n\t\tconst linkPath = text.split(sep);\n\t\t// Get all results as candidates, prioritizing the link with the most common directories.\n\t\t// For example if in the directory /home/common and the link is common/file, the result\n\t\t// should be: `['/home/common/common/file', '/home/common/file']`. The first is the most\n\t\t// likely as cwd detection is active.\n\t\twhile (i < cwdPath.length) {\n\t\t\tresult.push(\n\t\t\t\tosPath.resolve(\n\t\t\t\t\tcwd + sep + linkPath.slice(commonDirs).join(sep),\n\t\t\t\t),\n\t\t\t);\n\t\t\tif (cwdPath[i] === linkPath[i]) {\n\t\t\t\tcommonDirs++;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\tresult.push(osPath.resolve(cwd + sep + text));\n\t}\n\treturn result;\n}\n\nexport function osPathModule(os: OperatingSystem): IPath {\n\treturn os === OperatingSystem.Windows ? win32 : posix;\n}\n"],
  "mappings": "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",
  "names": []
}
