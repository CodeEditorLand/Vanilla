{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/terminalContrib/links/browser/terminalLocalLinkDetector.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { OS } from '../../../../../base/common/platform.js';\nimport { URI } from '../../../../../base/common/uri.js';\nimport { IUriIdentityService } from '../../../../../platform/uriIdentity/common/uriIdentity.js';\nimport { IWorkspaceContextService } from '../../../../../platform/workspace/common/workspace.js';\nimport { ITerminalLinkDetector, ITerminalLinkResolver, ITerminalSimpleLink, ResolvedLink, TerminalBuiltinLinkType } from './links.js';\nimport { convertLinkRangeToBuffer, getXtermLineContent, getXtermRangesByAttr, osPathModule, updateLinkWithRelativeCwd } from './terminalLinkHelpers.js';\nimport { ITerminalCapabilityStore, TerminalCapability } from '../../../../../platform/terminal/common/capabilities/capabilities.js';\nimport type { IBufferLine, IBufferRange, Terminal } from '@xterm/xterm';\nimport { ITerminalProcessManager } from '../../../terminal/common/terminal.js';\nimport { detectLinks } from './terminalLinkParsing.js';\nimport { ITerminalBackend, ITerminalLogService } from '../../../../../platform/terminal/common/terminal.js';\n\nconst enum Constants {\n\t/**\n\t * The max line length to try extract word links from.\n\t */\n\tMaxLineLength = 2000,\n\n\t/**\n\t * The maximum number of links in a line to resolve against the file system. This limit is put\n\t * in place to avoid sending excessive data when remote connections are in place.\n\t */\n\tMaxResolvedLinksInLine = 10,\n\n\t/**\n\t * The maximum length of a link to resolve against the file system. This limit is put in place\n\t * to avoid sending excessive data when remote connections are in place.\n\t */\n\tMaxResolvedLinkLength = 1024,\n}\n\nconst fallbackMatchers: RegExp[] = [\n\t// Python style error: File \"<path>\", line <line>\n\t/^ *File (?<link>\"(?<path>.+)\"(, line (?<line>\\d+))?)/,\n\t// Unknown tool #200166: FILE  <path>:<line>:<col>\n\t/^ +FILE +(?<link>(?<path>.+)(?::(?<line>\\d+)(?::(?<col>\\d+))?)?)/,\n\t// Some C++ compile error formats:\n\t// C:\\foo\\bar baz(339) : error ...\n\t// C:\\foo\\bar baz(339,12) : error ...\n\t// C:\\foo\\bar baz(339, 12) : error ...\n\t// C:\\foo\\bar baz(339): error ...       [#178584, Visual Studio CL/NVIDIA CUDA compiler]\n\t// C:\\foo\\bar baz(339,12): ...\n\t// C:\\foo\\bar baz(339, 12): ...\n\t/^(?<link>(?<path>.+)\\((?<line>\\d+)(?:, ?(?<col>\\d+))?\\)) ?:/,\n\t// C:\\foo/bar baz:339 : error ...\n\t// C:\\foo/bar baz:339:12 : error ...\n\t// C:\\foo/bar baz:339: error ...\n\t// C:\\foo/bar baz:339:12: error ...     [#178584, Clang]\n\t/^(?<link>(?<path>.+):(?<line>\\d+)(?::(?<col>\\d+))?) ?:/,\n\t// Cmd prompt\n\t/^(?<link>(?<path>.+))>/,\n\t// The whole line is the path\n\t/^ *(?<link>(?<path>.+))/\n];\n\nexport class TerminalLocalLinkDetector implements ITerminalLinkDetector {\n\tstatic id = 'local';\n\n\t// This was chosen as a reasonable maximum line length given the tradeoff between performance\n\t// and how likely it is to encounter such a large line length. Some useful reference points:\n\t// - Window old max length: 260 ($MAX_PATH)\n\t// - Linux max length: 4096 ($PATH_MAX)\n\treadonly maxLinkLength = 500;\n\n\tconstructor(\n\t\treadonly xterm: Terminal,\n\t\tprivate readonly _capabilities: ITerminalCapabilityStore,\n\t\tprivate readonly _processManager: Pick<ITerminalProcessManager, 'initialCwd' | 'os' | 'remoteAuthority' | 'userHome'> & { backend?: Pick<ITerminalBackend, 'getWslPath'> },\n\t\tprivate readonly _linkResolver: ITerminalLinkResolver,\n\t\t@ITerminalLogService private readonly _logService: ITerminalLogService,\n\t\t@IUriIdentityService private readonly _uriIdentityService: IUriIdentityService,\n\t\t@IWorkspaceContextService private readonly _workspaceContextService: IWorkspaceContextService\n\t) {\n\t}\n\n\tasync detect(lines: IBufferLine[], startLine: number, endLine: number): Promise<ITerminalSimpleLink[]> {\n\t\tconst links: ITerminalSimpleLink[] = [];\n\n\t\t// Get the text representation of the wrapped line\n\t\tconst text = getXtermLineContent(this.xterm.buffer.active, startLine, endLine, this.xterm.cols);\n\t\tif (text === '' || text.length > Constants.MaxLineLength) {\n\t\t\treturn [];\n\t\t}\n\n\t\tlet stringIndex = -1;\n\t\tlet resolvedLinkCount = 0;\n\n\t\tconst os = this._processManager.os || OS;\n\t\tconst parsedLinks = detectLinks(text, os);\n\t\tthis._logService.trace('terminalLocalLinkDetector#detect text', text);\n\t\tthis._logService.trace('terminalLocalLinkDetector#detect parsedLinks', parsedLinks);\n\t\tfor (const parsedLink of parsedLinks) {\n\n\t\t\t// Don't try resolve any links of excessive length\n\t\t\tif (parsedLink.path.text.length > Constants.MaxResolvedLinkLength) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Convert the link text's string index into a wrapped buffer range\n\t\t\tconst bufferRange = convertLinkRangeToBuffer(lines, this.xterm.cols, {\n\t\t\t\tstartColumn: (parsedLink.prefix?.index ?? parsedLink.path.index) + 1,\n\t\t\t\tstartLineNumber: 1,\n\t\t\t\tendColumn: parsedLink.path.index + parsedLink.path.text.length + (parsedLink.suffix?.suffix.text.length ?? 0) + 1,\n\t\t\t\tendLineNumber: 1\n\t\t\t}, startLine);\n\n\t\t\t// Get a single link candidate if the cwd of the line is known\n\t\t\tconst linkCandidates: string[] = [];\n\t\t\tconst osPath = osPathModule(os);\n\t\t\tconst isUri = parsedLink.path.text.startsWith('file://');\n\t\t\tif (osPath.isAbsolute(parsedLink.path.text) || parsedLink.path.text.startsWith('~') || isUri) {\n\t\t\t\tlinkCandidates.push(parsedLink.path.text);\n\t\t\t} else {\n\t\t\t\tif (this._capabilities.has(TerminalCapability.CommandDetection)) {\n\t\t\t\t\tconst absolutePath = updateLinkWithRelativeCwd(this._capabilities, bufferRange.start.y, parsedLink.path.text, osPath, this._logService);\n\t\t\t\t\t// Only add a single exact link candidate if the cwd is available, this may cause\n\t\t\t\t\t// the link to not be resolved but that should only occur when the actual file does\n\t\t\t\t\t// not exist. Doing otherwise could cause unexpected results where handling via the\n\t\t\t\t\t// word link detector is preferable.\n\t\t\t\t\tif (absolutePath) {\n\t\t\t\t\t\tlinkCandidates.push(...absolutePath);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Fallback to resolving against the initial cwd, removing any relative directory prefixes\n\t\t\t\tif (linkCandidates.length === 0) {\n\t\t\t\t\tlinkCandidates.push(parsedLink.path.text);\n\t\t\t\t\tif (parsedLink.path.text.match(/^(\\.\\.[\\/\\\\])+/)) {\n\t\t\t\t\t\tlinkCandidates.push(parsedLink.path.text.replace(/^(\\.\\.[\\/\\\\])+/, ''));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If any candidates end with special characters that are likely to not be part of the\n\t\t\t// link, add a candidate excluding them.\n\t\t\tconst specialEndCharRegex = /[\\[\\]\"'\\.]$/;\n\t\t\tconst trimRangeMap: Map<string, number> = new Map();\n\t\t\tconst specialEndLinkCandidates: string[] = [];\n\t\t\tfor (const candidate of linkCandidates) {\n\t\t\t\tlet previous = candidate;\n\t\t\t\tlet removed = previous.replace(specialEndCharRegex, '');\n\t\t\t\tlet trimRange = 0;\n\t\t\t\twhile (removed !== previous) {\n\t\t\t\t\t// Only trim the link if there is no suffix, otherwise the underline would be incorrect\n\t\t\t\t\tif (!parsedLink.suffix) {\n\t\t\t\t\t\ttrimRange++;\n\t\t\t\t\t}\n\t\t\t\t\tspecialEndLinkCandidates.push(removed);\n\t\t\t\t\ttrimRangeMap.set(removed, trimRange);\n\t\t\t\t\tprevious = removed;\n\t\t\t\t\tremoved = removed.replace(specialEndCharRegex, '');\n\t\t\t\t}\n\t\t\t}\n\t\t\tlinkCandidates.push(...specialEndLinkCandidates);\n\t\t\tthis._logService.trace('terminalLocalLinkDetector#detect linkCandidates', linkCandidates);\n\n\t\t\t// Validate the path and convert to the outgoing type\n\t\t\tconst simpleLink = await this._validateAndGetLink(undefined, bufferRange, linkCandidates, trimRangeMap);\n\t\t\tif (simpleLink) {\n\t\t\t\tsimpleLink.parsedLink = parsedLink;\n\t\t\t\tsimpleLink.text = text.substring(\n\t\t\t\t\tparsedLink.prefix?.index ?? parsedLink.path.index,\n\t\t\t\t\tparsedLink.suffix ? parsedLink.suffix.suffix.index + parsedLink.suffix.suffix.text.length : parsedLink.path.index + parsedLink.path.text.length\n\t\t\t\t);\n\t\t\t\tthis._logService.trace('terminalLocalLinkDetector#detect verified link', simpleLink);\n\t\t\t\tlinks.push(simpleLink);\n\t\t\t}\n\n\t\t\t// Stop early if too many links exist in the line\n\t\t\tif (++resolvedLinkCount >= Constants.MaxResolvedLinksInLine) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Match against the fallback matchers which are mainly designed to catch paths with spaces\n\t\t// that aren't possible using the regular mechanism.\n\t\tif (links.length === 0) {\n\t\t\tfor (const matcher of fallbackMatchers) {\n\t\t\t\tconst match = text.match(matcher);\n\t\t\t\tconst group = match?.groups;\n\t\t\t\tif (!group) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst link = group?.link;\n\t\t\t\tconst path = group?.path;\n\t\t\t\tconst line = group?.line;\n\t\t\t\tconst col = group?.col;\n\t\t\t\tif (!link || !path) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Don't try resolve any links of excessive length\n\t\t\t\tif (link.length > Constants.MaxResolvedLinkLength) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Convert the link text's string index into a wrapped buffer range\n\t\t\t\tstringIndex = text.indexOf(link);\n\t\t\t\tconst bufferRange = convertLinkRangeToBuffer(lines, this.xterm.cols, {\n\t\t\t\t\tstartColumn: stringIndex + 1,\n\t\t\t\t\tstartLineNumber: 1,\n\t\t\t\t\tendColumn: stringIndex + link.length + 1,\n\t\t\t\t\tendLineNumber: 1\n\t\t\t\t}, startLine);\n\n\t\t\t\t// Validate and add link\n\t\t\t\tconst suffix = line ? `:${line}${col ? `:${col}` : ''}` : '';\n\t\t\t\tconst simpleLink = await this._validateAndGetLink(`${path}${suffix}`, bufferRange, [path]);\n\t\t\t\tif (simpleLink) {\n\t\t\t\t\tlinks.push(simpleLink);\n\t\t\t\t}\n\n\t\t\t\t// Only match a single fallback matcher\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Sometimes links are styled specially in the terminal like underlined or bolded, try split\n\t\t// the line by attributes and test whether it matches a path\n\t\tif (links.length === 0) {\n\t\t\tconst rangeCandidates = getXtermRangesByAttr(this.xterm.buffer.active, startLine, endLine, this.xterm.cols);\n\t\t\tfor (const rangeCandidate of rangeCandidates) {\n\t\t\t\tlet text = '';\n\t\t\t\tfor (let y = rangeCandidate.start.y; y <= rangeCandidate.end.y; y++) {\n\t\t\t\t\tconst line = this.xterm.buffer.active.getLine(y);\n\t\t\t\t\tif (!line) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst lineStartX = y === rangeCandidate.start.y ? rangeCandidate.start.x : 0;\n\t\t\t\t\tconst lineEndX = y === rangeCandidate.end.y ? rangeCandidate.end.x : this.xterm.cols - 1;\n\t\t\t\t\ttext += line.translateToString(false, lineStartX, lineEndX);\n\t\t\t\t}\n\n\t\t\t\t// HACK: Adjust to 1-based for link API\n\t\t\t\trangeCandidate.start.x++;\n\t\t\t\trangeCandidate.start.y++;\n\t\t\t\trangeCandidate.end.y++;\n\n\t\t\t\t// Validate and add link\n\t\t\t\tconst simpleLink = await this._validateAndGetLink(text, rangeCandidate, [text]);\n\t\t\t\tif (simpleLink) {\n\t\t\t\t\tlinks.push(simpleLink);\n\t\t\t\t}\n\n\t\t\t\t// Stop early if too many links exist in the line\n\t\t\t\tif (++resolvedLinkCount >= Constants.MaxResolvedLinksInLine) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn links;\n\t}\n\n\tprivate _isDirectoryInsideWorkspace(uri: URI) {\n\t\tconst folders = this._workspaceContextService.getWorkspace().folders;\n\t\tfor (let i = 0; i < folders.length; i++) {\n\t\t\tif (this._uriIdentityService.extUri.isEqualOrParent(uri, folders[i].uri)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate async _validateLinkCandidates(linkCandidates: string[]): Promise<ResolvedLink | undefined> {\n\t\tfor (const link of linkCandidates) {\n\t\t\tlet uri: URI | undefined;\n\t\t\tif (link.startsWith('file://')) {\n\t\t\t\turi = URI.parse(link);\n\t\t\t}\n\t\t\tconst result = await this._linkResolver.resolveLink(this._processManager, link, uri);\n\t\t\tif (result) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Validates a set of link candidates and returns a link if validated.\n\t * @param linkText The link text, this should be undefined to use the link stat value\n\t * @param trimRangeMap A map of link candidates to the amount of buffer range they need trimmed.\n\t */\n\tprivate async _validateAndGetLink(linkText: string | undefined, bufferRange: IBufferRange, linkCandidates: string[], trimRangeMap?: Map<string, number>): Promise<ITerminalSimpleLink | undefined> {\n\t\tconst linkStat = await this._validateLinkCandidates(linkCandidates);\n\t\tif (linkStat) {\n\t\t\tlet type: TerminalBuiltinLinkType;\n\t\t\tif (linkStat.isDirectory) {\n\t\t\t\tif (this._isDirectoryInsideWorkspace(linkStat.uri)) {\n\t\t\t\t\ttype = TerminalBuiltinLinkType.LocalFolderInWorkspace;\n\t\t\t\t} else {\n\t\t\t\t\ttype = TerminalBuiltinLinkType.LocalFolderOutsideWorkspace;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttype = TerminalBuiltinLinkType.LocalFile;\n\t\t\t}\n\n\t\t\t// Offset the buffer range if the link range was trimmed\n\t\t\tconst trimRange = trimRangeMap?.get(linkStat.link);\n\t\t\tif (trimRange) {\n\t\t\t\tbufferRange.end.x -= trimRange;\n\t\t\t\tif (bufferRange.end.x < 0) {\n\t\t\t\t\tbufferRange.end.y--;\n\t\t\t\t\tbufferRange.end.x += this.xterm.cols;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\ttext: linkText ?? linkStat.link,\n\t\t\t\turi: linkStat.uri,\n\t\t\t\tbufferRange: bufferRange,\n\t\t\t\ttype\n\t\t\t};\n\t\t}\n\t\treturn undefined;\n\t}\n}\n"],
  "mappings": "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",
  "names": ["Constants", "text"]
}
