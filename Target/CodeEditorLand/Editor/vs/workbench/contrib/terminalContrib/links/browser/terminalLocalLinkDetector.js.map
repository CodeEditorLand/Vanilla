{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/terminalContrib/links/browser/terminalLocalLinkDetector.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { IBufferLine, IBufferRange, Terminal } from \"@xterm/xterm\";\nimport { OS } from \"../../../../../base/common/platform.js\";\nimport { URI } from \"../../../../../base/common/uri.js\";\nimport {\n\ttype ITerminalCapabilityStore,\n\tTerminalCapability,\n} from \"../../../../../platform/terminal/common/capabilities/capabilities.js\";\nimport {\n\ttype ITerminalBackend,\n\tITerminalLogService,\n} from \"../../../../../platform/terminal/common/terminal.js\";\nimport { IUriIdentityService } from \"../../../../../platform/uriIdentity/common/uriIdentity.js\";\nimport { IWorkspaceContextService } from \"../../../../../platform/workspace/common/workspace.js\";\nimport type { ITerminalProcessManager } from \"../../../terminal/common/terminal.js\";\nimport {\n\ttype ITerminalLinkDetector,\n\ttype ITerminalLinkResolver,\n\ttype ITerminalSimpleLink,\n\ttype ResolvedLink,\n\tTerminalBuiltinLinkType,\n} from \"./links.js\";\nimport {\n\tconvertLinkRangeToBuffer,\n\tgetXtermLineContent,\n\tgetXtermRangesByAttr,\n\tosPathModule,\n\tupdateLinkWithRelativeCwd,\n} from \"./terminalLinkHelpers.js\";\nimport { detectLinks } from \"./terminalLinkParsing.js\";\n\nenum Constants {\n\t/**\n\t * The max line length to try extract word links from.\n\t */\n\tMaxLineLength = 2000,\n\n\t/**\n\t * The maximum number of links in a line to resolve against the file system. This limit is put\n\t * in place to avoid sending excessive data when remote connections are in place.\n\t */\n\tMaxResolvedLinksInLine = 10,\n\n\t/**\n\t * The maximum length of a link to resolve against the file system. This limit is put in place\n\t * to avoid sending excessive data when remote connections are in place.\n\t */\n\tMaxResolvedLinkLength = 1024,\n}\n\nconst fallbackMatchers: RegExp[] = [\n\t// Python style error: File \"<path>\", line <line>\n\t/^ *File (?<link>\"(?<path>.+)\"(, line (?<line>\\d+))?)/,\n\t// Unknown tool #200166: FILE  <path>:<line>:<col>\n\t/^ +FILE +(?<link>(?<path>.+)(?::(?<line>\\d+)(?::(?<col>\\d+))?)?)/,\n\t// Some C++ compile error formats:\n\t// C:\\foo\\bar baz(339) : error ...\n\t// C:\\foo\\bar baz(339,12) : error ...\n\t// C:\\foo\\bar baz(339, 12) : error ...\n\t// C:\\foo\\bar baz(339): error ...       [#178584, Visual Studio CL/NVIDIA CUDA compiler]\n\t// C:\\foo\\bar baz(339,12): ...\n\t// C:\\foo\\bar baz(339, 12): ...\n\t/^(?<link>(?<path>.+)\\((?<line>\\d+)(?:, ?(?<col>\\d+))?\\)) ?:/,\n\t// C:\\foo/bar baz:339 : error ...\n\t// C:\\foo/bar baz:339:12 : error ...\n\t// C:\\foo/bar baz:339: error ...\n\t// C:\\foo/bar baz:339:12: error ...     [#178584, Clang]\n\t/^(?<link>(?<path>.+):(?<line>\\d+)(?::(?<col>\\d+))?) ?:/,\n\t// Cmd prompt\n\t/^(?<link>(?<path>.+))>/,\n\t// The whole line is the path\n\t/^ *(?<link>(?<path>.+))/,\n];\n\nexport class TerminalLocalLinkDetector implements ITerminalLinkDetector {\n\tstatic id = \"local\";\n\n\t// This was chosen as a reasonable maximum line length given the tradeoff between performance\n\t// and how likely it is to encounter such a large line length. Some useful reference points:\n\t// - Window old max length: 260 ($MAX_PATH)\n\t// - Linux max length: 4096 ($PATH_MAX)\n\treadonly maxLinkLength = 500;\n\n\tconstructor(\n\t\treadonly xterm: Terminal,\n\t\tprivate readonly _capabilities: ITerminalCapabilityStore,\n\t\tprivate readonly _processManager: Pick<ITerminalProcessManager, 'initialCwd' | 'os' | 'remoteAuthority' | 'userHome'> & { backend?: Pick<ITerminalBackend, 'getWslPath'> },\n\t\tprivate readonly _linkResolver: ITerminalLinkResolver,\n\t\t@ITerminalLogService private readonly _logService: ITerminalLogService,\n\t\t@IUriIdentityService private readonly _uriIdentityService: IUriIdentityService,\n\t\t@IWorkspaceContextService private readonly _workspaceContextService: IWorkspaceContextService\n\t) {\n\t}\n\n\tasync detect(\n\t\tlines: IBufferLine[],\n\t\tstartLine: number,\n\t\tendLine: number,\n\t): Promise<ITerminalSimpleLink[]> {\n\t\tconst links: ITerminalSimpleLink[] = [];\n\n\t\t// Get the text representation of the wrapped line\n\t\tconst text = getXtermLineContent(\n\t\t\tthis.xterm.buffer.active,\n\t\t\tstartLine,\n\t\t\tendLine,\n\t\t\tthis.xterm.cols,\n\t\t);\n\t\tif (text === \"\" || text.length > Constants.MaxLineLength) {\n\t\t\treturn [];\n\t\t}\n\n\t\tlet stringIndex = -1;\n\t\tlet resolvedLinkCount = 0;\n\n\t\tconst os = this._processManager.os || OS;\n\t\tconst parsedLinks = detectLinks(text, os);\n\t\tthis._logService.trace(\"terminalLocalLinkDetector#detect text\", text);\n\t\tthis._logService.trace(\n\t\t\t\"terminalLocalLinkDetector#detect parsedLinks\",\n\t\t\tparsedLinks,\n\t\t);\n\t\tfor (const parsedLink of parsedLinks) {\n\t\t\t// Don't try resolve any links of excessive length\n\t\t\tif (parsedLink.path.text.length > Constants.MaxResolvedLinkLength) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Convert the link text's string index into a wrapped buffer range\n\t\t\tconst bufferRange = convertLinkRangeToBuffer(\n\t\t\t\tlines,\n\t\t\t\tthis.xterm.cols,\n\t\t\t\t{\n\t\t\t\t\tstartColumn:\n\t\t\t\t\t\t(parsedLink.prefix?.index ?? parsedLink.path.index) + 1,\n\t\t\t\t\tstartLineNumber: 1,\n\t\t\t\t\tendColumn:\n\t\t\t\t\t\tparsedLink.path.index +\n\t\t\t\t\t\tparsedLink.path.text.length +\n\t\t\t\t\t\t(parsedLink.suffix?.suffix.text.length ?? 0) +\n\t\t\t\t\t\t1,\n\t\t\t\t\tendLineNumber: 1,\n\t\t\t\t},\n\t\t\t\tstartLine,\n\t\t\t);\n\n\t\t\t// Get a single link candidate if the cwd of the line is known\n\t\t\tconst linkCandidates: string[] = [];\n\t\t\tconst osPath = osPathModule(os);\n\t\t\tconst isUri = parsedLink.path.text.startsWith(\"file://\");\n\t\t\tif (\n\t\t\t\tosPath.isAbsolute(parsedLink.path.text) ||\n\t\t\t\tparsedLink.path.text.startsWith(\"~\") ||\n\t\t\t\tisUri\n\t\t\t) {\n\t\t\t\tlinkCandidates.push(parsedLink.path.text);\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tthis._capabilities.has(TerminalCapability.CommandDetection)\n\t\t\t\t) {\n\t\t\t\t\tconst absolutePath = updateLinkWithRelativeCwd(\n\t\t\t\t\t\tthis._capabilities,\n\t\t\t\t\t\tbufferRange.start.y,\n\t\t\t\t\t\tparsedLink.path.text,\n\t\t\t\t\t\tosPath,\n\t\t\t\t\t\tthis._logService,\n\t\t\t\t\t);\n\t\t\t\t\t// Only add a single exact link candidate if the cwd is available, this may cause\n\t\t\t\t\t// the link to not be resolved but that should only occur when the actual file does\n\t\t\t\t\t// not exist. Doing otherwise could cause unexpected results where handling via the\n\t\t\t\t\t// word link detector is preferable.\n\t\t\t\t\tif (absolutePath) {\n\t\t\t\t\t\tlinkCandidates.push(...absolutePath);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Fallback to resolving against the initial cwd, removing any relative directory prefixes\n\t\t\t\tif (linkCandidates.length === 0) {\n\t\t\t\t\tlinkCandidates.push(parsedLink.path.text);\n\t\t\t\t\tif (parsedLink.path.text.match(/^(\\.\\.[/\\\\])+/)) {\n\t\t\t\t\t\tlinkCandidates.push(\n\t\t\t\t\t\t\tparsedLink.path.text.replace(/^(\\.\\.[/\\\\])+/, \"\"),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If any candidates end with special characters that are likely to not be part of the\n\t\t\t// link, add a candidate excluding them.\n\t\t\tconst specialEndCharRegex = /[[\\]\"'.]$/;\n\t\t\tconst trimRangeMap: Map<string, number> = new Map();\n\t\t\tconst specialEndLinkCandidates: string[] = [];\n\t\t\tfor (const candidate of linkCandidates) {\n\t\t\t\tlet previous = candidate;\n\t\t\t\tlet removed = previous.replace(specialEndCharRegex, \"\");\n\t\t\t\tlet trimRange = 0;\n\t\t\t\twhile (removed !== previous) {\n\t\t\t\t\t// Only trim the link if there is no suffix, otherwise the underline would be incorrect\n\t\t\t\t\tif (!parsedLink.suffix) {\n\t\t\t\t\t\ttrimRange++;\n\t\t\t\t\t}\n\t\t\t\t\tspecialEndLinkCandidates.push(removed);\n\t\t\t\t\ttrimRangeMap.set(removed, trimRange);\n\t\t\t\t\tprevious = removed;\n\t\t\t\t\tremoved = removed.replace(specialEndCharRegex, \"\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tlinkCandidates.push(...specialEndLinkCandidates);\n\t\t\tthis._logService.trace(\n\t\t\t\t\"terminalLocalLinkDetector#detect linkCandidates\",\n\t\t\t\tlinkCandidates,\n\t\t\t);\n\n\t\t\t// Validate the path and convert to the outgoing type\n\t\t\tconst simpleLink = await this._validateAndGetLink(\n\t\t\t\tundefined,\n\t\t\t\tbufferRange,\n\t\t\t\tlinkCandidates,\n\t\t\t\ttrimRangeMap,\n\t\t\t);\n\t\t\tif (simpleLink) {\n\t\t\t\tsimpleLink.parsedLink = parsedLink;\n\t\t\t\tsimpleLink.text = text.substring(\n\t\t\t\t\tparsedLink.prefix?.index ?? parsedLink.path.index,\n\t\t\t\t\tparsedLink.suffix\n\t\t\t\t\t\t? parsedLink.suffix.suffix.index +\n\t\t\t\t\t\t\t\tparsedLink.suffix.suffix.text.length\n\t\t\t\t\t\t: parsedLink.path.index + parsedLink.path.text.length,\n\t\t\t\t);\n\t\t\t\tthis._logService.trace(\n\t\t\t\t\t\"terminalLocalLinkDetector#detect verified link\",\n\t\t\t\t\tsimpleLink,\n\t\t\t\t);\n\t\t\t\tlinks.push(simpleLink);\n\t\t\t}\n\n\t\t\t// Stop early if too many links exist in the line\n\t\t\tif (++resolvedLinkCount >= Constants.MaxResolvedLinksInLine) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Match against the fallback matchers which are mainly designed to catch paths with spaces\n\t\t// that aren't possible using the regular mechanism.\n\t\tif (links.length === 0) {\n\t\t\tfor (const matcher of fallbackMatchers) {\n\t\t\t\tconst match = text.match(matcher);\n\t\t\t\tconst group = match?.groups;\n\t\t\t\tif (!group) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst link = group?.link;\n\t\t\t\tconst path = group?.path;\n\t\t\t\tconst line = group?.line;\n\t\t\t\tconst col = group?.col;\n\t\t\t\tif (!link || !path) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Don't try resolve any links of excessive length\n\t\t\t\tif (link.length > Constants.MaxResolvedLinkLength) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Convert the link text's string index into a wrapped buffer range\n\t\t\t\tstringIndex = text.indexOf(link);\n\t\t\t\tconst bufferRange = convertLinkRangeToBuffer(\n\t\t\t\t\tlines,\n\t\t\t\t\tthis.xterm.cols,\n\t\t\t\t\t{\n\t\t\t\t\t\tstartColumn: stringIndex + 1,\n\t\t\t\t\t\tstartLineNumber: 1,\n\t\t\t\t\t\tendColumn: stringIndex + link.length + 1,\n\t\t\t\t\t\tendLineNumber: 1,\n\t\t\t\t\t},\n\t\t\t\t\tstartLine,\n\t\t\t\t);\n\n\t\t\t\t// Validate and add link\n\t\t\t\tconst suffix = line ? `:${line}${col ? `:${col}` : \"\"}` : \"\";\n\t\t\t\tconst simpleLink = await this._validateAndGetLink(\n\t\t\t\t\t`${path}${suffix}`,\n\t\t\t\t\tbufferRange,\n\t\t\t\t\t[path],\n\t\t\t\t);\n\t\t\t\tif (simpleLink) {\n\t\t\t\t\tlinks.push(simpleLink);\n\t\t\t\t}\n\n\t\t\t\t// Only match a single fallback matcher\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Sometimes links are styled specially in the terminal like underlined or bolded, try split\n\t\t// the line by attributes and test whether it matches a path\n\t\tif (links.length === 0) {\n\t\t\tconst rangeCandidates = getXtermRangesByAttr(\n\t\t\t\tthis.xterm.buffer.active,\n\t\t\t\tstartLine,\n\t\t\t\tendLine,\n\t\t\t\tthis.xterm.cols,\n\t\t\t);\n\t\t\tfor (const rangeCandidate of rangeCandidates) {\n\t\t\t\tlet text = \"\";\n\t\t\t\tfor (\n\t\t\t\t\tlet y = rangeCandidate.start.y;\n\t\t\t\t\ty <= rangeCandidate.end.y;\n\t\t\t\t\ty++\n\t\t\t\t) {\n\t\t\t\t\tconst line = this.xterm.buffer.active.getLine(y);\n\t\t\t\t\tif (!line) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst lineStartX =\n\t\t\t\t\t\ty === rangeCandidate.start.y\n\t\t\t\t\t\t\t? rangeCandidate.start.x\n\t\t\t\t\t\t\t: 0;\n\t\t\t\t\tconst lineEndX =\n\t\t\t\t\t\ty === rangeCandidate.end.y\n\t\t\t\t\t\t\t? rangeCandidate.end.x\n\t\t\t\t\t\t\t: this.xterm.cols - 1;\n\t\t\t\t\ttext += line.translateToString(false, lineStartX, lineEndX);\n\t\t\t\t}\n\n\t\t\t\t// HACK: Adjust to 1-based for link API\n\t\t\t\trangeCandidate.start.x++;\n\t\t\t\trangeCandidate.start.y++;\n\t\t\t\trangeCandidate.end.y++;\n\n\t\t\t\t// Validate and add link\n\t\t\t\tconst simpleLink = await this._validateAndGetLink(\n\t\t\t\t\ttext,\n\t\t\t\t\trangeCandidate,\n\t\t\t\t\t[text],\n\t\t\t\t);\n\t\t\t\tif (simpleLink) {\n\t\t\t\t\tlinks.push(simpleLink);\n\t\t\t\t}\n\n\t\t\t\t// Stop early if too many links exist in the line\n\t\t\t\tif (++resolvedLinkCount >= Constants.MaxResolvedLinksInLine) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn links;\n\t}\n\n\tprivate _isDirectoryInsideWorkspace(uri: URI) {\n\t\tconst folders = this._workspaceContextService.getWorkspace().folders;\n\t\tfor (let i = 0; i < folders.length; i++) {\n\t\t\tif (\n\t\t\t\tthis._uriIdentityService.extUri.isEqualOrParent(\n\t\t\t\t\turi,\n\t\t\t\t\tfolders[i].uri,\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate async _validateLinkCandidates(\n\t\tlinkCandidates: string[],\n\t): Promise<ResolvedLink | undefined> {\n\t\tfor (const link of linkCandidates) {\n\t\t\tlet uri: URI | undefined;\n\t\t\tif (link.startsWith(\"file://\")) {\n\t\t\t\turi = URI.parse(link);\n\t\t\t}\n\t\t\tconst result = await this._linkResolver.resolveLink(\n\t\t\t\tthis._processManager,\n\t\t\t\tlink,\n\t\t\t\turi,\n\t\t\t);\n\t\t\tif (result) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Validates a set of link candidates and returns a link if validated.\n\t * @param linkText The link text, this should be undefined to use the link stat value\n\t * @param trimRangeMap A map of link candidates to the amount of buffer range they need trimmed.\n\t */\n\tprivate async _validateAndGetLink(\n\t\tlinkText: string | undefined,\n\t\tbufferRange: IBufferRange,\n\t\tlinkCandidates: string[],\n\t\ttrimRangeMap?: Map<string, number>,\n\t): Promise<ITerminalSimpleLink | undefined> {\n\t\tconst linkStat = await this._validateLinkCandidates(linkCandidates);\n\t\tif (linkStat) {\n\t\t\tlet type: TerminalBuiltinLinkType;\n\t\t\tif (linkStat.isDirectory) {\n\t\t\t\tif (this._isDirectoryInsideWorkspace(linkStat.uri)) {\n\t\t\t\t\ttype = TerminalBuiltinLinkType.LocalFolderInWorkspace;\n\t\t\t\t} else {\n\t\t\t\t\ttype = TerminalBuiltinLinkType.LocalFolderOutsideWorkspace;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttype = TerminalBuiltinLinkType.LocalFile;\n\t\t\t}\n\n\t\t\t// Offset the buffer range if the link range was trimmed\n\t\t\tconst trimRange = trimRangeMap?.get(linkStat.link);\n\t\t\tif (trimRange) {\n\t\t\t\tbufferRange.end.x -= trimRange;\n\t\t\t\tif (bufferRange.end.x < 0) {\n\t\t\t\t\tbufferRange.end.y--;\n\t\t\t\t\tbufferRange.end.x += this.xterm.cols;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\ttext: linkText ?? linkStat.link,\n\t\t\t\turi: linkStat.uri,\n\t\t\t\tbufferRange: bufferRange,\n\t\t\t\ttype,\n\t\t\t};\n\t\t}\n\t\treturn undefined;\n\t}\n}\n"],
  "mappings": "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",
  "names": ["Constants", "text"]
}
