{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/terminalContrib/links/browser/terminalLinkParsing.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * This module is responsible for parsing possible links out of lines with only access to the line\n * text and the target operating system, ie. it does not do any validation that paths actually\n * exist.\n */\n\nimport { Lazy } from \"../../../../../base/common/lazy.js\";\nimport { OperatingSystem } from \"../../../../../base/common/platform.js\";\n\nexport interface IParsedLink {\n\tpath: ILinkPartialRange;\n\tprefix?: ILinkPartialRange;\n\tsuffix?: ILinkSuffix;\n}\n\nexport interface ILinkSuffix {\n\trow: number | undefined;\n\tcol: number | undefined;\n\trowEnd: number | undefined;\n\tcolEnd: number | undefined;\n\tsuffix: ILinkPartialRange;\n}\n\nexport interface ILinkPartialRange {\n\tindex: number;\n\ttext: string;\n}\n\n/**\n * A regex that extracts the link suffix which contains line and column information. The link suffix\n * must terminate at the end of line.\n */\nconst linkSuffixRegexEol = new Lazy<RegExp>(() =>\n\tgenerateLinkSuffixRegex(true),\n);\n/**\n * A regex that extracts the link suffix which contains line and column information.\n */\nconst linkSuffixRegex = new Lazy<RegExp>(() => generateLinkSuffixRegex(false));\n\nfunction generateLinkSuffixRegex(eolOnly: boolean) {\n\tlet ri = 0;\n\tlet ci = 0;\n\tlet rei = 0;\n\tlet cei = 0;\n\tfunction r(): string {\n\t\treturn `(?<row${ri++}>\\\\d+)`;\n\t}\n\tfunction c(): string {\n\t\treturn `(?<col${ci++}>\\\\d+)`;\n\t}\n\tfunction re(): string {\n\t\treturn `(?<rowEnd${rei++}>\\\\d+)`;\n\t}\n\tfunction ce(): string {\n\t\treturn `(?<colEnd${cei++}>\\\\d+)`;\n\t}\n\n\tconst eolSuffix = eolOnly ? \"$\" : \"\";\n\n\t// The comments in the regex below use real strings/numbers for better readability, here's\n\t// the legend:\n\t// - Path    = foo\n\t// - Row     = 339\n\t// - Col     = 12\n\t// - RowEnd  = 341\n\t// - ColEnd  = 789\n\t//\n\t// These all support single quote ' in the place of \" and [] in the place of ()\n\t//\n\t// See the tests for an exhaustive list of all supported formats\n\tconst lineAndColumnRegexClauses = [\n\t\t// foo:339\n\t\t// foo:339:12\n\t\t// foo:339:12-789\n\t\t// foo:339:12-341.789\n\t\t// foo:339.12\n\t\t// foo 339\n\t\t// foo 339:12                              [#140780]\n\t\t// foo 339.12\n\t\t// foo#339\n\t\t// foo#339:12                              [#190288]\n\t\t// foo#339.12\n\t\t// \"foo\",339\n\t\t// \"foo\",339:12\n\t\t// \"foo\",339.12\n\t\t// \"foo\",339.12-789\n\t\t// \"foo\",339.12-341.789\n\t\t`(?::|#| |['\"],)${r()}([:.]${c()}(?:-(?:${re()}\\\\.)?${ce()})?)?` +\n\t\t\teolSuffix,\n\t\t// The quotes below are optional           [#171652]\n\t\t// \"foo\", line 339                         [#40468]\n\t\t// \"foo\", line 339, col 12\n\t\t// \"foo\", line 339, column 12\n\t\t// \"foo\":line 339\n\t\t// \"foo\":line 339, col 12\n\t\t// \"foo\":line 339, column 12\n\t\t// \"foo\": line 339\n\t\t// \"foo\": line 339, col 12\n\t\t// \"foo\": line 339, column 12\n\t\t// \"foo\" on line 339\n\t\t// \"foo\" on line 339, col 12\n\t\t// \"foo\" on line 339, column 12\n\t\t// \"foo\" line 339 column 12\n\t\t// \"foo\", line 339, character 12           [#171880]\n\t\t// \"foo\", line 339, characters 12-789      [#171880]\n\t\t// \"foo\", lines 339-341                    [#171880]\n\t\t// \"foo\", lines 339-341, characters 12-789 [#178287]\n\t\t`['\"]?(?:,? |: ?| on )lines? ${r()}(?:-${re()})?(?:,? (?:col(?:umn)?|characters?) ${c()}(?:-${ce()})?)?` +\n\t\t\teolSuffix,\n\t\t// foo(339)\n\t\t// foo(339,12)\n\t\t// foo(339, 12)\n\t\t// foo (339)\n\t\t//   ...\n\t\t// foo: (339)\n\t\t//   ...\n\t\t`:? ?[\\\\[\\\\(]${r()}(?:, ?${c()})?[\\\\]\\\\)]` + eolSuffix,\n\t];\n\n\tconst suffixClause = lineAndColumnRegexClauses\n\t\t// Join all clauses together\n\t\t.join(\"|\")\n\t\t// Convert spaces to allow the non-breaking space char (ascii 160)\n\t\t.replace(/ /g, `[${\"\\u00A0\"} ]`);\n\n\treturn new RegExp(`(${suffixClause})`, eolOnly ? undefined : \"g\");\n}\n\n/**\n * Removes the optional link suffix which contains line and column information.\n * @param link The link to use.\n */\nexport function removeLinkSuffix(link: string): string {\n\tconst suffix = getLinkSuffix(link)?.suffix;\n\tif (!suffix) {\n\t\treturn link;\n\t}\n\treturn link.substring(0, suffix.index);\n}\n\n/**\n * Removes any query string from the link.\n * @param link The link to use.\n */\nexport function removeLinkQueryString(link: string): string {\n\t// Skip ? in UNC paths\n\tconst start = link.startsWith(\"\\\\\\\\?\\\\\") ? 4 : 0;\n\tconst index = link.indexOf(\"?\", start);\n\tif (index === -1) {\n\t\treturn link;\n\t}\n\treturn link.substring(0, index);\n}\n\nexport function detectLinkSuffixes(line: string): ILinkSuffix[] {\n\t// Find all suffixes on the line. Since the regex global flag is used, lastIndex will be updated\n\t// in place such that there are no overlapping matches.\n\tlet match: RegExpExecArray | null;\n\tconst results: ILinkSuffix[] = [];\n\tlinkSuffixRegex.value.lastIndex = 0;\n\twhile ((match = linkSuffixRegex.value.exec(line)) !== null) {\n\t\tconst suffix = toLinkSuffix(match);\n\t\tif (suffix === null) {\n\t\t\tbreak;\n\t\t}\n\t\tresults.push(suffix);\n\t}\n\treturn results;\n}\n\n/**\n * Returns the optional link suffix which contains line and column information.\n * @param link The link to parse.\n */\nexport function getLinkSuffix(link: string): ILinkSuffix | null {\n\treturn toLinkSuffix(linkSuffixRegexEol.value.exec(link));\n}\n\nexport function toLinkSuffix(\n\tmatch: RegExpExecArray | null,\n): ILinkSuffix | null {\n\tconst groups = match?.groups;\n\tif (!groups || match.length < 1) {\n\t\treturn null;\n\t}\n\treturn {\n\t\trow: parseIntOptional(groups.row0 || groups.row1 || groups.row2),\n\t\tcol: parseIntOptional(groups.col0 || groups.col1 || groups.col2),\n\t\trowEnd: parseIntOptional(\n\t\t\tgroups.rowEnd0 || groups.rowEnd1 || groups.rowEnd2,\n\t\t),\n\t\tcolEnd: parseIntOptional(\n\t\t\tgroups.colEnd0 || groups.colEnd1 || groups.colEnd2,\n\t\t),\n\t\tsuffix: { index: match.index, text: match[0] },\n\t};\n}\n\nfunction parseIntOptional(value: string | undefined): number | undefined {\n\tif (value === undefined) {\n\t\treturn value;\n\t}\n\treturn Number.parseInt(value);\n}\n\n// This defines valid path characters for a link with a suffix, the first `[]` of the regex includes\n// characters the path is not allowed to _start_ with, the second `[]` includes characters not\n// allowed at all in the path. If the characters show up in both regexes the link will stop at that\n// character, otherwise it will stop at a space character.\nconst linkWithSuffixPathCharacters =\n\t/(?<path>(?:file:\\/\\/\\/)?[^\\s|<>[({][^\\s|<>]*)$/;\n\nexport function detectLinks(line: string, os: OperatingSystem) {\n\t// 1: Detect all links on line via suffixes first\n\tconst results = detectLinksViaSuffix(line);\n\n\t// 2: Detect all links without suffixes and merge non-conflicting ranges into the results\n\tconst noSuffixPaths = detectPathsNoSuffix(line, os);\n\tbinaryInsertList(results, noSuffixPaths);\n\n\treturn results;\n}\n\nfunction binaryInsertList(list: IParsedLink[], newItems: IParsedLink[]) {\n\tif (list.length === 0) {\n\t\tlist.push(...newItems);\n\t}\n\tfor (const item of newItems) {\n\t\tbinaryInsert(list, item, 0, list.length);\n\t}\n}\n\nfunction binaryInsert(\n\tlist: IParsedLink[],\n\tnewItem: IParsedLink,\n\tlow: number,\n\thigh: number,\n) {\n\tif (list.length === 0) {\n\t\tlist.push(newItem);\n\t\treturn;\n\t}\n\tif (low > high) {\n\t\treturn;\n\t}\n\t// Find the index where the newItem would be inserted\n\tconst mid = Math.floor((low + high) / 2);\n\tif (\n\t\tmid >= list.length ||\n\t\t(newItem.path.index < list[mid].path.index &&\n\t\t\t(mid === 0 || newItem.path.index > list[mid - 1].path.index))\n\t) {\n\t\t// Check if it conflicts with an existing link before adding\n\t\tif (\n\t\t\tmid >= list.length ||\n\t\t\t(newItem.path.index + newItem.path.text.length <\n\t\t\t\tlist[mid].path.index &&\n\t\t\t\t(mid === 0 ||\n\t\t\t\t\tnewItem.path.index >\n\t\t\t\t\t\tlist[mid - 1].path.index +\n\t\t\t\t\t\t\tlist[mid - 1].path.text.length))\n\t\t) {\n\t\t\tlist.splice(mid, 0, newItem);\n\t\t}\n\t\treturn;\n\t}\n\tif (newItem.path.index > list[mid].path.index) {\n\t\tbinaryInsert(list, newItem, mid + 1, high);\n\t} else {\n\t\tbinaryInsert(list, newItem, low, mid - 1);\n\t}\n}\n\nfunction detectLinksViaSuffix(line: string): IParsedLink[] {\n\tconst results: IParsedLink[] = [];\n\n\t// 1: Detect link suffixes on the line\n\tconst suffixes = detectLinkSuffixes(line);\n\tfor (const suffix of suffixes) {\n\t\tconst beforeSuffix = line.substring(0, suffix.suffix.index);\n\t\tconst possiblePathMatch = beforeSuffix.match(\n\t\t\tlinkWithSuffixPathCharacters,\n\t\t);\n\t\tif (\n\t\t\tpossiblePathMatch &&\n\t\t\tpossiblePathMatch.index !== undefined &&\n\t\t\tpossiblePathMatch.groups?.path\n\t\t) {\n\t\t\tlet linkStartIndex = possiblePathMatch.index;\n\t\t\tlet path = possiblePathMatch.groups.path;\n\t\t\t// Extract a path prefix if it exists (not part of the path, but part of the underlined\n\t\t\t// section)\n\t\t\tlet prefix: ILinkPartialRange | undefined;\n\t\t\tconst prefixMatch = path.match(/^(?<prefix>['\"]+)/);\n\t\t\tif (prefixMatch?.groups?.prefix) {\n\t\t\t\tprefix = {\n\t\t\t\t\tindex: linkStartIndex,\n\t\t\t\t\ttext: prefixMatch.groups.prefix,\n\t\t\t\t};\n\t\t\t\tpath = path.substring(prefix.text.length);\n\n\t\t\t\t// Don't allow suffix links to be returned when the link itself is the empty string\n\t\t\t\tif (path.trim().length === 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// If there are multiple characters in the prefix, trim the prefix if the _first_\n\t\t\t\t// suffix character is the same as the last prefix character. For example, for the\n\t\t\t\t// text `echo \"'foo' on line 1\"`:\n\t\t\t\t//\n\t\t\t\t// - Prefix='\n\t\t\t\t// - Path=foo\n\t\t\t\t// - Suffix=' on line 1\n\t\t\t\t//\n\t\t\t\t// If this fails on a multi-character prefix, just keep the original.\n\t\t\t\tif (prefixMatch.groups.prefix.length > 1) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tsuffix.suffix.text[0].match(/['\"]/) &&\n\t\t\t\t\t\tprefixMatch.groups.prefix[\n\t\t\t\t\t\t\tprefixMatch.groups.prefix.length - 1\n\t\t\t\t\t\t] === suffix.suffix.text[0]\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst trimPrefixAmount =\n\t\t\t\t\t\t\tprefixMatch.groups.prefix.length - 1;\n\t\t\t\t\t\tprefix.index += trimPrefixAmount;\n\t\t\t\t\t\tprefix.text =\n\t\t\t\t\t\t\tprefixMatch.groups.prefix[\n\t\t\t\t\t\t\t\tprefixMatch.groups.prefix.length - 1\n\t\t\t\t\t\t\t];\n\t\t\t\t\t\tlinkStartIndex += trimPrefixAmount;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tresults.push({\n\t\t\t\tpath: {\n\t\t\t\t\tindex: linkStartIndex + (prefix?.text.length || 0),\n\t\t\t\t\ttext: path,\n\t\t\t\t},\n\t\t\t\tprefix,\n\t\t\t\tsuffix,\n\t\t\t});\n\t\t}\n\t}\n\n\treturn results;\n}\n\nenum RegexPathConstants {\n\tPathPrefix = \"(?:\\\\.\\\\.?|\\\\~|file://)\",\n\tPathSeparatorClause = \"\\\\/\",\n\t// '\":; are allowed in paths but they are often separators so ignore them\n\t// Also disallow \\\\ to prevent a catastropic backtracking case #24795\n\tExcludedPathCharactersClause = \"[^\\\\0<>\\\\?\\\\s!`&*()'\\\":;\\\\\\\\]\",\n\tExcludedStartPathCharactersClause = \"[^\\\\0<>\\\\?\\\\s!`&*()\\\\[\\\\]'\\\":;\\\\\\\\]\",\n\n\tWinOtherPathPrefix = \"\\\\.\\\\.?|\\\\~\",\n\tWinPathSeparatorClause = \"(?:\\\\\\\\|\\\\/)\",\n\tWinExcludedPathCharactersClause = \"[^\\\\0<>\\\\?\\\\|\\\\/\\\\s!`&*()'\\\":;]\",\n\tWinExcludedStartPathCharactersClause = \"[^\\\\0<>\\\\?\\\\|\\\\/\\\\s!`&*()\\\\[\\\\]'\\\":;]\",\n}\n\n/**\n * A regex that matches non-Windows paths, such as `/foo`, `~/foo`, `./foo`, `../foo` and\n * `foo/bar`.\n */\nconst unixLocalLinkClause =\n\t\"(?:(?:\" +\n\tRegexPathConstants.PathPrefix +\n\t\"|(?:\" +\n\tRegexPathConstants.ExcludedStartPathCharactersClause +\n\tRegexPathConstants.ExcludedPathCharactersClause +\n\t\"*))?(?:\" +\n\tRegexPathConstants.PathSeparatorClause +\n\t\"(?:\" +\n\tRegexPathConstants.ExcludedPathCharactersClause +\n\t\")+)+)\";\n\n/**\n * A regex clause that matches the start of an absolute path on Windows, such as: `C:`, `c:`,\n * `file:///c:` (uri) and `\\\\?\\C:` (UNC path).\n */\nexport const winDrivePrefix = \"(?:\\\\\\\\\\\\\\\\\\\\?\\\\\\\\|file:\\\\/\\\\/\\\\/)?[a-zA-Z]:\";\n\n/**\n * A regex that matches Windows paths, such as `\\\\?\\c:\\foo`, `c:\\foo`, `~\\foo`, `.\\foo`, `..\\foo`\n * and `foo\\bar`.\n */\nconst winLocalLinkClause =\n\t\"(?:(?:\" +\n\t`(?:${winDrivePrefix}|${RegexPathConstants.WinOtherPathPrefix})` +\n\t\"|(?:\" +\n\tRegexPathConstants.WinExcludedStartPathCharactersClause +\n\tRegexPathConstants.WinExcludedPathCharactersClause +\n\t\"*))?(?:\" +\n\tRegexPathConstants.WinPathSeparatorClause +\n\t\"(?:\" +\n\tRegexPathConstants.WinExcludedPathCharactersClause +\n\t\")+)+)\";\n\nfunction detectPathsNoSuffix(line: string, os: OperatingSystem): IParsedLink[] {\n\tconst results: IParsedLink[] = [];\n\n\tconst regex = new RegExp(\n\t\tos === OperatingSystem.Windows\n\t\t\t? winLocalLinkClause\n\t\t\t: unixLocalLinkClause,\n\t\t\"g\",\n\t);\n\tlet match;\n\twhile ((match = regex.exec(line)) !== null) {\n\t\tlet text = match[0];\n\t\tlet index = match.index;\n\t\tif (!text) {\n\t\t\t// Something matched but does not comply with the given match index, since this would\n\t\t\t// most likely a bug the regex itself we simply do nothing here\n\t\t\tbreak;\n\t\t}\n\n\t\t// Adjust the link range to exclude a/ and b/ if it looks like a git diff\n\t\tif (\n\t\t\t// --- a/foo/bar\n\t\t\t// +++ b/foo/bar\n\t\t\t((line.startsWith(\"--- a/\") || line.startsWith(\"+++ b/\")) &&\n\t\t\t\tindex === 4) ||\n\t\t\t// diff --git a/foo/bar b/foo/bar\n\t\t\t(line.startsWith(\"diff --git\") &&\n\t\t\t\t(text.startsWith(\"a/\") || text.startsWith(\"b/\")))\n\t\t) {\n\t\t\ttext = text.substring(2);\n\t\t\tindex += 2;\n\t\t}\n\n\t\tresults.push({\n\t\t\tpath: {\n\t\t\t\tindex,\n\t\t\t\ttext,\n\t\t\t},\n\t\t\tprefix: undefined,\n\t\t\tsuffix: undefined,\n\t\t});\n\t}\n\n\treturn results;\n}\n"],
  "mappings": ";;AAWA,SAAS,YAAY;AACrB,SAAS,uBAAuB;AAyBhC,MAAM,qBAAqB,IAAI;AAAA,EAAa,MAC3C,wBAAwB,IAAI;AAC7B;AAIA,MAAM,kBAAkB,IAAI,KAAa,MAAM,wBAAwB,KAAK,CAAC;AAE7E,SAAS,wBAAwB,SAAkB;AAClD,MAAI,KAAK;AACT,MAAI,KAAK;AACT,MAAI,MAAM;AACV,MAAI,MAAM;AACV,WAAS,IAAY;AACpB,WAAO,SAAS,IAAI;AAAA,EACrB;AAFS;AAGT,WAAS,IAAY;AACpB,WAAO,SAAS,IAAI;AAAA,EACrB;AAFS;AAGT,WAAS,KAAa;AACrB,WAAO,YAAY,KAAK;AAAA,EACzB;AAFS;AAGT,WAAS,KAAa;AACrB,WAAO,YAAY,KAAK;AAAA,EACzB;AAFS;AAIT,QAAM,YAAY,UAAU,MAAM;AAalC,QAAM,4BAA4B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAiBjC,kBAAkB,EAAE,CAAC,QAAQ,EAAE,CAAC,UAAU,GAAG,CAAC,QAAQ,GAAG,CAAC,SACzD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAmBD,+BAA+B,EAAE,CAAC,OAAO,GAAG,CAAC,uCAAuC,EAAE,CAAC,OAAO,GAAG,CAAC,SACjG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAQD,eAAe,EAAE,CAAC,SAAS,EAAE,CAAC,eAAe;AAAA,EAC9C;AAEA,QAAM,eAAe,0BAEnB,KAAK,GAAG,EAER,QAAQ,MAAM,IAAI,MAAQ,IAAI;AAEhC,SAAO,IAAI,OAAO,IAAI,YAAY,KAAK,UAAU,SAAY,GAAG;AACjE;AAvFS;AA6FF,SAAS,iBAAiB,MAAsB;AACtD,QAAM,SAAS,cAAc,IAAI,GAAG;AACpC,MAAI,CAAC,QAAQ;AACZ,WAAO;AAAA,EACR;AACA,SAAO,KAAK,UAAU,GAAG,OAAO,KAAK;AACtC;AANgB;AAYT,SAAS,sBAAsB,MAAsB;AAE3D,QAAM,QAAQ,KAAK,WAAW,SAAS,IAAI,IAAI;AAC/C,QAAM,QAAQ,KAAK,QAAQ,KAAK,KAAK;AACrC,MAAI,UAAU,IAAI;AACjB,WAAO;AAAA,EACR;AACA,SAAO,KAAK,UAAU,GAAG,KAAK;AAC/B;AARgB;AAUT,SAAS,mBAAmB,MAA6B;AAG/D,MAAI;AACJ,QAAM,UAAyB,CAAC;AAChC,kBAAgB,MAAM,YAAY;AAClC,UAAQ,QAAQ,gBAAgB,MAAM,KAAK,IAAI,OAAO,MAAM;AAC3D,UAAM,SAAS,aAAa,KAAK;AACjC,QAAI,WAAW,MAAM;AACpB;AAAA,IACD;AACA,YAAQ,KAAK,MAAM;AAAA,EACpB;AACA,SAAO;AACR;AAdgB;AAoBT,SAAS,cAAc,MAAkC;AAC/D,SAAO,aAAa,mBAAmB,MAAM,KAAK,IAAI,CAAC;AACxD;AAFgB;AAIT,SAAS,aACf,OACqB;AACrB,QAAM,SAAS,OAAO;AACtB,MAAI,CAAC,UAAU,MAAM,SAAS,GAAG;AAChC,WAAO;AAAA,EACR;AACA,SAAO;AAAA,IACN,KAAK,iBAAiB,OAAO,QAAQ,OAAO,QAAQ,OAAO,IAAI;AAAA,IAC/D,KAAK,iBAAiB,OAAO,QAAQ,OAAO,QAAQ,OAAO,IAAI;AAAA,IAC/D,QAAQ;AAAA,MACP,OAAO,WAAW,OAAO,WAAW,OAAO;AAAA,IAC5C;AAAA,IACA,QAAQ;AAAA,MACP,OAAO,WAAW,OAAO,WAAW,OAAO;AAAA,IAC5C;AAAA,IACA,QAAQ,EAAE,OAAO,MAAM,OAAO,MAAM,MAAM,CAAC,EAAE;AAAA,EAC9C;AACD;AAlBgB;AAoBhB,SAAS,iBAAiB,OAA+C;AACxE,MAAI,UAAU,QAAW;AACxB,WAAO;AAAA,EACR;AACA,SAAO,OAAO,SAAS,KAAK;AAC7B;AALS;AAWT,MAAM,+BACL;AAEM,SAAS,YAAY,MAAc,IAAqB;AAE9D,QAAM,UAAU,qBAAqB,IAAI;AAGzC,QAAM,gBAAgB,oBAAoB,MAAM,EAAE;AAClD,mBAAiB,SAAS,aAAa;AAEvC,SAAO;AACR;AATgB;AAWhB,SAAS,iBAAiB,MAAqB,UAAyB;AACvE,MAAI,KAAK,WAAW,GAAG;AACtB,SAAK,KAAK,GAAG,QAAQ;AAAA,EACtB;AACA,aAAW,QAAQ,UAAU;AAC5B,iBAAa,MAAM,MAAM,GAAG,KAAK,MAAM;AAAA,EACxC;AACD;AAPS;AAST,SAAS,aACR,MACA,SACA,KACA,MACC;AACD,MAAI,KAAK,WAAW,GAAG;AACtB,SAAK,KAAK,OAAO;AACjB;AAAA,EACD;AACA,MAAI,MAAM,MAAM;AACf;AAAA,EACD;AAEA,QAAM,MAAM,KAAK,OAAO,MAAM,QAAQ,CAAC;AACvC,MACC,OAAO,KAAK,UACX,QAAQ,KAAK,QAAQ,KAAK,GAAG,EAAE,KAAK,UACnC,QAAQ,KAAK,QAAQ,KAAK,QAAQ,KAAK,MAAM,CAAC,EAAE,KAAK,QACtD;AAED,QACC,OAAO,KAAK,UACX,QAAQ,KAAK,QAAQ,QAAQ,KAAK,KAAK,SACvC,KAAK,GAAG,EAAE,KAAK,UACd,QAAQ,KACR,QAAQ,KAAK,QACZ,KAAK,MAAM,CAAC,EAAE,KAAK,QAClB,KAAK,MAAM,CAAC,EAAE,KAAK,KAAK,SAC3B;AACD,WAAK,OAAO,KAAK,GAAG,OAAO;AAAA,IAC5B;AACA;AAAA,EACD;AACA,MAAI,QAAQ,KAAK,QAAQ,KAAK,GAAG,EAAE,KAAK,OAAO;AAC9C,iBAAa,MAAM,SAAS,MAAM,GAAG,IAAI;AAAA,EAC1C,OAAO;AACN,iBAAa,MAAM,SAAS,KAAK,MAAM,CAAC;AAAA,EACzC;AACD;AAvCS;AAyCT,SAAS,qBAAqB,MAA6B;AAC1D,QAAM,UAAyB,CAAC;AAGhC,QAAM,WAAW,mBAAmB,IAAI;AACxC,aAAW,UAAU,UAAU;AAC9B,UAAM,eAAe,KAAK,UAAU,GAAG,OAAO,OAAO,KAAK;AAC1D,UAAM,oBAAoB,aAAa;AAAA,MACtC;AAAA,IACD;AACA,QACC,qBACA,kBAAkB,UAAU,UAC5B,kBAAkB,QAAQ,MACzB;AACD,UAAI,iBAAiB,kBAAkB;AACvC,UAAI,OAAO,kBAAkB,OAAO;AAGpC,UAAI;AACJ,YAAM,cAAc,KAAK,MAAM,mBAAmB;AAClD,UAAI,aAAa,QAAQ,QAAQ;AAChC,iBAAS;AAAA,UACR,OAAO;AAAA,UACP,MAAM,YAAY,OAAO;AAAA,QAC1B;AACA,eAAO,KAAK,UAAU,OAAO,KAAK,MAAM;AAGxC,YAAI,KAAK,KAAK,EAAE,WAAW,GAAG;AAC7B;AAAA,QACD;AAWA,YAAI,YAAY,OAAO,OAAO,SAAS,GAAG;AACzC,cACC,OAAO,OAAO,KAAK,CAAC,EAAE,MAAM,MAAM,KAClC,YAAY,OAAO,OAClB,YAAY,OAAO,OAAO,SAAS,CACpC,MAAM,OAAO,OAAO,KAAK,CAAC,GACzB;AACD,kBAAM,mBACL,YAAY,OAAO,OAAO,SAAS;AACpC,mBAAO,SAAS;AAChB,mBAAO,OACN,YAAY,OAAO,OAClB,YAAY,OAAO,OAAO,SAAS,CACpC;AACD,8BAAkB;AAAA,UACnB;AAAA,QACD;AAAA,MACD;AACA,cAAQ,KAAK;AAAA,QACZ,MAAM;AAAA,UACL,OAAO,kBAAkB,QAAQ,KAAK,UAAU;AAAA,UAChD,MAAM;AAAA,QACP;AAAA,QACA;AAAA,QACA;AAAA,MACD,CAAC;AAAA,IACF;AAAA,EACD;AAEA,SAAO;AACR;AAxES;AA0ET,IAAK,qBAAL,kBAAKA,wBAAL;AACC,EAAAA,oBAAA,gBAAa;AACb,EAAAA,oBAAA,yBAAsB;AAGtB,EAAAA,oBAAA,kCAA+B;AAC/B,EAAAA,oBAAA,uCAAoC;AAEpC,EAAAA,oBAAA,wBAAqB;AACrB,EAAAA,oBAAA,4BAAyB;AACzB,EAAAA,oBAAA,qCAAkC;AAClC,EAAAA,oBAAA,0CAAuC;AAXnC,SAAAA;AAAA,GAAA;AAkBL,MAAM,sBACL;AAeM,MAAM,iBAAiB;AAM9B,MAAM,qBACL,YACM,cAAc,IAAI,sCAAqC;AAU9D,SAAS,oBAAoB,MAAc,IAAoC;AAC9E,QAAM,UAAyB,CAAC;AAEhC,QAAM,QAAQ,IAAI;AAAA,IACjB,OAAO,gBAAgB,UACpB,qBACA;AAAA,IACH;AAAA,EACD;AACA,MAAI;AACJ,UAAQ,QAAQ,MAAM,KAAK,IAAI,OAAO,MAAM;AAC3C,QAAI,OAAO,MAAM,CAAC;AAClB,QAAI,QAAQ,MAAM;AAClB,QAAI,CAAC,MAAM;AAGV;AAAA,IACD;AAGA;AAAA;AAAA;AAAA,OAGG,KAAK,WAAW,QAAQ,KAAK,KAAK,WAAW,QAAQ,MACtD,UAAU;AAAA,MAEV,KAAK,WAAW,YAAY,MAC3B,KAAK,WAAW,IAAI,KAAK,KAAK,WAAW,IAAI;AAAA,MAC9C;AACD,aAAO,KAAK,UAAU,CAAC;AACvB,eAAS;AAAA,IACV;AAEA,YAAQ,KAAK;AAAA,MACZ,MAAM;AAAA,QACL;AAAA,QACA;AAAA,MACD;AAAA,MACA,QAAQ;AAAA,MACR,QAAQ;AAAA,IACT,CAAC;AAAA,EACF;AAEA,SAAO;AACR;AA5CS;",
  "names": ["RegexPathConstants"]
}
