{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/terminalContrib/links/browser/terminalLinkParsing.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * This module is responsible for parsing possible links out of lines with only access to the line\n * text and the target operating system, ie. it does not do any validation that paths actually\n * exist.\n */\n\nimport { Lazy } from '../../../../../base/common/lazy.js';\nimport { OperatingSystem } from '../../../../../base/common/platform.js';\n\nexport interface IParsedLink {\n\tpath: ILinkPartialRange;\n\tprefix?: ILinkPartialRange;\n\tsuffix?: ILinkSuffix;\n}\n\nexport interface ILinkSuffix {\n\trow: number | undefined;\n\tcol: number | undefined;\n\trowEnd: number | undefined;\n\tcolEnd: number | undefined;\n\tsuffix: ILinkPartialRange;\n}\n\nexport interface ILinkPartialRange {\n\tindex: number;\n\ttext: string;\n}\n\n/**\n * A regex that extracts the link suffix which contains line and column information. The link suffix\n * must terminate at the end of line.\n */\nconst linkSuffixRegexEol = new Lazy<RegExp>(() => generateLinkSuffixRegex(true));\n/**\n * A regex that extracts the link suffix which contains line and column information.\n */\nconst linkSuffixRegex = new Lazy<RegExp>(() => generateLinkSuffixRegex(false));\n\nfunction generateLinkSuffixRegex(eolOnly: boolean) {\n\tlet ri = 0;\n\tlet ci = 0;\n\tlet rei = 0;\n\tlet cei = 0;\n\tfunction r(): string {\n\t\treturn `(?<row${ri++}>\\\\d+)`;\n\t}\n\tfunction c(): string {\n\t\treturn `(?<col${ci++}>\\\\d+)`;\n\t}\n\tfunction re(): string {\n\t\treturn `(?<rowEnd${rei++}>\\\\d+)`;\n\t}\n\tfunction ce(): string {\n\t\treturn `(?<colEnd${cei++}>\\\\d+)`;\n\t}\n\n\tconst eolSuffix = eolOnly ? '$' : '';\n\n\t// The comments in the regex below use real strings/numbers for better readability, here's\n\t// the legend:\n\t// - Path    = foo\n\t// - Row     = 339\n\t// - Col     = 12\n\t// - RowEnd  = 341\n\t// - ColEnd  = 789\n\t//\n\t// These all support single quote ' in the place of \" and [] in the place of ()\n\t//\n\t// See the tests for an exhaustive list of all supported formats\n\tconst lineAndColumnRegexClauses = [\n\t\t// foo:339\n\t\t// foo:339:12\n\t\t// foo:339:12-789\n\t\t// foo:339:12-341.789\n\t\t// foo:339.12\n\t\t// foo 339\n\t\t// foo 339:12                              [#140780]\n\t\t// foo 339.12\n\t\t// foo#339\n\t\t// foo#339:12                              [#190288]\n\t\t// foo#339.12\n\t\t// \"foo\",339\n\t\t// \"foo\",339:12\n\t\t// \"foo\",339.12\n\t\t// \"foo\",339.12-789\n\t\t// \"foo\",339.12-341.789\n\t\t`(?::|#| |['\"],)${r()}([:.]${c()}(?:-(?:${re()}\\\\.)?${ce()})?)?` + eolSuffix,\n\t\t// The quotes below are optional           [#171652]\n\t\t// \"foo\", line 339                         [#40468]\n\t\t// \"foo\", line 339, col 12\n\t\t// \"foo\", line 339, column 12\n\t\t// \"foo\":line 339\n\t\t// \"foo\":line 339, col 12\n\t\t// \"foo\":line 339, column 12\n\t\t// \"foo\": line 339\n\t\t// \"foo\": line 339, col 12\n\t\t// \"foo\": line 339, column 12\n\t\t// \"foo\" on line 339\n\t\t// \"foo\" on line 339, col 12\n\t\t// \"foo\" on line 339, column 12\n\t\t// \"foo\" line 339 column 12\n\t\t// \"foo\", line 339, character 12           [#171880]\n\t\t// \"foo\", line 339, characters 12-789      [#171880]\n\t\t// \"foo\", lines 339-341                    [#171880]\n\t\t// \"foo\", lines 339-341, characters 12-789 [#178287]\n\t\t`['\"]?(?:,? |: ?| on )lines? ${r()}(?:-${re()})?(?:,? (?:col(?:umn)?|characters?) ${c()}(?:-${ce()})?)?` + eolSuffix,\n\t\t// foo(339)\n\t\t// foo(339,12)\n\t\t// foo(339, 12)\n\t\t// foo (339)\n\t\t//   ...\n\t\t// foo: (339)\n\t\t//   ...\n\t\t`:? ?[\\\\[\\\\(]${r()}(?:, ?${c()})?[\\\\]\\\\)]` + eolSuffix,\n\t];\n\n\tconst suffixClause = lineAndColumnRegexClauses\n\t\t// Join all clauses together\n\t\t.join('|')\n\t\t// Convert spaces to allow the non-breaking space char (ascii 160)\n\t\t.replace(/ /g, `[${'\\u00A0'} ]`);\n\n\treturn new RegExp(`(${suffixClause})`, eolOnly ? undefined : 'g');\n}\n\n/**\n * Removes the optional link suffix which contains line and column information.\n * @param link The link to use.\n */\nexport function removeLinkSuffix(link: string): string {\n\tconst suffix = getLinkSuffix(link)?.suffix;\n\tif (!suffix) {\n\t\treturn link;\n\t}\n\treturn link.substring(0, suffix.index);\n}\n\n/**\n * Removes any query string from the link.\n * @param link The link to use.\n */\nexport function removeLinkQueryString(link: string): string {\n\t// Skip ? in UNC paths\n\tconst start = link.startsWith('\\\\\\\\?\\\\') ? 4 : 0;\n\tconst index = link.indexOf('?', start);\n\tif (index === -1) {\n\t\treturn link;\n\t}\n\treturn link.substring(0, index);\n}\n\nexport function detectLinkSuffixes(line: string): ILinkSuffix[] {\n\t// Find all suffixes on the line. Since the regex global flag is used, lastIndex will be updated\n\t// in place such that there are no overlapping matches.\n\tlet match: RegExpExecArray | null;\n\tconst results: ILinkSuffix[] = [];\n\tlinkSuffixRegex.value.lastIndex = 0;\n\twhile ((match = linkSuffixRegex.value.exec(line)) !== null) {\n\t\tconst suffix = toLinkSuffix(match);\n\t\tif (suffix === null) {\n\t\t\tbreak;\n\t\t}\n\t\tresults.push(suffix);\n\t}\n\treturn results;\n}\n\n/**\n * Returns the optional link suffix which contains line and column information.\n * @param link The link to parse.\n */\nexport function getLinkSuffix(link: string): ILinkSuffix | null {\n\treturn toLinkSuffix(linkSuffixRegexEol.value.exec(link));\n}\n\nexport function toLinkSuffix(match: RegExpExecArray | null): ILinkSuffix | null {\n\tconst groups = match?.groups;\n\tif (!groups || match.length < 1) {\n\t\treturn null;\n\t}\n\treturn {\n\t\trow: parseIntOptional(groups.row0 || groups.row1 || groups.row2),\n\t\tcol: parseIntOptional(groups.col0 || groups.col1 || groups.col2),\n\t\trowEnd: parseIntOptional(groups.rowEnd0 || groups.rowEnd1 || groups.rowEnd2),\n\t\tcolEnd: parseIntOptional(groups.colEnd0 || groups.colEnd1 || groups.colEnd2),\n\t\tsuffix: { index: match.index, text: match[0] }\n\t};\n}\n\nfunction parseIntOptional(value: string | undefined): number | undefined {\n\tif (value === undefined) {\n\t\treturn value;\n\t}\n\treturn parseInt(value);\n}\n\n// This defines valid path characters for a link with a suffix, the first `[]` of the regex includes\n// characters the path is not allowed to _start_ with, the second `[]` includes characters not\n// allowed at all in the path. If the characters show up in both regexes the link will stop at that\n// character, otherwise it will stop at a space character.\nconst linkWithSuffixPathCharacters = /(?<path>(?:file:\\/\\/\\/)?[^\\s\\|<>\\[\\({][^\\s\\|<>]*)$/;\n\nexport function detectLinks(line: string, os: OperatingSystem) {\n\t// 1: Detect all links on line via suffixes first\n\tconst results = detectLinksViaSuffix(line);\n\n\t// 2: Detect all links without suffixes and merge non-conflicting ranges into the results\n\tconst noSuffixPaths = detectPathsNoSuffix(line, os);\n\tbinaryInsertList(results, noSuffixPaths);\n\n\treturn results;\n}\n\nfunction binaryInsertList(list: IParsedLink[], newItems: IParsedLink[]) {\n\tif (list.length === 0) {\n\t\tlist.push(...newItems);\n\t}\n\tfor (const item of newItems) {\n\t\tbinaryInsert(list, item, 0, list.length);\n\t}\n}\n\nfunction binaryInsert(list: IParsedLink[], newItem: IParsedLink, low: number, high: number) {\n\tif (list.length === 0) {\n\t\tlist.push(newItem);\n\t\treturn;\n\t}\n\tif (low > high) {\n\t\treturn;\n\t}\n\t// Find the index where the newItem would be inserted\n\tconst mid = Math.floor((low + high) / 2);\n\tif (\n\t\tmid >= list.length ||\n\t\t(newItem.path.index < list[mid].path.index && (mid === 0 || newItem.path.index > list[mid - 1].path.index))\n\t) {\n\t\t// Check if it conflicts with an existing link before adding\n\t\tif (\n\t\t\tmid >= list.length ||\n\t\t\t(newItem.path.index + newItem.path.text.length < list[mid].path.index && (mid === 0 || newItem.path.index > list[mid - 1].path.index + list[mid - 1].path.text.length))\n\t\t) {\n\t\t\tlist.splice(mid, 0, newItem);\n\t\t}\n\t\treturn;\n\t}\n\tif (newItem.path.index > list[mid].path.index) {\n\t\tbinaryInsert(list, newItem, mid + 1, high);\n\t} else {\n\t\tbinaryInsert(list, newItem, low, mid - 1);\n\t}\n}\n\nfunction detectLinksViaSuffix(line: string): IParsedLink[] {\n\tconst results: IParsedLink[] = [];\n\n\t// 1: Detect link suffixes on the line\n\tconst suffixes = detectLinkSuffixes(line);\n\tfor (const suffix of suffixes) {\n\t\tconst beforeSuffix = line.substring(0, suffix.suffix.index);\n\t\tconst possiblePathMatch = beforeSuffix.match(linkWithSuffixPathCharacters);\n\t\tif (possiblePathMatch && possiblePathMatch.index !== undefined && possiblePathMatch.groups?.path) {\n\t\t\tlet linkStartIndex = possiblePathMatch.index;\n\t\t\tlet path = possiblePathMatch.groups.path;\n\t\t\t// Extract a path prefix if it exists (not part of the path, but part of the underlined\n\t\t\t// section)\n\t\t\tlet prefix: ILinkPartialRange | undefined = undefined;\n\t\t\tconst prefixMatch = path.match(/^(?<prefix>['\"]+)/);\n\t\t\tif (prefixMatch?.groups?.prefix) {\n\t\t\t\tprefix = {\n\t\t\t\t\tindex: linkStartIndex,\n\t\t\t\t\ttext: prefixMatch.groups.prefix\n\t\t\t\t};\n\t\t\t\tpath = path.substring(prefix.text.length);\n\n\t\t\t\t// Don't allow suffix links to be returned when the link itself is the empty string\n\t\t\t\tif (path.trim().length === 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// If there are multiple characters in the prefix, trim the prefix if the _first_\n\t\t\t\t// suffix character is the same as the last prefix character. For example, for the\n\t\t\t\t// text `echo \"'foo' on line 1\"`:\n\t\t\t\t//\n\t\t\t\t// - Prefix='\n\t\t\t\t// - Path=foo\n\t\t\t\t// - Suffix=' on line 1\n\t\t\t\t//\n\t\t\t\t// If this fails on a multi-character prefix, just keep the original.\n\t\t\t\tif (prefixMatch.groups.prefix.length > 1) {\n\t\t\t\t\tif (suffix.suffix.text[0].match(/['\"]/) && prefixMatch.groups.prefix[prefixMatch.groups.prefix.length - 1] === suffix.suffix.text[0]) {\n\t\t\t\t\t\tconst trimPrefixAmount = prefixMatch.groups.prefix.length - 1;\n\t\t\t\t\t\tprefix.index += trimPrefixAmount;\n\t\t\t\t\t\tprefix.text = prefixMatch.groups.prefix[prefixMatch.groups.prefix.length - 1];\n\t\t\t\t\t\tlinkStartIndex += trimPrefixAmount;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tresults.push({\n\t\t\t\tpath: {\n\t\t\t\t\tindex: linkStartIndex + (prefix?.text.length || 0),\n\t\t\t\t\ttext: path\n\t\t\t\t},\n\t\t\t\tprefix,\n\t\t\t\tsuffix\n\t\t\t});\n\t\t}\n\t}\n\n\treturn results;\n}\n\nenum RegexPathConstants {\n\tPathPrefix = '(?:\\\\.\\\\.?|\\\\~|file:\\/\\/)',\n\tPathSeparatorClause = '\\\\/',\n\t// '\":; are allowed in paths but they are often separators so ignore them\n\t// Also disallow \\\\ to prevent a catastropic backtracking case #24795\n\tExcludedPathCharactersClause = '[^\\\\0<>\\\\?\\\\s!`&*()\\'\":;\\\\\\\\]',\n\tExcludedStartPathCharactersClause = '[^\\\\0<>\\\\?\\\\s!`&*()\\\\[\\\\]\\'\":;\\\\\\\\]',\n\n\tWinOtherPathPrefix = '\\\\.\\\\.?|\\\\~',\n\tWinPathSeparatorClause = '(?:\\\\\\\\|\\\\/)',\n\tWinExcludedPathCharactersClause = '[^\\\\0<>\\\\?\\\\|\\\\/\\\\s!`&*()\\'\":;]',\n\tWinExcludedStartPathCharactersClause = '[^\\\\0<>\\\\?\\\\|\\\\/\\\\s!`&*()\\\\[\\\\]\\'\":;]',\n}\n\n/**\n * A regex that matches non-Windows paths, such as `/foo`, `~/foo`, `./foo`, `../foo` and\n * `foo/bar`.\n */\nconst unixLocalLinkClause = '(?:(?:' + RegexPathConstants.PathPrefix + '|(?:' + RegexPathConstants.ExcludedStartPathCharactersClause + RegexPathConstants.ExcludedPathCharactersClause + '*))?(?:' + RegexPathConstants.PathSeparatorClause + '(?:' + RegexPathConstants.ExcludedPathCharactersClause + ')+)+)';\n\n/**\n * A regex clause that matches the start of an absolute path on Windows, such as: `C:`, `c:`,\n * `file:///c:` (uri) and `\\\\?\\C:` (UNC path).\n */\nexport const winDrivePrefix = '(?:\\\\\\\\\\\\\\\\\\\\?\\\\\\\\|file:\\\\/\\\\/\\\\/)?[a-zA-Z]:';\n\n/**\n * A regex that matches Windows paths, such as `\\\\?\\c:\\foo`, `c:\\foo`, `~\\foo`, `.\\foo`, `..\\foo`\n * and `foo\\bar`.\n */\nconst winLocalLinkClause = '(?:(?:' + `(?:${winDrivePrefix}|${RegexPathConstants.WinOtherPathPrefix})` + '|(?:' + RegexPathConstants.WinExcludedStartPathCharactersClause + RegexPathConstants.WinExcludedPathCharactersClause + '*))?(?:' + RegexPathConstants.WinPathSeparatorClause + '(?:' + RegexPathConstants.WinExcludedPathCharactersClause + ')+)+)';\n\nfunction detectPathsNoSuffix(line: string, os: OperatingSystem): IParsedLink[] {\n\tconst results: IParsedLink[] = [];\n\n\tconst regex = new RegExp(os === OperatingSystem.Windows ? winLocalLinkClause : unixLocalLinkClause, 'g');\n\tlet match;\n\twhile ((match = regex.exec(line)) !== null) {\n\t\tlet text = match[0];\n\t\tlet index = match.index;\n\t\tif (!text) {\n\t\t\t// Something matched but does not comply with the given match index, since this would\n\t\t\t// most likely a bug the regex itself we simply do nothing here\n\t\t\tbreak;\n\t\t}\n\n\t\t// Adjust the link range to exclude a/ and b/ if it looks like a git diff\n\t\tif (\n\t\t\t// --- a/foo/bar\n\t\t\t// +++ b/foo/bar\n\t\t\t((line.startsWith('--- a/') || line.startsWith('+++ b/')) && index === 4) ||\n\t\t\t// diff --git a/foo/bar b/foo/bar\n\t\t\t(line.startsWith('diff --git') && (text.startsWith('a/') || text.startsWith('b/')))\n\t\t) {\n\t\t\ttext = text.substring(2);\n\t\t\tindex += 2;\n\t\t}\n\n\t\tresults.push({\n\t\t\tpath: {\n\t\t\t\tindex,\n\t\t\t\ttext\n\t\t\t},\n\t\t\tprefix: undefined,\n\t\t\tsuffix: undefined\n\t\t});\n\t}\n\n\treturn results;\n}\n"],
  "mappings": "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",
  "names": ["RegexPathConstants"]
}
