{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/terminalContrib/links/browser/terminalWordLinkDetector.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { IBufferLine, Terminal } from \"@xterm/xterm\";\nimport { Disposable } from \"../../../../../base/common/lifecycle.js\";\nimport { matchesScheme } from \"../../../../../base/common/network.js\";\nimport { escapeRegExpCharacters } from \"../../../../../base/common/strings.js\";\nimport { URI } from \"../../../../../base/common/uri.js\";\nimport { IConfigurationService } from \"../../../../../platform/configuration/common/configuration.js\";\nimport { IProductService } from \"../../../../../platform/product/common/productService.js\";\nimport { TerminalSettingId } from \"../../../../../platform/terminal/common/terminal.js\";\nimport {\n\ttype ITerminalConfiguration,\n\tTERMINAL_CONFIG_SECTION,\n} from \"../../../terminal/common/terminal.js\";\nimport {\n\ttype ITerminalLinkDetector,\n\ttype ITerminalSimpleLink,\n\tTerminalBuiltinLinkType,\n} from \"./links.js\";\nimport {\n\tconvertLinkRangeToBuffer,\n\tgetXtermLineContent,\n} from \"./terminalLinkHelpers.js\";\n\nenum Constants {\n\t/**\n\t * The max line length to try extract word links from.\n\t */\n\tMaxLineLength = 2000,\n}\n\ninterface Word {\n\tstartIndex: number;\n\tendIndex: number;\n\ttext: string;\n}\n\nexport class TerminalWordLinkDetector\n\textends Disposable\n\timplements ITerminalLinkDetector\n{\n\tstatic id = \"word\";\n\n\t// Word links typically search the workspace so it makes sense that their maximum link length is\n\t// quite small.\n\treadonly maxLinkLength = 100;\n\n\tprivate _separatorRegex!: RegExp;\n\n\tconstructor(\n\t\treadonly xterm: Terminal,\n\t\t@IConfigurationService\n\t\tprivate readonly _configurationService: IConfigurationService,\n\t\t@IProductService private readonly _productService: IProductService,\n\t) {\n\t\tsuper();\n\n\t\tthis._refreshSeparatorCodes();\n\t\tthis._register(\n\t\t\tthis._configurationService.onDidChangeConfiguration((e) => {\n\t\t\t\tif (e.affectsConfiguration(TerminalSettingId.WordSeparators)) {\n\t\t\t\t\tthis._refreshSeparatorCodes();\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\t}\n\n\tdetect(\n\t\tlines: IBufferLine[],\n\t\tstartLine: number,\n\t\tendLine: number,\n\t): ITerminalSimpleLink[] {\n\t\tconst links: ITerminalSimpleLink[] = [];\n\n\t\t// Get the text representation of the wrapped line\n\t\tconst text = getXtermLineContent(\n\t\t\tthis.xterm.buffer.active,\n\t\t\tstartLine,\n\t\t\tendLine,\n\t\t\tthis.xterm.cols,\n\t\t);\n\t\tif (text === \"\" || text.length > Constants.MaxLineLength) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// Parse out all words from the wrapped line\n\t\tconst words: Word[] = this._parseWords(text);\n\n\t\t// Map the words to ITerminalLink objects\n\t\tfor (const word of words) {\n\t\t\tif (word.text === \"\") {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (\n\t\t\t\tword.text.length > 0 &&\n\t\t\t\tword.text.charAt(word.text.length - 1) === \":\"\n\t\t\t) {\n\t\t\t\tword.text = word.text.slice(0, -1);\n\t\t\t\tword.endIndex--;\n\t\t\t}\n\t\t\tconst bufferRange = convertLinkRangeToBuffer(\n\t\t\t\tlines,\n\t\t\t\tthis.xterm.cols,\n\t\t\t\t{\n\t\t\t\t\tstartColumn: word.startIndex + 1,\n\t\t\t\t\tstartLineNumber: 1,\n\t\t\t\t\tendColumn: word.endIndex + 1,\n\t\t\t\t\tendLineNumber: 1,\n\t\t\t\t},\n\t\t\t\tstartLine,\n\t\t\t);\n\n\t\t\t// Support this product's URL protocol\n\t\t\tif (matchesScheme(word.text, this._productService.urlProtocol)) {\n\t\t\t\tconst uri = URI.parse(word.text);\n\t\t\t\tif (uri) {\n\t\t\t\t\tlinks.push({\n\t\t\t\t\t\ttext: word.text,\n\t\t\t\t\t\turi,\n\t\t\t\t\t\tbufferRange,\n\t\t\t\t\t\ttype: TerminalBuiltinLinkType.Url,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Search links\n\t\t\tlinks.push({\n\t\t\t\ttext: word.text,\n\t\t\t\tbufferRange,\n\t\t\t\ttype: TerminalBuiltinLinkType.Search,\n\t\t\t\tcontextLine: text,\n\t\t\t});\n\t\t}\n\n\t\treturn links;\n\t}\n\n\tprivate _parseWords(text: string): Word[] {\n\t\tconst words: Word[] = [];\n\t\tconst splitWords = text.split(this._separatorRegex);\n\t\tlet runningIndex = 0;\n\t\tfor (let i = 0; i < splitWords.length; i++) {\n\t\t\twords.push({\n\t\t\t\ttext: splitWords[i],\n\t\t\t\tstartIndex: runningIndex,\n\t\t\t\tendIndex: runningIndex + splitWords[i].length,\n\t\t\t});\n\t\t\trunningIndex += splitWords[i].length + 1;\n\t\t}\n\t\treturn words;\n\t}\n\n\tprivate _refreshSeparatorCodes(): void {\n\t\tconst separators =\n\t\t\tthis._configurationService.getValue<ITerminalConfiguration>(\n\t\t\t\tTERMINAL_CONFIG_SECTION,\n\t\t\t).wordSeparators;\n\t\tlet powerlineSymbols = \"\";\n\t\tfor (let i = 0xe0b0; i <= 0xe0bf; i++) {\n\t\t\tpowerlineSymbols += String.fromCharCode(i);\n\t\t}\n\t\tthis._separatorRegex = new RegExp(\n\t\t\t`[${escapeRegExpCharacters(separators)}${powerlineSymbols}]`,\n\t\t\t\"g\",\n\t\t);\n\t}\n}\n"],
  "mappings": "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",
  "names": ["Constants"]
}
