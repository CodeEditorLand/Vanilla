{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/terminalContrib/links/browser/terminalLinkResolver.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { mainWindow } from \"../../../../../base/browser/window.js\";\nimport { Schemas } from \"../../../../../base/common/network.js\";\nimport { type IPath, posix, win32 } from \"../../../../../base/common/path.js\";\nimport {\n\tOS,\n\tOperatingSystem,\n\tisWindows,\n} from \"../../../../../base/common/platform.js\";\nimport { URI } from \"../../../../../base/common/uri.js\";\nimport { IFileService } from \"../../../../../platform/files/common/files.js\";\nimport type { ITerminalBackend } from \"../../../../../platform/terminal/common/terminal.js\";\nimport type { ITerminalProcessManager } from \"../../../terminal/common/terminal.js\";\nimport type { ITerminalLinkResolver, ResolvedLink } from \"./links.js\";\nimport {\n\tremoveLinkQueryString,\n\tremoveLinkSuffix,\n\twinDrivePrefix,\n} from \"./terminalLinkParsing.js\";\n\nexport class TerminalLinkResolver implements ITerminalLinkResolver {\n\t// Link cache could be shared across all terminals, but that could lead to weird results when\n\t// both local and remote terminals are present\n\tprivate readonly _resolvedLinkCaches: Map<string, LinkCache> = new Map();\n\n\tconstructor(\n\t\t@IFileService private readonly _fileService: IFileService,\n\t) {\n\t}\n\n\tasync resolveLink(\n\t\tprocessManager: Pick<\n\t\t\tITerminalProcessManager,\n\t\t\t\"initialCwd\" | \"os\" | \"remoteAuthority\" | \"userHome\"\n\t\t> & { backend?: Pick<ITerminalBackend, \"getWslPath\"> },\n\t\tlink: string,\n\t\turi?: URI,\n\t): Promise<ResolvedLink> {\n\t\t// Correct scheme and authority for remote terminals\n\t\tif (\n\t\t\turi &&\n\t\t\turi.scheme === Schemas.file &&\n\t\t\tprocessManager.remoteAuthority\n\t\t) {\n\t\t\turi = uri.with({\n\t\t\t\tscheme: Schemas.vscodeRemote,\n\t\t\t\tauthority: processManager.remoteAuthority,\n\t\t\t});\n\t\t}\n\n\t\t// Get the link cache\n\t\tlet cache = this._resolvedLinkCaches.get(\n\t\t\tprocessManager.remoteAuthority ?? \"\",\n\t\t);\n\t\tif (!cache) {\n\t\t\tcache = new LinkCache();\n\t\t\tthis._resolvedLinkCaches.set(\n\t\t\t\tprocessManager.remoteAuthority ?? \"\",\n\t\t\t\tcache,\n\t\t\t);\n\t\t}\n\n\t\t// Check resolved link cache first\n\t\tconst cached = cache.get(uri || link);\n\t\tif (cached !== undefined) {\n\t\t\treturn cached;\n\t\t}\n\n\t\tif (uri) {\n\t\t\ttry {\n\t\t\t\tconst stat = await this._fileService.stat(uri);\n\t\t\t\tconst result = { uri, link, isDirectory: stat.isDirectory };\n\t\t\t\tcache.set(uri, result);\n\t\t\t\treturn result;\n\t\t\t} catch (e) {\n\t\t\t\t// Does not exist\n\t\t\t\tcache.set(uri, null);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t// Remove any line/col suffix\n\t\tlet linkUrl = removeLinkSuffix(link);\n\n\t\t// Remove any query string\n\t\tlinkUrl = removeLinkQueryString(linkUrl);\n\n\t\t// Exit early if the link is determines as not valid already\n\t\tif (linkUrl.length === 0) {\n\t\t\tcache.set(link, null);\n\t\t\treturn null;\n\t\t}\n\n\t\t// If the link looks like a /mnt/ WSL path and this is a Windows frontend, use the backend\n\t\t// to get the resolved path from the wslpath util.\n\t\tif (\n\t\t\tisWindows &&\n\t\t\tlink.match(/^\\/mnt\\/[a-z]/i) &&\n\t\t\tprocessManager.backend\n\t\t) {\n\t\t\tlinkUrl = await processManager.backend.getWslPath(\n\t\t\t\tlinkUrl,\n\t\t\t\t\"unix-to-win\",\n\t\t\t);\n\t\t}\n\t\t// Skip preprocessing if it looks like a special Windows -> WSL link\n\t\telse if (\n\t\t\tisWindows &&\n\t\t\tlink.match(/^(?:\\/\\/|\\\\\\\\)wsl(?:\\$|\\.localhost)(\\/|\\\\)/)\n\t\t) {\n\t\t\t// No-op, it's already the right format\n\t\t}\n\t\t// Handle all non-WSL links\n\t\telse {\n\t\t\tconst preprocessedLink = this._preprocessPath(\n\t\t\t\tlinkUrl,\n\t\t\t\tprocessManager.initialCwd,\n\t\t\t\tprocessManager.os,\n\t\t\t\tprocessManager.userHome,\n\t\t\t);\n\t\t\tif (!preprocessedLink) {\n\t\t\t\tcache.set(link, null);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tlinkUrl = preprocessedLink;\n\t\t}\n\n\t\ttry {\n\t\t\tlet uri: URI;\n\t\t\tif (processManager.remoteAuthority) {\n\t\t\t\turi = URI.from({\n\t\t\t\t\tscheme: Schemas.vscodeRemote,\n\t\t\t\t\tauthority: processManager.remoteAuthority,\n\t\t\t\t\tpath: linkUrl,\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\turi = URI.file(linkUrl);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst stat = await this._fileService.stat(uri);\n\t\t\t\tconst result = { uri, link, isDirectory: stat.isDirectory };\n\t\t\t\tcache.set(link, result);\n\t\t\t\treturn result;\n\t\t\t} catch (e) {\n\t\t\t\t// Does not exist\n\t\t\t\tcache.set(link, null);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} catch {\n\t\t\t// Errors in parsing the path\n\t\t\tcache.set(link, null);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprotected _preprocessPath(\n\t\tlink: string,\n\t\tinitialCwd: string,\n\t\tos: OperatingSystem | undefined,\n\t\tuserHome: string | undefined,\n\t): string | null {\n\t\tconst osPath = this._getOsPath(os);\n\t\tif (link.charAt(0) === \"~\") {\n\t\t\t// Resolve ~ -> userHome\n\t\t\tif (!userHome) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tlink = osPath.join(userHome, link.substring(1));\n\t\t} else if (link.charAt(0) !== \"/\" && link.charAt(0) !== \"~\") {\n\t\t\t// Resolve workspace path . | .. | <relative_path> -> <path>/. | <path>/.. | <path>/<relative_path>\n\t\t\tif (os === OperatingSystem.Windows) {\n\t\t\t\tif (\n\t\t\t\t\t!link.match(\"^\" + winDrivePrefix) &&\n\t\t\t\t\t!link.startsWith(\"\\\\\\\\?\\\\\")\n\t\t\t\t) {\n\t\t\t\t\tif (!initialCwd) {\n\t\t\t\t\t\t// Abort if no workspace is open\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tlink = osPath.join(initialCwd, link);\n\t\t\t\t} else {\n\t\t\t\t\t// Remove \\\\?\\ from paths so that they share the same underlying\n\t\t\t\t\t// uri and don't open multiple tabs for the same file\n\t\t\t\t\tlink = link.replace(/^\\\\\\\\\\?\\\\/, \"\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!initialCwd) {\n\t\t\t\t\t// Abort if no workspace is open\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tlink = osPath.join(initialCwd, link);\n\t\t\t}\n\t\t}\n\t\tlink = osPath.normalize(link);\n\n\t\treturn link;\n\t}\n\n\tprivate _getOsPath(os: OperatingSystem | undefined): IPath {\n\t\treturn (os ?? OS) === OperatingSystem.Windows ? win32 : posix;\n\t}\n}\n\nenum LinkCacheConstants {\n\t/**\n\t * How long to cache links for in milliseconds, the TTL resets whenever a new value is set in\n\t * the cache.\n\t */\n\tTTL = 10000,\n}\n\nclass LinkCache {\n\tprivate readonly _cache = new Map<string, ResolvedLink>();\n\tprivate _cacheTilTimeout = 0;\n\n\tset(link: string | URI, value: ResolvedLink) {\n\t\t// Reset cached link TTL on any set\n\t\tif (this._cacheTilTimeout) {\n\t\t\tmainWindow.clearTimeout(this._cacheTilTimeout);\n\t\t}\n\t\tthis._cacheTilTimeout = mainWindow.setTimeout(\n\t\t\t() => this._cache.clear(),\n\t\t\tLinkCacheConstants.TTL,\n\t\t);\n\t\tthis._cache.set(this._getKey(link), value);\n\t}\n\n\tget(link: string | URI): ResolvedLink | undefined {\n\t\treturn this._cache.get(this._getKey(link));\n\t}\n\n\tprivate _getKey(link: string | URI): string {\n\t\tif (URI.isUri(link)) {\n\t\t\treturn link.toString();\n\t\t}\n\t\treturn link;\n\t}\n}\n"],
  "mappings": "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",
  "names": ["uri", "LinkCacheConstants"]
}
