{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/terminalContrib/links/browser/terminalMultiLineLinkDetector.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from '../../../../../base/common/uri.js';\nimport { IUriIdentityService } from '../../../../../platform/uriIdentity/common/uriIdentity.js';\nimport { IWorkspaceContextService } from '../../../../../platform/workspace/common/workspace.js';\nimport { ITerminalLinkDetector, ITerminalLinkResolver, ITerminalSimpleLink, TerminalBuiltinLinkType } from './links.js';\nimport { convertLinkRangeToBuffer, getXtermLineContent } from './terminalLinkHelpers.js';\nimport type { IBufferLine, Terminal } from '@xterm/xterm';\nimport { ITerminalProcessManager } from '../../../terminal/common/terminal.js';\nimport { ITerminalBackend, ITerminalLogService } from '../../../../../platform/terminal/common/terminal.js';\n\nconst enum Constants {\n\t/**\n\t * The max line length to try extract word links from.\n\t */\n\tMaxLineLength = 2000,\n\n\t/**\n\t * The maximum length of a link to resolve against the file system. This limit is put in place\n\t * to avoid sending excessive data when remote connections are in place.\n\t */\n\tMaxResolvedLinkLength = 1024,\n}\n\nconst lineNumberPrefixMatchers = [\n\t// Ripgrep:\n\t//   /some/file\n\t//   16:searchresult\n\t//   16:    searchresult\n\t// Eslint:\n\t//   /some/file\n\t//     16:5  error ...\n\t/^ *(?<link>(?<line>\\d+):(?<col>\\d+)?)/\n];\n\nconst gitDiffMatchers = [\n\t// --- a/some/file\n\t// +++ b/some/file\n\t// @@ -8,11 +8,11 @@ file content...\n\t/^(?<link>@@ .+ \\+(?<toFileLine>\\d+),(?<toFileCount>\\d+) @@)/\n];\n\nexport class TerminalMultiLineLinkDetector implements ITerminalLinkDetector {\n\tstatic id = 'multiline';\n\n\t// This was chosen as a reasonable maximum line length given the tradeoff between performance\n\t// and how likely it is to encounter such a large line length. Some useful reference points:\n\t// - Window old max length: 260 ($MAX_PATH)\n\t// - Linux max length: 4096 ($PATH_MAX)\n\treadonly maxLinkLength = 500;\n\n\tconstructor(\n\t\treadonly xterm: Terminal,\n\t\tprivate readonly _processManager: Pick<ITerminalProcessManager, 'initialCwd' | 'os' | 'remoteAuthority' | 'userHome'> & { backend?: Pick<ITerminalBackend, 'getWslPath'> },\n\t\tprivate readonly _linkResolver: ITerminalLinkResolver,\n\t\t@ITerminalLogService private readonly _logService: ITerminalLogService,\n\t\t@IUriIdentityService private readonly _uriIdentityService: IUriIdentityService,\n\t\t@IWorkspaceContextService private readonly _workspaceContextService: IWorkspaceContextService\n\t) {\n\t}\n\n\tasync detect(lines: IBufferLine[], startLine: number, endLine: number): Promise<ITerminalSimpleLink[]> {\n\t\tconst links: ITerminalSimpleLink[] = [];\n\n\t\t// Get the text representation of the wrapped line\n\t\tconst text = getXtermLineContent(this.xterm.buffer.active, startLine, endLine, this.xterm.cols);\n\t\tif (text === '' || text.length > Constants.MaxLineLength) {\n\t\t\treturn [];\n\t\t}\n\n\t\tthis._logService.trace('terminalMultiLineLinkDetector#detect text', text);\n\n\t\t// Match against the fallback matchers which are mainly designed to catch paths with spaces\n\t\t// that aren't possible using the regular mechanism.\n\t\tfor (const matcher of lineNumberPrefixMatchers) {\n\t\t\tconst match = text.match(matcher);\n\t\t\tconst group = match?.groups;\n\t\t\tif (!group) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst link = group?.link;\n\t\t\tconst line = group?.line;\n\t\t\tconst col = group?.col;\n\t\t\tif (!link || line === undefined) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Don't try resolve any links of excessive length\n\t\t\tif (link.length > Constants.MaxResolvedLinkLength) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis._logService.trace('terminalMultiLineLinkDetector#detect candidate', link);\n\n\t\t\t// Scan up looking for the first line that could be a path\n\t\t\tlet possiblePath: string | undefined;\n\t\t\tfor (let index = startLine - 1; index >= 0; index--) {\n\t\t\t\t// Ignore lines that aren't at the beginning of a wrapped line\n\t\t\t\tif (this.xterm.buffer.active.getLine(index)!.isWrapped) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst text = getXtermLineContent(this.xterm.buffer.active, index, index, this.xterm.cols);\n\t\t\t\tif (!text.match(/^\\s*\\d/)) {\n\t\t\t\t\tpossiblePath = text;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!possiblePath) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Check if the first non-matching line is an absolute or relative link\n\t\t\tconst linkStat = await this._linkResolver.resolveLink(this._processManager, possiblePath);\n\t\t\tif (linkStat) {\n\t\t\t\tlet type: TerminalBuiltinLinkType;\n\t\t\t\tif (linkStat.isDirectory) {\n\t\t\t\t\tif (this._isDirectoryInsideWorkspace(linkStat.uri)) {\n\t\t\t\t\t\ttype = TerminalBuiltinLinkType.LocalFolderInWorkspace;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttype = TerminalBuiltinLinkType.LocalFolderOutsideWorkspace;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttype = TerminalBuiltinLinkType.LocalFile;\n\t\t\t\t}\n\n\t\t\t\t// Convert the entire line's text string index into a wrapped buffer range\n\t\t\t\tconst bufferRange = convertLinkRangeToBuffer(lines, this.xterm.cols, {\n\t\t\t\t\tstartColumn: 1,\n\t\t\t\t\tstartLineNumber: 1,\n\t\t\t\t\tendColumn: 1 + text.length,\n\t\t\t\t\tendLineNumber: 1\n\t\t\t\t}, startLine);\n\n\t\t\t\tconst simpleLink: ITerminalSimpleLink = {\n\t\t\t\t\ttext: link,\n\t\t\t\t\turi: linkStat.uri,\n\t\t\t\t\tselection: {\n\t\t\t\t\t\tstartLineNumber: parseInt(line),\n\t\t\t\t\t\tstartColumn: col ? parseInt(col) : 1\n\t\t\t\t\t},\n\t\t\t\t\tdisableTrimColon: true,\n\t\t\t\t\tbufferRange: bufferRange,\n\t\t\t\t\ttype\n\t\t\t\t};\n\t\t\t\tthis._logService.trace('terminalMultiLineLinkDetector#detect verified link', simpleLink);\n\t\t\t\tlinks.push(simpleLink);\n\n\t\t\t\t// Break on the first match\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (links.length === 0) {\n\t\t\tfor (const matcher of gitDiffMatchers) {\n\t\t\t\tconst match = text.match(matcher);\n\t\t\t\tconst group = match?.groups;\n\t\t\t\tif (!group) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst link = group?.link;\n\t\t\t\tconst toFileLine = group?.toFileLine;\n\t\t\t\tconst toFileCount = group?.toFileCount;\n\t\t\t\tif (!link || toFileLine === undefined) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Don't try resolve any links of excessive length\n\t\t\t\tif (link.length > Constants.MaxResolvedLinkLength) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tthis._logService.trace('terminalMultiLineLinkDetector#detect candidate', link);\n\n\n\t\t\t\t// Scan up looking for the first line that could be a path\n\t\t\t\tlet possiblePath: string | undefined;\n\t\t\t\tfor (let index = startLine - 1; index >= 0; index--) {\n\t\t\t\t\t// Ignore lines that aren't at the beginning of a wrapped line\n\t\t\t\t\tif (this.xterm.buffer.active.getLine(index)!.isWrapped) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tconst text = getXtermLineContent(this.xterm.buffer.active, index, index, this.xterm.cols);\n\t\t\t\t\tconst match = text.match(/\\+\\+\\+ b\\/(?<path>.+)/);\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\tpossiblePath = match.groups?.path;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!possiblePath) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Check if the first non-matching line is an absolute or relative link\n\t\t\t\tconst linkStat = await this._linkResolver.resolveLink(this._processManager, possiblePath);\n\t\t\t\tif (linkStat) {\n\t\t\t\t\tlet type: TerminalBuiltinLinkType;\n\t\t\t\t\tif (linkStat.isDirectory) {\n\t\t\t\t\t\tif (this._isDirectoryInsideWorkspace(linkStat.uri)) {\n\t\t\t\t\t\t\ttype = TerminalBuiltinLinkType.LocalFolderInWorkspace;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttype = TerminalBuiltinLinkType.LocalFolderOutsideWorkspace;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttype = TerminalBuiltinLinkType.LocalFile;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Convert the link to the buffer range\n\t\t\t\t\tconst bufferRange = convertLinkRangeToBuffer(lines, this.xterm.cols, {\n\t\t\t\t\t\tstartColumn: 1,\n\t\t\t\t\t\tstartLineNumber: 1,\n\t\t\t\t\t\tendColumn: 1 + link.length,\n\t\t\t\t\t\tendLineNumber: 1\n\t\t\t\t\t}, startLine);\n\n\t\t\t\t\tconst simpleLink: ITerminalSimpleLink = {\n\t\t\t\t\t\ttext: link,\n\t\t\t\t\t\turi: linkStat.uri,\n\t\t\t\t\t\tselection: {\n\t\t\t\t\t\t\tstartLineNumber: parseInt(toFileLine),\n\t\t\t\t\t\t\tstartColumn: 1,\n\t\t\t\t\t\t\tendLineNumber: parseInt(toFileLine) + parseInt(toFileCount)\n\t\t\t\t\t\t},\n\t\t\t\t\t\tbufferRange: bufferRange,\n\t\t\t\t\t\ttype\n\t\t\t\t\t};\n\t\t\t\t\tthis._logService.trace('terminalMultiLineLinkDetector#detect verified link', simpleLink);\n\t\t\t\t\tlinks.push(simpleLink);\n\n\t\t\t\t\t// Break on the first match\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn links;\n\t}\n\n\tprivate _isDirectoryInsideWorkspace(uri: URI) {\n\t\tconst folders = this._workspaceContextService.getWorkspace().folders;\n\t\tfor (let i = 0; i < folders.length; i++) {\n\t\t\tif (this._uriIdentityService.extUri.isEqualOrParent(uri, folders[i].uri)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n"],
  "mappings": "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",
  "names": ["Constants", "text", "match"]
}
