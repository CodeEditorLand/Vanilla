{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/terminalContrib/links/browser/terminalMultiLineLinkDetector.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { IBufferLine, Terminal } from \"@xterm/xterm\";\nimport type { URI } from \"../../../../../base/common/uri.js\";\nimport {\n\ttype ITerminalBackend,\n\tITerminalLogService,\n} from \"../../../../../platform/terminal/common/terminal.js\";\nimport { IUriIdentityService } from \"../../../../../platform/uriIdentity/common/uriIdentity.js\";\nimport { IWorkspaceContextService } from \"../../../../../platform/workspace/common/workspace.js\";\nimport type { ITerminalProcessManager } from \"../../../terminal/common/terminal.js\";\nimport {\n\ttype ITerminalLinkDetector,\n\ttype ITerminalLinkResolver,\n\ttype ITerminalSimpleLink,\n\tTerminalBuiltinLinkType,\n} from \"./links.js\";\nimport {\n\tconvertLinkRangeToBuffer,\n\tgetXtermLineContent,\n} from \"./terminalLinkHelpers.js\";\n\nenum Constants {\n\t/**\n\t * The max line length to try extract word links from.\n\t */\n\tMaxLineLength = 2000,\n\n\t/**\n\t * The maximum length of a link to resolve against the file system. This limit is put in place\n\t * to avoid sending excessive data when remote connections are in place.\n\t */\n\tMaxResolvedLinkLength = 1024,\n}\n\nconst lineNumberPrefixMatchers = [\n\t// Ripgrep:\n\t//   /some/file\n\t//   16:searchresult\n\t//   16:    searchresult\n\t// Eslint:\n\t//   /some/file\n\t//     16:5  error ...\n\t/^ *(?<link>(?<line>\\d+):(?<col>\\d+)?)/,\n];\n\nconst gitDiffMatchers = [\n\t// --- a/some/file\n\t// +++ b/some/file\n\t// @@ -8,11 +8,11 @@ file content...\n\t/^(?<link>@@ .+ \\+(?<toFileLine>\\d+),(?<toFileCount>\\d+) @@)/,\n];\n\nexport class TerminalMultiLineLinkDetector implements ITerminalLinkDetector {\n\tstatic id = \"multiline\";\n\n\t// This was chosen as a reasonable maximum line length given the tradeoff between performance\n\t// and how likely it is to encounter such a large line length. Some useful reference points:\n\t// - Window old max length: 260 ($MAX_PATH)\n\t// - Linux max length: 4096 ($PATH_MAX)\n\treadonly maxLinkLength = 500;\n\n\tconstructor(\n\t\treadonly xterm: Terminal,\n\t\tprivate readonly _processManager: Pick<ITerminalProcessManager, 'initialCwd' | 'os' | 'remoteAuthority' | 'userHome'> & { backend?: Pick<ITerminalBackend, 'getWslPath'> },\n\t\tprivate readonly _linkResolver: ITerminalLinkResolver,\n\t\t@ITerminalLogService private readonly _logService: ITerminalLogService,\n\t\t@IUriIdentityService private readonly _uriIdentityService: IUriIdentityService,\n\t\t@IWorkspaceContextService private readonly _workspaceContextService: IWorkspaceContextService\n\t) {\n\t}\n\n\tasync detect(\n\t\tlines: IBufferLine[],\n\t\tstartLine: number,\n\t\tendLine: number,\n\t): Promise<ITerminalSimpleLink[]> {\n\t\tconst links: ITerminalSimpleLink[] = [];\n\n\t\t// Get the text representation of the wrapped line\n\t\tconst text = getXtermLineContent(\n\t\t\tthis.xterm.buffer.active,\n\t\t\tstartLine,\n\t\t\tendLine,\n\t\t\tthis.xterm.cols,\n\t\t);\n\t\tif (text === \"\" || text.length > Constants.MaxLineLength) {\n\t\t\treturn [];\n\t\t}\n\n\t\tthis._logService.trace(\n\t\t\t\"terminalMultiLineLinkDetector#detect text\",\n\t\t\ttext,\n\t\t);\n\n\t\t// Match against the fallback matchers which are mainly designed to catch paths with spaces\n\t\t// that aren't possible using the regular mechanism.\n\t\tfor (const matcher of lineNumberPrefixMatchers) {\n\t\t\tconst match = text.match(matcher);\n\t\t\tconst group = match?.groups;\n\t\t\tif (!group) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst link = group?.link;\n\t\t\tconst line = group?.line;\n\t\t\tconst col = group?.col;\n\t\t\tif (!link || line === undefined) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Don't try resolve any links of excessive length\n\t\t\tif (link.length > Constants.MaxResolvedLinkLength) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis._logService.trace(\n\t\t\t\t\"terminalMultiLineLinkDetector#detect candidate\",\n\t\t\t\tlink,\n\t\t\t);\n\n\t\t\t// Scan up looking for the first line that could be a path\n\t\t\tlet possiblePath: string | undefined;\n\t\t\tfor (let index = startLine - 1; index >= 0; index--) {\n\t\t\t\t// Ignore lines that aren't at the beginning of a wrapped line\n\t\t\t\tif (this.xterm.buffer.active.getLine(index)!.isWrapped) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst text = getXtermLineContent(\n\t\t\t\t\tthis.xterm.buffer.active,\n\t\t\t\t\tindex,\n\t\t\t\t\tindex,\n\t\t\t\t\tthis.xterm.cols,\n\t\t\t\t);\n\t\t\t\tif (!text.match(/^\\s*\\d/)) {\n\t\t\t\t\tpossiblePath = text;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!possiblePath) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Check if the first non-matching line is an absolute or relative link\n\t\t\tconst linkStat = await this._linkResolver.resolveLink(\n\t\t\t\tthis._processManager,\n\t\t\t\tpossiblePath,\n\t\t\t);\n\t\t\tif (linkStat) {\n\t\t\t\tlet type: TerminalBuiltinLinkType;\n\t\t\t\tif (linkStat.isDirectory) {\n\t\t\t\t\tif (this._isDirectoryInsideWorkspace(linkStat.uri)) {\n\t\t\t\t\t\ttype = TerminalBuiltinLinkType.LocalFolderInWorkspace;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttype =\n\t\t\t\t\t\t\tTerminalBuiltinLinkType.LocalFolderOutsideWorkspace;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttype = TerminalBuiltinLinkType.LocalFile;\n\t\t\t\t}\n\n\t\t\t\t// Convert the entire line's text string index into a wrapped buffer range\n\t\t\t\tconst bufferRange = convertLinkRangeToBuffer(\n\t\t\t\t\tlines,\n\t\t\t\t\tthis.xterm.cols,\n\t\t\t\t\t{\n\t\t\t\t\t\tstartColumn: 1,\n\t\t\t\t\t\tstartLineNumber: 1,\n\t\t\t\t\t\tendColumn: 1 + text.length,\n\t\t\t\t\t\tendLineNumber: 1,\n\t\t\t\t\t},\n\t\t\t\t\tstartLine,\n\t\t\t\t);\n\n\t\t\t\tconst simpleLink: ITerminalSimpleLink = {\n\t\t\t\t\ttext: link,\n\t\t\t\t\turi: linkStat.uri,\n\t\t\t\t\tselection: {\n\t\t\t\t\t\tstartLineNumber: Number.parseInt(line),\n\t\t\t\t\t\tstartColumn: col ? Number.parseInt(col) : 1,\n\t\t\t\t\t},\n\t\t\t\t\tdisableTrimColon: true,\n\t\t\t\t\tbufferRange: bufferRange,\n\t\t\t\t\ttype,\n\t\t\t\t};\n\t\t\t\tthis._logService.trace(\n\t\t\t\t\t\"terminalMultiLineLinkDetector#detect verified link\",\n\t\t\t\t\tsimpleLink,\n\t\t\t\t);\n\t\t\t\tlinks.push(simpleLink);\n\n\t\t\t\t// Break on the first match\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (links.length === 0) {\n\t\t\tfor (const matcher of gitDiffMatchers) {\n\t\t\t\tconst match = text.match(matcher);\n\t\t\t\tconst group = match?.groups;\n\t\t\t\tif (!group) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst link = group?.link;\n\t\t\t\tconst toFileLine = group?.toFileLine;\n\t\t\t\tconst toFileCount = group?.toFileCount;\n\t\t\t\tif (!link || toFileLine === undefined) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Don't try resolve any links of excessive length\n\t\t\t\tif (link.length > Constants.MaxResolvedLinkLength) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tthis._logService.trace(\n\t\t\t\t\t\"terminalMultiLineLinkDetector#detect candidate\",\n\t\t\t\t\tlink,\n\t\t\t\t);\n\n\t\t\t\t// Scan up looking for the first line that could be a path\n\t\t\t\tlet possiblePath: string | undefined;\n\t\t\t\tfor (let index = startLine - 1; index >= 0; index--) {\n\t\t\t\t\t// Ignore lines that aren't at the beginning of a wrapped line\n\t\t\t\t\tif (this.xterm.buffer.active.getLine(index)!.isWrapped) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tconst text = getXtermLineContent(\n\t\t\t\t\t\tthis.xterm.buffer.active,\n\t\t\t\t\t\tindex,\n\t\t\t\t\t\tindex,\n\t\t\t\t\t\tthis.xterm.cols,\n\t\t\t\t\t);\n\t\t\t\t\tconst match = text.match(/\\+\\+\\+ b\\/(?<path>.+)/);\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\tpossiblePath = match.groups?.path;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!possiblePath) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Check if the first non-matching line is an absolute or relative link\n\t\t\t\tconst linkStat = await this._linkResolver.resolveLink(\n\t\t\t\t\tthis._processManager,\n\t\t\t\t\tpossiblePath,\n\t\t\t\t);\n\t\t\t\tif (linkStat) {\n\t\t\t\t\tlet type: TerminalBuiltinLinkType;\n\t\t\t\t\tif (linkStat.isDirectory) {\n\t\t\t\t\t\tif (this._isDirectoryInsideWorkspace(linkStat.uri)) {\n\t\t\t\t\t\t\ttype =\n\t\t\t\t\t\t\t\tTerminalBuiltinLinkType.LocalFolderInWorkspace;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttype =\n\t\t\t\t\t\t\t\tTerminalBuiltinLinkType.LocalFolderOutsideWorkspace;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttype = TerminalBuiltinLinkType.LocalFile;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Convert the link to the buffer range\n\t\t\t\t\tconst bufferRange = convertLinkRangeToBuffer(\n\t\t\t\t\t\tlines,\n\t\t\t\t\t\tthis.xterm.cols,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstartColumn: 1,\n\t\t\t\t\t\t\tstartLineNumber: 1,\n\t\t\t\t\t\t\tendColumn: 1 + link.length,\n\t\t\t\t\t\t\tendLineNumber: 1,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tstartLine,\n\t\t\t\t\t);\n\n\t\t\t\t\tconst simpleLink: ITerminalSimpleLink = {\n\t\t\t\t\t\ttext: link,\n\t\t\t\t\t\turi: linkStat.uri,\n\t\t\t\t\t\tselection: {\n\t\t\t\t\t\t\tstartLineNumber: Number.parseInt(toFileLine),\n\t\t\t\t\t\t\tstartColumn: 1,\n\t\t\t\t\t\t\tendLineNumber:\n\t\t\t\t\t\t\t\tNumber.parseInt(toFileLine) +\n\t\t\t\t\t\t\t\tNumber.parseInt(toFileCount),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tbufferRange: bufferRange,\n\t\t\t\t\t\ttype,\n\t\t\t\t\t};\n\t\t\t\t\tthis._logService.trace(\n\t\t\t\t\t\t\"terminalMultiLineLinkDetector#detect verified link\",\n\t\t\t\t\t\tsimpleLink,\n\t\t\t\t\t);\n\t\t\t\t\tlinks.push(simpleLink);\n\n\t\t\t\t\t// Break on the first match\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn links;\n\t}\n\n\tprivate _isDirectoryInsideWorkspace(uri: URI) {\n\t\tconst folders = this._workspaceContextService.getWorkspace().folders;\n\t\tfor (let i = 0; i < folders.length; i++) {\n\t\t\tif (\n\t\t\t\tthis._uriIdentityService.extUri.isEqualOrParent(\n\t\t\t\t\turi,\n\t\t\t\t\tfolders[i].uri,\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n"],
  "mappings": "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",
  "names": ["Constants", "text", "match"]
}
