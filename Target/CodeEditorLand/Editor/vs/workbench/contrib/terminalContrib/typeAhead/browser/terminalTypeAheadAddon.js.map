{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/terminalContrib/typeAhead/browser/terminalTypeAheadAddon.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type {\n\tIBuffer,\n\tIBufferCell,\n\tIDisposable,\n\tITerminalAddon,\n\tTerminal,\n} from \"@xterm/xterm\";\nimport { disposableTimeout } from \"../../../../../base/common/async.js\";\nimport { Color, RGBA } from \"../../../../../base/common/color.js\";\nimport { debounce } from \"../../../../../base/common/decorators.js\";\nimport { Emitter } from \"../../../../../base/common/event.js\";\nimport {\n\tDisposable,\n\ttoDisposable,\n} from \"../../../../../base/common/lifecycle.js\";\nimport { escapeRegExpCharacters } from \"../../../../../base/common/strings.js\";\nimport { IConfigurationService } from \"../../../../../platform/configuration/common/configuration.js\";\nimport { ITelemetryService } from \"../../../../../platform/telemetry/common/telemetry.js\";\nimport type {\n\tIXtermCore,\n\tXtermAttributes,\n} from \"../../../terminal/browser/xterm-private.js\";\nimport {\n\ttype IBeforeProcessDataEvent,\n\ttype ITerminalProcessManager,\n\tTERMINAL_CONFIG_SECTION,\n} from \"../../../terminal/common/terminal.js\";\nimport {\n\tDEFAULT_LOCAL_ECHO_EXCLUDE,\n\ttype ITerminalTypeAheadConfiguration,\n} from \"../common/terminalTypeAheadConfiguration.js\";\n\nenum VT {\n\tEsc = \"\\x1b\",\n\tCsi = `\\x1b[`,\n\tShowCursor = `\\x1b[?25h`,\n\tHideCursor = `\\x1b[?25l`,\n\tDeleteChar = `\\x1b[X`,\n\tDeleteRestOfLine = `\\x1b[K`,\n}\n\nconst CSI_STYLE_RE = /^\\x1b\\[[0-9;]*m/;\nconst CSI_MOVE_RE = /^\\x1b\\[?([0-9]*)(;[35])?O?([DC])/;\nconst NOT_WORD_RE = /[^a-z0-9]/i;\n\nenum StatsConstants {\n\tStatsBufferSize = 24,\n\tStatsSendTelemetryEvery = 1000 * 60 * 5, // how often to collect stats\n\tStatsMinSamplesToTurnOn = 5,\n\tStatsMinAccuracyToTurnOn = 0.3,\n\tStatsToggleOffThreshold = 0.5, // if latency is less than `threshold * this`, turn off\n}\n\n/**\n * Codes that should be omitted from sending to the prediction engine and instead omitted directly:\n * - Hide cursor (DECTCEM): We wrap the local echo sequence in hide and show\n *   CSI ? 2 5 l\n * - Show cursor (DECTCEM): We wrap the local echo sequence in hide and show\n *   CSI ? 2 5 h\n * - Device Status Report (DSR): These sequence fire report events from xterm which could cause\n *   double reporting and potentially a stack overflow (#119472)\n *   CSI Ps n\n *   CSI ? Ps n\n */\nconst PREDICTION_OMIT_RE = /^(\\x1b\\[(\\??25[hl]|\\??[0-9;]+n))+/;\n\nconst core = (terminal: Terminal): IXtermCore => (terminal as any)._core;\nconst flushOutput = (terminal: Terminal) => {\n\t// TODO: Flushing output is not possible anymore without async\n};\n\nenum CursorMoveDirection {\n\tBack = \"D\",\n\tForwards = \"C\",\n}\n\ninterface ICoordinate {\n\tx: number;\n\ty: number;\n\tbaseY: number;\n}\n\nclass Cursor implements ICoordinate {\n\tprivate _x = 0;\n\tprivate _y = 1;\n\tprivate _baseY = 1;\n\n\tget x() {\n\t\treturn this._x;\n\t}\n\n\tget y() {\n\t\treturn this._y;\n\t}\n\n\tget baseY() {\n\t\treturn this._baseY;\n\t}\n\n\tget coordinate(): ICoordinate {\n\t\treturn { x: this._x, y: this._y, baseY: this._baseY };\n\t}\n\n\tconstructor(\n\t\treadonly rows: number,\n\t\treadonly cols: number,\n\t\tprivate readonly _buffer: IBuffer,\n\t) {\n\t\tthis._x = _buffer.cursorX;\n\t\tthis._y = _buffer.cursorY;\n\t\tthis._baseY = _buffer.baseY;\n\t}\n\n\tgetLine() {\n\t\treturn this._buffer.getLine(this._y + this._baseY);\n\t}\n\n\tgetCell(loadInto?: IBufferCell) {\n\t\treturn this.getLine()?.getCell(this._x, loadInto);\n\t}\n\n\tmoveTo(coordinate: ICoordinate) {\n\t\tthis._x = coordinate.x;\n\t\tthis._y = coordinate.y + coordinate.baseY - this._baseY;\n\t\treturn this.moveInstruction();\n\t}\n\n\tclone() {\n\t\tconst c = new Cursor(this.rows, this.cols, this._buffer);\n\t\tc.moveTo(this);\n\t\treturn c;\n\t}\n\n\tmove(x: number, y: number) {\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\treturn this.moveInstruction();\n\t}\n\n\tshift(x = 0, y = 0) {\n\t\tthis._x += x;\n\t\tthis._y += y;\n\t\treturn this.moveInstruction();\n\t}\n\n\tmoveInstruction() {\n\t\tif (this._y >= this.rows) {\n\t\t\tthis._baseY += this._y - (this.rows - 1);\n\t\t\tthis._y = this.rows - 1;\n\t\t} else if (this._y < 0) {\n\t\t\tthis._baseY -= this._y;\n\t\t\tthis._y = 0;\n\t\t}\n\n\t\treturn `${VT.Csi}${this._y + 1};${this._x + 1}H`;\n\t}\n}\n\nconst moveToWordBoundary = (b: IBuffer, cursor: Cursor, direction: -1 | 1) => {\n\tlet ateLeadingWhitespace = false;\n\tif (direction < 0) {\n\t\tcursor.shift(-1);\n\t}\n\n\tlet cell: IBufferCell | undefined;\n\twhile (cursor.x >= 0) {\n\t\tcell = cursor.getCell(cell);\n\t\tif (!cell?.getCode()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst chars = cell.getChars();\n\t\tif (NOT_WORD_RE.test(chars)) {\n\t\t\tif (ateLeadingWhitespace) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tateLeadingWhitespace = true;\n\t\t}\n\n\t\tcursor.shift(direction);\n\t}\n\n\tif (direction < 0) {\n\t\tcursor.shift(1); // we want to place the cursor after the whitespace starting the word\n\t}\n};\n\nenum MatchResult {\n\t/** matched successfully */\n\tSuccess = 0,\n\t/** failed to match */\n\tFailure = 1,\n\t/** buffer data, it might match in the future one more data comes in */\n\tBuffer = 2,\n}\n\nexport interface IPrediction {\n\t/**\n\t * Whether applying this prediction can modify the style attributes of the\n\t * terminal. If so it means we need to reset the cursor style if it's\n\t * rolled back.\n\t */\n\treadonly affectsStyle?: boolean;\n\n\t/**\n\t * If set to false, the prediction will not be cleared if no input is\n\t * received from the server.\n\t */\n\treadonly clearAfterTimeout?: boolean;\n\n\t/**\n\t * Returns a sequence to apply the prediction.\n\t * @param buffer to write to\n\t * @param cursor position to write the data. Should advance the cursor.\n\t * @returns a string to be written to the user terminal, or optionally a\n\t * string for the user terminal and real pty.\n\t */\n\tapply(buffer: IBuffer, cursor: Cursor): string;\n\n\t/**\n\t * Returns a sequence to roll back a previous `apply()` call. If\n\t * `rollForwards` is not given, then this is also called if a prediction\n\t * is correct before show the user's data.\n\t */\n\trollback(cursor: Cursor): string;\n\n\t/**\n\t * If available, this will be called when the prediction is correct.\n\t */\n\trollForwards(cursor: Cursor, withInput: string): string;\n\n\t/**\n\t * Returns whether the given input is one expected by this prediction.\n\t * @param input reader for the input the PTY is giving\n\t * @param lookBehind the last successfully-made prediction, if any\n\t */\n\tmatches(input: StringReader, lookBehind?: IPrediction): MatchResult;\n}\n\nclass StringReader {\n\tindex = 0;\n\n\tget remaining() {\n\t\treturn this._input.length - this.index;\n\t}\n\n\tget eof() {\n\t\treturn this.index === this._input.length;\n\t}\n\n\tget rest() {\n\t\treturn this._input.slice(this.index);\n\t}\n\n\tconstructor(private readonly _input: string) {}\n\n\t/**\n\t * Advances the reader and returns the character if it matches.\n\t */\n\teatChar(char: string) {\n\t\tif (this._input[this.index] !== char) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.index++;\n\t\treturn char;\n\t}\n\n\t/**\n\t * Advances the reader and returns the string if it matches.\n\t */\n\teatStr(substr: string) {\n\t\tif (this._input.slice(this.index, substr.length) !== substr) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.index += substr.length;\n\t\treturn substr;\n\t}\n\n\t/**\n\t * Matches and eats the substring character-by-character. If EOF is reached\n\t * before the substring is consumed, it will buffer. Index is not moved\n\t * if it's not a match.\n\t */\n\teatGradually(substr: string): MatchResult {\n\t\tconst prevIndex = this.index;\n\t\tfor (let i = 0; i < substr.length; i++) {\n\t\t\tif (i > 0 && this.eof) {\n\t\t\t\treturn MatchResult.Buffer;\n\t\t\t}\n\n\t\t\tif (!this.eatChar(substr[i])) {\n\t\t\t\tthis.index = prevIndex;\n\t\t\t\treturn MatchResult.Failure;\n\t\t\t}\n\t\t}\n\n\t\treturn MatchResult.Success;\n\t}\n\n\t/**\n\t * Advances the reader and returns the regex if it matches.\n\t */\n\teatRe(re: RegExp) {\n\t\tconst match = re.exec(this._input.slice(this.index));\n\t\tif (!match) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.index += match[0].length;\n\t\treturn match;\n\t}\n\n\t/**\n\t * Advances the reader and returns the character if the code matches.\n\t */\n\teatCharCode(min = 0, max = min + 1) {\n\t\tconst code = this._input.charCodeAt(this.index);\n\t\tif (code < min || code >= max) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tthis.index++;\n\t\treturn code;\n\t}\n}\n\n/**\n * Preidction which never tests true. Will always discard predictions made\n * after it.\n */\nclass HardBoundary implements IPrediction {\n\treadonly clearAfterTimeout = false;\n\n\tapply() {\n\t\treturn \"\";\n\t}\n\n\trollback() {\n\t\treturn \"\";\n\t}\n\n\trollForwards() {\n\t\treturn \"\";\n\t}\n\n\tmatches() {\n\t\treturn MatchResult.Failure;\n\t}\n}\n\n/**\n * Wraps another prediction. Does not apply the prediction, but will pass\n * through its `matches` request.\n */\nclass TentativeBoundary implements IPrediction {\n\tprivate _appliedCursor?: Cursor;\n\n\tconstructor(readonly inner: IPrediction) {}\n\n\tapply(buffer: IBuffer, cursor: Cursor) {\n\t\tthis._appliedCursor = cursor.clone();\n\t\tthis.inner.apply(buffer, this._appliedCursor);\n\t\treturn \"\";\n\t}\n\n\trollback(cursor: Cursor) {\n\t\tthis.inner.rollback(cursor.clone());\n\t\treturn \"\";\n\t}\n\n\trollForwards(cursor: Cursor, withInput: string) {\n\t\tif (this._appliedCursor) {\n\t\t\tcursor.moveTo(this._appliedCursor);\n\t\t}\n\n\t\treturn withInput;\n\t}\n\n\tmatches(input: StringReader) {\n\t\treturn this.inner.matches(input);\n\t}\n}\n\nconst isTenativeCharacterPrediction = (\n\tp: unknown,\n): p is TentativeBoundary & { inner: CharacterPrediction } =>\n\tp instanceof TentativeBoundary && p.inner instanceof CharacterPrediction;\n\n/**\n * Prediction for a single alphanumeric character.\n */\nclass CharacterPrediction implements IPrediction {\n\treadonly affectsStyle = true;\n\n\tappliedAt?: {\n\t\tpos: ICoordinate;\n\t\toldAttributes: string;\n\t\toldChar: string;\n\t};\n\n\tconstructor(\n\t\tprivate readonly _style: TypeAheadStyle,\n\t\tprivate readonly _char: string,\n\t) {}\n\n\tapply(_: IBuffer, cursor: Cursor) {\n\t\tconst cell = cursor.getCell();\n\t\tthis.appliedAt = cell\n\t\t\t? {\n\t\t\t\t\tpos: cursor.coordinate,\n\t\t\t\t\toldAttributes: attributesToSeq(cell),\n\t\t\t\t\toldChar: cell.getChars(),\n\t\t\t\t}\n\t\t\t: { pos: cursor.coordinate, oldAttributes: \"\", oldChar: \"\" };\n\n\t\tcursor.shift(1);\n\n\t\treturn this._style.apply + this._char + this._style.undo;\n\t}\n\n\trollback(cursor: Cursor) {\n\t\tif (!this.appliedAt) {\n\t\t\treturn \"\"; // not applied\n\t\t}\n\n\t\tconst { oldAttributes, oldChar, pos } = this.appliedAt;\n\t\tconst r =\n\t\t\tcursor.moveTo(pos) +\n\t\t\t(oldChar\n\t\t\t\t? `${oldAttributes}${oldChar}${cursor.moveTo(pos)}`\n\t\t\t\t: VT.DeleteChar);\n\t\treturn r;\n\t}\n\n\trollForwards(cursor: Cursor, input: string) {\n\t\tif (!this.appliedAt) {\n\t\t\treturn \"\"; // not applied\n\t\t}\n\n\t\treturn cursor.clone().moveTo(this.appliedAt.pos) + input;\n\t}\n\n\tmatches(input: StringReader, lookBehind?: IPrediction) {\n\t\tconst startIndex = input.index;\n\n\t\t// remove any styling CSI before checking the char\n\t\twhile (input.eatRe(CSI_STYLE_RE)) {}\n\n\t\tif (input.eof) {\n\t\t\treturn MatchResult.Buffer;\n\t\t}\n\n\t\tif (input.eatChar(this._char)) {\n\t\t\treturn MatchResult.Success;\n\t\t}\n\n\t\tif (lookBehind instanceof CharacterPrediction) {\n\t\t\t// see #112842\n\t\t\tconst sillyZshOutcome = input.eatGradually(\n\t\t\t\t`\\b${lookBehind._char}${this._char}`,\n\t\t\t);\n\t\t\tif (sillyZshOutcome !== MatchResult.Failure) {\n\t\t\t\treturn sillyZshOutcome;\n\t\t\t}\n\t\t}\n\n\t\tinput.index = startIndex;\n\t\treturn MatchResult.Failure;\n\t}\n}\n\nclass BackspacePrediction implements IPrediction {\n\tprotected _appliedAt?: {\n\t\tpos: ICoordinate;\n\t\toldAttributes: string;\n\t\toldChar: string;\n\t\tisLastChar: boolean;\n\t};\n\n\tconstructor(private readonly _terminal: Terminal) {}\n\n\tapply(_: IBuffer, cursor: Cursor) {\n\t\t// at eol if everything to the right is whitespace (zsh will emit a \"clear line\" code in this case)\n\t\t// todo: can be optimized if `getTrimmedLength` is exposed from xterm\n\t\tconst isLastChar = !cursor\n\t\t\t.getLine()\n\t\t\t?.translateToString(undefined, cursor.x)\n\t\t\t.trim();\n\t\tconst pos = cursor.coordinate;\n\t\tconst move = cursor.shift(-1);\n\t\tconst cell = cursor.getCell();\n\t\tthis._appliedAt = cell\n\t\t\t? {\n\t\t\t\t\tisLastChar,\n\t\t\t\t\tpos,\n\t\t\t\t\toldAttributes: attributesToSeq(cell),\n\t\t\t\t\toldChar: cell.getChars(),\n\t\t\t\t}\n\t\t\t: { isLastChar, pos, oldAttributes: \"\", oldChar: \"\" };\n\n\t\treturn move + VT.DeleteChar;\n\t}\n\n\trollback(cursor: Cursor) {\n\t\tif (!this._appliedAt) {\n\t\t\treturn \"\"; // not applied\n\t\t}\n\n\t\tconst { oldAttributes, oldChar, pos } = this._appliedAt;\n\t\tif (!oldChar) {\n\t\t\treturn cursor.moveTo(pos) + VT.DeleteChar;\n\t\t}\n\n\t\treturn (\n\t\t\toldAttributes +\n\t\t\toldChar +\n\t\t\tcursor.moveTo(pos) +\n\t\t\tattributesToSeq(core(this._terminal)._inputHandler._curAttrData)\n\t\t);\n\t}\n\n\trollForwards() {\n\t\treturn \"\";\n\t}\n\n\tmatches(input: StringReader) {\n\t\tif (this._appliedAt?.isLastChar) {\n\t\t\tconst r1 = input.eatGradually(`\\b${VT.Csi}K`);\n\t\t\tif (r1 !== MatchResult.Failure) {\n\t\t\t\treturn r1;\n\t\t\t}\n\n\t\t\tconst r2 = input.eatGradually(`\\b \\b`);\n\t\t\tif (r2 !== MatchResult.Failure) {\n\t\t\t\treturn r2;\n\t\t\t}\n\t\t}\n\n\t\treturn MatchResult.Failure;\n\t}\n}\n\nclass NewlinePrediction implements IPrediction {\n\tprotected _prevPosition?: ICoordinate;\n\n\tapply(_: IBuffer, cursor: Cursor) {\n\t\tthis._prevPosition = cursor.coordinate;\n\t\tcursor.move(0, cursor.y + 1);\n\t\treturn \"\\r\\n\";\n\t}\n\n\trollback(cursor: Cursor) {\n\t\treturn this._prevPosition ? cursor.moveTo(this._prevPosition) : \"\";\n\t}\n\n\trollForwards() {\n\t\treturn \"\"; // does not need to rewrite\n\t}\n\n\tmatches(input: StringReader) {\n\t\treturn input.eatGradually(\"\\r\\n\");\n\t}\n}\n\n/**\n * Prediction when the cursor reaches the end of the line. Similar to newline\n * prediction, but shells handle it slightly differently.\n */\nclass LinewrapPrediction extends NewlinePrediction implements IPrediction {\n\toverride apply(_: IBuffer, cursor: Cursor) {\n\t\tthis._prevPosition = cursor.coordinate;\n\t\tcursor.move(0, cursor.y + 1);\n\t\treturn \" \\r\";\n\t}\n\n\toverride matches(input: StringReader) {\n\t\t// bash and zshell add a space which wraps in the terminal, then a CR\n\t\tconst r = input.eatGradually(\" \\r\");\n\t\tif (r !== MatchResult.Failure) {\n\t\t\t// zshell additionally adds a clear line after wrapping to be safe -- eat it\n\t\t\tconst r2 = input.eatGradually(VT.DeleteRestOfLine);\n\t\t\treturn r2 === MatchResult.Buffer ? MatchResult.Buffer : r;\n\t\t}\n\n\t\treturn input.eatGradually(\"\\r\\n\");\n\t}\n}\n\nclass CursorMovePrediction implements IPrediction {\n\tprivate _applied?: {\n\t\trollForward: string;\n\t\tprevPosition: number;\n\t\tprevAttrs: string;\n\t\tamount: number;\n\t};\n\n\tconstructor(\n\t\tprivate readonly _direction: CursorMoveDirection,\n\t\tprivate readonly _moveByWords: boolean,\n\t\tprivate readonly _amount: number,\n\t) {}\n\n\tapply(buffer: IBuffer, cursor: Cursor) {\n\t\tconst prevPosition = cursor.x;\n\t\tconst currentCell = cursor.getCell();\n\t\tconst prevAttrs = currentCell ? attributesToSeq(currentCell) : \"\";\n\n\t\tconst {\n\t\t\t_amount: amount,\n\t\t\t_direction: direction,\n\t\t\t_moveByWords: moveByWords,\n\t\t} = this;\n\t\tconst delta = direction === CursorMoveDirection.Back ? -1 : 1;\n\n\t\tconst target = cursor.clone();\n\t\tif (moveByWords) {\n\t\t\tfor (let i = 0; i < amount; i++) {\n\t\t\t\tmoveToWordBoundary(buffer, target, delta);\n\t\t\t}\n\t\t} else {\n\t\t\ttarget.shift(delta * amount);\n\t\t}\n\n\t\tthis._applied = {\n\t\t\tamount: Math.abs(cursor.x - target.x),\n\t\t\tprevPosition,\n\t\t\tprevAttrs,\n\t\t\trollForward: cursor.moveTo(target),\n\t\t};\n\n\t\treturn this._applied.rollForward;\n\t}\n\n\trollback(cursor: Cursor) {\n\t\tif (!this._applied) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\treturn (\n\t\t\tcursor.move(this._applied.prevPosition, cursor.y) +\n\t\t\tthis._applied.prevAttrs\n\t\t);\n\t}\n\n\trollForwards() {\n\t\treturn \"\"; // does not need to rewrite\n\t}\n\n\tmatches(input: StringReader) {\n\t\tif (!this._applied) {\n\t\t\treturn MatchResult.Failure;\n\t\t}\n\n\t\tconst direction = this._direction;\n\t\tconst { amount, rollForward } = this._applied;\n\n\t\t// arg can be omitted to move one character. We don't eatGradually() here\n\t\t// or below moves that don't go as far as the cursor would be buffered\n\t\t// indefinitely\n\t\tif (input.eatStr(`${VT.Csi}${direction}`.repeat(amount))) {\n\t\t\treturn MatchResult.Success;\n\t\t}\n\n\t\t// \\b is the equivalent to moving one character back\n\t\tif (direction === CursorMoveDirection.Back) {\n\t\t\tif (input.eatStr(`\\b`.repeat(amount))) {\n\t\t\t\treturn MatchResult.Success;\n\t\t\t}\n\t\t}\n\n\t\t// check if the cursor position is set absolutely\n\t\tif (rollForward) {\n\t\t\tconst r = input.eatGradually(rollForward);\n\t\t\tif (r !== MatchResult.Failure) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\t// check for a relative move in the direction\n\t\treturn input.eatGradually(`${VT.Csi}${amount}${direction}`);\n\t}\n}\n\nexport class PredictionStats extends Disposable {\n\tprivate readonly _stats: [latency: number, correct: boolean][] = [];\n\tprivate _index = 0;\n\tprivate readonly _addedAtTime = new WeakMap<IPrediction, number>();\n\tprivate readonly _changeEmitter = new Emitter<void>();\n\treadonly onChange = this._changeEmitter.event;\n\n\t/**\n\t * Gets the percent (0-1) of predictions that were accurate.\n\t */\n\tget accuracy() {\n\t\tlet correctCount = 0;\n\t\tfor (const [, correct] of this._stats) {\n\t\t\tif (correct) {\n\t\t\t\tcorrectCount++;\n\t\t\t}\n\t\t}\n\n\t\treturn correctCount / (this._stats.length || 1);\n\t}\n\n\t/**\n\t * Gets the number of recorded stats.\n\t */\n\tget sampleSize() {\n\t\treturn this._stats.length;\n\t}\n\n\t/**\n\t * Gets latency stats of successful predictions.\n\t */\n\tget latency() {\n\t\tconst latencies = this._stats\n\t\t\t.filter(([, correct]) => correct)\n\t\t\t.map(([s]) => s)\n\t\t\t.sort();\n\n\t\treturn {\n\t\t\tcount: latencies.length,\n\t\t\tmin: latencies[0],\n\t\t\tmedian: latencies[Math.floor(latencies.length / 2)],\n\t\t\tmax: latencies[latencies.length - 1],\n\t\t};\n\t}\n\n\t/**\n\t * Gets the maximum observed latency.\n\t */\n\tget maxLatency() {\n\t\tlet max = Number.NEGATIVE_INFINITY;\n\t\tfor (const [latency, correct] of this._stats) {\n\t\t\tif (correct) {\n\t\t\t\tmax = Math.max(latency, max);\n\t\t\t}\n\t\t}\n\n\t\treturn max;\n\t}\n\n\tconstructor(timeline: PredictionTimeline) {\n\t\tsuper();\n\t\tthis._register(\n\t\t\ttimeline.onPredictionAdded((p) =>\n\t\t\t\tthis._addedAtTime.set(p, Date.now()),\n\t\t\t),\n\t\t);\n\t\tthis._register(\n\t\t\ttimeline.onPredictionSucceeded(this._pushStat.bind(this, true)),\n\t\t);\n\t\tthis._register(\n\t\t\ttimeline.onPredictionFailed(this._pushStat.bind(this, false)),\n\t\t);\n\t}\n\n\tprivate _pushStat(correct: boolean, prediction: IPrediction) {\n\t\tconst started = this._addedAtTime.get(prediction)!;\n\t\tthis._stats[this._index] = [Date.now() - started, correct];\n\t\tthis._index = (this._index + 1) % StatsConstants.StatsBufferSize;\n\t\tthis._changeEmitter.fire();\n\t}\n}\n\nexport class PredictionTimeline {\n\t/**\n\t * Expected queue of events. Only predictions for the lowest are\n\t * written into the terminal.\n\t */\n\tprivate _expected: { gen: number; p: IPrediction }[] = [];\n\n\t/**\n\t * Current prediction generation.\n\t */\n\tprivate _currentGen = 0;\n\n\t/**\n\t * Current cursor position -- kept outside the buffer since it can be ahead\n\t * if typing swiftly. The position of the cursor that the user is currently\n\t * looking at on their screen (or will be looking at after all pending writes\n\t * are flushed.)\n\t */\n\tprivate _physicalCursor: Cursor | undefined;\n\n\t/**\n\t * Cursor position taking into account all (possibly not-yet-applied)\n\t * predictions. A new prediction inserted, if applied, will be applied at\n\t * the position of the tentative cursor.\n\t */\n\tprivate _tenativeCursor: Cursor | undefined;\n\n\t/**\n\t * Previously sent data that was buffered and should be prepended to the\n\t * next input.\n\t */\n\tprivate _inputBuffer?: string;\n\n\t/**\n\t * Whether predictions are echoed to the terminal. If false, predictions\n\t * will still be computed internally for latency metrics, but input will\n\t * never be adjusted.\n\t */\n\tprivate _showPredictions = false;\n\n\t/**\n\t * The last successfully-made prediction.\n\t */\n\tprivate _lookBehind?: IPrediction;\n\n\tprivate readonly _addedEmitter = new Emitter<IPrediction>();\n\treadonly onPredictionAdded = this._addedEmitter.event;\n\tprivate readonly _failedEmitter = new Emitter<IPrediction>();\n\treadonly onPredictionFailed = this._failedEmitter.event;\n\tprivate readonly _succeededEmitter = new Emitter<IPrediction>();\n\treadonly onPredictionSucceeded = this._succeededEmitter.event;\n\n\tprivate get _currentGenerationPredictions() {\n\t\treturn this._expected\n\t\t\t.filter(({ gen }) => gen === this._expected[0].gen)\n\t\t\t.map(({ p }) => p);\n\t}\n\n\tget isShowingPredictions() {\n\t\treturn this._showPredictions;\n\t}\n\n\tget length() {\n\t\treturn this._expected.length;\n\t}\n\n\tconstructor(\n\t\treadonly terminal: Terminal,\n\t\tprivate readonly _style: TypeAheadStyle,\n\t) {}\n\n\tsetShowPredictions(show: boolean) {\n\t\tif (show === this._showPredictions) {\n\t\t\treturn;\n\t\t}\n\n\t\t// console.log('set predictions:', show);\n\t\tthis._showPredictions = show;\n\n\t\tconst buffer = this._getActiveBuffer();\n\t\tif (!buffer) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst toApply = this._currentGenerationPredictions;\n\t\tif (show) {\n\t\t\tthis.clearCursor();\n\t\t\tthis._style.expectIncomingStyle(\n\t\t\t\ttoApply.reduce(\n\t\t\t\t\t(count, p) => (p.affectsStyle ? count + 1 : count),\n\t\t\t\t\t0,\n\t\t\t\t),\n\t\t\t);\n\t\t\tthis.terminal.write(\n\t\t\t\ttoApply\n\t\t\t\t\t.map((p) => p.apply(buffer, this.physicalCursor(buffer)))\n\t\t\t\t\t.join(\"\"),\n\t\t\t);\n\t\t} else {\n\t\t\tthis.terminal.write(\n\t\t\t\ttoApply\n\t\t\t\t\t.reverse()\n\t\t\t\t\t.map((p) => p.rollback(this.physicalCursor(buffer)))\n\t\t\t\t\t.join(\"\"),\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Undoes any predictions written and resets expectations.\n\t */\n\tundoAllPredictions() {\n\t\tconst buffer = this._getActiveBuffer();\n\t\tif (this._showPredictions && buffer) {\n\t\t\tthis.terminal.write(\n\t\t\t\tthis._currentGenerationPredictions\n\t\t\t\t\t.reverse()\n\t\t\t\t\t.map((p) => p.rollback(this.physicalCursor(buffer)))\n\t\t\t\t\t.join(\"\"),\n\t\t\t);\n\t\t}\n\n\t\tthis._expected = [];\n\t}\n\n\t/**\n\t * Should be called when input is incoming to the temrinal.\n\t */\n\tbeforeServerInput(input: string): string {\n\t\tconst originalInput = input;\n\t\tif (this._inputBuffer) {\n\t\t\tinput = this._inputBuffer + input;\n\t\t\tthis._inputBuffer = undefined;\n\t\t}\n\n\t\tif (!this._expected.length) {\n\t\t\tthis._clearPredictionState();\n\t\t\treturn input;\n\t\t}\n\n\t\tconst buffer = this._getActiveBuffer();\n\t\tif (!buffer) {\n\t\t\tthis._clearPredictionState();\n\t\t\treturn input;\n\t\t}\n\n\t\tlet output = \"\";\n\n\t\tconst reader = new StringReader(input);\n\t\tconst startingGen = this._expected[0].gen;\n\t\tconst emitPredictionOmitted = () => {\n\t\t\tconst omit = reader.eatRe(PREDICTION_OMIT_RE);\n\t\t\tif (omit) {\n\t\t\t\toutput += omit[0];\n\t\t\t}\n\t\t};\n\n\t\tReadLoop: while (this._expected.length && reader.remaining > 0) {\n\t\t\temitPredictionOmitted();\n\n\t\t\tconst { p: prediction, gen } = this._expected[0];\n\t\t\tconst cursor = this.physicalCursor(buffer);\n\t\t\tconst beforeTestReaderIndex = reader.index;\n\t\t\tswitch (prediction.matches(reader, this._lookBehind)) {\n\t\t\t\tcase MatchResult.Success: {\n\t\t\t\t\t// if the input character matches what the next prediction expected, undo\n\t\t\t\t\t// the prediction and write the real character out.\n\t\t\t\t\tconst eaten = input.slice(\n\t\t\t\t\t\tbeforeTestReaderIndex,\n\t\t\t\t\t\treader.index,\n\t\t\t\t\t);\n\t\t\t\t\tif (gen === startingGen) {\n\t\t\t\t\t\toutput += prediction.rollForwards?.(cursor, eaten);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprediction.apply(buffer, this.physicalCursor(buffer)); // move cursor for additional apply\n\t\t\t\t\t\toutput += eaten;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._succeededEmitter.fire(prediction);\n\t\t\t\t\tthis._lookBehind = prediction;\n\t\t\t\t\tthis._expected.shift();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase MatchResult.Buffer:\n\t\t\t\t\t// on a buffer, store the remaining data and completely read data\n\t\t\t\t\t// to be output as normal.\n\t\t\t\t\tthis._inputBuffer = input.slice(beforeTestReaderIndex);\n\t\t\t\t\treader.index = input.length;\n\t\t\t\t\tbreak ReadLoop;\n\t\t\t\tcase MatchResult.Failure: {\n\t\t\t\t\t// on a failure, roll back all remaining items in this generation\n\t\t\t\t\t// and clear predictions, since they are no longer valid\n\t\t\t\t\tconst rollback = this._expected\n\t\t\t\t\t\t.filter((p) => p.gen === startingGen)\n\t\t\t\t\t\t.reverse();\n\t\t\t\t\toutput += rollback\n\t\t\t\t\t\t.map(({ p }) => p.rollback(this.physicalCursor(buffer)))\n\t\t\t\t\t\t.join(\"\");\n\t\t\t\t\tif (rollback.some((r) => r.p.affectsStyle)) {\n\t\t\t\t\t\t// reading the current style should generally be safe, since predictions\n\t\t\t\t\t\t// always restore the style if they modify it.\n\t\t\t\t\t\toutput += attributesToSeq(\n\t\t\t\t\t\t\tcore(this.terminal)._inputHandler._curAttrData,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tthis._clearPredictionState();\n\t\t\t\t\tthis._failedEmitter.fire(prediction);\n\t\t\t\t\tbreak ReadLoop;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\temitPredictionOmitted();\n\n\t\t// Extra data (like the result of running a command) should cause us to\n\t\t// reset the cursor\n\t\tif (!reader.eof) {\n\t\t\toutput += reader.rest;\n\t\t\tthis._clearPredictionState();\n\t\t}\n\n\t\t// If we passed a generation boundary, apply the current generation's predictions\n\t\tif (this._expected.length && startingGen !== this._expected[0].gen) {\n\t\t\tfor (const { p, gen } of this._expected) {\n\t\t\t\tif (gen !== this._expected[0].gen) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (p.affectsStyle) {\n\t\t\t\t\tthis._style.expectIncomingStyle();\n\t\t\t\t}\n\n\t\t\t\toutput += p.apply(buffer, this.physicalCursor(buffer));\n\t\t\t}\n\t\t}\n\n\t\tif (!this._showPredictions) {\n\t\t\treturn originalInput;\n\t\t}\n\n\t\tif (output.length === 0 || output === input) {\n\t\t\treturn output;\n\t\t}\n\n\t\tif (this._physicalCursor) {\n\t\t\toutput += this._physicalCursor.moveInstruction();\n\t\t}\n\n\t\t// prevent cursor flickering while typing\n\t\toutput = VT.HideCursor + output + VT.ShowCursor;\n\n\t\treturn output;\n\t}\n\n\t/**\n\t * Clears any expected predictions and stored state. Should be called when\n\t * the pty gives us something we don't recognize.\n\t */\n\tprivate _clearPredictionState() {\n\t\tthis._expected = [];\n\t\tthis.clearCursor();\n\t\tthis._lookBehind = undefined;\n\t}\n\n\t/**\n\t * Appends a typeahead prediction.\n\t */\n\taddPrediction(buffer: IBuffer, prediction: IPrediction) {\n\t\tthis._expected.push({ gen: this._currentGen, p: prediction });\n\t\tthis._addedEmitter.fire(prediction);\n\n\t\tif (this._currentGen !== this._expected[0].gen) {\n\t\t\tprediction.apply(buffer, this.tentativeCursor(buffer));\n\t\t\treturn false;\n\t\t}\n\n\t\tconst text = prediction.apply(buffer, this.physicalCursor(buffer));\n\t\tthis._tenativeCursor = undefined; // next read will get or clone the physical cursor\n\n\t\tif (this._showPredictions && text) {\n\t\t\tif (prediction.affectsStyle) {\n\t\t\t\tthis._style.expectIncomingStyle();\n\t\t\t}\n\t\t\t// console.log('predict:', JSON.stringify(text));\n\t\t\tthis.terminal.write(text);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Appends a prediction followed by a boundary. The predictions applied\n\t * after this one will only be displayed after the give prediction matches\n\t * pty output/\n\t */\n\taddBoundary(): void;\n\taddBoundary(buffer: IBuffer, prediction: IPrediction): boolean;\n\taddBoundary(buffer?: IBuffer, prediction?: IPrediction) {\n\t\tlet applied = false;\n\t\tif (buffer && prediction) {\n\t\t\t// We apply the prediction so that it's matched against, but wrapped\n\t\t\t// in a tentativeboundary so that it doesn't affect the physical cursor.\n\t\t\t// Then we apply it specifically to the tentative cursor.\n\t\t\tapplied = this.addPrediction(\n\t\t\t\tbuffer,\n\t\t\t\tnew TentativeBoundary(prediction),\n\t\t\t);\n\t\t\tprediction.apply(buffer, this.tentativeCursor(buffer));\n\t\t}\n\t\tthis._currentGen++;\n\t\treturn applied;\n\t}\n\n\t/**\n\t * Peeks the last prediction written.\n\t */\n\tpeekEnd(): IPrediction | undefined {\n\t\treturn this._expected[this._expected.length - 1]?.p;\n\t}\n\n\t/**\n\t * Peeks the first pending prediction.\n\t */\n\tpeekStart(): IPrediction | undefined {\n\t\treturn this._expected[0]?.p;\n\t}\n\n\t/**\n\t * Current position of the cursor in the terminal.\n\t */\n\tphysicalCursor(buffer: IBuffer) {\n\t\tif (!this._physicalCursor) {\n\t\t\tif (this._showPredictions) {\n\t\t\t\tflushOutput(this.terminal);\n\t\t\t}\n\t\t\tthis._physicalCursor = new Cursor(\n\t\t\t\tthis.terminal.rows,\n\t\t\t\tthis.terminal.cols,\n\t\t\t\tbuffer,\n\t\t\t);\n\t\t}\n\n\t\treturn this._physicalCursor;\n\t}\n\n\t/**\n\t * Cursor position if all predictions and boundaries that have been inserted\n\t * so far turn out to be successfully predicted.\n\t */\n\ttentativeCursor(buffer: IBuffer) {\n\t\tif (!this._tenativeCursor) {\n\t\t\tthis._tenativeCursor = this.physicalCursor(buffer).clone();\n\t\t}\n\n\t\treturn this._tenativeCursor;\n\t}\n\n\tclearCursor() {\n\t\tthis._physicalCursor = undefined;\n\t\tthis._tenativeCursor = undefined;\n\t}\n\n\tprivate _getActiveBuffer() {\n\t\tconst buffer = this.terminal.buffer.active;\n\t\treturn buffer.type === \"normal\" ? buffer : undefined;\n\t}\n}\n\n/**\n * Gets the escape sequence args to restore state/appearance in the cell.\n */\nconst attributesToArgs = (cell: XtermAttributes) => {\n\tif (cell.isAttributeDefault()) {\n\t\treturn [0];\n\t}\n\n\tconst args = [];\n\tif (cell.isBold()) {\n\t\targs.push(1);\n\t}\n\tif (cell.isDim()) {\n\t\targs.push(2);\n\t}\n\tif (cell.isItalic()) {\n\t\targs.push(3);\n\t}\n\tif (cell.isUnderline()) {\n\t\targs.push(4);\n\t}\n\tif (cell.isBlink()) {\n\t\targs.push(5);\n\t}\n\tif (cell.isInverse()) {\n\t\targs.push(7);\n\t}\n\tif (cell.isInvisible()) {\n\t\targs.push(8);\n\t}\n\n\tif (cell.isFgRGB()) {\n\t\targs.push(\n\t\t\t38,\n\t\t\t2,\n\t\t\tcell.getFgColor() >>> 24,\n\t\t\t(cell.getFgColor() >>> 16) & 0xff,\n\t\t\tcell.getFgColor() & 0xff,\n\t\t);\n\t}\n\tif (cell.isFgPalette()) {\n\t\targs.push(38, 5, cell.getFgColor());\n\t}\n\tif (cell.isFgDefault()) {\n\t\targs.push(39);\n\t}\n\n\tif (cell.isBgRGB()) {\n\t\targs.push(\n\t\t\t48,\n\t\t\t2,\n\t\t\tcell.getBgColor() >>> 24,\n\t\t\t(cell.getBgColor() >>> 16) & 0xff,\n\t\t\tcell.getBgColor() & 0xff,\n\t\t);\n\t}\n\tif (cell.isBgPalette()) {\n\t\targs.push(48, 5, cell.getBgColor());\n\t}\n\tif (cell.isBgDefault()) {\n\t\targs.push(49);\n\t}\n\n\treturn args;\n};\n\n/**\n * Gets the escape sequence to restore state/appearance in the cell.\n */\nconst attributesToSeq = (cell: XtermAttributes) =>\n\t`${VT.Csi}${attributesToArgs(cell).join(\";\")}m`;\n\nconst arrayHasPrefixAt = <T>(\n\ta: ReadonlyArray<T>,\n\tai: number,\n\tb: ReadonlyArray<T>,\n) => {\n\tif (a.length - ai > b.length) {\n\t\treturn false;\n\t}\n\n\tfor (let bi = 0; bi < b.length; bi++, ai++) {\n\t\tif (b[ai] !== a[ai]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n};\n\n/**\n * @see https://github.com/xtermjs/xterm.js/blob/065eb13a9d3145bea687239680ec9696d9112b8e/src/common/InputHandler.ts#L2127\n */\nconst getColorWidth = (params: (number | number[])[], pos: number) => {\n\tconst accu = [0, 0, -1, 0, 0, 0];\n\tlet cSpace = 0;\n\tlet advance = 0;\n\n\tdo {\n\t\tconst v = params[pos + advance];\n\t\taccu[advance + cSpace] = typeof v === \"number\" ? v : v[0];\n\t\tif (typeof v !== \"number\") {\n\t\t\tlet i = 0;\n\t\t\tdo {\n\t\t\t\tif (accu[1] === 5) {\n\t\t\t\t\tcSpace = 1;\n\t\t\t\t}\n\t\t\t\taccu[advance + i + 1 + cSpace] = v[i];\n\t\t\t} while (++i < v.length && i + advance + 1 + cSpace < accu.length);\n\t\t\tbreak;\n\t\t}\n\t\t// exit early if can decide color mode with semicolons\n\t\tif (\n\t\t\t(accu[1] === 5 && advance + cSpace >= 2) ||\n\t\t\t(accu[1] === 2 && advance + cSpace >= 5)\n\t\t) {\n\t\t\tbreak;\n\t\t}\n\t\t// offset colorSpace slot for semicolon mode\n\t\tif (accu[1]) {\n\t\t\tcSpace = 1;\n\t\t}\n\t} while (++advance + pos < params.length && advance + cSpace < accu.length);\n\n\treturn advance;\n};\n\nclass TypeAheadStyle implements IDisposable {\n\tprivate static _compileArgs(args: ReadonlyArray<number>) {\n\t\treturn `${VT.Csi}${args.join(\";\")}m`;\n\t}\n\n\t/**\n\t * Number of typeahead style arguments we expect to read. If this is 0 and\n\t * we see a style coming in, we know that the PTY actually wanted to update.\n\t */\n\tprivate _expectedIncomingStyles = 0;\n\tprivate _applyArgs!: ReadonlyArray<number>;\n\tprivate _originalUndoArgs!: ReadonlyArray<number>;\n\tprivate _undoArgs!: ReadonlyArray<number>;\n\n\tapply!: string;\n\tundo!: string;\n\tprivate _csiHandler?: IDisposable;\n\n\tconstructor(\n\t\tvalue: ITerminalTypeAheadConfiguration[\"localEchoStyle\"],\n\t\tprivate readonly _terminal: Terminal,\n\t) {\n\t\tthis.onUpdate(value);\n\t}\n\n\t/**\n\t * Signals that a style was written to the terminal and we should watch\n\t * for it coming in.\n\t */\n\texpectIncomingStyle(n = 1) {\n\t\tthis._expectedIncomingStyles += n * 2;\n\t}\n\n\t/**\n\t * Starts tracking for CSI changes in the terminal.\n\t */\n\tstartTracking() {\n\t\tthis._expectedIncomingStyles = 0;\n\t\tthis._onDidWriteSGR(\n\t\t\tattributesToArgs(core(this._terminal)._inputHandler._curAttrData),\n\t\t);\n\t\tthis._csiHandler = this._terminal.parser.registerCsiHandler(\n\t\t\t{ final: \"m\" },\n\t\t\t(args) => {\n\t\t\t\tthis._onDidWriteSGR(args);\n\t\t\t\treturn false;\n\t\t\t},\n\t\t);\n\t}\n\n\t/**\n\t * Stops tracking terminal CSI changes.\n\t */\n\t@debounce(2000)\n\tdebounceStopTracking() {\n\t\tthis._stopTracking();\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tdispose() {\n\t\tthis._stopTracking();\n\t}\n\n\tprivate _stopTracking() {\n\t\tthis._csiHandler?.dispose();\n\t\tthis._csiHandler = undefined;\n\t}\n\n\tprivate _onDidWriteSGR(args: (number | number[])[]) {\n\t\tconst originalUndo = this._undoArgs;\n\t\tfor (let i = 0; i < args.length; ) {\n\t\t\tconst px = args[i];\n\t\t\tconst p = typeof px === \"number\" ? px : px[0];\n\n\t\t\tif (this._expectedIncomingStyles) {\n\t\t\t\tif (arrayHasPrefixAt(args, i, this._undoArgs)) {\n\t\t\t\t\tthis._expectedIncomingStyles--;\n\t\t\t\t\ti += this._undoArgs.length;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (arrayHasPrefixAt(args, i, this._applyArgs)) {\n\t\t\t\t\tthis._expectedIncomingStyles--;\n\t\t\t\t\ti += this._applyArgs.length;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst width =\n\t\t\t\tp === 38 || p === 48 || p === 58 ? getColorWidth(args, i) : 1;\n\t\t\tswitch (this._applyArgs[0]) {\n\t\t\t\tcase 1:\n\t\t\t\t\tif (p === 2) {\n\t\t\t\t\t\tthis._undoArgs = [22, 2];\n\t\t\t\t\t} else if (p === 22 || p === 0) {\n\t\t\t\t\t\tthis._undoArgs = [22];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tif (p === 1) {\n\t\t\t\t\t\tthis._undoArgs = [22, 1];\n\t\t\t\t\t} else if (p === 22 || p === 0) {\n\t\t\t\t\t\tthis._undoArgs = [22];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 38:\n\t\t\t\t\tif (p === 0 || p === 39 || p === 100) {\n\t\t\t\t\t\tthis._undoArgs = [39];\n\t\t\t\t\t} else if ((p >= 30 && p <= 38) || (p >= 90 && p <= 97)) {\n\t\t\t\t\t\tthis._undoArgs = args.slice(i, i + width) as number[];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (p === this._applyArgs[0]) {\n\t\t\t\t\t\tthis._undoArgs = this._applyArgs;\n\t\t\t\t\t} else if (p === 0) {\n\t\t\t\t\t\tthis._undoArgs = this._originalUndoArgs;\n\t\t\t\t\t}\n\t\t\t\t// no-op\n\t\t\t}\n\n\t\t\ti += width;\n\t\t}\n\n\t\tif (originalUndo !== this._undoArgs) {\n\t\t\tthis.undo = TypeAheadStyle._compileArgs(this._undoArgs);\n\t\t}\n\t}\n\n\t/**\n\t * Updates the current typeahead style.\n\t */\n\tonUpdate(style: ITerminalTypeAheadConfiguration[\"localEchoStyle\"]) {\n\t\tconst { applyArgs, undoArgs } = this._getArgs(style);\n\t\tthis._applyArgs = applyArgs;\n\t\tthis._undoArgs = this._originalUndoArgs = undoArgs;\n\t\tthis.apply = TypeAheadStyle._compileArgs(this._applyArgs);\n\t\tthis.undo = TypeAheadStyle._compileArgs(this._undoArgs);\n\t}\n\n\tprivate _getArgs(style: ITerminalTypeAheadConfiguration[\"localEchoStyle\"]) {\n\t\tswitch (style) {\n\t\t\tcase \"bold\":\n\t\t\t\treturn { applyArgs: [1], undoArgs: [22] };\n\t\t\tcase \"dim\":\n\t\t\t\treturn { applyArgs: [2], undoArgs: [22] };\n\t\t\tcase \"italic\":\n\t\t\t\treturn { applyArgs: [3], undoArgs: [23] };\n\t\t\tcase \"underlined\":\n\t\t\t\treturn { applyArgs: [4], undoArgs: [24] };\n\t\t\tcase \"inverted\":\n\t\t\t\treturn { applyArgs: [7], undoArgs: [27] };\n\t\t\tdefault: {\n\t\t\t\tlet color: Color;\n\t\t\t\ttry {\n\t\t\t\t\tcolor = Color.fromHex(style);\n\t\t\t\t} catch {\n\t\t\t\t\tcolor = new Color(new RGBA(255, 0, 0, 1));\n\t\t\t\t}\n\n\t\t\t\tconst { r, g, b } = color.rgba;\n\t\t\t\treturn { applyArgs: [38, 2, r, g, b], undoArgs: [39] };\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst compileExcludeRegexp = (programs = DEFAULT_LOCAL_ECHO_EXCLUDE) =>\n\tnew RegExp(\n\t\t`\\\\b(${programs.map(escapeRegExpCharacters).join(\"|\")})\\\\b`,\n\t\t\"i\",\n\t);\n\nexport enum CharPredictState {\n\t/** No characters typed on this line yet */\n\tUnknown = 0,\n\t/** Has a pending character prediction */\n\tHasPendingChar = 1,\n\t/** Character validated on this line */\n\tValidated = 2,\n}\n\nexport class TypeAheadAddon extends Disposable implements ITerminalAddon {\n\tprivate _typeaheadStyle?: TypeAheadStyle;\n\tprivate _typeaheadThreshold =\n\t\tthis._configurationService.getValue<ITerminalTypeAheadConfiguration>(\n\t\t\tTERMINAL_CONFIG_SECTION,\n\t\t).localEchoLatencyThreshold;\n\tprivate _excludeProgramRe = compileExcludeRegexp(\n\t\tthis._configurationService.getValue<ITerminalTypeAheadConfiguration>(\n\t\t\tTERMINAL_CONFIG_SECTION,\n\t\t).localEchoExcludePrograms,\n\t);\n\tprotected _lastRow?: {\n\t\ty: number;\n\t\tstartingX: number;\n\t\tendingX: number;\n\t\tcharState: CharPredictState;\n\t};\n\tprotected _timeline?: PredictionTimeline;\n\tprivate _terminalTitle = \"\";\n\tstats?: PredictionStats;\n\n\t/**\n\t * Debounce that clears predictions after a timeout if the PTY doesn't apply them.\n\t */\n\tprivate _clearPredictionDebounce?: IDisposable;\n\n\tconstructor(\n\t\tprivate _processManager: ITerminalProcessManager,\n\t\t@IConfigurationService private readonly _configurationService: IConfigurationService,\n\t\t@ITelemetryService private readonly _telemetryService: ITelemetryService,\n\t) {\n\t\tsuper();\n\t\tthis._register(toDisposable(() => this._clearPredictionDebounce?.dispose()));\n\t}\n\n\tactivate(terminal: Terminal): void {\n\t\tconst style = (this._typeaheadStyle = this._register(\n\t\t\tnew TypeAheadStyle(\n\t\t\t\tthis._configurationService.getValue<ITerminalTypeAheadConfiguration>(\n\t\t\t\t\tTERMINAL_CONFIG_SECTION,\n\t\t\t\t).localEchoStyle,\n\t\t\t\tterminal,\n\t\t\t),\n\t\t));\n\t\tconst timeline = (this._timeline = new PredictionTimeline(\n\t\t\tterminal,\n\t\t\tthis._typeaheadStyle,\n\t\t));\n\t\tconst stats = (this.stats = this._register(\n\t\t\tnew PredictionStats(this._timeline),\n\t\t));\n\n\t\ttimeline.setShowPredictions(this._typeaheadThreshold === 0);\n\t\tthis._register(terminal.onData((e) => this._onUserData(e)));\n\t\tthis._register(\n\t\t\tterminal.onTitleChange((title) => {\n\t\t\t\tthis._terminalTitle = title;\n\t\t\t\tthis._reevaluatePredictorState(stats, timeline);\n\t\t\t}),\n\t\t);\n\t\tthis._register(\n\t\t\tterminal.onResize(() => {\n\t\t\t\ttimeline.setShowPredictions(false);\n\t\t\t\ttimeline.clearCursor();\n\t\t\t\tthis._reevaluatePredictorState(stats, timeline);\n\t\t\t}),\n\t\t);\n\t\tthis._register(\n\t\t\tthis._configurationService.onDidChangeConfiguration((e) => {\n\t\t\t\tif (e.affectsConfiguration(TERMINAL_CONFIG_SECTION)) {\n\t\t\t\t\tstyle.onUpdate(\n\t\t\t\t\t\tthis._configurationService.getValue<ITerminalTypeAheadConfiguration>(\n\t\t\t\t\t\t\tTERMINAL_CONFIG_SECTION,\n\t\t\t\t\t\t).localEchoStyle,\n\t\t\t\t\t);\n\t\t\t\t\tthis._typeaheadThreshold =\n\t\t\t\t\t\tthis._configurationService.getValue<ITerminalTypeAheadConfiguration>(\n\t\t\t\t\t\t\tTERMINAL_CONFIG_SECTION,\n\t\t\t\t\t\t).localEchoLatencyThreshold;\n\t\t\t\t\tthis._excludeProgramRe = compileExcludeRegexp(\n\t\t\t\t\t\tthis._configurationService.getValue<ITerminalTypeAheadConfiguration>(\n\t\t\t\t\t\t\tTERMINAL_CONFIG_SECTION,\n\t\t\t\t\t\t).localEchoExcludePrograms,\n\t\t\t\t\t);\n\t\t\t\t\tthis._reevaluatePredictorState(stats, timeline);\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\t\tthis._register(\n\t\t\tthis._timeline.onPredictionSucceeded((p) => {\n\t\t\t\tif (\n\t\t\t\t\tthis._lastRow?.charState ===\n\t\t\t\t\t\tCharPredictState.HasPendingChar &&\n\t\t\t\t\tisTenativeCharacterPrediction(p) &&\n\t\t\t\t\tp.inner.appliedAt\n\t\t\t\t) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tp.inner.appliedAt.pos.y +\n\t\t\t\t\t\t\tp.inner.appliedAt.pos.baseY ===\n\t\t\t\t\t\tthis._lastRow.y\n\t\t\t\t\t) {\n\t\t\t\t\t\tthis._lastRow.charState = CharPredictState.Validated;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\t\tthis._register(\n\t\t\tthis._processManager.onBeforeProcessData((e) =>\n\t\t\t\tthis._onBeforeProcessData(e),\n\t\t\t),\n\t\t);\n\n\t\tlet nextStatsSend: any;\n\t\tthis._register(\n\t\t\tstats.onChange(() => {\n\t\t\t\tif (!nextStatsSend) {\n\t\t\t\t\tnextStatsSend = setTimeout(() => {\n\t\t\t\t\t\tthis._sendLatencyStats(stats);\n\t\t\t\t\t\tnextStatsSend = undefined;\n\t\t\t\t\t}, StatsConstants.StatsSendTelemetryEvery);\n\t\t\t\t}\n\n\t\t\t\tif (timeline.length === 0) {\n\t\t\t\t\tstyle.debounceStopTracking();\n\t\t\t\t}\n\n\t\t\t\tthis._reevaluatePredictorState(stats, timeline);\n\t\t\t}),\n\t\t);\n\t}\n\n\treset() {\n\t\tthis._lastRow = undefined;\n\t}\n\n\tprivate _deferClearingPredictions() {\n\t\tif (!this.stats || !this._timeline) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._clearPredictionDebounce?.dispose();\n\t\tif (\n\t\t\tthis._timeline.length === 0 ||\n\t\t\tthis._timeline.peekStart()?.clearAfterTimeout === false\n\t\t) {\n\t\t\tthis._clearPredictionDebounce = undefined;\n\t\t\treturn;\n\t\t}\n\n\t\tthis._clearPredictionDebounce = disposableTimeout(\n\t\t\t() => {\n\t\t\t\tthis._timeline?.undoAllPredictions();\n\t\t\t\tif (\n\t\t\t\t\tthis._lastRow?.charState === CharPredictState.HasPendingChar\n\t\t\t\t) {\n\t\t\t\t\tthis._lastRow.charState = CharPredictState.Unknown;\n\t\t\t\t}\n\t\t\t},\n\t\t\tMath.max(500, (this.stats.maxLatency * 3) / 2),\n\t\t\tthis._store,\n\t\t);\n\t}\n\n\t/**\n\t * Note on debounce:\n\t *\n\t * We want to toggle the state only when the user has a pause in their\n\t * typing. Otherwise, we could turn this on when the PTY sent data but the\n\t * terminal cursor is not updated, causes issues.\n\t */\n\t@debounce(100)\n\tprotected _reevaluatePredictorState(\n\t\tstats: PredictionStats,\n\t\ttimeline: PredictionTimeline,\n\t) {\n\t\tthis._reevaluatePredictorStateNow(stats, timeline);\n\t}\n\n\tprotected _reevaluatePredictorStateNow(\n\t\tstats: PredictionStats,\n\t\ttimeline: PredictionTimeline,\n\t) {\n\t\tif (this._excludeProgramRe.test(this._terminalTitle)) {\n\t\t\ttimeline.setShowPredictions(false);\n\t\t} else if (this._typeaheadThreshold < 0) {\n\t\t\ttimeline.setShowPredictions(false);\n\t\t} else if (this._typeaheadThreshold === 0) {\n\t\t\ttimeline.setShowPredictions(true);\n\t\t} else if (\n\t\t\tstats.sampleSize > StatsConstants.StatsMinSamplesToTurnOn &&\n\t\t\tstats.accuracy > StatsConstants.StatsMinAccuracyToTurnOn\n\t\t) {\n\t\t\tconst latency = stats.latency.median;\n\t\t\tif (latency >= this._typeaheadThreshold) {\n\t\t\t\ttimeline.setShowPredictions(true);\n\t\t\t} else if (\n\t\t\t\tlatency <\n\t\t\t\tthis._typeaheadThreshold /\n\t\t\t\t\tStatsConstants.StatsToggleOffThreshold\n\t\t\t) {\n\t\t\t\ttimeline.setShowPredictions(false);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _sendLatencyStats(stats: PredictionStats) {\n\t\t/* __GDPR__\n\t\t\t\"terminalLatencyStats\" : {\n\t\t\t\t\"owner\": \"Tyriar\",\n\t\t\t\t\"min\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\t\t\"max\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\t\t\"median\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\t\t\"count\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\t\t\"predictionAccuracy\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true }\n\t\t\t}\n\t\t */\n\t\tthis._telemetryService.publicLog(\"terminalLatencyStats\", {\n\t\t\t...stats.latency,\n\t\t\tpredictionAccuracy: stats.accuracy,\n\t\t});\n\t}\n\n\tprivate _onUserData(data: string): void {\n\t\tif (this._timeline?.terminal.buffer.active.type !== \"normal\") {\n\t\t\treturn;\n\t\t}\n\n\t\t// console.log('user data:', JSON.stringify(data));\n\n\t\tconst terminal = this._timeline.terminal;\n\t\tconst buffer = terminal.buffer.active;\n\n\t\t// Detect programs like git log/less that use the normal buffer but don't\n\t\t// take input by deafult (fixes #109541)\n\t\tif (buffer.cursorX === 1 && buffer.cursorY === terminal.rows - 1) {\n\t\t\tif (\n\t\t\t\tbuffer\n\t\t\t\t\t.getLine(buffer.cursorY + buffer.baseY)\n\t\t\t\t\t?.getCell(0)\n\t\t\t\t\t?.getChars() === \":\"\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// the following code guards the terminal prompt to avoid being able to\n\t\t// arrow or backspace-into the prompt. Record the lowest X value at which\n\t\t// the user gave input, and mark all additions before that as tentative.\n\t\tconst actualY = buffer.baseY + buffer.cursorY;\n\t\tif (actualY !== this._lastRow?.y) {\n\t\t\tthis._lastRow = {\n\t\t\t\ty: actualY,\n\t\t\t\tstartingX: buffer.cursorX,\n\t\t\t\tendingX: buffer.cursorX,\n\t\t\t\tcharState: CharPredictState.Unknown,\n\t\t\t};\n\t\t} else {\n\t\t\tthis._lastRow.startingX = Math.min(\n\t\t\t\tthis._lastRow.startingX,\n\t\t\t\tbuffer.cursorX,\n\t\t\t);\n\t\t\tthis._lastRow.endingX = Math.max(\n\t\t\t\tthis._lastRow.endingX,\n\t\t\t\tthis._timeline.physicalCursor(buffer).x,\n\t\t\t);\n\t\t}\n\n\t\tconst addLeftNavigating = (p: IPrediction) =>\n\t\t\tthis._timeline!.tentativeCursor(buffer).x <=\n\t\t\tthis._lastRow!.startingX\n\t\t\t\t? this._timeline!.addBoundary(buffer, p)\n\t\t\t\t: this._timeline!.addPrediction(buffer, p);\n\n\t\tconst addRightNavigating = (p: IPrediction) =>\n\t\t\tthis._timeline!.tentativeCursor(buffer).x >=\n\t\t\tthis._lastRow!.endingX - 1\n\t\t\t\t? this._timeline!.addBoundary(buffer, p)\n\t\t\t\t: this._timeline!.addPrediction(buffer, p);\n\n\t\t/** @see https://github.com/xtermjs/xterm.js/blob/1913e9512c048e3cf56bb5f5df51bfff6899c184/src/common/input/Keyboard.ts */\n\t\tconst reader = new StringReader(data);\n\t\twhile (reader.remaining > 0) {\n\t\t\tif (reader.eatCharCode(127)) {\n\t\t\t\t// backspace\n\t\t\t\tconst previous = this._timeline.peekEnd();\n\t\t\t\tif (previous && previous instanceof CharacterPrediction) {\n\t\t\t\t\tthis._timeline.addBoundary();\n\t\t\t\t}\n\n\t\t\t\t// backspace must be able to read the previously-written character in\n\t\t\t\t// the event that it needs to undo it\n\t\t\t\tif (this._timeline.isShowingPredictions) {\n\t\t\t\t\tflushOutput(this._timeline.terminal);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tthis._timeline.tentativeCursor(buffer).x <=\n\t\t\t\t\tthis._lastRow.startingX\n\t\t\t\t) {\n\t\t\t\t\tthis._timeline.addBoundary(\n\t\t\t\t\t\tbuffer,\n\t\t\t\t\t\tnew BackspacePrediction(this._timeline.terminal),\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\t// Backspace decrements our ability to go right.\n\t\t\t\t\tthis._lastRow.endingX--;\n\t\t\t\t\tthis._timeline.addPrediction(\n\t\t\t\t\t\tbuffer,\n\t\t\t\t\t\tnew BackspacePrediction(this._timeline.terminal),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (reader.eatCharCode(32, 126)) {\n\t\t\t\t// alphanum\n\t\t\t\tconst char = data[reader.index - 1];\n\t\t\t\tconst prediction = new CharacterPrediction(\n\t\t\t\t\tthis._typeaheadStyle!,\n\t\t\t\t\tchar,\n\t\t\t\t);\n\t\t\t\tif (this._lastRow.charState === CharPredictState.Unknown) {\n\t\t\t\t\tthis._timeline.addBoundary(buffer, prediction);\n\t\t\t\t\tthis._lastRow.charState = CharPredictState.HasPendingChar;\n\t\t\t\t} else {\n\t\t\t\t\tthis._timeline.addPrediction(buffer, prediction);\n\t\t\t\t}\n\n\t\t\t\tif (this._timeline.tentativeCursor(buffer).x >= terminal.cols) {\n\t\t\t\t\tthis._timeline.addBoundary(\n\t\t\t\t\t\tbuffer,\n\t\t\t\t\t\tnew LinewrapPrediction(),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst cursorMv = reader.eatRe(CSI_MOVE_RE);\n\t\t\tif (cursorMv) {\n\t\t\t\tconst direction = cursorMv[3] as CursorMoveDirection;\n\t\t\t\tconst p = new CursorMovePrediction(\n\t\t\t\t\tdirection,\n\t\t\t\t\t!!cursorMv[2],\n\t\t\t\t\tNumber(cursorMv[1]) || 1,\n\t\t\t\t);\n\t\t\t\tif (direction === CursorMoveDirection.Back) {\n\t\t\t\t\taddLeftNavigating(p);\n\t\t\t\t} else {\n\t\t\t\t\taddRightNavigating(p);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (reader.eatStr(`${VT.Esc}f`)) {\n\t\t\t\taddRightNavigating(\n\t\t\t\t\tnew CursorMovePrediction(\n\t\t\t\t\t\tCursorMoveDirection.Forwards,\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t1,\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (reader.eatStr(`${VT.Esc}b`)) {\n\t\t\t\taddLeftNavigating(\n\t\t\t\t\tnew CursorMovePrediction(CursorMoveDirection.Back, true, 1),\n\t\t\t\t);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (reader.eatChar(\"\\r\") && buffer.cursorY < terminal.rows - 1) {\n\t\t\t\tthis._timeline.addPrediction(buffer, new NewlinePrediction());\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// something else\n\t\t\tthis._timeline.addBoundary(buffer, new HardBoundary());\n\t\t\tbreak;\n\t\t}\n\n\t\tif (this._timeline.length === 1) {\n\t\t\tthis._deferClearingPredictions();\n\t\t\tthis._typeaheadStyle!.startTracking();\n\t\t}\n\t}\n\n\tprivate _onBeforeProcessData(event: IBeforeProcessDataEvent): void {\n\t\tif (!this._timeline) {\n\t\t\treturn;\n\t\t}\n\n\t\t// console.log('incoming data:', JSON.stringify(event.data));\n\t\tevent.data = this._timeline.beforeServerInput(event.data);\n\t\t// console.log('emitted data:', JSON.stringify(event.data));\n\n\t\tthis._deferClearingPredictions();\n\t}\n}\n"],
  "mappings": "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",
  "names": ["VT", "StatsConstants", "CursorMoveDirection", "MatchResult", "CharPredictState"]
}
