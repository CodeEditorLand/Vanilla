{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/terminalContrib/typeAhead/browser/terminalTypeAheadAddon.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { disposableTimeout } from '../../../../../base/common/async.js';\nimport { Color, RGBA } from '../../../../../base/common/color.js';\nimport { debounce } from '../../../../../base/common/decorators.js';\nimport { Emitter } from '../../../../../base/common/event.js';\nimport { Disposable, toDisposable } from '../../../../../base/common/lifecycle.js';\nimport { escapeRegExpCharacters } from '../../../../../base/common/strings.js';\nimport { IConfigurationService } from '../../../../../platform/configuration/common/configuration.js';\nimport { ITelemetryService } from '../../../../../platform/telemetry/common/telemetry.js';\nimport { XtermAttributes, IXtermCore } from '../../../terminal/browser/xterm-private.js';\nimport { IBeforeProcessDataEvent, ITerminalProcessManager, TERMINAL_CONFIG_SECTION } from '../../../terminal/common/terminal.js';\nimport type { IBuffer, IBufferCell, IDisposable, ITerminalAddon, Terminal } from '@xterm/xterm';\nimport { DEFAULT_LOCAL_ECHO_EXCLUDE, type ITerminalTypeAheadConfiguration } from '../common/terminalTypeAheadConfiguration.js';\n\nconst enum VT {\n\tEsc = '\\x1b',\n\tCsi = `\\x1b[`,\n\tShowCursor = `\\x1b[?25h`,\n\tHideCursor = `\\x1b[?25l`,\n\tDeleteChar = `\\x1b[X`,\n\tDeleteRestOfLine = `\\x1b[K`,\n}\n\nconst CSI_STYLE_RE = /^\\x1b\\[[0-9;]*m/;\nconst CSI_MOVE_RE = /^\\x1b\\[?([0-9]*)(;[35])?O?([DC])/;\nconst NOT_WORD_RE = /[^a-z0-9]/i;\n\nconst enum StatsConstants {\n\tStatsBufferSize = 24,\n\tStatsSendTelemetryEvery = 1000 * 60 * 5, // how often to collect stats\n\tStatsMinSamplesToTurnOn = 5,\n\tStatsMinAccuracyToTurnOn = 0.3,\n\tStatsToggleOffThreshold = 0.5, // if latency is less than `threshold * this`, turn off\n}\n\n/**\n * Codes that should be omitted from sending to the prediction engine and instead omitted directly:\n * - Hide cursor (DECTCEM): We wrap the local echo sequence in hide and show\n *   CSI ? 2 5 l\n * - Show cursor (DECTCEM): We wrap the local echo sequence in hide and show\n *   CSI ? 2 5 h\n * - Device Status Report (DSR): These sequence fire report events from xterm which could cause\n *   double reporting and potentially a stack overflow (#119472)\n *   CSI Ps n\n *   CSI ? Ps n\n */\nconst PREDICTION_OMIT_RE = /^(\\x1b\\[(\\??25[hl]|\\??[0-9;]+n))+/;\n\nconst core = (terminal: Terminal): IXtermCore => (terminal as any)._core;\nconst flushOutput = (terminal: Terminal) => {\n\t// TODO: Flushing output is not possible anymore without async\n};\n\nconst enum CursorMoveDirection {\n\tBack = 'D',\n\tForwards = 'C',\n}\n\ninterface ICoordinate {\n\tx: number;\n\ty: number;\n\tbaseY: number;\n}\n\nclass Cursor implements ICoordinate {\n\tprivate _x = 0;\n\tprivate _y = 1;\n\tprivate _baseY = 1;\n\n\tget x() {\n\t\treturn this._x;\n\t}\n\n\tget y() {\n\t\treturn this._y;\n\t}\n\n\tget baseY() {\n\t\treturn this._baseY;\n\t}\n\n\tget coordinate(): ICoordinate {\n\t\treturn { x: this._x, y: this._y, baseY: this._baseY };\n\t}\n\n\tconstructor(\n\t\treadonly rows: number,\n\t\treadonly cols: number,\n\t\tprivate readonly _buffer: IBuffer\n\t) {\n\t\tthis._x = _buffer.cursorX;\n\t\tthis._y = _buffer.cursorY;\n\t\tthis._baseY = _buffer.baseY;\n\t}\n\n\tgetLine() {\n\t\treturn this._buffer.getLine(this._y + this._baseY);\n\t}\n\n\tgetCell(loadInto?: IBufferCell) {\n\t\treturn this.getLine()?.getCell(this._x, loadInto);\n\t}\n\n\tmoveTo(coordinate: ICoordinate) {\n\t\tthis._x = coordinate.x;\n\t\tthis._y = (coordinate.y + coordinate.baseY) - this._baseY;\n\t\treturn this.moveInstruction();\n\t}\n\n\tclone() {\n\t\tconst c = new Cursor(this.rows, this.cols, this._buffer);\n\t\tc.moveTo(this);\n\t\treturn c;\n\t}\n\n\tmove(x: number, y: number) {\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\treturn this.moveInstruction();\n\t}\n\n\tshift(x: number = 0, y: number = 0) {\n\t\tthis._x += x;\n\t\tthis._y += y;\n\t\treturn this.moveInstruction();\n\t}\n\n\tmoveInstruction() {\n\t\tif (this._y >= this.rows) {\n\t\t\tthis._baseY += this._y - (this.rows - 1);\n\t\t\tthis._y = this.rows - 1;\n\t\t} else if (this._y < 0) {\n\t\t\tthis._baseY -= this._y;\n\t\t\tthis._y = 0;\n\t\t}\n\n\t\treturn `${VT.Csi}${this._y + 1};${this._x + 1}H`;\n\t}\n}\n\nconst moveToWordBoundary = (b: IBuffer, cursor: Cursor, direction: -1 | 1) => {\n\tlet ateLeadingWhitespace = false;\n\tif (direction < 0) {\n\t\tcursor.shift(-1);\n\t}\n\n\tlet cell: IBufferCell | undefined;\n\twhile (cursor.x >= 0) {\n\t\tcell = cursor.getCell(cell);\n\t\tif (!cell?.getCode()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst chars = cell.getChars();\n\t\tif (NOT_WORD_RE.test(chars)) {\n\t\t\tif (ateLeadingWhitespace) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tateLeadingWhitespace = true;\n\t\t}\n\n\t\tcursor.shift(direction);\n\t}\n\n\tif (direction < 0) {\n\t\tcursor.shift(1); // we want to place the cursor after the whitespace starting the word\n\t}\n};\n\nconst enum MatchResult {\n\t/** matched successfully */\n\tSuccess,\n\t/** failed to match */\n\tFailure,\n\t/** buffer data, it might match in the future one more data comes in */\n\tBuffer,\n}\n\nexport interface IPrediction {\n\t/**\n\t * Whether applying this prediction can modify the style attributes of the\n\t * terminal. If so it means we need to reset the cursor style if it's\n\t * rolled back.\n\t */\n\treadonly affectsStyle?: boolean;\n\n\t/**\n\t * If set to false, the prediction will not be cleared if no input is\n\t * received from the server.\n\t */\n\treadonly clearAfterTimeout?: boolean;\n\n\t/**\n\t * Returns a sequence to apply the prediction.\n\t * @param buffer to write to\n\t * @param cursor position to write the data. Should advance the cursor.\n\t * @returns a string to be written to the user terminal, or optionally a\n\t * string for the user terminal and real pty.\n\t */\n\tapply(buffer: IBuffer, cursor: Cursor): string;\n\n\t/**\n\t * Returns a sequence to roll back a previous `apply()` call. If\n\t * `rollForwards` is not given, then this is also called if a prediction\n\t * is correct before show the user's data.\n\t */\n\trollback(cursor: Cursor): string;\n\n\t/**\n\t * If available, this will be called when the prediction is correct.\n\t */\n\trollForwards(cursor: Cursor, withInput: string): string;\n\n\t/**\n\t * Returns whether the given input is one expected by this prediction.\n\t * @param input reader for the input the PTY is giving\n\t * @param lookBehind the last successfully-made prediction, if any\n\t */\n\tmatches(input: StringReader, lookBehind?: IPrediction): MatchResult;\n}\n\nclass StringReader {\n\tindex = 0;\n\n\tget remaining() {\n\t\treturn this._input.length - this.index;\n\t}\n\n\tget eof() {\n\t\treturn this.index === this._input.length;\n\t}\n\n\tget rest() {\n\t\treturn this._input.slice(this.index);\n\t}\n\n\tconstructor(\n\t\tprivate readonly _input: string\n\t) { }\n\n\t/**\n\t * Advances the reader and returns the character if it matches.\n\t */\n\teatChar(char: string) {\n\t\tif (this._input[this.index] !== char) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.index++;\n\t\treturn char;\n\t}\n\n\t/**\n\t * Advances the reader and returns the string if it matches.\n\t */\n\teatStr(substr: string) {\n\t\tif (this._input.slice(this.index, substr.length) !== substr) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.index += substr.length;\n\t\treturn substr;\n\t}\n\n\t/**\n\t * Matches and eats the substring character-by-character. If EOF is reached\n\t * before the substring is consumed, it will buffer. Index is not moved\n\t * if it's not a match.\n\t */\n\teatGradually(substr: string): MatchResult {\n\t\tconst prevIndex = this.index;\n\t\tfor (let i = 0; i < substr.length; i++) {\n\t\t\tif (i > 0 && this.eof) {\n\t\t\t\treturn MatchResult.Buffer;\n\t\t\t}\n\n\t\t\tif (!this.eatChar(substr[i])) {\n\t\t\t\tthis.index = prevIndex;\n\t\t\t\treturn MatchResult.Failure;\n\t\t\t}\n\t\t}\n\n\t\treturn MatchResult.Success;\n\t}\n\n\t/**\n\t * Advances the reader and returns the regex if it matches.\n\t */\n\teatRe(re: RegExp) {\n\t\tconst match = re.exec(this._input.slice(this.index));\n\t\tif (!match) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.index += match[0].length;\n\t\treturn match;\n\t}\n\n\t/**\n\t * Advances the reader and returns the character if the code matches.\n\t */\n\teatCharCode(min = 0, max = min + 1) {\n\t\tconst code = this._input.charCodeAt(this.index);\n\t\tif (code < min || code >= max) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tthis.index++;\n\t\treturn code;\n\t}\n}\n\n/**\n * Preidction which never tests true. Will always discard predictions made\n * after it.\n */\nclass HardBoundary implements IPrediction {\n\treadonly clearAfterTimeout = false;\n\n\tapply() {\n\t\treturn '';\n\t}\n\n\trollback() {\n\t\treturn '';\n\t}\n\n\trollForwards() {\n\t\treturn '';\n\t}\n\n\tmatches() {\n\t\treturn MatchResult.Failure;\n\t}\n}\n\n/**\n * Wraps another prediction. Does not apply the prediction, but will pass\n * through its `matches` request.\n */\nclass TentativeBoundary implements IPrediction {\n\tprivate _appliedCursor?: Cursor;\n\n\tconstructor(readonly inner: IPrediction) { }\n\n\tapply(buffer: IBuffer, cursor: Cursor) {\n\t\tthis._appliedCursor = cursor.clone();\n\t\tthis.inner.apply(buffer, this._appliedCursor);\n\t\treturn '';\n\t}\n\n\trollback(cursor: Cursor) {\n\t\tthis.inner.rollback(cursor.clone());\n\t\treturn '';\n\t}\n\n\trollForwards(cursor: Cursor, withInput: string) {\n\t\tif (this._appliedCursor) {\n\t\t\tcursor.moveTo(this._appliedCursor);\n\t\t}\n\n\t\treturn withInput;\n\t}\n\n\tmatches(input: StringReader) {\n\t\treturn this.inner.matches(input);\n\t}\n}\n\nconst isTenativeCharacterPrediction = (p: unknown): p is (TentativeBoundary & { inner: CharacterPrediction }) =>\n\tp instanceof TentativeBoundary && p.inner instanceof CharacterPrediction;\n\n/**\n * Prediction for a single alphanumeric character.\n */\nclass CharacterPrediction implements IPrediction {\n\treadonly affectsStyle = true;\n\n\tappliedAt?: {\n\t\tpos: ICoordinate;\n\t\toldAttributes: string;\n\t\toldChar: string;\n\t};\n\n\tconstructor(private readonly _style: TypeAheadStyle, private readonly _char: string) { }\n\n\tapply(_: IBuffer, cursor: Cursor) {\n\t\tconst cell = cursor.getCell();\n\t\tthis.appliedAt = cell\n\t\t\t? { pos: cursor.coordinate, oldAttributes: attributesToSeq(cell), oldChar: cell.getChars() }\n\t\t\t: { pos: cursor.coordinate, oldAttributes: '', oldChar: '' };\n\n\t\tcursor.shift(1);\n\n\t\treturn this._style.apply + this._char + this._style.undo;\n\t}\n\n\trollback(cursor: Cursor) {\n\t\tif (!this.appliedAt) {\n\t\t\treturn ''; // not applied\n\t\t}\n\n\t\tconst { oldAttributes, oldChar, pos } = this.appliedAt;\n\t\tconst r = cursor.moveTo(pos) + (oldChar ? `${oldAttributes}${oldChar}${cursor.moveTo(pos)}` : VT.DeleteChar);\n\t\treturn r;\n\t}\n\n\trollForwards(cursor: Cursor, input: string) {\n\t\tif (!this.appliedAt) {\n\t\t\treturn ''; // not applied\n\t\t}\n\n\t\treturn cursor.clone().moveTo(this.appliedAt.pos) + input;\n\t}\n\n\tmatches(input: StringReader, lookBehind?: IPrediction) {\n\t\tconst startIndex = input.index;\n\n\t\t// remove any styling CSI before checking the char\n\t\twhile (input.eatRe(CSI_STYLE_RE)) { }\n\n\t\tif (input.eof) {\n\t\t\treturn MatchResult.Buffer;\n\t\t}\n\n\t\tif (input.eatChar(this._char)) {\n\t\t\treturn MatchResult.Success;\n\t\t}\n\n\t\tif (lookBehind instanceof CharacterPrediction) {\n\t\t\t// see #112842\n\t\t\tconst sillyZshOutcome = input.eatGradually(`\\b${lookBehind._char}${this._char}`);\n\t\t\tif (sillyZshOutcome !== MatchResult.Failure) {\n\t\t\t\treturn sillyZshOutcome;\n\t\t\t}\n\t\t}\n\n\t\tinput.index = startIndex;\n\t\treturn MatchResult.Failure;\n\t}\n}\n\nclass BackspacePrediction implements IPrediction {\n\tprotected _appliedAt?: {\n\t\tpos: ICoordinate;\n\t\toldAttributes: string;\n\t\toldChar: string;\n\t\tisLastChar: boolean;\n\t};\n\n\tconstructor(private readonly _terminal: Terminal) { }\n\n\tapply(_: IBuffer, cursor: Cursor) {\n\t\t// at eol if everything to the right is whitespace (zsh will emit a \"clear line\" code in this case)\n\t\t// todo: can be optimized if `getTrimmedLength` is exposed from xterm\n\t\tconst isLastChar = !cursor.getLine()?.translateToString(undefined, cursor.x).trim();\n\t\tconst pos = cursor.coordinate;\n\t\tconst move = cursor.shift(-1);\n\t\tconst cell = cursor.getCell();\n\t\tthis._appliedAt = cell\n\t\t\t? { isLastChar, pos, oldAttributes: attributesToSeq(cell), oldChar: cell.getChars() }\n\t\t\t: { isLastChar, pos, oldAttributes: '', oldChar: '' };\n\n\t\treturn move + VT.DeleteChar;\n\t}\n\n\trollback(cursor: Cursor) {\n\t\tif (!this._appliedAt) {\n\t\t\treturn ''; // not applied\n\t\t}\n\n\t\tconst { oldAttributes, oldChar, pos } = this._appliedAt;\n\t\tif (!oldChar) {\n\t\t\treturn cursor.moveTo(pos) + VT.DeleteChar;\n\t\t}\n\n\t\treturn oldAttributes + oldChar + cursor.moveTo(pos) + attributesToSeq(core(this._terminal)._inputHandler._curAttrData);\n\t}\n\n\trollForwards() {\n\t\treturn '';\n\t}\n\n\tmatches(input: StringReader) {\n\t\tif (this._appliedAt?.isLastChar) {\n\t\t\tconst r1 = input.eatGradually(`\\b${VT.Csi}K`);\n\t\t\tif (r1 !== MatchResult.Failure) {\n\t\t\t\treturn r1;\n\t\t\t}\n\n\t\t\tconst r2 = input.eatGradually(`\\b \\b`);\n\t\t\tif (r2 !== MatchResult.Failure) {\n\t\t\t\treturn r2;\n\t\t\t}\n\t\t}\n\n\t\treturn MatchResult.Failure;\n\t}\n}\n\nclass NewlinePrediction implements IPrediction {\n\tprotected _prevPosition?: ICoordinate;\n\n\tapply(_: IBuffer, cursor: Cursor) {\n\t\tthis._prevPosition = cursor.coordinate;\n\t\tcursor.move(0, cursor.y + 1);\n\t\treturn '\\r\\n';\n\t}\n\n\trollback(cursor: Cursor) {\n\t\treturn this._prevPosition ? cursor.moveTo(this._prevPosition) : '';\n\t}\n\n\trollForwards() {\n\t\treturn ''; // does not need to rewrite\n\t}\n\n\tmatches(input: StringReader) {\n\t\treturn input.eatGradually('\\r\\n');\n\t}\n}\n\n/**\n * Prediction when the cursor reaches the end of the line. Similar to newline\n * prediction, but shells handle it slightly differently.\n */\nclass LinewrapPrediction extends NewlinePrediction implements IPrediction {\n\toverride apply(_: IBuffer, cursor: Cursor) {\n\t\tthis._prevPosition = cursor.coordinate;\n\t\tcursor.move(0, cursor.y + 1);\n\t\treturn ' \\r';\n\t}\n\n\toverride matches(input: StringReader) {\n\t\t// bash and zshell add a space which wraps in the terminal, then a CR\n\t\tconst r = input.eatGradually(' \\r');\n\t\tif (r !== MatchResult.Failure) {\n\t\t\t// zshell additionally adds a clear line after wrapping to be safe -- eat it\n\t\t\tconst r2 = input.eatGradually(VT.DeleteRestOfLine);\n\t\t\treturn r2 === MatchResult.Buffer ? MatchResult.Buffer : r;\n\t\t}\n\n\t\treturn input.eatGradually('\\r\\n');\n\t}\n}\n\nclass CursorMovePrediction implements IPrediction {\n\tprivate _applied?: {\n\t\trollForward: string;\n\t\tprevPosition: number;\n\t\tprevAttrs: string;\n\t\tamount: number;\n\t};\n\n\tconstructor(\n\t\tprivate readonly _direction: CursorMoveDirection,\n\t\tprivate readonly _moveByWords: boolean,\n\t\tprivate readonly _amount: number,\n\t) { }\n\n\tapply(buffer: IBuffer, cursor: Cursor) {\n\t\tconst prevPosition = cursor.x;\n\t\tconst currentCell = cursor.getCell();\n\t\tconst prevAttrs = currentCell ? attributesToSeq(currentCell) : '';\n\n\t\tconst { _amount: amount, _direction: direction, _moveByWords: moveByWords } = this;\n\t\tconst delta = direction === CursorMoveDirection.Back ? -1 : 1;\n\n\t\tconst target = cursor.clone();\n\t\tif (moveByWords) {\n\t\t\tfor (let i = 0; i < amount; i++) {\n\t\t\t\tmoveToWordBoundary(buffer, target, delta);\n\t\t\t}\n\t\t} else {\n\t\t\ttarget.shift(delta * amount);\n\t\t}\n\n\t\tthis._applied = {\n\t\t\tamount: Math.abs(cursor.x - target.x),\n\t\t\tprevPosition,\n\t\t\tprevAttrs,\n\t\t\trollForward: cursor.moveTo(target),\n\t\t};\n\n\t\treturn this._applied.rollForward;\n\t}\n\n\trollback(cursor: Cursor) {\n\t\tif (!this._applied) {\n\t\t\treturn '';\n\t\t}\n\n\t\treturn cursor.move(this._applied.prevPosition, cursor.y) + this._applied.prevAttrs;\n\t}\n\n\trollForwards() {\n\t\treturn ''; // does not need to rewrite\n\t}\n\n\tmatches(input: StringReader) {\n\t\tif (!this._applied) {\n\t\t\treturn MatchResult.Failure;\n\t\t}\n\n\t\tconst direction = this._direction;\n\t\tconst { amount, rollForward } = this._applied;\n\n\n\t\t// arg can be omitted to move one character. We don't eatGradually() here\n\t\t// or below moves that don't go as far as the cursor would be buffered\n\t\t// indefinitely\n\t\tif (input.eatStr(`${VT.Csi}${direction}`.repeat(amount))) {\n\t\t\treturn MatchResult.Success;\n\t\t}\n\n\t\t// \\b is the equivalent to moving one character back\n\t\tif (direction === CursorMoveDirection.Back) {\n\t\t\tif (input.eatStr(`\\b`.repeat(amount))) {\n\t\t\t\treturn MatchResult.Success;\n\t\t\t}\n\t\t}\n\n\t\t// check if the cursor position is set absolutely\n\t\tif (rollForward) {\n\t\t\tconst r = input.eatGradually(rollForward);\n\t\t\tif (r !== MatchResult.Failure) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\t// check for a relative move in the direction\n\t\treturn input.eatGradually(`${VT.Csi}${amount}${direction}`);\n\t}\n}\n\nexport class PredictionStats extends Disposable {\n\tprivate readonly _stats: [latency: number, correct: boolean][] = [];\n\tprivate _index = 0;\n\tprivate readonly _addedAtTime = new WeakMap<IPrediction, number>();\n\tprivate readonly _changeEmitter = new Emitter<void>();\n\treadonly onChange = this._changeEmitter.event;\n\n\t/**\n\t * Gets the percent (0-1) of predictions that were accurate.\n\t */\n\tget accuracy() {\n\t\tlet correctCount = 0;\n\t\tfor (const [, correct] of this._stats) {\n\t\t\tif (correct) {\n\t\t\t\tcorrectCount++;\n\t\t\t}\n\t\t}\n\n\t\treturn correctCount / (this._stats.length || 1);\n\t}\n\n\t/**\n\t * Gets the number of recorded stats.\n\t */\n\tget sampleSize() {\n\t\treturn this._stats.length;\n\t}\n\n\t/**\n\t * Gets latency stats of successful predictions.\n\t */\n\tget latency() {\n\t\tconst latencies = this._stats.filter(([, correct]) => correct).map(([s]) => s).sort();\n\n\t\treturn {\n\t\t\tcount: latencies.length,\n\t\t\tmin: latencies[0],\n\t\t\tmedian: latencies[Math.floor(latencies.length / 2)],\n\t\t\tmax: latencies[latencies.length - 1],\n\t\t};\n\t}\n\n\t/**\n\t * Gets the maximum observed latency.\n\t */\n\tget maxLatency() {\n\t\tlet max = -Infinity;\n\t\tfor (const [latency, correct] of this._stats) {\n\t\t\tif (correct) {\n\t\t\t\tmax = Math.max(latency, max);\n\t\t\t}\n\t\t}\n\n\t\treturn max;\n\t}\n\n\tconstructor(timeline: PredictionTimeline) {\n\t\tsuper();\n\t\tthis._register(timeline.onPredictionAdded(p => this._addedAtTime.set(p, Date.now())));\n\t\tthis._register(timeline.onPredictionSucceeded(this._pushStat.bind(this, true)));\n\t\tthis._register(timeline.onPredictionFailed(this._pushStat.bind(this, false)));\n\t}\n\n\tprivate _pushStat(correct: boolean, prediction: IPrediction) {\n\t\tconst started = this._addedAtTime.get(prediction)!;\n\t\tthis._stats[this._index] = [Date.now() - started, correct];\n\t\tthis._index = (this._index + 1) % StatsConstants.StatsBufferSize;\n\t\tthis._changeEmitter.fire();\n\t}\n}\n\nexport class PredictionTimeline {\n\t/**\n\t * Expected queue of events. Only predictions for the lowest are\n\t * written into the terminal.\n\t */\n\tprivate _expected: ({ gen: number; p: IPrediction })[] = [];\n\n\t/**\n\t * Current prediction generation.\n\t */\n\tprivate _currentGen = 0;\n\n\t/**\n\t * Current cursor position -- kept outside the buffer since it can be ahead\n\t * if typing swiftly. The position of the cursor that the user is currently\n\t * looking at on their screen (or will be looking at after all pending writes\n\t * are flushed.)\n\t */\n\tprivate _physicalCursor: Cursor | undefined;\n\n\t/**\n\t * Cursor position taking into account all (possibly not-yet-applied)\n\t * predictions. A new prediction inserted, if applied, will be applied at\n\t * the position of the tentative cursor.\n\t */\n\tprivate _tenativeCursor: Cursor | undefined;\n\n\t/**\n\t * Previously sent data that was buffered and should be prepended to the\n\t * next input.\n\t */\n\tprivate _inputBuffer?: string;\n\n\t/**\n\t * Whether predictions are echoed to the terminal. If false, predictions\n\t * will still be computed internally for latency metrics, but input will\n\t * never be adjusted.\n\t */\n\tprivate _showPredictions = false;\n\n\t/**\n\t * The last successfully-made prediction.\n\t */\n\tprivate _lookBehind?: IPrediction;\n\n\tprivate readonly _addedEmitter = new Emitter<IPrediction>();\n\treadonly onPredictionAdded = this._addedEmitter.event;\n\tprivate readonly _failedEmitter = new Emitter<IPrediction>();\n\treadonly onPredictionFailed = this._failedEmitter.event;\n\tprivate readonly _succeededEmitter = new Emitter<IPrediction>();\n\treadonly onPredictionSucceeded = this._succeededEmitter.event;\n\n\tprivate get _currentGenerationPredictions() {\n\t\treturn this._expected.filter(({ gen }) => gen === this._expected[0].gen).map(({ p }) => p);\n\t}\n\n\tget isShowingPredictions() {\n\t\treturn this._showPredictions;\n\t}\n\n\tget length() {\n\t\treturn this._expected.length;\n\t}\n\n\tconstructor(readonly terminal: Terminal, private readonly _style: TypeAheadStyle) { }\n\n\tsetShowPredictions(show: boolean) {\n\t\tif (show === this._showPredictions) {\n\t\t\treturn;\n\t\t}\n\n\t\t// console.log('set predictions:', show);\n\t\tthis._showPredictions = show;\n\n\t\tconst buffer = this._getActiveBuffer();\n\t\tif (!buffer) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst toApply = this._currentGenerationPredictions;\n\t\tif (show) {\n\t\t\tthis.clearCursor();\n\t\t\tthis._style.expectIncomingStyle(toApply.reduce((count, p) => p.affectsStyle ? count + 1 : count, 0));\n\t\t\tthis.terminal.write(toApply.map(p => p.apply(buffer, this.physicalCursor(buffer))).join(''));\n\t\t} else {\n\t\t\tthis.terminal.write(toApply.reverse().map(p => p.rollback(this.physicalCursor(buffer))).join(''));\n\t\t}\n\t}\n\n\t/**\n\t * Undoes any predictions written and resets expectations.\n\t */\n\tundoAllPredictions() {\n\t\tconst buffer = this._getActiveBuffer();\n\t\tif (this._showPredictions && buffer) {\n\t\t\tthis.terminal.write(this._currentGenerationPredictions.reverse()\n\t\t\t\t.map(p => p.rollback(this.physicalCursor(buffer))).join(''));\n\t\t}\n\n\t\tthis._expected = [];\n\t}\n\n\t/**\n\t * Should be called when input is incoming to the temrinal.\n\t */\n\tbeforeServerInput(input: string): string {\n\t\tconst originalInput = input;\n\t\tif (this._inputBuffer) {\n\t\t\tinput = this._inputBuffer + input;\n\t\t\tthis._inputBuffer = undefined;\n\t\t}\n\n\t\tif (!this._expected.length) {\n\t\t\tthis._clearPredictionState();\n\t\t\treturn input;\n\t\t}\n\n\t\tconst buffer = this._getActiveBuffer();\n\t\tif (!buffer) {\n\t\t\tthis._clearPredictionState();\n\t\t\treturn input;\n\t\t}\n\n\t\tlet output = '';\n\n\t\tconst reader = new StringReader(input);\n\t\tconst startingGen = this._expected[0].gen;\n\t\tconst emitPredictionOmitted = () => {\n\t\t\tconst omit = reader.eatRe(PREDICTION_OMIT_RE);\n\t\t\tif (omit) {\n\t\t\t\toutput += omit[0];\n\t\t\t}\n\t\t};\n\n\t\tReadLoop: while (this._expected.length && reader.remaining > 0) {\n\t\t\temitPredictionOmitted();\n\n\t\t\tconst { p: prediction, gen } = this._expected[0];\n\t\t\tconst cursor = this.physicalCursor(buffer);\n\t\t\tconst beforeTestReaderIndex = reader.index;\n\t\t\tswitch (prediction.matches(reader, this._lookBehind)) {\n\t\t\t\tcase MatchResult.Success: {\n\t\t\t\t\t// if the input character matches what the next prediction expected, undo\n\t\t\t\t\t// the prediction and write the real character out.\n\t\t\t\t\tconst eaten = input.slice(beforeTestReaderIndex, reader.index);\n\t\t\t\t\tif (gen === startingGen) {\n\t\t\t\t\t\toutput += prediction.rollForwards?.(cursor, eaten);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprediction.apply(buffer, this.physicalCursor(buffer)); // move cursor for additional apply\n\t\t\t\t\t\toutput += eaten;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._succeededEmitter.fire(prediction);\n\t\t\t\t\tthis._lookBehind = prediction;\n\t\t\t\t\tthis._expected.shift();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase MatchResult.Buffer:\n\t\t\t\t\t// on a buffer, store the remaining data and completely read data\n\t\t\t\t\t// to be output as normal.\n\t\t\t\t\tthis._inputBuffer = input.slice(beforeTestReaderIndex);\n\t\t\t\t\treader.index = input.length;\n\t\t\t\t\tbreak ReadLoop;\n\t\t\t\tcase MatchResult.Failure: {\n\t\t\t\t\t// on a failure, roll back all remaining items in this generation\n\t\t\t\t\t// and clear predictions, since they are no longer valid\n\t\t\t\t\tconst rollback = this._expected.filter(p => p.gen === startingGen).reverse();\n\t\t\t\t\toutput += rollback.map(({ p }) => p.rollback(this.physicalCursor(buffer))).join('');\n\t\t\t\t\tif (rollback.some(r => r.p.affectsStyle)) {\n\t\t\t\t\t\t// reading the current style should generally be safe, since predictions\n\t\t\t\t\t\t// always restore the style if they modify it.\n\t\t\t\t\t\toutput += attributesToSeq(core(this.terminal)._inputHandler._curAttrData);\n\t\t\t\t\t}\n\t\t\t\t\tthis._clearPredictionState();\n\t\t\t\t\tthis._failedEmitter.fire(prediction);\n\t\t\t\t\tbreak ReadLoop;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\temitPredictionOmitted();\n\n\t\t// Extra data (like the result of running a command) should cause us to\n\t\t// reset the cursor\n\t\tif (!reader.eof) {\n\t\t\toutput += reader.rest;\n\t\t\tthis._clearPredictionState();\n\t\t}\n\n\t\t// If we passed a generation boundary, apply the current generation's predictions\n\t\tif (this._expected.length && startingGen !== this._expected[0].gen) {\n\t\t\tfor (const { p, gen } of this._expected) {\n\t\t\t\tif (gen !== this._expected[0].gen) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (p.affectsStyle) {\n\t\t\t\t\tthis._style.expectIncomingStyle();\n\t\t\t\t}\n\n\t\t\t\toutput += p.apply(buffer, this.physicalCursor(buffer));\n\t\t\t}\n\t\t}\n\n\t\tif (!this._showPredictions) {\n\t\t\treturn originalInput;\n\t\t}\n\n\t\tif (output.length === 0 || output === input) {\n\t\t\treturn output;\n\t\t}\n\n\t\tif (this._physicalCursor) {\n\t\t\toutput += this._physicalCursor.moveInstruction();\n\t\t}\n\n\t\t// prevent cursor flickering while typing\n\t\toutput = VT.HideCursor + output + VT.ShowCursor;\n\n\t\treturn output;\n\t}\n\n\t/**\n\t * Clears any expected predictions and stored state. Should be called when\n\t * the pty gives us something we don't recognize.\n\t */\n\tprivate _clearPredictionState() {\n\t\tthis._expected = [];\n\t\tthis.clearCursor();\n\t\tthis._lookBehind = undefined;\n\t}\n\n\t/**\n\t * Appends a typeahead prediction.\n\t */\n\taddPrediction(buffer: IBuffer, prediction: IPrediction) {\n\t\tthis._expected.push({ gen: this._currentGen, p: prediction });\n\t\tthis._addedEmitter.fire(prediction);\n\n\t\tif (this._currentGen !== this._expected[0].gen) {\n\t\t\tprediction.apply(buffer, this.tentativeCursor(buffer));\n\t\t\treturn false;\n\t\t}\n\n\t\tconst text = prediction.apply(buffer, this.physicalCursor(buffer));\n\t\tthis._tenativeCursor = undefined; // next read will get or clone the physical cursor\n\n\t\tif (this._showPredictions && text) {\n\t\t\tif (prediction.affectsStyle) {\n\t\t\t\tthis._style.expectIncomingStyle();\n\t\t\t}\n\t\t\t// console.log('predict:', JSON.stringify(text));\n\t\t\tthis.terminal.write(text);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Appends a prediction followed by a boundary. The predictions applied\n\t * after this one will only be displayed after the give prediction matches\n\t * pty output/\n\t */\n\taddBoundary(): void;\n\taddBoundary(buffer: IBuffer, prediction: IPrediction): boolean;\n\taddBoundary(buffer?: IBuffer, prediction?: IPrediction) {\n\t\tlet applied = false;\n\t\tif (buffer && prediction) {\n\t\t\t// We apply the prediction so that it's matched against, but wrapped\n\t\t\t// in a tentativeboundary so that it doesn't affect the physical cursor.\n\t\t\t// Then we apply it specifically to the tentative cursor.\n\t\t\tapplied = this.addPrediction(buffer, new TentativeBoundary(prediction));\n\t\t\tprediction.apply(buffer, this.tentativeCursor(buffer));\n\t\t}\n\t\tthis._currentGen++;\n\t\treturn applied;\n\t}\n\n\t/**\n\t * Peeks the last prediction written.\n\t */\n\tpeekEnd(): IPrediction | undefined {\n\t\treturn this._expected[this._expected.length - 1]?.p;\n\t}\n\n\t/**\n\t * Peeks the first pending prediction.\n\t */\n\tpeekStart(): IPrediction | undefined {\n\t\treturn this._expected[0]?.p;\n\t}\n\n\t/**\n\t * Current position of the cursor in the terminal.\n\t */\n\tphysicalCursor(buffer: IBuffer) {\n\t\tif (!this._physicalCursor) {\n\t\t\tif (this._showPredictions) {\n\t\t\t\tflushOutput(this.terminal);\n\t\t\t}\n\t\t\tthis._physicalCursor = new Cursor(this.terminal.rows, this.terminal.cols, buffer);\n\t\t}\n\n\t\treturn this._physicalCursor;\n\t}\n\n\t/**\n\t * Cursor position if all predictions and boundaries that have been inserted\n\t * so far turn out to be successfully predicted.\n\t */\n\ttentativeCursor(buffer: IBuffer) {\n\t\tif (!this._tenativeCursor) {\n\t\t\tthis._tenativeCursor = this.physicalCursor(buffer).clone();\n\t\t}\n\n\t\treturn this._tenativeCursor;\n\t}\n\n\tclearCursor() {\n\t\tthis._physicalCursor = undefined;\n\t\tthis._tenativeCursor = undefined;\n\t}\n\n\tprivate _getActiveBuffer() {\n\t\tconst buffer = this.terminal.buffer.active;\n\t\treturn buffer.type === 'normal' ? buffer : undefined;\n\t}\n}\n\n/**\n * Gets the escape sequence args to restore state/appearance in the cell.\n */\nconst attributesToArgs = (cell: XtermAttributes) => {\n\tif (cell.isAttributeDefault()) { return [0]; }\n\n\tconst args = [];\n\tif (cell.isBold()) { args.push(1); }\n\tif (cell.isDim()) { args.push(2); }\n\tif (cell.isItalic()) { args.push(3); }\n\tif (cell.isUnderline()) { args.push(4); }\n\tif (cell.isBlink()) { args.push(5); }\n\tif (cell.isInverse()) { args.push(7); }\n\tif (cell.isInvisible()) { args.push(8); }\n\n\tif (cell.isFgRGB()) { args.push(38, 2, cell.getFgColor() >>> 24, (cell.getFgColor() >>> 16) & 0xFF, cell.getFgColor() & 0xFF); }\n\tif (cell.isFgPalette()) { args.push(38, 5, cell.getFgColor()); }\n\tif (cell.isFgDefault()) { args.push(39); }\n\n\tif (cell.isBgRGB()) { args.push(48, 2, cell.getBgColor() >>> 24, (cell.getBgColor() >>> 16) & 0xFF, cell.getBgColor() & 0xFF); }\n\tif (cell.isBgPalette()) { args.push(48, 5, cell.getBgColor()); }\n\tif (cell.isBgDefault()) { args.push(49); }\n\n\treturn args;\n};\n\n/**\n * Gets the escape sequence to restore state/appearance in the cell.\n */\nconst attributesToSeq = (cell: XtermAttributes) => `${VT.Csi}${attributesToArgs(cell).join(';')}m`;\n\nconst arrayHasPrefixAt = <T>(a: ReadonlyArray<T>, ai: number, b: ReadonlyArray<T>) => {\n\tif (a.length - ai > b.length) {\n\t\treturn false;\n\t}\n\n\tfor (let bi = 0; bi < b.length; bi++, ai++) {\n\t\tif (b[ai] !== a[ai]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n};\n\n/**\n * @see https://github.com/xtermjs/xterm.js/blob/065eb13a9d3145bea687239680ec9696d9112b8e/src/common/InputHandler.ts#L2127\n */\nconst getColorWidth = (params: (number | number[])[], pos: number) => {\n\tconst accu = [0, 0, -1, 0, 0, 0];\n\tlet cSpace = 0;\n\tlet advance = 0;\n\n\tdo {\n\t\tconst v = params[pos + advance];\n\t\taccu[advance + cSpace] = typeof v === 'number' ? v : v[0];\n\t\tif (typeof v !== 'number') {\n\t\t\tlet i = 0;\n\t\t\tdo {\n\t\t\t\tif (accu[1] === 5) {\n\t\t\t\t\tcSpace = 1;\n\t\t\t\t}\n\t\t\t\taccu[advance + i + 1 + cSpace] = v[i];\n\t\t\t} while (++i < v.length && i + advance + 1 + cSpace < accu.length);\n\t\t\tbreak;\n\t\t}\n\t\t// exit early if can decide color mode with semicolons\n\t\tif ((accu[1] === 5 && advance + cSpace >= 2)\n\t\t\t|| (accu[1] === 2 && advance + cSpace >= 5)) {\n\t\t\tbreak;\n\t\t}\n\t\t// offset colorSpace slot for semicolon mode\n\t\tif (accu[1]) {\n\t\t\tcSpace = 1;\n\t\t}\n\t} while (++advance + pos < params.length && advance + cSpace < accu.length);\n\n\treturn advance;\n};\n\nclass TypeAheadStyle implements IDisposable {\n\tprivate static _compileArgs(args: ReadonlyArray<number>) {\n\t\treturn `${VT.Csi}${args.join(';')}m`;\n\t}\n\n\t/**\n\t * Number of typeahead style arguments we expect to read. If this is 0 and\n\t * we see a style coming in, we know that the PTY actually wanted to update.\n\t */\n\tprivate _expectedIncomingStyles = 0;\n\tprivate _applyArgs!: ReadonlyArray<number>;\n\tprivate _originalUndoArgs!: ReadonlyArray<number>;\n\tprivate _undoArgs!: ReadonlyArray<number>;\n\n\tapply!: string;\n\tundo!: string;\n\tprivate _csiHandler?: IDisposable;\n\n\tconstructor(value: ITerminalTypeAheadConfiguration['localEchoStyle'], private readonly _terminal: Terminal) {\n\t\tthis.onUpdate(value);\n\t}\n\n\t/**\n\t * Signals that a style was written to the terminal and we should watch\n\t * for it coming in.\n\t */\n\texpectIncomingStyle(n = 1) {\n\t\tthis._expectedIncomingStyles += n * 2;\n\t}\n\n\t/**\n\t * Starts tracking for CSI changes in the terminal.\n\t */\n\tstartTracking() {\n\t\tthis._expectedIncomingStyles = 0;\n\t\tthis._onDidWriteSGR(attributesToArgs(core(this._terminal)._inputHandler._curAttrData));\n\t\tthis._csiHandler = this._terminal.parser.registerCsiHandler({ final: 'm' }, args => {\n\t\t\tthis._onDidWriteSGR(args);\n\t\t\treturn false;\n\t\t});\n\t}\n\n\t/**\n\t * Stops tracking terminal CSI changes.\n\t */\n\t@debounce(2000)\n\tdebounceStopTracking() {\n\t\tthis._stopTracking();\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tdispose() {\n\t\tthis._stopTracking();\n\t}\n\n\tprivate _stopTracking() {\n\t\tthis._csiHandler?.dispose();\n\t\tthis._csiHandler = undefined;\n\t}\n\n\tprivate _onDidWriteSGR(args: (number | number[])[]) {\n\t\tconst originalUndo = this._undoArgs;\n\t\tfor (let i = 0; i < args.length;) {\n\t\t\tconst px = args[i];\n\t\t\tconst p = typeof px === 'number' ? px : px[0];\n\n\t\t\tif (this._expectedIncomingStyles) {\n\t\t\t\tif (arrayHasPrefixAt(args, i, this._undoArgs)) {\n\t\t\t\t\tthis._expectedIncomingStyles--;\n\t\t\t\t\ti += this._undoArgs.length;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (arrayHasPrefixAt(args, i, this._applyArgs)) {\n\t\t\t\t\tthis._expectedIncomingStyles--;\n\t\t\t\t\ti += this._applyArgs.length;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst width = p === 38 || p === 48 || p === 58 ? getColorWidth(args, i) : 1;\n\t\t\tswitch (this._applyArgs[0]) {\n\t\t\t\tcase 1:\n\t\t\t\t\tif (p === 2) {\n\t\t\t\t\t\tthis._undoArgs = [22, 2];\n\t\t\t\t\t} else if (p === 22 || p === 0) {\n\t\t\t\t\t\tthis._undoArgs = [22];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tif (p === 1) {\n\t\t\t\t\t\tthis._undoArgs = [22, 1];\n\t\t\t\t\t} else if (p === 22 || p === 0) {\n\t\t\t\t\t\tthis._undoArgs = [22];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 38:\n\t\t\t\t\tif (p === 0 || p === 39 || p === 100) {\n\t\t\t\t\t\tthis._undoArgs = [39];\n\t\t\t\t\t} else if ((p >= 30 && p <= 38) || (p >= 90 && p <= 97)) {\n\t\t\t\t\t\tthis._undoArgs = args.slice(i, i + width) as number[];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (p === this._applyArgs[0]) {\n\t\t\t\t\t\tthis._undoArgs = this._applyArgs;\n\t\t\t\t\t} else if (p === 0) {\n\t\t\t\t\t\tthis._undoArgs = this._originalUndoArgs;\n\t\t\t\t\t}\n\t\t\t\t// no-op\n\t\t\t}\n\n\t\t\ti += width;\n\t\t}\n\n\t\tif (originalUndo !== this._undoArgs) {\n\t\t\tthis.undo = TypeAheadStyle._compileArgs(this._undoArgs);\n\t\t}\n\t}\n\n\t/**\n\t * Updates the current typeahead style.\n\t */\n\tonUpdate(style: ITerminalTypeAheadConfiguration['localEchoStyle']) {\n\t\tconst { applyArgs, undoArgs } = this._getArgs(style);\n\t\tthis._applyArgs = applyArgs;\n\t\tthis._undoArgs = this._originalUndoArgs = undoArgs;\n\t\tthis.apply = TypeAheadStyle._compileArgs(this._applyArgs);\n\t\tthis.undo = TypeAheadStyle._compileArgs(this._undoArgs);\n\t}\n\n\tprivate _getArgs(style: ITerminalTypeAheadConfiguration['localEchoStyle']) {\n\t\tswitch (style) {\n\t\t\tcase 'bold':\n\t\t\t\treturn { applyArgs: [1], undoArgs: [22] };\n\t\t\tcase 'dim':\n\t\t\t\treturn { applyArgs: [2], undoArgs: [22] };\n\t\t\tcase 'italic':\n\t\t\t\treturn { applyArgs: [3], undoArgs: [23] };\n\t\t\tcase 'underlined':\n\t\t\t\treturn { applyArgs: [4], undoArgs: [24] };\n\t\t\tcase 'inverted':\n\t\t\t\treturn { applyArgs: [7], undoArgs: [27] };\n\t\t\tdefault: {\n\t\t\t\tlet color: Color;\n\t\t\t\ttry {\n\t\t\t\t\tcolor = Color.fromHex(style);\n\t\t\t\t} catch {\n\t\t\t\t\tcolor = new Color(new RGBA(255, 0, 0, 1));\n\t\t\t\t}\n\n\t\t\t\tconst { r, g, b } = color.rgba;\n\t\t\t\treturn { applyArgs: [38, 2, r, g, b], undoArgs: [39] };\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst compileExcludeRegexp = (programs = DEFAULT_LOCAL_ECHO_EXCLUDE) =>\n\tnew RegExp(`\\\\b(${programs.map(escapeRegExpCharacters).join('|')})\\\\b`, 'i');\n\nexport const enum CharPredictState {\n\t/** No characters typed on this line yet */\n\tUnknown,\n\t/** Has a pending character prediction */\n\tHasPendingChar,\n\t/** Character validated on this line */\n\tValidated,\n}\n\nexport class TypeAheadAddon extends Disposable implements ITerminalAddon {\n\tprivate _typeaheadStyle?: TypeAheadStyle;\n\tprivate _typeaheadThreshold = this._configurationService.getValue<ITerminalTypeAheadConfiguration>(TERMINAL_CONFIG_SECTION).localEchoLatencyThreshold;\n\tprivate _excludeProgramRe = compileExcludeRegexp(this._configurationService.getValue<ITerminalTypeAheadConfiguration>(TERMINAL_CONFIG_SECTION).localEchoExcludePrograms);\n\tprotected _lastRow?: { y: number; startingX: number; endingX: number; charState: CharPredictState };\n\tprotected _timeline?: PredictionTimeline;\n\tprivate _terminalTitle = '';\n\tstats?: PredictionStats;\n\n\t/**\n\t * Debounce that clears predictions after a timeout if the PTY doesn't apply them.\n\t */\n\tprivate _clearPredictionDebounce?: IDisposable;\n\n\tconstructor(\n\t\tprivate _processManager: ITerminalProcessManager,\n\t\t@IConfigurationService private readonly _configurationService: IConfigurationService,\n\t\t@ITelemetryService private readonly _telemetryService: ITelemetryService,\n\t) {\n\t\tsuper();\n\t\tthis._register(toDisposable(() => this._clearPredictionDebounce?.dispose()));\n\t}\n\n\tactivate(terminal: Terminal): void {\n\t\tconst style = this._typeaheadStyle = this._register(new TypeAheadStyle(this._configurationService.getValue<ITerminalTypeAheadConfiguration>(TERMINAL_CONFIG_SECTION).localEchoStyle, terminal));\n\t\tconst timeline = this._timeline = new PredictionTimeline(terminal, this._typeaheadStyle);\n\t\tconst stats = this.stats = this._register(new PredictionStats(this._timeline));\n\n\t\ttimeline.setShowPredictions(this._typeaheadThreshold === 0);\n\t\tthis._register(terminal.onData(e => this._onUserData(e)));\n\t\tthis._register(terminal.onTitleChange(title => {\n\t\t\tthis._terminalTitle = title;\n\t\t\tthis._reevaluatePredictorState(stats, timeline);\n\t\t}));\n\t\tthis._register(terminal.onResize(() => {\n\t\t\ttimeline.setShowPredictions(false);\n\t\t\ttimeline.clearCursor();\n\t\t\tthis._reevaluatePredictorState(stats, timeline);\n\t\t}));\n\t\tthis._register(this._configurationService.onDidChangeConfiguration(e => {\n\t\t\tif (e.affectsConfiguration(TERMINAL_CONFIG_SECTION)) {\n\t\t\t\tstyle.onUpdate(this._configurationService.getValue<ITerminalTypeAheadConfiguration>(TERMINAL_CONFIG_SECTION).localEchoStyle);\n\t\t\t\tthis._typeaheadThreshold = this._configurationService.getValue<ITerminalTypeAheadConfiguration>(TERMINAL_CONFIG_SECTION).localEchoLatencyThreshold;\n\t\t\t\tthis._excludeProgramRe = compileExcludeRegexp(this._configurationService.getValue<ITerminalTypeAheadConfiguration>(TERMINAL_CONFIG_SECTION).localEchoExcludePrograms);\n\t\t\t\tthis._reevaluatePredictorState(stats, timeline);\n\t\t\t}\n\t\t}));\n\t\tthis._register(this._timeline.onPredictionSucceeded(p => {\n\t\t\tif (this._lastRow?.charState === CharPredictState.HasPendingChar && isTenativeCharacterPrediction(p) && p.inner.appliedAt) {\n\t\t\t\tif (p.inner.appliedAt.pos.y + p.inner.appliedAt.pos.baseY === this._lastRow.y) {\n\t\t\t\t\tthis._lastRow.charState = CharPredictState.Validated;\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\t\tthis._register(this._processManager.onBeforeProcessData(e => this._onBeforeProcessData(e)));\n\n\t\tlet nextStatsSend: any;\n\t\tthis._register(stats.onChange(() => {\n\t\t\tif (!nextStatsSend) {\n\t\t\t\tnextStatsSend = setTimeout(() => {\n\t\t\t\t\tthis._sendLatencyStats(stats);\n\t\t\t\t\tnextStatsSend = undefined;\n\t\t\t\t}, StatsConstants.StatsSendTelemetryEvery);\n\t\t\t}\n\n\t\t\tif (timeline.length === 0) {\n\t\t\t\tstyle.debounceStopTracking();\n\t\t\t}\n\n\t\t\tthis._reevaluatePredictorState(stats, timeline);\n\t\t}));\n\t}\n\n\treset() {\n\t\tthis._lastRow = undefined;\n\t}\n\n\tprivate _deferClearingPredictions() {\n\t\tif (!this.stats || !this._timeline) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._clearPredictionDebounce?.dispose();\n\t\tif (this._timeline.length === 0 || this._timeline.peekStart()?.clearAfterTimeout === false) {\n\t\t\tthis._clearPredictionDebounce = undefined;\n\t\t\treturn;\n\t\t}\n\n\t\tthis._clearPredictionDebounce = disposableTimeout(\n\t\t\t() => {\n\t\t\t\tthis._timeline?.undoAllPredictions();\n\t\t\t\tif (this._lastRow?.charState === CharPredictState.HasPendingChar) {\n\t\t\t\t\tthis._lastRow.charState = CharPredictState.Unknown;\n\t\t\t\t}\n\t\t\t},\n\t\t\tMath.max(500, this.stats.maxLatency * 3 / 2),\n\t\t\tthis._store\n\t\t);\n\t}\n\n\t/**\n\t * Note on debounce:\n\t *\n\t * We want to toggle the state only when the user has a pause in their\n\t * typing. Otherwise, we could turn this on when the PTY sent data but the\n\t * terminal cursor is not updated, causes issues.\n\t */\n\t@debounce(100)\n\tprotected _reevaluatePredictorState(stats: PredictionStats, timeline: PredictionTimeline) {\n\t\tthis._reevaluatePredictorStateNow(stats, timeline);\n\t}\n\n\tprotected _reevaluatePredictorStateNow(stats: PredictionStats, timeline: PredictionTimeline) {\n\t\tif (this._excludeProgramRe.test(this._terminalTitle)) {\n\t\t\ttimeline.setShowPredictions(false);\n\t\t} else if (this._typeaheadThreshold < 0) {\n\t\t\ttimeline.setShowPredictions(false);\n\t\t} else if (this._typeaheadThreshold === 0) {\n\t\t\ttimeline.setShowPredictions(true);\n\t\t} else if (stats.sampleSize > StatsConstants.StatsMinSamplesToTurnOn && stats.accuracy > StatsConstants.StatsMinAccuracyToTurnOn) {\n\t\t\tconst latency = stats.latency.median;\n\t\t\tif (latency >= this._typeaheadThreshold) {\n\t\t\t\ttimeline.setShowPredictions(true);\n\t\t\t} else if (latency < this._typeaheadThreshold / StatsConstants.StatsToggleOffThreshold) {\n\t\t\t\ttimeline.setShowPredictions(false);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _sendLatencyStats(stats: PredictionStats) {\n\t\t/* __GDPR__\n\t\t\t\"terminalLatencyStats\" : {\n\t\t\t\t\"owner\": \"Tyriar\",\n\t\t\t\t\"min\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\t\t\"max\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\t\t\"median\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\t\t\"count\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\t\t\"predictionAccuracy\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true }\n\t\t\t}\n\t\t */\n\t\tthis._telemetryService.publicLog('terminalLatencyStats', {\n\t\t\t...stats.latency,\n\t\t\tpredictionAccuracy: stats.accuracy,\n\t\t});\n\t}\n\n\tprivate _onUserData(data: string): void {\n\t\tif (this._timeline?.terminal.buffer.active.type !== 'normal') {\n\t\t\treturn;\n\t\t}\n\n\t\t// console.log('user data:', JSON.stringify(data));\n\n\t\tconst terminal = this._timeline.terminal;\n\t\tconst buffer = terminal.buffer.active;\n\n\t\t// Detect programs like git log/less that use the normal buffer but don't\n\t\t// take input by deafult (fixes #109541)\n\t\tif (buffer.cursorX === 1 && buffer.cursorY === terminal.rows - 1) {\n\t\t\tif (buffer.getLine(buffer.cursorY + buffer.baseY)?.getCell(0)?.getChars() === ':') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// the following code guards the terminal prompt to avoid being able to\n\t\t// arrow or backspace-into the prompt. Record the lowest X value at which\n\t\t// the user gave input, and mark all additions before that as tentative.\n\t\tconst actualY = buffer.baseY + buffer.cursorY;\n\t\tif (actualY !== this._lastRow?.y) {\n\t\t\tthis._lastRow = { y: actualY, startingX: buffer.cursorX, endingX: buffer.cursorX, charState: CharPredictState.Unknown };\n\t\t} else {\n\t\t\tthis._lastRow.startingX = Math.min(this._lastRow.startingX, buffer.cursorX);\n\t\t\tthis._lastRow.endingX = Math.max(this._lastRow.endingX, this._timeline.physicalCursor(buffer).x);\n\t\t}\n\n\t\tconst addLeftNavigating = (p: IPrediction) =>\n\t\t\tthis._timeline!.tentativeCursor(buffer).x <= this._lastRow!.startingX\n\t\t\t\t? this._timeline!.addBoundary(buffer, p)\n\t\t\t\t: this._timeline!.addPrediction(buffer, p);\n\n\t\tconst addRightNavigating = (p: IPrediction) =>\n\t\t\tthis._timeline!.tentativeCursor(buffer).x >= this._lastRow!.endingX - 1\n\t\t\t\t? this._timeline!.addBoundary(buffer, p)\n\t\t\t\t: this._timeline!.addPrediction(buffer, p);\n\n\t\t/** @see https://github.com/xtermjs/xterm.js/blob/1913e9512c048e3cf56bb5f5df51bfff6899c184/src/common/input/Keyboard.ts */\n\t\tconst reader = new StringReader(data);\n\t\twhile (reader.remaining > 0) {\n\t\t\tif (reader.eatCharCode(127)) { // backspace\n\t\t\t\tconst previous = this._timeline.peekEnd();\n\t\t\t\tif (previous && previous instanceof CharacterPrediction) {\n\t\t\t\t\tthis._timeline.addBoundary();\n\t\t\t\t}\n\n\t\t\t\t// backspace must be able to read the previously-written character in\n\t\t\t\t// the event that it needs to undo it\n\t\t\t\tif (this._timeline.isShowingPredictions) {\n\t\t\t\t\tflushOutput(this._timeline.terminal);\n\t\t\t\t}\n\n\t\t\t\tif (this._timeline.tentativeCursor(buffer).x <= this._lastRow.startingX) {\n\t\t\t\t\tthis._timeline.addBoundary(buffer, new BackspacePrediction(this._timeline.terminal));\n\t\t\t\t} else {\n\t\t\t\t\t// Backspace decrements our ability to go right.\n\t\t\t\t\tthis._lastRow.endingX--;\n\t\t\t\t\tthis._timeline.addPrediction(buffer, new BackspacePrediction(this._timeline.terminal));\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (reader.eatCharCode(32, 126)) { // alphanum\n\t\t\t\tconst char = data[reader.index - 1];\n\t\t\t\tconst prediction = new CharacterPrediction(this._typeaheadStyle!, char);\n\t\t\t\tif (this._lastRow.charState === CharPredictState.Unknown) {\n\t\t\t\t\tthis._timeline.addBoundary(buffer, prediction);\n\t\t\t\t\tthis._lastRow.charState = CharPredictState.HasPendingChar;\n\t\t\t\t} else {\n\t\t\t\t\tthis._timeline.addPrediction(buffer, prediction);\n\t\t\t\t}\n\n\t\t\t\tif (this._timeline.tentativeCursor(buffer).x >= terminal.cols) {\n\t\t\t\t\tthis._timeline.addBoundary(buffer, new LinewrapPrediction());\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst cursorMv = reader.eatRe(CSI_MOVE_RE);\n\t\t\tif (cursorMv) {\n\t\t\t\tconst direction = cursorMv[3] as CursorMoveDirection;\n\t\t\t\tconst p = new CursorMovePrediction(direction, !!cursorMv[2], Number(cursorMv[1]) || 1);\n\t\t\t\tif (direction === CursorMoveDirection.Back) {\n\t\t\t\t\taddLeftNavigating(p);\n\t\t\t\t} else {\n\t\t\t\t\taddRightNavigating(p);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (reader.eatStr(`${VT.Esc}f`)) {\n\t\t\t\taddRightNavigating(new CursorMovePrediction(CursorMoveDirection.Forwards, true, 1));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (reader.eatStr(`${VT.Esc}b`)) {\n\t\t\t\taddLeftNavigating(new CursorMovePrediction(CursorMoveDirection.Back, true, 1));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (reader.eatChar('\\r') && buffer.cursorY < terminal.rows - 1) {\n\t\t\t\tthis._timeline.addPrediction(buffer, new NewlinePrediction());\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// something else\n\t\t\tthis._timeline.addBoundary(buffer, new HardBoundary());\n\t\t\tbreak;\n\t\t}\n\n\t\tif (this._timeline.length === 1) {\n\t\t\tthis._deferClearingPredictions();\n\t\t\tthis._typeaheadStyle!.startTracking();\n\t\t}\n\t}\n\n\tprivate _onBeforeProcessData(event: IBeforeProcessDataEvent): void {\n\t\tif (!this._timeline) {\n\t\t\treturn;\n\t\t}\n\n\t\t// console.log('incoming data:', JSON.stringify(event.data));\n\t\tevent.data = this._timeline.beforeServerInput(event.data);\n\t\t// console.log('emitted data:', JSON.stringify(event.data));\n\n\t\tthis._deferClearingPredictions();\n\t}\n}\n"],
  "mappings": "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",
  "names": ["VT", "StatsConstants", "CursorMoveDirection", "MatchResult", "CharPredictState"]
}
