import{notEqual as s,strictEqual as l,throws as p}from"assert";import{importAMDNodeModule as u}from"../../../../../../amdX.js";import{ensureNoDisposablesAreLeakedInTestSuite as f}from"../../../../../../base/test/common/utils.js";import{TestConfigurationService as D}from"../../../../../../platform/configuration/test/common/testConfigurationService.js";import{TerminalCapability as h}from"../../../../../../platform/terminal/common/capabilities/capabilities.js";import{CommandDetectionCapability as w}from"../../../../../../platform/terminal/common/capabilities/commandDetectionCapability.js";import{TerminalCapabilityStore as k}from"../../../../../../platform/terminal/common/capabilities/terminalCapabilityStore.js";import{DecorationAddon as T}from"../../../browser/xterm/decorationAddon.js";import{workbenchInstantiationService as C}from"../../../../../test/browser/workbenchTestServices.js";suite("DecorationAddon",()=>{const o=f();let r,t;setup(async()=>{const e=(await u("@xterm/xterm","lib/xterm.js")).Terminal;class m extends e{registerDecoration(i){if(i.marker.isDisposed)return;const d=document.createElement("div");return{marker:i.marker,element:d,onDispose:()=>{},isDisposed:!1,dispose:()=>{},onRender:c=>c}}}const n=C({configurationService:()=>new D({files:{},workbench:{hover:{delay:5}},terminal:{integrated:{shellIntegration:{decorationsEnabled:"both"}}}})},o);t=o.add(new m({allowProposedApi:!0,cols:80,rows:30}));const a=o.add(new k);a.add(h.CommandDetection,o.add(n.createInstance(w,t))),r=o.add(n.createInstance(T,a)),t.loadAddon(r)}),suite("registerDecoration",()=>{test("should throw when command has no marker",async()=>{p(()=>r.registerCommandDecoration({command:"cd src",timestamp:Date.now(),hasOutput:()=>!1}))}),test("should return undefined when marker has been disposed of",async()=>{const e=t.registerMarker(1);e?.dispose(),l(r.registerCommandDecoration({command:"cd src",marker:e,timestamp:Date.now(),hasOutput:()=>!1}),void 0)}),test("should return decoration when marker has not been disposed of",async()=>{const e=t.registerMarker(2);s(r.registerCommandDecoration({command:"cd src",marker:e,timestamp:Date.now(),hasOutput:()=>!1}),void 0)}),test("should return decoration with mark properties",async()=>{const e=t.registerMarker(2);s(r.registerCommandDecoration(void 0,void 0,{marker:e}),void 0)})})});
