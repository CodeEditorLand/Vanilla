import{deepEqual as p,deepStrictEqual as w,strictEqual as n}from"assert";import*as u from"sinon";import{importAMDNodeModule as y}from"../../../../../../amdX.js";import{ensureNoDisposablesAreLeakedInTestSuite as C}from"../../../../../../base/test/common/utils.js";import{NullLogService as k}from"../../../../../../platform/log/common/log.js";import{TerminalCapability as s}from"../../../../../../platform/terminal/common/capabilities/capabilities.js";import{deserializeMessage as b,parseKeyValueAssignment as g,parseMarkSequence as f,ShellIntegrationAddon as D}from"../../../../../../platform/terminal/common/xterm/shellIntegrationAddon.js";import{writeP as a}from"../../../browser/terminalTestHelpers.js";class $ extends D{getCommandDetectionMock(t){const i=super._createOrGetCommandDetection(t);return this.capabilities.add(s.CommandDetection,i),u.mock(i)}getCwdDectionMock(){const t=super._createOrGetCwdDetection();return this.capabilities.add(s.CwdDetection,t),u.mock(t)}}suite("ShellIntegrationAddon",()=>{const h=C();let t,i,o;setup(async()=>{const e=(await y("@xterm/xterm","lib/xterm.js")).Terminal;t=h.add(new e({allowProposedApi:!0,cols:80,rows:30})),i=h.add(new $("",!0,void 0,new k)),t.loadAddon(i),o=i.capabilities}),suite("cwd detection",()=>{test("should activate capability on the cwd sequence (OSC 633 ; P ; Cwd=<cwd> ST)",async()=>{n(o.has(s.CwdDetection),!1),await a(t,"foo"),n(o.has(s.CwdDetection),!1),await a(t,"\x1B]633;P;Cwd=/foo\x07"),n(o.has(s.CwdDetection),!0)}),test("should pass cwd sequence to the capability",async()=>{const e=i.getCwdDectionMock();e.expects("updateCwd").once().withExactArgs("/foo"),await a(t,"\x1B]633;P;Cwd=/foo\x07"),e.verify()}),test("detect ITerm sequence: `OSC 1337 ; CurrentDir=<Cwd> ST`",async()=>{const e=[["root","/","/"],["non-root","/some/path","/some/path"]];for(const c of e){const[d,m,l]=c,r=i.getCwdDectionMock();r.expects("updateCwd").once().withExactArgs(l).named(d),await a(t,`\x1B]1337;CurrentDir=${m}\x07`),r.verify()}}),suite("detect `SetCwd` sequence: `OSC 7; scheme://cwd ST`",()=>{test("should accept well-formatted URLs",async()=>{const e=[["empty hostname, pointing root","file:///","/"],["empty hostname","file:///test-root/local","/test-root/local"],["non-empty hostname","file://some-hostname/test-root/local","/test-root/local"],["URL-encoded value (1)","file:///test-root/%6c%6f%63%61%6c","/test-root/local"],["URL-encoded value (2)","file:///test-root/local%22",'/test-root/local"'],["URL-encoded value (3)",'file:///test-root/local"','/test-root/local"']];for(const c of e){const[d,m,l]=c,r=i.getCwdDectionMock();r.expects("updateCwd").once().withExactArgs(l).named(d),await a(t,`\x1B]7;${m}\x07`),r.verify()}}),test("should ignore ill-formatted URLs",async()=>{const e=[["no hostname, pointing root","file://"],["no scheme (1)","/test-root"],["no scheme (2)","//test-root"],["no scheme (3)","///test-root"],["no scheme (4)",":///test-root"],["http","http:///test-root"],["ftp","ftp:///test-root"],["ssh","ssh:///test-root"]];for(const c of e){const[d,m]=c,l=i.getCwdDectionMock();l.expects("updateCwd").never().named(d),await a(t,`\x1B]7;${m}\x07`),l.verify()}})}),test("detect `SetWindowsFrindlyCwd` sequence: `OSC 9 ; 9 ; <cwd> ST`",async()=>{const e=[["root","/","/"],["non-root","/some/path","/some/path"]];for(const c of e){const[d,m,l]=c,r=i.getCwdDectionMock();r.expects("updateCwd").once().withExactArgs(l).named(d),await a(t,`\x1B]9;9;${m}\x07`),r.verify()}})}),suite("command tracking",()=>{test("should activate capability on the prompt start sequence (OSC 633 ; A ST)",async()=>{n(o.has(s.CommandDetection),!1),await a(t,"foo"),n(o.has(s.CommandDetection),!1),await a(t,"\x1B]633;A\x07"),n(o.has(s.CommandDetection),!0)}),test("should pass prompt start sequence to the capability",async()=>{const e=i.getCommandDetectionMock(t);e.expects("handlePromptStart").once().withExactArgs(),await a(t,"\x1B]633;A\x07"),e.verify()}),test("should activate capability on the command start sequence (OSC 633 ; B ST)",async()=>{n(o.has(s.CommandDetection),!1),await a(t,"foo"),n(o.has(s.CommandDetection),!1),await a(t,"\x1B]633;B\x07"),n(o.has(s.CommandDetection),!0)}),test("should pass command start sequence to the capability",async()=>{const e=i.getCommandDetectionMock(t);e.expects("handleCommandStart").once().withExactArgs(),await a(t,"\x1B]633;B\x07"),e.verify()}),test("should activate capability on the command executed sequence (OSC 633 ; C ST)",async()=>{n(o.has(s.CommandDetection),!1),await a(t,"foo"),n(o.has(s.CommandDetection),!1),await a(t,"\x1B]633;C\x07"),n(o.has(s.CommandDetection),!0)}),test("should pass command executed sequence to the capability",async()=>{const e=i.getCommandDetectionMock(t);e.expects("handleCommandExecuted").once().withExactArgs(),await a(t,"\x1B]633;C\x07"),e.verify()}),test("should activate capability on the command finished sequence (OSC 633 ; D ; <ExitCode> ST)",async()=>{n(o.has(s.CommandDetection),!1),await a(t,"foo"),n(o.has(s.CommandDetection),!1),await a(t,"\x1B]633;D;7\x07"),n(o.has(s.CommandDetection),!0)}),test("should pass command finished sequence to the capability",async()=>{const e=i.getCommandDetectionMock(t);e.expects("handleCommandFinished").once().withExactArgs(7),await a(t,"\x1B]633;D;7\x07"),e.verify()}),test("should pass command line sequence to the capability",async()=>{const e=i.getCommandDetectionMock(t);e.expects("setCommandLine").once().withExactArgs("",!1),await a(t,"\x1B]633;E\x07"),e.verify();const c=i.getCommandDetectionMock(t);c.expects("setCommandLine").twice().withExactArgs("cmd",!1),await a(t,"\x1B]633;E;cmd\x07"),await a(t,"\x1B]633;E;cmd;invalid-nonce\x07"),c.verify()}),test("should not activate capability on the cwd sequence (OSC 633 ; P=Cwd=<cwd> ST)",async()=>{n(o.has(s.CommandDetection),!1),await a(t,"foo"),n(o.has(s.CommandDetection),!1),await a(t,"\x1B]633;P;Cwd=/foo\x07"),n(o.has(s.CommandDetection),!1)}),test("should pass cwd sequence to the capability if it's initialized",async()=>{const e=i.getCommandDetectionMock(t);e.expects("setCwd").once().withExactArgs("/foo"),await a(t,"\x1B]633;P;Cwd=/foo\x07"),e.verify()})}),suite("BufferMarkCapability",()=>{test("SetMark",async()=>{n(o.has(s.BufferMarkDetection),!1),await a(t,"foo"),n(o.has(s.BufferMarkDetection),!1),await a(t,"\x1B]633;SetMark;\x07"),n(o.has(s.BufferMarkDetection),!0)}),test("SetMark - ID",async()=>{n(o.has(s.BufferMarkDetection),!1),await a(t,"foo"),n(o.has(s.BufferMarkDetection),!1),await a(t,"\x1B]633;SetMark;1;\x07"),n(o.has(s.BufferMarkDetection),!0)}),test("SetMark - hidden",async()=>{n(o.has(s.BufferMarkDetection),!1),await a(t,"foo"),n(o.has(s.BufferMarkDetection),!1),await a(t,"\x1B]633;SetMark;;Hidden\x07"),n(o.has(s.BufferMarkDetection),!0)}),test("SetMark - hidden & ID",async()=>{n(o.has(s.BufferMarkDetection),!1),await a(t,"foo"),n(o.has(s.BufferMarkDetection),!1),await a(t,"\x1B]633;SetMark;1;Hidden\x07"),n(o.has(s.BufferMarkDetection),!0)}),suite("parseMarkSequence",()=>{test("basic",async()=>{p(f(["",""]),{id:void 0,hidden:!1})}),test("ID",async()=>{p(f(["Id=3",""]),{id:"3",hidden:!1})}),test("hidden",async()=>{p(f(["","Hidden"]),{id:void 0,hidden:!0})}),test("ID + hidden",async()=>{p(f(["Id=4555","Hidden"]),{id:"4555",hidden:!0})})})}),suite("deserializeMessage",()=>{const e="\\",c=`
`,d=";";[["empty","",""],["basic","value","value"],["space","some thing","some thing"],["escaped backslash",`${e}${e}`,e],["non-initial escaped backslash",`foo${e}${e}`,`foo${e}`],["two escaped backslashes",`${e}${e}${e}${e}`,`${e}${e}`],["escaped backslash amidst text",`Hello${e}${e}there`,`Hello${e}there`],["backslash escaped literally and as hex",`${e}${e} is same as ${e}x5c`,`${e} is same as ${e}`],["escaped semicolon",`${e}x3b`,d],["non-initial escaped semicolon",`foo${e}x3b`,`foo${d}`],["escaped semicolon (upper hex)",`${e}x3B`,d],['escaped backslash followed by literal "x3b" is not a semicolon',`${e}${e}x3b`,`${e}x3b`],['non-initial escaped backslash followed by literal "x3b" is not a semicolon',`foo${e}${e}x3b`,`foo${e}x3b`],["escaped backslash followed by escaped semicolon",`${e}${e}${e}x3b`,`${e}${d}`],["escaped semicolon amidst text",`some${e}x3bthing`,`some${d}thing`],["escaped newline",`${e}x0a`,c],["non-initial escaped newline",`foo${e}x0a`,`foo${c}`],["escaped newline (upper hex)",`${e}x0A`,c],['escaped backslash followed by literal "x0a" is not a newline',`${e}${e}x0a`,`${e}x0a`],['non-initial escaped backslash followed by literal "x0a" is not a newline',`foo${e}${e}x0a`,`foo${e}x0a`]].forEach(([l,r,x])=>{test(l,()=>n(b(r),x))})}),test("parseKeyValueAssignment",()=>{[["empty","",["",void 0]],['no "=" sign',"some-text",["some-text",void 0]],["empty value","key=",["key",""]],["empty key","=value",["","value"]],["normal","key=value",["key","value"]],['multiple "=" signs (1)',"key==value",["key","=value"]],['multiple "=" signs (2)',"key=value===true",["key","value===true"]],['just a "="',"=",["",""]],['just a "=="',"==",["","="]]].forEach(c=>{const[d,m,[l,r]]=c;w(g(m),{key:l,value:r},d)})})});
