import{fail as o}from"assert";import{Emitter as m}from"../../../../../base/common/event.js";import{ensureNoDisposablesAreLeakedInTestSuite as f}from"../../../../../base/test/common/utils.js";import{TestConfigurationService as d}from"../../../../../platform/configuration/test/common/testConfigurationService.js";import{IDialogService as c}from"../../../../../platform/dialogs/common/dialogs.js";import{TestDialogService as u}from"../../../../../platform/dialogs/test/common/testDialogService.js";import{TerminalLocation as a}from"../../../../../platform/terminal/common/terminal.js";import{ITerminalInstanceService as l,ITerminalService as p}from"../../browser/terminal.js";import{TerminalService as h}from"../../browser/terminalService.js";import{TERMINAL_CONFIG_SECTION as T}from"../../common/terminal.js";import{IRemoteAgentService as I}from"../../../../services/remote/common/remoteAgentService.js";import{workbenchInstantiationService as P}from"../../../../test/browser/workbenchTestServices.js";suite("Workbench - TerminalService",()=>{const t=f();let i,n,s;setup(async()=>{s=new u,n=new d({files:{},terminal:{integrated:{confirmOnKill:"never"}}});const e=P({configurationService:()=>n},t);e.stub(c,s),e.stub(l,"getBackend",void 0),e.stub(l,"getRegisteredBackends",[]),e.stub(I,"getConnection",null),i=t.add(e.createInstance(h)),e.stub(p,i)}),suite("safeDisposeTerminal",()=>{let e;setup(()=>{e=t.add(new m)}),test("should not show prompt when confirmOnKill is never",async()=>{await r(n,"never"),await i.safeDisposeTerminal({target:a.Editor,hasChildProcesses:!0,onExit:e.event,dispose:()=>e.fire(void 0)}),await i.safeDisposeTerminal({target:a.Panel,hasChildProcesses:!0,onExit:e.event,dispose:()=>e.fire(void 0)})}),test("should not show prompt when any terminal editor is closed (handled by editor itself)",async()=>{await r(n,"editor"),i.safeDisposeTerminal({target:a.Editor,hasChildProcesses:!0,onExit:e.event,dispose:()=>e.fire(void 0)}),await r(n,"always"),i.safeDisposeTerminal({target:a.Editor,hasChildProcesses:!0,onExit:e.event,dispose:()=>e.fire(void 0)})}),test("should not show prompt when confirmOnKill is editor and panel terminal is closed",async()=>{await r(n,"editor"),i.safeDisposeTerminal({target:a.Panel,hasChildProcesses:!0,onExit:e.event,dispose:()=>e.fire(void 0)})}),test("should show prompt when confirmOnKill is panel and panel terminal is closed",async()=>{await r(n,"panel"),s.setConfirmResult({confirmed:!1}),i.safeDisposeTerminal({target:a.Panel,hasChildProcesses:!1,onExit:e.event,dispose:()=>e.fire(void 0)}),s.setConfirmResult({confirmed:!0}),i.safeDisposeTerminal({target:a.Panel,hasChildProcesses:!1,onExit:e.event,dispose:()=>e.fire(void 0)}),s.setConfirmResult({confirmed:!1}),await i.safeDisposeTerminal({target:a.Panel,hasChildProcesses:!0,dispose:()=>o()}),s.setConfirmResult({confirmed:!0}),i.safeDisposeTerminal({target:a.Panel,hasChildProcesses:!0,onExit:e.event,dispose:()=>e.fire(void 0)})}),test("should show prompt when confirmOnKill is always and panel terminal is closed",async()=>{await r(n,"always"),s.setConfirmResult({confirmed:!1}),i.safeDisposeTerminal({target:a.Panel,hasChildProcesses:!1,onExit:e.event,dispose:()=>e.fire(void 0)}),s.setConfirmResult({confirmed:!0}),i.safeDisposeTerminal({target:a.Panel,hasChildProcesses:!1,onExit:e.event,dispose:()=>e.fire(void 0)}),s.setConfirmResult({confirmed:!1}),await i.safeDisposeTerminal({target:a.Panel,hasChildProcesses:!0,dispose:()=>o()}),s.setConfirmResult({confirmed:!0}),i.safeDisposeTerminal({target:a.Panel,hasChildProcesses:!0,onExit:e.event,dispose:()=>e.fire(void 0)})})})});async function r(t,i){await t.setUserConfiguration(T,{confirmOnKill:i}),t.onDidChangeConfigurationEmitter.fire({affectsConfiguration:()=>!0,affectedKeys:["terminal.integrated.confirmOnKill"]})}
