{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/terminal/common/history.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Disposable } from \"../../../../base/common/lifecycle.js\";\nimport { LRUCache } from \"../../../../base/common/map.js\";\nimport { Schemas } from \"../../../../base/common/network.js\";\nimport { join } from \"../../../../base/common/path.js\";\nimport {\n\tOperatingSystem,\n\tisWindows,\n} from \"../../../../base/common/platform.js\";\nimport { env } from \"../../../../base/common/process.js\";\nimport { URI } from \"../../../../base/common/uri.js\";\nimport { IConfigurationService } from \"../../../../platform/configuration/common/configuration.js\";\nimport {\n\tFileOperationError,\n\tFileOperationResult,\n\ttype IFileContent,\n\tIFileService,\n} from \"../../../../platform/files/common/files.js\";\nimport {\n\tIInstantiationService,\n\ttype ServicesAccessor,\n} from \"../../../../platform/instantiation/common/instantiation.js\";\nimport {\n\tIStorageService,\n\tStorageScope,\n\tStorageTarget,\n} from \"../../../../platform/storage/common/storage.js\";\nimport {\n\tGeneralShellType,\n\tPosixShellType,\n\tTerminalSettingId,\n\ttype TerminalShellType,\n} from \"../../../../platform/terminal/common/terminal.js\";\nimport { IRemoteAgentService } from \"../../../services/remote/common/remoteAgentService.js\";\n\n/**\n * Tracks a list of generic entries.\n */\nexport interface ITerminalPersistedHistory<T> {\n\t/**\n\t * The persisted entries.\n\t */\n\treadonly entries: IterableIterator<[string, T]>;\n\t/**\n\t * Adds an entry.\n\t */\n\tadd(key: string, value: T): void;\n\t/**\n\t * Removes an entry.\n\t */\n\tremove(key: string): void;\n\t/**\n\t * Clears all entries.\n\t */\n\tclear(): void;\n}\n\ninterface ISerializedCache<T> {\n\tentries: { key: string; value: T }[];\n}\n\nenum Constants {\n\tDefaultHistoryLimit = 100,\n}\n\nenum StorageKeys {\n\tEntries = \"terminal.history.entries\",\n\tTimestamp = \"terminal.history.timestamp\",\n}\n\nlet commandHistory:\n\t| ITerminalPersistedHistory<{ shellType: TerminalShellType }>\n\t| undefined;\nexport function getCommandHistory(\n\taccessor: ServicesAccessor,\n): ITerminalPersistedHistory<{ shellType: TerminalShellType | undefined }> {\n\tif (!commandHistory) {\n\t\tcommandHistory = accessor\n\t\t\t.get(IInstantiationService)\n\t\t\t.createInstance(\n\t\t\t\tTerminalPersistedHistory,\n\t\t\t\t\"commands\",\n\t\t\t) as TerminalPersistedHistory<{ shellType: TerminalShellType }>;\n\t}\n\treturn commandHistory;\n}\n\nlet directoryHistory:\n\t| ITerminalPersistedHistory<{ remoteAuthority?: string }>\n\t| undefined;\nexport function getDirectoryHistory(\n\taccessor: ServicesAccessor,\n): ITerminalPersistedHistory<{ remoteAuthority?: string }> {\n\tif (!directoryHistory) {\n\t\tdirectoryHistory = accessor\n\t\t\t.get(IInstantiationService)\n\t\t\t.createInstance(\n\t\t\t\tTerminalPersistedHistory,\n\t\t\t\t\"dirs\",\n\t\t\t) as TerminalPersistedHistory<{ remoteAuthority?: string }>;\n\t}\n\treturn directoryHistory;\n}\n\n// Shell file history loads once per shell per window\nconst shellFileHistory: Map<TerminalShellType | undefined, string[] | null> =\n\tnew Map();\nexport async function getShellFileHistory(\n\taccessor: ServicesAccessor,\n\tshellType: TerminalShellType | undefined,\n): Promise<string[]> {\n\tconst cached = shellFileHistory.get(shellType);\n\tif (cached === null) {\n\t\treturn [];\n\t}\n\tif (cached !== undefined) {\n\t\treturn cached;\n\t}\n\tlet result: IterableIterator<string> | undefined;\n\tswitch (shellType) {\n\t\tcase PosixShellType.Bash:\n\t\t\tresult = await fetchBashHistory(accessor);\n\t\t\tbreak;\n\t\tcase GeneralShellType.PowerShell:\n\t\t\tresult = await fetchPwshHistory(accessor);\n\t\t\tbreak;\n\t\tcase PosixShellType.Zsh:\n\t\t\tresult = await fetchZshHistory(accessor);\n\t\t\tbreak;\n\t\tcase PosixShellType.Fish:\n\t\t\tresult = await fetchFishHistory(accessor);\n\t\t\tbreak;\n\t\tcase GeneralShellType.Python:\n\t\t\tresult = await fetchPythonHistory(accessor);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn [];\n\t}\n\tif (result === undefined) {\n\t\tshellFileHistory.set(shellType, null);\n\t\treturn [];\n\t}\n\tconst array = Array.from(result);\n\tshellFileHistory.set(shellType, array);\n\treturn array;\n}\nexport function clearShellFileHistory() {\n\tshellFileHistory.clear();\n}\n\nexport class TerminalPersistedHistory<T>\n\textends Disposable\n\timplements ITerminalPersistedHistory<T>\n{\n\tprivate readonly _entries: LRUCache<string, T>;\n\tprivate _timestamp = 0;\n\tprivate _isReady = false;\n\tprivate _isStale = true;\n\n\tget entries(): IterableIterator<[string, T]> {\n\t\tthis._ensureUpToDate();\n\t\treturn this._entries.entries();\n\t}\n\n\tconstructor(\n\t\tprivate readonly _storageDataKey: string,\n\t\t@IConfigurationService private readonly _configurationService: IConfigurationService,\n\t\t@IStorageService private readonly _storageService: IStorageService\n\t) {\n\t\tsuper();\n\n\t\t// Init cache\n\t\tthis._entries = new LRUCache<string, T>(this._getHistoryLimit());\n\n\t\t// Listen for config changes to set history limit\n\t\tthis._register(this._configurationService.onDidChangeConfiguration(e => {\n\t\t\tif (e.affectsConfiguration(TerminalSettingId.ShellIntegrationCommandHistory)) {\n\t\t\t\tthis._entries.limit = this._getHistoryLimit();\n\t\t\t}\n\t\t}));\n\n\t\t// Listen to cache changes from other windows\n\t\tthis._register(this._storageService.onDidChangeValue(StorageScope.APPLICATION, this._getTimestampStorageKey(), this._store)(() => {\n\t\t\tif (!this._isStale) {\n\t\t\t\tthis._isStale = this._storageService.getNumber(this._getTimestampStorageKey(), StorageScope.APPLICATION, 0) !== this._timestamp;\n\t\t\t}\n\t\t}));\n\t}\n\n\tadd(key: string, value: T) {\n\t\tthis._ensureUpToDate();\n\t\tthis._entries.set(key, value);\n\t\tthis._saveState();\n\t}\n\n\tremove(key: string) {\n\t\tthis._ensureUpToDate();\n\t\tthis._entries.delete(key);\n\t\tthis._saveState();\n\t}\n\n\tclear() {\n\t\tthis._ensureUpToDate();\n\t\tthis._entries.clear();\n\t\tthis._saveState();\n\t}\n\n\tprivate _ensureUpToDate() {\n\t\t// Initial load\n\t\tif (!this._isReady) {\n\t\t\tthis._loadState();\n\t\t\tthis._isReady = true;\n\t\t}\n\n\t\t// React to stale cache caused by another window\n\t\tif (this._isStale) {\n\t\t\t// Since state is saved whenever the entries change, it's a safe assumption that no\n\t\t\t// merging of entries needs to happen, just loading the new state.\n\t\t\tthis._entries.clear();\n\t\t\tthis._loadState();\n\t\t\tthis._isStale = false;\n\t\t}\n\t}\n\n\tprivate _loadState() {\n\t\tthis._timestamp = this._storageService.getNumber(\n\t\t\tthis._getTimestampStorageKey(),\n\t\t\tStorageScope.APPLICATION,\n\t\t\t0,\n\t\t);\n\n\t\t// Load global entries plus\n\t\tconst serialized = this._loadPersistedState();\n\t\tif (serialized) {\n\t\t\tfor (const entry of serialized.entries) {\n\t\t\t\tthis._entries.set(entry.key, entry.value);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _loadPersistedState(): ISerializedCache<T> | undefined {\n\t\tconst raw = this._storageService.get(\n\t\t\tthis._getEntriesStorageKey(),\n\t\t\tStorageScope.APPLICATION,\n\t\t);\n\t\tif (raw === undefined || raw.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\tlet serialized: ISerializedCache<T> | undefined;\n\t\ttry {\n\t\t\tserialized = JSON.parse(raw);\n\t\t} catch {\n\t\t\t// Invalid data\n\t\t\treturn undefined;\n\t\t}\n\t\treturn serialized;\n\t}\n\n\tprivate _saveState() {\n\t\tconst serialized: ISerializedCache<T> = { entries: [] };\n\t\tthis._entries.forEach((value, key) =>\n\t\t\tserialized.entries.push({ key, value }),\n\t\t);\n\t\tthis._storageService.store(\n\t\t\tthis._getEntriesStorageKey(),\n\t\t\tJSON.stringify(serialized),\n\t\t\tStorageScope.APPLICATION,\n\t\t\tStorageTarget.MACHINE,\n\t\t);\n\t\tthis._timestamp = Date.now();\n\t\tthis._storageService.store(\n\t\t\tthis._getTimestampStorageKey(),\n\t\t\tthis._timestamp,\n\t\t\tStorageScope.APPLICATION,\n\t\t\tStorageTarget.MACHINE,\n\t\t);\n\t}\n\n\tprivate _getHistoryLimit() {\n\t\tconst historyLimit = this._configurationService.getValue(\n\t\t\tTerminalSettingId.ShellIntegrationCommandHistory,\n\t\t);\n\t\treturn typeof historyLimit === \"number\"\n\t\t\t? historyLimit\n\t\t\t: Constants.DefaultHistoryLimit;\n\t}\n\n\tprivate _getTimestampStorageKey() {\n\t\treturn `${StorageKeys.Timestamp}.${this._storageDataKey}`;\n\t}\n\n\tprivate _getEntriesStorageKey() {\n\t\treturn `${StorageKeys.Entries}.${this._storageDataKey}`;\n\t}\n}\n\nexport async function fetchBashHistory(\n\taccessor: ServicesAccessor,\n): Promise<IterableIterator<string> | undefined> {\n\tconst fileService = accessor.get(IFileService);\n\tconst remoteAgentService = accessor.get(IRemoteAgentService);\n\tconst remoteEnvironment = await remoteAgentService.getEnvironment();\n\tif (\n\t\tremoteEnvironment?.os === OperatingSystem.Windows ||\n\t\t(!remoteEnvironment && isWindows)\n\t) {\n\t\treturn undefined;\n\t}\n\tconst content = await fetchFileContents(\n\t\tenv[\"HOME\"],\n\t\t\".bash_history\",\n\t\tfalse,\n\t\tfileService,\n\t\tremoteAgentService,\n\t);\n\tif (content === undefined) {\n\t\treturn undefined;\n\t}\n\t// .bash_history does not differentiate wrapped commands from multiple commands. Parse\n\t// the output to get the\n\tconst fileLines = content.split(\"\\n\");\n\tconst result: Set<string> = new Set();\n\tlet currentLine: string;\n\tlet currentCommand: string | undefined;\n\tlet wrapChar: string | undefined;\n\tfor (let i = 0; i < fileLines.length; i++) {\n\t\tcurrentLine = fileLines[i];\n\t\tif (currentCommand === undefined) {\n\t\t\tcurrentCommand = currentLine;\n\t\t} else {\n\t\t\tcurrentCommand += `\\n${currentLine}`;\n\t\t}\n\t\tfor (let c = 0; c < currentLine.length; c++) {\n\t\t\tif (wrapChar) {\n\t\t\t\tif (currentLine[c] === wrapChar) {\n\t\t\t\t\twrapChar = undefined;\n\t\t\t\t}\n\t\t\t} else if (currentLine[c].match(/['\"]/)) {\n\t\t\t\twrapChar = currentLine[c];\n\t\t\t}\n\t\t}\n\t\tif (wrapChar === undefined) {\n\t\t\tif (currentCommand.length > 0) {\n\t\t\t\tresult.add(currentCommand.trim());\n\t\t\t}\n\t\t\tcurrentCommand = undefined;\n\t\t}\n\t}\n\n\treturn result.values();\n}\n\nexport async function fetchZshHistory(accessor: ServicesAccessor) {\n\tconst fileService = accessor.get(IFileService);\n\tconst remoteAgentService = accessor.get(IRemoteAgentService);\n\tconst remoteEnvironment = await remoteAgentService.getEnvironment();\n\tif (\n\t\tremoteEnvironment?.os === OperatingSystem.Windows ||\n\t\t(!remoteEnvironment && isWindows)\n\t) {\n\t\treturn undefined;\n\t}\n\tconst content = await fetchFileContents(\n\t\tenv[\"HOME\"],\n\t\t\".zsh_history\",\n\t\tfalse,\n\t\tfileService,\n\t\tremoteAgentService,\n\t);\n\tif (content === undefined) {\n\t\treturn undefined;\n\t}\n\tconst fileLines = content.split(/:\\s\\d+:\\d+;/);\n\tconst result: Set<string> = new Set();\n\tfor (let i = 0; i < fileLines.length; i++) {\n\t\tconst sanitized = fileLines[i].replace(/\\\\\\n/g, \"\\n\").trim();\n\t\tif (sanitized.length > 0) {\n\t\t\tresult.add(sanitized);\n\t\t}\n\t}\n\treturn result.values();\n}\n\nexport async function fetchPythonHistory(\n\taccessor: ServicesAccessor,\n): Promise<IterableIterator<string> | undefined> {\n\tconst fileService = accessor.get(IFileService);\n\tconst remoteAgentService = accessor.get(IRemoteAgentService);\n\n\tconst content = await fetchFileContents(\n\t\tenv[\"HOME\"],\n\t\t\".python_history\",\n\t\tfalse,\n\t\tfileService,\n\t\tremoteAgentService,\n\t);\n\n\tif (content === undefined) {\n\t\treturn undefined;\n\t}\n\n\t// Python history file is a simple text file with one command per line\n\tconst fileLines = content.split(\"\\n\");\n\tconst result: Set<string> = new Set();\n\n\tfileLines.forEach((line) => {\n\t\tif (line.trim().length > 0) {\n\t\t\tresult.add(line.trim());\n\t\t}\n\t});\n\n\treturn result.values();\n}\n\nexport async function fetchPwshHistory(accessor: ServicesAccessor) {\n\tconst fileService: Pick<IFileService, \"readFile\"> =\n\t\taccessor.get(IFileService);\n\tconst remoteAgentService: Pick<\n\t\tIRemoteAgentService,\n\t\t\"getConnection\" | \"getEnvironment\"\n\t> = accessor.get(IRemoteAgentService);\n\tlet folderPrefix: string | undefined;\n\tlet filePath: string;\n\tconst remoteEnvironment = await remoteAgentService.getEnvironment();\n\tconst isFileWindows =\n\t\tremoteEnvironment?.os === OperatingSystem.Windows ||\n\t\t(!remoteEnvironment && isWindows);\n\tif (isFileWindows) {\n\t\tfolderPrefix = env[\"APPDATA\"];\n\t\tfilePath =\n\t\t\t\"Microsoft\\\\Windows\\\\PowerShell\\\\PSReadLine\\\\ConsoleHost_history.txt\";\n\t} else {\n\t\tfolderPrefix = env[\"HOME\"];\n\t\tfilePath = \".local/share/powershell/PSReadline/ConsoleHost_history.txt\";\n\t}\n\tconst content = await fetchFileContents(\n\t\tfolderPrefix,\n\t\tfilePath,\n\t\tisFileWindows,\n\t\tfileService,\n\t\tremoteAgentService,\n\t);\n\tif (content === undefined) {\n\t\treturn undefined;\n\t}\n\tconst fileLines = content.split(\"\\n\");\n\tconst result: Set<string> = new Set();\n\tlet currentLine: string;\n\tlet currentCommand: string | undefined;\n\tlet wrapChar: string | undefined;\n\tfor (let i = 0; i < fileLines.length; i++) {\n\t\tcurrentLine = fileLines[i];\n\t\tif (currentCommand === undefined) {\n\t\t\tcurrentCommand = currentLine;\n\t\t} else {\n\t\t\tcurrentCommand += `\\n${currentLine}`;\n\t\t}\n\t\tif (!currentLine.endsWith(\"`\")) {\n\t\t\tconst sanitized = currentCommand.trim();\n\t\t\tif (sanitized.length > 0) {\n\t\t\t\tresult.add(sanitized);\n\t\t\t}\n\t\t\tcurrentCommand = undefined;\n\t\t\tcontinue;\n\t\t}\n\t\t// If the line ends with `, the line may be wrapped. Need to also test the case where ` is\n\t\t// the last character in the line\n\t\tfor (let c = 0; c < currentLine.length; c++) {\n\t\t\tif (wrapChar) {\n\t\t\t\tif (currentLine[c] === wrapChar) {\n\t\t\t\t\twrapChar = undefined;\n\t\t\t\t}\n\t\t\t} else if (currentLine[c].match(/`/)) {\n\t\t\t\twrapChar = currentLine[c];\n\t\t\t}\n\t\t}\n\t\t// Having an even number of backticks means the line is terminated\n\t\t// TODO: This doesn't cover more complicated cases where ` is within quotes\n\t\tif (wrapChar) {\n\t\t\t// Remove trailing backtick\n\t\t\tcurrentCommand = currentCommand.replace(/`$/, \"\");\n\t\t\twrapChar = undefined;\n\t\t} else {\n\t\t\tconst sanitized = currentCommand.trim();\n\t\t\tif (sanitized.length > 0) {\n\t\t\t\tresult.add(sanitized);\n\t\t\t}\n\t\t\tcurrentCommand = undefined;\n\t\t}\n\t}\n\n\treturn result.values();\n}\n\nexport async function fetchFishHistory(accessor: ServicesAccessor) {\n\tconst fileService = accessor.get(IFileService);\n\tconst remoteAgentService = accessor.get(IRemoteAgentService);\n\tconst remoteEnvironment = await remoteAgentService.getEnvironment();\n\tif (\n\t\tremoteEnvironment?.os === OperatingSystem.Windows ||\n\t\t(!remoteEnvironment && isWindows)\n\t) {\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * From `fish` docs:\n\t * > The command history is stored in the file ~/.local/share/fish/fish_history\n\t *   (or $XDG_DATA_HOME/fish/fish_history if that variable is set) by default.\n\t *\n\t * (https://fishshell.com/docs/current/interactive.html#history-search)\n\t */\n\tconst overridenDataHome = env[\"XDG_DATA_HOME\"];\n\n\t// TODO: Unchecked fish behavior:\n\t// What if XDG_DATA_HOME was defined but somehow $XDG_DATA_HOME/fish/fish_history\n\t// was not exist. Does fish fall back to ~/.local/share/fish/fish_history?\n\n\tconst content = await (overridenDataHome\n\t\t? fetchFileContents(\n\t\t\t\tenv[\"XDG_DATA_HOME\"],\n\t\t\t\t\"fish/fish_history\",\n\t\t\t\tfalse,\n\t\t\t\tfileService,\n\t\t\t\tremoteAgentService,\n\t\t\t)\n\t\t: fetchFileContents(\n\t\t\t\tenv[\"HOME\"],\n\t\t\t\t\".local/share/fish/fish_history\",\n\t\t\t\tfalse,\n\t\t\t\tfileService,\n\t\t\t\tremoteAgentService,\n\t\t\t));\n\tif (content === undefined) {\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * These apply to `fish` v3.5.1:\n\t * - It looks like YAML but it's not. It's, quoting, *\"a broken psuedo-YAML\"*.\n\t *   See these discussions for more details:\n\t *   - https://github.com/fish-shell/fish-shell/pull/6493\n\t *   - https://github.com/fish-shell/fish-shell/issues/3341\n\t * - Every record should exactly start with `- cmd:` (the whitespace between `-` and `cmd` cannot be replaced with tab)\n\t * - Both `- cmd: echo 1` and `- cmd:echo 1` are valid entries.\n\t * - Backslashes are esacped as `\\\\`.\n\t * - Multiline commands are joined with a `\\n` sequence, hence they're read as single line commands.\n\t * - Property `when` is optional.\n\t * - History navigation respects the records order and ignore the actual `when` property values (chronological order).\n\t * - If `cmd` value is multiline , it just takes the first line. Also YAML operators like `>-` or `|-` are not supported.\n\t */\n\tconst result: Set<string> = new Set();\n\tconst cmds = content\n\t\t.split(\"\\n\")\n\t\t.filter((x) => x.startsWith(\"- cmd:\"))\n\t\t.map((x) => x.substring(6).trimStart());\n\tfor (let i = 0; i < cmds.length; i++) {\n\t\tconst sanitized = sanitizeFishHistoryCmd(cmds[i]).trim();\n\t\tif (sanitized.length > 0) {\n\t\t\tresult.add(sanitized);\n\t\t}\n\t}\n\treturn result.values();\n}\n\nexport function sanitizeFishHistoryCmd(cmd: string): string {\n\t/**\n\t * NOTE\n\t * This repeatedReplace() call can be eliminated by using look-ahead\n\t * caluses in the original RegExp pattern:\n\t *\n\t * >>> ```ts\n\t * >>> cmds[i].replace(/(?<=^|[^\\\\])((?:\\\\\\\\)*)(\\\\n)/g, '$1\\n')\n\t * >>> ```\n\t *\n\t * But since not all browsers support look aheads we opted to a simple\n\t * pattern and repeatedly calling replace method.\n\t */\n\treturn repeatedReplace(/(^|[^\\\\])((?:\\\\\\\\)*)(\\\\n)/g, cmd, \"$1$2\\n\");\n}\n\nfunction repeatedReplace(\n\tpattern: RegExp,\n\tvalue: string,\n\treplaceValue: string,\n): string {\n\tlet last;\n\tlet current = value;\n\twhile (true) {\n\t\tlast = current;\n\t\tcurrent = current.replace(pattern, replaceValue);\n\t\tif (current === last) {\n\t\t\treturn current;\n\t\t}\n\t}\n}\n\nasync function fetchFileContents(\n\tfolderPrefix: string | undefined,\n\tfilePath: string,\n\tisFileWindows: boolean,\n\tfileService: Pick<IFileService, \"readFile\">,\n\tremoteAgentService: Pick<IRemoteAgentService, \"getConnection\">,\n): Promise<string | undefined> {\n\tif (!folderPrefix) {\n\t\treturn undefined;\n\t}\n\tconst connection = remoteAgentService.getConnection();\n\tconst isRemote = !!connection?.remoteAuthority;\n\tconst historyFileUri = URI.from({\n\t\tscheme: isRemote ? Schemas.vscodeRemote : Schemas.file,\n\t\tauthority: isRemote ? connection.remoteAuthority : undefined,\n\t\tpath: URI.file(join(folderPrefix, filePath)).path,\n\t});\n\tlet content: IFileContent;\n\ttry {\n\t\tcontent = await fileService.readFile(historyFileUri);\n\t} catch (e: unknown) {\n\t\t// Handle file not found only\n\t\tif (\n\t\t\te instanceof FileOperationError &&\n\t\t\te.fileOperationResult === FileOperationResult.FILE_NOT_FOUND\n\t\t) {\n\t\t\treturn undefined;\n\t\t}\n\t\tthrow e;\n\t}\n\tif (content === undefined) {\n\t\treturn undefined;\n\t}\n\treturn content.value.toString();\n}\n"],
  "mappings": "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",
  "names": ["Constants", "StorageKeys"]
}
