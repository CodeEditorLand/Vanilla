{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/terminal/common/history.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { env } from '../../../../base/common/process.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { LRUCache } from '../../../../base/common/map.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { FileOperationError, FileOperationResult, IFileContent, IFileService } from '../../../../platform/files/common/files.js';\nimport { IInstantiationService, ServicesAccessor } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IStorageService, StorageScope, StorageTarget } from '../../../../platform/storage/common/storage.js';\nimport { GeneralShellType, PosixShellType, TerminalSettingId, TerminalShellType } from '../../../../platform/terminal/common/terminal.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IRemoteAgentService } from '../../../services/remote/common/remoteAgentService.js';\nimport { Schemas } from '../../../../base/common/network.js';\nimport { isWindows, OperatingSystem } from '../../../../base/common/platform.js';\nimport { join } from '../../../../base/common/path.js';\n\n/**\n * Tracks a list of generic entries.\n */\nexport interface ITerminalPersistedHistory<T> {\n\t/**\n\t * The persisted entries.\n\t */\n\treadonly entries: IterableIterator<[string, T]>;\n\t/**\n\t * Adds an entry.\n\t */\n\tadd(key: string, value: T): void;\n\t/**\n\t * Removes an entry.\n\t */\n\tremove(key: string): void;\n\t/**\n\t * Clears all entries.\n\t */\n\tclear(): void;\n}\n\ninterface ISerializedCache<T> {\n\tentries: { key: string; value: T }[];\n}\n\nconst enum Constants {\n\tDefaultHistoryLimit = 100\n}\n\nconst enum StorageKeys {\n\tEntries = 'terminal.history.entries',\n\tTimestamp = 'terminal.history.timestamp'\n}\n\nlet commandHistory: ITerminalPersistedHistory<{ shellType: TerminalShellType }> | undefined = undefined;\nexport function getCommandHistory(accessor: ServicesAccessor): ITerminalPersistedHistory<{ shellType: TerminalShellType | undefined }> {\n\tif (!commandHistory) {\n\t\tcommandHistory = accessor.get(IInstantiationService).createInstance(TerminalPersistedHistory, 'commands') as TerminalPersistedHistory<{ shellType: TerminalShellType }>;\n\t}\n\treturn commandHistory;\n}\n\nlet directoryHistory: ITerminalPersistedHistory<{ remoteAuthority?: string }> | undefined = undefined;\nexport function getDirectoryHistory(accessor: ServicesAccessor): ITerminalPersistedHistory<{ remoteAuthority?: string }> {\n\tif (!directoryHistory) {\n\t\tdirectoryHistory = accessor.get(IInstantiationService).createInstance(TerminalPersistedHistory, 'dirs') as TerminalPersistedHistory<{ remoteAuthority?: string }>;\n\t}\n\treturn directoryHistory;\n}\n\n// Shell file history loads once per shell per window\nconst shellFileHistory: Map<TerminalShellType | undefined, string[] | null> = new Map();\nexport async function getShellFileHistory(accessor: ServicesAccessor, shellType: TerminalShellType | undefined): Promise<string[]> {\n\tconst cached = shellFileHistory.get(shellType);\n\tif (cached === null) {\n\t\treturn [];\n\t}\n\tif (cached !== undefined) {\n\t\treturn cached;\n\t}\n\tlet result: IterableIterator<string> | undefined;\n\tswitch (shellType) {\n\t\tcase PosixShellType.Bash:\n\t\t\tresult = await fetchBashHistory(accessor);\n\t\t\tbreak;\n\t\tcase GeneralShellType.PowerShell:\n\t\t\tresult = await fetchPwshHistory(accessor);\n\t\t\tbreak;\n\t\tcase PosixShellType.Zsh:\n\t\t\tresult = await fetchZshHistory(accessor);\n\t\t\tbreak;\n\t\tcase PosixShellType.Fish:\n\t\t\tresult = await fetchFishHistory(accessor);\n\t\t\tbreak;\n\t\tcase GeneralShellType.Python:\n\t\t\tresult = await fetchPythonHistory(accessor);\n\t\t\tbreak;\n\t\tdefault: return [];\n\t}\n\tif (result === undefined) {\n\t\tshellFileHistory.set(shellType, null);\n\t\treturn [];\n\t}\n\tconst array = Array.from(result);\n\tshellFileHistory.set(shellType, array);\n\treturn array;\n}\nexport function clearShellFileHistory() {\n\tshellFileHistory.clear();\n}\n\nexport class TerminalPersistedHistory<T> extends Disposable implements ITerminalPersistedHistory<T> {\n\tprivate readonly _entries: LRUCache<string, T>;\n\tprivate _timestamp: number = 0;\n\tprivate _isReady = false;\n\tprivate _isStale = true;\n\n\tget entries(): IterableIterator<[string, T]> {\n\t\tthis._ensureUpToDate();\n\t\treturn this._entries.entries();\n\t}\n\n\tconstructor(\n\t\tprivate readonly _storageDataKey: string,\n\t\t@IConfigurationService private readonly _configurationService: IConfigurationService,\n\t\t@IStorageService private readonly _storageService: IStorageService\n\t) {\n\t\tsuper();\n\n\t\t// Init cache\n\t\tthis._entries = new LRUCache<string, T>(this._getHistoryLimit());\n\n\t\t// Listen for config changes to set history limit\n\t\tthis._register(this._configurationService.onDidChangeConfiguration(e => {\n\t\t\tif (e.affectsConfiguration(TerminalSettingId.ShellIntegrationCommandHistory)) {\n\t\t\t\tthis._entries.limit = this._getHistoryLimit();\n\t\t\t}\n\t\t}));\n\n\t\t// Listen to cache changes from other windows\n\t\tthis._register(this._storageService.onDidChangeValue(StorageScope.APPLICATION, this._getTimestampStorageKey(), this._store)(() => {\n\t\t\tif (!this._isStale) {\n\t\t\t\tthis._isStale = this._storageService.getNumber(this._getTimestampStorageKey(), StorageScope.APPLICATION, 0) !== this._timestamp;\n\t\t\t}\n\t\t}));\n\t}\n\n\tadd(key: string, value: T) {\n\t\tthis._ensureUpToDate();\n\t\tthis._entries.set(key, value);\n\t\tthis._saveState();\n\t}\n\n\tremove(key: string) {\n\t\tthis._ensureUpToDate();\n\t\tthis._entries.delete(key);\n\t\tthis._saveState();\n\t}\n\n\tclear() {\n\t\tthis._ensureUpToDate();\n\t\tthis._entries.clear();\n\t\tthis._saveState();\n\t}\n\n\tprivate _ensureUpToDate() {\n\t\t// Initial load\n\t\tif (!this._isReady) {\n\t\t\tthis._loadState();\n\t\t\tthis._isReady = true;\n\t\t}\n\n\t\t// React to stale cache caused by another window\n\t\tif (this._isStale) {\n\t\t\t// Since state is saved whenever the entries change, it's a safe assumption that no\n\t\t\t// merging of entries needs to happen, just loading the new state.\n\t\t\tthis._entries.clear();\n\t\t\tthis._loadState();\n\t\t\tthis._isStale = false;\n\t\t}\n\t}\n\n\tprivate _loadState() {\n\t\tthis._timestamp = this._storageService.getNumber(this._getTimestampStorageKey(), StorageScope.APPLICATION, 0);\n\n\t\t// Load global entries plus\n\t\tconst serialized = this._loadPersistedState();\n\t\tif (serialized) {\n\t\t\tfor (const entry of serialized.entries) {\n\t\t\t\tthis._entries.set(entry.key, entry.value);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _loadPersistedState(): ISerializedCache<T> | undefined {\n\t\tconst raw = this._storageService.get(this._getEntriesStorageKey(), StorageScope.APPLICATION);\n\t\tif (raw === undefined || raw.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\tlet serialized: ISerializedCache<T> | undefined = undefined;\n\t\ttry {\n\t\t\tserialized = JSON.parse(raw);\n\t\t} catch {\n\t\t\t// Invalid data\n\t\t\treturn undefined;\n\t\t}\n\t\treturn serialized;\n\t}\n\n\tprivate _saveState() {\n\t\tconst serialized: ISerializedCache<T> = { entries: [] };\n\t\tthis._entries.forEach((value, key) => serialized.entries.push({ key, value }));\n\t\tthis._storageService.store(this._getEntriesStorageKey(), JSON.stringify(serialized), StorageScope.APPLICATION, StorageTarget.MACHINE);\n\t\tthis._timestamp = Date.now();\n\t\tthis._storageService.store(this._getTimestampStorageKey(), this._timestamp, StorageScope.APPLICATION, StorageTarget.MACHINE);\n\t}\n\n\tprivate _getHistoryLimit() {\n\t\tconst historyLimit = this._configurationService.getValue(TerminalSettingId.ShellIntegrationCommandHistory);\n\t\treturn typeof historyLimit === 'number' ? historyLimit : Constants.DefaultHistoryLimit;\n\t}\n\n\tprivate _getTimestampStorageKey() {\n\t\treturn `${StorageKeys.Timestamp}.${this._storageDataKey}`;\n\t}\n\n\tprivate _getEntriesStorageKey() {\n\t\treturn `${StorageKeys.Entries}.${this._storageDataKey}`;\n\t}\n}\n\nexport async function fetchBashHistory(accessor: ServicesAccessor): Promise<IterableIterator<string> | undefined> {\n\tconst fileService = accessor.get(IFileService);\n\tconst remoteAgentService = accessor.get(IRemoteAgentService);\n\tconst remoteEnvironment = await remoteAgentService.getEnvironment();\n\tif (remoteEnvironment?.os === OperatingSystem.Windows || !remoteEnvironment && isWindows) {\n\t\treturn undefined;\n\t}\n\tconst content = await fetchFileContents(env['HOME'], '.bash_history', false, fileService, remoteAgentService);\n\tif (content === undefined) {\n\t\treturn undefined;\n\t}\n\t// .bash_history does not differentiate wrapped commands from multiple commands. Parse\n\t// the output to get the\n\tconst fileLines = content.split('\\n');\n\tconst result: Set<string> = new Set();\n\tlet currentLine: string;\n\tlet currentCommand: string | undefined = undefined;\n\tlet wrapChar: string | undefined = undefined;\n\tfor (let i = 0; i < fileLines.length; i++) {\n\t\tcurrentLine = fileLines[i];\n\t\tif (currentCommand === undefined) {\n\t\t\tcurrentCommand = currentLine;\n\t\t} else {\n\t\t\tcurrentCommand += `\\n${currentLine}`;\n\t\t}\n\t\tfor (let c = 0; c < currentLine.length; c++) {\n\t\t\tif (wrapChar) {\n\t\t\t\tif (currentLine[c] === wrapChar) {\n\t\t\t\t\twrapChar = undefined;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (currentLine[c].match(/['\"]/)) {\n\t\t\t\t\twrapChar = currentLine[c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (wrapChar === undefined) {\n\t\t\tif (currentCommand.length > 0) {\n\t\t\t\tresult.add(currentCommand.trim());\n\t\t\t}\n\t\t\tcurrentCommand = undefined;\n\t\t}\n\t}\n\n\treturn result.values();\n}\n\nexport async function fetchZshHistory(accessor: ServicesAccessor) {\n\tconst fileService = accessor.get(IFileService);\n\tconst remoteAgentService = accessor.get(IRemoteAgentService);\n\tconst remoteEnvironment = await remoteAgentService.getEnvironment();\n\tif (remoteEnvironment?.os === OperatingSystem.Windows || !remoteEnvironment && isWindows) {\n\t\treturn undefined;\n\t}\n\tconst content = await fetchFileContents(env['HOME'], '.zsh_history', false, fileService, remoteAgentService);\n\tif (content === undefined) {\n\t\treturn undefined;\n\t}\n\tconst fileLines = content.split(/\\:\\s\\d+\\:\\d+;/);\n\tconst result: Set<string> = new Set();\n\tfor (let i = 0; i < fileLines.length; i++) {\n\t\tconst sanitized = fileLines[i].replace(/\\\\\\n/g, '\\n').trim();\n\t\tif (sanitized.length > 0) {\n\t\t\tresult.add(sanitized);\n\t\t}\n\t}\n\treturn result.values();\n}\n\n\nexport async function fetchPythonHistory(accessor: ServicesAccessor): Promise<IterableIterator<string> | undefined> {\n\tconst fileService = accessor.get(IFileService);\n\tconst remoteAgentService = accessor.get(IRemoteAgentService);\n\n\tconst content = await fetchFileContents(env['HOME'], '.python_history', false, fileService, remoteAgentService);\n\n\tif (content === undefined) {\n\t\treturn undefined;\n\t}\n\n\t// Python history file is a simple text file with one command per line\n\tconst fileLines = content.split('\\n');\n\tconst result: Set<string> = new Set();\n\n\tfileLines.forEach(line => {\n\t\tif (line.trim().length > 0) {\n\t\t\tresult.add(line.trim());\n\t\t}\n\t});\n\n\treturn result.values();\n}\n\nexport async function fetchPwshHistory(accessor: ServicesAccessor) {\n\tconst fileService: Pick<IFileService, 'readFile'> = accessor.get(IFileService);\n\tconst remoteAgentService: Pick<IRemoteAgentService, 'getConnection' | 'getEnvironment'> = accessor.get(IRemoteAgentService);\n\tlet folderPrefix: string | undefined;\n\tlet filePath: string;\n\tconst remoteEnvironment = await remoteAgentService.getEnvironment();\n\tconst isFileWindows = remoteEnvironment?.os === OperatingSystem.Windows || !remoteEnvironment && isWindows;\n\tif (isFileWindows) {\n\t\tfolderPrefix = env['APPDATA'];\n\t\tfilePath = 'Microsoft\\\\Windows\\\\PowerShell\\\\PSReadLine\\\\ConsoleHost_history.txt';\n\t} else {\n\t\tfolderPrefix = env['HOME'];\n\t\tfilePath = '.local/share/powershell/PSReadline/ConsoleHost_history.txt';\n\t}\n\tconst content = await fetchFileContents(folderPrefix, filePath, isFileWindows, fileService, remoteAgentService);\n\tif (content === undefined) {\n\t\treturn undefined;\n\t}\n\tconst fileLines = content.split('\\n');\n\tconst result: Set<string> = new Set();\n\tlet currentLine: string;\n\tlet currentCommand: string | undefined = undefined;\n\tlet wrapChar: string | undefined = undefined;\n\tfor (let i = 0; i < fileLines.length; i++) {\n\t\tcurrentLine = fileLines[i];\n\t\tif (currentCommand === undefined) {\n\t\t\tcurrentCommand = currentLine;\n\t\t} else {\n\t\t\tcurrentCommand += `\\n${currentLine}`;\n\t\t}\n\t\tif (!currentLine.endsWith('`')) {\n\t\t\tconst sanitized = currentCommand.trim();\n\t\t\tif (sanitized.length > 0) {\n\t\t\t\tresult.add(sanitized);\n\t\t\t}\n\t\t\tcurrentCommand = undefined;\n\t\t\tcontinue;\n\t\t}\n\t\t// If the line ends with `, the line may be wrapped. Need to also test the case where ` is\n\t\t// the last character in the line\n\t\tfor (let c = 0; c < currentLine.length; c++) {\n\t\t\tif (wrapChar) {\n\t\t\t\tif (currentLine[c] === wrapChar) {\n\t\t\t\t\twrapChar = undefined;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (currentLine[c].match(/`/)) {\n\t\t\t\t\twrapChar = currentLine[c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Having an even number of backticks means the line is terminated\n\t\t// TODO: This doesn't cover more complicated cases where ` is within quotes\n\t\tif (!wrapChar) {\n\t\t\tconst sanitized = currentCommand.trim();\n\t\t\tif (sanitized.length > 0) {\n\t\t\t\tresult.add(sanitized);\n\t\t\t}\n\t\t\tcurrentCommand = undefined;\n\t\t} else {\n\t\t\t// Remove trailing backtick\n\t\t\tcurrentCommand = currentCommand.replace(/`$/, '');\n\t\t\twrapChar = undefined;\n\t\t}\n\t}\n\n\treturn result.values();\n}\n\nexport async function fetchFishHistory(accessor: ServicesAccessor) {\n\tconst fileService = accessor.get(IFileService);\n\tconst remoteAgentService = accessor.get(IRemoteAgentService);\n\tconst remoteEnvironment = await remoteAgentService.getEnvironment();\n\tif (remoteEnvironment?.os === OperatingSystem.Windows || !remoteEnvironment && isWindows) {\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * From `fish` docs:\n\t * > The command history is stored in the file ~/.local/share/fish/fish_history\n\t *   (or $XDG_DATA_HOME/fish/fish_history if that variable is set) by default.\n\t *\n\t * (https://fishshell.com/docs/current/interactive.html#history-search)\n\t */\n\tconst overridenDataHome = env['XDG_DATA_HOME'];\n\n\t// TODO: Unchecked fish behavior:\n\t// What if XDG_DATA_HOME was defined but somehow $XDG_DATA_HOME/fish/fish_history\n\t// was not exist. Does fish fall back to ~/.local/share/fish/fish_history?\n\n\tconst content = await (overridenDataHome\n\t\t? fetchFileContents(env['XDG_DATA_HOME'], 'fish/fish_history', false, fileService, remoteAgentService)\n\t\t: fetchFileContents(env['HOME'], '.local/share/fish/fish_history', false, fileService, remoteAgentService));\n\tif (content === undefined) {\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * These apply to `fish` v3.5.1:\n\t * - It looks like YAML but it's not. It's, quoting, *\"a broken psuedo-YAML\"*.\n\t *   See these discussions for more details:\n\t *   - https://github.com/fish-shell/fish-shell/pull/6493\n\t *   - https://github.com/fish-shell/fish-shell/issues/3341\n\t * - Every record should exactly start with `- cmd:` (the whitespace between `-` and `cmd` cannot be replaced with tab)\n\t * - Both `- cmd: echo 1` and `- cmd:echo 1` are valid entries.\n\t * - Backslashes are esacped as `\\\\`.\n\t * - Multiline commands are joined with a `\\n` sequence, hence they're read as single line commands.\n\t * - Property `when` is optional.\n\t * - History navigation respects the records order and ignore the actual `when` property values (chronological order).\n\t * - If `cmd` value is multiline , it just takes the first line. Also YAML operators like `>-` or `|-` are not supported.\n\t */\n\tconst result: Set<string> = new Set();\n\tconst cmds = content.split('\\n')\n\t\t.filter(x => x.startsWith('- cmd:'))\n\t\t.map(x => x.substring(6).trimStart());\n\tfor (let i = 0; i < cmds.length; i++) {\n\t\tconst sanitized = sanitizeFishHistoryCmd(cmds[i]).trim();\n\t\tif (sanitized.length > 0) {\n\t\t\tresult.add(sanitized);\n\t\t}\n\t}\n\treturn result.values();\n}\n\nexport function sanitizeFishHistoryCmd(cmd: string): string {\n\t/**\n\t * NOTE\n\t * This repeatedReplace() call can be eliminated by using look-ahead\n\t * caluses in the original RegExp pattern:\n\t *\n\t * >>> ```ts\n\t * >>> cmds[i].replace(/(?<=^|[^\\\\])((?:\\\\\\\\)*)(\\\\n)/g, '$1\\n')\n\t * >>> ```\n\t *\n\t * But since not all browsers support look aheads we opted to a simple\n\t * pattern and repeatedly calling replace method.\n\t */\n\treturn repeatedReplace(/(^|[^\\\\])((?:\\\\\\\\)*)(\\\\n)/g, cmd, '$1$2\\n');\n}\n\nfunction repeatedReplace(pattern: RegExp, value: string, replaceValue: string): string {\n\tlet last;\n\tlet current = value;\n\twhile (true) {\n\t\tlast = current;\n\t\tcurrent = current.replace(pattern, replaceValue);\n\t\tif (current === last) {\n\t\t\treturn current;\n\t\t}\n\t}\n}\n\nasync function fetchFileContents(\n\tfolderPrefix: string | undefined,\n\tfilePath: string,\n\tisFileWindows: boolean,\n\tfileService: Pick<IFileService, 'readFile'>,\n\tremoteAgentService: Pick<IRemoteAgentService, 'getConnection'>,\n): Promise<string | undefined> {\n\tif (!folderPrefix) {\n\t\treturn undefined;\n\t}\n\tconst connection = remoteAgentService.getConnection();\n\tconst isRemote = !!connection?.remoteAuthority;\n\tconst historyFileUri = URI.from({\n\t\tscheme: isRemote ? Schemas.vscodeRemote : Schemas.file,\n\t\tauthority: isRemote ? connection.remoteAuthority : undefined,\n\t\tpath: URI.file(join(folderPrefix, filePath)).path\n\t});\n\tlet content: IFileContent;\n\ttry {\n\t\tcontent = await fileService.readFile(historyFileUri);\n\t} catch (e: unknown) {\n\t\t// Handle file not found only\n\t\tif (e instanceof FileOperationError && e.fileOperationResult === FileOperationResult.FILE_NOT_FOUND) {\n\t\t\treturn undefined;\n\t\t}\n\t\tthrow e;\n\t}\n\tif (content === undefined) {\n\t\treturn undefined;\n\t}\n\treturn content.value.toString();\n}\n"],
  "mappings": "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",
  "names": ["Constants", "StorageKeys"]
}
