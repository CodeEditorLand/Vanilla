var M=Object.defineProperty;var q=Object.getOwnPropertyDescriptor;var P=(c,a,e,t)=>{for(var r=t>1?void 0:t?q(a,e):a,i=c.length-1,s;i>=0;i--)(s=c[i])&&(r=(t?s(a,e,r):s(r))||r);return t&&r&&M(a,e,r),r},o=(c,a)=>(e,t)=>a(e,t,c);import{DeferredPromise as B}from"../../../../base/common/async.js";import{Emitter as L}from"../../../../base/common/event.js";import{revive as N}from"../../../../base/common/marshalling.js";import{mark as g}from"../../../../base/common/performance.js";import{OperatingSystem as H}from"../../../../base/common/platform.js";import{StopWatch as V}from"../../../../base/common/stopwatch.js";import{ICommandService as z}from"../../../../platform/commands/common/commands.js";import{IConfigurationService as K}from"../../../../platform/configuration/common/configuration.js";import{IInstantiationService as b}from"../../../../platform/instantiation/common/instantiation.js";import{Registry as F}from"../../../../platform/registry/common/platform.js";import{IRemoteAuthorityResolverService as j}from"../../../../platform/remote/common/remoteAuthorityResolver.js";import{IStorageService as G,StorageScope as v,StorageTarget as Q}from"../../../../platform/storage/common/storage.js";import"../../../../platform/terminal/common/capabilities/capabilities.js";import{ITerminalLogService as $,TerminalExtensions as J,TerminalSettingId as y}from"../../../../platform/terminal/common/terminal.js";import"../../../../platform/terminal/common/terminalProcess.js";import{IWorkspaceContextService as U}from"../../../../platform/workspace/common/workspace.js";import"../../../common/contributions.js";import{BaseTerminalBackend as X}from"./baseTerminalBackend.js";import{RemotePty as k}from"./remotePty.js";import{ITerminalInstanceService as Y}from"./terminal.js";import{RemoteTerminalChannelClient as Z,REMOTE_TERMINAL_CHANNEL_NAME as ee}from"../common/remote/remoteTerminalChannel.js";import{TERMINAL_CONFIG_SECTION as R}from"../common/terminal.js";import{TerminalStorageKeys as p}from"../common/terminalStorageKeys.js";import{IConfigurationResolverService as te}from"../../../services/configurationResolver/common/configurationResolver.js";import{IHistoryService as ne}from"../../../services/history/common/history.js";import{IRemoteAgentService as x}from"../../../services/remote/common/remoteAgentService.js";import{IStatusbarService as re}from"../../../services/statusbar/browser/statusbar.js";let T=class{static ID="remoteTerminalBackend";constructor(a,e,t){const r=e.getConnection();if(r?.remoteAuthority){const i=a.createInstance(Z,r.remoteAuthority,r.getChannel(ee)),s=a.createInstance(I,r.remoteAuthority,i);F.as(J.Backend).registerTerminalBackend(s),t.didRegisterBackend(s.remoteAuthority)}}};T=P([o(0,b),o(1,x),o(2,Y)],T);let I=class extends X{constructor(e,t,r,i,s,O,E,C,A,_,S,D,w){super(t,s,S,_,w,A);this.remoteAuthority=e;this._remoteTerminalChannel=t;this._remoteAgentService=r;this._instantiationService=i;this._commandService=O;this._storageService=E;this._remoteAuthorityResolverService=C;this._historyService=S;this._configurationService=D;this._remoteTerminalChannel.onProcessData(n=>this._ptys.get(n.id)?.handleData(n.event)),this._remoteTerminalChannel.onProcessReplay(n=>{this._ptys.get(n.id)?.handleReplay(n.event),n.event.commands.commands.length>0&&this._onRestoreCommands.fire({id:n.id,commands:n.event.commands.commands})}),this._remoteTerminalChannel.onProcessOrphanQuestion(n=>this._ptys.get(n.id)?.handleOrphanQuestion()),this._remoteTerminalChannel.onDidRequestDetach(n=>this._onDidRequestDetach.fire(n)),this._remoteTerminalChannel.onProcessReady(n=>this._ptys.get(n.id)?.handleReady(n.event)),this._remoteTerminalChannel.onDidChangeProperty(n=>this._ptys.get(n.id)?.handleDidChangeProperty(n.property)),this._remoteTerminalChannel.onProcessExit(n=>{const m=this._ptys.get(n.id);m&&(m.handleExit(n.event),this._ptys.delete(n.id))});const f=["_remoteCLI.openExternal","_remoteCLI.windowOpen","_remoteCLI.getSystemStatus","_remoteCLI.manageExtensions"];this._remoteTerminalChannel.onExecuteCommand(async n=>{if(!this._ptys.get(n.persistentProcessId))return;const l=n.reqId,d=n.commandId;if(!f.includes(d)){this._remoteTerminalChannel.sendCommandResult(l,!0,"Invalid remote cli command: "+d);return}const W=n.commandArgs.map(u=>N(u));try{const u=await this._commandService.executeCommand(n.commandId,...W);this._remoteTerminalChannel.sendCommandResult(l,!1,u)}catch(u){this._remoteTerminalChannel.sendCommandResult(l,!0,u)}});const h=this._configurationService.getValue(R);for(const n of Object.keys(h.autoReplies)){const m=h.autoReplies[n];m&&this._remoteTerminalChannel.installAutoReply(n,m)}this._register(this._configurationService.onDidChangeConfiguration(async n=>{if(n.affectsConfiguration(y.AutoReplies)){this._remoteTerminalChannel.uninstallAllAutoReplies();const m=this._configurationService.getValue(R);for(const l of Object.keys(m.autoReplies)){const d=m.autoReplies[l];d&&await this._remoteTerminalChannel.installAutoReply(l,d)}}})),this._onPtyHostConnected.fire()}_ptys=new Map;_whenConnected=new B;get whenReady(){return this._whenConnected.p}setReady(){this._whenConnected.complete()}_onDidRequestDetach=this._register(new L);onDidRequestDetach=this._onDidRequestDetach.event;_onRestoreCommands=this._register(new L);onRestoreCommands=this._onRestoreCommands.event;async requestDetachInstance(e,t){if(!this._remoteTerminalChannel)throw new Error("Cannot request detach instance when there is no remote!");return this._remoteTerminalChannel.requestDetachInstance(e,t)}async acceptDetachInstanceReply(e,t){if(this._remoteTerminalChannel){if(!t){this._logService.warn("Cannot attach to feature terminals, custom pty terminals, or those without a persistentProcessId");return}}else throw new Error("Cannot accept detached instance when there is no remote!");return this._remoteTerminalChannel.acceptDetachInstanceReply(e,t)}async persistTerminalState(){if(!this._remoteTerminalChannel)throw new Error("Cannot persist terminal state when there is no remote!");const e=Array.from(this._ptys.keys()),t=await this._remoteTerminalChannel.serializeTerminalState(e);this._storageService.store(p.TerminalBufferState,t,v.WORKSPACE,Q.MACHINE)}async createProcess(e,t,r,i,s,O,E,C){if(!this._remoteTerminalChannel)throw new Error("Cannot create remote terminal when there is no remote!");if(!await this._remoteAgentService.getEnvironment())throw new Error("Could not fetch remote environment");const _=this._configurationService.getValue(R),S={"terminal.integrated.env.windows":this._configurationService.getValue(y.EnvWindows),"terminal.integrated.env.osx":this._configurationService.getValue(y.EnvMacOs),"terminal.integrated.env.linux":this._configurationService.getValue(y.EnvLinux),"terminal.integrated.cwd":this._configurationService.getValue(y.Cwd),"terminal.integrated.detectLocale":_.detectLocale},D={name:e.name,executable:e.executable,args:e.args,cwd:e.cwd,env:e.env,useShellEnvironment:e.useShellEnvironment,reconnectionProperties:e.reconnectionProperties,type:e.type,isFeatureTerminal:e.isFeatureTerminal},w=this._historyService.getLastActiveWorkspaceRoot(),f=await this._remoteTerminalChannel.createProcess(D,S,w,E,C,r,i,s),h=this._instantiationService.createInstance(k,f.persistentTerminalId,C,this._remoteTerminalChannel);return this._ptys.set(f.persistentTerminalId,h),h}async attachToProcess(e){if(!this._remoteTerminalChannel)throw new Error("Cannot create remote terminal when there is no remote!");try{await this._remoteTerminalChannel.attachToProcess(e);const t=this._instantiationService.createInstance(k,e,!0,this._remoteTerminalChannel);return this._ptys.set(e,t),t}catch(t){this._logService.trace(`Couldn't attach to process ${t.message}`)}}async attachToRevivedProcess(e){if(!this._remoteTerminalChannel)throw new Error("Cannot create remote terminal when there is no remote!");try{const t=await this._remoteTerminalChannel.getRevivedPtyNewId(e)??e;return await this.attachToProcess(t)}catch(t){this._logService.trace(`Couldn't attach to process ${t.message}`)}}async listProcesses(){return this._remoteTerminalChannel.listProcesses()}async getLatency(){const e=new V,t=await this._remoteTerminalChannel.getLatency();return e.stop(),[{label:"window<->ptyhostservice<->ptyhost",latency:e.elapsed()},...t]}async updateProperty(e,t,r){await this._remoteTerminalChannel.updateProperty(e,t,r)}async updateTitle(e,t,r){await this._remoteTerminalChannel.updateTitle(e,t,r)}async updateIcon(e,t,r,i){await this._remoteTerminalChannel.updateIcon(e,t,r,i)}async getDefaultSystemShell(e){return this._remoteTerminalChannel.getDefaultSystemShell(e)||""}async getProfiles(e,t,r){return this._remoteTerminalChannel.getProfiles(e,t,r)||[]}async getEnvironment(){return this._remoteTerminalChannel.getEnvironment()||{}}async getShellEnvironment(){const e=this._remoteAgentService.getConnection();return e?(await this._remoteAuthorityResolverService.resolveAuthority(e.remoteAuthority)).options?.extensionHostEnv:void 0}async getWslPath(e,t){return(await this._remoteAgentService.getEnvironment())?.os!==H.Windows?e:this._remoteTerminalChannel.getWslPath(e,t)||e}async setTerminalLayoutInfo(e){if(!this._remoteTerminalChannel)throw new Error("Cannot call setActiveInstanceId when there is no remote");return this._remoteTerminalChannel.setTerminalLayoutInfo(e)}async reduceConnectionGraceTime(){if(!this._remoteTerminalChannel)throw new Error("Cannot reduce grace time when there is no remote");return this._remoteTerminalChannel.reduceConnectionGraceTime()}async getTerminalLayoutInfo(){if(!this._remoteTerminalChannel)throw new Error("Cannot call getActiveInstanceId when there is no remote");const e=this._getWorkspaceId(),t=this._storageService.get(p.TerminalBufferState,v.WORKSPACE),r=this._deserializeTerminalState(t);if(r&&r.length>0)try{g("code/terminal/willReviveTerminalProcessesRemote"),await this._remoteTerminalChannel.reviveTerminalProcesses(e,r,Intl.DateTimeFormat().resolvedOptions().locale),g("code/terminal/didReviveTerminalProcessesRemote"),this._storageService.remove(p.TerminalBufferState,v.WORKSPACE);const i=this._storageService.get(p.TerminalLayoutInfo,v.WORKSPACE);i&&(g("code/terminal/willSetTerminalLayoutInfoRemote"),await this._remoteTerminalChannel.setTerminalLayoutInfo(JSON.parse(i)),g("code/terminal/didSetTerminalLayoutInfoRemote"),this._storageService.remove(p.TerminalLayoutInfo,v.WORKSPACE))}catch(i){this._logService.warn("RemoteTerminalBackend#getTerminalLayoutInfo Error",i&&typeof i=="object"&&"message"in i?i.message:i)}return this._remoteTerminalChannel.getTerminalLayoutInfo()}async getPerformanceMarks(){return this._remoteTerminalChannel.getPerformanceMarks()}};I=P([o(2,x),o(3,b),o(4,$),o(5,z),o(6,G),o(7,j),o(8,U),o(9,te),o(10,ne),o(11,K),o(12,re)],I);export{T as RemoteTerminalBackendContribution};
