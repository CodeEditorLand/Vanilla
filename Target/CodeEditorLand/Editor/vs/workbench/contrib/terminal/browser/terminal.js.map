{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/terminal/browser/terminal.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IDimension } from '../../../../base/browser/dom.js';\nimport { Orientation } from '../../../../base/browser/ui/splitview/splitview.js';\nimport { Color } from '../../../../base/common/color.js';\nimport { Event, IDynamicListEventMultiplexer, type DynamicListEventMultiplexer } from '../../../../base/common/event.js';\nimport { DisposableStore, IDisposable } from '../../../../base/common/lifecycle.js';\nimport { OperatingSystem } from '../../../../base/common/platform.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IKeyMods } from '../../../../platform/quickinput/common/quickInput.js';\nimport { IMarkProperties, ITerminalCapabilityImplMap, ITerminalCapabilityStore, ITerminalCommand, TerminalCapability } from '../../../../platform/terminal/common/capabilities/capabilities.js';\nimport { IMergedEnvironmentVariableCollection } from '../../../../platform/terminal/common/environmentVariable.js';\nimport { IExtensionTerminalProfile, IReconnectionProperties, IShellIntegration, IShellLaunchConfig, ITerminalBackend, ITerminalDimensions, ITerminalLaunchError, ITerminalProfile, ITerminalTabLayoutInfoById, TerminalExitReason, TerminalIcon, TerminalLocation, TerminalShellType, TerminalType, TitleEventSource, WaitOnExitValue } from '../../../../platform/terminal/common/terminal.js';\nimport { IColorTheme } from '../../../../platform/theme/common/themeService.js';\nimport { IWorkspaceFolder } from '../../../../platform/workspace/common/workspace.js';\nimport { EditorInput } from '../../../common/editor/editorInput.js';\nimport { IEditableData } from '../../../common/views.js';\nimport { ITerminalStatusList } from './terminalStatusList.js';\nimport { XtermTerminal } from './xterm/xtermTerminal.js';\nimport { IRegisterContributedProfileArgs, IRemoteTerminalAttachTarget, IStartExtensionTerminalRequest, ITerminalConfiguration, ITerminalFont, ITerminalProcessExtHostProxy, ITerminalProcessInfo } from '../common/terminal.js';\nimport type { IMarker, ITheme, Terminal as RawXtermTerminal, IBufferRange } from '@xterm/xterm';\nimport { ScrollPosition } from './xterm/markNavigationAddon.js';\nimport { IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';\nimport { GroupIdentifier } from '../../../common/editor.js';\nimport { ACTIVE_GROUP_TYPE, AUX_WINDOW_GROUP_TYPE, SIDE_GROUP_TYPE } from '../../../services/editor/common/editorService.js';\nimport type { ICurrentPartialCommand } from '../../../../platform/terminal/common/capabilities/commandDetection/terminalCommand.js';\nimport type { IXtermCore } from './xterm-private.js';\nimport type { IMenu } from '../../../../platform/actions/common/actions.js';\nimport type { Barrier } from '../../../../base/common/async.js';\n\nexport const ITerminalService = createDecorator<ITerminalService>('terminalService');\nexport const ITerminalConfigurationService = createDecorator<ITerminalConfigurationService>('terminalConfigurationService');\nexport const ITerminalEditorService = createDecorator<ITerminalEditorService>('terminalEditorService');\nexport const ITerminalGroupService = createDecorator<ITerminalGroupService>('terminalGroupService');\nexport const ITerminalInstanceService = createDecorator<ITerminalInstanceService>('terminalInstanceService');\n\n/**\n * A terminal contribution that gets created whenever a terminal is created. A contribution has\n * access to the process manager through the constructor and provides a method for when xterm.js has\n * been initialized.\n */\nexport interface ITerminalContribution extends IDisposable {\n\tlayout?(xterm: IXtermTerminal & { raw: RawXtermTerminal }, dimension: IDimension): void;\n\txtermOpen?(xterm: IXtermTerminal & { raw: RawXtermTerminal }): void;\n\txtermReady?(xterm: IXtermTerminal & { raw: RawXtermTerminal }): void;\n}\n\n/**\n * A service used to create instances or fetch backends, this services allows services that\n * ITerminalService depends on to also create instances.\n *\n * **This service is intended to only be used within the terminal contrib.**\n */\nexport interface ITerminalInstanceService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * An event that's fired when a terminal instance is created.\n\t */\n\tonDidCreateInstance: Event<ITerminalInstance>;\n\n\t/**\n\t * Helper function to convert a shell launch config, a profile or undefined into its equivalent\n\t * shell launch config.\n\t * @param shellLaunchConfigOrProfile A shell launch config, a profile or undefined\n\t * @param cwd A cwd to override.\n\t */\n\tconvertProfileToShellLaunchConfig(shellLaunchConfigOrProfile?: IShellLaunchConfig | ITerminalProfile, cwd?: string | URI): IShellLaunchConfig;\n\n\t/**\n\t * Create a new terminal instance.\n\t * @param launchConfig The shell launch config.\n\t * @param target The target of the terminal.\n\t */\n\tcreateInstance(launchConfig: IShellLaunchConfig, target: TerminalLocation): ITerminalInstance;\n\n\t/**\n\t * Gets the registered backend for a remote authority (undefined = local). This is a convenience\n\t * method to avoid using the more verbose fetching from the registry.\n\t * @param remoteAuthority The remote authority of the backend.\n\t */\n\tgetBackend(remoteAuthority?: string): Promise<ITerminalBackend | undefined>;\n\n\tgetRegisteredBackends(): IterableIterator<ITerminalBackend>;\n\tdidRegisterBackend(remoteAuthority?: string): void;\n}\n\nexport const enum Direction {\n\tLeft = 0,\n\tRight = 1,\n\tUp = 2,\n\tDown = 3\n}\n\nexport interface IQuickPickTerminalObject {\n\tconfig: IRegisterContributedProfileArgs | ITerminalProfile | { profile: IExtensionTerminalProfile; options: { icon?: string; color?: string } } | undefined;\n\tkeyMods: IKeyMods | undefined;\n}\n\nexport interface IMarkTracker {\n\tscrollToPreviousMark(scrollPosition?: ScrollPosition, retainSelection?: boolean, skipEmptyCommands?: boolean): void;\n\tscrollToNextMark(): void;\n\tselectToPreviousMark(): void;\n\tselectToNextMark(): void;\n\tselectToPreviousLine(): void;\n\tselectToNextLine(): void;\n\tclear(): void;\n\tscrollToClosestMarker(startMarkerId: string, endMarkerId?: string, highlight?: boolean | undefined): void;\n\n\tscrollToLine(line: number, position: ScrollPosition): void;\n\trevealCommand(command: ITerminalCommand | ICurrentPartialCommand, position?: ScrollPosition): void;\n\trevealRange(range: IBufferRange): void;\n\tregisterTemporaryDecoration(marker: IMarker, endMarker: IMarker | undefined, showOutline: boolean): void;\n\tshowCommandGuide(command: ITerminalCommand | undefined): void;\n\n\tsaveScrollState(): void;\n\trestoreScrollState(): void;\n}\n\nexport interface ITerminalGroup {\n\tactiveInstance: ITerminalInstance | undefined;\n\tterminalInstances: ITerminalInstance[];\n\ttitle: string;\n\n\treadonly onDidDisposeInstance: Event<ITerminalInstance>;\n\treadonly onDisposed: Event<ITerminalGroup>;\n\treadonly onInstancesChanged: Event<void>;\n\treadonly onPanelOrientationChanged: Event<Orientation>;\n\n\tfocusPreviousPane(): void;\n\tfocusNextPane(): void;\n\tresizePane(direction: Direction): void;\n\tresizePanes(relativeSizes: number[]): void;\n\tsetActiveInstanceByIndex(index: number, force?: boolean): void;\n\tattachToElement(element: HTMLElement): void;\n\taddInstance(instance: ITerminalInstance): void;\n\tremoveInstance(instance: ITerminalInstance): void;\n\tmoveInstance(instances: ITerminalInstance | ITerminalInstance[], index: number, position: 'before' | 'after'): void;\n\tsetVisible(visible: boolean): void;\n\tlayout(width: number, height: number): void;\n\taddDisposable(disposable: IDisposable): void;\n\tsplit(shellLaunchConfig: IShellLaunchConfig): ITerminalInstance;\n\tgetLayoutInfo(isActive: boolean): ITerminalTabLayoutInfoById;\n}\n\nexport const enum TerminalConnectionState {\n\tConnecting,\n\tConnected\n}\n\nexport interface IDetachedXTermOptions {\n\tcols: number;\n\trows: number;\n\tcolorProvider: IXtermColorProvider;\n\tcapabilities?: ITerminalCapabilityStore;\n\treadonly?: boolean;\n\tprocessInfo: ITerminalProcessInfo;\n}\n\n/**\n * A generic interface implemented in both the {@link ITerminalInstance} (an\n * interface used for terminals attached to the terminal panel or editor) and\n * {@link IDetachedTerminalInstance} (a terminal used elsewhere in VS Code UI).\n */\nexport interface IBaseTerminalInstance {\n\treadonly capabilities: ITerminalCapabilityStore;\n\n\t/**\n\t * DOM element the terminal is mounted in.\n\t */\n\treadonly domElement?: HTMLElement;\n\n\t/**\n\t * Current selection in the terminal.\n\t */\n\treadonly selection: string | undefined;\n\n\t/**\n\t * Check if anything is selected in terminal.\n\t */\n\thasSelection(): boolean;\n\n\t/**\n\t * Clear current selection.\n\t */\n\tclearSelection(): void;\n\n\t/**\n\t * Focuses the terminal instance if it's able to (the xterm.js instance must exist).\n\t *\n\t * @param force Force focus even if there is a selection.\n\t */\n\tfocus(force?: boolean): void;\n\n\t/**\n\t * Force the scroll bar to be visible until {@link resetScrollbarVisibility} is called.\n\t */\n\tforceScrollbarVisibility(): void;\n\n\t/**\n\t * Resets the scroll bar to only be visible when needed, this does nothing unless\n\t * {@link forceScrollbarVisibility} was called.\n\t */\n\tresetScrollbarVisibility(): void;\n\n\t/**\n\t * Gets a terminal contribution by its ID.\n\t */\n\tgetContribution<T extends ITerminalContribution>(id: string): T | null;\n}\n\n/**\n * A {@link ITerminalInstance}-like object that emulates a subset of\n * capabilities. This instance is returned from {@link ITerminalService.createDetachedTerminal}\n * to represent terminals that appear in other parts of the VS Code UI outside\n * of the \"Terminal\" view or editors.\n */\nexport interface IDetachedTerminalInstance extends IDisposable, IBaseTerminalInstance {\n\treadonly xterm: IDetachedXtermTerminal;\n\n\t/**\n\t * Attached the terminal to the given element. This should be preferred over\n\t * calling {@link IXtermTerminal.attachToElement} so that extra DOM elements\n\t * for contributions are initialized.\n\t *\n\t * @param container Container the terminal will be rendered in\n\t * @param options Additional options for mounting the terminal in an element\n\t */\n\tattachToElement(container: HTMLElement, options?: Partial<IXtermAttachToElementOptions>): void;\n}\n\nexport const isDetachedTerminalInstance = (t: ITerminalInstance | IDetachedTerminalInstance): t is IDetachedTerminalInstance => typeof (t as ITerminalInstance).instanceId !== 'number';\n\nexport interface ITerminalService extends ITerminalInstanceHost {\n\treadonly _serviceBrand: undefined;\n\n\t/** Gets all terminal instances, including editor and terminal view (group) instances. */\n\treadonly instances: readonly ITerminalInstance[];\n\t/** Gets detached terminal instances created via {@link createDetachedXterm}. */\n\treadonly detachedInstances: Iterable<IDetachedTerminalInstance>;\n\treadonly defaultLocation: TerminalLocation;\n\n\treadonly isProcessSupportRegistered: boolean;\n\treadonly connectionState: TerminalConnectionState;\n\treadonly whenConnected: Promise<void>;\n\t/** The number of restored terminal groups on startup. */\n\treadonly restoredGroupCount: number;\n\n\treadonly onDidCreateInstance: Event<ITerminalInstance>;\n\treadonly onDidChangeInstanceDimensions: Event<ITerminalInstance>;\n\treadonly onDidRequestStartExtensionTerminal: Event<IStartExtensionTerminalRequest>;\n\treadonly onDidRegisterProcessSupport: Event<void>;\n\treadonly onDidChangeConnectionState: Event<void>;\n\n\t// Group events\n\treadonly onDidChangeActiveGroup: Event<ITerminalGroup | undefined>;\n\n\t// Multiplexed events\n\treadonly onAnyInstanceData: Event<{ instance: ITerminalInstance; data: string }>;\n\treadonly onAnyInstanceDataInput: Event<ITerminalInstance>;\n\treadonly onAnyInstanceIconChange: Event<{ instance: ITerminalInstance; userInitiated: boolean }>;\n\treadonly onAnyInstanceMaximumDimensionsChange: Event<ITerminalInstance>;\n\treadonly onAnyInstancePrimaryStatusChange: Event<ITerminalInstance>;\n\treadonly onAnyInstanceProcessIdReady: Event<ITerminalInstance>;\n\treadonly onAnyInstanceSelectionChange: Event<ITerminalInstance>;\n\treadonly onAnyInstanceTitleChange: Event<ITerminalInstance>;\n\n\t/**\n\t * Creates a terminal.\n\t * @param options The options to create the terminal with, when not specified the default\n\t * profile will be used at the default target.\n\t */\n\tcreateTerminal(options?: ICreateTerminalOptions): Promise<ITerminalInstance>;\n\n\t/**\n\t * Creates a detached xterm instance which is not attached to the DOM or\n\t * tracked as a terminal instance.\n\t * @params options The options to create the terminal with\n\t */\n\tcreateDetachedTerminal(options: IDetachedXTermOptions): Promise<IDetachedTerminalInstance>;\n\n\t/**\n\t * Creates a raw terminal instance, this should not be used outside of the terminal part.\n\t */\n\tgetInstanceFromId(terminalId: number): ITerminalInstance | undefined;\n\tgetInstanceFromIndex(terminalIndex: number): ITerminalInstance;\n\n\t/**\n\t * An owner of terminals might be created after reconnection has occurred,\n\t * so store them to be requested/adopted later\n\t */\n\tgetReconnectedTerminals(reconnectionOwner: string): ITerminalInstance[] | undefined;\n\n\tgetActiveOrCreateInstance(options?: { acceptsInput?: boolean }): Promise<ITerminalInstance>;\n\trevealTerminal(source: ITerminalInstance, preserveFocus?: boolean): Promise<void>;\n\trevealActiveTerminal(preserveFocus?: boolean): Promise<void>;\n\tmoveToEditor(source: ITerminalInstance, group?: GroupIdentifier | SIDE_GROUP_TYPE | ACTIVE_GROUP_TYPE | AUX_WINDOW_GROUP_TYPE): void;\n\tmoveIntoNewEditor(source: ITerminalInstance): void;\n\tmoveToTerminalView(source: ITerminalInstance | URI): Promise<void>;\n\tgetPrimaryBackend(): ITerminalBackend | undefined;\n\n\t/**\n\t * Fire the onActiveTabChanged event, this will trigger the terminal dropdown to be updated,\n\t * among other things.\n\t */\n\trefreshActiveGroup(): void;\n\n\tregisterProcessSupport(isSupported: boolean): void;\n\n\tshowProfileQuickPick(type: 'setDefault' | 'createInstance', cwd?: string | URI): Promise<ITerminalInstance | undefined>;\n\n\tsetContainers(panelContainer: HTMLElement, terminalContainer: HTMLElement): void;\n\n\trequestStartExtensionTerminal(proxy: ITerminalProcessExtHostProxy, cols: number, rows: number): Promise<ITerminalLaunchError | undefined>;\n\tisAttachedToTerminal(remoteTerm: IRemoteTerminalAttachTarget): boolean;\n\tgetEditableData(instance: ITerminalInstance): IEditableData | undefined;\n\tsetEditable(instance: ITerminalInstance, data: IEditableData | null): void;\n\tisEditable(instance: ITerminalInstance | undefined): boolean;\n\tsafeDisposeTerminal(instance: ITerminalInstance): Promise<void>;\n\n\tgetDefaultInstanceHost(): ITerminalInstanceHost;\n\tgetInstanceHost(target: ITerminalLocationOptions | undefined): Promise<ITerminalInstanceHost>;\n\n\tresolveLocation(location?: ITerminalLocationOptions): Promise<TerminalLocation | undefined>;\n\tsetNativeDelegate(nativeCalls: ITerminalServiceNativeDelegate): void;\n\n\tgetEditingTerminal(): ITerminalInstance | undefined;\n\tsetEditingTerminal(instance: ITerminalInstance | undefined): void;\n\n\t/**\n\t * Creates an instance event listener that listens to all instances, dynamically adding new\n\t * instances and removing old instances as needed.\n\t * @param getEvent Maps the instance to the event.\n\t */\n\tcreateOnInstanceEvent<T>(getEvent: (instance: ITerminalInstance) => Event<T>): DynamicListEventMultiplexer<ITerminalInstance, T>;\n\n\t/**\n\t * Creates a capability event listener that listens to capabilities on all instances,\n\t * dynamically adding and removing instances and capabilities as needed.\n\t * @param capabilityId The capability type to listen to an event on.\n\t * @param getEvent Maps the capability to the event.\n\t */\n\tcreateOnInstanceCapabilityEvent<T extends TerminalCapability, K>(capabilityId: T, getEvent: (capability: ITerminalCapabilityImplMap[T]) => Event<K>): IDynamicListEventMultiplexer<{ instance: ITerminalInstance; data: K }>;\n}\n\n/**\n * A service that provides convenient access to the terminal configuration and derived values.\n */\nexport interface ITerminalConfigurationService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * A typed and partially validated representation of the terminal configuration.\n\t */\n\treadonly config: Readonly<ITerminalConfiguration>;\n\n\t/**\n\t * Fires when something within the terminal configuration changes.\n\t */\n\treadonly onConfigChanged: Event<void>;\n\n\tsetPanelContainer(panelContainer: HTMLElement): void;\n\tconfigFontIsMonospace(): boolean;\n\tgetFont(w: Window, xtermCore?: IXtermCore, excludeDimensions?: boolean): ITerminalFont;\n}\n\nexport class TerminalLinkQuickPickEvent extends MouseEvent {\n\n}\nexport interface ITerminalServiceNativeDelegate {\n\tgetWindowCount(): Promise<number>;\n}\n\n/**\n * This service is responsible for integrating with the editor service and managing terminal\n * editors.\n */\nexport interface ITerminalEditorService extends ITerminalInstanceHost {\n\treadonly _serviceBrand: undefined;\n\n\t/** Gets all _terminal editor_ instances. */\n\treadonly instances: readonly ITerminalInstance[];\n\n\topenEditor(instance: ITerminalInstance, editorOptions?: TerminalEditorLocation): Promise<void>;\n\tdetachInstance(instance: ITerminalInstance): void;\n\tsplitInstance(instanceToSplit: ITerminalInstance, shellLaunchConfig?: IShellLaunchConfig): ITerminalInstance;\n\trevealActiveEditor(preserveFocus?: boolean): Promise<void>;\n\tresolveResource(instance: ITerminalInstance): URI;\n\treviveInput(deserializedInput: IDeserializedTerminalEditorInput): EditorInput;\n\tgetInputFromResource(resource: URI): EditorInput;\n}\n\nexport const terminalEditorId = 'terminalEditor';\n\ninterface ITerminalEditorInputObject {\n\treadonly id: number;\n\treadonly pid: number;\n\treadonly title: string;\n\treadonly titleSource: TitleEventSource;\n\treadonly cwd: string;\n\treadonly icon: TerminalIcon | undefined;\n\treadonly color: string | undefined;\n\treadonly hasChildProcesses?: boolean;\n\treadonly type?: TerminalType;\n\treadonly isFeatureTerminal?: boolean;\n\treadonly hideFromUser?: boolean;\n\treadonly reconnectionProperties?: IReconnectionProperties;\n\treadonly shellIntegrationNonce: string;\n}\n\nexport interface ISerializedTerminalEditorInput extends ITerminalEditorInputObject {\n}\n\nexport interface IDeserializedTerminalEditorInput extends ITerminalEditorInputObject {\n}\n\nexport type ITerminalLocationOptions = TerminalLocation | TerminalEditorLocation | { parentTerminal: Promise<ITerminalInstance> | ITerminalInstance } | { splitActiveTerminal: boolean };\n\nexport interface ICreateTerminalOptions {\n\t/**\n\t * The shell launch config or profile to launch with, when not specified the default terminal\n\t * profile will be used.\n\t */\n\tconfig?: IShellLaunchConfig | ITerminalProfile | IExtensionTerminalProfile;\n\t/**\n\t * The current working directory to start with, this will override IShellLaunchConfig.cwd if\n\t * specified.\n\t */\n\tcwd?: string | URI;\n\t/**\n\t * The terminal's resource, passed when the terminal has moved windows.\n\t */\n\tresource?: URI;\n\n\t/**\n\t * The terminal's location (editor or panel), it's terminal parent (split to the right), or editor group\n\t */\n\tlocation?: ITerminalLocationOptions;\n\n\t/**\n\t * This terminal will not wait for contributed profiles to resolve which means it will proceed\n\t * when the workbench is not yet loaded.\n\t */\n\tskipContributedProfileCheck?: boolean;\n}\n\nexport interface TerminalEditorLocation {\n\tviewColumn: GroupIdentifier | SIDE_GROUP_TYPE | ACTIVE_GROUP_TYPE | AUX_WINDOW_GROUP_TYPE;\n\tpreserveFocus?: boolean;\n}\n\n/**\n * This service is responsible for managing terminal groups, that is the terminals that are hosted\n * within the terminal panel, not in an editor.\n */\nexport interface ITerminalGroupService extends ITerminalInstanceHost {\n\treadonly _serviceBrand: undefined;\n\n\t/** Gets all _terminal view_ instances, ie. instances contained within terminal groups. */\n\treadonly instances: readonly ITerminalInstance[];\n\treadonly groups: readonly ITerminalGroup[];\n\tactiveGroup: ITerminalGroup | undefined;\n\treadonly activeGroupIndex: number;\n\t/**\n\t * Gets or sets the last accessed menu, this is used to select the instance(s) for menu actions.\n\t */\n\tlastAccessedMenu: 'inline-tab' | 'tab-list';\n\n\treadonly onDidChangeActiveGroup: Event<ITerminalGroup | undefined>;\n\treadonly onDidDisposeGroup: Event<ITerminalGroup>;\n\t/** Fires when a group is created, disposed of, or shown (in the case of a background group). */\n\treadonly onDidChangeGroups: Event<void>;\n\t/** Fires when the panel has been shown and expanded, so has non-zero dimensions. */\n\treadonly onDidShow: Event<void>;\n\treadonly onDidChangePanelOrientation: Event<Orientation>;\n\n\tcreateGroup(shellLaunchConfig?: IShellLaunchConfig): ITerminalGroup;\n\tcreateGroup(instance?: ITerminalInstance): ITerminalGroup;\n\tgetGroupForInstance(instance: ITerminalInstance): ITerminalGroup | undefined;\n\n\t/**\n\t * Moves a terminal instance's group to the target instance group's position.\n\t * @param source The source instance to move.\n\t * @param target The target instance to move the source instance to.\n\t */\n\tmoveGroup(source: ITerminalInstance | ITerminalInstance[], target: ITerminalInstance): void;\n\tmoveGroupToEnd(source: ITerminalInstance | ITerminalInstance[]): void;\n\n\tmoveInstance(source: ITerminalInstance, target: ITerminalInstance, side: 'before' | 'after'): void;\n\tunsplitInstance(instance: ITerminalInstance): void;\n\tjoinInstances(instances: ITerminalInstance[]): void;\n\tinstanceIsSplit(instance: ITerminalInstance): boolean;\n\n\tgetGroupLabels(): string[];\n\tsetActiveGroupByIndex(index: number): void;\n\tsetActiveGroupToNext(): void;\n\tsetActiveGroupToPrevious(): void;\n\n\tsetActiveInstanceByIndex(terminalIndex: number): void;\n\n\tsetContainer(container: HTMLElement): void;\n\n\tshowPanel(focus?: boolean): Promise<void>;\n\thidePanel(): void;\n\tfocusTabs(): void;\n\tfocusHover(): void;\n\tupdateVisibility(): void;\n}\n\n/**\n * An interface that indicates the implementer hosts terminal instances, exposing a common set of\n * properties and events.\n */\nexport interface ITerminalInstanceHost {\n\treadonly activeInstance: ITerminalInstance | undefined;\n\treadonly instances: readonly ITerminalInstance[];\n\n\treadonly onDidDisposeInstance: Event<ITerminalInstance>;\n\treadonly onDidFocusInstance: Event<ITerminalInstance>;\n\treadonly onDidChangeActiveInstance: Event<ITerminalInstance | undefined>;\n\treadonly onDidChangeInstances: Event<void>;\n\treadonly onDidChangeInstanceCapability: Event<ITerminalInstance>;\n\n\tsetActiveInstance(instance: ITerminalInstance): void;\n\t/**\n\t * Reveal and focus the instance, regardless of its location.\n\t */\n\tfocusInstance(instance: ITerminalInstance): void;\n\t/**\n\t * Reveal and focus the active instance, regardless of its location.\n\t */\n\tfocusActiveInstance(): Promise<void>;\n\t/**\n\t * Gets an instance from a resource if it exists. This MUST be used instead of getInstanceFromId\n\t * when you only know about a terminal's URI. (a URI's instance ID may not be this window's instance ID)\n\t */\n\tgetInstanceFromResource(resource: URI | undefined): ITerminalInstance | undefined;\n}\n\n/**\n * Similar to xterm.js' ILinkProvider but using promises and hides xterm.js internals (like buffer\n * positions, decorations, etc.) from the rest of vscode. This is the interface to use for\n * workbench integrations.\n */\nexport interface ITerminalExternalLinkProvider {\n\tprovideLinks(instance: ITerminalInstance, line: string): Promise<ITerminalLink[] | undefined>;\n}\n\nexport interface ITerminalLink {\n\t/** The startIndex of the link in the line. */\n\tstartIndex: number;\n\t/** The length of the link in the line. */\n\tlength: number;\n\t/** The descriptive label for what the link does when activated. */\n\tlabel?: string;\n\t/**\n\t * Activates the link.\n\t * @param text The text of the link.\n\t */\n\tactivate(text: string): void;\n}\n\nexport interface ISearchOptions {\n\t/** Whether the find should be done as a regex. */\n\tregex?: boolean;\n\t/** Whether only whole words should match. */\n\twholeWord?: boolean;\n\t/** Whether find should pay attention to case. */\n\tcaseSensitive?: boolean;\n\t/** Whether the search should start at the current search position (not the next row). */\n\tincremental?: boolean;\n}\n\nexport interface ITerminalInstance extends IBaseTerminalInstance {\n\t/**\n\t * The ID of the terminal instance, this is an arbitrary number only used to uniquely identify\n\t * terminal instances within a window.\n\t */\n\treadonly instanceId: number;\n\t/**\n\t * A unique URI for this terminal instance with the following encoding:\n\t * path: /<workspace ID>/<instance ID>\n\t * fragment: Title\n\t * Note that when dragging terminals across windows, this will retain the original workspace ID /instance ID\n\t * from the other window.\n\t */\n\treadonly resource: URI;\n\n\treadonly cols: number;\n\treadonly rows: number;\n\treadonly maxCols: number;\n\treadonly maxRows: number;\n\treadonly fixedCols?: number;\n\treadonly fixedRows?: number;\n\treadonly domElement: HTMLElement;\n\treadonly icon?: TerminalIcon;\n\treadonly color?: string;\n\treadonly reconnectionProperties?: IReconnectionProperties;\n\treadonly processName: string;\n\treadonly sequence?: string;\n\treadonly staticTitle?: string;\n\treadonly workspaceFolder?: IWorkspaceFolder;\n\treadonly cwd?: string;\n\treadonly initialCwd?: string;\n\treadonly os?: OperatingSystem;\n\treadonly usedShellIntegrationInjection: boolean;\n\treadonly injectedArgs: string[] | undefined;\n\treadonly extEnvironmentVariableCollection: IMergedEnvironmentVariableCollection | undefined;\n\n\t/**\n\t * The underlying disposable store, allowing objects who share the same lifecycle as the\n\t * terminal instance but are created externally to be managed by the instance.\n\t */\n\treadonly store: DisposableStore;\n\n\treadonly statusList: ITerminalStatusList;\n\n\t/**\n\t * The process ID of the shell process, this is undefined when there is no process associated\n\t * with this terminal.\n\t */\n\tprocessId: number | undefined;\n\n\t/**\n\t * The position of the terminal.\n\t */\n\ttarget?: TerminalLocation;\n\n\t/**\n\t * The id of a persistent process. This is defined if this is a terminal created by a pty host\n\t * that supports reconnection.\n\t */\n\treadonly persistentProcessId: number | undefined;\n\n\t/**\n\t * Whether the process should be persisted across reloads.\n\t */\n\treadonly shouldPersist: boolean;\n\n\t/*\n\t * Whether this terminal has been disposed of\n\t */\n\treadonly isDisposed: boolean;\n\n\t/**\n\t * Whether the terminal's pty is hosted on a remote.\n\t */\n\treadonly isRemote: boolean;\n\n\t/**\n\t * The remote authority of the terminal's pty.\n\t */\n\treadonly remoteAuthority: string | undefined;\n\n\t/**\n\t * Whether an element within this terminal is focused.\n\t */\n\treadonly hasFocus: boolean;\n\n\t/**\n\t * Get or set the behavior of the terminal when it closes. This was indented only to be called\n\t * after reconnecting to a terminal.\n\t */\n\twaitOnExit: WaitOnExitValue | undefined;\n\n\t/**\n\t * An event that fires when the terminal instance's title changes.\n\t */\n\tonTitleChanged: Event<ITerminalInstance>;\n\n\t/**\n\t * An event that fires when the terminal instance's icon changes.\n\t */\n\tonIconChanged: Event<{ instance: ITerminalInstance; userInitiated: boolean }>;\n\n\t/**\n\t * An event that fires when the terminal instance is disposed.\n\t */\n\tonDisposed: Event<ITerminalInstance>;\n\n\tonProcessIdReady: Event<ITerminalInstance>;\n\tonProcessReplayComplete: Event<void>;\n\tonRequestExtHostProcess: Event<ITerminalInstance>;\n\tonDimensionsChanged: Event<void>;\n\tonMaximumDimensionsChanged: Event<void>;\n\tonDidChangeHasChildProcesses: Event<boolean>;\n\n\tonDidFocus: Event<ITerminalInstance>;\n\tonDidRequestFocus: Event<void>;\n\tonDidBlur: Event<ITerminalInstance>;\n\tonDidInputData: Event<string>;\n\tonDidChangeSelection: Event<ITerminalInstance>;\n\tonDidExecuteText: Event<void>;\n\tonDidChangeTarget: Event<TerminalLocation | undefined>;\n\tonDidSendText: Event<string>;\n\tonDidChangeShellType: Event<TerminalShellType>;\n\tonDidChangeVisibility: Event<boolean>;\n\n\tonWillPaste: Event<string>;\n\tonDidPaste: Event<string>;\n\n\t/**\n\t * An event that fires when a terminal is dropped on this instance via drag and drop.\n\t */\n\tonRequestAddInstanceToGroup: Event<IRequestAddInstanceToGroupEvent>;\n\n\t/**\n\t * Attach a listener to the raw data stream coming from the pty, including ANSI escape\n\t * sequences.\n\t */\n\tonData: Event<string>;\n\tonWillData: Event<string>;\n\n\t/**\n\t * Attach a listener to the binary data stream coming from xterm and going to pty\n\t */\n\tonBinary: Event<string>;\n\n\t/**\n\t * Attach a listener to listen for new lines added to this terminal instance.\n\t *\n\t * @param listener The listener function which takes new line strings added to the terminal,\n\t * excluding ANSI escape sequences. The line event will fire when an LF character is added to\n\t * the terminal (ie. the line is not wrapped). Note that this means that the line data will\n\t * not fire for the last line, until either the line is ended with a LF character of the process\n\t * is exited. The lineData string will contain the fully wrapped line, not containing any LF/CR\n\t * characters.\n\t */\n\tonLineData: Event<string>;\n\n\t/**\n\t * Attach a listener that fires when the terminal's pty process exits. The number in the event\n\t * is the processes' exit code, an exit code of undefined means the process was killed as a result of\n\t * the ITerminalInstance being disposed.\n\t */\n\tonExit: Event<number | ITerminalLaunchError | undefined>;\n\n\t/**\n\t * The exit code or undefined when the terminal process hasn't yet exited or\n\t * the process exit code could not be determined. Use {@link exitReason} to see\n\t * why the process has exited.\n\t */\n\treadonly exitCode: number | undefined;\n\n\t/**\n\t * The reason the terminal process exited, this will be undefined if the process is still\n\t * running.\n\t */\n\treadonly exitReason: TerminalExitReason | undefined;\n\n\t/**\n\t * The xterm.js instance for this terminal.\n\t */\n\treadonly xterm?: XtermTerminal;\n\n\t/**\n\t * Returns an array of data events that have fired within the first 10 seconds. If this is\n\t * called 10 seconds after the terminal has existed the result will be undefined. This is useful\n\t * when objects that depend on the data events have delayed initialization, like extension\n\t * hosts.\n\t */\n\treadonly initialDataEvents: string[] | undefined;\n\n\t/** A promise that resolves when the terminal's pty/process have been created. */\n\treadonly processReady: Promise<void>;\n\n\t/** Whether the terminal's process has child processes (ie. is dirty/busy). */\n\treadonly hasChildProcesses: boolean;\n\n\t/**\n\t * The title of the terminal. This is either title or the process currently running or an\n\t * explicit name given to the terminal instance through the extension API.\n\t */\n\treadonly title: string;\n\n\t/**\n\t * How the current title was set.\n\t */\n\treadonly titleSource: TitleEventSource;\n\n\t/**\n\t * The shell type of the terminal.\n\t */\n\treadonly shellType: TerminalShellType | undefined;\n\n\t/**\n\t * The focus state of the terminal before exiting.\n\t */\n\treadonly hadFocusOnExit: boolean;\n\n\t/**\n\t * False when the title is set by an API or the user. We check this to make sure we\n\t * do not override the title when the process title changes in the terminal.\n\t */\n\tisTitleSetByProcess: boolean;\n\n\t/**\n\t * The shell launch config used to launch the shell.\n\t */\n\treadonly shellLaunchConfig: IShellLaunchConfig;\n\n\t/**\n\t * Whether to disable layout for the terminal. This is useful when the size of the terminal is\n\t * being manipulating (e.g. adding a split pane) and we want the terminal to ignore particular\n\t * resize events.\n\t */\n\tdisableLayout: boolean;\n\n\t/**\n\t * The description of the terminal, this is typically displayed next to {@link title}.\n\t */\n\tdescription: string | undefined;\n\n\t/**\n\t * The remote-aware $HOME directory (or Windows equivalent) of the terminal.\n\t */\n\tuserHome: string | undefined;\n\n\t/**\n\t * The nonce used to verify commands coming from shell integration.\n\t */\n\tshellIntegrationNonce: string;\n\n\t/**\n\t * Registers and returns a marker\n\t * @param the y offset from the cursor\n\t */\n\tregisterMarker(offset?: number): IMarker | undefined;\n\n\t/**\n\t * Adds a marker to the buffer, mapping it to an ID if provided.\n\t */\n\taddBufferMarker(properties: IMarkProperties): void;\n\n\t/**\n\t *\n\t * @param startMarkId The ID for the start marker\n\t * @param endMarkId The ID for the end marker\n\t * @param highlight Whether the buffer from startMarker to endMarker\n\t * should be highlighted\n\t */\n\tscrollToMark(startMarkId: string, endMarkId?: string, highlight?: boolean): void;\n\n\t/**\n\t * Dispose the terminal instance, removing it from the panel/service and freeing up resources.\n\t *\n\t * @param reason The reason why the terminal is being disposed\n\t */\n\tdispose(reason?: TerminalExitReason): void;\n\n\t/**\n\t * Informs the process that the terminal is now detached and\n\t * then disposes the terminal.\n\t *\n\t * @param reason The reason why the terminal is being disposed\n\t */\n\tdetachProcessAndDispose(reason: TerminalExitReason): Promise<void>;\n\n\t/**\n\t * Copies the terminal selection to the clipboard.\n\t */\n\tcopySelection(asHtml?: boolean, command?: ITerminalCommand): Promise<void>;\n\n\t/**\n\t * When the panel is hidden or a terminal in the editor area becomes inactive, reset the focus context key\n\t * to avoid issues like #147180.\n\t */\n\tresetFocusContextKey(): void;\n\n\t/**\n\t * Focuses the terminal instance when it's ready (the xterm.js instance much exist). This is the\n\t * best focus call when the terminal is being shown for example.\n\t * when the terminal is being shown.\n\t *\n\t * @param force Force focus even if there is a selection.\n\t */\n\tfocusWhenReady(force?: boolean): Promise<void>;\n\n\t/**\n\t * Focuses and pastes the contents of the clipboard into the terminal instance.\n\t */\n\tpaste(): Promise<void>;\n\n\t/**\n\t * Focuses and pastes the contents of the selection clipboard into the terminal instance.\n\t */\n\tpasteSelection(): Promise<void>;\n\n\t/**\n\t * Override the copy on selection feature with a custom value.\n\t * @param value Whether to enable copySelection.\n\t */\n\toverrideCopyOnSelection(value: boolean): IDisposable;\n\n\t/**\n\t * Send text to the terminal instance. The text is written to the stdin of the underlying pty\n\t * process (shell) of the terminal instance.\n\t *\n\t * @param text The text to send.\n\t * @param shouldExecute Indicates that the text being sent should be executed rather than just inserted in the terminal.\n\t * The character(s) added are \\n or \\r\\n, depending on the platform. This defaults to `true`.\n\t * @param bracketedPasteMode Whether to wrap the text in the bracketed paste mode sequence when\n\t * it's enabled. When true, the shell will treat the text as if it were pasted into the shell,\n\t * this may for example select the text and it will also ensure that the text will not be\n\t * interpreted as a shell keybinding.\n\t */\n\tsendText(text: string, shouldExecute: boolean, bracketedPasteMode?: boolean): Promise<void>;\n\n\t/**\n\t * Sends a path to the terminal instance, preparing it as needed based on the detected shell\n\t * running within the terminal. The text is written to the stdin of the underlying pty process\n\t * (shell) of the terminal instance.\n\t *\n\t * @param originalPath The path to send.\n\t * @param shouldExecute Indicates that the text being sent should be executed rather than just inserted in the terminal.\n\t * The character(s) added are \\n or \\r\\n, depending on the platform. This defaults to `true`.\n\t */\n\tsendPath(originalPath: string | URI, shouldExecute: boolean): Promise<void>;\n\n\trunCommand(command: string, shouldExecute?: boolean): void;\n\n\t/**\n\t * Takes a path and returns the properly escaped path to send to a given shell. On Windows, this\n\t * includes trying to prepare the path for WSL if needed.\n\t *\n\t * @param originalPath The path to be escaped and formatted.\n\t */\n\tpreparePathForShell(originalPath: string): Promise<string>;\n\n\t/** Scroll the terminal buffer down 1 line. */   scrollDownLine(): void;\n\t/** Scroll the terminal buffer down 1 page. */   scrollDownPage(): void;\n\t/** Scroll the terminal buffer to the bottom. */ scrollToBottom(): void;\n\t/** Scroll the terminal buffer up 1 line. */     scrollUpLine(): void;\n\t/** Scroll the terminal buffer up 1 page. */     scrollUpPage(): void;\n\t/** Scroll the terminal buffer to the top. */    scrollToTop(): void;\n\n\t/**\n\t * Clears the terminal buffer, leaving only the prompt line and moving it to the top of the\n\t * viewport.\n\t */\n\tclearBuffer(): void;\n\n\t/**\n\t * Attaches the terminal instance to an element on the DOM, before this is called the terminal\n\t * instance process may run in the background but cannot be displayed on the UI.\n\t *\n\t * @param container The element to attach the terminal instance to.\n\t */\n\tattachToElement(container: HTMLElement): void;\n\n\t/**\n\t * Detaches the terminal instance from the terminal editor DOM element.\n\t */\n\tdetachFromElement(): void;\n\n\t/**\n\t * Layout the terminal instance.\n\t *\n\t * @param dimension The dimensions of the container.\n\t */\n\tlayout(dimension: { width: number; height: number }): void;\n\n\t/**\n\t * Sets whether the terminal instance's element is visible in the DOM.\n\t *\n\t * @param visible Whether the element is visible.\n\t */\n\tsetVisible(visible: boolean): void;\n\n\t/**\n\t * Immediately kills the terminal's current pty process and launches a new one to replace it.\n\t *\n\t * @param shell The new launch configuration.\n\t */\n\treuseTerminal(shell: IShellLaunchConfig): Promise<void>;\n\n\t/**\n\t * Relaunches the terminal, killing it and reusing the launch config used initially. Any\n\t * environment variable changes will be recalculated when this happens.\n\t */\n\trelaunch(): void;\n\n\t/**\n\t * Sets the terminal instance's dimensions to the values provided via the onDidOverrideDimensions event,\n\t * which allows overriding the the regular dimensions (fit to the size of the panel).\n\t */\n\tsetOverrideDimensions(dimensions: ITerminalDimensions): void;\n\n\t/**\n\t * Sets the terminal instance's dimensions to the values provided via quick input.\n\t */\n\tsetFixedDimensions(): Promise<void>;\n\n\t/**\n\t * Toggles terminal line wrapping.\n\t */\n\ttoggleSizeToContentWidth(): Promise<void>;\n\n\t/**\n\t * Gets the initial current working directory, fetching it from the backend if required.\n\t */\n\tgetInitialCwd(): Promise<string>;\n\n\t/**\n\t * Gets the current working directory from cwd detection capabilities if available, otherwise\n\t * from the backend. This will return the initial cwd if cwd detection is not available (ie.\n\t * on Windows when shell integration is disabled).\n\t */\n\tgetCwd(): Promise<string>;\n\n\t/**\n\t * Sets the title of the terminal to the provided string. If no title is provided, it will reset\n\t * to the terminal's title if it was not explicitly set by the user or API.\n\t * @param title The new title.\n\t */\n\trename(title?: string): Promise<void>;\n\n\t/**\n\t * Sets or triggers a quick pick to change the icon of this terminal.\n\t */\n\tchangeIcon(icon?: TerminalIcon): Promise<TerminalIcon | undefined>;\n\n\t/**\n\t * Sets or triggers a quick pick to change the color of the associated terminal tab icon.\n\t */\n\tchangeColor(color?: string, skipQuickPick?: boolean): Promise<string | undefined>;\n\n\t/**\n\t * Triggers a quick pick that displays recent commands or cwds. Selecting one will\n\t * rerun it in the active terminal.\n\t */\n\trunRecent(type: 'command' | 'cwd'): Promise<void>;\n\n\t/**\n\t * Attempts to detect and kill the process listening on specified port.\n\t * If successful, places commandToRun on the command line\n\t */\n\tfreePortKillProcess(port: string, commandToRun: string): Promise<void>;\n\n\t/**\n\t * Update the parent context key service to use for this terminal instance.\n\t */\n\tsetParentContextKeyService(parentContextKeyService: IContextKeyService): void;\n\n\t/**\n\t * Handles a mouse event for the terminal, this may happen on an anscestor of the terminal\n\t * instance's element.\n\t * @param event The mouse event.\n\t * @param contextMenu The context menu to show if needed.\n\t * @returns Whether the context menu should be suppressed.\n\t */\n\thandleMouseEvent(event: MouseEvent, contextMenu: IMenu): Promise<{ cancelContextMenu: boolean } | void>;\n\n\t/**\n\t * Pause input events until the provided barrier is resolved.\n\t * @param barrier The barrier to wait for until input events can continue.\n\t */\n\tpauseInputEvents(barrier: Barrier): void;\n}\n\nexport const enum XtermTerminalConstants {\n\tSearchHighlightLimit = 1000\n}\n\nexport interface IXtermAttachToElementOptions {\n\t/**\n\t * Whether GPU rendering should be enabled for this element, defaults to true.\n\t */\n\tenableGpu: boolean;\n}\n\nexport interface IXtermTerminal extends IDisposable {\n\t/**\n\t * An object that tracks when commands are run and enables navigating and selecting between\n\t * them.\n\t */\n\treadonly markTracker: IMarkTracker;\n\n\t/**\n\t * Reports the status of shell integration and fires events relating to it.\n\t */\n\treadonly shellIntegration: IShellIntegration;\n\n\treadonly onDidChangeSelection: Event<void>;\n\treadonly onDidChangeFindResults: Event<{ resultIndex: number; resultCount: number }>;\n\n\t/**\n\t * Event fired when focus enters (fires with true) or leaves (false) the terminal.\n\t */\n\treadonly onDidChangeFocus: Event<boolean>;\n\n\t/**\n\t * Gets a view of the current texture atlas used by the renderers.\n\t */\n\treadonly textureAtlas: Promise<ImageBitmap> | undefined;\n\n\t/**\n\t * Whether the `disableStdin` option in xterm.js is set.\n\t */\n\treadonly isStdinDisabled: boolean;\n\n\t/**\n\t * Whether the terminal is currently focused.\n\t */\n\treadonly isFocused: boolean;\n\n\t/**\n\t * Whether a canvas-based renderer is being used.\n\t */\n\treadonly isGpuAccelerated: boolean;\n\n\t/**\n\t * Attached the terminal to the given element\n\t * @param container Container the terminal will be rendered in\n\t * @param options Additional options for mounting the terminal in an element\n\t */\n\tattachToElement(container: HTMLElement, options?: Partial<IXtermAttachToElementOptions>): void;\n\n\tfindResult?: { resultIndex: number; resultCount: number };\n\n\t/**\n\t * Find the next instance of the term\n\t*/\n\tfindNext(term: string, searchOptions: ISearchOptions): Promise<boolean>;\n\n\t/**\n\t * Find the previous instance of the term\n\t */\n\tfindPrevious(term: string, searchOptions: ISearchOptions): Promise<boolean>;\n\n\t/**\n\t * Forces the terminal to redraw its viewport.\n\t */\n\tforceRedraw(): void;\n\n\t/**\n\t * Gets the font metrics of this xterm.js instance.\n\t */\n\tgetFont(): ITerminalFont;\n\n\t/**\n\t * Gets whether there's any terminal selection.\n\t */\n\thasSelection(): boolean;\n\n\t/**\n\t * Clears any terminal selection.\n\t */\n\tclearSelection(): void;\n\n\t/**\n\t * Selects all terminal contents/\n\t */\n\tselectAll(): void;\n\n\t/**\n\t * Selects the content between the two markers by their VS Code OSC `SetMarker`\n\t * ID. It's a no-op if either of the two markers are not found.\n\t *\n\t * @param fromMarkerId Start marker ID\n\t * @param toMarkerId End marker ID\n\t * @param scrollIntoView Whether the terminal should scroll to the start of\n\t * the range, defaults tof alse\n\t */\n\tselectMarkedRange(fromMarkerId: string, toMarkerId: string, scrollIntoView?: boolean): void;\n\n\t/**\n\t * Copies the terminal selection.\n\t * @param {boolean} copyAsHtml Whether to copy selection as HTML, defaults to false.\n\t */\n\tcopySelection(copyAsHtml?: boolean): void;\n\n\t/**\n\t * Focuses the terminal. Warning: {@link ITerminalInstance.focus} should be\n\t * preferred when dealing with terminal instances in order to get\n\t * accessibility triggers.\n\t */\n\tfocus(): void;\n\n\t/** Scroll the terminal buffer down 1 line.   */ scrollDownLine(): void;\n\t/** Scroll the terminal buffer down 1 page.   */ scrollDownPage(): void;\n\t/** Scroll the terminal buffer to the bottom. */ scrollToBottom(): void;\n\t/** Scroll the terminal buffer up 1 line.     */ scrollUpLine(): void;\n\t/** Scroll the terminal buffer up 1 page.     */ scrollUpPage(): void;\n\t/** Scroll the terminal buffer to the top.    */ scrollToTop(): void;\n\t/** Scroll the terminal buffer to a set line  */ scrollToLine(line: number, position?: ScrollPosition): void;\n\n\t/**\n\t * Clears the terminal buffer, leaving only the prompt line and moving it to the top of the\n\t * viewport.\n\t */\n\tclearBuffer(): void;\n\n\t/**\n\t * Clears the search result decorations\n\t */\n\tclearSearchDecorations(): void;\n\n\t/**\n\t * Clears the active search result decorations\n\t */\n\tclearActiveSearchDecoration(): void;\n\n\t/**\n\t * Returns a reverse iterator of buffer lines as strings\n\t */\n\tgetBufferReverseIterator(): IterableIterator<string>;\n\n\t/**\n\t * Gets the buffer contents as HTML.\n\t */\n\tgetContentsAsHtml(): Promise<string>;\n\n\t/**\n\t * Refreshes the terminal after it has been moved.\n\t */\n\trefresh(): void;\n\n\tgetXtermTheme(theme?: IColorTheme): ITheme;\n}\n\nexport interface IDetachedXtermTerminal extends IXtermTerminal {\n\t/**\n\t * Writes data to the terminal.\n\t * @param data data to write\n\t * @param callback Optional callback that fires when the data was processed\n\t * by the parser.\n\t */\n\twrite(data: string | Uint8Array, callback?: () => void): void;\n\n\t/**\n\t * Resizes the terminal.\n\t */\n\tresize(columns: number, rows: number): void;\n}\n\nexport interface IInternalXtermTerminal {\n\t/**\n\t * Writes text directly to the terminal, bypassing the process.\n\t *\n\t * **WARNING:** This should never be used outside of the terminal component and only for\n\t * developer purposed inside the terminal component.\n\t */\n\t_writeText(data: string): void; // eslint-disable-line @typescript-eslint/naming-convention\n}\n\nexport interface IXtermColorProvider {\n\tgetBackgroundColor(theme: IColorTheme): Color | undefined;\n}\n\nexport interface IRequestAddInstanceToGroupEvent {\n\turi: URI;\n\tside: 'before' | 'after';\n}\n\nexport const enum LinuxDistro {\n\tUnknown = 1,\n\tFedora = 2,\n\tUbuntu = 3,\n}\n\nexport const enum TerminalDataTransfers {\n\tTerminals = 'Terminals'\n}\n"],
  "mappings": ";;AAKA,SAAS,kBAAkB;AAC3B,SAAS,mBAAmB;AAC5B,SAAS,aAAa;AACtB,SAAS,OAAO,oCAAsE;AACtF,SAAS,iBAAiB,mBAAmB;AAC7C,SAAS,uBAAuB;AAChC,SAAS,WAAW;AACpB,SAAS,uBAAuB;AAChC,SAAS,gBAAgB;AACzB,SAAS,iBAAiB,4BAA4B,0BAA0B,kBAAkB,0BAA0B;AAC5H,SAAS,4CAA4C;AACrD,SAAS,2BAA2B,yBAAyB,mBAAmB,oBAAoB,kBAAkB,qBAAqB,sBAAsB,kBAAkB,4BAA4B,oBAAoB,cAAc,kBAAkB,mBAAmB,cAAc,kBAAkB,uBAAuB;AAC7U,SAAS,mBAAmB;AAC5B,SAAS,wBAAwB;AACjC,SAAS,mBAAmB;AAC5B,SAAS,qBAAqB;AAC9B,SAAS,2BAA2B;AACpC,SAAS,qBAAqB;AAC9B,SAAS,iCAAiC,6BAA6B,gCAAgC,wBAAwB,eAAe,8BAA8B,4BAA4B;AAExM,SAAS,sBAAsB;AAC/B,SAAS,0BAA0B;AACnC,SAAS,uBAAuB;AAChC,SAAS,mBAAmB,uBAAuB,uBAAuB;AAMnE,MAAM,mBAAmB,gBAAkC,iBAAiB;AAC5E,MAAM,gCAAgC,gBAA+C,8BAA8B;AACnH,MAAM,yBAAyB,gBAAwC,uBAAuB;AAC9F,MAAM,wBAAwB,gBAAuC,sBAAsB;AAC3F,MAAM,2BAA2B,gBAA0C,yBAAyB;AAqDpG,IAAW,YAAX,kBAAWA,eAAX;AACN,EAAAA,sBAAA,UAAO,KAAP;AACA,EAAAA,sBAAA,WAAQ,KAAR;AACA,EAAAA,sBAAA,QAAK,KAAL;AACA,EAAAA,sBAAA,UAAO,KAAP;AAJiB,SAAAA;AAAA,GAAA;AA0DX,IAAW,0BAAX,kBAAWC,6BAAX;AACN,EAAAA,kDAAA;AACA,EAAAA,kDAAA;AAFiB,SAAAA;AAAA,GAAA;AAsFX,MAAM,6BAA6B,wBAAC,MAAqF,OAAQ,EAAwB,eAAe,UAArI;AAuInC,MAAM,mCAAmC,WAAW;AAAA,EAlX3D,OAkX2D;AAAA;AAAA;AAE3D;AAwBO,MAAM,mBAAmB;AA4pBzB,IAAW,yBAAX,kBAAWC,4BAAX;AACN,EAAAA,gDAAA,0BAAuB,OAAvB;AADiB,SAAAA;AAAA,GAAA;AAmMX,IAAW,cAAX,kBAAWC,iBAAX;AACN,EAAAA,0BAAA,aAAU,KAAV;AACA,EAAAA,0BAAA,YAAS,KAAT;AACA,EAAAA,0BAAA,YAAS,KAAT;AAHiB,SAAAA;AAAA,GAAA;AAMX,IAAW,wBAAX,kBAAWC,2BAAX;AACN,EAAAA,uBAAA,eAAY;AADK,SAAAA;AAAA,GAAA;",
  "names": ["Direction", "TerminalConnectionState", "XtermTerminalConstants", "LinuxDistro", "TerminalDataTransfers"]
}
