{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/terminal/browser/terminal.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type {\n\tIBufferRange,\n\tIMarker,\n\tITheme,\n\tTerminal as RawXtermTerminal,\n} from \"@xterm/xterm\";\nimport type { IDimension } from \"../../../../base/browser/dom.js\";\nimport type { Orientation } from \"../../../../base/browser/ui/splitview/splitview.js\";\nimport type { Barrier } from \"../../../../base/common/async.js\";\nimport type { Color } from \"../../../../base/common/color.js\";\nimport type {\n\tDynamicListEventMultiplexer,\n\tEvent,\n\tIDynamicListEventMultiplexer,\n} from \"../../../../base/common/event.js\";\nimport type {\n\tDisposableStore,\n\tIDisposable,\n} from \"../../../../base/common/lifecycle.js\";\nimport type { OperatingSystem } from \"../../../../base/common/platform.js\";\nimport type { URI } from \"../../../../base/common/uri.js\";\nimport type { IMenu } from \"../../../../platform/actions/common/actions.js\";\nimport type { IContextKeyService } from \"../../../../platform/contextkey/common/contextkey.js\";\nimport { createDecorator } from \"../../../../platform/instantiation/common/instantiation.js\";\nimport type { IKeyMods } from \"../../../../platform/quickinput/common/quickInput.js\";\nimport type {\n\tIMarkProperties,\n\tITerminalCapabilityImplMap,\n\tITerminalCapabilityStore,\n\tITerminalCommand,\n\tTerminalCapability,\n} from \"../../../../platform/terminal/common/capabilities/capabilities.js\";\nimport type { ICurrentPartialCommand } from \"../../../../platform/terminal/common/capabilities/commandDetection/terminalCommand.js\";\nimport type { IMergedEnvironmentVariableCollection } from \"../../../../platform/terminal/common/environmentVariable.js\";\nimport type {\n\tIExtensionTerminalProfile,\n\tIReconnectionProperties,\n\tIShellIntegration,\n\tIShellLaunchConfig,\n\tITerminalBackend,\n\tITerminalDimensions,\n\tITerminalLaunchError,\n\tITerminalProfile,\n\tITerminalTabLayoutInfoById,\n\tTerminalExitReason,\n\tTerminalIcon,\n\tTerminalLocation,\n\tTerminalShellType,\n\tTerminalType,\n\tTitleEventSource,\n\tWaitOnExitValue,\n} from \"../../../../platform/terminal/common/terminal.js\";\nimport type { IColorTheme } from \"../../../../platform/theme/common/themeService.js\";\nimport type { IWorkspaceFolder } from \"../../../../platform/workspace/common/workspace.js\";\nimport type { GroupIdentifier } from \"../../../common/editor.js\";\nimport type { EditorInput } from \"../../../common/editor/editorInput.js\";\nimport type { IEditableData } from \"../../../common/views.js\";\nimport type {\n\tACTIVE_GROUP_TYPE,\n\tAUX_WINDOW_GROUP_TYPE,\n\tSIDE_GROUP_TYPE,\n} from \"../../../services/editor/common/editorService.js\";\nimport type {\n\tIRegisterContributedProfileArgs,\n\tIRemoteTerminalAttachTarget,\n\tIStartExtensionTerminalRequest,\n\tITerminalConfiguration,\n\tITerminalFont,\n\tITerminalProcessExtHostProxy,\n\tITerminalProcessInfo,\n} from \"../common/terminal.js\";\nimport type { ITerminalStatusList } from \"./terminalStatusList.js\";\nimport type { IXtermCore } from \"./xterm-private.js\";\nimport type { ScrollPosition } from \"./xterm/markNavigationAddon.js\";\nimport type { XtermTerminal } from \"./xterm/xtermTerminal.js\";\n\nexport const ITerminalService =\n\tcreateDecorator<ITerminalService>(\"terminalService\");\nexport const ITerminalConfigurationService =\n\tcreateDecorator<ITerminalConfigurationService>(\n\t\t\"terminalConfigurationService\",\n\t);\nexport const ITerminalEditorService = createDecorator<ITerminalEditorService>(\n\t\"terminalEditorService\",\n);\nexport const ITerminalGroupService = createDecorator<ITerminalGroupService>(\n\t\"terminalGroupService\",\n);\nexport const ITerminalInstanceService =\n\tcreateDecorator<ITerminalInstanceService>(\"terminalInstanceService\");\n\n/**\n * A terminal contribution that gets created whenever a terminal is created. A contribution has\n * access to the process manager through the constructor and provides a method for when xterm.js has\n * been initialized.\n */\nexport interface ITerminalContribution extends IDisposable {\n\tlayout?(\n\t\txterm: IXtermTerminal & { raw: RawXtermTerminal },\n\t\tdimension: IDimension,\n\t): void;\n\txtermOpen?(xterm: IXtermTerminal & { raw: RawXtermTerminal }): void;\n\txtermReady?(xterm: IXtermTerminal & { raw: RawXtermTerminal }): void;\n}\n\n/**\n * A service used to create instances or fetch backends, this services allows services that\n * ITerminalService depends on to also create instances.\n *\n * **This service is intended to only be used within the terminal contrib.**\n */\nexport interface ITerminalInstanceService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * An event that's fired when a terminal instance is created.\n\t */\n\tonDidCreateInstance: Event<ITerminalInstance>;\n\n\t/**\n\t * Helper function to convert a shell launch config, a profile or undefined into its equivalent\n\t * shell launch config.\n\t * @param shellLaunchConfigOrProfile A shell launch config, a profile or undefined\n\t * @param cwd A cwd to override.\n\t */\n\tconvertProfileToShellLaunchConfig(\n\t\tshellLaunchConfigOrProfile?: IShellLaunchConfig | ITerminalProfile,\n\t\tcwd?: string | URI,\n\t): IShellLaunchConfig;\n\n\t/**\n\t * Create a new terminal instance.\n\t * @param launchConfig The shell launch config.\n\t * @param target The target of the terminal.\n\t */\n\tcreateInstance(\n\t\tlaunchConfig: IShellLaunchConfig,\n\t\ttarget: TerminalLocation,\n\t): ITerminalInstance;\n\n\t/**\n\t * Gets the registered backend for a remote authority (undefined = local). This is a convenience\n\t * method to avoid using the more verbose fetching from the registry.\n\t * @param remoteAuthority The remote authority of the backend.\n\t */\n\tgetBackend(remoteAuthority?: string): Promise<ITerminalBackend | undefined>;\n\n\tgetRegisteredBackends(): IterableIterator<ITerminalBackend>;\n\tdidRegisterBackend(remoteAuthority?: string): void;\n}\n\nexport enum Direction {\n\tLeft = 0,\n\tRight = 1,\n\tUp = 2,\n\tDown = 3,\n}\n\nexport interface IQuickPickTerminalObject {\n\tconfig:\n\t\t| IRegisterContributedProfileArgs\n\t\t| ITerminalProfile\n\t\t| {\n\t\t\t\tprofile: IExtensionTerminalProfile;\n\t\t\t\toptions: { icon?: string; color?: string };\n\t\t  }\n\t\t| undefined;\n\tkeyMods: IKeyMods | undefined;\n}\n\nexport interface IMarkTracker {\n\tscrollToPreviousMark(\n\t\tscrollPosition?: ScrollPosition,\n\t\tretainSelection?: boolean,\n\t\tskipEmptyCommands?: boolean,\n\t): void;\n\tscrollToNextMark(): void;\n\tselectToPreviousMark(): void;\n\tselectToNextMark(): void;\n\tselectToPreviousLine(): void;\n\tselectToNextLine(): void;\n\tclear(): void;\n\tscrollToClosestMarker(\n\t\tstartMarkerId: string,\n\t\tendMarkerId?: string,\n\t\thighlight?: boolean | undefined,\n\t): void;\n\n\tscrollToLine(line: number, position: ScrollPosition): void;\n\trevealCommand(\n\t\tcommand: ITerminalCommand | ICurrentPartialCommand,\n\t\tposition?: ScrollPosition,\n\t): void;\n\trevealRange(range: IBufferRange): void;\n\tregisterTemporaryDecoration(\n\t\tmarker: IMarker,\n\t\tendMarker: IMarker | undefined,\n\t\tshowOutline: boolean,\n\t): void;\n\tshowCommandGuide(command: ITerminalCommand | undefined): void;\n\n\tsaveScrollState(): void;\n\trestoreScrollState(): void;\n}\n\nexport interface ITerminalGroup {\n\tactiveInstance: ITerminalInstance | undefined;\n\tterminalInstances: ITerminalInstance[];\n\ttitle: string;\n\n\treadonly onDidDisposeInstance: Event<ITerminalInstance>;\n\treadonly onDisposed: Event<ITerminalGroup>;\n\treadonly onInstancesChanged: Event<void>;\n\treadonly onPanelOrientationChanged: Event<Orientation>;\n\n\tfocusPreviousPane(): void;\n\tfocusNextPane(): void;\n\tresizePane(direction: Direction): void;\n\tresizePanes(relativeSizes: number[]): void;\n\tsetActiveInstanceByIndex(index: number, force?: boolean): void;\n\tattachToElement(element: HTMLElement): void;\n\taddInstance(instance: ITerminalInstance): void;\n\tremoveInstance(instance: ITerminalInstance): void;\n\tmoveInstance(\n\t\tinstances: ITerminalInstance | ITerminalInstance[],\n\t\tindex: number,\n\t\tposition: \"before\" | \"after\",\n\t): void;\n\tsetVisible(visible: boolean): void;\n\tlayout(width: number, height: number): void;\n\taddDisposable(disposable: IDisposable): void;\n\tsplit(shellLaunchConfig: IShellLaunchConfig): ITerminalInstance;\n\tgetLayoutInfo(isActive: boolean): ITerminalTabLayoutInfoById;\n}\n\nexport enum TerminalConnectionState {\n\tConnecting = 0,\n\tConnected = 1,\n}\n\nexport interface IDetachedXTermOptions {\n\tcols: number;\n\trows: number;\n\tcolorProvider: IXtermColorProvider;\n\tcapabilities?: ITerminalCapabilityStore;\n\treadonly?: boolean;\n\tprocessInfo: ITerminalProcessInfo;\n}\n\n/**\n * A generic interface implemented in both the {@link ITerminalInstance} (an\n * interface used for terminals attached to the terminal panel or editor) and\n * {@link IDetachedTerminalInstance} (a terminal used elsewhere in VS Code UI).\n */\nexport interface IBaseTerminalInstance {\n\treadonly capabilities: ITerminalCapabilityStore;\n\n\t/**\n\t * DOM element the terminal is mounted in.\n\t */\n\treadonly domElement?: HTMLElement;\n\n\t/**\n\t * Current selection in the terminal.\n\t */\n\treadonly selection: string | undefined;\n\n\t/**\n\t * Check if anything is selected in terminal.\n\t */\n\thasSelection(): boolean;\n\n\t/**\n\t * Clear current selection.\n\t */\n\tclearSelection(): void;\n\n\t/**\n\t * Focuses the terminal instance if it's able to (the xterm.js instance must exist).\n\t *\n\t * @param force Force focus even if there is a selection.\n\t */\n\tfocus(force?: boolean): void;\n\n\t/**\n\t * Force the scroll bar to be visible until {@link resetScrollbarVisibility} is called.\n\t */\n\tforceScrollbarVisibility(): void;\n\n\t/**\n\t * Resets the scroll bar to only be visible when needed, this does nothing unless\n\t * {@link forceScrollbarVisibility} was called.\n\t */\n\tresetScrollbarVisibility(): void;\n\n\t/**\n\t * Gets a terminal contribution by its ID.\n\t */\n\tgetContribution<T extends ITerminalContribution>(id: string): T | null;\n}\n\n/**\n * A {@link ITerminalInstance}-like object that emulates a subset of\n * capabilities. This instance is returned from {@link ITerminalService.createDetachedTerminal}\n * to represent terminals that appear in other parts of the VS Code UI outside\n * of the \"Terminal\" view or editors.\n */\nexport interface IDetachedTerminalInstance\n\textends IDisposable,\n\t\tIBaseTerminalInstance {\n\treadonly xterm: IDetachedXtermTerminal;\n\n\t/**\n\t * Attached the terminal to the given element. This should be preferred over\n\t * calling {@link IXtermTerminal.attachToElement} so that extra DOM elements\n\t * for contributions are initialized.\n\t *\n\t * @param container Container the terminal will be rendered in\n\t * @param options Additional options for mounting the terminal in an element\n\t */\n\tattachToElement(\n\t\tcontainer: HTMLElement,\n\t\toptions?: Partial<IXtermAttachToElementOptions>,\n\t): void;\n}\n\nexport const isDetachedTerminalInstance = (\n\tt: ITerminalInstance | IDetachedTerminalInstance,\n): t is IDetachedTerminalInstance =>\n\ttypeof (t as ITerminalInstance).instanceId !== \"number\";\n\nexport interface ITerminalService extends ITerminalInstanceHost {\n\treadonly _serviceBrand: undefined;\n\n\t/** Gets all terminal instances, including editor and terminal view (group) instances. */\n\treadonly instances: readonly ITerminalInstance[];\n\t/** Gets detached terminal instances created via {@link createDetachedXterm}. */\n\treadonly detachedInstances: Iterable<IDetachedTerminalInstance>;\n\treadonly defaultLocation: TerminalLocation;\n\n\treadonly isProcessSupportRegistered: boolean;\n\treadonly connectionState: TerminalConnectionState;\n\treadonly whenConnected: Promise<void>;\n\t/** The number of restored terminal groups on startup. */\n\treadonly restoredGroupCount: number;\n\n\treadonly onDidCreateInstance: Event<ITerminalInstance>;\n\treadonly onDidChangeInstanceDimensions: Event<ITerminalInstance>;\n\treadonly onDidRequestStartExtensionTerminal: Event<IStartExtensionTerminalRequest>;\n\treadonly onDidRegisterProcessSupport: Event<void>;\n\treadonly onDidChangeConnectionState: Event<void>;\n\n\t// Group events\n\treadonly onDidChangeActiveGroup: Event<ITerminalGroup | undefined>;\n\n\t// Multiplexed events\n\treadonly onAnyInstanceData: Event<{\n\t\tinstance: ITerminalInstance;\n\t\tdata: string;\n\t}>;\n\treadonly onAnyInstanceDataInput: Event<ITerminalInstance>;\n\treadonly onAnyInstanceIconChange: Event<{\n\t\tinstance: ITerminalInstance;\n\t\tuserInitiated: boolean;\n\t}>;\n\treadonly onAnyInstanceMaximumDimensionsChange: Event<ITerminalInstance>;\n\treadonly onAnyInstancePrimaryStatusChange: Event<ITerminalInstance>;\n\treadonly onAnyInstanceProcessIdReady: Event<ITerminalInstance>;\n\treadonly onAnyInstanceSelectionChange: Event<ITerminalInstance>;\n\treadonly onAnyInstanceTitleChange: Event<ITerminalInstance>;\n\n\t/**\n\t * Creates a terminal.\n\t * @param options The options to create the terminal with, when not specified the default\n\t * profile will be used at the default target.\n\t */\n\tcreateTerminal(\n\t\toptions?: ICreateTerminalOptions,\n\t): Promise<ITerminalInstance>;\n\n\t/**\n\t * Creates a detached xterm instance which is not attached to the DOM or\n\t * tracked as a terminal instance.\n\t * @params options The options to create the terminal with\n\t */\n\tcreateDetachedTerminal(\n\t\toptions: IDetachedXTermOptions,\n\t): Promise<IDetachedTerminalInstance>;\n\n\t/**\n\t * Creates a raw terminal instance, this should not be used outside of the terminal part.\n\t */\n\tgetInstanceFromId(terminalId: number): ITerminalInstance | undefined;\n\tgetInstanceFromIndex(terminalIndex: number): ITerminalInstance;\n\n\t/**\n\t * An owner of terminals might be created after reconnection has occurred,\n\t * so store them to be requested/adopted later\n\t */\n\tgetReconnectedTerminals(\n\t\treconnectionOwner: string,\n\t): ITerminalInstance[] | undefined;\n\n\tgetActiveOrCreateInstance(options?: {\n\t\tacceptsInput?: boolean;\n\t}): Promise<ITerminalInstance>;\n\trevealTerminal(\n\t\tsource: ITerminalInstance,\n\t\tpreserveFocus?: boolean,\n\t): Promise<void>;\n\trevealActiveTerminal(preserveFocus?: boolean): Promise<void>;\n\tmoveToEditor(\n\t\tsource: ITerminalInstance,\n\t\tgroup?:\n\t\t\t| GroupIdentifier\n\t\t\t| SIDE_GROUP_TYPE\n\t\t\t| ACTIVE_GROUP_TYPE\n\t\t\t| AUX_WINDOW_GROUP_TYPE,\n\t): void;\n\tmoveIntoNewEditor(source: ITerminalInstance): void;\n\tmoveToTerminalView(source: ITerminalInstance | URI): Promise<void>;\n\tgetPrimaryBackend(): ITerminalBackend | undefined;\n\n\t/**\n\t * Fire the onActiveTabChanged event, this will trigger the terminal dropdown to be updated,\n\t * among other things.\n\t */\n\trefreshActiveGroup(): void;\n\n\tregisterProcessSupport(isSupported: boolean): void;\n\n\tshowProfileQuickPick(\n\t\ttype: \"setDefault\" | \"createInstance\",\n\t\tcwd?: string | URI,\n\t): Promise<ITerminalInstance | undefined>;\n\n\tsetContainers(\n\t\tpanelContainer: HTMLElement,\n\t\tterminalContainer: HTMLElement,\n\t): void;\n\n\trequestStartExtensionTerminal(\n\t\tproxy: ITerminalProcessExtHostProxy,\n\t\tcols: number,\n\t\trows: number,\n\t): Promise<ITerminalLaunchError | undefined>;\n\tisAttachedToTerminal(remoteTerm: IRemoteTerminalAttachTarget): boolean;\n\tgetEditableData(instance: ITerminalInstance): IEditableData | undefined;\n\tsetEditable(instance: ITerminalInstance, data: IEditableData | null): void;\n\tisEditable(instance: ITerminalInstance | undefined): boolean;\n\tsafeDisposeTerminal(instance: ITerminalInstance): Promise<void>;\n\n\tgetDefaultInstanceHost(): ITerminalInstanceHost;\n\tgetInstanceHost(\n\t\ttarget: ITerminalLocationOptions | undefined,\n\t): Promise<ITerminalInstanceHost>;\n\n\tresolveLocation(\n\t\tlocation?: ITerminalLocationOptions,\n\t): Promise<TerminalLocation | undefined>;\n\tsetNativeDelegate(nativeCalls: ITerminalServiceNativeDelegate): void;\n\n\tgetEditingTerminal(): ITerminalInstance | undefined;\n\tsetEditingTerminal(instance: ITerminalInstance | undefined): void;\n\n\t/**\n\t * Creates an instance event listener that listens to all instances, dynamically adding new\n\t * instances and removing old instances as needed.\n\t * @param getEvent Maps the instance to the event.\n\t */\n\tcreateOnInstanceEvent<T>(\n\t\tgetEvent: (instance: ITerminalInstance) => Event<T>,\n\t): DynamicListEventMultiplexer<ITerminalInstance, T>;\n\n\t/**\n\t * Creates a capability event listener that listens to capabilities on all instances,\n\t * dynamically adding and removing instances and capabilities as needed.\n\t * @param capabilityId The capability type to listen to an event on.\n\t * @param getEvent Maps the capability to the event.\n\t */\n\tcreateOnInstanceCapabilityEvent<T extends TerminalCapability, K>(\n\t\tcapabilityId: T,\n\t\tgetEvent: (capability: ITerminalCapabilityImplMap[T]) => Event<K>,\n\t): IDynamicListEventMultiplexer<{ instance: ITerminalInstance; data: K }>;\n}\n\n/**\n * A service that provides convenient access to the terminal configuration and derived values.\n */\nexport interface ITerminalConfigurationService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * A typed and partially validated representation of the terminal configuration.\n\t */\n\treadonly config: Readonly<ITerminalConfiguration>;\n\n\t/**\n\t * Fires when something within the terminal configuration changes.\n\t */\n\treadonly onConfigChanged: Event<void>;\n\n\tsetPanelContainer(panelContainer: HTMLElement): void;\n\tconfigFontIsMonospace(): boolean;\n\tgetFont(\n\t\tw: Window,\n\t\txtermCore?: IXtermCore,\n\t\texcludeDimensions?: boolean,\n\t): ITerminalFont;\n}\n\nexport class TerminalLinkQuickPickEvent extends MouseEvent {}\nexport interface ITerminalServiceNativeDelegate {\n\tgetWindowCount(): Promise<number>;\n}\n\n/**\n * This service is responsible for integrating with the editor service and managing terminal\n * editors.\n */\nexport interface ITerminalEditorService extends ITerminalInstanceHost {\n\treadonly _serviceBrand: undefined;\n\n\t/** Gets all _terminal editor_ instances. */\n\treadonly instances: readonly ITerminalInstance[];\n\n\topenEditor(\n\t\tinstance: ITerminalInstance,\n\t\teditorOptions?: TerminalEditorLocation,\n\t): Promise<void>;\n\tdetachInstance(instance: ITerminalInstance): void;\n\tsplitInstance(\n\t\tinstanceToSplit: ITerminalInstance,\n\t\tshellLaunchConfig?: IShellLaunchConfig,\n\t): ITerminalInstance;\n\trevealActiveEditor(preserveFocus?: boolean): Promise<void>;\n\tresolveResource(instance: ITerminalInstance): URI;\n\treviveInput(\n\t\tdeserializedInput: IDeserializedTerminalEditorInput,\n\t): EditorInput;\n\tgetInputFromResource(resource: URI): EditorInput;\n}\n\nexport const terminalEditorId = \"terminalEditor\";\n\ninterface ITerminalEditorInputObject {\n\treadonly id: number;\n\treadonly pid: number;\n\treadonly title: string;\n\treadonly titleSource: TitleEventSource;\n\treadonly cwd: string;\n\treadonly icon: TerminalIcon | undefined;\n\treadonly color: string | undefined;\n\treadonly hasChildProcesses?: boolean;\n\treadonly type?: TerminalType;\n\treadonly isFeatureTerminal?: boolean;\n\treadonly hideFromUser?: boolean;\n\treadonly reconnectionProperties?: IReconnectionProperties;\n\treadonly shellIntegrationNonce: string;\n}\n\nexport interface ISerializedTerminalEditorInput\n\textends ITerminalEditorInputObject {}\n\nexport interface IDeserializedTerminalEditorInput\n\textends ITerminalEditorInputObject {}\n\nexport type ITerminalLocationOptions =\n\t| TerminalLocation\n\t| TerminalEditorLocation\n\t| { parentTerminal: Promise<ITerminalInstance> | ITerminalInstance }\n\t| { splitActiveTerminal: boolean };\n\nexport interface ICreateTerminalOptions {\n\t/**\n\t * The shell launch config or profile to launch with, when not specified the default terminal\n\t * profile will be used.\n\t */\n\tconfig?: IShellLaunchConfig | ITerminalProfile | IExtensionTerminalProfile;\n\t/**\n\t * The current working directory to start with, this will override IShellLaunchConfig.cwd if\n\t * specified.\n\t */\n\tcwd?: string | URI;\n\t/**\n\t * The terminal's resource, passed when the terminal has moved windows.\n\t */\n\tresource?: URI;\n\n\t/**\n\t * The terminal's location (editor or panel), it's terminal parent (split to the right), or editor group\n\t */\n\tlocation?: ITerminalLocationOptions;\n\n\t/**\n\t * This terminal will not wait for contributed profiles to resolve which means it will proceed\n\t * when the workbench is not yet loaded.\n\t */\n\tskipContributedProfileCheck?: boolean;\n}\n\nexport interface TerminalEditorLocation {\n\tviewColumn:\n\t\t| GroupIdentifier\n\t\t| SIDE_GROUP_TYPE\n\t\t| ACTIVE_GROUP_TYPE\n\t\t| AUX_WINDOW_GROUP_TYPE;\n\tpreserveFocus?: boolean;\n}\n\n/**\n * This service is responsible for managing terminal groups, that is the terminals that are hosted\n * within the terminal panel, not in an editor.\n */\nexport interface ITerminalGroupService extends ITerminalInstanceHost {\n\treadonly _serviceBrand: undefined;\n\n\t/** Gets all _terminal view_ instances, ie. instances contained within terminal groups. */\n\treadonly instances: readonly ITerminalInstance[];\n\treadonly groups: readonly ITerminalGroup[];\n\tactiveGroup: ITerminalGroup | undefined;\n\treadonly activeGroupIndex: number;\n\t/**\n\t * Gets or sets the last accessed menu, this is used to select the instance(s) for menu actions.\n\t */\n\tlastAccessedMenu: \"inline-tab\" | \"tab-list\";\n\n\treadonly onDidChangeActiveGroup: Event<ITerminalGroup | undefined>;\n\treadonly onDidDisposeGroup: Event<ITerminalGroup>;\n\t/** Fires when a group is created, disposed of, or shown (in the case of a background group). */\n\treadonly onDidChangeGroups: Event<void>;\n\t/** Fires when the panel has been shown and expanded, so has non-zero dimensions. */\n\treadonly onDidShow: Event<void>;\n\treadonly onDidChangePanelOrientation: Event<Orientation>;\n\n\tcreateGroup(shellLaunchConfig?: IShellLaunchConfig): ITerminalGroup;\n\tcreateGroup(instance?: ITerminalInstance): ITerminalGroup;\n\tgetGroupForInstance(\n\t\tinstance: ITerminalInstance,\n\t): ITerminalGroup | undefined;\n\n\t/**\n\t * Moves a terminal instance's group to the target instance group's position.\n\t * @param source The source instance to move.\n\t * @param target The target instance to move the source instance to.\n\t */\n\tmoveGroup(\n\t\tsource: ITerminalInstance | ITerminalInstance[],\n\t\ttarget: ITerminalInstance,\n\t): void;\n\tmoveGroupToEnd(source: ITerminalInstance | ITerminalInstance[]): void;\n\n\tmoveInstance(\n\t\tsource: ITerminalInstance,\n\t\ttarget: ITerminalInstance,\n\t\tside: \"before\" | \"after\",\n\t): void;\n\tunsplitInstance(instance: ITerminalInstance): void;\n\tjoinInstances(instances: ITerminalInstance[]): void;\n\tinstanceIsSplit(instance: ITerminalInstance): boolean;\n\n\tgetGroupLabels(): string[];\n\tsetActiveGroupByIndex(index: number): void;\n\tsetActiveGroupToNext(): void;\n\tsetActiveGroupToPrevious(): void;\n\n\tsetActiveInstanceByIndex(terminalIndex: number): void;\n\n\tsetContainer(container: HTMLElement): void;\n\n\tshowPanel(focus?: boolean): Promise<void>;\n\thidePanel(): void;\n\tfocusTabs(): void;\n\tfocusHover(): void;\n\tupdateVisibility(): void;\n}\n\n/**\n * An interface that indicates the implementer hosts terminal instances, exposing a common set of\n * properties and events.\n */\nexport interface ITerminalInstanceHost {\n\treadonly activeInstance: ITerminalInstance | undefined;\n\treadonly instances: readonly ITerminalInstance[];\n\n\treadonly onDidDisposeInstance: Event<ITerminalInstance>;\n\treadonly onDidFocusInstance: Event<ITerminalInstance>;\n\treadonly onDidChangeActiveInstance: Event<ITerminalInstance | undefined>;\n\treadonly onDidChangeInstances: Event<void>;\n\treadonly onDidChangeInstanceCapability: Event<ITerminalInstance>;\n\n\tsetActiveInstance(instance: ITerminalInstance): void;\n\t/**\n\t * Reveal and focus the instance, regardless of its location.\n\t */\n\tfocusInstance(instance: ITerminalInstance): void;\n\t/**\n\t * Reveal and focus the active instance, regardless of its location.\n\t */\n\tfocusActiveInstance(): Promise<void>;\n\t/**\n\t * Gets an instance from a resource if it exists. This MUST be used instead of getInstanceFromId\n\t * when you only know about a terminal's URI. (a URI's instance ID may not be this window's instance ID)\n\t */\n\tgetInstanceFromResource(\n\t\tresource: URI | undefined,\n\t): ITerminalInstance | undefined;\n}\n\n/**\n * Similar to xterm.js' ILinkProvider but using promises and hides xterm.js internals (like buffer\n * positions, decorations, etc.) from the rest of vscode. This is the interface to use for\n * workbench integrations.\n */\nexport interface ITerminalExternalLinkProvider {\n\tprovideLinks(\n\t\tinstance: ITerminalInstance,\n\t\tline: string,\n\t): Promise<ITerminalLink[] | undefined>;\n}\n\nexport interface ITerminalLink {\n\t/** The startIndex of the link in the line. */\n\tstartIndex: number;\n\t/** The length of the link in the line. */\n\tlength: number;\n\t/** The descriptive label for what the link does when activated. */\n\tlabel?: string;\n\t/**\n\t * Activates the link.\n\t * @param text The text of the link.\n\t */\n\tactivate(text: string): void;\n}\n\nexport interface ISearchOptions {\n\t/** Whether the find should be done as a regex. */\n\tregex?: boolean;\n\t/** Whether only whole words should match. */\n\twholeWord?: boolean;\n\t/** Whether find should pay attention to case. */\n\tcaseSensitive?: boolean;\n\t/** Whether the search should start at the current search position (not the next row). */\n\tincremental?: boolean;\n}\n\nexport interface ITerminalInstance extends IBaseTerminalInstance {\n\t/**\n\t * The ID of the terminal instance, this is an arbitrary number only used to uniquely identify\n\t * terminal instances within a window.\n\t */\n\treadonly instanceId: number;\n\t/**\n\t * A unique URI for this terminal instance with the following encoding:\n\t * path: /<workspace ID>/<instance ID>\n\t * fragment: Title\n\t * Note that when dragging terminals across windows, this will retain the original workspace ID /instance ID\n\t * from the other window.\n\t */\n\treadonly resource: URI;\n\n\treadonly cols: number;\n\treadonly rows: number;\n\treadonly maxCols: number;\n\treadonly maxRows: number;\n\treadonly fixedCols?: number;\n\treadonly fixedRows?: number;\n\treadonly domElement: HTMLElement;\n\treadonly icon?: TerminalIcon;\n\treadonly color?: string;\n\treadonly reconnectionProperties?: IReconnectionProperties;\n\treadonly processName: string;\n\treadonly sequence?: string;\n\treadonly staticTitle?: string;\n\treadonly workspaceFolder?: IWorkspaceFolder;\n\treadonly cwd?: string;\n\treadonly initialCwd?: string;\n\treadonly os?: OperatingSystem;\n\treadonly usedShellIntegrationInjection: boolean;\n\treadonly injectedArgs: string[] | undefined;\n\treadonly extEnvironmentVariableCollection:\n\t\t| IMergedEnvironmentVariableCollection\n\t\t| undefined;\n\n\t/**\n\t * The underlying disposable store, allowing objects who share the same lifecycle as the\n\t * terminal instance but are created externally to be managed by the instance.\n\t */\n\treadonly store: DisposableStore;\n\n\treadonly statusList: ITerminalStatusList;\n\n\t/**\n\t * The process ID of the shell process, this is undefined when there is no process associated\n\t * with this terminal.\n\t */\n\tprocessId: number | undefined;\n\n\t/**\n\t * The position of the terminal.\n\t */\n\ttarget?: TerminalLocation;\n\n\t/**\n\t * The id of a persistent process. This is defined if this is a terminal created by a pty host\n\t * that supports reconnection.\n\t */\n\treadonly persistentProcessId: number | undefined;\n\n\t/**\n\t * Whether the process should be persisted across reloads.\n\t */\n\treadonly shouldPersist: boolean;\n\n\t/*\n\t * Whether this terminal has been disposed of\n\t */\n\treadonly isDisposed: boolean;\n\n\t/**\n\t * Whether the terminal's pty is hosted on a remote.\n\t */\n\treadonly isRemote: boolean;\n\n\t/**\n\t * The remote authority of the terminal's pty.\n\t */\n\treadonly remoteAuthority: string | undefined;\n\n\t/**\n\t * Whether an element within this terminal is focused.\n\t */\n\treadonly hasFocus: boolean;\n\n\t/**\n\t * Get or set the behavior of the terminal when it closes. This was indented only to be called\n\t * after reconnecting to a terminal.\n\t */\n\twaitOnExit: WaitOnExitValue | undefined;\n\n\t/**\n\t * An event that fires when the terminal instance's title changes.\n\t */\n\tonTitleChanged: Event<ITerminalInstance>;\n\n\t/**\n\t * An event that fires when the terminal instance's icon changes.\n\t */\n\tonIconChanged: Event<{\n\t\tinstance: ITerminalInstance;\n\t\tuserInitiated: boolean;\n\t}>;\n\n\t/**\n\t * An event that fires when the terminal instance is disposed.\n\t */\n\tonDisposed: Event<ITerminalInstance>;\n\n\tonProcessIdReady: Event<ITerminalInstance>;\n\tonProcessReplayComplete: Event<void>;\n\tonRequestExtHostProcess: Event<ITerminalInstance>;\n\tonDimensionsChanged: Event<void>;\n\tonMaximumDimensionsChanged: Event<void>;\n\tonDidChangeHasChildProcesses: Event<boolean>;\n\n\tonDidFocus: Event<ITerminalInstance>;\n\tonDidRequestFocus: Event<void>;\n\tonDidBlur: Event<ITerminalInstance>;\n\tonDidInputData: Event<string>;\n\tonDidChangeSelection: Event<ITerminalInstance>;\n\tonDidExecuteText: Event<void>;\n\tonDidChangeTarget: Event<TerminalLocation | undefined>;\n\tonDidSendText: Event<string>;\n\tonDidChangeShellType: Event<TerminalShellType>;\n\tonDidChangeVisibility: Event<boolean>;\n\n\tonWillPaste: Event<string>;\n\tonDidPaste: Event<string>;\n\n\t/**\n\t * An event that fires when a terminal is dropped on this instance via drag and drop.\n\t */\n\tonRequestAddInstanceToGroup: Event<IRequestAddInstanceToGroupEvent>;\n\n\t/**\n\t * Attach a listener to the raw data stream coming from the pty, including ANSI escape\n\t * sequences.\n\t */\n\tonData: Event<string>;\n\tonWillData: Event<string>;\n\n\t/**\n\t * Attach a listener to the binary data stream coming from xterm and going to pty\n\t */\n\tonBinary: Event<string>;\n\n\t/**\n\t * Attach a listener to listen for new lines added to this terminal instance.\n\t *\n\t * @param listener The listener function which takes new line strings added to the terminal,\n\t * excluding ANSI escape sequences. The line event will fire when an LF character is added to\n\t * the terminal (ie. the line is not wrapped). Note that this means that the line data will\n\t * not fire for the last line, until either the line is ended with a LF character of the process\n\t * is exited. The lineData string will contain the fully wrapped line, not containing any LF/CR\n\t * characters.\n\t */\n\tonLineData: Event<string>;\n\n\t/**\n\t * Attach a listener that fires when the terminal's pty process exits. The number in the event\n\t * is the processes' exit code, an exit code of undefined means the process was killed as a result of\n\t * the ITerminalInstance being disposed.\n\t */\n\tonExit: Event<number | ITerminalLaunchError | undefined>;\n\n\t/**\n\t * The exit code or undefined when the terminal process hasn't yet exited or\n\t * the process exit code could not be determined. Use {@link exitReason} to see\n\t * why the process has exited.\n\t */\n\treadonly exitCode: number | undefined;\n\n\t/**\n\t * The reason the terminal process exited, this will be undefined if the process is still\n\t * running.\n\t */\n\treadonly exitReason: TerminalExitReason | undefined;\n\n\t/**\n\t * The xterm.js instance for this terminal.\n\t */\n\treadonly xterm?: XtermTerminal;\n\n\t/**\n\t * Returns an array of data events that have fired within the first 10 seconds. If this is\n\t * called 10 seconds after the terminal has existed the result will be undefined. This is useful\n\t * when objects that depend on the data events have delayed initialization, like extension\n\t * hosts.\n\t */\n\treadonly initialDataEvents: string[] | undefined;\n\n\t/** A promise that resolves when the terminal's pty/process have been created. */\n\treadonly processReady: Promise<void>;\n\n\t/** Whether the terminal's process has child processes (ie. is dirty/busy). */\n\treadonly hasChildProcesses: boolean;\n\n\t/**\n\t * The title of the terminal. This is either title or the process currently running or an\n\t * explicit name given to the terminal instance through the extension API.\n\t */\n\treadonly title: string;\n\n\t/**\n\t * How the current title was set.\n\t */\n\treadonly titleSource: TitleEventSource;\n\n\t/**\n\t * The shell type of the terminal.\n\t */\n\treadonly shellType: TerminalShellType | undefined;\n\n\t/**\n\t * The focus state of the terminal before exiting.\n\t */\n\treadonly hadFocusOnExit: boolean;\n\n\t/**\n\t * False when the title is set by an API or the user. We check this to make sure we\n\t * do not override the title when the process title changes in the terminal.\n\t */\n\tisTitleSetByProcess: boolean;\n\n\t/**\n\t * The shell launch config used to launch the shell.\n\t */\n\treadonly shellLaunchConfig: IShellLaunchConfig;\n\n\t/**\n\t * Whether to disable layout for the terminal. This is useful when the size of the terminal is\n\t * being manipulating (e.g. adding a split pane) and we want the terminal to ignore particular\n\t * resize events.\n\t */\n\tdisableLayout: boolean;\n\n\t/**\n\t * The description of the terminal, this is typically displayed next to {@link title}.\n\t */\n\tdescription: string | undefined;\n\n\t/**\n\t * The remote-aware $HOME directory (or Windows equivalent) of the terminal.\n\t */\n\tuserHome: string | undefined;\n\n\t/**\n\t * The nonce used to verify commands coming from shell integration.\n\t */\n\tshellIntegrationNonce: string;\n\n\t/**\n\t * Registers and returns a marker\n\t * @param the y offset from the cursor\n\t */\n\tregisterMarker(offset?: number): IMarker | undefined;\n\n\t/**\n\t * Adds a marker to the buffer, mapping it to an ID if provided.\n\t */\n\taddBufferMarker(properties: IMarkProperties): void;\n\n\t/**\n\t *\n\t * @param startMarkId The ID for the start marker\n\t * @param endMarkId The ID for the end marker\n\t * @param highlight Whether the buffer from startMarker to endMarker\n\t * should be highlighted\n\t */\n\tscrollToMark(\n\t\tstartMarkId: string,\n\t\tendMarkId?: string,\n\t\thighlight?: boolean,\n\t): void;\n\n\t/**\n\t * Dispose the terminal instance, removing it from the panel/service and freeing up resources.\n\t *\n\t * @param reason The reason why the terminal is being disposed\n\t */\n\tdispose(reason?: TerminalExitReason): void;\n\n\t/**\n\t * Informs the process that the terminal is now detached and\n\t * then disposes the terminal.\n\t *\n\t * @param reason The reason why the terminal is being disposed\n\t */\n\tdetachProcessAndDispose(reason: TerminalExitReason): Promise<void>;\n\n\t/**\n\t * Copies the terminal selection to the clipboard.\n\t */\n\tcopySelection(asHtml?: boolean, command?: ITerminalCommand): Promise<void>;\n\n\t/**\n\t * When the panel is hidden or a terminal in the editor area becomes inactive, reset the focus context key\n\t * to avoid issues like #147180.\n\t */\n\tresetFocusContextKey(): void;\n\n\t/**\n\t * Focuses the terminal instance when it's ready (the xterm.js instance much exist). This is the\n\t * best focus call when the terminal is being shown for example.\n\t * when the terminal is being shown.\n\t *\n\t * @param force Force focus even if there is a selection.\n\t */\n\tfocusWhenReady(force?: boolean): Promise<void>;\n\n\t/**\n\t * Focuses and pastes the contents of the clipboard into the terminal instance.\n\t */\n\tpaste(): Promise<void>;\n\n\t/**\n\t * Focuses and pastes the contents of the selection clipboard into the terminal instance.\n\t */\n\tpasteSelection(): Promise<void>;\n\n\t/**\n\t * Override the copy on selection feature with a custom value.\n\t * @param value Whether to enable copySelection.\n\t */\n\toverrideCopyOnSelection(value: boolean): IDisposable;\n\n\t/**\n\t * Send text to the terminal instance. The text is written to the stdin of the underlying pty\n\t * process (shell) of the terminal instance.\n\t *\n\t * @param text The text to send.\n\t * @param shouldExecute Indicates that the text being sent should be executed rather than just inserted in the terminal.\n\t * The character(s) added are \\n or \\r\\n, depending on the platform. This defaults to `true`.\n\t * @param bracketedPasteMode Whether to wrap the text in the bracketed paste mode sequence when\n\t * it's enabled. When true, the shell will treat the text as if it were pasted into the shell,\n\t * this may for example select the text and it will also ensure that the text will not be\n\t * interpreted as a shell keybinding.\n\t */\n\tsendText(\n\t\ttext: string,\n\t\tshouldExecute: boolean,\n\t\tbracketedPasteMode?: boolean,\n\t): Promise<void>;\n\n\t/**\n\t * Sends a path to the terminal instance, preparing it as needed based on the detected shell\n\t * running within the terminal. The text is written to the stdin of the underlying pty process\n\t * (shell) of the terminal instance.\n\t *\n\t * @param originalPath The path to send.\n\t * @param shouldExecute Indicates that the text being sent should be executed rather than just inserted in the terminal.\n\t * The character(s) added are \\n or \\r\\n, depending on the platform. This defaults to `true`.\n\t */\n\tsendPath(originalPath: string | URI, shouldExecute: boolean): Promise<void>;\n\n\trunCommand(command: string, shouldExecute?: boolean): void;\n\n\t/**\n\t * Takes a path and returns the properly escaped path to send to a given shell. On Windows, this\n\t * includes trying to prepare the path for WSL if needed.\n\t *\n\t * @param originalPath The path to be escaped and formatted.\n\t */\n\tpreparePathForShell(originalPath: string): Promise<string>;\n\n\t/** Scroll the terminal buffer down 1 line. */ scrollDownLine(): void;\n\t/** Scroll the terminal buffer down 1 page. */ scrollDownPage(): void;\n\t/** Scroll the terminal buffer to the bottom. */ scrollToBottom(): void;\n\t/** Scroll the terminal buffer up 1 line. */ scrollUpLine(): void;\n\t/** Scroll the terminal buffer up 1 page. */ scrollUpPage(): void;\n\t/** Scroll the terminal buffer to the top. */ scrollToTop(): void;\n\n\t/**\n\t * Clears the terminal buffer, leaving only the prompt line and moving it to the top of the\n\t * viewport.\n\t */\n\tclearBuffer(): void;\n\n\t/**\n\t * Attaches the terminal instance to an element on the DOM, before this is called the terminal\n\t * instance process may run in the background but cannot be displayed on the UI.\n\t *\n\t * @param container The element to attach the terminal instance to.\n\t */\n\tattachToElement(container: HTMLElement): void;\n\n\t/**\n\t * Detaches the terminal instance from the terminal editor DOM element.\n\t */\n\tdetachFromElement(): void;\n\n\t/**\n\t * Layout the terminal instance.\n\t *\n\t * @param dimension The dimensions of the container.\n\t */\n\tlayout(dimension: { width: number; height: number }): void;\n\n\t/**\n\t * Sets whether the terminal instance's element is visible in the DOM.\n\t *\n\t * @param visible Whether the element is visible.\n\t */\n\tsetVisible(visible: boolean): void;\n\n\t/**\n\t * Immediately kills the terminal's current pty process and launches a new one to replace it.\n\t *\n\t * @param shell The new launch configuration.\n\t */\n\treuseTerminal(shell: IShellLaunchConfig): Promise<void>;\n\n\t/**\n\t * Relaunches the terminal, killing it and reusing the launch config used initially. Any\n\t * environment variable changes will be recalculated when this happens.\n\t */\n\trelaunch(): void;\n\n\t/**\n\t * Sets the terminal instance's dimensions to the values provided via the onDidOverrideDimensions event,\n\t * which allows overriding the the regular dimensions (fit to the size of the panel).\n\t */\n\tsetOverrideDimensions(dimensions: ITerminalDimensions): void;\n\n\t/**\n\t * Sets the terminal instance's dimensions to the values provided via quick input.\n\t */\n\tsetFixedDimensions(): Promise<void>;\n\n\t/**\n\t * Toggles terminal line wrapping.\n\t */\n\ttoggleSizeToContentWidth(): Promise<void>;\n\n\t/**\n\t * Gets the initial current working directory, fetching it from the backend if required.\n\t */\n\tgetInitialCwd(): Promise<string>;\n\n\t/**\n\t * Gets the current working directory from cwd detection capabilities if available, otherwise\n\t * from the backend. This will return the initial cwd if cwd detection is not available (ie.\n\t * on Windows when shell integration is disabled).\n\t */\n\tgetCwd(): Promise<string>;\n\n\t/**\n\t * Sets the title of the terminal to the provided string. If no title is provided, it will reset\n\t * to the terminal's title if it was not explicitly set by the user or API.\n\t * @param title The new title.\n\t */\n\trename(title?: string): Promise<void>;\n\n\t/**\n\t * Sets or triggers a quick pick to change the icon of this terminal.\n\t */\n\tchangeIcon(icon?: TerminalIcon): Promise<TerminalIcon | undefined>;\n\n\t/**\n\t * Sets or triggers a quick pick to change the color of the associated terminal tab icon.\n\t */\n\tchangeColor(\n\t\tcolor?: string,\n\t\tskipQuickPick?: boolean,\n\t): Promise<string | undefined>;\n\n\t/**\n\t * Triggers a quick pick that displays recent commands or cwds. Selecting one will\n\t * rerun it in the active terminal.\n\t */\n\trunRecent(type: \"command\" | \"cwd\"): Promise<void>;\n\n\t/**\n\t * Attempts to detect and kill the process listening on specified port.\n\t * If successful, places commandToRun on the command line\n\t */\n\tfreePortKillProcess(port: string, commandToRun: string): Promise<void>;\n\n\t/**\n\t * Update the parent context key service to use for this terminal instance.\n\t */\n\tsetParentContextKeyService(\n\t\tparentContextKeyService: IContextKeyService,\n\t): void;\n\n\t/**\n\t * Handles a mouse event for the terminal, this may happen on an anscestor of the terminal\n\t * instance's element.\n\t * @param event The mouse event.\n\t * @param contextMenu The context menu to show if needed.\n\t * @returns Whether the context menu should be suppressed.\n\t */\n\thandleMouseEvent(\n\t\tevent: MouseEvent,\n\t\tcontextMenu: IMenu,\n\t): Promise<{ cancelContextMenu: boolean } | void>;\n\n\t/**\n\t * Pause input events until the provided barrier is resolved.\n\t * @param barrier The barrier to wait for until input events can continue.\n\t */\n\tpauseInputEvents(barrier: Barrier): void;\n}\n\nexport enum XtermTerminalConstants {\n\tSearchHighlightLimit = 1000,\n}\n\nexport interface IXtermAttachToElementOptions {\n\t/**\n\t * Whether GPU rendering should be enabled for this element, defaults to true.\n\t */\n\tenableGpu: boolean;\n}\n\nexport interface IXtermTerminal extends IDisposable {\n\t/**\n\t * An object that tracks when commands are run and enables navigating and selecting between\n\t * them.\n\t */\n\treadonly markTracker: IMarkTracker;\n\n\t/**\n\t * Reports the status of shell integration and fires events relating to it.\n\t */\n\treadonly shellIntegration: IShellIntegration;\n\n\treadonly onDidChangeSelection: Event<void>;\n\treadonly onDidChangeFindResults: Event<{\n\t\tresultIndex: number;\n\t\tresultCount: number;\n\t}>;\n\n\t/**\n\t * Event fired when focus enters (fires with true) or leaves (false) the terminal.\n\t */\n\treadonly onDidChangeFocus: Event<boolean>;\n\n\t/**\n\t * Gets a view of the current texture atlas used by the renderers.\n\t */\n\treadonly textureAtlas: Promise<ImageBitmap> | undefined;\n\n\t/**\n\t * Whether the `disableStdin` option in xterm.js is set.\n\t */\n\treadonly isStdinDisabled: boolean;\n\n\t/**\n\t * Whether the terminal is currently focused.\n\t */\n\treadonly isFocused: boolean;\n\n\t/**\n\t * Whether a canvas-based renderer is being used.\n\t */\n\treadonly isGpuAccelerated: boolean;\n\n\t/**\n\t * Attached the terminal to the given element\n\t * @param container Container the terminal will be rendered in\n\t * @param options Additional options for mounting the terminal in an element\n\t */\n\tattachToElement(\n\t\tcontainer: HTMLElement,\n\t\toptions?: Partial<IXtermAttachToElementOptions>,\n\t): void;\n\n\tfindResult?: { resultIndex: number; resultCount: number };\n\n\t/**\n\t * Find the next instance of the term\n\t */\n\tfindNext(term: string, searchOptions: ISearchOptions): Promise<boolean>;\n\n\t/**\n\t * Find the previous instance of the term\n\t */\n\tfindPrevious(term: string, searchOptions: ISearchOptions): Promise<boolean>;\n\n\t/**\n\t * Forces the terminal to redraw its viewport.\n\t */\n\tforceRedraw(): void;\n\n\t/**\n\t * Gets the font metrics of this xterm.js instance.\n\t */\n\tgetFont(): ITerminalFont;\n\n\t/**\n\t * Gets whether there's any terminal selection.\n\t */\n\thasSelection(): boolean;\n\n\t/**\n\t * Clears any terminal selection.\n\t */\n\tclearSelection(): void;\n\n\t/**\n\t * Selects all terminal contents/\n\t */\n\tselectAll(): void;\n\n\t/**\n\t * Selects the content between the two markers by their VS Code OSC `SetMarker`\n\t * ID. It's a no-op if either of the two markers are not found.\n\t *\n\t * @param fromMarkerId Start marker ID\n\t * @param toMarkerId End marker ID\n\t * @param scrollIntoView Whether the terminal should scroll to the start of\n\t * the range, defaults tof alse\n\t */\n\tselectMarkedRange(\n\t\tfromMarkerId: string,\n\t\ttoMarkerId: string,\n\t\tscrollIntoView?: boolean,\n\t): void;\n\n\t/**\n\t * Copies the terminal selection.\n\t * @param {boolean} copyAsHtml Whether to copy selection as HTML, defaults to false.\n\t */\n\tcopySelection(copyAsHtml?: boolean): void;\n\n\t/**\n\t * Focuses the terminal. Warning: {@link ITerminalInstance.focus} should be\n\t * preferred when dealing with terminal instances in order to get\n\t * accessibility triggers.\n\t */\n\tfocus(): void;\n\n\t/** Scroll the terminal buffer down 1 line.   */ scrollDownLine(): void;\n\t/** Scroll the terminal buffer down 1 page.   */ scrollDownPage(): void;\n\t/** Scroll the terminal buffer to the bottom. */ scrollToBottom(): void;\n\t/** Scroll the terminal buffer up 1 line.     */ scrollUpLine(): void;\n\t/** Scroll the terminal buffer up 1 page.     */ scrollUpPage(): void;\n\t/** Scroll the terminal buffer to the top.    */ scrollToTop(): void;\n\t/** Scroll the terminal buffer to a set line  */ scrollToLine(\n\t\tline: number,\n\t\tposition?: ScrollPosition,\n\t): void;\n\n\t/**\n\t * Clears the terminal buffer, leaving only the prompt line and moving it to the top of the\n\t * viewport.\n\t */\n\tclearBuffer(): void;\n\n\t/**\n\t * Clears the search result decorations\n\t */\n\tclearSearchDecorations(): void;\n\n\t/**\n\t * Clears the active search result decorations\n\t */\n\tclearActiveSearchDecoration(): void;\n\n\t/**\n\t * Returns a reverse iterator of buffer lines as strings\n\t */\n\tgetBufferReverseIterator(): IterableIterator<string>;\n\n\t/**\n\t * Gets the buffer contents as HTML.\n\t */\n\tgetContentsAsHtml(): Promise<string>;\n\n\t/**\n\t * Refreshes the terminal after it has been moved.\n\t */\n\trefresh(): void;\n\n\tgetXtermTheme(theme?: IColorTheme): ITheme;\n}\n\nexport interface IDetachedXtermTerminal extends IXtermTerminal {\n\t/**\n\t * Writes data to the terminal.\n\t * @param data data to write\n\t * @param callback Optional callback that fires when the data was processed\n\t * by the parser.\n\t */\n\twrite(data: string | Uint8Array, callback?: () => void): void;\n\n\t/**\n\t * Resizes the terminal.\n\t */\n\tresize(columns: number, rows: number): void;\n}\n\nexport interface IInternalXtermTerminal {\n\t/**\n\t * Writes text directly to the terminal, bypassing the process.\n\t *\n\t * **WARNING:** This should never be used outside of the terminal component and only for\n\t * developer purposed inside the terminal component.\n\t */\n\t_writeText(data: string): void; // eslint-disable-line @typescript-eslint/naming-convention\n}\n\nexport interface IXtermColorProvider {\n\tgetBackgroundColor(theme: IColorTheme): Color | undefined;\n}\n\nexport interface IRequestAddInstanceToGroupEvent {\n\turi: URI;\n\tside: \"before\" | \"after\";\n}\n\nexport enum LinuxDistro {\n\tUnknown = 1,\n\tFedora = 2,\n\tUbuntu = 3,\n}\n\nexport enum TerminalDataTransfers {\n\tTerminals = \"Terminals\",\n}\n"],
  "mappings": ";;AA4BA,SAAS,uBAAuB;AAqDzB,MAAM,mBACZ,gBAAkC,iBAAiB;AAC7C,MAAM,gCACZ;AAAA,EACC;AACD;AACM,MAAM,yBAAyB;AAAA,EACrC;AACD;AACO,MAAM,wBAAwB;AAAA,EACpC;AACD;AACO,MAAM,2BACZ,gBAA0C,yBAAyB;AA8D7D,IAAK,YAAL,kBAAKA,eAAL;AACN,EAAAA,sBAAA,UAAO,KAAP;AACA,EAAAA,sBAAA,WAAQ,KAAR;AACA,EAAAA,sBAAA,QAAK,KAAL;AACA,EAAAA,sBAAA,UAAO,KAAP;AAJW,SAAAA;AAAA,GAAA;AAoFL,IAAK,0BAAL,kBAAKC,6BAAL;AACN,EAAAA,kDAAA,gBAAa,KAAb;AACA,EAAAA,kDAAA,eAAY,KAAZ;AAFW,SAAAA;AAAA,GAAA;AA2FL,MAAM,6BAA6B,wBACzC,MAEA,OAAQ,EAAwB,eAAe,UAHN;AAyLnC,MAAM,mCAAmC,WAAW;AAAA,EApgB3D,OAogB2D;AAAA;AAAA;AAAC;AAgCrD,MAAM,mBAAmB;AAusBzB,IAAK,yBAAL,kBAAKC,4BAAL;AACN,EAAAA,gDAAA,0BAAuB,OAAvB;AADW,SAAAA;AAAA,GAAA;AAgNL,IAAK,cAAL,kBAAKC,iBAAL;AACN,EAAAA,0BAAA,aAAU,KAAV;AACA,EAAAA,0BAAA,YAAS,KAAT;AACA,EAAAA,0BAAA,YAAS,KAAT;AAHW,SAAAA;AAAA,GAAA;AAML,IAAK,wBAAL,kBAAKC,2BAAL;AACN,EAAAA,uBAAA,eAAY;AADD,SAAAA;AAAA,GAAA;",
  "names": ["Direction", "TerminalConnectionState", "XtermTerminalConstants", "LinuxDistro", "TerminalDataTransfers"]
}
