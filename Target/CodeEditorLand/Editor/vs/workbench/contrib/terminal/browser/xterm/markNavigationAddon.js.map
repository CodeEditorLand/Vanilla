{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/terminal/browser/xterm/markNavigationAddon.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { coalesce } from '../../../../../base/common/arrays.js';\nimport { Disposable, DisposableStore, MutableDisposable, dispose } from '../../../../../base/common/lifecycle.js';\nimport { IMarkTracker } from '../terminal.js';\nimport { ITerminalCapabilityStore, ITerminalCommand, TerminalCapability } from '../../../../../platform/terminal/common/capabilities/capabilities.js';\nimport type { Terminal, IMarker, ITerminalAddon, IDecoration, IBufferRange } from '@xterm/xterm';\nimport { timeout } from '../../../../../base/common/async.js';\nimport { IThemeService } from '../../../../../platform/theme/common/themeService.js';\nimport { TERMINAL_OVERVIEW_RULER_CURSOR_FOREGROUND_COLOR } from '../../common/terminalColorRegistry.js';\nimport { getWindow } from '../../../../../base/browser/dom.js';\nimport { ICurrentPartialCommand } from '../../../../../platform/terminal/common/capabilities/commandDetection/terminalCommand.js';\nimport { IConfigurationService } from '../../../../../platform/configuration/common/configuration.js';\n\n// HACK: Mark navigation currently depends on terminalContrib/stickyScroll\n// eslint-disable-next-line local/code-import-patterns\nimport { TerminalStickyScrollSettingId } from '../../../terminalContrib/stickyScroll/common/terminalStickyScrollConfiguration.js';\n\nenum Boundary {\n\tTop,\n\tBottom\n}\n\nexport const enum ScrollPosition {\n\tTop,\n\tMiddle\n}\n\ninterface IScrollToMarkerOptions {\n\thideDecoration?: boolean;\n\t/** Scroll even if the line is within the viewport */\n\tforceScroll?: boolean;\n\tbufferRange?: IBufferRange;\n}\n\nexport class MarkNavigationAddon extends Disposable implements IMarkTracker, ITerminalAddon {\n\tprivate _currentMarker: IMarker | Boundary = Boundary.Bottom;\n\tprivate _selectionStart: IMarker | Boundary | null = null;\n\tprivate _isDisposable: boolean = false;\n\tprotected _terminal: Terminal | undefined;\n\tprivate _navigationDecorations: IDecoration[] | undefined;\n\n\tprivate _activeCommandGuide?: ITerminalCommand;\n\tprivate readonly _commandGuideDecorations = this._register(new MutableDisposable<DisposableStore>());\n\n\tactivate(terminal: Terminal): void {\n\t\tthis._terminal = terminal;\n\t\tthis._register(this._terminal.onData(() => {\n\t\t\tthis._currentMarker = Boundary.Bottom;\n\t\t}));\n\t}\n\n\tconstructor(\n\t\tprivate readonly _capabilities: ITerminalCapabilityStore,\n\t\t@IConfigurationService private readonly _configurationService: IConfigurationService,\n\t\t@IThemeService private readonly _themeService: IThemeService\n\t) {\n\t\tsuper();\n\t}\n\n\tprivate _getMarkers(skipEmptyCommands?: boolean): readonly IMarker[] {\n\t\tconst commandCapability = this._capabilities.get(TerminalCapability.CommandDetection);\n\t\tconst partialCommandCapability = this._capabilities.get(TerminalCapability.PartialCommandDetection);\n\t\tconst markCapability = this._capabilities.get(TerminalCapability.BufferMarkDetection);\n\t\tlet markers: IMarker[] = [];\n\t\tif (commandCapability) {\n\t\t\tmarkers = coalesce(commandCapability.commands.filter(e => skipEmptyCommands ? e.exitCode !== undefined : true).map(e => e.promptStartMarker ?? e.marker));\n\t\t\t// Allow navigating to the current command iff it has been executed, this ignores the\n\t\t\t// skipEmptyCommands flag intenionally as chances are it's not going to be empty if an\n\t\t\t// executed marker exists when this is requested.\n\t\t\tif (commandCapability.currentCommand?.promptStartMarker && commandCapability.currentCommand.commandExecutedMarker) {\n\t\t\t\tmarkers.push(commandCapability.currentCommand?.promptStartMarker);\n\t\t\t}\n\t\t} else if (partialCommandCapability) {\n\t\t\tmarkers.push(...partialCommandCapability.commands);\n\t\t}\n\n\t\tif (markCapability && !skipEmptyCommands) {\n\t\t\tlet next = markCapability.markers().next()?.value;\n\t\t\tconst arr: IMarker[] = [];\n\t\t\twhile (next) {\n\t\t\t\tarr.push(next);\n\t\t\t\tnext = markCapability.markers().next()?.value;\n\t\t\t}\n\t\t\tmarkers = arr;\n\t\t}\n\t\treturn markers;\n\t}\n\n\tprivate _findCommand(marker: IMarker): ITerminalCommand | ICurrentPartialCommand | undefined {\n\t\tconst commandCapability = this._capabilities.get(TerminalCapability.CommandDetection);\n\t\tif (commandCapability) {\n\t\t\tconst command = commandCapability.commands.find(e => e.marker?.line === marker.line || e.promptStartMarker?.line === marker.line);\n\t\t\tif (command) {\n\t\t\t\treturn command;\n\t\t\t}\n\t\t\tif (commandCapability.currentCommand) {\n\t\t\t\treturn commandCapability.currentCommand;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tclear(): void {\n\t\t// Clear the current marker so successive focus/selection actions are performed from the\n\t\t// bottom of the buffer\n\t\tthis._currentMarker = Boundary.Bottom;\n\t\tthis._resetNavigationDecorations();\n\t\tthis._selectionStart = null;\n\t}\n\n\tprivate _resetNavigationDecorations() {\n\t\tif (this._navigationDecorations) {\n\t\t\tdispose(this._navigationDecorations);\n\t\t}\n\t\tthis._navigationDecorations = [];\n\t}\n\n\tprivate _isEmptyCommand(marker: IMarker | Boundary) {\n\t\tif (marker === Boundary.Bottom) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (marker === Boundary.Top) {\n\t\t\treturn !this._getMarkers(true).map(e => e.line).includes(0);\n\t\t}\n\n\t\treturn !this._getMarkers(true).includes(marker);\n\t}\n\n\tscrollToPreviousMark(scrollPosition: ScrollPosition = ScrollPosition.Middle, retainSelection: boolean = false, skipEmptyCommands: boolean = true): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tif (!retainSelection) {\n\t\t\tthis._selectionStart = null;\n\t\t}\n\n\t\tlet markerIndex;\n\t\tconst currentLineY = typeof this._currentMarker === 'object'\n\t\t\t? this.getTargetScrollLine(this._currentMarker.line, scrollPosition)\n\t\t\t: Math.min(getLine(this._terminal, this._currentMarker), this._terminal.buffer.active.baseY);\n\t\tconst viewportY = this._terminal.buffer.active.viewportY;\n\t\tif (typeof this._currentMarker === 'object' ? !this._isMarkerInViewport(this._terminal, this._currentMarker) : currentLineY !== viewportY) {\n\t\t\t// The user has scrolled, find the line based on the current scroll position. This only\n\t\t\t// works when not retaining selection\n\t\t\tconst markersBelowViewport = this._getMarkers(skipEmptyCommands).filter(e => e.line >= viewportY).length;\n\t\t\t// -1 will scroll to the top\n\t\t\tmarkerIndex = this._getMarkers(skipEmptyCommands).length - markersBelowViewport - 1;\n\t\t} else if (this._currentMarker === Boundary.Bottom) {\n\t\t\tmarkerIndex = this._getMarkers(skipEmptyCommands).length - 1;\n\t\t} else if (this._currentMarker === Boundary.Top) {\n\t\t\tmarkerIndex = -1;\n\t\t} else if (this._isDisposable) {\n\t\t\tmarkerIndex = this._findPreviousMarker(skipEmptyCommands);\n\t\t\tthis._currentMarker.dispose();\n\t\t\tthis._isDisposable = false;\n\t\t} else {\n\t\t\tif (skipEmptyCommands && this._isEmptyCommand(this._currentMarker)) {\n\t\t\t\tmarkerIndex = this._findPreviousMarker(true);\n\t\t\t} else {\n\t\t\t\tmarkerIndex = this._getMarkers(skipEmptyCommands).indexOf(this._currentMarker) - 1;\n\t\t\t}\n\t\t}\n\n\t\tif (markerIndex < 0) {\n\t\t\tthis._currentMarker = Boundary.Top;\n\t\t\tthis._terminal.scrollToTop();\n\t\t\tthis._resetNavigationDecorations();\n\t\t\treturn;\n\t\t}\n\n\t\tthis._currentMarker = this._getMarkers(skipEmptyCommands)[markerIndex];\n\t\tthis._scrollToCommand(this._currentMarker, scrollPosition);\n\t}\n\n\tscrollToNextMark(scrollPosition: ScrollPosition = ScrollPosition.Middle, retainSelection: boolean = false, skipEmptyCommands: boolean = true): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tif (!retainSelection) {\n\t\t\tthis._selectionStart = null;\n\t\t}\n\n\t\tlet markerIndex;\n\t\tconst currentLineY = typeof this._currentMarker === 'object'\n\t\t\t? this.getTargetScrollLine(this._currentMarker.line, scrollPosition)\n\t\t\t: Math.min(getLine(this._terminal, this._currentMarker), this._terminal.buffer.active.baseY);\n\t\tconst viewportY = this._terminal.buffer.active.viewportY;\n\t\tif (typeof this._currentMarker === 'object' ? !this._isMarkerInViewport(this._terminal, this._currentMarker) : currentLineY !== viewportY) {\n\t\t\t// The user has scrolled, find the line based on the current scroll position. This only\n\t\t\t// works when not retaining selection\n\t\t\tconst markersAboveViewport = this._getMarkers(skipEmptyCommands).filter(e => e.line <= viewportY).length;\n\t\t\t// markers.length will scroll to the bottom\n\t\t\tmarkerIndex = markersAboveViewport;\n\t\t} else if (this._currentMarker === Boundary.Bottom) {\n\t\t\tmarkerIndex = this._getMarkers(skipEmptyCommands).length;\n\t\t} else if (this._currentMarker === Boundary.Top) {\n\t\t\tmarkerIndex = 0;\n\t\t} else if (this._isDisposable) {\n\t\t\tmarkerIndex = this._findNextMarker(skipEmptyCommands);\n\t\t\tthis._currentMarker.dispose();\n\t\t\tthis._isDisposable = false;\n\t\t} else {\n\t\t\tif (skipEmptyCommands && this._isEmptyCommand(this._currentMarker)) {\n\t\t\t\tmarkerIndex = this._findNextMarker(true);\n\t\t\t} else {\n\t\t\t\tmarkerIndex = this._getMarkers(skipEmptyCommands).indexOf(this._currentMarker) + 1;\n\t\t\t}\n\t\t}\n\n\t\tif (markerIndex >= this._getMarkers(skipEmptyCommands).length) {\n\t\t\tthis._currentMarker = Boundary.Bottom;\n\t\t\tthis._terminal.scrollToBottom();\n\t\t\tthis._resetNavigationDecorations();\n\t\t\treturn;\n\t\t}\n\n\t\tthis._currentMarker = this._getMarkers(skipEmptyCommands)[markerIndex];\n\t\tthis._scrollToCommand(this._currentMarker, scrollPosition);\n\t}\n\n\tprivate _scrollToCommand(marker: IMarker, position: ScrollPosition): void {\n\t\tconst command = this._findCommand(marker);\n\t\tif (command) {\n\t\t\tthis.revealCommand(command, position);\n\t\t} else {\n\t\t\tthis._scrollToMarker(marker, position);\n\t\t}\n\t}\n\n\tprivate _scrollToMarker(start: IMarker | number, position: ScrollPosition, end?: IMarker | number, options?: IScrollToMarkerOptions): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tif (!this._isMarkerInViewport(this._terminal, start) || options?.forceScroll) {\n\t\t\tconst line = this.getTargetScrollLine(toLineIndex(start), position);\n\t\t\tthis._terminal.scrollToLine(line);\n\t\t}\n\t\tif (!options?.hideDecoration) {\n\t\t\tif (options?.bufferRange) {\n\t\t\t\tthis._highlightBufferRange(options.bufferRange);\n\t\t\t} else {\n\t\t\t\tthis.registerTemporaryDecoration(start, end, true);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _createMarkerForOffset(marker: IMarker | number, offset: number): IMarker {\n\t\tif (offset === 0 && isMarker(marker)) {\n\t\t\treturn marker;\n\t\t} else {\n\t\t\tconst offsetMarker = this._terminal?.registerMarker(-this._terminal.buffer.active.cursorY + toLineIndex(marker) - this._terminal.buffer.active.baseY + offset);\n\t\t\tif (offsetMarker) {\n\t\t\t\treturn offsetMarker;\n\t\t\t} else {\n\t\t\t\tthrow new Error(`Could not register marker with offset ${toLineIndex(marker)}, ${offset}`);\n\t\t\t}\n\t\t}\n\t}\n\n\trevealCommand(command: ITerminalCommand | ICurrentPartialCommand, position: ScrollPosition = ScrollPosition.Middle): void {\n\t\tconst marker = 'getOutput' in command ? command.marker : command.commandStartMarker;\n\t\tif (!this._terminal || !marker) {\n\t\t\treturn;\n\t\t}\n\t\tconst line = toLineIndex(marker);\n\t\tconst promptRowCount = command.getPromptRowCount();\n\t\tconst commandRowCount = command.getCommandRowCount();\n\t\tthis._scrollToMarker(\n\t\t\tline - (promptRowCount - 1),\n\t\t\tposition,\n\t\t\tline + (commandRowCount - 1)\n\t\t);\n\t}\n\n\trevealRange(range: IBufferRange): void {\n\t\tthis._scrollToMarker(\n\t\t\trange.start.y - 1,\n\t\t\tScrollPosition.Middle,\n\t\t\trange.end.y - 1,\n\t\t\t{\n\t\t\t\tbufferRange: range,\n\t\t\t\t// Ensure scroll shows the line when sticky scroll is enabled\n\t\t\t\tforceScroll: !!this._configurationService.getValue(TerminalStickyScrollSettingId.Enabled)\n\t\t\t}\n\t\t);\n\t}\n\n\tshowCommandGuide(command: ITerminalCommand | undefined): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tif (!command) {\n\t\t\tthis._commandGuideDecorations.clear();\n\t\t\tthis._activeCommandGuide = undefined;\n\t\t\treturn;\n\t\t}\n\t\tif (this._activeCommandGuide === command) {\n\t\t\treturn;\n\t\t}\n\t\tif (command.marker) {\n\t\t\tthis._activeCommandGuide = command;\n\n\t\t\t// Highlight output\n\t\t\tconst store = this._commandGuideDecorations.value = new DisposableStore();\n\t\t\tif (!command.executedMarker || !command.endMarker) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst startLine = command.marker.line - (command.getPromptRowCount() - 1);\n\t\t\tconst decorationCount = toLineIndex(command.endMarker) - startLine;\n\t\t\t// Abort if the command is excessively long to avoid performance on hover/leave\n\t\t\tif (decorationCount > 200) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (let i = 0; i < decorationCount; i++) {\n\t\t\t\tconst decoration = this._terminal.registerDecoration({\n\t\t\t\t\tmarker: this._createMarkerForOffset(startLine, i)\n\t\t\t\t});\n\t\t\t\tif (decoration) {\n\t\t\t\t\tstore.add(decoration);\n\t\t\t\t\tlet renderedElement: HTMLElement | undefined;\n\t\t\t\t\tstore.add(decoration.onRender(element => {\n\t\t\t\t\t\tif (!renderedElement) {\n\t\t\t\t\t\t\trenderedElement = element;\n\t\t\t\t\t\t\telement.classList.add('terminal-command-guide');\n\t\t\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\t\t\telement.classList.add('top');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i === decorationCount - 1) {\n\t\t\t\t\t\t\t\telement.classList.add('bottom');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (this._terminal?.element) {\n\t\t\t\t\t\t\telement.style.marginLeft = `-${getWindow(this._terminal.element).getComputedStyle(this._terminal.element).paddingLeft}`;\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate _scrollState: { viewportY: number } | undefined;\n\n\tsaveScrollState(): void {\n\t\tthis._scrollState = { viewportY: this._terminal?.buffer.active.viewportY ?? 0 };\n\t}\n\n\trestoreScrollState(): void {\n\t\tif (this._scrollState && this._terminal) {\n\t\t\tthis._terminal.scrollToLine(this._scrollState.viewportY);\n\t\t\tthis._scrollState = undefined;\n\t\t}\n\t}\n\n\tprivate _highlightBufferRange(range: IBufferRange): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._resetNavigationDecorations();\n\t\tconst startLine = range.start.y;\n\t\tconst decorationCount = range.end.y - range.start.y + 1;\n\t\tfor (let i = 0; i < decorationCount; i++) {\n\t\t\tconst decoration = this._terminal.registerDecoration({\n\t\t\t\tmarker: this._createMarkerForOffset(startLine - 1, i),\n\t\t\t\tx: range.start.x - 1,\n\t\t\t\twidth: (range.end.x - 1) - (range.start.x - 1) + 1,\n\t\t\t\toverviewRulerOptions: undefined\n\t\t\t});\n\t\t\tif (decoration) {\n\t\t\t\tthis._navigationDecorations?.push(decoration);\n\t\t\t\tlet renderedElement: HTMLElement | undefined;\n\n\t\t\t\tdecoration.onRender(element => {\n\t\t\t\t\tif (!renderedElement) {\n\t\t\t\t\t\trenderedElement = element;\n\t\t\t\t\t\telement.classList.add('terminal-range-highlight');\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tdecoration.onDispose(() => { this._navigationDecorations = this._navigationDecorations?.filter(d => d !== decoration); });\n\t\t\t}\n\t\t}\n\t}\n\n\tregisterTemporaryDecoration(marker: IMarker | number, endMarker: IMarker | number | undefined, showOutline: boolean): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tthis._resetNavigationDecorations();\n\t\tconst color = this._themeService.getColorTheme().getColor(TERMINAL_OVERVIEW_RULER_CURSOR_FOREGROUND_COLOR);\n\t\tconst startLine = toLineIndex(marker);\n\t\tconst decorationCount = endMarker ? toLineIndex(endMarker) - startLine + 1 : 1;\n\t\tfor (let i = 0; i < decorationCount; i++) {\n\t\t\tconst decoration = this._terminal.registerDecoration({\n\t\t\t\tmarker: this._createMarkerForOffset(marker, i),\n\t\t\t\twidth: this._terminal.cols,\n\t\t\t\toverviewRulerOptions: i === 0 ? {\n\t\t\t\t\tcolor: color?.toString() || '#a0a0a0cc'\n\t\t\t\t} : undefined\n\t\t\t});\n\t\t\tif (decoration) {\n\t\t\t\tthis._navigationDecorations?.push(decoration);\n\t\t\t\tlet renderedElement: HTMLElement | undefined;\n\n\t\t\t\tdecoration.onRender(element => {\n\t\t\t\t\tif (!renderedElement) {\n\t\t\t\t\t\trenderedElement = element;\n\t\t\t\t\t\telement.classList.add('terminal-scroll-highlight');\n\t\t\t\t\t\tif (showOutline) {\n\t\t\t\t\t\t\telement.classList.add('terminal-scroll-highlight-outline');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\t\telement.classList.add('top');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (i === decorationCount - 1) {\n\t\t\t\t\t\t\telement.classList.add('bottom');\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\telement.classList.add('terminal-scroll-highlight');\n\t\t\t\t\t}\n\t\t\t\t\tif (this._terminal?.element) {\n\t\t\t\t\t\telement.style.marginLeft = `-${getWindow(this._terminal.element).getComputedStyle(this._terminal.element).paddingLeft}`;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t// TODO: This is not efficient for a large decorationCount\n\t\t\t\tdecoration.onDispose(() => { this._navigationDecorations = this._navigationDecorations?.filter(d => d !== decoration); });\n\t\t\t\t// Number picked to align with symbol highlight in the editor\n\t\t\t\tif (showOutline) {\n\t\t\t\t\ttimeout(350).then(() => {\n\t\t\t\t\t\tif (renderedElement) {\n\t\t\t\t\t\t\trenderedElement.classList.remove('terminal-scroll-highlight-outline');\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tscrollToLine(line: number, position: ScrollPosition): void {\n\t\tthis._terminal?.scrollToLine(this.getTargetScrollLine(line, position));\n\t}\n\n\tgetTargetScrollLine(line: number, position: ScrollPosition): number {\n\t\t// Middle is treated as 1/4 of the viewport's size because context below is almost always\n\t\t// more important than context above in the terminal.\n\t\tif (this._terminal && position === ScrollPosition.Middle) {\n\t\t\treturn Math.max(line - Math.floor(this._terminal.rows / 4), 0);\n\t\t}\n\t\treturn line;\n\t}\n\n\tprivate _isMarkerInViewport(terminal: Terminal, marker: IMarker | number) {\n\t\tconst viewportY = terminal.buffer.active.viewportY;\n\t\tconst line = toLineIndex(marker);\n\t\treturn line >= viewportY && line < viewportY + terminal.rows;\n\t}\n\n\tscrollToClosestMarker(startMarkerId: string, endMarkerId?: string, highlight?: boolean | undefined): void {\n\t\tconst detectionCapability = this._capabilities.get(TerminalCapability.BufferMarkDetection);\n\t\tif (!detectionCapability) {\n\t\t\treturn;\n\t\t}\n\t\tconst startMarker = detectionCapability.getMark(startMarkerId);\n\t\tif (!startMarker) {\n\t\t\treturn;\n\t\t}\n\t\tconst endMarker = endMarkerId ? detectionCapability.getMark(endMarkerId) : startMarker;\n\t\tthis._scrollToMarker(startMarker, ScrollPosition.Top, endMarker, { hideDecoration: !highlight });\n\t}\n\n\tselectToPreviousMark(): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._selectionStart === null) {\n\t\t\tthis._selectionStart = this._currentMarker;\n\t\t}\n\t\tif (this._capabilities.has(TerminalCapability.CommandDetection)) {\n\t\t\tthis.scrollToPreviousMark(ScrollPosition.Middle, true, true);\n\t\t} else {\n\t\t\tthis.scrollToPreviousMark(ScrollPosition.Middle, true, false);\n\t\t}\n\t\tselectLines(this._terminal, this._currentMarker, this._selectionStart);\n\t}\n\n\tselectToNextMark(): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._selectionStart === null) {\n\t\t\tthis._selectionStart = this._currentMarker;\n\t\t}\n\t\tif (this._capabilities.has(TerminalCapability.CommandDetection)) {\n\t\t\tthis.scrollToNextMark(ScrollPosition.Middle, true, true);\n\t\t} else {\n\t\t\tthis.scrollToNextMark(ScrollPosition.Middle, true, false);\n\t\t}\n\t\tselectLines(this._terminal, this._currentMarker, this._selectionStart);\n\t}\n\n\tselectToPreviousLine(): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._selectionStart === null) {\n\t\t\tthis._selectionStart = this._currentMarker;\n\t\t}\n\t\tthis.scrollToPreviousLine(this._terminal, ScrollPosition.Middle, true);\n\t\tselectLines(this._terminal, this._currentMarker, this._selectionStart);\n\t}\n\n\tselectToNextLine(): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._selectionStart === null) {\n\t\t\tthis._selectionStart = this._currentMarker;\n\t\t}\n\t\tthis.scrollToNextLine(this._terminal, ScrollPosition.Middle, true);\n\t\tselectLines(this._terminal, this._currentMarker, this._selectionStart);\n\t}\n\n\tscrollToPreviousLine(xterm: Terminal, scrollPosition: ScrollPosition = ScrollPosition.Middle, retainSelection: boolean = false): void {\n\t\tif (!retainSelection) {\n\t\t\tthis._selectionStart = null;\n\t\t}\n\n\t\tif (this._currentMarker === Boundary.Top) {\n\t\t\txterm.scrollToTop();\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._currentMarker === Boundary.Bottom) {\n\t\t\tthis._currentMarker = this._registerMarkerOrThrow(xterm, this._getOffset(xterm) - 1);\n\t\t} else {\n\t\t\tconst offset = this._getOffset(xterm);\n\t\t\tif (this._isDisposable) {\n\t\t\t\tthis._currentMarker.dispose();\n\t\t\t}\n\t\t\tthis._currentMarker = this._registerMarkerOrThrow(xterm, offset - 1);\n\t\t}\n\t\tthis._isDisposable = true;\n\t\tthis._scrollToMarker(this._currentMarker, scrollPosition);\n\t}\n\n\tscrollToNextLine(xterm: Terminal, scrollPosition: ScrollPosition = ScrollPosition.Middle, retainSelection: boolean = false): void {\n\t\tif (!retainSelection) {\n\t\t\tthis._selectionStart = null;\n\t\t}\n\n\t\tif (this._currentMarker === Boundary.Bottom) {\n\t\t\txterm.scrollToBottom();\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._currentMarker === Boundary.Top) {\n\t\t\tthis._currentMarker = this._registerMarkerOrThrow(xterm, this._getOffset(xterm) + 1);\n\t\t} else {\n\t\t\tconst offset = this._getOffset(xterm);\n\t\t\tif (this._isDisposable) {\n\t\t\t\tthis._currentMarker.dispose();\n\t\t\t}\n\t\t\tthis._currentMarker = this._registerMarkerOrThrow(xterm, offset + 1);\n\t\t}\n\t\tthis._isDisposable = true;\n\t\tthis._scrollToMarker(this._currentMarker, scrollPosition);\n\t}\n\n\tprivate _registerMarkerOrThrow(xterm: Terminal, cursorYOffset: number): IMarker {\n\t\tconst marker = xterm.registerMarker(cursorYOffset);\n\t\tif (!marker) {\n\t\t\tthrow new Error(`Could not create marker for ${cursorYOffset}`);\n\t\t}\n\t\treturn marker;\n\t}\n\n\tprivate _getOffset(xterm: Terminal): number {\n\t\tif (this._currentMarker === Boundary.Bottom) {\n\t\t\treturn 0;\n\t\t} else if (this._currentMarker === Boundary.Top) {\n\t\t\treturn 0 - (xterm.buffer.active.baseY + xterm.buffer.active.cursorY);\n\t\t} else {\n\t\t\tlet offset = getLine(xterm, this._currentMarker);\n\t\t\toffset -= xterm.buffer.active.baseY + xterm.buffer.active.cursorY;\n\t\t\treturn offset;\n\t\t}\n\t}\n\n\tprivate _findPreviousMarker(skipEmptyCommands: boolean = false): number {\n\t\tif (this._currentMarker === Boundary.Top) {\n\t\t\treturn 0;\n\t\t} else if (this._currentMarker === Boundary.Bottom) {\n\t\t\treturn this._getMarkers(skipEmptyCommands).length - 1;\n\t\t}\n\n\t\tlet i;\n\t\tfor (i = this._getMarkers(skipEmptyCommands).length - 1; i >= 0; i--) {\n\t\t\tif (this._getMarkers(skipEmptyCommands)[i].line < this._currentMarker.line) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tprivate _findNextMarker(skipEmptyCommands: boolean = false): number {\n\t\tif (this._currentMarker === Boundary.Top) {\n\t\t\treturn 0;\n\t\t} else if (this._currentMarker === Boundary.Bottom) {\n\t\t\treturn this._getMarkers(skipEmptyCommands).length - 1;\n\t\t}\n\n\t\tlet i;\n\t\tfor (i = 0; i < this._getMarkers(skipEmptyCommands).length; i++) {\n\t\t\tif (this._getMarkers(skipEmptyCommands)[i].line > this._currentMarker.line) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\treturn this._getMarkers(skipEmptyCommands).length;\n\t}\n}\n\nexport function getLine(xterm: Terminal, marker: IMarker | Boundary): number {\n\t// Use the _second last_ row as the last row is likely the prompt\n\tif (marker === Boundary.Bottom) {\n\t\treturn xterm.buffer.active.baseY + xterm.rows - 1;\n\t}\n\n\tif (marker === Boundary.Top) {\n\t\treturn 0;\n\t}\n\n\treturn marker.line;\n}\n\nexport function selectLines(xterm: Terminal, start: IMarker | Boundary, end: IMarker | Boundary | null): void {\n\tif (end === null) {\n\t\tend = Boundary.Bottom;\n\t}\n\n\tlet startLine = getLine(xterm, start);\n\tlet endLine = getLine(xterm, end);\n\n\tif (startLine > endLine) {\n\t\tconst temp = startLine;\n\t\tstartLine = endLine;\n\t\tendLine = temp;\n\t}\n\n\t// Subtract a line as the marker is on the line the command run, we do not want the next\n\t// command in the selection for the current command\n\tendLine -= 1;\n\n\txterm.selectLines(startLine, endLine);\n}\n\nfunction isMarker(value: IMarker | number): value is IMarker {\n\treturn typeof value !== 'number';\n}\n\nfunction toLineIndex(line: IMarker | number): number {\n\treturn isMarker(line) ? line.line : line;\n}\n"],
  "mappings": "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",
  "names": ["Boundary", "ScrollPosition"]
}
