{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/terminal/browser/xterm/markNavigationAddon.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type {\n\tIBufferRange,\n\tIDecoration,\n\tIMarker,\n\tITerminalAddon,\n\tTerminal,\n} from \"@xterm/xterm\";\nimport { getWindow } from \"../../../../../base/browser/dom.js\";\nimport { coalesce } from \"../../../../../base/common/arrays.js\";\nimport { timeout } from \"../../../../../base/common/async.js\";\nimport {\n\tDisposable,\n\tDisposableStore,\n\tMutableDisposable,\n\tdispose,\n} from \"../../../../../base/common/lifecycle.js\";\nimport { IConfigurationService } from \"../../../../../platform/configuration/common/configuration.js\";\nimport {\n\ttype ITerminalCapabilityStore,\n\ttype ITerminalCommand,\n\tTerminalCapability,\n} from \"../../../../../platform/terminal/common/capabilities/capabilities.js\";\nimport type { ICurrentPartialCommand } from \"../../../../../platform/terminal/common/capabilities/commandDetection/terminalCommand.js\";\nimport { IThemeService } from \"../../../../../platform/theme/common/themeService.js\";\nimport { TERMINAL_OVERVIEW_RULER_CURSOR_FOREGROUND_COLOR } from \"../../common/terminalColorRegistry.js\";\nimport type { IMarkTracker } from \"../terminal.js\";\n\n// HACK: Mark navigation currently depends on terminalContrib/stickyScroll\n// eslint-disable-next-line local/code-import-patterns\nimport { TerminalStickyScrollSettingId } from \"../../../terminalContrib/stickyScroll/common/terminalStickyScrollConfiguration.js\";\n\nenum Boundary {\n\tTop = 0,\n\tBottom = 1,\n}\n\nexport enum ScrollPosition {\n\tTop = 0,\n\tMiddle = 1,\n}\n\ninterface IScrollToMarkerOptions {\n\thideDecoration?: boolean;\n\t/** Scroll even if the line is within the viewport */\n\tforceScroll?: boolean;\n\tbufferRange?: IBufferRange;\n}\n\nexport class MarkNavigationAddon\n\textends Disposable\n\timplements IMarkTracker, ITerminalAddon\n{\n\tprivate _currentMarker: IMarker | Boundary = Boundary.Bottom;\n\tprivate _selectionStart: IMarker | Boundary | null = null;\n\tprivate _isDisposable = false;\n\tprotected _terminal: Terminal | undefined;\n\tprivate _navigationDecorations: IDecoration[] | undefined;\n\n\tprivate _activeCommandGuide?: ITerminalCommand;\n\tprivate readonly _commandGuideDecorations = this._register(\n\t\tnew MutableDisposable<DisposableStore>(),\n\t);\n\n\tactivate(terminal: Terminal): void {\n\t\tthis._terminal = terminal;\n\t\tthis._register(\n\t\t\tthis._terminal.onData(() => {\n\t\t\t\tthis._currentMarker = Boundary.Bottom;\n\t\t\t}),\n\t\t);\n\t}\n\n\tconstructor(\n\t\tprivate readonly _capabilities: ITerminalCapabilityStore,\n\t\t@IConfigurationService\n\t\tprivate readonly _configurationService: IConfigurationService,\n\t\t@IThemeService private readonly _themeService: IThemeService,\n\t) {\n\t\tsuper();\n\t}\n\n\tprivate _getMarkers(skipEmptyCommands?: boolean): readonly IMarker[] {\n\t\tconst commandCapability = this._capabilities.get(\n\t\t\tTerminalCapability.CommandDetection,\n\t\t);\n\t\tconst partialCommandCapability = this._capabilities.get(\n\t\t\tTerminalCapability.PartialCommandDetection,\n\t\t);\n\t\tconst markCapability = this._capabilities.get(\n\t\t\tTerminalCapability.BufferMarkDetection,\n\t\t);\n\t\tlet markers: IMarker[] = [];\n\t\tif (commandCapability) {\n\t\t\tmarkers = coalesce(\n\t\t\t\tcommandCapability.commands\n\t\t\t\t\t.filter((e) =>\n\t\t\t\t\t\tskipEmptyCommands ? e.exitCode !== undefined : true,\n\t\t\t\t\t)\n\t\t\t\t\t.map((e) => e.promptStartMarker ?? e.marker),\n\t\t\t);\n\t\t\t// Allow navigating to the current command iff it has been executed, this ignores the\n\t\t\t// skipEmptyCommands flag intenionally as chances are it's not going to be empty if an\n\t\t\t// executed marker exists when this is requested.\n\t\t\tif (\n\t\t\t\tcommandCapability.currentCommand?.promptStartMarker &&\n\t\t\t\tcommandCapability.currentCommand.commandExecutedMarker\n\t\t\t) {\n\t\t\t\tmarkers.push(\n\t\t\t\t\tcommandCapability.currentCommand?.promptStartMarker,\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (partialCommandCapability) {\n\t\t\tmarkers.push(...partialCommandCapability.commands);\n\t\t}\n\n\t\tif (markCapability && !skipEmptyCommands) {\n\t\t\tlet next = markCapability.markers().next()?.value;\n\t\t\tconst arr: IMarker[] = [];\n\t\t\twhile (next) {\n\t\t\t\tarr.push(next);\n\t\t\t\tnext = markCapability.markers().next()?.value;\n\t\t\t}\n\t\t\tmarkers = arr;\n\t\t}\n\t\treturn markers;\n\t}\n\n\tprivate _findCommand(\n\t\tmarker: IMarker,\n\t): ITerminalCommand | ICurrentPartialCommand | undefined {\n\t\tconst commandCapability = this._capabilities.get(\n\t\t\tTerminalCapability.CommandDetection,\n\t\t);\n\t\tif (commandCapability) {\n\t\t\tconst command = commandCapability.commands.find(\n\t\t\t\t(e) =>\n\t\t\t\t\te.marker?.line === marker.line ||\n\t\t\t\t\te.promptStartMarker?.line === marker.line,\n\t\t\t);\n\t\t\tif (command) {\n\t\t\t\treturn command;\n\t\t\t}\n\t\t\tif (commandCapability.currentCommand) {\n\t\t\t\treturn commandCapability.currentCommand;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tclear(): void {\n\t\t// Clear the current marker so successive focus/selection actions are performed from the\n\t\t// bottom of the buffer\n\t\tthis._currentMarker = Boundary.Bottom;\n\t\tthis._resetNavigationDecorations();\n\t\tthis._selectionStart = null;\n\t}\n\n\tprivate _resetNavigationDecorations() {\n\t\tif (this._navigationDecorations) {\n\t\t\tdispose(this._navigationDecorations);\n\t\t}\n\t\tthis._navigationDecorations = [];\n\t}\n\n\tprivate _isEmptyCommand(marker: IMarker | Boundary) {\n\t\tif (marker === Boundary.Bottom) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (marker === Boundary.Top) {\n\t\t\treturn !this._getMarkers(true)\n\t\t\t\t.map((e) => e.line)\n\t\t\t\t.includes(0);\n\t\t}\n\n\t\treturn !this._getMarkers(true).includes(marker);\n\t}\n\n\tscrollToPreviousMark(\n\t\tscrollPosition: ScrollPosition = ScrollPosition.Middle,\n\t\tretainSelection = false,\n\t\tskipEmptyCommands = true,\n\t): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tif (!retainSelection) {\n\t\t\tthis._selectionStart = null;\n\t\t}\n\n\t\tlet markerIndex;\n\t\tconst currentLineY =\n\t\t\ttypeof this._currentMarker === \"object\"\n\t\t\t\t? this.getTargetScrollLine(\n\t\t\t\t\t\tthis._currentMarker.line,\n\t\t\t\t\t\tscrollPosition,\n\t\t\t\t\t)\n\t\t\t\t: Math.min(\n\t\t\t\t\t\tgetLine(this._terminal, this._currentMarker),\n\t\t\t\t\t\tthis._terminal.buffer.active.baseY,\n\t\t\t\t\t);\n\t\tconst viewportY = this._terminal.buffer.active.viewportY;\n\t\tif (\n\t\t\ttypeof this._currentMarker === \"object\"\n\t\t\t\t? !this._isMarkerInViewport(this._terminal, this._currentMarker)\n\t\t\t\t: currentLineY !== viewportY\n\t\t) {\n\t\t\t// The user has scrolled, find the line based on the current scroll position. This only\n\t\t\t// works when not retaining selection\n\t\t\tconst markersBelowViewport = this._getMarkers(\n\t\t\t\tskipEmptyCommands,\n\t\t\t).filter((e) => e.line >= viewportY).length;\n\t\t\t// -1 will scroll to the top\n\t\t\tmarkerIndex =\n\t\t\t\tthis._getMarkers(skipEmptyCommands).length -\n\t\t\t\tmarkersBelowViewport -\n\t\t\t\t1;\n\t\t} else if (this._currentMarker === Boundary.Bottom) {\n\t\t\tmarkerIndex = this._getMarkers(skipEmptyCommands).length - 1;\n\t\t} else if (this._currentMarker === Boundary.Top) {\n\t\t\tmarkerIndex = -1;\n\t\t} else if (this._isDisposable) {\n\t\t\tmarkerIndex = this._findPreviousMarker(skipEmptyCommands);\n\t\t\tthis._currentMarker.dispose();\n\t\t\tthis._isDisposable = false;\n\t\t} else if (\n\t\t\tskipEmptyCommands &&\n\t\t\tthis._isEmptyCommand(this._currentMarker)\n\t\t) {\n\t\t\tmarkerIndex = this._findPreviousMarker(true);\n\t\t} else {\n\t\t\tmarkerIndex =\n\t\t\t\tthis._getMarkers(skipEmptyCommands).indexOf(\n\t\t\t\t\tthis._currentMarker,\n\t\t\t\t) - 1;\n\t\t}\n\n\t\tif (markerIndex < 0) {\n\t\t\tthis._currentMarker = Boundary.Top;\n\t\t\tthis._terminal.scrollToTop();\n\t\t\tthis._resetNavigationDecorations();\n\t\t\treturn;\n\t\t}\n\n\t\tthis._currentMarker = this._getMarkers(skipEmptyCommands)[markerIndex];\n\t\tthis._scrollToCommand(this._currentMarker, scrollPosition);\n\t}\n\n\tscrollToNextMark(\n\t\tscrollPosition: ScrollPosition = ScrollPosition.Middle,\n\t\tretainSelection = false,\n\t\tskipEmptyCommands = true,\n\t): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tif (!retainSelection) {\n\t\t\tthis._selectionStart = null;\n\t\t}\n\n\t\tlet markerIndex;\n\t\tconst currentLineY =\n\t\t\ttypeof this._currentMarker === \"object\"\n\t\t\t\t? this.getTargetScrollLine(\n\t\t\t\t\t\tthis._currentMarker.line,\n\t\t\t\t\t\tscrollPosition,\n\t\t\t\t\t)\n\t\t\t\t: Math.min(\n\t\t\t\t\t\tgetLine(this._terminal, this._currentMarker),\n\t\t\t\t\t\tthis._terminal.buffer.active.baseY,\n\t\t\t\t\t);\n\t\tconst viewportY = this._terminal.buffer.active.viewportY;\n\t\tif (\n\t\t\ttypeof this._currentMarker === \"object\"\n\t\t\t\t? !this._isMarkerInViewport(this._terminal, this._currentMarker)\n\t\t\t\t: currentLineY !== viewportY\n\t\t) {\n\t\t\t// The user has scrolled, find the line based on the current scroll position. This only\n\t\t\t// works when not retaining selection\n\t\t\tconst markersAboveViewport = this._getMarkers(\n\t\t\t\tskipEmptyCommands,\n\t\t\t).filter((e) => e.line <= viewportY).length;\n\t\t\t// markers.length will scroll to the bottom\n\t\t\tmarkerIndex = markersAboveViewport;\n\t\t} else if (this._currentMarker === Boundary.Bottom) {\n\t\t\tmarkerIndex = this._getMarkers(skipEmptyCommands).length;\n\t\t} else if (this._currentMarker === Boundary.Top) {\n\t\t\tmarkerIndex = 0;\n\t\t} else if (this._isDisposable) {\n\t\t\tmarkerIndex = this._findNextMarker(skipEmptyCommands);\n\t\t\tthis._currentMarker.dispose();\n\t\t\tthis._isDisposable = false;\n\t\t} else if (\n\t\t\tskipEmptyCommands &&\n\t\t\tthis._isEmptyCommand(this._currentMarker)\n\t\t) {\n\t\t\tmarkerIndex = this._findNextMarker(true);\n\t\t} else {\n\t\t\tmarkerIndex =\n\t\t\t\tthis._getMarkers(skipEmptyCommands).indexOf(\n\t\t\t\t\tthis._currentMarker,\n\t\t\t\t) + 1;\n\t\t}\n\n\t\tif (markerIndex >= this._getMarkers(skipEmptyCommands).length) {\n\t\t\tthis._currentMarker = Boundary.Bottom;\n\t\t\tthis._terminal.scrollToBottom();\n\t\t\tthis._resetNavigationDecorations();\n\t\t\treturn;\n\t\t}\n\n\t\tthis._currentMarker = this._getMarkers(skipEmptyCommands)[markerIndex];\n\t\tthis._scrollToCommand(this._currentMarker, scrollPosition);\n\t}\n\n\tprivate _scrollToCommand(marker: IMarker, position: ScrollPosition): void {\n\t\tconst command = this._findCommand(marker);\n\t\tif (command) {\n\t\t\tthis.revealCommand(command, position);\n\t\t} else {\n\t\t\tthis._scrollToMarker(marker, position);\n\t\t}\n\t}\n\n\tprivate _scrollToMarker(\n\t\tstart: IMarker | number,\n\t\tposition: ScrollPosition,\n\t\tend?: IMarker | number,\n\t\toptions?: IScrollToMarkerOptions,\n\t): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tif (\n\t\t\t!this._isMarkerInViewport(this._terminal, start) ||\n\t\t\toptions?.forceScroll\n\t\t) {\n\t\t\tconst line = this.getTargetScrollLine(toLineIndex(start), position);\n\t\t\tthis._terminal.scrollToLine(line);\n\t\t}\n\t\tif (!options?.hideDecoration) {\n\t\t\tif (options?.bufferRange) {\n\t\t\t\tthis._highlightBufferRange(options.bufferRange);\n\t\t\t} else {\n\t\t\t\tthis.registerTemporaryDecoration(start, end, true);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _createMarkerForOffset(\n\t\tmarker: IMarker | number,\n\t\toffset: number,\n\t): IMarker {\n\t\tif (offset === 0 && isMarker(marker)) {\n\t\t\treturn marker;\n\t\t} else {\n\t\t\tconst offsetMarker = this._terminal?.registerMarker(\n\t\t\t\t-this._terminal.buffer.active.cursorY +\n\t\t\t\t\ttoLineIndex(marker) -\n\t\t\t\t\tthis._terminal.buffer.active.baseY +\n\t\t\t\t\toffset,\n\t\t\t);\n\t\t\tif (offsetMarker) {\n\t\t\t\treturn offsetMarker;\n\t\t\t} else {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Could not register marker with offset ${toLineIndex(marker)}, ${offset}`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\trevealCommand(\n\t\tcommand: ITerminalCommand | ICurrentPartialCommand,\n\t\tposition: ScrollPosition = ScrollPosition.Middle,\n\t): void {\n\t\tconst marker =\n\t\t\t\"getOutput\" in command\n\t\t\t\t? command.marker\n\t\t\t\t: command.commandStartMarker;\n\t\tif (!this._terminal || !marker) {\n\t\t\treturn;\n\t\t}\n\t\tconst line = toLineIndex(marker);\n\t\tconst promptRowCount = command.getPromptRowCount();\n\t\tconst commandRowCount = command.getCommandRowCount();\n\t\tthis._scrollToMarker(\n\t\t\tline - (promptRowCount - 1),\n\t\t\tposition,\n\t\t\tline + (commandRowCount - 1),\n\t\t);\n\t}\n\n\trevealRange(range: IBufferRange): void {\n\t\tthis._scrollToMarker(\n\t\t\trange.start.y - 1,\n\t\t\tScrollPosition.Middle,\n\t\t\trange.end.y - 1,\n\t\t\t{\n\t\t\t\tbufferRange: range,\n\t\t\t\t// Ensure scroll shows the line when sticky scroll is enabled\n\t\t\t\tforceScroll: !!this._configurationService.getValue(\n\t\t\t\t\tTerminalStickyScrollSettingId.Enabled,\n\t\t\t\t),\n\t\t\t},\n\t\t);\n\t}\n\n\tshowCommandGuide(command: ITerminalCommand | undefined): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tif (!command) {\n\t\t\tthis._commandGuideDecorations.clear();\n\t\t\tthis._activeCommandGuide = undefined;\n\t\t\treturn;\n\t\t}\n\t\tif (this._activeCommandGuide === command) {\n\t\t\treturn;\n\t\t}\n\t\tif (command.marker) {\n\t\t\tthis._activeCommandGuide = command;\n\n\t\t\t// Highlight output\n\t\t\tconst store = (this._commandGuideDecorations.value =\n\t\t\t\tnew DisposableStore());\n\t\t\tif (!command.executedMarker || !command.endMarker) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst startLine =\n\t\t\t\tcommand.marker.line - (command.getPromptRowCount() - 1);\n\t\t\tconst decorationCount = toLineIndex(command.endMarker) - startLine;\n\t\t\t// Abort if the command is excessively long to avoid performance on hover/leave\n\t\t\tif (decorationCount > 200) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (let i = 0; i < decorationCount; i++) {\n\t\t\t\tconst decoration = this._terminal.registerDecoration({\n\t\t\t\t\tmarker: this._createMarkerForOffset(startLine, i),\n\t\t\t\t});\n\t\t\t\tif (decoration) {\n\t\t\t\t\tstore.add(decoration);\n\t\t\t\t\tlet renderedElement: HTMLElement | undefined;\n\t\t\t\t\tstore.add(\n\t\t\t\t\t\tdecoration.onRender((element) => {\n\t\t\t\t\t\t\tif (!renderedElement) {\n\t\t\t\t\t\t\t\trenderedElement = element;\n\t\t\t\t\t\t\t\telement.classList.add(\"terminal-command-guide\");\n\t\t\t\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\t\t\t\telement.classList.add(\"top\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (i === decorationCount - 1) {\n\t\t\t\t\t\t\t\t\telement.classList.add(\"bottom\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (this._terminal?.element) {\n\t\t\t\t\t\t\t\telement.style.marginLeft = `-${getWindow(this._terminal.element).getComputedStyle(this._terminal.element).paddingLeft}`;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _scrollState: { viewportY: number } | undefined;\n\n\tsaveScrollState(): void {\n\t\tthis._scrollState = {\n\t\t\tviewportY: this._terminal?.buffer.active.viewportY ?? 0,\n\t\t};\n\t}\n\n\trestoreScrollState(): void {\n\t\tif (this._scrollState && this._terminal) {\n\t\t\tthis._terminal.scrollToLine(this._scrollState.viewportY);\n\t\t\tthis._scrollState = undefined;\n\t\t}\n\t}\n\n\tprivate _highlightBufferRange(range: IBufferRange): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._resetNavigationDecorations();\n\t\tconst startLine = range.start.y;\n\t\tconst decorationCount = range.end.y - range.start.y + 1;\n\t\tfor (let i = 0; i < decorationCount; i++) {\n\t\t\tconst decoration = this._terminal.registerDecoration({\n\t\t\t\tmarker: this._createMarkerForOffset(startLine - 1, i),\n\t\t\t\tx: range.start.x - 1,\n\t\t\t\twidth: range.end.x - 1 - (range.start.x - 1) + 1,\n\t\t\t\toverviewRulerOptions: undefined,\n\t\t\t});\n\t\t\tif (decoration) {\n\t\t\t\tthis._navigationDecorations?.push(decoration);\n\t\t\t\tlet renderedElement: HTMLElement | undefined;\n\n\t\t\t\tdecoration.onRender((element) => {\n\t\t\t\t\tif (!renderedElement) {\n\t\t\t\t\t\trenderedElement = element;\n\t\t\t\t\t\telement.classList.add(\"terminal-range-highlight\");\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tdecoration.onDispose(() => {\n\t\t\t\t\tthis._navigationDecorations =\n\t\t\t\t\t\tthis._navigationDecorations?.filter(\n\t\t\t\t\t\t\t(d) => d !== decoration,\n\t\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\tregisterTemporaryDecoration(\n\t\tmarker: IMarker | number,\n\t\tendMarker: IMarker | number | undefined,\n\t\tshowOutline: boolean,\n\t): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tthis._resetNavigationDecorations();\n\t\tconst color = this._themeService\n\t\t\t.getColorTheme()\n\t\t\t.getColor(TERMINAL_OVERVIEW_RULER_CURSOR_FOREGROUND_COLOR);\n\t\tconst startLine = toLineIndex(marker);\n\t\tconst decorationCount = endMarker\n\t\t\t? toLineIndex(endMarker) - startLine + 1\n\t\t\t: 1;\n\t\tfor (let i = 0; i < decorationCount; i++) {\n\t\t\tconst decoration = this._terminal.registerDecoration({\n\t\t\t\tmarker: this._createMarkerForOffset(marker, i),\n\t\t\t\twidth: this._terminal.cols,\n\t\t\t\toverviewRulerOptions:\n\t\t\t\t\ti === 0\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tcolor: color?.toString() || \"#a0a0a0cc\",\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: undefined,\n\t\t\t});\n\t\t\tif (decoration) {\n\t\t\t\tthis._navigationDecorations?.push(decoration);\n\t\t\t\tlet renderedElement: HTMLElement | undefined;\n\n\t\t\t\tdecoration.onRender((element) => {\n\t\t\t\t\tif (renderedElement) {\n\t\t\t\t\t\telement.classList.add(\"terminal-scroll-highlight\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\trenderedElement = element;\n\t\t\t\t\t\telement.classList.add(\"terminal-scroll-highlight\");\n\t\t\t\t\t\tif (showOutline) {\n\t\t\t\t\t\t\telement.classList.add(\n\t\t\t\t\t\t\t\t\"terminal-scroll-highlight-outline\",\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\t\telement.classList.add(\"top\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (i === decorationCount - 1) {\n\t\t\t\t\t\t\telement.classList.add(\"bottom\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (this._terminal?.element) {\n\t\t\t\t\t\telement.style.marginLeft = `-${getWindow(this._terminal.element).getComputedStyle(this._terminal.element).paddingLeft}`;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t// TODO: This is not efficient for a large decorationCount\n\t\t\t\tdecoration.onDispose(() => {\n\t\t\t\t\tthis._navigationDecorations =\n\t\t\t\t\t\tthis._navigationDecorations?.filter(\n\t\t\t\t\t\t\t(d) => d !== decoration,\n\t\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t\t// Number picked to align with symbol highlight in the editor\n\t\t\t\tif (showOutline) {\n\t\t\t\t\ttimeout(350).then(() => {\n\t\t\t\t\t\tif (renderedElement) {\n\t\t\t\t\t\t\trenderedElement.classList.remove(\n\t\t\t\t\t\t\t\t\"terminal-scroll-highlight-outline\",\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tscrollToLine(line: number, position: ScrollPosition): void {\n\t\tthis._terminal?.scrollToLine(this.getTargetScrollLine(line, position));\n\t}\n\n\tgetTargetScrollLine(line: number, position: ScrollPosition): number {\n\t\t// Middle is treated as 1/4 of the viewport's size because context below is almost always\n\t\t// more important than context above in the terminal.\n\t\tif (this._terminal && position === ScrollPosition.Middle) {\n\t\t\treturn Math.max(line - Math.floor(this._terminal.rows / 4), 0);\n\t\t}\n\t\treturn line;\n\t}\n\n\tprivate _isMarkerInViewport(terminal: Terminal, marker: IMarker | number) {\n\t\tconst viewportY = terminal.buffer.active.viewportY;\n\t\tconst line = toLineIndex(marker);\n\t\treturn line >= viewportY && line < viewportY + terminal.rows;\n\t}\n\n\tscrollToClosestMarker(\n\t\tstartMarkerId: string,\n\t\tendMarkerId?: string,\n\t\thighlight?: boolean | undefined,\n\t): void {\n\t\tconst detectionCapability = this._capabilities.get(\n\t\t\tTerminalCapability.BufferMarkDetection,\n\t\t);\n\t\tif (!detectionCapability) {\n\t\t\treturn;\n\t\t}\n\t\tconst startMarker = detectionCapability.getMark(startMarkerId);\n\t\tif (!startMarker) {\n\t\t\treturn;\n\t\t}\n\t\tconst endMarker = endMarkerId\n\t\t\t? detectionCapability.getMark(endMarkerId)\n\t\t\t: startMarker;\n\t\tthis._scrollToMarker(startMarker, ScrollPosition.Top, endMarker, {\n\t\t\thideDecoration: !highlight,\n\t\t});\n\t}\n\n\tselectToPreviousMark(): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._selectionStart === null) {\n\t\t\tthis._selectionStart = this._currentMarker;\n\t\t}\n\t\tif (this._capabilities.has(TerminalCapability.CommandDetection)) {\n\t\t\tthis.scrollToPreviousMark(ScrollPosition.Middle, true, true);\n\t\t} else {\n\t\t\tthis.scrollToPreviousMark(ScrollPosition.Middle, true, false);\n\t\t}\n\t\tselectLines(this._terminal, this._currentMarker, this._selectionStart);\n\t}\n\n\tselectToNextMark(): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._selectionStart === null) {\n\t\t\tthis._selectionStart = this._currentMarker;\n\t\t}\n\t\tif (this._capabilities.has(TerminalCapability.CommandDetection)) {\n\t\t\tthis.scrollToNextMark(ScrollPosition.Middle, true, true);\n\t\t} else {\n\t\t\tthis.scrollToNextMark(ScrollPosition.Middle, true, false);\n\t\t}\n\t\tselectLines(this._terminal, this._currentMarker, this._selectionStart);\n\t}\n\n\tselectToPreviousLine(): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._selectionStart === null) {\n\t\t\tthis._selectionStart = this._currentMarker;\n\t\t}\n\t\tthis.scrollToPreviousLine(this._terminal, ScrollPosition.Middle, true);\n\t\tselectLines(this._terminal, this._currentMarker, this._selectionStart);\n\t}\n\n\tselectToNextLine(): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._selectionStart === null) {\n\t\t\tthis._selectionStart = this._currentMarker;\n\t\t}\n\t\tthis.scrollToNextLine(this._terminal, ScrollPosition.Middle, true);\n\t\tselectLines(this._terminal, this._currentMarker, this._selectionStart);\n\t}\n\n\tscrollToPreviousLine(\n\t\txterm: Terminal,\n\t\tscrollPosition: ScrollPosition = ScrollPosition.Middle,\n\t\tretainSelection = false,\n\t): void {\n\t\tif (!retainSelection) {\n\t\t\tthis._selectionStart = null;\n\t\t}\n\n\t\tif (this._currentMarker === Boundary.Top) {\n\t\t\txterm.scrollToTop();\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._currentMarker === Boundary.Bottom) {\n\t\t\tthis._currentMarker = this._registerMarkerOrThrow(\n\t\t\t\txterm,\n\t\t\t\tthis._getOffset(xterm) - 1,\n\t\t\t);\n\t\t} else {\n\t\t\tconst offset = this._getOffset(xterm);\n\t\t\tif (this._isDisposable) {\n\t\t\t\tthis._currentMarker.dispose();\n\t\t\t}\n\t\t\tthis._currentMarker = this._registerMarkerOrThrow(\n\t\t\t\txterm,\n\t\t\t\toffset - 1,\n\t\t\t);\n\t\t}\n\t\tthis._isDisposable = true;\n\t\tthis._scrollToMarker(this._currentMarker, scrollPosition);\n\t}\n\n\tscrollToNextLine(\n\t\txterm: Terminal,\n\t\tscrollPosition: ScrollPosition = ScrollPosition.Middle,\n\t\tretainSelection = false,\n\t): void {\n\t\tif (!retainSelection) {\n\t\t\tthis._selectionStart = null;\n\t\t}\n\n\t\tif (this._currentMarker === Boundary.Bottom) {\n\t\t\txterm.scrollToBottom();\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._currentMarker === Boundary.Top) {\n\t\t\tthis._currentMarker = this._registerMarkerOrThrow(\n\t\t\t\txterm,\n\t\t\t\tthis._getOffset(xterm) + 1,\n\t\t\t);\n\t\t} else {\n\t\t\tconst offset = this._getOffset(xterm);\n\t\t\tif (this._isDisposable) {\n\t\t\t\tthis._currentMarker.dispose();\n\t\t\t}\n\t\t\tthis._currentMarker = this._registerMarkerOrThrow(\n\t\t\t\txterm,\n\t\t\t\toffset + 1,\n\t\t\t);\n\t\t}\n\t\tthis._isDisposable = true;\n\t\tthis._scrollToMarker(this._currentMarker, scrollPosition);\n\t}\n\n\tprivate _registerMarkerOrThrow(\n\t\txterm: Terminal,\n\t\tcursorYOffset: number,\n\t): IMarker {\n\t\tconst marker = xterm.registerMarker(cursorYOffset);\n\t\tif (!marker) {\n\t\t\tthrow new Error(`Could not create marker for ${cursorYOffset}`);\n\t\t}\n\t\treturn marker;\n\t}\n\n\tprivate _getOffset(xterm: Terminal): number {\n\t\tif (this._currentMarker === Boundary.Bottom) {\n\t\t\treturn 0;\n\t\t} else if (this._currentMarker === Boundary.Top) {\n\t\t\treturn (\n\t\t\t\t0 - (xterm.buffer.active.baseY + xterm.buffer.active.cursorY)\n\t\t\t);\n\t\t} else {\n\t\t\tlet offset = getLine(xterm, this._currentMarker);\n\t\t\toffset -= xterm.buffer.active.baseY + xterm.buffer.active.cursorY;\n\t\t\treturn offset;\n\t\t}\n\t}\n\n\tprivate _findPreviousMarker(skipEmptyCommands = false): number {\n\t\tif (this._currentMarker === Boundary.Top) {\n\t\t\treturn 0;\n\t\t} else if (this._currentMarker === Boundary.Bottom) {\n\t\t\treturn this._getMarkers(skipEmptyCommands).length - 1;\n\t\t}\n\n\t\tlet i;\n\t\tfor (i = this._getMarkers(skipEmptyCommands).length - 1; i >= 0; i--) {\n\t\t\tif (\n\t\t\t\tthis._getMarkers(skipEmptyCommands)[i].line <\n\t\t\t\tthis._currentMarker.line\n\t\t\t) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tprivate _findNextMarker(skipEmptyCommands = false): number {\n\t\tif (this._currentMarker === Boundary.Top) {\n\t\t\treturn 0;\n\t\t} else if (this._currentMarker === Boundary.Bottom) {\n\t\t\treturn this._getMarkers(skipEmptyCommands).length - 1;\n\t\t}\n\n\t\tlet i;\n\t\tfor (i = 0; i < this._getMarkers(skipEmptyCommands).length; i++) {\n\t\t\tif (\n\t\t\t\tthis._getMarkers(skipEmptyCommands)[i].line >\n\t\t\t\tthis._currentMarker.line\n\t\t\t) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\treturn this._getMarkers(skipEmptyCommands).length;\n\t}\n}\n\nexport function getLine(xterm: Terminal, marker: IMarker | Boundary): number {\n\t// Use the _second last_ row as the last row is likely the prompt\n\tif (marker === Boundary.Bottom) {\n\t\treturn xterm.buffer.active.baseY + xterm.rows - 1;\n\t}\n\n\tif (marker === Boundary.Top) {\n\t\treturn 0;\n\t}\n\n\treturn marker.line;\n}\n\nexport function selectLines(\n\txterm: Terminal,\n\tstart: IMarker | Boundary,\n\tend: IMarker | Boundary | null,\n): void {\n\tif (end === null) {\n\t\tend = Boundary.Bottom;\n\t}\n\n\tlet startLine = getLine(xterm, start);\n\tlet endLine = getLine(xterm, end);\n\n\tif (startLine > endLine) {\n\t\tconst temp = startLine;\n\t\tstartLine = endLine;\n\t\tendLine = temp;\n\t}\n\n\t// Subtract a line as the marker is on the line the command run, we do not want the next\n\t// command in the selection for the current command\n\tendLine -= 1;\n\n\txterm.selectLines(startLine, endLine);\n}\n\nfunction isMarker(value: IMarker | number): value is IMarker {\n\treturn typeof value !== \"number\";\n}\n\nfunction toLineIndex(line: IMarker | number): number {\n\treturn isMarker(line) ? line.line : line;\n}\n"],
  "mappings": "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",
  "names": ["Boundary", "ScrollPosition"]
}
