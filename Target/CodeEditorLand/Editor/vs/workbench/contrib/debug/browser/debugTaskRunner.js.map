{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/debug/browser/debugTaskRunner.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Action } from '../../../../base/common/actions.js';\nimport { disposableTimeout } from '../../../../base/common/async.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { createErrorWithActions } from '../../../../base/common/errorMessage.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { DisposableStore, IDisposable } from '../../../../base/common/lifecycle.js';\nimport severity from '../../../../base/common/severity.js';\nimport * as nls from '../../../../nls.js';\nimport { ICommandService } from '../../../../platform/commands/common/commands.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { IDialogService } from '../../../../platform/dialogs/common/dialogs.js';\nimport { IMarkerService, MarkerSeverity } from '../../../../platform/markers/common/markers.js';\nimport { IProgressService, ProgressLocation } from '../../../../platform/progress/common/progress.js';\nimport { IStorageService, StorageScope, StorageTarget } from '../../../../platform/storage/common/storage.js';\nimport { IWorkspace, IWorkspaceFolder } from '../../../../platform/workspace/common/workspace.js';\nimport { DEBUG_CONFIGURE_COMMAND_ID, DEBUG_CONFIGURE_LABEL } from './debugCommands.js';\nimport { IDebugConfiguration } from '../common/debug.js';\nimport { Markers } from '../../markers/common/markers.js';\nimport { ConfiguringTask, CustomTask, ITaskEvent, ITaskIdentifier, Task, TaskEventKind } from '../../tasks/common/tasks.js';\nimport { ITaskService, ITaskSummary } from '../../tasks/common/taskService.js';\nimport { IViewsService } from '../../../services/views/common/viewsService.js';\n\nconst onceFilter = (event: Event<ITaskEvent>, filter: (e: ITaskEvent) => boolean) => Event.once(Event.filter(event, filter));\n\nexport const enum TaskRunResult {\n\tFailure,\n\tSuccess\n}\n\nconst DEBUG_TASK_ERROR_CHOICE_KEY = 'debug.taskerrorchoice';\nconst ABORT_LABEL = nls.localize('abort', \"Abort\");\nconst DEBUG_ANYWAY_LABEL = nls.localize({ key: 'debugAnyway', comment: ['&& denotes a mnemonic'] }, \"&&Debug Anyway\");\nconst DEBUG_ANYWAY_LABEL_NO_MEMO = nls.localize('debugAnywayNoMemo', \"Debug Anyway\");\n\ninterface IRunnerTaskSummary extends ITaskSummary {\n\tcancelled?: boolean;\n}\n\nexport class DebugTaskRunner implements IDisposable {\n\n\tprivate globalCancellation = new CancellationTokenSource();\n\n\tconstructor(\n\t\t@ITaskService private readonly taskService: ITaskService,\n\t\t@IMarkerService private readonly markerService: IMarkerService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t\t@IViewsService private readonly viewsService: IViewsService,\n\t\t@IDialogService private readonly dialogService: IDialogService,\n\t\t@IStorageService private readonly storageService: IStorageService,\n\t\t@ICommandService private readonly commandService: ICommandService,\n\t\t@IProgressService private readonly progressService: IProgressService,\n\t) { }\n\n\tcancel(): void {\n\t\tthis.globalCancellation.dispose(true);\n\t\tthis.globalCancellation = new CancellationTokenSource();\n\t}\n\n\tpublic dispose(): void {\n\t\tthis.globalCancellation.dispose(true);\n\t}\n\n\tasync runTaskAndCheckErrors(\n\t\troot: IWorkspaceFolder | IWorkspace | undefined,\n\t\ttaskId: string | ITaskIdentifier | undefined,\n\t): Promise<TaskRunResult> {\n\t\ttry {\n\t\t\tconst taskSummary = await this.runTask(root, taskId, this.globalCancellation.token);\n\t\t\tif (taskSummary && (taskSummary.exitCode === undefined || taskSummary.cancelled)) {\n\t\t\t\t// User canceled, either debugging, or the prelaunch task\n\t\t\t\treturn TaskRunResult.Failure;\n\t\t\t}\n\n\t\t\tconst errorCount = taskId ? this.markerService.read({ severities: MarkerSeverity.Error, take: 2 }).length : 0;\n\t\t\tconst successExitCode = taskSummary && taskSummary.exitCode === 0;\n\t\t\tconst failureExitCode = taskSummary && taskSummary.exitCode !== 0;\n\t\t\tconst onTaskErrors = this.configurationService.getValue<IDebugConfiguration>('debug').onTaskErrors;\n\t\t\tif (successExitCode || onTaskErrors === 'debugAnyway' || (errorCount === 0 && !failureExitCode)) {\n\t\t\t\treturn TaskRunResult.Success;\n\t\t\t}\n\t\t\tif (onTaskErrors === 'showErrors') {\n\t\t\t\tawait this.viewsService.openView(Markers.MARKERS_VIEW_ID, true);\n\t\t\t\treturn Promise.resolve(TaskRunResult.Failure);\n\t\t\t}\n\t\t\tif (onTaskErrors === 'abort') {\n\t\t\t\treturn Promise.resolve(TaskRunResult.Failure);\n\t\t\t}\n\n\t\t\tconst taskLabel = typeof taskId === 'string' ? taskId : taskId ? taskId.name : '';\n\t\t\tconst message = errorCount > 1\n\t\t\t\t? nls.localize('preLaunchTaskErrors', \"Errors exist after running preLaunchTask '{0}'.\", taskLabel)\n\t\t\t\t: errorCount === 1\n\t\t\t\t\t? nls.localize('preLaunchTaskError', \"Error exists after running preLaunchTask '{0}'.\", taskLabel)\n\t\t\t\t\t: taskSummary && typeof taskSummary.exitCode === 'number'\n\t\t\t\t\t\t? nls.localize('preLaunchTaskExitCode', \"The preLaunchTask '{0}' terminated with exit code {1}.\", taskLabel, taskSummary.exitCode)\n\t\t\t\t\t\t: nls.localize('preLaunchTaskTerminated', \"The preLaunchTask '{0}' terminated.\", taskLabel);\n\n\t\t\tenum DebugChoice {\n\t\t\t\tDebugAnyway = 1,\n\t\t\t\tShowErrors = 2,\n\t\t\t\tCancel = 0\n\t\t\t}\n\t\t\tconst { result, checkboxChecked } = await this.dialogService.prompt<DebugChoice>({\n\t\t\t\ttype: severity.Warning,\n\t\t\t\tmessage,\n\t\t\t\tbuttons: [\n\t\t\t\t\t{\n\t\t\t\t\t\tlabel: DEBUG_ANYWAY_LABEL,\n\t\t\t\t\t\trun: () => DebugChoice.DebugAnyway\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tlabel: nls.localize({ key: 'showErrors', comment: ['&& denotes a mnemonic'] }, \"&&Show Errors\"),\n\t\t\t\t\t\trun: () => DebugChoice.ShowErrors\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\tcancelButton: {\n\t\t\t\t\tlabel: ABORT_LABEL,\n\t\t\t\t\trun: () => DebugChoice.Cancel\n\t\t\t\t},\n\t\t\t\tcheckbox: {\n\t\t\t\t\tlabel: nls.localize('remember', \"Remember my choice in user settings\"),\n\t\t\t\t}\n\t\t\t});\n\n\n\t\t\tconst debugAnyway = result === DebugChoice.DebugAnyway;\n\t\t\tconst abort = result === DebugChoice.Cancel;\n\t\t\tif (checkboxChecked) {\n\t\t\t\tthis.configurationService.updateValue('debug.onTaskErrors', result === DebugChoice.DebugAnyway ? 'debugAnyway' : abort ? 'abort' : 'showErrors');\n\t\t\t}\n\n\t\t\tif (abort) {\n\t\t\t\treturn Promise.resolve(TaskRunResult.Failure);\n\t\t\t}\n\t\t\tif (debugAnyway) {\n\t\t\t\treturn TaskRunResult.Success;\n\t\t\t}\n\n\t\t\tawait this.viewsService.openView(Markers.MARKERS_VIEW_ID, true);\n\t\t\treturn Promise.resolve(TaskRunResult.Failure);\n\t\t} catch (err) {\n\t\t\tconst taskConfigureAction = this.taskService.configureAction();\n\t\t\tconst choiceMap: { [key: string]: number } = JSON.parse(this.storageService.get(DEBUG_TASK_ERROR_CHOICE_KEY, StorageScope.WORKSPACE, '{}'));\n\n\t\t\tlet choice = -1;\n\t\t\tenum DebugChoice {\n\t\t\t\tDebugAnyway = 0,\n\t\t\t\tConfigureTask = 1,\n\t\t\t\tCancel = 2\n\t\t\t}\n\t\t\tif (choiceMap[err.message] !== undefined) {\n\t\t\t\tchoice = choiceMap[err.message];\n\t\t\t} else {\n\t\t\t\tconst { result, checkboxChecked } = await this.dialogService.prompt<DebugChoice>({\n\t\t\t\t\ttype: severity.Error,\n\t\t\t\t\tmessage: err.message,\n\t\t\t\t\tbuttons: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlabel: nls.localize({ key: 'debugAnyway', comment: ['&& denotes a mnemonic'] }, \"&&Debug Anyway\"),\n\t\t\t\t\t\t\trun: () => DebugChoice.DebugAnyway\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlabel: taskConfigureAction.label,\n\t\t\t\t\t\t\trun: () => DebugChoice.ConfigureTask\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\tcancelButton: {\n\t\t\t\t\t\trun: () => DebugChoice.Cancel\n\t\t\t\t\t},\n\t\t\t\t\tcheckbox: {\n\t\t\t\t\t\tlabel: nls.localize('rememberTask', \"Remember my choice for this task\")\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tchoice = result;\n\t\t\t\tif (checkboxChecked) {\n\t\t\t\t\tchoiceMap[err.message] = choice;\n\t\t\t\t\tthis.storageService.store(DEBUG_TASK_ERROR_CHOICE_KEY, JSON.stringify(choiceMap), StorageScope.WORKSPACE, StorageTarget.MACHINE);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (choice === DebugChoice.ConfigureTask) {\n\t\t\t\tawait taskConfigureAction.run();\n\t\t\t}\n\n\t\t\treturn choice === DebugChoice.DebugAnyway ? TaskRunResult.Success : TaskRunResult.Failure;\n\t\t}\n\t}\n\n\tasync runTask(root: IWorkspace | IWorkspaceFolder | undefined, taskId: string | ITaskIdentifier | undefined, token = this.globalCancellation.token): Promise<IRunnerTaskSummary | null> {\n\t\tif (!taskId) {\n\t\t\treturn Promise.resolve(null);\n\t\t}\n\t\tif (!root) {\n\t\t\treturn Promise.reject(new Error(nls.localize('invalidTaskReference', \"Task '{0}' can not be referenced from a launch configuration that is in a different workspace folder.\", typeof taskId === 'string' ? taskId : taskId.type)));\n\t\t}\n\t\t// run a task before starting a debug session\n\t\tconst task = await this.taskService.getTask(root, taskId);\n\t\tif (!task) {\n\t\t\tconst errorMessage = typeof taskId === 'string'\n\t\t\t\t? nls.localize('DebugTaskNotFoundWithTaskId', \"Could not find the task '{0}'.\", taskId)\n\t\t\t\t: nls.localize('DebugTaskNotFound', \"Could not find the specified task.\");\n\t\t\treturn Promise.reject(createErrorWithActions(errorMessage, [new Action(DEBUG_CONFIGURE_COMMAND_ID, DEBUG_CONFIGURE_LABEL, undefined, true, () => this.commandService.executeCommand(DEBUG_CONFIGURE_COMMAND_ID))]));\n\t\t}\n\n\t\t// If a task is missing the problem matcher the promise will never complete, so we need to have a workaround #35340\n\t\tlet taskStarted = false;\n\t\tconst store = new DisposableStore();\n\t\tconst getTaskKey = (t: Task) => t.getKey() ?? t.getMapKey();\n\t\tconst taskKey = getTaskKey(task);\n\t\tconst inactivePromise: Promise<ITaskSummary | null> = new Promise((resolve) => store.add(\n\t\t\tonceFilter(this.taskService.onDidStateChange, e => {\n\t\t\t\t// When a task isBackground it will go inactive when it is safe to launch.\n\t\t\t\t// But when a background task is terminated by the user, it will also fire an inactive event.\n\t\t\t\t// This means that we will not get to see the real exit code from running the task (undefined when terminated by the user).\n\t\t\t\t// Catch the ProcessEnded event here, which occurs before inactive, and capture the exit code to prevent this.\n\t\t\t\treturn (e.kind === TaskEventKind.Inactive\n\t\t\t\t\t|| (e.kind === TaskEventKind.ProcessEnded && e.exitCode === undefined))\n\t\t\t\t\t&& getTaskKey(e.__task) === taskKey;\n\t\t\t})(e => {\n\t\t\t\ttaskStarted = true;\n\t\t\t\tresolve(e.kind === TaskEventKind.ProcessEnded ? { exitCode: e.exitCode } : null);\n\t\t\t}),\n\t\t));\n\n\t\tstore.add(\n\t\t\tonceFilter(this.taskService.onDidStateChange, e => ((e.kind === TaskEventKind.Active) || (e.kind === TaskEventKind.DependsOnStarted)) && getTaskKey(e.__task) === taskKey\n\t\t\t)(() => {\n\t\t\t\t// Task is active, so everything seems to be fine, no need to prompt after 10 seconds\n\t\t\t\t// Use case being a slow running task should not be prompted even though it takes more than 10 seconds\n\t\t\t\ttaskStarted = true;\n\t\t\t})\n\t\t);\n\n\t\tconst didAcquireInput = store.add(new Emitter<void>());\n\t\tstore.add(onceFilter(\n\t\t\tthis.taskService.onDidStateChange,\n\t\t\te => (e.kind === TaskEventKind.AcquiredInput) && getTaskKey(e.__task) === taskKey\n\t\t)(() => didAcquireInput.fire()));\n\n\t\tconst taskDonePromise: Promise<ITaskSummary | null> = this.taskService.getActiveTasks().then(async (tasks): Promise<ITaskSummary | null> => {\n\t\t\tif (tasks.find(t => getTaskKey(t) === taskKey)) {\n\t\t\t\tdidAcquireInput.fire();\n\t\t\t\t// Check that the task isn't busy and if it is, wait for it\n\t\t\t\tconst busyTasks = await this.taskService.getBusyTasks();\n\t\t\t\tif (busyTasks.find(t => getTaskKey(t) === taskKey)) {\n\t\t\t\t\ttaskStarted = true;\n\t\t\t\t\treturn inactivePromise;\n\t\t\t\t}\n\t\t\t\t// task is already running and isn't busy - nothing to do.\n\t\t\t\treturn Promise.resolve(null);\n\t\t\t}\n\n\t\t\tconst taskPromise = this.taskService.run(task);\n\t\t\tif (task.configurationProperties.isBackground) {\n\t\t\t\treturn inactivePromise;\n\t\t\t}\n\n\t\t\treturn taskPromise.then(x => x ?? null);\n\t\t});\n\n\t\tconst result = new Promise<IRunnerTaskSummary | null>((resolve, reject) => {\n\t\t\ttaskDonePromise.then(result => {\n\t\t\t\ttaskStarted = true;\n\t\t\t\tresolve(result);\n\t\t\t}, error => reject(error));\n\n\t\t\tstore.add(token.onCancellationRequested(() => {\n\t\t\t\tresolve({ exitCode: undefined, cancelled: true });\n\t\t\t\tthis.taskService.terminate(task).catch(() => { });\n\t\t\t}));\n\n\t\t\t// Start the timeouts once a terminal has been acquired\n\t\t\tstore.add(didAcquireInput.event(() => {\n\t\t\t\tconst waitTime = task.configurationProperties.isBackground ? 5000 : 10000;\n\n\t\t\t\t// Error shown if there's a background task with no problem matcher that doesn't exit quickly\n\t\t\t\tstore.add(disposableTimeout(() => {\n\t\t\t\t\tif (!taskStarted) {\n\t\t\t\t\t\tconst errorMessage = nls.localize('taskNotTracked', \"The task '{0}' has not exited and doesn't have a 'problemMatcher' defined. Make sure to define a problem matcher for watch tasks.\", typeof taskId === 'string' ? taskId : JSON.stringify(taskId));\n\t\t\t\t\t\treject({ severity: severity.Error, message: errorMessage });\n\t\t\t\t\t}\n\t\t\t\t}, waitTime));\n\n\t\t\t\t// Notification shown on any task taking a while to resolve\n\t\t\t\tstore.add(disposableTimeout(() => {\n\t\t\t\t\tconst message = nls.localize('runningTask', \"Waiting for preLaunchTask '{0}'...\", task.configurationProperties.name);\n\t\t\t\t\tconst buttons = [DEBUG_ANYWAY_LABEL_NO_MEMO, ABORT_LABEL];\n\t\t\t\t\tconst canConfigure = task instanceof CustomTask || task instanceof ConfiguringTask;\n\t\t\t\t\tif (canConfigure) {\n\t\t\t\t\t\tbuttons.splice(1, 0, nls.localize('configureTask', \"Configure Task\"));\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.progressService.withProgress(\n\t\t\t\t\t\t{ location: ProgressLocation.Notification, title: message, buttons },\n\t\t\t\t\t\t() => result.catch(() => { }),\n\t\t\t\t\t\t(choice) => {\n\t\t\t\t\t\t\tif (choice === undefined) {\n\t\t\t\t\t\t\t\t// no-op, keep waiting\n\t\t\t\t\t\t\t} else if (choice === 0) { // debug anyway\n\t\t\t\t\t\t\t\tresolve({ exitCode: 0 });\n\t\t\t\t\t\t\t} else { // abort or configure\n\t\t\t\t\t\t\t\tresolve({ exitCode: undefined, cancelled: true });\n\t\t\t\t\t\t\t\tthis.taskService.terminate(task).catch(() => { });\n\t\t\t\t\t\t\t\tif (canConfigure && choice === 1) { // configure\n\t\t\t\t\t\t\t\t\tthis.taskService.openConfig(task as CustomTask);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}, 10_000));\n\t\t\t}));\n\t\t});\n\n\t\treturn result.finally(() => store.dispose());\n\t}\n}\n"],
  "mappings": ";;;;;;;;;;;;AAKA,SAAS,cAAc;AACvB,SAAS,yBAAyB;AAClC,SAAS,+BAA+B;AACxC,SAAS,8BAA8B;AACvC,SAAS,SAAS,aAAa;AAC/B,SAAS,iBAAiB,mBAAmB;AAC7C,OAAO,cAAc;AACrB,YAAY,SAAS;AACrB,SAAS,uBAAuB;AAChC,SAAS,6BAA6B;AACtC,SAAS,sBAAsB;AAC/B,SAAS,gBAAgB,sBAAsB;AAC/C,SAAS,kBAAkB,wBAAwB;AACnD,SAAS,iBAAiB,cAAc,qBAAqB;AAC7D,SAAS,YAAY,wBAAwB;AAC7C,SAAS,4BAA4B,6BAA6B;AAClE,SAAS,2BAA2B;AACpC,SAAS,eAAe;AACxB,SAAS,iBAAiB,YAAY,YAAY,iBAAiB,MAAM,qBAAqB;AAC9F,SAAS,cAAc,oBAAoB;AAC3C,SAAS,qBAAqB;AAE9B,MAAM,aAAa,wBAAC,OAA0B,WAAuC,MAAM,KAAK,MAAM,OAAO,OAAO,MAAM,CAAC,GAAxG;AAEZ,IAAW,gBAAX,kBAAWA,mBAAX;AACN,EAAAA,8BAAA;AACA,EAAAA,8BAAA;AAFiB,SAAAA;AAAA,GAAA;AAKlB,MAAM,8BAA8B;AACpC,MAAM,cAAc,IAAI,SAAS,SAAS,OAAO;AACjD,MAAM,qBAAqB,IAAI,SAAS,EAAE,KAAK,eAAe,SAAS,CAAC,uBAAuB,EAAE,GAAG,gBAAgB;AACpH,MAAM,6BAA6B,IAAI,SAAS,qBAAqB,cAAc;AAM5E,IAAM,kBAAN,MAA6C;AAAA,EAInD,YACgC,aACE,eACO,sBACR,cACC,eACC,gBACA,gBACC,iBAClC;AAR8B;AACE;AACO;AACR;AACC;AACC;AACA;AACC;AAAA,EAChC;AAAA,EAxDL,OA2CoD;AAAA;AAAA;AAAA,EAE3C,qBAAqB,IAAI,wBAAwB;AAAA,EAazD,SAAe;AACd,SAAK,mBAAmB,QAAQ,IAAI;AACpC,SAAK,qBAAqB,IAAI,wBAAwB;AAAA,EACvD;AAAA,EAEO,UAAgB;AACtB,SAAK,mBAAmB,QAAQ,IAAI;AAAA,EACrC;AAAA,EAEA,MAAM,sBACL,MACA,QACyB;AACzB,QAAI;AACH,YAAM,cAAc,MAAM,KAAK,QAAQ,MAAM,QAAQ,KAAK,mBAAmB,KAAK;AAClF,UAAI,gBAAgB,YAAY,aAAa,UAAa,YAAY,YAAY;AAEjF,eAAO;AAAA,MACR;AAEA,YAAM,aAAa,SAAS,KAAK,cAAc,KAAK,EAAE,YAAY,eAAe,OAAO,MAAM,EAAE,CAAC,EAAE,SAAS;AAC5G,YAAM,kBAAkB,eAAe,YAAY,aAAa;AAChE,YAAM,kBAAkB,eAAe,YAAY,aAAa;AAChE,YAAM,eAAe,KAAK,qBAAqB,SAA8B,OAAO,EAAE;AACtF,UAAI,mBAAmB,iBAAiB,iBAAkB,eAAe,KAAK,CAAC,iBAAkB;AAChG,eAAO;AAAA,MACR;AACA,UAAI,iBAAiB,cAAc;AAClC,cAAM,KAAK,aAAa,SAAS,QAAQ,iBAAiB,IAAI;AAC9D,eAAO,QAAQ,QAAQ,eAAqB;AAAA,MAC7C;AACA,UAAI,iBAAiB,SAAS;AAC7B,eAAO,QAAQ,QAAQ,eAAqB;AAAA,MAC7C;AAEA,YAAM,YAAY,OAAO,WAAW,WAAW,SAAS,SAAS,OAAO,OAAO;AAC/E,YAAM,UAAU,aAAa,IAC1B,IAAI,SAAS,uBAAuB,mDAAmD,SAAS,IAChG,eAAe,IACd,IAAI,SAAS,sBAAsB,mDAAmD,SAAS,IAC/F,eAAe,OAAO,YAAY,aAAa,WAC9C,IAAI,SAAS,yBAAyB,0DAA0D,WAAW,YAAY,QAAQ,IAC/H,IAAI,SAAS,2BAA2B,uCAAuC,SAAS;AAE7F,UAAK;AAAL,QAAKC,iBAAL;AACC,QAAAA,0BAAA,iBAAc,KAAd;AACA,QAAAA,0BAAA,gBAAa,KAAb;AACA,QAAAA,0BAAA,YAAS,KAAT;AAAA,SAHI;AAKL,YAAM,EAAE,QAAQ,gBAAgB,IAAI,MAAM,KAAK,cAAc,OAAoB;AAAA,QAChF,MAAM,SAAS;AAAA,QACf;AAAA,QACA,SAAS;AAAA,UACR;AAAA,YACC,OAAO;AAAA,YACP,KAAK,6BAAM,qBAAN;AAAA,UACN;AAAA,UACA;AAAA,YACC,OAAO,IAAI,SAAS,EAAE,KAAK,cAAc,SAAS,CAAC,uBAAuB,EAAE,GAAG,eAAe;AAAA,YAC9F,KAAK,6BAAM,oBAAN;AAAA,UACN;AAAA,QACD;AAAA,QACA,cAAc;AAAA,UACb,OAAO;AAAA,UACP,KAAK,6BAAM,gBAAN;AAAA,QACN;AAAA,QACA,UAAU;AAAA,UACT,OAAO,IAAI,SAAS,YAAY,qCAAqC;AAAA,QACtE;AAAA,MACD,CAAC;AAGD,YAAM,cAAc,WAAW;AAC/B,YAAM,QAAQ,WAAW;AACzB,UAAI,iBAAiB;AACpB,aAAK,qBAAqB,YAAY,sBAAsB,WAAW,sBAA0B,gBAAgB,QAAQ,UAAU,YAAY;AAAA,MAChJ;AAEA,UAAI,OAAO;AACV,eAAO,QAAQ,QAAQ,eAAqB;AAAA,MAC7C;AACA,UAAI,aAAa;AAChB,eAAO;AAAA,MACR;AAEA,YAAM,KAAK,aAAa,SAAS,QAAQ,iBAAiB,IAAI;AAC9D,aAAO,QAAQ,QAAQ,eAAqB;AAAA,IAC7C,SAAS,KAAK;AACb,YAAM,sBAAsB,KAAK,YAAY,gBAAgB;AAC7D,YAAM,YAAuC,KAAK,MAAM,KAAK,eAAe,IAAI,6BAA6B,aAAa,WAAW,IAAI,CAAC;AAE1I,UAAI,SAAS;AACb,UAAK;AAAL,QAAKA,iBAAL;AACC,QAAAA,0BAAA,iBAAc,KAAd;AACA,QAAAA,0BAAA,mBAAgB,KAAhB;AACA,QAAAA,0BAAA,YAAS,KAAT;AAAA,SAHI;AAKL,UAAI,UAAU,IAAI,OAAO,MAAM,QAAW;AACzC,iBAAS,UAAU,IAAI,OAAO;AAAA,MAC/B,OAAO;AACN,cAAM,EAAE,QAAQ,gBAAgB,IAAI,MAAM,KAAK,cAAc,OAAoB;AAAA,UAChF,MAAM,SAAS;AAAA,UACf,SAAS,IAAI;AAAA,UACb,SAAS;AAAA,YACR;AAAA,cACC,OAAO,IAAI,SAAS,EAAE,KAAK,eAAe,SAAS,CAAC,uBAAuB,EAAE,GAAG,gBAAgB;AAAA,cAChG,KAAK,6BAAM,qBAAN;AAAA,YACN;AAAA,YACA;AAAA,cACC,OAAO,oBAAoB;AAAA,cAC3B,KAAK,6BAAM,uBAAN;AAAA,YACN;AAAA,UACD;AAAA,UACA,cAAc;AAAA,YACb,KAAK,6BAAM,gBAAN;AAAA,UACN;AAAA,UACA,UAAU;AAAA,YACT,OAAO,IAAI,SAAS,gBAAgB,kCAAkC;AAAA,UACvE;AAAA,QACD,CAAC;AACD,iBAAS;AACT,YAAI,iBAAiB;AACpB,oBAAU,IAAI,OAAO,IAAI;AACzB,eAAK,eAAe,MAAM,6BAA6B,KAAK,UAAU,SAAS,GAAG,aAAa,WAAW,cAAc,OAAO;AAAA,QAChI;AAAA,MACD;AAEA,UAAI,WAAW,uBAA2B;AACzC,cAAM,oBAAoB,IAAI;AAAA,MAC/B;AAEA,aAAO,WAAW,sBAA0B,kBAAwB;AAAA,IACrE;AAAA,EACD;AAAA,EAEA,MAAM,QAAQ,MAAiD,QAA8C,QAAQ,KAAK,mBAAmB,OAA2C;AACvL,QAAI,CAAC,QAAQ;AACZ,aAAO,QAAQ,QAAQ,IAAI;AAAA,IAC5B;AACA,QAAI,CAAC,MAAM;AACV,aAAO,QAAQ,OAAO,IAAI,MAAM,IAAI,SAAS,wBAAwB,yGAAyG,OAAO,WAAW,WAAW,SAAS,OAAO,IAAI,CAAC,CAAC;AAAA,IAClO;AAEA,UAAM,OAAO,MAAM,KAAK,YAAY,QAAQ,MAAM,MAAM;AACxD,QAAI,CAAC,MAAM;AACV,YAAM,eAAe,OAAO,WAAW,WACpC,IAAI,SAAS,+BAA+B,kCAAkC,MAAM,IACpF,IAAI,SAAS,qBAAqB,oCAAoC;AACzE,aAAO,QAAQ,OAAO,uBAAuB,cAAc,CAAC,IAAI,OAAO,4BAA4B,uBAAuB,QAAW,MAAM,MAAM,KAAK,eAAe,eAAe,0BAA0B,CAAC,CAAC,CAAC,CAAC;AAAA,IACnN;AAGA,QAAI,cAAc;AAClB,UAAM,QAAQ,IAAI,gBAAgB;AAClC,UAAM,aAAa,wBAAC,MAAY,EAAE,OAAO,KAAK,EAAE,UAAU,GAAvC;AACnB,UAAM,UAAU,WAAW,IAAI;AAC/B,UAAM,kBAAgD,IAAI,QAAQ,CAAC,YAAY,MAAM;AAAA,MACpF,WAAW,KAAK,YAAY,kBAAkB,OAAK;AAKlD,gBAAQ,EAAE,SAAS,cAAc,YAC5B,EAAE,SAAS,cAAc,gBAAgB,EAAE,aAAa,WACzD,WAAW,EAAE,MAAM,MAAM;AAAA,MAC9B,CAAC,EAAE,OAAK;AACP,sBAAc;AACd,gBAAQ,EAAE,SAAS,cAAc,eAAe,EAAE,UAAU,EAAE,SAAS,IAAI,IAAI;AAAA,MAChF,CAAC;AAAA,IACF,CAAC;AAED,UAAM;AAAA,MACL;AAAA,QAAW,KAAK,YAAY;AAAA,QAAkB,QAAO,EAAE,SAAS,cAAc,UAAY,EAAE,SAAS,cAAc,qBAAsB,WAAW,EAAE,MAAM,MAAM;AAAA,MAClK,EAAE,MAAM;AAGP,sBAAc;AAAA,MACf,CAAC;AAAA,IACF;AAEA,UAAM,kBAAkB,MAAM,IAAI,IAAI,QAAc,CAAC;AACrD,UAAM,IAAI;AAAA,MACT,KAAK,YAAY;AAAA,MACjB,OAAM,EAAE,SAAS,cAAc,iBAAkB,WAAW,EAAE,MAAM,MAAM;AAAA,IAC3E,EAAE,MAAM,gBAAgB,KAAK,CAAC,CAAC;AAE/B,UAAM,kBAAgD,KAAK,YAAY,eAAe,EAAE,KAAK,OAAO,UAAwC;AAC3I,UAAI,MAAM,KAAK,OAAK,WAAW,CAAC,MAAM,OAAO,GAAG;AAC/C,wBAAgB,KAAK;AAErB,cAAM,YAAY,MAAM,KAAK,YAAY,aAAa;AACtD,YAAI,UAAU,KAAK,OAAK,WAAW,CAAC,MAAM,OAAO,GAAG;AACnD,wBAAc;AACd,iBAAO;AAAA,QACR;AAEA,eAAO,QAAQ,QAAQ,IAAI;AAAA,MAC5B;AAEA,YAAM,cAAc,KAAK,YAAY,IAAI,IAAI;AAC7C,UAAI,KAAK,wBAAwB,cAAc;AAC9C,eAAO;AAAA,MACR;AAEA,aAAO,YAAY,KAAK,OAAK,KAAK,IAAI;AAAA,IACvC,CAAC;AAED,UAAM,SAAS,IAAI,QAAmC,CAAC,SAAS,WAAW;AAC1E,sBAAgB,KAAK,CAAAC,YAAU;AAC9B,sBAAc;AACd,gBAAQA,OAAM;AAAA,MACf,GAAG,WAAS,OAAO,KAAK,CAAC;AAEzB,YAAM,IAAI,MAAM,wBAAwB,MAAM;AAC7C,gBAAQ,EAAE,UAAU,QAAW,WAAW,KAAK,CAAC;AAChD,aAAK,YAAY,UAAU,IAAI,EAAE,MAAM,MAAM;AAAA,QAAE,CAAC;AAAA,MACjD,CAAC,CAAC;AAGF,YAAM,IAAI,gBAAgB,MAAM,MAAM;AACrC,cAAM,WAAW,KAAK,wBAAwB,eAAe,MAAO;AAGpE,cAAM,IAAI,kBAAkB,MAAM;AACjC,cAAI,CAAC,aAAa;AACjB,kBAAM,eAAe,IAAI,SAAS,kBAAkB,qIAAqI,OAAO,WAAW,WAAW,SAAS,KAAK,UAAU,MAAM,CAAC;AACrP,mBAAO,EAAE,UAAU,SAAS,OAAO,SAAS,aAAa,CAAC;AAAA,UAC3D;AAAA,QACD,GAAG,QAAQ,CAAC;AAGZ,cAAM,IAAI,kBAAkB,MAAM;AACjC,gBAAM,UAAU,IAAI,SAAS,eAAe,sCAAsC,KAAK,wBAAwB,IAAI;AACnH,gBAAM,UAAU,CAAC,4BAA4B,WAAW;AACxD,gBAAM,eAAe,gBAAgB,cAAc,gBAAgB;AACnE,cAAI,cAAc;AACjB,oBAAQ,OAAO,GAAG,GAAG,IAAI,SAAS,iBAAiB,gBAAgB,CAAC;AAAA,UACrE;AAEA,eAAK,gBAAgB;AAAA,YACpB,EAAE,UAAU,iBAAiB,cAAc,OAAO,SAAS,QAAQ;AAAA,YACnE,MAAM,OAAO,MAAM,MAAM;AAAA,YAAE,CAAC;AAAA,YAC5B,CAAC,WAAW;AACX,kBAAI,WAAW,QAAW;AAAA,cAE1B,WAAW,WAAW,GAAG;AACxB,wBAAQ,EAAE,UAAU,EAAE,CAAC;AAAA,cACxB,OAAO;AACN,wBAAQ,EAAE,UAAU,QAAW,WAAW,KAAK,CAAC;AAChD,qBAAK,YAAY,UAAU,IAAI,EAAE,MAAM,MAAM;AAAA,gBAAE,CAAC;AAChD,oBAAI,gBAAgB,WAAW,GAAG;AACjC,uBAAK,YAAY,WAAW,IAAkB;AAAA,gBAC/C;AAAA,cACD;AAAA,YACD;AAAA,UACD;AAAA,QACD,GAAG,GAAM,CAAC;AAAA,MACX,CAAC,CAAC;AAAA,IACH,CAAC;AAED,WAAO,OAAO,QAAQ,MAAM,MAAM,QAAQ,CAAC;AAAA,EAC5C;AACD;AArRa,kBAAN;AAAA,EAKJ;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,GAZU;",
  "names": ["TaskRunResult", "DebugChoice", "result"]
}
