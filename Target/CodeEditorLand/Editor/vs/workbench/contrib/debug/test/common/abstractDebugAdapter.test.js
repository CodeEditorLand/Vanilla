import s from"assert";import{timeout as a}from"../../../../../base/common/async.js";import{ensureNoDisposablesAreLeakedInTestSuite as u}from"../../../../../base/test/common/utils.js";import{MockDebugAdapter as i}from"./mockDebug.js";suite("Debug - AbstractDebugAdapter",()=>{u(),suite("event ordering",()=>{let t,e;setup(()=>{t=new i,e=[],t.onEvent(o=>{e.push(o.body.output),Promise.resolve().then(()=>e.push("--end microtask--"))})});const r=async o=>{await new Promise(n=>t.sendRequest("evaluate",{expression:o},n)),e.push(`=${o}`),Promise.resolve().then(()=>e.push("--end microtask--"))};test("inserts task boundary before response",async()=>{await r("before.foo"),await a(0),s.deepStrictEqual(e,["before.foo","--end microtask--","=before.foo","--end microtask--"])}),test("inserts task boundary after response",async()=>{await r("after.foo"),await a(0),s.deepStrictEqual(e,["=after.foo","--end microtask--","after.foo","--end microtask--"])}),test("does not insert boundaries between events",async()=>{t.sendEventBody("output",{output:"a"}),t.sendEventBody("output",{output:"b"}),t.sendEventBody("output",{output:"c"}),await a(0),s.deepStrictEqual(e,["a","b","c","--end microtask--","--end microtask--","--end microtask--"])})})});
