import type { CancellationToken } from "../../../../../base/common/cancellation.js";
import type { Event } from "../../../../../base/common/event.js";
import type { URI as uri } from "../../../../../base/common/uri.js";
import type { IPosition, Position } from "../../../../../editor/common/core/position.js";
import type { ITextModel } from "../../../../../editor/common/model.js";
import type { IStorageService } from "../../../../../platform/storage/common/storage.js";
import type { IWorkspaceFolder } from "../../../../../platform/workspace/common/workspace.js";
import { AbstractDebugAdapter } from "../../common/abstractDebugAdapter.js";
import { type AdapterEndEvent, type IAdapterManager, type IBreakpoint, type IBreakpointData, type IBreakpointUpdateData, type IConfig, type IConfigurationManager, type IDataBreakpoint, type IDataBreakpointInfoResponse, type IDebugLocationReferenced, type IDebugModel, type IDebugService, type IDebugSession, type IDebugSessionOptions, type IDebugger, type IExceptionBreakpoint, type IExceptionInfo, type IFunctionBreakpoint, type IInstructionBreakpoint, type ILaunch, type IMemoryRegion, type INewReplElementData, type IRawModelUpdate, type IRawStoppedDetails, type IReplElement, type IStackFrame, type IThread, type IViewModel, type LoadedSourceEvent, State } from "../../common/debug.js";
import type { DebugCompoundRoot } from "../../common/debugCompoundRoot.js";
import type { IInstructionBreakpointOptions } from "../../common/debugModel.js";
import type { Source } from "../../common/debugSource.js";
import { DebugStorage } from "../../common/debugStorage.js";
export declare class MockDebugService implements IDebugService {
    _serviceBrand: undefined;
    get state(): State;
    get onWillNewSession(): Event<IDebugSession>;
    get onDidNewSession(): Event<IDebugSession>;
    get onDidEndSession(): Event<{
        session: IDebugSession;
        restart: boolean;
    }>;
    get onDidChangeState(): Event<State>;
    getConfigurationManager(): IConfigurationManager;
    getAdapterManager(): IAdapterManager;
    canSetBreakpointsIn(model: ITextModel): boolean;
    focusStackFrame(focusedStackFrame: IStackFrame): Promise<void>;
    sendAllBreakpoints(session?: IDebugSession): Promise<any>;
    sendBreakpoints(modelUri: uri, sourceModified?: boolean | undefined, session?: IDebugSession | undefined): Promise<any>;
    addBreakpoints(uri: uri, rawBreakpoints: IBreakpointData[]): Promise<IBreakpoint[]>;
    updateBreakpoints(uri: uri, data: Map<string, IBreakpointUpdateData>, sendOnResourceSaved: boolean): Promise<void>;
    enableOrDisableBreakpoints(enabled: boolean): Promise<void>;
    setBreakpointsActivated(): Promise<void>;
    removeBreakpoints(): Promise<any>;
    addInstructionBreakpoint(opts: IInstructionBreakpointOptions): Promise<void>;
    removeInstructionBreakpoints(address?: string): Promise<void>;
    setExceptionBreakpointCondition(breakpoint: IExceptionBreakpoint, condition: string): Promise<void>;
    setExceptionBreakpointsForSession(session: IDebugSession, data: DebugProtocol.ExceptionBreakpointsFilter[]): void;
    addFunctionBreakpoint(): void;
    moveWatchExpression(id: string, position: number): void;
    updateFunctionBreakpoint(id: string, update: {
        name?: string;
        hitCondition?: string;
        condition?: string;
    }): Promise<void>;
    removeFunctionBreakpoints(id?: string): Promise<void>;
    addDataBreakpoint(): Promise<void>;
    updateDataBreakpoint(id: string, update: {
        hitCondition?: string;
        condition?: string;
    }): Promise<void>;
    removeDataBreakpoints(id?: string | undefined): Promise<void>;
    addReplExpression(name: string): Promise<void>;
    removeReplExpressions(): void;
    addWatchExpression(name?: string): Promise<void>;
    renameWatchExpression(id: string, newName: string): Promise<void>;
    removeWatchExpressions(id?: string): void;
    startDebugging(launch: ILaunch, configOrName?: IConfig | string, options?: IDebugSessionOptions): Promise<boolean>;
    restartSession(): Promise<any>;
    stopSession(): Promise<any>;
    getModel(): IDebugModel;
    getViewModel(): IViewModel;
    sourceIsNotAvailable(uri: uri): void;
    tryToAutoFocusStackFrame(thread: IThread): Promise<any>;
    runTo(uri: uri, lineNumber: number, column?: number): Promise<void>;
}
export declare class MockSession implements IDebugSession {
    readonly suppressDebugToolbar = false;
    readonly suppressDebugStatusbar = false;
    readonly suppressDebugView = false;
    readonly autoExpandLazyVariables = false;
    getMemory(memoryReference: string): IMemoryRegion;
    get onDidInvalidateMemory(): Event<DebugProtocol.MemoryEvent>;
    readMemory(memoryReference: string, offset: number, count: number): Promise<DebugProtocol.ReadMemoryResponse | undefined>;
    writeMemory(memoryReference: string, offset: number, data: string, allowPartial?: boolean): Promise<DebugProtocol.WriteMemoryResponse | undefined>;
    get compoundRoot(): DebugCompoundRoot | undefined;
    get saveBeforeRestart(): boolean;
    get isSimpleUI(): boolean;
    get lifecycleManagedByParent(): boolean;
    stepInTargets(frameId: number): Promise<{
        id: number;
        label: string;
    }[]>;
    cancel(_progressId: string): Promise<DebugProtocol.CancelResponse>;
    breakpointsLocations(uri: uri, lineNumber: number): Promise<IPosition[]>;
    dataBytesBreakpointInfo(address: string, bytes: number): Promise<IDataBreakpointInfoResponse | undefined>;
    dataBreakpointInfo(name: string, variablesReference?: number | undefined): Promise<{
        dataId: string | null;
        description: string;
        canPersist?: boolean | undefined;
    } | undefined>;
    sendDataBreakpoints(dbps: IDataBreakpoint[]): Promise<void>;
    subId: string | undefined;
    get compact(): boolean;
    setSubId(subId: string | undefined): void;
    get parentSession(): IDebugSession | undefined;
    getReplElements(): IReplElement[];
    hasSeparateRepl(): boolean;
    removeReplExpressions(): void;
    get onDidChangeReplElements(): Event<IReplElement | undefined>;
    addReplExpression(stackFrame: IStackFrame, name: string): Promise<void>;
    appendToRepl(data: INewReplElementData): void;
    configuration: IConfig;
    unresolvedConfiguration: IConfig;
    state: State;
    root: IWorkspaceFolder;
    capabilities: DebugProtocol.Capabilities;
    getId(): string;
    getLabel(): string;
    get name(): string;
    setName(name: string): void;
    getSourceForUri(modelUri: uri): Source;
    getThread(threadId: number): IThread;
    getStoppedDetails(): IRawStoppedDetails;
    get onDidCustomEvent(): Event<DebugProtocol.Event>;
    get onDidLoadedSource(): Event<LoadedSourceEvent>;
    get onDidChangeState(): Event<void>;
    get onDidEndAdapter(): Event<AdapterEndEvent | undefined>;
    get onDidChangeName(): Event<string>;
    get onDidProgressStart(): Event<DebugProtocol.ProgressStartEvent>;
    get onDidProgressUpdate(): Event<DebugProtocol.ProgressUpdateEvent>;
    get onDidProgressEnd(): Event<DebugProtocol.ProgressEndEvent>;
    setConfiguration(configuration: {
        resolved: IConfig;
        unresolved: IConfig;
    }): void;
    getAllThreads(): IThread[];
    getSource(raw: DebugProtocol.Source): Source;
    getLoadedSources(): Promise<Source[]>;
    completions(frameId: number, threadId: number, text: string, position: Position, overwriteBefore: number): Promise<DebugProtocol.CompletionsResponse>;
    clearThreads(removeThreads: boolean, reference?: number): void;
    rawUpdate(data: IRawModelUpdate): void;
    initialize(dbgr: IDebugger): Promise<void>;
    launchOrAttach(config: IConfig): Promise<void>;
    restart(): Promise<void>;
    sendBreakpoints(modelUri: uri, bpts: IBreakpoint[], sourceModified: boolean): Promise<void>;
    sendFunctionBreakpoints(fbps: IFunctionBreakpoint[]): Promise<void>;
    sendExceptionBreakpoints(exbpts: IExceptionBreakpoint[]): Promise<void>;
    sendInstructionBreakpoints(dbps: IInstructionBreakpoint[]): Promise<void>;
    getDebugProtocolBreakpoint(breakpointId: string): DebugProtocol.Breakpoint | undefined;
    customRequest(request: string, args: any): Promise<DebugProtocol.Response>;
    stackTrace(threadId: number, startFrame: number, levels: number, token: CancellationToken): Promise<DebugProtocol.StackTraceResponse>;
    exceptionInfo(threadId: number): Promise<IExceptionInfo>;
    scopes(frameId: number): Promise<DebugProtocol.ScopesResponse>;
    variables(variablesReference: number, threadId: number | undefined, filter: "indexed" | "named", start: number, count: number): Promise<DebugProtocol.VariablesResponse>;
    evaluate(expression: string, frameId: number, context?: string): Promise<DebugProtocol.EvaluateResponse>;
    restartFrame(frameId: number, threadId: number): Promise<void>;
    next(threadId: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void>;
    stepIn(threadId: number, targetId?: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void>;
    stepOut(threadId: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void>;
    stepBack(threadId: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void>;
    continue(threadId: number): Promise<void>;
    reverseContinue(threadId: number): Promise<void>;
    pause(threadId: number): Promise<void>;
    terminateThreads(threadIds: number[]): Promise<void>;
    setVariable(variablesReference: number, name: string, value: string): Promise<DebugProtocol.SetVariableResponse>;
    setExpression(frameId: number, expression: string, value: string): Promise<DebugProtocol.SetExpressionResponse | undefined>;
    loadSource(resource: uri): Promise<DebugProtocol.SourceResponse>;
    disassemble(memoryReference: string, offset: number, instructionOffset: number, instructionCount: number): Promise<DebugProtocol.DisassembledInstruction[] | undefined>;
    terminate(restart?: boolean): Promise<void>;
    disconnect(restart?: boolean): Promise<void>;
    gotoTargets(source: DebugProtocol.Source, line: number, column?: number | undefined): Promise<DebugProtocol.GotoTargetsResponse>;
    goto(threadId: number, targetId: number): Promise<DebugProtocol.GotoResponse>;
    resolveLocationReference(locationReference: number): Promise<IDebugLocationReferenced>;
}
export declare class MockRawSession {
    capabilities: DebugProtocol.Capabilities;
    disconnected: boolean;
    sessionLengthInSeconds: number;
    readyForBreakpoints: boolean;
    emittedStopped: boolean;
    getLengthInSeconds(): number;
    stackTrace(args: DebugProtocol.StackTraceArguments): Promise<DebugProtocol.StackTraceResponse>;
    exceptionInfo(args: DebugProtocol.ExceptionInfoArguments): Promise<DebugProtocol.ExceptionInfoResponse>;
    launchOrAttach(args: IConfig): Promise<DebugProtocol.Response>;
    scopes(args: DebugProtocol.ScopesArguments): Promise<DebugProtocol.ScopesResponse>;
    variables(args: DebugProtocol.VariablesArguments): Promise<DebugProtocol.VariablesResponse>;
    evaluate(args: DebugProtocol.EvaluateArguments): Promise<DebugProtocol.EvaluateResponse>;
    custom(request: string, args: any): Promise<DebugProtocol.Response>;
    terminate(restart?: boolean): Promise<DebugProtocol.TerminateResponse>;
    disconnect(restart?: boolean): Promise<any>;
    threads(): Promise<DebugProtocol.ThreadsResponse>;
    stepIn(args: DebugProtocol.StepInArguments): Promise<DebugProtocol.StepInResponse>;
    stepOut(args: DebugProtocol.StepOutArguments): Promise<DebugProtocol.StepOutResponse>;
    stepBack(args: DebugProtocol.StepBackArguments): Promise<DebugProtocol.StepBackResponse>;
    continue(args: DebugProtocol.ContinueArguments): Promise<DebugProtocol.ContinueResponse>;
    reverseContinue(args: DebugProtocol.ReverseContinueArguments): Promise<DebugProtocol.ReverseContinueResponse>;
    pause(args: DebugProtocol.PauseArguments): Promise<DebugProtocol.PauseResponse>;
    terminateThreads(args: DebugProtocol.TerminateThreadsArguments): Promise<DebugProtocol.TerminateThreadsResponse>;
    setVariable(args: DebugProtocol.SetVariableArguments): Promise<DebugProtocol.SetVariableResponse>;
    restartFrame(args: DebugProtocol.RestartFrameArguments): Promise<DebugProtocol.RestartFrameResponse>;
    completions(args: DebugProtocol.CompletionsArguments): Promise<DebugProtocol.CompletionsResponse>;
    next(args: DebugProtocol.NextArguments): Promise<DebugProtocol.NextResponse>;
    source(args: DebugProtocol.SourceArguments): Promise<DebugProtocol.SourceResponse>;
    loadedSources(args: DebugProtocol.LoadedSourcesArguments): Promise<DebugProtocol.LoadedSourcesResponse>;
    setBreakpoints(args: DebugProtocol.SetBreakpointsArguments): Promise<DebugProtocol.SetBreakpointsResponse>;
    setFunctionBreakpoints(args: DebugProtocol.SetFunctionBreakpointsArguments): Promise<DebugProtocol.SetFunctionBreakpointsResponse>;
    setExceptionBreakpoints(args: DebugProtocol.SetExceptionBreakpointsArguments): Promise<DebugProtocol.SetExceptionBreakpointsResponse>;
    readonly onDidStop: Event<DebugProtocol.StoppedEvent>;
}
export declare class MockDebugAdapter extends AbstractDebugAdapter {
    private seq;
    private pendingResponses;
    startSession(): Promise<void>;
    stopSession(): Promise<void>;
    sendMessage(message: DebugProtocol.ProtocolMessage): void;
    sendResponseBody(request: DebugProtocol.Request, body: any): void;
    sendEventBody(event: string, body: any): void;
    waitForResponseFromClient(command: string): Promise<DebugProtocol.Response>;
    sendRequestBody(command: string, args: any): void;
    evaluate(request: DebugProtocol.Request, args: DebugProtocol.EvaluateArguments): void;
}
export declare class MockDebugStorage extends DebugStorage {
    constructor(storageService: IStorageService);
}
