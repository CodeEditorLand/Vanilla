{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/debug/test/common/mockDebug.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DeferredPromise } from '../../../../../base/common/async.js';\nimport { CancellationToken } from '../../../../../base/common/cancellation.js';\nimport { Event } from '../../../../../base/common/event.js';\nimport { URI as uri } from '../../../../../base/common/uri.js';\nimport { IPosition, Position } from '../../../../../editor/common/core/position.js';\nimport { ITextModel } from '../../../../../editor/common/model.js';\nimport { NullLogService } from '../../../../../platform/log/common/log.js';\nimport { IStorageService } from '../../../../../platform/storage/common/storage.js';\nimport { IWorkspaceFolder } from '../../../../../platform/workspace/common/workspace.js';\nimport { AbstractDebugAdapter } from '../../common/abstractDebugAdapter.js';\nimport { AdapterEndEvent, IAdapterManager, IBreakpoint, IBreakpointData, IBreakpointUpdateData, IConfig, IConfigurationManager, IDataBreakpoint, IDataBreakpointInfoResponse, IDebugLocationReferenced, IDebugModel, IDebugService, IDebugSession, IDebugSessionOptions, IDebugger, IExceptionBreakpoint, IExceptionInfo, IFunctionBreakpoint, IInstructionBreakpoint, ILaunch, IMemoryRegion, INewReplElementData, IRawModelUpdate, IRawStoppedDetails, IReplElement, IStackFrame, IThread, IViewModel, LoadedSourceEvent, State } from '../../common/debug.js';\nimport { DebugCompoundRoot } from '../../common/debugCompoundRoot.js';\nimport { IInstructionBreakpointOptions } from '../../common/debugModel.js';\nimport { Source } from '../../common/debugSource.js';\nimport { DebugStorage } from '../../common/debugStorage.js';\n\nexport class MockDebugService implements IDebugService {\n\t_serviceBrand: undefined;\n\n\tget state(): State {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tget onWillNewSession(): Event<IDebugSession> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tget onDidNewSession(): Event<IDebugSession> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tget onDidEndSession(): Event<{ session: IDebugSession; restart: boolean }> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tget onDidChangeState(): Event<State> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tgetConfigurationManager(): IConfigurationManager {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tgetAdapterManager(): IAdapterManager {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tcanSetBreakpointsIn(model: ITextModel): boolean {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tfocusStackFrame(focusedStackFrame: IStackFrame): Promise<void> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tsendAllBreakpoints(session?: IDebugSession): Promise<any> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tsendBreakpoints(modelUri: uri, sourceModified?: boolean | undefined, session?: IDebugSession | undefined): Promise<any> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\taddBreakpoints(uri: uri, rawBreakpoints: IBreakpointData[]): Promise<IBreakpoint[]> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tupdateBreakpoints(uri: uri, data: Map<string, IBreakpointUpdateData>, sendOnResourceSaved: boolean): Promise<void> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tenableOrDisableBreakpoints(enabled: boolean): Promise<void> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tsetBreakpointsActivated(): Promise<void> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tremoveBreakpoints(): Promise<any> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\taddInstructionBreakpoint(opts: IInstructionBreakpointOptions): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tremoveInstructionBreakpoints(address?: string): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tsetExceptionBreakpointCondition(breakpoint: IExceptionBreakpoint, condition: string): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tsetExceptionBreakpointsForSession(session: IDebugSession, data: DebugProtocol.ExceptionBreakpointsFilter[]): void {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\taddFunctionBreakpoint(): void { }\n\n\tmoveWatchExpression(id: string, position: number): void { }\n\n\tupdateFunctionBreakpoint(id: string, update: { name?: string; hitCondition?: string; condition?: string }): Promise<void> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tremoveFunctionBreakpoints(id?: string): Promise<void> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\taddDataBreakpoint(): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tupdateDataBreakpoint(id: string, update: { hitCondition?: string; condition?: string }): Promise<void> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tremoveDataBreakpoints(id?: string | undefined): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\taddReplExpression(name: string): Promise<void> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tremoveReplExpressions(): void { }\n\n\taddWatchExpression(name?: string): Promise<void> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\trenameWatchExpression(id: string, newName: string): Promise<void> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tremoveWatchExpressions(id?: string): void { }\n\n\tstartDebugging(launch: ILaunch, configOrName?: IConfig | string, options?: IDebugSessionOptions): Promise<boolean> {\n\t\treturn Promise.resolve(true);\n\t}\n\n\trestartSession(): Promise<any> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tstopSession(): Promise<any> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tgetModel(): IDebugModel {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tgetViewModel(): IViewModel {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tsourceIsNotAvailable(uri: uri): void { }\n\n\ttryToAutoFocusStackFrame(thread: IThread): Promise<any> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\trunTo(uri: uri, lineNumber: number, column?: number): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n}\n\nexport class MockSession implements IDebugSession {\n\treadonly suppressDebugToolbar = false;\n\treadonly suppressDebugStatusbar = false;\n\treadonly suppressDebugView = false;\n\treadonly autoExpandLazyVariables = false;\n\n\tgetMemory(memoryReference: string): IMemoryRegion {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tget onDidInvalidateMemory(): Event<DebugProtocol.MemoryEvent> {\n\t\tthrow new Error('Not implemented');\n\t}\n\n\treadMemory(memoryReference: string, offset: number, count: number): Promise<DebugProtocol.ReadMemoryResponse | undefined> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\twriteMemory(memoryReference: string, offset: number, data: string, allowPartial?: boolean): Promise<DebugProtocol.WriteMemoryResponse | undefined> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tget compoundRoot(): DebugCompoundRoot | undefined {\n\t\treturn undefined;\n\t}\n\n\tget saveBeforeRestart(): boolean {\n\t\treturn true;\n\t}\n\n\tget isSimpleUI(): boolean {\n\t\treturn false;\n\t}\n\n\tget lifecycleManagedByParent(): boolean {\n\t\treturn false;\n\t}\n\n\tstepInTargets(frameId: number): Promise<{ id: number; label: string }[]> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tcancel(_progressId: string): Promise<DebugProtocol.CancelResponse> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tbreakpointsLocations(uri: uri, lineNumber: number): Promise<IPosition[]> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tdataBytesBreakpointInfo(address: string, bytes: number): Promise<IDataBreakpointInfoResponse | undefined> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tdataBreakpointInfo(name: string, variablesReference?: number | undefined): Promise<{ dataId: string | null; description: string; canPersist?: boolean | undefined } | undefined> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tsendDataBreakpoints(dbps: IDataBreakpoint[]): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tsubId: string | undefined;\n\n\tget compact(): boolean {\n\t\treturn false;\n\t}\n\n\tsetSubId(subId: string | undefined): void {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tget parentSession(): IDebugSession | undefined {\n\t\treturn undefined;\n\t}\n\n\tgetReplElements(): IReplElement[] {\n\t\treturn [];\n\t}\n\n\thasSeparateRepl(): boolean {\n\t\treturn true;\n\t}\n\n\tremoveReplExpressions(): void { }\n\tget onDidChangeReplElements(): Event<IReplElement | undefined> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\taddReplExpression(stackFrame: IStackFrame, name: string): Promise<void> {\n\t\treturn Promise.resolve(undefined);\n\t}\n\n\tappendToRepl(data: INewReplElementData): void { }\n\n\tconfiguration: IConfig = { type: 'mock', name: 'mock', request: 'launch' };\n\tunresolvedConfiguration: IConfig = { type: 'mock', name: 'mock', request: 'launch' };\n\tstate = State.Stopped;\n\troot!: IWorkspaceFolder;\n\tcapabilities: DebugProtocol.Capabilities = {};\n\n\tgetId(): string {\n\t\treturn 'mock';\n\t}\n\n\tgetLabel(): string {\n\t\treturn 'mockname';\n\t}\n\n\tget name(): string {\n\t\treturn 'mockname';\n\t}\n\n\tsetName(name: string): void {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tgetSourceForUri(modelUri: uri): Source {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tgetThread(threadId: number): IThread {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tgetStoppedDetails(): IRawStoppedDetails {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tget onDidCustomEvent(): Event<DebugProtocol.Event> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tget onDidLoadedSource(): Event<LoadedSourceEvent> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tget onDidChangeState(): Event<void> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tget onDidEndAdapter(): Event<AdapterEndEvent | undefined> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tget onDidChangeName(): Event<string> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tget onDidProgressStart(): Event<DebugProtocol.ProgressStartEvent> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tget onDidProgressUpdate(): Event<DebugProtocol.ProgressUpdateEvent> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tget onDidProgressEnd(): Event<DebugProtocol.ProgressEndEvent> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tsetConfiguration(configuration: { resolved: IConfig; unresolved: IConfig }) { }\n\n\tgetAllThreads(): IThread[] {\n\t\treturn [];\n\t}\n\n\tgetSource(raw: DebugProtocol.Source): Source {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tgetLoadedSources(): Promise<Source[]> {\n\t\treturn Promise.resolve([]);\n\t}\n\n\tcompletions(frameId: number, threadId: number, text: string, position: Position, overwriteBefore: number): Promise<DebugProtocol.CompletionsResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tclearThreads(removeThreads: boolean, reference?: number): void { }\n\n\trawUpdate(data: IRawModelUpdate): void { }\n\n\tinitialize(dbgr: IDebugger): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tlaunchOrAttach(config: IConfig): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\trestart(): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tsendBreakpoints(modelUri: uri, bpts: IBreakpoint[], sourceModified: boolean): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tsendFunctionBreakpoints(fbps: IFunctionBreakpoint[]): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tsendExceptionBreakpoints(exbpts: IExceptionBreakpoint[]): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tsendInstructionBreakpoints(dbps: IInstructionBreakpoint[]): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tgetDebugProtocolBreakpoint(breakpointId: string): DebugProtocol.Breakpoint | undefined {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tcustomRequest(request: string, args: any): Promise<DebugProtocol.Response> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tstackTrace(threadId: number, startFrame: number, levels: number, token: CancellationToken): Promise<DebugProtocol.StackTraceResponse> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\texceptionInfo(threadId: number): Promise<IExceptionInfo> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tscopes(frameId: number): Promise<DebugProtocol.ScopesResponse> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tvariables(variablesReference: number, threadId: number | undefined, filter: 'indexed' | 'named', start: number, count: number): Promise<DebugProtocol.VariablesResponse> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tevaluate(expression: string, frameId: number, context?: string): Promise<DebugProtocol.EvaluateResponse> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\trestartFrame(frameId: number, threadId: number): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tnext(threadId: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tstepIn(threadId: number, targetId?: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tstepOut(threadId: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tstepBack(threadId: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tcontinue(threadId: number): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\treverseContinue(threadId: number): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tpause(threadId: number): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tterminateThreads(threadIds: number[]): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tsetVariable(variablesReference: number, name: string, value: string): Promise<DebugProtocol.SetVariableResponse> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tsetExpression(frameId: number, expression: string, value: string): Promise<DebugProtocol.SetExpressionResponse | undefined> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tloadSource(resource: uri): Promise<DebugProtocol.SourceResponse> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tdisassemble(memoryReference: string, offset: number, instructionOffset: number, instructionCount: number): Promise<DebugProtocol.DisassembledInstruction[] | undefined> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tterminate(restart = false): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tdisconnect(restart = false): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tgotoTargets(source: DebugProtocol.Source, line: number, column?: number | undefined): Promise<DebugProtocol.GotoTargetsResponse> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tgoto(threadId: number, targetId: number): Promise<DebugProtocol.GotoResponse> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tresolveLocationReference(locationReference: number): Promise<IDebugLocationReferenced> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n}\n\nexport class MockRawSession {\n\n\tcapabilities: DebugProtocol.Capabilities = {};\n\tdisconnected = false;\n\tsessionLengthInSeconds: number = 0;\n\n\treadyForBreakpoints = true;\n\temittedStopped = true;\n\n\tgetLengthInSeconds(): number {\n\t\treturn 100;\n\t}\n\n\tstackTrace(args: DebugProtocol.StackTraceArguments): Promise<DebugProtocol.StackTraceResponse> {\n\t\treturn Promise.resolve({\n\t\t\tseq: 1,\n\t\t\ttype: 'response',\n\t\t\trequest_seq: 1,\n\t\t\tsuccess: true,\n\t\t\tcommand: 'stackTrace',\n\t\t\tbody: {\n\t\t\t\tstackFrames: [{\n\t\t\t\t\tid: 1,\n\t\t\t\t\tname: 'mock',\n\t\t\t\t\tline: 5,\n\t\t\t\t\tcolumn: 6\n\t\t\t\t}]\n\t\t\t}\n\t\t});\n\t}\n\n\texceptionInfo(args: DebugProtocol.ExceptionInfoArguments): Promise<DebugProtocol.ExceptionInfoResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tlaunchOrAttach(args: IConfig): Promise<DebugProtocol.Response> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tscopes(args: DebugProtocol.ScopesArguments): Promise<DebugProtocol.ScopesResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tvariables(args: DebugProtocol.VariablesArguments): Promise<DebugProtocol.VariablesResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tevaluate(args: DebugProtocol.EvaluateArguments): Promise<DebugProtocol.EvaluateResponse> {\n\t\treturn Promise.resolve(null!);\n\t}\n\n\tcustom(request: string, args: any): Promise<DebugProtocol.Response> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tterminate(restart = false): Promise<DebugProtocol.TerminateResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tdisconnect(restart?: boolean): Promise<any> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tthreads(): Promise<DebugProtocol.ThreadsResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tstepIn(args: DebugProtocol.StepInArguments): Promise<DebugProtocol.StepInResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tstepOut(args: DebugProtocol.StepOutArguments): Promise<DebugProtocol.StepOutResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tstepBack(args: DebugProtocol.StepBackArguments): Promise<DebugProtocol.StepBackResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tcontinue(args: DebugProtocol.ContinueArguments): Promise<DebugProtocol.ContinueResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\treverseContinue(args: DebugProtocol.ReverseContinueArguments): Promise<DebugProtocol.ReverseContinueResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tpause(args: DebugProtocol.PauseArguments): Promise<DebugProtocol.PauseResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tterminateThreads(args: DebugProtocol.TerminateThreadsArguments): Promise<DebugProtocol.TerminateThreadsResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tsetVariable(args: DebugProtocol.SetVariableArguments): Promise<DebugProtocol.SetVariableResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\trestartFrame(args: DebugProtocol.RestartFrameArguments): Promise<DebugProtocol.RestartFrameResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tcompletions(args: DebugProtocol.CompletionsArguments): Promise<DebugProtocol.CompletionsResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tnext(args: DebugProtocol.NextArguments): Promise<DebugProtocol.NextResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tsource(args: DebugProtocol.SourceArguments): Promise<DebugProtocol.SourceResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tloadedSources(args: DebugProtocol.LoadedSourcesArguments): Promise<DebugProtocol.LoadedSourcesResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tsetBreakpoints(args: DebugProtocol.SetBreakpointsArguments): Promise<DebugProtocol.SetBreakpointsResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tsetFunctionBreakpoints(args: DebugProtocol.SetFunctionBreakpointsArguments): Promise<DebugProtocol.SetFunctionBreakpointsResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tsetExceptionBreakpoints(args: DebugProtocol.SetExceptionBreakpointsArguments): Promise<DebugProtocol.SetExceptionBreakpointsResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\treadonly onDidStop: Event<DebugProtocol.StoppedEvent> = null!;\n}\n\nexport class MockDebugAdapter extends AbstractDebugAdapter {\n\tprivate seq = 0;\n\n\tprivate pendingResponses = new Map<string, DeferredPromise<DebugProtocol.Response>>();\n\n\tstartSession(): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n\n\tstopSession(): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n\n\tsendMessage(message: DebugProtocol.ProtocolMessage): void {\n\t\tif (message.type === 'request') {\n\t\t\tsetTimeout(() => {\n\t\t\t\tconst request = message as DebugProtocol.Request;\n\t\t\t\tswitch (request.command) {\n\t\t\t\t\tcase 'evaluate':\n\t\t\t\t\t\tthis.evaluate(request, request.arguments);\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.sendResponseBody(request, {});\n\t\t\t\treturn;\n\t\t\t}, 0);\n\t\t} else if (message.type === 'response') {\n\t\t\tconst response = message as DebugProtocol.Response;\n\t\t\tif (this.pendingResponses.has(response.command)) {\n\t\t\t\tthis.pendingResponses.get(response.command)!.complete(response);\n\t\t\t}\n\t\t}\n\t}\n\n\tsendResponseBody(request: DebugProtocol.Request, body: any) {\n\t\tconst response: DebugProtocol.Response = {\n\t\t\tseq: ++this.seq,\n\t\t\ttype: 'response',\n\t\t\trequest_seq: request.seq,\n\t\t\tcommand: request.command,\n\t\t\tsuccess: true,\n\t\t\tbody\n\t\t};\n\t\tthis.acceptMessage(response);\n\t}\n\n\tsendEventBody(event: string, body: any) {\n\t\tconst response: DebugProtocol.Event = {\n\t\t\tseq: ++this.seq,\n\t\t\ttype: 'event',\n\t\t\tevent,\n\t\t\tbody\n\t\t};\n\t\tthis.acceptMessage(response);\n\t}\n\n\twaitForResponseFromClient(command: string): Promise<DebugProtocol.Response> {\n\t\tconst deferred = new DeferredPromise<DebugProtocol.Response>();\n\t\tif (this.pendingResponses.has(command)) {\n\t\t\treturn this.pendingResponses.get(command)!.p;\n\t\t}\n\n\t\tthis.pendingResponses.set(command, deferred);\n\t\treturn deferred.p;\n\t}\n\n\tsendRequestBody(command: string, args: any) {\n\t\tconst response: DebugProtocol.Request = {\n\t\t\tseq: ++this.seq,\n\t\t\ttype: 'request',\n\t\t\tcommand,\n\t\t\targuments: args\n\t\t};\n\t\tthis.acceptMessage(response);\n\t}\n\n\tevaluate(request: DebugProtocol.Request, args: DebugProtocol.EvaluateArguments) {\n\t\tif (args.expression.indexOf('before.') === 0) {\n\t\t\tthis.sendEventBody('output', { output: args.expression });\n\t\t}\n\n\t\tthis.sendResponseBody(request, {\n\t\t\tresult: '=' + args.expression,\n\t\t\tvariablesReference: 0\n\t\t});\n\n\t\tif (args.expression.indexOf('after.') === 0) {\n\t\t\tthis.sendEventBody('output', { output: args.expression });\n\t\t}\n\t}\n}\n\nexport class MockDebugStorage extends DebugStorage {\n\n\tconstructor(storageService: IStorageService) {\n\t\tsuper(storageService, undefined as any, undefined as any, new NullLogService());\n\t}\n}\n"],
  "mappings": "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",
  "names": ["uri"]
}
