var V=Object.defineProperty;var x=Object.getOwnPropertyDescriptor;var m=(o,i,e,n)=>{for(var t=n>1?void 0:n?x(i,e):i,s=o.length-1,a;s>=0;s--)(a=o[s])&&(t=(n?a(i,e,t):a(t))||t);return n&&t&&V(i,e,t),t},l=(o,i)=>(e,n)=>i(e,n,o);import{toDisposable as I}from"../../../../base/common/lifecycle.js";import{isDefined as y}from"../../../../base/common/types.js";import{ContextKeyExpr as v,IContextKeyService as D}from"../../../../platform/contextkey/common/contextkey.js";import{ExtensionIdentifier as f}from"../../../../platform/extensions/common/extensions.js";import{createDecorator as E}from"../../../../platform/instantiation/common/instantiation.js";import{ILogService as C}from"../../../../platform/log/common/log.js";import{IExtensionService as T}from"../../../services/extensions/common/extensions.js";import{ExtensionsRegistry as w}from"../../../services/extensions/common/extensionsRegistry.js";import{CONTEXT_VARIABLE_NAME as P,CONTEXT_VARIABLE_TYPE as S,CONTEXT_VARIABLE_VALUE as R}from"./debug.js";import{getContextForVariable as A}from"./debugContext.js";import{Scope as k,Variable as c,VisualizedExpression as b}from"./debugModel.js";const U=E("debugVisualizerService");class H{constructor(i,e){this.handle=i;this.viz=e}get name(){return this.viz.name}get iconPath(){return this.viz.iconPath}get iconClass(){return this.viz.iconClass}async resolve(i){return this.viz.visualization??=await this.handle.resolveDebugVisualizer(this.viz,i)}async execute(){await this.handle.executeDebugVisualizerCommand(this.viz.id)}}const h={object:[],dispose:()=>{}};let p=class{constructor(i,e,n){this.contextKeyService=i;this.extensionService=e;this.logService=n;K.setHandler((t,{added:s,removed:a})=>{this.registrations=this.registrations.filter(u=>!a.some(r=>f.equals(r.description.identifier,u.extensionId))),s.forEach(u=>this.processExtensionRegistration(u.description))})}handles=new Map;trees=new Map;didActivate=new Map;registrations=[];async getApplicableFor(i,e){if(!(i instanceof c))return h;const n=i.getThreadId();if(n===void 0)return h;const t=this.getVariableContext(n,i),s=A(this.contextKeyService,i,[[P.key,i.name],[R.key,i.value],[S.key,i.type]]),a=await Promise.all(this.registrations.map(async r=>{if(!s.contextMatchesRules(r.expr))return;let d=this.didActivate.get(r.id);if(d||(d=this.extensionService.activateByEvent(`onDebugVisualizer:${r.id}`),this.didActivate.set(r.id,d)),await d,e.isCancellationRequested)return;const g=this.handles.get(z(r.extensionId,r.id));return g&&{handle:g,result:await g.provideDebugVisualizers(t,e)}})),u={object:a.filter(y).flatMap(r=>r.result.map(d=>new H(r.handle,d))),dispose:()=>{for(const r of a)r?.handle.disposeDebugVisualizers(r.result.map(d=>d.id))}};return e.isCancellationRequested&&u.dispose(),u}register(i){const e=z(i.extensionId,i.id);return this.handles.set(e,i),I(()=>this.handles.delete(e))}registerTree(i,e){return this.trees.set(i,e),I(()=>this.trees.delete(i))}async getVisualizedNodeFor(i,e){if(!(e instanceof c))return;const n=e.getThreadId();if(n===void 0)return;const t=this.trees.get(i);if(t)try{const s=await t.getTreeItem(this.getVariableContext(n,e));return s?new b(e.getSession(),this,i,s,e):void 0}catch(s){this.logService.warn("Failed to get visualized node",s);return}}async getVisualizedChildren(i,e,n){return(await this.trees.get(e)?.getChildren(n)||[]).map(a=>new b(i,this,e,a,void 0))}async editTreeItem(i,e,n){const t=await this.trees.get(i)?.editItem?.(e.id,n);t&&Object.assign(e,t)}getVariableContext(i,e){const n={sessionId:e.getSession()?.getId()||"",containerId:e.parent instanceof c?e.reference:void 0,threadId:i,variable:{name:e.name,value:e.value,type:e.type,evaluateName:e.evaluateName,variablesReference:e.reference||0,indexedVariables:e.indexedVariables,memoryReference:e.memoryReference,namedVariables:e.namedVariables,presentationHint:e.presentationHint}};for(let t=e;t instanceof c;t=t.parent)t.parent instanceof k&&(n.frameId=t.parent.stackFrame.frameId);return n}processExtensionRegistration(i){const e=i.contributes?.debugVisualizers;if(e instanceof Array)for(const{when:n,id:t}of e)try{const s=v.deserialize(n);s&&this.registrations.push({expr:s,id:t,extensionId:i.identifier})}catch(s){this.logService.error(`Error processing debug visualizer registration from extension '${i.identifier.value}'`,s)}}};p=m([l(0,D),l(1,T),l(2,C)],p);const z=(o,i)=>`${f.toKey(o)}\0${i}`,K=w.registerExtensionPoint({extensionPoint:"debugVisualizers",jsonSchema:{type:"array",items:{type:"object",properties:{id:{type:"string",description:"Name of the debug visualizer"},when:{type:"string",description:"Condition when the debug visualizer is applicable"}},required:["id","when"]}},activationEventsGenerator:(o,i)=>{for(const e of o)e.id&&i.push(`onDebugVisualizer:${e.id}`)}});export{H as DebugVisualizer,p as DebugVisualizerService,U as IDebugVisualizerService};
