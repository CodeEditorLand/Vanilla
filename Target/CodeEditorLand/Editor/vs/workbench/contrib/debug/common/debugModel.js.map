{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/debug/common/debugModel.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { distinct } from '../../../../base/common/arrays.js';\nimport { findLastIdx } from '../../../../base/common/arraysFind.js';\nimport { DeferredPromise, RunOnceScheduler } from '../../../../base/common/async.js';\nimport { VSBuffer, decodeBase64, encodeBase64 } from '../../../../base/common/buffer.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { Emitter, Event, trackSetChanges } from '../../../../base/common/event.js';\nimport { stringHash } from '../../../../base/common/hash.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { mixin } from '../../../../base/common/objects.js';\nimport { autorun } from '../../../../base/common/observable.js';\nimport * as resources from '../../../../base/common/resources.js';\nimport { isString, isUndefinedOrNull } from '../../../../base/common/types.js';\nimport { URI, URI as uri } from '../../../../base/common/uri.js';\nimport { generateUuid } from '../../../../base/common/uuid.js';\nimport { IRange, Range } from '../../../../editor/common/core/range.js';\nimport * as nls from '../../../../nls.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { IUriIdentityService } from '../../../../platform/uriIdentity/common/uriIdentity.js';\nimport { IEditorPane } from '../../../common/editor.js';\nimport { DEBUG_MEMORY_SCHEME, DataBreakpointSetType, DataBreakpointSource, DebugTreeItemCollapsibleState, IBaseBreakpoint, IBreakpoint, IBreakpointData, IBreakpointUpdateData, IBreakpointsChangeEvent, IDataBreakpoint, IDebugEvaluatePosition, IDebugModel, IDebugSession, IDebugVisualizationTreeItem, IEnablement, IExceptionBreakpoint, IExceptionInfo, IExpression, IExpressionContainer, IFunctionBreakpoint, IInstructionBreakpoint, IMemoryInvalidationEvent, IMemoryRegion, IRawModelUpdate, IRawStoppedDetails, IScope, IStackFrame, IThread, ITreeElement, MemoryRange, MemoryRangeType, State, isFrameDeemphasized } from './debug.js';\nimport { Source, UNKNOWN_SOURCE_LABEL, getUriFromSource } from './debugSource.js';\nimport { DebugStorage } from './debugStorage.js';\nimport { IDebugVisualizerService } from './debugVisualizers.js';\nimport { DisassemblyViewInput } from './disassemblyViewInput.js';\nimport { IEditorService } from '../../../services/editor/common/editorService.js';\nimport { ITextFileService } from '../../../services/textfile/common/textfiles.js';\n\ninterface IDebugProtocolVariableWithContext extends DebugProtocol.Variable {\n\t__vscodeVariableMenuContext?: string;\n}\n\nexport class ExpressionContainer implements IExpressionContainer {\n\n\tpublic static readonly allValues = new Map<string, string>();\n\t// Use chunks to support variable paging #9537\n\tprivate static readonly BASE_CHUNK_SIZE = 100;\n\n\tpublic type: string | undefined;\n\tpublic valueChanged = false;\n\tprivate _value: string = '';\n\tprotected children?: Promise<IExpression[]>;\n\n\tconstructor(\n\t\tprotected session: IDebugSession | undefined,\n\t\tprotected readonly threadId: number | undefined,\n\t\tprivate _reference: number | undefined,\n\t\tprivate readonly id: string,\n\t\tpublic namedVariables: number | undefined = 0,\n\t\tpublic indexedVariables: number | undefined = 0,\n\t\tpublic memoryReference: string | undefined = undefined,\n\t\tprivate startOfVariables: number | undefined = 0,\n\t\tpublic presentationHint: DebugProtocol.VariablePresentationHint | undefined = undefined,\n\t\tpublic valueLocationReference: number | undefined = undefined,\n\t) { }\n\n\tget reference(): number | undefined {\n\t\treturn this._reference;\n\t}\n\n\tset reference(value: number | undefined) {\n\t\tthis._reference = value;\n\t\tthis.children = undefined; // invalidate children cache\n\t}\n\n\tasync evaluateLazy(): Promise<void> {\n\t\tif (typeof this.reference === 'undefined') {\n\t\t\treturn;\n\t\t}\n\n\t\tconst response = await this.session!.variables(this.reference, this.threadId, undefined, undefined, undefined);\n\t\tif (!response || !response.body || !response.body.variables || response.body.variables.length !== 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst dummyVar = response.body.variables[0];\n\t\tthis.reference = dummyVar.variablesReference;\n\t\tthis._value = dummyVar.value;\n\t\tthis.namedVariables = dummyVar.namedVariables;\n\t\tthis.indexedVariables = dummyVar.indexedVariables;\n\t\tthis.memoryReference = dummyVar.memoryReference;\n\t\tthis.presentationHint = dummyVar.presentationHint;\n\t\tthis.valueLocationReference = dummyVar.valueLocationReference;\n\t\t// Also call overridden method to adopt subclass props\n\t\tthis.adoptLazyResponse(dummyVar);\n\t}\n\n\tprotected adoptLazyResponse(response: DebugProtocol.Variable): void {\n\t}\n\n\tgetChildren(): Promise<IExpression[]> {\n\t\tif (!this.children) {\n\t\t\tthis.children = this.doGetChildren();\n\t\t}\n\n\t\treturn this.children;\n\t}\n\n\tprivate async doGetChildren(): Promise<IExpression[]> {\n\t\tif (!this.hasChildren) {\n\t\t\treturn [];\n\t\t}\n\n\t\tif (!this.getChildrenInChunks) {\n\t\t\treturn this.fetchVariables(undefined, undefined, undefined);\n\t\t}\n\n\t\t// Check if object has named variables, fetch them independent from indexed variables #9670\n\t\tconst children = this.namedVariables ? await this.fetchVariables(undefined, undefined, 'named') : [];\n\n\t\t// Use a dynamic chunk size based on the number of elements #9774\n\t\tlet chunkSize = ExpressionContainer.BASE_CHUNK_SIZE;\n\t\twhile (!!this.indexedVariables && this.indexedVariables > chunkSize * ExpressionContainer.BASE_CHUNK_SIZE) {\n\t\t\tchunkSize *= ExpressionContainer.BASE_CHUNK_SIZE;\n\t\t}\n\n\t\tif (!!this.indexedVariables && this.indexedVariables > chunkSize) {\n\t\t\t// There are a lot of children, create fake intermediate values that represent chunks #9537\n\t\t\tconst numberOfChunks = Math.ceil(this.indexedVariables / chunkSize);\n\t\t\tfor (let i = 0; i < numberOfChunks; i++) {\n\t\t\t\tconst start = (this.startOfVariables || 0) + i * chunkSize;\n\t\t\t\tconst count = Math.min(chunkSize, this.indexedVariables - i * chunkSize);\n\t\t\t\tchildren.push(new Variable(this.session, this.threadId, this, this.reference, `[${start}..${start + count - 1}]`, '', '', undefined, count, undefined, { kind: 'virtual' }, undefined, undefined, true, start));\n\t\t\t}\n\n\t\t\treturn children;\n\t\t}\n\n\t\tconst variables = await this.fetchVariables(this.startOfVariables, this.indexedVariables, 'indexed');\n\t\treturn children.concat(variables);\n\t}\n\n\tgetId(): string {\n\t\treturn this.id;\n\t}\n\n\tgetSession(): IDebugSession | undefined {\n\t\treturn this.session;\n\t}\n\n\tget value(): string {\n\t\treturn this._value;\n\t}\n\n\tget hasChildren(): boolean {\n\t\t// only variables with reference > 0 have children.\n\t\treturn !!this.reference && this.reference > 0 && !this.presentationHint?.lazy;\n\t}\n\n\tprivate async fetchVariables(start: number | undefined, count: number | undefined, filter: 'indexed' | 'named' | undefined): Promise<Variable[]> {\n\t\ttry {\n\t\t\tconst response = await this.session!.variables(this.reference || 0, this.threadId, filter, start, count);\n\t\t\tif (!response || !response.body || !response.body.variables) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tconst nameCount = new Map<string, number>();\n\t\t\tconst vars = response.body.variables.filter(v => !!v).map((v: IDebugProtocolVariableWithContext) => {\n\t\t\t\tif (isString(v.value) && isString(v.name) && typeof v.variablesReference === 'number') {\n\t\t\t\t\tconst count = nameCount.get(v.name) || 0;\n\t\t\t\t\tconst idDuplicationIndex = count > 0 ? count.toString() : '';\n\t\t\t\t\tnameCount.set(v.name, count + 1);\n\t\t\t\t\treturn new Variable(this.session, this.threadId, this, v.variablesReference, v.name, v.evaluateName, v.value, v.namedVariables, v.indexedVariables, v.memoryReference, v.presentationHint, v.type, v.__vscodeVariableMenuContext, true, 0, idDuplicationIndex, v.declarationLocationReference, v.valueLocationReference);\n\t\t\t\t}\n\t\t\t\treturn new Variable(this.session, this.threadId, this, 0, '', undefined, nls.localize('invalidVariableAttributes', \"Invalid variable attributes\"), 0, 0, undefined, { kind: 'virtual' }, undefined, undefined, false);\n\t\t\t});\n\n\t\t\tif (this.session!.autoExpandLazyVariables) {\n\t\t\t\tawait Promise.all(vars.map(v => v.presentationHint?.lazy && v.evaluateLazy()));\n\t\t\t}\n\n\t\t\treturn vars;\n\t\t} catch (e) {\n\t\t\treturn [new Variable(this.session, this.threadId, this, 0, '', undefined, e.message, 0, 0, undefined, { kind: 'virtual' }, undefined, undefined, false)];\n\t\t}\n\t}\n\n\t// The adapter explicitly sents the children count of an expression only if there are lots of children which should be chunked.\n\tprivate get getChildrenInChunks(): boolean {\n\t\treturn !!this.indexedVariables;\n\t}\n\n\tset value(value: string) {\n\t\tthis._value = value;\n\t\tthis.valueChanged = !!ExpressionContainer.allValues.get(this.getId()) &&\n\t\t\tExpressionContainer.allValues.get(this.getId()) !== Expression.DEFAULT_VALUE && ExpressionContainer.allValues.get(this.getId()) !== value;\n\t\tExpressionContainer.allValues.set(this.getId(), value);\n\t}\n\n\ttoString(): string {\n\t\treturn this.value;\n\t}\n\n\tasync evaluateExpression(\n\t\texpression: string,\n\t\tsession: IDebugSession | undefined,\n\t\tstackFrame: IStackFrame | undefined,\n\t\tcontext: string,\n\t\tkeepLazyVars = false,\n\t\tlocation?: IDebugEvaluatePosition,\n\t): Promise<boolean> {\n\n\t\tif (!session || (!stackFrame && context !== 'repl')) {\n\t\t\tthis.value = context === 'repl' ? nls.localize('startDebugFirst', \"Please start a debug session to evaluate expressions\") : Expression.DEFAULT_VALUE;\n\t\t\tthis.reference = 0;\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.session = session;\n\t\ttry {\n\t\t\tconst response = await session.evaluate(expression, stackFrame ? stackFrame.frameId : undefined, context, location);\n\n\t\t\tif (response && response.body) {\n\t\t\t\tthis.value = response.body.result || '';\n\t\t\t\tthis.reference = response.body.variablesReference;\n\t\t\t\tthis.namedVariables = response.body.namedVariables;\n\t\t\t\tthis.indexedVariables = response.body.indexedVariables;\n\t\t\t\tthis.memoryReference = response.body.memoryReference;\n\t\t\t\tthis.type = response.body.type || this.type;\n\t\t\t\tthis.presentationHint = response.body.presentationHint;\n\t\t\t\tthis.valueLocationReference = response.body.valueLocationReference;\n\n\t\t\t\tif (!keepLazyVars && response.body.presentationHint?.lazy) {\n\t\t\t\t\tawait this.evaluateLazy();\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t} catch (e) {\n\t\t\tthis.value = e.message || '';\n\t\t\tthis.reference = 0;\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\nfunction handleSetResponse(expression: ExpressionContainer, response: DebugProtocol.SetVariableResponse | DebugProtocol.SetExpressionResponse | undefined): void {\n\tif (response && response.body) {\n\t\texpression.value = response.body.value || '';\n\t\texpression.type = response.body.type || expression.type;\n\t\texpression.reference = response.body.variablesReference;\n\t\texpression.namedVariables = response.body.namedVariables;\n\t\texpression.indexedVariables = response.body.indexedVariables;\n\t\t// todo @weinand: the set responses contain most properties, but not memory references. Should they?\n\t}\n}\n\nexport class VisualizedExpression implements IExpression {\n\tpublic errorMessage?: string;\n\tprivate readonly id = generateUuid();\n\n\tevaluateLazy(): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n\tgetChildren(): Promise<IExpression[]> {\n\t\treturn this.visualizer.getVisualizedChildren(this.session, this.treeId, this.treeItem.id);\n\t}\n\n\tgetId(): string {\n\t\treturn this.id;\n\t}\n\n\tget name() {\n\t\treturn this.treeItem.label;\n\t}\n\n\tget value() {\n\t\treturn this.treeItem.description || '';\n\t}\n\n\tget hasChildren() {\n\t\treturn this.treeItem.collapsibleState !== DebugTreeItemCollapsibleState.None;\n\t}\n\n\tconstructor(\n\t\tprivate readonly session: IDebugSession | undefined,\n\t\tprivate readonly visualizer: IDebugVisualizerService,\n\t\tpublic readonly treeId: string,\n\t\tpublic readonly treeItem: IDebugVisualizationTreeItem,\n\t\tpublic readonly original?: Variable,\n\t) { }\n\n\tpublic getSession(): IDebugSession | undefined {\n\t\treturn this.session;\n\t}\n\n\t/** Edits the value, sets the {@link errorMessage} and returns false if unsuccessful */\n\tpublic async edit(newValue: string) {\n\t\ttry {\n\t\t\tawait this.visualizer.editTreeItem(this.treeId, this.treeItem, newValue);\n\t\t\treturn true;\n\t\t} catch (e) {\n\t\t\tthis.errorMessage = e.message;\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\nexport class Expression extends ExpressionContainer implements IExpression {\n\tstatic readonly DEFAULT_VALUE = nls.localize('notAvailable', \"not available\");\n\n\tpublic available: boolean;\n\n\tprivate readonly _onDidChangeValue = new Emitter<IExpression>();\n\tpublic readonly onDidChangeValue: Event<IExpression> = this._onDidChangeValue.event;\n\n\tconstructor(public name: string, id = generateUuid()) {\n\t\tsuper(undefined, undefined, 0, id);\n\t\tthis.available = false;\n\t\t// name is not set if the expression is just being added\n\t\t// in that case do not set default value to prevent flashing #14499\n\t\tif (name) {\n\t\t\tthis.value = Expression.DEFAULT_VALUE;\n\t\t}\n\t}\n\n\tasync evaluate(session: IDebugSession | undefined, stackFrame: IStackFrame | undefined, context: string, keepLazyVars?: boolean, location?: IDebugEvaluatePosition): Promise<void> {\n\t\tconst hadDefaultValue = this.value === Expression.DEFAULT_VALUE;\n\t\tthis.available = await this.evaluateExpression(this.name, session, stackFrame, context, keepLazyVars, location);\n\t\tif (hadDefaultValue || this.valueChanged) {\n\t\t\tthis._onDidChangeValue.fire(this);\n\t\t}\n\t}\n\n\toverride toString(): string {\n\t\treturn `${this.name}\\n${this.value}`;\n\t}\n\n\tasync setExpression(value: string, stackFrame: IStackFrame): Promise<void> {\n\t\tif (!this.session) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst response = await this.session.setExpression(stackFrame.frameId, this.name, value);\n\t\thandleSetResponse(this, response);\n\t}\n}\n\nexport class Variable extends ExpressionContainer implements IExpression {\n\n\t// Used to show the error message coming from the adapter when setting the value #7807\n\tpublic errorMessage: string | undefined;\n\n\tconstructor(\n\t\tsession: IDebugSession | undefined,\n\t\tthreadId: number | undefined,\n\t\tpublic readonly parent: IExpressionContainer,\n\t\treference: number | undefined,\n\t\tpublic readonly name: string,\n\t\tpublic evaluateName: string | undefined,\n\t\tvalue: string | undefined,\n\t\tnamedVariables: number | undefined,\n\t\tindexedVariables: number | undefined,\n\t\tmemoryReference: string | undefined,\n\t\tpresentationHint: DebugProtocol.VariablePresentationHint | undefined,\n\t\ttype: string | undefined = undefined,\n\t\tpublic readonly variableMenuContext: string | undefined = undefined,\n\t\tpublic readonly available = true,\n\t\tstartOfVariables = 0,\n\t\tidDuplicationIndex = '',\n\t\tpublic readonly declarationLocationReference: number | undefined = undefined,\n\t\tvalueLocationReference: number | undefined = undefined,\n\t) {\n\t\tsuper(session, threadId, reference, `variable:${parent.getId()}:${name}:${idDuplicationIndex}`, namedVariables, indexedVariables, memoryReference, startOfVariables, presentationHint, valueLocationReference);\n\t\tthis.value = value || '';\n\t\tthis.type = type;\n\t}\n\n\tgetThreadId() {\n\t\treturn this.threadId;\n\t}\n\n\tasync setVariable(value: string, stackFrame: IStackFrame): Promise<any> {\n\t\tif (!this.session) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\t// Send out a setExpression for debug extensions that do not support set variables https://github.com/microsoft/vscode/issues/124679#issuecomment-869844437\n\t\t\tif (this.session.capabilities.supportsSetExpression && !this.session.capabilities.supportsSetVariable && this.evaluateName) {\n\t\t\t\treturn this.setExpression(value, stackFrame);\n\t\t\t}\n\n\t\t\tconst response = await this.session.setVariable((<ExpressionContainer>this.parent).reference, this.name, value);\n\t\t\thandleSetResponse(this, response);\n\t\t} catch (err) {\n\t\t\tthis.errorMessage = err.message;\n\t\t}\n\t}\n\n\tasync setExpression(value: string, stackFrame: IStackFrame): Promise<void> {\n\t\tif (!this.session || !this.evaluateName) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst response = await this.session.setExpression(stackFrame.frameId, this.evaluateName, value);\n\t\thandleSetResponse(this, response);\n\t}\n\n\toverride toString(): string {\n\t\treturn this.name ? `${this.name}: ${this.value}` : this.value;\n\t}\n\n\tprotected override adoptLazyResponse(response: DebugProtocol.Variable): void {\n\t\tthis.evaluateName = response.evaluateName;\n\t}\n\n\ttoDebugProtocolObject(): DebugProtocol.Variable {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tvariablesReference: this.reference || 0,\n\t\t\tmemoryReference: this.memoryReference,\n\t\t\tvalue: this.value,\n\t\t\tevaluateName: this.evaluateName\n\t\t};\n\t}\n}\n\nexport class Scope extends ExpressionContainer implements IScope {\n\n\tconstructor(\n\t\tpublic readonly stackFrame: IStackFrame,\n\t\tid: number,\n\t\tpublic readonly name: string,\n\t\treference: number,\n\t\tpublic expensive: boolean,\n\t\tnamedVariables?: number,\n\t\tindexedVariables?: number,\n\t\tpublic readonly range?: IRange\n\t) {\n\t\tsuper(stackFrame.thread.session, stackFrame.thread.threadId, reference, `scope:${name}:${id}`, namedVariables, indexedVariables);\n\t}\n\n\toverride toString(): string {\n\t\treturn this.name;\n\t}\n\n\ttoDebugProtocolObject(): DebugProtocol.Scope {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tvariablesReference: this.reference || 0,\n\t\t\texpensive: this.expensive\n\t\t};\n\t}\n}\n\nexport class ErrorScope extends Scope {\n\n\tconstructor(\n\t\tstackFrame: IStackFrame,\n\t\tindex: number,\n\t\tmessage: string,\n\t) {\n\t\tsuper(stackFrame, index, message, 0, false);\n\t}\n\n\toverride toString(): string {\n\t\treturn this.name;\n\t}\n}\n\nexport class StackFrame implements IStackFrame {\n\n\tprivate scopes: Promise<Scope[]> | undefined;\n\n\tconstructor(\n\t\tpublic readonly thread: Thread,\n\t\tpublic readonly frameId: number,\n\t\tpublic readonly source: Source,\n\t\tpublic readonly name: string,\n\t\tpublic readonly presentationHint: string | undefined,\n\t\tpublic readonly range: IRange,\n\t\tprivate readonly index: number,\n\t\tpublic readonly canRestart: boolean,\n\t\tpublic readonly instructionPointerReference?: string\n\t) { }\n\n\tgetId(): string {\n\t\treturn `stackframe:${this.thread.getId()}:${this.index}:${this.source.name}`;\n\t}\n\n\tgetScopes(): Promise<IScope[]> {\n\t\tif (!this.scopes) {\n\t\t\tthis.scopes = this.thread.session.scopes(this.frameId, this.thread.threadId).then(response => {\n\t\t\t\tif (!response || !response.body || !response.body.scopes) {\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\n\t\t\t\tconst usedIds = new Set<number>();\n\t\t\t\treturn response.body.scopes.map(rs => {\n\t\t\t\t\t// form the id based on the name and location so that it's the\n\t\t\t\t\t// same across multiple pauses to retain expansion state\n\t\t\t\t\tlet id = 0;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tid = stringHash(`${rs.name}:${rs.line}:${rs.column}`, id);\n\t\t\t\t\t} while (usedIds.has(id));\n\n\t\t\t\t\tusedIds.add(id);\n\t\t\t\t\treturn new Scope(this, id, rs.name, rs.variablesReference, rs.expensive, rs.namedVariables, rs.indexedVariables,\n\t\t\t\t\t\trs.line && rs.column && rs.endLine && rs.endColumn ? new Range(rs.line, rs.column, rs.endLine, rs.endColumn) : undefined);\n\n\t\t\t\t});\n\t\t\t}, err => [new ErrorScope(this, 0, err.message)]);\n\t\t}\n\n\t\treturn this.scopes;\n\t}\n\n\tasync getMostSpecificScopes(range: IRange): Promise<IScope[]> {\n\t\tconst scopes = await this.getScopes();\n\t\tconst nonExpensiveScopes = scopes.filter(s => !s.expensive);\n\t\tconst haveRangeInfo = nonExpensiveScopes.some(s => !!s.range);\n\t\tif (!haveRangeInfo) {\n\t\t\treturn nonExpensiveScopes;\n\t\t}\n\n\t\tconst scopesContainingRange = nonExpensiveScopes.filter(scope => scope.range && Range.containsRange(scope.range, range))\n\t\t\t.sort((first, second) => (first.range!.endLineNumber - first.range!.startLineNumber) - (second.range!.endLineNumber - second.range!.startLineNumber));\n\t\treturn scopesContainingRange.length ? scopesContainingRange : nonExpensiveScopes;\n\t}\n\n\trestart(): Promise<void> {\n\t\treturn this.thread.session.restartFrame(this.frameId, this.thread.threadId);\n\t}\n\n\tforgetScopes(): void {\n\t\tthis.scopes = undefined;\n\t}\n\n\ttoString(): string {\n\t\tconst lineNumberToString = typeof this.range.startLineNumber === 'number' ? `:${this.range.startLineNumber}` : '';\n\t\tconst sourceToString = `${this.source.inMemory ? this.source.name : this.source.uri.fsPath}${lineNumberToString}`;\n\n\t\treturn sourceToString === UNKNOWN_SOURCE_LABEL ? this.name : `${this.name} (${sourceToString})`;\n\t}\n\n\tasync openInEditor(editorService: IEditorService, preserveFocus?: boolean, sideBySide?: boolean, pinned?: boolean): Promise<IEditorPane | undefined> {\n\t\tconst threadStopReason = this.thread.stoppedDetails?.reason;\n\t\tif (this.instructionPointerReference &&\n\t\t\t(threadStopReason === 'instruction breakpoint' ||\n\t\t\t\t(threadStopReason === 'step' && this.thread.lastSteppingGranularity === 'instruction') ||\n\t\t\t\teditorService.activeEditor instanceof DisassemblyViewInput)) {\n\t\t\treturn editorService.openEditor(DisassemblyViewInput.instance, { pinned: true, revealIfOpened: true });\n\t\t}\n\n\t\tif (this.source.available) {\n\t\t\treturn this.source.openInEditor(editorService, this.range, preserveFocus, sideBySide, pinned);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tequals(other: IStackFrame): boolean {\n\t\treturn (this.name === other.name) && (other.thread === this.thread) && (this.frameId === other.frameId) && (other.source === this.source) && (Range.equalsRange(this.range, other.range));\n\t}\n}\n\nconst KEEP_SUBTLE_FRAME_AT_TOP_REASONS: readonly string[] = ['breakpoint', 'step', 'function breakpoint'];\n\nexport class Thread implements IThread {\n\tprivate callStack: IStackFrame[];\n\tprivate staleCallStack: IStackFrame[];\n\tprivate callStackCancellationTokens: CancellationTokenSource[] = [];\n\tpublic stoppedDetails: IRawStoppedDetails | undefined;\n\tpublic stopped: boolean;\n\tpublic reachedEndOfCallStack = false;\n\tpublic lastSteppingGranularity: DebugProtocol.SteppingGranularity | undefined;\n\n\tconstructor(public readonly session: IDebugSession, public name: string, public readonly threadId: number) {\n\t\tthis.callStack = [];\n\t\tthis.staleCallStack = [];\n\t\tthis.stopped = false;\n\t}\n\n\tgetId(): string {\n\t\treturn `thread:${this.session.getId()}:${this.threadId}`;\n\t}\n\n\tclearCallStack(): void {\n\t\tif (this.callStack.length) {\n\t\t\tthis.staleCallStack = this.callStack;\n\t\t}\n\t\tthis.callStack = [];\n\t\tthis.callStackCancellationTokens.forEach(c => c.dispose(true));\n\t\tthis.callStackCancellationTokens = [];\n\t}\n\n\tgetCallStack(): IStackFrame[] {\n\t\treturn this.callStack;\n\t}\n\n\tgetStaleCallStack(): ReadonlyArray<IStackFrame> {\n\t\treturn this.staleCallStack;\n\t}\n\n\tgetTopStackFrame(): IStackFrame | undefined {\n\t\tconst callStack = this.getCallStack();\n\t\tconst stopReason = this.stoppedDetails?.reason;\n\t\t// Allow stack frame without source and with instructionReferencePointer as top stack frame when using disassembly view.\n\t\tconst firstAvailableStackFrame = callStack.find(sf => !!(\n\t\t\t((stopReason === 'instruction breakpoint' || (stopReason === 'step' && this.lastSteppingGranularity === 'instruction')) && sf.instructionPointerReference) ||\n\t\t\t(sf.source && sf.source.available && (KEEP_SUBTLE_FRAME_AT_TOP_REASONS.includes(stopReason!) || !isFrameDeemphasized(sf)))));\n\t\treturn firstAvailableStackFrame;\n\t}\n\n\tget stateLabel(): string {\n\t\tif (this.stoppedDetails) {\n\t\t\treturn this.stoppedDetails.description ||\n\t\t\t\t(this.stoppedDetails.reason ? nls.localize({ key: 'pausedOn', comment: ['indicates reason for program being paused'] }, \"Paused on {0}\", this.stoppedDetails.reason) : nls.localize('paused', \"Paused\"));\n\t\t}\n\n\t\treturn nls.localize({ key: 'running', comment: ['indicates state'] }, \"Running\");\n\t}\n\n\t/**\n\t * Queries the debug adapter for the callstack and returns a promise\n\t * which completes once the call stack has been retrieved.\n\t * If the thread is not stopped, it returns a promise to an empty array.\n\t * Only fetches the first stack frame for performance reasons. Calling this method consecutive times\n\t * gets the remainder of the call stack.\n\t */\n\tasync fetchCallStack(levels = 20): Promise<void> {\n\t\tif (this.stopped) {\n\t\t\tconst start = this.callStack.length;\n\t\t\tconst callStack = await this.getCallStackImpl(start, levels);\n\t\t\tthis.reachedEndOfCallStack = callStack.length < levels;\n\t\t\tif (start < this.callStack.length) {\n\t\t\t\t// Set the stack frames for exact position we requested. To make sure no concurrent requests create duplicate stack frames #30660\n\t\t\t\tthis.callStack.splice(start, this.callStack.length - start);\n\t\t\t}\n\t\t\tthis.callStack = this.callStack.concat(callStack || []);\n\t\t\tif (typeof this.stoppedDetails?.totalFrames === 'number' && this.stoppedDetails.totalFrames === this.callStack.length) {\n\t\t\t\tthis.reachedEndOfCallStack = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async getCallStackImpl(startFrame: number, levels: number): Promise<IStackFrame[]> {\n\t\ttry {\n\t\t\tconst tokenSource = new CancellationTokenSource();\n\t\t\tthis.callStackCancellationTokens.push(tokenSource);\n\t\t\tconst response = await this.session.stackTrace(this.threadId, startFrame, levels, tokenSource.token);\n\t\t\tif (!response || !response.body || tokenSource.token.isCancellationRequested) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tif (this.stoppedDetails) {\n\t\t\t\tthis.stoppedDetails.totalFrames = response.body.totalFrames;\n\t\t\t}\n\n\t\t\treturn response.body.stackFrames.map((rsf, index) => {\n\t\t\t\tconst source = this.session.getSource(rsf.source);\n\n\t\t\t\treturn new StackFrame(this, rsf.id, source, rsf.name, rsf.presentationHint, new Range(\n\t\t\t\t\trsf.line,\n\t\t\t\t\trsf.column,\n\t\t\t\t\trsf.endLine || rsf.line,\n\t\t\t\t\trsf.endColumn || rsf.column\n\t\t\t\t), startFrame + index, typeof rsf.canRestart === 'boolean' ? rsf.canRestart : true, rsf.instructionPointerReference);\n\t\t\t});\n\t\t} catch (err) {\n\t\t\tif (this.stoppedDetails) {\n\t\t\t\tthis.stoppedDetails.framesErrorMessage = err.message;\n\t\t\t}\n\n\t\t\treturn [];\n\t\t}\n\t}\n\n\t/**\n\t * Returns exception info promise if the exception was thrown, otherwise undefined\n\t */\n\tget exceptionInfo(): Promise<IExceptionInfo | undefined> {\n\t\tif (this.stoppedDetails && this.stoppedDetails.reason === 'exception') {\n\t\t\tif (this.session.capabilities.supportsExceptionInfoRequest) {\n\t\t\t\treturn this.session.exceptionInfo(this.threadId);\n\t\t\t}\n\t\t\treturn Promise.resolve({\n\t\t\t\tdescription: this.stoppedDetails.text,\n\t\t\t\tbreakMode: null\n\t\t\t});\n\t\t}\n\t\treturn Promise.resolve(undefined);\n\t}\n\n\tnext(granularity?: DebugProtocol.SteppingGranularity): Promise<any> {\n\t\treturn this.session.next(this.threadId, granularity);\n\t}\n\n\tstepIn(granularity?: DebugProtocol.SteppingGranularity): Promise<any> {\n\t\treturn this.session.stepIn(this.threadId, undefined, granularity);\n\t}\n\n\tstepOut(granularity?: DebugProtocol.SteppingGranularity): Promise<any> {\n\t\treturn this.session.stepOut(this.threadId, granularity);\n\t}\n\n\tstepBack(granularity?: DebugProtocol.SteppingGranularity): Promise<any> {\n\t\treturn this.session.stepBack(this.threadId, granularity);\n\t}\n\n\tcontinue(): Promise<any> {\n\t\treturn this.session.continue(this.threadId);\n\t}\n\n\tpause(): Promise<any> {\n\t\treturn this.session.pause(this.threadId);\n\t}\n\n\tterminate(): Promise<any> {\n\t\treturn this.session.terminateThreads([this.threadId]);\n\t}\n\n\treverseContinue(): Promise<any> {\n\t\treturn this.session.reverseContinue(this.threadId);\n\t}\n}\n\n/**\n * Gets a URI to a memory in the given session ID.\n */\nexport const getUriForDebugMemory = (\n\tsessionId: string,\n\tmemoryReference: string,\n\trange?: { fromOffset: number; toOffset: number },\n\tdisplayName = 'memory'\n) => {\n\treturn URI.from({\n\t\tscheme: DEBUG_MEMORY_SCHEME,\n\t\tauthority: sessionId,\n\t\tpath: '/' + encodeURIComponent(memoryReference) + `/${encodeURIComponent(displayName)}.bin`,\n\t\tquery: range ? `?range=${range.fromOffset}:${range.toOffset}` : undefined,\n\t});\n};\n\nexport class MemoryRegion extends Disposable implements IMemoryRegion {\n\tprivate readonly invalidateEmitter = this._register(new Emitter<IMemoryInvalidationEvent>());\n\n\t/** @inheritdoc */\n\tpublic readonly onDidInvalidate = this.invalidateEmitter.event;\n\n\t/** @inheritdoc */\n\tpublic readonly writable = !!this.session.capabilities.supportsWriteMemoryRequest;\n\n\tconstructor(private readonly memoryReference: string, private readonly session: IDebugSession) {\n\t\tsuper();\n\t\tthis._register(session.onDidInvalidateMemory(e => {\n\t\t\tif (e.body.memoryReference === memoryReference) {\n\t\t\t\tthis.invalidate(e.body.offset, e.body.count - e.body.offset);\n\t\t\t}\n\t\t}));\n\t}\n\n\tpublic async read(fromOffset: number, toOffset: number): Promise<MemoryRange[]> {\n\t\tconst length = toOffset - fromOffset;\n\t\tconst offset = fromOffset;\n\t\tconst result = await this.session.readMemory(this.memoryReference, offset, length);\n\n\t\tif (result === undefined || !result.body?.data) {\n\t\t\treturn [{ type: MemoryRangeType.Unreadable, offset, length }];\n\t\t}\n\n\t\tlet data: VSBuffer;\n\t\ttry {\n\t\t\tdata = decodeBase64(result.body.data);\n\t\t} catch {\n\t\t\treturn [{ type: MemoryRangeType.Error, offset, length, error: 'Invalid base64 data from debug adapter' }];\n\t\t}\n\n\t\tconst unreadable = result.body.unreadableBytes || 0;\n\t\tconst dataLength = length - unreadable;\n\t\tif (data.byteLength < dataLength) {\n\t\t\tconst pad = VSBuffer.alloc(dataLength - data.byteLength);\n\t\t\tpad.buffer.fill(0);\n\t\t\tdata = VSBuffer.concat([data, pad], dataLength);\n\t\t} else if (data.byteLength > dataLength) {\n\t\t\tdata = data.slice(0, dataLength);\n\t\t}\n\n\t\tif (!unreadable) {\n\t\t\treturn [{ type: MemoryRangeType.Valid, offset, length, data }];\n\t\t}\n\n\t\treturn [\n\t\t\t{ type: MemoryRangeType.Valid, offset, length: dataLength, data },\n\t\t\t{ type: MemoryRangeType.Unreadable, offset: offset + dataLength, length: unreadable },\n\t\t];\n\t}\n\n\tpublic async write(offset: number, data: VSBuffer): Promise<number> {\n\t\tconst result = await this.session.writeMemory(this.memoryReference, offset, encodeBase64(data), true);\n\t\tconst written = result?.body?.bytesWritten ?? data.byteLength;\n\t\tthis.invalidate(offset, offset + written);\n\t\treturn written;\n\t}\n\n\tpublic override dispose() {\n\t\tsuper.dispose();\n\t}\n\n\tprivate invalidate(fromOffset: number, toOffset: number) {\n\t\tthis.invalidateEmitter.fire({ fromOffset, toOffset });\n\t}\n}\n\nexport class Enablement implements IEnablement {\n\tconstructor(\n\t\tpublic enabled: boolean,\n\t\tprivate readonly id: string\n\t) { }\n\n\tgetId(): string {\n\t\treturn this.id;\n\t}\n}\n\ninterface IBreakpointSessionData extends DebugProtocol.Breakpoint {\n\tsupportsConditionalBreakpoints: boolean;\n\tsupportsHitConditionalBreakpoints: boolean;\n\tsupportsLogPoints: boolean;\n\tsupportsFunctionBreakpoints: boolean;\n\tsupportsDataBreakpoints: boolean;\n\tsupportsInstructionBreakpoints: boolean;\n\tsessionId: string;\n}\n\nfunction toBreakpointSessionData(data: DebugProtocol.Breakpoint, capabilities: DebugProtocol.Capabilities): IBreakpointSessionData {\n\treturn mixin({\n\t\tsupportsConditionalBreakpoints: !!capabilities.supportsConditionalBreakpoints,\n\t\tsupportsHitConditionalBreakpoints: !!capabilities.supportsHitConditionalBreakpoints,\n\t\tsupportsLogPoints: !!capabilities.supportsLogPoints,\n\t\tsupportsFunctionBreakpoints: !!capabilities.supportsFunctionBreakpoints,\n\t\tsupportsDataBreakpoints: !!capabilities.supportsDataBreakpoints,\n\t\tsupportsInstructionBreakpoints: !!capabilities.supportsInstructionBreakpoints\n\t}, data);\n}\n\nexport interface IBaseBreakpointOptions {\n\tenabled?: boolean;\n\thitCondition?: string;\n\tcondition?: string;\n\tlogMessage?: string;\n\tmode?: string;\n\tmodeLabel?: string;\n}\n\nexport abstract class BaseBreakpoint extends Enablement implements IBaseBreakpoint {\n\n\tprivate sessionData = new Map<string, IBreakpointSessionData>();\n\tprotected data: IBreakpointSessionData | undefined;\n\tpublic hitCondition: string | undefined;\n\tpublic condition: string | undefined;\n\tpublic logMessage: string | undefined;\n\tpublic mode: string | undefined;\n\tpublic modeLabel: string | undefined;\n\n\tconstructor(\n\t\tid: string,\n\t\topts: IBaseBreakpointOptions\n\t) {\n\t\tsuper(opts.enabled ?? true, id);\n\t\tthis.condition = opts.condition;\n\t\tthis.hitCondition = opts.hitCondition;\n\t\tthis.logMessage = opts.logMessage;\n\t\tthis.mode = opts.mode;\n\t\tthis.modeLabel = opts.modeLabel;\n\t}\n\n\tsetSessionData(sessionId: string, data: IBreakpointSessionData | undefined): void {\n\t\tif (!data) {\n\t\t\tthis.sessionData.delete(sessionId);\n\t\t} else {\n\t\t\tdata.sessionId = sessionId;\n\t\t\tthis.sessionData.set(sessionId, data);\n\t\t}\n\n\t\tconst allData = Array.from(this.sessionData.values());\n\t\tconst verifiedData = distinct(allData.filter(d => d.verified), d => `${d.line}:${d.column}`);\n\t\tif (verifiedData.length) {\n\t\t\t// In case multiple session verified the breakpoint and they provide different data show the intial data that the user set (corner case)\n\t\t\tthis.data = verifiedData.length === 1 ? verifiedData[0] : undefined;\n\t\t} else {\n\t\t\t// No session verified the breakpoint\n\t\t\tthis.data = allData.length ? allData[0] : undefined;\n\t\t}\n\t}\n\n\tget message(): string | undefined {\n\t\tif (!this.data) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn this.data.message;\n\t}\n\n\tget verified(): boolean {\n\t\treturn this.data ? this.data.verified : true;\n\t}\n\n\tget sessionsThatVerified() {\n\t\tconst sessionIds: string[] = [];\n\t\tfor (const [sessionId, data] of this.sessionData) {\n\t\t\tif (data.verified) {\n\t\t\t\tsessionIds.push(sessionId);\n\t\t\t}\n\t\t}\n\n\t\treturn sessionIds;\n\t}\n\n\tabstract get supported(): boolean;\n\n\tgetIdFromAdapter(sessionId: string): number | undefined {\n\t\tconst data = this.sessionData.get(sessionId);\n\t\treturn data ? data.id : undefined;\n\t}\n\n\tgetDebugProtocolBreakpoint(sessionId: string): DebugProtocol.Breakpoint | undefined {\n\t\tconst data = this.sessionData.get(sessionId);\n\t\tif (data) {\n\t\t\tconst bp: DebugProtocol.Breakpoint = {\n\t\t\t\tid: data.id,\n\t\t\t\tverified: data.verified,\n\t\t\t\tmessage: data.message,\n\t\t\t\tsource: data.source,\n\t\t\t\tline: data.line,\n\t\t\t\tcolumn: data.column,\n\t\t\t\tendLine: data.endLine,\n\t\t\t\tendColumn: data.endColumn,\n\t\t\t\tinstructionReference: data.instructionReference,\n\t\t\t\toffset: data.offset\n\t\t\t};\n\t\t\treturn bp;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\ttoJSON(): IBaseBreakpointOptions & { id: string } {\n\t\treturn {\n\t\t\tid: this.getId(),\n\t\t\tenabled: this.enabled,\n\t\t\tcondition: this.condition,\n\t\t\thitCondition: this.hitCondition,\n\t\t\tlogMessage: this.logMessage,\n\t\t\tmode: this.mode,\n\t\t\tmodeLabel: this.modeLabel,\n\t\t};\n\t}\n}\n\nexport interface IBreakpointOptions extends IBaseBreakpointOptions {\n\turi: uri;\n\tlineNumber: number;\n\tcolumn: number | undefined;\n\tadapterData: any;\n\ttriggeredBy: string | undefined;\n}\n\nexport class Breakpoint extends BaseBreakpoint implements IBreakpoint {\n\tprivate sessionsDidTrigger?: Set<string>;\n\tprivate readonly _uri: uri;\n\tprivate _adapterData: any;\n\tprivate _lineNumber: number;\n\tprivate _column: number | undefined;\n\tpublic triggeredBy: string | undefined;\n\n\tconstructor(\n\t\topts: IBreakpointOptions,\n\t\tprivate readonly textFileService: ITextFileService,\n\t\tprivate readonly uriIdentityService: IUriIdentityService,\n\t\tprivate readonly logService: ILogService,\n\t\tid = generateUuid(),\n\t) {\n\t\tsuper(id, opts);\n\t\tthis._uri = opts.uri;\n\t\tthis._lineNumber = opts.lineNumber;\n\t\tthis._column = opts.column;\n\t\tthis._adapterData = opts.adapterData;\n\t\tthis.triggeredBy = opts.triggeredBy;\n\t}\n\n\ttoDAP(): DebugProtocol.SourceBreakpoint {\n\t\treturn {\n\t\t\tline: this.sessionAgnosticData.lineNumber,\n\t\t\tcolumn: this.sessionAgnosticData.column,\n\t\t\tcondition: this.condition,\n\t\t\thitCondition: this.hitCondition,\n\t\t\tlogMessage: this.logMessage,\n\t\t\tmode: this.mode\n\t\t};\n\t}\n\n\tget originalUri() {\n\t\treturn this._uri;\n\t}\n\n\tget lineNumber(): number {\n\t\treturn this.verified && this.data && typeof this.data.line === 'number' ? this.data.line : this._lineNumber;\n\t}\n\n\toverride get verified(): boolean {\n\t\tif (this.data) {\n\t\t\treturn this.data.verified && !this.textFileService.isDirty(this._uri);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tget pending(): boolean {\n\t\tif (this.data) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.triggeredBy !== undefined;\n\t}\n\n\tget uri(): uri {\n\t\treturn this.verified && this.data && this.data.source ? getUriFromSource(this.data.source, this.data.source.path, this.data.sessionId, this.uriIdentityService, this.logService) : this._uri;\n\t}\n\n\tget column(): number | undefined {\n\t\treturn this.verified && this.data && typeof this.data.column === 'number' ? this.data.column : this._column;\n\t}\n\n\toverride get message(): string | undefined {\n\t\tif (this.textFileService.isDirty(this.uri)) {\n\t\t\treturn nls.localize('breakpointDirtydHover', \"Unverified breakpoint. File is modified, please restart debug session.\");\n\t\t}\n\n\t\treturn super.message;\n\t}\n\n\tget adapterData(): any {\n\t\treturn this.data && this.data.source && this.data.source.adapterData ? this.data.source.adapterData : this._adapterData;\n\t}\n\n\tget endLineNumber(): number | undefined {\n\t\treturn this.verified && this.data ? this.data.endLine : undefined;\n\t}\n\n\tget endColumn(): number | undefined {\n\t\treturn this.verified && this.data ? this.data.endColumn : undefined;\n\t}\n\n\tget sessionAgnosticData(): { lineNumber: number; column: number | undefined } {\n\t\treturn {\n\t\t\tlineNumber: this._lineNumber,\n\t\t\tcolumn: this._column\n\t\t};\n\t}\n\n\tget supported(): boolean {\n\t\tif (!this.data) {\n\t\t\treturn true;\n\t\t}\n\t\tif (this.logMessage && !this.data.supportsLogPoints) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.condition && !this.data.supportsConditionalBreakpoints) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.hitCondition && !this.data.supportsHitConditionalBreakpoints) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\toverride setSessionData(sessionId: string, data: IBreakpointSessionData | undefined): void {\n\t\tsuper.setSessionData(sessionId, data);\n\t\tif (!this._adapterData) {\n\t\t\tthis._adapterData = this.adapterData;\n\t\t}\n\t}\n\n\toverride toJSON(): IBreakpointOptions & { id: string } {\n\t\treturn {\n\t\t\t...super.toJSON(),\n\t\t\turi: this._uri,\n\t\t\tlineNumber: this._lineNumber,\n\t\t\tcolumn: this._column,\n\t\t\tadapterData: this.adapterData,\n\t\t\ttriggeredBy: this.triggeredBy,\n\t\t};\n\t}\n\n\toverride toString(): string {\n\t\treturn `${resources.basenameOrAuthority(this.uri)} ${this.lineNumber}`;\n\t}\n\n\tpublic setSessionDidTrigger(sessionId: string): void {\n\t\tthis.sessionsDidTrigger ??= new Set();\n\t\tthis.sessionsDidTrigger.add(sessionId);\n\t}\n\n\tpublic getSessionDidTrigger(sessionId: string): boolean {\n\t\treturn !!this.sessionsDidTrigger?.has(sessionId);\n\t}\n\n\tupdate(data: IBreakpointUpdateData): void {\n\t\tif (data.hasOwnProperty('lineNumber') && !isUndefinedOrNull(data.lineNumber)) {\n\t\t\tthis._lineNumber = data.lineNumber;\n\t\t}\n\t\tif (data.hasOwnProperty('column')) {\n\t\t\tthis._column = data.column;\n\t\t}\n\t\tif (data.hasOwnProperty('condition')) {\n\t\t\tthis.condition = data.condition;\n\t\t}\n\t\tif (data.hasOwnProperty('hitCondition')) {\n\t\t\tthis.hitCondition = data.hitCondition;\n\t\t}\n\t\tif (data.hasOwnProperty('logMessage')) {\n\t\t\tthis.logMessage = data.logMessage;\n\t\t}\n\t\tif (data.hasOwnProperty('mode')) {\n\t\t\tthis.mode = data.mode;\n\t\t\tthis.modeLabel = data.modeLabel;\n\t\t}\n\t\tif (data.hasOwnProperty('triggeredBy')) {\n\t\t\tthis.triggeredBy = data.triggeredBy;\n\t\t\tthis.sessionsDidTrigger = undefined;\n\t\t}\n\t}\n}\n\nexport interface IFunctionBreakpointOptions extends IBaseBreakpointOptions {\n\tname: string;\n}\n\nexport class FunctionBreakpoint extends BaseBreakpoint implements IFunctionBreakpoint {\n\tpublic name: string;\n\n\tconstructor(\n\t\topts: IFunctionBreakpointOptions,\n\t\tid = generateUuid()\n\t) {\n\t\tsuper(id, opts);\n\t\tthis.name = opts.name;\n\t}\n\n\ttoDAP(): DebugProtocol.FunctionBreakpoint {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tcondition: this.condition,\n\t\t\thitCondition: this.hitCondition,\n\t\t};\n\t}\n\n\toverride toJSON(): IFunctionBreakpointOptions & { id: string } {\n\t\treturn {\n\t\t\t...super.toJSON(),\n\t\t\tname: this.name,\n\t\t};\n\t}\n\n\tget supported(): boolean {\n\t\tif (!this.data) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn this.data.supportsFunctionBreakpoints;\n\t}\n\n\toverride toString(): string {\n\t\treturn this.name;\n\t}\n}\n\nexport interface IDataBreakpointOptions extends IBaseBreakpointOptions {\n\tdescription: string;\n\tsrc: DataBreakpointSource;\n\tcanPersist: boolean;\n\tinitialSessionData?: { session: IDebugSession; dataId: string };\n\taccessTypes: DebugProtocol.DataBreakpointAccessType[] | undefined;\n\taccessType: DebugProtocol.DataBreakpointAccessType;\n}\n\nexport class DataBreakpoint extends BaseBreakpoint implements IDataBreakpoint {\n\tprivate readonly sessionDataIdForAddr = new WeakMap<IDebugSession, string | null>();\n\n\tpublic readonly description: string;\n\tpublic readonly src: DataBreakpointSource;\n\tpublic readonly canPersist: boolean;\n\tpublic readonly accessTypes: DebugProtocol.DataBreakpointAccessType[] | undefined;\n\tpublic readonly accessType: DebugProtocol.DataBreakpointAccessType;\n\n\tconstructor(\n\t\topts: IDataBreakpointOptions,\n\t\tid = generateUuid()\n\t) {\n\t\tsuper(id, opts);\n\t\tthis.description = opts.description;\n\t\tif ('dataId' in opts) { //  back compat with old saved variables in 1.87\n\t\t\topts.src = { type: DataBreakpointSetType.Variable, dataId: opts.dataId as string };\n\t\t}\n\t\tthis.src = opts.src;\n\t\tthis.canPersist = opts.canPersist;\n\t\tthis.accessTypes = opts.accessTypes;\n\t\tthis.accessType = opts.accessType;\n\t\tif (opts.initialSessionData) {\n\t\t\tthis.sessionDataIdForAddr.set(opts.initialSessionData.session, opts.initialSessionData.dataId);\n\t\t}\n\t}\n\n\tasync toDAP(session: IDebugSession): Promise<DebugProtocol.DataBreakpoint | undefined> {\n\t\tlet dataId: string;\n\t\tif (this.src.type === DataBreakpointSetType.Variable) {\n\t\t\tdataId = this.src.dataId;\n\t\t} else {\n\t\t\tlet sessionDataId = this.sessionDataIdForAddr.get(session);\n\t\t\tif (!sessionDataId) {\n\t\t\t\tsessionDataId = (await session.dataBytesBreakpointInfo(this.src.address, this.src.bytes))?.dataId;\n\t\t\t\tif (!sessionDataId) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tthis.sessionDataIdForAddr.set(session, sessionDataId);\n\t\t\t}\n\t\t\tdataId = sessionDataId;\n\t\t}\n\n\t\treturn {\n\t\t\tdataId,\n\t\t\taccessType: this.accessType,\n\t\t\tcondition: this.condition,\n\t\t\thitCondition: this.hitCondition,\n\t\t};\n\t}\n\n\toverride toJSON(): IDataBreakpointOptions & { id: string } {\n\t\treturn {\n\t\t\t...super.toJSON(),\n\t\t\tdescription: this.description,\n\t\t\tsrc: this.src,\n\t\t\taccessTypes: this.accessTypes,\n\t\t\taccessType: this.accessType,\n\t\t\tcanPersist: this.canPersist,\n\t\t};\n\t}\n\n\tget supported(): boolean {\n\t\tif (!this.data) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn this.data.supportsDataBreakpoints;\n\t}\n\n\toverride toString(): string {\n\t\treturn this.description;\n\t}\n}\n\nexport interface IExceptionBreakpointOptions extends IBaseBreakpointOptions {\n\tfilter: string;\n\tlabel: string;\n\tsupportsCondition: boolean;\n\tdescription: string | undefined;\n\tconditionDescription: string | undefined;\n\tfallback?: boolean;\n}\n\nexport class ExceptionBreakpoint extends BaseBreakpoint implements IExceptionBreakpoint {\n\n\tprivate supportedSessions: Set<string> = new Set();\n\n\tpublic readonly filter: string;\n\tpublic readonly label: string;\n\tpublic readonly supportsCondition: boolean;\n\tpublic readonly description: string | undefined;\n\tpublic readonly conditionDescription: string | undefined;\n\tprivate fallback: boolean = false;\n\n\tconstructor(\n\t\topts: IExceptionBreakpointOptions,\n\t\tid = generateUuid(),\n\t) {\n\t\tsuper(id, opts);\n\t\tthis.filter = opts.filter;\n\t\tthis.label = opts.label;\n\t\tthis.supportsCondition = opts.supportsCondition;\n\t\tthis.description = opts.description;\n\t\tthis.conditionDescription = opts.conditionDescription;\n\t\tthis.fallback = opts.fallback || false;\n\t}\n\n\toverride toJSON(): IExceptionBreakpointOptions & { id: string } {\n\t\treturn {\n\t\t\t...super.toJSON(),\n\t\t\tfilter: this.filter,\n\t\t\tlabel: this.label,\n\t\t\tenabled: this.enabled,\n\t\t\tsupportsCondition: this.supportsCondition,\n\t\t\tconditionDescription: this.conditionDescription,\n\t\t\tcondition: this.condition,\n\t\t\tfallback: this.fallback,\n\t\t\tdescription: this.description,\n\t\t};\n\t}\n\n\tsetSupportedSession(sessionId: string, supported: boolean): void {\n\t\tif (supported) {\n\t\t\tthis.supportedSessions.add(sessionId);\n\t\t}\n\t\telse {\n\t\t\tthis.supportedSessions.delete(sessionId);\n\t\t}\n\t}\n\n\t/**\n\t * Used to specify which breakpoints to show when no session is specified.\n\t * Useful when no session is active and we want to show the exception breakpoints from the last session.\n\t */\n\tsetFallback(isFallback: boolean) {\n\t\tthis.fallback = isFallback;\n\t}\n\n\tget supported(): boolean {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Checks if the breakpoint is applicable for the specified session.\n\t * If sessionId is undefined, returns true if this breakpoint is a fallback breakpoint.\n\t */\n\tisSupportedSession(sessionId?: string): boolean {\n\t\treturn sessionId ? this.supportedSessions.has(sessionId) : this.fallback;\n\t}\n\n\tmatches(filter: DebugProtocol.ExceptionBreakpointsFilter) {\n\t\treturn this.filter === filter.filter\n\t\t\t&& this.label === filter.label\n\t\t\t&& this.supportsCondition === !!filter.supportsCondition\n\t\t\t&& this.conditionDescription === filter.conditionDescription\n\t\t\t&& this.description === filter.description;\n\t}\n\n\toverride toString(): string {\n\t\treturn this.label;\n\t}\n}\n\nexport interface IInstructionBreakpointOptions extends IBaseBreakpointOptions {\n\tinstructionReference: string;\n\toffset: number;\n\tcanPersist: boolean;\n\taddress: bigint;\n}\n\nexport class InstructionBreakpoint extends BaseBreakpoint implements IInstructionBreakpoint {\n\tpublic readonly instructionReference: string;\n\tpublic readonly offset: number;\n\tpublic readonly canPersist: boolean;\n\tpublic readonly address: bigint;\n\n\tconstructor(\n\t\topts: IInstructionBreakpointOptions,\n\t\tid = generateUuid()\n\t) {\n\t\tsuper(id, opts);\n\t\tthis.instructionReference = opts.instructionReference;\n\t\tthis.offset = opts.offset;\n\t\tthis.canPersist = opts.canPersist;\n\t\tthis.address = opts.address;\n\t}\n\n\ttoDAP(): DebugProtocol.InstructionBreakpoint {\n\t\treturn {\n\t\t\tinstructionReference: this.instructionReference,\n\t\t\tcondition: this.condition,\n\t\t\thitCondition: this.hitCondition,\n\t\t\tmode: this.mode,\n\t\t\toffset: this.offset,\n\t\t};\n\t}\n\n\toverride toJSON(): IInstructionBreakpointOptions & { id: string } {\n\t\treturn {\n\t\t\t...super.toJSON(),\n\t\t\tinstructionReference: this.instructionReference,\n\t\t\toffset: this.offset,\n\t\t\tcanPersist: this.canPersist,\n\t\t\taddress: this.address,\n\t\t};\n\t}\n\n\tget supported(): boolean {\n\t\tif (!this.data) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn this.data.supportsInstructionBreakpoints;\n\t}\n\n\toverride toString(): string {\n\t\treturn this.instructionReference;\n\t}\n}\n\nexport class ThreadAndSessionIds implements ITreeElement {\n\tconstructor(public sessionId: string, public threadId: number) { }\n\n\tgetId(): string {\n\t\treturn `${this.sessionId}:${this.threadId}`;\n\t}\n}\n\ninterface IBreakpointModeInternal extends DebugProtocol.BreakpointMode {\n\tfirstFromDebugType: string;\n}\n\nexport class DebugModel extends Disposable implements IDebugModel {\n\n\tprivate sessions: IDebugSession[];\n\tprivate schedulers = new Map<string, { scheduler: RunOnceScheduler; completeDeferred: DeferredPromise<void> }>();\n\tprivate breakpointsActivated = true;\n\tprivate readonly _onDidChangeBreakpoints = this._register(new Emitter<IBreakpointsChangeEvent | undefined>());\n\tprivate readonly _onDidChangeCallStack = this._register(new Emitter<void>());\n\tprivate readonly _onDidChangeWatchExpressions = this._register(new Emitter<IExpression | undefined>());\n\tprivate readonly _onDidChangeWatchExpressionValue = this._register(new Emitter<IExpression | undefined>());\n\tprivate readonly _breakpointModes = new Map<string, IBreakpointModeInternal>();\n\tprivate breakpoints!: Breakpoint[];\n\tprivate functionBreakpoints!: FunctionBreakpoint[];\n\tprivate exceptionBreakpoints!: ExceptionBreakpoint[];\n\tprivate dataBreakpoints!: DataBreakpoint[];\n\tprivate watchExpressions!: Expression[];\n\tprivate instructionBreakpoints: InstructionBreakpoint[];\n\n\tconstructor(\n\t\tdebugStorage: DebugStorage,\n\t\t@ITextFileService private readonly textFileService: ITextFileService,\n\t\t@IUriIdentityService private readonly uriIdentityService: IUriIdentityService,\n\t\t@ILogService private readonly logService: ILogService\n\t) {\n\t\tsuper();\n\n\t\tthis._register(autorun(reader => {\n\t\t\tthis.breakpoints = debugStorage.breakpoints.read(reader);\n\t\t\tthis.functionBreakpoints = debugStorage.functionBreakpoints.read(reader);\n\t\t\tthis.exceptionBreakpoints = debugStorage.exceptionBreakpoints.read(reader);\n\t\t\tthis.dataBreakpoints = debugStorage.dataBreakpoints.read(reader);\n\t\t\tthis._onDidChangeBreakpoints.fire(undefined);\n\t\t}));\n\n\t\tthis._register(autorun(reader => {\n\t\t\tthis.watchExpressions = debugStorage.watchExpressions.read(reader);\n\t\t\tthis._onDidChangeWatchExpressions.fire(undefined);\n\t\t}));\n\n\t\tthis._register(trackSetChanges(\n\t\t\t() => new Set(this.watchExpressions),\n\t\t\tthis.onDidChangeWatchExpressions,\n\t\t\t(we) => we.onDidChangeValue((e) => this._onDidChangeWatchExpressionValue.fire(e)))\n\t\t);\n\n\t\tthis.instructionBreakpoints = [];\n\t\tthis.sessions = [];\n\t}\n\n\tgetId(): string {\n\t\treturn 'root';\n\t}\n\n\tgetSession(sessionId: string | undefined, includeInactive = false): IDebugSession | undefined {\n\t\tif (sessionId) {\n\t\t\treturn this.getSessions(includeInactive).find(s => s.getId() === sessionId);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tgetSessions(includeInactive = false): IDebugSession[] {\n\t\t// By default do not return inactive sessions.\n\t\t// However we are still holding onto inactive sessions due to repl and debug service session revival (eh scenario)\n\t\treturn this.sessions.filter(s => includeInactive || s.state !== State.Inactive);\n\t}\n\n\taddSession(session: IDebugSession): void {\n\t\tthis.sessions = this.sessions.filter(s => {\n\t\t\tif (s.getId() === session.getId()) {\n\t\t\t\t// Make sure to de-dupe if a session is re-initialized. In case of EH debugging we are adding a session again after an attach.\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (s.state === State.Inactive && s.configuration.name === session.configuration.name) {\n\t\t\t\t// Make sure to remove all inactive sessions that are using the same configuration as the new session\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t});\n\n\t\tlet i = 1;\n\t\twhile (this.sessions.some(s => s.getLabel() === session.getLabel())) {\n\t\t\tsession.setName(`${session.configuration.name} ${++i}`);\n\t\t}\n\n\t\tlet index = -1;\n\t\tif (session.parentSession) {\n\t\t\t// Make sure that child sessions are placed after the parent session\n\t\t\tindex = findLastIdx(this.sessions, s => s.parentSession === session.parentSession || s === session.parentSession);\n\t\t}\n\t\tif (index >= 0) {\n\t\t\tthis.sessions.splice(index + 1, 0, session);\n\t\t} else {\n\t\t\tthis.sessions.push(session);\n\t\t}\n\t\tthis._onDidChangeCallStack.fire(undefined);\n\t}\n\n\tget onDidChangeBreakpoints(): Event<IBreakpointsChangeEvent | undefined> {\n\t\treturn this._onDidChangeBreakpoints.event;\n\t}\n\n\tget onDidChangeCallStack(): Event<void> {\n\t\treturn this._onDidChangeCallStack.event;\n\t}\n\n\tget onDidChangeWatchExpressions(): Event<IExpression | undefined> {\n\t\treturn this._onDidChangeWatchExpressions.event;\n\t}\n\n\tget onDidChangeWatchExpressionValue(): Event<IExpression | undefined> {\n\t\treturn this._onDidChangeWatchExpressionValue.event;\n\t}\n\n\trawUpdate(data: IRawModelUpdate): void {\n\t\tconst session = this.sessions.find(p => p.getId() === data.sessionId);\n\t\tif (session) {\n\t\t\tsession.rawUpdate(data);\n\t\t\tthis._onDidChangeCallStack.fire(undefined);\n\t\t}\n\t}\n\n\tclearThreads(id: string, removeThreads: boolean, reference: number | undefined = undefined): void {\n\t\tconst session = this.sessions.find(p => p.getId() === id);\n\t\tthis.schedulers.forEach(entry => {\n\t\t\tentry.scheduler.dispose();\n\t\t\tentry.completeDeferred.complete();\n\t\t});\n\t\tthis.schedulers.clear();\n\n\t\tif (session) {\n\t\t\tsession.clearThreads(removeThreads, reference);\n\t\t\tthis._onDidChangeCallStack.fire(undefined);\n\t\t}\n\t}\n\n\t/**\n\t * Update the call stack and notify the call stack view that changes have occurred.\n\t */\n\tasync fetchCallstack(thread: IThread, levels?: number): Promise<void> {\n\n\t\tif ((<Thread>thread).reachedEndOfCallStack) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst totalFrames = thread.stoppedDetails?.totalFrames;\n\t\tconst remainingFrames = (typeof totalFrames === 'number') ? (totalFrames - thread.getCallStack().length) : undefined;\n\n\t\tif (!levels || (remainingFrames && levels > remainingFrames)) {\n\t\t\tlevels = remainingFrames;\n\t\t}\n\n\t\tif (levels && levels > 0) {\n\t\t\tawait (<Thread>thread).fetchCallStack(levels);\n\t\t\tthis._onDidChangeCallStack.fire();\n\t\t}\n\n\t\treturn;\n\t}\n\n\trefreshTopOfCallstack(thread: Thread, fetchFullStack = true): { topCallStack: Promise<void>; wholeCallStack: Promise<void> } {\n\t\tif (thread.session.capabilities.supportsDelayedStackTraceLoading) {\n\t\t\t// For improved performance load the first stack frame and then load the rest async.\n\t\t\tlet topCallStack = Promise.resolve();\n\t\t\tconst wholeCallStack = new Promise<void>((c, e) => {\n\t\t\t\ttopCallStack = thread.fetchCallStack(1).then(() => {\n\t\t\t\t\tif (!fetchFullStack) {\n\t\t\t\t\t\tc();\n\t\t\t\t\t\tthis._onDidChangeCallStack.fire();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!this.schedulers.has(thread.getId())) {\n\t\t\t\t\t\tconst deferred = new DeferredPromise<void>();\n\t\t\t\t\t\tthis.schedulers.set(thread.getId(), {\n\t\t\t\t\t\t\tcompleteDeferred: deferred,\n\t\t\t\t\t\t\tscheduler: new RunOnceScheduler(() => {\n\t\t\t\t\t\t\t\tthread.fetchCallStack(19).then(() => {\n\t\t\t\t\t\t\t\t\tconst stale = thread.getStaleCallStack();\n\t\t\t\t\t\t\t\t\tconst current = thread.getCallStack();\n\t\t\t\t\t\t\t\t\tlet bottomOfCallStackChanged = stale.length !== current.length;\n\t\t\t\t\t\t\t\t\tfor (let i = 1; i < stale.length && !bottomOfCallStackChanged; i++) {\n\t\t\t\t\t\t\t\t\t\tbottomOfCallStackChanged = !stale[i].equals(current[i]);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (bottomOfCallStackChanged) {\n\t\t\t\t\t\t\t\t\t\tthis._onDidChangeCallStack.fire();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}).finally(() => {\n\t\t\t\t\t\t\t\t\tdeferred.complete();\n\t\t\t\t\t\t\t\t\tthis.schedulers.delete(thread.getId());\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}, 420)\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tconst entry = this.schedulers.get(thread.getId())!;\n\t\t\t\t\tentry.scheduler.schedule();\n\t\t\t\t\tentry.completeDeferred.p.then(c, e);\n\t\t\t\t\tthis._onDidChangeCallStack.fire();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\treturn { topCallStack, wholeCallStack };\n\t\t}\n\n\t\tconst wholeCallStack = thread.fetchCallStack();\n\t\treturn { wholeCallStack, topCallStack: wholeCallStack };\n\t}\n\n\tgetBreakpoints(filter?: { uri?: uri; originalUri?: uri; lineNumber?: number; column?: number; enabledOnly?: boolean; triggeredOnly?: boolean }): IBreakpoint[] {\n\t\tif (filter) {\n\t\t\tconst uriStr = filter.uri?.toString();\n\t\t\tconst originalUriStr = filter.originalUri?.toString();\n\t\t\treturn this.breakpoints.filter(bp => {\n\t\t\t\tif (uriStr && bp.uri.toString() !== uriStr) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (originalUriStr && bp.originalUri.toString() !== originalUriStr) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (filter.lineNumber && bp.lineNumber !== filter.lineNumber) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (filter.column && bp.column !== filter.column) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (filter.enabledOnly && (!this.breakpointsActivated || !bp.enabled)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (filter.triggeredOnly && bp.triggeredBy === undefined) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\n\t\treturn this.breakpoints;\n\t}\n\n\tgetFunctionBreakpoints(): IFunctionBreakpoint[] {\n\t\treturn this.functionBreakpoints;\n\t}\n\n\tgetDataBreakpoints(): IDataBreakpoint[] {\n\t\treturn this.dataBreakpoints;\n\t}\n\n\tgetExceptionBreakpoints(): IExceptionBreakpoint[] {\n\t\treturn this.exceptionBreakpoints;\n\t}\n\n\tgetExceptionBreakpointsForSession(sessionId?: string): IExceptionBreakpoint[] {\n\t\treturn this.exceptionBreakpoints.filter(ebp => ebp.isSupportedSession(sessionId));\n\t}\n\n\tgetInstructionBreakpoints(): IInstructionBreakpoint[] {\n\t\treturn this.instructionBreakpoints;\n\t}\n\n\tsetExceptionBreakpointsForSession(sessionId: string, filters: DebugProtocol.ExceptionBreakpointsFilter[]): void {\n\t\tif (!filters) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet didChangeBreakpoints = false;\n\t\tfilters.forEach((d) => {\n\t\t\tlet ebp = this.exceptionBreakpoints.filter((exbp) => exbp.matches(d)).pop();\n\n\t\t\tif (!ebp) {\n\t\t\t\tdidChangeBreakpoints = true;\n\t\t\t\tebp = new ExceptionBreakpoint({\n\t\t\t\t\tfilter: d.filter,\n\t\t\t\t\tlabel: d.label,\n\t\t\t\t\tenabled: !!d.default,\n\t\t\t\t\tsupportsCondition: !!d.supportsCondition,\n\t\t\t\t\tdescription: d.description,\n\t\t\t\t\tconditionDescription: d.conditionDescription,\n\t\t\t\t});\n\t\t\t\tthis.exceptionBreakpoints.push(ebp);\n\t\t\t}\n\n\t\t\tebp.setSupportedSession(sessionId, true);\n\t\t});\n\n\t\tif (didChangeBreakpoints) {\n\t\t\tthis._onDidChangeBreakpoints.fire(undefined);\n\t\t}\n\t}\n\n\tremoveExceptionBreakpointsForSession(sessionId: string): void {\n\t\tthis.exceptionBreakpoints.forEach(ebp => ebp.setSupportedSession(sessionId, false));\n\t}\n\n\t// Set last focused session as fallback session.\n\t// This is done to keep track of the exception breakpoints to show when no session is active.\n\tsetExceptionBreakpointFallbackSession(sessionId: string): void {\n\t\tthis.exceptionBreakpoints.forEach(ebp => ebp.setFallback(ebp.isSupportedSession(sessionId)));\n\t}\n\n\tsetExceptionBreakpointCondition(exceptionBreakpoint: IExceptionBreakpoint, condition: string | undefined): void {\n\t\t(exceptionBreakpoint as ExceptionBreakpoint).condition = condition;\n\t\tthis._onDidChangeBreakpoints.fire(undefined);\n\t}\n\n\tareBreakpointsActivated(): boolean {\n\t\treturn this.breakpointsActivated;\n\t}\n\n\tsetBreakpointsActivated(activated: boolean): void {\n\t\tthis.breakpointsActivated = activated;\n\t\tthis._onDidChangeBreakpoints.fire(undefined);\n\t}\n\n\taddBreakpoints(uri: uri, rawData: IBreakpointData[], fireEvent = true): IBreakpoint[] {\n\t\tconst newBreakpoints = rawData.map(rawBp => {\n\t\t\treturn new Breakpoint({\n\t\t\t\turi,\n\t\t\t\tlineNumber: rawBp.lineNumber,\n\t\t\t\tcolumn: rawBp.column,\n\t\t\t\tenabled: rawBp.enabled ?? true,\n\t\t\t\tcondition: rawBp.condition,\n\t\t\t\thitCondition: rawBp.hitCondition,\n\t\t\t\tlogMessage: rawBp.logMessage,\n\t\t\t\ttriggeredBy: rawBp.triggeredBy,\n\t\t\t\tadapterData: undefined,\n\t\t\t\tmode: rawBp.mode,\n\t\t\t\tmodeLabel: rawBp.modeLabel,\n\t\t\t}, this.textFileService, this.uriIdentityService, this.logService, rawBp.id);\n\t\t});\n\t\tthis.breakpoints = this.breakpoints.concat(newBreakpoints);\n\t\tthis.breakpointsActivated = true;\n\t\tthis.sortAndDeDup();\n\n\t\tif (fireEvent) {\n\t\t\tthis._onDidChangeBreakpoints.fire({ added: newBreakpoints, sessionOnly: false });\n\t\t}\n\n\t\treturn newBreakpoints;\n\t}\n\n\tremoveBreakpoints(toRemove: IBreakpoint[]): void {\n\t\tthis.breakpoints = this.breakpoints.filter(bp => !toRemove.some(toRemove => toRemove.getId() === bp.getId()));\n\t\tthis._onDidChangeBreakpoints.fire({ removed: toRemove, sessionOnly: false });\n\t}\n\n\tupdateBreakpoints(data: Map<string, IBreakpointUpdateData>): void {\n\t\tconst updated: IBreakpoint[] = [];\n\t\tthis.breakpoints.forEach(bp => {\n\t\t\tconst bpData = data.get(bp.getId());\n\t\t\tif (bpData) {\n\t\t\t\tbp.update(bpData);\n\t\t\t\tupdated.push(bp);\n\t\t\t}\n\t\t});\n\t\tthis.sortAndDeDup();\n\t\tthis._onDidChangeBreakpoints.fire({ changed: updated, sessionOnly: false });\n\t}\n\n\tsetBreakpointSessionData(sessionId: string, capabilites: DebugProtocol.Capabilities, data: Map<string, DebugProtocol.Breakpoint> | undefined): void {\n\t\tthis.breakpoints.forEach(bp => {\n\t\t\tif (!data) {\n\t\t\t\tbp.setSessionData(sessionId, undefined);\n\t\t\t} else {\n\t\t\t\tconst bpData = data.get(bp.getId());\n\t\t\t\tif (bpData) {\n\t\t\t\t\tbp.setSessionData(sessionId, toBreakpointSessionData(bpData, capabilites));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tthis.functionBreakpoints.forEach(fbp => {\n\t\t\tif (!data) {\n\t\t\t\tfbp.setSessionData(sessionId, undefined);\n\t\t\t} else {\n\t\t\t\tconst fbpData = data.get(fbp.getId());\n\t\t\t\tif (fbpData) {\n\t\t\t\t\tfbp.setSessionData(sessionId, toBreakpointSessionData(fbpData, capabilites));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tthis.dataBreakpoints.forEach(dbp => {\n\t\t\tif (!data) {\n\t\t\t\tdbp.setSessionData(sessionId, undefined);\n\t\t\t} else {\n\t\t\t\tconst dbpData = data.get(dbp.getId());\n\t\t\t\tif (dbpData) {\n\t\t\t\t\tdbp.setSessionData(sessionId, toBreakpointSessionData(dbpData, capabilites));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tthis.exceptionBreakpoints.forEach(ebp => {\n\t\t\tif (!data) {\n\t\t\t\tebp.setSessionData(sessionId, undefined);\n\t\t\t} else {\n\t\t\t\tconst ebpData = data.get(ebp.getId());\n\t\t\t\tif (ebpData) {\n\t\t\t\t\tebp.setSessionData(sessionId, toBreakpointSessionData(ebpData, capabilites));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tthis.instructionBreakpoints.forEach(ibp => {\n\t\t\tif (!data) {\n\t\t\t\tibp.setSessionData(sessionId, undefined);\n\t\t\t} else {\n\t\t\t\tconst ibpData = data.get(ibp.getId());\n\t\t\t\tif (ibpData) {\n\t\t\t\t\tibp.setSessionData(sessionId, toBreakpointSessionData(ibpData, capabilites));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tthis._onDidChangeBreakpoints.fire({\n\t\t\tsessionOnly: true\n\t\t});\n\t}\n\n\tgetDebugProtocolBreakpoint(breakpointId: string, sessionId: string): DebugProtocol.Breakpoint | undefined {\n\t\tconst bp = this.breakpoints.find(bp => bp.getId() === breakpointId);\n\t\tif (bp) {\n\t\t\treturn bp.getDebugProtocolBreakpoint(sessionId);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tgetBreakpointModes(forBreakpointType: 'source' | 'exception' | 'data' | 'instruction'): DebugProtocol.BreakpointMode[] {\n\t\treturn [...this._breakpointModes.values()].filter(mode => mode.appliesTo.includes(forBreakpointType));\n\t}\n\n\tregisterBreakpointModes(debugType: string, modes: DebugProtocol.BreakpointMode[]) {\n\t\tfor (const mode of modes) {\n\t\t\tconst key = `${mode.mode}/${mode.label}`;\n\t\t\tconst rec = this._breakpointModes.get(key);\n\t\t\tif (rec) {\n\t\t\t\tfor (const target of mode.appliesTo) {\n\t\t\t\t\tif (!rec.appliesTo.includes(target)) {\n\t\t\t\t\t\trec.appliesTo.push(target);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst duplicate = [...this._breakpointModes.values()].find(r => r !== rec && r.label === mode.label);\n\t\t\t\tif (duplicate) {\n\t\t\t\t\tduplicate.label = `${duplicate.label} (${duplicate.firstFromDebugType})`;\n\t\t\t\t}\n\n\t\t\t\tthis._breakpointModes.set(key, {\n\t\t\t\t\tmode: mode.mode,\n\t\t\t\t\tlabel: duplicate ? `${mode.label} (${debugType})` : mode.label,\n\t\t\t\t\tfirstFromDebugType: debugType,\n\t\t\t\t\tdescription: mode.description,\n\t\t\t\t\tappliesTo: mode.appliesTo.slice(), // avoid later mutations\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate sortAndDeDup(): void {\n\t\tthis.breakpoints = this.breakpoints.sort((first, second) => {\n\t\t\tif (first.uri.toString() !== second.uri.toString()) {\n\t\t\t\treturn resources.basenameOrAuthority(first.uri).localeCompare(resources.basenameOrAuthority(second.uri));\n\t\t\t}\n\t\t\tif (first.lineNumber === second.lineNumber) {\n\t\t\t\tif (first.column && second.column) {\n\t\t\t\t\treturn first.column - second.column;\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\treturn first.lineNumber - second.lineNumber;\n\t\t});\n\t\tthis.breakpoints = distinct(this.breakpoints, bp => `${bp.uri.toString()}:${bp.lineNumber}:${bp.column}`);\n\t}\n\n\tsetEnablement(element: IEnablement, enable: boolean): void {\n\t\tif (element instanceof Breakpoint || element instanceof FunctionBreakpoint || element instanceof ExceptionBreakpoint || element instanceof DataBreakpoint || element instanceof InstructionBreakpoint) {\n\t\t\tconst changed: Array<IBreakpoint | IFunctionBreakpoint | IDataBreakpoint | IInstructionBreakpoint> = [];\n\t\t\tif (element.enabled !== enable && (element instanceof Breakpoint || element instanceof FunctionBreakpoint || element instanceof DataBreakpoint || element instanceof InstructionBreakpoint)) {\n\t\t\t\tchanged.push(element);\n\t\t\t}\n\n\t\t\telement.enabled = enable;\n\t\t\tif (enable) {\n\t\t\t\tthis.breakpointsActivated = true;\n\t\t\t}\n\n\t\t\tthis._onDidChangeBreakpoints.fire({ changed: changed, sessionOnly: false });\n\t\t}\n\t}\n\n\tenableOrDisableAllBreakpoints(enable: boolean): void {\n\t\tconst changed: Array<IBreakpoint | IFunctionBreakpoint | IDataBreakpoint | IInstructionBreakpoint> = [];\n\n\t\tthis.breakpoints.forEach(bp => {\n\t\t\tif (bp.enabled !== enable) {\n\t\t\t\tchanged.push(bp);\n\t\t\t}\n\t\t\tbp.enabled = enable;\n\t\t});\n\t\tthis.functionBreakpoints.forEach(fbp => {\n\t\t\tif (fbp.enabled !== enable) {\n\t\t\t\tchanged.push(fbp);\n\t\t\t}\n\t\t\tfbp.enabled = enable;\n\t\t});\n\t\tthis.dataBreakpoints.forEach(dbp => {\n\t\t\tif (dbp.enabled !== enable) {\n\t\t\t\tchanged.push(dbp);\n\t\t\t}\n\t\t\tdbp.enabled = enable;\n\t\t});\n\t\tthis.instructionBreakpoints.forEach(ibp => {\n\t\t\tif (ibp.enabled !== enable) {\n\t\t\t\tchanged.push(ibp);\n\t\t\t}\n\t\t\tibp.enabled = enable;\n\t\t});\n\n\t\tif (enable) {\n\t\t\tthis.breakpointsActivated = true;\n\t\t}\n\n\t\tthis._onDidChangeBreakpoints.fire({ changed: changed, sessionOnly: false });\n\t}\n\n\taddFunctionBreakpoint(opts: IFunctionBreakpointOptions, id?: string): IFunctionBreakpoint {\n\t\tconst newFunctionBreakpoint = new FunctionBreakpoint(opts, id);\n\t\tthis.functionBreakpoints.push(newFunctionBreakpoint);\n\t\tthis._onDidChangeBreakpoints.fire({ added: [newFunctionBreakpoint], sessionOnly: false });\n\n\t\treturn newFunctionBreakpoint;\n\t}\n\n\tupdateFunctionBreakpoint(id: string, update: { name?: string; hitCondition?: string; condition?: string }): void {\n\t\tconst functionBreakpoint = this.functionBreakpoints.find(fbp => fbp.getId() === id);\n\t\tif (functionBreakpoint) {\n\t\t\tif (typeof update.name === 'string') {\n\t\t\t\tfunctionBreakpoint.name = update.name;\n\t\t\t}\n\t\t\tif (typeof update.condition === 'string') {\n\t\t\t\tfunctionBreakpoint.condition = update.condition;\n\t\t\t}\n\t\t\tif (typeof update.hitCondition === 'string') {\n\t\t\t\tfunctionBreakpoint.hitCondition = update.hitCondition;\n\t\t\t}\n\t\t\tthis._onDidChangeBreakpoints.fire({ changed: [functionBreakpoint], sessionOnly: false });\n\t\t}\n\t}\n\n\tremoveFunctionBreakpoints(id?: string): void {\n\t\tlet removed: FunctionBreakpoint[];\n\t\tif (id) {\n\t\t\tremoved = this.functionBreakpoints.filter(fbp => fbp.getId() === id);\n\t\t\tthis.functionBreakpoints = this.functionBreakpoints.filter(fbp => fbp.getId() !== id);\n\t\t} else {\n\t\t\tremoved = this.functionBreakpoints;\n\t\t\tthis.functionBreakpoints = [];\n\t\t}\n\t\tthis._onDidChangeBreakpoints.fire({ removed, sessionOnly: false });\n\t}\n\n\taddDataBreakpoint(opts: IDataBreakpointOptions, id?: string): void {\n\t\tconst newDataBreakpoint = new DataBreakpoint(opts, id);\n\t\tthis.dataBreakpoints.push(newDataBreakpoint);\n\t\tthis._onDidChangeBreakpoints.fire({ added: [newDataBreakpoint], sessionOnly: false });\n\t}\n\n\tupdateDataBreakpoint(id: string, update: { hitCondition?: string; condition?: string }): void {\n\t\tconst dataBreakpoint = this.dataBreakpoints.find(fbp => fbp.getId() === id);\n\t\tif (dataBreakpoint) {\n\t\t\tif (typeof update.condition === 'string') {\n\t\t\t\tdataBreakpoint.condition = update.condition;\n\t\t\t}\n\t\t\tif (typeof update.hitCondition === 'string') {\n\t\t\t\tdataBreakpoint.hitCondition = update.hitCondition;\n\t\t\t}\n\t\t\tthis._onDidChangeBreakpoints.fire({ changed: [dataBreakpoint], sessionOnly: false });\n\t\t}\n\t}\n\n\tremoveDataBreakpoints(id?: string): void {\n\t\tlet removed: DataBreakpoint[];\n\t\tif (id) {\n\t\t\tremoved = this.dataBreakpoints.filter(fbp => fbp.getId() === id);\n\t\t\tthis.dataBreakpoints = this.dataBreakpoints.filter(fbp => fbp.getId() !== id);\n\t\t} else {\n\t\t\tremoved = this.dataBreakpoints;\n\t\t\tthis.dataBreakpoints = [];\n\t\t}\n\t\tthis._onDidChangeBreakpoints.fire({ removed, sessionOnly: false });\n\t}\n\n\taddInstructionBreakpoint(opts: IInstructionBreakpointOptions): void {\n\t\tconst newInstructionBreakpoint = new InstructionBreakpoint(opts);\n\t\tthis.instructionBreakpoints.push(newInstructionBreakpoint);\n\t\tthis._onDidChangeBreakpoints.fire({ added: [newInstructionBreakpoint], sessionOnly: true });\n\t}\n\n\tremoveInstructionBreakpoints(instructionReference?: string, offset?: number): void {\n\t\tlet removed: InstructionBreakpoint[] = [];\n\t\tif (instructionReference) {\n\t\t\tfor (let i = 0; i < this.instructionBreakpoints.length; i++) {\n\t\t\t\tconst ibp = this.instructionBreakpoints[i];\n\t\t\t\tif (ibp.instructionReference === instructionReference && (offset === undefined || ibp.offset === offset)) {\n\t\t\t\t\tremoved.push(ibp);\n\t\t\t\t\tthis.instructionBreakpoints.splice(i--, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tremoved = this.instructionBreakpoints;\n\t\t\tthis.instructionBreakpoints = [];\n\t\t}\n\t\tthis._onDidChangeBreakpoints.fire({ removed, sessionOnly: false });\n\t}\n\n\tgetWatchExpressions(): Expression[] {\n\t\treturn this.watchExpressions;\n\t}\n\n\taddWatchExpression(name?: string): IExpression {\n\t\tconst we = new Expression(name || '');\n\t\tthis.watchExpressions.push(we);\n\t\tthis._onDidChangeWatchExpressions.fire(we);\n\n\t\treturn we;\n\t}\n\n\trenameWatchExpression(id: string, newName: string): void {\n\t\tconst filtered = this.watchExpressions.filter(we => we.getId() === id);\n\t\tif (filtered.length === 1) {\n\t\t\tfiltered[0].name = newName;\n\t\t\tthis._onDidChangeWatchExpressions.fire(filtered[0]);\n\t\t}\n\t}\n\n\tremoveWatchExpressions(id: string | null = null): void {\n\t\tthis.watchExpressions = id ? this.watchExpressions.filter(we => we.getId() !== id) : [];\n\t\tthis._onDidChangeWatchExpressions.fire(undefined);\n\t}\n\n\tmoveWatchExpression(id: string, position: number): void {\n\t\tconst we = this.watchExpressions.find(we => we.getId() === id);\n\t\tif (we) {\n\t\t\tthis.watchExpressions = this.watchExpressions.filter(we => we.getId() !== id);\n\t\t\tthis.watchExpressions = this.watchExpressions.slice(0, position).concat(we, this.watchExpressions.slice(position));\n\t\t\tthis._onDidChangeWatchExpressions.fire(undefined);\n\t\t}\n\t}\n\n\tsourceIsNotAvailable(uri: uri): void {\n\t\tthis.sessions.forEach(s => {\n\t\t\tconst source = s.getSourceForUri(uri);\n\t\t\tif (source) {\n\t\t\t\tsource.available = false;\n\t\t\t}\n\t\t});\n\t\tthis._onDidChangeCallStack.fire(undefined);\n\t}\n}\n"],
  "mappings": "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",
  "names": ["count", "wholeCallStack", "uri", "toRemove", "bp", "we"]
}
