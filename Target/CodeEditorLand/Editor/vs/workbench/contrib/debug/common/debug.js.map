{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/debug/common/debug.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { IAction } from \"../../../../base/common/actions.js\";\nimport type { VSBuffer } from \"../../../../base/common/buffer.js\";\nimport type { CancellationToken } from \"../../../../base/common/cancellation.js\";\nimport type { Color } from \"../../../../base/common/color.js\";\nimport type { Event } from \"../../../../base/common/event.js\";\nimport type { IJSONSchemaSnippet } from \"../../../../base/common/jsonSchema.js\";\nimport type { IDisposable } from \"../../../../base/common/lifecycle.js\";\nimport type severity from \"../../../../base/common/severity.js\";\nimport {\n\tURI,\n\ttype UriComponents,\n\ttype URI as uri,\n} from \"../../../../base/common/uri.js\";\nimport type {\n\tIPosition,\n\tPosition,\n} from \"../../../../editor/common/core/position.js\";\nimport type { IRange } from \"../../../../editor/common/core/range.js\";\nimport type * as editorCommon from \"../../../../editor/common/editorCommon.js\";\nimport type { ITextModel as EditorIModel } from \"../../../../editor/common/model.js\";\nimport * as nls from \"../../../../nls.js\";\nimport type { ConfigurationTarget } from \"../../../../platform/configuration/common/configuration.js\";\nimport { RawContextKey } from \"../../../../platform/contextkey/common/contextkey.js\";\nimport { createDecorator } from \"../../../../platform/instantiation/common/instantiation.js\";\nimport type { ITelemetryEndpoint } from \"../../../../platform/telemetry/common/telemetry.js\";\nimport type { IWorkspaceFolder } from \"../../../../platform/workspace/common/workspace.js\";\nimport type { IEditorPane } from \"../../../common/editor.js\";\nimport type { IEditorService } from \"../../../services/editor/common/editorService.js\";\nimport type { ITaskIdentifier } from \"../../tasks/common/tasks.js\";\nimport type { LiveTestResult } from \"../../testing/common/testResult.js\";\nimport type { DebugCompoundRoot } from \"./debugCompoundRoot.js\";\nimport type {\n\tIDataBreakpointOptions,\n\tIFunctionBreakpointOptions,\n\tIInstructionBreakpointOptions,\n} from \"./debugModel.js\";\nimport type { Source } from \"./debugSource.js\";\n\nexport const VIEWLET_ID = \"workbench.view.debug\";\n\nexport const VARIABLES_VIEW_ID = \"workbench.debug.variablesView\";\nexport const WATCH_VIEW_ID = \"workbench.debug.watchExpressionsView\";\nexport const CALLSTACK_VIEW_ID = \"workbench.debug.callStackView\";\nexport const LOADED_SCRIPTS_VIEW_ID = \"workbench.debug.loadedScriptsView\";\nexport const BREAKPOINTS_VIEW_ID = \"workbench.debug.breakPointsView\";\nexport const DISASSEMBLY_VIEW_ID = \"workbench.debug.disassemblyView\";\nexport const DEBUG_PANEL_ID = \"workbench.panel.repl\";\nexport const REPL_VIEW_ID = \"workbench.panel.repl.view\";\nexport const CONTEXT_DEBUG_TYPE = new RawContextKey<string>(\n\t\"debugType\",\n\tundefined,\n\t{\n\t\ttype: \"string\",\n\t\tdescription: nls.localize(\n\t\t\t\"debugType\",\n\t\t\t\"Debug type of the active debug session. For example 'python'.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_DEBUG_CONFIGURATION_TYPE = new RawContextKey<string>(\n\t\"debugConfigurationType\",\n\tundefined,\n\t{\n\t\ttype: \"string\",\n\t\tdescription: nls.localize(\n\t\t\t\"debugConfigurationType\",\n\t\t\t\"Debug type of the selected launch configuration. For example 'python'.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_DEBUG_STATE = new RawContextKey<string>(\n\t\"debugState\",\n\t\"inactive\",\n\t{\n\t\ttype: \"string\",\n\t\tdescription: nls.localize(\n\t\t\t\"debugState\",\n\t\t\t\"State that the focused debug session is in. One of the following: 'inactive', 'initializing', 'stopped' or 'running'.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_DEBUG_UX_KEY = \"debugUx\";\nexport const CONTEXT_DEBUG_UX = new RawContextKey<string>(\n\tCONTEXT_DEBUG_UX_KEY,\n\t\"default\",\n\t{\n\t\ttype: \"string\",\n\t\tdescription: nls.localize(\n\t\t\t\"debugUX\",\n\t\t\t\"Debug UX state. When there are no debug configurations it is 'simple', otherwise 'default'. Used to decide when to show welcome views in the debug viewlet.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_HAS_DEBUGGED = new RawContextKey<boolean>(\n\t\"hasDebugged\",\n\tfalse,\n\t{\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"hasDebugged\",\n\t\t\t\"True when a debug session has been started at least once, false otherwise.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_IN_DEBUG_MODE = new RawContextKey<boolean>(\n\t\"inDebugMode\",\n\tfalse,\n\t{\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"inDebugMode\",\n\t\t\t\"True when debugging, false otherwise.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_IN_DEBUG_REPL = new RawContextKey<boolean>(\n\t\"inDebugRepl\",\n\tfalse,\n\t{\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"inDebugRepl\",\n\t\t\t\"True when focus is in the debug console, false otherwise.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_BREAKPOINT_WIDGET_VISIBLE = new RawContextKey<boolean>(\n\t\"breakpointWidgetVisible\",\n\tfalse,\n\t{\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"breakpointWidgetVisibile\",\n\t\t\t\"True when breakpoint editor zone widget is visible, false otherwise.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_IN_BREAKPOINT_WIDGET = new RawContextKey<boolean>(\n\t\"inBreakpointWidget\",\n\tfalse,\n\t{\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"inBreakpointWidget\",\n\t\t\t\"True when focus is in the breakpoint editor zone widget, false otherwise.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_BREAKPOINTS_FOCUSED = new RawContextKey<boolean>(\n\t\"breakpointsFocused\",\n\ttrue,\n\t{\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"breakpointsFocused\",\n\t\t\t\"True when the BREAKPOINTS view is focused, false otherwise.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_WATCH_EXPRESSIONS_FOCUSED = new RawContextKey<boolean>(\n\t\"watchExpressionsFocused\",\n\ttrue,\n\t{\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"watchExpressionsFocused\",\n\t\t\t\"True when the WATCH view is focused, false otherwise.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_WATCH_EXPRESSIONS_EXIST = new RawContextKey<boolean>(\n\t\"watchExpressionsExist\",\n\tfalse,\n\t{\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"watchExpressionsExist\",\n\t\t\t\"True when at least one watch expression exists, false otherwise.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_VARIABLES_FOCUSED = new RawContextKey<boolean>(\n\t\"variablesFocused\",\n\ttrue,\n\t{\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"variablesFocused\",\n\t\t\t\"True when the VARIABLES views is focused, false otherwise\",\n\t\t),\n\t},\n);\nexport const CONTEXT_EXPRESSION_SELECTED = new RawContextKey<boolean>(\n\t\"expressionSelected\",\n\tfalse,\n\t{\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"expressionSelected\",\n\t\t\t\"True when an expression input box is open in either the WATCH or the VARIABLES view, false otherwise.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_BREAKPOINT_INPUT_FOCUSED = new RawContextKey<boolean>(\n\t\"breakpointInputFocused\",\n\tfalse,\n\t{\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"breakpointInputFocused\",\n\t\t\t\"True when the input box has focus in the BREAKPOINTS view.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_CALLSTACK_ITEM_TYPE = new RawContextKey<string>(\n\t\"callStackItemType\",\n\tundefined,\n\t{\n\t\ttype: \"string\",\n\t\tdescription: nls.localize(\n\t\t\t\"callStackItemType\",\n\t\t\t\"Represents the item type of the focused element in the CALL STACK view. For example: 'session', 'thread', 'stackFrame'\",\n\t\t),\n\t},\n);\nexport const CONTEXT_CALLSTACK_SESSION_IS_ATTACH = new RawContextKey<boolean>(\n\t\"callStackSessionIsAttach\",\n\tfalse,\n\t{\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"callStackSessionIsAttach\",\n\t\t\t\"True when the session in the CALL STACK view is attach, false otherwise. Used internally for inline menus in the CALL STACK view.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_CALLSTACK_ITEM_STOPPED = new RawContextKey<boolean>(\n\t\"callStackItemStopped\",\n\tfalse,\n\t{\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"callStackItemStopped\",\n\t\t\t\"True when the focused item in the CALL STACK is stopped. Used internaly for inline menus in the CALL STACK view.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_CALLSTACK_SESSION_HAS_ONE_THREAD =\n\tnew RawContextKey<boolean>(\"callStackSessionHasOneThread\", false, {\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"callStackSessionHasOneThread\",\n\t\t\t\"True when the focused session in the CALL STACK view has exactly one thread. Used internally for inline menus in the CALL STACK view.\",\n\t\t),\n\t});\nexport const CONTEXT_WATCH_ITEM_TYPE = new RawContextKey<string>(\n\t\"watchItemType\",\n\tundefined,\n\t{\n\t\ttype: \"string\",\n\t\tdescription: nls.localize(\n\t\t\t\"watchItemType\",\n\t\t\t\"Represents the item type of the focused element in the WATCH view. For example: 'expression', 'variable'\",\n\t\t),\n\t},\n);\nexport const CONTEXT_CAN_VIEW_MEMORY = new RawContextKey<boolean>(\n\t\"canViewMemory\",\n\tundefined,\n\t{\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"canViewMemory\",\n\t\t\t\"Indicates whether the item in the view has an associated memory refrence.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_BREAKPOINT_ITEM_TYPE = new RawContextKey<string>(\n\t\"breakpointItemType\",\n\tundefined,\n\t{\n\t\ttype: \"string\",\n\t\tdescription: nls.localize(\n\t\t\t\"breakpointItemType\",\n\t\t\t\"Represents the item type of the focused element in the BREAKPOINTS view. For example: 'breakpoint', 'exceptionBreakppint', 'functionBreakpoint', 'dataBreakpoint'\",\n\t\t),\n\t},\n);\nexport const CONTEXT_BREAKPOINT_ITEM_IS_DATA_BYTES = new RawContextKey<boolean>(\n\t\"breakpointItemBytes\",\n\tundefined,\n\t{\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"breakpointItemIsDataBytes\",\n\t\t\t\"Whether the breakpoint item is a data breakpoint on a byte range.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_BREAKPOINT_HAS_MODES = new RawContextKey<boolean>(\n\t\"breakpointHasModes\",\n\tfalse,\n\t{\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"breakpointHasModes\",\n\t\t\t\"Whether the breakpoint has multiple modes it can switch to.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_BREAKPOINT_SUPPORTS_CONDITION = new RawContextKey<boolean>(\n\t\"breakpointSupportsCondition\",\n\tfalse,\n\t{\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"breakpointSupportsCondition\",\n\t\t\t\"True when the focused breakpoint supports conditions.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_LOADED_SCRIPTS_SUPPORTED = new RawContextKey<boolean>(\n\t\"loadedScriptsSupported\",\n\tfalse,\n\t{\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"loadedScriptsSupported\",\n\t\t\t\"True when the focused sessions supports the LOADED SCRIPTS view\",\n\t\t),\n\t},\n);\nexport const CONTEXT_LOADED_SCRIPTS_ITEM_TYPE = new RawContextKey<string>(\n\t\"loadedScriptsItemType\",\n\tundefined,\n\t{\n\t\ttype: \"string\",\n\t\tdescription: nls.localize(\n\t\t\t\"loadedScriptsItemType\",\n\t\t\t\"Represents the item type of the focused element in the LOADED SCRIPTS view.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_FOCUSED_SESSION_IS_ATTACH = new RawContextKey<boolean>(\n\t\"focusedSessionIsAttach\",\n\tfalse,\n\t{\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"focusedSessionIsAttach\",\n\t\t\t\"True when the focused session is 'attach'.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_FOCUSED_SESSION_IS_NO_DEBUG = new RawContextKey<boolean>(\n\t\"focusedSessionIsNoDebug\",\n\tfalse,\n\t{\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"focusedSessionIsNoDebug\",\n\t\t\t\"True when the focused session is run without debugging.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_STEP_BACK_SUPPORTED = new RawContextKey<boolean>(\n\t\"stepBackSupported\",\n\tfalse,\n\t{\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"stepBackSupported\",\n\t\t\t\"True when the focused session supports 'stepBack' requests.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_RESTART_FRAME_SUPPORTED = new RawContextKey<boolean>(\n\t\"restartFrameSupported\",\n\tfalse,\n\t{\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"restartFrameSupported\",\n\t\t\t\"True when the focused session supports 'restartFrame' requests.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_STACK_FRAME_SUPPORTS_RESTART = new RawContextKey<boolean>(\n\t\"stackFrameSupportsRestart\",\n\tfalse,\n\t{\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"stackFrameSupportsRestart\",\n\t\t\t\"True when the focused stack frame supports 'restartFrame'.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_JUMP_TO_CURSOR_SUPPORTED = new RawContextKey<boolean>(\n\t\"jumpToCursorSupported\",\n\tfalse,\n\t{\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"jumpToCursorSupported\",\n\t\t\t\"True when the focused session supports 'jumpToCursor' request.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_STEP_INTO_TARGETS_SUPPORTED = new RawContextKey<boolean>(\n\t\"stepIntoTargetsSupported\",\n\tfalse,\n\t{\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"stepIntoTargetsSupported\",\n\t\t\t\"True when the focused session supports 'stepIntoTargets' request.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_BREAKPOINTS_EXIST = new RawContextKey<boolean>(\n\t\"breakpointsExist\",\n\tfalse,\n\t{\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"breakpointsExist\",\n\t\t\t\"True when at least one breakpoint exists.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_DEBUGGERS_AVAILABLE = new RawContextKey<boolean>(\n\t\"debuggersAvailable\",\n\tfalse,\n\t{\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"debuggersAvailable\",\n\t\t\t\"True when there is at least one debug extensions active.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_DEBUG_EXTENSION_AVAILABLE = new RawContextKey<boolean>(\n\t\"debugExtensionAvailable\",\n\ttrue,\n\t{\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"debugExtensionsAvailable\",\n\t\t\t\"True when there is at least one debug extension installed and enabled.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_DEBUG_PROTOCOL_VARIABLE_MENU_CONTEXT =\n\tnew RawContextKey<string>(\"debugProtocolVariableMenuContext\", undefined, {\n\t\ttype: \"string\",\n\t\tdescription: nls.localize(\n\t\t\t\"debugProtocolVariableMenuContext\",\n\t\t\t\"Represents the context the debug adapter sets on the focused variable in the VARIABLES view.\",\n\t\t),\n\t});\nexport const CONTEXT_SET_VARIABLE_SUPPORTED = new RawContextKey<boolean>(\n\t\"debugSetVariableSupported\",\n\tfalse,\n\t{\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"debugSetVariableSupported\",\n\t\t\t\"True when the focused session supports 'setVariable' request.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_SET_DATA_BREAKPOINT_BYTES_SUPPORTED =\n\tnew RawContextKey<boolean>(\n\t\t\"debugSetDataBreakpointAddressSupported\",\n\t\tfalse,\n\t\t{\n\t\t\ttype: \"boolean\",\n\t\t\tdescription: nls.localize(\n\t\t\t\t\"debugSetDataBreakpointAddressSupported\",\n\t\t\t\t\"True when the focused session supports 'getBreakpointInfo' request on an address.\",\n\t\t\t),\n\t\t},\n\t);\nexport const CONTEXT_SET_EXPRESSION_SUPPORTED = new RawContextKey<boolean>(\n\t\"debugSetExpressionSupported\",\n\tfalse,\n\t{\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"debugSetExpressionSupported\",\n\t\t\t\"True when the focused session supports 'setExpression' request.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_BREAK_WHEN_VALUE_CHANGES_SUPPORTED =\n\tnew RawContextKey<boolean>(\"breakWhenValueChangesSupported\", false, {\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"breakWhenValueChangesSupported\",\n\t\t\t\"True when the focused session supports to break when value changes.\",\n\t\t),\n\t});\nexport const CONTEXT_BREAK_WHEN_VALUE_IS_ACCESSED_SUPPORTED =\n\tnew RawContextKey<boolean>(\"breakWhenValueIsAccessedSupported\", false, {\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"breakWhenValueIsAccessedSupported\",\n\t\t\t\"True when the focused breakpoint supports to break when value is accessed.\",\n\t\t),\n\t});\nexport const CONTEXT_BREAK_WHEN_VALUE_IS_READ_SUPPORTED =\n\tnew RawContextKey<boolean>(\"breakWhenValueIsReadSupported\", false, {\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"breakWhenValueIsReadSupported\",\n\t\t\t\"True when the focused breakpoint supports to break when value is read.\",\n\t\t),\n\t});\nexport const CONTEXT_TERMINATE_DEBUGGEE_SUPPORTED = new RawContextKey<boolean>(\n\t\"terminateDebuggeeSupported\",\n\tfalse,\n\t{\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"terminateDebuggeeSupported\",\n\t\t\t\"True when the focused session supports the terminate debuggee capability.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_SUSPEND_DEBUGGEE_SUPPORTED = new RawContextKey<boolean>(\n\t\"suspendDebuggeeSupported\",\n\tfalse,\n\t{\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"suspendDebuggeeSupported\",\n\t\t\t\"True when the focused session supports the suspend debuggee capability.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_VARIABLE_EVALUATE_NAME_PRESENT =\n\tnew RawContextKey<boolean>(\"variableEvaluateNamePresent\", false, {\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"variableEvaluateNamePresent\",\n\t\t\t\"True when the focused variable has an 'evalauteName' field set.\",\n\t\t),\n\t});\nexport const CONTEXT_VARIABLE_IS_READONLY = new RawContextKey<boolean>(\n\t\"variableIsReadonly\",\n\tfalse,\n\t{\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"variableIsReadonly\",\n\t\t\t\"True when the focused variable is read-only.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_VARIABLE_VALUE = new RawContextKey<boolean>(\n\t\"variableValue\",\n\tfalse,\n\t{\n\t\ttype: \"string\",\n\t\tdescription: nls.localize(\n\t\t\t\"variableValue\",\n\t\t\t\"Value of the variable, present for debug visualization clauses.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_VARIABLE_TYPE = new RawContextKey<boolean>(\n\t\"variableType\",\n\tfalse,\n\t{\n\t\ttype: \"string\",\n\t\tdescription: nls.localize(\n\t\t\t\"variableType\",\n\t\t\t\"Type of the variable, present for debug visualization clauses.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_VARIABLE_INTERFACES = new RawContextKey<boolean>(\n\t\"variableInterfaces\",\n\tfalse,\n\t{\n\t\ttype: \"array\",\n\t\tdescription: nls.localize(\n\t\t\t\"variableInterfaces\",\n\t\t\t\"Any interfaces or contracts that the variable satisfies, present for debug visualization clauses.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_VARIABLE_NAME = new RawContextKey<boolean>(\n\t\"variableName\",\n\tfalse,\n\t{\n\t\ttype: \"string\",\n\t\tdescription: nls.localize(\n\t\t\t\"variableName\",\n\t\t\t\"Name of the variable, present for debug visualization clauses.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_VARIABLE_LANGUAGE = new RawContextKey<boolean>(\n\t\"variableLanguage\",\n\tfalse,\n\t{\n\t\ttype: \"string\",\n\t\tdescription: nls.localize(\n\t\t\t\"variableLanguage\",\n\t\t\t\"Language of the variable source, present for debug visualization clauses.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_VARIABLE_EXTENSIONID = new RawContextKey<boolean>(\n\t\"variableExtensionId\",\n\tfalse,\n\t{\n\t\ttype: \"string\",\n\t\tdescription: nls.localize(\n\t\t\t\"variableExtensionId\",\n\t\t\t\"Extension ID of the variable source, present for debug visualization clauses.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_EXCEPTION_WIDGET_VISIBLE = new RawContextKey<boolean>(\n\t\"exceptionWidgetVisible\",\n\tfalse,\n\t{\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"exceptionWidgetVisible\",\n\t\t\t\"True when the exception widget is visible.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_MULTI_SESSION_REPL = new RawContextKey<boolean>(\n\t\"multiSessionRepl\",\n\tfalse,\n\t{\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"multiSessionRepl\",\n\t\t\t\"True when there is more than 1 debug console.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_MULTI_SESSION_DEBUG = new RawContextKey<boolean>(\n\t\"multiSessionDebug\",\n\tfalse,\n\t{\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"multiSessionDebug\",\n\t\t\t\"True when there is more than 1 active debug session.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_DISASSEMBLE_REQUEST_SUPPORTED = new RawContextKey<boolean>(\n\t\"disassembleRequestSupported\",\n\tfalse,\n\t{\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"disassembleRequestSupported\",\n\t\t\t\"True when the focused sessions supports disassemble request.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_DISASSEMBLY_VIEW_FOCUS = new RawContextKey<boolean>(\n\t\"disassemblyViewFocus\",\n\tfalse,\n\t{\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"disassemblyViewFocus\",\n\t\t\t\"True when the Disassembly View is focused.\",\n\t\t),\n\t},\n);\nexport const CONTEXT_LANGUAGE_SUPPORTS_DISASSEMBLE_REQUEST =\n\tnew RawContextKey<boolean>(\"languageSupportsDisassembleRequest\", false, {\n\t\ttype: \"boolean\",\n\t\tdescription: nls.localize(\n\t\t\t\"languageSupportsDisassembleRequest\",\n\t\t\t\"True when the language in the current editor supports disassemble request.\",\n\t\t),\n\t});\nexport const CONTEXT_FOCUSED_STACK_FRAME_HAS_INSTRUCTION_POINTER_REFERENCE =\n\tnew RawContextKey<boolean>(\n\t\t\"focusedStackFrameHasInstructionReference\",\n\t\tfalse,\n\t\t{\n\t\t\ttype: \"boolean\",\n\t\t\tdescription: nls.localize(\n\t\t\t\t\"focusedStackFrameHasInstructionReference\",\n\t\t\t\t\"True when the focused stack frame has instruction pointer reference.\",\n\t\t\t),\n\t\t},\n\t);\n\nexport const debuggerDisabledMessage = (debugType: string) =>\n\tnls.localize(\n\t\t\"debuggerDisabled\",\n\t\t\"Configured debug type '{0}' is installed but not supported in this environment.\",\n\t\tdebugType,\n\t);\n\nexport const EDITOR_CONTRIBUTION_ID = \"editor.contrib.debug\";\nexport const BREAKPOINT_EDITOR_CONTRIBUTION_ID = \"editor.contrib.breakpoint\";\nexport const DEBUG_SCHEME = \"debug\";\nexport const INTERNAL_CONSOLE_OPTIONS_SCHEMA = {\n\tenum: [\"neverOpen\", \"openOnSessionStart\", \"openOnFirstSessionStart\"],\n\tdefault: \"openOnFirstSessionStart\",\n\tdescription: nls.localize(\n\t\t\"internalConsoleOptions\",\n\t\t\"Controls when the internal Debug Console should open.\",\n\t),\n};\n\n// raw\n\nexport interface IRawModelUpdate {\n\tsessionId: string;\n\tthreads: DebugProtocol.Thread[];\n\tstoppedDetails?: IRawStoppedDetails;\n}\n\nexport interface IRawStoppedDetails {\n\treason?: string;\n\tdescription?: string;\n\tthreadId?: number;\n\ttext?: string;\n\ttotalFrames?: number;\n\tallThreadsStopped?: boolean;\n\tpreserveFocusHint?: boolean;\n\tframesErrorMessage?: string;\n\thitBreakpointIds?: number[];\n}\n\n// model\n\nexport interface ITreeElement {\n\tgetId(): string;\n}\n\nexport interface IReplElement extends ITreeElement {\n\ttoString(includeSource?: boolean): string;\n\treadonly sourceData?: IReplElementSource;\n}\n\nexport interface INestingReplElement extends IReplElement {\n\treadonly hasChildren: boolean;\n\tgetChildren(): Promise<IReplElement[]> | IReplElement[];\n}\n\nexport interface IReplElementSource {\n\treadonly source: Source;\n\treadonly lineNumber: number;\n\treadonly column: number;\n}\n\nexport interface IExpressionValue {\n\treadonly value: string;\n\treadonly type?: string;\n\tvalueChanged?: boolean;\n}\n\nexport interface IExpressionContainer extends ITreeElement, IExpressionValue {\n\treadonly hasChildren: boolean;\n\tgetSession(): IDebugSession | undefined;\n\tevaluateLazy(): Promise<void>;\n\tgetChildren(): Promise<IExpression[]>;\n\treadonly reference?: number;\n\treadonly memoryReference?: string;\n\treadonly presentationHint?:\n\t\t| DebugProtocol.VariablePresentationHint\n\t\t| undefined;\n\treadonly valueLocationReference?: number;\n}\n\nexport interface IExpression extends IExpressionContainer {\n\tname: string;\n}\n\nexport interface IDebugger {\n\treadonly type: string;\n\tcreateDebugAdapter(session: IDebugSession): Promise<IDebugAdapter>;\n\trunInTerminal(\n\t\targs: DebugProtocol.RunInTerminalRequestArguments,\n\t\tsessionId: string,\n\t): Promise<number | undefined>;\n\tstartDebugging(args: IConfig, parentSessionId: string): Promise<boolean>;\n\tgetCustomTelemetryEndpoint(): ITelemetryEndpoint | undefined;\n\tgetInitialConfigurationContent(initialConfigs?: IConfig[]): Promise<string>;\n}\n\nexport interface IDebuggerMetadata {\n\tlabel: string;\n\ttype: string;\n\tstrings?: { [key in DebuggerString]: string };\n\tinterestedInLanguage(languageId: string): boolean;\n}\n\nexport enum State {\n\tInactive = 0,\n\tInitializing = 1,\n\tStopped = 2,\n\tRunning = 3,\n}\n\nexport function getStateLabel(state: State): string {\n\tswitch (state) {\n\t\tcase State.Initializing:\n\t\t\treturn \"initializing\";\n\t\tcase State.Stopped:\n\t\t\treturn \"stopped\";\n\t\tcase State.Running:\n\t\t\treturn \"running\";\n\t\tdefault:\n\t\t\treturn \"inactive\";\n\t}\n}\n\nexport interface AdapterEndEvent {\n\terror?: Error;\n\tsessionLengthInSeconds: number;\n\temittedStopped: boolean;\n}\n\nexport interface LoadedSourceEvent {\n\treason: \"new\" | \"changed\" | \"removed\";\n\tsource: Source;\n}\n\nexport type IDebugSessionReplMode = \"separate\" | \"mergeWithParent\";\n\nexport interface IDebugTestRunReference {\n\trunId: string;\n\ttaskId: string;\n}\n\nexport interface IDebugSessionOptions {\n\tnoDebug?: boolean;\n\tparentSession?: IDebugSession;\n\tlifecycleManagedByParent?: boolean;\n\trepl?: IDebugSessionReplMode;\n\tcompoundRoot?: DebugCompoundRoot;\n\tcompact?: boolean;\n\tstartedByUser?: boolean;\n\tsaveBeforeRestart?: boolean;\n\tsuppressDebugToolbar?: boolean;\n\tsuppressDebugStatusbar?: boolean;\n\tsuppressDebugView?: boolean;\n\t/**\n\t * Set if the debug session is correlated with a test run. Stopping/restarting\n\t * the session will instead stop/restart the test run.\n\t */\n\ttestRun?: IDebugTestRunReference;\n}\n\nexport interface IDataBreakpointInfoResponse {\n\tdataId: string | null;\n\tdescription: string;\n\tcanPersist?: boolean;\n\taccessTypes?: DebugProtocol.DataBreakpointAccessType[];\n}\n\nexport interface IMemoryInvalidationEvent {\n\tfromOffset: number;\n\ttoOffset: number;\n}\n\nexport enum MemoryRangeType {\n\tValid = 0,\n\tUnreadable = 1,\n\tError = 2,\n}\n\nexport interface IMemoryRange {\n\ttype: MemoryRangeType;\n\toffset: number;\n\tlength: number;\n}\n\nexport interface IValidMemoryRange extends IMemoryRange {\n\ttype: MemoryRangeType.Valid;\n\toffset: number;\n\tlength: number;\n\tdata: VSBuffer;\n}\n\nexport interface IUnreadableMemoryRange extends IMemoryRange {\n\ttype: MemoryRangeType.Unreadable;\n}\n\nexport interface IErrorMemoryRange extends IMemoryRange {\n\ttype: MemoryRangeType.Error;\n\terror: string;\n}\n\n/**\n * Union type of memory that can be returned from read(). Since a read request\n * could encompass multiple previously-read ranges, multiple of these types\n * are possible to return.\n */\nexport type MemoryRange =\n\t| IValidMemoryRange\n\t| IUnreadableMemoryRange\n\t| IErrorMemoryRange;\n\nexport const DEBUG_MEMORY_SCHEME = \"vscode-debug-memory\";\n\n/**\n * An IMemoryRegion corresponds to a contiguous range of memory referred to\n * by a DAP `memoryReference`.\n */\nexport interface IMemoryRegion extends IDisposable {\n\t/**\n\t * Event that fires when memory changes. Can be a result of memory events or\n\t * `write` requests.\n\t */\n\treadonly onDidInvalidate: Event<IMemoryInvalidationEvent>;\n\n\t/**\n\t * Whether writes are supported on this memory region.\n\t */\n\treadonly writable: boolean;\n\n\t/**\n\t * Requests memory ranges from the debug adapter. It returns a list of memory\n\t * ranges that overlap (but may exceed!) the given offset. Use the `offset`\n\t * and `length` of each range for display.\n\t */\n\tread(fromOffset: number, toOffset: number): Promise<MemoryRange[]>;\n\n\t/**\n\t * Writes memory to the debug adapter at the given offset.\n\t */\n\twrite(offset: number, data: VSBuffer): Promise<number>;\n}\n\n/** Data that can be inserted in {@link IDebugSession.appendToRepl} */\nexport interface INewReplElementData {\n\t/**\n\t * Output string to display\n\t */\n\toutput: string;\n\n\t/**\n\t * Expression data to display. Will result in the item being expandable in\n\t * the REPL. Its value will be used if {@link output} is not provided.\n\t */\n\texpression?: IExpression;\n\n\t/**\n\t * Output severity.\n\t */\n\tsev: severity;\n\n\t/**\n\t * Originating location.\n\t */\n\tsource?: IReplElementSource;\n}\n\nexport interface IDebugEvaluatePosition {\n\tline: number;\n\tcolumn: number;\n\tsource: DebugProtocol.Source;\n}\n\nexport interface IDebugLocationReferenced {\n\tline: number;\n\tcolumn: number;\n\tendLine?: number;\n\tendColumn?: number;\n\tsource: Source;\n}\n\nexport interface IDebugSession extends ITreeElement {\n\treadonly configuration: IConfig;\n\treadonly unresolvedConfiguration: IConfig | undefined;\n\treadonly state: State;\n\treadonly root: IWorkspaceFolder | undefined;\n\treadonly parentSession: IDebugSession | undefined;\n\treadonly subId: string | undefined;\n\treadonly compact: boolean;\n\treadonly compoundRoot: DebugCompoundRoot | undefined;\n\treadonly saveBeforeRestart: boolean;\n\treadonly name: string;\n\treadonly autoExpandLazyVariables: boolean;\n\treadonly suppressDebugToolbar: boolean;\n\treadonly suppressDebugStatusbar: boolean;\n\treadonly suppressDebugView: boolean;\n\treadonly lifecycleManagedByParent: boolean;\n\t/** Test run this debug session was spawned by */\n\treadonly correlatedTestRun?: LiveTestResult;\n\n\tsetSubId(subId: string | undefined): void;\n\n\tgetMemory(memoryReference: string): IMemoryRegion;\n\n\tsetName(name: string): void;\n\treadonly onDidChangeName: Event<string>;\n\tgetLabel(): string;\n\n\tgetSourceForUri(modelUri: uri): Source | undefined;\n\tgetSource(raw?: DebugProtocol.Source): Source;\n\n\tsetConfiguration(configuration: {\n\t\tresolved: IConfig;\n\t\tunresolved: IConfig | undefined;\n\t}): void;\n\trawUpdate(data: IRawModelUpdate): void;\n\n\tgetThread(threadId: number): IThread | undefined;\n\tgetAllThreads(): IThread[];\n\tclearThreads(removeThreads: boolean, reference?: number): void;\n\tgetStoppedDetails(): IRawStoppedDetails | undefined;\n\n\tgetReplElements(): IReplElement[];\n\thasSeparateRepl(): boolean;\n\tremoveReplExpressions(): void;\n\taddReplExpression(\n\t\tstackFrame: IStackFrame | undefined,\n\t\tname: string,\n\t): Promise<void>;\n\tappendToRepl(data: INewReplElementData): void;\n\n\t// session events\n\treadonly onDidEndAdapter: Event<AdapterEndEvent | undefined>;\n\treadonly onDidChangeState: Event<void>;\n\treadonly onDidChangeReplElements: Event<IReplElement | undefined>;\n\n\t// DA capabilities\n\treadonly capabilities: DebugProtocol.Capabilities;\n\n\t// DAP events\n\n\treadonly onDidLoadedSource: Event<LoadedSourceEvent>;\n\treadonly onDidCustomEvent: Event<DebugProtocol.Event>;\n\treadonly onDidProgressStart: Event<DebugProtocol.ProgressStartEvent>;\n\treadonly onDidProgressUpdate: Event<DebugProtocol.ProgressUpdateEvent>;\n\treadonly onDidProgressEnd: Event<DebugProtocol.ProgressEndEvent>;\n\treadonly onDidInvalidateMemory: Event<DebugProtocol.MemoryEvent>;\n\n\t// DAP request\n\n\tinitialize(dbgr: IDebugger): Promise<void>;\n\tlaunchOrAttach(config: IConfig): Promise<void>;\n\trestart(): Promise<void>;\n\tterminate(restart?: boolean /* false */): Promise<void>;\n\tdisconnect(restart?: boolean /* false */, suspend?: boolean): Promise<void>;\n\n\tsendBreakpoints(\n\t\tmodelUri: uri,\n\t\tbpts: IBreakpoint[],\n\t\tsourceModified: boolean,\n\t): Promise<void>;\n\tsendFunctionBreakpoints(fbps: IFunctionBreakpoint[]): Promise<void>;\n\tdataBreakpointInfo(\n\t\tname: string,\n\t\tvariablesReference?: number,\n\t): Promise<IDataBreakpointInfoResponse | undefined>;\n\tdataBytesBreakpointInfo(\n\t\taddress: string,\n\t\tbytes: number,\n\t): Promise<IDataBreakpointInfoResponse | undefined>;\n\tsendDataBreakpoints(dbps: IDataBreakpoint[]): Promise<void>;\n\tsendInstructionBreakpoints(dbps: IInstructionBreakpoint[]): Promise<void>;\n\tsendExceptionBreakpoints(exbpts: IExceptionBreakpoint[]): Promise<void>;\n\tbreakpointsLocations(uri: uri, lineNumber: number): Promise<IPosition[]>;\n\tgetDebugProtocolBreakpoint(\n\t\tbreakpointId: string,\n\t): DebugProtocol.Breakpoint | undefined;\n\tresolveLocationReference(\n\t\tlocationReference: number,\n\t): Promise<IDebugLocationReferenced>;\n\n\tstackTrace(\n\t\tthreadId: number,\n\t\tstartFrame: number,\n\t\tlevels: number,\n\t\ttoken: CancellationToken,\n\t): Promise<DebugProtocol.StackTraceResponse | undefined>;\n\texceptionInfo(threadId: number): Promise<IExceptionInfo | undefined>;\n\tscopes(\n\t\tframeId: number,\n\t\tthreadId: number,\n\t): Promise<DebugProtocol.ScopesResponse | undefined>;\n\tvariables(\n\t\tvariablesReference: number,\n\t\tthreadId: number | undefined,\n\t\tfilter: \"indexed\" | \"named\" | undefined,\n\t\tstart: number | undefined,\n\t\tcount: number | undefined,\n\t): Promise<DebugProtocol.VariablesResponse | undefined>;\n\tevaluate(\n\t\texpression: string,\n\t\tframeId?: number,\n\t\tcontext?: string,\n\t\tlocation?: IDebugEvaluatePosition,\n\t): Promise<DebugProtocol.EvaluateResponse | undefined>;\n\tcustomRequest(\n\t\trequest: string,\n\t\targs: any,\n\t): Promise<DebugProtocol.Response | undefined>;\n\tcancel(\n\t\tprogressId: string,\n\t): Promise<DebugProtocol.CancelResponse | undefined>;\n\tdisassemble(\n\t\tmemoryReference: string,\n\t\toffset: number,\n\t\tinstructionOffset: number,\n\t\tinstructionCount: number,\n\t): Promise<DebugProtocol.DisassembledInstruction[] | undefined>;\n\treadMemory(\n\t\tmemoryReference: string,\n\t\toffset: number,\n\t\tcount: number,\n\t): Promise<DebugProtocol.ReadMemoryResponse | undefined>;\n\twriteMemory(\n\t\tmemoryReference: string,\n\t\toffset: number,\n\t\tdata: string,\n\t\tallowPartial?: boolean,\n\t): Promise<DebugProtocol.WriteMemoryResponse | undefined>;\n\n\trestartFrame(frameId: number, threadId: number): Promise<void>;\n\tnext(\n\t\tthreadId: number,\n\t\tgranularity?: DebugProtocol.SteppingGranularity,\n\t): Promise<void>;\n\tstepIn(\n\t\tthreadId: number,\n\t\ttargetId?: number,\n\t\tgranularity?: DebugProtocol.SteppingGranularity,\n\t): Promise<void>;\n\tstepInTargets(\n\t\tframeId: number,\n\t): Promise<DebugProtocol.StepInTarget[] | undefined>;\n\tstepOut(\n\t\tthreadId: number,\n\t\tgranularity?: DebugProtocol.SteppingGranularity,\n\t): Promise<void>;\n\tstepBack(\n\t\tthreadId: number,\n\t\tgranularity?: DebugProtocol.SteppingGranularity,\n\t): Promise<void>;\n\tcontinue(threadId: number): Promise<void>;\n\treverseContinue(threadId: number): Promise<void>;\n\tpause(threadId: number): Promise<void>;\n\tterminateThreads(threadIds: number[]): Promise<void>;\n\n\tcompletions(\n\t\tframeId: number | undefined,\n\t\tthreadId: number,\n\t\ttext: string,\n\t\tposition: Position,\n\t\toverwriteBefore: number,\n\t\ttoken: CancellationToken,\n\t): Promise<DebugProtocol.CompletionsResponse | undefined>;\n\tsetVariable(\n\t\tvariablesReference: number | undefined,\n\t\tname: string,\n\t\tvalue: string,\n\t): Promise<DebugProtocol.SetVariableResponse | undefined>;\n\tsetExpression(\n\t\tframeId: number,\n\t\texpression: string,\n\t\tvalue: string,\n\t): Promise<DebugProtocol.SetExpressionResponse | undefined>;\n\tloadSource(\n\t\tresource: uri,\n\t): Promise<DebugProtocol.SourceResponse | undefined>;\n\tgetLoadedSources(): Promise<Source[]>;\n\n\tgotoTargets(\n\t\tsource: DebugProtocol.Source,\n\t\tline: number,\n\t\tcolumn?: number,\n\t): Promise<DebugProtocol.GotoTargetsResponse | undefined>;\n\tgoto(\n\t\tthreadId: number,\n\t\ttargetId: number,\n\t): Promise<DebugProtocol.GotoResponse | undefined>;\n}\n\nexport interface IThread extends ITreeElement {\n\t/**\n\t * Process the thread belongs to\n\t */\n\treadonly session: IDebugSession;\n\n\t/**\n\t * Id of the thread generated by the debug adapter backend.\n\t */\n\treadonly threadId: number;\n\n\t/**\n\t * Name of the thread.\n\t */\n\treadonly name: string;\n\n\t/**\n\t * Information about the current thread stop event. Undefined if thread is not stopped.\n\t */\n\treadonly stoppedDetails: IRawStoppedDetails | undefined;\n\n\t/**\n\t * Information about the exception if an 'exception' stopped event raised and DA supports the 'exceptionInfo' request, otherwise undefined.\n\t */\n\treadonly exceptionInfo: Promise<IExceptionInfo | undefined>;\n\n\treadonly stateLabel: string;\n\n\t/**\n\t * Gets the callstack if it has already been received from the debug\n\t * adapter.\n\t */\n\tgetCallStack(): ReadonlyArray<IStackFrame>;\n\n\t/**\n\t * Gets the top stack frame that is not hidden if the callstack has already been received from the debug adapter\n\t */\n\tgetTopStackFrame(): IStackFrame | undefined;\n\n\t/**\n\t * Invalidates the callstack cache\n\t */\n\tclearCallStack(): void;\n\n\t/**\n\t * Indicates whether this thread is stopped. The callstack for stopped\n\t * threads can be retrieved from the debug adapter.\n\t */\n\treadonly stopped: boolean;\n\n\tnext(granularity?: DebugProtocol.SteppingGranularity): Promise<any>;\n\tstepIn(granularity?: DebugProtocol.SteppingGranularity): Promise<any>;\n\tstepOut(granularity?: DebugProtocol.SteppingGranularity): Promise<any>;\n\tstepBack(granularity?: DebugProtocol.SteppingGranularity): Promise<any>;\n\tcontinue(): Promise<any>;\n\tpause(): Promise<any>;\n\tterminate(): Promise<any>;\n\treverseContinue(): Promise<any>;\n}\n\nexport interface IScope extends IExpressionContainer {\n\treadonly name: string;\n\treadonly expensive: boolean;\n\treadonly range?: IRange;\n\treadonly hasChildren: boolean;\n}\n\nexport interface IStackFrame extends ITreeElement {\n\treadonly thread: IThread;\n\treadonly name: string;\n\treadonly presentationHint: string | undefined;\n\treadonly frameId: number;\n\treadonly range: IRange;\n\treadonly source: Source;\n\treadonly canRestart: boolean;\n\treadonly instructionPointerReference?: string;\n\tgetScopes(): Promise<IScope[]>;\n\tgetMostSpecificScopes(range: IRange): Promise<ReadonlyArray<IScope>>;\n\tforgetScopes(): void;\n\trestart(): Promise<any>;\n\ttoString(): string;\n\topenInEditor(\n\t\teditorService: IEditorService,\n\t\tpreserveFocus?: boolean,\n\t\tsideBySide?: boolean,\n\t\tpinned?: boolean,\n\t): Promise<IEditorPane | undefined>;\n\tequals(other: IStackFrame): boolean;\n}\n\nexport function isFrameDeemphasized(frame: IStackFrame): boolean {\n\tconst hint = frame.presentationHint ?? frame.source.presentationHint;\n\treturn hint === \"deemphasize\" || hint === \"subtle\";\n}\n\nexport interface IEnablement extends ITreeElement {\n\treadonly enabled: boolean;\n}\n\nexport interface IBreakpointData {\n\treadonly id?: string;\n\treadonly lineNumber: number;\n\treadonly column?: number;\n\treadonly enabled?: boolean;\n\treadonly condition?: string;\n\treadonly logMessage?: string;\n\treadonly hitCondition?: string;\n\treadonly triggeredBy?: string;\n\treadonly mode?: string;\n\treadonly modeLabel?: string;\n}\n\nexport interface IBreakpointUpdateData {\n\treadonly condition?: string;\n\treadonly hitCondition?: string;\n\treadonly logMessage?: string;\n\treadonly lineNumber?: number;\n\treadonly column?: number;\n\treadonly triggeredBy?: string;\n\treadonly mode?: string;\n\treadonly modeLabel?: string;\n}\n\nexport interface IBaseBreakpoint extends IEnablement {\n\treadonly condition?: string;\n\treadonly hitCondition?: string;\n\treadonly logMessage?: string;\n\treadonly verified: boolean;\n\treadonly supported: boolean;\n\treadonly message?: string;\n\t/** The preferred mode of the breakpoint from {@link DebugProtocol.BreakpointMode} */\n\treadonly mode?: string;\n\t/** The preferred mode label of the breakpoint from {@link DebugProtocol.BreakpointMode} */\n\treadonly modeLabel?: string;\n\treadonly sessionsThatVerified: string[];\n\tgetIdFromAdapter(sessionId: string): number | undefined;\n}\n\nexport interface IBreakpoint extends IBaseBreakpoint {\n\t/** URI where the breakpoint was first set by the user. */\n\treadonly originalUri: uri;\n\t/** URI where the breakpoint is currently shown; may be moved by debugger */\n\treadonly uri: uri;\n\treadonly lineNumber: number;\n\treadonly endLineNumber?: number;\n\treadonly column?: number;\n\treadonly endColumn?: number;\n\treadonly adapterData: any;\n\treadonly sessionAgnosticData: {\n\t\tlineNumber: number;\n\t\tcolumn: number | undefined;\n\t};\n\t/** An ID of the breakpoint that triggers this breakpoint. */\n\treadonly triggeredBy?: string;\n\t/** Pending on the trigger breakpoint, which means this breakpoint is not yet sent to DA */\n\treadonly pending: boolean;\n\n\t/** Marks that a session did trigger the breakpoint. */\n\tsetSessionDidTrigger(sessionId: string): void;\n\t/** Gets whether the `triggeredBy` condition has been met in the given sesison ID. */\n\tgetSessionDidTrigger(sessionId: string): boolean;\n\n\ttoDAP(): DebugProtocol.SourceBreakpoint;\n}\n\nexport interface IFunctionBreakpoint extends IBaseBreakpoint {\n\treadonly name: string;\n\ttoDAP(): DebugProtocol.FunctionBreakpoint;\n}\n\nexport interface IExceptionBreakpoint extends IBaseBreakpoint {\n\treadonly filter: string;\n\treadonly label: string;\n\treadonly description: string | undefined;\n}\n\nexport enum DataBreakpointSetType {\n\tVariable = 0,\n\tAddress = 1,\n}\n\n/**\n * Source for a data breakpoint. A data breakpoint on a variable always has a\n * `dataId` because it cannot reference that variable globally, but addresses\n * can request info repeated and use session-specific data.\n */\nexport type DataBreakpointSource =\n\t| { type: DataBreakpointSetType.Variable; dataId: string }\n\t| { type: DataBreakpointSetType.Address; address: string; bytes: number };\n\nexport interface IDataBreakpoint extends IBaseBreakpoint {\n\treadonly description: string;\n\treadonly canPersist: boolean;\n\treadonly src: DataBreakpointSource;\n\treadonly accessType: DebugProtocol.DataBreakpointAccessType;\n\ttoDAP(\n\t\tsession: IDebugSession,\n\t): Promise<DebugProtocol.DataBreakpoint | undefined>;\n}\n\nexport interface IInstructionBreakpoint extends IBaseBreakpoint {\n\treadonly instructionReference: string;\n\treadonly offset?: number;\n\t/** Original instruction memory address; display purposes only */\n\treadonly address: bigint;\n\ttoDAP(): DebugProtocol.InstructionBreakpoint;\n}\n\nexport interface IExceptionInfo {\n\treadonly id?: string;\n\treadonly description?: string;\n\treadonly breakMode: string | null;\n\treadonly details?: DebugProtocol.ExceptionDetails;\n}\n\n// model interfaces\n\nexport interface IViewModel extends ITreeElement {\n\t/**\n\t * Returns the focused debug session or undefined if no session is stopped.\n\t */\n\treadonly focusedSession: IDebugSession | undefined;\n\n\t/**\n\t * Returns the focused thread or undefined if no thread is stopped.\n\t */\n\treadonly focusedThread: IThread | undefined;\n\n\t/**\n\t * Returns the focused stack frame or undefined if there are no stack frames.\n\t */\n\treadonly focusedStackFrame: IStackFrame | undefined;\n\n\tsetVisualizedExpression(\n\t\toriginal: IExpression,\n\t\tvisualized: (IExpression & { treeId: string }) | undefined,\n\t): void;\n\t/** Returns the visualized expression if loaded, or a tree it should be visualized with, or undefined */\n\tgetVisualizedExpression(\n\t\texpression: IExpression,\n\t): IExpression | string | undefined;\n\tgetSelectedExpression():\n\t\t| { expression: IExpression; settingWatch: boolean }\n\t\t| undefined;\n\tsetSelectedExpression(\n\t\texpression: IExpression | undefined,\n\t\tsettingWatch: boolean,\n\t): void;\n\tupdateViews(): void;\n\n\tisMultiSessionView(): boolean;\n\n\tonDidFocusSession: Event<IDebugSession | undefined>;\n\tonDidFocusThread: Event<{\n\t\tthread: IThread | undefined;\n\t\texplicit: boolean;\n\t\tsession: IDebugSession | undefined;\n\t}>;\n\tonDidFocusStackFrame: Event<{\n\t\tstackFrame: IStackFrame | undefined;\n\t\texplicit: boolean;\n\t\tsession: IDebugSession | undefined;\n\t}>;\n\tonDidSelectExpression: Event<\n\t\t{ expression: IExpression; settingWatch: boolean } | undefined\n\t>;\n\tonDidEvaluateLazyExpression: Event<IExpressionContainer>;\n\t/**\n\t * Fired when `setVisualizedExpression`, to migrate elements currently\n\t * rendered as `original` to the `replacement`.\n\t */\n\tonDidChangeVisualization: Event<{\n\t\toriginal: IExpression;\n\t\treplacement: IExpression;\n\t}>;\n\tonWillUpdateViews: Event<void>;\n\n\tevaluateLazyExpression(expression: IExpressionContainer): void;\n}\n\nexport interface IEvaluate {\n\tevaluate(\n\t\tsession: IDebugSession,\n\t\tstackFrame: IStackFrame,\n\t\tcontext: string,\n\t): Promise<void>;\n}\n\nexport interface IDebugModel extends ITreeElement {\n\tgetSession(\n\t\tsessionId: string | undefined,\n\t\tincludeInactive?: boolean,\n\t): IDebugSession | undefined;\n\tgetSessions(includeInactive?: boolean): IDebugSession[];\n\tgetBreakpoints(filter?: {\n\t\turi?: uri;\n\t\toriginalUri?: uri;\n\t\tlineNumber?: number;\n\t\tcolumn?: number;\n\t\tenabledOnly?: boolean;\n\t\ttriggeredOnly?: boolean;\n\t}): ReadonlyArray<IBreakpoint>;\n\tareBreakpointsActivated(): boolean;\n\tgetFunctionBreakpoints(): ReadonlyArray<IFunctionBreakpoint>;\n\tgetDataBreakpoints(): ReadonlyArray<IDataBreakpoint>;\n\n\t/**\n\t * Returns list of all exception breakpoints.\n\t */\n\tgetExceptionBreakpoints(): ReadonlyArray<IExceptionBreakpoint>;\n\n\t/**\n\t * Returns list of exception breakpoints for the given session\n\t * @param sessionId Session id. If falsy, returns the breakpoints from the last set fallback session.\n\t */\n\tgetExceptionBreakpointsForSession(\n\t\tsessionId?: string,\n\t): ReadonlyArray<IExceptionBreakpoint>;\n\n\tgetInstructionBreakpoints(): ReadonlyArray<IInstructionBreakpoint>;\n\tgetWatchExpressions(): ReadonlyArray<IExpression & IEvaluate>;\n\tregisterBreakpointModes(\n\t\tdebugType: string,\n\t\tmodes: DebugProtocol.BreakpointMode[],\n\t): void;\n\tgetBreakpointModes(\n\t\tforBreakpointType: \"source\" | \"exception\" | \"data\" | \"instruction\",\n\t): DebugProtocol.BreakpointMode[];\n\tonDidChangeBreakpoints: Event<IBreakpointsChangeEvent | undefined>;\n\tonDidChangeCallStack: Event<void>;\n\t/**\n\t * The expression has been added, removed, or repositioned.\n\t */\n\tonDidChangeWatchExpressions: Event<IExpression | undefined>;\n\t/**\n\t * The expression's value has changed.\n\t */\n\tonDidChangeWatchExpressionValue: Event<IExpression | undefined>;\n\n\tfetchCallstack(thread: IThread, levels?: number): Promise<void>;\n}\n\n/**\n * An event describing a change to the set of [breakpoints](#debug.Breakpoint).\n */\nexport interface IBreakpointsChangeEvent {\n\tadded?: Array<\n\t\t| IBreakpoint\n\t\t| IFunctionBreakpoint\n\t\t| IDataBreakpoint\n\t\t| IInstructionBreakpoint\n\t>;\n\tremoved?: Array<\n\t\t| IBreakpoint\n\t\t| IFunctionBreakpoint\n\t\t| IDataBreakpoint\n\t\t| IInstructionBreakpoint\n\t>;\n\tchanged?: Array<\n\t\t| IBreakpoint\n\t\t| IFunctionBreakpoint\n\t\t| IDataBreakpoint\n\t\t| IInstructionBreakpoint\n\t>;\n\tsessionOnly: boolean;\n}\n\n// Debug configuration interfaces\n\nexport interface IDebugConfiguration {\n\tallowBreakpointsEverywhere: boolean;\n\tgutterMiddleClickAction:\n\t\t| \"logpoint\"\n\t\t| \"conditionalBreakpoint\"\n\t\t| \"triggeredBreakpoint\"\n\t\t| \"none\";\n\topenDebug:\n\t\t| \"neverOpen\"\n\t\t| \"openOnSessionStart\"\n\t\t| \"openOnFirstSessionStart\"\n\t\t| \"openOnDebugBreak\";\n\topenExplorerOnEnd: boolean;\n\tinlineValues: boolean | \"auto\" | \"on\" | \"off\"; // boolean for back-compat\n\ttoolBarLocation: \"floating\" | \"docked\" | \"commandCenter\" | \"hidden\";\n\tshowInStatusBar: \"never\" | \"always\" | \"onFirstSessionStart\";\n\tinternalConsoleOptions:\n\t\t| \"neverOpen\"\n\t\t| \"openOnSessionStart\"\n\t\t| \"openOnFirstSessionStart\";\n\textensionHostDebugAdapter: boolean;\n\tenableAllHovers: boolean;\n\tshowSubSessionsInToolBar: boolean;\n\tcloseReadonlyTabsOnEnd: boolean;\n\tconsole: {\n\t\tfontSize: number;\n\t\tfontFamily: string;\n\t\tlineHeight: number;\n\t\twordWrap: boolean;\n\t\tcloseOnEnd: boolean;\n\t\tcollapseIdenticalLines: boolean;\n\t\thistorySuggestions: boolean;\n\t\tacceptSuggestionOnEnter: \"off\" | \"on\";\n\t};\n\tfocusWindowOnBreak: boolean;\n\tfocusEditorOnBreak: boolean;\n\tonTaskErrors: \"debugAnyway\" | \"showErrors\" | \"prompt\" | \"abort\";\n\tshowBreakpointsInOverviewRuler: boolean;\n\tshowInlineBreakpointCandidates: boolean;\n\tconfirmOnExit: \"always\" | \"never\";\n\tdisassemblyView: {\n\t\tshowSourceCode: boolean;\n\t};\n\tautoExpandLazyVariables: \"auto\" | \"off\" | \"on\";\n\tenableStatusBarColor: boolean;\n\tshowVariableTypes: boolean;\n}\n\nexport interface IGlobalConfig {\n\tversion: string;\n\tcompounds: ICompound[];\n\tconfigurations: IConfig[];\n}\n\ninterface IEnvConfig {\n\tinternalConsoleOptions?:\n\t\t| \"neverOpen\"\n\t\t| \"openOnSessionStart\"\n\t\t| \"openOnFirstSessionStart\";\n\tpreRestartTask?: string | ITaskIdentifier;\n\tpostRestartTask?: string | ITaskIdentifier;\n\tpreLaunchTask?: string | ITaskIdentifier;\n\tpostDebugTask?: string | ITaskIdentifier;\n\tdebugServer?: number;\n\tnoDebug?: boolean;\n\tsuppressMultipleSessionWarning?: boolean;\n}\n\nexport interface IConfigPresentation {\n\thidden?: boolean;\n\tgroup?: string;\n\torder?: number;\n}\n\nexport interface IConfig extends IEnvConfig {\n\t// fundamental attributes\n\ttype: string;\n\trequest: string;\n\tname: string;\n\tpresentation?: IConfigPresentation;\n\t// platform specifics\n\twindows?: IEnvConfig;\n\tosx?: IEnvConfig;\n\tlinux?: IEnvConfig;\n\n\t// internals\n\t__configurationTarget?: ConfigurationTarget;\n\t__sessionId?: string;\n\t__restart?: any;\n\t__autoAttach?: boolean;\n\tport?: number; // TODO\n}\n\nexport interface ICompound {\n\tname: string;\n\tstopAll?: boolean;\n\tpreLaunchTask?: string | ITaskIdentifier;\n\tconfigurations: (string | { name: string; folder: string })[];\n\tpresentation?: IConfigPresentation;\n}\n\nexport interface IDebugAdapter extends IDisposable {\n\treadonly onError: Event<Error>;\n\treadonly onExit: Event<number | null>;\n\tonRequest(callback: (request: DebugProtocol.Request) => void): void;\n\tonEvent(callback: (event: DebugProtocol.Event) => void): void;\n\tstartSession(): Promise<void>;\n\tsendMessage(message: DebugProtocol.ProtocolMessage): void;\n\tsendResponse(response: DebugProtocol.Response): void;\n\tsendRequest(\n\t\tcommand: string,\n\t\targs: any,\n\t\tclb: (result: DebugProtocol.Response) => void,\n\t\ttimeout?: number,\n\t): number;\n\tstopSession(): Promise<void>;\n}\n\nexport interface IDebugAdapterFactory extends ITerminalLauncher {\n\tcreateDebugAdapter(session: IDebugSession): IDebugAdapter;\n\tsubstituteVariables(\n\t\tfolder: IWorkspaceFolder | undefined,\n\t\tconfig: IConfig,\n\t): Promise<IConfig>;\n}\n\nexport interface IDebugAdapterExecutableOptions {\n\tcwd?: string;\n\tenv?: { [key: string]: string };\n}\n\nexport interface IDebugAdapterExecutable {\n\treadonly type: \"executable\";\n\treadonly command: string;\n\treadonly args: string[];\n\treadonly options?: IDebugAdapterExecutableOptions;\n}\n\nexport interface IDebugAdapterServer {\n\treadonly type: \"server\";\n\treadonly port: number;\n\treadonly host?: string;\n}\n\nexport interface IDebugAdapterNamedPipeServer {\n\treadonly type: \"pipeServer\";\n\treadonly path: string;\n}\n\nexport interface IDebugAdapterInlineImpl extends IDisposable {\n\treadonly onDidSendMessage: Event<DebugProtocol.Message>;\n\thandleMessage(message: DebugProtocol.Message): void;\n}\n\nexport interface IDebugAdapterImpl {\n\treadonly type: \"implementation\";\n}\n\nexport type IAdapterDescriptor =\n\t| IDebugAdapterExecutable\n\t| IDebugAdapterServer\n\t| IDebugAdapterNamedPipeServer\n\t| IDebugAdapterImpl;\n\nexport interface IPlatformSpecificAdapterContribution {\n\tprogram?: string;\n\targs?: string[];\n\truntime?: string;\n\truntimeArgs?: string[];\n}\n\nexport interface IDebuggerContribution\n\textends IPlatformSpecificAdapterContribution {\n\ttype: string;\n\tlabel?: string;\n\twin?: IPlatformSpecificAdapterContribution;\n\twinx86?: IPlatformSpecificAdapterContribution;\n\twindows?: IPlatformSpecificAdapterContribution;\n\tosx?: IPlatformSpecificAdapterContribution;\n\tlinux?: IPlatformSpecificAdapterContribution;\n\n\t// internal\n\taiKey?: string;\n\n\t// supported languages\n\tlanguages?: string[];\n\n\t// debug configuration support\n\tconfigurationAttributes?: any;\n\tinitialConfigurations?: any[];\n\tconfigurationSnippets?: IJSONSchemaSnippet[];\n\tvariables?: { [key: string]: string };\n\twhen?: string;\n\thiddenWhen?: string;\n\tdeprecated?: string;\n\tstrings?: { [key in DebuggerString]: string };\n}\n\nexport interface IBreakpointContribution {\n\tlanguage: string;\n\twhen?: string;\n}\n\nexport enum DebugConfigurationProviderTriggerKind {\n\t/**\n\t *\t`DebugConfigurationProvider.provideDebugConfigurations` is called to provide the initial debug configurations for a newly created launch.json.\n\t */\n\tInitial = 1,\n\t/**\n\t * `DebugConfigurationProvider.provideDebugConfigurations` is called to provide dynamically generated debug configurations when the user asks for them through the UI (e.g. via the \"Select and Start Debugging\" command).\n\t */\n\tDynamic = 2,\n}\n\nexport interface IDebugConfigurationProvider {\n\treadonly type: string;\n\treadonly triggerKind: DebugConfigurationProviderTriggerKind;\n\tresolveDebugConfiguration?(\n\t\tfolderUri: uri | undefined,\n\t\tdebugConfiguration: IConfig,\n\t\ttoken: CancellationToken,\n\t): Promise<IConfig | null | undefined>;\n\tresolveDebugConfigurationWithSubstitutedVariables?(\n\t\tfolderUri: uri | undefined,\n\t\tdebugConfiguration: IConfig,\n\t\ttoken: CancellationToken,\n\t): Promise<IConfig | null | undefined>;\n\tprovideDebugConfigurations?(\n\t\tfolderUri: uri | undefined,\n\t\ttoken: CancellationToken,\n\t): Promise<IConfig[]>;\n}\n\nexport interface IDebugAdapterDescriptorFactory {\n\treadonly type: string;\n\tcreateDebugAdapterDescriptor(\n\t\tsession: IDebugSession,\n\t): Promise<IAdapterDescriptor>;\n}\n\ninterface ITerminalLauncher {\n\trunInTerminal(\n\t\targs: DebugProtocol.RunInTerminalRequestArguments,\n\t\tsessionId: string,\n\t): Promise<number | undefined>;\n}\n\nexport interface IConfigurationManager {\n\t/**\n\t * Returns an object containing the selected launch configuration and the selected configuration name. Both these fields can be null (no folder workspace).\n\t */\n\treadonly selectedConfiguration: {\n\t\tlaunch: ILaunch | undefined;\n\t\t// Potentially activates extensions\n\t\tgetConfig: () => Promise<IConfig | undefined>;\n\t\tname: string | undefined;\n\t\t// Type is used when matching dynamic configurations to their corresponding provider\n\t\ttype: string | undefined;\n\t};\n\n\tselectConfiguration(\n\t\tlaunch: ILaunch | undefined,\n\t\tname?: string,\n\t\tconfig?: IConfig,\n\t\tdynamicConfigOptions?: { type?: string },\n\t): Promise<void>;\n\n\tgetLaunches(): ReadonlyArray<ILaunch>;\n\tgetLaunch(workspaceUri: uri | undefined): ILaunch | undefined;\n\tgetAllConfigurations(): {\n\t\tlaunch: ILaunch;\n\t\tname: string;\n\t\tpresentation?: IConfigPresentation;\n\t}[];\n\tremoveRecentDynamicConfigurations(name: string, type: string): void;\n\tgetRecentDynamicConfigurations(): { name: string; type: string }[];\n\n\t/**\n\t * Allows to register on change of selected debug configuration.\n\t */\n\tonDidSelectConfiguration: Event<void>;\n\n\t/**\n\t * Allows to register on change of selected debug configuration.\n\t */\n\tonDidChangeConfigurationProviders: Event<void>;\n\n\thasDebugConfigurationProvider(\n\t\tdebugType: string,\n\t\ttriggerKind?: DebugConfigurationProviderTriggerKind,\n\t): boolean;\n\tgetDynamicProviders(): Promise<\n\t\t{\n\t\t\tlabel: string;\n\t\t\ttype: string;\n\t\t\tpick: () => Promise<\n\t\t\t\t{ launch: ILaunch; config: IConfig } | undefined\n\t\t\t>;\n\t\t}[]\n\t>;\n\n\tregisterDebugConfigurationProvider(\n\t\tdebugConfigurationProvider: IDebugConfigurationProvider,\n\t): IDisposable;\n\tunregisterDebugConfigurationProvider(\n\t\tdebugConfigurationProvider: IDebugConfigurationProvider,\n\t): void;\n\n\tresolveConfigurationByProviders(\n\t\tfolderUri: uri | undefined,\n\t\ttype: string | undefined,\n\t\tdebugConfiguration: any,\n\t\ttoken: CancellationToken,\n\t): Promise<any>;\n}\n\nexport enum DebuggerString {\n\tUnverifiedBreakpoints = \"unverifiedBreakpoints\",\n}\n\nexport interface IAdapterManager {\n\tonDidRegisterDebugger: Event<void>;\n\n\thasEnabledDebuggers(): boolean;\n\tgetDebugAdapterDescriptor(\n\t\tsession: IDebugSession,\n\t): Promise<IAdapterDescriptor | undefined>;\n\tgetDebuggerLabel(type: string): string | undefined;\n\tsomeDebuggerInterestedInLanguage(language: string): boolean;\n\tgetDebugger(type: string): IDebuggerMetadata | undefined;\n\n\tactivateDebuggers(\n\t\tactivationEvent: string,\n\t\tdebugType?: string,\n\t): Promise<void>;\n\tregisterDebugAdapterFactory(\n\t\tdebugTypes: string[],\n\t\tdebugAdapterFactory: IDebugAdapterFactory,\n\t): IDisposable;\n\tcreateDebugAdapter(session: IDebugSession): IDebugAdapter | undefined;\n\tregisterDebugAdapterDescriptorFactory(\n\t\tdebugAdapterDescriptorFactory: IDebugAdapterDescriptorFactory,\n\t): IDisposable;\n\tunregisterDebugAdapterDescriptorFactory(\n\t\tdebugAdapterDescriptorFactory: IDebugAdapterDescriptorFactory,\n\t): void;\n\n\tsubstituteVariables(\n\t\tdebugType: string,\n\t\tfolder: IWorkspaceFolder | undefined,\n\t\tconfig: IConfig,\n\t): Promise<IConfig>;\n\trunInTerminal(\n\t\tdebugType: string,\n\t\targs: DebugProtocol.RunInTerminalRequestArguments,\n\t\tsessionId: string,\n\t): Promise<number | undefined>;\n\tgetEnabledDebugger(\n\t\ttype: string,\n\t): (IDebugger & IDebuggerMetadata) | undefined;\n\tguessDebugger(\n\t\tgettingConfigurations: boolean,\n\t): Promise<(IDebugger & IDebuggerMetadata) | undefined>;\n\n\tget onDidDebuggersExtPointRead(): Event<void>;\n}\n\nexport interface ILaunch {\n\t/**\n\t * Resource pointing to the launch.json this object is wrapping.\n\t */\n\treadonly uri: uri;\n\n\t/**\n\t * Name of the launch.\n\t */\n\treadonly name: string;\n\n\t/**\n\t * Workspace of the launch. Can be undefined.\n\t */\n\treadonly workspace: IWorkspaceFolder | undefined;\n\n\t/**\n\t * Should this launch be shown in the debug dropdown.\n\t */\n\treadonly hidden: boolean;\n\n\t/**\n\t * Returns a configuration with the specified name.\n\t * Returns undefined if there is no configuration with the specified name.\n\t */\n\tgetConfiguration(name: string): IConfig | undefined;\n\n\t/**\n\t * Returns a compound with the specified name.\n\t * Returns undefined if there is no compound with the specified name.\n\t */\n\tgetCompound(name: string): ICompound | undefined;\n\n\t/**\n\t * Returns the names of all configurations and compounds.\n\t * Ignores configurations which are invalid.\n\t */\n\tgetConfigurationNames(ignoreCompoundsAndPresentation?: boolean): string[];\n\n\t/**\n\t * Opens the launch.json file. Creates if it does not exist.\n\t */\n\topenConfigFile(\n\t\toptions: {\n\t\t\tpreserveFocus: boolean;\n\t\t\ttype?: string;\n\t\t\tsuppressInitialConfigs?: boolean;\n\t\t},\n\t\ttoken?: CancellationToken,\n\t): Promise<{ editor: IEditorPane | null; created: boolean }>;\n}\n\n// Debug service interfaces\n\nexport const IDebugService = createDecorator<IDebugService>(\"debugService\");\n\nexport interface IDebugService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Gets the current debug state.\n\t */\n\treadonly state: State;\n\n\treadonly initializingOptions?: IDebugSessionOptions | undefined;\n\n\t/**\n\t * Allows to register on debug state changes.\n\t */\n\tonDidChangeState: Event<State>;\n\n\t/**\n\t * Allows to register on sessions about to be created (not yet fully initialised).\n\t * This is fired exactly one time for any given session.\n\t */\n\tonWillNewSession: Event<IDebugSession>;\n\n\t/**\n\t * Fired when a new debug session is started. This may fire multiple times\n\t * for a single session due to restarts.\n\t */\n\tonDidNewSession: Event<IDebugSession>;\n\n\t/**\n\t * Allows to register on end session events.\n\t *\n\t * Contains a boolean indicating whether the session will restart. If restart\n\t * is true, the session should not considered to be dead yet.\n\t */\n\tonDidEndSession: Event<{ session: IDebugSession; restart: boolean }>;\n\n\t/**\n\t * Gets the configuration manager.\n\t */\n\tgetConfigurationManager(): IConfigurationManager;\n\n\t/**\n\t * Gets the adapter manager.\n\t */\n\tgetAdapterManager(): IAdapterManager;\n\n\t/**\n\t * Sets the focused stack frame and evaluates all expressions against the newly focused stack frame,\n\t */\n\tfocusStackFrame(\n\t\tfocusedStackFrame: IStackFrame | undefined,\n\t\tthread?: IThread,\n\t\tsession?: IDebugSession,\n\t\toptions?: {\n\t\t\texplicit?: boolean;\n\t\t\tpreserveFocus?: boolean;\n\t\t\tsideBySide?: boolean;\n\t\t\tpinned?: boolean;\n\t\t},\n\t): Promise<void>;\n\n\t/**\n\t * Returns true if breakpoints can be set for a given editor model. Depends on mode.\n\t */\n\tcanSetBreakpointsIn(model: EditorIModel): boolean;\n\n\t/**\n\t * Adds new breakpoints to the model for the file specified with the uri. Notifies debug adapter of breakpoint changes.\n\t */\n\taddBreakpoints(\n\t\turi: uri,\n\t\trawBreakpoints: IBreakpointData[],\n\t\tariaAnnounce?: boolean,\n\t): Promise<IBreakpoint[]>;\n\n\t/**\n\t * Updates the breakpoints.\n\t */\n\tupdateBreakpoints(\n\t\toriginalUri: uri,\n\t\tdata: Map<string, IBreakpointUpdateData>,\n\t\tsendOnResourceSaved: boolean,\n\t): Promise<void>;\n\n\t/**\n\t * Enables or disables all breakpoints. If breakpoint is passed only enables or disables the passed breakpoint.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tenableOrDisableBreakpoints(\n\t\tenable: boolean,\n\t\tbreakpoint?: IEnablement,\n\t): Promise<void>;\n\n\t/**\n\t * Sets the global activated property for all breakpoints.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tsetBreakpointsActivated(activated: boolean): Promise<void>;\n\n\t/**\n\t * Removes all breakpoints. If id is passed only removes the breakpoint associated with that id.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tremoveBreakpoints(id?: string): Promise<any>;\n\n\t/**\n\t * Adds a new function breakpoint for the given name.\n\t */\n\taddFunctionBreakpoint(opts?: IFunctionBreakpointOptions, id?: string): void;\n\n\t/**\n\t * Updates an already existing function breakpoint.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tupdateFunctionBreakpoint(\n\t\tid: string,\n\t\tupdate: { name?: string; hitCondition?: string; condition?: string },\n\t): Promise<void>;\n\n\t/**\n\t * Removes all function breakpoints. If id is passed only removes the function breakpoint with the passed id.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tremoveFunctionBreakpoints(id?: string): Promise<void>;\n\n\t/**\n\t * Adds a new data breakpoint.\n\t */\n\taddDataBreakpoint(opts: IDataBreakpointOptions): Promise<void>;\n\n\t/**\n\t * Updates an already existing data breakpoint.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tupdateDataBreakpoint(\n\t\tid: string,\n\t\tupdate: { hitCondition?: string; condition?: string },\n\t): Promise<void>;\n\n\t/**\n\t * Removes all data breakpoints. If id is passed only removes the data breakpoint with the passed id.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tremoveDataBreakpoints(id?: string): Promise<void>;\n\n\t/**\n\t * Adds a new instruction breakpoint.\n\t */\n\taddInstructionBreakpoint(\n\t\topts: IInstructionBreakpointOptions,\n\t): Promise<void>;\n\n\t/**\n\t * Removes all instruction breakpoints. If address is passed only removes the instruction breakpoint with the passed address.\n\t * The address should be the address string supplied by the debugger from the \"Disassemble\" request.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tremoveInstructionBreakpoints(\n\t\tinstructionReference?: string,\n\t\toffset?: number,\n\t): Promise<void>;\n\n\tsetExceptionBreakpointCondition(\n\t\tbreakpoint: IExceptionBreakpoint,\n\t\tcondition: string | undefined,\n\t): Promise<void>;\n\n\t/**\n\t * Creates breakpoints based on the sesison filter options. This will create\n\t * disabled breakpoints (or enabled, if the filter indicates it's a default)\n\t * for each filter provided in the session.\n\t */\n\tsetExceptionBreakpointsForSession(\n\t\tsession: IDebugSession,\n\t\tfilters: DebugProtocol.ExceptionBreakpointsFilter[],\n\t): void;\n\n\t/**\n\t * Sends all breakpoints to the passed session.\n\t * If session is not passed, sends all breakpoints to each session.\n\t */\n\tsendAllBreakpoints(session?: IDebugSession): Promise<any>;\n\n\t/**\n\t * Sends breakpoints of the given source to the passed session.\n\t */\n\tsendBreakpoints(\n\t\tmodelUri: uri,\n\t\tsourceModified?: boolean,\n\t\tsession?: IDebugSession,\n\t): Promise<any>;\n\n\t/**\n\t * Adds a new watch expression and evaluates it against the debug adapter.\n\t */\n\taddWatchExpression(name?: string): void;\n\n\t/**\n\t * Renames a watch expression and evaluates it against the debug adapter.\n\t */\n\trenameWatchExpression(id: string, newName: string): void;\n\n\t/**\n\t * Moves a watch expression to a new possition. Used for reordering watch expressions.\n\t */\n\tmoveWatchExpression(id: string, position: number): void;\n\n\t/**\n\t * Removes all watch expressions. If id is passed only removes the watch expression with the passed id.\n\t */\n\tremoveWatchExpressions(id?: string): void;\n\n\t/**\n\t * Starts debugging. If the configOrName is not passed uses the selected configuration in the debug dropdown.\n\t * Also saves all files, manages if compounds are present in the configuration\n\t * and resolveds configurations via DebugConfigurationProviders.\n\t *\n\t * Returns true if the start debugging was successful. For compound launches, all configurations have to start successfully for it to return success.\n\t * On errors the startDebugging will throw an error, however some error and cancelations are handled and in that case will simply return false.\n\t */\n\tstartDebugging(\n\t\tlaunch: ILaunch | undefined,\n\t\tconfigOrName?: IConfig | string,\n\t\toptions?: IDebugSessionOptions,\n\t\tsaveBeforeStart?: boolean,\n\t): Promise<boolean>;\n\n\t/**\n\t * Restarts a session or creates a new one if there is no active session.\n\t */\n\trestartSession(session: IDebugSession, restartData?: any): Promise<any>;\n\n\t/**\n\t * Stops the session. If no session is specified then all sessions are stopped.\n\t */\n\tstopSession(\n\t\tsession: IDebugSession | undefined,\n\t\tdisconnect?: boolean,\n\t\tsuspend?: boolean,\n\t): Promise<any>;\n\n\t/**\n\t * Makes unavailable all sources with the passed uri. Source will appear as grayed out in callstack view.\n\t */\n\tsourceIsNotAvailable(uri: uri): void;\n\n\t/**\n\t * Gets the current debug model.\n\t */\n\tgetModel(): IDebugModel;\n\n\t/**\n\t * Gets the current view model.\n\t */\n\tgetViewModel(): IViewModel;\n\n\t/**\n\t * Resumes execution and pauses until the given position is reached.\n\t */\n\trunTo(uri: uri, lineNumber: number, column?: number): Promise<void>;\n}\n\n// Editor interfaces\nexport enum BreakpointWidgetContext {\n\tCONDITION = 0,\n\tHIT_COUNT = 1,\n\tLOG_MESSAGE = 2,\n\tTRIGGER_POINT = 3,\n}\n\nexport interface IDebugEditorContribution\n\textends editorCommon.IEditorContribution {\n\tshowHover(range: Position, focus: boolean): Promise<void>;\n\taddLaunchConfiguration(): Promise<any>;\n\tcloseExceptionWidget(): void;\n}\n\nexport interface IBreakpointEditorContribution\n\textends editorCommon.IEditorContribution {\n\tshowBreakpointWidget(\n\t\tlineNumber: number,\n\t\tcolumn: number | undefined,\n\t\tcontext?: BreakpointWidgetContext,\n\t): void;\n\tcloseBreakpointWidget(): void;\n\tgetContextMenuActionsAtPosition(\n\t\tlineNumber: number,\n\t\tmodel: EditorIModel,\n\t): IAction[];\n}\n\nexport interface IReplConfiguration {\n\treadonly fontSize: number;\n\treadonly fontFamily: string;\n\treadonly lineHeight: number;\n\treadonly cssLineHeight: string;\n\treadonly backgroundColor: Color | undefined;\n\treadonly fontSizeForTwistie: number;\n}\n\nexport interface IReplOptions {\n\treadonly replConfiguration: IReplConfiguration;\n}\n\nexport interface IDebugVisualizationContext {\n\tvariable: DebugProtocol.Variable;\n\tcontainerId?: number;\n\tframeId?: number;\n\tthreadId: number;\n\tsessionId: string;\n}\n\nexport enum DebugVisualizationType {\n\tCommand = 0,\n\tTree = 1,\n}\n\nexport type MainThreadDebugVisualization =\n\t| { type: DebugVisualizationType.Command }\n\t| { type: DebugVisualizationType.Tree; id: string };\n\nexport enum DebugTreeItemCollapsibleState {\n\tNone = 0,\n\tCollapsed = 1,\n\tExpanded = 2,\n}\n\nexport interface IDebugVisualizationTreeItem {\n\tid: number;\n\tlabel: string;\n\tdescription?: string;\n\tcollapsibleState: DebugTreeItemCollapsibleState;\n\tcontextValue?: string;\n\tcanEdit?: boolean;\n}\n\nexport namespace IDebugVisualizationTreeItem {\n\texport type Serialized = IDebugVisualizationTreeItem;\n\texport const deserialize = (v: Serialized): IDebugVisualizationTreeItem =>\n\t\tv;\n\texport const serialize = (item: IDebugVisualizationTreeItem): Serialized =>\n\t\titem;\n}\n\nexport interface IDebugVisualization {\n\tid: number;\n\tname: string;\n\ticonPath: { light?: URI; dark: URI } | undefined;\n\ticonClass: string | undefined;\n\tvisualization: MainThreadDebugVisualization | undefined;\n}\n\nexport namespace IDebugVisualization {\n\texport interface Serialized {\n\t\tid: number;\n\t\tname: string;\n\t\ticonPath?: { light?: UriComponents; dark: UriComponents };\n\t\ticonClass?: string;\n\t\tvisualization?: MainThreadDebugVisualization;\n\t}\n\n\texport const deserialize = (v: Serialized): IDebugVisualization => ({\n\t\tid: v.id,\n\t\tname: v.name,\n\t\ticonPath: v.iconPath && {\n\t\t\tlight: URI.revive(v.iconPath.light),\n\t\t\tdark: URI.revive(v.iconPath.dark),\n\t\t},\n\t\ticonClass: v.iconClass,\n\t\tvisualization: v.visualization,\n\t});\n\n\texport const serialize = (visualizer: IDebugVisualization): Serialized =>\n\t\tvisualizer;\n}\n"],
  "mappings": "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",
  "names": ["State", "MemoryRangeType", "DataBreakpointSetType", "DebugConfigurationProviderTriggerKind", "DebuggerString", "BreakpointWidgetContext", "DebugVisualizationType", "DebugTreeItemCollapsibleState", "IDebugVisualizationTreeItem", "IDebugVisualization"]
}
