{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/debug/common/debugUtils.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { coalesce } from \"../../../../base/common/arrays.js\";\nimport { CancellationToken } from \"../../../../base/common/cancellation.js\";\nimport { Schemas } from \"../../../../base/common/network.js\";\nimport { deepClone } from \"../../../../base/common/objects.js\";\nimport { isAbsolute } from \"../../../../base/common/path.js\";\nimport { equalsIgnoreCase } from \"../../../../base/common/strings.js\";\nimport { URI as uri } from \"../../../../base/common/uri.js\";\nimport type { Position } from \"../../../../editor/common/core/position.js\";\nimport { type IRange, Range } from \"../../../../editor/common/core/range.js\";\nimport type { ITextModel } from \"../../../../editor/common/model.js\";\nimport type { ILanguageFeaturesService } from \"../../../../editor/common/services/languageFeatures.js\";\nimport type { IConfigurationService } from \"../../../../platform/configuration/common/configuration.js\";\nimport type { IEditorService } from \"../../../services/editor/common/editorService.js\";\nimport type {\n\tIConfigPresentation,\n\tIDebugSession,\n\tIDebuggerContribution,\n} from \"./debug.js\";\n\nconst _formatPIIRegexp = /{([^}]+)}/g;\n\nexport function formatPII(\n\tvalue: string,\n\texcludePII: boolean,\n\targs: { [key: string]: string } | undefined,\n): string {\n\treturn value.replace(_formatPIIRegexp, (match, group) => {\n\t\tif (excludePII && group.length > 0 && group[0] !== \"_\") {\n\t\t\treturn match;\n\t\t}\n\n\t\treturn args && args.hasOwnProperty(group) ? args[group] : match;\n\t});\n}\n\n/**\n * Filters exceptions (keys marked with \"!\") from the given object. Used to\n * ensure exception data is not sent on web remotes, see #97628.\n */\nexport function filterExceptionsFromTelemetry<\n\tT extends { [key: string]: unknown },\n>(data: T): Partial<T> {\n\tconst output: Partial<T> = {};\n\tfor (const key of Object.keys(data) as (keyof T & string)[]) {\n\t\tif (!key.startsWith(\"!\")) {\n\t\t\toutput[key] = data[key];\n\t\t}\n\t}\n\n\treturn output;\n}\n\nexport function isSessionAttach(session: IDebugSession): boolean {\n\treturn (\n\t\tsession.configuration.request === \"attach\" &&\n\t\t!getExtensionHostDebugSession(session) &&\n\t\t(!session.parentSession || isSessionAttach(session.parentSession))\n\t);\n}\n\n/**\n * Returns the session or any parent which is an extension host debug session.\n * Returns undefined if there's none.\n */\nexport function getExtensionHostDebugSession(\n\tsession: IDebugSession,\n): IDebugSession | void {\n\tlet type = session.configuration.type;\n\tif (!type) {\n\t\treturn;\n\t}\n\n\tif (type === \"vslsShare\") {\n\t\ttype = (<any>session.configuration).adapterProxy.configuration.type;\n\t}\n\n\tif (\n\t\tequalsIgnoreCase(type, \"extensionhost\") ||\n\t\tequalsIgnoreCase(type, \"pwa-extensionhost\")\n\t) {\n\t\treturn session;\n\t}\n\n\treturn session.parentSession\n\t\t? getExtensionHostDebugSession(session.parentSession)\n\t\t: undefined;\n}\n\n// only a debugger contributions with a label, program, or runtime attribute is considered a \"defining\" or \"main\" debugger contribution\nexport function isDebuggerMainContribution(dbg: IDebuggerContribution) {\n\treturn dbg.type && (dbg.label || dbg.program || dbg.runtime);\n}\n\nexport function getExactExpressionStartAndEnd(\n\tlineContent: string,\n\tlooseStart: number,\n\tlooseEnd: number,\n): { start: number; end: number } {\n\tlet matchingExpression: string | undefined;\n\tlet startOffset = 0;\n\n\t// Some example supported expressions: myVar.prop, a.b.c.d, myVar?.prop, myVar->prop, MyClass::StaticProp, *myVar\n\t// Match any character except a set of characters which often break interesting sub-expressions\n\tconst expression: RegExp = /([^()[\\]{}<>\\s+\\-/%~#^;=|,`!]|->)+/g;\n\tlet result: RegExpExecArray | null = null;\n\n\t// First find the full expression under the cursor\n\twhile ((result = expression.exec(lineContent))) {\n\t\tconst start = result.index + 1;\n\t\tconst end = start + result[0].length;\n\n\t\tif (start <= looseStart && end >= looseEnd) {\n\t\t\tmatchingExpression = result[0];\n\t\t\tstartOffset = start;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// If there are non-word characters after the cursor, we want to truncate the expression then.\n\t// For example in expression 'a.b.c.d', if the focus was under 'b', 'a.b' would be evaluated.\n\tif (matchingExpression) {\n\t\tconst subExpression: RegExp = /(\\w|\\p{L})+/gu;\n\t\tlet subExpressionResult: RegExpExecArray | null = null;\n\t\twhile ((subExpressionResult = subExpression.exec(matchingExpression))) {\n\t\t\tconst subEnd =\n\t\t\t\tsubExpressionResult.index +\n\t\t\t\t1 +\n\t\t\t\tstartOffset +\n\t\t\t\tsubExpressionResult[0].length;\n\t\t\tif (subEnd >= looseEnd) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (subExpressionResult) {\n\t\t\tmatchingExpression = matchingExpression.substring(\n\t\t\t\t0,\n\t\t\t\tsubExpression.lastIndex,\n\t\t\t);\n\t\t}\n\t}\n\n\treturn matchingExpression\n\t\t? {\n\t\t\t\tstart: startOffset,\n\t\t\t\tend: startOffset + matchingExpression.length - 1,\n\t\t\t}\n\t\t: { start: 0, end: 0 };\n}\n\nexport async function getEvaluatableExpressionAtPosition(\n\tlanguageFeaturesService: ILanguageFeaturesService,\n\tmodel: ITextModel,\n\tposition: Position,\n\ttoken?: CancellationToken,\n): Promise<{ range: IRange; matchingExpression: string } | null> {\n\tif (languageFeaturesService.evaluatableExpressionProvider.has(model)) {\n\t\tconst supports =\n\t\t\tlanguageFeaturesService.evaluatableExpressionProvider.ordered(\n\t\t\t\tmodel,\n\t\t\t);\n\n\t\tconst results = coalesce(\n\t\t\tawait Promise.all(\n\t\t\t\tsupports.map(async (support) => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn await support.provideEvaluatableExpression(\n\t\t\t\t\t\t\tmodel,\n\t\t\t\t\t\t\tposition,\n\t\t\t\t\t\t\ttoken ?? CancellationToken.None,\n\t\t\t\t\t\t);\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t),\n\t\t);\n\n\t\tif (results.length > 0) {\n\t\t\tlet matchingExpression = results[0].expression;\n\t\t\tconst range = results[0].range;\n\n\t\t\tif (!matchingExpression) {\n\t\t\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\t\t\tmatchingExpression = lineContent.substring(\n\t\t\t\t\trange.startColumn - 1,\n\t\t\t\t\trange.endColumn - 1,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn { range, matchingExpression };\n\t\t}\n\t} else {\n\t\t// old one-size-fits-all strategy\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\tconst { start, end } = getExactExpressionStartAndEnd(\n\t\t\tlineContent,\n\t\t\tposition.column,\n\t\t\tposition.column,\n\t\t);\n\n\t\t// use regex to extract the sub-expression #9821\n\t\tconst matchingExpression = lineContent.substring(start - 1, end);\n\t\treturn {\n\t\t\tmatchingExpression,\n\t\t\trange: new Range(\n\t\t\t\tposition.lineNumber,\n\t\t\t\tstart,\n\t\t\t\tposition.lineNumber,\n\t\t\t\tstart + matchingExpression.length,\n\t\t\t),\n\t\t};\n\t}\n\n\treturn null;\n}\n\n// RFC 2396, Appendix A: https://www.ietf.org/rfc/rfc2396.txt\nconst _schemePattern = /^[a-zA-Z][a-zA-Z0-9+\\-.]+:/;\n\nexport function isUri(s: string | undefined): boolean {\n\t// heuristics: a valid uri starts with a scheme and\n\t// the scheme has at least 2 characters so that it doesn't look like a drive letter.\n\treturn !!(s && s.match(_schemePattern));\n}\n\nfunction stringToUri(source: PathContainer): string | undefined {\n\tif (typeof source.path === \"string\") {\n\t\tif (\n\t\t\ttypeof source.sourceReference === \"number\" &&\n\t\t\tsource.sourceReference > 0\n\t\t) {\n\t\t\t// if there is a source reference, don't touch path\n\t\t} else if (isUri(source.path)) {\n\t\t\treturn <string>(<unknown>uri.parse(source.path));\n\t\t} else {\n\t\t\t// assume path\n\t\t\tif (isAbsolute(source.path)) {\n\t\t\t\treturn <string>(<unknown>uri.file(source.path));\n\t\t\t} else {\n\t\t\t\t// leave relative path as is\n\t\t\t}\n\t\t}\n\t}\n\treturn source.path;\n}\n\nfunction uriToString(source: PathContainer): string | undefined {\n\tif (typeof source.path === \"object\") {\n\t\tconst u = uri.revive(source.path);\n\t\tif (u) {\n\t\t\tif (u.scheme === Schemas.file) {\n\t\t\t\treturn u.fsPath;\n\t\t\t} else {\n\t\t\t\treturn u.toString();\n\t\t\t}\n\t\t}\n\t}\n\treturn source.path;\n}\n\n// path hooks helpers\n\ninterface PathContainer {\n\tpath?: string;\n\tsourceReference?: number;\n}\n\nexport function convertToDAPaths(\n\tmessage: DebugProtocol.ProtocolMessage,\n\ttoUri: boolean,\n): DebugProtocol.ProtocolMessage {\n\tconst fixPath = toUri ? stringToUri : uriToString;\n\n\t// since we modify Source.paths in the message in place, we need to make a copy of it (see #61129)\n\tconst msg = deepClone(message);\n\n\tconvertPaths(msg, (toDA: boolean, source: PathContainer | undefined) => {\n\t\tif (toDA && source) {\n\t\t\tsource.path = fixPath(source);\n\t\t}\n\t});\n\treturn msg;\n}\n\nexport function convertToVSCPaths(\n\tmessage: DebugProtocol.ProtocolMessage,\n\ttoUri: boolean,\n): DebugProtocol.ProtocolMessage {\n\tconst fixPath = toUri ? stringToUri : uriToString;\n\n\t// since we modify Source.paths in the message in place, we need to make a copy of it (see #61129)\n\tconst msg = deepClone(message);\n\n\tconvertPaths(msg, (toDA: boolean, source: PathContainer | undefined) => {\n\t\tif (!toDA && source) {\n\t\t\tsource.path = fixPath(source);\n\t\t}\n\t});\n\treturn msg;\n}\n\nfunction convertPaths(\n\tmsg: DebugProtocol.ProtocolMessage,\n\tfixSourcePath: (toDA: boolean, source: PathContainer | undefined) => void,\n): void {\n\tswitch (msg.type) {\n\t\tcase \"event\": {\n\t\t\tconst event = <DebugProtocol.Event>msg;\n\t\t\tswitch (event.event) {\n\t\t\t\tcase \"output\":\n\t\t\t\t\tfixSourcePath(\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t(<DebugProtocol.OutputEvent>event).body.source,\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"loadedSource\":\n\t\t\t\t\tfixSourcePath(\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t(<DebugProtocol.LoadedSourceEvent>event).body.source,\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"breakpoint\":\n\t\t\t\t\tfixSourcePath(\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t(<DebugProtocol.BreakpointEvent>event).body.breakpoint\n\t\t\t\t\t\t\t.source,\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase \"request\": {\n\t\t\tconst request = <DebugProtocol.Request>msg;\n\t\t\tswitch (request.command) {\n\t\t\t\tcase \"setBreakpoints\":\n\t\t\t\t\tfixSourcePath(\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t(<DebugProtocol.SetBreakpointsArguments>(\n\t\t\t\t\t\t\trequest.arguments\n\t\t\t\t\t\t)).source,\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"breakpointLocations\":\n\t\t\t\t\tfixSourcePath(\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t(<DebugProtocol.BreakpointLocationsArguments>(\n\t\t\t\t\t\t\trequest.arguments\n\t\t\t\t\t\t)).source,\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"source\":\n\t\t\t\t\tfixSourcePath(\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t(<DebugProtocol.SourceArguments>request.arguments)\n\t\t\t\t\t\t\t.source,\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"gotoTargets\":\n\t\t\t\t\tfixSourcePath(\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t(<DebugProtocol.GotoTargetsArguments>request.arguments)\n\t\t\t\t\t\t\t.source,\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"launchVSCode\":\n\t\t\t\t\trequest.arguments.args.forEach(\n\t\t\t\t\t\t(arg: PathContainer | undefined) =>\n\t\t\t\t\t\t\tfixSourcePath(false, arg),\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase \"response\": {\n\t\t\tconst response = <DebugProtocol.Response>msg;\n\t\t\tif (response.success && response.body) {\n\t\t\t\tswitch (response.command) {\n\t\t\t\t\tcase \"stackTrace\":\n\t\t\t\t\t\t(<DebugProtocol.StackTraceResponse>(\n\t\t\t\t\t\t\tresponse\n\t\t\t\t\t\t)).body.stackFrames.forEach((frame) =>\n\t\t\t\t\t\t\tfixSourcePath(false, frame.source),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"loadedSources\":\n\t\t\t\t\t\t(<DebugProtocol.LoadedSourcesResponse>(\n\t\t\t\t\t\t\tresponse\n\t\t\t\t\t\t)).body.sources.forEach((source) =>\n\t\t\t\t\t\t\tfixSourcePath(false, source),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"scopes\":\n\t\t\t\t\t\t(<DebugProtocol.ScopesResponse>(\n\t\t\t\t\t\t\tresponse\n\t\t\t\t\t\t)).body.scopes.forEach((scope) =>\n\t\t\t\t\t\t\tfixSourcePath(false, scope.source),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"setFunctionBreakpoints\":\n\t\t\t\t\t\t(<DebugProtocol.SetFunctionBreakpointsResponse>(\n\t\t\t\t\t\t\tresponse\n\t\t\t\t\t\t)).body.breakpoints.forEach((bp) =>\n\t\t\t\t\t\t\tfixSourcePath(false, bp.source),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"setBreakpoints\":\n\t\t\t\t\t\t(<DebugProtocol.SetBreakpointsResponse>(\n\t\t\t\t\t\t\tresponse\n\t\t\t\t\t\t)).body.breakpoints.forEach((bp) =>\n\t\t\t\t\t\t\tfixSourcePath(false, bp.source),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"disassemble\":\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst di = <DebugProtocol.DisassembleResponse>(\n\t\t\t\t\t\t\t\tresponse\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tdi.body?.instructions.forEach((di) =>\n\t\t\t\t\t\t\t\tfixSourcePath(false, di.location),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"locations\":\n\t\t\t\t\t\tfixSourcePath(\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t(<DebugProtocol.LocationsResponse>response).body\n\t\t\t\t\t\t\t\t?.source,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nexport function getVisibleAndSorted<\n\tT extends { presentation?: IConfigPresentation },\n>(array: T[]): T[] {\n\treturn array\n\t\t.filter((config) => !config.presentation?.hidden)\n\t\t.sort((first, second) => {\n\t\t\tif (!first.presentation) {\n\t\t\t\tif (!second.presentation) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (!second.presentation) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (!first.presentation.group) {\n\t\t\t\tif (!second.presentation.group) {\n\t\t\t\t\treturn compareOrders(\n\t\t\t\t\t\tfirst.presentation.order,\n\t\t\t\t\t\tsecond.presentation.order,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (!second.presentation.group) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (first.presentation.group !== second.presentation.group) {\n\t\t\t\treturn first.presentation.group.localeCompare(\n\t\t\t\t\tsecond.presentation.group,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn compareOrders(\n\t\t\t\tfirst.presentation.order,\n\t\t\t\tsecond.presentation.order,\n\t\t\t);\n\t\t});\n}\n\nfunction compareOrders(\n\tfirst: number | undefined,\n\tsecond: number | undefined,\n): number {\n\tif (typeof first !== \"number\") {\n\t\tif (typeof second !== \"number\") {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn 1;\n\t}\n\tif (typeof second !== \"number\") {\n\t\treturn -1;\n\t}\n\n\treturn first - second;\n}\n\nexport async function saveAllBeforeDebugStart(\n\tconfigurationService: IConfigurationService,\n\teditorService: IEditorService,\n): Promise<void> {\n\tconst saveBeforeStartConfig: string = configurationService.getValue(\n\t\t\"debug.saveBeforeStart\",\n\t\t{ overrideIdentifier: editorService.activeTextEditorLanguageId },\n\t);\n\tif (saveBeforeStartConfig !== \"none\") {\n\t\tawait editorService.saveAll();\n\t\tif (saveBeforeStartConfig === \"allEditorsInActiveGroup\") {\n\t\t\tconst activeEditor = editorService.activeEditorPane;\n\t\t\tif (\n\t\t\t\tactiveEditor &&\n\t\t\t\tactiveEditor.input.resource?.scheme === Schemas.untitled\n\t\t\t) {\n\t\t\t\t// Make sure to save the active editor in case it is in untitled file it wont be saved as part of saveAll #111850\n\t\t\t\tawait editorService.save({\n\t\t\t\t\teditor: activeEditor.input,\n\t\t\t\t\tgroupId: activeEditor.group.id,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\tawait configurationService.reloadConfiguration();\n}\n\nexport const sourcesEqual = (\n\ta: DebugProtocol.Source | undefined,\n\tb: DebugProtocol.Source | undefined,\n): boolean =>\n\t!a || !b\n\t\t? a === b\n\t\t: a.name === b.name &&\n\t\t\ta.path === b.path &&\n\t\t\ta.sourceReference === b.sourceReference;\n"],
  "mappings": "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",
  "names": ["di"]
}
