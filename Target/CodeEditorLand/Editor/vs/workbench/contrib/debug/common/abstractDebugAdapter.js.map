{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/debug/common/abstractDebugAdapter.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { IDebugAdapter } from './debug.js';\nimport { timeout } from '../../../../base/common/async.js';\nimport { localize } from '../../../../nls.js';\n\n/**\n * Abstract implementation of the low level API for a debug adapter.\n * Missing is how this API communicates with the debug adapter.\n */\nexport abstract class AbstractDebugAdapter implements IDebugAdapter {\n\tprivate sequence: number;\n\tprivate pendingRequests = new Map<number, (e: DebugProtocol.Response) => void>();\n\tprivate requestCallback: ((request: DebugProtocol.Request) => void) | undefined;\n\tprivate eventCallback: ((request: DebugProtocol.Event) => void) | undefined;\n\tprivate messageCallback: ((message: DebugProtocol.ProtocolMessage) => void) | undefined;\n\tprivate queue: DebugProtocol.ProtocolMessage[] = [];\n\tprotected readonly _onError = new Emitter<Error>();\n\tprotected readonly _onExit = new Emitter<number | null>();\n\n\tconstructor() {\n\t\tthis.sequence = 1;\n\t}\n\n\tabstract startSession(): Promise<void>;\n\n\tabstract stopSession(): Promise<void>;\n\n\tabstract sendMessage(message: DebugProtocol.ProtocolMessage): void;\n\n\tget onError(): Event<Error> {\n\t\treturn this._onError.event;\n\t}\n\n\tget onExit(): Event<number | null> {\n\t\treturn this._onExit.event;\n\t}\n\n\tonMessage(callback: (message: DebugProtocol.ProtocolMessage) => void): void {\n\t\tif (this.messageCallback) {\n\t\t\tthis._onError.fire(new Error(`attempt to set more than one 'Message' callback`));\n\t\t}\n\t\tthis.messageCallback = callback;\n\t}\n\n\tonEvent(callback: (event: DebugProtocol.Event) => void): void {\n\t\tif (this.eventCallback) {\n\t\t\tthis._onError.fire(new Error(`attempt to set more than one 'Event' callback`));\n\t\t}\n\t\tthis.eventCallback = callback;\n\t}\n\n\tonRequest(callback: (request: DebugProtocol.Request) => void): void {\n\t\tif (this.requestCallback) {\n\t\t\tthis._onError.fire(new Error(`attempt to set more than one 'Request' callback`));\n\t\t}\n\t\tthis.requestCallback = callback;\n\t}\n\n\tsendResponse(response: DebugProtocol.Response): void {\n\t\tif (response.seq > 0) {\n\t\t\tthis._onError.fire(new Error(`attempt to send more than one response for command ${response.command}`));\n\t\t} else {\n\t\t\tthis.internalSend('response', response);\n\t\t}\n\t}\n\n\tsendRequest(command: string, args: any, clb: (result: DebugProtocol.Response) => void, timeout?: number): number {\n\t\tconst request: any = {\n\t\t\tcommand: command\n\t\t};\n\t\tif (args && Object.keys(args).length > 0) {\n\t\t\trequest.arguments = args;\n\t\t}\n\t\tthis.internalSend('request', request);\n\t\tif (typeof timeout === 'number') {\n\t\t\tconst timer = setTimeout(() => {\n\t\t\t\tclearTimeout(timer);\n\t\t\t\tconst clb = this.pendingRequests.get(request.seq);\n\t\t\t\tif (clb) {\n\t\t\t\t\tthis.pendingRequests.delete(request.seq);\n\t\t\t\t\tconst err: DebugProtocol.Response = {\n\t\t\t\t\t\ttype: 'response',\n\t\t\t\t\t\tseq: 0,\n\t\t\t\t\t\trequest_seq: request.seq,\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\tcommand,\n\t\t\t\t\t\tmessage: localize('timeout', \"Timeout after {0} ms for '{1}'\", timeout, command)\n\t\t\t\t\t};\n\t\t\t\t\tclb(err);\n\t\t\t\t}\n\t\t\t}, timeout);\n\t\t}\n\t\tif (clb) {\n\t\t\t// store callback for this request\n\t\t\tthis.pendingRequests.set(request.seq, clb);\n\t\t}\n\n\t\treturn request.seq;\n\t}\n\n\tacceptMessage(message: DebugProtocol.ProtocolMessage): void {\n\t\tif (this.messageCallback) {\n\t\t\tthis.messageCallback(message);\n\t\t} else {\n\t\t\tthis.queue.push(message);\n\t\t\tif (this.queue.length === 1) {\n\t\t\t\t// first item = need to start processing loop\n\t\t\t\tthis.processQueue();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns whether we should insert a timeout between processing messageA\n\t * and messageB. Artificially queueing protocol messages guarantees that any\n\t * microtasks for previous message finish before next message is processed.\n\t * This is essential ordering when using promises anywhere along the call path.\n\t *\n\t * For example, take the following, where `chooseAndSendGreeting` returns\n\t * a person name and then emits a greeting event:\n\t *\n\t * ```\n\t * let person: string;\n\t * adapter.onGreeting(() => console.log('hello', person));\n\t * person = await adapter.chooseAndSendGreeting();\n\t * ```\n\t *\n\t * Because the event is dispatched synchronously, it may fire before person\n\t * is assigned if they're processed in the same task. Inserting a task\n\t * boundary avoids this issue.\n\t */\n\tprotected needsTaskBoundaryBetween(messageA: DebugProtocol.ProtocolMessage, messageB: DebugProtocol.ProtocolMessage) {\n\t\treturn messageA.type !== 'event' || messageB.type !== 'event';\n\t}\n\n\t/**\n\t * Reads and dispatches items from the queue until it is empty.\n\t */\n\tprivate async processQueue() {\n\t\tlet message: DebugProtocol.ProtocolMessage | undefined;\n\t\twhile (this.queue.length) {\n\t\t\tif (!message || this.needsTaskBoundaryBetween(this.queue[0], message)) {\n\t\t\t\tawait timeout(0);\n\t\t\t}\n\n\t\t\tmessage = this.queue.shift();\n\t\t\tif (!message) {\n\t\t\t\treturn; // may have been disposed of\n\t\t\t}\n\n\t\t\tswitch (message.type) {\n\t\t\t\tcase 'event':\n\t\t\t\t\tthis.eventCallback?.(<DebugProtocol.Event>message);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'request':\n\t\t\t\t\tthis.requestCallback?.(<DebugProtocol.Request>message);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'response': {\n\t\t\t\t\tconst response = <DebugProtocol.Response>message;\n\t\t\t\t\tconst clb = this.pendingRequests.get(response.request_seq);\n\t\t\t\t\tif (clb) {\n\t\t\t\t\t\tthis.pendingRequests.delete(response.request_seq);\n\t\t\t\t\t\tclb(response);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate internalSend(typ: 'request' | 'response' | 'event', message: DebugProtocol.ProtocolMessage): void {\n\t\tmessage.type = typ;\n\t\tmessage.seq = this.sequence++;\n\t\tthis.sendMessage(message);\n\t}\n\n\tprotected async cancelPendingRequests(): Promise<void> {\n\t\tif (this.pendingRequests.size === 0) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\tconst pending = new Map<number, (e: DebugProtocol.Response) => void>();\n\t\tthis.pendingRequests.forEach((value, key) => pending.set(key, value));\n\t\tawait timeout(500);\n\t\tpending.forEach((callback, request_seq) => {\n\t\t\tconst err: DebugProtocol.Response = {\n\t\t\t\ttype: 'response',\n\t\t\t\tseq: 0,\n\t\t\t\trequest_seq,\n\t\t\t\tsuccess: false,\n\t\t\t\tcommand: 'canceled',\n\t\t\t\tmessage: 'canceled'\n\t\t\t};\n\t\t\tcallback(err);\n\t\t\tthis.pendingRequests.delete(request_seq);\n\t\t});\n\t}\n\n\tgetPendingRequestIds(): number[] {\n\t\treturn Array.from(this.pendingRequests.keys());\n\t}\n\n\tdispose(): void {\n\t\tthis.queue = [];\n\t}\n}\n"],
  "mappings": "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",
  "names": ["timeout", "clb"]
}
