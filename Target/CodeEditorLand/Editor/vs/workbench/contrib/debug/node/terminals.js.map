{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/debug/node/terminals.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as cp from 'child_process';\nimport { getDriveLetter } from '../../../../base/common/extpath.js';\nimport * as platform from '../../../../base/common/platform.js';\n\nfunction spawnAsPromised(command: string, args: string[]): Promise<string> {\n\treturn new Promise((resolve, reject) => {\n\t\tlet stdout = '';\n\t\tconst child = cp.spawn(command, args);\n\t\tif (child.pid) {\n\t\t\tchild.stdout.on('data', (data: Buffer) => {\n\t\t\t\tstdout += data.toString();\n\t\t\t});\n\t\t}\n\t\tchild.on('error', err => {\n\t\t\treject(err);\n\t\t});\n\t\tchild.on('close', code => {\n\t\t\tresolve(stdout);\n\t\t});\n\t});\n}\n\nexport async function hasChildProcesses(processId: number | undefined): Promise<boolean> {\n\tif (processId) {\n\n\t\t// if shell has at least one child process, assume that shell is busy\n\t\tif (platform.isWindows) {\n\t\t\tconst windowsProcessTree = await import('@vscode/windows-process-tree');\n\t\t\treturn new Promise<boolean>(resolve => {\n\t\t\t\twindowsProcessTree.getProcessTree(processId, processTree => {\n\t\t\t\t\tresolve(!!processTree && processTree.children.length > 0);\n\t\t\t\t});\n\t\t\t});\n\t\t} else {\n\t\t\treturn spawnAsPromised('/usr/bin/pgrep', ['-lP', String(processId)]).then(stdout => {\n\t\t\t\tconst r = stdout.trim();\n\t\t\t\tif (r.length === 0 || r.indexOf(' tmux') >= 0) { // ignore 'tmux'; see #43683\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}, error => {\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\t}\n\t// fall back to safe side\n\treturn Promise.resolve(true);\n}\n\nconst enum ShellType { cmd, powershell, bash }\n\n\nexport function prepareCommand(shell: string, args: string[], argsCanBeInterpretedByShell: boolean, cwd?: string, env?: { [key: string]: string | null }): string {\n\n\tshell = shell.trim().toLowerCase();\n\n\t// try to determine the shell type\n\tlet shellType;\n\tif (shell.indexOf('powershell') >= 0 || shell.indexOf('pwsh') >= 0) {\n\t\tshellType = ShellType.powershell;\n\t} else if (shell.indexOf('cmd.exe') >= 0) {\n\t\tshellType = ShellType.cmd;\n\t} else if (shell.indexOf('bash') >= 0) {\n\t\tshellType = ShellType.bash;\n\t} else if (platform.isWindows) {\n\t\tshellType = ShellType.cmd; // pick a good default for Windows\n\t} else {\n\t\tshellType = ShellType.bash;\t// pick a good default for anything else\n\t}\n\n\tlet quote: (s: string) => string;\n\t// begin command with a space to avoid polluting shell history\n\tlet command = ' ';\n\n\tswitch (shellType) {\n\n\t\tcase ShellType.powershell:\n\n\t\t\tquote = (s: string) => {\n\t\t\t\ts = s.replace(/\\'/g, '\\'\\'');\n\t\t\t\tif (s.length > 0 && s.charAt(s.length - 1) === '\\\\') {\n\t\t\t\t\treturn `'${s}\\\\'`;\n\t\t\t\t}\n\t\t\t\treturn `'${s}'`;\n\t\t\t};\n\n\t\t\tif (cwd) {\n\t\t\t\tconst driveLetter = getDriveLetter(cwd);\n\t\t\t\tif (driveLetter) {\n\t\t\t\t\tcommand += `${driveLetter}:; `;\n\t\t\t\t}\n\t\t\t\tcommand += `cd ${quote(cwd)}; `;\n\t\t\t}\n\t\t\tif (env) {\n\t\t\t\tfor (const key in env) {\n\t\t\t\t\tconst value = env[key];\n\t\t\t\t\tif (value === null) {\n\t\t\t\t\t\tcommand += `Remove-Item env:${key}; `;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcommand += `\\${env:${key}}='${value}'; `;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (args.length > 0) {\n\t\t\t\tconst arg = args.shift()!;\n\t\t\t\tconst cmd = argsCanBeInterpretedByShell ? arg : quote(arg);\n\t\t\t\tcommand += (cmd[0] === '\\'') ? `& ${cmd} ` : `${cmd} `;\n\t\t\t\tfor (const a of args) {\n\t\t\t\t\tcommand += (a === '<' || a === '>' || argsCanBeInterpretedByShell) ? a : quote(a);\n\t\t\t\t\tcommand += ' ';\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ShellType.cmd:\n\n\t\t\tquote = (s: string) => {\n\t\t\t\t// Note: Wrapping in cmd /C \"...\" complicates the escaping.\n\t\t\t\t// cmd /C \"node -e \"console.log(process.argv)\" \"\"\"A^>0\"\"\"\" # prints \"A>0\"\n\t\t\t\t// cmd /C \"node -e \"console.log(process.argv)\" \"foo^> bar\"\" # prints foo> bar\n\t\t\t\t// Outside of the cmd /C, it could be a simple quoting, but here, the ^ is needed too\n\t\t\t\ts = s.replace(/\\\"/g, '\"\"');\n\t\t\t\ts = s.replace(/([><!^&|])/g, '^$1');\n\t\t\t\treturn (' \"'.split('').some(char => s.includes(char)) || s.length === 0) ? `\"${s}\"` : s;\n\t\t\t};\n\n\t\t\tif (cwd) {\n\t\t\t\tconst driveLetter = getDriveLetter(cwd);\n\t\t\t\tif (driveLetter) {\n\t\t\t\t\tcommand += `${driveLetter}: && `;\n\t\t\t\t}\n\t\t\t\tcommand += `cd ${quote(cwd)} && `;\n\t\t\t}\n\t\t\tif (env) {\n\t\t\t\tcommand += 'cmd /C \"';\n\t\t\t\tfor (const key in env) {\n\t\t\t\t\tlet value = env[key];\n\t\t\t\t\tif (value === null) {\n\t\t\t\t\t\tcommand += `set \"${key}=\" && `;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalue = value.replace(/[&^|<>]/g, s => `^${s}`);\n\t\t\t\t\t\tcommand += `set \"${key}=${value}\" && `;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const a of args) {\n\t\t\t\tcommand += (a === '<' || a === '>' || argsCanBeInterpretedByShell) ? a : quote(a);\n\t\t\t\tcommand += ' ';\n\t\t\t}\n\t\t\tif (env) {\n\t\t\t\tcommand += '\"';\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ShellType.bash: {\n\n\t\t\tquote = (s: string) => {\n\t\t\t\ts = s.replace(/([\"'\\\\\\$!><#()\\[\\]*&^| ;{}?`])/g, '\\\\$1');\n\t\t\t\treturn s.length === 0 ? `\"\"` : s;\n\t\t\t};\n\n\t\t\tconst hardQuote = (s: string) => {\n\t\t\t\treturn /[^\\w@%\\/+=,.:^-]/.test(s) ? `'${s.replace(/'/g, '\\'\\\\\\'\\'')}'` : s;\n\t\t\t};\n\n\t\t\tif (cwd) {\n\t\t\t\tcommand += `cd ${quote(cwd)} ; `;\n\t\t\t}\n\t\t\tif (env) {\n\t\t\t\tcommand += '/usr/bin/env';\n\t\t\t\tfor (const key in env) {\n\t\t\t\t\tconst value = env[key];\n\t\t\t\t\tif (value === null) {\n\t\t\t\t\t\tcommand += ` -u ${hardQuote(key)}`;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcommand += ` ${hardQuote(`${key}=${value}`)}`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcommand += ' ';\n\t\t\t}\n\t\t\tfor (const a of args) {\n\t\t\t\tcommand += (a === '<' || a === '>' || argsCanBeInterpretedByShell) ? a : quote(a);\n\t\t\t\tcommand += ' ';\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn command;\n}\n"],
  "mappings": "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",
  "names": ["ShellType"]
}
