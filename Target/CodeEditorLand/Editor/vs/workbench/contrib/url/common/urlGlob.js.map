{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/url/common/urlGlob.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from '../../../../base/common/uri.js';\n\n// TODO: rewrite this to use URIs directly and validate each part individually\n// instead of relying on memoization of the stringified URI.\nexport const testUrlMatchesGlob = (uri: URI, globUrl: string): boolean => {\n\tlet url = uri.with({ query: null, fragment: null }).toString(true);\n\tconst normalize = (url: string) => url.replace(/\\/+$/, '');\n\tglobUrl = normalize(globUrl);\n\turl = normalize(url);\n\n\tconst memo = Array.from({ length: url.length + 1 }).map(() =>\n\t\tArray.from({ length: globUrl.length + 1 }).map(() => undefined),\n\t);\n\n\tif (/^[^./:]*:\\/\\//.test(globUrl)) {\n\t\treturn doUrlMatch(memo, url, globUrl, 0, 0);\n\t}\n\n\tconst scheme = /^(https?):\\/\\//.exec(url)?.[1];\n\tif (scheme) {\n\t\treturn doUrlMatch(memo, url, `${scheme}://${globUrl}`, 0, 0);\n\t}\n\n\treturn false;\n};\n\nconst doUrlMatch = (\n\tmemo: (boolean | undefined)[][],\n\turl: string,\n\tglobUrl: string,\n\turlOffset: number,\n\tglobUrlOffset: number,\n): boolean => {\n\tif (memo[urlOffset]?.[globUrlOffset] !== undefined) {\n\t\treturn memo[urlOffset][globUrlOffset]!;\n\t}\n\n\tconst options = [];\n\n\t// Endgame.\n\t// Fully exact match\n\tif (urlOffset === url.length) {\n\t\treturn globUrlOffset === globUrl.length;\n\t}\n\n\t// Some path remaining in url\n\tif (globUrlOffset === globUrl.length) {\n\t\tconst remaining = url.slice(urlOffset);\n\t\treturn remaining[0] === '/';\n\t}\n\n\tif (url[urlOffset] === globUrl[globUrlOffset]) {\n\t\t// Exact match.\n\t\toptions.push(doUrlMatch(memo, url, globUrl, urlOffset + 1, globUrlOffset + 1));\n\t}\n\n\tif (globUrl[globUrlOffset] + globUrl[globUrlOffset + 1] === '*.') {\n\t\t// Any subdomain match. Either consume one thing that's not a / or : and don't advance base or consume nothing and do.\n\t\tif (!['/', ':'].includes(url[urlOffset])) {\n\t\t\toptions.push(doUrlMatch(memo, url, globUrl, urlOffset + 1, globUrlOffset));\n\t\t}\n\t\toptions.push(doUrlMatch(memo, url, globUrl, urlOffset, globUrlOffset + 2));\n\t}\n\n\tif (globUrl[globUrlOffset] === '*') {\n\t\t// Any match. Either consume one thing and don't advance base or consume nothing and do.\n\t\tif (urlOffset + 1 === url.length) {\n\t\t\t// If we're at the end of the input url consume one from both.\n\t\t\toptions.push(doUrlMatch(memo, url, globUrl, urlOffset + 1, globUrlOffset + 1));\n\t\t} else {\n\t\t\toptions.push(doUrlMatch(memo, url, globUrl, urlOffset + 1, globUrlOffset));\n\t\t}\n\t\toptions.push(doUrlMatch(memo, url, globUrl, urlOffset, globUrlOffset + 1));\n\t}\n\n\tif (globUrl[globUrlOffset] + globUrl[globUrlOffset + 1] === ':*') {\n\t\t// any port match. Consume a port if it exists otherwise nothing. Always comsume the base.\n\t\tif (url[urlOffset] === ':') {\n\t\t\tlet endPortIndex = urlOffset + 1;\n\t\t\tdo { endPortIndex++; } while (/[0-9]/.test(url[endPortIndex]));\n\t\t\toptions.push(doUrlMatch(memo, url, globUrl, endPortIndex, globUrlOffset + 2));\n\t\t} else {\n\t\t\toptions.push(doUrlMatch(memo, url, globUrl, urlOffset, globUrlOffset + 2));\n\t\t}\n\t}\n\n\treturn (memo[urlOffset][globUrlOffset] = options.some(a => a === true));\n};\n"],
  "mappings": ";;AAKA,SAAS,WAAW;AAIb,MAAM,qBAAqB,wBAAC,KAAU,YAA6B;AACzE,MAAI,MAAM,IAAI,KAAK,EAAE,OAAO,MAAM,UAAU,KAAK,CAAC,EAAE,SAAS,IAAI;AACjE,QAAM,YAAY,wBAACA,SAAgBA,KAAI,QAAQ,QAAQ,EAAE,GAAvC;AAClB,YAAU,UAAU,OAAO;AAC3B,QAAM,UAAU,GAAG;AAEnB,QAAM,OAAO,MAAM,KAAK,EAAE,QAAQ,IAAI,SAAS,EAAE,CAAC,EAAE;AAAA,IAAI,MACvD,MAAM,KAAK,EAAE,QAAQ,QAAQ,SAAS,EAAE,CAAC,EAAE,IAAI,MAAM,MAAS;AAAA,EAC/D;AAEA,MAAI,gBAAgB,KAAK,OAAO,GAAG;AAClC,WAAO,WAAW,MAAM,KAAK,SAAS,GAAG,CAAC;AAAA,EAC3C;AAEA,QAAM,SAAS,iBAAiB,KAAK,GAAG,IAAI,CAAC;AAC7C,MAAI,QAAQ;AACX,WAAO,WAAW,MAAM,KAAK,GAAG,MAAM,MAAM,OAAO,IAAI,GAAG,CAAC;AAAA,EAC5D;AAEA,SAAO;AACR,GApBkC;AAsBlC,MAAM,aAAa,wBAClB,MACA,KACA,SACA,WACA,kBACa;AACb,MAAI,KAAK,SAAS,IAAI,aAAa,MAAM,QAAW;AACnD,WAAO,KAAK,SAAS,EAAE,aAAa;AAAA,EACrC;AAEA,QAAM,UAAU,CAAC;AAIjB,MAAI,cAAc,IAAI,QAAQ;AAC7B,WAAO,kBAAkB,QAAQ;AAAA,EAClC;AAGA,MAAI,kBAAkB,QAAQ,QAAQ;AACrC,UAAM,YAAY,IAAI,MAAM,SAAS;AACrC,WAAO,UAAU,CAAC,MAAM;AAAA,EACzB;AAEA,MAAI,IAAI,SAAS,MAAM,QAAQ,aAAa,GAAG;AAE9C,YAAQ,KAAK,WAAW,MAAM,KAAK,SAAS,YAAY,GAAG,gBAAgB,CAAC,CAAC;AAAA,EAC9E;AAEA,MAAI,QAAQ,aAAa,IAAI,QAAQ,gBAAgB,CAAC,MAAM,MAAM;AAEjE,QAAI,CAAC,CAAC,KAAK,GAAG,EAAE,SAAS,IAAI,SAAS,CAAC,GAAG;AACzC,cAAQ,KAAK,WAAW,MAAM,KAAK,SAAS,YAAY,GAAG,aAAa,CAAC;AAAA,IAC1E;AACA,YAAQ,KAAK,WAAW,MAAM,KAAK,SAAS,WAAW,gBAAgB,CAAC,CAAC;AAAA,EAC1E;AAEA,MAAI,QAAQ,aAAa,MAAM,KAAK;AAEnC,QAAI,YAAY,MAAM,IAAI,QAAQ;AAEjC,cAAQ,KAAK,WAAW,MAAM,KAAK,SAAS,YAAY,GAAG,gBAAgB,CAAC,CAAC;AAAA,IAC9E,OAAO;AACN,cAAQ,KAAK,WAAW,MAAM,KAAK,SAAS,YAAY,GAAG,aAAa,CAAC;AAAA,IAC1E;AACA,YAAQ,KAAK,WAAW,MAAM,KAAK,SAAS,WAAW,gBAAgB,CAAC,CAAC;AAAA,EAC1E;AAEA,MAAI,QAAQ,aAAa,IAAI,QAAQ,gBAAgB,CAAC,MAAM,MAAM;AAEjE,QAAI,IAAI,SAAS,MAAM,KAAK;AAC3B,UAAI,eAAe,YAAY;AAC/B,SAAG;AAAE;AAAA,MAAgB,SAAS,QAAQ,KAAK,IAAI,YAAY,CAAC;AAC5D,cAAQ,KAAK,WAAW,MAAM,KAAK,SAAS,cAAc,gBAAgB,CAAC,CAAC;AAAA,IAC7E,OAAO;AACN,cAAQ,KAAK,WAAW,MAAM,KAAK,SAAS,WAAW,gBAAgB,CAAC,CAAC;AAAA,IAC1E;AAAA,EACD;AAEA,SAAQ,KAAK,SAAS,EAAE,aAAa,IAAI,QAAQ,KAAK,OAAK,MAAM,IAAI;AACtE,GA7DmB;",
  "names": ["url"]
}
