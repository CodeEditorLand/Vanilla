var j=Object.defineProperty;var U=Object.getOwnPropertyDescriptor;var L=(I,l,t,n)=>{for(var e=n>1?void 0:n?U(l,t):l,o=I.length-1,i;o>=0;o--)(i=I[o])&&(e=(n?i(l,t,e):i(e))||e);return n&&e&&j(l,t,e),e},d=(I,l)=>(t,n)=>l(t,n,I);import{distinct as N}from"../../../../base/common/arrays.js";import{disposableTimeout as P}from"../../../../base/common/async.js";import"../../../../base/common/collections.js";import{match as J}from"../../../../base/common/glob.js";import{DisposableStore as _}from"../../../../base/common/lifecycle.js";import{Schemas as v}from"../../../../base/common/network.js";import"../../../../base/common/product.js";import{basename as z,extname as K}from"../../../../base/common/resources.js";import{isEmptyObject as H}from"../../../../base/common/types.js";import"../../../../base/common/uri.js";import{ILanguageService as X}from"../../../../editor/common/languages/language.js";import{PLAINTEXT_LANGUAGE_ID as D}from"../../../../editor/common/languages/modesRegistry.js";import"../../../../editor/common/model.js";import{IModelService as q}from"../../../../editor/common/services/model.js";import{localize as B}from"../../../../nls.js";import{areSameExtensions as T}from"../../../../platform/extensionManagement/common/extensionManagementUtil.js";import{IExtensionRecommendationNotificationService as Q,RecommendationsNotificationResult as V,RecommendationSource as Y}from"../../../../platform/extensionRecommendations/common/extensionRecommendations.js";import{IProductService as Z}from"../../../../platform/product/common/productService.js";import{IStorageService as $,StorageScope as y,StorageTarget as A}from"../../../../platform/storage/common/storage.js";import{IWorkspaceContextService as ee}from"../../../../platform/workspace/common/workspace.js";import{EnablementState as te}from"../../../services/extensionManagement/common/extensionManagement.js";import{ExtensionRecommendationReason as ne,IExtensionIgnoredRecommendationsService as oe}from"../../../services/extensionRecommendations/common/extensionRecommendations.js";import{CellUri as ie}from"../../notebook/common/notebookCommon.js";import{IExtensionsWorkbenchService as re}from"../common/extensions.js";import{ExtensionRecommendations as se}from"./extensionRecommendations.js";const M="fileBasedRecommendations/promptedRecommendations",k="extensionsAssistant/recommendations",ae=1e3*60*60*24;let x=class extends se{constructor(t,n,e,o,i,p,f,g){super();this.extensionsWorkbenchService=t;this.modelService=n;this.languageService=e;this.storageService=i;this.extensionRecommendationNotificationService=p;this.extensionIgnoredRecommendationsService=f;this.workspaceContextService=g;if(this.fileOpenRecommendations={},o.extensionRecommendations)for(const[s,a]of Object.entries(o.extensionRecommendations))a.onFileOpen&&(this.fileOpenRecommendations[s.toLowerCase()]=a.onFileOpen)}fileOpenRecommendations;recommendationsByPattern=new Map;fileBasedRecommendations=new Map;fileBasedImportantRecommendations=new Set;get recommendations(){const t=[];return[...this.fileBasedRecommendations.keys()].sort((n,e)=>{if(this.fileBasedRecommendations.get(n).recommendedTime===this.fileBasedRecommendations.get(e).recommendedTime){if(this.fileBasedImportantRecommendations.has(n))return-1;if(this.fileBasedImportantRecommendations.has(e))return 1}return this.fileBasedRecommendations.get(n).recommendedTime>this.fileBasedRecommendations.get(e).recommendedTime?-1:1}).forEach(n=>{t.push({extension:n,reason:{reasonId:ne.File,reasonText:B("fileBasedRecommendation","This extension is recommended based on the files you recently opened.")}})}),t}get importantRecommendations(){return this.recommendations.filter(t=>this.fileBasedImportantRecommendations.has(t.extension))}get otherRecommendations(){return this.recommendations.filter(t=>!this.fileBasedImportantRecommendations.has(t.extension))}async doActivate(){if(H(this.fileOpenRecommendations))return;await this.extensionsWorkbenchService.whenInitialized;const t=this.getCachedRecommendations(),n=Date.now();Object.entries(t).forEach(([e,o])=>{(n-o)/ae<=7&&this.fileOpenRecommendations[e]&&this.fileBasedRecommendations.set(e.toLowerCase(),{recommendedTime:o})}),this._register(this.modelService.onModelAdded(e=>this.onModelAdded(e))),this.modelService.getModels().forEach(e=>this.onModelAdded(e))}onModelAdded(t){const n=t.uri.scheme===v.vscodeNotebookCell?ie.parse(t.uri)?.notebook:t.uri;if(!n)return;const e=N([v.untitled,v.file,v.vscodeRemote,...this.workspaceContextService.getWorkspace().folders.map(o=>o.uri.scheme)]);!n||!e.includes(n.scheme)||P(()=>this.promptImportantRecommendations(n,t),0,this._store)}promptImportantRecommendations(t,n,e){if(n.isDisposed())return;const o=K(t).toLowerCase();e=e??this.recommendationsByPattern.get(o)??this.fileOpenRecommendations;const i=Object.entries(e);if(i.length===0)return;const p=new Map,f=this.extensionsWorkbenchService.local,g={},s={},a={};let R=!1;const G=n.getLanguageId();for(const[m,W]of i){const u=[],C=[],E=[];for(const r of W){let w=!1,O=!1;const S=!!r.languages,b=!!r.contentPattern;if((S||b)&&u.push(r),S&&r.languages.includes(G)&&(w=!0),r.pathGlob){const h=r.pathGlob;(p.get(h)??J(r.pathGlob,t.with({fragment:""}).toString()))&&(O=!0),p.set(h,O)}let c=w||O;o&&!c||(c&&r.whenInstalled&&(r.whenInstalled.every(h=>f.some(F=>T({id:h},F.identifier)))||(c=!1)),c&&r.whenNotInstalled&&f.some(h=>r.whenNotInstalled?.some(F=>T({id:F},h.identifier)))&&(c=!1),c&&b&&(n.findMatches(r.contentPattern,!1,!0,!1,null,!1).length||(c=!1)),c?(C.push(r),u.pop()):(S||b)&&(E.push(r),S&&(R=!0)))}C.length&&(s[m]=C),E.length&&(a[m]=E),u.length&&(g[m]=u)}if(o&&this.recommendationsByPattern.set(o,g),Object.keys(a).length&&R){const m=new _;m.add(n.onDidChangeLanguage(()=>{P(()=>{m.isDisposed||(this.promptImportantRecommendations(t,n,a),m.dispose())},0,m)})),m.add(n.onWillDispose(()=>m.dispose()))}Object.keys(s).length&&this.promptFromRecommendations(t,n,s)}promptFromRecommendations(t,n,e){let o=!1;const i=new Set,p=new Set;for(const[s,a]of Object.entries(e))for(const R of a)p.add(s),R.important&&(i.add(s),this.fileBasedImportantRecommendations.add(s)),R.languages&&(o=!0);for(const s of p){const a=this.fileBasedRecommendations.get(s)||{recommendedTime:Date.now(),sources:[]};a.recommendedTime=Date.now(),this.fileBasedRecommendations.set(s,a)}if(this.storeCachedRecommendations(),this.extensionRecommendationNotificationService.hasToIgnoreRecommendationNotifications())return;const f=n.getLanguageId(),g=this.languageService.getLanguageName(f);i.size&&this.promptRecommendedExtensionForFileType(g&&o&&f!==D?B("languageName","the {0} language",g):z(t),f,[...i])}promptRecommendedExtensionForFileType(t,n,e){if(e=this.filterIgnoredOrNotAllowed(e),e.length===0)return!1;e=this.filterInstalled(e,this.extensionsWorkbenchService.local).filter(i=>this.fileBasedImportantRecommendations.has(i));const o=n!==D?this.getPromptedRecommendations()[n]:void 0;return o&&(e=e.filter(i=>o.includes(i))),e.length===0?!1:(this.promptImportantExtensionsInstallNotification(e,t,n),!0)}async promptImportantExtensionsInstallNotification(t,n,e){try{await this.extensionRecommendationNotificationService.promptImportantExtensionsInstallNotification({extensions:t,name:n,source:Y.FILE})===V.Accepted&&this.addToPromptedRecommendations(e,t)}catch{}}getPromptedRecommendations(){return JSON.parse(this.storageService.get(M,y.PROFILE,"{}"))}addToPromptedRecommendations(t,n){const e=this.getPromptedRecommendations();e[t]=N([...e[t]??[],...n]),this.storageService.store(M,JSON.stringify(e),y.PROFILE,A.USER)}filterIgnoredOrNotAllowed(t){const n=[...this.extensionIgnoredRecommendationsService.ignoredRecommendations,...this.extensionRecommendationNotificationService.ignoredRecommendations];return t.filter(e=>!n.includes(e))}filterInstalled(t,n){const e=n.reduce((o,i)=>(i.enablementState!==te.DisabledByExtensionKind&&o.add(i.identifier.id.toLowerCase()),o),new Set);return t.filter(o=>!e.has(o.toLowerCase()))}getCachedRecommendations(){let t=JSON.parse(this.storageService.get(k,y.PROFILE,"[]"));Array.isArray(t)&&(t=t.reduce((e,o)=>(e[o]=Date.now(),e),{}));const n={};return Object.entries(t).forEach(([e,o])=>{typeof o=="number"&&(n[e.toLowerCase()]=o)}),n}storeCachedRecommendations(){const t={};this.fileBasedRecommendations.forEach((n,e)=>t[e]=n.recommendedTime),this.storageService.store(k,JSON.stringify(t),y.PROFILE,A.MACHINE)}};x=L([d(0,re),d(1,q),d(2,X),d(3,Z),d(4,$),d(5,Q),d(6,oe),d(7,ee)],x);export{x as FileBasedRecommendations};
