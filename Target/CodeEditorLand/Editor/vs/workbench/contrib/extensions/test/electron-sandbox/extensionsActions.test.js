import a from"assert";import{generateUuid as te}from"../../../../../base/common/uuid.js";import{IExtensionsWorkbenchService as c,ExtensionContainers as x}from"../../common/extensions.js";import*as d from"../../browser/extensionsActions.js";import{ExtensionsWorkbenchService as p}from"../../browser/extensionsWorkbenchService.js";import{IExtensionManagementService as h,IExtensionGalleryService as b,InstallOperation as W,IExtensionTipsService as se,getTargetPlatform as B}from"../../../../../platform/extensionManagement/common/extensionManagement.js";import{IWorkbenchExtensionEnablementService as I,EnablementState as L,IExtensionManagementServerService as k,ExtensionInstallLocation as F,IWorkbenchExtensionManagementService as ie}from"../../../../services/extensionManagement/common/extensionManagement.js";import{IExtensionRecommendationsService as oe}from"../../../../services/extensionRecommendations/common/extensionRecommendations.js";import{getGalleryExtensionId as X}from"../../../../../platform/extensionManagement/common/extensionManagementUtil.js";import{TestExtensionEnablementService as S}from"../../../../services/extensionManagement/test/browser/extensionEnablementService.test.js";import{ExtensionGalleryService as ae}from"../../../../../platform/extensionManagement/common/extensionGalleryService.js";import{IURLService as le}from"../../../../../platform/url/common/url.js";import{TestInstantiationService as re}from"../../../../../platform/instantiation/test/common/instantiationServiceMock.js";import{Emitter as M,Event as q}from"../../../../../base/common/event.js";import"../../../../../base/common/paging.js";import{ITelemetryService as ce}from"../../../../../platform/telemetry/common/telemetry.js";import{NullTelemetryService as de}from"../../../../../platform/telemetry/common/telemetryUtils.js";import{IExtensionService as R,toExtensionDescription as T}from"../../../../services/extensions/common/extensions.js";import{IWorkspaceContextService as ue}from"../../../../../platform/workspace/common/workspace.js";import{TestContextService as xe,TestWorkspaceTrustManagementService as be}from"../../../../test/common/workbenchTestServices.js";import{TestExtensionTipsService as me,TestSharedProcessService as Ee}from"../../../../test/electron-sandbox/workbenchTestServices.js";import{IConfigurationService as Ie}from"../../../../../platform/configuration/common/configuration.js";import{ILogService as fe,NullLogService as Y}from"../../../../../platform/log/common/log.js";import{NativeURLService as ge}from"../../../../../platform/url/common/urlService.js";import{URI as g}from"../../../../../base/common/uri.js";import{TestConfigurationService as ve}from"../../../../../platform/configuration/test/common/testConfigurationService.js";import{IRemoteAgentService as we}from"../../../../services/remote/common/remoteAgentService.js";import{RemoteAgentService as ye}from"../../../../services/remote/electron-sandbox/remoteAgentService.js";import{ExtensionType as K}from"../../../../../platform/extensions/common/extensions.js";import{ISharedProcessService as he}from"../../../../../platform/ipc/electron-sandbox/services.js";import{CancellationToken as y}from"../../../../../base/common/cancellation.js";import{ILabelService as pe}from"../../../../../platform/label/common/label.js";import{IProductService as Se}from"../../../../../platform/product/common/productService.js";import{Schemas as D}from"../../../../../base/common/network.js";import{IProgressService as ke}from"../../../../../platform/progress/common/progress.js";import{ProgressService as Ae}from"../../../../services/progress/browser/progressService.js";import{ILifecycleService as qe}from"../../../../services/lifecycle/common/lifecycle.js";import{TestEnvironmentService as Z,TestLifecycleService as Pe}from"../../../../test/browser/workbenchTestServices.js";import"../../../../../base/common/lifecycle.js";import{INativeWorkbenchEnvironmentService as ee}from"../../../../services/environment/electron-sandbox/environmentService.js";import{IWorkbenchEnvironmentService as _}from"../../../../services/environment/common/environmentService.js";import{IUserDataSyncEnablementService as De}from"../../../../../platform/userDataSync/common/userDataSync.js";import{UserDataSyncEnablementService as Re}from"../../../../../platform/userDataSync/common/userDataSyncEnablementService.js";import{IContextKeyService as Le}from"../../../../../platform/contextkey/common/contextkey.js";import{MockContextKeyService as Me}from"../../../../../platform/keybinding/test/common/mockKeybindingService.js";import{IWorkspaceTrustManagementService as Te}from"../../../../../platform/workspace/common/workspaceTrust.js";import{IEnvironmentService as $,INativeEnvironmentService as ne}from"../../../../../platform/environment/common/environment.js";import{platform as H}from"../../../../../base/common/platform.js";import{arch as J}from"../../../../../base/common/process.js";import{ensureNoDisposablesAreLeakedInTestSuite as z}from"../../../../../base/test/common/utils.js";import{IUpdateService as Ge,State as je}from"../../../../../platform/update/common/update.js";import{IFileService as Oe}from"../../../../../platform/files/common/files.js";import{FileService as We}from"../../../../../platform/files/common/fileService.js";import"../../../../../base/common/types.js";import{IUserDataProfileService as Ne}from"../../../../services/userDataProfile/common/userDataProfile.js";import{UserDataProfileService as Ue}from"../../../../services/userDataProfile/common/userDataProfileService.js";import{toUserDataProfile as Ce}from"../../../../../platform/userDataProfile/common/userDataProfile.js";let e,j,U,O,C;function V(i){j=i.add(new M),U=i.add(new M),O=i.add(new M),C=i.add(new M),e=i.add(new re),e.stub($,Z),e.stub(_,Z),e.stub(ce,de),e.stub(fe,Y),e.stub(ue,new xe),e.stub(Oe,i.add(new We(new Y))),e.stub(Ie,new ve),e.stub(ke,Ae),e.stub(Se,{}),e.stub(Le,new Me),e.stub(b,ae),e.stub(he,Ee),e.stub(ie,{onDidInstallExtensions:U.event,onInstallExtension:j.event,onUninstallExtension:O.event,onDidUninstallExtension:C.event,onDidUpdateExtensionMetadata:q.None,onDidChangeProfile:q.None,async getInstalled(){return[]},async getInstalledWorkspaceExtensions(){return[]},async getExtensionsControlManifest(){return{malicious:[],deprecated:{},search:[]}},async updateMetadata(t,s){return t.identifier.uuid=s.id,t.publisherDisplayName=s.publisherDisplayName,t.publisherId=s.publisherId,t},async canInstall(){return!0},async getTargetPlatform(){return B(H,J)}}),e.stub(we,ye);const n={extensionManagementService:e.get(h),label:"local",id:"vscode-local"};e.stub(k,{get localExtensionManagementServer(){return n},getExtensionManagementServer(t){if(t.location.scheme===D.file)return n;throw new Error(`Invalid Extension ${t.location}`)}}),e.stub(Ne,i.add(new Ue(Ce("test","test",g.file("foo"),g.file("cache"))))),e.stub(I,i.add(new S(e))),e.stub(pe,{onDidChangeFormatters:i.add(new M).event}),e.stub(qe,i.add(new Pe)),e.stub(se,i.add(e.createInstance(me))),e.stub(oe,{}),e.stub(le,ge),e.stub(b,"isEnabled",!0),e.stubPromise(b,"query",f()),e.stubPromise(b,"getExtensions",[]),e.stub(R,{extensions:[],onDidChangeExtensions:q.None,canAddExtension:t=>!1,canRemoveExtension:t=>!1,whenInstalledExtensionsRegistered:()=>Promise.resolve(!0)}),e.get(I).reset(),e.stub(De,i.add(e.createInstance(Re))),e.stub(Ge,{onStateChange:q.None,state:je.Uninitialized}),e.set(c,i.add(e.createInstance(p))),e.stub(Te,i.add(new be))}suite("ExtensionsActions",()=>{const i=z();setup(()=>V(i)),test("Install action is disabled when there is no extension",()=>{const n=i.add(e.createInstance(d.InstallAction,{installPreReleaseVersion:!1}));a.ok(!n.enabled)}),test("Test Install action when state is installed",()=>{const n=e.get(c),t=i.add(e.createInstance(d.InstallAction,{installPreReleaseVersion:!1}));i.add(e.createInstance(x,[t]));const s=r("a");return e.stubPromise(h,"getInstalled",[s]),n.queryLocal().then(()=>(e.stubPromise(b,"query",f(m("a",{identifier:s.identifier}))),n.queryGallery(y.None).then(o=>{t.extension=o.firstPage[0],a.ok(!t.enabled),a.strictEqual("Install",t.label),a.strictEqual("extension-action label prominent install hide",t.class)})))}),test("Test InstallingLabelAction when state is installing",()=>{const n=e.get(c),t=i.add(e.createInstance(d.InstallingLabelAction));i.add(e.createInstance(x,[t]));const s=m("a");return e.stubPromise(b,"query",f(s)),n.queryGallery(y.None).then(o=>{t.extension=o.firstPage[0],j.fire({identifier:s.identifier,source:s,profileLocation:null}),a.ok(!t.enabled),a.strictEqual("Installing",t.label),a.strictEqual("extension-action label install installing",t.class)})}),test("Test Install action when state is uninstalled",async()=>{const n=e.get(c),t=i.add(e.createInstance(d.InstallAction,{installPreReleaseVersion:!1}));i.add(e.createInstance(x,[t]));const s=m("a");e.stubPromise(b,"query",f(s));const o=await n.queryGallery(y.None),l=q.toPromise(q.filter(t.onDidChange,u=>u.enabled===!0));t.extension=o.firstPage[0],await l,a.ok(t.enabled),a.strictEqual("Install",t.label)}),test("Test Install action when extension is system action",()=>{const n=i.add(e.createInstance(d.InstallAction,{installPreReleaseVersion:!1}));i.add(e.createInstance(x,[n]));const t=r("a",{},{type:K.System});return e.stubPromise(h,"getInstalled",[t]),e.get(c).queryLocal().then(s=>{O.fire({identifier:t.identifier,profileLocation:null}),C.fire({identifier:t.identifier,profileLocation:null}),n.extension=s[0],a.ok(!n.enabled)})}),test("Test Install action when extension doesnot has gallery",()=>{const n=i.add(e.createInstance(d.InstallAction,{installPreReleaseVersion:!1}));i.add(e.createInstance(x,[n]));const t=r("a");return e.stubPromise(h,"getInstalled",[t]),e.get(c).queryLocal().then(s=>{O.fire({identifier:t.identifier,profileLocation:null}),C.fire({identifier:t.identifier,profileLocation:null}),n.extension=s[0],a.ok(!n.enabled)})}),test("Uninstall action is disabled when there is no extension",()=>{const n=i.add(e.createInstance(d.UninstallAction));i.add(e.createInstance(x,[n])),a.ok(!n.enabled)}),test("Test Uninstall action when state is uninstalling",()=>{const n=i.add(e.createInstance(d.UninstallAction));i.add(e.createInstance(x,[n]));const t=r("a");return e.stubPromise(h,"getInstalled",[t]),e.get(c).queryLocal().then(s=>{n.extension=s[0],O.fire({identifier:t.identifier,profileLocation:null}),a.ok(!n.enabled),a.strictEqual("Uninstalling",n.label),a.strictEqual("extension-action label uninstall uninstalling",n.class)})}),test("Test Uninstall action when state is installed and is user extension",()=>{const n=i.add(e.createInstance(d.UninstallAction));i.add(e.createInstance(x,[n]));const t=r("a");return e.stubPromise(h,"getInstalled",[t]),e.get(c).queryLocal().then(s=>{n.extension=s[0],a.ok(n.enabled),a.strictEqual("Uninstall",n.label),a.strictEqual("extension-action label uninstall",n.class)})}),test("Test Uninstall action when state is installed and is system extension",()=>{const n=i.add(e.createInstance(d.UninstallAction));i.add(e.createInstance(x,[n]));const t=r("a",{},{type:K.System});return e.stubPromise(h,"getInstalled",[t]),e.get(c).queryLocal().then(s=>{n.extension=s[0],a.ok(!n.enabled),a.strictEqual("Uninstall",n.label),a.strictEqual("extension-action label uninstall",n.class)})}),test("Test Uninstall action when state is installing and is user extension",()=>{const n=i.add(e.createInstance(d.UninstallAction));i.add(e.createInstance(x,[n]));const t=r("a");return e.stubPromise(h,"getInstalled",[t]),e.get(c).queryLocal().then(s=>{const o=m("a"),l=s[0];l.gallery=o,j.fire({identifier:o.identifier,source:o,profileLocation:null}),n.extension=l,a.ok(!n.enabled)})}),test("Test Uninstall action after extension is installed",async()=>{const n=i.add(e.createInstance(d.UninstallAction));i.add(e.createInstance(x,[n]));const t=m("a");e.stubPromise(b,"query",f(t));const s=await e.get(c).queryGallery(y.None);n.extension=s.firstPage[0],j.fire({identifier:t.identifier,source:t,profileLocation:null});const o=q.toPromise(n.onDidChange);U.fire([{identifier:t.identifier,source:t,operation:W.Install,local:r("a",t,t),profileLocation:null}]),await o,a.ok(n.enabled),a.strictEqual("Uninstall",n.label),a.strictEqual("extension-action label uninstall",n.class)}),test("Test UpdateAction when there is no extension",()=>{const n=i.add(e.createInstance(d.UpdateAction,!1));i.add(e.createInstance(x,[n])),a.ok(!n.enabled)}),test("Test UpdateAction when extension is uninstalled",()=>{const n=i.add(e.createInstance(d.UpdateAction,!1));i.add(e.createInstance(x,[n]));const t=m("a",{version:"1.0.0"});return e.stubPromise(b,"query",f(t)),e.get(c).queryGallery(y.None).then(s=>{n.extension=s.firstPage[0],a.ok(!n.enabled)})}),test("Test UpdateAction when extension is installed and not outdated",()=>{const n=i.add(e.createInstance(d.UpdateAction,!1));i.add(e.createInstance(x,[n]));const t=r("a",{version:"1.0.0"});return e.stubPromise(h,"getInstalled",[t]),e.get(c).queryLocal().then(s=>(n.extension=s[0],e.stubPromise(b,"query",f(m("a",{identifier:t.identifier,version:t.manifest.version}))),e.get(c).queryGallery(y.None).then(o=>a.ok(!n.enabled))))}),test("Test UpdateAction when extension is installed outdated and system extension",()=>{const n=i.add(e.createInstance(d.UpdateAction,!1));i.add(e.createInstance(x,[n]));const t=r("a",{version:"1.0.0"},{type:K.System});return e.stubPromise(h,"getInstalled",[t]),e.get(c).queryLocal().then(s=>(n.extension=s[0],e.stubPromise(b,"query",f(m("a",{identifier:t.identifier,version:"1.0.1"}))),e.get(c).queryGallery(y.None).then(o=>a.ok(!n.enabled))))}),test("Test UpdateAction when extension is installed outdated and user extension",()=>{const n=i.add(e.createInstance(d.UpdateAction,!1));i.add(e.createInstance(x,[n]));const t=r("a",{version:"1.0.0"});return e.stubPromise(h,"getInstalled",[t]),e.get(c).queryLocal().then(async o=>{n.extension=o[0];const l=m("a",{identifier:t.identifier,version:"1.0.1"});return e.stubPromise(b,"query",f(l)),e.stubPromise(b,"getCompatibleExtension",l),e.stubPromise(b,"getExtensions",[l]),a.ok(!n.enabled),new Promise(u=>{i.add(n.onDidChange(()=>{n.enabled&&u()})),e.get(c).queryGallery(y.None)})})}),test("Test UpdateAction when extension is installing and outdated and user extension",async()=>{const n=i.add(e.createInstance(d.UpdateAction,!1));i.add(e.createInstance(x,[n]));const t=r("a",{version:"1.0.0"});e.stubPromise(h,"getInstalled",[t]);const s=await e.get(c).queryLocal();n.extension=s[0];const o=m("a",{identifier:t.identifier,version:"1.0.1"});e.stubPromise(b,"query",f(o)),e.stubPromise(b,"getCompatibleExtension",o),e.stubPromise(b,"getExtensions",[o]),await new Promise(l=>{i.add(n.onDidChange(()=>{n.enabled&&l()})),e.get(c).queryGallery(y.None)}),await new Promise(l=>{i.add(n.onDidChange(()=>{n.enabled||l()})),j.fire({identifier:t.identifier,source:o,profileLocation:null})})}),test("Test ManageExtensionAction when there is no extension",()=>{const n=i.add(e.createInstance(d.ManageExtensionAction));i.add(e.createInstance(x,[n])),a.ok(!n.enabled)}),test("Test ManageExtensionAction when extension is installed",()=>{const n=i.add(e.createInstance(d.ManageExtensionAction));i.add(e.createInstance(x,[n]));const t=r("a");return e.stubPromise(h,"getInstalled",[t]),e.get(c).queryLocal().then(s=>{n.extension=s[0],a.ok(n.enabled),a.strictEqual("extension-action icon manage codicon codicon-extensions-manage",n.class),a.strictEqual("Manage",n.tooltip)})}),test("Test ManageExtensionAction when extension is uninstalled",()=>{const n=i.add(e.createInstance(d.ManageExtensionAction));i.add(e.createInstance(x,[n]));const t=m("a");return e.stubPromise(b,"query",f(t)),e.get(c).queryGallery(y.None).then(s=>{n.extension=s.firstPage[0],a.ok(!n.enabled),a.strictEqual("extension-action icon manage codicon codicon-extensions-manage hide",n.class),a.strictEqual("Manage",n.tooltip)})}),test("Test ManageExtensionAction when extension is installing",()=>{const n=i.add(e.createInstance(d.ManageExtensionAction));i.add(e.createInstance(x,[n]));const t=m("a");return e.stubPromise(b,"query",f(t)),e.get(c).queryGallery(y.None).then(s=>{n.extension=s.firstPage[0],j.fire({identifier:t.identifier,source:t,profileLocation:null}),a.ok(!n.enabled),a.strictEqual("extension-action icon manage codicon codicon-extensions-manage hide",n.class),a.strictEqual("Manage",n.tooltip)})}),test("Test ManageExtensionAction when extension is queried from gallery and installed",async()=>{const n=i.add(e.createInstance(d.ManageExtensionAction));i.add(e.createInstance(x,[n]));const t=m("a");e.stubPromise(b,"query",f(t));const s=await e.get(c).queryGallery(y.None);n.extension=s.firstPage[0],j.fire({identifier:t.identifier,source:t,profileLocation:null});const o=q.toPromise(n.onDidChange);U.fire([{identifier:t.identifier,source:t,operation:W.Install,local:r("a",t,t),profileLocation:null}]),await o,a.ok(n.enabled),a.strictEqual("extension-action icon manage codicon codicon-extensions-manage",n.class),a.strictEqual("Manage",n.tooltip)}),test("Test ManageExtensionAction when extension is system extension",()=>{const n=i.add(e.createInstance(d.ManageExtensionAction));i.add(e.createInstance(x,[n]));const t=r("a",{},{type:K.System});return e.stubPromise(h,"getInstalled",[t]),e.get(c).queryLocal().then(s=>{n.extension=s[0],a.ok(n.enabled),a.strictEqual("extension-action icon manage codicon codicon-extensions-manage",n.class),a.strictEqual("Manage",n.tooltip)})}),test("Test ManageExtensionAction when extension is uninstalling",()=>{const n=i.add(e.createInstance(d.ManageExtensionAction));i.add(e.createInstance(x,[n]));const t=r("a");return e.stubPromise(h,"getInstalled",[t]),e.get(c).queryLocal().then(s=>{n.extension=s[0],O.fire({identifier:t.identifier,profileLocation:null}),a.ok(!n.enabled),a.strictEqual("extension-action icon manage codicon codicon-extensions-manage",n.class),a.strictEqual("Manage",n.tooltip)})}),test("Test EnableForWorkspaceAction when there is no extension",()=>{const n=i.add(e.createInstance(d.EnableForWorkspaceAction));a.ok(!n.enabled)}),test("Test EnableForWorkspaceAction when there extension is not disabled",()=>{const n=r("a");return e.stubPromise(h,"getInstalled",[n]),e.get(c).queryLocal().then(t=>{const s=i.add(e.createInstance(d.EnableForWorkspaceAction));s.extension=t[0],a.ok(!s.enabled)})}),test("Test EnableForWorkspaceAction when the extension is disabled globally",()=>{const n=r("a");return e.get(I).setEnablement([n],L.DisabledGlobally).then(()=>(e.stubPromise(h,"getInstalled",[n]),e.get(c).queryLocal().then(t=>{const s=i.add(e.createInstance(d.EnableForWorkspaceAction));s.extension=t[0],a.ok(s.enabled)})))}),test("Test EnableForWorkspaceAction when extension is disabled for workspace",()=>{const n=r("a");return e.get(I).setEnablement([n],L.DisabledWorkspace).then(()=>(e.stubPromise(h,"getInstalled",[n]),e.get(c).queryLocal().then(t=>{const s=i.add(e.createInstance(d.EnableForWorkspaceAction));s.extension=t[0],a.ok(s.enabled)})))}),test("Test EnableForWorkspaceAction when the extension is disabled globally and workspace",()=>{const n=r("a");return e.get(I).setEnablement([n],L.DisabledGlobally).then(()=>e.get(I).setEnablement([n],L.DisabledWorkspace)).then(()=>(e.stubPromise(h,"getInstalled",[n]),e.get(c).queryLocal().then(t=>{const s=i.add(e.createInstance(d.EnableForWorkspaceAction));s.extension=t[0],a.ok(s.enabled)})))}),test("Test EnableGloballyAction when there is no extension",()=>{const n=i.add(e.createInstance(d.EnableGloballyAction));a.ok(!n.enabled)}),test("Test EnableGloballyAction when the extension is not disabled",()=>{const n=r("a");return e.stubPromise(h,"getInstalled",[n]),e.get(c).queryLocal().then(t=>{const s=i.add(e.createInstance(d.EnableGloballyAction));s.extension=t[0],a.ok(!s.enabled)})}),test("Test EnableGloballyAction when the extension is disabled for workspace",()=>{const n=r("a");return e.get(I).setEnablement([n],L.DisabledWorkspace).then(()=>(e.stubPromise(h,"getInstalled",[n]),e.get(c).queryLocal().then(t=>{const s=i.add(e.createInstance(d.EnableGloballyAction));s.extension=t[0],a.ok(!s.enabled)})))}),test("Test EnableGloballyAction when the extension is disabled globally",()=>{const n=r("a");return e.get(I).setEnablement([n],L.DisabledGlobally).then(()=>(e.stubPromise(h,"getInstalled",[n]),e.get(c).queryLocal().then(t=>{const s=i.add(e.createInstance(d.EnableGloballyAction));s.extension=t[0],a.ok(s.enabled)})))}),test("Test EnableGloballyAction when the extension is disabled in both",()=>{const n=r("a");return e.get(I).setEnablement([n],L.DisabledGlobally).then(()=>e.get(I).setEnablement([n],L.DisabledWorkspace)).then(()=>(e.stubPromise(h,"getInstalled",[n]),e.get(c).queryLocal().then(t=>{const s=i.add(e.createInstance(d.EnableGloballyAction));s.extension=t[0],a.ok(s.enabled)})))}),test("Test EnableAction when there is no extension",()=>{const n=i.add(e.createInstance(d.EnableDropDownAction));a.ok(!n.enabled)}),test("Test EnableDropDownAction when extension is installed and enabled",()=>{const n=r("a");return e.stubPromise(h,"getInstalled",[n]),e.get(c).queryLocal().then(t=>{const s=i.add(e.createInstance(d.EnableDropDownAction));s.extension=t[0],a.ok(!s.enabled)})}),test("Test EnableDropDownAction when extension is installed and disabled globally",()=>{const n=r("a");return e.get(I).setEnablement([n],L.DisabledGlobally).then(()=>(e.stubPromise(h,"getInstalled",[n]),e.get(c).queryLocal().then(t=>{const s=i.add(e.createInstance(d.EnableDropDownAction));s.extension=t[0],a.ok(s.enabled)})))}),test("Test EnableDropDownAction when extension is installed and disabled for workspace",()=>{const n=r("a");return e.get(I).setEnablement([n],L.DisabledWorkspace).then(()=>(e.stubPromise(h,"getInstalled",[n]),e.get(c).queryLocal().then(t=>{const s=i.add(e.createInstance(d.EnableDropDownAction));s.extension=t[0],a.ok(s.enabled)})))}),test("Test EnableDropDownAction when extension is uninstalled",()=>{const n=m("a");return e.stubPromise(b,"query",f(n)),e.get(c).queryGallery(y.None).then(t=>{const s=i.add(e.createInstance(d.EnableDropDownAction));s.extension=t.firstPage[0],a.ok(!s.enabled)})}),test("Test EnableDropDownAction when extension is installing",()=>{const n=m("a");return e.stubPromise(b,"query",f(n)),e.get(c).queryGallery(y.None).then(t=>{const s=i.add(e.createInstance(d.EnableDropDownAction));s.extension=t.firstPage[0],i.add(e.createInstance(x,[s])),j.fire({identifier:n.identifier,source:n,profileLocation:null}),a.ok(!s.enabled)})}),test("Test EnableDropDownAction when extension is uninstalling",()=>{const n=r("a");return e.stubPromise(h,"getInstalled",[n]),e.get(c).queryLocal().then(t=>{const s=i.add(e.createInstance(d.EnableDropDownAction));s.extension=t[0],O.fire({identifier:n.identifier,profileLocation:null}),a.ok(!s.enabled)})}),test("Test DisableForWorkspaceAction when there is no extension",()=>{const n=i.add(e.createInstance(d.DisableForWorkspaceAction));a.ok(!n.enabled)}),test("Test DisableForWorkspaceAction when the extension is disabled globally",()=>{const n=r("a");return e.get(I).setEnablement([n],L.DisabledGlobally).then(()=>(e.stubPromise(h,"getInstalled",[n]),e.get(c).queryLocal().then(t=>{const s=i.add(e.createInstance(d.DisableForWorkspaceAction));s.extension=t[0],a.ok(!s.enabled)})))}),test("Test DisableForWorkspaceAction when the extension is disabled workspace",()=>{const n=r("a");return e.get(I).setEnablement([n],L.DisabledGlobally).then(()=>(e.stubPromise(h,"getInstalled",[n]),e.get(c).queryLocal().then(t=>{const s=i.add(e.createInstance(d.DisableForWorkspaceAction));s.extension=t[0],a.ok(!s.enabled)})))}),test("Test DisableForWorkspaceAction when extension is enabled",()=>{const n=r("a");return e.stub(R,{extensions:[T(n)],onDidChangeExtensions:q.None,whenInstalledExtensionsRegistered:()=>Promise.resolve(!0)}),e.stubPromise(h,"getInstalled",[n]),e.get(c).queryLocal().then(t=>{const s=i.add(e.createInstance(d.DisableForWorkspaceAction));s.extension=t[0],a.ok(s.enabled)})}),test("Test DisableGloballyAction when there is no extension",()=>{const n=i.add(e.createInstance(d.DisableGloballyAction));a.ok(!n.enabled)}),test("Test DisableGloballyAction when the extension is disabled globally",()=>{const n=r("a");return e.get(I).setEnablement([n],L.DisabledGlobally).then(()=>(e.stubPromise(h,"getInstalled",[n]),e.get(c).queryLocal().then(t=>{const s=i.add(e.createInstance(d.DisableGloballyAction));s.extension=t[0],a.ok(!s.enabled)})))}),test("Test DisableGloballyAction when the extension is disabled for workspace",()=>{const n=r("a");return e.get(I).setEnablement([n],L.DisabledWorkspace).then(()=>(e.stubPromise(h,"getInstalled",[n]),e.get(c).queryLocal().then(t=>{const s=i.add(e.createInstance(d.DisableGloballyAction));s.extension=t[0],a.ok(!s.enabled)})))}),test("Test DisableGloballyAction when the extension is enabled",()=>{const n=r("a");return e.stubPromise(h,"getInstalled",[n]),e.stub(R,{extensions:[T(n)],onDidChangeExtensions:q.None,whenInstalledExtensionsRegistered:()=>Promise.resolve(!0)}),e.get(c).queryLocal().then(t=>{const s=i.add(e.createInstance(d.DisableGloballyAction));s.extension=t[0],a.ok(s.enabled)})}),test("Test DisableGloballyAction when extension is installed and enabled",()=>{const n=r("a");return e.stubPromise(h,"getInstalled",[n]),e.stub(R,{extensions:[T(n)],onDidChangeExtensions:q.None,whenInstalledExtensionsRegistered:()=>Promise.resolve(!0)}),e.get(c).queryLocal().then(t=>{const s=i.add(e.createInstance(d.DisableGloballyAction));s.extension=t[0],a.ok(s.enabled)})}),test("Test DisableGloballyAction when extension is installed and disabled globally",()=>{const n=r("a");return e.stub(R,{extensions:[T(n)],onDidChangeExtensions:q.None,whenInstalledExtensionsRegistered:()=>Promise.resolve(!0)}),e.get(I).setEnablement([n],L.DisabledGlobally).then(()=>(e.stubPromise(h,"getInstalled",[n]),e.get(c).queryLocal().then(t=>{const s=i.add(e.createInstance(d.DisableGloballyAction));s.extension=t[0],a.ok(!s.enabled)})))}),test("Test DisableGloballyAction when extension is uninstalled",()=>{const n=m("a");return e.stubPromise(b,"query",f(n)),e.stub(R,{extensions:[T(r("a"))],onDidChangeExtensions:q.None,whenInstalledExtensionsRegistered:()=>Promise.resolve(!0)}),e.get(c).queryGallery(y.None).then(t=>{const s=i.add(e.createInstance(d.DisableGloballyAction));s.extension=t.firstPage[0],a.ok(!s.enabled)})}),test("Test DisableGloballyAction when extension is installing",()=>{const n=m("a");return e.stubPromise(b,"query",f(n)),e.stub(R,{extensions:[T(r("a"))],onDidChangeExtensions:q.None,whenInstalledExtensionsRegistered:()=>Promise.resolve(!0)}),e.get(c).queryGallery(y.None).then(t=>{const s=i.add(e.createInstance(d.DisableGloballyAction));s.extension=t.firstPage[0],i.add(e.createInstance(x,[s])),j.fire({identifier:n.identifier,source:n,profileLocation:null}),a.ok(!s.enabled)})}),test("Test DisableGloballyAction when extension is uninstalling",()=>{const n=r("a");return e.stubPromise(h,"getInstalled",[n]),e.stub(R,{extensions:[T(n)],onDidChangeExtensions:q.None,whenInstalledExtensionsRegistered:()=>Promise.resolve(!0)}),e.get(c).queryLocal().then(t=>{const s=i.add(e.createInstance(d.DisableGloballyAction));s.extension=t[0],i.add(e.createInstance(x,[s])),O.fire({identifier:n.identifier,profileLocation:null}),a.ok(!s.enabled)})})}),suite("ExtensionRuntimeStateAction",()=>{const i=z();setup(()=>V(i)),test("Test Runtime State when there is no extension",()=>{const n=i.add(e.createInstance(d.ExtensionRuntimeStateAction));i.add(e.createInstance(x,[n])),a.ok(!n.enabled)}),test("Test Runtime State when extension state is installing",async()=>{const n=i.add(e.createInstance(d.ExtensionRuntimeStateAction));i.add(e.createInstance(x,[n]));const t=e.get(c),s=m("a");e.stubPromise(b,"query",f(s));const o=await t.queryGallery(y.None);n.extension=o.firstPage[0],j.fire({identifier:s.identifier,source:s,profileLocation:null}),a.ok(!n.enabled)}),test("Test Runtime State when extension state is uninstalling",async()=>{const n=i.add(e.createInstance(d.ExtensionRuntimeStateAction));i.add(e.createInstance(x,[n]));const t=r("a");e.stubPromise(h,"getInstalled",[t]);const s=await e.get(c).queryLocal();n.extension=s[0],O.fire({identifier:t.identifier,profileLocation:null}),a.ok(!n.enabled)}),test("Test Runtime State when extension is newly installed",async()=>{const n=new M;e.stub(R,{extensions:[T(r("b"))],onDidChangeExtensions:n.event,canAddExtension:u=>!1,whenInstalledExtensionsRegistered:()=>Promise.resolve(!0)});const t=i.add(e.createInstance(d.ExtensionRuntimeStateAction));i.add(e.createInstance(x,[t]));const s=m("a");e.stubPromise(b,"query",f(s));const o=await e.get(c).queryGallery(y.None);t.extension=o.firstPage[0],a.ok(!t.enabled),j.fire({identifier:s.identifier,source:s,profileLocation:null});const l=q.toPromise(t.onDidChange);U.fire([{identifier:s.identifier,source:s,operation:W.Install,local:r("a",s,s),profileLocation:null}]),await l,a.ok(t.enabled),a.strictEqual(t.tooltip,"Please restart extensions to enable this extension.")}),test("Test Runtime State when extension is newly installed and ext host restart is not required",async()=>{const n=new M;e.stub(R,{extensions:[T(r("b"))],onDidChangeExtensions:n.event,canAddExtension:l=>!0,whenInstalledExtensionsRegistered:()=>Promise.resolve(!0)});const t=i.add(e.createInstance(d.ExtensionRuntimeStateAction));i.add(e.createInstance(x,[t]));const s=m("a");e.stubPromise(b,"query",f(s));const o=await e.get(c).queryGallery(y.None);t.extension=o.firstPage[0],a.ok(!t.enabled),j.fire({identifier:s.identifier,source:s,profileLocation:null}),U.fire([{identifier:s.identifier,source:s,operation:W.Install,local:r("a",s,s),profileLocation:null}]),a.ok(!t.enabled)}),test("Test Runtime State when extension is installed and uninstalled",async()=>{e.stub(R,{extensions:[T(r("b"))],onDidChangeExtensions:q.None,canRemoveExtension:l=>!1,canAddExtension:l=>!1,whenInstalledExtensionsRegistered:()=>Promise.resolve(!0)});const n=i.add(e.createInstance(d.ExtensionRuntimeStateAction));i.add(e.createInstance(x,[n]));const t=m("a");e.stubPromise(b,"query",f(t));const s=await e.get(c).queryGallery(y.None);n.extension=s.firstPage[0];const o=t.identifier;j.fire({identifier:o,source:t,profileLocation:null}),U.fire([{identifier:o,source:t,operation:W.Install,local:r("a",t,{identifier:o}),profileLocation:null}]),O.fire({identifier:o,profileLocation:null}),C.fire({identifier:o,profileLocation:null}),a.ok(!n.enabled)}),test("Test Runtime State when extension is uninstalled",async()=>{e.stub(R,{extensions:[T(r("a",{version:"1.0.0"}))],onDidChangeExtensions:q.None,canRemoveExtension:o=>!1,canAddExtension:o=>!1,whenInstalledExtensionsRegistered:()=>Promise.resolve(!0)}),e.set(c,i.add(e.createInstance(p)));const n=i.add(e.createInstance(d.ExtensionRuntimeStateAction));i.add(e.createInstance(x,[n]));const t=r("a");e.stubPromise(h,"getInstalled",[t]);const s=await e.get(c).queryLocal();n.extension=s[0],O.fire({identifier:t.identifier,profileLocation:null}),C.fire({identifier:t.identifier,profileLocation:null}),a.ok(n.enabled),a.strictEqual(n.tooltip,"Please restart extensions to complete the uninstallation of this extension.")}),test("Test Runtime State when extension is uninstalled and can be removed",async()=>{const n=r("a");e.stub(R,{extensions:[T(n)],onDidChangeExtensions:q.None,canRemoveExtension:o=>!0,canAddExtension:o=>!0,whenInstalledExtensionsRegistered:()=>Promise.resolve(!0)});const t=i.add(e.createInstance(d.ExtensionRuntimeStateAction));i.add(e.createInstance(x,[t])),e.stubPromise(h,"getInstalled",[n]);const s=await e.get(c).queryLocal();t.extension=s[0],O.fire({identifier:n.identifier,profileLocation:null}),C.fire({identifier:n.identifier,profileLocation:null}),a.ok(!t.enabled)}),test("Test Runtime State when extension is uninstalled and installed",async()=>{e.stub(R,{extensions:[T(r("a",{version:"1.0.0"}))],onDidChangeExtensions:q.None,canRemoveExtension:u=>!1,canAddExtension:u=>!1,whenInstalledExtensionsRegistered:()=>Promise.resolve(!0)});const n=i.add(e.createInstance(d.ExtensionRuntimeStateAction));i.add(e.createInstance(x,[n]));const t=r("a");e.stubPromise(h,"getInstalled",[t]);const s=await e.get(c).queryLocal();n.extension=s[0],O.fire({identifier:t.identifier,profileLocation:null}),C.fire({identifier:t.identifier,profileLocation:null});const o=m("a"),l=o.identifier;j.fire({identifier:l,source:o,profileLocation:null}),U.fire([{identifier:l,source:o,operation:W.Install,local:t,profileLocation:null}]),a.ok(!n.enabled)}),test("Test Runtime State when extension is updated while running",async()=>{e.stub(R,{extensions:[T(r("a",{version:"1.0.1"}))],onDidChangeExtensions:q.None,canRemoveExtension:l=>!0,canAddExtension:l=>!1,whenInstalledExtensionsRegistered:()=>Promise.resolve(!0)}),e.set(c,i.add(e.createInstance(p)));const n=i.add(e.createInstance(d.ExtensionRuntimeStateAction));i.add(e.createInstance(x,[n]));const t=r("a",{version:"1.0.1"}),s=e.get(c);e.stubPromise(h,"getInstalled",[t]);const o=await s.queryLocal();return n.extension=o[0],new Promise(l=>{i.add(n.onDidChange(()=>{n.enabled&&n.tooltip==="Please restart extensions to enable the updated extension."&&l()}));const u=m("a",{uuid:t.identifier.id,version:"1.0.2"});j.fire({identifier:u.identifier,source:u,profileLocation:null}),U.fire([{identifier:u.identifier,source:u,operation:W.Install,local:r("a",u,u),profileLocation:null}])})}),test("Test Runtime State when extension is updated when not running",async()=>{e.stub(R,{extensions:[T(r("b"))],onDidChangeExtensions:q.None,canRemoveExtension:u=>!1,canAddExtension:u=>!1,whenInstalledExtensionsRegistered:()=>Promise.resolve(!0)});const n=r("a",{version:"1.0.1"});await e.get(I).setEnablement([n],L.DisabledGlobally);const t=i.add(e.createInstance(d.ExtensionRuntimeStateAction));i.add(e.createInstance(x,[t]));const s=e.get(c);e.stubPromise(h,"getInstalled",[n]);const o=await s.queryLocal();t.extension=o[0];const l=m("a",{identifier:n.identifier,version:"1.0.2"});j.fire({identifier:l.identifier,source:l,profileLocation:null}),U.fire([{identifier:l.identifier,source:l,operation:W.Update,local:r("a",l,l),profileLocation:null}]),a.ok(!t.enabled)}),test("Test Runtime State when extension is disabled when running",async()=>{e.stub(R,{extensions:[T(r("a"))],onDidChangeExtensions:q.None,canRemoveExtension:l=>!1,canAddExtension:l=>!1,whenInstalledExtensionsRegistered:()=>Promise.resolve(!0)}),e.set(c,i.add(e.createInstance(p)));const n=i.add(e.createInstance(d.ExtensionRuntimeStateAction));i.add(e.createInstance(x,[n]));const t=r("a"),s=e.get(c);e.stubPromise(h,"getInstalled",[t]);const o=await s.queryLocal();n.extension=o[0],await s.setEnablement(o[0],L.DisabledGlobally),await n.update(),a.ok(n.enabled),a.strictEqual("Please restart extensions to disable this extension.",n.tooltip)}),test("Test Runtime State when extension enablement is toggled when running",async()=>{e.stub(R,{extensions:[T(r("a",{version:"1.0.0"}))],onDidChangeExtensions:q.None,canRemoveExtension:l=>!1,canAddExtension:l=>!1,whenInstalledExtensionsRegistered:()=>Promise.resolve(!0)}),e.set(c,i.add(e.createInstance(p)));const n=i.add(e.createInstance(d.ExtensionRuntimeStateAction));i.add(e.createInstance(x,[n]));const t=r("a"),s=e.get(c);e.stubPromise(h,"getInstalled",[t]);const o=await s.queryLocal();n.extension=o[0],await s.setEnablement(o[0],L.DisabledGlobally),await s.setEnablement(o[0],L.EnabledGlobally),a.ok(!n.enabled)}),test("Test Runtime State when extension is enabled when not running",async()=>{e.stub(R,{extensions:[T(r("b"))],onDidChangeExtensions:q.None,canRemoveExtension:l=>!1,canAddExtension:l=>!1,whenInstalledExtensionsRegistered:()=>Promise.resolve(!0)});const n=r("a");await e.get(I).setEnablement([n],L.DisabledGlobally);const t=i.add(e.createInstance(d.ExtensionRuntimeStateAction));i.add(e.createInstance(x,[t]));const s=e.get(c);e.stubPromise(h,"getInstalled",[n]);const o=await s.queryLocal();t.extension=o[0],await s.setEnablement(o[0],L.EnabledGlobally),await t.update(),a.ok(t.enabled),a.strictEqual("Please restart extensions to enable this extension.",t.tooltip)}),test("Test Runtime State when extension enablement is toggled when not running",async()=>{e.stub(R,{extensions:[T(r("b"))],onDidChangeExtensions:q.None,canRemoveExtension:l=>!1,canAddExtension:l=>!1,whenInstalledExtensionsRegistered:()=>Promise.resolve(!0)});const n=r("a");await e.get(I).setEnablement([n],L.DisabledGlobally);const t=i.add(e.createInstance(d.ExtensionRuntimeStateAction));i.add(e.createInstance(x,[t]));const s=e.get(c);e.stubPromise(h,"getInstalled",[n]);const o=await s.queryLocal();t.extension=o[0],await s.setEnablement(o[0],L.EnabledGlobally),await s.setEnablement(o[0],L.DisabledGlobally),a.ok(!t.enabled)}),test("Test Runtime State when extension is updated when not running and enabled",async()=>{e.stub(R,{extensions:[T(r("a"))],onDidChangeExtensions:q.None,canRemoveExtension:u=>!1,canAddExtension:u=>!1,whenInstalledExtensionsRegistered:()=>Promise.resolve(!0)});const n=r("a",{version:"1.0.1"});await e.get(I).setEnablement([n],L.DisabledGlobally);const t=i.add(e.createInstance(d.ExtensionRuntimeStateAction));i.add(e.createInstance(x,[t]));const s=e.get(c);e.stubPromise(h,"getInstalled",[n]);const o=await s.queryLocal();t.extension=o[0];const l=m("a",{identifier:n.identifier,version:"1.0.2"});j.fire({identifier:l.identifier,source:l,profileLocation:null}),U.fire([{identifier:l.identifier,source:l,operation:W.Install,local:r("a",l,l),profileLocation:null}]),await s.setEnablement(o[0],L.EnabledGlobally),await t.update(),a.ok(t.enabled),a.strictEqual("Please restart extensions to enable this extension.",t.tooltip)}),test("Test Runtime State when a localization extension is newly installed",async()=>{e.stub(R,{extensions:[T(r("b"))],onDidChangeExtensions:q.None,canRemoveExtension:o=>!1,canAddExtension:o=>!1,whenInstalledExtensionsRegistered:()=>Promise.resolve(!0)});const n=i.add(e.createInstance(d.ExtensionRuntimeStateAction));i.add(e.createInstance(x,[n]));const t=m("a");e.stubPromise(b,"query",f(t));const s=await e.get(c).queryGallery(y.None);n.extension=s.firstPage[0],a.ok(!n.enabled),j.fire({identifier:t.identifier,source:t,profileLocation:null}),U.fire([{identifier:t.identifier,source:t,operation:W.Install,local:r("a",{...t,contributes:{localizations:[{languageId:"de",translations:[]}]}},t),profileLocation:null}]),a.ok(!n.enabled)}),test("Test Runtime State when a localization extension is updated while running",async()=>{e.stub(R,{extensions:[T(r("a",{version:"1.0.1"}))],onDidChangeExtensions:q.None,canRemoveExtension:u=>!1,canAddExtension:u=>!1,whenInstalledExtensionsRegistered:()=>Promise.resolve(!0)});const n=i.add(e.createInstance(d.ExtensionRuntimeStateAction));i.add(e.createInstance(x,[n]));const t=r("a",{version:"1.0.1",contributes:{localizations:[{languageId:"de",translations:[]}]}}),s=e.get(c);e.stubPromise(h,"getInstalled",[t]);const o=await s.queryLocal();n.extension=o[0];const l=m("a",{uuid:t.identifier.id,version:"1.0.2"});j.fire({identifier:l.identifier,source:l,profileLocation:null}),U.fire([{identifier:l.identifier,source:l,operation:W.Install,local:r("a",{...l,contributes:{localizations:[{languageId:"de",translations:[]}]}},l),profileLocation:null}]),a.ok(!n.enabled)}),test("Test Runtime State when extension is not installed but extension from different server is installed and running",async()=>{const n=m("a"),t=r("a",{extensionKind:["workspace"]},{location:g.file("pub.a")}),s=r("a",{extensionKind:["workspace"]},{location:g.file("pub.a").with({scheme:D.vscodeRemote})}),o=A(e,E([t]),E([s]));e.stub(k,o),e.stub(I,i.add(new S(e)));const l=new M;e.stub(R,{extensions:[T(s)],onDidChangeExtensions:l.event,canAddExtension:P=>!1,whenInstalledExtensionsRegistered:()=>Promise.resolve(!0)});const u=i.add(e.createInstance(p));e.set(c,u);const w=i.add(e.createInstance(d.ExtensionRuntimeStateAction));i.add(e.createInstance(x,[w])),e.stubPromise(b,"query",f(n)),await u.queryGallery(y.None);const v=await u.queryLocal(o.localExtensionManagementServer);w.extension=v[0],a.ok(w.extension),a.ok(!w.enabled)}),test("Test Runtime State when extension is uninstalled but extension from different server is installed and running",async()=>{const n=m("a"),t=r("a",{extensionKind:["workspace"]},{location:g.file("pub.a")}),s=r("a",{extensionKind:["workspace"]},{location:g.file("pub.a").with({scheme:D.vscodeRemote})}),o=E([t]),l=new M,u=new M;o.onUninstallExtension=l.event,o.onDidUninstallExtension=u.event;const w=A(e,o,E([s]));e.stub(k,w),e.stub(I,i.add(new S(e)));const v=new M;e.stub(R,{extensions:[T(s)],onDidChangeExtensions:v.event,canAddExtension:Q=>!1,whenInstalledExtensionsRegistered:()=>Promise.resolve(!0)});const P=i.add(e.createInstance(p));e.set(c,P);const G=i.add(e.createInstance(d.ExtensionRuntimeStateAction));i.add(e.createInstance(x,[G])),e.stubPromise(b,"query",f(n)),await P.queryGallery(y.None);const N=await P.queryLocal(w.localExtensionManagementServer);G.extension=N[0],a.ok(G.extension),a.ok(!G.enabled),l.fire({identifier:t.identifier,profileLocation:null}),C.fire({identifier:t.identifier,profileLocation:null}),a.ok(!G.enabled)}),test("Test Runtime State when workspace extension is disabled on local server and installed in remote server",async()=>{const n=m("a"),t=E([]),s=new M;t.onDidInstallExtensions=s.event;const o=r("a",{extensionKind:["workspace"]},{location:g.file("pub.a")}),l=A(e,E([o]),t);e.stub(k,l),e.stub(I,i.add(new S(e)));const u=i.add(e.createInstance(p));e.set(c,u);const w=new M;e.stub(R,{extensions:[],onDidChangeExtensions:w.event,canAddExtension:Q=>!1,whenInstalledExtensionsRegistered:()=>Promise.resolve(!0)});const v=i.add(e.createInstance(d.ExtensionRuntimeStateAction));i.add(e.createInstance(x,[v])),e.stubPromise(b,"query",f(n)),await u.queryGallery(y.None);const P=await u.queryLocal(l.localExtensionManagementServer);v.extension=P[0],a.ok(v.extension),a.ok(!v.enabled);const G=r("a",{extensionKind:["workspace"]},{location:g.file("pub.a").with({scheme:D.vscodeRemote})}),N=q.toPromise(v.onDidChange);s.fire([{identifier:G.identifier,local:G,operation:W.Install,profileLocation:null}]),await N,a.ok(v.enabled),a.strictEqual(v.tooltip,"Please reload window to enable this extension.")}),test("Test Runtime State when ui extension is disabled on remote server and installed in local server",async()=>{const n=m("a"),t=E([]),s=new M;t.onDidInstallExtensions=s.event;const o=r("a",{extensionKind:["ui"]},{location:g.file("pub.a").with({scheme:D.vscodeRemote})}),l=A(e,t,E([o]));e.stub(k,l),e.stub(I,i.add(new S(e)));const u=i.add(e.createInstance(p));e.set(c,u);const w=new M;e.stub(R,{extensions:[],onDidChangeExtensions:w.event,canAddExtension:Q=>!1,whenInstalledExtensionsRegistered:()=>Promise.resolve(!0)});const v=i.add(e.createInstance(d.ExtensionRuntimeStateAction));i.add(e.createInstance(x,[v])),e.stubPromise(b,"query",f(n)),await u.queryGallery(y.None);const P=await u.queryLocal(l.remoteExtensionManagementServer);v.extension=P[0],a.ok(v.extension),a.ok(!v.enabled);const G=r("a",{extensionKind:["ui"]},{location:g.file("pub.a")}),N=q.toPromise(q.filter(v.onDidChange,()=>v.enabled));s.fire([{identifier:G.identifier,local:G,operation:W.Install,profileLocation:null}]),await N,a.ok(v.enabled),a.strictEqual(v.tooltip,"Please reload window to enable this extension.")}),test("Test Runtime State for remote ui extension is disabled when it is installed and enabled in local server",async()=>{const n=m("a"),t=r("a",{extensionKind:["ui"]},{location:g.file("pub.a")}),s=E([t]),o=new M;s.onDidInstallExtensions=o.event;const l=r("a",{extensionKind:["ui"]},{location:g.file("pub.a").with({scheme:D.vscodeRemote})}),u=A(e,s,E([l]));e.stub(k,u),e.stub(I,i.add(new S(e)));const w=new M;e.stub(R,{extensions:[T(t)],onDidChangeExtensions:w.event,canAddExtension:N=>!1,whenInstalledExtensionsRegistered:()=>Promise.resolve(!0)});const v=i.add(e.createInstance(p));e.set(c,v);const P=i.add(e.createInstance(d.ExtensionRuntimeStateAction));i.add(e.createInstance(x,[P])),e.stubPromise(b,"query",f(n)),await v.queryGallery(y.None);const G=await v.queryLocal(u.remoteExtensionManagementServer);P.extension=G[0],a.ok(P.extension),a.ok(!P.enabled)}),test("Test Runtime State for remote workspace+ui extension is enabled when it is installed and enabled in local server",async()=>{const n=m("a"),t=r("a",{extensionKind:["workspace","ui"]},{location:g.file("pub.a")}),s=E([t]),o=new M;s.onDidInstallExtensions=o.event;const l=r("a",{extensionKind:["workspace","ui"]},{location:g.file("pub.a").with({scheme:D.vscodeRemote})}),u=A(e,s,E([l]));e.stub(k,u),e.stub(I,i.add(new S(e)));const w=i.add(e.createInstance(p));e.set(c,w);const v=new M;e.stub(R,{extensions:[T(t)],onDidChangeExtensions:v.event,canAddExtension:N=>!1,whenInstalledExtensionsRegistered:()=>Promise.resolve(!0)});const P=i.add(e.createInstance(d.ExtensionRuntimeStateAction));i.add(e.createInstance(x,[P])),e.stubPromise(b,"query",f(n)),await w.queryGallery(y.None);const G=await w.queryLocal(u.remoteExtensionManagementServer);P.extension=G[0],a.ok(P.extension),a.ok(P.enabled)}),test("Test Runtime State for local ui+workspace extension is enabled when it is installed and enabled in remote server",async()=>{const n=m("a"),t=r("a",{extensionKind:["ui","workspace"]},{location:g.file("pub.a")}),s=r("a",{extensionKind:["ui","workspace"]},{location:g.file("pub.a").with({scheme:D.vscodeRemote})}),o=E([s]),l=new M;o.onDidInstallExtensions=l.event;const u=A(e,E([t]),o);e.stub(k,u),e.stub(I,i.add(new S(e)));const w=i.add(e.createInstance(p));e.set(c,w);const v=new M;e.stub(R,{extensions:[T(s)],onDidChangeExtensions:v.event,canAddExtension:N=>!1,whenInstalledExtensionsRegistered:()=>Promise.resolve(!0)});const P=i.add(e.createInstance(d.ExtensionRuntimeStateAction));i.add(e.createInstance(x,[P])),e.stubPromise(b,"query",f(n)),await w.queryGallery(y.None);const G=await w.queryLocal(u.localExtensionManagementServer);P.extension=G[0],a.ok(P.extension),a.ok(P.enabled)}),test("Test Runtime State for local workspace+ui extension is enabled when it is installed in both servers but running in local server",async()=>{const n=m("a"),t=r("a",{extensionKind:["workspace","ui"]},{location:g.file("pub.a")}),s=E([t]),o=new M;s.onDidInstallExtensions=o.event;const l=r("a",{extensionKind:["workspace","ui"]},{location:g.file("pub.a").with({scheme:D.vscodeRemote})}),u=A(e,s,E([l]));e.stub(k,u),e.stub(I,i.add(new S(e)));const w=i.add(e.createInstance(p));e.set(c,w);const v=new M;e.stub(R,{extensions:[T(t)],onDidChangeExtensions:v.event,canAddExtension:N=>!1,whenInstalledExtensionsRegistered:()=>Promise.resolve(!0)});const P=i.add(e.createInstance(d.ExtensionRuntimeStateAction));i.add(e.createInstance(x,[P])),e.stubPromise(b,"query",f(n)),await w.queryGallery(y.None);const G=await w.queryLocal(u.localExtensionManagementServer);P.extension=G[0],a.ok(P.extension),a.ok(P.enabled)}),test("Test Runtime State for remote ui+workspace extension is enabled when it is installed on both servers but running in remote server",async()=>{const n=m("a"),t=r("a",{extensionKind:["ui","workspace"]},{location:g.file("pub.a")}),s=r("a",{extensionKind:["ui","workspace"]},{location:g.file("pub.a").with({scheme:D.vscodeRemote})}),o=E([s]),l=new M;o.onDidInstallExtensions=l.event;const u=A(e,E([t]),o);e.stub(k,u),e.stub(I,i.add(new S(e)));const w=i.add(e.createInstance(p));e.set(c,w);const v=new M;e.stub(R,{extensions:[T(s)],onDidChangeExtensions:v.event,canAddExtension:N=>!1,whenInstalledExtensionsRegistered:()=>Promise.resolve(!0)});const P=i.add(e.createInstance(d.ExtensionRuntimeStateAction));i.add(e.createInstance(x,[P])),e.stubPromise(b,"query",f(n)),await w.queryGallery(y.None);const G=await w.queryLocal(u.remoteExtensionManagementServer);P.extension=G[0],a.ok(P.extension),a.ok(P.enabled)}),test("Test Runtime State when ui+workspace+web extension is installed in web and remote and running in remote",async()=>{const n=m("a"),t=r("a",{extensionKind:["ui","workspace"],browser:"browser.js"},{location:g.file("pub.a").with({scheme:D.vscodeUserData})}),s=r("a",{extensionKind:["ui","workspace"],browser:"browser.js"},{location:g.file("pub.a").with({scheme:D.vscodeRemote})}),o=A(e,null,E([s]),E([t]));e.stub(k,o),e.stub(I,i.add(new S(e))),e.stub(R,{extensions:[T(s)],onDidChangeExtensions:q.None,canAddExtension:v=>!1,whenInstalledExtensionsRegistered:()=>Promise.resolve(!0)});const l=i.add(e.createInstance(p));e.set(c,l);const u=i.add(e.createInstance(d.ExtensionRuntimeStateAction));i.add(e.createInstance(x,[u])),e.stubPromise(b,"query",f(n)),await l.queryGallery(y.None);const w=await l.queryLocal(o.remoteExtensionManagementServer);u.extension=w[0],a.ok(u.extension),a.ok(!u.enabled)}),test("Test Runtime State when workspace+ui+web extension is installed in web and local and running in local",async()=>{const n=m("a"),t=r("a",{extensionKind:["workspace","ui"],browser:"browser.js"},{location:g.file("pub.a").with({scheme:D.vscodeUserData})}),s=r("a",{extensionKind:["workspace","ui"],browser:"browser.js"},{location:g.file("pub.a")}),o=A(e,E([s]),null,E([t]));e.stub(k,o),e.stub(I,i.add(new S(e))),e.stub(R,{extensions:[T(s)],onDidChangeExtensions:q.None,canAddExtension:v=>!1,whenInstalledExtensionsRegistered:()=>Promise.resolve(!0)});const l=i.add(e.createInstance(p));e.set(c,l);const u=i.add(e.createInstance(d.ExtensionRuntimeStateAction));i.add(e.createInstance(x,[u])),e.stubPromise(b,"query",f(n)),await l.queryGallery(y.None);const w=await l.queryLocal(o.remoteExtensionManagementServer);u.extension=w[0],a.ok(u.extension),a.ok(!u.enabled)})}),suite("RemoteInstallAction",()=>{const i=z();setup(()=>V(i)),test("Test remote install action is enabled for local workspace extension",async()=>{const n=r("a",{extensionKind:["workspace"]},{location:g.file("pub.a")}),t=A(e,E([n]));e.stub(k,t),e.stub(I,i.add(new S(e)));const s=i.add(e.createInstance(p));e.set(c,s),e.stubPromise(b,"query",f(m("a",{identifier:n.identifier})));const o=i.add(e.createInstance(d.RemoteInstallAction,!1));i.add(e.createInstance(x,[o]));const l=await s.queryLocal(t.localExtensionManagementServer);await s.queryGallery(y.None),o.extension=l[0],a.ok(o.enabled),a.strictEqual("Install in remote",o.label),a.strictEqual("extension-action label prominent install-other-server",o.class)}),test("Test remote install action when installing local workspace extension",async()=>{const n=E(),t=new M;n.onInstallExtension=t.event;const s=r("a",{extensionKind:["workspace"]},{location:g.file("pub.a")}),o=A(e,E([s]),n);e.stub(k,o),e.stub(I,i.add(new S(e)));const l=i.add(e.createInstance(p));e.stub(c,l,"open",void 0),e.set(c,l);const u=m("a",{identifier:s.identifier});e.stubPromise(b,"query",f(u));const w=i.add(e.createInstance(d.RemoteInstallAction,!1));i.add(e.createInstance(x,[w]));const v=await l.queryLocal(o.localExtensionManagementServer);await l.queryGallery(y.None),w.extension=v[0],a.ok(w.enabled),a.strictEqual("Install in remote",w.label),a.strictEqual("extension-action label prominent install-other-server",w.class),t.fire({identifier:s.identifier,source:u,profileLocation:null}),a.ok(w.enabled),a.strictEqual("Installing",w.label),a.strictEqual("extension-action label install-other-server installing",w.class)}),test("Test remote install action when installing local workspace extension is finished",async()=>{const n=E(),t=new M;n.onInstallExtension=t.event;const s=new M;n.onDidInstallExtensions=s.event;const o=r("a",{extensionKind:["workspace"]},{location:g.file("pub.a")}),l=A(e,E([o]),n);e.stub(k,l),e.stub(I,i.add(new S(e)));const u=i.add(e.createInstance(p));e.stub(c,u,"open",void 0),e.set(c,u);const w=m("a",{identifier:o.identifier});e.stubPromise(b,"query",f(w));const v=i.add(e.createInstance(d.RemoteInstallAction,!1));i.add(e.createInstance(x,[v]));const P=await u.queryLocal(l.localExtensionManagementServer);await u.queryGallery(y.None),v.extension=P[0],a.ok(v.enabled),a.strictEqual("Install in remote",v.label),a.strictEqual("extension-action label prominent install-other-server",v.class),t.fire({identifier:o.identifier,source:w,profileLocation:null}),a.ok(v.enabled),a.strictEqual("Installing",v.label),a.strictEqual("extension-action label install-other-server installing",v.class);const G=r("a",{extensionKind:["workspace"]},{location:g.file("pub.a").with({scheme:D.vscodeRemote})}),N=q.toPromise(v.onDidChange);s.fire([{identifier:G.identifier,local:G,operation:W.Install,profileLocation:null}]),await N,a.ok(!v.enabled)}),test("Test remote install action is enabled for disabled local workspace extension",async()=>{const n=r("a",{extensionKind:["workspace"]},{location:g.file("pub.a")}),t=A(e,E([n]));e.stub(k,t),e.stub(I,i.add(new S(e)));const s=i.add(e.createInstance(p));e.set(c,s);const o=r("a",{extensionKind:["workspace"]},{location:g.file("pub.a").with({scheme:D.vscodeRemote})});await e.get(I).setEnablement([o],L.DisabledGlobally),e.stubPromise(b,"query",f(m("a",{identifier:n.identifier})));const l=i.add(e.createInstance(d.RemoteInstallAction,!1));i.add(e.createInstance(x,[l]));const u=await s.queryLocal(t.localExtensionManagementServer);await s.queryGallery(y.None),l.extension=u[0],a.ok(l.enabled),a.strictEqual("Install in remote",l.label),a.strictEqual("extension-action label prominent install-other-server",l.class)}),test("Test remote install action is enabled local workspace+ui extension",async()=>{const n=r("a",{extensionKind:["workspace","ui"]},{location:g.file("pub.a")}),t=A(e,E([n]));e.stub(k,t),e.stub(I,i.add(new S(e)));const s=i.add(e.createInstance(p));e.set(c,s),await e.get(I).setEnablement([n],L.DisabledGlobally),e.stubPromise(b,"query",f(m("a",{identifier:n.identifier})));const o=i.add(e.createInstance(d.RemoteInstallAction,!1));i.add(e.createInstance(x,[o]));const l=await s.queryLocal(t.localExtensionManagementServer);await s.queryGallery(y.None),o.extension=l[0],a.ok(o.enabled),a.strictEqual("Install in remote",o.label),a.strictEqual("extension-action label prominent install-other-server",o.class)}),test("Test remote install action is enabled for local ui+workapace extension if can install is true",async()=>{const n=r("a",{extensionKind:["ui","workspace"]},{location:g.file("pub.a")}),t=A(e,E([n]));e.stub(k,t),e.stub(I,i.add(new S(e)));const s=i.add(e.createInstance(p));e.set(c,s),await e.get(I).setEnablement([n],L.DisabledGlobally),e.stubPromise(b,"query",f(m("a",{identifier:n.identifier})));const o=i.add(e.createInstance(d.RemoteInstallAction,!0));i.add(e.createInstance(x,[o]));const l=await s.queryLocal(t.localExtensionManagementServer);await s.queryGallery(y.None),o.extension=l[0],a.ok(o.enabled),a.strictEqual("Install in remote",o.label),a.strictEqual("extension-action label prominent install-other-server",o.class)}),test("Test remote install action is disabled for local ui+workapace extension if can install is false",async()=>{const n=r("a",{extensionKind:["ui","workspace"]},{location:g.file("pub.a")}),t=A(e,E([n]));e.stub(k,t),e.stub(I,i.add(new S(e)));const s=i.add(e.createInstance(p));e.set(c,s),await e.get(I).setEnablement([n],L.DisabledGlobally),e.stubPromise(b,"query",f(m("a",{identifier:n.identifier})));const o=i.add(e.createInstance(d.RemoteInstallAction,!1));i.add(e.createInstance(x,[o]));const l=await s.queryLocal(t.localExtensionManagementServer);await s.queryGallery(y.None),o.extension=l[0],a.ok(!o.enabled)}),test("Test remote install action is disabled when extension is not set",async()=>{const n=r("a",{extensionKind:["workspace"]},{location:g.file("pub.a")}),t=A(e,E([n]));e.stub(I,i.add(new S(e)));const s=i.add(e.createInstance(p));e.set(c,s),e.stubPromise(b,"query",f(m("a",{identifier:n.identifier})));const o=i.add(e.createInstance(d.RemoteInstallAction,!1));i.add(e.createInstance(x,[o])),await s.queryLocal(t.localExtensionManagementServer),await s.queryGallery(y.None),a.ok(!o.enabled)}),test("Test remote install action is disabled for extension which is not installed",async()=>{const n=A(e);e.stub(k,n),e.stub(I,i.add(new S(e)));const t=i.add(e.createInstance(p));e.set(c,t),e.stubPromise(b,"query",f(m("a")));const s=i.add(e.createInstance(d.RemoteInstallAction,!1));i.add(e.createInstance(x,[s]));const o=await t.queryGallery(y.None);s.extension=o.firstPage[0],a.ok(s.extension),a.ok(!s.enabled)}),test("Test remote install action is disabled for local workspace extension which is disabled in env",async()=>{const n=r("a",{extensionKind:["workspace"]},{location:g.file("pub.a")}),t=A(e,E([n])),s={disableExtensions:!0};e.stub($,s),e.stub(ne,s),e.stub(_,s),e.stub(ee,s),e.stub(k,t),e.stub(I,i.add(new S(e)));const o=i.add(e.createInstance(p));e.set(c,o),e.stubPromise(b,"query",f(m("a",{identifier:n.identifier})));const l=i.add(e.createInstance(d.RemoteInstallAction,!1));i.add(e.createInstance(x,[l]));const u=await o.queryLocal(t.localExtensionManagementServer);await o.queryGallery(y.None),l.extension=u[0],a.ok(l.extension),a.ok(!l.enabled)}),test("Test remote install action is disabled when remote server is not available",async()=>{const n=e.get(c),t=e.get(k),s=r("a",{extensionKind:["workspace"]},{location:g.file("pub.a")});e.stubPromise(h,"getInstalled",[s]),e.stubPromise(b,"query",f(m("a",{identifier:s.identifier})));const o=i.add(e.createInstance(d.RemoteInstallAction,!1));i.add(e.createInstance(x,[o]));const l=await n.queryLocal(t.localExtensionManagementServer);await n.queryGallery(y.None),o.extension=l[0],a.ok(o.extension),a.ok(!o.enabled)}),test("Test remote install action is disabled for local workspace extension if it is uninstalled locally",async()=>{const n=e.get(h),t=A(e,n);e.stub(k,t),e.stub(I,i.add(new S(e)));const s=r("a",{extensionKind:["workspace"]},{location:g.file("pub.a")});e.stubPromise(h,"getInstalled",[s]);const o=i.add(e.createInstance(p));e.set(c,o),e.stubPromise(b,"query",f(m("a",{identifier:s.identifier})));const l=i.add(e.createInstance(d.RemoteInstallAction,!1));i.add(e.createInstance(x,[l]));const u=await o.queryLocal(t.localExtensionManagementServer);await o.queryGallery(y.None),l.extension=u[0],a.ok(l.enabled),a.strictEqual("Install in remote",l.label),O.fire({identifier:s.identifier,profileLocation:null}),a.ok(!l.enabled)}),test("Test remote install action is disabled for local workspace extension if it is installed in remote",async()=>{const n=r("a",{extensionKind:["workspace"]},{location:g.file("pub.a")}),t=r("a",{extensionKind:["workspace"]},{location:g.file("pub.a").with({scheme:D.vscodeRemote})}),s=A(e,E([n]),E([t]));e.stub(k,s),e.stub(I,i.add(new S(e)));const o=i.add(e.createInstance(p));e.set(c,o),e.stubPromise(b,"query",f(m("a",{identifier:n.identifier})));const l=i.add(e.createInstance(d.RemoteInstallAction,!1));i.add(e.createInstance(x,[l]));const u=await o.queryLocal(s.localExtensionManagementServer);await o.queryGallery(y.None),l.extension=u[0],a.ok(l.extension),a.ok(!l.enabled)}),test("Test remote install action is enabled for local workspace extension if it has not gallery",async()=>{const n=r("a",{extensionKind:["workspace"]},{location:g.file("pub.a")}),t=A(e,E([n]));e.stub(k,t),e.stub(I,i.add(new S(e)));const s=i.add(e.createInstance(p));e.set(c,s),e.stubPromise(b,"query",f(m("a",{identifier:n.identifier})));const o=i.add(e.createInstance(d.RemoteInstallAction,!1));i.add(e.createInstance(x,[o]));const l=await s.queryLocal(t.localExtensionManagementServer);o.extension=l[0],a.ok(o.extension),a.ok(o.enabled)}),test("Test remote install action is disabled for local workspace system extension",async()=>{const n=r("a",{extensionKind:["workspace"]},{location:g.file("pub.a"),type:K.System}),t=A(e,E([n]));e.stub(k,t),e.stub(I,i.add(new S(e)));const s=i.add(e.createInstance(p));e.set(c,s),e.stubPromise(b,"query",f(m("a",{identifier:n.identifier})));const o=i.add(e.createInstance(d.RemoteInstallAction,!1));i.add(e.createInstance(x,[o]));const l=await s.queryLocal(t.localExtensionManagementServer);o.extension=l[0],a.ok(o.extension),a.ok(!o.enabled)}),test("Test remote install action is disabled for local ui extension if it is not installed in remote",async()=>{const n=r("a",{extensionKind:["ui"]},{location:g.file("pub.a")}),t=A(e,E([n]));e.stub(k,t),e.stub(I,i.add(new S(e)));const s=i.add(e.createInstance(p));e.set(c,s),e.stubPromise(b,"query",f(m("a",{identifier:n.identifier})));const o=i.add(e.createInstance(d.RemoteInstallAction,!1));i.add(e.createInstance(x,[o]));const l=await s.queryLocal(t.localExtensionManagementServer);o.extension=l[0],a.ok(o.extension),a.ok(!o.enabled)}),test("Test remote install action is disabled for local ui extension if it is also installed in remote",async()=>{const n=r("a",{extensionKind:["ui"]},{location:g.file("pub.a")}),t=r("a",{extensionKind:["ui"]},{location:g.file("pub.a").with({scheme:D.vscodeRemote})}),s=A(e,E([n]),E([t]));e.stub(k,s),e.stub(I,i.add(new S(e)));const o=i.add(e.createInstance(p));e.set(c,o),e.stubPromise(b,"query",f(m("a",{identifier:n.identifier})));const l=i.add(e.createInstance(d.RemoteInstallAction,!1));i.add(e.createInstance(x,[l]));const u=await o.queryLocal(s.localExtensionManagementServer);l.extension=u[0],a.ok(l.extension),a.ok(!l.enabled)}),test("Test remote install action is enabled for locally installed language pack extension",async()=>{const n=r("a",{contributes:{localizations:[{languageId:"de",translations:[]}]}},{location:g.file("pub.a")}),t=A(e,E([n]));e.stub(k,t),e.stub(I,i.add(new S(e)));const s=i.add(e.createInstance(p));e.set(c,s),e.stubPromise(b,"query",f(m("a",{identifier:n.identifier})));const o=i.add(e.createInstance(d.RemoteInstallAction,!1));i.add(e.createInstance(x,[o]));const l=await s.queryLocal(t.localExtensionManagementServer);await s.queryGallery(y.None),o.extension=l[0],a.ok(o.enabled),a.strictEqual("Install in remote",o.label),a.strictEqual("extension-action label prominent install-other-server",o.class)}),test("Test remote install action is disabled if local language pack extension is uninstalled",async()=>{const n=e.get(h),t=A(e,n);e.stub(k,t),e.stub(I,i.add(new S(e)));const s=r("a",{contributes:{localizations:[{languageId:"de",translations:[]}]}},{location:g.file("pub.a")});e.stubPromise(h,"getInstalled",[s]);const o=i.add(e.createInstance(p));e.set(c,o),e.stubPromise(b,"query",f(m("a",{identifier:s.identifier})));const l=i.add(e.createInstance(d.RemoteInstallAction,!1));i.add(e.createInstance(x,[l]));const u=await o.queryLocal(t.localExtensionManagementServer);await o.queryGallery(y.None),l.extension=u[0],a.ok(l.enabled),a.strictEqual("Install in remote",l.label),O.fire({identifier:s.identifier,profileLocation:null}),a.ok(!l.enabled)})}),suite("LocalInstallAction",()=>{const i=z();setup(()=>V(i)),test("Test local install action is enabled for remote ui extension",async()=>{const n=r("a",{extensionKind:["ui"]},{location:g.file("pub.a").with({scheme:D.vscodeRemote})}),t=A(e,E(),E([n]));e.stub(k,t),e.stub(I,i.add(new S(e)));const s=i.add(e.createInstance(p));e.set(c,s),e.stubPromise(b,"query",f(m("a",{identifier:n.identifier})));const o=i.add(e.createInstance(d.LocalInstallAction));i.add(e.createInstance(x,[o]));const l=await s.queryLocal(t.remoteExtensionManagementServer);await s.queryGallery(y.None),o.extension=l[0],a.ok(o.enabled),a.strictEqual("Install Locally",o.label),a.strictEqual("extension-action label prominent install-other-server",o.class)}),test("Test local install action is enabled for remote ui+workspace extension",async()=>{const n=r("a",{extensionKind:["ui","workspace"]},{location:g.file("pub.a").with({scheme:D.vscodeRemote})}),t=A(e,E(),E([n]));e.stub(k,t),e.stub(I,i.add(new S(e)));const s=i.add(e.createInstance(p));e.set(c,s),e.stubPromise(b,"query",f(m("a",{identifier:n.identifier})));const o=i.add(e.createInstance(d.LocalInstallAction));i.add(e.createInstance(x,[o]));const l=await s.queryLocal(t.remoteExtensionManagementServer);await s.queryGallery(y.None),o.extension=l[0],a.ok(o.enabled),a.strictEqual("Install Locally",o.label),a.strictEqual("extension-action label prominent install-other-server",o.class)}),test("Test local install action when installing remote ui extension",async()=>{const n=E(),t=new M;n.onInstallExtension=t.event;const s=r("a",{extensionKind:["ui"]},{location:g.file("pub.a").with({scheme:D.vscodeRemote})}),o=A(e,n,E([s]));e.stub(k,o),e.stub(I,i.add(new S(e)));const l=i.add(e.createInstance(p));e.stub(c,l,"open",void 0),e.set(c,l);const u=m("a",{identifier:s.identifier});e.stubPromise(b,"query",f(u));const w=i.add(e.createInstance(d.LocalInstallAction));i.add(e.createInstance(x,[w]));const v=await l.queryLocal(o.remoteExtensionManagementServer);await l.queryGallery(y.None),w.extension=v[0],a.ok(w.enabled),a.strictEqual("Install Locally",w.label),a.strictEqual("extension-action label prominent install-other-server",w.class),t.fire({identifier:s.identifier,source:u,profileLocation:null}),a.ok(w.enabled),a.strictEqual("Installing",w.label),a.strictEqual("extension-action label install-other-server installing",w.class)}),test("Test local install action when installing remote ui extension is finished",async()=>{const n=E(),t=new M;n.onInstallExtension=t.event;const s=new M;n.onDidInstallExtensions=s.event;const o=r("a",{extensionKind:["ui"]},{location:g.file("pub.a").with({scheme:D.vscodeRemote})}),l=A(e,n,E([o]));e.stub(k,l),e.stub(I,i.add(new S(e)));const u=i.add(e.createInstance(p));e.stub(c,u,"open",void 0),e.set(c,u);const w=m("a",{identifier:o.identifier});e.stubPromise(b,"query",f(w));const v=i.add(e.createInstance(d.LocalInstallAction));i.add(e.createInstance(x,[v]));const P=await u.queryLocal(l.remoteExtensionManagementServer);await u.queryGallery(y.None),v.extension=P[0],a.ok(v.enabled),a.strictEqual("Install Locally",v.label),a.strictEqual("extension-action label prominent install-other-server",v.class),t.fire({identifier:o.identifier,source:w,profileLocation:null}),a.ok(v.enabled),a.strictEqual("Installing",v.label),a.strictEqual("extension-action label install-other-server installing",v.class);const G=r("a",{extensionKind:["ui"]},{location:g.file("pub.a")}),N=q.toPromise(v.onDidChange);s.fire([{identifier:G.identifier,local:G,operation:W.Install,profileLocation:null}]),await N,a.ok(!v.enabled)}),test("Test local install action is enabled for disabled remote ui extension",async()=>{const n=r("a",{extensionKind:["ui"]},{location:g.file("pub.a").with({scheme:D.vscodeRemote})}),t=A(e,E(),E([n]));e.stub(k,t),e.stub(I,i.add(new S(e)));const s=i.add(e.createInstance(p));e.set(c,s);const o=r("a",{extensionKind:["ui"]},{location:g.file("pub.a")});await e.get(I).setEnablement([o],L.DisabledGlobally),e.stubPromise(b,"query",f(m("a",{identifier:n.identifier})));const l=i.add(e.createInstance(d.LocalInstallAction));i.add(e.createInstance(x,[l]));const u=await s.queryLocal(t.remoteExtensionManagementServer);await s.queryGallery(y.None),l.extension=u[0],a.ok(l.enabled),a.strictEqual("Install Locally",l.label),a.strictEqual("extension-action label prominent install-other-server",l.class)}),test("Test local install action is disabled when extension is not set",async()=>{const n=r("a",{extensionKind:["ui"]},{location:g.file("pub.a").with({scheme:D.vscodeRemote})}),t=A(e,E(),E([n]));e.stub(I,i.add(new S(e)));const s=i.add(e.createInstance(p));e.set(c,s),e.stubPromise(b,"query",f(m("a",{identifier:n.identifier})));const o=i.add(e.createInstance(d.LocalInstallAction));i.add(e.createInstance(x,[o])),await s.queryLocal(t.remoteExtensionManagementServer),await s.queryGallery(y.None),a.ok(!o.enabled)}),test("Test local install action is disabled for extension which is not installed",async()=>{const n=A(e);e.stub(k,n),e.stub(I,i.add(new S(e)));const t=i.add(e.createInstance(p));e.set(c,t),e.stubPromise(b,"query",f(m("a")));const s=i.add(e.createInstance(d.LocalInstallAction));i.add(e.createInstance(x,[s]));const o=await t.queryGallery(y.None);s.extension=o.firstPage[0],a.ok(s.extension),a.ok(!s.enabled)}),test("Test local install action is disabled for remote ui extension which is disabled in env",async()=>{const n=r("a",{extensionKind:["ui"]},{location:g.file("pub.a").with({scheme:D.vscodeRemote})}),t={disableExtensions:!0};e.stub($,t),e.stub(ne,t),e.stub(_,t),e.stub(ee,t);const s=A(e,E(),E([n]));e.stub(k,s),e.stub(I,i.add(new S(e)));const o=i.add(e.createInstance(p));e.set(c,o),e.stubPromise(b,"query",f(m("a",{identifier:n.identifier})));const l=i.add(e.createInstance(d.LocalInstallAction));i.add(e.createInstance(x,[l]));const u=await o.queryLocal(s.remoteExtensionManagementServer);await o.queryGallery(y.None),l.extension=u[0],a.ok(l.extension),a.ok(!l.enabled)}),test("Test local install action is disabled when local server is not available",async()=>{const n=r("a",{extensionKind:["ui"]},{location:g.file("pub.a").with({scheme:D.vscodeRemote})}),t=Ke(e,E([n]));e.stub(k,t),e.stub(I,i.add(new S(e)));const s=i.add(e.createInstance(p));e.set(c,s),e.stubPromise(b,"query",f(m("a",{identifier:n.identifier})));const o=i.add(e.createInstance(d.LocalInstallAction));i.add(e.createInstance(x,[o]));const l=await s.queryLocal(t.remoteExtensionManagementServer);await s.queryGallery(y.None),o.extension=l[0],a.ok(o.extension),a.ok(!o.enabled)}),test("Test local install action is disabled for remote ui extension if it is installed in local",async()=>{const n=r("a",{extensionKind:["ui"]},{location:g.file("pub.a")}),t=r("a",{extensionKind:["ui"]},{location:g.file("pub.a").with({scheme:D.vscodeRemote})}),s=A(e,E([n]),E([t]));e.stub(k,s),e.stub(I,i.add(new S(e)));const o=i.add(e.createInstance(p));e.set(c,o),e.stubPromise(b,"query",f(m("a",{identifier:n.identifier})));const l=i.add(e.createInstance(d.LocalInstallAction));i.add(e.createInstance(x,[l]));const u=await o.queryLocal(s.remoteExtensionManagementServer);await o.queryGallery(y.None),l.extension=u[0],a.ok(l.extension),a.ok(!l.enabled)}),test("Test local install action is disabled for remoteUI extension if it is uninstalled locally",async()=>{const n=e.get(h),t=A(e,E(),n);e.stub(k,t),e.stub(I,i.add(new S(e)));const s=r("a",{extensionKind:["ui"]},{location:g.file("pub.a").with({scheme:D.vscodeRemote})});e.stubPromise(h,"getInstalled",[s]);const o=i.add(e.createInstance(p));e.set(c,o),e.stubPromise(b,"query",f(m("a",{identifier:s.identifier})));const l=i.add(e.createInstance(d.LocalInstallAction));i.add(e.createInstance(x,[l]));const u=await o.queryLocal(t.remoteExtensionManagementServer);await o.queryGallery(y.None),l.extension=u[0],a.ok(l.enabled),a.strictEqual("Install Locally",l.label),O.fire({identifier:s.identifier,profileLocation:null}),a.ok(!l.enabled)}),test("Test local install action is enabled for remote UI extension if it has gallery",async()=>{const n=r("a",{extensionKind:["ui"]},{location:g.file("pub.a").with({scheme:D.vscodeRemote})}),t=A(e,E(),E([n]));e.stub(k,t),e.stub(I,i.add(new S(e)));const s=i.add(e.createInstance(p));e.set(c,s),e.stubPromise(b,"query",f(m("a",{identifier:n.identifier})));const o=i.add(e.createInstance(d.LocalInstallAction));i.add(e.createInstance(x,[o]));const l=await s.queryLocal(t.remoteExtensionManagementServer);o.extension=l[0],a.ok(o.extension),a.ok(o.enabled)}),test("Test local install action is disabled for remote UI system extension",async()=>{const n=r("a",{extensionKind:["ui"]},{location:g.file("pub.a").with({scheme:D.vscodeRemote}),type:K.System}),t=A(e,E(),E([n]));e.stub(k,t),e.stub(I,i.add(new S(e)));const s=i.add(e.createInstance(p));e.set(c,s),e.stubPromise(b,"query",f(m("a",{identifier:n.identifier})));const o=i.add(e.createInstance(d.LocalInstallAction));i.add(e.createInstance(x,[o]));const l=await s.queryLocal(t.remoteExtensionManagementServer);o.extension=l[0],a.ok(o.extension),a.ok(!o.enabled)}),test("Test local install action is disabled for remote workspace extension if it is not installed in local",async()=>{const n=r("a",{extensionKind:["workspace"]},{location:g.file("pub.a").with({scheme:D.vscodeRemote})}),t=A(e,E(),E([n]));e.stub(k,t),e.stub(I,i.add(new S(e)));const s=i.add(e.createInstance(p));e.set(c,s),e.stubPromise(b,"query",f(m("a",{identifier:n.identifier})));const o=i.add(e.createInstance(d.LocalInstallAction));i.add(e.createInstance(x,[o]));const l=await s.queryLocal(t.remoteExtensionManagementServer);o.extension=l[0],a.ok(o.extension),a.ok(!o.enabled)}),test("Test local install action is disabled for remote workspace extension if it is also installed in local",async()=>{const n=r("a",{extensionKind:["workspae"]},{location:g.file("pub.a")}),t=r("a",{extensionKind:["workspace"]},{location:g.file("pub.a").with({scheme:D.vscodeRemote})}),s=A(e,E([n]),E([t]));e.stub(k,s),e.stub(I,i.add(new S(e)));const o=i.add(e.createInstance(p));e.set(c,o),e.stubPromise(b,"query",f(m("a",{identifier:n.identifier})));const l=i.add(e.createInstance(d.LocalInstallAction));i.add(e.createInstance(x,[l]));const u=await o.queryLocal(s.remoteExtensionManagementServer);l.extension=u[0],a.ok(l.extension),a.ok(!l.enabled)}),test("Test local install action is enabled for remotely installed language pack extension",async()=>{const n=r("a",{contributes:{localizations:[{languageId:"de",translations:[]}]}},{location:g.file("pub.a").with({scheme:D.vscodeRemote})}),t=A(e,E(),E([n]));e.stub(k,t),e.stub(I,i.add(new S(e)));const s=i.add(e.createInstance(p));e.set(c,s),e.stubPromise(b,"query",f(m("a",{identifier:n.identifier})));const o=i.add(e.createInstance(d.LocalInstallAction));i.add(e.createInstance(x,[o]));const l=await s.queryLocal(t.remoteExtensionManagementServer);await s.queryGallery(y.None),o.extension=l[0],a.ok(o.enabled),a.strictEqual("Install Locally",o.label),a.strictEqual("extension-action label prominent install-other-server",o.class)}),test("Test local install action is disabled if remote language pack extension is uninstalled",async()=>{const n=e.get(h),t=A(e,E(),n);e.stub(k,t),e.stub(I,i.add(new S(e)));const s=r("a",{contributes:{localizations:[{languageId:"de",translations:[]}]}},{location:g.file("pub.a").with({scheme:D.vscodeRemote})});e.stubPromise(h,"getInstalled",[s]);const o=i.add(e.createInstance(p));e.set(c,o),e.stubPromise(b,"query",f(m("a",{identifier:s.identifier})));const l=i.add(e.createInstance(d.LocalInstallAction));i.add(e.createInstance(x,[l]));const u=await o.queryLocal(t.remoteExtensionManagementServer);await o.queryGallery(y.None),l.extension=u[0],a.ok(l.enabled),a.strictEqual("Install Locally",l.label),O.fire({identifier:s.identifier,profileLocation:null}),a.ok(!l.enabled)})});function r(i="someext",n={},t={}){return n={name:i,publisher:"pub",version:"1.0.0",...n},t={type:K.User,location:g.file(`pub.${i}`),identifier:{id:X(n.publisher,n.name)},...t},t.isBuiltin=t.type===K.System,Object.create({manifest:n,...t})}function m(i,n={},t={},s={}){const o=B(H,J),l=Object.create({name:i,publisher:"pub",version:"1.0.0",allTargetPlatforms:[o],properties:{},assets:{},...n});return l.properties={...l.properties,dependencies:[],targetPlatform:o,...t},l.assets={...l.assets,...s},l.identifier={id:X(l.publisher,l.name),uuid:te()},l.hasReleaseVersion=!0,l}function f(...i){return{firstPage:i,total:i.length,pageSize:i.length,getPage:()=>null}}function Ke(i,n){const t={id:"vscode-remote",label:"remote",extensionManagementService:n||E()};return{_serviceBrand:void 0,localExtensionManagementServer:null,remoteExtensionManagementServer:t,webExtensionManagementServer:null,getExtensionManagementServer:s=>s.location.scheme===D.vscodeRemote?t:null,getExtensionInstallLocation(s){return this.getExtensionManagementServer(s)===t?F.Remote:F.Local}}}function A(i,n,t,s){const o=n===null?null:{id:"vscode-local",label:"local",extensionManagementService:n||E()},l=t===null?null:{id:"vscode-remote",label:"remote",extensionManagementService:t||E()},u=s?{id:"vscode-web",label:"web",extensionManagementService:s}:null;return{_serviceBrand:void 0,localExtensionManagementServer:o,remoteExtensionManagementServer:l,webExtensionManagementServer:u,getExtensionManagementServer:w=>{if(w.location.scheme===D.file)return o;if(w.location.scheme===D.vscodeRemote)return l;if(w.location.scheme===D.vscodeUserData)return u;throw new Error("")},getExtensionInstallLocation(w){const v=this.getExtensionManagementServer(w);return v===null?null:v===l?F.Remote:v===u?F.Web:F.Local}}}function E(i=[]){return{onInstallExtension:q.None,onDidInstallExtensions:q.None,onUninstallExtension:q.None,onDidUninstallExtension:q.None,onDidChangeProfile:q.None,onDidUpdateExtensionMetadata:q.None,getInstalled:()=>Promise.resolve(i),canInstall:async n=>!0,installFromGallery:n=>Promise.reject(new Error("not supported")),updateMetadata:async(n,t,s)=>(n.identifier.uuid=t.id,n.publisherDisplayName=t.publisherDisplayName,n.publisherId=t.publisherId,n),async getTargetPlatform(){return B(H,J)},async getExtensionsControlManifest(){return{malicious:[],deprecated:{},search:[]}}}}
