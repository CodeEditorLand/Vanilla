var We=Object.defineProperty;var xe=Object.getOwnPropertyDescriptor;var me=(H,_,e,t)=>{for(var s=t>1?void 0:t?xe(_,e):_,i=H.length-1,r;i>=0;i--)(r=H[i])&&(s=(t?r(_,e,s):r(s))||s);return t&&s&&We(_,e,s),s},T=(H,_)=>(e,t)=>_(e,t,H);import{Action as Me}from"../../../../base/common/actions.js";import{raceTimeout as se}from"../../../../base/common/async.js";import{CancellationTokenSource as _e}from"../../../../base/common/cancellation.js";import"../../../../base/common/collections.js";import{Emitter as B,Event as ue}from"../../../../base/common/event.js";import*as ze from"../../../../base/common/glob.js";import*as De from"../../../../base/common/json.js";import{toFormattedString as Oe}from"../../../../base/common/jsonFormatter.js";import{Disposable as Ue,dispose as Ve}from"../../../../base/common/lifecycle.js";import{LRUCache as le,Touch as ve}from"../../../../base/common/map.js";import{Schemas as Ae}from"../../../../base/common/network.js";import*as ie from"../../../../base/common/objects.js";import{ValidationState as $,ValidationStatus as Ke}from"../../../../base/common/parsers.js";import*as Y from"../../../../base/common/platform.js";import{TerminateResponseCode as Qe}from"../../../../base/common/processes.js";import*as te from"../../../../base/common/resources.js";import z from"../../../../base/common/severity.js";import{ThemeIcon as Ne}from"../../../../base/common/themables.js";import*as E from"../../../../base/common/types.js";import{URI as Le}from"../../../../base/common/uri.js";import*as Ge from"../../../../base/common/uuid.js";import{IModelService as je}from"../../../../editor/common/services/model.js";import{ITextModelService as Be}from"../../../../editor/common/services/resolverService.js";import*as l from"../../../../nls.js";import{CommandsRegistry as P,ICommandService as Je}from"../../../../platform/commands/common/commands.js";import{ConfigurationTarget as J,IConfigurationService as qe}from"../../../../platform/configuration/common/configuration.js";import{IContextKeyService as He}from"../../../../platform/contextkey/common/contextkey.js";import{IDialogService as $e}from"../../../../platform/dialogs/common/dialogs.js";import{TextEditorSelectionRevealType as Ye}from"../../../../platform/editor/common/editor.js";import{IFileService as Xe}from"../../../../platform/files/common/files.js";import{IInstantiationService as Ze}from"../../../../platform/instantiation/common/instantiation.js";import{ILogService as et}from"../../../../platform/log/common/log.js";import{IMarkerService as tt}from"../../../../platform/markers/common/markers.js";import{INotificationService as st}from"../../../../platform/notification/common/notification.js";import{IOpenerService as it}from"../../../../platform/opener/common/opener.js";import{IProgressService as rt,ProgressLocation as nt}from"../../../../platform/progress/common/progress.js";import{IQuickInputService as ot}from"../../../../platform/quickinput/common/quickInput.js";import{IStorageService as at,StorageScope as D,StorageTarget as de}from"../../../../platform/storage/common/storage.js";import{ITelemetryService as ct}from"../../../../platform/telemetry/common/telemetry.js";import{TerminalExitReason as ut}from"../../../../platform/terminal/common/terminal.js";import{IThemeService as lt}from"../../../../platform/theme/common/themeService.js";import{IWorkspaceContextService as dt,WorkbenchState as W,WorkspaceFolder as ft}from"../../../../platform/workspace/common/workspace.js";import{IWorkspaceTrustManagementService as kt,IWorkspaceTrustRequestService as pt}from"../../../../platform/workspace/common/workspaceTrust.js";import{VirtualWorkspaceContext as Se}from"../../../common/contextkeys.js";import{EditorResourceAccessor as gt,SaveReason as ye}from"../../../common/editor.js";import{IViewDescriptorService as ht}from"../../../common/views.js";import{IConfigurationResolverService as Tt}from"../../../services/configurationResolver/common/configurationResolver.js";import{IEditorService as mt}from"../../../services/editor/common/editorService.js";import{IWorkbenchEnvironmentService as _t}from"../../../services/environment/common/environmentService.js";import{IExtensionService as vt}from"../../../services/extensions/common/extensions.js";import{ILifecycleService as St,ShutdownReason as yt,StartupKind as It}from"../../../services/lifecycle/common/lifecycle.js";import{IOutputService as bt}from"../../../services/output/common/output.js";import{IPaneCompositePartService as Ct}from"../../../services/panecomposite/browser/panecomposite.js";import{IPathService as wt}from"../../../services/path/common/pathService.js";import{IPreferencesService as Pt}from"../../../services/preferences/common/preferences.js";import{IRemoteAgentService as Rt}from"../../../services/remote/common/remoteAgentService.js";import{ITextFileService as Et}from"../../../services/textfile/common/textfiles.js";import{IViewsService as Ft}from"../../../services/views/common/viewsService.js";import{Markers as Wt}from"../../markers/common/markers.js";import{ITerminalGroupService as xt,ITerminalService as Mt}from"../../terminal/browser/terminal.js";import{ITerminalProfileResolverService as zt}from"../../terminal/common/terminal.js";import{ProblemMatcherRegistry as X}from"../common/problemMatcher.js";import*as b from"../common/taskConfiguration.js";import{TaskDefinitionRegistry as re}from"../common/taskDefinitionRegistry.js";import{ConfiguringTask as L,ContributedTask as F,CustomTask as C,ExecutionEngine as O,InMemoryTask as x,JsonSchemaVersion as M,KeyedTaskIdentifier as Dt,RuntimeType as fe,TASK_RUNNING_STATE as Ot,TaskDefinition as ne,TaskEventKind as ke,TaskGroup as R,TaskRunSource as S,TaskSettingId as G,TaskSorter as Ut,TaskSourceKind as y,TasksSchemaProperties as U,USER_TASKS_GROUP_KEY as Z}from"../common/tasks.js";import{CustomExecutionSupportedContext as Vt,ProcessExecutionSupportedContext as Ie,ServerlessWebContext as be,ShellExecutionSupportedContext as Ce,TaskCommandsRegistered as At,TaskExecutionSupportedContext as Kt}from"../common/taskService.js";import{TaskError as q,TaskErrors as V,TaskExecuteKind as Qt}from"../common/taskSystem.js";import{getTemplates as Nt}from"../common/taskTemplates.js";import{configureTaskIcon as Lt,isWorkspaceFolder as we,QUICKOPEN_DETAIL_CONFIG as Gt,QUICKOPEN_SKIP_CONFIG as Pe,TaskQuickPick as Q}from"./taskQuickPick.js";import{TerminalTaskSystem as pe}from"./terminalTaskSystem.js";const oe="task.quickOpen.history",ge="task.problemMatchers.neverPrompt",jt="task.quickOpen.showAll";var ae;(e=>(e.ID="workbench.action.tasks.configureTaskRunner",e.TEXT=l.localize2("ConfigureTaskRunnerAction.label","Configure Task")))(ae||={});class Re{constructor(_){this._outputChannel=_;this._validationStatus=new Ke}_validationStatus;info(_){this._validationStatus.state=$.Info,this._outputChannel.append(_+`
`)}warn(_){this._validationStatus.state=$.Warning,this._outputChannel.append(_+`
`)}error(_){this._validationStatus.state=$.Error,this._outputChannel.append(_+`
`)}fatal(_){this._validationStatus.state=$.Fatal,this._outputChannel.append(_+`
`)}get status(){return this._validationStatus}}class A{_store=new Map;forEach(_){this._store.forEach(_)}static getKey(_){let e;if(E.isString(_))e=_;else{const t=we(_)?_.uri:_.configuration;e=t?t.toString():""}return e}get(_){const e=A.getKey(_);let t=this._store.get(e);return t||(t=[],this._store.set(e,t)),t}add(_,...e){const t=A.getKey(_);let s=this._store.get(t);s||(s=[],this._store.set(t,s)),s.push(...e)}all(){const _=[];return this._store.forEach(e=>_.push(...e)),_}}let w=class extends Ue{constructor(e,t,s,i,r,n,a,d,u,o,c,f,g,h,p,k,m,I,N,K,ee,Bt,Ee,Jt,qt,Ht,$t,Yt,Xt,Zt,es,ts,ss,is,Fe,rs){super();this._configurationService=e;this._markerService=t;this._outputService=s;this._paneCompositeService=i;this._viewsService=r;this._commandService=n;this._editorService=a;this._fileService=d;this._contextService=u;this._telemetryService=o;this._textFileService=c;this._modelService=f;this._extensionService=g;this._quickInputService=h;this._configurationResolverService=p;this._terminalService=k;this._terminalGroupService=m;this._storageService=I;this._progressService=N;this._openerService=K;this._dialogService=ee;this._notificationService=Bt;this._contextKeyService=Ee;this._environmentService=Jt;this._terminalProfileResolverService=qt;this._pathService=Ht;this._textModelResolverService=$t;this._preferencesService=Yt;this._viewDescriptorService=Xt;this._workspaceTrustRequestService=Zt;this._workspaceTrustManagementService=es;this._logService=ts;this._themeService=ss;this._lifecycleService=is;this._instantiationService=rs;this._whenTaskSystemReady=ue.toPromise(this.onDidChangeTaskSystemInfo),this._workspaceTasksPromise=void 0,this._taskSystem=void 0,this._taskSystemListeners=void 0,this._outputChannel=this._outputService.getChannel(w.OutputChannelId),this._providers=new Map,this._providerTypes=new Map,this._taskSystemInfos=new Map,this._register(this._contextService.onDidChangeWorkspaceFolders(()=>{const v=this._computeWorkspaceFolderSetup();return this.executionEngine!==v[2]&&(this._disposeTaskSystemListeners(),this._taskSystem=void 0),this._updateSetup(v),this._updateWorkspaceTasks(S.FolderOpen)})),this._register(this._configurationService.onDidChangeConfiguration(async v=>{!v.affectsConfiguration("tasks")||!this._taskSystem&&!this._workspaceTasksPromise||((!this._taskSystem||this._taskSystem instanceof pe)&&this._outputChannel.clear(),v.affectsConfiguration(G.Reconnection)&&(this._configurationService.getValue(G.Reconnection)||(this._persistentTasks?.clear(),this._storageService.remove(w.PersistentTasks_Key,D.WORKSPACE))),this._setTaskLRUCacheLimit(),await this._updateWorkspaceTasks(S.ConfigurationChange),this._onDidChangeTaskConfig.fire())})),this._taskRunningState=Ot.bindTo(Ee),this._onDidStateChange=this._register(new B),this._registerCommands().then(()=>At.bindTo(this._contextKeyService).set(!0)),be.bindTo(this._contextKeyService).set(Y.isWeb&&!Fe.getConnection()?.remoteAuthority),this._configurationResolverService.contributeVariable("defaultBuildTask",async()=>{let v=await this._getTasksForGroup(R.Build,!0);if(v.length>0){const Te=this._getDefaultTasks(v);if(Te.length===1)return Te[0]._label}v=await this._getTasksForGroup(R.Build);const j=this._getDefaultTasks(v);if(j.length===1)return j[0]._label;j.length&&(v=j);let ce;v&&v.length>0&&(ce=await this._showQuickPick(v,l.localize("TaskService.pickBuildTaskForLabel","Select the build task (there is no default build task defined)")));const he=ce?ce.task:void 0;if(he)return he._label}),this._register(this._lifecycleService.onBeforeShutdown(v=>{this._willRestart=v.reason!==yt.RELOAD})),this._register(this.onDidStateChange(v=>{if(this._log(l.localize("taskEvent","Task Event kind: {0}",v.kind),!0),v.kind!==ke.Changed)if((this._willRestart||v.kind===ke.Terminated&&v.exitReason===ut.User)&&v.taskId){const j=v.__task.getKey();j&&this.removePersistentTask(j)}else v.kind===ke.Start&&v.__task&&v.__task.getWorkspaceFolder()&&this._setPersistentTask(v.__task)})),this._waitForAllSupportedExecutions=new Promise(v=>{ue.once(this._onDidRegisterAllSupportedExecutions.event)(()=>v())}),this._terminalService.getReconnectedTerminals("Task")?.length?this._attemptTaskReconnection():this._terminalService.whenConnected.then(()=>{this._terminalService.getReconnectedTerminals("Task")?.length?this._attemptTaskReconnection():(this._tasksReconnected=!0,this._onDidReconnectToTasks.fire())}),this._upgrade()}static RecentlyUsedTasks_Key="workbench.tasks.recentlyUsedTasks";static RecentlyUsedTasks_KeyV2="workbench.tasks.recentlyUsedTasks2";static PersistentTasks_Key="workbench.tasks.persistentTasks";static IgnoreTask010DonotShowAgain_key="workbench.tasks.ignoreTask010Shown";_serviceBrand;static OutputChannelId="tasks";static OutputChannelLabel=l.localize("tasks","Tasks");static _nextHandle=0;_tasksReconnected=!1;_schemaVersion;_executionEngine;_workspaceFolders;_workspace;_ignoredWorkspaceFolders;_showIgnoreMessage;_providers;_providerTypes;_taskSystemInfos;_workspaceTasksPromise;_whenTaskSystemReady;_taskSystem;_taskSystemListeners=[];_recentlyUsedTasksV1;_recentlyUsedTasks;_persistentTasks;_taskRunningState;_outputChannel;_onDidStateChange;_waitForAllSupportedExecutions;_onDidRegisterSupportedExecutions=new B;_onDidRegisterAllSupportedExecutions=new B;_onDidChangeTaskSystemInfo=new B;_willRestart=!1;onDidChangeTaskSystemInfo=this._onDidChangeTaskSystemInfo.event;_onDidReconnectToTasks=new B;onDidReconnectToTasks=this._onDidReconnectToTasks.event;_onDidChangeTaskConfig=new B;onDidChangeTaskConfig=this._onDidChangeTaskConfig.event;get isReconnected(){return this._tasksReconnected}_onDidChangeTaskProviders=this._register(new B);onDidChangeTaskProviders=this._onDidChangeTaskProviders.event;registerSupportedExecutions(e,t,s){e!==void 0&&Vt.bindTo(this._contextKeyService).set(e);const i=!!Se.getValue(this._contextKeyService);t!==void 0&&Ce.bindTo(this._contextKeyService).set(t&&!i),s!==void 0&&Ie.bindTo(this._contextKeyService).set(s&&!i),this._workspaceTasksPromise=void 0,this._onDidRegisterSupportedExecutions.fire(),(Y.isWeb||e&&t&&s)&&this._onDidRegisterAllSupportedExecutions.fire()}_attemptTaskReconnection(){if(this._lifecycleService.startupKind!==It.ReloadedWindow&&(this._log(l.localize("TaskService.skippingReconnection","Startup kind not window reload, setting connected and removing persistent tasks"),!0),this._tasksReconnected=!0,this._storageService.remove(w.PersistentTasks_Key,D.WORKSPACE)),!this._configurationService.getValue(G.Reconnection)||this._tasksReconnected){this._log(l.localize("TaskService.notConnecting","Setting tasks connected configured value {0}, tasks were already reconnected {1}",this._configurationService.getValue(G.Reconnection),this._tasksReconnected),!0),this._tasksReconnected=!0;return}this._log(l.localize("TaskService.reconnecting","Reconnecting to running tasks..."),!0),this.getWorkspaceTasks(S.Reconnect).then(async()=>{this._tasksReconnected=await this._reconnectTasks(),this._log(l.localize("TaskService.reconnected","Reconnected to running tasks."),!0),this._onDidReconnectToTasks.fire()})}async _reconnectTasks(){const e=await this.getSavedTasks("persistent");if(!e.length)return this._log(l.localize("TaskService.noTasks","No persistent tasks to reconnect."),!0),!0;const t=e.map(s=>s._label).join(", ");this._log(l.localize("TaskService.reconnectingTasks","Reconnecting to {0} tasks...",t),!0);for(const s of e)if(L.is(s)){const i=await this.tryResolveTask(s);i&&this.run(i,void 0,S.Reconnect)}else this.run(s,void 0,S.Reconnect);return!0}get onDidStateChange(){return this._onDidStateChange.event}get supportsMultipleTaskExecutions(){return this.inTerminal()}async _registerCommands(){P.registerCommand({id:"workbench.action.tasks.runTask",handler:async(e,t)=>{await this._trust()&&await this._runTaskCommand(t)},metadata:{description:"Run Task",args:[{name:"args",isOptional:!0,description:l.localize("runTask.arg","Filters the tasks shown in the quickpick"),schema:{anyOf:[{type:"string",description:l.localize("runTask.label","The task's label or a term to filter by")},{type:"object",properties:{type:{type:"string",description:l.localize("runTask.type","The contributed task type")},task:{type:"string",description:l.localize("runTask.task","The task's label or a term to filter by")}}}]}}]}}),P.registerCommand("workbench.action.tasks.reRunTask",async(e,t)=>{await this._trust()&&this._reRunTaskCommand()}),P.registerCommand("workbench.action.tasks.restartTask",async(e,t)=>{await this._trust()&&this._runRestartTaskCommand(t)}),P.registerCommand("workbench.action.tasks.terminate",async(e,t)=>{await this._trust()&&this._runTerminateCommand(t)}),P.registerCommand("workbench.action.tasks.showLog",()=>{this._showOutput(void 0,!0)}),P.registerCommand("workbench.action.tasks.build",async()=>{await this._trust()&&this._runBuildCommand()}),P.registerCommand("workbench.action.tasks.test",async()=>{await this._trust()&&this._runTestCommand()}),P.registerCommand("workbench.action.tasks.configureTaskRunner",async()=>{await this._trust()&&this._runConfigureTasks()}),P.registerCommand("workbench.action.tasks.configureDefaultBuildTask",async()=>{await this._trust()&&this._runConfigureDefaultBuildTask()}),P.registerCommand("workbench.action.tasks.configureDefaultTestTask",async()=>{await this._trust()&&this._runConfigureDefaultTestTask()}),P.registerCommand("workbench.action.tasks.showTasks",async()=>{if(await this._trust())return this.runShowTasks()}),P.registerCommand("workbench.action.tasks.toggleProblems",()=>this._commandService.executeCommand(Wt.TOGGLE_MARKERS_VIEW_ACTION_ID)),P.registerCommand("workbench.action.tasks.openUserTasks",async()=>{const e=this._getResourceForKind(y.User);e&&this._openTaskFile(e,y.User)}),P.registerCommand("workbench.action.tasks.openWorkspaceFileTasks",async()=>{const e=this._getResourceForKind(y.WorkspaceFile);e&&this._openTaskFile(e,y.WorkspaceFile)})}get workspaceFolders(){return this._workspaceFolders||this._updateSetup(),this._workspaceFolders}get ignoredWorkspaceFolders(){return this._ignoredWorkspaceFolders||this._updateSetup(),this._ignoredWorkspaceFolders}get executionEngine(){return this._executionEngine===void 0&&this._updateSetup(),this._executionEngine}get schemaVersion(){return this._schemaVersion===void 0&&this._updateSetup(),this._schemaVersion}get showIgnoreMessage(){return this._showIgnoreMessage===void 0&&(this._showIgnoreMessage=!this._storageService.getBoolean(w.IgnoreTask010DonotShowAgain_key,D.WORKSPACE,!1)),this._showIgnoreMessage}_getActivationEvents(e){const t=[];if(t.push("onCommand:workbench.action.tasks.runTask"),e)t.push(`onTaskType:${e}`);else for(const s of re.all())t.push(`onTaskType:${s.taskType}`);return t}async _activateTaskProviders(e){await this._extensionService.whenInstalledExtensionsRegistered(),this._log("Activating task providers "+(e??"all")),await se(Promise.all(this._getActivationEvents(e).map(t=>this._extensionService.activateByEvent(t))),5e3,()=>console.warn("Timed out activating extensions for task providers"))}_updateSetup(e){if(e||(e=this._computeWorkspaceFolderSetup()),this._workspaceFolders=e[0],this._ignoredWorkspaceFolders)if(this._ignoredWorkspaceFolders.length!==e[1].length)this._showIgnoreMessage=void 0;else{const t=new Set;this._ignoredWorkspaceFolders.forEach(s=>t.add(s.uri.toString()));for(const s of e[1])if(!t.has(s.uri.toString())){this._showIgnoreMessage=void 0;break}}this._ignoredWorkspaceFolders=e[1],this._executionEngine=e[2],this._schemaVersion=e[3],this._workspace=e[4]}_showOutput(e=S.User,t){!Se.getValue(this._contextKeyService)&&(e===S.User||e===S.ConfigurationChange)&&(t?this._outputService.showChannel(this._outputChannel.id,!0):this._notificationService.prompt(z.Warning,l.localize("taskServiceOutputPrompt","There are task errors. See the output for details."),[{label:l.localize("showOutput","Show output"),run:()=>{this._outputService.showChannel(this._outputChannel.id,!0)}}]))}_disposeTaskSystemListeners(){this._taskSystemListeners&&(Ve(this._taskSystemListeners),this._taskSystemListeners=void 0)}registerTaskProvider(e,t){if(!e)return{dispose:()=>{}};const s=w._nextHandle++;return this._providers.set(s,e),this._providerTypes.set(s,t),this._onDidChangeTaskProviders.fire(),{dispose:()=>{this._providers.delete(s),this._providerTypes.delete(s),this._onDidChangeTaskProviders.fire()}}}get hasTaskSystemInfo(){const e=Array.from(this._taskSystemInfos.values()).flat().length;return this._environmentService.remoteAuthority?e>1:e>0}registerTaskSystem(e,t){if(t.platform===Y.Platform.Web&&(e=this.workspaceFolders.length?this.workspaceFolders[0].uri.scheme:e),!this._taskSystemInfos.has(e))this._taskSystemInfos.set(e,[t]);else{const s=this._taskSystemInfos.get(e);t.platform===Y.Platform.Web?s.push(t):s.unshift(t)}this.hasTaskSystemInfo&&this._onDidChangeTaskSystemInfo.fire()}_getTaskSystemInfo(e){const t=this._taskSystemInfos.get(e);return t&&t.length?t[0]:void 0}extensionCallbackTaskComplete(e,t){return this._taskSystem?this._taskSystem.customExecutionComplete(e,t):Promise.resolve()}async _findWorkspaceTasks(e){const t=[],s=await this.getWorkspaceTasks();for(const[,i]of s){if(i.configurations)for(const r in i.configurations.byIdentifier){const n=i.configurations.byIdentifier[r];e(n,i.workspaceFolder)&&t.push(n)}if(i.set)for(const r of i.set.tasks)e(r,i.workspaceFolder)&&t.push(r)}return t}async _findWorkspaceTasksInGroup(e,t){return this._findWorkspaceTasks(s=>{const i=s.configurationProperties.group;return i&&typeof i!="string"?i._id===e._id&&(!t||!!i.isDefault):!1})}async getTask(e,t,s=!1,i=void 0){if(!await this._trust())return;const r=E.isString(e)?e:we(e)?e.name:e.configuration?te.basename(e.configuration):void 0;if(this.ignoredWorkspaceFolders.some(c=>c.name===r))return Promise.reject(new Error(l.localize("TaskServer.folderIgnored","The folder {0} is ignored since it uses task version 0.1.0",r)));const n=E.isString(t)?t:ne.createTaskIdentifier(t,console);if(n===void 0)return Promise.resolve(void 0);const a=A.getKey(e),d=await this._findWorkspaceTasks((c,f)=>{const g=A.getKey(f);return g!==a&&g!==Z?!1:c.matches(n,s)});if(d.sort(c=>c._source.kind===y.Extension?1:-1),d.length>0){const c=d[0];return L.is(c)?this.tryResolveTask(c):c}const u=await this._getGroupedTasks({type:i});let o=u.get(e);if(o=o.concat(u.get(Z)),!!o)return o=o.filter(c=>c.matches(n,s)).sort(c=>c._source.kind===y.Extension?1:-1),o.length>0?o[0]:void 0}async tryResolveTask(e){if(!await this._trust())return;await this._activateTaskProviders(e.type);let t,s=!1;for(const[r,n]of this._providers){const a=this._providerTypes.get(r);if(e.type===a){if(a&&!this._isTaskProviderEnabled(a)){s=!0;continue}t=n;break}}if(!t){s&&this._log(l.localize("TaskService.providerUnavailable","Warning: {0} tasks are unavailable in the current environment.",e.configures.type));return}try{const r=await t.resolveTask(e);if(r&&r._id===e._id)return b.createCustomTask(r,e)}catch{}const i=await this.tasks({type:e.type});for(const r of i)if(r._id===e._id)return b.createCustomTask(r,e)}async tasks(e){return await this._trust()?this._versionAndEngineCompatible(e)?this._getGroupedTasks(e).then(t=>this.applyFilterToTaskMap(e,t)):Promise.resolve([]):[]}async getKnownTasks(e){return this._versionAndEngineCompatible(e)?this._getGroupedTasks(e,!0,!0).then(t=>this.applyFilterToTaskMap(e,t)):Promise.resolve([])}taskTypes(){const e=[];if(this._isProvideTasksEnabled())for(const t of re.all())this._isTaskProviderEnabled(t.taskType)&&e.push(t.taskType);return e}createSorter(){return new Ut(this._contextService.getWorkspace()?this._contextService.getWorkspace().folders:[])}_isActive(){return this._taskSystem?this._taskSystem.isActive():Promise.resolve(!1)}async getActiveTasks(){return this._taskSystem?this._taskSystem.getActiveTasks():[]}async getBusyTasks(){return this._taskSystem?this._taskSystem.getBusyTasks():[]}getRecentlyUsedTasksV1(){if(this._recentlyUsedTasksV1)return this._recentlyUsedTasksV1;const e=this._configurationService.getValue(oe);this._recentlyUsedTasksV1=new le(e);const t=this._storageService.get(w.RecentlyUsedTasks_Key,D.WORKSPACE);if(t)try{const s=JSON.parse(t);if(Array.isArray(s))for(const i of s)this._recentlyUsedTasksV1.set(i,i)}catch{}return this._recentlyUsedTasksV1}applyFilterToTaskMap(e,t){if(!e||!e.type)return t.all();const s=[];return t.forEach(i=>{for(const r of i)if(F.is(r)&&(r.defines.type===e.type||r._source.label===e.type))s.push(r);else if(C.is(r))if(r.type===e.type)s.push(r);else{const n=r.customizes();n&&n.type===e.type&&s.push(r)}}),s}_getTasksFromStorage(e){return e==="persistent"?this._getPersistentTasks():this._getRecentTasks()}_getRecentTasks(){if(this._recentlyUsedTasks)return this._recentlyUsedTasks;const e=this._configurationService.getValue(oe);this._recentlyUsedTasks=new le(e);const t=this._storageService.get(w.RecentlyUsedTasks_KeyV2,D.WORKSPACE);if(t)try{const s=JSON.parse(t);if(Array.isArray(s))for(const i of s)this._recentlyUsedTasks.set(i[0],i[1])}catch{}return this._recentlyUsedTasks}_getPersistentTasks(){if(this._persistentTasks)return this._log(l.localize("taskService.gettingCachedTasks","Returning cached tasks {0}",this._persistentTasks.size),!0),this._persistentTasks;this._persistentTasks=new le(10);const e=this._storageService.get(w.PersistentTasks_Key,D.WORKSPACE);if(e)try{const t=JSON.parse(e);if(Array.isArray(t))for(const s of t)this._persistentTasks.set(s[0],s[1])}catch{}return this._persistentTasks}_getFolderFromTaskKey(e){const t=JSON.parse(e);return{folder:t.folder,isWorkspaceFile:t.id?.endsWith(y.WorkspaceFile)}}async getSavedTasks(e){const t=Object.create(null);this.workspaceFolders.forEach(o=>{t[o.uri.toString()]=o});const s=new Map,i=new Map,r=this._getTasksFromStorage(e),n=[];this._log(l.localize("taskService.getSavedTasks","Fetching tasks from task storage."),!0);function a(o,c,f){c&&!o.has(c)&&o.set(c,[]),c&&(t[c]||c===Z)&&f&&o.get(c).push(f)}for(const o of r.entries())try{const c=o[0],f=JSON.parse(o[1]),g=this._getFolderFromTaskKey(c);this._log(l.localize("taskService.getSavedTasks.reading","Reading tasks from task storage, {0}, {1}, {2}",c,f,g.folder),!0),a(g.isWorkspaceFile?i:s,g.folder,f)}catch(c){this._log(l.localize("taskService.getSavedTasks.error","Fetching a task from task storage failed: {0}.",c),!0)}const d=new Map;async function u(o,c,f){for(const g of c.keys()){const h=[],p=Object.create(null),k=t[g]?f?b.TaskConfigSource.WorkspaceFile:b.TaskConfigSource.TasksJson:b.TaskConfigSource.User;await o._computeTasksForSingleConfig(t[g]??await o._getAFolder(),{version:"2.0.0",tasks:c.get(g)},S.System,h,p,k,!0),h.forEach(m=>{const I=m.getKey();I&&d.set(I,m)});for(const m in p){const I=p[m].getKey();I&&d.set(I,p[m])}}}await u(this,s,!1),await u(this,i,!0);for(const o of r.keys())d.has(o)?(n.push(d.get(o)),this._log(l.localize("taskService.getSavedTasks.resolved","Resolved task {0}",o),!0)):this._log(l.localize("taskService.getSavedTasks.unresolved","Unable to resolve task {0} ",o),!0);return n}removeRecentlyUsedTask(e){this._getTasksFromStorage("historical").has(e)&&(this._getTasksFromStorage("historical").delete(e),this._saveRecentlyUsedTasks())}removePersistentTask(e){this._log(l.localize("taskService.removePersistentTask","Removing persistent task {0}",e),!0),this._getTasksFromStorage("persistent").has(e)&&(this._getTasksFromStorage("persistent").delete(e),this._savePersistentTasks())}_setTaskLRUCacheLimit(){const e=this._configurationService.getValue(oe);this._recentlyUsedTasks&&(this._recentlyUsedTasks.limit=e)}async _setRecentlyUsedTask(e){let t=e.getKey();if(!x.is(e)&&t){const s=this._createCustomizableTask(e);if(F.is(e)&&s){const i=[],r=Object.create(null);await this._computeTasksForSingleConfig(e._source.workspaceFolder??this.workspaceFolders[0],{version:"2.0.0",tasks:[s]},S.System,i,r,b.TaskConfigSource.TasksJson,!0);for(const n in r)t=r[n].getKey()}this._getTasksFromStorage("historical").set(t,JSON.stringify(s)),this._saveRecentlyUsedTasks()}}_saveRecentlyUsedTasks(){if(!this._recentlyUsedTasks)return;const e=this._configurationService.getValue(oe);if(e===0)return;let t=[...this._recentlyUsedTasks.keys()];t.length>e&&(t=t.slice(0,e));const s=[];for(const i of t)s.push([i,this._recentlyUsedTasks.get(i,ve.None)]);this._storageService.store(w.RecentlyUsedTasks_KeyV2,JSON.stringify(s),D.WORKSPACE,de.MACHINE)}async _setPersistentTask(e){if(!this._configurationService.getValue(G.Reconnection))return;let t=e.getKey();if(!x.is(e)&&t){const s=this._createCustomizableTask(e);if(F.is(e)&&s){const i=[],r=Object.create(null);await this._computeTasksForSingleConfig(e._source.workspaceFolder??this.workspaceFolders[0],{version:"2.0.0",tasks:[s]},S.System,i,r,b.TaskConfigSource.TasksJson,!0);for(const n in r)t=r[n].getKey()}if(!e.configurationProperties.isBackground)return;this._log(l.localize("taskService.setPersistentTask","Setting persistent task {0}",t),!0),this._getTasksFromStorage("persistent").set(t,JSON.stringify(s)),this._savePersistentTasks()}}_savePersistentTasks(){this._persistentTasks=this._getTasksFromStorage("persistent");const e=[...this._persistentTasks.keys()],t=[];for(const s of e)t.push([s,this._persistentTasks.get(s,ve.None)]);this._log(l.localize("savePersistentTask","Saving persistent tasks: {0}",e.join(", ")),!0),this._storageService.store(w.PersistentTasks_Key,JSON.stringify(t),D.WORKSPACE,de.MACHINE)}_openDocumentation(){this._openerService.open(Le.parse("https://code.visualstudio.com/docs/editor/tasks#_defining-a-problem-matcher"))}async _findSingleWorkspaceTaskOfGroup(e){const t=await this._findWorkspaceTasksInGroup(e,!0);if(t.length===1&&typeof t[0].configurationProperties.group!="string"&&t[0].configurationProperties.group?.isDefault){let s;if(L.is(t[0])?s=await this.tryResolveTask(t[0]):s=t[0],s)return this.run(s,void 0,S.User)}}async _build(){const e=await this._findSingleWorkspaceTaskOfGroup(R.Build);return e||this._getGroupedTasksAndExecute()}async _runTest(){const e=await this._findSingleWorkspaceTaskOfGroup(R.Test);return e||this._getGroupedTasksAndExecute(!0)}async _getGroupedTasksAndExecute(e){const t=await this._getGroupedTasks(),s=this._createRunnableTask(t,e?R.Test:R.Build);if(!s||!s.task)throw e?this.schemaVersion===M.V0_1_0?new q(z.Info,l.localize("TaskService.noTestTask1","No test task defined. Mark a task with 'isTestCommand' in the tasks.json file."),V.NoTestTask):new q(z.Info,l.localize("TaskService.noTestTask2","No test task defined. Mark a task with as a 'test' group in the tasks.json file."),V.NoTestTask):this.schemaVersion===M.V0_1_0?new q(z.Info,l.localize("TaskService.noBuildTask1","No build task defined. Mark a task with 'isBuildCommand' in the tasks.json file."),V.NoBuildTask):new q(z.Info,l.localize("TaskService.noBuildTask2","No build task defined. Mark a task with as a 'build' group in the tasks.json file."),V.NoBuildTask);let i;try{i=await this._executeTask(s.task,s.resolver,S.User)}catch(r){return this._handleError(r),Promise.reject(r)}return i}async run(e,t,s=S.System){if(!await this._trust())return;if(!e)throw new q(z.Info,l.localize("TaskServer.noTask","Task to execute is undefined"),V.TaskNotFound);const i=this._createResolver();let r;try{if(t&&t.attachProblemMatcher&&this._shouldAttachProblemMatcher(e)&&!x.is(e)){const n=await this._attachProblemMatcher(e);n&&(r=await this._executeTask(n,i,s))}else r=await this._executeTask(e,i,s);return r}catch(n){return this._handleError(n),Promise.reject(n)}}_isProvideTasksEnabled(){return this._configurationService.getValue(G.AutoDetect)==="on"}_isProblemMatcherPromptEnabled(e){const t=this._configurationService.getValue(ge);return E.isBoolean(t)?!t:e===void 0?!0:!t[e]}_getTypeForTask(e){let t;return C.is(e)?t=e._source.config.element.type:t=e.getDefinition().type,t}_shouldAttachProblemMatcher(e){return this._isProblemMatcherPromptEnabled(this._getTypeForTask(e))===!1||!this._canCustomize(e)||e.configurationProperties.group!==void 0&&e.configurationProperties.group!==R.Build||e.configurationProperties.problemMatchers!==void 0&&e.configurationProperties.problemMatchers.length>0?!1:F.is(e)?!e.hasDefinedMatchers&&!!e.configurationProperties.problemMatchers&&e.configurationProperties.problemMatchers.length===0:C.is(e)?e._source.config.element.problemMatcher===void 0&&!e.hasDefinedMatchers:!1}async _updateNeverProblemMatcherSetting(e){const t=this._configurationService.getValue(ge);if(t===!0)return;let s;return t!==!1?s=t:s=Object.create(null),s[e]=!0,this._configurationService.updateValue(ge,s)}async _attachProblemMatcher(e){let t=[];for(const r of X.keys()){const n=X.get(r);n.deprecated||(n.name===n.label?t.push({label:n.name,matcher:n}):t.push({label:n.label,description:`$${n.name}`,matcher:n}))}if(t.length===0)return;t=t.sort((r,n)=>r.label&&n.label?r.label.localeCompare(n.label):0),t.unshift({type:"separator",label:l.localize("TaskService.associate","associate")});let s;C.is(e)?s=e._source.config.element.type:s=e.getDefinition().type,t.unshift({label:l.localize("TaskService.attachProblemMatcher.continueWithout","Continue without scanning the task output"),matcher:void 0},{label:l.localize("TaskService.attachProblemMatcher.never","Never scan the task output for this task"),matcher:void 0,never:!0},{label:l.localize("TaskService.attachProblemMatcher.neverType","Never scan the task output for {0} tasks",s),matcher:void 0,setting:s},{label:l.localize("TaskService.attachProblemMatcher.learnMoreAbout","Learn more about scanning the task output"),matcher:void 0,learnMore:!0});const i=await this._quickInputService.pick(t,{placeHolder:l.localize("selectProblemMatcher","Select for which kind of errors and warnings to scan the task output")});if(!i)return e;if(i.learnMore){this._openDocumentation();return}if(i.never)return this.customize(e,{problemMatcher:[]},!0),e;if(i.matcher){const r=e.clone(),n=`$${i.matcher.name}`,a={problemMatcher:[n]};r.configurationProperties.problemMatchers=[n];const d=X.get(i.matcher.name);return d&&d.watching!==void 0&&(a.isBackground=!0,r.configurationProperties.isBackground=!0),this.customize(e,a,!0),r}return i.setting&&await this._updateNeverProblemMatcherSetting(i.setting),e}async _getTasksForGroup(e,t){const s=await this._getGroupedTasks(void 0,t),i=[];return s.forEach(r=>{for(const n of r)R.from(n.configurationProperties.group)?._id===e._id&&i.push(n)}),i}needsFolderQualification(){return this._contextService.getWorkbenchState()===W.WORKSPACE}_canCustomize(e){return this.schemaVersion!==M.V2_0_0?!1:C.is(e)?!0:F.is(e)?!!e.getWorkspaceFolder():!1}async _formatTaskForJson(e,t){let s,i="";try{s=await this._textModelResolverService.createModelReference(e);const r=s.object.textEditorModel,{tabSize:n,insertSpaces:a}=r.getOptions(),d=r.getEOL();let u=Oe(t,{eol:d,tabSize:n,insertSpaces:a});const o=new RegExp(d+(a?" ".repeat(n):"\\t"),"g");u=u.replace(o,d+(a?" ".repeat(n*3):"			"));const c=a?" ".repeat(n*2):"		";i=c+u.slice(0,u.length-1)+c+u.slice(u.length-1)}finally{s?.dispose()}return i}async _openEditorAtTask(e,t,s=-1){if(e===void 0)return Promise.resolve(!1);const r=(await this._fileService.readFile(e)).value;if(!r||!t)return!1;const n=r.toString();let a;if(s!==-1){const f=this._configurationService.getValue("tasks",{resource:e});f.tasks&&f.tasks.length>s&&(a=await this._formatTaskForJson(e,f.tasks[s]))}a||(typeof t=="string"?a=t:a=await this._formatTaskForJson(e,t));const d=n.indexOf(a);let u=1;for(let f=0;f<d;f++)n.charAt(f)===`
`&&u++;let o=u;for(let f=0;f<a.length;f++)a.charAt(f)===`
`&&o++;const c=u>1?{startLineNumber:u,startColumn:u===o?4:3,endLineNumber:o,endColumn:u===o?void 0:4}:void 0;return await this._editorService.openEditor({resource:e,options:{pinned:!1,forceReload:!0,selection:c,selectionRevealType:Ye.CenterIfOutsideViewport}}),!!c}_createCustomizableTask(e){let t;const s=C.is(e)||L.is(e)?e._source.config:void 0;if(s&&s.element)t={...s.element};else if(F.is(e)){t={};const i=Object.assign(Object.create(null),e.defines);delete i._key,Object.keys(i).forEach(r=>t[r]=i[r]),e.configurationProperties.problemMatchers&&e.configurationProperties.problemMatchers.length>0&&E.isStringArray(e.configurationProperties.problemMatchers)&&(t.problemMatcher=e.configurationProperties.problemMatchers),e.configurationProperties.group&&(t.group=b.GroupKind.to(e.configurationProperties.group))}if(t)return(t.problemMatcher===void 0&&e.configurationProperties.problemMatchers===void 0||e.configurationProperties.problemMatchers&&e.configurationProperties.problemMatchers.length===0)&&(t.problemMatcher=[]),e._source.label!=="Workspace"?t.label=e.configurationProperties.identifier:t.label=e._label,t.detail=e.configurationProperties.detail,t}async customize(e,t,s){if(!await this._trust())return;const i=e.getWorkspaceFolder();if(!i)return Promise.resolve(void 0);const r=this._getConfiguration(i,e._source.kind);if(r.hasParseErrors)return this._notificationService.warn(l.localize("customizeParseErrors","The current task configuration has errors. Please fix the errors first before customizing a task.")),Promise.resolve(void 0);const n=r.config,a=this._createCustomizableTask(e);if(!a)return Promise.resolve(void 0);const d=C.is(e)?e._source.config.index:void 0;if(t)for(const u of Object.getOwnPropertyNames(t)){const o=t[u];o!=null&&(a[u]=o)}if(n)d===-1&&t?t.problemMatcher!==void 0?(n.problemMatcher=t.problemMatcher,await this._writeConfiguration(i,"tasks.problemMatchers",n.problemMatcher,e._source.kind)):t.group!==void 0&&(n.group=t.group,await this._writeConfiguration(i,"tasks.group",n.group,e._source.kind)):(Array.isArray(n.tasks)||(n.tasks=[]),d===void 0?n.tasks.push(a):n.tasks[d]=a,await this._writeConfiguration(i,"tasks.tasks",n.tasks,e._source.kind));else{const u={version:"2.0.0",tasks:[a]};let o=["{",l.localize("tasksJsonComment",`	// See https://go.microsoft.com/fwlink/?LinkId=733558 
	// for the documentation about the tasks.json format`)].join(`
`)+JSON.stringify(u,null,"	").substr(1);const c=this._configurationService.getValue();c.editor.insertSpaces&&(o=o.replace(/(\n)(\t+)/g,(f,g,h)=>g+" ".repeat(h.length*c.editor.tabSize))),await this._textFileService.create([{resource:i.toResource(".vscode/tasks.json"),value:o}])}s&&this._openEditorAtTask(this._getResourceForTask(e),a)}_writeConfiguration(e,t,s,i){let r;switch(i){case y.User:r=J.USER;break;case y.WorkspaceFile:r=J.WORKSPACE;break;default:this._contextService.getWorkbenchState()===W.FOLDER?r=J.WORKSPACE:this._contextService.getWorkbenchState()===W.WORKSPACE&&(r=J.WORKSPACE_FOLDER)}if(r)return this._configurationService.updateValue(t,s,{resource:e.uri},r)}_getResourceForKind(e){switch(this._updateSetup(),e){case y.User:return te.joinPath(te.dirname(this._preferencesService.userSettingsResource),"tasks.json");case y.WorkspaceFile:if(this._workspace&&this._workspace.configuration)return this._workspace.configuration;default:return}}_getResourceForTask(e){if(C.is(e)){let t=this._getResourceForKind(e._source.kind);if(!t){const s=e.getWorkspaceFolder();s?t=s.toResource(e._source.config.file):t=this.workspaceFolders[0].uri}return t}else return e.getWorkspaceFolder().toResource(".vscode/tasks.json")}async openConfig(e){let t;return e?t=this._getResourceForTask(e):t=this._workspaceFolders&&this._workspaceFolders.length>0?this._workspaceFolders[0].toResource(".vscode/tasks.json"):void 0,this._openEditorAtTask(t,e?e._label:void 0,e?e._source.config.index:-1)}_createRunnableTask(e,t){const s=new Map,i=[],r=[];e.forEach((a,d)=>{let u=s.get(d);u||(u={id:new Map,label:new Map,identifier:new Map},s.set(d,u));for(const o of a)u.id.set(o._id,o),u.label.set(o._label,o),o.configurationProperties.identifier&&u.identifier.set(o.configurationProperties.identifier,o),t&&o.configurationProperties.group===t&&(o._source.kind===y.Workspace?i.push(o):r.push(o))});const n={resolve:async(a,d)=>{const u=s.get(typeof a=="string"?a:a.toString());if(u)return u.id.get(d)||u.label.get(d)||u.identifier.get(d)}};if(i.length>0)return i.length>1&&this._log(l.localize("moreThanOneBuildTask","There are many build tasks defined in the tasks.json. Executing the first one.")),{task:i[0],resolver:n};if(r.length!==0){if(r.length===1)return{task:r[0],resolver:n};{const a=Ge.generateUuid();return{task:new x(a,{kind:y.InMemory,label:"inMemory"},a,"inMemory",{reevaluateOnRerun:!0},{identifier:a,dependsOn:r.map(u=>({uri:u.getWorkspaceFolder().uri,task:u._id})),name:a}),resolver:n}}}}_createResolver(e){let t;async function s(n,a,d){const u=await n._findWorkspaceTasks(c=>{const f=L.is(c)||C.is(c)?c._source.config.workspaceFolder?.uri:void 0,g=typeof a=="string"?a:a.toString();if(f?.toString()!==g)return!1;if(E.isString(d))return c._label===d||c.configurationProperties.identifier===d;{const h=c.getDefinition(!0),p=ne.createTaskIdentifier(d,console);return p&&h?p._key===h._key:!1}});if(u.length===0)return;const o=u[0];return L.is(o)?n.tryResolveTask(o):o}async function i(n){return t===void 0&&(t=new Map,(e||await n._getGroupedTasks()).forEach((a,d)=>{let u=t.get(d);u||(u={label:new Map,identifier:new Map,taskIdentifier:new Map},t.set(d,u));for(const o of a){u.label.set(o._label,o),o.configurationProperties.identifier&&u.identifier.set(o.configurationProperties.identifier,o);const c=o.getDefinition(!0);c!==void 0&&u.taskIdentifier.set(c._key,o)}})),t}async function r(n,a,d){const o=(await i(n)).get(typeof a=="string"?a:a.toString());if(o){if(E.isString(d))return o.label.get(d)||o.identifier.get(d);{const c=ne.createTaskIdentifier(d,console);return c!==void 0?o.taskIdentifier.get(c._key):void 0}}}return{resolve:async(n,a)=>{if(a)return t===void 0&&e===void 0?await s(this,n,a)??r(this,n,a):r(this,n,a)}}}async _saveBeforeRun(){let e;(n=>(n.Always="always",n.Never="never",n.Prompt="prompt"))(e||={});const t=this._configurationService.getValue(G.SaveBeforeRun);if(t==="never")return!1;if(t==="prompt"&&this._editorService.editors.some(s=>s.isDirty())){const{confirmed:s}=await this._dialogService.confirm({message:l.localize("TaskSystem.saveBeforeRun.prompt.title","Save all editors?"),detail:l.localize("detail","Do you want to save all editors before running the task?"),primaryButton:l.localize({key:"saveBeforeRun.save",comment:["&& denotes a mnemonic"]},"&&Save"),cancelButton:l.localize({key:"saveBeforeRun.dontSave",comment:["&& denotes a mnemonic"]},"Do&&n't Save")});if(!s)return!1}return await this._editorService.saveAll({reason:ye.AUTO}),!0}async _executeTask(e,t,s){let i=e;if(await this._saveBeforeRun()){await this._configurationService.reloadConfiguration(),await this._updateWorkspaceTasks();const n=e.getWorkspaceFolder(),a=e.configurationProperties.identifier,d=C.is(e)?e.customizes()?.type:F.is(e)?e.type:void 0;i=(n&&a&&s===S.User?await this.getTask(n,a,!1,d):e)??e}await X.onReady();const r=s===S.Reconnect?this._getTaskSystem().reconnect(i,t):this._getTaskSystem().run(i,t);return r?this._handleExecuteResult(r,s):{exitCode:0}}async _handleExecuteResult(e,t){if(t===S.User&&await this._setRecentlyUsedTask(e.task),e.kind===Qt.Active){const s=e.active;if(s&&s.same&&t===S.FolderOpen||t===S.Reconnect)return this._logService.debug("Ignoring task that is already active",e.task),e.promise;if(s&&s.same)if(this._taskSystem?.isTaskVisible(e.task)){const i=l.localize("TaskSystem.activeSame.noBackground","The task '{0}' is already active.",e.task.getQualifiedLabel()),r=this._getTaskSystem().getLastInstance(e.task)??e.task;this._notificationService.prompt(z.Warning,i,[{label:l.localize("terminateTask","Terminate Task"),run:()=>this.terminate(r)},{label:l.localize("restartTask","Restart Task"),run:()=>this._restart(r)}],{sticky:!0})}else this._taskSystem?.revealTask(e.task);else throw new q(z.Warning,l.localize("TaskSystem.active","There is already a task running. Terminate it first before executing another task."),V.RunningTask)}return this._setRecentlyUsedTask(e.task),e.promise}async _restart(e){if(!this._taskSystem)return;if((await this._taskSystem.terminate(e)).success)try{await this.run(e)}catch{}else this._notificationService.warn(l.localize("TaskSystem.restartFailed","Failed to terminate and restart task {0}",E.isString(e)?e:e.configurationProperties.name))}async terminate(e){return await this._trust()?this._taskSystem?this._taskSystem.terminate(e):{success:!0,task:void 0}:{success:!0,task:void 0}}_terminateAll(){return this._taskSystem?this._taskSystem.terminateAll():Promise.resolve([])}_createTerminalTaskSystem(){return new pe(this._terminalService,this._terminalGroupService,this._outputService,this._paneCompositeService,this._viewsService,this._markerService,this._modelService,this._configurationResolverService,this._contextService,this._environmentService,w.OutputChannelId,this._fileService,this._terminalProfileResolverService,this._pathService,this._viewDescriptorService,this._logService,this._notificationService,this._instantiationService,e=>{if(e)return this._getTaskSystemInfo(e.uri.scheme);if(this._taskSystemInfos.size>0){const t=Array.from(this._taskSystemInfos.entries()),s=t.filter(i=>i[0]!==Ae.file);return s.length>0?s[0][1][0]:t[0][1][0]}else return})}_isTaskProviderEnabled(e){const t=re.get(e);return!t||!t.when||this._contextKeyService.contextMatchesRules(t.when)}async _getGroupedTasks(e,t,s){await this._waitForAllSupportedExecutions;const i=e?.type,r=this._needsRecentTasksMigration();t||await this._activateTaskProviders(e?.type);const n=Object.create(null);re.all().forEach(o=>n[o.taskType]=!0),n.shell=!0,n.process=!0;const a=await new Promise(o=>{const c=[];let f=0;const g=p=>{p&&c.push(p),--f===0&&o(c)},h=p=>{try{p&&E.isString(p.message)?(this._log(`Error: ${p.message}
`),this._showOutput()):(this._log("Unknown error received while collecting tasks from providers."),this._showOutput())}finally{--f===0&&o(c)}};if(this._isProvideTasksEnabled()&&this.schemaVersion===M.V2_0_0&&this._providers.size>0){let p=!1;for(const[k,m]of this._providers){const I=this._providerTypes.get(k);if(i===void 0||i===I){if(I&&!this._isTaskProviderEnabled(I))continue;p=!0,f++,se(m.provideTasks(n).then(N=>{for(const K of N.tasks)if(K.type!==this._providerTypes.get(k)){this._log(l.localize("unexpectedTaskType",`The task provider for "{0}" tasks unexpectedly provided a task of type "{1}".
`,this._providerTypes.get(k),K.type)),K.type!=="shell"&&K.type!=="process"&&this._showOutput();break}return g(N)},h),5e3,()=>{console.error("Timed out getting tasks from ",I),g(void 0)})}}p||o(c)}else o(c)}),d=new A,u=new A;for(const o of a)for(const c of o.tasks){const f=c.getWorkspaceFolder();f&&u.add(f,c)}try{let o=[];return(!s||this._workspaceTrustManagementService.isWorkspaceTrusted())&&(o=Array.from(await this.getWorkspaceTasks())),await Promise.all(this._getCustomTaskPromises(o,e,d,u,t)),r&&await this._migrateRecentTasks(d.all()),d}catch{const o=new A;for(const c of a)for(const f of c.tasks){const g=f.getWorkspaceFolder();g&&o.add(g,f)}return o}}_getCustomTaskPromises(e,t,s,i,r){return e.map(async([n,a])=>{const d=i.get(n);if(!a.set){d&&s.add(n,...d);return}if(this._contextService.getWorkbenchState()===W.EMPTY)s.add(n,...a.set.tasks);else{const u=a.configurations,o=a.set?this._getLegacyTaskConfigurations(a.set):void 0,c=[];if(u||o){const f=new Set;u&&Object.keys(u.byIdentifier).forEach(p=>f.add(p));for(const p of d)if(F.is(p))if(u){const k=u.byIdentifier[p.defines._key];k?(f.delete(p.defines._key),s.add(n,b.createCustomTask(p,k))):s.add(n,p)}else if(o){const k=o[p.defines._key];k?(s.add(n,b.createCustomTask(p,k)),c.push(k)):s.add(n,p)}else s.add(n,p);if(c.length>0){const p=c.reduce((k,m)=>(k[m._id]=!0,k),Object.create(null));for(const k of a.set.tasks)p[k._id]||s.add(n,k)}else s.add(n,...a.set.tasks);const h=Array.from(f).map(async p=>{const k=u.byIdentifier[p];if(t?.type&&t.type!==k.configures.type)return;let m=!1;for(const[I,N]of this._providers){const K=this._providerTypes.get(I);if(k.type===K){if(K&&!this._isTaskProviderEnabled(K)){m=!0;continue}try{const ee=await N.resolveTask(k);if(ee&&ee._id===k._id){s.add(n,b.createCustomTask(ee,k));return}}catch{}}}m?this._log(l.localize("TaskService.providerUnavailable","Warning: {0} tasks are unavailable in the current environment.",k.configures.type)):r||(this._log(l.localize("TaskService.noConfiguration",`Error: The {0} task detection didn't contribute a task for the following configuration:
{1}
The task will be ignored.`,k.configures.type,JSON.stringify(k._source.config.element,void 0,4))),this._showOutput())});await Promise.all(h)}else s.add(n,...a.set.tasks),s.add(n,...d)}})}_getLegacyTaskConfigurations(e){let t;function s(){return t||(t=Object.create(null),t)}for(const i of e.tasks)if(C.is(i)){const r=i.command&&i.command.name;if(r==="gulp"||r==="grunt"||r==="jake"){const n=Dt.create({type:r,task:i.configurationProperties.name});s()[n._key]=i}}return t}async getWorkspaceTasks(e=S.User){return await this._trust()?(await se(this._waitForAllSupportedExecutions,2e3,()=>{this._logService.warn("Timed out waiting for all supported executions")}),await this._whenTaskSystemReady,this._workspaceTasksPromise?this._workspaceTasksPromise:this._updateWorkspaceTasks(e)):new Map}_updateWorkspaceTasks(e=S.User){return this._workspaceTasksPromise=this._computeWorkspaceTasks(e),this._workspaceTasksPromise}async _getAFolder(){let e=this.workspaceFolders.length>0?this.workspaceFolders[0]:void 0;if(!e){const t=await this._pathService.userHome();e=new ft({uri:t,name:te.basename(t),index:0})}return e}async _computeWorkspaceTasks(e=S.User){const t=[];for(const a of this.workspaceFolders)t.push(this._computeWorkspaceFolderTasks(a,e));const s=await Promise.all(t),i=new Map;for(const a of s)a&&i.set(a.workspaceFolder.uri.toString(),a);const r=await this._getAFolder();if(this._contextService.getWorkbenchState()!==W.EMPTY){const a=await this._computeWorkspaceFileTasks(r,e);a&&this._workspace&&this._workspace.configuration&&i.set(this._workspace.configuration.toString(),a)}const n=await this._computeUserTasks(r,e);return n&&i.set(Z,n),i}get _jsonTasksSupported(){return Ce.getValue(this._contextKeyService)===!0&&Ie.getValue(this._contextKeyService)===!0}async _computeWorkspaceFolderTasks(e,t=S.User){const s=this._executionEngine===O.Process?await this._computeLegacyConfiguration(e):await this._computeConfiguration(e);if(!s||!s.config||s.hasErrors)return Promise.resolve({workspaceFolder:e,set:void 0,configurations:void 0,hasErrors:s?s.hasErrors:!1});await X.onReady();const i=this._getTaskSystemInfo(e.uri.scheme),r=new Re(this._outputChannel),n=b.parse(e,void 0,i?i.platform:Y.platform,s.config,r,b.TaskConfigSource.TasksJson,this._contextKeyService);let a=!1;if(!n.validationStatus.isOK()&&n.validationStatus.state!==$.Info&&(a=!0,this._showOutput(t)),r.status.isFatal())return r.fatal(l.localize("TaskSystem.configurationErrors","Error: the provided task configuration has validation errors and can't not be used. Please correct the errors first.")),{workspaceFolder:e,set:void 0,configurations:void 0,hasErrors:a};let d;if(n.configured&&n.configured.length>0){d={byIdentifier:Object.create(null)};for(const u of n.configured)d.byIdentifier[u.configures._key]=u}return!this._jsonTasksSupported&&n.custom.length>0&&console.warn("Custom workspace tasks are not supported."),{workspaceFolder:e,set:{tasks:this._jsonTasksSupported?n.custom:[]},configurations:d,hasErrors:a}}_testParseExternalConfig(e,t){if(!e)return{config:void 0,hasParseErrors:!1};const s=e.$parseErrors;if(s){let i=!1;for(const r of s)if(/tasks\.json$/.test(r)){i=!0;break}if(i)return this._log(l.localize({key:"TaskSystem.invalidTaskJsonOther",comment:["Message notifies of an error in one of several places there is tasks related json, not necessarily in a file named tasks.json"]},"Error: The content of the tasks json in {0} has syntax errors. Please correct them before executing a task.",t)),this._showOutput(),{config:e,hasParseErrors:!0}}return{config:e,hasParseErrors:!1}}_log(e,t){(!t||this._configurationService.getValue(G.VerboseLogging))&&this._outputChannel.append(e+`
`)}async _computeWorkspaceFileTasks(e,t=S.User){if(this._executionEngine===O.Process)return this._emptyWorkspaceTaskResults(e);const s=this._getConfiguration(e,y.WorkspaceFile),i=this._testParseExternalConfig(s.config,l.localize("TasksSystem.locationWorkspaceConfig","workspace file")),r={byIdentifier:Object.create(null)},n=[];return await this._computeTasksForSingleConfig(e,i.config,t,n,r.byIdentifier,b.TaskConfigSource.WorkspaceFile),(i.config?b.ExecutionEngine.from(i.config):O.Terminal)===O.Process?(this._notificationService.warn(l.localize("TaskSystem.versionWorkspaceFile","Only tasks version 2.0.0 permitted in workspace configuration files.")),this._emptyWorkspaceTaskResults(e)):{workspaceFolder:e,set:{tasks:n},configurations:r,hasErrors:i.hasParseErrors}}async _computeUserTasks(e,t=S.User){if(this._executionEngine===O.Process)return this._emptyWorkspaceTaskResults(e);const s=this._getConfiguration(e,y.User),i=this._testParseExternalConfig(s.config,l.localize("TasksSystem.locationUserConfig","user settings")),r={byIdentifier:Object.create(null)},n=[];return await this._computeTasksForSingleConfig(e,i.config,t,n,r.byIdentifier,b.TaskConfigSource.User),(i.config?b.ExecutionEngine.from(i.config):O.Terminal)===O.Process?(this._notificationService.warn(l.localize("TaskSystem.versionSettings","Only tasks version 2.0.0 permitted in user settings.")),this._emptyWorkspaceTaskResults(e)):{workspaceFolder:e,set:{tasks:n},configurations:r,hasErrors:i.hasParseErrors}}_emptyWorkspaceTaskResults(e){return{workspaceFolder:e,set:void 0,configurations:void 0,hasErrors:!1}}async _computeTasksForSingleConfig(e,t,s,i,r,n,a=!1){if(t){if(!e)return this._logService.trace("TaskService.computeTasksForSingleConfig: no workspace folder for worskspace",this._workspace?.id),!1}else return!1;const d=this._getTaskSystemInfo(e.uri.scheme),u=new Re(this._outputChannel),o=b.parse(e,this._workspace,d?d.platform:Y.platform,t,u,n,this._contextKeyService,a);let c=!1;if(!o.validationStatus.isOK()&&o.validationStatus.state!==$.Info&&(this._showOutput(s),c=!0),u.status.isFatal())return u.fatal(l.localize("TaskSystem.configurationErrors","Error: the provided task configuration has validation errors and can't not be used. Please correct the errors first.")),c;if(o.configured&&o.configured.length>0)for(const f of o.configured)r[f.configures._key]=f;if(!this._jsonTasksSupported&&o.custom.length>0)console.warn("Custom workspace tasks are not supported.");else for(const f of o.custom)i.push(f);return c}_computeConfiguration(e){const{config:t,hasParseErrors:s}=this._getConfiguration(e);return Promise.resolve({workspaceFolder:e,config:t,hasErrors:s})}_computeWorkspaceFolderSetup(){const e=[],t=[];let s=O.Terminal,i=M.V2_0_0,r;if(this._contextService.getWorkbenchState()===W.FOLDER){const n=this._contextService.getWorkspace().folders[0];e.push(n),s=this._computeExecutionEngine(n);const a={executionEngineVersion:s};this._telemetryService.publicLog("taskService.engineVersion",a),i=this._computeJsonSchemaVersion(n)}else if(this._contextService.getWorkbenchState()===W.WORKSPACE){r=this._contextService.getWorkspace();for(const n of this._contextService.getWorkspace().folders)i===this._computeJsonSchemaVersion(n)?e.push(n):(t.push(n),this._log(l.localize("taskService.ignoreingFolder","Ignoring task configurations for workspace folder {0}. Multi folder workspace task support requires that all folders use task version 2.0.0",n.uri.fsPath)))}return[e,t,s,i,r]}_computeExecutionEngine(e){const{config:t}=this._getConfiguration(e);return t?b.ExecutionEngine.from(t):O._default}_computeJsonSchemaVersion(e){const{config:t}=this._getConfiguration(e);return t?b.JsonSchemaVersion.from(t):M.V2_0_0}_getConfiguration(e,t){let s;if(t!==y.User&&this._contextService.getWorkbenchState()===W.EMPTY)s=void 0;else{const r=this._configurationService.inspect("tasks",{resource:e.uri});switch(t){case y.User:{r.userValue!==r.workspaceFolderValue&&(s=ie.deepClone(r.userValue));break}case y.Workspace:s=ie.deepClone(r.workspaceFolderValue);break;case y.WorkspaceFile:{this._contextService.getWorkbenchState()===W.WORKSPACE&&r.workspaceFolderValue!==r.workspaceValue&&(s=ie.deepClone(r.workspaceValue));break}default:s=ie.deepClone(r.workspaceFolderValue)}}if(!s)return{config:void 0,hasParseErrors:!1};const i=s.$parseErrors;if(i){let r=!1;for(const n of i)if(/tasks\.json$/.test(n)){r=!0;break}if(r)return this._log(l.localize("TaskSystem.invalidTaskJson","Error: The content of the tasks.json file has syntax errors. Please correct them before executing a task.")),this._showOutput(),{config:void 0,hasParseErrors:!0}}return{config:s,hasParseErrors:!1}}inTerminal(){return this._taskSystem?this._taskSystem instanceof pe:this._executionEngine===O.Terminal}configureAction(){const e=this;return new class extends Me{constructor(){super(ae.ID,ae.TEXT.value,void 0,!0,()=>(e._runConfigureTasks(),Promise.resolve(void 0)))}}}_handleError(e){let t=!0;if(e instanceof q){const s=e,i=s.code===V.NotConfigured||s.code===V.NoBuildTask||s.code===V.NoTestTask,r=s.code===V.RunningTask;i||r?this._notificationService.prompt(s.severity,s.message,[{label:i?ae.TEXT.value:l.localize("TerminateAction.label","Terminate Task"),run:()=>{i?this._runConfigureTasks():this._runTerminateCommand()}}]):this._notificationService.notify({severity:s.severity,message:s.message})}else if(e instanceof Error){const s=e;this._notificationService.error(s.message),t=!1}else E.isString(e)?this._notificationService.error(e):this._notificationService.error(l.localize("TaskSystem.unknownError","An error has occurred while running a task. See task log for details."));t&&this._showOutput()}_showDetail(){return this._configurationService.getValue(Gt)}async _createTaskQuickPickEntries(e,t=!1,s=!1,i,r=!0){let n={};if(e==null||e.length===0)return[];const a=o=>{const c={label:o._label,description:this.getTaskDescription(o),task:o,detail:this._showDetail()?o.configurationProperties.detail:void 0};return n[o._id]?(n[o._id].length===1&&(n[o._id][0].label+=" (1)"),c.label=c.label+" ("+(n[o._id].length+1).toString()+")"):n[o._id]=[],n[o._id].push(c),c};function d(o,c,f){c.length&&o.push({type:"separator",label:f});for(const g of c){const h=a(g);h.buttons=[{iconClass:Ne.asClassName(Lt),tooltip:l.localize("configureTask","Configure Task")}],i&&g===i.task?o.unshift(i):o.push(h)}}let u;if(t)if(u=[],e.length===1)u.push(a(e[0]));else{const o=await this.getSavedTasks("historical"),c=[],f=new Set;let g=[],h=[];const p=Object.create(null);e.forEach(m=>{const I=m.getCommonTaskId();I&&(p[I]=m)}),o.reverse().forEach(m=>{const I=m.getCommonTaskId();if(I){f.add(I);const N=p[I];N&&c.push(N)}});for(const m of e){const I=m.getCommonTaskId();(!I||!f.has(I))&&(m._source.kind===y.Workspace||m._source.kind===y.User?g.push(m):h.push(m))}const k=this.createSorter();r&&d(u,c,l.localize("recentlyUsed","recently used tasks")),g=g.sort((m,I)=>k.compare(m,I)),d(u,g,l.localize("configured","configured tasks")),h=h.sort((m,I)=>k.compare(m,I)),d(u,h,l.localize("detected","detected tasks"))}else{if(s){const o=this.createSorter();e=e.sort((c,f)=>o.compare(c,f))}u=e.map(o=>a(o))}return n={},u}async _showTwoLevelQuickPick(e,t,s,i){return this._instantiationService.createInstance(Q).show(e,t,s,i)}async _showQuickPick(e,t,s,i=!1,r=!1,n,a,d){const u=await e,o=await se(this._createTaskQuickPickEntries(u,i,r,n),200,()=>{});if(o)return o.length===1&&this._configurationService.getValue(Pe)?o[0]:(o.length===0&&s?o.push(s):o.length>1&&a&&a.length>0&&(o.push({type:"separator",label:""}),o.push(a[0])),this._quickInputService.pick(o,{value:d,placeHolder:t,matchOnDescription:!0,onDidTriggerItemButton:c=>{const f=c.item.task;this._quickInputService.cancel(),F.is(f)?this.customize(f,void 0,!0):C.is(f)&&this.openConfig(f)}}))}_needsRecentTasksMigration(){return this.getRecentlyUsedTasksV1().size>0&&this._getTasksFromStorage("historical").size===0}async _migrateRecentTasks(e){if(!this._needsRecentTasksMigration())return;const t=this.getRecentlyUsedTasksV1(),s=Object.create(null);e.forEach(r=>{const n=r.getKey();n&&(s[n]=r)});const i=[...t.keys()].reverse();for(const r in i){const n=s[r];n&&await this._setRecentlyUsedTask(n)}this._storageService.remove(w.RecentlyUsedTasks_Key,D.WORKSPACE)}_showIgnoredFoldersMessage(){return this.ignoredWorkspaceFolders.length===0||!this.showIgnoreMessage||this._notificationService.prompt(z.Info,l.localize("TaskService.ignoredFolder","The following workspace folders are ignored since they use task version 0.1.0: {0}",this.ignoredWorkspaceFolders.map(e=>e.name).join(", ")),[{label:l.localize("TaskService.notAgain","Don't Show Again"),isSecondary:!0,run:()=>{this._storageService.store(w.IgnoreTask010DonotShowAgain_key,!0,D.WORKSPACE,de.MACHINE),this._showIgnoreMessage=!1}}]),Promise.resolve(void 0)}async _trust(){return be&&!Kt?!1:(await this._workspaceTrustManagementService.workspaceTrustInitialized,this._workspaceTrustManagementService.isWorkspaceTrusted()?!0:await this._workspaceTrustRequestService.requestWorkspaceTrust({message:l.localize("TaskService.requestTrust","Listing and running tasks requires that some of the files in this workspace be executed as code.")})===!0)}async _runTaskCommand(e){if(!this._tasksReconnected)return;if(!e)return this._doRunTaskCommand();const t=typeof e=="string"?void 0:e.type,s=typeof e=="string"?e:e.task,i=await this._getGroupedTasks({type:t}),r=this._getTaskIdentifier(e),n=i.all(),a=this._createResolver(i),d=this._contextService.getWorkspace().folders.map(o=>o.uri);if(this._contextService.getWorkbenchState()===W.WORKSPACE&&d.push(this._contextService.getWorkspace().configuration),d.push(Z),r)for(const o of d){const c=await a.resolve(o,r);if(c){this.run(c);return}}if(!(s?n.find(o=>o.configurationProperties.identifier===s||o.getDefinition(!0)?.configurationProperties?.identifier===s):void 0))return this._doRunTaskCommand(n,t,s);for(const o of d){const c=await a.resolve(o,s);if(c){await this.run(c,{attachProblemMatcher:!0},S.User);return}}}_tasksAndGroupedTasks(e){if(!this._versionAndEngineCompatible(e))return{tasks:Promise.resolve([]),grouped:Promise.resolve(new A)};const t=this._getGroupedTasks(e);return{tasks:t.then(i=>{if(!e||!e.type)return i.all();const r=[];return i.forEach(n=>{for(const a of n)if(F.is(a)&&a.defines.type===e.type)r.push(a);else if(C.is(a))if(a.type===e.type)r.push(a);else{const d=a.customizes();d&&d.type===e.type&&r.push(a)}}),r}),grouped:t}}_doRunTaskCommand(e,t,s){const i=n=>{n!==void 0&&(n===null?this._runConfigureTasks():this.run(n,{attachProblemMatcher:!0},S.User).then(void 0,a=>{}))},r=l.localize("TaskService.pickRunTask","Select the task to run");this._showIgnoredFoldersMessage().then(()=>{if(this._configurationService.getValue(jt)){let n;e||(n=this._tasksAndGroupedTasks()),this._showQuickPick(e||n.tasks,r,{label:"$(plus) "+l.localize("TaskService.noEntryToRun","Configure a Task"),task:null},!0,void 0,void 0,void 0,s).then(a=>i(a?a.task:void 0))}else this._showTwoLevelQuickPick(r,{label:"$(plus) "+l.localize("TaskService.noEntryToRun","Configure a Task"),task:null},t,s).then(i)})}_reRunTaskCommand(){X.onReady().then(()=>this._editorService.saveAll({reason:ye.AUTO}).then(()=>{const e=this._getTaskSystem().rerun();return e?this._handleExecuteResult(e):(this._taskRunningState.get()||this._doRunTaskCommand(),Promise.resolve(void 0))}))}_getDefaultTasks(e,t=!1){const s=[];for(const i of e.filter(r=>!!r.configurationProperties.group))(t&&typeof i.configurationProperties.group.isDefault=="string"||!t&&i.configurationProperties.group.isDefault===!0)&&s.push(i);return s}_runTaskGroupCommand(e,t,s,i){if(this.schemaVersion===M.V0_1_0){i();return}const r={location:nt.Window,title:t.fetching},n=(async()=>{async function a(h,p,k){k.run(h,p,S.User).then(void 0,m=>{})}const d=h=>{this._showIgnoredFoldersMessage().then(()=>{this._showQuickPick(h,t.select,{label:t.notFoundConfigure,task:null},!0).then(p=>{const k=p?p.task:void 0;if(k!==void 0){if(k===null){s.apply(this);return}a(k,{attachProblemMatcher:!0},this)}})})};let u=[];const{globGroupTasks:o,globTasksDetected:c}=await this._getGlobTasks(e._id);u=[...o],!c&&u.length===0&&(u=await this._findWorkspaceTasksInGroup(e,!0));const f=h=>this._getTasksForGroup(e).then(p=>{if(p.length>0){const k=this._getDefaultTasks(p,h);if(k.length===1){a(k[0],void 0,this);return}else k.length>0&&(p=k)}d(p)}),g=h=>{L.is(h)?this.tryResolveTask(h).then(p=>{a(p,void 0,this)}):a(h,void 0,this)};return u.length===1?g(u[0]):c&&u.length>1?f(!0):(u.length||(u=await this._findWorkspaceTasksInGroup(e,!0)),u.length===1?g(u[0]):f(!1))})();this._progressService.withProgress(r,()=>n)}async _getGlobTasks(e){let t=!1;const s=gt.getOriginalUri(this._editorService.activeEditor);if(s){const i=this._contextService.getWorkspaceFolder(s);if(i){const r=this._getConfiguration(i)?.config?.tasks;if(r&&(t=r.filter(n=>n.group&&typeof n.group!="string"&&typeof n.group.isDefault=="string").length>0,t)){const n=i?.uri?te.relativePath(i.uri,s)??s.path:s.path;return{globGroupTasks:await this._findWorkspaceTasks(d=>{const u=d.configurationProperties.group;return u&&typeof u!="string"&&typeof u.isDefault=="string"?u._id===e&&ze.match(u.isDefault,n):(t=!1,!1)}),globTasksDetected:t}}}}return{globGroupTasks:[],globTasksDetected:t}}_runBuildCommand(){if(this._tasksReconnected)return this._runTaskGroupCommand(R.Build,{fetching:l.localize("TaskService.fetchingBuildTasks","Fetching build tasks..."),select:l.localize("TaskService.pickBuildTask","Select the build task to run"),notFoundConfigure:l.localize("TaskService.noBuildTask","No build task to run found. Configure Build Task...")},this._runConfigureDefaultBuildTask,this._build)}_runTestCommand(){return this._runTaskGroupCommand(R.Test,{fetching:l.localize("TaskService.fetchingTestTasks","Fetching test tasks..."),select:l.localize("TaskService.pickTestTask","Select the test task to run"),notFoundConfigure:l.localize("TaskService.noTestTaskTerminal","No test task to run found. Configure Tasks...")},this._runConfigureDefaultTestTask,this._runTest)}_runTerminateCommand(e){if(e==="terminateAll"){this._terminateAll();return}const t=s=>{this._showQuickPick(s||this.getActiveTasks(),l.localize("TaskService.taskToTerminate","Select a task to terminate"),{label:l.localize("TaskService.noTaskRunning","No task is currently running"),task:void 0},!1,!0,void 0,[{label:l.localize("TaskService.terminateAllRunningTasks","All Running Tasks"),id:"terminateAll",task:void 0}]).then(i=>{i&&i.id==="terminateAll"&&this._terminateAll();const r=i?i.task:void 0;r!=null&&this.terminate(r)})};if(this.inTerminal()){const s=this._getTaskIdentifier(e);let i;s!==void 0?(i=this.getActiveTasks(),i.then(r=>{for(const n of r)if(n.matches(s)){this.terminate(n);return}t(i)})):t()}else this._isActive().then(s=>{s&&this._terminateAll().then(i=>{const r=i[0];r.success||(r.code&&r.code===Qe.ProcessNotFound?this._notificationService.error(l.localize("TerminateAction.noProcess","The launched process doesn't exist anymore. If the task spawned background tasks exiting VS Code might result in orphaned processes.")):this._notificationService.error(l.localize("TerminateAction.failed","Failed to terminate running task")))})})}async _runRestartTaskCommand(e){const t=await this.getActiveTasks();if(t.length===1){this._restart(t[0]);return}if(this.inTerminal()){const s=this._getTaskIdentifier(e);if(s!==void 0){for(const r of t)if(r.matches(s)){this._restart(r);return}}const i=await this._showQuickPick(t,l.localize("TaskService.taskToRestart","Select the task to restart"),{label:l.localize("TaskService.noTaskToRestart","No task to restart"),task:null},!1,!0);i&&i.task&&this._restart(i.task)}else t.length>0&&this._restart(t[0])}_getTaskIdentifier(e){let t;return E.isString(e)?t=e:e&&E.isString(e.type)&&(t=ne.createTaskIdentifier(e,console)),t}_configHasTasks(e){return!!e&&!!e.tasks&&e.tasks.length>0}_openTaskFile(e,t){let s=!1;this._fileService.stat(e).then(i=>i,()=>{}).then(async i=>{const r=!!i,n=this._configurationService.inspect("tasks",{resource:e});let a,d;switch(t){case y.User:a=this._configHasTasks(n.userValue),d=J.USER;break;case y.WorkspaceFile:a=this._configHasTasks(n.workspaceValue),d=J.WORKSPACE;break;default:a=this._configHasTasks(n.workspaceFolderValue),d=J.WORKSPACE_FOLDER}let u;if(!a){const o=await this._quickInputService.pick(Nt(),{placeHolder:l.localize("TaskService.template","Select a Task Template")});if(!o)return Promise.resolve(void 0);u=o.content;const c=this._configurationService.getValue();c.editor.insertSpaces&&(u=u.replace(/(\n)(\t+)/g,(f,g,h)=>g+" ".repeat(h.length*c.editor.tabSize))),s=!0}if(!r&&u)return this._textFileService.create([{resource:e,value:u}]).then(o=>o[0].resource);if(r&&(a||u)){const o=i?.resource;return u&&o&&this._configurationService.updateValue("tasks",De.parse(u),{resource:o},d),o}}).then(i=>{i&&this._editorService.openEditor({resource:i,options:{pinned:s}})})}_isTaskEntry(e){const t=e;return t&&!!t.task}_isSettingEntry(e){const t=e;return t&&!!t.settingType}_configureTask(e){F.is(e)?this.customize(e,void 0,!0):C.is(e)?this.openConfig(e):L.is(e)}_handleSelection(e){if(e)if(this._isTaskEntry(e))this._configureTask(e.task);else if(this._isSettingEntry(e))this._instantiationService.createInstance(Q).handleSettingOption(e.settingType);else if(e.folder&&this._contextService.getWorkbenchState()!==W.EMPTY)this._openTaskFile(e.folder.toResource(".vscode/tasks.json"),y.Workspace);else{const t=this._getResourceForKind(y.User);t&&this._openTaskFile(t,y.User)}}getTaskDescription(e){let t;if(e._source.kind===y.User)t=l.localize("taskQuickPick.userSettings","User");else if(e._source.kind===y.WorkspaceFile)t=e.getWorkspaceFileName();else if(this.needsFolderQualification()){const s=e.getWorkspaceFolder();s&&(t=s.name)}return t}async _runConfigureTasks(){if(!await this._trust())return;let e;this.schemaVersion===M.V2_0_0?e=this._getGroupedTasks():e=Promise.resolve(new A);const t=this._contextService.getWorkspace().folders.map(o=>this._fileService.stat(o.toResource(".vscode/tasks.json")).then(c=>c,()=>{})),s=l.localize("TaskService.createJsonFile","Create tasks.json file from template"),i=l.localize("TaskService.openJsonFile","Open tasks.json file"),r=new _e,n=r.token,a=Promise.all(t).then(o=>e.then(c=>{const f=[];let g=0,h=c.all();if(h.length>0){h=h.sort((k,m)=>k._label.localeCompare(m._label));for(const k of h){const m={label:Q.getTaskLabelWithIcon(k),task:k,description:this.getTaskDescription(k),detail:this._showDetail()?k.configurationProperties.detail:void 0};Q.applyColorStyles(k,m,this._themeService),f.push(m),F.is(k)||g++}}const p=g===0;if(p||c.get(Z).length===g){const k=o[0]!==void 0?i:s;f.length&&f.push({type:"separator"}),f.push({label:k,folder:this._contextService.getWorkspace().folders[0]})}return f.length===1&&!p&&r.cancel(),f}));if(!await Promise.race([new Promise(o=>{a.then(()=>o(!1))}),new Promise(o=>{const c=setTimeout(()=>{clearTimeout(c),o(!0)},200)})])&&(await a).length===1&&this._configurationService.getValue(Pe)){const o=(await a)[0];if(o.task){this._handleSelection(o);return}}const u=a.then(o=>(o.push(...Q.allSettingEntries(this._configurationService)),o));this._quickInputService.pick(u,{placeHolder:l.localize("TaskService.pickTask","Select a task to configure")},n).then(async o=>{if(n.isCancellationRequested){const c=(await a)[0];c.task&&(o=c)}this._handleSelection(o)})}_runConfigureDefaultBuildTask(){this.schemaVersion===M.V2_0_0?this.tasks().then(e=>{if(e.length===0){this._runConfigureTasks();return}const t=[];let s,i;this._showIgnoredFoldersMessage().then(async()=>{const{globGroupTasks:r}=await this._getGlobTasks(R.Build._id);let n=r;n?.length||(n=this._getDefaultTasks(e,!1));let a;if(n.length===1){const o=n[0].configurationProperties.group;o&&(typeof o=="string"&&R.Build._id,a=n[0])}for(const o of e)if(o===a){const c=l.localize("TaskService.defaultBuildTaskExists","{0} is already marked as the default build task",Q.getTaskLabelWithIcon(o,o.getQualifiedLabel()));s=o,i={label:c,task:o,description:this.getTaskDescription(o),detail:this._showDetail()?o.configurationProperties.detail:void 0},Q.applyColorStyles(o,i,this._themeService)}else{const c={label:Q.getTaskLabelWithIcon(o),task:o,description:this.getTaskDescription(o),detail:this._showDetail()?o.configurationProperties.detail:void 0};Q.applyColorStyles(o,c,this._themeService),t.push(c)}i&&t.unshift(i);const u=new _e().token;this._quickInputService.pick(t,{placeHolder:l.localize("TaskService.pickTask","Select a task to configure")},u).then(async o=>{if(u.isCancellationRequested){const f=(await t)[0];f.task&&(o=f)}const c=o&&"task"in o?o.task:void 0;c!=null&&(c===s&&C.is(c)&&this.openConfig(c),x.is(c)||this.customize(c,{group:{kind:"build",isDefault:!0}},!0).then(()=>{s&&c!==s&&!x.is(s)&&this.customize(s,{group:"build"},!1)}))}),this._quickInputService.pick(t,{placeHolder:l.localize("TaskService.pickDefaultBuildTask","Select the task to be used as the default build task")}).then(o=>{const c=o&&"task"in o?o.task:void 0;c!=null&&(c===s&&C.is(c)&&this.openConfig(c),x.is(c)||this.customize(c,{group:{kind:"build",isDefault:!0}},!0).then(()=>{s&&c!==s&&!x.is(s)&&this.customize(s,{group:"build"},!1)}))})})}):this._runConfigureTasks()}_runConfigureDefaultTestTask(){this.schemaVersion===M.V2_0_0?this.tasks().then(e=>{if(e.length===0){this._runConfigureTasks();return}let t,s;for(const i of e){const r=R.from(i.configurationProperties.group);if(r&&r.isDefault&&r._id===R.Test._id){t=i;break}}t&&(s={label:l.localize("TaskService.defaultTestTaskExists","{0} is already marked as the default test task.",t.getQualifiedLabel()),task:t,detail:this._showDetail()?t.configurationProperties.detail:void 0}),this._showIgnoredFoldersMessage().then(()=>{this._showQuickPick(e,l.localize("TaskService.pickDefaultTestTask","Select the task to be used as the default test task"),void 0,!0,!1,s).then(i=>{const r=i?i.task:void 0;r&&(r===t&&C.is(r)&&this.openConfig(r),x.is(r)||this.customize(r,{group:{kind:"test",isDefault:!0}},!0).then(()=>{t&&r!==t&&!x.is(t)&&this.customize(t,{group:"test"},!1)}))})})}):this._runConfigureTasks()}async runShowTasks(){const e=this.getActiveTasks(),t=await e;let s;t.length===1?this._taskSystem.revealTask(t[0]):t.length&&t.every(i=>x.is(i)?!1:(s||(s=i.command.presentation?.group),i.command.presentation?.group&&i.command.presentation.group===s))?this._taskSystem.revealTask(t[0]):this._showQuickPick(e,l.localize("TaskService.pickShowTask","Select the task to show its output"),{label:l.localize("TaskService.noTaskIsRunning","No task is running"),task:null},!1,!0).then(i=>{const r=i?i.task:void 0;r!=null&&this._taskSystem.revealTask(r)})}async _createTasksDotOld(e){const t=e.toResource(".vscode/tasks.json");if(await this._fileService.exists(t)){const s=t.with({path:`${t.path}.old`});return await this._fileService.copy(t,s,!0),[s,t]}}_upgradeTask(e,t,s){if(!C.is(e))return;const i={label:e._label},r=new Set(["gulp","jake","grunt"]);E.isString(e.command.name)&&r.has(e.command.name)?(i.type=e.command.name,i.task=e.command.args[0]):(e.command.runtime===fe.Shell&&(i.type=fe.toString(fe.Shell)),e.command.name&&!t&&!s.windows?.command&&!s.osx?.command&&!s.linux?.command?i.command=e.command.name:t&&(i.command=e._source.config.element.command),e.command.args&&(!Array.isArray(e.command.args)||e.command.args.length>0)&&(!s.windows?.args&&!s.osx?.args&&!s.linux?.args?i.args=e.command.args:i.args=e._source.config.element.args)),e.configurationProperties.presentation&&(i.presentation=e.configurationProperties.presentation),e.configurationProperties.isBackground&&(i.isBackground=e.configurationProperties.isBackground),e.configurationProperties.problemMatchers&&(i.problemMatcher=e._source.config.element.problemMatcher),e.configurationProperties.group&&(i.group=e.configurationProperties.group),e._source.config.element=i;const n=new C(e._id,e._source,e._label,e.type,e.command,e.hasDefinedMatchers,e.runOptions,e.configurationProperties),a=this._createCustomizableTask(n);if(a)return a}async _upgrade(){if(this.schemaVersion===M.V2_0_0)return;if(!this._workspaceTrustManagementService.isWorkspaceTrusted()){this._register(ue.once(this._workspaceTrustManagementService.onDidChangeTrust)(s=>{s&&this._upgrade()}));return}const e=await this._getGroupedTasks(),t=[];for(const s of this.workspaceFolders){const i=await this._createTasksDotOld(s);if(i&&t.push(i),!i)continue;const r=[],n=!!this._configurationService.getValue(U.SuppressTaskName,{resource:s.uri}),a={windows:this._configurationService.getValue(U.Windows,{resource:s.uri}),osx:this._configurationService.getValue(U.Osx,{resource:s.uri}),linux:this._configurationService.getValue(U.Linux,{resource:s.uri})};e.get(s).forEach(d=>{const u=this._upgradeTask(d,n,a);u&&r.push(u)}),this._taskSystem=void 0,this._workspaceTasksPromise=void 0,await this._writeConfiguration(s,"tasks.tasks",r),await this._writeConfiguration(s,"tasks.version","2.0.0"),this._configurationService.getValue(U.ShowOutput,{resource:s.uri})&&await this._configurationService.updateValue(U.ShowOutput,void 0,{resource:s.uri}),this._configurationService.getValue(U.IsShellCommand,{resource:s.uri})&&await this._configurationService.updateValue(U.IsShellCommand,void 0,{resource:s.uri}),this._configurationService.getValue(U.SuppressTaskName,{resource:s.uri})&&await this._configurationService.updateValue(U.SuppressTaskName,void 0,{resource:s.uri})}this._updateSetup(),this._notificationService.prompt(z.Warning,t.length===1?l.localize("taskService.upgradeVersion","The deprecated tasks version 0.1.0 has been removed. Your tasks have been upgraded to version 2.0.0. Open the diff to review the upgrade."):l.localize("taskService.upgradeVersionPlural","The deprecated tasks version 0.1.0 has been removed. Your tasks have been upgraded to version 2.0.0. Open the diffs to review the upgrade."),[{label:t.length===1?l.localize("taskService.openDiff","Open diff"):l.localize("taskService.openDiffs","Open diffs"),run:async()=>{for(const s of t)await this._editorService.openEditor({original:{resource:s[0]},modified:{resource:s[1]}})}}])}};w=me([T(0,qe),T(1,tt),T(2,bt),T(3,Ct),T(4,Ft),T(5,Je),T(6,mt),T(7,Xe),T(8,dt),T(9,ct),T(10,Et),T(11,je),T(12,vt),T(13,ot),T(14,Tt),T(15,Mt),T(16,xt),T(17,at),T(18,rt),T(19,it),T(20,$e),T(21,st),T(22,He),T(23,_t),T(24,zt),T(25,wt),T(26,Be),T(27,Pt),T(28,ht),T(29,pt),T(30,kt),T(31,et),T(32,lt),T(33,St),T(34,Rt),T(35,Ze)],w);export{w as AbstractTaskService,ae as ConfigureTaskAction};
