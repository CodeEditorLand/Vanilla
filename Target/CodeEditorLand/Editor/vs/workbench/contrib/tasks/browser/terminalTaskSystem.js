import{asArray as ce}from"../../../../base/common/arrays.js";import*as le from"../../../../base/common/async.js";import"../../../../base/common/collections.js";import{Emitter as _e}from"../../../../base/common/event.js";import{isUNC as Y}from"../../../../base/common/extpath.js";import{Disposable as Se,DisposableStore as Ie}from"../../../../base/common/lifecycle.js";import{LinkedMap as ke,Touch as me}from"../../../../base/common/map.js";import*as Z from"../../../../base/common/objects.js";import*as R from"../../../../base/common/path.js";import*as y from"../../../../base/common/platform.js";import*as be from"../../../../base/common/resources.js";import N from"../../../../base/common/severity.js";import*as b from"../../../../base/common/types.js";import*as P from"../../../../nls.js";import"../../../../editor/common/services/model.js";import"../../../../platform/files/common/files.js";import{MarkerSeverity as ee}from"../../../../platform/markers/common/markers.js";import{WorkbenchState as ue}from"../../../../platform/workspace/common/workspace.js";import{Markers as te}from"../../markers/common/markers.js";import{ProblemMatcherRegistry as Q}from"../common/problemMatcher.js";import{Codicon as ye}from"../../../../base/common/codicons.js";import{Schemas as de}from"../../../../base/common/network.js";import{ThemeIcon as $}from"../../../../base/common/themables.js";import{URI as Pe}from"../../../../base/common/uri.js";import"../../../../platform/instantiation/common/instantiation.js";import"../../../../platform/log/common/log.js";import"../../../../platform/notification/common/notification.js";import"../../../../platform/terminal/common/terminal.js";import{formatMessageForTerminal as K}from"../../../../platform/terminal/common/terminalStrings.js";import{ViewContainerLocation as z}from"../../../common/views.js";import"../../../services/views/common/viewsService.js";import{TaskTerminalStatus as we}from"./taskTerminalStatus.js";import{ProblemCollectorEventKind as fe,ProblemHandlingStrategy as Ce,StartStopProblemCollector as xe,WatchingProblemCollector as Ee}from"../common/problemCollectors.js";import{GroupKind as Ve}from"../common/taskConfiguration.js";import{TaskError as U,TaskErrors as ie,TaskExecuteKind as he,Triggers as ne}from"../common/taskSystem.js";import{CommandString as j,ContributedTask as re,CustomTask as B,DependsOrder as Re,InMemoryTask as Me,PanelKind as D,RevealKind as q,RevealProblemKind as se,RuntimeType as O,ShellQuoting as G,TaskEvent as I,TaskEventKind as w,TaskScope as Ae,TaskSourceKind as pe}from"../common/tasks.js";import"../../terminal/browser/terminal.js";import{VSCodeOscProperty as ge,VSCodeOscPt as L,VSCodeSequence as W}from"../../terminal/browser/terminalEscapeSequences.js";import{TerminalProcessExtHostProxy as De}from"../../terminal/browser/terminalProcessExtHostProxy.js";import{TERMINAL_VIEW_ID as ae}from"../../terminal/common/terminal.js";import"../../../services/configurationResolver/common/configurationResolver.js";import"../../../services/environment/common/environmentService.js";import"../../../services/output/common/output.js";import"../../../services/panecomposite/browser/panecomposite.js";import"../../../services/path/common/pathService.js";const H="Task";class F{constructor(k,e,t,i){this.workspaceFolder=k;this.taskSystemInfo=e;this.values=t;this._service=i}static _regex=/\$\{(.*?)\}/g;async resolve(k){const e=[];k.replace(F._regex,(i,...r)=>(e.push(this._replacer(i,r)),i));const t=await Promise.all(e);return k.replace(F._regex,()=>t.shift())}async _replacer(k,e){const t=this.values.get(k.substring(2,k.length-1));return t??(this._service?this._service.resolveAsync(this.workspaceFolder,k):k)}}class Oe{task;resolver;trigger;resolvedVariables;systemInfo;workspaceFolder;shellLaunchConfig;constructor(k,e,t){this.task=k,this.resolver=e,this.trigger=t}verify(){let k=!1;return this.trigger&&this.resolvedVariables&&this.workspaceFolder&&this.shellLaunchConfig!==void 0&&(k=!0),k}getVerifiedTask(){if(this.verify())return{task:this.task,resolver:this.resolver,trigger:this.trigger,resolvedVariables:this.resolvedVariables,systemInfo:this.systemInfo,workspaceFolder:this.workspaceFolder,shellLaunchConfig:this.shellLaunchConfig};throw new Error("VerifiedTask was not checked. verify must be checked before getVerifiedTask.")}}class V extends Se{constructor(e,t,i,r,n,o,a,c,s,m,S,g,h,p,l,v,f,u,d){super();this._terminalService=e;this._terminalGroupService=t;this._outputService=i;this._paneCompositeService=r;this._viewsService=n;this._markerService=o;this._modelService=a;this._configurationResolverService=c;this._contextService=s;this._environmentService=m;this._outputChannelId=S;this._fileService=g;this._terminalProfileResolverService=h;this._pathService=p;this._viewDescriptorService=l;this._logService=v;this._notificationService=f;this._activeTasks=Object.create(null),this._busyTasks=Object.create(null),this._terminals=Object.create(null),this._idleTaskTerminals=new ke,this._sameTaskTerminals=Object.create(null),this._onDidStateChange=new _e,this._taskSystemInfoResolver=d,this._register(this._terminalStatusManager=u.createInstance(we))}static TelemetryEventName="taskService";static ProcessVarName="__process__";static _shellQuotes={cmd:{strong:'"'},powershell:{escape:{escapeChar:"`",charsToEscape:` "'()`},strong:"'",weak:'"'},bash:{escape:{escapeChar:"\\",charsToEscape:` "'`},strong:"'",weak:'"'},zsh:{escape:{escapeChar:"\\",charsToEscape:` "'`},strong:"'",weak:'"'}};static _osShellQuotes={Linux:V._shellQuotes.bash,Mac:V._shellQuotes.bash,Windows:V._shellQuotes.powershell};_activeTasks;_busyTasks;_terminals;_idleTaskTerminals;_sameTaskTerminals;_taskSystemInfoResolver;_lastTask;_currentTask;_isRerun=!1;_previousPanelId;_previousTerminalInstance;_terminalStatusManager;_terminalCreationQueue=Promise.resolve();_hasReconnected=!1;_onDidStateChange;_reconnectedTerminals;taskShellIntegrationStartSequence(e){return W(L.PromptStart)+W(L.Property,`${ge.Task}=True`)+(e?W(L.Property,`${ge.Cwd}=${typeof e=="string"?e:e.fsPath}`):"")+W(L.CommandStart)}get taskShellIntegrationOutputSequence(){return W(L.CommandExecuted)}get onDidStateChange(){return this._onDidStateChange.event}_log(e){this._appendOutput(e+`
`)}_showOutput(){this._outputService.showChannel(this._outputChannelId,!0)}reconnect(e,t){return this._reconnectToTerminals(),this.run(e,t,ne.reconnect)}run(e,t,i=ne.command){e=e.clone();const r=Me.is(e)||this._isTaskEmpty(e)?[]:this._getInstances(e),n=r.length<((e.runOptions&&e.runOptions.instanceLimit)??1),o=r[0]?.count?.count??0;if(this._currentTask=new Oe(e,t,i),o>0&&(e.instance=o),!n){const a=r[r.length-1];return this._lastTask=this._currentTask,{kind:he.Active,task:a.task,active:{same:!0,background:e.configurationProperties.isBackground},promise:a.promise}}try{const a={kind:he.Started,task:e,started:{},promise:this._executeTask(e,t,i,new Set,new Map,void 0)};return a.promise.then(c=>{this._lastTask=this._currentTask}),a}catch(a){throw a instanceof U?a:a instanceof Error?(this._log(a.message),new U(N.Error,a.message,ie.UnknownError)):(this._log(a.toString()),new U(N.Error,P.localize("TerminalTaskSystem.unknownError","A unknown error has occurred while executing a task. See task output log for details."),ie.UnknownError))}}rerun(){if(this._lastTask&&this._lastTask.verify()){this._lastTask.task.runOptions.reevaluateOnRerun!==void 0&&!this._lastTask.task.runOptions.reevaluateOnRerun&&(this._isRerun=!0);const e=this.run(this._lastTask.task,this._lastTask.resolver);return e.promise.then(t=>{this._isRerun=!1}),e}else return}_showTaskLoadErrors(e){e.taskLoadMessages&&e.taskLoadMessages.length>0&&(e.taskLoadMessages.forEach(i=>{this._log(i+`
`)}),this._notificationService.prompt(N.Warning,P.localize("TerminalTaskSystem.taskLoadReporting",'There are issues with task "{0}". See the output for more details.',e._label),[{label:"Show Output",run:()=>this._showOutput()}]))}isTaskVisible(e){const t=this._activeTasks[e.getMapKey()];if(!t?.terminal)return!1;const i=this._terminalService.activeInstance;return!!this._viewsService.getActiveViewWithId(ae)&&i?.instanceId===t.terminal.instanceId}revealTask(e){const t=this._activeTasks[e.getMapKey()];if(!t?.terminal)return!1;const i=this._viewDescriptorService.getViewLocationById(ae)===z.Panel;return i&&this.isTaskVisible(e)?(this._previousPanelId?(this._previousTerminalInstance&&this._terminalService.setActiveInstance(this._previousTerminalInstance),this._paneCompositeService.openPaneComposite(this._previousPanelId,z.Panel)):this._paneCompositeService.hideActivePaneComposite(z.Panel),this._previousPanelId=void 0,this._previousTerminalInstance=void 0):(i&&(this._previousPanelId=this._paneCompositeService.getActivePaneComposite(z.Panel)?.getId(),this._previousPanelId===ae&&(this._previousTerminalInstance=this._terminalService.activeInstance??void 0)),this._terminalService.setActiveInstance(t.terminal),(B.is(e)||re.is(e))&&this._terminalGroupService.showPanel(e.command.presentation.focus)),!0}isActive(){return Promise.resolve(this.isActiveSync())}isActiveSync(){return Object.values(this._activeTasks).some(e=>!!e.terminal)}canAutoTerminate(){return Object.values(this._activeTasks).every(e=>!e.task.configurationProperties.promptOnClose)}getActiveTasks(){return Object.values(this._activeTasks).flatMap(e=>e.terminal?e.task:[])}getLastInstance(e){const t=e.getKey();return Object.values(this._activeTasks).reverse().find(i=>t&&t===i.task.getKey())?.task}getBusyTasks(){return Object.keys(this._busyTasks).map(e=>this._busyTasks[e])}customExecutionComplete(e,t){return this._activeTasks[e.getMapKey()]?.terminal?new Promise(r=>{r()}):Promise.reject(new Error("Expected to have a terminal for a custom execution task"))}_getInstances(e){const t=e.getKey();return Object.values(this._activeTasks).filter(i=>t&&t===i.task.getKey())}_removeFromActiveTasks(e){const t=typeof e=="string"?e:e.getMapKey();this._activeTasks[t]&&delete this._activeTasks[t]}_fireTaskEvent(e){if(e.kind!==w.Changed){const t=this._activeTasks[e.__task.getMapKey()];t&&(t.state=e.kind)}this._onDidStateChange.fire(e)}terminate(e){const t=this._activeTasks[e.getMapKey()];if(!t)return Promise.resolve({success:!1,task:void 0});const i=t.terminal;return i?new Promise((r,n)=>{i.onDisposed(a=>{this._fireTaskEvent(I.terminated(e,a.instanceId,a.exitReason))});const o=i.onExit(()=>{const a=t.task;try{o.dispose(),this._fireTaskEvent(I.terminated(a,i.instanceId,i.exitReason))}catch{}r({success:!0,task:a})});i.dispose()}):Promise.resolve({success:!1,task:void 0})}terminateAll(){const e=[];for(const[t,i]of Object.entries(this._activeTasks)){const r=i?.terminal;r&&(e.push(new Promise((n,o)=>{const a=r.onExit(()=>{const c=i.task;try{a.dispose(),this._fireTaskEvent(I.terminated(c,r.instanceId,r.exitReason))}catch{}this._activeTasks[t]===i&&delete this._activeTasks[t],n({success:!0,task:i.task})})})),r.dispose())}return Promise.all(e)}_showDependencyCycleMessage(e){this._log(P.localize("dependencyCycle",'There is a dependency cycle. See task "{0}".',e._label)),this._showOutput()}_executeTask(e,t,i,r,n,o){this._showTaskLoadErrors(e);const a=e.getMapKey(),c=Promise.resolve().then(async()=>{o=o??new Map;const g=[];if(e.configurationProperties.dependsOn){const h=new Set(r).add(e.getCommonTaskId());for(const p of e.configurationProperties.dependsOn){const l=await t.resolve(p.uri,p.task);if(l){this._adoptConfigurationForDependencyTask(l,e);let v;const f=l.getCommonTaskId();if(h.has(f))this._showDependencyCycleMessage(l),v=Promise.resolve({});else if(v=n.get(f),!v){const u=this._activeTasks[l.getMapKey()]??this._getInstances(l).pop();v=u&&this._getDependencyPromise(u)}if(v||(this._fireTaskEvent(I.general(w.DependsOnStarted,e)),v=this._executeDependencyTask(l,t,i,h,n,o)),n.set(f,v),g.push(v),e.configurationProperties.dependsOrder===Re.sequence&&(await v).exitCode!==0)break}else this._log(P.localize("dependencyFailed","Couldn't resolve dependent task '{0}' in workspace folder '{1}'",b.isString(p.task)?p.task:JSON.stringify(p.task,void 0,0),p.uri.toString())),this._showOutput()}}return Promise.all(g).then(h=>{for(const p of h)if(p.exitCode!==0)return{exitCode:p.exitCode};return(re.is(e)||B.is(e))&&e.command?this._isRerun?this._reexecuteCommand(e,i,o):this._executeCommand(e,i,o):{exitCode:0}})}).finally(()=>{delete this._activeTasks[a]}),m=this._getInstances(e).pop()?.count??{count:0};m.count++;const S={task:e,promise:c,count:m};return this._activeTasks[a]=S,c}_createInactiveDependencyPromise(e){return new Promise(t=>{const i=this.onDidStateChange(r=>{r.kind===w.Inactive&&r.__task===e&&(i.dispose(),t({exitCode:0}))})})}_adoptConfigurationForDependencyTask(e,t){e.configurationProperties.icon?(e.configurationProperties.icon.id||=t.configurationProperties.icon?.id,e.configurationProperties.icon.color||=t.configurationProperties.icon?.color):e.configurationProperties.icon=t.configurationProperties.icon}async _getDependencyPromise(e){return!e.task.configurationProperties.isBackground||!e.task.configurationProperties.problemMatchers||e.task.configurationProperties.problemMatchers.length===0?e.promise:e.state===w.Inactive?{exitCode:0}:this._createInactiveDependencyPromise(e.task)}async _executeDependencyTask(e,t,i,r,n,o){if(!e.configurationProperties.isBackground)return this._executeTask(e,t,i,r,n,o);const a=this._createInactiveDependencyPromise(e);return Promise.race([a,this._executeTask(e,t,i,r,n,o)])}async _resolveAndFindExecutable(e,t,i,r,n){const o=await this._configurationResolverService.resolveAsync(t,j.value(i.command.name));r=r?await this._configurationResolverService.resolveAsync(t,r):void 0;const a=n?await Promise.all(n.split(R.delimiter).map(s=>this._configurationResolverService.resolveAsync(t,s))):void 0;let c=await e?.findExecutable(o,r,a);return c||(c=R.join(r??"",o)),c}_findUnresolvedVariables(e,t){if(t.size===0)return e;const i=new Set;for(const r of e)t.has(r.substring(2,r.length-1))||i.add(r);return i}_mergeMaps(e,t){for(const i of t)e.has(i[0])||e.set(i[0],i[1])}async _acquireInput(e,t,i,r,n){const o=await this._resolveVariablesFromSet(e,t,i,r,n);return this._fireTaskEvent(I.general(w.AcquiredInput,i)),o}_resolveVariablesFromSet(e,t,i,r,n){const o=i.command&&i.command.runtime===O.Process,a=i.command&&i.command.options?i.command.options:void 0,c=a?a.cwd:void 0;let s;if(a&&a.env){for(const g of Object.keys(a.env))if(g.toLowerCase()==="path"){b.isString(a.env[g])&&(s=a.env[g]);break}}const m=this._findUnresolvedVariables(r,n);let S;if(e&&t){const g={variables:m};return e.platform===y.Platform.Windows&&o&&(g.process={name:j.value(i.command.name)},c&&(g.process.cwd=c),s&&(g.process.path=s)),S=e.resolveVariables(t,g,pe.toConfigurationTarget(i._source.kind)).then(async h=>{if(h){if(this._mergeMaps(n,h.variables),h.variables=new Map(n),o){let p=j.value(i.command.name);e.platform===y.Platform.Windows&&(p=await this._resolveAndFindExecutable(e,t,i,c,s)),h.variables.set(V.ProcessVarName,p)}return h}}),S}else{const g=new Array;return m.forEach(h=>g.push(h)),new Promise((h,p)=>{this._configurationResolverService.resolveWithInteraction(t,g,"tasks",void 0,pe.toConfigurationTarget(i._source.kind)).then(async l=>{if(l){if(this._mergeMaps(n,l),l=new Map(n),o){let f;y.isWindows?f=await this._resolveAndFindExecutable(e,t,i,c,s):f=await this._configurationResolverService.resolveAsync(t,j.value(i.command.name)),l.set(V.ProcessVarName,f)}h({variables:l})}else h(void 0)},l=>{p(l)})})}}_executeCommand(e,t,i){const r=e.getWorkspaceFolder();let n;if(r)n=this._currentTask.workspaceFolder=r;else{const s=this._contextService.getWorkspace().folders;n=s.length>0?s[0]:void 0}const o=this._currentTask.systemInfo=this._taskSystemInfoResolver(n),a=new Set;return this._collectTaskVariables(a,e),this._acquireInput(o,n,e,a,i).then(s=>s&&!this._isTaskEmpty(e)?(this._currentTask.resolvedVariables=s,this._executeInTerminal(e,t,new F(n,o,s.variables,this._configurationResolverService),n)):(this._fireTaskEvent(I.general(w.End,e)),Promise.resolve({exitCode:0})),s=>Promise.reject(s))}_isTaskEmpty(e){const t=e.command.runtime===O.CustomExecution;return!(e.command!==void 0&&e.command.runtime&&(t||e.command.name!==void 0))}_reexecuteCommand(e,t,i){const r=this._lastTask;if(!r)return Promise.reject(new Error("No task previously run"));const n=this._currentTask.workspaceFolder=r.workspaceFolder,o=new Set;this._collectTaskVariables(o,e);let a=!0;return o.forEach(c=>{c.substring(2,c.length-1)in r.getVerifiedTask().resolvedVariables&&(a=!1)}),a?(this._currentTask.resolvedVariables=r.getVerifiedTask().resolvedVariables,this._executeInTerminal(e,t,new F(r.getVerifiedTask().workspaceFolder,r.getVerifiedTask().systemInfo,r.getVerifiedTask().resolvedVariables.variables,this._configurationResolverService),n)):this._acquireInput(r.getVerifiedTask().systemInfo,r.getVerifiedTask().workspaceFolder,e,o,i).then(c=>c?(this._currentTask.resolvedVariables=c,this._executeInTerminal(e,t,new F(r.getVerifiedTask().workspaceFolder,r.getVerifiedTask().systemInfo,c.variables,this._configurationResolverService),n)):(this._fireTaskEvent(I.general(w.End,e)),{exitCode:0}),c=>Promise.reject(c))}async _executeInTerminal(e,t,i,r){let n,o,a;if(e.configurationProperties.isBackground){const s=await this._resolveMatchers(i,e.configurationProperties.problemMatchers),m=new Ee(s,this._markerService,this._modelService,this._fileService);s.length>0&&!m.isWatching()&&(this._appendOutput(P.localize("TerminalTaskSystem.nonWatchingMatcher","Task {0} is a background task but uses a problem matcher without a background pattern",e._label)),this._showOutput());const S=new Ie;let g=0;const h=e.getMapKey();S.add(m.onDidStateChange(f=>{if(f.kind===fe.BackgroundProcessingBegins)g++,this._busyTasks[h]=e,this._fireTaskEvent(I.general(w.Active,e,n?.instanceId));else if(f.kind===fe.BackgroundProcessingEnds&&(g--,this._busyTasks[h]&&delete this._busyTasks[h],this._fireTaskEvent(I.general(w.Inactive,e,n?.instanceId)),g===0&&m.numberOfMatches>0&&m.maxMarkerSeverity&&m.maxMarkerSeverity>=ee.Error)){const u=e.command.presentation.reveal;e.command.presentation.revealProblems===se.OnProblem?this._viewsService.openView(te.MARKERS_VIEW_ID,!0):u===q.Silent&&(this._terminalService.setActiveInstance(n),this._terminalGroupService.showPanel(!1))}})),m.aboutToStart();let p;if([n,o]=await this._createTerminal(e,i,r),o)return Promise.reject(new Error(o.message));if(!n)return Promise.reject(new Error(`Failed to create terminal for task ${e._label}`));this._terminalStatusManager.addTerminal(e,n,m);let l=!1;n.processReady.then(()=>{l||(this._fireTaskEvent(I.processStarted(e,n.instanceId,n.processId)),l=!0)},f=>{this._logService.error("Task terminal process never got ready")}),this._fireTaskEvent(I.start(e,n.instanceId,i.values));let v;if(s.length&&(v=n.onLineData(f=>{m.processLine(f),p||(p=new le.Delayer(3e3)),p.trigger(()=>{m.forceDelivery(),p=void 0})})),a=new Promise((f,u)=>{const d=n.onExit(T=>{const _=typeof T=="number"?T:T?.code;v?.dispose(),d.dispose();const E=e.getMapKey();if(this._busyTasks[h]&&delete this._busyTasks[h],this._removeFromActiveTasks(e),this._fireTaskEvent(I.changed()),T!==void 0)switch(e.command.presentation.panel){case D.Dedicated:this._sameTaskTerminals[E]=n.instanceId.toString();break;case D.Shared:this._idleTaskTerminals.set(E,n.instanceId.toString(),me.AsOld);break}if(e.command.presentation.reveal===q.Silent&&(_!==0||m.numberOfMatches>0&&m.maxMarkerSeverity&&m.maxMarkerSeverity>=ee.Error))try{this._terminalService.setActiveInstance(n),this._terminalGroupService.showPanel(!1)}catch{}m.done(),m.dispose(),l||(this._fireTaskEvent(I.processStarted(e,n.instanceId,n.processId)),l=!0),this._fireTaskEvent(I.processEnded(e,n.instanceId,_));for(let M=0;M<g;M++)this._fireTaskEvent(I.general(w.Inactive,e,n.instanceId));g=0,this._fireTaskEvent(I.general(w.End,e)),S.dispose(),f({exitCode:_??void 0})})}),t===ne.reconnect&&n.xterm){const f=[],u=n.xterm.getBufferReverseIterator(),d=new RegExp(m.beginPatterns.map(_=>_.source).join("|"));for(const _ of u)if(f.push(_),d.test(_))break;let T;for(let _=f.length-1;_>=0;_--)m.processLine(f[_]),T||(T=new le.Delayer(3e3)),T.trigger(()=>{m.forceDelivery(),T=void 0})}}else{if([n,o]=await this._createTerminal(e,i,r),o)return Promise.reject(new Error(o.message));if(!n)return Promise.reject(new Error(`Failed to create terminal for task ${e._label}`));this._fireTaskEvent(I.start(e,n.instanceId,i.values));const s=e.getMapKey();this._busyTasks[s]=e,this._fireTaskEvent(I.general(w.Active,e,n.instanceId));const m=await this._resolveMatchers(i,e.configurationProperties.problemMatchers),S=new xe(m,this._markerService,this._modelService,Ce.Clean,this._fileService);this._terminalStatusManager.addTerminal(e,n,S);let g=!1;n.processReady.then(()=>{g||(this._fireTaskEvent(I.processStarted(e,n.instanceId,n.processId)),g=!0)},p=>{});const h=n.onLineData(p=>{S.processLine(p)});a=new Promise((p,l)=>{const v=n.onExit(f=>{const u=typeof f=="number"?f:f?.code;v.dispose();const d=e.getMapKey();if(this._removeFromActiveTasks(e),this._fireTaskEvent(I.changed()),f!==void 0)switch(e.command.presentation.panel){case D.Dedicated:this._sameTaskTerminals[d]=n.instanceId.toString();break;case D.Shared:this._idleTaskTerminals.set(d,n.instanceId.toString(),me.AsOld);break}const T=e.command.presentation.reveal,_=e.command.presentation.revealProblems;if(n&&_===se.OnProblem&&S.numberOfMatches>0)this._viewsService.openView(te.MARKERS_VIEW_ID);else if(n&&T===q.Silent&&(u!==0||S.numberOfMatches>0&&S.maxMarkerSeverity&&S.maxMarkerSeverity>=ee.Error))try{this._terminalService.setActiveInstance(n),this._terminalGroupService.showPanel(!1)}catch{}setTimeout(()=>{h.dispose(),S.done(),S.dispose()},100),!g&&n&&(this._fireTaskEvent(I.processStarted(e,n.instanceId,n.processId)),g=!0),this._fireTaskEvent(I.processEnded(e,n?.instanceId,u??void 0)),this._busyTasks[s]&&delete this._busyTasks[s],this._fireTaskEvent(I.general(w.Inactive,e,n?.instanceId)),this._fireTaskEvent(I.general(w.End,e,n?.instanceId)),p({exitCode:u??void 0})})})}return e.command.presentation&&e.command.presentation.revealProblems===se.Always?this._viewsService.openView(te.MARKERS_VIEW_ID):e.command.presentation&&(e.command.presentation.focus||e.command.presentation.reveal===q.Always)&&(this._terminalService.setActiveInstance(n),await this._terminalService.revealTerminal(n),e.command.presentation.focus&&this._terminalService.focusInstance(n)),this._activeTasks[e.getMapKey()].terminal=n,this._fireTaskEvent(I.changed()),a}_createTerminalName(e){return this._contextService.getWorkbenchState()===ue.WORKSPACE?e.getQualifiedLabel():e.configurationProperties.name||""}async _createShellLaunchConfig(e,t,i,r,n,o,a,c){let s;const m=e.command.runtime===O.Shell,S=this._contextService.getWorkbenchState()===ue.WORKSPACE,g=this._createTerminalName(e),h=H,p=e.command.name;let l;if(n.cwd&&(l=n.cwd,R.isAbsolute(l)||t&&t.uri.scheme===de.file&&(l=R.join(t.uri.fsPath,l)),l=Y(l)?l:be.toLocalResource(Pe.from({scheme:de.file,path:l}),this._environmentService.remoteAuthority,this._pathService.defaultUriScheme)),m){let v;switch(r){case y.Platform.Windows:v=y.OperatingSystem.Windows;break;case y.Platform.Mac:v=y.OperatingSystem.Macintosh;break;case y.Platform.Linux:default:v=y.OperatingSystem.Linux;break}const f=await this._terminalProfileResolverService.getDefaultProfile({allowAutomationShell:!0,os:v,remoteAuthority:this._environmentService.remoteAuthority});let u;if(e.configurationProperties.icon?.id)u=$.fromId(e.configurationProperties.icon.id);else{const A=e.configurationProperties.group?Ve.to(e.configurationProperties.group):void 0;u=(typeof A=="string"?A:A?.kind)==="test"?$.fromId(ye.beaker.id):f.icon}s={name:g,type:h,executable:f.path,args:f.args,env:{...f.env},icon:u,color:e.configurationProperties.icon?.color||void 0,waitOnExit:c};let d=!1;const T=e.command.options&&e.command.options.shell;T&&(T.executable&&(T.executable!==s.executable&&(s.args=void 0),s.executable=await this._resolveVariable(i,T.executable),d=!0),T.args&&(s.args=await this._resolveVariables(i,T.args.slice()))),s.args===void 0&&(s.args=[]);const _=Array.isArray(s.args)?s.args.slice(0):[s.args],E=[],C=R.posix.basename((await this._pathService.fileURI(s.executable)).path).toLowerCase(),M=this._buildShellCommandLine(r,C,T,o,p,a);let J=!1;if(r===y.Platform.Windows){J=!0;const A=await this._pathService.userHome();if(C==="cmd.exe"&&(n.cwd&&Y(n.cwd)||!n.cwd&&Y(A.fsPath)))return;C==="powershell.exe"||C==="pwsh.exe"?d||E.push("-Command"):C==="bash.exe"||C==="zsh.exe"?(J=!1,d||E.push("-c")):C==="wsl.exe"?d||E.push("-e"):d||E.push("/d","/c")}else d||(y.Platform.Mac,E.push("-c"));const X=this._addAllArgument(E,_);if(X.push(M),s.args=J?X.join(" "):X,e.command.presentation&&e.command.presentation.echo)if(S&&t){const A=l&&typeof l=="object"&&"path"in l?R.basename(l.path):t.name;s.initialText=this.taskShellIntegrationStartSequence(l)+K(P.localize({key:"task.executingInFolder",comment:["The workspace folder the task is running in","The task command line or label"]},"Executing task in folder {0}: {1}",A,M),{excludeLeadingNewLine:!0})+this.taskShellIntegrationOutputSequence}else s.initialText=this.taskShellIntegrationStartSequence(l)+K(P.localize({key:"task.executing.shellIntegration",comment:["The task command line or label"]},"Executing task: {0}",M),{excludeLeadingNewLine:!0})+this.taskShellIntegrationOutputSequence;else s.initialText={text:this.taskShellIntegrationStartSequence(l)+this.taskShellIntegrationOutputSequence,trailingNewLine:!1}}else{const v=e.command.runtime!==O.CustomExecution?j.value(o):void 0,f=m?v:await this._resolveVariable(i,await this._resolveVariable(i,"${"+V.ProcessVarName+"}"));if(s={name:g,type:h,icon:e.configurationProperties.icon?.id?$.fromId(e.configurationProperties.icon.id):void 0,color:e.configurationProperties.icon?.color||void 0,executable:f,args:a.map(u=>b.isString(u)?u:u.value),waitOnExit:c},e.command.presentation&&e.command.presentation.echo){const u=d=>!d||d.length===0?"":b.isString(d)?d:d.join(" ");S&&t?s.initialText=this.taskShellIntegrationStartSequence(l)+K(P.localize({key:"task.executingInFolder",comment:["The workspace folder the task is running in","The task command line or label"]},"Executing task in folder {0}: {1}",t.name,`${s.executable} ${u(s.args)}`),{excludeLeadingNewLine:!0})+this.taskShellIntegrationOutputSequence:s.initialText=this.taskShellIntegrationStartSequence(l)+K(P.localize({key:"task.executing.shell-integration",comment:["The task command line or label"]},"Executing task: {0}",`${s.executable} ${u(s.args)}`),{excludeLeadingNewLine:!0})+this.taskShellIntegrationOutputSequence}else s.initialText={text:this.taskShellIntegrationStartSequence(l)+this.taskShellIntegrationOutputSequence,trailingNewLine:!1}}return l&&(s.cwd=l),n.env&&(s.env?s.env={...s.env,...n.env}:s.env=n.env),s.isFeatureTerminal=!0,s.useShellEnvironment=!0,s}_addAllArgument(e,t){const i=Z.deepClone(t);return e.forEach(r=>{t.every((o,a)=>o.toLowerCase()===r&&t.length>a+1?!t.slice(a+1).every(c=>c.startsWith("-")):o.toLowerCase()!==r)&&i.push(r)}),i}async _reconnectToTerminal(e){if(this._reconnectedTerminals)for(let t=0;t<this._reconnectedTerminals.length;t++){const i=this._reconnectedTerminals[t];if(oe(i)?.lastTask===e.getCommonTaskId())return this._reconnectedTerminals.splice(t,1),i}}async _doCreateTerminal(e,t,i){const r=await this._reconnectToTerminal(e),n=a=>this._fireTaskEvent(I.terminated(e,a.instanceId,a.exitReason));if(r)return"command"in e&&e.command.presentation&&(r.waitOnExit=ve(e.command.presentation,e.configurationProperties)),r.onDisposed(n),this._logService.trace("reconnected to task and terminal",e._id),r;if(t){for(const a of Object.values(this._terminals))if(a.group===t){this._logService.trace(`Found terminal to split for group ${t}`);const c=a.terminal,s=await this._terminalService.createTerminal({location:{parentTerminal:c},config:i});if(s.onDisposed(n),s)return s}this._logService.trace(`No terminal found to split for group ${t}`)}const o=await this._terminalService.createTerminal({config:i});return o.onDisposed(n),o}_reconnectToTerminals(){if(this._hasReconnected){this._logService.trace(`Already reconnected, to ${this._reconnectedTerminals?.length} terminals so returning`);return}if(this._reconnectedTerminals=this._terminalService.getReconnectedTerminals(H)?.filter(e=>!e.isDisposed&&oe(e))||[],this._logService.trace(`Attempting reconnection of ${this._reconnectedTerminals?.length} terminals`),!this._reconnectedTerminals?.length)this._logService.trace("No terminals to reconnect to so returning");else for(const e of this._reconnectedTerminals){const t=oe(e);if(t){const i={lastTask:t.lastTask,group:t.group,terminal:e};this._terminals[e.instanceId]=i,this._logService.trace("Reconnecting to task terminal",i.lastTask,e.instanceId)}}this._hasReconnected=!0}_deleteTaskAndTerminal(e,t){delete this._terminals[e.instanceId],delete this._sameTaskTerminals[t.lastTask],this._idleTaskTerminals.delete(t.lastTask);const i=t.lastTask;this._removeFromActiveTasks(i),this._busyTasks[i]&&delete this._busyTasks[i]}async _createTerminal(e,t,i){const r=t.taskSystemInfo?t.taskSystemInfo.platform:y.platform,n=await this._resolveOptions(t,e.command.options),o=e.command.presentation;if(!o)throw new Error("Task presentation options should not be undefined here.");const a=ve(o,e.configurationProperties);let c,s,m;if(e.command.runtime===O.CustomExecution)this._currentTask.shellLaunchConfig=m={customPtyImplementation:(d,T,_)=>new De(d,T,_,this._terminalService),waitOnExit:a,name:this._createTerminalName(e),initialText:e.command.presentation&&e.command.presentation.echo?K(P.localize({key:"task.executing",comment:["The task command line or label"]},"Executing task: {0}",e._label),{excludeLeadingNewLine:!0}):void 0,isFeatureTerminal:!0,icon:e.configurationProperties.icon?.id?$.fromId(e.configurationProperties.icon.id):void 0,color:e.configurationProperties.icon?.color||void 0};else{const d=await this._resolveCommandAndArgs(t,e.command);if(c=d.command,s=d.args,this._currentTask.shellLaunchConfig=m=await this._createShellLaunchConfig(e,i,t,r,n,c,s,a),m===void 0)return[void 0,new U(N.Error,P.localize("TerminalTaskSystem","Can't execute a shell command on an UNC drive using cmd.exe."),ie.UnknownError)]}const S=o.panel===D.Dedicated,g=o.panel===D.Shared,h=o.group,p=e.getMapKey();let l;if(S){const d=this._sameTaskTerminals[p];d&&(l=this._terminals[d],delete this._sameTaskTerminals[p])}else if(g){let d=this._idleTaskTerminals.remove(p);if(!d)for(const T of this._idleTaskTerminals.keys()){const _=this._idleTaskTerminals.get(T);if(_&&this._terminals[_]&&this._terminals[_].group===h){d=this._idleTaskTerminals.remove(T);break}}d&&(l=this._terminals[d])}if(l){if(!m)throw new Error("Task shell launch configuration should not be undefined here.");return l.terminal.scrollToBottom(),e.configurationProperties.isBackground&&(m.reconnectionProperties={ownerId:H,data:{lastTask:e.getCommonTaskId(),group:h,label:e._label,id:e._id}}),await l.terminal.reuseTerminal(m),e.command.presentation&&e.command.presentation.clear&&l.terminal.clearBuffer(),this._terminals[l.terminal.instanceId.toString()].lastTask=p,[l.terminal,void 0]}this._terminalCreationQueue=this._terminalCreationQueue.then(()=>this._doCreateTerminal(e,h,m));const v=await this._terminalCreationQueue;e.configurationProperties.isBackground&&(v.shellLaunchConfig.reconnectionProperties={ownerId:H,data:{lastTask:e.getCommonTaskId(),group:h,label:e._label,id:e._id}});const f=v.instanceId.toString(),u={terminal:v,lastTask:p,group:h};return v.onDisposed(()=>this._deleteTaskAndTerminal(v,u)),this._terminals[f]=u,[v,void 0]}_buildShellCommandLine(e,t,i,r,n,o){const a=R.parse(t).name.toLowerCase(),c=this._getQuotingOptions(a,i,e);function s(u){if(u.length>=2&&(u[0]===c.strong?c.strong:u[0]===c.weak?c.weak:void 0)===u[u.length-1])return!1;let d;for(let T=0;T<u.length;T++){const _=u[T];if(_===d)d=void 0;else{if(d!==void 0)continue;if(_===c.escape)T++;else if(_===c.strong||_===c.weak)d=_;else if(_===" ")return!0}}return!1}function m(u,d){if(d===G.Strong&&c.strong)return[c.strong+u+c.strong,!0];if(d===G.Weak&&c.weak)return[c.weak+u+c.weak,!0];if(d===G.Escape&&c.escape){if(b.isString(c.escape))return[u.replace(/ /g,c.escape+" "),!0];{const T=[];for(const C of c.escape.charsToEscape)T.push(`\\${C}`);const _=new RegExp("["+T.join(",")+"]","g"),E=c.escape.escapeChar;return[u.replace(_,C=>E+C),!0]}}return[u,!1]}function S(u){return b.isString(u)?s(u)?m(u,G.Strong):[u,!1]:m(u.value,u.quoting)}if((!o||o.length===0)&&b.isString(r)&&(r===n||s(n)))return r;const g=[];let h=!1,p=!1,l,v;[l,v]=S(r),g.push(l),h=v;for(const u of o)[l,v]=S(u),g.push(l),p=p||v;let f=g.join(" ");return e===y.Platform.Windows&&(a==="cmd"&&h&&p?f='"'+f+'"':(a==="powershell"||a==="pwsh")&&h&&(f="& "+f)),f}_getQuotingOptions(e,t,i){return t&&t.quoting?t.quoting:V._shellQuotes[e]||V._osShellQuotes[y.PlatformToString(i)]}_collectTaskVariables(e,t){if(t.command&&t.command.name&&this._collectCommandVariables(e,t.command,t),this._collectMatcherVariables(e,t.configurationProperties.problemMatchers),t.command.runtime===O.CustomExecution&&(B.is(t)||re.is(t))){let i;B.is(t)?i=t._source.config.element:(i=Z.deepClone(t.defines),delete i._key,delete i.type),this._collectDefinitionVariables(e,i)}}_collectDefinitionVariables(e,t){if(b.isString(t))this._collectVariables(e,t);else if(Array.isArray(t))t.forEach(i=>this._collectDefinitionVariables(e,i));else if(b.isObject(t))for(const i in t)this._collectDefinitionVariables(e,t[i])}_collectCommandVariables(e,t,i){if(t.runtime===O.CustomExecution)return;if(t.name===void 0)throw new Error("Command name should never be undefined here.");if(this._collectVariables(e,t.name),t.args?.forEach(n=>this._collectVariables(e,n)),i._source.scope!==Ae.Global&&e.add("${workspaceFolder}"),t.options){const n=t.options;n.cwd&&this._collectVariables(e,n.cwd);const o=n.env;o&&Object.keys(o).forEach(a=>{const c=o[a];b.isString(c)&&this._collectVariables(e,c)}),n.shell&&(n.shell.executable&&this._collectVariables(e,n.shell.executable),n.shell.args?.forEach(a=>this._collectVariables(e,a)))}}_collectMatcherVariables(e,t){t==null||t.length===0||t.forEach(i=>{let r;if(b.isString(i)?i[0]==="$"?r=Q.get(i.substring(1)):r=Q.get(i):r=i,r&&r.filePrefix)if(b.isString(r.filePrefix))this._collectVariables(e,r.filePrefix);else for(const n of[...ce(r.filePrefix.include||[]),...ce(r.filePrefix.exclude||[])])this._collectVariables(e,n)})}_collectVariables(e,t){const i=b.isString(t)?t:t.value,r=/\$\{(.*?)\}/g;let n;do n=r.exec(i),n&&e.add(n[0]);while(n)}async _resolveCommandAndArgs(e,t){let i=t.args?t.args.slice():[];return i=await this._resolveVariables(e,i),{command:await this._resolveVariable(e,t.name),args:i}}async _resolveVariables(e,t){return Promise.all(t.map(i=>this._resolveVariable(e,i)))}async _resolveMatchers(e,t){if(t==null||t.length===0)return[];const i=[];for(const r of t){let n;if(b.isString(r)?r[0]==="$"?n=Q.get(r.substring(1)):n=Q.get(r):n=r,!n){this._appendOutput(P.localize("unknownProblemMatcher","Problem matcher {0} can't be resolved. The matcher will be ignored"));continue}const o=e.taskSystemInfo,a=n.filePrefix!==void 0,c=o!==void 0&&o.uriProvider!==void 0;if(!a&&!c)i.push(n);else{const s=Z.deepClone(n);if(c&&o!==void 0&&(s.uriProvider=o.uriProvider),a){const m=s.filePrefix;b.isString(m)?s.filePrefix=await this._resolveVariable(e,m):m!==void 0&&(m.include&&(m.include=Array.isArray(m.include)?await Promise.all(m.include.map(S=>this._resolveVariable(e,S))):await this._resolveVariable(e,m.include)),m.exclude&&(m.exclude=Array.isArray(m.exclude)?await Promise.all(m.exclude.map(S=>this._resolveVariable(e,S))):await this._resolveVariable(e,m.exclude)))}i.push(s)}}return i}async _resolveVariable(e,t){if(b.isString(t))return e.resolve(t);if(t!==void 0)return{value:await e.resolve(t.value),quoting:t.quoting};throw new Error("Should never try to resolve undefined.")}async _resolveOptions(e,t){if(t==null){let r;try{r=await this._resolveVariable(e,"${workspaceFolder}")}catch{}return{cwd:r}}const i=b.isString(t.cwd)?{cwd:await this._resolveVariable(e,t.cwd)}:{cwd:await this._resolveVariable(e,"${workspaceFolder}")};if(t.env){i.env=Object.create(null);for(const r of Object.keys(t.env)){const n=t.env[r];b.isString(n)?i.env[r]=await this._resolveVariable(e,n):i.env[r]=n.toString()}}return i}static WellKnownCommands={ant:!0,cmake:!0,eslint:!0,gradle:!0,grunt:!0,gulp:!0,jake:!0,jenkins:!0,jshint:!0,make:!0,maven:!0,msbuild:!0,msc:!0,nmake:!0,npm:!0,rake:!0,tsc:!0,xbuild:!0};getSanitizedCommand(e){let t=e.toLowerCase();const i=t.lastIndexOf(R.sep);return i!==-1&&(t=t.substring(i+1)),V.WellKnownCommands[t]?t:"other"}_appendOutput(e){this._outputService.getChannel(this._outputChannelId)?.append(e)}}function ve(x,k){return(x.close===void 0||x.close===!1)&&(x.reveal!==q.Never||!k.isBackground||x.close===!1)?x.panel===D.New?Te(P.localize("closeTerminal","Press any key to close the terminal.")):x.showReuseMessage?Te(P.localize("reuseTerminal","Terminal will be reused by tasks, press any key to close it.")):!0:!x.close}function Te(x){return k=>`${W(L.CommandFinished,k.toString())}${x}`}function oe(x){return x.shellLaunchConfig.attachPersistentProcess?.reconnectionProperties?.data}export{V as TerminalTaskSystem};
