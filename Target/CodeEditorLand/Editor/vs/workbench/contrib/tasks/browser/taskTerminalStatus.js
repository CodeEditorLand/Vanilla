var k=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var I=(c,o,t,e)=>{for(var i=e>1?void 0:e?f(o,t):o,l=c.length-1,T;l>=0;l--)(T=c[l])&&(i=(e?T(o,t,i):T(i))||i);return e&&i&&k(o,t,i),i},u=(c,o)=>(t,e)=>o(t,e,c);import{Codicon as n}from"../../../../base/common/codicons.js";import{Disposable as v,MutableDisposable as h,toDisposable as g}from"../../../../base/common/lifecycle.js";import a from"../../../../base/common/severity.js";import*as r from"../../../../nls.js";import{AccessibilitySignal as d,IAccessibilitySignalService as _}from"../../../../platform/accessibilitySignal/browser/accessibilitySignalService.js";import{MarkerSeverity as m}from"../../../../platform/markers/common/markers.js";import{spinningLoading as b}from"../../../../platform/theme/common/iconRegistry.js";import{StartStopProblemCollector as y}from"../common/problemCollectors.js";import{ITaskService as E}from"../common/taskService.js";import{TaskEventKind as p,TaskRunType as A}from"../common/tasks.js";const s="task_terminal_status",M={id:s,icon:b,severity:a.Info,tooltip:r.localize("taskTerminalStatus.active","Task is running")},L={id:s,icon:n.check,severity:a.Info,tooltip:r.localize("taskTerminalStatus.succeeded","Task succeeded")},D={id:s,icon:n.check,severity:a.Info,tooltip:r.localize("taskTerminalStatus.succeededInactive","Task succeeded and waiting...")},C={id:s,icon:n.error,severity:a.Error,tooltip:r.localize("taskTerminalStatus.errors","Task has errors")},w={id:s,icon:n.error,severity:a.Error,tooltip:r.localize("taskTerminalStatus.errorsInactive","Task has errors and is waiting...")},F={id:s,icon:n.warning,severity:a.Warning,tooltip:r.localize("taskTerminalStatus.warnings","Task has warnings")},x={id:s,icon:n.warning,severity:a.Warning,tooltip:r.localize("taskTerminalStatus.warningsInactive","Task has warnings and is waiting...")},U={id:s,icon:n.info,severity:a.Info,tooltip:r.localize("taskTerminalStatus.infos","Task has infos")},K={id:s,icon:n.info,severity:a.Info,tooltip:r.localize("taskTerminalStatus.infosInactive","Task has infos and is waiting...")};let S=class extends v{constructor(t,e){super();this._accessibilitySignalService=e;this._register(t.onDidStateChange(i=>{switch(i.kind){case p.ProcessStarted:case p.Active:this.eventActive(i);break;case p.Inactive:this.eventInactive(i);break;case p.ProcessEnded:this.eventEnd(i);break}})),this._register(g(()=>{for(const i of this.terminalMap.values())i.disposeListener?.dispose();this.terminalMap.clear()}))}terminalMap=new Map;_marker;addTerminal(t,e,i){const l={id:s,severity:a.Info};e.statusList.add(l),this._register(i.onDidFindFirstMatch(()=>{this._marker=e.registerMarker(),this._marker&&this._register(this._marker)})),this._register(i.onDidFindErrors(()=>{this._marker&&e.addBufferMarker({marker:this._marker,hoverMessage:r.localize("task.watchFirstError","Beginning of detected errors for this run"),disableCommandStorage:!0})})),this._register(i.onDidRequestInvalidateLastMarker(()=>{this._marker?.dispose(),this._marker=void 0})),this.terminalMap.set(e.instanceId,{terminal:e,task:t,status:l,problemMatcher:i,taskRunEnded:!1})}terminalFromEvent(t){if(!(!("terminalId"in t)||!t.terminalId))return this.terminalMap.get(t.terminalId)}eventEnd(t){const e=this.terminalFromEvent(t);if(e)if(e.taskRunEnded=!0,e.terminal.statusList.remove(e.status),t.exitCode===0&&e.problemMatcher.numberOfMatches===0)if(this._accessibilitySignalService.playSignal(d.taskCompleted),e.task.configurationProperties.isBackground)for(const i of e.terminal.statusList.statuses)e.terminal.statusList.remove(i);else e.terminal.statusList.add(L);else t.exitCode||e.problemMatcher.maxMarkerSeverity===m.Error?(this._accessibilitySignalService.playSignal(d.taskFailed),e.terminal.statusList.add(C)):e.problemMatcher.maxMarkerSeverity===m.Warning?e.terminal.statusList.add(F):e.problemMatcher.maxMarkerSeverity===m.Info&&e.terminal.statusList.add(U)}eventInactive(t){const e=this.terminalFromEvent(t);!e||!e.problemMatcher||e.taskRunEnded||(e.terminal.statusList.remove(e.status),e.problemMatcher.numberOfMatches===0?(this._accessibilitySignalService.playSignal(d.taskCompleted),e.terminal.statusList.add(D)):e.problemMatcher.maxMarkerSeverity===m.Error?(this._accessibilitySignalService.playSignal(d.taskFailed),e.terminal.statusList.add(w)):e.problemMatcher.maxMarkerSeverity===m.Warning?e.terminal.statusList.add(x):e.problemMatcher.maxMarkerSeverity===m.Info&&e.terminal.statusList.add(K))}eventActive(t){const e=this.terminalFromEvent(t);e&&(e.disposeListener||(e.disposeListener=this._register(new h),e.disposeListener.value=e.terminal.onDisposed(()=>{t.terminalId&&(this.terminalMap.delete(t.terminalId),e.disposeListener?.dispose())})),e.taskRunEnded=!1,e.terminal.statusList.remove(e.status),(e.problemMatcher instanceof y||e.problemMatcher?.problemMatchers.length>0||t.runType===A.SingleRun)&&e.terminal.statusList.add(M))}};S=I([u(0,E),u(1,_)],S);export{M as ACTIVE_TASK_STATUS,C as FAILED_TASK_STATUS,L as SUCCEEDED_TASK_STATUS,S as TaskTerminalStatus};
