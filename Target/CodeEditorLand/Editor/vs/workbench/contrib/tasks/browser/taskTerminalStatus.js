var k=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var I=(m,o,t,e)=>{for(var i=e>1?void 0:e?f(o,t):o,l=m.length-1,u;l>=0;l--)(u=m[l])&&(i=(e?u(o,t,i):u(i))||i);return e&&i&&k(o,t,i),i},p=(m,o)=>(t,e)=>o(t,e,m);import{Codicon as n}from"../../../../../vs/base/common/codicons.js";import{Disposable as v,MutableDisposable as h,toDisposable as g}from"../../../../../vs/base/common/lifecycle.js";import a from"../../../../../vs/base/common/severity.js";import*as r from"../../../../../vs/nls.js";import{AccessibilitySignal as d,IAccessibilitySignalService as _}from"../../../../../vs/platform/accessibilitySignal/browser/accessibilitySignalService.js";import{MarkerSeverity as c}from"../../../../../vs/platform/markers/common/markers.js";import"../../../../../vs/platform/terminal/common/capabilities/capabilities.js";import{spinningLoading as b}from"../../../../../vs/platform/theme/common/iconRegistry.js";import{StartStopProblemCollector as E}from"../../../../../vs/workbench/contrib/tasks/common/problemCollectors.js";import{TaskEventKind as S,TaskRunType as A}from"../../../../../vs/workbench/contrib/tasks/common/tasks.js";import{ITaskService as M}from"../../../../../vs/workbench/contrib/tasks/common/taskService.js";import"../../../../../vs/workbench/contrib/terminal/browser/terminal.js";import"../../../../../vs/workbench/contrib/terminal/common/terminal.js";const s="task_terminal_status",y={id:s,icon:b,severity:a.Info,tooltip:r.localize("taskTerminalStatus.active","Task is running")},L={id:s,icon:n.check,severity:a.Info,tooltip:r.localize("taskTerminalStatus.succeeded","Task succeeded")},D={id:s,icon:n.check,severity:a.Info,tooltip:r.localize("taskTerminalStatus.succeededInactive","Task succeeded and waiting...")},C={id:s,icon:n.error,severity:a.Error,tooltip:r.localize("taskTerminalStatus.errors","Task has errors")},w={id:s,icon:n.error,severity:a.Error,tooltip:r.localize("taskTerminalStatus.errorsInactive","Task has errors and is waiting...")},F={id:s,icon:n.warning,severity:a.Warning,tooltip:r.localize("taskTerminalStatus.warnings","Task has warnings")},x={id:s,icon:n.warning,severity:a.Warning,tooltip:r.localize("taskTerminalStatus.warningsInactive","Task has warnings and is waiting...")},U={id:s,icon:n.info,severity:a.Info,tooltip:r.localize("taskTerminalStatus.infos","Task has infos")},K={id:s,icon:n.info,severity:a.Info,tooltip:r.localize("taskTerminalStatus.infosInactive","Task has infos and is waiting...")};let T=class extends v{constructor(t,e){super();this._accessibilitySignalService=e;this._register(t.onDidStateChange(i=>{switch(i.kind){case S.ProcessStarted:case S.Active:this.eventActive(i);break;case S.Inactive:this.eventInactive(i);break;case S.ProcessEnded:this.eventEnd(i);break}})),this._register(g(()=>{for(const i of this.terminalMap.values())i.disposeListener?.dispose();this.terminalMap.clear()}))}terminalMap=new Map;_marker;addTerminal(t,e,i){const l={id:s,severity:a.Info};e.statusList.add(l),this._register(i.onDidFindFirstMatch(()=>{this._marker=e.registerMarker(),this._marker&&this._register(this._marker)})),this._register(i.onDidFindErrors(()=>{this._marker&&e.addBufferMarker({marker:this._marker,hoverMessage:r.localize("task.watchFirstError","Beginning of detected errors for this run"),disableCommandStorage:!0})})),this._register(i.onDidRequestInvalidateLastMarker(()=>{this._marker?.dispose(),this._marker=void 0})),this.terminalMap.set(e.instanceId,{terminal:e,task:t,status:l,problemMatcher:i,taskRunEnded:!1})}terminalFromEvent(t){if(!(!("terminalId"in t)||!t.terminalId))return this.terminalMap.get(t.terminalId)}eventEnd(t){const e=this.terminalFromEvent(t);if(e)if(e.taskRunEnded=!0,e.terminal.statusList.remove(e.status),t.exitCode===0&&e.problemMatcher.numberOfMatches===0)if(this._accessibilitySignalService.playSignal(d.taskCompleted),e.task.configurationProperties.isBackground)for(const i of e.terminal.statusList.statuses)e.terminal.statusList.remove(i);else e.terminal.statusList.add(L);else t.exitCode||e.problemMatcher.maxMarkerSeverity===c.Error?(this._accessibilitySignalService.playSignal(d.taskFailed),e.terminal.statusList.add(C)):e.problemMatcher.maxMarkerSeverity===c.Warning?e.terminal.statusList.add(F):e.problemMatcher.maxMarkerSeverity===c.Info&&e.terminal.statusList.add(U)}eventInactive(t){const e=this.terminalFromEvent(t);!e||!e.problemMatcher||e.taskRunEnded||(e.terminal.statusList.remove(e.status),e.problemMatcher.numberOfMatches===0?(this._accessibilitySignalService.playSignal(d.taskCompleted),e.terminal.statusList.add(D)):e.problemMatcher.maxMarkerSeverity===c.Error?(this._accessibilitySignalService.playSignal(d.taskFailed),e.terminal.statusList.add(w)):e.problemMatcher.maxMarkerSeverity===c.Warning?e.terminal.statusList.add(x):e.problemMatcher.maxMarkerSeverity===c.Info&&e.terminal.statusList.add(K))}eventActive(t){const e=this.terminalFromEvent(t);e&&(e.disposeListener||(e.disposeListener=this._register(new h),e.disposeListener.value=e.terminal.onDisposed(()=>{t.terminalId&&(this.terminalMap.delete(t.terminalId),e.disposeListener?.dispose())})),e.taskRunEnded=!1,e.terminal.statusList.remove(e.status),(e.problemMatcher instanceof E||e.problemMatcher?.problemMatchers.length>0||t.runType===A.SingleRun)&&e.terminal.statusList.add(y))}};T=I([p(0,M),p(1,_)],T);export{y as ACTIVE_TASK_STATUS,C as FAILED_TASK_STATUS,L as SUCCEEDED_TASK_STATUS,T as TaskTerminalStatus};
