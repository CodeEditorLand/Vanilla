var w=Object.defineProperty;var A=Object.getOwnPropertyDescriptor;var g=(c,o,e,s)=>{for(var i=s>1?void 0:s?A(o,e):o,t=c.length-1,a;t>=0;t--)(a=c[t])&&(i=(s?a(o,e,i):a(i))||i);return s&&i&&w(o,e,i),i},k=(c,o)=>(e,s)=>o(e,s,c);import*as l from"../../../../nls.js";import*as y from"../../../../base/common/resources.js";import{Disposable as R}from"../../../../base/common/lifecycle.js";import"../../../common/contributions.js";import{ITaskService as b}from"../common/taskService.js";import{RunOnOptions as S,TaskRunSource as d,TaskSourceKind as P,TASKS_CATEGORY as W}from"../common/tasks.js";import{IQuickInputService as O}from"../../../../platform/quickinput/common/quickInput.js";import{Action2 as C}from"../../../../platform/actions/common/actions.js";import"../../../../platform/instantiation/common/instantiation.js";import{IWorkspaceTrustManagementService as F}from"../../../../platform/workspace/common/workspaceTrust.js";import{ConfigurationTarget as T,IConfigurationService as v}from"../../../../platform/configuration/common/configuration.js";import"../../../../base/common/uri.js";import{Event as f}from"../../../../base/common/event.js";import{ILogService as M}from"../../../../platform/log/common/log.js";const p="task.allowAutomaticTasks";let m=class extends R{constructor(e,s,i,t){super();this._taskService=e;this._configurationService=s;this._workspaceTrustManagementService=i;this._logService=t;this._taskService.isReconnected?this._tryRunTasks():this._register(f.once(this._taskService.onDidReconnectToTasks)(async()=>await this._tryRunTasks())),this._register(this._workspaceTrustManagementService.onDidChangeTrust(async()=>await this._tryRunTasks()))}_hasRunTasks=!1;async _tryRunTasks(){if(!this._workspaceTrustManagementService.isWorkspaceTrusted()||this._hasRunTasks||this._configurationService.getValue(p)==="off")return;this._hasRunTasks=!0,this._logService.trace("RunAutomaticTasks: Trying to run tasks."),this._taskService.hasTaskSystemInfo||(this._logService.trace("RunAutomaticTasks: Awaiting task system info."),await f.toPromise(f.once(this._taskService.onDidChangeTaskSystemInfo)));let e=await this._taskService.getWorkspaceTasks(d.FolderOpen);this._logService.trace(`RunAutomaticTasks: Found ${e.size} automatic tasks`);let s=this._findAutoTasks(this._taskService,e);if(this._logService.trace(`RunAutomaticTasks: taskNames=${JSON.stringify(s.taskNames)}`),s.taskNames.length===0){if(!await Promise.race([new Promise(t=>{f.toPromise(f.once(this._taskService.onDidChangeTaskConfig)).then(()=>t(!0))}),new Promise(t=>{const a=setTimeout(()=>{clearTimeout(a),t(!1)},1e4)})])){this._logService.trace("RunAutomaticTasks: waited some extra time, but no update of tasks configuration");return}e=await this._taskService.getWorkspaceTasks(d.FolderOpen),s=this._findAutoTasks(this._taskService,e),this._logService.trace(`RunAutomaticTasks: updated taskNames=${JSON.stringify(s.taskNames)}`)}this._runWithPermission(this._taskService,this._configurationService,s.tasks,s.taskNames)}_runTasks(e,s){s.forEach(i=>{i instanceof Promise?i.then(t=>{t&&e.run(t)}):e.run(i)})}_getTaskSource(e){switch(P.toConfigurationTarget(e.kind)){case T.WORKSPACE_FOLDER:return y.joinPath(e.config.workspaceFolder.uri,e.config.file);case T.WORKSPACE:return e.config.workspace?.configuration??void 0}}_findAutoTasks(e,s){const i=new Array,t=new Array,a=new Map;return s&&s.forEach(u=>{if(u.set&&u.set.tasks.forEach(r=>{if(r.runOptions.runOn===S.folderOpen){i.push(r),t.push(r._label);const n=this._getTaskSource(r._source);n&&a.set(n.fsPath,n)}}),u.configurations){for(const r of Object.values(u.configurations.byIdentifier))if(r.runOptions.runOn===S.folderOpen){i.push(new Promise(_=>{e.getTask(u.workspaceFolder,r._id,!0).then(I=>_(I))})),r._label?t.push(r._label):t.push(r.configures.task);const n=this._getTaskSource(r._source);n&&a.set(n.fsPath,n)}}}),{tasks:i,taskNames:t,locations:a}}async _runWithPermission(e,s,i,t){t.length!==0&&s.getValue(p)!=="off"&&this._runTasks(e,i)}};m=g([k(0,b),k(1,v),k(2,F),k(3,M)],m);class h extends C{static ID="workbench.action.tasks.manageAutomaticRunning";static LABEL=l.localize("workbench.action.tasks.manageAutomaticRunning","Manage Automatic Tasks");constructor(){super({id:h.ID,title:h.LABEL,category:W})}async run(o){const e=o.get(O),s=o.get(v),i={label:l.localize("workbench.action.tasks.allowAutomaticTasks","Allow Automatic Tasks")},t={label:l.localize("workbench.action.tasks.disallowAutomaticTasks","Disallow Automatic Tasks")},a=await e.pick([i,t],{canPickMany:!1});a&&s.updateValue(p,a===i?"on":"off",T.USER)}}export{h as ManageAutomaticTaskRunning,m as RunAutomaticTasks};
