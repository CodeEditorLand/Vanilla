var y=Object.defineProperty;var w=Object.getOwnPropertyDescriptor;var g=(c,o,e,s)=>{for(var t=s>1?void 0:s?w(o,e):o,i=c.length-1,a;i>=0;i--)(a=c[i])&&(t=(s?a(o,e,t):a(t))||t);return s&&t&&y(o,e,t),t},k=(c,o)=>(e,s)=>o(e,s,c);import{Event as f}from"../../../../base/common/event.js";import{Disposable as A}from"../../../../base/common/lifecycle.js";import*as b from"../../../../base/common/resources.js";import*as p from"../../../../nls.js";import{Action2 as R}from"../../../../platform/actions/common/actions.js";import{ConfigurationTarget as l,IConfigurationService as S}from"../../../../platform/configuration/common/configuration.js";import{ILogService as P}from"../../../../platform/log/common/log.js";import{IQuickInputService as W}from"../../../../platform/quickinput/common/quickInput.js";import{IWorkspaceTrustManagementService as O}from"../../../../platform/workspace/common/workspaceTrust.js";import{ITaskService as C}from"../common/taskService.js";import{RunOnOptions as d,TASKS_CATEGORY as F,TaskRunSource as v,TaskSourceKind as M}from"../common/tasks.js";const T="task.allowAutomaticTasks";let m=class extends A{constructor(e,s,t,i){super();this._taskService=e;this._configurationService=s;this._workspaceTrustManagementService=t;this._logService=i;this._taskService.isReconnected?this._tryRunTasks():this._register(f.once(this._taskService.onDidReconnectToTasks)(async()=>await this._tryRunTasks())),this._register(this._workspaceTrustManagementService.onDidChangeTrust(async()=>await this._tryRunTasks()))}_hasRunTasks=!1;async _tryRunTasks(){if(!this._workspaceTrustManagementService.isWorkspaceTrusted()||this._hasRunTasks||this._configurationService.getValue(T)==="off")return;this._hasRunTasks=!0,this._logService.trace("RunAutomaticTasks: Trying to run tasks."),this._taskService.hasTaskSystemInfo||(this._logService.trace("RunAutomaticTasks: Awaiting task system info."),await f.toPromise(f.once(this._taskService.onDidChangeTaskSystemInfo)));let e=await this._taskService.getWorkspaceTasks(v.FolderOpen);this._logService.trace(`RunAutomaticTasks: Found ${e.size} automatic tasks`);let s=this._findAutoTasks(this._taskService,e);if(this._logService.trace(`RunAutomaticTasks: taskNames=${JSON.stringify(s.taskNames)}`),s.taskNames.length===0){if(!await Promise.race([new Promise(i=>{f.toPromise(f.once(this._taskService.onDidChangeTaskConfig)).then(()=>i(!0))}),new Promise(i=>{const a=setTimeout(()=>{clearTimeout(a),i(!1)},1e4)})])){this._logService.trace("RunAutomaticTasks: waited some extra time, but no update of tasks configuration");return}e=await this._taskService.getWorkspaceTasks(v.FolderOpen),s=this._findAutoTasks(this._taskService,e),this._logService.trace(`RunAutomaticTasks: updated taskNames=${JSON.stringify(s.taskNames)}`)}this._runWithPermission(this._taskService,this._configurationService,s.tasks,s.taskNames)}_runTasks(e,s){s.forEach(t=>{t instanceof Promise?t.then(i=>{i&&e.run(i)}):e.run(t)})}_getTaskSource(e){switch(M.toConfigurationTarget(e.kind)){case l.WORKSPACE_FOLDER:return b.joinPath(e.config.workspaceFolder.uri,e.config.file);case l.WORKSPACE:return e.config.workspace?.configuration??void 0}}_findAutoTasks(e,s){const t=new Array,i=new Array,a=new Map;return s&&s.forEach(u=>{if(u.set&&u.set.tasks.forEach(r=>{if(r.runOptions.runOn===d.folderOpen){t.push(r),i.push(r._label);const n=this._getTaskSource(r._source);n&&a.set(n.fsPath,n)}}),u.configurations){for(const r of Object.values(u.configurations.byIdentifier))if(r.runOptions.runOn===d.folderOpen){t.push(new Promise(_=>{e.getTask(u.workspaceFolder,r._id,!0).then(I=>_(I))})),r._label?i.push(r._label):i.push(r.configures.task);const n=this._getTaskSource(r._source);n&&a.set(n.fsPath,n)}}}),{tasks:t,taskNames:i,locations:a}}async _runWithPermission(e,s,t,i){i.length!==0&&s.getValue(T)!=="off"&&this._runTasks(e,t)}};m=g([k(0,C),k(1,S),k(2,O),k(3,P)],m);class h extends R{static ID="workbench.action.tasks.manageAutomaticRunning";static LABEL=p.localize("workbench.action.tasks.manageAutomaticRunning","Manage Automatic Tasks");constructor(){super({id:h.ID,title:h.LABEL,category:F})}async run(o){const e=o.get(W),s=o.get(S),t={label:p.localize("workbench.action.tasks.allowAutomaticTasks","Allow Automatic Tasks")},i={label:p.localize("workbench.action.tasks.disallowAutomaticTasks","Disallow Automatic Tasks")},a=await e.pick([t,i],{canPickMany:!1});a&&s.updateValue(T,a===t?"on":"off",l.USER)}}export{h as ManageAutomaticTaskRunning,m as RunAutomaticTasks};
