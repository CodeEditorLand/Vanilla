{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/tasks/common/problemMatcher.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { localize } from \"../../../../nls.js\";\n\nimport { asArray } from \"../../../../base/common/arrays.js\";\nimport * as Assert from \"../../../../base/common/assert.js\";\nimport type { IStringDictionary } from \"../../../../base/common/collections.js\";\nimport type { IJSONSchema } from \"../../../../base/common/jsonSchema.js\";\nimport { Schemas as NetworkSchemas } from \"../../../../base/common/network.js\";\nimport * as Objects from \"../../../../base/common/objects.js\";\nimport {\n\ttype IProblemReporter,\n\tParser,\n\tValidationState,\n\tValidationStatus,\n} from \"../../../../base/common/parsers.js\";\nimport { join, normalize } from \"../../../../base/common/path.js\";\nimport * as Platform from \"../../../../base/common/platform.js\";\nimport Severity from \"../../../../base/common/severity.js\";\nimport * as Strings from \"../../../../base/common/strings.js\";\nimport * as Types from \"../../../../base/common/types.js\";\nimport { URI } from \"../../../../base/common/uri.js\";\nimport * as UUID from \"../../../../base/common/uuid.js\";\n\nimport { Emitter, type Event } from \"../../../../base/common/event.js\";\nimport {\n\tFileType,\n\ttype IFileService,\n\ttype IFileStatWithPartialMetadata,\n\ttype IFileSystemProvider,\n} from \"../../../../platform/files/common/files.js\";\nimport {\n\ttype IMarkerData,\n\tMarkerSeverity,\n} from \"../../../../platform/markers/common/markers.js\";\nimport {\n\ttype ExtensionMessageCollector,\n\tExtensionsRegistry,\n} from \"../../../services/extensions/common/extensionsRegistry.js\";\n\nexport enum FileLocationKind {\n\tDefault = 0,\n\tRelative = 1,\n\tAbsolute = 2,\n\tAutoDetect = 3,\n\tSearch = 4,\n}\n\nexport namespace FileLocationKind {\n\texport function fromString(value: string): FileLocationKind | undefined {\n\t\tvalue = value.toLowerCase();\n\t\tif (value === \"absolute\") {\n\t\t\treturn FileLocationKind.Absolute;\n\t\t} else if (value === \"relative\") {\n\t\t\treturn FileLocationKind.Relative;\n\t\t} else if (value === \"autodetect\") {\n\t\t\treturn FileLocationKind.AutoDetect;\n\t\t} else if (value === \"search\") {\n\t\t\treturn FileLocationKind.Search;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n}\n\nexport enum ProblemLocationKind {\n\tFile = 0,\n\tLocation = 1,\n}\n\nexport namespace ProblemLocationKind {\n\texport function fromString(value: string): ProblemLocationKind | undefined {\n\t\tvalue = value.toLowerCase();\n\t\tif (value === \"file\") {\n\t\t\treturn ProblemLocationKind.File;\n\t\t} else if (value === \"location\") {\n\t\t\treturn ProblemLocationKind.Location;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n}\n\nexport interface IProblemPattern {\n\tregexp: RegExp;\n\n\tkind?: ProblemLocationKind;\n\n\tfile?: number;\n\n\tmessage?: number;\n\n\tlocation?: number;\n\n\tline?: number;\n\n\tcharacter?: number;\n\n\tendLine?: number;\n\n\tendCharacter?: number;\n\n\tcode?: number;\n\n\tseverity?: number;\n\n\tloop?: boolean;\n}\n\nexport interface INamedProblemPattern extends IProblemPattern {\n\tname: string;\n}\n\nexport type MultiLineProblemPattern = IProblemPattern[];\n\nexport interface IWatchingPattern {\n\tregexp: RegExp;\n\tfile?: number;\n}\n\nexport interface IWatchingMatcher {\n\tactiveOnStart: boolean;\n\tbeginsPattern: IWatchingPattern;\n\tendsPattern: IWatchingPattern;\n}\n\nexport enum ApplyToKind {\n\tallDocuments = 0,\n\topenDocuments = 1,\n\tclosedDocuments = 2,\n}\n\nexport namespace ApplyToKind {\n\texport function fromString(value: string): ApplyToKind | undefined {\n\t\tvalue = value.toLowerCase();\n\t\tif (value === \"alldocuments\") {\n\t\t\treturn ApplyToKind.allDocuments;\n\t\t} else if (value === \"opendocuments\") {\n\t\t\treturn ApplyToKind.openDocuments;\n\t\t} else if (value === \"closeddocuments\") {\n\t\t\treturn ApplyToKind.closedDocuments;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n}\n\nexport interface ProblemMatcher {\n\towner: string;\n\tsource?: string;\n\tapplyTo: ApplyToKind;\n\tfileLocation: FileLocationKind;\n\tfilePrefix?: string | Config.SearchFileLocationArgs;\n\tpattern: IProblemPattern | IProblemPattern[];\n\tseverity?: Severity;\n\twatching?: IWatchingMatcher;\n\turiProvider?: (path: string) => URI;\n}\n\nexport interface INamedProblemMatcher extends ProblemMatcher {\n\tname: string;\n\tlabel: string;\n\tdeprecated?: boolean;\n}\n\nexport interface INamedMultiLineProblemPattern {\n\tname: string;\n\tlabel: string;\n\tpatterns: MultiLineProblemPattern;\n}\n\nexport function isNamedProblemMatcher(\n\tvalue: ProblemMatcher | undefined,\n): value is INamedProblemMatcher {\n\treturn value && Types.isString((<INamedProblemMatcher>value).name)\n\t\t? true\n\t\t: false;\n}\n\ninterface ILocation {\n\tstartLineNumber: number;\n\tstartCharacter: number;\n\tendLineNumber: number;\n\tendCharacter: number;\n}\n\ninterface IProblemData {\n\tkind?: ProblemLocationKind;\n\tfile?: string;\n\tlocation?: string;\n\tline?: string;\n\tcharacter?: string;\n\tendLine?: string;\n\tendCharacter?: string;\n\tmessage?: string;\n\tseverity?: string;\n\tcode?: string;\n}\n\nexport interface IProblemMatch {\n\tresource: Promise<URI>;\n\tmarker: IMarkerData;\n\tdescription: ProblemMatcher;\n}\n\nexport interface IHandleResult {\n\tmatch: IProblemMatch | null;\n\tcontinue: boolean;\n}\n\nexport async function getResource(\n\tfilename: string,\n\tmatcher: ProblemMatcher,\n\tfileService?: IFileService,\n): Promise<URI> {\n\tconst kind = matcher.fileLocation;\n\tlet fullPath: string | undefined;\n\tif (kind === FileLocationKind.Absolute) {\n\t\tfullPath = filename;\n\t} else if (\n\t\tkind === FileLocationKind.Relative &&\n\t\tmatcher.filePrefix &&\n\t\tTypes.isString(matcher.filePrefix)\n\t) {\n\t\tfullPath = join(matcher.filePrefix, filename);\n\t} else if (kind === FileLocationKind.AutoDetect) {\n\t\tconst matcherClone = Objects.deepClone(matcher);\n\t\tmatcherClone.fileLocation = FileLocationKind.Relative;\n\t\tif (fileService) {\n\t\t\tconst relative = await getResource(filename, matcherClone);\n\t\t\tlet stat: IFileStatWithPartialMetadata | undefined;\n\t\t\ttry {\n\t\t\t\tstat = await fileService.stat(relative);\n\t\t\t} catch (ex) {\n\t\t\t\t// Do nothing, we just need to catch file resolution errors.\n\t\t\t}\n\t\t\tif (stat) {\n\t\t\t\treturn relative;\n\t\t\t}\n\t\t}\n\n\t\tmatcherClone.fileLocation = FileLocationKind.Absolute;\n\t\treturn getResource(filename, matcherClone);\n\t} else if (kind === FileLocationKind.Search && fileService) {\n\t\tconst fsProvider = fileService.getProvider(NetworkSchemas.file);\n\t\tif (fsProvider) {\n\t\t\tconst uri = await searchForFileLocation(\n\t\t\t\tfilename,\n\t\t\t\tfsProvider,\n\t\t\t\tmatcher.filePrefix as Config.SearchFileLocationArgs,\n\t\t\t);\n\t\t\tfullPath = uri?.path;\n\t\t}\n\n\t\tif (!fullPath) {\n\t\t\tconst absoluteMatcher = Objects.deepClone(matcher);\n\t\t\tabsoluteMatcher.fileLocation = FileLocationKind.Absolute;\n\t\t\treturn getResource(filename, absoluteMatcher);\n\t\t}\n\t}\n\tif (fullPath === undefined) {\n\t\tthrow new Error(\n\t\t\t\"FileLocationKind is not actionable. Does the matcher have a filePrefix? This should never happen.\",\n\t\t);\n\t}\n\tfullPath = normalize(fullPath);\n\tfullPath = fullPath.replace(/\\\\/g, \"/\");\n\tif (fullPath[0] !== \"/\") {\n\t\tfullPath = \"/\" + fullPath;\n\t}\n\tif (matcher.uriProvider !== undefined) {\n\t\treturn matcher.uriProvider(fullPath);\n\t} else {\n\t\treturn URI.file(fullPath);\n\t}\n}\n\nasync function searchForFileLocation(\n\tfilename: string,\n\tfsProvider: IFileSystemProvider,\n\targs: Config.SearchFileLocationArgs,\n): Promise<URI | undefined> {\n\tconst exclusions = new Set(\n\t\tasArray(args.exclude || []).map((x) => URI.file(x).path),\n\t);\n\tasync function search(dir: URI): Promise<URI | undefined> {\n\t\tif (exclusions.has(dir.path)) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst entries = await fsProvider.readdir(dir);\n\t\tconst subdirs: URI[] = [];\n\n\t\tfor (const [name, fileType] of entries) {\n\t\t\tif (fileType === FileType.Directory) {\n\t\t\t\tsubdirs.push(URI.joinPath(dir, name));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (fileType === FileType.File) {\n\t\t\t\t/**\n\t\t\t\t * Note that sometimes the given `filename` could be a relative\n\t\t\t\t * path (not just the \"name.ext\" part). For example, the\n\t\t\t\t * `filename` can be \"/subdir/name.ext\". So, just comparing\n\t\t\t\t * `name` as `filename` is not sufficient. The workaround here\n\t\t\t\t * is to form the URI with `dir` and `name` and check if it ends\n\t\t\t\t * with the given `filename`.\n\t\t\t\t */\n\t\t\t\tconst fullUri = URI.joinPath(dir, name);\n\t\t\t\tif (fullUri.path.endsWith(filename)) {\n\t\t\t\t\treturn fullUri;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const subdir of subdirs) {\n\t\t\tconst result = await search(subdir);\n\t\t\tif (result) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tfor (const dir of asArray(args.include || [])) {\n\t\tconst hit = await search(URI.file(dir));\n\t\tif (hit) {\n\t\t\treturn hit;\n\t\t}\n\t}\n\treturn undefined;\n}\n\nexport interface ILineMatcher {\n\tmatchLength: number;\n\tnext(line: string): IProblemMatch | null;\n\thandle(lines: string[], start?: number): IHandleResult;\n}\n\nexport function createLineMatcher(\n\tmatcher: ProblemMatcher,\n\tfileService?: IFileService,\n): ILineMatcher {\n\tconst pattern = matcher.pattern;\n\tif (Array.isArray(pattern)) {\n\t\treturn new MultiLineMatcher(matcher, fileService);\n\t} else {\n\t\treturn new SingleLineMatcher(matcher, fileService);\n\t}\n}\n\nconst endOfLine: string =\n\tPlatform.OS === Platform.OperatingSystem.Windows ? \"\\r\\n\" : \"\\n\";\n\nabstract class AbstractLineMatcher implements ILineMatcher {\n\tprivate matcher: ProblemMatcher;\n\tprivate fileService?: IFileService;\n\n\tconstructor(matcher: ProblemMatcher, fileService?: IFileService) {\n\t\tthis.matcher = matcher;\n\t\tthis.fileService = fileService;\n\t}\n\n\tpublic handle(lines: string[], start = 0): IHandleResult {\n\t\treturn { match: null, continue: false };\n\t}\n\n\tpublic next(line: string): IProblemMatch | null {\n\t\treturn null;\n\t}\n\n\tpublic abstract get matchLength(): number;\n\n\tprotected fillProblemData(\n\t\tdata: IProblemData | undefined,\n\t\tpattern: IProblemPattern,\n\t\tmatches: RegExpExecArray,\n\t): data is IProblemData {\n\t\tif (data) {\n\t\t\tthis.fillProperty(data, \"file\", pattern, matches, true);\n\t\t\tthis.appendProperty(data, \"message\", pattern, matches, true);\n\t\t\tthis.fillProperty(data, \"code\", pattern, matches, true);\n\t\t\tthis.fillProperty(data, \"severity\", pattern, matches, true);\n\t\t\tthis.fillProperty(data, \"location\", pattern, matches, true);\n\t\t\tthis.fillProperty(data, \"line\", pattern, matches);\n\t\t\tthis.fillProperty(data, \"character\", pattern, matches);\n\t\t\tthis.fillProperty(data, \"endLine\", pattern, matches);\n\t\t\tthis.fillProperty(data, \"endCharacter\", pattern, matches);\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate appendProperty(\n\t\tdata: IProblemData,\n\t\tproperty: keyof IProblemData,\n\t\tpattern: IProblemPattern,\n\t\tmatches: RegExpExecArray,\n\t\ttrim = false,\n\t): void {\n\t\tconst patternProperty = pattern[property];\n\t\tif (Types.isUndefined(data[property])) {\n\t\t\tthis.fillProperty(data, property, pattern, matches, trim);\n\t\t} else if (\n\t\t\t!Types.isUndefined(patternProperty) &&\n\t\t\tpatternProperty < matches.length\n\t\t) {\n\t\t\tlet value = matches[patternProperty];\n\t\t\tif (trim) {\n\t\t\t\tvalue = Strings.trim(value)!;\n\t\t\t}\n\t\t\t(data as any)[property] += endOfLine + value;\n\t\t}\n\t}\n\n\tprivate fillProperty(\n\t\tdata: IProblemData,\n\t\tproperty: keyof IProblemData,\n\t\tpattern: IProblemPattern,\n\t\tmatches: RegExpExecArray,\n\t\ttrim = false,\n\t): void {\n\t\tconst patternAtProperty = pattern[property];\n\t\tif (\n\t\t\tTypes.isUndefined(data[property]) &&\n\t\t\t!Types.isUndefined(patternAtProperty) &&\n\t\t\tpatternAtProperty < matches.length\n\t\t) {\n\t\t\tlet value = matches[patternAtProperty];\n\t\t\tif (value !== undefined) {\n\t\t\t\tif (trim) {\n\t\t\t\t\tvalue = Strings.trim(value)!;\n\t\t\t\t}\n\t\t\t\t(data as any)[property] = value;\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected getMarkerMatch(data: IProblemData): IProblemMatch | undefined {\n\t\ttry {\n\t\t\tconst location = this.getLocation(data);\n\t\t\tif (data.file && location && data.message) {\n\t\t\t\tconst marker: IMarkerData = {\n\t\t\t\t\tseverity: this.getSeverity(data),\n\t\t\t\t\tstartLineNumber: location.startLineNumber,\n\t\t\t\t\tstartColumn: location.startCharacter,\n\t\t\t\t\tendLineNumber: location.endLineNumber,\n\t\t\t\t\tendColumn: location.endCharacter,\n\t\t\t\t\tmessage: data.message,\n\t\t\t\t};\n\t\t\t\tif (data.code !== undefined) {\n\t\t\t\t\tmarker.code = data.code;\n\t\t\t\t}\n\t\t\t\tif (this.matcher.source !== undefined) {\n\t\t\t\t\tmarker.source = this.matcher.source;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tdescription: this.matcher,\n\t\t\t\t\tresource: this.getResource(data.file),\n\t\t\t\t\tmarker: marker,\n\t\t\t\t};\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tconsole.error(\n\t\t\t\t`Failed to convert problem data into match: ${JSON.stringify(data)}`,\n\t\t\t);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tprotected getResource(filename: string): Promise<URI> {\n\t\treturn getResource(filename, this.matcher, this.fileService);\n\t}\n\n\tprivate getLocation(data: IProblemData): ILocation | null {\n\t\tif (data.kind === ProblemLocationKind.File) {\n\t\t\treturn this.createLocation(0, 0, 0, 0);\n\t\t}\n\t\tif (data.location) {\n\t\t\treturn this.parseLocationInfo(data.location);\n\t\t}\n\t\tif (!data.line) {\n\t\t\treturn null;\n\t\t}\n\t\tconst startLine = Number.parseInt(data.line);\n\t\tconst startColumn = data.character\n\t\t\t? Number.parseInt(data.character)\n\t\t\t: undefined;\n\t\tconst endLine = data.endLine\n\t\t\t? Number.parseInt(data.endLine)\n\t\t\t: undefined;\n\t\tconst endColumn = data.endCharacter\n\t\t\t? Number.parseInt(data.endCharacter)\n\t\t\t: undefined;\n\t\treturn this.createLocation(startLine, startColumn, endLine, endColumn);\n\t}\n\n\tprivate parseLocationInfo(value: string): ILocation | null {\n\t\tif (!value || !value.match(/(\\d+|\\d+,\\d+|\\d+,\\d+,\\d+,\\d+)/)) {\n\t\t\treturn null;\n\t\t}\n\t\tconst parts = value.split(\",\");\n\t\tconst startLine = Number.parseInt(parts[0]);\n\t\tconst startColumn =\n\t\t\tparts.length > 1 ? Number.parseInt(parts[1]) : undefined;\n\t\tif (parts.length > 3) {\n\t\t\treturn this.createLocation(\n\t\t\t\tstartLine,\n\t\t\t\tstartColumn,\n\t\t\t\tNumber.parseInt(parts[2]),\n\t\t\t\tNumber.parseInt(parts[3]),\n\t\t\t);\n\t\t} else {\n\t\t\treturn this.createLocation(\n\t\t\t\tstartLine,\n\t\t\t\tstartColumn,\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate createLocation(\n\t\tstartLine: number,\n\t\tstartColumn: number | undefined,\n\t\tendLine: number | undefined,\n\t\tendColumn: number | undefined,\n\t): ILocation {\n\t\tif (startColumn !== undefined && endColumn !== undefined) {\n\t\t\treturn {\n\t\t\t\tstartLineNumber: startLine,\n\t\t\t\tstartCharacter: startColumn,\n\t\t\t\tendLineNumber: endLine || startLine,\n\t\t\t\tendCharacter: endColumn,\n\t\t\t};\n\t\t}\n\t\tif (startColumn !== undefined) {\n\t\t\treturn {\n\t\t\t\tstartLineNumber: startLine,\n\t\t\t\tstartCharacter: startColumn,\n\t\t\t\tendLineNumber: startLine,\n\t\t\t\tendCharacter: startColumn,\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tstartLineNumber: startLine,\n\t\t\tstartCharacter: 1,\n\t\t\tendLineNumber: startLine,\n\t\t\tendCharacter: 2 ** 31 - 1,\n\t\t}; // See https://github.com/microsoft/vscode/issues/80288#issuecomment-650636442 for discussion\n\t}\n\n\tprivate getSeverity(data: IProblemData): MarkerSeverity {\n\t\tlet result: Severity | null = null;\n\t\tif (data.severity) {\n\t\t\tconst value = data.severity;\n\t\t\tif (value) {\n\t\t\t\tresult = Severity.fromValue(value);\n\t\t\t\tif (result === Severity.Ignore) {\n\t\t\t\t\tif (value === \"E\") {\n\t\t\t\t\t\tresult = Severity.Error;\n\t\t\t\t\t} else if (value === \"W\") {\n\t\t\t\t\t\tresult = Severity.Warning;\n\t\t\t\t\t} else if (value === \"I\") {\n\t\t\t\t\t\tresult = Severity.Info;\n\t\t\t\t\t} else if (Strings.equalsIgnoreCase(value, \"hint\")) {\n\t\t\t\t\t\tresult = Severity.Info;\n\t\t\t\t\t} else if (Strings.equalsIgnoreCase(value, \"note\")) {\n\t\t\t\t\t\tresult = Severity.Info;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (result === null || result === Severity.Ignore) {\n\t\t\tresult = this.matcher.severity || Severity.Error;\n\t\t}\n\t\treturn MarkerSeverity.fromSeverity(result);\n\t}\n}\n\nclass SingleLineMatcher extends AbstractLineMatcher {\n\tprivate pattern: IProblemPattern;\n\n\tconstructor(matcher: ProblemMatcher, fileService?: IFileService) {\n\t\tsuper(matcher, fileService);\n\t\tthis.pattern = <IProblemPattern>matcher.pattern;\n\t}\n\n\tpublic get matchLength(): number {\n\t\treturn 1;\n\t}\n\n\tpublic override handle(lines: string[], start = 0): IHandleResult {\n\t\tAssert.ok(lines.length - start === 1);\n\t\tconst data: IProblemData = Object.create(null);\n\t\tif (this.pattern.kind !== undefined) {\n\t\t\tdata.kind = this.pattern.kind;\n\t\t}\n\t\tconst matches = this.pattern.regexp.exec(lines[start]);\n\t\tif (matches) {\n\t\t\tthis.fillProblemData(data, this.pattern, matches);\n\t\t\tconst match = this.getMarkerMatch(data);\n\t\t\tif (match) {\n\t\t\t\treturn { match: match, continue: false };\n\t\t\t}\n\t\t}\n\t\treturn { match: null, continue: false };\n\t}\n\n\tpublic override next(line: string): IProblemMatch | null {\n\t\treturn null;\n\t}\n}\n\nclass MultiLineMatcher extends AbstractLineMatcher {\n\tprivate patterns: IProblemPattern[];\n\tprivate data: IProblemData | undefined;\n\n\tconstructor(matcher: ProblemMatcher, fileService?: IFileService) {\n\t\tsuper(matcher, fileService);\n\t\tthis.patterns = <IProblemPattern[]>matcher.pattern;\n\t}\n\n\tpublic get matchLength(): number {\n\t\treturn this.patterns.length;\n\t}\n\n\tpublic override handle(lines: string[], start = 0): IHandleResult {\n\t\tAssert.ok(lines.length - start === this.patterns.length);\n\t\tthis.data = Object.create(null);\n\t\tlet data = this.data!;\n\t\tdata.kind = this.patterns[0].kind;\n\t\tfor (let i = 0; i < this.patterns.length; i++) {\n\t\t\tconst pattern = this.patterns[i];\n\t\t\tconst matches = pattern.regexp.exec(lines[i + start]);\n\t\t\tif (matches) {\n\t\t\t\t// Only the last pattern can loop\n\t\t\t\tif (pattern.loop && i === this.patterns.length - 1) {\n\t\t\t\t\tdata = Objects.deepClone(data);\n\t\t\t\t}\n\t\t\t\tthis.fillProblemData(data, pattern, matches);\n\t\t\t} else {\n\t\t\t\treturn { match: null, continue: false };\n\t\t\t}\n\t\t}\n\t\tconst loop = !!this.patterns[this.patterns.length - 1].loop;\n\t\tif (!loop) {\n\t\t\tthis.data = undefined;\n\t\t}\n\t\tconst markerMatch = data ? this.getMarkerMatch(data) : null;\n\t\treturn { match: markerMatch ? markerMatch : null, continue: loop };\n\t}\n\n\tpublic override next(line: string): IProblemMatch | null {\n\t\tconst pattern = this.patterns[this.patterns.length - 1];\n\t\tAssert.ok(pattern.loop === true && this.data !== null);\n\t\tconst matches = pattern.regexp.exec(line);\n\t\tif (!matches) {\n\t\t\tthis.data = undefined;\n\t\t\treturn null;\n\t\t}\n\t\tconst data = Objects.deepClone(this.data);\n\t\tlet problemMatch: IProblemMatch | undefined;\n\t\tif (this.fillProblemData(data, pattern, matches)) {\n\t\t\tproblemMatch = this.getMarkerMatch(data);\n\t\t}\n\t\treturn problemMatch ? problemMatch : null;\n\t}\n}\n\nexport namespace Config {\n\texport interface IProblemPattern {\n\t\t/**\n\t\t * The regular expression to find a problem in the console output of an\n\t\t * executed task.\n\t\t */\n\t\tregexp?: string;\n\n\t\t/**\n\t\t * Whether the pattern matches a whole file, or a location (file/line)\n\t\t *\n\t\t * The default is to match for a location. Only valid on the\n\t\t * first problem pattern in a multi line problem matcher.\n\t\t */\n\t\tkind?: string;\n\n\t\t/**\n\t\t * The match group index of the filename.\n\t\t * If omitted 1 is used.\n\t\t */\n\t\tfile?: number;\n\n\t\t/**\n\t\t * The match group index of the problem's location. Valid location\n\t\t * patterns are: (line), (line,column) and (startLine,startColumn,endLine,endColumn).\n\t\t * If omitted the line and column properties are used.\n\t\t */\n\t\tlocation?: number;\n\n\t\t/**\n\t\t * The match group index of the problem's line in the source file.\n\t\t *\n\t\t * Defaults to 2.\n\t\t */\n\t\tline?: number;\n\n\t\t/**\n\t\t * The match group index of the problem's column in the source file.\n\t\t *\n\t\t * Defaults to 3.\n\t\t */\n\t\tcolumn?: number;\n\n\t\t/**\n\t\t * The match group index of the problem's end line in the source file.\n\t\t *\n\t\t * Defaults to undefined. No end line is captured.\n\t\t */\n\t\tendLine?: number;\n\n\t\t/**\n\t\t * The match group index of the problem's end column in the source file.\n\t\t *\n\t\t * Defaults to undefined. No end column is captured.\n\t\t */\n\t\tendColumn?: number;\n\n\t\t/**\n\t\t * The match group index of the problem's severity.\n\t\t *\n\t\t * Defaults to undefined. In this case the problem matcher's severity\n\t\t * is used.\n\t\t */\n\t\tseverity?: number;\n\n\t\t/**\n\t\t * The match group index of the problem's code.\n\t\t *\n\t\t * Defaults to undefined. No code is captured.\n\t\t */\n\t\tcode?: number;\n\n\t\t/**\n\t\t * The match group index of the message. If omitted it defaults\n\t\t * to 4 if location is specified. Otherwise it defaults to 5.\n\t\t */\n\t\tmessage?: number;\n\n\t\t/**\n\t\t * Specifies if the last pattern in a multi line problem matcher should\n\t\t * loop as long as it does match a line consequently. Only valid on the\n\t\t * last problem pattern in a multi line problem matcher.\n\t\t */\n\t\tloop?: boolean;\n\t}\n\n\texport interface ICheckedProblemPattern extends IProblemPattern {\n\t\t/**\n\t\t * The regular expression to find a problem in the console output of an\n\t\t * executed task.\n\t\t */\n\t\tregexp: string;\n\t}\n\n\texport namespace CheckedProblemPattern {\n\t\texport function is(value: any): value is ICheckedProblemPattern {\n\t\t\tconst candidate: IProblemPattern = value as IProblemPattern;\n\t\t\treturn candidate && Types.isString(candidate.regexp);\n\t\t}\n\t}\n\n\texport interface INamedProblemPattern extends IProblemPattern {\n\t\t/**\n\t\t * The name of the problem pattern.\n\t\t */\n\t\tname: string;\n\n\t\t/**\n\t\t * A human readable label\n\t\t */\n\t\tlabel?: string;\n\t}\n\n\texport namespace NamedProblemPattern {\n\t\texport function is(value: any): value is INamedProblemPattern {\n\t\t\tconst candidate: INamedProblemPattern =\n\t\t\t\tvalue as INamedProblemPattern;\n\t\t\treturn candidate && Types.isString(candidate.name);\n\t\t}\n\t}\n\n\texport interface INamedCheckedProblemPattern extends INamedProblemPattern {\n\t\t/**\n\t\t * The regular expression to find a problem in the console output of an\n\t\t * executed task.\n\t\t */\n\t\tregexp: string;\n\t}\n\n\texport namespace NamedCheckedProblemPattern {\n\t\texport function is(value: any): value is INamedCheckedProblemPattern {\n\t\t\tconst candidate: INamedProblemPattern =\n\t\t\t\tvalue as INamedProblemPattern;\n\t\t\treturn (\n\t\t\t\tcandidate &&\n\t\t\t\tNamedProblemPattern.is(candidate) &&\n\t\t\t\tTypes.isString(candidate.regexp)\n\t\t\t);\n\t\t}\n\t}\n\n\texport type MultiLineProblemPattern = IProblemPattern[];\n\n\texport namespace MultiLineProblemPattern {\n\t\texport function is(value: any): value is MultiLineProblemPattern {\n\t\t\treturn value && Array.isArray(value);\n\t\t}\n\t}\n\n\texport type MultiLineCheckedProblemPattern = ICheckedProblemPattern[];\n\n\texport namespace MultiLineCheckedProblemPattern {\n\t\texport function is(\n\t\t\tvalue: any,\n\t\t): value is MultiLineCheckedProblemPattern {\n\t\t\tif (!MultiLineProblemPattern.is(value)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (const element of value) {\n\t\t\t\tif (!Config.CheckedProblemPattern.is(element)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\texport interface INamedMultiLineCheckedProblemPattern {\n\t\t/**\n\t\t * The name of the problem pattern.\n\t\t */\n\t\tname: string;\n\n\t\t/**\n\t\t * A human readable label\n\t\t */\n\t\tlabel?: string;\n\n\t\t/**\n\t\t * The actual patterns\n\t\t */\n\t\tpatterns: MultiLineCheckedProblemPattern;\n\t}\n\n\texport namespace NamedMultiLineCheckedProblemPattern {\n\t\texport function is(\n\t\t\tvalue: any,\n\t\t): value is INamedMultiLineCheckedProblemPattern {\n\t\t\tconst candidate = value as INamedMultiLineCheckedProblemPattern;\n\t\t\treturn (\n\t\t\t\tcandidate &&\n\t\t\t\tTypes.isString(candidate.name) &&\n\t\t\t\tArray.isArray(candidate.patterns) &&\n\t\t\t\tMultiLineCheckedProblemPattern.is(candidate.patterns)\n\t\t\t);\n\t\t}\n\t}\n\n\texport type NamedProblemPatterns = (\n\t\t| Config.INamedProblemPattern\n\t\t| Config.INamedMultiLineCheckedProblemPattern\n\t)[];\n\n\t/**\n\t * A watching pattern\n\t */\n\texport interface IWatchingPattern {\n\t\t/**\n\t\t * The actual regular expression\n\t\t */\n\t\tregexp?: string;\n\n\t\t/**\n\t\t * The match group index of the filename. If provided the expression\n\t\t * is matched for that file only.\n\t\t */\n\t\tfile?: number;\n\t}\n\n\t/**\n\t * A description to track the start and end of a watching task.\n\t */\n\texport interface IBackgroundMonitor {\n\t\t/**\n\t\t * If set to true the watcher is in active mode when the task\n\t\t * starts. This is equals of issuing a line that matches the\n\t\t * beginsPattern.\n\t\t */\n\t\tactiveOnStart?: boolean;\n\n\t\t/**\n\t\t * If matched in the output the start of a watching task is signaled.\n\t\t */\n\t\tbeginsPattern?: string | IWatchingPattern;\n\n\t\t/**\n\t\t * If matched in the output the end of a watching task is signaled.\n\t\t */\n\t\tendsPattern?: string | IWatchingPattern;\n\t}\n\n\t/**\n\t * A description of a problem matcher that detects problems\n\t * in build output.\n\t */\n\texport interface ProblemMatcher {\n\t\t/**\n\t\t * The name of a base problem matcher to use. If specified the\n\t\t * base problem matcher will be used as a template and properties\n\t\t * specified here will replace properties of the base problem\n\t\t * matcher\n\t\t */\n\t\tbase?: string;\n\n\t\t/**\n\t\t * The owner of the produced VSCode problem. This is typically\n\t\t * the identifier of a VSCode language service if the problems are\n\t\t * to be merged with the one produced by the language service\n\t\t * or a generated internal id. Defaults to the generated internal id.\n\t\t */\n\t\towner?: string;\n\n\t\t/**\n\t\t * A human-readable string describing the source of this problem.\n\t\t * E.g. 'typescript' or 'super lint'.\n\t\t */\n\t\tsource?: string;\n\n\t\t/**\n\t\t * Specifies to which kind of documents the problems found by this\n\t\t * matcher are applied. Valid values are:\n\t\t *\n\t\t *   \"allDocuments\": problems found in all documents are applied.\n\t\t *   \"openDocuments\": problems found in documents that are open\n\t\t *   are applied.\n\t\t *   \"closedDocuments\": problems found in closed documents are\n\t\t *   applied.\n\t\t */\n\t\tapplyTo?: string;\n\n\t\t/**\n\t\t * The severity of the VSCode problem produced by this problem matcher.\n\t\t *\n\t\t * Valid values are:\n\t\t *   \"error\": to produce errors.\n\t\t *   \"warning\": to produce warnings.\n\t\t *   \"info\": to produce infos.\n\t\t *\n\t\t * The value is used if a pattern doesn't specify a severity match group.\n\t\t * Defaults to \"error\" if omitted.\n\t\t */\n\t\tseverity?: string;\n\n\t\t/**\n\t\t * Defines how filename reported in a problem pattern\n\t\t * should be read. Valid values are:\n\t\t *  - \"absolute\": the filename is always treated absolute.\n\t\t *  - \"relative\": the filename is always treated relative to\n\t\t *    the current working directory. This is the default.\n\t\t *  - [\"relative\", \"path value\"]: the filename is always\n\t\t *    treated relative to the given path value.\n\t\t *  - \"autodetect\": the filename is treated relative to\n\t\t *    the current workspace directory, and if the file\n\t\t *    does not exist, it is treated as absolute.\n\t\t *  - [\"autodetect\", \"path value\"]: the filename is treated\n\t\t *    relative to the given path value, and if it does not\n\t\t *    exist, it is treated as absolute.\n\t\t *  - [\"search\", { include?: \"\" | []; exclude?: \"\" | [] }]: The filename\n\t\t *    needs to be searched under the directories named by the \"include\"\n\t\t *    property and their nested subdirectories. With \"exclude\" property\n\t\t *    present, the directories should be removed from the search. When\n\t\t *    `include` is not unprovided, the current workspace directory should\n\t\t *    be used as the default.\n\t\t */\n\t\tfileLocation?: string | string[] | [\"search\", SearchFileLocationArgs];\n\n\t\t/**\n\t\t * The name of a predefined problem pattern, the inline definition\n\t\t * of a problem pattern or an array of problem patterns to match\n\t\t * problems spread over multiple lines.\n\t\t */\n\t\tpattern?: string | IProblemPattern | IProblemPattern[];\n\n\t\t/**\n\t\t * A regular expression signaling that a watched tasks begins executing\n\t\t * triggered through file watching.\n\t\t */\n\t\twatchedTaskBeginsRegExp?: string;\n\n\t\t/**\n\t\t * A regular expression signaling that a watched tasks ends executing.\n\t\t */\n\t\twatchedTaskEndsRegExp?: string;\n\n\t\t/**\n\t\t * @deprecated Use background instead.\n\t\t */\n\t\twatching?: IBackgroundMonitor;\n\t\tbackground?: IBackgroundMonitor;\n\t}\n\n\texport type SearchFileLocationArgs = {\n\t\tinclude?: string | string[];\n\t\texclude?: string | string[];\n\t};\n\n\texport type ProblemMatcherType =\n\t\t| string\n\t\t| ProblemMatcher\n\t\t| Array<string | ProblemMatcher>;\n\n\texport interface INamedProblemMatcher extends ProblemMatcher {\n\t\t/**\n\t\t * This name can be used to refer to the\n\t\t * problem matcher from within a task.\n\t\t */\n\t\tname: string;\n\n\t\t/**\n\t\t * A human readable label.\n\t\t */\n\t\tlabel?: string;\n\t}\n\n\texport function isNamedProblemMatcher(\n\t\tvalue: ProblemMatcher,\n\t): value is INamedProblemMatcher {\n\t\treturn Types.isString((<INamedProblemMatcher>value).name);\n\t}\n}\n\nexport class ProblemPatternParser extends Parser {\n\tconstructor(logger: IProblemReporter) {\n\t\tsuper(logger);\n\t}\n\n\tpublic parse(value: Config.IProblemPattern): IProblemPattern;\n\tpublic parse(\n\t\tvalue: Config.MultiLineProblemPattern,\n\t): MultiLineProblemPattern;\n\tpublic parse(value: Config.INamedProblemPattern): INamedProblemPattern;\n\tpublic parse(\n\t\tvalue: Config.INamedMultiLineCheckedProblemPattern,\n\t): INamedMultiLineProblemPattern;\n\tpublic parse(\n\t\tvalue:\n\t\t\t| Config.IProblemPattern\n\t\t\t| Config.MultiLineProblemPattern\n\t\t\t| Config.INamedProblemPattern\n\t\t\t| Config.INamedMultiLineCheckedProblemPattern,\n\t): any {\n\t\tif (Config.NamedMultiLineCheckedProblemPattern.is(value)) {\n\t\t\treturn this.createNamedMultiLineProblemPattern(value);\n\t\t} else if (Config.MultiLineCheckedProblemPattern.is(value)) {\n\t\t\treturn this.createMultiLineProblemPattern(value);\n\t\t} else if (Config.NamedCheckedProblemPattern.is(value)) {\n\t\t\tconst result = this.createSingleProblemPattern(\n\t\t\t\tvalue,\n\t\t\t) as INamedProblemPattern;\n\t\t\tresult.name = value.name;\n\t\t\treturn result;\n\t\t} else if (Config.CheckedProblemPattern.is(value)) {\n\t\t\treturn this.createSingleProblemPattern(value);\n\t\t} else {\n\t\t\tthis.error(\n\t\t\t\tlocalize(\n\t\t\t\t\t\"ProblemPatternParser.problemPattern.missingRegExp\",\n\t\t\t\t\t\"The problem pattern is missing a regular expression.\",\n\t\t\t\t),\n\t\t\t);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate createSingleProblemPattern(\n\t\tvalue: Config.ICheckedProblemPattern,\n\t): IProblemPattern | null {\n\t\tconst result = this.doCreateSingleProblemPattern(value, true);\n\t\tif (result === undefined) {\n\t\t\treturn null;\n\t\t} else if (result.kind === undefined) {\n\t\t\tresult.kind = ProblemLocationKind.Location;\n\t\t}\n\t\treturn this.validateProblemPattern([result]) ? result : null;\n\t}\n\n\tprivate createNamedMultiLineProblemPattern(\n\t\tvalue: Config.INamedMultiLineCheckedProblemPattern,\n\t): INamedMultiLineProblemPattern | null {\n\t\tconst validPatterns = this.createMultiLineProblemPattern(\n\t\t\tvalue.patterns,\n\t\t);\n\t\tif (!validPatterns) {\n\t\t\treturn null;\n\t\t}\n\t\tconst result = {\n\t\t\tname: value.name,\n\t\t\tlabel: value.label ? value.label : value.name,\n\t\t\tpatterns: validPatterns,\n\t\t};\n\t\treturn result;\n\t}\n\n\tprivate createMultiLineProblemPattern(\n\t\tvalues: Config.MultiLineCheckedProblemPattern,\n\t): MultiLineProblemPattern | null {\n\t\tconst result: MultiLineProblemPattern = [];\n\t\tfor (let i = 0; i < values.length; i++) {\n\t\t\tconst pattern = this.doCreateSingleProblemPattern(values[i], false);\n\t\t\tif (pattern === undefined) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (i < values.length - 1) {\n\t\t\t\tif (!Types.isUndefined(pattern.loop) && pattern.loop) {\n\t\t\t\t\tpattern.loop = false;\n\t\t\t\t\tthis.error(\n\t\t\t\t\t\tlocalize(\n\t\t\t\t\t\t\t\"ProblemPatternParser.loopProperty.notLast\",\n\t\t\t\t\t\t\t\"The loop property is only supported on the last line matcher.\",\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult.push(pattern);\n\t\t}\n\t\tif (result[0].kind === undefined) {\n\t\t\tresult[0].kind = ProblemLocationKind.Location;\n\t\t}\n\t\treturn this.validateProblemPattern(result) ? result : null;\n\t}\n\n\tprivate doCreateSingleProblemPattern(\n\t\tvalue: Config.ICheckedProblemPattern,\n\t\tsetDefaults: boolean,\n\t): IProblemPattern | undefined {\n\t\tconst regexp = this.createRegularExpression(value.regexp);\n\t\tif (regexp === undefined) {\n\t\t\treturn undefined;\n\t\t}\n\t\tlet result: IProblemPattern = { regexp };\n\t\tif (value.kind) {\n\t\t\tresult.kind = ProblemLocationKind.fromString(value.kind);\n\t\t}\n\n\t\tfunction copyProperty(\n\t\t\tresult: IProblemPattern,\n\t\t\tsource: Config.IProblemPattern,\n\t\t\tresultKey: keyof IProblemPattern,\n\t\t\tsourceKey: keyof Config.IProblemPattern,\n\t\t) {\n\t\t\tconst value = source[sourceKey];\n\t\t\tif (typeof value === \"number\") {\n\t\t\t\t(result as any)[resultKey] = value;\n\t\t\t}\n\t\t}\n\t\tcopyProperty(result, value, \"file\", \"file\");\n\t\tcopyProperty(result, value, \"location\", \"location\");\n\t\tcopyProperty(result, value, \"line\", \"line\");\n\t\tcopyProperty(result, value, \"character\", \"column\");\n\t\tcopyProperty(result, value, \"endLine\", \"endLine\");\n\t\tcopyProperty(result, value, \"endCharacter\", \"endColumn\");\n\t\tcopyProperty(result, value, \"severity\", \"severity\");\n\t\tcopyProperty(result, value, \"code\", \"code\");\n\t\tcopyProperty(result, value, \"message\", \"message\");\n\t\tif (value.loop === true || value.loop === false) {\n\t\t\tresult.loop = value.loop;\n\t\t}\n\t\tif (setDefaults) {\n\t\t\tif (result.location || result.kind === ProblemLocationKind.File) {\n\t\t\t\tconst defaultValue: Partial<IProblemPattern> = {\n\t\t\t\t\tfile: 1,\n\t\t\t\t\tmessage: 0,\n\t\t\t\t};\n\t\t\t\tresult = Objects.mixin(result, defaultValue, false);\n\t\t\t} else {\n\t\t\t\tconst defaultValue: Partial<IProblemPattern> = {\n\t\t\t\t\tfile: 1,\n\t\t\t\t\tline: 2,\n\t\t\t\t\tcharacter: 3,\n\t\t\t\t\tmessage: 0,\n\t\t\t\t};\n\t\t\t\tresult = Objects.mixin(result, defaultValue, false);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate validateProblemPattern(values: IProblemPattern[]): boolean {\n\t\tlet file = false,\n\t\t\tmessage = false,\n\t\t\tlocation = false,\n\t\t\tline = false;\n\t\tconst locationKind =\n\t\t\tvalues[0].kind === undefined\n\t\t\t\t? ProblemLocationKind.Location\n\t\t\t\t: values[0].kind;\n\n\t\tvalues.forEach((pattern, i) => {\n\t\t\tif (i !== 0 && pattern.kind) {\n\t\t\t\tthis.error(\n\t\t\t\t\tlocalize(\n\t\t\t\t\t\t\"ProblemPatternParser.problemPattern.kindProperty.notFirst\",\n\t\t\t\t\t\t\"The problem pattern is invalid. The kind property must be provided only in the first element\",\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\t\t\tfile = file || !Types.isUndefined(pattern.file);\n\t\t\tmessage = message || !Types.isUndefined(pattern.message);\n\t\t\tlocation = location || !Types.isUndefined(pattern.location);\n\t\t\tline = line || !Types.isUndefined(pattern.line);\n\t\t});\n\t\tif (!(file && message)) {\n\t\t\tthis.error(\n\t\t\t\tlocalize(\n\t\t\t\t\t\"ProblemPatternParser.problemPattern.missingProperty\",\n\t\t\t\t\t\"The problem pattern is invalid. It must have at least have a file and a message.\",\n\t\t\t\t),\n\t\t\t);\n\t\t\treturn false;\n\t\t}\n\t\tif (\n\t\t\tlocationKind === ProblemLocationKind.Location &&\n\t\t\t!(location || line)\n\t\t) {\n\t\t\tthis.error(\n\t\t\t\tlocalize(\n\t\t\t\t\t\"ProblemPatternParser.problemPattern.missingLocation\",\n\t\t\t\t\t'The problem pattern is invalid. It must either have kind: \"file\" or have a line or location match group.',\n\t\t\t\t),\n\t\t\t);\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate createRegularExpression(value: string): RegExp | undefined {\n\t\tlet result: RegExp | undefined;\n\t\ttry {\n\t\t\tresult = new RegExp(value);\n\t\t} catch (err) {\n\t\t\tthis.error(\n\t\t\t\tlocalize(\n\t\t\t\t\t\"ProblemPatternParser.invalidRegexp\",\n\t\t\t\t\t\"Error: The string {0} is not a valid regular expression.\\n\",\n\t\t\t\t\tvalue,\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\t\treturn result;\n\t}\n}\n\nexport class ExtensionRegistryReporter implements IProblemReporter {\n\tconstructor(\n\t\tprivate _collector: ExtensionMessageCollector,\n\t\tprivate _validationStatus: ValidationStatus = new ValidationStatus(),\n\t) {}\n\n\tpublic info(message: string): void {\n\t\tthis._validationStatus.state = ValidationState.Info;\n\t\tthis._collector.info(message);\n\t}\n\n\tpublic warn(message: string): void {\n\t\tthis._validationStatus.state = ValidationState.Warning;\n\t\tthis._collector.warn(message);\n\t}\n\n\tpublic error(message: string): void {\n\t\tthis._validationStatus.state = ValidationState.Error;\n\t\tthis._collector.error(message);\n\t}\n\n\tpublic fatal(message: string): void {\n\t\tthis._validationStatus.state = ValidationState.Fatal;\n\t\tthis._collector.error(message);\n\t}\n\n\tpublic get status(): ValidationStatus {\n\t\treturn this._validationStatus;\n\t}\n}\n\nexport namespace Schemas {\n\texport const ProblemPattern: IJSONSchema = {\n\t\tdefault: {\n\t\t\tregexp: \"^([^\\\\\\\\s].*)\\\\\\\\((\\\\\\\\d+,\\\\\\\\d+)\\\\\\\\):\\\\\\\\s*(.*)$\",\n\t\t\tfile: 1,\n\t\t\tlocation: 2,\n\t\t\tmessage: 3,\n\t\t},\n\t\ttype: \"object\",\n\t\tadditionalProperties: false,\n\t\tproperties: {\n\t\t\tregexp: {\n\t\t\t\ttype: \"string\",\n\t\t\t\tdescription: localize(\n\t\t\t\t\t\"ProblemPatternSchema.regexp\",\n\t\t\t\t\t\"The regular expression to find an error, warning or info in the output.\",\n\t\t\t\t),\n\t\t\t},\n\t\t\tkind: {\n\t\t\t\ttype: \"string\",\n\t\t\t\tdescription: localize(\n\t\t\t\t\t\"ProblemPatternSchema.kind\",\n\t\t\t\t\t\"whether the pattern matches a location (file and line) or only a file.\",\n\t\t\t\t),\n\t\t\t},\n\t\t\tfile: {\n\t\t\t\ttype: \"integer\",\n\t\t\t\tdescription: localize(\n\t\t\t\t\t\"ProblemPatternSchema.file\",\n\t\t\t\t\t\"The match group index of the filename. If omitted 1 is used.\",\n\t\t\t\t),\n\t\t\t},\n\t\t\tlocation: {\n\t\t\t\ttype: \"integer\",\n\t\t\t\tdescription: localize(\n\t\t\t\t\t\"ProblemPatternSchema.location\",\n\t\t\t\t\t\"The match group index of the problem's location. Valid location patterns are: (line), (line,column) and (startLine,startColumn,endLine,endColumn). If omitted (line,column) is assumed.\",\n\t\t\t\t),\n\t\t\t},\n\t\t\tline: {\n\t\t\t\ttype: \"integer\",\n\t\t\t\tdescription: localize(\n\t\t\t\t\t\"ProblemPatternSchema.line\",\n\t\t\t\t\t\"The match group index of the problem's line. Defaults to 2\",\n\t\t\t\t),\n\t\t\t},\n\t\t\tcolumn: {\n\t\t\t\ttype: \"integer\",\n\t\t\t\tdescription: localize(\n\t\t\t\t\t\"ProblemPatternSchema.column\",\n\t\t\t\t\t\"The match group index of the problem's line character. Defaults to 3\",\n\t\t\t\t),\n\t\t\t},\n\t\t\tendLine: {\n\t\t\t\ttype: \"integer\",\n\t\t\t\tdescription: localize(\n\t\t\t\t\t\"ProblemPatternSchema.endLine\",\n\t\t\t\t\t\"The match group index of the problem's end line. Defaults to undefined\",\n\t\t\t\t),\n\t\t\t},\n\t\t\tendColumn: {\n\t\t\t\ttype: \"integer\",\n\t\t\t\tdescription: localize(\n\t\t\t\t\t\"ProblemPatternSchema.endColumn\",\n\t\t\t\t\t\"The match group index of the problem's end line character. Defaults to undefined\",\n\t\t\t\t),\n\t\t\t},\n\t\t\tseverity: {\n\t\t\t\ttype: \"integer\",\n\t\t\t\tdescription: localize(\n\t\t\t\t\t\"ProblemPatternSchema.severity\",\n\t\t\t\t\t\"The match group index of the problem's severity. Defaults to undefined\",\n\t\t\t\t),\n\t\t\t},\n\t\t\tcode: {\n\t\t\t\ttype: \"integer\",\n\t\t\t\tdescription: localize(\n\t\t\t\t\t\"ProblemPatternSchema.code\",\n\t\t\t\t\t\"The match group index of the problem's code. Defaults to undefined\",\n\t\t\t\t),\n\t\t\t},\n\t\t\tmessage: {\n\t\t\t\ttype: \"integer\",\n\t\t\t\tdescription: localize(\n\t\t\t\t\t\"ProblemPatternSchema.message\",\n\t\t\t\t\t\"The match group index of the message. If omitted it defaults to 4 if location is specified. Otherwise it defaults to 5.\",\n\t\t\t\t),\n\t\t\t},\n\t\t\tloop: {\n\t\t\t\ttype: \"boolean\",\n\t\t\t\tdescription: localize(\n\t\t\t\t\t\"ProblemPatternSchema.loop\",\n\t\t\t\t\t\"In a multi line matcher loop indicated whether this pattern is executed in a loop as long as it matches. Can only specified on a last pattern in a multi line pattern.\",\n\t\t\t\t),\n\t\t\t},\n\t\t},\n\t};\n\n\texport const NamedProblemPattern: IJSONSchema =\n\t\tObjects.deepClone(ProblemPattern);\n\tNamedProblemPattern.properties =\n\t\tObjects.deepClone(NamedProblemPattern.properties) || {};\n\tNamedProblemPattern.properties[\"name\"] = {\n\t\ttype: \"string\",\n\t\tdescription: localize(\n\t\t\t\"NamedProblemPatternSchema.name\",\n\t\t\t\"The name of the problem pattern.\",\n\t\t),\n\t};\n\n\texport const MultiLineProblemPattern: IJSONSchema = {\n\t\ttype: \"array\",\n\t\titems: ProblemPattern,\n\t};\n\n\texport const NamedMultiLineProblemPattern: IJSONSchema = {\n\t\ttype: \"object\",\n\t\tadditionalProperties: false,\n\t\tproperties: {\n\t\t\tname: {\n\t\t\t\ttype: \"string\",\n\t\t\t\tdescription: localize(\n\t\t\t\t\t\"NamedMultiLineProblemPatternSchema.name\",\n\t\t\t\t\t\"The name of the problem multi line problem pattern.\",\n\t\t\t\t),\n\t\t\t},\n\t\t\tpatterns: {\n\t\t\t\ttype: \"array\",\n\t\t\t\tdescription: localize(\n\t\t\t\t\t\"NamedMultiLineProblemPatternSchema.patterns\",\n\t\t\t\t\t\"The actual patterns.\",\n\t\t\t\t),\n\t\t\t\titems: ProblemPattern,\n\t\t\t},\n\t\t},\n\t};\n\n\texport const WatchingPattern: IJSONSchema = {\n\t\ttype: \"object\",\n\t\tadditionalProperties: false,\n\t\tproperties: {\n\t\t\tregexp: {\n\t\t\t\ttype: \"string\",\n\t\t\t\tdescription: localize(\n\t\t\t\t\t\"WatchingPatternSchema.regexp\",\n\t\t\t\t\t\"The regular expression to detect the begin or end of a background task.\",\n\t\t\t\t),\n\t\t\t},\n\t\t\tfile: {\n\t\t\t\ttype: \"integer\",\n\t\t\t\tdescription: localize(\n\t\t\t\t\t\"WatchingPatternSchema.file\",\n\t\t\t\t\t\"The match group index of the filename. Can be omitted.\",\n\t\t\t\t),\n\t\t\t},\n\t\t},\n\t};\n\n\texport const PatternType: IJSONSchema = {\n\t\tanyOf: [\n\t\t\t{\n\t\t\t\ttype: \"string\",\n\t\t\t\tdescription: localize(\n\t\t\t\t\t\"PatternTypeSchema.name\",\n\t\t\t\t\t\"The name of a contributed or predefined pattern\",\n\t\t\t\t),\n\t\t\t},\n\t\t\tSchemas.ProblemPattern,\n\t\t\tSchemas.MultiLineProblemPattern,\n\t\t],\n\t\tdescription: localize(\n\t\t\t\"PatternTypeSchema.description\",\n\t\t\t\"A problem pattern or the name of a contributed or predefined problem pattern. Can be omitted if base is specified.\",\n\t\t),\n\t};\n\n\texport const ProblemMatcher: IJSONSchema = {\n\t\ttype: \"object\",\n\t\tadditionalProperties: false,\n\t\tproperties: {\n\t\t\tbase: {\n\t\t\t\ttype: \"string\",\n\t\t\t\tdescription: localize(\n\t\t\t\t\t\"ProblemMatcherSchema.base\",\n\t\t\t\t\t\"The name of a base problem matcher to use.\",\n\t\t\t\t),\n\t\t\t},\n\t\t\towner: {\n\t\t\t\ttype: \"string\",\n\t\t\t\tdescription: localize(\n\t\t\t\t\t\"ProblemMatcherSchema.owner\",\n\t\t\t\t\t\"The owner of the problem inside Code. Can be omitted if base is specified. Defaults to 'external' if omitted and base is not specified.\",\n\t\t\t\t),\n\t\t\t},\n\t\t\tsource: {\n\t\t\t\ttype: \"string\",\n\t\t\t\tdescription: localize(\n\t\t\t\t\t\"ProblemMatcherSchema.source\",\n\t\t\t\t\t\"A human-readable string describing the source of this diagnostic, e.g. 'typescript' or 'super lint'.\",\n\t\t\t\t),\n\t\t\t},\n\t\t\tseverity: {\n\t\t\t\ttype: \"string\",\n\t\t\t\tenum: [\"error\", \"warning\", \"info\"],\n\t\t\t\tdescription: localize(\n\t\t\t\t\t\"ProblemMatcherSchema.severity\",\n\t\t\t\t\t\"The default severity for captures problems. Is used if the pattern doesn't define a match group for severity.\",\n\t\t\t\t),\n\t\t\t},\n\t\t\tapplyTo: {\n\t\t\t\ttype: \"string\",\n\t\t\t\tenum: [\"allDocuments\", \"openDocuments\", \"closedDocuments\"],\n\t\t\t\tdescription: localize(\n\t\t\t\t\t\"ProblemMatcherSchema.applyTo\",\n\t\t\t\t\t\"Controls if a problem reported on a text document is applied only to open, closed or all documents.\",\n\t\t\t\t),\n\t\t\t},\n\t\t\tpattern: PatternType,\n\t\t\tfileLocation: {\n\t\t\t\toneOf: [\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tenum: [\"absolute\", \"relative\", \"autoDetect\", \"search\"],\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\tprefixItems: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tenum: [\n\t\t\t\t\t\t\t\t\t\"absolute\",\n\t\t\t\t\t\t\t\t\t\"relative\",\n\t\t\t\t\t\t\t\t\t\"autoDetect\",\n\t\t\t\t\t\t\t\t\t\"search\",\n\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t\tminItems: 1,\n\t\t\t\t\t\tmaxItems: 1,\n\t\t\t\t\t\tadditionalItems: false,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\tprefixItems: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tenum: [\"relative\", \"autoDetect\"],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{ type: \"string\" },\n\t\t\t\t\t\t],\n\t\t\t\t\t\tminItems: 2,\n\t\t\t\t\t\tmaxItems: 2,\n\t\t\t\t\t\tadditionalItems: false,\n\t\t\t\t\t\texamples: [\n\t\t\t\t\t\t\t[\"relative\", \"${workspaceFolder}\"],\n\t\t\t\t\t\t\t[\"autoDetect\", \"${workspaceFolder}\"],\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\tprefixItems: [\n\t\t\t\t\t\t\t{ type: \"string\", enum: [\"search\"] },\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\tinclude: {\n\t\t\t\t\t\t\t\t\t\toneOf: [\n\t\t\t\t\t\t\t\t\t\t\t{ type: \"string\" },\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\t\t\t\t\t\titems: { type: \"string\" },\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\texclude: {\n\t\t\t\t\t\t\t\t\t\toneOf: [\n\t\t\t\t\t\t\t\t\t\t\t{ type: \"string\" },\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\t\t\t\t\t\titems: { type: \"string\" },\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\trequired: [\"include\"],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t\tminItems: 2,\n\t\t\t\t\t\tmaxItems: 2,\n\t\t\t\t\t\tadditionalItems: false,\n\t\t\t\t\t\texamples: [\n\t\t\t\t\t\t\t[\"search\", { include: [\"${workspaceFolder}\"] }],\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\"search\",\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tinclude: [\"${workspaceFolder}\"],\n\t\t\t\t\t\t\t\t\texclude: [],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tdescription: localize(\n\t\t\t\t\t\"ProblemMatcherSchema.fileLocation\",\n\t\t\t\t\t\"Defines how file names reported in a problem pattern should be interpreted. A relative fileLocation may be an array, where the second element of the array is the path of the relative file location. The search fileLocation mode, performs a deep (and, possibly, heavy) file system search within the directories specified by the include/exclude properties of the second element (or the current workspace directory if not specified).\",\n\t\t\t\t),\n\t\t\t},\n\t\t\tbackground: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tadditionalProperties: false,\n\t\t\t\tdescription: localize(\n\t\t\t\t\t\"ProblemMatcherSchema.background\",\n\t\t\t\t\t\"Patterns to track the begin and end of a matcher active on a background task.\",\n\t\t\t\t),\n\t\t\t\tproperties: {\n\t\t\t\t\tactiveOnStart: {\n\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\tdescription: localize(\n\t\t\t\t\t\t\t\"ProblemMatcherSchema.background.activeOnStart\",\n\t\t\t\t\t\t\t\"If set to true the background monitor is in active mode when the task starts. This is equals of issuing a line that matches the beginsPattern\",\n\t\t\t\t\t\t),\n\t\t\t\t\t},\n\t\t\t\t\tbeginsPattern: {\n\t\t\t\t\t\toneOf: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tSchemas.WatchingPattern,\n\t\t\t\t\t\t],\n\t\t\t\t\t\tdescription: localize(\n\t\t\t\t\t\t\t\"ProblemMatcherSchema.background.beginsPattern\",\n\t\t\t\t\t\t\t\"If matched in the output the start of a background task is signaled.\",\n\t\t\t\t\t\t),\n\t\t\t\t\t},\n\t\t\t\t\tendsPattern: {\n\t\t\t\t\t\toneOf: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tSchemas.WatchingPattern,\n\t\t\t\t\t\t],\n\t\t\t\t\t\tdescription: localize(\n\t\t\t\t\t\t\t\"ProblemMatcherSchema.background.endsPattern\",\n\t\t\t\t\t\t\t\"If matched in the output the end of a background task is signaled.\",\n\t\t\t\t\t\t),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twatching: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tadditionalProperties: false,\n\t\t\t\tdeprecationMessage: localize(\n\t\t\t\t\t\"ProblemMatcherSchema.watching.deprecated\",\n\t\t\t\t\t\"The watching property is deprecated. Use background instead.\",\n\t\t\t\t),\n\t\t\t\tdescription: localize(\n\t\t\t\t\t\"ProblemMatcherSchema.watching\",\n\t\t\t\t\t\"Patterns to track the begin and end of a watching matcher.\",\n\t\t\t\t),\n\t\t\t\tproperties: {\n\t\t\t\t\tactiveOnStart: {\n\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\tdescription: localize(\n\t\t\t\t\t\t\t\"ProblemMatcherSchema.watching.activeOnStart\",\n\t\t\t\t\t\t\t\"If set to true the watcher is in active mode when the task starts. This is equals of issuing a line that matches the beginPattern\",\n\t\t\t\t\t\t),\n\t\t\t\t\t},\n\t\t\t\t\tbeginsPattern: {\n\t\t\t\t\t\toneOf: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tSchemas.WatchingPattern,\n\t\t\t\t\t\t],\n\t\t\t\t\t\tdescription: localize(\n\t\t\t\t\t\t\t\"ProblemMatcherSchema.watching.beginsPattern\",\n\t\t\t\t\t\t\t\"If matched in the output the start of a watching task is signaled.\",\n\t\t\t\t\t\t),\n\t\t\t\t\t},\n\t\t\t\t\tendsPattern: {\n\t\t\t\t\t\toneOf: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tSchemas.WatchingPattern,\n\t\t\t\t\t\t],\n\t\t\t\t\t\tdescription: localize(\n\t\t\t\t\t\t\t\"ProblemMatcherSchema.watching.endsPattern\",\n\t\t\t\t\t\t\t\"If matched in the output the end of a watching task is signaled.\",\n\t\t\t\t\t\t),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t};\n\n\texport const LegacyProblemMatcher: IJSONSchema =\n\t\tObjects.deepClone(ProblemMatcher);\n\tLegacyProblemMatcher.properties =\n\t\tObjects.deepClone(LegacyProblemMatcher.properties) || {};\n\tLegacyProblemMatcher.properties[\"watchedTaskBeginsRegExp\"] = {\n\t\ttype: \"string\",\n\t\tdeprecationMessage: localize(\n\t\t\t\"LegacyProblemMatcherSchema.watchedBegin.deprecated\",\n\t\t\t\"This property is deprecated. Use the watching property instead.\",\n\t\t),\n\t\tdescription: localize(\n\t\t\t\"LegacyProblemMatcherSchema.watchedBegin\",\n\t\t\t\"A regular expression signaling that a watched tasks begins executing triggered through file watching.\",\n\t\t),\n\t};\n\tLegacyProblemMatcher.properties[\"watchedTaskEndsRegExp\"] = {\n\t\ttype: \"string\",\n\t\tdeprecationMessage: localize(\n\t\t\t\"LegacyProblemMatcherSchema.watchedEnd.deprecated\",\n\t\t\t\"This property is deprecated. Use the watching property instead.\",\n\t\t),\n\t\tdescription: localize(\n\t\t\t\"LegacyProblemMatcherSchema.watchedEnd\",\n\t\t\t\"A regular expression signaling that a watched tasks ends executing.\",\n\t\t),\n\t};\n\n\texport const NamedProblemMatcher: IJSONSchema =\n\t\tObjects.deepClone(ProblemMatcher);\n\tNamedProblemMatcher.properties =\n\t\tObjects.deepClone(NamedProblemMatcher.properties) || {};\n\tNamedProblemMatcher.properties.name = {\n\t\ttype: \"string\",\n\t\tdescription: localize(\n\t\t\t\"NamedProblemMatcherSchema.name\",\n\t\t\t\"The name of the problem matcher used to refer to it.\",\n\t\t),\n\t};\n\tNamedProblemMatcher.properties.label = {\n\t\ttype: \"string\",\n\t\tdescription: localize(\n\t\t\t\"NamedProblemMatcherSchema.label\",\n\t\t\t\"A human readable label of the problem matcher.\",\n\t\t),\n\t};\n}\n\nconst problemPatternExtPoint =\n\tExtensionsRegistry.registerExtensionPoint<Config.NamedProblemPatterns>({\n\t\textensionPoint: \"problemPatterns\",\n\t\tjsonSchema: {\n\t\t\tdescription: localize(\n\t\t\t\t\"ProblemPatternExtPoint\",\n\t\t\t\t\"Contributes problem patterns\",\n\t\t\t),\n\t\t\ttype: \"array\",\n\t\t\titems: {\n\t\t\t\tanyOf: [\n\t\t\t\t\tSchemas.NamedProblemPattern,\n\t\t\t\t\tSchemas.NamedMultiLineProblemPattern,\n\t\t\t\t],\n\t\t\t},\n\t\t},\n\t});\n\nexport interface IProblemPatternRegistry {\n\tonReady(): Promise<void>;\n\n\tget(key: string): IProblemPattern | MultiLineProblemPattern;\n}\n\nclass ProblemPatternRegistryImpl implements IProblemPatternRegistry {\n\tprivate patterns: IStringDictionary<IProblemPattern | IProblemPattern[]>;\n\tprivate readyPromise: Promise<void>;\n\n\tconstructor() {\n\t\tthis.patterns = Object.create(null);\n\t\tthis.fillDefaults();\n\t\tthis.readyPromise = new Promise<void>((resolve, reject) => {\n\t\t\tproblemPatternExtPoint.setHandler((extensions, delta) => {\n\t\t\t\t// We get all statically know extension during startup in one batch\n\t\t\t\ttry {\n\t\t\t\t\tdelta.removed.forEach((extension) => {\n\t\t\t\t\t\tconst problemPatterns =\n\t\t\t\t\t\t\textension.value as Config.NamedProblemPatterns;\n\t\t\t\t\t\tfor (const pattern of problemPatterns) {\n\t\t\t\t\t\t\tif (this.patterns[pattern.name]) {\n\t\t\t\t\t\t\t\tdelete this.patterns[pattern.name];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tdelta.added.forEach((extension) => {\n\t\t\t\t\t\tconst problemPatterns =\n\t\t\t\t\t\t\textension.value as Config.NamedProblemPatterns;\n\t\t\t\t\t\tconst parser = new ProblemPatternParser(\n\t\t\t\t\t\t\tnew ExtensionRegistryReporter(extension.collector),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tfor (const pattern of problemPatterns) {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tConfig.NamedMultiLineCheckedProblemPattern.is(\n\t\t\t\t\t\t\t\t\tpattern,\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst result = parser.parse(pattern);\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tparser.problemReporter.status.state <\n\t\t\t\t\t\t\t\t\tValidationState.Error\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tthis.add(result.name, result.patterns);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\textension.collector.error(\n\t\t\t\t\t\t\t\t\t\tlocalize(\n\t\t\t\t\t\t\t\t\t\t\t\"ProblemPatternRegistry.error\",\n\t\t\t\t\t\t\t\t\t\t\t\"Invalid problem pattern. The pattern will be ignored.\",\n\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\textension.collector.error(\n\t\t\t\t\t\t\t\t\t\tJSON.stringify(pattern, undefined, 4),\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (Config.NamedProblemPattern.is(pattern)) {\n\t\t\t\t\t\t\t\tconst result = parser.parse(pattern);\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tparser.problemReporter.status.state <\n\t\t\t\t\t\t\t\t\tValidationState.Error\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tthis.add(pattern.name, result);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\textension.collector.error(\n\t\t\t\t\t\t\t\t\t\tlocalize(\n\t\t\t\t\t\t\t\t\t\t\t\"ProblemPatternRegistry.error\",\n\t\t\t\t\t\t\t\t\t\t\t\"Invalid problem pattern. The pattern will be ignored.\",\n\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\textension.collector.error(\n\t\t\t\t\t\t\t\t\t\tJSON.stringify(pattern, undefined, 4),\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tparser.reset();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// Do nothing\n\t\t\t\t}\n\t\t\t\tresolve(undefined);\n\t\t\t});\n\t\t});\n\t}\n\n\tpublic onReady(): Promise<void> {\n\t\treturn this.readyPromise;\n\t}\n\n\tpublic add(key: string, value: IProblemPattern | IProblemPattern[]): void {\n\t\tthis.patterns[key] = value;\n\t}\n\n\tpublic get(key: string): IProblemPattern | IProblemPattern[] {\n\t\treturn this.patterns[key];\n\t}\n\n\tprivate fillDefaults(): void {\n\t\tthis.add(\"msCompile\", {\n\t\t\tregexp: /^(?:\\s*\\d+>)?(\\S.*)\\((\\d+|\\d+,\\d+|\\d+,\\d+,\\d+,\\d+)\\)\\s*:\\s+((?:fatal +)?error|warning|info)\\s+(\\w+\\d+)\\s*:\\s*(.*)$/,\n\t\t\tkind: ProblemLocationKind.Location,\n\t\t\tfile: 1,\n\t\t\tlocation: 2,\n\t\t\tseverity: 3,\n\t\t\tcode: 4,\n\t\t\tmessage: 5,\n\t\t});\n\t\tthis.add(\"gulp-tsc\", {\n\t\t\tregexp: /^([^\\s].*)\\((\\d+|\\d+,\\d+|\\d+,\\d+,\\d+,\\d+)\\):\\s+(\\d+)\\s+(.*)$/,\n\t\t\tkind: ProblemLocationKind.Location,\n\t\t\tfile: 1,\n\t\t\tlocation: 2,\n\t\t\tcode: 3,\n\t\t\tmessage: 4,\n\t\t});\n\t\tthis.add(\"cpp\", {\n\t\t\tregexp: /^(\\S.*)\\((\\d+|\\d+,\\d+|\\d+,\\d+,\\d+,\\d+)\\):\\s+(error|warning|info)\\s+(C\\d+)\\s*:\\s*(.*)$/,\n\t\t\tkind: ProblemLocationKind.Location,\n\t\t\tfile: 1,\n\t\t\tlocation: 2,\n\t\t\tseverity: 3,\n\t\t\tcode: 4,\n\t\t\tmessage: 5,\n\t\t});\n\t\tthis.add(\"csc\", {\n\t\t\tregexp: /^(\\S.*)\\((\\d+|\\d+,\\d+|\\d+,\\d+,\\d+,\\d+)\\):\\s+(error|warning|info)\\s+(CS\\d+)\\s*:\\s*(.*)$/,\n\t\t\tkind: ProblemLocationKind.Location,\n\t\t\tfile: 1,\n\t\t\tlocation: 2,\n\t\t\tseverity: 3,\n\t\t\tcode: 4,\n\t\t\tmessage: 5,\n\t\t});\n\t\tthis.add(\"vb\", {\n\t\t\tregexp: /^(\\S.*)\\((\\d+|\\d+,\\d+|\\d+,\\d+,\\d+,\\d+)\\):\\s+(error|warning|info)\\s+(BC\\d+)\\s*:\\s*(.*)$/,\n\t\t\tkind: ProblemLocationKind.Location,\n\t\t\tfile: 1,\n\t\t\tlocation: 2,\n\t\t\tseverity: 3,\n\t\t\tcode: 4,\n\t\t\tmessage: 5,\n\t\t});\n\t\tthis.add(\"lessCompile\", {\n\t\t\tregexp: /^\\s*(.*) in file (.*) line no. (\\d+)$/,\n\t\t\tkind: ProblemLocationKind.Location,\n\t\t\tmessage: 1,\n\t\t\tfile: 2,\n\t\t\tline: 3,\n\t\t});\n\t\tthis.add(\"jshint\", {\n\t\t\tregexp: /^(.*):\\s+line\\s+(\\d+),\\s+col\\s+(\\d+),\\s(.+?)(?:\\s+\\((\\w)(\\d+)\\))?$/,\n\t\t\tkind: ProblemLocationKind.Location,\n\t\t\tfile: 1,\n\t\t\tline: 2,\n\t\t\tcharacter: 3,\n\t\t\tmessage: 4,\n\t\t\tseverity: 5,\n\t\t\tcode: 6,\n\t\t});\n\t\tthis.add(\"jshint-stylish\", [\n\t\t\t{\n\t\t\t\tregexp: /^(.+)$/,\n\t\t\t\tkind: ProblemLocationKind.Location,\n\t\t\t\tfile: 1,\n\t\t\t},\n\t\t\t{\n\t\t\t\tregexp: /^\\s+line\\s+(\\d+)\\s+col\\s+(\\d+)\\s+(.+?)(?:\\s+\\((\\w)(\\d+)\\))?$/,\n\t\t\t\tline: 1,\n\t\t\t\tcharacter: 2,\n\t\t\t\tmessage: 3,\n\t\t\t\tseverity: 4,\n\t\t\t\tcode: 5,\n\t\t\t\tloop: true,\n\t\t\t},\n\t\t]);\n\t\tthis.add(\"eslint-compact\", {\n\t\t\tregexp: /^(.+):\\sline\\s(\\d+),\\scol\\s(\\d+),\\s(Error|Warning|Info)\\s-\\s(.+)\\s\\((.+)\\)$/,\n\t\t\tfile: 1,\n\t\t\tkind: ProblemLocationKind.Location,\n\t\t\tline: 2,\n\t\t\tcharacter: 3,\n\t\t\tseverity: 4,\n\t\t\tmessage: 5,\n\t\t\tcode: 6,\n\t\t});\n\t\tthis.add(\"eslint-stylish\", [\n\t\t\t{\n\t\t\t\tregexp: /^((?:[a-zA-Z]:)*[./\\\\]+.*?)$/,\n\t\t\t\tkind: ProblemLocationKind.Location,\n\t\t\t\tfile: 1,\n\t\t\t},\n\t\t\t{\n\t\t\t\tregexp: /^\\s+(\\d+):(\\d+)\\s+(error|warning|info)\\s+(.+?)(?:\\s\\s+(.*))?$/,\n\t\t\t\tline: 1,\n\t\t\t\tcharacter: 2,\n\t\t\t\tseverity: 3,\n\t\t\t\tmessage: 4,\n\t\t\t\tcode: 5,\n\t\t\t\tloop: true,\n\t\t\t},\n\t\t]);\n\t\tthis.add(\"go\", {\n\t\t\tregexp: /^([^:]*: )?((.:)?[^:]*):(\\d+)(:(\\d+))?: (.*)$/,\n\t\t\tkind: ProblemLocationKind.Location,\n\t\t\tfile: 2,\n\t\t\tline: 4,\n\t\t\tcharacter: 6,\n\t\t\tmessage: 7,\n\t\t});\n\t}\n}\n\nexport const ProblemPatternRegistry: IProblemPatternRegistry =\n\tnew ProblemPatternRegistryImpl();\n\nexport class ProblemMatcherParser extends Parser {\n\tconstructor(logger: IProblemReporter) {\n\t\tsuper(logger);\n\t}\n\n\tpublic parse(json: Config.ProblemMatcher): ProblemMatcher | undefined {\n\t\tconst result = this.createProblemMatcher(json);\n\t\tif (!this.checkProblemMatcherValid(json, result)) {\n\t\t\treturn undefined;\n\t\t}\n\t\tthis.addWatchingMatcher(json, result);\n\n\t\treturn result;\n\t}\n\n\tprivate checkProblemMatcherValid(\n\t\texternalProblemMatcher: Config.ProblemMatcher,\n\t\tproblemMatcher: ProblemMatcher | null,\n\t): problemMatcher is ProblemMatcher {\n\t\tif (!problemMatcher) {\n\t\t\tthis.error(\n\t\t\t\tlocalize(\n\t\t\t\t\t\"ProblemMatcherParser.noProblemMatcher\",\n\t\t\t\t\t\"Error: the description can't be converted into a problem matcher:\\n{0}\\n\",\n\t\t\t\t\tJSON.stringify(externalProblemMatcher, null, 4),\n\t\t\t\t),\n\t\t\t);\n\t\t\treturn false;\n\t\t}\n\t\tif (!problemMatcher.pattern) {\n\t\t\tthis.error(\n\t\t\t\tlocalize(\n\t\t\t\t\t\"ProblemMatcherParser.noProblemPattern\",\n\t\t\t\t\t\"Error: the description doesn't define a valid problem pattern:\\n{0}\\n\",\n\t\t\t\t\tJSON.stringify(externalProblemMatcher, null, 4),\n\t\t\t\t),\n\t\t\t);\n\t\t\treturn false;\n\t\t}\n\t\tif (!problemMatcher.owner) {\n\t\t\tthis.error(\n\t\t\t\tlocalize(\n\t\t\t\t\t\"ProblemMatcherParser.noOwner\",\n\t\t\t\t\t\"Error: the description doesn't define an owner:\\n{0}\\n\",\n\t\t\t\t\tJSON.stringify(externalProblemMatcher, null, 4),\n\t\t\t\t),\n\t\t\t);\n\t\t\treturn false;\n\t\t}\n\t\tif (Types.isUndefined(problemMatcher.fileLocation)) {\n\t\t\tthis.error(\n\t\t\t\tlocalize(\n\t\t\t\t\t\"ProblemMatcherParser.noFileLocation\",\n\t\t\t\t\t\"Error: the description doesn't define a file location:\\n{0}\\n\",\n\t\t\t\t\tJSON.stringify(externalProblemMatcher, null, 4),\n\t\t\t\t),\n\t\t\t);\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate createProblemMatcher(\n\t\tdescription: Config.ProblemMatcher,\n\t): ProblemMatcher | null {\n\t\tlet result: ProblemMatcher | null = null;\n\n\t\tconst owner = Types.isString(description.owner)\n\t\t\t? description.owner\n\t\t\t: UUID.generateUuid();\n\t\tconst source = Types.isString(description.source)\n\t\t\t? description.source\n\t\t\t: undefined;\n\t\tlet applyTo = Types.isString(description.applyTo)\n\t\t\t? ApplyToKind.fromString(description.applyTo)\n\t\t\t: ApplyToKind.allDocuments;\n\t\tif (!applyTo) {\n\t\t\tapplyTo = ApplyToKind.allDocuments;\n\t\t}\n\t\tlet fileLocation: FileLocationKind | undefined;\n\t\tlet filePrefix: string | Config.SearchFileLocationArgs | undefined;\n\n\t\tlet kind: FileLocationKind | undefined;\n\t\tif (Types.isUndefined(description.fileLocation)) {\n\t\t\tfileLocation = FileLocationKind.Relative;\n\t\t\tfilePrefix = \"${workspaceFolder}\";\n\t\t} else if (Types.isString(description.fileLocation)) {\n\t\t\tkind = FileLocationKind.fromString(\n\t\t\t\t<string>description.fileLocation,\n\t\t\t);\n\t\t\tif (kind) {\n\t\t\t\tfileLocation = kind;\n\t\t\t\tif (\n\t\t\t\t\tkind === FileLocationKind.Relative ||\n\t\t\t\t\tkind === FileLocationKind.AutoDetect\n\t\t\t\t) {\n\t\t\t\t\tfilePrefix = \"${workspaceFolder}\";\n\t\t\t\t} else if (kind === FileLocationKind.Search) {\n\t\t\t\t\tfilePrefix = { include: [\"${workspaceFolder}\"] };\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (Types.isStringArray(description.fileLocation)) {\n\t\t\tconst values = <string[]>description.fileLocation;\n\t\t\tif (values.length > 0) {\n\t\t\t\tkind = FileLocationKind.fromString(values[0]);\n\t\t\t\tif (values.length === 1 && kind === FileLocationKind.Absolute) {\n\t\t\t\t\tfileLocation = kind;\n\t\t\t\t} else if (\n\t\t\t\t\tvalues.length === 2 &&\n\t\t\t\t\t(kind === FileLocationKind.Relative ||\n\t\t\t\t\t\tkind === FileLocationKind.AutoDetect) &&\n\t\t\t\t\tvalues[1]\n\t\t\t\t) {\n\t\t\t\t\tfileLocation = kind;\n\t\t\t\t\tfilePrefix = values[1];\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (Array.isArray(description.fileLocation)) {\n\t\t\tconst kind = FileLocationKind.fromString(\n\t\t\t\tdescription.fileLocation[0],\n\t\t\t);\n\t\t\tif (kind === FileLocationKind.Search) {\n\t\t\t\tfileLocation = FileLocationKind.Search;\n\t\t\t\tfilePrefix = description.fileLocation[1] ?? {\n\t\t\t\t\tinclude: [\"${workspaceFolder}\"],\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tconst pattern = description.pattern\n\t\t\t? this.createProblemPattern(description.pattern)\n\t\t\t: undefined;\n\n\t\tlet severity = description.severity\n\t\t\t? Severity.fromValue(description.severity)\n\t\t\t: undefined;\n\t\tif (severity === Severity.Ignore) {\n\t\t\tthis.info(\n\t\t\t\tlocalize(\n\t\t\t\t\t\"ProblemMatcherParser.unknownSeverity\",\n\t\t\t\t\t\"Info: unknown severity {0}. Valid values are error, warning and info.\\n\",\n\t\t\t\t\tdescription.severity,\n\t\t\t\t),\n\t\t\t);\n\t\t\tseverity = Severity.Error;\n\t\t}\n\n\t\tif (Types.isString(description.base)) {\n\t\t\tconst variableName = <string>description.base;\n\t\t\tif (variableName.length > 1 && variableName[0] === \"$\") {\n\t\t\t\tconst base = ProblemMatcherRegistry.get(\n\t\t\t\t\tvariableName.substring(1),\n\t\t\t\t);\n\t\t\t\tif (base) {\n\t\t\t\t\tresult = Objects.deepClone(base);\n\t\t\t\t\tif (\n\t\t\t\t\t\tdescription.owner !== undefined &&\n\t\t\t\t\t\towner !== undefined\n\t\t\t\t\t) {\n\t\t\t\t\t\tresult.owner = owner;\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\tdescription.source !== undefined &&\n\t\t\t\t\t\tsource !== undefined\n\t\t\t\t\t) {\n\t\t\t\t\t\tresult.source = source;\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\tdescription.fileLocation !== undefined &&\n\t\t\t\t\t\tfileLocation !== undefined\n\t\t\t\t\t) {\n\t\t\t\t\t\tresult.fileLocation = fileLocation;\n\t\t\t\t\t\tresult.filePrefix = filePrefix;\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\tdescription.pattern !== undefined &&\n\t\t\t\t\t\tpattern !== undefined &&\n\t\t\t\t\t\tpattern !== null\n\t\t\t\t\t) {\n\t\t\t\t\t\tresult.pattern = pattern;\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\tdescription.severity !== undefined &&\n\t\t\t\t\t\tseverity !== undefined\n\t\t\t\t\t) {\n\t\t\t\t\t\tresult.severity = severity;\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\tdescription.applyTo !== undefined &&\n\t\t\t\t\t\tapplyTo !== undefined\n\t\t\t\t\t) {\n\t\t\t\t\t\tresult.applyTo = applyTo;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (fileLocation && pattern) {\n\t\t\tresult = {\n\t\t\t\towner: owner,\n\t\t\t\tapplyTo: applyTo,\n\t\t\t\tfileLocation: fileLocation,\n\t\t\t\tpattern: pattern,\n\t\t\t};\n\t\t\tif (source) {\n\t\t\t\tresult.source = source;\n\t\t\t}\n\t\t\tif (filePrefix) {\n\t\t\t\tresult.filePrefix = filePrefix;\n\t\t\t}\n\t\t\tif (severity) {\n\t\t\t\tresult.severity = severity;\n\t\t\t}\n\t\t}\n\t\tif (Config.isNamedProblemMatcher(description)) {\n\t\t\t(result as INamedProblemMatcher).name = description.name;\n\t\t\t(result as INamedProblemMatcher).label = Types.isString(\n\t\t\t\tdescription.label,\n\t\t\t)\n\t\t\t\t? description.label\n\t\t\t\t: description.name;\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate createProblemPattern(\n\t\tvalue: string | Config.IProblemPattern | Config.MultiLineProblemPattern,\n\t): IProblemPattern | IProblemPattern[] | null {\n\t\tif (Types.isString(value)) {\n\t\t\tconst variableName: string = <string>value;\n\t\t\tif (variableName.length > 1 && variableName[0] === \"$\") {\n\t\t\t\tconst result = ProblemPatternRegistry.get(\n\t\t\t\t\tvariableName.substring(1),\n\t\t\t\t);\n\t\t\t\tif (!result) {\n\t\t\t\t\tthis.error(\n\t\t\t\t\t\tlocalize(\n\t\t\t\t\t\t\t\"ProblemMatcherParser.noDefinedPatter\",\n\t\t\t\t\t\t\t\"Error: the pattern with the identifier {0} doesn't exist.\",\n\t\t\t\t\t\t\tvariableName,\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else if (variableName.length === 0) {\n\t\t\t\tthis.error(\n\t\t\t\t\tlocalize(\n\t\t\t\t\t\t\"ProblemMatcherParser.noIdentifier\",\n\t\t\t\t\t\t\"Error: the pattern property refers to an empty identifier.\",\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthis.error(\n\t\t\t\t\tlocalize(\n\t\t\t\t\t\t\"ProblemMatcherParser.noValidIdentifier\",\n\t\t\t\t\t\t\"Error: the pattern property {0} is not a valid pattern variable name.\",\n\t\t\t\t\t\tvariableName,\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (value) {\n\t\t\tconst problemPatternParser = new ProblemPatternParser(\n\t\t\t\tthis.problemReporter,\n\t\t\t);\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\treturn problemPatternParser.parse(value);\n\t\t\t} else {\n\t\t\t\treturn problemPatternParser.parse(value);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate addWatchingMatcher(\n\t\texternal: Config.ProblemMatcher,\n\t\tinternal: ProblemMatcher,\n\t): void {\n\t\tconst oldBegins = this.createRegularExpression(\n\t\t\texternal.watchedTaskBeginsRegExp,\n\t\t);\n\t\tconst oldEnds = this.createRegularExpression(\n\t\t\texternal.watchedTaskEndsRegExp,\n\t\t);\n\t\tif (oldBegins && oldEnds) {\n\t\t\tinternal.watching = {\n\t\t\t\tactiveOnStart: false,\n\t\t\t\tbeginsPattern: { regexp: oldBegins },\n\t\t\t\tendsPattern: { regexp: oldEnds },\n\t\t\t};\n\t\t\treturn;\n\t\t}\n\t\tconst backgroundMonitor = external.background || external.watching;\n\t\tif (Types.isUndefinedOrNull(backgroundMonitor)) {\n\t\t\treturn;\n\t\t}\n\t\tconst begins: IWatchingPattern | null = this.createWatchingPattern(\n\t\t\tbackgroundMonitor.beginsPattern,\n\t\t);\n\t\tconst ends: IWatchingPattern | null = this.createWatchingPattern(\n\t\t\tbackgroundMonitor.endsPattern,\n\t\t);\n\t\tif (begins && ends) {\n\t\t\tinternal.watching = {\n\t\t\t\tactiveOnStart: Types.isBoolean(backgroundMonitor.activeOnStart)\n\t\t\t\t\t? backgroundMonitor.activeOnStart\n\t\t\t\t\t: false,\n\t\t\t\tbeginsPattern: begins,\n\t\t\t\tendsPattern: ends,\n\t\t\t};\n\t\t\treturn;\n\t\t}\n\t\tif (begins || ends) {\n\t\t\tthis.error(\n\t\t\t\tlocalize(\n\t\t\t\t\t\"ProblemMatcherParser.problemPattern.watchingMatcher\",\n\t\t\t\t\t\"A problem matcher must define both a begin pattern and an end pattern for watching.\",\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate createWatchingPattern(\n\t\texternal: string | Config.IWatchingPattern | undefined,\n\t): IWatchingPattern | null {\n\t\tif (Types.isUndefinedOrNull(external)) {\n\t\t\treturn null;\n\t\t}\n\t\tlet regexp: RegExp | null;\n\t\tlet file: number | undefined;\n\t\tif (Types.isString(external)) {\n\t\t\tregexp = this.createRegularExpression(external);\n\t\t} else {\n\t\t\tregexp = this.createRegularExpression(external.regexp);\n\t\t\tif (Types.isNumber(external.file)) {\n\t\t\t\tfile = external.file;\n\t\t\t}\n\t\t}\n\t\tif (!regexp) {\n\t\t\treturn null;\n\t\t}\n\t\treturn file ? { regexp, file } : { regexp, file: 1 };\n\t}\n\n\tprivate createRegularExpression(value: string | undefined): RegExp | null {\n\t\tlet result: RegExp | null = null;\n\t\tif (!value) {\n\t\t\treturn result;\n\t\t}\n\t\ttry {\n\t\t\tresult = new RegExp(value);\n\t\t} catch (err) {\n\t\t\tthis.error(\n\t\t\t\tlocalize(\n\t\t\t\t\t\"ProblemMatcherParser.invalidRegexp\",\n\t\t\t\t\t\"Error: The string {0} is not a valid regular expression.\\n\",\n\t\t\t\t\tvalue,\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\t\treturn result;\n\t}\n}\n\nconst problemMatchersExtPoint = ExtensionsRegistry.registerExtensionPoint<\n\tConfig.INamedProblemMatcher[]\n>({\n\textensionPoint: \"problemMatchers\",\n\tdeps: [problemPatternExtPoint],\n\tjsonSchema: {\n\t\tdescription: localize(\n\t\t\t\"ProblemMatcherExtPoint\",\n\t\t\t\"Contributes problem matchers\",\n\t\t),\n\t\ttype: \"array\",\n\t\titems: Schemas.NamedProblemMatcher,\n\t},\n});\n\nexport interface IProblemMatcherRegistry {\n\tonReady(): Promise<void>;\n\tget(name: string): INamedProblemMatcher;\n\tkeys(): string[];\n\treadonly onMatcherChanged: Event<void>;\n}\n\nclass ProblemMatcherRegistryImpl implements IProblemMatcherRegistry {\n\tprivate matchers: IStringDictionary<INamedProblemMatcher>;\n\tprivate readyPromise: Promise<void>;\n\tprivate readonly _onMatchersChanged: Emitter<void> = new Emitter<void>();\n\tpublic readonly onMatcherChanged: Event<void> =\n\t\tthis._onMatchersChanged.event;\n\n\tconstructor() {\n\t\tthis.matchers = Object.create(null);\n\t\tthis.fillDefaults();\n\t\tthis.readyPromise = new Promise<void>((resolve, reject) => {\n\t\t\tproblemMatchersExtPoint.setHandler((extensions, delta) => {\n\t\t\t\ttry {\n\t\t\t\t\tdelta.removed.forEach((extension) => {\n\t\t\t\t\t\tconst problemMatchers = extension.value;\n\t\t\t\t\t\tfor (const matcher of problemMatchers) {\n\t\t\t\t\t\t\tif (this.matchers[matcher.name]) {\n\t\t\t\t\t\t\t\tdelete this.matchers[matcher.name];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tdelta.added.forEach((extension) => {\n\t\t\t\t\t\tconst problemMatchers = extension.value;\n\t\t\t\t\t\tconst parser = new ProblemMatcherParser(\n\t\t\t\t\t\t\tnew ExtensionRegistryReporter(extension.collector),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tfor (const matcher of problemMatchers) {\n\t\t\t\t\t\t\tconst result = parser.parse(matcher);\n\t\t\t\t\t\t\tif (result && isNamedProblemMatcher(result)) {\n\t\t\t\t\t\t\t\tthis.add(result);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tif (delta.removed.length > 0 || delta.added.length > 0) {\n\t\t\t\t\t\tthis._onMatchersChanged.fire();\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {}\n\t\t\t\tconst matcher = this.get(\"tsc-watch\");\n\t\t\t\tif (matcher) {\n\t\t\t\t\t(<any>matcher).tscWatch = true;\n\t\t\t\t}\n\t\t\t\tresolve(undefined);\n\t\t\t});\n\t\t});\n\t}\n\n\tpublic onReady(): Promise<void> {\n\t\tProblemPatternRegistry.onReady();\n\t\treturn this.readyPromise;\n\t}\n\n\tpublic add(matcher: INamedProblemMatcher): void {\n\t\tthis.matchers[matcher.name] = matcher;\n\t}\n\n\tpublic get(name: string): INamedProblemMatcher {\n\t\treturn this.matchers[name];\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn Object.keys(this.matchers);\n\t}\n\n\tprivate fillDefaults(): void {\n\t\tthis.add({\n\t\t\tname: \"msCompile\",\n\t\t\tlabel: localize(\"msCompile\", \"Microsoft compiler problems\"),\n\t\t\towner: \"msCompile\",\n\t\t\tsource: \"cpp\",\n\t\t\tapplyTo: ApplyToKind.allDocuments,\n\t\t\tfileLocation: FileLocationKind.Absolute,\n\t\t\tpattern: ProblemPatternRegistry.get(\"msCompile\"),\n\t\t});\n\n\t\tthis.add({\n\t\t\tname: \"lessCompile\",\n\t\t\tlabel: localize(\"lessCompile\", \"Less problems\"),\n\t\t\tdeprecated: true,\n\t\t\towner: \"lessCompile\",\n\t\t\tsource: \"less\",\n\t\t\tapplyTo: ApplyToKind.allDocuments,\n\t\t\tfileLocation: FileLocationKind.Absolute,\n\t\t\tpattern: ProblemPatternRegistry.get(\"lessCompile\"),\n\t\t\tseverity: Severity.Error,\n\t\t});\n\n\t\tthis.add({\n\t\t\tname: \"gulp-tsc\",\n\t\t\tlabel: localize(\"gulp-tsc\", \"Gulp TSC Problems\"),\n\t\t\towner: \"typescript\",\n\t\t\tsource: \"ts\",\n\t\t\tapplyTo: ApplyToKind.closedDocuments,\n\t\t\tfileLocation: FileLocationKind.Relative,\n\t\t\tfilePrefix: \"${workspaceFolder}\",\n\t\t\tpattern: ProblemPatternRegistry.get(\"gulp-tsc\"),\n\t\t});\n\n\t\tthis.add({\n\t\t\tname: \"jshint\",\n\t\t\tlabel: localize(\"jshint\", \"JSHint problems\"),\n\t\t\towner: \"jshint\",\n\t\t\tsource: \"jshint\",\n\t\t\tapplyTo: ApplyToKind.allDocuments,\n\t\t\tfileLocation: FileLocationKind.Absolute,\n\t\t\tpattern: ProblemPatternRegistry.get(\"jshint\"),\n\t\t});\n\n\t\tthis.add({\n\t\t\tname: \"jshint-stylish\",\n\t\t\tlabel: localize(\"jshint-stylish\", \"JSHint stylish problems\"),\n\t\t\towner: \"jshint\",\n\t\t\tsource: \"jshint\",\n\t\t\tapplyTo: ApplyToKind.allDocuments,\n\t\t\tfileLocation: FileLocationKind.Absolute,\n\t\t\tpattern: ProblemPatternRegistry.get(\"jshint-stylish\"),\n\t\t});\n\n\t\tthis.add({\n\t\t\tname: \"eslint-compact\",\n\t\t\tlabel: localize(\"eslint-compact\", \"ESLint compact problems\"),\n\t\t\towner: \"eslint\",\n\t\t\tsource: \"eslint\",\n\t\t\tapplyTo: ApplyToKind.allDocuments,\n\t\t\tfileLocation: FileLocationKind.Absolute,\n\t\t\tfilePrefix: \"${workspaceFolder}\",\n\t\t\tpattern: ProblemPatternRegistry.get(\"eslint-compact\"),\n\t\t});\n\n\t\tthis.add({\n\t\t\tname: \"eslint-stylish\",\n\t\t\tlabel: localize(\"eslint-stylish\", \"ESLint stylish problems\"),\n\t\t\towner: \"eslint\",\n\t\t\tsource: \"eslint\",\n\t\t\tapplyTo: ApplyToKind.allDocuments,\n\t\t\tfileLocation: FileLocationKind.Absolute,\n\t\t\tpattern: ProblemPatternRegistry.get(\"eslint-stylish\"),\n\t\t});\n\n\t\tthis.add({\n\t\t\tname: \"go\",\n\t\t\tlabel: localize(\"go\", \"Go problems\"),\n\t\t\towner: \"go\",\n\t\t\tsource: \"go\",\n\t\t\tapplyTo: ApplyToKind.allDocuments,\n\t\t\tfileLocation: FileLocationKind.Relative,\n\t\t\tfilePrefix: \"${workspaceFolder}\",\n\t\t\tpattern: ProblemPatternRegistry.get(\"go\"),\n\t\t});\n\t}\n}\n\nexport const ProblemMatcherRegistry: IProblemMatcherRegistry =\n\tnew ProblemMatcherRegistryImpl();\n"],
  "mappings": "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",
  "names": ["FileLocationKind", "ProblemLocationKind", "ApplyToKind", "Config", "CheckedProblemPattern", "NamedProblemPattern", "NamedCheckedProblemPattern", "MultiLineProblemPattern", "MultiLineCheckedProblemPattern", "NamedMultiLineCheckedProblemPattern", "isNamedProblemMatcher", "result", "value", "Schemas", "kind", "matcher"]
}
