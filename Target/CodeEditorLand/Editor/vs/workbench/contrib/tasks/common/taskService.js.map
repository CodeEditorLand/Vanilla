{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/tasks/common/taskService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { Action } from \"../../../../base/common/actions.js\";\nimport type { Event } from \"../../../../base/common/event.js\";\nimport type { IDisposable } from \"../../../../base/common/lifecycle.js\";\nimport * as nls from \"../../../../nls.js\";\nimport { createDecorator } from \"../../../../platform/instantiation/common/instantiation.js\";\n\nimport type { IStringDictionary } from \"../../../../base/common/collections.js\";\nimport {\n\tContextKeyExpr,\n\tRawContextKey,\n} from \"../../../../platform/contextkey/common/contextkey.js\";\nimport type {\n\tIWorkspace,\n\tIWorkspaceFolder,\n} from \"../../../../platform/workspace/common/workspace.js\";\nimport type {\n\tITaskSummary,\n\tITaskSystemInfo,\n\tITaskTerminateResponse,\n} from \"./taskSystem.js\";\nimport type {\n\tConfiguringTask,\n\tContributedTask,\n\tCustomTask,\n\tITaskEvent,\n\tITaskIdentifier,\n\tITaskSet,\n\tTask,\n\tTaskRunSource,\n\tTaskSorter,\n} from \"./tasks.js\";\n\nexport type {\n\tITaskSummary,\n\tTask,\n\tITaskTerminateResponse as TaskTerminateResponse,\n};\n\nexport const CustomExecutionSupportedContext = new RawContextKey<boolean>(\n\t\"customExecutionSupported\",\n\tfalse,\n\tnls.localize(\n\t\t\"tasks.customExecutionSupported\",\n\t\t\"Whether CustomExecution tasks are supported. Consider using in the when clause of a 'taskDefinition' contribution.\",\n\t),\n);\nexport const ShellExecutionSupportedContext = new RawContextKey<boolean>(\n\t\"shellExecutionSupported\",\n\tfalse,\n\tnls.localize(\n\t\t\"tasks.shellExecutionSupported\",\n\t\t\"Whether ShellExecution tasks are supported. Consider using in the when clause of a 'taskDefinition' contribution.\",\n\t),\n);\nexport const TaskCommandsRegistered = new RawContextKey<boolean>(\n\t\"taskCommandsRegistered\",\n\tfalse,\n\tnls.localize(\n\t\t\"tasks.taskCommandsRegistered\",\n\t\t\"Whether the task commands have been registered yet\",\n\t),\n);\nexport const ProcessExecutionSupportedContext = new RawContextKey<boolean>(\n\t\"processExecutionSupported\",\n\tfalse,\n\tnls.localize(\n\t\t\"tasks.processExecutionSupported\",\n\t\t\"Whether ProcessExecution tasks are supported. Consider using in the when clause of a 'taskDefinition' contribution.\",\n\t),\n);\nexport const ServerlessWebContext = new RawContextKey<boolean>(\n\t\"serverlessWebContext\",\n\tfalse,\n\tnls.localize(\n\t\t\"tasks.serverlessWebContext\",\n\t\t\"True when in the web with no remote authority.\",\n\t),\n);\nexport const TaskExecutionSupportedContext = ContextKeyExpr.or(\n\tContextKeyExpr.and(\n\t\tShellExecutionSupportedContext,\n\t\tProcessExecutionSupportedContext,\n\t),\n\tCustomExecutionSupportedContext,\n);\n\nexport const ITaskService = createDecorator<ITaskService>(\"taskService\");\n\nexport interface ITaskProvider {\n\tprovideTasks(validTypes: IStringDictionary<boolean>): Promise<ITaskSet>;\n\tresolveTask(task: ConfiguringTask): Promise<ContributedTask | undefined>;\n}\n\nexport interface IProblemMatcherRunOptions {\n\tattachProblemMatcher?: boolean;\n}\n\nexport interface ICustomizationProperties {\n\tgroup?: string | { kind?: string; isDefault?: boolean };\n\tproblemMatcher?: string | string[];\n\tisBackground?: boolean;\n\tcolor?: string;\n\ticon?: string;\n}\n\nexport interface ITaskFilter {\n\tversion?: string;\n\ttype?: string;\n\ttask?: string;\n}\n\ninterface IWorkspaceTaskResult {\n\tset: ITaskSet | undefined;\n\tconfigurations:\n\t\t| {\n\t\t\t\tbyIdentifier: IStringDictionary<ConfiguringTask>;\n\t\t  }\n\t\t| undefined;\n\thasErrors: boolean;\n}\n\nexport interface IWorkspaceFolderTaskResult extends IWorkspaceTaskResult {\n\tworkspaceFolder: IWorkspaceFolder;\n}\n\nexport interface ITaskService {\n\treadonly _serviceBrand: undefined;\n\tonDidStateChange: Event<ITaskEvent>;\n\t/** Fired when task providers are registered or unregistered */\n\tonDidChangeTaskProviders: Event<void>;\n\tisReconnected: boolean;\n\tonDidReconnectToTasks: Event<void>;\n\tsupportsMultipleTaskExecutions: boolean;\n\n\tconfigureAction(): Action;\n\trun(\n\t\ttask: Task | undefined,\n\t\toptions?: IProblemMatcherRunOptions,\n\t): Promise<ITaskSummary | undefined>;\n\tinTerminal(): boolean;\n\tgetActiveTasks(): Promise<Task[]>;\n\tgetBusyTasks(): Promise<Task[]>;\n\tterminate(task: Task): Promise<ITaskTerminateResponse>;\n\ttasks(filter?: ITaskFilter): Promise<Task[]>;\n\t/**\n\t * Gets tasks currently known to the task system. Unlike {@link tasks},\n\t * this does not activate extensions or prompt for workspace trust.\n\t */\n\tgetKnownTasks(filter?: ITaskFilter): Promise<Task[]>;\n\ttaskTypes(): string[];\n\tgetWorkspaceTasks(\n\t\trunSource?: TaskRunSource,\n\t): Promise<Map<string, IWorkspaceFolderTaskResult>>;\n\tgetSavedTasks(\n\t\ttype: \"persistent\" | \"historical\",\n\t): Promise<(Task | ConfiguringTask)[]>;\n\tremoveRecentlyUsedTask(taskRecentlyUsedKey: string): void;\n\t/**\n\t * @param alias The task's name, label or defined identifier.\n\t */\n\tgetTask(\n\t\tworkspaceFolder: IWorkspace | IWorkspaceFolder | string,\n\t\talias: string | ITaskIdentifier,\n\t\tcompareId?: boolean,\n\t): Promise<Task | undefined>;\n\ttryResolveTask(configuringTask: ConfiguringTask): Promise<Task | undefined>;\n\tcreateSorter(): TaskSorter;\n\n\tgetTaskDescription(task: Task | ConfiguringTask): string | undefined;\n\tcustomize(\n\t\ttask: ContributedTask | CustomTask | ConfiguringTask,\n\t\tproperties?: {},\n\t\topenConfig?: boolean,\n\t): Promise<void>;\n\topenConfig(\n\t\ttask: CustomTask | ConfiguringTask | undefined,\n\t): Promise<boolean>;\n\n\tregisterTaskProvider(\n\t\ttaskProvider: ITaskProvider,\n\t\ttype: string,\n\t): IDisposable;\n\n\tregisterTaskSystem(scheme: string, taskSystemInfo: ITaskSystemInfo): void;\n\tonDidChangeTaskSystemInfo: Event<void>;\n\tonDidChangeTaskConfig: Event<void>;\n\treadonly hasTaskSystemInfo: boolean;\n\tregisterSupportedExecutions(\n\t\tcustom?: boolean,\n\t\tshell?: boolean,\n\t\tprocess?: boolean,\n\t): void;\n\n\textensionCallbackTaskComplete(\n\t\ttask: Task,\n\t\tresult: number | undefined,\n\t): Promise<void>;\n}\n"],
  "mappings": "AAQA,YAAY,SAAS;AACrB,SAAS,uBAAuB;AAGhC;AAAA,EACC;AAAA,EACA;AAAA,OACM;AA4BA,MAAM,kCAAkC,IAAI;AAAA,EAClD;AAAA,EACA;AAAA,EACA,IAAI;AAAA,IACH;AAAA,IACA;AAAA,EACD;AACD;AACO,MAAM,iCAAiC,IAAI;AAAA,EACjD;AAAA,EACA;AAAA,EACA,IAAI;AAAA,IACH;AAAA,IACA;AAAA,EACD;AACD;AACO,MAAM,yBAAyB,IAAI;AAAA,EACzC;AAAA,EACA;AAAA,EACA,IAAI;AAAA,IACH;AAAA,IACA;AAAA,EACD;AACD;AACO,MAAM,mCAAmC,IAAI;AAAA,EACnD;AAAA,EACA;AAAA,EACA,IAAI;AAAA,IACH;AAAA,IACA;AAAA,EACD;AACD;AACO,MAAM,uBAAuB,IAAI;AAAA,EACvC;AAAA,EACA;AAAA,EACA,IAAI;AAAA,IACH;AAAA,IACA;AAAA,EACD;AACD;AACO,MAAM,gCAAgC,eAAe;AAAA,EAC3D,eAAe;AAAA,IACd;AAAA,IACA;AAAA,EACD;AAAA,EACA;AACD;AAEO,MAAM,eAAe,gBAA8B,aAAa;",
  "names": []
}
