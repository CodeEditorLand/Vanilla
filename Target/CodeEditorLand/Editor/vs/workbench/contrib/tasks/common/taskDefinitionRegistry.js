import*as f from"../../../../base/common/objects.js";import*as d from"../../../../base/common/types.js";import*as a from"../../../../nls.js";import{ExtensionsRegistry as h}from"../../../services/extensions/common/extensionsRegistry.js";import{Emitter as y}from"../../../../base/common/event.js";import{ContextKeyExpr as k}from"../../../../platform/contextkey/common/contextkey.js";const u={type:"object",additionalProperties:!1,properties:{type:{type:"string",description:a.localize("TaskDefinition.description","The actual task type. Please note that types starting with a '$' are reserved for internal usage.")},required:{type:"array",items:{type:"string"}},properties:{type:"object",description:a.localize("TaskDefinition.properties","Additional properties of the task type"),additionalProperties:{$ref:"http://json-schema.org/draft-07/schema#"}},when:{type:"string",markdownDescription:a.localize("TaskDefinition.when","Condition which must be true to enable this type of task. Consider using `shellExecutionSupported`, `processExecutionSupported`, and `customExecutionSupported` as appropriate for this task definition. See the [API documentation](https://code.visualstudio.com/api/extension-guides/task-provider#when-clause) for more information."),default:""}}};var m;(i=>{function p(e,s,o){if(!e)return;const t=d.isString(e.type)?e.type:void 0;if(!t||t.length===0){o.error(a.localize("TaskTypeConfiguration.noType","The task type configuration is missing the required 'taskType' property"));return}const r=[];if(Array.isArray(e.required))for(const n of e.required)d.isString(n)&&r.push(n);return{extensionId:s.value,taskType:t,required:r,properties:e.properties?f.deepClone(e.properties):{},when:e.when?k.deserialize(e.when):void 0}}i.from=p})(m||={});const l=h.registerExtensionPoint({extensionPoint:"taskDefinitions",activationEventsGenerator:(p,i)=>{for(const e of p)e.type&&i.push(`onTaskType:${e.type}`)},jsonSchema:{description:a.localize("TaskDefinitionExtPoint","Contributes task kinds"),type:"array",items:u}});class T{taskTypes;readyPromise;_schema;_onDefinitionsChanged=new y;onDefinitionsChanged=this._onDefinitionsChanged.event;constructor(){this.taskTypes=Object.create(null),this.readyPromise=new Promise((i,e)=>{l.setHandler((s,o)=>{this._schema=void 0;try{for(const t of o.removed){const r=t.value;for(const n of r)this.taskTypes&&n.type&&this.taskTypes[n.type]&&delete this.taskTypes[n.type]}for(const t of o.added){const r=t.value;for(const n of r){const c=m.from(n,t.description.identifier,t.collector);c&&(this.taskTypes[c.taskType]=c)}}(o.removed.length>0||o.added.length>0)&&this._onDefinitionsChanged.fire()}catch{}i(void 0)})})}onReady(){return this.readyPromise}get(i){return this.taskTypes[i]}all(){return Object.keys(this.taskTypes).map(i=>this.taskTypes[i])}getJsonSchema(){if(this._schema===void 0){const i=[];for(const e of this.all()){const s={type:"object",additionalProperties:!1};e.required.length>0&&(s.required=e.required.slice(0)),e.properties!==void 0?s.properties=f.deepClone(e.properties):s.properties=Object.create(null),s.properties.type={type:"string",enum:[e.taskType]},i.push(s)}this._schema={oneOf:i}}return this._schema}}const I=new T;export{I as TaskDefinitionRegistry};
