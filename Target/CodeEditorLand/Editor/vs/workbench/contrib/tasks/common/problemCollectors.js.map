{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/tasks/common/problemCollectors.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type {\n\tINumberDictionary,\n\tIStringDictionary,\n} from \"../../../../base/common/collections.js\";\nimport { Emitter, Event } from \"../../../../base/common/event.js\";\nimport {\n\tDisposable,\n\tDisposableStore,\n\ttype IDisposable,\n} from \"../../../../base/common/lifecycle.js\";\nimport { URI } from \"../../../../base/common/uri.js\";\n\nimport type { IModelService } from \"../../../../editor/common/services/model.js\";\n\nimport { isWindows } from \"../../../../base/common/platform.js\";\nimport { generateUuid } from \"../../../../base/common/uuid.js\";\nimport type { IFileService } from \"../../../../platform/files/common/files.js\";\nimport {\n\tIMarkerData,\n\ttype IMarkerService,\n\ttype MarkerSeverity,\n} from \"../../../../platform/markers/common/markers.js\";\nimport {\n\tApplyToKind,\n\ttype ILineMatcher,\n\ttype IProblemMatch,\n\ttype IWatchingPattern,\n\ttype ProblemMatcher,\n\tcreateLineMatcher,\n\tgetResource,\n} from \"./problemMatcher.js\";\n\nexport enum ProblemCollectorEventKind {\n\tBackgroundProcessingBegins = \"backgroundProcessingBegins\",\n\tBackgroundProcessingEnds = \"backgroundProcessingEnds\",\n}\n\nexport interface IProblemCollectorEvent {\n\tkind: ProblemCollectorEventKind;\n}\n\nnamespace IProblemCollectorEvent {\n\texport function create(kind: ProblemCollectorEventKind) {\n\t\treturn Object.freeze({ kind });\n\t}\n}\n\nexport interface IProblemMatcher {\n\tprocessLine(line: string): void;\n}\n\nexport abstract class AbstractProblemCollector\n\textends Disposable\n\timplements IDisposable\n{\n\tprivate matchers: INumberDictionary<ILineMatcher[]>;\n\tprivate activeMatcher: ILineMatcher | null;\n\tprotected _numberOfMatches: number;\n\tprivate _maxMarkerSeverity?: MarkerSeverity;\n\tprivate buffer: string[];\n\tprivate bufferLength: number;\n\tprivate openModels: IStringDictionary<boolean>;\n\tprotected readonly modelListeners = new DisposableStore();\n\tprivate tail: Promise<void> | undefined;\n\n\t// [owner] -> ApplyToKind\n\tprotected applyToByOwner: Map<string, ApplyToKind>;\n\t// [owner] -> [resource] -> URI\n\tprivate resourcesToClean: Map<string, Map<string, URI>>;\n\t// [owner] -> [resource] -> [markerkey] -> markerData\n\tprivate markers: Map<string, Map<string, Map<string, IMarkerData>>>;\n\t// [owner] -> [resource] -> number;\n\tprivate deliveredMarkers: Map<string, Map<string, number>>;\n\n\tprotected _onDidStateChange: Emitter<IProblemCollectorEvent>;\n\n\tprotected readonly _onDidFindFirstMatch = new Emitter<void>();\n\treadonly onDidFindFirstMatch = this._onDidFindFirstMatch.event;\n\n\tprotected readonly _onDidFindErrors = new Emitter<void>();\n\treadonly onDidFindErrors = this._onDidFindErrors.event;\n\n\tprotected readonly _onDidRequestInvalidateLastMarker = new Emitter<void>();\n\treadonly onDidRequestInvalidateLastMarker =\n\t\tthis._onDidRequestInvalidateLastMarker.event;\n\n\tconstructor(\n\t\tpublic readonly problemMatchers: ProblemMatcher[],\n\t\tprotected markerService: IMarkerService,\n\t\tprotected modelService: IModelService,\n\t\tfileService?: IFileService,\n\t) {\n\t\tsuper();\n\t\tthis.matchers = Object.create(null);\n\t\tthis.bufferLength = 1;\n\t\tproblemMatchers\n\t\t\t.map((elem) => createLineMatcher(elem, fileService))\n\t\t\t.forEach((matcher) => {\n\t\t\t\tconst length = matcher.matchLength;\n\t\t\t\tif (length > this.bufferLength) {\n\t\t\t\t\tthis.bufferLength = length;\n\t\t\t\t}\n\t\t\t\tlet value = this.matchers[length];\n\t\t\t\tif (!value) {\n\t\t\t\t\tvalue = [];\n\t\t\t\t\tthis.matchers[length] = value;\n\t\t\t\t}\n\t\t\t\tvalue.push(matcher);\n\t\t\t});\n\t\tthis.buffer = [];\n\t\tthis.activeMatcher = null;\n\t\tthis._numberOfMatches = 0;\n\t\tthis._maxMarkerSeverity = undefined;\n\t\tthis.openModels = Object.create(null);\n\t\tthis.applyToByOwner = new Map<string, ApplyToKind>();\n\t\tfor (const problemMatcher of problemMatchers) {\n\t\t\tconst current = this.applyToByOwner.get(problemMatcher.owner);\n\t\t\tif (current === undefined) {\n\t\t\t\tthis.applyToByOwner.set(\n\t\t\t\t\tproblemMatcher.owner,\n\t\t\t\t\tproblemMatcher.applyTo,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthis.applyToByOwner.set(\n\t\t\t\t\tproblemMatcher.owner,\n\t\t\t\t\tthis.mergeApplyTo(current, problemMatcher.applyTo),\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tthis.resourcesToClean = new Map<string, Map<string, URI>>();\n\t\tthis.markers = new Map<string, Map<string, Map<string, IMarkerData>>>();\n\t\tthis.deliveredMarkers = new Map<string, Map<string, number>>();\n\t\tthis._register(\n\t\t\tthis.modelService.onModelAdded(\n\t\t\t\t(model) => {\n\t\t\t\t\tthis.openModels[model.uri.toString()] = true;\n\t\t\t\t},\n\t\t\t\tthis,\n\t\t\t\tthis.modelListeners,\n\t\t\t),\n\t\t);\n\t\tthis._register(\n\t\t\tthis.modelService.onModelRemoved(\n\t\t\t\t(model) => {\n\t\t\t\t\tdelete this.openModels[model.uri.toString()];\n\t\t\t\t},\n\t\t\t\tthis,\n\t\t\t\tthis.modelListeners,\n\t\t\t),\n\t\t);\n\t\tthis.modelService\n\t\t\t.getModels()\n\t\t\t.forEach((model) => (this.openModels[model.uri.toString()] = true));\n\n\t\tthis._onDidStateChange = new Emitter();\n\t}\n\n\tpublic get onDidStateChange(): Event<IProblemCollectorEvent> {\n\t\treturn this._onDidStateChange.event;\n\t}\n\n\tpublic processLine(line: string) {\n\t\tif (this.tail) {\n\t\t\tconst oldTail = this.tail;\n\t\t\tthis.tail = oldTail.then(() => {\n\t\t\t\treturn this.processLineInternal(line);\n\t\t\t});\n\t\t} else {\n\t\t\tthis.tail = this.processLineInternal(line);\n\t\t}\n\t}\n\n\tprotected abstract processLineInternal(line: string): Promise<void>;\n\n\tpublic override dispose() {\n\t\tsuper.dispose();\n\t\tthis.modelListeners.dispose();\n\t}\n\n\tpublic get numberOfMatches(): number {\n\t\treturn this._numberOfMatches;\n\t}\n\n\tpublic get maxMarkerSeverity(): MarkerSeverity | undefined {\n\t\treturn this._maxMarkerSeverity;\n\t}\n\n\tprotected tryFindMarker(line: string): IProblemMatch | null {\n\t\tlet result: IProblemMatch | null = null;\n\t\tif (this.activeMatcher) {\n\t\t\tresult = this.activeMatcher.next(line);\n\t\t\tif (result) {\n\t\t\t\tthis.captureMatch(result);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tthis.clearBuffer();\n\t\t\tthis.activeMatcher = null;\n\t\t}\n\t\tif (this.buffer.length < this.bufferLength) {\n\t\t\tthis.buffer.push(line);\n\t\t} else {\n\t\t\tconst end = this.buffer.length - 1;\n\t\t\tfor (let i = 0; i < end; i++) {\n\t\t\t\tthis.buffer[i] = this.buffer[i + 1];\n\t\t\t}\n\t\t\tthis.buffer[end] = line;\n\t\t}\n\n\t\tresult = this.tryMatchers();\n\t\tif (result) {\n\t\t\tthis.clearBuffer();\n\t\t}\n\t\treturn result;\n\t}\n\n\tprotected async shouldApplyMatch(result: IProblemMatch): Promise<boolean> {\n\t\tswitch (result.description.applyTo) {\n\t\t\tcase ApplyToKind.allDocuments:\n\t\t\t\treturn true;\n\t\t\tcase ApplyToKind.openDocuments:\n\t\t\t\treturn !!this.openModels[(await result.resource).toString()];\n\t\t\tcase ApplyToKind.closedDocuments:\n\t\t\t\treturn !this.openModels[(await result.resource).toString()];\n\t\t\tdefault:\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate mergeApplyTo(\n\t\tcurrent: ApplyToKind,\n\t\tvalue: ApplyToKind,\n\t): ApplyToKind {\n\t\tif (current === value || current === ApplyToKind.allDocuments) {\n\t\t\treturn current;\n\t\t}\n\t\treturn ApplyToKind.allDocuments;\n\t}\n\n\tprivate tryMatchers(): IProblemMatch | null {\n\t\tthis.activeMatcher = null;\n\t\tconst length = this.buffer.length;\n\t\tfor (let startIndex = 0; startIndex < length; startIndex++) {\n\t\t\tconst candidates = this.matchers[length - startIndex];\n\t\t\tif (!candidates) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (const matcher of candidates) {\n\t\t\t\tconst result = matcher.handle(this.buffer, startIndex);\n\t\t\t\tif (result.match) {\n\t\t\t\t\tthis.captureMatch(result.match);\n\t\t\t\t\tif (result.continue) {\n\t\t\t\t\t\tthis.activeMatcher = matcher;\n\t\t\t\t\t}\n\t\t\t\t\treturn result.match;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate captureMatch(match: IProblemMatch): void {\n\t\tthis._numberOfMatches++;\n\t\tif (\n\t\t\tthis._maxMarkerSeverity === undefined ||\n\t\t\tmatch.marker.severity > this._maxMarkerSeverity\n\t\t) {\n\t\t\tthis._maxMarkerSeverity = match.marker.severity;\n\t\t}\n\t}\n\n\tprivate clearBuffer(): void {\n\t\tif (this.buffer.length > 0) {\n\t\t\tthis.buffer = [];\n\t\t}\n\t}\n\n\tprotected recordResourcesToClean(owner: string): void {\n\t\tconst resourceSetToClean = this.getResourceSetToClean(owner);\n\t\tthis.markerService\n\t\t\t.read({ owner: owner })\n\t\t\t.forEach((marker) =>\n\t\t\t\tresourceSetToClean.set(\n\t\t\t\t\tmarker.resource.toString(),\n\t\t\t\t\tmarker.resource,\n\t\t\t\t),\n\t\t\t);\n\t}\n\n\tprotected recordResourceToClean(owner: string, resource: URI): void {\n\t\tthis.getResourceSetToClean(owner).set(resource.toString(), resource);\n\t}\n\n\tprotected removeResourceToClean(owner: string, resource: string): void {\n\t\tconst resourceSet = this.resourcesToClean.get(owner);\n\t\tresourceSet?.delete(resource);\n\t}\n\n\tprivate getResourceSetToClean(owner: string): Map<string, URI> {\n\t\tlet result = this.resourcesToClean.get(owner);\n\t\tif (!result) {\n\t\t\tresult = new Map<string, URI>();\n\t\t\tthis.resourcesToClean.set(owner, result);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprotected cleanAllMarkers(): void {\n\t\tthis.resourcesToClean.forEach((value, owner) => {\n\t\t\tthis._cleanMarkers(owner, value);\n\t\t});\n\t\tthis.resourcesToClean = new Map<string, Map<string, URI>>();\n\t}\n\n\tprotected cleanMarkers(owner: string): void {\n\t\tconst toClean = this.resourcesToClean.get(owner);\n\t\tif (toClean) {\n\t\t\tthis._cleanMarkers(owner, toClean);\n\t\t\tthis.resourcesToClean.delete(owner);\n\t\t}\n\t}\n\n\tprivate _cleanMarkers(owner: string, toClean: Map<string, URI>): void {\n\t\tconst uris: URI[] = [];\n\t\tconst applyTo = this.applyToByOwner.get(owner);\n\t\ttoClean.forEach((uri, uriAsString) => {\n\t\t\tif (\n\t\t\t\tapplyTo === ApplyToKind.allDocuments ||\n\t\t\t\t(applyTo === ApplyToKind.openDocuments &&\n\t\t\t\t\tthis.openModels[uriAsString]) ||\n\t\t\t\t(applyTo === ApplyToKind.closedDocuments &&\n\t\t\t\t\t!this.openModels[uriAsString])\n\t\t\t) {\n\t\t\t\turis.push(uri);\n\t\t\t}\n\t\t});\n\t\tthis.markerService.remove(owner, uris);\n\t}\n\n\tprotected recordMarker(\n\t\tmarker: IMarkerData,\n\t\towner: string,\n\t\tresourceAsString: string,\n\t): void {\n\t\tlet markersPerOwner = this.markers.get(owner);\n\t\tif (!markersPerOwner) {\n\t\t\tmarkersPerOwner = new Map<string, Map<string, IMarkerData>>();\n\t\t\tthis.markers.set(owner, markersPerOwner);\n\t\t}\n\t\tlet markersPerResource = markersPerOwner.get(resourceAsString);\n\t\tif (!markersPerResource) {\n\t\t\tmarkersPerResource = new Map<string, IMarkerData>();\n\t\t\tmarkersPerOwner.set(resourceAsString, markersPerResource);\n\t\t}\n\t\tconst key = IMarkerData.makeKeyOptionalMessage(marker, false);\n\t\tlet existingMarker;\n\t\tif (!markersPerResource.has(key)) {\n\t\t\tmarkersPerResource.set(key, marker);\n\t\t} else if (\n\t\t\t(existingMarker = markersPerResource.get(key)) !== undefined &&\n\t\t\texistingMarker.message.length < marker.message.length &&\n\t\t\tisWindows\n\t\t) {\n\t\t\t// Most likely https://github.com/microsoft/vscode/issues/77475\n\t\t\t// Heuristic dictates that when the key is the same and message is smaller, we have hit this limitation.\n\t\t\tmarkersPerResource.set(key, marker);\n\t\t}\n\t}\n\n\tprotected reportMarkers(): void {\n\t\tthis.markers.forEach((markersPerOwner, owner) => {\n\t\t\tconst deliveredMarkersPerOwner =\n\t\t\t\tthis.getDeliveredMarkersPerOwner(owner);\n\t\t\tmarkersPerOwner.forEach((markers, resource) => {\n\t\t\t\tthis.deliverMarkersPerOwnerAndResourceResolved(\n\t\t\t\t\towner,\n\t\t\t\t\tresource,\n\t\t\t\t\tmarkers,\n\t\t\t\t\tdeliveredMarkersPerOwner,\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\t}\n\n\tprotected deliverMarkersPerOwnerAndResource(\n\t\towner: string,\n\t\tresource: string,\n\t): void {\n\t\tconst markersPerOwner = this.markers.get(owner);\n\t\tif (!markersPerOwner) {\n\t\t\treturn;\n\t\t}\n\t\tconst deliveredMarkersPerOwner =\n\t\t\tthis.getDeliveredMarkersPerOwner(owner);\n\t\tconst markersPerResource = markersPerOwner.get(resource);\n\t\tif (!markersPerResource) {\n\t\t\treturn;\n\t\t}\n\t\tthis.deliverMarkersPerOwnerAndResourceResolved(\n\t\t\towner,\n\t\t\tresource,\n\t\t\tmarkersPerResource,\n\t\t\tdeliveredMarkersPerOwner,\n\t\t);\n\t}\n\n\tprivate deliverMarkersPerOwnerAndResourceResolved(\n\t\towner: string,\n\t\tresource: string,\n\t\tmarkers: Map<string, IMarkerData>,\n\t\treported: Map<string, number>,\n\t): void {\n\t\tif (markers.size !== reported.get(resource)) {\n\t\t\tconst toSet: IMarkerData[] = [];\n\t\t\tmarkers.forEach((value) => toSet.push(value));\n\t\t\tthis.markerService.changeOne(owner, URI.parse(resource), toSet);\n\t\t\treported.set(resource, markers.size);\n\t\t}\n\t}\n\n\tprivate getDeliveredMarkersPerOwner(owner: string): Map<string, number> {\n\t\tlet result = this.deliveredMarkers.get(owner);\n\t\tif (!result) {\n\t\t\tresult = new Map<string, number>();\n\t\t\tthis.deliveredMarkers.set(owner, result);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprotected cleanMarkerCaches(): void {\n\t\tthis._numberOfMatches = 0;\n\t\tthis._maxMarkerSeverity = undefined;\n\t\tthis.markers.clear();\n\t\tthis.deliveredMarkers.clear();\n\t}\n\n\tpublic done(): void {\n\t\tthis.reportMarkers();\n\t\tthis.cleanAllMarkers();\n\t}\n}\n\nexport enum ProblemHandlingStrategy {\n\tClean = 0,\n}\n\nexport class StartStopProblemCollector\n\textends AbstractProblemCollector\n\timplements IProblemMatcher\n{\n\tprivate owners: string[];\n\n\tprivate currentOwner: string | undefined;\n\tprivate currentResource: string | undefined;\n\n\tconstructor(\n\t\tproblemMatchers: ProblemMatcher[],\n\t\tmarkerService: IMarkerService,\n\t\tmodelService: IModelService,\n\t\t_strategy: ProblemHandlingStrategy = ProblemHandlingStrategy.Clean,\n\t\tfileService?: IFileService,\n\t) {\n\t\tsuper(problemMatchers, markerService, modelService, fileService);\n\t\tconst ownerSet: { [key: string]: boolean } = Object.create(null);\n\t\tproblemMatchers.forEach(\n\t\t\t(description) => (ownerSet[description.owner] = true),\n\t\t);\n\t\tthis.owners = Object.keys(ownerSet);\n\t\tthis.owners.forEach((owner) => {\n\t\t\tthis.recordResourcesToClean(owner);\n\t\t});\n\t}\n\n\tprotected async processLineInternal(line: string): Promise<void> {\n\t\tconst markerMatch = this.tryFindMarker(line);\n\t\tif (!markerMatch) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst owner = markerMatch.description.owner;\n\t\tconst resource = await markerMatch.resource;\n\t\tconst resourceAsString = resource.toString();\n\t\tthis.removeResourceToClean(owner, resourceAsString);\n\t\tconst shouldApplyMatch = await this.shouldApplyMatch(markerMatch);\n\t\tif (shouldApplyMatch) {\n\t\t\tthis.recordMarker(markerMatch.marker, owner, resourceAsString);\n\t\t\tif (\n\t\t\t\tthis.currentOwner !== owner ||\n\t\t\t\tthis.currentResource !== resourceAsString\n\t\t\t) {\n\t\t\t\tif (this.currentOwner && this.currentResource) {\n\t\t\t\t\tthis.deliverMarkersPerOwnerAndResource(\n\t\t\t\t\t\tthis.currentOwner,\n\t\t\t\t\t\tthis.currentResource,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tthis.currentOwner = owner;\n\t\t\t\tthis.currentResource = resourceAsString;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninterface IBackgroundPatterns {\n\tkey: string;\n\tmatcher: ProblemMatcher;\n\tbegin: IWatchingPattern;\n\tend: IWatchingPattern;\n}\n\nexport class WatchingProblemCollector\n\textends AbstractProblemCollector\n\timplements IProblemMatcher\n{\n\tprivate backgroundPatterns: IBackgroundPatterns[];\n\n\t// workaround for https://github.com/microsoft/vscode/issues/44018\n\tprivate _activeBackgroundMatchers: Set<string>;\n\n\t// Current State\n\tprivate currentOwner: string | undefined;\n\tprivate currentResource: string | undefined;\n\n\tprivate lines: string[] = [];\n\tpublic beginPatterns: RegExp[] = [];\n\tconstructor(\n\t\tproblemMatchers: ProblemMatcher[],\n\t\tmarkerService: IMarkerService,\n\t\tmodelService: IModelService,\n\t\tfileService?: IFileService,\n\t) {\n\t\tsuper(problemMatchers, markerService, modelService, fileService);\n\t\tthis.resetCurrentResource();\n\t\tthis.backgroundPatterns = [];\n\t\tthis._activeBackgroundMatchers = new Set<string>();\n\t\tthis.problemMatchers.forEach((matcher) => {\n\t\t\tif (matcher.watching) {\n\t\t\t\tconst key: string = generateUuid();\n\t\t\t\tthis.backgroundPatterns.push({\n\t\t\t\t\tkey,\n\t\t\t\t\tmatcher: matcher,\n\t\t\t\t\tbegin: matcher.watching.beginsPattern,\n\t\t\t\t\tend: matcher.watching.endsPattern,\n\t\t\t\t});\n\t\t\t\tthis.beginPatterns.push(matcher.watching.beginsPattern.regexp);\n\t\t\t}\n\t\t});\n\n\t\tthis.modelListeners.add(\n\t\t\tthis.modelService.onModelRemoved((modelEvent) => {\n\t\t\t\tlet markerChanged: IDisposable | undefined = Event.debounce(\n\t\t\t\t\tthis.markerService.onMarkerChanged,\n\t\t\t\t\t(last: readonly URI[] | undefined, e: readonly URI[]) => {\n\t\t\t\t\t\treturn (last ?? []).concat(e);\n\t\t\t\t\t},\n\t\t\t\t\t500,\n\t\t\t\t\tfalse,\n\t\t\t\t\ttrue,\n\t\t\t\t)(async (markerEvent) => {\n\t\t\t\t\tmarkerChanged?.dispose();\n\t\t\t\t\tmarkerChanged = undefined;\n\t\t\t\t\tif (\n\t\t\t\t\t\t!markerEvent ||\n\t\t\t\t\t\t!markerEvent.includes(modelEvent.uri) ||\n\t\t\t\t\t\tthis.markerService.read({ resource: modelEvent.uri })\n\t\t\t\t\t\t\t.length !== 0\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tconst oldLines = Array.from(this.lines);\n\t\t\t\t\tfor (const line of oldLines) {\n\t\t\t\t\t\tawait this.processLineInternal(line);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tsetTimeout(async () => {\n\t\t\t\t\t// Calling dispose below can trigger the debounce event (via flushOnListenerRemove), so we\n\t\t\t\t\t// have to unset markerChanged first to make sure the handler above doesn't dispose it again.\n\t\t\t\t\tconst _markerChanged = markerChanged;\n\t\t\t\t\tmarkerChanged = undefined;\n\t\t\t\t\t_markerChanged?.dispose();\n\t\t\t\t}, 600);\n\t\t\t}),\n\t\t);\n\t}\n\n\tpublic aboutToStart(): void {\n\t\tfor (const background of this.backgroundPatterns) {\n\t\t\tif (\n\t\t\t\tbackground.matcher.watching &&\n\t\t\t\tbackground.matcher.watching.activeOnStart\n\t\t\t) {\n\t\t\t\tthis._activeBackgroundMatchers.add(background.key);\n\t\t\t\tthis._onDidStateChange.fire(\n\t\t\t\t\tIProblemCollectorEvent.create(\n\t\t\t\t\t\tProblemCollectorEventKind.BackgroundProcessingBegins,\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t\tthis.recordResourcesToClean(background.matcher.owner);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected async processLineInternal(line: string): Promise<void> {\n\t\tif ((await this.tryBegin(line)) || this.tryFinish(line)) {\n\t\t\treturn;\n\t\t}\n\t\tthis.lines.push(line);\n\t\tconst markerMatch = this.tryFindMarker(line);\n\t\tif (!markerMatch) {\n\t\t\treturn;\n\t\t}\n\t\tconst resource = await markerMatch.resource;\n\t\tconst owner = markerMatch.description.owner;\n\t\tconst resourceAsString = resource.toString();\n\t\tthis.removeResourceToClean(owner, resourceAsString);\n\t\tconst shouldApplyMatch = await this.shouldApplyMatch(markerMatch);\n\t\tif (shouldApplyMatch) {\n\t\t\tthis.recordMarker(markerMatch.marker, owner, resourceAsString);\n\t\t\tif (\n\t\t\t\tthis.currentOwner !== owner ||\n\t\t\t\tthis.currentResource !== resourceAsString\n\t\t\t) {\n\t\t\t\tthis.reportMarkersForCurrentResource();\n\t\t\t\tthis.currentOwner = owner;\n\t\t\t\tthis.currentResource = resourceAsString;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic forceDelivery(): void {\n\t\tthis.reportMarkersForCurrentResource();\n\t}\n\n\tprivate async tryBegin(line: string): Promise<boolean> {\n\t\tlet result = false;\n\t\tfor (const background of this.backgroundPatterns) {\n\t\t\tconst matches = background.begin.regexp.exec(line);\n\t\t\tif (matches) {\n\t\t\t\tif (this._activeBackgroundMatchers.has(background.key)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tthis._activeBackgroundMatchers.add(background.key);\n\t\t\t\tresult = true;\n\t\t\t\tthis._onDidFindFirstMatch.fire();\n\t\t\t\tthis.lines = [];\n\t\t\t\tthis.lines.push(line);\n\t\t\t\tthis._onDidStateChange.fire(\n\t\t\t\t\tIProblemCollectorEvent.create(\n\t\t\t\t\t\tProblemCollectorEventKind.BackgroundProcessingBegins,\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t\tthis.cleanMarkerCaches();\n\t\t\t\tthis.resetCurrentResource();\n\t\t\t\tconst owner = background.matcher.owner;\n\t\t\t\tconst file = matches[background.begin.file!];\n\t\t\t\tif (file) {\n\t\t\t\t\tconst resource = getResource(file, background.matcher);\n\t\t\t\t\tthis.recordResourceToClean(owner, await resource);\n\t\t\t\t} else {\n\t\t\t\t\tthis.recordResourcesToClean(owner);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate tryFinish(line: string): boolean {\n\t\tlet result = false;\n\t\tfor (const background of this.backgroundPatterns) {\n\t\t\tconst matches = background.end.regexp.exec(line);\n\t\t\tif (matches) {\n\t\t\t\tif (this._numberOfMatches > 0) {\n\t\t\t\t\tthis._onDidFindErrors.fire();\n\t\t\t\t} else {\n\t\t\t\t\tthis._onDidRequestInvalidateLastMarker.fire();\n\t\t\t\t}\n\t\t\t\tif (this._activeBackgroundMatchers.has(background.key)) {\n\t\t\t\t\tthis._activeBackgroundMatchers.delete(background.key);\n\t\t\t\t\tthis.resetCurrentResource();\n\t\t\t\t\tthis._onDidStateChange.fire(\n\t\t\t\t\t\tIProblemCollectorEvent.create(\n\t\t\t\t\t\t\tProblemCollectorEventKind.BackgroundProcessingEnds,\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t\tresult = true;\n\t\t\t\t\tthis.lines.push(line);\n\t\t\t\t\tconst owner = background.matcher.owner;\n\t\t\t\t\tthis.cleanMarkers(owner);\n\t\t\t\t\tthis.cleanMarkerCaches();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate resetCurrentResource(): void {\n\t\tthis.reportMarkersForCurrentResource();\n\t\tthis.currentOwner = undefined;\n\t\tthis.currentResource = undefined;\n\t}\n\n\tprivate reportMarkersForCurrentResource(): void {\n\t\tif (this.currentOwner && this.currentResource) {\n\t\t\tthis.deliverMarkersPerOwnerAndResource(\n\t\t\t\tthis.currentOwner,\n\t\t\t\tthis.currentResource,\n\t\t\t);\n\t\t}\n\t}\n\n\tpublic override done(): void {\n\t\t[...this.applyToByOwner.keys()].forEach((owner) => {\n\t\t\tthis.recordResourcesToClean(owner);\n\t\t});\n\t\tsuper.done();\n\t}\n\n\tpublic isWatching(): boolean {\n\t\treturn this.backgroundPatterns.length > 0;\n\t}\n}\n"],
  "mappings": "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",
  "names": ["ProblemCollectorEventKind", "IProblemCollectorEvent", "ProblemHandlingStrategy"]
}
