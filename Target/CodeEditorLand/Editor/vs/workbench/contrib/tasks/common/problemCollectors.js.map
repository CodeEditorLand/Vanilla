{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/tasks/common/problemCollectors.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IStringDictionary, INumberDictionary } from '../../../../base/common/collections.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { Event, Emitter } from '../../../../base/common/event.js';\nimport { IDisposable, DisposableStore, Disposable } from '../../../../base/common/lifecycle.js';\n\nimport { IModelService } from '../../../../editor/common/services/model.js';\n\nimport { ILineMatcher, createLineMatcher, ProblemMatcher, IProblemMatch, ApplyToKind, IWatchingPattern, getResource } from './problemMatcher.js';\nimport { IMarkerService, IMarkerData, MarkerSeverity } from '../../../../platform/markers/common/markers.js';\nimport { generateUuid } from '../../../../base/common/uuid.js';\nimport { IFileService } from '../../../../platform/files/common/files.js';\nimport { isWindows } from '../../../../base/common/platform.js';\n\nexport const enum ProblemCollectorEventKind {\n\tBackgroundProcessingBegins = 'backgroundProcessingBegins',\n\tBackgroundProcessingEnds = 'backgroundProcessingEnds'\n}\n\nexport interface IProblemCollectorEvent {\n\tkind: ProblemCollectorEventKind;\n}\n\nnamespace IProblemCollectorEvent {\n\texport function create(kind: ProblemCollectorEventKind) {\n\t\treturn Object.freeze({ kind });\n\t}\n}\n\nexport interface IProblemMatcher {\n\tprocessLine(line: string): void;\n}\n\nexport abstract class AbstractProblemCollector extends Disposable implements IDisposable {\n\n\tprivate matchers: INumberDictionary<ILineMatcher[]>;\n\tprivate activeMatcher: ILineMatcher | null;\n\tprotected _numberOfMatches: number;\n\tprivate _maxMarkerSeverity?: MarkerSeverity;\n\tprivate buffer: string[];\n\tprivate bufferLength: number;\n\tprivate openModels: IStringDictionary<boolean>;\n\tprotected readonly modelListeners = new DisposableStore();\n\tprivate tail: Promise<void> | undefined;\n\n\t// [owner] -> ApplyToKind\n\tprotected applyToByOwner: Map<string, ApplyToKind>;\n\t// [owner] -> [resource] -> URI\n\tprivate resourcesToClean: Map<string, Map<string, URI>>;\n\t// [owner] -> [resource] -> [markerkey] -> markerData\n\tprivate markers: Map<string, Map<string, Map<string, IMarkerData>>>;\n\t// [owner] -> [resource] -> number;\n\tprivate deliveredMarkers: Map<string, Map<string, number>>;\n\n\tprotected _onDidStateChange: Emitter<IProblemCollectorEvent>;\n\n\tprotected readonly _onDidFindFirstMatch = new Emitter<void>();\n\treadonly onDidFindFirstMatch = this._onDidFindFirstMatch.event;\n\n\tprotected readonly _onDidFindErrors = new Emitter<void>();\n\treadonly onDidFindErrors = this._onDidFindErrors.event;\n\n\tprotected readonly _onDidRequestInvalidateLastMarker = new Emitter<void>();\n\treadonly onDidRequestInvalidateLastMarker = this._onDidRequestInvalidateLastMarker.event;\n\n\tconstructor(public readonly problemMatchers: ProblemMatcher[], protected markerService: IMarkerService, protected modelService: IModelService, fileService?: IFileService) {\n\t\tsuper();\n\t\tthis.matchers = Object.create(null);\n\t\tthis.bufferLength = 1;\n\t\tproblemMatchers.map(elem => createLineMatcher(elem, fileService)).forEach((matcher) => {\n\t\t\tconst length = matcher.matchLength;\n\t\t\tif (length > this.bufferLength) {\n\t\t\t\tthis.bufferLength = length;\n\t\t\t}\n\t\t\tlet value = this.matchers[length];\n\t\t\tif (!value) {\n\t\t\t\tvalue = [];\n\t\t\t\tthis.matchers[length] = value;\n\t\t\t}\n\t\t\tvalue.push(matcher);\n\t\t});\n\t\tthis.buffer = [];\n\t\tthis.activeMatcher = null;\n\t\tthis._numberOfMatches = 0;\n\t\tthis._maxMarkerSeverity = undefined;\n\t\tthis.openModels = Object.create(null);\n\t\tthis.applyToByOwner = new Map<string, ApplyToKind>();\n\t\tfor (const problemMatcher of problemMatchers) {\n\t\t\tconst current = this.applyToByOwner.get(problemMatcher.owner);\n\t\t\tif (current === undefined) {\n\t\t\t\tthis.applyToByOwner.set(problemMatcher.owner, problemMatcher.applyTo);\n\t\t\t} else {\n\t\t\t\tthis.applyToByOwner.set(problemMatcher.owner, this.mergeApplyTo(current, problemMatcher.applyTo));\n\t\t\t}\n\t\t}\n\t\tthis.resourcesToClean = new Map<string, Map<string, URI>>();\n\t\tthis.markers = new Map<string, Map<string, Map<string, IMarkerData>>>();\n\t\tthis.deliveredMarkers = new Map<string, Map<string, number>>();\n\t\tthis._register(this.modelService.onModelAdded((model) => {\n\t\t\tthis.openModels[model.uri.toString()] = true;\n\t\t}, this, this.modelListeners));\n\t\tthis._register(this.modelService.onModelRemoved((model) => {\n\t\t\tdelete this.openModels[model.uri.toString()];\n\t\t}, this, this.modelListeners));\n\t\tthis.modelService.getModels().forEach(model => this.openModels[model.uri.toString()] = true);\n\n\t\tthis._onDidStateChange = new Emitter();\n\t}\n\n\tpublic get onDidStateChange(): Event<IProblemCollectorEvent> {\n\t\treturn this._onDidStateChange.event;\n\t}\n\n\tpublic processLine(line: string) {\n\t\tif (this.tail) {\n\t\t\tconst oldTail = this.tail;\n\t\t\tthis.tail = oldTail.then(() => {\n\t\t\t\treturn this.processLineInternal(line);\n\t\t\t});\n\t\t} else {\n\t\t\tthis.tail = this.processLineInternal(line);\n\t\t}\n\t}\n\n\tprotected abstract processLineInternal(line: string): Promise<void>;\n\n\tpublic override dispose() {\n\t\tsuper.dispose();\n\t\tthis.modelListeners.dispose();\n\t}\n\n\tpublic get numberOfMatches(): number {\n\t\treturn this._numberOfMatches;\n\t}\n\n\tpublic get maxMarkerSeverity(): MarkerSeverity | undefined {\n\t\treturn this._maxMarkerSeverity;\n\t}\n\n\tprotected tryFindMarker(line: string): IProblemMatch | null {\n\t\tlet result: IProblemMatch | null = null;\n\t\tif (this.activeMatcher) {\n\t\t\tresult = this.activeMatcher.next(line);\n\t\t\tif (result) {\n\t\t\t\tthis.captureMatch(result);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tthis.clearBuffer();\n\t\t\tthis.activeMatcher = null;\n\t\t}\n\t\tif (this.buffer.length < this.bufferLength) {\n\t\t\tthis.buffer.push(line);\n\t\t} else {\n\t\t\tconst end = this.buffer.length - 1;\n\t\t\tfor (let i = 0; i < end; i++) {\n\t\t\t\tthis.buffer[i] = this.buffer[i + 1];\n\t\t\t}\n\t\t\tthis.buffer[end] = line;\n\t\t}\n\n\t\tresult = this.tryMatchers();\n\t\tif (result) {\n\t\t\tthis.clearBuffer();\n\t\t}\n\t\treturn result;\n\t}\n\n\tprotected async shouldApplyMatch(result: IProblemMatch): Promise<boolean> {\n\t\tswitch (result.description.applyTo) {\n\t\t\tcase ApplyToKind.allDocuments:\n\t\t\t\treturn true;\n\t\t\tcase ApplyToKind.openDocuments:\n\t\t\t\treturn !!this.openModels[(await result.resource).toString()];\n\t\t\tcase ApplyToKind.closedDocuments:\n\t\t\t\treturn !this.openModels[(await result.resource).toString()];\n\t\t\tdefault:\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate mergeApplyTo(current: ApplyToKind, value: ApplyToKind): ApplyToKind {\n\t\tif (current === value || current === ApplyToKind.allDocuments) {\n\t\t\treturn current;\n\t\t}\n\t\treturn ApplyToKind.allDocuments;\n\t}\n\n\tprivate tryMatchers(): IProblemMatch | null {\n\t\tthis.activeMatcher = null;\n\t\tconst length = this.buffer.length;\n\t\tfor (let startIndex = 0; startIndex < length; startIndex++) {\n\t\t\tconst candidates = this.matchers[length - startIndex];\n\t\t\tif (!candidates) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (const matcher of candidates) {\n\t\t\t\tconst result = matcher.handle(this.buffer, startIndex);\n\t\t\t\tif (result.match) {\n\t\t\t\t\tthis.captureMatch(result.match);\n\t\t\t\t\tif (result.continue) {\n\t\t\t\t\t\tthis.activeMatcher = matcher;\n\t\t\t\t\t}\n\t\t\t\t\treturn result.match;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate captureMatch(match: IProblemMatch): void {\n\t\tthis._numberOfMatches++;\n\t\tif (this._maxMarkerSeverity === undefined || match.marker.severity > this._maxMarkerSeverity) {\n\t\t\tthis._maxMarkerSeverity = match.marker.severity;\n\t\t}\n\t}\n\n\tprivate clearBuffer(): void {\n\t\tif (this.buffer.length > 0) {\n\t\t\tthis.buffer = [];\n\t\t}\n\t}\n\n\tprotected recordResourcesToClean(owner: string): void {\n\t\tconst resourceSetToClean = this.getResourceSetToClean(owner);\n\t\tthis.markerService.read({ owner: owner }).forEach(marker => resourceSetToClean.set(marker.resource.toString(), marker.resource));\n\t}\n\n\tprotected recordResourceToClean(owner: string, resource: URI): void {\n\t\tthis.getResourceSetToClean(owner).set(resource.toString(), resource);\n\t}\n\n\tprotected removeResourceToClean(owner: string, resource: string): void {\n\t\tconst resourceSet = this.resourcesToClean.get(owner);\n\t\tresourceSet?.delete(resource);\n\t}\n\n\tprivate getResourceSetToClean(owner: string): Map<string, URI> {\n\t\tlet result = this.resourcesToClean.get(owner);\n\t\tif (!result) {\n\t\t\tresult = new Map<string, URI>();\n\t\t\tthis.resourcesToClean.set(owner, result);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprotected cleanAllMarkers(): void {\n\t\tthis.resourcesToClean.forEach((value, owner) => {\n\t\t\tthis._cleanMarkers(owner, value);\n\t\t});\n\t\tthis.resourcesToClean = new Map<string, Map<string, URI>>();\n\t}\n\n\tprotected cleanMarkers(owner: string): void {\n\t\tconst toClean = this.resourcesToClean.get(owner);\n\t\tif (toClean) {\n\t\t\tthis._cleanMarkers(owner, toClean);\n\t\t\tthis.resourcesToClean.delete(owner);\n\t\t}\n\t}\n\n\tprivate _cleanMarkers(owner: string, toClean: Map<string, URI>): void {\n\t\tconst uris: URI[] = [];\n\t\tconst applyTo = this.applyToByOwner.get(owner);\n\t\ttoClean.forEach((uri, uriAsString) => {\n\t\t\tif (\n\t\t\t\tapplyTo === ApplyToKind.allDocuments ||\n\t\t\t\t(applyTo === ApplyToKind.openDocuments && this.openModels[uriAsString]) ||\n\t\t\t\t(applyTo === ApplyToKind.closedDocuments && !this.openModels[uriAsString])\n\t\t\t) {\n\t\t\t\turis.push(uri);\n\t\t\t}\n\t\t});\n\t\tthis.markerService.remove(owner, uris);\n\t}\n\n\tprotected recordMarker(marker: IMarkerData, owner: string, resourceAsString: string): void {\n\t\tlet markersPerOwner = this.markers.get(owner);\n\t\tif (!markersPerOwner) {\n\t\t\tmarkersPerOwner = new Map<string, Map<string, IMarkerData>>();\n\t\t\tthis.markers.set(owner, markersPerOwner);\n\t\t}\n\t\tlet markersPerResource = markersPerOwner.get(resourceAsString);\n\t\tif (!markersPerResource) {\n\t\t\tmarkersPerResource = new Map<string, IMarkerData>();\n\t\t\tmarkersPerOwner.set(resourceAsString, markersPerResource);\n\t\t}\n\t\tconst key = IMarkerData.makeKeyOptionalMessage(marker, false);\n\t\tlet existingMarker;\n\t\tif (!markersPerResource.has(key)) {\n\t\t\tmarkersPerResource.set(key, marker);\n\t\t} else if (((existingMarker = markersPerResource.get(key)) !== undefined) && (existingMarker.message.length < marker.message.length) && isWindows) {\n\t\t\t// Most likely https://github.com/microsoft/vscode/issues/77475\n\t\t\t// Heuristic dictates that when the key is the same and message is smaller, we have hit this limitation.\n\t\t\tmarkersPerResource.set(key, marker);\n\t\t}\n\t}\n\n\tprotected reportMarkers(): void {\n\t\tthis.markers.forEach((markersPerOwner, owner) => {\n\t\t\tconst deliveredMarkersPerOwner = this.getDeliveredMarkersPerOwner(owner);\n\t\t\tmarkersPerOwner.forEach((markers, resource) => {\n\t\t\t\tthis.deliverMarkersPerOwnerAndResourceResolved(owner, resource, markers, deliveredMarkersPerOwner);\n\t\t\t});\n\t\t});\n\t}\n\n\tprotected deliverMarkersPerOwnerAndResource(owner: string, resource: string): void {\n\t\tconst markersPerOwner = this.markers.get(owner);\n\t\tif (!markersPerOwner) {\n\t\t\treturn;\n\t\t}\n\t\tconst deliveredMarkersPerOwner = this.getDeliveredMarkersPerOwner(owner);\n\t\tconst markersPerResource = markersPerOwner.get(resource);\n\t\tif (!markersPerResource) {\n\t\t\treturn;\n\t\t}\n\t\tthis.deliverMarkersPerOwnerAndResourceResolved(owner, resource, markersPerResource, deliveredMarkersPerOwner);\n\t}\n\n\tprivate deliverMarkersPerOwnerAndResourceResolved(owner: string, resource: string, markers: Map<string, IMarkerData>, reported: Map<string, number>): void {\n\t\tif (markers.size !== reported.get(resource)) {\n\t\t\tconst toSet: IMarkerData[] = [];\n\t\t\tmarkers.forEach(value => toSet.push(value));\n\t\t\tthis.markerService.changeOne(owner, URI.parse(resource), toSet);\n\t\t\treported.set(resource, markers.size);\n\t\t}\n\t}\n\n\tprivate getDeliveredMarkersPerOwner(owner: string): Map<string, number> {\n\t\tlet result = this.deliveredMarkers.get(owner);\n\t\tif (!result) {\n\t\t\tresult = new Map<string, number>();\n\t\t\tthis.deliveredMarkers.set(owner, result);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprotected cleanMarkerCaches(): void {\n\t\tthis._numberOfMatches = 0;\n\t\tthis._maxMarkerSeverity = undefined;\n\t\tthis.markers.clear();\n\t\tthis.deliveredMarkers.clear();\n\t}\n\n\tpublic done(): void {\n\t\tthis.reportMarkers();\n\t\tthis.cleanAllMarkers();\n\t}\n}\n\nexport const enum ProblemHandlingStrategy {\n\tClean\n}\n\nexport class StartStopProblemCollector extends AbstractProblemCollector implements IProblemMatcher {\n\tprivate owners: string[];\n\n\tprivate currentOwner: string | undefined;\n\tprivate currentResource: string | undefined;\n\n\tconstructor(problemMatchers: ProblemMatcher[], markerService: IMarkerService, modelService: IModelService, _strategy: ProblemHandlingStrategy = ProblemHandlingStrategy.Clean, fileService?: IFileService) {\n\t\tsuper(problemMatchers, markerService, modelService, fileService);\n\t\tconst ownerSet: { [key: string]: boolean } = Object.create(null);\n\t\tproblemMatchers.forEach(description => ownerSet[description.owner] = true);\n\t\tthis.owners = Object.keys(ownerSet);\n\t\tthis.owners.forEach((owner) => {\n\t\t\tthis.recordResourcesToClean(owner);\n\t\t});\n\t}\n\n\tprotected async processLineInternal(line: string): Promise<void> {\n\t\tconst markerMatch = this.tryFindMarker(line);\n\t\tif (!markerMatch) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst owner = markerMatch.description.owner;\n\t\tconst resource = await markerMatch.resource;\n\t\tconst resourceAsString = resource.toString();\n\t\tthis.removeResourceToClean(owner, resourceAsString);\n\t\tconst shouldApplyMatch = await this.shouldApplyMatch(markerMatch);\n\t\tif (shouldApplyMatch) {\n\t\t\tthis.recordMarker(markerMatch.marker, owner, resourceAsString);\n\t\t\tif (this.currentOwner !== owner || this.currentResource !== resourceAsString) {\n\t\t\t\tif (this.currentOwner && this.currentResource) {\n\t\t\t\t\tthis.deliverMarkersPerOwnerAndResource(this.currentOwner, this.currentResource);\n\t\t\t\t}\n\t\t\t\tthis.currentOwner = owner;\n\t\t\t\tthis.currentResource = resourceAsString;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninterface IBackgroundPatterns {\n\tkey: string;\n\tmatcher: ProblemMatcher;\n\tbegin: IWatchingPattern;\n\tend: IWatchingPattern;\n}\n\nexport class WatchingProblemCollector extends AbstractProblemCollector implements IProblemMatcher {\n\n\tprivate backgroundPatterns: IBackgroundPatterns[];\n\n\t// workaround for https://github.com/microsoft/vscode/issues/44018\n\tprivate _activeBackgroundMatchers: Set<string>;\n\n\t// Current State\n\tprivate currentOwner: string | undefined;\n\tprivate currentResource: string | undefined;\n\n\tprivate lines: string[] = [];\n\tpublic beginPatterns: RegExp[] = [];\n\tconstructor(problemMatchers: ProblemMatcher[], markerService: IMarkerService, modelService: IModelService, fileService?: IFileService) {\n\t\tsuper(problemMatchers, markerService, modelService, fileService);\n\t\tthis.resetCurrentResource();\n\t\tthis.backgroundPatterns = [];\n\t\tthis._activeBackgroundMatchers = new Set<string>();\n\t\tthis.problemMatchers.forEach(matcher => {\n\t\t\tif (matcher.watching) {\n\t\t\t\tconst key: string = generateUuid();\n\t\t\t\tthis.backgroundPatterns.push({\n\t\t\t\t\tkey,\n\t\t\t\t\tmatcher: matcher,\n\t\t\t\t\tbegin: matcher.watching.beginsPattern,\n\t\t\t\t\tend: matcher.watching.endsPattern\n\t\t\t\t});\n\t\t\t\tthis.beginPatterns.push(matcher.watching.beginsPattern.regexp);\n\t\t\t}\n\t\t});\n\n\t\tthis.modelListeners.add(this.modelService.onModelRemoved(modelEvent => {\n\t\t\tlet markerChanged: IDisposable | undefined =\n\t\t\t\tEvent.debounce(this.markerService.onMarkerChanged, (last: readonly URI[] | undefined, e: readonly URI[]) => {\n\t\t\t\t\treturn (last ?? []).concat(e);\n\t\t\t\t}, 500, false, true)(async (markerEvent) => {\n\t\t\t\t\tmarkerChanged?.dispose();\n\t\t\t\t\tmarkerChanged = undefined;\n\t\t\t\t\tif (!markerEvent || !markerEvent.includes(modelEvent.uri) || (this.markerService.read({ resource: modelEvent.uri }).length !== 0)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tconst oldLines = Array.from(this.lines);\n\t\t\t\t\tfor (const line of oldLines) {\n\t\t\t\t\t\tawait this.processLineInternal(line);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\tsetTimeout(async () => {\n\t\t\t\t// Calling dispose below can trigger the debounce event (via flushOnListenerRemove), so we\n\t\t\t\t// have to unset markerChanged first to make sure the handler above doesn't dispose it again.\n\t\t\t\tconst _markerChanged = markerChanged;\n\t\t\t\tmarkerChanged = undefined;\n\t\t\t\t_markerChanged?.dispose();\n\t\t\t}, 600);\n\t\t}));\n\t}\n\n\tpublic aboutToStart(): void {\n\t\tfor (const background of this.backgroundPatterns) {\n\t\t\tif (background.matcher.watching && background.matcher.watching.activeOnStart) {\n\t\t\t\tthis._activeBackgroundMatchers.add(background.key);\n\t\t\t\tthis._onDidStateChange.fire(IProblemCollectorEvent.create(ProblemCollectorEventKind.BackgroundProcessingBegins));\n\t\t\t\tthis.recordResourcesToClean(background.matcher.owner);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected async processLineInternal(line: string): Promise<void> {\n\t\tif (await this.tryBegin(line) || this.tryFinish(line)) {\n\t\t\treturn;\n\t\t}\n\t\tthis.lines.push(line);\n\t\tconst markerMatch = this.tryFindMarker(line);\n\t\tif (!markerMatch) {\n\t\t\treturn;\n\t\t}\n\t\tconst resource = await markerMatch.resource;\n\t\tconst owner = markerMatch.description.owner;\n\t\tconst resourceAsString = resource.toString();\n\t\tthis.removeResourceToClean(owner, resourceAsString);\n\t\tconst shouldApplyMatch = await this.shouldApplyMatch(markerMatch);\n\t\tif (shouldApplyMatch) {\n\t\t\tthis.recordMarker(markerMatch.marker, owner, resourceAsString);\n\t\t\tif (this.currentOwner !== owner || this.currentResource !== resourceAsString) {\n\t\t\t\tthis.reportMarkersForCurrentResource();\n\t\t\t\tthis.currentOwner = owner;\n\t\t\t\tthis.currentResource = resourceAsString;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic forceDelivery(): void {\n\t\tthis.reportMarkersForCurrentResource();\n\t}\n\n\tprivate async tryBegin(line: string): Promise<boolean> {\n\t\tlet result = false;\n\t\tfor (const background of this.backgroundPatterns) {\n\t\t\tconst matches = background.begin.regexp.exec(line);\n\t\t\tif (matches) {\n\t\t\t\tif (this._activeBackgroundMatchers.has(background.key)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tthis._activeBackgroundMatchers.add(background.key);\n\t\t\t\tresult = true;\n\t\t\t\tthis._onDidFindFirstMatch.fire();\n\t\t\t\tthis.lines = [];\n\t\t\t\tthis.lines.push(line);\n\t\t\t\tthis._onDidStateChange.fire(IProblemCollectorEvent.create(ProblemCollectorEventKind.BackgroundProcessingBegins));\n\t\t\t\tthis.cleanMarkerCaches();\n\t\t\t\tthis.resetCurrentResource();\n\t\t\t\tconst owner = background.matcher.owner;\n\t\t\t\tconst file = matches[background.begin.file!];\n\t\t\t\tif (file) {\n\t\t\t\t\tconst resource = getResource(file, background.matcher);\n\t\t\t\t\tthis.recordResourceToClean(owner, await resource);\n\t\t\t\t} else {\n\t\t\t\t\tthis.recordResourcesToClean(owner);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate tryFinish(line: string): boolean {\n\t\tlet result = false;\n\t\tfor (const background of this.backgroundPatterns) {\n\t\t\tconst matches = background.end.regexp.exec(line);\n\t\t\tif (matches) {\n\t\t\t\tif (this._numberOfMatches > 0) {\n\t\t\t\t\tthis._onDidFindErrors.fire();\n\t\t\t\t} else {\n\t\t\t\t\tthis._onDidRequestInvalidateLastMarker.fire();\n\t\t\t\t}\n\t\t\t\tif (this._activeBackgroundMatchers.has(background.key)) {\n\t\t\t\t\tthis._activeBackgroundMatchers.delete(background.key);\n\t\t\t\t\tthis.resetCurrentResource();\n\t\t\t\t\tthis._onDidStateChange.fire(IProblemCollectorEvent.create(ProblemCollectorEventKind.BackgroundProcessingEnds));\n\t\t\t\t\tresult = true;\n\t\t\t\t\tthis.lines.push(line);\n\t\t\t\t\tconst owner = background.matcher.owner;\n\t\t\t\t\tthis.cleanMarkers(owner);\n\t\t\t\t\tthis.cleanMarkerCaches();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate resetCurrentResource(): void {\n\t\tthis.reportMarkersForCurrentResource();\n\t\tthis.currentOwner = undefined;\n\t\tthis.currentResource = undefined;\n\t}\n\n\tprivate reportMarkersForCurrentResource(): void {\n\t\tif (this.currentOwner && this.currentResource) {\n\t\t\tthis.deliverMarkersPerOwnerAndResource(this.currentOwner, this.currentResource);\n\t\t}\n\t}\n\n\tpublic override done(): void {\n\t\t[...this.applyToByOwner.keys()].forEach(owner => {\n\t\t\tthis.recordResourcesToClean(owner);\n\t\t});\n\t\tsuper.done();\n\t}\n\n\tpublic isWatching(): boolean {\n\t\treturn this.backgroundPatterns.length > 0;\n\t}\n}\n"],
  "mappings": "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",
  "names": ["ProblemCollectorEventKind", "IProblemCollectorEvent", "ProblemHandlingStrategy"]
}
