{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/searchEditor/browser/searchEditorSerialization.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { coalesce } from '../../../../base/common/arrays.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport './media/searchEditor.css';\nimport { ServicesAccessor } from '../../../../editor/browser/editorExtensions.js';\nimport { Range } from '../../../../editor/common/core/range.js';\nimport type { ITextModel } from '../../../../editor/common/model.js';\nimport { localize } from '../../../../nls.js';\nimport { FileMatch, Match, searchMatchComparer, SearchResult, FolderMatch, CellMatch } from '../../search/browser/searchModel.js';\nimport type { SearchConfiguration } from './searchEditorInput.js';\nimport { ITextQuery, SearchSortOrder } from '../../../services/search/common/search.js';\nimport { ITextFileService } from '../../../services/textfile/common/textfiles.js';\n\n// Using \\r\\n on Windows inserts an extra newline between results.\nconst lineDelimiter = '\\n';\n\nconst translateRangeLines =\n\t(n: number) =>\n\t\t(range: Range) =>\n\t\t\tnew Range(range.startLineNumber + n, range.startColumn, range.endLineNumber + n, range.endColumn);\n\nconst matchToSearchResultFormat = (match: Match, longestLineNumber: number): { line: string; ranges: Range[]; lineNumber: string }[] => {\n\tconst getLinePrefix = (i: number) => `${match.range().startLineNumber + i}`;\n\n\tconst fullMatchLines = match.fullPreviewLines();\n\n\n\tconst results: { line: string; ranges: Range[]; lineNumber: string }[] = [];\n\n\tfullMatchLines\n\t\t.forEach((sourceLine, i) => {\n\t\t\tconst lineNumber = getLinePrefix(i);\n\t\t\tconst paddingStr = ' '.repeat(longestLineNumber - lineNumber.length);\n\t\t\tconst prefix = `  ${paddingStr}${lineNumber}: `;\n\t\t\tconst prefixOffset = prefix.length;\n\n\t\t\t// split instead of replace to avoid creating a new string object\n\t\t\tconst line = prefix + (sourceLine.split(/\\r?\\n?$/, 1)[0] || '');\n\n\t\t\tconst rangeOnThisLine = ({ start, end }: { start?: number; end?: number }) => new Range(1, (start ?? 1) + prefixOffset, 1, (end ?? sourceLine.length + 1) + prefixOffset);\n\n\t\t\tconst matchRange = match.rangeInPreview();\n\t\t\tconst matchIsSingleLine = matchRange.startLineNumber === matchRange.endLineNumber;\n\n\t\t\tlet lineRange;\n\t\t\tif (matchIsSingleLine) { lineRange = (rangeOnThisLine({ start: matchRange.startColumn, end: matchRange.endColumn })); }\n\t\t\telse if (i === 0) { lineRange = (rangeOnThisLine({ start: matchRange.startColumn })); }\n\t\t\telse if (i === fullMatchLines.length - 1) { lineRange = (rangeOnThisLine({ end: matchRange.endColumn })); }\n\t\t\telse { lineRange = (rangeOnThisLine({})); }\n\n\t\t\tresults.push({ lineNumber: lineNumber, line, ranges: [lineRange] });\n\t\t});\n\n\treturn results;\n};\n\ntype SearchResultSerialization = { text: string[]; matchRanges: Range[] };\n\nfunction fileMatchToSearchResultFormat(fileMatch: FileMatch, labelFormatter: (x: URI) => string): SearchResultSerialization[] {\n\n\tconst textSerializations = fileMatch.textMatches().length > 0 ? matchesToSearchResultFormat(fileMatch.resource, fileMatch.textMatches().sort(searchMatchComparer), fileMatch.context, labelFormatter) : undefined;\n\tconst cellSerializations = fileMatch.cellMatches().sort((a, b) => a.cellIndex - b.cellIndex).sort().filter(cellMatch => cellMatch.contentMatches.length > 0).map((cellMatch, index) => cellMatchToSearchResultFormat(cellMatch, labelFormatter, index === 0));\n\n\treturn [textSerializations, ...cellSerializations].filter(x => !!x) as SearchResultSerialization[];\n}\nfunction matchesToSearchResultFormat(resource: URI, sortedMatches: Match[], matchContext: Map<number, string>, labelFormatter: (x: URI) => string, shouldUseHeader = true): SearchResultSerialization {\n\tconst longestLineNumber = sortedMatches[sortedMatches.length - 1].range().endLineNumber.toString().length;\n\n\tconst text: string[] = shouldUseHeader ? [`${labelFormatter(resource)}:`] : [];\n\tconst matchRanges: Range[] = [];\n\n\tconst targetLineNumberToOffset: Record<string, number> = {};\n\n\tconst context: { line: string; lineNumber: number }[] = [];\n\tmatchContext.forEach((line, lineNumber) => context.push({ line, lineNumber }));\n\tcontext.sort((a, b) => a.lineNumber - b.lineNumber);\n\n\tlet lastLine: number | undefined = undefined;\n\n\tconst seenLines = new Set<string>();\n\tsortedMatches.forEach(match => {\n\t\tmatchToSearchResultFormat(match, longestLineNumber).forEach(match => {\n\t\t\tif (!seenLines.has(match.lineNumber)) {\n\t\t\t\twhile (context.length && context[0].lineNumber < +match.lineNumber) {\n\t\t\t\t\tconst { line, lineNumber } = context.shift()!;\n\t\t\t\t\tif (lastLine !== undefined && lineNumber !== lastLine + 1) {\n\t\t\t\t\t\ttext.push('');\n\t\t\t\t\t}\n\t\t\t\t\ttext.push(`  ${' '.repeat(longestLineNumber - `${lineNumber}`.length)}${lineNumber}  ${line}`);\n\t\t\t\t\tlastLine = lineNumber;\n\t\t\t\t}\n\n\t\t\t\ttargetLineNumberToOffset[match.lineNumber] = text.length;\n\t\t\t\tseenLines.add(match.lineNumber);\n\t\t\t\ttext.push(match.line);\n\t\t\t\tlastLine = +match.lineNumber;\n\t\t\t}\n\n\t\t\tmatchRanges.push(...match.ranges.map(translateRangeLines(targetLineNumberToOffset[match.lineNumber])));\n\t\t});\n\t});\n\n\twhile (context.length) {\n\t\tconst { line, lineNumber } = context.shift()!;\n\t\ttext.push(`  ${lineNumber}  ${line}`);\n\t}\n\n\treturn { text, matchRanges };\n}\n\nfunction cellMatchToSearchResultFormat(cellMatch: CellMatch, labelFormatter: (x: URI) => string, shouldUseHeader: boolean): SearchResultSerialization {\n\treturn matchesToSearchResultFormat(cellMatch.cell?.uri ?? cellMatch.parent.resource, cellMatch.contentMatches.sort(searchMatchComparer), cellMatch.context, labelFormatter, shouldUseHeader);\n}\n\nconst contentPatternToSearchConfiguration = (pattern: ITextQuery, includes: string, excludes: string, contextLines: number): SearchConfiguration => {\n\treturn {\n\t\tquery: pattern.contentPattern.pattern,\n\t\tisRegexp: !!pattern.contentPattern.isRegExp,\n\t\tisCaseSensitive: !!pattern.contentPattern.isCaseSensitive,\n\t\tmatchWholeWord: !!pattern.contentPattern.isWordMatch,\n\t\tfilesToExclude: excludes, filesToInclude: includes,\n\t\tshowIncludesExcludes: !!(includes || excludes || pattern?.userDisabledExcludesAndIgnoreFiles),\n\t\tuseExcludeSettingsAndIgnoreFiles: (pattern?.userDisabledExcludesAndIgnoreFiles === undefined ? true : !pattern.userDisabledExcludesAndIgnoreFiles),\n\t\tcontextLines,\n\t\tonlyOpenEditors: !!pattern.onlyOpenEditors,\n\t\tnotebookSearchConfig: {\n\t\t\tincludeMarkupInput: !!pattern.contentPattern.notebookInfo?.isInNotebookMarkdownInput,\n\t\t\tincludeMarkupPreview: !!pattern.contentPattern.notebookInfo?.isInNotebookMarkdownPreview,\n\t\t\tincludeCodeInput: !!pattern.contentPattern.notebookInfo?.isInNotebookCellInput,\n\t\t\tincludeOutput: !!pattern.contentPattern.notebookInfo?.isInNotebookCellOutput,\n\t\t}\n\t};\n};\n\nexport const serializeSearchConfiguration = (config: Partial<SearchConfiguration>): string => {\n\tconst removeNullFalseAndUndefined = <T>(a: (T | null | false | undefined)[]) => a.filter(a => a !== false && a !== null && a !== undefined) as T[];\n\n\tconst escapeNewlines = (str: string) => str.replace(/\\\\/g, '\\\\\\\\').replace(/\\n/g, '\\\\n');\n\n\treturn removeNullFalseAndUndefined([\n\t\t`# Query: ${escapeNewlines(config.query ?? '')}`,\n\n\t\t(config.isCaseSensitive || config.matchWholeWord || config.isRegexp || config.useExcludeSettingsAndIgnoreFiles === false)\n\t\t&& `# Flags: ${coalesce([\n\t\t\tconfig.isCaseSensitive && 'CaseSensitive',\n\t\t\tconfig.matchWholeWord && 'WordMatch',\n\t\t\tconfig.isRegexp && 'RegExp',\n\t\t\tconfig.onlyOpenEditors && 'OpenEditors',\n\t\t\t(config.useExcludeSettingsAndIgnoreFiles === false) && 'IgnoreExcludeSettings'\n\t\t]).join(' ')}`,\n\t\tconfig.filesToInclude ? `# Including: ${config.filesToInclude}` : undefined,\n\t\tconfig.filesToExclude ? `# Excluding: ${config.filesToExclude}` : undefined,\n\t\tconfig.contextLines ? `# ContextLines: ${config.contextLines}` : undefined,\n\t\t''\n\t]).join(lineDelimiter);\n};\n\nexport const extractSearchQueryFromModel = (model: ITextModel): SearchConfiguration =>\n\textractSearchQueryFromLines(model.getValueInRange(new Range(1, 1, 6, 1)).split(lineDelimiter));\n\nexport const defaultSearchConfig = (): SearchConfiguration => ({\n\tquery: '',\n\tfilesToInclude: '',\n\tfilesToExclude: '',\n\tisRegexp: false,\n\tisCaseSensitive: false,\n\tuseExcludeSettingsAndIgnoreFiles: true,\n\tmatchWholeWord: false,\n\tcontextLines: 0,\n\tshowIncludesExcludes: false,\n\tonlyOpenEditors: false,\n\tnotebookSearchConfig: {\n\t\tincludeMarkupInput: true,\n\t\tincludeMarkupPreview: false,\n\t\tincludeCodeInput: true,\n\t\tincludeOutput: true,\n\t}\n});\n\nexport const extractSearchQueryFromLines = (lines: string[]): SearchConfiguration => {\n\n\tconst query = defaultSearchConfig();\n\n\tconst unescapeNewlines = (str: string) => {\n\t\tlet out = '';\n\t\tfor (let i = 0; i < str.length; i++) {\n\t\t\tif (str[i] === '\\\\') {\n\t\t\t\ti++;\n\t\t\t\tconst escaped = str[i];\n\n\t\t\t\tif (escaped === 'n') {\n\t\t\t\t\tout += '\\n';\n\t\t\t\t}\n\t\t\t\telse if (escaped === '\\\\') {\n\t\t\t\t\tout += '\\\\';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow Error(localize('invalidQueryStringError', \"All backslashes in Query string must be escaped (\\\\\\\\)\"));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tout += str[i];\n\t\t\t}\n\t\t}\n\t\treturn out;\n\t};\n\n\tconst parseYML = /^# ([^:]*): (.*)$/;\n\tfor (const line of lines) {\n\t\tconst parsed = parseYML.exec(line);\n\t\tif (!parsed) { continue; }\n\t\tconst [, key, value] = parsed;\n\t\tswitch (key) {\n\t\t\tcase 'Query': query.query = unescapeNewlines(value); break;\n\t\t\tcase 'Including': query.filesToInclude = value; break;\n\t\t\tcase 'Excluding': query.filesToExclude = value; break;\n\t\t\tcase 'ContextLines': query.contextLines = +value; break;\n\t\t\tcase 'Flags': {\n\t\t\t\tquery.isRegexp = value.indexOf('RegExp') !== -1;\n\t\t\t\tquery.isCaseSensitive = value.indexOf('CaseSensitive') !== -1;\n\t\t\t\tquery.useExcludeSettingsAndIgnoreFiles = value.indexOf('IgnoreExcludeSettings') === -1;\n\t\t\t\tquery.matchWholeWord = value.indexOf('WordMatch') !== -1;\n\t\t\t\tquery.onlyOpenEditors = value.indexOf('OpenEditors') !== -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tquery.showIncludesExcludes = !!(query.filesToInclude || query.filesToExclude || !query.useExcludeSettingsAndIgnoreFiles);\n\n\treturn query;\n};\n\nexport const serializeSearchResultForEditor =\n\t(searchResult: SearchResult, rawIncludePattern: string, rawExcludePattern: string, contextLines: number, labelFormatter: (x: URI) => string, sortOrder: SearchSortOrder, limitHit?: boolean): { matchRanges: Range[]; text: string; config: Partial<SearchConfiguration> } => {\n\t\tif (!searchResult.query) { throw Error('Internal Error: Expected query, got null'); }\n\t\tconst config = contentPatternToSearchConfiguration(searchResult.query, rawIncludePattern, rawExcludePattern, contextLines);\n\n\t\tconst filecount = searchResult.fileCount() > 1 ? localize('numFiles', \"{0} files\", searchResult.fileCount()) : localize('oneFile', \"1 file\");\n\t\tconst resultcount = searchResult.count() > 1 ? localize('numResults', \"{0} results\", searchResult.count()) : localize('oneResult', \"1 result\");\n\n\t\tconst info = [\n\t\t\tsearchResult.count()\n\t\t\t\t? `${resultcount} - ${filecount}`\n\t\t\t\t: localize('noResults', \"No Results\"),\n\t\t];\n\t\tif (limitHit) {\n\t\t\tinfo.push(localize('searchMaxResultsWarning', \"The result set only contains a subset of all matches. Be more specific in your search to narrow down the results.\"));\n\t\t}\n\t\tinfo.push('');\n\n\t\tconst matchComparer = (a: FileMatch | FolderMatch, b: FileMatch | FolderMatch) => searchMatchComparer(a, b, sortOrder);\n\n\t\tconst allResults =\n\t\t\tflattenSearchResultSerializations(\n\t\t\t\tsearchResult.folderMatches().sort(matchComparer)\n\t\t\t\t\t.map(folderMatch => folderMatch.allDownstreamFileMatches().sort(matchComparer)\n\t\t\t\t\t\t.flatMap(fileMatch => fileMatchToSearchResultFormat(fileMatch, labelFormatter))).flat());\n\n\t\treturn {\n\t\t\tmatchRanges: allResults.matchRanges.map(translateRangeLines(info.length)),\n\t\t\ttext: info.concat(allResults.text).join(lineDelimiter),\n\t\t\tconfig\n\t\t};\n\t};\n\nconst flattenSearchResultSerializations = (serializations: SearchResultSerialization[]): SearchResultSerialization => {\n\tconst text: string[] = [];\n\tconst matchRanges: Range[] = [];\n\n\tserializations.forEach(serialized => {\n\t\tserialized.matchRanges.map(translateRangeLines(text.length)).forEach(range => matchRanges.push(range));\n\t\tserialized.text.forEach(line => text.push(line));\n\t\ttext.push(''); // new line\n\t});\n\n\treturn { text, matchRanges };\n};\n\nexport const parseSavedSearchEditor = async (accessor: ServicesAccessor, resource: URI) => {\n\tconst textFileService = accessor.get(ITextFileService);\n\n\tconst text = (await textFileService.read(resource)).value;\n\treturn parseSerializedSearchEditor(text);\n};\n\nexport const parseSerializedSearchEditor = (text: string) => {\n\tconst headerlines = [];\n\tconst bodylines = [];\n\n\tlet inHeader = true;\n\tfor (const line of text.split(/\\r?\\n/g)) {\n\t\tif (inHeader) {\n\t\t\theaderlines.push(line);\n\t\t\tif (line === '') {\n\t\t\t\tinHeader = false;\n\t\t\t}\n\t\t} else {\n\t\t\tbodylines.push(line);\n\t\t}\n\t}\n\n\treturn { config: extractSearchQueryFromLines(headerlines), text: bodylines.join('\\n') };\n};\n"],
  "mappings": "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",
  "names": ["match", "a"]
}
