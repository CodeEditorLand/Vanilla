import{Emitter as v}from"../../../../../vs/base/common/event.js";import{ResourceMap as M}from"../../../../../vs/base/common/map.js";import{assertIsDefined as y}from"../../../../../vs/base/common/types.js";import"../../../../../vs/base/common/uri.js";import{ILanguageService as f}from"../../../../../vs/editor/common/languages/language.js";import"../../../../../vs/editor/common/model.js";import{createTextBufferFactoryFromStream as I}from"../../../../../vs/editor/common/model/textModel.js";import{IModelService as m}from"../../../../../vs/editor/common/services/model.js";import{IInstantiationService as u}from"../../../../../vs/platform/instantiation/common/instantiation.js";import{SearchEditorWorkingCopyTypeId as E}from"../../../../../vs/workbench/contrib/searchEditor/browser/constants.js";import{parseSavedSearchEditor as k,parseSerializedSearchEditor as w}from"../../../../../vs/workbench/contrib/searchEditor/browser/searchEditorSerialization.js";import{SEARCH_RESULT_LANGUAGE_ID as l}from"../../../../../vs/workbench/services/search/common/search.js";import{IWorkingCopyBackupService as p}from"../../../../../vs/workbench/services/workingCopy/common/workingCopyBackup.js";import"./searchEditorInput.js";class g{constructor(e){this.config=e}_onConfigDidUpdate=new v;onConfigDidUpdate=this._onConfigDidUpdate.event;updateConfig(e){this.config=e,this._onConfigDidUpdate.fire(e)}}class q{constructor(e){this.resource=e}async resolve(){return y(F.models.get(this.resource)).resolve()}}class C{models=new M;constructor(){}initializeModelFromExistingModel(e,t,i){if(this.models.has(t))throw Error("Unable to contruct model for resource that already exists");const s=e.get(f),n=e.get(m),a=e.get(u),c=e.get(p);let o;this.models.set(t,{resolve:()=>(o||(o=(async()=>{const r=await this.tryFetchModelFromBackupService(t,s,n,c,a);return r||Promise.resolve({resultsModel:n.getModel(t)??n.createModel("",s.createById(l),t),configurationModel:new g(i)})})()),o)})}initializeModelFromRawData(e,t,i,s){if(this.models.has(t))throw Error("Unable to contruct model for resource that already exists");const n=e.get(f),a=e.get(m),c=e.get(u),o=e.get(p);let r;this.models.set(t,{resolve:()=>(r||(r=(async()=>{const d=await this.tryFetchModelFromBackupService(t,n,a,o,c);return d||Promise.resolve({resultsModel:a.createModel(s??"",n.createById(l),t),configurationModel:new g(i)})})()),r)})}initializeModelFromExistingFile(e,t,i){if(this.models.has(t))throw Error("Unable to contruct model for resource that already exists");const s=e.get(f),n=e.get(m),a=e.get(u),c=e.get(p);let o;this.models.set(t,{resolve:async()=>(o||(o=(async()=>{const r=await this.tryFetchModelFromBackupService(t,s,n,c,a);if(r)return r;const{text:d,config:h}=await a.invokeFunction(k,i);return{resultsModel:n.createModel(d??"",s.createById(l),t),configurationModel:new g(h)}})()),o)})}async tryFetchModelFromBackupService(e,t,i,s,n){const a=await s.resolve({resource:e,typeId:E});let c=i.getModel(e);if(!c&&a){const o=await I(a.value);c=i.createModel(o,t.createById(l),e)}if(c){const o=c.getValue(),{text:r,config:d}=w(o);return i.destroyModel(e),{resultsModel:i.createModel(r??"",t.createById(l),e),configurationModel:new g(d)}}else return}}const F=new C;export{g as SearchConfigurationModel,q as SearchEditorModel,F as searchEditorModelFactory};
