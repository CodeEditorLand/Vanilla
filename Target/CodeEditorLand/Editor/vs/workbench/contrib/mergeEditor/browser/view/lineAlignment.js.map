{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/mergeEditor/browser/view/lineAlignment.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { compareBy } from \"../../../../../base/common/arrays.js\";\nimport {\n\tassertFn,\n\tcheckAdjacentItems,\n} from \"../../../../../base/common/assert.js\";\nimport { isDefined } from \"../../../../../base/common/types.js\";\nimport { Position } from \"../../../../../editor/common/core/position.js\";\nimport { Range } from \"../../../../../editor/common/core/range.js\";\nimport { TextLength } from \"../../../../../editor/common/core/textLength.js\";\nimport { RangeMapping } from \"../model/mapping.js\";\nimport type { ModifiedBaseRange } from \"../model/modifiedBaseRange.js\";\nimport {\n\taddLength,\n\tlengthBetweenPositions,\n\tlengthOfRange,\n} from \"../model/rangeUtils.js\";\n\nexport type LineAlignment = [\n\tinput1LineNumber: number | undefined,\n\tbaseLineNumber: number,\n\tinput2LineNumber: number | undefined,\n];\n\nexport function getAlignments(m: ModifiedBaseRange): LineAlignment[] {\n\tconst equalRanges1 = toEqualRangeMappings(\n\t\tm.input1Diffs.flatMap((d) => d.rangeMappings),\n\t\tm.baseRange.toRange(),\n\t\tm.input1Range.toRange(),\n\t);\n\tconst equalRanges2 = toEqualRangeMappings(\n\t\tm.input2Diffs.flatMap((d) => d.rangeMappings),\n\t\tm.baseRange.toRange(),\n\t\tm.input2Range.toRange(),\n\t);\n\n\tconst commonRanges = splitUpCommonEqualRangeMappings(\n\t\tequalRanges1,\n\t\tequalRanges2,\n\t);\n\n\tlet result: LineAlignment[] = [];\n\tresult.push([\n\t\tm.input1Range.startLineNumber - 1,\n\t\tm.baseRange.startLineNumber - 1,\n\t\tm.input2Range.startLineNumber - 1,\n\t]);\n\n\tfunction isFullSync(lineAlignment: LineAlignment) {\n\t\treturn lineAlignment.every((i) => i !== undefined);\n\t}\n\n\t// One base line has either up to one full sync or up to two half syncs.\n\tfor (const m of commonRanges) {\n\t\tconst lineAlignment: LineAlignment = [\n\t\t\tm.output1Pos?.lineNumber,\n\t\t\tm.inputPos.lineNumber,\n\t\t\tm.output2Pos?.lineNumber,\n\t\t];\n\t\tconst alignmentIsFullSync = isFullSync(lineAlignment);\n\n\t\tlet shouldAdd = true;\n\t\tif (alignmentIsFullSync) {\n\t\t\tconst isNewFullSyncAlignment = !result.some(\n\t\t\t\t(r) =>\n\t\t\t\t\tisFullSync(r) &&\n\t\t\t\t\tr.some(\n\t\t\t\t\t\t(v, idx) => v !== undefined && v === lineAlignment[idx],\n\t\t\t\t\t),\n\t\t\t);\n\t\t\tif (isNewFullSyncAlignment) {\n\t\t\t\t// Remove half syncs\n\t\t\t\tresult = result.filter(\n\t\t\t\t\t(r) =>\n\t\t\t\t\t\t!r.some(\n\t\t\t\t\t\t\t(v, idx) =>\n\t\t\t\t\t\t\t\tv !== undefined && v === lineAlignment[idx],\n\t\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\t\t\tshouldAdd = isNewFullSyncAlignment;\n\t\t} else {\n\t\t\tconst isNew = !result.some((r) =>\n\t\t\t\tr.some((v, idx) => v !== undefined && v === lineAlignment[idx]),\n\t\t\t);\n\t\t\tshouldAdd = isNew;\n\t\t}\n\n\t\tif (shouldAdd) {\n\t\t\tresult.push(lineAlignment);\n\t\t} else if (m.length.isGreaterThan(new TextLength(1, 0))) {\n\t\t\tresult.push([\n\t\t\t\tm.output1Pos ? m.output1Pos.lineNumber + 1 : undefined,\n\t\t\t\tm.inputPos.lineNumber + 1,\n\t\t\t\tm.output2Pos ? m.output2Pos.lineNumber + 1 : undefined,\n\t\t\t]);\n\t\t}\n\t}\n\n\tconst finalLineAlignment: LineAlignment = [\n\t\tm.input1Range.endLineNumberExclusive,\n\t\tm.baseRange.endLineNumberExclusive,\n\t\tm.input2Range.endLineNumberExclusive,\n\t];\n\tresult = result.filter((r) =>\n\t\tr.every((v, idx) => v !== finalLineAlignment[idx]),\n\t);\n\tresult.push(finalLineAlignment);\n\n\tassertFn(\n\t\t() =>\n\t\t\tcheckAdjacentItems(\n\t\t\t\tresult.map((r) => r[0]).filter(isDefined),\n\t\t\t\t(a, b) => a < b,\n\t\t\t) &&\n\t\t\tcheckAdjacentItems(\n\t\t\t\tresult.map((r) => r[1]).filter(isDefined),\n\t\t\t\t(a, b) => a <= b,\n\t\t\t) &&\n\t\t\tcheckAdjacentItems(\n\t\t\t\tresult.map((r) => r[2]).filter(isDefined),\n\t\t\t\t(a, b) => a < b,\n\t\t\t) &&\n\t\t\tresult.every(\n\t\t\t\t(alignment) => alignment.filter(isDefined).length >= 2,\n\t\t\t),\n\t);\n\n\treturn result;\n}\ninterface CommonRangeMapping {\n\toutput1Pos: Position | undefined;\n\toutput2Pos: Position | undefined;\n\tinputPos: Position;\n\tlength: TextLength;\n}\n\nfunction toEqualRangeMappings(\n\tdiffs: RangeMapping[],\n\tinputRange: Range,\n\toutputRange: Range,\n): RangeMapping[] {\n\tconst result: RangeMapping[] = [];\n\n\tlet equalRangeInputStart = inputRange.getStartPosition();\n\tlet equalRangeOutputStart = outputRange.getStartPosition();\n\n\tfor (const d of diffs) {\n\t\tconst equalRangeMapping = new RangeMapping(\n\t\t\tRange.fromPositions(\n\t\t\t\tequalRangeInputStart,\n\t\t\t\td.inputRange.getStartPosition(),\n\t\t\t),\n\t\t\tRange.fromPositions(\n\t\t\t\tequalRangeOutputStart,\n\t\t\t\td.outputRange.getStartPosition(),\n\t\t\t),\n\t\t);\n\t\tassertFn(() =>\n\t\t\tlengthOfRange(equalRangeMapping.inputRange).equals(\n\t\t\t\tlengthOfRange(equalRangeMapping.outputRange),\n\t\t\t),\n\t\t);\n\t\tif (!equalRangeMapping.inputRange.isEmpty()) {\n\t\t\tresult.push(equalRangeMapping);\n\t\t}\n\n\t\tequalRangeInputStart = d.inputRange.getEndPosition();\n\t\tequalRangeOutputStart = d.outputRange.getEndPosition();\n\t}\n\n\tconst equalRangeMapping = new RangeMapping(\n\t\tRange.fromPositions(equalRangeInputStart, inputRange.getEndPosition()),\n\t\tRange.fromPositions(\n\t\t\tequalRangeOutputStart,\n\t\t\toutputRange.getEndPosition(),\n\t\t),\n\t);\n\tassertFn(() =>\n\t\tlengthOfRange(equalRangeMapping.inputRange).equals(\n\t\t\tlengthOfRange(equalRangeMapping.outputRange),\n\t\t),\n\t);\n\tif (!equalRangeMapping.inputRange.isEmpty()) {\n\t\tresult.push(equalRangeMapping);\n\t}\n\n\treturn result;\n}\n\n/**\n * It is `result[i][0].inputRange.equals(result[i][1].inputRange)`.\n */\nfunction splitUpCommonEqualRangeMappings(\n\tequalRangeMappings1: RangeMapping[],\n\tequalRangeMappings2: RangeMapping[],\n): CommonRangeMapping[] {\n\tconst result: CommonRangeMapping[] = [];\n\n\tconst events: {\n\t\tinput: 0 | 1;\n\t\tstart: boolean;\n\t\tinputPos: Position;\n\t\toutputPos: Position;\n\t}[] = [];\n\tfor (const [input, rangeMappings] of [\n\t\t[0, equalRangeMappings1],\n\t\t[1, equalRangeMappings2],\n\t] as const) {\n\t\tfor (const rangeMapping of rangeMappings) {\n\t\t\tevents.push({\n\t\t\t\tinput: input,\n\t\t\t\tstart: true,\n\t\t\t\tinputPos: rangeMapping.inputRange.getStartPosition(),\n\t\t\t\toutputPos: rangeMapping.outputRange.getStartPosition(),\n\t\t\t});\n\t\t\tevents.push({\n\t\t\t\tinput: input,\n\t\t\t\tstart: false,\n\t\t\t\tinputPos: rangeMapping.inputRange.getEndPosition(),\n\t\t\t\toutputPos: rangeMapping.outputRange.getEndPosition(),\n\t\t\t});\n\t\t}\n\t}\n\n\tevents.sort(compareBy((m) => m.inputPos, Position.compare));\n\n\tconst starts: [Position | undefined, Position | undefined] = [\n\t\tundefined,\n\t\tundefined,\n\t];\n\tlet lastInputPos: Position | undefined;\n\n\tfor (const event of events) {\n\t\tif (lastInputPos && starts.some((s) => !!s)) {\n\t\t\tconst length = lengthBetweenPositions(lastInputPos, event.inputPos);\n\t\t\tif (!length.isZero()) {\n\t\t\t\tresult.push({\n\t\t\t\t\tinputPos: lastInputPos,\n\t\t\t\t\tlength,\n\t\t\t\t\toutput1Pos: starts[0],\n\t\t\t\t\toutput2Pos: starts[1],\n\t\t\t\t});\n\t\t\t\tif (starts[0]) {\n\t\t\t\t\tstarts[0] = addLength(starts[0], length);\n\t\t\t\t}\n\t\t\t\tif (starts[1]) {\n\t\t\t\t\tstarts[1] = addLength(starts[1], length);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstarts[event.input] = event.start ? event.outputPos : undefined;\n\t\tlastInputPos = event.inputPos;\n\t}\n\n\treturn result;\n}\n"],
  "mappings": "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",
  "names": ["m", "equalRangeMapping"]
}
