{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/mergeEditor/browser/model/lineRange.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport {\n\ttype Comparator,\n\tcompareBy,\n\tnumberComparator,\n} from \"../../../../../base/common/arrays.js\";\nimport { BugIndicatingError } from \"../../../../../base/common/errors.js\";\nimport { Constants } from \"../../../../../base/common/uint.js\";\nimport { Range } from \"../../../../../editor/common/core/range.js\";\nimport type { ITextModel } from \"../../../../../editor/common/model.js\";\n\nexport class LineRange {\n\tpublic static readonly compareByStart: Comparator<LineRange> = compareBy(\n\t\t(l) => l.startLineNumber,\n\t\tnumberComparator,\n\t);\n\n\tpublic static join(ranges: LineRange[]): LineRange | undefined {\n\t\tif (ranges.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tlet startLineNumber = Number.MAX_SAFE_INTEGER;\n\t\tlet endLineNumber = 0;\n\t\tfor (const range of ranges) {\n\t\t\tstartLineNumber = Math.min(startLineNumber, range.startLineNumber);\n\t\t\tendLineNumber = Math.max(\n\t\t\t\tendLineNumber,\n\t\t\t\trange.startLineNumber + range.lineCount,\n\t\t\t);\n\t\t}\n\t\treturn new LineRange(startLineNumber, endLineNumber - startLineNumber);\n\t}\n\n\tstatic fromLineNumbers(\n\t\tstartLineNumber: number,\n\t\tendExclusiveLineNumber: number,\n\t): LineRange {\n\t\treturn new LineRange(\n\t\t\tstartLineNumber,\n\t\t\tendExclusiveLineNumber - startLineNumber,\n\t\t);\n\t}\n\n\tconstructor(\n\t\tpublic readonly startLineNumber: number,\n\t\tpublic readonly lineCount: number,\n\t) {\n\t\tif (lineCount < 0) {\n\t\t\tthrow new BugIndicatingError();\n\t\t}\n\t}\n\n\tpublic join(other: LineRange): LineRange {\n\t\treturn new LineRange(\n\t\t\tMath.min(this.startLineNumber, other.startLineNumber),\n\t\t\tMath.max(\n\t\t\t\tthis.endLineNumberExclusive,\n\t\t\t\tother.endLineNumberExclusive,\n\t\t\t) - this.startLineNumber,\n\t\t);\n\t}\n\n\tpublic get endLineNumberExclusive(): number {\n\t\treturn this.startLineNumber + this.lineCount;\n\t}\n\n\tpublic get isEmpty(): boolean {\n\t\treturn this.lineCount === 0;\n\t}\n\n\t/**\n\t * Returns false if there is at least one line between `this` and `other`.\n\t */\n\tpublic touches(other: LineRange): boolean {\n\t\treturn (\n\t\t\tthis.endLineNumberExclusive >= other.startLineNumber &&\n\t\t\tother.endLineNumberExclusive >= this.startLineNumber\n\t\t);\n\t}\n\n\tpublic isAfter(range: LineRange): boolean {\n\t\treturn this.startLineNumber >= range.endLineNumberExclusive;\n\t}\n\n\tpublic isBefore(range: LineRange): boolean {\n\t\treturn range.startLineNumber >= this.endLineNumberExclusive;\n\t}\n\n\tpublic delta(lineDelta: number): LineRange {\n\t\treturn new LineRange(this.startLineNumber + lineDelta, this.lineCount);\n\t}\n\n\tpublic toString() {\n\t\treturn `[${this.startLineNumber},${this.endLineNumberExclusive})`;\n\t}\n\n\tpublic equals(originalRange: LineRange) {\n\t\treturn (\n\t\t\tthis.startLineNumber === originalRange.startLineNumber &&\n\t\t\tthis.lineCount === originalRange.lineCount\n\t\t);\n\t}\n\n\tpublic contains(lineNumber: number): boolean {\n\t\treturn (\n\t\t\tthis.startLineNumber <= lineNumber &&\n\t\t\tlineNumber < this.endLineNumberExclusive\n\t\t);\n\t}\n\n\tpublic deltaEnd(delta: number): LineRange {\n\t\treturn new LineRange(this.startLineNumber, this.lineCount + delta);\n\t}\n\n\tpublic deltaStart(lineDelta: number): LineRange {\n\t\treturn new LineRange(\n\t\t\tthis.startLineNumber + lineDelta,\n\t\t\tthis.lineCount - lineDelta,\n\t\t);\n\t}\n\n\tpublic getLines(model: ITextModel): string[] {\n\t\tconst result = new Array(this.lineCount);\n\t\tfor (let i = 0; i < this.lineCount; i++) {\n\t\t\tresult[i] = model.getLineContent(this.startLineNumber + i);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic containsRange(range: LineRange): boolean {\n\t\treturn (\n\t\t\tthis.startLineNumber <= range.startLineNumber &&\n\t\t\trange.endLineNumberExclusive <= this.endLineNumberExclusive\n\t\t);\n\t}\n\n\tpublic toRange(): Range {\n\t\treturn new Range(\n\t\t\tthis.startLineNumber,\n\t\t\t1,\n\t\t\tthis.endLineNumberExclusive,\n\t\t\t1,\n\t\t);\n\t}\n\n\tpublic toInclusiveRange(): Range | undefined {\n\t\tif (this.isEmpty) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn new Range(\n\t\t\tthis.startLineNumber,\n\t\t\t1,\n\t\t\tthis.endLineNumberExclusive - 1,\n\t\t\tConstants.MAX_SAFE_SMALL_INTEGER,\n\t\t);\n\t}\n\n\tpublic toInclusiveRangeOrEmpty(): Range {\n\t\tif (this.isEmpty) {\n\t\t\treturn new Range(this.startLineNumber, 1, this.startLineNumber, 1);\n\t\t}\n\t\treturn new Range(\n\t\t\tthis.startLineNumber,\n\t\t\t1,\n\t\t\tthis.endLineNumberExclusive - 1,\n\t\t\tConstants.MAX_SAFE_SMALL_INTEGER,\n\t\t);\n\t}\n\n\tintersects(lineRange: LineRange) {\n\t\treturn (\n\t\t\tthis.startLineNumber <= lineRange.endLineNumberExclusive &&\n\t\t\tlineRange.startLineNumber <= this.endLineNumberExclusive\n\t\t);\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
