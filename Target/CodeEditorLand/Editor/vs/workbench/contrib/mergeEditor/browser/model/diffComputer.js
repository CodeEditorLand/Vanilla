var M=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var L=(r,e,i,o)=>{for(var u=o>1?void 0:o?h(e,i):e,s=r.length-1,g;s>=0;s--)(g=r[s])&&(u=(o?g(e,i,u):g(u))||u);return o&&u&&M(e,i,u),u},c=(r,e)=>(i,o)=>e(i,o,r);import{assertFn as D,checkAdjacentItems as C}from"../../../../../base/common/assert.js";import"../../../../../base/common/observable.js";import"../../../../../editor/common/diff/rangeMapping.js";import"../../../../../editor/common/model.js";import{IEditorWorkerService as E}from"../../../../../editor/common/services/editorWorker.js";import{IConfigurationService as T}from"../../../../../platform/configuration/common/configuration.js";import{LineRange as V}from"./lineRange.js";import{DetailedLineRangeMapping as w,RangeMapping as S}from"./mapping.js";import{observableConfigValue as y}from"../../../../../platform/observable/common/platformObservableUtils.js";import"../../../../../editor/common/core/lineRange.js";let l=class{constructor(e,i){this.editorWorkerService=e;this.configurationService=i}mergeAlgorithm=y("mergeEditor.diffAlgorithm","advanced",this.configurationService).map(e=>e==="smart"?"legacy":e==="experimental"?"advanced":e);async computeDiff(e,i,o){const u=this.mergeAlgorithm.read(o),s=e.getVersionId(),g=i.getVersionId(),R=await this.editorWorkerService.computeDiff(e.uri,i.uri,{ignoreTrimWhitespace:!1,maxComputationTimeMs:0,computeMoves:!1},u);if(!R)throw new Error("Diff computation failed");if(e.isDisposed()||i.isDisposed())return{diffs:null};const p=R.changes.map(n=>new w(b(n.original),e,b(n.modified),i,n.innerChanges?.map(a=>k(a)))),N=e.getVersionId(),I=i.getVersionId();return s!==N||g!==I?{diffs:null}:(D(()=>{for(const n of p){const a=n.inputRange,d=n.outputRange,v=n.inputTextModel,x=n.outputTextModel;for(const t of n.rangeMappings){let m=a.startLineNumber-1<=t.inputRange.startLineNumber&&t.inputRange.endLineNumber<=a.endLineNumberExclusive;m&&t.inputRange.startLineNumber===a.startLineNumber-1&&(m=t.inputRange.endColumn>=v.getLineMaxColumn(t.inputRange.startLineNumber)),m&&t.inputRange.endLineNumber===a.endLineNumberExclusive&&(m=t.inputRange.endColumn===1);let f=d.startLineNumber-1<=t.outputRange.startLineNumber&&t.outputRange.endLineNumber<=d.endLineNumberExclusive;if(f&&t.outputRange.startLineNumber===d.startLineNumber-1&&(f=t.outputRange.endColumn>=x.getLineMaxColumn(t.outputRange.endLineNumber)),f&&t.outputRange.endLineNumber===d.endLineNumberExclusive&&(f=t.outputRange.endColumn===1),!m||!f)return!1}}return p.length===0||p[0].inputRange.startLineNumber===p[0].outputRange.startLineNumber&&C(p,(n,a)=>a.inputRange.startLineNumber-n.inputRange.endLineNumberExclusive===a.outputRange.startLineNumber-n.outputRange.endLineNumberExclusive&&n.inputRange.endLineNumberExclusive<a.inputRange.startLineNumber&&n.outputRange.endLineNumberExclusive<a.outputRange.startLineNumber)}),{diffs:p})}};l=L([c(0,E),c(1,T)],l);function b(r){return new V(r.startLineNumber,r.length)}function k(r){return new S(r.originalRange,r.modifiedRange)}export{l as MergeDiffComputer,b as toLineRange,k as toRangeMapping};
