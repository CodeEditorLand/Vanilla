var h=Object.defineProperty;var I=Object.getOwnPropertyDescriptor;var d=(a,e,i,r)=>{for(var t=r>1?void 0:r?I(e,i):e,o=a.length-1,n;o>=0;o--)(n=a[o])&&(t=(r?n(e,i,t):n(t))||t);return r&&t&&h(e,i,t),t},p=(a,e)=>(i,r)=>e(i,r,a);import{addDisposableListener as S,onDidRegisterWindow as v}from"../../../../base/browser/dom.js";import{mainWindow as y}from"../../../../base/browser/window.js";import{RunOnceScheduler as w}from"../../../../base/common/async.js";import{Event as x}from"../../../../base/common/event.js";import{Disposable as g}from"../../../../base/common/lifecycle.js";import*as b from"../../../../base/common/platform.js";import{EditorAction as T,EditorContributionInstantiation as L,registerEditorAction as D,registerEditorContribution as O}from"../../../../editor/browser/editorExtensions.js";import{EditorOption as m}from"../../../../editor/common/config/editorOptions.js";import{Range as _}from"../../../../editor/common/core/range.js";import{Handler as k}from"../../../../editor/common/editorCommon.js";import{EditorContextKeys as R}from"../../../../editor/common/editorContextKeys.js";import{EndOfLinePreference as A}from"../../../../editor/common/model.js";import*as W from"../../../../nls.js";import{IClipboardService as C}from"../../../../platform/clipboard/common/clipboardService.js";import{IConfigurationService as N}from"../../../../platform/configuration/common/configuration.js";import{WorkbenchPhase as M,registerWorkbenchContribution2 as P}from"../../../common/contributions.js";import{SelectionClipboardContributionID as j}from"../browser/selectionClipboard.js";let s=class extends g{static SELECTION_LENGTH_LIMIT=65536;constructor(e,i){if(super(),b.isLinux){let r=e.getOption(m.selectionClipboard);this._register(e.onDidChangeConfiguration(o=>{o.hasChanged(m.selectionClipboard)&&(r=e.getOption(m.selectionClipboard))}));const t=this._register(new w(()=>{if(!e.hasModel())return;const o=e.getModel();let n=e.getSelections();n=n.slice(0),n.sort(_.compareRangesUsingStarts);let u=0;for(const l of n){if(l.isEmpty())return;u+=o.getValueLengthInRange(l)}if(u>s.SELECTION_LENGTH_LIMIT)return;const f=[];for(const l of n)f.push(o.getValueInRange(l,A.TextDefined));const E=f.join(o.getEOL());i.writeText(E,"selection")},100));this._register(e.onDidChangeCursorSelection(o=>{r&&o.source!=="restoreState"&&t.schedule()}))}}dispose(){super.dispose()}};s=d([p(1,C)],s);let c=class extends g{static ID="workbench.contrib.linuxSelectionClipboardPastePreventer";constructor(e){super(),this._register(x.runAndSubscribe(v,({window:i,disposables:r})=>{r.add(S(i.document,"mouseup",t=>{t.button===1&&(e.getValue("editor").selectionClipboard||t.preventDefault())}))},{window:y,disposables:this._store}))}};c=d([p(0,N)],c);class H extends T{constructor(){super({id:"editor.action.selectionClipboardPaste",label:W.localize("actions.pasteSelectionClipboard","Paste Selection Clipboard"),alias:"Paste Selection Clipboard",precondition:R.writable})}async run(e,i,r){const o=await e.get(C).readText("selection");i.trigger("keyboard",k.Paste,{text:o,pasteOnNewLine:!1,multicursorText:null})}}O(j,s,L.Eager),b.isLinux&&(P(c.ID,c,M.BlockRestore),D(H));export{s as SelectionClipboard};
