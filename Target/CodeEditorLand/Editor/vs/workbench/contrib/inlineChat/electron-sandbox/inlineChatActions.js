import{KeyCode as s,KeyMod as a}from"../../../../base/common/keyCodes.js";import{ContextKeyExpr as C}from"../../../../platform/contextkey/common/contextkey.js";import{KeybindingWeight as h}from"../../../../platform/keybinding/common/keybindingsRegistry.js";import{AbstractInlineChatAction as f,setHoldForSpeech as S}from"../browser/inlineChatActions.js";import{disposableTimeout as I}from"../../../../base/common/async.js";import{EditorContextKeys as u}from"../../../../editor/common/editorContextKeys.js";import{ICommandService as g}from"../../../../platform/commands/common/commands.js";import{IKeybindingService as v}from"../../../../platform/keybinding/common/keybinding.js";import{StartVoiceChatAction as y,StopListeningAction as b,VOICE_KEY_HOLD_THRESHOLD as x}from"../../chat/electron-sandbox/actions/voiceChatActions.js";import{CTX_INLINE_CHAT_VISIBLE as A,InlineChatConfigKeys as E}from"../common/inlineChat.js";import{HasSpeechProvider as H,ISpeechService as K}from"../../speech/common/speechService.js";import{localize2 as T}from"../../../../nls.js";import{IConfigurationService as _}from"../../../../platform/configuration/common/configuration.js";class $ extends f{constructor(){super({id:"inlineChat.holdForSpeech",precondition:C.and(H,A),title:T("holdForSpeech","Hold for Speech"),keybinding:{when:u.textInputFocus,weight:h.WorkbenchContrib,primary:a.CtrlCmd|s.KeyI}})}runInlineChatCommand(o,t,i,...r){d(o,t,this)}}function d(e,o,t){const i=e.get(_),r=e.get(K),l=e.get(v),n=e.get(g);if(!i.getValue(E.HoldToSpeech||!r.hasSpeechProvider))return;const c=l.enableKeybindingHoldMode(t.desc.id);if(!c)return;let m=!1;const p=I(()=>{n.executeCommand(y.ID,{voice:{disableTimeout:!0}}),m=!0},x);c.finally(()=>{m&&n.executeCommand(b.ID).finally(()=>{o.acceptInput()}),p.dispose()})}S(d);export{$ as HoldToSpeak};
