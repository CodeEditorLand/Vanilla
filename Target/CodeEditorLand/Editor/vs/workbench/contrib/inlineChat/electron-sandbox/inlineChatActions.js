import{disposableTimeout as p}from"../../../../base/common/async.js";import{KeyCode as l,KeyMod as h}from"../../../../base/common/keyCodes.js";import{EditorContextKeys as C}from"../../../../editor/common/editorContextKeys.js";import{localize2 as f}from"../../../../nls.js";import{ICommandService as S}from"../../../../platform/commands/common/commands.js";import{IConfigurationService as I}from"../../../../platform/configuration/common/configuration.js";import{ContextKeyExpr as u}from"../../../../platform/contextkey/common/contextkey.js";import{IKeybindingService as y}from"../../../../platform/keybinding/common/keybinding.js";import{KeybindingWeight as g}from"../../../../platform/keybinding/common/keybindingsRegistry.js";import{StartVoiceChatAction as v,StopListeningAction as b,VOICE_KEY_HOLD_THRESHOLD as x}from"../../chat/electron-sandbox/actions/voiceChatActions.js";import{HasSpeechProvider as A,ISpeechService as E}from"../../speech/common/speechService.js";import{AbstractInlineChatAction as H,setHoldForSpeech as K}from"../browser/inlineChatActions.js";import{CTX_INLINE_CHAT_VISIBLE as T,InlineChatConfigKeys as w}from"../common/inlineChat.js";class z extends H{constructor(){super({id:"inlineChat.holdForSpeech",precondition:u.and(A,T),title:f("holdForSpeech","Hold for Speech"),keybinding:{when:C.textInputFocus,weight:g.WorkbenchContrib,primary:h.CtrlCmd|l.KeyI}})}runInlineChatCommand(o,t,i,...r){s(o,t,this)}}function s(e,o,t){const i=e.get(I),r=e.get(E),a=e.get(y),n=e.get(S);if(!i.getValue(w.HoldToSpeech||!r.hasSpeechProvider))return;const c=a.enableKeybindingHoldMode(t.desc.id);if(!c)return;let m=!1;const d=p(()=>{n.executeCommand(v.ID,{voice:{disableTimeout:!0}}),m=!0},x);c.finally(()=>{m&&n.executeCommand(b.ID).finally(()=>{o.acceptInput()}),d.dispose()})}K(s);export{z as HoldToSpeak};
