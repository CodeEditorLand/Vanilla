{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/notebook/common/notebookRange.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * [start, end]\n */\nexport interface ICellRange {\n\t/**\n\t * zero based index\n\t */\n\tstart: number;\n\n\t/**\n\t * zero based index\n\t */\n\tend: number;\n}\n\nexport function isICellRange(candidate: any): candidate is ICellRange {\n\tif (!candidate || typeof candidate !== \"object\") {\n\t\treturn false;\n\t}\n\treturn (\n\t\ttypeof (<ICellRange>candidate).start === \"number\" &&\n\t\ttypeof (<ICellRange>candidate).end === \"number\"\n\t);\n}\n\nexport function cellIndexesToRanges(indexes: number[]) {\n\tindexes.sort((a, b) => a - b);\n\tconst first = indexes.shift();\n\n\tif (first === undefined) {\n\t\treturn [];\n\t}\n\n\treturn indexes\n\t\t.reduce(\n\t\t\t(ranges, num) => {\n\t\t\t\tif (num <= ranges[0][1]) {\n\t\t\t\t\tranges[0][1] = num + 1;\n\t\t\t\t} else {\n\t\t\t\t\tranges.unshift([num, num + 1]);\n\t\t\t\t}\n\t\t\t\treturn ranges;\n\t\t\t},\n\t\t\t[[first, first + 1]],\n\t\t)\n\t\t.reverse()\n\t\t.map((val) => ({ start: val[0], end: val[1] }));\n}\n\nexport function cellRangesToIndexes(ranges: ICellRange[]) {\n\tconst indexes = ranges.reduce((a, b) => {\n\t\tfor (let i = b.start; i < b.end; i++) {\n\t\t\ta.push(i);\n\t\t}\n\n\t\treturn a;\n\t}, [] as number[]);\n\n\treturn indexes;\n}\n\nexport function reduceCellRanges(ranges: ICellRange[]): ICellRange[] {\n\tconst sorted = ranges.sort((a, b) => a.start - b.start);\n\tconst first = sorted[0];\n\n\tif (!first) {\n\t\treturn [];\n\t}\n\n\tconst reduced = sorted.reduce(\n\t\t(prev: ICellRange[], curr) => {\n\t\t\tconst last = prev[prev.length - 1];\n\t\t\tif (last.end >= curr.start) {\n\t\t\t\tlast.end = Math.max(last.end, curr.end);\n\t\t\t} else {\n\t\t\t\tprev.push(curr);\n\t\t\t}\n\t\t\treturn prev;\n\t\t},\n\t\t[first] as ICellRange[],\n\t);\n\n\tif (reduced.length > 1) {\n\t\t// remove the (0, 0) range\n\t\treturn reduced.filter(\n\t\t\t(range) => !(range.start === range.end && range.start === 0),\n\t\t);\n\t}\n\n\treturn reduced;\n}\n\nexport function cellRangesEqual(a: ICellRange[], b: ICellRange[]) {\n\ta = reduceCellRanges(a);\n\tb = reduceCellRanges(b);\n\tif (a.length !== b.length) {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0; i < a.length; i++) {\n\t\tif (a[i].start !== b[i].start || a[i].end !== b[i].end) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * todo@rebornix test and sort\n * @param range\n * @param other\n * @returns\n */\n\nexport function cellRangeContains(\n\trange: ICellRange,\n\tother: ICellRange,\n): boolean {\n\treturn other.start >= range.start && other.end <= range.end;\n}\n"],
  "mappings": ";;AAoBO,SAAS,aAAa,WAAyC;AACrE,MAAI,CAAC,aAAa,OAAO,cAAc,UAAU;AAChD,WAAO;AAAA,EACR;AACA,SACC,OAAoB,UAAW,UAAU,YACzC,OAAoB,UAAW,QAAQ;AAEzC;AARgB;AAUT,SAAS,oBAAoB,SAAmB;AACtD,UAAQ,KAAK,CAAC,GAAG,MAAM,IAAI,CAAC;AAC5B,QAAM,QAAQ,QAAQ,MAAM;AAE5B,MAAI,UAAU,QAAW;AACxB,WAAO,CAAC;AAAA,EACT;AAEA,SAAO,QACL;AAAA,IACA,CAAC,QAAQ,QAAQ;AAChB,UAAI,OAAO,OAAO,CAAC,EAAE,CAAC,GAAG;AACxB,eAAO,CAAC,EAAE,CAAC,IAAI,MAAM;AAAA,MACtB,OAAO;AACN,eAAO,QAAQ,CAAC,KAAK,MAAM,CAAC,CAAC;AAAA,MAC9B;AACA,aAAO;AAAA,IACR;AAAA,IACA,CAAC,CAAC,OAAO,QAAQ,CAAC,CAAC;AAAA,EACpB,EACC,QAAQ,EACR,IAAI,CAAC,SAAS,EAAE,OAAO,IAAI,CAAC,GAAG,KAAK,IAAI,CAAC,EAAE,EAAE;AAChD;AAtBgB;AAwBT,SAAS,oBAAoB,QAAsB;AACzD,QAAM,UAAU,OAAO,OAAO,CAAC,GAAG,MAAM;AACvC,aAAS,IAAI,EAAE,OAAO,IAAI,EAAE,KAAK,KAAK;AACrC,QAAE,KAAK,CAAC;AAAA,IACT;AAEA,WAAO;AAAA,EACR,GAAG,CAAC,CAAa;AAEjB,SAAO;AACR;AAVgB;AAYT,SAAS,iBAAiB,QAAoC;AACpE,QAAM,SAAS,OAAO,KAAK,CAAC,GAAG,MAAM,EAAE,QAAQ,EAAE,KAAK;AACtD,QAAM,QAAQ,OAAO,CAAC;AAEtB,MAAI,CAAC,OAAO;AACX,WAAO,CAAC;AAAA,EACT;AAEA,QAAM,UAAU,OAAO;AAAA,IACtB,CAAC,MAAoB,SAAS;AAC7B,YAAM,OAAO,KAAK,KAAK,SAAS,CAAC;AACjC,UAAI,KAAK,OAAO,KAAK,OAAO;AAC3B,aAAK,MAAM,KAAK,IAAI,KAAK,KAAK,KAAK,GAAG;AAAA,MACvC,OAAO;AACN,aAAK,KAAK,IAAI;AAAA,MACf;AACA,aAAO;AAAA,IACR;AAAA,IACA,CAAC,KAAK;AAAA,EACP;AAEA,MAAI,QAAQ,SAAS,GAAG;AAEvB,WAAO,QAAQ;AAAA,MACd,CAAC,UAAU,EAAE,MAAM,UAAU,MAAM,OAAO,MAAM,UAAU;AAAA,IAC3D;AAAA,EACD;AAEA,SAAO;AACR;AA7BgB;AA+BT,SAAS,gBAAgB,GAAiB,GAAiB;AACjE,MAAI,iBAAiB,CAAC;AACtB,MAAI,iBAAiB,CAAC;AACtB,MAAI,EAAE,WAAW,EAAE,QAAQ;AAC1B,WAAO;AAAA,EACR;AAEA,WAAS,IAAI,GAAG,IAAI,EAAE,QAAQ,KAAK;AAClC,QAAI,EAAE,CAAC,EAAE,UAAU,EAAE,CAAC,EAAE,SAAS,EAAE,CAAC,EAAE,QAAQ,EAAE,CAAC,EAAE,KAAK;AACvD,aAAO;AAAA,IACR;AAAA,EACD;AAEA,SAAO;AACR;AAdgB;AAuBT,SAAS,kBACf,OACA,OACU;AACV,SAAO,MAAM,SAAS,MAAM,SAAS,MAAM,OAAO,MAAM;AACzD;AALgB;",
  "names": []
}
