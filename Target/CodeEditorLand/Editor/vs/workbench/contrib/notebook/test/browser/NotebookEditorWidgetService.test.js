var h=Object.defineProperty;var W=Object.getOwnPropertyDescriptor;var S=(t,e,d,s)=>{for(var n=s>1?void 0:s?W(e,d):e,l=t.length-1,p;l>=0;l--)(p=t[l])&&(n=(s?p(e,d,n):p(n))||n);return s&&n&&h(e,d,n),n},w=(t,e)=>(d,s)=>e(d,s,t);import i from"assert";import{Emitter as I,Event as f}from"../../../../../base/common/event.js";import{DisposableStore as b}from"../../../../../base/common/lifecycle.js";import{URI as D}from"../../../../../base/common/uri.js";import{mock as g}from"../../../../../base/test/common/mock.js";import{ensureNoDisposablesAreLeakedInTestSuite as k}from"../../../../../base/test/common/utils.js";import{IContextKeyService as q}from"../../../../../platform/contextkey/common/contextkey.js";import{IInstantiationService as N}from"../../../../../platform/instantiation/common/instantiation.js";import"../../../../../platform/instantiation/test/common/instantiationServiceMock.js";import"../../../../common/editor.js";import"../../browser/notebookEditorWidget.js";import{NotebookEditorWidgetService as x}from"../../browser/services/notebookEditorServiceImpl.js";import{NotebookEditorInput as C}from"../../common/notebookEditorInput.js";import{setupInstantiationService as P}from"./testNotebookEditor.js";import{IEditorGroupsService as y}from"../../../../services/editor/common/editorGroupsService.js";import{IEditorService as G}from"../../../../services/editor/common/editorService.js";let c=class extends x{constructor(e,d,s,n){super(e,d,s,n)}createWidget(){return new class extends g(){onWillHide=()=>{};getDomNode=()=>({remove:()=>{}});dispose=()=>{}}}};c=S([w(0,y),w(1,G),w(2,q),w(3,N)],c);function m(t,e){return new class extends g(){resource=D.parse(t);get typeId(){return e}}}suite("NotebookEditorWidgetService",()=>{let t,e,d,s,n,l,p;teardown(()=>t.dispose()),k(),setup(()=>{t=new b,n=new I,l=new I,p=new I,d=new class extends g(){id=1;onDidCloseEditor=l.event;onWillMoveEditor=p.event},s=new class extends g(){id=2;onDidCloseEditor=f.None;onWillMoveEditor=f.None},e=P(t),e.stub(y,new class extends g(){onDidRemoveGroup=n.event;onDidAddGroup=f.None;whenReady=Promise.resolve();groups=[d,s];getPart(o){return{windowId:0}}}),e.stub(G,new class extends g(){onDidEditorsChange=f.None})}),test("Retrieve widget within group",async function(){const o=m("/test.np","type1"),u=t.add(e.createInstance(c)),r=u.retrieveWidget(e,1,o),a=r.value,v=u.retrieveWidget(e,1,o);i.notStrictEqual(v.value,void 0,"should create a widget"),i.strictEqual(a,v.value,"should return the same widget"),i.strictEqual(r.value,void 0,"initial borrow should no longer have widget")}),test("Retrieve independent widgets",async function(){const o=m("/test.np","type1"),u=m("/test.np","type2"),r=t.add(e.createInstance(c)),a=r.retrieveWidget(e,1,o),v=r.retrieveWidget(e,2,o),E=r.retrieveWidget(e,1,u);i.notStrictEqual(a.value,void 0,"should create a widget"),i.notStrictEqual(v.value,void 0,"should create a widget"),i.notStrictEqual(E.value,void 0,"should create a widget"),i.notStrictEqual(a.value,v.value,"should return a different widget"),i.notStrictEqual(a.value,E.value,"should return a different widget")}),test("Only relevant widgets get disposed",async function(){const o=m("/test.np","type1"),u=m("/test.np","type2"),r=t.add(e.createInstance(c)),a=r.retrieveWidget(e,1,o),v=r.retrieveWidget(e,1,u),E=r.retrieveWidget(e,2,o);n.fire(d),i.strictEqual(a.value,void 0,"widgets in group should get disposed"),i.strictEqual(v.value,void 0,"widgets in group should get disposed"),i.notStrictEqual(E.value,void 0,"other group should not be disposed")}),test("Widget should move between groups when editor is moved",async function(){const o=m("/test.np",C.ID),u=t.add(e.createInstance(c)),r=u.retrieveWidget(e,1,o).value;await new Promise(E=>setTimeout(E,0)),p.fire({editor:o,groupId:1,target:2});const a=u.retrieveWidget(e,2,o),v=u.retrieveWidget(e,1,o);i.notStrictEqual(r,void 0,"valid widget"),i.strictEqual(a.value,r,"widget should be reused in new group"),i.notStrictEqual(v.value,r,"should create a new widget in the first group")})});
