import t from"assert";import{VSBuffer as d}from"../../../../../base/common/buffer.js";import{CancellationToken as p}from"../../../../../base/common/cancellation.js";import{DisposableStore as z}from"../../../../../base/common/lifecycle.js";import{Mimes as C}from"../../../../../base/common/mime.js";import{URI as v}from"../../../../../base/common/uri.js";import{mock as s}from"../../../../../base/test/common/mock.js";import{ensureNoDisposablesAreLeakedInTestSuite as E}from"../../../../../base/test/common/utils.js";import{TestConfigurationService as T}from"../../../../../platform/configuration/test/common/testConfigurationService.js";import{ExtensionIdentifier as M}from"../../../../../platform/extensions/common/extensions.js";import"../../../../../platform/files/common/files.js";import"../../../../../platform/instantiation/test/common/instantiationServiceMock.js";import"../../../../../platform/log/common/log.js";import"../../../../../platform/telemetry/common/telemetry.js";import{NotebookTextModel as k}from"../../common/model/notebookTextModel.js";import{CellKind as w,NotebookSetting as g}from"../../common/notebookCommon.js";import{NotebookFileWorkingCopyModel as f}from"../../common/notebookEditorModel.js";import{SimpleNotebookProviderInfo as I}from"../../common/notebookService.js";import{setupInstantiationService as O}from"./testNotebookEditor.js";import{SnapshotContext as b}from"../../../../services/workingCopy/common/fileWorkingCopy.js";suite("NotebookFileWorkingCopyModel",function(){let n,u;const r=new T,c=new class extends s(){publicLogError2(){}},m=new class extends s(){};teardown(()=>n.dispose()),E(),setup(()=>{n=new z,u=O(n)}),test("no transient output is send to serializer",async function(){const a=u.createInstance(k,"notebook",v.file("test"),[{cellKind:w.Code,language:"foo",mime:"foo",source:"foo",outputs:[{outputId:"id",outputs:[{mime:C.text,data:d.fromString("Hello Out")}]}]}],{},{transientCellMetadata:{},transientDocumentMetadata:{},cellContentMetadata:{},transientOutputs:!1});{let e=0;await n.add(new f(a,S(a,new class extends s(){options={transientOutputs:!0,transientCellMetadata:{},transientDocumentMetadata:{},cellContentMetadata:{}};async notebookToData(o){return e+=1,t.strictEqual(o.cells.length,1),t.strictEqual(o.cells[0].outputs.length,0),d.fromString("")}}),r,c,m)).snapshot(b.Save,p.None),t.strictEqual(e,1)}{let e=0;await n.add(new f(a,S(a,new class extends s(){options={transientOutputs:!1,transientCellMetadata:{},transientDocumentMetadata:{},cellContentMetadata:{}};async notebookToData(o){return e+=1,t.strictEqual(o.cells.length,1),t.strictEqual(o.cells[0].outputs.length,1),d.fromString("")}}),r,c,m)).snapshot(b.Save,p.None),t.strictEqual(e,1)}}),test("no transient metadata is send to serializer",async function(){const a=u.createInstance(k,"notebook",v.file("test"),[{cellKind:w.Code,language:"foo",mime:"foo",source:"foo",outputs:[]}],{foo:123,bar:456},{transientCellMetadata:{},transientDocumentMetadata:{},cellContentMetadata:{},transientOutputs:!1});n.add(a);{let e=0;await n.add(new f(a,S(a,new class extends s(){options={transientOutputs:!0,transientCellMetadata:{},transientDocumentMetadata:{bar:!0},cellContentMetadata:{}};async notebookToData(o){return e+=1,t.strictEqual(o.metadata.foo,123),t.strictEqual(o.metadata.bar,void 0),d.fromString("")}}),r,c,m)).snapshot(b.Save,p.None),t.strictEqual(e,1)}{let e=0;await n.add(new f(a,S(a,new class extends s(){options={transientOutputs:!1,transientCellMetadata:{},transientDocumentMetadata:{},cellContentMetadata:{}};async notebookToData(o){return e+=1,t.strictEqual(o.metadata.foo,123),t.strictEqual(o.metadata.bar,456),d.fromString("")}}),r,c,m)).snapshot(b.Save,p.None),t.strictEqual(e,1)}}),test("no transient cell metadata is send to serializer",async function(){const a=u.createInstance(k,"notebook",v.file("test"),[{cellKind:w.Code,language:"foo",mime:"foo",source:"foo",outputs:[],metadata:{foo:123,bar:456}}],{},{transientCellMetadata:{},transientDocumentMetadata:{},cellContentMetadata:{},transientOutputs:!1});n.add(a);{let e=0;await n.add(new f(a,S(a,new class extends s(){options={transientOutputs:!0,transientDocumentMetadata:{},transientCellMetadata:{bar:!0},cellContentMetadata:{}};async notebookToData(o){return e+=1,t.strictEqual(o.cells[0].metadata.foo,123),t.strictEqual(o.cells[0].metadata.bar,void 0),d.fromString("")}}),r,c,m)).snapshot(b.Save,p.None),t.strictEqual(e,1)}{let e=0;await n.add(new f(a,S(a,new class extends s(){options={transientOutputs:!1,transientCellMetadata:{},transientDocumentMetadata:{},cellContentMetadata:{}};async notebookToData(o){return e+=1,t.strictEqual(o.cells[0].metadata.foo,123),t.strictEqual(o.cells[0].metadata.bar,456),d.fromString("")}}),r,c,m)).snapshot(b.Save,p.None),t.strictEqual(e,1)}}),test("Notebooks with outputs beyond the size threshold will throw for backup snapshots",async function(){await r.setUserConfiguration(g.outputBackupSizeLimit,100*1/1024);const e={outputId:"123",outputs:[{mime:C.text,data:d.fromString("a".repeat(101))}]},i=u.createInstance(k,"notebook",v.file("test"),[{cellKind:w.Code,language:"foo",mime:"foo",source:"foo",outputs:[e],metadata:{foo:123,bar:456}}],{},{transientCellMetadata:{},transientDocumentMetadata:{},cellContentMetadata:{},transientOutputs:!1});n.add(i);let o=0;const N=n.add(new f(i,S(i,new class extends s(){options={transientOutputs:!0,transientDocumentMetadata:{},transientCellMetadata:{bar:!0},cellContentMetadata:{}};async notebookToData(l){return o+=1,t.strictEqual(l.cells[0].metadata.foo,123),t.strictEqual(l.cells[0].metadata.bar,void 0),d.fromString("")}}),r,c,m));try{await N.snapshot(b.Backup,p.None),t.fail("Expected snapshot to throw an error for large output")}catch(l){t.notEqual(l.code,"ERR_ASSERTION",l.message)}await N.snapshot(b.Save,p.None),t.strictEqual(o,1)}),test("Notebook model will not return a save delegate if the serializer has not been retreived",async function(){const a=u.createInstance(k,"notebook",v.file("test"),[{cellKind:w.Code,language:"foo",mime:"foo",source:"foo",outputs:[],metadata:{foo:123,bar:456}}],{},{transientCellMetadata:{},transientDocumentMetadata:{},cellContentMetadata:{},transientOutputs:!1});n.add(a);const e=new class extends s(){save(){return Promise.resolve({name:"savedFile"})}};e.test="yes";let i=()=>{};const o=new Promise(y=>{i=y}),N=S(a,o);r.setUserConfiguration(g.remoteSaving,!0);const l=n.add(new f(a,N,r,c,m)),D=l.save;t.strictEqual(D,void 0),i(e),await l.getNotebookSerializer();const h=await l.save?.({},{});t.strictEqual(h.name,"savedFile")})});function S(n,u){return new class extends s(){serializer=void 0;async withNotebookDataProvider(r){return this.serializer=await u,new I(n.viewType,this.serializer,{id:new M("test"),location:void 0})}tryGetDataProviderSync(r){if(this.serializer)return new I(n.viewType,this.serializer,{id:new M("test"),location:void 0})}}}
