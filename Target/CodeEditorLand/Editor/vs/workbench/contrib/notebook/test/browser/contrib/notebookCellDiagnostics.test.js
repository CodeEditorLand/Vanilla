import a from"assert";import{Emitter as p,Event as E}from"../../../../../../base/common/event.js";import{DisposableStore as v}from"../../../../../../base/common/lifecycle.js";import{ResourceMap as I}from"../../../../../../base/common/map.js";import{waitForState as m}from"../../../../../../base/common/observable.js";import"../../../../../../base/common/uri.js";import{mock as C}from"../../../../../../base/test/common/mock.js";import{ensureNoDisposablesAreLeakedInTestSuite as S}from"../../../../../../base/test/common/utils.js";import{IConfigurationService as k}from"../../../../../../platform/configuration/common/configuration.js";import"../../../../../../platform/configuration/test/common/testConfigurationService.js";import"../../../../../../platform/instantiation/test/common/instantiationServiceMock.js";import{IMarkerService as b}from"../../../../../../platform/markers/common/markers.js";import{ChatAgentLocation as w,IChatAgentService as M}from"../../../../chat/common/chatAgents.js";import{CellDiagnostics as f}from"../../../browser/contrib/cellDiagnostics/cellDiagnosticEditorContrib.js";import"../../../browser/viewModel/codeCellViewModel.js";import{CellKind as g,NotebookSetting as D}from"../../../common/notebookCommon.js";import{INotebookExecutionStateService as N,NotebookExecutionType as y}from"../../../common/notebookExecutionStateService.js";import{setupInstantiationService as A,TestNotebookExecutionStateService as T,withTestNotebook as x}from"../testNotebookEditor.js";import{nullExtensionDescription as L}from"../../../../../services/extensions/common/extensions.js";suite("notebookCellDiagnostics",()=>{let r,s,i,c;teardown(()=>{s.dispose()}),S();class h extends T{_onDidChangeExecution=new p;onDidChangeExecution=this._onDidChangeExecution.event;fireExecutionChanged(n,u,d){this._onDidChangeExecution.fire({type:y.cell,cellHandle:u,notebook:n,affectsNotebook:()=>!0,affectsCell:()=>!0,changed:d})}}setup(function(){s=new v,r=A(s),i=new h,r.stub(N,i);const t={extensionId:L.identifier,extensionDisplayName:"",extensionPublisherId:"",name:"testEditorAgent",isDefault:!0,locations:[w.Editor],metadata:{},slashCommands:[],disambiguation:[]},n=new class extends C(){getAgents(){return[{id:"testEditorAgent",...t}]}onDidChangeAgents=E.None};r.stub(M,n),c=new class extends C(){markers=new I;changeOne(d,e,o){this.markers.set(e,o)}},r.stub(b,c),r.get(k).setUserConfiguration(D.cellFailureDiagnostics,!0)}),test("diagnostic is added for cell execution failure",async function(){await x([["print(x)","python",g.Code,[],{}]],async(t,n,u,d)=>{const e=n.viewCells[0];s.add(r.createInstance(f,t)),e.model.internalMetadata.error={message:"error",stack:"line 1 : print(x)",uri:e.uri,location:{startColumn:1,endColumn:5,startLineNumber:1,endLineNumber:1}},i.fireExecutionChanged(t.textModel.uri,e.handle),await m(e.excecutionError,o=>!!o),a.strictEqual(e?.excecutionError.get()?.message,"error"),a.equal(c.markers.get(e.uri)?.length,1)},r)}),test("diagnostics are cleared only for cell with new execution",async function(){await x([["print(x)","python",g.Code,[],{}],["print(y)","python",g.Code,[],{}]],async(t,n,u,d)=>{const e=n.viewCells[0],o=n.viewCells[1];s.add(r.createInstance(f,t)),e.model.internalMetadata.error={message:"error",stack:"line 1 : print(x)",uri:e.uri,location:{startColumn:1,endColumn:5,startLineNumber:1,endLineNumber:1}},o.model.internalMetadata.error={message:"another error",stack:"line 1 : print(y)",uri:e.uri,location:{startColumn:1,endColumn:5,startLineNumber:1,endLineNumber:1}},i.fireExecutionChanged(t.textModel.uri,e.handle),i.fireExecutionChanged(t.textModel.uri,o.handle),await m(e.excecutionError,l=>!!l),await m(o.excecutionError,l=>!!l),e.model.internalMetadata.error=void 0,i.fireExecutionChanged(t.textModel.uri,e.handle,{}),await m(e.excecutionError,l=>l===void 0),a.strictEqual(e?.excecutionError.get(),void 0),a.strictEqual(o?.excecutionError.get()?.message,"another error","cell that was not executed should still have an error"),a.equal(c.markers.get(e.uri)?.length,0),a.equal(c.markers.get(o.uri)?.length,1)},r)})});
