import e from"assert";import{CancellationToken as c}from"../../../../../../base/common/cancellation.js";import{mock as b}from"../../../../../../base/test/common/mock.js";import{ensureNoDisposablesAreLeakedInTestSuite as f}from"../../../../../../base/test/common/utils.js";import"../../../../../../editor/common/model.js";import"../../../../../../editor/contrib/documentSymbols/browser/outlineModel.js";import"../../../browser/notebookBrowser.js";import{NotebookOutlineEntryFactory as u}from"../../../browser/viewModel/notebookOutlineEntryFactory.js";import"../../../common/notebookExecutionStateService.js";import"../testNotebookEditor.js";import"../../../../../../editor/common/services/resolverService.js";import"../../../../../../base/common/uri.js";import"../../../../../../base/common/lifecycle.js";suite("Notebook Symbols",function(){f();const g={};function r(o,n="textId"){g[n]=o}const a=new class extends b(){getCellExecution(){}};class v{constructor(n){this.textId=n}getTopLevelSymbols(){return g[this.textId]}}const i=new class extends b(){getOrCreate(o,n){const t=new v(o.id);return Promise.resolve(t)}getDebounceValue(o){return 0}},s=new class extends b(){createModelReference(o){return Promise.resolve({object:{textEditorModel:{id:o.toString(),getVersionId(){return 1}}},dispose(){}})}};function l(o=1,n="textId"){return{id:n,uri:{toString(){return n}},textBuffer:{getLineCount(){return 0}},getText(){return"# code"},model:{textModel:{id:n,getVersionId(){return o}}},resolveTextModel(){return this.model.textModel}}}test("Cell without symbols cache",function(){r([{name:"var",range:{}}]);const n=new u(a,i,s).getOutlineEntries(l(),0);e.equal(n.length,1,"no entries created"),e.equal(n[0].label,"# code","entry should fall back to first line of cell")}),test("Cell with simple symbols",async function(){r([{name:"var1",range:{}},{name:"var2",range:{}}]);const o=new u(a,i,s),n=l();await o.cacheSymbols(n,c.None);const t=o.getOutlineEntries(n,0);e.equal(t.length,3,"wrong number of outline entries"),e.equal(t[0].label,"# code"),e.equal(t[1].label,"var1"),e.equal(t[1].level,8),e.equal(t[1].index,1),e.equal(t[2].label,"var2"),e.equal(t[2].level,8),e.equal(t[2].index,2)}),test("Cell with nested symbols",async function(){r([{name:"root1",range:{},children:[{name:"nested1",range:{}},{name:"nested2",range:{}}]},{name:"root2",range:{},children:[{name:"nested1",range:{}}]}]);const o=new u(a,i,s),n=l();await o.cacheSymbols(n,c.None);const t=o.getOutlineEntries(l(),0);e.equal(t.length,6,"wrong number of outline entries"),e.equal(t[0].label,"# code"),e.equal(t[1].label,"root1"),e.equal(t[1].level,8),e.equal(t[2].label,"nested1"),e.equal(t[2].level,9),e.equal(t[3].label,"nested2"),e.equal(t[3].level,9),e.equal(t[4].label,"root2"),e.equal(t[4].level,8),e.equal(t[5].label,"nested1"),e.equal(t[5].level,9)}),test("Multiple Cells with symbols",async function(){r([{name:"var1",range:{}}],"$1"),r([{name:"var2",range:{}}],"$2");const o=new u(a,i,s),n=l(1,"$1"),t=l(1,"$2");await o.cacheSymbols(n,c.None),await o.cacheSymbols(t,c.None);const d=o.getOutlineEntries(l(1,"$1"),0),m=o.getOutlineEntries(l(1,"$2"),0);e.equal(d.length,2,"wrong number of outline entries"),e.equal(d[0].label,"# code"),e.equal(d[1].label,"var1"),e.equal(m.length,2,"wrong number of outline entries"),e.equal(m[0].label,"# code"),e.equal(m[1].label,"var2")})});
