import l from"assert";import"../../../../../../base/browser/ui/tree/tree.js";import{CancellationToken as S}from"../../../../../../base/common/cancellation.js";import"../../../../../../base/common/lifecycle.js";import{mock as q}from"../../../../../../base/test/common/mock.js";import{ensureNoDisposablesAreLeakedInTestSuite as I}from"../../../../../../base/test/common/utils.js";import"../../../../../../editor/common/model.js";import"../../../../../../editor/contrib/documentSymbols/browser/outlineModel.js";import{TestConfigurationService as N}from"../../../../../../platform/configuration/test/common/testConfigurationService.js";import{TestThemeService as T}from"../../../../../../platform/theme/test/common/testThemeService.js";import{NotebookBreadcrumbsProvider as x,NotebookOutlinePaneProvider as $,NotebookQuickPickProvider as P}from"../../../browser/contrib/outline/notebookOutline.js";import"../../../browser/notebookBrowser.js";import"../../../browser/viewModel/notebookOutlineDataSource.js";import{NotebookOutlineEntryFactory as k}from"../../../browser/viewModel/notebookOutlineEntryFactory.js";import{OutlineEntry as C}from"../../../browser/viewModel/OutlineEntry.js";import"../../../common/notebookExecutionStateService.js";import"../testNotebookEditor.js";import"../../../../../../editor/common/services/resolverService.js";import"../../../../../../base/common/uri.js";suite("Notebook Outline View Providers",function(){const f=I(),u=new N,g=new T,M={};function r(o,a="textId"){M[a]=o}const m=new class extends q(){getCellExecution(){}};class E{constructor(a){this.textId=a}getTopLevelSymbols(){return M[this.textId]}}const w=new class extends q(){getOrCreate(o,a){const t=new E(o.id);return Promise.resolve(t)}getDebounceValue(o){return 0}},b=new class extends q(){createModelReference(o){return Promise.resolve({object:{textEditorModel:{id:o.toString(),getVersionId(){return 1}}},dispose(){}})}};function s(o=1,a="# code",t="textId"){return{uri:{toString(){return t}},id:t,textBuffer:{getLineCount(){return 0}},getText(){return a},model:{textModel:{id:t,getVersionId(){return o}}},resolveTextModel(){return this.model.textModel},cellKind:2}}function v(o,a=void 0){return new class extends q(){object={entries:o,activeElement:a}}}function d(o=1,a="markup",t="textId",c=1){return{textBuffer:{getLineCount(){return 0}},getText(){return a},getAlternativeId(){return c},model:{textModel:{id:t,getVersionId(){return o}}},resolveTextModel(){return this.model.textModel},cellKind:1}}function y(o,a){const t=[],c=a.getChildren(o);for(const e of c)t.push(e),t.push(...y(e,a));return t}function p(o){if(o.length>0){const a=[o[0]],t=[o[0]];for(let c=1;c<o.length;c++){const e=o[c];for(;;){const n=t.length;if(n===0){a.push(e),t.push(e);break}else{const i=t[n-1];if(i.level<e.level){i.addChild(e),t.push(e);break}else t.pop()}}}return a}}async function h(o){await u.setUserConfiguration("notebook.outline.showMarkdownHeadersOnly",o.outlineShowMarkdownHeadersOnly),await u.setUserConfiguration("notebook.outline.showCodeCells",o.outlineShowCodeCells),await u.setUserConfiguration("notebook.outline.showCodeCellSymbols",o.outlineShowCodeCellSymbols),await u.setUserConfiguration("notebook.gotoSymbols.showAllSymbols",o.quickPickShowAllSymbols),await u.setUserConfiguration("notebook.breadcrumbs.showCodeCells",o.breadcrumbsShowCodeCells)}test("OutlinePane 0: Default Settings (Headers Only ON, Code cells OFF, Symbols ON)",async function(){await h({outlineShowMarkdownHeadersOnly:!0,outlineShowCodeCells:!1,outlineShowCodeCellSymbols:!0,quickPickShowAllSymbols:!1,breadcrumbsShowCodeCells:!1});const o=[d(1,"# h1","$0",0),d(1,"plaintext","$1",0),s(1,"# code cell 2","$2"),s(1,"# code cell 3","$3")];r([],"$0"),r([],"$1"),r([{name:"var2",range:{}}],"$2"),r([{name:"var3",range:{}}],"$3");const a=new k(m,w,b);for(const n of o)await a.cacheSymbols(n,S.None);const t=new C(-1,-1,s(),"fakeRoot",!1,!1,void 0,void 0);for(const n of o)a.getOutlineEntries(n,0).forEach(i=>t.addChild(i));const c=f.add(new $(void 0,u)),e=y(t,c);l.equal(e.length,1),l.equal(e[0].label,"h1"),l.equal(e[0].level,1)}),test("OutlinePane 1: ALL Markdown",async function(){await h({outlineShowMarkdownHeadersOnly:!1,outlineShowCodeCells:!1,outlineShowCodeCellSymbols:!1,quickPickShowAllSymbols:!1,breadcrumbsShowCodeCells:!1});const o=[d(1,"# h1","$0",0),d(1,"plaintext","$1",0),s(1,"# code cell 2","$2"),s(1,"# code cell 3","$3")];r([],"$0"),r([],"$1"),r([{name:"var2",range:{}}],"$2"),r([{name:"var3",range:{}}],"$3");const a=new k(m,w,b);for(const n of o)await a.cacheSymbols(n,S.None);const t=new C(-1,-1,s(),"fakeRoot",!1,!1,void 0,void 0);for(const n of o)a.getOutlineEntries(n,0).forEach(i=>t.addChild(i));const c=f.add(new $(void 0,u)),e=y(t,c);l.equal(e.length,2),l.equal(e[0].label,"h1"),l.equal(e[0].level,1),l.equal(e[1].label,"plaintext"),l.equal(e[1].level,7)}),test("OutlinePane 2: Only Headers",async function(){await h({outlineShowMarkdownHeadersOnly:!0,outlineShowCodeCells:!1,outlineShowCodeCellSymbols:!1,quickPickShowAllSymbols:!1,breadcrumbsShowCodeCells:!1});const o=[d(1,"# h1","$0",0),d(1,"plaintext","$1",0),s(1,"# code cell 2","$2"),s(1,"# code cell 3","$3")];r([],"$0"),r([],"$1"),r([{name:"var2",range:{}}],"$2"),r([{name:"var3",range:{}}],"$3");const a=new k(m,w,b);for(const n of o)await a.cacheSymbols(n,S.None);const t=new C(-1,-1,s(),"fakeRoot",!1,!1,void 0,void 0);for(const n of o)a.getOutlineEntries(n,0).forEach(i=>t.addChild(i));const c=f.add(new $(void 0,u)),e=y(t,c);l.equal(e.length,1),l.equal(e[0].label,"h1"),l.equal(e[0].level,1)}),test("OutlinePane 3: Only Headers + Code Cells",async function(){await h({outlineShowMarkdownHeadersOnly:!0,outlineShowCodeCells:!0,outlineShowCodeCellSymbols:!1,quickPickShowAllSymbols:!1,breadcrumbsShowCodeCells:!1});const o=[d(1,"# h1","$0",0),d(1,"plaintext","$1",0),s(1,"# code cell 2","$2"),s(1,"# code cell 3","$3")];r([],"$0"),r([],"$1"),r([{name:"var2",range:{}}],"$2"),r([{name:"var3",range:{}}],"$3");const a=new k(m,w,b);for(const n of o)await a.cacheSymbols(n,S.None);const t=new C(-1,-1,s(),"fakeRoot",!1,!1,void 0,void 0);for(const n of o)a.getOutlineEntries(n,0).forEach(i=>t.addChild(i));const c=f.add(new $(void 0,u)),e=y(t,c);l.equal(e.length,3),l.equal(e[0].label,"h1"),l.equal(e[0].level,1),l.equal(e[1].label,"# code cell 2"),l.equal(e[1].level,7),l.equal(e[2].label,"# code cell 3"),l.equal(e[2].level,7)}),test("OutlinePane 4: Only Headers + Code Cells + Symbols",async function(){await h({outlineShowMarkdownHeadersOnly:!0,outlineShowCodeCells:!0,outlineShowCodeCellSymbols:!0,quickPickShowAllSymbols:!1,breadcrumbsShowCodeCells:!1});const o=[d(1,"# h1","$0",0),d(1,"plaintext","$1",0),s(1,"# code cell 2","$2"),s(1,"# code cell 3","$3")];r([],"$0"),r([],"$1"),r([{name:"var2",range:{}}],"$2"),r([{name:"var3",range:{}}],"$3");const a=new k(m,w,b);for(const n of o)await a.cacheSymbols(n,S.None);const t=new C(-1,-1,s(),"fakeRoot",!1,!1,void 0,void 0);for(const n of o)a.getOutlineEntries(n,0).forEach(i=>t.addChild(i));const c=f.add(new $(void 0,u)),e=y(t,c);l.equal(e.length,5),l.equal(e[0].label,"h1"),l.equal(e[0].level,1),l.equal(e[1].label,"# code cell 2"),l.equal(e[1].level,7),l.equal(e[2].label,"var2"),l.equal(e[2].level,8),l.equal(e[3].label,"# code cell 3"),l.equal(e[3].level,7),l.equal(e[4].label,"var3"),l.equal(e[4].level,8)}),test("QuickPick 0: Symbols On + 2 cells WITH symbols",async function(){await h({outlineShowMarkdownHeadersOnly:!1,outlineShowCodeCells:!1,outlineShowCodeCellSymbols:!1,quickPickShowAllSymbols:!0,breadcrumbsShowCodeCells:!1});const o=[d(1,"# h1","$0",0),d(1,"plaintext","$1",0),s(1,"# code cell 2","$2"),s(1,"# code cell 3","$3")];r([],"$0"),r([],"$1"),r([{name:"var2",range:{},kind:12}],"$2"),r([{name:"var3",range:{},kind:12}],"$3");const a=new k(m,w,b);for(const n of o)await a.cacheSymbols(n,S.None);const t=new C(-1,-1,s(),"fakeRoot",!1,!1,void 0,void 0);for(const n of o)a.getOutlineEntries(n,0).forEach(i=>t.addChild(i));const e=f.add(new P(v([...t.children]),u,g)).getQuickPickElements();l.equal(e.length,4),l.equal(e[0].label,"$(markdown) h1"),l.equal(e[0].element.level,1),l.equal(e[1].label,"$(markdown) plaintext"),l.equal(e[1].element.level,7),l.equal(e[2].label,"$(symbol-variable) var2"),l.equal(e[2].element.level,8),l.equal(e[3].label,"$(symbol-variable) var3"),l.equal(e[3].element.level,8)}),test("QuickPick 1: Symbols On + 1 cell WITH symbol + 1 cell WITHOUT symbol",async function(){await h({outlineShowMarkdownHeadersOnly:!1,outlineShowCodeCells:!1,outlineShowCodeCellSymbols:!1,quickPickShowAllSymbols:!0,breadcrumbsShowCodeCells:!1});const o=[d(1,"# h1","$0",0),d(1,"plaintext","$1",0),s(1,"# code cell 2","$2"),s(1,"# code cell 3","$3")];r([],"$0"),r([],"$1"),r([],"$2"),r([{name:"var3",range:{},kind:12}],"$3");const a=new k(m,w,b);for(const n of o)await a.cacheSymbols(n,S.None);const t=new C(-1,-1,s(),"fakeRoot",!1,!1,void 0,void 0);for(const n of o)a.getOutlineEntries(n,0).forEach(i=>t.addChild(i));const e=f.add(new P(v([...t.children]),u,g)).getQuickPickElements();l.equal(e.length,4),l.equal(e[0].label,"$(markdown) h1"),l.equal(e[0].element.level,1),l.equal(e[1].label,"$(markdown) plaintext"),l.equal(e[1].element.level,7),l.equal(e[2].label,"$(code) # code cell 2"),l.equal(e[2].element.level,7),l.equal(e[3].label,"$(symbol-variable) var3"),l.equal(e[3].element.level,8)}),test("QuickPick 3: Symbols Off",async function(){await h({outlineShowMarkdownHeadersOnly:!1,outlineShowCodeCells:!1,outlineShowCodeCellSymbols:!1,quickPickShowAllSymbols:!1,breadcrumbsShowCodeCells:!1});const o=[d(1,"# h1","$0",0),d(1,"plaintext","$1",0),s(1,"# code cell 2","$2"),s(1,"# code cell 3","$3")];r([],"$0"),r([],"$1"),r([{name:"var2",range:{},kind:12}],"$2"),r([{name:"var3",range:{},kind:12}],"$3");const a=new k(m,w,b);for(const n of o)await a.cacheSymbols(n,S.None);const t=new C(-1,-1,s(),"fakeRoot",!1,!1,void 0,void 0);for(const n of o)a.getOutlineEntries(n,0).forEach(i=>t.addChild(i));const e=f.add(new P(v([...t.children]),u,g)).getQuickPickElements();l.equal(e.length,4),l.equal(e[0].label,"$(markdown) h1"),l.equal(e[0].element.level,1),l.equal(e[1].label,"$(markdown) plaintext"),l.equal(e[1].element.level,7),l.equal(e[2].label,"$(code) # code cell 2"),l.equal(e[2].element.level,7),l.equal(e[3].label,"$(code) # code cell 3"),l.equal(e[3].element.level,7)}),test("Breadcrumbs 0: Code Cells On ",async function(){await h({outlineShowMarkdownHeadersOnly:!1,outlineShowCodeCells:!1,outlineShowCodeCellSymbols:!1,quickPickShowAllSymbols:!1,breadcrumbsShowCodeCells:!0});const o=[d(1,"# h1","$0",0),d(1,"plaintext","$1",0),s(1,"# code cell 2","$2"),s(1,"# code cell 3","$3")];r([],"$0"),r([],"$1"),r([{name:"var2",range:{},kind:12}],"$2"),r([{name:"var3",range:{},kind:12}],"$3");const a=new k(m,w,b);for(const i of o)await a.cacheSymbols(i,S.None);const t=new C(-1,-1,d(),"fakeRoot",!1,!1,void 0,void 0);for(const i of o)a.getOutlineEntries(i,0).forEach(O=>t.addChild(O));const c=p([...t.children]),n=f.add(new x(v([],[...c[0].children][1]),u)).getBreadcrumbElements();l.equal(n.length,3),l.equal(n[0].label,"fakeRoot"),l.equal(n[0].level,-1),l.equal(n[1].label,"h1"),l.equal(n[1].level,1),l.equal(n[2].label,"# code cell 2"),l.equal(n[2].level,7)}),test("Breadcrumbs 1: Code Cells Off ",async function(){await h({outlineShowMarkdownHeadersOnly:!1,outlineShowCodeCells:!1,outlineShowCodeCellSymbols:!1,quickPickShowAllSymbols:!1,breadcrumbsShowCodeCells:!1});const o=[d(1,"# h1","$0",0),d(1,"plaintext","$1",0),s(1,"# code cell 2","$2"),s(1,"# code cell 3","$3")];r([],"$0"),r([],"$1"),r([{name:"var2",range:{},kind:12}],"$2"),r([{name:"var3",range:{},kind:12}],"$3");const a=new k(m,w,b);for(const i of o)await a.cacheSymbols(i,S.None);const t=new C(-1,-1,d(),"fakeRoot",!1,!1,void 0,void 0);for(const i of o)a.getOutlineEntries(i,0).forEach(O=>t.addChild(O));const c=p([...t.children]),n=f.add(new x(v([],[...c[0].children][1]),u)).getBreadcrumbElements();l.equal(n.length,2),l.equal(n[0].label,"fakeRoot"),l.equal(n[0].level,-1),l.equal(n[1].label,"h1"),l.equal(n[1].level,1)})});
