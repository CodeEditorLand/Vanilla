{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/notebook/browser/viewModel/notebookOutlineDataSource.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { CancellationToken } from \"../../../../../base/common/cancellation.js\";\nimport { Emitter, type Event } from \"../../../../../base/common/event.js\";\nimport {\n\tDisposableStore,\n\tMutableDisposable,\n} from \"../../../../../base/common/lifecycle.js\";\nimport { isEqual } from \"../../../../../base/common/resources.js\";\nimport type { URI } from \"../../../../../base/common/uri.js\";\nimport { IConfigurationService } from \"../../../../../platform/configuration/common/configuration.js\";\nimport { IMarkerService } from \"../../../../../platform/markers/common/markers.js\";\nimport {\n\ttype OutlineChangeEvent,\n\tOutlineConfigKeys,\n} from \"../../../../services/outline/browser/outline.js\";\nimport { CellKind } from \"../../common/notebookCommon.js\";\nimport type {\n\tIActiveNotebookEditor,\n\tINotebookEditor,\n} from \"../notebookBrowser.js\";\nimport type { OutlineEntry } from \"./OutlineEntry.js\";\nimport {\n\tINotebookOutlineEntryFactory,\n\ttype NotebookOutlineEntryFactory,\n} from \"./notebookOutlineEntryFactory.js\";\n\nexport interface INotebookCellOutlineDataSource {\n\treadonly activeElement: OutlineEntry | undefined;\n\treadonly entries: OutlineEntry[];\n}\n\nexport class NotebookCellOutlineDataSource\n\timplements INotebookCellOutlineDataSource\n{\n\tprivate readonly _disposables = new DisposableStore();\n\n\tprivate readonly _onDidChange = new Emitter<OutlineChangeEvent>();\n\treadonly onDidChange: Event<OutlineChangeEvent> = this._onDidChange.event;\n\n\tprivate _uri: URI | undefined;\n\tprivate _entries: OutlineEntry[] = [];\n\tprivate _activeEntry?: OutlineEntry;\n\n\tconstructor(\n\t\tprivate readonly _editor: INotebookEditor,\n\t\t@IMarkerService private readonly _markerService: IMarkerService,\n\t\t@IConfigurationService private readonly _configurationService: IConfigurationService,\n\t\t@INotebookOutlineEntryFactory private readonly _outlineEntryFactory: NotebookOutlineEntryFactory\n\t) {\n\t\tthis.recomputeState();\n\t}\n\n\tget activeElement(): OutlineEntry | undefined {\n\t\treturn this._activeEntry;\n\t}\n\tget entries(): OutlineEntry[] {\n\t\treturn this._entries;\n\t}\n\tget isEmpty(): boolean {\n\t\treturn this._entries.length === 0;\n\t}\n\tget uri() {\n\t\treturn this._uri;\n\t}\n\n\tpublic async computeFullSymbols(cancelToken: CancellationToken) {\n\t\tconst notebookEditorWidget = this._editor;\n\n\t\tconst notebookCells = notebookEditorWidget\n\t\t\t?.getViewModel()\n\t\t\t?.viewCells.filter((cell) => cell.cellKind === CellKind.Code);\n\n\t\tif (notebookCells) {\n\t\t\tconst promises: Promise<void>[] = [];\n\t\t\t// limit the number of cells so that we don't resolve an excessive amount of text models\n\t\t\tfor (const cell of notebookCells.slice(0, 50)) {\n\t\t\t\t// gather all symbols asynchronously\n\t\t\t\tpromises.push(\n\t\t\t\t\tthis._outlineEntryFactory.cacheSymbols(cell, cancelToken),\n\t\t\t\t);\n\t\t\t}\n\t\t\tawait Promise.allSettled(promises);\n\t\t}\n\t\tthis.recomputeState();\n\t}\n\n\tpublic recomputeState(): void {\n\t\tthis._disposables.clear();\n\t\tthis._activeEntry = undefined;\n\t\tthis._uri = undefined;\n\n\t\tif (!this._editor.hasModel()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._uri = this._editor.textModel.uri;\n\n\t\tconst notebookEditorWidget: IActiveNotebookEditor = this._editor;\n\n\t\tif (notebookEditorWidget.getLength() === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst notebookCells = notebookEditorWidget.getViewModel().viewCells;\n\n\t\tconst entries: OutlineEntry[] = [];\n\t\tfor (const cell of notebookCells) {\n\t\t\tentries.push(\n\t\t\t\t...this._outlineEntryFactory.getOutlineEntries(\n\t\t\t\t\tcell,\n\t\t\t\t\tentries.length,\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\n\t\t// build a tree from the list of entries\n\t\tif (entries.length > 0) {\n\t\t\tconst result: OutlineEntry[] = [entries[0]];\n\t\t\tconst parentStack: OutlineEntry[] = [entries[0]];\n\n\t\t\tfor (let i = 1; i < entries.length; i++) {\n\t\t\t\tconst entry = entries[i];\n\n\t\t\t\twhile (true) {\n\t\t\t\t\tconst len = parentStack.length;\n\t\t\t\t\tif (len === 0) {\n\t\t\t\t\t\t// root node\n\t\t\t\t\t\tresult.push(entry);\n\t\t\t\t\t\tparentStack.push(entry);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst parentCandidate = parentStack[len - 1];\n\t\t\t\t\t\tif (parentCandidate.level < entry.level) {\n\t\t\t\t\t\t\tparentCandidate.addChild(entry);\n\t\t\t\t\t\t\tparentStack.push(entry);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparentStack.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._entries = result;\n\t\t}\n\n\t\t// feature: show markers with each cell\n\t\tconst markerServiceListener = new MutableDisposable();\n\t\tthis._disposables.add(markerServiceListener);\n\t\tconst updateMarkerUpdater = () => {\n\t\t\tif (notebookEditorWidget.isDisposed) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst doUpdateMarker = (clear: boolean) => {\n\t\t\t\tfor (const entry of this._entries) {\n\t\t\t\t\tif (clear) {\n\t\t\t\t\t\tentry.clearMarkers();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tentry.updateMarkers(this._markerService);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tconst problem = this._configurationService.getValue(\n\t\t\t\t\"problems.visibility\",\n\t\t\t);\n\t\t\tif (problem === undefined) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst config = this._configurationService.getValue(\n\t\t\t\tOutlineConfigKeys.problemsEnabled,\n\t\t\t);\n\n\t\t\tif (problem && config) {\n\t\t\t\tmarkerServiceListener.value =\n\t\t\t\t\tthis._markerService.onMarkerChanged((e) => {\n\t\t\t\t\t\tif (notebookEditorWidget.isDisposed) {\n\t\t\t\t\t\t\tconsole.error(\"notebook editor is disposed\");\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\te.some((uri) =>\n\t\t\t\t\t\t\t\tnotebookEditorWidget\n\t\t\t\t\t\t\t\t\t.getCellsInRange()\n\t\t\t\t\t\t\t\t\t.some((cell) => isEqual(cell.uri, uri)),\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tdoUpdateMarker(false);\n\t\t\t\t\t\t\tthis._onDidChange.fire({});\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\tdoUpdateMarker(false);\n\t\t\t} else {\n\t\t\t\tmarkerServiceListener.clear();\n\t\t\t\tdoUpdateMarker(true);\n\t\t\t}\n\t\t};\n\t\tupdateMarkerUpdater();\n\t\tthis._disposables.add(\n\t\t\tthis._configurationService.onDidChangeConfiguration((e) => {\n\t\t\t\tif (\n\t\t\t\t\te.affectsConfiguration(\"problems.visibility\") ||\n\t\t\t\t\te.affectsConfiguration(OutlineConfigKeys.problemsEnabled)\n\t\t\t\t) {\n\t\t\t\t\tupdateMarkerUpdater();\n\t\t\t\t\tthis._onDidChange.fire({});\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\n\t\tconst { changeEventTriggered } = this.recomputeActive();\n\t\tif (!changeEventTriggered) {\n\t\t\tthis._onDidChange.fire({});\n\t\t}\n\t}\n\n\tpublic recomputeActive(): { changeEventTriggered: boolean } {\n\t\tlet newActive: OutlineEntry | undefined;\n\t\tconst notebookEditorWidget = this._editor;\n\n\t\tif (notebookEditorWidget) {\n\t\t\t//TODO don't check for widget, only here if we do have\n\t\t\tif (\n\t\t\t\tnotebookEditorWidget.hasModel() &&\n\t\t\t\tnotebookEditorWidget.getLength() > 0\n\t\t\t) {\n\t\t\t\tconst cell = notebookEditorWidget.cellAt(\n\t\t\t\t\tnotebookEditorWidget.getFocus().start,\n\t\t\t\t);\n\t\t\t\tif (cell) {\n\t\t\t\t\tfor (const entry of this._entries) {\n\t\t\t\t\t\tnewActive = entry.find(cell, []);\n\t\t\t\t\t\tif (newActive) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (newActive !== this._activeEntry) {\n\t\t\tthis._activeEntry = newActive;\n\t\t\tthis._onDidChange.fire({ affectOnlyActiveElement: true });\n\t\t\treturn { changeEventTriggered: true };\n\t\t}\n\t\treturn { changeEventTriggered: false };\n\t}\n\n\tdispose(): void {\n\t\tthis._entries.length = 0;\n\t\tthis._activeEntry = undefined;\n\t\tthis._disposables.dispose();\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
