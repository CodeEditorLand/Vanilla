import{renderMarkdownAsPlaintext as p}from"../../../../../base/browser/markdownRenderer.js";import"../../../../../base/common/cancellation.js";import"../../../../../editor/common/core/range.js";import"../../../../../editor/common/languages.js";import"../../../../../editor/contrib/documentSymbols/browser/outlineModel.js";import{localize as h}from"../../../../../nls.js";import{CellKind as g}from"../../common/notebookCommon.js";import"../../common/notebookExecutionStateService.js";import"../notebookBrowser.js";import{getMarkdownHeadersInCell as y}from"./foldingModel.js";import{OutlineEntry as d}from"./OutlineEntry.js";var v=(e=>(e[e.NonHeaderOutlineLevel=7]="NonHeaderOutlineLevel",e))(v||{});function M(i){const e=Array.from(y(i));if(e.length)return e;const t=i.match(/<h([1-6]).*>(.*)<\/h\1>/i);if(t){const n=parseInt(t[1]),r=t[2].trim();e.push({depth:n,text:r})}return e}class P{constructor(e){this.executionStateService=e}cellOutlineEntryCache={};cachedMarkdownOutlineEntries=new WeakMap;getOutlineEntries(e,t){const n=[],r=e.cellKind===g.Markup;let s=w(e),u=!1;if(r){const o=e.getText().substring(0,1e4),a=this.cachedMarkdownOutlineEntries.get(e),c=a?.alternativeId===e.getAlternativeId()?a.headers:Array.from(M(o));this.cachedMarkdownOutlineEntries.set(e,{alternativeId:e.getAlternativeId(),headers:c});for(const{depth:l,text:f}of c)u=!0,n.push(new d(t++,l,e,f,!1,!1));u||(s=p({value:s}))}if(!u){const o=!r&&this.executionStateService.getCellExecution(e.uri);let a=s.trim();if(!r&&e.model.textModel){const c=this.cellOutlineEntryCache[e.model.textModel.id];c&&(n.push(new d(t++,7,e,a,!!o,o?o.isPaused:!1)),c.forEach(l=>{n.push(new d(t++,l.level,e,l.name,!1,!1,l.range,l.kind))}))}n.length===0&&(a.length===0&&(a=h("empty","empty cell")),n.push(new d(t++,7,e,a,!!o,o?o.isPaused:!1)))}return n}async cacheSymbols(e,t,n){const r=await e.resolveTextModel(),s=await t.getOrCreate(r,n),u=m(s.getTopLevelSymbols(),8);this.cellOutlineEntryCache[r.id]=u}}function m(i,e){const t=[];return i.forEach(n=>{t.push({name:n.name,range:n.range,level:e,kind:n.kind}),n.children&&t.push(...m(n.children,e+1))}),t}function w(i){const e=i.textBuffer;for(let t=0;t<e.getLineCount();t++){const n=e.getLineFirstNonWhitespaceColumn(t+1),r=e.getLineLength(t+1);if(n<r)return e.getLineContent(t+1)}return i.getText().substring(0,100)}export{v as NotebookOutlineConstants,P as NotebookOutlineEntryFactory};
