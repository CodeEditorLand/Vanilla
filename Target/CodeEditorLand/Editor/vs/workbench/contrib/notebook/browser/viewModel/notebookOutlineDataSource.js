var y=Object.defineProperty;var v=Object.getOwnPropertyDescriptor;var g=(c,t,r,e)=>{for(var i=e>1?void 0:e?v(t,r):t,s=c.length-1,d;s>=0;s--)(d=c[s])&&(i=(e?d(t,r,i):d(i))||i);return e&&i&&y(t,r,i),i},h=(c,t)=>(r,e)=>t(r,e,c);import{Emitter as E}from"../../../../../base/common/event.js";import{DisposableStore as b,MutableDisposable as _}from"../../../../../base/common/lifecycle.js";import{isEqual as k}from"../../../../../base/common/resources.js";import{IConfigurationService as C}from"../../../../../platform/configuration/common/configuration.js";import{IMarkerService as O}from"../../../../../platform/markers/common/markers.js";import{OutlineConfigKeys as m}from"../../../../services/outline/browser/outline.js";import{CellKind as S}from"../../common/notebookCommon.js";import{INotebookOutlineEntryFactory as I}from"./notebookOutlineEntryFactory.js";let p=class{constructor(t,r,e,i){this._editor=t;this._markerService=r;this._configurationService=e;this._outlineEntryFactory=i;this.recomputeState()}_disposables=new b;_onDidChange=new E;onDidChange=this._onDidChange.event;_uri;_entries=[];_activeEntry;get activeElement(){return this._activeEntry}get entries(){return this._entries}get isEmpty(){return this._entries.length===0}get uri(){return this._uri}async computeFullSymbols(t){const e=this._editor?.getViewModel()?.viewCells.filter(i=>i.cellKind===S.Code);if(e){const i=[];for(const s of e.slice(0,50))i.push(this._outlineEntryFactory.cacheSymbols(s,t));await Promise.allSettled(i)}this.recomputeState()}recomputeState(){if(this._disposables.clear(),this._activeEntry=void 0,this._uri=void 0,!this._editor.hasModel())return;this._uri=this._editor.textModel.uri;const t=this._editor;if(t.getLength()===0)return;const r=t.getViewModel().viewCells,e=[];for(const n of r)e.push(...this._outlineEntryFactory.getOutlineEntries(n,e.length));if(e.length>0){const n=[e[0]],l=[e[0]];for(let u=1;u<e.length;u++){const o=e[u];for(;;){const a=l.length;if(a===0){n.push(o),l.push(o);break}else{const f=l[a-1];if(f.level<o.level){f.addChild(o),l.push(o);break}else l.pop()}}}this._entries=n}const i=new _;this._disposables.add(i);const s=()=>{if(t.isDisposed)return;const n=o=>{for(const a of this._entries)o?a.clearMarkers():a.updateMarkers(this._markerService)},l=this._configurationService.getValue("problems.visibility");if(l===void 0)return;const u=this._configurationService.getValue(m.problemsEnabled);l&&u?(i.value=this._markerService.onMarkerChanged(o=>{t.isDisposed||o.some(a=>t.getCellsInRange().some(f=>k(f.uri,a)))&&(n(!1),this._onDidChange.fire({}))}),n(!1)):(i.clear(),n(!0))};s(),this._disposables.add(this._configurationService.onDidChangeConfiguration(n=>{(n.affectsConfiguration("problems.visibility")||n.affectsConfiguration(m.problemsEnabled))&&(s(),this._onDidChange.fire({}))}));const{changeEventTriggered:d}=this.recomputeActive();d||this._onDidChange.fire({})}recomputeActive(){let t;const r=this._editor;if(r&&r.hasModel()&&r.getLength()>0){const e=r.cellAt(r.getFocus().start);if(e){for(const i of this._entries)if(t=i.find(e,[]),t)break}}return t!==this._activeEntry?(this._activeEntry=t,this._onDidChange.fire({affectOnlyActiveElement:!0}),{changeEventTriggered:!0}):{changeEventTriggered:!1}}dispose(){this._entries.length=0,this._activeEntry=void 0,this._disposables.dispose()}};p=g([h(1,O),h(2,C),h(3,I)],p);export{p as NotebookCellOutlineDataSource};
