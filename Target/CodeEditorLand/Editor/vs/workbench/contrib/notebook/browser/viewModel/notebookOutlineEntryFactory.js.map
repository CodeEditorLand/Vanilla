{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/notebook/browser/viewModel/notebookOutlineEntryFactory.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { renderMarkdownAsPlaintext } from \"../../../../../base/browser/markdownRenderer.js\";\nimport type { CancellationToken } from \"../../../../../base/common/cancellation.js\";\nimport type { IRange } from \"../../../../../editor/common/core/range.js\";\nimport type { SymbolKind } from \"../../../../../editor/common/languages.js\";\nimport { ITextModelService } from \"../../../../../editor/common/services/resolverService.js\";\nimport {\n\tIOutlineModelService,\n\ttype OutlineModelService,\n} from \"../../../../../editor/contrib/documentSymbols/browser/outlineModel.js\";\nimport { localize } from \"../../../../../nls.js\";\nimport { createDecorator } from \"../../../../../platform/instantiation/common/instantiation.js\";\nimport { CellKind } from \"../../common/notebookCommon.js\";\nimport { INotebookExecutionStateService } from \"../../common/notebookExecutionStateService.js\";\nimport type { ICellViewModel } from \"../notebookBrowser.js\";\nimport { OutlineEntry } from \"./OutlineEntry.js\";\nimport { getMarkdownHeadersInCell } from \"./foldingModel.js\";\n\nexport enum NotebookOutlineConstants {\n\tNonHeaderOutlineLevel = 7,\n}\n\ntype entryDesc = {\n\tname: string;\n\trange: IRange;\n\tlevel: number;\n\tkind: SymbolKind;\n};\n\nfunction getMarkdownHeadersInCellFallbackToHtmlTags(fullContent: string) {\n\tconst headers = Array.from(getMarkdownHeadersInCell(fullContent));\n\tif (headers.length) {\n\t\treturn headers;\n\t}\n\t// no markdown syntax headers, try to find html tags\n\tconst match = fullContent.match(/<h([1-6]).*>(.*)<\\/h\\1>/i);\n\tif (match) {\n\t\tconst level = Number.parseInt(match[1]);\n\t\tconst text = match[2].trim();\n\t\theaders.push({ depth: level, text });\n\t}\n\treturn headers;\n}\n\nexport const INotebookOutlineEntryFactory =\n\tcreateDecorator<INotebookOutlineEntryFactory>(\n\t\t\"INotebookOutlineEntryFactory\",\n\t);\n\nexport interface INotebookOutlineEntryFactory {\n\treadonly _serviceBrand: undefined;\n\n\tgetOutlineEntries(cell: ICellViewModel, index: number): OutlineEntry[];\n\tcacheSymbols(\n\t\tcell: ICellViewModel,\n\t\tcancelToken: CancellationToken,\n\t): Promise<void>;\n}\n\nexport class NotebookOutlineEntryFactory\n\timplements INotebookOutlineEntryFactory\n{\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate cellOutlineEntryCache: Record<string, entryDesc[]> = {};\n\tprivate readonly cachedMarkdownOutlineEntries = new WeakMap<\n\t\tICellViewModel,\n\t\t{ alternativeId: number; headers: { depth: number; text: string }[] }\n\t>();\n\tconstructor(\n\t\t@INotebookExecutionStateService\n\t\tprivate readonly executionStateService: INotebookExecutionStateService,\n\t\t@IOutlineModelService\n\t\tprivate readonly outlineModelService: IOutlineModelService,\n\t\t@ITextModelService private readonly textModelService: ITextModelService,\n\t) {}\n\n\tpublic getOutlineEntries(\n\t\tcell: ICellViewModel,\n\t\tindex: number,\n\t): OutlineEntry[] {\n\t\tconst entries: OutlineEntry[] = [];\n\n\t\tconst isMarkdown = cell.cellKind === CellKind.Markup;\n\n\t\t// cap the amount of characters that we look at and use the following logic\n\t\t// - for MD prefer headings (each header is an entry)\n\t\t// - otherwise use the first none-empty line of the cell (MD or code)\n\t\tlet content = getCellFirstNonEmptyLine(cell);\n\t\tlet hasHeader = false;\n\n\t\tif (isMarkdown) {\n\t\t\tconst fullContent = cell.getText().substring(0, 10000);\n\t\t\tconst cache = this.cachedMarkdownOutlineEntries.get(cell);\n\t\t\tconst headers =\n\t\t\t\tcache?.alternativeId === cell.getAlternativeId()\n\t\t\t\t\t? cache.headers\n\t\t\t\t\t: Array.from(\n\t\t\t\t\t\t\tgetMarkdownHeadersInCellFallbackToHtmlTags(\n\t\t\t\t\t\t\t\tfullContent,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\t\t\tthis.cachedMarkdownOutlineEntries.set(cell, {\n\t\t\t\talternativeId: cell.getAlternativeId(),\n\t\t\t\theaders,\n\t\t\t});\n\n\t\t\tfor (const { depth, text } of headers) {\n\t\t\t\thasHeader = true;\n\t\t\t\tentries.push(\n\t\t\t\t\tnew OutlineEntry(index++, depth, cell, text, false, false),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (!hasHeader) {\n\t\t\t\tcontent = renderMarkdownAsPlaintext({ value: content });\n\t\t\t}\n\t\t}\n\n\t\tif (!hasHeader) {\n\t\t\tconst exeState =\n\t\t\t\t!isMarkdown &&\n\t\t\t\tthis.executionStateService.getCellExecution(cell.uri);\n\t\t\tlet preview = content.trim();\n\n\t\t\tif (!isMarkdown) {\n\t\t\t\tconst cached = this.cellOutlineEntryCache[cell.id];\n\n\t\t\t\t// Gathering symbols from the model is an async operation, but this provider is syncronous.\n\t\t\t\t// So symbols need to be precached before this function is called to get the full list.\n\t\t\t\tif (cached) {\n\t\t\t\t\t// push code cell entry that is a parent of cached symbols, always necessary. filtering for quickpick done in that provider.\n\t\t\t\t\tentries.push(\n\t\t\t\t\t\tnew OutlineEntry(\n\t\t\t\t\t\t\tindex++,\n\t\t\t\t\t\t\tNotebookOutlineConstants.NonHeaderOutlineLevel,\n\t\t\t\t\t\t\tcell,\n\t\t\t\t\t\t\tpreview,\n\t\t\t\t\t\t\t!!exeState,\n\t\t\t\t\t\t\texeState ? exeState.isPaused : false,\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t\tcached.forEach((entry) => {\n\t\t\t\t\t\tentries.push(\n\t\t\t\t\t\t\tnew OutlineEntry(\n\t\t\t\t\t\t\t\tindex++,\n\t\t\t\t\t\t\t\tentry.level,\n\t\t\t\t\t\t\t\tcell,\n\t\t\t\t\t\t\t\tentry.name,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tentry.range,\n\t\t\t\t\t\t\t\tentry.kind,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (entries.length === 0) {\n\t\t\t\t// if there are no cached entries, use the first line of the cell as a code cell\n\t\t\t\tif (preview.length === 0) {\n\t\t\t\t\t// empty or just whitespace\n\t\t\t\t\tpreview = localize(\"empty\", \"empty cell\");\n\t\t\t\t}\n\t\t\t\tentries.push(\n\t\t\t\t\tnew OutlineEntry(\n\t\t\t\t\t\tindex++,\n\t\t\t\t\t\tNotebookOutlineConstants.NonHeaderOutlineLevel,\n\t\t\t\t\t\tcell,\n\t\t\t\t\t\tpreview,\n\t\t\t\t\t\t!!exeState,\n\t\t\t\t\t\texeState ? exeState.isPaused : false,\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn entries;\n\t}\n\n\tpublic async cacheSymbols(\n\t\tcell: ICellViewModel,\n\t\tcancelToken: CancellationToken,\n\t) {\n\t\tif (cell.cellKind === CellKind.Markup) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst ref = await this.textModelService.createModelReference(cell.uri);\n\t\ttry {\n\t\t\tconst textModel = ref.object.textEditorModel;\n\t\t\tconst outlineModel = await this.outlineModelService.getOrCreate(\n\t\t\t\ttextModel,\n\t\t\t\tcancelToken,\n\t\t\t);\n\t\t\tconst entries = createOutlineEntries(\n\t\t\t\toutlineModel.getTopLevelSymbols(),\n\t\t\t\t8,\n\t\t\t);\n\t\t\tthis.cellOutlineEntryCache[cell.id] = entries;\n\t\t} finally {\n\t\t\tref.dispose();\n\t\t}\n\t}\n}\n\ntype outlineModel = Awaited<ReturnType<OutlineModelService[\"getOrCreate\"]>>;\ntype documentSymbol = ReturnType<outlineModel[\"getTopLevelSymbols\"]>[number];\n\nfunction createOutlineEntries(\n\tsymbols: documentSymbol[],\n\tlevel: number,\n): entryDesc[] {\n\tconst entries: entryDesc[] = [];\n\tsymbols.forEach((symbol) => {\n\t\tentries.push({\n\t\t\tname: symbol.name,\n\t\t\trange: symbol.range,\n\t\t\tlevel,\n\t\t\tkind: symbol.kind,\n\t\t});\n\t\tif (symbol.children) {\n\t\t\tentries.push(...createOutlineEntries(symbol.children, level + 1));\n\t\t}\n\t});\n\treturn entries;\n}\n\nfunction getCellFirstNonEmptyLine(cell: ICellViewModel) {\n\tconst textBuffer = cell.textBuffer;\n\tfor (let i = 0; i < textBuffer.getLineCount(); i++) {\n\t\tconst firstNonWhitespace = textBuffer.getLineFirstNonWhitespaceColumn(\n\t\t\ti + 1,\n\t\t);\n\t\tconst lineLength = textBuffer.getLineLength(i + 1);\n\t\tif (firstNonWhitespace < lineLength) {\n\t\t\treturn textBuffer.getLineContent(i + 1);\n\t\t}\n\t}\n\n\treturn cell.getText().substring(0, 100);\n}\n"],
  "mappings": "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",
  "names": ["NotebookOutlineConstants"]
}
