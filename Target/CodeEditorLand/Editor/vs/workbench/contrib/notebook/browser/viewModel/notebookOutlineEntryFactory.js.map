{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/notebook/browser/viewModel/notebookOutlineEntryFactory.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { renderMarkdownAsPlaintext } from '../../../../../base/browser/markdownRenderer.js';\nimport { CancellationToken } from '../../../../../base/common/cancellation.js';\nimport { IOutlineModelService, OutlineModelService } from '../../../../../editor/contrib/documentSymbols/browser/outlineModel.js';\nimport { localize } from '../../../../../nls.js';\nimport { ICellViewModel } from '../notebookBrowser.js';\nimport { getMarkdownHeadersInCell } from './foldingModel.js';\nimport { OutlineEntry } from './OutlineEntry.js';\nimport { CellKind } from '../../common/notebookCommon.js';\nimport { INotebookExecutionStateService } from '../../common/notebookExecutionStateService.js';\nimport { IRange } from '../../../../../editor/common/core/range.js';\nimport { SymbolKind } from '../../../../../editor/common/languages.js';\nimport { createDecorator } from '../../../../../platform/instantiation/common/instantiation.js';\nimport { ITextModelService } from '../../../../../editor/common/services/resolverService.js';\n\nexport const enum NotebookOutlineConstants {\n\tNonHeaderOutlineLevel = 7,\n}\n\ntype entryDesc = {\n\tname: string;\n\trange: IRange;\n\tlevel: number;\n\tkind: SymbolKind;\n};\n\nfunction getMarkdownHeadersInCellFallbackToHtmlTags(fullContent: string) {\n\tconst headers = Array.from(getMarkdownHeadersInCell(fullContent));\n\tif (headers.length) {\n\t\treturn headers;\n\t}\n\t// no markdown syntax headers, try to find html tags\n\tconst match = fullContent.match(/<h([1-6]).*>(.*)<\\/h\\1>/i);\n\tif (match) {\n\t\tconst level = parseInt(match[1]);\n\t\tconst text = match[2].trim();\n\t\theaders.push({ depth: level, text });\n\t}\n\treturn headers;\n}\n\nexport const INotebookOutlineEntryFactory = createDecorator<INotebookOutlineEntryFactory>('INotebookOutlineEntryFactory');\n\nexport interface INotebookOutlineEntryFactory {\n\treadonly _serviceBrand: undefined;\n\n\tgetOutlineEntries(cell: ICellViewModel, index: number): OutlineEntry[];\n\tcacheSymbols(cell: ICellViewModel, cancelToken: CancellationToken): Promise<void>;\n}\n\nexport class NotebookOutlineEntryFactory implements INotebookOutlineEntryFactory {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate cellOutlineEntryCache: Record<string, entryDesc[]> = {};\n\tprivate readonly cachedMarkdownOutlineEntries = new WeakMap<ICellViewModel, { alternativeId: number; headers: { depth: number; text: string }[] }>();\n\tconstructor(\n\t\t@INotebookExecutionStateService private readonly executionStateService: INotebookExecutionStateService,\n\t\t@IOutlineModelService private readonly outlineModelService: IOutlineModelService,\n\t\t@ITextModelService private readonly textModelService: ITextModelService\n\t) { }\n\n\tpublic getOutlineEntries(cell: ICellViewModel, index: number): OutlineEntry[] {\n\t\tconst entries: OutlineEntry[] = [];\n\n\t\tconst isMarkdown = cell.cellKind === CellKind.Markup;\n\n\t\t// cap the amount of characters that we look at and use the following logic\n\t\t// - for MD prefer headings (each header is an entry)\n\t\t// - otherwise use the first none-empty line of the cell (MD or code)\n\t\tlet content = getCellFirstNonEmptyLine(cell);\n\t\tlet hasHeader = false;\n\n\t\tif (isMarkdown) {\n\t\t\tconst fullContent = cell.getText().substring(0, 10000);\n\t\t\tconst cache = this.cachedMarkdownOutlineEntries.get(cell);\n\t\t\tconst headers = cache?.alternativeId === cell.getAlternativeId() ? cache.headers : Array.from(getMarkdownHeadersInCellFallbackToHtmlTags(fullContent));\n\t\t\tthis.cachedMarkdownOutlineEntries.set(cell, { alternativeId: cell.getAlternativeId(), headers });\n\n\t\t\tfor (const { depth, text } of headers) {\n\t\t\t\thasHeader = true;\n\t\t\t\tentries.push(new OutlineEntry(index++, depth, cell, text, false, false));\n\t\t\t}\n\n\t\t\tif (!hasHeader) {\n\t\t\t\tcontent = renderMarkdownAsPlaintext({ value: content });\n\t\t\t}\n\t\t}\n\n\t\tif (!hasHeader) {\n\t\t\tconst exeState = !isMarkdown && this.executionStateService.getCellExecution(cell.uri);\n\t\t\tlet preview = content.trim();\n\n\t\t\tif (!isMarkdown) {\n\t\t\t\tconst cached = this.cellOutlineEntryCache[cell.id];\n\n\t\t\t\t// Gathering symbols from the model is an async operation, but this provider is syncronous.\n\t\t\t\t// So symbols need to be precached before this function is called to get the full list.\n\t\t\t\tif (cached) {\n\t\t\t\t\t// push code cell entry that is a parent of cached symbols, always necessary. filtering for quickpick done in that provider.\n\t\t\t\t\tentries.push(new OutlineEntry(index++, NotebookOutlineConstants.NonHeaderOutlineLevel, cell, preview, !!exeState, exeState ? exeState.isPaused : false));\n\t\t\t\t\tcached.forEach((entry) => {\n\t\t\t\t\t\tentries.push(new OutlineEntry(index++, entry.level, cell, entry.name, false, false, entry.range, entry.kind));\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (entries.length === 0) { // if there are no cached entries, use the first line of the cell as a code cell\n\t\t\t\tif (preview.length === 0) {\n\t\t\t\t\t// empty or just whitespace\n\t\t\t\t\tpreview = localize('empty', \"empty cell\");\n\t\t\t\t}\n\t\t\t\tentries.push(new OutlineEntry(index++, NotebookOutlineConstants.NonHeaderOutlineLevel, cell, preview, !!exeState, exeState ? exeState.isPaused : false));\n\t\t\t}\n\t\t}\n\n\t\treturn entries;\n\t}\n\n\tpublic async cacheSymbols(cell: ICellViewModel, cancelToken: CancellationToken) {\n\t\tif (cell.cellKind === CellKind.Markup) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst ref = await this.textModelService.createModelReference(cell.uri);\n\t\ttry {\n\t\t\tconst textModel = ref.object.textEditorModel;\n\t\t\tconst outlineModel = await this.outlineModelService.getOrCreate(textModel, cancelToken);\n\t\t\tconst entries = createOutlineEntries(outlineModel.getTopLevelSymbols(), 8);\n\t\t\tthis.cellOutlineEntryCache[cell.id] = entries;\n\t\t} finally {\n\t\t\tref.dispose();\n\t\t}\n\t}\n}\n\ntype outlineModel = Awaited<ReturnType<OutlineModelService['getOrCreate']>>;\ntype documentSymbol = ReturnType<outlineModel['getTopLevelSymbols']>[number];\n\nfunction createOutlineEntries(symbols: documentSymbol[], level: number): entryDesc[] {\n\tconst entries: entryDesc[] = [];\n\tsymbols.forEach(symbol => {\n\t\tentries.push({ name: symbol.name, range: symbol.range, level, kind: symbol.kind });\n\t\tif (symbol.children) {\n\t\t\tentries.push(...createOutlineEntries(symbol.children, level + 1));\n\t\t}\n\t});\n\treturn entries;\n}\n\nfunction getCellFirstNonEmptyLine(cell: ICellViewModel) {\n\tconst textBuffer = cell.textBuffer;\n\tfor (let i = 0; i < textBuffer.getLineCount(); i++) {\n\t\tconst firstNonWhitespace = textBuffer.getLineFirstNonWhitespaceColumn(i + 1);\n\t\tconst lineLength = textBuffer.getLineLength(i + 1);\n\t\tif (firstNonWhitespace < lineLength) {\n\t\t\treturn textBuffer.getLineContent(i + 1);\n\t\t}\n\t}\n\n\treturn cell.getText().substring(0, 100);\n}\n"],
  "mappings": "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",
  "names": ["NotebookOutlineConstants"]
}
