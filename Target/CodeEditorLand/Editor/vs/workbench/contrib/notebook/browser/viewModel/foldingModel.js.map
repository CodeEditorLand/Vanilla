{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/notebook/browser/viewModel/foldingModel.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { renderMarkdownAsPlaintext } from \"../../../../../base/browser/markdownRenderer.js\";\nimport { Emitter, type Event } from \"../../../../../base/common/event.js\";\nimport {\n\tDisposableStore,\n\ttype IDisposable,\n} from \"../../../../../base/common/lifecycle.js\";\nimport { marked } from \"../../../../../base/common/marked/marked.js\";\nimport { TrackedRangeStickiness } from \"../../../../../editor/common/model.js\";\nimport type { FoldingLimitReporter } from \"../../../../../editor/contrib/folding/browser/folding.js\";\nimport {\n\ttype FoldingRegion,\n\tFoldingRegions,\n} from \"../../../../../editor/contrib/folding/browser/foldingRanges.js\";\nimport {\n\ttype IFoldingRangeData,\n\tsanitizeRanges,\n} from \"../../../../../editor/contrib/folding/browser/syntaxRangeProvider.js\";\nimport { CellKind } from \"../../common/notebookCommon.js\";\nimport {\n\ttype ICellRange,\n\tcellRangesToIndexes,\n} from \"../../common/notebookRange.js\";\nimport type { INotebookViewModel } from \"../notebookBrowser.js\";\n\ntype RegionFilter = (r: FoldingRegion) => boolean;\ntype RegionFilterWithLevel = (r: FoldingRegion, level: number) => boolean;\n\nconst foldingRangeLimit: FoldingLimitReporter = {\n\tlimit: 5000,\n\tupdate: () => {},\n};\n\nexport class FoldingModel implements IDisposable {\n\tprivate _viewModel: INotebookViewModel | null = null;\n\tprivate readonly _viewModelStore = new DisposableStore();\n\tprivate _regions: FoldingRegions;\n\tget regions() {\n\t\treturn this._regions;\n\t}\n\n\tprivate readonly _onDidFoldingRegionChanges = new Emitter<void>();\n\treadonly onDidFoldingRegionChanged: Event<void> =\n\t\tthis._onDidFoldingRegionChanges.event;\n\n\tprivate _foldingRangeDecorationIds: string[] = [];\n\n\tconstructor() {\n\t\tthis._regions = new FoldingRegions(\n\t\t\tnew Uint32Array(0),\n\t\t\tnew Uint32Array(0),\n\t\t);\n\t}\n\n\tdispose() {\n\t\tthis._onDidFoldingRegionChanges.dispose();\n\t\tthis._viewModelStore.dispose();\n\t}\n\n\tdetachViewModel() {\n\t\tthis._viewModelStore.clear();\n\t\tthis._viewModel = null;\n\t}\n\n\tattachViewModel(model: INotebookViewModel) {\n\t\tthis._viewModel = model;\n\n\t\tthis._viewModelStore.add(\n\t\t\tthis._viewModel.onDidChangeViewCells(() => {\n\t\t\t\tthis.recompute();\n\t\t\t}),\n\t\t);\n\n\t\tthis._viewModelStore.add(\n\t\t\tthis._viewModel.onDidChangeSelection(() => {\n\t\t\t\tif (!this._viewModel) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst indexes = cellRangesToIndexes(\n\t\t\t\t\tthis._viewModel.getSelections(),\n\t\t\t\t);\n\n\t\t\t\tlet changed = false;\n\n\t\t\t\tindexes.forEach((index) => {\n\t\t\t\t\tlet regionIndex = this.regions.findRange(index + 1);\n\n\t\t\t\t\twhile (regionIndex !== -1) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tthis._regions.isCollapsed(regionIndex) &&\n\t\t\t\t\t\t\tindex >\n\t\t\t\t\t\t\t\tthis._regions.getStartLineNumber(regionIndex) -\n\t\t\t\t\t\t\t\t\t1\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tthis._regions.setCollapsed(regionIndex, false);\n\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tregionIndex = this._regions.getParentIndex(regionIndex);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif (changed) {\n\t\t\t\t\tthis._onDidFoldingRegionChanges.fire();\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\n\t\tthis.recompute();\n\t}\n\n\tgetRegionAtLine(lineNumber: number): FoldingRegion | null {\n\t\tif (this._regions) {\n\t\t\tconst index = this._regions.findRange(lineNumber);\n\t\t\tif (index >= 0) {\n\t\t\t\treturn this._regions.toRegion(index);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tgetRegionsInside(\n\t\tregion: FoldingRegion | null,\n\t\tfilter?: RegionFilter | RegionFilterWithLevel,\n\t): FoldingRegion[] {\n\t\tconst result: FoldingRegion[] = [];\n\t\tconst index = region ? region.regionIndex + 1 : 0;\n\t\tconst endLineNumber = region ? region.endLineNumber : Number.MAX_VALUE;\n\n\t\tif (filter && filter.length === 2) {\n\t\t\tconst levelStack: FoldingRegion[] = [];\n\t\t\tfor (let i = index, len = this._regions.length; i < len; i++) {\n\t\t\t\tconst current = this._regions.toRegion(i);\n\t\t\t\tif (this._regions.getStartLineNumber(i) < endLineNumber) {\n\t\t\t\t\twhile (\n\t\t\t\t\t\tlevelStack.length > 0 &&\n\t\t\t\t\t\t!current.containedBy(levelStack[levelStack.length - 1])\n\t\t\t\t\t) {\n\t\t\t\t\t\tlevelStack.pop();\n\t\t\t\t\t}\n\t\t\t\t\tlevelStack.push(current);\n\t\t\t\t\tif (filter(current, levelStack.length)) {\n\t\t\t\t\t\tresult.push(current);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = index, len = this._regions.length; i < len; i++) {\n\t\t\t\tconst current = this._regions.toRegion(i);\n\t\t\t\tif (this._regions.getStartLineNumber(i) < endLineNumber) {\n\t\t\t\t\tif (!filter || (filter as RegionFilter)(current)) {\n\t\t\t\t\t\tresult.push(current);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tgetAllRegionsAtLine(\n\t\tlineNumber: number,\n\t\tfilter?: (r: FoldingRegion, level: number) => boolean,\n\t): FoldingRegion[] {\n\t\tconst result: FoldingRegion[] = [];\n\t\tif (this._regions) {\n\t\t\tlet index = this._regions.findRange(lineNumber);\n\t\t\tlet level = 1;\n\t\t\twhile (index >= 0) {\n\t\t\t\tconst current = this._regions.toRegion(index);\n\t\t\t\tif (!filter || filter(current, level)) {\n\t\t\t\t\tresult.push(current);\n\t\t\t\t}\n\t\t\t\tlevel++;\n\t\t\t\tindex = current.parentIndex;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tsetCollapsed(index: number, newState: boolean) {\n\t\tthis._regions.setCollapsed(index, newState);\n\t}\n\n\trecompute() {\n\t\tif (!this._viewModel) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewModel = this._viewModel;\n\t\tconst cells = viewModel.viewCells;\n\t\tconst stack: { index: number; level: number; endIndex: number }[] = [];\n\n\t\tfor (let i = 0; i < cells.length; i++) {\n\t\t\tconst cell = cells[i];\n\n\t\t\tif (\n\t\t\t\tcell.cellKind !== CellKind.Markup ||\n\t\t\t\tcell.language !== \"markdown\"\n\t\t\t) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst minDepth = Math.min(\n\t\t\t\t7,\n\t\t\t\t...Array.from(\n\t\t\t\t\tgetMarkdownHeadersInCell(cell.getText()),\n\t\t\t\t\t(header) => header.depth,\n\t\t\t\t),\n\t\t\t);\n\t\t\tif (minDepth < 7) {\n\t\t\t\t// header 1 to 6\n\t\t\t\tstack.push({ index: i, level: minDepth, endIndex: 0 });\n\t\t\t}\n\t\t}\n\n\t\t// calculate folding ranges\n\t\tconst rawFoldingRanges: IFoldingRangeData[] = stack\n\t\t\t.map((entry, startIndex) => {\n\t\t\t\tlet end: number | undefined;\n\t\t\t\tfor (let i = startIndex + 1; i < stack.length; ++i) {\n\t\t\t\t\tif (stack[i].level <= entry.level) {\n\t\t\t\t\t\tend = stack[i].index - 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst endIndex = end !== undefined ? end : cells.length - 1;\n\n\t\t\t\t// one based\n\t\t\t\treturn {\n\t\t\t\t\tstart: entry.index + 1,\n\t\t\t\t\tend: endIndex + 1,\n\t\t\t\t\trank: 1,\n\t\t\t\t};\n\t\t\t})\n\t\t\t.filter((range) => range.start !== range.end);\n\n\t\tconst newRegions = sanitizeRanges(rawFoldingRanges, foldingRangeLimit);\n\n\t\t// restore collased state\n\t\tlet i = 0;\n\t\tconst nextCollapsed = () => {\n\t\t\twhile (i < this._regions.length) {\n\t\t\t\tconst isCollapsed = this._regions.isCollapsed(i);\n\t\t\t\ti++;\n\t\t\t\tif (isCollapsed) {\n\t\t\t\t\treturn i - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t};\n\n\t\tlet k = 0;\n\t\tlet collapsedIndex = nextCollapsed();\n\n\t\twhile (collapsedIndex !== -1 && k < newRegions.length) {\n\t\t\t// get the latest range\n\t\t\tconst decRange = viewModel.getTrackedRange(\n\t\t\t\tthis._foldingRangeDecorationIds[collapsedIndex],\n\t\t\t);\n\t\t\tif (decRange) {\n\t\t\t\tconst collasedStartIndex = decRange.start;\n\n\t\t\t\twhile (k < newRegions.length) {\n\t\t\t\t\tconst startIndex = newRegions.getStartLineNumber(k) - 1;\n\t\t\t\t\tif (collasedStartIndex >= startIndex) {\n\t\t\t\t\t\tnewRegions.setCollapsed(\n\t\t\t\t\t\t\tk,\n\t\t\t\t\t\t\tcollasedStartIndex === startIndex,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tk++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcollapsedIndex = nextCollapsed();\n\t\t}\n\n\t\twhile (k < newRegions.length) {\n\t\t\tnewRegions.setCollapsed(k, false);\n\t\t\tk++;\n\t\t}\n\n\t\tconst cellRanges: ICellRange[] = [];\n\t\tfor (let i = 0; i < newRegions.length; i++) {\n\t\t\tconst region = newRegions.toRegion(i);\n\t\t\tcellRanges.push({\n\t\t\t\tstart: region.startLineNumber - 1,\n\t\t\t\tend: region.endLineNumber - 1,\n\t\t\t});\n\t\t}\n\n\t\t// remove old tracked ranges and add new ones\n\t\t// TODO@rebornix, implement delta\n\t\tthis._foldingRangeDecorationIds.forEach((id) =>\n\t\t\tviewModel.setTrackedRange(\n\t\t\t\tid,\n\t\t\t\tnull,\n\t\t\t\tTrackedRangeStickiness.GrowsOnlyWhenTypingAfter,\n\t\t\t),\n\t\t);\n\t\tthis._foldingRangeDecorationIds = cellRanges\n\t\t\t.map((region) =>\n\t\t\t\tviewModel.setTrackedRange(\n\t\t\t\t\tnull,\n\t\t\t\t\tregion,\n\t\t\t\t\tTrackedRangeStickiness.GrowsOnlyWhenTypingAfter,\n\t\t\t\t),\n\t\t\t)\n\t\t\t.filter((str) => str !== null) as string[];\n\n\t\tthis._regions = newRegions;\n\t\tthis._onDidFoldingRegionChanges.fire();\n\t}\n\n\tgetMemento(): ICellRange[] {\n\t\tconst collapsedRanges: ICellRange[] = [];\n\t\tlet i = 0;\n\t\twhile (i < this._regions.length) {\n\t\t\tconst isCollapsed = this._regions.isCollapsed(i);\n\n\t\t\tif (isCollapsed) {\n\t\t\t\tconst region = this._regions.toRegion(i);\n\t\t\t\tcollapsedRanges.push({\n\t\t\t\t\tstart: region.startLineNumber - 1,\n\t\t\t\t\tend: region.endLineNumber - 1,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n\n\t\treturn collapsedRanges;\n\t}\n\n\tpublic applyMemento(state: ICellRange[]): boolean {\n\t\tif (!this._viewModel) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlet i = 0;\n\t\tlet k = 0;\n\n\t\twhile (k < state.length && i < this._regions.length) {\n\t\t\t// get the latest range\n\t\t\tconst decRange = this._viewModel.getTrackedRange(\n\t\t\t\tthis._foldingRangeDecorationIds[i],\n\t\t\t);\n\t\t\tif (decRange) {\n\t\t\t\tconst collasedStartIndex = state[k].start;\n\n\t\t\t\twhile (i < this._regions.length) {\n\t\t\t\t\tconst startIndex = this._regions.getStartLineNumber(i) - 1;\n\t\t\t\t\tif (collasedStartIndex >= startIndex) {\n\t\t\t\t\t\tthis._regions.setCollapsed(\n\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\tcollasedStartIndex === startIndex,\n\t\t\t\t\t\t);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\n\t\twhile (i < this._regions.length) {\n\t\t\tthis._regions.setCollapsed(i, false);\n\t\t\ti++;\n\t\t}\n\n\t\treturn true;\n\t}\n}\n\nexport function updateFoldingStateAtIndex(\n\tfoldingModel: FoldingModel,\n\tindex: number,\n\tcollapsed: boolean,\n) {\n\tconst range = foldingModel.regions.findRange(index + 1);\n\tfoldingModel.setCollapsed(range, collapsed);\n}\n\nexport function* getMarkdownHeadersInCell(\n\tcellContent: string,\n): Iterable<{ readonly depth: number; readonly text: string }> {\n\tfor (const token of marked.lexer(cellContent, { gfm: true })) {\n\t\tif (token.type === \"heading\") {\n\t\t\tyield {\n\t\t\t\tdepth: token.depth,\n\t\t\t\ttext: renderMarkdownAsPlaintext({ value: token.raw }).trim(),\n\t\t\t};\n\t\t}\n\t}\n}\n"],
  "mappings": "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",
  "names": ["i"]
}
