{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/notebook/browser/viewParts/notebookEditorStickyScroll.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as DOM from '../../../../../base/browser/dom.js';\nimport { EventType as TouchEventType } from '../../../../../base/browser/touch.js';\nimport { StandardMouseEvent } from '../../../../../base/browser/mouseEvent.js';\nimport { Emitter, Event } from '../../../../../base/common/event.js';\nimport { Disposable, DisposableStore, type IReference } from '../../../../../base/common/lifecycle.js';\nimport { MenuId } from '../../../../../platform/actions/common/actions.js';\nimport { IContextMenuService } from '../../../../../platform/contextview/browser/contextView.js';\nimport { CellFoldingState, INotebookEditor } from '../notebookBrowser.js';\nimport { INotebookCellList } from '../view/notebookRenderingCommon.js';\nimport { OutlineEntry } from '../viewModel/OutlineEntry.js';\nimport { NotebookCellOutlineDataSource } from '../viewModel/notebookOutlineDataSource.js';\nimport { CellKind } from '../../common/notebookCommon.js';\nimport { Delayer } from '../../../../../base/common/async.js';\nimport { ThemeIcon } from '../../../../../base/common/themables.js';\nimport { foldingCollapsedIcon, foldingExpandedIcon } from '../../../../../editor/contrib/folding/browser/foldingDecorations.js';\nimport { MarkupCellViewModel } from '../viewModel/markupCellViewModel.js';\nimport { FoldingController } from '../controller/foldingController.js';\nimport { NotebookOptionsChangeEvent } from '../notebookOptions.js';\nimport { NotebookSectionArgs } from '../controller/sectionActions.js';\nimport { IInstantiationService } from '../../../../../platform/instantiation/common/instantiation.js';\nimport { INotebookCellOutlineDataSourceFactory } from '../viewModel/notebookOutlineDataSourceFactory.js';\n\nexport class NotebookStickyLine extends Disposable {\n\tconstructor(\n\t\tpublic readonly element: HTMLElement,\n\t\tpublic readonly foldingIcon: StickyFoldingIcon,\n\t\tpublic readonly header: HTMLElement,\n\t\tpublic readonly entry: OutlineEntry,\n\t\tpublic readonly notebookEditor: INotebookEditor,\n\t) {\n\t\tsuper();\n\t\t// click the header to focus the cell\n\t\tthis._register(DOM.addDisposableListener(this.header, DOM.EventType.CLICK || TouchEventType.Tap, () => {\n\t\t\tthis.focusCell();\n\t\t}));\n\n\t\t// click the folding icon to fold the range covered by the header\n\t\tthis._register(DOM.addDisposableListener(this.foldingIcon.domNode, DOM.EventType.CLICK || TouchEventType.Tap, () => {\n\t\t\tif (this.entry.cell.cellKind === CellKind.Markup) {\n\t\t\t\tconst currentFoldingState = (this.entry.cell as MarkupCellViewModel).foldingState;\n\t\t\t\tthis.toggleFoldRange(currentFoldingState);\n\t\t\t}\n\t\t}));\n\n\t}\n\n\tprivate toggleFoldRange(currentState: CellFoldingState) {\n\t\tconst foldingController = this.notebookEditor.getContribution<FoldingController>(FoldingController.id);\n\n\t\tconst index = this.entry.index;\n\t\tconst headerLevel = this.entry.level;\n\t\tconst newFoldingState = (currentState === CellFoldingState.Collapsed) ? CellFoldingState.Expanded : CellFoldingState.Collapsed;\n\n\t\tfoldingController.setFoldingStateDown(index, newFoldingState, headerLevel);\n\t\tthis.focusCell();\n\t}\n\n\tprivate focusCell() {\n\t\tthis.notebookEditor.focusNotebookCell(this.entry.cell, 'container');\n\t\tconst cellScrollTop = this.notebookEditor.getAbsoluteTopOfElement(this.entry.cell);\n\t\tconst parentCount = NotebookStickyLine.getParentCount(this.entry);\n\t\t// 1.1 addresses visible cell padding, to make sure we don't focus md cell and also render its sticky line\n\t\tthis.notebookEditor.setScrollTop(cellScrollTop - (parentCount + 1.1) * 22);\n\t}\n\n\tstatic getParentCount(entry: OutlineEntry) {\n\t\tlet count = 0;\n\t\twhile (entry.parent) {\n\t\t\tcount++;\n\t\t\tentry = entry.parent;\n\t\t}\n\t\treturn count;\n\t}\n}\n\nclass StickyFoldingIcon {\n\n\tpublic domNode: HTMLElement;\n\n\tconstructor(\n\t\tpublic isCollapsed: boolean,\n\t\tpublic dimension: number\n\t) {\n\t\tthis.domNode = document.createElement('div');\n\t\tthis.domNode.style.width = `${dimension}px`;\n\t\tthis.domNode.style.height = `${dimension}px`;\n\t\tthis.domNode.className = ThemeIcon.asClassName(isCollapsed ? foldingCollapsedIcon : foldingExpandedIcon);\n\t}\n\n\tpublic setVisible(visible: boolean) {\n\t\tthis.domNode.style.cursor = visible ? 'pointer' : 'default';\n\t\tthis.domNode.style.opacity = visible ? '1' : '0';\n\t}\n}\n\nexport class NotebookStickyScroll extends Disposable {\n\tprivate readonly _disposables = new DisposableStore();\n\tprivate currentStickyLines = new Map<OutlineEntry, { line: NotebookStickyLine; rendered: boolean }>();\n\n\tprivate readonly _onDidChangeNotebookStickyScroll = this._register(new Emitter<number>());\n\treadonly onDidChangeNotebookStickyScroll: Event<number> = this._onDidChangeNotebookStickyScroll.event;\n\tprivate notebookCellOutlineReference?: IReference<NotebookCellOutlineDataSource>;\n\n\tprivate readonly _layoutDisposableStore = this._register(new DisposableStore());\n\n\tgetDomNode(): HTMLElement {\n\t\treturn this.domNode;\n\t}\n\n\tgetCurrentStickyHeight() {\n\t\tlet height = 0;\n\t\tthis.currentStickyLines.forEach((value) => {\n\t\t\tif (value.rendered) {\n\t\t\t\theight += 22;\n\t\t\t}\n\t\t});\n\t\treturn height;\n\t}\n\n\tprivate setCurrentStickyLines(newStickyLines: Map<OutlineEntry, { line: NotebookStickyLine; rendered: boolean }>) {\n\t\tthis.currentStickyLines = newStickyLines;\n\t}\n\n\tprivate compareStickyLineMaps(mapA: Map<OutlineEntry, { line: NotebookStickyLine; rendered: boolean }>, mapB: Map<OutlineEntry, { line: NotebookStickyLine; rendered: boolean }>): boolean {\n\t\tif (mapA.size !== mapB.size) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (const [key, value] of mapA) {\n\t\t\tconst otherValue = mapB.get(key);\n\t\t\tif (!otherValue || value.rendered !== otherValue.rendered) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tconstructor(\n\t\tprivate readonly domNode: HTMLElement,\n\t\tprivate readonly notebookEditor: INotebookEditor,\n\t\tprivate readonly notebookCellList: INotebookCellList,\n\t\tprivate readonly layoutFn: (delta: number) => void,\n\t\t@IContextMenuService private readonly _contextMenuService: IContextMenuService,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService\n\t) {\n\t\tsuper();\n\n\t\tif (this.notebookEditor.notebookOptions.getDisplayOptions().stickyScrollEnabled) {\n\t\t\tthis.init();\n\t\t}\n\n\t\tthis._register(this.notebookEditor.notebookOptions.onDidChangeOptions((e) => {\n\t\t\tif (e.stickyScrollEnabled || e.stickyScrollMode) {\n\t\t\t\tthis.updateConfig(e);\n\t\t\t}\n\t\t}));\n\n\t\tthis._register(DOM.addDisposableListener(this.domNode, DOM.EventType.CONTEXT_MENU, async (event: MouseEvent) => {\n\t\t\tthis.onContextMenu(event);\n\t\t}));\n\t}\n\n\tprivate onContextMenu(e: MouseEvent) {\n\t\tconst event = new StandardMouseEvent(DOM.getWindow(this.domNode), e);\n\n\t\tconst selectedElement = event.target.parentElement;\n\t\tconst selectedOutlineEntry = Array.from(this.currentStickyLines.values()).find(entry => entry.line.element.contains(selectedElement))?.line.entry;\n\t\tif (!selectedOutlineEntry) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst args: NotebookSectionArgs = {\n\t\t\toutlineEntry: selectedOutlineEntry,\n\t\t\tnotebookEditor: this.notebookEditor,\n\t\t};\n\n\t\tthis._contextMenuService.showContextMenu({\n\t\t\tmenuId: MenuId.NotebookStickyScrollContext,\n\t\t\tgetAnchor: () => event,\n\t\t\tmenuActionOptions: { shouldForwardArgs: true, arg: args },\n\t\t});\n\t}\n\n\tprivate updateConfig(e: NotebookOptionsChangeEvent) {\n\t\tif (e.stickyScrollEnabled) {\n\t\t\tif (this.notebookEditor.notebookOptions.getDisplayOptions().stickyScrollEnabled) {\n\t\t\t\tthis.init();\n\t\t\t} else {\n\t\t\t\tthis._disposables.clear();\n\t\t\t\tthis.notebookCellOutlineReference?.dispose();\n\t\t\t\tthis.disposeCurrentStickyLines();\n\t\t\t\tDOM.clearNode(this.domNode);\n\t\t\t\tthis.updateDisplay();\n\t\t\t}\n\t\t} else if (e.stickyScrollMode && this.notebookEditor.notebookOptions.getDisplayOptions().stickyScrollEnabled && this.notebookCellOutlineReference?.object) {\n\t\t\tthis.updateContent(computeContent(this.notebookEditor, this.notebookCellList, this.notebookCellOutlineReference?.object?.entries, this.getCurrentStickyHeight()));\n\t\t}\n\t}\n\n\tprivate init() {\n\t\tconst { object: notebookCellOutline } = this.notebookCellOutlineReference = this.instantiationService.invokeFunction((accessor) => accessor.get(INotebookCellOutlineDataSourceFactory).getOrCreate(this.notebookEditor));\n\t\tthis._register(this.notebookCellOutlineReference);\n\t\tthis.updateContent(computeContent(this.notebookEditor, this.notebookCellList, notebookCellOutline.entries, this.getCurrentStickyHeight()));\n\n\t\tthis._disposables.add(notebookCellOutline.onDidChange(() => {\n\t\t\tconst recompute = computeContent(this.notebookEditor, this.notebookCellList, notebookCellOutline.entries, this.getCurrentStickyHeight());\n\t\t\tif (!this.compareStickyLineMaps(recompute, this.currentStickyLines)) {\n\t\t\t\tthis.updateContent(recompute);\n\t\t\t}\n\t\t}));\n\n\t\tthis._disposables.add(this.notebookEditor.onDidAttachViewModel(() => {\n\t\t\tthis.updateContent(computeContent(this.notebookEditor, this.notebookCellList, notebookCellOutline.entries, this.getCurrentStickyHeight()));\n\t\t}));\n\n\t\tthis._disposables.add(this.notebookEditor.onDidScroll(() => {\n\t\t\tconst d = new Delayer(100);\n\t\t\td.trigger(() => {\n\t\t\t\td.dispose();\n\t\t\t\tconst recompute = computeContent(this.notebookEditor, this.notebookCellList, notebookCellOutline.entries, this.getCurrentStickyHeight());\n\t\t\t\tif (!this.compareStickyLineMaps(recompute, this.currentStickyLines)) {\n\t\t\t\t\tthis.updateContent(recompute);\n\t\t\t\t}\n\t\t\t});\n\t\t}));\n\t}\n\n\t// take in an cell index, and get the corresponding outline entry\n\tstatic getVisibleOutlineEntry(visibleIndex: number, notebookOutlineEntries: OutlineEntry[]): OutlineEntry | undefined {\n\t\tlet left = 0;\n\t\tlet right = notebookOutlineEntries.length - 1;\n\t\tlet bucket = -1;\n\n\t\twhile (left <= right) {\n\t\t\tconst mid = Math.floor((left + right) / 2);\n\t\t\tif (notebookOutlineEntries[mid].index === visibleIndex) {\n\t\t\t\tbucket = mid;\n\t\t\t\tbreak;\n\t\t\t} else if (notebookOutlineEntries[mid].index < visibleIndex) {\n\t\t\t\tbucket = mid;\n\t\t\t\tleft = mid + 1;\n\t\t\t} else {\n\t\t\t\tright = mid - 1;\n\t\t\t}\n\t\t}\n\n\t\tif (bucket !== -1) {\n\t\t\tconst rootEntry = notebookOutlineEntries[bucket];\n\t\t\tconst flatList: OutlineEntry[] = [];\n\t\t\trootEntry.asFlatList(flatList);\n\t\t\treturn flatList.find(entry => entry.index === visibleIndex);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tprivate updateContent(newMap: Map<OutlineEntry, { line: NotebookStickyLine; rendered: boolean }>) {\n\t\tDOM.clearNode(this.domNode);\n\t\tthis.disposeCurrentStickyLines();\n\t\tthis.renderStickyLines(newMap, this.domNode);\n\n\t\tconst oldStickyHeight = this.getCurrentStickyHeight();\n\t\tthis.setCurrentStickyLines(newMap);\n\n\t\t// (+) = sticky height increased\n\t\t// (-) = sticky height decreased\n\t\tconst sizeDelta = this.getCurrentStickyHeight() - oldStickyHeight;\n\t\tif (sizeDelta !== 0) {\n\t\t\tthis._onDidChangeNotebookStickyScroll.fire(sizeDelta);\n\n\t\t\tconst d = this._layoutDisposableStore.add(DOM.scheduleAtNextAnimationFrame(DOM.getWindow(this.getDomNode()), () => {\n\t\t\t\tthis.layoutFn(sizeDelta);\n\t\t\t\tthis.updateDisplay();\n\n\t\t\t\tthis._layoutDisposableStore.delete(d);\n\t\t\t}));\n\t\t} else {\n\t\t\tthis.updateDisplay();\n\t\t}\n\t}\n\n\tprivate updateDisplay() {\n\t\tconst hasSticky = this.getCurrentStickyHeight() > 0;\n\t\tif (!hasSticky) {\n\t\t\tthis.domNode.style.display = 'none';\n\t\t} else {\n\t\t\tthis.domNode.style.display = 'block';\n\t\t}\n\t}\n\n\tstatic computeStickyHeight(entry: OutlineEntry) {\n\t\tlet height = 0;\n\t\tif (entry.cell.cellKind === CellKind.Markup && entry.level < 7) {\n\t\t\theight += 22;\n\t\t}\n\t\twhile (entry.parent) {\n\t\t\theight += 22;\n\t\t\tentry = entry.parent;\n\t\t}\n\t\treturn height;\n\t}\n\n\tstatic checkCollapsedStickyLines(entry: OutlineEntry | undefined, numLinesToRender: number, notebookEditor: INotebookEditor) {\n\t\tlet currentEntry = entry;\n\t\tconst newMap = new Map<OutlineEntry, { line: NotebookStickyLine; rendered: boolean }>();\n\n\t\tconst elementsToRender = [];\n\t\twhile (currentEntry) {\n\t\t\tif (currentEntry.level >= 7) {\n\t\t\t\t// level 7+ represents a non-header entry, which we don't want to render\n\t\t\t\tcurrentEntry = currentEntry.parent;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst lineToRender = NotebookStickyScroll.createStickyElement(currentEntry, notebookEditor);\n\t\t\tnewMap.set(currentEntry, { line: lineToRender, rendered: false });\n\t\t\telementsToRender.unshift(lineToRender);\n\t\t\tcurrentEntry = currentEntry.parent;\n\t\t}\n\n\t\t// iterate over elements to render, and append to container\n\t\t// break when we reach numLinesToRender\n\t\tfor (let i = 0; i < elementsToRender.length; i++) {\n\t\t\tif (i >= numLinesToRender) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnewMap.set(elementsToRender[i].entry, { line: elementsToRender[i], rendered: true });\n\t\t}\n\t\treturn newMap;\n\t}\n\n\tprivate renderStickyLines(stickyMap: Map<OutlineEntry, { line: NotebookStickyLine; rendered: boolean }>, containerElement: HTMLElement) {\n\t\tconst reversedEntries = Array.from(stickyMap.entries()).reverse();\n\t\tfor (const [, value] of reversedEntries) {\n\t\t\tif (!value.rendered) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcontainerElement.append(value.line.element);\n\t\t}\n\t}\n\n\tstatic createStickyElement(entry: OutlineEntry, notebookEditor: INotebookEditor) {\n\t\tconst stickyElement = document.createElement('div');\n\t\tstickyElement.classList.add('notebook-sticky-scroll-element');\n\n\t\tconst indentMode = notebookEditor.notebookOptions.getLayoutConfiguration().stickyScrollMode;\n\t\tif (indentMode === 'indented') {\n\t\t\tstickyElement.style.paddingLeft = NotebookStickyLine.getParentCount(entry) * 10 + 'px';\n\t\t}\n\n\t\tlet isCollapsed = false;\n\t\tif (entry.cell.cellKind === CellKind.Markup) {\n\t\t\tisCollapsed = (entry.cell as MarkupCellViewModel).foldingState === CellFoldingState.Collapsed;\n\t\t}\n\n\t\tconst stickyFoldingIcon = new StickyFoldingIcon(isCollapsed, 16);\n\t\tstickyFoldingIcon.domNode.classList.add('notebook-sticky-scroll-folding-icon');\n\t\tstickyFoldingIcon.setVisible(true);\n\n\t\tconst stickyHeader = document.createElement('div');\n\t\tstickyHeader.classList.add('notebook-sticky-scroll-header');\n\t\tstickyHeader.innerText = entry.label;\n\n\t\tstickyElement.append(stickyFoldingIcon.domNode, stickyHeader);\n\n\t\treturn new NotebookStickyLine(stickyElement, stickyFoldingIcon, stickyHeader, entry, notebookEditor);\n\t}\n\n\tprivate disposeCurrentStickyLines() {\n\t\tthis.currentStickyLines.forEach((value) => {\n\t\t\tvalue.line.dispose();\n\t\t});\n\t}\n\n\toverride dispose() {\n\t\tthis._disposables.dispose();\n\t\tthis.disposeCurrentStickyLines();\n\t\tthis.notebookCellOutlineReference?.dispose();\n\t\tsuper.dispose();\n\t}\n}\n\nexport function computeContent(notebookEditor: INotebookEditor, notebookCellList: INotebookCellList, notebookOutlineEntries: OutlineEntry[], renderedStickyHeight: number): Map<OutlineEntry, { line: NotebookStickyLine; rendered: boolean }> {\n\t// get data about the cell list within viewport ----------------------------------------------------------------------------------------\n\tconst editorScrollTop = notebookEditor.scrollTop - renderedStickyHeight;\n\tconst visibleRange = notebookEditor.visibleRanges[0];\n\tif (!visibleRange) {\n\t\treturn new Map();\n\t}\n\n\t// edge case for cell 0 in the notebook is a header ------------------------------------------------------------------------------------\n\tif (visibleRange.start === 0) {\n\t\tconst firstCell = notebookEditor.cellAt(0);\n\t\tconst firstCellEntry = NotebookStickyScroll.getVisibleOutlineEntry(0, notebookOutlineEntries);\n\t\tif (firstCell && firstCellEntry && firstCell.cellKind === CellKind.Markup && firstCellEntry.level < 7) {\n\t\t\tif (notebookEditor.scrollTop > 22) {\n\t\t\t\tconst newMap = NotebookStickyScroll.checkCollapsedStickyLines(firstCellEntry, 100, notebookEditor);\n\t\t\t\treturn newMap;\n\t\t\t}\n\t\t}\n\t}\n\n\t// iterate over cells in viewport ------------------------------------------------------------------------------------------------------\n\tlet cell;\n\tlet cellEntry;\n\tconst startIndex = visibleRange.start - 1; // -1 to account for cells hidden \"under\" sticky lines.\n\tfor (let currentIndex = startIndex; currentIndex < visibleRange.end; currentIndex++) {\n\t\t// store data for current cell, and next cell\n\t\tcell = notebookEditor.cellAt(currentIndex);\n\t\tif (!cell) {\n\t\t\treturn new Map();\n\t\t}\n\t\tcellEntry = NotebookStickyScroll.getVisibleOutlineEntry(currentIndex, notebookOutlineEntries);\n\t\tif (!cellEntry) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst nextCell = notebookEditor.cellAt(currentIndex + 1);\n\t\tif (!nextCell) {\n\t\t\tconst sectionBottom = notebookEditor.getLayoutInfo().scrollHeight;\n\t\t\tconst linesToRender = Math.floor((sectionBottom) / 22);\n\t\t\tconst newMap = NotebookStickyScroll.checkCollapsedStickyLines(cellEntry, linesToRender, notebookEditor);\n\t\t\treturn newMap;\n\t\t}\n\t\tconst nextCellEntry = NotebookStickyScroll.getVisibleOutlineEntry(currentIndex + 1, notebookOutlineEntries);\n\t\tif (!nextCellEntry) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// check next cell, if markdown with non level 7 entry, that means this is the end of the section (new header) ---------------------\n\t\tif (nextCell.cellKind === CellKind.Markup && nextCellEntry.level < 7) {\n\t\t\tconst sectionBottom = notebookCellList.getCellViewScrollTop(nextCell);\n\t\t\tconst currentSectionStickyHeight = NotebookStickyScroll.computeStickyHeight(cellEntry);\n\t\t\tconst nextSectionStickyHeight = NotebookStickyScroll.computeStickyHeight(nextCellEntry);\n\n\t\t\t// case: we can render the all sticky lines for the current section ------------------------------------------------------------\n\t\t\tif (editorScrollTop + currentSectionStickyHeight < sectionBottom) {\n\t\t\t\tconst linesToRender = Math.floor((sectionBottom - editorScrollTop) / 22);\n\t\t\t\tconst newMap = NotebookStickyScroll.checkCollapsedStickyLines(cellEntry, linesToRender, notebookEditor);\n\t\t\t\treturn newMap;\n\t\t\t}\n\n\t\t\t// case: next section is the same size or bigger, render next entry -----------------------------------------------------------\n\t\t\telse if (nextSectionStickyHeight >= currentSectionStickyHeight) {\n\t\t\t\tconst newMap = NotebookStickyScroll.checkCollapsedStickyLines(nextCellEntry, 100, notebookEditor);\n\t\t\t\treturn newMap;\n\t\t\t}\n\t\t\t// case: next section is the smaller, shrink until next section height is greater than the available space ---------------------\n\t\t\telse if (nextSectionStickyHeight < currentSectionStickyHeight) {\n\t\t\t\tconst availableSpace = sectionBottom - editorScrollTop;\n\n\t\t\t\tif (availableSpace >= nextSectionStickyHeight) {\n\t\t\t\t\tconst linesToRender = Math.floor((availableSpace) / 22);\n\t\t\t\t\tconst newMap = NotebookStickyScroll.checkCollapsedStickyLines(cellEntry, linesToRender, notebookEditor);\n\t\t\t\t\treturn newMap;\n\t\t\t\t} else {\n\t\t\t\t\tconst newMap = NotebookStickyScroll.checkCollapsedStickyLines(nextCellEntry, 100, notebookEditor);\n\t\t\t\t\treturn newMap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} // visible range loop close\n\n\t// case: all visible cells were non-header cells, so render any headers relevant to their section --------------------------------------\n\tconst sectionBottom = notebookEditor.getLayoutInfo().scrollHeight;\n\tconst linesToRender = Math.floor((sectionBottom - editorScrollTop) / 22);\n\tconst newMap = NotebookStickyScroll.checkCollapsedStickyLines(cellEntry, linesToRender, notebookEditor);\n\treturn newMap;\n}\n"],
  "mappings": "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",
  "names": ["newMap", "sectionBottom", "linesToRender"]
}
