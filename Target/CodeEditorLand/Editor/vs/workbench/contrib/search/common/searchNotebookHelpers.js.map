{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/contrib/search/common/searchNotebookHelpers.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { URI, UriComponents } from \"../../../../base/common/uri.js\";\nimport { Range } from \"../../../../editor/common/core/range.js\";\nimport type {\n\tFindMatch,\n\tIReadonlyTextBuffer,\n} from \"../../../../editor/common/model.js\";\nimport {\n\ttype IFileMatch,\n\ttype ITextSearchMatch,\n\tTextSearchMatch,\n} from \"../../../services/search/common/search.js\";\n\nexport type IRawClosedNotebookFileMatch =\n\tINotebookFileMatchNoModel<UriComponents>;\n\nexport interface INotebookFileMatchNoModel<U extends UriComponents = URI>\n\textends IFileMatch<U> {\n\tcellResults: INotebookCellMatchNoModel<U>[];\n}\n\nexport interface INotebookCellMatchNoModel<U extends UriComponents = URI> {\n\tindex: number;\n\tcontentResults: ITextSearchMatch<U>[];\n\twebviewResults: ITextSearchMatch<U>[];\n}\n\nexport function isINotebookFileMatchNoModel(\n\tobject: IFileMatch,\n): object is INotebookFileMatchNoModel {\n\treturn \"cellResults\" in object;\n}\n\nexport const rawCellPrefix = \"rawCell#\";\n\nexport function genericCellMatchesToTextSearchMatches(\n\tcontentMatches: FindMatch[],\n\tbuffer: IReadonlyTextBuffer,\n) {\n\tlet previousEndLine = -1;\n\tconst contextGroupings: FindMatch[][] = [];\n\tlet currentContextGrouping: FindMatch[] = [];\n\n\tcontentMatches.forEach((match) => {\n\t\tif (match.range.startLineNumber !== previousEndLine) {\n\t\t\tif (currentContextGrouping.length > 0) {\n\t\t\t\tcontextGroupings.push([...currentContextGrouping]);\n\t\t\t\tcurrentContextGrouping = [];\n\t\t\t}\n\t\t}\n\n\t\tcurrentContextGrouping.push(match);\n\t\tpreviousEndLine = match.range.endLineNumber;\n\t});\n\n\tif (currentContextGrouping.length > 0) {\n\t\tcontextGroupings.push([...currentContextGrouping]);\n\t}\n\n\tconst textSearchResults = contextGroupings.map((grouping) => {\n\t\tconst lineTexts: string[] = [];\n\t\tconst firstLine = grouping[0].range.startLineNumber;\n\t\tconst lastLine = grouping[grouping.length - 1].range.endLineNumber;\n\t\tfor (let i = firstLine; i <= lastLine; i++) {\n\t\t\tlineTexts.push(buffer.getLineContent(i));\n\t\t}\n\t\treturn new TextSearchMatch(\n\t\t\tlineTexts.join(\"\\n\") + \"\\n\",\n\t\t\tgrouping.map(\n\t\t\t\t(m) =>\n\t\t\t\t\tnew Range(\n\t\t\t\t\t\tm.range.startLineNumber - 1,\n\t\t\t\t\t\tm.range.startColumn - 1,\n\t\t\t\t\t\tm.range.endLineNumber - 1,\n\t\t\t\t\t\tm.range.endColumn - 1,\n\t\t\t\t\t),\n\t\t\t),\n\t\t);\n\t});\n\n\treturn textSearchResults;\n}\n"],
  "mappings": ";;AAMA,SAAS,aAAa;AAKtB;AAAA,EAGC;AAAA,OACM;AAgBA,SAAS,4BACf,QACsC;AACtC,SAAO,iBAAiB;AACzB;AAJgB;AAMT,MAAM,gBAAgB;AAEtB,SAAS,sCACf,gBACA,QACC;AACD,MAAI,kBAAkB;AACtB,QAAM,mBAAkC,CAAC;AACzC,MAAI,yBAAsC,CAAC;AAE3C,iBAAe,QAAQ,CAAC,UAAU;AACjC,QAAI,MAAM,MAAM,oBAAoB,iBAAiB;AACpD,UAAI,uBAAuB,SAAS,GAAG;AACtC,yBAAiB,KAAK,CAAC,GAAG,sBAAsB,CAAC;AACjD,iCAAyB,CAAC;AAAA,MAC3B;AAAA,IACD;AAEA,2BAAuB,KAAK,KAAK;AACjC,sBAAkB,MAAM,MAAM;AAAA,EAC/B,CAAC;AAED,MAAI,uBAAuB,SAAS,GAAG;AACtC,qBAAiB,KAAK,CAAC,GAAG,sBAAsB,CAAC;AAAA,EAClD;AAEA,QAAM,oBAAoB,iBAAiB,IAAI,CAAC,aAAa;AAC5D,UAAM,YAAsB,CAAC;AAC7B,UAAM,YAAY,SAAS,CAAC,EAAE,MAAM;AACpC,UAAM,WAAW,SAAS,SAAS,SAAS,CAAC,EAAE,MAAM;AACrD,aAAS,IAAI,WAAW,KAAK,UAAU,KAAK;AAC3C,gBAAU,KAAK,OAAO,eAAe,CAAC,CAAC;AAAA,IACxC;AACA,WAAO,IAAI;AAAA,MACV,UAAU,KAAK,IAAI,IAAI;AAAA,MACvB,SAAS;AAAA,QACR,CAAC,MACA,IAAI;AAAA,UACH,EAAE,MAAM,kBAAkB;AAAA,UAC1B,EAAE,MAAM,cAAc;AAAA,UACtB,EAAE,MAAM,gBAAgB;AAAA,UACxB,EAAE,MAAM,YAAY;AAAA,QACrB;AAAA,MACF;AAAA,IACD;AAAA,EACD,CAAC;AAED,SAAO;AACR;AA9CgB;",
  "names": []
}
