import{importAMDNodeModule as L}from"../../../../../amdX.js";import{Disposable as S}from"../../../../../base/common/lifecycle.js";import{autorun as I,keepObserved as C}from"../../../../../base/common/observable.js";import"../../../../../base/common/worker/simpleWorker.js";import{countEOL as b}from"../../../../../editor/common/core/eolCounter.js";import"../../../../../editor/common/core/lineRange.js";import{Range as T}from"../../../../../editor/common/core/range.js";import"../../../../../editor/common/languages.js";import"../../../../../editor/common/model.js";import{TokenizationStateStore as v}from"../../../../../editor/common/model/textModelTokens.js";import"../../../../../editor/common/textModelEvents.js";import{ContiguousMultilineTokensBuilder as m}from"../../../../../editor/common/tokens/contiguousMultilineTokensBuilder.js";import"../../../../../platform/configuration/common/configuration.js";import{observableConfigValue as y}from"../../../../../platform/observable/common/platformObservableUtils.js";import{ArrayEdit as x,MonotonousIndexTransformer as u,SingleArrayEdit as z}from"../arrayOperation.js";class k extends S{constructor(g,s,l,h,r,c){super();this._model=g;this._worker=s;this._languageIdCodec=l;this._backgroundTokenizationStore=h;this._configurationService=r;this._maxTokenizationLineLength=c;this._register(C(this._loggingEnabled)),this._register(this._model.onDidChangeContent(t=>{this._shouldLog,this._worker.$acceptModelChanged(this.controllerId,t),this._pendingChanges.push(t)})),this._register(this._model.onDidChangeLanguage(t=>{const n=this._model.getLanguageId(),i=this._languageIdCodec.encodeLanguageId(n);this._worker.$acceptModelLanguageChanged(this.controllerId,n,i)}));const e=this._model.getLanguageId(),o=this._languageIdCodec.encodeLanguageId(e);this._worker.$acceptNewModel({uri:this._model.uri,versionId:this._model.getVersionId(),lines:this._model.getLinesContent(),EOL:this._model.getEOL(),languageId:e,encodedLanguageId:o,maxTokenizationLineLength:this._maxTokenizationLineLength.get(),controllerId:this.controllerId}),this._register(I(t=>{const n=this._maxTokenizationLineLength.read(t);this._worker.$acceptMaxTokenizationLineLength(this.controllerId,n)}))}static _id=0;controllerId=k._id++;_pendingChanges=[];_states=new v;_loggingEnabled=y("editor.experimental.asyncTokenizationLogging",!1,this._configurationService);_applyStateStackDiffFn;_initialState;dispose(){super.dispose(),this._worker.$acceptRemovedModel(this.controllerId)}requestTokens(g,s){this._worker.$retokenize(this.controllerId,g,s)}async setTokensAndStates(g,s,l,h){if(this.controllerId!==g)return;let r=m.deserialize(new Uint8Array(l));if(this._shouldLog,this._shouldLog){const e=this._pendingChanges.filter(o=>o.versionId<=s).map(o=>o.changes).map(o=>_(o)).join(" then ")}for(;this._pendingChanges.length>0&&this._pendingChanges[0].versionId<=s;){const e=this._pendingChanges.shift();this._states.acceptChanges(e.changes)}if(this._pendingChanges.length>0){if(this._shouldLog){const t=this._pendingChanges.map(n=>n.changes).map(n=>_(n)).join(" then ")}const e=u.fromMany(this._pendingChanges.map(t=>f(t.changes))),o=new m;for(const t of r)for(let n=t.startLineNumber;n<=t.endLineNumber;n++)e.transform(n-1)!==void 0&&o.add(n,t.getLineTokens(n));r=o.finalize();for(const t of this._pendingChanges)for(const n of t.changes)for(let i=0;i<r.length;i++)r[i].applyEdit(n.range,n.text)}const c=u.fromMany(this._pendingChanges.map(e=>f(e.changes)));if(!this._applyStateStackDiffFn||!this._initialState){const{applyStateStackDiff:e,INITIAL:o}=await L("vscode-textmate","release/main.js");this._applyStateStackDiffFn=e,this._initialState=o}for(const e of h){let o=e.startLineNumber<=1?this._initialState:this._states.getEndState(e.startLineNumber-1);for(let t=0;t<e.stateDeltas.length;t++){const n=e.stateDeltas[t];let i;n?(i=this._applyStateStackDiffFn(o,n),this._states.setEndState(e.startLineNumber+t,i)):i=this._states.getEndState(e.startLineNumber+t);const p=c.transform(e.startLineNumber+t-1);p!==void 0&&this._backgroundTokenizationStore.setEndState(p+1,i),e.startLineNumber+t>=this._model.getLineCount()-1&&this._backgroundTokenizationStore.backgroundTokenizationFinished(),o=i}}this._backgroundTokenizationStore.setTokens(r)}get _shouldLog(){return this._loggingEnabled.get()}}function f(d){return new x(d.map(a=>new z(a.range.startLineNumber-1,a.range.endLineNumber-a.range.startLineNumber+1,b(a.text)[0]+1)))}function _(d){return d.map(a=>T.lift(a.range).toString()+" => "+a.text).join(" & ")}export{k as TextMateWorkerTokenizerController};
