{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/configurationResolver/common/variableResolver.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as paths from '../../../../base/common/path.js';\nimport * as process from '../../../../base/common/process.js';\nimport * as types from '../../../../base/common/types.js';\nimport * as objects from '../../../../base/common/objects.js';\nimport { IStringDictionary } from '../../../../base/common/collections.js';\nimport { IProcessEnvironment, isWindows, isMacintosh, isLinux } from '../../../../base/common/platform.js';\nimport { normalizeDriveLetter } from '../../../../base/common/labels.js';\nimport { localize } from '../../../../nls.js';\nimport { URI as uri } from '../../../../base/common/uri.js';\nimport { IConfigurationResolverService, VariableError, VariableKind } from './configurationResolver.js';\nimport { IWorkspaceFolder } from '../../../../platform/workspace/common/workspace.js';\nimport { ILabelService } from '../../../../platform/label/common/label.js';\nimport { replaceAsync } from '../../../../base/common/strings.js';\n\ninterface IVariableResolveContext {\n\tgetFolderUri(folderName: string): uri | undefined;\n\tgetWorkspaceFolderCount(): number;\n\tgetConfigurationValue(folderUri: uri | undefined, section: string): string | undefined;\n\tgetAppRoot(): string | undefined;\n\tgetExecPath(): string | undefined;\n\tgetFilePath(): string | undefined;\n\tgetWorkspaceFolderPathForFile?(): string | undefined;\n\tgetSelectedText(): string | undefined;\n\tgetLineNumber(): string | undefined;\n\tgetExtension(id: string): Promise<{ readonly extensionLocation: uri } | undefined>;\n}\n\ntype Environment = { env: IProcessEnvironment | undefined; userHome: string | undefined };\n\nexport class AbstractVariableResolverService implements IConfigurationResolverService {\n\n\tstatic readonly VARIABLE_LHS = '${';\n\tstatic readonly VARIABLE_REGEXP = /\\$\\{(.*?)\\}/g;\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate _context: IVariableResolveContext;\n\tprivate _labelService?: ILabelService;\n\tprivate _envVariablesPromise?: Promise<IProcessEnvironment>;\n\tprivate _userHomePromise?: Promise<string>;\n\tprotected _contributedVariables: Map<string, () => Promise<string | undefined>> = new Map();\n\n\tconstructor(_context: IVariableResolveContext, _labelService?: ILabelService, _userHomePromise?: Promise<string>, _envVariablesPromise?: Promise<IProcessEnvironment>) {\n\t\tthis._context = _context;\n\t\tthis._labelService = _labelService;\n\t\tthis._userHomePromise = _userHomePromise;\n\t\tif (_envVariablesPromise) {\n\t\t\tthis._envVariablesPromise = _envVariablesPromise.then(envVariables => {\n\t\t\t\treturn this.prepareEnv(envVariables);\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate prepareEnv(envVariables: IProcessEnvironment): IProcessEnvironment {\n\t\t// windows env variables are case insensitive\n\t\tif (isWindows) {\n\t\t\tconst ev: IProcessEnvironment = Object.create(null);\n\t\t\tObject.keys(envVariables).forEach(key => {\n\t\t\t\tev[key.toLowerCase()] = envVariables[key];\n\t\t\t});\n\t\t\treturn ev;\n\t\t}\n\t\treturn envVariables;\n\t}\n\n\tpublic resolveWithEnvironment(environment: IProcessEnvironment, root: IWorkspaceFolder | undefined, value: string): Promise<string> {\n\t\treturn this.recursiveResolve({ env: this.prepareEnv(environment), userHome: undefined }, root ? root.uri : undefined, value);\n\t}\n\n\tpublic async resolveAsync(root: IWorkspaceFolder | undefined, value: string): Promise<string>;\n\tpublic async resolveAsync(root: IWorkspaceFolder | undefined, value: string[]): Promise<string[]>;\n\tpublic async resolveAsync(root: IWorkspaceFolder | undefined, value: IStringDictionary<string>): Promise<IStringDictionary<string>>;\n\tpublic async resolveAsync(root: IWorkspaceFolder | undefined, value: any): Promise<any> {\n\t\tconst environment: Environment = {\n\t\t\tenv: await this._envVariablesPromise,\n\t\t\tuserHome: await this._userHomePromise\n\t\t};\n\t\treturn this.recursiveResolve(environment, root ? root.uri : undefined, value);\n\t}\n\n\tprivate async resolveAnyBase(workspaceFolder: IWorkspaceFolder | undefined, config: any, commandValueMapping?: IStringDictionary<string>, resolvedVariables?: Map<string, string>): Promise<any> {\n\n\t\tconst result = objects.deepClone(config);\n\n\t\t// hoist platform specific attributes to top level\n\t\tif (isWindows && result.windows) {\n\t\t\tObject.keys(result.windows).forEach(key => result[key] = result.windows[key]);\n\t\t} else if (isMacintosh && result.osx) {\n\t\t\tObject.keys(result.osx).forEach(key => result[key] = result.osx[key]);\n\t\t} else if (isLinux && result.linux) {\n\t\t\tObject.keys(result.linux).forEach(key => result[key] = result.linux[key]);\n\t\t}\n\n\t\t// delete all platform specific sections\n\t\tdelete result.windows;\n\t\tdelete result.osx;\n\t\tdelete result.linux;\n\n\t\t// substitute all variables recursively in string values\n\t\tconst environmentPromises: Environment = {\n\t\t\tenv: await this._envVariablesPromise,\n\t\t\tuserHome: await this._userHomePromise\n\t\t};\n\t\treturn this.recursiveResolve(environmentPromises, workspaceFolder ? workspaceFolder.uri : undefined, result, commandValueMapping, resolvedVariables);\n\t}\n\n\tpublic async resolveAnyAsync(workspaceFolder: IWorkspaceFolder | undefined, config: any, commandValueMapping?: IStringDictionary<string>): Promise<any> {\n\t\treturn this.resolveAnyBase(workspaceFolder, config, commandValueMapping);\n\t}\n\n\tpublic async resolveAnyMap(workspaceFolder: IWorkspaceFolder | undefined, config: any, commandValueMapping?: IStringDictionary<string>): Promise<{ newConfig: any; resolvedVariables: Map<string, string> }> {\n\t\tconst resolvedVariables = new Map<string, string>();\n\t\tconst newConfig = await this.resolveAnyBase(workspaceFolder, config, commandValueMapping, resolvedVariables);\n\t\treturn { newConfig, resolvedVariables };\n\t}\n\n\tpublic resolveWithInteractionReplace(folder: IWorkspaceFolder | undefined, config: any, section?: string, variables?: IStringDictionary<string>): Promise<any> {\n\t\tthrow new Error('resolveWithInteractionReplace not implemented.');\n\t}\n\n\tpublic resolveWithInteraction(folder: IWorkspaceFolder | undefined, config: any, section?: string, variables?: IStringDictionary<string>): Promise<Map<string, string> | undefined> {\n\t\tthrow new Error('resolveWithInteraction not implemented.');\n\t}\n\n\tpublic contributeVariable(variable: string, resolution: () => Promise<string | undefined>): void {\n\t\tif (this._contributedVariables.has(variable)) {\n\t\t\tthrow new Error('Variable ' + variable + ' is contributed twice.');\n\t\t} else {\n\t\t\tthis._contributedVariables.set(variable, resolution);\n\t\t}\n\t}\n\n\tprivate async recursiveResolve(environment: Environment, folderUri: uri | undefined, value: any, commandValueMapping?: IStringDictionary<string>, resolvedVariables?: Map<string, string>): Promise<any> {\n\t\tif (types.isString(value)) {\n\t\t\treturn this.resolveString(environment, folderUri, value, commandValueMapping, resolvedVariables);\n\t\t} else if (Array.isArray(value)) {\n\t\t\treturn Promise.all(value.map(s => this.recursiveResolve(environment, folderUri, s, commandValueMapping, resolvedVariables)));\n\t\t} else if (types.isObject(value)) {\n\t\t\tconst result: IStringDictionary<string | IStringDictionary<string> | string[]> = Object.create(null);\n\t\t\tconst replaced = await Promise.all(Object.keys(value).map(async key => {\n\t\t\t\tconst replaced = await this.resolveString(environment, folderUri, key, commandValueMapping, resolvedVariables);\n\t\t\t\treturn [replaced, await this.recursiveResolve(environment, folderUri, value[key], commandValueMapping, resolvedVariables)] as const;\n\t\t\t}));\n\t\t\t// two step process to preserve object key order\n\t\t\tfor (const [key, value] of replaced) {\n\t\t\t\tresult[key] = value;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\treturn value;\n\t}\n\n\tprivate resolveString(environment: Environment, folderUri: uri | undefined, value: string, commandValueMapping: IStringDictionary<string> | undefined, resolvedVariables?: Map<string, string>): Promise<string> {\n\t\t// loop through all variables occurrences in 'value'\n\t\treturn replaceAsync(value, AbstractVariableResolverService.VARIABLE_REGEXP, async (match: string, variable: string) => {\n\t\t\t// disallow attempted nesting, see #77289. This doesn't exclude variables that resolve to other variables.\n\t\t\tif (variable.includes(AbstractVariableResolverService.VARIABLE_LHS)) {\n\t\t\t\treturn match;\n\t\t\t}\n\n\t\t\tlet resolvedValue = await this.evaluateSingleVariable(environment, match, variable, folderUri, commandValueMapping);\n\n\t\t\tresolvedVariables?.set(variable, resolvedValue);\n\n\t\t\tif ((resolvedValue !== match) && types.isString(resolvedValue) && resolvedValue.match(AbstractVariableResolverService.VARIABLE_REGEXP)) {\n\t\t\t\tresolvedValue = await this.resolveString(environment, folderUri, resolvedValue, commandValueMapping, resolvedVariables);\n\t\t\t}\n\n\t\t\treturn resolvedValue;\n\t\t});\n\t}\n\n\tprivate fsPath(displayUri: uri): string {\n\t\treturn this._labelService ? this._labelService.getUriLabel(displayUri, { noPrefix: true }) : displayUri.fsPath;\n\t}\n\n\tprivate async evaluateSingleVariable(environment: Environment, match: string, variable: string, folderUri: uri | undefined, commandValueMapping: IStringDictionary<string> | undefined): Promise<string> {\n\n\t\t// try to separate variable arguments from variable name\n\t\tlet argument: string | undefined;\n\t\tconst parts = variable.split(':');\n\t\tif (parts.length > 1) {\n\t\t\tvariable = parts[0];\n\t\t\targument = parts[1];\n\t\t}\n\n\t\t// common error handling for all variables that require an open editor\n\t\tconst getFilePath = (variableKind: VariableKind): string => {\n\n\t\t\tconst filePath = this._context.getFilePath();\n\t\t\tif (filePath) {\n\t\t\t\treturn normalizeDriveLetter(filePath);\n\t\t\t}\n\t\t\tthrow new VariableError(variableKind, (localize('canNotResolveFile', \"Variable {0} can not be resolved. Please open an editor.\", match)));\n\t\t};\n\n\t\t// common error handling for all variables that require an open editor\n\t\tconst getFolderPathForFile = (variableKind: VariableKind): string => {\n\n\t\t\tconst filePath = getFilePath(variableKind);\t\t// throws error if no editor open\n\t\t\tif (this._context.getWorkspaceFolderPathForFile) {\n\t\t\t\tconst folderPath = this._context.getWorkspaceFolderPathForFile();\n\t\t\t\tif (folderPath) {\n\t\t\t\t\treturn normalizeDriveLetter(folderPath);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new VariableError(variableKind, localize('canNotResolveFolderForFile', \"Variable {0}: can not find workspace folder of '{1}'.\", match, paths.basename(filePath)));\n\t\t};\n\n\t\t// common error handling for all variables that require an open folder and accept a folder name argument\n\t\tconst getFolderUri = (variableKind: VariableKind): uri => {\n\n\t\t\tif (argument) {\n\t\t\t\tconst folder = this._context.getFolderUri(argument);\n\t\t\t\tif (folder) {\n\t\t\t\t\treturn folder;\n\t\t\t\t}\n\t\t\t\tthrow new VariableError(variableKind, localize('canNotFindFolder', \"Variable {0} can not be resolved. No such folder '{1}'.\", match, argument));\n\t\t\t}\n\n\t\t\tif (folderUri) {\n\t\t\t\treturn folderUri;\n\t\t\t}\n\n\t\t\tif (this._context.getWorkspaceFolderCount() > 1) {\n\t\t\t\tthrow new VariableError(variableKind, localize('canNotResolveWorkspaceFolderMultiRoot', \"Variable {0} can not be resolved in a multi folder workspace. Scope this variable using ':' and a workspace folder name.\", match));\n\t\t\t}\n\t\t\tthrow new VariableError(variableKind, localize('canNotResolveWorkspaceFolder', \"Variable {0} can not be resolved. Please open a folder.\", match));\n\t\t};\n\n\n\t\tswitch (variable) {\n\n\t\t\tcase 'env':\n\t\t\t\tif (argument) {\n\t\t\t\t\tif (environment.env) {\n\t\t\t\t\t\t// Depending on the source of the environment, on Windows, the values may all be lowercase.\n\t\t\t\t\t\tconst env = environment.env[isWindows ? argument.toLowerCase() : argument];\n\t\t\t\t\t\tif (types.isString(env)) {\n\t\t\t\t\t\t\treturn env;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// For `env` we should do the same as a normal shell does - evaluates undefined envs to an empty string #46436\n\t\t\t\t\treturn '';\n\t\t\t\t}\n\t\t\t\tthrow new VariableError(VariableKind.Env, localize('missingEnvVarName', \"Variable {0} can not be resolved because no environment variable name is given.\", match));\n\n\t\t\tcase 'config':\n\t\t\t\tif (argument) {\n\t\t\t\t\tconst config = this._context.getConfigurationValue(folderUri, argument);\n\t\t\t\t\tif (types.isUndefinedOrNull(config)) {\n\t\t\t\t\t\tthrow new VariableError(VariableKind.Config, localize('configNotFound', \"Variable {0} can not be resolved because setting '{1}' not found.\", match, argument));\n\t\t\t\t\t}\n\t\t\t\t\tif (types.isObject(config)) {\n\t\t\t\t\t\tthrow new VariableError(VariableKind.Config, localize('configNoString', \"Variable {0} can not be resolved because '{1}' is a structured value.\", match, argument));\n\t\t\t\t\t}\n\t\t\t\t\treturn config;\n\t\t\t\t}\n\t\t\t\tthrow new VariableError(VariableKind.Config, localize('missingConfigName', \"Variable {0} can not be resolved because no settings name is given.\", match));\n\n\t\t\tcase 'command':\n\t\t\t\treturn this.resolveFromMap(VariableKind.Command, match, argument, commandValueMapping, 'command');\n\n\t\t\tcase 'input':\n\t\t\t\treturn this.resolveFromMap(VariableKind.Input, match, argument, commandValueMapping, 'input');\n\n\t\t\tcase 'extensionInstallFolder':\n\t\t\t\tif (argument) {\n\t\t\t\t\tconst ext = await this._context.getExtension(argument);\n\t\t\t\t\tif (!ext) {\n\t\t\t\t\t\tthrow new VariableError(VariableKind.ExtensionInstallFolder, localize('extensionNotInstalled', \"Variable {0} can not be resolved because the extension {1} is not installed.\", match, argument));\n\t\t\t\t\t}\n\t\t\t\t\treturn this.fsPath(ext.extensionLocation);\n\t\t\t\t}\n\t\t\t\tthrow new VariableError(VariableKind.ExtensionInstallFolder, localize('missingExtensionName', \"Variable {0} can not be resolved because no extension name is given.\", match));\n\n\t\t\tdefault: {\n\n\t\t\t\tswitch (variable) {\n\t\t\t\t\tcase 'workspaceRoot':\n\t\t\t\t\tcase 'workspaceFolder':\n\t\t\t\t\t\treturn normalizeDriveLetter(this.fsPath(getFolderUri(VariableKind.WorkspaceFolder)));\n\n\t\t\t\t\tcase 'cwd':\n\t\t\t\t\t\treturn ((folderUri || argument) ? normalizeDriveLetter(this.fsPath(getFolderUri(VariableKind.Cwd))) : process.cwd());\n\n\t\t\t\t\tcase 'workspaceRootFolderName':\n\t\t\t\t\tcase 'workspaceFolderBasename':\n\t\t\t\t\t\treturn normalizeDriveLetter(paths.basename(this.fsPath(getFolderUri(VariableKind.WorkspaceFolderBasename))));\n\n\t\t\t\t\tcase 'userHome': {\n\t\t\t\t\t\tif (environment.userHome) {\n\t\t\t\t\t\t\treturn environment.userHome;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow new VariableError(VariableKind.UserHome, localize('canNotResolveUserHome', \"Variable {0} can not be resolved. UserHome path is not defined\", match));\n\t\t\t\t\t}\n\n\t\t\t\t\tcase 'lineNumber': {\n\t\t\t\t\t\tconst lineNumber = this._context.getLineNumber();\n\t\t\t\t\t\tif (lineNumber) {\n\t\t\t\t\t\t\treturn lineNumber;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow new VariableError(VariableKind.LineNumber, localize('canNotResolveLineNumber', \"Variable {0} can not be resolved. Make sure to have a line selected in the active editor.\", match));\n\t\t\t\t\t}\n\t\t\t\t\tcase 'selectedText': {\n\t\t\t\t\t\tconst selectedText = this._context.getSelectedText();\n\t\t\t\t\t\tif (selectedText) {\n\t\t\t\t\t\t\treturn selectedText;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow new VariableError(VariableKind.SelectedText, localize('canNotResolveSelectedText', \"Variable {0} can not be resolved. Make sure to have some text selected in the active editor.\", match));\n\t\t\t\t\t}\n\t\t\t\t\tcase 'file':\n\t\t\t\t\t\treturn getFilePath(VariableKind.File);\n\n\t\t\t\t\tcase 'fileWorkspaceFolder':\n\t\t\t\t\t\treturn getFolderPathForFile(VariableKind.FileWorkspaceFolder);\n\n\t\t\t\t\tcase 'fileWorkspaceFolderBasename':\n\t\t\t\t\t\treturn paths.basename(getFolderPathForFile(VariableKind.FileWorkspaceFolderBasename));\n\n\t\t\t\t\tcase 'relativeFile':\n\t\t\t\t\t\tif (folderUri || argument) {\n\t\t\t\t\t\t\treturn paths.relative(this.fsPath(getFolderUri(VariableKind.RelativeFile)), getFilePath(VariableKind.RelativeFile));\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn getFilePath(VariableKind.RelativeFile);\n\n\t\t\t\t\tcase 'relativeFileDirname': {\n\t\t\t\t\t\tconst dirname = paths.dirname(getFilePath(VariableKind.RelativeFileDirname));\n\t\t\t\t\t\tif (folderUri || argument) {\n\t\t\t\t\t\t\tconst relative = paths.relative(this.fsPath(getFolderUri(VariableKind.RelativeFileDirname)), dirname);\n\t\t\t\t\t\t\treturn relative.length === 0 ? '.' : relative;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn dirname;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'fileDirname':\n\t\t\t\t\t\treturn paths.dirname(getFilePath(VariableKind.FileDirname));\n\n\t\t\t\t\tcase 'fileExtname':\n\t\t\t\t\t\treturn paths.extname(getFilePath(VariableKind.FileExtname));\n\n\t\t\t\t\tcase 'fileBasename':\n\t\t\t\t\t\treturn paths.basename(getFilePath(VariableKind.FileBasename));\n\n\t\t\t\t\tcase 'fileBasenameNoExtension': {\n\t\t\t\t\t\tconst basename = paths.basename(getFilePath(VariableKind.FileBasenameNoExtension));\n\t\t\t\t\t\treturn (basename.slice(0, basename.length - paths.extname(basename).length));\n\t\t\t\t\t}\n\t\t\t\t\tcase 'fileDirnameBasename':\n\t\t\t\t\t\treturn paths.basename(paths.dirname(getFilePath(VariableKind.FileDirnameBasename)));\n\n\t\t\t\t\tcase 'execPath': {\n\t\t\t\t\t\tconst ep = this._context.getExecPath();\n\t\t\t\t\t\tif (ep) {\n\t\t\t\t\t\t\treturn ep;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn match;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'execInstallFolder': {\n\t\t\t\t\t\tconst ar = this._context.getAppRoot();\n\t\t\t\t\t\tif (ar) {\n\t\t\t\t\t\t\treturn ar;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn match;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'pathSeparator':\n\t\t\t\t\tcase '/':\n\t\t\t\t\t\treturn paths.sep;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst key = argument ? `${variable}:${argument}` : variable;\n\t\t\t\t\t\t\treturn this.resolveFromMap(VariableKind.Unknown, match, key, commandValueMapping, undefined);\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\treturn match;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate resolveFromMap(variableKind: VariableKind, match: string, argument: string | undefined, commandValueMapping: IStringDictionary<string> | undefined, prefix: string | undefined): string {\n\t\tif (argument && commandValueMapping) {\n\t\t\tconst v = (prefix === undefined) ? commandValueMapping[argument] : commandValueMapping[prefix + ':' + argument];\n\t\t\tif (typeof v === 'string') {\n\t\t\t\treturn v;\n\t\t\t}\n\t\t\tthrow new VariableError(variableKind, localize('noValueForCommand', \"Variable {0} can not be resolved because the command has no value.\", match));\n\t\t}\n\t\treturn match;\n\t}\n}\n"],
  "mappings": "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",
  "names": ["replaced", "value"]
}
