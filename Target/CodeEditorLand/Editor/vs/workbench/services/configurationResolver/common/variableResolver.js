import*as f from"../../../../base/common/path.js";import*as P from"../../../../base/common/process.js";import*as m from"../../../../base/common/types.js";import*as y from"../../../../base/common/objects.js";import"../../../../base/common/collections.js";import{isWindows as w,isMacintosh as I,isLinux as x}from"../../../../base/common/platform.js";import{normalizeDriveLetter as h}from"../../../../base/common/labels.js";import{localize as d}from"../../../../nls.js";import"../../../../base/common/uri.js";import{VariableError as u,VariableKind as a}from"./configurationResolver.js";import"../../../../platform/workspace/common/workspace.js";import"../../../../platform/label/common/label.js";import{replaceAsync as E}from"../../../../base/common/strings.js";class b{static VARIABLE_LHS="${";static VARIABLE_REGEXP=/\$\{(.*?)\}/g;_context;_labelService;_envVariablesPromise;_userHomePromise;_contributedVariables=new Map;constructor(n,e,t,o){this._context=n,this._labelService=e,this._userHomePromise=t,o&&(this._envVariablesPromise=o.then(s=>this.prepareEnv(s)))}prepareEnv(n){if(w){const e=Object.create(null);return Object.keys(n).forEach(t=>{e[t.toLowerCase()]=n[t]}),e}return n}resolveWithEnvironment(n,e,t){return this.recursiveResolve({env:this.prepareEnv(n),userHome:void 0},e?e.uri:void 0,t)}async resolveAsync(n,e){const t={env:await this._envVariablesPromise,userHome:await this._userHomePromise};return this.recursiveResolve(t,n?n.uri:void 0,e)}async resolveAnyBase(n,e,t,o){const s=y.deepClone(e);w&&s.windows?Object.keys(s.windows).forEach(c=>s[c]=s.windows[c]):I&&s.osx?Object.keys(s.osx).forEach(c=>s[c]=s.osx[c]):x&&s.linux&&Object.keys(s.linux).forEach(c=>s[c]=s.linux[c]),delete s.windows,delete s.osx,delete s.linux;const i={env:await this._envVariablesPromise,userHome:await this._userHomePromise};return this.recursiveResolve(i,n?n.uri:void 0,s,t,o)}async resolveAnyAsync(n,e,t){return this.resolveAnyBase(n,e,t)}async resolveAnyMap(n,e,t){const o=new Map;return{newConfig:await this.resolveAnyBase(n,e,t,o),resolvedVariables:o}}resolveWithInteractionReplace(n,e,t,o){throw new Error("resolveWithInteractionReplace not implemented.")}resolveWithInteraction(n,e,t,o){throw new Error("resolveWithInteraction not implemented.")}contributeVariable(n,e){if(this._contributedVariables.has(n))throw new Error("Variable "+n+" is contributed twice.");this._contributedVariables.set(n,e)}async recursiveResolve(n,e,t,o,s){if(m.isString(t))return this.resolveString(n,e,t,o,s);if(Array.isArray(t))return Promise.all(t.map(i=>this.recursiveResolve(n,e,i,o,s)));if(m.isObject(t)){const i=Object.create(null),c=await Promise.all(Object.keys(t).map(async l=>[await this.resolveString(n,e,l,o,s),await this.recursiveResolve(n,e,t[l],o,s)]));for(const[l,v]of c)i[l]=v;return i}return t}resolveString(n,e,t,o,s){return E(t,b.VARIABLE_REGEXP,async(i,c)=>{if(c.includes(b.VARIABLE_LHS))return i;let l=await this.evaluateSingleVariable(n,i,c,e,o);return s?.set(c,l),l!==i&&m.isString(l)&&l.match(b.VARIABLE_REGEXP)&&(l=await this.resolveString(n,e,l,o,s)),l})}fsPath(n){return this._labelService?this._labelService.getUriLabel(n,{noPrefix:!0}):n.fsPath}async evaluateSingleVariable(n,e,t,o,s){let i;const c=t.split(":");c.length>1&&(t=c[0],i=c[1]);const l=r=>{const g=this._context.getFilePath();if(g)return h(g);throw new u(r,d("canNotResolveFile","Variable {0} can not be resolved. Please open an editor.",e))},v=r=>{const g=l(r);if(this._context.getWorkspaceFolderPathForFile){const F=this._context.getWorkspaceFolderPathForFile();if(F)return h(F)}throw new u(r,d("canNotResolveFolderForFile","Variable {0}: can not find workspace folder of '{1}'.",e,f.basename(g)))},p=r=>{if(i){const g=this._context.getFolderUri(i);if(g)return g;throw new u(r,d("canNotFindFolder","Variable {0} can not be resolved. No such folder '{1}'.",e,i))}if(o)return o;throw this._context.getWorkspaceFolderCount()>1?new u(r,d("canNotResolveWorkspaceFolderMultiRoot","Variable {0} can not be resolved in a multi folder workspace. Scope this variable using ':' and a workspace folder name.",e)):new u(r,d("canNotResolveWorkspaceFolder","Variable {0} can not be resolved. Please open a folder.",e))};switch(t){case"env":if(i){if(n.env){const r=n.env[w?i.toLowerCase():i];if(m.isString(r))return r}return""}throw new u(a.Env,d("missingEnvVarName","Variable {0} can not be resolved because no environment variable name is given.",e));case"config":if(i){const r=this._context.getConfigurationValue(o,i);if(m.isUndefinedOrNull(r))throw new u(a.Config,d("configNotFound","Variable {0} can not be resolved because setting '{1}' not found.",e,i));if(m.isObject(r))throw new u(a.Config,d("configNoString","Variable {0} can not be resolved because '{1}' is a structured value.",e,i));return r}throw new u(a.Config,d("missingConfigName","Variable {0} can not be resolved because no settings name is given.",e));case"command":return this.resolveFromMap(a.Command,e,i,s,"command");case"input":return this.resolveFromMap(a.Input,e,i,s,"input");case"extensionInstallFolder":if(i){const r=await this._context.getExtension(i);if(!r)throw new u(a.ExtensionInstallFolder,d("extensionNotInstalled","Variable {0} can not be resolved because the extension {1} is not installed.",e,i));return this.fsPath(r.extensionLocation)}throw new u(a.ExtensionInstallFolder,d("missingExtensionName","Variable {0} can not be resolved because no extension name is given.",e));default:switch(t){case"workspaceRoot":case"workspaceFolder":return h(this.fsPath(p(a.WorkspaceFolder)));case"cwd":return o||i?h(this.fsPath(p(a.Cwd))):P.cwd();case"workspaceRootFolderName":case"workspaceFolderBasename":return h(f.basename(this.fsPath(p(a.WorkspaceFolderBasename))));case"userHome":{if(n.userHome)return n.userHome;throw new u(a.UserHome,d("canNotResolveUserHome","Variable {0} can not be resolved. UserHome path is not defined",e))}case"lineNumber":{const r=this._context.getLineNumber();if(r)return r;throw new u(a.LineNumber,d("canNotResolveLineNumber","Variable {0} can not be resolved. Make sure to have a line selected in the active editor.",e))}case"selectedText":{const r=this._context.getSelectedText();if(r)return r;throw new u(a.SelectedText,d("canNotResolveSelectedText","Variable {0} can not be resolved. Make sure to have some text selected in the active editor.",e))}case"file":return l(a.File);case"fileWorkspaceFolder":return v(a.FileWorkspaceFolder);case"fileWorkspaceFolderBasename":return f.basename(v(a.FileWorkspaceFolderBasename));case"relativeFile":return o||i?f.relative(this.fsPath(p(a.RelativeFile)),l(a.RelativeFile)):l(a.RelativeFile);case"relativeFileDirname":{const r=f.dirname(l(a.RelativeFileDirname));if(o||i){const g=f.relative(this.fsPath(p(a.RelativeFileDirname)),r);return g.length===0?".":g}return r}case"fileDirname":return f.dirname(l(a.FileDirname));case"fileExtname":return f.extname(l(a.FileExtname));case"fileBasename":return f.basename(l(a.FileBasename));case"fileBasenameNoExtension":{const r=f.basename(l(a.FileBasenameNoExtension));return r.slice(0,r.length-f.extname(r).length)}case"fileDirnameBasename":return f.basename(f.dirname(l(a.FileDirnameBasename)));case"execPath":{const r=this._context.getExecPath();return r||e}case"execInstallFolder":{const r=this._context.getAppRoot();return r||e}case"pathSeparator":case"/":return f.sep;default:try{const r=i?`${t}:${i}`:t;return this.resolveFromMap(a.Unknown,e,r,s,void 0)}catch{return e}}}}resolveFromMap(n,e,t,o,s){if(t&&o){const i=s===void 0?o[t]:o[s+":"+t];if(typeof i=="string")return i;throw new u(n,d("noValueForCommand","Variable {0} can not be resolved because the command has no value.",e))}return e}}export{b as AbstractVariableResolverService};
