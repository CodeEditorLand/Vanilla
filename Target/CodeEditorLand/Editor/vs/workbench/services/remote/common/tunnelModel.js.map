{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/remote/common/tunnelModel.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as nls from '../../../../nls.js';\nimport { debounce } from '../../../../base/common/decorators.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { hash } from '../../../../base/common/hash.js';\nimport { Disposable, DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { ConfigurationTarget, IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { IDialogService } from '../../../../platform/dialogs/common/dialogs.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { IAddressProvider } from '../../../../platform/remote/common/remoteAgentConnection.js';\nimport { IRemoteAuthorityResolverService, TunnelDescription } from '../../../../platform/remote/common/remoteAuthorityResolver.js';\nimport { IStorageService, StorageScope, StorageTarget } from '../../../../platform/storage/common/storage.js';\nimport { RemoteTunnel, ITunnelService, TunnelProtocol, TunnelPrivacyId, LOCALHOST_ADDRESSES, ProvidedPortAttributes, PortAttributesProvider, isLocalhost, isAllInterfaces, ProvidedOnAutoForward, ALL_INTERFACES_ADDRESSES } from '../../../../platform/tunnel/common/tunnel.js';\nimport { IWorkspaceContextService } from '../../../../platform/workspace/common/workspace.js';\nimport { IWorkbenchEnvironmentService } from '../../environment/common/environmentService.js';\nimport { IExtensionService } from '../../extensions/common/extensions.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { isNumber, isObject, isString } from '../../../../base/common/types.js';\nimport { deepClone } from '../../../../base/common/objects.js';\nimport { IContextKeyService, RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\n\nconst MISMATCH_LOCAL_PORT_COOLDOWN = 10 * 1000; // 10 seconds\nconst TUNNELS_TO_RESTORE = 'remote.tunnels.toRestore';\nconst TUNNELS_TO_RESTORE_EXPIRATION = 'remote.tunnels.toRestoreExpiration';\nconst RESTORE_EXPIRATION_TIME = 1000 * 60 * 60 * 24 * 14; // 2 weeks\nexport const ACTIVATION_EVENT = 'onTunnel';\nexport const forwardedPortsViewEnabled = new RawContextKey<boolean>('forwardedPortsViewEnabled', false, nls.localize('tunnel.forwardedPortsViewEnabled', \"Whether the Ports view is enabled.\"));\n\nexport interface RestorableTunnel {\n\tremoteHost: string;\n\tremotePort: number;\n\tlocalAddress: string;\n\tlocalUri: URI;\n\tprotocol: TunnelProtocol;\n\tlocalPort?: number;\n\tname?: string;\n\tsource: {\n\t\tsource: TunnelSource;\n\t\tdescription: string;\n\t};\n}\n\nexport interface Tunnel {\n\tremoteHost: string;\n\tremotePort: number;\n\tlocalAddress: string;\n\tlocalUri: URI;\n\tprotocol: TunnelProtocol;\n\tlocalPort?: number;\n\tname?: string;\n\tcloseable?: boolean;\n\tprivacy: TunnelPrivacyId | string;\n\trunningProcess: string | undefined;\n\thasRunningProcess?: boolean;\n\tpid: number | undefined;\n\tsource: {\n\t\tsource: TunnelSource;\n\t\tdescription: string;\n\t};\n}\n\nexport function parseAddress(address: string): { host: string; port: number } | undefined {\n\tconst matches = address.match(/^([a-zA-Z0-9_-]+(?:\\.[a-zA-Z0-9_-]+)*:)?([0-9]+)$/);\n\tif (!matches) {\n\t\treturn undefined;\n\t}\n\treturn { host: matches[1]?.substring(0, matches[1].length - 1) || 'localhost', port: Number(matches[2]) };\n}\n\nexport enum TunnelCloseReason {\n\tOther = 'Other',\n\tUser = 'User',\n\tAutoForwardEnd = 'AutoForwardEnd',\n}\n\nexport enum TunnelSource {\n\tUser,\n\tAuto,\n\tExtension\n}\n\nexport const UserTunnelSource = {\n\tsource: TunnelSource.User,\n\tdescription: nls.localize('tunnel.source.user', \"User Forwarded\")\n};\nexport const AutoTunnelSource = {\n\tsource: TunnelSource.Auto,\n\tdescription: nls.localize('tunnel.source.auto', \"Auto Forwarded\")\n};\n\nexport function mapHasAddress<T>(map: Map<string, T>, host: string, port: number): T | undefined {\n\tconst initialAddress = map.get(makeAddress(host, port));\n\tif (initialAddress) {\n\t\treturn initialAddress;\n\t}\n\n\tif (isLocalhost(host)) {\n\t\t// Do localhost checks\n\t\tfor (const testHost of LOCALHOST_ADDRESSES) {\n\t\t\tconst testAddress = makeAddress(testHost, port);\n\t\t\tif (map.has(testAddress)) {\n\t\t\t\treturn map.get(testAddress);\n\t\t\t}\n\t\t}\n\t} else if (isAllInterfaces(host)) {\n\t\t// Do all interfaces checks\n\t\tfor (const testHost of ALL_INTERFACES_ADDRESSES) {\n\t\t\tconst testAddress = makeAddress(testHost, port);\n\t\t\tif (map.has(testAddress)) {\n\t\t\t\treturn map.get(testAddress);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn undefined;\n}\n\nexport function mapHasAddressLocalhostOrAllInterfaces<T>(map: Map<string, T>, host: string, port: number): T | undefined {\n\tconst originalAddress = mapHasAddress(map, host, port);\n\tif (originalAddress) {\n\t\treturn originalAddress;\n\t}\n\tconst otherHost = isAllInterfaces(host) ? 'localhost' : (isLocalhost(host) ? '0.0.0.0' : undefined);\n\tif (otherHost) {\n\t\treturn mapHasAddress(map, otherHost, port);\n\t}\n\treturn undefined;\n}\n\n\nexport function makeAddress(host: string, port: number): string {\n\treturn host + ':' + port;\n}\n\nexport interface TunnelProperties {\n\tremote: { host: string; port: number };\n\tlocal?: number;\n\tname?: string;\n\tsource?: {\n\t\tsource: TunnelSource;\n\t\tdescription: string;\n\t};\n\televateIfNeeded?: boolean;\n\tprivacy?: string;\n}\n\nexport interface CandidatePort {\n\thost: string;\n\tport: number;\n\tdetail?: string;\n\tpid?: number;\n}\n\ninterface PortAttributes extends Attributes {\n\tkey: number | PortRange | RegExp | HostAndPort;\n}\n\nexport enum OnPortForward {\n\tNotify = 'notify',\n\tOpenBrowser = 'openBrowser',\n\tOpenBrowserOnce = 'openBrowserOnce',\n\tOpenPreview = 'openPreview',\n\tSilent = 'silent',\n\tIgnore = 'ignore'\n}\n\nexport interface Attributes {\n\tlabel: string | undefined;\n\tonAutoForward: OnPortForward | undefined;\n\televateIfNeeded: boolean | undefined;\n\trequireLocalPort: boolean | undefined;\n\tprotocol: TunnelProtocol | undefined;\n}\n\ninterface PortRange { start: number; end: number }\n\ninterface HostAndPort { host: string; port: number }\n\nexport function isCandidatePort(candidate: any): candidate is CandidatePort {\n\treturn candidate && 'host' in candidate && typeof candidate.host === 'string'\n\t\t&& 'port' in candidate && typeof candidate.port === 'number'\n\t\t&& (!('detail' in candidate) || typeof candidate.detail === 'string')\n\t\t&& (!('pid' in candidate) || typeof candidate.pid === 'string');\n}\n\nexport class PortsAttributes extends Disposable {\n\tprivate static SETTING = 'remote.portsAttributes';\n\tprivate static DEFAULTS = 'remote.otherPortsAttributes';\n\tprivate static RANGE = /^(\\d+)\\-(\\d+)$/;\n\tprivate static HOST_AND_PORT = /^([a-z0-9\\-]+):(\\d{1,5})$/;\n\tprivate portsAttributes: PortAttributes[] = [];\n\tprivate defaultPortAttributes: Attributes | undefined;\n\tprivate _onDidChangeAttributes = new Emitter<void>();\n\tpublic readonly onDidChangeAttributes = this._onDidChangeAttributes.event;\n\n\tconstructor(private readonly configurationService: IConfigurationService) {\n\t\tsuper();\n\t\tthis._register(configurationService.onDidChangeConfiguration(e => {\n\t\t\tif (e.affectsConfiguration(PortsAttributes.SETTING) || e.affectsConfiguration(PortsAttributes.DEFAULTS)) {\n\t\t\t\tthis.updateAttributes();\n\t\t\t}\n\t\t}));\n\t\tthis.updateAttributes();\n\t}\n\n\tprivate updateAttributes() {\n\t\tthis.portsAttributes = this.readSetting();\n\t\tthis._onDidChangeAttributes.fire();\n\t}\n\n\tgetAttributes(port: number, host: string, commandLine?: string): Attributes | undefined {\n\t\tlet index = this.findNextIndex(port, host, commandLine, this.portsAttributes, 0);\n\t\tconst attributes: Attributes = {\n\t\t\tlabel: undefined,\n\t\t\tonAutoForward: undefined,\n\t\t\televateIfNeeded: undefined,\n\t\t\trequireLocalPort: undefined,\n\t\t\tprotocol: undefined\n\t\t};\n\t\twhile (index >= 0) {\n\t\t\tconst found = this.portsAttributes[index];\n\t\t\tif (found.key === port) {\n\t\t\t\tattributes.onAutoForward = found.onAutoForward ?? attributes.onAutoForward;\n\t\t\t\tattributes.elevateIfNeeded = (found.elevateIfNeeded !== undefined) ? found.elevateIfNeeded : attributes.elevateIfNeeded;\n\t\t\t\tattributes.label = found.label ?? attributes.label;\n\t\t\t\tattributes.requireLocalPort = found.requireLocalPort;\n\t\t\t\tattributes.protocol = found.protocol;\n\t\t\t} else {\n\t\t\t\t// It's a range or regex, which means that if the attribute is already set, we keep it\n\t\t\t\tattributes.onAutoForward = attributes.onAutoForward ?? found.onAutoForward;\n\t\t\t\tattributes.elevateIfNeeded = (attributes.elevateIfNeeded !== undefined) ? attributes.elevateIfNeeded : found.elevateIfNeeded;\n\t\t\t\tattributes.label = attributes.label ?? found.label;\n\t\t\t\tattributes.requireLocalPort = (attributes.requireLocalPort !== undefined) ? attributes.requireLocalPort : undefined;\n\t\t\t\tattributes.protocol = attributes.protocol ?? found.protocol;\n\t\t\t}\n\t\t\tindex = this.findNextIndex(port, host, commandLine, this.portsAttributes, index + 1);\n\t\t}\n\t\tif (attributes.onAutoForward !== undefined || attributes.elevateIfNeeded !== undefined\n\t\t\t|| attributes.label !== undefined || attributes.requireLocalPort !== undefined\n\t\t\t|| attributes.protocol !== undefined) {\n\t\t\treturn attributes;\n\t\t}\n\n\t\t// If we find no matches, then use the other port attributes.\n\t\treturn this.getOtherAttributes();\n\t}\n\n\tprivate hasStartEnd(value: number | PortRange | RegExp | HostAndPort): value is PortRange {\n\t\treturn ((<any>value).start !== undefined) && ((<any>value).end !== undefined);\n\t}\n\n\tprivate hasHostAndPort(value: number | PortRange | RegExp | HostAndPort): value is HostAndPort {\n\t\treturn ((<any>value).host !== undefined) && ((<any>value).port !== undefined)\n\t\t\t&& isString((<any>value).host) && isNumber((<any>value).port);\n\t}\n\n\tprivate findNextIndex(port: number, host: string, commandLine: string | undefined, attributes: PortAttributes[], fromIndex: number): number {\n\t\tif (fromIndex >= attributes.length) {\n\t\t\treturn -1;\n\t\t}\n\t\tconst shouldUseHost = !isLocalhost(host) && !isAllInterfaces(host);\n\t\tconst sliced = attributes.slice(fromIndex);\n\t\tconst foundIndex = sliced.findIndex((value) => {\n\t\t\tif (isNumber(value.key)) {\n\t\t\t\treturn shouldUseHost ? false : value.key === port;\n\t\t\t} else if (this.hasStartEnd(value.key)) {\n\t\t\t\treturn shouldUseHost ? false : (port >= value.key.start && port <= value.key.end);\n\t\t\t} else if (this.hasHostAndPort(value.key)) {\n\t\t\t\treturn (port === value.key.port) && (host === value.key.host);\n\t\t\t} else {\n\t\t\t\treturn commandLine ? value.key.test(commandLine) : false;\n\t\t\t}\n\n\t\t});\n\t\treturn foundIndex >= 0 ? foundIndex + fromIndex : -1;\n\t}\n\n\tprivate readSetting(): PortAttributes[] {\n\t\tconst settingValue = this.configurationService.getValue(PortsAttributes.SETTING);\n\t\tif (!settingValue || !isObject(settingValue)) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst attributes: PortAttributes[] = [];\n\t\tfor (const attributesKey in settingValue) {\n\t\t\tif (attributesKey === undefined) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst setting = (<any>settingValue)[attributesKey];\n\t\t\tlet key: number | PortRange | RegExp | HostAndPort | undefined = undefined;\n\t\t\tif (Number(attributesKey)) {\n\t\t\t\tkey = Number(attributesKey);\n\t\t\t} else if (isString(attributesKey)) {\n\t\t\t\tif (PortsAttributes.RANGE.test(attributesKey)) {\n\t\t\t\t\tconst match = attributesKey.match(PortsAttributes.RANGE);\n\t\t\t\t\tkey = { start: Number(match![1]), end: Number(match![2]) };\n\t\t\t\t} else if (PortsAttributes.HOST_AND_PORT.test(attributesKey)) {\n\t\t\t\t\tconst match = attributesKey.match(PortsAttributes.HOST_AND_PORT);\n\t\t\t\t\tkey = { host: match![1], port: Number(match![2]) };\n\t\t\t\t} else {\n\t\t\t\t\tlet regTest: RegExp | undefined = undefined;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tregTest = RegExp(attributesKey);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t// The user entered an invalid regular expression.\n\t\t\t\t\t}\n\t\t\t\t\tif (regTest) {\n\t\t\t\t\t\tkey = regTest;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!key) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tattributes.push({\n\t\t\t\tkey: key,\n\t\t\t\televateIfNeeded: setting.elevateIfNeeded,\n\t\t\t\tonAutoForward: setting.onAutoForward,\n\t\t\t\tlabel: setting.label,\n\t\t\t\trequireLocalPort: setting.requireLocalPort,\n\t\t\t\tprotocol: setting.protocol\n\t\t\t});\n\t\t}\n\n\t\tconst defaults = <any>this.configurationService.getValue(PortsAttributes.DEFAULTS);\n\t\tif (defaults) {\n\t\t\tthis.defaultPortAttributes = {\n\t\t\t\televateIfNeeded: defaults.elevateIfNeeded,\n\t\t\t\tlabel: defaults.label,\n\t\t\t\tonAutoForward: defaults.onAutoForward,\n\t\t\t\trequireLocalPort: defaults.requireLocalPort,\n\t\t\t\tprotocol: defaults.protocol\n\t\t\t};\n\t\t}\n\n\t\treturn this.sortAttributes(attributes);\n\t}\n\n\tprivate sortAttributes(attributes: PortAttributes[]): PortAttributes[] {\n\t\tfunction getVal(item: PortAttributes, thisRef: PortsAttributes) {\n\t\t\tif (isNumber(item.key)) {\n\t\t\t\treturn item.key;\n\t\t\t} else if (thisRef.hasStartEnd(item.key)) {\n\t\t\t\treturn item.key.start;\n\t\t\t} else if (thisRef.hasHostAndPort(item.key)) {\n\t\t\t\treturn item.key.port;\n\t\t\t} else {\n\t\t\t\treturn Number.MAX_VALUE;\n\t\t\t}\n\t\t}\n\n\t\treturn attributes.sort((a, b) => {\n\t\t\treturn getVal(a, this) - getVal(b, this);\n\t\t});\n\t}\n\n\tprivate getOtherAttributes() {\n\t\treturn this.defaultPortAttributes;\n\t}\n\n\tstatic providedActionToAction(providedAction: ProvidedOnAutoForward | undefined) {\n\t\tswitch (providedAction) {\n\t\t\tcase ProvidedOnAutoForward.Notify: return OnPortForward.Notify;\n\t\t\tcase ProvidedOnAutoForward.OpenBrowser: return OnPortForward.OpenBrowser;\n\t\t\tcase ProvidedOnAutoForward.OpenBrowserOnce: return OnPortForward.OpenBrowserOnce;\n\t\t\tcase ProvidedOnAutoForward.OpenPreview: return OnPortForward.OpenPreview;\n\t\t\tcase ProvidedOnAutoForward.Silent: return OnPortForward.Silent;\n\t\t\tcase ProvidedOnAutoForward.Ignore: return OnPortForward.Ignore;\n\t\t\tdefault: return undefined;\n\t\t}\n\t}\n\n\tpublic async addAttributes(port: number, attributes: Partial<Attributes>, target: ConfigurationTarget) {\n\t\tconst settingValue = this.configurationService.inspect(PortsAttributes.SETTING);\n\t\tconst remoteValue: any = settingValue.userRemoteValue;\n\t\tlet newRemoteValue: any;\n\t\tif (!remoteValue || !isObject(remoteValue)) {\n\t\t\tnewRemoteValue = {};\n\t\t} else {\n\t\t\tnewRemoteValue = deepClone(remoteValue);\n\t\t}\n\n\t\tif (!newRemoteValue[`${port}`]) {\n\t\t\tnewRemoteValue[`${port}`] = {};\n\t\t}\n\t\tfor (const attribute in attributes) {\n\t\t\tnewRemoteValue[`${port}`][attribute] = (<any>attributes)[attribute];\n\t\t}\n\n\t\treturn this.configurationService.updateValue(PortsAttributes.SETTING, newRemoteValue, target);\n\t}\n}\n\nexport class TunnelModel extends Disposable {\n\treadonly forwarded: Map<string, Tunnel>;\n\tprivate readonly inProgress: Map<string, true> = new Map();\n\treadonly detected: Map<string, Tunnel>;\n\tprivate remoteTunnels: Map<string, RemoteTunnel>;\n\tprivate _onForwardPort: Emitter<Tunnel | void> = new Emitter();\n\tpublic onForwardPort: Event<Tunnel | void> = this._onForwardPort.event;\n\tprivate _onClosePort: Emitter<{ host: string; port: number }> = new Emitter();\n\tpublic onClosePort: Event<{ host: string; port: number }> = this._onClosePort.event;\n\tprivate _onPortName: Emitter<{ host: string; port: number }> = new Emitter();\n\tpublic onPortName: Event<{ host: string; port: number }> = this._onPortName.event;\n\tprivate _candidates: Map<string, CandidatePort> | undefined;\n\tprivate _onCandidatesChanged: Emitter<Map<string, { host: string; port: number }>> = new Emitter();\n\t// onCandidateChanged returns the removed candidates\n\tpublic onCandidatesChanged: Event<Map<string, { host: string; port: number }>> = this._onCandidatesChanged.event;\n\tprivate _candidateFilter: ((candidates: CandidatePort[]) => Promise<CandidatePort[]>) | undefined;\n\tprivate tunnelRestoreValue: Promise<string | undefined>;\n\tprivate _onEnvironmentTunnelsSet: Emitter<void> = new Emitter();\n\tpublic onEnvironmentTunnelsSet: Event<void> = this._onEnvironmentTunnelsSet.event;\n\tprivate _environmentTunnelsSet: boolean = false;\n\tpublic readonly configPortsAttributes: PortsAttributes;\n\tprivate restoreListener: DisposableStore | undefined = undefined;\n\tprivate knownPortsRestoreValue: string | undefined;\n\tprivate restoreComplete = false;\n\tprivate onRestoreComplete: Emitter<void> = new Emitter();\n\tprivate unrestoredExtensionTunnels: Map<string, RestorableTunnel> = new Map();\n\tprivate sessionCachedProperties: Map<string, Partial<TunnelProperties>> = new Map();\n\n\tprivate portAttributesProviders: PortAttributesProvider[] = [];\n\n\tconstructor(\n\t\t@ITunnelService private readonly tunnelService: ITunnelService,\n\t\t@IStorageService private readonly storageService: IStorageService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t\t@IWorkbenchEnvironmentService private readonly environmentService: IWorkbenchEnvironmentService,\n\t\t@IRemoteAuthorityResolverService private readonly remoteAuthorityResolverService: IRemoteAuthorityResolverService,\n\t\t@IWorkspaceContextService private readonly workspaceContextService: IWorkspaceContextService,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IDialogService private readonly dialogService: IDialogService,\n\t\t@IExtensionService private readonly extensionService: IExtensionService,\n\t\t@IContextKeyService private readonly contextKeyService: IContextKeyService\n\t) {\n\t\tsuper();\n\t\tthis.configPortsAttributes = new PortsAttributes(configurationService);\n\t\tthis.tunnelRestoreValue = this.getTunnelRestoreValue();\n\t\tthis._register(this.configPortsAttributes.onDidChangeAttributes(this.updateAttributes, this));\n\t\tthis.forwarded = new Map();\n\t\tthis.remoteTunnels = new Map();\n\t\tthis.tunnelService.tunnels.then(async (tunnels) => {\n\t\t\tconst attributes = await this.getAttributes(tunnels.map(tunnel => {\n\t\t\t\treturn { port: tunnel.tunnelRemotePort, host: tunnel.tunnelRemoteHost };\n\t\t\t}));\n\t\t\tfor (const tunnel of tunnels) {\n\t\t\t\tif (tunnel.localAddress) {\n\t\t\t\t\tconst key = makeAddress(tunnel.tunnelRemoteHost, tunnel.tunnelRemotePort);\n\t\t\t\t\tconst matchingCandidate = mapHasAddressLocalhostOrAllInterfaces(this._candidates ?? new Map(), tunnel.tunnelRemoteHost, tunnel.tunnelRemotePort);\n\t\t\t\t\tthis.forwarded.set(key, {\n\t\t\t\t\t\tremotePort: tunnel.tunnelRemotePort,\n\t\t\t\t\t\tremoteHost: tunnel.tunnelRemoteHost,\n\t\t\t\t\t\tlocalAddress: tunnel.localAddress,\n\t\t\t\t\t\tprotocol: attributes?.get(tunnel.tunnelRemotePort)?.protocol ?? TunnelProtocol.Http,\n\t\t\t\t\t\tlocalUri: await this.makeLocalUri(tunnel.localAddress, attributes?.get(tunnel.tunnelRemotePort)),\n\t\t\t\t\t\tlocalPort: tunnel.tunnelLocalPort,\n\t\t\t\t\t\tname: attributes?.get(tunnel.tunnelRemotePort)?.label,\n\t\t\t\t\t\trunningProcess: matchingCandidate?.detail,\n\t\t\t\t\t\thasRunningProcess: !!matchingCandidate,\n\t\t\t\t\t\tpid: matchingCandidate?.pid,\n\t\t\t\t\t\tprivacy: tunnel.privacy,\n\t\t\t\t\t\tsource: UserTunnelSource,\n\t\t\t\t\t});\n\t\t\t\t\tthis.remoteTunnels.set(key, tunnel);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tthis.detected = new Map();\n\t\tthis._register(this.tunnelService.onTunnelOpened(async (tunnel) => {\n\t\t\tconst key = makeAddress(tunnel.tunnelRemoteHost, tunnel.tunnelRemotePort);\n\t\t\tif (!mapHasAddressLocalhostOrAllInterfaces(this.forwarded, tunnel.tunnelRemoteHost, tunnel.tunnelRemotePort)\n\t\t\t\t&& !mapHasAddressLocalhostOrAllInterfaces(this.detected, tunnel.tunnelRemoteHost, tunnel.tunnelRemotePort)\n\t\t\t\t&& !mapHasAddressLocalhostOrAllInterfaces(this.inProgress, tunnel.tunnelRemoteHost, tunnel.tunnelRemotePort)\n\t\t\t\t&& tunnel.localAddress) {\n\t\t\t\tconst matchingCandidate = mapHasAddressLocalhostOrAllInterfaces(this._candidates ?? new Map(), tunnel.tunnelRemoteHost, tunnel.tunnelRemotePort);\n\t\t\t\tconst attributes = (await this.getAttributes([{ port: tunnel.tunnelRemotePort, host: tunnel.tunnelRemoteHost }]))?.get(tunnel.tunnelRemotePort);\n\t\t\t\tthis.forwarded.set(key, {\n\t\t\t\t\tremoteHost: tunnel.tunnelRemoteHost,\n\t\t\t\t\tremotePort: tunnel.tunnelRemotePort,\n\t\t\t\t\tlocalAddress: tunnel.localAddress,\n\t\t\t\t\tprotocol: attributes?.protocol ?? TunnelProtocol.Http,\n\t\t\t\t\tlocalUri: await this.makeLocalUri(tunnel.localAddress, attributes),\n\t\t\t\t\tlocalPort: tunnel.tunnelLocalPort,\n\t\t\t\t\tname: attributes?.label,\n\t\t\t\t\tcloseable: true,\n\t\t\t\t\trunningProcess: matchingCandidate?.detail,\n\t\t\t\t\thasRunningProcess: !!matchingCandidate,\n\t\t\t\t\tpid: matchingCandidate?.pid,\n\t\t\t\t\tprivacy: tunnel.privacy,\n\t\t\t\t\tsource: UserTunnelSource,\n\t\t\t\t});\n\t\t\t}\n\t\t\tawait this.storeForwarded();\n\t\t\tthis.checkExtensionActivationEvents();\n\t\t\tthis.remoteTunnels.set(key, tunnel);\n\t\t\tthis._onForwardPort.fire(this.forwarded.get(key)!);\n\t\t}));\n\t\tthis._register(this.tunnelService.onTunnelClosed(address => {\n\t\t\treturn this.onTunnelClosed(address, TunnelCloseReason.Other);\n\t\t}));\n\t}\n\n\tprivate extensionHasActivationEvent() {\n\t\tif (this.extensionService.extensions.find(extension => extension.activationEvents?.includes(ACTIVATION_EVENT))) {\n\t\t\tthis.contextKeyService.createKey(forwardedPortsViewEnabled.key, true);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate checkExtensionActivationEvents() {\n\t\tif (this.extensionHasActivationEvent()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst activationDisposable = this._register(this.extensionService.onDidRegisterExtensions(() => {\n\t\t\tif (this.extensionHasActivationEvent()) {\n\t\t\t\tactivationDisposable.dispose();\n\t\t\t}\n\t\t}));\n\t}\n\n\tprivate async onTunnelClosed(address: { host: string; port: number }, reason: TunnelCloseReason) {\n\t\tconst key = makeAddress(address.host, address.port);\n\t\tif (this.forwarded.has(key)) {\n\t\t\tthis.forwarded.delete(key);\n\t\t\tawait this.storeForwarded();\n\t\t\tthis._onClosePort.fire(address);\n\t\t}\n\t}\n\n\tprivate makeLocalUri(localAddress: string, attributes?: Attributes) {\n\t\tif (localAddress.startsWith('http')) {\n\t\t\treturn URI.parse(localAddress);\n\t\t}\n\t\tconst protocol = attributes?.protocol ?? 'http';\n\t\treturn URI.parse(`${protocol}://${localAddress}`);\n\t}\n\n\tprivate async addStorageKeyPostfix(prefix: string): Promise<string | undefined> {\n\t\tconst workspace = this.workspaceContextService.getWorkspace();\n\t\tconst workspaceHash = workspace.configuration ? hash(workspace.configuration.path) : (workspace.folders.length > 0 ? hash(workspace.folders[0].uri.path) : undefined);\n\t\tif (workspaceHash === undefined) {\n\t\t\tthis.logService.debug('Could not get workspace hash for forwarded ports storage key.');\n\t\t\treturn undefined;\n\t\t}\n\t\treturn `${prefix}.${this.environmentService.remoteAuthority}.${workspaceHash}`;\n\t}\n\n\tprivate async getTunnelRestoreStorageKey(): Promise<string | undefined> {\n\t\treturn this.addStorageKeyPostfix(TUNNELS_TO_RESTORE);\n\t}\n\n\tprivate async getRestoreExpirationStorageKey(): Promise<string | undefined> {\n\t\treturn this.addStorageKeyPostfix(TUNNELS_TO_RESTORE_EXPIRATION);\n\t}\n\n\tprivate async getTunnelRestoreValue(): Promise<string | undefined> {\n\t\tconst deprecatedValue = this.storageService.get(TUNNELS_TO_RESTORE, StorageScope.WORKSPACE);\n\t\tif (deprecatedValue) {\n\t\t\tthis.storageService.remove(TUNNELS_TO_RESTORE, StorageScope.WORKSPACE);\n\t\t\tawait this.storeForwarded();\n\t\t\treturn deprecatedValue;\n\t\t}\n\t\tconst storageKey = await this.getTunnelRestoreStorageKey();\n\t\tif (!storageKey) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this.storageService.get(storageKey, StorageScope.PROFILE);\n\t}\n\n\tasync restoreForwarded() {\n\t\tthis.cleanupExpiredTunnelsForRestore();\n\t\tif (this.configurationService.getValue('remote.restoreForwardedPorts')) {\n\t\t\tconst tunnelRestoreValue = await this.tunnelRestoreValue;\n\t\t\tif (tunnelRestoreValue && (tunnelRestoreValue !== this.knownPortsRestoreValue)) {\n\t\t\t\tconst tunnels = <RestorableTunnel[] | undefined>JSON.parse(tunnelRestoreValue) ?? [];\n\t\t\t\tthis.logService.trace(`ForwardedPorts: (TunnelModel) restoring ports ${tunnels.map(tunnel => tunnel.remotePort).join(', ')}`);\n\t\t\t\tfor (const tunnel of tunnels) {\n\t\t\t\t\tconst alreadyForwarded = mapHasAddressLocalhostOrAllInterfaces(this.detected, tunnel.remoteHost, tunnel.remotePort);\n\t\t\t\t\t// Extension forwarded ports should only be updated, not restored.\n\t\t\t\t\tif ((tunnel.source.source !== TunnelSource.Extension && !alreadyForwarded) || (tunnel.source.source === TunnelSource.Extension && alreadyForwarded)) {\n\t\t\t\t\t\tawait this.doForward({\n\t\t\t\t\t\t\tremote: { host: tunnel.remoteHost, port: tunnel.remotePort },\n\t\t\t\t\t\t\tlocal: tunnel.localPort,\n\t\t\t\t\t\t\tname: tunnel.name,\n\t\t\t\t\t\t\televateIfNeeded: true,\n\t\t\t\t\t\t\tsource: tunnel.source\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (tunnel.source.source === TunnelSource.Extension && !alreadyForwarded) {\n\t\t\t\t\t\tthis.unrestoredExtensionTunnels.set(makeAddress(tunnel.remoteHost, tunnel.remotePort), tunnel);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.restoreComplete = true;\n\t\tthis.onRestoreComplete.fire();\n\n\t\tif (!this.restoreListener) {\n\t\t\t// It's possible that at restore time the value hasn't synced.\n\t\t\tconst key = await this.getTunnelRestoreStorageKey();\n\t\t\tthis.restoreListener = this._register(new DisposableStore());\n\t\t\tthis.restoreListener.add(this.storageService.onDidChangeValue(StorageScope.PROFILE, undefined, this.restoreListener)(async (e) => {\n\t\t\t\tif (e.key === key) {\n\t\t\t\t\tthis.tunnelRestoreValue = Promise.resolve(this.storageService.get(key, StorageScope.PROFILE));\n\t\t\t\t\tawait this.restoreForwarded();\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\t}\n\n\tprivate cleanupExpiredTunnelsForRestore() {\n\t\tconst keys = this.storageService.keys(StorageScope.PROFILE, StorageTarget.USER).filter(key => key.startsWith(TUNNELS_TO_RESTORE_EXPIRATION));\n\t\tfor (const key of keys) {\n\t\t\tconst expiration = this.storageService.getNumber(key, StorageScope.PROFILE);\n\t\t\tif (expiration && expiration < Date.now()) {\n\t\t\t\tthis.tunnelRestoreValue = Promise.resolve(undefined);\n\t\t\t\tconst storageKey = key.replace(TUNNELS_TO_RESTORE_EXPIRATION, TUNNELS_TO_RESTORE);\n\t\t\t\tthis.storageService.remove(key, StorageScope.PROFILE);\n\t\t\t\tthis.storageService.remove(storageKey, StorageScope.PROFILE);\n\t\t\t}\n\t\t}\n\t}\n\n\t@debounce(1000)\n\tprivate async storeForwarded() {\n\t\tif (this.configurationService.getValue('remote.restoreForwardedPorts')) {\n\t\t\tconst forwarded = Array.from(this.forwarded.values());\n\t\t\tconst restorableTunnels: RestorableTunnel[] = forwarded.map(tunnel => {\n\t\t\t\treturn {\n\t\t\t\t\tremoteHost: tunnel.remoteHost,\n\t\t\t\t\tremotePort: tunnel.remotePort,\n\t\t\t\t\tlocalPort: tunnel.localPort,\n\t\t\t\t\tname: tunnel.name,\n\t\t\t\t\tlocalAddress: tunnel.localAddress,\n\t\t\t\t\tlocalUri: tunnel.localUri,\n\t\t\t\t\tprotocol: tunnel.protocol,\n\t\t\t\t\tsource: tunnel.source,\n\t\t\t\t};\n\t\t\t});\n\t\t\tlet valueToStore: string | undefined;\n\t\t\tif (forwarded.length > 0) {\n\t\t\t\tvalueToStore = JSON.stringify(restorableTunnels);\n\t\t\t}\n\n\t\t\tconst key = await this.getTunnelRestoreStorageKey();\n\t\t\tconst expirationKey = await this.getRestoreExpirationStorageKey();\n\t\t\tif (!valueToStore && key && expirationKey) {\n\t\t\t\tthis.storageService.remove(key, StorageScope.PROFILE);\n\t\t\t\tthis.storageService.remove(expirationKey, StorageScope.PROFILE);\n\t\t\t} else if ((valueToStore !== this.knownPortsRestoreValue) && key && expirationKey) {\n\t\t\t\tthis.storageService.store(key, valueToStore, StorageScope.PROFILE, StorageTarget.USER);\n\t\t\t\tthis.storageService.store(expirationKey, Date.now() + RESTORE_EXPIRATION_TIME, StorageScope.PROFILE, StorageTarget.USER);\n\t\t\t}\n\t\t\tthis.knownPortsRestoreValue = valueToStore;\n\t\t}\n\t}\n\n\tprivate mismatchCooldown = new Date();\n\tprivate async showPortMismatchModalIfNeeded(tunnel: RemoteTunnel, expectedLocal: number, attributes: Attributes | undefined) {\n\t\tif (!tunnel.tunnelLocalPort || !attributes?.requireLocalPort) {\n\t\t\treturn;\n\t\t}\n\t\tif (tunnel.tunnelLocalPort === expectedLocal) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst newCooldown = new Date();\n\t\tif ((this.mismatchCooldown.getTime() + MISMATCH_LOCAL_PORT_COOLDOWN) > newCooldown.getTime()) {\n\t\t\treturn;\n\t\t}\n\t\tthis.mismatchCooldown = newCooldown;\n\t\tconst mismatchString = nls.localize('remote.localPortMismatch.single', \"Local port {0} could not be used for forwarding to remote port {1}.\\n\\nThis usually happens when there is already another process using local port {0}.\\n\\nPort number {2} has been used instead.\",\n\t\t\texpectedLocal, tunnel.tunnelRemotePort, tunnel.tunnelLocalPort);\n\t\treturn this.dialogService.info(mismatchString);\n\t}\n\n\tasync forward(tunnelProperties: TunnelProperties, attributes?: Attributes | null): Promise<RemoteTunnel | string | undefined> {\n\t\tif (!this.restoreComplete && this.environmentService.remoteAuthority) {\n\t\t\tawait Event.toPromise(this.onRestoreComplete.event);\n\t\t}\n\t\treturn this.doForward(tunnelProperties, attributes);\n\t}\n\n\tprivate async doForward(tunnelProperties: TunnelProperties, attributes?: Attributes | null): Promise<RemoteTunnel | string | undefined> {\n\t\tawait this.extensionService.activateByEvent(ACTIVATION_EVENT);\n\n\t\tconst existingTunnel = mapHasAddressLocalhostOrAllInterfaces(this.forwarded, tunnelProperties.remote.host, tunnelProperties.remote.port);\n\t\tattributes = attributes ??\n\t\t\t((attributes !== null)\n\t\t\t\t? (await this.getAttributes([tunnelProperties.remote]))?.get(tunnelProperties.remote.port)\n\t\t\t\t: undefined);\n\t\tconst localPort = (tunnelProperties.local !== undefined) ? tunnelProperties.local : tunnelProperties.remote.port;\n\t\tlet noTunnelValue: string | undefined;\n\t\tif (!existingTunnel) {\n\t\t\tconst authority = this.environmentService.remoteAuthority;\n\t\t\tconst addressProvider: IAddressProvider | undefined = authority ? {\n\t\t\t\tgetAddress: async () => { return (await this.remoteAuthorityResolverService.resolveAuthority(authority)).authority; }\n\t\t\t} : undefined;\n\n\t\t\tconst key = makeAddress(tunnelProperties.remote.host, tunnelProperties.remote.port);\n\t\t\tthis.inProgress.set(key, true);\n\t\t\ttunnelProperties = this.mergeCachedAndUnrestoredProperties(key, tunnelProperties);\n\n\t\t\tconst tunnel = await this.tunnelService.openTunnel(addressProvider, tunnelProperties.remote.host, tunnelProperties.remote.port, undefined, localPort, (!tunnelProperties.elevateIfNeeded) ? attributes?.elevateIfNeeded : tunnelProperties.elevateIfNeeded, tunnelProperties.privacy, attributes?.protocol);\n\t\t\tif (typeof tunnel === 'string') {\n\t\t\t\t// There was an error  while creating the tunnel.\n\t\t\t\tnoTunnelValue = tunnel;\n\t\t\t} else if (tunnel && tunnel.localAddress) {\n\t\t\t\tconst matchingCandidate = mapHasAddressLocalhostOrAllInterfaces<CandidatePort>(this._candidates ?? new Map(), tunnelProperties.remote.host, tunnelProperties.remote.port);\n\t\t\t\tconst protocol = (tunnel.protocol ?\n\t\t\t\t\t((tunnel.protocol === TunnelProtocol.Https) ? TunnelProtocol.Https : TunnelProtocol.Http)\n\t\t\t\t\t: (attributes?.protocol ?? TunnelProtocol.Http));\n\t\t\t\tconst newForward: Tunnel = {\n\t\t\t\t\tremoteHost: tunnel.tunnelRemoteHost,\n\t\t\t\t\tremotePort: tunnel.tunnelRemotePort,\n\t\t\t\t\tlocalPort: tunnel.tunnelLocalPort,\n\t\t\t\t\tname: attributes?.label ?? tunnelProperties.name,\n\t\t\t\t\tcloseable: true,\n\t\t\t\t\tlocalAddress: tunnel.localAddress,\n\t\t\t\t\tprotocol,\n\t\t\t\t\tlocalUri: await this.makeLocalUri(tunnel.localAddress, attributes),\n\t\t\t\t\trunningProcess: matchingCandidate?.detail,\n\t\t\t\t\thasRunningProcess: !!matchingCandidate,\n\t\t\t\t\tpid: matchingCandidate?.pid,\n\t\t\t\t\tsource: tunnelProperties.source ?? UserTunnelSource,\n\t\t\t\t\tprivacy: tunnel.privacy,\n\t\t\t\t};\n\t\t\t\tthis.forwarded.set(key, newForward);\n\t\t\t\tthis.remoteTunnels.set(key, tunnel);\n\t\t\t\tthis.inProgress.delete(key);\n\t\t\t\tawait this.storeForwarded();\n\t\t\t\tawait this.showPortMismatchModalIfNeeded(tunnel, localPort, attributes);\n\t\t\t\tthis._onForwardPort.fire(newForward);\n\t\t\t\treturn tunnel;\n\t\t\t}\n\t\t\tthis.inProgress.delete(key);\n\t\t} else {\n\t\t\treturn this.mergeAttributesIntoExistingTunnel(existingTunnel, tunnelProperties, attributes);\n\t\t}\n\n\t\treturn noTunnelValue;\n\t}\n\n\tprivate mergeCachedAndUnrestoredProperties(key: string, tunnelProperties: TunnelProperties): TunnelProperties {\n\t\tconst map = this.unrestoredExtensionTunnels.has(key) ? this.unrestoredExtensionTunnels : (this.sessionCachedProperties.has(key) ? this.sessionCachedProperties : undefined);\n\t\tif (map) {\n\t\t\tconst updateProps = map.get(key)!;\n\t\t\tmap.delete(key);\n\t\t\tif (updateProps) {\n\t\t\t\ttunnelProperties.name = updateProps.name ?? tunnelProperties.name;\n\t\t\t\ttunnelProperties.local = (('local' in updateProps) ? updateProps.local : (('localPort' in updateProps) ? updateProps.localPort : undefined)) ?? tunnelProperties.local;\n\t\t\t\ttunnelProperties.privacy = tunnelProperties.privacy;\n\t\t\t}\n\t\t}\n\t\treturn tunnelProperties;\n\t}\n\n\tprivate async mergeAttributesIntoExistingTunnel(existingTunnel: Tunnel, tunnelProperties: TunnelProperties, attributes: Attributes | undefined) {\n\t\tconst newName = attributes?.label ?? tunnelProperties.name;\n\t\tenum MergedAttributeAction {\n\t\t\tNone = 0,\n\t\t\tFire = 1,\n\t\t\tReopen = 2\n\t\t}\n\t\tlet mergedAction = MergedAttributeAction.None;\n\t\tif (newName !== existingTunnel.name) {\n\t\t\texistingTunnel.name = newName;\n\t\t\tmergedAction = MergedAttributeAction.Fire;\n\t\t}\n\t\t// Source of existing tunnel wins so that original source is maintained\n\t\tif ((attributes?.protocol || (existingTunnel.protocol !== TunnelProtocol.Http)) && (attributes?.protocol !== existingTunnel.protocol)) {\n\t\t\ttunnelProperties.source = existingTunnel.source;\n\t\t\tmergedAction = MergedAttributeAction.Reopen;\n\t\t}\n\t\t// New privacy value wins\n\t\tif (tunnelProperties.privacy && (existingTunnel.privacy !== tunnelProperties.privacy)) {\n\t\t\tmergedAction = MergedAttributeAction.Reopen;\n\t\t}\n\t\tswitch (mergedAction) {\n\t\t\tcase MergedAttributeAction.Fire: {\n\t\t\t\tthis._onForwardPort.fire();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase MergedAttributeAction.Reopen: {\n\t\t\t\tawait this.close(existingTunnel.remoteHost, existingTunnel.remotePort, TunnelCloseReason.User);\n\t\t\t\tawait this.doForward(tunnelProperties, attributes);\n\t\t\t}\n\t\t}\n\n\t\treturn mapHasAddressLocalhostOrAllInterfaces(this.remoteTunnels, tunnelProperties.remote.host, tunnelProperties.remote.port);\n\t}\n\n\tasync name(host: string, port: number, name: string) {\n\t\tconst existingForwarded = mapHasAddressLocalhostOrAllInterfaces(this.forwarded, host, port);\n\t\tconst key = makeAddress(host, port);\n\t\tif (existingForwarded) {\n\t\t\texistingForwarded.name = name;\n\t\t\tawait this.storeForwarded();\n\t\t\tthis._onPortName.fire({ host, port });\n\t\t\treturn;\n\t\t} else if (this.detected.has(key)) {\n\t\t\tthis.detected.get(key)!.name = name;\n\t\t\tthis._onPortName.fire({ host, port });\n\t\t}\n\t}\n\n\tasync close(host: string, port: number, reason: TunnelCloseReason): Promise<void> {\n\t\tconst key = makeAddress(host, port);\n\t\tconst oldTunnel = this.forwarded.get(key)!;\n\t\tif ((reason === TunnelCloseReason.AutoForwardEnd) && oldTunnel && (oldTunnel.source.source === TunnelSource.Auto)) {\n\t\t\tthis.sessionCachedProperties.set(key, {\n\t\t\t\tlocal: oldTunnel.localPort,\n\t\t\t\tname: oldTunnel.name,\n\t\t\t\tprivacy: oldTunnel.privacy,\n\t\t\t});\n\t\t}\n\t\tawait this.tunnelService.closeTunnel(host, port);\n\t\treturn this.onTunnelClosed({ host, port }, reason);\n\t}\n\n\taddress(host: string, port: number): string | undefined {\n\t\tconst key = makeAddress(host, port);\n\t\treturn (this.forwarded.get(key) || this.detected.get(key))?.localAddress;\n\t}\n\n\tpublic get environmentTunnelsSet(): boolean {\n\t\treturn this._environmentTunnelsSet;\n\t}\n\n\taddEnvironmentTunnels(tunnels: TunnelDescription[] | undefined): void {\n\t\tif (tunnels) {\n\t\t\tfor (const tunnel of tunnels) {\n\t\t\t\tconst matchingCandidate = mapHasAddressLocalhostOrAllInterfaces(this._candidates ?? new Map(), tunnel.remoteAddress.host, tunnel.remoteAddress.port);\n\t\t\t\tconst localAddress = typeof tunnel.localAddress === 'string' ? tunnel.localAddress : makeAddress(tunnel.localAddress.host, tunnel.localAddress.port);\n\t\t\t\tthis.detected.set(makeAddress(tunnel.remoteAddress.host, tunnel.remoteAddress.port), {\n\t\t\t\t\tremoteHost: tunnel.remoteAddress.host,\n\t\t\t\t\tremotePort: tunnel.remoteAddress.port,\n\t\t\t\t\tlocalAddress: localAddress,\n\t\t\t\t\tprotocol: TunnelProtocol.Http,\n\t\t\t\t\tlocalUri: this.makeLocalUri(localAddress),\n\t\t\t\t\tcloseable: false,\n\t\t\t\t\trunningProcess: matchingCandidate?.detail,\n\t\t\t\t\thasRunningProcess: !!matchingCandidate,\n\t\t\t\t\tpid: matchingCandidate?.pid,\n\t\t\t\t\tprivacy: TunnelPrivacyId.ConstantPrivate,\n\t\t\t\t\tsource: {\n\t\t\t\t\t\tsource: TunnelSource.Extension,\n\t\t\t\t\t\tdescription: nls.localize('tunnel.staticallyForwarded', \"Statically Forwarded\")\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tthis.tunnelService.setEnvironmentTunnel(tunnel.remoteAddress.host, tunnel.remoteAddress.port, localAddress, TunnelPrivacyId.ConstantPrivate, TunnelProtocol.Http);\n\t\t\t}\n\t\t}\n\t\tthis._environmentTunnelsSet = true;\n\t\tthis._onEnvironmentTunnelsSet.fire();\n\t\tthis._onForwardPort.fire();\n\t}\n\n\tsetCandidateFilter(filter: ((candidates: CandidatePort[]) => Promise<CandidatePort[]>) | undefined): void {\n\t\tthis._candidateFilter = filter;\n\t}\n\n\tasync setCandidates(candidates: CandidatePort[]) {\n\t\tlet processedCandidates = candidates;\n\t\tif (this._candidateFilter) {\n\t\t\t// When an extension provides a filter, we do the filtering on the extension host before the candidates are set here.\n\t\t\t// However, when the filter doesn't come from an extension we filter here.\n\t\t\tprocessedCandidates = await this._candidateFilter(candidates);\n\t\t}\n\t\tconst removedCandidates = this.updateInResponseToCandidates(processedCandidates);\n\t\tthis.logService.trace(`ForwardedPorts: (TunnelModel) removed candidates ${Array.from(removedCandidates.values()).map(candidate => candidate.port).join(', ')}`);\n\t\tthis._onCandidatesChanged.fire(removedCandidates);\n\t}\n\n\t// Returns removed candidates\n\tprivate updateInResponseToCandidates(candidates: CandidatePort[]): Map<string, { host: string; port: number }> {\n\t\tconst removedCandidates = this._candidates ?? new Map();\n\t\tconst candidatesMap = new Map();\n\t\tthis._candidates = candidatesMap;\n\t\tcandidates.forEach(value => {\n\t\t\tconst addressKey = makeAddress(value.host, value.port);\n\t\t\tcandidatesMap.set(addressKey, {\n\t\t\t\thost: value.host,\n\t\t\t\tport: value.port,\n\t\t\t\tdetail: value.detail,\n\t\t\t\tpid: value.pid\n\t\t\t});\n\t\t\tif (removedCandidates.has(addressKey)) {\n\t\t\t\tremovedCandidates.delete(addressKey);\n\t\t\t}\n\t\t\tconst forwardedValue = mapHasAddressLocalhostOrAllInterfaces(this.forwarded, value.host, value.port);\n\t\t\tif (forwardedValue) {\n\t\t\t\tforwardedValue.runningProcess = value.detail;\n\t\t\t\tforwardedValue.hasRunningProcess = true;\n\t\t\t\tforwardedValue.pid = value.pid;\n\t\t\t}\n\t\t});\n\t\tremovedCandidates.forEach((_value, key) => {\n\t\t\tconst parsedAddress = parseAddress(key);\n\t\t\tif (!parsedAddress) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst forwardedValue = mapHasAddressLocalhostOrAllInterfaces(this.forwarded, parsedAddress.host, parsedAddress.port);\n\t\t\tif (forwardedValue) {\n\t\t\t\tforwardedValue.runningProcess = undefined;\n\t\t\t\tforwardedValue.hasRunningProcess = false;\n\t\t\t\tforwardedValue.pid = undefined;\n\t\t\t}\n\t\t\tconst detectedValue = mapHasAddressLocalhostOrAllInterfaces(this.detected, parsedAddress.host, parsedAddress.port);\n\t\t\tif (detectedValue) {\n\t\t\t\tdetectedValue.runningProcess = undefined;\n\t\t\t\tdetectedValue.hasRunningProcess = false;\n\t\t\t\tdetectedValue.pid = undefined;\n\t\t\t}\n\t\t});\n\t\treturn removedCandidates;\n\t}\n\n\tget candidates(): CandidatePort[] {\n\t\treturn this._candidates ? Array.from(this._candidates.values()) : [];\n\t}\n\n\tget candidatesOrUndefined(): CandidatePort[] | undefined {\n\t\treturn this._candidates ? this.candidates : undefined;\n\t}\n\n\tprivate async updateAttributes() {\n\t\t// If the label changes in the attributes, we should update it.\n\t\tconst tunnels = Array.from(this.forwarded.values());\n\t\tconst allAttributes = await this.getAttributes(tunnels.map(tunnel => {\n\t\t\treturn { port: tunnel.remotePort, host: tunnel.remoteHost };\n\t\t}), false);\n\t\tif (!allAttributes) {\n\t\t\treturn;\n\t\t}\n\t\tfor (const forwarded of tunnels) {\n\t\t\tconst attributes = allAttributes.get(forwarded.remotePort);\n\t\t\tif ((attributes?.protocol || (forwarded.protocol !== TunnelProtocol.Http)) && (attributes?.protocol !== forwarded.protocol)) {\n\t\t\t\tawait this.doForward({\n\t\t\t\t\tremote: { host: forwarded.remoteHost, port: forwarded.remotePort },\n\t\t\t\t\tlocal: forwarded.localPort,\n\t\t\t\t\tname: forwarded.name,\n\t\t\t\t\tsource: forwarded.source\n\t\t\t\t}, attributes);\n\t\t\t}\n\n\t\t\tif (!attributes) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (attributes.label && attributes.label !== forwarded.name) {\n\t\t\t\tawait this.name(forwarded.remoteHost, forwarded.remotePort, attributes.label);\n\t\t\t}\n\n\t\t}\n\t}\n\n\tasync getAttributes(forwardedPorts: { host: string; port: number }[], checkProviders: boolean = true): Promise<Map<number, Attributes> | undefined> {\n\t\tconst matchingCandidates: Map<number, CandidatePort> = new Map();\n\t\tconst pidToPortsMapping: Map<number | undefined, number[]> = new Map();\n\t\tforwardedPorts.forEach(forwardedPort => {\n\t\t\tconst matchingCandidate = mapHasAddressLocalhostOrAllInterfaces<CandidatePort>(this._candidates ?? new Map(), LOCALHOST_ADDRESSES[0], forwardedPort.port) ?? forwardedPort;\n\t\t\tif (matchingCandidate) {\n\t\t\t\tmatchingCandidates.set(forwardedPort.port, matchingCandidate);\n\t\t\t\tconst pid = isCandidatePort(matchingCandidate) ? matchingCandidate.pid : undefined;\n\t\t\t\tif (!pidToPortsMapping.has(pid)) {\n\t\t\t\t\tpidToPortsMapping.set(pid, []);\n\t\t\t\t}\n\t\t\t\tpidToPortsMapping.get(pid)?.push(forwardedPort.port);\n\t\t\t}\n\t\t});\n\n\t\tconst configAttributes: Map<number, Attributes> = new Map();\n\t\tforwardedPorts.forEach(forwardedPort => {\n\t\t\tconst attributes = this.configPortsAttributes.getAttributes(forwardedPort.port, forwardedPort.host, matchingCandidates.get(forwardedPort.port)?.detail);\n\t\t\tif (attributes) {\n\t\t\t\tconfigAttributes.set(forwardedPort.port, attributes);\n\t\t\t}\n\t\t});\n\t\tif ((this.portAttributesProviders.length === 0) || !checkProviders) {\n\t\t\treturn (configAttributes.size > 0) ? configAttributes : undefined;\n\t\t}\n\n\t\t// Group calls to provide attributes by pid.\n\t\tconst allProviderResults = await Promise.all(this.portAttributesProviders.flatMap(provider => {\n\t\t\treturn Array.from(pidToPortsMapping.entries()).map(entry => {\n\t\t\t\tconst portGroup = entry[1];\n\t\t\t\tconst matchingCandidate = matchingCandidates.get(portGroup[0]);\n\t\t\t\treturn provider.providePortAttributes(portGroup,\n\t\t\t\t\tmatchingCandidate?.pid, matchingCandidate?.detail, CancellationToken.None);\n\t\t\t});\n\t\t}));\n\t\tconst providedAttributes: Map<number, ProvidedPortAttributes> = new Map();\n\t\tallProviderResults.forEach(attributes => attributes.forEach(attribute => {\n\t\t\tif (attribute) {\n\t\t\t\tprovidedAttributes.set(attribute.port, attribute);\n\t\t\t}\n\t\t}));\n\n\t\tif (!configAttributes && !providedAttributes) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Merge. The config wins.\n\t\tconst mergedAttributes: Map<number, Attributes> = new Map();\n\t\tforwardedPorts.forEach(forwardedPorts => {\n\t\t\tconst config = configAttributes.get(forwardedPorts.port);\n\t\t\tconst provider = providedAttributes.get(forwardedPorts.port);\n\t\t\tmergedAttributes.set(forwardedPorts.port, {\n\t\t\t\televateIfNeeded: config?.elevateIfNeeded,\n\t\t\t\tlabel: config?.label,\n\t\t\t\tonAutoForward: config?.onAutoForward ?? PortsAttributes.providedActionToAction(provider?.autoForwardAction),\n\t\t\t\trequireLocalPort: config?.requireLocalPort,\n\t\t\t\tprotocol: config?.protocol\n\t\t\t});\n\t\t});\n\n\t\treturn mergedAttributes;\n\t}\n\n\taddAttributesProvider(provider: PortAttributesProvider) {\n\t\tthis.portAttributesProviders.push(provider);\n\t}\n}\n"],
  "mappings": "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",
  "names": ["TunnelCloseReason", "TunnelSource", "OnPortForward", "MergedAttributeAction", "forwardedPorts"]
}
