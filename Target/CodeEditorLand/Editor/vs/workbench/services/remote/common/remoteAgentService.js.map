{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/remote/common/remoteAgentService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { timeout } from \"../../../../base/common/async.js\";\nimport type { Event } from \"../../../../base/common/event.js\";\nimport type {\n\tIChannel,\n\tIServerChannel,\n} from \"../../../../base/parts/ipc/common/ipc.js\";\nimport type {\n\tIDiagnosticInfo,\n\tIDiagnosticInfoOptions,\n} from \"../../../../platform/diagnostics/common/diagnostics.js\";\nimport { createDecorator } from \"../../../../platform/instantiation/common/instantiation.js\";\nimport type { PersistentConnectionEvent } from \"../../../../platform/remote/common/remoteAgentConnection.js\";\nimport type {\n\tIRemoteAgentEnvironment,\n\tRemoteAgentConnectionContext,\n} from \"../../../../platform/remote/common/remoteAgentEnvironment.js\";\nimport type {\n\tITelemetryData,\n\tTelemetryLevel,\n} from \"../../../../platform/telemetry/common/telemetry.js\";\n\nexport const IRemoteAgentService =\n\tcreateDecorator<IRemoteAgentService>(\"remoteAgentService\");\n\nexport interface IRemoteAgentService {\n\treadonly _serviceBrand: undefined;\n\n\tgetConnection(): IRemoteAgentConnection | null;\n\t/**\n\t * Get the remote environment. In case of an error, returns `null`.\n\t */\n\tgetEnvironment(): Promise<IRemoteAgentEnvironment | null>;\n\t/**\n\t * Get the remote environment. Can return an error.\n\t */\n\tgetRawEnvironment(): Promise<IRemoteAgentEnvironment | null>;\n\t/**\n\t * Get exit information for a remote extension host.\n\t */\n\tgetExtensionHostExitInfo(\n\t\treconnectionToken: string,\n\t): Promise<IExtensionHostExitInfo | null>;\n\n\t/**\n\t * Gets the round trip time from the remote extension host. Note that this\n\t * may be delayed if the extension host is busy.\n\t */\n\tgetRoundTripTime(): Promise<number | undefined>;\n\n\t/**\n\t * Gracefully ends the current connection, if any.\n\t */\n\tendConnection(): Promise<void>;\n\n\tgetDiagnosticInfo(\n\t\toptions: IDiagnosticInfoOptions,\n\t): Promise<IDiagnosticInfo | undefined>;\n\tupdateTelemetryLevel(telemetryLevel: TelemetryLevel): Promise<void>;\n\tlogTelemetry(eventName: string, data?: ITelemetryData): Promise<void>;\n\tflushTelemetry(): Promise<void>;\n}\n\nexport interface IExtensionHostExitInfo {\n\tcode: number;\n\tsignal: string;\n}\n\nexport interface IRemoteAgentConnection {\n\treadonly remoteAuthority: string;\n\n\treadonly onReconnecting: Event<void>;\n\treadonly onDidStateChange: Event<PersistentConnectionEvent>;\n\n\tend(): Promise<void>;\n\tdispose(): void;\n\tgetChannel<T extends IChannel>(channelName: string): T;\n\twithChannel<T extends IChannel, R>(\n\t\tchannelName: string,\n\t\tcallback: (channel: T) => Promise<R>,\n\t): Promise<R>;\n\tregisterChannel<T extends IServerChannel<RemoteAgentConnectionContext>>(\n\t\tchannelName: string,\n\t\tchannel: T,\n\t): void;\n\tgetInitialConnectionTimeMs(): Promise<number>;\n}\n\nexport interface IRemoteConnectionLatencyMeasurement {\n\treadonly initial: number | undefined;\n\treadonly current: number;\n\treadonly average: number;\n\n\treadonly high: boolean;\n}\n\nexport const remoteConnectionLatencyMeasurer = new (class {\n\treadonly maxSampleCount = 5;\n\treadonly sampleDelay = 2000;\n\n\treadonly initial: number[] = [];\n\treadonly maxInitialCount = 3;\n\n\treadonly average: number[] = [];\n\treadonly maxAverageCount = 100;\n\n\treadonly highLatencyMultiple = 2;\n\treadonly highLatencyMinThreshold = 500;\n\treadonly highLatencyMaxThreshold = 1500;\n\n\tlastMeasurement: IRemoteConnectionLatencyMeasurement | undefined =\n\t\tundefined;\n\tget latency() {\n\t\treturn this.lastMeasurement;\n\t}\n\n\tasync measure(\n\t\tremoteAgentService: IRemoteAgentService,\n\t): Promise<IRemoteConnectionLatencyMeasurement | undefined> {\n\t\tlet currentLatency = Number.POSITIVE_INFINITY;\n\n\t\t// Measure up to samples count\n\t\tfor (let i = 0; i < this.maxSampleCount; i++) {\n\t\t\tconst rtt = await remoteAgentService.getRoundTripTime();\n\t\t\tif (rtt === undefined) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tcurrentLatency = Math.min(\n\t\t\t\tcurrentLatency,\n\t\t\t\trtt / 2 /* we want just one way, not round trip time */,\n\t\t\t);\n\t\t\tawait timeout(this.sampleDelay);\n\t\t}\n\n\t\t// Keep track of average latency\n\t\tthis.average.push(currentLatency);\n\t\tif (this.average.length > this.maxAverageCount) {\n\t\t\tthis.average.shift();\n\t\t}\n\n\t\t// Keep track of initial latency\n\t\tlet initialLatency: number | undefined;\n\t\tif (this.initial.length < this.maxInitialCount) {\n\t\t\tthis.initial.push(currentLatency);\n\t\t} else {\n\t\t\tinitialLatency =\n\t\t\t\tthis.initial.reduce((sum, value) => sum + value, 0) /\n\t\t\t\tthis.initial.length;\n\t\t}\n\n\t\t// Remember as last measurement\n\t\tthis.lastMeasurement = {\n\t\t\tinitial: initialLatency,\n\t\t\tcurrent: currentLatency,\n\t\t\taverage:\n\t\t\t\tthis.average.reduce((sum, value) => sum + value, 0) /\n\t\t\t\tthis.average.length,\n\t\t\thigh: (() => {\n\t\t\t\t// based on the initial, average and current latency, try to decide\n\t\t\t\t// if the connection has high latency\n\t\t\t\t// Some rules:\n\t\t\t\t// - we require the initial latency to be computed\n\t\t\t\t// - we only consider latency above highLatencyMinThreshold as potentially high\n\t\t\t\t// - we require the current latency to be above the average latency by a factor of highLatencyMultiple\n\t\t\t\t// - but not if the latency is actually above highLatencyMaxThreshold\n\n\t\t\t\tif (typeof initialLatency === \"undefined\") {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (currentLatency > this.highLatencyMaxThreshold) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tcurrentLatency > this.highLatencyMinThreshold &&\n\t\t\t\t\tcurrentLatency > initialLatency * this.highLatencyMultiple\n\t\t\t\t) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t})(),\n\t\t};\n\n\t\treturn this.lastMeasurement;\n\t}\n})();\n"],
  "mappings": "AAKA,SAAS,eAAe;AAUxB,SAAS,uBAAuB;AAWzB,MAAM,sBACZ,gBAAqC,oBAAoB;AAyEnD,MAAM,kCAAkC,IAAK,MAAM;AAAA,EAChD,iBAAiB;AAAA,EACjB,cAAc;AAAA,EAEd,UAAoB,CAAC;AAAA,EACrB,kBAAkB;AAAA,EAElB,UAAoB,CAAC;AAAA,EACrB,kBAAkB;AAAA,EAElB,sBAAsB;AAAA,EACtB,0BAA0B;AAAA,EAC1B,0BAA0B;AAAA,EAEnC,kBACC;AAAA,EACD,IAAI,UAAU;AACb,WAAO,KAAK;AAAA,EACb;AAAA,EAEA,MAAM,QACL,oBAC2D;AAC3D,QAAI,iBAAiB,OAAO;AAG5B,aAAS,IAAI,GAAG,IAAI,KAAK,gBAAgB,KAAK;AAC7C,YAAM,MAAM,MAAM,mBAAmB,iBAAiB;AACtD,UAAI,QAAQ,QAAW;AACtB,eAAO;AAAA,MACR;AAEA,uBAAiB,KAAK;AAAA,QACrB;AAAA,QACA,MAAM;AAAA,MACP;AACA,YAAM,QAAQ,KAAK,WAAW;AAAA,IAC/B;AAGA,SAAK,QAAQ,KAAK,cAAc;AAChC,QAAI,KAAK,QAAQ,SAAS,KAAK,iBAAiB;AAC/C,WAAK,QAAQ,MAAM;AAAA,IACpB;AAGA,QAAI;AACJ,QAAI,KAAK,QAAQ,SAAS,KAAK,iBAAiB;AAC/C,WAAK,QAAQ,KAAK,cAAc;AAAA,IACjC,OAAO;AACN,uBACC,KAAK,QAAQ,OAAO,CAAC,KAAK,UAAU,MAAM,OAAO,CAAC,IAClD,KAAK,QAAQ;AAAA,IACf;AAGA,SAAK,kBAAkB;AAAA,MACtB,SAAS;AAAA,MACT,SAAS;AAAA,MACT,SACC,KAAK,QAAQ,OAAO,CAAC,KAAK,UAAU,MAAM,OAAO,CAAC,IAClD,KAAK,QAAQ;AAAA,MACd,OAAO,MAAM;AASZ,YAAI,OAAO,mBAAmB,aAAa;AAC1C,iBAAO;AAAA,QACR;AAEA,YAAI,iBAAiB,KAAK,yBAAyB;AAClD,iBAAO;AAAA,QACR;AAEA,YACC,iBAAiB,KAAK,2BACtB,iBAAiB,iBAAiB,KAAK,qBACtC;AACD,iBAAO;AAAA,QACR;AAEA,eAAO;AAAA,MACR,GAAG;AAAA,IACJ;AAEA,WAAO,KAAK;AAAA,EACb;AACD,EAAG;",
  "names": []
}
