{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/remote/common/remoteAgentService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { RemoteAgentConnectionContext, IRemoteAgentEnvironment } from '../../../../platform/remote/common/remoteAgentEnvironment.js';\nimport { IChannel, IServerChannel } from '../../../../base/parts/ipc/common/ipc.js';\nimport { IDiagnosticInfoOptions, IDiagnosticInfo } from '../../../../platform/diagnostics/common/diagnostics.js';\nimport { Event } from '../../../../base/common/event.js';\nimport { PersistentConnectionEvent } from '../../../../platform/remote/common/remoteAgentConnection.js';\nimport { ITelemetryData, TelemetryLevel } from '../../../../platform/telemetry/common/telemetry.js';\nimport { timeout } from '../../../../base/common/async.js';\n\nexport const IRemoteAgentService = createDecorator<IRemoteAgentService>('remoteAgentService');\n\nexport interface IRemoteAgentService {\n\treadonly _serviceBrand: undefined;\n\n\tgetConnection(): IRemoteAgentConnection | null;\n\t/**\n\t * Get the remote environment. In case of an error, returns `null`.\n\t */\n\tgetEnvironment(): Promise<IRemoteAgentEnvironment | null>;\n\t/**\n\t * Get the remote environment. Can return an error.\n\t */\n\tgetRawEnvironment(): Promise<IRemoteAgentEnvironment | null>;\n\t/**\n\t * Get exit information for a remote extension host.\n\t */\n\tgetExtensionHostExitInfo(reconnectionToken: string): Promise<IExtensionHostExitInfo | null>;\n\n\t/**\n\t * Gets the round trip time from the remote extension host. Note that this\n\t * may be delayed if the extension host is busy.\n\t */\n\tgetRoundTripTime(): Promise<number | undefined>;\n\n\t/**\n\t * Gracefully ends the current connection, if any.\n\t */\n\tendConnection(): Promise<void>;\n\n\tgetDiagnosticInfo(options: IDiagnosticInfoOptions): Promise<IDiagnosticInfo | undefined>;\n\tupdateTelemetryLevel(telemetryLevel: TelemetryLevel): Promise<void>;\n\tlogTelemetry(eventName: string, data?: ITelemetryData): Promise<void>;\n\tflushTelemetry(): Promise<void>;\n}\n\nexport interface IExtensionHostExitInfo {\n\tcode: number;\n\tsignal: string;\n}\n\nexport interface IRemoteAgentConnection {\n\treadonly remoteAuthority: string;\n\n\treadonly onReconnecting: Event<void>;\n\treadonly onDidStateChange: Event<PersistentConnectionEvent>;\n\n\tend(): Promise<void>;\n\tdispose(): void;\n\tgetChannel<T extends IChannel>(channelName: string): T;\n\twithChannel<T extends IChannel, R>(channelName: string, callback: (channel: T) => Promise<R>): Promise<R>;\n\tregisterChannel<T extends IServerChannel<RemoteAgentConnectionContext>>(channelName: string, channel: T): void;\n\tgetInitialConnectionTimeMs(): Promise<number>;\n}\n\nexport interface IRemoteConnectionLatencyMeasurement {\n\n\treadonly initial: number | undefined;\n\treadonly current: number;\n\treadonly average: number;\n\n\treadonly high: boolean;\n}\n\nexport const remoteConnectionLatencyMeasurer = new class {\n\n\treadonly maxSampleCount = 5;\n\treadonly sampleDelay = 2000;\n\n\treadonly initial: number[] = [];\n\treadonly maxInitialCount = 3;\n\n\treadonly average: number[] = [];\n\treadonly maxAverageCount = 100;\n\n\treadonly highLatencyMultiple = 2;\n\treadonly highLatencyMinThreshold = 500;\n\treadonly highLatencyMaxThreshold = 1500;\n\n\tlastMeasurement: IRemoteConnectionLatencyMeasurement | undefined = undefined;\n\tget latency() { return this.lastMeasurement; }\n\n\tasync measure(remoteAgentService: IRemoteAgentService): Promise<IRemoteConnectionLatencyMeasurement | undefined> {\n\t\tlet currentLatency = Infinity;\n\n\t\t// Measure up to samples count\n\t\tfor (let i = 0; i < this.maxSampleCount; i++) {\n\t\t\tconst rtt = await remoteAgentService.getRoundTripTime();\n\t\t\tif (rtt === undefined) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tcurrentLatency = Math.min(currentLatency, rtt / 2 /* we want just one way, not round trip time */);\n\t\t\tawait timeout(this.sampleDelay);\n\t\t}\n\n\t\t// Keep track of average latency\n\t\tthis.average.push(currentLatency);\n\t\tif (this.average.length > this.maxAverageCount) {\n\t\t\tthis.average.shift();\n\t\t}\n\n\t\t// Keep track of initial latency\n\t\tlet initialLatency: number | undefined = undefined;\n\t\tif (this.initial.length < this.maxInitialCount) {\n\t\t\tthis.initial.push(currentLatency);\n\t\t} else {\n\t\t\tinitialLatency = this.initial.reduce((sum, value) => sum + value, 0) / this.initial.length;\n\t\t}\n\n\t\t// Remember as last measurement\n\t\tthis.lastMeasurement = {\n\t\t\tinitial: initialLatency,\n\t\t\tcurrent: currentLatency,\n\t\t\taverage: this.average.reduce((sum, value) => sum + value, 0) / this.average.length,\n\t\t\thigh: (() => {\n\n\t\t\t\t// based on the initial, average and current latency, try to decide\n\t\t\t\t// if the connection has high latency\n\t\t\t\t// Some rules:\n\t\t\t\t// - we require the initial latency to be computed\n\t\t\t\t// - we only consider latency above highLatencyMinThreshold as potentially high\n\t\t\t\t// - we require the current latency to be above the average latency by a factor of highLatencyMultiple\n\t\t\t\t// - but not if the latency is actually above highLatencyMaxThreshold\n\n\t\t\t\tif (typeof initialLatency === 'undefined') {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (currentLatency > this.highLatencyMaxThreshold) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tif (currentLatency > this.highLatencyMinThreshold && currentLatency > initialLatency * this.highLatencyMultiple) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t})()\n\t\t};\n\n\t\treturn this.lastMeasurement;\n\t}\n};\n"],
  "mappings": "AAKA,SAAS,uBAAuB;AAChC,SAAS,8BAA8B,+BAA+B;AACtE,SAAS,UAAU,sBAAsB;AACzC,SAAS,wBAAwB,uBAAuB;AACxD,SAAS,aAAa;AACtB,SAAS,iCAAiC;AAC1C,SAAS,gBAAgB,sBAAsB;AAC/C,SAAS,eAAe;AAEjB,MAAM,sBAAsB,gBAAqC,oBAAoB;AAgErF,MAAM,kCAAkC,IAAI,MAAM;AAAA,EAE/C,iBAAiB;AAAA,EACjB,cAAc;AAAA,EAEd,UAAoB,CAAC;AAAA,EACrB,kBAAkB;AAAA,EAElB,UAAoB,CAAC;AAAA,EACrB,kBAAkB;AAAA,EAElB,sBAAsB;AAAA,EACtB,0BAA0B;AAAA,EAC1B,0BAA0B;AAAA,EAEnC,kBAAmE;AAAA,EACnE,IAAI,UAAU;AAAE,WAAO,KAAK;AAAA,EAAiB;AAAA,EAE7C,MAAM,QAAQ,oBAAmG;AAChH,QAAI,iBAAiB;AAGrB,aAAS,IAAI,GAAG,IAAI,KAAK,gBAAgB,KAAK;AAC7C,YAAM,MAAM,MAAM,mBAAmB,iBAAiB;AACtD,UAAI,QAAQ,QAAW;AACtB,eAAO;AAAA,MACR;AAEA,uBAAiB,KAAK;AAAA,QAAI;AAAA,QAAgB,MAAM;AAAA;AAAA,MAAiD;AACjG,YAAM,QAAQ,KAAK,WAAW;AAAA,IAC/B;AAGA,SAAK,QAAQ,KAAK,cAAc;AAChC,QAAI,KAAK,QAAQ,SAAS,KAAK,iBAAiB;AAC/C,WAAK,QAAQ,MAAM;AAAA,IACpB;AAGA,QAAI,iBAAqC;AACzC,QAAI,KAAK,QAAQ,SAAS,KAAK,iBAAiB;AAC/C,WAAK,QAAQ,KAAK,cAAc;AAAA,IACjC,OAAO;AACN,uBAAiB,KAAK,QAAQ,OAAO,CAAC,KAAK,UAAU,MAAM,OAAO,CAAC,IAAI,KAAK,QAAQ;AAAA,IACrF;AAGA,SAAK,kBAAkB;AAAA,MACtB,SAAS;AAAA,MACT,SAAS;AAAA,MACT,SAAS,KAAK,QAAQ,OAAO,CAAC,KAAK,UAAU,MAAM,OAAO,CAAC,IAAI,KAAK,QAAQ;AAAA,MAC5E,OAAO,MAAM;AAUZ,YAAI,OAAO,mBAAmB,aAAa;AAC1C,iBAAO;AAAA,QACR;AAEA,YAAI,iBAAiB,KAAK,yBAAyB;AAClD,iBAAO;AAAA,QACR;AAEA,YAAI,iBAAiB,KAAK,2BAA2B,iBAAiB,iBAAiB,KAAK,qBAAqB;AAChH,iBAAO;AAAA,QACR;AAEA,eAAO;AAAA,MACR,GAAG;AAAA,IACJ;AAEA,WAAO,KAAK;AAAA,EACb;AACD;",
  "names": []
}
