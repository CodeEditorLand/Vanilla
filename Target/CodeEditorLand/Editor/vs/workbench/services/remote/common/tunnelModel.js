var z=Object.defineProperty;var B=Object.getOwnPropertyDescriptor;var I=(c,l,e,t)=>{for(var r=t>1?void 0:t?B(l,e):l,o=c.length-1,n;o>=0;o--)(n=c[o])&&(r=(t?n(l,e,r):n(r))||r);return t&&r&&z(l,e,r),r},A=(c,l)=>(e,t)=>l(e,t,c);import*as S from"../../../../nls.js";import{debounce as G}from"../../../../base/common/decorators.js";import{Emitter as w,Event as j}from"../../../../base/common/event.js";import{hash as k}from"../../../../base/common/hash.js";import{Disposable as L,DisposableStore as X}from"../../../../base/common/lifecycle.js";import{URI as M}from"../../../../base/common/uri.js";import{IConfigurationService as J}from"../../../../platform/configuration/common/configuration.js";import{IDialogService as Z}from"../../../../platform/dialogs/common/dialogs.js";import{ILogService as Q}from"../../../../platform/log/common/log.js";import"../../../../platform/remote/common/remoteAgentConnection.js";import{IRemoteAuthorityResolverService as Y}from"../../../../platform/remote/common/remoteAuthorityResolver.js";import{IStorageService as ee,StorageScope as v,StorageTarget as F}from"../../../../platform/storage/common/storage.js";import{ITunnelService as te,TunnelProtocol as b,TunnelPrivacyId as V,LOCALHOST_ADDRESSES as U,isLocalhost as x,isAllInterfaces as N,ProvidedOnAutoForward as R,ALL_INTERFACES_ADDRESSES as re}from"../../../../platform/tunnel/common/tunnel.js";import{IWorkspaceContextService as oe}from"../../../../platform/workspace/common/workspace.js";import{IWorkbenchEnvironmentService as ne}from"../../environment/common/environmentService.js";import{IExtensionService as ie}from"../../extensions/common/extensions.js";import{CancellationToken as se}from"../../../../base/common/cancellation.js";import{isNumber as O,isObject as D,isString as K}from"../../../../base/common/types.js";import{deepClone as ae}from"../../../../base/common/objects.js";import{IContextKeyService as de,RawContextKey as q}from"../../../../platform/contextkey/common/contextkey.js";const ce=10*1e3,E="remote.tunnels.toRestore",H="remote.tunnels.toRestoreExpiration",ue=1e3*60*60*24*14,$="onTunnel",$e=new q("forwardedPortsViewEnabled",!1,S.localize("tunnel.forwardedPortsViewEnabled","Whether the Ports view is enabled.")),le=new q("forwardedPortsViewOnlyEnabled",!1,S.localize("tunnel.forwardedPortsViewEnabled","Whether the Ports view is enabled."));function pe(c){const l=c.match(/^([a-zA-Z0-9_-]+(?:\.[a-zA-Z0-9_-]+)*:)?([0-9]+)$/);if(l)return{host:l[1]?.substring(0,l[1].length-1)||"localhost",port:Number(l[2])}}var he=(t=>(t.Other="Other",t.User="User",t.AutoForwardEnd="AutoForwardEnd",t))(he||{}),fe=(t=>(t[t.User=0]="User",t[t.Auto=1]="Auto",t[t.Extension=2]="Extension",t))(fe||{});const _={source:0,description:S.localize("tunnel.source.user","User Forwarded")},We={source:1,description:S.localize("tunnel.source.auto","Auto Forwarded")};function W(c,l,e){const t=c.get(m(l,e));if(t)return t;if(x(l))for(const r of U){const o=m(r,e);if(c.has(o))return c.get(o)}else if(N(l))for(const r of re){const o=m(r,e);if(c.has(o))return c.get(o)}}function f(c,l,e){const t=W(c,l,e);if(t)return t;const r=N(l)?"localhost":x(l)?"0.0.0.0":void 0;if(r)return W(c,r,e)}function m(c,l){return c+":"+l}var me=(n=>(n.Notify="notify",n.OpenBrowser="openBrowser",n.OpenBrowserOnce="openBrowserOnce",n.OpenPreview="openPreview",n.Silent="silent",n.Ignore="ignore",n))(me||{});function ge(c){return c&&"host"in c&&typeof c.host=="string"&&"port"in c&&typeof c.port=="number"&&(!("detail"in c)||typeof c.detail=="string")&&(!("pid"in c)||typeof c.pid=="string")}class P extends L{constructor(e){super();this.configurationService=e;this._register(e.onDidChangeConfiguration(t=>{(t.affectsConfiguration(P.SETTING)||t.affectsConfiguration(P.DEFAULTS))&&this.updateAttributes()})),this.updateAttributes()}static SETTING="remote.portsAttributes";static DEFAULTS="remote.otherPortsAttributes";static RANGE=/^(\d+)\-(\d+)$/;static HOST_AND_PORT=/^([a-z0-9\-]+):(\d{1,5})$/;portsAttributes=[];defaultPortAttributes;_onDidChangeAttributes=new w;onDidChangeAttributes=this._onDidChangeAttributes.event;updateAttributes(){this.portsAttributes=this.readSetting(),this._onDidChangeAttributes.fire()}getAttributes(e,t,r){let o=this.findNextIndex(e,t,r,this.portsAttributes,0);const n={label:void 0,onAutoForward:void 0,elevateIfNeeded:void 0,requireLocalPort:void 0,protocol:void 0};for(;o>=0;){const i=this.portsAttributes[o];i.key===e?(n.onAutoForward=i.onAutoForward??n.onAutoForward,n.elevateIfNeeded=i.elevateIfNeeded!==void 0?i.elevateIfNeeded:n.elevateIfNeeded,n.label=i.label??n.label,n.requireLocalPort=i.requireLocalPort,n.protocol=i.protocol):(n.onAutoForward=n.onAutoForward??i.onAutoForward,n.elevateIfNeeded=n.elevateIfNeeded!==void 0?n.elevateIfNeeded:i.elevateIfNeeded,n.label=n.label??i.label,n.requireLocalPort=n.requireLocalPort!==void 0?n.requireLocalPort:void 0,n.protocol=n.protocol??i.protocol),o=this.findNextIndex(e,t,r,this.portsAttributes,o+1)}return n.onAutoForward!==void 0||n.elevateIfNeeded!==void 0||n.label!==void 0||n.requireLocalPort!==void 0||n.protocol!==void 0?n:this.getOtherAttributes()}hasStartEnd(e){return e.start!==void 0&&e.end!==void 0}hasHostAndPort(e){return e.host!==void 0&&e.port!==void 0&&K(e.host)&&O(e.port)}findNextIndex(e,t,r,o,n){if(n>=o.length)return-1;const i=!x(t)&&!N(t),h=o.slice(n).findIndex(s=>O(s.key)?i?!1:s.key===e:this.hasStartEnd(s.key)?i?!1:e>=s.key.start&&e<=s.key.end:this.hasHostAndPort(s.key)?e===s.key.port&&t===s.key.host:r?s.key.test(r):!1);return h>=0?h+n:-1}readSetting(){const e=this.configurationService.getValue(P.SETTING);if(!e||!D(e))return[];const t=[];for(const o in e){if(o===void 0)continue;const n=e[o];let i;if(Number(o))i=Number(o);else if(K(o))if(P.RANGE.test(o)){const u=o.match(P.RANGE);i={start:Number(u[1]),end:Number(u[2])}}else if(P.HOST_AND_PORT.test(o)){const u=o.match(P.HOST_AND_PORT);i={host:u[1],port:Number(u[2])}}else{let u;try{u=RegExp(o)}catch{}u&&(i=u)}i&&t.push({key:i,elevateIfNeeded:n.elevateIfNeeded,onAutoForward:n.onAutoForward,label:n.label,requireLocalPort:n.requireLocalPort,protocol:n.protocol})}const r=this.configurationService.getValue(P.DEFAULTS);return r&&(this.defaultPortAttributes={elevateIfNeeded:r.elevateIfNeeded,label:r.label,onAutoForward:r.onAutoForward,requireLocalPort:r.requireLocalPort,protocol:r.protocol}),this.sortAttributes(t)}sortAttributes(e){function t(r,o){return O(r.key)?r.key:o.hasStartEnd(r.key)?r.key.start:o.hasHostAndPort(r.key)?r.key.port:Number.MAX_VALUE}return e.sort((r,o)=>t(r,this)-t(o,this))}getOtherAttributes(){return this.defaultPortAttributes}static providedActionToAction(e){switch(e){case R.Notify:return"notify";case R.OpenBrowser:return"openBrowser";case R.OpenBrowserOnce:return"openBrowserOnce";case R.OpenPreview:return"openPreview";case R.Silent:return"silent";case R.Ignore:return"ignore";default:return}}async addAttributes(e,t,r){const n=this.configurationService.inspect(P.SETTING).userRemoteValue;let i;!n||!D(n)?i={}:i=ae(n),i[`${e}`]||(i[`${e}`]={});for(const u in t)i[`${e}`][u]=t[u];return this.configurationService.updateValue(P.SETTING,i,r)}}let T=class extends L{constructor(e,t,r,o,n,i,u,h,s,d){super();this.tunnelService=e;this.storageService=t;this.configurationService=r;this.environmentService=o;this.remoteAuthorityResolverService=n;this.workspaceContextService=i;this.logService=u;this.dialogService=h;this.extensionService=s;this.contextKeyService=d;this.configPortsAttributes=new P(r),this.tunnelRestoreValue=this.getTunnelRestoreValue(),this._register(this.configPortsAttributes.onDidChangeAttributes(this.updateAttributes,this)),this.forwarded=new Map,this.remoteTunnels=new Map,this.tunnelService.tunnels.then(async a=>{const g=await this.getAttributes(a.map(p=>({port:p.tunnelRemotePort,host:p.tunnelRemoteHost})));for(const p of a)if(p.localAddress){const y=m(p.tunnelRemoteHost,p.tunnelRemotePort),C=f(this._candidates??new Map,p.tunnelRemoteHost,p.tunnelRemotePort);this.forwarded.set(y,{remotePort:p.tunnelRemotePort,remoteHost:p.tunnelRemoteHost,localAddress:p.localAddress,protocol:g?.get(p.tunnelRemotePort)?.protocol??b.Http,localUri:await this.makeLocalUri(p.localAddress,g?.get(p.tunnelRemotePort)),localPort:p.tunnelLocalPort,name:g?.get(p.tunnelRemotePort)?.label,runningProcess:C?.detail,hasRunningProcess:!!C,pid:C?.pid,privacy:p.privacy,source:_}),this.remoteTunnels.set(y,p)}}),this.detected=new Map,this._register(this.tunnelService.onTunnelOpened(async a=>{const g=m(a.tunnelRemoteHost,a.tunnelRemotePort);if(!f(this.forwarded,a.tunnelRemoteHost,a.tunnelRemotePort)&&!f(this.detected,a.tunnelRemoteHost,a.tunnelRemotePort)&&!f(this.inProgress,a.tunnelRemoteHost,a.tunnelRemotePort)&&a.localAddress){const p=f(this._candidates??new Map,a.tunnelRemoteHost,a.tunnelRemotePort),y=(await this.getAttributes([{port:a.tunnelRemotePort,host:a.tunnelRemoteHost}]))?.get(a.tunnelRemotePort);this.forwarded.set(g,{remoteHost:a.tunnelRemoteHost,remotePort:a.tunnelRemotePort,localAddress:a.localAddress,protocol:y?.protocol??b.Http,localUri:await this.makeLocalUri(a.localAddress,y),localPort:a.tunnelLocalPort,name:y?.label,closeable:!0,runningProcess:p?.detail,hasRunningProcess:!!p,pid:p?.pid,privacy:a.privacy,source:_})}await this.storeForwarded(),this.checkExtensionActivationEvents(!0),this.remoteTunnels.set(g,a),this._onForwardPort.fire(this.forwarded.get(g))})),this._register(this.tunnelService.onTunnelClosed(a=>this.onTunnelClosed(a,"Other"))),this.checkExtensionActivationEvents(!1)}forwarded;inProgress=new Map;detected;remoteTunnels;_onForwardPort=new w;onForwardPort=this._onForwardPort.event;_onClosePort=new w;onClosePort=this._onClosePort.event;_onPortName=new w;onPortName=this._onPortName.event;_candidates;_onCandidatesChanged=new w;onCandidatesChanged=this._onCandidatesChanged.event;_candidateFilter;tunnelRestoreValue;_onEnvironmentTunnelsSet=new w;onEnvironmentTunnelsSet=this._onEnvironmentTunnelsSet.event;_environmentTunnelsSet=!1;configPortsAttributes;restoreListener=void 0;knownPortsRestoreValue;restoreComplete=!1;onRestoreComplete=new w;unrestoredExtensionTunnels=new Map;sessionCachedProperties=new Map;portAttributesProviders=[];extensionHasActivationEvent(){return this.extensionService.extensions.find(e=>e.activationEvents?.includes($))?(this.contextKeyService.createKey(le.key,!0),!0):!1}hasCheckedExtensionsOnTunnelOpened=!1;checkExtensionActivationEvents(e){if(this.hasCheckedExtensionsOnTunnelOpened||(e&&(this.hasCheckedExtensionsOnTunnelOpened=!0),this.environmentService.remoteAuthority!==void 0&&!e)||this.extensionHasActivationEvent())return;const r=this._register(this.extensionService.onDidRegisterExtensions(()=>{this.extensionHasActivationEvent()&&r.dispose()}))}async onTunnelClosed(e,t){const r=m(e.host,e.port);this.forwarded.has(r)&&(this.forwarded.delete(r),await this.storeForwarded(),this._onClosePort.fire(e))}makeLocalUri(e,t){if(e.startsWith("http"))return M.parse(e);const r=t?.protocol??"http";return M.parse(`${r}://${e}`)}async addStorageKeyPostfix(e){const t=this.workspaceContextService.getWorkspace(),r=t.configuration?k(t.configuration.path):t.folders.length>0?k(t.folders[0].uri.path):void 0;if(r===void 0){this.logService.debug("Could not get workspace hash for forwarded ports storage key.");return}return`${e}.${this.environmentService.remoteAuthority}.${r}`}async getTunnelRestoreStorageKey(){return this.addStorageKeyPostfix(E)}async getRestoreExpirationStorageKey(){return this.addStorageKeyPostfix(H)}async getTunnelRestoreValue(){const e=this.storageService.get(E,v.WORKSPACE);if(e)return this.storageService.remove(E,v.WORKSPACE),await this.storeForwarded(),e;const t=await this.getTunnelRestoreStorageKey();if(t)return this.storageService.get(t,v.PROFILE)}async restoreForwarded(){if(this.cleanupExpiredTunnelsForRestore(),this.configurationService.getValue("remote.restoreForwardedPorts")){const e=await this.tunnelRestoreValue;if(e&&e!==this.knownPortsRestoreValue){const t=JSON.parse(e)??[];this.logService.trace(`ForwardedPorts: (TunnelModel) restoring ports ${t.map(r=>r.remotePort).join(", ")}`);for(const r of t){const o=f(this.detected,r.remoteHost,r.remotePort);r.source.source!==2&&!o||r.source.source===2&&o?await this.doForward({remote:{host:r.remoteHost,port:r.remotePort},local:r.localPort,name:r.name,elevateIfNeeded:!0,source:r.source}):r.source.source===2&&!o&&this.unrestoredExtensionTunnels.set(m(r.remoteHost,r.remotePort),r)}}}if(this.restoreComplete=!0,this.onRestoreComplete.fire(),!this.restoreListener){const e=await this.getTunnelRestoreStorageKey();this.restoreListener=this._register(new X),this.restoreListener.add(this.storageService.onDidChangeValue(v.PROFILE,void 0,this.restoreListener)(async t=>{t.key===e&&(this.tunnelRestoreValue=Promise.resolve(this.storageService.get(e,v.PROFILE)),await this.restoreForwarded())}))}}cleanupExpiredTunnelsForRestore(){const e=this.storageService.keys(v.PROFILE,F.USER).filter(t=>t.startsWith(H));for(const t of e){const r=this.storageService.getNumber(t,v.PROFILE);if(r&&r<Date.now()){this.tunnelRestoreValue=Promise.resolve(void 0);const o=t.replace(H,E);this.storageService.remove(t,v.PROFILE),this.storageService.remove(o,v.PROFILE)}}}async storeForwarded(){if(this.configurationService.getValue("remote.restoreForwardedPorts")){const e=Array.from(this.forwarded.values()),t=e.map(i=>({remoteHost:i.remoteHost,remotePort:i.remotePort,localPort:i.localPort,name:i.name,localAddress:i.localAddress,localUri:i.localUri,protocol:i.protocol,source:i.source}));let r;e.length>0&&(r=JSON.stringify(t));const o=await this.getTunnelRestoreStorageKey(),n=await this.getRestoreExpirationStorageKey();!r&&o&&n?(this.storageService.remove(o,v.PROFILE),this.storageService.remove(n,v.PROFILE)):r!==this.knownPortsRestoreValue&&o&&n&&(this.storageService.store(o,r,v.PROFILE,F.USER),this.storageService.store(n,Date.now()+ue,v.PROFILE,F.USER)),this.knownPortsRestoreValue=r}}mismatchCooldown=new Date;async showPortMismatchModalIfNeeded(e,t,r){if(!e.tunnelLocalPort||!r?.requireLocalPort||e.tunnelLocalPort===t)return;const o=new Date;if(this.mismatchCooldown.getTime()+ce>o.getTime())return;this.mismatchCooldown=o;const n=S.localize("remote.localPortMismatch.single",`Local port {0} could not be used for forwarding to remote port {1}.

This usually happens when there is already another process using local port {0}.

Port number {2} has been used instead.`,t,e.tunnelRemotePort,e.tunnelLocalPort);return this.dialogService.info(n)}async forward(e,t){return!this.restoreComplete&&this.environmentService.remoteAuthority&&await j.toPromise(this.onRestoreComplete.event),this.doForward(e,t)}async doForward(e,t){await this.extensionService.activateByEvent($);const r=f(this.forwarded,e.remote.host,e.remote.port);t=t??(t!==null?(await this.getAttributes([e.remote]))?.get(e.remote.port):void 0);const o=e.local!==void 0?e.local:e.remote.port;let n;if(r)return this.mergeAttributesIntoExistingTunnel(r,e,t);{const i=this.environmentService.remoteAuthority,u=i?{getAddress:async()=>(await this.remoteAuthorityResolverService.resolveAuthority(i)).authority}:void 0,h=m(e.remote.host,e.remote.port);this.inProgress.set(h,!0),e=this.mergeCachedAndUnrestoredProperties(h,e);const s=await this.tunnelService.openTunnel(u,e.remote.host,e.remote.port,void 0,o,e.elevateIfNeeded?e.elevateIfNeeded:t?.elevateIfNeeded,e.privacy,t?.protocol);if(typeof s=="string")n=s;else if(s&&s.localAddress){const d=f(this._candidates??new Map,e.remote.host,e.remote.port),a=s.protocol?s.protocol===b.Https?b.Https:b.Http:t?.protocol??b.Http,g={remoteHost:s.tunnelRemoteHost,remotePort:s.tunnelRemotePort,localPort:s.tunnelLocalPort,name:t?.label??e.name,closeable:!0,localAddress:s.localAddress,protocol:a,localUri:await this.makeLocalUri(s.localAddress,t),runningProcess:d?.detail,hasRunningProcess:!!d,pid:d?.pid,source:e.source??_,privacy:s.privacy};return this.forwarded.set(h,g),this.remoteTunnels.set(h,s),this.inProgress.delete(h),await this.storeForwarded(),await this.showPortMismatchModalIfNeeded(s,o,t),this._onForwardPort.fire(g),s}this.inProgress.delete(h)}return n}mergeCachedAndUnrestoredProperties(e,t){const r=this.unrestoredExtensionTunnels.has(e)?this.unrestoredExtensionTunnels:this.sessionCachedProperties.has(e)?this.sessionCachedProperties:void 0;if(r){const o=r.get(e);r.delete(e),o&&(t.name=o.name??t.name,t.local=("local"in o?o.local:"localPort"in o?o.localPort:void 0)??t.local,t.privacy=t.privacy)}return t}async mergeAttributesIntoExistingTunnel(e,t,r){const o=r?.label??t.name;let n;(d=>(d[d.None=0]="None",d[d.Fire=1]="Fire",d[d.Reopen=2]="Reopen"))(n||={});let i=0;switch(o!==e.name&&(e.name=o,i=1),(r?.protocol||e.protocol!==b.Http)&&r?.protocol!==e.protocol&&(t.source=e.source,i=2),t.privacy&&e.privacy!==t.privacy&&(i=2),i){case 1:{this._onForwardPort.fire();break}case 2:await this.close(e.remoteHost,e.remotePort,"User"),await this.doForward(t,r)}return f(this.remoteTunnels,t.remote.host,t.remote.port)}async name(e,t,r){const o=f(this.forwarded,e,t),n=m(e,t);if(o){o.name=r,await this.storeForwarded(),this._onPortName.fire({host:e,port:t});return}else this.detected.has(n)&&(this.detected.get(n).name=r,this._onPortName.fire({host:e,port:t}))}async close(e,t,r){const o=m(e,t),n=this.forwarded.get(o);return r==="AutoForwardEnd"&&n&&n.source.source===1&&this.sessionCachedProperties.set(o,{local:n.localPort,name:n.name,privacy:n.privacy}),await this.tunnelService.closeTunnel(e,t),this.onTunnelClosed({host:e,port:t},r)}address(e,t){const r=m(e,t);return(this.forwarded.get(r)||this.detected.get(r))?.localAddress}get environmentTunnelsSet(){return this._environmentTunnelsSet}addEnvironmentTunnels(e){if(e)for(const t of e){const r=f(this._candidates??new Map,t.remoteAddress.host,t.remoteAddress.port),o=typeof t.localAddress=="string"?t.localAddress:m(t.localAddress.host,t.localAddress.port);this.detected.set(m(t.remoteAddress.host,t.remoteAddress.port),{remoteHost:t.remoteAddress.host,remotePort:t.remoteAddress.port,localAddress:o,protocol:b.Http,localUri:this.makeLocalUri(o),closeable:!1,runningProcess:r?.detail,hasRunningProcess:!!r,pid:r?.pid,privacy:V.ConstantPrivate,source:{source:2,description:S.localize("tunnel.staticallyForwarded","Statically Forwarded")}}),this.tunnelService.setEnvironmentTunnel(t.remoteAddress.host,t.remoteAddress.port,o,V.ConstantPrivate,b.Http)}this._environmentTunnelsSet=!0,this._onEnvironmentTunnelsSet.fire(),this._onForwardPort.fire()}setCandidateFilter(e){this._candidateFilter=e}async setCandidates(e){let t=e;this._candidateFilter&&(t=await this._candidateFilter(e));const r=this.updateInResponseToCandidates(t);this.logService.trace(`ForwardedPorts: (TunnelModel) removed candidates ${Array.from(r.values()).map(o=>o.port).join(", ")}`),this._onCandidatesChanged.fire(r)}updateInResponseToCandidates(e){const t=this._candidates??new Map,r=new Map;return this._candidates=r,e.forEach(o=>{const n=m(o.host,o.port);r.set(n,{host:o.host,port:o.port,detail:o.detail,pid:o.pid}),t.has(n)&&t.delete(n);const i=f(this.forwarded,o.host,o.port);i&&(i.runningProcess=o.detail,i.hasRunningProcess=!0,i.pid=o.pid)}),t.forEach((o,n)=>{const i=pe(n);if(!i)return;const u=f(this.forwarded,i.host,i.port);u&&(u.runningProcess=void 0,u.hasRunningProcess=!1,u.pid=void 0);const h=f(this.detected,i.host,i.port);h&&(h.runningProcess=void 0,h.hasRunningProcess=!1,h.pid=void 0)}),t}get candidates(){return this._candidates?Array.from(this._candidates.values()):[]}get candidatesOrUndefined(){return this._candidates?this.candidates:void 0}async updateAttributes(){const e=Array.from(this.forwarded.values()),t=await this.getAttributes(e.map(r=>({port:r.remotePort,host:r.remoteHost})),!1);if(t)for(const r of e){const o=t.get(r.remotePort);(o?.protocol||r.protocol!==b.Http)&&o?.protocol!==r.protocol&&await this.doForward({remote:{host:r.remoteHost,port:r.remotePort},local:r.localPort,name:r.name,source:r.source},o),o&&o.label&&o.label!==r.name&&await this.name(r.remoteHost,r.remotePort,o.label)}}async getAttributes(e,t=!0){const r=new Map,o=new Map;e.forEach(s=>{const d=f(this._candidates??new Map,U[0],s.port)??s;if(d){r.set(s.port,d);const a=ge(d)?d.pid:void 0;o.has(a)||o.set(a,[]),o.get(a)?.push(s.port)}});const n=new Map;if(e.forEach(s=>{const d=this.configPortsAttributes.getAttributes(s.port,s.host,r.get(s.port)?.detail);d&&n.set(s.port,d)}),this.portAttributesProviders.length===0||!t)return n.size>0?n:void 0;const i=await Promise.all(this.portAttributesProviders.flatMap(s=>Array.from(o.entries()).map(d=>{const a=d[1],g=r.get(a[0]);return s.providePortAttributes(a,g?.pid,g?.detail,se.None)}))),u=new Map;if(i.forEach(s=>s.forEach(d=>{d&&u.set(d.port,d)})),!n&&!u)return;const h=new Map;return e.forEach(s=>{const d=n.get(s.port),a=u.get(s.port);h.set(s.port,{elevateIfNeeded:d?.elevateIfNeeded,label:d?.label,onAutoForward:d?.onAutoForward??P.providedActionToAction(a?.autoForwardAction),requireLocalPort:d?.requireLocalPort,protocol:d?.protocol})}),h}addAttributesProvider(e){this.portAttributesProviders.push(e)}};I([G(1e3)],T.prototype,"storeForwarded",1),T=I([A(0,te),A(1,ee),A(2,J),A(3,ne),A(4,Y),A(5,oe),A(6,Q),A(7,Z),A(8,ie),A(9,de)],T);export{$ as ACTIVATION_EVENT,We as AutoTunnelSource,me as OnPortForward,P as PortsAttributes,he as TunnelCloseReason,T as TunnelModel,fe as TunnelSource,_ as UserTunnelSource,$e as forwardedPortsFeaturesEnabled,le as forwardedPortsViewEnabled,ge as isCandidatePort,m as makeAddress,W as mapHasAddress,f as mapHasAddressLocalhostOrAllInterfaces,pe as parseAddress};
