{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/history/browser/historyService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { localize } from '../../../../nls.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IResourceEditorInput, IEditorOptions } from '../../../../platform/editor/common/editor.js';\nimport { IEditorPane, IEditorCloseEvent, EditorResourceAccessor, IEditorIdentifier, GroupIdentifier, EditorsOrder, SideBySideEditor, IUntypedEditorInput, isResourceEditorInput, isEditorInput, isSideBySideEditorInput, EditorCloseContext, IEditorPaneSelection, EditorPaneSelectionCompareResult, EditorPaneSelectionChangeReason, isEditorPaneWithSelection, IEditorPaneSelectionChangeEvent, IEditorPaneWithSelection, IEditorWillMoveEvent, GroupModelChangeKind } from '../../../common/editor.js';\nimport { EditorInput } from '../../../common/editor/editorInput.js';\nimport { IEditorService } from '../../editor/common/editorService.js';\nimport { GoFilter, GoScope, IHistoryService } from '../common/history.js';\nimport { FileChangesEvent, IFileService, FileChangeType, FILES_EXCLUDE_CONFIG, FileOperationEvent, FileOperation } from '../../../../platform/files/common/files.js';\nimport { IWorkspaceContextService } from '../../../../platform/workspace/common/workspace.js';\nimport { dispose, Disposable, DisposableStore, IDisposable } from '../../../../base/common/lifecycle.js';\nimport { IStorageService, StorageScope, StorageTarget } from '../../../../platform/storage/common/storage.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { IEditorGroup, IEditorGroupsService } from '../../editor/common/editorGroupsService.js';\nimport { getExcludes, ISearchConfiguration, SEARCH_EXCLUDE_CONFIG } from '../../search/common/search.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { EditorServiceImpl } from '../../../browser/parts/editor/editor.js';\nimport { IWorkbenchLayoutService } from '../../layout/browser/layoutService.js';\nimport { IContextKeyService, RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\nimport { coalesce, remove } from '../../../../base/common/arrays.js';\nimport { InstantiationType, registerSingleton } from '../../../../platform/instantiation/common/extensions.js';\nimport { addDisposableListener, EventType, EventHelper, WindowIdleValue } from '../../../../base/browser/dom.js';\nimport { IWorkspacesService } from '../../../../platform/workspaces/common/workspaces.js';\nimport { Schemas } from '../../../../base/common/network.js';\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\nimport { ResourceGlobMatcher } from '../../../common/resources.js';\nimport { IPathService } from '../../path/common/pathService.js';\nimport { IUriIdentityService } from '../../../../platform/uriIdentity/common/uriIdentity.js';\nimport { ILifecycleService, LifecyclePhase } from '../../lifecycle/common/lifecycle.js';\nimport { ILogService, LogLevel } from '../../../../platform/log/common/log.js';\nimport { mainWindow } from '../../../../base/browser/window.js';\n\ninterface ISerializedEditorHistoryEntry {\n\treadonly editor: Omit<IResourceEditorInput, 'resource'> & { resource: string };\n}\n\ninterface IRecentlyClosedEditor {\n\treadonly editorId: string | undefined;\n\treadonly editor: IUntypedEditorInput;\n\n\treadonly resource: URI | undefined;\n\treadonly associatedResources: URI[];\n\n\treadonly index: number;\n\treadonly sticky: boolean;\n}\n\nexport class HistoryService extends Disposable implements IHistoryService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate static readonly MOUSE_NAVIGATION_SETTING = 'workbench.editor.mouseBackForwardToNavigate';\n\tprivate static readonly NAVIGATION_SCOPE_SETTING = 'workbench.editor.navigationScope';\n\n\tprivate readonly activeEditorListeners = this._register(new DisposableStore());\n\tprivate lastActiveEditor: IEditorIdentifier | undefined = undefined;\n\n\tprivate readonly editorHelper = this.instantiationService.createInstance(EditorHelper);\n\n\tconstructor(\n\t\t@IEditorService private readonly editorService: EditorServiceImpl,\n\t\t@IEditorGroupsService private readonly editorGroupService: IEditorGroupsService,\n\t\t@IWorkspaceContextService private readonly contextService: IWorkspaceContextService,\n\t\t@IStorageService private readonly storageService: IStorageService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t\t@IFileService private readonly fileService: IFileService,\n\t\t@IWorkspacesService private readonly workspacesService: IWorkspacesService,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService,\n\t\t@IWorkbenchLayoutService private readonly layoutService: IWorkbenchLayoutService,\n\t\t@IContextKeyService private readonly contextKeyService: IContextKeyService,\n\t\t@ILogService private readonly logService: ILogService\n\t) {\n\t\tsuper();\n\n\t\tthis.registerListeners();\n\n\t\t// if the service is created late enough that an editor is already opened\n\t\t// make sure to trigger the onActiveEditorChanged() to track the editor\n\t\t// properly (fixes https://github.com/microsoft/vscode/issues/59908)\n\t\tif (this.editorService.activeEditorPane) {\n\t\t\tthis.onDidActiveEditorChange();\n\t\t}\n\t}\n\n\tprivate registerListeners(): void {\n\n\t\t// Mouse back/forward support\n\t\tthis.registerMouseNavigationListener();\n\n\t\t// Editor changes\n\t\tthis._register(this.editorService.onDidActiveEditorChange(() => this.onDidActiveEditorChange()));\n\t\tthis._register(this.editorService.onDidOpenEditorFail(event => this.remove(event.editor)));\n\t\tthis._register(this.editorService.onDidCloseEditor(event => this.onDidCloseEditor(event)));\n\t\tthis._register(this.editorService.onDidMostRecentlyActiveEditorsChange(() => this.handleEditorEventInRecentEditorsStack()));\n\n\t\t// Editor group changes\n\t\tthis._register(this.editorGroupService.onDidRemoveGroup(e => this.onDidRemoveGroup(e)));\n\n\t\t// File changes\n\t\tthis._register(this.fileService.onDidFilesChange(event => this.onDidFilesChange(event)));\n\t\tthis._register(this.fileService.onDidRunOperation(event => this.onDidFilesChange(event)));\n\n\t\t// Storage\n\t\tthis._register(this.storageService.onWillSaveState(() => this.saveState()));\n\n\t\t// Configuration\n\t\tthis.registerEditorNavigationScopeChangeListener();\n\n\t\t// Context keys\n\t\tthis._register(this.onDidChangeEditorNavigationStack(() => this.updateContextKeys()));\n\t\tthis._register(this.editorGroupService.onDidChangeActiveGroup(() => this.updateContextKeys()));\n\t}\n\n\tprivate onDidCloseEditor(e: IEditorCloseEvent): void {\n\t\tthis.handleEditorCloseEventInHistory(e);\n\t\tthis.handleEditorCloseEventInReopen(e);\n\t}\n\n\tprivate registerMouseNavigationListener(): void {\n\t\tconst mouseBackForwardSupportListener = this._register(new DisposableStore());\n\t\tconst handleMouseBackForwardSupport = () => {\n\t\t\tmouseBackForwardSupportListener.clear();\n\n\t\t\tif (this.configurationService.getValue(HistoryService.MOUSE_NAVIGATION_SETTING)) {\n\t\t\t\tthis._register(Event.runAndSubscribe(this.layoutService.onDidAddContainer, ({ container, disposables }) => {\n\t\t\t\t\tconst eventDisposables = disposables.add(new DisposableStore());\n\t\t\t\t\teventDisposables.add(addDisposableListener(container, EventType.MOUSE_DOWN, e => this.onMouseDownOrUp(e, true)));\n\t\t\t\t\teventDisposables.add(addDisposableListener(container, EventType.MOUSE_UP, e => this.onMouseDownOrUp(e, false)));\n\n\t\t\t\t\tmouseBackForwardSupportListener.add(eventDisposables);\n\t\t\t\t}, { container: this.layoutService.mainContainer, disposables: this._store }));\n\t\t\t}\n\t\t};\n\n\t\tthis._register(this.configurationService.onDidChangeConfiguration(event => {\n\t\t\tif (event.affectsConfiguration(HistoryService.MOUSE_NAVIGATION_SETTING)) {\n\t\t\t\thandleMouseBackForwardSupport();\n\t\t\t}\n\t\t}));\n\n\t\thandleMouseBackForwardSupport();\n\t}\n\n\tprivate onMouseDownOrUp(event: MouseEvent, isMouseDown: boolean): void {\n\n\t\t// Support to navigate in history when mouse buttons 4/5 are pressed\n\t\t// We want to trigger this on mouse down for a faster experience\n\t\t// but we also need to prevent mouse up from triggering the default\n\t\t// which is to navigate in the browser history.\n\n\t\tswitch (event.button) {\n\t\t\tcase 3:\n\t\t\t\tEventHelper.stop(event);\n\t\t\t\tif (isMouseDown) {\n\t\t\t\t\tthis.goBack();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tEventHelper.stop(event);\n\t\t\t\tif (isMouseDown) {\n\t\t\t\t\tthis.goForward();\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tprivate onDidRemoveGroup(group: IEditorGroup): void {\n\t\tthis.handleEditorGroupRemoveInNavigationStacks(group);\n\t}\n\n\tprivate onDidActiveEditorChange(): void {\n\t\tconst activeEditorGroup = this.editorGroupService.activeGroup;\n\t\tconst activeEditorPane = activeEditorGroup.activeEditorPane;\n\n\t\tif (this.lastActiveEditor && this.editorHelper.matchesEditorIdentifier(this.lastActiveEditor, activeEditorPane)) {\n\t\t\treturn; // return if the active editor is still the same\n\t\t}\n\n\t\t// Remember as last active editor (can be undefined if none opened)\n\t\tthis.lastActiveEditor = activeEditorPane?.input ? { editor: activeEditorPane.input, groupId: activeEditorPane.group.id } : undefined;\n\n\t\t// Dispose old listeners\n\t\tthis.activeEditorListeners.clear();\n\n\t\t// Handle editor change unless the editor is transient. In that case\n\t\t// setup a listener to see if the transient editor becomes non-transient\n\t\t// (https://github.com/microsoft/vscode/issues/211769)\n\t\tif (!activeEditorPane?.group.isTransient(activeEditorPane.input)) {\n\t\t\tthis.handleActiveEditorChange(activeEditorGroup, activeEditorPane);\n\t\t} else {\n\t\t\tthis.logService.trace(`[History]: ignoring transient editor change until becoming non-transient (editor: ${activeEditorPane.input?.resource?.toString()}})`);\n\n\t\t\tconst transientListener = activeEditorGroup.onDidModelChange(e => {\n\t\t\t\tif (e.kind === GroupModelChangeKind.EDITOR_TRANSIENT && e.editor === activeEditorPane.input && !activeEditorPane.group.isTransient(activeEditorPane.input)) {\n\t\t\t\t\ttransientListener.dispose();\n\n\t\t\t\t\tthis.handleActiveEditorChange(activeEditorGroup, activeEditorPane);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis.activeEditorListeners.add(transientListener);\n\t\t}\n\n\t\t// Listen to selection changes unless the editor is transient\n\t\tif (isEditorPaneWithSelection(activeEditorPane)) {\n\t\t\tthis.activeEditorListeners.add(activeEditorPane.onDidChangeSelection(e => {\n\t\t\t\tif (!activeEditorPane.group.isTransient(activeEditorPane.input)) {\n\t\t\t\t\tthis.handleActiveEditorSelectionChangeEvent(activeEditorGroup, activeEditorPane, e);\n\t\t\t\t} else {\n\t\t\t\t\tthis.logService.trace(`[History]: ignoring transient editor selection change (editor: ${activeEditorPane.input?.resource?.toString()}})`);\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\n\t\t// Context keys\n\t\tthis.updateContextKeys();\n\t}\n\n\tprivate onDidFilesChange(event: FileChangesEvent | FileOperationEvent): void {\n\n\t\t// External file changes (watcher)\n\t\tif (event instanceof FileChangesEvent) {\n\t\t\tif (event.gotDeleted()) {\n\t\t\t\tthis.remove(event);\n\t\t\t}\n\t\t}\n\n\t\t// Internal file changes (e.g. explorer)\n\t\telse {\n\n\t\t\t// Delete\n\t\t\tif (event.isOperation(FileOperation.DELETE)) {\n\t\t\t\tthis.remove(event);\n\t\t\t}\n\n\t\t\t// Move\n\t\t\telse if (event.isOperation(FileOperation.MOVE) && event.target.isFile) {\n\t\t\t\tthis.move(event);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate handleActiveEditorChange(group: IEditorGroup, editorPane?: IEditorPane): void {\n\t\tthis.handleActiveEditorChangeInHistory(editorPane);\n\t\tthis.handleActiveEditorChangeInNavigationStacks(group, editorPane);\n\t}\n\n\tprivate handleActiveEditorSelectionChangeEvent(group: IEditorGroup, editorPane: IEditorPaneWithSelection, event: IEditorPaneSelectionChangeEvent): void {\n\t\tthis.handleActiveEditorSelectionChangeInNavigationStacks(group, editorPane, event);\n\t}\n\n\tprivate move(event: FileOperationEvent): void {\n\t\tthis.moveInHistory(event);\n\t\tthis.moveInEditorNavigationStacks(event);\n\t}\n\n\tprivate remove(editor: EditorInput): void;\n\tprivate remove(event: FileChangesEvent): void;\n\tprivate remove(event: FileOperationEvent): void;\n\tprivate remove(arg1: EditorInput | FileChangesEvent | FileOperationEvent): void {\n\t\tthis.removeFromHistory(arg1);\n\t\tthis.removeFromEditorNavigationStacks(arg1);\n\t\tthis.removeFromRecentlyClosedEditors(arg1);\n\t\tthis.removeFromRecentlyOpened(arg1);\n\t}\n\n\tprivate removeFromRecentlyOpened(arg1: EditorInput | FileChangesEvent | FileOperationEvent): void {\n\t\tlet resource: URI | undefined = undefined;\n\t\tif (isEditorInput(arg1)) {\n\t\t\tresource = EditorResourceAccessor.getOriginalUri(arg1);\n\t\t} else if (arg1 instanceof FileChangesEvent) {\n\t\t\t// Ignore for now (recently opened are most often out of workspace files anyway for which there are no file events)\n\t\t} else {\n\t\t\tresource = arg1.resource;\n\t\t}\n\n\t\tif (resource) {\n\t\t\tthis.workspacesService.removeRecentlyOpened([resource]);\n\t\t}\n\t}\n\n\tclear(): void {\n\n\t\t// History\n\t\tthis.clearRecentlyOpened();\n\n\t\t// Navigation (next, previous)\n\t\tthis.clearEditorNavigationStacks();\n\n\t\t// Recently closed editors\n\t\tthis.recentlyClosedEditors = [];\n\n\t\t// Context Keys\n\t\tthis.updateContextKeys();\n\t}\n\n\t//#region History Context Keys\n\n\tprivate readonly canNavigateBackContextKey = (new RawContextKey<boolean>('canNavigateBack', false, localize('canNavigateBack', \"Whether it is possible to navigate back in editor history\"))).bindTo(this.contextKeyService);\n\tprivate readonly canNavigateForwardContextKey = (new RawContextKey<boolean>('canNavigateForward', false, localize('canNavigateForward', \"Whether it is possible to navigate forward in editor history\"))).bindTo(this.contextKeyService);\n\n\tprivate readonly canNavigateBackInNavigationsContextKey = (new RawContextKey<boolean>('canNavigateBackInNavigationLocations', false, localize('canNavigateBackInNavigationLocations', \"Whether it is possible to navigate back in editor navigation locations history\"))).bindTo(this.contextKeyService);\n\tprivate readonly canNavigateForwardInNavigationsContextKey = (new RawContextKey<boolean>('canNavigateForwardInNavigationLocations', false, localize('canNavigateForwardInNavigationLocations', \"Whether it is possible to navigate forward in editor navigation locations history\"))).bindTo(this.contextKeyService);\n\tprivate readonly canNavigateToLastNavigationLocationContextKey = (new RawContextKey<boolean>('canNavigateToLastNavigationLocation', false, localize('canNavigateToLastNavigationLocation', \"Whether it is possible to navigate to the last editor navigation location\"))).bindTo(this.contextKeyService);\n\n\tprivate readonly canNavigateBackInEditsContextKey = (new RawContextKey<boolean>('canNavigateBackInEditLocations', false, localize('canNavigateBackInEditLocations', \"Whether it is possible to navigate back in editor edit locations history\"))).bindTo(this.contextKeyService);\n\tprivate readonly canNavigateForwardInEditsContextKey = (new RawContextKey<boolean>('canNavigateForwardInEditLocations', false, localize('canNavigateForwardInEditLocations', \"Whether it is possible to navigate forward in editor edit locations history\"))).bindTo(this.contextKeyService);\n\tprivate readonly canNavigateToLastEditLocationContextKey = (new RawContextKey<boolean>('canNavigateToLastEditLocation', false, localize('canNavigateToLastEditLocation', \"Whether it is possible to navigate to the last editor edit location\"))).bindTo(this.contextKeyService);\n\n\tprivate readonly canReopenClosedEditorContextKey = (new RawContextKey<boolean>('canReopenClosedEditor', false, localize('canReopenClosedEditor', \"Whether it is possible to reopen the last closed editor\"))).bindTo(this.contextKeyService);\n\n\tupdateContextKeys(): void {\n\t\tthis.contextKeyService.bufferChangeEvents(() => {\n\t\t\tconst activeStack = this.getStack();\n\n\t\t\tthis.canNavigateBackContextKey.set(activeStack.canGoBack(GoFilter.NONE));\n\t\t\tthis.canNavigateForwardContextKey.set(activeStack.canGoForward(GoFilter.NONE));\n\n\t\t\tthis.canNavigateBackInNavigationsContextKey.set(activeStack.canGoBack(GoFilter.NAVIGATION));\n\t\t\tthis.canNavigateForwardInNavigationsContextKey.set(activeStack.canGoForward(GoFilter.NAVIGATION));\n\t\t\tthis.canNavigateToLastNavigationLocationContextKey.set(activeStack.canGoLast(GoFilter.NAVIGATION));\n\n\t\t\tthis.canNavigateBackInEditsContextKey.set(activeStack.canGoBack(GoFilter.EDITS));\n\t\t\tthis.canNavigateForwardInEditsContextKey.set(activeStack.canGoForward(GoFilter.EDITS));\n\t\t\tthis.canNavigateToLastEditLocationContextKey.set(activeStack.canGoLast(GoFilter.EDITS));\n\n\t\t\tthis.canReopenClosedEditorContextKey.set(this.recentlyClosedEditors.length > 0);\n\t\t});\n\t}\n\n\t//#endregion\n\n\t//#region Editor History Navigation (limit: 50)\n\n\tprivate readonly _onDidChangeEditorNavigationStack = this._register(new Emitter<void>());\n\treadonly onDidChangeEditorNavigationStack = this._onDidChangeEditorNavigationStack.event;\n\n\tprivate defaultScopedEditorNavigationStack: IEditorNavigationStacks | undefined = undefined;\n\tprivate readonly editorGroupScopedNavigationStacks = new Map<GroupIdentifier, { stack: IEditorNavigationStacks; disposable: IDisposable }>();\n\tprivate readonly editorScopedNavigationStacks = new Map<GroupIdentifier, Map<EditorInput, { stack: IEditorNavigationStacks; disposable: IDisposable }>>();\n\n\tprivate editorNavigationScope = GoScope.DEFAULT;\n\n\tprivate registerEditorNavigationScopeChangeListener(): void {\n\t\tconst handleEditorNavigationScopeChange = () => {\n\n\t\t\t// Ensure to start fresh when setting changes\n\t\t\tthis.disposeEditorNavigationStacks();\n\n\t\t\t// Update scope\n\t\t\tconst configuredScope = this.configurationService.getValue(HistoryService.NAVIGATION_SCOPE_SETTING);\n\t\t\tif (configuredScope === 'editorGroup') {\n\t\t\t\tthis.editorNavigationScope = GoScope.EDITOR_GROUP;\n\t\t\t} else if (configuredScope === 'editor') {\n\t\t\t\tthis.editorNavigationScope = GoScope.EDITOR;\n\t\t\t} else {\n\t\t\t\tthis.editorNavigationScope = GoScope.DEFAULT;\n\t\t\t}\n\t\t};\n\n\t\tthis._register(this.configurationService.onDidChangeConfiguration(event => {\n\t\t\tif (event.affectsConfiguration(HistoryService.NAVIGATION_SCOPE_SETTING)) {\n\t\t\t\thandleEditorNavigationScopeChange();\n\t\t\t}\n\t\t}));\n\n\t\thandleEditorNavigationScopeChange();\n\t}\n\n\tprivate getStack(group = this.editorGroupService.activeGroup, editor = group.activeEditor): IEditorNavigationStacks {\n\t\tswitch (this.editorNavigationScope) {\n\n\t\t\t// Per Editor\n\t\t\tcase GoScope.EDITOR: {\n\t\t\t\tif (!editor) {\n\t\t\t\t\treturn new NoOpEditorNavigationStacks();\n\t\t\t\t}\n\n\t\t\t\tlet stacksForGroup = this.editorScopedNavigationStacks.get(group.id);\n\t\t\t\tif (!stacksForGroup) {\n\t\t\t\t\tstacksForGroup = new Map<EditorInput, { stack: IEditorNavigationStacks; disposable: IDisposable }>();\n\t\t\t\t\tthis.editorScopedNavigationStacks.set(group.id, stacksForGroup);\n\t\t\t\t}\n\n\t\t\t\tlet stack = stacksForGroup.get(editor)?.stack;\n\t\t\t\tif (!stack) {\n\t\t\t\t\tconst disposable = new DisposableStore();\n\n\t\t\t\t\tstack = disposable.add(this.instantiationService.createInstance(EditorNavigationStacks, GoScope.EDITOR));\n\t\t\t\t\tdisposable.add(stack.onDidChange(() => this._onDidChangeEditorNavigationStack.fire()));\n\n\t\t\t\t\tstacksForGroup.set(editor, { stack, disposable });\n\t\t\t\t}\n\n\t\t\t\treturn stack;\n\t\t\t}\n\n\t\t\t// Per Editor Group\n\t\t\tcase GoScope.EDITOR_GROUP: {\n\t\t\t\tlet stack = this.editorGroupScopedNavigationStacks.get(group.id)?.stack;\n\t\t\t\tif (!stack) {\n\t\t\t\t\tconst disposable = new DisposableStore();\n\n\t\t\t\t\tstack = disposable.add(this.instantiationService.createInstance(EditorNavigationStacks, GoScope.EDITOR_GROUP));\n\t\t\t\t\tdisposable.add(stack.onDidChange(() => this._onDidChangeEditorNavigationStack.fire()));\n\n\t\t\t\t\tthis.editorGroupScopedNavigationStacks.set(group.id, { stack, disposable });\n\t\t\t\t}\n\n\t\t\t\treturn stack;\n\t\t\t}\n\n\t\t\t// Global\n\t\t\tcase GoScope.DEFAULT: {\n\t\t\t\tif (!this.defaultScopedEditorNavigationStack) {\n\t\t\t\t\tthis.defaultScopedEditorNavigationStack = this._register(this.instantiationService.createInstance(EditorNavigationStacks, GoScope.DEFAULT));\n\n\t\t\t\t\tthis._register(this.defaultScopedEditorNavigationStack.onDidChange(() => this._onDidChangeEditorNavigationStack.fire()));\n\t\t\t\t}\n\n\t\t\t\treturn this.defaultScopedEditorNavigationStack;\n\t\t\t}\n\t\t}\n\t}\n\n\tgoForward(filter?: GoFilter): Promise<void> {\n\t\treturn this.getStack().goForward(filter);\n\t}\n\n\tgoBack(filter?: GoFilter): Promise<void> {\n\t\treturn this.getStack().goBack(filter);\n\t}\n\n\tgoPrevious(filter?: GoFilter): Promise<void> {\n\t\treturn this.getStack().goPrevious(filter);\n\t}\n\n\tgoLast(filter?: GoFilter): Promise<void> {\n\t\treturn this.getStack().goLast(filter);\n\t}\n\n\tprivate handleActiveEditorChangeInNavigationStacks(group: IEditorGroup, editorPane?: IEditorPane): void {\n\t\tthis.getStack(group, editorPane?.input).handleActiveEditorChange(editorPane);\n\t}\n\n\tprivate handleActiveEditorSelectionChangeInNavigationStacks(group: IEditorGroup, editorPane: IEditorPaneWithSelection, event: IEditorPaneSelectionChangeEvent): void {\n\t\tthis.getStack(group, editorPane.input).handleActiveEditorSelectionChange(editorPane, event);\n\t}\n\n\tprivate handleEditorCloseEventInHistory(e: IEditorCloseEvent): void {\n\t\tconst editors = this.editorScopedNavigationStacks.get(e.groupId);\n\t\tif (editors) {\n\t\t\tconst editorStack = editors.get(e.editor);\n\t\t\tif (editorStack) {\n\t\t\t\teditorStack.disposable.dispose();\n\t\t\t\teditors.delete(e.editor);\n\t\t\t}\n\n\t\t\tif (editors.size === 0) {\n\t\t\t\tthis.editorScopedNavigationStacks.delete(e.groupId);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate handleEditorGroupRemoveInNavigationStacks(group: IEditorGroup): void {\n\n\t\t// Global\n\t\tthis.defaultScopedEditorNavigationStack?.remove(group.id);\n\n\t\t// Editor groups\n\t\tconst editorGroupStack = this.editorGroupScopedNavigationStacks.get(group.id);\n\t\tif (editorGroupStack) {\n\t\t\teditorGroupStack.disposable.dispose();\n\t\t\tthis.editorGroupScopedNavigationStacks.delete(group.id);\n\t\t}\n\t}\n\n\tprivate clearEditorNavigationStacks(): void {\n\t\tthis.withEachEditorNavigationStack(stack => stack.clear());\n\t}\n\n\tprivate removeFromEditorNavigationStacks(arg1: EditorInput | FileChangesEvent | FileOperationEvent): void {\n\t\tthis.withEachEditorNavigationStack(stack => stack.remove(arg1));\n\t}\n\n\tprivate moveInEditorNavigationStacks(event: FileOperationEvent): void {\n\t\tthis.withEachEditorNavigationStack(stack => stack.move(event));\n\t}\n\n\tprivate withEachEditorNavigationStack(fn: (stack: IEditorNavigationStacks) => void): void {\n\n\t\t// Global\n\t\tif (this.defaultScopedEditorNavigationStack) {\n\t\t\tfn(this.defaultScopedEditorNavigationStack);\n\t\t}\n\n\t\t// Per editor group\n\t\tfor (const [, entry] of this.editorGroupScopedNavigationStacks) {\n\t\t\tfn(entry.stack);\n\t\t}\n\n\t\t// Per editor\n\t\tfor (const [, entries] of this.editorScopedNavigationStacks) {\n\t\t\tfor (const [, entry] of entries) {\n\t\t\t\tfn(entry.stack);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate disposeEditorNavigationStacks(): void {\n\n\t\t// Global\n\t\tthis.defaultScopedEditorNavigationStack?.dispose();\n\t\tthis.defaultScopedEditorNavigationStack = undefined;\n\n\t\t// Per Editor group\n\t\tfor (const [, stack] of this.editorGroupScopedNavigationStacks) {\n\t\t\tstack.disposable.dispose();\n\t\t}\n\t\tthis.editorGroupScopedNavigationStacks.clear();\n\n\t\t// Per Editor\n\t\tfor (const [, stacks] of this.editorScopedNavigationStacks) {\n\t\t\tfor (const [, stack] of stacks) {\n\t\t\t\tstack.disposable.dispose();\n\t\t\t}\n\t\t}\n\t\tthis.editorScopedNavigationStacks.clear();\n\t}\n\n\t//#endregion\n\n\t//#region Navigation: Next/Previous Used Editor\n\n\tprivate recentlyUsedEditorsStack: readonly IEditorIdentifier[] | undefined = undefined;\n\tprivate recentlyUsedEditorsStackIndex = 0;\n\n\tprivate recentlyUsedEditorsInGroupStack: readonly IEditorIdentifier[] | undefined = undefined;\n\tprivate recentlyUsedEditorsInGroupStackIndex = 0;\n\n\tprivate navigatingInRecentlyUsedEditorsStack = false;\n\tprivate navigatingInRecentlyUsedEditorsInGroupStack = false;\n\n\topenNextRecentlyUsedEditor(groupId?: GroupIdentifier): Promise<void> {\n\t\tconst [stack, index] = this.ensureRecentlyUsedStack(index => index - 1, groupId);\n\n\t\treturn this.doNavigateInRecentlyUsedEditorsStack(stack[index], groupId);\n\t}\n\n\topenPreviouslyUsedEditor(groupId?: GroupIdentifier): Promise<void> {\n\t\tconst [stack, index] = this.ensureRecentlyUsedStack(index => index + 1, groupId);\n\n\t\treturn this.doNavigateInRecentlyUsedEditorsStack(stack[index], groupId);\n\t}\n\n\tprivate async doNavigateInRecentlyUsedEditorsStack(editorIdentifier: IEditorIdentifier | undefined, groupId?: GroupIdentifier): Promise<void> {\n\t\tif (editorIdentifier) {\n\t\t\tconst acrossGroups = typeof groupId !== 'number' || !this.editorGroupService.getGroup(groupId);\n\n\t\t\tif (acrossGroups) {\n\t\t\t\tthis.navigatingInRecentlyUsedEditorsStack = true;\n\t\t\t} else {\n\t\t\t\tthis.navigatingInRecentlyUsedEditorsInGroupStack = true;\n\t\t\t}\n\n\t\t\tconst group = this.editorGroupService.getGroup(editorIdentifier.groupId) ?? this.editorGroupService.activeGroup;\n\t\t\ttry {\n\t\t\t\tawait group.openEditor(editorIdentifier.editor);\n\t\t\t} finally {\n\t\t\t\tif (acrossGroups) {\n\t\t\t\t\tthis.navigatingInRecentlyUsedEditorsStack = false;\n\t\t\t\t} else {\n\t\t\t\t\tthis.navigatingInRecentlyUsedEditorsInGroupStack = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate ensureRecentlyUsedStack(indexModifier: (index: number) => number, groupId?: GroupIdentifier): [readonly IEditorIdentifier[], number] {\n\t\tlet editors: readonly IEditorIdentifier[];\n\t\tlet index: number;\n\n\t\tconst group = typeof groupId === 'number' ? this.editorGroupService.getGroup(groupId) : undefined;\n\n\t\t// Across groups\n\t\tif (!group) {\n\t\t\teditors = this.recentlyUsedEditorsStack || this.editorService.getEditors(EditorsOrder.MOST_RECENTLY_ACTIVE);\n\t\t\tindex = this.recentlyUsedEditorsStackIndex;\n\t\t}\n\n\t\t// Within group\n\t\telse {\n\t\t\teditors = this.recentlyUsedEditorsInGroupStack || group.getEditors(EditorsOrder.MOST_RECENTLY_ACTIVE).map(editor => ({ groupId: group.id, editor }));\n\t\t\tindex = this.recentlyUsedEditorsInGroupStackIndex;\n\t\t}\n\n\t\t// Adjust index\n\t\tlet newIndex = indexModifier(index);\n\t\tif (newIndex < 0) {\n\t\t\tnewIndex = 0;\n\t\t} else if (newIndex > editors.length - 1) {\n\t\t\tnewIndex = editors.length - 1;\n\t\t}\n\n\t\t// Remember index and editors\n\t\tif (!group) {\n\t\t\tthis.recentlyUsedEditorsStack = editors;\n\t\t\tthis.recentlyUsedEditorsStackIndex = newIndex;\n\t\t} else {\n\t\t\tthis.recentlyUsedEditorsInGroupStack = editors;\n\t\t\tthis.recentlyUsedEditorsInGroupStackIndex = newIndex;\n\t\t}\n\n\t\treturn [editors, newIndex];\n\t}\n\n\tprivate handleEditorEventInRecentEditorsStack(): void {\n\n\t\t// Drop all-editors stack unless navigating in all editors\n\t\tif (!this.navigatingInRecentlyUsedEditorsStack) {\n\t\t\tthis.recentlyUsedEditorsStack = undefined;\n\t\t\tthis.recentlyUsedEditorsStackIndex = 0;\n\t\t}\n\n\t\t// Drop in-group-editors stack unless navigating in group\n\t\tif (!this.navigatingInRecentlyUsedEditorsInGroupStack) {\n\t\t\tthis.recentlyUsedEditorsInGroupStack = undefined;\n\t\t\tthis.recentlyUsedEditorsInGroupStackIndex = 0;\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region File: Reopen Closed Editor (limit: 20)\n\n\tprivate static readonly MAX_RECENTLY_CLOSED_EDITORS = 20;\n\n\tprivate recentlyClosedEditors: IRecentlyClosedEditor[] = [];\n\tprivate ignoreEditorCloseEvent = false;\n\n\tprivate handleEditorCloseEventInReopen(event: IEditorCloseEvent): void {\n\t\tif (this.ignoreEditorCloseEvent) {\n\t\t\treturn; // blocked\n\t\t}\n\n\t\tconst { editor, context } = event;\n\t\tif (context === EditorCloseContext.REPLACE || context === EditorCloseContext.MOVE) {\n\t\t\treturn; // ignore if editor was replaced or moved\n\t\t}\n\n\t\tconst untypedEditor = editor.toUntyped();\n\t\tif (!untypedEditor) {\n\t\t\treturn; // we need a untyped editor to restore from going forward\n\t\t}\n\n\t\tconst associatedResources: URI[] = [];\n\t\tconst editorResource = EditorResourceAccessor.getOriginalUri(editor, { supportSideBySide: SideBySideEditor.BOTH });\n\t\tif (URI.isUri(editorResource)) {\n\t\t\tassociatedResources.push(editorResource);\n\t\t} else if (editorResource) {\n\t\t\tassociatedResources.push(...coalesce([editorResource.primary, editorResource.secondary]));\n\t\t}\n\n\t\t// Remove from list of recently closed before...\n\t\tthis.removeFromRecentlyClosedEditors(editor);\n\n\t\t// ...adding it as last recently closed\n\t\tthis.recentlyClosedEditors.push({\n\t\t\teditorId: editor.editorId,\n\t\t\teditor: untypedEditor,\n\t\t\tresource: EditorResourceAccessor.getOriginalUri(editor),\n\t\t\tassociatedResources,\n\t\t\tindex: event.index,\n\t\t\tsticky: event.sticky\n\t\t});\n\n\t\t// Bounding\n\t\tif (this.recentlyClosedEditors.length > HistoryService.MAX_RECENTLY_CLOSED_EDITORS) {\n\t\t\tthis.recentlyClosedEditors.shift();\n\t\t}\n\n\t\t// Context\n\t\tthis.canReopenClosedEditorContextKey.set(true);\n\t}\n\n\tasync reopenLastClosedEditor(): Promise<void> {\n\n\t\t// Open editor if we have one\n\t\tconst lastClosedEditor = this.recentlyClosedEditors.pop();\n\t\tlet reopenClosedEditorPromise: Promise<void> | undefined = undefined;\n\t\tif (lastClosedEditor) {\n\t\t\treopenClosedEditorPromise = this.doReopenLastClosedEditor(lastClosedEditor);\n\t\t}\n\n\t\t// Update context\n\t\tthis.canReopenClosedEditorContextKey.set(this.recentlyClosedEditors.length > 0);\n\n\t\treturn reopenClosedEditorPromise;\n\t}\n\n\tprivate async doReopenLastClosedEditor(lastClosedEditor: IRecentlyClosedEditor): Promise<void> {\n\t\tconst options: IEditorOptions = { pinned: true, sticky: lastClosedEditor.sticky, index: lastClosedEditor.index, ignoreError: true };\n\n\t\t// Special sticky handling: remove the index property from options\n\t\t// if that would result in sticky state to not preserve or apply\n\t\t// wrongly.\n\t\tif (\n\t\t\t(lastClosedEditor.sticky && !this.editorGroupService.activeGroup.isSticky(lastClosedEditor.index)) ||\n\t\t\t(!lastClosedEditor.sticky && this.editorGroupService.activeGroup.isSticky(lastClosedEditor.index))\n\t\t) {\n\t\t\toptions.index = undefined;\n\t\t}\n\n\t\t// Re-open editor unless already opened\n\t\tlet editorPane: IEditorPane | undefined = undefined;\n\t\tif (!this.editorGroupService.activeGroup.contains(lastClosedEditor.editor)) {\n\n\t\t\t// Fix for https://github.com/microsoft/vscode/issues/107850\n\t\t\t// If opening an editor fails, it is possible that we get\n\t\t\t// another editor-close event as a result. But we really do\n\t\t\t// want to ignore that in our list of recently closed editors\n\t\t\t//  to prevent endless loops.\n\n\t\t\tthis.ignoreEditorCloseEvent = true;\n\t\t\ttry {\n\t\t\t\teditorPane = await this.editorService.openEditor({\n\t\t\t\t\t...lastClosedEditor.editor,\n\t\t\t\t\toptions: {\n\t\t\t\t\t\t...lastClosedEditor.editor.options,\n\t\t\t\t\t\t...options\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} finally {\n\t\t\t\tthis.ignoreEditorCloseEvent = false;\n\t\t\t}\n\t\t}\n\n\t\t// If no editor was opened, try with the next one\n\t\tif (!editorPane) {\n\n\t\t\t// Fix for https://github.com/microsoft/vscode/issues/67882\n\t\t\t// If opening of the editor fails, make sure to try the next one\n\t\t\t// but make sure to remove this one from the list to prevent\n\t\t\t// endless loops.\n\t\t\tremove(this.recentlyClosedEditors, lastClosedEditor);\n\n\t\t\t// Try with next one\n\t\t\tthis.reopenLastClosedEditor();\n\t\t}\n\t}\n\n\tprivate removeFromRecentlyClosedEditors(arg1: EditorInput | FileChangesEvent | FileOperationEvent): void {\n\t\tthis.recentlyClosedEditors = this.recentlyClosedEditors.filter(recentlyClosedEditor => {\n\t\t\tif (isEditorInput(arg1) && recentlyClosedEditor.editorId !== arg1.editorId) {\n\t\t\t\treturn true; // keep: different editor identifiers\n\t\t\t}\n\n\t\t\tif (recentlyClosedEditor.resource && this.editorHelper.matchesFile(recentlyClosedEditor.resource, arg1)) {\n\t\t\t\treturn false; // remove: editor matches directly\n\t\t\t}\n\n\t\t\tif (recentlyClosedEditor.associatedResources.some(associatedResource => this.editorHelper.matchesFile(associatedResource, arg1))) {\n\t\t\t\treturn false; // remove: an associated resource matches\n\t\t\t}\n\n\t\t\treturn true; // keep\n\t\t});\n\n\t\t// Update context\n\t\tthis.canReopenClosedEditorContextKey.set(this.recentlyClosedEditors.length > 0);\n\t}\n\n\t//#endregion\n\n\t//#region Go to: Recently Opened Editor (limit: 200, persisted)\n\n\tprivate static readonly MAX_HISTORY_ITEMS = 200;\n\tprivate static readonly HISTORY_STORAGE_KEY = 'history.entries';\n\n\tprivate history: Array<EditorInput | IResourceEditorInput> | undefined = undefined;\n\n\tprivate readonly editorHistoryListeners = new Map<EditorInput, DisposableStore>();\n\n\tprivate readonly resourceExcludeMatcher = this._register(new WindowIdleValue(mainWindow, () => {\n\t\tconst matcher = this._register(this.instantiationService.createInstance(\n\t\t\tResourceGlobMatcher,\n\t\t\troot => getExcludes(root ? this.configurationService.getValue<ISearchConfiguration>({ resource: root }) : this.configurationService.getValue<ISearchConfiguration>()) || Object.create(null),\n\t\t\tevent => event.affectsConfiguration(FILES_EXCLUDE_CONFIG) || event.affectsConfiguration(SEARCH_EXCLUDE_CONFIG)\n\t\t));\n\n\t\tthis._register(matcher.onExpressionChange(() => this.removeExcludedFromHistory()));\n\n\t\treturn matcher;\n\t}));\n\n\tprivate handleActiveEditorChangeInHistory(editorPane?: IEditorPane): void {\n\n\t\t// Ensure we have not configured to exclude input and don't track invalid inputs\n\t\tconst editor = editorPane?.input;\n\t\tif (!editor || editor.isDisposed() || !this.includeInHistory(editor)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remove any existing entry and add to the beginning\n\t\tthis.removeFromHistory(editor);\n\t\tthis.addToHistory(editor);\n\t}\n\n\tprivate addToHistory(editor: EditorInput | IResourceEditorInput, insertFirst = true): void {\n\t\tthis.ensureHistoryLoaded(this.history);\n\n\t\tconst historyInput = this.editorHelper.preferResourceEditorInput(editor);\n\t\tif (!historyInput) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Insert based on preference\n\t\tif (insertFirst) {\n\t\t\tthis.history.unshift(historyInput);\n\t\t} else {\n\t\t\tthis.history.push(historyInput);\n\t\t}\n\n\t\t// Respect max entries setting\n\t\tif (this.history.length > HistoryService.MAX_HISTORY_ITEMS) {\n\t\t\tthis.editorHelper.clearOnEditorDispose(this.history.pop()!, this.editorHistoryListeners);\n\t\t}\n\n\t\t// React to editor input disposing\n\t\tif (isEditorInput(editor)) {\n\t\t\tthis.editorHelper.onEditorDispose(editor, () => this.updateHistoryOnEditorDispose(historyInput), this.editorHistoryListeners);\n\t\t}\n\t}\n\n\tprivate updateHistoryOnEditorDispose(editor: EditorInput | IResourceEditorInput): void {\n\t\tif (isEditorInput(editor)) {\n\n\t\t\t// Any non side-by-side editor input gets removed directly on dispose\n\t\t\tif (!isSideBySideEditorInput(editor)) {\n\t\t\t\tthis.removeFromHistory(editor);\n\t\t\t}\n\n\t\t\t// Side-by-side editors get special treatment: we try to distill the\n\t\t\t// possibly untyped resource inputs from both sides to be able to\n\t\t\t// offer these entries from the history to the user still unless\n\t\t\t// they are excluded.\n\t\t\telse {\n\t\t\t\tconst resourceInputs: IResourceEditorInput[] = [];\n\t\t\t\tconst sideInputs = editor.primary.matches(editor.secondary) ? [editor.primary] : [editor.primary, editor.secondary];\n\t\t\t\tfor (const sideInput of sideInputs) {\n\t\t\t\t\tconst candidateResourceInput = this.editorHelper.preferResourceEditorInput(sideInput);\n\t\t\t\t\tif (isResourceEditorInput(candidateResourceInput) && this.includeInHistory(candidateResourceInput)) {\n\t\t\t\t\t\tresourceInputs.push(candidateResourceInput);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Insert the untyped resource inputs where our disposed\n\t\t\t\t// side-by-side editor input is in the history stack\n\t\t\t\tthis.replaceInHistory(editor, ...resourceInputs);\n\t\t\t}\n\t\t} else {\n\n\t\t\t// Remove any editor that should not be included in history\n\t\t\tif (!this.includeInHistory(editor)) {\n\t\t\t\tthis.removeFromHistory(editor);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate includeInHistory(editor: EditorInput | IResourceEditorInput): boolean {\n\t\tif (isEditorInput(editor)) {\n\t\t\treturn true; // include any non files\n\t\t}\n\n\t\treturn !this.resourceExcludeMatcher.value.matches(editor.resource);\n\t}\n\n\tprivate removeExcludedFromHistory(): void {\n\t\tthis.ensureHistoryLoaded(this.history);\n\n\t\tthis.history = this.history.filter(entry => {\n\t\t\tconst include = this.includeInHistory(entry);\n\n\t\t\t// Cleanup any listeners associated with the input when removing from history\n\t\t\tif (!include) {\n\t\t\t\tthis.editorHelper.clearOnEditorDispose(entry, this.editorHistoryListeners);\n\t\t\t}\n\n\t\t\treturn include;\n\t\t});\n\t}\n\n\tprivate moveInHistory(event: FileOperationEvent): void {\n\t\tif (event.isOperation(FileOperation.MOVE)) {\n\t\t\tconst removed = this.removeFromHistory(event);\n\t\t\tif (removed) {\n\t\t\t\tthis.addToHistory({ resource: event.target.resource });\n\t\t\t}\n\t\t}\n\t}\n\n\tremoveFromHistory(arg1: EditorInput | IResourceEditorInput | FileChangesEvent | FileOperationEvent): boolean {\n\t\tlet removed = false;\n\n\t\tthis.ensureHistoryLoaded(this.history);\n\n\t\tthis.history = this.history.filter(entry => {\n\t\t\tconst matches = this.editorHelper.matchesEditor(arg1, entry);\n\n\t\t\t// Cleanup any listeners associated with the input when removing from history\n\t\t\tif (matches) {\n\t\t\t\tthis.editorHelper.clearOnEditorDispose(arg1, this.editorHistoryListeners);\n\t\t\t\tremoved = true;\n\t\t\t}\n\n\t\t\treturn !matches;\n\t\t});\n\n\t\treturn removed;\n\t}\n\n\tprivate replaceInHistory(editor: EditorInput | IResourceEditorInput, ...replacements: ReadonlyArray<EditorInput | IResourceEditorInput>): void {\n\t\tthis.ensureHistoryLoaded(this.history);\n\n\t\tlet replaced = false;\n\n\t\tconst newHistory: Array<EditorInput | IResourceEditorInput> = [];\n\t\tfor (const entry of this.history) {\n\n\t\t\t// Entry matches and is going to be disposed + replaced\n\t\t\tif (this.editorHelper.matchesEditor(editor, entry)) {\n\n\t\t\t\t// Cleanup any listeners associated with the input when replacing from history\n\t\t\t\tthis.editorHelper.clearOnEditorDispose(editor, this.editorHistoryListeners);\n\n\t\t\t\t// Insert replacements but only once\n\t\t\t\tif (!replaced) {\n\t\t\t\t\tnewHistory.push(...replacements);\n\t\t\t\t\treplaced = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Entry does not match, but only add it if it didn't match\n\t\t\t// our replacements already\n\t\t\telse if (!replacements.some(replacement => this.editorHelper.matchesEditor(replacement, entry))) {\n\t\t\t\tnewHistory.push(entry);\n\t\t\t}\n\t\t}\n\n\t\t// If the target editor to replace was not found, make sure to\n\t\t// insert the replacements to the end to ensure we got them\n\t\tif (!replaced) {\n\t\t\tnewHistory.push(...replacements);\n\t\t}\n\n\t\tthis.history = newHistory;\n\t}\n\n\tclearRecentlyOpened(): void {\n\t\tthis.history = [];\n\n\t\tfor (const [, disposable] of this.editorHistoryListeners) {\n\t\t\tdispose(disposable);\n\t\t}\n\t\tthis.editorHistoryListeners.clear();\n\t}\n\n\tgetHistory(): readonly (EditorInput | IResourceEditorInput)[] {\n\t\tthis.ensureHistoryLoaded(this.history);\n\n\t\treturn this.history;\n\t}\n\n\tprivate ensureHistoryLoaded(history: Array<EditorInput | IResourceEditorInput> | undefined): asserts history {\n\t\tif (!this.history) {\n\n\t\t\t// Until history is loaded, it is just empty\n\t\t\tthis.history = [];\n\n\t\t\t// We want to seed history from opened editors\n\t\t\t// too as well as previous stored state, so we\n\t\t\t// need to wait for the editor groups being ready\n\t\t\tif (this.editorGroupService.isReady) {\n\t\t\t\tthis.loadHistory();\n\t\t\t} else {\n\t\t\t\t(async () => {\n\t\t\t\t\tawait this.editorGroupService.whenReady;\n\n\t\t\t\t\tthis.loadHistory();\n\t\t\t\t})();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate loadHistory(): void {\n\n\t\t// Init as empty before adding - since we are about to\n\t\t// populate the history from opened editors, we capture\n\t\t// the right order here.\n\t\tthis.history = [];\n\n\t\t// All stored editors from previous session\n\t\tconst storedEditorHistory = this.loadHistoryFromStorage();\n\n\t\t// All restored editors from previous session\n\t\t// in reverse editor from least to most recently\n\t\t// used.\n\t\tconst openedEditorsLru = [...this.editorService.getEditors(EditorsOrder.MOST_RECENTLY_ACTIVE)].reverse();\n\n\t\t// We want to merge the opened editors from the last\n\t\t// session with the stored editors from the last\n\t\t// session. Because not all editors can be serialised\n\t\t// we want to make sure to include all opened editors\n\t\t// too.\n\t\t// Opened editors should always be first in the history\n\n\t\tconst handledEditors = new Set<string /* resource + editorId */>();\n\n\t\t// Add all opened editors first\n\t\tfor (const { editor } of openedEditorsLru) {\n\t\t\tif (!this.includeInHistory(editor)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Add into history\n\t\t\tthis.addToHistory(editor);\n\n\t\t\t// Remember as added\n\t\t\tif (editor.resource) {\n\t\t\t\thandledEditors.add(`${editor.resource.toString()}/${editor.editorId}`);\n\t\t\t}\n\t\t}\n\n\t\t// Add remaining from storage if not there already\n\t\t// We check on resource and `editorId` (from `override`)\n\t\t// to figure out if the editor has been already added.\n\t\tfor (const editor of storedEditorHistory) {\n\t\t\tif (\n\t\t\t\t!handledEditors.has(`${editor.resource.toString()}/${editor.options?.override}`) &&\n\t\t\t\tthis.includeInHistory(editor)\n\t\t\t) {\n\t\t\t\tthis.addToHistory(editor, false /* at the end */);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate loadHistoryFromStorage(): Array<IResourceEditorInput> {\n\t\tconst entries: IResourceEditorInput[] = [];\n\n\t\tconst entriesRaw = this.storageService.get(HistoryService.HISTORY_STORAGE_KEY, StorageScope.WORKSPACE);\n\t\tif (entriesRaw) {\n\t\t\ttry {\n\t\t\t\tconst entriesParsed: ISerializedEditorHistoryEntry[] = JSON.parse(entriesRaw);\n\t\t\t\tfor (const entryParsed of entriesParsed) {\n\t\t\t\t\tif (!entryParsed.editor || !entryParsed.editor.resource) {\n\t\t\t\t\t\tcontinue; // unexpected data format\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tentries.push({\n\t\t\t\t\t\t\t...entryParsed.editor,\n\t\t\t\t\t\t\tresource: typeof entryParsed.editor.resource === 'string' ?\n\t\t\t\t\t\t\t\tURI.parse(entryParsed.editor.resource) :  \t//  from 1.67.x: URI is stored efficiently as URI.toString()\n\t\t\t\t\t\t\t\tURI.from(entryParsed.editor.resource)\t\t// until 1.66.x: URI was stored very verbose as URI.toJSON()\n\t\t\t\t\t\t});\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tonUnexpectedError(error); // do not fail entire history when one entry fails\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tonUnexpectedError(error); // https://github.com/microsoft/vscode/issues/99075\n\t\t\t}\n\t\t}\n\n\t\treturn entries;\n\t}\n\n\tprivate saveState(): void {\n\t\tif (!this.history) {\n\t\t\treturn; // nothing to save because history was not used\n\t\t}\n\n\t\tconst entries: ISerializedEditorHistoryEntry[] = [];\n\t\tfor (const editor of this.history) {\n\t\t\tif (isEditorInput(editor) || !isResourceEditorInput(editor)) {\n\t\t\t\tcontinue; // only save resource editor inputs\n\t\t\t}\n\n\t\t\tentries.push({\n\t\t\t\teditor: {\n\t\t\t\t\t...editor,\n\t\t\t\t\tresource: editor.resource.toString()\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tthis.storageService.store(HistoryService.HISTORY_STORAGE_KEY, JSON.stringify(entries), StorageScope.WORKSPACE, StorageTarget.MACHINE);\n\t}\n\n\t//#endregion\n\n\t//#region Last Active Workspace/File\n\n\tgetLastActiveWorkspaceRoot(schemeFilter?: string, authorityFilter?: string): URI | undefined {\n\n\t\t// No Folder: return early\n\t\tconst folders = this.contextService.getWorkspace().folders;\n\t\tif (folders.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Single Folder: return early\n\t\tif (folders.length === 1) {\n\t\t\tconst resource = folders[0].uri;\n\t\t\tif ((!schemeFilter || resource.scheme === schemeFilter) && (!authorityFilter || resource.authority === authorityFilter)) {\n\t\t\t\treturn resource;\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Multiple folders: find the last active one\n\t\tfor (const input of this.getHistory()) {\n\t\t\tif (isEditorInput(input)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (schemeFilter && input.resource.scheme !== schemeFilter) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (authorityFilter && input.resource.authority !== authorityFilter) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst resourceWorkspace = this.contextService.getWorkspaceFolder(input.resource);\n\t\t\tif (resourceWorkspace) {\n\t\t\t\treturn resourceWorkspace.uri;\n\t\t\t}\n\t\t}\n\n\t\t// Fallback to first workspace matching scheme filter if any\n\t\tfor (const folder of folders) {\n\t\t\tconst resource = folder.uri;\n\t\t\tif ((!schemeFilter || resource.scheme === schemeFilter) && (!authorityFilter || resource.authority === authorityFilter)) {\n\t\t\t\treturn resource;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tgetLastActiveFile(filterByScheme: string, filterByAuthority?: string): URI | undefined {\n\t\tfor (const input of this.getHistory()) {\n\t\t\tlet resource: URI | undefined;\n\t\t\tif (isEditorInput(input)) {\n\t\t\t\tresource = EditorResourceAccessor.getOriginalUri(input, { filterByScheme });\n\t\t\t} else {\n\t\t\t\tresource = input.resource;\n\t\t\t}\n\n\t\t\tif (resource && resource.scheme === filterByScheme && (!filterByAuthority || resource.authority === filterByAuthority)) {\n\t\t\t\treturn resource;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t//#endregion\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\tfor (const [, stack] of this.editorGroupScopedNavigationStacks) {\n\t\t\tstack.disposable.dispose();\n\t\t}\n\n\t\tfor (const [, editors] of this.editorScopedNavigationStacks) {\n\t\t\tfor (const [, stack] of editors) {\n\t\t\t\tstack.disposable.dispose();\n\t\t\t}\n\t\t}\n\n\t\tfor (const [, listener] of this.editorHistoryListeners) {\n\t\t\tlistener.dispose();\n\t\t}\n\t}\n}\n\nregisterSingleton(IHistoryService, HistoryService, InstantiationType.Eager);\n\nclass EditorSelectionState {\n\n\tconstructor(\n\t\tprivate readonly editorIdentifier: IEditorIdentifier,\n\t\treadonly selection: IEditorPaneSelection | undefined,\n\t\tprivate readonly reason: EditorPaneSelectionChangeReason | undefined\n\t) { }\n\n\tjustifiesNewNavigationEntry(other: EditorSelectionState): boolean {\n\t\tif (this.editorIdentifier.groupId !== other.editorIdentifier.groupId) {\n\t\t\treturn true; // different group\n\t\t}\n\n\t\tif (!this.editorIdentifier.editor.matches(other.editorIdentifier.editor)) {\n\t\t\treturn true; // different editor\n\t\t}\n\n\t\tif (!this.selection || !other.selection) {\n\t\t\treturn true; // unknown selections\n\t\t}\n\n\t\tconst result = this.selection.compare(other.selection);\n\n\t\tif (result === EditorPaneSelectionCompareResult.SIMILAR && (other.reason === EditorPaneSelectionChangeReason.NAVIGATION || other.reason === EditorPaneSelectionChangeReason.JUMP)) {\n\t\t\t// let navigation sources win even if the selection is `SIMILAR`\n\t\t\t// (e.g. \"Go to definition\" should add a history entry)\n\t\t\treturn true;\n\t\t}\n\n\t\treturn result === EditorPaneSelectionCompareResult.DIFFERENT;\n\t}\n}\n\ninterface IEditorNavigationStacks extends IDisposable {\n\treadonly onDidChange: Event<void>;\n\n\tcanGoForward(filter?: GoFilter): boolean;\n\tgoForward(filter?: GoFilter): Promise<void>;\n\tcanGoBack(filter?: GoFilter): boolean;\n\tgoBack(filter?: GoFilter): Promise<void>;\n\tgoPrevious(filter?: GoFilter): Promise<void>;\n\tcanGoLast(filter?: GoFilter): boolean;\n\tgoLast(filter?: GoFilter): Promise<void>;\n\n\thandleActiveEditorChange(editorPane?: IEditorPane): void;\n\thandleActiveEditorSelectionChange(editorPane: IEditorPaneWithSelection, event: IEditorPaneSelectionChangeEvent): void;\n\n\tclear(): void;\n\tremove(arg1: EditorInput | FileChangesEvent | FileOperationEvent | GroupIdentifier): void;\n\tmove(event: FileOperationEvent): void;\n}\n\nclass EditorNavigationStacks extends Disposable implements IEditorNavigationStacks {\n\n\tprivate readonly selectionsStack = this._register(this.instantiationService.createInstance(EditorNavigationStack, GoFilter.NONE, this.scope));\n\tprivate readonly editsStack = this._register(this.instantiationService.createInstance(EditorNavigationStack, GoFilter.EDITS, this.scope));\n\tprivate readonly navigationsStack = this._register(this.instantiationService.createInstance(EditorNavigationStack, GoFilter.NAVIGATION, this.scope));\n\n\tprivate readonly stacks: EditorNavigationStack[] = [\n\t\tthis.selectionsStack,\n\t\tthis.editsStack,\n\t\tthis.navigationsStack\n\t];\n\n\treadonly onDidChange = Event.any(\n\t\tthis.selectionsStack.onDidChange,\n\t\tthis.editsStack.onDidChange,\n\t\tthis.navigationsStack.onDidChange\n\t);\n\n\tconstructor(\n\t\tprivate readonly scope: GoScope,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService\n\t) {\n\t\tsuper();\n\t}\n\n\tcanGoForward(filter?: GoFilter): boolean {\n\t\treturn this.getStack(filter).canGoForward();\n\t}\n\n\tgoForward(filter?: GoFilter): Promise<void> {\n\t\treturn this.getStack(filter).goForward();\n\t}\n\n\tcanGoBack(filter?: GoFilter): boolean {\n\t\treturn this.getStack(filter).canGoBack();\n\t}\n\n\tgoBack(filter?: GoFilter): Promise<void> {\n\t\treturn this.getStack(filter).goBack();\n\t}\n\n\tgoPrevious(filter?: GoFilter): Promise<void> {\n\t\treturn this.getStack(filter).goPrevious();\n\t}\n\n\tcanGoLast(filter?: GoFilter): boolean {\n\t\treturn this.getStack(filter).canGoLast();\n\t}\n\n\tgoLast(filter?: GoFilter): Promise<void> {\n\t\treturn this.getStack(filter).goLast();\n\t}\n\n\tprivate getStack(filter = GoFilter.NONE): EditorNavigationStack {\n\t\tswitch (filter) {\n\t\t\tcase GoFilter.NONE: return this.selectionsStack;\n\t\t\tcase GoFilter.EDITS: return this.editsStack;\n\t\t\tcase GoFilter.NAVIGATION: return this.navigationsStack;\n\t\t}\n\t}\n\n\thandleActiveEditorChange(editorPane?: IEditorPane): void {\n\n\t\t// Always send to selections navigation stack\n\t\tthis.selectionsStack.notifyNavigation(editorPane);\n\t}\n\n\thandleActiveEditorSelectionChange(editorPane: IEditorPaneWithSelection, event: IEditorPaneSelectionChangeEvent): void {\n\t\tconst previous = this.selectionsStack.current;\n\n\t\t// Always send to selections navigation stack\n\t\tthis.selectionsStack.notifyNavigation(editorPane, event);\n\n\t\t// Check for edits\n\t\tif (event.reason === EditorPaneSelectionChangeReason.EDIT) {\n\t\t\tthis.editsStack.notifyNavigation(editorPane, event);\n\t\t}\n\n\t\t// Check for navigations\n\t\t//\n\t\t// Note: ignore if selections navigation stack is navigating because\n\t\t// in that case we do not want to receive repeated entries in\n\t\t// the navigation stack.\n\t\telse if (\n\t\t\t(event.reason === EditorPaneSelectionChangeReason.NAVIGATION || event.reason === EditorPaneSelectionChangeReason.JUMP) &&\n\t\t\t!this.selectionsStack.isNavigating()\n\t\t) {\n\n\t\t\t// A \"JUMP\" navigation selection change always has a source and\n\t\t\t// target. As such, we add the previous entry of the selections\n\t\t\t// navigation stack so that our navigation stack receives both\n\t\t\t// entries unless the user is currently navigating.\n\n\t\t\tif (event.reason === EditorPaneSelectionChangeReason.JUMP && !this.navigationsStack.isNavigating()) {\n\t\t\t\tif (previous) {\n\t\t\t\t\tthis.navigationsStack.addOrReplace(previous.groupId, previous.editor, previous.selection);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.navigationsStack.notifyNavigation(editorPane, event);\n\t\t}\n\t}\n\n\tclear(): void {\n\t\tfor (const stack of this.stacks) {\n\t\t\tstack.clear();\n\t\t}\n\t}\n\n\tremove(arg1: EditorInput | FileChangesEvent | FileOperationEvent | GroupIdentifier): void {\n\t\tfor (const stack of this.stacks) {\n\t\t\tstack.remove(arg1);\n\t\t}\n\t}\n\n\tmove(event: FileOperationEvent): void {\n\t\tfor (const stack of this.stacks) {\n\t\t\tstack.move(event);\n\t\t}\n\t}\n}\n\nclass NoOpEditorNavigationStacks implements IEditorNavigationStacks {\n\tonDidChange = Event.None;\n\n\tcanGoForward(): boolean { return false; }\n\tasync goForward(): Promise<void> { }\n\tcanGoBack(): boolean { return false; }\n\tasync goBack(): Promise<void> { }\n\tasync goPrevious(): Promise<void> { }\n\tcanGoLast(): boolean { return false; }\n\tasync goLast(): Promise<void> { }\n\n\thandleActiveEditorChange(): void { }\n\thandleActiveEditorSelectionChange(): void { }\n\n\tclear(): void { }\n\tremove(): void { }\n\tmove(): void { }\n\n\tdispose(): void { }\n}\n\ninterface IEditorNavigationStackEntry {\n\tgroupId: GroupIdentifier;\n\teditor: EditorInput | IResourceEditorInput;\n\tselection?: IEditorPaneSelection;\n}\n\nexport class EditorNavigationStack extends Disposable {\n\n\tprivate static readonly MAX_STACK_SIZE = 50;\n\n\tprivate readonly _onDidChange = this._register(new Emitter<void>());\n\treadonly onDidChange = this._onDidChange.event;\n\n\tprivate readonly mapEditorToDisposable = new Map<EditorInput, DisposableStore>();\n\tprivate readonly mapGroupToDisposable = new Map<GroupIdentifier, IDisposable>();\n\n\tprivate readonly editorHelper = this.instantiationService.createInstance(EditorHelper);\n\n\tprivate stack: IEditorNavigationStackEntry[] = [];\n\n\tprivate index = -1;\n\tprivate previousIndex = -1;\n\n\tprivate navigating: boolean = false;\n\n\tprivate currentSelectionState: EditorSelectionState | undefined = undefined;\n\n\tget current(): IEditorNavigationStackEntry | undefined {\n\t\treturn this.stack[this.index];\n\t}\n\n\tprivate set current(entry: IEditorNavigationStackEntry | undefined) {\n\t\tif (entry) {\n\t\t\tthis.stack[this.index] = entry;\n\t\t}\n\t}\n\n\tconstructor(\n\t\tprivate readonly filter: GoFilter,\n\t\tprivate readonly scope: GoScope,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService,\n\t\t@IEditorService private readonly editorService: IEditorService,\n\t\t@IEditorGroupsService private readonly editorGroupService: IEditorGroupsService,\n\t\t@ILogService private readonly logService: ILogService\n\t) {\n\t\tsuper();\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tthis._register(this.onDidChange(() => this.traceStack()));\n\t\tthis._register(this.logService.onDidChangeLogLevel(() => this.traceStack()));\n\t}\n\n\tprivate traceStack(): void {\n\t\tif (this.logService.getLevel() !== LogLevel.Trace) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst entryLabels: string[] = [];\n\t\tfor (const entry of this.stack) {\n\t\t\tif (typeof entry.selection?.log === 'function') {\n\t\t\t\tentryLabels.push(`- group: ${entry.groupId}, editor: ${entry.editor.resource?.toString()}, selection: ${entry.selection.log()}`);\n\t\t\t} else {\n\t\t\t\tentryLabels.push(`- group: ${entry.groupId}, editor: ${entry.editor.resource?.toString()}, selection: <none>`);\n\t\t\t}\n\t\t}\n\n\t\tif (entryLabels.length === 0) {\n\t\t\tthis.trace(`index: ${this.index}, navigating: ${this.isNavigating()}: <empty>`);\n\t\t} else {\n\t\t\tthis.trace(`index: ${this.index}, navigating: ${this.isNavigating()}\n${entryLabels.join('\\n')}\n\t\t\t`);\n\t\t}\n\t}\n\n\tprivate trace(msg: string, editor: EditorInput | IResourceEditorInput | undefined | null = null, event?: IEditorPaneSelectionChangeEvent): void {\n\t\tif (this.logService.getLevel() !== LogLevel.Trace) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet filterLabel: string;\n\t\tswitch (this.filter) {\n\t\t\tcase GoFilter.NONE: filterLabel = 'global';\n\t\t\t\tbreak;\n\t\t\tcase GoFilter.EDITS: filterLabel = 'edits';\n\t\t\t\tbreak;\n\t\t\tcase GoFilter.NAVIGATION: filterLabel = 'navigation';\n\t\t\t\tbreak;\n\t\t}\n\n\t\tlet scopeLabel: string;\n\t\tswitch (this.scope) {\n\t\t\tcase GoScope.DEFAULT: scopeLabel = 'default';\n\t\t\t\tbreak;\n\t\t\tcase GoScope.EDITOR_GROUP: scopeLabel = 'editorGroup';\n\t\t\t\tbreak;\n\t\t\tcase GoScope.EDITOR: scopeLabel = 'editor';\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (editor !== null) {\n\t\t\tthis.logService.trace(`[History stack ${filterLabel}-${scopeLabel}]: ${msg} (editor: ${editor?.resource?.toString()}, event: ${this.traceEvent(event)})`);\n\t\t} else {\n\t\t\tthis.logService.trace(`[History stack ${filterLabel}-${scopeLabel}]: ${msg}`);\n\t\t}\n\t}\n\n\tprivate traceEvent(event?: IEditorPaneSelectionChangeEvent): string {\n\t\tif (!event) {\n\t\t\treturn '<none>';\n\t\t}\n\n\t\tswitch (event.reason) {\n\t\t\tcase EditorPaneSelectionChangeReason.EDIT: return 'edit';\n\t\t\tcase EditorPaneSelectionChangeReason.NAVIGATION: return 'navigation';\n\t\t\tcase EditorPaneSelectionChangeReason.JUMP: return 'jump';\n\t\t\tcase EditorPaneSelectionChangeReason.PROGRAMMATIC: return 'programmatic';\n\t\t\tcase EditorPaneSelectionChangeReason.USER: return 'user';\n\t\t}\n\t}\n\n\tprivate registerGroupListeners(groupId: GroupIdentifier): void {\n\t\tif (!this.mapGroupToDisposable.has(groupId)) {\n\t\t\tconst group = this.editorGroupService.getGroup(groupId);\n\t\t\tif (group) {\n\t\t\t\tthis.mapGroupToDisposable.set(groupId, group.onWillMoveEditor(e => this.onWillMoveEditor(e)));\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate onWillMoveEditor(e: IEditorWillMoveEvent): void {\n\t\tthis.trace('onWillMoveEditor()', e.editor);\n\n\t\tif (this.scope === GoScope.EDITOR_GROUP) {\n\t\t\treturn; // ignore move events if our scope is group based\n\t\t}\n\n\t\tfor (const entry of this.stack) {\n\t\t\tif (entry.groupId !== e.groupId) {\n\t\t\t\tcontinue; // not in the group that reported the event\n\t\t\t}\n\n\t\t\tif (!this.editorHelper.matchesEditor(e.editor, entry.editor)) {\n\t\t\t\tcontinue; // not the editor this event is about\n\t\t\t}\n\n\t\t\t// Update to target group\n\t\t\tentry.groupId = e.target;\n\t\t}\n\t}\n\n\t//#region Stack Mutation\n\n\tnotifyNavigation(editorPane: IEditorPane | undefined, event?: IEditorPaneSelectionChangeEvent): void {\n\t\tthis.trace('notifyNavigation()', editorPane?.input, event);\n\n\t\tconst isSelectionAwareEditorPane = isEditorPaneWithSelection(editorPane);\n\t\tconst hasValidEditor = editorPane?.input && !editorPane.input.isDisposed();\n\n\t\t// Treat editor changes that happen as part of stack navigation specially\n\t\t// we do not want to add a new stack entry as a matter of navigating the\n\t\t// stack but we need to keep our currentEditorSelectionState up to date\n\t\t// with the navigtion that occurs.\n\t\tif (this.navigating) {\n\t\t\tthis.trace(`notifyNavigation() ignoring (navigating)`, editorPane?.input, event);\n\n\t\t\tif (isSelectionAwareEditorPane && hasValidEditor) {\n\t\t\t\tthis.trace('notifyNavigation() updating current selection state', editorPane?.input, event);\n\n\t\t\t\tthis.currentSelectionState = new EditorSelectionState({ groupId: editorPane.group.id, editor: editorPane.input }, editorPane.getSelection(), event?.reason);\n\t\t\t} else {\n\t\t\t\tthis.trace('notifyNavigation() dropping current selection state', editorPane?.input, event);\n\n\t\t\t\tthis.currentSelectionState = undefined; // we navigated to a non-selection aware or disposed editor\n\t\t\t}\n\t\t}\n\n\t\t// Normal navigation not part of stack navigation\n\t\telse {\n\t\t\tthis.trace(`notifyNavigation() not ignoring`, editorPane?.input, event);\n\n\t\t\t// Navigation inside selection aware editor\n\t\t\tif (isSelectionAwareEditorPane && hasValidEditor) {\n\t\t\t\tthis.onSelectionAwareEditorNavigation(editorPane.group.id, editorPane.input, editorPane.getSelection(), event);\n\t\t\t}\n\n\t\t\t// Navigation to non-selection aware or disposed editor\n\t\t\telse {\n\t\t\t\tthis.currentSelectionState = undefined; // at this time we have no active selection aware editor\n\n\t\t\t\tif (hasValidEditor) {\n\t\t\t\t\tthis.onNonSelectionAwareEditorNavigation(editorPane.group.id, editorPane.input);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate onSelectionAwareEditorNavigation(groupId: GroupIdentifier, editor: EditorInput, selection: IEditorPaneSelection | undefined, event?: IEditorPaneSelectionChangeEvent): void {\n\t\tif (this.current?.groupId === groupId && !selection && this.editorHelper.matchesEditor(this.current.editor, editor)) {\n\t\t\treturn; // do not push same editor input again of same group if we have no valid selection\n\t\t}\n\n\t\tthis.trace('onSelectionAwareEditorNavigation()', editor, event);\n\n\t\tconst stateCandidate = new EditorSelectionState({ groupId, editor }, selection, event?.reason);\n\n\t\t// Add to stack if we dont have a current state or this new state justifies a push\n\t\tif (!this.currentSelectionState || this.currentSelectionState.justifiesNewNavigationEntry(stateCandidate)) {\n\t\t\tthis.doAdd(groupId, editor, stateCandidate.selection);\n\t\t}\n\n\t\t// Otherwise we replace the current stack entry with this one\n\t\telse {\n\t\t\tthis.doReplace(groupId, editor, stateCandidate.selection);\n\t\t}\n\n\t\t// Update our current navigation editor state\n\t\tthis.currentSelectionState = stateCandidate;\n\t}\n\n\tprivate onNonSelectionAwareEditorNavigation(groupId: GroupIdentifier, editor: EditorInput): void {\n\t\tif (this.current?.groupId === groupId && this.editorHelper.matchesEditor(this.current.editor, editor)) {\n\t\t\treturn; // do not push same editor input again of same group\n\t\t}\n\n\t\tthis.trace('onNonSelectionAwareEditorNavigation()', editor);\n\n\t\tthis.doAdd(groupId, editor);\n\t}\n\n\tprivate doAdd(groupId: GroupIdentifier, editor: EditorInput | IResourceEditorInput, selection?: IEditorPaneSelection): void {\n\t\tif (!this.navigating) {\n\t\t\tthis.addOrReplace(groupId, editor, selection);\n\t\t}\n\t}\n\n\tprivate doReplace(groupId: GroupIdentifier, editor: EditorInput | IResourceEditorInput, selection?: IEditorPaneSelection): void {\n\t\tif (!this.navigating) {\n\t\t\tthis.addOrReplace(groupId, editor, selection, true /* force replace */);\n\t\t}\n\t}\n\n\taddOrReplace(groupId: GroupIdentifier, editorCandidate: EditorInput | IResourceEditorInput, selection?: IEditorPaneSelection, forceReplace?: boolean): void {\n\n\t\t// Ensure we listen to changes in group\n\t\tthis.registerGroupListeners(groupId);\n\n\t\t// Check whether to replace an existing entry or not\n\t\tlet replace = false;\n\t\tif (this.current) {\n\t\t\tif (forceReplace) {\n\t\t\t\treplace = true; // replace if we are forced to\n\t\t\t} else if (this.shouldReplaceStackEntry(this.current, { groupId, editor: editorCandidate, selection })) {\n\t\t\t\treplace = true; // replace if the group & input is the same and selection indicates as such\n\t\t\t}\n\t\t}\n\n\t\tconst editor = this.editorHelper.preferResourceEditorInput(editorCandidate);\n\t\tif (!editor) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (replace) {\n\t\t\tthis.trace('replace()', editor);\n\t\t} else {\n\t\t\tthis.trace('add()', editor);\n\t\t}\n\n\t\tconst newStackEntry: IEditorNavigationStackEntry = { groupId, editor, selection };\n\n\t\t// Replace at current position\n\t\tconst removedEntries: IEditorNavigationStackEntry[] = [];\n\t\tif (replace) {\n\t\t\tif (this.current) {\n\t\t\t\tremovedEntries.push(this.current);\n\t\t\t}\n\t\t\tthis.current = newStackEntry;\n\t\t}\n\n\t\t// Add to stack at current position\n\t\telse {\n\n\t\t\t// If we are not at the end of history, we remove anything after\n\t\t\tif (this.stack.length > this.index + 1) {\n\t\t\t\tfor (let i = this.index + 1; i < this.stack.length; i++) {\n\t\t\t\t\tremovedEntries.push(this.stack[i]);\n\t\t\t\t}\n\n\t\t\t\tthis.stack = this.stack.slice(0, this.index + 1);\n\t\t\t}\n\n\t\t\t// Insert entry at index\n\t\t\tthis.stack.splice(this.index + 1, 0, newStackEntry);\n\n\t\t\t// Check for limit\n\t\t\tif (this.stack.length > EditorNavigationStack.MAX_STACK_SIZE) {\n\t\t\t\tremovedEntries.push(this.stack.shift()!); // remove first\n\t\t\t\tif (this.previousIndex >= 0) {\n\t\t\t\t\tthis.previousIndex--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.setIndex(this.index + 1, true /* skip event, we fire it later */);\n\t\t\t}\n\t\t}\n\n\t\t// Clear editor listeners from removed entries\n\t\tfor (const removedEntry of removedEntries) {\n\t\t\tthis.editorHelper.clearOnEditorDispose(removedEntry.editor, this.mapEditorToDisposable);\n\t\t}\n\n\t\t// Remove this from the stack unless the stack input is a resource\n\t\t// that can easily be restored even when the input gets disposed\n\t\tif (isEditorInput(editor)) {\n\t\t\tthis.editorHelper.onEditorDispose(editor, () => this.remove(editor), this.mapEditorToDisposable);\n\t\t}\n\n\t\t// Event\n\t\tthis._onDidChange.fire();\n\t}\n\n\tprivate shouldReplaceStackEntry(entry: IEditorNavigationStackEntry, candidate: IEditorNavigationStackEntry): boolean {\n\t\tif (entry.groupId !== candidate.groupId) {\n\t\t\treturn false; // different group\n\t\t}\n\n\t\tif (!this.editorHelper.matchesEditor(entry.editor, candidate.editor)) {\n\t\t\treturn false; // different editor\n\t\t}\n\n\t\tif (!entry.selection) {\n\t\t\treturn true; // always replace when we have no specific selection yet\n\t\t}\n\n\t\tif (!candidate.selection) {\n\t\t\treturn false; // otherwise, prefer to keep existing specific selection over new unspecific one\n\t\t}\n\n\t\t// Finally, replace when selections are considered identical\n\t\treturn entry.selection.compare(candidate.selection) === EditorPaneSelectionCompareResult.IDENTICAL;\n\t}\n\n\tmove(event: FileOperationEvent): void {\n\t\tif (event.isOperation(FileOperation.MOVE)) {\n\t\t\tfor (const entry of this.stack) {\n\t\t\t\tif (this.editorHelper.matchesEditor(event, entry.editor)) {\n\t\t\t\t\tentry.editor = { resource: event.target.resource };\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tremove(arg1: EditorInput | FileChangesEvent | FileOperationEvent | GroupIdentifier): void {\n\t\tconst previousStackSize = this.stack.length;\n\n\t\t// Remove all stack entries that match `arg1`\n\t\tthis.stack = this.stack.filter(entry => {\n\t\t\tconst matches = typeof arg1 === 'number' ? entry.groupId === arg1 : this.editorHelper.matchesEditor(arg1, entry.editor);\n\n\t\t\t// Cleanup any listeners associated with the input when removing\n\t\t\tif (matches) {\n\t\t\t\tthis.editorHelper.clearOnEditorDispose(entry.editor, this.mapEditorToDisposable);\n\t\t\t}\n\n\t\t\treturn !matches;\n\t\t});\n\n\t\tif (previousStackSize === this.stack.length) {\n\t\t\treturn; // nothing removed\n\t\t}\n\n\t\t// Given we just removed entries, we need to make sure\n\t\t// to remove entries that are now identical and next\n\t\t// to each other to prevent no-op navigations.\n\t\tthis.flatten();\n\n\t\t// Reset indeces\n\t\tthis.index = this.stack.length - 1;\n\t\tthis.previousIndex = -1;\n\n\t\t// Clear group listener\n\t\tif (typeof arg1 === 'number') {\n\t\t\tthis.mapGroupToDisposable.get(arg1)?.dispose();\n\t\t\tthis.mapGroupToDisposable.delete(arg1);\n\t\t}\n\n\t\t// Event\n\t\tthis._onDidChange.fire();\n\t}\n\n\tprivate flatten(): void {\n\t\tconst flattenedStack: IEditorNavigationStackEntry[] = [];\n\n\t\tlet previousEntry: IEditorNavigationStackEntry | undefined = undefined;\n\t\tfor (const entry of this.stack) {\n\t\t\tif (previousEntry && this.shouldReplaceStackEntry(entry, previousEntry)) {\n\t\t\t\tcontinue; // skip over entry when it is considered the same\n\t\t\t}\n\n\t\t\tpreviousEntry = entry;\n\t\t\tflattenedStack.push(entry);\n\t\t}\n\n\t\tthis.stack = flattenedStack;\n\t}\n\n\tclear(): void {\n\t\tthis.index = -1;\n\t\tthis.previousIndex = -1;\n\t\tthis.stack.splice(0);\n\n\t\tfor (const [, disposable] of this.mapEditorToDisposable) {\n\t\t\tdispose(disposable);\n\t\t}\n\t\tthis.mapEditorToDisposable.clear();\n\n\t\tfor (const [, disposable] of this.mapGroupToDisposable) {\n\t\t\tdispose(disposable);\n\t\t}\n\t\tthis.mapGroupToDisposable.clear();\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\tthis.clear();\n\t}\n\n\t//#endregion\n\n\t//#region Navigation\n\n\tcanGoForward(): boolean {\n\t\treturn this.stack.length > this.index + 1;\n\t}\n\n\tasync goForward(): Promise<void> {\n\t\tconst navigated = await this.maybeGoCurrent();\n\t\tif (navigated) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.canGoForward()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.setIndex(this.index + 1);\n\t\treturn this.navigate();\n\t}\n\n\tcanGoBack(): boolean {\n\t\treturn this.index > 0;\n\t}\n\n\tasync goBack(): Promise<void> {\n\t\tconst navigated = await this.maybeGoCurrent();\n\t\tif (navigated) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.canGoBack()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.setIndex(this.index - 1);\n\t\treturn this.navigate();\n\t}\n\n\tasync goPrevious(): Promise<void> {\n\t\tconst navigated = await this.maybeGoCurrent();\n\t\tif (navigated) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If we never navigated, just go back\n\t\tif (this.previousIndex === -1) {\n\t\t\treturn this.goBack();\n\t\t}\n\n\t\t// Otherwise jump to previous stack entry\n\t\tthis.setIndex(this.previousIndex);\n\t\treturn this.navigate();\n\t}\n\n\tcanGoLast(): boolean {\n\t\treturn this.stack.length > 0;\n\t}\n\n\tasync goLast(): Promise<void> {\n\t\tif (!this.canGoLast()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.setIndex(this.stack.length - 1);\n\t\treturn this.navigate();\n\t}\n\n\tprivate async maybeGoCurrent(): Promise<boolean> {\n\n\t\t// When this navigation stack works with a specific\n\t\t// filter where not every selection change is added\n\t\t// to the stack, we want to first reveal the current\n\t\t// selection before attempting to navigate in the\n\t\t// stack.\n\n\t\tif (this.filter === GoFilter.NONE) {\n\t\t\treturn false; // only applies when  we are a filterd stack\n\t\t}\n\n\t\tif (this.isCurrentSelectionActive()) {\n\t\t\treturn false; // we are at the current navigation stop\n\t\t}\n\n\t\t// Go to current selection\n\t\tawait this.navigate();\n\n\t\treturn true;\n\t}\n\n\tprivate isCurrentSelectionActive(): boolean {\n\t\tif (!this.current?.selection) {\n\t\t\treturn false; // we need a current selection\n\t\t}\n\n\t\tconst pane = this.editorService.activeEditorPane;\n\t\tif (!isEditorPaneWithSelection(pane)) {\n\t\t\treturn false; // we need an active editor pane with selection support\n\t\t}\n\n\t\tif (pane.group.id !== this.current.groupId) {\n\t\t\treturn false; // we need matching groups\n\t\t}\n\n\t\tif (!pane.input || !this.editorHelper.matchesEditor(pane.input, this.current.editor)) {\n\t\t\treturn false; // we need matching editors\n\t\t}\n\n\t\tconst paneSelection = pane.getSelection();\n\t\tif (!paneSelection) {\n\t\t\treturn false; // we need a selection to compare with\n\t\t}\n\n\t\treturn paneSelection.compare(this.current.selection) === EditorPaneSelectionCompareResult.IDENTICAL;\n\t}\n\n\tprivate setIndex(newIndex: number, skipEvent?: boolean): void {\n\t\tthis.previousIndex = this.index;\n\t\tthis.index = newIndex;\n\n\t\t// Event\n\t\tif (!skipEvent) {\n\t\t\tthis._onDidChange.fire();\n\t\t}\n\t}\n\n\tprivate async navigate(): Promise<void> {\n\t\tthis.navigating = true;\n\n\t\ttry {\n\t\t\tif (this.current) {\n\t\t\t\tawait this.doNavigate(this.current);\n\t\t\t}\n\t\t} finally {\n\t\t\tthis.navigating = false;\n\t\t}\n\t}\n\n\tprivate doNavigate(location: IEditorNavigationStackEntry): Promise<IEditorPane | undefined> {\n\t\tlet options: IEditorOptions = Object.create(null);\n\n\t\t// Apply selection if any\n\t\tif (location.selection) {\n\t\t\toptions = location.selection.restore(options);\n\t\t}\n\n\t\tif (isEditorInput(location.editor)) {\n\t\t\treturn this.editorService.openEditor(location.editor, options, location.groupId);\n\t\t}\n\n\t\treturn this.editorService.openEditor({\n\t\t\t...location.editor,\n\t\t\toptions: {\n\t\t\t\t...location.editor.options,\n\t\t\t\t...options\n\t\t\t}\n\t\t}, location.groupId);\n\t}\n\n\tisNavigating(): boolean {\n\t\treturn this.navigating;\n\t}\n\n\t//#endregion\n}\n\nclass EditorHelper {\n\n\tconstructor(\n\t\t@IUriIdentityService private readonly uriIdentityService: IUriIdentityService,\n\t\t@ILifecycleService private readonly lifecycleService: ILifecycleService,\n\t\t@IFileService private readonly fileService: IFileService,\n\t\t@IPathService private readonly pathService: IPathService\n\t) { }\n\n\tpreferResourceEditorInput(editor: EditorInput): EditorInput | IResourceEditorInput;\n\tpreferResourceEditorInput(editor: IResourceEditorInput): IResourceEditorInput | undefined;\n\tpreferResourceEditorInput(editor: EditorInput | IResourceEditorInput): EditorInput | IResourceEditorInput | undefined;\n\tpreferResourceEditorInput(editor: EditorInput | IResourceEditorInput): EditorInput | IResourceEditorInput | undefined {\n\t\tconst resource = EditorResourceAccessor.getOriginalUri(editor);\n\n\t\t// For now, only prefer well known schemes that we control to prevent\n\t\t// issues such as https://github.com/microsoft/vscode/issues/85204\n\t\t// from being used as resource inputs\n\t\t// resource inputs survive editor disposal and as such are a lot more\n\t\t// durable across editor changes and restarts\n\t\tconst hasValidResourceEditorInputScheme =\n\t\t\tresource?.scheme === Schemas.file ||\n\t\t\tresource?.scheme === Schemas.vscodeRemote ||\n\t\t\tresource?.scheme === Schemas.vscodeUserData ||\n\t\t\tresource?.scheme === this.pathService.defaultUriScheme;\n\n\t\t// Scheme is valid: prefer the untyped input\n\t\t// over the typed input if possible to keep\n\t\t// the entry across restarts\n\t\tif (hasValidResourceEditorInputScheme) {\n\t\t\tif (isEditorInput(editor)) {\n\t\t\t\tconst untypedInput = editor.toUntyped();\n\t\t\t\tif (isResourceEditorInput(untypedInput)) {\n\t\t\t\t\treturn untypedInput;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn editor;\n\t\t}\n\n\t\t// Scheme is invalid: allow the editor input\n\t\t// for as long as it is not disposed\n\t\telse {\n\t\t\treturn isEditorInput(editor) ? editor : undefined;\n\t\t}\n\t}\n\n\tmatchesEditor(arg1: EditorInput | IResourceEditorInput | FileChangesEvent | FileOperationEvent, inputB: EditorInput | IResourceEditorInput): boolean {\n\t\tif (arg1 instanceof FileChangesEvent || arg1 instanceof FileOperationEvent) {\n\t\t\tif (isEditorInput(inputB)) {\n\t\t\t\treturn false; // we only support this for `IResourceEditorInputs` that are file based\n\t\t\t}\n\n\t\t\tif (arg1 instanceof FileChangesEvent) {\n\t\t\t\treturn arg1.contains(inputB.resource, FileChangeType.DELETED);\n\t\t\t}\n\n\t\t\treturn this.matchesFile(inputB.resource, arg1);\n\t\t}\n\n\t\tif (isEditorInput(arg1)) {\n\t\t\tif (isEditorInput(inputB)) {\n\t\t\t\treturn arg1.matches(inputB);\n\t\t\t}\n\n\t\t\treturn this.matchesFile(inputB.resource, arg1);\n\t\t}\n\n\t\tif (isEditorInput(inputB)) {\n\t\t\treturn this.matchesFile(arg1.resource, inputB);\n\t\t}\n\n\t\treturn arg1 && inputB && this.uriIdentityService.extUri.isEqual(arg1.resource, inputB.resource);\n\t}\n\n\tmatchesFile(resource: URI, arg2: EditorInput | IResourceEditorInput | FileChangesEvent | FileOperationEvent): boolean {\n\t\tif (arg2 instanceof FileChangesEvent) {\n\t\t\treturn arg2.contains(resource, FileChangeType.DELETED);\n\t\t}\n\n\t\tif (arg2 instanceof FileOperationEvent) {\n\t\t\treturn this.uriIdentityService.extUri.isEqualOrParent(resource, arg2.resource);\n\t\t}\n\n\t\tif (isEditorInput(arg2)) {\n\t\t\tconst inputResource = arg2.resource;\n\t\t\tif (!inputResource) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (this.lifecycleService.phase >= LifecyclePhase.Restored && !this.fileService.hasProvider(inputResource)) {\n\t\t\t\treturn false; // make sure to only check this when workbench has restored (for https://github.com/microsoft/vscode/issues/48275)\n\t\t\t}\n\n\t\t\treturn this.uriIdentityService.extUri.isEqual(inputResource, resource);\n\t\t}\n\n\t\treturn this.uriIdentityService.extUri.isEqual(arg2?.resource, resource);\n\t}\n\n\tmatchesEditorIdentifier(identifier: IEditorIdentifier, editorPane?: IEditorPane): boolean {\n\t\tif (!editorPane?.group) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (identifier.groupId !== editorPane.group.id) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn editorPane.input ? identifier.editor.matches(editorPane.input) : false;\n\t}\n\n\tonEditorDispose(editor: EditorInput, listener: Function, mapEditorToDispose: Map<EditorInput, DisposableStore>): void {\n\t\tconst toDispose = Event.once(editor.onWillDispose)(() => listener());\n\n\t\tlet disposables = mapEditorToDispose.get(editor);\n\t\tif (!disposables) {\n\t\t\tdisposables = new DisposableStore();\n\t\t\tmapEditorToDispose.set(editor, disposables);\n\t\t}\n\n\t\tdisposables.add(toDispose);\n\t}\n\n\tclearOnEditorDispose(editor: EditorInput | IResourceEditorInput | FileChangesEvent | FileOperationEvent, mapEditorToDispose: Map<EditorInput, DisposableStore>): void {\n\t\tif (!isEditorInput(editor)) {\n\t\t\treturn; // only supported when passing in an actual editor input\n\t\t}\n\n\t\tconst disposables = mapEditorToDispose.get(editor);\n\t\tif (disposables) {\n\t\t\tdispose(disposables);\n\t\t\tmapEditorToDispose.delete(editor);\n\t\t}\n\t}\n}\n"],
  "mappings": "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",
  "names": ["index"]
}
