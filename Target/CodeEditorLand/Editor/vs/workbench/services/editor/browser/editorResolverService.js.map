{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/editor/browser/editorResolverService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as glob from '../../../../base/common/glob.js';\nimport { distinct, insert } from '../../../../base/common/arrays.js';\nimport { Disposable, DisposableStore, IDisposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { basename, extname, isEqual } from '../../../../base/common/resources.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { EditorActivation, EditorResolution, IEditorOptions } from '../../../../platform/editor/common/editor.js';\nimport { DEFAULT_EDITOR_ASSOCIATION, EditorResourceAccessor, EditorInputWithOptions, IResourceSideBySideEditorInput, isEditorInputWithOptions, isEditorInputWithOptionsAndGroup, isResourceDiffEditorInput, isResourceSideBySideEditorInput, isUntitledResourceEditorInput, isResourceMergeEditorInput, IUntypedEditorInput, SideBySideEditor, isResourceMultiDiffEditorInput } from '../../../common/editor.js';\nimport { EditorInput } from '../../../common/editor/editorInput.js';\nimport { IEditorGroup, IEditorGroupsService } from '../common/editorGroupsService.js';\nimport { Schemas } from '../../../../base/common/network.js';\nimport { RegisteredEditorInfo, RegisteredEditorPriority, RegisteredEditorOptions, EditorAssociation, EditorAssociations, editorsAssociationsSettingId, globMatchesResource, IEditorResolverService, priorityToRank, ResolvedEditor, ResolvedStatus, EditorInputFactoryObject } from '../common/editorResolverService.js';\nimport { QuickPickItem, IKeyMods, IQuickInputService, IQuickPickItem, IQuickPickSeparator } from '../../../../platform/quickinput/common/quickInput.js';\nimport { localize } from '../../../../nls.js';\nimport { INotificationService, Severity } from '../../../../platform/notification/common/notification.js';\nimport { ITelemetryService } from '../../../../platform/telemetry/common/telemetry.js';\nimport { InstantiationType, registerSingleton } from '../../../../platform/instantiation/common/extensions.js';\nimport { IStorageService, StorageScope, StorageTarget } from '../../../../platform/storage/common/storage.js';\nimport { IExtensionService } from '../../extensions/common/extensions.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { findGroup } from '../common/editorGroupFinder.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { PreferredGroup } from '../common/editorService.js';\nimport { SideBySideEditorInput } from '../../../common/editor/sideBySideEditorInput.js';\nimport { PauseableEmitter } from '../../../../base/common/event.js';\n\ninterface RegisteredEditor {\n\tglobPattern: string | glob.IRelativePattern;\n\teditorInfo: RegisteredEditorInfo;\n\toptions?: RegisteredEditorOptions;\n\teditorFactoryObject: EditorInputFactoryObject;\n}\n\ntype RegisteredEditors = Array<RegisteredEditor>;\n\nexport class EditorResolverService extends Disposable implements IEditorResolverService {\n\treadonly _serviceBrand: undefined;\n\n\t// Events\n\tprivate readonly _onDidChangeEditorRegistrations = this._register(new PauseableEmitter<void>());\n\treadonly onDidChangeEditorRegistrations = this._onDidChangeEditorRegistrations.event;\n\n\t// Constants\n\tprivate static readonly configureDefaultID = 'promptOpenWith.configureDefault';\n\tprivate static readonly cacheStorageID = 'editorOverrideService.cache';\n\tprivate static readonly conflictingDefaultsStorageID = 'editorOverrideService.conflictingDefaults';\n\n\t// Data Stores\n\tprivate _editors: Map<string | glob.IRelativePattern, Map<string, RegisteredEditors>> = new Map<string | glob.IRelativePattern, Map<string, RegisteredEditors>>();\n\tprivate _flattenedEditors: Map<string | glob.IRelativePattern, RegisteredEditors> = new Map();\n\tprivate _shouldReFlattenEditors: boolean = true;\n\tprivate cache: Set<string> | undefined;\n\n\tconstructor(\n\t\t@IEditorGroupsService private readonly editorGroupService: IEditorGroupsService,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t\t@IQuickInputService private readonly quickInputService: IQuickInputService,\n\t\t@INotificationService private readonly notificationService: INotificationService,\n\t\t@ITelemetryService private readonly telemetryService: ITelemetryService,\n\t\t@IStorageService private readonly storageService: IStorageService,\n\t\t@IExtensionService private readonly extensionService: IExtensionService,\n\t\t@ILogService private readonly logService: ILogService\n\t) {\n\t\tsuper();\n\t\t// Read in the cache on statup\n\t\tthis.cache = new Set<string>(JSON.parse(this.storageService.get(EditorResolverService.cacheStorageID, StorageScope.PROFILE, JSON.stringify([]))));\n\t\tthis.storageService.remove(EditorResolverService.cacheStorageID, StorageScope.PROFILE);\n\n\t\tthis._register(this.storageService.onWillSaveState(() => {\n\t\t\t// We want to store the glob patterns we would activate on, this allows us to know if we need to await the ext host on startup for opening a resource\n\t\t\tthis.cacheEditors();\n\t\t}));\n\n\t\t// When extensions have registered we no longer need the cache\n\t\tthis._register(this.extensionService.onDidRegisterExtensions(() => {\n\t\t\tthis.cache = undefined;\n\t\t}));\n\t}\n\n\tprivate resolveUntypedInputAndGroup(editor: IUntypedEditorInput, preferredGroup: PreferredGroup | undefined): Promise<[IUntypedEditorInput, IEditorGroup, EditorActivation | undefined] | undefined> | [IUntypedEditorInput, IEditorGroup, EditorActivation | undefined] | undefined {\n\t\tconst untypedEditor = editor;\n\n\t\t// Use the untyped editor to find a group\n\t\tconst findGroupResult = this.instantiationService.invokeFunction(findGroup, untypedEditor, preferredGroup);\n\t\tif (findGroupResult instanceof Promise) {\n\t\t\treturn findGroupResult.then(([group, activation]) => [untypedEditor, group, activation]);\n\t\t} else {\n\t\t\tconst [group, activation] = findGroupResult;\n\t\t\treturn [untypedEditor, group, activation];\n\t\t}\n\t}\n\n\tasync resolveEditor(editor: IUntypedEditorInput, preferredGroup: PreferredGroup | undefined): Promise<ResolvedEditor> {\n\t\t// Update the flattened editors\n\t\tthis._flattenedEditors = this._flattenEditorsMap();\n\n\t\t// Special case: side by side editors requires us to\n\t\t// independently resolve both sides and then build\n\t\t// a side by side editor with the result\n\t\tif (isResourceSideBySideEditorInput(editor)) {\n\t\t\treturn this.doResolveSideBySideEditor(editor, preferredGroup);\n\t\t}\n\n\t\tlet resolvedUntypedAndGroup: [IUntypedEditorInput, IEditorGroup, EditorActivation | undefined] | undefined;\n\t\tconst resolvedUntypedAndGroupResult = this.resolveUntypedInputAndGroup(editor, preferredGroup);\n\t\tif (resolvedUntypedAndGroupResult instanceof Promise) {\n\t\t\tresolvedUntypedAndGroup = await resolvedUntypedAndGroupResult;\n\t\t} else {\n\t\t\tresolvedUntypedAndGroup = resolvedUntypedAndGroupResult;\n\t\t}\n\n\t\tif (!resolvedUntypedAndGroup) {\n\t\t\treturn ResolvedStatus.NONE;\n\t\t}\n\t\t// Get the resolved untyped editor, group, and activation\n\t\tconst [untypedEditor, group, activation] = resolvedUntypedAndGroup;\n\t\tif (activation) {\n\t\t\tuntypedEditor.options = { ...untypedEditor.options, activation };\n\t\t}\n\n\t\tlet resource = EditorResourceAccessor.getCanonicalUri(untypedEditor, { supportSideBySide: SideBySideEditor.PRIMARY });\n\n\t\t// If it was resolved before we await for the extensions to activate and then proceed with resolution or else the backing extensions won't be registered\n\t\tif (this.cache && resource && this.resourceMatchesCache(resource)) {\n\t\t\tawait this.extensionService.whenInstalledExtensionsRegistered();\n\t\t}\n\n\t\t// Undefined resource -> untilted. Other malformed URI's are unresolvable\n\t\tif (resource === undefined) {\n\t\t\tresource = URI.from({ scheme: Schemas.untitled });\n\t\t} else if (resource.scheme === undefined || resource === null) {\n\t\t\treturn ResolvedStatus.NONE;\n\t\t}\n\n\t\tif (untypedEditor.options?.override === EditorResolution.PICK) {\n\t\t\tconst picked = await this.doPickEditor(untypedEditor);\n\t\t\t// If the picker was cancelled we will stop resolving the editor\n\t\t\tif (!picked) {\n\t\t\t\treturn ResolvedStatus.ABORT;\n\t\t\t}\n\t\t\t// Populate the options with the new ones\n\t\t\tuntypedEditor.options = picked;\n\t\t}\n\n\t\t// Resolved the editor ID as much as possible, now find a given editor (cast here is ok because we resolve down to a string above)\n\t\tlet { editor: selectedEditor, conflictingDefault } = this.getEditor(resource, untypedEditor.options?.override as (string | EditorResolution.EXCLUSIVE_ONLY | undefined));\n\t\t// If no editor was found and this was a typed editor or an editor with an explicit override we could not resolve it\n\t\tif (!selectedEditor && (untypedEditor.options?.override || isEditorInputWithOptions(editor))) {\n\t\t\treturn ResolvedStatus.NONE;\n\t\t} else if (!selectedEditor) {\n\t\t\t// Simple untyped editors that we could not resolve will be resolved to the default editor\n\t\t\tconst resolvedEditor = this.getEditor(resource, DEFAULT_EDITOR_ASSOCIATION.id);\n\t\t\tselectedEditor = resolvedEditor?.editor;\n\t\t\tconflictingDefault = resolvedEditor?.conflictingDefault;\n\t\t\tif (!selectedEditor) {\n\t\t\t\treturn ResolvedStatus.NONE;\n\t\t\t}\n\t\t}\n\n\t\t// In the special case of diff editors we do some more work to determine the correct editor for both sides\n\t\tif (isResourceDiffEditorInput(untypedEditor) && untypedEditor.options?.override === undefined) {\n\t\t\tlet resource2 = EditorResourceAccessor.getCanonicalUri(untypedEditor, { supportSideBySide: SideBySideEditor.SECONDARY });\n\t\t\tif (!resource2) {\n\t\t\t\tresource2 = URI.from({ scheme: Schemas.untitled });\n\t\t\t}\n\t\t\tconst { editor: selectedEditor2 } = this.getEditor(resource2, undefined);\n\t\t\tif (!selectedEditor2 || selectedEditor.editorInfo.id !== selectedEditor2.editorInfo.id) {\n\t\t\t\tconst { editor: selectedDiff, conflictingDefault: conflictingDefaultDiff } = this.getEditor(resource, DEFAULT_EDITOR_ASSOCIATION.id);\n\t\t\t\tselectedEditor = selectedDiff;\n\t\t\t\tconflictingDefault = conflictingDefaultDiff;\n\t\t\t}\n\t\t\tif (!selectedEditor) {\n\t\t\t\treturn ResolvedStatus.NONE;\n\t\t\t}\n\t\t}\n\n\t\t// If no override we take the selected editor id so that matches works with the isActive check\n\t\tuntypedEditor.options = { override: selectedEditor.editorInfo.id, ...untypedEditor.options };\n\n\t\t// Check if diff can be created based on prescene of factory function\n\t\tif (selectedEditor.editorFactoryObject.createDiffEditorInput === undefined && isResourceDiffEditorInput(untypedEditor)) {\n\t\t\treturn ResolvedStatus.NONE;\n\t\t}\n\n\t\tconst input = await this.doResolveEditor(untypedEditor, group, selectedEditor);\n\t\tif (conflictingDefault && input) {\n\t\t\t// Show the conflicting default dialog\n\t\t\tawait this.doHandleConflictingDefaults(resource, selectedEditor.editorInfo.label, untypedEditor, input.editor, group);\n\t\t}\n\n\t\tif (input) {\n\t\t\tthis.sendEditorResolutionTelemetry(input.editor);\n\t\t\tif (input.editor.editorId !== selectedEditor.editorInfo.id) {\n\t\t\t\tthis.logService.warn(`Editor ID Mismatch: ${input.editor.editorId} !== ${selectedEditor.editorInfo.id}. This will cause bugs. Please ensure editorInput.editorId matches the registered id`);\n\t\t\t}\n\t\t\treturn { ...input, group };\n\t\t}\n\t\treturn ResolvedStatus.ABORT;\n\t}\n\n\tprivate async doResolveSideBySideEditor(editor: IResourceSideBySideEditorInput, preferredGroup: PreferredGroup | undefined): Promise<ResolvedEditor> {\n\t\tconst primaryResolvedEditor = await this.resolveEditor(editor.primary, preferredGroup);\n\t\tif (!isEditorInputWithOptionsAndGroup(primaryResolvedEditor)) {\n\t\t\treturn ResolvedStatus.NONE;\n\t\t}\n\t\tconst secondaryResolvedEditor = await this.resolveEditor(editor.secondary, primaryResolvedEditor.group ?? preferredGroup);\n\t\tif (!isEditorInputWithOptionsAndGroup(secondaryResolvedEditor)) {\n\t\t\treturn ResolvedStatus.NONE;\n\t\t}\n\t\treturn {\n\t\t\tgroup: primaryResolvedEditor.group ?? secondaryResolvedEditor.group,\n\t\t\teditor: this.instantiationService.createInstance(SideBySideEditorInput, editor.label, editor.description, secondaryResolvedEditor.editor, primaryResolvedEditor.editor),\n\t\t\toptions: editor.options\n\t\t};\n\t}\n\n\tbufferChangeEvents(callback: Function): void {\n\t\tthis._onDidChangeEditorRegistrations.pause();\n\t\ttry {\n\t\t\tcallback();\n\t\t} finally {\n\t\t\tthis._onDidChangeEditorRegistrations.resume();\n\t\t}\n\t}\n\n\tregisterEditor(\n\t\tglobPattern: string | glob.IRelativePattern,\n\t\teditorInfo: RegisteredEditorInfo,\n\t\toptions: RegisteredEditorOptions,\n\t\teditorFactoryObject: EditorInputFactoryObject\n\t): IDisposable {\n\t\tlet registeredEditor = this._editors.get(globPattern);\n\t\tif (registeredEditor === undefined) {\n\t\t\tregisteredEditor = new Map<string, RegisteredEditors>();\n\t\t\tthis._editors.set(globPattern, registeredEditor);\n\t\t}\n\n\t\tlet editorsWithId = registeredEditor.get(editorInfo.id);\n\t\tif (editorsWithId === undefined) {\n\t\t\teditorsWithId = [];\n\t\t}\n\t\tconst remove = insert(editorsWithId, {\n\t\t\tglobPattern,\n\t\t\teditorInfo,\n\t\t\toptions,\n\t\t\teditorFactoryObject\n\t\t});\n\t\tregisteredEditor.set(editorInfo.id, editorsWithId);\n\t\tthis._shouldReFlattenEditors = true;\n\t\tthis._onDidChangeEditorRegistrations.fire();\n\t\treturn toDisposable(() => {\n\t\t\tremove();\n\t\t\tif (editorsWithId && editorsWithId.length === 0) {\n\t\t\t\tregisteredEditor?.delete(editorInfo.id);\n\t\t\t}\n\t\t\tthis._shouldReFlattenEditors = true;\n\t\t\tthis._onDidChangeEditorRegistrations.fire();\n\t\t});\n\t}\n\n\tgetAssociationsForResource(resource: URI): EditorAssociations {\n\t\tconst associations = this.getAllUserAssociations();\n\t\tlet matchingAssociations = associations.filter(association => association.filenamePattern && globMatchesResource(association.filenamePattern, resource));\n\t\t// Sort matching associations based on glob length as a longer glob will be more specific\n\t\tmatchingAssociations = matchingAssociations.sort((a, b) => (b.filenamePattern?.length ?? 0) - (a.filenamePattern?.length ?? 0));\n\t\tconst allEditors: RegisteredEditors = this._registeredEditors;\n\t\t// Ensure that the settings are valid editors\n\t\treturn matchingAssociations.filter(association => allEditors.find(c => c.editorInfo.id === association.viewType));\n\t}\n\n\tgetAllUserAssociations(): EditorAssociations {\n\t\tconst inspectedEditorAssociations = this.configurationService.inspect<{ [fileNamePattern: string]: string }>(editorsAssociationsSettingId) || {};\n\t\tconst defaultAssociations = inspectedEditorAssociations.defaultValue ?? {};\n\t\tconst workspaceAssociations = inspectedEditorAssociations.workspaceValue ?? {};\n\t\tconst userAssociations = inspectedEditorAssociations.userValue ?? {};\n\t\tconst rawAssociations: { [fileNamePattern: string]: string } = { ...workspaceAssociations };\n\t\t// We want to apply the default associations and user associations on top of the workspace associations but ignore duplicate keys.\n\t\tfor (const [key, value] of Object.entries({ ...defaultAssociations, ...userAssociations })) {\n\t\t\tif (rawAssociations[key] === undefined) {\n\t\t\t\trawAssociations[key] = value;\n\t\t\t}\n\t\t}\n\t\tconst associations = [];\n\t\tfor (const [key, value] of Object.entries(rawAssociations)) {\n\t\t\tconst association: EditorAssociation = {\n\t\t\t\tfilenamePattern: key,\n\t\t\t\tviewType: value\n\t\t\t};\n\t\t\tassociations.push(association);\n\t\t}\n\t\treturn associations;\n\t}\n\n\t/**\n\t * Given the nested nature of the editors map, we merge factories of the same glob and id to make it flat\n\t * and easier to work with\n\t */\n\tprivate _flattenEditorsMap() {\n\t\t// If we shouldn't be re-flattening (due to lack of update) then return early\n\t\tif (!this._shouldReFlattenEditors) {\n\t\t\treturn this._flattenedEditors;\n\t\t}\n\t\tthis._shouldReFlattenEditors = false;\n\t\tconst editors = new Map<string | glob.IRelativePattern, RegisteredEditors>();\n\t\tfor (const [glob, value] of this._editors) {\n\t\t\tconst registeredEditors: RegisteredEditors = [];\n\t\t\tfor (const editors of value.values()) {\n\t\t\t\tlet registeredEditor: RegisteredEditor | undefined = undefined;\n\t\t\t\t// Merge all editors with the same id and glob pattern together\n\t\t\t\tfor (const editor of editors) {\n\t\t\t\t\tif (!registeredEditor) {\n\t\t\t\t\t\tregisteredEditor = {\n\t\t\t\t\t\t\teditorInfo: editor.editorInfo,\n\t\t\t\t\t\t\tglobPattern: editor.globPattern,\n\t\t\t\t\t\t\toptions: {},\n\t\t\t\t\t\t\teditorFactoryObject: {}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\t// Merge options and factories\n\t\t\t\t\tregisteredEditor.options = { ...registeredEditor.options, ...editor.options };\n\t\t\t\t\tregisteredEditor.editorFactoryObject = { ...registeredEditor.editorFactoryObject, ...editor.editorFactoryObject };\n\t\t\t\t}\n\t\t\t\tif (registeredEditor) {\n\t\t\t\t\tregisteredEditors.push(registeredEditor);\n\t\t\t\t}\n\t\t\t}\n\t\t\teditors.set(glob, registeredEditors);\n\t\t}\n\t\treturn editors;\n\t}\n\n\t/**\n\t * Returns all editors as an array. Possible to contain duplicates\n\t */\n\tprivate get _registeredEditors(): RegisteredEditors {\n\t\treturn Array.from(this._flattenedEditors.values()).flat();\n\t}\n\n\tupdateUserAssociations(globPattern: string, editorID: string): void {\n\t\tconst newAssociation: EditorAssociation = { viewType: editorID, filenamePattern: globPattern };\n\t\tconst currentAssociations = this.getAllUserAssociations();\n\t\tconst newSettingObject = Object.create(null);\n\t\t// Form the new setting object including the newest associations\n\t\tfor (const association of [...currentAssociations, newAssociation]) {\n\t\t\tif (association.filenamePattern) {\n\t\t\t\tnewSettingObject[association.filenamePattern] = association.viewType;\n\t\t\t}\n\t\t}\n\t\tthis.configurationService.updateValue(editorsAssociationsSettingId, newSettingObject);\n\t}\n\n\tprivate findMatchingEditors(resource: URI): RegisteredEditor[] {\n\t\t// The user setting should be respected even if the editor doesn't specify that resource in package.json\n\t\tconst userSettings = this.getAssociationsForResource(resource);\n\t\tconst matchingEditors: RegisteredEditor[] = [];\n\t\t// Then all glob patterns\n\t\tfor (const [key, editors] of this._flattenedEditors) {\n\t\t\tfor (const editor of editors) {\n\t\t\t\tconst foundInSettings = userSettings.find(setting => setting.viewType === editor.editorInfo.id);\n\t\t\t\tif ((foundInSettings && editor.editorInfo.priority !== RegisteredEditorPriority.exclusive) || globMatchesResource(key, resource)) {\n\t\t\t\t\tmatchingEditors.push(editor);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Return the editors sorted by their priority\n\t\treturn matchingEditors.sort((a, b) => {\n\t\t\t// Very crude if priorities match longer glob wins as longer globs are normally more specific\n\t\t\tif (priorityToRank(b.editorInfo.priority) === priorityToRank(a.editorInfo.priority) && typeof b.globPattern === 'string' && typeof a.globPattern === 'string') {\n\t\t\t\treturn b.globPattern.length - a.globPattern.length;\n\t\t\t}\n\t\t\treturn priorityToRank(b.editorInfo.priority) - priorityToRank(a.editorInfo.priority);\n\t\t});\n\t}\n\n\tpublic getEditors(resource?: URI): RegisteredEditorInfo[] {\n\t\tthis._flattenedEditors = this._flattenEditorsMap();\n\n\t\t// By resource\n\t\tif (URI.isUri(resource)) {\n\t\t\tconst editors = this.findMatchingEditors(resource);\n\t\t\tif (editors.find(e => e.editorInfo.priority === RegisteredEditorPriority.exclusive)) {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t\treturn editors.map(editor => editor.editorInfo);\n\t\t}\n\n\t\t// All\n\t\treturn distinct(this._registeredEditors.map(editor => editor.editorInfo), editor => editor.id);\n\t}\n\n\t/**\n\t * Given a resource and an editorId selects the best possible editor\n\t * @returns The editor and whether there was another default which conflicted with it\n\t */\n\tprivate getEditor(resource: URI, editorId: string | EditorResolution.EXCLUSIVE_ONLY | undefined): { editor: RegisteredEditor | undefined; conflictingDefault: boolean } {\n\n\t\tconst findMatchingEditor = (editors: RegisteredEditors, viewType: string) => {\n\t\t\treturn editors.find((editor) => {\n\t\t\t\tif (editor.options && editor.options.canSupportResource !== undefined) {\n\t\t\t\t\treturn editor.editorInfo.id === viewType && editor.options.canSupportResource(resource);\n\t\t\t\t}\n\t\t\t\treturn editor.editorInfo.id === viewType;\n\t\t\t});\n\t\t};\n\n\t\tif (editorId && editorId !== EditorResolution.EXCLUSIVE_ONLY) {\n\t\t\t// Specific id passed in doesn't have to match the resource, it can be anything\n\t\t\tconst registeredEditors = this._registeredEditors;\n\t\t\treturn {\n\t\t\t\teditor: findMatchingEditor(registeredEditors, editorId),\n\t\t\t\tconflictingDefault: false\n\t\t\t};\n\t\t}\n\n\t\tconst editors = this.findMatchingEditors(resource);\n\n\t\tconst associationsFromSetting = this.getAssociationsForResource(resource);\n\t\t// We only want minPriority+ if no user defined setting is found, else we won't resolve an editor\n\t\tconst minPriority = editorId === EditorResolution.EXCLUSIVE_ONLY ? RegisteredEditorPriority.exclusive : RegisteredEditorPriority.builtin;\n\t\tlet possibleEditors = editors.filter(editor => priorityToRank(editor.editorInfo.priority) >= priorityToRank(minPriority) && editor.editorInfo.id !== DEFAULT_EDITOR_ASSOCIATION.id);\n\t\tif (possibleEditors.length === 0) {\n\t\t\treturn {\n\t\t\t\teditor: associationsFromSetting[0] && minPriority !== RegisteredEditorPriority.exclusive ? findMatchingEditor(editors, associationsFromSetting[0].viewType) : undefined,\n\t\t\t\tconflictingDefault: false\n\t\t\t};\n\t\t}\n\t\t// If the editor is exclusive we use that, else use the user setting, else use the built-in+ editor\n\t\tconst selectedViewType = possibleEditors[0].editorInfo.priority === RegisteredEditorPriority.exclusive ?\n\t\t\tpossibleEditors[0].editorInfo.id :\n\t\t\tassociationsFromSetting[0]?.viewType || possibleEditors[0].editorInfo.id;\n\n\t\tlet conflictingDefault = false;\n\n\t\t// Filter out exclusive before we check for conflicts as exclusive editors cannot be manually chosen\n\t\tpossibleEditors = possibleEditors.filter(editor => editor.editorInfo.priority !== RegisteredEditorPriority.exclusive);\n\t\tif (associationsFromSetting.length === 0 && possibleEditors.length > 1) {\n\t\t\tconflictingDefault = true;\n\t\t}\n\n\t\treturn {\n\t\t\teditor: findMatchingEditor(editors, selectedViewType),\n\t\t\tconflictingDefault\n\t\t};\n\t}\n\n\tprivate async doResolveEditor(editor: IUntypedEditorInput, group: IEditorGroup, selectedEditor: RegisteredEditor): Promise<EditorInputWithOptions | undefined> {\n\t\tlet options = editor.options;\n\t\tconst resource = EditorResourceAccessor.getCanonicalUri(editor, { supportSideBySide: SideBySideEditor.PRIMARY });\n\t\t// If no activation option is provided, populate it.\n\t\tif (options && typeof options.activation === 'undefined') {\n\t\t\toptions = { ...options, activation: options.preserveFocus ? EditorActivation.RESTORE : undefined };\n\t\t}\n\n\t\t// If it's a merge editor we trigger the create merge editor input\n\t\tif (isResourceMergeEditorInput(editor)) {\n\t\t\tif (!selectedEditor.editorFactoryObject.createMergeEditorInput) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst inputWithOptions = await selectedEditor.editorFactoryObject.createMergeEditorInput(editor, group);\n\t\t\treturn { editor: inputWithOptions.editor, options: inputWithOptions.options ?? options };\n\t\t}\n\n\t\t// If it's a diff editor we trigger the create diff editor input\n\t\tif (isResourceDiffEditorInput(editor)) {\n\t\t\tif (!selectedEditor.editorFactoryObject.createDiffEditorInput) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst inputWithOptions = await selectedEditor.editorFactoryObject.createDiffEditorInput(editor, group);\n\t\t\treturn { editor: inputWithOptions.editor, options: inputWithOptions.options ?? options };\n\t\t}\n\n\t\t// If it's a diff list editor we trigger the create diff list editor input\n\t\tif (isResourceMultiDiffEditorInput(editor)) {\n\t\t\tif (!selectedEditor.editorFactoryObject.createMultiDiffEditorInput) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst inputWithOptions = await selectedEditor.editorFactoryObject.createMultiDiffEditorInput(editor, group);\n\t\t\treturn { editor: inputWithOptions.editor, options: inputWithOptions.options ?? options };\n\t\t}\n\n\t\tif (isResourceSideBySideEditorInput(editor)) {\n\t\t\tthrow new Error(`Untyped side by side editor input not supported here.`);\n\t\t}\n\n\t\tif (isUntitledResourceEditorInput(editor)) {\n\t\t\tif (!selectedEditor.editorFactoryObject.createUntitledEditorInput) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst inputWithOptions = await selectedEditor.editorFactoryObject.createUntitledEditorInput(editor, group);\n\t\t\treturn { editor: inputWithOptions.editor, options: inputWithOptions.options ?? options };\n\t\t}\n\n\t\t// Should no longer have an undefined resource so lets throw an error if that's somehow the case\n\t\tif (resource === undefined) {\n\t\t\tthrow new Error(`Undefined resource on non untitled editor input.`);\n\t\t}\n\n\t\t// If the editor states it can only be opened once per resource we must close all existing ones except one and move the new one into the group\n\t\tconst singleEditorPerResource = typeof selectedEditor.options?.singlePerResource === 'function' ? selectedEditor.options.singlePerResource() : selectedEditor.options?.singlePerResource;\n\t\tif (singleEditorPerResource) {\n\t\t\tconst existingEditors = this.findExistingEditorsForResource(resource, selectedEditor.editorInfo.id);\n\t\t\tif (existingEditors.length) {\n\t\t\t\tconst editor = await this.moveExistingEditorForResource(existingEditors, group);\n\t\t\t\tif (editor) {\n\t\t\t\t\treturn { editor, options };\n\t\t\t\t} else {\n\t\t\t\t\treturn; // failed to move\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If no factory is above, return flow back to caller letting them know we could not resolve it\n\t\tif (!selectedEditor.editorFactoryObject.createEditorInput) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Respect options passed back\n\t\tconst inputWithOptions = await selectedEditor.editorFactoryObject.createEditorInput(editor, group);\n\t\toptions = inputWithOptions.options ?? options;\n\t\tconst input = inputWithOptions.editor;\n\n\t\treturn { editor: input, options };\n\t}\n\n\t/**\n\t * Moves the first existing editor for a resource to the target group unless already opened there.\n\t * Additionally will close any other editors that are open for that resource and viewtype besides the first one found\n\t * @param resource The resource of the editor\n\t * @param viewType the viewtype of the editor\n\t * @param targetGroup The group to move it to\n\t * @returns The moved editor input or `undefined` if the editor could not be moved\n\t */\n\tprivate async moveExistingEditorForResource(\n\t\texistingEditorsForResource: Array<{ editor: EditorInput; group: IEditorGroup }>,\n\t\ttargetGroup: IEditorGroup,\n\t): Promise<EditorInput | undefined> {\n\t\tconst editorToUse = existingEditorsForResource[0];\n\n\t\t// We should only have one editor but if there are multiple we close the others\n\t\tfor (const { editor, group } of existingEditorsForResource) {\n\t\t\tif (editor !== editorToUse.editor) {\n\t\t\t\tconst closed = await group.closeEditor(editor);\n\t\t\t\tif (!closed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Move the editor already opened to the target group\n\t\tif (targetGroup.id !== editorToUse.group.id) {\n\t\t\tconst moved = editorToUse.group.moveEditor(editorToUse.editor, targetGroup);\n\t\t\tif (!moved) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\treturn editorToUse.editor;\n\t}\n\n\t/**\n\t * Given a resource and an editorId, returns all editors open for that resource and editorId.\n\t * @param resource The resource specified\n\t * @param editorId The editorID\n\t * @returns A list of editors\n\t */\n\tprivate findExistingEditorsForResource(\n\t\tresource: URI,\n\t\teditorId: string,\n\t): Array<{ editor: EditorInput; group: IEditorGroup }> {\n\t\tconst out: Array<{ editor: EditorInput; group: IEditorGroup }> = [];\n\t\tconst orderedGroups = distinct([\n\t\t\t...this.editorGroupService.groups,\n\t\t]);\n\n\t\tfor (const group of orderedGroups) {\n\t\t\tfor (const editor of group.editors) {\n\t\t\t\tif (isEqual(editor.resource, resource) && editor.editorId === editorId) {\n\t\t\t\t\tout.push({ editor, group });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn out;\n\t}\n\n\tprivate async doHandleConflictingDefaults(resource: URI, editorName: string, untypedInput: IUntypedEditorInput, currentEditor: EditorInput, group: IEditorGroup) {\n\t\ttype StoredChoice = {\n\t\t\t[key: string]: string[];\n\t\t};\n\t\tconst editors = this.findMatchingEditors(resource);\n\t\tconst storedChoices: StoredChoice = JSON.parse(this.storageService.get(EditorResolverService.conflictingDefaultsStorageID, StorageScope.PROFILE, '{}'));\n\t\tconst globForResource = `*${extname(resource)}`;\n\t\t// Writes to the storage service that a choice has been made for the currently installed editors\n\t\tconst writeCurrentEditorsToStorage = () => {\n\t\t\tstoredChoices[globForResource] = [];\n\t\t\teditors.forEach(editor => storedChoices[globForResource].push(editor.editorInfo.id));\n\t\t\tthis.storageService.store(EditorResolverService.conflictingDefaultsStorageID, JSON.stringify(storedChoices), StorageScope.PROFILE, StorageTarget.MACHINE);\n\t\t};\n\n\t\t// If the user has already made a choice for this editor we don't want to ask them again\n\t\tif (storedChoices[globForResource] && storedChoices[globForResource].find(editorID => editorID === currentEditor.editorId)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst handle = this.notificationService.prompt(Severity.Warning,\n\t\t\tlocalize('editorResolver.conflictingDefaults', 'There are multiple default editors available for the resource.'),\n\t\t\t[{\n\t\t\t\tlabel: localize('editorResolver.configureDefault', 'Configure Default'),\n\t\t\t\trun: async () => {\n\t\t\t\t\t// Show the picker and tell it to update the setting to whatever the user selected\n\t\t\t\t\tconst picked = await this.doPickEditor(untypedInput, true);\n\t\t\t\t\tif (!picked) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tuntypedInput.options = picked;\n\t\t\t\t\tconst replacementEditor = await this.resolveEditor(untypedInput, group);\n\t\t\t\t\tif (replacementEditor === ResolvedStatus.ABORT || replacementEditor === ResolvedStatus.NONE) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// Replace the current editor with the picked one\n\t\t\t\t\tgroup.replaceEditors([\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\teditor: currentEditor,\n\t\t\t\t\t\t\treplacement: replacementEditor.editor,\n\t\t\t\t\t\t\toptions: replacementEditor.options ?? picked,\n\t\t\t\t\t\t}\n\t\t\t\t\t]);\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: localize('editorResolver.keepDefault', 'Keep {0}', editorName),\n\t\t\t\trun: writeCurrentEditorsToStorage\n\t\t\t}\n\t\t\t]);\n\t\t// If the user pressed X we assume they want to keep the current editor as default\n\t\tconst onCloseListener = handle.onDidClose(() => {\n\t\t\twriteCurrentEditorsToStorage();\n\t\t\tonCloseListener.dispose();\n\t\t});\n\t}\n\n\tprivate mapEditorsToQuickPickEntry(resource: URI, showDefaultPicker?: boolean) {\n\t\tconst currentEditor = this.editorGroupService.activeGroup.findEditors(resource).at(0);\n\t\t// If untitled, we want all registered editors\n\t\tlet registeredEditors = resource.scheme === Schemas.untitled ? this._registeredEditors.filter(e => e.editorInfo.priority !== RegisteredEditorPriority.exclusive) : this.findMatchingEditors(resource);\n\t\t// We don't want duplicate Id entries\n\t\tregisteredEditors = distinct(registeredEditors, c => c.editorInfo.id);\n\t\tconst defaultSetting = this.getAssociationsForResource(resource)[0]?.viewType;\n\t\t// Not the most efficient way to do this, but we want to ensure the text editor is at the top of the quickpick\n\t\tregisteredEditors = registeredEditors.sort((a, b) => {\n\t\t\tif (a.editorInfo.id === DEFAULT_EDITOR_ASSOCIATION.id) {\n\t\t\t\treturn -1;\n\t\t\t} else if (b.editorInfo.id === DEFAULT_EDITOR_ASSOCIATION.id) {\n\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\treturn priorityToRank(b.editorInfo.priority) - priorityToRank(a.editorInfo.priority);\n\t\t\t}\n\t\t});\n\t\tconst quickPickEntries: Array<QuickPickItem> = [];\n\t\tconst currentlyActiveLabel = localize('promptOpenWith.currentlyActive', \"Active\");\n\t\tconst currentDefaultLabel = localize('promptOpenWith.currentDefault', \"Default\");\n\t\tconst currentDefaultAndActiveLabel = localize('promptOpenWith.currentDefaultAndActive', \"Active and Default\");\n\t\t// Default order = setting -> highest priority -> text\n\t\tlet defaultViewType = defaultSetting;\n\t\tif (!defaultViewType && registeredEditors.length > 2 && registeredEditors[1]?.editorInfo.priority !== RegisteredEditorPriority.option) {\n\t\t\tdefaultViewType = registeredEditors[1]?.editorInfo.id;\n\t\t}\n\t\tif (!defaultViewType) {\n\t\t\tdefaultViewType = DEFAULT_EDITOR_ASSOCIATION.id;\n\t\t}\n\t\t// Map the editors to quickpick entries\n\t\tregisteredEditors.forEach(editor => {\n\t\t\tconst currentViewType = currentEditor?.editorId ?? DEFAULT_EDITOR_ASSOCIATION.id;\n\t\t\tconst isActive = currentEditor ? editor.editorInfo.id === currentViewType : false;\n\t\t\tconst isDefault = editor.editorInfo.id === defaultViewType;\n\t\t\tconst quickPickEntry: IQuickPickItem = {\n\t\t\t\tid: editor.editorInfo.id,\n\t\t\t\tlabel: editor.editorInfo.label,\n\t\t\t\tdescription: isActive && isDefault ? currentDefaultAndActiveLabel : isActive ? currentlyActiveLabel : isDefault ? currentDefaultLabel : undefined,\n\t\t\t\tdetail: editor.editorInfo.detail ?? editor.editorInfo.priority,\n\t\t\t};\n\t\t\tquickPickEntries.push(quickPickEntry);\n\t\t});\n\t\tif (!showDefaultPicker && extname(resource) !== '') {\n\t\t\tconst separator: IQuickPickSeparator = { type: 'separator' };\n\t\t\tquickPickEntries.push(separator);\n\t\t\tconst configureDefaultEntry = {\n\t\t\t\tid: EditorResolverService.configureDefaultID,\n\t\t\t\tlabel: localize('promptOpenWith.configureDefault', \"Configure default editor for '{0}'...\", `*${extname(resource)}`),\n\t\t\t};\n\t\t\tquickPickEntries.push(configureDefaultEntry);\n\t\t}\n\t\treturn quickPickEntries;\n\t}\n\n\tprivate async doPickEditor(editor: IUntypedEditorInput, showDefaultPicker?: boolean): Promise<IEditorOptions | undefined> {\n\n\t\ttype EditorPick = {\n\t\t\treadonly item: IQuickPickItem;\n\t\t\treadonly keyMods?: IKeyMods;\n\t\t\treadonly openInBackground: boolean;\n\t\t};\n\n\t\tlet resource = EditorResourceAccessor.getOriginalUri(editor, { supportSideBySide: SideBySideEditor.PRIMARY });\n\n\t\tif (resource === undefined) {\n\t\t\tresource = URI.from({ scheme: Schemas.untitled });\n\t\t}\n\n\t\t// Get all the editors for the resource as quickpick entries\n\t\tconst editorPicks = this.mapEditorsToQuickPickEntry(resource, showDefaultPicker);\n\n\t\t// Create the editor picker\n\t\tconst disposables = new DisposableStore();\n\t\tconst editorPicker = disposables.add(this.quickInputService.createQuickPick<IQuickPickItem>({ useSeparators: true }));\n\t\tconst placeHolderMessage = showDefaultPicker ?\n\t\t\tlocalize('promptOpenWith.updateDefaultPlaceHolder', \"Select new default editor for '{0}'\", `*${extname(resource)}`) :\n\t\t\tlocalize('promptOpenWith.placeHolder', \"Select editor for '{0}'\", basename(resource));\n\t\teditorPicker.placeholder = placeHolderMessage;\n\t\teditorPicker.canAcceptInBackground = true;\n\t\teditorPicker.items = editorPicks;\n\t\tconst firstItem = editorPicker.items.find(item => item.type === 'item') as IQuickPickItem | undefined;\n\t\tif (firstItem) {\n\t\t\teditorPicker.selectedItems = [firstItem];\n\t\t}\n\n\t\t// Prompt the user to select an editor\n\t\tconst picked: EditorPick | undefined = await new Promise<EditorPick | undefined>(resolve => {\n\t\t\tdisposables.add(editorPicker.onDidAccept(e => {\n\t\t\t\tlet result: EditorPick | undefined = undefined;\n\n\t\t\t\tif (editorPicker.selectedItems.length === 1) {\n\t\t\t\t\tresult = {\n\t\t\t\t\t\titem: editorPicker.selectedItems[0],\n\t\t\t\t\t\tkeyMods: editorPicker.keyMods,\n\t\t\t\t\t\topenInBackground: e.inBackground\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// If asked to always update the setting then update it even if the gear isn't clicked\n\t\t\t\tif (resource && showDefaultPicker && result?.item.id) {\n\t\t\t\t\tthis.updateUserAssociations(`*${extname(resource)}`, result.item.id,);\n\t\t\t\t}\n\n\t\t\t\tresolve(result);\n\t\t\t}));\n\n\t\t\tdisposables.add(editorPicker.onDidHide(() => {\n\t\t\t\tdisposables.dispose();\n\t\t\t\tresolve(undefined);\n\t\t\t}));\n\n\t\t\tdisposables.add(editorPicker.onDidTriggerItemButton(e => {\n\n\t\t\t\t// Trigger opening and close picker\n\t\t\t\tresolve({ item: e.item, openInBackground: false });\n\n\t\t\t\t// Persist setting\n\t\t\t\tif (resource && e.item && e.item.id) {\n\t\t\t\t\tthis.updateUserAssociations(`*${extname(resource)}`, e.item.id,);\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\teditorPicker.show();\n\t\t});\n\n\t\t// Close picker\n\t\teditorPicker.dispose();\n\n\t\t// If the user picked an editor, look at how the picker was\n\t\t// used (e.g. modifier keys, open in background) and create the\n\t\t// options and group to use accordingly\n\t\tif (picked) {\n\n\t\t\t// If the user selected to configure default we trigger this picker again and tell it to show the default picker\n\t\t\tif (picked.item.id === EditorResolverService.configureDefaultID) {\n\t\t\t\treturn this.doPickEditor(editor, true);\n\t\t\t}\n\n\t\t\t// Figure out options\n\t\t\tconst targetOptions: IEditorOptions = {\n\t\t\t\t...editor.options,\n\t\t\t\toverride: picked.item.id,\n\t\t\t\tpreserveFocus: picked.openInBackground || editor.options?.preserveFocus,\n\t\t\t};\n\n\t\t\treturn targetOptions;\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate sendEditorResolutionTelemetry(chosenInput: EditorInput): void {\n\t\ttype editorResolutionClassification = {\n\t\t\tviewType: { classification: 'PublicNonPersonalData'; purpose: 'FeatureInsight'; comment: 'The id of the editor opened. Used to gain an understanding of what editors are most popular' };\n\t\t\towner: 'lramos15';\n\t\t\tcomment: 'An event that fires when an editor type is picked';\n\t\t};\n\t\ttype editorResolutionEvent = {\n\t\t\tviewType: string;\n\t\t};\n\t\tif (chosenInput.editorId) {\n\t\t\tthis.telemetryService.publicLog2<editorResolutionEvent, editorResolutionClassification>('override.viewType', { viewType: chosenInput.editorId });\n\t\t}\n\t}\n\n\tprivate cacheEditors() {\n\t\t// Create a set to store glob patterns\n\t\tconst cacheStorage: Set<string> = new Set<string>();\n\n\t\t// Store just the relative pattern pieces without any path info\n\t\tfor (const [globPattern, contribPoint] of this._flattenedEditors) {\n\t\t\tconst nonOptional = !!contribPoint.find(c => c.editorInfo.priority !== RegisteredEditorPriority.option && c.editorInfo.id !== DEFAULT_EDITOR_ASSOCIATION.id);\n\t\t\t// Don't keep a cache of the optional ones as those wouldn't be opened on start anyways\n\t\t\tif (!nonOptional) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (glob.isRelativePattern(globPattern)) {\n\t\t\t\tcacheStorage.add(`${globPattern.pattern}`);\n\t\t\t} else {\n\t\t\t\tcacheStorage.add(globPattern);\n\t\t\t}\n\t\t}\n\n\t\t// Also store the users settings as those would have to activate on startup as well\n\t\tconst userAssociations = this.getAllUserAssociations();\n\t\tfor (const association of userAssociations) {\n\t\t\tif (association.filenamePattern) {\n\t\t\t\tcacheStorage.add(association.filenamePattern);\n\t\t\t}\n\t\t}\n\t\tthis.storageService.store(EditorResolverService.cacheStorageID, JSON.stringify(Array.from(cacheStorage)), StorageScope.PROFILE, StorageTarget.MACHINE);\n\t}\n\n\tprivate resourceMatchesCache(resource: URI): boolean {\n\t\tif (!this.cache) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (const cacheEntry of this.cache) {\n\t\t\tif (globMatchesResource(cacheEntry, resource)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n\nregisterSingleton(IEditorResolverService, EditorResolverService, InstantiationType.Eager);\n"],
  "mappings": "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",
  "names": ["glob", "editors", "inputWithOptions", "editor"]
}
