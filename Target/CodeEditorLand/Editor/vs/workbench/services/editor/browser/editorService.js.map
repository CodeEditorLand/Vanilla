{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/editor/browser/editorService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IResourceEditorInput, IEditorOptions, EditorActivation, IResourceEditorInputIdentifier, ITextResourceEditorInput } from '../../../../platform/editor/common/editor.js';\nimport { SideBySideEditor, IEditorPane, GroupIdentifier, IUntitledTextResourceEditorInput, IResourceDiffEditorInput, EditorInputWithOptions, isEditorInputWithOptions, IEditorIdentifier, IEditorCloseEvent, ITextDiffEditorPane, IRevertOptions, SaveReason, EditorsOrder, IWorkbenchEditorConfiguration, EditorResourceAccessor, IVisibleEditorPane, EditorInputCapabilities, isResourceDiffEditorInput, IUntypedEditorInput, isResourceEditorInput, isEditorInput, isEditorInputWithOptionsAndGroup, IFindEditorOptions, isResourceMergeEditorInput, IEditorWillOpenEvent, IEditorControl } from '../../../common/editor.js';\nimport { EditorInput } from '../../../common/editor/editorInput.js';\nimport { SideBySideEditorInput } from '../../../common/editor/sideBySideEditorInput.js';\nimport { ResourceMap, ResourceSet } from '../../../../base/common/map.js';\nimport { IFileService, FileOperationEvent, FileOperation, FileChangesEvent, FileChangeType } from '../../../../platform/files/common/files.js';\nimport { Event, Emitter } from '../../../../base/common/event.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { joinPath } from '../../../../base/common/resources.js';\nimport { DiffEditorInput } from '../../../common/editor/diffEditorInput.js';\nimport { SideBySideEditor as SideBySideEditorPane } from '../../../browser/parts/editor/sideBySideEditor.js';\nimport { IEditorGroupsService, IEditorGroup, GroupsOrder, IEditorReplacement, isEditorReplacement, ICloseEditorOptions, IEditorGroupsContainer } from '../common/editorGroupsService.js';\nimport { IUntypedEditorReplacement, IEditorService, ISaveEditorsOptions, ISaveAllEditorsOptions, IRevertAllEditorsOptions, IBaseSaveRevertAllEditorOptions, IOpenEditorsOptions, PreferredGroup, isPreferredGroup, IEditorsChangeEvent, ISaveEditorsResult } from '../common/editorService.js';\nimport { IConfigurationChangeEvent, IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { Disposable, IDisposable, dispose, DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { coalesce, distinct } from '../../../../base/common/arrays.js';\nimport { isCodeEditor, isDiffEditor, ICodeEditor, IDiffEditor, isCompositeEditor } from '../../../../editor/browser/editorBrowser.js';\nimport { IEditorGroupView, EditorServiceImpl } from '../../../browser/parts/editor/editor.js';\nimport { registerSingleton } from '../../../../platform/instantiation/common/extensions.js';\nimport { isUndefined } from '../../../../base/common/types.js';\nimport { EditorsObserver } from '../../../browser/parts/editor/editorsObserver.js';\nimport { Promises, timeout } from '../../../../base/common/async.js';\nimport { IWorkspaceContextService } from '../../../../platform/workspace/common/workspace.js';\nimport { indexOfPath } from '../../../../base/common/extpath.js';\nimport { IUriIdentityService } from '../../../../platform/uriIdentity/common/uriIdentity.js';\nimport { IEditorResolverService, ResolvedStatus } from '../common/editorResolverService.js';\nimport { IWorkspaceTrustRequestService, WorkspaceTrustUriResponse } from '../../../../platform/workspace/common/workspaceTrust.js';\nimport { IHostService } from '../../host/browser/host.js';\nimport { findGroup } from '../common/editorGroupFinder.js';\nimport { ITextEditorService } from '../../textfile/common/textEditorService.js';\nimport { SyncDescriptor } from '../../../../platform/instantiation/common/descriptors.js';\n\nexport class EditorService extends Disposable implements EditorServiceImpl {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\t//#region events\n\n\tprivate readonly _onDidActiveEditorChange = this._register(new Emitter<void>());\n\treadonly onDidActiveEditorChange = this._onDidActiveEditorChange.event;\n\n\tprivate readonly _onDidVisibleEditorsChange = this._register(new Emitter<void>());\n\treadonly onDidVisibleEditorsChange = this._onDidVisibleEditorsChange.event;\n\n\tprivate readonly _onDidEditorsChange = this._register(new Emitter<IEditorsChangeEvent>());\n\treadonly onDidEditorsChange = this._onDidEditorsChange.event;\n\n\tprivate readonly _onWillOpenEditor = this._register(new Emitter<IEditorWillOpenEvent>());\n\treadonly onWillOpenEditor = this._onWillOpenEditor.event;\n\n\tprivate readonly _onDidCloseEditor = this._register(new Emitter<IEditorCloseEvent>());\n\treadonly onDidCloseEditor = this._onDidCloseEditor.event;\n\n\tprivate readonly _onDidOpenEditorFail = this._register(new Emitter<IEditorIdentifier>());\n\treadonly onDidOpenEditorFail = this._onDidOpenEditorFail.event;\n\n\tprivate readonly _onDidMostRecentlyActiveEditorsChange = this._register(new Emitter<void>());\n\treadonly onDidMostRecentlyActiveEditorsChange = this._onDidMostRecentlyActiveEditorsChange.event;\n\n\t//#endregion\n\n\tprivate readonly editorGroupsContainer: IEditorGroupsContainer;\n\n\tconstructor(\n\t\teditorGroupsContainer: IEditorGroupsContainer | undefined,\n\t\t@IEditorGroupsService private readonly editorGroupService: IEditorGroupsService,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService,\n\t\t@IFileService private readonly fileService: IFileService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t\t@IWorkspaceContextService private readonly contextService: IWorkspaceContextService,\n\t\t@IUriIdentityService private readonly uriIdentityService: IUriIdentityService,\n\t\t@IEditorResolverService private readonly editorResolverService: IEditorResolverService,\n\t\t@IWorkspaceTrustRequestService private readonly workspaceTrustRequestService: IWorkspaceTrustRequestService,\n\t\t@IHostService private readonly hostService: IHostService,\n\t\t@ITextEditorService private readonly textEditorService: ITextEditorService\n\t) {\n\t\tsuper();\n\n\t\tthis.editorGroupsContainer = editorGroupsContainer ?? editorGroupService;\n\t\tthis.editorsObserver = this._register(this.instantiationService.createInstance(EditorsObserver, this.editorGroupsContainer));\n\n\t\tthis.onConfigurationUpdated();\n\n\t\tthis.registerListeners();\n\t}\n\n\tcreateScoped(editorGroupsContainer: IEditorGroupsContainer | 'main', disposables: DisposableStore): IEditorService {\n\t\treturn disposables.add(new EditorService(editorGroupsContainer === 'main' ? this.editorGroupService.mainPart : editorGroupsContainer, this.editorGroupService, this.instantiationService, this.fileService, this.configurationService, this.contextService, this.uriIdentityService, this.editorResolverService, this.workspaceTrustRequestService, this.hostService, this.textEditorService));\n\t}\n\n\tprivate registerListeners(): void {\n\n\t\t// Editor & group changes\n\t\tif (this.editorGroupsContainer === this.editorGroupService.mainPart || this.editorGroupsContainer === this.editorGroupService) {\n\t\t\tthis.editorGroupService.whenReady.then(() => this.onEditorGroupsReady());\n\t\t} else {\n\t\t\tthis.onEditorGroupsReady();\n\t\t}\n\t\tthis._register(this.editorGroupsContainer.onDidChangeActiveGroup(group => this.handleActiveEditorChange(group)));\n\t\tthis._register(this.editorGroupsContainer.onDidAddGroup(group => this.registerGroupListeners(group as IEditorGroupView)));\n\t\tthis._register(this.editorsObserver.onDidMostRecentlyActiveEditorsChange(() => this._onDidMostRecentlyActiveEditorsChange.fire()));\n\n\t\t// Out of workspace file watchers\n\t\tthis._register(this.onDidVisibleEditorsChange(() => this.handleVisibleEditorsChange()));\n\n\t\t// File changes & operations\n\t\t// Note: there is some duplication with the two file event handlers- Since we cannot always rely on the disk events\n\t\t// carrying all necessary data in all environments, we also use the file operation events to make sure operations are handled.\n\t\t// In any case there is no guarantee if the local event is fired first or the disk one. Thus, code must handle the case\n\t\t// that the event ordering is random as well as might not carry all information needed.\n\t\tthis._register(this.fileService.onDidRunOperation(e => this.onDidRunFileOperation(e)));\n\t\tthis._register(this.fileService.onDidFilesChange(e => this.onDidFilesChange(e)));\n\n\t\t// Configuration\n\t\tthis._register(this.configurationService.onDidChangeConfiguration(e => this.onConfigurationUpdated(e)));\n\t}\n\n\t//#region Editor & group event handlers\n\n\tprivate lastActiveEditor: EditorInput | undefined = undefined;\n\n\tprivate onEditorGroupsReady(): void {\n\n\t\t// Register listeners to each opened group\n\t\tfor (const group of this.editorGroupsContainer.groups) {\n\t\t\tthis.registerGroupListeners(group as IEditorGroupView);\n\t\t}\n\n\t\t// Fire initial set of editor events if there is an active editor\n\t\tif (this.activeEditor) {\n\t\t\tthis.doHandleActiveEditorChangeEvent();\n\t\t\tthis._onDidVisibleEditorsChange.fire();\n\t\t}\n\t}\n\n\tprivate handleActiveEditorChange(group: IEditorGroup): void {\n\t\tif (group !== this.editorGroupsContainer.activeGroup) {\n\t\t\treturn; // ignore if not the active group\n\t\t}\n\n\t\tif (!this.lastActiveEditor && !group.activeEditor) {\n\t\t\treturn; // ignore if we still have no active editor\n\t\t}\n\n\t\tthis.doHandleActiveEditorChangeEvent();\n\t}\n\n\tprivate doHandleActiveEditorChangeEvent(): void {\n\n\t\t// Remember as last active\n\t\tconst activeGroup = this.editorGroupsContainer.activeGroup;\n\t\tthis.lastActiveEditor = activeGroup.activeEditor ?? undefined;\n\n\t\t// Fire event to outside parties\n\t\tthis._onDidActiveEditorChange.fire();\n\t}\n\n\tprivate registerGroupListeners(group: IEditorGroupView): void {\n\t\tconst groupDisposables = new DisposableStore();\n\n\t\tgroupDisposables.add(group.onDidModelChange(e => {\n\t\t\tthis._onDidEditorsChange.fire({ groupId: group.id, event: e });\n\t\t}));\n\n\t\tgroupDisposables.add(group.onDidActiveEditorChange(() => {\n\t\t\tthis.handleActiveEditorChange(group);\n\t\t\tthis._onDidVisibleEditorsChange.fire();\n\t\t}));\n\n\t\tgroupDisposables.add(group.onWillOpenEditor(e => {\n\t\t\tthis._onWillOpenEditor.fire(e);\n\t\t}));\n\n\t\tgroupDisposables.add(group.onDidCloseEditor(e => {\n\t\t\tthis._onDidCloseEditor.fire(e);\n\t\t}));\n\n\t\tgroupDisposables.add(group.onDidOpenEditorFail(editor => {\n\t\t\tthis._onDidOpenEditorFail.fire({ editor, groupId: group.id });\n\t\t}));\n\n\t\tEvent.once(group.onWillDispose)(() => {\n\t\t\tdispose(groupDisposables);\n\t\t});\n\t}\n\n\t//#endregion\n\n\t//#region Visible Editors Change: Install file watchers for out of workspace resources that became visible\n\n\tprivate readonly activeOutOfWorkspaceWatchers = new ResourceMap<IDisposable>();\n\n\tprivate handleVisibleEditorsChange(): void {\n\t\tconst visibleOutOfWorkspaceResources = new ResourceSet();\n\n\t\tfor (const editor of this.visibleEditors) {\n\t\t\tconst resources = distinct(coalesce([\n\t\t\t\tEditorResourceAccessor.getCanonicalUri(editor, { supportSideBySide: SideBySideEditor.PRIMARY }),\n\t\t\t\tEditorResourceAccessor.getCanonicalUri(editor, { supportSideBySide: SideBySideEditor.SECONDARY })\n\t\t\t]), resource => resource.toString());\n\n\t\t\tfor (const resource of resources) {\n\t\t\t\tif (this.fileService.hasProvider(resource) && !this.contextService.isInsideWorkspace(resource)) {\n\t\t\t\t\tvisibleOutOfWorkspaceResources.add(resource);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Handle no longer visible out of workspace resources\n\t\tfor (const resource of this.activeOutOfWorkspaceWatchers.keys()) {\n\t\t\tif (!visibleOutOfWorkspaceResources.has(resource)) {\n\t\t\t\tdispose(this.activeOutOfWorkspaceWatchers.get(resource));\n\t\t\t\tthis.activeOutOfWorkspaceWatchers.delete(resource);\n\t\t\t}\n\t\t}\n\n\t\t// Handle newly visible out of workspace resources\n\t\tfor (const resource of visibleOutOfWorkspaceResources.keys()) {\n\t\t\tif (!this.activeOutOfWorkspaceWatchers.get(resource)) {\n\t\t\t\tconst disposable = this.fileService.watch(resource);\n\t\t\t\tthis.activeOutOfWorkspaceWatchers.set(resource, disposable);\n\t\t\t}\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region File Changes: Move & Deletes to move or close opend editors\n\n\tprivate async onDidRunFileOperation(e: FileOperationEvent): Promise<void> {\n\n\t\t// Handle moves specially when file is opened\n\t\tif (e.isOperation(FileOperation.MOVE)) {\n\t\t\tthis.handleMovedFile(e.resource, e.target.resource);\n\t\t}\n\n\t\t// Handle deletes\n\t\tif (e.isOperation(FileOperation.DELETE) || e.isOperation(FileOperation.MOVE)) {\n\t\t\tthis.handleDeletedFile(e.resource, false, e.target ? e.target.resource : undefined);\n\t\t}\n\t}\n\n\tprivate onDidFilesChange(e: FileChangesEvent): void {\n\t\tif (e.gotDeleted()) {\n\t\t\tthis.handleDeletedFile(e, true);\n\t\t}\n\t}\n\n\tprivate async handleMovedFile(source: URI, target: URI): Promise<void> {\n\t\tfor (const group of this.editorGroupsContainer.groups) {\n\t\t\tconst replacements: (IUntypedEditorReplacement | IEditorReplacement)[] = [];\n\n\t\t\tfor (const editor of group.editors) {\n\t\t\t\tconst resource = editor.resource;\n\t\t\t\tif (!resource || !this.uriIdentityService.extUri.isEqualOrParent(resource, source)) {\n\t\t\t\t\tcontinue; // not matching our resource\n\t\t\t\t}\n\n\t\t\t\t// Determine new resulting target resource\n\t\t\t\tlet targetResource: URI;\n\t\t\t\tif (this.uriIdentityService.extUri.isEqual(source, resource)) {\n\t\t\t\t\ttargetResource = target; // file got moved\n\t\t\t\t} else {\n\t\t\t\t\tconst index = indexOfPath(resource.path, source.path, this.uriIdentityService.extUri.ignorePathCasing(resource));\n\t\t\t\t\ttargetResource = joinPath(target, resource.path.substr(index + source.path.length + 1)); // parent folder got moved\n\t\t\t\t}\n\n\t\t\t\t// Delegate rename() to editor instance\n\t\t\t\tconst moveResult = await editor.rename(group.id, targetResource);\n\t\t\t\tif (!moveResult) {\n\t\t\t\t\treturn; // not target - ignore\n\t\t\t\t}\n\n\t\t\t\tconst optionOverrides = {\n\t\t\t\t\tpreserveFocus: true,\n\t\t\t\t\tpinned: group.isPinned(editor),\n\t\t\t\t\tsticky: group.isSticky(editor),\n\t\t\t\t\tindex: group.getIndexOfEditor(editor),\n\t\t\t\t\tinactive: !group.isActive(editor)\n\t\t\t\t};\n\n\t\t\t\t// Construct a replacement with our extra options mixed in\n\t\t\t\tif (isEditorInput(moveResult.editor)) {\n\t\t\t\t\treplacements.push({\n\t\t\t\t\t\teditor,\n\t\t\t\t\t\treplacement: moveResult.editor,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t...moveResult.options,\n\t\t\t\t\t\t\t...optionOverrides\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treplacements.push({\n\t\t\t\t\t\teditor,\n\t\t\t\t\t\treplacement: {\n\t\t\t\t\t\t\t...moveResult.editor,\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t...moveResult.editor.options,\n\t\t\t\t\t\t\t\t...optionOverrides\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Apply replacements\n\t\t\tif (replacements.length) {\n\t\t\t\tthis.replaceEditors(replacements, group);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate closeOnFileDelete: boolean = false;\n\n\tprivate onConfigurationUpdated(e?: IConfigurationChangeEvent): void {\n\t\tif (e && !e.affectsConfiguration('workbench.editor.closeOnFileDelete')) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst configuration = this.configurationService.getValue<IWorkbenchEditorConfiguration>();\n\t\tif (typeof configuration.workbench?.editor?.closeOnFileDelete === 'boolean') {\n\t\t\tthis.closeOnFileDelete = configuration.workbench.editor.closeOnFileDelete;\n\t\t} else {\n\t\t\tthis.closeOnFileDelete = false; // default\n\t\t}\n\t}\n\n\tprivate handleDeletedFile(arg1: URI | FileChangesEvent, isExternal: boolean, movedTo?: URI): void {\n\t\tfor (const editor of this.getAllNonDirtyEditors({ includeUntitled: false, supportSideBySide: true })) {\n\t\t\t(async () => {\n\t\t\t\tconst resource = editor.resource;\n\t\t\t\tif (!resource) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Handle deletes in opened editors depending on:\n\t\t\t\t// - we close any editor when `closeOnFileDelete: true`\n\t\t\t\t// - we close any editor when the delete occurred from within VSCode\n\t\t\t\tif (this.closeOnFileDelete || !isExternal) {\n\n\t\t\t\t\t// Do NOT close any opened editor that matches the resource path (either equal or being parent) of the\n\t\t\t\t\t// resource we move to (movedTo). Otherwise we would close a resource that has been renamed to the same\n\t\t\t\t\t// path but different casing.\n\t\t\t\t\tif (movedTo && this.uriIdentityService.extUri.isEqualOrParent(resource, movedTo)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet matches = false;\n\t\t\t\t\tif (arg1 instanceof FileChangesEvent) {\n\t\t\t\t\t\tmatches = arg1.contains(resource, FileChangeType.DELETED);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmatches = this.uriIdentityService.extUri.isEqualOrParent(resource, arg1);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!matches) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// We have received reports of users seeing delete events even though the file still\n\t\t\t\t\t// exists (network shares issue: https://github.com/microsoft/vscode/issues/13665).\n\t\t\t\t\t// Since we do not want to close an editor without reason, we have to check if the\n\t\t\t\t\t// file is really gone and not just a faulty file event.\n\t\t\t\t\t// This only applies to external file events, so we need to check for the isExternal\n\t\t\t\t\t// flag.\n\t\t\t\t\tlet exists = false;\n\t\t\t\t\tif (isExternal && this.fileService.hasProvider(resource)) {\n\t\t\t\t\t\tawait timeout(100);\n\t\t\t\t\t\texists = await this.fileService.exists(resource);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!exists && !editor.isDisposed()) {\n\t\t\t\t\t\teditor.dispose();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})();\n\t\t}\n\t}\n\n\tprivate getAllNonDirtyEditors(options: { includeUntitled: boolean; supportSideBySide: boolean }): EditorInput[] {\n\t\tconst editors: EditorInput[] = [];\n\n\t\tfunction conditionallyAddEditor(editor: EditorInput): void {\n\t\t\tif (editor.hasCapability(EditorInputCapabilities.Untitled) && !options.includeUntitled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (editor.isDirty()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\teditors.push(editor);\n\t\t}\n\n\t\tfor (const editor of this.editors) {\n\t\t\tif (options.supportSideBySide && editor instanceof SideBySideEditorInput) {\n\t\t\t\tconditionallyAddEditor(editor.primary);\n\t\t\t\tconditionallyAddEditor(editor.secondary);\n\t\t\t} else {\n\t\t\t\tconditionallyAddEditor(editor);\n\t\t\t}\n\t\t}\n\n\t\treturn editors;\n\t}\n\n\t//#endregion\n\n\t//#region Editor accessors\n\n\tprivate readonly editorsObserver: EditorsObserver;\n\n\tget activeEditorPane(): IVisibleEditorPane | undefined {\n\t\treturn this.editorGroupsContainer.activeGroup?.activeEditorPane;\n\t}\n\n\tget activeTextEditorControl(): ICodeEditor | IDiffEditor | undefined {\n\t\tconst activeEditorPane = this.activeEditorPane;\n\t\tif (activeEditorPane) {\n\t\t\tconst activeControl = activeEditorPane.getControl();\n\t\t\tif (isCodeEditor(activeControl) || isDiffEditor(activeControl)) {\n\t\t\t\treturn activeControl;\n\t\t\t}\n\t\t\tif (isCompositeEditor(activeControl) && isCodeEditor(activeControl.activeCodeEditor)) {\n\t\t\t\treturn activeControl.activeCodeEditor;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tget activeTextEditorLanguageId(): string | undefined {\n\t\tlet activeCodeEditor: ICodeEditor | undefined = undefined;\n\n\t\tconst activeTextEditorControl = this.activeTextEditorControl;\n\t\tif (isDiffEditor(activeTextEditorControl)) {\n\t\t\tactiveCodeEditor = activeTextEditorControl.getModifiedEditor();\n\t\t} else {\n\t\t\tactiveCodeEditor = activeTextEditorControl;\n\t\t}\n\n\t\treturn activeCodeEditor?.getModel()?.getLanguageId();\n\t}\n\n\tget count(): number {\n\t\treturn this.editorsObserver.count;\n\t}\n\n\tget editors(): EditorInput[] {\n\t\treturn this.getEditors(EditorsOrder.SEQUENTIAL).map(({ editor }) => editor);\n\t}\n\n\tgetEditors(order: EditorsOrder, options?: { excludeSticky?: boolean }): IEditorIdentifier[] {\n\t\tswitch (order) {\n\n\t\t\t// MRU\n\t\t\tcase EditorsOrder.MOST_RECENTLY_ACTIVE:\n\t\t\t\tif (options?.excludeSticky) {\n\t\t\t\t\treturn this.editorsObserver.editors.filter(({ groupId, editor }) => !this.editorGroupsContainer.getGroup(groupId)?.isSticky(editor));\n\t\t\t\t}\n\n\t\t\t\treturn this.editorsObserver.editors;\n\n\t\t\t// Sequential\n\t\t\tcase EditorsOrder.SEQUENTIAL: {\n\t\t\t\tconst editors: IEditorIdentifier[] = [];\n\n\t\t\t\tfor (const group of this.editorGroupsContainer.getGroups(GroupsOrder.GRID_APPEARANCE)) {\n\t\t\t\t\teditors.push(...group.getEditors(EditorsOrder.SEQUENTIAL, options).map(editor => ({ editor, groupId: group.id })));\n\t\t\t\t}\n\n\t\t\t\treturn editors;\n\t\t\t}\n\t\t}\n\t}\n\n\tget activeEditor(): EditorInput | undefined {\n\t\tconst activeGroup = this.editorGroupsContainer.activeGroup;\n\n\t\treturn activeGroup ? activeGroup.activeEditor ?? undefined : undefined;\n\t}\n\n\tget visibleEditorPanes(): IVisibleEditorPane[] {\n\t\treturn coalesce(this.editorGroupsContainer.groups.map(group => group.activeEditorPane));\n\t}\n\n\tget visibleTextEditorControls(): Array<ICodeEditor | IDiffEditor> {\n\t\tconst visibleTextEditorControls: Array<ICodeEditor | IDiffEditor> = [];\n\t\tfor (const visibleEditorPane of this.visibleEditorPanes) {\n\t\t\tconst controls: Array<IEditorControl | undefined> = [];\n\t\t\tif (visibleEditorPane instanceof SideBySideEditorPane) {\n\t\t\t\tcontrols.push(visibleEditorPane.getPrimaryEditorPane()?.getControl());\n\t\t\t\tcontrols.push(visibleEditorPane.getSecondaryEditorPane()?.getControl());\n\t\t\t} else {\n\t\t\t\tcontrols.push(visibleEditorPane.getControl());\n\t\t\t}\n\n\t\t\tfor (const control of controls) {\n\t\t\t\tif (isCodeEditor(control) || isDiffEditor(control)) {\n\t\t\t\t\tvisibleTextEditorControls.push(control);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn visibleTextEditorControls;\n\t}\n\n\tget visibleEditors(): EditorInput[] {\n\t\treturn coalesce(this.editorGroupsContainer.groups.map(group => group.activeEditor));\n\t}\n\n\t//#endregion\n\n\t//#region openEditor()\n\n\topenEditor(editor: EditorInput, options?: IEditorOptions, group?: PreferredGroup): Promise<IEditorPane | undefined>;\n\topenEditor(editor: IUntypedEditorInput, group?: PreferredGroup): Promise<IEditorPane | undefined>;\n\topenEditor(editor: IResourceEditorInput, group?: PreferredGroup): Promise<IEditorPane | undefined>;\n\topenEditor(editor: ITextResourceEditorInput | IUntitledTextResourceEditorInput, group?: PreferredGroup): Promise<IEditorPane | undefined>;\n\topenEditor(editor: IResourceDiffEditorInput, group?: PreferredGroup): Promise<ITextDiffEditorPane | undefined>;\n\topenEditor(editor: EditorInput | IUntypedEditorInput, optionsOrPreferredGroup?: IEditorOptions | PreferredGroup, preferredGroup?: PreferredGroup): Promise<IEditorPane | undefined>;\n\tasync openEditor(editor: EditorInput | IUntypedEditorInput, optionsOrPreferredGroup?: IEditorOptions | PreferredGroup, preferredGroup?: PreferredGroup): Promise<IEditorPane | undefined> {\n\t\tlet typedEditor: EditorInput | undefined = undefined;\n\t\tlet options = isEditorInput(editor) ? optionsOrPreferredGroup as IEditorOptions : editor.options;\n\t\tlet group: IEditorGroup | undefined = undefined;\n\n\t\tif (isPreferredGroup(optionsOrPreferredGroup)) {\n\t\t\tpreferredGroup = optionsOrPreferredGroup;\n\t\t}\n\n\t\t// Resolve override unless disabled\n\t\tif (!isEditorInput(editor)) {\n\t\t\tconst resolvedEditor = await this.editorResolverService.resolveEditor(editor, preferredGroup);\n\n\t\t\tif (resolvedEditor === ResolvedStatus.ABORT) {\n\t\t\t\treturn; // skip editor if override is aborted\n\t\t\t}\n\n\t\t\t// We resolved an editor to use\n\t\t\tif (isEditorInputWithOptionsAndGroup(resolvedEditor)) {\n\t\t\t\ttypedEditor = resolvedEditor.editor;\n\t\t\t\toptions = resolvedEditor.options;\n\t\t\t\tgroup = resolvedEditor.group;\n\t\t\t}\n\t\t}\n\n\t\t// Override is disabled or did not apply: fallback to default\n\t\tif (!typedEditor) {\n\t\t\ttypedEditor = isEditorInput(editor) ? editor : await this.textEditorService.resolveTextEditor(editor);\n\t\t}\n\n\t\t// If group still isn't defined because of a disabled override we resolve it\n\t\tif (!group) {\n\t\t\tlet activation: EditorActivation | undefined = undefined;\n\t\t\tconst findGroupResult = this.instantiationService.invokeFunction(findGroup, { editor: typedEditor, options }, preferredGroup);\n\t\t\tif (findGroupResult instanceof Promise) {\n\t\t\t\t([group, activation] = await findGroupResult);\n\t\t\t} else {\n\t\t\t\t([group, activation] = findGroupResult);\n\t\t\t}\n\n\t\t\t// Mixin editor group activation if returned\n\t\t\tif (activation) {\n\t\t\t\toptions = { ...options, activation };\n\t\t\t}\n\t\t}\n\n\t\treturn group.openEditor(typedEditor, options);\n\t}\n\n\t//#endregion\n\n\t//#region openEditors()\n\n\topenEditors(editors: EditorInputWithOptions[], group?: PreferredGroup, options?: IOpenEditorsOptions): Promise<IEditorPane[]>;\n\topenEditors(editors: IUntypedEditorInput[], group?: PreferredGroup, options?: IOpenEditorsOptions): Promise<IEditorPane[]>;\n\topenEditors(editors: Array<EditorInputWithOptions | IUntypedEditorInput>, group?: PreferredGroup, options?: IOpenEditorsOptions): Promise<IEditorPane[]>;\n\tasync openEditors(editors: Array<EditorInputWithOptions | IUntypedEditorInput>, preferredGroup?: PreferredGroup, options?: IOpenEditorsOptions): Promise<IEditorPane[]> {\n\n\t\t// Pass all editors to trust service to determine if\n\t\t// we should proceed with opening the editors if we\n\t\t// are asked to validate trust.\n\t\tif (options?.validateTrust) {\n\t\t\tconst editorsTrusted = await this.handleWorkspaceTrust(editors);\n\t\t\tif (!editorsTrusted) {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t}\n\n\t\t// Find target groups for editors to open\n\t\tconst mapGroupToTypedEditors = new Map<IEditorGroup, Array<EditorInputWithOptions>>();\n\t\tfor (const editor of editors) {\n\t\t\tlet typedEditor: EditorInputWithOptions | undefined = undefined;\n\t\t\tlet group: IEditorGroup | undefined = undefined;\n\n\t\t\t// Resolve override unless disabled\n\t\t\tif (!isEditorInputWithOptions(editor)) {\n\t\t\t\tconst resolvedEditor = await this.editorResolverService.resolveEditor(editor, preferredGroup);\n\n\t\t\t\tif (resolvedEditor === ResolvedStatus.ABORT) {\n\t\t\t\t\tcontinue; // skip editor if override is aborted\n\t\t\t\t}\n\n\t\t\t\t// We resolved an editor to use\n\t\t\t\tif (isEditorInputWithOptionsAndGroup(resolvedEditor)) {\n\t\t\t\t\ttypedEditor = resolvedEditor;\n\t\t\t\t\tgroup = resolvedEditor.group;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override is disabled or did not apply: fallback to default\n\t\t\tif (!typedEditor) {\n\t\t\t\ttypedEditor = isEditorInputWithOptions(editor) ? editor : { editor: await this.textEditorService.resolveTextEditor(editor), options: editor.options };\n\t\t\t}\n\n\t\t\t// If group still isn't defined because of a disabled override we resolve it\n\t\t\tif (!group) {\n\t\t\t\tconst findGroupResult = this.instantiationService.invokeFunction(findGroup, typedEditor, preferredGroup);\n\t\t\t\tif (findGroupResult instanceof Promise) {\n\t\t\t\t\t([group] = await findGroupResult);\n\t\t\t\t} else {\n\t\t\t\t\t([group] = findGroupResult);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update map of groups to editors\n\t\t\tlet targetGroupEditors = mapGroupToTypedEditors.get(group);\n\t\t\tif (!targetGroupEditors) {\n\t\t\t\ttargetGroupEditors = [];\n\t\t\t\tmapGroupToTypedEditors.set(group, targetGroupEditors);\n\t\t\t}\n\n\t\t\ttargetGroupEditors.push(typedEditor);\n\t\t}\n\n\t\t// Open in target groups\n\t\tconst result: Promise<IEditorPane | undefined>[] = [];\n\t\tfor (const [group, editors] of mapGroupToTypedEditors) {\n\t\t\tresult.push(group.openEditors(editors));\n\t\t}\n\n\t\treturn coalesce(await Promises.settled(result));\n\t}\n\n\tprivate async handleWorkspaceTrust(editors: Array<EditorInputWithOptions | IUntypedEditorInput>): Promise<boolean> {\n\t\tconst { resources, diffMode, mergeMode } = this.extractEditorResources(editors);\n\n\t\tconst trustResult = await this.workspaceTrustRequestService.requestOpenFilesTrust(resources);\n\t\tswitch (trustResult) {\n\t\t\tcase WorkspaceTrustUriResponse.Open:\n\t\t\t\treturn true;\n\t\t\tcase WorkspaceTrustUriResponse.OpenInNewWindow:\n\t\t\t\tawait this.hostService.openWindow(resources.map(resource => ({ fileUri: resource })), { forceNewWindow: true, diffMode, mergeMode });\n\t\t\t\treturn false;\n\t\t\tcase WorkspaceTrustUriResponse.Cancel:\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate extractEditorResources(editors: Array<EditorInputWithOptions | IUntypedEditorInput>): { resources: URI[]; diffMode?: boolean; mergeMode?: boolean } {\n\t\tconst resources = new ResourceSet();\n\t\tlet diffMode = false;\n\t\tlet mergeMode = false;\n\n\t\tfor (const editor of editors) {\n\n\t\t\t// Typed Editor\n\t\t\tif (isEditorInputWithOptions(editor)) {\n\t\t\t\tconst resource = EditorResourceAccessor.getOriginalUri(editor.editor, { supportSideBySide: SideBySideEditor.BOTH });\n\t\t\t\tif (URI.isUri(resource)) {\n\t\t\t\t\tresources.add(resource);\n\t\t\t\t} else if (resource) {\n\t\t\t\t\tif (resource.primary) {\n\t\t\t\t\t\tresources.add(resource.primary);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (resource.secondary) {\n\t\t\t\t\t\tresources.add(resource.secondary);\n\t\t\t\t\t}\n\n\t\t\t\t\tdiffMode = editor.editor instanceof DiffEditorInput;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Untyped editor\n\t\t\telse {\n\t\t\t\tif (isResourceMergeEditorInput(editor)) {\n\t\t\t\t\tif (URI.isUri(editor.input1)) {\n\t\t\t\t\t\tresources.add(editor.input1.resource);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (URI.isUri(editor.input2)) {\n\t\t\t\t\t\tresources.add(editor.input2.resource);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (URI.isUri(editor.base)) {\n\t\t\t\t\t\tresources.add(editor.base.resource);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (URI.isUri(editor.result)) {\n\t\t\t\t\t\tresources.add(editor.result.resource);\n\t\t\t\t\t}\n\n\t\t\t\t\tmergeMode = true;\n\t\t\t\t} if (isResourceDiffEditorInput(editor)) {\n\t\t\t\t\tif (URI.isUri(editor.original.resource)) {\n\t\t\t\t\t\tresources.add(editor.original.resource);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (URI.isUri(editor.modified.resource)) {\n\t\t\t\t\t\tresources.add(editor.modified.resource);\n\t\t\t\t\t}\n\n\t\t\t\t\tdiffMode = true;\n\t\t\t\t} else if (isResourceEditorInput(editor)) {\n\t\t\t\t\tresources.add(editor.resource);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tresources: Array.from(resources.keys()),\n\t\t\tdiffMode,\n\t\t\tmergeMode\n\t\t};\n\t}\n\n\t//#endregion\n\n\t//#region isOpened() / isVisible()\n\n\tisOpened(editor: IResourceEditorInputIdentifier): boolean {\n\t\treturn this.editorsObserver.hasEditor({\n\t\t\tresource: this.uriIdentityService.asCanonicalUri(editor.resource),\n\t\t\ttypeId: editor.typeId,\n\t\t\teditorId: editor.editorId\n\t\t});\n\t}\n\n\tisVisible(editor: EditorInput): boolean {\n\t\tfor (const group of this.editorGroupsContainer.groups) {\n\t\t\tif (group.activeEditor?.matches(editor)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t//#endregion\n\n\t//#region closeEditor()\n\n\tasync closeEditor({ editor, groupId }: IEditorIdentifier, options?: ICloseEditorOptions): Promise<void> {\n\t\tconst group = this.editorGroupsContainer.getGroup(groupId);\n\n\t\tawait group?.closeEditor(editor, options);\n\t}\n\n\t//#endregion\n\n\t//#region closeEditors()\n\n\tasync closeEditors(editors: IEditorIdentifier[], options?: ICloseEditorOptions): Promise<void> {\n\t\tconst mapGroupToEditors = new Map<IEditorGroup, EditorInput[]>();\n\n\t\tfor (const { editor, groupId } of editors) {\n\t\t\tconst group = this.editorGroupsContainer.getGroup(groupId);\n\t\t\tif (!group) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet editors = mapGroupToEditors.get(group);\n\t\t\tif (!editors) {\n\t\t\t\teditors = [];\n\t\t\t\tmapGroupToEditors.set(group, editors);\n\t\t\t}\n\n\t\t\teditors.push(editor);\n\t\t}\n\n\t\tfor (const [group, editors] of mapGroupToEditors) {\n\t\t\tawait group.closeEditors(editors, options);\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region findEditors()\n\n\tfindEditors(resource: URI, options?: IFindEditorOptions): readonly IEditorIdentifier[];\n\tfindEditors(editor: IResourceEditorInputIdentifier, options?: IFindEditorOptions): readonly IEditorIdentifier[];\n\tfindEditors(resource: URI, options: IFindEditorOptions | undefined, group: IEditorGroup | GroupIdentifier): readonly EditorInput[];\n\tfindEditors(editor: IResourceEditorInputIdentifier, options: IFindEditorOptions | undefined, group: IEditorGroup | GroupIdentifier): EditorInput | undefined;\n\tfindEditors(arg1: URI | IResourceEditorInputIdentifier, options: IFindEditorOptions | undefined, arg2?: IEditorGroup | GroupIdentifier): readonly IEditorIdentifier[] | readonly EditorInput[] | EditorInput | undefined;\n\tfindEditors(arg1: URI | IResourceEditorInputIdentifier, options: IFindEditorOptions | undefined, arg2?: IEditorGroup | GroupIdentifier): readonly IEditorIdentifier[] | readonly EditorInput[] | EditorInput | undefined {\n\t\tconst resource = URI.isUri(arg1) ? arg1 : arg1.resource;\n\t\tconst typeId = URI.isUri(arg1) ? undefined : arg1.typeId;\n\n\t\t// Do a quick check for the resource via the editor observer\n\t\t// which is a very efficient way to find an editor by resource.\n\t\t// However, we can only do that unless we are asked to find an\n\t\t// editor on the secondary side of a side by side editor, because\n\t\t// the editor observer provides fast lookups only for primary\n\t\t// editors.\n\t\tif (options?.supportSideBySide !== SideBySideEditor.ANY && options?.supportSideBySide !== SideBySideEditor.SECONDARY) {\n\t\t\tif (!this.editorsObserver.hasEditors(resource)) {\n\t\t\t\tif (URI.isUri(arg1) || isUndefined(arg2)) {\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\n\t\t// Search only in specific group\n\t\tif (!isUndefined(arg2)) {\n\t\t\tconst targetGroup = typeof arg2 === 'number' ? this.editorGroupsContainer.getGroup(arg2) : arg2;\n\n\t\t\t// Resource provided: result is an array\n\t\t\tif (URI.isUri(arg1)) {\n\t\t\t\tif (!targetGroup) {\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\n\t\t\t\treturn targetGroup.findEditors(resource, options);\n\t\t\t}\n\n\t\t\t// Editor identifier provided, result is single\n\t\t\telse {\n\t\t\t\tif (!targetGroup) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\tconst editors = targetGroup.findEditors(resource, options);\n\t\t\t\tfor (const editor of editors) {\n\t\t\t\t\tif (editor.typeId === typeId) {\n\t\t\t\t\t\treturn editor;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\n\t\t// Search across all groups in MRU order\n\t\telse {\n\t\t\tconst result: IEditorIdentifier[] = [];\n\n\t\t\tfor (const group of this.editorGroupsContainer.getGroups(GroupsOrder.MOST_RECENTLY_ACTIVE)) {\n\t\t\t\tconst editors: EditorInput[] = [];\n\n\t\t\t\t// Resource provided: result is an array\n\t\t\t\tif (URI.isUri(arg1)) {\n\t\t\t\t\teditors.push(...this.findEditors(arg1, options, group));\n\t\t\t\t}\n\n\t\t\t\t// Editor identifier provided, result is single\n\t\t\t\telse {\n\t\t\t\t\tconst editor = this.findEditors(arg1, options, group);\n\t\t\t\t\tif (editor) {\n\t\t\t\t\t\teditors.push(editor);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tresult.push(...editors.map(editor => ({ editor, groupId: group.id })));\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region replaceEditors()\n\n\tasync replaceEditors(replacements: IUntypedEditorReplacement[], group: IEditorGroup | GroupIdentifier): Promise<void>;\n\tasync replaceEditors(replacements: IEditorReplacement[], group: IEditorGroup | GroupIdentifier): Promise<void>;\n\tasync replaceEditors(replacements: Array<IEditorReplacement | IUntypedEditorReplacement>, group: IEditorGroup | GroupIdentifier): Promise<void> {\n\t\tconst targetGroup = typeof group === 'number' ? this.editorGroupsContainer.getGroup(group) : group;\n\n\t\t// Convert all replacements to typed editors unless already\n\t\t// typed and handle overrides properly.\n\t\tconst typedReplacements: IEditorReplacement[] = [];\n\t\tfor (const replacement of replacements) {\n\t\t\tlet typedReplacement: IEditorReplacement | undefined = undefined;\n\n\t\t\t// Resolve override unless disabled\n\t\t\tif (!isEditorInput(replacement.replacement)) {\n\t\t\t\tconst resolvedEditor = await this.editorResolverService.resolveEditor(\n\t\t\t\t\treplacement.replacement,\n\t\t\t\t\ttargetGroup\n\t\t\t\t);\n\n\t\t\t\tif (resolvedEditor === ResolvedStatus.ABORT) {\n\t\t\t\t\tcontinue; // skip editor if override is aborted\n\t\t\t\t}\n\n\t\t\t\t// We resolved an editor to use\n\t\t\t\tif (isEditorInputWithOptionsAndGroup(resolvedEditor)) {\n\t\t\t\t\ttypedReplacement = {\n\t\t\t\t\t\teditor: replacement.editor,\n\t\t\t\t\t\treplacement: resolvedEditor.editor,\n\t\t\t\t\t\toptions: resolvedEditor.options,\n\t\t\t\t\t\tforceReplaceDirty: replacement.forceReplaceDirty\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override is disabled or did not apply: fallback to default\n\t\t\tif (!typedReplacement) {\n\t\t\t\ttypedReplacement = {\n\t\t\t\t\teditor: replacement.editor,\n\t\t\t\t\treplacement: isEditorReplacement(replacement) ? replacement.replacement : await this.textEditorService.resolveTextEditor(replacement.replacement),\n\t\t\t\t\toptions: isEditorReplacement(replacement) ? replacement.options : replacement.replacement.options,\n\t\t\t\t\tforceReplaceDirty: replacement.forceReplaceDirty\n\t\t\t\t};\n\t\t\t}\n\n\t\t\ttypedReplacements.push(typedReplacement);\n\t\t}\n\n\t\treturn targetGroup?.replaceEditors(typedReplacements);\n\t}\n\n\t//#endregion\n\n\t//#region save/revert\n\n\tasync save(editors: IEditorIdentifier | IEditorIdentifier[], options?: ISaveEditorsOptions): Promise<ISaveEditorsResult> {\n\n\t\t// Convert to array\n\t\tif (!Array.isArray(editors)) {\n\t\t\teditors = [editors];\n\t\t}\n\n\t\t// Make sure to not save the same editor multiple times\n\t\t// by using the `matches()` method to find duplicates\n\t\tconst uniqueEditors = this.getUniqueEditors(editors);\n\n\t\t// Split editors up into a bucket that is saved in parallel\n\t\t// and sequentially. Unless \"Save As\", all non-untitled editors\n\t\t// can be saved in parallel to speed up the operation. Remaining\n\t\t// editors are potentially bringing up some UI and thus run\n\t\t// sequentially.\n\t\tconst editorsToSaveParallel: IEditorIdentifier[] = [];\n\t\tconst editorsToSaveSequentially: IEditorIdentifier[] = [];\n\t\tif (options?.saveAs) {\n\t\t\teditorsToSaveSequentially.push(...uniqueEditors);\n\t\t} else {\n\t\t\tfor (const { groupId, editor } of uniqueEditors) {\n\t\t\t\tif (editor.hasCapability(EditorInputCapabilities.Untitled)) {\n\t\t\t\t\teditorsToSaveSequentially.push({ groupId, editor });\n\t\t\t\t} else {\n\t\t\t\t\teditorsToSaveParallel.push({ groupId, editor });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Editors to save in parallel\n\t\tconst saveResults = await Promises.settled(editorsToSaveParallel.map(({ groupId, editor }) => {\n\n\t\t\t// Use save as a hint to pin the editor if used explicitly\n\t\t\tif (options?.reason === SaveReason.EXPLICIT) {\n\t\t\t\tthis.editorGroupsContainer.getGroup(groupId)?.pinEditor(editor);\n\t\t\t}\n\n\t\t\t// Save\n\t\t\treturn editor.save(groupId, options);\n\t\t}));\n\n\t\t// Editors to save sequentially\n\t\tfor (const { groupId, editor } of editorsToSaveSequentially) {\n\t\t\tif (editor.isDisposed()) {\n\t\t\t\tcontinue; // might have been disposed from the save already\n\t\t\t}\n\n\t\t\t// Preserve view state by opening the editor first if the editor\n\t\t\t// is untitled or we \"Save As\". This also allows the user to review\n\t\t\t// the contents of the editor before making a decision.\n\t\t\tconst editorPane = await this.openEditor(editor, groupId);\n\t\t\tconst editorOptions: IEditorOptions = {\n\t\t\t\tpinned: true,\n\t\t\t\tviewState: editorPane?.getViewState()\n\t\t\t};\n\n\t\t\tconst result = options?.saveAs ? await editor.saveAs(groupId, options) : await editor.save(groupId, options);\n\t\t\tsaveResults.push(result);\n\n\t\t\tif (!result) {\n\t\t\t\tbreak; // failed or cancelled, abort\n\t\t\t}\n\n\t\t\t// Replace editor preserving viewstate (either across all groups or\n\t\t\t// only selected group) if the resulting editor is different from the\n\t\t\t// current one.\n\t\t\tif (!editor.matches(result)) {\n\t\t\t\tconst targetGroups = editor.hasCapability(EditorInputCapabilities.Untitled) ? this.editorGroupsContainer.groups.map(group => group.id) /* untitled replaces across all groups */ : [groupId];\n\t\t\t\tfor (const targetGroup of targetGroups) {\n\t\t\t\t\tif (result instanceof EditorInput) {\n\t\t\t\t\t\tawait this.replaceEditors([{ editor, replacement: result, options: editorOptions }], targetGroup);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tawait this.replaceEditors([{ editor, replacement: { ...result, options: editorOptions } }], targetGroup);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tsuccess: saveResults.every(result => !!result),\n\t\t\teditors: coalesce(saveResults)\n\t\t};\n\t}\n\n\tsaveAll(options?: ISaveAllEditorsOptions): Promise<ISaveEditorsResult> {\n\t\treturn this.save(this.getAllModifiedEditors(options), options);\n\t}\n\n\tasync revert(editors: IEditorIdentifier | IEditorIdentifier[], options?: IRevertOptions): Promise<boolean> {\n\n\t\t// Convert to array\n\t\tif (!Array.isArray(editors)) {\n\t\t\teditors = [editors];\n\t\t}\n\n\t\t// Make sure to not revert the same editor multiple times\n\t\t// by using the `matches()` method to find duplicates\n\t\tconst uniqueEditors = this.getUniqueEditors(editors);\n\n\t\tawait Promises.settled(uniqueEditors.map(async ({ groupId, editor }) => {\n\n\t\t\t// Use revert as a hint to pin the editor\n\t\t\tthis.editorGroupsContainer.getGroup(groupId)?.pinEditor(editor);\n\n\t\t\treturn editor.revert(groupId, options);\n\t\t}));\n\n\t\treturn !uniqueEditors.some(({ editor }) => editor.isDirty());\n\t}\n\n\tasync revertAll(options?: IRevertAllEditorsOptions): Promise<boolean> {\n\t\treturn this.revert(this.getAllModifiedEditors(options), options);\n\t}\n\n\tprivate getAllModifiedEditors(options?: IBaseSaveRevertAllEditorOptions): IEditorIdentifier[] {\n\t\tconst editors: IEditorIdentifier[] = [];\n\n\t\tfor (const group of this.editorGroupsContainer.getGroups(GroupsOrder.MOST_RECENTLY_ACTIVE)) {\n\t\t\tfor (const editor of group.getEditors(EditorsOrder.MOST_RECENTLY_ACTIVE)) {\n\t\t\t\tif (!editor.isModified()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ((typeof options?.includeUntitled === 'boolean' || !options?.includeUntitled?.includeScratchpad)\n\t\t\t\t\t&& editor.hasCapability(EditorInputCapabilities.Scratchpad)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!options?.includeUntitled && editor.hasCapability(EditorInputCapabilities.Untitled)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (options?.excludeSticky && group.isSticky(editor)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\teditors.push({ groupId: group.id, editor });\n\t\t\t}\n\t\t}\n\n\t\treturn editors;\n\t}\n\n\tprivate getUniqueEditors(editors: IEditorIdentifier[]): IEditorIdentifier[] {\n\t\tconst uniqueEditors: IEditorIdentifier[] = [];\n\t\tfor (const { editor, groupId } of editors) {\n\t\t\tif (uniqueEditors.some(uniqueEditor => uniqueEditor.editor.matches(editor))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tuniqueEditors.push({ editor, groupId });\n\t\t}\n\n\t\treturn uniqueEditors;\n\t}\n\n\t//#endregion\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\t// Dispose remaining watchers if any\n\t\tthis.activeOutOfWorkspaceWatchers.forEach(disposable => dispose(disposable));\n\t\tthis.activeOutOfWorkspaceWatchers.clear();\n\t}\n}\n\nregisterSingleton(IEditorService, new SyncDescriptor(EditorService, [undefined], false));\n"],
  "mappings": "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",
  "names": ["editors"]
}
