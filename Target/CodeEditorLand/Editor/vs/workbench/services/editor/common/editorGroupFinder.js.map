{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/editor/common/editorGroupFinder.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IConfigurationService } from \"../../../../platform/configuration/common/configuration.js\";\nimport { EditorActivation } from \"../../../../platform/editor/common/editor.js\";\nimport type { ServicesAccessor } from \"../../../../platform/instantiation/common/instantiation.js\";\nimport {\n\tEditorInputCapabilities,\n\ttype EditorInputWithOptions,\n\ttype IUntypedEditorInput,\n\tisEditorInput,\n\tisEditorInputWithOptions,\n} from \"../../../common/editor.js\";\nimport type { EditorInput } from \"../../../common/editor/editorInput.js\";\nimport {\n\tGroupsOrder,\n\ttype IEditorGroup,\n\tIEditorGroupsService,\n\tpreferredSideBySideGroupDirection,\n} from \"./editorGroupsService.js\";\nimport {\n\tAUX_WINDOW_GROUP,\n\ttype AUX_WINDOW_GROUP_TYPE,\n\ttype PreferredGroup,\n\tSIDE_GROUP,\n} from \"./editorService.js\";\n\n/**\n * Finds the target `IEditorGroup` given the instructions provided\n * that is best for the editor and matches the preferred group if\n * possible.\n */\nexport function findGroup(\n\taccessor: ServicesAccessor,\n\teditor: IUntypedEditorInput,\n\tpreferredGroup: Exclude<PreferredGroup, AUX_WINDOW_GROUP_TYPE> | undefined,\n): [IEditorGroup, EditorActivation | undefined];\nexport function findGroup(\n\taccessor: ServicesAccessor,\n\teditor: EditorInputWithOptions,\n\tpreferredGroup: Exclude<PreferredGroup, AUX_WINDOW_GROUP_TYPE> | undefined,\n): [IEditorGroup, EditorActivation | undefined];\nexport function findGroup(\n\taccessor: ServicesAccessor,\n\teditor: EditorInputWithOptions | IUntypedEditorInput,\n\tpreferredGroup: Exclude<PreferredGroup, AUX_WINDOW_GROUP_TYPE> | undefined,\n): [IEditorGroup, EditorActivation | undefined];\nexport function findGroup(\n\taccessor: ServicesAccessor,\n\teditor: IUntypedEditorInput,\n\tpreferredGroup: AUX_WINDOW_GROUP_TYPE,\n): Promise<[IEditorGroup, EditorActivation | undefined]>;\nexport function findGroup(\n\taccessor: ServicesAccessor,\n\teditor: EditorInputWithOptions,\n\tpreferredGroup: AUX_WINDOW_GROUP_TYPE,\n): Promise<[IEditorGroup, EditorActivation | undefined]>;\nexport function findGroup(\n\taccessor: ServicesAccessor,\n\teditor: EditorInputWithOptions | IUntypedEditorInput,\n\tpreferredGroup: AUX_WINDOW_GROUP_TYPE,\n): Promise<[IEditorGroup, EditorActivation | undefined]>;\nexport function findGroup(\n\taccessor: ServicesAccessor,\n\teditor: EditorInputWithOptions | IUntypedEditorInput,\n\tpreferredGroup: PreferredGroup | undefined,\n):\n\t| Promise<[IEditorGroup, EditorActivation | undefined]>\n\t| [IEditorGroup, EditorActivation | undefined];\nexport function findGroup(\n\taccessor: ServicesAccessor,\n\teditor: EditorInputWithOptions | IUntypedEditorInput,\n\tpreferredGroup: PreferredGroup | undefined,\n):\n\t| Promise<[IEditorGroup, EditorActivation | undefined]>\n\t| [IEditorGroup, EditorActivation | undefined] {\n\tconst editorGroupService = accessor.get(IEditorGroupsService);\n\tconst configurationService = accessor.get(IConfigurationService);\n\n\tconst group = doFindGroup(\n\t\teditor,\n\t\tpreferredGroup,\n\t\teditorGroupService,\n\t\tconfigurationService,\n\t);\n\tif (group instanceof Promise) {\n\t\treturn group.then((group) =>\n\t\t\thandleGroupActivation(\n\t\t\t\tgroup,\n\t\t\t\teditor,\n\t\t\t\tpreferredGroup,\n\t\t\t\teditorGroupService,\n\t\t\t),\n\t\t);\n\t}\n\n\treturn handleGroupActivation(\n\t\tgroup,\n\t\teditor,\n\t\tpreferredGroup,\n\t\teditorGroupService,\n\t);\n}\n\nfunction handleGroupActivation(\n\tgroup: IEditorGroup,\n\teditor: EditorInputWithOptions | IUntypedEditorInput,\n\tpreferredGroup: PreferredGroup | undefined,\n\teditorGroupService: IEditorGroupsService,\n): [IEditorGroup, EditorActivation | undefined] {\n\t// Resolve editor activation strategy\n\tlet activation: EditorActivation | undefined;\n\tif (\n\t\teditorGroupService.activeGroup !== group && // only if target group is not already active\n\t\teditor.options &&\n\t\t!editor.options.inactive && // never for inactive editors\n\t\teditor.options.preserveFocus && // only if preserveFocus\n\t\ttypeof editor.options.activation !== \"number\" && // only if activation is not already defined (either true or false)\n\t\tpreferredGroup !== SIDE_GROUP // never for the SIDE_GROUP\n\t) {\n\t\t// If the resolved group is not the active one, we typically\n\t\t// want the group to become active. There are a few cases\n\t\t// where we stay away from encorcing this, e.g. if the caller\n\t\t// is already providing `activation`.\n\t\t//\n\t\t// Specifically for historic reasons we do not activate a\n\t\t// group is it is opened as `SIDE_GROUP` with `preserveFocus:true`.\n\t\t// repeated Alt-clicking of files in the explorer always open\n\t\t// into the same side group and not cause a group to be created each time.\n\t\tactivation = EditorActivation.ACTIVATE;\n\t}\n\n\treturn [group, activation];\n}\n\nfunction doFindGroup(\n\tinput: EditorInputWithOptions | IUntypedEditorInput,\n\tpreferredGroup: PreferredGroup | undefined,\n\teditorGroupService: IEditorGroupsService,\n\tconfigurationService: IConfigurationService,\n): Promise<IEditorGroup> | IEditorGroup {\n\tlet group: Promise<IEditorGroup> | IEditorGroup | undefined;\n\tconst editor = isEditorInputWithOptions(input) ? input.editor : input;\n\tconst options = input.options;\n\n\t// Group: Instance of Group\n\tif (preferredGroup && typeof preferredGroup !== \"number\") {\n\t\tgroup = preferredGroup;\n\t}\n\n\t// Group: Specific Group\n\telse if (typeof preferredGroup === \"number\" && preferredGroup >= 0) {\n\t\tgroup = editorGroupService.getGroup(preferredGroup);\n\t}\n\n\t// Group: Side by Side\n\telse if (preferredGroup === SIDE_GROUP) {\n\t\tconst direction =\n\t\t\tpreferredSideBySideGroupDirection(configurationService);\n\n\t\tlet candidateGroup = editorGroupService.findGroup({ direction });\n\t\tif (!candidateGroup || isGroupLockedForEditor(candidateGroup, editor)) {\n\t\t\t// Create new group either when the candidate group\n\t\t\t// is locked or was not found in the direction\n\t\t\tcandidateGroup = editorGroupService.addGroup(\n\t\t\t\teditorGroupService.activeGroup,\n\t\t\t\tdirection,\n\t\t\t);\n\t\t}\n\n\t\tgroup = candidateGroup;\n\t}\n\n\t// Group: Aux Window\n\telse if (preferredGroup === AUX_WINDOW_GROUP) {\n\t\tgroup = editorGroupService\n\t\t\t.createAuxiliaryEditorPart()\n\t\t\t.then((group) => group.activeGroup);\n\t}\n\n\t// Group: Unspecified without a specific index to open\n\telse if (!options || typeof options.index !== \"number\") {\n\t\tconst groupsByLastActive = editorGroupService.getGroups(\n\t\t\tGroupsOrder.MOST_RECENTLY_ACTIVE,\n\t\t);\n\n\t\t// Respect option to reveal an editor if it is already visible in any group\n\t\tif (options?.revealIfVisible) {\n\t\t\tfor (const lastActiveGroup of groupsByLastActive) {\n\t\t\t\tif (isActive(lastActiveGroup, editor)) {\n\t\t\t\t\tgroup = lastActiveGroup;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Respect option to reveal an editor if it is open (not necessarily visible)\n\t\t// Still prefer to reveal an editor in a group where the editor is active though.\n\t\t// We also try to reveal an editor if it has the `Singleton` capability which\n\t\t// indicates that the same editor cannot be opened across groups.\n\t\tif (!group) {\n\t\t\tif (\n\t\t\t\toptions?.revealIfOpened ||\n\t\t\t\tconfigurationService.getValue<boolean>(\n\t\t\t\t\t\"workbench.editor.revealIfOpen\",\n\t\t\t\t) ||\n\t\t\t\t(isEditorInput(editor) &&\n\t\t\t\t\teditor.hasCapability(EditorInputCapabilities.Singleton))\n\t\t\t) {\n\t\t\t\tlet groupWithInputActive: IEditorGroup | undefined;\n\t\t\t\tlet groupWithInputOpened: IEditorGroup | undefined;\n\n\t\t\t\tfor (const group of groupsByLastActive) {\n\t\t\t\t\tif (isOpened(group, editor)) {\n\t\t\t\t\t\tif (!groupWithInputOpened) {\n\t\t\t\t\t\t\tgroupWithInputOpened = group;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!groupWithInputActive && group.isActive(editor)) {\n\t\t\t\t\t\t\tgroupWithInputActive = group;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (groupWithInputOpened && groupWithInputActive) {\n\t\t\t\t\t\tbreak; // we found all groups we wanted\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Prefer a target group where the input is visible\n\t\t\t\tgroup = groupWithInputActive || groupWithInputOpened;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Fallback to active group if target not valid but avoid\n\t// locked editor groups unless editor is already opened there\n\tif (!group) {\n\t\tlet candidateGroup = editorGroupService.activeGroup;\n\n\t\t// Locked group: find the next non-locked group\n\t\t// going up the neigbours of the group or create\n\t\t// a new group otherwise\n\t\tif (isGroupLockedForEditor(candidateGroup, editor)) {\n\t\t\tfor (const group of editorGroupService.getGroups(\n\t\t\t\tGroupsOrder.MOST_RECENTLY_ACTIVE,\n\t\t\t)) {\n\t\t\t\tif (isGroupLockedForEditor(group, editor)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tcandidateGroup = group;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (isGroupLockedForEditor(candidateGroup, editor)) {\n\t\t\t\t// Group is still locked, so we have to create a new\n\t\t\t\t// group to the side of the candidate group\n\t\t\t\tgroup = editorGroupService.addGroup(\n\t\t\t\t\tcandidateGroup,\n\t\t\t\t\tpreferredSideBySideGroupDirection(configurationService),\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tgroup = candidateGroup;\n\t\t\t}\n\t\t}\n\n\t\t// Non-locked group: take as is\n\t\telse {\n\t\t\tgroup = candidateGroup;\n\t\t}\n\t}\n\n\treturn group;\n}\n\nfunction isGroupLockedForEditor(\n\tgroup: IEditorGroup,\n\teditor: EditorInput | IUntypedEditorInput,\n): boolean {\n\tif (!group.isLocked) {\n\t\t// only relevant for locked editor groups\n\t\treturn false;\n\t}\n\n\tif (isOpened(group, editor)) {\n\t\t// special case: the locked group contains\n\t\t// the provided editor. in that case we do not want\n\t\t// to open the editor in any different group.\n\t\treturn false;\n\t}\n\n\t// group is locked for this editor\n\treturn true;\n}\n\nfunction isActive(\n\tgroup: IEditorGroup,\n\teditor: EditorInput | IUntypedEditorInput,\n): boolean {\n\tif (!group.activeEditor) {\n\t\treturn false;\n\t}\n\n\treturn group.activeEditor.matches(editor);\n}\n\nfunction isOpened(\n\tgroup: IEditorGroup,\n\teditor: EditorInput | IUntypedEditorInput,\n): boolean {\n\tfor (const typedEditor of group.editors) {\n\t\tif (typedEditor.matches(editor)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n"],
  "mappings": "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",
  "names": ["group"]
}
