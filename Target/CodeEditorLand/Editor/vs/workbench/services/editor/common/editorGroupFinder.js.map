{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/editor/common/editorGroupFinder.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { EditorActivation } from '../../../../platform/editor/common/editor.js';\nimport { ServicesAccessor } from '../../../../platform/instantiation/common/instantiation.js';\nimport { EditorInputWithOptions, isEditorInputWithOptions, IUntypedEditorInput, isEditorInput, EditorInputCapabilities } from '../../../common/editor.js';\nimport { EditorInput } from '../../../common/editor/editorInput.js';\nimport { IEditorGroup, GroupsOrder, preferredSideBySideGroupDirection, IEditorGroupsService } from './editorGroupsService.js';\nimport { AUX_WINDOW_GROUP, AUX_WINDOW_GROUP_TYPE, PreferredGroup, SIDE_GROUP } from './editorService.js';\n\n/**\n * Finds the target `IEditorGroup` given the instructions provided\n * that is best for the editor and matches the preferred group if\n * possible.\n */\nexport function findGroup(accessor: ServicesAccessor, editor: IUntypedEditorInput, preferredGroup: Exclude<PreferredGroup, AUX_WINDOW_GROUP_TYPE> | undefined): [IEditorGroup, EditorActivation | undefined];\nexport function findGroup(accessor: ServicesAccessor, editor: EditorInputWithOptions, preferredGroup: Exclude<PreferredGroup, AUX_WINDOW_GROUP_TYPE> | undefined): [IEditorGroup, EditorActivation | undefined];\nexport function findGroup(accessor: ServicesAccessor, editor: EditorInputWithOptions | IUntypedEditorInput, preferredGroup: Exclude<PreferredGroup, AUX_WINDOW_GROUP_TYPE> | undefined): [IEditorGroup, EditorActivation | undefined];\nexport function findGroup(accessor: ServicesAccessor, editor: IUntypedEditorInput, preferredGroup: AUX_WINDOW_GROUP_TYPE): Promise<[IEditorGroup, EditorActivation | undefined]>;\nexport function findGroup(accessor: ServicesAccessor, editor: EditorInputWithOptions, preferredGroup: AUX_WINDOW_GROUP_TYPE): Promise<[IEditorGroup, EditorActivation | undefined]>;\nexport function findGroup(accessor: ServicesAccessor, editor: EditorInputWithOptions | IUntypedEditorInput, preferredGroup: AUX_WINDOW_GROUP_TYPE): Promise<[IEditorGroup, EditorActivation | undefined]>;\nexport function findGroup(accessor: ServicesAccessor, editor: EditorInputWithOptions | IUntypedEditorInput, preferredGroup: PreferredGroup | undefined): Promise<[IEditorGroup, EditorActivation | undefined]> | [IEditorGroup, EditorActivation | undefined];\nexport function findGroup(accessor: ServicesAccessor, editor: EditorInputWithOptions | IUntypedEditorInput, preferredGroup: PreferredGroup | undefined): Promise<[IEditorGroup, EditorActivation | undefined]> | [IEditorGroup, EditorActivation | undefined] {\n\tconst editorGroupService = accessor.get(IEditorGroupsService);\n\tconst configurationService = accessor.get(IConfigurationService);\n\n\tconst group = doFindGroup(editor, preferredGroup, editorGroupService, configurationService);\n\tif (group instanceof Promise) {\n\t\treturn group.then(group => handleGroupActivation(group, editor, preferredGroup, editorGroupService));\n\t}\n\n\treturn handleGroupActivation(group, editor, preferredGroup, editorGroupService);\n}\n\nfunction handleGroupActivation(group: IEditorGroup, editor: EditorInputWithOptions | IUntypedEditorInput, preferredGroup: PreferredGroup | undefined, editorGroupService: IEditorGroupsService): [IEditorGroup, EditorActivation | undefined] {\n\n\t// Resolve editor activation strategy\n\tlet activation: EditorActivation | undefined = undefined;\n\tif (\n\t\teditorGroupService.activeGroup !== group && \t\t// only if target group is not already active\n\t\teditor.options && !editor.options.inactive &&\t\t// never for inactive editors\n\t\teditor.options.preserveFocus &&\t\t\t\t\t\t// only if preserveFocus\n\t\ttypeof editor.options.activation !== 'number' &&\t// only if activation is not already defined (either true or false)\n\t\tpreferredGroup !== SIDE_GROUP\t\t\t\t\t\t// never for the SIDE_GROUP\n\t) {\n\t\t// If the resolved group is not the active one, we typically\n\t\t// want the group to become active. There are a few cases\n\t\t// where we stay away from encorcing this, e.g. if the caller\n\t\t// is already providing `activation`.\n\t\t//\n\t\t// Specifically for historic reasons we do not activate a\n\t\t// group is it is opened as `SIDE_GROUP` with `preserveFocus:true`.\n\t\t// repeated Alt-clicking of files in the explorer always open\n\t\t// into the same side group and not cause a group to be created each time.\n\t\tactivation = EditorActivation.ACTIVATE;\n\t}\n\n\treturn [group, activation];\n}\n\nfunction doFindGroup(input: EditorInputWithOptions | IUntypedEditorInput, preferredGroup: PreferredGroup | undefined, editorGroupService: IEditorGroupsService, configurationService: IConfigurationService): Promise<IEditorGroup> | IEditorGroup {\n\tlet group: Promise<IEditorGroup> | IEditorGroup | undefined;\n\tconst editor = isEditorInputWithOptions(input) ? input.editor : input;\n\tconst options = input.options;\n\n\t// Group: Instance of Group\n\tif (preferredGroup && typeof preferredGroup !== 'number') {\n\t\tgroup = preferredGroup;\n\t}\n\n\t// Group: Specific Group\n\telse if (typeof preferredGroup === 'number' && preferredGroup >= 0) {\n\t\tgroup = editorGroupService.getGroup(preferredGroup);\n\t}\n\n\t// Group: Side by Side\n\telse if (preferredGroup === SIDE_GROUP) {\n\t\tconst direction = preferredSideBySideGroupDirection(configurationService);\n\n\t\tlet candidateGroup = editorGroupService.findGroup({ direction });\n\t\tif (!candidateGroup || isGroupLockedForEditor(candidateGroup, editor)) {\n\t\t\t// Create new group either when the candidate group\n\t\t\t// is locked or was not found in the direction\n\t\t\tcandidateGroup = editorGroupService.addGroup(editorGroupService.activeGroup, direction);\n\t\t}\n\n\t\tgroup = candidateGroup;\n\t}\n\n\t// Group: Aux Window\n\telse if (preferredGroup === AUX_WINDOW_GROUP) {\n\t\tgroup = editorGroupService.createAuxiliaryEditorPart().then(group => group.activeGroup);\n\t}\n\n\t// Group: Unspecified without a specific index to open\n\telse if (!options || typeof options.index !== 'number') {\n\t\tconst groupsByLastActive = editorGroupService.getGroups(GroupsOrder.MOST_RECENTLY_ACTIVE);\n\n\t\t// Respect option to reveal an editor if it is already visible in any group\n\t\tif (options?.revealIfVisible) {\n\t\t\tfor (const lastActiveGroup of groupsByLastActive) {\n\t\t\t\tif (isActive(lastActiveGroup, editor)) {\n\t\t\t\t\tgroup = lastActiveGroup;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Respect option to reveal an editor if it is open (not necessarily visible)\n\t\t// Still prefer to reveal an editor in a group where the editor is active though.\n\t\t// We also try to reveal an editor if it has the `Singleton` capability which\n\t\t// indicates that the same editor cannot be opened across groups.\n\t\tif (!group) {\n\t\t\tif (options?.revealIfOpened || configurationService.getValue<boolean>('workbench.editor.revealIfOpen') || (isEditorInput(editor) && editor.hasCapability(EditorInputCapabilities.Singleton))) {\n\t\t\t\tlet groupWithInputActive: IEditorGroup | undefined = undefined;\n\t\t\t\tlet groupWithInputOpened: IEditorGroup | undefined = undefined;\n\n\t\t\t\tfor (const group of groupsByLastActive) {\n\t\t\t\t\tif (isOpened(group, editor)) {\n\t\t\t\t\t\tif (!groupWithInputOpened) {\n\t\t\t\t\t\t\tgroupWithInputOpened = group;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!groupWithInputActive && group.isActive(editor)) {\n\t\t\t\t\t\t\tgroupWithInputActive = group;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (groupWithInputOpened && groupWithInputActive) {\n\t\t\t\t\t\tbreak; // we found all groups we wanted\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Prefer a target group where the input is visible\n\t\t\t\tgroup = groupWithInputActive || groupWithInputOpened;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Fallback to active group if target not valid but avoid\n\t// locked editor groups unless editor is already opened there\n\tif (!group) {\n\t\tlet candidateGroup = editorGroupService.activeGroup;\n\n\t\t// Locked group: find the next non-locked group\n\t\t// going up the neigbours of the group or create\n\t\t// a new group otherwise\n\t\tif (isGroupLockedForEditor(candidateGroup, editor)) {\n\t\t\tfor (const group of editorGroupService.getGroups(GroupsOrder.MOST_RECENTLY_ACTIVE)) {\n\t\t\t\tif (isGroupLockedForEditor(group, editor)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tcandidateGroup = group;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (isGroupLockedForEditor(candidateGroup, editor)) {\n\t\t\t\t// Group is still locked, so we have to create a new\n\t\t\t\t// group to the side of the candidate group\n\t\t\t\tgroup = editorGroupService.addGroup(candidateGroup, preferredSideBySideGroupDirection(configurationService));\n\t\t\t} else {\n\t\t\t\tgroup = candidateGroup;\n\t\t\t}\n\t\t}\n\n\t\t// Non-locked group: take as is\n\t\telse {\n\t\t\tgroup = candidateGroup;\n\t\t}\n\t}\n\n\treturn group;\n}\n\nfunction isGroupLockedForEditor(group: IEditorGroup, editor: EditorInput | IUntypedEditorInput): boolean {\n\tif (!group.isLocked) {\n\t\t// only relevant for locked editor groups\n\t\treturn false;\n\t}\n\n\tif (isOpened(group, editor)) {\n\t\t// special case: the locked group contains\n\t\t// the provided editor. in that case we do not want\n\t\t// to open the editor in any different group.\n\t\treturn false;\n\t}\n\n\t// group is locked for this editor\n\treturn true;\n}\n\nfunction isActive(group: IEditorGroup, editor: EditorInput | IUntypedEditorInput): boolean {\n\tif (!group.activeEditor) {\n\t\treturn false;\n\t}\n\n\treturn group.activeEditor.matches(editor);\n}\n\nfunction isOpened(group: IEditorGroup, editor: EditorInput | IUntypedEditorInput): boolean {\n\tfor (const typedEditor of group.editors) {\n\t\tif (typedEditor.matches(editor)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n"],
  "mappings": "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",
  "names": ["group"]
}
