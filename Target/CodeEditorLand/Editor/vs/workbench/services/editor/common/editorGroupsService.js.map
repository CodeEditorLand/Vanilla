{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/editor/common/editorGroupsService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../../../base/common/event.js';\nimport { IInstantiationService, createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IEditorPane, GroupIdentifier, EditorInputWithOptions, CloseDirection, IEditorPartOptions, IEditorPartOptionsChangeEvent, EditorsOrder, IVisibleEditorPane, IEditorCloseEvent, IUntypedEditorInput, isEditorInput, IEditorWillMoveEvent, IMatchEditorOptions, IActiveEditorChangeEvent, IFindEditorOptions, IToolbarActions } from '../../../common/editor.js';\nimport { EditorInput } from '../../../common/editor/editorInput.js';\nimport { IEditorOptions } from '../../../../platform/editor/common/editor.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { IDimension } from '../../../../editor/common/core/dimension.js';\nimport { DisposableStore, IDisposable } from '../../../../base/common/lifecycle.js';\nimport { ContextKeyValue, IContextKeyService, RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IGroupModelChangeEvent } from '../../../common/editor/editorGroupModel.js';\nimport { IRectangle } from '../../../../platform/window/common/window.js';\nimport { IMenuChangeEvent } from '../../../../platform/actions/common/actions.js';\nimport { DeepPartial } from '../../../../base/common/types.js';\n\nexport const IEditorGroupsService = createDecorator<IEditorGroupsService>('editorGroupsService');\n\nexport const enum GroupDirection {\n\tUP,\n\tDOWN,\n\tLEFT,\n\tRIGHT\n}\n\nexport const enum GroupOrientation {\n\tHORIZONTAL,\n\tVERTICAL\n}\n\nexport const enum GroupLocation {\n\tFIRST,\n\tLAST,\n\tNEXT,\n\tPREVIOUS\n}\n\nexport interface IFindGroupScope {\n\treadonly direction?: GroupDirection;\n\treadonly location?: GroupLocation;\n}\n\nexport const enum GroupsArrangement {\n\t/**\n\t * Make the current active group consume the entire\n\t * editor area.\n\t */\n\tMAXIMIZE,\n\n\t/**\n\t * Make the current active group consume the maximum\n\t * amount of space possible.\n\t */\n\tEXPAND,\n\n\t/**\n\t * Size all groups evenly.\n\t */\n\tEVEN\n}\n\nexport interface GroupLayoutArgument {\n\n\t/**\n\t * Only applies when there are multiple groups\n\t * arranged next to each other in a row or column.\n\t * If provided, their sum must be 1 to be applied\n\t * per row or column.\n\t */\n\treadonly size?: number;\n\n\t/**\n\t * Editor groups  will be laid out orthogonal to the\n\t * parent orientation.\n\t */\n\treadonly groups?: GroupLayoutArgument[];\n}\n\nexport interface EditorGroupLayout {\n\n\t/**\n\t * The initial orientation of the editor groups at the root.\n\t */\n\treadonly orientation: GroupOrientation;\n\n\t/**\n\t * The editor groups at the root of the layout.\n\t */\n\treadonly groups: GroupLayoutArgument[];\n}\n\nexport const enum MergeGroupMode {\n\tCOPY_EDITORS,\n\tMOVE_EDITORS\n}\n\nexport interface IMergeGroupOptions {\n\tmode?: MergeGroupMode;\n\treadonly index?: number;\n}\n\nexport interface ICloseEditorOptions {\n\treadonly preserveFocus?: boolean;\n}\n\nexport type ICloseEditorsFilter = {\n\treadonly except?: EditorInput;\n\treadonly direction?: CloseDirection;\n\treadonly savedOnly?: boolean;\n\treadonly excludeSticky?: boolean;\n};\n\nexport interface ICloseAllEditorsOptions {\n\treadonly excludeSticky?: boolean;\n\treadonly excludeConfirming?: boolean;\n}\n\nexport interface IEditorReplacement {\n\treadonly editor: EditorInput;\n\treadonly replacement: EditorInput;\n\treadonly options?: IEditorOptions;\n\n\t/**\n\t * Skips asking the user for confirmation and doesn't\n\t * save the document. Only use this if you really need to!\n\t */\n\treadonly forceReplaceDirty?: boolean;\n}\n\nexport function isEditorReplacement(replacement: unknown): replacement is IEditorReplacement {\n\tconst candidate = replacement as IEditorReplacement | undefined;\n\n\treturn isEditorInput(candidate?.editor) && isEditorInput(candidate?.replacement);\n}\n\nexport const enum GroupsOrder {\n\n\t/**\n\t * Groups sorted by creation order (oldest one first)\n\t */\n\tCREATION_TIME,\n\n\t/**\n\t * Groups sorted by most recent activity (most recent active first)\n\t */\n\tMOST_RECENTLY_ACTIVE,\n\n\t/**\n\t * Groups sorted by grid widget order\n\t */\n\tGRID_APPEARANCE\n}\n\nexport interface IEditorSideGroup {\n\n\t/**\n\t * Open an editor in this group.\n\t *\n\t * @returns a promise that resolves around an IEditor instance unless\n\t * the call failed, or the editor was not opened as active editor.\n\t */\n\topenEditor(editor: EditorInput, options?: IEditorOptions): Promise<IEditorPane | undefined>;\n}\n\nexport interface IEditorDropTargetDelegate {\n\n\t/**\n\t * A helper to figure out if the drop target contains the provided group.\n\t */\n\tcontainsGroup?(groupView: IEditorGroup): boolean;\n}\n\n/**\n * The basic primitive to work with editor groups. This interface is both implemented\n * by editor part component as well as the editor groups service that operates across\n * all opened editor parts.\n */\nexport interface IEditorGroupsContainer {\n\n\t/**\n\t * An event for when the active editor group changes. The active editor\n\t * group is the default location for new editors to open.\n\t */\n\treadonly onDidChangeActiveGroup: Event<IEditorGroup>;\n\n\t/**\n\t * An event for when a new group was added.\n\t */\n\treadonly onDidAddGroup: Event<IEditorGroup>;\n\n\t/**\n\t * An event for when a group was removed.\n\t */\n\treadonly onDidRemoveGroup: Event<IEditorGroup>;\n\n\t/**\n\t * An event for when a group was moved.\n\t */\n\treadonly onDidMoveGroup: Event<IEditorGroup>;\n\n\t/**\n\t * An event for when a group gets activated.\n\t */\n\treadonly onDidActivateGroup: Event<IEditorGroup>;\n\n\t/**\n\t * An event for when the index of a group changes.\n\t */\n\treadonly onDidChangeGroupIndex: Event<IEditorGroup>;\n\n\t/**\n\t * An event for when the locked state of a group changes.\n\t */\n\treadonly onDidChangeGroupLocked: Event<IEditorGroup>;\n\n\t/**\n\t * An event for when the maximized state of a group changes.\n\t */\n\treadonly onDidChangeGroupMaximized: Event<boolean>;\n\n\t/**\n\t * A property that indicates when groups have been created\n\t * and are ready to be used in the editor part.\n\t */\n\treadonly isReady: boolean;\n\n\t/**\n\t * A promise that resolves when groups have been created\n\t * and are ready to be used in the editor part.\n\t *\n\t * Await this promise to safely work on the editor groups model\n\t * (for example, install editor group listeners).\n\t *\n\t * Use the `whenRestored` property to await visible editors\n\t * having fully resolved.\n\t */\n\treadonly whenReady: Promise<void>;\n\n\t/**\n\t * A promise that resolves when groups have been restored in\n\t * the editor part.\n\t *\n\t * For groups with active editor, the promise will resolve\n\t * when the visible editor has finished to resolve.\n\t *\n\t * Use the `whenReady` property to not await editors to\n\t * resolve.\n\t */\n\treadonly whenRestored: Promise<void>;\n\n\t/**\n\t * Find out if the editor part has UI state to restore\n\t * from a previous session.\n\t */\n\treadonly hasRestorableState: boolean;\n\n\t/**\n\t * An active group is the default location for new editors to open.\n\t */\n\treadonly activeGroup: IEditorGroup;\n\n\t/**\n\t * A side group allows a subset of methods on a group that is either\n\t * created to the side or picked if already there.\n\t */\n\treadonly sideGroup: IEditorSideGroup;\n\n\t/**\n\t * All groups that are currently visible in the container in the order\n\t * of their creation (oldest first).\n\t */\n\treadonly groups: readonly IEditorGroup[];\n\n\t/**\n\t * The number of editor groups that are currently opened in the\n\t * container.\n\t */\n\treadonly count: number;\n\n\t/**\n\t * The current layout orientation of the root group.\n\t */\n\treadonly orientation: GroupOrientation;\n\n\t/**\n\t * Get all groups that are currently visible in the container.\n\t *\n\t * @param order the order of the editors to use\n\t */\n\tgetGroups(order: GroupsOrder): readonly IEditorGroup[];\n\n\t/**\n\t * Allows to convert a group identifier to a group.\n\t */\n\tgetGroup(identifier: GroupIdentifier): IEditorGroup | undefined;\n\n\t/**\n\t * Set a group as active. An active group is the default location for new editors to open.\n\t */\n\tactivateGroup(group: IEditorGroup | GroupIdentifier): IEditorGroup;\n\n\t/**\n\t * Returns the size of a group.\n\t */\n\tgetSize(group: IEditorGroup | GroupIdentifier): { width: number; height: number };\n\n\t/**\n\t * Sets the size of a group.\n\t */\n\tsetSize(group: IEditorGroup | GroupIdentifier, size: { width: number; height: number }): void;\n\n\t/**\n\t * Arrange all groups in the container according to the provided arrangement.\n\t */\n\tarrangeGroups(arrangement: GroupsArrangement, target?: IEditorGroup | GroupIdentifier): void;\n\n\t/**\n\t * Toggles the target goup size to maximize/unmaximize.\n\t */\n\ttoggleMaximizeGroup(group?: IEditorGroup | GroupIdentifier): void;\n\n\t/**\n\t * Toggles the target goup size to expand/distribute even.\n\t */\n\ttoggleExpandGroup(group?: IEditorGroup | GroupIdentifier): void;\n\n\t/**\n\t * Applies the provided layout by either moving existing groups or creating new groups.\n\t */\n\tapplyLayout(layout: EditorGroupLayout): void;\n\n\t/**\n\t * Returns an editor layout of the container.\n\t */\n\tgetLayout(): EditorGroupLayout;\n\n\t/**\n\t * Sets the orientation of the root group to be either vertical or horizontal.\n\t */\n\tsetGroupOrientation(orientation: GroupOrientation): void;\n\n\t/**\n\t * Find a group in a specific scope:\n\t * * `GroupLocation.FIRST`: the first group\n\t * * `GroupLocation.LAST`: the last group\n\t * * `GroupLocation.NEXT`: the next group from either the active one or `source`\n\t * * `GroupLocation.PREVIOUS`: the previous group from either the active one or `source`\n\t * * `GroupDirection.UP`: the next group above the active one or `source`\n\t * * `GroupDirection.DOWN`: the next group below the active one or `source`\n\t * * `GroupDirection.LEFT`: the next group to the left of the active one or `source`\n\t * * `GroupDirection.RIGHT`: the next group to the right of the active one or `source`\n\t *\n\t * @param scope the scope of the group to search in\n\t * @param source optional source to search from\n\t * @param wrap optionally wrap around if reaching the edge of groups\n\t */\n\tfindGroup(scope: IFindGroupScope, source?: IEditorGroup | GroupIdentifier, wrap?: boolean): IEditorGroup | undefined;\n\n\t/**\n\t * Add a new group to the container. A new group is added by splitting a provided one in\n\t * one of the four directions.\n\t *\n\t * @param location the group from which to split to add a new group\n\t * @param direction the direction of where to split to\n\t */\n\taddGroup(location: IEditorGroup | GroupIdentifier, direction: GroupDirection): IEditorGroup;\n\n\t/**\n\t * Remove a group from the container.\n\t */\n\tremoveGroup(group: IEditorGroup | GroupIdentifier): void;\n\n\t/**\n\t * Move a group to a new group in the container.\n\t *\n\t * @param group the group to move\n\t * @param location the group from which to split to add the moved group\n\t * @param direction the direction of where to split to\n\t */\n\tmoveGroup(group: IEditorGroup | GroupIdentifier, location: IEditorGroup | GroupIdentifier, direction: GroupDirection): IEditorGroup;\n\n\t/**\n\t * Merge the editors of a group into a target group. By default, all editors will\n\t * move and the source group will close. This behaviour can be configured via the\n\t * `IMergeGroupOptions` options.\n\t *\n\t * @param group the group to merge\n\t * @param target the target group to merge into\n\t * @param options controls how the merge should be performed. by default all editors\n\t * will be moved over to the target and the source group will close. Configure to\n\t * `MOVE_EDITORS_KEEP_GROUP` to prevent the source group from closing. Set to\n\t * `COPY_EDITORS` to copy the editors into the target instead of moding them.\n\t *\n\t * @returns if merging was successful\n\t */\n\tmergeGroup(group: IEditorGroup | GroupIdentifier, target: IEditorGroup | GroupIdentifier, options?: IMergeGroupOptions): boolean;\n\n\t/**\n\t * Merge all editor groups into the target one.\n\t *\n\t * @returns if merging was successful\n\t */\n\tmergeAllGroups(target: IEditorGroup | GroupIdentifier): boolean;\n\n\t/**\n\t * Copy a group to a new group in the container.\n\t *\n\t * @param group the group to copy\n\t * @param location the group from which to split to add the copied group\n\t * @param direction the direction of where to split to\n\t */\n\tcopyGroup(group: IEditorGroup | GroupIdentifier, location: IEditorGroup | GroupIdentifier, direction: GroupDirection): IEditorGroup;\n\n\t/**\n\t * Allows to register a drag and drop target for editors\n\t * on the provided `container`.\n\t */\n\tcreateEditorDropTarget(container: unknown /* HTMLElement */, delegate: IEditorDropTargetDelegate): IDisposable;\n}\n\n/**\n * An editor part is a viewer of editor groups. There can be multiple editor\n * parts opened in multiple windows.\n */\nexport interface IEditorPart extends IEditorGroupsContainer {\n\n\t/**\n\t * An event for when the editor part is layed out.\n\t */\n\treadonly onDidLayout: Event<IDimension>;\n\n\t/**\n\t * An event for when the editor part is scrolled.\n\t */\n\treadonly onDidScroll: Event<void>;\n\n\t/**\n\t * An event for when the editor part is disposed.\n\t */\n\treadonly onWillDispose: Event<void>;\n\n\t/**\n\t * The identifier of the window the editor part is contained in.\n\t */\n\treadonly windowId: number;\n\n\t/**\n\t * The size of the editor part.\n\t */\n\treadonly contentDimension: IDimension;\n\n\t/**\n\t * Find out if an editor group is currently maximized.\n\t */\n\thasMaximizedGroup(): boolean;\n\n\t/**\n\t * Enable or disable centered editor layout.\n\t */\n\tcenterLayout(active: boolean): void;\n\n\t/**\n\t * Find out if the editor layout is currently centered.\n\t */\n\tisLayoutCentered(): boolean;\n\n\t/**\n\t * Enforce editor part options temporarily.\n\t */\n\tenforcePartOptions(options: DeepPartial<IEditorPartOptions>): IDisposable;\n}\n\nexport interface IAuxiliaryEditorPart extends IEditorPart {\n\n\t/**\n\t * Close this auxiliary editor part after moving all\n\t * editors of all groups back to the main editor part.\n\t *\n\t * @returns `false` if an editor could not be moved back.\n\t */\n\tclose(): boolean;\n}\n\nexport interface IEditorWorkingSet {\n\treadonly id: string;\n\treadonly name: string;\n}\n\nexport interface IEditorWorkingSetOptions {\n\treadonly preserveFocus?: boolean;\n}\n\nexport interface IEditorGroupContextKeyProvider<T extends ContextKeyValue> {\n\n\t/**\n\t * The context key that needs to be set for each editor group context and the global context.\n\t */\n\treadonly contextKey: RawContextKey<T>;\n\n\t/**\n\t * Retrieves the context key value for the given editor group.\n\t */\n\treadonly getGroupContextKeyValue: (group: IEditorGroup) => T;\n\n\t/**\n\t * An event that is fired when there was a change leading to the context key value to be re-evaluated.\n\t */\n\treadonly onDidChange?: Event<void>;\n}\n\n/**\n * The main service to interact with editor groups across all opened editor parts.\n */\nexport interface IEditorGroupsService extends IEditorGroupsContainer {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * An event for when a new auxiliary editor part is created.\n\t */\n\treadonly onDidCreateAuxiliaryEditorPart: Event<IAuxiliaryEditorPart>;\n\n\t/**\n\t * Provides access to the main window editor part.\n\t */\n\treadonly mainPart: IEditorPart;\n\n\t/**\n\t * Provides access to all editor parts.\n\t */\n\treadonly parts: ReadonlyArray<IEditorPart>;\n\n\t/**\n\t * Get the editor part that contains the group with the provided identifier.\n\t */\n\tgetPart(group: IEditorGroup | GroupIdentifier): IEditorPart;\n\n\t/**\n\t * Get the editor part that is rooted in the provided container.\n\t */\n\tgetPart(container: unknown /* HTMLElement */): IEditorPart;\n\n\t/**\n\t * Access the options of the editor part.\n\t */\n\treadonly partOptions: IEditorPartOptions;\n\n\t/**\n\t * An event that notifies when editor part options change.\n\t */\n\treadonly onDidChangeEditorPartOptions: Event<IEditorPartOptionsChangeEvent>;\n\n\t/**\n\t * Opens a new window with a full editor part instantiated\n\t * in there at the optional position and size on screen.\n\t */\n\tcreateAuxiliaryEditorPart(options?: { bounds?: Partial<IRectangle> }): Promise<IAuxiliaryEditorPart>;\n\n\t/**\n\t * Returns the instantiation service that is scoped to the\n\t * provided editor part. Use this method when building UI\n\t * that contributes to auxiliary editor parts to ensure the\n\t * UI is scoped to that part.\n\t */\n\tgetScopedInstantiationService(part: IEditorPart): IInstantiationService;\n\n\t/**\n\t * Save a new editor working set from the currently opened\n\t * editors and group layout.\n\t */\n\tsaveWorkingSet(name: string): IEditorWorkingSet;\n\n\t/**\n\t * Returns all known editor working sets.\n\t */\n\tgetWorkingSets(): IEditorWorkingSet[];\n\n\t/**\n\t * Applies the working set. Use `empty` to apply an empty working set.\n\t *\n\t * @returns `true` when the working set as applied.\n\t */\n\tapplyWorkingSet(workingSet: IEditorWorkingSet | 'empty', options?: IEditorWorkingSetOptions): Promise<boolean>;\n\n\t/**\n\t * Deletes a working set.\n\t */\n\tdeleteWorkingSet(workingSet: IEditorWorkingSet): void;\n\n\t/**\n\t * Registers a context key provider. This provider sets a context key for each scoped editor group context and the global context.\n\t *\n\t * @param provider - The context key provider to be registered.\n\t * @returns - A disposable object to unregister the provider.\n\t */\n\tregisterContextKeyProvider<T extends ContextKeyValue>(provider: IEditorGroupContextKeyProvider<T>): IDisposable;\n}\n\nexport const enum OpenEditorContext {\n\tNEW_EDITOR = 1,\n\tMOVE_EDITOR = 2,\n\tCOPY_EDITOR = 3\n}\n\nexport interface IActiveEditorActions {\n\treadonly actions: IToolbarActions;\n\treadonly onDidChange: Event<IMenuChangeEvent | void>;\n}\n\nexport interface IEditorGroup {\n\n\t/**\n\t * An event which fires whenever the underlying group model changes.\n\t */\n\treadonly onDidModelChange: Event<IGroupModelChangeEvent>;\n\n\t/**\n\t * An event that is fired when the group gets disposed.\n\t */\n\treadonly onWillDispose: Event<void>;\n\n\t/**\n\t * An event that is fired when the active editor in the group changed.\n\t */\n\treadonly onDidActiveEditorChange: Event<IActiveEditorChangeEvent>;\n\n\t/**\n\t * An event that is fired when an editor is about to close.\n\t */\n\treadonly onWillCloseEditor: Event<IEditorCloseEvent>;\n\n\t/**\n\t * An event that is fired when an editor is closed.\n\t */\n\treadonly onDidCloseEditor: Event<IEditorCloseEvent>;\n\n\t/**\n\t * An event that is fired when an editor is about to move to\n\t * a different group.\n\t */\n\treadonly onWillMoveEditor: Event<IEditorWillMoveEvent>;\n\n\t/**\n\t * A unique identifier of this group that remains identical even if the\n\t * group is moved to different locations.\n\t */\n\treadonly id: GroupIdentifier;\n\n\t/**\n\t * The identifier of the window this editor group is part of.\n\t */\n\treadonly windowId: number;\n\n\t/**\n\t * A number that indicates the position of this group in the visual\n\t * order of groups from left to right and top to bottom. The lowest\n\t * index will likely be top-left while the largest index in most\n\t * cases should be bottom-right, but that depends on the grid.\n\t */\n\treadonly index: number;\n\n\t/**\n\t * A human readable label for the group. This label can change depending\n\t * on the layout of all editor groups. Clients should listen on the\n\t * `onDidGroupModelChange` event to react to that.\n\t */\n\treadonly label: string;\n\n\t/**\n\t * A human readable label for the group to be used by screen readers.\n\t */\n\treadonly ariaLabel: string;\n\n\t/**\n\t * The active editor pane is the currently visible editor pane of the group.\n\t */\n\treadonly activeEditorPane: IVisibleEditorPane | undefined;\n\n\t/**\n\t * The active editor is the currently visible editor of the group\n\t * within the current active editor pane.\n\t */\n\treadonly activeEditor: EditorInput | null;\n\n\t/**\n\t * All selected editor in this group in sequential order.\n\t * The active editor is always part of the selection.\n\t */\n\treadonly selectedEditors: EditorInput[];\n\n\t/**\n\t * The editor in the group that is in preview mode if any. There can\n\t * only ever be one editor in preview mode.\n\t */\n\treadonly previewEditor: EditorInput | null;\n\n\t/**\n\t * The number of opened editors in this group.\n\t */\n\treadonly count: number;\n\n\t/**\n\t * Whether the group has editors or not.\n\t */\n\treadonly isEmpty: boolean;\n\n\t/**\n\t * Whether this editor group is locked or not. Locked editor groups\n\t * will only be considered for editors to open in when the group is\n\t * explicitly provided for the editor.\n\t *\n\t * Note: editor group locking only applies when more than one group\n\t * is opened.\n\t */\n\treadonly isLocked: boolean;\n\n\t/**\n\t * The number of sticky editors in this group.\n\t */\n\treadonly stickyCount: number;\n\n\t/**\n\t * All opened editors in the group in sequential order of their appearance.\n\t */\n\treadonly editors: readonly EditorInput[];\n\n\t/**\n\t * The scoped context key service for this group.\n\t */\n\treadonly scopedContextKeyService: IContextKeyService;\n\n\t/**\n\t * Get all editors that are currently opened in the group.\n\t *\n\t * @param order the order of the editors to use\n\t * @param options options to select only specific editors as instructed\n\t */\n\tgetEditors(order: EditorsOrder, options?: { excludeSticky?: boolean }): readonly EditorInput[];\n\n\t/**\n\t * Finds all editors for the given resource that are currently\n\t * opened in the group. This method will return an entry for\n\t * each editor that reports a `resource` that matches the\n\t * provided one.\n\t *\n\t * @param resource the resource of the editor to find\n\t * @param options whether to support side by side editors or not\n\t */\n\tfindEditors(resource: URI, options?: IFindEditorOptions): readonly EditorInput[];\n\n\t/**\n\t * Returns the editor at a specific index of the group.\n\t */\n\tgetEditorByIndex(index: number): EditorInput | undefined;\n\n\t/**\n\t * Returns the index of the editor in the group or -1 if not opened.\n\t */\n\tgetIndexOfEditor(editor: EditorInput): number;\n\n\t/**\n\t * Whether the editor is the first in the group.\n\t */\n\tisFirst(editor: EditorInput): boolean;\n\n\t/**\n\t * Whether the editor is the last in the group.\n\t */\n\tisLast(editor: EditorInput): boolean;\n\n\t/**\n\t * Open an editor in this group.\n\t *\n\t * @returns a promise that resolves around an IEditor instance unless\n\t * the call failed, or the editor was not opened as active editor.\n\t */\n\topenEditor(editor: EditorInput, options?: IEditorOptions): Promise<IEditorPane | undefined>;\n\n\t/**\n\t * Opens editors in this group.\n\t *\n\t * @returns a promise that resolves around an IEditor instance unless\n\t * the call failed, or the editor was not opened as active editor. Since\n\t * a group can only ever have one active editor, even if many editors are\n\t * opened, the result will only be one editor.\n\t */\n\topenEditors(editors: EditorInputWithOptions[]): Promise<IEditorPane | undefined>;\n\n\t/**\n\t * Find out if the provided editor is pinned in the group.\n\t */\n\tisPinned(editorOrIndex: EditorInput | number): boolean;\n\n\t/**\n\t * Find out if the provided editor or index of editor is sticky in the group.\n\t */\n\tisSticky(editorOrIndex: EditorInput | number): boolean;\n\n\t/**\n\t * Find out if the provided editor or index of editor is transient in the group.\n\t */\n\tisTransient(editorOrIndex: EditorInput | number): boolean;\n\n\t/**\n\t * Find out if the provided editor is active in the group.\n\t */\n\tisActive(editor: EditorInput | IUntypedEditorInput): boolean;\n\n\t/**\n\t * Whether the editor is selected in the group.\n\t */\n\tisSelected(editor: EditorInput): boolean;\n\n\t/**\n\t * Set a new selection for this group. This will replace the current\n\t * selection with the new selection.\n\t *\n\t * @param activeSelectedEditor the editor to set as active selected editor\n\t * @param inactiveSelectedEditors the inactive editors to set as selected\n\t */\n\tsetSelection(activeSelectedEditor: EditorInput, inactiveSelectedEditors: EditorInput[]): Promise<void>;\n\n\t/**\n\t * Find out if a certain editor is included in the group.\n\t *\n\t * @param candidate the editor to find\n\t * @param options fine tune how to match editors\n\t */\n\tcontains(candidate: EditorInput | IUntypedEditorInput, options?: IMatchEditorOptions): boolean;\n\n\t/**\n\t * Move an editor from this group either within this group or to another group.\n\t *\n\t * @returns whether the editor was moved or not.\n\t */\n\tmoveEditor(editor: EditorInput, target: IEditorGroup, options?: IEditorOptions): boolean;\n\n\t/**\n\t * Move editors from this group either within this group or to another group.\n\t *\n\t * @returns whether all editors were moved or not.\n\t */\n\tmoveEditors(editors: EditorInputWithOptions[], target: IEditorGroup): boolean;\n\n\t/**\n\t * Copy an editor from this group to another group.\n\t *\n\t * Note: It is currently not supported to show the same editor more than once in the same group.\n\t */\n\tcopyEditor(editor: EditorInput, target: IEditorGroup, options?: IEditorOptions): void;\n\n\t/**\n\t * Copy editors from this group to another group.\n\t *\n\t * Note: It is currently not supported to show the same editor more than once in the same group.\n\t */\n\tcopyEditors(editors: EditorInputWithOptions[], target: IEditorGroup): void;\n\n\t/**\n\t * Close an editor from the group. This may trigger a confirmation dialog if\n\t * the editor is dirty and thus returns a promise as value.\n\t *\n\t * @param editor the editor to close, or the currently active editor\n\t * if unspecified.\n\t *\n\t * @returns a promise when the editor is closed or not. If `true`, the editor\n\t * is closed and if `false` there was a veto closing the editor, e.g. when it\n\t * is dirty.\n\t */\n\tcloseEditor(editor?: EditorInput, options?: ICloseEditorOptions): Promise<boolean>;\n\n\t/**\n\t * Closes specific editors in this group. This may trigger a confirmation dialog if\n\t * there are dirty editors and thus returns a promise as value.\n\t *\n\t * @returns a promise whether the editors were closed or not. If `true`, the editors\n\t * were closed and if `false` there was a veto closing the editors, e.g. when one\n\t * is dirty.\n\t */\n\tcloseEditors(editors: EditorInput[] | ICloseEditorsFilter, options?: ICloseEditorOptions): Promise<boolean>;\n\n\t/**\n\t * Closes all editors from the group. This may trigger a confirmation dialog if\n\t * there are dirty editors and thus returns a promise as value.\n\t *\n\t * @returns a promise when all editors are closed.\n\t */\n\tcloseAllEditors(options?: ICloseAllEditorsOptions): Promise<boolean>;\n\n\t/**\n\t * Replaces editors in this group with the provided replacement.\n\t *\n\t * @param editors the editors to replace\n\t *\n\t * @returns a promise that is resolved when the replaced active\n\t * editor (if any) has finished loading.\n\t */\n\treplaceEditors(editors: IEditorReplacement[]): Promise<void>;\n\n\t/**\n\t * Set an editor to be pinned. A pinned editor is not replaced\n\t * when another editor opens at the same location.\n\t *\n\t * @param editor the editor to pin, or the currently active editor\n\t * if unspecified.\n\t */\n\tpinEditor(editor?: EditorInput): void;\n\n\t/**\n\t * Set an editor to be sticky. A sticky editor is showing in the beginning\n\t * of the tab stripe and will not be impacted by close operations.\n\t *\n\t * @param editor the editor to make sticky, or the currently active editor\n\t * if unspecified.\n\t */\n\tstickEditor(editor?: EditorInput): void;\n\n\t/**\n\t * Set an editor to be non-sticky and thus moves back to a location after\n\t * sticky editors and can be closed normally.\n\t *\n\t * @param editor the editor to make unsticky, or the currently active editor\n\t * if unspecified.\n\t */\n\tunstickEditor(editor?: EditorInput): void;\n\n\t/**\n\t * Whether this editor group should be locked or not.\n\t *\n\t * See {@linkcode IEditorGroup.isLocked `isLocked`}\n\t */\n\tlock(locked: boolean): void;\n\n\t/**\n\t * Move keyboard focus into the group.\n\t */\n\tfocus(): void;\n\n\t/**\n\t * Create the editor actions for the current active editor.\n\t */\n\tcreateEditorActions(disposables: DisposableStore): IActiveEditorActions;\n}\n\nexport function isEditorGroup(obj: unknown): obj is IEditorGroup {\n\tconst group = obj as IEditorGroup | undefined;\n\n\treturn !!group && typeof group.id === 'number' && Array.isArray(group.editors);\n}\n\n//#region Editor Group Helpers\n\nexport function preferredSideBySideGroupDirection(configurationService: IConfigurationService): GroupDirection.DOWN | GroupDirection.RIGHT {\n\tconst openSideBySideDirection = configurationService.getValue('workbench.editor.openSideBySideDirection');\n\n\tif (openSideBySideDirection === 'down') {\n\t\treturn GroupDirection.DOWN;\n\t}\n\n\treturn GroupDirection.RIGHT;\n}\n\n//#endregion\n"],
  "mappings": ";;AAKA,SAAS,aAAa;AACtB,SAAS,uBAAuB,uBAAuB;AACvD,SAAS,aAAa,iBAAiB,wBAAwB,gBAAgB,oBAAoB,+BAA+B,cAAc,oBAAoB,mBAAmB,qBAAqB,eAAe,sBAAsB,qBAAqB,0BAA0B,oBAAoB,uBAAuB;AAC3U,SAAS,mBAAmB;AAC5B,SAAS,sBAAsB;AAC/B,SAAS,6BAA6B;AACtC,SAAS,kBAAkB;AAC3B,SAAS,iBAAiB,mBAAmB;AAC7C,SAAS,iBAAiB,oBAAoB,qBAAqB;AACnE,SAAS,WAAW;AACpB,SAAS,8BAA8B;AACvC,SAAS,kBAAkB;AAC3B,SAAS,wBAAwB;AACjC,SAAS,mBAAmB;AAErB,MAAM,uBAAuB,gBAAsC,qBAAqB;AAExF,IAAW,iBAAX,kBAAWA,oBAAX;AACN,EAAAA,gCAAA;AACA,EAAAA,gCAAA;AACA,EAAAA,gCAAA;AACA,EAAAA,gCAAA;AAJiB,SAAAA;AAAA,GAAA;AAOX,IAAW,mBAAX,kBAAWC,sBAAX;AACN,EAAAA,oCAAA;AACA,EAAAA,oCAAA;AAFiB,SAAAA;AAAA,GAAA;AAKX,IAAW,gBAAX,kBAAWC,mBAAX;AACN,EAAAA,8BAAA;AACA,EAAAA,8BAAA;AACA,EAAAA,8BAAA;AACA,EAAAA,8BAAA;AAJiB,SAAAA;AAAA,GAAA;AAYX,IAAW,oBAAX,kBAAWC,uBAAX;AAKN,EAAAA,sCAAA;AAMA,EAAAA,sCAAA;AAKA,EAAAA,sCAAA;AAhBiB,SAAAA;AAAA,GAAA;AAiDX,IAAW,iBAAX,kBAAWC,oBAAX;AACN,EAAAA,gCAAA;AACA,EAAAA,gCAAA;AAFiB,SAAAA;AAAA,GAAA;AAsCX,SAAS,oBAAoB,aAAyD;AAC5F,QAAM,YAAY;AAElB,SAAO,cAAc,WAAW,MAAM,KAAK,cAAc,WAAW,WAAW;AAChF;AAJgB;AAMT,IAAW,cAAX,kBAAWC,iBAAX;AAKN,EAAAA,0BAAA;AAKA,EAAAA,0BAAA;AAKA,EAAAA,0BAAA;AAfiB,SAAAA;AAAA,GAAA;AA+cX,IAAW,oBAAX,kBAAWC,uBAAX;AACN,EAAAA,sCAAA,gBAAa,KAAb;AACA,EAAAA,sCAAA,iBAAc,KAAd;AACA,EAAAA,sCAAA,iBAAc,KAAd;AAHiB,SAAAA;AAAA,GAAA;AA0VX,SAAS,cAAc,KAAmC;AAChE,QAAM,QAAQ;AAEd,SAAO,CAAC,CAAC,SAAS,OAAO,MAAM,OAAO,YAAY,MAAM,QAAQ,MAAM,OAAO;AAC9E;AAJgB;AAQT,SAAS,kCAAkC,sBAAyF;AAC1I,QAAM,0BAA0B,qBAAqB,SAAS,0CAA0C;AAExG,MAAI,4BAA4B,QAAQ;AACvC,WAAO;AAAA,EACR;AAEA,SAAO;AACR;AARgB;",
  "names": ["GroupDirection", "GroupOrientation", "GroupLocation", "GroupsArrangement", "MergeGroupMode", "GroupsOrder", "OpenEditorContext"]
}
