{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/editor/common/editorService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { Event } from \"../../../../base/common/event.js\";\nimport type { DisposableStore } from \"../../../../base/common/lifecycle.js\";\nimport type { URI } from \"../../../../base/common/uri.js\";\nimport type {\n\tIDiffEditor,\n\tIEditor,\n} from \"../../../../editor/common/editorCommon.js\";\nimport type {\n\tIEditorOptions,\n\tIResourceEditorInput,\n\tIResourceEditorInputIdentifier,\n\tITextResourceEditorInput,\n} from \"../../../../platform/editor/common/editor.js\";\nimport { createDecorator } from \"../../../../platform/instantiation/common/instantiation.js\";\nimport type {\n\tEditorsOrder,\n\tGroupIdentifier,\n\tIEditorCloseEvent,\n\tIEditorIdentifier,\n\tIEditorPane,\n\tIEditorWillOpenEvent,\n\tIFindEditorOptions,\n\tIResourceDiffEditorInput,\n\tIRevertOptions,\n\tISaveOptions,\n\tITextDiffEditorPane,\n\tIUntitledTextResourceEditorInput,\n\tIUntypedEditorInput,\n\tIVisibleEditorPane,\n} from \"../../../common/editor.js\";\nimport type { IGroupModelChangeEvent } from \"../../../common/editor/editorGroupModel.js\";\nimport type { EditorInput } from \"../../../common/editor/editorInput.js\";\nimport {\n\ttype ICloseEditorOptions,\n\ttype IEditorGroup,\n\ttype IEditorGroupsContainer,\n\tisEditorGroup,\n} from \"./editorGroupsService.js\";\n\nexport const IEditorService = createDecorator<IEditorService>(\"editorService\");\n\n/**\n * Open an editor in the currently active group.\n */\nexport const ACTIVE_GROUP = -1;\nexport type ACTIVE_GROUP_TYPE = typeof ACTIVE_GROUP;\n\n/**\n * Open an editor to the side of the active group.\n */\nexport const SIDE_GROUP = -2;\nexport type SIDE_GROUP_TYPE = typeof SIDE_GROUP;\n\n/**\n * Open an editor in a new auxiliary window.\n */\nexport const AUX_WINDOW_GROUP = -3;\nexport type AUX_WINDOW_GROUP_TYPE = typeof AUX_WINDOW_GROUP;\n\nexport type PreferredGroup =\n\t| IEditorGroup\n\t| GroupIdentifier\n\t| SIDE_GROUP_TYPE\n\t| ACTIVE_GROUP_TYPE\n\t| AUX_WINDOW_GROUP_TYPE;\n\nexport function isPreferredGroup(obj: unknown): obj is PreferredGroup {\n\tconst candidate = obj as PreferredGroup | undefined;\n\n\treturn typeof obj === \"number\" || isEditorGroup(candidate);\n}\n\nexport interface ISaveEditorsOptions extends ISaveOptions {\n\t/**\n\t * If true, will ask for a location of the editor to save to.\n\t */\n\treadonly saveAs?: boolean;\n}\n\nexport interface ISaveEditorsResult {\n\t/**\n\t * Whether the save operation was successful.\n\t */\n\treadonly success: boolean;\n\n\t/**\n\t * Resulting editors after the save operation.\n\t */\n\treadonly editors: Array<EditorInput | IUntypedEditorInput>;\n}\n\nexport interface IUntypedEditorReplacement {\n\t/**\n\t * The editor to replace.\n\t */\n\treadonly editor: EditorInput;\n\n\t/**\n\t * The replacement for the editor.\n\t */\n\treadonly replacement: IUntypedEditorInput;\n\n\t/**\n\t * Skips asking the user for confirmation and doesn't\n\t * save the document. Only use this if you really need to!\n\t */\n\tforceReplaceDirty?: boolean;\n}\n\nexport interface IBaseSaveRevertAllEditorOptions {\n\t/**\n\t * Whether to include untitled editors as well.\n\t */\n\treadonly includeUntitled?:\n\t\t| {\n\t\t\t\t/**\n\t\t\t\t * Whether to include scratchpad editors.\n\t\t\t\t * Scratchpads are not included if not specified.\n\t\t\t\t */\n\t\t\t\treadonly includeScratchpad: boolean;\n\t\t  }\n\t\t| boolean;\n\n\t/**\n\t * Whether to exclude sticky editors.\n\t */\n\treadonly excludeSticky?: boolean;\n}\n\nexport interface ISaveAllEditorsOptions\n\textends ISaveEditorsOptions,\n\t\tIBaseSaveRevertAllEditorOptions {}\n\nexport interface IRevertAllEditorsOptions\n\textends IRevertOptions,\n\t\tIBaseSaveRevertAllEditorOptions {}\n\nexport interface IOpenEditorsOptions {\n\t/**\n\t * Whether to validate trust when opening editors\n\t * that are potentially not inside the workspace.\n\t */\n\treadonly validateTrust?: boolean;\n}\n\nexport interface IEditorsChangeEvent {\n\t/**\n\t * The group which had the editor change\n\t */\n\tgroupId: GroupIdentifier;\n\t/*\n\t * The event fired from the model\n\t */\n\tevent: IGroupModelChangeEvent;\n}\n\nexport interface IEditorService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Emitted when the currently active editor changes.\n\t *\n\t * @see {@link IEditorService.activeEditorPane}\n\t */\n\treadonly onDidActiveEditorChange: Event<void>;\n\n\t/**\n\t * Emitted when any of the current visible editors changes.\n\t *\n\t * @see {@link IEditorService.visibleEditorPanes}\n\t */\n\treadonly onDidVisibleEditorsChange: Event<void>;\n\n\t/**\n\t * An aggregated event for any change to any editor across\n\t * all groups.\n\t */\n\treadonly onDidEditorsChange: Event<IEditorsChangeEvent>;\n\n\t/**\n\t * Emitted when an editor is about to open.\n\t */\n\treadonly onWillOpenEditor: Event<IEditorWillOpenEvent>;\n\n\t/**\n\t * Emitted when an editor is closed.\n\t */\n\treadonly onDidCloseEditor: Event<IEditorCloseEvent>;\n\n\t/**\n\t * The currently active editor pane or `undefined` if none. The editor pane is\n\t * the workbench container for editors of any kind.\n\t *\n\t * @see {@link IEditorService.activeEditor} for access to the active editor input\n\t */\n\treadonly activeEditorPane: IVisibleEditorPane | undefined;\n\n\t/**\n\t * The currently active editor or `undefined` if none. An editor is active when it is\n\t * located in the currently active editor group. It will be `undefined` if the active\n\t * editor group has no editors open.\n\t */\n\treadonly activeEditor: EditorInput | undefined;\n\n\t/**\n\t * The currently active text editor control or `undefined` if there is currently no active\n\t * editor or the active editor widget is neither a text nor a diff editor.\n\t *\n\t * @see {@link IEditorService.activeEditor}\n\t */\n\treadonly activeTextEditorControl: IEditor | IDiffEditor | undefined;\n\n\t/**\n\t * The currently active text editor language id or `undefined` if there is currently no active\n\t * editor or the active editor control is neither a text nor a diff editor. If the active\n\t * editor is a diff editor, the modified side's language id will be taken.\n\t */\n\treadonly activeTextEditorLanguageId: string | undefined;\n\n\t/**\n\t * All editor panes that are currently visible across all editor groups.\n\t *\n\t * @see {@link IEditorService.visibleEditors} for access to the visible editor inputs\n\t */\n\treadonly visibleEditorPanes: readonly IVisibleEditorPane[];\n\n\t/**\n\t * All editors that are currently visible. An editor is visible when it is opened in an\n\t * editor group and active in that group. Multiple editor groups can be opened at the same time.\n\t */\n\treadonly visibleEditors: readonly EditorInput[];\n\n\t/**\n\t * All text editor widgets that are currently visible across all editor groups. A text editor\n\t * widget is either a text or a diff editor.\n\t *\n\t * This property supports side-by-side editors as well, by returning both sides if they are\n\t * text editor widgets.\n\t */\n\treadonly visibleTextEditorControls: readonly (IEditor | IDiffEditor)[];\n\n\t/**\n\t * All editors that are opened across all editor groups in sequential order\n\t * of appearance.\n\t *\n\t * This includes active as well as inactive editors in each editor group.\n\t */\n\treadonly editors: readonly EditorInput[];\n\n\t/**\n\t * The total number of editors that are opened either inactive or active.\n\t */\n\treadonly count: number;\n\n\t/**\n\t * All editors that are opened across all editor groups with their group\n\t * identifier.\n\t *\n\t * @param order the order of the editors to use\n\t * @param options whether to exclude sticky editors or not\n\t */\n\tgetEditors(\n\t\torder: EditorsOrder,\n\t\toptions?: { excludeSticky?: boolean },\n\t): readonly IEditorIdentifier[];\n\n\t/**\n\t * Open an editor in an editor group.\n\t *\n\t * @param editor the editor to open\n\t * @param options the options to use for the editor\n\t * @param group the target group. If unspecified, the editor will open in the currently\n\t * active group. Use `SIDE_GROUP` to open the editor in a new editor group to the side\n\t * of the currently active group.\n\t *\n\t * @returns the editor that opened or `undefined` if the operation failed or the editor was not\n\t * opened to be active.\n\t */\n\topenEditor(\n\t\teditor: IResourceEditorInput,\n\t\tgroup?:\n\t\t\t| IEditorGroup\n\t\t\t| GroupIdentifier\n\t\t\t| SIDE_GROUP_TYPE\n\t\t\t| ACTIVE_GROUP_TYPE\n\t\t\t| AUX_WINDOW_GROUP_TYPE,\n\t): Promise<IEditorPane | undefined>;\n\topenEditor(\n\t\teditor: ITextResourceEditorInput | IUntitledTextResourceEditorInput,\n\t\tgroup?:\n\t\t\t| IEditorGroup\n\t\t\t| GroupIdentifier\n\t\t\t| SIDE_GROUP_TYPE\n\t\t\t| ACTIVE_GROUP_TYPE\n\t\t\t| AUX_WINDOW_GROUP_TYPE,\n\t): Promise<IEditorPane | undefined>;\n\topenEditor(\n\t\teditor: IResourceDiffEditorInput,\n\t\tgroup?:\n\t\t\t| IEditorGroup\n\t\t\t| GroupIdentifier\n\t\t\t| SIDE_GROUP_TYPE\n\t\t\t| ACTIVE_GROUP_TYPE\n\t\t\t| AUX_WINDOW_GROUP_TYPE,\n\t): Promise<ITextDiffEditorPane | undefined>;\n\topenEditor(\n\t\teditor: IUntypedEditorInput,\n\t\tgroup?:\n\t\t\t| IEditorGroup\n\t\t\t| GroupIdentifier\n\t\t\t| SIDE_GROUP_TYPE\n\t\t\t| ACTIVE_GROUP_TYPE\n\t\t\t| AUX_WINDOW_GROUP_TYPE,\n\t): Promise<IEditorPane | undefined>;\n\n\t/**\n\t * @deprecated using this method is a sign that your editor has not adopted the editor\n\t * resolver yet. Please use `IEditorResolverService.registerEditor` to make your editor\n\t * known to the workbench and then use untyped editor inputs for opening:\n\t *\n\t * ```ts\n\t * editorService.openEditor({ resource });\n\t * ```\n\t *\n\t * If you already have an `EditorInput` in hand and must use it for opening, use `group.openEditor`\n\t * instead, via `IEditorGroupsService`.\n\t */\n\topenEditor(\n\t\teditor: EditorInput,\n\t\toptions?: IEditorOptions,\n\t\tgroup?:\n\t\t\t| IEditorGroup\n\t\t\t| GroupIdentifier\n\t\t\t| SIDE_GROUP_TYPE\n\t\t\t| ACTIVE_GROUP_TYPE\n\t\t\t| AUX_WINDOW_GROUP_TYPE,\n\t): Promise<IEditorPane | undefined>;\n\n\t/**\n\t * Open editors in an editor group.\n\t *\n\t * @param editors the editors to open with associated options\n\t * @param group the target group. If unspecified, the editor will open in the currently\n\t * active group. Use `SIDE_GROUP` to open the editor in a new editor group to the side\n\t * of the currently active group.\n\t *\n\t * @returns the editors that opened. The array can be empty or have less elements for editors\n\t * that failed to open or were instructed to open as inactive.\n\t */\n\topenEditors(\n\t\teditors: IUntypedEditorInput[],\n\t\tgroup?:\n\t\t\t| IEditorGroup\n\t\t\t| GroupIdentifier\n\t\t\t| SIDE_GROUP_TYPE\n\t\t\t| ACTIVE_GROUP_TYPE\n\t\t\t| AUX_WINDOW_GROUP_TYPE,\n\t\toptions?: IOpenEditorsOptions,\n\t): Promise<readonly IEditorPane[]>;\n\n\t/**\n\t * Replaces editors in an editor group with the provided replacement.\n\t *\n\t * @param replacements the editors to replace\n\t * @param group the editor group\n\t *\n\t * @returns a promise that is resolved when the replaced active\n\t * editor (if any) has finished loading.\n\t */\n\treplaceEditors(\n\t\treplacements: IUntypedEditorReplacement[],\n\t\tgroup: IEditorGroup | GroupIdentifier,\n\t): Promise<void>;\n\n\t/**\n\t * Find out if the provided editor is opened in any editor group.\n\t *\n\t * Note: An editor can be opened but not actively visible.\n\t *\n\t * Note: This method will return `true` if a side by side editor\n\t * is opened where the `primary` editor matches too.\n\t */\n\tisOpened(editor: IResourceEditorInputIdentifier): boolean;\n\n\t/**\n\t * Find out if the provided editor is visible in any editor group.\n\t */\n\tisVisible(editor: EditorInput): boolean;\n\n\t/**\n\t * Close an editor in a specific editor group.\n\t */\n\tcloseEditor(\n\t\teditor: IEditorIdentifier,\n\t\toptions?: ICloseEditorOptions,\n\t): Promise<void>;\n\n\t/**\n\t * Close multiple editors in specific editor groups.\n\t */\n\tcloseEditors(\n\t\teditors: readonly IEditorIdentifier[],\n\t\toptions?: ICloseEditorOptions,\n\t): Promise<void>;\n\n\t/**\n\t * This method will return an entry for each editor that reports\n\t * a `resource` that matches the provided one in the group or\n\t * across all groups.\n\t *\n\t * It is possible that multiple editors are returned in case the\n\t * same resource is opened in different editors. To find the specific\n\t * editor, use the `IResourceEditorInputIdentifier` as input.\n\t */\n\tfindEditors(\n\t\tresource: URI,\n\t\toptions?: IFindEditorOptions,\n\t): readonly IEditorIdentifier[];\n\tfindEditors(\n\t\teditor: IResourceEditorInputIdentifier,\n\t\toptions?: IFindEditorOptions,\n\t): readonly IEditorIdentifier[];\n\n\t/**\n\t * Save the provided list of editors.\n\t */\n\tsave(\n\t\teditors: IEditorIdentifier | IEditorIdentifier[],\n\t\toptions?: ISaveEditorsOptions,\n\t): Promise<ISaveEditorsResult>;\n\n\t/**\n\t * Save all editors.\n\t */\n\tsaveAll(options?: ISaveAllEditorsOptions): Promise<ISaveEditorsResult>;\n\n\t/**\n\t * Reverts the provided list of editors.\n\t *\n\t * @returns `true` if all editors reverted and `false` otherwise.\n\t */\n\trevert(\n\t\teditors: IEditorIdentifier | IEditorIdentifier[],\n\t\toptions?: IRevertOptions,\n\t): Promise<boolean>;\n\n\t/**\n\t * Reverts all editors.\n\t *\n\t * @returns `true` if all editors reverted and `false` otherwise.\n\t */\n\trevertAll(options?: IRevertAllEditorsOptions): Promise<boolean>;\n\n\t/**\n\t * Create a scoped editor service that only operates on the provided\n\t * editor group container. Use `main` to create a scoped editor service\n\t * to the main editor group container of the main window.\n\t */\n\tcreateScoped(\n\t\teditorGroupsContainer: IEditorGroupsContainer | \"main\",\n\t\tdisposables: DisposableStore,\n\t): IEditorService;\n}\n"],
  "mappings": ";;AAkBA,SAAS,uBAAuB;AAmBhC;AAAA,EAIC;AAAA,OACM;AAEA,MAAM,iBAAiB,gBAAgC,eAAe;AAKtE,MAAM,eAAe;AAMrB,MAAM,aAAa;AAMnB,MAAM,mBAAmB;AAUzB,SAAS,iBAAiB,KAAqC;AACrE,QAAM,YAAY;AAElB,SAAO,OAAO,QAAQ,YAAY,cAAc,SAAS;AAC1D;AAJgB;",
  "names": []
}
