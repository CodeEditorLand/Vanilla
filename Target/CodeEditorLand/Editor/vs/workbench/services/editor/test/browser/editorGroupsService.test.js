import t from"assert";import{workbenchInstantiationService as R,registerTestEditor as et,TestFileEditorInput as H,TestServiceAccessor as B,workbenchTeardown as it,createEditorParts as U}from"../../../../test/browser/workbenchTestServices.js";import{GroupDirection as y,GroupsOrder as D,MergeGroupMode as X,GroupOrientation as L,GroupLocation as A,isEditorGroup as ot,IEditorGroupsService as rt,GroupsArrangement as st}from"../../common/editorGroupsService.js";import{CloseDirection as K,EditorsOrder as I,EditorInputCapabilities as $,GroupModelChangeKind as S,SideBySideEditor as V,EditorExtensions as at}from"../../../../common/editor.js";import{URI as a}from"../../../../../base/common/uri.js";import{SyncDescriptor as j}from"../../../../../platform/instantiation/common/descriptors.js";import{DisposableStore as F}from"../../../../../base/common/lifecycle.js";import{MockScopableContextKeyService as N}from"../../../../../platform/keybinding/test/common/mockKeybindingService.js";import{ConfirmResult as b}from"../../../../../platform/dialogs/common/dialogs.js";import{TestConfigurationService as J}from"../../../../../platform/configuration/test/common/testConfigurationService.js";import{IConfigurationService as tt}from"../../../../../platform/configuration/common/configuration.js";import{SideBySideEditorInput as W}from"../../../../common/editor/sideBySideEditorInput.js";import"../../../../common/editor/editorGroupModel.js";import"../../../../../platform/instantiation/test/common/instantiationServiceMock.js";import{ensureNoDisposablesAreLeakedInTestSuite as nt}from"../../../../../base/test/common/utils.js";import{Registry as ct}from"../../../../../platform/registry/common/platform.js";import{IContextKeyService as z,RawContextKey as Y}from"../../../../../platform/contextkey/common/contextkey.js";import{Emitter as ut}from"../../../../../base/common/event.js";import{isEqual as lt}from"../../../../../base/common/resources.js";suite("EditorGroupsService",()=>{const Q="MyFileEditorForEditorGroupService",n="testEditorInputForEditorGroupService",k=new F;let _;setup(()=>{k.add(et(Q,[new j(H),new j(W)],n))}),teardown(async()=>{_&&(await it(_),_=void 0),k.clear()});async function Z(r=R(void 0,k)){r.invokeFunction(o=>ct.as(at.EditorFactory).start(o));const e=await U(r,k);return r.stub(rt,e),_=r,[e,r]}async function p(r){const[e,o]=await Z(r);return[e.testMainPart,o]}function c(r,e){return k.add(new H(r,e))}test("groups basics",async function(){const r=R({contextKeyService:w=>w.createInstance(N)},k),[e]=await p(r);let o=0;const i=e.onDidChangeActiveGroup(()=>{o++});let s=0;const u=e.onDidAddGroup(()=>{s++});let l=0;const d=e.onDidRemoveGroup(()=>{l++});let E=0;const g=e.onDidMoveGroup(()=>{E++}),q=e.groups[0];t.strictEqual(ot(q),!0),t.strictEqual(e.groups.length,1),t.strictEqual(e.count,1),t.strictEqual(q,e.getGroup(q.id)),t.ok(e.activeGroup===q),t.strictEqual(q.label,"Group 1");let f=e.getGroups(D.MOST_RECENTLY_ACTIVE);t.strictEqual(f.length,1),t.strictEqual(f[0],q);const G=e.addGroup(q,y.RIGHT);t.strictEqual(G,e.getGroup(G.id)),t.strictEqual(s,1),t.strictEqual(e.groups.length,2),t.strictEqual(e.count,2),t.ok(e.activeGroup===q),t.strictEqual(q.label,"Group 1"),t.strictEqual(G.label,"Group 2"),f=e.getGroups(D.MOST_RECENTLY_ACTIVE),t.strictEqual(f.length,2),t.strictEqual(f[0],q),t.strictEqual(f[1],G),t.strictEqual(o,0);let x=0;const h=q.onDidModelChange(w=>{w.kind===S.GROUP_ACTIVE&&x++});let T=0;const O=G.onDidModelChange(w=>{w.kind===S.GROUP_ACTIVE&&T++});e.activateGroup(G),t.ok(e.activeGroup===G),t.strictEqual(o,1),t.strictEqual(x,1),t.strictEqual(T,1),h.dispose(),O.dispose(),f=e.getGroups(D.MOST_RECENTLY_ACTIVE),t.strictEqual(f.length,2),t.strictEqual(f[0],G),t.strictEqual(f[1],q);const m=e.addGroup(G,y.DOWN);let C=!1;k.add(m.onWillDispose(()=>{C=!0})),t.strictEqual(s,2),t.strictEqual(e.groups.length,3),t.ok(e.activeGroup===G),t.ok(!m.activeEditorPane),t.strictEqual(q.label,"Group 1"),t.strictEqual(G.label,"Group 2"),t.strictEqual(m.label,"Group 3"),f=e.getGroups(D.MOST_RECENTLY_ACTIVE),t.strictEqual(f.length,3),t.strictEqual(f[0],G),t.strictEqual(f[1],q),t.strictEqual(f[2],m);const v=e.getGroups(D.GRID_APPEARANCE);t.strictEqual(v.length,3),t.strictEqual(v[0],q),t.strictEqual(v[0].index,0),t.strictEqual(v[1],G),t.strictEqual(v[1].index,1),t.strictEqual(v[2],m),t.strictEqual(v[2].index,2),e.moveGroup(m,G,y.DOWN),t.strictEqual(E,1),e.removeGroup(m),t.ok(!e.getGroup(m.id)),t.ok(!e.hasGroup(m.id)),t.strictEqual(C,!0),t.strictEqual(l,1),t.strictEqual(e.groups.length,2),t.ok(e.activeGroup===G),t.strictEqual(q.label,"Group 1"),t.strictEqual(G.label,"Group 2"),f=e.getGroups(D.MOST_RECENTLY_ACTIVE),t.strictEqual(f.length,2),t.strictEqual(f[0],G),t.strictEqual(f[1],q);const M=e.activeGroup.scopedContextKeyService,P=q.scopedContextKeyService;t.ok(M),t.ok(P),t.ok(M!==P),e.removeGroup(G),t.strictEqual(l,2),t.strictEqual(e.groups.length,1),t.ok(e.activeGroup===q),f=e.getGroups(D.MOST_RECENTLY_ACTIVE),t.strictEqual(f.length,1),t.strictEqual(f[0],q),e.removeGroup(q),t.strictEqual(e.groups.length,1),t.strictEqual(l,2),t.ok(e.activeGroup===q),e.setGroupOrientation(e.orientation===L.HORIZONTAL?L.VERTICAL:L.HORIZONTAL),i.dispose(),u.dispose(),d.dispose(),g.dispose()}),test("sideGroup",async()=>{const r=R({contextKeyService:l=>l.createInstance(N)},k),[e]=await p(r),o=e.activeGroup,i=c(a.file("foo/bar1"),n),s=c(a.file("foo/bar2"),n),u=c(a.file("foo/bar3"),n);await o.openEditor(i,{pinned:!0}),await e.sideGroup.openEditor(s,{pinned:!0}),t.strictEqual(e.count,2),e.activateGroup(o),await e.sideGroup.openEditor(u,{pinned:!0}),t.strictEqual(e.count,2)}),test("save & restore state",async function(){const[r,e]=await p(),o=r.groups[0],i=r.addGroup(o,y.RIGHT),s=r.addGroup(i,y.DOWN),u=c(a.file("foo/bar1"),n);await o.openEditor(u,{pinned:!0});const l=c(a.file("foo/bar2"),n);await i.openEditor(l,{pinned:!0}),t.strictEqual(r.groups.length,3),r.testSaveState(),r.dispose();const[d]=await p(e);t.strictEqual(d.groups.length,3),t.ok(d.getGroup(o.id)),t.ok(d.hasGroup(o.id)),t.ok(d.getGroup(i.id)),t.ok(d.hasGroup(i.id)),t.ok(d.getGroup(s.id)),t.ok(d.hasGroup(s.id)),d.clearState()}),test("groups index / labels",async function(){const[r]=await p(),e=r.groups[0],o=r.addGroup(e,y.RIGHT),i=r.addGroup(o,y.DOWN);let s=0;const u=r.onDidChangeGroupIndex(()=>{s++});let l=0;const d=i.onDidModelChange(g=>{g.kind===S.GROUP_INDEX&&l++});t.strictEqual(e.index,0),t.strictEqual(o.index,1),t.strictEqual(i.index,2),t.strictEqual(e.label,"Group 1"),t.strictEqual(o.label,"Group 2"),t.strictEqual(i.label,"Group 3"),r.removeGroup(o),t.strictEqual(e.index,0),t.strictEqual(i.index,1),t.strictEqual(e.label,"Group 1"),t.strictEqual(i.label,"Group 2"),t.strictEqual(l,1),t.strictEqual(s,1),r.moveGroup(i,e,y.UP),t.strictEqual(i.index,0),t.strictEqual(e.index,1),t.strictEqual(i.label,"Group 1"),t.strictEqual(e.label,"Group 2"),t.strictEqual(l,2),t.strictEqual(s,3);const E=r.addGroup(i,y.UP);t.strictEqual(E.index,0),t.strictEqual(i.index,1),t.strictEqual(e.index,2),t.strictEqual(E.label,"Group 1"),t.strictEqual(i.label,"Group 2"),t.strictEqual(e.label,"Group 3"),t.strictEqual(l,3),t.strictEqual(s,6),d.dispose(),u.dispose()}),test("groups label",async function(){const[r]=await p(),e=r.groups[0],o=r.addGroup(e,y.RIGHT);let i=0;const s=r.onDidChangeGroupLabel(()=>{i++});let u=0;const l=e.onDidModelChange(g=>{g.kind===S.GROUP_LABEL&&u++});let d=0;const E=o.onDidModelChange(g=>{g.kind===S.GROUP_LABEL&&d++});t.strictEqual(e.label,"Group 1"),t.strictEqual(o.label,"Group 2"),r.notifyGroupsLabelChange("Window 2"),t.strictEqual(e.label,"Window 2: Group 1"),t.strictEqual(o.label,"Window 2: Group 2"),t.strictEqual(u,1),t.strictEqual(d,1),t.strictEqual(i,2),r.notifyGroupsLabelChange("Window 3"),t.strictEqual(e.label,"Window 3: Group 1"),t.strictEqual(o.label,"Window 3: Group 2"),t.strictEqual(u,2),t.strictEqual(d,2),t.strictEqual(i,4),l.dispose(),E.dispose(),s.dispose()}),test("copy/merge groups",async()=>{const[r]=await p();let e=0;const o=r.onDidAddGroup(()=>{e++});let i=0;const s=r.onDidRemoveGroup(()=>{i++}),u=r.groups[0];let l=!1;const d=u.onWillDispose(()=>{l=!0}),E=c(a.file("foo/bar"),n);await u.openEditor(E,{pinned:!0});const g=r.addGroup(u,y.RIGHT);r.activateGroup(g);const q=r.copyGroup(u,g,y.DOWN);t.strictEqual(e,2),t.strictEqual(q.count,1),t.ok(q.activeEditor instanceof H);let f=r.mergeGroup(u,g,{mode:X.COPY_EDITORS});t.strictEqual(f,!0),t.strictEqual(g.count,1),t.ok(g.activeEditor instanceof H),f=r.mergeGroup(u,g,{mode:X.MOVE_EDITORS}),t.strictEqual(f,!0),t.strictEqual(u.count,0),f=r.mergeGroup(u,q),t.strictEqual(f,!0),t.strictEqual(i,1),t.strictEqual(l,!0),o.dispose(),s.dispose(),d.dispose(),r.dispose()}),test("merge all groups",async()=>{const[r]=await p(),e=r.groups[0],o=c(a.file("foo/bar1"),n),i=c(a.file("foo/bar2"),n),s=c(a.file("foo/bar3"),n);await e.openEditor(o,{pinned:!0});const u=r.addGroup(e,y.RIGHT);await u.openEditor(i,{pinned:!0}),await r.copyGroup(e,u,y.DOWN).openEditor(s,{pinned:!0}),r.activateGroup(e),t.strictEqual(e.count,1);const d=r.mergeAllGroups(r.activeGroup);t.strictEqual(d,!0),t.strictEqual(e.count,3),r.dispose()}),test("whenReady / whenRestored",async()=>{const[r]=await p();await r.whenReady,t.strictEqual(r.isReady,!0),await r.whenRestored}),test("options",async()=>{const[r]=await p();let e,o;k.add(r.onDidChangeEditorPartOptions(s=>{e=s.oldPartOptions,o=s.newPartOptions}));const i=r.partOptions;t.ok(i),k.add(r.enforcePartOptions({showTabs:"single"})),t.strictEqual(r.partOptions.showTabs,"single"),t.strictEqual(o.showTabs,"single"),t.strictEqual(e,i)}),test("editor basics",async function(){const[r]=await p(),e=r.activeGroup;t.strictEqual(e.isEmpty,!0);let o=0,i=0;const s=[];let u=0;const l=[];let d=0,E=0,g=0;const q=e.onDidModelChange(w=>{w.kind===S.EDITOR_OPEN?(t.ok(w.editor),i++,s.push(w)):w.kind===S.EDITOR_PIN?(t.ok(w.editor),d++):w.kind===S.EDITOR_STICKY?(t.ok(w.editor),E++):w.kind===S.EDITOR_CAPABILITIES?(t.ok(w.editor),g++):w.kind===S.EDITOR_CLOSE&&(t.ok(w.editor),u++,l.push(w))}),f=e.onDidActiveEditorChange(w=>{t.ok(w.editor),o++});let G=0;const x=e.onDidCloseEditor(()=>{G++});let h=0;const T=e.onWillCloseEditor(()=>{h++});let O=0;const m=e.onDidCloseEditor(()=>{O++}),C=c(a.file("foo/bar"),n),v=c(a.file("foo/bar/inactive"),n);await e.openEditor(C,{pinned:!0}),await e.openEditor(v,{inactive:!0}),t.strictEqual(e.isActive(C),!0),t.strictEqual(e.isActive(v),!1),t.strictEqual(e.contains(C),!0),t.strictEqual(e.contains(v),!0),t.strictEqual(e.isEmpty,!1),t.strictEqual(e.count,2),t.strictEqual(g,0),t.strictEqual(i,2),t.strictEqual(s[0].editorIndex,0),t.strictEqual(s[1].editorIndex,1),t.strictEqual(s[0].editor,C),t.strictEqual(s[1].editor,v),t.strictEqual(o,1),t.strictEqual(e.getEditorByIndex(0),C),t.strictEqual(e.getEditorByIndex(1),v),t.strictEqual(e.getIndexOfEditor(C),0),t.strictEqual(e.getIndexOfEditor(v),1),t.strictEqual(e.isFirst(C),!0),t.strictEqual(e.isFirst(v),!1),t.strictEqual(e.isLast(C),!1),t.strictEqual(e.isLast(v),!0),C.capabilities=$.RequiresTrust,t.strictEqual(g,1),v.capabilities=$.Singleton,t.strictEqual(g,2),t.strictEqual(e.previewEditor,v),t.strictEqual(e.isPinned(v),!1),e.pinEditor(v),t.strictEqual(d,1),t.strictEqual(e.isPinned(v),!0),t.ok(!e.previewEditor),t.strictEqual(e.activeEditor,C),t.strictEqual(e.activeEditorPane?.getId(),Q),t.strictEqual(e.count,2);const M=e.getEditors(I.MOST_RECENTLY_ACTIVE);t.strictEqual(M[0],C),t.strictEqual(M[1],v),await e.openEditor(v),t.strictEqual(o,2),t.strictEqual(e.activeEditor,v),await e.openEditor(C);const P=await e.closeEditor(v);t.strictEqual(P,!0),t.strictEqual(o,3),t.strictEqual(u,1),t.strictEqual(l[0].editorIndex,1),t.strictEqual(l[0].editor,v),t.strictEqual(G,1),t.strictEqual(h,1),t.strictEqual(O,1),t.ok(v.gotDisposed),t.strictEqual(e.activeEditor,C),t.strictEqual(E,0),e.stickEditor(C),t.strictEqual(E,1),e.unstickEditor(C),t.strictEqual(E,2),x.dispose(),T.dispose(),m.dispose(),f.dispose(),q.dispose()}),test("openEditors / closeEditors",async()=>{const[r]=await p(),e=r.activeGroup;t.strictEqual(e.isEmpty,!0);const o=c(a.file("foo/bar"),n),i=c(a.file("foo/bar/inactive"),n);await e.openEditors([{editor:o,options:{pinned:!0}},{editor:i}]),t.strictEqual(e.count,2),t.strictEqual(e.getEditorByIndex(0),o),t.strictEqual(e.getEditorByIndex(1),i),await e.closeEditors([o,i]),t.ok(o.gotDisposed),t.ok(i.gotDisposed),t.strictEqual(e.isEmpty,!0)}),test("closeEditor - dirty editor handling",async()=>{const[r,e]=await p(),o=e.createInstance(B);o.fileDialogService.setConfirmResult(b.DONT_SAVE);const i=r.activeGroup,s=c(a.file("foo/bar"),n);s.dirty=!0,await i.openEditor(s),o.fileDialogService.setConfirmResult(b.CANCEL);let u=await i.closeEditor(s);t.strictEqual(u,!1),t.ok(!s.gotDisposed),o.fileDialogService.setConfirmResult(b.DONT_SAVE),u=await i.closeEditor(s),t.strictEqual(u,!0),t.ok(s.gotDisposed)}),test("closeEditor (one, opened in multiple groups)",async()=>{const[r]=await p(),e=r.activeGroup;t.strictEqual(e.isEmpty,!0);const o=r.addGroup(e,y.RIGHT),i=c(a.file("foo/bar"),n),s=c(a.file("foo/bar/inactive"),n);await e.openEditors([{editor:i,options:{pinned:!0}},{editor:s}]),await o.openEditors([{editor:i,options:{pinned:!0}},{editor:s}]);let u=await o.closeEditor(i);t.strictEqual(u,!0),t.ok(!i.gotDisposed),u=await e.closeEditor(i),t.strictEqual(u,!0),t.ok(i.gotDisposed)}),test("closeEditors - dirty editor handling",async()=>{const[r,e]=await p(),o=e.createInstance(B);o.fileDialogService.setConfirmResult(b.DONT_SAVE);let i=!1;const s=r.activeGroup,u=c(a.file("foo/bar1"),n);u.dirty=!0;const l=c(a.file("foo/bar2"),n);await s.openEditor(u),await s.openEditor(l),o.fileDialogService.setConfirmResult(b.CANCEL),i=await s.closeEditors([u,l]),t.strictEqual(i,!1),t.ok(!u.gotDisposed),t.ok(!l.gotDisposed),o.fileDialogService.setConfirmResult(b.DONT_SAVE),i=await s.closeEditors([u,l]),t.strictEqual(i,!0),t.ok(u.gotDisposed),t.ok(l.gotDisposed)}),test("closeEditors (except one)",async()=>{const[r]=await p(),e=r.activeGroup;t.strictEqual(e.isEmpty,!0);const o=c(a.file("foo/bar1"),n),i=c(a.file("foo/bar2"),n),s=c(a.file("foo/bar3"),n);await e.openEditors([{editor:o,options:{pinned:!0}},{editor:i,options:{pinned:!0}},{editor:s}]),t.strictEqual(e.count,3),t.strictEqual(e.getEditorByIndex(0),o),t.strictEqual(e.getEditorByIndex(1),i),t.strictEqual(e.getEditorByIndex(2),s),await e.closeEditors({except:i}),t.strictEqual(e.count,1),t.strictEqual(e.getEditorByIndex(0),i)}),test("closeEditors (except one, sticky editor)",async()=>{const[r]=await p(),e=r.activeGroup;t.strictEqual(e.isEmpty,!0);const o=c(a.file("foo/bar1"),n),i=c(a.file("foo/bar2"),n),s=c(a.file("foo/bar3"),n);await e.openEditors([{editor:o,options:{pinned:!0,sticky:!0}},{editor:i,options:{pinned:!0}},{editor:s}]),t.strictEqual(e.count,3),t.strictEqual(e.stickyCount,1),t.strictEqual(e.getEditorByIndex(0),o),t.strictEqual(e.getEditorByIndex(1),i),t.strictEqual(e.getEditorByIndex(2),s),await e.closeEditors({except:i,excludeSticky:!0}),t.strictEqual(e.count,2),t.strictEqual(e.stickyCount,1),t.strictEqual(e.getEditorByIndex(0),o),t.strictEqual(e.getEditorByIndex(1),i),await e.closeEditors({except:i}),t.strictEqual(e.count,1),t.strictEqual(e.stickyCount,0),t.strictEqual(e.getEditorByIndex(0),i)}),test("closeEditors (saved only)",async()=>{const[r]=await p(),e=r.activeGroup;t.strictEqual(e.isEmpty,!0);const o=c(a.file("foo/bar1"),n),i=c(a.file("foo/bar2"),n),s=c(a.file("foo/bar3"),n);await e.openEditors([{editor:o,options:{pinned:!0}},{editor:i,options:{pinned:!0}},{editor:s}]),t.strictEqual(e.count,3),t.strictEqual(e.getEditorByIndex(0),o),t.strictEqual(e.getEditorByIndex(1),i),t.strictEqual(e.getEditorByIndex(2),s),await e.closeEditors({savedOnly:!0}),t.strictEqual(e.count,0)}),test("closeEditors (saved only, sticky editor)",async()=>{const[r]=await p(),e=r.activeGroup;t.strictEqual(e.isEmpty,!0);const o=c(a.file("foo/bar1"),n),i=c(a.file("foo/bar2"),n),s=c(a.file("foo/bar3"),n);await e.openEditors([{editor:o,options:{pinned:!0,sticky:!0}},{editor:i,options:{pinned:!0}},{editor:s}]),t.strictEqual(e.count,3),t.strictEqual(e.stickyCount,1),t.strictEqual(e.getEditorByIndex(0),o),t.strictEqual(e.getEditorByIndex(1),i),t.strictEqual(e.getEditorByIndex(2),s),await e.closeEditors({savedOnly:!0,excludeSticky:!0}),t.strictEqual(e.count,1),t.strictEqual(e.stickyCount,1),t.strictEqual(e.getEditorByIndex(0),o),await e.closeEditors({savedOnly:!0}),t.strictEqual(e.count,0)}),test("closeEditors (direction: right)",async()=>{const[r]=await p(),e=r.activeGroup;t.strictEqual(e.isEmpty,!0);const o=c(a.file("foo/bar1"),n),i=c(a.file("foo/bar2"),n),s=c(a.file("foo/bar3"),n);await e.openEditors([{editor:o,options:{pinned:!0}},{editor:i,options:{pinned:!0}},{editor:s}]),t.strictEqual(e.count,3),t.strictEqual(e.getEditorByIndex(0),o),t.strictEqual(e.getEditorByIndex(1),i),t.strictEqual(e.getEditorByIndex(2),s),await e.closeEditors({direction:K.RIGHT,except:i}),t.strictEqual(e.count,2),t.strictEqual(e.getEditorByIndex(0),o),t.strictEqual(e.getEditorByIndex(1),i)}),test("closeEditors (direction: right, sticky editor)",async()=>{const[r]=await p(),e=r.activeGroup;t.strictEqual(e.isEmpty,!0);const o=c(a.file("foo/bar1"),n),i=c(a.file("foo/bar2"),n),s=c(a.file("foo/bar3"),n);await e.openEditors([{editor:o,options:{pinned:!0,sticky:!0}},{editor:i,options:{pinned:!0}},{editor:s}]),t.strictEqual(e.count,3),t.strictEqual(e.stickyCount,1),t.strictEqual(e.getEditorByIndex(0),o),t.strictEqual(e.getEditorByIndex(1),i),t.strictEqual(e.getEditorByIndex(2),s),await e.closeEditors({direction:K.RIGHT,except:i,excludeSticky:!0}),t.strictEqual(e.count,2),t.strictEqual(e.stickyCount,1),t.strictEqual(e.getEditorByIndex(0),o),t.strictEqual(e.getEditorByIndex(1),i),await e.closeEditors({direction:K.RIGHT,except:i}),t.strictEqual(e.count,2),t.strictEqual(e.getEditorByIndex(0),o),t.strictEqual(e.getEditorByIndex(1),i)}),test("closeEditors (direction: left)",async()=>{const[r]=await p(),e=r.activeGroup;t.strictEqual(e.isEmpty,!0);const o=c(a.file("foo/bar1"),n),i=c(a.file("foo/bar2"),n),s=c(a.file("foo/bar3"),n);await e.openEditors([{editor:o,options:{pinned:!0}},{editor:i,options:{pinned:!0}},{editor:s}]),t.strictEqual(e.count,3),t.strictEqual(e.getEditorByIndex(0),o),t.strictEqual(e.getEditorByIndex(1),i),t.strictEqual(e.getEditorByIndex(2),s),await e.closeEditors({direction:K.LEFT,except:i}),t.strictEqual(e.count,2),t.strictEqual(e.getEditorByIndex(0),i),t.strictEqual(e.getEditorByIndex(1),s)}),test("closeEditors (direction: left, sticky editor)",async()=>{const[r]=await p(),e=r.activeGroup;t.strictEqual(e.isEmpty,!0);const o=c(a.file("foo/bar1"),n),i=c(a.file("foo/bar2"),n),s=c(a.file("foo/bar3"),n);await e.openEditors([{editor:o,options:{pinned:!0,sticky:!0}},{editor:i,options:{pinned:!0}},{editor:s}]),t.strictEqual(e.count,3),t.strictEqual(e.stickyCount,1),t.strictEqual(e.getEditorByIndex(0),o),t.strictEqual(e.getEditorByIndex(1),i),t.strictEqual(e.getEditorByIndex(2),s),await e.closeEditors({direction:K.LEFT,except:i,excludeSticky:!0}),t.strictEqual(e.count,3),t.strictEqual(e.stickyCount,1),t.strictEqual(e.getEditorByIndex(0),o),t.strictEqual(e.getEditorByIndex(1),i),t.strictEqual(e.getEditorByIndex(2),s),await e.closeEditors({direction:K.LEFT,except:i}),t.strictEqual(e.count,2),t.strictEqual(e.getEditorByIndex(0),i),t.strictEqual(e.getEditorByIndex(1),s)}),test("closeAllEditors",async()=>{const[r]=await p(),e=r.activeGroup;t.strictEqual(e.isEmpty,!0);const o=c(a.file("foo/bar"),n),i=c(a.file("foo/bar/inactive"),n);await e.openEditors([{editor:o,options:{pinned:!0}},{editor:i}]),t.strictEqual(e.count,2),t.strictEqual(e.getEditorByIndex(0),o),t.strictEqual(e.getEditorByIndex(1),i),await e.closeAllEditors(),t.strictEqual(e.isEmpty,!0)}),test("closeAllEditors - dirty editor handling",async()=>{const[r,e]=await p();let o=!0;const i=e.createInstance(B);i.fileDialogService.setConfirmResult(b.DONT_SAVE);const s=r.activeGroup,u=c(a.file("foo/bar1"),n);u.dirty=!0;const l=c(a.file("foo/bar2"),n);await s.openEditor(u),await s.openEditor(l),i.fileDialogService.setConfirmResult(b.CANCEL),o=await s.closeAllEditors(),t.strictEqual(o,!1),t.ok(!u.gotDisposed),t.ok(!l.gotDisposed),i.fileDialogService.setConfirmResult(b.DONT_SAVE),o=await s.closeAllEditors(),t.strictEqual(o,!0),t.ok(u.gotDisposed),t.ok(l.gotDisposed)}),test("closeAllEditors (sticky editor)",async()=>{const[r]=await p(),e=r.activeGroup;t.strictEqual(e.isEmpty,!0);const o=c(a.file("foo/bar"),n),i=c(a.file("foo/bar/inactive"),n);await e.openEditors([{editor:o,options:{pinned:!0,sticky:!0}},{editor:i}]),t.strictEqual(e.count,2),t.strictEqual(e.stickyCount,1),await e.closeAllEditors({excludeSticky:!0}),t.strictEqual(e.count,1),t.strictEqual(e.stickyCount,1),t.strictEqual(e.getEditorByIndex(0),o),await e.closeAllEditors(),t.strictEqual(e.isEmpty,!0)}),test("moveEditor (same group)",async()=>{const[r]=await p(),e=r.activeGroup;t.strictEqual(e.isEmpty,!0);const o=c(a.file("foo/bar"),n),i=c(a.file("foo/bar/inactive"),n),s=[],u=e.onDidModelChange(d=>{d.kind===S.EDITOR_MOVE&&(t.ok(d.editor),s.push(d))});await e.openEditors([{editor:o,options:{pinned:!0}},{editor:i}]),t.strictEqual(e.count,2),t.strictEqual(e.getEditorByIndex(0),o),t.strictEqual(e.getEditorByIndex(1),i),e.moveEditor(i,e,{index:0}),t.strictEqual(s.length,1),t.strictEqual(s[0].editorIndex,0),t.strictEqual(s[0].oldEditorIndex,1),t.strictEqual(s[0].editor,i),t.strictEqual(e.getEditorByIndex(0),i),t.strictEqual(e.getEditorByIndex(1),o);const l=e.moveEditors([{editor:i,options:{index:1}}],e);t.strictEqual(l,!0),t.strictEqual(s.length,2),t.strictEqual(s[1].editorIndex,1),t.strictEqual(s[1].oldEditorIndex,0),t.strictEqual(s[1].editor,i),t.strictEqual(e.getEditorByIndex(0),o),t.strictEqual(e.getEditorByIndex(1),i),u.dispose()}),test("moveEditor (across groups)",async()=>{const[r]=await p(),e=r.activeGroup;t.strictEqual(e.isEmpty,!0);const o=r.addGroup(e,y.RIGHT),i=c(a.file("foo/bar"),n),s=c(a.file("foo/bar/inactive"),n);await e.openEditors([{editor:i,options:{pinned:!0}},{editor:s}]),t.strictEqual(e.count,2),t.strictEqual(e.getEditorByIndex(0),i),t.strictEqual(e.getEditorByIndex(1),s),e.moveEditor(s,o,{index:0}),t.strictEqual(e.count,1),t.strictEqual(e.getEditorByIndex(0),i),t.strictEqual(o.count,1),t.strictEqual(o.getEditorByIndex(0),s)}),test("moveEditors (across groups)",async()=>{const[r]=await p(),e=r.activeGroup;t.strictEqual(e.isEmpty,!0);const o=r.addGroup(e,y.RIGHT),i=c(a.file("foo/bar1"),n),s=c(a.file("foo/bar2"),n),u=c(a.file("foo/bar3"),n);await e.openEditors([{editor:i,options:{pinned:!0}},{editor:s,options:{pinned:!0}},{editor:u,options:{pinned:!0}}]),t.strictEqual(e.getEditorByIndex(0),i),t.strictEqual(e.getEditorByIndex(1),s),t.strictEqual(e.getEditorByIndex(2),u),e.moveEditors([{editor:s},{editor:u}],o),t.strictEqual(e.count,1),t.strictEqual(o.count,2),t.strictEqual(e.getEditorByIndex(0),i),t.strictEqual(o.getEditorByIndex(0),s),t.strictEqual(o.getEditorByIndex(1),u)}),test("copyEditor (across groups)",async()=>{const[r]=await p(),e=r.activeGroup;t.strictEqual(e.isEmpty,!0);const o=r.addGroup(e,y.RIGHT),i=c(a.file("foo/bar"),n),s=c(a.file("foo/bar/inactive"),n);await e.openEditors([{editor:i,options:{pinned:!0}},{editor:s}]),t.strictEqual(e.count,2),t.strictEqual(e.getEditorByIndex(0),i),t.strictEqual(e.getEditorByIndex(1),s),e.copyEditor(s,o,{index:0}),t.strictEqual(e.count,2),t.strictEqual(e.getEditorByIndex(0),i),t.strictEqual(e.getEditorByIndex(1),s),t.strictEqual(o.count,1),t.strictEqual(o.getEditorByIndex(0),s)}),test("copyEditors (across groups)",async()=>{const[r]=await p(),e=r.activeGroup;t.strictEqual(e.isEmpty,!0);const o=r.addGroup(e,y.RIGHT),i=c(a.file("foo/bar1"),n),s=c(a.file("foo/bar2"),n),u=c(a.file("foo/bar3"),n);await e.openEditors([{editor:i,options:{pinned:!0}},{editor:s,options:{pinned:!0}},{editor:u,options:{pinned:!0}}]),t.strictEqual(e.getEditorByIndex(0),i),t.strictEqual(e.getEditorByIndex(1),s),t.strictEqual(e.getEditorByIndex(2),u),e.copyEditors([{editor:i},{editor:s},{editor:u}],o),[e,o].forEach(l=>{t.strictEqual(l.getEditorByIndex(0),i),t.strictEqual(l.getEditorByIndex(1),s),t.strictEqual(l.getEditorByIndex(2),u)})}),test("replaceEditors",async()=>{const[r]=await p(),e=r.activeGroup;t.strictEqual(e.isEmpty,!0);const o=c(a.file("foo/bar"),n),i=c(a.file("foo/bar/inactive"),n);await e.openEditor(o),t.strictEqual(e.count,1),t.strictEqual(e.getEditorByIndex(0),o),await e.replaceEditors([{editor:o,replacement:i}]),t.strictEqual(e.count,1),t.strictEqual(e.getEditorByIndex(0),i)}),test("replaceEditors - dirty editor handling",async()=>{const[r,e]=await p(),o=e.createInstance(B);o.fileDialogService.setConfirmResult(b.DONT_SAVE);const i=r.activeGroup,s=c(a.file("foo/bar1"),n);s.dirty=!0;const u=c(a.file("foo/bar2"),n);await i.openEditor(s),t.strictEqual(i.activeEditor,s),o.fileDialogService.setConfirmResult(b.CANCEL),await i.replaceEditors([{editor:s,replacement:u}]),t.strictEqual(i.activeEditor,s),t.ok(!s.gotDisposed),o.fileDialogService.setConfirmResult(b.DONT_SAVE),await i.replaceEditors([{editor:s,replacement:u}]),t.strictEqual(i.activeEditor,u),t.ok(s.gotDisposed)}),test("replaceEditors - forceReplaceDirty flag",async()=>{const[r,e]=await p(),o=e.createInstance(B);o.fileDialogService.setConfirmResult(b.DONT_SAVE);const i=r.activeGroup,s=c(a.file("foo/bar1"),n);s.dirty=!0;const u=c(a.file("foo/bar2"),n);await i.openEditor(s),t.strictEqual(i.activeEditor,s),o.fileDialogService.setConfirmResult(b.CANCEL),await i.replaceEditors([{editor:s,replacement:u,forceReplaceDirty:!1}]),t.strictEqual(i.activeEditor,s),t.ok(!s.gotDisposed),await i.replaceEditors([{editor:s,replacement:u,forceReplaceDirty:!0}]),t.strictEqual(i.activeEditor,u),t.ok(s.gotDisposed)}),test("replaceEditors - proper index handling",async()=>{const[r]=await p(),e=r.activeGroup;t.strictEqual(e.isEmpty,!0);const o=c(a.file("foo/bar1"),n),i=c(a.file("foo/bar2"),n),s=c(a.file("foo/bar3"),n),u=c(a.file("foo/bar4"),n),l=c(a.file("foo/bar5"),n),d=c(a.file("foo/bar6"),n),E=c(a.file("foo/bar7"),n),g=c(a.file("foo/bar8"),n);await e.openEditor(o,{pinned:!0}),await e.openEditor(i,{pinned:!0}),await e.openEditor(s,{pinned:!0}),await e.openEditor(u,{pinned:!0}),await e.openEditor(l,{pinned:!0}),await e.replaceEditors([{editor:o,replacement:d},{editor:s,replacement:E},{editor:l,replacement:g}]),t.strictEqual(e.getEditorByIndex(0),d),t.strictEqual(e.getEditorByIndex(1),i),t.strictEqual(e.getEditorByIndex(2),E),t.strictEqual(e.getEditorByIndex(3),u),t.strictEqual(e.getEditorByIndex(4),g)}),test("replaceEditors - should be able to replace when side by side editor is involved with same input side by side",async()=>{const[r,e]=await p(),o=r.activeGroup;t.strictEqual(o.isEmpty,!0);const i=c(a.file("foo/bar"),n),s=e.createInstance(W,void 0,void 0,i,i);await o.openEditor(i),t.strictEqual(o.count,1),t.strictEqual(o.getEditorByIndex(0),i),await o.replaceEditors([{editor:i,replacement:s}]),t.strictEqual(o.count,1),t.strictEqual(o.getEditorByIndex(0),s),await o.replaceEditors([{editor:s,replacement:i}]),t.strictEqual(o.count,1),t.strictEqual(o.getEditorByIndex(0),i)}),test("find editors",async()=>{const[r]=await p(),e=r.activeGroup,o=r.addGroup(e,y.RIGHT);t.strictEqual(e.isEmpty,!0);const i=c(a.file("foo/bar1"),n),s=c(a.file("foo/bar1"),`${n}-1`),u=c(a.file("foo/bar3"),n),l=c(a.file("foo/bar4"),n),d=c(a.file("foo/bar4"),`${n}-1`);await e.openEditor(i,{pinned:!0}),await e.openEditor(s,{pinned:!0}),await e.openEditor(u,{pinned:!0}),await e.openEditor(l,{pinned:!0}),await o.openEditor(d,{pinned:!0});let E=e.findEditors(a.file("foo/bar1"));t.strictEqual(E.length,2),E=o.findEditors(a.file("foo/bar4")),t.strictEqual(E.length,1)}),test("find editors (side by side support)",async()=>{const[r,e]=await p(),o=e.createInstance(B),i=r.activeGroup;t.strictEqual(i.isEmpty,!0);const s=c(a.file("foo/bar-secondary"),n),u=c(a.file("foo/bar-primary"),`${n}-1`),l=new W(void 0,void 0,s,u,o.editorService);await i.openEditor(l,{pinned:!0});let d=i.findEditors(a.file("foo/bar-secondary"));t.strictEqual(d.length,0),d=i.findEditors(a.file("foo/bar-secondary"),{supportSideBySide:V.PRIMARY}),t.strictEqual(d.length,0),d=i.findEditors(a.file("foo/bar-primary"),{supportSideBySide:V.PRIMARY}),t.strictEqual(d.length,1),d=i.findEditors(a.file("foo/bar-secondary"),{supportSideBySide:V.SECONDARY}),t.strictEqual(d.length,1),d=i.findEditors(a.file("foo/bar-primary"),{supportSideBySide:V.SECONDARY}),t.strictEqual(d.length,0),d=i.findEditors(a.file("foo/bar-secondary"),{supportSideBySide:V.ANY}),t.strictEqual(d.length,1),d=i.findEditors(a.file("foo/bar-primary"),{supportSideBySide:V.ANY}),t.strictEqual(d.length,1)}),test("find neighbour group (left/right)",async function(){const[r]=await p(),e=r.activeGroup,o=r.addGroup(e,y.RIGHT);t.strictEqual(o,r.findGroup({direction:y.RIGHT},e)),t.strictEqual(e,r.findGroup({direction:y.LEFT},o))}),test("find neighbour group (up/down)",async function(){const[r]=await p(),e=r.activeGroup,o=r.addGroup(e,y.DOWN);t.strictEqual(o,r.findGroup({direction:y.DOWN},e)),t.strictEqual(e,r.findGroup({direction:y.UP},o))}),test("find group by location (left/right)",async function(){const[r]=await p(),e=r.activeGroup,o=r.addGroup(e,y.RIGHT),i=r.addGroup(o,y.DOWN);t.strictEqual(e,r.findGroup({location:A.FIRST})),t.strictEqual(i,r.findGroup({location:A.LAST})),t.strictEqual(o,r.findGroup({location:A.NEXT},e)),t.strictEqual(e,r.findGroup({location:A.PREVIOUS},o)),t.strictEqual(i,r.findGroup({location:A.NEXT},o)),t.strictEqual(o,r.findGroup({location:A.PREVIOUS},i))}),test("applyLayout (2x2)",async function(){const[r]=await p();r.applyLayout({groups:[{groups:[{},{}]},{groups:[{},{}]}],orientation:L.HORIZONTAL}),t.strictEqual(r.groups.length,4)}),test("getLayout",async function(){const[r]=await p();r.applyLayout({groups:[{groups:[{},{}]},{groups:[{},{}]}],orientation:L.HORIZONTAL});let e=r.getLayout();t.strictEqual(e.orientation,L.HORIZONTAL),t.strictEqual(e.groups.length,2),t.strictEqual(e.groups[0].groups.length,2),t.strictEqual(e.groups[1].groups.length,2),r.applyLayout({groups:[{},{},{}],orientation:L.VERTICAL}),e=r.getLayout(),t.strictEqual(e.orientation,L.VERTICAL),t.strictEqual(e.groups.length,3),t.ok(typeof e.groups[0].size=="number"),t.ok(typeof e.groups[1].size=="number"),t.ok(typeof e.groups[2].size=="number")}),test("centeredLayout",async function(){const[r]=await p();r.centerLayout(!0),t.strictEqual(r.isLayoutCentered(),!0)}),test("sticky editors",async()=>{const[r]=await p(),e=r.activeGroup;t.strictEqual(e.stickyCount,0),t.strictEqual(e.getEditors(I.SEQUENTIAL).length,0),t.strictEqual(e.getEditors(I.MOST_RECENTLY_ACTIVE).length,0),t.strictEqual(e.getEditors(I.SEQUENTIAL,{excludeSticky:!0}).length,0),t.strictEqual(e.getEditors(I.MOST_RECENTLY_ACTIVE,{excludeSticky:!0}).length,0);const o=c(a.file("foo/bar"),n),i=c(a.file("foo/bar/inactive"),n);await e.openEditor(o,{pinned:!0}),await e.openEditor(i,{inactive:!0}),t.strictEqual(e.stickyCount,0),t.strictEqual(e.isSticky(o),!1),t.strictEqual(e.isSticky(i),!1),t.strictEqual(e.getEditors(I.SEQUENTIAL).length,2),t.strictEqual(e.getEditors(I.MOST_RECENTLY_ACTIVE).length,2),t.strictEqual(e.getEditors(I.SEQUENTIAL,{excludeSticky:!0}).length,2),t.strictEqual(e.getEditors(I.MOST_RECENTLY_ACTIVE,{excludeSticky:!0}).length,2),e.stickEditor(o),t.strictEqual(e.stickyCount,1),t.strictEqual(e.isSticky(o),!0),t.strictEqual(e.isSticky(i),!1),t.strictEqual(e.getEditors(I.SEQUENTIAL).length,2),t.strictEqual(e.getEditors(I.MOST_RECENTLY_ACTIVE).length,2),t.strictEqual(e.getEditors(I.SEQUENTIAL,{excludeSticky:!0}).length,1),t.strictEqual(e.getEditors(I.MOST_RECENTLY_ACTIVE,{excludeSticky:!0}).length,1),e.unstickEditor(o),t.strictEqual(e.stickyCount,0),t.strictEqual(e.isSticky(o),!1),t.strictEqual(e.isSticky(i),!1),t.strictEqual(e.getIndexOfEditor(o),0),t.strictEqual(e.getIndexOfEditor(i),1),t.strictEqual(e.getEditors(I.SEQUENTIAL).length,2),t.strictEqual(e.getEditors(I.MOST_RECENTLY_ACTIVE).length,2),t.strictEqual(e.getEditors(I.SEQUENTIAL,{excludeSticky:!0}).length,2),t.strictEqual(e.getEditors(I.MOST_RECENTLY_ACTIVE,{excludeSticky:!0}).length,2);let s=0;const u=e.onDidModelChange(d=>{d.kind===S.EDITOR_MOVE&&(t.ok(d.editor),s++)});e.stickEditor(i),t.strictEqual(e.stickyCount,1),t.strictEqual(e.isSticky(o),!1),t.strictEqual(e.isSticky(i),!0),t.strictEqual(e.getIndexOfEditor(o),1),t.strictEqual(e.getIndexOfEditor(i),0),t.strictEqual(s,1),t.strictEqual(e.getEditors(I.SEQUENTIAL).length,2),t.strictEqual(e.getEditors(I.MOST_RECENTLY_ACTIVE).length,2),t.strictEqual(e.getEditors(I.SEQUENTIAL,{excludeSticky:!0}).length,1),t.strictEqual(e.getEditors(I.MOST_RECENTLY_ACTIVE,{excludeSticky:!0}).length,1);const l=c(a.file("foo/bar/sticky"),n);await e.openEditor(l,{sticky:!0}),t.strictEqual(e.stickyCount,2),t.strictEqual(e.isSticky(o),!1),t.strictEqual(e.isSticky(i),!0),t.strictEqual(e.isSticky(l),!0),t.strictEqual(e.getIndexOfEditor(i),0),t.strictEqual(e.getIndexOfEditor(l),1),t.strictEqual(e.getIndexOfEditor(o),2),await e.openEditor(o,{sticky:!0}),t.strictEqual(e.stickyCount,3),t.strictEqual(e.isSticky(o),!0),t.strictEqual(e.isSticky(i),!0),t.strictEqual(e.isSticky(l),!0),t.strictEqual(e.getIndexOfEditor(i),0),t.strictEqual(e.getIndexOfEditor(l),1),t.strictEqual(e.getIndexOfEditor(o),2),u.dispose()}),test("sticky: true wins over index",async()=>{const[r]=await p(),e=r.activeGroup;t.strictEqual(e.stickyCount,0);const o=c(a.file("foo/bar"),n),i=c(a.file("foo/bar/inactive"),n),s=c(a.file("foo/bar/sticky"),n);await e.openEditor(o,{pinned:!0}),await e.openEditor(i,{inactive:!0}),await e.openEditor(s,{sticky:!0,index:2}),t.strictEqual(e.stickyCount,1),t.strictEqual(e.isSticky(s),!0),t.strictEqual(e.getIndexOfEditor(o),1),t.strictEqual(e.getIndexOfEditor(i),2),t.strictEqual(e.getIndexOfEditor(s),0)}),test("selection: setSelection, isSelected, selectedEditors",async()=>{const[r]=await p(),e=r.activeGroup,o=c(a.file("foo/bar1"),n),i=c(a.file("foo/bar2"),n),s=c(a.file("foo/bar3"),n);function u(l){for(const d of l)if(e.selectedEditors.indexOf(d)===-1)return!1;return l.length===e.selectedEditors.length}await e.openEditors([o,i,s].map(l=>({editor:l,options:{pinned:!0}}))),t.strictEqual(e.isActive(o),!0),t.strictEqual(e.isSelected(o),!0),t.strictEqual(e.isSelected(i),!1),t.strictEqual(e.isSelected(s),!1),t.strictEqual(u([o]),!0),await e.setSelection(o,[s]),t.strictEqual(e.isActive(o),!0),t.strictEqual(e.isSelected(o),!0),t.strictEqual(e.isSelected(i),!1),t.strictEqual(e.isSelected(s),!0),t.strictEqual(u([o,s]),!0),await e.setSelection(i,[o,s]),t.strictEqual(e.isSelected(o),!0),t.strictEqual(e.isActive(i),!0),t.strictEqual(e.isSelected(i),!0),t.strictEqual(e.isSelected(s),!0),t.strictEqual(u([o,i,s]),!0),await e.setSelection(o,[]),t.strictEqual(e.isActive(o),!0),t.strictEqual(e.isSelected(o),!0),t.strictEqual(e.isSelected(i),!1),t.strictEqual(e.isSelected(s),!1),t.strictEqual(u([o]),!0)}),test("moveEditor with context (across groups)",async()=>{const[r]=await p(),e=r.activeGroup;t.strictEqual(e.isEmpty,!0);const o=r.addGroup(e,y.RIGHT),i=c(a.file("foo/bar"),n),s=c(a.file("foo/bar/inactive"),n),u=c(a.file("foo/bar/third"),n);let l=0;const d=e.onWillMoveEditor(()=>{l++});let E=0;const g=o.onWillMoveEditor(()=>{E++});await e.openEditors([{editor:i,options:{pinned:!0}},{editor:s},{editor:u}]),t.strictEqual(l,0),t.strictEqual(E,0);let q=e.moveEditor(i,o);t.strictEqual(q,!0),t.strictEqual(l,1),t.strictEqual(E,0),q=e.moveEditor(s,o),t.strictEqual(q,!0),t.strictEqual(l,2),t.strictEqual(E,0),q=o.moveEditor(s,e),t.strictEqual(q,!0),t.strictEqual(l,2),t.strictEqual(E,1),d.dispose(),g.dispose()}),test("moveEditor disabled",async()=>{const[r]=await p(),e=r.activeGroup;t.strictEqual(e.isEmpty,!0);const o=r.addGroup(e,y.RIGHT),i=c(a.file("foo/bar"),n),s=c(a.file("foo/bar/inactive"),n),u=c(a.file("foo/bar/third"),n);await e.openEditors([{editor:i,options:{pinned:!0}},{editor:s},{editor:u}]),i.setMoveDisabled("disabled");const l=e.moveEditor(i,o);t.strictEqual(l,!1),t.strictEqual(e.count,3)}),test("onWillOpenEditor",async()=>{const[r]=await p(),e=r.activeGroup;t.strictEqual(e.isEmpty,!0);const o=r.addGroup(e,y.RIGHT),i=c(a.file("foo/bar"),n),s=c(a.file("foo/bar/second"),n),u=c(a.file("foo/bar/third"),n);let l=0;const d=e.onWillOpenEditor(()=>{l++});let E=0;const g=o.onWillOpenEditor(()=>{E++});await e.openEditor(i),t.strictEqual(l,1),t.strictEqual(E,0),o.openEditor(s),t.strictEqual(l,1),t.strictEqual(E,1),e.openEditor(u),t.strictEqual(l,2),t.strictEqual(E,1),o.moveEditor(s,e),t.strictEqual(l,3),t.strictEqual(E,1),d.dispose(),g.dispose()}),test("copyEditor with context (across groups)",async()=>{const[r]=await p(),e=r.activeGroup;t.strictEqual(e.isEmpty,!0);let o=0;const i=e.onWillMoveEditor(()=>o++),s=r.addGroup(e,y.RIGHT),u=c(a.file("foo/bar"),n),l=c(a.file("foo/bar/inactive"),n);await e.openEditors([{editor:u,options:{pinned:!0}},{editor:l}]),t.strictEqual(o,0),e.copyEditor(l,s,{index:0}),t.strictEqual(o,0),i.dispose()}),test("locked groups - basics",async()=>{const[r]=await p(),e=r.activeGroup,o=r.addGroup(e,y.RIGHT);let i=0,s=0;const u=r.onDidChangeGroupLocked(q=>{q===e?i++:q===o&&s++});let l=0;const d=e.onDidModelChange(q=>{q.kind===S.GROUP_LOCKED&&l++});let E=0;const g=o.onDidModelChange(q=>{q.kind===S.GROUP_LOCKED&&E++});o.lock(!0),o.lock(!0),t.strictEqual(l,0),t.strictEqual(i,0),t.strictEqual(E,1),t.strictEqual(s,1),o.lock(!1),o.lock(!1),t.strictEqual(l,0),t.strictEqual(i,0),t.strictEqual(E,2),t.strictEqual(s,2),e.lock(!0),e.lock(!0),t.strictEqual(l,1),t.strictEqual(i,1),t.strictEqual(E,2),t.strictEqual(s,2),e.lock(!1),e.lock(!1),t.strictEqual(l,2),t.strictEqual(i,2),t.strictEqual(E,2),t.strictEqual(s,2),u.dispose(),d.dispose(),g.dispose()}),test("locked groups - single group is can be locked",async()=>{const[r]=await p(),e=r.activeGroup;e.lock(!0),t.strictEqual(e.isLocked,!0);const o=r.addGroup(e,y.RIGHT);o.lock(!0),t.strictEqual(o.isLocked,!0),r.removeGroup(e),t.strictEqual(o.isLocked,!0);const i=r.addGroup(o,y.RIGHT);o.lock(!0),i.lock(!0),t.strictEqual(o.isLocked,!0),t.strictEqual(i.isLocked,!0),r.removeGroup(i),t.strictEqual(o.isLocked,!0)}),test("locked groups - auto locking via setting",async()=>{const r=R(void 0,k),e=new J;await e.setUserConfiguration("workbench",{editor:{autoLockGroups:{testEditorInputForEditorGroupService:!0}}}),r.stub(tt,e);const[o]=await p(r),i=o.activeGroup;let s=o.addGroup(i,y.RIGHT),u=c(a.file("foo/bar1"),n),l=c(a.file("foo/bar2"),n);await s.openEditor(u,{pinned:!0}),t.strictEqual(s.isLocked,!0),s.lock(!1),await s.openEditor(l,{pinned:!0}),t.strictEqual(s.isLocked,!1),await s.closeAllEditors(),o.removeGroup(s),await i.closeAllEditors(),u=c(a.file("foo/bar1"),n),l=c(a.file("foo/bar2"),n),await i.openEditor(u,{pinned:!0}),t.strictEqual(i.isLocked,!1),s=o.addGroup(i,y.RIGHT),t.strictEqual(i.isLocked,!1);const d=o.addGroup(i,y.LEFT);t.strictEqual(i.isLocked,!1),o.removeGroup(d),t.strictEqual(i.isLocked,!1)}),test("maximize editor group",async()=>{const r=R(void 0,k),[e]=await p(r),o=e.activeGroup,i=e.getSize(o);t.strictEqual(e.hasMaximizedGroup(),!1);const s=e.addGroup(o,y.RIGHT),u=e.addGroup(s,y.DOWN),l=e.getSize(o),d=e.getSize(s),E=e.getSize(u);let g;const q=e.onDidChangeGroupMaximized(f=>{g=f});t.strictEqual(e.hasMaximizedGroup(),!1),e.arrangeGroups(st.MAXIMIZE,o),t.strictEqual(e.hasMaximizedGroup(),!0),t.deepStrictEqual(e.getSize(o),i),t.deepStrictEqual(e.getSize(s),{width:0,height:0}),t.deepStrictEqual(e.getSize(u),{width:0,height:0}),t.deepStrictEqual(g,!0),e.toggleMaximizeGroup(),t.strictEqual(e.hasMaximizedGroup(),!1),t.deepStrictEqual(e.getSize(o),l),t.deepStrictEqual(e.getSize(s),d),t.deepStrictEqual(e.getSize(u),E),t.deepStrictEqual(g,!1),q.dispose()}),test("transient editors - basics",async()=>{const[r]=await p(),e=r.activeGroup,o=c(a.file("foo/bar"),n),i=c(a.file("foo/bar/inactive"),n);await e.openEditor(o,{pinned:!0}),await e.openEditor(i,{transient:!0}),t.strictEqual(e.isTransient(o),!1),t.strictEqual(e.isTransient(i),!0),await e.openEditor(o,{pinned:!0}),await e.openEditor(i,{transient:!0}),t.strictEqual(e.isTransient(i),!0),await e.openEditor(i,{transient:!1}),t.strictEqual(e.isTransient(i),!1),await e.openEditor(i,{transient:!0}),t.strictEqual(e.isTransient(i),!1)}),test("transient editors - pinning clears transient",async()=>{const[r]=await p(),e=r.activeGroup,o=c(a.file("foo/bar"),n),i=c(a.file("foo/bar/inactive"),n);await e.openEditor(o,{pinned:!0}),await e.openEditor(i,{transient:!0}),t.strictEqual(e.isTransient(o),!1),t.strictEqual(e.isTransient(i),!0),await e.openEditor(o,{pinned:!0}),await e.openEditor(i,{pinned:!0,transient:!0}),t.strictEqual(e.isTransient(i),!1)}),test("transient editors - overrides enablePreview setting",async function(){const r=R(void 0,k),e=new J;await e.setUserConfiguration("workbench",{editor:{enablePreview:!1}}),r.stub(tt,e);const[o]=await p(r),i=o.activeGroup;t.strictEqual(i.isEmpty,!0);const s=c(a.file("foo/bar"),n),u=c(a.file("foo/bar2"),n);await i.openEditor(s,{pinned:!1}),t.strictEqual(i.isPinned(s),!0),await i.openEditor(u,{transient:!0}),t.strictEqual(i.isPinned(u),!1),i.focus(),t.strictEqual(i.isPinned(u),!0)}),test("working sets - create / apply state",async function(){const[r]=await p(),e=c(a.file("foo/bar"),n),o=c(a.file("foo/bar2"),n),i=await r.activeGroup.openEditor(e,{pinned:!0}),s=await r.sideGroup.openEditor(o,{pinned:!0}),u=r.createState();await s?.group.closeAllEditors(),await i?.group.closeAllEditors(),t.strictEqual(r.count,1),t.strictEqual(r.activeGroup.isEmpty,!0),await r.applyState(u),t.strictEqual(r.count,2),t.strictEqual(r.groups[0].contains(e),!0),t.strictEqual(r.groups[1].contains(o),!0);for(const E of r.groups)await E.closeAllEditors();const l=r.createState();await r.applyState(l),t.strictEqual(r.count,1);const d=c(a.file("foo/bar3"),n);d.dirty=!0,await r.activeGroup.openEditor(d,{pinned:!0}),await r.applyState(l),t.strictEqual(r.count,1),t.strictEqual(r.groups[0].contains(d),!0),await r.applyState("empty"),t.strictEqual(r.count,1),t.strictEqual(r.groups[0].contains(d),!0),d.dirty=!1,await r.applyState("empty"),t.strictEqual(r.count,1),t.strictEqual(r.activeGroup.isEmpty,!0)}),test("context key provider",async function(){const r=new F,e=R({contextKeyService:O=>O.createInstance(N)},r),o=e.get(z),[i]=await Z(e),s=c(a.file("foo/bar"),n),u=c(a.file("foo/bar2"),n),l=c(a.file("foo/bar3"),n),d=i.activeGroup,E=i.addGroup(d,y.RIGHT);await E.openEditor(u,{pinned:!0}),await d.openEditor(s,{pinned:!0});const g=new Y("testContextKey",i.activeGroup.id),q={contextKey:g,getGroupContextKeyValue:O=>O.id};r.add(i.registerContextKeyProvider(q)),t.strictEqual(i.activeGroup.id,d.id);let f=o.getContextKeyValue(g.key),G=d.scopedContextKeyService.getContextKeyValue(g.key),x=E.scopedContextKeyService.getContextKeyValue(g.key);t.strictEqual(f,d.id),t.strictEqual(G,d.id),t.strictEqual(x,E.id),i.activateGroup(E),f=o.getContextKeyValue(g.key),G=d.scopedContextKeyService.getContextKeyValue(g.key),x=E.scopedContextKeyService.getContextKeyValue(g.key),t.strictEqual(f,E.id),t.strictEqual(G,d.id),t.strictEqual(x,E.id);const h=i.addGroup(E,y.RIGHT);await h.openEditor(l,{pinned:!0}),f=o.getContextKeyValue(g.key),G=d.scopedContextKeyService.getContextKeyValue(g.key),x=E.scopedContextKeyService.getContextKeyValue(g.key);const T=h.scopedContextKeyService.getContextKeyValue(g.key);t.strictEqual(f,h.id),t.strictEqual(G,d.id),t.strictEqual(x,E.id),t.strictEqual(T,h.id),r.dispose()}),test("context key provider: onDidChange",async function(){const r=new F,e=R({contextKeyService:T=>T.createInstance(N)},r),o=e.get(z),i=await U(e,r),s=c(a.file("foo/bar"),n),u=c(a.file("foo/bar2"),n),l=i.activeGroup,d=i.addGroup(l,y.RIGHT);await d.openEditor(u,{pinned:!0}),await l.openEditor(s,{pinned:!0});let E=0;const g=new ut,q=new Y("testContextKey",i.activeGroup.id),f={contextKey:q,getGroupContextKeyValue:T=>T.id+E,onDidChange:g.event};r.add(i.registerContextKeyProvider(f)),t.strictEqual(i.activeGroup.id,l.id);let G=o.getContextKeyValue(q.key),x=l.scopedContextKeyService.getContextKeyValue(q.key),h=d.scopedContextKeyService.getContextKeyValue(q.key);t.strictEqual(G,l.id+E),t.strictEqual(x,l.id+E),t.strictEqual(h,d.id+E),E=10,g.fire(),G=o.getContextKeyValue(q.key),x=l.scopedContextKeyService.getContextKeyValue(q.key),h=d.scopedContextKeyService.getContextKeyValue(q.key),t.strictEqual(G,l.id+E),t.strictEqual(x,l.id+E),t.strictEqual(h,d.id+E),r.dispose()}),test("context key provider: active editor change",async function(){const r=new F,e=R({contextKeyService:f=>f.createInstance(N)},r),o=e.get(z),i=await U(e,r),s=c(a.file("foo/bar"),n),u=c(a.file("foo/bar2"),n),l=i.activeGroup;await l.openEditor(u,{pinned:!0}),await l.openEditor(s,{pinned:!0});const d=new Y("testContextKey",s.resource.toString()),E={contextKey:d,getGroupContextKeyValue:f=>f.activeEditor?.resource?.toString()??""};r.add(i.registerContextKeyProvider(E)),t.strictEqual(lt(l.activeEditor?.resource,s.resource),!0);let g=o.getContextKeyValue(d.key),q=l.scopedContextKeyService.getContextKeyValue(d.key);t.strictEqual(g,s.resource.toString()),t.strictEqual(q,s.resource.toString()),await l.openEditor(u),g=o.getContextKeyValue(d.key),q=l.scopedContextKeyService.getContextKeyValue(d.key),t.strictEqual(g,u.resource.toString()),t.strictEqual(q,u.resource.toString()),r.dispose()}),nt()});
