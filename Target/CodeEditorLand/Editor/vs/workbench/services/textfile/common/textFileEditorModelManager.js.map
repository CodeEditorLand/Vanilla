{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/textfile/common/textFileEditorModelManager.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Promises, ResourceQueue } from \"../../../../base/common/async.js\";\nimport type { CancellationToken } from \"../../../../base/common/cancellation.js\";\nimport { toErrorMessage } from \"../../../../base/common/errorMessage.js\";\nimport { onUnexpectedError } from \"../../../../base/common/errors.js\";\nimport { Emitter, Event } from \"../../../../base/common/event.js\";\nimport {\n\tDisposable,\n\tDisposableStore,\n\ttype IDisposable,\n\tdispose,\n} from \"../../../../base/common/lifecycle.js\";\nimport { ResourceMap } from \"../../../../base/common/map.js\";\nimport { extname, joinPath } from \"../../../../base/common/resources.js\";\nimport { URI } from \"../../../../base/common/uri.js\";\nimport {\n\tPLAINTEXT_EXTENSION,\n\tPLAINTEXT_LANGUAGE_ID,\n} from \"../../../../editor/common/languages/modesRegistry.js\";\nimport type { ITextSnapshot } from \"../../../../editor/common/model.js\";\nimport { createTextBufferFactoryFromSnapshot } from \"../../../../editor/common/model/textModel.js\";\nimport { localize } from \"../../../../nls.js\";\nimport {\n\tFileChangeType,\n\ttype FileChangesEvent,\n\tFileOperation,\n\tIFileService,\n\ttype IFileSystemProviderCapabilitiesChangeEvent,\n\ttype IFileSystemProviderRegistrationEvent,\n} from \"../../../../platform/files/common/files.js\";\nimport { IInstantiationService } from \"../../../../platform/instantiation/common/instantiation.js\";\nimport { INotificationService } from \"../../../../platform/notification/common/notification.js\";\nimport type {\n\tIProgress,\n\tIProgressStep,\n} from \"../../../../platform/progress/common/progress.js\";\nimport { IUriIdentityService } from \"../../../../platform/uriIdentity/common/uriIdentity.js\";\nimport {\n\ttype IStoredFileWorkingCopySaveParticipantContext,\n\tIWorkingCopyFileService,\n\ttype WorkingCopyFileEvent,\n} from \"../../workingCopy/common/workingCopyFileService.js\";\nimport { TextFileEditorModel } from \"./textFileEditorModel.js\";\nimport { TextFileSaveParticipant } from \"./textFileSaveParticipant.js\";\nimport type {\n\tITextFileEditorModel,\n\tITextFileEditorModelManager,\n\tITextFileEditorModelResolveOrCreateOptions,\n\tITextFileResolveEvent,\n\tITextFileSaveEvent,\n\tITextFileSaveParticipant,\n} from \"./textfiles.js\";\n\nexport class TextFileEditorModelManager\n\textends Disposable\n\timplements ITextFileEditorModelManager\n{\n\tprivate readonly _onDidCreate = this._register(\n\t\tnew Emitter<TextFileEditorModel>({\n\t\t\tleakWarningThreshold: 500 /* increased for users with hundreds of inputs opened */,\n\t\t}),\n\t);\n\treadonly onDidCreate = this._onDidCreate.event;\n\n\tprivate readonly _onDidResolve = this._register(\n\t\tnew Emitter<ITextFileResolveEvent>(),\n\t);\n\treadonly onDidResolve = this._onDidResolve.event;\n\n\tprivate readonly _onDidRemove = this._register(new Emitter<URI>());\n\treadonly onDidRemove = this._onDidRemove.event;\n\n\tprivate readonly _onDidChangeDirty = this._register(\n\t\tnew Emitter<TextFileEditorModel>(),\n\t);\n\treadonly onDidChangeDirty = this._onDidChangeDirty.event;\n\n\tprivate readonly _onDidChangeReadonly = this._register(\n\t\tnew Emitter<TextFileEditorModel>(),\n\t);\n\treadonly onDidChangeReadonly = this._onDidChangeReadonly.event;\n\n\tprivate readonly _onDidChangeOrphaned = this._register(\n\t\tnew Emitter<TextFileEditorModel>(),\n\t);\n\treadonly onDidChangeOrphaned = this._onDidChangeOrphaned.event;\n\n\tprivate readonly _onDidSaveError = this._register(\n\t\tnew Emitter<TextFileEditorModel>(),\n\t);\n\treadonly onDidSaveError = this._onDidSaveError.event;\n\n\tprivate readonly _onDidSave = this._register(\n\t\tnew Emitter<ITextFileSaveEvent>(),\n\t);\n\treadonly onDidSave = this._onDidSave.event;\n\n\tprivate readonly _onDidRevert = this._register(\n\t\tnew Emitter<TextFileEditorModel>(),\n\t);\n\treadonly onDidRevert = this._onDidRevert.event;\n\n\tprivate readonly _onDidChangeEncoding = this._register(\n\t\tnew Emitter<TextFileEditorModel>(),\n\t);\n\treadonly onDidChangeEncoding = this._onDidChangeEncoding.event;\n\n\tprivate readonly mapResourceToModel =\n\t\tnew ResourceMap<TextFileEditorModel>();\n\tprivate readonly mapResourceToModelListeners =\n\t\tnew ResourceMap<IDisposable>();\n\tprivate readonly mapResourceToDisposeListener =\n\t\tnew ResourceMap<IDisposable>();\n\tprivate readonly mapResourceToPendingModelResolvers = new ResourceMap<\n\t\tPromise<void>\n\t>();\n\n\tprivate readonly modelResolveQueue = this._register(new ResourceQueue());\n\n\tsaveErrorHandler = (() => {\n\t\tconst notificationService = this.notificationService;\n\n\t\treturn {\n\t\t\tonSaveError(error: Error, model: ITextFileEditorModel): void {\n\t\t\t\tnotificationService.error(\n\t\t\t\t\tlocalize(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tkey: \"genericSaveError\",\n\t\t\t\t\t\t\tcomment: [\n\t\t\t\t\t\t\t\t\"{0} is the resource that failed to save and {1} the error message\",\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"Failed to save '{0}': {1}\",\n\t\t\t\t\t\tmodel.name,\n\t\t\t\t\t\ttoErrorMessage(error, false),\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t},\n\t\t};\n\t})();\n\n\tget models(): TextFileEditorModel[] {\n\t\treturn [...this.mapResourceToModel.values()];\n\t}\n\n\tconstructor(\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService,\n\t\t@IFileService private readonly fileService: IFileService,\n\t\t@INotificationService private readonly notificationService: INotificationService,\n\t\t@IWorkingCopyFileService private readonly workingCopyFileService: IWorkingCopyFileService,\n\t\t@IUriIdentityService private readonly uriIdentityService: IUriIdentityService\n\t) {\n\t\tsuper();\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\t// Update models from file change events\n\t\tthis._register(\n\t\t\tthis.fileService.onDidFilesChange((e) => this.onDidFilesChange(e)),\n\t\t);\n\n\t\t// File system provider changes\n\t\tthis._register(\n\t\t\tthis.fileService.onDidChangeFileSystemProviderCapabilities((e) =>\n\t\t\t\tthis.onDidChangeFileSystemProviderCapabilities(e),\n\t\t\t),\n\t\t);\n\t\tthis._register(\n\t\t\tthis.fileService.onDidChangeFileSystemProviderRegistrations((e) =>\n\t\t\t\tthis.onDidChangeFileSystemProviderRegistrations(e),\n\t\t\t),\n\t\t);\n\n\t\t// Working copy operations\n\t\tthis._register(\n\t\t\tthis.workingCopyFileService.onWillRunWorkingCopyFileOperation((e) =>\n\t\t\t\tthis.onWillRunWorkingCopyFileOperation(e),\n\t\t\t),\n\t\t);\n\t\tthis._register(\n\t\t\tthis.workingCopyFileService.onDidFailWorkingCopyFileOperation((e) =>\n\t\t\t\tthis.onDidFailWorkingCopyFileOperation(e),\n\t\t\t),\n\t\t);\n\t\tthis._register(\n\t\t\tthis.workingCopyFileService.onDidRunWorkingCopyFileOperation((e) =>\n\t\t\t\tthis.onDidRunWorkingCopyFileOperation(e),\n\t\t\t),\n\t\t);\n\t}\n\n\tprivate onDidFilesChange(e: FileChangesEvent): void {\n\t\tfor (const model of this.models) {\n\t\t\tif (model.isDirty()) {\n\t\t\t\tcontinue; // never reload dirty models\n\t\t\t}\n\n\t\t\t// Trigger a model resolve for any update or add event that impacts\n\t\t\t// the model. We also consider the added event because it could\n\t\t\t// be that a file was added and updated right after.\n\t\t\tif (\n\t\t\t\te.contains(\n\t\t\t\t\tmodel.resource,\n\t\t\t\t\tFileChangeType.UPDATED,\n\t\t\t\t\tFileChangeType.ADDED,\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tthis.queueModelReload(model);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate onDidChangeFileSystemProviderCapabilities(\n\t\te: IFileSystemProviderCapabilitiesChangeEvent,\n\t): void {\n\t\t// Resolve models again for file systems that changed\n\t\t// capabilities to fetch latest metadata (e.g. readonly)\n\t\t// into all models.\n\t\tthis.queueModelReloads(e.scheme);\n\t}\n\n\tprivate onDidChangeFileSystemProviderRegistrations(\n\t\te: IFileSystemProviderRegistrationEvent,\n\t): void {\n\t\tif (!e.added) {\n\t\t\treturn; // only if added\n\t\t}\n\n\t\t// Resolve models again for file systems that registered\n\t\t// to account for capability changes: extensions may\n\t\t// unregister and register the same provider with different\n\t\t// capabilities, so we want to ensure to fetch latest\n\t\t// metadata (e.g. readonly) into all models.\n\t\tthis.queueModelReloads(e.scheme);\n\t}\n\n\tprivate queueModelReloads(scheme: string): void {\n\t\tfor (const model of this.models) {\n\t\t\tif (model.isDirty()) {\n\t\t\t\tcontinue; // never reload dirty models\n\t\t\t}\n\n\t\t\tif (scheme === model.resource.scheme) {\n\t\t\t\tthis.queueModelReload(model);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate queueModelReload(model: TextFileEditorModel): void {\n\t\t// Resolve model to update (use a queue to prevent accumulation of resolves\n\t\t// when the resolve actually takes long. At most we only want the queue\n\t\t// to have a size of 2 (1 running resolve and 1 queued resolve).\n\t\tconst queueSize = this.modelResolveQueue.queueSize(model.resource);\n\t\tif (queueSize <= 1) {\n\t\t\tthis.modelResolveQueue.queueFor(model.resource, async () => {\n\t\t\t\ttry {\n\t\t\t\t\tawait this.reload(model);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tonUnexpectedError(error);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate readonly mapCorrelationIdToModelsToRestore = new Map<\n\t\tnumber,\n\t\t{\n\t\t\tsource: URI;\n\t\t\ttarget: URI;\n\t\t\tsnapshot?: ITextSnapshot;\n\t\t\tlanguageId?: string;\n\t\t\tencoding?: string;\n\t\t}[]\n\t>();\n\n\tprivate onWillRunWorkingCopyFileOperation(e: WorkingCopyFileEvent): void {\n\t\t// Move / Copy: remember models to restore after the operation\n\t\tif (\n\t\t\te.operation === FileOperation.MOVE ||\n\t\t\te.operation === FileOperation.COPY\n\t\t) {\n\t\t\tconst modelsToRestore: {\n\t\t\t\tsource: URI;\n\t\t\t\ttarget: URI;\n\t\t\t\tsnapshot?: ITextSnapshot;\n\t\t\t\tlanguageId?: string;\n\t\t\t\tencoding?: string;\n\t\t\t}[] = [];\n\n\t\t\tfor (const { source, target } of e.files) {\n\t\t\t\tif (source) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tthis.uriIdentityService.extUri.isEqual(source, target)\n\t\t\t\t\t) {\n\t\t\t\t\t\tcontinue; // ignore if resources are considered equal\n\t\t\t\t\t}\n\n\t\t\t\t\t// find all models that related to source (can be many if resource is a folder)\n\t\t\t\t\tconst sourceModels: TextFileEditorModel[] = [];\n\t\t\t\t\tfor (const model of this.models) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tthis.uriIdentityService.extUri.isEqualOrParent(\n\t\t\t\t\t\t\t\tmodel.resource,\n\t\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tsourceModels.push(model);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// remember each source model to resolve again after move is done\n\t\t\t\t\t// with optional content to restore if it was dirty\n\t\t\t\t\tfor (const sourceModel of sourceModels) {\n\t\t\t\t\t\tconst sourceModelResource = sourceModel.resource;\n\n\t\t\t\t\t\t// If the source is the actual model, just use target as new resource\n\t\t\t\t\t\tlet targetModelResource: URI;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tthis.uriIdentityService.extUri.isEqual(\n\t\t\t\t\t\t\t\tsourceModelResource,\n\t\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\ttargetModelResource = target;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Otherwise a parent folder of the source is being moved, so we need\n\t\t\t\t\t\t// to compute the target resource based on that\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttargetModelResource = joinPath(\n\t\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\t\tsourceModelResource.path.substr(\n\t\t\t\t\t\t\t\t\tsource.path.length + 1,\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmodelsToRestore.push({\n\t\t\t\t\t\t\tsource: sourceModelResource,\n\t\t\t\t\t\t\ttarget: targetModelResource,\n\t\t\t\t\t\t\tlanguageId: sourceModel.getLanguageId(),\n\t\t\t\t\t\t\tencoding: sourceModel.getEncoding(),\n\t\t\t\t\t\t\tsnapshot: sourceModel.isDirty()\n\t\t\t\t\t\t\t\t? sourceModel.createSnapshot()\n\t\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.mapCorrelationIdToModelsToRestore.set(\n\t\t\t\te.correlationId,\n\t\t\t\tmodelsToRestore,\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate onDidFailWorkingCopyFileOperation(e: WorkingCopyFileEvent): void {\n\t\t// Move / Copy: restore dirty flag on models to restore that were dirty\n\t\tif (\n\t\t\te.operation === FileOperation.MOVE ||\n\t\t\te.operation === FileOperation.COPY\n\t\t) {\n\t\t\tconst modelsToRestore = this.mapCorrelationIdToModelsToRestore.get(\n\t\t\t\te.correlationId,\n\t\t\t);\n\t\t\tif (modelsToRestore) {\n\t\t\t\tthis.mapCorrelationIdToModelsToRestore.delete(e.correlationId);\n\n\t\t\t\tmodelsToRestore.forEach((model) => {\n\t\t\t\t\t// snapshot presence means this model used to be dirty and so we restore that\n\t\t\t\t\t// flag. we do NOT have to restore the content because the model was only soft\n\t\t\t\t\t// reverted and did not loose its original dirty contents.\n\t\t\t\t\tif (model.snapshot) {\n\t\t\t\t\t\tthis.get(model.source)?.setDirty(true);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate onDidRunWorkingCopyFileOperation(e: WorkingCopyFileEvent): void {\n\t\tswitch (e.operation) {\n\t\t\t// Create: Revert existing models\n\t\t\tcase FileOperation.CREATE:\n\t\t\t\te.waitUntil(\n\t\t\t\t\t(async () => {\n\t\t\t\t\t\tfor (const { target } of e.files) {\n\t\t\t\t\t\t\tconst model = this.get(target);\n\t\t\t\t\t\t\tif (model && !model.isDisposed()) {\n\t\t\t\t\t\t\t\tawait model.revert();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t})(),\n\t\t\t\t);\n\t\t\t\tbreak;\n\n\t\t\t// Move/Copy: restore models that were resolved before the operation took place\n\t\t\tcase FileOperation.MOVE:\n\t\t\tcase FileOperation.COPY:\n\t\t\t\te.waitUntil(\n\t\t\t\t\t(async () => {\n\t\t\t\t\t\tconst modelsToRestore =\n\t\t\t\t\t\t\tthis.mapCorrelationIdToModelsToRestore.get(\n\t\t\t\t\t\t\t\te.correlationId,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\tif (modelsToRestore) {\n\t\t\t\t\t\t\tthis.mapCorrelationIdToModelsToRestore.delete(\n\t\t\t\t\t\t\t\te.correlationId,\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tawait Promises.settled(\n\t\t\t\t\t\t\t\tmodelsToRestore.map(async (modelToRestore) => {\n\t\t\t\t\t\t\t\t\t// From this moment on, only operate on the canonical resource\n\t\t\t\t\t\t\t\t\t// to fix a potential data loss issue:\n\t\t\t\t\t\t\t\t\t// https://github.com/microsoft/vscode/issues/211374\n\t\t\t\t\t\t\t\t\tconst target =\n\t\t\t\t\t\t\t\t\t\tthis.uriIdentityService.asCanonicalUri(\n\t\t\t\t\t\t\t\t\t\t\tmodelToRestore.target,\n\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t// restore the model at the target. if we have previous dirty content, we pass it\n\t\t\t\t\t\t\t\t\t// over to be used, otherwise we force a reload from disk. this is important\n\t\t\t\t\t\t\t\t\t// because we know the file has changed on disk after the move and the model might\n\t\t\t\t\t\t\t\t\t// have still existed with the previous state. this ensures that the model is not\n\t\t\t\t\t\t\t\t\t// tracking a stale state.\n\t\t\t\t\t\t\t\t\tconst restoredModel = await this.resolve(\n\t\t\t\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\treload: { async: false }, // enforce a reload\n\t\t\t\t\t\t\t\t\t\t\tcontents: modelToRestore.snapshot\n\t\t\t\t\t\t\t\t\t\t\t\t? createTextBufferFactoryFromSnapshot(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodelToRestore.snapshot,\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t\t\t\t\t\t\tencoding: modelToRestore.encoding,\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t// restore previous language only if the language is now unspecified and it was specified\n\t\t\t\t\t\t\t\t\t// but not when the file was explicitly stored with the plain text extension\n\t\t\t\t\t\t\t\t\t// (https://github.com/microsoft/vscode/issues/125795)\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tmodelToRestore.languageId &&\n\t\t\t\t\t\t\t\t\t\tmodelToRestore.languageId !==\n\t\t\t\t\t\t\t\t\t\t\tPLAINTEXT_LANGUAGE_ID &&\n\t\t\t\t\t\t\t\t\t\trestoredModel.getLanguageId() ===\n\t\t\t\t\t\t\t\t\t\t\tPLAINTEXT_LANGUAGE_ID &&\n\t\t\t\t\t\t\t\t\t\textname(target) !== PLAINTEXT_EXTENSION\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\trestoredModel.updateTextEditorModel(\n\t\t\t\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\t\t\t\tmodelToRestore.languageId,\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t})(),\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tget(resource: URI): TextFileEditorModel | undefined {\n\t\treturn this.mapResourceToModel.get(resource);\n\t}\n\n\tprivate has(resource: URI): boolean {\n\t\treturn this.mapResourceToModel.has(resource);\n\t}\n\n\tprivate async reload(model: TextFileEditorModel): Promise<void> {\n\t\t// Await a pending model resolve first before proceeding\n\t\t// to ensure that we never resolve a model more than once\n\t\t// in parallel.\n\t\tawait this.joinPendingResolves(model.resource);\n\n\t\tif (\n\t\t\tmodel.isDirty() ||\n\t\t\tmodel.isDisposed() ||\n\t\t\t!this.has(model.resource)\n\t\t) {\n\t\t\treturn; // the model possibly got dirty or disposed, so return early then\n\t\t}\n\n\t\t// Trigger reload\n\t\tawait this.doResolve(model, { reload: { async: false } });\n\t}\n\n\tasync resolve(\n\t\tresource: URI,\n\t\toptions?: ITextFileEditorModelResolveOrCreateOptions,\n\t): Promise<TextFileEditorModel> {\n\t\t// Await a pending model resolve first before proceeding\n\t\t// to ensure that we never resolve a model more than once\n\t\t// in parallel.\n\t\tconst pendingResolve = this.joinPendingResolves(resource);\n\t\tif (pendingResolve) {\n\t\t\tawait pendingResolve;\n\t\t}\n\n\t\t// Trigger resolve\n\t\treturn this.doResolve(resource, options);\n\t}\n\n\tprivate async doResolve(\n\t\tresourceOrModel: URI | TextFileEditorModel,\n\t\toptions?: ITextFileEditorModelResolveOrCreateOptions,\n\t): Promise<TextFileEditorModel> {\n\t\tlet model: TextFileEditorModel | undefined;\n\t\tlet resource: URI;\n\t\tif (URI.isUri(resourceOrModel)) {\n\t\t\tresource = resourceOrModel;\n\t\t\tmodel = this.get(resource);\n\t\t} else {\n\t\t\tresource = resourceOrModel.resource;\n\t\t\tmodel = resourceOrModel;\n\t\t}\n\n\t\tlet modelResolve: Promise<void>;\n\t\tlet didCreateModel = false;\n\n\t\t// Model exists\n\t\tif (model) {\n\t\t\t// Always reload if contents are provided\n\t\t\tif (options?.contents) {\n\t\t\t\tmodelResolve = model.resolve(options);\n\t\t\t}\n\n\t\t\t// Reload async or sync based on options\n\t\t\telse if (options?.reload) {\n\t\t\t\t// async reload: trigger a reload but return immediately\n\t\t\t\tif (options.reload.async) {\n\t\t\t\t\tmodelResolve = Promise.resolve();\n\t\t\t\t\t(async () => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait model.resolve(options);\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tonUnexpectedError(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t})();\n\t\t\t\t}\n\n\t\t\t\t// sync reload: do not return until model reloaded\n\t\t\t\telse {\n\t\t\t\t\tmodelResolve = model.resolve(options);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Do not reload\n\t\t\telse {\n\t\t\t\tmodelResolve = Promise.resolve();\n\t\t\t}\n\t\t}\n\n\t\t// Model does not exist\n\t\telse {\n\t\t\tdidCreateModel = true;\n\n\t\t\tconst newModel = (model = this.instantiationService.createInstance(\n\t\t\t\tTextFileEditorModel,\n\t\t\t\tresource,\n\t\t\t\toptions ? options.encoding : undefined,\n\t\t\t\toptions ? options.languageId : undefined,\n\t\t\t));\n\t\t\tmodelResolve = model.resolve(options);\n\n\t\t\tthis.registerModel(newModel);\n\t\t}\n\n\t\t// Store pending resolves to avoid race conditions\n\t\tthis.mapResourceToPendingModelResolvers.set(resource, modelResolve);\n\n\t\t// Make known to manager (if not already known)\n\t\tthis.add(resource, model);\n\n\t\t// Emit some events if we created the model\n\t\tif (didCreateModel) {\n\t\t\tthis._onDidCreate.fire(model);\n\n\t\t\t// If the model is dirty right from the beginning,\n\t\t\t// make sure to emit this as an event\n\t\t\tif (model.isDirty()) {\n\t\t\t\tthis._onDidChangeDirty.fire(model);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tawait modelResolve;\n\t\t} catch (error) {\n\t\t\t// Automatically dispose the model if we created it\n\t\t\t// because we cannot dispose a model we do not own\n\t\t\t// https://github.com/microsoft/vscode/issues/138850\n\t\t\tif (didCreateModel) {\n\t\t\t\tmodel.dispose();\n\t\t\t}\n\n\t\t\tthrow error;\n\t\t} finally {\n\t\t\t// Remove from pending resolves\n\t\t\tthis.mapResourceToPendingModelResolvers.delete(resource);\n\t\t}\n\n\t\t// Apply language if provided\n\t\tif (options?.languageId) {\n\t\t\tmodel.setLanguageId(options.languageId);\n\t\t}\n\n\t\t// Model can be dirty if a backup was restored, so we make sure to\n\t\t// have this event delivered if we created the model here\n\t\tif (didCreateModel && model.isDirty()) {\n\t\t\tthis._onDidChangeDirty.fire(model);\n\t\t}\n\n\t\treturn model;\n\t}\n\n\tprivate joinPendingResolves(resource: URI): Promise<void> | undefined {\n\t\tconst pendingModelResolve =\n\t\t\tthis.mapResourceToPendingModelResolvers.get(resource);\n\t\tif (!pendingModelResolve) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn this.doJoinPendingResolves(resource);\n\t}\n\n\tprivate async doJoinPendingResolves(resource: URI): Promise<void> {\n\t\t// While we have pending model resolves, ensure\n\t\t// to await the last one finishing before returning.\n\t\t// This prevents a race when multiple clients await\n\t\t// the pending resolve and then all trigger the resolve\n\t\t// at the same time.\n\t\tlet currentModelCopyResolve: Promise<void> | undefined;\n\t\twhile (this.mapResourceToPendingModelResolvers.has(resource)) {\n\t\t\tconst nextPendingModelResolve =\n\t\t\t\tthis.mapResourceToPendingModelResolvers.get(resource);\n\t\t\tif (nextPendingModelResolve === currentModelCopyResolve) {\n\t\t\t\treturn; // already awaited on - return\n\t\t\t}\n\n\t\t\tcurrentModelCopyResolve = nextPendingModelResolve;\n\t\t\ttry {\n\t\t\t\tawait nextPendingModelResolve;\n\t\t\t} catch (error) {\n\t\t\t\t// ignore any error here, it will bubble to the original requestor\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate registerModel(model: TextFileEditorModel): void {\n\t\t// Install model listeners\n\t\tconst modelListeners = new DisposableStore();\n\t\tmodelListeners.add(\n\t\t\tmodel.onDidResolve((reason) =>\n\t\t\t\tthis._onDidResolve.fire({ model, reason }),\n\t\t\t),\n\t\t);\n\t\tmodelListeners.add(\n\t\t\tmodel.onDidChangeDirty(() => this._onDidChangeDirty.fire(model)),\n\t\t);\n\t\tmodelListeners.add(\n\t\t\tmodel.onDidChangeReadonly(() =>\n\t\t\t\tthis._onDidChangeReadonly.fire(model),\n\t\t\t),\n\t\t);\n\t\tmodelListeners.add(\n\t\t\tmodel.onDidChangeOrphaned(() =>\n\t\t\t\tthis._onDidChangeOrphaned.fire(model),\n\t\t\t),\n\t\t);\n\t\tmodelListeners.add(\n\t\t\tmodel.onDidSaveError(() => this._onDidSaveError.fire(model)),\n\t\t);\n\t\tmodelListeners.add(\n\t\t\tmodel.onDidSave((e) => this._onDidSave.fire({ model, ...e })),\n\t\t);\n\t\tmodelListeners.add(\n\t\t\tmodel.onDidRevert(() => this._onDidRevert.fire(model)),\n\t\t);\n\t\tmodelListeners.add(\n\t\t\tmodel.onDidChangeEncoding(() =>\n\t\t\t\tthis._onDidChangeEncoding.fire(model),\n\t\t\t),\n\t\t);\n\n\t\t// Keep for disposal\n\t\tthis.mapResourceToModelListeners.set(model.resource, modelListeners);\n\t}\n\n\tadd(resource: URI, model: TextFileEditorModel): void {\n\t\tconst knownModel = this.mapResourceToModel.get(resource);\n\t\tif (knownModel === model) {\n\t\t\treturn; // already cached\n\t\t}\n\n\t\t// dispose any previously stored dispose listener for this resource\n\t\tconst disposeListener = this.mapResourceToDisposeListener.get(resource);\n\t\tdisposeListener?.dispose();\n\n\t\t// store in cache but remove when model gets disposed\n\t\tthis.mapResourceToModel.set(resource, model);\n\t\tthis.mapResourceToDisposeListener.set(\n\t\t\tresource,\n\t\t\tmodel.onWillDispose(() => this.remove(resource)),\n\t\t);\n\t}\n\n\tremove(resource: URI): void {\n\t\tconst removed = this.mapResourceToModel.delete(resource);\n\n\t\tconst disposeListener = this.mapResourceToDisposeListener.get(resource);\n\t\tif (disposeListener) {\n\t\t\tdispose(disposeListener);\n\t\t\tthis.mapResourceToDisposeListener.delete(resource);\n\t\t}\n\n\t\tconst modelListener = this.mapResourceToModelListeners.get(resource);\n\t\tif (modelListener) {\n\t\t\tdispose(modelListener);\n\t\t\tthis.mapResourceToModelListeners.delete(resource);\n\t\t}\n\n\t\tif (removed) {\n\t\t\tthis._onDidRemove.fire(resource);\n\t\t}\n\t}\n\n\t//#region Save participants\n\n\tprivate readonly saveParticipants = this._register(\n\t\tthis.instantiationService.createInstance(TextFileSaveParticipant),\n\t);\n\n\taddSaveParticipant(participant: ITextFileSaveParticipant): IDisposable {\n\t\treturn this.saveParticipants.addSaveParticipant(participant);\n\t}\n\n\trunSaveParticipants(\n\t\tmodel: ITextFileEditorModel,\n\t\tcontext: IStoredFileWorkingCopySaveParticipantContext,\n\t\tprogress: IProgress<IProgressStep>,\n\t\ttoken: CancellationToken,\n\t): Promise<void> {\n\t\treturn this.saveParticipants.participate(\n\t\t\tmodel,\n\t\t\tcontext,\n\t\t\tprogress,\n\t\t\ttoken,\n\t\t);\n\t}\n\n\t//#endregion\n\n\tcanDispose(model: TextFileEditorModel): true | Promise<true> {\n\t\t// quick return if model already disposed or not dirty and not resolving\n\t\tif (\n\t\t\tmodel.isDisposed() ||\n\t\t\t(!this.mapResourceToPendingModelResolvers.has(model.resource) &&\n\t\t\t\t!model.isDirty())\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// promise based return in all other cases\n\t\treturn this.doCanDispose(model);\n\t}\n\n\tprivate async doCanDispose(model: TextFileEditorModel): Promise<true> {\n\t\t// Await any pending resolves first before proceeding\n\t\tconst pendingResolve = this.joinPendingResolves(model.resource);\n\t\tif (pendingResolve) {\n\t\t\tawait pendingResolve;\n\n\t\t\treturn this.canDispose(model);\n\t\t}\n\n\t\t// dirty model: we do not allow to dispose dirty models to prevent\n\t\t// data loss cases. dirty models can only be disposed when they are\n\t\t// either saved or reverted\n\t\tif (model.isDirty()) {\n\t\t\tawait Event.toPromise(model.onDidChangeDirty);\n\n\t\t\treturn this.canDispose(model);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\t// model caches\n\t\tthis.mapResourceToModel.clear();\n\t\tthis.mapResourceToPendingModelResolvers.clear();\n\n\t\t// dispose the dispose listeners\n\t\tdispose(this.mapResourceToDisposeListener.values());\n\t\tthis.mapResourceToDisposeListener.clear();\n\n\t\t// dispose the model change listeners\n\t\tdispose(this.mapResourceToModelListeners.values());\n\t\tthis.mapResourceToModelListeners.clear();\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
