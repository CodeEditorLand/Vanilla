{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/textfile/common/textFileEditorModelManager.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { localize } from '../../../../nls.js';\nimport { toErrorMessage } from '../../../../base/common/errorMessage.js';\nimport { Event, Emitter } from '../../../../base/common/event.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { TextFileEditorModel } from './textFileEditorModel.js';\nimport { dispose, IDisposable, Disposable, DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { ITextFileEditorModel, ITextFileEditorModelManager, ITextFileEditorModelResolveOrCreateOptions, ITextFileResolveEvent, ITextFileSaveEvent, ITextFileSaveParticipant } from './textfiles.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ResourceMap } from '../../../../base/common/map.js';\nimport { IFileService, FileChangesEvent, FileOperation, FileChangeType, IFileSystemProviderRegistrationEvent, IFileSystemProviderCapabilitiesChangeEvent } from '../../../../platform/files/common/files.js';\nimport { Promises, ResourceQueue } from '../../../../base/common/async.js';\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\nimport { TextFileSaveParticipant } from './textFileSaveParticipant.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { INotificationService } from '../../../../platform/notification/common/notification.js';\nimport { IStoredFileWorkingCopySaveParticipantContext, IWorkingCopyFileService, WorkingCopyFileEvent } from '../../workingCopy/common/workingCopyFileService.js';\nimport { ITextSnapshot } from '../../../../editor/common/model.js';\nimport { extname, joinPath } from '../../../../base/common/resources.js';\nimport { createTextBufferFactoryFromSnapshot } from '../../../../editor/common/model/textModel.js';\nimport { PLAINTEXT_EXTENSION, PLAINTEXT_LANGUAGE_ID } from '../../../../editor/common/languages/modesRegistry.js';\nimport { IUriIdentityService } from '../../../../platform/uriIdentity/common/uriIdentity.js';\nimport { IProgress, IProgressStep } from '../../../../platform/progress/common/progress.js';\n\nexport class TextFileEditorModelManager extends Disposable implements ITextFileEditorModelManager {\n\n\tprivate readonly _onDidCreate = this._register(new Emitter<TextFileEditorModel>({ leakWarningThreshold: 500 /* increased for users with hundreds of inputs opened */ }));\n\treadonly onDidCreate = this._onDidCreate.event;\n\n\tprivate readonly _onDidResolve = this._register(new Emitter<ITextFileResolveEvent>());\n\treadonly onDidResolve = this._onDidResolve.event;\n\n\tprivate readonly _onDidRemove = this._register(new Emitter<URI>());\n\treadonly onDidRemove = this._onDidRemove.event;\n\n\tprivate readonly _onDidChangeDirty = this._register(new Emitter<TextFileEditorModel>());\n\treadonly onDidChangeDirty = this._onDidChangeDirty.event;\n\n\tprivate readonly _onDidChangeReadonly = this._register(new Emitter<TextFileEditorModel>());\n\treadonly onDidChangeReadonly = this._onDidChangeReadonly.event;\n\n\tprivate readonly _onDidChangeOrphaned = this._register(new Emitter<TextFileEditorModel>());\n\treadonly onDidChangeOrphaned = this._onDidChangeOrphaned.event;\n\n\tprivate readonly _onDidSaveError = this._register(new Emitter<TextFileEditorModel>());\n\treadonly onDidSaveError = this._onDidSaveError.event;\n\n\tprivate readonly _onDidSave = this._register(new Emitter<ITextFileSaveEvent>());\n\treadonly onDidSave = this._onDidSave.event;\n\n\tprivate readonly _onDidRevert = this._register(new Emitter<TextFileEditorModel>());\n\treadonly onDidRevert = this._onDidRevert.event;\n\n\tprivate readonly _onDidChangeEncoding = this._register(new Emitter<TextFileEditorModel>());\n\treadonly onDidChangeEncoding = this._onDidChangeEncoding.event;\n\n\tprivate readonly mapResourceToModel = new ResourceMap<TextFileEditorModel>();\n\tprivate readonly mapResourceToModelListeners = new ResourceMap<IDisposable>();\n\tprivate readonly mapResourceToDisposeListener = new ResourceMap<IDisposable>();\n\tprivate readonly mapResourceToPendingModelResolvers = new ResourceMap<Promise<void>>();\n\n\tprivate readonly modelResolveQueue = this._register(new ResourceQueue());\n\n\tsaveErrorHandler = (() => {\n\t\tconst notificationService = this.notificationService;\n\n\t\treturn {\n\t\t\tonSaveError(error: Error, model: ITextFileEditorModel): void {\n\t\t\t\tnotificationService.error(localize({ key: 'genericSaveError', comment: ['{0} is the resource that failed to save and {1} the error message'] }, \"Failed to save '{0}': {1}\", model.name, toErrorMessage(error, false)));\n\t\t\t}\n\t\t};\n\t})();\n\n\tget models(): TextFileEditorModel[] {\n\t\treturn [...this.mapResourceToModel.values()];\n\t}\n\n\tconstructor(\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService,\n\t\t@IFileService private readonly fileService: IFileService,\n\t\t@INotificationService private readonly notificationService: INotificationService,\n\t\t@IWorkingCopyFileService private readonly workingCopyFileService: IWorkingCopyFileService,\n\t\t@IUriIdentityService private readonly uriIdentityService: IUriIdentityService\n\t) {\n\t\tsuper();\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\n\t\t// Update models from file change events\n\t\tthis._register(this.fileService.onDidFilesChange(e => this.onDidFilesChange(e)));\n\n\t\t// File system provider changes\n\t\tthis._register(this.fileService.onDidChangeFileSystemProviderCapabilities(e => this.onDidChangeFileSystemProviderCapabilities(e)));\n\t\tthis._register(this.fileService.onDidChangeFileSystemProviderRegistrations(e => this.onDidChangeFileSystemProviderRegistrations(e)));\n\n\t\t// Working copy operations\n\t\tthis._register(this.workingCopyFileService.onWillRunWorkingCopyFileOperation(e => this.onWillRunWorkingCopyFileOperation(e)));\n\t\tthis._register(this.workingCopyFileService.onDidFailWorkingCopyFileOperation(e => this.onDidFailWorkingCopyFileOperation(e)));\n\t\tthis._register(this.workingCopyFileService.onDidRunWorkingCopyFileOperation(e => this.onDidRunWorkingCopyFileOperation(e)));\n\t}\n\n\tprivate onDidFilesChange(e: FileChangesEvent): void {\n\t\tfor (const model of this.models) {\n\t\t\tif (model.isDirty()) {\n\t\t\t\tcontinue; // never reload dirty models\n\t\t\t}\n\n\t\t\t// Trigger a model resolve for any update or add event that impacts\n\t\t\t// the model. We also consider the added event because it could\n\t\t\t// be that a file was added and updated right after.\n\t\t\tif (e.contains(model.resource, FileChangeType.UPDATED, FileChangeType.ADDED)) {\n\t\t\t\tthis.queueModelReload(model);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate onDidChangeFileSystemProviderCapabilities(e: IFileSystemProviderCapabilitiesChangeEvent): void {\n\n\t\t// Resolve models again for file systems that changed\n\t\t// capabilities to fetch latest metadata (e.g. readonly)\n\t\t// into all models.\n\t\tthis.queueModelReloads(e.scheme);\n\t}\n\n\tprivate onDidChangeFileSystemProviderRegistrations(e: IFileSystemProviderRegistrationEvent): void {\n\t\tif (!e.added) {\n\t\t\treturn; // only if added\n\t\t}\n\n\t\t// Resolve models again for file systems that registered\n\t\t// to account for capability changes: extensions may\n\t\t// unregister and register the same provider with different\n\t\t// capabilities, so we want to ensure to fetch latest\n\t\t// metadata (e.g. readonly) into all models.\n\t\tthis.queueModelReloads(e.scheme);\n\t}\n\n\tprivate queueModelReloads(scheme: string): void {\n\t\tfor (const model of this.models) {\n\t\t\tif (model.isDirty()) {\n\t\t\t\tcontinue; // never reload dirty models\n\t\t\t}\n\n\t\t\tif (scheme === model.resource.scheme) {\n\t\t\t\tthis.queueModelReload(model);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate queueModelReload(model: TextFileEditorModel): void {\n\n\t\t// Resolve model to update (use a queue to prevent accumulation of resolves\n\t\t// when the resolve actually takes long. At most we only want the queue\n\t\t// to have a size of 2 (1 running resolve and 1 queued resolve).\n\t\tconst queueSize = this.modelResolveQueue.queueSize(model.resource);\n\t\tif (queueSize <= 1) {\n\t\t\tthis.modelResolveQueue.queueFor(model.resource, async () => {\n\t\t\t\ttry {\n\t\t\t\t\tawait this.reload(model);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tonUnexpectedError(error);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate readonly mapCorrelationIdToModelsToRestore = new Map<number, { source: URI; target: URI; snapshot?: ITextSnapshot; languageId?: string; encoding?: string }[]>();\n\n\tprivate onWillRunWorkingCopyFileOperation(e: WorkingCopyFileEvent): void {\n\n\t\t// Move / Copy: remember models to restore after the operation\n\t\tif (e.operation === FileOperation.MOVE || e.operation === FileOperation.COPY) {\n\t\t\tconst modelsToRestore: { source: URI; target: URI; snapshot?: ITextSnapshot; languageId?: string; encoding?: string }[] = [];\n\n\t\t\tfor (const { source, target } of e.files) {\n\t\t\t\tif (source) {\n\t\t\t\t\tif (this.uriIdentityService.extUri.isEqual(source, target)) {\n\t\t\t\t\t\tcontinue; // ignore if resources are considered equal\n\t\t\t\t\t}\n\n\t\t\t\t\t// find all models that related to source (can be many if resource is a folder)\n\t\t\t\t\tconst sourceModels: TextFileEditorModel[] = [];\n\t\t\t\t\tfor (const model of this.models) {\n\t\t\t\t\t\tif (this.uriIdentityService.extUri.isEqualOrParent(model.resource, source)) {\n\t\t\t\t\t\t\tsourceModels.push(model);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// remember each source model to resolve again after move is done\n\t\t\t\t\t// with optional content to restore if it was dirty\n\t\t\t\t\tfor (const sourceModel of sourceModels) {\n\t\t\t\t\t\tconst sourceModelResource = sourceModel.resource;\n\n\t\t\t\t\t\t// If the source is the actual model, just use target as new resource\n\t\t\t\t\t\tlet targetModelResource: URI;\n\t\t\t\t\t\tif (this.uriIdentityService.extUri.isEqual(sourceModelResource, source)) {\n\t\t\t\t\t\t\ttargetModelResource = target;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Otherwise a parent folder of the source is being moved, so we need\n\t\t\t\t\t\t// to compute the target resource based on that\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttargetModelResource = joinPath(target, sourceModelResource.path.substr(source.path.length + 1));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmodelsToRestore.push({\n\t\t\t\t\t\t\tsource: sourceModelResource,\n\t\t\t\t\t\t\ttarget: targetModelResource,\n\t\t\t\t\t\t\tlanguageId: sourceModel.getLanguageId(),\n\t\t\t\t\t\t\tencoding: sourceModel.getEncoding(),\n\t\t\t\t\t\t\tsnapshot: sourceModel.isDirty() ? sourceModel.createSnapshot() : undefined\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.mapCorrelationIdToModelsToRestore.set(e.correlationId, modelsToRestore);\n\t\t}\n\t}\n\n\tprivate onDidFailWorkingCopyFileOperation(e: WorkingCopyFileEvent): void {\n\n\t\t// Move / Copy: restore dirty flag on models to restore that were dirty\n\t\tif ((e.operation === FileOperation.MOVE || e.operation === FileOperation.COPY)) {\n\t\t\tconst modelsToRestore = this.mapCorrelationIdToModelsToRestore.get(e.correlationId);\n\t\t\tif (modelsToRestore) {\n\t\t\t\tthis.mapCorrelationIdToModelsToRestore.delete(e.correlationId);\n\n\t\t\t\tmodelsToRestore.forEach(model => {\n\t\t\t\t\t// snapshot presence means this model used to be dirty and so we restore that\n\t\t\t\t\t// flag. we do NOT have to restore the content because the model was only soft\n\t\t\t\t\t// reverted and did not loose its original dirty contents.\n\t\t\t\t\tif (model.snapshot) {\n\t\t\t\t\t\tthis.get(model.source)?.setDirty(true);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate onDidRunWorkingCopyFileOperation(e: WorkingCopyFileEvent): void {\n\t\tswitch (e.operation) {\n\n\t\t\t// Create: Revert existing models\n\t\t\tcase FileOperation.CREATE:\n\t\t\t\te.waitUntil((async () => {\n\t\t\t\t\tfor (const { target } of e.files) {\n\t\t\t\t\t\tconst model = this.get(target);\n\t\t\t\t\t\tif (model && !model.isDisposed()) {\n\t\t\t\t\t\t\tawait model.revert();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})());\n\t\t\t\tbreak;\n\n\t\t\t// Move/Copy: restore models that were resolved before the operation took place\n\t\t\tcase FileOperation.MOVE:\n\t\t\tcase FileOperation.COPY:\n\t\t\t\te.waitUntil((async () => {\n\t\t\t\t\tconst modelsToRestore = this.mapCorrelationIdToModelsToRestore.get(e.correlationId);\n\t\t\t\t\tif (modelsToRestore) {\n\t\t\t\t\t\tthis.mapCorrelationIdToModelsToRestore.delete(e.correlationId);\n\n\t\t\t\t\t\tawait Promises.settled(modelsToRestore.map(async modelToRestore => {\n\n\t\t\t\t\t\t\t// From this moment on, only operate on the canonical resource\n\t\t\t\t\t\t\t// to fix a potential data loss issue:\n\t\t\t\t\t\t\t// https://github.com/microsoft/vscode/issues/211374\n\t\t\t\t\t\t\tconst target = this.uriIdentityService.asCanonicalUri(modelToRestore.target);\n\n\t\t\t\t\t\t\t// restore the model at the target. if we have previous dirty content, we pass it\n\t\t\t\t\t\t\t// over to be used, otherwise we force a reload from disk. this is important\n\t\t\t\t\t\t\t// because we know the file has changed on disk after the move and the model might\n\t\t\t\t\t\t\t// have still existed with the previous state. this ensures that the model is not\n\t\t\t\t\t\t\t// tracking a stale state.\n\t\t\t\t\t\t\tconst restoredModel = await this.resolve(target, {\n\t\t\t\t\t\t\t\treload: { async: false }, // enforce a reload\n\t\t\t\t\t\t\t\tcontents: modelToRestore.snapshot ? createTextBufferFactoryFromSnapshot(modelToRestore.snapshot) : undefined,\n\t\t\t\t\t\t\t\tencoding: modelToRestore.encoding\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t// restore previous language only if the language is now unspecified and it was specified\n\t\t\t\t\t\t\t// but not when the file was explicitly stored with the plain text extension\n\t\t\t\t\t\t\t// (https://github.com/microsoft/vscode/issues/125795)\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tmodelToRestore.languageId &&\n\t\t\t\t\t\t\t\tmodelToRestore.languageId !== PLAINTEXT_LANGUAGE_ID &&\n\t\t\t\t\t\t\t\trestoredModel.getLanguageId() === PLAINTEXT_LANGUAGE_ID &&\n\t\t\t\t\t\t\t\textname(target) !== PLAINTEXT_EXTENSION\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\trestoredModel.updateTextEditorModel(undefined, modelToRestore.languageId);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}));\n\t\t\t\t\t}\n\t\t\t\t})());\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tget(resource: URI): TextFileEditorModel | undefined {\n\t\treturn this.mapResourceToModel.get(resource);\n\t}\n\n\tprivate has(resource: URI): boolean {\n\t\treturn this.mapResourceToModel.has(resource);\n\t}\n\n\tprivate async reload(model: TextFileEditorModel): Promise<void> {\n\n\t\t// Await a pending model resolve first before proceeding\n\t\t// to ensure that we never resolve a model more than once\n\t\t// in parallel.\n\t\tawait this.joinPendingResolves(model.resource);\n\n\t\tif (model.isDirty() || model.isDisposed() || !this.has(model.resource)) {\n\t\t\treturn; // the model possibly got dirty or disposed, so return early then\n\t\t}\n\n\t\t// Trigger reload\n\t\tawait this.doResolve(model, { reload: { async: false } });\n\t}\n\n\tasync resolve(resource: URI, options?: ITextFileEditorModelResolveOrCreateOptions): Promise<TextFileEditorModel> {\n\n\t\t// Await a pending model resolve first before proceeding\n\t\t// to ensure that we never resolve a model more than once\n\t\t// in parallel.\n\t\tconst pendingResolve = this.joinPendingResolves(resource);\n\t\tif (pendingResolve) {\n\t\t\tawait pendingResolve;\n\t\t}\n\n\t\t// Trigger resolve\n\t\treturn this.doResolve(resource, options);\n\t}\n\n\tprivate async doResolve(resourceOrModel: URI | TextFileEditorModel, options?: ITextFileEditorModelResolveOrCreateOptions): Promise<TextFileEditorModel> {\n\t\tlet model: TextFileEditorModel | undefined;\n\t\tlet resource: URI;\n\t\tif (URI.isUri(resourceOrModel)) {\n\t\t\tresource = resourceOrModel;\n\t\t\tmodel = this.get(resource);\n\t\t} else {\n\t\t\tresource = resourceOrModel.resource;\n\t\t\tmodel = resourceOrModel;\n\t\t}\n\n\t\tlet modelResolve: Promise<void>;\n\t\tlet didCreateModel = false;\n\n\t\t// Model exists\n\t\tif (model) {\n\n\t\t\t// Always reload if contents are provided\n\t\t\tif (options?.contents) {\n\t\t\t\tmodelResolve = model.resolve(options);\n\t\t\t}\n\n\t\t\t// Reload async or sync based on options\n\t\t\telse if (options?.reload) {\n\n\t\t\t\t// async reload: trigger a reload but return immediately\n\t\t\t\tif (options.reload.async) {\n\t\t\t\t\tmodelResolve = Promise.resolve();\n\t\t\t\t\t(async () => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait model.resolve(options);\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tonUnexpectedError(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t})();\n\t\t\t\t}\n\n\t\t\t\t// sync reload: do not return until model reloaded\n\t\t\t\telse {\n\t\t\t\t\tmodelResolve = model.resolve(options);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Do not reload\n\t\t\telse {\n\t\t\t\tmodelResolve = Promise.resolve();\n\t\t\t}\n\t\t}\n\n\t\t// Model does not exist\n\t\telse {\n\t\t\tdidCreateModel = true;\n\n\t\t\tconst newModel = model = this.instantiationService.createInstance(TextFileEditorModel, resource, options ? options.encoding : undefined, options ? options.languageId : undefined);\n\t\t\tmodelResolve = model.resolve(options);\n\n\t\t\tthis.registerModel(newModel);\n\t\t}\n\n\t\t// Store pending resolves to avoid race conditions\n\t\tthis.mapResourceToPendingModelResolvers.set(resource, modelResolve);\n\n\t\t// Make known to manager (if not already known)\n\t\tthis.add(resource, model);\n\n\t\t// Emit some events if we created the model\n\t\tif (didCreateModel) {\n\t\t\tthis._onDidCreate.fire(model);\n\n\t\t\t// If the model is dirty right from the beginning,\n\t\t\t// make sure to emit this as an event\n\t\t\tif (model.isDirty()) {\n\t\t\t\tthis._onDidChangeDirty.fire(model);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tawait modelResolve;\n\t\t} catch (error) {\n\n\t\t\t// Automatically dispose the model if we created it\n\t\t\t// because we cannot dispose a model we do not own\n\t\t\t// https://github.com/microsoft/vscode/issues/138850\n\t\t\tif (didCreateModel) {\n\t\t\t\tmodel.dispose();\n\t\t\t}\n\n\t\t\tthrow error;\n\t\t} finally {\n\n\t\t\t// Remove from pending resolves\n\t\t\tthis.mapResourceToPendingModelResolvers.delete(resource);\n\t\t}\n\n\t\t// Apply language if provided\n\t\tif (options?.languageId) {\n\t\t\tmodel.setLanguageId(options.languageId);\n\t\t}\n\n\t\t// Model can be dirty if a backup was restored, so we make sure to\n\t\t// have this event delivered if we created the model here\n\t\tif (didCreateModel && model.isDirty()) {\n\t\t\tthis._onDidChangeDirty.fire(model);\n\t\t}\n\n\t\treturn model;\n\t}\n\n\tprivate joinPendingResolves(resource: URI): Promise<void> | undefined {\n\t\tconst pendingModelResolve = this.mapResourceToPendingModelResolvers.get(resource);\n\t\tif (!pendingModelResolve) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn this.doJoinPendingResolves(resource);\n\t}\n\n\tprivate async doJoinPendingResolves(resource: URI): Promise<void> {\n\n\t\t// While we have pending model resolves, ensure\n\t\t// to await the last one finishing before returning.\n\t\t// This prevents a race when multiple clients await\n\t\t// the pending resolve and then all trigger the resolve\n\t\t// at the same time.\n\t\tlet currentModelCopyResolve: Promise<void> | undefined;\n\t\twhile (this.mapResourceToPendingModelResolvers.has(resource)) {\n\t\t\tconst nextPendingModelResolve = this.mapResourceToPendingModelResolvers.get(resource);\n\t\t\tif (nextPendingModelResolve === currentModelCopyResolve) {\n\t\t\t\treturn; // already awaited on - return\n\t\t\t}\n\n\t\t\tcurrentModelCopyResolve = nextPendingModelResolve;\n\t\t\ttry {\n\t\t\t\tawait nextPendingModelResolve;\n\t\t\t} catch (error) {\n\t\t\t\t// ignore any error here, it will bubble to the original requestor\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate registerModel(model: TextFileEditorModel): void {\n\n\t\t// Install model listeners\n\t\tconst modelListeners = new DisposableStore();\n\t\tmodelListeners.add(model.onDidResolve(reason => this._onDidResolve.fire({ model, reason })));\n\t\tmodelListeners.add(model.onDidChangeDirty(() => this._onDidChangeDirty.fire(model)));\n\t\tmodelListeners.add(model.onDidChangeReadonly(() => this._onDidChangeReadonly.fire(model)));\n\t\tmodelListeners.add(model.onDidChangeOrphaned(() => this._onDidChangeOrphaned.fire(model)));\n\t\tmodelListeners.add(model.onDidSaveError(() => this._onDidSaveError.fire(model)));\n\t\tmodelListeners.add(model.onDidSave(e => this._onDidSave.fire({ model, ...e })));\n\t\tmodelListeners.add(model.onDidRevert(() => this._onDidRevert.fire(model)));\n\t\tmodelListeners.add(model.onDidChangeEncoding(() => this._onDidChangeEncoding.fire(model)));\n\n\t\t// Keep for disposal\n\t\tthis.mapResourceToModelListeners.set(model.resource, modelListeners);\n\t}\n\n\tadd(resource: URI, model: TextFileEditorModel): void {\n\t\tconst knownModel = this.mapResourceToModel.get(resource);\n\t\tif (knownModel === model) {\n\t\t\treturn; // already cached\n\t\t}\n\n\t\t// dispose any previously stored dispose listener for this resource\n\t\tconst disposeListener = this.mapResourceToDisposeListener.get(resource);\n\t\tdisposeListener?.dispose();\n\n\t\t// store in cache but remove when model gets disposed\n\t\tthis.mapResourceToModel.set(resource, model);\n\t\tthis.mapResourceToDisposeListener.set(resource, model.onWillDispose(() => this.remove(resource)));\n\t}\n\n\tremove(resource: URI): void {\n\t\tconst removed = this.mapResourceToModel.delete(resource);\n\n\t\tconst disposeListener = this.mapResourceToDisposeListener.get(resource);\n\t\tif (disposeListener) {\n\t\t\tdispose(disposeListener);\n\t\t\tthis.mapResourceToDisposeListener.delete(resource);\n\t\t}\n\n\t\tconst modelListener = this.mapResourceToModelListeners.get(resource);\n\t\tif (modelListener) {\n\t\t\tdispose(modelListener);\n\t\t\tthis.mapResourceToModelListeners.delete(resource);\n\t\t}\n\n\t\tif (removed) {\n\t\t\tthis._onDidRemove.fire(resource);\n\t\t}\n\t}\n\n\t//#region Save participants\n\n\tprivate readonly saveParticipants = this._register(this.instantiationService.createInstance(TextFileSaveParticipant));\n\n\taddSaveParticipant(participant: ITextFileSaveParticipant): IDisposable {\n\t\treturn this.saveParticipants.addSaveParticipant(participant);\n\t}\n\n\trunSaveParticipants(model: ITextFileEditorModel, context: IStoredFileWorkingCopySaveParticipantContext, progress: IProgress<IProgressStep>, token: CancellationToken): Promise<void> {\n\t\treturn this.saveParticipants.participate(model, context, progress, token);\n\t}\n\n\t//#endregion\n\n\tcanDispose(model: TextFileEditorModel): true | Promise<true> {\n\n\t\t// quick return if model already disposed or not dirty and not resolving\n\t\tif (\n\t\t\tmodel.isDisposed() ||\n\t\t\t(!this.mapResourceToPendingModelResolvers.has(model.resource) && !model.isDirty())\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// promise based return in all other cases\n\t\treturn this.doCanDispose(model);\n\t}\n\n\tprivate async doCanDispose(model: TextFileEditorModel): Promise<true> {\n\n\t\t// Await any pending resolves first before proceeding\n\t\tconst pendingResolve = this.joinPendingResolves(model.resource);\n\t\tif (pendingResolve) {\n\t\t\tawait pendingResolve;\n\n\t\t\treturn this.canDispose(model);\n\t\t}\n\n\t\t// dirty model: we do not allow to dispose dirty models to prevent\n\t\t// data loss cases. dirty models can only be disposed when they are\n\t\t// either saved or reverted\n\t\tif (model.isDirty()) {\n\t\t\tawait Event.toPromise(model.onDidChangeDirty);\n\n\t\t\treturn this.canDispose(model);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\t// model caches\n\t\tthis.mapResourceToModel.clear();\n\t\tthis.mapResourceToPendingModelResolvers.clear();\n\n\t\t// dispose the dispose listeners\n\t\tdispose(this.mapResourceToDisposeListener.values());\n\t\tthis.mapResourceToDisposeListener.clear();\n\n\t\t// dispose the model change listeners\n\t\tdispose(this.mapResourceToModelListeners.values());\n\t\tthis.mapResourceToModelListeners.clear();\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
