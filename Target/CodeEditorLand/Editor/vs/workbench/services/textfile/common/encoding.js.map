{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/textfile/common/encoding.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { importAMDNodeModule } from \"../../../../amdX.js\";\nimport { isESM } from \"../../../../base/common/amd.js\";\nimport { coalesce } from \"../../../../base/common/arrays.js\";\nimport {\n\tVSBuffer,\n\ttype VSBufferReadable,\n\ttype VSBufferReadableStream,\n} from \"../../../../base/common/buffer.js\";\nimport { CancellationTokenSource } from \"../../../../base/common/cancellation.js\";\nimport {\n\ttype Readable,\n\ttype ReadableStream,\n\tlistenStream,\n\tnewWriteableStream,\n} from \"../../../../base/common/stream.js\";\n\nexport const UTF8 = \"utf8\";\nexport const UTF8_with_bom = \"utf8bom\";\nexport const UTF16be = \"utf16be\";\nexport const UTF16le = \"utf16le\";\n\nexport type UTF_ENCODING =\n\t| typeof UTF8\n\t| typeof UTF8_with_bom\n\t| typeof UTF16be\n\t| typeof UTF16le;\n\nexport function isUTFEncoding(encoding: string): encoding is UTF_ENCODING {\n\treturn [UTF8, UTF8_with_bom, UTF16be, UTF16le].some(\n\t\t(utfEncoding) => utfEncoding === encoding,\n\t);\n}\n\nexport const UTF16be_BOM = [0xfe, 0xff];\nexport const UTF16le_BOM = [0xff, 0xfe];\nexport const UTF8_BOM = [0xef, 0xbb, 0xbf];\n\nconst ZERO_BYTE_DETECTION_BUFFER_MAX_LEN = 512; // number of bytes to look at to decide about a file being binary or not\nconst NO_ENCODING_GUESS_MIN_BYTES = 512; // when not auto guessing the encoding, small number of bytes are enough\nconst AUTO_ENCODING_GUESS_MIN_BYTES = 512 * 8; // with auto guessing we want a lot more content to be read for guessing\nconst AUTO_ENCODING_GUESS_MAX_BYTES = 512 * 128; // set an upper limit for the number of bytes we pass on to jschardet\n\nexport interface IDecodeStreamOptions {\n\tacceptTextOnly: boolean;\n\tguessEncoding: boolean;\n\tcandidateGuessEncodings: string[];\n\tminBytesRequiredForDetection?: number;\n\n\toverwriteEncoding(detectedEncoding: string | null): Promise<string>;\n}\n\nexport interface IDecodeStreamResult {\n\tstream: ReadableStream<string>;\n\tdetected: IDetectedEncodingResult;\n}\n\nexport enum DecodeStreamErrorKind {\n\t/**\n\t * Error indicating that the stream is binary even\n\t * though `acceptTextOnly` was specified.\n\t */\n\tSTREAM_IS_BINARY = 1,\n}\n\nexport class DecodeStreamError extends Error {\n\tconstructor(\n\t\tmessage: string,\n\t\treadonly decodeStreamErrorKind: DecodeStreamErrorKind,\n\t) {\n\t\tsuper(message);\n\t}\n}\n\nexport interface IDecoderStream {\n\twrite(buffer: Uint8Array): string;\n\tend(): string | undefined;\n}\n\nclass DecoderStream implements IDecoderStream {\n\t/**\n\t * This stream will only load iconv-lite lazily if the encoding\n\t * is not UTF-8. This ensures that for most common cases we do\n\t * not pay the price of loading the module from disk.\n\t *\n\t * We still need to be careful when converting UTF-8 to a string\n\t * though because we read the file in chunks of Buffer and thus\n\t * need to decode it via TextDecoder helper that is available\n\t * in browser and node.js environments.\n\t */\n\tstatic async create(encoding: string): Promise<DecoderStream> {\n\t\tlet decoder: IDecoderStream | undefined;\n\t\tif (encoding !== UTF8) {\n\t\t\tconst iconv = await importAMDNodeModule<\n\t\t\t\ttypeof import(\"@vscode/iconv-lite-umd\")\n\t\t\t>(\"@vscode/iconv-lite-umd\", \"lib/iconv-lite-umd.js\");\n\t\t\tdecoder = iconv.getDecoder(toNodeEncoding(encoding));\n\t\t} else {\n\t\t\tconst utf8TextDecoder = new TextDecoder();\n\t\t\tdecoder = {\n\t\t\t\twrite(buffer: Uint8Array): string {\n\t\t\t\t\treturn utf8TextDecoder.decode(buffer, {\n\t\t\t\t\t\t// Signal to TextDecoder that potentially more data is coming\n\t\t\t\t\t\t// and that we are calling `decode` in the end to consume any\n\t\t\t\t\t\t// remainders\n\t\t\t\t\t\tstream: true,\n\t\t\t\t\t});\n\t\t\t\t},\n\n\t\t\t\tend(): string | undefined {\n\t\t\t\t\treturn utf8TextDecoder.decode();\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\treturn new DecoderStream(decoder);\n\t}\n\n\tprivate constructor(private iconvLiteDecoder: IDecoderStream) {}\n\n\twrite(buffer: Uint8Array): string {\n\t\treturn this.iconvLiteDecoder.write(buffer);\n\t}\n\n\tend(): string | undefined {\n\t\treturn this.iconvLiteDecoder.end();\n\t}\n}\n\nexport function toDecodeStream(\n\tsource: VSBufferReadableStream,\n\toptions: IDecodeStreamOptions,\n): Promise<IDecodeStreamResult> {\n\tconst minBytesRequiredForDetection =\n\t\t(options.minBytesRequiredForDetection ?? options.guessEncoding)\n\t\t\t? AUTO_ENCODING_GUESS_MIN_BYTES\n\t\t\t: NO_ENCODING_GUESS_MIN_BYTES;\n\n\treturn new Promise<IDecodeStreamResult>((resolve, reject) => {\n\t\tconst target = newWriteableStream<string>((strings) =>\n\t\t\tstrings.join(\"\"),\n\t\t);\n\n\t\tconst bufferedChunks: VSBuffer[] = [];\n\t\tlet bytesBuffered = 0;\n\n\t\tlet decoder: IDecoderStream | undefined;\n\n\t\tconst cts = new CancellationTokenSource();\n\n\t\tconst createDecoder = async () => {\n\t\t\ttry {\n\t\t\t\t// detect encoding from buffer\n\t\t\t\tconst detected = await detectEncodingFromBuffer(\n\t\t\t\t\t{\n\t\t\t\t\t\tbuffer: VSBuffer.concat(bufferedChunks),\n\t\t\t\t\t\tbytesRead: bytesBuffered,\n\t\t\t\t\t},\n\t\t\t\t\toptions.guessEncoding,\n\t\t\t\t\toptions.candidateGuessEncodings,\n\t\t\t\t);\n\n\t\t\t\t// throw early if the source seems binary and\n\t\t\t\t// we are instructed to only accept text\n\t\t\t\tif (detected.seemsBinary && options.acceptTextOnly) {\n\t\t\t\t\tthrow new DecodeStreamError(\n\t\t\t\t\t\t\"Stream is binary but only text is accepted for decoding\",\n\t\t\t\t\t\tDecodeStreamErrorKind.STREAM_IS_BINARY,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// ensure to respect overwrite of encoding\n\t\t\t\tdetected.encoding = await options.overwriteEncoding(\n\t\t\t\t\tdetected.encoding,\n\t\t\t\t);\n\n\t\t\t\t// decode and write buffered content\n\t\t\t\tdecoder = await DecoderStream.create(detected.encoding);\n\t\t\t\tconst decoded = decoder.write(\n\t\t\t\t\tVSBuffer.concat(bufferedChunks).buffer,\n\t\t\t\t);\n\t\t\t\ttarget.write(decoded);\n\n\t\t\t\tbufferedChunks.length = 0;\n\t\t\t\tbytesBuffered = 0;\n\n\t\t\t\t// signal to the outside our detected encoding and final decoder stream\n\t\t\t\tresolve({\n\t\t\t\t\tstream: target,\n\t\t\t\t\tdetected,\n\t\t\t\t});\n\t\t\t} catch (error) {\n\t\t\t\t// Stop handling anything from the source and target\n\t\t\t\tcts.cancel();\n\t\t\t\ttarget.destroy();\n\n\t\t\t\treject(error);\n\t\t\t}\n\t\t};\n\n\t\tlistenStream(\n\t\t\tsource,\n\t\t\t{\n\t\t\t\tonData: async (chunk) => {\n\t\t\t\t\t// if the decoder is ready, we just write directly\n\t\t\t\t\tif (decoder) {\n\t\t\t\t\t\ttarget.write(decoder.write(chunk.buffer));\n\t\t\t\t\t}\n\n\t\t\t\t\t// otherwise we need to buffer the data until the stream is ready\n\t\t\t\t\telse {\n\t\t\t\t\t\tbufferedChunks.push(chunk);\n\t\t\t\t\t\tbytesBuffered += chunk.byteLength;\n\n\t\t\t\t\t\t// buffered enough data for encoding detection, create stream\n\t\t\t\t\t\tif (bytesBuffered >= minBytesRequiredForDetection) {\n\t\t\t\t\t\t\t// pause stream here until the decoder is ready\n\t\t\t\t\t\t\tsource.pause();\n\n\t\t\t\t\t\t\tawait createDecoder();\n\n\t\t\t\t\t\t\t// resume stream now that decoder is ready but\n\t\t\t\t\t\t\t// outside of this stack to reduce recursion\n\t\t\t\t\t\t\tsetTimeout(() => source.resume());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tonError: (error) => target.error(error), // simply forward to target\n\t\t\t\tonEnd: async () => {\n\t\t\t\t\t// we were still waiting for data to do the encoding\n\t\t\t\t\t// detection. thus, wrap up starting the stream even\n\t\t\t\t\t// without all the data to get things going\n\t\t\t\t\tif (!decoder) {\n\t\t\t\t\t\tawait createDecoder();\n\t\t\t\t\t}\n\n\t\t\t\t\t// end the target with the remainders of the decoder\n\t\t\t\t\ttarget.end(decoder?.end());\n\t\t\t\t},\n\t\t\t},\n\t\t\tcts.token,\n\t\t);\n\t});\n}\n\nexport async function toEncodeReadable(\n\treadable: Readable<string>,\n\tencoding: string,\n\toptions?: { addBOM?: boolean },\n): Promise<VSBufferReadable> {\n\tconst iconv = await importAMDNodeModule<\n\t\ttypeof import(\"@vscode/iconv-lite-umd\")\n\t>(\"@vscode/iconv-lite-umd\", \"lib/iconv-lite-umd.js\");\n\tconst encoder = iconv.getEncoder(toNodeEncoding(encoding), options);\n\n\tlet bytesWritten = false;\n\tlet done = false;\n\n\treturn {\n\t\tread() {\n\t\t\tif (done) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst chunk = readable.read();\n\t\t\tif (typeof chunk !== \"string\") {\n\t\t\t\tdone = true;\n\n\t\t\t\t// If we are instructed to add a BOM but we detect that no\n\t\t\t\t// bytes have been written, we must ensure to return the BOM\n\t\t\t\t// ourselves so that we comply with the contract.\n\t\t\t\tif (!bytesWritten && options?.addBOM) {\n\t\t\t\t\tswitch (encoding) {\n\t\t\t\t\t\tcase UTF8:\n\t\t\t\t\t\tcase UTF8_with_bom:\n\t\t\t\t\t\t\treturn VSBuffer.wrap(Uint8Array.from(UTF8_BOM));\n\t\t\t\t\t\tcase UTF16be:\n\t\t\t\t\t\t\treturn VSBuffer.wrap(Uint8Array.from(UTF16be_BOM));\n\t\t\t\t\t\tcase UTF16le:\n\t\t\t\t\t\t\treturn VSBuffer.wrap(Uint8Array.from(UTF16le_BOM));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst leftovers = encoder.end();\n\t\t\t\tif (leftovers && leftovers.length > 0) {\n\t\t\t\t\tbytesWritten = true;\n\n\t\t\t\t\treturn VSBuffer.wrap(leftovers);\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tbytesWritten = true;\n\n\t\t\treturn VSBuffer.wrap(encoder.write(chunk));\n\t\t},\n\t};\n}\n\nexport async function encodingExists(encoding: string): Promise<boolean> {\n\tconst iconv = await importAMDNodeModule<\n\t\ttypeof import(\"@vscode/iconv-lite-umd\")\n\t>(\"@vscode/iconv-lite-umd\", \"lib/iconv-lite-umd.js\");\n\n\treturn iconv.encodingExists(toNodeEncoding(encoding));\n}\n\nexport function toNodeEncoding(enc: string | null): string {\n\tif (enc === UTF8_with_bom || enc === null) {\n\t\treturn UTF8; // iconv does not distinguish UTF 8 with or without BOM, so we need to help it\n\t}\n\n\treturn enc;\n}\n\nexport function detectEncodingByBOMFromBuffer(\n\tbuffer: VSBuffer | null,\n\tbytesRead: number,\n): typeof UTF8_with_bom | typeof UTF16le | typeof UTF16be | null {\n\tif (!buffer || bytesRead < UTF16be_BOM.length) {\n\t\treturn null;\n\t}\n\n\tconst b0 = buffer.readUInt8(0);\n\tconst b1 = buffer.readUInt8(1);\n\n\t// UTF-16 BE\n\tif (b0 === UTF16be_BOM[0] && b1 === UTF16be_BOM[1]) {\n\t\treturn UTF16be;\n\t}\n\n\t// UTF-16 LE\n\tif (b0 === UTF16le_BOM[0] && b1 === UTF16le_BOM[1]) {\n\t\treturn UTF16le;\n\t}\n\n\tif (bytesRead < UTF8_BOM.length) {\n\t\treturn null;\n\t}\n\n\tconst b2 = buffer.readUInt8(2);\n\n\t// UTF-8\n\tif (b0 === UTF8_BOM[0] && b1 === UTF8_BOM[1] && b2 === UTF8_BOM[2]) {\n\t\treturn UTF8_with_bom;\n\t}\n\n\treturn null;\n}\n\n// we explicitly ignore a specific set of encodings from auto guessing\n// - ASCII: we never want this encoding (most UTF-8 files would happily detect as\n//          ASCII files and then you could not type non-ASCII characters anymore)\n// - UTF-16: we have our own detection logic for UTF-16\n// - UTF-32: we do not support this encoding in VSCode\nconst IGNORE_ENCODINGS = [\"ascii\", \"utf-16\", \"utf-32\"];\n\n/**\n * Guesses the encoding from buffer.\n */\nasync function guessEncodingByBuffer(\n\tbuffer: VSBuffer,\n\tcandidateGuessEncodings?: string[],\n): Promise<string | null> {\n\t// TODO@bpasero TODO@esm: this used to be `dist/jschardet.min.js`, but we are running into an issue that\n\t// https://github.com/aadsm/jschardet/pull/96 mitigates. Long-term we should just add minification\n\t// of dependencies into our build process so that we do not depend on how others are doing it.\n\tconst jschardet = await importAMDNodeModule<typeof import(\"jschardet\")>(\n\t\t\"jschardet\",\n\t\tisESM ? \"dist/jschardet.js\" : \"dist/jschardet.min.js\",\n\t);\n\n\t// ensure to limit buffer for guessing due to https://github.com/aadsm/jschardet/issues/53\n\tconst limitedBuffer = buffer.slice(0, AUTO_ENCODING_GUESS_MAX_BYTES);\n\n\t// before guessing jschardet calls toString('binary') on input if it is a Buffer,\n\t// since we are using it inside browser environment as well we do conversion ourselves\n\t// https://github.com/aadsm/jschardet/blob/v2.1.1/src/index.js#L36-L40\n\tconst binaryString = encodeLatin1(limitedBuffer.buffer);\n\n\t// ensure to convert candidate encodings to jschardet encoding names if provided\n\tif (candidateGuessEncodings) {\n\t\tcandidateGuessEncodings = coalesce(\n\t\t\tcandidateGuessEncodings.map((e) => toJschardetEncoding(e)),\n\t\t);\n\t\tif (candidateGuessEncodings.length === 0) {\n\t\t\tcandidateGuessEncodings = undefined;\n\t\t}\n\t}\n\n\tconst guessed = jschardet.detect(\n\t\tbinaryString,\n\t\tcandidateGuessEncodings\n\t\t\t? { detectEncodings: candidateGuessEncodings }\n\t\t\t: undefined,\n\t);\n\tif (!guessed || !guessed.encoding) {\n\t\treturn null;\n\t}\n\n\tconst enc = guessed.encoding.toLowerCase();\n\tif (IGNORE_ENCODINGS.indexOf(enc) >= 0) {\n\t\treturn null; // see comment above why we ignore some encodings\n\t}\n\n\treturn toIconvLiteEncoding(guessed.encoding);\n}\n\nconst JSCHARDET_TO_ICONV_ENCODINGS: { [name: string]: string } = {\n\tibm866: \"cp866\",\n\tbig5: \"cp950\",\n};\n\nfunction normalizeEncoding(encodingName: string): string {\n\treturn encodingName.replace(/[^a-zA-Z0-9]/g, \"\").toLowerCase();\n}\n\nfunction toIconvLiteEncoding(encodingName: string): string {\n\tconst normalizedEncodingName = normalizeEncoding(encodingName);\n\tconst mapped = JSCHARDET_TO_ICONV_ENCODINGS[normalizedEncodingName];\n\n\treturn mapped || normalizedEncodingName;\n}\n\nfunction toJschardetEncoding(encodingName: string): string | undefined {\n\tconst normalizedEncodingName = normalizeEncoding(encodingName);\n\tconst mapped = GUESSABLE_ENCODINGS[normalizedEncodingName];\n\n\treturn mapped.guessableName;\n}\n\nfunction encodeLatin1(buffer: Uint8Array): string {\n\tlet result = \"\";\n\tfor (let i = 0; i < buffer.length; i++) {\n\t\tresult += String.fromCharCode(buffer[i]);\n\t}\n\n\treturn result;\n}\n\n/**\n * The encodings that are allowed in a settings file don't match the canonical encoding labels specified by WHATWG.\n * See https://encoding.spec.whatwg.org/#names-and-labels\n * Iconv-lite strips all non-alphanumeric characters, but ripgrep doesn't. For backcompat, allow these labels.\n */\nexport function toCanonicalName(enc: string): string {\n\tswitch (enc) {\n\t\tcase \"shiftjis\":\n\t\t\treturn \"shift-jis\";\n\t\tcase \"utf16le\":\n\t\t\treturn \"utf-16le\";\n\t\tcase \"utf16be\":\n\t\t\treturn \"utf-16be\";\n\t\tcase \"big5hkscs\":\n\t\t\treturn \"big5-hkscs\";\n\t\tcase \"eucjp\":\n\t\t\treturn \"euc-jp\";\n\t\tcase \"euckr\":\n\t\t\treturn \"euc-kr\";\n\t\tcase \"koi8r\":\n\t\t\treturn \"koi8-r\";\n\t\tcase \"koi8u\":\n\t\t\treturn \"koi8-u\";\n\t\tcase \"macroman\":\n\t\t\treturn \"x-mac-roman\";\n\t\tcase \"utf8bom\":\n\t\t\treturn \"utf8\";\n\t\tdefault: {\n\t\t\tconst m = enc.match(/windows(\\d+)/);\n\t\t\tif (m) {\n\t\t\t\treturn \"windows-\" + m[1];\n\t\t\t}\n\n\t\t\treturn enc;\n\t\t}\n\t}\n}\n\nexport interface IDetectedEncodingResult {\n\tencoding: string | null;\n\tseemsBinary: boolean;\n}\n\nexport interface IReadResult {\n\tbuffer: VSBuffer | null;\n\tbytesRead: number;\n}\n\nexport function detectEncodingFromBuffer(\n\treadResult: IReadResult,\n\tautoGuessEncoding?: false,\n\tcandidateGuessEncodings?: string[],\n): IDetectedEncodingResult;\nexport function detectEncodingFromBuffer(\n\treadResult: IReadResult,\n\tautoGuessEncoding?: boolean,\n\tcandidateGuessEncodings?: string[],\n): Promise<IDetectedEncodingResult>;\nexport function detectEncodingFromBuffer(\n\t{ buffer, bytesRead }: IReadResult,\n\tautoGuessEncoding?: boolean,\n\tcandidateGuessEncodings?: string[],\n): Promise<IDetectedEncodingResult> | IDetectedEncodingResult {\n\t// Always first check for BOM to find out about encoding\n\tlet encoding = detectEncodingByBOMFromBuffer(buffer, bytesRead);\n\n\t// Detect 0 bytes to see if file is binary or UTF-16 LE/BE\n\t// unless we already know that this file has a UTF-16 encoding\n\tlet seemsBinary = false;\n\tif (encoding !== UTF16be && encoding !== UTF16le && buffer) {\n\t\tlet couldBeUTF16LE = true; // e.g. 0xAA 0x00\n\t\tlet couldBeUTF16BE = true; // e.g. 0x00 0xAA\n\t\tlet containsZeroByte = false;\n\n\t\t// This is a simplified guess to detect UTF-16 BE or LE by just checking if\n\t\t// the first 512 bytes have the 0-byte at a specific location. For UTF-16 LE\n\t\t// this would be the odd byte index and for UTF-16 BE the even one.\n\t\t// Note: this can produce false positives (a binary file that uses a 2-byte\n\t\t// encoding of the same format as UTF-16) and false negatives (a UTF-16 file\n\t\t// that is using 4 bytes to encode a character).\n\t\tfor (\n\t\t\tlet i = 0;\n\t\t\ti < bytesRead && i < ZERO_BYTE_DETECTION_BUFFER_MAX_LEN;\n\t\t\ti++\n\t\t) {\n\t\t\tconst isEndian = i % 2 === 1; // assume 2-byte sequences typical for UTF-16\n\t\t\tconst isZeroByte = buffer.readUInt8(i) === 0;\n\n\t\t\tif (isZeroByte) {\n\t\t\t\tcontainsZeroByte = true;\n\t\t\t}\n\n\t\t\t// UTF-16 LE: expect e.g. 0xAA 0x00\n\t\t\tif (\n\t\t\t\tcouldBeUTF16LE &&\n\t\t\t\t((isEndian && !isZeroByte) || (!isEndian && isZeroByte))\n\t\t\t) {\n\t\t\t\tcouldBeUTF16LE = false;\n\t\t\t}\n\n\t\t\t// UTF-16 BE: expect e.g. 0x00 0xAA\n\t\t\tif (\n\t\t\t\tcouldBeUTF16BE &&\n\t\t\t\t((isEndian && isZeroByte) || (!isEndian && !isZeroByte))\n\t\t\t) {\n\t\t\t\tcouldBeUTF16BE = false;\n\t\t\t}\n\n\t\t\t// Return if this is neither UTF16-LE nor UTF16-BE and thus treat as binary\n\t\t\tif (isZeroByte && !couldBeUTF16LE && !couldBeUTF16BE) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Handle case of 0-byte included\n\t\tif (containsZeroByte) {\n\t\t\tif (couldBeUTF16LE) {\n\t\t\t\tencoding = UTF16le;\n\t\t\t} else if (couldBeUTF16BE) {\n\t\t\t\tencoding = UTF16be;\n\t\t\t} else {\n\t\t\t\tseemsBinary = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Auto guess encoding if configured\n\tif (autoGuessEncoding && !seemsBinary && !encoding && buffer) {\n\t\treturn guessEncodingByBuffer(\n\t\t\tbuffer.slice(0, bytesRead),\n\t\t\tcandidateGuessEncodings,\n\t\t).then((guessedEncoding) => {\n\t\t\treturn {\n\t\t\t\tseemsBinary: false,\n\t\t\t\tencoding: guessedEncoding,\n\t\t\t};\n\t\t});\n\t}\n\n\treturn { seemsBinary, encoding };\n}\n\ntype EncodingsMap = {\n\t[encoding: string]: {\n\t\tlabelLong: string;\n\t\tlabelShort: string;\n\t\torder: number;\n\t\tencodeOnly?: boolean;\n\t\talias?: string;\n\t\tguessableName?: string;\n\t};\n};\n\nexport const SUPPORTED_ENCODINGS: EncodingsMap = {\n\tutf8: {\n\t\tlabelLong: \"UTF-8\",\n\t\tlabelShort: \"UTF-8\",\n\t\torder: 1,\n\t\talias: \"utf8bom\",\n\t\tguessableName: \"UTF-8\",\n\t},\n\tutf8bom: {\n\t\tlabelLong: \"UTF-8 with BOM\",\n\t\tlabelShort: \"UTF-8 with BOM\",\n\t\tencodeOnly: true,\n\t\torder: 2,\n\t\talias: \"utf8\",\n\t},\n\tutf16le: {\n\t\tlabelLong: \"UTF-16 LE\",\n\t\tlabelShort: \"UTF-16 LE\",\n\t\torder: 3,\n\t\tguessableName: \"UTF-16LE\",\n\t},\n\tutf16be: {\n\t\tlabelLong: \"UTF-16 BE\",\n\t\tlabelShort: \"UTF-16 BE\",\n\t\torder: 4,\n\t\tguessableName: \"UTF-16BE\",\n\t},\n\twindows1252: {\n\t\tlabelLong: \"Western (Windows 1252)\",\n\t\tlabelShort: \"Windows 1252\",\n\t\torder: 5,\n\t\tguessableName: \"windows-1252\",\n\t},\n\tiso88591: {\n\t\tlabelLong: \"Western (ISO 8859-1)\",\n\t\tlabelShort: \"ISO 8859-1\",\n\t\torder: 6,\n\t},\n\tiso88593: {\n\t\tlabelLong: \"Western (ISO 8859-3)\",\n\t\tlabelShort: \"ISO 8859-3\",\n\t\torder: 7,\n\t},\n\tiso885915: {\n\t\tlabelLong: \"Western (ISO 8859-15)\",\n\t\tlabelShort: \"ISO 8859-15\",\n\t\torder: 8,\n\t},\n\tmacroman: {\n\t\tlabelLong: \"Western (Mac Roman)\",\n\t\tlabelShort: \"Mac Roman\",\n\t\torder: 9,\n\t},\n\tcp437: {\n\t\tlabelLong: \"DOS (CP 437)\",\n\t\tlabelShort: \"CP437\",\n\t\torder: 10,\n\t},\n\twindows1256: {\n\t\tlabelLong: \"Arabic (Windows 1256)\",\n\t\tlabelShort: \"Windows 1256\",\n\t\torder: 11,\n\t},\n\tiso88596: {\n\t\tlabelLong: \"Arabic (ISO 8859-6)\",\n\t\tlabelShort: \"ISO 8859-6\",\n\t\torder: 12,\n\t},\n\twindows1257: {\n\t\tlabelLong: \"Baltic (Windows 1257)\",\n\t\tlabelShort: \"Windows 1257\",\n\t\torder: 13,\n\t},\n\tiso88594: {\n\t\tlabelLong: \"Baltic (ISO 8859-4)\",\n\t\tlabelShort: \"ISO 8859-4\",\n\t\torder: 14,\n\t},\n\tiso885914: {\n\t\tlabelLong: \"Celtic (ISO 8859-14)\",\n\t\tlabelShort: \"ISO 8859-14\",\n\t\torder: 15,\n\t},\n\twindows1250: {\n\t\tlabelLong: \"Central European (Windows 1250)\",\n\t\tlabelShort: \"Windows 1250\",\n\t\torder: 16,\n\t\tguessableName: \"windows-1250\",\n\t},\n\tiso88592: {\n\t\tlabelLong: \"Central European (ISO 8859-2)\",\n\t\tlabelShort: \"ISO 8859-2\",\n\t\torder: 17,\n\t\tguessableName: \"ISO-8859-2\",\n\t},\n\tcp852: {\n\t\tlabelLong: \"Central European (CP 852)\",\n\t\tlabelShort: \"CP 852\",\n\t\torder: 18,\n\t},\n\twindows1251: {\n\t\tlabelLong: \"Cyrillic (Windows 1251)\",\n\t\tlabelShort: \"Windows 1251\",\n\t\torder: 19,\n\t\tguessableName: \"windows-1251\",\n\t},\n\tcp866: {\n\t\tlabelLong: \"Cyrillic (CP 866)\",\n\t\tlabelShort: \"CP 866\",\n\t\torder: 20,\n\t\tguessableName: \"IBM866\",\n\t},\n\tiso88595: {\n\t\tlabelLong: \"Cyrillic (ISO 8859-5)\",\n\t\tlabelShort: \"ISO 8859-5\",\n\t\torder: 21,\n\t\tguessableName: \"ISO-8859-5\",\n\t},\n\tkoi8r: {\n\t\tlabelLong: \"Cyrillic (KOI8-R)\",\n\t\tlabelShort: \"KOI8-R\",\n\t\torder: 22,\n\t\tguessableName: \"KOI8-R\",\n\t},\n\tkoi8u: {\n\t\tlabelLong: \"Cyrillic (KOI8-U)\",\n\t\tlabelShort: \"KOI8-U\",\n\t\torder: 23,\n\t},\n\tiso885913: {\n\t\tlabelLong: \"Estonian (ISO 8859-13)\",\n\t\tlabelShort: \"ISO 8859-13\",\n\t\torder: 24,\n\t},\n\twindows1253: {\n\t\tlabelLong: \"Greek (Windows 1253)\",\n\t\tlabelShort: \"Windows 1253\",\n\t\torder: 25,\n\t\tguessableName: \"windows-1253\",\n\t},\n\tiso88597: {\n\t\tlabelLong: \"Greek (ISO 8859-7)\",\n\t\tlabelShort: \"ISO 8859-7\",\n\t\torder: 26,\n\t\tguessableName: \"ISO-8859-7\",\n\t},\n\twindows1255: {\n\t\tlabelLong: \"Hebrew (Windows 1255)\",\n\t\tlabelShort: \"Windows 1255\",\n\t\torder: 27,\n\t\tguessableName: \"windows-1255\",\n\t},\n\tiso88598: {\n\t\tlabelLong: \"Hebrew (ISO 8859-8)\",\n\t\tlabelShort: \"ISO 8859-8\",\n\t\torder: 28,\n\t\tguessableName: \"ISO-8859-8\",\n\t},\n\tiso885910: {\n\t\tlabelLong: \"Nordic (ISO 8859-10)\",\n\t\tlabelShort: \"ISO 8859-10\",\n\t\torder: 29,\n\t},\n\tiso885916: {\n\t\tlabelLong: \"Romanian (ISO 8859-16)\",\n\t\tlabelShort: \"ISO 8859-16\",\n\t\torder: 30,\n\t},\n\twindows1254: {\n\t\tlabelLong: \"Turkish (Windows 1254)\",\n\t\tlabelShort: \"Windows 1254\",\n\t\torder: 31,\n\t},\n\tiso88599: {\n\t\tlabelLong: \"Turkish (ISO 8859-9)\",\n\t\tlabelShort: \"ISO 8859-9\",\n\t\torder: 32,\n\t},\n\twindows1258: {\n\t\tlabelLong: \"Vietnamese (Windows 1258)\",\n\t\tlabelShort: \"Windows 1258\",\n\t\torder: 33,\n\t},\n\tgbk: {\n\t\tlabelLong: \"Simplified Chinese (GBK)\",\n\t\tlabelShort: \"GBK\",\n\t\torder: 34,\n\t},\n\tgb18030: {\n\t\tlabelLong: \"Simplified Chinese (GB18030)\",\n\t\tlabelShort: \"GB18030\",\n\t\torder: 35,\n\t},\n\tcp950: {\n\t\tlabelLong: \"Traditional Chinese (Big5)\",\n\t\tlabelShort: \"Big5\",\n\t\torder: 36,\n\t\tguessableName: \"Big5\",\n\t},\n\tbig5hkscs: {\n\t\tlabelLong: \"Traditional Chinese (Big5-HKSCS)\",\n\t\tlabelShort: \"Big5-HKSCS\",\n\t\torder: 37,\n\t},\n\tshiftjis: {\n\t\tlabelLong: \"Japanese (Shift JIS)\",\n\t\tlabelShort: \"Shift JIS\",\n\t\torder: 38,\n\t\tguessableName: \"SHIFT_JIS\",\n\t},\n\teucjp: {\n\t\tlabelLong: \"Japanese (EUC-JP)\",\n\t\tlabelShort: \"EUC-JP\",\n\t\torder: 39,\n\t\tguessableName: \"EUC-JP\",\n\t},\n\teuckr: {\n\t\tlabelLong: \"Korean (EUC-KR)\",\n\t\tlabelShort: \"EUC-KR\",\n\t\torder: 40,\n\t\tguessableName: \"EUC-KR\",\n\t},\n\twindows874: {\n\t\tlabelLong: \"Thai (Windows 874)\",\n\t\tlabelShort: \"Windows 874\",\n\t\torder: 41,\n\t},\n\tiso885911: {\n\t\tlabelLong: \"Latin/Thai (ISO 8859-11)\",\n\t\tlabelShort: \"ISO 8859-11\",\n\t\torder: 42,\n\t},\n\tkoi8ru: {\n\t\tlabelLong: \"Cyrillic (KOI8-RU)\",\n\t\tlabelShort: \"KOI8-RU\",\n\t\torder: 43,\n\t},\n\tkoi8t: {\n\t\tlabelLong: \"Tajik (KOI8-T)\",\n\t\tlabelShort: \"KOI8-T\",\n\t\torder: 44,\n\t},\n\tgb2312: {\n\t\tlabelLong: \"Simplified Chinese (GB 2312)\",\n\t\tlabelShort: \"GB 2312\",\n\t\torder: 45,\n\t\tguessableName: \"GB2312\",\n\t},\n\tcp865: {\n\t\tlabelLong: \"Nordic DOS (CP 865)\",\n\t\tlabelShort: \"CP 865\",\n\t\torder: 46,\n\t},\n\tcp850: {\n\t\tlabelLong: \"Western European DOS (CP 850)\",\n\t\tlabelShort: \"CP 850\",\n\t\torder: 47,\n\t},\n};\n\nexport const GUESSABLE_ENCODINGS: EncodingsMap = (() => {\n\tconst guessableEncodings: EncodingsMap = {};\n\tfor (const encoding in SUPPORTED_ENCODINGS) {\n\t\tif (SUPPORTED_ENCODINGS[encoding].guessableName) {\n\t\t\tguessableEncodings[encoding] = SUPPORTED_ENCODINGS[encoding];\n\t\t}\n\t}\n\n\treturn guessableEncodings;\n})();\n"],
  "mappings": "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",
  "names": ["DecodeStreamErrorKind"]
}
