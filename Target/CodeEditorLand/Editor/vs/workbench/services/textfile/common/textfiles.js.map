{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/textfile/common/textfiles.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport {\n\tVSBuffer,\n\ttype VSBufferReadable,\n\ttype VSBufferReadableStream,\n} from \"../../../../base/common/buffer.js\";\nimport type { CancellationToken } from \"../../../../base/common/cancellation.js\";\nimport type { Event } from \"../../../../base/common/event.js\";\nimport type { IDisposable } from \"../../../../base/common/lifecycle.js\";\nimport type { ReadableStream } from \"../../../../base/common/stream.js\";\nimport {\n\tareFunctions,\n\tisUndefinedOrNull,\n} from \"../../../../base/common/types.js\";\nimport type { URI } from \"../../../../base/common/uri.js\";\nimport type {\n\tITextBufferFactory,\n\tITextModel,\n\tITextSnapshot,\n} from \"../../../../editor/common/model.js\";\nimport type { ITextEditorModel } from \"../../../../editor/common/services/resolverService.js\";\nimport {\n\tFileOperationError,\n\tFileOperationResult,\n\ttype IBaseFileStatWithMetadata,\n\ttype IFileReadLimits,\n\ttype IFileStatWithMetadata,\n\ttype IReadFileStreamOptions,\n\ttype IWriteFileOptions,\n} from \"../../../../platform/files/common/files.js\";\nimport { createDecorator } from \"../../../../platform/instantiation/common/instantiation.js\";\nimport type {\n\tIProgress,\n\tIProgressStep,\n} from \"../../../../platform/progress/common/progress.js\";\nimport type {\n\tIRevertOptions,\n\tISaveOptions,\n\tSaveReason,\n} from \"../../../common/editor.js\";\nimport type { IUntitledTextEditorModelManager } from \"../../untitled/common/untitledTextEditorService.js\";\nimport type {\n\tIWorkingCopy,\n\tIWorkingCopySaveEvent,\n} from \"../../workingCopy/common/workingCopy.js\";\nimport type { IFileOperationUndoRedoInfo } from \"../../workingCopy/common/workingCopyFileService.js\";\n\nexport const ITextFileService =\n\tcreateDecorator<ITextFileService>(\"textFileService\");\n\nexport interface ITextFileService extends IDisposable {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Access to the manager of text file editor models providing further\n\t * methods to work with them.\n\t */\n\treadonly files: ITextFileEditorModelManager;\n\n\t/**\n\t * Access to the manager of untitled text editor models providing further\n\t * methods to work with them.\n\t */\n\treadonly untitled: IUntitledTextEditorModelManager;\n\n\t/**\n\t * Helper to determine encoding for resources.\n\t */\n\treadonly encoding: IResourceEncodings;\n\n\t/**\n\t * A resource is dirty if it has unsaved changes or is an untitled file not yet saved.\n\t *\n\t * @param resource the resource to check for being dirty\n\t */\n\tisDirty(resource: URI): boolean;\n\n\t/**\n\t * Saves the resource.\n\t *\n\t * @param resource the resource to save\n\t * @param options optional save options\n\t * @return Path of the saved resource or undefined if canceled.\n\t */\n\tsave(\n\t\tresource: URI,\n\t\toptions?: ITextFileSaveOptions,\n\t): Promise<URI | undefined>;\n\n\t/**\n\t * Saves the provided resource asking the user for a file name or using the provided one.\n\t *\n\t * @param resource the resource to save as.\n\t * @param targetResource the optional target to save to.\n\t * @param options optional save options\n\t * @return Path of the saved resource or undefined if canceled.\n\t */\n\tsaveAs(\n\t\tresource: URI,\n\t\ttargetResource?: URI,\n\t\toptions?: ITextFileSaveAsOptions,\n\t): Promise<URI | undefined>;\n\n\t/**\n\t * Reverts the provided resource.\n\t *\n\t * @param resource the resource of the file to revert.\n\t * @param force to force revert even when the file is not dirty\n\t */\n\trevert(resource: URI, options?: IRevertOptions): Promise<void>;\n\n\t/**\n\t * Read the contents of a file identified by the resource.\n\t */\n\tread(\n\t\tresource: URI,\n\t\toptions?: IReadTextFileOptions,\n\t): Promise<ITextFileContent>;\n\n\t/**\n\t * Read the contents of a file identified by the resource as stream.\n\t */\n\treadStream(\n\t\tresource: URI,\n\t\toptions?: IReadTextFileOptions,\n\t): Promise<ITextFileStreamContent>;\n\n\t/**\n\t * Update a file with given contents.\n\t */\n\twrite(\n\t\tresource: URI,\n\t\tvalue: string | ITextSnapshot,\n\t\toptions?: IWriteTextFileOptions,\n\t): Promise<IFileStatWithMetadata>;\n\n\t/**\n\t * Create files. If the file exists it will be overwritten with the contents if\n\t * the options enable to overwrite.\n\t */\n\tcreate(\n\t\toperations: {\n\t\t\tresource: URI;\n\t\t\tvalue?: string | ITextSnapshot;\n\t\t\toptions?: { overwrite?: boolean };\n\t\t}[],\n\t\tundoInfo?: IFileOperationUndoRedoInfo,\n\t): Promise<readonly IFileStatWithMetadata[]>;\n\n\t/**\n\t * Returns the readable that uses the appropriate encoding. This method should\n\t * be used whenever a `string` or `ITextSnapshot` is being persisted to the\n\t * file system.\n\t */\n\tgetEncodedReadable(\n\t\tresource: URI,\n\t\tvalue: ITextSnapshot,\n\t\toptions?: IWriteTextFileOptions,\n\t): Promise<VSBufferReadable>;\n\tgetEncodedReadable(\n\t\tresource: URI,\n\t\tvalue: string,\n\t\toptions?: IWriteTextFileOptions,\n\t): Promise<VSBuffer>;\n\tgetEncodedReadable(\n\t\tresource: URI,\n\t\tvalue?: ITextSnapshot,\n\t\toptions?: IWriteTextFileOptions,\n\t): Promise<VSBufferReadable | undefined>;\n\tgetEncodedReadable(\n\t\tresource: URI,\n\t\tvalue?: string,\n\t\toptions?: IWriteTextFileOptions,\n\t): Promise<VSBuffer | undefined>;\n\tgetEncodedReadable(\n\t\tresource: URI,\n\t\tvalue?: string | ITextSnapshot,\n\t\toptions?: IWriteTextFileOptions,\n\t): Promise<VSBuffer | VSBufferReadable | undefined>;\n\n\t/**\n\t * Returns a stream of strings that uses the appropriate encoding. This method should\n\t * be used whenever a `VSBufferReadableStream` is being loaded from the file system.\n\t *\n\t * Will throw an error if `acceptTextOnly: true` for resources that seem to be binary.\n\t */\n\tgetDecodedStream(\n\t\tresource: URI,\n\t\tvalue: VSBufferReadableStream,\n\t\toptions?: IReadTextFileEncodingOptions,\n\t): Promise<ReadableStream<string>>;\n}\n\nexport interface IReadTextFileEncodingOptions {\n\t/**\n\t * The optional encoding parameter allows to specify the desired encoding when resolving\n\t * the contents of the file.\n\t */\n\treadonly encoding?: string;\n\n\t/**\n\t * The optional guessEncoding parameter allows to guess encoding from content of the file.\n\t */\n\treadonly autoGuessEncoding?: boolean;\n\n\t/**\n\t * The optional candidateGuessEncodings parameter limits the allowed encodings to guess from.\n\t */\n\treadonly candidateGuessEncodings?: string[];\n\n\t/**\n\t * The optional acceptTextOnly parameter allows to fail this request early if the file\n\t * contents are not textual.\n\t */\n\treadonly acceptTextOnly?: boolean;\n}\n\nexport interface IReadTextFileOptions\n\textends IReadTextFileEncodingOptions,\n\t\tIReadFileStreamOptions {}\n\nexport interface IWriteTextFileOptions extends IWriteFileOptions {\n\t/**\n\t * The encoding to use when updating a file.\n\t */\n\treadonly encoding?: string;\n\n\t/**\n\t * Whether to write to the file as elevated (admin) user. When setting this option a prompt will\n\t * ask the user to authenticate as super user.\n\t */\n\treadonly writeElevated?: boolean;\n}\n\nexport enum TextFileOperationResult {\n\tFILE_IS_BINARY = 0,\n}\n\nexport class TextFileOperationError extends FileOperationError {\n\tstatic isTextFileOperationError(\n\t\tobj: unknown,\n\t): obj is TextFileOperationError {\n\t\treturn (\n\t\t\tobj instanceof Error &&\n\t\t\t!isUndefinedOrNull(\n\t\t\t\t(obj as TextFileOperationError).textFileOperationResult,\n\t\t\t)\n\t\t);\n\t}\n\n\toverride readonly options?: IReadTextFileOptions & IWriteTextFileOptions;\n\n\tconstructor(\n\t\tmessage: string,\n\t\tpublic textFileOperationResult: TextFileOperationResult,\n\t\toptions?: IReadTextFileOptions & IWriteTextFileOptions,\n\t) {\n\t\tsuper(message, FileOperationResult.FILE_OTHER_ERROR);\n\n\t\tthis.options = options;\n\t}\n}\n\nexport interface IResourceEncodings {\n\tgetPreferredReadEncoding(resource: URI): Promise<IResourceEncoding>;\n\tgetPreferredWriteEncoding(\n\t\tresource: URI,\n\t\tpreferredEncoding?: string,\n\t): Promise<IResourceEncoding>;\n}\n\nexport interface IResourceEncoding {\n\treadonly encoding: string;\n\treadonly hasBOM: boolean;\n}\n\n/**\n * The save error handler can be installed on the text file editor model to install code that executes when save errors occur.\n */\nexport interface ISaveErrorHandler {\n\t/**\n\t * Called whenever a save fails.\n\t */\n\tonSaveError(\n\t\terror: Error,\n\t\tmodel: ITextFileEditorModel,\n\t\toptions: ITextFileSaveAsOptions,\n\t): void;\n}\n\n/**\n * States the text file editor model can be in.\n */\nexport enum TextFileEditorModelState {\n\t/**\n\t * A model is saved.\n\t */\n\tSAVED = 0,\n\n\t/**\n\t * A model is dirty.\n\t */\n\tDIRTY = 1,\n\n\t/**\n\t * A model is currently being saved but this operation has not completed yet.\n\t */\n\tPENDING_SAVE = 2,\n\n\t/**\n\t * A model is in conflict mode when changes cannot be saved because the\n\t * underlying file has changed. Models in conflict mode are always dirty.\n\t */\n\tCONFLICT = 3,\n\n\t/**\n\t * A model is in orphan state when the underlying file has been deleted.\n\t */\n\tORPHAN = 4,\n\n\t/**\n\t * Any error that happens during a save that is not causing the CONFLICT state.\n\t * Models in error mode are always dirty.\n\t */\n\tERROR = 5,\n}\n\nexport enum TextFileResolveReason {\n\tEDITOR = 1,\n\tREFERENCE = 2,\n\tOTHER = 3,\n}\n\ninterface IBaseTextFileContent extends IBaseFileStatWithMetadata {\n\t/**\n\t * The encoding of the content if known.\n\t */\n\treadonly encoding: string;\n}\n\nexport interface ITextFileContent extends IBaseTextFileContent {\n\t/**\n\t * The content of a text file.\n\t */\n\treadonly value: string;\n}\n\nexport interface ITextFileStreamContent extends IBaseTextFileContent {\n\t/**\n\t * The line grouped content of a text file.\n\t */\n\treadonly value: ITextBufferFactory;\n}\n\nexport interface ITextFileEditorModelResolveOrCreateOptions\n\textends ITextFileResolveOptions {\n\t/**\n\t * The language id to use for the model text content.\n\t */\n\treadonly languageId?: string;\n\n\t/**\n\t * The encoding to use when resolving the model text content.\n\t */\n\treadonly encoding?: string;\n\n\t/**\n\t * If the model was already resolved before, allows to trigger\n\t * a reload of it to fetch the latest contents.\n\t */\n\treadonly reload?: {\n\t\t/**\n\t\t * Controls whether the reload happens in the background\n\t\t * or whether `resolve` will await the reload to happen.\n\t\t */\n\t\treadonly async: boolean;\n\t};\n}\n\nexport interface ITextFileSaveEvent extends ITextFileEditorModelSaveEvent {\n\t/**\n\t * The model that was saved.\n\t */\n\treadonly model: ITextFileEditorModel;\n}\n\nexport interface ITextFileResolveEvent {\n\t/**\n\t * The model that was resolved.\n\t */\n\treadonly model: ITextFileEditorModel;\n\n\t/**\n\t * The reason why the model was resolved.\n\t */\n\treadonly reason: TextFileResolveReason;\n}\n\nexport interface ITextFileSaveParticipantContext {\n\t/**\n\t * The reason why the save was triggered.\n\t */\n\treadonly reason: SaveReason;\n\n\t/**\n\t * Only applies to when a text file was saved as, for\n\t * example when starting with untitled and saving. This\n\t * provides access to the initial resource the text\n\t * file had before.\n\t */\n\treadonly savedFrom?: URI;\n}\n\nexport interface ITextFileSaveParticipant {\n\t/**\n\t * Participate in a save of a model. Allows to change the model\n\t * before it is being saved to disk.\n\t */\n\tparticipate(\n\t\tmodel: ITextFileEditorModel,\n\t\tcontext: ITextFileSaveParticipantContext,\n\t\tprogress: IProgress<IProgressStep>,\n\t\ttoken: CancellationToken,\n\t): Promise<void>;\n}\n\nexport interface ITextFileEditorModelManager {\n\treadonly onDidCreate: Event<ITextFileEditorModel>;\n\treadonly onDidResolve: Event<ITextFileResolveEvent>;\n\treadonly onDidChangeDirty: Event<ITextFileEditorModel>;\n\treadonly onDidChangeReadonly: Event<ITextFileEditorModel>;\n\treadonly onDidRemove: Event<URI>;\n\treadonly onDidChangeOrphaned: Event<ITextFileEditorModel>;\n\treadonly onDidChangeEncoding: Event<ITextFileEditorModel>;\n\treadonly onDidSaveError: Event<ITextFileEditorModel>;\n\treadonly onDidSave: Event<ITextFileSaveEvent>;\n\treadonly onDidRevert: Event<ITextFileEditorModel>;\n\n\t/**\n\t * Access to all text file editor models in memory.\n\t */\n\treadonly models: ITextFileEditorModel[];\n\n\t/**\n\t * Allows to configure the error handler that is called on save errors.\n\t */\n\tsaveErrorHandler: ISaveErrorHandler;\n\n\t/**\n\t * Returns the text file editor model for the provided resource\n\t * or undefined if none.\n\t */\n\tget(resource: URI): ITextFileEditorModel | undefined;\n\n\t/**\n\t * Allows to resolve a text file model from disk.\n\t */\n\tresolve(\n\t\tresource: URI,\n\t\toptions?: ITextFileEditorModelResolveOrCreateOptions,\n\t): Promise<ITextFileEditorModel>;\n\n\t/**\n\t * Adds a participant for saving text file models.\n\t */\n\taddSaveParticipant(participant: ITextFileSaveParticipant): IDisposable;\n\n\t/**\n\t * Runs the registered save participants on the provided model.\n\t */\n\trunSaveParticipants(\n\t\tmodel: ITextFileEditorModel,\n\t\tcontext: ITextFileSaveParticipantContext,\n\t\tprogress: IProgress<IProgressStep>,\n\t\ttoken: CancellationToken,\n\t): Promise<void>;\n\n\t/**\n\t * Waits for the model to be ready to be disposed. There may be conditions\n\t * under which the model cannot be disposed, e.g. when it is dirty. Once the\n\t * promise is settled, it is safe to dispose the model.\n\t */\n\tcanDispose(model: ITextFileEditorModel): true | Promise<true>;\n}\n\nexport interface ITextFileSaveOptions extends ISaveOptions {\n\t/**\n\t * Save the file with an attempt to unlock it.\n\t */\n\treadonly writeUnlock?: boolean;\n\n\t/**\n\t * Save the file with elevated privileges.\n\t *\n\t * Note: This may not be supported in all environments.\n\t */\n\treadonly writeElevated?: boolean;\n\n\t/**\n\t * Allows to write to a file even if it has been modified on disk.\n\t */\n\treadonly ignoreModifiedSince?: boolean;\n\n\t/**\n\t * If set, will bubble up the error to the caller instead of handling it.\n\t */\n\treadonly ignoreErrorHandler?: boolean;\n}\n\nexport interface ITextFileSaveAsOptions extends ITextFileSaveOptions {\n\t/**\n\t * Optional URI of the resource the text file is saved from if known.\n\t */\n\treadonly from?: URI;\n\n\t/**\n\t * Optional URI to use as suggested file path to save as.\n\t */\n\treadonly suggestedTarget?: URI;\n}\n\nexport interface ITextFileResolveOptions {\n\t/**\n\t * The contents to use for the model if known. If not\n\t * provided, the contents will be retrieved from the\n\t * underlying resource or backup if present.\n\t */\n\treadonly contents?: ITextBufferFactory;\n\n\t/**\n\t * Go to file bypassing any cache of the model if any.\n\t */\n\treadonly forceReadFromFile?: boolean;\n\n\t/**\n\t * Allow to resolve a model even if we think it is a binary file.\n\t */\n\treadonly allowBinary?: boolean;\n\n\t/**\n\t * Context why the model is being resolved.\n\t */\n\treadonly reason?: TextFileResolveReason;\n\n\t/**\n\t * If provided, the size of the file will be checked against the limits\n\t * and an error will be thrown if any limit is exceeded.\n\t */\n\treadonly limits?: IFileReadLimits;\n}\n\nexport enum EncodingMode {\n\t/**\n\t * Instructs the encoding support to encode the object with the provided encoding\n\t */\n\tEncode = 0,\n\n\t/**\n\t * Instructs the encoding support to decode the object with the provided encoding\n\t */\n\tDecode = 1,\n}\n\nexport interface IEncodingSupport {\n\t/**\n\t * Gets the encoding of the object if known.\n\t */\n\tgetEncoding(): string | undefined;\n\n\t/**\n\t * Sets the encoding for the object for saving.\n\t */\n\tsetEncoding(encoding: string, mode: EncodingMode): Promise<void>;\n}\n\nexport interface ILanguageSupport {\n\t/**\n\t * Sets the language id of the object.\n\t */\n\tsetLanguageId(languageId: string, source?: string): void;\n}\n\nexport interface ITextFileEditorModelSaveEvent extends IWorkingCopySaveEvent {\n\t/**\n\t * The resolved stat from the save operation.\n\t */\n\treadonly stat: IFileStatWithMetadata;\n}\n\nexport interface ITextFileEditorModel\n\textends ITextEditorModel,\n\t\tIEncodingSupport,\n\t\tILanguageSupport,\n\t\tIWorkingCopy {\n\treadonly onDidSave: Event<ITextFileEditorModelSaveEvent>;\n\treadonly onDidSaveError: Event<void>;\n\treadonly onDidChangeOrphaned: Event<void>;\n\treadonly onDidChangeReadonly: Event<void>;\n\treadonly onDidChangeEncoding: Event<void>;\n\n\thasState(state: TextFileEditorModelState): boolean;\n\tjoinState(state: TextFileEditorModelState.PENDING_SAVE): Promise<void>;\n\n\tupdatePreferredEncoding(encoding: string | undefined): void;\n\n\tsave(options?: ITextFileSaveAsOptions): Promise<boolean>;\n\trevert(options?: IRevertOptions): Promise<void>;\n\n\tresolve(options?: ITextFileResolveOptions): Promise<void>;\n\n\tisDirty(): this is IResolvedTextFileEditorModel;\n\n\tgetLanguageId(): string | undefined;\n\n\tisResolved(): this is IResolvedTextFileEditorModel;\n}\n\nexport function isTextFileEditorModel(\n\tmodel: ITextEditorModel,\n): model is ITextFileEditorModel {\n\tconst candidate = model as ITextFileEditorModel;\n\n\treturn areFunctions(\n\t\tcandidate.setEncoding,\n\t\tcandidate.getEncoding,\n\t\tcandidate.save,\n\t\tcandidate.revert,\n\t\tcandidate.isDirty,\n\t\tcandidate.getLanguageId,\n\t);\n}\n\nexport interface IResolvedTextFileEditorModel extends ITextFileEditorModel {\n\treadonly textEditorModel: ITextModel;\n\n\tcreateSnapshot(): ITextSnapshot;\n}\n\nexport function snapshotToString(snapshot: ITextSnapshot): string {\n\tconst chunks: string[] = [];\n\n\tlet chunk: string | null;\n\twhile (typeof (chunk = snapshot.read()) === \"string\") {\n\t\tchunks.push(chunk);\n\t}\n\n\treturn chunks.join(\"\");\n}\n\nexport function stringToSnapshot(value: string): ITextSnapshot {\n\tlet done = false;\n\n\treturn {\n\t\tread(): string | null {\n\t\t\tif (!done) {\n\t\t\t\tdone = true;\n\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t},\n\t};\n}\n\nexport function toBufferOrReadable(value: string): VSBuffer;\nexport function toBufferOrReadable(value: ITextSnapshot): VSBufferReadable;\nexport function toBufferOrReadable(\n\tvalue: string | ITextSnapshot,\n): VSBuffer | VSBufferReadable;\nexport function toBufferOrReadable(\n\tvalue: string | ITextSnapshot | undefined,\n): VSBuffer | VSBufferReadable | undefined;\nexport function toBufferOrReadable(\n\tvalue: string | ITextSnapshot | undefined,\n): VSBuffer | VSBufferReadable | undefined {\n\tif (typeof value === \"undefined\") {\n\t\treturn undefined;\n\t}\n\n\tif (typeof value === \"string\") {\n\t\treturn VSBuffer.fromString(value);\n\t}\n\n\treturn {\n\t\tread: () => {\n\t\t\tconst chunk = value.read();\n\t\t\tif (typeof chunk === \"string\") {\n\t\t\t\treturn VSBuffer.fromString(chunk);\n\t\t\t}\n\n\t\t\treturn null;\n\t\t},\n\t};\n}\n"],
  "mappings": ";;AAKA;AAAA,EACC;AAAA,OAGM;AAKP;AAAA,EACC;AAAA,EACA;AAAA,OACM;AAQP;AAAA,EACC;AAAA,EACA;AAAA,OAMM;AACP,SAAS,uBAAuB;AAiBzB,MAAM,mBACZ,gBAAkC,iBAAiB;AA0L7C,IAAK,0BAAL,kBAAKA,6BAAL;AACN,EAAAA,kDAAA,oBAAiB,KAAjB;AADW,SAAAA;AAAA,GAAA;AAIL,MAAM,+BAA+B,mBAAmB;AAAA,EAc9D,YACC,SACO,yBACP,SACC;AACD,UAAM,SAAS,oBAAoB,gBAAgB;AAH5C;AAKP,SAAK,UAAU;AAAA,EAChB;AAAA,EAxQD,OAkP+D;AAAA;AAAA;AAAA,EAC9D,OAAO,yBACN,KACgC;AAChC,WACC,eAAe,SACf,CAAC;AAAA,MACC,IAA+B;AAAA,IACjC;AAAA,EAEF;AAAA,EAEkB;AAWnB;AAgCO,IAAK,2BAAL,kBAAKC,8BAAL;AAIN,EAAAA,oDAAA,WAAQ,KAAR;AAKA,EAAAA,oDAAA,WAAQ,KAAR;AAKA,EAAAA,oDAAA,kBAAe,KAAf;AAMA,EAAAA,oDAAA,cAAW,KAAX;AAKA,EAAAA,oDAAA,YAAS,KAAT;AAMA,EAAAA,oDAAA,WAAQ,KAAR;AA/BW,SAAAA;AAAA,GAAA;AAkCL,IAAK,wBAAL,kBAAKC,2BAAL;AACN,EAAAA,8CAAA,YAAS,KAAT;AACA,EAAAA,8CAAA,eAAY,KAAZ;AACA,EAAAA,8CAAA,WAAQ,KAAR;AAHW,SAAAA;AAAA,GAAA;AAgOL,IAAK,eAAL,kBAAKC,kBAAL;AAIN,EAAAA,4BAAA,YAAS,KAAT;AAKA,EAAAA,4BAAA,YAAS,KAAT;AATW,SAAAA;AAAA,GAAA;AAkEL,SAAS,sBACf,OACgC;AAChC,QAAM,YAAY;AAElB,SAAO;AAAA,IACN,UAAU;AAAA,IACV,UAAU;AAAA,IACV,UAAU;AAAA,IACV,UAAU;AAAA,IACV,UAAU;AAAA,IACV,UAAU;AAAA,EACX;AACD;AAbgB;AAqBT,SAAS,iBAAiB,UAAiC;AACjE,QAAM,SAAmB,CAAC;AAE1B,MAAI;AACJ,SAAO,QAAQ,QAAQ,SAAS,KAAK,OAAO,UAAU;AACrD,WAAO,KAAK,KAAK;AAAA,EAClB;AAEA,SAAO,OAAO,KAAK,EAAE;AACtB;AATgB;AAWT,SAAS,iBAAiB,OAA8B;AAC9D,MAAI,OAAO;AAEX,SAAO;AAAA,IACN,OAAsB;AACrB,UAAI,CAAC,MAAM;AACV,eAAO;AAEP,eAAO;AAAA,MACR;AAEA,aAAO;AAAA,IACR;AAAA,EACD;AACD;AAdgB;AAwBT,SAAS,mBACf,OAC0C;AAC1C,MAAI,OAAO,UAAU,aAAa;AACjC,WAAO;AAAA,EACR;AAEA,MAAI,OAAO,UAAU,UAAU;AAC9B,WAAO,SAAS,WAAW,KAAK;AAAA,EACjC;AAEA,SAAO;AAAA,IACN,MAAM,6BAAM;AACX,YAAM,QAAQ,MAAM,KAAK;AACzB,UAAI,OAAO,UAAU,UAAU;AAC9B,eAAO,SAAS,WAAW,KAAK;AAAA,MACjC;AAEA,aAAO;AAAA,IACR,GAPM;AAAA,EAQP;AACD;AArBgB;",
  "names": ["TextFileOperationResult", "TextFileEditorModelState", "TextFileResolveReason", "EncodingMode"]
}
