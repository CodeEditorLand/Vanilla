{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/textfile/common/textfiles.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from '../../../../base/common/uri.js';\nimport { Event } from '../../../../base/common/event.js';\nimport { IDisposable } from '../../../../base/common/lifecycle.js';\nimport { ISaveOptions, IRevertOptions, SaveReason } from '../../../common/editor.js';\nimport { ReadableStream } from '../../../../base/common/stream.js';\nimport { IBaseFileStatWithMetadata, IFileStatWithMetadata, IWriteFileOptions, FileOperationError, FileOperationResult, IReadFileStreamOptions, IFileReadLimits } from '../../../../platform/files/common/files.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ITextEditorModel } from '../../../../editor/common/services/resolverService.js';\nimport { ITextBufferFactory, ITextModel, ITextSnapshot } from '../../../../editor/common/model.js';\nimport { VSBuffer, VSBufferReadable, VSBufferReadableStream } from '../../../../base/common/buffer.js';\nimport { areFunctions, isUndefinedOrNull } from '../../../../base/common/types.js';\nimport { IWorkingCopy, IWorkingCopySaveEvent } from '../../workingCopy/common/workingCopy.js';\nimport { IUntitledTextEditorModelManager } from '../../untitled/common/untitledTextEditorService.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { IProgress, IProgressStep } from '../../../../platform/progress/common/progress.js';\nimport { IFileOperationUndoRedoInfo } from '../../workingCopy/common/workingCopyFileService.js';\n\nexport const ITextFileService = createDecorator<ITextFileService>('textFileService');\n\nexport interface ITextFileService extends IDisposable {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Access to the manager of text file editor models providing further\n\t * methods to work with them.\n\t */\n\treadonly files: ITextFileEditorModelManager;\n\n\t/**\n\t * Access to the manager of untitled text editor models providing further\n\t * methods to work with them.\n\t */\n\treadonly untitled: IUntitledTextEditorModelManager;\n\n\t/**\n\t * Helper to determine encoding for resources.\n\t */\n\treadonly encoding: IResourceEncodings;\n\n\t/**\n\t * A resource is dirty if it has unsaved changes or is an untitled file not yet saved.\n\t *\n\t * @param resource the resource to check for being dirty\n\t */\n\tisDirty(resource: URI): boolean;\n\n\t/**\n\t * Saves the resource.\n\t *\n\t * @param resource the resource to save\n\t * @param options optional save options\n\t * @return Path of the saved resource or undefined if canceled.\n\t */\n\tsave(resource: URI, options?: ITextFileSaveOptions): Promise<URI | undefined>;\n\n\t/**\n\t * Saves the provided resource asking the user for a file name or using the provided one.\n\t *\n\t * @param resource the resource to save as.\n\t * @param targetResource the optional target to save to.\n\t * @param options optional save options\n\t * @return Path of the saved resource or undefined if canceled.\n\t */\n\tsaveAs(resource: URI, targetResource?: URI, options?: ITextFileSaveAsOptions): Promise<URI | undefined>;\n\n\t/**\n\t * Reverts the provided resource.\n\t *\n\t * @param resource the resource of the file to revert.\n\t * @param force to force revert even when the file is not dirty\n\t */\n\trevert(resource: URI, options?: IRevertOptions): Promise<void>;\n\n\t/**\n\t * Read the contents of a file identified by the resource.\n\t */\n\tread(resource: URI, options?: IReadTextFileOptions): Promise<ITextFileContent>;\n\n\t/**\n\t * Read the contents of a file identified by the resource as stream.\n\t */\n\treadStream(resource: URI, options?: IReadTextFileOptions): Promise<ITextFileStreamContent>;\n\n\t/**\n\t * Update a file with given contents.\n\t */\n\twrite(resource: URI, value: string | ITextSnapshot, options?: IWriteTextFileOptions): Promise<IFileStatWithMetadata>;\n\n\t/**\n\t * Create files. If the file exists it will be overwritten with the contents if\n\t * the options enable to overwrite.\n\t */\n\tcreate(operations: { resource: URI; value?: string | ITextSnapshot; options?: { overwrite?: boolean } }[], undoInfo?: IFileOperationUndoRedoInfo): Promise<readonly IFileStatWithMetadata[]>;\n\n\t/**\n\t * Returns the readable that uses the appropriate encoding. This method should\n\t * be used whenever a `string` or `ITextSnapshot` is being persisted to the\n\t * file system.\n\t */\n\tgetEncodedReadable(resource: URI, value: ITextSnapshot, options?: IWriteTextFileOptions): Promise<VSBufferReadable>;\n\tgetEncodedReadable(resource: URI, value: string, options?: IWriteTextFileOptions): Promise<VSBuffer>;\n\tgetEncodedReadable(resource: URI, value?: ITextSnapshot, options?: IWriteTextFileOptions): Promise<VSBufferReadable | undefined>;\n\tgetEncodedReadable(resource: URI, value?: string, options?: IWriteTextFileOptions): Promise<VSBuffer | undefined>;\n\tgetEncodedReadable(resource: URI, value?: string | ITextSnapshot, options?: IWriteTextFileOptions): Promise<VSBuffer | VSBufferReadable | undefined>;\n\n\t/**\n\t * Returns a stream of strings that uses the appropriate encoding. This method should\n\t * be used whenever a `VSBufferReadableStream` is being loaded from the file system.\n\t *\n\t * Will throw an error if `acceptTextOnly: true` for resources that seem to be binary.\n\t */\n\tgetDecodedStream(resource: URI, value: VSBufferReadableStream, options?: IReadTextFileEncodingOptions): Promise<ReadableStream<string>>;\n}\n\nexport interface IReadTextFileEncodingOptions {\n\n\t/**\n\t * The optional encoding parameter allows to specify the desired encoding when resolving\n\t * the contents of the file.\n\t */\n\treadonly encoding?: string;\n\n\t/**\n\t * The optional guessEncoding parameter allows to guess encoding from content of the file.\n\t */\n\treadonly autoGuessEncoding?: boolean;\n\n\t/**\n\t * The optional candidateGuessEncodings parameter limits the allowed encodings to guess from.\n\t */\n\treadonly candidateGuessEncodings?: string[];\n\n\t/**\n\t * The optional acceptTextOnly parameter allows to fail this request early if the file\n\t * contents are not textual.\n\t */\n\treadonly acceptTextOnly?: boolean;\n}\n\nexport interface IReadTextFileOptions extends IReadTextFileEncodingOptions, IReadFileStreamOptions { }\n\nexport interface IWriteTextFileOptions extends IWriteFileOptions {\n\n\t/**\n\t * The encoding to use when updating a file.\n\t */\n\treadonly encoding?: string;\n\n\t/**\n\t * Whether to write to the file as elevated (admin) user. When setting this option a prompt will\n\t * ask the user to authenticate as super user.\n\t */\n\treadonly writeElevated?: boolean;\n}\n\nexport const enum TextFileOperationResult {\n\tFILE_IS_BINARY\n}\n\nexport class TextFileOperationError extends FileOperationError {\n\n\tstatic isTextFileOperationError(obj: unknown): obj is TextFileOperationError {\n\t\treturn obj instanceof Error && !isUndefinedOrNull((obj as TextFileOperationError).textFileOperationResult);\n\t}\n\n\toverride readonly options?: IReadTextFileOptions & IWriteTextFileOptions;\n\n\tconstructor(\n\t\tmessage: string,\n\t\tpublic textFileOperationResult: TextFileOperationResult,\n\t\toptions?: IReadTextFileOptions & IWriteTextFileOptions\n\t) {\n\t\tsuper(message, FileOperationResult.FILE_OTHER_ERROR);\n\n\t\tthis.options = options;\n\t}\n}\n\nexport interface IResourceEncodings {\n\tgetPreferredReadEncoding(resource: URI): Promise<IResourceEncoding>;\n\tgetPreferredWriteEncoding(resource: URI, preferredEncoding?: string): Promise<IResourceEncoding>;\n}\n\nexport interface IResourceEncoding {\n\treadonly encoding: string;\n\treadonly hasBOM: boolean;\n}\n\n/**\n * The save error handler can be installed on the text file editor model to install code that executes when save errors occur.\n */\nexport interface ISaveErrorHandler {\n\n\t/**\n\t * Called whenever a save fails.\n\t */\n\tonSaveError(error: Error, model: ITextFileEditorModel, options: ITextFileSaveAsOptions): void;\n}\n\n/**\n * States the text file editor model can be in.\n */\nexport const enum TextFileEditorModelState {\n\n\t/**\n\t * A model is saved.\n\t */\n\tSAVED,\n\n\t/**\n\t * A model is dirty.\n\t */\n\tDIRTY,\n\n\t/**\n\t * A model is currently being saved but this operation has not completed yet.\n\t */\n\tPENDING_SAVE,\n\n\t/**\n\t * A model is in conflict mode when changes cannot be saved because the\n\t * underlying file has changed. Models in conflict mode are always dirty.\n\t */\n\tCONFLICT,\n\n\t/**\n\t * A model is in orphan state when the underlying file has been deleted.\n\t */\n\tORPHAN,\n\n\t/**\n\t * Any error that happens during a save that is not causing the CONFLICT state.\n\t * Models in error mode are always dirty.\n\t */\n\tERROR\n}\n\nexport const enum TextFileResolveReason {\n\tEDITOR = 1,\n\tREFERENCE = 2,\n\tOTHER = 3\n}\n\ninterface IBaseTextFileContent extends IBaseFileStatWithMetadata {\n\n\t/**\n\t * The encoding of the content if known.\n\t */\n\treadonly encoding: string;\n}\n\nexport interface ITextFileContent extends IBaseTextFileContent {\n\n\t/**\n\t * The content of a text file.\n\t */\n\treadonly value: string;\n}\n\nexport interface ITextFileStreamContent extends IBaseTextFileContent {\n\n\t/**\n\t * The line grouped content of a text file.\n\t */\n\treadonly value: ITextBufferFactory;\n}\n\nexport interface ITextFileEditorModelResolveOrCreateOptions extends ITextFileResolveOptions {\n\n\t/**\n\t * The language id to use for the model text content.\n\t */\n\treadonly languageId?: string;\n\n\t/**\n\t * The encoding to use when resolving the model text content.\n\t */\n\treadonly encoding?: string;\n\n\t/**\n\t * If the model was already resolved before, allows to trigger\n\t * a reload of it to fetch the latest contents.\n\t */\n\treadonly reload?: {\n\n\t\t/**\n\t\t * Controls whether the reload happens in the background\n\t\t * or whether `resolve` will await the reload to happen.\n\t\t */\n\t\treadonly async: boolean;\n\t};\n}\n\nexport interface ITextFileSaveEvent extends ITextFileEditorModelSaveEvent {\n\n\t/**\n\t * The model that was saved.\n\t */\n\treadonly model: ITextFileEditorModel;\n}\n\nexport interface ITextFileResolveEvent {\n\n\t/**\n\t * The model that was resolved.\n\t */\n\treadonly model: ITextFileEditorModel;\n\n\t/**\n\t * The reason why the model was resolved.\n\t */\n\treadonly reason: TextFileResolveReason;\n}\n\nexport interface ITextFileSaveParticipantContext {\n\n\t/**\n\t * The reason why the save was triggered.\n\t */\n\treadonly reason: SaveReason;\n\n\t/**\n\t * Only applies to when a text file was saved as, for\n\t * example when starting with untitled and saving. This\n\t * provides access to the initial resource the text\n\t * file had before.\n\t */\n\treadonly savedFrom?: URI;\n}\n\nexport interface ITextFileSaveParticipant {\n\n\t/**\n\t * Participate in a save of a model. Allows to change the model\n\t * before it is being saved to disk.\n\t */\n\tparticipate(\n\t\tmodel: ITextFileEditorModel,\n\t\tcontext: ITextFileSaveParticipantContext,\n\t\tprogress: IProgress<IProgressStep>,\n\t\ttoken: CancellationToken\n\t): Promise<void>;\n}\n\nexport interface ITextFileEditorModelManager {\n\n\treadonly onDidCreate: Event<ITextFileEditorModel>;\n\treadonly onDidResolve: Event<ITextFileResolveEvent>;\n\treadonly onDidChangeDirty: Event<ITextFileEditorModel>;\n\treadonly onDidChangeReadonly: Event<ITextFileEditorModel>;\n\treadonly onDidRemove: Event<URI>;\n\treadonly onDidChangeOrphaned: Event<ITextFileEditorModel>;\n\treadonly onDidChangeEncoding: Event<ITextFileEditorModel>;\n\treadonly onDidSaveError: Event<ITextFileEditorModel>;\n\treadonly onDidSave: Event<ITextFileSaveEvent>;\n\treadonly onDidRevert: Event<ITextFileEditorModel>;\n\n\t/**\n\t * Access to all text file editor models in memory.\n\t */\n\treadonly models: ITextFileEditorModel[];\n\n\t/**\n\t * Allows to configure the error handler that is called on save errors.\n\t */\n\tsaveErrorHandler: ISaveErrorHandler;\n\n\t/**\n\t * Returns the text file editor model for the provided resource\n\t * or undefined if none.\n\t */\n\tget(resource: URI): ITextFileEditorModel | undefined;\n\n\t/**\n\t * Allows to resolve a text file model from disk.\n\t */\n\tresolve(resource: URI, options?: ITextFileEditorModelResolveOrCreateOptions): Promise<ITextFileEditorModel>;\n\n\t/**\n\t * Adds a participant for saving text file models.\n\t */\n\taddSaveParticipant(participant: ITextFileSaveParticipant): IDisposable;\n\n\t/**\n\t * Runs the registered save participants on the provided model.\n\t */\n\trunSaveParticipants(model: ITextFileEditorModel, context: ITextFileSaveParticipantContext, progress: IProgress<IProgressStep>, token: CancellationToken): Promise<void>;\n\n\t/**\n\t * Waits for the model to be ready to be disposed. There may be conditions\n\t * under which the model cannot be disposed, e.g. when it is dirty. Once the\n\t * promise is settled, it is safe to dispose the model.\n\t */\n\tcanDispose(model: ITextFileEditorModel): true | Promise<true>;\n}\n\nexport interface ITextFileSaveOptions extends ISaveOptions {\n\n\t/**\n\t * Save the file with an attempt to unlock it.\n\t */\n\treadonly writeUnlock?: boolean;\n\n\t/**\n\t * Save the file with elevated privileges.\n\t *\n\t * Note: This may not be supported in all environments.\n\t */\n\treadonly writeElevated?: boolean;\n\n\t/**\n\t * Allows to write to a file even if it has been modified on disk.\n\t */\n\treadonly ignoreModifiedSince?: boolean;\n\n\t/**\n\t * If set, will bubble up the error to the caller instead of handling it.\n\t */\n\treadonly ignoreErrorHandler?: boolean;\n}\n\nexport interface ITextFileSaveAsOptions extends ITextFileSaveOptions {\n\n\t/**\n\t * Optional URI of the resource the text file is saved from if known.\n\t */\n\treadonly from?: URI;\n\n\t/**\n\t * Optional URI to use as suggested file path to save as.\n\t */\n\treadonly suggestedTarget?: URI;\n}\n\nexport interface ITextFileResolveOptions {\n\n\t/**\n\t * The contents to use for the model if known. If not\n\t * provided, the contents will be retrieved from the\n\t * underlying resource or backup if present.\n\t */\n\treadonly contents?: ITextBufferFactory;\n\n\t/**\n\t * Go to file bypassing any cache of the model if any.\n\t */\n\treadonly forceReadFromFile?: boolean;\n\n\t/**\n\t * Allow to resolve a model even if we think it is a binary file.\n\t */\n\treadonly allowBinary?: boolean;\n\n\t/**\n\t * Context why the model is being resolved.\n\t */\n\treadonly reason?: TextFileResolveReason;\n\n\t/**\n\t * If provided, the size of the file will be checked against the limits\n\t * and an error will be thrown if any limit is exceeded.\n\t */\n\treadonly limits?: IFileReadLimits;\n}\n\nexport const enum EncodingMode {\n\n\t/**\n\t * Instructs the encoding support to encode the object with the provided encoding\n\t */\n\tEncode,\n\n\t/**\n\t * Instructs the encoding support to decode the object with the provided encoding\n\t */\n\tDecode\n}\n\nexport interface IEncodingSupport {\n\n\t/**\n\t * Gets the encoding of the object if known.\n\t */\n\tgetEncoding(): string | undefined;\n\n\t/**\n\t * Sets the encoding for the object for saving.\n\t */\n\tsetEncoding(encoding: string, mode: EncodingMode): Promise<void>;\n}\n\nexport interface ILanguageSupport {\n\n\t/**\n\t * Sets the language id of the object.\n\t */\n\tsetLanguageId(languageId: string, source?: string): void;\n}\n\nexport interface ITextFileEditorModelSaveEvent extends IWorkingCopySaveEvent {\n\n\t/**\n\t * The resolved stat from the save operation.\n\t */\n\treadonly stat: IFileStatWithMetadata;\n}\n\nexport interface ITextFileEditorModel extends ITextEditorModel, IEncodingSupport, ILanguageSupport, IWorkingCopy {\n\n\treadonly onDidSave: Event<ITextFileEditorModelSaveEvent>;\n\treadonly onDidSaveError: Event<void>;\n\treadonly onDidChangeOrphaned: Event<void>;\n\treadonly onDidChangeReadonly: Event<void>;\n\treadonly onDidChangeEncoding: Event<void>;\n\n\thasState(state: TextFileEditorModelState): boolean;\n\tjoinState(state: TextFileEditorModelState.PENDING_SAVE): Promise<void>;\n\n\tupdatePreferredEncoding(encoding: string | undefined): void;\n\n\tsave(options?: ITextFileSaveAsOptions): Promise<boolean>;\n\trevert(options?: IRevertOptions): Promise<void>;\n\n\tresolve(options?: ITextFileResolveOptions): Promise<void>;\n\n\tisDirty(): this is IResolvedTextFileEditorModel;\n\n\tgetLanguageId(): string | undefined;\n\n\tisResolved(): this is IResolvedTextFileEditorModel;\n}\n\nexport function isTextFileEditorModel(model: ITextEditorModel): model is ITextFileEditorModel {\n\tconst candidate = model as ITextFileEditorModel;\n\n\treturn areFunctions(candidate.setEncoding, candidate.getEncoding, candidate.save, candidate.revert, candidate.isDirty, candidate.getLanguageId);\n}\n\nexport interface IResolvedTextFileEditorModel extends ITextFileEditorModel {\n\n\treadonly textEditorModel: ITextModel;\n\n\tcreateSnapshot(): ITextSnapshot;\n}\n\nexport function snapshotToString(snapshot: ITextSnapshot): string {\n\tconst chunks: string[] = [];\n\n\tlet chunk: string | null;\n\twhile (typeof (chunk = snapshot.read()) === 'string') {\n\t\tchunks.push(chunk);\n\t}\n\n\treturn chunks.join('');\n}\n\nexport function stringToSnapshot(value: string): ITextSnapshot {\n\tlet done = false;\n\n\treturn {\n\t\tread(): string | null {\n\t\t\tif (!done) {\n\t\t\t\tdone = true;\n\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t};\n}\n\nexport function toBufferOrReadable(value: string): VSBuffer;\nexport function toBufferOrReadable(value: ITextSnapshot): VSBufferReadable;\nexport function toBufferOrReadable(value: string | ITextSnapshot): VSBuffer | VSBufferReadable;\nexport function toBufferOrReadable(value: string | ITextSnapshot | undefined): VSBuffer | VSBufferReadable | undefined;\nexport function toBufferOrReadable(value: string | ITextSnapshot | undefined): VSBuffer | VSBufferReadable | undefined {\n\tif (typeof value === 'undefined') {\n\t\treturn undefined;\n\t}\n\n\tif (typeof value === 'string') {\n\t\treturn VSBuffer.fromString(value);\n\t}\n\n\treturn {\n\t\tread: () => {\n\t\t\tconst chunk = value.read();\n\t\t\tif (typeof chunk === 'string') {\n\t\t\t\treturn VSBuffer.fromString(chunk);\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t};\n}\n"],
  "mappings": ";;AAKA,SAAS,WAAW;AACpB,SAAS,aAAa;AACtB,SAAS,mBAAmB;AAC5B,SAAS,cAAc,gBAAgB,kBAAkB;AACzD,SAAS,sBAAsB;AAC/B,SAAS,2BAA2B,uBAAuB,mBAAmB,oBAAoB,qBAAqB,wBAAwB,uBAAuB;AACtK,SAAS,uBAAuB;AAChC,SAAS,wBAAwB;AACjC,SAAS,oBAAoB,YAAY,qBAAqB;AAC9D,SAAS,UAAU,kBAAkB,8BAA8B;AACnE,SAAS,cAAc,yBAAyB;AAChD,SAAS,cAAc,6BAA6B;AACpD,SAAS,uCAAuC;AAChD,SAAS,yBAAyB;AAClC,SAAS,WAAW,qBAAqB;AACzC,SAAS,kCAAkC;AAEpC,MAAM,mBAAmB,gBAAkC,iBAAiB;AA2I5E,IAAW,0BAAX,kBAAWA,6BAAX;AACN,EAAAA,kDAAA;AADiB,SAAAA;AAAA,GAAA;AAIX,MAAM,+BAA+B,mBAAmB;AAAA,EAQ9D,YACC,SACO,yBACP,SACC;AACD,UAAM,SAAS,oBAAoB,gBAAgB;AAH5C;AAKP,SAAK,UAAU;AAAA,EAChB;AAAA,EArLD,OAqK+D;AAAA;AAAA;AAAA,EAE9D,OAAO,yBAAyB,KAA6C;AAC5E,WAAO,eAAe,SAAS,CAAC,kBAAmB,IAA+B,uBAAuB;AAAA,EAC1G;AAAA,EAEkB;AAWnB;AA0BO,IAAW,2BAAX,kBAAWC,8BAAX;AAKN,EAAAA,oDAAA;AAKA,EAAAA,oDAAA;AAKA,EAAAA,oDAAA;AAMA,EAAAA,oDAAA;AAKA,EAAAA,oDAAA;AAMA,EAAAA,oDAAA;AAhCiB,SAAAA;AAAA,GAAA;AAmCX,IAAW,wBAAX,kBAAWC,2BAAX;AACN,EAAAA,8CAAA,YAAS,KAAT;AACA,EAAAA,8CAAA,eAAY,KAAZ;AACA,EAAAA,8CAAA,WAAQ,KAAR;AAHiB,SAAAA;AAAA,GAAA;AAoOX,IAAW,eAAX,kBAAWC,kBAAX;AAKN,EAAAA,4BAAA;AAKA,EAAAA,4BAAA;AAViB,SAAAA;AAAA,GAAA;AAmEX,SAAS,sBAAsB,OAAwD;AAC7F,QAAM,YAAY;AAElB,SAAO,aAAa,UAAU,aAAa,UAAU,aAAa,UAAU,MAAM,UAAU,QAAQ,UAAU,SAAS,UAAU,aAAa;AAC/I;AAJgB;AAaT,SAAS,iBAAiB,UAAiC;AACjE,QAAM,SAAmB,CAAC;AAE1B,MAAI;AACJ,SAAO,QAAQ,QAAQ,SAAS,KAAK,OAAO,UAAU;AACrD,WAAO,KAAK,KAAK;AAAA,EAClB;AAEA,SAAO,OAAO,KAAK,EAAE;AACtB;AATgB;AAWT,SAAS,iBAAiB,OAA8B;AAC9D,MAAI,OAAO;AAEX,SAAO;AAAA,IACN,OAAsB;AACrB,UAAI,CAAC,MAAM;AACV,eAAO;AAEP,eAAO;AAAA,MACR;AAEA,aAAO;AAAA,IACR;AAAA,EACD;AACD;AAdgB;AAoBT,SAAS,mBAAmB,OAAoF;AACtH,MAAI,OAAO,UAAU,aAAa;AACjC,WAAO;AAAA,EACR;AAEA,MAAI,OAAO,UAAU,UAAU;AAC9B,WAAO,SAAS,WAAW,KAAK;AAAA,EACjC;AAEA,SAAO;AAAA,IACN,MAAM,6BAAM;AACX,YAAM,QAAQ,MAAM,KAAK;AACzB,UAAI,OAAO,UAAU,UAAU;AAC9B,eAAO,SAAS,WAAW,KAAK;AAAA,MACjC;AAEA,aAAO;AAAA,IACR,GAPM;AAAA,EAQP;AACD;AAnBgB;",
  "names": ["TextFileOperationResult", "TextFileEditorModelState", "TextFileResolveReason", "EncodingMode"]
}
