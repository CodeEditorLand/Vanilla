import t from"assert";import"../../../../../platform/instantiation/common/instantiation.js";import{TextFileEditorModel as l}from"../../common/textFileEditorModel.js";import{EncodingMode as S,TextFileEditorModelState as v,snapshotToString as T,isTextFileEditorModel as C}from"../../common/textfiles.js";import{createFileEditorInput as D,workbenchInstantiationService as F,TestServiceAccessor as I,TestReadonlyTextFileEditorModel as q,getLastResolvedFileStat as y}from"../../../../test/browser/workbenchTestServices.js";import{ensureNoDisposablesAreLeakedInTestSuite as _,toResource as n}from"../../../../../base/test/common/utils.js";import"../../common/textFileEditorModelManager.js";import{FileOperationResult as g,FileOperationError as h,NotModifiedSinceFileOperationError as P}from"../../../../../platform/files/common/files.js";import{DeferredPromise as R,timeout as w}from"../../../../../base/common/async.js";import{assertIsDefined as p}from"../../../../../base/common/types.js";import{createTextBufferFactory as c}from"../../../../../editor/common/model/textModel.js";import{DisposableStore as b,toDisposable as N}from"../../../../../base/common/lifecycle.js";import{SaveReason as m,SaveSourceRegistry as O}from"../../../../common/editor.js";import{isEqual as U}from"../../../../../base/common/resources.js";import{UTF16be as L}from"../../common/encoding.js";import{isWeb as A}from"../../../../../base/common/platform.js";import{URI as V}from"../../../../../base/common/uri.js";suite("Files - TextFileEditorModel",()=>{function E(e){const i=y(e);return i?i.mtime:-1}const a=new b;let d,o,k;setup(()=>{d=F(void 0,a),o=d.createInstance(I),k=o.fileService.getContent(),a.add(o.textFileService.files),a.add(N(()=>o.fileService.setContent(k)))}),teardown(async()=>{for(const e of o.textFileService.files.models)e.dispose();a.clear()}),test("basic events",async function(){const e=a.add(d.createInstance(l,n.call(this,"/path/index_async.txt"),"utf8",void 0));o.workingCopyService.testUnregisterWorkingCopy(e);let i=0;a.add(e.onDidResolve(()=>i++)),await e.resolve(),t.strictEqual(i,1);let r=0;a.add(e.onDidChangeContent(()=>r++));let s=0;a.add(e.onDidChangeDirty(()=>s++)),e.updateTextEditorModel(c("bar")),t.strictEqual(r,1),t.strictEqual(s,1),e.updateTextEditorModel(c("foo")),t.strictEqual(r,2),t.strictEqual(s,1),await e.revert(),t.strictEqual(s,2)}),test("isTextFileEditorModel",async function(){const e=d.createInstance(l,n.call(this,"/path/index_async.txt"),"utf8",void 0);t.strictEqual(C(e),!0),e.dispose()}),test("save",async function(){const e=d.createInstance(l,n.call(this,"/path/index_async.txt"),"utf8",void 0);await e.resolve(),t.strictEqual(o.workingCopyService.dirtyCount,0);let i;a.add(e.onDidSave(u=>i=u)),await e.save(),t.ok(!i),e.updateTextEditorModel(c("bar")),t.ok(E(e)<=Date.now()),t.ok(e.hasState(v.DIRTY)),t.ok(e.isModified()),t.strictEqual(o.workingCopyService.dirtyCount,1),t.strictEqual(o.workingCopyService.isDirty(e.resource,e.typeId),!0);let r=!1;a.add(o.workingCopyService.onDidChangeDirty(u=>{u.resource.toString()===e.resource.toString()&&(r=!0)}));const s=O.registerSource("testSource","Hello Save"),f=e.save({reason:m.AUTO,source:s});t.ok(e.hasState(v.PENDING_SAVE)),await Promise.all([f,e.joinState(v.PENDING_SAVE)]),t.ok(e.hasState(v.SAVED)),t.ok(!e.isDirty()),t.ok(!e.isModified()),t.ok(i),t.ok(i.stat),t.strictEqual(i.reason,m.AUTO),t.strictEqual(i.source,s),t.ok(r),t.strictEqual(o.workingCopyService.dirtyCount,0),t.strictEqual(o.workingCopyService.isDirty(e.resource,e.typeId),!1),i=void 0,await e.save({force:!0}),t.ok(i),e.dispose(),t.ok(!o.modelService.getModel(e.resource))}),test("save - touching also emits saved event",async function(){const e=d.createInstance(l,n.call(this,"/path/index_async.txt"),"utf8",void 0);await e.resolve();let i=!1;a.add(e.onDidSave(()=>i=!0));let r=!1;a.add(o.workingCopyService.onDidChangeDirty(s=>{s.resource.toString()===e.resource.toString()&&(r=!0)})),await e.save({force:!0}),t.ok(i),t.ok(!r),e.dispose(),t.ok(!o.modelService.getModel(e.resource))}),test("save - touching with error turns model dirty",async function(){const e=d.createInstance(l,n.call(this,"/path/index_async.txt"),"utf8",void 0);await e.resolve();let i=!1;a.add(e.onDidSaveError(()=>i=!0));let r=!1;a.add(e.onDidSave(()=>r=!0)),o.fileService.writeShouldThrowError=new Error("failed to write");try{await e.save({force:!0}),t.ok(e.hasState(v.ERROR)),t.ok(e.isDirty()),t.ok(e.isModified()),t.ok(i),t.strictEqual(o.workingCopyService.dirtyCount,1),t.strictEqual(o.workingCopyService.isDirty(e.resource,e.typeId),!0)}finally{o.fileService.writeShouldThrowError=void 0}await e.save({force:!0}),t.ok(r),t.strictEqual(e.isDirty(),!1),e.dispose(),t.ok(!o.modelService.getModel(e.resource))}),test("save - returns false when save fails",async function(){const e=d.createInstance(l,n.call(this,"/path/index_async.txt"),"utf8",void 0);await e.resolve(),o.fileService.writeShouldThrowError=new Error("failed to write");try{const r=await e.save({force:!0});t.strictEqual(r,!1)}finally{o.fileService.writeShouldThrowError=void 0}const i=await e.save({force:!0});t.strictEqual(i,!0),e.dispose(),t.ok(!o.modelService.getModel(e.resource))}),test("save error (generic)",async function(){const e=d.createInstance(l,n.call(this,"/path/index_async.txt"),"utf8",void 0);await e.resolve(),e.updateTextEditorModel(c("bar"));let i=!1;a.add(e.onDidSaveError(()=>i=!0)),o.fileService.writeShouldThrowError=new Error("failed to write");try{const r=e.save();t.ok(e.hasState(v.PENDING_SAVE)),await r,t.ok(e.hasState(v.ERROR)),t.ok(e.isDirty()),t.ok(e.isModified()),t.ok(i),t.strictEqual(o.workingCopyService.dirtyCount,1),t.strictEqual(o.workingCopyService.isDirty(e.resource,e.typeId),!0),e.dispose()}finally{o.fileService.writeShouldThrowError=void 0}}),test("save error (conflict)",async function(){const e=d.createInstance(l,n.call(this,"/path/index_async.txt"),"utf8",void 0);await e.resolve(),e.updateTextEditorModel(c("bar"));let i=!1;a.add(e.onDidSaveError(()=>i=!0)),o.fileService.writeShouldThrowError=new h("save conflict",g.FILE_MODIFIED_SINCE);try{const r=e.save();t.ok(e.hasState(v.PENDING_SAVE)),await r,t.ok(e.hasState(v.CONFLICT)),t.ok(e.isDirty()),t.ok(e.isModified()),t.ok(i),t.strictEqual(o.workingCopyService.dirtyCount,1),t.strictEqual(o.workingCopyService.isDirty(e.resource,e.typeId),!0),e.dispose()}finally{o.fileService.writeShouldThrowError=void 0}}),test("setEncoding - encode",async function(){const e=a.add(d.createInstance(l,n.call(this,"/path/index_async.txt"),"utf8",void 0));let i=!1;a.add(e.onDidChangeEncoding(()=>i=!0)),await e.setEncoding("utf8",S.Encode),t.strictEqual(E(e),-1),t.ok(!i),await e.setEncoding("utf16",S.Encode),t.ok(i),t.ok(E(e)<=Date.now())}),test("setEncoding - decode",async function(){let e=a.add(d.createInstance(l,n.call(this,"/path/index_async.txt"),"utf8",void 0));o.workingCopyService.testUnregisterWorkingCopy(e),await e.setEncoding("utf16",S.Decode),e=o.workingCopyService.get(e),t.ok(e.isResolved())}),test("setEncoding - decode dirty file saves first",async function(){const e=a.add(d.createInstance(l,n.call(this,"/path/index_async.txt"),"utf8",void 0));o.workingCopyService.testUnregisterWorkingCopy(e),await e.resolve(),e.updateTextEditorModel(c("bar")),t.strictEqual(e.isDirty(),!0),await e.setEncoding("utf16",S.Decode),t.strictEqual(e.isDirty(),!1)}),test("encoding updates with language based configuration",async function(){const e="text-file-model-test";a.add(o.languageService.registerLanguage({id:e})),o.testConfigurationService.setOverrideIdentifiers("files.encoding",[e]);const i=a.add(d.createInstance(l,n.call(this,"/path/index_async.txt"),"utf8",void 0));o.workingCopyService.testUnregisterWorkingCopy(i),await i.resolve();const r=new R;a.add(o.workingCopyService.onDidRegister(s=>{U(s.resource,i.resource)&&r.complete(i)})),o.testConfigurationService.setUserConfiguration("files.encoding",L),i.setLanguageId(e),await r.p}),test("create with language",async function(){const e="text-file-model-test";a.add(o.languageService.registerLanguage({id:e}));const i=d.createInstance(l,n.call(this,"/path/index_async.txt"),"utf8",e);await i.resolve(),t.strictEqual(i.textEditorModel.getLanguageId(),e),i.dispose(),t.ok(!o.modelService.getModel(i.resource))}),test("disposes when underlying model is destroyed",async function(){const e=d.createInstance(l,n.call(this,"/path/index_async.txt"),"utf8",void 0);await e.resolve(),e.textEditorModel.dispose(),t.ok(e.isDisposed())}),test("Resolve does not trigger save",async function(){const e=d.createInstance(l,n.call(this,"/path/index.txt"),"utf8",void 0);t.ok(e.hasState(v.SAVED)),a.add(e.onDidSave(()=>t.fail())),a.add(e.onDidChangeDirty(()=>t.fail())),await e.resolve(),t.ok(e.isResolved()),e.dispose(),t.ok(!o.modelService.getModel(e.resource))}),test("Resolve returns dirty model as long as model is dirty",async function(){const e=a.add(d.createInstance(l,n.call(this,"/path/index_async.txt"),"utf8",void 0));await e.resolve(),e.updateTextEditorModel(c("foo")),t.ok(e.isDirty()),t.ok(e.hasState(v.DIRTY)),await e.resolve(),t.ok(e.isDirty())}),test("Resolve with contents",async function(){const e=d.createInstance(l,n.call(this,"/path/index_async.txt"),"utf8",void 0);await e.resolve({contents:c("Hello World")}),t.strictEqual(e.textEditorModel?.getValue(),"Hello World"),t.strictEqual(e.isDirty(),!0),await e.resolve({contents:c("Hello Changes")}),t.strictEqual(e.textEditorModel?.getValue(),"Hello Changes"),t.strictEqual(e.isDirty(),!0),await e.textEditorModel.undo(),t.ok(e.isDirty()),e.dispose(),t.ok(!o.modelService.getModel(e.resource))}),test("Revert",async function(){let e=0,i=a.add(d.createInstance(l,n.call(this,"/path/index_async.txt"),"utf8",void 0));a.add(i.onDidRevert(()=>e++));let r=!1;a.add(o.workingCopyService.onDidChangeDirty(s=>{s.resource.toString()===i.resource.toString()&&(r=!0)})),await i.resolve(),i.updateTextEditorModel(c("foo")),t.ok(i.isDirty()),t.ok(i.isModified()),t.strictEqual(o.workingCopyService.dirtyCount,1),t.strictEqual(o.workingCopyService.isDirty(i.resource,i.typeId),!0),o.workingCopyService.testUnregisterWorkingCopy(i),await i.revert(),i=o.workingCopyService.get(i),t.strictEqual(i.isDirty(),!1),t.strictEqual(i.isModified(),!1),t.strictEqual(e,1),t.ok(r),t.strictEqual(o.workingCopyService.dirtyCount,0),t.strictEqual(o.workingCopyService.isDirty(i.resource,i.typeId),!1)}),test("Revert (soft)",async function(){let e=0;const i=a.add(d.createInstance(l,n.call(this,"/path/index_async.txt"),"utf8",void 0));a.add(i.onDidRevert(()=>e++));let r=!1;a.add(o.workingCopyService.onDidChangeDirty(s=>{s.resource.toString()===i.resource.toString()&&(r=!0)})),await i.resolve(),i.updateTextEditorModel(c("foo")),t.ok(i.isDirty()),t.ok(i.isModified()),t.strictEqual(o.workingCopyService.dirtyCount,1),t.strictEqual(o.workingCopyService.isDirty(i.resource,i.typeId),!0),await i.revert({soft:!0}),t.strictEqual(i.isDirty(),!1),t.strictEqual(i.isModified(),!1),t.strictEqual(i.textEditorModel.getValue(),"foo"),t.strictEqual(e,1),t.ok(r),t.strictEqual(o.workingCopyService.dirtyCount,0),t.strictEqual(o.workingCopyService.isDirty(i.resource,i.typeId),!1)}),test("Undo to saved state turns model non-dirty",async function(){const e=a.add(d.createInstance(l,n.call(this,"/path/index_async.txt"),"utf8",void 0));await e.resolve(),e.updateTextEditorModel(c("Hello Text")),t.ok(e.isDirty()),await e.textEditorModel.undo(),t.ok(!e.isDirty())}),test("Resolve and undo turns model dirty",async function(){const e=a.add(d.createInstance(l,n.call(this,"/path/index_async.txt"),"utf8",void 0));await e.resolve(),o.fileService.setContent("Hello Change"),await e.resolve(),await e.textEditorModel.undo(),t.ok(e.isDirty()),t.strictEqual(o.workingCopyService.dirtyCount,1),t.strictEqual(o.workingCopyService.isDirty(e.resource,e.typeId),!0)}),test("Update Dirty",async function(){let e=0;const i=a.add(d.createInstance(l,n.call(this,"/path/index_async.txt"),"utf8",void 0));i.setDirty(!0),t.ok(!i.isDirty()),await i.resolve(),i.updateTextEditorModel(c("foo")),t.ok(i.isDirty()),await i.revert({soft:!0}),t.strictEqual(i.isDirty(),!1),a.add(i.onDidChangeDirty(()=>e++));let r=!1;a.add(o.workingCopyService.onDidChangeDirty(s=>{s.resource.toString()===i.resource.toString()&&(r=!0)})),i.setDirty(!0),t.ok(i.isDirty()),t.strictEqual(e,1),t.ok(r),i.setDirty(!1),t.strictEqual(i.isDirty(),!1),t.strictEqual(e,2)}),test("No Dirty or saving for readonly models",async function(){let e=!1;a.add(o.workingCopyService.onDidChangeDirty(s=>{s.resource.toString()===i.resource.toString()&&(e=!0)}));const i=a.add(d.createInstance(q,n.call(this,"/path/index_async.txt"),"utf8",void 0));let r=!1;a.add(i.onDidSave(()=>{r=!0})),await i.resolve(),i.updateTextEditorModel(c("foo")),t.ok(!i.isDirty()),await i.save({force:!0}),t.strictEqual(r,!1),await i.revert({soft:!0}),t.ok(!i.isDirty()),t.ok(!e)}),test("File not modified error is handled gracefully",async function(){const e=a.add(d.createInstance(l,n.call(this,"/path/index_async.txt"),"utf8",void 0));await e.resolve();const i=E(e);o.textFileService.setReadStreamErrorOnce(new h("error",g.FILE_NOT_MODIFIED_SINCE)),await e.resolve(),t.ok(e),t.strictEqual(E(e),i)}),test("stat.readonly and stat.locked can change when decreased mtime is ignored",async function(){const e=a.add(d.createInstance(l,n.call(this,"/path/index_async.txt"),"utf8",void 0));await e.resolve();const i=p(y(e));o.textFileService.setReadStreamErrorOnce(new P("error",{...i,mtime:i.mtime-1,readonly:!i.readonly,locked:!i.locked})),await e.resolve(),t.ok(e),t.strictEqual(E(e),i.mtime,"mtime should not decrease"),t.notStrictEqual(y(e)?.readonly,i.readonly,"readonly should have changed despite simultaneous attempt to decrease mtime"),t.notStrictEqual(y(e)?.locked,i.locked,"locked should have changed despite simultaneous attempt to decrease mtime")}),test("Resolve error is handled gracefully if model already exists",async function(){const e=a.add(d.createInstance(l,n.call(this,"/path/index_async.txt"),"utf8",void 0));await e.resolve(),o.textFileService.setReadStreamErrorOnce(new h("error",g.FILE_NOT_FOUND)),await e.resolve(),t.ok(e)}),test("save() and isDirty() - proper with check for mtimes",async function(){const e=a.add(D(d,n.call(this,"/path/index_async2.txt"))),i=a.add(D(d,n.call(this,"/path/index_async.txt"))),r=a.add(await e.resolve()),s=a.add(await i.resolve());r.updateTextEditorModel(c("foo"));const f=p(y(r)).mtime,u=p(y(s)).mtime;t.ok(f>0),t.ok(u>0),t.ok(o.textFileService.isDirty(n.call(this,"/path/index_async2.txt"))),t.ok(!o.textFileService.isDirty(n.call(this,"/path/index_async.txt"))),s.updateTextEditorModel(c("foo")),t.ok(o.textFileService.isDirty(n.call(this,"/path/index_async.txt"))),await w(10),await o.textFileService.save(n.call(this,"/path/index_async.txt")),await o.textFileService.save(n.call(this,"/path/index_async2.txt")),t.ok(!o.textFileService.isDirty(n.call(this,"/path/index_async.txt"))),t.ok(!o.textFileService.isDirty(n.call(this,"/path/index_async2.txt"))),A?(t.ok(p(y(r)).mtime>=f),t.ok(p(y(s)).mtime>=u)):(t.ok(p(y(r)).mtime>f),t.ok(p(y(s)).mtime>u))}),test("Save Participant",async function(){let e=0;const i=a.add(d.createInstance(l,n.call(this,"/path/index_async.txt"),"utf8",void 0));a.add(i.onDidSave(()=>{t.strictEqual(T(i.createSnapshot()),e===1?"bar":"foobar"),t.ok(!i.isDirty()),e++}));const r=o.textFileService.files.addSaveParticipant({participate:async s=>{t.ok(s.isDirty()),s.updateTextEditorModel(c("bar")),t.ok(s.isDirty()),e++}});await i.resolve(),i.updateTextEditorModel(c("foo")),t.ok(i.isDirty()),await i.save(),t.strictEqual(e,2),r.dispose(),i.updateTextEditorModel(c("foobar")),t.ok(i.isDirty()),await i.save(),t.strictEqual(e,3)}),test("Save Participant - skip",async function(){let e=0;const i=a.add(d.createInstance(l,n.call(this,"/path/index_async.txt"),"utf8",void 0));a.add(o.textFileService.files.addSaveParticipant({participate:async()=>{e++}})),await i.resolve(),i.updateTextEditorModel(c("foo")),await i.save({skipSaveParticipants:!0}),t.strictEqual(e,0)}),test("Save Participant, async participant",async function(){let e=0;const i=a.add(d.createInstance(l,n.call(this,"/path/index_async.txt"),"utf8",void 0));a.add(i.onDidSave(()=>{t.ok(!i.isDirty()),e++})),a.add(o.textFileService.files.addSaveParticipant({participate:s=>(t.ok(s.isDirty()),s.updateTextEditorModel(c("bar")),t.ok(s.isDirty()),e++,w(10))})),await i.resolve(),i.updateTextEditorModel(c("foo"));const r=Date.now();await i.save(),t.strictEqual(e,2),t.ok(Date.now()-r>=10)}),test("Save Participant, bad participant",async function(){const e=a.add(d.createInstance(l,n.call(this,"/path/index_async.txt"),"utf8",void 0));a.add(o.textFileService.files.addSaveParticipant({participate:async()=>{new Error("boom")}})),await e.resolve(),e.updateTextEditorModel(c("foo")),await e.save()}),test("Save Participant, participant cancelled when saved again",async function(){const e=a.add(d.createInstance(l,n.call(this,"/path/index_async.txt"),"utf8",void 0)),i=[];a.add(o.textFileService.files.addSaveParticipant({participate:async(W,H,G,M)=>{await w(10),M.isCancellationRequested||i.push(!0)}})),await e.resolve(),e.updateTextEditorModel(c("foo"));const r=e.save();e.updateTextEditorModel(c("foo 1"));const s=e.save();e.updateTextEditorModel(c("foo 2"));const f=e.save();e.updateTextEditorModel(c("foo 3"));const u=e.save();await Promise.all([r,s,f,u]),t.strictEqual(i.length,1)}),test("Save Participant, calling save from within is unsupported but does not explode (sync save, no model change)",async function(){const e=a.add(d.createInstance(l,n.call(this,"/path/index_async.txt"),"utf8",void 0));await x(e,!1,!1,!1)}),test("Save Participant, calling save from within is unsupported but does not explode (async save, no model change)",async function(){const e=a.add(d.createInstance(l,n.call(this,"/path/index_async.txt"),"utf8",void 0));await x(e,!0,!1,!1)}),test("Save Participant, calling save from within is unsupported but does not explode (sync save, model change)",async function(){const e=a.add(d.createInstance(l,n.call(this,"/path/index_async.txt"),"utf8",void 0));await x(e,!1,!0,!1)}),test("Save Participant, calling save from within is unsupported but does not explode (async save, model change)",async function(){const e=a.add(d.createInstance(l,n.call(this,"/path/index_async.txt"),"utf8",void 0));await x(e,!0,!0,!1)}),test("Save Participant, calling save from within is unsupported but does not explode (force)",async function(){const e=a.add(d.createInstance(l,n.call(this,"/path/index_async.txt"),"utf8",void 0));await x(e,!1,!1,!0)});async function x(e,i,r,s){a.add(o.textFileService.files.addSaveParticipant({participate:async()=>{if(i&&await w(10),r){e.updateTextEditorModel(c("bar"));const u=e.save(s?{force:s}:void 0);t.notStrictEqual(f,u),await u}else{const u=e.save(s?{force:s}:void 0);t.strictEqual(f,u),await f}}})),await e.resolve(),e.updateTextEditorModel(c("foo"));const f=e.save(s?{force:s}:void 0);await f}test("Save Participant carries context",async function(){const e=a.add(d.createInstance(l,n.call(this,"/path/index_async.txt"),"utf8",void 0)),i=V.file("testFrom");let r;if(a.add(o.textFileService.files.addSaveParticipant({participate:async(s,f)=>{try{t.strictEqual(f.reason,m.EXPLICIT),t.strictEqual(f.savedFrom?.toString(),i.toString())}catch(u){r=u}}})),await e.resolve(),e.updateTextEditorModel(c("foo")),await e.save({force:!0,from:i}),r)throw r}),_()});
