{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/workspaces/common/workspaceIdentityService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { VSBuffer } from '../../../../base/common/buffer.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { isEqualOrParent, joinPath, relativePath } from '../../../../base/common/resources.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { InstantiationType, registerSingleton } from '../../../../platform/instantiation/common/extensions.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IWorkspaceStateFolder } from '../../../../platform/userDataSync/common/userDataSync.js';\nimport { EditSessionIdentityMatch, IEditSessionIdentityService } from '../../../../platform/workspace/common/editSessions.js';\nimport { IWorkspaceContextService, IWorkspaceFolder } from '../../../../platform/workspace/common/workspace.js';\n\nexport const IWorkspaceIdentityService = createDecorator<IWorkspaceIdentityService>('IWorkspaceIdentityService');\nexport interface IWorkspaceIdentityService {\n\t_serviceBrand: undefined;\n\tmatches(folders: IWorkspaceStateFolder[], cancellationToken: CancellationToken): Promise<((obj: any) => any) | false>;\n\tgetWorkspaceStateFolders(cancellationToken: CancellationToken): Promise<IWorkspaceStateFolder[]>;\n}\n\nexport class WorkspaceIdentityService implements IWorkspaceIdentityService {\n\tdeclare _serviceBrand: undefined;\n\n\tconstructor(\n\t\t@IWorkspaceContextService private readonly workspaceContextService: IWorkspaceContextService,\n\t\t@IEditSessionIdentityService private readonly editSessionIdentityService: IEditSessionIdentityService\n\t) { }\n\n\tasync getWorkspaceStateFolders(cancellationToken: CancellationToken): Promise<IWorkspaceStateFolder[]> {\n\t\tconst workspaceStateFolders: IWorkspaceStateFolder[] = [];\n\n\t\tfor (const workspaceFolder of this.workspaceContextService.getWorkspace().folders) {\n\t\t\tconst workspaceFolderIdentity = await this.editSessionIdentityService.getEditSessionIdentifier(workspaceFolder, cancellationToken);\n\t\t\tif (!workspaceFolderIdentity) { continue; }\n\t\t\tworkspaceStateFolders.push({ resourceUri: workspaceFolder.uri.toString(), workspaceFolderIdentity });\n\t\t}\n\n\t\treturn workspaceStateFolders;\n\t}\n\n\tasync matches(incomingWorkspaceFolders: IWorkspaceStateFolder[], cancellationToken: CancellationToken): Promise<((value: any) => any) | false> {\n\t\tconst incomingToCurrentWorkspaceFolderUris: { [key: string]: string } = {};\n\n\t\tconst incomingIdentitiesToIncomingWorkspaceFolders: { [key: string]: string } = {};\n\t\tfor (const workspaceFolder of incomingWorkspaceFolders) {\n\t\t\tincomingIdentitiesToIncomingWorkspaceFolders[workspaceFolder.workspaceFolderIdentity] = workspaceFolder.resourceUri;\n\t\t}\n\n\t\t// Precompute the identities of the current workspace folders\n\t\tconst currentWorkspaceFoldersToIdentities = new Map<IWorkspaceFolder, string>();\n\t\tfor (const workspaceFolder of this.workspaceContextService.getWorkspace().folders) {\n\t\t\tconst workspaceFolderIdentity = await this.editSessionIdentityService.getEditSessionIdentifier(workspaceFolder, cancellationToken);\n\t\t\tif (!workspaceFolderIdentity) { continue; }\n\t\t\tcurrentWorkspaceFoldersToIdentities.set(workspaceFolder, workspaceFolderIdentity);\n\t\t}\n\n\t\t// Match the current workspace folders to the incoming workspace folders\n\t\tfor (const [currentWorkspaceFolder, currentWorkspaceFolderIdentity] of currentWorkspaceFoldersToIdentities.entries()) {\n\n\t\t\t// Happy case: identities do not need further disambiguation\n\t\t\tconst incomingWorkspaceFolder = incomingIdentitiesToIncomingWorkspaceFolders[currentWorkspaceFolderIdentity];\n\t\t\tif (incomingWorkspaceFolder) {\n\t\t\t\t// There is an incoming workspace folder with the exact same identity as the current workspace folder\n\t\t\t\tincomingToCurrentWorkspaceFolderUris[incomingWorkspaceFolder] = currentWorkspaceFolder.uri.toString();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Unhappy case: compare the identity of the current workspace folder to all incoming workspace folder identities\n\t\t\tlet hasCompleteMatch = false;\n\t\t\tfor (const [incomingIdentity, incomingFolder] of Object.entries(incomingIdentitiesToIncomingWorkspaceFolders)) {\n\t\t\t\tif (await this.editSessionIdentityService.provideEditSessionIdentityMatch(currentWorkspaceFolder, currentWorkspaceFolderIdentity, incomingIdentity, cancellationToken) === EditSessionIdentityMatch.Complete) {\n\t\t\t\t\tincomingToCurrentWorkspaceFolderUris[incomingFolder] = currentWorkspaceFolder.uri.toString();\n\t\t\t\t\thasCompleteMatch = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hasCompleteMatch) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tconst convertUri = (uriToConvert: URI) => {\n\t\t\t// Figure out which current folder the incoming URI is a child of\n\t\t\tfor (const incomingFolderUriKey of Object.keys(incomingToCurrentWorkspaceFolderUris)) {\n\t\t\t\tconst incomingFolderUri = URI.parse(incomingFolderUriKey);\n\t\t\t\tif (isEqualOrParent(incomingFolderUri, uriToConvert)) {\n\t\t\t\t\tconst currentWorkspaceFolderUri = incomingToCurrentWorkspaceFolderUris[incomingFolderUriKey];\n\n\t\t\t\t\t// Compute the relative file path section of the uri to convert relative to the folder it came from\n\t\t\t\t\tconst relativeFilePath = relativePath(incomingFolderUri, uriToConvert);\n\n\t\t\t\t\t// Reparent the relative file path under the current workspace folder it belongs to\n\t\t\t\t\tif (relativeFilePath) {\n\t\t\t\t\t\treturn joinPath(URI.parse(currentWorkspaceFolderUri), relativeFilePath);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// No conversion was possible; return the original URI\n\t\t\treturn uriToConvert;\n\t\t};\n\n\t\t// Recursively look for any URIs in the provided object and\n\t\t// replace them with the URIs of the current workspace folders\n\t\tconst uriReplacer = (obj: any, depth = 0) => {\n\t\t\tif (!obj || depth > 200) {\n\t\t\t\treturn obj;\n\t\t\t}\n\n\t\t\tif (obj instanceof VSBuffer || obj instanceof Uint8Array) {\n\t\t\t\treturn <any>obj;\n\t\t\t}\n\n\t\t\tif (URI.isUri(obj)) {\n\t\t\t\treturn convertUri(obj);\n\t\t\t}\n\n\t\t\tif (Array.isArray(obj)) {\n\t\t\t\tfor (let i = 0; i < obj.length; ++i) {\n\t\t\t\t\tobj[i] = uriReplacer(obj[i], depth + 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// walk object\n\t\t\t\tfor (const key in obj) {\n\t\t\t\t\tif (Object.hasOwnProperty.call(obj, key)) {\n\t\t\t\t\t\tobj[key] = uriReplacer(obj[key], depth + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn obj;\n\t\t};\n\n\t\treturn uriReplacer;\n\t}\n}\n\nregisterSingleton(IWorkspaceIdentityService, WorkspaceIdentityService, InstantiationType.Delayed);\n"],
  "mappings": "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",
  "names": []
}
