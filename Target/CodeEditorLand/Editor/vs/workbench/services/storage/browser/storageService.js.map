{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/storage/browser/storageService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BroadcastDataChannel } from '../../../../base/browser/broadcast.js';\nimport { isSafari } from '../../../../base/browser/browser.js';\nimport { getActiveWindow } from '../../../../base/browser/dom.js';\nimport { IndexedDB } from '../../../../base/browser/indexedDB.js';\nimport { DeferredPromise, Promises } from '../../../../base/common/async.js';\nimport { toErrorMessage } from '../../../../base/common/errorMessage.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable, DisposableStore, IDisposable } from '../../../../base/common/lifecycle.js';\nimport { assertIsDefined } from '../../../../base/common/types.js';\nimport { InMemoryStorageDatabase, isStorageItemsChangeEvent, IStorage, IStorageDatabase, IStorageItemsChangeEvent, IUpdateRequest, Storage } from '../../../../base/parts/storage/common/storage.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { AbstractStorageService, isProfileUsingDefaultStorage, IS_NEW_KEY, StorageScope, StorageTarget } from '../../../../platform/storage/common/storage.js';\nimport { isUserDataProfile, IUserDataProfile } from '../../../../platform/userDataProfile/common/userDataProfile.js';\nimport { IAnyWorkspaceIdentifier } from '../../../../platform/workspace/common/workspace.js';\nimport { IUserDataProfileService } from '../../userDataProfile/common/userDataProfile.js';\n\nexport class BrowserStorageService extends AbstractStorageService {\n\n\tprivate static BROWSER_DEFAULT_FLUSH_INTERVAL = 5 * 1000; // every 5s because async operations are not permitted on shutdown\n\n\tprivate applicationStorage: IStorage | undefined;\n\tprivate applicationStorageDatabase: IIndexedDBStorageDatabase | undefined;\n\tprivate readonly applicationStoragePromise = new DeferredPromise<{ indexedDb: IIndexedDBStorageDatabase; storage: IStorage }>();\n\n\tprivate profileStorage: IStorage | undefined;\n\tprivate profileStorageDatabase: IIndexedDBStorageDatabase | undefined;\n\tprivate profileStorageProfile = this.userDataProfileService.currentProfile;\n\tprivate readonly profileStorageDisposables = this._register(new DisposableStore());\n\n\tprivate workspaceStorage: IStorage | undefined;\n\tprivate workspaceStorageDatabase: IIndexedDBStorageDatabase | undefined;\n\n\tget hasPendingUpdate(): boolean {\n\t\treturn Boolean(\n\t\t\tthis.applicationStorageDatabase?.hasPendingUpdate ||\n\t\t\tthis.profileStorageDatabase?.hasPendingUpdate ||\n\t\t\tthis.workspaceStorageDatabase?.hasPendingUpdate\n\t\t);\n\t}\n\n\tconstructor(\n\t\tprivate readonly workspace: IAnyWorkspaceIdentifier,\n\t\tprivate readonly userDataProfileService: IUserDataProfileService,\n\t\t@ILogService private readonly logService: ILogService,\n\t) {\n\t\tsuper({ flushInterval: BrowserStorageService.BROWSER_DEFAULT_FLUSH_INTERVAL });\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tthis._register(this.userDataProfileService.onDidChangeCurrentProfile(e => e.join(this.switchToProfile(e.profile))));\n\t}\n\n\tprotected async doInitialize(): Promise<void> {\n\n\t\t// Init storages\n\t\tawait Promises.settled([\n\t\t\tthis.createApplicationStorage(),\n\t\t\tthis.createProfileStorage(this.profileStorageProfile),\n\t\t\tthis.createWorkspaceStorage()\n\t\t]);\n\t}\n\n\tprivate async createApplicationStorage(): Promise<void> {\n\t\tconst applicationStorageIndexedDB = await IndexedDBStorageDatabase.createApplicationStorage(this.logService);\n\n\t\tthis.applicationStorageDatabase = this._register(applicationStorageIndexedDB);\n\t\tthis.applicationStorage = this._register(new Storage(this.applicationStorageDatabase));\n\n\t\tthis._register(this.applicationStorage.onDidChangeStorage(e => this.emitDidChangeValue(StorageScope.APPLICATION, e)));\n\n\t\tawait this.applicationStorage.init();\n\n\t\tthis.updateIsNew(this.applicationStorage);\n\n\t\tthis.applicationStoragePromise.complete({ indexedDb: applicationStorageIndexedDB, storage: this.applicationStorage });\n\t}\n\n\tprivate async createProfileStorage(profile: IUserDataProfile): Promise<void> {\n\n\t\t// First clear any previously associated disposables\n\t\tthis.profileStorageDisposables.clear();\n\n\t\t// Remember profile associated to profile storage\n\t\tthis.profileStorageProfile = profile;\n\n\t\tif (isProfileUsingDefaultStorage(this.profileStorageProfile)) {\n\n\t\t\t// If we are using default profile storage, the profile storage is\n\t\t\t// actually the same as application storage. As such we\n\t\t\t// avoid creating the storage library a second time on\n\t\t\t// the same DB.\n\n\t\t\tconst { indexedDb: applicationStorageIndexedDB, storage: applicationStorage } = await this.applicationStoragePromise.p;\n\n\t\t\tthis.profileStorageDatabase = applicationStorageIndexedDB;\n\t\t\tthis.profileStorage = applicationStorage;\n\n\t\t\tthis.profileStorageDisposables.add(this.profileStorage.onDidChangeStorage(e => this.emitDidChangeValue(StorageScope.PROFILE, e)));\n\t\t} else {\n\t\t\tconst profileStorageIndexedDB = await IndexedDBStorageDatabase.createProfileStorage(this.profileStorageProfile, this.logService);\n\n\t\t\tthis.profileStorageDatabase = this.profileStorageDisposables.add(profileStorageIndexedDB);\n\t\t\tthis.profileStorage = this.profileStorageDisposables.add(new Storage(this.profileStorageDatabase));\n\n\t\t\tthis.profileStorageDisposables.add(this.profileStorage.onDidChangeStorage(e => this.emitDidChangeValue(StorageScope.PROFILE, e)));\n\n\t\t\tawait this.profileStorage.init();\n\n\t\t\tthis.updateIsNew(this.profileStorage);\n\t\t}\n\t}\n\n\tprivate async createWorkspaceStorage(): Promise<void> {\n\t\tconst workspaceStorageIndexedDB = await IndexedDBStorageDatabase.createWorkspaceStorage(this.workspace.id, this.logService);\n\n\t\tthis.workspaceStorageDatabase = this._register(workspaceStorageIndexedDB);\n\t\tthis.workspaceStorage = this._register(new Storage(this.workspaceStorageDatabase));\n\n\t\tthis._register(this.workspaceStorage.onDidChangeStorage(e => this.emitDidChangeValue(StorageScope.WORKSPACE, e)));\n\n\t\tawait this.workspaceStorage.init();\n\n\t\tthis.updateIsNew(this.workspaceStorage);\n\t}\n\n\tprivate updateIsNew(storage: IStorage): void {\n\t\tconst firstOpen = storage.getBoolean(IS_NEW_KEY);\n\t\tif (firstOpen === undefined) {\n\t\t\tstorage.set(IS_NEW_KEY, true);\n\t\t} else if (firstOpen) {\n\t\t\tstorage.set(IS_NEW_KEY, false);\n\t\t}\n\t}\n\n\tprotected getStorage(scope: StorageScope): IStorage | undefined {\n\t\tswitch (scope) {\n\t\t\tcase StorageScope.APPLICATION:\n\t\t\t\treturn this.applicationStorage;\n\t\t\tcase StorageScope.PROFILE:\n\t\t\t\treturn this.profileStorage;\n\t\t\tdefault:\n\t\t\t\treturn this.workspaceStorage;\n\t\t}\n\t}\n\n\tprotected getLogDetails(scope: StorageScope): string | undefined {\n\t\tswitch (scope) {\n\t\t\tcase StorageScope.APPLICATION:\n\t\t\t\treturn this.applicationStorageDatabase?.name;\n\t\t\tcase StorageScope.PROFILE:\n\t\t\t\treturn this.profileStorageDatabase?.name;\n\t\t\tdefault:\n\t\t\t\treturn this.workspaceStorageDatabase?.name;\n\t\t}\n\t}\n\n\tprotected async switchToProfile(toProfile: IUserDataProfile): Promise<void> {\n\t\tif (!this.canSwitchProfile(this.profileStorageProfile, toProfile)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst oldProfileStorage = assertIsDefined(this.profileStorage);\n\t\tconst oldItems = oldProfileStorage.items;\n\n\t\t// Close old profile storage but only if this is\n\t\t// different from application storage!\n\t\tif (oldProfileStorage !== this.applicationStorage) {\n\t\t\tawait oldProfileStorage.close();\n\t\t}\n\n\t\t// Create new profile storage & init\n\t\tawait this.createProfileStorage(toProfile);\n\n\t\t// Handle data switch and eventing\n\t\tthis.switchData(oldItems, assertIsDefined(this.profileStorage), StorageScope.PROFILE);\n\t}\n\n\tprotected async switchToWorkspace(toWorkspace: IAnyWorkspaceIdentifier, preserveData: boolean): Promise<void> {\n\t\tthrow new Error('Migrating storage is currently unsupported in Web');\n\t}\n\n\tprotected override shouldFlushWhenIdle(): boolean {\n\t\t// this flush() will potentially cause new state to be stored\n\t\t// since new state will only be created while the document\n\t\t// has focus, one optimization is to not run this when the\n\t\t// document has no focus, assuming that state has not changed\n\t\t//\n\t\t// another optimization is to not collect more state if we\n\t\t// have a pending update already running which indicates\n\t\t// that the connection is either slow or disconnected and\n\t\t// thus unhealthy.\n\t\treturn getActiveWindow().document.hasFocus() && !this.hasPendingUpdate;\n\t}\n\n\tclose(): void {\n\n\t\t// Safari: there is an issue where the page can hang on load when\n\t\t// a previous session has kept IndexedDB transactions running.\n\t\t// The only fix seems to be to cancel any pending transactions\n\t\t// (https://github.com/microsoft/vscode/issues/136295)\n\t\t//\n\t\t// On all other browsers, we keep the databases opened because\n\t\t// we expect data to be written when the unload happens.\n\t\tif (isSafari) {\n\t\t\tthis.applicationStorage?.close();\n\t\t\tthis.profileStorageDatabase?.close();\n\t\t\tthis.workspaceStorageDatabase?.close();\n\t\t}\n\n\t\t// Always dispose to ensure that no timeouts or callbacks\n\t\t// get triggered in this phase.\n\t\tthis.dispose();\n\t}\n\n\tasync clear(): Promise<void> {\n\n\t\t// Clear key/values\n\t\tfor (const scope of [StorageScope.APPLICATION, StorageScope.PROFILE, StorageScope.WORKSPACE]) {\n\t\t\tfor (const target of [StorageTarget.USER, StorageTarget.MACHINE]) {\n\t\t\t\tfor (const key of this.keys(scope, target)) {\n\t\t\t\t\tthis.remove(key, scope);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tawait this.getStorage(scope)?.whenFlushed();\n\t\t}\n\n\t\t// Clear databases\n\t\tawait Promises.settled([\n\t\t\tthis.applicationStorageDatabase?.clear() ?? Promise.resolve(),\n\t\t\tthis.profileStorageDatabase?.clear() ?? Promise.resolve(),\n\t\t\tthis.workspaceStorageDatabase?.clear() ?? Promise.resolve()\n\t\t]);\n\t}\n\n\thasScope(scope: IAnyWorkspaceIdentifier | IUserDataProfile): boolean {\n\t\tif (isUserDataProfile(scope)) {\n\t\t\treturn this.profileStorageProfile.id === scope.id;\n\t\t}\n\n\t\treturn this.workspace.id === scope.id;\n\t}\n}\n\ninterface IIndexedDBStorageDatabase extends IStorageDatabase, IDisposable {\n\n\t/**\n\t * Name of the database.\n\t */\n\treadonly name: string;\n\n\t/**\n\t * Whether an update in the DB is currently pending\n\t * (either update or delete operation).\n\t */\n\treadonly hasPendingUpdate: boolean;\n\n\t/**\n\t * For testing only.\n\t */\n\tclear(): Promise<void>;\n}\n\nclass InMemoryIndexedDBStorageDatabase extends InMemoryStorageDatabase implements IIndexedDBStorageDatabase {\n\n\treadonly hasPendingUpdate = false;\n\treadonly name = 'in-memory-indexedb-storage';\n\n\tasync clear(): Promise<void> {\n\t\t(await this.getItems()).clear();\n\t}\n\n\tdispose(): void {\n\t\t// No-op\n\t}\n}\n\ninterface IndexedDBStorageDatabaseOptions {\n\tid: string;\n\tbroadcastChanges?: boolean;\n}\n\nexport class IndexedDBStorageDatabase extends Disposable implements IIndexedDBStorageDatabase {\n\n\tstatic async createApplicationStorage(logService: ILogService): Promise<IIndexedDBStorageDatabase> {\n\t\treturn IndexedDBStorageDatabase.create({ id: 'global', broadcastChanges: true }, logService);\n\t}\n\n\tstatic async createProfileStorage(profile: IUserDataProfile, logService: ILogService): Promise<IIndexedDBStorageDatabase> {\n\t\treturn IndexedDBStorageDatabase.create({ id: `global-${profile.id}`, broadcastChanges: true }, logService);\n\t}\n\n\tstatic async createWorkspaceStorage(workspaceId: string, logService: ILogService): Promise<IIndexedDBStorageDatabase> {\n\t\treturn IndexedDBStorageDatabase.create({ id: workspaceId }, logService);\n\t}\n\n\tstatic async create(options: IndexedDBStorageDatabaseOptions, logService: ILogService): Promise<IIndexedDBStorageDatabase> {\n\t\ttry {\n\t\t\tconst database = new IndexedDBStorageDatabase(options, logService);\n\t\t\tawait database.whenConnected;\n\n\t\t\treturn database;\n\t\t} catch (error) {\n\t\t\tlogService.error(`[IndexedDB Storage ${options.id}] create(): ${toErrorMessage(error, true)}`);\n\n\t\t\treturn new InMemoryIndexedDBStorageDatabase();\n\t\t}\n\t}\n\n\tprivate static readonly STORAGE_DATABASE_PREFIX = 'vscode-web-state-db-';\n\tprivate static readonly STORAGE_OBJECT_STORE = 'ItemTable';\n\n\tprivate readonly _onDidChangeItemsExternal = this._register(new Emitter<IStorageItemsChangeEvent>());\n\treadonly onDidChangeItemsExternal = this._onDidChangeItemsExternal.event;\n\n\tprivate broadcastChannel: BroadcastDataChannel<IStorageItemsChangeEvent> | undefined;\n\n\tprivate pendingUpdate: Promise<boolean> | undefined = undefined;\n\tget hasPendingUpdate(): boolean { return !!this.pendingUpdate; }\n\n\treadonly name: string;\n\tprivate readonly whenConnected: Promise<IndexedDB>;\n\n\tprivate constructor(\n\t\toptions: IndexedDBStorageDatabaseOptions,\n\t\tprivate readonly logService: ILogService\n\t) {\n\t\tsuper();\n\n\t\tthis.name = `${IndexedDBStorageDatabase.STORAGE_DATABASE_PREFIX}${options.id}`;\n\t\tthis.broadcastChannel = options.broadcastChanges ? this._register(new BroadcastDataChannel<IStorageItemsChangeEvent>(this.name)) : undefined;\n\n\t\tthis.whenConnected = this.connect();\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\n\t\t// Check for storage change events from other\n\t\t// windows/tabs via `BroadcastChannel` mechanisms.\n\t\tif (this.broadcastChannel) {\n\t\t\tthis._register(this.broadcastChannel.onDidReceiveData(data => {\n\t\t\t\tif (isStorageItemsChangeEvent(data)) {\n\t\t\t\t\tthis._onDidChangeItemsExternal.fire(data);\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\t}\n\n\tprivate async connect(): Promise<IndexedDB> {\n\t\ttry {\n\t\t\treturn await IndexedDB.create(this.name, undefined, [IndexedDBStorageDatabase.STORAGE_OBJECT_STORE]);\n\t\t} catch (error) {\n\t\t\tthis.logService.error(`[IndexedDB Storage ${this.name}] connect() error: ${toErrorMessage(error)}`);\n\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync getItems(): Promise<Map<string, string>> {\n\t\tconst db = await this.whenConnected;\n\n\t\tfunction isValid(value: unknown): value is string {\n\t\t\treturn typeof value === 'string';\n\t\t}\n\n\t\treturn db.getKeyValues<string>(IndexedDBStorageDatabase.STORAGE_OBJECT_STORE, isValid);\n\t}\n\n\tasync updateItems(request: IUpdateRequest): Promise<void> {\n\n\t\t// Run the update\n\t\tlet didUpdate = false;\n\t\tthis.pendingUpdate = this.doUpdateItems(request);\n\t\ttry {\n\t\t\tdidUpdate = await this.pendingUpdate;\n\t\t} finally {\n\t\t\tthis.pendingUpdate = undefined;\n\t\t}\n\n\t\t// Broadcast changes to other windows/tabs if enabled\n\t\t// and only if we actually did update storage items.\n\t\tif (this.broadcastChannel && didUpdate) {\n\t\t\tconst event: IStorageItemsChangeEvent = {\n\t\t\t\tchanged: request.insert,\n\t\t\t\tdeleted: request.delete\n\t\t\t};\n\n\t\t\tthis.broadcastChannel.postData(event);\n\t\t}\n\t}\n\n\tprivate async doUpdateItems(request: IUpdateRequest): Promise<boolean> {\n\n\t\t// Return early if the request is empty\n\t\tconst toInsert = request.insert;\n\t\tconst toDelete = request.delete;\n\t\tif ((!toInsert && !toDelete) || (toInsert?.size === 0 && toDelete?.size === 0)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst db = await this.whenConnected;\n\n\t\t// Update `ItemTable` with inserts and/or deletes\n\t\tawait db.runInTransaction(IndexedDBStorageDatabase.STORAGE_OBJECT_STORE, 'readwrite', objectStore => {\n\t\t\tconst requests: IDBRequest[] = [];\n\n\t\t\t// Inserts\n\t\t\tif (toInsert) {\n\t\t\t\tfor (const [key, value] of toInsert) {\n\t\t\t\t\trequests.push(objectStore.put(value, key));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Deletes\n\t\t\tif (toDelete) {\n\t\t\t\tfor (const key of toDelete) {\n\t\t\t\t\trequests.push(objectStore.delete(key));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn requests;\n\t\t});\n\n\t\treturn true;\n\t}\n\n\tasync optimize(): Promise<void> {\n\t\t// not suported in IndexedDB\n\t}\n\n\tasync close(): Promise<void> {\n\t\tconst db = await this.whenConnected;\n\n\t\t// Wait for pending updates to having finished\n\t\tawait this.pendingUpdate;\n\n\t\t// Finally, close IndexedDB\n\t\treturn db.close();\n\t}\n\n\tasync clear(): Promise<void> {\n\t\tconst db = await this.whenConnected;\n\n\t\tawait db.runInTransaction(IndexedDBStorageDatabase.STORAGE_OBJECT_STORE, 'readwrite', objectStore => objectStore.clear());\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
