var y=Object.defineProperty;var W=Object.getOwnPropertyDescriptor;var S=(f,d,n,o)=>{for(var e=o>1?void 0:o?W(d,n):d,s=f.length-1,a;s>=0;s--)(a=f[s])&&(e=(o?a(d,n,e):a(e))||e);return o&&e&&y(d,n,e),e},u=(f,d)=>(n,o)=>d(n,o,f);import{handleVetos as E}from"../../../../platform/lifecycle/common/lifecycle.js";import{ILifecycleService as I,WillShutdownJoinerOrder as R}from"../common/lifecycle.js";import{IStorageService as B}from"../../../../platform/storage/common/storage.js";import{ipcRenderer as h}from"../../../../base/parts/sandbox/electron-sandbox/globals.js";import{ILogService as _}from"../../../../platform/log/common/log.js";import{AbstractLifecycleService as k}from"../common/lifecycleService.js";import{InstantiationType as A,registerSingleton as $}from"../../../../platform/instantiation/common/extensions.js";import{INativeHostService as b}from"../../../../platform/native/common/native.js";import{Promises as v,disposableTimeout as g,raceCancellation as p}from"../../../../base/common/async.js";import{toErrorMessage as w}from"../../../../base/common/errorMessage.js";import{CancellationTokenSource as L}from"../../../../base/common/cancellation.js";let l=class extends k{constructor(n,o,e){super(e,o);this.nativeHostService=n;this.registerListeners()}static BEFORE_SHUTDOWN_WARNING_DELAY=5e3;static WILL_SHUTDOWN_WARNING_DELAY=800;registerListeners(){const n=this.nativeHostService.windowId;h.on("vscode:onBeforeUnload",async(o,e)=>{this.logService.trace(`[lifecycle] onBeforeUnload (reason: ${e.reason})`),await this.handleBeforeShutdown(e.reason)?(this.logService.trace("[lifecycle] onBeforeUnload prevented via veto"),this._onShutdownVeto.fire(),h.send(e.cancelChannel,n)):(this.logService.trace("[lifecycle] onBeforeUnload continues without veto"),this.shutdownReason=e.reason,h.send(e.okChannel,n))}),h.on("vscode:onWillUnload",async(o,e)=>{this.logService.trace(`[lifecycle] onWillUnload (reason: ${e.reason})`),await this.handleWillShutdown(e.reason),this._onDidShutdown.fire(),h.send(e.replyChannel,n)})}async handleBeforeShutdown(n){const o=this.logService,e=[],s=new Set;let a,c;this._onBeforeShutdown.fire({reason:n,veto(t,i){e.push(t),t===!0?o.info(`[lifecycle]: Shutdown was prevented (id: ${i})`):t instanceof Promise&&(s.add(i),t.then(m=>{m===!0&&o.info(`[lifecycle]: Shutdown was prevented (id: ${i})`)}).finally(()=>s.delete(i)))},finalVeto(t,i){if(!a)a=t,c=i;else throw new Error(`[lifecycle]: Final veto is already defined (id: ${i})`)}});const r=g(()=>{o.warn(`[lifecycle] onBeforeShutdown is taking a long time, pending operations: ${Array.from(s).join(", ")}`)},l.BEFORE_SHUTDOWN_WARNING_DELAY);try{let t=await E(e,i=>this.handleBeforeShutdownError(i,n));if(t)return t;if(a)try{s.add(c),t=await a(),t&&o.info(`[lifecycle]: Shutdown was prevented by final veto (id: ${c})`)}catch(i){t=!0,this.handleBeforeShutdownError(i,n)}return t}finally{r.dispose()}}handleBeforeShutdownError(n,o){this.logService.error(`[lifecycle]: Error during before-shutdown phase (error: ${w(n)})`),this._onBeforeShutdownError.fire({reason:o,error:n})}async handleWillShutdown(n){const o=[],e=[],s=new Set,a=new L;this._onWillShutdown.fire({reason:n,token:a.token,joiners:()=>Array.from(s.values()),join(r,t){if(s.add(t),t.order===R.Last){const i=typeof r=="function"?r:()=>r;e.push(()=>i().finally(()=>s.delete(t)))}else{const i=typeof r=="function"?r():r;i.finally(()=>s.delete(t)),o.push(i)}},force:()=>{a.dispose(!0)}});const c=g(()=>{this.logService.warn(`[lifecycle] onWillShutdown is taking a long time, pending operations: ${Array.from(s).map(r=>r.id).join(", ")}`)},l.WILL_SHUTDOWN_WARNING_DELAY);try{await p(v.settled(o),a.token)}catch(r){this.logService.error(`[lifecycle]: Error during will-shutdown phase in default joiners (error: ${w(r)})`)}try{await p(v.settled(e.map(r=>r())),a.token)}catch(r){this.logService.error(`[lifecycle]: Error during will-shutdown phase in last joiners (error: ${w(r)})`)}c.dispose()}shutdown(){return this.nativeHostService.closeWindow()}};l=S([u(0,b),u(1,B),u(2,_)],l),$(I,l,A.Eager);export{l as NativeLifecycleService};
