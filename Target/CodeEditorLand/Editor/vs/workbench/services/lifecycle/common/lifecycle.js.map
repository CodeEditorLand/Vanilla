{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/lifecycle/common/lifecycle.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { Event } from '../../../../base/common/event.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\n\nexport const ILifecycleService = createDecorator<ILifecycleService>('lifecycleService');\n\n/**\n * An event that is send out when the window is about to close. Clients have a chance to veto\n * the closing by either calling veto with a boolean \"true\" directly or with a promise that\n * resolves to a boolean. Returning a promise is useful in cases of long running operations\n * on shutdown.\n *\n * Note: It is absolutely important to avoid long running promises if possible. Please try hard\n * to return a boolean directly. Returning a promise has quite an impact on the shutdown sequence!\n */\nexport interface BeforeShutdownEvent {\n\n\t/**\n\t * The reason why the application will be shutting down.\n\t */\n\treadonly reason: ShutdownReason;\n\n\t/**\n\t * Allows to veto the shutdown. The veto can be a long running operation but it\n\t * will block the application from closing.\n\t *\n\t * @param id to identify the veto operation in case it takes very long or never\n\t * completes.\n\t */\n\tveto(value: boolean | Promise<boolean>, id: string): void;\n}\n\nexport interface InternalBeforeShutdownEvent extends BeforeShutdownEvent {\n\n\t/**\n\t * Allows to set a veto operation to run after all other\n\t * vetos have been handled from the `BeforeShutdownEvent`\n\t *\n\t * This method is hidden from the API because it is intended\n\t * to be only used once internally.\n\t */\n\tfinalVeto(vetoFn: () => boolean | Promise<boolean>, id: string): void;\n}\n\n/**\n * An event that signals an error happened during `onBeforeShutdown` veto handling.\n * In this case the shutdown operation will not proceed because this is an unexpected\n * condition that is treated like a veto.\n */\nexport interface BeforeShutdownErrorEvent {\n\n\t/**\n\t * The reason why the application is shutting down.\n\t */\n\treadonly reason: ShutdownReason;\n\n\t/**\n\t * The error that happened during shutdown handling.\n\t */\n\treadonly error: Error;\n}\n\nexport enum WillShutdownJoinerOrder {\n\n\t/**\n\t * Joiners to run before the `Last` joiners. This is the default order and best for\n\t * most cases. You can be sure that services are still functional at this point.\n\t */\n\tDefault = 1,\n\n\t/**\n\t * The joiners to run last. This should ONLY be used in rare cases when you have no\n\t * dependencies to workbench services or state. The workbench may be in a state where\n\t * resources can no longer be accessed or changed.\n\t */\n\tLast\n}\n\nexport interface IWillShutdownEventJoiner {\n\treadonly id: string;\n\treadonly label: string;\n\treadonly order?: WillShutdownJoinerOrder;\n}\n\nexport interface IWillShutdownEventDefaultJoiner extends IWillShutdownEventJoiner {\n\treadonly order?: WillShutdownJoinerOrder.Default;\n}\n\nexport interface IWillShutdownEventLastJoiner extends IWillShutdownEventJoiner {\n\treadonly order: WillShutdownJoinerOrder.Last;\n}\n\n/**\n * An event that is send out when the window closes. Clients have a chance to join the closing\n * by providing a promise from the join method. Returning a promise is useful in cases of long\n * running operations on shutdown.\n *\n * Note: It is absolutely important to avoid long running promises if possible. Please try hard\n * to return a boolean directly. Returning a promise has quite an impact on the shutdown sequence!\n */\nexport interface WillShutdownEvent {\n\n\t/**\n\t * The reason why the application is shutting down.\n\t */\n\treadonly reason: ShutdownReason;\n\n\t/**\n\t * A token that will signal cancellation when the\n\t * shutdown was forced by the user.\n\t */\n\treadonly token: CancellationToken;\n\n\t/**\n\t * Allows to join the shutdown. The promise can be a long running operation but it\n\t * will block the application from closing.\n\t *\n\t * @param promise the promise to join the shutdown event.\n\t * @param joiner to identify the join operation in case it takes very long or never\n\t * completes.\n\t */\n\tjoin(promise: Promise<void>, joiner: IWillShutdownEventDefaultJoiner): void;\n\n\t/**\n\t * Allows to join the shutdown at the end. The promise can be a long running operation but it\n\t * will block the application from closing.\n\t *\n\t * @param promiseFn the promise to join the shutdown event.\n\t * @param joiner to identify the join operation in case it takes very long or never\n\t * completes.\n\t */\n\tjoin(promiseFn: (() => Promise<void>), joiner: IWillShutdownEventLastJoiner): void;\n\n\t/**\n\t * Allows to access the joiners that have not finished joining this event.\n\t */\n\tjoiners(): IWillShutdownEventJoiner[];\n\n\t/**\n\t * Allows to enforce the shutdown, even when there are\n\t * pending `join` operations to complete.\n\t */\n\tforce(): void;\n}\n\nexport const enum ShutdownReason {\n\n\t/**\n\t * The window is closed.\n\t */\n\tCLOSE = 1,\n\n\t/**\n\t * The window closes because the application quits.\n\t */\n\tQUIT,\n\n\t/**\n\t * The window is reloaded.\n\t */\n\tRELOAD,\n\n\t/**\n\t * The window is loaded into a different workspace context.\n\t */\n\tLOAD\n}\n\nexport const enum StartupKind {\n\tNewWindow = 1,\n\tReloadedWindow = 3,\n\tReopenedWindow = 4\n}\n\nexport function StartupKindToString(startupKind: StartupKind): string {\n\tswitch (startupKind) {\n\t\tcase StartupKind.NewWindow: return 'NewWindow';\n\t\tcase StartupKind.ReloadedWindow: return 'ReloadedWindow';\n\t\tcase StartupKind.ReopenedWindow: return 'ReopenedWindow';\n\t}\n}\n\nexport const enum LifecyclePhase {\n\n\t/**\n\t * The first phase signals that we are about to startup getting ready.\n\t *\n\t * Note: doing work in this phase blocks an editor from showing to\n\t * the user, so please rather consider to use `Restored` phase.\n\t */\n\tStarting = 1,\n\n\t/**\n\t * Services are ready and the window is about to restore its UI state.\n\t *\n\t * Note: doing work in this phase blocks an editor from showing to\n\t * the user, so please rather consider to use `Restored` phase.\n\t */\n\tReady = 2,\n\n\t/**\n\t * Views, panels and editors have restored. Editors are given a bit of\n\t * time to restore their contents.\n\t */\n\tRestored = 3,\n\n\t/**\n\t * The last phase after views, panels and editors have restored and\n\t * some time has passed (2-5 seconds).\n\t */\n\tEventually = 4\n}\n\nexport function LifecyclePhaseToString(phase: LifecyclePhase): string {\n\tswitch (phase) {\n\t\tcase LifecyclePhase.Starting: return 'Starting';\n\t\tcase LifecyclePhase.Ready: return 'Ready';\n\t\tcase LifecyclePhase.Restored: return 'Restored';\n\t\tcase LifecyclePhase.Eventually: return 'Eventually';\n\t}\n}\n\n/**\n * A lifecycle service informs about lifecycle events of the\n * application, such as shutdown.\n */\nexport interface ILifecycleService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Value indicates how this window got loaded.\n\t */\n\treadonly startupKind: StartupKind;\n\n\t/**\n\t * A flag indicating in what phase of the lifecycle we currently are.\n\t */\n\tphase: LifecyclePhase;\n\n\t/**\n\t * Fired before shutdown happens. Allows listeners to veto against the\n\t * shutdown to prevent it from happening.\n\t *\n\t * The event carries a shutdown reason that indicates how the shutdown was triggered.\n\t */\n\treadonly onBeforeShutdown: Event<BeforeShutdownEvent>;\n\n\t/**\n\t * Fired when the shutdown was prevented by a component giving veto.\n\t */\n\treadonly onShutdownVeto: Event<void>;\n\n\t/**\n\t * Fired when an error happened during `onBeforeShutdown` veto handling.\n\t * In this case the shutdown operation will not proceed because this is\n\t * an unexpected condition that is treated like a veto.\n\t *\n\t * The event carries a shutdown reason that indicates how the shutdown was triggered.\n\t */\n\treadonly onBeforeShutdownError: Event<BeforeShutdownErrorEvent>;\n\n\t/**\n\t * Fired when no client is preventing the shutdown from happening (from `onBeforeShutdown`).\n\t *\n\t * This event can be joined with a long running operation via `WillShutdownEvent#join()` to\n\t * handle long running shutdown operations.\n\t *\n\t * The event carries a shutdown reason that indicates how the shutdown was triggered.\n\t */\n\treadonly onWillShutdown: Event<WillShutdownEvent>;\n\n\t/**\n\t * Fired when the shutdown is about to happen after long running shutdown operations\n\t * have finished (from `onWillShutdown`).\n\t *\n\t * This event should be used to dispose resources.\n\t */\n\treadonly onDidShutdown: Event<void>;\n\n\t/**\n\t * Returns a promise that resolves when a certain lifecycle phase\n\t * has started.\n\t */\n\twhen(phase: LifecyclePhase): Promise<void>;\n\n\t/**\n\t * Triggers a shutdown of the workbench. Depending on native or web, this can have\n\t * different implementations and behaviour.\n\t *\n\t * **Note:** this should normally not be called. See related methods in `IHostService`\n\t * and `INativeHostService` to close a window or quit the application.\n\t */\n\tshutdown(): Promise<void>;\n}\n"],
  "mappings": ";;AAKA,SAAS,yBAAyB;AAClC,SAAS,aAAa;AACtB,SAAS,uBAAuB;AAEzB,MAAM,oBAAoB,gBAAmC,kBAAkB;AA0D/E,IAAK,0BAAL,kBAAKA,6BAAL;AAMN,EAAAA,kDAAA,aAAU,KAAV;AAOA,EAAAA,kDAAA;AAbW,SAAAA;AAAA,GAAA;AAmFL,IAAW,iBAAX,kBAAWC,oBAAX;AAKN,EAAAA,gCAAA,WAAQ,KAAR;AAKA,EAAAA,gCAAA;AAKA,EAAAA,gCAAA;AAKA,EAAAA,gCAAA;AApBiB,SAAAA;AAAA,GAAA;AAuBX,IAAW,cAAX,kBAAWC,iBAAX;AACN,EAAAA,0BAAA,eAAY,KAAZ;AACA,EAAAA,0BAAA,oBAAiB,KAAjB;AACA,EAAAA,0BAAA,oBAAiB,KAAjB;AAHiB,SAAAA;AAAA,GAAA;AAMX,SAAS,oBAAoB,aAAkC;AACrE,UAAQ,aAAa;AAAA,IACpB,KAAK;AAAuB,aAAO;AAAA,IACnC,KAAK;AAA4B,aAAO;AAAA,IACxC,KAAK;AAA4B,aAAO;AAAA,EACzC;AACD;AANgB;AAQT,IAAW,iBAAX,kBAAWC,oBAAX;AAQN,EAAAA,gCAAA,cAAW,KAAX;AAQA,EAAAA,gCAAA,WAAQ,KAAR;AAMA,EAAAA,gCAAA,cAAW,KAAX;AAMA,EAAAA,gCAAA,gBAAa,KAAb;AA5BiB,SAAAA;AAAA,GAAA;AA+BX,SAAS,uBAAuB,OAA+B;AACrE,UAAQ,OAAO;AAAA,IACd,KAAK;AAAyB,aAAO;AAAA,IACrC,KAAK;AAAsB,aAAO;AAAA,IAClC,KAAK;AAAyB,aAAO;AAAA,IACrC,KAAK;AAA2B,aAAO;AAAA,EACxC;AACD;AAPgB;",
  "names": ["WillShutdownJoinerOrder", "ShutdownReason", "StartupKind", "LifecyclePhase"]
}
