{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/files/electron-sandbox/watcherClient.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { getDelayedChannel, ProxyChannel } from '../../../../base/parts/ipc/common/ipc.js';\nimport { IFileChange } from '../../../../platform/files/common/files.js';\nimport { AbstractUniversalWatcherClient, ILogMessage, IRecursiveWatcher } from '../../../../platform/files/common/watcher.js';\nimport { IUtilityProcessWorkerWorkbenchService } from '../../utilityProcess/electron-sandbox/utilityProcessWorkerWorkbenchService.js';\n\nexport class UniversalWatcherClient extends AbstractUniversalWatcherClient {\n\n\tconstructor(\n\t\tonFileChanges: (changes: IFileChange[]) => void,\n\t\tonLogMessage: (msg: ILogMessage) => void,\n\t\tverboseLogging: boolean,\n\t\tprivate readonly utilityProcessWorkerWorkbenchService: IUtilityProcessWorkerWorkbenchService\n\t) {\n\t\tsuper(onFileChanges, onLogMessage, verboseLogging);\n\n\t\tthis.init();\n\t}\n\n\tprotected override createWatcher(disposables: DisposableStore): IRecursiveWatcher {\n\t\tconst watcher = ProxyChannel.toService<IRecursiveWatcher>(getDelayedChannel((async () => {\n\n\t\t\t// Acquire universal watcher via utility process worker\n\t\t\t//\n\t\t\t// We explicitly do not add the worker as a disposable\n\t\t\t// because we need to call `stop` on disposal to prevent\n\t\t\t// a crash on shutdown (see below).\n\t\t\t//\n\t\t\t// The utility process worker services ensures to terminate\n\t\t\t// the process automatically when the window closes or reloads.\n\t\t\tconst { client, onDidTerminate } = disposables.add(await this.utilityProcessWorkerWorkbenchService.createWorker({\n\t\t\t\tmoduleId: 'vs/platform/files/node/watcher/watcherMain',\n\t\t\t\ttype: 'fileWatcher'\n\t\t\t}));\n\n\t\t\t// React on unexpected termination of the watcher process\n\t\t\t// by listening to the `onDidTerminate` event. We do not\n\t\t\t// consider an exit code of `0` as abnormal termination.\n\n\t\t\tonDidTerminate.then(({ reason }) => {\n\t\t\t\tif (reason?.code === 0) {\n\t\t\t\t\tthis.trace(`terminated by itself with code ${reason.code}, signal: ${reason.signal}`);\n\t\t\t\t} else {\n\t\t\t\t\tthis.onError(`terminated by itself unexpectedly with code ${reason?.code}, signal: ${reason?.signal} (ETERM)`);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn client.getChannel('watcher');\n\t\t})()));\n\n\t\treturn watcher;\n\t}\n}\n"],
  "mappings": ";;AAKA,SAAS,uBAAuB;AAChC,SAAS,mBAAmB,oBAAoB;AAChD,SAAS,mBAAmB;AAC5B,SAAS,gCAAgC,aAAa,yBAAyB;AAC/E,SAAS,6CAA6C;AAE/C,MAAM,+BAA+B,+BAA+B;AAAA,EAE1E,YACC,eACA,cACA,gBACiB,sCAChB;AACD,UAAM,eAAe,cAAc,cAAc;AAFhC;AAIjB,SAAK,KAAK;AAAA,EACX;AAAA,EAtBD,OAW2E;AAAA;AAAA;AAAA,EAavD,cAAc,aAAiD;AACjF,UAAM,UAAU,aAAa,UAA6B,mBAAmB,YAAY;AAUxF,YAAM,EAAE,QAAQ,eAAe,IAAI,YAAY,IAAI,MAAM,KAAK,qCAAqC,aAAa;AAAA,QAC/G,UAAU;AAAA,QACV,MAAM;AAAA,MACP,CAAC,CAAC;AAMF,qBAAe,KAAK,CAAC,EAAE,OAAO,MAAM;AACnC,YAAI,QAAQ,SAAS,GAAG;AACvB,eAAK,MAAM,kCAAkC,OAAO,IAAI,aAAa,OAAO,MAAM,EAAE;AAAA,QACrF,OAAO;AACN,eAAK,QAAQ,+CAA+C,QAAQ,IAAI,aAAa,QAAQ,MAAM,UAAU;AAAA,QAC9G;AAAA,MACD,CAAC;AAED,aAAO,OAAO,WAAW,SAAS;AAAA,IACnC,GAAG,CAAC,CAAC;AAEL,WAAO;AAAA,EACR;AACD;",
  "names": []
}
