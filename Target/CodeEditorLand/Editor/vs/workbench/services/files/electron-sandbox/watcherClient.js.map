{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/files/electron-sandbox/watcherClient.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { DisposableStore } from \"../../../../base/common/lifecycle.js\";\nimport {\n\tProxyChannel,\n\tgetDelayedChannel,\n} from \"../../../../base/parts/ipc/common/ipc.js\";\nimport type { IFileChange } from \"../../../../platform/files/common/files.js\";\nimport {\n\tAbstractUniversalWatcherClient,\n\ttype ILogMessage,\n\ttype IRecursiveWatcher,\n} from \"../../../../platform/files/common/watcher.js\";\nimport type { IUtilityProcessWorkerWorkbenchService } from \"../../utilityProcess/electron-sandbox/utilityProcessWorkerWorkbenchService.js\";\n\nexport class UniversalWatcherClient extends AbstractUniversalWatcherClient {\n\tconstructor(\n\t\tonFileChanges: (changes: IFileChange[]) => void,\n\t\tonLogMessage: (msg: ILogMessage) => void,\n\t\tverboseLogging: boolean,\n\t\tprivate readonly utilityProcessWorkerWorkbenchService: IUtilityProcessWorkerWorkbenchService,\n\t) {\n\t\tsuper(onFileChanges, onLogMessage, verboseLogging);\n\n\t\tthis.init();\n\t}\n\n\tprotected override createWatcher(\n\t\tdisposables: DisposableStore,\n\t): IRecursiveWatcher {\n\t\tconst watcher = ProxyChannel.toService<IRecursiveWatcher>(\n\t\t\tgetDelayedChannel(\n\t\t\t\t(async () => {\n\t\t\t\t\t// Acquire universal watcher via utility process worker\n\t\t\t\t\t//\n\t\t\t\t\t// We explicitly do not add the worker as a disposable\n\t\t\t\t\t// because we need to call `stop` on disposal to prevent\n\t\t\t\t\t// a crash on shutdown (see below).\n\t\t\t\t\t//\n\t\t\t\t\t// The utility process worker services ensures to terminate\n\t\t\t\t\t// the process automatically when the window closes or reloads.\n\t\t\t\t\tconst { client, onDidTerminate } = disposables.add(\n\t\t\t\t\t\tawait this.utilityProcessWorkerWorkbenchService.createWorker(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmoduleId:\n\t\t\t\t\t\t\t\t\t\"vs/platform/files/node/watcher/watcherMain\",\n\t\t\t\t\t\t\t\ttype: \"fileWatcher\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\n\t\t\t\t\t// React on unexpected termination of the watcher process\n\t\t\t\t\t// by listening to the `onDidTerminate` event. We do not\n\t\t\t\t\t// consider an exit code of `0` as abnormal termination.\n\n\t\t\t\t\tonDidTerminate.then(({ reason }) => {\n\t\t\t\t\t\tif (reason?.code === 0) {\n\t\t\t\t\t\t\tthis.trace(\n\t\t\t\t\t\t\t\t`terminated by itself with code ${reason.code}, signal: ${reason.signal}`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.onError(\n\t\t\t\t\t\t\t\t`terminated by itself unexpectedly with code ${reason?.code}, signal: ${reason?.signal} (ETERM)`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\treturn client.getChannel(\"watcher\");\n\t\t\t\t})(),\n\t\t\t),\n\t\t);\n\n\t\treturn watcher;\n\t}\n}\n"],
  "mappings": ";;AAMA;AAAA,EACC;AAAA,EACA;AAAA,OACM;AAEP;AAAA,EACC;AAAA,OAGM;AAGA,MAAM,+BAA+B,+BAA+B;AAAA,EAC1E,YACC,eACA,cACA,gBACiB,sCAChB;AACD,UAAM,eAAe,cAAc,cAAc;AAFhC;AAIjB,SAAK,KAAK;AAAA,EACX;AAAA,EA5BD,OAkB2E;AAAA;AAAA;AAAA,EAYvD,cAClB,aACoB;AACpB,UAAM,UAAU,aAAa;AAAA,MAC5B;AAAA,SACE,YAAY;AASZ,gBAAM,EAAE,QAAQ,eAAe,IAAI,YAAY;AAAA,YAC9C,MAAM,KAAK,qCAAqC;AAAA,cAC/C;AAAA,gBACC,UACC;AAAA,gBACD,MAAM;AAAA,cACP;AAAA,YACD;AAAA,UACD;AAMA,yBAAe,KAAK,CAAC,EAAE,OAAO,MAAM;AACnC,gBAAI,QAAQ,SAAS,GAAG;AACvB,mBAAK;AAAA,gBACJ,kCAAkC,OAAO,IAAI,aAAa,OAAO,MAAM;AAAA,cACxE;AAAA,YACD,OAAO;AACN,mBAAK;AAAA,gBACJ,+CAA+C,QAAQ,IAAI,aAAa,QAAQ,MAAM;AAAA,cACvF;AAAA,YACD;AAAA,UACD,CAAC;AAED,iBAAO,OAAO,WAAW,SAAS;AAAA,QACnC,GAAG;AAAA,MACJ;AAAA,IACD;AAEA,WAAO;AAAA,EACR;AACD;",
  "names": []
}
