{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/progress/browser/progressIndicator.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { ProgressBar } from '../../../../base/browser/ui/progressbar/progressbar.js';\nimport { IProgressRunner, IProgressIndicator, emptyProgressRunner } from '../../../../platform/progress/common/progress.js';\nimport { IEditorGroupView } from '../../../browser/parts/editor/editor.js';\nimport { GroupModelChangeKind } from '../../../common/editor.js';\n\nexport class EditorProgressIndicator extends Disposable implements IProgressIndicator {\n\n\tconstructor(\n\t\tprivate readonly progressBar: ProgressBar,\n\t\tprivate readonly group: IEditorGroupView\n\t) {\n\t\tsuper();\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners() {\n\n\t\t// Stop any running progress when the active editor changes or\n\t\t// the group becomes empty.\n\t\t// In contrast to the composite progress indicator, we do not\n\t\t// track active editor progress and replay it later (yet).\n\t\tthis._register(this.group.onDidModelChange(e => {\n\t\t\tif (\n\t\t\t\te.kind === GroupModelChangeKind.EDITOR_ACTIVE ||\n\t\t\t\t(e.kind === GroupModelChangeKind.EDITOR_CLOSE && this.group.isEmpty)\n\t\t\t) {\n\t\t\t\tthis.progressBar.stop().hide();\n\t\t\t}\n\t\t}));\n\t}\n\n\tshow(infinite: true, delay?: number): IProgressRunner;\n\tshow(total: number, delay?: number): IProgressRunner;\n\tshow(infiniteOrTotal: true | number, delay?: number): IProgressRunner {\n\n\t\t// No editor open: ignore any progress reporting\n\t\tif (this.group.isEmpty) {\n\t\t\treturn emptyProgressRunner;\n\t\t}\n\n\t\tif (infiniteOrTotal === true) {\n\t\t\treturn this.doShow(true, delay);\n\t\t}\n\n\t\treturn this.doShow(infiniteOrTotal, delay);\n\t}\n\n\tprivate doShow(infinite: true, delay?: number): IProgressRunner;\n\tprivate doShow(total: number, delay?: number): IProgressRunner;\n\tprivate doShow(infiniteOrTotal: true | number, delay?: number): IProgressRunner {\n\t\tif (typeof infiniteOrTotal === 'boolean') {\n\t\t\tthis.progressBar.infinite().show(delay);\n\t\t} else {\n\t\t\tthis.progressBar.total(infiniteOrTotal).show(delay);\n\t\t}\n\n\t\treturn {\n\t\t\ttotal: (total: number) => {\n\t\t\t\tthis.progressBar.total(total);\n\t\t\t},\n\n\t\t\tworked: (worked: number) => {\n\t\t\t\tif (this.progressBar.hasTotal()) {\n\t\t\t\t\tthis.progressBar.worked(worked);\n\t\t\t\t} else {\n\t\t\t\t\tthis.progressBar.infinite().show();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tdone: () => {\n\t\t\t\tthis.progressBar.stop().hide();\n\t\t\t}\n\t\t};\n\t}\n\n\tasync showWhile(promise: Promise<unknown>, delay?: number): Promise<void> {\n\n\t\t// No editor open: ignore any progress reporting\n\t\tif (this.group.isEmpty) {\n\t\t\ttry {\n\t\t\t\tawait promise;\n\t\t\t} catch (error) {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t}\n\n\t\treturn this.doShowWhile(promise, delay);\n\t}\n\n\tprivate async doShowWhile(promise: Promise<unknown>, delay?: number): Promise<void> {\n\t\ttry {\n\t\t\tthis.progressBar.infinite().show(delay);\n\n\t\t\tawait promise;\n\t\t} catch (error) {\n\t\t\t// ignore\n\t\t} finally {\n\t\t\tthis.progressBar.stop().hide();\n\t\t}\n\t}\n}\n\nnamespace ProgressIndicatorState {\n\n\texport const enum Type {\n\t\tNone,\n\t\tDone,\n\t\tInfinite,\n\t\tWhile,\n\t\tWork\n\t}\n\n\texport const None = { type: Type.None } as const;\n\texport const Done = { type: Type.Done } as const;\n\texport const Infinite = { type: Type.Infinite } as const;\n\n\texport class While {\n\n\t\treadonly type = Type.While;\n\n\t\tconstructor(\n\t\t\treadonly whilePromise: Promise<unknown>,\n\t\t\treadonly whileStart: number,\n\t\t\treadonly whileDelay: number,\n\t\t) { }\n\t}\n\n\texport class Work {\n\n\t\treadonly type = Type.Work;\n\n\t\tconstructor(\n\t\t\treadonly total: number | undefined,\n\t\t\treadonly worked: number | undefined\n\t\t) { }\n\t}\n\n\texport type State =\n\t\ttypeof None\n\t\t| typeof Done\n\t\t| typeof Infinite\n\t\t| While\n\t\t| Work;\n}\n\nexport interface IProgressScope {\n\n\t/**\n\t * Fired whenever `isActive` value changed.\n\t */\n\treadonly onDidChangeActive: Event<void>;\n\n\t/**\n\t * Whether progress should be active or not.\n\t */\n\treadonly isActive: boolean;\n}\n\nexport class ScopedProgressIndicator extends Disposable implements IProgressIndicator {\n\n\tprivate progressState: ProgressIndicatorState.State = ProgressIndicatorState.None;\n\n\tconstructor(\n\t\tprivate readonly progressBar: ProgressBar,\n\t\tprivate readonly scope: IProgressScope\n\t) {\n\t\tsuper();\n\n\t\tthis.registerListeners();\n\t}\n\n\tregisterListeners() {\n\t\tthis._register(this.scope.onDidChangeActive(() => {\n\t\t\tif (this.scope.isActive) {\n\t\t\t\tthis.onDidScopeActivate();\n\t\t\t} else {\n\t\t\t\tthis.onDidScopeDeactivate();\n\t\t\t}\n\t\t}));\n\t}\n\n\tprivate onDidScopeActivate(): void {\n\n\t\t// Return early if progress state indicates that progress is done\n\t\tif (this.progressState.type === ProgressIndicatorState.Done.type) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Replay Infinite Progress from Promise\n\t\tif (this.progressState.type === ProgressIndicatorState.Type.While) {\n\t\t\tlet delay: number | undefined;\n\t\t\tif (this.progressState.whileDelay > 0) {\n\t\t\t\tconst remainingDelay = this.progressState.whileDelay - (Date.now() - this.progressState.whileStart);\n\t\t\t\tif (remainingDelay > 0) {\n\t\t\t\t\tdelay = remainingDelay;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.doShowWhile(delay);\n\t\t}\n\n\t\t// Replay Infinite Progress\n\t\telse if (this.progressState.type === ProgressIndicatorState.Type.Infinite) {\n\t\t\tthis.progressBar.infinite().show();\n\t\t}\n\n\t\t// Replay Finite Progress (Total & Worked)\n\t\telse if (this.progressState.type === ProgressIndicatorState.Type.Work) {\n\t\t\tif (this.progressState.total) {\n\t\t\t\tthis.progressBar.total(this.progressState.total).show();\n\t\t\t}\n\n\t\t\tif (this.progressState.worked) {\n\t\t\t\tthis.progressBar.worked(this.progressState.worked).show();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate onDidScopeDeactivate(): void {\n\t\tthis.progressBar.stop().hide();\n\t}\n\n\tshow(infinite: true, delay?: number): IProgressRunner;\n\tshow(total: number, delay?: number): IProgressRunner;\n\tshow(infiniteOrTotal: true | number, delay?: number): IProgressRunner {\n\n\t\t// Sort out Arguments\n\t\tif (typeof infiniteOrTotal === 'boolean') {\n\t\t\tthis.progressState = ProgressIndicatorState.Infinite;\n\t\t} else {\n\t\t\tthis.progressState = new ProgressIndicatorState.Work(infiniteOrTotal, undefined);\n\t\t}\n\n\t\t// Active: Show Progress\n\t\tif (this.scope.isActive) {\n\n\t\t\t// Infinite: Start Progressbar and Show after Delay\n\t\t\tif (this.progressState.type === ProgressIndicatorState.Type.Infinite) {\n\t\t\t\tthis.progressBar.infinite().show(delay);\n\t\t\t}\n\n\t\t\t// Finite: Start Progressbar and Show after Delay\n\t\t\telse if (this.progressState.type === ProgressIndicatorState.Type.Work && typeof this.progressState.total === 'number') {\n\t\t\t\tthis.progressBar.total(this.progressState.total).show(delay);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\ttotal: (total: number) => {\n\t\t\t\tthis.progressState = new ProgressIndicatorState.Work(\n\t\t\t\t\ttotal,\n\t\t\t\t\tthis.progressState.type === ProgressIndicatorState.Type.Work ? this.progressState.worked : undefined);\n\n\t\t\t\tif (this.scope.isActive) {\n\t\t\t\t\tthis.progressBar.total(total);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tworked: (worked: number) => {\n\n\t\t\t\t// Verify first that we are either not active or the progressbar has a total set\n\t\t\t\tif (!this.scope.isActive || this.progressBar.hasTotal()) {\n\t\t\t\t\tthis.progressState = new ProgressIndicatorState.Work(\n\t\t\t\t\t\tthis.progressState.type === ProgressIndicatorState.Type.Work ? this.progressState.total : undefined,\n\t\t\t\t\t\tthis.progressState.type === ProgressIndicatorState.Type.Work && typeof this.progressState.worked === 'number' ? this.progressState.worked + worked : worked);\n\n\t\t\t\t\tif (this.scope.isActive) {\n\t\t\t\t\t\tthis.progressBar.worked(worked);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Otherwise the progress bar does not support worked(), we fallback to infinite() progress\n\t\t\t\telse {\n\t\t\t\t\tthis.progressState = ProgressIndicatorState.Infinite;\n\t\t\t\t\tthis.progressBar.infinite().show();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tdone: () => {\n\t\t\t\tthis.progressState = ProgressIndicatorState.Done;\n\n\t\t\t\tif (this.scope.isActive) {\n\t\t\t\t\tthis.progressBar.stop().hide();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\tasync showWhile(promise: Promise<unknown>, delay?: number): Promise<void> {\n\n\t\t// Join with existing running promise to ensure progress is accurate\n\t\tif (this.progressState.type === ProgressIndicatorState.Type.While) {\n\t\t\tpromise = Promise.all([promise, this.progressState.whilePromise]);\n\t\t}\n\n\t\t// Keep Promise in State\n\t\tthis.progressState = new ProgressIndicatorState.While(promise, delay || 0, Date.now());\n\n\t\ttry {\n\t\t\tthis.doShowWhile(delay);\n\n\t\t\tawait promise;\n\t\t} catch (error) {\n\t\t\t// ignore\n\t\t} finally {\n\n\t\t\t// If this is not the last promise in the list of joined promises, skip this\n\t\t\tif (this.progressState.type !== ProgressIndicatorState.Type.While || this.progressState.whilePromise === promise) {\n\n\t\t\t\t// The while promise is either null or equal the promise we last hooked on\n\t\t\t\tthis.progressState = ProgressIndicatorState.None;\n\n\t\t\t\tif (this.scope.isActive) {\n\t\t\t\t\tthis.progressBar.stop().hide();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate doShowWhile(delay?: number): void {\n\n\t\t// Show Progress when active\n\t\tif (this.scope.isActive) {\n\t\t\tthis.progressBar.infinite().show(delay);\n\t\t}\n\t}\n}\n\nexport abstract class AbstractProgressScope extends Disposable implements IProgressScope {\n\n\tprivate readonly _onDidChangeActive = this._register(new Emitter<void>());\n\treadonly onDidChangeActive = this._onDidChangeActive.event;\n\n\tget isActive() { return this._isActive; }\n\n\tconstructor(\n\t\tprivate scopeId: string,\n\t\tprivate _isActive: boolean\n\t) {\n\t\tsuper();\n\t}\n\n\tprotected onScopeOpened(scopeId: string) {\n\t\tif (scopeId === this.scopeId) {\n\t\t\tif (!this._isActive) {\n\t\t\t\tthis._isActive = true;\n\n\t\t\t\tthis._onDidChangeActive.fire();\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected onScopeClosed(scopeId: string) {\n\t\tif (scopeId === this.scopeId) {\n\t\t\tif (this._isActive) {\n\t\t\t\tthis._isActive = false;\n\n\t\t\t\tthis._onDidChangeActive.fire();\n\t\t\t}\n\t\t}\n\t}\n}\n"],
  "mappings": "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",
  "names": ["ProgressIndicatorState", "Type"]
}
