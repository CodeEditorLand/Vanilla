{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/search/worker/localFileSearch.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Promises } from \"../../../../base/common/async.js\";\nimport {\n\ttype CancellationToken,\n\tCancellationTokenSource,\n} from \"../../../../base/common/cancellation.js\";\nimport * as glob from \"../../../../base/common/glob.js\";\nimport { revive } from \"../../../../base/common/marshalling.js\";\nimport * as paths from \"../../../../base/common/path.js\";\nimport { ExtUri } from \"../../../../base/common/resources.js\";\nimport { createRegExp } from \"../../../../base/common/strings.js\";\nimport { URI, type UriComponents } from \"../../../../base/common/uri.js\";\nimport type {\n\tIRequestHandler,\n\tIWorkerServer,\n} from \"../../../../base/common/worker/simpleWorker.js\";\nimport { getFileResults } from \"../common/getFileResults.js\";\nimport { IgnoreFile } from \"../common/ignoreFile.js\";\nimport {\n\ttype ILocalFileSearchSimpleWorker,\n\ttype IWorkerFileSearchComplete,\n\ttype IWorkerFileSystemDirectoryHandle,\n\ttype IWorkerFileSystemHandle,\n\ttype IWorkerTextSearchComplete,\n\tLocalFileSearchSimpleWorkerHost,\n} from \"../common/localFileSearchWorkerTypes.js\";\nimport type {\n\tICommonQueryProps,\n\tIFileMatch,\n\tIFileQueryProps,\n\tIFolderQuery,\n\tIPatternInfo,\n\tITextQueryProps,\n} from \"../common/search.js\";\n\nconst PERF = false;\n\ntype FileNode = {\n\ttype: \"file\";\n\tname: string;\n\tpath: string;\n\tresolve: () => Promise<ArrayBuffer>;\n};\n\ntype DirNode = {\n\ttype: \"dir\";\n\tname: string;\n\tentries: Promise<(DirNode | FileNode)[]>;\n};\n\nconst globalStart = +new Date();\nconst itrcount: Record<string, number> = {};\nconst time = async <T>(name: string, task: () => Promise<T> | T) => {\n\tif (!PERF) {\n\t\treturn task();\n\t}\n\n\tconst start = Date.now();\n\tconst itr = (itrcount[name] ?? 0) + 1;\n\tconsole.info(\n\t\tname,\n\t\titr,\n\t\t\"starting\",\n\t\tMath.round((start - globalStart) * 10) / 10000,\n\t);\n\n\titrcount[name] = itr;\n\tconst r = await task();\n\tconst end = Date.now();\n\tconsole.info(name, itr, \"took\", end - start);\n\treturn r;\n};\n\n/**\n * Defines the worker entry point. Must be exported and named `create`.\n * @skipMangle\n */\nexport function create(workerServer: IWorkerServer): IRequestHandler {\n\treturn new LocalFileSearchSimpleWorker(workerServer);\n}\n\nexport class LocalFileSearchSimpleWorker\n\timplements ILocalFileSearchSimpleWorker, IRequestHandler\n{\n\t_requestHandlerBrand: any;\n\n\tprivate readonly host: LocalFileSearchSimpleWorkerHost;\n\tcancellationTokens: Map<number, CancellationTokenSource> = new Map();\n\n\tconstructor(workerServer: IWorkerServer) {\n\t\tthis.host = LocalFileSearchSimpleWorkerHost.getChannel(workerServer);\n\t}\n\n\t$cancelQuery(queryId: number): void {\n\t\tthis.cancellationTokens.get(queryId)?.cancel();\n\t}\n\n\tprivate registerCancellationToken(\n\t\tqueryId: number,\n\t): CancellationTokenSource {\n\t\tconst source = new CancellationTokenSource();\n\t\tthis.cancellationTokens.set(queryId, source);\n\t\treturn source;\n\t}\n\n\tasync $listDirectory(\n\t\thandle: IWorkerFileSystemDirectoryHandle,\n\t\tquery: IFileQueryProps<UriComponents>,\n\t\tfolderQuery: IFolderQuery<UriComponents>,\n\t\tignorePathCasing: boolean,\n\t\tqueryId: number,\n\t): Promise<IWorkerFileSearchComplete> {\n\t\tconst revivedFolderQuery = reviveFolderQuery(folderQuery);\n\t\tconst extUri = new ExtUri(() => ignorePathCasing);\n\n\t\tconst token = this.registerCancellationToken(queryId);\n\t\tconst entries: string[] = [];\n\t\tlet limitHit = false;\n\t\tlet count = 0;\n\n\t\tconst max = query.maxResults || 512;\n\n\t\tconst filePatternMatcher = query.filePattern\n\t\t\t? (name: string) =>\n\t\t\t\t\tquery.filePattern!.split(\"\").every((c) => name.includes(c))\n\t\t\t: (name: string) => true;\n\n\t\tawait time(\"listDirectory\", () =>\n\t\t\tthis.walkFolderQuery(\n\t\t\t\thandle,\n\t\t\t\treviveQueryProps(query),\n\t\t\t\trevivedFolderQuery,\n\t\t\t\textUri,\n\t\t\t\t(file) => {\n\t\t\t\t\tif (!filePatternMatcher(file.name)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tcount++;\n\n\t\t\t\t\tif (max && count > max) {\n\t\t\t\t\t\tlimitHit = true;\n\t\t\t\t\t\ttoken.cancel();\n\t\t\t\t\t}\n\t\t\t\t\treturn entries.push(file.path);\n\t\t\t\t},\n\t\t\t\ttoken.token,\n\t\t\t),\n\t\t);\n\n\t\treturn {\n\t\t\tresults: entries,\n\t\t\tlimitHit,\n\t\t};\n\t}\n\n\tasync $searchDirectory(\n\t\thandle: IWorkerFileSystemDirectoryHandle,\n\t\tquery: ITextQueryProps<UriComponents>,\n\t\tfolderQuery: IFolderQuery<UriComponents>,\n\t\tignorePathCasing: boolean,\n\t\tqueryId: number,\n\t): Promise<IWorkerTextSearchComplete> {\n\t\tconst revivedQuery = reviveFolderQuery(folderQuery);\n\t\tconst extUri = new ExtUri(() => ignorePathCasing);\n\n\t\treturn time(\"searchInFiles\", async () => {\n\t\t\tconst token = this.registerCancellationToken(queryId);\n\n\t\t\tconst results: IFileMatch[] = [];\n\n\t\t\tconst pattern = createSearchRegExp(query.contentPattern);\n\n\t\t\tconst onGoingProcesses: Promise<void>[] = [];\n\n\t\t\tlet fileCount = 0;\n\t\t\tlet resultCount = 0;\n\t\t\tconst limitHit = false;\n\n\t\t\tconst processFile = async (file: FileNode) => {\n\t\t\t\tif (token.token.isCancellationRequested) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tfileCount++;\n\n\t\t\t\tconst contents = await file.resolve();\n\t\t\t\tif (token.token.isCancellationRequested) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst bytes = new Uint8Array(contents);\n\t\t\t\tconst fileResults = getFileResults(bytes, pattern, {\n\t\t\t\t\tsurroundingContext: query.surroundingContext ?? 0,\n\t\t\t\t\tpreviewOptions: query.previewOptions,\n\t\t\t\t\tremainingResultQuota: query.maxResults\n\t\t\t\t\t\t? query.maxResults - resultCount\n\t\t\t\t\t\t: 10000,\n\t\t\t\t});\n\n\t\t\t\tif (fileResults.length) {\n\t\t\t\t\tresultCount += fileResults.length;\n\t\t\t\t\tif (query.maxResults && resultCount > query.maxResults) {\n\t\t\t\t\t\ttoken.cancel();\n\t\t\t\t\t}\n\t\t\t\t\tconst match = {\n\t\t\t\t\t\tresource: URI.joinPath(revivedQuery.folder, file.path),\n\t\t\t\t\t\tresults: fileResults,\n\t\t\t\t\t};\n\t\t\t\t\tthis.host.$sendTextSearchMatch(match, queryId);\n\t\t\t\t\tresults.push(match);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tawait time(\"walkFolderToResolve\", () =>\n\t\t\t\tthis.walkFolderQuery(\n\t\t\t\t\thandle,\n\t\t\t\t\treviveQueryProps(query),\n\t\t\t\t\trevivedQuery,\n\t\t\t\t\textUri,\n\t\t\t\t\tasync (file) => onGoingProcesses.push(processFile(file)),\n\t\t\t\t\ttoken.token,\n\t\t\t\t),\n\t\t\t);\n\n\t\t\tawait time(\"resolveOngoingProcesses\", () =>\n\t\t\t\tPromise.all(onGoingProcesses),\n\t\t\t);\n\n\t\t\tif (PERF) {\n\t\t\t\tconsole.log(\"Searched in\", fileCount, \"files\");\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tresults,\n\t\t\t\tlimitHit,\n\t\t\t};\n\t\t});\n\t}\n\n\tprivate async walkFolderQuery(\n\t\thandle: IWorkerFileSystemDirectoryHandle,\n\t\tqueryProps: ICommonQueryProps<URI>,\n\t\tfolderQuery: IFolderQuery<URI>,\n\t\textUri: ExtUri,\n\t\tonFile: (file: FileNode) => any,\n\t\ttoken: CancellationToken,\n\t): Promise<void> {\n\t\tconst folderExcludes = folderQuery.excludePattern?.map(\n\t\t\t(excludePattern) =>\n\t\t\t\tglob.parse(excludePattern.pattern ?? {}, {\n\t\t\t\t\ttrimForExclusions: true,\n\t\t\t\t}) as glob.ParsedExpression,\n\t\t);\n\n\t\tconst evalFolderExcludes = (\n\t\t\tpath: string,\n\t\t\tbasename: string,\n\t\t\thasSibling: (query: string) => boolean,\n\t\t) => {\n\t\t\treturn folderExcludes?.some((folderExclude) => {\n\t\t\t\treturn folderExclude(path, basename, hasSibling);\n\t\t\t});\n\t\t};\n\t\t// For folders, only check if the folder is explicitly excluded so walking continues.\n\t\tconst isFolderExcluded = (\n\t\t\tpath: string,\n\t\t\tbasename: string,\n\t\t\thasSibling: (query: string) => boolean,\n\t\t) => {\n\t\t\tpath = path.slice(1);\n\t\t\tif (evalFolderExcludes(path, basename, hasSibling)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (pathExcludedInQuery(queryProps, path)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t\t// For files ensure the full check takes place.\n\t\tconst isFileIncluded = (\n\t\t\tpath: string,\n\t\t\tbasename: string,\n\t\t\thasSibling: (query: string) => boolean,\n\t\t) => {\n\t\t\tpath = path.slice(1);\n\t\t\tif (evalFolderExcludes(path, basename, hasSibling)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!pathIncludedInQuery(queryProps, path, extUri)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\n\t\tconst processFile = (\n\t\t\tfile: FileSystemFileHandle,\n\t\t\tprior: string,\n\t\t): FileNode => {\n\t\t\tconst resolved: FileNode = {\n\t\t\t\ttype: \"file\",\n\t\t\t\tname: file.name,\n\t\t\t\tpath: prior,\n\t\t\t\tresolve: () => file.getFile().then((r) => r.arrayBuffer()),\n\t\t\t} as const;\n\n\t\t\treturn resolved;\n\t\t};\n\n\t\tconst isFileSystemDirectoryHandle = (\n\t\t\thandle: IWorkerFileSystemHandle,\n\t\t): handle is FileSystemDirectoryHandle => {\n\t\t\treturn handle.kind === \"directory\";\n\t\t};\n\n\t\tconst isFileSystemFileHandle = (\n\t\t\thandle: IWorkerFileSystemHandle,\n\t\t): handle is FileSystemFileHandle => {\n\t\t\treturn handle.kind === \"file\";\n\t\t};\n\n\t\tconst processDirectory = async (\n\t\t\tdirectory: IWorkerFileSystemDirectoryHandle,\n\t\t\tprior: string,\n\t\t\tignoreFile?: IgnoreFile,\n\t\t): Promise<DirNode> => {\n\t\t\tif (!folderQuery.disregardIgnoreFiles) {\n\t\t\t\tconst ignoreFiles = await Promise.all([\n\t\t\t\t\tdirectory\n\t\t\t\t\t\t.getFileHandle(\".gitignore\")\n\t\t\t\t\t\t.catch((e) => undefined),\n\t\t\t\t\tdirectory.getFileHandle(\".ignore\").catch((e) => undefined),\n\t\t\t\t]);\n\n\t\t\t\tawait Promise.all(\n\t\t\t\t\tignoreFiles.map(async (file) => {\n\t\t\t\t\t\tif (!file) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst ignoreContents = new TextDecoder(\"utf8\").decode(\n\t\t\t\t\t\t\tnew Uint8Array(\n\t\t\t\t\t\t\t\tawait (await file.getFile()).arrayBuffer(),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tignoreFile = new IgnoreFile(\n\t\t\t\t\t\t\tignoreContents,\n\t\t\t\t\t\t\tprior,\n\t\t\t\t\t\t\tignoreFile,\n\t\t\t\t\t\t);\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst entries = Promises.withAsyncBody<(FileNode | DirNode)[]>(\n\t\t\t\tasync (c) => {\n\t\t\t\t\tconst files: FileNode[] = [];\n\t\t\t\t\tconst dirs: Promise<DirNode>[] = [];\n\n\t\t\t\t\tconst entries: [string, IWorkerFileSystemHandle][] = [];\n\t\t\t\t\tconst sibilings = new Set<string>();\n\n\t\t\t\t\tfor await (const entry of directory.entries()) {\n\t\t\t\t\t\tentries.push(entry);\n\t\t\t\t\t\tsibilings.add(entry[0]);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (const [basename, handle] of entries) {\n\t\t\t\t\t\tif (token.isCancellationRequested) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst path = prior + basename;\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tignoreFile &&\n\t\t\t\t\t\t\t!ignoreFile.isPathIncludedInTraversal(\n\t\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\thandle.kind === \"directory\",\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst hasSibling = (query: string) =>\n\t\t\t\t\t\t\tsibilings.has(query);\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tisFileSystemDirectoryHandle(handle) &&\n\t\t\t\t\t\t\t!isFolderExcluded(path, basename, hasSibling)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tdirs.push(\n\t\t\t\t\t\t\t\tprocessDirectory(\n\t\t\t\t\t\t\t\t\thandle,\n\t\t\t\t\t\t\t\t\tpath + \"/\",\n\t\t\t\t\t\t\t\t\tignoreFile,\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tisFileSystemFileHandle(handle) &&\n\t\t\t\t\t\t\tisFileIncluded(path, basename, hasSibling)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tfiles.push(processFile(handle, path));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tc([...(await Promise.all(dirs)), ...files]);\n\t\t\t\t},\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\ttype: \"dir\",\n\t\t\t\tname: directory.name,\n\t\t\t\tentries,\n\t\t\t};\n\t\t};\n\n\t\tconst resolveDirectory = async (\n\t\t\tdirectory: DirNode,\n\t\t\tonFile: (f: FileNode) => any,\n\t\t) => {\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tawait Promise.all(\n\t\t\t\t(await directory.entries)\n\t\t\t\t\t.sort(\n\t\t\t\t\t\t(a, b) =>\n\t\t\t\t\t\t\t-(a.type === \"dir\" ? 0 : 1) +\n\t\t\t\t\t\t\t(b.type === \"dir\" ? 0 : 1),\n\t\t\t\t\t)\n\t\t\t\t\t.map(async (entry) => {\n\t\t\t\t\t\tif (entry.type === \"dir\") {\n\t\t\t\t\t\t\treturn resolveDirectory(entry, onFile);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn onFile(entry);\n\t\t\t\t\t\t}\n\t\t\t\t\t}),\n\t\t\t);\n\t\t};\n\n\t\tconst processed = await time(\"process\", () =>\n\t\t\tprocessDirectory(handle, \"/\"),\n\t\t);\n\t\tawait time(\"resolve\", () => resolveDirectory(processed, onFile));\n\t}\n}\n\nfunction createSearchRegExp(options: IPatternInfo): RegExp {\n\treturn createRegExp(options.pattern, !!options.isRegExp, {\n\t\twholeWord: options.isWordMatch,\n\t\tglobal: true,\n\t\tmatchCase: options.isCaseSensitive,\n\t\tmultiline: true,\n\t\tunicode: true,\n\t});\n}\n\nfunction reviveFolderQuery(\n\tfolderQuery: IFolderQuery<UriComponents>,\n): IFolderQuery<URI> {\n\t// @todo: andrea - try to see why we can't just call 'revive' here\n\treturn revive({\n\t\t...revive(folderQuery),\n\t\texcludePattern: folderQuery.excludePattern?.map((ep) => ({\n\t\t\tfolder: URI.revive(ep.folder),\n\t\t\tpattern: ep.pattern,\n\t\t})),\n\t\tfolder: URI.revive(folderQuery.folder),\n\t});\n}\n\nfunction reviveQueryProps(\n\tqueryProps: ICommonQueryProps<UriComponents>,\n): ICommonQueryProps<URI> {\n\treturn {\n\t\t...queryProps,\n\t\textraFileResources: queryProps.extraFileResources?.map((r) =>\n\t\t\tURI.revive(r),\n\t\t),\n\t\tfolderQueries: queryProps.folderQueries.map((fq) =>\n\t\t\treviveFolderQuery(fq),\n\t\t),\n\t};\n}\n\nfunction pathExcludedInQuery(\n\tqueryProps: ICommonQueryProps<URI>,\n\tfsPath: string,\n): boolean {\n\tif (\n\t\tqueryProps.excludePattern &&\n\t\tglob.match(queryProps.excludePattern, fsPath)\n\t) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nfunction pathIncludedInQuery(\n\tqueryProps: ICommonQueryProps<URI>,\n\tpath: string,\n\textUri: ExtUri,\n): boolean {\n\tif (\n\t\tqueryProps.excludePattern &&\n\t\tglob.match(queryProps.excludePattern, path)\n\t) {\n\t\treturn false;\n\t}\n\n\tif (queryProps.includePattern || queryProps.usingSearchPaths) {\n\t\tif (\n\t\t\tqueryProps.includePattern &&\n\t\t\tglob.match(queryProps.includePattern, path)\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// If searchPaths are being used, the extra file must be in a subfolder and match the pattern, if present\n\t\tif (queryProps.usingSearchPaths) {\n\t\t\treturn (\n\t\t\t\t!!queryProps.folderQueries &&\n\t\t\t\tqueryProps.folderQueries.some((fq) => {\n\t\t\t\t\tconst searchPath = fq.folder;\n\t\t\t\t\tconst uri = URI.file(path);\n\t\t\t\t\tif (extUri.isEqualOrParent(uri, searchPath)) {\n\t\t\t\t\t\tconst relPath = paths.relative(\n\t\t\t\t\t\t\tsearchPath.path,\n\t\t\t\t\t\t\turi.path,\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t!fq.includePattern ||\n\t\t\t\t\t\t\t!!glob.match(fq.includePattern, relPath)\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n"],
  "mappings": "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",
  "names": ["handle", "entries", "onFile"]
}
