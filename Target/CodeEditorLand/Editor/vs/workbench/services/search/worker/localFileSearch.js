import{Promises as L}from"../../../../base/common/async.js";import{CancellationTokenSource as A}from"../../../../base/common/cancellation.js";import*as w from"../../../../base/common/glob.js";import{revive as O}from"../../../../base/common/marshalling.js";import*as $ from"../../../../base/common/path.js";import{ExtUri as U}from"../../../../base/common/resources.js";import{createRegExp as j}from"../../../../base/common/strings.js";import{URI as b}from"../../../../base/common/uri.js";import{getFileResults as G}from"../common/getFileResults.js";import{IgnoreFile as _}from"../common/ignoreFile.js";import{LocalFileSearchSimpleWorkerHost as z}from"../common/localFileSearchWorkerTypes.js";const E=!1,se=+new Date,N={},P=async(e,t)=>{if(!E)return t();const n=Date.now(),s=(N[e]??0)+1;N[e]=s;const a=await t(),l=Date.now();return a};function ae(e){return new J(e)}class J{_requestHandlerBrand;host;cancellationTokens=new Map;constructor(t){this.host=z.getChannel(t)}$cancelQuery(t){this.cancellationTokens.get(t)?.cancel()}registerCancellationToken(t){const n=new A;return this.cancellationTokens.set(t,n),n}async $listDirectory(t,n,s,a,l){const d=H(s),x=new U(()=>a),c=this.registerCancellationToken(l),f=[];let F=!1,p=0;const g=n.maxResults||512,y=n.filePattern?u=>n.filePattern.split("").every(I=>u.includes(I)):u=>!0;return await P("listDirectory",()=>this.walkFolderQuery(t,M(n),d,x,u=>{if(y(u.name))return p++,g&&p>g&&(F=!0,c.cancel()),f.push(u.path)},c.token)),{results:f,limitHit:F}}async $searchDirectory(t,n,s,a,l){const d=H(s),x=new U(()=>a);return P("searchInFiles",async()=>{const c=this.registerCancellationToken(l),f=[],F=K(n.contentPattern),p=[];let g=0,y=0;const u=!1,I=async k=>{if(c.token.isCancellationRequested)return;g++;const r=await k.resolve();if(c.token.isCancellationRequested)return;const i=new Uint8Array(r),o=G(i,F,{surroundingContext:n.surroundingContext??0,previewOptions:n.previewOptions,remainingResultQuota:n.maxResults?n.maxResults-y:1e4});if(o.length){y+=o.length,n.maxResults&&y>n.maxResults&&c.cancel();const m={resource:b.joinPath(d.folder,k.path),results:o};this.host.$sendTextSearchMatch(m,l),f.push(m)}};return await P("walkFolderToResolve",()=>this.walkFolderQuery(t,M(n),d,x,async k=>p.push(I(k)),c.token)),await P("resolveOngoingProcesses",()=>Promise.all(p)),{results:f,limitHit:u}})}async walkFolderQuery(t,n,s,a,l,d){const x=s.excludePattern?.map(r=>w.parse(r.pattern??{},{trimForExclusions:!0})),c=(r,i,o)=>x?.some(m=>m(r,i,o)),f=(r,i,o)=>(r=r.slice(1),!!(c(r,i,o)||V(n,r))),F=(r,i,o)=>(r=r.slice(1),!(c(r,i,o)||!X(n,r,a))),p=(r,i)=>({type:"file",name:r.name,path:i,resolve:()=>r.getFile().then(m=>m.arrayBuffer())}),g=r=>r.kind==="directory",y=r=>r.kind==="file",u=async(r,i,o)=>{if(!s.disregardIgnoreFiles){const Q=await Promise.all([r.getFileHandle(".gitignore").catch(h=>{}),r.getFileHandle(".ignore").catch(h=>{})]);await Promise.all(Q.map(async h=>{if(!h)return;const R=new TextDecoder("utf8").decode(new Uint8Array(await(await h.getFile()).arrayBuffer()));o=new _(R,i,o)}))}const m=L.withAsyncBody(async Q=>{const h=[],R=[],W=[],D=new Set;for await(const S of r.entries())W.push(S),D.add(S[0]);for(const[S,C]of W){if(d.isCancellationRequested)break;const v=i+S;if(o&&!o.isPathIncludedInTraversal(v,C.kind==="directory"))continue;const T=B=>D.has(B);g(C)&&!f(v,S,T)?R.push(u(C,v+"/",o)):y(C)&&F(v,S,T)&&h.push(p(C,v))}Q([...await Promise.all(R),...h])});return{type:"dir",name:r.name,entries:m}},I=async(r,i)=>{d.isCancellationRequested||await Promise.all((await r.entries).sort((o,m)=>-(o.type==="dir"?0:1)+(m.type==="dir"?0:1)).map(async o=>o.type==="dir"?I(o,i):i(o)))},k=await P("process",()=>u(t,"/"));await P("resolve",()=>I(k,l))}}function K(e){return j(e.pattern,!!e.isRegExp,{wholeWord:e.isWordMatch,global:!0,matchCase:e.isCaseSensitive,multiline:!0,unicode:!0})}function H(e){return O(e)}function M(e){return{...e,extraFileResources:e.extraFileResources?.map(t=>b.revive(t)),folderQueries:e.folderQueries.map(t=>H(t))}}function V(e,t){return!!(e.excludePattern&&w.match(e.excludePattern,t))}function X(e,t,n){return e.excludePattern&&w.match(e.excludePattern,t)?!1:e.includePattern||e.usingSearchPaths?e.includePattern&&w.match(e.includePattern,t)?!0:e.usingSearchPaths?!!e.folderQueries&&e.folderQueries.some(s=>{const a=s.folder,l=b.file(t);if(n.isEqualOrParent(l,a)){const d=$.relative(a.path,l.path);return!s.includePattern||!!w.match(s.includePattern,d)}else return!1}):!1:!0}export{J as LocalFileSearchSimpleWorker,ae as create};
