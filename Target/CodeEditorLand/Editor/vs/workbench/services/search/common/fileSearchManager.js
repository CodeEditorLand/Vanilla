import{CancellationTokenSource as S}from"../../../../base/common/cancellation.js";import{toErrorMessage as g}from"../../../../base/common/errorMessage.js";import*as v from"../../../../base/common/glob.js";import{Disposable as y}from"../../../../base/common/lifecycle.js";import*as u from"../../../../base/common/path.js";import*as T from"../../../../base/common/resources.js";import{StopWatch as P}from"../../../../base/common/stopwatch.js";import{TernarySearchTree as C}from"../../../../base/common/ternarySearchTree.js";import"../../../../base/common/uri.js";import{DEFAULT_MAX_SEARCH_RESULTS as E,excludeToGlobPattern as x,hasSiblingFn as k,QueryGlobTester as M,resolvePatternsForProvider as I}from"./search.js";import{OldFileSearchProviderConverter as R}from"./searchExtConversionTypes.js";import"./searchExtTypes.js";class D{constructor(e,t,r){this.config=e;this.provider=t;this.sessionLifecycle=r;this.filePattern=e.filePattern,this.includePattern=e.includePattern&&v.parse(e.includePattern),this.maxResults=e.maxResults||void 0,this.exists=e.exists,this.activeCancellationTokens=new Set,this.globalExcludePattern=e.excludePattern&&v.parse(e.excludePattern)}filePattern;includePattern;maxResults;exists;isLimitHit=!1;resultCount=0;isCanceled=!1;activeCancellationTokens;globalExcludePattern;cancel(){this.isCanceled=!0,this.activeCancellationTokens.forEach(e=>e.cancel()),this.activeCancellationTokens=new Set}search(e){const t=this.config.folderQueries||[];return new Promise((r,l)=>{const a=i=>{this.resultCount++,e(i)};if(this.isCanceled)return r({limitHit:this.isLimitHit});this.config.extraFileResources&&this.config.extraFileResources.forEach(i=>{const s=i.toString(),n=u.basename(s);this.globalExcludePattern&&this.globalExcludePattern(s,n)||this.matchFile(a,{base:i,basename:n})}),this.doSearch(t,a).then(i=>{r({limitHit:this.isLimitHit,stats:i||void 0})},i=>{l(new Error(g(i)))})})}async doSearch(e,t){const r=new S,l=e.map(o=>this.getSearchOptionsForFolder(o)),a=this.provider instanceof R?this.sessionLifecycle?.tokenSource.token:this.sessionLifecycle?.obj,i={folderOptions:l,maxResults:this.config.maxResults??E,session:a},s=C.forUris();e.forEach(o=>{const c=new M(this.config,o),f=!c.hasSiblingExcludeClauses();s.set(o.folder,{queryTester:c,noSiblingsClauses:f,folder:o.folder,tree:this.initDirectoryTree()})});let n;try{this.activeCancellationTokens.add(r),n=P.create();const o=await this.provider.provideFileSearchResults(this.config.filePattern||"",i,r.token),c=n.elapsed(),f=P.create();return this.isCanceled&&!this.isLimitHit||(o&&o.forEach(h=>{const d=s.findSubstr(h),p=u.posix.relative(d.folder.path,h.path);if(d.noSiblingsClauses){const m=u.basename(h.path);this.matchFile(t,{base:d.folder,relativePath:p,basename:m});return}this.addDirectoryEntries(d.tree,d.folder,p,t)}),this.isCanceled&&!this.isLimitHit)?null:(s.forEach(h=>{this.matchDirectoryTree(h.tree,h.queryTester,t)}),{providerTime:c,postProcessTime:f.elapsed()})}finally{r.dispose(),this.activeCancellationTokens.delete(r)}}getSearchOptionsForFolder(e){const t=I(this.config.includePattern,e.includePattern);let r=e.excludePattern?.map(a=>({folder:a.folder,patterns:I(this.config.excludePattern,a.pattern)}));r?.length||(r=[{folder:void 0,patterns:I(this.config.excludePattern,void 0)}]);const l=x(r);return{folder:e.folder,excludes:l,includes:t,useIgnoreFiles:{local:!e.disregardIgnoreFiles,parent:!e.disregardParentIgnoreFiles,global:!e.disregardGlobalIgnoreFiles},followSymlinks:!e.ignoreSymlinks}}initDirectoryTree(){const e={rootEntries:[],pathToEntries:Object.create(null)};return e.pathToEntries["."]=e.rootEntries,e}addDirectoryEntries({pathToEntries:e},t,r,l){if(r===this.filePattern){const i=u.basename(this.filePattern);this.matchFile(l,{base:t,relativePath:this.filePattern,basename:i})}function a(i){const s=u.basename(i),n=u.dirname(i);let o=e[n];o||(o=e[n]=[],a(n)),o.push({base:t,relativePath:i,basename:s})}a(r)}matchDirectoryTree({rootEntries:e,pathToEntries:t},r,l){const a=this,i=this.filePattern;function s(n){const o=k(()=>n.map(c=>c.basename));for(let c=0,f=n.length;c<f;c++){const h=n[c],{relativePath:d,basename:p}=h;if(r.matchesExcludesSync(d,p,i!==p?o:void 0))continue;const m=t[d];if(m)s(m);else{if(d===i)continue;a.matchFile(l,h)}if(a.isLimitHit)break}}s(e)}matchFile(e,t){(!this.includePattern||t.relativePath&&this.includePattern(t.relativePath,t.basename))&&((this.exists||this.maxResults&&this.resultCount>=this.maxResults)&&(this.isLimitHit=!0,this.cancel()),this.isLimitHit||e(t))}}class w extends y{obj;tokenSource;constructor(){super(),this.obj=new Object,this.tokenSource=new S}dispose(){this.tokenSource.cancel(),super.dispose()}}class F{static BATCH_SIZE=512;sessions=new Map;fileSearch(e,t,r,l){const a=this.getSessionTokenSource(e.cacheKey),i=new D(e,t,a);let s=0;const n=o=>{s+=o.length,r(o.map(c=>this.rawMatchToSearchItem(c)))};return this.doSearch(i,F.BATCH_SIZE,n,l).then(o=>({limitHit:o.limitHit,stats:o.stats?{fromCache:!1,type:"fileSearchProvider",resultCount:s,detailStats:o.stats}:void 0,messages:[]}))}clearCache(e){this.sessions.get(e)?.dispose(),this.sessions.delete(e)}getSessionTokenSource(e){if(e)return this.sessions.has(e)||this.sessions.set(e,new w),this.sessions.get(e)}rawMatchToSearchItem(e){return e.relativePath?{resource:T.joinPath(e.base,e.relativePath)}:{resource:e.base}}doSearch(e,t,r,l){const a=l.onCancellationRequested(()=>{e.cancel()}),i=n=>{n&&(s.push(n),t>0&&s.length>=t&&(r(s),s=[]))};let s=[];return e.search(i).then(n=>(s.length&&r(s),a.dispose(),n),n=>(s.length&&r(s),a.dispose(),Promise.reject(n)))}}export{F as FileSearchManager};
