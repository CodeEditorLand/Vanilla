{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/search/common/textSearchManager.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isThenable } from '../../../../base/common/async.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { toErrorMessage } from '../../../../base/common/errorMessage.js';\nimport { Schemas } from '../../../../base/common/network.js';\nimport * as path from '../../../../base/common/path.js';\nimport * as resources from '../../../../base/common/resources.js';\nimport { TernarySearchTree } from '../../../../base/common/ternarySearchTree.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { DEFAULT_MAX_SEARCH_RESULTS, hasSiblingPromiseFn, IAITextQuery, IExtendedExtensionSearchOptions, IFileMatch, IFolderQuery, excludeToGlobPattern, IPatternInfo, ISearchCompleteStats, ITextQuery, ITextSearchContext, ITextSearchMatch, ITextSearchResult, ITextSearchStats, QueryGlobTester, QueryType, resolvePatternsForProvider, ISearchRange, DEFAULT_TEXT_SEARCH_PREVIEW_OPTIONS } from './search.js';\nimport { AITextSearchProviderNew, TextSearchCompleteNew, TextSearchMatchNew, TextSearchProviderFolderOptions, TextSearchProviderNew, TextSearchProviderOptions, TextSearchQueryNew, TextSearchResultNew } from './searchExtTypes.js';\n\nexport interface IFileUtils {\n\treaddir: (resource: URI) => Promise<string[]>;\n\ttoCanonicalName: (encoding: string) => string;\n}\ninterface IAITextQueryProviderPair {\n\tquery: IAITextQuery; provider: AITextSearchProviderNew;\n}\n\ninterface ITextQueryProviderPair {\n\tquery: ITextQuery; provider: TextSearchProviderNew;\n}\ninterface FolderQueryInfo {\n\tqueryTester: QueryGlobTester;\n\tfolder: URI;\n\tfolderIdx: number;\n}\n\nexport class TextSearchManager {\n\n\tprivate collector: TextSearchResultsCollector | null = null;\n\n\tprivate isLimitHit = false;\n\tprivate resultCount = 0;\n\n\tconstructor(private queryProviderPair: IAITextQueryProviderPair | ITextQueryProviderPair,\n\t\tprivate fileUtils: IFileUtils,\n\t\tprivate processType: ITextSearchStats['type']) { }\n\n\tprivate get query() {\n\t\treturn this.queryProviderPair.query;\n\t}\n\n\tsearch(onProgress: (matches: IFileMatch[]) => void, token: CancellationToken): Promise<ISearchCompleteStats> {\n\t\tconst folderQueries = this.query.folderQueries || [];\n\t\tconst tokenSource = new CancellationTokenSource(token);\n\n\t\treturn new Promise<ISearchCompleteStats>((resolve, reject) => {\n\t\t\tthis.collector = new TextSearchResultsCollector(onProgress);\n\n\t\t\tlet isCanceled = false;\n\t\t\tconst onResult = (result: TextSearchResultNew, folderIdx: number) => {\n\t\t\t\tif (isCanceled) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!this.isLimitHit) {\n\t\t\t\t\tconst resultSize = this.resultSize(result);\n\t\t\t\t\tif (result instanceof TextSearchMatchNew && typeof this.query.maxResults === 'number' && this.resultCount + resultSize > this.query.maxResults) {\n\t\t\t\t\t\tthis.isLimitHit = true;\n\t\t\t\t\t\tisCanceled = true;\n\t\t\t\t\t\ttokenSource.cancel();\n\n\t\t\t\t\t\tresult = this.trimResultToSize(result, this.query.maxResults - this.resultCount);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst newResultSize = this.resultSize(result);\n\t\t\t\t\tthis.resultCount += newResultSize;\n\t\t\t\t\tconst a = result instanceof TextSearchMatchNew;\n\n\t\t\t\t\tif (newResultSize > 0 || !a) {\n\t\t\t\t\t\tthis.collector!.add(result, folderIdx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// For each root folder\n\t\t\tthis.doSearch(folderQueries, onResult, tokenSource.token).then(result => {\n\t\t\t\ttokenSource.dispose();\n\t\t\t\tthis.collector!.flush();\n\n\t\t\t\tresolve({\n\t\t\t\t\tlimitHit: this.isLimitHit || result?.limitHit,\n\t\t\t\t\tmessages: this.getMessagesFromResults(result),\n\t\t\t\t\tstats: {\n\t\t\t\t\t\ttype: this.processType\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}, (err: Error) => {\n\t\t\t\ttokenSource.dispose();\n\t\t\t\tconst errMsg = toErrorMessage(err);\n\t\t\t\treject(new Error(errMsg));\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate getMessagesFromResults(result: TextSearchCompleteNew | null | undefined) {\n\t\tif (!result?.message) { return []; }\n\t\tif (Array.isArray(result.message)) { return result.message; }\n\t\treturn [result.message];\n\t}\n\n\tprivate resultSize(result: TextSearchResultNew): number {\n\t\tif (result instanceof TextSearchMatchNew) {\n\t\t\treturn Array.isArray(result.ranges) ?\n\t\t\t\tresult.ranges.length :\n\t\t\t\t1;\n\t\t}\n\t\telse {\n\t\t\t// #104400 context lines shoudn't count towards result count\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tprivate trimResultToSize(result: TextSearchMatchNew, size: number): TextSearchMatchNew {\n\t\treturn new TextSearchMatchNew(result.uri, result.ranges.slice(0, size), result.previewText);\n\t}\n\n\tprivate async doSearch(folderQueries: IFolderQuery<URI>[], onResult: (result: TextSearchResultNew, folderIdx: number) => void, token: CancellationToken): Promise<TextSearchCompleteNew | null | undefined> {\n\t\tconst folderMappings: TernarySearchTree<URI, FolderQueryInfo> = TernarySearchTree.forUris<FolderQueryInfo>();\n\t\tfolderQueries.forEach((fq, i) => {\n\t\t\tconst queryTester = new QueryGlobTester(this.query, fq);\n\t\t\tfolderMappings.set(fq.folder, { queryTester, folder: fq.folder, folderIdx: i });\n\t\t});\n\n\t\tconst testingPs: Promise<void>[] = [];\n\t\tconst progress = {\n\t\t\treport: (result: TextSearchResultNew) => {\n\n\t\t\t\tif (result.uri === undefined) {\n\t\t\t\t\tthrow Error('Text search result URI is undefined. Please check provider implementation.');\n\t\t\t\t}\n\t\t\t\tconst folderQuery = folderMappings.findSubstr(result.uri)!;\n\t\t\t\tconst hasSibling = folderQuery.folder.scheme === Schemas.file ?\n\t\t\t\t\thasSiblingPromiseFn(() => {\n\t\t\t\t\t\treturn this.fileUtils.readdir(resources.dirname(result.uri));\n\t\t\t\t\t}) :\n\t\t\t\t\tundefined;\n\n\t\t\t\tconst relativePath = resources.relativePath(folderQuery.folder, result.uri);\n\t\t\t\tif (relativePath) {\n\t\t\t\t\t// This method is only async when the exclude contains sibling clauses\n\t\t\t\t\tconst included = folderQuery.queryTester.includedInQuery(relativePath, path.basename(relativePath), hasSibling);\n\t\t\t\t\tif (isThenable(included)) {\n\t\t\t\t\t\ttestingPs.push(\n\t\t\t\t\t\t\tincluded.then(isIncluded => {\n\t\t\t\t\t\t\t\tif (isIncluded) {\n\t\t\t\t\t\t\t\t\tonResult(result, folderQuery.folderIdx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}));\n\t\t\t\t\t} else if (included) {\n\t\t\t\t\t\tonResult(result, folderQuery.folderIdx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tconst folderOptions = folderQueries.map(fq => this.getSearchOptionsForFolder(fq));\n\t\tconst searchOptions: TextSearchProviderOptions = {\n\t\t\tfolderOptions,\n\t\t\tmaxFileSize: this.query.maxFileSize,\n\t\t\tmaxResults: this.query.maxResults ?? DEFAULT_MAX_SEARCH_RESULTS,\n\t\t\tpreviewOptions: this.query.previewOptions ?? DEFAULT_TEXT_SEARCH_PREVIEW_OPTIONS,\n\t\t\tsurroundingContext: this.query.surroundingContext ?? 0,\n\t\t};\n\t\tif ('usePCRE2' in this.query) {\n\t\t\t(<IExtendedExtensionSearchOptions>searchOptions).usePCRE2 = this.query.usePCRE2;\n\t\t}\n\n\t\tlet result;\n\t\tif (this.queryProviderPair.query.type === QueryType.aiText) {\n\t\t\tresult = await (this.queryProviderPair as IAITextQueryProviderPair).provider.provideAITextSearchResults(this.queryProviderPair.query.contentPattern, searchOptions, progress, token);\n\t\t} else {\n\t\t\tresult = await (this.queryProviderPair as ITextQueryProviderPair).provider.provideTextSearchResults(patternInfoToQuery(this.queryProviderPair.query.contentPattern), searchOptions, progress, token);\n\t\t}\n\t\tif (testingPs.length) {\n\t\t\tawait Promise.all(testingPs);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate getSearchOptionsForFolder(fq: IFolderQuery<URI>): TextSearchProviderFolderOptions {\n\t\tconst includes = resolvePatternsForProvider(this.query.includePattern, fq.includePattern);\n\n\t\tlet excludePattern = fq.excludePattern?.map(e => ({\n\t\t\tfolder: e.folder,\n\t\t\tpatterns: resolvePatternsForProvider(this.query.excludePattern, e.pattern)\n\t\t}));\n\n\t\tif (!excludePattern || excludePattern.length === 0) {\n\t\t\texcludePattern = [{\n\t\t\t\tfolder: undefined,\n\t\t\t\tpatterns: resolvePatternsForProvider(this.query.excludePattern, undefined)\n\t\t\t}];\n\t\t}\n\t\tconst excludes = excludeToGlobPattern(excludePattern);\n\n\t\tconst options = {\n\t\t\tfolder: URI.from(fq.folder),\n\t\t\texcludes,\n\t\t\tincludes,\n\t\t\tuseIgnoreFiles: {\n\t\t\t\tlocal: !fq.disregardIgnoreFiles,\n\t\t\t\tparent: !fq.disregardParentIgnoreFiles,\n\t\t\t\tglobal: !fq.disregardGlobalIgnoreFiles\n\t\t\t},\n\t\t\tfollowSymlinks: !fq.ignoreSymlinks,\n\t\t\tencoding: (fq.fileEncoding && this.fileUtils.toCanonicalName(fq.fileEncoding)) ?? '',\n\t\t};\n\t\treturn options;\n\t}\n}\n\nfunction patternInfoToQuery(patternInfo: IPatternInfo): TextSearchQueryNew {\n\treturn {\n\t\tisCaseSensitive: patternInfo.isCaseSensitive || false,\n\t\tisRegExp: patternInfo.isRegExp || false,\n\t\tisWordMatch: patternInfo.isWordMatch || false,\n\t\tisMultiline: patternInfo.isMultiline || false,\n\t\tpattern: patternInfo.pattern\n\t};\n}\n\nexport class TextSearchResultsCollector {\n\tprivate _batchedCollector: BatchedCollector<IFileMatch>;\n\n\tprivate _currentFolderIdx: number = -1;\n\tprivate _currentUri: URI | undefined;\n\tprivate _currentFileMatch: IFileMatch | null = null;\n\n\tconstructor(private _onResult: (result: IFileMatch[]) => void) {\n\t\tthis._batchedCollector = new BatchedCollector<IFileMatch>(512, items => this.sendItems(items));\n\t}\n\n\tadd(data: TextSearchResultNew, folderIdx: number): void {\n\t\t// Collects TextSearchResults into IInternalFileMatches and collates using BatchedCollector.\n\t\t// This is efficient for ripgrep which sends results back one file at a time. It wouldn't be efficient for other search\n\t\t// providers that send results in random order. We could do this step afterwards instead.\n\t\tif (this._currentFileMatch && (this._currentFolderIdx !== folderIdx || !resources.isEqual(this._currentUri, data.uri))) {\n\t\t\tthis.pushToCollector();\n\t\t\tthis._currentFileMatch = null;\n\t\t}\n\n\t\tif (!this._currentFileMatch) {\n\t\t\tthis._currentFolderIdx = folderIdx;\n\t\t\tthis._currentFileMatch = {\n\t\t\t\tresource: data.uri,\n\t\t\t\tresults: []\n\t\t\t};\n\t\t}\n\n\t\tthis._currentFileMatch.results!.push(extensionResultToFrontendResult(data));\n\t}\n\n\tprivate pushToCollector(): void {\n\t\tconst size = this._currentFileMatch && this._currentFileMatch.results ?\n\t\t\tthis._currentFileMatch.results.length :\n\t\t\t0;\n\t\tthis._batchedCollector.addItem(this._currentFileMatch!, size);\n\t}\n\n\tflush(): void {\n\t\tthis.pushToCollector();\n\t\tthis._batchedCollector.flush();\n\t}\n\n\tprivate sendItems(items: IFileMatch[]): void {\n\t\tthis._onResult(items);\n\t}\n}\n\nfunction extensionResultToFrontendResult(data: TextSearchResultNew): ITextSearchResult {\n\t// Warning: result from RipgrepTextSearchEH has fake Range. Don't depend on any other props beyond these...\n\tif (data instanceof TextSearchMatchNew) {\n\t\treturn {\n\t\t\tpreviewText: data.previewText,\n\t\t\trangeLocations: data.ranges.map(r => ({\n\t\t\t\tpreview: {\n\t\t\t\t\tstartLineNumber: r.previewRange.start.line,\n\t\t\t\t\tstartColumn: r.previewRange.start.character,\n\t\t\t\t\tendLineNumber: r.previewRange.end.line,\n\t\t\t\t\tendColumn: r.previewRange.end.character\n\t\t\t\t} satisfies ISearchRange,\n\t\t\t\tsource: {\n\t\t\t\t\tstartLineNumber: r.sourceRange.start.line,\n\t\t\t\t\tstartColumn: r.sourceRange.start.character,\n\t\t\t\t\tendLineNumber: r.sourceRange.end.line,\n\t\t\t\t\tendColumn: r.sourceRange.end.character\n\t\t\t\t} satisfies ISearchRange,\n\t\t\t})),\n\t\t} satisfies ITextSearchMatch;\n\t} else {\n\t\treturn {\n\t\t\ttext: data.text,\n\t\t\tlineNumber: data.lineNumber\n\t\t} satisfies ITextSearchContext;\n\t}\n}\n\n\n/**\n * Collects items that have a size - before the cumulative size of collected items reaches START_BATCH_AFTER_COUNT, the callback is called for every\n * set of items collected.\n * But after that point, the callback is called with batches of maxBatchSize.\n * If the batch isn't filled within some time, the callback is also called.\n */\nexport class BatchedCollector<T> {\n\tprivate static readonly TIMEOUT = 4000;\n\n\t// After START_BATCH_AFTER_COUNT items have been collected, stop flushing on timeout\n\tprivate static readonly START_BATCH_AFTER_COUNT = 50;\n\n\tprivate totalNumberCompleted = 0;\n\tprivate batch: T[] = [];\n\tprivate batchSize = 0;\n\tprivate timeoutHandle: any;\n\n\tconstructor(private maxBatchSize: number, private cb: (items: T[]) => void) {\n\t}\n\n\taddItem(item: T, size: number): void {\n\t\tif (!item) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.addItemToBatch(item, size);\n\t}\n\n\taddItems(items: T[], size: number): void {\n\t\tif (!items) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.addItemsToBatch(items, size);\n\t}\n\n\tprivate addItemToBatch(item: T, size: number): void {\n\t\tthis.batch.push(item);\n\t\tthis.batchSize += size;\n\t\tthis.onUpdate();\n\t}\n\n\tprivate addItemsToBatch(item: T[], size: number): void {\n\t\tthis.batch = this.batch.concat(item);\n\t\tthis.batchSize += size;\n\t\tthis.onUpdate();\n\t}\n\n\tprivate onUpdate(): void {\n\t\tif (this.totalNumberCompleted < BatchedCollector.START_BATCH_AFTER_COUNT) {\n\t\t\t// Flush because we aren't batching yet\n\t\t\tthis.flush();\n\t\t} else if (this.batchSize >= this.maxBatchSize) {\n\t\t\t// Flush because the batch is full\n\t\t\tthis.flush();\n\t\t} else if (!this.timeoutHandle) {\n\t\t\t// No timeout running, start a timeout to flush\n\t\t\tthis.timeoutHandle = setTimeout(() => {\n\t\t\t\tthis.flush();\n\t\t\t}, BatchedCollector.TIMEOUT);\n\t\t}\n\t}\n\n\tflush(): void {\n\t\tif (this.batchSize) {\n\t\t\tthis.totalNumberCompleted += this.batchSize;\n\t\t\tthis.cb(this.batch);\n\t\t\tthis.batch = [];\n\t\t\tthis.batchSize = 0;\n\n\t\t\tif (this.timeoutHandle) {\n\t\t\t\tclearTimeout(this.timeoutHandle);\n\t\t\t\tthis.timeoutHandle = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n"],
  "mappings": "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",
  "names": ["result"]
}
