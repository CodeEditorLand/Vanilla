{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/search/common/textSearchManager.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isThenable } from \"../../../../base/common/async.js\";\nimport {\n\ttype CancellationToken,\n\tCancellationTokenSource,\n} from \"../../../../base/common/cancellation.js\";\nimport { toErrorMessage } from \"../../../../base/common/errorMessage.js\";\nimport { Schemas } from \"../../../../base/common/network.js\";\nimport * as path from \"../../../../base/common/path.js\";\nimport * as resources from \"../../../../base/common/resources.js\";\nimport { TernarySearchTree } from \"../../../../base/common/ternarySearchTree.js\";\nimport { URI } from \"../../../../base/common/uri.js\";\nimport {\n\tDEFAULT_MAX_SEARCH_RESULTS,\n\tDEFAULT_TEXT_SEARCH_PREVIEW_OPTIONS,\n\ttype IAITextQuery,\n\ttype IExtendedExtensionSearchOptions,\n\ttype IFileMatch,\n\ttype IFolderQuery,\n\ttype IPatternInfo,\n\ttype ISearchCompleteStats,\n\ttype ISearchRange,\n\ttype ITextQuery,\n\ttype ITextSearchContext,\n\ttype ITextSearchMatch,\n\ttype ITextSearchResult,\n\ttype ITextSearchStats,\n\tQueryGlobTester,\n\tQueryType,\n\texcludeToGlobPattern,\n\thasSiblingPromiseFn,\n\tresolvePatternsForProvider,\n} from \"./search.js\";\nimport {\n\ttype AITextSearchProviderNew,\n\ttype TextSearchCompleteNew,\n\tTextSearchMatchNew,\n\ttype TextSearchProviderFolderOptions,\n\ttype TextSearchProviderNew,\n\ttype TextSearchProviderOptions,\n\ttype TextSearchQueryNew,\n\ttype TextSearchResultNew,\n} from \"./searchExtTypes.js\";\n\nexport interface IFileUtils {\n\treaddir: (resource: URI) => Promise<string[]>;\n\ttoCanonicalName: (encoding: string) => string;\n}\ninterface IAITextQueryProviderPair {\n\tquery: IAITextQuery;\n\tprovider: AITextSearchProviderNew;\n}\n\ninterface ITextQueryProviderPair {\n\tquery: ITextQuery;\n\tprovider: TextSearchProviderNew;\n}\ninterface FolderQueryInfo {\n\tqueryTester: QueryGlobTester;\n\tfolder: URI;\n\tfolderIdx: number;\n}\n\nexport class TextSearchManager {\n\tprivate collector: TextSearchResultsCollector | null = null;\n\n\tprivate isLimitHit = false;\n\tprivate resultCount = 0;\n\n\tconstructor(\n\t\tprivate queryProviderPair:\n\t\t\t| IAITextQueryProviderPair\n\t\t\t| ITextQueryProviderPair,\n\t\tprivate fileUtils: IFileUtils,\n\t\tprivate processType: ITextSearchStats[\"type\"],\n\t) {}\n\n\tprivate get query() {\n\t\treturn this.queryProviderPair.query;\n\t}\n\n\tsearch(\n\t\tonProgress: (matches: IFileMatch[]) => void,\n\t\ttoken: CancellationToken,\n\t): Promise<ISearchCompleteStats> {\n\t\tconst folderQueries = this.query.folderQueries || [];\n\t\tconst tokenSource = new CancellationTokenSource(token);\n\n\t\treturn new Promise<ISearchCompleteStats>((resolve, reject) => {\n\t\t\tthis.collector = new TextSearchResultsCollector(onProgress);\n\n\t\t\tlet isCanceled = false;\n\t\t\tconst onResult = (\n\t\t\t\tresult: TextSearchResultNew,\n\t\t\t\tfolderIdx: number,\n\t\t\t) => {\n\t\t\t\tif (isCanceled) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!this.isLimitHit) {\n\t\t\t\t\tconst resultSize = this.resultSize(result);\n\t\t\t\t\tif (\n\t\t\t\t\t\tresult instanceof TextSearchMatchNew &&\n\t\t\t\t\t\ttypeof this.query.maxResults === \"number\" &&\n\t\t\t\t\t\tthis.resultCount + resultSize > this.query.maxResults\n\t\t\t\t\t) {\n\t\t\t\t\t\tthis.isLimitHit = true;\n\t\t\t\t\t\tisCanceled = true;\n\t\t\t\t\t\ttokenSource.cancel();\n\n\t\t\t\t\t\tresult = this.trimResultToSize(\n\t\t\t\t\t\t\tresult,\n\t\t\t\t\t\t\tthis.query.maxResults - this.resultCount,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst newResultSize = this.resultSize(result);\n\t\t\t\t\tthis.resultCount += newResultSize;\n\t\t\t\t\tconst a = result instanceof TextSearchMatchNew;\n\n\t\t\t\t\tif (newResultSize > 0 || !a) {\n\t\t\t\t\t\tthis.collector!.add(result, folderIdx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// For each root folder\n\t\t\tthis.doSearch(folderQueries, onResult, tokenSource.token).then(\n\t\t\t\t(result) => {\n\t\t\t\t\ttokenSource.dispose();\n\t\t\t\t\tthis.collector!.flush();\n\n\t\t\t\t\tresolve({\n\t\t\t\t\t\tlimitHit: this.isLimitHit || result?.limitHit,\n\t\t\t\t\t\tmessages: this.getMessagesFromResults(result),\n\t\t\t\t\t\tstats: {\n\t\t\t\t\t\t\ttype: this.processType,\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\t(err: Error) => {\n\t\t\t\t\ttokenSource.dispose();\n\t\t\t\t\tconst errMsg = toErrorMessage(err);\n\t\t\t\t\treject(new Error(errMsg));\n\t\t\t\t},\n\t\t\t);\n\t\t});\n\t}\n\n\tprivate getMessagesFromResults(\n\t\tresult: TextSearchCompleteNew | null | undefined,\n\t) {\n\t\tif (!result?.message) {\n\t\t\treturn [];\n\t\t}\n\t\tif (Array.isArray(result.message)) {\n\t\t\treturn result.message;\n\t\t}\n\t\treturn [result.message];\n\t}\n\n\tprivate resultSize(result: TextSearchResultNew): number {\n\t\tif (result instanceof TextSearchMatchNew) {\n\t\t\treturn Array.isArray(result.ranges) ? result.ranges.length : 1;\n\t\t} else {\n\t\t\t// #104400 context lines shoudn't count towards result count\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tprivate trimResultToSize(\n\t\tresult: TextSearchMatchNew,\n\t\tsize: number,\n\t): TextSearchMatchNew {\n\t\treturn new TextSearchMatchNew(\n\t\t\tresult.uri,\n\t\t\tresult.ranges.slice(0, size),\n\t\t\tresult.previewText,\n\t\t);\n\t}\n\n\tprivate async doSearch(\n\t\tfolderQueries: IFolderQuery<URI>[],\n\t\tonResult: (result: TextSearchResultNew, folderIdx: number) => void,\n\t\ttoken: CancellationToken,\n\t): Promise<TextSearchCompleteNew | null | undefined> {\n\t\tconst folderMappings: TernarySearchTree<URI, FolderQueryInfo> =\n\t\t\tTernarySearchTree.forUris<FolderQueryInfo>();\n\t\tfolderQueries.forEach((fq, i) => {\n\t\t\tconst queryTester = new QueryGlobTester(this.query, fq);\n\t\t\tfolderMappings.set(fq.folder, {\n\t\t\t\tqueryTester,\n\t\t\t\tfolder: fq.folder,\n\t\t\t\tfolderIdx: i,\n\t\t\t});\n\t\t});\n\n\t\tconst testingPs: Promise<void>[] = [];\n\t\tconst progress = {\n\t\t\treport: (result: TextSearchResultNew) => {\n\t\t\t\tif (result.uri === undefined) {\n\t\t\t\t\tthrow Error(\n\t\t\t\t\t\t\"Text search result URI is undefined. Please check provider implementation.\",\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tconst folderQuery = folderMappings.findSubstr(result.uri)!;\n\t\t\t\tconst hasSibling =\n\t\t\t\t\tfolderQuery.folder.scheme === Schemas.file\n\t\t\t\t\t\t? hasSiblingPromiseFn(() => {\n\t\t\t\t\t\t\t\treturn this.fileUtils.readdir(\n\t\t\t\t\t\t\t\t\tresources.dirname(result.uri),\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t: undefined;\n\n\t\t\t\tconst relativePath = resources.relativePath(\n\t\t\t\t\tfolderQuery.folder,\n\t\t\t\t\tresult.uri,\n\t\t\t\t);\n\t\t\t\tif (relativePath) {\n\t\t\t\t\t// This method is only async when the exclude contains sibling clauses\n\t\t\t\t\tconst included = folderQuery.queryTester.includedInQuery(\n\t\t\t\t\t\trelativePath,\n\t\t\t\t\t\tpath.basename(relativePath),\n\t\t\t\t\t\thasSibling,\n\t\t\t\t\t);\n\t\t\t\t\tif (isThenable(included)) {\n\t\t\t\t\t\ttestingPs.push(\n\t\t\t\t\t\t\tincluded.then((isIncluded) => {\n\t\t\t\t\t\t\t\tif (isIncluded) {\n\t\t\t\t\t\t\t\t\tonResult(result, folderQuery.folderIdx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (included) {\n\t\t\t\t\t\tonResult(result, folderQuery.folderIdx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\n\t\tconst folderOptions = folderQueries.map((fq) =>\n\t\t\tthis.getSearchOptionsForFolder(fq),\n\t\t);\n\t\tconst searchOptions: TextSearchProviderOptions = {\n\t\t\tfolderOptions,\n\t\t\tmaxFileSize: this.query.maxFileSize,\n\t\t\tmaxResults: this.query.maxResults ?? DEFAULT_MAX_SEARCH_RESULTS,\n\t\t\tpreviewOptions:\n\t\t\t\tthis.query.previewOptions ??\n\t\t\t\tDEFAULT_TEXT_SEARCH_PREVIEW_OPTIONS,\n\t\t\tsurroundingContext: this.query.surroundingContext ?? 0,\n\t\t};\n\t\tif (\"usePCRE2\" in this.query) {\n\t\t\t(<IExtendedExtensionSearchOptions>searchOptions).usePCRE2 =\n\t\t\t\tthis.query.usePCRE2;\n\t\t}\n\n\t\tlet result;\n\t\tif (this.queryProviderPair.query.type === QueryType.aiText) {\n\t\t\tresult = await (\n\t\t\t\tthis.queryProviderPair as IAITextQueryProviderPair\n\t\t\t).provider.provideAITextSearchResults(\n\t\t\t\tthis.queryProviderPair.query.contentPattern,\n\t\t\t\tsearchOptions,\n\t\t\t\tprogress,\n\t\t\t\ttoken,\n\t\t\t);\n\t\t} else {\n\t\t\tresult = await (\n\t\t\t\tthis.queryProviderPair as ITextQueryProviderPair\n\t\t\t).provider.provideTextSearchResults(\n\t\t\t\tpatternInfoToQuery(this.queryProviderPair.query.contentPattern),\n\t\t\t\tsearchOptions,\n\t\t\t\tprogress,\n\t\t\t\ttoken,\n\t\t\t);\n\t\t}\n\t\tif (testingPs.length) {\n\t\t\tawait Promise.all(testingPs);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate getSearchOptionsForFolder(\n\t\tfq: IFolderQuery<URI>,\n\t): TextSearchProviderFolderOptions {\n\t\tconst includes = resolvePatternsForProvider(\n\t\t\tthis.query.includePattern,\n\t\t\tfq.includePattern,\n\t\t);\n\n\t\tlet excludePattern = fq.excludePattern?.map((e) => ({\n\t\t\tfolder: e.folder,\n\t\t\tpatterns: resolvePatternsForProvider(\n\t\t\t\tthis.query.excludePattern,\n\t\t\t\te.pattern,\n\t\t\t),\n\t\t}));\n\n\t\tif (!excludePattern || excludePattern.length === 0) {\n\t\t\texcludePattern = [\n\t\t\t\t{\n\t\t\t\t\tfolder: undefined,\n\t\t\t\t\tpatterns: resolvePatternsForProvider(\n\t\t\t\t\t\tthis.query.excludePattern,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t];\n\t\t}\n\t\tconst excludes = excludeToGlobPattern(excludePattern);\n\n\t\tconst options = {\n\t\t\tfolder: URI.from(fq.folder),\n\t\t\texcludes,\n\t\t\tincludes,\n\t\t\tuseIgnoreFiles: {\n\t\t\t\tlocal: !fq.disregardIgnoreFiles,\n\t\t\t\tparent: !fq.disregardParentIgnoreFiles,\n\t\t\t\tglobal: !fq.disregardGlobalIgnoreFiles,\n\t\t\t},\n\t\t\tfollowSymlinks: !fq.ignoreSymlinks,\n\t\t\tencoding:\n\t\t\t\t(fq.fileEncoding &&\n\t\t\t\t\tthis.fileUtils.toCanonicalName(fq.fileEncoding)) ??\n\t\t\t\t\"\",\n\t\t};\n\t\treturn options;\n\t}\n}\n\nfunction patternInfoToQuery(patternInfo: IPatternInfo): TextSearchQueryNew {\n\treturn {\n\t\tisCaseSensitive: patternInfo.isCaseSensitive || false,\n\t\tisRegExp: patternInfo.isRegExp || false,\n\t\tisWordMatch: patternInfo.isWordMatch || false,\n\t\tisMultiline: patternInfo.isMultiline || false,\n\t\tpattern: patternInfo.pattern,\n\t};\n}\n\nexport class TextSearchResultsCollector {\n\tprivate _batchedCollector: BatchedCollector<IFileMatch>;\n\n\tprivate _currentFolderIdx = -1;\n\tprivate _currentUri: URI | undefined;\n\tprivate _currentFileMatch: IFileMatch | null = null;\n\n\tconstructor(private _onResult: (result: IFileMatch[]) => void) {\n\t\tthis._batchedCollector = new BatchedCollector<IFileMatch>(\n\t\t\t512,\n\t\t\t(items) => this.sendItems(items),\n\t\t);\n\t}\n\n\tadd(data: TextSearchResultNew, folderIdx: number): void {\n\t\t// Collects TextSearchResults into IInternalFileMatches and collates using BatchedCollector.\n\t\t// This is efficient for ripgrep which sends results back one file at a time. It wouldn't be efficient for other search\n\t\t// providers that send results in random order. We could do this step afterwards instead.\n\t\tif (\n\t\t\tthis._currentFileMatch &&\n\t\t\t(this._currentFolderIdx !== folderIdx ||\n\t\t\t\t!resources.isEqual(this._currentUri, data.uri))\n\t\t) {\n\t\t\tthis.pushToCollector();\n\t\t\tthis._currentFileMatch = null;\n\t\t}\n\n\t\tif (!this._currentFileMatch) {\n\t\t\tthis._currentFolderIdx = folderIdx;\n\t\t\tthis._currentFileMatch = {\n\t\t\t\tresource: data.uri,\n\t\t\t\tresults: [],\n\t\t\t};\n\t\t}\n\n\t\tthis._currentFileMatch.results!.push(\n\t\t\textensionResultToFrontendResult(data),\n\t\t);\n\t}\n\n\tprivate pushToCollector(): void {\n\t\tconst size =\n\t\t\tthis._currentFileMatch && this._currentFileMatch.results\n\t\t\t\t? this._currentFileMatch.results.length\n\t\t\t\t: 0;\n\t\tthis._batchedCollector.addItem(this._currentFileMatch!, size);\n\t}\n\n\tflush(): void {\n\t\tthis.pushToCollector();\n\t\tthis._batchedCollector.flush();\n\t}\n\n\tprivate sendItems(items: IFileMatch[]): void {\n\t\tthis._onResult(items);\n\t}\n}\n\nfunction extensionResultToFrontendResult(\n\tdata: TextSearchResultNew,\n): ITextSearchResult {\n\t// Warning: result from RipgrepTextSearchEH has fake Range. Don't depend on any other props beyond these...\n\tif (data instanceof TextSearchMatchNew) {\n\t\treturn {\n\t\t\tpreviewText: data.previewText,\n\t\t\trangeLocations: data.ranges.map((r) => ({\n\t\t\t\tpreview: {\n\t\t\t\t\tstartLineNumber: r.previewRange.start.line,\n\t\t\t\t\tstartColumn: r.previewRange.start.character,\n\t\t\t\t\tendLineNumber: r.previewRange.end.line,\n\t\t\t\t\tendColumn: r.previewRange.end.character,\n\t\t\t\t} satisfies ISearchRange,\n\t\t\t\tsource: {\n\t\t\t\t\tstartLineNumber: r.sourceRange.start.line,\n\t\t\t\t\tstartColumn: r.sourceRange.start.character,\n\t\t\t\t\tendLineNumber: r.sourceRange.end.line,\n\t\t\t\t\tendColumn: r.sourceRange.end.character,\n\t\t\t\t} satisfies ISearchRange,\n\t\t\t})),\n\t\t} satisfies ITextSearchMatch;\n\t} else {\n\t\treturn {\n\t\t\ttext: data.text,\n\t\t\tlineNumber: data.lineNumber,\n\t\t} satisfies ITextSearchContext;\n\t}\n}\n\n/**\n * Collects items that have a size - before the cumulative size of collected items reaches START_BATCH_AFTER_COUNT, the callback is called for every\n * set of items collected.\n * But after that point, the callback is called with batches of maxBatchSize.\n * If the batch isn't filled within some time, the callback is also called.\n */\nexport class BatchedCollector<T> {\n\tprivate static readonly TIMEOUT = 4000;\n\n\t// After START_BATCH_AFTER_COUNT items have been collected, stop flushing on timeout\n\tprivate static readonly START_BATCH_AFTER_COUNT = 50;\n\n\tprivate totalNumberCompleted = 0;\n\tprivate batch: T[] = [];\n\tprivate batchSize = 0;\n\tprivate timeoutHandle: any;\n\n\tconstructor(\n\t\tprivate maxBatchSize: number,\n\t\tprivate cb: (items: T[]) => void,\n\t) {}\n\n\taddItem(item: T, size: number): void {\n\t\tif (!item) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.addItemToBatch(item, size);\n\t}\n\n\taddItems(items: T[], size: number): void {\n\t\tif (!items) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.addItemsToBatch(items, size);\n\t}\n\n\tprivate addItemToBatch(item: T, size: number): void {\n\t\tthis.batch.push(item);\n\t\tthis.batchSize += size;\n\t\tthis.onUpdate();\n\t}\n\n\tprivate addItemsToBatch(item: T[], size: number): void {\n\t\tthis.batch = this.batch.concat(item);\n\t\tthis.batchSize += size;\n\t\tthis.onUpdate();\n\t}\n\n\tprivate onUpdate(): void {\n\t\tif (\n\t\t\tthis.totalNumberCompleted < BatchedCollector.START_BATCH_AFTER_COUNT\n\t\t) {\n\t\t\t// Flush because we aren't batching yet\n\t\t\tthis.flush();\n\t\t} else if (this.batchSize >= this.maxBatchSize) {\n\t\t\t// Flush because the batch is full\n\t\t\tthis.flush();\n\t\t} else if (!this.timeoutHandle) {\n\t\t\t// No timeout running, start a timeout to flush\n\t\t\tthis.timeoutHandle = setTimeout(() => {\n\t\t\t\tthis.flush();\n\t\t\t}, BatchedCollector.TIMEOUT);\n\t\t}\n\t}\n\n\tflush(): void {\n\t\tif (this.batchSize) {\n\t\t\tthis.totalNumberCompleted += this.batchSize;\n\t\t\tthis.cb(this.batch);\n\t\t\tthis.batch = [];\n\t\t\tthis.batchSize = 0;\n\n\t\t\tif (this.timeoutHandle) {\n\t\t\t\tclearTimeout(this.timeoutHandle);\n\t\t\t\tthis.timeoutHandle = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n"],
  "mappings": "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",
  "names": ["result"]
}
