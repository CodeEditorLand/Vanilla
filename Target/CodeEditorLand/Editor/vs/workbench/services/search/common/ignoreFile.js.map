{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/search/common/ignoreFile.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as glob from \"../../../../base/common/glob.js\";\n\nexport class IgnoreFile {\n\tprivate isPathIgnored: (\n\t\tpath: string,\n\t\tisDir: boolean,\n\t\tparent?: IgnoreFile,\n\t) => boolean;\n\n\tconstructor(\n\t\tcontents: string,\n\t\tprivate readonly location: string,\n\t\tprivate readonly parent?: IgnoreFile,\n\t) {\n\t\tif (location[location.length - 1] === \"\\\\\") {\n\t\t\tthrow Error(\n\t\t\t\t\"Unexpected path format, do not use trailing backslashes\",\n\t\t\t);\n\t\t}\n\t\tif (location[location.length - 1] !== \"/\") {\n\t\t\tlocation += \"/\";\n\t\t}\n\t\tthis.isPathIgnored = this.parseIgnoreFile(\n\t\t\tcontents,\n\t\t\tthis.location,\n\t\t\tthis.parent,\n\t\t);\n\t}\n\n\t/**\n\t * Updates the contents of the ignorefile. Preservering the location and parent\n\t * @param contents The new contents of the gitignore file\n\t */\n\tupdateContents(contents: string) {\n\t\tthis.isPathIgnored = this.parseIgnoreFile(\n\t\t\tcontents,\n\t\t\tthis.location,\n\t\t\tthis.parent,\n\t\t);\n\t}\n\n\t/**\n\t * Returns true if a path in a traversable directory has not been ignored.\n\t *\n\t * Note: For performance reasons this does not check if the parent directories have been ignored,\n\t * so it should always be used in tandem with `shouldTraverseDir` when walking a directory.\n\t *\n\t * In cases where a path must be tested in isolation, `isArbitraryPathIncluded` should be used.\n\t */\n\tisPathIncludedInTraversal(path: string, isDir: boolean): boolean {\n\t\tif (path[0] !== \"/\" || path[path.length - 1] === \"/\") {\n\t\t\tthrow Error(\n\t\t\t\t\"Unexpected path format, expectred to begin with slash and end without. got:\" +\n\t\t\t\t\tpath,\n\t\t\t);\n\t\t}\n\n\t\tconst ignored = this.isPathIgnored(path, isDir);\n\n\t\treturn !ignored;\n\t}\n\n\t/**\n\t * Returns true if an arbitrary path has not been ignored.\n\t * This is an expensive operation and should only be used ouside of traversals.\n\t */\n\tisArbitraryPathIgnored(path: string, isDir: boolean): boolean {\n\t\tif (path[0] !== \"/\" || path[path.length - 1] === \"/\") {\n\t\t\tthrow Error(\n\t\t\t\t\"Unexpected path format, expectred to begin with slash and end without. got:\" +\n\t\t\t\t\tpath,\n\t\t\t);\n\t\t}\n\n\t\tconst segments = path.split(\"/\").filter((x) => x);\n\t\tlet ignored = false;\n\n\t\tlet walkingPath = \"\";\n\n\t\tfor (let i = 0; i < segments.length; i++) {\n\t\t\tconst isLast = i === segments.length - 1;\n\t\t\tconst segment = segments[i];\n\n\t\t\twalkingPath = walkingPath + \"/\" + segment;\n\n\t\t\tif (\n\t\t\t\t!this.isPathIncludedInTraversal(\n\t\t\t\t\twalkingPath,\n\t\t\t\t\tisLast ? isDir : true,\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tignored = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn ignored;\n\t}\n\n\tprivate gitignoreLinesToExpression(\n\t\tlines: string[],\n\t\tdirPath: string,\n\t\ttrimForExclusions: boolean,\n\t): glob.ParsedExpression {\n\t\tconst includeLines = lines.map((line) =>\n\t\t\tthis.gitignoreLineToGlob(line, dirPath),\n\t\t);\n\n\t\tconst includeExpression: glob.IExpression = Object.create(null);\n\t\tfor (const line of includeLines) {\n\t\t\tincludeExpression[line] = true;\n\t\t}\n\n\t\treturn glob.parse(includeExpression, { trimForExclusions });\n\t}\n\n\tprivate parseIgnoreFile(\n\t\tignoreContents: string,\n\t\tdirPath: string,\n\t\tparent: IgnoreFile | undefined,\n\t): (path: string, isDir: boolean) => boolean {\n\t\tconst contentLines = ignoreContents\n\t\t\t.split(\"\\n\")\n\t\t\t.map((line) => line.trim())\n\t\t\t.filter((line) => line && line[0] !== \"#\");\n\n\t\t// Pull out all the lines that end with `/`, those only apply to directories\n\t\tconst fileLines = contentLines.filter((line) => !line.endsWith(\"/\"));\n\n\t\tconst fileIgnoreLines = fileLines.filter((line) => !line.includes(\"!\"));\n\t\tconst isFileIgnored = this.gitignoreLinesToExpression(\n\t\t\tfileIgnoreLines,\n\t\t\tdirPath,\n\t\t\ttrue,\n\t\t);\n\n\t\t// TODO: Slight hack... this naieve approach may reintroduce too many files in cases of weirdly complex .gitignores\n\t\tconst fileIncludeLines = fileLines\n\t\t\t.filter((line) => line.includes(\"!\"))\n\t\t\t.map((line) => line.replace(/!/g, \"\"));\n\t\tconst isFileIncluded = this.gitignoreLinesToExpression(\n\t\t\tfileIncludeLines,\n\t\t\tdirPath,\n\t\t\tfalse,\n\t\t);\n\n\t\t// When checking if a dir is ignored we can use all lines\n\t\tconst dirIgnoreLines = contentLines.filter(\n\t\t\t(line) => !line.includes(\"!\"),\n\t\t);\n\t\tconst isDirIgnored = this.gitignoreLinesToExpression(\n\t\t\tdirIgnoreLines,\n\t\t\tdirPath,\n\t\t\ttrue,\n\t\t);\n\n\t\t// Same hack.\n\t\tconst dirIncludeLines = contentLines\n\t\t\t.filter((line) => line.includes(\"!\"))\n\t\t\t.map((line) => line.replace(/!/g, \"\"));\n\t\tconst isDirIncluded = this.gitignoreLinesToExpression(\n\t\t\tdirIncludeLines,\n\t\t\tdirPath,\n\t\t\tfalse,\n\t\t);\n\n\t\tconst isPathIgnored = (path: string, isDir: boolean) => {\n\t\t\tif (!path.startsWith(dirPath)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (isDir && isDirIgnored(path) && !isDirIncluded(path)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (isFileIgnored(path) && !isFileIncluded(path)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (parent) {\n\t\t\t\treturn parent.isPathIgnored(path, isDir);\n\t\t\t}\n\n\t\t\treturn false;\n\t\t};\n\n\t\treturn isPathIgnored;\n\t}\n\n\tprivate gitignoreLineToGlob(line: string, dirPath: string): string {\n\t\tconst firstSep = line.indexOf(\"/\");\n\t\tif (firstSep === -1 || firstSep === line.length - 1) {\n\t\t\tline = \"**/\" + line;\n\t\t} else {\n\t\t\tif (firstSep === 0) {\n\t\t\t\tif (dirPath.slice(-1) === \"/\") {\n\t\t\t\t\tline = line.slice(1);\n\t\t\t\t}\n\t\t\t} else if (dirPath.slice(-1) !== \"/\") {\n\t\t\t\tline = \"/\" + line;\n\t\t\t}\n\t\t\tline = dirPath + line;\n\t\t}\n\n\t\treturn line;\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
