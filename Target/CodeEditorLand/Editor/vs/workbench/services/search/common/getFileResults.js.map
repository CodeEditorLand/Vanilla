{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/search/common/getFileResults.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ITextSearchMatch, ITextSearchPreviewOptions, ITextSearchResult } from './search.js';\nimport { Range } from '../../../../editor/common/core/range.js';\n\nexport const getFileResults = (\n\tbytes: Uint8Array,\n\tpattern: RegExp,\n\toptions: {\n\t\tsurroundingContext: number;\n\t\tpreviewOptions: ITextSearchPreviewOptions | undefined;\n\t\tremainingResultQuota: number;\n\t}\n): ITextSearchResult[] => {\n\n\tlet text: string;\n\tif (bytes[0] === 0xff && bytes[1] === 0xfe) {\n\t\ttext = new TextDecoder('utf-16le').decode(bytes);\n\t} else if (bytes[0] === 0xfe && bytes[1] === 0xff) {\n\t\ttext = new TextDecoder('utf-16be').decode(bytes);\n\t} else {\n\t\ttext = new TextDecoder('utf8').decode(bytes);\n\t\tif (text.slice(0, 1000).includes('\\uFFFD') && bytes.includes(0)) {\n\t\t\treturn [];\n\t\t}\n\t}\n\n\tconst results: ITextSearchResult[] = [];\n\n\tconst patternIndecies: { matchStartIndex: number; matchedText: string }[] = [];\n\n\tlet patternMatch: RegExpExecArray | null = null;\n\tlet remainingResultQuota = options.remainingResultQuota;\n\twhile (remainingResultQuota >= 0 && (patternMatch = pattern.exec(text))) {\n\t\tpatternIndecies.push({ matchStartIndex: patternMatch.index, matchedText: patternMatch[0] });\n\t\tremainingResultQuota--;\n\t}\n\n\tif (patternIndecies.length) {\n\t\tconst contextLinesNeeded = new Set<number>();\n\t\tconst resultLines = new Set<number>();\n\n\t\tconst lineRanges: { start: number; end: number }[] = [];\n\t\tconst readLine = (lineNumber: number) => text.slice(lineRanges[lineNumber].start, lineRanges[lineNumber].end);\n\n\t\tlet prevLineEnd = 0;\n\t\tlet lineEndingMatch: RegExpExecArray | null = null;\n\t\tconst lineEndRegex = /\\r?\\n/g;\n\t\twhile ((lineEndingMatch = lineEndRegex.exec(text))) {\n\t\t\tlineRanges.push({ start: prevLineEnd, end: lineEndingMatch.index });\n\t\t\tprevLineEnd = lineEndingMatch.index + lineEndingMatch[0].length;\n\t\t}\n\t\tif (prevLineEnd < text.length) { lineRanges.push({ start: prevLineEnd, end: text.length }); }\n\n\t\tlet startLine = 0;\n\t\tfor (const { matchStartIndex, matchedText } of patternIndecies) {\n\t\t\tif (remainingResultQuota < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\twhile (Boolean(lineRanges[startLine + 1]) && matchStartIndex > lineRanges[startLine].end) {\n\t\t\t\tstartLine++;\n\t\t\t}\n\t\t\tlet endLine = startLine;\n\t\t\twhile (Boolean(lineRanges[endLine + 1]) && matchStartIndex + matchedText.length > lineRanges[endLine].end) {\n\t\t\t\tendLine++;\n\t\t\t}\n\n\t\t\tif (options.surroundingContext) {\n\t\t\t\tfor (let contextLine = Math.max(0, startLine - options.surroundingContext); contextLine < startLine; contextLine++) {\n\t\t\t\t\tcontextLinesNeeded.add(contextLine);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet previewText = '';\n\t\t\tlet offset = 0;\n\t\t\tfor (let matchLine = startLine; matchLine <= endLine; matchLine++) {\n\t\t\t\tlet previewLine = readLine(matchLine);\n\t\t\t\tif (options.previewOptions?.charsPerLine && previewLine.length > options.previewOptions.charsPerLine) {\n\t\t\t\t\toffset = Math.max(matchStartIndex - lineRanges[startLine].start - 20, 0);\n\t\t\t\t\tpreviewLine = previewLine.substr(offset, options.previewOptions.charsPerLine);\n\t\t\t\t}\n\t\t\t\tpreviewText += `${previewLine}\\n`;\n\t\t\t\tresultLines.add(matchLine);\n\t\t\t}\n\n\t\t\tconst fileRange = new Range(\n\t\t\t\tstartLine,\n\t\t\t\tmatchStartIndex - lineRanges[startLine].start,\n\t\t\t\tendLine,\n\t\t\t\tmatchStartIndex + matchedText.length - lineRanges[endLine].start\n\t\t\t);\n\t\t\tconst previewRange = new Range(\n\t\t\t\t0,\n\t\t\t\tmatchStartIndex - lineRanges[startLine].start - offset,\n\t\t\t\tendLine - startLine,\n\t\t\t\tmatchStartIndex + matchedText.length - lineRanges[endLine].start - (endLine === startLine ? offset : 0)\n\t\t\t);\n\n\t\t\tconst match: ITextSearchMatch = {\n\t\t\t\trangeLocations: [{\n\t\t\t\t\tsource: fileRange,\n\t\t\t\t\tpreview: previewRange,\n\t\t\t\t}],\n\t\t\t\tpreviewText: previewText\n\t\t\t};\n\n\t\t\tresults.push(match);\n\n\t\t\tif (options.surroundingContext) {\n\t\t\t\tfor (let contextLine = endLine + 1; contextLine <= Math.min(endLine + options.surroundingContext, lineRanges.length - 1); contextLine++) {\n\t\t\t\t\tcontextLinesNeeded.add(contextLine);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (const contextLine of contextLinesNeeded) {\n\t\t\tif (!resultLines.has(contextLine)) {\n\n\t\t\t\tresults.push({\n\t\t\t\t\ttext: readLine(contextLine),\n\t\t\t\t\tlineNumber: contextLine + 1,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\treturn results;\n};\n"],
  "mappings": "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",
  "names": []
}
