{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/search/common/queryBuilder.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from \"../../../../base/common/arrays.js\";\nimport * as collections from \"../../../../base/common/collections.js\";\nimport * as glob from \"../../../../base/common/glob.js\";\nimport { untildify } from \"../../../../base/common/labels.js\";\nimport { ResourceMap } from \"../../../../base/common/map.js\";\nimport { Schemas } from \"../../../../base/common/network.js\";\nimport * as path from \"../../../../base/common/path.js\";\nimport {\n\tbasename,\n\tisAbsolutePath,\n\tisEqual,\n\trelativePath,\n} from \"../../../../base/common/resources.js\";\nimport * as strings from \"../../../../base/common/strings.js\";\nimport { assertIsDefined, isDefined } from \"../../../../base/common/types.js\";\nimport {\n\tURI,\n\ttype UriComponents,\n\tURI as uri,\n} from \"../../../../base/common/uri.js\";\nimport { isMultilineRegexSource } from \"../../../../editor/common/model/textModelSearch.js\";\nimport * as nls from \"../../../../nls.js\";\nimport { IConfigurationService } from \"../../../../platform/configuration/common/configuration.js\";\nimport { ILogService } from \"../../../../platform/log/common/log.js\";\nimport { IUriIdentityService } from \"../../../../platform/uriIdentity/common/uriIdentity.js\";\nimport {\n\tIWorkspaceContextService,\n\ttype IWorkspaceFolderData,\n\tWorkbenchState,\n\ttoWorkspaceFolder,\n} from \"../../../../platform/workspace/common/workspace.js\";\nimport { IEditorGroupsService } from \"../../editor/common/editorGroupsService.js\";\nimport { IPathService } from \"../../path/common/pathService.js\";\nimport {\n\ttype ExcludeGlobPattern,\n\ttype ICommonQueryProps,\n\ttype IFileQuery,\n\ttype IFolderQuery,\n\ttype IPatternInfo,\n\ttype ISearchConfiguration,\n\ttype ITextQuery,\n\ttype ITextSearchPreviewOptions,\n\tQueryType,\n\tgetExcludes,\n\tpathIncludedInQuery,\n} from \"./search.js\";\nimport type { GlobPattern } from \"./searchExtTypes.js\";\n\n/**\n * One folder to search and a glob expression that should be applied.\n */\ninterface IOneSearchPathPattern {\n\tsearchPath: uri;\n\tpattern?: string;\n}\n\n/**\n * One folder to search and a set of glob expressions that should be applied.\n */\nexport interface ISearchPathPattern {\n\tsearchPath: uri;\n\tpattern?: glob.IExpression;\n}\n\ntype ISearchPathPatternBuilder = string | string[];\n\nexport interface ISearchPatternBuilder<U extends UriComponents> {\n\turi?: U;\n\tpattern: ISearchPathPatternBuilder;\n}\n\nexport function isISearchPatternBuilder<U extends UriComponents>(\n\tobject: ISearchPatternBuilder<U> | ISearchPathPatternBuilder,\n): object is ISearchPatternBuilder<U> {\n\treturn typeof object === \"object\" && \"uri\" in object && \"pattern\" in object;\n}\n\nexport function globPatternToISearchPatternBuilder(\n\tglobPattern: GlobPattern,\n): ISearchPatternBuilder<URI> {\n\tif (typeof globPattern === \"string\") {\n\t\treturn {\n\t\t\tpattern: globPattern,\n\t\t};\n\t}\n\n\treturn {\n\t\tpattern: globPattern.pattern,\n\t\turi: globPattern.baseUri,\n\t};\n}\n\n/**\n * A set of search paths and a set of glob expressions that should be applied.\n */\nexport interface ISearchPathsInfo {\n\tsearchPaths?: ISearchPathPattern[];\n\tpattern?: glob.IExpression;\n}\n\ninterface ICommonQueryBuilderOptions<U extends UriComponents = URI> {\n\t_reason?: string;\n\texcludePattern?: ISearchPatternBuilder<U>[];\n\tincludePattern?: ISearchPathPatternBuilder;\n\textraFileResources?: U[];\n\n\t/** Parse the special ./ syntax supported by the searchview, and expand foo to ** /foo */\n\texpandPatterns?: boolean;\n\n\tmaxResults?: number;\n\tmaxFileSize?: number;\n\tdisregardIgnoreFiles?: boolean;\n\tdisregardGlobalIgnoreFiles?: boolean;\n\tdisregardParentIgnoreFiles?: boolean;\n\tdisregardExcludeSettings?: boolean;\n\tdisregardSearchExcludeSettings?: boolean;\n\tignoreSymlinks?: boolean;\n\tonlyOpenEditors?: boolean;\n\tonlyFileScheme?: boolean;\n}\n\nexport interface IFileQueryBuilderOptions<U extends UriComponents = URI>\n\textends ICommonQueryBuilderOptions<U> {\n\tfilePattern?: string;\n\texists?: boolean;\n\tsortByScore?: boolean;\n\tcacheKey?: string;\n\tshouldGlobSearch?: boolean;\n}\n\nexport interface ITextQueryBuilderOptions<U extends UriComponents = URI>\n\textends ICommonQueryBuilderOptions<U> {\n\tpreviewOptions?: ITextSearchPreviewOptions;\n\tfileEncoding?: string;\n\tsurroundingContext?: number;\n\tisSmartCase?: boolean;\n\tnotebookSearchConfig?: {\n\t\tincludeMarkupInput: boolean;\n\t\tincludeMarkupPreview: boolean;\n\t\tincludeCodeInput: boolean;\n\t\tincludeOutput: boolean;\n\t};\n}\n\nexport class QueryBuilder {\n\tconstructor(\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t\t@IWorkspaceContextService private readonly workspaceContextService: IWorkspaceContextService,\n\t\t@IEditorGroupsService private readonly editorGroupsService: IEditorGroupsService,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IPathService private readonly pathService: IPathService,\n\t\t@IUriIdentityService private readonly uriIdentityService: IUriIdentityService\n\t) {\n\t}\n\n\ttext(\n\t\tcontentPattern: IPatternInfo,\n\t\tfolderResources?: uri[],\n\t\toptions: ITextQueryBuilderOptions = {},\n\t): ITextQuery {\n\t\tcontentPattern = this.getContentPattern(contentPattern, options);\n\t\tconst searchConfig =\n\t\t\tthis.configurationService.getValue<ISearchConfiguration>();\n\n\t\tconst fallbackToPCRE =\n\t\t\tfolderResources &&\n\t\t\tfolderResources.some((folder) => {\n\t\t\t\tconst folderConfig =\n\t\t\t\t\tthis.configurationService.getValue<ISearchConfiguration>({\n\t\t\t\t\t\tresource: folder,\n\t\t\t\t\t});\n\t\t\t\treturn !folderConfig.search.useRipgrep;\n\t\t\t});\n\n\t\tconst commonQuery = this.commonQuery(\n\t\t\tfolderResources?.map(toWorkspaceFolder),\n\t\t\toptions,\n\t\t);\n\t\treturn {\n\t\t\t...commonQuery,\n\t\t\ttype: QueryType.Text,\n\t\t\tcontentPattern,\n\t\t\tpreviewOptions: options.previewOptions,\n\t\t\tmaxFileSize: options.maxFileSize,\n\t\t\tusePCRE2: searchConfig.search.usePCRE2 || fallbackToPCRE || false,\n\t\t\tsurroundingContext: options.surroundingContext,\n\t\t\tuserDisabledExcludesAndIgnoreFiles:\n\t\t\t\toptions.disregardExcludeSettings &&\n\t\t\t\toptions.disregardIgnoreFiles,\n\t\t};\n\t}\n\n\t/**\n\t * Adjusts input pattern for config\n\t */\n\tprivate getContentPattern(\n\t\tinputPattern: IPatternInfo,\n\t\toptions: ITextQueryBuilderOptions,\n\t): IPatternInfo {\n\t\tconst searchConfig =\n\t\t\tthis.configurationService.getValue<ISearchConfiguration>();\n\n\t\tif (inputPattern.isRegExp) {\n\t\t\tinputPattern.pattern = inputPattern.pattern.replace(\n\t\t\t\t/\\r?\\n/g,\n\t\t\t\t\"\\\\n\",\n\t\t\t);\n\t\t}\n\n\t\tconst newPattern = {\n\t\t\t...inputPattern,\n\t\t\twordSeparators: searchConfig.editor.wordSeparators,\n\t\t};\n\n\t\tif (this.isCaseSensitive(inputPattern, options)) {\n\t\t\tnewPattern.isCaseSensitive = true;\n\t\t}\n\n\t\tif (this.isMultiline(inputPattern)) {\n\t\t\tnewPattern.isMultiline = true;\n\t\t}\n\n\t\tif (options.notebookSearchConfig?.includeMarkupInput) {\n\t\t\tif (!newPattern.notebookInfo) {\n\t\t\t\tnewPattern.notebookInfo = {};\n\t\t\t}\n\t\t\tnewPattern.notebookInfo.isInNotebookMarkdownInput =\n\t\t\t\toptions.notebookSearchConfig.includeMarkupInput;\n\t\t}\n\n\t\tif (options.notebookSearchConfig?.includeMarkupPreview) {\n\t\t\tif (!newPattern.notebookInfo) {\n\t\t\t\tnewPattern.notebookInfo = {};\n\t\t\t}\n\t\t\tnewPattern.notebookInfo.isInNotebookMarkdownPreview =\n\t\t\t\toptions.notebookSearchConfig.includeMarkupPreview;\n\t\t}\n\n\t\tif (options.notebookSearchConfig?.includeCodeInput) {\n\t\t\tif (!newPattern.notebookInfo) {\n\t\t\t\tnewPattern.notebookInfo = {};\n\t\t\t}\n\t\t\tnewPattern.notebookInfo.isInNotebookCellInput =\n\t\t\t\toptions.notebookSearchConfig.includeCodeInput;\n\t\t}\n\n\t\tif (options.notebookSearchConfig?.includeOutput) {\n\t\t\tif (!newPattern.notebookInfo) {\n\t\t\t\tnewPattern.notebookInfo = {};\n\t\t\t}\n\t\t\tnewPattern.notebookInfo.isInNotebookCellOutput =\n\t\t\t\toptions.notebookSearchConfig.includeOutput;\n\t\t}\n\n\t\treturn newPattern;\n\t}\n\n\tfile(\n\t\tfolders: (IWorkspaceFolderData | URI)[],\n\t\toptions: IFileQueryBuilderOptions = {},\n\t): IFileQuery {\n\t\tconst commonQuery = this.commonQuery(folders, options);\n\t\treturn {\n\t\t\t...commonQuery,\n\t\t\ttype: QueryType.File,\n\t\t\tfilePattern: options.filePattern\n\t\t\t\t? options.filePattern.trim()\n\t\t\t\t: options.filePattern,\n\t\t\texists: options.exists,\n\t\t\tsortByScore: options.sortByScore,\n\t\t\tcacheKey: options.cacheKey,\n\t\t\tshouldGlobMatchFilePattern: options.shouldGlobSearch,\n\t\t};\n\t}\n\n\tprivate handleIncludeExclude(\n\t\tpattern: string | string[] | undefined,\n\t\texpandPatterns: boolean | undefined,\n\t): ISearchPathsInfo {\n\t\tif (!pattern) {\n\t\t\treturn {};\n\t\t}\n\n\t\tif (Array.isArray(pattern)) {\n\t\t\tpattern = pattern.filter((p) => p.length > 0).map(normalizeSlashes);\n\t\t\tif (!pattern.length) {\n\t\t\t\treturn {};\n\t\t\t}\n\t\t} else {\n\t\t\tpattern = normalizeSlashes(pattern);\n\t\t}\n\t\treturn expandPatterns\n\t\t\t? this.parseSearchPaths(pattern)\n\t\t\t: {\n\t\t\t\t\tpattern: patternListToIExpression(\n\t\t\t\t\t\t...(Array.isArray(pattern) ? pattern : [pattern]),\n\t\t\t\t\t),\n\t\t\t\t};\n\t}\n\n\tprivate commonQuery(\n\t\tfolderResources: (IWorkspaceFolderData | URI)[] = [],\n\t\toptions: ICommonQueryBuilderOptions = {},\n\t): ICommonQueryProps<uri> {\n\t\tlet excludePatterns: string | string[] | undefined = Array.isArray(\n\t\t\toptions.excludePattern,\n\t\t)\n\t\t\t? options.excludePattern.flatMap((p) => p.pattern)\n\t\t\t: options.excludePattern;\n\t\texcludePatterns =\n\t\t\texcludePatterns?.length === 1\n\t\t\t\t? excludePatterns[0]\n\t\t\t\t: excludePatterns;\n\t\tconst includeSearchPathsInfo: ISearchPathsInfo =\n\t\t\tthis.handleIncludeExclude(\n\t\t\t\toptions.includePattern,\n\t\t\t\toptions.expandPatterns,\n\t\t\t);\n\t\tconst excludeSearchPathsInfo: ISearchPathsInfo =\n\t\t\tthis.handleIncludeExclude(excludePatterns, options.expandPatterns);\n\n\t\t// Build folderQueries from searchPaths, if given, otherwise folderResources\n\t\tconst includeFolderName = folderResources.length > 1;\n\t\tconst folderQueries = (\n\t\t\tincludeSearchPathsInfo.searchPaths &&\n\t\t\tincludeSearchPathsInfo.searchPaths.length\n\t\t\t\t? includeSearchPathsInfo.searchPaths.map((searchPath) =>\n\t\t\t\t\t\tthis.getFolderQueryForSearchPath(\n\t\t\t\t\t\t\tsearchPath,\n\t\t\t\t\t\t\toptions,\n\t\t\t\t\t\t\texcludeSearchPathsInfo,\n\t\t\t\t\t\t),\n\t\t\t\t\t)\n\t\t\t\t: folderResources.map((folder) =>\n\t\t\t\t\t\tthis.getFolderQueryForRoot(\n\t\t\t\t\t\t\tfolder,\n\t\t\t\t\t\t\toptions,\n\t\t\t\t\t\t\texcludeSearchPathsInfo,\n\t\t\t\t\t\t\tincludeFolderName,\n\t\t\t\t\t\t),\n\t\t\t\t\t)\n\t\t).filter((query) => !!query) as IFolderQuery[];\n\n\t\tconst queryProps: ICommonQueryProps<uri> = {\n\t\t\t_reason: options._reason,\n\t\t\tfolderQueries,\n\t\t\tusingSearchPaths: !!(\n\t\t\t\tincludeSearchPathsInfo.searchPaths &&\n\t\t\t\tincludeSearchPathsInfo.searchPaths.length\n\t\t\t),\n\t\t\textraFileResources: options.extraFileResources,\n\n\t\t\texcludePattern: excludeSearchPathsInfo.pattern,\n\t\t\tincludePattern: includeSearchPathsInfo.pattern,\n\t\t\tonlyOpenEditors: options.onlyOpenEditors,\n\t\t\tmaxResults: options.maxResults,\n\t\t\tonlyFileScheme: options.onlyFileScheme,\n\t\t};\n\n\t\tif (options.onlyOpenEditors) {\n\t\t\tconst openEditors = arrays.coalesce(\n\t\t\t\tthis.editorGroupsService.groups.flatMap((group) =>\n\t\t\t\t\tgroup.editors.map((editor) => editor.resource),\n\t\t\t\t),\n\t\t\t);\n\t\t\tthis.logService.trace(\n\t\t\t\t\"QueryBuilder#commonQuery - openEditor URIs\",\n\t\t\t\tJSON.stringify(openEditors),\n\t\t\t);\n\t\t\tconst openEditorsInQuery = openEditors.filter((editor) =>\n\t\t\t\tpathIncludedInQuery(queryProps, editor.fsPath),\n\t\t\t);\n\t\t\tconst openEditorsQueryProps =\n\t\t\t\tthis.commonQueryFromFileList(openEditorsInQuery);\n\t\t\tthis.logService.trace(\n\t\t\t\t\"QueryBuilder#commonQuery - openEditor Query\",\n\t\t\t\tJSON.stringify(openEditorsQueryProps),\n\t\t\t);\n\t\t\treturn { ...queryProps, ...openEditorsQueryProps };\n\t\t}\n\n\t\t// Filter extraFileResources against global include/exclude patterns - they are already expected to not belong to a workspace\n\t\tconst extraFileResources =\n\t\t\toptions.extraFileResources &&\n\t\t\toptions.extraFileResources.filter((extraFile) =>\n\t\t\t\tpathIncludedInQuery(queryProps, extraFile.fsPath),\n\t\t\t);\n\t\tqueryProps.extraFileResources =\n\t\t\textraFileResources && extraFileResources.length\n\t\t\t\t? extraFileResources\n\t\t\t\t: undefined;\n\n\t\treturn queryProps;\n\t}\n\n\tprivate commonQueryFromFileList(files: URI[]): ICommonQueryProps<URI> {\n\t\tconst folderQueries: IFolderQuery[] = [];\n\t\tconst foldersToSearch: ResourceMap<IFolderQuery> = new ResourceMap();\n\t\tconst includePattern: glob.IExpression = {};\n\t\tlet hasIncludedFile = false;\n\t\tfiles.forEach((file) => {\n\t\t\tif (file.scheme === Schemas.walkThrough) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst providerExists = isAbsolutePath(file);\n\t\t\t// Special case userdata as we don't have a search provider for it, but it can be searched.\n\t\t\tif (providerExists) {\n\t\t\t\tconst searchRoot =\n\t\t\t\t\tthis.workspaceContextService.getWorkspaceFolder(file)\n\t\t\t\t\t\t?.uri ?? this.uriIdentityService.extUri.dirname(file);\n\n\t\t\t\tlet folderQuery = foldersToSearch.get(searchRoot);\n\t\t\t\tif (!folderQuery) {\n\t\t\t\t\thasIncludedFile = true;\n\t\t\t\t\tfolderQuery = { folder: searchRoot, includePattern: {} };\n\t\t\t\t\tfolderQueries.push(folderQuery);\n\t\t\t\t\tfoldersToSearch.set(searchRoot, folderQuery);\n\t\t\t\t}\n\n\t\t\t\tconst relPath = path.relative(searchRoot.fsPath, file.fsPath);\n\t\t\t\tassertIsDefined(folderQuery.includePattern)[\n\t\t\t\t\trelPath.replace(/\\\\/g, \"/\")\n\t\t\t\t] = true;\n\t\t\t} else if (file.fsPath) {\n\t\t\t\thasIncludedFile = true;\n\t\t\t\tincludePattern[file.fsPath] = true;\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tfolderQueries,\n\t\t\tincludePattern,\n\t\t\tusingSearchPaths: true,\n\t\t\texcludePattern: hasIncludedFile ? undefined : { \"**/*\": true },\n\t\t};\n\t}\n\n\t/**\n\t * Resolve isCaseSensitive flag based on the query and the isSmartCase flag, for search providers that don't support smart case natively.\n\t */\n\tprivate isCaseSensitive(\n\t\tcontentPattern: IPatternInfo,\n\t\toptions: ITextQueryBuilderOptions,\n\t): boolean {\n\t\tif (options.isSmartCase) {\n\t\t\tif (contentPattern.isRegExp) {\n\t\t\t\t// Consider it case sensitive if it contains an unescaped capital letter\n\t\t\t\tif (\n\t\t\t\t\tstrings.containsUppercaseCharacter(\n\t\t\t\t\t\tcontentPattern.pattern,\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else if (\n\t\t\t\tstrings.containsUppercaseCharacter(contentPattern.pattern)\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn !!contentPattern.isCaseSensitive;\n\t}\n\n\tprivate isMultiline(contentPattern: IPatternInfo): boolean {\n\t\tif (contentPattern.isMultiline) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (\n\t\t\tcontentPattern.isRegExp &&\n\t\t\tisMultilineRegexSource(contentPattern.pattern)\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (contentPattern.pattern.indexOf(\"\\n\") >= 0) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn !!contentPattern.isMultiline;\n\t}\n\n\t/**\n\t * Take the includePattern as seen in the search viewlet, and split into components that look like searchPaths, and\n\t * glob patterns. Glob patterns are expanded from 'foo/bar' to '{foo/bar/**, **\\/foo/bar}.\n\t *\n\t * Public for test.\n\t */\n\tparseSearchPaths(pattern: string | string[]): ISearchPathsInfo {\n\t\tconst isSearchPath = (segment: string) => {\n\t\t\t// A segment is a search path if it is an absolute path or starts with ./, ../, .\\, or ..\\\n\t\t\treturn path.isAbsolute(segment) || /^\\.\\.?([/\\\\]|$)/.test(segment);\n\t\t};\n\n\t\tconst patterns = Array.isArray(pattern)\n\t\t\t? pattern\n\t\t\t: splitGlobPattern(pattern);\n\t\tconst segments = patterns.map((segment) => {\n\t\t\tconst userHome = this.pathService.resolvedUserHome;\n\t\t\tif (userHome) {\n\t\t\t\treturn untildify(\n\t\t\t\t\tsegment,\n\t\t\t\t\tuserHome.scheme === Schemas.file\n\t\t\t\t\t\t? userHome.fsPath\n\t\t\t\t\t\t: userHome.path,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn segment;\n\t\t});\n\t\tconst groups = collections.groupBy(segments, (segment) =>\n\t\t\tisSearchPath(segment) ? \"searchPaths\" : \"exprSegments\",\n\t\t);\n\n\t\tconst expandedExprSegments = (groups.exprSegments || [])\n\t\t\t.map((s) => strings.rtrim(s, \"/\"))\n\t\t\t.map((s) => strings.rtrim(s, \"\\\\\"))\n\t\t\t.map((p) => {\n\t\t\t\tif (p[0] === \".\") {\n\t\t\t\t\tp = \"*\" + p; // convert \".js\" to \"*.js\"\n\t\t\t\t}\n\n\t\t\t\treturn expandGlobalGlob(p);\n\t\t\t});\n\n\t\tconst result: ISearchPathsInfo = {};\n\t\tconst searchPaths = this.expandSearchPathPatterns(\n\t\t\tgroups.searchPaths || [],\n\t\t);\n\t\tif (searchPaths && searchPaths.length) {\n\t\t\tresult.searchPaths = searchPaths;\n\t\t}\n\n\t\tconst exprSegments = expandedExprSegments.flat();\n\t\tconst includePattern = patternListToIExpression(...exprSegments);\n\t\tif (includePattern) {\n\t\t\tresult.pattern = includePattern;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate getExcludesForFolder(\n\t\tfolderConfig: ISearchConfiguration,\n\t\toptions: ICommonQueryBuilderOptions,\n\t): glob.IExpression | undefined {\n\t\treturn options.disregardExcludeSettings\n\t\t\t? undefined\n\t\t\t: getExcludes(\n\t\t\t\t\tfolderConfig,\n\t\t\t\t\t!options.disregardSearchExcludeSettings,\n\t\t\t\t);\n\t}\n\n\t/**\n\t * Split search paths (./ or ../ or absolute paths in the includePatterns) into absolute paths and globs applied to those paths\n\t */\n\tprivate expandSearchPathPatterns(\n\t\tsearchPaths: string[],\n\t): ISearchPathPattern[] {\n\t\tif (!searchPaths || !searchPaths.length) {\n\t\t\t// No workspace => ignore search paths\n\t\t\treturn [];\n\t\t}\n\n\t\tconst expandedSearchPaths = searchPaths.flatMap((searchPath) => {\n\t\t\t// 1 open folder => just resolve the search paths to absolute paths\n\t\t\tlet { pathPortion, globPortion } = splitGlobFromPath(searchPath);\n\n\t\t\tif (globPortion) {\n\t\t\t\tglobPortion = normalizeGlobPattern(globPortion);\n\t\t\t}\n\n\t\t\t// One pathPortion to multiple expanded search paths (e.g. duplicate matching workspace folders)\n\t\t\tconst oneExpanded = this.expandOneSearchPath(pathPortion);\n\n\t\t\t// Expanded search paths to multiple resolved patterns (with ** and without)\n\t\t\treturn oneExpanded.flatMap((oneExpandedResult) =>\n\t\t\t\tthis.resolveOneSearchPathPattern(\n\t\t\t\t\toneExpandedResult,\n\t\t\t\t\tglobPortion,\n\t\t\t\t),\n\t\t\t);\n\t\t});\n\n\t\tconst searchPathPatternMap = new Map<string, ISearchPathPattern>();\n\t\texpandedSearchPaths.forEach((oneSearchPathPattern) => {\n\t\t\tconst key = oneSearchPathPattern.searchPath.toString();\n\t\t\tconst existing = searchPathPatternMap.get(key);\n\t\t\tif (existing) {\n\t\t\t\tif (oneSearchPathPattern.pattern) {\n\t\t\t\t\texisting.pattern = existing.pattern || {};\n\t\t\t\t\texisting.pattern[oneSearchPathPattern.pattern] = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsearchPathPatternMap.set(key, {\n\t\t\t\t\tsearchPath: oneSearchPathPattern.searchPath,\n\t\t\t\t\tpattern: oneSearchPathPattern.pattern\n\t\t\t\t\t\t? patternListToIExpression(oneSearchPathPattern.pattern)\n\t\t\t\t\t\t: undefined,\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\treturn Array.from(searchPathPatternMap.values());\n\t}\n\n\t/**\n\t * Takes a searchPath like `./a/foo` or `../a/foo` and expands it to absolute paths for all the workspaces it matches.\n\t */\n\tprivate expandOneSearchPath(searchPath: string): IOneSearchPathPattern[] {\n\t\tif (path.isAbsolute(searchPath)) {\n\t\t\tconst workspaceFolders =\n\t\t\t\tthis.workspaceContextService.getWorkspace().folders;\n\t\t\tif (\n\t\t\t\tworkspaceFolders[0] &&\n\t\t\t\tworkspaceFolders[0].uri.scheme !== Schemas.file\n\t\t\t) {\n\t\t\t\treturn [\n\t\t\t\t\t{\n\t\t\t\t\t\tsearchPath: workspaceFolders[0].uri.with({\n\t\t\t\t\t\t\tpath: searchPath,\n\t\t\t\t\t\t}),\n\t\t\t\t\t},\n\t\t\t\t];\n\t\t\t}\n\n\t\t\t// Currently only local resources can be searched for with absolute search paths.\n\t\t\t// TODO convert this to a workspace folder + pattern, so excludes will be resolved properly for an absolute path inside a workspace folder\n\t\t\treturn [\n\t\t\t\t{\n\t\t\t\t\tsearchPath: uri.file(path.normalize(searchPath)),\n\t\t\t\t},\n\t\t\t];\n\t\t}\n\n\t\tif (\n\t\t\tthis.workspaceContextService.getWorkbenchState() ===\n\t\t\tWorkbenchState.FOLDER\n\t\t) {\n\t\t\tconst workspaceUri =\n\t\t\t\tthis.workspaceContextService.getWorkspace().folders[0].uri;\n\n\t\t\tsearchPath = normalizeSlashes(searchPath);\n\t\t\tif (searchPath.startsWith(\"../\") || searchPath === \"..\") {\n\t\t\t\tconst resolvedPath = path.posix.resolve(\n\t\t\t\t\tworkspaceUri.path,\n\t\t\t\t\tsearchPath,\n\t\t\t\t);\n\t\t\t\treturn [\n\t\t\t\t\t{\n\t\t\t\t\t\tsearchPath: workspaceUri.with({ path: resolvedPath }),\n\t\t\t\t\t},\n\t\t\t\t];\n\t\t\t}\n\n\t\t\tconst cleanedPattern = normalizeGlobPattern(searchPath);\n\t\t\treturn [\n\t\t\t\t{\n\t\t\t\t\tsearchPath: workspaceUri,\n\t\t\t\t\tpattern: cleanedPattern,\n\t\t\t\t},\n\t\t\t];\n\t\t} else if (searchPath === \"./\" || searchPath === \".\\\\\") {\n\t\t\treturn []; // ./ or ./**/foo makes sense for single-folder but not multi-folder workspaces\n\t\t} else {\n\t\t\tconst searchPathWithoutDotSlash = searchPath.replace(\n\t\t\t\t/^\\.[/\\\\]/,\n\t\t\t\t\"\",\n\t\t\t);\n\t\t\tconst folders = this.workspaceContextService.getWorkspace().folders;\n\t\t\tconst folderMatches = folders\n\t\t\t\t.map((folder) => {\n\t\t\t\t\tconst match = searchPathWithoutDotSlash.match(\n\t\t\t\t\t\tnew RegExp(\n\t\t\t\t\t\t\t`^${strings.escapeRegExpCharacters(folder.name)}(?:/(.*)|$)`,\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t\treturn match\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tmatch,\n\t\t\t\t\t\t\t\tfolder,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: null;\n\t\t\t\t})\n\t\t\t\t.filter(isDefined);\n\n\t\t\tif (folderMatches.length) {\n\t\t\t\treturn folderMatches.map((match) => {\n\t\t\t\t\tconst patternMatch = match.match[1];\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsearchPath: match.folder.uri,\n\t\t\t\t\t\tpattern:\n\t\t\t\t\t\t\tpatternMatch && normalizeGlobPattern(patternMatch),\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tconst probableWorkspaceFolderNameMatch =\n\t\t\t\t\tsearchPath.match(/\\.[/\\\\](.+)[/\\\\]?/);\n\t\t\t\tconst probableWorkspaceFolderName =\n\t\t\t\t\tprobableWorkspaceFolderNameMatch\n\t\t\t\t\t\t? probableWorkspaceFolderNameMatch[1]\n\t\t\t\t\t\t: searchPath;\n\n\t\t\t\t// No root folder with name\n\t\t\t\tconst searchPathNotFoundError = nls.localize(\n\t\t\t\t\t\"search.noWorkspaceWithName\",\n\t\t\t\t\t\"Workspace folder does not exist: {0}\",\n\t\t\t\t\tprobableWorkspaceFolderName,\n\t\t\t\t);\n\t\t\t\tthrow new Error(searchPathNotFoundError);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate resolveOneSearchPathPattern(\n\t\toneExpandedResult: IOneSearchPathPattern,\n\t\tglobPortion?: string,\n\t): IOneSearchPathPattern[] {\n\t\tconst pattern =\n\t\t\toneExpandedResult.pattern && globPortion\n\t\t\t\t? `${oneExpandedResult.pattern}/${globPortion}`\n\t\t\t\t: oneExpandedResult.pattern || globPortion;\n\n\t\tconst results = [\n\t\t\t{\n\t\t\t\tsearchPath: oneExpandedResult.searchPath,\n\t\t\t\tpattern,\n\t\t\t},\n\t\t];\n\n\t\tif (pattern && !pattern.endsWith(\"**\")) {\n\t\t\tresults.push({\n\t\t\t\tsearchPath: oneExpandedResult.searchPath,\n\t\t\t\tpattern: pattern + \"/**\",\n\t\t\t});\n\t\t}\n\n\t\treturn results;\n\t}\n\n\tprivate getFolderQueryForSearchPath(\n\t\tsearchPath: ISearchPathPattern,\n\t\toptions: ICommonQueryBuilderOptions,\n\t\tsearchPathExcludes: ISearchPathsInfo,\n\t): IFolderQuery | null {\n\t\tconst rootConfig = this.getFolderQueryForRoot(\n\t\t\ttoWorkspaceFolder(searchPath.searchPath),\n\t\t\toptions,\n\t\t\tsearchPathExcludes,\n\t\t\tfalse,\n\t\t);\n\t\tif (!rootConfig) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\t...rootConfig,\n\t\t\t...{\n\t\t\t\tincludePattern: searchPath.pattern,\n\t\t\t},\n\t\t};\n\t}\n\n\tprivate getFolderQueryForRoot(\n\t\tfolder: IWorkspaceFolderData | URI,\n\t\toptions: ICommonQueryBuilderOptions,\n\t\tsearchPathExcludes: ISearchPathsInfo,\n\t\tincludeFolderName: boolean,\n\t): IFolderQuery | null {\n\t\tlet thisFolderExcludeSearchPathPattern: glob.IExpression | undefined;\n\t\tconst folderUri = URI.isUri(folder) ? folder : folder.uri;\n\n\t\t// only use exclude root if it is different from the folder root\n\t\tlet excludeFolderRoots = options.excludePattern?.map(\n\t\t\t(excludePattern) => {\n\t\t\t\tconst excludeRoot =\n\t\t\t\t\toptions.excludePattern &&\n\t\t\t\t\tisISearchPatternBuilder(excludePattern)\n\t\t\t\t\t\t? excludePattern.uri\n\t\t\t\t\t\t: undefined;\n\t\t\t\tconst shouldUseExcludeRoot =\n\t\t\t\t\t!excludeRoot ||\n\t\t\t\t\t!(\n\t\t\t\t\t\tURI.isUri(folder) &&\n\t\t\t\t\t\tthis.uriIdentityService.extUri.isEqual(\n\t\t\t\t\t\t\tfolder,\n\t\t\t\t\t\t\texcludeRoot,\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\treturn shouldUseExcludeRoot ? excludeRoot : undefined;\n\t\t\t},\n\t\t);\n\n\t\tif (!excludeFolderRoots?.length) {\n\t\t\texcludeFolderRoots = [undefined];\n\t\t}\n\n\t\tif (searchPathExcludes.searchPaths) {\n\t\t\tconst thisFolderExcludeSearchPath =\n\t\t\t\tsearchPathExcludes.searchPaths.filter((sp) =>\n\t\t\t\t\tisEqual(sp.searchPath, folderUri),\n\t\t\t\t)[0];\n\t\t\tif (\n\t\t\t\tthisFolderExcludeSearchPath &&\n\t\t\t\t!thisFolderExcludeSearchPath.pattern\n\t\t\t) {\n\t\t\t\t// entire folder is excluded\n\t\t\t\treturn null;\n\t\t\t} else if (thisFolderExcludeSearchPath) {\n\t\t\t\tthisFolderExcludeSearchPathPattern =\n\t\t\t\t\tthisFolderExcludeSearchPath.pattern;\n\t\t\t}\n\t\t}\n\n\t\tconst folderConfig =\n\t\t\tthis.configurationService.getValue<ISearchConfiguration>({\n\t\t\t\tresource: folderUri,\n\t\t\t});\n\t\tconst settingExcludes = this.getExcludesForFolder(\n\t\t\tfolderConfig,\n\t\t\toptions,\n\t\t);\n\t\tconst excludePattern: glob.IExpression = {\n\t\t\t...(settingExcludes || {}),\n\t\t\t...(thisFolderExcludeSearchPathPattern || {}),\n\t\t};\n\n\t\tconst folderName = URI.isUri(folder) ? basename(folder) : folder.name;\n\n\t\tconst excludePatternRet: ExcludeGlobPattern[] = excludeFolderRoots\n\t\t\t.map((excludeFolderRoot) => {\n\t\t\t\treturn Object.keys(excludePattern).length > 0\n\t\t\t\t\t? ({\n\t\t\t\t\t\t\tfolder: excludeFolderRoot,\n\t\t\t\t\t\t\tpattern: excludePattern,\n\t\t\t\t\t\t} satisfies ExcludeGlobPattern)\n\t\t\t\t\t: undefined;\n\t\t\t})\n\t\t\t.filter((e) => e) as ExcludeGlobPattern[];\n\n\t\treturn {\n\t\t\tfolder: folderUri,\n\t\t\tfolderName: includeFolderName ? folderName : undefined,\n\t\t\texcludePattern: excludePatternRet,\n\t\t\tfileEncoding: folderConfig.files && folderConfig.files.encoding,\n\t\t\tdisregardIgnoreFiles:\n\t\t\t\ttypeof options.disregardIgnoreFiles === \"boolean\"\n\t\t\t\t\t? options.disregardIgnoreFiles\n\t\t\t\t\t: !folderConfig.search.useIgnoreFiles,\n\t\t\tdisregardGlobalIgnoreFiles:\n\t\t\t\ttypeof options.disregardGlobalIgnoreFiles === \"boolean\"\n\t\t\t\t\t? options.disregardGlobalIgnoreFiles\n\t\t\t\t\t: !folderConfig.search.useGlobalIgnoreFiles,\n\t\t\tdisregardParentIgnoreFiles:\n\t\t\t\ttypeof options.disregardParentIgnoreFiles === \"boolean\"\n\t\t\t\t\t? options.disregardParentIgnoreFiles\n\t\t\t\t\t: !folderConfig.search.useParentIgnoreFiles,\n\t\t\tignoreSymlinks:\n\t\t\t\ttypeof options.ignoreSymlinks === \"boolean\"\n\t\t\t\t\t? options.ignoreSymlinks\n\t\t\t\t\t: !folderConfig.search.followSymlinks,\n\t\t};\n\t}\n}\n\nfunction splitGlobFromPath(searchPath: string): {\n\tpathPortion: string;\n\tglobPortion?: string;\n} {\n\tconst globCharMatch = searchPath.match(/[*{}()[\\]?]/);\n\tif (globCharMatch) {\n\t\tconst globCharIdx = globCharMatch.index;\n\t\tconst lastSlashMatch = searchPath\n\t\t\t.substr(0, globCharIdx)\n\t\t\t.match(/[/|\\\\][^/\\\\]*$/);\n\t\tif (lastSlashMatch) {\n\t\t\tlet pathPortion = searchPath.substr(0, lastSlashMatch.index);\n\t\t\tif (!pathPortion.match(/[/\\\\]/)) {\n\t\t\t\t// If the last slash was the only slash, then we now have '' or 'C:' or '.'. Append a slash.\n\t\t\t\tpathPortion += \"/\";\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tpathPortion,\n\t\t\t\tglobPortion: searchPath.substr((lastSlashMatch.index || 0) + 1),\n\t\t\t};\n\t\t}\n\t}\n\n\t// No glob char, or malformed\n\treturn {\n\t\tpathPortion: searchPath,\n\t};\n}\n\nfunction patternListToIExpression(...patterns: string[]): glob.IExpression {\n\treturn patterns.length\n\t\t? patterns.reduce((glob, cur) => {\n\t\t\t\tglob[cur] = true;\n\t\t\t\treturn glob;\n\t\t\t}, Object.create(null))\n\t\t: undefined;\n}\n\nfunction splitGlobPattern(pattern: string): string[] {\n\treturn glob\n\t\t.splitGlobAware(pattern, \",\")\n\t\t.map((s) => s.trim())\n\t\t.filter((s) => !!s.length);\n}\n\n/**\n * Note - we used {} here previously but ripgrep can't handle nested {} patterns. See https://github.com/microsoft/vscode/issues/32761\n */\nfunction expandGlobalGlob(pattern: string): string[] {\n\tconst patterns = [`**/${pattern}/**`, `**/${pattern}`];\n\n\treturn patterns.map((p) => p.replace(/\\*\\*\\/\\*\\*/g, \"**\"));\n}\n\nfunction normalizeSlashes(pattern: string): string {\n\treturn pattern.replace(/\\\\/g, \"/\");\n}\n\n/**\n * Normalize slashes, remove `./` and trailing slashes\n */\nfunction normalizeGlobPattern(pattern: string): string {\n\treturn normalizeSlashes(pattern).replace(/^\\.\\//, \"\").replace(/\\/+$/g, \"\");\n}\n\n/**\n * Escapes a path for use as a glob pattern that would match the input precisely.\n * Characters '?', '*', '[', and ']' are escaped into character range glob syntax\n * (for example, '?' becomes '[?]').\n * NOTE: This implementation makes no special cases for UNC paths. For example,\n * given the input \"//?/C:/A?.txt\", this would produce output '//[?]/C:/A[?].txt',\n * which may not be desirable in some cases. Use with caution if UNC paths could be expected.\n */\nfunction escapeGlobPattern(path: string): string {\n\treturn path.replace(/([?*[\\]])/g, \"[$1]\");\n}\n\n/**\n * Construct an include pattern from a list of folders uris to search in.\n */\nexport function resolveResourcesForSearchIncludes(\n\tresources: URI[],\n\tcontextService: IWorkspaceContextService,\n): string[] {\n\tresources = arrays.distinct(resources, (resource) => resource.toString());\n\n\tconst folderPaths: string[] = [];\n\tconst workspace = contextService.getWorkspace();\n\n\tif (resources) {\n\t\tresources.forEach((resource) => {\n\t\t\tlet folderPath: string | undefined;\n\t\t\tif (contextService.getWorkbenchState() === WorkbenchState.FOLDER) {\n\t\t\t\t// Show relative path from the root for single-root mode\n\t\t\t\tfolderPath = relativePath(workspace.folders[0].uri, resource); // always uses forward slashes\n\t\t\t\tif (folderPath && folderPath !== \".\") {\n\t\t\t\t\tfolderPath = \"./\" + folderPath;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst owningFolder =\n\t\t\t\t\tcontextService.getWorkspaceFolder(resource);\n\t\t\t\tif (owningFolder) {\n\t\t\t\t\tconst owningRootName = owningFolder.name;\n\t\t\t\t\t// If this root is the only one with its basename, use a relative ./ path. If there is another, use an absolute path\n\t\t\t\t\tconst isUniqueFolder =\n\t\t\t\t\t\tworkspace.folders.filter(\n\t\t\t\t\t\t\t(folder) => folder.name === owningRootName,\n\t\t\t\t\t\t).length === 1;\n\t\t\t\t\tif (isUniqueFolder) {\n\t\t\t\t\t\tconst relPath = relativePath(\n\t\t\t\t\t\t\towningFolder.uri,\n\t\t\t\t\t\t\tresource,\n\t\t\t\t\t\t); // always uses forward slashes\n\t\t\t\t\t\tif (relPath === \"\") {\n\t\t\t\t\t\t\tfolderPath = `./${owningFolder.name}`;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfolderPath = `./${owningFolder.name}/${relPath}`;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfolderPath = resource.fsPath; // TODO rob: handle non-file URIs\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (folderPath) {\n\t\t\t\tfolderPaths.push(escapeGlobPattern(folderPath));\n\t\t\t}\n\t\t});\n\t}\n\treturn folderPaths;\n}\n"],
  "mappings": "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",
  "names": ["excludePattern", "glob", "path"]
}
