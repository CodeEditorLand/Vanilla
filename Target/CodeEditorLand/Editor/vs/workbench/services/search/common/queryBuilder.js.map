{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/search/common/queryBuilder.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from '../../../../base/common/arrays.js';\nimport * as collections from '../../../../base/common/collections.js';\nimport * as glob from '../../../../base/common/glob.js';\nimport { untildify } from '../../../../base/common/labels.js';\nimport { ResourceMap } from '../../../../base/common/map.js';\nimport { Schemas } from '../../../../base/common/network.js';\nimport * as path from '../../../../base/common/path.js';\nimport { isEqual, basename, relativePath, isAbsolutePath } from '../../../../base/common/resources.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { assertIsDefined, isDefined } from '../../../../base/common/types.js';\nimport { URI, URI as uri, UriComponents } from '../../../../base/common/uri.js';\nimport { isMultilineRegexSource } from '../../../../editor/common/model/textModelSearch.js';\nimport * as nls from '../../../../nls.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { IUriIdentityService } from '../../../../platform/uriIdentity/common/uriIdentity.js';\nimport { IWorkspaceContextService, IWorkspaceFolderData, toWorkspaceFolder, WorkbenchState } from '../../../../platform/workspace/common/workspace.js';\nimport { IEditorGroupsService } from '../../editor/common/editorGroupsService.js';\nimport { IPathService } from '../../path/common/pathService.js';\nimport { ExcludeGlobPattern, getExcludes, ICommonQueryProps, IFileQuery, IFolderQuery, IPatternInfo, ISearchConfiguration, ITextQuery, ITextSearchPreviewOptions, pathIncludedInQuery, QueryType } from './search.js';\nimport { GlobPattern } from './searchExtTypes.js';\n\n/**\n * One folder to search and a glob expression that should be applied.\n */\ninterface IOneSearchPathPattern {\n\tsearchPath: uri;\n\tpattern?: string;\n}\n\n/**\n * One folder to search and a set of glob expressions that should be applied.\n */\nexport interface ISearchPathPattern {\n\tsearchPath: uri;\n\tpattern?: glob.IExpression;\n}\n\ntype ISearchPathPatternBuilder = string | string[];\n\nexport interface ISearchPatternBuilder<U extends UriComponents> {\n\turi?: U;\n\tpattern: ISearchPathPatternBuilder;\n}\n\nexport function isISearchPatternBuilder<U extends UriComponents>(object: ISearchPatternBuilder<U> | ISearchPathPatternBuilder): object is ISearchPatternBuilder<U> {\n\treturn (typeof object === 'object' && 'uri' in object && 'pattern' in object);\n}\n\nexport function globPatternToISearchPatternBuilder(globPattern: GlobPattern): ISearchPatternBuilder<URI> {\n\n\tif (typeof globPattern === 'string') {\n\t\treturn {\n\t\t\tpattern: globPattern\n\t\t};\n\t}\n\n\treturn {\n\t\tpattern: globPattern.pattern,\n\t\turi: globPattern.baseUri\n\t};\n}\n\n/**\n * A set of search paths and a set of glob expressions that should be applied.\n */\nexport interface ISearchPathsInfo {\n\tsearchPaths?: ISearchPathPattern[];\n\tpattern?: glob.IExpression;\n}\n\ninterface ICommonQueryBuilderOptions<U extends UriComponents = URI> {\n\t_reason?: string;\n\texcludePattern?: ISearchPatternBuilder<U>[];\n\tincludePattern?: ISearchPathPatternBuilder;\n\textraFileResources?: U[];\n\n\t/** Parse the special ./ syntax supported by the searchview, and expand foo to ** /foo */\n\texpandPatterns?: boolean;\n\n\tmaxResults?: number;\n\tmaxFileSize?: number;\n\tdisregardIgnoreFiles?: boolean;\n\tdisregardGlobalIgnoreFiles?: boolean;\n\tdisregardParentIgnoreFiles?: boolean;\n\tdisregardExcludeSettings?: boolean;\n\tdisregardSearchExcludeSettings?: boolean;\n\tignoreSymlinks?: boolean;\n\tonlyOpenEditors?: boolean;\n\tonlyFileScheme?: boolean;\n}\n\nexport interface IFileQueryBuilderOptions<U extends UriComponents = URI> extends ICommonQueryBuilderOptions<U> {\n\tfilePattern?: string;\n\texists?: boolean;\n\tsortByScore?: boolean;\n\tcacheKey?: string;\n\tshouldGlobSearch?: boolean;\n}\n\nexport interface ITextQueryBuilderOptions<U extends UriComponents = URI> extends ICommonQueryBuilderOptions<U> {\n\tpreviewOptions?: ITextSearchPreviewOptions;\n\tfileEncoding?: string;\n\tsurroundingContext?: number;\n\tisSmartCase?: boolean;\n\tnotebookSearchConfig?: {\n\t\tincludeMarkupInput: boolean;\n\t\tincludeMarkupPreview: boolean;\n\t\tincludeCodeInput: boolean;\n\t\tincludeOutput: boolean;\n\t};\n}\n\nexport class QueryBuilder {\n\n\tconstructor(\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t\t@IWorkspaceContextService private readonly workspaceContextService: IWorkspaceContextService,\n\t\t@IEditorGroupsService private readonly editorGroupsService: IEditorGroupsService,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IPathService private readonly pathService: IPathService,\n\t\t@IUriIdentityService private readonly uriIdentityService: IUriIdentityService\n\t) {\n\t}\n\n\ttext(contentPattern: IPatternInfo, folderResources?: uri[], options: ITextQueryBuilderOptions = {}): ITextQuery {\n\t\tcontentPattern = this.getContentPattern(contentPattern, options);\n\t\tconst searchConfig = this.configurationService.getValue<ISearchConfiguration>();\n\n\t\tconst fallbackToPCRE = folderResources && folderResources.some(folder => {\n\t\t\tconst folderConfig = this.configurationService.getValue<ISearchConfiguration>({ resource: folder });\n\t\t\treturn !folderConfig.search.useRipgrep;\n\t\t});\n\n\t\tconst commonQuery = this.commonQuery(folderResources?.map(toWorkspaceFolder), options);\n\t\treturn {\n\t\t\t...commonQuery,\n\t\t\ttype: QueryType.Text,\n\t\t\tcontentPattern,\n\t\t\tpreviewOptions: options.previewOptions,\n\t\t\tmaxFileSize: options.maxFileSize,\n\t\t\tusePCRE2: searchConfig.search.usePCRE2 || fallbackToPCRE || false,\n\t\t\tsurroundingContext: options.surroundingContext,\n\t\t\tuserDisabledExcludesAndIgnoreFiles: options.disregardExcludeSettings && options.disregardIgnoreFiles,\n\n\t\t};\n\t}\n\n\t/**\n\t * Adjusts input pattern for config\n\t */\n\tprivate getContentPattern(inputPattern: IPatternInfo, options: ITextQueryBuilderOptions): IPatternInfo {\n\t\tconst searchConfig = this.configurationService.getValue<ISearchConfiguration>();\n\n\t\tif (inputPattern.isRegExp) {\n\t\t\tinputPattern.pattern = inputPattern.pattern.replace(/\\r?\\n/g, '\\\\n');\n\t\t}\n\n\t\tconst newPattern = {\n\t\t\t...inputPattern,\n\t\t\twordSeparators: searchConfig.editor.wordSeparators\n\t\t};\n\n\t\tif (this.isCaseSensitive(inputPattern, options)) {\n\t\t\tnewPattern.isCaseSensitive = true;\n\t\t}\n\n\t\tif (this.isMultiline(inputPattern)) {\n\t\t\tnewPattern.isMultiline = true;\n\t\t}\n\n\t\tif (options.notebookSearchConfig?.includeMarkupInput) {\n\t\t\tif (!newPattern.notebookInfo) {\n\t\t\t\tnewPattern.notebookInfo = {};\n\t\t\t}\n\t\t\tnewPattern.notebookInfo.isInNotebookMarkdownInput = options.notebookSearchConfig.includeMarkupInput;\n\t\t}\n\n\t\tif (options.notebookSearchConfig?.includeMarkupPreview) {\n\t\t\tif (!newPattern.notebookInfo) {\n\t\t\t\tnewPattern.notebookInfo = {};\n\t\t\t}\n\t\t\tnewPattern.notebookInfo.isInNotebookMarkdownPreview = options.notebookSearchConfig.includeMarkupPreview;\n\t\t}\n\n\t\tif (options.notebookSearchConfig?.includeCodeInput) {\n\t\t\tif (!newPattern.notebookInfo) {\n\t\t\t\tnewPattern.notebookInfo = {};\n\t\t\t}\n\t\t\tnewPattern.notebookInfo.isInNotebookCellInput = options.notebookSearchConfig.includeCodeInput;\n\t\t}\n\n\t\tif (options.notebookSearchConfig?.includeOutput) {\n\t\t\tif (!newPattern.notebookInfo) {\n\t\t\t\tnewPattern.notebookInfo = {};\n\t\t\t}\n\t\t\tnewPattern.notebookInfo.isInNotebookCellOutput = options.notebookSearchConfig.includeOutput;\n\t\t}\n\n\t\treturn newPattern;\n\t}\n\n\tfile(folders: (IWorkspaceFolderData | URI)[], options: IFileQueryBuilderOptions = {}): IFileQuery {\n\t\tconst commonQuery = this.commonQuery(folders, options);\n\t\treturn {\n\t\t\t...commonQuery,\n\t\t\ttype: QueryType.File,\n\t\t\tfilePattern: options.filePattern\n\t\t\t\t? options.filePattern.trim()\n\t\t\t\t: options.filePattern,\n\t\t\texists: options.exists,\n\t\t\tsortByScore: options.sortByScore,\n\t\t\tcacheKey: options.cacheKey,\n\t\t\tshouldGlobMatchFilePattern: options.shouldGlobSearch\n\t\t};\n\t}\n\n\tprivate handleIncludeExclude(pattern: string | string[] | undefined, expandPatterns: boolean | undefined): ISearchPathsInfo {\n\t\tif (!pattern) {\n\t\t\treturn {};\n\t\t}\n\n\t\tif (Array.isArray(pattern)) {\n\t\t\tpattern = pattern.filter(p => p.length > 0).map(normalizeSlashes);\n\t\t\tif (!pattern.length) {\n\t\t\t\treturn {};\n\t\t\t}\n\t\t} else {\n\t\t\tpattern = normalizeSlashes(pattern);\n\t\t}\n\t\treturn expandPatterns\n\t\t\t? this.parseSearchPaths(pattern)\n\t\t\t: { pattern: patternListToIExpression(...(Array.isArray(pattern) ? pattern : [pattern])) };\n\t}\n\n\tprivate commonQuery(folderResources: (IWorkspaceFolderData | URI)[] = [], options: ICommonQueryBuilderOptions = {}): ICommonQueryProps<uri> {\n\n\t\tlet excludePatterns: string | string[] | undefined = Array.isArray(options.excludePattern) ? options.excludePattern.map(p => p.pattern).flat() : options.excludePattern;\n\t\texcludePatterns = excludePatterns?.length === 1 ? excludePatterns[0] : excludePatterns;\n\t\tconst includeSearchPathsInfo: ISearchPathsInfo = this.handleIncludeExclude(options.includePattern, options.expandPatterns);\n\t\tconst excludeSearchPathsInfo: ISearchPathsInfo = this.handleIncludeExclude(excludePatterns, options.expandPatterns);\n\n\t\t// Build folderQueries from searchPaths, if given, otherwise folderResources\n\t\tconst includeFolderName = folderResources.length > 1;\n\t\tconst folderQueries = (includeSearchPathsInfo.searchPaths && includeSearchPathsInfo.searchPaths.length ?\n\t\t\tincludeSearchPathsInfo.searchPaths.map(searchPath => this.getFolderQueryForSearchPath(searchPath, options, excludeSearchPathsInfo)) :\n\t\t\tfolderResources.map(folder => this.getFolderQueryForRoot(folder, options, excludeSearchPathsInfo, includeFolderName)))\n\t\t\t.filter(query => !!query) as IFolderQuery[];\n\n\t\tconst queryProps: ICommonQueryProps<uri> = {\n\t\t\t_reason: options._reason,\n\t\t\tfolderQueries,\n\t\t\tusingSearchPaths: !!(includeSearchPathsInfo.searchPaths && includeSearchPathsInfo.searchPaths.length),\n\t\t\textraFileResources: options.extraFileResources,\n\n\t\t\texcludePattern: excludeSearchPathsInfo.pattern,\n\t\t\tincludePattern: includeSearchPathsInfo.pattern,\n\t\t\tonlyOpenEditors: options.onlyOpenEditors,\n\t\t\tmaxResults: options.maxResults,\n\t\t\tonlyFileScheme: options.onlyFileScheme\n\t\t};\n\n\t\tif (options.onlyOpenEditors) {\n\t\t\tconst openEditors = arrays.coalesce(this.editorGroupsService.groups.flatMap(group => group.editors.map(editor => editor.resource)));\n\t\t\tthis.logService.trace('QueryBuilder#commonQuery - openEditor URIs', JSON.stringify(openEditors));\n\t\t\tconst openEditorsInQuery = openEditors.filter(editor => pathIncludedInQuery(queryProps, editor.fsPath));\n\t\t\tconst openEditorsQueryProps = this.commonQueryFromFileList(openEditorsInQuery);\n\t\t\tthis.logService.trace('QueryBuilder#commonQuery - openEditor Query', JSON.stringify(openEditorsQueryProps));\n\t\t\treturn { ...queryProps, ...openEditorsQueryProps };\n\t\t}\n\n\t\t// Filter extraFileResources against global include/exclude patterns - they are already expected to not belong to a workspace\n\t\tconst extraFileResources = options.extraFileResources && options.extraFileResources.filter(extraFile => pathIncludedInQuery(queryProps, extraFile.fsPath));\n\t\tqueryProps.extraFileResources = extraFileResources && extraFileResources.length ? extraFileResources : undefined;\n\n\t\treturn queryProps;\n\t}\n\n\tprivate commonQueryFromFileList(files: URI[]): ICommonQueryProps<URI> {\n\t\tconst folderQueries: IFolderQuery[] = [];\n\t\tconst foldersToSearch: ResourceMap<IFolderQuery> = new ResourceMap();\n\t\tconst includePattern: glob.IExpression = {};\n\t\tlet hasIncludedFile = false;\n\t\tfiles.forEach(file => {\n\t\t\tif (file.scheme === Schemas.walkThrough) { return; }\n\n\t\t\tconst providerExists = isAbsolutePath(file);\n\t\t\t// Special case userdata as we don't have a search provider for it, but it can be searched.\n\t\t\tif (providerExists) {\n\n\t\t\t\tconst searchRoot = this.workspaceContextService.getWorkspaceFolder(file)?.uri ?? this.uriIdentityService.extUri.dirname(file);\n\n\t\t\t\tlet folderQuery = foldersToSearch.get(searchRoot);\n\t\t\t\tif (!folderQuery) {\n\t\t\t\t\thasIncludedFile = true;\n\t\t\t\t\tfolderQuery = { folder: searchRoot, includePattern: {} };\n\t\t\t\t\tfolderQueries.push(folderQuery);\n\t\t\t\t\tfoldersToSearch.set(searchRoot, folderQuery);\n\t\t\t\t}\n\n\t\t\t\tconst relPath = path.relative(searchRoot.fsPath, file.fsPath);\n\t\t\t\tassertIsDefined(folderQuery.includePattern)[relPath.replace(/\\\\/g, '/')] = true;\n\t\t\t} else {\n\t\t\t\tif (file.fsPath) {\n\t\t\t\t\thasIncludedFile = true;\n\t\t\t\t\tincludePattern[file.fsPath] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tfolderQueries,\n\t\t\tincludePattern,\n\t\t\tusingSearchPaths: true,\n\t\t\texcludePattern: hasIncludedFile ? undefined : { '**/*': true }\n\t\t};\n\t}\n\n\t/**\n\t * Resolve isCaseSensitive flag based on the query and the isSmartCase flag, for search providers that don't support smart case natively.\n\t */\n\tprivate isCaseSensitive(contentPattern: IPatternInfo, options: ITextQueryBuilderOptions): boolean {\n\t\tif (options.isSmartCase) {\n\t\t\tif (contentPattern.isRegExp) {\n\t\t\t\t// Consider it case sensitive if it contains an unescaped capital letter\n\t\t\t\tif (strings.containsUppercaseCharacter(contentPattern.pattern, true)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else if (strings.containsUppercaseCharacter(contentPattern.pattern)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn !!contentPattern.isCaseSensitive;\n\t}\n\n\tprivate isMultiline(contentPattern: IPatternInfo): boolean {\n\t\tif (contentPattern.isMultiline) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (contentPattern.isRegExp && isMultilineRegexSource(contentPattern.pattern)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (contentPattern.pattern.indexOf('\\n') >= 0) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn !!contentPattern.isMultiline;\n\t}\n\n\t/**\n\t * Take the includePattern as seen in the search viewlet, and split into components that look like searchPaths, and\n\t * glob patterns. Glob patterns are expanded from 'foo/bar' to '{foo/bar/**, **\\/foo/bar}.\n\t *\n\t * Public for test.\n\t */\n\tparseSearchPaths(pattern: string | string[]): ISearchPathsInfo {\n\t\tconst isSearchPath = (segment: string) => {\n\t\t\t// A segment is a search path if it is an absolute path or starts with ./, ../, .\\, or ..\\\n\t\t\treturn path.isAbsolute(segment) || /^\\.\\.?([\\/\\\\]|$)/.test(segment);\n\t\t};\n\n\t\tconst patterns = Array.isArray(pattern) ? pattern : splitGlobPattern(pattern);\n\t\tconst segments = patterns\n\t\t\t.map(segment => {\n\t\t\t\tconst userHome = this.pathService.resolvedUserHome;\n\t\t\t\tif (userHome) {\n\t\t\t\t\treturn untildify(segment, userHome.scheme === Schemas.file ? userHome.fsPath : userHome.path);\n\t\t\t\t}\n\n\t\t\t\treturn segment;\n\t\t\t});\n\t\tconst groups = collections.groupBy(segments,\n\t\t\tsegment => isSearchPath(segment) ? 'searchPaths' : 'exprSegments');\n\n\t\tconst expandedExprSegments = (groups.exprSegments || [])\n\t\t\t.map(s => strings.rtrim(s, '/'))\n\t\t\t.map(s => strings.rtrim(s, '\\\\'))\n\t\t\t.map(p => {\n\t\t\t\tif (p[0] === '.') {\n\t\t\t\t\tp = '*' + p; // convert \".js\" to \"*.js\"\n\t\t\t\t}\n\n\t\t\t\treturn expandGlobalGlob(p);\n\t\t\t});\n\n\t\tconst result: ISearchPathsInfo = {};\n\t\tconst searchPaths = this.expandSearchPathPatterns(groups.searchPaths || []);\n\t\tif (searchPaths && searchPaths.length) {\n\t\t\tresult.searchPaths = searchPaths;\n\t\t}\n\n\t\tconst exprSegments = expandedExprSegments.flat();\n\t\tconst includePattern = patternListToIExpression(...exprSegments);\n\t\tif (includePattern) {\n\t\t\tresult.pattern = includePattern;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate getExcludesForFolder(folderConfig: ISearchConfiguration, options: ICommonQueryBuilderOptions): glob.IExpression | undefined {\n\t\treturn options.disregardExcludeSettings ?\n\t\t\tundefined :\n\t\t\tgetExcludes(folderConfig, !options.disregardSearchExcludeSettings);\n\t}\n\n\t/**\n\t * Split search paths (./ or ../ or absolute paths in the includePatterns) into absolute paths and globs applied to those paths\n\t */\n\tprivate expandSearchPathPatterns(searchPaths: string[]): ISearchPathPattern[] {\n\t\tif (!searchPaths || !searchPaths.length) {\n\t\t\t// No workspace => ignore search paths\n\t\t\treturn [];\n\t\t}\n\n\t\tconst expandedSearchPaths = searchPaths.flatMap(searchPath => {\n\t\t\t// 1 open folder => just resolve the search paths to absolute paths\n\t\t\tlet { pathPortion, globPortion } = splitGlobFromPath(searchPath);\n\n\t\t\tif (globPortion) {\n\t\t\t\tglobPortion = normalizeGlobPattern(globPortion);\n\t\t\t}\n\n\t\t\t// One pathPortion to multiple expanded search paths (e.g. duplicate matching workspace folders)\n\t\t\tconst oneExpanded = this.expandOneSearchPath(pathPortion);\n\n\t\t\t// Expanded search paths to multiple resolved patterns (with ** and without)\n\t\t\treturn oneExpanded.flatMap(oneExpandedResult => this.resolveOneSearchPathPattern(oneExpandedResult, globPortion));\n\t\t});\n\n\t\tconst searchPathPatternMap = new Map<string, ISearchPathPattern>();\n\t\texpandedSearchPaths.forEach(oneSearchPathPattern => {\n\t\t\tconst key = oneSearchPathPattern.searchPath.toString();\n\t\t\tconst existing = searchPathPatternMap.get(key);\n\t\t\tif (existing) {\n\t\t\t\tif (oneSearchPathPattern.pattern) {\n\t\t\t\t\texisting.pattern = existing.pattern || {};\n\t\t\t\t\texisting.pattern[oneSearchPathPattern.pattern] = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsearchPathPatternMap.set(key, {\n\t\t\t\t\tsearchPath: oneSearchPathPattern.searchPath,\n\t\t\t\t\tpattern: oneSearchPathPattern.pattern ? patternListToIExpression(oneSearchPathPattern.pattern) : undefined\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\treturn Array.from(searchPathPatternMap.values());\n\t}\n\n\t/**\n\t * Takes a searchPath like `./a/foo` or `../a/foo` and expands it to absolute paths for all the workspaces it matches.\n\t */\n\tprivate expandOneSearchPath(searchPath: string): IOneSearchPathPattern[] {\n\t\tif (path.isAbsolute(searchPath)) {\n\t\t\tconst workspaceFolders = this.workspaceContextService.getWorkspace().folders;\n\t\t\tif (workspaceFolders[0] && workspaceFolders[0].uri.scheme !== Schemas.file) {\n\t\t\t\treturn [{\n\t\t\t\t\tsearchPath: workspaceFolders[0].uri.with({ path: searchPath })\n\t\t\t\t}];\n\t\t\t}\n\n\t\t\t// Currently only local resources can be searched for with absolute search paths.\n\t\t\t// TODO convert this to a workspace folder + pattern, so excludes will be resolved properly for an absolute path inside a workspace folder\n\t\t\treturn [{\n\t\t\t\tsearchPath: uri.file(path.normalize(searchPath))\n\t\t\t}];\n\t\t}\n\n\t\tif (this.workspaceContextService.getWorkbenchState() === WorkbenchState.FOLDER) {\n\t\t\tconst workspaceUri = this.workspaceContextService.getWorkspace().folders[0].uri;\n\n\t\t\tsearchPath = normalizeSlashes(searchPath);\n\t\t\tif (searchPath.startsWith('../') || searchPath === '..') {\n\t\t\t\tconst resolvedPath = path.posix.resolve(workspaceUri.path, searchPath);\n\t\t\t\treturn [{\n\t\t\t\t\tsearchPath: workspaceUri.with({ path: resolvedPath })\n\t\t\t\t}];\n\t\t\t}\n\n\t\t\tconst cleanedPattern = normalizeGlobPattern(searchPath);\n\t\t\treturn [{\n\t\t\t\tsearchPath: workspaceUri,\n\t\t\t\tpattern: cleanedPattern\n\t\t\t}];\n\t\t} else if (searchPath === './' || searchPath === '.\\\\') {\n\t\t\treturn []; // ./ or ./**/foo makes sense for single-folder but not multi-folder workspaces\n\t\t} else {\n\t\t\tconst searchPathWithoutDotSlash = searchPath.replace(/^\\.[\\/\\\\]/, '');\n\t\t\tconst folders = this.workspaceContextService.getWorkspace().folders;\n\t\t\tconst folderMatches = folders.map(folder => {\n\t\t\t\tconst match = searchPathWithoutDotSlash.match(new RegExp(`^${strings.escapeRegExpCharacters(folder.name)}(?:/(.*)|$)`));\n\t\t\t\treturn match ? {\n\t\t\t\t\tmatch,\n\t\t\t\t\tfolder\n\t\t\t\t} : null;\n\t\t\t}).filter(isDefined);\n\n\t\t\tif (folderMatches.length) {\n\t\t\t\treturn folderMatches.map(match => {\n\t\t\t\t\tconst patternMatch = match.match[1];\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsearchPath: match.folder.uri,\n\t\t\t\t\t\tpattern: patternMatch && normalizeGlobPattern(patternMatch)\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tconst probableWorkspaceFolderNameMatch = searchPath.match(/\\.[\\/\\\\](.+)[\\/\\\\]?/);\n\t\t\t\tconst probableWorkspaceFolderName = probableWorkspaceFolderNameMatch ? probableWorkspaceFolderNameMatch[1] : searchPath;\n\n\t\t\t\t// No root folder with name\n\t\t\t\tconst searchPathNotFoundError = nls.localize('search.noWorkspaceWithName', \"Workspace folder does not exist: {0}\", probableWorkspaceFolderName);\n\t\t\t\tthrow new Error(searchPathNotFoundError);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate resolveOneSearchPathPattern(oneExpandedResult: IOneSearchPathPattern, globPortion?: string): IOneSearchPathPattern[] {\n\t\tconst pattern = oneExpandedResult.pattern && globPortion ?\n\t\t\t`${oneExpandedResult.pattern}/${globPortion}` :\n\t\t\toneExpandedResult.pattern || globPortion;\n\n\t\tconst results = [\n\t\t\t{\n\t\t\t\tsearchPath: oneExpandedResult.searchPath,\n\t\t\t\tpattern\n\t\t\t}];\n\n\t\tif (pattern && !pattern.endsWith('**')) {\n\t\t\tresults.push({\n\t\t\t\tsearchPath: oneExpandedResult.searchPath,\n\t\t\t\tpattern: pattern + '/**'\n\t\t\t});\n\t\t}\n\n\t\treturn results;\n\t}\n\n\tprivate getFolderQueryForSearchPath(searchPath: ISearchPathPattern, options: ICommonQueryBuilderOptions, searchPathExcludes: ISearchPathsInfo): IFolderQuery | null {\n\t\tconst rootConfig = this.getFolderQueryForRoot(toWorkspaceFolder(searchPath.searchPath), options, searchPathExcludes, false);\n\t\tif (!rootConfig) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\t...rootConfig,\n\t\t\t...{\n\t\t\t\tincludePattern: searchPath.pattern\n\t\t\t}\n\t\t};\n\t}\n\n\tprivate getFolderQueryForRoot(folder: (IWorkspaceFolderData | URI), options: ICommonQueryBuilderOptions, searchPathExcludes: ISearchPathsInfo, includeFolderName: boolean): IFolderQuery | null {\n\t\tlet thisFolderExcludeSearchPathPattern: glob.IExpression | undefined;\n\t\tconst folderUri = URI.isUri(folder) ? folder : folder.uri;\n\n\t\t// only use exclude root if it is different from the folder root\n\t\tlet excludeFolderRoots = options.excludePattern?.map(excludePattern => {\n\t\t\tconst excludeRoot = options.excludePattern && isISearchPatternBuilder(excludePattern) ? excludePattern.uri : undefined;\n\t\t\tconst shouldUseExcludeRoot = (!excludeRoot || !(URI.isUri(folder) && this.uriIdentityService.extUri.isEqual(folder, excludeRoot)));\n\t\t\treturn shouldUseExcludeRoot ? excludeRoot : undefined;\n\t\t});\n\n\t\tif (!excludeFolderRoots?.length) {\n\t\t\texcludeFolderRoots = [undefined];\n\t\t}\n\n\t\tif (searchPathExcludes.searchPaths) {\n\t\t\tconst thisFolderExcludeSearchPath = searchPathExcludes.searchPaths.filter(sp => isEqual(sp.searchPath, folderUri))[0];\n\t\t\tif (thisFolderExcludeSearchPath && !thisFolderExcludeSearchPath.pattern) {\n\t\t\t\t// entire folder is excluded\n\t\t\t\treturn null;\n\t\t\t} else if (thisFolderExcludeSearchPath) {\n\t\t\t\tthisFolderExcludeSearchPathPattern = thisFolderExcludeSearchPath.pattern;\n\t\t\t}\n\t\t}\n\n\t\tconst folderConfig = this.configurationService.getValue<ISearchConfiguration>({ resource: folderUri });\n\t\tconst settingExcludes = this.getExcludesForFolder(folderConfig, options);\n\t\tconst excludePattern: glob.IExpression = {\n\t\t\t...(settingExcludes || {}),\n\t\t\t...(thisFolderExcludeSearchPathPattern || {})\n\t\t};\n\n\t\tconst folderName = URI.isUri(folder) ? basename(folder) : folder.name;\n\n\t\tconst excludePatternRet: ExcludeGlobPattern[] = excludeFolderRoots.map(excludeFolderRoot => {\n\t\t\treturn Object.keys(excludePattern).length > 0 ? {\n\t\t\t\tfolder: excludeFolderRoot,\n\t\t\t\tpattern: excludePattern\n\t\t\t} satisfies ExcludeGlobPattern : undefined;\n\t\t}).filter((e) => e) as ExcludeGlobPattern[];\n\n\t\treturn {\n\t\t\tfolder: folderUri,\n\t\t\tfolderName: includeFolderName ? folderName : undefined,\n\t\t\texcludePattern: excludePatternRet,\n\t\t\tfileEncoding: folderConfig.files && folderConfig.files.encoding,\n\t\t\tdisregardIgnoreFiles: typeof options.disregardIgnoreFiles === 'boolean' ? options.disregardIgnoreFiles : !folderConfig.search.useIgnoreFiles,\n\t\t\tdisregardGlobalIgnoreFiles: typeof options.disregardGlobalIgnoreFiles === 'boolean' ? options.disregardGlobalIgnoreFiles : !folderConfig.search.useGlobalIgnoreFiles,\n\t\t\tdisregardParentIgnoreFiles: typeof options.disregardParentIgnoreFiles === 'boolean' ? options.disregardParentIgnoreFiles : !folderConfig.search.useParentIgnoreFiles,\n\t\t\tignoreSymlinks: typeof options.ignoreSymlinks === 'boolean' ? options.ignoreSymlinks : !folderConfig.search.followSymlinks,\n\t\t};\n\t}\n}\n\nfunction splitGlobFromPath(searchPath: string): { pathPortion: string; globPortion?: string } {\n\tconst globCharMatch = searchPath.match(/[\\*\\{\\}\\(\\)\\[\\]\\?]/);\n\tif (globCharMatch) {\n\t\tconst globCharIdx = globCharMatch.index;\n\t\tconst lastSlashMatch = searchPath.substr(0, globCharIdx).match(/[/|\\\\][^/\\\\]*$/);\n\t\tif (lastSlashMatch) {\n\t\t\tlet pathPortion = searchPath.substr(0, lastSlashMatch.index);\n\t\t\tif (!pathPortion.match(/[/\\\\]/)) {\n\t\t\t\t// If the last slash was the only slash, then we now have '' or 'C:' or '.'. Append a slash.\n\t\t\t\tpathPortion += '/';\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tpathPortion,\n\t\t\t\tglobPortion: searchPath.substr((lastSlashMatch.index || 0) + 1)\n\t\t\t};\n\t\t}\n\t}\n\n\t// No glob char, or malformed\n\treturn {\n\t\tpathPortion: searchPath\n\t};\n}\n\nfunction patternListToIExpression(...patterns: string[]): glob.IExpression {\n\treturn patterns.length ?\n\t\tpatterns.reduce((glob, cur) => { glob[cur] = true; return glob; }, Object.create(null)) :\n\t\tundefined;\n}\n\nfunction splitGlobPattern(pattern: string): string[] {\n\treturn glob.splitGlobAware(pattern, ',')\n\t\t.map(s => s.trim())\n\t\t.filter(s => !!s.length);\n}\n\n/**\n * Note - we used {} here previously but ripgrep can't handle nested {} patterns. See https://github.com/microsoft/vscode/issues/32761\n */\nfunction expandGlobalGlob(pattern: string): string[] {\n\tconst patterns = [\n\t\t`**/${pattern}/**`,\n\t\t`**/${pattern}`\n\t];\n\n\treturn patterns.map(p => p.replace(/\\*\\*\\/\\*\\*/g, '**'));\n}\n\nfunction normalizeSlashes(pattern: string): string {\n\treturn pattern.replace(/\\\\/g, '/');\n}\n\n/**\n * Normalize slashes, remove `./` and trailing slashes\n */\nfunction normalizeGlobPattern(pattern: string): string {\n\treturn normalizeSlashes(pattern)\n\t\t.replace(/^\\.\\//, '')\n\t\t.replace(/\\/+$/g, '');\n}\n\n/**\n * Escapes a path for use as a glob pattern that would match the input precisely.\n * Characters '?', '*', '[', and ']' are escaped into character range glob syntax\n * (for example, '?' becomes '[?]').\n * NOTE: This implementation makes no special cases for UNC paths. For example,\n * given the input \"//?/C:/A?.txt\", this would produce output '//[?]/C:/A[?].txt',\n * which may not be desirable in some cases. Use with caution if UNC paths could be expected.\n */\nfunction escapeGlobPattern(path: string): string {\n\treturn path.replace(/([?*[\\]])/g, '[$1]');\n}\n\n/**\n * Construct an include pattern from a list of folders uris to search in.\n */\nexport function resolveResourcesForSearchIncludes(resources: URI[], contextService: IWorkspaceContextService): string[] {\n\tresources = arrays.distinct(resources, resource => resource.toString());\n\n\tconst folderPaths: string[] = [];\n\tconst workspace = contextService.getWorkspace();\n\n\tif (resources) {\n\t\tresources.forEach(resource => {\n\t\t\tlet folderPath: string | undefined;\n\t\t\tif (contextService.getWorkbenchState() === WorkbenchState.FOLDER) {\n\t\t\t\t// Show relative path from the root for single-root mode\n\t\t\t\tfolderPath = relativePath(workspace.folders[0].uri, resource); // always uses forward slashes\n\t\t\t\tif (folderPath && folderPath !== '.') {\n\t\t\t\t\tfolderPath = './' + folderPath;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst owningFolder = contextService.getWorkspaceFolder(resource);\n\t\t\t\tif (owningFolder) {\n\t\t\t\t\tconst owningRootName = owningFolder.name;\n\t\t\t\t\t// If this root is the only one with its basename, use a relative ./ path. If there is another, use an absolute path\n\t\t\t\t\tconst isUniqueFolder = workspace.folders.filter(folder => folder.name === owningRootName).length === 1;\n\t\t\t\t\tif (isUniqueFolder) {\n\t\t\t\t\t\tconst relPath = relativePath(owningFolder.uri, resource); // always uses forward slashes\n\t\t\t\t\t\tif (relPath === '') {\n\t\t\t\t\t\t\tfolderPath = `./${owningFolder.name}`;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfolderPath = `./${owningFolder.name}/${relPath}`;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfolderPath = resource.fsPath; // TODO rob: handle non-file URIs\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (folderPath) {\n\t\t\t\tfolderPaths.push(escapeGlobPattern(folderPath));\n\t\t\t}\n\t\t});\n\t}\n\treturn folderPaths;\n}\n"],
  "mappings": "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",
  "names": ["excludePattern", "glob", "path"]
}
