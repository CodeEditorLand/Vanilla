{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/search/common/searchExtConversionTypes.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { asArray, coalesce } from \"../../../../base/common/arrays.js\";\nimport type { CancellationToken } from \"../../../../base/common/cancellation.js\";\nimport type { URI } from \"../../../../base/common/uri.js\";\nimport type { IProgress } from \"../../../../platform/progress/common/progress.js\";\nimport { DEFAULT_TEXT_SEARCH_PREVIEW_OPTIONS } from \"./search.js\";\nimport {\n\ttype AITextSearchProviderNew,\n\ttype FileSearchProviderNew,\n\ttype FileSearchProviderOptions,\n\ttype ProviderResult,\n\ttype Range,\n\ttype TextSearchCompleteMessage,\n\ttype TextSearchCompleteNew,\n\tTextSearchContextNew,\n\tTextSearchMatchNew,\n\ttype TextSearchProviderNew,\n\ttype TextSearchProviderOptions,\n\ttype TextSearchQueryNew,\n\ttype TextSearchResultNew,\n} from \"./searchExtTypes.js\";\n\n// old types that are retained for backward compatibility\n// TODO: delete this when search apis are adopted by all first-party extensions\n\n/**\n * A relative pattern is a helper to construct glob patterns that are matched\n * relatively to a base path. The base path can either be an absolute file path\n * or a [workspace folder](#WorkspaceFolder).\n */\nexport interface RelativePattern {\n\t/**\n\t * A base file path to which this pattern will be matched against relatively.\n\t */\n\tbase: string;\n\n\t/**\n\t * A file glob pattern like `*.{ts,js}` that will be matched on file paths\n\t * relative to the base path.\n\t *\n\t * Example: Given a base of `/home/work/folder` and a file path of `/home/work/folder/index.js`,\n\t * the file glob pattern will match on `index.js`.\n\t */\n\tpattern: string;\n}\n\n/**\n * A file glob pattern to match file paths against. This can either be a glob pattern string\n * (like `** /*.{ts,js}` without space before / or `*.{ts,js}`) or a [relative pattern](#RelativePattern).\n *\n * Glob patterns can have the following syntax:\n * * `*` to match zero or more characters in a path segment\n * * `?` to match on one character in a path segment\n * * `**` to match any number of path segments, including none\n * * `{}` to group conditions (e.g. `** /*.{ts,js}` without space before / matches all TypeScript and JavaScript files)\n * * `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, \u2026)\n * * `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)\n *\n * Note: a backslash (`\\`) is not valid within a glob pattern. If you have an existing file\n * path to match against, consider to use the [relative pattern](#RelativePattern) support\n * that takes care of converting any backslash into slash. Otherwise, make sure to convert\n * any backslash to slash when creating the glob pattern.\n */\nexport type GlobPattern = string | RelativePattern;\n\n/**\n * The parameters of a query for text search.\n */\nexport interface TextSearchQuery {\n\t/**\n\t * The text pattern to search for.\n\t */\n\tpattern: string;\n\n\t/**\n\t * Whether or not `pattern` should match multiple lines of text.\n\t */\n\tisMultiline?: boolean;\n\n\t/**\n\t * Whether or not `pattern` should be interpreted as a regular expression.\n\t */\n\tisRegExp?: boolean;\n\n\t/**\n\t * Whether or not the search should be case-sensitive.\n\t */\n\tisCaseSensitive?: boolean;\n\n\t/**\n\t * Whether or not to search for whole word matches only.\n\t */\n\tisWordMatch?: boolean;\n}\n\n/**\n * A file glob pattern to match file paths against.\n * TODO@roblou - merge this with the GlobPattern docs/definition in vscode.d.ts.\n * @see [GlobPattern](#GlobPattern)\n */\nexport type GlobString = string;\n\n/**\n * Options common to file and text search\n */\nexport interface SearchOptions {\n\t/**\n\t * The root folder to search within.\n\t */\n\tfolder: URI;\n\n\t/**\n\t * Files that match an `includes` glob pattern should be included in the search.\n\t */\n\tincludes: GlobString[];\n\n\t/**\n\t * Files that match an `excludes` glob pattern should be excluded from the search.\n\t */\n\texcludes: GlobString[];\n\n\t/**\n\t * Whether external files that exclude files, like .gitignore, should be respected.\n\t * See the vscode setting `\"search.useIgnoreFiles\"`.\n\t */\n\tuseIgnoreFiles: boolean;\n\n\t/**\n\t * Whether symlinks should be followed while searching.\n\t * See the vscode setting `\"search.followSymlinks\"`.\n\t */\n\tfollowSymlinks: boolean;\n\n\t/**\n\t * Whether global files that exclude files, like .gitignore, should be respected.\n\t * See the vscode setting `\"search.useGlobalIgnoreFiles\"`.\n\t */\n\tuseGlobalIgnoreFiles: boolean;\n\n\t/**\n\t * Whether files in parent directories that exclude files, like .gitignore, should be respected.\n\t * See the vscode setting `\"search.useParentIgnoreFiles\"`.\n\t */\n\tuseParentIgnoreFiles: boolean;\n}\n\n/**\n * Options to specify the size of the result text preview.\n * These options don't affect the size of the match itself, just the amount of preview text.\n */\nexport interface TextSearchPreviewOptions {\n\t/**\n\t * The maximum number of lines in the preview.\n\t * Only search providers that support multiline search will ever return more than one line in the match.\n\t */\n\tmatchLines: number;\n\n\t/**\n\t * The maximum number of characters included per line.\n\t */\n\tcharsPerLine: number;\n}\n\n/**\n * Options that apply to text search.\n */\nexport interface TextSearchOptions extends SearchOptions {\n\t/**\n\t * The maximum number of results to be returned.\n\t */\n\tmaxResults: number;\n\n\t/**\n\t * Options to specify the size of the result text preview.\n\t */\n\tpreviewOptions?: TextSearchPreviewOptions;\n\n\t/**\n\t * Exclude files larger than `maxFileSize` in bytes.\n\t */\n\tmaxFileSize?: number;\n\n\t/**\n\t * Interpret files using this encoding.\n\t * See the vscode setting `\"files.encoding\"`\n\t */\n\tencoding?: string;\n\n\t/**\n\t * Number of lines of context to include before each match.\n\t */\n\tbeforeContext?: number;\n\n\t/**\n\t * Number of lines of context to include after each match.\n\t */\n\tafterContext?: number;\n}\n/**\n * Options that apply to AI text search.\n */\nexport interface AITextSearchOptions extends SearchOptions {\n\t/**\n\t * The maximum number of results to be returned.\n\t */\n\tmaxResults: number;\n\n\t/**\n\t * Options to specify the size of the result text preview.\n\t */\n\tpreviewOptions?: TextSearchPreviewOptions;\n\n\t/**\n\t * Exclude files larger than `maxFileSize` in bytes.\n\t */\n\tmaxFileSize?: number;\n\n\t/**\n\t * Number of lines of context to include before each match.\n\t */\n\tbeforeContext?: number;\n\n\t/**\n\t * Number of lines of context to include after each match.\n\t */\n\tafterContext?: number;\n}\n\n/**\n * Information collected when text search is complete.\n */\nexport interface TextSearchComplete {\n\t/**\n\t * Whether the search hit the limit on the maximum number of search results.\n\t * `maxResults` on [`TextSearchOptions`](#TextSearchOptions) specifies the max number of results.\n\t * - If exactly that number of matches exist, this should be false.\n\t * - If `maxResults` matches are returned and more exist, this should be true.\n\t * - If search hits an internal limit which is less than `maxResults`, this should be true.\n\t */\n\tlimitHit?: boolean;\n\n\t/**\n\t * Additional information regarding the state of the completed search.\n\t *\n\t * Supports links in markdown syntax:\n\t * - Click to [run a command](command:workbench.action.OpenQuickPick)\n\t * - Click to [open a website](https://aka.ms)\n\t */\n\tmessage?: TextSearchCompleteMessage | TextSearchCompleteMessage[];\n}\n\n/**\n * The parameters of a query for file search.\n */\nexport interface FileSearchQuery {\n\t/**\n\t * The search pattern to match against file paths.\n\t */\n\tpattern: string;\n}\n\n/**\n * Options that apply to file search.\n */\nexport interface FileSearchOptions extends SearchOptions {\n\t/**\n\t * The maximum number of results to be returned.\n\t */\n\tmaxResults?: number;\n\n\t/**\n\t * A CancellationToken that represents the session for this search query. If the provider chooses to, this object can be used as the key for a cache,\n\t * and searches with the same session object can search the same cache. When the token is cancelled, the session is complete and the cache can be cleared.\n\t */\n\tsession?: CancellationToken;\n}\n\n/**\n * A preview of the text result.\n */\nexport interface TextSearchMatchPreview {\n\t/**\n\t * The matching lines of text, or a portion of the matching line that contains the match.\n\t */\n\ttext: string;\n\n\t/**\n\t * The Range within `text` corresponding to the text of the match.\n\t * The number of matches must match the TextSearchMatch's range property.\n\t */\n\tmatches: Range | Range[];\n}\n\n/**\n * A match from a text search\n */\nexport interface TextSearchMatch {\n\t/**\n\t * The uri for the matching document.\n\t */\n\turi: URI;\n\n\t/**\n\t * The range of the match within the document, or multiple ranges for multiple matches.\n\t */\n\tranges: Range | Range[];\n\n\t/**\n\t * A preview of the text match.\n\t */\n\tpreview: TextSearchMatchPreview;\n}\n\n/**\n * Checks if the given object is of type TextSearchMatch.\n * @param object The object to check.\n * @returns True if the object is a TextSearchMatch, false otherwise.\n */\nfunction isTextSearchMatch(object: any): object is TextSearchMatch {\n\treturn \"uri\" in object && \"ranges\" in object && \"preview\" in object;\n}\n\n/**\n * A line of context surrounding a TextSearchMatch.\n */\nexport interface TextSearchContext {\n\t/**\n\t * The uri for the matching document.\n\t */\n\turi: URI;\n\n\t/**\n\t * One line of text.\n\t * previewOptions.charsPerLine applies to this\n\t */\n\ttext: string;\n\n\t/**\n\t * The line number of this line of context.\n\t */\n\tlineNumber: number;\n}\n\nexport type TextSearchResult = TextSearchMatch | TextSearchContext;\n\n/**\n * A FileSearchProvider provides search results for files in the given folder that match a query string. It can be invoked by quickaccess or other extensions.\n *\n * A FileSearchProvider is the more powerful of two ways to implement file search in VS Code. Use a FileSearchProvider if you wish to search within a folder for\n * all files that match the user's query.\n *\n * The FileSearchProvider will be invoked on every keypress in quickaccess. When `workspace.findFiles` is called, it will be invoked with an empty query string,\n * and in that case, every file in the folder should be returned.\n */\nexport interface FileSearchProvider {\n\t/**\n\t * Provide the set of files that match a certain file path pattern.\n\t * @param query The parameters for this query.\n\t * @param options A set of options to consider while searching files.\n\t * @param progress A progress callback that must be invoked for all results.\n\t * @param token A cancellation token.\n\t */\n\tprovideFileSearchResults(\n\t\tquery: FileSearchQuery,\n\t\toptions: FileSearchOptions,\n\t\ttoken: CancellationToken,\n\t): ProviderResult<URI[]>;\n}\n\n/**\n * A TextSearchProvider provides search results for text results inside files in the workspace.\n */\nexport interface TextSearchProvider {\n\t/**\n\t * Provide results that match the given text pattern.\n\t * @param query The parameters for this query.\n\t * @param options A set of options to consider while searching.\n\t * @param progress A progress callback that must be invoked for all results.\n\t * @param token A cancellation token.\n\t */\n\tprovideTextSearchResults(\n\t\tquery: TextSearchQuery,\n\t\toptions: TextSearchOptions,\n\t\tprogress: IProgress<TextSearchResult>,\n\t\ttoken: CancellationToken,\n\t): ProviderResult<TextSearchComplete>;\n}\n\nexport interface AITextSearchProvider {\n\t/**\n\t * Provide results that match the given text pattern.\n\t * @param query The parameter for this query.\n\t * @param options A set of options to consider while searching.\n\t * @param progress A progress callback that must be invoked for all results.\n\t * @param token A cancellation token.\n\t */\n\tprovideAITextSearchResults(\n\t\tquery: string,\n\t\toptions: AITextSearchOptions,\n\t\tprogress: IProgress<TextSearchResult>,\n\t\ttoken: CancellationToken,\n\t): ProviderResult<TextSearchComplete>;\n}\n\n/**\n * Options that can be set on a findTextInFiles search.\n */\nexport interface FindTextInFilesOptions {\n\t/**\n\t * A [glob pattern](#GlobPattern) that defines the files to search for. The glob pattern\n\t * will be matched against the file paths of files relative to their workspace. Use a [relative pattern](#RelativePattern)\n\t * to restrict the search results to a [workspace folder](#WorkspaceFolder).\n\t */\n\tinclude?: GlobPattern;\n\n\t/**\n\t * A [glob pattern](#GlobPattern) that defines files and folders to exclude. The glob pattern\n\t * will be matched against the file paths of resulting matches relative to their workspace. When `undefined` only default excludes will\n\t * apply, when `null` no excludes will apply.\n\t */\n\texclude?: GlobPattern | null;\n\n\t/**\n\t * The maximum number of results to search for\n\t */\n\tmaxResults?: number;\n\n\t/**\n\t * Whether external files that exclude files, like .gitignore, should be respected.\n\t * See the vscode setting `\"search.useIgnoreFiles\"`.\n\t */\n\tuseIgnoreFiles?: boolean;\n\n\t/**\n\t * Whether global files that exclude files, like .gitignore, should be respected.\n\t * See the vscode setting `\"search.useGlobalIgnoreFiles\"`.\n\t */\n\tuseGlobalIgnoreFiles?: boolean;\n\n\t/**\n\t * Whether files in parent directories that exclude files, like .gitignore, should be respected.\n\t * See the vscode setting `\"search.useParentIgnoreFiles\"`.\n\t */\n\tuseParentIgnoreFiles: boolean;\n\n\t/**\n\t * Whether symlinks should be followed while searching.\n\t * See the vscode setting `\"search.followSymlinks\"`.\n\t */\n\tfollowSymlinks?: boolean;\n\n\t/**\n\t * Interpret files using this encoding.\n\t * See the vscode setting `\"files.encoding\"`\n\t */\n\tencoding?: string;\n\n\t/**\n\t * Options to specify the size of the result text preview.\n\t */\n\tpreviewOptions?: TextSearchPreviewOptions;\n\n\t/**\n\t * Number of lines of context to include before each match.\n\t */\n\tbeforeContext?: number;\n\n\t/**\n\t * Number of lines of context to include after each match.\n\t */\n\tafterContext?: number;\n}\n\nfunction newToOldFileProviderOptions(\n\toptions: FileSearchProviderOptions,\n): FileSearchOptions[] {\n\treturn options.folderOptions.map(\n\t\t(folderOption) =>\n\t\t\t({\n\t\t\t\tfolder: folderOption.folder,\n\t\t\t\texcludes: folderOption.excludes.map((e) =>\n\t\t\t\t\ttypeof e === \"string\" ? e : e.pattern,\n\t\t\t\t),\n\t\t\t\tincludes: folderOption.includes,\n\t\t\t\tuseGlobalIgnoreFiles: folderOption.useIgnoreFiles.global,\n\t\t\t\tuseIgnoreFiles: folderOption.useIgnoreFiles.local,\n\t\t\t\tuseParentIgnoreFiles: folderOption.useIgnoreFiles.parent,\n\t\t\t\tfollowSymlinks: folderOption.followSymlinks,\n\t\t\t\tmaxResults: options.maxResults,\n\t\t\t\tsession: <CancellationToken | undefined>options.session, // TODO: make sure that we actually use a cancellation token here.\n\t\t\t}) satisfies FileSearchOptions,\n\t);\n}\n\nexport class OldFileSearchProviderConverter implements FileSearchProviderNew {\n\tconstructor(private provider: FileSearchProvider) {}\n\n\tprovideFileSearchResults(\n\t\tpattern: string,\n\t\toptions: FileSearchProviderOptions,\n\t\ttoken: CancellationToken,\n\t): ProviderResult<URI[]> {\n\t\tconst getResult = async () => {\n\t\t\tconst newOpts = newToOldFileProviderOptions(options);\n\t\t\treturn Promise.all(\n\t\t\t\tnewOpts.map((o) =>\n\t\t\t\t\tthis.provider.provideFileSearchResults(\n\t\t\t\t\t\t{ pattern },\n\t\t\t\t\t\to,\n\t\t\t\t\t\ttoken,\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t);\n\t\t};\n\t\treturn getResult().then((e) => coalesce(e).flat());\n\t}\n}\n\nfunction newToOldTextProviderOptions(\n\toptions: TextSearchProviderOptions,\n): TextSearchOptions[] {\n\treturn options.folderOptions.map(\n\t\t(folderOption) =>\n\t\t\t({\n\t\t\t\tfolder: folderOption.folder,\n\t\t\t\texcludes: folderOption.excludes.map((e) =>\n\t\t\t\t\ttypeof e === \"string\" ? e : e.pattern,\n\t\t\t\t),\n\t\t\t\tincludes: folderOption.includes,\n\t\t\t\tuseGlobalIgnoreFiles: folderOption.useIgnoreFiles.global,\n\t\t\t\tuseIgnoreFiles: folderOption.useIgnoreFiles.local,\n\t\t\t\tuseParentIgnoreFiles: folderOption.useIgnoreFiles.parent,\n\t\t\t\tfollowSymlinks: folderOption.followSymlinks,\n\t\t\t\tmaxResults: options.maxResults,\n\t\t\t\tpreviewOptions: newToOldPreviewOptions(options.previewOptions),\n\t\t\t\tmaxFileSize: options.maxFileSize,\n\t\t\t\tencoding: folderOption.encoding,\n\t\t\t\tafterContext: options.surroundingContext,\n\t\t\t\tbeforeContext: options.surroundingContext,\n\t\t\t}) satisfies TextSearchOptions,\n\t);\n}\n\nexport function newToOldPreviewOptions(\n\toptions:\n\t\t| {\n\t\t\t\tmatchLines?: number;\n\t\t\t\tcharsPerLine?: number;\n\t\t  }\n\t\t| undefined,\n): {\n\tmatchLines: number;\n\tcharsPerLine: number;\n} {\n\treturn {\n\t\tmatchLines:\n\t\t\toptions?.matchLines ??\n\t\t\tDEFAULT_TEXT_SEARCH_PREVIEW_OPTIONS.matchLines,\n\t\tcharsPerLine:\n\t\t\toptions?.charsPerLine ??\n\t\t\tDEFAULT_TEXT_SEARCH_PREVIEW_OPTIONS.charsPerLine,\n\t};\n}\n\nexport function oldToNewTextSearchResult(\n\tresult: TextSearchResult,\n): TextSearchResultNew {\n\tif (isTextSearchMatch(result)) {\n\t\tconst ranges = asArray(result.ranges).map((r, i) => {\n\t\t\tconst previewArr = asArray(result.preview.matches);\n\t\t\tconst matchingPreviewRange = previewArr[i];\n\t\t\treturn { sourceRange: r, previewRange: matchingPreviewRange };\n\t\t});\n\t\treturn new TextSearchMatchNew(result.uri, ranges, result.preview.text);\n\t} else {\n\t\treturn new TextSearchContextNew(\n\t\t\tresult.uri,\n\t\t\tresult.text,\n\t\t\tresult.lineNumber,\n\t\t);\n\t}\n}\n\nexport class OldTextSearchProviderConverter implements TextSearchProviderNew {\n\tconstructor(private provider: TextSearchProvider) {}\n\n\tprovideTextSearchResults(\n\t\tquery: TextSearchQueryNew,\n\t\toptions: TextSearchProviderOptions,\n\t\tprogress: IProgress<TextSearchResultNew>,\n\t\ttoken: CancellationToken,\n\t): ProviderResult<TextSearchCompleteNew> {\n\t\tconst progressShim = (oldResult: TextSearchResult) => {\n\t\t\tif (!validateProviderResult(oldResult)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tprogress.report(oldToNewTextSearchResult(oldResult));\n\t\t};\n\n\t\tconst getResult = async () => {\n\t\t\treturn coalesce(\n\t\t\t\tawait Promise.all(\n\t\t\t\t\tnewToOldTextProviderOptions(options).map((o) =>\n\t\t\t\t\t\tthis.provider.provideTextSearchResults(\n\t\t\t\t\t\t\tquery,\n\t\t\t\t\t\t\to,\n\t\t\t\t\t\t\t{ report: (e) => progressShim(e) },\n\t\t\t\t\t\t\ttoken,\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t).reduce(\n\t\t\t\t(prev, cur) => ({ limitHit: prev.limitHit || cur.limitHit }),\n\t\t\t\t{ limitHit: false },\n\t\t\t);\n\t\t};\n\t\tconst oldResult = getResult();\n\t\treturn oldResult.then((e) => {\n\t\t\treturn {\n\t\t\t\tlimitHit: e.limitHit,\n\t\t\t\tmessage: coalesce(asArray(e.message)),\n\t\t\t} satisfies TextSearchCompleteNew;\n\t\t});\n\t}\n}\n\nexport class OldAITextSearchProviderConverter\n\timplements AITextSearchProviderNew\n{\n\tconstructor(private provider: AITextSearchProvider) {}\n\n\tprovideAITextSearchResults(\n\t\tquery: string,\n\t\toptions: TextSearchProviderOptions,\n\t\tprogress: IProgress<TextSearchResultNew>,\n\t\ttoken: CancellationToken,\n\t): ProviderResult<TextSearchCompleteNew> {\n\t\tconst progressShim = (oldResult: TextSearchResult) => {\n\t\t\tif (!validateProviderResult(oldResult)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tprogress.report(oldToNewTextSearchResult(oldResult));\n\t\t};\n\n\t\tconst getResult = async () => {\n\t\t\treturn coalesce(\n\t\t\t\tawait Promise.all(\n\t\t\t\t\tnewToOldTextProviderOptions(options).map((o) =>\n\t\t\t\t\t\tthis.provider.provideAITextSearchResults(\n\t\t\t\t\t\t\tquery,\n\t\t\t\t\t\t\to,\n\t\t\t\t\t\t\t{ report: (e) => progressShim(e) },\n\t\t\t\t\t\t\ttoken,\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t).reduce(\n\t\t\t\t(prev, cur) => ({ limitHit: prev.limitHit || cur.limitHit }),\n\t\t\t\t{ limitHit: false },\n\t\t\t);\n\t\t};\n\t\tconst oldResult = getResult();\n\t\treturn oldResult.then((e) => {\n\t\t\treturn {\n\t\t\t\tlimitHit: e.limitHit,\n\t\t\t\tmessage: coalesce(asArray(e.message)),\n\t\t\t} satisfies TextSearchCompleteNew;\n\t\t});\n\t}\n}\n\nfunction validateProviderResult(result: TextSearchResult): boolean {\n\tif (extensionResultIsMatch(result)) {\n\t\tif (Array.isArray(result.ranges)) {\n\t\t\tif (!Array.isArray(result.preview.matches)) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t\"INVALID - A text search provider match's`ranges` and`matches` properties must have the same type.\",\n\t\t\t\t);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t(<Range[]>result.preview.matches).length !==\n\t\t\t\tresult.ranges.length\n\t\t\t) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t\"INVALID - A text search provider match's`ranges` and`matches` properties must have the same length.\",\n\t\t\t\t);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (Array.isArray(result.preview.matches)) {\n\t\t\tconsole.warn(\n\t\t\t\t\"INVALID - A text search provider match's`ranges` and`matches` properties must have the same length.\",\n\t\t\t);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nexport function extensionResultIsMatch(\n\tdata: TextSearchResult,\n): data is TextSearchMatch {\n\treturn !!(<TextSearchMatch>data).preview;\n}\n"],
  "mappings": "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",
  "names": ["oldResult"]
}
