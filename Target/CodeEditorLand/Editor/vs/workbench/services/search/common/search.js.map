{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/search/common/search.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { mapArrayOrNot } from \"../../../../base/common/arrays.js\";\nimport { isThenable } from \"../../../../base/common/async.js\";\nimport type { CancellationToken } from \"../../../../base/common/cancellation.js\";\nimport { isCancellationError } from \"../../../../base/common/errors.js\";\nimport type { Event } from \"../../../../base/common/event.js\";\nimport * as extpath from \"../../../../base/common/extpath.js\";\nimport * as glob from \"../../../../base/common/glob.js\";\nimport type { IDisposable } from \"../../../../base/common/lifecycle.js\";\nimport type { ResourceSet } from \"../../../../base/common/map.js\";\nimport * as objects from \"../../../../base/common/objects.js\";\nimport * as paths from \"../../../../base/common/path.js\";\nimport { fuzzyContains, getNLines } from \"../../../../base/common/strings.js\";\nimport type { URI, UriComponents } from \"../../../../base/common/uri.js\";\nimport type { IFilesConfiguration } from \"../../../../platform/files/common/files.js\";\nimport { createDecorator } from \"../../../../platform/instantiation/common/instantiation.js\";\nimport type { ITelemetryData } from \"../../../../platform/telemetry/common/telemetry.js\";\nimport {\n\ttype GlobPattern,\n\tTextSearchCompleteMessageType,\n} from \"./searchExtTypes.js\";\n\nexport { TextSearchCompleteMessageType };\n\nexport const VIEWLET_ID = \"workbench.view.search\";\nexport const PANEL_ID = \"workbench.panel.search\";\nexport const VIEW_ID = \"workbench.view.search\";\nexport const SEARCH_RESULT_LANGUAGE_ID = \"search-result\";\n\nexport const SEARCH_EXCLUDE_CONFIG = \"search.exclude\";\nexport const DEFAULT_MAX_SEARCH_RESULTS = 20000;\n\n// Warning: this pattern is used in the search editor to detect offsets. If you\n// change this, also change the search-result built-in extension\nconst SEARCH_ELIDED_PREFIX = \"\u27EA \";\nconst SEARCH_ELIDED_SUFFIX = \" characters skipped \u27EB\";\nconst SEARCH_ELIDED_MIN_LEN =\n\t(SEARCH_ELIDED_PREFIX.length + SEARCH_ELIDED_SUFFIX.length + 5) * 2;\n\nexport const ISearchService = createDecorator<ISearchService>(\"searchService\");\n\n/**\n * A service that enables to search for files or with in files.\n */\nexport interface ISearchService {\n\treadonly _serviceBrand: undefined;\n\ttextSearch(\n\t\tquery: ITextQuery,\n\t\ttoken?: CancellationToken,\n\t\tonProgress?: (result: ISearchProgressItem) => void,\n\t): Promise<ISearchComplete>;\n\taiTextSearch(\n\t\tquery: IAITextQuery,\n\t\ttoken?: CancellationToken,\n\t\tonProgress?: (result: ISearchProgressItem) => void,\n\t): Promise<ISearchComplete>;\n\ttextSearchSplitSyncAsync(\n\t\tquery: ITextQuery,\n\t\ttoken?: CancellationToken | undefined,\n\t\tonProgress?: ((result: ISearchProgressItem) => void) | undefined,\n\t\tnotebookFilesToIgnore?: ResourceSet,\n\t\tasyncNotebookFilesToIgnore?: Promise<ResourceSet>,\n\t): { syncResults: ISearchComplete; asyncResults: Promise<ISearchComplete> };\n\tfileSearch(\n\t\tquery: IFileQuery,\n\t\ttoken?: CancellationToken,\n\t): Promise<ISearchComplete>;\n\tclearCache(cacheKey: string): Promise<void>;\n\tregisterSearchResultProvider(\n\t\tscheme: string,\n\t\ttype: SearchProviderType,\n\t\tprovider: ISearchResultProvider,\n\t): IDisposable;\n}\n\n/**\n * TODO@roblou - split text from file search entirely, or share code in a more natural way.\n */\nexport enum SearchProviderType {\n\tfile = 0,\n\ttext = 1,\n\taiText = 2,\n}\n\nexport interface ISearchResultProvider {\n\ttextSearch(\n\t\tquery: ITextQuery,\n\t\tonProgress?: (p: ISearchProgressItem) => void,\n\t\ttoken?: CancellationToken,\n\t): Promise<ISearchComplete>;\n\tfileSearch(\n\t\tquery: IFileQuery,\n\t\ttoken?: CancellationToken,\n\t): Promise<ISearchComplete>;\n\tclearCache(cacheKey: string): Promise<void>;\n}\n\nexport interface ExcludeGlobPattern<U extends UriComponents = URI> {\n\tfolder?: U;\n\tpattern: glob.IExpression;\n}\n\nexport interface IFolderQuery<U extends UriComponents = URI> {\n\tfolder: U;\n\tfolderName?: string;\n\texcludePattern?: ExcludeGlobPattern<U>[];\n\tincludePattern?: glob.IExpression;\n\tfileEncoding?: string;\n\tdisregardIgnoreFiles?: boolean;\n\tdisregardGlobalIgnoreFiles?: boolean;\n\tdisregardParentIgnoreFiles?: boolean;\n\tignoreSymlinks?: boolean;\n}\n\nexport interface ICommonQueryProps<U extends UriComponents> {\n\t/** For telemetry - indicates what is triggering the source */\n\t_reason?: string;\n\n\tfolderQueries: IFolderQuery<U>[];\n\t// The include pattern for files that gets passed into ripgrep.\n\t// Note that this will override any ignore files if applicable.\n\tincludePattern?: glob.IExpression;\n\texcludePattern?: glob.IExpression;\n\textraFileResources?: U[];\n\n\tonlyOpenEditors?: boolean;\n\n\tmaxResults?: number;\n\tusingSearchPaths?: boolean;\n\tonlyFileScheme?: boolean;\n}\n\nexport interface IFileQueryProps<U extends UriComponents>\n\textends ICommonQueryProps<U> {\n\ttype: QueryType.File;\n\tfilePattern?: string;\n\n\t// when walking through the tree to find the result, don't use the filePattern to fuzzy match.\n\t// Instead, should use glob matching.\n\tshouldGlobMatchFilePattern?: boolean;\n\n\t/**\n\t * If true no results will be returned. Instead `limitHit` will indicate if at least one result exists or not.\n\t * Currently does not work with queries including a 'siblings clause'.\n\t */\n\texists?: boolean;\n\tsortByScore?: boolean;\n\tcacheKey?: string;\n}\n\nexport interface ITextQueryProps<U extends UriComponents>\n\textends ICommonQueryProps<U> {\n\ttype: QueryType.Text;\n\tcontentPattern: IPatternInfo;\n\n\tpreviewOptions?: ITextSearchPreviewOptions;\n\tmaxFileSize?: number;\n\tusePCRE2?: boolean;\n\tsurroundingContext?: number;\n\n\tuserDisabledExcludesAndIgnoreFiles?: boolean;\n}\n\nexport interface IAITextQueryProps<U extends UriComponents>\n\textends ICommonQueryProps<U> {\n\ttype: QueryType.aiText;\n\tcontentPattern: string;\n\n\tpreviewOptions?: ITextSearchPreviewOptions;\n\tmaxFileSize?: number;\n\tsurroundingContext?: number;\n\n\tuserDisabledExcludesAndIgnoreFiles?: boolean;\n}\n\nexport type IFileQuery = IFileQueryProps<URI>;\nexport type IRawFileQuery = IFileQueryProps<UriComponents>;\nexport type ITextQuery = ITextQueryProps<URI>;\nexport type IRawTextQuery = ITextQueryProps<UriComponents>;\nexport type IAITextQuery = IAITextQueryProps<URI>;\nexport type IRawAITextQuery = IAITextQueryProps<UriComponents>;\n\nexport type IRawQuery = IRawTextQuery | IRawFileQuery | IRawAITextQuery;\nexport type ISearchQuery = ITextQuery | IFileQuery | IAITextQuery;\n\nexport enum QueryType {\n\tFile = 1,\n\tText = 2,\n\taiText = 3,\n}\n\n/* __GDPR__FRAGMENT__\n\t\"IPatternInfo\" : {\n\t\t\"isRegExp\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n\t\t\"isWordMatch\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n\t\t\"wordSeparators\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n\t\t\"isMultiline\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n\t\t\"isCaseSensitive\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n\t\t\"isSmartCase\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true }\n\t}\n*/\nexport interface IPatternInfo {\n\tpattern: string;\n\tisRegExp?: boolean;\n\tisWordMatch?: boolean;\n\twordSeparators?: string;\n\tisMultiline?: boolean;\n\tisUnicode?: boolean;\n\tisCaseSensitive?: boolean;\n\tnotebookInfo?: INotebookPatternInfo;\n}\n\nexport interface INotebookPatternInfo {\n\tisInNotebookMarkdownInput?: boolean;\n\tisInNotebookMarkdownPreview?: boolean;\n\tisInNotebookCellInput?: boolean;\n\tisInNotebookCellOutput?: boolean;\n}\n\nexport interface IExtendedExtensionSearchOptions {\n\tusePCRE2?: boolean;\n}\n\nexport interface IFileMatch<U extends UriComponents = URI> {\n\tresource: U;\n\tresults?: ITextSearchResult<U>[];\n}\n\nexport type IRawFileMatch2 = IFileMatch<UriComponents>;\n\nexport interface ITextSearchPreviewOptions {\n\tmatchLines: number;\n\tcharsPerLine: number;\n}\n\nexport interface ISearchRange {\n\treadonly startLineNumber: number;\n\treadonly startColumn: number;\n\treadonly endLineNumber: number;\n\treadonly endColumn: number;\n}\n\nexport interface ITextSearchMatch<U extends UriComponents = URI> {\n\turi?: U;\n\trangeLocations: SearchRangeSetPairing[];\n\tpreviewText: string;\n\twebviewIndex?: number;\n\tcellFragment?: string;\n}\n\nexport interface ITextSearchContext<U extends UriComponents = URI> {\n\turi?: U;\n\ttext: string;\n\tlineNumber: number;\n}\n\nexport type ITextSearchResult<U extends UriComponents = URI> =\n\t| ITextSearchMatch<U>\n\t| ITextSearchContext<U>;\n\nexport function resultIsMatch(\n\tresult: ITextSearchResult,\n): result is ITextSearchMatch {\n\treturn (\n\t\t!!(<ITextSearchMatch>result).rangeLocations &&\n\t\t!!(<ITextSearchMatch>result).previewText\n\t);\n}\n\nexport interface IProgressMessage {\n\tmessage: string;\n}\n\nexport type ISearchProgressItem = IFileMatch | IProgressMessage;\n\nexport function isFileMatch(p: ISearchProgressItem): p is IFileMatch {\n\treturn !!(<IFileMatch>p).resource;\n}\n\nexport function isProgressMessage(\n\tp: ISearchProgressItem | ISerializedSearchProgressItem,\n): p is IProgressMessage {\n\treturn !!(p as IProgressMessage).message;\n}\n\nexport interface ITextSearchCompleteMessage {\n\ttext: string;\n\ttype: TextSearchCompleteMessageType;\n\ttrusted?: boolean;\n}\n\nexport interface ISearchCompleteStats {\n\tlimitHit?: boolean;\n\tmessages: ITextSearchCompleteMessage[];\n\tstats?: IFileSearchStats | ITextSearchStats;\n}\n\nexport interface ISearchComplete extends ISearchCompleteStats {\n\tresults: IFileMatch[];\n\texit?: SearchCompletionExitCode;\n}\n\nexport enum SearchCompletionExitCode {\n\tNormal = 0,\n\tNewSearchStarted = 1,\n}\n\nexport interface ITextSearchStats {\n\ttype: \"textSearchProvider\" | \"searchProcess\" | \"aiTextSearchProvider\";\n}\n\nexport interface IFileSearchStats {\n\tfromCache: boolean;\n\tdetailStats:\n\t\t| ISearchEngineStats\n\t\t| ICachedSearchStats\n\t\t| IFileSearchProviderStats;\n\n\tresultCount: number;\n\ttype: \"fileSearchProvider\" | \"searchProcess\";\n\tsortingTime?: number;\n}\n\nexport interface ICachedSearchStats {\n\tcacheWasResolved: boolean;\n\tcacheLookupTime: number;\n\tcacheFilterTime: number;\n\tcacheEntryCount: number;\n}\n\nexport interface ISearchEngineStats {\n\tfileWalkTime: number;\n\tdirectoriesWalked: number;\n\tfilesWalked: number;\n\tcmdTime: number;\n\tcmdResultCount?: number;\n}\n\nexport interface IFileSearchProviderStats {\n\tproviderTime: number;\n\tpostProcessTime: number;\n}\n\nexport class FileMatch implements IFileMatch {\n\tresults: ITextSearchResult[] = [];\n\tconstructor(public resource: URI) {\n\t\t// empty\n\t}\n}\n\nexport interface SearchRangeSetPairing {\n\tsource: ISearchRange;\n\tpreview: ISearchRange;\n}\n\nexport class TextSearchMatch implements ITextSearchMatch {\n\trangeLocations: SearchRangeSetPairing[] = [];\n\tpreviewText: string;\n\twebviewIndex?: number;\n\n\tconstructor(\n\t\ttext: string,\n\t\tranges: ISearchRange | ISearchRange[],\n\t\tpreviewOptions?: ITextSearchPreviewOptions,\n\t\twebviewIndex?: number,\n\t) {\n\t\tthis.webviewIndex = webviewIndex;\n\n\t\t// Trim preview if this is one match and a single-line match with a preview requested.\n\t\t// Otherwise send the full text, like for replace or for showing multiple previews.\n\t\t// TODO this is fishy.\n\t\tconst rangesArr = Array.isArray(ranges) ? ranges : [ranges];\n\n\t\tif (\n\t\t\tpreviewOptions &&\n\t\t\tpreviewOptions.matchLines === 1 &&\n\t\t\tisSingleLineRangeList(rangesArr)\n\t\t) {\n\t\t\t// 1 line preview requested\n\t\t\ttext = getNLines(text, previewOptions.matchLines);\n\n\t\t\tlet result = \"\";\n\t\t\tlet shift = 0;\n\t\t\tlet lastEnd = 0;\n\t\t\tconst leadingChars = Math.floor(previewOptions.charsPerLine / 5);\n\t\t\tfor (const range of rangesArr) {\n\t\t\t\tconst previewStart = Math.max(\n\t\t\t\t\trange.startColumn - leadingChars,\n\t\t\t\t\t0,\n\t\t\t\t);\n\t\t\t\tconst previewEnd =\n\t\t\t\t\trange.startColumn + previewOptions.charsPerLine;\n\t\t\t\tif (\n\t\t\t\t\tpreviewStart >\n\t\t\t\t\tlastEnd + leadingChars + SEARCH_ELIDED_MIN_LEN\n\t\t\t\t) {\n\t\t\t\t\tconst elision =\n\t\t\t\t\t\tSEARCH_ELIDED_PREFIX +\n\t\t\t\t\t\t(previewStart - lastEnd) +\n\t\t\t\t\t\tSEARCH_ELIDED_SUFFIX;\n\t\t\t\t\tresult += elision + text.slice(previewStart, previewEnd);\n\t\t\t\t\tshift += previewStart - (lastEnd + elision.length);\n\t\t\t\t} else {\n\t\t\t\t\tresult += text.slice(lastEnd, previewEnd);\n\t\t\t\t}\n\n\t\t\t\tlastEnd = previewEnd;\n\t\t\t\tthis.rangeLocations.push({\n\t\t\t\t\tsource: range,\n\t\t\t\t\tpreview: new OneLineRange(\n\t\t\t\t\t\t0,\n\t\t\t\t\t\trange.startColumn - shift,\n\t\t\t\t\t\trange.endColumn - shift,\n\t\t\t\t\t),\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis.previewText = result;\n\t\t} else {\n\t\t\tconst firstMatchLine = Array.isArray(ranges)\n\t\t\t\t? ranges[0].startLineNumber\n\t\t\t\t: ranges.startLineNumber;\n\n\t\t\tconst rangeLocs = mapArrayOrNot(ranges, (r) => ({\n\t\t\t\tpreview: new SearchRange(\n\t\t\t\t\tr.startLineNumber - firstMatchLine,\n\t\t\t\t\tr.startColumn,\n\t\t\t\t\tr.endLineNumber - firstMatchLine,\n\t\t\t\t\tr.endColumn,\n\t\t\t\t),\n\t\t\t\tsource: r,\n\t\t\t}));\n\n\t\t\tthis.rangeLocations = Array.isArray(rangeLocs)\n\t\t\t\t? rangeLocs\n\t\t\t\t: [rangeLocs];\n\t\t\tthis.previewText = text;\n\t\t}\n\t}\n}\n\nfunction isSingleLineRangeList(ranges: ISearchRange[]): boolean {\n\tconst line = ranges[0].startLineNumber;\n\tfor (const r of ranges) {\n\t\tif (r.startLineNumber !== line || r.endLineNumber !== line) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nexport class SearchRange implements ISearchRange {\n\tstartLineNumber: number;\n\tstartColumn: number;\n\tendLineNumber: number;\n\tendColumn: number;\n\n\tconstructor(\n\t\tstartLineNumber: number,\n\t\tstartColumn: number,\n\t\tendLineNumber: number,\n\t\tendColumn: number,\n\t) {\n\t\tthis.startLineNumber = startLineNumber;\n\t\tthis.startColumn = startColumn;\n\t\tthis.endLineNumber = endLineNumber;\n\t\tthis.endColumn = endColumn;\n\t}\n}\n\nexport class OneLineRange extends SearchRange {\n\tconstructor(lineNumber: number, startColumn: number, endColumn: number) {\n\t\tsuper(lineNumber, startColumn, lineNumber, endColumn);\n\t}\n}\n\nexport enum ViewMode {\n\tList = \"list\",\n\tTree = \"tree\",\n}\n\nexport enum SearchSortOrder {\n\tDefault = \"default\",\n\tFileNames = \"fileNames\",\n\tType = \"type\",\n\tModified = \"modified\",\n\tCountDescending = \"countDescending\",\n\tCountAscending = \"countAscending\",\n}\n\nexport interface ISearchConfigurationProperties {\n\texclude: glob.IExpression;\n\tuseRipgrep: boolean;\n\t/**\n\t * Use ignore file for file search.\n\t */\n\tuseIgnoreFiles: boolean;\n\tuseGlobalIgnoreFiles: boolean;\n\tuseParentIgnoreFiles: boolean;\n\tfollowSymlinks: boolean;\n\tsmartCase: boolean;\n\tglobalFindClipboard: boolean;\n\tlocation: \"sidebar\" | \"panel\";\n\tuseReplacePreview: boolean;\n\tshowLineNumbers: boolean;\n\tusePCRE2: boolean;\n\tactionsPosition: \"auto\" | \"right\";\n\tmaintainFileSearchCache: boolean;\n\tmaxResults: number | null;\n\tcollapseResults: \"auto\" | \"alwaysCollapse\" | \"alwaysExpand\";\n\tsearchOnType: boolean;\n\tseedOnFocus: boolean;\n\tseedWithNearestWord: boolean;\n\tsearchOnTypeDebouncePeriod: number;\n\tmode: \"view\" | \"reuseEditor\" | \"newEditor\";\n\tsearchEditor: {\n\t\tdoubleClickBehaviour:\n\t\t\t| \"selectWord\"\n\t\t\t| \"goToLocation\"\n\t\t\t| \"openLocationToSide\";\n\t\tsingleClickBehaviour: \"default\" | \"peekDefinition\";\n\t\treusePriorSearchConfiguration: boolean;\n\t\tdefaultNumberOfContextLines: number | null;\n\t\tfocusResultsOnSearch: boolean;\n\t\texperimental: {};\n\t};\n\tsortOrder: SearchSortOrder;\n\tdecorations: {\n\t\tcolors: boolean;\n\t\tbadges: boolean;\n\t};\n\tquickAccess: {\n\t\tpreserveInput: boolean;\n\t};\n\tdefaultViewMode: ViewMode;\n\texperimental: {\n\t\tclosedNotebookRichContentResults: boolean;\n\t};\n}\n\nexport interface ISearchConfiguration extends IFilesConfiguration {\n\tsearch: ISearchConfigurationProperties;\n\teditor: {\n\t\twordSeparators: string;\n\t};\n}\n\nexport function getExcludes(\n\tconfiguration: ISearchConfiguration,\n\tincludeSearchExcludes = true,\n): glob.IExpression | undefined {\n\tconst fileExcludes =\n\t\tconfiguration && configuration.files && configuration.files.exclude;\n\tconst searchExcludes =\n\t\tincludeSearchExcludes &&\n\t\tconfiguration &&\n\t\tconfiguration.search &&\n\t\tconfiguration.search.exclude;\n\n\tif (!fileExcludes && !searchExcludes) {\n\t\treturn undefined;\n\t}\n\n\tif (!fileExcludes || !searchExcludes) {\n\t\treturn fileExcludes || searchExcludes || undefined;\n\t}\n\n\tlet allExcludes: glob.IExpression = Object.create(null);\n\t// clone the config as it could be frozen\n\tallExcludes = objects.mixin(allExcludes, objects.deepClone(fileExcludes));\n\tallExcludes = objects.mixin(\n\t\tallExcludes,\n\t\tobjects.deepClone(searchExcludes),\n\t\ttrue,\n\t);\n\n\treturn allExcludes;\n}\n\nexport function pathIncludedInQuery(\n\tqueryProps: ICommonQueryProps<URI>,\n\tfsPath: string,\n): boolean {\n\tif (\n\t\tqueryProps.excludePattern &&\n\t\tglob.match(queryProps.excludePattern, fsPath)\n\t) {\n\t\treturn false;\n\t}\n\n\tif (queryProps.includePattern || queryProps.usingSearchPaths) {\n\t\tif (\n\t\t\tqueryProps.includePattern &&\n\t\t\tglob.match(queryProps.includePattern, fsPath)\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// If searchPaths are being used, the extra file must be in a subfolder and match the pattern, if present\n\t\tif (queryProps.usingSearchPaths) {\n\t\t\treturn (\n\t\t\t\t!!queryProps.folderQueries &&\n\t\t\t\tqueryProps.folderQueries.some((fq) => {\n\t\t\t\t\tconst searchPath = fq.folder.fsPath;\n\t\t\t\t\tif (extpath.isEqualOrParent(fsPath, searchPath)) {\n\t\t\t\t\t\tconst relPath = paths.relative(searchPath, fsPath);\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t!fq.includePattern ||\n\t\t\t\t\t\t\t!!glob.match(fq.includePattern, relPath)\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nexport enum SearchErrorCode {\n\tunknownEncoding = 1,\n\tregexParseError = 2,\n\tglobParseError = 3,\n\tinvalidLiteral = 4,\n\trgProcessError = 5,\n\tother = 6,\n\tcanceled = 7,\n}\n\nexport class SearchError extends Error {\n\tconstructor(\n\t\tmessage: string,\n\t\treadonly code?: SearchErrorCode,\n\t) {\n\t\tsuper(message);\n\t}\n}\n\nexport function deserializeSearchError(error: Error): SearchError {\n\tconst errorMsg = error.message;\n\n\tif (isCancellationError(error)) {\n\t\treturn new SearchError(errorMsg, SearchErrorCode.canceled);\n\t}\n\n\ttry {\n\t\tconst details = JSON.parse(errorMsg);\n\t\treturn new SearchError(details.message, details.code);\n\t} catch (e) {\n\t\treturn new SearchError(errorMsg, SearchErrorCode.other);\n\t}\n}\n\nexport function serializeSearchError(searchError: SearchError): Error {\n\tconst details = { message: searchError.message, code: searchError.code };\n\treturn new Error(JSON.stringify(details));\n}\nexport interface ITelemetryEvent {\n\teventName: string;\n\tdata: ITelemetryData;\n}\n\nexport interface IRawSearchService {\n\tfileSearch(\n\t\tsearch: IRawFileQuery,\n\t): Event<ISerializedSearchProgressItem | ISerializedSearchComplete>;\n\ttextSearch(\n\t\tsearch: IRawTextQuery,\n\t): Event<ISerializedSearchProgressItem | ISerializedSearchComplete>;\n\tclearCache(cacheKey: string): Promise<void>;\n}\n\nexport interface IRawFileMatch {\n\tbase?: string;\n\t/**\n\t * The path of the file relative to the containing `base` folder.\n\t * This path is exactly as it appears on the filesystem.\n\t */\n\trelativePath: string;\n\t/**\n\t * This path is transformed for search purposes. For example, this could be\n\t * the `relativePath` with the workspace folder name prepended. This way the\n\t * search algorithm would also match against the name of the containing folder.\n\t *\n\t * If not given, the search algorithm should use `relativePath`.\n\t */\n\tsearchPath: string | undefined;\n}\n\nexport interface ISearchEngine<T> {\n\tsearch: (\n\t\tonResult: (matches: T) => void,\n\t\tonProgress: (progress: IProgressMessage) => void,\n\t\tdone: (error: Error | null, complete: ISearchEngineSuccess) => void,\n\t) => void;\n\tcancel: () => void;\n}\n\nexport interface ISerializedSearchSuccess {\n\ttype: \"success\";\n\tlimitHit: boolean;\n\tmessages: ITextSearchCompleteMessage[];\n\tstats?: IFileSearchStats | ITextSearchStats;\n}\n\nexport interface ISearchEngineSuccess {\n\tlimitHit: boolean;\n\tmessages: ITextSearchCompleteMessage[];\n\tstats: ISearchEngineStats;\n}\n\nexport interface ISerializedSearchError {\n\ttype: \"error\";\n\terror: {\n\t\tmessage: string;\n\t\tstack: string;\n\t};\n}\n\nexport type ISerializedSearchComplete =\n\t| ISerializedSearchSuccess\n\t| ISerializedSearchError;\n\nexport function isSerializedSearchComplete(\n\targ: ISerializedSearchProgressItem | ISerializedSearchComplete,\n): arg is ISerializedSearchComplete {\n\tif ((arg as any).type === \"error\") {\n\t\treturn true;\n\t} else if ((arg as any).type === \"success\") {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nexport function isSerializedSearchSuccess(\n\targ: ISerializedSearchComplete,\n): arg is ISerializedSearchSuccess {\n\treturn arg.type === \"success\";\n}\n\nexport function isSerializedFileMatch(\n\targ: ISerializedSearchProgressItem,\n): arg is ISerializedFileMatch {\n\treturn !!(<ISerializedFileMatch>arg).path;\n}\n\nexport function isFilePatternMatch(\n\tcandidate: IRawFileMatch,\n\tfilePatternToUse: string,\n\tfuzzy = true,\n): boolean {\n\tconst pathToMatch = candidate.searchPath\n\t\t? candidate.searchPath\n\t\t: candidate.relativePath;\n\treturn fuzzy\n\t\t? fuzzyContains(pathToMatch, filePatternToUse)\n\t\t: glob.match(filePatternToUse, pathToMatch);\n}\n\nexport interface ISerializedFileMatch {\n\tpath: string;\n\tresults?: ITextSearchResult[];\n\tnumMatches?: number;\n}\n\n// Type of the possible values for progress calls from the engine\nexport type ISerializedSearchProgressItem =\n\t| ISerializedFileMatch\n\t| ISerializedFileMatch[]\n\t| IProgressMessage;\nexport type IFileSearchProgressItem =\n\t| IRawFileMatch\n\t| IRawFileMatch[]\n\t| IProgressMessage;\n\nexport class SerializableFileMatch implements ISerializedFileMatch {\n\tpath: string;\n\tresults: ITextSearchMatch[];\n\n\tconstructor(path: string) {\n\t\tthis.path = path;\n\t\tthis.results = [];\n\t}\n\n\taddMatch(match: ITextSearchMatch): void {\n\t\tthis.results.push(match);\n\t}\n\n\tserialize(): ISerializedFileMatch {\n\t\treturn {\n\t\t\tpath: this.path,\n\t\t\tresults: this.results,\n\t\t\tnumMatches: this.results.length,\n\t\t};\n\t}\n}\n\n/**\n *  Computes the patterns that the provider handles. Discards sibling clauses and 'false' patterns\n */\nexport function resolvePatternsForProvider(\n\tglobalPattern: glob.IExpression | undefined,\n\tfolderPattern: glob.IExpression | undefined,\n): string[] {\n\tconst merged = {\n\t\t...(globalPattern || {}),\n\t\t...(folderPattern || {}),\n\t};\n\n\treturn Object.keys(merged).filter((key) => {\n\t\tconst value = merged[key];\n\t\treturn typeof value === \"boolean\" && value;\n\t});\n}\n\nexport class QueryGlobTester {\n\tprivate _excludeExpression: glob.IExpression[]; // TODO: evaluate globs based on baseURI of pattern\n\tprivate _parsedExcludeExpression: glob.ParsedExpression[];\n\n\tprivate _parsedIncludeExpression: glob.ParsedExpression | null = null;\n\n\tconstructor(config: ISearchQuery, folderQuery: IFolderQuery) {\n\t\t// todo: try to incorporate folderQuery.excludePattern.folder if available\n\t\tthis._excludeExpression =\n\t\t\tfolderQuery.excludePattern?.map((excludePattern) => {\n\t\t\t\treturn {\n\t\t\t\t\t...(config.excludePattern || {}),\n\t\t\t\t\t...(excludePattern.pattern || {}),\n\t\t\t\t} satisfies glob.IExpression;\n\t\t\t}) ?? [];\n\n\t\tif (this._excludeExpression.length === 0) {\n\t\t\t// even if there are no folderQueries, we want to observe  the global excludes\n\t\t\tthis._excludeExpression = [config.excludePattern || {}];\n\t\t}\n\n\t\tthis._parsedExcludeExpression = this._excludeExpression.map((e) =>\n\t\t\tglob.parse(e),\n\t\t);\n\n\t\t// Empty includeExpression means include nothing, so no {} shortcuts\n\t\tlet includeExpression: glob.IExpression | undefined =\n\t\t\tconfig.includePattern;\n\t\tif (folderQuery.includePattern) {\n\t\t\tif (includeExpression) {\n\t\t\t\tincludeExpression = {\n\t\t\t\t\t...includeExpression,\n\t\t\t\t\t...folderQuery.includePattern,\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tincludeExpression = folderQuery.includePattern;\n\t\t\t}\n\t\t}\n\n\t\tif (includeExpression) {\n\t\t\tthis._parsedIncludeExpression = glob.parse(includeExpression);\n\t\t}\n\t}\n\n\tprivate _evalParsedExcludeExpression(\n\t\ttestPath: string,\n\t\tbasename: string | undefined,\n\t\thasSibling?: (name: string) => boolean,\n\t): string | null {\n\t\t// todo: less hacky way of evaluating sync vs async sibling clauses\n\t\tlet result: string | null = null;\n\n\t\tfor (const folderExclude of this._parsedExcludeExpression) {\n\t\t\t// find first non-null result\n\t\t\tconst evaluation = folderExclude(testPath, basename, hasSibling);\n\n\t\t\tif (typeof evaluation === \"string\") {\n\t\t\t\tresult = evaluation;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tmatchesExcludesSync(\n\t\ttestPath: string,\n\t\tbasename?: string,\n\t\thasSibling?: (name: string) => boolean,\n\t): boolean {\n\t\tif (\n\t\t\tthis._parsedExcludeExpression &&\n\t\t\tthis._evalParsedExcludeExpression(testPath, basename, hasSibling)\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Guaranteed sync - siblingsFn should not return a promise.\n\t */\n\tincludedInQuerySync(\n\t\ttestPath: string,\n\t\tbasename?: string,\n\t\thasSibling?: (name: string) => boolean,\n\t): boolean {\n\t\tif (\n\t\t\tthis._parsedExcludeExpression &&\n\t\t\tthis._evalParsedExcludeExpression(testPath, basename, hasSibling)\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (\n\t\t\tthis._parsedIncludeExpression &&\n\t\t\t!this._parsedIncludeExpression(testPath, basename, hasSibling)\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Evaluating the exclude expression is only async if it includes sibling clauses. As an optimization, avoid doing anything with Promises\n\t * unless the expression is async.\n\t */\n\tincludedInQuery(\n\t\ttestPath: string,\n\t\tbasename?: string,\n\t\thasSibling?: (name: string) => boolean | Promise<boolean>,\n\t): Promise<boolean> | boolean {\n\t\tconst isIncluded = () => {\n\t\t\treturn this._parsedIncludeExpression\n\t\t\t\t? !!this._parsedIncludeExpression(\n\t\t\t\t\t\ttestPath,\n\t\t\t\t\t\tbasename,\n\t\t\t\t\t\thasSibling,\n\t\t\t\t\t)\n\t\t\t\t: true;\n\t\t};\n\n\t\treturn Promise.all(\n\t\t\tthis._parsedExcludeExpression.map((e) => {\n\t\t\t\tconst excluded = e(testPath, basename, hasSibling);\n\t\t\t\tif (isThenable(excluded)) {\n\t\t\t\t\treturn excluded.then((excluded) => {\n\t\t\t\t\t\tif (excluded) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn isIncluded();\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn isIncluded();\n\t\t\t}),\n\t\t).then((e) => e.some((e) => !!e));\n\t}\n\n\thasSiblingExcludeClauses(): boolean {\n\t\treturn this._excludeExpression.reduce(\n\t\t\t(prev, curr) => hasSiblingClauses(curr) || prev,\n\t\t\tfalse,\n\t\t);\n\t}\n}\n\nfunction hasSiblingClauses(pattern: glob.IExpression): boolean {\n\tfor (const key in pattern) {\n\t\tif (typeof pattern[key] !== \"boolean\") {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport function hasSiblingPromiseFn(siblingsFn?: () => Promise<string[]>) {\n\tif (!siblingsFn) {\n\t\treturn undefined;\n\t}\n\n\tlet siblings: Promise<Record<string, true>>;\n\treturn (name: string) => {\n\t\tif (!siblings) {\n\t\t\tsiblings = (siblingsFn() || Promise.resolve([])).then((list) =>\n\t\t\t\tlist ? listToMap(list) : {},\n\t\t\t);\n\t\t}\n\t\treturn siblings.then((map) => !!map[name]);\n\t};\n}\n\nexport function hasSiblingFn(siblingsFn?: () => string[]) {\n\tif (!siblingsFn) {\n\t\treturn undefined;\n\t}\n\n\tlet siblings: Record<string, true>;\n\treturn (name: string) => {\n\t\tif (!siblings) {\n\t\t\tconst list = siblingsFn();\n\t\t\tsiblings = list ? listToMap(list) : {};\n\t\t}\n\t\treturn !!siblings[name];\n\t};\n}\n\nfunction listToMap(list: string[]) {\n\tconst map: Record<string, true> = {};\n\tfor (const key of list) {\n\t\tmap[key] = true;\n\t}\n\treturn map;\n}\n\nexport function excludeToGlobPattern(\n\texcludesForFolder: { baseUri?: URI | undefined; patterns: string[] }[],\n): GlobPattern[] {\n\treturn excludesForFolder.flatMap((exclude) =>\n\t\texclude.patterns.map((pattern) => {\n\t\t\treturn exclude.baseUri\n\t\t\t\t? {\n\t\t\t\t\t\tbaseUri: exclude.baseUri,\n\t\t\t\t\t\tpattern: pattern,\n\t\t\t\t\t}\n\t\t\t\t: pattern;\n\t\t}),\n\t);\n}\n\nexport const DEFAULT_TEXT_SEARCH_PREVIEW_OPTIONS = {\n\tmatchLines: 100,\n\tcharsPerLine: 10000,\n};\n"],
  "mappings": "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",
  "names": ["SearchProviderType", "QueryType", "SearchCompletionExitCode", "ViewMode", "SearchSortOrder", "SearchErrorCode", "excluded", "e"]
}
