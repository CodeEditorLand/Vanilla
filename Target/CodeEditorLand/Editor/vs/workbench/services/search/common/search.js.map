{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/search/common/search.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { mapArrayOrNot } from '../../../../base/common/arrays.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport * as glob from '../../../../base/common/glob.js';\nimport { IDisposable } from '../../../../base/common/lifecycle.js';\nimport * as objects from '../../../../base/common/objects.js';\nimport * as extpath from '../../../../base/common/extpath.js';\nimport { fuzzyContains, getNLines } from '../../../../base/common/strings.js';\nimport { URI, UriComponents } from '../../../../base/common/uri.js';\nimport { IFilesConfiguration } from '../../../../platform/files/common/files.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ITelemetryData } from '../../../../platform/telemetry/common/telemetry.js';\nimport { Event } from '../../../../base/common/event.js';\nimport * as paths from '../../../../base/common/path.js';\nimport { isCancellationError } from '../../../../base/common/errors.js';\nimport { GlobPattern, TextSearchCompleteMessageType } from './searchExtTypes.js';\nimport { isThenable } from '../../../../base/common/async.js';\nimport { ResourceSet } from '../../../../base/common/map.js';\n\nexport { TextSearchCompleteMessageType };\n\nexport const VIEWLET_ID = 'workbench.view.search';\nexport const PANEL_ID = 'workbench.panel.search';\nexport const VIEW_ID = 'workbench.view.search';\nexport const SEARCH_RESULT_LANGUAGE_ID = 'search-result';\n\nexport const SEARCH_EXCLUDE_CONFIG = 'search.exclude';\nexport const DEFAULT_MAX_SEARCH_RESULTS = 20000;\n\n// Warning: this pattern is used in the search editor to detect offsets. If you\n// change this, also change the search-result built-in extension\nconst SEARCH_ELIDED_PREFIX = '\u27EA ';\nconst SEARCH_ELIDED_SUFFIX = ' characters skipped \u27EB';\nconst SEARCH_ELIDED_MIN_LEN = (SEARCH_ELIDED_PREFIX.length + SEARCH_ELIDED_SUFFIX.length + 5) * 2;\n\nexport const ISearchService = createDecorator<ISearchService>('searchService');\n\n/**\n * A service that enables to search for files or with in files.\n */\nexport interface ISearchService {\n\treadonly _serviceBrand: undefined;\n\ttextSearch(query: ITextQuery, token?: CancellationToken, onProgress?: (result: ISearchProgressItem) => void): Promise<ISearchComplete>;\n\taiTextSearch(query: IAITextQuery, token?: CancellationToken, onProgress?: (result: ISearchProgressItem) => void): Promise<ISearchComplete>;\n\ttextSearchSplitSyncAsync(query: ITextQuery, token?: CancellationToken | undefined, onProgress?: ((result: ISearchProgressItem) => void) | undefined, notebookFilesToIgnore?: ResourceSet, asyncNotebookFilesToIgnore?: Promise<ResourceSet>): { syncResults: ISearchComplete; asyncResults: Promise<ISearchComplete> };\n\tfileSearch(query: IFileQuery, token?: CancellationToken): Promise<ISearchComplete>;\n\tclearCache(cacheKey: string): Promise<void>;\n\tregisterSearchResultProvider(scheme: string, type: SearchProviderType, provider: ISearchResultProvider): IDisposable;\n}\n\n/**\n * TODO@roblou - split text from file search entirely, or share code in a more natural way.\n */\nexport const enum SearchProviderType {\n\tfile,\n\ttext,\n\taiText\n}\n\nexport interface ISearchResultProvider {\n\ttextSearch(query: ITextQuery, onProgress?: (p: ISearchProgressItem) => void, token?: CancellationToken): Promise<ISearchComplete>;\n\tfileSearch(query: IFileQuery, token?: CancellationToken): Promise<ISearchComplete>;\n\tclearCache(cacheKey: string): Promise<void>;\n}\n\n\nexport interface ExcludeGlobPattern<U extends UriComponents = URI> {\n\tfolder?: U;\n\tpattern: glob.IExpression;\n}\n\nexport interface IFolderQuery<U extends UriComponents = URI> {\n\tfolder: U;\n\tfolderName?: string;\n\texcludePattern?: ExcludeGlobPattern<U>[];\n\tincludePattern?: glob.IExpression;\n\tfileEncoding?: string;\n\tdisregardIgnoreFiles?: boolean;\n\tdisregardGlobalIgnoreFiles?: boolean;\n\tdisregardParentIgnoreFiles?: boolean;\n\tignoreSymlinks?: boolean;\n}\n\nexport interface ICommonQueryProps<U extends UriComponents> {\n\t/** For telemetry - indicates what is triggering the source */\n\t_reason?: string;\n\n\tfolderQueries: IFolderQuery<U>[];\n\t// The include pattern for files that gets passed into ripgrep.\n\t// Note that this will override any ignore files if applicable.\n\tincludePattern?: glob.IExpression;\n\texcludePattern?: glob.IExpression;\n\textraFileResources?: U[];\n\n\tonlyOpenEditors?: boolean;\n\n\tmaxResults?: number;\n\tusingSearchPaths?: boolean;\n\tonlyFileScheme?: boolean;\n}\n\nexport interface IFileQueryProps<U extends UriComponents> extends ICommonQueryProps<U> {\n\ttype: QueryType.File;\n\tfilePattern?: string;\n\n\t// when walking through the tree to find the result, don't use the filePattern to fuzzy match.\n\t// Instead, should use glob matching.\n\tshouldGlobMatchFilePattern?: boolean;\n\n\t/**\n\t * If true no results will be returned. Instead `limitHit` will indicate if at least one result exists or not.\n\t * Currently does not work with queries including a 'siblings clause'.\n\t */\n\texists?: boolean;\n\tsortByScore?: boolean;\n\tcacheKey?: string;\n}\n\nexport interface ITextQueryProps<U extends UriComponents> extends ICommonQueryProps<U> {\n\ttype: QueryType.Text;\n\tcontentPattern: IPatternInfo;\n\n\tpreviewOptions?: ITextSearchPreviewOptions;\n\tmaxFileSize?: number;\n\tusePCRE2?: boolean;\n\tsurroundingContext?: number;\n\n\tuserDisabledExcludesAndIgnoreFiles?: boolean;\n}\n\nexport interface IAITextQueryProps<U extends UriComponents> extends ICommonQueryProps<U> {\n\ttype: QueryType.aiText;\n\tcontentPattern: string;\n\n\tpreviewOptions?: ITextSearchPreviewOptions;\n\tmaxFileSize?: number;\n\tsurroundingContext?: number;\n\n\tuserDisabledExcludesAndIgnoreFiles?: boolean;\n}\n\nexport type IFileQuery = IFileQueryProps<URI>;\nexport type IRawFileQuery = IFileQueryProps<UriComponents>;\nexport type ITextQuery = ITextQueryProps<URI>;\nexport type IRawTextQuery = ITextQueryProps<UriComponents>;\nexport type IAITextQuery = IAITextQueryProps<URI>;\nexport type IRawAITextQuery = IAITextQueryProps<UriComponents>;\n\nexport type IRawQuery = IRawTextQuery | IRawFileQuery | IRawAITextQuery;\nexport type ISearchQuery = ITextQuery | IFileQuery | IAITextQuery;\n\nexport const enum QueryType {\n\tFile = 1,\n\tText = 2,\n\taiText = 3\n}\n\n/* __GDPR__FRAGMENT__\n\t\"IPatternInfo\" : {\n\t\t\"isRegExp\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n\t\t\"isWordMatch\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n\t\t\"wordSeparators\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n\t\t\"isMultiline\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n\t\t\"isCaseSensitive\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n\t\t\"isSmartCase\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true }\n\t}\n*/\nexport interface IPatternInfo {\n\tpattern: string;\n\tisRegExp?: boolean;\n\tisWordMatch?: boolean;\n\twordSeparators?: string;\n\tisMultiline?: boolean;\n\tisUnicode?: boolean;\n\tisCaseSensitive?: boolean;\n\tnotebookInfo?: INotebookPatternInfo;\n}\n\nexport interface INotebookPatternInfo {\n\tisInNotebookMarkdownInput?: boolean;\n\tisInNotebookMarkdownPreview?: boolean;\n\tisInNotebookCellInput?: boolean;\n\tisInNotebookCellOutput?: boolean;\n}\n\nexport interface IExtendedExtensionSearchOptions {\n\tusePCRE2?: boolean;\n}\n\nexport interface IFileMatch<U extends UriComponents = URI> {\n\tresource: U;\n\tresults?: ITextSearchResult<U>[];\n}\n\nexport type IRawFileMatch2 = IFileMatch<UriComponents>;\n\nexport interface ITextSearchPreviewOptions {\n\tmatchLines: number;\n\tcharsPerLine: number;\n}\n\nexport interface ISearchRange {\n\treadonly startLineNumber: number;\n\treadonly startColumn: number;\n\treadonly endLineNumber: number;\n\treadonly endColumn: number;\n}\n\nexport interface ITextSearchMatch<U extends UriComponents = URI> {\n\turi?: U;\n\trangeLocations: SearchRangeSetPairing[];\n\tpreviewText: string;\n\twebviewIndex?: number;\n\tcellFragment?: string;\n}\n\nexport interface ITextSearchContext<U extends UriComponents = URI> {\n\turi?: U;\n\ttext: string;\n\tlineNumber: number;\n}\n\nexport type ITextSearchResult<U extends UriComponents = URI> = ITextSearchMatch<U> | ITextSearchContext<U>;\n\nexport function resultIsMatch(result: ITextSearchResult): result is ITextSearchMatch {\n\treturn !!(<ITextSearchMatch>result).rangeLocations && !!(<ITextSearchMatch>result).previewText;\n}\n\nexport interface IProgressMessage {\n\tmessage: string;\n}\n\nexport type ISearchProgressItem = IFileMatch | IProgressMessage;\n\nexport function isFileMatch(p: ISearchProgressItem): p is IFileMatch {\n\treturn !!(<IFileMatch>p).resource;\n}\n\nexport function isProgressMessage(p: ISearchProgressItem | ISerializedSearchProgressItem): p is IProgressMessage {\n\treturn !!(p as IProgressMessage).message;\n}\n\nexport interface ITextSearchCompleteMessage {\n\ttext: string;\n\ttype: TextSearchCompleteMessageType;\n\ttrusted?: boolean;\n}\n\nexport interface ISearchCompleteStats {\n\tlimitHit?: boolean;\n\tmessages: ITextSearchCompleteMessage[];\n\tstats?: IFileSearchStats | ITextSearchStats;\n}\n\nexport interface ISearchComplete extends ISearchCompleteStats {\n\tresults: IFileMatch[];\n\texit?: SearchCompletionExitCode;\n}\n\nexport const enum SearchCompletionExitCode {\n\tNormal,\n\tNewSearchStarted\n}\n\nexport interface ITextSearchStats {\n\ttype: 'textSearchProvider' | 'searchProcess' | 'aiTextSearchProvider';\n}\n\nexport interface IFileSearchStats {\n\tfromCache: boolean;\n\tdetailStats: ISearchEngineStats | ICachedSearchStats | IFileSearchProviderStats;\n\n\tresultCount: number;\n\ttype: 'fileSearchProvider' | 'searchProcess';\n\tsortingTime?: number;\n}\n\nexport interface ICachedSearchStats {\n\tcacheWasResolved: boolean;\n\tcacheLookupTime: number;\n\tcacheFilterTime: number;\n\tcacheEntryCount: number;\n}\n\nexport interface ISearchEngineStats {\n\tfileWalkTime: number;\n\tdirectoriesWalked: number;\n\tfilesWalked: number;\n\tcmdTime: number;\n\tcmdResultCount?: number;\n}\n\nexport interface IFileSearchProviderStats {\n\tproviderTime: number;\n\tpostProcessTime: number;\n}\n\nexport class FileMatch implements IFileMatch {\n\tresults: ITextSearchResult[] = [];\n\tconstructor(public resource: URI) {\n\t\t// empty\n\t}\n}\n\nexport interface SearchRangeSetPairing {\n\tsource: ISearchRange;\n\tpreview: ISearchRange;\n}\n\nexport class TextSearchMatch implements ITextSearchMatch {\n\trangeLocations: SearchRangeSetPairing[] = [];\n\tpreviewText: string;\n\twebviewIndex?: number;\n\n\tconstructor(text: string, ranges: ISearchRange | ISearchRange[], previewOptions?: ITextSearchPreviewOptions, webviewIndex?: number) {\n\t\tthis.webviewIndex = webviewIndex;\n\n\t\t// Trim preview if this is one match and a single-line match with a preview requested.\n\t\t// Otherwise send the full text, like for replace or for showing multiple previews.\n\t\t// TODO this is fishy.\n\t\tconst rangesArr = Array.isArray(ranges) ? ranges : [ranges];\n\n\t\tif (previewOptions && previewOptions.matchLines === 1 && isSingleLineRangeList(rangesArr)) {\n\t\t\t// 1 line preview requested\n\t\t\ttext = getNLines(text, previewOptions.matchLines);\n\n\t\t\tlet result = '';\n\t\t\tlet shift = 0;\n\t\t\tlet lastEnd = 0;\n\t\t\tconst leadingChars = Math.floor(previewOptions.charsPerLine / 5);\n\t\t\tfor (const range of rangesArr) {\n\t\t\t\tconst previewStart = Math.max(range.startColumn - leadingChars, 0);\n\t\t\t\tconst previewEnd = range.startColumn + previewOptions.charsPerLine;\n\t\t\t\tif (previewStart > lastEnd + leadingChars + SEARCH_ELIDED_MIN_LEN) {\n\t\t\t\t\tconst elision = SEARCH_ELIDED_PREFIX + (previewStart - lastEnd) + SEARCH_ELIDED_SUFFIX;\n\t\t\t\t\tresult += elision + text.slice(previewStart, previewEnd);\n\t\t\t\t\tshift += previewStart - (lastEnd + elision.length);\n\t\t\t\t} else {\n\t\t\t\t\tresult += text.slice(lastEnd, previewEnd);\n\t\t\t\t}\n\n\t\t\t\tlastEnd = previewEnd;\n\t\t\t\tthis.rangeLocations.push({\n\t\t\t\t\tsource: range,\n\t\t\t\t\tpreview: new OneLineRange(0, range.startColumn - shift, range.endColumn - shift)\n\t\t\t\t});\n\n\t\t\t}\n\n\t\t\tthis.previewText = result;\n\t\t} else {\n\t\t\tconst firstMatchLine = Array.isArray(ranges) ? ranges[0].startLineNumber : ranges.startLineNumber;\n\n\t\t\tconst rangeLocs = mapArrayOrNot(ranges, r => ({\n\t\t\t\tpreview: new SearchRange(r.startLineNumber - firstMatchLine, r.startColumn, r.endLineNumber - firstMatchLine, r.endColumn),\n\t\t\t\tsource: r\n\t\t\t}));\n\n\t\t\tthis.rangeLocations = Array.isArray(rangeLocs) ? rangeLocs : [rangeLocs];\n\t\t\tthis.previewText = text;\n\t\t}\n\t}\n}\n\nfunction isSingleLineRangeList(ranges: ISearchRange[]): boolean {\n\tconst line = ranges[0].startLineNumber;\n\tfor (const r of ranges) {\n\t\tif (r.startLineNumber !== line || r.endLineNumber !== line) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nexport class SearchRange implements ISearchRange {\n\tstartLineNumber: number;\n\tstartColumn: number;\n\tendLineNumber: number;\n\tendColumn: number;\n\n\tconstructor(startLineNumber: number, startColumn: number, endLineNumber: number, endColumn: number) {\n\t\tthis.startLineNumber = startLineNumber;\n\t\tthis.startColumn = startColumn;\n\t\tthis.endLineNumber = endLineNumber;\n\t\tthis.endColumn = endColumn;\n\t}\n}\n\nexport class OneLineRange extends SearchRange {\n\tconstructor(lineNumber: number, startColumn: number, endColumn: number) {\n\t\tsuper(lineNumber, startColumn, lineNumber, endColumn);\n\t}\n}\n\nexport const enum ViewMode {\n\tList = 'list',\n\tTree = 'tree'\n}\n\nexport const enum SearchSortOrder {\n\tDefault = 'default',\n\tFileNames = 'fileNames',\n\tType = 'type',\n\tModified = 'modified',\n\tCountDescending = 'countDescending',\n\tCountAscending = 'countAscending'\n}\n\nexport interface ISearchConfigurationProperties {\n\texclude: glob.IExpression;\n\tuseRipgrep: boolean;\n\t/**\n\t * Use ignore file for file search.\n\t */\n\tuseIgnoreFiles: boolean;\n\tuseGlobalIgnoreFiles: boolean;\n\tuseParentIgnoreFiles: boolean;\n\tfollowSymlinks: boolean;\n\tsmartCase: boolean;\n\tglobalFindClipboard: boolean;\n\tlocation: 'sidebar' | 'panel';\n\tuseReplacePreview: boolean;\n\tshowLineNumbers: boolean;\n\tusePCRE2: boolean;\n\tactionsPosition: 'auto' | 'right';\n\tmaintainFileSearchCache: boolean;\n\tmaxResults: number | null;\n\tcollapseResults: 'auto' | 'alwaysCollapse' | 'alwaysExpand';\n\tsearchOnType: boolean;\n\tseedOnFocus: boolean;\n\tseedWithNearestWord: boolean;\n\tsearchOnTypeDebouncePeriod: number;\n\tmode: 'view' | 'reuseEditor' | 'newEditor';\n\tsearchEditor: {\n\t\tdoubleClickBehaviour: 'selectWord' | 'goToLocation' | 'openLocationToSide';\n\t\tsingleClickBehaviour: 'default' | 'peekDefinition';\n\t\treusePriorSearchConfiguration: boolean;\n\t\tdefaultNumberOfContextLines: number | null;\n\t\tfocusResultsOnSearch: boolean;\n\t\texperimental: {};\n\t};\n\tsortOrder: SearchSortOrder;\n\tdecorations: {\n\t\tcolors: boolean;\n\t\tbadges: boolean;\n\t};\n\tquickAccess: {\n\t\tpreserveInput: boolean;\n\t};\n\tdefaultViewMode: ViewMode;\n\texperimental: {\n\t\tclosedNotebookRichContentResults: boolean;\n\t};\n}\n\nexport interface ISearchConfiguration extends IFilesConfiguration {\n\tsearch: ISearchConfigurationProperties;\n\teditor: {\n\t\twordSeparators: string;\n\t};\n}\n\nexport function getExcludes(configuration: ISearchConfiguration, includeSearchExcludes = true): glob.IExpression | undefined {\n\tconst fileExcludes = configuration && configuration.files && configuration.files.exclude;\n\tconst searchExcludes = includeSearchExcludes && configuration && configuration.search && configuration.search.exclude;\n\n\tif (!fileExcludes && !searchExcludes) {\n\t\treturn undefined;\n\t}\n\n\tif (!fileExcludes || !searchExcludes) {\n\t\treturn fileExcludes || searchExcludes || undefined;\n\t}\n\n\tlet allExcludes: glob.IExpression = Object.create(null);\n\t// clone the config as it could be frozen\n\tallExcludes = objects.mixin(allExcludes, objects.deepClone(fileExcludes));\n\tallExcludes = objects.mixin(allExcludes, objects.deepClone(searchExcludes), true);\n\n\treturn allExcludes;\n}\n\nexport function pathIncludedInQuery(queryProps: ICommonQueryProps<URI>, fsPath: string): boolean {\n\tif (queryProps.excludePattern && glob.match(queryProps.excludePattern, fsPath)) {\n\t\treturn false;\n\t}\n\n\tif (queryProps.includePattern || queryProps.usingSearchPaths) {\n\t\tif (queryProps.includePattern && glob.match(queryProps.includePattern, fsPath)) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// If searchPaths are being used, the extra file must be in a subfolder and match the pattern, if present\n\t\tif (queryProps.usingSearchPaths) {\n\t\t\treturn !!queryProps.folderQueries && queryProps.folderQueries.some(fq => {\n\t\t\t\tconst searchPath = fq.folder.fsPath;\n\t\t\t\tif (extpath.isEqualOrParent(fsPath, searchPath)) {\n\t\t\t\t\tconst relPath = paths.relative(searchPath, fsPath);\n\t\t\t\t\treturn !fq.includePattern || !!glob.match(fq.includePattern, relPath);\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nexport enum SearchErrorCode {\n\tunknownEncoding = 1,\n\tregexParseError,\n\tglobParseError,\n\tinvalidLiteral,\n\trgProcessError,\n\tother,\n\tcanceled\n}\n\nexport class SearchError extends Error {\n\tconstructor(message: string, readonly code?: SearchErrorCode) {\n\t\tsuper(message);\n\t}\n}\n\nexport function deserializeSearchError(error: Error): SearchError {\n\tconst errorMsg = error.message;\n\n\tif (isCancellationError(error)) {\n\t\treturn new SearchError(errorMsg, SearchErrorCode.canceled);\n\t}\n\n\ttry {\n\t\tconst details = JSON.parse(errorMsg);\n\t\treturn new SearchError(details.message, details.code);\n\t} catch (e) {\n\t\treturn new SearchError(errorMsg, SearchErrorCode.other);\n\t}\n}\n\nexport function serializeSearchError(searchError: SearchError): Error {\n\tconst details = { message: searchError.message, code: searchError.code };\n\treturn new Error(JSON.stringify(details));\n}\nexport interface ITelemetryEvent {\n\teventName: string;\n\tdata: ITelemetryData;\n}\n\nexport interface IRawSearchService {\n\tfileSearch(search: IRawFileQuery): Event<ISerializedSearchProgressItem | ISerializedSearchComplete>;\n\ttextSearch(search: IRawTextQuery): Event<ISerializedSearchProgressItem | ISerializedSearchComplete>;\n\tclearCache(cacheKey: string): Promise<void>;\n}\n\nexport interface IRawFileMatch {\n\tbase?: string;\n\t/**\n\t * The path of the file relative to the containing `base` folder.\n\t * This path is exactly as it appears on the filesystem.\n\t */\n\trelativePath: string;\n\t/**\n\t * This path is transformed for search purposes. For example, this could be\n\t * the `relativePath` with the workspace folder name prepended. This way the\n\t * search algorithm would also match against the name of the containing folder.\n\t *\n\t * If not given, the search algorithm should use `relativePath`.\n\t */\n\tsearchPath: string | undefined;\n}\n\nexport interface ISearchEngine<T> {\n\tsearch: (onResult: (matches: T) => void, onProgress: (progress: IProgressMessage) => void, done: (error: Error | null, complete: ISearchEngineSuccess) => void) => void;\n\tcancel: () => void;\n}\n\nexport interface ISerializedSearchSuccess {\n\ttype: 'success';\n\tlimitHit: boolean;\n\tmessages: ITextSearchCompleteMessage[];\n\tstats?: IFileSearchStats | ITextSearchStats;\n}\n\nexport interface ISearchEngineSuccess {\n\tlimitHit: boolean;\n\tmessages: ITextSearchCompleteMessage[];\n\tstats: ISearchEngineStats;\n}\n\nexport interface ISerializedSearchError {\n\ttype: 'error';\n\terror: {\n\t\tmessage: string;\n\t\tstack: string;\n\t};\n}\n\nexport type ISerializedSearchComplete = ISerializedSearchSuccess | ISerializedSearchError;\n\nexport function isSerializedSearchComplete(arg: ISerializedSearchProgressItem | ISerializedSearchComplete): arg is ISerializedSearchComplete {\n\tif ((arg as any).type === 'error') {\n\t\treturn true;\n\t} else if ((arg as any).type === 'success') {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nexport function isSerializedSearchSuccess(arg: ISerializedSearchComplete): arg is ISerializedSearchSuccess {\n\treturn arg.type === 'success';\n}\n\nexport function isSerializedFileMatch(arg: ISerializedSearchProgressItem): arg is ISerializedFileMatch {\n\treturn !!(<ISerializedFileMatch>arg).path;\n}\n\nexport function isFilePatternMatch(candidate: IRawFileMatch, filePatternToUse: string, fuzzy = true): boolean {\n\tconst pathToMatch = candidate.searchPath ? candidate.searchPath : candidate.relativePath;\n\treturn fuzzy ?\n\t\tfuzzyContains(pathToMatch, filePatternToUse) :\n\t\tglob.match(filePatternToUse, pathToMatch);\n}\n\nexport interface ISerializedFileMatch {\n\tpath: string;\n\tresults?: ITextSearchResult[];\n\tnumMatches?: number;\n}\n\n// Type of the possible values for progress calls from the engine\nexport type ISerializedSearchProgressItem = ISerializedFileMatch | ISerializedFileMatch[] | IProgressMessage;\nexport type IFileSearchProgressItem = IRawFileMatch | IRawFileMatch[] | IProgressMessage;\n\n\nexport class SerializableFileMatch implements ISerializedFileMatch {\n\tpath: string;\n\tresults: ITextSearchMatch[];\n\n\tconstructor(path: string) {\n\t\tthis.path = path;\n\t\tthis.results = [];\n\t}\n\n\taddMatch(match: ITextSearchMatch): void {\n\t\tthis.results.push(match);\n\t}\n\n\tserialize(): ISerializedFileMatch {\n\t\treturn {\n\t\t\tpath: this.path,\n\t\t\tresults: this.results,\n\t\t\tnumMatches: this.results.length\n\t\t};\n\t}\n}\n\n/**\n *  Computes the patterns that the provider handles. Discards sibling clauses and 'false' patterns\n */\nexport function resolvePatternsForProvider(globalPattern: glob.IExpression | undefined, folderPattern: glob.IExpression | undefined): string[] {\n\tconst merged = {\n\t\t...(globalPattern || {}),\n\t\t...(folderPattern || {})\n\t};\n\n\treturn Object.keys(merged)\n\t\t.filter(key => {\n\t\t\tconst value = merged[key];\n\t\t\treturn typeof value === 'boolean' && value;\n\t\t});\n}\n\nexport class QueryGlobTester {\n\n\tprivate _excludeExpression: glob.IExpression[]; // TODO: evaluate globs based on baseURI of pattern\n\tprivate _parsedExcludeExpression: glob.ParsedExpression[];\n\n\tprivate _parsedIncludeExpression: glob.ParsedExpression | null = null;\n\n\tconstructor(config: ISearchQuery, folderQuery: IFolderQuery) {\n\t\t// todo: try to incorporate folderQuery.excludePattern.folder if available\n\t\tthis._excludeExpression = folderQuery.excludePattern?.map(excludePattern => {\n\t\t\treturn {\n\t\t\t\t...(config.excludePattern || {}),\n\t\t\t\t...(excludePattern.pattern || {})\n\t\t\t} satisfies glob.IExpression;\n\t\t}) ?? [];\n\n\t\tif (this._excludeExpression.length === 0) {\n\t\t\t// even if there are no folderQueries, we want to observe  the global excludes\n\t\t\tthis._excludeExpression = [config.excludePattern || {}];\n\t\t}\n\n\t\tthis._parsedExcludeExpression = this._excludeExpression.map(e => glob.parse(e));\n\n\t\t// Empty includeExpression means include nothing, so no {} shortcuts\n\t\tlet includeExpression: glob.IExpression | undefined = config.includePattern;\n\t\tif (folderQuery.includePattern) {\n\t\t\tif (includeExpression) {\n\t\t\t\tincludeExpression = {\n\t\t\t\t\t...includeExpression,\n\t\t\t\t\t...folderQuery.includePattern\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tincludeExpression = folderQuery.includePattern;\n\t\t\t}\n\t\t}\n\n\t\tif (includeExpression) {\n\t\t\tthis._parsedIncludeExpression = glob.parse(includeExpression);\n\t\t}\n\t}\n\n\tprivate _evalParsedExcludeExpression(testPath: string, basename: string | undefined, hasSibling?: (name: string) => boolean): string | null {\n\t\t// todo: less hacky way of evaluating sync vs async sibling clauses\n\t\tlet result: string | null = null;\n\n\t\tfor (const folderExclude of this._parsedExcludeExpression) {\n\n\t\t\t// find first non-null result\n\t\t\tconst evaluation = folderExclude(testPath, basename, hasSibling);\n\n\t\t\tif (typeof evaluation === 'string') {\n\t\t\t\tresult = evaluation;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\n\tmatchesExcludesSync(testPath: string, basename?: string, hasSibling?: (name: string) => boolean): boolean {\n\t\tif (this._parsedExcludeExpression && this._evalParsedExcludeExpression(testPath, basename, hasSibling)) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Guaranteed sync - siblingsFn should not return a promise.\n\t */\n\tincludedInQuerySync(testPath: string, basename?: string, hasSibling?: (name: string) => boolean): boolean {\n\t\tif (this._parsedExcludeExpression && this._evalParsedExcludeExpression(testPath, basename, hasSibling)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this._parsedIncludeExpression && !this._parsedIncludeExpression(testPath, basename, hasSibling)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Evaluating the exclude expression is only async if it includes sibling clauses. As an optimization, avoid doing anything with Promises\n\t * unless the expression is async.\n\t */\n\tincludedInQuery(testPath: string, basename?: string, hasSibling?: (name: string) => boolean | Promise<boolean>): Promise<boolean> | boolean {\n\n\t\tconst isIncluded = () => {\n\t\t\treturn this._parsedIncludeExpression ?\n\t\t\t\t!!(this._parsedIncludeExpression(testPath, basename, hasSibling)) :\n\t\t\t\ttrue;\n\t\t};\n\n\t\treturn Promise.all(this._parsedExcludeExpression.map(e => {\n\t\t\tconst excluded = e(testPath, basename, hasSibling);\n\t\t\tif (isThenable(excluded)) {\n\t\t\t\treturn excluded.then(excluded => {\n\t\t\t\t\tif (excluded) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn isIncluded();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn isIncluded();\n\n\t\t})).then(e => e.some(e => !!e));\n\n\n\t}\n\n\thasSiblingExcludeClauses(): boolean {\n\t\treturn this._excludeExpression.reduce((prev, curr) => hasSiblingClauses(curr) || prev, false);\n\t}\n}\n\nfunction hasSiblingClauses(pattern: glob.IExpression): boolean {\n\tfor (const key in pattern) {\n\t\tif (typeof pattern[key] !== 'boolean') {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport function hasSiblingPromiseFn(siblingsFn?: () => Promise<string[]>) {\n\tif (!siblingsFn) {\n\t\treturn undefined;\n\t}\n\n\tlet siblings: Promise<Record<string, true>>;\n\treturn (name: string) => {\n\t\tif (!siblings) {\n\t\t\tsiblings = (siblingsFn() || Promise.resolve([]))\n\t\t\t\t.then(list => list ? listToMap(list) : {});\n\t\t}\n\t\treturn siblings.then(map => !!map[name]);\n\t};\n}\n\nexport function hasSiblingFn(siblingsFn?: () => string[]) {\n\tif (!siblingsFn) {\n\t\treturn undefined;\n\t}\n\n\tlet siblings: Record<string, true>;\n\treturn (name: string) => {\n\t\tif (!siblings) {\n\t\t\tconst list = siblingsFn();\n\t\t\tsiblings = list ? listToMap(list) : {};\n\t\t}\n\t\treturn !!siblings[name];\n\t};\n}\n\nfunction listToMap(list: string[]) {\n\tconst map: Record<string, true> = {};\n\tfor (const key of list) {\n\t\tmap[key] = true;\n\t}\n\treturn map;\n}\n\nexport function excludeToGlobPattern(excludesForFolder: { baseUri?: URI | undefined; patterns: string[] }[]): GlobPattern[] {\n\treturn excludesForFolder.flatMap(exclude => exclude.patterns.map(pattern => {\n\t\treturn exclude.baseUri ?\n\t\t\t{\n\t\t\t\tbaseUri: exclude.baseUri,\n\t\t\t\tpattern: pattern\n\t\t\t} : pattern;\n\t}));\n}\n\nexport const DEFAULT_TEXT_SEARCH_PREVIEW_OPTIONS = {\n\tmatchLines: 100,\n\tcharsPerLine: 10000\n};\n"],
  "mappings": "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",
  "names": ["SearchProviderType", "QueryType", "SearchCompletionExitCode", "ViewMode", "SearchSortOrder", "SearchErrorCode", "excluded", "e"]
}
