{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/search/common/searchHelpers.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Range } from '../../../../editor/common/core/range.js';\nimport { FindMatch, ITextModel } from '../../../../editor/common/model.js';\nimport { ITextSearchPreviewOptions, TextSearchMatch, ITextSearchResult, ITextSearchMatch, ITextQuery } from './search.js';\n\nfunction editorMatchToTextSearchResult(matches: FindMatch[], model: ITextModel, previewOptions?: ITextSearchPreviewOptions): TextSearchMatch {\n\tconst firstLine = matches[0].range.startLineNumber;\n\tconst lastLine = matches[matches.length - 1].range.endLineNumber;\n\n\tconst lineTexts: string[] = [];\n\tfor (let i = firstLine; i <= lastLine; i++) {\n\t\tlineTexts.push(model.getLineContent(i));\n\t}\n\n\treturn new TextSearchMatch(\n\t\tlineTexts.join('\\n') + '\\n',\n\t\tmatches.map(m => new Range(m.range.startLineNumber - 1, m.range.startColumn - 1, m.range.endLineNumber - 1, m.range.endColumn - 1)),\n\t\tpreviewOptions);\n}\n\n/**\n * Combine a set of FindMatches into a set of TextSearchResults. They should be grouped by matches that start on the same line that the previous match ends on.\n */\nexport function editorMatchesToTextSearchResults(matches: FindMatch[], model: ITextModel, previewOptions?: ITextSearchPreviewOptions): TextSearchMatch[] {\n\tlet previousEndLine = -1;\n\tconst groupedMatches: FindMatch[][] = [];\n\tlet currentMatches: FindMatch[] = [];\n\tmatches.forEach((match) => {\n\t\tif (match.range.startLineNumber !== previousEndLine) {\n\t\t\tcurrentMatches = [];\n\t\t\tgroupedMatches.push(currentMatches);\n\t\t}\n\n\t\tcurrentMatches.push(match);\n\t\tpreviousEndLine = match.range.endLineNumber;\n\t});\n\n\treturn groupedMatches.map(sameLineMatches => {\n\t\treturn editorMatchToTextSearchResult(sameLineMatches, model, previewOptions);\n\t});\n}\n\nexport function getTextSearchMatchWithModelContext(matches: ITextSearchMatch[], model: ITextModel, query: ITextQuery): ITextSearchResult[] {\n\tconst results: ITextSearchResult[] = [];\n\n\tlet prevLine = -1;\n\tfor (let i = 0; i < matches.length; i++) {\n\t\tconst { start: matchStartLine, end: matchEndLine } = getMatchStartEnd(matches[i]);\n\t\tif (typeof query.surroundingContext === 'number' && query.surroundingContext > 0) {\n\t\t\tconst beforeContextStartLine = Math.max(prevLine + 1, matchStartLine - query.surroundingContext);\n\t\t\tfor (let b = beforeContextStartLine; b < matchStartLine; b++) {\n\t\t\t\tresults.push({\n\t\t\t\t\ttext: model.getLineContent(b + 1),\n\t\t\t\t\tlineNumber: b + 1\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tresults.push(matches[i]);\n\n\t\tconst nextMatch = matches[i + 1];\n\t\tconst nextMatchStartLine = nextMatch ? getMatchStartEnd(nextMatch).start : Number.MAX_VALUE;\n\t\tif (typeof query.surroundingContext === 'number' && query.surroundingContext > 0) {\n\t\t\tconst afterContextToLine = Math.min(nextMatchStartLine - 1, matchEndLine + query.surroundingContext, model.getLineCount() - 1);\n\t\t\tfor (let a = matchEndLine + 1; a <= afterContextToLine; a++) {\n\t\t\t\tresults.push({\n\t\t\t\t\ttext: model.getLineContent(a + 1),\n\t\t\t\t\tlineNumber: a + 1\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tprevLine = matchEndLine;\n\t}\n\n\treturn results;\n}\n\nfunction getMatchStartEnd(match: ITextSearchMatch): { start: number; end: number } {\n\tconst matchRanges = match.rangeLocations.map(e => e.source);\n\tconst matchStartLine = matchRanges[0].startLineNumber;\n\tconst matchEndLine = matchRanges[matchRanges.length - 1].endLineNumber;\n\n\treturn {\n\t\tstart: matchStartLine,\n\t\tend: matchEndLine\n\t};\n}\n"],
  "mappings": ";;AAKA,SAAS,aAAa;AACtB,SAAS,WAAW,kBAAkB;AACtC,SAAS,2BAA2B,iBAAiB,mBAAmB,kBAAkB,kBAAkB;AAE5G,SAAS,8BAA8B,SAAsB,OAAmB,gBAA6D;AAC5I,QAAM,YAAY,QAAQ,CAAC,EAAE,MAAM;AACnC,QAAM,WAAW,QAAQ,QAAQ,SAAS,CAAC,EAAE,MAAM;AAEnD,QAAM,YAAsB,CAAC;AAC7B,WAAS,IAAI,WAAW,KAAK,UAAU,KAAK;AAC3C,cAAU,KAAK,MAAM,eAAe,CAAC,CAAC;AAAA,EACvC;AAEA,SAAO,IAAI;AAAA,IACV,UAAU,KAAK,IAAI,IAAI;AAAA,IACvB,QAAQ,IAAI,OAAK,IAAI,MAAM,EAAE,MAAM,kBAAkB,GAAG,EAAE,MAAM,cAAc,GAAG,EAAE,MAAM,gBAAgB,GAAG,EAAE,MAAM,YAAY,CAAC,CAAC;AAAA,IAClI;AAAA,EAAc;AAChB;AAbS;AAkBF,SAAS,iCAAiC,SAAsB,OAAmB,gBAA+D;AACxJ,MAAI,kBAAkB;AACtB,QAAM,iBAAgC,CAAC;AACvC,MAAI,iBAA8B,CAAC;AACnC,UAAQ,QAAQ,CAAC,UAAU;AAC1B,QAAI,MAAM,MAAM,oBAAoB,iBAAiB;AACpD,uBAAiB,CAAC;AAClB,qBAAe,KAAK,cAAc;AAAA,IACnC;AAEA,mBAAe,KAAK,KAAK;AACzB,sBAAkB,MAAM,MAAM;AAAA,EAC/B,CAAC;AAED,SAAO,eAAe,IAAI,qBAAmB;AAC5C,WAAO,8BAA8B,iBAAiB,OAAO,cAAc;AAAA,EAC5E,CAAC;AACF;AAjBgB;AAmBT,SAAS,mCAAmC,SAA6B,OAAmB,OAAwC;AAC1I,QAAM,UAA+B,CAAC;AAEtC,MAAI,WAAW;AACf,WAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACxC,UAAM,EAAE,OAAO,gBAAgB,KAAK,aAAa,IAAI,iBAAiB,QAAQ,CAAC,CAAC;AAChF,QAAI,OAAO,MAAM,uBAAuB,YAAY,MAAM,qBAAqB,GAAG;AACjF,YAAM,yBAAyB,KAAK,IAAI,WAAW,GAAG,iBAAiB,MAAM,kBAAkB;AAC/F,eAAS,IAAI,wBAAwB,IAAI,gBAAgB,KAAK;AAC7D,gBAAQ,KAAK;AAAA,UACZ,MAAM,MAAM,eAAe,IAAI,CAAC;AAAA,UAChC,YAAY,IAAI;AAAA,QACjB,CAAC;AAAA,MACF;AAAA,IACD;AAEA,YAAQ,KAAK,QAAQ,CAAC,CAAC;AAEvB,UAAM,YAAY,QAAQ,IAAI,CAAC;AAC/B,UAAM,qBAAqB,YAAY,iBAAiB,SAAS,EAAE,QAAQ,OAAO;AAClF,QAAI,OAAO,MAAM,uBAAuB,YAAY,MAAM,qBAAqB,GAAG;AACjF,YAAM,qBAAqB,KAAK,IAAI,qBAAqB,GAAG,eAAe,MAAM,oBAAoB,MAAM,aAAa,IAAI,CAAC;AAC7H,eAAS,IAAI,eAAe,GAAG,KAAK,oBAAoB,KAAK;AAC5D,gBAAQ,KAAK;AAAA,UACZ,MAAM,MAAM,eAAe,IAAI,CAAC;AAAA,UAChC,YAAY,IAAI;AAAA,QACjB,CAAC;AAAA,MACF;AAAA,IACD;AAEA,eAAW;AAAA,EACZ;AAEA,SAAO;AACR;AAlCgB;AAoChB,SAAS,iBAAiB,OAAyD;AAClF,QAAM,cAAc,MAAM,eAAe,IAAI,OAAK,EAAE,MAAM;AAC1D,QAAM,iBAAiB,YAAY,CAAC,EAAE;AACtC,QAAM,eAAe,YAAY,YAAY,SAAS,CAAC,EAAE;AAEzD,SAAO;AAAA,IACN,OAAO;AAAA,IACP,KAAK;AAAA,EACN;AACD;AATS;",
  "names": []
}
