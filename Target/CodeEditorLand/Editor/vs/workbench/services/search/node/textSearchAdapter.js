import"../../../../../vs/base/common/cancellation.js";import*as l from"../../../../../vs/base/node/pfs.js";import{resultIsMatch as u}from"../../../../../vs/workbench/services/search/common/search.js";import{RipgrepTextSearchEngine as h}from"../../../../../vs/workbench/services/search/node/ripgrepTextSearchEngine.js";import{NativeTextSearchManager as m}from"../../../../../vs/workbench/services/search/node/textSearchManager.js";class q{constructor(r,s){this.query=r;this.numThreads=s}search(r,s,i){if((!this.query.folderQueries||!this.query.folderQueries.length)&&(!this.query.extraFileResources||!this.query.extraFileResources.length))return Promise.resolve({type:"success",limitHit:!1,stats:{type:"searchProcess"},messages:[]});const n={appendLine(a){i({message:a})}},c=new m(this.query,new h(n,this.numThreads),l);return new Promise((a,o)=>c.search(t=>{s(t.map(p))},r).then(t=>a({limitHit:t.limitHit??!1,type:"success",stats:t.stats,messages:[]}),o))}}function p(e){return{path:e.resource&&e.resource.fsPath,results:e.results,numMatches:(e.results||[]).reduce((r,s)=>u(s)?r+s.rangeLocations.length:r+1,0)}}export{q as TextSearchEngineAdapter};
