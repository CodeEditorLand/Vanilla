{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/search/node/fileSearch.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as childProcess from \"child_process\";\nimport * as fs from \"fs\";\nimport type { Readable } from \"stream\";\nimport { StringDecoder } from \"string_decoder\";\nimport * as arrays from \"../../../../base/common/arrays.js\";\nimport { toErrorMessage } from \"../../../../base/common/errorMessage.js\";\nimport { isEqualOrParent } from \"../../../../base/common/extpath.js\";\nimport { prepareQuery } from \"../../../../base/common/fuzzyScorer.js\";\nimport * as glob from \"../../../../base/common/glob.js\";\nimport * as normalization from \"../../../../base/common/normalization.js\";\nimport * as path from \"../../../../base/common/path.js\";\nimport * as platform from \"../../../../base/common/platform.js\";\nimport { StopWatch } from \"../../../../base/common/stopwatch.js\";\nimport * as strings from \"../../../../base/common/strings.js\";\nimport * as types from \"../../../../base/common/types.js\";\nimport type { URI } from \"../../../../base/common/uri.js\";\nimport { Promises } from \"../../../../base/node/pfs.js\";\nimport {\n\ttype IFileQuery,\n\ttype IFolderQuery,\n\ttype IProgressMessage,\n\ttype IRawFileMatch,\n\ttype ISearchEngine,\n\ttype ISearchEngineStats,\n\ttype ISearchEngineSuccess,\n\thasSiblingFn,\n\tisFilePatternMatch,\n} from \"../common/search.js\";\nimport { spawnRipgrepCmd } from \"./ripgrepFileSearch.js\";\n\ninterface IDirectoryEntry extends IRawFileMatch {\n\tbase: string;\n\tbasename: string;\n}\n\ninterface IDirectoryTree {\n\trootEntries: IDirectoryEntry[];\n\tpathToEntries: { [relativePath: string]: IDirectoryEntry[] };\n}\n\nconst killCmds = new Set<() => void>();\nprocess.on(\"exit\", () => {\n\tkillCmds.forEach((cmd) => cmd());\n});\n\nexport class FileWalker {\n\tprivate config: IFileQuery;\n\tprivate filePattern: string;\n\tprivate normalizedFilePatternLowercase: string | null = null;\n\tprivate includePattern: glob.ParsedExpression | undefined;\n\tprivate maxResults: number | null;\n\tprivate exists: boolean;\n\tprivate maxFilesize: number | null = null;\n\tprivate isLimitHit: boolean;\n\tprivate resultCount: number;\n\tprivate isCanceled = false;\n\tprivate fileWalkSW: StopWatch | null = null;\n\tprivate directoriesWalked: number;\n\tprivate filesWalked: number;\n\tprivate errors: string[];\n\tprivate cmdSW: StopWatch | null = null;\n\tprivate cmdResultCount = 0;\n\n\tprivate folderExcludePatterns: Map<\n\t\tstring,\n\t\tAbsoluteAndRelativeParsedExpression\n\t>;\n\tprivate globalExcludePattern: glob.ParsedExpression | undefined;\n\n\tprivate walkedPaths: { [path: string]: boolean };\n\n\tconstructor(config: IFileQuery) {\n\t\tthis.config = config;\n\t\tthis.filePattern = config.filePattern || \"\";\n\t\tthis.includePattern =\n\t\t\tconfig.includePattern && glob.parse(config.includePattern);\n\t\tthis.maxResults = config.maxResults || null;\n\t\tthis.exists = !!config.exists;\n\t\tthis.walkedPaths = Object.create(null);\n\t\tthis.resultCount = 0;\n\t\tthis.isLimitHit = false;\n\t\tthis.directoriesWalked = 0;\n\t\tthis.filesWalked = 0;\n\t\tthis.errors = [];\n\n\t\tif (this.filePattern) {\n\t\t\tthis.normalizedFilePatternLowercase =\n\t\t\t\tconfig.shouldGlobMatchFilePattern\n\t\t\t\t\t? null\n\t\t\t\t\t: prepareQuery(this.filePattern).normalizedLowercase;\n\t\t}\n\n\t\tthis.globalExcludePattern =\n\t\t\tconfig.excludePattern && glob.parse(config.excludePattern);\n\t\tthis.folderExcludePatterns = new Map<\n\t\t\tstring,\n\t\t\tAbsoluteAndRelativeParsedExpression\n\t\t>();\n\n\t\tconfig.folderQueries.forEach((folderQuery) => {\n\t\t\tconst folderExcludeExpression: glob.IExpression = {}; // todo: consider exclude baseURI\n\n\t\t\tfolderQuery.excludePattern?.forEach((excludePattern) => {\n\t\t\t\tObject.assign(\n\t\t\t\t\tfolderExcludeExpression,\n\t\t\t\t\texcludePattern.pattern || {},\n\t\t\t\t\tthis.config.excludePattern || {},\n\t\t\t\t);\n\t\t\t});\n\n\t\t\tif (!folderQuery.excludePattern?.length) {\n\t\t\t\tObject.assign(\n\t\t\t\t\tfolderExcludeExpression,\n\t\t\t\t\tthis.config.excludePattern || {},\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Add excludes for other root folders\n\t\t\tconst fqPath = folderQuery.folder.fsPath;\n\t\t\tconfig.folderQueries\n\t\t\t\t.map((rootFolderQuery) => rootFolderQuery.folder.fsPath)\n\t\t\t\t.filter((rootFolder) => rootFolder !== fqPath)\n\t\t\t\t.forEach((otherRootFolder) => {\n\t\t\t\t\t// Exclude nested root folders\n\t\t\t\t\tif (isEqualOrParent(otherRootFolder, fqPath)) {\n\t\t\t\t\t\tfolderExcludeExpression[\n\t\t\t\t\t\t\tpath.relative(fqPath, otherRootFolder)\n\t\t\t\t\t\t] = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\tthis.folderExcludePatterns.set(\n\t\t\t\tfqPath,\n\t\t\t\tnew AbsoluteAndRelativeParsedExpression(\n\t\t\t\t\tfolderExcludeExpression,\n\t\t\t\t\tfqPath,\n\t\t\t\t),\n\t\t\t);\n\t\t});\n\t}\n\n\tcancel(): void {\n\t\tthis.isCanceled = true;\n\t\tkillCmds.forEach((cmd) => cmd());\n\t}\n\n\twalk(\n\t\tfolderQueries: IFolderQuery[],\n\t\textraFiles: URI[],\n\t\tnumThreads: number | undefined,\n\t\tonResult: (result: IRawFileMatch) => void,\n\t\tonMessage: (message: IProgressMessage) => void,\n\t\tdone: (error: Error | null, isLimitHit: boolean) => void,\n\t): void {\n\t\tthis.fileWalkSW = StopWatch.create(false);\n\n\t\t// Support that the file pattern is a full path to a file that exists\n\t\tif (this.isCanceled) {\n\t\t\treturn done(null, this.isLimitHit);\n\t\t}\n\n\t\t// For each extra file\n\t\textraFiles.forEach((extraFilePath) => {\n\t\t\tconst basename = path.basename(extraFilePath.fsPath);\n\t\t\tif (\n\t\t\t\tthis.globalExcludePattern &&\n\t\t\t\tthis.globalExcludePattern(extraFilePath.fsPath, basename)\n\t\t\t) {\n\t\t\t\treturn; // excluded\n\t\t\t}\n\n\t\t\t// File: Check for match on file pattern and include pattern\n\t\t\tthis.matchFile(onResult, {\n\t\t\t\trelativePath:\n\t\t\t\t\textraFilePath.fsPath /* no workspace relative path */,\n\t\t\t\tsearchPath: undefined,\n\t\t\t});\n\t\t});\n\n\t\tthis.cmdSW = StopWatch.create(false);\n\n\t\t// For each root folder\n\t\tthis.parallel<IFolderQuery, void>(\n\t\t\tfolderQueries,\n\t\t\t(\n\t\t\t\tfolderQuery: IFolderQuery,\n\t\t\t\trootFolderDone: (err: Error | null, result: void) => void,\n\t\t\t) => {\n\t\t\t\tthis.call(\n\t\t\t\t\tthis.cmdTraversal,\n\t\t\t\t\tthis,\n\t\t\t\t\tfolderQuery,\n\t\t\t\t\tnumThreads,\n\t\t\t\t\tonResult,\n\t\t\t\t\tonMessage,\n\t\t\t\t\t(err?: Error) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\tconst errorMessage = toErrorMessage(err);\n\t\t\t\t\t\t\tconsole.error(errorMessage);\n\t\t\t\t\t\t\tthis.errors.push(errorMessage);\n\t\t\t\t\t\t\trootFolderDone(err, undefined);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trootFolderDone(null, undefined);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t},\n\t\t\t(errors, _result) => {\n\t\t\t\tthis.fileWalkSW!.stop();\n\t\t\t\tconst err = errors ? arrays.coalesce(errors)[0] : null;\n\t\t\t\tdone(err, this.isLimitHit);\n\t\t\t},\n\t\t);\n\t}\n\n\tprivate parallel<T, E>(\n\t\tlist: T[],\n\t\tfn: (\n\t\t\titem: T,\n\t\t\tcallback: (err: Error | null, result: E | null) => void,\n\t\t) => void,\n\t\tcallback: (err: Array<Error | null> | null, result: E[]) => void,\n\t): void {\n\t\tconst results = new Array(list.length);\n\t\tconst errors = new Array<Error | null>(list.length);\n\t\tlet didErrorOccur = false;\n\t\tlet doneCount = 0;\n\n\t\tif (list.length === 0) {\n\t\t\treturn callback(null, []);\n\t\t}\n\n\t\tlist.forEach((item, index) => {\n\t\t\tfn(item, (error, result) => {\n\t\t\t\tif (error) {\n\t\t\t\t\tdidErrorOccur = true;\n\t\t\t\t\tresults[index] = null;\n\t\t\t\t\terrors[index] = error;\n\t\t\t\t} else {\n\t\t\t\t\tresults[index] = result;\n\t\t\t\t\terrors[index] = null;\n\t\t\t\t}\n\n\t\t\t\tif (++doneCount === list.length) {\n\t\t\t\t\treturn callback(didErrorOccur ? errors : null, results);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate call<F extends Function>(fun: F, that: any, ...args: any[]): void {\n\t\ttry {\n\t\t\tfun.apply(that, args);\n\t\t} catch (e) {\n\t\t\targs[args.length - 1](e);\n\t\t}\n\t}\n\n\tprivate cmdTraversal(\n\t\tfolderQuery: IFolderQuery,\n\t\tnumThreads: number | undefined,\n\t\tonResult: (result: IRawFileMatch) => void,\n\t\tonMessage: (message: IProgressMessage) => void,\n\t\tcb: (err?: Error) => void,\n\t): void {\n\t\tconst rootFolder = folderQuery.folder.fsPath;\n\t\tconst isMac = platform.isMacintosh;\n\n\t\tconst killCmd = () => cmd && cmd.kill();\n\t\tkillCmds.add(killCmd);\n\n\t\tlet done = (err?: Error) => {\n\t\t\tkillCmds.delete(killCmd);\n\t\t\tdone = () => {};\n\t\t\tcb(err);\n\t\t};\n\t\tlet leftover = \"\";\n\t\tconst tree = this.initDirectoryTree();\n\n\t\tconst ripgrep = spawnRipgrepCmd(\n\t\t\tthis.config,\n\t\t\tfolderQuery,\n\t\t\tthis.config.includePattern,\n\t\t\tthis.folderExcludePatterns.get(folderQuery.folder.fsPath)!\n\t\t\t\t.expression,\n\t\t\tnumThreads,\n\t\t);\n\t\tconst cmd = ripgrep.cmd;\n\t\tconst noSiblingsClauses = !Object.keys(ripgrep.siblingClauses).length;\n\n\t\tconst escapedArgs = ripgrep.rgArgs.args\n\t\t\t.map((arg) => (arg.match(/^-/) ? arg : `'${arg}'`))\n\t\t\t.join(\" \");\n\n\t\tlet rgCmd = `${ripgrep.rgDiskPath} ${escapedArgs}\\n - cwd: ${ripgrep.cwd}`;\n\t\tif (ripgrep.rgArgs.siblingClauses) {\n\t\t\trgCmd += `\\n - Sibling clauses: ${JSON.stringify(ripgrep.rgArgs.siblingClauses)}`;\n\t\t}\n\t\tonMessage({ message: rgCmd });\n\n\t\tthis.cmdResultCount = 0;\n\t\tthis.collectStdout(\n\t\t\tcmd,\n\t\t\t\"utf8\",\n\t\t\tonMessage,\n\t\t\t(err: Error | null, stdout?: string, last?: boolean) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tdone(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (this.isLimitHit) {\n\t\t\t\t\tdone();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Mac: uses NFD unicode form on disk, but we want NFC\n\t\t\t\tconst normalized =\n\t\t\t\t\tleftover +\n\t\t\t\t\t(isMac ? normalization.normalizeNFC(stdout || \"\") : stdout);\n\t\t\t\tconst relativeFiles = normalized.split(\"\\n\");\n\n\t\t\t\tif (last) {\n\t\t\t\t\tconst n = relativeFiles.length;\n\t\t\t\t\trelativeFiles[n - 1] = relativeFiles[n - 1].trim();\n\t\t\t\t\tif (!relativeFiles[n - 1]) {\n\t\t\t\t\t\trelativeFiles.pop();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tleftover = relativeFiles.pop() || \"\";\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\trelativeFiles.length &&\n\t\t\t\t\trelativeFiles[0].indexOf(\"\\n\") !== -1\n\t\t\t\t) {\n\t\t\t\t\tdone(new Error(\"Splitting up files failed\"));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.cmdResultCount += relativeFiles.length;\n\n\t\t\t\tif (noSiblingsClauses) {\n\t\t\t\t\tfor (const relativePath of relativeFiles) {\n\t\t\t\t\t\tthis.matchFile(onResult, {\n\t\t\t\t\t\t\tbase: rootFolder,\n\t\t\t\t\t\t\trelativePath,\n\t\t\t\t\t\t\tsearchPath: this.getSearchPath(\n\t\t\t\t\t\t\t\tfolderQuery,\n\t\t\t\t\t\t\t\trelativePath,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (this.isLimitHit) {\n\t\t\t\t\t\t\tkillCmd();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (last || this.isLimitHit) {\n\t\t\t\t\t\tdone();\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// TODO: Optimize siblings clauses with ripgrep here.\n\t\t\t\tthis.addDirectoryEntries(\n\t\t\t\t\tfolderQuery,\n\t\t\t\t\ttree,\n\t\t\t\t\trootFolder,\n\t\t\t\t\trelativeFiles,\n\t\t\t\t\tonResult,\n\t\t\t\t);\n\n\t\t\t\tif (last) {\n\t\t\t\t\tthis.matchDirectoryTree(tree, rootFolder, onResult);\n\t\t\t\t\tdone();\n\t\t\t\t}\n\t\t\t},\n\t\t);\n\t}\n\n\t/**\n\t * Public for testing.\n\t */\n\tspawnFindCmd(folderQuery: IFolderQuery) {\n\t\tconst excludePattern = this.folderExcludePatterns.get(\n\t\t\tfolderQuery.folder.fsPath,\n\t\t)!;\n\t\tconst basenames = excludePattern.getBasenameTerms();\n\t\tconst pathTerms = excludePattern.getPathTerms();\n\t\tconst args = [\"-L\", \".\"];\n\t\tif (basenames.length || pathTerms.length) {\n\t\t\targs.push(\"-not\", \"(\", \"(\");\n\t\t\tfor (const basename of basenames) {\n\t\t\t\targs.push(\"-name\", basename);\n\t\t\t\targs.push(\"-o\");\n\t\t\t}\n\t\t\tfor (const path of pathTerms) {\n\t\t\t\targs.push(\"-path\", path);\n\t\t\t\targs.push(\"-o\");\n\t\t\t}\n\t\t\targs.pop();\n\t\t\targs.push(\")\", \"-prune\", \")\");\n\t\t}\n\t\targs.push(\"-type\", \"f\");\n\t\treturn childProcess.spawn(\"find\", args, {\n\t\t\tcwd: folderQuery.folder.fsPath,\n\t\t});\n\t}\n\n\t/**\n\t * Public for testing.\n\t */\n\treadStdout(\n\t\tcmd: childProcess.ChildProcess,\n\t\tencoding: BufferEncoding,\n\t\tcb: (err: Error | null, stdout?: string) => void,\n\t): void {\n\t\tlet all = \"\";\n\t\tthis.collectStdout(\n\t\t\tcmd,\n\t\t\tencoding,\n\t\t\t() => {},\n\t\t\t(err: Error | null, stdout?: string, last?: boolean) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tcb(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tall += stdout;\n\t\t\t\tif (last) {\n\t\t\t\t\tcb(null, all);\n\t\t\t\t}\n\t\t\t},\n\t\t);\n\t}\n\n\tprivate collectStdout(\n\t\tcmd: childProcess.ChildProcess,\n\t\tencoding: BufferEncoding,\n\t\tonMessage: (message: IProgressMessage) => void,\n\t\tcb: (err: Error | null, stdout?: string, last?: boolean) => void,\n\t): void {\n\t\tlet onData = (err: Error | null, stdout?: string, last?: boolean) => {\n\t\t\tif (err || last) {\n\t\t\t\tonData = () => {};\n\n\t\t\t\tthis.cmdSW?.stop();\n\t\t\t}\n\t\t\tcb(err, stdout, last);\n\t\t};\n\n\t\tlet gotData = false;\n\t\tif (cmd.stdout) {\n\t\t\t// Should be non-null, but #38195\n\t\t\tthis.forwardData(cmd.stdout, encoding, onData);\n\t\t\tcmd.stdout.once(\"data\", () => (gotData = true));\n\t\t} else {\n\t\t\tonMessage({ message: \"stdout is null\" });\n\t\t}\n\n\t\tlet stderr: Buffer[];\n\t\tif (cmd.stderr) {\n\t\t\t// Should be non-null, but #38195\n\t\t\tstderr = this.collectData(cmd.stderr);\n\t\t} else {\n\t\t\tonMessage({ message: \"stderr is null\" });\n\t\t}\n\n\t\tcmd.on(\"error\", (err: Error) => {\n\t\t\tonData(err);\n\t\t});\n\n\t\tcmd.on(\"close\", (code: number) => {\n\t\t\t// ripgrep returns code=1 when no results are found\n\t\t\tlet stderrText: string;\n\t\t\tif (\n\t\t\t\t!gotData &&\n\t\t\t\t(stderrText = this.decodeData(stderr, encoding)) &&\n\t\t\t\trgErrorMsgForDisplay(stderrText)\n\t\t\t) {\n\t\t\t\tonData(\n\t\t\t\t\tnew Error(\n\t\t\t\t\t\t`command failed with error code ${code}: ${this.decodeData(stderr, encoding)}`,\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tif (this.exists && code === 0) {\n\t\t\t\t\tthis.isLimitHit = true;\n\t\t\t\t}\n\t\t\t\tonData(null, \"\", true);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate forwardData(\n\t\tstream: Readable,\n\t\tencoding: BufferEncoding,\n\t\tcb: (err: Error | null, stdout?: string) => void,\n\t): StringDecoder {\n\t\tconst decoder = new StringDecoder(encoding);\n\t\tstream.on(\"data\", (data: Buffer) => {\n\t\t\tcb(null, decoder.write(data));\n\t\t});\n\t\treturn decoder;\n\t}\n\n\tprivate collectData(stream: Readable): Buffer[] {\n\t\tconst buffers: Buffer[] = [];\n\t\tstream.on(\"data\", (data: Buffer) => {\n\t\t\tbuffers.push(data);\n\t\t});\n\t\treturn buffers;\n\t}\n\n\tprivate decodeData(buffers: Buffer[], encoding: BufferEncoding): string {\n\t\tconst decoder = new StringDecoder(encoding);\n\t\treturn buffers.map((buffer) => decoder.write(buffer)).join(\"\");\n\t}\n\n\tprivate initDirectoryTree(): IDirectoryTree {\n\t\tconst tree: IDirectoryTree = {\n\t\t\trootEntries: [],\n\t\t\tpathToEntries: Object.create(null),\n\t\t};\n\t\ttree.pathToEntries[\".\"] = tree.rootEntries;\n\t\treturn tree;\n\t}\n\n\tprivate addDirectoryEntries(\n\t\tfolderQuery: IFolderQuery,\n\t\t{ pathToEntries }: IDirectoryTree,\n\t\tbase: string,\n\t\trelativeFiles: string[],\n\t\tonResult: (result: IRawFileMatch) => void,\n\t) {\n\t\t// Support relative paths to files from a root resource (ignores excludes)\n\t\tif (relativeFiles.indexOf(this.filePattern) !== -1) {\n\t\t\tthis.matchFile(onResult, {\n\t\t\t\tbase,\n\t\t\t\trelativePath: this.filePattern,\n\t\t\t\tsearchPath: this.getSearchPath(folderQuery, this.filePattern),\n\t\t\t});\n\t\t}\n\n\t\tconst add = (relativePath: string) => {\n\t\t\tconst basename = path.basename(relativePath);\n\t\t\tconst dirname = path.dirname(relativePath);\n\t\t\tlet entries = pathToEntries[dirname];\n\t\t\tif (!entries) {\n\t\t\t\tentries = pathToEntries[dirname] = [];\n\t\t\t\tadd(dirname);\n\t\t\t}\n\t\t\tentries.push({\n\t\t\t\tbase,\n\t\t\t\trelativePath,\n\t\t\t\tbasename,\n\t\t\t\tsearchPath: this.getSearchPath(folderQuery, relativePath),\n\t\t\t});\n\t\t};\n\t\trelativeFiles.forEach(add);\n\t}\n\n\tprivate matchDirectoryTree(\n\t\t{ rootEntries, pathToEntries }: IDirectoryTree,\n\t\trootFolder: string,\n\t\tonResult: (result: IRawFileMatch) => void,\n\t) {\n\t\tconst self = this;\n\t\tconst excludePattern = this.folderExcludePatterns.get(rootFolder)!;\n\t\tconst filePattern = this.filePattern;\n\t\tfunction matchDirectory(entries: IDirectoryEntry[]) {\n\t\t\tself.directoriesWalked++;\n\t\t\tconst hasSibling = hasSiblingFn(() =>\n\t\t\t\tentries.map((entry) => entry.basename),\n\t\t\t);\n\t\t\tfor (let i = 0, n = entries.length; i < n; i++) {\n\t\t\t\tconst entry = entries[i];\n\t\t\t\tconst { relativePath, basename } = entry;\n\n\t\t\t\t// Check exclude pattern\n\t\t\t\t// If the user searches for the exact file name, we adjust the glob matching\n\t\t\t\t// to ignore filtering by siblings because the user seems to know what they\n\t\t\t\t// are searching for and we want to include the result in that case anyway\n\t\t\t\tif (\n\t\t\t\t\texcludePattern.test(\n\t\t\t\t\t\trelativePath,\n\t\t\t\t\t\tbasename,\n\t\t\t\t\t\tfilePattern !== basename ? hasSibling : undefined,\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst sub = pathToEntries[relativePath];\n\t\t\t\tif (sub) {\n\t\t\t\t\tmatchDirectory(sub);\n\t\t\t\t} else {\n\t\t\t\t\tself.filesWalked++;\n\t\t\t\t\tif (relativePath === filePattern) {\n\t\t\t\t\t\tcontinue; // ignore file if its path matches with the file pattern because that is already matched above\n\t\t\t\t\t}\n\n\t\t\t\t\tself.matchFile(onResult, entry);\n\t\t\t\t}\n\n\t\t\t\tif (self.isLimitHit) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmatchDirectory(rootEntries);\n\t}\n\n\tgetStats(): ISearchEngineStats {\n\t\treturn {\n\t\t\tcmdTime: this.cmdSW!.elapsed(),\n\t\t\tfileWalkTime: this.fileWalkSW!.elapsed(),\n\t\t\tdirectoriesWalked: this.directoriesWalked,\n\t\t\tfilesWalked: this.filesWalked,\n\t\t\tcmdResultCount: this.cmdResultCount,\n\t\t};\n\t}\n\n\tprivate doWalk(\n\t\tfolderQuery: IFolderQuery,\n\t\trelativeParentPath: string,\n\t\tfiles: string[],\n\t\tonResult: (result: IRawFileMatch) => void,\n\t\tdone: (error?: Error) => void,\n\t): void {\n\t\tconst rootFolder = folderQuery.folder;\n\n\t\t// Execute tasks on each file in parallel to optimize throughput\n\t\tconst hasSibling = hasSiblingFn(() => files);\n\t\tthis.parallel(\n\t\t\tfiles,\n\t\t\t(\n\t\t\t\tfile: string,\n\t\t\t\tclb: (error: Error | null, _?: any) => void,\n\t\t\t): void => {\n\t\t\t\t// Check canceled\n\t\t\t\tif (this.isCanceled || this.isLimitHit) {\n\t\t\t\t\treturn clb(null);\n\t\t\t\t}\n\n\t\t\t\t// Check exclude pattern\n\t\t\t\t// If the user searches for the exact file name, we adjust the glob matching\n\t\t\t\t// to ignore filtering by siblings because the user seems to know what they\n\t\t\t\t// are searching for and we want to include the result in that case anyway\n\t\t\t\tconst currentRelativePath = relativeParentPath\n\t\t\t\t\t? [relativeParentPath, file].join(path.sep)\n\t\t\t\t\t: file;\n\t\t\t\tif (\n\t\t\t\t\tthis.folderExcludePatterns\n\t\t\t\t\t\t.get(folderQuery.folder.fsPath)!\n\t\t\t\t\t\t.test(\n\t\t\t\t\t\t\tcurrentRelativePath,\n\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\tthis.config.filePattern !== file\n\t\t\t\t\t\t\t\t? hasSibling\n\t\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\treturn clb(null);\n\t\t\t\t}\n\n\t\t\t\t// Use lstat to detect links\n\t\t\t\tconst currentAbsolutePath = [\n\t\t\t\t\trootFolder.fsPath,\n\t\t\t\t\tcurrentRelativePath,\n\t\t\t\t].join(path.sep);\n\t\t\t\tfs.lstat(currentAbsolutePath, (error, lstat) => {\n\t\t\t\t\tif (error || this.isCanceled || this.isLimitHit) {\n\t\t\t\t\t\treturn clb(null);\n\t\t\t\t\t}\n\n\t\t\t\t\t// If the path is a link, we must instead use fs.stat() to find out if the\n\t\t\t\t\t// link is a directory or not because lstat will always return the stat of\n\t\t\t\t\t// the link which is always a file.\n\t\t\t\t\tthis.statLinkIfNeeded(\n\t\t\t\t\t\tcurrentAbsolutePath,\n\t\t\t\t\t\tlstat,\n\t\t\t\t\t\t(error, stat) => {\n\t\t\t\t\t\t\tif (error || this.isCanceled || this.isLimitHit) {\n\t\t\t\t\t\t\t\treturn clb(null);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Directory: Follow directories\n\t\t\t\t\t\t\tif (stat.isDirectory()) {\n\t\t\t\t\t\t\t\tthis.directoriesWalked++;\n\n\t\t\t\t\t\t\t\t// to really prevent loops with links we need to resolve the real path of them\n\t\t\t\t\t\t\t\treturn this.realPathIfNeeded(\n\t\t\t\t\t\t\t\t\tcurrentAbsolutePath,\n\t\t\t\t\t\t\t\t\tlstat,\n\t\t\t\t\t\t\t\t\t(error, realpath) => {\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\terror ||\n\t\t\t\t\t\t\t\t\t\t\tthis.isCanceled ||\n\t\t\t\t\t\t\t\t\t\t\tthis.isLimitHit\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\treturn clb(null);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\trealpath = realpath || \"\";\n\t\t\t\t\t\t\t\t\t\tif (this.walkedPaths[realpath]) {\n\t\t\t\t\t\t\t\t\t\t\treturn clb(null); // escape when there are cycles (can happen with symlinks)\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tthis.walkedPaths[realpath] = true; // remember as walked\n\n\t\t\t\t\t\t\t\t\t\t// Continue walking\n\t\t\t\t\t\t\t\t\t\treturn Promises.readdir(\n\t\t\t\t\t\t\t\t\t\t\tcurrentAbsolutePath,\n\t\t\t\t\t\t\t\t\t\t).then(\n\t\t\t\t\t\t\t\t\t\t\t(children) => {\n\t\t\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.isCanceled ||\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.isLimitHit\n\t\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn clb(null);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.doWalk(\n\t\t\t\t\t\t\t\t\t\t\t\t\tfolderQuery,\n\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentRelativePath,\n\t\t\t\t\t\t\t\t\t\t\t\t\tchildren,\n\t\t\t\t\t\t\t\t\t\t\t\t\tonResult,\n\t\t\t\t\t\t\t\t\t\t\t\t\t(err) => clb(err || null),\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t(error) => {\n\t\t\t\t\t\t\t\t\t\t\t\tclb(null);\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// File: Check for match on file pattern and include pattern\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tthis.filesWalked++;\n\t\t\t\t\t\t\t\tif (currentRelativePath === this.filePattern) {\n\t\t\t\t\t\t\t\t\treturn clb(null, undefined); // ignore file if its path matches with the file pattern because checkFilePatternRelativeMatch() takes care of those\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tthis.maxFilesize &&\n\t\t\t\t\t\t\t\t\ttypes.isNumber(stat.size) &&\n\t\t\t\t\t\t\t\t\tstat.size > this.maxFilesize\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\treturn clb(null, undefined); // ignore file if max file size is hit\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tthis.matchFile(onResult, {\n\t\t\t\t\t\t\t\t\tbase: rootFolder.fsPath,\n\t\t\t\t\t\t\t\t\trelativePath: currentRelativePath,\n\t\t\t\t\t\t\t\t\tsearchPath: this.getSearchPath(\n\t\t\t\t\t\t\t\t\t\tfolderQuery,\n\t\t\t\t\t\t\t\t\t\tcurrentRelativePath,\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Unwind\n\t\t\t\t\t\t\treturn clb(null, undefined);\n\t\t\t\t\t\t},\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t},\n\t\t\t(error: Array<Error | null> | null): void => {\n\t\t\t\tconst filteredErrors = error ? arrays.coalesce(error) : error; // find any error by removing null values first\n\t\t\t\treturn done(\n\t\t\t\t\tfilteredErrors && filteredErrors.length > 0\n\t\t\t\t\t\t? filteredErrors[0]\n\t\t\t\t\t\t: undefined,\n\t\t\t\t);\n\t\t\t},\n\t\t);\n\t}\n\n\tprivate matchFile(\n\t\tonResult: (result: IRawFileMatch) => void,\n\t\tcandidate: IRawFileMatch,\n\t): void {\n\t\tif (\n\t\t\tthis.isFileMatch(candidate) &&\n\t\t\t(!this.includePattern ||\n\t\t\t\tthis.includePattern(\n\t\t\t\t\tcandidate.relativePath,\n\t\t\t\t\tpath.basename(candidate.relativePath),\n\t\t\t\t))\n\t\t) {\n\t\t\tthis.resultCount++;\n\n\t\t\tif (\n\t\t\t\tthis.exists ||\n\t\t\t\t(this.maxResults && this.resultCount > this.maxResults)\n\t\t\t) {\n\t\t\t\tthis.isLimitHit = true;\n\t\t\t}\n\n\t\t\tif (!this.isLimitHit) {\n\t\t\t\tonResult(candidate);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate isFileMatch(candidate: IRawFileMatch): boolean {\n\t\t// Check for search pattern\n\t\tif (this.filePattern) {\n\t\t\tif (this.filePattern === \"*\") {\n\t\t\t\treturn true; // support the all-matching wildcard\n\t\t\t}\n\n\t\t\tif (this.normalizedFilePatternLowercase) {\n\t\t\t\treturn isFilePatternMatch(\n\t\t\t\t\tcandidate,\n\t\t\t\t\tthis.normalizedFilePatternLowercase,\n\t\t\t\t);\n\t\t\t} else if (this.filePattern) {\n\t\t\t\treturn isFilePatternMatch(candidate, this.filePattern, false);\n\t\t\t}\n\t\t}\n\n\t\t// No patterns means we match all\n\t\treturn true;\n\t}\n\n\tprivate statLinkIfNeeded(\n\t\tpath: string,\n\t\tlstat: fs.Stats,\n\t\tclb: (error: Error | null, stat: fs.Stats) => void,\n\t): void {\n\t\tif (lstat.isSymbolicLink()) {\n\t\t\treturn fs.stat(path, clb); // stat the target the link points to\n\t\t}\n\n\t\treturn clb(null, lstat); // not a link, so the stat is already ok for us\n\t}\n\n\tprivate realPathIfNeeded(\n\t\tpath: string,\n\t\tlstat: fs.Stats,\n\t\tclb: (error: Error | null, realpath?: string) => void,\n\t): void {\n\t\tif (lstat.isSymbolicLink()) {\n\t\t\treturn fs.realpath(path, (error, realpath) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treturn clb(error);\n\t\t\t\t}\n\n\t\t\t\treturn clb(null, realpath);\n\t\t\t});\n\t\t}\n\n\t\treturn clb(null, path);\n\t}\n\n\t/**\n\t * If we're searching for files in multiple workspace folders, then better prepend the\n\t * name of the workspace folder to the path of the file. This way we'll be able to\n\t * better filter files that are all on the top of a workspace folder and have all the\n\t * same name. A typical example are `package.json` or `README.md` files.\n\t */\n\tprivate getSearchPath(\n\t\tfolderQuery: IFolderQuery,\n\t\trelativePath: string,\n\t): string {\n\t\tif (folderQuery.folderName) {\n\t\t\treturn path.join(folderQuery.folderName, relativePath);\n\t\t}\n\t\treturn relativePath;\n\t}\n}\n\nexport class Engine implements ISearchEngine<IRawFileMatch> {\n\tprivate folderQueries: IFolderQuery[];\n\tprivate extraFiles: URI[];\n\tprivate walker: FileWalker;\n\tprivate numThreads?: number;\n\n\tconstructor(config: IFileQuery, numThreads?: number) {\n\t\tthis.folderQueries = config.folderQueries;\n\t\tthis.extraFiles = config.extraFileResources || [];\n\t\tthis.numThreads = numThreads;\n\n\t\tthis.walker = new FileWalker(config);\n\t}\n\n\tsearch(\n\t\tonResult: (result: IRawFileMatch) => void,\n\t\tonProgress: (progress: IProgressMessage) => void,\n\t\tdone: (error: Error | null, complete: ISearchEngineSuccess) => void,\n\t): void {\n\t\tthis.walker.walk(\n\t\t\tthis.folderQueries,\n\t\t\tthis.extraFiles,\n\t\t\tthis.numThreads,\n\t\t\tonResult,\n\t\t\tonProgress,\n\t\t\t(err: Error | null, isLimitHit: boolean) => {\n\t\t\t\tdone(err, {\n\t\t\t\t\tlimitHit: isLimitHit,\n\t\t\t\t\tstats: this.walker.getStats(),\n\t\t\t\t\tmessages: [],\n\t\t\t\t});\n\t\t\t},\n\t\t);\n\t}\n\n\tcancel(): void {\n\t\tthis.walker.cancel();\n\t}\n}\n\n/**\n * This class exists to provide one interface on top of two ParsedExpressions, one for absolute expressions and one for relative expressions.\n * The absolute and relative expressions don't \"have\" to be kept separate, but this keeps us from having to path.join every single\n * file searched, it's only used for a text search with a searchPath\n */\nclass AbsoluteAndRelativeParsedExpression {\n\tprivate absoluteParsedExpr: glob.ParsedExpression | undefined;\n\tprivate relativeParsedExpr: glob.ParsedExpression | undefined;\n\n\tconstructor(\n\t\tpublic expression: glob.IExpression,\n\t\tprivate root: string,\n\t) {\n\t\tthis.init(expression);\n\t}\n\n\t/**\n\t * Split the IExpression into its absolute and relative components, and glob.parse them separately.\n\t */\n\tprivate init(expr: glob.IExpression): void {\n\t\tlet absoluteGlobExpr: glob.IExpression | undefined;\n\t\tlet relativeGlobExpr: glob.IExpression | undefined;\n\t\tObject.keys(expr)\n\t\t\t.filter((key) => expr[key])\n\t\t\t.forEach((key) => {\n\t\t\t\tif (path.isAbsolute(key)) {\n\t\t\t\t\tabsoluteGlobExpr =\n\t\t\t\t\t\tabsoluteGlobExpr || glob.getEmptyExpression();\n\t\t\t\t\tabsoluteGlobExpr[key] = expr[key];\n\t\t\t\t} else {\n\t\t\t\t\trelativeGlobExpr =\n\t\t\t\t\t\trelativeGlobExpr || glob.getEmptyExpression();\n\t\t\t\t\trelativeGlobExpr[key] = expr[key];\n\t\t\t\t}\n\t\t\t});\n\n\t\tthis.absoluteParsedExpr =\n\t\t\tabsoluteGlobExpr &&\n\t\t\tglob.parse(absoluteGlobExpr, { trimForExclusions: true });\n\t\tthis.relativeParsedExpr =\n\t\t\trelativeGlobExpr &&\n\t\t\tglob.parse(relativeGlobExpr, { trimForExclusions: true });\n\t}\n\n\ttest(\n\t\t_path: string,\n\t\tbasename?: string,\n\t\thasSibling?: (name: string) => boolean | Promise<boolean>,\n\t): string | Promise<string | null> | undefined | null {\n\t\treturn (\n\t\t\t(this.relativeParsedExpr &&\n\t\t\t\tthis.relativeParsedExpr(_path, basename, hasSibling)) ||\n\t\t\t(this.absoluteParsedExpr &&\n\t\t\t\tthis.absoluteParsedExpr(\n\t\t\t\t\tpath.join(this.root, _path),\n\t\t\t\t\tbasename,\n\t\t\t\t\thasSibling,\n\t\t\t\t))\n\t\t);\n\t}\n\n\tgetBasenameTerms(): string[] {\n\t\tconst basenameTerms: string[] = [];\n\t\tif (this.absoluteParsedExpr) {\n\t\t\tbasenameTerms.push(\n\t\t\t\t...glob.getBasenameTerms(this.absoluteParsedExpr),\n\t\t\t);\n\t\t}\n\n\t\tif (this.relativeParsedExpr) {\n\t\t\tbasenameTerms.push(\n\t\t\t\t...glob.getBasenameTerms(this.relativeParsedExpr),\n\t\t\t);\n\t\t}\n\n\t\treturn basenameTerms;\n\t}\n\n\tgetPathTerms(): string[] {\n\t\tconst pathTerms: string[] = [];\n\t\tif (this.absoluteParsedExpr) {\n\t\t\tpathTerms.push(...glob.getPathTerms(this.absoluteParsedExpr));\n\t\t}\n\n\t\tif (this.relativeParsedExpr) {\n\t\t\tpathTerms.push(...glob.getPathTerms(this.relativeParsedExpr));\n\t\t}\n\n\t\treturn pathTerms;\n\t}\n}\n\nfunction rgErrorMsgForDisplay(msg: string): string | undefined {\n\tconst lines = msg.trim().split(\"\\n\");\n\tconst firstLine = lines[0].trim();\n\n\tif (firstLine.startsWith(\"Error parsing regex\")) {\n\t\treturn firstLine;\n\t}\n\n\tif (firstLine.startsWith(\"regex parse error\")) {\n\t\treturn strings.uppercaseFirstLetter(lines[lines.length - 1].trim());\n\t}\n\n\tif (\n\t\tfirstLine.startsWith(\"error parsing glob\") ||\n\t\tfirstLine.startsWith(\"unsupported encoding\")\n\t) {\n\t\t// Uppercase first letter\n\t\treturn firstLine.charAt(0).toUpperCase() + firstLine.substr(1);\n\t}\n\n\tif (firstLine === `Literal '\\\\n' not allowed.`) {\n\t\t// I won't localize this because none of the Ripgrep error messages are localized\n\t\treturn `Literal '\\\\n' currently not supported`;\n\t}\n\n\tif (firstLine.startsWith(\"Literal \")) {\n\t\t// Other unsupported chars\n\t\treturn firstLine;\n\t}\n\n\treturn undefined;\n}\n"],
  "mappings": "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",
  "names": ["path", "error"]
}
