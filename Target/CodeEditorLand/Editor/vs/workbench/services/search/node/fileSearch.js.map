{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/search/node/fileSearch.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as childProcess from 'child_process';\nimport * as fs from 'fs';\nimport * as path from '../../../../base/common/path.js';\nimport { Readable } from 'stream';\nimport { StringDecoder } from 'string_decoder';\nimport * as arrays from '../../../../base/common/arrays.js';\nimport { toErrorMessage } from '../../../../base/common/errorMessage.js';\nimport * as glob from '../../../../base/common/glob.js';\nimport * as normalization from '../../../../base/common/normalization.js';\nimport { isEqualOrParent } from '../../../../base/common/extpath.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport { StopWatch } from '../../../../base/common/stopwatch.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport * as types from '../../../../base/common/types.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { Promises } from '../../../../base/node/pfs.js';\nimport { IFileQuery, IFolderQuery, IProgressMessage, ISearchEngineStats, IRawFileMatch, ISearchEngine, ISearchEngineSuccess, isFilePatternMatch, hasSiblingFn } from '../common/search.js';\nimport { spawnRipgrepCmd } from './ripgrepFileSearch.js';\nimport { prepareQuery } from '../../../../base/common/fuzzyScorer.js';\n\ninterface IDirectoryEntry extends IRawFileMatch {\n\tbase: string;\n\tbasename: string;\n}\n\ninterface IDirectoryTree {\n\trootEntries: IDirectoryEntry[];\n\tpathToEntries: { [relativePath: string]: IDirectoryEntry[] };\n}\n\nconst killCmds = new Set<() => void>();\nprocess.on('exit', () => {\n\tkillCmds.forEach(cmd => cmd());\n});\n\nexport class FileWalker {\n\tprivate config: IFileQuery;\n\tprivate filePattern: string;\n\tprivate normalizedFilePatternLowercase: string | null = null;\n\tprivate includePattern: glob.ParsedExpression | undefined;\n\tprivate maxResults: number | null;\n\tprivate exists: boolean;\n\tprivate maxFilesize: number | null = null;\n\tprivate isLimitHit: boolean;\n\tprivate resultCount: number;\n\tprivate isCanceled = false;\n\tprivate fileWalkSW: StopWatch | null = null;\n\tprivate directoriesWalked: number;\n\tprivate filesWalked: number;\n\tprivate errors: string[];\n\tprivate cmdSW: StopWatch | null = null;\n\tprivate cmdResultCount: number = 0;\n\n\tprivate folderExcludePatterns: Map<string, AbsoluteAndRelativeParsedExpression>;\n\tprivate globalExcludePattern: glob.ParsedExpression | undefined;\n\n\tprivate walkedPaths: { [path: string]: boolean };\n\n\tconstructor(config: IFileQuery) {\n\t\tthis.config = config;\n\t\tthis.filePattern = config.filePattern || '';\n\t\tthis.includePattern = config.includePattern && glob.parse(config.includePattern);\n\t\tthis.maxResults = config.maxResults || null;\n\t\tthis.exists = !!config.exists;\n\t\tthis.walkedPaths = Object.create(null);\n\t\tthis.resultCount = 0;\n\t\tthis.isLimitHit = false;\n\t\tthis.directoriesWalked = 0;\n\t\tthis.filesWalked = 0;\n\t\tthis.errors = [];\n\n\t\tif (this.filePattern) {\n\t\t\tthis.normalizedFilePatternLowercase = config.shouldGlobMatchFilePattern ? null : prepareQuery(this.filePattern).normalizedLowercase;\n\t\t}\n\n\t\tthis.globalExcludePattern = config.excludePattern && glob.parse(config.excludePattern);\n\t\tthis.folderExcludePatterns = new Map<string, AbsoluteAndRelativeParsedExpression>();\n\n\t\tconfig.folderQueries.forEach(folderQuery => {\n\t\t\tconst folderExcludeExpression: glob.IExpression = {}; // todo: consider exclude baseURI\n\n\t\t\tfolderQuery.excludePattern?.forEach(excludePattern => {\n\t\t\t\tObject.assign(folderExcludeExpression, excludePattern.pattern || {}, this.config.excludePattern || {});\n\t\t\t});\n\n\t\t\tif (!folderQuery.excludePattern?.length) {\n\t\t\t\tObject.assign(folderExcludeExpression, this.config.excludePattern || {});\n\t\t\t}\n\n\t\t\t// Add excludes for other root folders\n\t\t\tconst fqPath = folderQuery.folder.fsPath;\n\t\t\tconfig.folderQueries\n\t\t\t\t.map(rootFolderQuery => rootFolderQuery.folder.fsPath)\n\t\t\t\t.filter(rootFolder => rootFolder !== fqPath)\n\t\t\t\t.forEach(otherRootFolder => {\n\t\t\t\t\t// Exclude nested root folders\n\t\t\t\t\tif (isEqualOrParent(otherRootFolder, fqPath)) {\n\t\t\t\t\t\tfolderExcludeExpression[path.relative(fqPath, otherRootFolder)] = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\tthis.folderExcludePatterns.set(fqPath, new AbsoluteAndRelativeParsedExpression(folderExcludeExpression, fqPath));\n\t\t});\n\t}\n\n\tcancel(): void {\n\t\tthis.isCanceled = true;\n\t\tkillCmds.forEach(cmd => cmd());\n\t}\n\n\twalk(folderQueries: IFolderQuery[], extraFiles: URI[], numThreads: number | undefined, onResult: (result: IRawFileMatch) => void, onMessage: (message: IProgressMessage) => void, done: (error: Error | null, isLimitHit: boolean) => void): void {\n\t\tthis.fileWalkSW = StopWatch.create(false);\n\n\t\t// Support that the file pattern is a full path to a file that exists\n\t\tif (this.isCanceled) {\n\t\t\treturn done(null, this.isLimitHit);\n\t\t}\n\n\t\t// For each extra file\n\t\textraFiles.forEach(extraFilePath => {\n\t\t\tconst basename = path.basename(extraFilePath.fsPath);\n\t\t\tif (this.globalExcludePattern && this.globalExcludePattern(extraFilePath.fsPath, basename)) {\n\t\t\t\treturn; // excluded\n\t\t\t}\n\n\t\t\t// File: Check for match on file pattern and include pattern\n\t\t\tthis.matchFile(onResult, { relativePath: extraFilePath.fsPath /* no workspace relative path */, searchPath: undefined });\n\t\t});\n\n\t\tthis.cmdSW = StopWatch.create(false);\n\n\t\t// For each root folder\n\t\tthis.parallel<IFolderQuery, void>(folderQueries, (folderQuery: IFolderQuery, rootFolderDone: (err: Error | null, result: void) => void) => {\n\t\t\tthis.call(this.cmdTraversal, this, folderQuery, numThreads, onResult, onMessage, (err?: Error) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tconst errorMessage = toErrorMessage(err);\n\t\t\t\t\tconsole.error(errorMessage);\n\t\t\t\t\tthis.errors.push(errorMessage);\n\t\t\t\t\trootFolderDone(err, undefined);\n\t\t\t\t} else {\n\t\t\t\t\trootFolderDone(null, undefined);\n\t\t\t\t}\n\t\t\t});\n\t\t}, (errors, _result) => {\n\t\t\tthis.fileWalkSW!.stop();\n\t\t\tconst err = errors ? arrays.coalesce(errors)[0] : null;\n\t\t\tdone(err, this.isLimitHit);\n\t\t});\n\t}\n\n\tprivate parallel<T, E>(list: T[], fn: (item: T, callback: (err: Error | null, result: E | null) => void) => void, callback: (err: Array<Error | null> | null, result: E[]) => void): void {\n\t\tconst results = new Array(list.length);\n\t\tconst errors = new Array<Error | null>(list.length);\n\t\tlet didErrorOccur = false;\n\t\tlet doneCount = 0;\n\n\t\tif (list.length === 0) {\n\t\t\treturn callback(null, []);\n\t\t}\n\n\t\tlist.forEach((item, index) => {\n\t\t\tfn(item, (error, result) => {\n\t\t\t\tif (error) {\n\t\t\t\t\tdidErrorOccur = true;\n\t\t\t\t\tresults[index] = null;\n\t\t\t\t\terrors[index] = error;\n\t\t\t\t} else {\n\t\t\t\t\tresults[index] = result;\n\t\t\t\t\terrors[index] = null;\n\t\t\t\t}\n\n\t\t\t\tif (++doneCount === list.length) {\n\t\t\t\t\treturn callback(didErrorOccur ? errors : null, results);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate call<F extends Function>(fun: F, that: any, ...args: any[]): void {\n\t\ttry {\n\t\t\tfun.apply(that, args);\n\t\t} catch (e) {\n\t\t\targs[args.length - 1](e);\n\t\t}\n\t}\n\n\tprivate cmdTraversal(folderQuery: IFolderQuery, numThreads: number | undefined, onResult: (result: IRawFileMatch) => void, onMessage: (message: IProgressMessage) => void, cb: (err?: Error) => void): void {\n\t\tconst rootFolder = folderQuery.folder.fsPath;\n\t\tconst isMac = platform.isMacintosh;\n\n\t\tconst killCmd = () => cmd && cmd.kill();\n\t\tkillCmds.add(killCmd);\n\n\t\tlet done = (err?: Error) => {\n\t\t\tkillCmds.delete(killCmd);\n\t\t\tdone = () => { };\n\t\t\tcb(err);\n\t\t};\n\t\tlet leftover = '';\n\t\tconst tree = this.initDirectoryTree();\n\n\t\tconst ripgrep = spawnRipgrepCmd(this.config, folderQuery, this.config.includePattern, this.folderExcludePatterns.get(folderQuery.folder.fsPath)!.expression, numThreads);\n\t\tconst cmd = ripgrep.cmd;\n\t\tconst noSiblingsClauses = !Object.keys(ripgrep.siblingClauses).length;\n\n\t\tconst escapedArgs = ripgrep.rgArgs.args\n\t\t\t.map(arg => arg.match(/^-/) ? arg : `'${arg}'`)\n\t\t\t.join(' ');\n\n\t\tlet rgCmd = `${ripgrep.rgDiskPath} ${escapedArgs}\\n - cwd: ${ripgrep.cwd}`;\n\t\tif (ripgrep.rgArgs.siblingClauses) {\n\t\t\trgCmd += `\\n - Sibling clauses: ${JSON.stringify(ripgrep.rgArgs.siblingClauses)}`;\n\t\t}\n\t\tonMessage({ message: rgCmd });\n\n\t\tthis.cmdResultCount = 0;\n\t\tthis.collectStdout(cmd, 'utf8', onMessage, (err: Error | null, stdout?: string, last?: boolean) => {\n\t\t\tif (err) {\n\t\t\t\tdone(err);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this.isLimitHit) {\n\t\t\t\tdone();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Mac: uses NFD unicode form on disk, but we want NFC\n\t\t\tconst normalized = leftover + (isMac ? normalization.normalizeNFC(stdout || '') : stdout);\n\t\t\tconst relativeFiles = normalized.split('\\n');\n\n\t\t\tif (last) {\n\t\t\t\tconst n = relativeFiles.length;\n\t\t\t\trelativeFiles[n - 1] = relativeFiles[n - 1].trim();\n\t\t\t\tif (!relativeFiles[n - 1]) {\n\t\t\t\t\trelativeFiles.pop();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tleftover = relativeFiles.pop() || '';\n\t\t\t}\n\n\t\t\tif (relativeFiles.length && relativeFiles[0].indexOf('\\n') !== -1) {\n\t\t\t\tdone(new Error('Splitting up files failed'));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.cmdResultCount += relativeFiles.length;\n\n\t\t\tif (noSiblingsClauses) {\n\t\t\t\tfor (const relativePath of relativeFiles) {\n\t\t\t\t\tthis.matchFile(onResult, { base: rootFolder, relativePath, searchPath: this.getSearchPath(folderQuery, relativePath) });\n\t\t\t\t\tif (this.isLimitHit) {\n\t\t\t\t\t\tkillCmd();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (last || this.isLimitHit) {\n\t\t\t\t\tdone();\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// TODO: Optimize siblings clauses with ripgrep here.\n\t\t\tthis.addDirectoryEntries(folderQuery, tree, rootFolder, relativeFiles, onResult);\n\n\t\t\tif (last) {\n\t\t\t\tthis.matchDirectoryTree(tree, rootFolder, onResult);\n\t\t\t\tdone();\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Public for testing.\n\t */\n\tspawnFindCmd(folderQuery: IFolderQuery) {\n\t\tconst excludePattern = this.folderExcludePatterns.get(folderQuery.folder.fsPath)!;\n\t\tconst basenames = excludePattern.getBasenameTerms();\n\t\tconst pathTerms = excludePattern.getPathTerms();\n\t\tconst args = ['-L', '.'];\n\t\tif (basenames.length || pathTerms.length) {\n\t\t\targs.push('-not', '(', '(');\n\t\t\tfor (const basename of basenames) {\n\t\t\t\targs.push('-name', basename);\n\t\t\t\targs.push('-o');\n\t\t\t}\n\t\t\tfor (const path of pathTerms) {\n\t\t\t\targs.push('-path', path);\n\t\t\t\targs.push('-o');\n\t\t\t}\n\t\t\targs.pop();\n\t\t\targs.push(')', '-prune', ')');\n\t\t}\n\t\targs.push('-type', 'f');\n\t\treturn childProcess.spawn('find', args, { cwd: folderQuery.folder.fsPath });\n\t}\n\n\t/**\n\t * Public for testing.\n\t */\n\treadStdout(cmd: childProcess.ChildProcess, encoding: BufferEncoding, cb: (err: Error | null, stdout?: string) => void): void {\n\t\tlet all = '';\n\t\tthis.collectStdout(cmd, encoding, () => { }, (err: Error | null, stdout?: string, last?: boolean) => {\n\t\t\tif (err) {\n\t\t\t\tcb(err);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tall += stdout;\n\t\t\tif (last) {\n\t\t\t\tcb(null, all);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate collectStdout(cmd: childProcess.ChildProcess, encoding: BufferEncoding, onMessage: (message: IProgressMessage) => void, cb: (err: Error | null, stdout?: string, last?: boolean) => void): void {\n\t\tlet onData = (err: Error | null, stdout?: string, last?: boolean) => {\n\t\t\tif (err || last) {\n\t\t\t\tonData = () => { };\n\n\t\t\t\tthis.cmdSW?.stop();\n\t\t\t}\n\t\t\tcb(err, stdout, last);\n\t\t};\n\n\t\tlet gotData = false;\n\t\tif (cmd.stdout) {\n\t\t\t// Should be non-null, but #38195\n\t\t\tthis.forwardData(cmd.stdout, encoding, onData);\n\t\t\tcmd.stdout.once('data', () => gotData = true);\n\t\t} else {\n\t\t\tonMessage({ message: 'stdout is null' });\n\t\t}\n\n\t\tlet stderr: Buffer[];\n\t\tif (cmd.stderr) {\n\t\t\t// Should be non-null, but #38195\n\t\t\tstderr = this.collectData(cmd.stderr);\n\t\t} else {\n\t\t\tonMessage({ message: 'stderr is null' });\n\t\t}\n\n\t\tcmd.on('error', (err: Error) => {\n\t\t\tonData(err);\n\t\t});\n\n\t\tcmd.on('close', (code: number) => {\n\t\t\t// ripgrep returns code=1 when no results are found\n\t\t\tlet stderrText: string;\n\t\t\tif (!gotData && (stderrText = this.decodeData(stderr, encoding)) && rgErrorMsgForDisplay(stderrText)) {\n\t\t\t\tonData(new Error(`command failed with error code ${code}: ${this.decodeData(stderr, encoding)}`));\n\t\t\t} else {\n\t\t\t\tif (this.exists && code === 0) {\n\t\t\t\t\tthis.isLimitHit = true;\n\t\t\t\t}\n\t\t\t\tonData(null, '', true);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate forwardData(stream: Readable, encoding: BufferEncoding, cb: (err: Error | null, stdout?: string) => void): StringDecoder {\n\t\tconst decoder = new StringDecoder(encoding);\n\t\tstream.on('data', (data: Buffer) => {\n\t\t\tcb(null, decoder.write(data));\n\t\t});\n\t\treturn decoder;\n\t}\n\n\tprivate collectData(stream: Readable): Buffer[] {\n\t\tconst buffers: Buffer[] = [];\n\t\tstream.on('data', (data: Buffer) => {\n\t\t\tbuffers.push(data);\n\t\t});\n\t\treturn buffers;\n\t}\n\n\tprivate decodeData(buffers: Buffer[], encoding: BufferEncoding): string {\n\t\tconst decoder = new StringDecoder(encoding);\n\t\treturn buffers.map(buffer => decoder.write(buffer)).join('');\n\t}\n\n\tprivate initDirectoryTree(): IDirectoryTree {\n\t\tconst tree: IDirectoryTree = {\n\t\t\trootEntries: [],\n\t\t\tpathToEntries: Object.create(null)\n\t\t};\n\t\ttree.pathToEntries['.'] = tree.rootEntries;\n\t\treturn tree;\n\t}\n\n\tprivate addDirectoryEntries(folderQuery: IFolderQuery, { pathToEntries }: IDirectoryTree, base: string, relativeFiles: string[], onResult: (result: IRawFileMatch) => void) {\n\t\t// Support relative paths to files from a root resource (ignores excludes)\n\t\tif (relativeFiles.indexOf(this.filePattern) !== -1) {\n\t\t\tthis.matchFile(onResult, {\n\t\t\t\tbase,\n\t\t\t\trelativePath: this.filePattern,\n\t\t\t\tsearchPath: this.getSearchPath(folderQuery, this.filePattern)\n\t\t\t});\n\t\t}\n\n\t\tconst add = (relativePath: string) => {\n\t\t\tconst basename = path.basename(relativePath);\n\t\t\tconst dirname = path.dirname(relativePath);\n\t\t\tlet entries = pathToEntries[dirname];\n\t\t\tif (!entries) {\n\t\t\t\tentries = pathToEntries[dirname] = [];\n\t\t\t\tadd(dirname);\n\t\t\t}\n\t\t\tentries.push({\n\t\t\t\tbase,\n\t\t\t\trelativePath,\n\t\t\t\tbasename,\n\t\t\t\tsearchPath: this.getSearchPath(folderQuery, relativePath),\n\t\t\t});\n\t\t};\n\t\trelativeFiles.forEach(add);\n\t}\n\n\tprivate matchDirectoryTree({ rootEntries, pathToEntries }: IDirectoryTree, rootFolder: string, onResult: (result: IRawFileMatch) => void) {\n\t\tconst self = this;\n\t\tconst excludePattern = this.folderExcludePatterns.get(rootFolder)!;\n\t\tconst filePattern = this.filePattern;\n\t\tfunction matchDirectory(entries: IDirectoryEntry[]) {\n\t\t\tself.directoriesWalked++;\n\t\t\tconst hasSibling = hasSiblingFn(() => entries.map(entry => entry.basename));\n\t\t\tfor (let i = 0, n = entries.length; i < n; i++) {\n\t\t\t\tconst entry = entries[i];\n\t\t\t\tconst { relativePath, basename } = entry;\n\n\t\t\t\t// Check exclude pattern\n\t\t\t\t// If the user searches for the exact file name, we adjust the glob matching\n\t\t\t\t// to ignore filtering by siblings because the user seems to know what they\n\t\t\t\t// are searching for and we want to include the result in that case anyway\n\t\t\t\tif (excludePattern.test(relativePath, basename, filePattern !== basename ? hasSibling : undefined)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst sub = pathToEntries[relativePath];\n\t\t\t\tif (sub) {\n\t\t\t\t\tmatchDirectory(sub);\n\t\t\t\t} else {\n\t\t\t\t\tself.filesWalked++;\n\t\t\t\t\tif (relativePath === filePattern) {\n\t\t\t\t\t\tcontinue; // ignore file if its path matches with the file pattern because that is already matched above\n\t\t\t\t\t}\n\n\t\t\t\t\tself.matchFile(onResult, entry);\n\t\t\t\t}\n\n\t\t\t\tif (self.isLimitHit) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmatchDirectory(rootEntries);\n\t}\n\n\tgetStats(): ISearchEngineStats {\n\t\treturn {\n\t\t\tcmdTime: this.cmdSW!.elapsed(),\n\t\t\tfileWalkTime: this.fileWalkSW!.elapsed(),\n\t\t\tdirectoriesWalked: this.directoriesWalked,\n\t\t\tfilesWalked: this.filesWalked,\n\t\t\tcmdResultCount: this.cmdResultCount\n\t\t};\n\t}\n\n\tprivate doWalk(folderQuery: IFolderQuery, relativeParentPath: string, files: string[], onResult: (result: IRawFileMatch) => void, done: (error?: Error) => void): void {\n\t\tconst rootFolder = folderQuery.folder;\n\n\t\t// Execute tasks on each file in parallel to optimize throughput\n\t\tconst hasSibling = hasSiblingFn(() => files);\n\t\tthis.parallel(files, (file: string, clb: (error: Error | null, _?: any) => void): void => {\n\n\t\t\t// Check canceled\n\t\t\tif (this.isCanceled || this.isLimitHit) {\n\t\t\t\treturn clb(null);\n\t\t\t}\n\n\t\t\t// Check exclude pattern\n\t\t\t// If the user searches for the exact file name, we adjust the glob matching\n\t\t\t// to ignore filtering by siblings because the user seems to know what they\n\t\t\t// are searching for and we want to include the result in that case anyway\n\t\t\tconst currentRelativePath = relativeParentPath ? [relativeParentPath, file].join(path.sep) : file;\n\t\t\tif (this.folderExcludePatterns.get(folderQuery.folder.fsPath)!.test(currentRelativePath, file, this.config.filePattern !== file ? hasSibling : undefined)) {\n\t\t\t\treturn clb(null);\n\t\t\t}\n\n\t\t\t// Use lstat to detect links\n\t\t\tconst currentAbsolutePath = [rootFolder.fsPath, currentRelativePath].join(path.sep);\n\t\t\tfs.lstat(currentAbsolutePath, (error, lstat) => {\n\t\t\t\tif (error || this.isCanceled || this.isLimitHit) {\n\t\t\t\t\treturn clb(null);\n\t\t\t\t}\n\n\t\t\t\t// If the path is a link, we must instead use fs.stat() to find out if the\n\t\t\t\t// link is a directory or not because lstat will always return the stat of\n\t\t\t\t// the link which is always a file.\n\t\t\t\tthis.statLinkIfNeeded(currentAbsolutePath, lstat, (error, stat) => {\n\t\t\t\t\tif (error || this.isCanceled || this.isLimitHit) {\n\t\t\t\t\t\treturn clb(null);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Directory: Follow directories\n\t\t\t\t\tif (stat.isDirectory()) {\n\t\t\t\t\t\tthis.directoriesWalked++;\n\n\t\t\t\t\t\t// to really prevent loops with links we need to resolve the real path of them\n\t\t\t\t\t\treturn this.realPathIfNeeded(currentAbsolutePath, lstat, (error, realpath) => {\n\t\t\t\t\t\t\tif (error || this.isCanceled || this.isLimitHit) {\n\t\t\t\t\t\t\t\treturn clb(null);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\trealpath = realpath || '';\n\t\t\t\t\t\t\tif (this.walkedPaths[realpath]) {\n\t\t\t\t\t\t\t\treturn clb(null); // escape when there are cycles (can happen with symlinks)\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.walkedPaths[realpath] = true; // remember as walked\n\n\t\t\t\t\t\t\t// Continue walking\n\t\t\t\t\t\t\treturn Promises.readdir(currentAbsolutePath).then(children => {\n\t\t\t\t\t\t\t\tif (this.isCanceled || this.isLimitHit) {\n\t\t\t\t\t\t\t\t\treturn clb(null);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tthis.doWalk(folderQuery, currentRelativePath, children, onResult, err => clb(err || null));\n\t\t\t\t\t\t\t}, error => {\n\t\t\t\t\t\t\t\tclb(null);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\t// File: Check for match on file pattern and include pattern\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.filesWalked++;\n\t\t\t\t\t\tif (currentRelativePath === this.filePattern) {\n\t\t\t\t\t\t\treturn clb(null, undefined); // ignore file if its path matches with the file pattern because checkFilePatternRelativeMatch() takes care of those\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (this.maxFilesize && types.isNumber(stat.size) && stat.size > this.maxFilesize) {\n\t\t\t\t\t\t\treturn clb(null, undefined); // ignore file if max file size is hit\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.matchFile(onResult, {\n\t\t\t\t\t\t\tbase: rootFolder.fsPath,\n\t\t\t\t\t\t\trelativePath: currentRelativePath,\n\t\t\t\t\t\t\tsearchPath: this.getSearchPath(folderQuery, currentRelativePath),\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\t// Unwind\n\t\t\t\t\treturn clb(null, undefined);\n\t\t\t\t});\n\t\t\t});\n\t\t}, (error: Array<Error | null> | null): void => {\n\t\t\tconst filteredErrors = error ? arrays.coalesce(error) : error; // find any error by removing null values first\n\t\t\treturn done(filteredErrors && filteredErrors.length > 0 ? filteredErrors[0] : undefined);\n\t\t});\n\t}\n\n\tprivate matchFile(onResult: (result: IRawFileMatch) => void, candidate: IRawFileMatch): void {\n\t\tif (this.isFileMatch(candidate) && (!this.includePattern || this.includePattern(candidate.relativePath, path.basename(candidate.relativePath)))) {\n\t\t\tthis.resultCount++;\n\n\t\t\tif (this.exists || (this.maxResults && this.resultCount > this.maxResults)) {\n\t\t\t\tthis.isLimitHit = true;\n\t\t\t}\n\n\t\t\tif (!this.isLimitHit) {\n\t\t\t\tonResult(candidate);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate isFileMatch(candidate: IRawFileMatch): boolean {\n\t\t// Check for search pattern\n\t\tif (this.filePattern) {\n\t\t\tif (this.filePattern === '*') {\n\t\t\t\treturn true; // support the all-matching wildcard\n\t\t\t}\n\n\t\t\tif (this.normalizedFilePatternLowercase) {\n\t\t\t\treturn isFilePatternMatch(candidate, this.normalizedFilePatternLowercase);\n\t\t\t} else if (this.filePattern) {\n\t\t\t\treturn isFilePatternMatch(candidate, this.filePattern, false);\n\t\t\t}\n\t\t}\n\n\t\t// No patterns means we match all\n\t\treturn true;\n\t}\n\n\tprivate statLinkIfNeeded(path: string, lstat: fs.Stats, clb: (error: Error | null, stat: fs.Stats) => void): void {\n\t\tif (lstat.isSymbolicLink()) {\n\t\t\treturn fs.stat(path, clb); // stat the target the link points to\n\t\t}\n\n\t\treturn clb(null, lstat); // not a link, so the stat is already ok for us\n\t}\n\n\tprivate realPathIfNeeded(path: string, lstat: fs.Stats, clb: (error: Error | null, realpath?: string) => void): void {\n\t\tif (lstat.isSymbolicLink()) {\n\t\t\treturn fs.realpath(path, (error, realpath) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treturn clb(error);\n\t\t\t\t}\n\n\t\t\t\treturn clb(null, realpath);\n\t\t\t});\n\t\t}\n\n\t\treturn clb(null, path);\n\t}\n\n\t/**\n\t * If we're searching for files in multiple workspace folders, then better prepend the\n\t * name of the workspace folder to the path of the file. This way we'll be able to\n\t * better filter files that are all on the top of a workspace folder and have all the\n\t * same name. A typical example are `package.json` or `README.md` files.\n\t */\n\tprivate getSearchPath(folderQuery: IFolderQuery, relativePath: string): string {\n\t\tif (folderQuery.folderName) {\n\t\t\treturn path.join(folderQuery.folderName, relativePath);\n\t\t}\n\t\treturn relativePath;\n\t}\n}\n\nexport class Engine implements ISearchEngine<IRawFileMatch> {\n\tprivate folderQueries: IFolderQuery[];\n\tprivate extraFiles: URI[];\n\tprivate walker: FileWalker;\n\tprivate numThreads?: number;\n\n\tconstructor(config: IFileQuery, numThreads?: number) {\n\t\tthis.folderQueries = config.folderQueries;\n\t\tthis.extraFiles = config.extraFileResources || [];\n\t\tthis.numThreads = numThreads;\n\n\t\tthis.walker = new FileWalker(config);\n\t}\n\n\tsearch(onResult: (result: IRawFileMatch) => void, onProgress: (progress: IProgressMessage) => void, done: (error: Error | null, complete: ISearchEngineSuccess) => void): void {\n\t\tthis.walker.walk(this.folderQueries, this.extraFiles, this.numThreads, onResult, onProgress, (err: Error | null, isLimitHit: boolean) => {\n\t\t\tdone(err, {\n\t\t\t\tlimitHit: isLimitHit,\n\t\t\t\tstats: this.walker.getStats(),\n\t\t\t\tmessages: [],\n\t\t\t});\n\t\t});\n\t}\n\n\tcancel(): void {\n\t\tthis.walker.cancel();\n\t}\n}\n\n/**\n * This class exists to provide one interface on top of two ParsedExpressions, one for absolute expressions and one for relative expressions.\n * The absolute and relative expressions don't \"have\" to be kept separate, but this keeps us from having to path.join every single\n * file searched, it's only used for a text search with a searchPath\n */\nclass AbsoluteAndRelativeParsedExpression {\n\tprivate absoluteParsedExpr: glob.ParsedExpression | undefined;\n\tprivate relativeParsedExpr: glob.ParsedExpression | undefined;\n\n\tconstructor(public expression: glob.IExpression, private root: string) {\n\t\tthis.init(expression);\n\t}\n\n\t/**\n\t * Split the IExpression into its absolute and relative components, and glob.parse them separately.\n\t */\n\tprivate init(expr: glob.IExpression): void {\n\t\tlet absoluteGlobExpr: glob.IExpression | undefined;\n\t\tlet relativeGlobExpr: glob.IExpression | undefined;\n\t\tObject.keys(expr)\n\t\t\t.filter(key => expr[key])\n\t\t\t.forEach(key => {\n\t\t\t\tif (path.isAbsolute(key)) {\n\t\t\t\t\tabsoluteGlobExpr = absoluteGlobExpr || glob.getEmptyExpression();\n\t\t\t\t\tabsoluteGlobExpr[key] = expr[key];\n\t\t\t\t} else {\n\t\t\t\t\trelativeGlobExpr = relativeGlobExpr || glob.getEmptyExpression();\n\t\t\t\t\trelativeGlobExpr[key] = expr[key];\n\t\t\t\t}\n\t\t\t});\n\n\t\tthis.absoluteParsedExpr = absoluteGlobExpr && glob.parse(absoluteGlobExpr, { trimForExclusions: true });\n\t\tthis.relativeParsedExpr = relativeGlobExpr && glob.parse(relativeGlobExpr, { trimForExclusions: true });\n\t}\n\n\ttest(_path: string, basename?: string, hasSibling?: (name: string) => boolean | Promise<boolean>): string | Promise<string | null> | undefined | null {\n\t\treturn (this.relativeParsedExpr && this.relativeParsedExpr(_path, basename, hasSibling)) ||\n\t\t\t(this.absoluteParsedExpr && this.absoluteParsedExpr(path.join(this.root, _path), basename, hasSibling));\n\t}\n\n\tgetBasenameTerms(): string[] {\n\t\tconst basenameTerms: string[] = [];\n\t\tif (this.absoluteParsedExpr) {\n\t\t\tbasenameTerms.push(...glob.getBasenameTerms(this.absoluteParsedExpr));\n\t\t}\n\n\t\tif (this.relativeParsedExpr) {\n\t\t\tbasenameTerms.push(...glob.getBasenameTerms(this.relativeParsedExpr));\n\t\t}\n\n\t\treturn basenameTerms;\n\t}\n\n\tgetPathTerms(): string[] {\n\t\tconst pathTerms: string[] = [];\n\t\tif (this.absoluteParsedExpr) {\n\t\t\tpathTerms.push(...glob.getPathTerms(this.absoluteParsedExpr));\n\t\t}\n\n\t\tif (this.relativeParsedExpr) {\n\t\t\tpathTerms.push(...glob.getPathTerms(this.relativeParsedExpr));\n\t\t}\n\n\t\treturn pathTerms;\n\t}\n}\n\nfunction rgErrorMsgForDisplay(msg: string): string | undefined {\n\tconst lines = msg.trim().split('\\n');\n\tconst firstLine = lines[0].trim();\n\n\tif (firstLine.startsWith('Error parsing regex')) {\n\t\treturn firstLine;\n\t}\n\n\tif (firstLine.startsWith('regex parse error')) {\n\t\treturn strings.uppercaseFirstLetter(lines[lines.length - 1].trim());\n\t}\n\n\tif (firstLine.startsWith('error parsing glob') ||\n\t\tfirstLine.startsWith('unsupported encoding')) {\n\t\t// Uppercase first letter\n\t\treturn firstLine.charAt(0).toUpperCase() + firstLine.substr(1);\n\t}\n\n\tif (firstLine === `Literal '\\\\n' not allowed.`) {\n\t\t// I won't localize this because none of the Ripgrep error messages are localized\n\t\treturn `Literal '\\\\n' currently not supported`;\n\t}\n\n\tif (firstLine.startsWith('Literal ')) {\n\t\t// Other unsupported chars\n\t\treturn firstLine;\n\t}\n\n\treturn undefined;\n}\n"],
  "mappings": "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",
  "names": ["path", "error"]
}
