{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/search/node/ripgrepTextSearchEngine.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as cp from 'child_process';\nimport { EventEmitter } from 'events';\nimport { StringDecoder } from 'string_decoder';\nimport { coalesce, mapArrayOrNot } from '../../../../base/common/arrays.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { groupBy } from '../../../../base/common/collections.js';\nimport { splitGlobAware } from '../../../../base/common/glob.js';\nimport { createRegExp, escapeRegExpCharacters } from '../../../../base/common/strings.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { Progress } from '../../../../platform/progress/common/progress.js';\nimport { DEFAULT_MAX_SEARCH_RESULTS, IExtendedExtensionSearchOptions, ITextSearchPreviewOptions, SearchError, SearchErrorCode, serializeSearchError, TextSearchMatch } from '../common/search.js';\nimport { Range, TextSearchCompleteNew, TextSearchContextNew, TextSearchMatchNew, TextSearchProviderOptions, TextSearchQueryNew, TextSearchResultNew } from '../common/searchExtTypes.js';\nimport { AST as ReAST, RegExpParser, RegExpVisitor } from 'vscode-regexpp';\nimport { rgPath } from '@vscode/ripgrep';\nimport { anchorGlob, IOutputChannel, Maybe, rangeToSearchRange, searchRangeToRange } from './ripgrepSearchUtils.js';\nimport type { RipgrepTextSearchOptions } from '../common/searchExtTypesInternal.js';\nimport { newToOldPreviewOptions } from '../common/searchExtConversionTypes.js';\n\n// If @vscode/ripgrep is in an .asar file, then the binary is unpacked.\nconst rgDiskPath = rgPath.replace(/\\bnode_modules\\.asar\\b/, 'node_modules.asar.unpacked');\n\nexport class RipgrepTextSearchEngine {\n\n\tconstructor(private outputChannel: IOutputChannel, private readonly _numThreads?: number | undefined) { }\n\n\tprovideTextSearchResults(query: TextSearchQueryNew, options: TextSearchProviderOptions, progress: Progress<TextSearchResultNew>, token: CancellationToken): Promise<TextSearchCompleteNew> {\n\t\treturn Promise.all(options.folderOptions.map(folderOption => {\n\t\t\tconst extendedOptions: RipgrepTextSearchOptions = {\n\t\t\t\tfolderOptions: folderOption,\n\t\t\t\tnumThreads: this._numThreads,\n\t\t\t\tmaxResults: options.maxResults,\n\t\t\t\tpreviewOptions: options.previewOptions,\n\t\t\t\tmaxFileSize: options.maxFileSize,\n\t\t\t\tsurroundingContext: options.surroundingContext\n\t\t\t};\n\t\t\treturn this.provideTextSearchResultsWithRgOptions(query, extendedOptions, progress, token);\n\t\t})).then((e => {\n\t\t\tconst complete: TextSearchCompleteNew = {\n\t\t\t\t// todo: get this to actually check\n\t\t\t\tlimitHit: e.some(complete => !!complete && complete.limitHit)\n\t\t\t};\n\t\t\treturn complete;\n\t\t}));\n\t}\n\n\tprovideTextSearchResultsWithRgOptions(query: TextSearchQueryNew, options: RipgrepTextSearchOptions, progress: Progress<TextSearchResultNew>, token: CancellationToken): Promise<TextSearchCompleteNew> {\n\t\tthis.outputChannel.appendLine(`provideTextSearchResults ${query.pattern}, ${JSON.stringify({\n\t\t\t...options,\n\t\t\t...{\n\t\t\t\tfolder: options.folderOptions.folder.toString()\n\t\t\t}\n\t\t})}`);\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\ttoken.onCancellationRequested(() => cancel());\n\n\t\t\tconst extendedOptions: RipgrepTextSearchOptions = {\n\t\t\t\t...options,\n\t\t\t\tnumThreads: this._numThreads\n\t\t\t};\n\t\t\tconst rgArgs = getRgArgs(query, extendedOptions);\n\n\t\t\tconst cwd = options.folderOptions.folder.fsPath;\n\n\t\t\tconst escapedArgs = rgArgs\n\t\t\t\t.map(arg => arg.match(/^-/) ? arg : `'${arg}'`)\n\t\t\t\t.join(' ');\n\t\t\tthis.outputChannel.appendLine(`${rgDiskPath} ${escapedArgs}\\n - cwd: ${cwd}`);\n\n\t\t\tlet rgProc: Maybe<cp.ChildProcess> = cp.spawn(rgDiskPath, rgArgs, { cwd });\n\t\t\trgProc.on('error', e => {\n\t\t\t\tconsole.error(e);\n\t\t\t\tthis.outputChannel.appendLine('Error: ' + (e && e.message));\n\t\t\t\treject(serializeSearchError(new SearchError(e && e.message, SearchErrorCode.rgProcessError)));\n\t\t\t});\n\n\t\t\tlet gotResult = false;\n\t\t\tconst ripgrepParser = new RipgrepParser(options.maxResults ?? DEFAULT_MAX_SEARCH_RESULTS, options.folderOptions.folder, newToOldPreviewOptions(options.previewOptions));\n\t\t\tripgrepParser.on('result', (match: TextSearchResultNew) => {\n\t\t\t\tgotResult = true;\n\t\t\t\tdataWithoutResult = '';\n\t\t\t\tprogress.report(match);\n\t\t\t});\n\n\t\t\tlet isDone = false;\n\t\t\tconst cancel = () => {\n\t\t\t\tisDone = true;\n\n\t\t\t\trgProc?.kill();\n\n\t\t\t\tripgrepParser?.cancel();\n\t\t\t};\n\n\t\t\tlet limitHit = false;\n\t\t\tripgrepParser.on('hitLimit', () => {\n\t\t\t\tlimitHit = true;\n\t\t\t\tcancel();\n\t\t\t});\n\n\t\t\tlet dataWithoutResult = '';\n\t\t\trgProc.stdout!.on('data', data => {\n\t\t\t\tripgrepParser.handleData(data);\n\t\t\t\tif (!gotResult) {\n\t\t\t\t\tdataWithoutResult += data;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tlet gotData = false;\n\t\t\trgProc.stdout!.once('data', () => gotData = true);\n\n\t\t\tlet stderr = '';\n\t\t\trgProc.stderr!.on('data', data => {\n\t\t\t\tconst message = data.toString();\n\t\t\t\tthis.outputChannel.appendLine(message);\n\n\t\t\t\tif (stderr.length + message.length < 1e6) {\n\t\t\t\t\tstderr += message;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\trgProc.on('close', () => {\n\t\t\t\tthis.outputChannel.appendLine(gotData ? 'Got data from stdout' : 'No data from stdout');\n\t\t\t\tthis.outputChannel.appendLine(gotResult ? 'Got result from parser' : 'No result from parser');\n\t\t\t\tif (dataWithoutResult) {\n\t\t\t\t\tthis.outputChannel.appendLine(`Got data without result: ${dataWithoutResult}`);\n\t\t\t\t}\n\n\t\t\t\tthis.outputChannel.appendLine('');\n\n\t\t\t\tif (isDone) {\n\t\t\t\t\tresolve({ limitHit });\n\t\t\t\t} else {\n\t\t\t\t\t// Trigger last result\n\t\t\t\t\tripgrepParser.flush();\n\t\t\t\t\trgProc = null;\n\t\t\t\t\tlet searchError: Maybe<SearchError>;\n\t\t\t\t\tif (stderr && !gotData && (searchError = rgErrorMsgForDisplay(stderr))) {\n\t\t\t\t\t\treject(serializeSearchError(new SearchError(searchError.message, searchError.code)));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve({ limitHit });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n}\n\n/**\n * Read the first line of stderr and return an error for display or undefined, based on a list of\n * allowed properties.\n * Ripgrep produces stderr output which is not from a fatal error, and we only want the search to be\n * \"failed\" when a fatal error was produced.\n */\nfunction rgErrorMsgForDisplay(msg: string): Maybe<SearchError> {\n\tconst lines = msg.split('\\n');\n\tconst firstLine = lines[0].trim();\n\n\tif (lines.some(l => l.startsWith('regex parse error'))) {\n\t\treturn new SearchError(buildRegexParseError(lines), SearchErrorCode.regexParseError);\n\t}\n\n\tconst match = firstLine.match(/grep config error: unknown encoding: (.*)/);\n\tif (match) {\n\t\treturn new SearchError(`Unknown encoding: ${match[1]}`, SearchErrorCode.unknownEncoding);\n\t}\n\n\tif (firstLine.startsWith('error parsing glob')) {\n\t\t// Uppercase first letter\n\t\treturn new SearchError(firstLine.charAt(0).toUpperCase() + firstLine.substr(1), SearchErrorCode.globParseError);\n\t}\n\n\tif (firstLine.startsWith('the literal')) {\n\t\t// Uppercase first letter\n\t\treturn new SearchError(firstLine.charAt(0).toUpperCase() + firstLine.substr(1), SearchErrorCode.invalidLiteral);\n\t}\n\n\tif (firstLine.startsWith('PCRE2: error compiling pattern')) {\n\t\treturn new SearchError(firstLine, SearchErrorCode.regexParseError);\n\t}\n\n\treturn undefined;\n}\n\nfunction buildRegexParseError(lines: string[]): string {\n\tconst errorMessage: string[] = ['Regex parse error'];\n\tconst pcre2ErrorLine = lines.filter(l => (l.startsWith('PCRE2:')));\n\tif (pcre2ErrorLine.length >= 1) {\n\t\tconst pcre2ErrorMessage = pcre2ErrorLine[0].replace('PCRE2:', '');\n\t\tif (pcre2ErrorMessage.indexOf(':') !== -1 && pcre2ErrorMessage.split(':').length >= 2) {\n\t\t\tconst pcre2ActualErrorMessage = pcre2ErrorMessage.split(':')[1];\n\t\t\terrorMessage.push(':' + pcre2ActualErrorMessage);\n\t\t}\n\t}\n\n\treturn errorMessage.join('');\n}\n\n\nexport class RipgrepParser extends EventEmitter {\n\tprivate remainder = '';\n\tprivate isDone = false;\n\tprivate hitLimit = false;\n\tprivate stringDecoder: StringDecoder;\n\n\tprivate numResults = 0;\n\n\tconstructor(private maxResults: number, private root: URI, private previewOptions: ITextSearchPreviewOptions) {\n\t\tsuper();\n\t\tthis.stringDecoder = new StringDecoder();\n\t}\n\n\tcancel(): void {\n\t\tthis.isDone = true;\n\t}\n\n\tflush(): void {\n\t\tthis.handleDecodedData(this.stringDecoder.end());\n\t}\n\n\n\toverride on(event: 'result', listener: (result: TextSearchResultNew) => void): this;\n\toverride on(event: 'hitLimit', listener: () => void): this;\n\toverride on(event: string, listener: (...args: any[]) => void): this {\n\t\tsuper.on(event, listener);\n\t\treturn this;\n\t}\n\n\thandleData(data: Buffer | string): void {\n\t\tif (this.isDone) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst dataStr = typeof data === 'string' ? data : this.stringDecoder.write(data);\n\t\tthis.handleDecodedData(dataStr);\n\t}\n\n\tprivate handleDecodedData(decodedData: string): void {\n\t\t// check for newline before appending to remainder\n\t\tlet newlineIdx = decodedData.indexOf('\\n');\n\n\t\t// If the previous data chunk didn't end in a newline, prepend it to this chunk\n\t\tconst dataStr = this.remainder + decodedData;\n\n\t\tif (newlineIdx >= 0) {\n\t\t\tnewlineIdx += this.remainder.length;\n\t\t} else {\n\t\t\t// Shortcut\n\t\t\tthis.remainder = dataStr;\n\t\t\treturn;\n\t\t}\n\n\t\tlet prevIdx = 0;\n\t\twhile (newlineIdx >= 0) {\n\t\t\tthis.handleLine(dataStr.substring(prevIdx, newlineIdx).trim());\n\t\t\tprevIdx = newlineIdx + 1;\n\t\t\tnewlineIdx = dataStr.indexOf('\\n', prevIdx);\n\t\t}\n\n\t\tthis.remainder = dataStr.substring(prevIdx);\n\t}\n\n\n\tprivate handleLine(outputLine: string): void {\n\t\tif (this.isDone || !outputLine) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet parsedLine: IRgMessage;\n\t\ttry {\n\t\t\tparsedLine = JSON.parse(outputLine);\n\t\t} catch (e) {\n\t\t\tthrow new Error(`malformed line from rg: ${outputLine}`);\n\t\t}\n\n\t\tif (parsedLine.type === 'match') {\n\t\t\tconst matchPath = bytesOrTextToString(parsedLine.data.path);\n\t\t\tconst uri = URI.joinPath(this.root, matchPath);\n\t\t\tconst result = this.createTextSearchMatch(parsedLine.data, uri);\n\t\t\tthis.onResult(result);\n\n\t\t\tif (this.hitLimit) {\n\t\t\t\tthis.cancel();\n\t\t\t\tthis.emit('hitLimit');\n\t\t\t}\n\t\t} else if (parsedLine.type === 'context') {\n\t\t\tconst contextPath = bytesOrTextToString(parsedLine.data.path);\n\t\t\tconst uri = URI.joinPath(this.root, contextPath);\n\t\t\tconst result = this.createTextSearchContexts(parsedLine.data, uri);\n\t\t\tresult.forEach(r => this.onResult(r));\n\t\t}\n\t}\n\n\tprivate createTextSearchMatch(data: IRgMatch, uri: URI): TextSearchMatchNew {\n\t\tconst lineNumber = data.line_number - 1;\n\t\tconst fullText = bytesOrTextToString(data.lines);\n\t\tconst fullTextBytes = Buffer.from(fullText);\n\n\t\tlet prevMatchEnd = 0;\n\t\tlet prevMatchEndCol = 0;\n\t\tlet prevMatchEndLine = lineNumber;\n\n\t\t// it looks like certain regexes can match a line, but cause rg to not\n\t\t// emit any specific submatches for that line.\n\t\t// https://github.com/microsoft/vscode/issues/100569#issuecomment-738496991\n\t\tif (data.submatches.length === 0) {\n\t\t\tdata.submatches.push(\n\t\t\t\tfullText.length\n\t\t\t\t\t? { start: 0, end: 1, match: { text: fullText[0] } }\n\t\t\t\t\t: { start: 0, end: 0, match: { text: '' } }\n\t\t\t);\n\t\t}\n\n\t\tconst ranges = coalesce(data.submatches.map((match, i) => {\n\t\t\tif (this.hitLimit) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tthis.numResults++;\n\t\t\tif (this.numResults >= this.maxResults) {\n\t\t\t\t// Finish the line, then report the result below\n\t\t\t\tthis.hitLimit = true;\n\t\t\t}\n\n\t\t\tconst matchText = bytesOrTextToString(match.match);\n\n\t\t\tconst inBetweenText = fullTextBytes.slice(prevMatchEnd, match.start).toString();\n\t\t\tconst inBetweenStats = getNumLinesAndLastNewlineLength(inBetweenText);\n\t\t\tconst startCol = inBetweenStats.numLines > 0 ?\n\t\t\t\tinBetweenStats.lastLineLength :\n\t\t\t\tinBetweenStats.lastLineLength + prevMatchEndCol;\n\n\t\t\tconst stats = getNumLinesAndLastNewlineLength(matchText);\n\t\t\tconst startLineNumber = inBetweenStats.numLines + prevMatchEndLine;\n\t\t\tconst endLineNumber = stats.numLines + startLineNumber;\n\t\t\tconst endCol = stats.numLines > 0 ?\n\t\t\t\tstats.lastLineLength :\n\t\t\t\tstats.lastLineLength + startCol;\n\n\t\t\tprevMatchEnd = match.end;\n\t\t\tprevMatchEndCol = endCol;\n\t\t\tprevMatchEndLine = endLineNumber;\n\n\t\t\treturn new Range(startLineNumber, startCol, endLineNumber, endCol);\n\t\t}));\n\n\t\tconst searchRange = mapArrayOrNot(<Range[]>ranges, rangeToSearchRange);\n\n\t\tconst internalResult = new TextSearchMatch(fullText, searchRange, this.previewOptions);\n\t\treturn new TextSearchMatchNew(\n\t\t\turi,\n\t\t\tinternalResult.rangeLocations.map(e => (\n\t\t\t\t{\n\t\t\t\t\tsourceRange: searchRangeToRange(e.source),\n\t\t\t\t\tpreviewRange: searchRangeToRange(e.preview),\n\t\t\t\t}\n\t\t\t)),\n\t\t\tinternalResult.previewText);\n\t}\n\n\tprivate createTextSearchContexts(data: IRgMatch, uri: URI): TextSearchContextNew[] {\n\t\tconst text = bytesOrTextToString(data.lines);\n\t\tconst startLine = data.line_number;\n\t\treturn text\n\t\t\t.replace(/\\r?\\n$/, '')\n\t\t\t.split('\\n')\n\t\t\t.map((line, i) => new TextSearchContextNew(uri, line, startLine + i));\n\t}\n\n\tprivate onResult(match: TextSearchResultNew): void {\n\t\tthis.emit('result', match);\n\t}\n}\n\nfunction bytesOrTextToString(obj: any): string {\n\treturn obj.bytes ?\n\t\tBuffer.from(obj.bytes, 'base64').toString() :\n\t\tobj.text;\n}\n\nfunction getNumLinesAndLastNewlineLength(text: string): { numLines: number; lastLineLength: number } {\n\tconst re = /\\n/g;\n\tlet numLines = 0;\n\tlet lastNewlineIdx = -1;\n\tlet match: ReturnType<typeof re.exec>;\n\twhile (match = re.exec(text)) {\n\t\tnumLines++;\n\t\tlastNewlineIdx = match.index;\n\t}\n\n\tconst lastLineLength = lastNewlineIdx >= 0 ?\n\t\ttext.length - lastNewlineIdx - 1 :\n\t\ttext.length;\n\n\treturn { numLines, lastLineLength };\n}\n\n// exported for testing\nexport function getRgArgs(query: TextSearchQueryNew, options: RipgrepTextSearchOptions): string[] {\n\tconst args = ['--hidden', '--no-require-git'];\n\targs.push(query.isCaseSensitive ? '--case-sensitive' : '--ignore-case');\n\n\tconst { doubleStarIncludes, otherIncludes } = groupBy(\n\t\toptions.folderOptions.includes,\n\t\t(include: string) => include.startsWith('**') ? 'doubleStarIncludes' : 'otherIncludes');\n\n\tif (otherIncludes && otherIncludes.length) {\n\t\tconst uniqueOthers = new Set<string>();\n\t\totherIncludes.forEach(other => { uniqueOthers.add(other); });\n\n\t\targs.push('-g', '!*');\n\t\tuniqueOthers\n\t\t\t.forEach(otherIncude => {\n\t\t\t\tspreadGlobComponents(otherIncude)\n\t\t\t\t\t.map(anchorGlob)\n\t\t\t\t\t.forEach(globArg => {\n\t\t\t\t\t\targs.push('-g', globArg);\n\t\t\t\t\t});\n\t\t\t});\n\t}\n\n\tif (doubleStarIncludes && doubleStarIncludes.length) {\n\t\tdoubleStarIncludes.forEach(globArg => {\n\t\t\targs.push('-g', globArg);\n\t\t});\n\t}\n\n\toptions.folderOptions.excludes.map(e => typeof (e) === 'string' ? e : e.pattern)\n\t\t.map(anchorGlob)\n\t\t.forEach(rgGlob => args.push('-g', `!${rgGlob}`));\n\n\tif (options.maxFileSize) {\n\t\targs.push('--max-filesize', options.maxFileSize + '');\n\t}\n\n\tif (options.folderOptions.useIgnoreFiles.local) {\n\t\tif (!options.folderOptions.useIgnoreFiles.parent) {\n\t\t\targs.push('--no-ignore-parent');\n\t\t}\n\t} else {\n\t\t// Don't use .gitignore or .ignore\n\t\targs.push('--no-ignore');\n\t}\n\n\tif (options.folderOptions.followSymlinks) {\n\t\targs.push('--follow');\n\t}\n\n\tif (options.folderOptions.encoding && options.folderOptions.encoding !== 'utf8') {\n\t\targs.push('--encoding', options.folderOptions.encoding);\n\t}\n\n\tif (options.numThreads) {\n\t\targs.push('--threads', `${options.numThreads}`);\n\t}\n\n\t// Ripgrep handles -- as a -- arg separator. Only --.\n\t// - is ok, --- is ok, --some-flag is also ok. Need to special case.\n\tif (query.pattern === '--') {\n\t\tquery.isRegExp = true;\n\t\tquery.pattern = '\\\\-\\\\-';\n\t}\n\n\tif (query.isMultiline && !query.isRegExp) {\n\t\tquery.pattern = escapeRegExpCharacters(query.pattern);\n\t\tquery.isRegExp = true;\n\t}\n\n\tif ((<IExtendedExtensionSearchOptions>options).usePCRE2) {\n\t\targs.push('--pcre2');\n\t}\n\n\t// Allow $ to match /r/n\n\targs.push('--crlf');\n\n\tif (query.isRegExp) {\n\t\tquery.pattern = unicodeEscapesToPCRE2(query.pattern);\n\t\targs.push('--engine', 'auto');\n\t}\n\n\tlet searchPatternAfterDoubleDashes: Maybe<string>;\n\tif (query.isWordMatch) {\n\t\tconst regexp = createRegExp(query.pattern, !!query.isRegExp, { wholeWord: query.isWordMatch });\n\t\tconst regexpStr = regexp.source.replace(/\\\\\\//g, '/'); // RegExp.source arbitrarily returns escaped slashes. Search and destroy.\n\t\targs.push('--regexp', regexpStr);\n\t} else if (query.isRegExp) {\n\t\tlet fixedRegexpQuery = fixRegexNewline(query.pattern);\n\t\tfixedRegexpQuery = fixNewline(fixedRegexpQuery);\n\t\targs.push('--regexp', fixedRegexpQuery);\n\t} else {\n\t\tsearchPatternAfterDoubleDashes = query.pattern;\n\t\targs.push('--fixed-strings');\n\t}\n\n\targs.push('--no-config');\n\tif (!options.folderOptions.useIgnoreFiles.global) {\n\t\targs.push('--no-ignore-global');\n\t}\n\n\targs.push('--json');\n\n\tif (query.isMultiline) {\n\t\targs.push('--multiline');\n\t}\n\n\tif (options.surroundingContext) {\n\t\targs.push('--before-context', options.surroundingContext + '');\n\t\targs.push('--after-context', options.surroundingContext + '');\n\t}\n\n\t// Folder to search\n\targs.push('--');\n\n\tif (searchPatternAfterDoubleDashes) {\n\t\t// Put the query after --, in case the query starts with a dash\n\t\targs.push(searchPatternAfterDoubleDashes);\n\t}\n\n\targs.push('.');\n\n\treturn args;\n}\n\n/**\n * `\"foo/*bar/something\"` -> `[\"foo\", \"foo/*bar\", \"foo/*bar/something\", \"foo/*bar/something/**\"]`\n */\nfunction spreadGlobComponents(globComponent: string): string[] {\n\tconst globComponentWithBraceExpansion = performBraceExpansionForRipgrep(globComponent);\n\n\treturn globComponentWithBraceExpansion.flatMap((globArg) => {\n\t\tconst components = splitGlobAware(globArg, '/');\n\t\treturn components.map((_, i) => components.slice(0, i + 1).join('/'));\n\t});\n\n}\n\nexport function unicodeEscapesToPCRE2(pattern: string): string {\n\t// Match \\u1234\n\tconst unicodePattern = /((?:[^\\\\]|^)(?:\\\\\\\\)*)\\\\u([a-z0-9]{4})/gi;\n\n\twhile (pattern.match(unicodePattern)) {\n\t\tpattern = pattern.replace(unicodePattern, `$1\\\\x{$2}`);\n\t}\n\n\t// Match \\u{1234}\n\t// \\u with 5-6 characters will be left alone because \\x only takes 4 characters.\n\tconst unicodePatternWithBraces = /((?:[^\\\\]|^)(?:\\\\\\\\)*)\\\\u\\{([a-z0-9]{4})\\}/gi;\n\twhile (pattern.match(unicodePatternWithBraces)) {\n\t\tpattern = pattern.replace(unicodePatternWithBraces, `$1\\\\x{$2}`);\n\t}\n\n\treturn pattern;\n}\n\nexport interface IRgMessage {\n\ttype: 'match' | 'context' | string;\n\tdata: IRgMatch;\n}\n\nexport interface IRgMatch {\n\tpath: IRgBytesOrText;\n\tlines: IRgBytesOrText;\n\tline_number: number;\n\tabsolute_offset: number;\n\tsubmatches: IRgSubmatch[];\n}\n\nexport interface IRgSubmatch {\n\tmatch: IRgBytesOrText;\n\tstart: number;\n\tend: number;\n}\n\nexport type IRgBytesOrText = { bytes: string } | { text: string };\n\nconst isLookBehind = (node: ReAST.Node) => node.type === 'Assertion' && node.kind === 'lookbehind';\n\nexport function fixRegexNewline(pattern: string): string {\n\t// we parse the pattern anew each tiem\n\tlet re: ReAST.Pattern;\n\ttry {\n\t\tre = new RegExpParser().parsePattern(pattern);\n\t} catch {\n\t\treturn pattern;\n\t}\n\n\tlet output = '';\n\tlet lastEmittedIndex = 0;\n\tconst replace = (start: number, end: number, text: string) => {\n\t\toutput += pattern.slice(lastEmittedIndex, start) + text;\n\t\tlastEmittedIndex = end;\n\t};\n\n\tconst context: ReAST.Node[] = [];\n\tconst visitor = new RegExpVisitor({\n\t\tonCharacterEnter(char) {\n\t\t\tif (char.raw !== '\\\\n') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst parent = context[0];\n\t\t\tif (!parent) {\n\t\t\t\t// simple char, \\n -> \\r?\\n\n\t\t\t\treplace(char.start, char.end, '\\\\r?\\\\n');\n\t\t\t} else if (context.some(isLookBehind)) {\n\t\t\t\t// no-op in a lookbehind, see #100569\n\t\t\t} else if (parent.type === 'CharacterClass') {\n\t\t\t\tif (parent.negate) {\n\t\t\t\t\t// negative bracket expr, [^a-z\\n] -> (?![a-z]|\\r?\\n)\n\t\t\t\t\tconst otherContent = pattern.slice(parent.start + 2, char.start) + pattern.slice(char.end, parent.end - 1);\n\t\t\t\t\tif (parent.parent?.type === 'Quantifier') {\n\t\t\t\t\t\t// If quantified, we can't use a negative lookahead in a quantifier.\n\t\t\t\t\t\t// But `.` already doesn't match new lines, so we can just use that\n\t\t\t\t\t\t// (with any other negations) instead.\n\t\t\t\t\t\treplace(parent.start, parent.end, otherContent ? `[^${otherContent}]` : '.');\n\t\t\t\t\t} else {\n\t\t\t\t\t\treplace(parent.start, parent.end, '(?!\\\\r?\\\\n' + (otherContent ? `|[${otherContent}]` : '') + ')');\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// positive bracket expr, [a-z\\n] -> (?:[a-z]|\\r?\\n)\n\t\t\t\t\tconst otherContent = pattern.slice(parent.start + 1, char.start) + pattern.slice(char.end, parent.end - 1);\n\t\t\t\t\treplace(parent.start, parent.end, otherContent === '' ? '\\\\r?\\\\n' : `(?:[${otherContent}]|\\\\r?\\\\n)`);\n\t\t\t\t}\n\t\t\t} else if (parent.type === 'Quantifier') {\n\t\t\t\treplace(char.start, char.end, '(?:\\\\r?\\\\n)');\n\t\t\t}\n\t\t},\n\t\tonQuantifierEnter(node) {\n\t\t\tcontext.unshift(node);\n\t\t},\n\t\tonQuantifierLeave() {\n\t\t\tcontext.shift();\n\t\t},\n\t\tonCharacterClassRangeEnter(node) {\n\t\t\tcontext.unshift(node);\n\t\t},\n\t\tonCharacterClassRangeLeave() {\n\t\t\tcontext.shift();\n\t\t},\n\t\tonCharacterClassEnter(node) {\n\t\t\tcontext.unshift(node);\n\t\t},\n\t\tonCharacterClassLeave() {\n\t\t\tcontext.shift();\n\t\t},\n\t\tonAssertionEnter(node) {\n\t\t\tif (isLookBehind(node)) {\n\t\t\t\tcontext.push(node);\n\t\t\t}\n\t\t},\n\t\tonAssertionLeave(node) {\n\t\t\tif (context[0] === node) {\n\t\t\t\tcontext.shift();\n\t\t\t}\n\t\t},\n\t});\n\n\tvisitor.visit(re);\n\toutput += pattern.slice(lastEmittedIndex);\n\treturn output;\n}\n\nexport function fixNewline(pattern: string): string {\n\treturn pattern.replace(/\\n/g, '\\\\r?\\\\n');\n}\n\n// brace expansion for ripgrep\n\n/**\n * Split string given first opportunity for brace expansion in the string.\n * - If the brace is prepended by a \\ character, then it is escaped.\n * - Does not process escapes that are within the sub-glob.\n * - If two unescaped `{` occur before `}`, then ripgrep will return an error for brace nesting, so don't split on those.\n */\nfunction getEscapeAwareSplitStringForRipgrep(pattern: string): { fixedStart?: string; strInBraces: string; fixedEnd?: string } {\n\tlet inBraces = false;\n\tlet escaped = false;\n\tlet fixedStart = '';\n\tlet strInBraces = '';\n\tfor (let i = 0; i < pattern.length; i++) {\n\t\tconst char = pattern[i];\n\t\tswitch (char) {\n\t\t\tcase '\\\\':\n\t\t\t\tif (escaped) {\n\t\t\t\t\t// If we're already escaped, then just leave the escaped slash and the preceeding slash that escapes it.\n\t\t\t\t\t// The two escaped slashes will result in a single slash and whatever processes the glob later will properly process the escape\n\t\t\t\t\tif (inBraces) {\n\t\t\t\t\t\tstrInBraces += '\\\\' + char;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfixedStart += '\\\\' + char;\n\t\t\t\t\t}\n\t\t\t\t\tescaped = false;\n\t\t\t\t} else {\n\t\t\t\t\tescaped = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '{':\n\t\t\t\tif (escaped) {\n\t\t\t\t\t// if we escaped this opening bracket, then it is to be taken literally. Remove the `\\` because we've acknowleged it and add the `{` to the appropriate string\n\t\t\t\t\tif (inBraces) {\n\t\t\t\t\t\tstrInBraces += char;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfixedStart += char;\n\t\t\t\t\t}\n\t\t\t\t\tescaped = false;\n\t\t\t\t} else {\n\t\t\t\t\tif (inBraces) {\n\t\t\t\t\t\t// ripgrep treats this as attempting to do a nested alternate group, which is invalid. Return with pattern including changes from escaped braces.\n\t\t\t\t\t\treturn { strInBraces: fixedStart + '{' + strInBraces + '{' + pattern.substring(i + 1) };\n\t\t\t\t\t} else {\n\t\t\t\t\t\tinBraces = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '}':\n\t\t\t\tif (escaped) {\n\t\t\t\t\t// same as `}`, but for closing bracket\n\t\t\t\t\tif (inBraces) {\n\t\t\t\t\t\tstrInBraces += char;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfixedStart += char;\n\t\t\t\t\t}\n\t\t\t\t\tescaped = false;\n\t\t\t\t} else if (inBraces) {\n\t\t\t\t\t// we found an end bracket to a valid opening bracket. Return the appropriate strings.\n\t\t\t\t\treturn { fixedStart, strInBraces, fixedEnd: pattern.substring(i + 1) };\n\t\t\t\t} else {\n\t\t\t\t\t// if we're not in braces and not escaped, then this is a literal `}` character and we're still adding to fixedStart.\n\t\t\t\t\tfixedStart += char;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// similar to the `\\\\` case, we didn't do anything with the escape, so we should re-insert it into the appropriate string\n\t\t\t\t// to be consumed later when individual parts of the glob are processed\n\t\t\t\tif (inBraces) {\n\t\t\t\t\tstrInBraces += (escaped ? '\\\\' : '') + char;\n\t\t\t\t} else {\n\t\t\t\t\tfixedStart += (escaped ? '\\\\' : '') + char;\n\t\t\t\t}\n\t\t\t\tescaped = false;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\n\t// we are haven't hit the last brace, so no splitting should occur. Return with pattern including changes from escaped braces.\n\treturn { strInBraces: fixedStart + (inBraces ? ('{' + strInBraces) : '') };\n}\n\n/**\n * Parses out curly braces and returns equivalent globs. Only supports one level of nesting.\n * Exported for testing.\n */\nexport function performBraceExpansionForRipgrep(pattern: string): string[] {\n\tconst { fixedStart, strInBraces, fixedEnd } = getEscapeAwareSplitStringForRipgrep(pattern);\n\tif (fixedStart === undefined || fixedEnd === undefined) {\n\t\treturn [strInBraces];\n\t}\n\n\tlet arr = splitGlobAware(strInBraces, ',');\n\n\tif (!arr.length) {\n\t\t// occurs if the braces are empty.\n\t\tarr = [''];\n\t}\n\n\tconst ends = performBraceExpansionForRipgrep(fixedEnd);\n\n\treturn arr.flatMap((elem) => {\n\t\tconst start = fixedStart + elem;\n\t\treturn ends.map((end) => {\n\t\t\treturn start + end;\n\t\t});\n\t});\n}\n"],
  "mappings": "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",
  "names": ["complete"]
}
