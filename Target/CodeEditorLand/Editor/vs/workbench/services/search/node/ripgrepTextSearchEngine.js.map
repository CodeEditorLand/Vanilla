{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/search/node/ripgrepTextSearchEngine.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as cp from \"child_process\";\nimport { EventEmitter } from \"events\";\nimport { StringDecoder } from \"string_decoder\";\nimport { rgPath } from \"@vscode/ripgrep\";\nimport { type AST as ReAST, RegExpParser, RegExpVisitor } from \"vscode-regexpp\";\nimport { coalesce, mapArrayOrNot } from \"../../../../base/common/arrays.js\";\nimport type { CancellationToken } from \"../../../../base/common/cancellation.js\";\nimport { groupBy } from \"../../../../base/common/collections.js\";\nimport { splitGlobAware } from \"../../../../base/common/glob.js\";\nimport {\n\tcreateRegExp,\n\tescapeRegExpCharacters,\n} from \"../../../../base/common/strings.js\";\nimport { URI } from \"../../../../base/common/uri.js\";\nimport type { Progress } from \"../../../../platform/progress/common/progress.js\";\nimport {\n\tDEFAULT_MAX_SEARCH_RESULTS,\n\ttype IExtendedExtensionSearchOptions,\n\ttype ITextSearchPreviewOptions,\n\tSearchError,\n\tSearchErrorCode,\n\tTextSearchMatch,\n\tserializeSearchError,\n} from \"../common/search.js\";\nimport { newToOldPreviewOptions } from \"../common/searchExtConversionTypes.js\";\nimport {\n\tRange,\n\ttype TextSearchCompleteNew,\n\tTextSearchContextNew,\n\tTextSearchMatchNew,\n\ttype TextSearchProviderOptions,\n\ttype TextSearchQueryNew,\n\ttype TextSearchResultNew,\n} from \"../common/searchExtTypes.js\";\nimport type { RipgrepTextSearchOptions } from \"../common/searchExtTypesInternal.js\";\nimport {\n\ttype IOutputChannel,\n\ttype Maybe,\n\tanchorGlob,\n\trangeToSearchRange,\n\tsearchRangeToRange,\n} from \"./ripgrepSearchUtils.js\";\n\n// If @vscode/ripgrep is in an .asar file, then the binary is unpacked.\nconst rgDiskPath = rgPath.replace(\n\t/\\bnode_modules\\.asar\\b/,\n\t\"node_modules.asar.unpacked\",\n);\n\nexport class RipgrepTextSearchEngine {\n\tconstructor(\n\t\tprivate outputChannel: IOutputChannel,\n\t\tprivate readonly _numThreads?: number | undefined,\n\t) {}\n\n\tprovideTextSearchResults(\n\t\tquery: TextSearchQueryNew,\n\t\toptions: TextSearchProviderOptions,\n\t\tprogress: Progress<TextSearchResultNew>,\n\t\ttoken: CancellationToken,\n\t): Promise<TextSearchCompleteNew> {\n\t\treturn Promise.all(\n\t\t\toptions.folderOptions.map((folderOption) => {\n\t\t\t\tconst extendedOptions: RipgrepTextSearchOptions = {\n\t\t\t\t\tfolderOptions: folderOption,\n\t\t\t\t\tnumThreads: this._numThreads,\n\t\t\t\t\tmaxResults: options.maxResults,\n\t\t\t\t\tpreviewOptions: options.previewOptions,\n\t\t\t\t\tmaxFileSize: options.maxFileSize,\n\t\t\t\t\tsurroundingContext: options.surroundingContext,\n\t\t\t\t};\n\t\t\t\treturn this.provideTextSearchResultsWithRgOptions(\n\t\t\t\t\tquery,\n\t\t\t\t\textendedOptions,\n\t\t\t\t\tprogress,\n\t\t\t\t\ttoken,\n\t\t\t\t);\n\t\t\t}),\n\t\t).then((e) => {\n\t\t\tconst complete: TextSearchCompleteNew = {\n\t\t\t\t// todo: get this to actually check\n\t\t\t\tlimitHit: e.some((complete) => !!complete && complete.limitHit),\n\t\t\t};\n\t\t\treturn complete;\n\t\t});\n\t}\n\n\tprovideTextSearchResultsWithRgOptions(\n\t\tquery: TextSearchQueryNew,\n\t\toptions: RipgrepTextSearchOptions,\n\t\tprogress: Progress<TextSearchResultNew>,\n\t\ttoken: CancellationToken,\n\t): Promise<TextSearchCompleteNew> {\n\t\tthis.outputChannel.appendLine(\n\t\t\t`provideTextSearchResults ${query.pattern}, ${JSON.stringify({\n\t\t\t\t...options,\n\t\t\t\t...{\n\t\t\t\t\tfolder: options.folderOptions.folder.toString(),\n\t\t\t\t},\n\t\t\t})}`,\n\t\t);\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\ttoken.onCancellationRequested(() => cancel());\n\n\t\t\tconst extendedOptions: RipgrepTextSearchOptions = {\n\t\t\t\t...options,\n\t\t\t\tnumThreads: this._numThreads,\n\t\t\t};\n\t\t\tconst rgArgs = getRgArgs(query, extendedOptions);\n\n\t\t\tconst cwd = options.folderOptions.folder.fsPath;\n\n\t\t\tconst escapedArgs = rgArgs\n\t\t\t\t.map((arg) => (arg.match(/^-/) ? arg : `'${arg}'`))\n\t\t\t\t.join(\" \");\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`${rgDiskPath} ${escapedArgs}\\n - cwd: ${cwd}`,\n\t\t\t);\n\n\t\t\tlet rgProc: Maybe<cp.ChildProcess> = cp.spawn(rgDiskPath, rgArgs, {\n\t\t\t\tcwd,\n\t\t\t});\n\t\t\trgProc.on(\"error\", (e) => {\n\t\t\t\tconsole.error(e);\n\t\t\t\tthis.outputChannel.appendLine(\"Error: \" + (e && e.message));\n\t\t\t\treject(\n\t\t\t\t\tserializeSearchError(\n\t\t\t\t\t\tnew SearchError(\n\t\t\t\t\t\t\te && e.message,\n\t\t\t\t\t\t\tSearchErrorCode.rgProcessError,\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t});\n\n\t\t\tlet gotResult = false;\n\t\t\tconst ripgrepParser = new RipgrepParser(\n\t\t\t\toptions.maxResults ?? DEFAULT_MAX_SEARCH_RESULTS,\n\t\t\t\toptions.folderOptions.folder,\n\t\t\t\tnewToOldPreviewOptions(options.previewOptions),\n\t\t\t);\n\t\t\tripgrepParser.on(\"result\", (match: TextSearchResultNew) => {\n\t\t\t\tgotResult = true;\n\t\t\t\tdataWithoutResult = \"\";\n\t\t\t\tprogress.report(match);\n\t\t\t});\n\n\t\t\tlet isDone = false;\n\t\t\tconst cancel = () => {\n\t\t\t\tisDone = true;\n\n\t\t\t\trgProc?.kill();\n\n\t\t\t\tripgrepParser?.cancel();\n\t\t\t};\n\n\t\t\tlet limitHit = false;\n\t\t\tripgrepParser.on(\"hitLimit\", () => {\n\t\t\t\tlimitHit = true;\n\t\t\t\tcancel();\n\t\t\t});\n\n\t\t\tlet dataWithoutResult = \"\";\n\t\t\trgProc.stdout!.on(\"data\", (data) => {\n\t\t\t\tripgrepParser.handleData(data);\n\t\t\t\tif (!gotResult) {\n\t\t\t\t\tdataWithoutResult += data;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tlet gotData = false;\n\t\t\trgProc.stdout!.once(\"data\", () => (gotData = true));\n\n\t\t\tlet stderr = \"\";\n\t\t\trgProc.stderr!.on(\"data\", (data) => {\n\t\t\t\tconst message = data.toString();\n\t\t\t\tthis.outputChannel.appendLine(message);\n\n\t\t\t\tif (stderr.length + message.length < 1e6) {\n\t\t\t\t\tstderr += message;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\trgProc.on(\"close\", () => {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\tgotData ? \"Got data from stdout\" : \"No data from stdout\",\n\t\t\t\t);\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\tgotResult\n\t\t\t\t\t\t? \"Got result from parser\"\n\t\t\t\t\t\t: \"No result from parser\",\n\t\t\t\t);\n\t\t\t\tif (dataWithoutResult) {\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`Got data without result: ${dataWithoutResult}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tthis.outputChannel.appendLine(\"\");\n\n\t\t\t\tif (isDone) {\n\t\t\t\t\tresolve({ limitHit });\n\t\t\t\t} else {\n\t\t\t\t\t// Trigger last result\n\t\t\t\t\tripgrepParser.flush();\n\t\t\t\t\trgProc = null;\n\t\t\t\t\tlet searchError: Maybe<SearchError>;\n\t\t\t\t\tif (\n\t\t\t\t\t\tstderr &&\n\t\t\t\t\t\t!gotData &&\n\t\t\t\t\t\t(searchError = rgErrorMsgForDisplay(stderr))\n\t\t\t\t\t) {\n\t\t\t\t\t\treject(\n\t\t\t\t\t\t\tserializeSearchError(\n\t\t\t\t\t\t\t\tnew SearchError(\n\t\t\t\t\t\t\t\t\tsearchError.message,\n\t\t\t\t\t\t\t\t\tsearchError.code,\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve({ limitHit });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n}\n\n/**\n * Read the first line of stderr and return an error for display or undefined, based on a list of\n * allowed properties.\n * Ripgrep produces stderr output which is not from a fatal error, and we only want the search to be\n * \"failed\" when a fatal error was produced.\n */\nfunction rgErrorMsgForDisplay(msg: string): Maybe<SearchError> {\n\tconst lines = msg.split(\"\\n\");\n\tconst firstLine = lines[0].trim();\n\n\tif (lines.some((l) => l.startsWith(\"regex parse error\"))) {\n\t\treturn new SearchError(\n\t\t\tbuildRegexParseError(lines),\n\t\t\tSearchErrorCode.regexParseError,\n\t\t);\n\t}\n\n\tconst match = firstLine.match(/grep config error: unknown encoding: (.*)/);\n\tif (match) {\n\t\treturn new SearchError(\n\t\t\t`Unknown encoding: ${match[1]}`,\n\t\t\tSearchErrorCode.unknownEncoding,\n\t\t);\n\t}\n\n\tif (firstLine.startsWith(\"error parsing glob\")) {\n\t\t// Uppercase first letter\n\t\treturn new SearchError(\n\t\t\tfirstLine.charAt(0).toUpperCase() + firstLine.substr(1),\n\t\t\tSearchErrorCode.globParseError,\n\t\t);\n\t}\n\n\tif (firstLine.startsWith(\"the literal\")) {\n\t\t// Uppercase first letter\n\t\treturn new SearchError(\n\t\t\tfirstLine.charAt(0).toUpperCase() + firstLine.substr(1),\n\t\t\tSearchErrorCode.invalidLiteral,\n\t\t);\n\t}\n\n\tif (firstLine.startsWith(\"PCRE2: error compiling pattern\")) {\n\t\treturn new SearchError(firstLine, SearchErrorCode.regexParseError);\n\t}\n\n\treturn undefined;\n}\n\nfunction buildRegexParseError(lines: string[]): string {\n\tconst errorMessage: string[] = [\"Regex parse error\"];\n\tconst pcre2ErrorLine = lines.filter((l) => l.startsWith(\"PCRE2:\"));\n\tif (pcre2ErrorLine.length >= 1) {\n\t\tconst pcre2ErrorMessage = pcre2ErrorLine[0].replace(\"PCRE2:\", \"\");\n\t\tif (\n\t\t\tpcre2ErrorMessage.indexOf(\":\") !== -1 &&\n\t\t\tpcre2ErrorMessage.split(\":\").length >= 2\n\t\t) {\n\t\t\tconst pcre2ActualErrorMessage = pcre2ErrorMessage.split(\":\")[1];\n\t\t\terrorMessage.push(\":\" + pcre2ActualErrorMessage);\n\t\t}\n\t}\n\n\treturn errorMessage.join(\"\");\n}\n\nexport class RipgrepParser extends EventEmitter {\n\tprivate remainder = \"\";\n\tprivate isDone = false;\n\tprivate hitLimit = false;\n\tprivate stringDecoder: StringDecoder;\n\n\tprivate numResults = 0;\n\n\tconstructor(\n\t\tprivate maxResults: number,\n\t\tprivate root: URI,\n\t\tprivate previewOptions: ITextSearchPreviewOptions,\n\t) {\n\t\tsuper();\n\t\tthis.stringDecoder = new StringDecoder();\n\t}\n\n\tcancel(): void {\n\t\tthis.isDone = true;\n\t}\n\n\tflush(): void {\n\t\tthis.handleDecodedData(this.stringDecoder.end());\n\t}\n\n\toverride on(\n\t\tevent: \"result\",\n\t\tlistener: (result: TextSearchResultNew) => void,\n\t): this;\n\toverride on(event: \"hitLimit\", listener: () => void): this;\n\toverride on(event: string, listener: (...args: any[]) => void): this {\n\t\tsuper.on(event, listener);\n\t\treturn this;\n\t}\n\n\thandleData(data: Buffer | string): void {\n\t\tif (this.isDone) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst dataStr =\n\t\t\ttypeof data === \"string\" ? data : this.stringDecoder.write(data);\n\t\tthis.handleDecodedData(dataStr);\n\t}\n\n\tprivate handleDecodedData(decodedData: string): void {\n\t\t// check for newline before appending to remainder\n\t\tlet newlineIdx = decodedData.indexOf(\"\\n\");\n\n\t\t// If the previous data chunk didn't end in a newline, prepend it to this chunk\n\t\tconst dataStr = this.remainder + decodedData;\n\n\t\tif (newlineIdx >= 0) {\n\t\t\tnewlineIdx += this.remainder.length;\n\t\t} else {\n\t\t\t// Shortcut\n\t\t\tthis.remainder = dataStr;\n\t\t\treturn;\n\t\t}\n\n\t\tlet prevIdx = 0;\n\t\twhile (newlineIdx >= 0) {\n\t\t\tthis.handleLine(dataStr.substring(prevIdx, newlineIdx).trim());\n\t\t\tprevIdx = newlineIdx + 1;\n\t\t\tnewlineIdx = dataStr.indexOf(\"\\n\", prevIdx);\n\t\t}\n\n\t\tthis.remainder = dataStr.substring(prevIdx);\n\t}\n\n\tprivate handleLine(outputLine: string): void {\n\t\tif (this.isDone || !outputLine) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet parsedLine: IRgMessage;\n\t\ttry {\n\t\t\tparsedLine = JSON.parse(outputLine);\n\t\t} catch (e) {\n\t\t\tthrow new Error(`malformed line from rg: ${outputLine}`);\n\t\t}\n\n\t\tif (parsedLine.type === \"match\") {\n\t\t\tconst matchPath = bytesOrTextToString(parsedLine.data.path);\n\t\t\tconst uri = URI.joinPath(this.root, matchPath);\n\t\t\tconst result = this.createTextSearchMatch(parsedLine.data, uri);\n\t\t\tthis.onResult(result);\n\n\t\t\tif (this.hitLimit) {\n\t\t\t\tthis.cancel();\n\t\t\t\tthis.emit(\"hitLimit\");\n\t\t\t}\n\t\t} else if (parsedLine.type === \"context\") {\n\t\t\tconst contextPath = bytesOrTextToString(parsedLine.data.path);\n\t\t\tconst uri = URI.joinPath(this.root, contextPath);\n\t\t\tconst result = this.createTextSearchContexts(parsedLine.data, uri);\n\t\t\tresult.forEach((r) => this.onResult(r));\n\t\t}\n\t}\n\n\tprivate createTextSearchMatch(\n\t\tdata: IRgMatch,\n\t\turi: URI,\n\t): TextSearchMatchNew {\n\t\tconst lineNumber = data.line_number - 1;\n\t\tconst fullText = bytesOrTextToString(data.lines);\n\t\tconst fullTextBytes = Buffer.from(fullText);\n\n\t\tlet prevMatchEnd = 0;\n\t\tlet prevMatchEndCol = 0;\n\t\tlet prevMatchEndLine = lineNumber;\n\n\t\t// it looks like certain regexes can match a line, but cause rg to not\n\t\t// emit any specific submatches for that line.\n\t\t// https://github.com/microsoft/vscode/issues/100569#issuecomment-738496991\n\t\tif (data.submatches.length === 0) {\n\t\t\tdata.submatches.push(\n\t\t\t\tfullText.length\n\t\t\t\t\t? { start: 0, end: 1, match: { text: fullText[0] } }\n\t\t\t\t\t: { start: 0, end: 0, match: { text: \"\" } },\n\t\t\t);\n\t\t}\n\n\t\tconst ranges = coalesce(\n\t\t\tdata.submatches.map((match, i) => {\n\t\t\t\tif (this.hitLimit) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tthis.numResults++;\n\t\t\t\tif (this.numResults >= this.maxResults) {\n\t\t\t\t\t// Finish the line, then report the result below\n\t\t\t\t\tthis.hitLimit = true;\n\t\t\t\t}\n\n\t\t\t\tconst matchText = bytesOrTextToString(match.match);\n\n\t\t\t\tconst inBetweenText = fullTextBytes\n\t\t\t\t\t.slice(prevMatchEnd, match.start)\n\t\t\t\t\t.toString();\n\t\t\t\tconst inBetweenStats =\n\t\t\t\t\tgetNumLinesAndLastNewlineLength(inBetweenText);\n\t\t\t\tconst startCol =\n\t\t\t\t\tinBetweenStats.numLines > 0\n\t\t\t\t\t\t? inBetweenStats.lastLineLength\n\t\t\t\t\t\t: inBetweenStats.lastLineLength + prevMatchEndCol;\n\n\t\t\t\tconst stats = getNumLinesAndLastNewlineLength(matchText);\n\t\t\t\tconst startLineNumber =\n\t\t\t\t\tinBetweenStats.numLines + prevMatchEndLine;\n\t\t\t\tconst endLineNumber = stats.numLines + startLineNumber;\n\t\t\t\tconst endCol =\n\t\t\t\t\tstats.numLines > 0\n\t\t\t\t\t\t? stats.lastLineLength\n\t\t\t\t\t\t: stats.lastLineLength + startCol;\n\n\t\t\t\tprevMatchEnd = match.end;\n\t\t\t\tprevMatchEndCol = endCol;\n\t\t\t\tprevMatchEndLine = endLineNumber;\n\n\t\t\t\treturn new Range(\n\t\t\t\t\tstartLineNumber,\n\t\t\t\t\tstartCol,\n\t\t\t\t\tendLineNumber,\n\t\t\t\t\tendCol,\n\t\t\t\t);\n\t\t\t}),\n\t\t);\n\n\t\tconst searchRange = mapArrayOrNot(<Range[]>ranges, rangeToSearchRange);\n\n\t\tconst internalResult = new TextSearchMatch(\n\t\t\tfullText,\n\t\t\tsearchRange,\n\t\t\tthis.previewOptions,\n\t\t);\n\t\treturn new TextSearchMatchNew(\n\t\t\turi,\n\t\t\tinternalResult.rangeLocations.map((e) => ({\n\t\t\t\tsourceRange: searchRangeToRange(e.source),\n\t\t\t\tpreviewRange: searchRangeToRange(e.preview),\n\t\t\t})),\n\t\t\tinternalResult.previewText,\n\t\t);\n\t}\n\n\tprivate createTextSearchContexts(\n\t\tdata: IRgMatch,\n\t\turi: URI,\n\t): TextSearchContextNew[] {\n\t\tconst text = bytesOrTextToString(data.lines);\n\t\tconst startLine = data.line_number;\n\t\treturn text\n\t\t\t.replace(/\\r?\\n$/, \"\")\n\t\t\t.split(\"\\n\")\n\t\t\t.map(\n\t\t\t\t(line, i) => new TextSearchContextNew(uri, line, startLine + i),\n\t\t\t);\n\t}\n\n\tprivate onResult(match: TextSearchResultNew): void {\n\t\tthis.emit(\"result\", match);\n\t}\n}\n\nfunction bytesOrTextToString(obj: any): string {\n\treturn obj.bytes ? Buffer.from(obj.bytes, \"base64\").toString() : obj.text;\n}\n\nfunction getNumLinesAndLastNewlineLength(text: string): {\n\tnumLines: number;\n\tlastLineLength: number;\n} {\n\tconst re = /\\n/g;\n\tlet numLines = 0;\n\tlet lastNewlineIdx = -1;\n\tlet match: ReturnType<typeof re.exec>;\n\twhile ((match = re.exec(text))) {\n\t\tnumLines++;\n\t\tlastNewlineIdx = match.index;\n\t}\n\n\tconst lastLineLength =\n\t\tlastNewlineIdx >= 0 ? text.length - lastNewlineIdx - 1 : text.length;\n\n\treturn { numLines, lastLineLength };\n}\n\n// exported for testing\nexport function getRgArgs(\n\tquery: TextSearchQueryNew,\n\toptions: RipgrepTextSearchOptions,\n): string[] {\n\tconst args = [\"--hidden\", \"--no-require-git\"];\n\targs.push(query.isCaseSensitive ? \"--case-sensitive\" : \"--ignore-case\");\n\n\tconst { doubleStarIncludes, otherIncludes } = groupBy(\n\t\toptions.folderOptions.includes,\n\t\t(include: string) =>\n\t\t\tinclude.startsWith(\"**\") ? \"doubleStarIncludes\" : \"otherIncludes\",\n\t);\n\n\tif (otherIncludes && otherIncludes.length) {\n\t\tconst uniqueOthers = new Set<string>();\n\t\totherIncludes.forEach((other) => {\n\t\t\tuniqueOthers.add(other);\n\t\t});\n\n\t\targs.push(\"-g\", \"!*\");\n\t\tuniqueOthers.forEach((otherIncude) => {\n\t\t\tspreadGlobComponents(otherIncude)\n\t\t\t\t.map(anchorGlob)\n\t\t\t\t.forEach((globArg) => {\n\t\t\t\t\targs.push(\"-g\", globArg);\n\t\t\t\t});\n\t\t});\n\t}\n\n\tif (doubleStarIncludes && doubleStarIncludes.length) {\n\t\tdoubleStarIncludes.forEach((globArg) => {\n\t\t\targs.push(\"-g\", globArg);\n\t\t});\n\t}\n\n\toptions.folderOptions.excludes\n\t\t.map((e) => (typeof e === \"string\" ? e : e.pattern))\n\t\t.map(anchorGlob)\n\t\t.forEach((rgGlob) => args.push(\"-g\", `!${rgGlob}`));\n\n\tif (options.maxFileSize) {\n\t\targs.push(\"--max-filesize\", options.maxFileSize + \"\");\n\t}\n\n\tif (options.folderOptions.useIgnoreFiles.local) {\n\t\tif (!options.folderOptions.useIgnoreFiles.parent) {\n\t\t\targs.push(\"--no-ignore-parent\");\n\t\t}\n\t} else {\n\t\t// Don't use .gitignore or .ignore\n\t\targs.push(\"--no-ignore\");\n\t}\n\n\tif (options.folderOptions.followSymlinks) {\n\t\targs.push(\"--follow\");\n\t}\n\n\tif (\n\t\toptions.folderOptions.encoding &&\n\t\toptions.folderOptions.encoding !== \"utf8\"\n\t) {\n\t\targs.push(\"--encoding\", options.folderOptions.encoding);\n\t}\n\n\tif (options.numThreads) {\n\t\targs.push(\"--threads\", `${options.numThreads}`);\n\t}\n\n\t// Ripgrep handles -- as a -- arg separator. Only --.\n\t// - is ok, --- is ok, --some-flag is also ok. Need to special case.\n\tif (query.pattern === \"--\") {\n\t\tquery.isRegExp = true;\n\t\tquery.pattern = \"\\\\-\\\\-\";\n\t}\n\n\tif (query.isMultiline && !query.isRegExp) {\n\t\tquery.pattern = escapeRegExpCharacters(query.pattern);\n\t\tquery.isRegExp = true;\n\t}\n\n\tif ((<IExtendedExtensionSearchOptions>options).usePCRE2) {\n\t\targs.push(\"--pcre2\");\n\t}\n\n\t// Allow $ to match /r/n\n\targs.push(\"--crlf\");\n\n\tif (query.isRegExp) {\n\t\tquery.pattern = unicodeEscapesToPCRE2(query.pattern);\n\t\targs.push(\"--engine\", \"auto\");\n\t}\n\n\tlet searchPatternAfterDoubleDashes: Maybe<string>;\n\tif (query.isWordMatch) {\n\t\tconst regexp = createRegExp(query.pattern, !!query.isRegExp, {\n\t\t\twholeWord: query.isWordMatch,\n\t\t});\n\t\tconst regexpStr = regexp.source.replace(/\\\\\\//g, \"/\"); // RegExp.source arbitrarily returns escaped slashes. Search and destroy.\n\t\targs.push(\"--regexp\", regexpStr);\n\t} else if (query.isRegExp) {\n\t\tlet fixedRegexpQuery = fixRegexNewline(query.pattern);\n\t\tfixedRegexpQuery = fixNewline(fixedRegexpQuery);\n\t\targs.push(\"--regexp\", fixedRegexpQuery);\n\t} else {\n\t\tsearchPatternAfterDoubleDashes = query.pattern;\n\t\targs.push(\"--fixed-strings\");\n\t}\n\n\targs.push(\"--no-config\");\n\tif (!options.folderOptions.useIgnoreFiles.global) {\n\t\targs.push(\"--no-ignore-global\");\n\t}\n\n\targs.push(\"--json\");\n\n\tif (query.isMultiline) {\n\t\targs.push(\"--multiline\");\n\t}\n\n\tif (options.surroundingContext) {\n\t\targs.push(\"--before-context\", options.surroundingContext + \"\");\n\t\targs.push(\"--after-context\", options.surroundingContext + \"\");\n\t}\n\n\t// Folder to search\n\targs.push(\"--\");\n\n\tif (searchPatternAfterDoubleDashes) {\n\t\t// Put the query after --, in case the query starts with a dash\n\t\targs.push(searchPatternAfterDoubleDashes);\n\t}\n\n\targs.push(\".\");\n\n\treturn args;\n}\n\n/**\n * `\"foo/*bar/something\"` -> `[\"foo\", \"foo/*bar\", \"foo/*bar/something\", \"foo/*bar/something/**\"]`\n */\nfunction spreadGlobComponents(globComponent: string): string[] {\n\tconst globComponentWithBraceExpansion =\n\t\tperformBraceExpansionForRipgrep(globComponent);\n\n\treturn globComponentWithBraceExpansion.flatMap((globArg) => {\n\t\tconst components = splitGlobAware(globArg, \"/\");\n\t\treturn components.map((_, i) => components.slice(0, i + 1).join(\"/\"));\n\t});\n}\n\nexport function unicodeEscapesToPCRE2(pattern: string): string {\n\t// Match \\u1234\n\tconst unicodePattern = /((?:[^\\\\]|^)(?:\\\\\\\\)*)\\\\u([a-z0-9]{4})/gi;\n\n\twhile (pattern.match(unicodePattern)) {\n\t\tpattern = pattern.replace(unicodePattern, `$1\\\\x{$2}`);\n\t}\n\n\t// Match \\u{1234}\n\t// \\u with 5-6 characters will be left alone because \\x only takes 4 characters.\n\tconst unicodePatternWithBraces =\n\t\t/((?:[^\\\\]|^)(?:\\\\\\\\)*)\\\\u\\{([a-z0-9]{4})\\}/gi;\n\twhile (pattern.match(unicodePatternWithBraces)) {\n\t\tpattern = pattern.replace(unicodePatternWithBraces, `$1\\\\x{$2}`);\n\t}\n\n\treturn pattern;\n}\n\nexport interface IRgMessage {\n\ttype: \"match\" | \"context\" | string;\n\tdata: IRgMatch;\n}\n\nexport interface IRgMatch {\n\tpath: IRgBytesOrText;\n\tlines: IRgBytesOrText;\n\tline_number: number;\n\tabsolute_offset: number;\n\tsubmatches: IRgSubmatch[];\n}\n\nexport interface IRgSubmatch {\n\tmatch: IRgBytesOrText;\n\tstart: number;\n\tend: number;\n}\n\nexport type IRgBytesOrText = { bytes: string } | { text: string };\n\nconst isLookBehind = (node: ReAST.Node) =>\n\tnode.type === \"Assertion\" && node.kind === \"lookbehind\";\n\nexport function fixRegexNewline(pattern: string): string {\n\t// we parse the pattern anew each tiem\n\tlet re: ReAST.Pattern;\n\ttry {\n\t\tre = new RegExpParser().parsePattern(pattern);\n\t} catch {\n\t\treturn pattern;\n\t}\n\n\tlet output = \"\";\n\tlet lastEmittedIndex = 0;\n\tconst replace = (start: number, end: number, text: string) => {\n\t\toutput += pattern.slice(lastEmittedIndex, start) + text;\n\t\tlastEmittedIndex = end;\n\t};\n\n\tconst context: ReAST.Node[] = [];\n\tconst visitor = new RegExpVisitor({\n\t\tonCharacterEnter(char) {\n\t\t\tif (char.raw !== \"\\\\n\") {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst parent = context[0];\n\t\t\tif (!parent) {\n\t\t\t\t// simple char, \\n -> \\r?\\n\n\t\t\t\treplace(char.start, char.end, \"\\\\r?\\\\n\");\n\t\t\t} else if (context.some(isLookBehind)) {\n\t\t\t\t// no-op in a lookbehind, see #100569\n\t\t\t} else if (parent.type === \"CharacterClass\") {\n\t\t\t\tif (parent.negate) {\n\t\t\t\t\t// negative bracket expr, [^a-z\\n] -> (?![a-z]|\\r?\\n)\n\t\t\t\t\tconst otherContent =\n\t\t\t\t\t\tpattern.slice(parent.start + 2, char.start) +\n\t\t\t\t\t\tpattern.slice(char.end, parent.end - 1);\n\t\t\t\t\tif (parent.parent?.type === \"Quantifier\") {\n\t\t\t\t\t\t// If quantified, we can't use a negative lookahead in a quantifier.\n\t\t\t\t\t\t// But `.` already doesn't match new lines, so we can just use that\n\t\t\t\t\t\t// (with any other negations) instead.\n\t\t\t\t\t\treplace(\n\t\t\t\t\t\t\tparent.start,\n\t\t\t\t\t\t\tparent.end,\n\t\t\t\t\t\t\totherContent ? `[^${otherContent}]` : \".\",\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treplace(\n\t\t\t\t\t\t\tparent.start,\n\t\t\t\t\t\t\tparent.end,\n\t\t\t\t\t\t\t\"(?!\\\\r?\\\\n\" +\n\t\t\t\t\t\t\t\t(otherContent ? `|[${otherContent}]` : \"\") +\n\t\t\t\t\t\t\t\t\")\",\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// positive bracket expr, [a-z\\n] -> (?:[a-z]|\\r?\\n)\n\t\t\t\t\tconst otherContent =\n\t\t\t\t\t\tpattern.slice(parent.start + 1, char.start) +\n\t\t\t\t\t\tpattern.slice(char.end, parent.end - 1);\n\t\t\t\t\treplace(\n\t\t\t\t\t\tparent.start,\n\t\t\t\t\t\tparent.end,\n\t\t\t\t\t\totherContent === \"\"\n\t\t\t\t\t\t\t? \"\\\\r?\\\\n\"\n\t\t\t\t\t\t\t: `(?:[${otherContent}]|\\\\r?\\\\n)`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else if (parent.type === \"Quantifier\") {\n\t\t\t\treplace(char.start, char.end, \"(?:\\\\r?\\\\n)\");\n\t\t\t}\n\t\t},\n\t\tonQuantifierEnter(node) {\n\t\t\tcontext.unshift(node);\n\t\t},\n\t\tonQuantifierLeave() {\n\t\t\tcontext.shift();\n\t\t},\n\t\tonCharacterClassRangeEnter(node) {\n\t\t\tcontext.unshift(node);\n\t\t},\n\t\tonCharacterClassRangeLeave() {\n\t\t\tcontext.shift();\n\t\t},\n\t\tonCharacterClassEnter(node) {\n\t\t\tcontext.unshift(node);\n\t\t},\n\t\tonCharacterClassLeave() {\n\t\t\tcontext.shift();\n\t\t},\n\t\tonAssertionEnter(node) {\n\t\t\tif (isLookBehind(node)) {\n\t\t\t\tcontext.push(node);\n\t\t\t}\n\t\t},\n\t\tonAssertionLeave(node) {\n\t\t\tif (context[0] === node) {\n\t\t\t\tcontext.shift();\n\t\t\t}\n\t\t},\n\t});\n\n\tvisitor.visit(re);\n\toutput += pattern.slice(lastEmittedIndex);\n\treturn output;\n}\n\nexport function fixNewline(pattern: string): string {\n\treturn pattern.replace(/\\n/g, \"\\\\r?\\\\n\");\n}\n\n// brace expansion for ripgrep\n\n/**\n * Split string given first opportunity for brace expansion in the string.\n * - If the brace is prepended by a \\ character, then it is escaped.\n * - Does not process escapes that are within the sub-glob.\n * - If two unescaped `{` occur before `}`, then ripgrep will return an error for brace nesting, so don't split on those.\n */\nfunction getEscapeAwareSplitStringForRipgrep(pattern: string): {\n\tfixedStart?: string;\n\tstrInBraces: string;\n\tfixedEnd?: string;\n} {\n\tlet inBraces = false;\n\tlet escaped = false;\n\tlet fixedStart = \"\";\n\tlet strInBraces = \"\";\n\tfor (let i = 0; i < pattern.length; i++) {\n\t\tconst char = pattern[i];\n\t\tswitch (char) {\n\t\t\tcase \"\\\\\":\n\t\t\t\tif (escaped) {\n\t\t\t\t\t// If we're already escaped, then just leave the escaped slash and the preceeding slash that escapes it.\n\t\t\t\t\t// The two escaped slashes will result in a single slash and whatever processes the glob later will properly process the escape\n\t\t\t\t\tif (inBraces) {\n\t\t\t\t\t\tstrInBraces += \"\\\\\" + char;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfixedStart += \"\\\\\" + char;\n\t\t\t\t\t}\n\t\t\t\t\tescaped = false;\n\t\t\t\t} else {\n\t\t\t\t\tescaped = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"{\":\n\t\t\t\tif (escaped) {\n\t\t\t\t\t// if we escaped this opening bracket, then it is to be taken literally. Remove the `\\` because we've acknowleged it and add the `{` to the appropriate string\n\t\t\t\t\tif (inBraces) {\n\t\t\t\t\t\tstrInBraces += char;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfixedStart += char;\n\t\t\t\t\t}\n\t\t\t\t\tescaped = false;\n\t\t\t\t} else if (inBraces) {\n\t\t\t\t\t// ripgrep treats this as attempting to do a nested alternate group, which is invalid. Return with pattern including changes from escaped braces.\n\t\t\t\t\treturn {\n\t\t\t\t\t\tstrInBraces:\n\t\t\t\t\t\t\tfixedStart +\n\t\t\t\t\t\t\t\"{\" +\n\t\t\t\t\t\t\tstrInBraces +\n\t\t\t\t\t\t\t\"{\" +\n\t\t\t\t\t\t\tpattern.substring(i + 1),\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tinBraces = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"}\":\n\t\t\t\tif (escaped) {\n\t\t\t\t\t// same as `}`, but for closing bracket\n\t\t\t\t\tif (inBraces) {\n\t\t\t\t\t\tstrInBraces += char;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfixedStart += char;\n\t\t\t\t\t}\n\t\t\t\t\tescaped = false;\n\t\t\t\t} else if (inBraces) {\n\t\t\t\t\t// we found an end bracket to a valid opening bracket. Return the appropriate strings.\n\t\t\t\t\treturn {\n\t\t\t\t\t\tfixedStart,\n\t\t\t\t\t\tstrInBraces,\n\t\t\t\t\t\tfixedEnd: pattern.substring(i + 1),\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\t// if we're not in braces and not escaped, then this is a literal `}` character and we're still adding to fixedStart.\n\t\t\t\t\tfixedStart += char;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// similar to the `\\\\` case, we didn't do anything with the escape, so we should re-insert it into the appropriate string\n\t\t\t\t// to be consumed later when individual parts of the glob are processed\n\t\t\t\tif (inBraces) {\n\t\t\t\t\tstrInBraces += (escaped ? \"\\\\\" : \"\") + char;\n\t\t\t\t} else {\n\t\t\t\t\tfixedStart += (escaped ? \"\\\\\" : \"\") + char;\n\t\t\t\t}\n\t\t\t\tescaped = false;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t// we are haven't hit the last brace, so no splitting should occur. Return with pattern including changes from escaped braces.\n\treturn { strInBraces: fixedStart + (inBraces ? \"{\" + strInBraces : \"\") };\n}\n\n/**\n * Parses out curly braces and returns equivalent globs. Only supports one level of nesting.\n * Exported for testing.\n */\nexport function performBraceExpansionForRipgrep(pattern: string): string[] {\n\tconst { fixedStart, strInBraces, fixedEnd } =\n\t\tgetEscapeAwareSplitStringForRipgrep(pattern);\n\tif (fixedStart === undefined || fixedEnd === undefined) {\n\t\treturn [strInBraces];\n\t}\n\n\tlet arr = splitGlobAware(strInBraces, \",\");\n\n\tif (!arr.length) {\n\t\t// occurs if the braces are empty.\n\t\tarr = [\"\"];\n\t}\n\n\tconst ends = performBraceExpansionForRipgrep(fixedEnd);\n\n\treturn arr.flatMap((elem) => {\n\t\tconst start = fixedStart + elem;\n\t\treturn ends.map((end) => {\n\t\t\treturn start + end;\n\t\t});\n\t});\n}\n"],
  "mappings": ";;AAKA,YAAY,QAAQ;AACpB,SAAS,oBAAoB;AAC7B,SAAS,qBAAqB;AAC9B,SAAS,cAAc;AACvB,SAA4B,cAAc,qBAAqB;AAC/D,SAAS,UAAU,qBAAqB;AAExC,SAAS,eAAe;AACxB,SAAS,sBAAsB;AAC/B;AAAA,EACC;AAAA,EACA;AAAA,OACM;AACP,SAAS,WAAW;AAEpB;AAAA,EACC;AAAA,EAGA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACM;AACP,SAAS,8BAA8B;AACvC;AAAA,EACC;AAAA,EAEA;AAAA,EACA;AAAA,OAIM;AAEP;AAAA,EAGC;AAAA,EACA;AAAA,EACA;AAAA,OACM;AAGP,MAAM,aAAa,OAAO;AAAA,EACzB;AAAA,EACA;AACD;AAEO,MAAM,wBAAwB;AAAA,EACpC,YACS,eACS,aAChB;AAFO;AACS;AAAA,EACf;AAAA,EA1DJ,OAsDqC;AAAA;AAAA;AAAA,EAMpC,yBACC,OACA,SACA,UACA,OACiC;AACjC,WAAO,QAAQ;AAAA,MACd,QAAQ,cAAc,IAAI,CAAC,iBAAiB;AAC3C,cAAM,kBAA4C;AAAA,UACjD,eAAe;AAAA,UACf,YAAY,KAAK;AAAA,UACjB,YAAY,QAAQ;AAAA,UACpB,gBAAgB,QAAQ;AAAA,UACxB,aAAa,QAAQ;AAAA,UACrB,oBAAoB,QAAQ;AAAA,QAC7B;AACA,eAAO,KAAK;AAAA,UACX;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACD;AAAA,MACD,CAAC;AAAA,IACF,EAAE,KAAK,CAAC,MAAM;AACb,YAAM,WAAkC;AAAA;AAAA,QAEvC,UAAU,EAAE,KAAK,CAACA,cAAa,CAAC,CAACA,aAAYA,UAAS,QAAQ;AAAA,MAC/D;AACA,aAAO;AAAA,IACR,CAAC;AAAA,EACF;AAAA,EAEA,sCACC,OACA,SACA,UACA,OACiC;AACjC,SAAK,cAAc;AAAA,MAClB,4BAA4B,MAAM,OAAO,KAAK,KAAK,UAAU;AAAA,QAC5D,GAAG;AAAA,QACH,GAAG;AAAA,UACF,QAAQ,QAAQ,cAAc,OAAO,SAAS;AAAA,QAC/C;AAAA,MACD,CAAC,CAAC;AAAA,IACH;AAEA,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACvC,YAAM,wBAAwB,MAAM,OAAO,CAAC;AAE5C,YAAM,kBAA4C;AAAA,QACjD,GAAG;AAAA,QACH,YAAY,KAAK;AAAA,MAClB;AACA,YAAM,SAAS,UAAU,OAAO,eAAe;AAE/C,YAAM,MAAM,QAAQ,cAAc,OAAO;AAEzC,YAAM,cAAc,OAClB,IAAI,CAAC,QAAS,IAAI,MAAM,IAAI,IAAI,MAAM,IAAI,GAAG,GAAI,EACjD,KAAK,GAAG;AACV,WAAK,cAAc;AAAA,QAClB,GAAG,UAAU,IAAI,WAAW;AAAA,UAAa,GAAG;AAAA,MAC7C;AAEA,UAAI,SAAiC,GAAG,MAAM,YAAY,QAAQ;AAAA,QACjE;AAAA,MACD,CAAC;AACD,aAAO,GAAG,SAAS,CAAC,MAAM;AACzB,gBAAQ,MAAM,CAAC;AACf,aAAK,cAAc,WAAW,aAAa,KAAK,EAAE,QAAQ;AAC1D;AAAA,UACC;AAAA,YACC,IAAI;AAAA,cACH,KAAK,EAAE;AAAA,cACP,gBAAgB;AAAA,YACjB;AAAA,UACD;AAAA,QACD;AAAA,MACD,CAAC;AAED,UAAI,YAAY;AAChB,YAAM,gBAAgB,IAAI;AAAA,QACzB,QAAQ,cAAc;AAAA,QACtB,QAAQ,cAAc;AAAA,QACtB,uBAAuB,QAAQ,cAAc;AAAA,MAC9C;AACA,oBAAc,GAAG,UAAU,CAAC,UAA+B;AAC1D,oBAAY;AACZ,4BAAoB;AACpB,iBAAS,OAAO,KAAK;AAAA,MACtB,CAAC;AAED,UAAI,SAAS;AACb,YAAM,SAAS,6BAAM;AACpB,iBAAS;AAET,gBAAQ,KAAK;AAEb,uBAAe,OAAO;AAAA,MACvB,GANe;AAQf,UAAI,WAAW;AACf,oBAAc,GAAG,YAAY,MAAM;AAClC,mBAAW;AACX,eAAO;AAAA,MACR,CAAC;AAED,UAAI,oBAAoB;AACxB,aAAO,OAAQ,GAAG,QAAQ,CAAC,SAAS;AACnC,sBAAc,WAAW,IAAI;AAC7B,YAAI,CAAC,WAAW;AACf,+BAAqB;AAAA,QACtB;AAAA,MACD,CAAC;AAED,UAAI,UAAU;AACd,aAAO,OAAQ,KAAK,QAAQ,MAAO,UAAU,IAAK;AAElD,UAAI,SAAS;AACb,aAAO,OAAQ,GAAG,QAAQ,CAAC,SAAS;AACnC,cAAM,UAAU,KAAK,SAAS;AAC9B,aAAK,cAAc,WAAW,OAAO;AAErC,YAAI,OAAO,SAAS,QAAQ,SAAS,KAAK;AACzC,oBAAU;AAAA,QACX;AAAA,MACD,CAAC;AAED,aAAO,GAAG,SAAS,MAAM;AACxB,aAAK,cAAc;AAAA,UAClB,UAAU,yBAAyB;AAAA,QACpC;AACA,aAAK,cAAc;AAAA,UAClB,YACG,2BACA;AAAA,QACJ;AACA,YAAI,mBAAmB;AACtB,eAAK,cAAc;AAAA,YAClB,4BAA4B,iBAAiB;AAAA,UAC9C;AAAA,QACD;AAEA,aAAK,cAAc,WAAW,EAAE;AAEhC,YAAI,QAAQ;AACX,kBAAQ,EAAE,SAAS,CAAC;AAAA,QACrB,OAAO;AAEN,wBAAc,MAAM;AACpB,mBAAS;AACT,cAAI;AACJ,cACC,UACA,CAAC,YACA,cAAc,qBAAqB,MAAM,IACzC;AACD;AAAA,cACC;AAAA,gBACC,IAAI;AAAA,kBACH,YAAY;AAAA,kBACZ,YAAY;AAAA,gBACb;AAAA,cACD;AAAA,YACD;AAAA,UACD,OAAO;AACN,oBAAQ,EAAE,SAAS,CAAC;AAAA,UACrB;AAAA,QACD;AAAA,MACD,CAAC;AAAA,IACF,CAAC;AAAA,EACF;AACD;AAQA,SAAS,qBAAqB,KAAiC;AAC9D,QAAM,QAAQ,IAAI,MAAM,IAAI;AAC5B,QAAM,YAAY,MAAM,CAAC,EAAE,KAAK;AAEhC,MAAI,MAAM,KAAK,CAAC,MAAM,EAAE,WAAW,mBAAmB,CAAC,GAAG;AACzD,WAAO,IAAI;AAAA,MACV,qBAAqB,KAAK;AAAA,MAC1B,gBAAgB;AAAA,IACjB;AAAA,EACD;AAEA,QAAM,QAAQ,UAAU,MAAM,2CAA2C;AACzE,MAAI,OAAO;AACV,WAAO,IAAI;AAAA,MACV,qBAAqB,MAAM,CAAC,CAAC;AAAA,MAC7B,gBAAgB;AAAA,IACjB;AAAA,EACD;AAEA,MAAI,UAAU,WAAW,oBAAoB,GAAG;AAE/C,WAAO,IAAI;AAAA,MACV,UAAU,OAAO,CAAC,EAAE,YAAY,IAAI,UAAU,OAAO,CAAC;AAAA,MACtD,gBAAgB;AAAA,IACjB;AAAA,EACD;AAEA,MAAI,UAAU,WAAW,aAAa,GAAG;AAExC,WAAO,IAAI;AAAA,MACV,UAAU,OAAO,CAAC,EAAE,YAAY,IAAI,UAAU,OAAO,CAAC;AAAA,MACtD,gBAAgB;AAAA,IACjB;AAAA,EACD;AAEA,MAAI,UAAU,WAAW,gCAAgC,GAAG;AAC3D,WAAO,IAAI,YAAY,WAAW,gBAAgB,eAAe;AAAA,EAClE;AAEA,SAAO;AACR;AAxCS;AA0CT,SAAS,qBAAqB,OAAyB;AACtD,QAAM,eAAyB,CAAC,mBAAmB;AACnD,QAAM,iBAAiB,MAAM,OAAO,CAAC,MAAM,EAAE,WAAW,QAAQ,CAAC;AACjE,MAAI,eAAe,UAAU,GAAG;AAC/B,UAAM,oBAAoB,eAAe,CAAC,EAAE,QAAQ,UAAU,EAAE;AAChE,QACC,kBAAkB,QAAQ,GAAG,MAAM,MACnC,kBAAkB,MAAM,GAAG,EAAE,UAAU,GACtC;AACD,YAAM,0BAA0B,kBAAkB,MAAM,GAAG,EAAE,CAAC;AAC9D,mBAAa,KAAK,MAAM,uBAAuB;AAAA,IAChD;AAAA,EACD;AAEA,SAAO,aAAa,KAAK,EAAE;AAC5B;AAfS;AAiBF,MAAM,sBAAsB,aAAa;AAAA,EAQ/C,YACS,YACA,MACA,gBACP;AACD,UAAM;AAJE;AACA;AACA;AAGR,SAAK,gBAAgB,IAAI,cAAc;AAAA,EACxC;AAAA,EA3TD,OA4SgD;AAAA;AAAA;AAAA,EACvC,YAAY;AAAA,EACZ,SAAS;AAAA,EACT,WAAW;AAAA,EACX;AAAA,EAEA,aAAa;AAAA,EAWrB,SAAe;AACd,SAAK,SAAS;AAAA,EACf;AAAA,EAEA,QAAc;AACb,SAAK,kBAAkB,KAAK,cAAc,IAAI,CAAC;AAAA,EAChD;AAAA,EAOS,GAAG,OAAe,UAA0C;AACpE,UAAM,GAAG,OAAO,QAAQ;AACxB,WAAO;AAAA,EACR;AAAA,EAEA,WAAW,MAA6B;AACvC,QAAI,KAAK,QAAQ;AAChB;AAAA,IACD;AAEA,UAAM,UACL,OAAO,SAAS,WAAW,OAAO,KAAK,cAAc,MAAM,IAAI;AAChE,SAAK,kBAAkB,OAAO;AAAA,EAC/B;AAAA,EAEQ,kBAAkB,aAA2B;AAEpD,QAAI,aAAa,YAAY,QAAQ,IAAI;AAGzC,UAAM,UAAU,KAAK,YAAY;AAEjC,QAAI,cAAc,GAAG;AACpB,oBAAc,KAAK,UAAU;AAAA,IAC9B,OAAO;AAEN,WAAK,YAAY;AACjB;AAAA,IACD;AAEA,QAAI,UAAU;AACd,WAAO,cAAc,GAAG;AACvB,WAAK,WAAW,QAAQ,UAAU,SAAS,UAAU,EAAE,KAAK,CAAC;AAC7D,gBAAU,aAAa;AACvB,mBAAa,QAAQ,QAAQ,MAAM,OAAO;AAAA,IAC3C;AAEA,SAAK,YAAY,QAAQ,UAAU,OAAO;AAAA,EAC3C;AAAA,EAEQ,WAAW,YAA0B;AAC5C,QAAI,KAAK,UAAU,CAAC,YAAY;AAC/B;AAAA,IACD;AAEA,QAAI;AACJ,QAAI;AACH,mBAAa,KAAK,MAAM,UAAU;AAAA,IACnC,SAAS,GAAG;AACX,YAAM,IAAI,MAAM,2BAA2B,UAAU,EAAE;AAAA,IACxD;AAEA,QAAI,WAAW,SAAS,SAAS;AAChC,YAAM,YAAY,oBAAoB,WAAW,KAAK,IAAI;AAC1D,YAAM,MAAM,IAAI,SAAS,KAAK,MAAM,SAAS;AAC7C,YAAM,SAAS,KAAK,sBAAsB,WAAW,MAAM,GAAG;AAC9D,WAAK,SAAS,MAAM;AAEpB,UAAI,KAAK,UAAU;AAClB,aAAK,OAAO;AACZ,aAAK,KAAK,UAAU;AAAA,MACrB;AAAA,IACD,WAAW,WAAW,SAAS,WAAW;AACzC,YAAM,cAAc,oBAAoB,WAAW,KAAK,IAAI;AAC5D,YAAM,MAAM,IAAI,SAAS,KAAK,MAAM,WAAW;AAC/C,YAAM,SAAS,KAAK,yBAAyB,WAAW,MAAM,GAAG;AACjE,aAAO,QAAQ,CAAC,MAAM,KAAK,SAAS,CAAC,CAAC;AAAA,IACvC;AAAA,EACD;AAAA,EAEQ,sBACP,MACA,KACqB;AACrB,UAAM,aAAa,KAAK,cAAc;AACtC,UAAM,WAAW,oBAAoB,KAAK,KAAK;AAC/C,UAAM,gBAAgB,OAAO,KAAK,QAAQ;AAE1C,QAAI,eAAe;AACnB,QAAI,kBAAkB;AACtB,QAAI,mBAAmB;AAKvB,QAAI,KAAK,WAAW,WAAW,GAAG;AACjC,WAAK,WAAW;AAAA,QACf,SAAS,SACN,EAAE,OAAO,GAAG,KAAK,GAAG,OAAO,EAAE,MAAM,SAAS,CAAC,EAAE,EAAE,IACjD,EAAE,OAAO,GAAG,KAAK,GAAG,OAAO,EAAE,MAAM,GAAG,EAAE;AAAA,MAC5C;AAAA,IACD;AAEA,UAAM,SAAS;AAAA,MACd,KAAK,WAAW,IAAI,CAAC,OAAO,MAAM;AACjC,YAAI,KAAK,UAAU;AAClB,iBAAO;AAAA,QACR;AAEA,aAAK;AACL,YAAI,KAAK,cAAc,KAAK,YAAY;AAEvC,eAAK,WAAW;AAAA,QACjB;AAEA,cAAM,YAAY,oBAAoB,MAAM,KAAK;AAEjD,cAAM,gBAAgB,cACpB,MAAM,cAAc,MAAM,KAAK,EAC/B,SAAS;AACX,cAAM,iBACL,gCAAgC,aAAa;AAC9C,cAAM,WACL,eAAe,WAAW,IACvB,eAAe,iBACf,eAAe,iBAAiB;AAEpC,cAAM,QAAQ,gCAAgC,SAAS;AACvD,cAAM,kBACL,eAAe,WAAW;AAC3B,cAAM,gBAAgB,MAAM,WAAW;AACvC,cAAM,SACL,MAAM,WAAW,IACd,MAAM,iBACN,MAAM,iBAAiB;AAE3B,uBAAe,MAAM;AACrB,0BAAkB;AAClB,2BAAmB;AAEnB,eAAO,IAAI;AAAA,UACV;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACD;AAAA,MACD,CAAC;AAAA,IACF;AAEA,UAAM,cAAc,cAAuB,QAAQ,kBAAkB;AAErE,UAAM,iBAAiB,IAAI;AAAA,MAC1B;AAAA,MACA;AAAA,MACA,KAAK;AAAA,IACN;AACA,WAAO,IAAI;AAAA,MACV;AAAA,MACA,eAAe,eAAe,IAAI,CAAC,OAAO;AAAA,QACzC,aAAa,mBAAmB,EAAE,MAAM;AAAA,QACxC,cAAc,mBAAmB,EAAE,OAAO;AAAA,MAC3C,EAAE;AAAA,MACF,eAAe;AAAA,IAChB;AAAA,EACD;AAAA,EAEQ,yBACP,MACA,KACyB;AACzB,UAAM,OAAO,oBAAoB,KAAK,KAAK;AAC3C,UAAM,YAAY,KAAK;AACvB,WAAO,KACL,QAAQ,UAAU,EAAE,EACpB,MAAM,IAAI,EACV;AAAA,MACA,CAAC,MAAM,MAAM,IAAI,qBAAqB,KAAK,MAAM,YAAY,CAAC;AAAA,IAC/D;AAAA,EACF;AAAA,EAEQ,SAAS,OAAkC;AAClD,SAAK,KAAK,UAAU,KAAK;AAAA,EAC1B;AACD;AAEA,SAAS,oBAAoB,KAAkB;AAC9C,SAAO,IAAI,QAAQ,OAAO,KAAK,IAAI,OAAO,QAAQ,EAAE,SAAS,IAAI,IAAI;AACtE;AAFS;AAIT,SAAS,gCAAgC,MAGvC;AACD,QAAM,KAAK;AACX,MAAI,WAAW;AACf,MAAI,iBAAiB;AACrB,MAAI;AACJ,SAAQ,QAAQ,GAAG,KAAK,IAAI,GAAI;AAC/B;AACA,qBAAiB,MAAM;AAAA,EACxB;AAEA,QAAM,iBACL,kBAAkB,IAAI,KAAK,SAAS,iBAAiB,IAAI,KAAK;AAE/D,SAAO,EAAE,UAAU,eAAe;AACnC;AAjBS;AAoBF,SAAS,UACf,OACA,SACW;AACX,QAAM,OAAO,CAAC,YAAY,kBAAkB;AAC5C,OAAK,KAAK,MAAM,kBAAkB,qBAAqB,eAAe;AAEtE,QAAM,EAAE,oBAAoB,cAAc,IAAI;AAAA,IAC7C,QAAQ,cAAc;AAAA,IACtB,CAAC,YACA,QAAQ,WAAW,IAAI,IAAI,uBAAuB;AAAA,EACpD;AAEA,MAAI,iBAAiB,cAAc,QAAQ;AAC1C,UAAM,eAAe,oBAAI,IAAY;AACrC,kBAAc,QAAQ,CAAC,UAAU;AAChC,mBAAa,IAAI,KAAK;AAAA,IACvB,CAAC;AAED,SAAK,KAAK,MAAM,IAAI;AACpB,iBAAa,QAAQ,CAAC,gBAAgB;AACrC,2BAAqB,WAAW,EAC9B,IAAI,UAAU,EACd,QAAQ,CAAC,YAAY;AACrB,aAAK,KAAK,MAAM,OAAO;AAAA,MACxB,CAAC;AAAA,IACH,CAAC;AAAA,EACF;AAEA,MAAI,sBAAsB,mBAAmB,QAAQ;AACpD,uBAAmB,QAAQ,CAAC,YAAY;AACvC,WAAK,KAAK,MAAM,OAAO;AAAA,IACxB,CAAC;AAAA,EACF;AAEA,UAAQ,cAAc,SACpB,IAAI,CAAC,MAAO,OAAO,MAAM,WAAW,IAAI,EAAE,OAAQ,EAClD,IAAI,UAAU,EACd,QAAQ,CAAC,WAAW,KAAK,KAAK,MAAM,IAAI,MAAM,EAAE,CAAC;AAEnD,MAAI,QAAQ,aAAa;AACxB,SAAK,KAAK,kBAAkB,QAAQ,cAAc,EAAE;AAAA,EACrD;AAEA,MAAI,QAAQ,cAAc,eAAe,OAAO;AAC/C,QAAI,CAAC,QAAQ,cAAc,eAAe,QAAQ;AACjD,WAAK,KAAK,oBAAoB;AAAA,IAC/B;AAAA,EACD,OAAO;AAEN,SAAK,KAAK,aAAa;AAAA,EACxB;AAEA,MAAI,QAAQ,cAAc,gBAAgB;AACzC,SAAK,KAAK,UAAU;AAAA,EACrB;AAEA,MACC,QAAQ,cAAc,YACtB,QAAQ,cAAc,aAAa,QAClC;AACD,SAAK,KAAK,cAAc,QAAQ,cAAc,QAAQ;AAAA,EACvD;AAEA,MAAI,QAAQ,YAAY;AACvB,SAAK,KAAK,aAAa,GAAG,QAAQ,UAAU,EAAE;AAAA,EAC/C;AAIA,MAAI,MAAM,YAAY,MAAM;AAC3B,UAAM,WAAW;AACjB,UAAM,UAAU;AAAA,EACjB;AAEA,MAAI,MAAM,eAAe,CAAC,MAAM,UAAU;AACzC,UAAM,UAAU,uBAAuB,MAAM,OAAO;AACpD,UAAM,WAAW;AAAA,EAClB;AAEA,MAAsC,QAAS,UAAU;AACxD,SAAK,KAAK,SAAS;AAAA,EACpB;AAGA,OAAK,KAAK,QAAQ;AAElB,MAAI,MAAM,UAAU;AACnB,UAAM,UAAU,sBAAsB,MAAM,OAAO;AACnD,SAAK,KAAK,YAAY,MAAM;AAAA,EAC7B;AAEA,MAAI;AACJ,MAAI,MAAM,aAAa;AACtB,UAAM,SAAS,aAAa,MAAM,SAAS,CAAC,CAAC,MAAM,UAAU;AAAA,MAC5D,WAAW,MAAM;AAAA,IAClB,CAAC;AACD,UAAM,YAAY,OAAO,OAAO,QAAQ,SAAS,GAAG;AACpD,SAAK,KAAK,YAAY,SAAS;AAAA,EAChC,WAAW,MAAM,UAAU;AAC1B,QAAI,mBAAmB,gBAAgB,MAAM,OAAO;AACpD,uBAAmB,WAAW,gBAAgB;AAC9C,SAAK,KAAK,YAAY,gBAAgB;AAAA,EACvC,OAAO;AACN,qCAAiC,MAAM;AACvC,SAAK,KAAK,iBAAiB;AAAA,EAC5B;AAEA,OAAK,KAAK,aAAa;AACvB,MAAI,CAAC,QAAQ,cAAc,eAAe,QAAQ;AACjD,SAAK,KAAK,oBAAoB;AAAA,EAC/B;AAEA,OAAK,KAAK,QAAQ;AAElB,MAAI,MAAM,aAAa;AACtB,SAAK,KAAK,aAAa;AAAA,EACxB;AAEA,MAAI,QAAQ,oBAAoB;AAC/B,SAAK,KAAK,oBAAoB,QAAQ,qBAAqB,EAAE;AAC7D,SAAK,KAAK,mBAAmB,QAAQ,qBAAqB,EAAE;AAAA,EAC7D;AAGA,OAAK,KAAK,IAAI;AAEd,MAAI,gCAAgC;AAEnC,SAAK,KAAK,8BAA8B;AAAA,EACzC;AAEA,OAAK,KAAK,GAAG;AAEb,SAAO;AACR;AAvIgB;AA4IhB,SAAS,qBAAqB,eAAiC;AAC9D,QAAM,kCACL,gCAAgC,aAAa;AAE9C,SAAO,gCAAgC,QAAQ,CAAC,YAAY;AAC3D,UAAM,aAAa,eAAe,SAAS,GAAG;AAC9C,WAAO,WAAW,IAAI,CAAC,GAAG,MAAM,WAAW,MAAM,GAAG,IAAI,CAAC,EAAE,KAAK,GAAG,CAAC;AAAA,EACrE,CAAC;AACF;AARS;AAUF,SAAS,sBAAsB,SAAyB;AAE9D,QAAM,iBAAiB;AAEvB,SAAO,QAAQ,MAAM,cAAc,GAAG;AACrC,cAAU,QAAQ,QAAQ,gBAAgB,WAAW;AAAA,EACtD;AAIA,QAAM,2BACL;AACD,SAAO,QAAQ,MAAM,wBAAwB,GAAG;AAC/C,cAAU,QAAQ,QAAQ,0BAA0B,WAAW;AAAA,EAChE;AAEA,SAAO;AACR;AAjBgB;AAwChB,MAAM,eAAe,wBAAC,SACrB,KAAK,SAAS,eAAe,KAAK,SAAS,cADvB;AAGd,SAAS,gBAAgB,SAAyB;AAExD,MAAI;AACJ,MAAI;AACH,SAAK,IAAI,aAAa,EAAE,aAAa,OAAO;AAAA,EAC7C,QAAQ;AACP,WAAO;AAAA,EACR;AAEA,MAAI,SAAS;AACb,MAAI,mBAAmB;AACvB,QAAM,UAAU,wBAAC,OAAe,KAAa,SAAiB;AAC7D,cAAU,QAAQ,MAAM,kBAAkB,KAAK,IAAI;AACnD,uBAAmB;AAAA,EACpB,GAHgB;AAKhB,QAAM,UAAwB,CAAC;AAC/B,QAAM,UAAU,IAAI,cAAc;AAAA,IACjC,iBAAiB,MAAM;AACtB,UAAI,KAAK,QAAQ,OAAO;AACvB;AAAA,MACD;AAEA,YAAM,SAAS,QAAQ,CAAC;AACxB,UAAI,CAAC,QAAQ;AAEZ,gBAAQ,KAAK,OAAO,KAAK,KAAK,SAAS;AAAA,MACxC,WAAW,QAAQ,KAAK,YAAY,GAAG;AAAA,MAEvC,WAAW,OAAO,SAAS,kBAAkB;AAC5C,YAAI,OAAO,QAAQ;AAElB,gBAAM,eACL,QAAQ,MAAM,OAAO,QAAQ,GAAG,KAAK,KAAK,IAC1C,QAAQ,MAAM,KAAK,KAAK,OAAO,MAAM,CAAC;AACvC,cAAI,OAAO,QAAQ,SAAS,cAAc;AAIzC;AAAA,cACC,OAAO;AAAA,cACP,OAAO;AAAA,cACP,eAAe,KAAK,YAAY,MAAM;AAAA,YACvC;AAAA,UACD,OAAO;AACN;AAAA,cACC,OAAO;AAAA,cACP,OAAO;AAAA,cACP,gBACE,eAAe,KAAK,YAAY,MAAM,MACvC;AAAA,YACF;AAAA,UACD;AAAA,QACD,OAAO;AAEN,gBAAM,eACL,QAAQ,MAAM,OAAO,QAAQ,GAAG,KAAK,KAAK,IAC1C,QAAQ,MAAM,KAAK,KAAK,OAAO,MAAM,CAAC;AACvC;AAAA,YACC,OAAO;AAAA,YACP,OAAO;AAAA,YACP,iBAAiB,KACd,YACA,OAAO,YAAY;AAAA,UACvB;AAAA,QACD;AAAA,MACD,WAAW,OAAO,SAAS,cAAc;AACxC,gBAAQ,KAAK,OAAO,KAAK,KAAK,aAAa;AAAA,MAC5C;AAAA,IACD;AAAA,IACA,kBAAkB,MAAM;AACvB,cAAQ,QAAQ,IAAI;AAAA,IACrB;AAAA,IACA,oBAAoB;AACnB,cAAQ,MAAM;AAAA,IACf;AAAA,IACA,2BAA2B,MAAM;AAChC,cAAQ,QAAQ,IAAI;AAAA,IACrB;AAAA,IACA,6BAA6B;AAC5B,cAAQ,MAAM;AAAA,IACf;AAAA,IACA,sBAAsB,MAAM;AAC3B,cAAQ,QAAQ,IAAI;AAAA,IACrB;AAAA,IACA,wBAAwB;AACvB,cAAQ,MAAM;AAAA,IACf;AAAA,IACA,iBAAiB,MAAM;AACtB,UAAI,aAAa,IAAI,GAAG;AACvB,gBAAQ,KAAK,IAAI;AAAA,MAClB;AAAA,IACD;AAAA,IACA,iBAAiB,MAAM;AACtB,UAAI,QAAQ,CAAC,MAAM,MAAM;AACxB,gBAAQ,MAAM;AAAA,MACf;AAAA,IACD;AAAA,EACD,CAAC;AAED,UAAQ,MAAM,EAAE;AAChB,YAAU,QAAQ,MAAM,gBAAgB;AACxC,SAAO;AACR;AAvGgB;AAyGT,SAAS,WAAW,SAAyB;AACnD,SAAO,QAAQ,QAAQ,OAAO,SAAS;AACxC;AAFgB;AAYhB,SAAS,oCAAoC,SAI3C;AACD,MAAI,WAAW;AACf,MAAI,UAAU;AACd,MAAI,aAAa;AACjB,MAAI,cAAc;AAClB,WAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACxC,UAAM,OAAO,QAAQ,CAAC;AACtB,YAAQ,MAAM;AAAA,MACb,KAAK;AACJ,YAAI,SAAS;AAGZ,cAAI,UAAU;AACb,2BAAe,OAAO;AAAA,UACvB,OAAO;AACN,0BAAc,OAAO;AAAA,UACtB;AACA,oBAAU;AAAA,QACX,OAAO;AACN,oBAAU;AAAA,QACX;AACA;AAAA,MACD,KAAK;AACJ,YAAI,SAAS;AAEZ,cAAI,UAAU;AACb,2BAAe;AAAA,UAChB,OAAO;AACN,0BAAc;AAAA,UACf;AACA,oBAAU;AAAA,QACX,WAAW,UAAU;AAEpB,iBAAO;AAAA,YACN,aACC,aACA,MACA,cACA,MACA,QAAQ,UAAU,IAAI,CAAC;AAAA,UACzB;AAAA,QACD,OAAO;AACN,qBAAW;AAAA,QACZ;AACA;AAAA,MACD,KAAK;AACJ,YAAI,SAAS;AAEZ,cAAI,UAAU;AACb,2BAAe;AAAA,UAChB,OAAO;AACN,0BAAc;AAAA,UACf;AACA,oBAAU;AAAA,QACX,WAAW,UAAU;AAEpB,iBAAO;AAAA,YACN;AAAA,YACA;AAAA,YACA,UAAU,QAAQ,UAAU,IAAI,CAAC;AAAA,UAClC;AAAA,QACD,OAAO;AAEN,wBAAc;AAAA,QACf;AACA;AAAA,MACD;AAGC,YAAI,UAAU;AACb,0BAAgB,UAAU,OAAO,MAAM;AAAA,QACxC,OAAO;AACN,yBAAe,UAAU,OAAO,MAAM;AAAA,QACvC;AACA,kBAAU;AACV;AAAA,IACF;AAAA,EACD;AAGA,SAAO,EAAE,aAAa,cAAc,WAAW,MAAM,cAAc,IAAI;AACxE;AArFS;AA2FF,SAAS,gCAAgC,SAA2B;AAC1E,QAAM,EAAE,YAAY,aAAa,SAAS,IACzC,oCAAoC,OAAO;AAC5C,MAAI,eAAe,UAAa,aAAa,QAAW;AACvD,WAAO,CAAC,WAAW;AAAA,EACpB;AAEA,MAAI,MAAM,eAAe,aAAa,GAAG;AAEzC,MAAI,CAAC,IAAI,QAAQ;AAEhB,UAAM,CAAC,EAAE;AAAA,EACV;AAEA,QAAM,OAAO,gCAAgC,QAAQ;AAErD,SAAO,IAAI,QAAQ,CAAC,SAAS;AAC5B,UAAM,QAAQ,aAAa;AAC3B,WAAO,KAAK,IAAI,CAAC,QAAQ;AACxB,aAAO,QAAQ;AAAA,IAChB,CAAC;AAAA,EACF,CAAC;AACF;AAtBgB;",
  "names": ["complete"]
}
