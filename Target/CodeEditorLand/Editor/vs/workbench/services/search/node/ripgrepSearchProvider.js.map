{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/search/node/ripgrepSearchProvider.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationTokenSource, CancellationToken } from '../../../../base/common/cancellation.js';\nimport { OutputChannel } from './ripgrepSearchUtils.js';\nimport { RipgrepTextSearchEngine } from './ripgrepTextSearchEngine.js';\nimport { TextSearchProviderNew, TextSearchCompleteNew, TextSearchResultNew, TextSearchQueryNew, TextSearchProviderOptions, } from '../common/searchExtTypes.js';\nimport { Progress } from '../../../../platform/progress/common/progress.js';\nimport { Schemas } from '../../../../base/common/network.js';\nimport type { RipgrepTextSearchOptions } from '../common/searchExtTypesInternal.js';\n\nexport class RipgrepSearchProvider implements TextSearchProviderNew {\n\tprivate inProgress: Set<CancellationTokenSource> = new Set();\n\n\tconstructor(private outputChannel: OutputChannel, private getNumThreads: () => Promise<number | undefined>) {\n\t\tprocess.once('exit', () => this.dispose());\n\t}\n\n\tasync provideTextSearchResults(query: TextSearchQueryNew, options: TextSearchProviderOptions, progress: Progress<TextSearchResultNew>, token: CancellationToken): Promise<TextSearchCompleteNew> {\n\t\tconst numThreads = await this.getNumThreads();\n\t\tconst engine = new RipgrepTextSearchEngine(this.outputChannel, numThreads);\n\n\t\treturn Promise.all(options.folderOptions.map(folderOption => {\n\n\t\t\tconst extendedOptions: RipgrepTextSearchOptions = {\n\t\t\t\tfolderOptions: folderOption,\n\t\t\t\tnumThreads,\n\t\t\t\tmaxResults: options.maxResults,\n\t\t\t\tpreviewOptions: options.previewOptions,\n\t\t\t\tmaxFileSize: options.maxFileSize,\n\t\t\t\tsurroundingContext: options.surroundingContext\n\t\t\t};\n\t\t\tif (folderOption.folder.scheme === Schemas.vscodeUserData) {\n\t\t\t\t// Ripgrep search engine can only provide file-scheme results, but we want to use it to search some schemes that are backed by the filesystem, but with some other provider as the frontend,\n\t\t\t\t// case in point vscode-userdata. In these cases we translate the query to a file, and translate the results back to the frontend scheme.\n\t\t\t\tconst translatedOptions = { ...extendedOptions, folder: folderOption.folder.with({ scheme: Schemas.file }) };\n\t\t\t\tconst progressTranslator = new Progress<TextSearchResultNew>(data => progress.report({ ...data, uri: data.uri.with({ scheme: folderOption.folder.scheme }) }));\n\t\t\t\treturn this.withToken(token, token => engine.provideTextSearchResultsWithRgOptions(query, translatedOptions, progressTranslator, token));\n\t\t\t} else {\n\t\t\t\treturn this.withToken(token, token => engine.provideTextSearchResultsWithRgOptions(query, extendedOptions, progress, token));\n\t\t\t}\n\t\t})).then((e => {\n\t\t\tconst complete: TextSearchCompleteNew = {\n\t\t\t\t// todo: get this to actually check\n\t\t\t\tlimitHit: e.some(complete => !!complete && complete.limitHit)\n\t\t\t};\n\t\t\treturn complete;\n\t\t}));\n\n\t}\n\n\tprivate async withToken<T>(token: CancellationToken, fn: (token: CancellationToken) => Promise<T>): Promise<T> {\n\t\tconst merged = mergedTokenSource(token);\n\t\tthis.inProgress.add(merged);\n\t\tconst result = await fn(merged.token);\n\t\tthis.inProgress.delete(merged);\n\n\t\treturn result;\n\t}\n\n\tprivate dispose() {\n\t\tthis.inProgress.forEach(engine => engine.cancel());\n\t}\n}\n\nfunction mergedTokenSource(token: CancellationToken): CancellationTokenSource {\n\tconst tokenSource = new CancellationTokenSource();\n\ttoken.onCancellationRequested(() => tokenSource.cancel());\n\n\treturn tokenSource;\n}\n"],
  "mappings": ";;AAKA,SAAS,yBAAyB,yBAAyB;AAC3D,SAAS,qBAAqB;AAC9B,SAAS,+BAA+B;AACxC,SAAS,uBAAuB,uBAAuB,qBAAqB,oBAAoB,iCAAkC;AAClI,SAAS,gBAAgB;AACzB,SAAS,eAAe;AAGjB,MAAM,sBAAuD;AAAA,EAGnE,YAAoB,eAAsC,eAAkD;AAAxF;AAAsC;AACzD,YAAQ,KAAK,QAAQ,MAAM,KAAK,QAAQ,CAAC;AAAA,EAC1C;AAAA,EAlBD,OAaoE;AAAA;AAAA;AAAA,EAC3D,aAA2C,oBAAI,IAAI;AAAA,EAM3D,MAAM,yBAAyB,OAA2B,SAAoC,UAAyC,OAA0D;AAChM,UAAM,aAAa,MAAM,KAAK,cAAc;AAC5C,UAAM,SAAS,IAAI,wBAAwB,KAAK,eAAe,UAAU;AAEzE,WAAO,QAAQ,IAAI,QAAQ,cAAc,IAAI,kBAAgB;AAE5D,YAAM,kBAA4C;AAAA,QACjD,eAAe;AAAA,QACf;AAAA,QACA,YAAY,QAAQ;AAAA,QACpB,gBAAgB,QAAQ;AAAA,QACxB,aAAa,QAAQ;AAAA,QACrB,oBAAoB,QAAQ;AAAA,MAC7B;AACA,UAAI,aAAa,OAAO,WAAW,QAAQ,gBAAgB;AAG1D,cAAM,oBAAoB,EAAE,GAAG,iBAAiB,QAAQ,aAAa,OAAO,KAAK,EAAE,QAAQ,QAAQ,KAAK,CAAC,EAAE;AAC3G,cAAM,qBAAqB,IAAI,SAA8B,UAAQ,SAAS,OAAO,EAAE,GAAG,MAAM,KAAK,KAAK,IAAI,KAAK,EAAE,QAAQ,aAAa,OAAO,OAAO,CAAC,EAAE,CAAC,CAAC;AAC7J,eAAO,KAAK,UAAU,OAAO,CAAAA,WAAS,OAAO,sCAAsC,OAAO,mBAAmB,oBAAoBA,MAAK,CAAC;AAAA,MACxI,OAAO;AACN,eAAO,KAAK,UAAU,OAAO,CAAAA,WAAS,OAAO,sCAAsC,OAAO,iBAAiB,UAAUA,MAAK,CAAC;AAAA,MAC5H;AAAA,IACD,CAAC,CAAC,EAAE,KAAM,OAAK;AACd,YAAM,WAAkC;AAAA;AAAA,QAEvC,UAAU,EAAE,KAAK,CAAAC,cAAY,CAAC,CAACA,aAAYA,UAAS,QAAQ;AAAA,MAC7D;AACA,aAAO;AAAA,IACR,CAAE;AAAA,EAEH;AAAA,EAEA,MAAc,UAAa,OAA0B,IAA0D;AAC9G,UAAM,SAAS,kBAAkB,KAAK;AACtC,SAAK,WAAW,IAAI,MAAM;AAC1B,UAAM,SAAS,MAAM,GAAG,OAAO,KAAK;AACpC,SAAK,WAAW,OAAO,MAAM;AAE7B,WAAO;AAAA,EACR;AAAA,EAEQ,UAAU;AACjB,SAAK,WAAW,QAAQ,YAAU,OAAO,OAAO,CAAC;AAAA,EAClD;AACD;AAEA,SAAS,kBAAkB,OAAmD;AAC7E,QAAM,cAAc,IAAI,wBAAwB;AAChD,QAAM,wBAAwB,MAAM,YAAY,OAAO,CAAC;AAExD,SAAO;AACR;AALS;",
  "names": ["token", "complete"]
}
