import{CancellationTokenSource as u}from"../../../../../vs/base/common/cancellation.js";import{Schemas as p}from"../../../../../vs/base/common/network.js";import{Progress as T}from"../../../../../vs/platform/progress/common/progress.js";import"../../../../../vs/workbench/services/search/common/searchExtTypes.js";import"../../../../../vs/workbench/services/search/node/ripgrepSearchUtils.js";import{RipgrepTextSearchEngine as d}from"../../../../../vs/workbench/services/search/node/ripgrepTextSearchEngine.js";class b{constructor(e,t){this.outputChannel=e;this.getNumThreads=t;process.once("exit",()=>this.dispose())}inProgress=new Set;async provideTextSearchResults(e,t,r,i){const l=await this.getNumThreads(),h=new d(this.outputChannel,l);return Promise.all(t.folderOptions.map(o=>{const a={folderOptions:o,numThreads:l,maxResults:t.maxResults,previewOptions:t.previewOptions,maxFileSize:t.maxFileSize,surroundingContext:t.surroundingContext};if(o.folder.scheme===p.vscodeUserData){const n={...a,folder:o.folder.with({scheme:p.file})},m=new T(s=>r.report({...s,uri:s.uri.with({scheme:o.folder.scheme})}));return this.withToken(i,s=>h.provideTextSearchResultsWithRgOptions(e,n,m,s))}else return this.withToken(i,n=>h.provideTextSearchResultsWithRgOptions(e,a,r,n))})).then(o=>({limitHit:o.some(n=>!!n&&n.limitHit)}))}async withToken(e,t){const r=S(e);this.inProgress.add(r);const i=await t(r.token);return this.inProgress.delete(r),i}dispose(){this.inProgress.forEach(e=>e.cancel())}}function S(c){const e=new u;return c.onCancellationRequested(()=>e.cancel()),e}export{b as RipgrepSearchProvider};
