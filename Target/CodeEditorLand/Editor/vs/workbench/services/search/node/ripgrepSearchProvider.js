import{CancellationTokenSource as u}from"../../../../base/common/cancellation.js";import{RipgrepTextSearchEngine as T}from"./ripgrepTextSearchEngine.js";import{Progress as d}from"../../../../platform/progress/common/progress.js";import{Schemas as p}from"../../../../base/common/network.js";class z{constructor(e,t){this.outputChannel=e;this.getNumThreads=t;process.once("exit",()=>this.dispose())}inProgress=new Set;async provideTextSearchResults(e,t,r,i){const l=await this.getNumThreads(),h=new T(this.outputChannel,l);return Promise.all(t.folderOptions.map(o=>{const a={folderOptions:o,numThreads:l,maxResults:t.maxResults,previewOptions:t.previewOptions,maxFileSize:t.maxFileSize,surroundingContext:t.surroundingContext};if(o.folder.scheme===p.vscodeUserData){const n={...a,folder:o.folder.with({scheme:p.file})},m=new d(s=>r.report({...s,uri:s.uri.with({scheme:o.folder.scheme})}));return this.withToken(i,s=>h.provideTextSearchResultsWithRgOptions(e,n,m,s))}else return this.withToken(i,n=>h.provideTextSearchResultsWithRgOptions(e,a,r,n))})).then(o=>({limitHit:o.some(n=>!!n&&n.limitHit)}))}async withToken(e,t){const r=S(e);this.inProgress.add(r);const i=await t(r.token);return this.inProgress.delete(r),i}dispose(){this.inProgress.forEach(e=>e.cancel())}}function S(c){const e=new u;return c.onCancellationRequested(()=>e.cancel()),e}export{z as RipgrepSearchProvider};
