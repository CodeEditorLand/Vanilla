import{CancellationTokenSource as u}from"../../../../base/common/cancellation.js";import{Schemas as h}from"../../../../base/common/network.js";import{Progress as T}from"../../../../platform/progress/common/progress.js";import{RipgrepTextSearchEngine as S}from"./ripgrepTextSearchEngine.js";class v{constructor(e,t){this.outputChannel=e;this.getNumThreads=t;process.once("exit",()=>this.dispose())}inProgress=new Set;async provideTextSearchResults(e,t,r,s){const l=await this.getNumThreads(),p=new S(this.outputChannel,l);return Promise.all(t.folderOptions.map(o=>{const a={folderOptions:o,numThreads:l,maxResults:t.maxResults,previewOptions:t.previewOptions,maxFileSize:t.maxFileSize,surroundingContext:t.surroundingContext};if(o.folder.scheme===h.vscodeUserData){const n={...a,folder:o.folder.with({scheme:h.file})},m=new T(i=>r.report({...i,uri:i.uri.with({scheme:o.folder.scheme})}));return this.withToken(s,i=>p.provideTextSearchResultsWithRgOptions(e,n,m,i))}else return this.withToken(s,n=>p.provideTextSearchResultsWithRgOptions(e,a,r,n))})).then(o=>({limitHit:o.some(n=>!!n&&n.limitHit)}))}async withToken(e,t){const r=d(e);this.inProgress.add(r);const s=await t(r.token);return this.inProgress.delete(r),s}dispose(){this.inProgress.forEach(e=>e.cancel())}}function d(c){const e=new u;return c.onCancellationRequested(()=>e.cancel()),e}export{v as RipgrepSearchProvider};
