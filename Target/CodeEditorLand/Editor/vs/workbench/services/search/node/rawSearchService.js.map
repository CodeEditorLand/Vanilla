{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/search/node/rawSearchService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from '../../../../base/common/arrays.js';\nimport { CancelablePromise, createCancelablePromise } from '../../../../base/common/async.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { canceled } from '../../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { compareItemsByFuzzyScore, FuzzyScorerCache, IItemAccessor, prepareQuery } from '../../../../base/common/fuzzyScorer.js';\nimport { revive } from '../../../../base/common/marshalling.js';\nimport { basename, dirname, join, sep } from '../../../../base/common/path.js';\nimport { StopWatch } from '../../../../base/common/stopwatch.js';\nimport { URI, UriComponents } from '../../../../base/common/uri.js';\nimport { ByteSize } from '../../../../platform/files/common/files.js';\nimport { DEFAULT_MAX_SEARCH_RESULTS, ICachedSearchStats, IFileQuery, IFileSearchProgressItem, IFileSearchStats, IFolderQuery, IProgressMessage, IRawFileMatch, IRawFileQuery, IRawQuery, IRawSearchService, IRawTextQuery, ISearchEngine, ISearchEngineSuccess, ISerializedFileMatch, ISerializedSearchComplete, ISerializedSearchProgressItem, ISerializedSearchSuccess, isFilePatternMatch, ITextQuery } from '../common/search.js';\nimport { Engine as FileSearchEngine } from './fileSearch.js';\nimport { TextSearchEngineAdapter } from './textSearchAdapter.js';\n\nexport type IProgressCallback = (p: ISerializedSearchProgressItem) => void;\ntype IFileProgressCallback = (p: IFileSearchProgressItem) => void;\n\nexport class SearchService implements IRawSearchService {\n\n\tprivate static readonly BATCH_SIZE = 512;\n\n\tprivate caches: { [cacheKey: string]: Cache } = Object.create(null);\n\n\tconstructor(private readonly processType: IFileSearchStats['type'] = 'searchProcess', private readonly getNumThreads?: () => Promise<number | undefined>) { }\n\n\tfileSearch(config: IRawFileQuery): Event<ISerializedSearchProgressItem | ISerializedSearchComplete> {\n\t\tlet promise: CancelablePromise<ISerializedSearchSuccess>;\n\n\t\tconst query = reviveQuery(config);\n\t\tconst emitter = new Emitter<ISerializedSearchProgressItem | ISerializedSearchComplete>({\n\t\t\tonDidAddFirstListener: () => {\n\t\t\t\tpromise = createCancelablePromise(async token => {\n\t\t\t\t\tconst numThreads = await this.getNumThreads?.();\n\t\t\t\t\treturn this.doFileSearchWithEngine(FileSearchEngine, query, p => emitter.fire(p), token, SearchService.BATCH_SIZE, numThreads);\n\t\t\t\t});\n\n\t\t\t\tpromise.then(\n\t\t\t\t\tc => emitter.fire(c),\n\t\t\t\t\terr => emitter.fire({ type: 'error', error: { message: err.message, stack: err.stack } }));\n\t\t\t},\n\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\tpromise.cancel();\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\ttextSearch(rawQuery: IRawTextQuery): Event<ISerializedSearchProgressItem | ISerializedSearchComplete> {\n\t\tlet promise: CancelablePromise<ISerializedSearchComplete>;\n\n\t\tconst query = reviveQuery(rawQuery);\n\t\tconst emitter = new Emitter<ISerializedSearchProgressItem | ISerializedSearchComplete>({\n\t\t\tonDidAddFirstListener: () => {\n\t\t\t\tpromise = createCancelablePromise(token => {\n\t\t\t\t\treturn this.ripgrepTextSearch(query, p => emitter.fire(p), token);\n\t\t\t\t});\n\n\t\t\t\tpromise.then(\n\t\t\t\t\tc => emitter.fire(c),\n\t\t\t\t\terr => emitter.fire({ type: 'error', error: { message: err.message, stack: err.stack } }));\n\t\t\t},\n\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\tpromise.cancel();\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\tprivate async ripgrepTextSearch(config: ITextQuery, progressCallback: IProgressCallback, token: CancellationToken): Promise<ISerializedSearchSuccess> {\n\t\tconfig.maxFileSize = this.getPlatformFileLimits().maxFileSize;\n\t\tconst numThreads = await this.getNumThreads?.();\n\t\tconst engine = new TextSearchEngineAdapter(config, numThreads);\n\n\t\treturn engine.search(token, progressCallback, progressCallback);\n\t}\n\n\tprivate getPlatformFileLimits(): { readonly maxFileSize: number } {\n\t\treturn {\n\t\t\tmaxFileSize: 16 * ByteSize.GB\n\t\t};\n\t}\n\n\tdoFileSearch(config: IFileQuery, numThreads: number | undefined, progressCallback: IProgressCallback, token?: CancellationToken): Promise<ISerializedSearchSuccess> {\n\t\treturn this.doFileSearchWithEngine(FileSearchEngine, config, progressCallback, token, SearchService.BATCH_SIZE, numThreads);\n\t}\n\n\tdoFileSearchWithEngine(EngineClass: { new(config: IFileQuery, numThreads?: number | undefined): ISearchEngine<IRawFileMatch> }, config: IFileQuery, progressCallback: IProgressCallback, token?: CancellationToken, batchSize = SearchService.BATCH_SIZE, threads?: number): Promise<ISerializedSearchSuccess> {\n\t\tlet resultCount = 0;\n\t\tconst fileProgressCallback: IFileProgressCallback = progress => {\n\t\t\tif (Array.isArray(progress)) {\n\t\t\t\tresultCount += progress.length;\n\t\t\t\tprogressCallback(progress.map(m => this.rawMatchToSearchItem(m)));\n\t\t\t} else if ((<IRawFileMatch>progress).relativePath) {\n\t\t\t\tresultCount++;\n\t\t\t\tprogressCallback(this.rawMatchToSearchItem(<IRawFileMatch>progress));\n\t\t\t} else {\n\t\t\t\tprogressCallback(<IProgressMessage>progress);\n\t\t\t}\n\t\t};\n\n\t\tif (config.sortByScore) {\n\t\t\tlet sortedSearch = this.trySortedSearchFromCache(config, fileProgressCallback, token);\n\t\t\tif (!sortedSearch) {\n\t\t\t\tconst walkerConfig = config.maxResults ? Object.assign({}, config, { maxResults: null }) : config;\n\t\t\t\tconst engine = new EngineClass(walkerConfig, threads);\n\t\t\t\tsortedSearch = this.doSortedSearch(engine, config, progressCallback, fileProgressCallback, token);\n\t\t\t}\n\n\t\t\treturn new Promise<ISerializedSearchSuccess>((c, e) => {\n\t\t\t\tsortedSearch.then(([result, rawMatches]) => {\n\t\t\t\t\tconst serializedMatches = rawMatches.map(rawMatch => this.rawMatchToSearchItem(rawMatch));\n\t\t\t\t\tthis.sendProgress(serializedMatches, progressCallback, batchSize);\n\t\t\t\t\tc(result);\n\t\t\t\t}, e);\n\t\t\t});\n\t\t}\n\n\t\tconst engine = new EngineClass(config, threads);\n\n\t\treturn this.doSearch(engine, fileProgressCallback, batchSize, token).then(complete => {\n\t\t\treturn {\n\t\t\t\tlimitHit: complete.limitHit,\n\t\t\t\ttype: 'success',\n\t\t\t\tstats: {\n\t\t\t\t\tdetailStats: complete.stats,\n\t\t\t\t\ttype: this.processType,\n\t\t\t\t\tfromCache: false,\n\t\t\t\t\tresultCount,\n\t\t\t\t\tsortingTime: undefined\n\t\t\t\t},\n\t\t\t\tmessages: []\n\t\t\t};\n\t\t});\n\t}\n\n\tprivate rawMatchToSearchItem(match: IRawFileMatch): ISerializedFileMatch {\n\t\treturn { path: match.base ? join(match.base, match.relativePath) : match.relativePath };\n\t}\n\n\tprivate doSortedSearch(engine: ISearchEngine<IRawFileMatch>, config: IFileQuery, progressCallback: IProgressCallback, fileProgressCallback: IFileProgressCallback, token?: CancellationToken): Promise<[ISerializedSearchSuccess, IRawFileMatch[]]> {\n\t\tconst emitter = new Emitter<IFileSearchProgressItem>();\n\n\t\tlet allResultsPromise = createCancelablePromise(token => {\n\t\t\tlet results: IRawFileMatch[] = [];\n\n\t\t\tconst innerProgressCallback: IFileProgressCallback = progress => {\n\t\t\t\tif (Array.isArray(progress)) {\n\t\t\t\t\tresults = progress;\n\t\t\t\t} else {\n\t\t\t\t\tfileProgressCallback(progress);\n\t\t\t\t\temitter.fire(progress);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\treturn this.doSearch(engine, innerProgressCallback, -1, token)\n\t\t\t\t.then<[ISearchEngineSuccess, IRawFileMatch[]]>(result => {\n\t\t\t\t\treturn [result, results];\n\t\t\t\t});\n\t\t});\n\n\t\tlet cache: Cache;\n\t\tif (config.cacheKey) {\n\t\t\tcache = this.getOrCreateCache(config.cacheKey);\n\t\t\tconst cacheRow: ICacheRow = {\n\t\t\t\tpromise: allResultsPromise,\n\t\t\t\tevent: emitter.event,\n\t\t\t\tresolved: false\n\t\t\t};\n\t\t\tcache.resultsToSearchCache[config.filePattern || ''] = cacheRow;\n\t\t\tallResultsPromise.then(() => {\n\t\t\t\tcacheRow.resolved = true;\n\t\t\t}, err => {\n\t\t\t\tdelete cache.resultsToSearchCache[config.filePattern || ''];\n\t\t\t});\n\n\t\t\tallResultsPromise = this.preventCancellation(allResultsPromise);\n\t\t}\n\n\t\treturn allResultsPromise.then(([result, results]) => {\n\t\t\tconst scorerCache: FuzzyScorerCache = cache ? cache.scorerCache : Object.create(null);\n\t\t\tconst sortSW = (typeof config.maxResults !== 'number' || config.maxResults > 0) && StopWatch.create(false);\n\t\t\treturn this.sortResults(config, results, scorerCache, token)\n\t\t\t\t.then<[ISerializedSearchSuccess, IRawFileMatch[]]>(sortedResults => {\n\t\t\t\t\t// sortingTime: -1 indicates a \"sorted\" search that was not sorted, i.e. populating the cache when quickaccess is opened.\n\t\t\t\t\t// Contrasting with findFiles which is not sorted and will have sortingTime: undefined\n\t\t\t\t\tconst sortingTime = sortSW ? sortSW.elapsed() : -1;\n\n\t\t\t\t\treturn [{\n\t\t\t\t\t\ttype: 'success',\n\t\t\t\t\t\tstats: {\n\t\t\t\t\t\t\tdetailStats: result.stats,\n\t\t\t\t\t\t\tsortingTime,\n\t\t\t\t\t\t\tfromCache: false,\n\t\t\t\t\t\t\ttype: this.processType,\n\t\t\t\t\t\t\tresultCount: sortedResults.length\n\t\t\t\t\t\t},\n\t\t\t\t\t\tmessages: result.messages,\n\t\t\t\t\t\tlimitHit: result.limitHit || typeof config.maxResults === 'number' && results.length > config.maxResults\n\t\t\t\t\t}, sortedResults];\n\t\t\t\t});\n\t\t});\n\t}\n\n\tprivate getOrCreateCache(cacheKey: string): Cache {\n\t\tconst existing = this.caches[cacheKey];\n\t\tif (existing) {\n\t\t\treturn existing;\n\t\t}\n\t\treturn this.caches[cacheKey] = new Cache();\n\t}\n\n\tprivate trySortedSearchFromCache(config: IFileQuery, progressCallback: IFileProgressCallback, token?: CancellationToken): Promise<[ISerializedSearchSuccess, IRawFileMatch[]]> | undefined {\n\t\tconst cache = config.cacheKey && this.caches[config.cacheKey];\n\t\tif (!cache) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst cached = this.getResultsFromCache(cache, config.filePattern || '', progressCallback, token);\n\t\tif (cached) {\n\t\t\treturn cached.then(([result, results, cacheStats]) => {\n\t\t\t\tconst sortSW = StopWatch.create(false);\n\t\t\t\treturn this.sortResults(config, results, cache.scorerCache, token)\n\t\t\t\t\t.then<[ISerializedSearchSuccess, IRawFileMatch[]]>(sortedResults => {\n\t\t\t\t\t\tconst sortingTime = sortSW.elapsed();\n\t\t\t\t\t\tconst stats: IFileSearchStats = {\n\t\t\t\t\t\t\tfromCache: true,\n\t\t\t\t\t\t\tdetailStats: cacheStats,\n\t\t\t\t\t\t\ttype: this.processType,\n\t\t\t\t\t\t\tresultCount: results.length,\n\t\t\t\t\t\t\tsortingTime\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttype: 'success',\n\t\t\t\t\t\t\t\tlimitHit: result.limitHit || typeof config.maxResults === 'number' && results.length > config.maxResults,\n\t\t\t\t\t\t\t\tstats,\n\t\t\t\t\t\t\t\tmessages: [],\n\t\t\t\t\t\t\t} satisfies ISerializedSearchSuccess,\n\t\t\t\t\t\t\tsortedResults\n\t\t\t\t\t\t];\n\t\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tprivate sortResults(config: IFileQuery, results: IRawFileMatch[], scorerCache: FuzzyScorerCache, token?: CancellationToken): Promise<IRawFileMatch[]> {\n\t\t// we use the same compare function that is used later when showing the results using fuzzy scoring\n\t\t// this is very important because we are also limiting the number of results by config.maxResults\n\t\t// and as such we want the top items to be included in this result set if the number of items\n\t\t// exceeds config.maxResults.\n\t\tconst query = prepareQuery(config.filePattern || '');\n\t\tconst compare = (matchA: IRawFileMatch, matchB: IRawFileMatch) => compareItemsByFuzzyScore(matchA, matchB, query, true, FileMatchItemAccessor, scorerCache);\n\n\t\tconst maxResults = typeof config.maxResults === 'number' ? config.maxResults : DEFAULT_MAX_SEARCH_RESULTS;\n\t\treturn arrays.topAsync(results, compare, maxResults, 10000, token);\n\t}\n\n\tprivate sendProgress(results: ISerializedFileMatch[], progressCb: IProgressCallback, batchSize: number) {\n\t\tif (batchSize && batchSize > 0) {\n\t\t\tfor (let i = 0; i < results.length; i += batchSize) {\n\t\t\t\tprogressCb(results.slice(i, i + batchSize));\n\t\t\t}\n\t\t} else {\n\t\t\tprogressCb(results);\n\t\t}\n\t}\n\n\tprivate getResultsFromCache(cache: Cache, searchValue: string, progressCallback: IFileProgressCallback, token?: CancellationToken): Promise<[ISearchEngineSuccess, IRawFileMatch[], ICachedSearchStats]> | null {\n\t\tconst cacheLookupSW = StopWatch.create(false);\n\n\t\t// Find cache entries by prefix of search value\n\t\tconst hasPathSep = searchValue.indexOf(sep) >= 0;\n\t\tlet cachedRow: ICacheRow | undefined;\n\t\tfor (const previousSearch in cache.resultsToSearchCache) {\n\t\t\t// If we narrow down, we might be able to reuse the cached results\n\t\t\tif (searchValue.startsWith(previousSearch)) {\n\t\t\t\tif (hasPathSep && previousSearch.indexOf(sep) < 0 && previousSearch !== '') {\n\t\t\t\t\tcontinue; // since a path character widens the search for potential more matches, require it in previous search too\n\t\t\t\t}\n\n\t\t\t\tconst row = cache.resultsToSearchCache[previousSearch];\n\t\t\t\tcachedRow = {\n\t\t\t\t\tpromise: this.preventCancellation(row.promise),\n\t\t\t\t\tevent: row.event,\n\t\t\t\t\tresolved: row.resolved\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!cachedRow) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst cacheLookupTime = cacheLookupSW.elapsed();\n\t\tconst cacheFilterSW = StopWatch.create(false);\n\n\t\tconst listener = cachedRow.event(progressCallback);\n\t\tif (token) {\n\t\t\ttoken.onCancellationRequested(() => {\n\t\t\t\tlistener.dispose();\n\t\t\t});\n\t\t}\n\n\t\treturn cachedRow.promise.then<[ISearchEngineSuccess, IRawFileMatch[], ICachedSearchStats]>(([complete, cachedEntries]) => {\n\t\t\tif (token && token.isCancellationRequested) {\n\t\t\t\tthrow canceled();\n\t\t\t}\n\n\t\t\t// Pattern match on results\n\t\t\tconst results: IRawFileMatch[] = [];\n\t\t\tconst normalizedSearchValueLowercase = prepareQuery(searchValue).normalizedLowercase;\n\t\t\tfor (const entry of cachedEntries) {\n\n\t\t\t\t// Check if this entry is a match for the search value\n\t\t\t\tif (!isFilePatternMatch(entry, normalizedSearchValueLowercase)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tresults.push(entry);\n\t\t\t}\n\n\t\t\treturn [complete, results, {\n\t\t\t\tcacheWasResolved: cachedRow.resolved,\n\t\t\t\tcacheLookupTime,\n\t\t\t\tcacheFilterTime: cacheFilterSW.elapsed(),\n\t\t\t\tcacheEntryCount: cachedEntries.length\n\t\t\t}];\n\t\t});\n\t}\n\n\n\n\tprivate doSearch(engine: ISearchEngine<IRawFileMatch>, progressCallback: IFileProgressCallback, batchSize: number, token?: CancellationToken): Promise<ISearchEngineSuccess> {\n\t\treturn new Promise<ISearchEngineSuccess>((c, e) => {\n\t\t\tlet batch: IRawFileMatch[] = [];\n\t\t\ttoken?.onCancellationRequested(() => engine.cancel());\n\n\t\t\tengine.search((match) => {\n\t\t\t\tif (match) {\n\t\t\t\t\tif (batchSize) {\n\t\t\t\t\t\tbatch.push(match);\n\t\t\t\t\t\tif (batchSize > 0 && batch.length >= batchSize) {\n\t\t\t\t\t\t\tprogressCallback(batch);\n\t\t\t\t\t\t\tbatch = [];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprogressCallback(match);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, (progress) => {\n\t\t\t\tprogressCallback(progress);\n\t\t\t}, (error, complete) => {\n\t\t\t\tif (batch.length) {\n\t\t\t\t\tprogressCallback(batch);\n\t\t\t\t}\n\n\t\t\t\tif (error) {\n\t\t\t\t\tprogressCallback({ message: 'Search finished. Error: ' + error.message });\n\t\t\t\t\te(error);\n\t\t\t\t} else {\n\t\t\t\t\tprogressCallback({ message: 'Search finished. Stats: ' + JSON.stringify(complete.stats) });\n\t\t\t\t\tc(complete);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tclearCache(cacheKey: string): Promise<void> {\n\t\tdelete this.caches[cacheKey];\n\t\treturn Promise.resolve(undefined);\n\t}\n\n\t/**\n\t * Return a CancelablePromise which is not actually cancelable\n\t * TODO@rob - Is this really needed?\n\t */\n\tprivate preventCancellation<C>(promise: CancelablePromise<C>): CancelablePromise<C> {\n\t\treturn new class implements CancelablePromise<C> {\n\t\t\tget [Symbol.toStringTag]() { return this.toString(); }\n\t\t\tcancel() {\n\t\t\t\t// Do nothing\n\t\t\t}\n\t\t\tthen<TResult1 = C, TResult2 = never>(resolve?: ((value: C) => TResult1 | Promise<TResult1>) | undefined | null, reject?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2> {\n\t\t\t\treturn promise.then(resolve, reject);\n\t\t\t}\n\t\t\tcatch(reject?: any) {\n\t\t\t\treturn this.then(undefined, reject);\n\t\t\t}\n\t\t\tfinally(onFinally: any) {\n\t\t\t\treturn promise.finally(onFinally);\n\t\t\t}\n\t\t};\n\t}\n}\n\ninterface ICacheRow {\n\t// TODO@roblou - never actually canceled\n\tpromise: CancelablePromise<[ISearchEngineSuccess, IRawFileMatch[]]>;\n\tresolved: boolean;\n\tevent: Event<IFileSearchProgressItem>;\n}\n\nclass Cache {\n\n\tresultsToSearchCache: { [searchValue: string]: ICacheRow } = Object.create(null);\n\n\tscorerCache: FuzzyScorerCache = Object.create(null);\n}\n\nconst FileMatchItemAccessor = new class implements IItemAccessor<IRawFileMatch> {\n\n\tgetItemLabel(match: IRawFileMatch): string {\n\t\treturn basename(match.relativePath); // e.g. myFile.txt\n\t}\n\n\tgetItemDescription(match: IRawFileMatch): string {\n\t\treturn dirname(match.relativePath); // e.g. some/path/to/file\n\t}\n\n\tgetItemPath(match: IRawFileMatch): string {\n\t\treturn match.relativePath; // e.g. some/path/to/file/myFile.txt\n\t}\n};\n\nfunction reviveQuery<U extends IRawQuery>(rawQuery: U): U extends IRawTextQuery ? ITextQuery : IFileQuery {\n\treturn {\n\t\t...<any>rawQuery, // TODO\n\t\t...{\n\t\t\tfolderQueries: rawQuery.folderQueries && rawQuery.folderQueries.map(reviveFolderQuery),\n\t\t\textraFileResources: rawQuery.extraFileResources && rawQuery.extraFileResources.map(components => URI.revive(components))\n\t\t}\n\t};\n}\n\nfunction reviveFolderQuery(rawFolderQuery: IFolderQuery<UriComponents>): IFolderQuery<URI> {\n\treturn revive(rawFolderQuery);\n}\n"],
  "mappings": "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",
  "names": ["engine", "token"]
}
