{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/search/node/rawSearchService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from \"../../../../base/common/arrays.js\";\nimport {\n\ttype CancelablePromise,\n\tcreateCancelablePromise,\n} from \"../../../../base/common/async.js\";\nimport type { CancellationToken } from \"../../../../base/common/cancellation.js\";\nimport { canceled } from \"../../../../base/common/errors.js\";\nimport { Emitter, type Event } from \"../../../../base/common/event.js\";\nimport {\n\ttype FuzzyScorerCache,\n\ttype IItemAccessor,\n\tcompareItemsByFuzzyScore,\n\tprepareQuery,\n} from \"../../../../base/common/fuzzyScorer.js\";\nimport { revive } from \"../../../../base/common/marshalling.js\";\nimport { basename, dirname, join, sep } from \"../../../../base/common/path.js\";\nimport { StopWatch } from \"../../../../base/common/stopwatch.js\";\nimport { URI, type UriComponents } from \"../../../../base/common/uri.js\";\nimport { ByteSize } from \"../../../../platform/files/common/files.js\";\nimport {\n\tDEFAULT_MAX_SEARCH_RESULTS,\n\ttype ICachedSearchStats,\n\ttype IFileQuery,\n\ttype IFileSearchProgressItem,\n\ttype IFileSearchStats,\n\ttype IFolderQuery,\n\ttype IProgressMessage,\n\ttype IRawFileMatch,\n\ttype IRawFileQuery,\n\ttype IRawQuery,\n\ttype IRawSearchService,\n\ttype IRawTextQuery,\n\ttype ISearchEngine,\n\ttype ISearchEngineSuccess,\n\ttype ISerializedFileMatch,\n\ttype ISerializedSearchComplete,\n\ttype ISerializedSearchProgressItem,\n\ttype ISerializedSearchSuccess,\n\ttype ITextQuery,\n\tisFilePatternMatch,\n} from \"../common/search.js\";\nimport { Engine as FileSearchEngine } from \"./fileSearch.js\";\nimport { TextSearchEngineAdapter } from \"./textSearchAdapter.js\";\n\nexport type IProgressCallback = (p: ISerializedSearchProgressItem) => void;\ntype IFileProgressCallback = (p: IFileSearchProgressItem) => void;\n\nexport class SearchService implements IRawSearchService {\n\tprivate static readonly BATCH_SIZE = 512;\n\n\tprivate caches: { [cacheKey: string]: Cache } = Object.create(null);\n\n\tconstructor(\n\t\tprivate readonly processType: IFileSearchStats[\"type\"] = \"searchProcess\",\n\t\tprivate readonly getNumThreads?: () => Promise<number | undefined>,\n\t) {}\n\n\tfileSearch(\n\t\tconfig: IRawFileQuery,\n\t): Event<ISerializedSearchProgressItem | ISerializedSearchComplete> {\n\t\tlet promise: CancelablePromise<ISerializedSearchSuccess>;\n\n\t\tconst query = reviveQuery(config);\n\t\tconst emitter = new Emitter<\n\t\t\tISerializedSearchProgressItem | ISerializedSearchComplete\n\t\t>({\n\t\t\tonDidAddFirstListener: () => {\n\t\t\t\tpromise = createCancelablePromise(async (token) => {\n\t\t\t\t\tconst numThreads = await this.getNumThreads?.();\n\t\t\t\t\treturn this.doFileSearchWithEngine(\n\t\t\t\t\t\tFileSearchEngine,\n\t\t\t\t\t\tquery,\n\t\t\t\t\t\t(p) => emitter.fire(p),\n\t\t\t\t\t\ttoken,\n\t\t\t\t\t\tSearchService.BATCH_SIZE,\n\t\t\t\t\t\tnumThreads,\n\t\t\t\t\t);\n\t\t\t\t});\n\n\t\t\t\tpromise.then(\n\t\t\t\t\t(c) => emitter.fire(c),\n\t\t\t\t\t(err) =>\n\t\t\t\t\t\temitter.fire({\n\t\t\t\t\t\t\ttype: \"error\",\n\t\t\t\t\t\t\terror: { message: err.message, stack: err.stack },\n\t\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t},\n\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\tpromise.cancel();\n\t\t\t},\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\ttextSearch(\n\t\trawQuery: IRawTextQuery,\n\t): Event<ISerializedSearchProgressItem | ISerializedSearchComplete> {\n\t\tlet promise: CancelablePromise<ISerializedSearchComplete>;\n\n\t\tconst query = reviveQuery(rawQuery);\n\t\tconst emitter = new Emitter<\n\t\t\tISerializedSearchProgressItem | ISerializedSearchComplete\n\t\t>({\n\t\t\tonDidAddFirstListener: () => {\n\t\t\t\tpromise = createCancelablePromise((token) => {\n\t\t\t\t\treturn this.ripgrepTextSearch(\n\t\t\t\t\t\tquery,\n\t\t\t\t\t\t(p) => emitter.fire(p),\n\t\t\t\t\t\ttoken,\n\t\t\t\t\t);\n\t\t\t\t});\n\n\t\t\t\tpromise.then(\n\t\t\t\t\t(c) => emitter.fire(c),\n\t\t\t\t\t(err) =>\n\t\t\t\t\t\temitter.fire({\n\t\t\t\t\t\t\ttype: \"error\",\n\t\t\t\t\t\t\terror: { message: err.message, stack: err.stack },\n\t\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t},\n\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\tpromise.cancel();\n\t\t\t},\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\tprivate async ripgrepTextSearch(\n\t\tconfig: ITextQuery,\n\t\tprogressCallback: IProgressCallback,\n\t\ttoken: CancellationToken,\n\t): Promise<ISerializedSearchSuccess> {\n\t\tconfig.maxFileSize = this.getPlatformFileLimits().maxFileSize;\n\t\tconst numThreads = await this.getNumThreads?.();\n\t\tconst engine = new TextSearchEngineAdapter(config, numThreads);\n\n\t\treturn engine.search(token, progressCallback, progressCallback);\n\t}\n\n\tprivate getPlatformFileLimits(): { readonly maxFileSize: number } {\n\t\treturn {\n\t\t\tmaxFileSize: 16 * ByteSize.GB,\n\t\t};\n\t}\n\n\tdoFileSearch(\n\t\tconfig: IFileQuery,\n\t\tnumThreads: number | undefined,\n\t\tprogressCallback: IProgressCallback,\n\t\ttoken?: CancellationToken,\n\t): Promise<ISerializedSearchSuccess> {\n\t\treturn this.doFileSearchWithEngine(\n\t\t\tFileSearchEngine,\n\t\t\tconfig,\n\t\t\tprogressCallback,\n\t\t\ttoken,\n\t\t\tSearchService.BATCH_SIZE,\n\t\t\tnumThreads,\n\t\t);\n\t}\n\n\tdoFileSearchWithEngine(\n\t\tEngineClass: {\n\t\t\tnew (\n\t\t\t\tconfig: IFileQuery,\n\t\t\t\tnumThreads?: number | undefined,\n\t\t\t): ISearchEngine<IRawFileMatch>;\n\t\t},\n\t\tconfig: IFileQuery,\n\t\tprogressCallback: IProgressCallback,\n\t\ttoken?: CancellationToken,\n\t\tbatchSize = SearchService.BATCH_SIZE,\n\t\tthreads?: number,\n\t): Promise<ISerializedSearchSuccess> {\n\t\tlet resultCount = 0;\n\t\tconst fileProgressCallback: IFileProgressCallback = (progress) => {\n\t\t\tif (Array.isArray(progress)) {\n\t\t\t\tresultCount += progress.length;\n\t\t\t\tprogressCallback(\n\t\t\t\t\tprogress.map((m) => this.rawMatchToSearchItem(m)),\n\t\t\t\t);\n\t\t\t} else if ((<IRawFileMatch>progress).relativePath) {\n\t\t\t\tresultCount++;\n\t\t\t\tprogressCallback(\n\t\t\t\t\tthis.rawMatchToSearchItem(<IRawFileMatch>progress),\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tprogressCallback(<IProgressMessage>progress);\n\t\t\t}\n\t\t};\n\n\t\tif (config.sortByScore) {\n\t\t\tlet sortedSearch = this.trySortedSearchFromCache(\n\t\t\t\tconfig,\n\t\t\t\tfileProgressCallback,\n\t\t\t\ttoken,\n\t\t\t);\n\t\t\tif (!sortedSearch) {\n\t\t\t\tconst walkerConfig = config.maxResults\n\t\t\t\t\t? Object.assign({}, config, { maxResults: null })\n\t\t\t\t\t: config;\n\t\t\t\tconst engine = new EngineClass(walkerConfig, threads);\n\t\t\t\tsortedSearch = this.doSortedSearch(\n\t\t\t\t\tengine,\n\t\t\t\t\tconfig,\n\t\t\t\t\tprogressCallback,\n\t\t\t\t\tfileProgressCallback,\n\t\t\t\t\ttoken,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn new Promise<ISerializedSearchSuccess>((c, e) => {\n\t\t\t\tsortedSearch.then(([result, rawMatches]) => {\n\t\t\t\t\tconst serializedMatches = rawMatches.map((rawMatch) =>\n\t\t\t\t\t\tthis.rawMatchToSearchItem(rawMatch),\n\t\t\t\t\t);\n\t\t\t\t\tthis.sendProgress(\n\t\t\t\t\t\tserializedMatches,\n\t\t\t\t\t\tprogressCallback,\n\t\t\t\t\t\tbatchSize,\n\t\t\t\t\t);\n\t\t\t\t\tc(result);\n\t\t\t\t}, e);\n\t\t\t});\n\t\t}\n\n\t\tconst engine = new EngineClass(config, threads);\n\n\t\treturn this.doSearch(\n\t\t\tengine,\n\t\t\tfileProgressCallback,\n\t\t\tbatchSize,\n\t\t\ttoken,\n\t\t).then((complete) => {\n\t\t\treturn {\n\t\t\t\tlimitHit: complete.limitHit,\n\t\t\t\ttype: \"success\",\n\t\t\t\tstats: {\n\t\t\t\t\tdetailStats: complete.stats,\n\t\t\t\t\ttype: this.processType,\n\t\t\t\t\tfromCache: false,\n\t\t\t\t\tresultCount,\n\t\t\t\t\tsortingTime: undefined,\n\t\t\t\t},\n\t\t\t\tmessages: [],\n\t\t\t};\n\t\t});\n\t}\n\n\tprivate rawMatchToSearchItem(match: IRawFileMatch): ISerializedFileMatch {\n\t\treturn {\n\t\t\tpath: match.base\n\t\t\t\t? join(match.base, match.relativePath)\n\t\t\t\t: match.relativePath,\n\t\t};\n\t}\n\n\tprivate doSortedSearch(\n\t\tengine: ISearchEngine<IRawFileMatch>,\n\t\tconfig: IFileQuery,\n\t\tprogressCallback: IProgressCallback,\n\t\tfileProgressCallback: IFileProgressCallback,\n\t\ttoken?: CancellationToken,\n\t): Promise<[ISerializedSearchSuccess, IRawFileMatch[]]> {\n\t\tconst emitter = new Emitter<IFileSearchProgressItem>();\n\n\t\tlet allResultsPromise = createCancelablePromise((token) => {\n\t\t\tlet results: IRawFileMatch[] = [];\n\n\t\t\tconst innerProgressCallback: IFileProgressCallback = (progress) => {\n\t\t\t\tif (Array.isArray(progress)) {\n\t\t\t\t\tresults = progress;\n\t\t\t\t} else {\n\t\t\t\t\tfileProgressCallback(progress);\n\t\t\t\t\temitter.fire(progress);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\treturn this.doSearch(engine, innerProgressCallback, -1, token).then<\n\t\t\t\t[ISearchEngineSuccess, IRawFileMatch[]]\n\t\t\t>((result) => {\n\t\t\t\treturn [result, results];\n\t\t\t});\n\t\t});\n\n\t\tlet cache: Cache;\n\t\tif (config.cacheKey) {\n\t\t\tcache = this.getOrCreateCache(config.cacheKey);\n\t\t\tconst cacheRow: ICacheRow = {\n\t\t\t\tpromise: allResultsPromise,\n\t\t\t\tevent: emitter.event,\n\t\t\t\tresolved: false,\n\t\t\t};\n\t\t\tcache.resultsToSearchCache[config.filePattern || \"\"] = cacheRow;\n\t\t\tallResultsPromise.then(\n\t\t\t\t() => {\n\t\t\t\t\tcacheRow.resolved = true;\n\t\t\t\t},\n\t\t\t\t(err) => {\n\t\t\t\t\tdelete cache.resultsToSearchCache[config.filePattern || \"\"];\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tallResultsPromise = this.preventCancellation(allResultsPromise);\n\t\t}\n\n\t\treturn allResultsPromise.then(([result, results]) => {\n\t\t\tconst scorerCache: FuzzyScorerCache = cache\n\t\t\t\t? cache.scorerCache\n\t\t\t\t: Object.create(null);\n\t\t\tconst sortSW =\n\t\t\t\t(typeof config.maxResults !== \"number\" ||\n\t\t\t\t\tconfig.maxResults > 0) &&\n\t\t\t\tStopWatch.create(false);\n\t\t\treturn this.sortResults(config, results, scorerCache, token).then<\n\t\t\t\t[ISerializedSearchSuccess, IRawFileMatch[]]\n\t\t\t>((sortedResults) => {\n\t\t\t\t// sortingTime: -1 indicates a \"sorted\" search that was not sorted, i.e. populating the cache when quickaccess is opened.\n\t\t\t\t// Contrasting with findFiles which is not sorted and will have sortingTime: undefined\n\t\t\t\tconst sortingTime = sortSW ? sortSW.elapsed() : -1;\n\n\t\t\t\treturn [\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: \"success\",\n\t\t\t\t\t\tstats: {\n\t\t\t\t\t\t\tdetailStats: result.stats,\n\t\t\t\t\t\t\tsortingTime,\n\t\t\t\t\t\t\tfromCache: false,\n\t\t\t\t\t\t\ttype: this.processType,\n\t\t\t\t\t\t\tresultCount: sortedResults.length,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tmessages: result.messages,\n\t\t\t\t\t\tlimitHit:\n\t\t\t\t\t\t\tresult.limitHit ||\n\t\t\t\t\t\t\t(typeof config.maxResults === \"number\" &&\n\t\t\t\t\t\t\t\tresults.length > config.maxResults),\n\t\t\t\t\t},\n\t\t\t\t\tsortedResults,\n\t\t\t\t];\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate getOrCreateCache(cacheKey: string): Cache {\n\t\tconst existing = this.caches[cacheKey];\n\t\tif (existing) {\n\t\t\treturn existing;\n\t\t}\n\t\treturn (this.caches[cacheKey] = new Cache());\n\t}\n\n\tprivate trySortedSearchFromCache(\n\t\tconfig: IFileQuery,\n\t\tprogressCallback: IFileProgressCallback,\n\t\ttoken?: CancellationToken,\n\t): Promise<[ISerializedSearchSuccess, IRawFileMatch[]]> | undefined {\n\t\tconst cache = config.cacheKey && this.caches[config.cacheKey];\n\t\tif (!cache) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst cached = this.getResultsFromCache(\n\t\t\tcache,\n\t\t\tconfig.filePattern || \"\",\n\t\t\tprogressCallback,\n\t\t\ttoken,\n\t\t);\n\t\tif (cached) {\n\t\t\treturn cached.then(([result, results, cacheStats]) => {\n\t\t\t\tconst sortSW = StopWatch.create(false);\n\t\t\t\treturn this.sortResults(\n\t\t\t\t\tconfig,\n\t\t\t\t\tresults,\n\t\t\t\t\tcache.scorerCache,\n\t\t\t\t\ttoken,\n\t\t\t\t).then<[ISerializedSearchSuccess, IRawFileMatch[]]>(\n\t\t\t\t\t(sortedResults) => {\n\t\t\t\t\t\tconst sortingTime = sortSW.elapsed();\n\t\t\t\t\t\tconst stats: IFileSearchStats = {\n\t\t\t\t\t\t\tfromCache: true,\n\t\t\t\t\t\t\tdetailStats: cacheStats,\n\t\t\t\t\t\t\ttype: this.processType,\n\t\t\t\t\t\t\tresultCount: results.length,\n\t\t\t\t\t\t\tsortingTime,\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttype: \"success\",\n\t\t\t\t\t\t\t\tlimitHit:\n\t\t\t\t\t\t\t\t\tresult.limitHit ||\n\t\t\t\t\t\t\t\t\t(typeof config.maxResults === \"number\" &&\n\t\t\t\t\t\t\t\t\t\tresults.length > config.maxResults),\n\t\t\t\t\t\t\t\tstats,\n\t\t\t\t\t\t\t\tmessages: [],\n\t\t\t\t\t\t\t} satisfies ISerializedSearchSuccess,\n\t\t\t\t\t\t\tsortedResults,\n\t\t\t\t\t\t];\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t});\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tprivate sortResults(\n\t\tconfig: IFileQuery,\n\t\tresults: IRawFileMatch[],\n\t\tscorerCache: FuzzyScorerCache,\n\t\ttoken?: CancellationToken,\n\t): Promise<IRawFileMatch[]> {\n\t\t// we use the same compare function that is used later when showing the results using fuzzy scoring\n\t\t// this is very important because we are also limiting the number of results by config.maxResults\n\t\t// and as such we want the top items to be included in this result set if the number of items\n\t\t// exceeds config.maxResults.\n\t\tconst query = prepareQuery(config.filePattern || \"\");\n\t\tconst compare = (matchA: IRawFileMatch, matchB: IRawFileMatch) =>\n\t\t\tcompareItemsByFuzzyScore(\n\t\t\t\tmatchA,\n\t\t\t\tmatchB,\n\t\t\t\tquery,\n\t\t\t\ttrue,\n\t\t\t\tFileMatchItemAccessor,\n\t\t\t\tscorerCache,\n\t\t\t);\n\n\t\tconst maxResults =\n\t\t\ttypeof config.maxResults === \"number\"\n\t\t\t\t? config.maxResults\n\t\t\t\t: DEFAULT_MAX_SEARCH_RESULTS;\n\t\treturn arrays.topAsync(results, compare, maxResults, 10000, token);\n\t}\n\n\tprivate sendProgress(\n\t\tresults: ISerializedFileMatch[],\n\t\tprogressCb: IProgressCallback,\n\t\tbatchSize: number,\n\t) {\n\t\tif (batchSize && batchSize > 0) {\n\t\t\tfor (let i = 0; i < results.length; i += batchSize) {\n\t\t\t\tprogressCb(results.slice(i, i + batchSize));\n\t\t\t}\n\t\t} else {\n\t\t\tprogressCb(results);\n\t\t}\n\t}\n\n\tprivate getResultsFromCache(\n\t\tcache: Cache,\n\t\tsearchValue: string,\n\t\tprogressCallback: IFileProgressCallback,\n\t\ttoken?: CancellationToken,\n\t): Promise<\n\t\t[ISearchEngineSuccess, IRawFileMatch[], ICachedSearchStats]\n\t> | null {\n\t\tconst cacheLookupSW = StopWatch.create(false);\n\n\t\t// Find cache entries by prefix of search value\n\t\tconst hasPathSep = searchValue.indexOf(sep) >= 0;\n\t\tlet cachedRow: ICacheRow | undefined;\n\t\tfor (const previousSearch in cache.resultsToSearchCache) {\n\t\t\t// If we narrow down, we might be able to reuse the cached results\n\t\t\tif (searchValue.startsWith(previousSearch)) {\n\t\t\t\tif (\n\t\t\t\t\thasPathSep &&\n\t\t\t\t\tpreviousSearch.indexOf(sep) < 0 &&\n\t\t\t\t\tpreviousSearch !== \"\"\n\t\t\t\t) {\n\t\t\t\t\tcontinue; // since a path character widens the search for potential more matches, require it in previous search too\n\t\t\t\t}\n\n\t\t\t\tconst row = cache.resultsToSearchCache[previousSearch];\n\t\t\t\tcachedRow = {\n\t\t\t\t\tpromise: this.preventCancellation(row.promise),\n\t\t\t\t\tevent: row.event,\n\t\t\t\t\tresolved: row.resolved,\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!cachedRow) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst cacheLookupTime = cacheLookupSW.elapsed();\n\t\tconst cacheFilterSW = StopWatch.create(false);\n\n\t\tconst listener = cachedRow.event(progressCallback);\n\t\tif (token) {\n\t\t\ttoken.onCancellationRequested(() => {\n\t\t\t\tlistener.dispose();\n\t\t\t});\n\t\t}\n\n\t\treturn cachedRow.promise.then<\n\t\t\t[ISearchEngineSuccess, IRawFileMatch[], ICachedSearchStats]\n\t\t>(([complete, cachedEntries]) => {\n\t\t\tif (token && token.isCancellationRequested) {\n\t\t\t\tthrow canceled();\n\t\t\t}\n\n\t\t\t// Pattern match on results\n\t\t\tconst results: IRawFileMatch[] = [];\n\t\t\tconst normalizedSearchValueLowercase =\n\t\t\t\tprepareQuery(searchValue).normalizedLowercase;\n\t\t\tfor (const entry of cachedEntries) {\n\t\t\t\t// Check if this entry is a match for the search value\n\t\t\t\tif (\n\t\t\t\t\t!isFilePatternMatch(entry, normalizedSearchValueLowercase)\n\t\t\t\t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tresults.push(entry);\n\t\t\t}\n\n\t\t\treturn [\n\t\t\t\tcomplete,\n\t\t\t\tresults,\n\t\t\t\t{\n\t\t\t\t\tcacheWasResolved: cachedRow.resolved,\n\t\t\t\t\tcacheLookupTime,\n\t\t\t\t\tcacheFilterTime: cacheFilterSW.elapsed(),\n\t\t\t\t\tcacheEntryCount: cachedEntries.length,\n\t\t\t\t},\n\t\t\t];\n\t\t});\n\t}\n\n\tprivate doSearch(\n\t\tengine: ISearchEngine<IRawFileMatch>,\n\t\tprogressCallback: IFileProgressCallback,\n\t\tbatchSize: number,\n\t\ttoken?: CancellationToken,\n\t): Promise<ISearchEngineSuccess> {\n\t\treturn new Promise<ISearchEngineSuccess>((c, e) => {\n\t\t\tlet batch: IRawFileMatch[] = [];\n\t\t\ttoken?.onCancellationRequested(() => engine.cancel());\n\n\t\t\tengine.search(\n\t\t\t\t(match) => {\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\tif (batchSize) {\n\t\t\t\t\t\t\tbatch.push(match);\n\t\t\t\t\t\t\tif (batchSize > 0 && batch.length >= batchSize) {\n\t\t\t\t\t\t\t\tprogressCallback(batch);\n\t\t\t\t\t\t\t\tbatch = [];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tprogressCallback(match);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t(progress) => {\n\t\t\t\t\tprogressCallback(progress);\n\t\t\t\t},\n\t\t\t\t(error, complete) => {\n\t\t\t\t\tif (batch.length) {\n\t\t\t\t\t\tprogressCallback(batch);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tprogressCallback({\n\t\t\t\t\t\t\tmessage: \"Search finished. Error: \" + error.message,\n\t\t\t\t\t\t});\n\t\t\t\t\t\te(error);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprogressCallback({\n\t\t\t\t\t\t\tmessage:\n\t\t\t\t\t\t\t\t\"Search finished. Stats: \" +\n\t\t\t\t\t\t\t\tJSON.stringify(complete.stats),\n\t\t\t\t\t\t});\n\t\t\t\t\t\tc(complete);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t);\n\t\t});\n\t}\n\n\tclearCache(cacheKey: string): Promise<void> {\n\t\tdelete this.caches[cacheKey];\n\t\treturn Promise.resolve(undefined);\n\t}\n\n\t/**\n\t * Return a CancelablePromise which is not actually cancelable\n\t * TODO@rob - Is this really needed?\n\t */\n\tprivate preventCancellation<C>(\n\t\tpromise: CancelablePromise<C>,\n\t): CancelablePromise<C> {\n\t\treturn new (class implements CancelablePromise<C> {\n\t\t\tget [Symbol.toStringTag]() {\n\t\t\t\treturn this.toString();\n\t\t\t}\n\t\t\tcancel() {\n\t\t\t\t// Do nothing\n\t\t\t}\n\t\t\tthen<TResult1 = C, TResult2 = never>(\n\t\t\t\tresolve?:\n\t\t\t\t\t| ((value: C) => TResult1 | Promise<TResult1>)\n\t\t\t\t\t| undefined\n\t\t\t\t\t| null,\n\t\t\t\treject?:\n\t\t\t\t\t| ((reason: any) => TResult2 | Promise<TResult2>)\n\t\t\t\t\t| undefined\n\t\t\t\t\t| null,\n\t\t\t): Promise<TResult1 | TResult2> {\n\t\t\t\treturn promise.then(resolve, reject);\n\t\t\t}\n\t\t\tcatch(reject?: any) {\n\t\t\t\treturn this.then(undefined, reject);\n\t\t\t}\n\t\t\tfinally(onFinally: any) {\n\t\t\t\treturn promise.finally(onFinally);\n\t\t\t}\n\t\t})();\n\t}\n}\n\ninterface ICacheRow {\n\t// TODO@roblou - never actually canceled\n\tpromise: CancelablePromise<[ISearchEngineSuccess, IRawFileMatch[]]>;\n\tresolved: boolean;\n\tevent: Event<IFileSearchProgressItem>;\n}\n\nclass Cache {\n\tresultsToSearchCache: { [searchValue: string]: ICacheRow } =\n\t\tObject.create(null);\n\n\tscorerCache: FuzzyScorerCache = Object.create(null);\n}\n\nconst FileMatchItemAccessor = new (class\n\timplements IItemAccessor<IRawFileMatch>\n{\n\tgetItemLabel(match: IRawFileMatch): string {\n\t\treturn basename(match.relativePath); // e.g. myFile.txt\n\t}\n\n\tgetItemDescription(match: IRawFileMatch): string {\n\t\treturn dirname(match.relativePath); // e.g. some/path/to/file\n\t}\n\n\tgetItemPath(match: IRawFileMatch): string {\n\t\treturn match.relativePath; // e.g. some/path/to/file/myFile.txt\n\t}\n})();\n\nfunction reviveQuery<U extends IRawQuery>(\n\trawQuery: U,\n): U extends IRawTextQuery ? ITextQuery : IFileQuery {\n\treturn {\n\t\t...(<any>rawQuery), // TODO\n\t\t...{\n\t\t\tfolderQueries:\n\t\t\t\trawQuery.folderQueries &&\n\t\t\t\trawQuery.folderQueries.map(reviveFolderQuery),\n\t\t\textraFileResources:\n\t\t\t\trawQuery.extraFileResources &&\n\t\t\t\trawQuery.extraFileResources.map((components) =>\n\t\t\t\t\tURI.revive(components),\n\t\t\t\t),\n\t\t},\n\t};\n}\n\nfunction reviveFolderQuery(\n\trawFolderQuery: IFolderQuery<UriComponents>,\n): IFolderQuery<URI> {\n\treturn revive(rawFolderQuery);\n}\n"],
  "mappings": "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",
  "names": ["engine", "token"]
}
