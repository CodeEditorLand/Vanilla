var N=Object.defineProperty;var F=Object.getOwnPropertyDescriptor;var P=(f,d,e,o)=>{for(var t=o>1?void 0:o?F(d,e):d,s=f.length-1,i;s>=0;s--)(i=f[s])&&(t=(o?i(d,e,t):i(t))||t);return o&&t&&N(d,e,t),t},x=(f,d)=>(e,o)=>d(e,o,f);import{IBuiltinExtensionsScannerService as A,ExtensionType as w,TargetPlatform as E,parseEnabledApiProposalNames as G}from"../../../../platform/extensions/common/extensions.js";import{IBrowserWorkbenchEnvironmentService as O}from"../../environment/browser/environmentService.js";import{IWebExtensionsScannerService as D}from"../common/extensionManagement.js";import{isWeb as b,Language as V}from"../../../../base/common/platform.js";import{InstantiationType as $,registerSingleton as _}from"../../../../platform/instantiation/common/extensions.js";import{joinPath as S}from"../../../../base/common/resources.js";import{URI as l}from"../../../../base/common/uri.js";import{FileOperationResult as J,IFileService as j}from"../../../../platform/files/common/files.js";import{Queue as Q}from"../../../../base/common/async.js";import{VSBuffer as z}from"../../../../base/common/buffer.js";import{ILogService as H}from"../../../../platform/log/common/log.js";import{CancellationToken as y}from"../../../../base/common/cancellation.js";import{IExtensionGalleryService as q}from"../../../../platform/extensionManagement/common/extensionManagement.js";import{areSameExtensions as m,getGalleryExtensionId as K,getExtensionId as U}from"../../../../platform/extensionManagement/common/extensionManagementUtil.js";import{Disposable as X}from"../../../../base/common/lifecycle.js";import{localizeManifest as Y}from"../../../../platform/extensionManagement/common/extensionNls.js";import{localize as Z,localize2 as ee}from"../../../../nls.js";import*as g from"../../../../base/common/semver/semver.js";import{isString as R,isUndefined as C}from"../../../../base/common/types.js";import{getErrorMessage as u}from"../../../../base/common/errors.js";import{ResourceMap as ie}from"../../../../base/common/map.js";import{IExtensionManifestPropertiesService as ne}from"../../extensions/common/extensionManifestPropertiesService.js";import{IExtensionResourceLoaderService as te,migratePlatformSpecificExtensionGalleryResourceURL as se}from"../../../../platform/extensionResourceLoader/common/extensionResourceLoader.js";import{Action2 as oe,registerAction2 as re}from"../../../../platform/actions/common/actions.js";import{Categories as ae}from"../../../../platform/action/common/actionCommonCategories.js";import{IsWebContext as ce}from"../../../../platform/contextkey/common/contextkeys.js";import{IEditorService as le}from"../../editor/common/editorService.js";import"../../../../platform/instantiation/common/instantiation.js";import{basename as W}from"../../../../base/common/path.js";import{IExtensionStorageService as de}from"../../../../platform/extensionManagement/common/extensionStorage.js";import{isNonEmptyArray as M}from"../../../../base/common/arrays.js";import{ILifecycleService as ue,LifecyclePhase as fe}from"../../lifecycle/common/lifecycle.js";import{IStorageService as xe,StorageScope as B,StorageTarget as me}from"../../../../platform/storage/common/storage.js";import{IProductService as pe}from"../../../../platform/product/common/productService.js";import{validateExtensionManifest as he}from"../../../../platform/extensions/common/extensionValidator.js";import L from"../../../../base/common/severity.js";import"../../../../base/common/collections.js";import{IUserDataProfileService as Ee}from"../../userDataProfile/common/userDataProfile.js";import{IUserDataProfilesService as ge}from"../../../../platform/userDataProfile/common/userDataProfile.js";import{IUriIdentityService as Ie}from"../../../../platform/uriIdentity/common/uriIdentity.js";function ve(f){const d=f;return typeof d?.id=="string"&&(d.preRelease===void 0||typeof d.preRelease=="boolean")&&(d.migrateStorageFrom===void 0||typeof d.migrateStorageFrom=="string")}function Se(f){return f?R(f.path)&&R(f.scheme):!1}let I=class extends X{constructor(e,o,t,s,i,n,r,a,c,p,h,v,k){super();this.environmentService=e;this.builtinExtensionsScannerService=o;this.fileService=t;this.logService=s;this.galleryService=i;this.extensionManifestPropertiesService=n;this.extensionResourceLoaderService=r;this.extensionStorageService=a;this.storageService=c;this.productService=p;this.userDataProfilesService=h;this.uriIdentityService=v;b&&(this.systemExtensionsCacheResource=S(e.userRoamingDataHome,"systemExtensionsCache.json"),this.customBuiltinExtensionsCacheResource=S(e.userRoamingDataHome,"customBuiltinExtensionsCache.json"),k.when(fe.Eventually).then(()=>this.updateCaches())),this.extensionsEnabledWithApiProposalVersion=p.extensionsEnabledWithApiProposalVersion?.map(T=>T.toLowerCase())??[]}systemExtensionsCacheResource=void 0;customBuiltinExtensionsCacheResource=void 0;resourcesAccessQueueMap=new ie;extensionsEnabledWithApiProposalVersion;_customBuiltinExtensionsInfoPromise;readCustomBuiltinExtensionsInfoFromEnv(){return this._customBuiltinExtensionsInfoPromise||(this._customBuiltinExtensionsInfoPromise=(async()=>{let e=[];const o=[],t=[],s=[],i=this.environmentService.options&&Array.isArray(this.environmentService.options.additionalBuiltinExtensions)?this.environmentService.options.additionalBuiltinExtensions.map(n=>R(n)?{id:n}:n):[];for(const n of i)if(ve(n))e.push({id:n.id,preRelease:!!n.preRelease}),n.migrateStorageFrom&&s.push([n.migrateStorageFrom,n.id]);else if(Se(n)){const r=l.revive(n);this.extensionResourceLoaderService.isExtensionGalleryResource(r)?t.push(r):o.push(r)}return e.length&&(e=await this.checkAdditionalBuiltinExtensions(e)),e.length&&this.logService.info("Found additional builtin gallery extensions in env",e),o.length&&this.logService.info("Found additional builtin location extensions in env",o.map(n=>n.toString())),t.length&&this.logService.info("Found additional builtin extension gallery resources in env",t.map(n=>n.toString())),{extensions:e,extensionsToMigrate:s,extensionLocations:o,extensionGalleryResources:t}})()),this._customBuiltinExtensionsInfoPromise}async checkAdditionalBuiltinExtensions(e){const o=await this.galleryService.getExtensionsControlManifest(),t=[];for(const s of e){if(o.malicious.some(n=>m(n,{id:s.id}))){this.logService.info(`Checking additional builtin extensions: Ignoring '${s.id}' because it is reported to be malicious.`);continue}const i=o.deprecated[s.id.toLowerCase()];if(i?.extension?.autoMigrate){const n=i.extension.id;this.logService.info(`Checking additional builtin extensions: '${s.id}' is deprecated, instead using '${n}'`),t.push({id:n,preRelease:!!s.preRelease})}else t.push(s)}return t}async readSystemExtensions(){const e=await this.builtinExtensionsScannerService.scanBuiltinExtensions(),o=await Promise.all((await this.readSystemExtensionsCache()).map(s=>this.toScannedExtension(s,!0,w.System))),t=new Map;for(const s of[...e,...o]){const i=t.get(s.identifier.id.toLowerCase());i&&g.gt(i.manifest.version,s.manifest.version)||t.set(s.identifier.id.toLowerCase(),s)}return[...t.values()]}async readCustomBuiltinExtensions(e){const[o,t]=await Promise.all([this.getCustomBuiltinExtensionsFromLocations(e),this.getCustomBuiltinExtensionsFromGallery(e)]),s=[...o,...t];return await this.migrateExtensionsStorage(s),s}async getCustomBuiltinExtensionsFromLocations(e){const{extensionLocations:o}=await this.readCustomBuiltinExtensionsInfoFromEnv();if(!o.length)return[];const t=[];return await Promise.allSettled(o.map(async s=>{try{const i=await this.toWebExtension(s),n=await this.toScannedExtension(i,!0);n.isValid||!e?.skipInvalidExtensions?t.push(n):this.logService.info(`Skipping invalid additional builtin extension ${i.identifier.id}`)}catch(i){this.logService.info(`Error while fetching the additional builtin extension ${s.toString()}.`,u(i))}})),t}async getCustomBuiltinExtensionsFromGallery(e){if(!this.galleryService.isEnabled())return this.logService.info("Ignoring fetching additional builtin extensions from gallery as it is disabled."),[];const o=[],{extensions:t,extensionGalleryResources:s}=await this.readCustomBuiltinExtensionsInfoFromEnv();try{const i=JSON.stringify({extensions:t.sort((a,c)=>a.id.localeCompare(c.id)),extensionGalleryResources:s.map(a=>a.toString()).sort()}),r=await(this.storageService.get("additionalBuiltinExtensions",B.APPLICATION,"{}")===i?this.getCustomBuiltinExtensionsFromCache():this.updateCustomBuiltinExtensionsCache());r.length&&await Promise.all(r.map(async a=>{try{const c=await this.toScannedExtension(a,!0);c.isValid||!e?.skipInvalidExtensions?o.push(c):this.logService.info(`Skipping invalid additional builtin gallery extension ${a.identifier.id}`)}catch(c){this.logService.info(`Ignoring additional builtin extension ${a.identifier.id} because there is an error while converting it into scanned extension`,u(c))}})),this.storageService.store("additionalBuiltinExtensions",i,B.APPLICATION,me.MACHINE)}catch(i){this.logService.info("Ignoring following additional builtin extensions as there is an error while fetching them from gallery",t.map(({id:n})=>n),u(i))}return o}async getCustomBuiltinExtensionsFromCache(){const e=await this.readCustomBuiltinExtensionsCache(),o=new Map;for(const t of e){const s=o.get(t.identifier.id.toLowerCase());s&&g.gt(s.version,t.version)||(t.metadata?.isPreReleaseVersion&&!t.metadata?.preRelease&&(t.metadata.preRelease=!0),o.set(t.identifier.id.toLowerCase(),t))}return[...o.values()]}_migrateExtensionsStoragePromise;async migrateExtensionsStorage(e){return this._migrateExtensionsStoragePromise||(this._migrateExtensionsStoragePromise=(async()=>{const{extensionsToMigrate:o}=await this.readCustomBuiltinExtensionsInfoFromEnv();if(!o.length)return;const t=await this.galleryService.getExtensions(o.map(([s])=>({id:s})),y.None);try{await Promise.allSettled(o.map(async([s,i])=>{const n=e.find(r=>m(r.identifier,{id:i}));if(n){const r=t.find(h=>m(h.identifier,{id:s})),a=r?await this.galleryService.getManifest(r,y.None):null,c=a?U(a.publisher,a.name):s,p=U(n.manifest.publisher,n.manifest.name);this.extensionStorageService.addToMigrationList(c,p)}else this.logService.info(`Skipped migrating extension storage from '${s}' to '${i}', because the '${i}' extension is not found.`)}))}catch(s){this.logService.error(s)}})()),this._migrateExtensionsStoragePromise}async updateCaches(){await this.updateSystemExtensionsCache(),await this.updateCustomBuiltinExtensionsCache()}async updateSystemExtensionsCache(){const e=await this.builtinExtensionsScannerService.scanBuiltinExtensions(),o=(await this.readSystemExtensionsCache()).filter(t=>{const s=e.find(i=>m(i.identifier,t.identifier));return s&&g.gt(t.version,s.manifest.version)});await this.writeSystemExtensionsCache(()=>o)}_updateCustomBuiltinExtensionsCachePromise;async updateCustomBuiltinExtensionsCache(){return this._updateCustomBuiltinExtensionsCachePromise||(this._updateCustomBuiltinExtensionsCachePromise=(async()=>{this.logService.info("Updating additional builtin extensions cache");const{extensions:e,extensionGalleryResources:o}=await this.readCustomBuiltinExtensionsInfoFromEnv(),[t,s]=await Promise.all([this.resolveBuiltinGalleryExtensions(e),this.resolveBuiltinExtensionGalleryResources(o)]),i=new Map;for(const r of[...t,...s])i.set(r.identifier.id.toLowerCase(),r);await this.resolveDependenciesAndPackedExtensions(s,i);const n=[...i.values()];return await this.writeCustomBuiltinExtensionsCache(()=>n),n})()),this._updateCustomBuiltinExtensionsCachePromise}async resolveBuiltinExtensionGalleryResources(e){if(e.length===0)return[];const o=new Map,t=[];await Promise.all(e.map(async i=>{try{const n=await this.toWebExtensionFromExtensionGalleryResource(i);o.set(n.identifier.id.toLowerCase(),n),t.push({id:n.identifier.id,version:n.version})}catch(n){this.logService.info(`Ignoring additional builtin extension from gallery resource ${i.toString()} because there is an error while converting it into web extension`,u(n))}}));const s=await this.galleryService.getExtensions(t,y.None);for(const i of s){const n=o.get(i.identifier.id.toLowerCase());n&&o.set(i.identifier.id.toLowerCase(),{...n,identifier:{id:n.identifier.id,uuid:i.identifier.uuid},readmeUri:i.assets.readme?l.parse(i.assets.readme.uri):void 0,changelogUri:i.assets.changelog?l.parse(i.assets.changelog.uri):void 0,metadata:{isPreReleaseVersion:i.properties.isPreReleaseVersion,preRelease:i.properties.isPreReleaseVersion,isBuiltin:!0,pinned:!0}})}return[...o.values()]}async resolveBuiltinGalleryExtensions(e){if(e.length===0)return[];const o=[],t=await this.getExtensionsWithDependenciesAndPackedExtensions(e),s=e.filter(({id:i})=>!t.has(i.toLowerCase()));return s.length&&this.logService.info("Skipping the additional builtin extensions because their compatible versions are not found.",s),await Promise.all([...t.values()].map(async i=>{try{const n=await this.toWebExtensionFromGallery(i,{isPreReleaseVersion:i.properties.isPreReleaseVersion,preRelease:i.properties.isPreReleaseVersion,isBuiltin:!0});o.push(n)}catch(n){this.logService.info(`Ignoring additional builtin extension ${i.identifier.id} because there is an error while converting it into web extension`,u(n))}})),o}async resolveDependenciesAndPackedExtensions(e,o){const t=[];for(const i of e)for(const n of[...i.manifest?.extensionDependencies??[],...i.manifest?.extensionPack??[]])o.has(n.toLowerCase())||t.push({id:n,version:i.version});if(t.length===0)return;const s=await this.getExtensionsWithDependenciesAndPackedExtensions(t,new Set([...o.keys()]));await Promise.all([...s.values()].map(async i=>{try{const n=await this.toWebExtensionFromGallery(i,{isPreReleaseVersion:i.properties.isPreReleaseVersion,preRelease:i.properties.isPreReleaseVersion,isBuiltin:!0});o.set(n.identifier.id.toLowerCase(),n)}catch(n){this.logService.info(`Ignoring additional builtin extension ${i.identifier.id} because there is an error while converting it into web extension`,u(n))}}))}async getExtensionsWithDependenciesAndPackedExtensions(e,o=new Set,t=new Map){if(e.length===0)return t;const s=await this.galleryService.getExtensions(e,{compatible:!0,targetPlatform:E.WEB},y.None),i=new Map;for(const n of s){t.set(n.identifier.id.toLowerCase(),n);for(const r of[...M(n.properties.dependencies)?n.properties.dependencies:[],...M(n.properties.extensionPack)?n.properties.extensionPack:[]])if(!t.has(r.toLowerCase())&&!i.has(r.toLowerCase())&&!o.has(r.toLowerCase())){const a=e.find(c=>m(c,n.identifier));i.set(r.toLowerCase(),{id:r,preRelease:a?.preRelease})}}return this.getExtensionsWithDependenciesAndPackedExtensions([...i.values()].filter(({id:n})=>!t.has(n.toLowerCase())),o,t)}async scanSystemExtensions(){return this.readSystemExtensions()}async scanUserExtensions(e,o){const t=new Map,s=await this.readCustomBuiltinExtensions(o);for(const n of s)t.set(n.identifier.id.toLowerCase(),n);const i=await this.scanInstalledExtensions(e,o);for(const n of i)t.set(n.identifier.id.toLowerCase(),n);return[...t.values()]}async scanExtensionsUnderDevelopment(){const e=this.environmentService.options?.developmentOptions?.extensions,o=[];return Array.isArray(e)&&await Promise.allSettled(e.map(async t=>{try{const s=l.revive(t);if(l.isUri(s)){const i=await this.toWebExtension(s);o.push(await this.toScannedExtension(i,!1))}else this.logService.info(`Skipping the extension under development ${t} as it is not URI type.`)}catch(s){this.logService.info(`Error while fetching the extension under development ${t.toString()}.`,u(s))}})),o}async scanExistingExtension(e,o,t){return o===w.System?(await this.scanSystemExtensions()).find(n=>n.location.toString()===e.toString())||null:(await this.scanUserExtensions(t)).find(i=>i.location.toString()===e.toString())||null}async scanExtensionManifest(e){try{return await this.getExtensionManifest(e)}catch(o){return this.logService.warn(`Error while fetching manifest from ${e.toString()}`,u(o)),null}}async addExtensionFromGallery(e,o,t){const s=await this.toWebExtensionFromGallery(e,o);return this.addWebExtension(s,t)}async addExtension(e,o,t){const s=await this.toWebExtension(e,void 0,void 0,void 0,void 0,void 0,void 0,o),i=await this.toScannedExtension(s,!1);return await this.addToInstalledExtensions([s],t),i}async removeExtension(e,o){await this.writeInstalledExtensions(o,t=>t.filter(s=>!m(s.identifier,e.identifier)))}async updateMetadata(e,o,t){let s;if(await this.writeInstalledExtensions(t,i=>{const n=[];for(const r of i)m(e.identifier,r.identifier)&&(r.metadata={...r.metadata,...o},s=r),n.push(r);return n}),!s)throw new Error("Extension not found");return this.toScannedExtension(s,e.isBuiltin)}async copyExtensions(e,o,t){const s=[],i=await this.readInstalledExtensions(e);await Promise.all(i.map(async n=>{const r=await this.toScannedExtension(n,!1);t(r)&&s.push(n)})),s.length&&await this.addToInstalledExtensions(s,o)}async addWebExtension(e,o){const t=!!(await this.scanSystemExtensions()).find(n=>m(n.identifier,e.identifier)),s=!!e.metadata?.isBuiltin,i=await this.toScannedExtension(e,s);return t?(await this.writeSystemExtensionsCache(n=>(n=n.filter(r=>!m(r.identifier,e.identifier)),n.push(e),n)),i):s?(await this.writeCustomBuiltinExtensionsCache(r=>(r=r.filter(a=>!m(a.identifier,e.identifier)),r.push(e),r)),(await this.readInstalledExtensions(o)).some(r=>m(r.identifier,e.identifier))&&await this.addToInstalledExtensions([e],o),i):(await this.addToInstalledExtensions([e],o),i)}async addToInstalledExtensions(e,o){await this.writeInstalledExtensions(o,t=>(t=t.filter(s=>e.some(i=>!m(s.identifier,i.identifier))),t.push(...e),t))}async scanInstalledExtensions(e,o){let t=await this.readInstalledExtensions(e);if(!this.uriIdentityService.extUri.isEqual(e,this.userDataProfilesService.defaultProfile.extensionsResource)){t=t.filter(n=>!n.metadata?.isApplicationScoped);const i=await this.readInstalledExtensions(this.userDataProfilesService.defaultProfile.extensionsResource);t.push(...i.filter(n=>n.metadata?.isApplicationScoped))}t.sort((i,n)=>i.identifier.id<n.identifier.id?-1:i.identifier.id>n.identifier.id?1:g.rcompare(i.version,n.version));const s=new Map;for(const i of t){const n=s.get(i.identifier.id.toLowerCase());if(n&&g.gt(n.manifest.version,i.version))continue;const r=await this.toScannedExtension(i,!1);r.isValid||!o?.skipInvalidExtensions?s.set(r.identifier.id.toLowerCase(),r):this.logService.info(`Skipping invalid installed extension ${i.identifier.id}`)}return[...s.values()]}async toWebExtensionFromGallery(e,o){const t=this.extensionResourceLoaderService.getExtensionGalleryResourceURL({publisher:e.publisher,name:e.name,version:e.version,targetPlatform:e.properties.targetPlatform===E.WEB?E.WEB:void 0},"extension");if(!t)throw new Error("No extension gallery service configured.");return this.toWebExtensionFromExtensionGalleryResource(t,e.identifier,e.assets.readme?l.parse(e.assets.readme.uri):void 0,e.assets.changelog?l.parse(e.assets.changelog.uri):void 0,o)}async toWebExtensionFromExtensionGalleryResource(e,o,t,s,i){const n=await this.listExtensionResources(e),r=this.getPackageNLSResourceMapFromResources(n),a=n.find(c=>W(c)==="package.nls.json");return this.toWebExtension(e,o,void 0,r,a?l.parse(a):null,t,s,i)}getPackageNLSResourceMapFromResources(e){const o=new Map;return e.forEach(t=>{const s=/package\.nls\.([\w-]+)\.json/.exec(W(t));s?.[1]&&o.set(s[1],l.parse(t))}),o}async toWebExtension(e,o,t,s,i,n,r,a){if(!t)try{t=await this.getExtensionManifest(e)}catch(p){throw new Error(`Error while fetching manifest from the location '${e.toString()}'. ${u(p)}`)}if(!this.extensionManifestPropertiesService.canExecuteOnWeb(t))throw new Error(Z("not a web extension","Cannot add '{0}' because this extension is not a web extension.",t.displayName||t.name));if(i===void 0)try{i=S(e,"package.nls.json"),await this.extensionResourceLoaderService.readExtensionResource(i)}catch{i=void 0}const c=i?l.isUri(i)?await this.getTranslations(i):i:null;return{identifier:{id:K(t.publisher,t.name),uuid:o?.uuid},version:t.version,location:e,manifest:t,readmeUri:n,changelogUri:r,packageNLSUris:s,fallbackPackageNLSUri:l.isUri(i)?i:void 0,defaultManifestTranslations:c,metadata:a}}async toScannedExtension(e,o,t=w.User){const s=[];let i=e.manifest;if(!i)try{i=await this.getExtensionManifest(e.location)}catch(h){s.push([L.Error,`Error while fetching manifest from the location '${e.location}'. ${u(h)}`])}if(!i){const[h,v]=e.identifier.id.split(".");i={name:v,publisher:h,version:e.version,engines:{vscode:"*"}}}const n=e.packageNLSUris?.get(V.value().toLowerCase()),r=e.defaultManifestTranslations??e.fallbackPackageNLSUri;n?i=await this.translateManifest(i,n,r):r&&(i=await this.translateManifest(i,r));const a=e.metadata?.id,c=this.extensionsEnabledWithApiProposalVersion.includes(e.identifier.id.toLowerCase());s.push(...he(this.productService.version,this.productService.date,e.location,i,!1,c));let p=!0;for(const[h,v]of s)h===L.Error&&(p=!1,this.logService.error(v));return i.enabledApiProposals&&c&&(i.enabledApiProposals=G([...i.enabledApiProposals])),{identifier:{id:e.identifier.id,uuid:e.identifier.uuid||a},location:e.location,manifest:i,type:t,isBuiltin:o,readmeUrl:e.readmeUri,changelogUrl:e.changelogUri,metadata:e.metadata,targetPlatform:E.WEB,validations:s,isValid:p}}async listExtensionResources(e){try{const o=await this.extensionResourceLoaderService.readExtensionResource(e);return JSON.parse(o)}catch(o){this.logService.warn("Error while fetching extension resources list",u(o))}return[]}async translateManifest(e,o,t){try{const s=l.isUri(o)?await this.getTranslations(o):o,i=l.isUri(t)?await this.getTranslations(t):t;s&&(e=Y(this.logService,e,s,i))}catch{}return e}async getExtensionManifest(e){const o=S(e,"package.json"),t=await this.extensionResourceLoaderService.readExtensionResource(o);return JSON.parse(t)}async getTranslations(e){try{const o=await this.extensionResourceLoaderService.readExtensionResource(e);return JSON.parse(o)}catch(o){this.logService.error("Error while fetching translations of an extension",e.toString(),u(o))}}async readInstalledExtensions(e){return this.withWebExtensions(e)}writeInstalledExtensions(e,o){return this.withWebExtensions(e,o)}readCustomBuiltinExtensionsCache(){return this.withWebExtensions(this.customBuiltinExtensionsCacheResource)}writeCustomBuiltinExtensionsCache(e){return this.withWebExtensions(this.customBuiltinExtensionsCacheResource,e)}readSystemExtensionsCache(){return this.withWebExtensions(this.systemExtensionsCacheResource)}writeSystemExtensionsCache(e){return this.withWebExtensions(this.systemExtensionsCacheResource,e)}async withWebExtensions(e,o){return e?this.getResourceAccessQueue(e).queue(async()=>{let t=[];try{const s=await this.fileService.readFile(e),i=JSON.parse(s.value.toString());for(const n of i){if(!n.location||!n.identifier||!n.version){this.logService.info("Ignoring invalid extension while scanning",i);continue}let r;n.packageNLSUris&&(r=new Map,Object.entries(n.packageNLSUris).forEach(([a,c])=>r.set(a,l.revive(c)))),t.push({identifier:n.identifier,version:n.version,location:l.revive(n.location),manifest:n.manifest,readmeUri:l.revive(n.readmeUri),changelogUri:l.revive(n.changelogUri),packageNLSUris:r,fallbackPackageNLSUri:l.revive(n.fallbackPackageNLSUri),defaultManifestTranslations:n.defaultManifestTranslations,packageNLSUri:l.revive(n.packageNLSUri),metadata:n.metadata})}try{t=await this.migrateWebExtensions(t,e)}catch(n){this.logService.error(`Error while migrating scanned extensions in ${e.toString()}`,u(n))}}catch(s){s.fileOperationResult!==J.FILE_NOT_FOUND&&this.logService.error(s)}return o&&await this.storeWebExtensions(t=o(t),e),t}):[]}async migrateWebExtensions(e,o){let t=!1;return e=await Promise.all(e.map(async s=>{if(!s.manifest)try{s.manifest=await this.getExtensionManifest(s.location),t=!0}catch(n){this.logService.error(`Error while updating manifest of an extension in ${o.toString()}`,s.identifier.id,u(n))}if(C(s.defaultManifestTranslations))if(s.fallbackPackageNLSUri)try{const n=await this.extensionResourceLoaderService.readExtensionResource(s.fallbackPackageNLSUri);s.defaultManifestTranslations=JSON.parse(n),t=!0}catch(n){this.logService.error("Error while fetching default manifest translations of an extension",s.identifier.id,u(n))}else t=!0,s.defaultManifestTranslations=null;const i=se(s.location,E.WEB);return i&&(t=!0,s.location=i),C(s.metadata?.hasPreReleaseVersion)&&s.metadata?.preRelease&&(t=!0,s.metadata.hasPreReleaseVersion=!0),s})),t&&await this.storeWebExtensions(e,o),e}async storeWebExtensions(e,o){function t(i){if(!i)return;const n=Object.create(null);return i.forEach((r,a)=>n[a]=r.toJSON()),n}const s=e.map(i=>({identifier:i.identifier,version:i.version,manifest:i.manifest,location:i.location.toJSON(),readmeUri:i.readmeUri?.toJSON(),changelogUri:i.changelogUri?.toJSON(),packageNLSUris:t(i.packageNLSUris),defaultManifestTranslations:i.defaultManifestTranslations,fallbackPackageNLSUri:i.fallbackPackageNLSUri?.toJSON(),metadata:i.metadata}));await this.fileService.writeFile(o,z.fromString(JSON.stringify(s)))}getResourceAccessQueue(e){let o=this.resourcesAccessQueueMap.get(e);return o||this.resourcesAccessQueueMap.set(e,o=new Q),o}};I=P([x(0,O),x(1,A),x(2,j),x(3,H),x(4,q),x(5,ne),x(6,te),x(7,de),x(8,xe),x(9,pe),x(10,ge),x(11,Ie),x(12,ue)],I),b&&re(class extends oe{constructor(){super({id:"workbench.extensions.action.openInstalledWebExtensionsResource",title:ee("openInstalledWebExtensionsResource","Open Installed Web Extensions Resource"),category:ae.Developer,f1:!0,precondition:ce})}run(f){const d=f.get(le),e=f.get(Ee);d.openEditor({resource:e.currentProfile.extensionsResource})}}),_(D,I,$.Delayed);export{I as WebExtensionsScannerService};
