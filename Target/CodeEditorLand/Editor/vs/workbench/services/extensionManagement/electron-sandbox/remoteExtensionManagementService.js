var w=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var x=(p,d,e,n)=>{for(var i=n>1?void 0:n?u(d,e):d,t=p.length-1,o;t>=0;t--)(o=p[t])&&(i=(n?o(d,e,i):o(i))||i);return n&&i&&w(d,e,i),i},s=(p,d)=>(e,n)=>d(e,n,p);import{isNonEmptyArray as h}from"../../../../base/common/arrays.js";import{Promises as P}from"../../../../base/common/async.js";import{CancellationToken as m}from"../../../../base/common/cancellation.js";import{toErrorMessage as A}from"../../../../base/common/errorMessage.js";import{isBoolean as k,isUndefined as D}from"../../../../base/common/types.js";import{localize as g}from"../../../../nls.js";import{IConfigurationService as M}from"../../../../platform/configuration/common/configuration.js";import{EXTENSION_INSTALL_CLIENT_TARGET_PLATFORM_CONTEXT as C,ExtensionManagementError as y,ExtensionManagementErrorCode as c,IExtensionGalleryService as b,InstallOperation as E}from"../../../../platform/extensionManagement/common/extensionManagement.js";import{areSameExtensions as S}from"../../../../platform/extensionManagement/common/extensionManagementUtil.js";import{areApiProposalsCompatible as G}from"../../../../platform/extensions/common/extensionValidator.js";import{ExtensionType as U}from"../../../../platform/extensions/common/extensions.js";import{IFileService as L}from"../../../../platform/files/common/files.js";import{ILogService as T}from"../../../../platform/log/common/log.js";import{IProductService as R}from"../../../../platform/product/common/productService.js";import{IUriIdentityService as V}from"../../../../platform/uriIdentity/common/uriIdentity.js";import{IUserDataProfilesService as F}from"../../../../platform/userDataProfile/common/userDataProfile.js";import{IExtensionManifestPropertiesService as N}from"../../extensions/common/extensionManifestPropertiesService.js";import{IRemoteUserDataProfilesService as _}from"../../userDataProfile/common/remoteUserDataProfiles.js";import{IUserDataProfileService as $}from"../../userDataProfile/common/userDataProfile.js";import{RemoteExtensionManagementService as j}from"../common/remoteExtensionManagementService.js";let v=class extends j{constructor(e,n,i,t,o,a,I,r,l,f,W,X){super(e,i,t,o,a);this.localExtensionManagementServer=n;this.logService=I;this.galleryService=r;this.configurationService=l;this.productService=f;this.fileService=W;this.extensionManifestPropertiesService=X}async install(e,n){const i=await super.install(e,n);return await this.installUIDependenciesAndPackedExtensions(i),i}async installFromGallery(e,n={}){if(D(n.donotVerifySignature)){const t=this.configurationService.getValue("extensions.verifySignature");n.donotVerifySignature=k(t)?!t:void 0}const i=await this.doInstallFromGallery(e,n);return await this.installUIDependenciesAndPackedExtensions(i),i}async doInstallFromGallery(e,n){if(this.configurationService.getValue("remote.downloadExtensionsLocally"))return this.downloadAndInstall(e,n);try{const i=await this.localExtensionManagementServer.extensionManagementService.getTargetPlatform();return await super.installFromGallery(e,{...n,context:{...n?.context,[C]:i}})}catch(i){switch(i.name){case c.Download:case c.DownloadSignature:case c.Gallery:case c.Internal:case c.Unknown:try{return this.logService.error(`Error while installing '${e.identifier.id}' extension in the remote server.`,A(i)),await this.downloadAndInstall(e,n)}catch(t){throw this.logService.error(t),t}default:throw this.logService.debug("Remote Install Error Name",i.name),i}}}async downloadAndInstall(e,n){this.logService.info(`Downloading the '${e.identifier.id}' extension locally and install`);const i=await this.checkAndGetCompatible(e,!!n.installPreReleaseVersion);n={...n,donotIncludePackAndDependencies:!0};const t=await this.getInstalled(U.User,void 0,n.productVersion),o=await this.getAllWorkspaceDependenciesAndPackedExtensions(i,m.None);if(o.length){this.logService.info(`Downloading the workspace dependencies and packed extensions of '${i.identifier.id}' locally and install`);for(const a of o)await this.downloadCompatibleAndInstall(a,t,n)}return await this.downloadCompatibleAndInstall(i,t,n)}async downloadCompatibleAndInstall(e,n,i){const t=await this.checkAndGetCompatible(e,!!i.installPreReleaseVersion);this.logService.trace("Downloading extension:",t.identifier.id);const o=await this.localExtensionManagementServer.extensionManagementService.download(t,n.filter(a=>S(a.identifier,t.identifier))[0]?E.Update:E.Install,!!i.donotVerifySignature);this.logService.info("Downloaded extension:",t.identifier.id,o.path);try{const a=await super.install(o,{...i,keepExisting:!0});return this.logService.info(`Successfully installed '${t.identifier.id}' extension`),a}finally{try{await this.fileService.del(o)}catch(a){this.logService.error(a)}}}async checkAndGetCompatible(e,n){const i=await this.getTargetPlatform();let t=null;if(e.hasPreReleaseVersion&&e.properties.isPreReleaseVersion!==n&&(t=(await this.galleryService.getExtensions([{...e.identifier,preRelease:n}],{targetPlatform:i,compatible:!0},m.None))[0]||null),!t&&await this.galleryService.isExtensionCompatible(e,n,i)&&(t=e),t||(t=await this.galleryService.getCompatibleExtension(e,n,i)),!t){const o=[];throw G(e.properties.enabledApiProposals??[],o)?!n&&e.properties.isPreReleaseVersion&&(await this.galleryService.getExtensions([e.identifier],m.None))[0]?new y(g("notFoundReleaseExtension","Can't install release version of '{0}' extension because it has no release version.",e.identifier.id),c.ReleaseVersionNotFound):new y(g("notFoundCompatibleDependency","Can't install '{0}' extension because it is not compatible with the current version of {1} (version {2}).",e.identifier.id,this.productService.nameLong,this.productService.version),c.Incompatible):new y(g("incompatibleAPI","Can't install '{0}' extension. {1}",e.displayName??e.identifier.id,o[0]),c.IncompatibleApi)}return t}async installUIDependenciesAndPackedExtensions(e){const n=await this.getAllUIDependenciesAndPackedExtensions(e.manifest,m.None),i=await this.localExtensionManagementServer.extensionManagementService.getInstalled(),t=n.filter(o=>i.every(a=>!S(a.identifier,o.identifier)));t.length&&(this.logService.info(`Installing UI dependencies and packed extensions of '${e.identifier.id}' locally`),await P.settled(t.map(o=>this.localExtensionManagementServer.extensionManagementService.installFromGallery(o))))}async getAllUIDependenciesAndPackedExtensions(e,n){const i=new Map,t=[...e.extensionPack||[],...e.extensionDependencies||[]];return await this.getDependenciesAndPackedExtensionsRecursively(t,i,!0,n),[...i.values()]}async getAllWorkspaceDependenciesAndPackedExtensions(e,n){const i=new Map;i.set(e.identifier.id.toLowerCase(),e);const t=await this.galleryService.getManifest(e,n);if(t){const o=[...t.extensionPack||[],...t.extensionDependencies||[]];await this.getDependenciesAndPackedExtensionsRecursively(o,i,!1,n)}return i.delete(e.identifier.id),[...i.values()]}async getDependenciesAndPackedExtensionsRecursively(e,n,i,t){if(e.length===0)return Promise.resolve();const o=await this.galleryService.getExtensions(e.map(r=>({id:r})),t),a=await Promise.all(o.map(r=>this.galleryService.getManifest(r,t))),I=[];for(let r=0;r<o.length;r++){const l=o[r],f=a[r];f&&this.extensionManifestPropertiesService.prefersExecuteOnUI(f)===i&&(n.set(l.identifier.id.toLowerCase(),l),I.push(f))}e=[];for(const r of I){if(h(r.extensionDependencies))for(const l of r.extensionDependencies)n.has(l.toLowerCase())||e.push(l);if(h(r.extensionPack))for(const l of r.extensionPack)n.has(l.toLowerCase())||e.push(l)}return this.getDependenciesAndPackedExtensionsRecursively(e,n,i,t)}};v=x([s(2,$),s(3,F),s(4,_),s(5,V),s(6,T),s(7,b),s(8,M),s(9,R),s(10,L),s(11,N)],v);export{v as NativeRemoteExtensionManagementService};
