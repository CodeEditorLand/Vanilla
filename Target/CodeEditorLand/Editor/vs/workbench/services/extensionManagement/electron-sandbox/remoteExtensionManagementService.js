var S=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var h=(p,d,e,n)=>{for(var i=n>1?void 0:n?u(d,e):d,t=p.length-1,r;t>=0;t--)(r=p[t])&&(i=(n?r(d,e,i):r(i))||i);return n&&i&&S(d,e,i),i},s=(p,d)=>(e,n)=>d(e,n,p);import{IExtensionGalleryService as P,InstallOperation as E,ExtensionManagementError as g,ExtensionManagementErrorCode as c,EXTENSION_INSTALL_CLIENT_TARGET_PLATFORM_CONTEXT as A}from"../../../../platform/extensionManagement/common/extensionManagement.js";import{ExtensionType as k}from"../../../../platform/extensions/common/extensions.js";import{areSameExtensions as y}from"../../../../platform/extensionManagement/common/extensionManagementUtil.js";import{ILogService as D}from"../../../../platform/log/common/log.js";import{toErrorMessage as C}from"../../../../base/common/errorMessage.js";import{isNonEmptyArray as w}from"../../../../base/common/arrays.js";import{CancellationToken as m}from"../../../../base/common/cancellation.js";import{localize as x}from"../../../../nls.js";import{IProductService as M}from"../../../../platform/product/common/productService.js";import{IConfigurationService as b}from"../../../../platform/configuration/common/configuration.js";import{Promises as G}from"../../../../base/common/async.js";import{IExtensionManifestPropertiesService as L}from"../../extensions/common/extensionManifestPropertiesService.js";import{IFileService as U}from"../../../../platform/files/common/files.js";import{RemoteExtensionManagementService as T}from"../common/remoteExtensionManagementService.js";import{IUserDataProfilesService as R}from"../../../../platform/userDataProfile/common/userDataProfile.js";import{IUserDataProfileService as F}from"../../userDataProfile/common/userDataProfile.js";import{IRemoteUserDataProfilesService as N}from"../../userDataProfile/common/remoteUserDataProfiles.js";import{IUriIdentityService as V}from"../../../../platform/uriIdentity/common/uriIdentity.js";import{areApiProposalsCompatible as _}from"../../../../platform/extensions/common/extensionValidator.js";let I=class extends T{constructor(e,n,i,t,r,a,v,o,l,f,$,W){super(e,i,t,r,a);this.localExtensionManagementServer=n;this.logService=v;this.galleryService=o;this.configurationService=l;this.productService=f;this.fileService=$;this.extensionManifestPropertiesService=W}async install(e,n){const i=await super.install(e,n);return await this.installUIDependenciesAndPackedExtensions(i),i}async installFromGallery(e,n){const i=await this.doInstallFromGallery(e,n);return await this.installUIDependenciesAndPackedExtensions(i),i}async doInstallFromGallery(e,n){if(this.configurationService.getValue("remote.downloadExtensionsLocally"))return this.downloadAndInstall(e,n||{});try{const i=await this.localExtensionManagementServer.extensionManagementService.getTargetPlatform();return await super.installFromGallery(e,{...n,context:{...n?.context,[A]:i}})}catch(i){switch(i.name){case c.Download:case c.DownloadSignature:case c.Gallery:case c.Internal:case c.Unknown:try{return this.logService.error(`Error while installing '${e.identifier.id}' extension in the remote server.`,C(i)),await this.downloadAndInstall(e,n||{})}catch(t){throw this.logService.error(t),t}default:throw this.logService.debug("Remote Install Error Name",i.name),i}}}async downloadAndInstall(e,n){this.logService.info(`Downloading the '${e.identifier.id}' extension locally and install`);const i=await this.checkAndGetCompatible(e,!!n.installPreReleaseVersion);n={...n,donotIncludePackAndDependencies:!0};const t=await this.getInstalled(k.User,void 0,n.productVersion),r=await this.getAllWorkspaceDependenciesAndPackedExtensions(i,m.None);if(r.length){this.logService.info(`Downloading the workspace dependencies and packed extensions of '${i.identifier.id}' locally and install`);for(const a of r)await this.downloadCompatibleAndInstall(a,t,n)}return await this.downloadCompatibleAndInstall(i,t,n)}async downloadCompatibleAndInstall(e,n,i){const t=await this.checkAndGetCompatible(e,!!i.installPreReleaseVersion);this.logService.trace("Downloading extension:",t.identifier.id);const r=await this.localExtensionManagementServer.extensionManagementService.download(t,n.filter(a=>y(a.identifier,t.identifier))[0]?E.Update:E.Install,!!i.donotVerifySignature);this.logService.info("Downloaded extension:",t.identifier.id,r.path);try{const a=await super.install(r,{...i,keepExisting:!0});return this.logService.info(`Successfully installed '${t.identifier.id}' extension`),a}finally{try{await this.fileService.del(r)}catch(a){this.logService.error(a)}}}async checkAndGetCompatible(e,n){const i=await this.getTargetPlatform();let t=null;if(e.hasPreReleaseVersion&&e.properties.isPreReleaseVersion!==n&&(t=(await this.galleryService.getExtensions([{...e.identifier,preRelease:n}],{targetPlatform:i,compatible:!0},m.None))[0]||null),!t&&await this.galleryService.isExtensionCompatible(e,n,i)&&(t=e),t||(t=await this.galleryService.getCompatibleExtension(e,n,i)),!t){const r=[];throw _(e.properties.enabledApiProposals??[],r)?!n&&e.properties.isPreReleaseVersion&&(await this.galleryService.getExtensions([e.identifier],m.None))[0]?new g(x("notFoundReleaseExtension","Can't install release version of '{0}' extension because it has no release version.",e.identifier.id),c.ReleaseVersionNotFound):new g(x("notFoundCompatibleDependency","Can't install '{0}' extension because it is not compatible with the current version of {1} (version {2}).",e.identifier.id,this.productService.nameLong,this.productService.version),c.Incompatible):new g(x("incompatibleAPI","Can't install '{0}' extension. {1}",e.displayName??e.identifier.id,r[0]),c.IncompatibleApi)}return t}async installUIDependenciesAndPackedExtensions(e){const n=await this.getAllUIDependenciesAndPackedExtensions(e.manifest,m.None),i=await this.localExtensionManagementServer.extensionManagementService.getInstalled(),t=n.filter(r=>i.every(a=>!y(a.identifier,r.identifier)));t.length&&(this.logService.info(`Installing UI dependencies and packed extensions of '${e.identifier.id}' locally`),await G.settled(t.map(r=>this.localExtensionManagementServer.extensionManagementService.installFromGallery(r))))}async getAllUIDependenciesAndPackedExtensions(e,n){const i=new Map,t=[...e.extensionPack||[],...e.extensionDependencies||[]];return await this.getDependenciesAndPackedExtensionsRecursively(t,i,!0,n),[...i.values()]}async getAllWorkspaceDependenciesAndPackedExtensions(e,n){const i=new Map;i.set(e.identifier.id.toLowerCase(),e);const t=await this.galleryService.getManifest(e,n);if(t){const r=[...t.extensionPack||[],...t.extensionDependencies||[]];await this.getDependenciesAndPackedExtensionsRecursively(r,i,!1,n)}return i.delete(e.identifier.id),[...i.values()]}async getDependenciesAndPackedExtensionsRecursively(e,n,i,t){if(e.length===0)return Promise.resolve();const r=await this.galleryService.getExtensions(e.map(o=>({id:o})),t),a=await Promise.all(r.map(o=>this.galleryService.getManifest(o,t))),v=[];for(let o=0;o<r.length;o++){const l=r[o],f=a[o];f&&this.extensionManifestPropertiesService.prefersExecuteOnUI(f)===i&&(n.set(l.identifier.id.toLowerCase(),l),v.push(f))}e=[];for(const o of v){if(w(o.extensionDependencies))for(const l of o.extensionDependencies)n.has(l.toLowerCase())||e.push(l);if(w(o.extensionPack))for(const l of o.extensionPack)n.has(l.toLowerCase())||e.push(l)}return this.getDependenciesAndPackedExtensionsRecursively(e,n,i,t)}};I=h([s(2,F),s(3,R),s(4,N),s(5,V),s(6,D),s(7,P),s(8,b),s(9,M),s(10,U),s(11,L)],I);export{I as NativeRemoteExtensionManagementService};
