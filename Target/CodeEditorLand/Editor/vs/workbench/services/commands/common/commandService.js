var E=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var v=(r,o,e,t)=>{for(var n=t>1?void 0:t?u(o,e):o,i=r.length-1,a;i>=0;i--)(a=r[i])&&(n=(t?a(o,e,n):a(n))||n);return t&&n&&E(o,e,n),n},s=(r,o)=>(e,t)=>o(e,t,r);import{IInstantiationService as _}from"../../../../platform/instantiation/common/instantiation.js";import{ICommandService as x,CommandsRegistry as c}from"../../../../platform/commands/common/commands.js";import{IExtensionService as y}from"../../extensions/common/extensions.js";import{Event as d,Emitter as l}from"../../../../base/common/event.js";import{Disposable as h}from"../../../../base/common/lifecycle.js";import{ILogService as C}from"../../../../platform/log/common/log.js";import{InstantiationType as I,registerSingleton as p}from"../../../../platform/instantiation/common/extensions.js";import{timeout as S}from"../../../../base/common/async.js";let m=class extends h{constructor(e,t,n){super();this._instantiationService=e;this._extensionService=t;this._logService=n;this._extensionService.whenInstalledExtensionsRegistered().then(i=>this._extensionHostIsReady=i),this._starActivation=null}_extensionHostIsReady=!1;_starActivation;_onWillExecuteCommand=this._register(new l);onWillExecuteCommand=this._onWillExecuteCommand.event;_onDidExecuteCommand=new l;onDidExecuteCommand=this._onDidExecuteCommand.event;_activateStar(){return this._starActivation||(this._starActivation=Promise.race([this._extensionService.activateByEvent("*"),S(3e4)])),this._starActivation}async executeCommand(e,...t){this._logService.trace("CommandService#executeCommand",e);const n=`onCommand:${e}`;return c.getCommand(e)?this._extensionService.activationEventIsDone(n)?this._tryExecuteCommand(e,t):this._extensionHostIsReady?(await this._extensionService.activateByEvent(n),this._tryExecuteCommand(e,t)):(this._extensionService.activateByEvent(n),this._tryExecuteCommand(e,t)):(await Promise.all([this._extensionService.activateByEvent(n),Promise.race([this._activateStar(),d.toPromise(d.filter(c.onDidRegisterCommand,a=>a===e))])]),this._tryExecuteCommand(e,t))}_tryExecuteCommand(e,t){const n=c.getCommand(e);if(!n)return Promise.reject(new Error(`command '${e}' not found`));try{this._onWillExecuteCommand.fire({commandId:e,args:t});const i=this._instantiationService.invokeFunction(n.handler,...t);return this._onDidExecuteCommand.fire({commandId:e,args:t}),Promise.resolve(i)}catch(i){return Promise.reject(i)}}};m=v([s(0,_),s(1,y),s(2,C)],m),p(x,m,I.Delayed);export{m as CommandService};
