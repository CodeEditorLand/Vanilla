import{importAMDNodeModule as f}from"../../../../../vs/amdX.js";import{StopWatch as h}from"../../../../../vs/base/common/stopwatch.js";import"../../../../../vs/base/common/worker/simpleWorker.js";import{WorkerTextModelSyncServer as v}from"../../../../../vs/editor/common/services/textModelSync/textModelSync.impl.js";import{LanguageDetectionWorkerHost as m}from"../../../../../vs/workbench/services/languageDetection/browser/languageDetectionWorker.protocol.js";function _(p){return new a(p)}class a{_requestHandlerBrand;static expectedRelativeConfidence=.2;static positiveConfidenceCorrectionBucket1=.05;static positiveConfidenceCorrectionBucket2=.025;static negativeConfidenceCorrection=.5;_workerTextModelSyncServer=new v;_host;_regexpModel;_regexpLoadFailed=!1;_modelOperations;_loadFailed=!1;modelIdToCoreId=new Map;constructor(e){this._host=m.getChannel(e),this._workerTextModelSyncServer.bindToServer(e)}async $detectLanguage(e,o,n,r){const i=[],t=[],c=new h,l=this.getTextForDetection(e);if(!l)return;const u=async()=>{for await(const s of this.detectLanguagesImpl(l)){this.modelIdToCoreId.has(s.languageId)||this.modelIdToCoreId.set(s.languageId,await this._host.$getLanguageId(s.languageId));const d=this.modelIdToCoreId.get(s.languageId);d&&(!r?.length||r.includes(d))&&(i.push(d),t.push(s.confidence))}if(c.stop(),i.length)return this._host.$sendTelemetryEvent(i,t,c.elapsed()),i[0]},g=async()=>this.runRegexpModel(l,o??{},r);if(n){const s=await g();if(s)return s;const d=await u();if(d)return d}else{const s=await u();if(s)return s;const d=await g();if(d)return d}}getTextForDetection(e){const o=this._workerTextModelSyncServer.getModel(e);if(!o)return;const n=o.positionAt(1e4);return o.getValueInRange({startColumn:1,startLineNumber:1,endColumn:n.column,endLineNumber:n.lineNumber})}async getRegexpModel(){if(this._regexpLoadFailed)return;if(this._regexpModel)return this._regexpModel;const e=await this._host.$getRegexpModelUri();try{return this._regexpModel=await f(e,""),this._regexpModel}catch{this._regexpLoadFailed=!0;return}}async runRegexpModel(e,o,n){const r=await this.getRegexpModel();if(!r)return;if(n?.length)for(const t of Object.keys(o))n.includes(t)?o[t]=1:o[t]=0;return r.detect(e,o,n)}async getModelOperations(){if(this._modelOperations)return this._modelOperations;const e=await this._host.$getIndexJsUri(),{ModelOperations:o}=await f(e,"");return this._modelOperations=new o({modelJsonLoaderFunc:async()=>{const n=await fetch(await this._host.$getModelJsonUri());try{return await n.json()}catch{const i="Failed to parse model JSON.";throw new Error(i)}},weightsLoaderFunc:async()=>await(await fetch(await this._host.$getWeightsUri())).arrayBuffer()}),this._modelOperations}adjustLanguageConfidence(e){switch(e.languageId){case"js":case"html":case"json":case"ts":case"css":case"py":case"xml":case"php":e.confidence+=a.positiveConfidenceCorrectionBucket1;break;case"cpp":case"sh":case"java":case"cs":case"c":e.confidence+=a.positiveConfidenceCorrectionBucket2;break;case"bat":case"ini":case"makefile":case"sql":case"csv":case"toml":e.confidence-=a.negativeConfidenceCorrection;break;default:break}return e}async*detectLanguagesImpl(e){if(this._loadFailed)return;let o;try{o=await this.getModelOperations()}catch(t){console.log(t),this._loadFailed=!0;return}let n;try{n=await o.runModel(e)}catch(t){console.warn(t)}if(!n||n.length===0||n[0].confidence<a.expectedRelativeConfidence)return;const r=this.adjustLanguageConfidence(n[0]);if(r.confidence<a.expectedRelativeConfidence)return;const i=[r];for(let t of n){if(t===r)continue;if(t=this.adjustLanguageConfidence(t),i[i.length-1].confidence-t.confidence>=a.expectedRelativeConfidence){for(;i.length;)yield i.shift();if(t.confidence>a.expectedRelativeConfidence){i.push(t);continue}return}else{if(t.confidence>a.expectedRelativeConfidence){i.push(t);continue}return}}}}export{a as LanguageDetectionSimpleWorker,_ as create};
