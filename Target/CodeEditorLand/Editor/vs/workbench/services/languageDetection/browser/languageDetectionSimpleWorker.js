import{importAMDNodeModule as f}from"../../../../amdX.js";import{StopWatch as h}from"../../../../base/common/stopwatch.js";import{WorkerTextModelSyncServer as m}from"../../../../editor/common/services/textModelSync/textModelSync.impl.js";import{LanguageDetectionWorkerHost as v}from"./languageDetectionWorker.protocol.js";function C(p){return new a(p)}class a{_requestHandlerBrand;static expectedRelativeConfidence=.2;static positiveConfidenceCorrectionBucket1=.05;static positiveConfidenceCorrectionBucket2=.025;static negativeConfidenceCorrection=.5;_workerTextModelSyncServer=new m;_host;_regexpModel;_regexpLoadFailed=!1;_modelOperations;_loadFailed=!1;modelIdToCoreId=new Map;constructor(e){this._host=v.getChannel(e),this._workerTextModelSyncServer.bindToServer(e)}async $detectLanguage(e,r,t,o){const i=[],n=[],c=new h,l=this.getTextForDetection(e);if(!l)return;const u=async()=>{for await(const s of this.detectLanguagesImpl(l)){this.modelIdToCoreId.has(s.languageId)||this.modelIdToCoreId.set(s.languageId,await this._host.$getLanguageId(s.languageId));const d=this.modelIdToCoreId.get(s.languageId);d&&(!o?.length||o.includes(d))&&(i.push(d),n.push(s.confidence))}if(c.stop(),i.length)return this._host.$sendTelemetryEvent(i,n,c.elapsed()),i[0]},g=async()=>this.runRegexpModel(l,r??{},o);if(t){const s=await g();if(s)return s;const d=await u();if(d)return d}else{const s=await u();if(s)return s;const d=await g();if(d)return d}}getTextForDetection(e){const r=this._workerTextModelSyncServer.getModel(e);if(!r)return;const t=r.positionAt(1e4);return r.getValueInRange({startColumn:1,startLineNumber:1,endColumn:t.column,endLineNumber:t.lineNumber})}async getRegexpModel(){if(this._regexpLoadFailed)return;if(this._regexpModel)return this._regexpModel;const e=await this._host.$getRegexpModelUri();try{return this._regexpModel=await f(e,""),this._regexpModel}catch{this._regexpLoadFailed=!0;return}}async runRegexpModel(e,r,t){const o=await this.getRegexpModel();if(!o)return;if(t?.length)for(const n of Object.keys(r))t.includes(n)?r[n]=1:r[n]=0;return o.detect(e,r,t)}async getModelOperations(){if(this._modelOperations)return this._modelOperations;const e=await this._host.$getIndexJsUri(),{ModelOperations:r}=await f(e,"");return this._modelOperations=new r({modelJsonLoaderFunc:async()=>{const t=await fetch(await this._host.$getModelJsonUri());try{return await t.json()}catch{const i="Failed to parse model JSON.";throw new Error(i)}},weightsLoaderFunc:async()=>await(await fetch(await this._host.$getWeightsUri())).arrayBuffer()}),this._modelOperations}adjustLanguageConfidence(e){switch(e.languageId){case"js":case"html":case"json":case"ts":case"css":case"py":case"xml":case"php":e.confidence+=a.positiveConfidenceCorrectionBucket1;break;case"cpp":case"sh":case"java":case"cs":case"c":e.confidence+=a.positiveConfidenceCorrectionBucket2;break;case"bat":case"ini":case"makefile":case"sql":case"csv":case"toml":e.confidence-=a.negativeConfidenceCorrection;break;default:break}return e}async*detectLanguagesImpl(e){if(this._loadFailed)return;let r;try{r=await this.getModelOperations()}catch{this._loadFailed=!0;return}let t;try{t=await r.runModel(e)}catch{}if(!t||t.length===0||t[0].confidence<a.expectedRelativeConfidence)return;const o=this.adjustLanguageConfidence(t[0]);if(o.confidence<a.expectedRelativeConfidence)return;const i=[o];for(let n of t){if(n===o)continue;if(n=this.adjustLanguageConfidence(n),i[i.length-1].confidence-n.confidence>=a.expectedRelativeConfidence){for(;i.length;)yield i.shift();if(n.confidence>a.expectedRelativeConfidence){i.push(n);continue}return}else{if(n.confidence>a.expectedRelativeConfidence){i.push(n);continue}return}}}}export{a as LanguageDetectionSimpleWorker,C as create};
