var k=Object.defineProperty;var D=Object.getOwnPropertyDescriptor;var R=(A,p,e,t)=>{for(var s=t>1?void 0:t?D(p,e):p,i=A.length-1,o;i>=0;i--)(o=A[i])&&(s=(t?o(p,e,s):o(s))||s);return t&&s&&k(p,e,s),s},m=(A,p)=>(e,t)=>p(e,t,A);import{Disposable as O,DisposableStore as $,dispose as T,MutableDisposable as j}from"../../../../../vs/base/common/lifecycle.js";import*as d from"../../../../../vs/nls.js";import{MenuId as y,MenuRegistry as w}from"../../../../../vs/platform/actions/common/actions.js";import{CommandsRegistry as I}from"../../../../../vs/platform/commands/common/commands.js";import{IDialogService as B}from"../../../../../vs/platform/dialogs/common/dialogs.js";import{InstantiationType as M,registerSingleton as z}from"../../../../../vs/platform/instantiation/common/extensions.js";import{Severity as L}from"../../../../../vs/platform/notification/common/notification.js";import{IQuickInputService as U}from"../../../../../vs/platform/quickinput/common/quickInput.js";import{IStorageService as H,StorageScope as S,StorageTarget as _}from"../../../../../vs/platform/storage/common/storage.js";import{IActivityService as G,NumberBadge as W}from"../../../../../vs/workbench/services/activity/common/activity.js";import{IAuthenticationAccessService as x}from"../../../../../vs/workbench/services/authentication/browser/authenticationAccessService.js";import{IAuthenticationUsageService as K}from"../../../../../vs/workbench/services/authentication/browser/authenticationUsageService.js";import{IAuthenticationExtensionsService as N,IAuthenticationService as P}from"../../../../../vs/workbench/services/authentication/common/authentication.js";const v=" ";let f=class extends O{constructor(e,t,s,i,o,n,a){super();this.activityService=e;this.storageService=t;this.dialogService=s;this.quickInputService=i;this._authenticationService=o;this._authenticationUsageService=n;this._authenticationAccessService=a;this.registerListeners()}_signInRequestItems=new Map;_sessionAccessRequestItems=new Map;_accountBadgeDisposable=this._register(new j);registerListeners(){this._register(this._authenticationService.onDidChangeSessions(async e=>{e.event.added?.length&&await this.updateNewSessionRequests(e.providerId,e.event.added),e.event.removed?.length&&await this.updateAccessRequests(e.providerId,e.event.removed),this.updateBadgeCount()})),this._register(this._authenticationService.onDidUnregisterAuthenticationProvider(e=>{const t=this._sessionAccessRequestItems.get(e.id)||{};Object.keys(t).forEach(s=>{this.removeAccessRequest(e.id,s)})}))}async updateNewSessionRequests(e,t){const s=this._signInRequestItems.get(e);s&&Object.keys(s).forEach(i=>{t.some(o=>o.scopes.slice().join(v)===i)&&(s[i]?.disposables.forEach(n=>n.dispose()),delete s[i],Object.keys(s).length===0?this._signInRequestItems.delete(e):this._signInRequestItems.set(e,s))})}async updateAccessRequests(e,t){const s=this._sessionAccessRequestItems.get(e);s&&Object.keys(s).forEach(i=>{t.forEach(o=>{const n=s[i].possibleSessions.findIndex(a=>a.id===o.id);n&&s[i].possibleSessions.splice(n,1)}),s[i].possibleSessions.length||this.removeAccessRequest(e,i)})}updateBadgeCount(){this._accountBadgeDisposable.clear();let e=0;if(this._signInRequestItems.forEach(t=>{Object.keys(t).forEach(s=>{e+=t[s].requestingExtensionIds.length})}),this._sessionAccessRequestItems.forEach(t=>{e+=Object.keys(t).length}),e>0){const t=new W(e,()=>d.localize("sign in","Sign in requested"));this._accountBadgeDisposable.value=this.activityService.showAccountsActivity({badge:t})}}removeAccessRequest(e,t){const s=this._sessionAccessRequestItems.get(e)||{};s[t]&&(T(s[t].disposables),delete s[t],this.updateBadgeCount())}updateSessionPreference(e,t,s){const i=`${t}-${e}-${s.scopes.join(v)}`;this.storageService.store(i,s.id,S.WORKSPACE,_.MACHINE),this.storageService.store(i,s.id,S.APPLICATION,_.MACHINE)}getSessionPreference(e,t,s){const i=`${t}-${e}-${s.join(v)}`;return this.storageService.get(i,S.WORKSPACE)??this.storageService.get(i,S.APPLICATION)}removeSessionPreference(e,t,s){const i=`${t}-${e}-${s.join(v)}`;this.storageService.remove(i,S.WORKSPACE),this.storageService.remove(i,S.APPLICATION)}async showGetSessionPrompt(e,t,s,i){let o;(u=>(u[u.Allow=0]="Allow",u[u.Deny=1]="Deny",u[u.Cancel=2]="Cancel"))(o||={});const{result:n}=await this.dialogService.prompt({type:L.Info,message:d.localize("confirmAuthenticationAccess","The extension '{0}' wants to access the {1} account '{2}'.",i,e.label,t),buttons:[{label:d.localize({key:"allow",comment:["&& denotes a mnemonic"]},"&&Allow"),run:()=>0},{label:d.localize({key:"deny",comment:["&& denotes a mnemonic"]},"&&Deny"),run:()=>1}],cancelButton:{run:()=>2}});return n!==2&&(this._authenticationAccessService.updateAllowedExtensions(e.id,t,[{id:s,name:i,allowed:n===0}]),this.removeAccessRequest(e.id,s)),n===0}async selectSession(e,t,s,i,o){const n=await this._authenticationService.getAccounts(e);if(!n.length)throw new Error("No accounts available");const a=new $,c=a.add(this.quickInputService.createQuickPick());c.ignoreFocusOut=!0;const l=o.map(r=>({label:r.account.label,session:r})),u=new Set(o.map(r=>r.account.label));return n.forEach(r=>{u.has(r.label)||l.push({label:r.label,account:r})}),l.push({label:d.localize("useOtherAccount","Sign in to another account")}),c.items=l,c.title=d.localize({key:"selectAccount",comment:["The placeholder {0} is the name of an extension. {1} is the name of the type of account, such as Microsoft or GitHub."]},"The extension '{0}' wants to access a {1} account",s,this._authenticationService.getProvider(e).label),c.placeholder=d.localize("getSessionPlateholder","Select an account for '{0}' to use or Esc to cancel",s),await new Promise((r,h)=>{a.add(c.onDidAccept(async b=>{c.dispose();let g=c.selectedItems[0].session;if(!g){const E=c.selectedItems[0].account;try{g=await this._authenticationService.createSession(e,i,{account:E})}catch(C){h(C);return}}const q=g.account.label;this._authenticationAccessService.updateAllowedExtensions(e,q,[{id:t,name:s,allowed:!0}]),this.updateSessionPreference(e,t,g),this.removeAccessRequest(e,t),r(g)})),a.add(c.onDidHide(b=>{c.selectedItems[0]||h("User did not consent to account access"),a.dispose()})),c.show()})}async completeSessionAccessRequest(e,t,s,i){const n=(this._sessionAccessRequestItems.get(e.id)||{})[t];if(!n||!e)return;const a=n.possibleSessions;let c;if(e.supportsMultipleAccounts)try{c=await this.selectSession(e.id,t,s,i,a)}catch{}else await this.showGetSessionPrompt(e,a[0].account.label,t,s)&&(c=a[0]);c&&this._authenticationUsageService.addAccountUsage(e.id,c.account.label,t,s)}requestSessionAccess(e,t,s,i,o){const n=this._sessionAccessRequestItems.get(e)||{};if(n[t])return;const c=this._authenticationService.getProvider(e),l=w.appendMenuItem(y.AccountsContext,{group:"3_accessRequests",command:{id:`${e}${t}Access`,title:d.localize({key:"accessRequest",comment:["The placeholder {0} will be replaced with an authentication provider''s label. {1} will be replaced with an extension name. (1) is to indicate that this menu item contributes to a badge count"]},"Grant access to {0} for {1}... (1)",c.label,s)}}),u=I.registerCommand({id:`${e}${t}Access`,handler:async r=>{this.completeSessionAccessRequest(c,t,s,i)}});n[t]={possibleSessions:o,disposables:[l,u]},this._sessionAccessRequestItems.set(e,n),this.updateBadgeCount()}async requestNewSession(e,t,s,i){this._authenticationService.isAuthenticationProviderRegistered(e)||await new Promise((h,b)=>{const g=this._authenticationService.onDidRegisterAuthenticationProvider(q=>{q.id===e&&(g.dispose(),h())})});let o;try{o=this._authenticationService.getProvider(e)}catch{return}const n=this._signInRequestItems.get(e),a=t.join(v);if(n&&n[a]&&n[a].requestingExtensionIds.includes(s))return;const l=`${e}:${s}:signIn${Object.keys(n||[]).length}`,u=w.appendMenuItem(y.AccountsContext,{group:"2_signInRequests",command:{id:l,title:d.localize({key:"signInRequest",comment:["The placeholder {0} will be replaced with an authentication provider's label. {1} will be replaced with an extension name. (1) is to indicate that this menu item contributes to a badge count."]},"Sign in with {0} to use {1} (1)",o.label,i)}}),r=I.registerCommand({id:l,handler:async h=>{const g=await h.get(P).createSession(e,t);this._authenticationAccessService.updateAllowedExtensions(e,g.account.label,[{id:s,name:i,allowed:!0}]),this.updateSessionPreference(e,s,g)}});if(n){const h=n[a]||{disposables:[],requestingExtensionIds:[]};n[a]={disposables:[...h.disposables,u,r],requestingExtensionIds:[...h.requestingExtensionIds,s]},this._signInRequestItems.set(e,n)}else this._signInRequestItems.set(e,{[a]:{disposables:[u,r],requestingExtensionIds:[s]}});this.updateBadgeCount()}};f=R([m(0,G),m(1,H),m(2,B),m(3,U),m(4,P),m(5,K),m(6,x)],f),z(N,f,M.Delayed);export{f as AuthenticationExtensionsService};
