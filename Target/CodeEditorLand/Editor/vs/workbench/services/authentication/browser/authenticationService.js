var S=Object.defineProperty;var I=Object.getOwnPropertyDescriptor;var p=(o,s,e,t)=>{for(var i=t>1?void 0:t?I(s,e):s,n=o.length-1,r;n>=0;n--)(r=o[n])&&(i=(t?r(s,e,i):r(i))||i);return t&&i&&S(s,e,i),i},c=(o,s)=>(e,t)=>s(e,t,o);import{Emitter as d,Event as y}from"../../../../base/common/event.js";import{Disposable as _,DisposableMap as D,DisposableStore as P,isDisposable as b,toDisposable as w}from"../../../../base/common/lifecycle.js";import{isFalsyOrWhitespace as m}from"../../../../base/common/strings.js";import{isString as v}from"../../../../base/common/types.js";import{localize as u}from"../../../../nls.js";import{InstantiationType as E,registerSingleton as C}from"../../../../platform/instantiation/common/extensions.js";import{IBrowserWorkbenchEnvironmentService as x}from"../../environment/browser/environmentService.js";import{ActivationKind as A,IExtensionService as R}from"../../extensions/common/extensions.js";import{IAuthenticationService as N}from"../common/authentication.js";import{IAuthenticationAccessService as T}from"./authenticationAccessService.js";function $(o){return`onAuthenticationRequest:${o}`}async function K(o,s){const e=await o.get(`${s.urlProtocol}.loginAccount`);if(e)try{const t=JSON.parse(e);if(t&&v(t.id)&&v(t.accessToken)&&v(t.providerId))return t}catch{}}let a=class extends _{constructor(e,t,i){super();this._extensionService=e;this._environmentService=i;this._register(t.onDidChangeExtensionSessionAccess(n=>{this._onDidChangeSessions.fire({providerId:n.providerId,label:n.accountName,event:{added:[],changed:[],removed:[]}})})),this._registerEnvContributedAuthenticationProviders()}_onDidRegisterAuthenticationProvider=this._register(new d);onDidRegisterAuthenticationProvider=this._onDidRegisterAuthenticationProvider.event;_onDidUnregisterAuthenticationProvider=this._register(new d);onDidUnregisterAuthenticationProvider=this._onDidUnregisterAuthenticationProvider.event;_onDidChangeSessions=this._register(new d);onDidChangeSessions=this._onDidChangeSessions.event;_onDidChangeDeclaredProviders=this._register(new d);onDidChangeDeclaredProviders=this._onDidChangeDeclaredProviders.event;_authenticationProviders=new Map;_authenticationProviderDisposables=this._register(new D);_declaredProviders=[];get declaredProviders(){return this._declaredProviders}_registerEnvContributedAuthenticationProviders(){if(this._environmentService.options?.authenticationProviders?.length)for(const e of this._environmentService.options.authenticationProviders)this.registerAuthenticationProvider(e.id,e)}registerDeclaredAuthenticationProvider(e){if(m(e.id))throw new Error(u("authentication.missingId","An authentication contribution must specify an id."));if(m(e.label))throw new Error(u("authentication.missingLabel","An authentication contribution must specify a label."));if(this.declaredProviders.some(t=>t.id===e.id))throw new Error(u("authentication.idConflict","This authentication id '{0}' has already been registered",e.id));this._declaredProviders.push(e),this._onDidChangeDeclaredProviders.fire()}unregisterDeclaredAuthenticationProvider(e){const t=this.declaredProviders.findIndex(i=>i.id===e);t>-1&&this.declaredProviders.splice(t,1),this._onDidChangeDeclaredProviders.fire()}isAuthenticationProviderRegistered(e){return this._authenticationProviders.has(e)}registerAuthenticationProvider(e,t){this._authenticationProviders.set(e,t);const i=new P;i.add(t.onDidChangeSessions(n=>this._onDidChangeSessions.fire({providerId:e,label:t.label,event:n}))),b(t)&&i.add(t),this._authenticationProviderDisposables.set(e,i),this._onDidRegisterAuthenticationProvider.fire({id:e,label:t.label})}unregisterAuthenticationProvider(e){const t=this._authenticationProviders.get(e);t&&(this._authenticationProviders.delete(e),this._onDidUnregisterAuthenticationProvider.fire({id:e,label:t.label})),this._authenticationProviderDisposables.deleteAndDispose(e)}getProviderIds(){const e=[];return this._authenticationProviders.forEach(t=>{e.push(t.id)}),e}getProvider(e){if(this._authenticationProviders.has(e))return this._authenticationProviders.get(e);throw new Error(`No authentication provider '${e}' is currently registered.`)}async getAccounts(e){const t=await this.getSessions(e),i=new Array,n=new Set;for(const r of t)n.has(r.account.label)||(n.add(r.account.label),i.push(r.account));return i}async getSessions(e,t,i,n=!1){const r=this._authenticationProviders.get(e)||await this.tryActivateProvider(e,n);if(r)return await r.getSessions(t,{account:i});throw new Error(`No authentication provider '${e}' is currently registered.`)}async createSession(e,t,i){const n=this._authenticationProviders.get(e)||await this.tryActivateProvider(e,!!i?.activateImmediate);if(n)return await n.createSession(t,{account:i?.account});throw new Error(`No authentication provider '${e}' is currently registered.`)}async removeSession(e,t){const i=this._authenticationProviders.get(e);if(i)return i.removeSession(t);throw new Error(`No authentication provider '${e}' is currently registered.`)}async tryActivateProvider(e,t){await this._extensionService.activateByEvent($(e),t?A.Immediate:A.Normal);let i=this._authenticationProviders.get(e);if(i)return i;const n=new P,r=new Promise((l,g)=>{n.add(y.once(this.onDidRegisterAuthenticationProvider)(h=>{if(h.id===e)if(i=this._authenticationProviders.get(e),i)l(i);else throw new Error(`No authentication provider '${e}' is currently registered.`)}))}),f=new Promise((l,g)=>{const h=setTimeout(()=>{g("Timed out waiting for authentication provider to register")},5e3);n.add(w(()=>clearTimeout(h)))});return Promise.race([r,f]).finally(()=>n.dispose())}};a=p([c(0,R),c(1,T),c(2,x)],a),C(N,a,E.Delayed);export{a as AuthenticationService,$ as getAuthenticationProviderActivationEvent,K as getCurrentAuthenticationSessionInfo};
