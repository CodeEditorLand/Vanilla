{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/authentication/common/authentication.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport type { Event } from \"../../../../base/common/event.js\";\nimport { createDecorator } from \"../../../../platform/instantiation/common/instantiation.js\";\n\n/**\n * Use this if you don't want the onDidChangeSessions event to fire in the extension host\n */\nexport const INTERNAL_AUTH_PROVIDER_PREFIX = \"__\";\n\nexport interface AuthenticationSessionAccount {\n\tlabel: string;\n\tid: string;\n}\n\nexport interface AuthenticationSession {\n\tid: string;\n\taccessToken: string;\n\taccount: AuthenticationSessionAccount;\n\tscopes: ReadonlyArray<string>;\n\tidToken?: string;\n}\n\nexport interface AuthenticationSessionsChangeEvent {\n\tadded: ReadonlyArray<AuthenticationSession> | undefined;\n\tremoved: ReadonlyArray<AuthenticationSession> | undefined;\n\tchanged: ReadonlyArray<AuthenticationSession> | undefined;\n}\n\nexport interface AuthenticationProviderInformation {\n\tid: string;\n\tlabel: string;\n}\n\nexport interface IAuthenticationCreateSessionOptions {\n\tactivateImmediate?: boolean;\n\t/**\n\t * The account that is being asked about. If this is passed in, the provider should\n\t * attempt to return the sessions that are only related to this account.\n\t */\n\taccount?: AuthenticationSessionAccount;\n}\n\nexport interface AllowedExtension {\n\tid: string;\n\tname: string;\n\t/**\n\t * If true or undefined, the extension is allowed to use the account\n\t * If false, the extension is not allowed to use the account\n\t * TODO: undefined shouldn't be a valid value, but it is for now\n\t */\n\tallowed?: boolean;\n\tlastUsed?: number;\n\t// If true, this comes from the product.json\n\ttrusted?: boolean;\n}\n\nexport const IAuthenticationService = createDecorator<IAuthenticationService>(\n\t\"IAuthenticationService\",\n);\n\nexport interface IAuthenticationService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Fires when an authentication provider has been registered\n\t */\n\treadonly onDidRegisterAuthenticationProvider: Event<AuthenticationProviderInformation>;\n\t/**\n\t * Fires when an authentication provider has been unregistered\n\t */\n\treadonly onDidUnregisterAuthenticationProvider: Event<AuthenticationProviderInformation>;\n\n\t/**\n\t * Fires when the list of sessions for a provider has been added, removed or changed\n\t */\n\treadonly onDidChangeSessions: Event<{\n\t\tproviderId: string;\n\t\tlabel: string;\n\t\tevent: AuthenticationSessionsChangeEvent;\n\t}>;\n\n\t/**\n\t * Fires when the list of declaredProviders has changed\n\t */\n\treadonly onDidChangeDeclaredProviders: Event<void>;\n\n\t/**\n\t * All providers that have been statically declared by extensions. These may not actually be registered or active yet.\n\t */\n\treadonly declaredProviders: AuthenticationProviderInformation[];\n\n\t/**\n\t * Registers that an extension has declared an authentication provider in their package.json\n\t * @param provider The provider information to register\n\t */\n\tregisterDeclaredAuthenticationProvider(\n\t\tprovider: AuthenticationProviderInformation,\n\t): void;\n\n\t/**\n\t * Unregisters a declared authentication provider\n\t * @param id The id of the provider to unregister\n\t */\n\tunregisterDeclaredAuthenticationProvider(id: string): void;\n\n\t/**\n\t * Checks if an authentication provider has been registered\n\t * @param id The id of the provider to check\n\t */\n\tisAuthenticationProviderRegistered(id: string): boolean;\n\n\t/**\n\t * Registers an authentication provider\n\t * @param id The id of the provider\n\t * @param provider The implementation of the provider\n\t */\n\tregisterAuthenticationProvider(\n\t\tid: string,\n\t\tprovider: IAuthenticationProvider,\n\t): void;\n\n\t/**\n\t * Unregisters an authentication provider\n\t * @param id The id of the provider to unregister\n\t */\n\tunregisterAuthenticationProvider(id: string): void;\n\n\t/**\n\t * Gets the provider ids of all registered authentication providers\n\t */\n\tgetProviderIds(): string[];\n\n\t/**\n\t * Gets the provider with the given id.\n\t * @param id The id of the provider to get\n\t * @throws if the provider is not registered\n\t */\n\tgetProvider(id: string): IAuthenticationProvider;\n\n\t/**\n\t * Gets all accounts that are currently logged in across all sessions\n\t * @param id The id of the provider to ask for accounts\n\t * @returns A promise that resolves to an array of accounts\n\t */\n\tgetAccounts(\n\t\tid: string,\n\t): Promise<ReadonlyArray<AuthenticationSessionAccount>>;\n\n\t/**\n\t * Gets all sessions that satisfy the given scopes from the provider with the given id\n\t * @param id The id of the provider to ask for a session\n\t * @param scopes The scopes for the session\n\t * @param activateImmediate If true, the provider should activate immediately if it is not already\n\t */\n\tgetSessions(\n\t\tid: string,\n\t\tscopes?: string[],\n\t\taccount?: AuthenticationSessionAccount,\n\t\tactivateImmediate?: boolean,\n\t): Promise<ReadonlyArray<AuthenticationSession>>;\n\n\t/**\n\t * Creates an AuthenticationSession with the given provider and scopes\n\t * @param providerId The id of the provider\n\t * @param scopes The scopes to request\n\t * @param options Additional options for creating the session\n\t */\n\tcreateSession(\n\t\tproviderId: string,\n\t\tscopes: string[],\n\t\toptions?: IAuthenticationCreateSessionOptions,\n\t): Promise<AuthenticationSession>;\n\n\t/**\n\t * Removes the session with the given id from the provider with the given id\n\t * @param providerId The id of the provider\n\t * @param sessionId The id of the session to remove\n\t */\n\tremoveSession(providerId: string, sessionId: string): Promise<void>;\n}\n\n// TODO: Move this into MainThreadAuthentication\nexport const IAuthenticationExtensionsService =\n\tcreateDecorator<IAuthenticationExtensionsService>(\n\t\t\"IAuthenticationExtensionsService\",\n\t);\nexport interface IAuthenticationExtensionsService {\n\treadonly _serviceBrand: undefined;\n\n\tupdateSessionPreference(\n\t\tproviderId: string,\n\t\textensionId: string,\n\t\tsession: AuthenticationSession,\n\t): void;\n\tgetSessionPreference(\n\t\tproviderId: string,\n\t\textensionId: string,\n\t\tscopes: string[],\n\t): string | undefined;\n\tremoveSessionPreference(\n\t\tproviderId: string,\n\t\textensionId: string,\n\t\tscopes: string[],\n\t): void;\n\tselectSession(\n\t\tproviderId: string,\n\t\textensionId: string,\n\t\textensionName: string,\n\t\tscopes: string[],\n\t\tpossibleSessions: readonly AuthenticationSession[],\n\t): Promise<AuthenticationSession>;\n\trequestSessionAccess(\n\t\tproviderId: string,\n\t\textensionId: string,\n\t\textensionName: string,\n\t\tscopes: string[],\n\t\tpossibleSessions: readonly AuthenticationSession[],\n\t): void;\n\trequestNewSession(\n\t\tproviderId: string,\n\t\tscopes: string[],\n\t\textensionId: string,\n\t\textensionName: string,\n\t): Promise<void>;\n}\n\nexport interface IAuthenticationProviderSessionOptions {\n\t/**\n\t * The account that is being asked about. If this is passed in, the provider should\n\t * attempt to return the sessions that are only related to this account.\n\t */\n\taccount?: AuthenticationSessionAccount;\n}\n\n/**\n * Represents an authentication provider.\n */\nexport interface IAuthenticationProvider {\n\t/**\n\t * The unique identifier of the authentication provider.\n\t */\n\treadonly id: string;\n\n\t/**\n\t * The display label of the authentication provider.\n\t */\n\treadonly label: string;\n\n\t/**\n\t * Indicates whether the authentication provider supports multiple accounts.\n\t */\n\treadonly supportsMultipleAccounts: boolean;\n\n\t/**\n\t * An {@link Event} which fires when the array of sessions has changed, or data\n\t * within a session has changed.\n\t */\n\treadonly onDidChangeSessions: Event<AuthenticationSessionsChangeEvent>;\n\n\t/**\n\t * Retrieves a list of authentication sessions.\n\t * @param scopes - An optional list of scopes. If provided, the sessions returned should match these permissions, otherwise all sessions should be returned.\n\t * @param options - Additional options for getting sessions.\n\t * @returns A promise that resolves to an array of authentication sessions.\n\t */\n\tgetSessions(\n\t\tscopes: string[] | undefined,\n\t\toptions: IAuthenticationProviderSessionOptions,\n\t): Promise<readonly AuthenticationSession[]>;\n\n\t/**\n\t * Prompts the user to log in.\n\t * If login is successful, the `onDidChangeSessions` event should be fired.\n\t * If login fails, a rejected promise should be returned.\n\t * If the provider does not support multiple accounts, this method should not be called if there is already an existing session matching the provided scopes.\n\t * @param scopes - A list of scopes that the new session should be created with.\n\t * @param options - Additional options for creating the session.\n\t * @returns A promise that resolves to an authentication session.\n\t */\n\tcreateSession(\n\t\tscopes: string[],\n\t\toptions: IAuthenticationProviderSessionOptions,\n\t): Promise<AuthenticationSession>;\n\n\t/**\n\t * Removes the session corresponding to the specified session ID.\n\t * If the removal is successful, the `onDidChangeSessions` event should be fired.\n\t * If a session cannot be removed, the provider should reject with an error message.\n\t * @param sessionId - The ID of the session to remove.\n\t */\n\tremoveSession(sessionId: string): Promise<void>;\n}\n"],
  "mappings": "AAKA,SAAS,uBAAuB;AAKzB,MAAM,gCAAgC;AAiDtC,MAAM,yBAAyB;AAAA,EACrC;AACD;AA4HO,MAAM,mCACZ;AAAA,EACC;AACD;",
  "names": []
}
