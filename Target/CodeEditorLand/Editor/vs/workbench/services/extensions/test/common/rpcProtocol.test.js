import n from"assert";import{VSBuffer as u}from"../../../../../base/common/buffer.js";import{CancellationToken as m,CancellationTokenSource as g}from"../../../../../base/common/cancellation.js";import{Emitter as w}from"../../../../../base/common/event.js";import{DisposableStore as y}from"../../../../../base/common/lifecycle.js";import"../../../../../base/parts/ipc/common/ipc.js";import{ensureNoDisposablesAreLeakedInTestSuite as E}from"../../../../../base/test/common/utils.js";import{ProxyIdentifier as P,SerializableObjectWithBuffers as c}from"../../common/proxyIdentifier.js";import{RPCProtocol as p}from"../../common/rpcProtocol.js";suite("RPCProtocol",()=>{let o;class b{_pair;_onMessage=new w;onMessage=this._onMessage.event;setPair(e){this._pair=e}send(e){Promise.resolve().then(()=>{this._pair._onMessage.fire(e)})}}let l,s;class d{$m(e,r){return Promise.resolve(l.call(null,e,r))}}setup(()=>{o=new y;const t=new b,e=new b;t.setPair(e),e.setPair(t);const r=o.add(new p(t)),a=o.add(new p(e)),i=new P("bb"),f=new d;a.set(i,f),s=r.getProxy(i)}),teardown(()=>{o.dispose()}),E(),test("simple call",function(t){l=(e,r)=>e+r,s.$m(4,1).then(e=>{n.strictEqual(e,5),t(null)},t)}),test("simple call without result",function(t){l=(e,r)=>{},s.$m(4,1).then(e=>{n.strictEqual(e,void 0),t(null)},t)}),test("passing buffer as argument",function(t){l=(r,a)=>(n.ok(r instanceof u),r.buffer[a]);const e=u.alloc(4);e.buffer[0]=1,e.buffer[1]=2,e.buffer[2]=3,e.buffer[3]=4,s.$m(e,2).then(r=>{n.strictEqual(r,3),t(null)},t)}),test("returning a buffer",function(t){l=(e,r)=>{const a=u.alloc(4);return a.buffer[0]=1,a.buffer[1]=2,a.buffer[2]=3,a.buffer[3]=4,a},s.$m(4,1).then(e=>{n.ok(e instanceof u),n.strictEqual(e.buffer[0],1),n.strictEqual(e.buffer[1],2),n.strictEqual(e.buffer[2],3),n.strictEqual(e.buffer[3],4),t(null)},t)}),test("cancelling a call via CancellationToken before",function(t){l=(r,a)=>r+a,s.$m(4,m.Cancelled).then(r=>{n.fail("should not receive result")},r=>{n.ok(!0),t(null)})}),test("passing CancellationToken.None",function(t){l=(e,r)=>(n.ok(!!r),e+1),s.$m(4,m.None).then(e=>{n.strictEqual(e,5),t(null)},t)}),test("cancelling a call via CancellationToken quickly",function(t){l=(a,i)=>new Promise((f,q)=>{const h=i.onCancellationRequested(v=>{h.dispose(),f(7)})});const e=new g;s.$m(4,e.token).then(a=>{n.strictEqual(a,7)},a=>{n.fail("should not receive error")}).finally(t),e.cancel()}),test("throwing an error",function(t){l=(e,r)=>{throw new Error("nope")},s.$m(4,1).then(e=>{n.fail("unexpected")},e=>{n.strictEqual(e.message,"nope")}).finally(t)}),test("error promise",function(t){l=(e,r)=>Promise.reject(void 0),s.$m(4,1).then(e=>{n.fail("unexpected")},e=>{n.strictEqual(e,void 0)}).finally(t)}),test("issue #60450: Converting circular structure to JSON",function(t){l=(e,r)=>{const a={};return a.self=a,a},s.$m(4,1).then(e=>{n.strictEqual(e,null)},e=>{n.fail("unexpected")}).finally(t)}),test("issue #72798: null errors are hard to digest",function(t){l=(e,r)=>{throw{what:"what"}},s.$m(4,1).then(e=>{n.fail("unexpected")},e=>{n.strictEqual(e.what,"what")}).finally(t)}),test("undefined arguments arrive as null",function(){return l=(t,e)=>(n.strictEqual(typeof t,"undefined"),n.strictEqual(e,null),7),s.$m(void 0,null).then(t=>{n.strictEqual(t,7)})}),test("issue #81424: SerializeRequest should throw if an argument can not be serialized",()=>{const t={};t.loop=t,n.throws(()=>{s.$m(t,"2")})}),test("SerializableObjectWithBuffers is correctly transfered",function(t){l=(r,a)=>new c({string:r.value.string+" world",buff:r.value.buff});const e=u.alloc(4);e.buffer[0]=1,e.buffer[1]=2,e.buffer[2]=3,e.buffer[3]=4,s.$m(new c({string:"hello",buff:e}),void 0).then(r=>{n.ok(r instanceof c),n.strictEqual(r.value.string,"hello world"),n.ok(r.value.buff instanceof u);const a=Array.from(r.value.buff.buffer);n.strictEqual(a[0],1),n.strictEqual(a[1],2),n.strictEqual(a[2],3),n.strictEqual(a[3],4),t(null)},t)})});
