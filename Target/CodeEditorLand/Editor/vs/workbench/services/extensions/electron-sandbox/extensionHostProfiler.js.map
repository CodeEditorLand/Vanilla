{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/extensions/electron-sandbox/extensionHostProfiler.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { TernarySearchTree } from '../../../../base/common/ternarySearchTree.js';\nimport { IExtensionHostProfile, IExtensionService, ProfileSegmentId, ProfileSession } from '../common/extensions.js';\nimport { IExtensionDescription } from '../../../../platform/extensions/common/extensions.js';\nimport { Schemas } from '../../../../base/common/network.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IV8InspectProfilingService, IV8Profile, IV8ProfileNode } from '../../../../platform/profiling/common/profiling.js';\nimport { createSingleCallFunction } from '../../../../base/common/functional.js';\n\nexport class ExtensionHostProfiler {\n\n\tconstructor(\n\t\tprivate readonly _host: string,\n\t\tprivate readonly _port: number,\n\t\t@IExtensionService private readonly _extensionService: IExtensionService,\n\t\t@IV8InspectProfilingService private readonly _profilingService: IV8InspectProfilingService,\n\t) {\n\t}\n\n\tpublic async start(): Promise<ProfileSession> {\n\n\t\tconst id = await this._profilingService.startProfiling({ host: this._host, port: this._port });\n\n\t\treturn {\n\t\t\tstop: createSingleCallFunction(async () => {\n\t\t\t\tconst profile = await this._profilingService.stopProfiling(id);\n\t\t\t\tawait this._extensionService.whenInstalledExtensionsRegistered();\n\t\t\t\tconst extensions = this._extensionService.extensions;\n\t\t\t\treturn this._distill(profile, extensions);\n\t\t\t})\n\t\t};\n\t}\n\n\tprivate _distill(profile: IV8Profile, extensions: readonly IExtensionDescription[]): IExtensionHostProfile {\n\t\tconst searchTree = TernarySearchTree.forUris<IExtensionDescription>();\n\t\tfor (const extension of extensions) {\n\t\t\tif (extension.extensionLocation.scheme === Schemas.file) {\n\t\t\t\tsearchTree.set(URI.file(extension.extensionLocation.fsPath), extension);\n\t\t\t}\n\t\t}\n\n\t\tconst nodes = profile.nodes;\n\t\tconst idsToNodes = new Map<number, IV8ProfileNode>();\n\t\tconst idsToSegmentId = new Map<number, ProfileSegmentId | null>();\n\t\tfor (const node of nodes) {\n\t\t\tidsToNodes.set(node.id, node);\n\t\t}\n\n\t\tfunction visit(node: IV8ProfileNode, segmentId: ProfileSegmentId | null) {\n\t\t\tif (!segmentId) {\n\t\t\t\tswitch (node.callFrame.functionName) {\n\t\t\t\t\tcase '(root)':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '(program)':\n\t\t\t\t\t\tsegmentId = 'program';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '(garbage collector)':\n\t\t\t\t\t\tsegmentId = 'gc';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tsegmentId = 'self';\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (segmentId === 'self' && node.callFrame.url) {\n\t\t\t\tlet extension: IExtensionDescription | undefined;\n\t\t\t\ttry {\n\t\t\t\t\textension = searchTree.findSubstr(URI.parse(node.callFrame.url));\n\t\t\t\t} catch {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t\tif (extension) {\n\t\t\t\t\tsegmentId = extension.identifier.value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tidsToSegmentId.set(node.id, segmentId);\n\n\t\t\tif (node.children) {\n\t\t\t\tfor (const child of node.children) {\n\t\t\t\t\tconst childNode = idsToNodes.get(child);\n\t\t\t\t\tif (childNode) {\n\t\t\t\t\t\tvisit(childNode, segmentId);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvisit(nodes[0], null);\n\n\t\tconst samples = profile.samples || [];\n\t\tconst timeDeltas = profile.timeDeltas || [];\n\t\tconst distilledDeltas: number[] = [];\n\t\tconst distilledIds: ProfileSegmentId[] = [];\n\n\t\tlet currSegmentTime = 0;\n\t\tlet currSegmentId: string | undefined;\n\t\tfor (let i = 0; i < samples.length; i++) {\n\t\t\tconst id = samples[i];\n\t\t\tconst segmentId = idsToSegmentId.get(id);\n\t\t\tif (segmentId !== currSegmentId) {\n\t\t\t\tif (currSegmentId) {\n\t\t\t\t\tdistilledIds.push(currSegmentId);\n\t\t\t\t\tdistilledDeltas.push(currSegmentTime);\n\t\t\t\t}\n\t\t\t\tcurrSegmentId = segmentId ?? undefined;\n\t\t\t\tcurrSegmentTime = 0;\n\t\t\t}\n\t\t\tcurrSegmentTime += timeDeltas[i];\n\t\t}\n\t\tif (currSegmentId) {\n\t\t\tdistilledIds.push(currSegmentId);\n\t\t\tdistilledDeltas.push(currSegmentTime);\n\t\t}\n\n\t\treturn {\n\t\t\tstartTime: profile.startTime,\n\t\t\tendTime: profile.endTime,\n\t\t\tdeltas: distilledDeltas,\n\t\t\tids: distilledIds,\n\t\t\tdata: profile,\n\t\t\tgetAggregatedTimes: () => {\n\t\t\t\tconst segmentsToTime = new Map<ProfileSegmentId, number>();\n\t\t\t\tfor (let i = 0; i < distilledIds.length; i++) {\n\t\t\t\t\tconst id = distilledIds[i];\n\t\t\t\t\tsegmentsToTime.set(id, (segmentsToTime.get(id) || 0) + distilledDeltas[i]);\n\t\t\t\t}\n\t\t\t\treturn segmentsToTime;\n\t\t\t}\n\t\t};\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
