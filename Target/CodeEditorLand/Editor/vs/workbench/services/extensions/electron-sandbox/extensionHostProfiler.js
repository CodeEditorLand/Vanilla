var T=Object.defineProperty;var b=Object.getOwnPropertyDescriptor;var v=(f,i,s,r)=>{for(var n=r>1?void 0:r?b(i,s):i,l=f.length-1,c;l>=0;l--)(c=f[l])&&(n=(r?c(i,s,n):c(n))||n);return r&&n&&T(i,s,n),n},g=(f,i)=>(s,r)=>i(s,r,f);import{createSingleCallFunction as _}from"../../../../../vs/base/common/functional.js";import{Schemas as y}from"../../../../../vs/base/common/network.js";import{TernarySearchTree as w}from"../../../../../vs/base/common/ternarySearchTree.js";import{URI as P}from"../../../../../vs/base/common/uri.js";import"../../../../../vs/platform/extensions/common/extensions.js";import{IV8InspectProfilingService as D}from"../../../../../vs/platform/profiling/common/profiling.js";import{IExtensionService as V}from"../../../../../vs/workbench/services/extensions/common/extensions.js";let u=class{constructor(i,s,r,n){this._host=i;this._port=s;this._extensionService=r;this._profilingService=n}async start(){const i=await this._profilingService.startProfiling({host:this._host,port:this._port});return{stop:_(async()=>{const s=await this._profilingService.stopProfiling(i);await this._extensionService.whenInstalledExtensionsRegistered();const r=this._extensionService.extensions;return this._distill(s,r)})}}_distill(i,s){const r=w.forUris();for(const e of s)e.extensionLocation.scheme===y.file&&r.set(P.file(e.extensionLocation.fsPath),e);const n=i.nodes,l=new Map,c=new Map;for(const e of n)l.set(e.id,e);function h(e,t){if(t){if(t==="self"&&e.callFrame.url){let o;try{o=r.findSubstr(P.parse(e.callFrame.url))}catch{}o&&(t=o.identifier.value)}}else switch(e.callFrame.functionName){case"(root)":break;case"(program)":t="program";break;case"(garbage collector)":t="gc";break;default:t="self";break}if(c.set(e.id,t),e.children)for(const o of e.children){const I=l.get(o);I&&h(I,t)}}h(n[0],null);const S=i.samples||[],x=i.timeDeltas||[],m=[],d=[];let p=0,a;for(let e=0;e<S.length;e++){const t=S[e],o=c.get(t);o!==a&&(a&&(d.push(a),m.push(p)),a=o??void 0,p=0),p+=x[e]}return a&&(d.push(a),m.push(p)),{startTime:i.startTime,endTime:i.endTime,deltas:m,ids:d,data:i,getAggregatedTimes:()=>{const e=new Map;for(let t=0;t<d.length;t++){const o=d[t];e.set(o,(e.get(o)||0)+m[t])}return e}}}};u=v([g(2,V),g(3,D)],u);export{u as ExtensionHostProfiler};
