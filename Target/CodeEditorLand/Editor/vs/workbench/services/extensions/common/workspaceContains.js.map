{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/extensions/common/workspaceContains.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as resources from '../../../../base/common/resources.js';\nimport { URI, UriComponents } from '../../../../base/common/uri.js';\nimport { CancellationTokenSource, CancellationToken } from '../../../../base/common/cancellation.js';\nimport * as errors from '../../../../base/common/errors.js';\nimport { ExtensionIdentifier, IExtensionDescription } from '../../../../platform/extensions/common/extensions.js';\nimport { IInstantiationService, ServicesAccessor } from '../../../../platform/instantiation/common/instantiation.js';\nimport { QueryBuilder } from '../../search/common/queryBuilder.js';\nimport { ISearchService } from '../../search/common/search.js';\nimport { toWorkspaceFolder } from '../../../../platform/workspace/common/workspace.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { promiseWithResolvers } from '../../../../base/common/async.js';\n\nconst WORKSPACE_CONTAINS_TIMEOUT = 7000;\n\nexport interface IExtensionActivationHost {\n\treadonly logService: ILogService;\n\treadonly folders: readonly UriComponents[];\n\treadonly forceUsingSearch: boolean;\n\n\texists(uri: URI): Promise<boolean>;\n\tcheckExists(folders: readonly UriComponents[], includes: string[], token: CancellationToken): Promise<boolean>;\n}\n\nexport interface IExtensionActivationResult {\n\tactivationEvent: string;\n}\n\nexport function checkActivateWorkspaceContainsExtension(host: IExtensionActivationHost, desc: IExtensionDescription): Promise<IExtensionActivationResult | undefined> {\n\tconst activationEvents = desc.activationEvents;\n\tif (!activationEvents) {\n\t\treturn Promise.resolve(undefined);\n\t}\n\n\tconst fileNames: string[] = [];\n\tconst globPatterns: string[] = [];\n\n\tfor (const activationEvent of activationEvents) {\n\t\tif (/^workspaceContains:/.test(activationEvent)) {\n\t\t\tconst fileNameOrGlob = activationEvent.substr('workspaceContains:'.length);\n\t\t\tif (fileNameOrGlob.indexOf('*') >= 0 || fileNameOrGlob.indexOf('?') >= 0 || host.forceUsingSearch) {\n\t\t\t\tglobPatterns.push(fileNameOrGlob);\n\t\t\t} else {\n\t\t\t\tfileNames.push(fileNameOrGlob);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (fileNames.length === 0 && globPatterns.length === 0) {\n\t\treturn Promise.resolve(undefined);\n\t}\n\n\tconst { promise, resolve } = promiseWithResolvers<IExtensionActivationResult | undefined>();\n\tconst activate = (activationEvent: string) => resolve({ activationEvent });\n\n\tconst fileNamePromise = Promise.all(fileNames.map((fileName) => _activateIfFileName(host, fileName, activate))).then(() => { });\n\tconst globPatternPromise = _activateIfGlobPatterns(host, desc.identifier, globPatterns, activate);\n\n\tPromise.all([fileNamePromise, globPatternPromise]).then(() => {\n\t\t// when all are done, resolve with undefined (relevant only if it was not activated so far)\n\t\tresolve(undefined);\n\t});\n\n\treturn promise;\n}\n\nasync function _activateIfFileName(host: IExtensionActivationHost, fileName: string, activate: (activationEvent: string) => void): Promise<void> {\n\t// find exact path\n\tfor (const uri of host.folders) {\n\t\tif (await host.exists(resources.joinPath(URI.revive(uri), fileName))) {\n\t\t\t// the file was found\n\t\t\tactivate(`workspaceContains:${fileName}`);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nasync function _activateIfGlobPatterns(host: IExtensionActivationHost, extensionId: ExtensionIdentifier, globPatterns: string[], activate: (activationEvent: string) => void): Promise<void> {\n\tif (globPatterns.length === 0) {\n\t\treturn Promise.resolve(undefined);\n\t}\n\n\tconst tokenSource = new CancellationTokenSource();\n\tconst searchP = host.checkExists(host.folders, globPatterns, tokenSource.token);\n\n\tconst timer = setTimeout(async () => {\n\t\ttokenSource.cancel();\n\t\thost.logService.info(`Not activating extension '${extensionId.value}': Timed out while searching for 'workspaceContains' pattern ${globPatterns.join(',')}`);\n\t}, WORKSPACE_CONTAINS_TIMEOUT);\n\n\tlet exists: boolean = false;\n\ttry {\n\t\texists = await searchP;\n\t} catch (err) {\n\t\tif (!errors.isCancellationError(err)) {\n\t\t\terrors.onUnexpectedError(err);\n\t\t}\n\t}\n\n\ttokenSource.dispose();\n\tclearTimeout(timer);\n\n\tif (exists) {\n\t\t// a file was found matching one of the glob patterns\n\t\tactivate(`workspaceContains:${globPatterns.join(',')}`);\n\t}\n}\n\nexport function checkGlobFileExists(\n\taccessor: ServicesAccessor,\n\tfolders: readonly UriComponents[],\n\tincludes: string[],\n\ttoken: CancellationToken,\n): Promise<boolean> {\n\tconst instantiationService = accessor.get(IInstantiationService);\n\tconst searchService = accessor.get(ISearchService);\n\tconst queryBuilder = instantiationService.createInstance(QueryBuilder);\n\tconst query = queryBuilder.file(folders.map(folder => toWorkspaceFolder(URI.revive(folder))), {\n\t\t_reason: 'checkExists',\n\t\tincludePattern: includes,\n\t\texists: true\n\t});\n\n\treturn searchService.fileSearch(query, token).then(\n\t\tresult => {\n\t\t\treturn !!result.limitHit;\n\t\t},\n\t\terr => {\n\t\t\tif (!errors.isCancellationError(err)) {\n\t\t\t\treturn Promise.reject(err);\n\t\t\t}\n\n\t\t\treturn false;\n\t\t});\n}\n"],
  "mappings": "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",
  "names": []
}
