{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/extensions/common/extensionDescriptionRegistry.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ExtensionIdentifier, ExtensionIdentifierMap, ExtensionIdentifierSet, IExtensionDescription } from '../../../../platform/extensions/common/extensions.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport * as path from '../../../../base/common/path.js';\nimport { Disposable, IDisposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { promiseWithResolvers } from '../../../../base/common/async.js';\n\nexport class DeltaExtensionsResult {\n\tconstructor(\n\t\tpublic readonly versionId: number,\n\t\tpublic readonly removedDueToLooping: IExtensionDescription[]\n\t) { }\n}\n\nexport interface IReadOnlyExtensionDescriptionRegistry {\n\tcontainsActivationEvent(activationEvent: string): boolean;\n\tcontainsExtension(extensionId: ExtensionIdentifier): boolean;\n\tgetExtensionDescriptionsForActivationEvent(activationEvent: string): IExtensionDescription[];\n\tgetAllExtensionDescriptions(): IExtensionDescription[];\n\tgetExtensionDescription(extensionId: ExtensionIdentifier | string): IExtensionDescription | undefined;\n\tgetExtensionDescriptionByUUID(uuid: string): IExtensionDescription | undefined;\n\tgetExtensionDescriptionByIdOrUUID(extensionId: ExtensionIdentifier | string, uuid: string | undefined): IExtensionDescription | undefined;\n}\n\nexport class ExtensionDescriptionRegistry implements IReadOnlyExtensionDescriptionRegistry {\n\n\tpublic static isHostExtension(extensionId: ExtensionIdentifier | string, myRegistry: ExtensionDescriptionRegistry, globalRegistry: ExtensionDescriptionRegistry): boolean {\n\t\tif (myRegistry.getExtensionDescription(extensionId)) {\n\t\t\t// I have this extension\n\t\t\treturn false;\n\t\t}\n\t\tconst extensionDescription = globalRegistry.getExtensionDescription(extensionId);\n\t\tif (!extensionDescription) {\n\t\t\t// unknown extension\n\t\t\treturn false;\n\t\t}\n\t\tif ((extensionDescription.main || extensionDescription.browser) && extensionDescription.api === 'none') {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate readonly _onDidChange = new Emitter<void>();\n\tpublic readonly onDidChange = this._onDidChange.event;\n\n\tprivate _versionId: number = 0;\n\tprivate _extensionDescriptions: IExtensionDescription[];\n\tprivate _extensionsMap!: ExtensionIdentifierMap<IExtensionDescription>;\n\tprivate _extensionsArr!: IExtensionDescription[];\n\tprivate _activationMap!: Map<string, IExtensionDescription[]>;\n\n\tconstructor(\n\t\tprivate readonly _activationEventsReader: IActivationEventsReader,\n\t\textensionDescriptions: IExtensionDescription[]\n\t) {\n\t\tthis._extensionDescriptions = extensionDescriptions;\n\t\tthis._initialize();\n\t}\n\n\tprivate _initialize(): void {\n\t\t// Ensure extensions are stored in the order: builtin, user, under development\n\t\tthis._extensionDescriptions.sort(extensionCmp);\n\n\t\tthis._extensionsMap = new ExtensionIdentifierMap<IExtensionDescription>();\n\t\tthis._extensionsArr = [];\n\t\tthis._activationMap = new Map<string, IExtensionDescription[]>();\n\n\t\tfor (const extensionDescription of this._extensionDescriptions) {\n\t\t\tif (this._extensionsMap.has(extensionDescription.identifier)) {\n\t\t\t\t// No overwriting allowed!\n\t\t\t\tconsole.error('Extension `' + extensionDescription.identifier.value + '` is already registered');\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis._extensionsMap.set(extensionDescription.identifier, extensionDescription);\n\t\t\tthis._extensionsArr.push(extensionDescription);\n\n\t\t\tconst activationEvents = this._activationEventsReader.readActivationEvents(extensionDescription);\n\t\t\tfor (const activationEvent of activationEvents) {\n\t\t\t\tif (!this._activationMap.has(activationEvent)) {\n\t\t\t\t\tthis._activationMap.set(activationEvent, []);\n\t\t\t\t}\n\t\t\t\tthis._activationMap.get(activationEvent)!.push(extensionDescription);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic set(extensionDescriptions: IExtensionDescription[]): { versionId: number } {\n\t\tthis._extensionDescriptions = extensionDescriptions;\n\t\tthis._initialize();\n\t\tthis._versionId++;\n\t\tthis._onDidChange.fire(undefined);\n\t\treturn {\n\t\t\tversionId: this._versionId\n\t\t};\n\t}\n\n\tpublic deltaExtensions(toAdd: IExtensionDescription[], toRemove: ExtensionIdentifier[]): DeltaExtensionsResult {\n\t\t// It is possible that an extension is removed, only to be added again at a different version\n\t\t// so we will first handle removals\n\t\tthis._extensionDescriptions = removeExtensions(this._extensionDescriptions, toRemove);\n\n\t\t// Then, handle the extensions to add\n\t\tthis._extensionDescriptions = this._extensionDescriptions.concat(toAdd);\n\n\t\t// Immediately remove looping extensions!\n\t\tconst looping = ExtensionDescriptionRegistry._findLoopingExtensions(this._extensionDescriptions);\n\t\tthis._extensionDescriptions = removeExtensions(this._extensionDescriptions, looping.map(ext => ext.identifier));\n\n\t\tthis._initialize();\n\t\tthis._versionId++;\n\t\tthis._onDidChange.fire(undefined);\n\t\treturn new DeltaExtensionsResult(this._versionId, looping);\n\t}\n\n\tprivate static _findLoopingExtensions(extensionDescriptions: IExtensionDescription[]): IExtensionDescription[] {\n\t\tconst G = new class {\n\n\t\t\tprivate _arcs = new Map<string, string[]>();\n\t\t\tprivate _nodesSet = new Set<string>();\n\t\t\tprivate _nodesArr: string[] = [];\n\n\t\t\taddNode(id: string): void {\n\t\t\t\tif (!this._nodesSet.has(id)) {\n\t\t\t\t\tthis._nodesSet.add(id);\n\t\t\t\t\tthis._nodesArr.push(id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\taddArc(from: string, to: string): void {\n\t\t\t\tthis.addNode(from);\n\t\t\t\tthis.addNode(to);\n\t\t\t\tif (this._arcs.has(from)) {\n\t\t\t\t\tthis._arcs.get(from)!.push(to);\n\t\t\t\t} else {\n\t\t\t\t\tthis._arcs.set(from, [to]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgetArcs(id: string): string[] {\n\t\t\t\tif (this._arcs.has(id)) {\n\t\t\t\t\treturn this._arcs.get(id)!;\n\t\t\t\t}\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\thasOnlyGoodArcs(id: string, good: Set<string>): boolean {\n\t\t\t\tconst dependencies = G.getArcs(id);\n\t\t\t\tfor (let i = 0; i < dependencies.length; i++) {\n\t\t\t\t\tif (!good.has(dependencies[i])) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tgetNodes(): string[] {\n\t\t\t\treturn this._nodesArr;\n\t\t\t}\n\t\t};\n\n\t\tconst descs = new ExtensionIdentifierMap<IExtensionDescription>();\n\t\tfor (const extensionDescription of extensionDescriptions) {\n\t\t\tdescs.set(extensionDescription.identifier, extensionDescription);\n\t\t\tif (extensionDescription.extensionDependencies) {\n\t\t\t\tfor (const depId of extensionDescription.extensionDependencies) {\n\t\t\t\t\tG.addArc(ExtensionIdentifier.toKey(extensionDescription.identifier), ExtensionIdentifier.toKey(depId));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// initialize with all extensions with no dependencies.\n\t\tconst good = new Set<string>();\n\t\tG.getNodes().filter(id => G.getArcs(id).length === 0).forEach(id => good.add(id));\n\n\t\t// all other extensions will be processed below.\n\t\tconst nodes = G.getNodes().filter(id => !good.has(id));\n\n\t\tlet madeProgress: boolean;\n\t\tdo {\n\t\t\tmadeProgress = false;\n\n\t\t\t// find one extension which has only good deps\n\t\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\t\tconst id = nodes[i];\n\n\t\t\t\tif (G.hasOnlyGoodArcs(id, good)) {\n\t\t\t\t\tnodes.splice(i, 1);\n\t\t\t\t\ti--;\n\t\t\t\t\tgood.add(id);\n\t\t\t\t\tmadeProgress = true;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (madeProgress);\n\n\t\t// The remaining nodes are bad and have loops\n\t\treturn nodes.map(id => descs.get(id)!);\n\t}\n\n\tpublic containsActivationEvent(activationEvent: string): boolean {\n\t\treturn this._activationMap.has(activationEvent);\n\t}\n\n\tpublic containsExtension(extensionId: ExtensionIdentifier): boolean {\n\t\treturn this._extensionsMap.has(extensionId);\n\t}\n\n\tpublic getExtensionDescriptionsForActivationEvent(activationEvent: string): IExtensionDescription[] {\n\t\tconst extensions = this._activationMap.get(activationEvent);\n\t\treturn extensions ? extensions.slice(0) : [];\n\t}\n\n\tpublic getAllExtensionDescriptions(): IExtensionDescription[] {\n\t\treturn this._extensionsArr.slice(0);\n\t}\n\n\tpublic getSnapshot(): ExtensionDescriptionRegistrySnapshot {\n\t\treturn new ExtensionDescriptionRegistrySnapshot(\n\t\t\tthis._versionId,\n\t\t\tthis.getAllExtensionDescriptions()\n\t\t);\n\t}\n\n\tpublic getExtensionDescription(extensionId: ExtensionIdentifier | string): IExtensionDescription | undefined {\n\t\tconst extension = this._extensionsMap.get(extensionId);\n\t\treturn extension ? extension : undefined;\n\t}\n\n\tpublic getExtensionDescriptionByUUID(uuid: string): IExtensionDescription | undefined {\n\t\tfor (const extensionDescription of this._extensionsArr) {\n\t\t\tif (extensionDescription.uuid === uuid) {\n\t\t\t\treturn extensionDescription;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tpublic getExtensionDescriptionByIdOrUUID(extensionId: ExtensionIdentifier | string, uuid: string | undefined): IExtensionDescription | undefined {\n\t\treturn (\n\t\t\tthis.getExtensionDescription(extensionId)\n\t\t\t?? (uuid ? this.getExtensionDescriptionByUUID(uuid) : undefined)\n\t\t);\n\t}\n}\n\nexport class ExtensionDescriptionRegistrySnapshot {\n\tconstructor(\n\t\tpublic readonly versionId: number,\n\t\tpublic readonly extensions: readonly IExtensionDescription[]\n\t) { }\n}\n\nexport interface IActivationEventsReader {\n\treadActivationEvents(extensionDescription: IExtensionDescription): string[];\n}\n\nexport class LockableExtensionDescriptionRegistry implements IReadOnlyExtensionDescriptionRegistry {\n\n\tprivate readonly _actual: ExtensionDescriptionRegistry;\n\tprivate readonly _lock = new Lock();\n\n\tconstructor(activationEventsReader: IActivationEventsReader) {\n\t\tthis._actual = new ExtensionDescriptionRegistry(activationEventsReader, []);\n\t}\n\n\tpublic async acquireLock(customerName: string): Promise<ExtensionDescriptionRegistryLock> {\n\t\tconst lock = await this._lock.acquire(customerName);\n\t\treturn new ExtensionDescriptionRegistryLock(this, lock);\n\t}\n\n\tpublic deltaExtensions(acquiredLock: ExtensionDescriptionRegistryLock, toAdd: IExtensionDescription[], toRemove: ExtensionIdentifier[]): DeltaExtensionsResult {\n\t\tif (!acquiredLock.isAcquiredFor(this)) {\n\t\t\tthrow new Error('Lock is not held');\n\t\t}\n\t\treturn this._actual.deltaExtensions(toAdd, toRemove);\n\t}\n\n\tpublic containsActivationEvent(activationEvent: string): boolean {\n\t\treturn this._actual.containsActivationEvent(activationEvent);\n\t}\n\tpublic containsExtension(extensionId: ExtensionIdentifier): boolean {\n\t\treturn this._actual.containsExtension(extensionId);\n\t}\n\tpublic getExtensionDescriptionsForActivationEvent(activationEvent: string): IExtensionDescription[] {\n\t\treturn this._actual.getExtensionDescriptionsForActivationEvent(activationEvent);\n\t}\n\tpublic getAllExtensionDescriptions(): IExtensionDescription[] {\n\t\treturn this._actual.getAllExtensionDescriptions();\n\t}\n\tpublic getSnapshot(): ExtensionDescriptionRegistrySnapshot {\n\t\treturn this._actual.getSnapshot();\n\t}\n\tpublic getExtensionDescription(extensionId: ExtensionIdentifier | string): IExtensionDescription | undefined {\n\t\treturn this._actual.getExtensionDescription(extensionId);\n\t}\n\tpublic getExtensionDescriptionByUUID(uuid: string): IExtensionDescription | undefined {\n\t\treturn this._actual.getExtensionDescriptionByUUID(uuid);\n\t}\n\tpublic getExtensionDescriptionByIdOrUUID(extensionId: ExtensionIdentifier | string, uuid: string | undefined): IExtensionDescription | undefined {\n\t\treturn this._actual.getExtensionDescriptionByIdOrUUID(extensionId, uuid);\n\t}\n}\n\nexport class ExtensionDescriptionRegistryLock extends Disposable {\n\n\tprivate _isDisposed = false;\n\n\tconstructor(\n\t\tprivate readonly _registry: LockableExtensionDescriptionRegistry,\n\t\tlock: IDisposable\n\t) {\n\t\tsuper();\n\t\tthis._register(lock);\n\t}\n\n\tpublic isAcquiredFor(registry: LockableExtensionDescriptionRegistry): boolean {\n\t\treturn !this._isDisposed && this._registry === registry;\n\t}\n}\n\nclass LockCustomer {\n\tpublic readonly promise: Promise<IDisposable>;\n\tprivate readonly _resolve: (value: IDisposable) => void;\n\n\tconstructor(\n\t\tpublic readonly name: string\n\t) {\n\t\tconst withResolvers = promiseWithResolvers<IDisposable>();\n\t\tthis.promise = withResolvers.promise;\n\t\tthis._resolve = withResolvers.resolve;\n\t}\n\n\tresolve(value: IDisposable): void {\n\t\tthis._resolve(value);\n\t}\n}\n\nclass Lock {\n\tprivate readonly _pendingCustomers: LockCustomer[] = [];\n\tprivate _isLocked = false;\n\n\tpublic async acquire(customerName: string): Promise<IDisposable> {\n\t\tconst customer = new LockCustomer(customerName);\n\t\tthis._pendingCustomers.push(customer);\n\t\tthis._advance();\n\t\treturn customer.promise;\n\t}\n\n\tprivate _advance(): void {\n\t\tif (this._isLocked) {\n\t\t\t// cannot advance yet\n\t\t\treturn;\n\t\t}\n\t\tif (this._pendingCustomers.length === 0) {\n\t\t\t// no more waiting customers\n\t\t\treturn;\n\t\t}\n\n\t\tconst customer = this._pendingCustomers.shift()!;\n\n\t\tthis._isLocked = true;\n\t\tlet customerHoldsLock = true;\n\n\t\tconst logLongRunningCustomerTimeout = setTimeout(() => {\n\t\t\tif (customerHoldsLock) {\n\t\t\t\tconsole.warn(`The customer named ${customer.name} has been holding on to the lock for 30s. This might be a problem.`);\n\t\t\t}\n\t\t}, 30 * 1000 /* 30 seconds */);\n\n\t\tconst releaseLock = () => {\n\t\t\tif (!customerHoldsLock) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tclearTimeout(logLongRunningCustomerTimeout);\n\t\t\tcustomerHoldsLock = false;\n\t\t\tthis._isLocked = false;\n\t\t\tthis._advance();\n\t\t};\n\n\t\tcustomer.resolve(toDisposable(releaseLock));\n\t}\n}\n\nconst enum SortBucket {\n\tBuiltin = 0,\n\tUser = 1,\n\tDev = 2\n}\n\n/**\n * Ensure that:\n * - first are builtin extensions\n * - second are user extensions\n * - third are extensions under development\n *\n * In each bucket, extensions must be sorted alphabetically by their folder name.\n */\nfunction extensionCmp(a: IExtensionDescription, b: IExtensionDescription): number {\n\tconst aSortBucket = (a.isBuiltin ? SortBucket.Builtin : a.isUnderDevelopment ? SortBucket.Dev : SortBucket.User);\n\tconst bSortBucket = (b.isBuiltin ? SortBucket.Builtin : b.isUnderDevelopment ? SortBucket.Dev : SortBucket.User);\n\tif (aSortBucket !== bSortBucket) {\n\t\treturn aSortBucket - bSortBucket;\n\t}\n\tconst aLastSegment = path.posix.basename(a.extensionLocation.path);\n\tconst bLastSegment = path.posix.basename(b.extensionLocation.path);\n\tif (aLastSegment < bLastSegment) {\n\t\treturn -1;\n\t}\n\tif (aLastSegment > bLastSegment) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nfunction removeExtensions(arr: IExtensionDescription[], toRemove: ExtensionIdentifier[]): IExtensionDescription[] {\n\tconst toRemoveSet = new ExtensionIdentifierSet(toRemove);\n\treturn arr.filter(extension => !toRemoveSet.has(extension.identifier));\n}\n"],
  "mappings": "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",
  "names": ["good", "SortBucket"]
}
