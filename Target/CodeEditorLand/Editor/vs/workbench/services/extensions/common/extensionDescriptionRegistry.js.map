{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/extensions/common/extensionDescriptionRegistry.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { promiseWithResolvers } from \"../../../../base/common/async.js\";\nimport { Emitter } from \"../../../../base/common/event.js\";\nimport {\n\tDisposable,\n\ttype IDisposable,\n\ttoDisposable,\n} from \"../../../../base/common/lifecycle.js\";\nimport * as path from \"../../../../base/common/path.js\";\nimport {\n\tExtensionIdentifier,\n\tExtensionIdentifierMap,\n\tExtensionIdentifierSet,\n\ttype IExtensionDescription,\n} from \"../../../../platform/extensions/common/extensions.js\";\n\nexport class DeltaExtensionsResult {\n\tconstructor(\n\t\tpublic readonly versionId: number,\n\t\tpublic readonly removedDueToLooping: IExtensionDescription[],\n\t) {}\n}\n\nexport interface IReadOnlyExtensionDescriptionRegistry {\n\tcontainsActivationEvent(activationEvent: string): boolean;\n\tcontainsExtension(extensionId: ExtensionIdentifier): boolean;\n\tgetExtensionDescriptionsForActivationEvent(\n\t\tactivationEvent: string,\n\t): IExtensionDescription[];\n\tgetAllExtensionDescriptions(): IExtensionDescription[];\n\tgetExtensionDescription(\n\t\textensionId: ExtensionIdentifier | string,\n\t): IExtensionDescription | undefined;\n\tgetExtensionDescriptionByUUID(\n\t\tuuid: string,\n\t): IExtensionDescription | undefined;\n\tgetExtensionDescriptionByIdOrUUID(\n\t\textensionId: ExtensionIdentifier | string,\n\t\tuuid: string | undefined,\n\t): IExtensionDescription | undefined;\n}\n\nexport class ExtensionDescriptionRegistry\n\timplements IReadOnlyExtensionDescriptionRegistry\n{\n\tpublic static isHostExtension(\n\t\textensionId: ExtensionIdentifier | string,\n\t\tmyRegistry: ExtensionDescriptionRegistry,\n\t\tglobalRegistry: ExtensionDescriptionRegistry,\n\t): boolean {\n\t\tif (myRegistry.getExtensionDescription(extensionId)) {\n\t\t\t// I have this extension\n\t\t\treturn false;\n\t\t}\n\t\tconst extensionDescription =\n\t\t\tglobalRegistry.getExtensionDescription(extensionId);\n\t\tif (!extensionDescription) {\n\t\t\t// unknown extension\n\t\t\treturn false;\n\t\t}\n\t\tif (\n\t\t\t(extensionDescription.main || extensionDescription.browser) &&\n\t\t\textensionDescription.api === \"none\"\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate readonly _onDidChange = new Emitter<void>();\n\tpublic readonly onDidChange = this._onDidChange.event;\n\n\tprivate _versionId = 0;\n\tprivate _extensionDescriptions: IExtensionDescription[];\n\tprivate _extensionsMap!: ExtensionIdentifierMap<IExtensionDescription>;\n\tprivate _extensionsArr!: IExtensionDescription[];\n\tprivate _activationMap!: Map<string, IExtensionDescription[]>;\n\n\tconstructor(\n\t\tprivate readonly _activationEventsReader: IActivationEventsReader,\n\t\textensionDescriptions: IExtensionDescription[],\n\t) {\n\t\tthis._extensionDescriptions = extensionDescriptions;\n\t\tthis._initialize();\n\t}\n\n\tprivate _initialize(): void {\n\t\t// Ensure extensions are stored in the order: builtin, user, under development\n\t\tthis._extensionDescriptions.sort(extensionCmp);\n\n\t\tthis._extensionsMap =\n\t\t\tnew ExtensionIdentifierMap<IExtensionDescription>();\n\t\tthis._extensionsArr = [];\n\t\tthis._activationMap = new Map<string, IExtensionDescription[]>();\n\n\t\tfor (const extensionDescription of this._extensionDescriptions) {\n\t\t\tif (this._extensionsMap.has(extensionDescription.identifier)) {\n\t\t\t\t// No overwriting allowed!\n\t\t\t\tconsole.error(\n\t\t\t\t\t\"Extension `\" +\n\t\t\t\t\t\textensionDescription.identifier.value +\n\t\t\t\t\t\t\"` is already registered\",\n\t\t\t\t);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis._extensionsMap.set(\n\t\t\t\textensionDescription.identifier,\n\t\t\t\textensionDescription,\n\t\t\t);\n\t\t\tthis._extensionsArr.push(extensionDescription);\n\n\t\t\tconst activationEvents =\n\t\t\t\tthis._activationEventsReader.readActivationEvents(\n\t\t\t\t\textensionDescription,\n\t\t\t\t);\n\t\t\tfor (const activationEvent of activationEvents) {\n\t\t\t\tif (!this._activationMap.has(activationEvent)) {\n\t\t\t\t\tthis._activationMap.set(activationEvent, []);\n\t\t\t\t}\n\t\t\t\tthis._activationMap\n\t\t\t\t\t.get(activationEvent)!\n\t\t\t\t\t.push(extensionDescription);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic set(extensionDescriptions: IExtensionDescription[]): {\n\t\tversionId: number;\n\t} {\n\t\tthis._extensionDescriptions = extensionDescriptions;\n\t\tthis._initialize();\n\t\tthis._versionId++;\n\t\tthis._onDidChange.fire(undefined);\n\t\treturn {\n\t\t\tversionId: this._versionId,\n\t\t};\n\t}\n\n\tpublic deltaExtensions(\n\t\ttoAdd: IExtensionDescription[],\n\t\ttoRemove: ExtensionIdentifier[],\n\t): DeltaExtensionsResult {\n\t\t// It is possible that an extension is removed, only to be added again at a different version\n\t\t// so we will first handle removals\n\t\tthis._extensionDescriptions = removeExtensions(\n\t\t\tthis._extensionDescriptions,\n\t\t\ttoRemove,\n\t\t);\n\n\t\t// Then, handle the extensions to add\n\t\tthis._extensionDescriptions = this._extensionDescriptions.concat(toAdd);\n\n\t\t// Immediately remove looping extensions!\n\t\tconst looping = ExtensionDescriptionRegistry._findLoopingExtensions(\n\t\t\tthis._extensionDescriptions,\n\t\t);\n\t\tthis._extensionDescriptions = removeExtensions(\n\t\t\tthis._extensionDescriptions,\n\t\t\tlooping.map((ext) => ext.identifier),\n\t\t);\n\n\t\tthis._initialize();\n\t\tthis._versionId++;\n\t\tthis._onDidChange.fire(undefined);\n\t\treturn new DeltaExtensionsResult(this._versionId, looping);\n\t}\n\n\tprivate static _findLoopingExtensions(\n\t\textensionDescriptions: IExtensionDescription[],\n\t): IExtensionDescription[] {\n\t\tconst G = new (class {\n\t\t\tprivate _arcs = new Map<string, string[]>();\n\t\t\tprivate _nodesSet = new Set<string>();\n\t\t\tprivate _nodesArr: string[] = [];\n\n\t\t\taddNode(id: string): void {\n\t\t\t\tif (!this._nodesSet.has(id)) {\n\t\t\t\t\tthis._nodesSet.add(id);\n\t\t\t\t\tthis._nodesArr.push(id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\taddArc(from: string, to: string): void {\n\t\t\t\tthis.addNode(from);\n\t\t\t\tthis.addNode(to);\n\t\t\t\tif (this._arcs.has(from)) {\n\t\t\t\t\tthis._arcs.get(from)!.push(to);\n\t\t\t\t} else {\n\t\t\t\t\tthis._arcs.set(from, [to]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgetArcs(id: string): string[] {\n\t\t\t\tif (this._arcs.has(id)) {\n\t\t\t\t\treturn this._arcs.get(id)!;\n\t\t\t\t}\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\thasOnlyGoodArcs(id: string, good: Set<string>): boolean {\n\t\t\t\tconst dependencies = G.getArcs(id);\n\t\t\t\tfor (let i = 0; i < dependencies.length; i++) {\n\t\t\t\t\tif (!good.has(dependencies[i])) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tgetNodes(): string[] {\n\t\t\t\treturn this._nodesArr;\n\t\t\t}\n\t\t})();\n\n\t\tconst descs = new ExtensionIdentifierMap<IExtensionDescription>();\n\t\tfor (const extensionDescription of extensionDescriptions) {\n\t\t\tdescs.set(extensionDescription.identifier, extensionDescription);\n\t\t\tif (extensionDescription.extensionDependencies) {\n\t\t\t\tfor (const depId of extensionDescription.extensionDependencies) {\n\t\t\t\t\tG.addArc(\n\t\t\t\t\t\tExtensionIdentifier.toKey(\n\t\t\t\t\t\t\textensionDescription.identifier,\n\t\t\t\t\t\t),\n\t\t\t\t\t\tExtensionIdentifier.toKey(depId),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// initialize with all extensions with no dependencies.\n\t\tconst good = new Set<string>();\n\t\tG.getNodes()\n\t\t\t.filter((id) => G.getArcs(id).length === 0)\n\t\t\t.forEach((id) => good.add(id));\n\n\t\t// all other extensions will be processed below.\n\t\tconst nodes = G.getNodes().filter((id) => !good.has(id));\n\n\t\tlet madeProgress: boolean;\n\t\tdo {\n\t\t\tmadeProgress = false;\n\n\t\t\t// find one extension which has only good deps\n\t\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\t\tconst id = nodes[i];\n\n\t\t\t\tif (G.hasOnlyGoodArcs(id, good)) {\n\t\t\t\t\tnodes.splice(i, 1);\n\t\t\t\t\ti--;\n\t\t\t\t\tgood.add(id);\n\t\t\t\t\tmadeProgress = true;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (madeProgress);\n\n\t\t// The remaining nodes are bad and have loops\n\t\treturn nodes.map((id) => descs.get(id)!);\n\t}\n\n\tpublic containsActivationEvent(activationEvent: string): boolean {\n\t\treturn this._activationMap.has(activationEvent);\n\t}\n\n\tpublic containsExtension(extensionId: ExtensionIdentifier): boolean {\n\t\treturn this._extensionsMap.has(extensionId);\n\t}\n\n\tpublic getExtensionDescriptionsForActivationEvent(\n\t\tactivationEvent: string,\n\t): IExtensionDescription[] {\n\t\tconst extensions = this._activationMap.get(activationEvent);\n\t\treturn extensions ? extensions.slice(0) : [];\n\t}\n\n\tpublic getAllExtensionDescriptions(): IExtensionDescription[] {\n\t\treturn this._extensionsArr.slice(0);\n\t}\n\n\tpublic getSnapshot(): ExtensionDescriptionRegistrySnapshot {\n\t\treturn new ExtensionDescriptionRegistrySnapshot(\n\t\t\tthis._versionId,\n\t\t\tthis.getAllExtensionDescriptions(),\n\t\t);\n\t}\n\n\tpublic getExtensionDescription(\n\t\textensionId: ExtensionIdentifier | string,\n\t): IExtensionDescription | undefined {\n\t\tconst extension = this._extensionsMap.get(extensionId);\n\t\treturn extension ? extension : undefined;\n\t}\n\n\tpublic getExtensionDescriptionByUUID(\n\t\tuuid: string,\n\t): IExtensionDescription | undefined {\n\t\tfor (const extensionDescription of this._extensionsArr) {\n\t\t\tif (extensionDescription.uuid === uuid) {\n\t\t\t\treturn extensionDescription;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tpublic getExtensionDescriptionByIdOrUUID(\n\t\textensionId: ExtensionIdentifier | string,\n\t\tuuid: string | undefined,\n\t): IExtensionDescription | undefined {\n\t\treturn (\n\t\t\tthis.getExtensionDescription(extensionId) ??\n\t\t\t(uuid ? this.getExtensionDescriptionByUUID(uuid) : undefined)\n\t\t);\n\t}\n}\n\nexport class ExtensionDescriptionRegistrySnapshot {\n\tconstructor(\n\t\tpublic readonly versionId: number,\n\t\tpublic readonly extensions: readonly IExtensionDescription[],\n\t) {}\n}\n\nexport interface IActivationEventsReader {\n\treadActivationEvents(extensionDescription: IExtensionDescription): string[];\n}\n\nexport class LockableExtensionDescriptionRegistry\n\timplements IReadOnlyExtensionDescriptionRegistry\n{\n\tprivate readonly _actual: ExtensionDescriptionRegistry;\n\tprivate readonly _lock = new Lock();\n\n\tconstructor(activationEventsReader: IActivationEventsReader) {\n\t\tthis._actual = new ExtensionDescriptionRegistry(\n\t\t\tactivationEventsReader,\n\t\t\t[],\n\t\t);\n\t}\n\n\tpublic async acquireLock(\n\t\tcustomerName: string,\n\t): Promise<ExtensionDescriptionRegistryLock> {\n\t\tconst lock = await this._lock.acquire(customerName);\n\t\treturn new ExtensionDescriptionRegistryLock(this, lock);\n\t}\n\n\tpublic deltaExtensions(\n\t\tacquiredLock: ExtensionDescriptionRegistryLock,\n\t\ttoAdd: IExtensionDescription[],\n\t\ttoRemove: ExtensionIdentifier[],\n\t): DeltaExtensionsResult {\n\t\tif (!acquiredLock.isAcquiredFor(this)) {\n\t\t\tthrow new Error(\"Lock is not held\");\n\t\t}\n\t\treturn this._actual.deltaExtensions(toAdd, toRemove);\n\t}\n\n\tpublic containsActivationEvent(activationEvent: string): boolean {\n\t\treturn this._actual.containsActivationEvent(activationEvent);\n\t}\n\tpublic containsExtension(extensionId: ExtensionIdentifier): boolean {\n\t\treturn this._actual.containsExtension(extensionId);\n\t}\n\tpublic getExtensionDescriptionsForActivationEvent(\n\t\tactivationEvent: string,\n\t): IExtensionDescription[] {\n\t\treturn this._actual.getExtensionDescriptionsForActivationEvent(\n\t\t\tactivationEvent,\n\t\t);\n\t}\n\tpublic getAllExtensionDescriptions(): IExtensionDescription[] {\n\t\treturn this._actual.getAllExtensionDescriptions();\n\t}\n\tpublic getSnapshot(): ExtensionDescriptionRegistrySnapshot {\n\t\treturn this._actual.getSnapshot();\n\t}\n\tpublic getExtensionDescription(\n\t\textensionId: ExtensionIdentifier | string,\n\t): IExtensionDescription | undefined {\n\t\treturn this._actual.getExtensionDescription(extensionId);\n\t}\n\tpublic getExtensionDescriptionByUUID(\n\t\tuuid: string,\n\t): IExtensionDescription | undefined {\n\t\treturn this._actual.getExtensionDescriptionByUUID(uuid);\n\t}\n\tpublic getExtensionDescriptionByIdOrUUID(\n\t\textensionId: ExtensionIdentifier | string,\n\t\tuuid: string | undefined,\n\t): IExtensionDescription | undefined {\n\t\treturn this._actual.getExtensionDescriptionByIdOrUUID(\n\t\t\textensionId,\n\t\t\tuuid,\n\t\t);\n\t}\n}\n\nexport class ExtensionDescriptionRegistryLock extends Disposable {\n\tprivate _isDisposed = false;\n\n\tconstructor(\n\t\tprivate readonly _registry: LockableExtensionDescriptionRegistry,\n\t\tlock: IDisposable,\n\t) {\n\t\tsuper();\n\t\tthis._register(lock);\n\t}\n\n\tpublic isAcquiredFor(\n\t\tregistry: LockableExtensionDescriptionRegistry,\n\t): boolean {\n\t\treturn !this._isDisposed && this._registry === registry;\n\t}\n}\n\nclass LockCustomer {\n\tpublic readonly promise: Promise<IDisposable>;\n\tprivate readonly _resolve: (value: IDisposable) => void;\n\n\tconstructor(public readonly name: string) {\n\t\tconst withResolvers = promiseWithResolvers<IDisposable>();\n\t\tthis.promise = withResolvers.promise;\n\t\tthis._resolve = withResolvers.resolve;\n\t}\n\n\tresolve(value: IDisposable): void {\n\t\tthis._resolve(value);\n\t}\n}\n\nclass Lock {\n\tprivate readonly _pendingCustomers: LockCustomer[] = [];\n\tprivate _isLocked = false;\n\n\tpublic async acquire(customerName: string): Promise<IDisposable> {\n\t\tconst customer = new LockCustomer(customerName);\n\t\tthis._pendingCustomers.push(customer);\n\t\tthis._advance();\n\t\treturn customer.promise;\n\t}\n\n\tprivate _advance(): void {\n\t\tif (this._isLocked) {\n\t\t\t// cannot advance yet\n\t\t\treturn;\n\t\t}\n\t\tif (this._pendingCustomers.length === 0) {\n\t\t\t// no more waiting customers\n\t\t\treturn;\n\t\t}\n\n\t\tconst customer = this._pendingCustomers.shift()!;\n\n\t\tthis._isLocked = true;\n\t\tlet customerHoldsLock = true;\n\n\t\tconst logLongRunningCustomerTimeout = setTimeout(() => {\n\t\t\tif (customerHoldsLock) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`The customer named ${customer.name} has been holding on to the lock for 30s. This might be a problem.`,\n\t\t\t\t);\n\t\t\t}\n\t\t}, 30 * 1000 /* 30 seconds */);\n\n\t\tconst releaseLock = () => {\n\t\t\tif (!customerHoldsLock) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tclearTimeout(logLongRunningCustomerTimeout);\n\t\t\tcustomerHoldsLock = false;\n\t\t\tthis._isLocked = false;\n\t\t\tthis._advance();\n\t\t};\n\n\t\tcustomer.resolve(toDisposable(releaseLock));\n\t}\n}\n\nenum SortBucket {\n\tBuiltin = 0,\n\tUser = 1,\n\tDev = 2,\n}\n\n/**\n * Ensure that:\n * - first are builtin extensions\n * - second are user extensions\n * - third are extensions under development\n *\n * In each bucket, extensions must be sorted alphabetically by their folder name.\n */\nfunction extensionCmp(\n\ta: IExtensionDescription,\n\tb: IExtensionDescription,\n): number {\n\tconst aSortBucket = a.isBuiltin\n\t\t? SortBucket.Builtin\n\t\t: a.isUnderDevelopment\n\t\t\t? SortBucket.Dev\n\t\t\t: SortBucket.User;\n\tconst bSortBucket = b.isBuiltin\n\t\t? SortBucket.Builtin\n\t\t: b.isUnderDevelopment\n\t\t\t? SortBucket.Dev\n\t\t\t: SortBucket.User;\n\tif (aSortBucket !== bSortBucket) {\n\t\treturn aSortBucket - bSortBucket;\n\t}\n\tconst aLastSegment = path.posix.basename(a.extensionLocation.path);\n\tconst bLastSegment = path.posix.basename(b.extensionLocation.path);\n\tif (aLastSegment < bLastSegment) {\n\t\treturn -1;\n\t}\n\tif (aLastSegment > bLastSegment) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nfunction removeExtensions(\n\tarr: IExtensionDescription[],\n\ttoRemove: ExtensionIdentifier[],\n): IExtensionDescription[] {\n\tconst toRemoveSet = new ExtensionIdentifierSet(toRemove);\n\treturn arr.filter((extension) => !toRemoveSet.has(extension.identifier));\n}\n"],
  "mappings": ";;AAKA,SAAS,4BAA4B;AACrC,SAAS,eAAe;AACxB;AAAA,EACC;AAAA,EAEA;AAAA,OACM;AACP,YAAY,UAAU;AACtB;AAAA,EACC;AAAA,EACA;AAAA,EACA;AAAA,OAEM;AAEA,MAAM,sBAAsB;AAAA,EAClC,YACiB,WACA,qBACf;AAFe;AACA;AAAA,EACd;AAAA,EAxBJ,OAoBmC;AAAA;AAAA;AAKnC;AAqBO,MAAM,6BAEb;AAAA,EAkCC,YACkB,yBACjB,uBACC;AAFgB;AAGjB,SAAK,yBAAyB;AAC9B,SAAK,YAAY;AAAA,EAClB;AAAA,EAxFD,OAgDA;AAAA;AAAA;AAAA,EACC,OAAc,gBACb,aACA,YACA,gBACU;AACV,QAAI,WAAW,wBAAwB,WAAW,GAAG;AAEpD,aAAO;AAAA,IACR;AACA,UAAM,uBACL,eAAe,wBAAwB,WAAW;AACnD,QAAI,CAAC,sBAAsB;AAE1B,aAAO;AAAA,IACR;AACA,SACE,qBAAqB,QAAQ,qBAAqB,YACnD,qBAAqB,QAAQ,QAC5B;AACD,aAAO;AAAA,IACR;AACA,WAAO;AAAA,EACR;AAAA,EAEiB,eAAe,IAAI,QAAc;AAAA,EAClC,cAAc,KAAK,aAAa;AAAA,EAExC,aAAa;AAAA,EACb;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAUA,cAAoB;AAE3B,SAAK,uBAAuB,KAAK,YAAY;AAE7C,SAAK,iBACJ,IAAI,uBAA8C;AACnD,SAAK,iBAAiB,CAAC;AACvB,SAAK,iBAAiB,oBAAI,IAAqC;AAE/D,eAAW,wBAAwB,KAAK,wBAAwB;AAC/D,UAAI,KAAK,eAAe,IAAI,qBAAqB,UAAU,GAAG;AAE7D,gBAAQ;AAAA,UACP,gBACC,qBAAqB,WAAW,QAChC;AAAA,QACF;AACA;AAAA,MACD;AAEA,WAAK,eAAe;AAAA,QACnB,qBAAqB;AAAA,QACrB;AAAA,MACD;AACA,WAAK,eAAe,KAAK,oBAAoB;AAE7C,YAAM,mBACL,KAAK,wBAAwB;AAAA,QAC5B;AAAA,MACD;AACD,iBAAW,mBAAmB,kBAAkB;AAC/C,YAAI,CAAC,KAAK,eAAe,IAAI,eAAe,GAAG;AAC9C,eAAK,eAAe,IAAI,iBAAiB,CAAC,CAAC;AAAA,QAC5C;AACA,aAAK,eACH,IAAI,eAAe,EACnB,KAAK,oBAAoB;AAAA,MAC5B;AAAA,IACD;AAAA,EACD;AAAA,EAEO,IAAI,uBAET;AACD,SAAK,yBAAyB;AAC9B,SAAK,YAAY;AACjB,SAAK;AACL,SAAK,aAAa,KAAK,MAAS;AAChC,WAAO;AAAA,MACN,WAAW,KAAK;AAAA,IACjB;AAAA,EACD;AAAA,EAEO,gBACN,OACA,UACwB;AAGxB,SAAK,yBAAyB;AAAA,MAC7B,KAAK;AAAA,MACL;AAAA,IACD;AAGA,SAAK,yBAAyB,KAAK,uBAAuB,OAAO,KAAK;AAGtE,UAAM,UAAU,6BAA6B;AAAA,MAC5C,KAAK;AAAA,IACN;AACA,SAAK,yBAAyB;AAAA,MAC7B,KAAK;AAAA,MACL,QAAQ,IAAI,CAAC,QAAQ,IAAI,UAAU;AAAA,IACpC;AAEA,SAAK,YAAY;AACjB,SAAK;AACL,SAAK,aAAa,KAAK,MAAS;AAChC,WAAO,IAAI,sBAAsB,KAAK,YAAY,OAAO;AAAA,EAC1D;AAAA,EAEA,OAAe,uBACd,uBAC0B;AAC1B,UAAM,IAAI,IAAK,MAAM;AAAA,MACZ,QAAQ,oBAAI,IAAsB;AAAA,MAClC,YAAY,oBAAI,IAAY;AAAA,MAC5B,YAAsB,CAAC;AAAA,MAE/B,QAAQ,IAAkB;AACzB,YAAI,CAAC,KAAK,UAAU,IAAI,EAAE,GAAG;AAC5B,eAAK,UAAU,IAAI,EAAE;AACrB,eAAK,UAAU,KAAK,EAAE;AAAA,QACvB;AAAA,MACD;AAAA,MAEA,OAAO,MAAc,IAAkB;AACtC,aAAK,QAAQ,IAAI;AACjB,aAAK,QAAQ,EAAE;AACf,YAAI,KAAK,MAAM,IAAI,IAAI,GAAG;AACzB,eAAK,MAAM,IAAI,IAAI,EAAG,KAAK,EAAE;AAAA,QAC9B,OAAO;AACN,eAAK,MAAM,IAAI,MAAM,CAAC,EAAE,CAAC;AAAA,QAC1B;AAAA,MACD;AAAA,MAEA,QAAQ,IAAsB;AAC7B,YAAI,KAAK,MAAM,IAAI,EAAE,GAAG;AACvB,iBAAO,KAAK,MAAM,IAAI,EAAE;AAAA,QACzB;AACA,eAAO,CAAC;AAAA,MACT;AAAA,MAEA,gBAAgB,IAAYA,OAA4B;AACvD,cAAM,eAAe,EAAE,QAAQ,EAAE;AACjC,iBAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC7C,cAAI,CAACA,MAAK,IAAI,aAAa,CAAC,CAAC,GAAG;AAC/B,mBAAO;AAAA,UACR;AAAA,QACD;AACA,eAAO;AAAA,MACR;AAAA,MAEA,WAAqB;AACpB,eAAO,KAAK;AAAA,MACb;AAAA,IACD,EAAG;AAEH,UAAM,QAAQ,IAAI,uBAA8C;AAChE,eAAW,wBAAwB,uBAAuB;AACzD,YAAM,IAAI,qBAAqB,YAAY,oBAAoB;AAC/D,UAAI,qBAAqB,uBAAuB;AAC/C,mBAAW,SAAS,qBAAqB,uBAAuB;AAC/D,YAAE;AAAA,YACD,oBAAoB;AAAA,cACnB,qBAAqB;AAAA,YACtB;AAAA,YACA,oBAAoB,MAAM,KAAK;AAAA,UAChC;AAAA,QACD;AAAA,MACD;AAAA,IACD;AAGA,UAAM,OAAO,oBAAI,IAAY;AAC7B,MAAE,SAAS,EACT,OAAO,CAAC,OAAO,EAAE,QAAQ,EAAE,EAAE,WAAW,CAAC,EACzC,QAAQ,CAAC,OAAO,KAAK,IAAI,EAAE,CAAC;AAG9B,UAAM,QAAQ,EAAE,SAAS,EAAE,OAAO,CAAC,OAAO,CAAC,KAAK,IAAI,EAAE,CAAC;AAEvD,QAAI;AACJ,OAAG;AACF,qBAAe;AAGf,eAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACtC,cAAM,KAAK,MAAM,CAAC;AAElB,YAAI,EAAE,gBAAgB,IAAI,IAAI,GAAG;AAChC,gBAAM,OAAO,GAAG,CAAC;AACjB;AACA,eAAK,IAAI,EAAE;AACX,yBAAe;AAAA,QAChB;AAAA,MACD;AAAA,IACD,SAAS;AAGT,WAAO,MAAM,IAAI,CAAC,OAAO,MAAM,IAAI,EAAE,CAAE;AAAA,EACxC;AAAA,EAEO,wBAAwB,iBAAkC;AAChE,WAAO,KAAK,eAAe,IAAI,eAAe;AAAA,EAC/C;AAAA,EAEO,kBAAkB,aAA2C;AACnE,WAAO,KAAK,eAAe,IAAI,WAAW;AAAA,EAC3C;AAAA,EAEO,2CACN,iBAC0B;AAC1B,UAAM,aAAa,KAAK,eAAe,IAAI,eAAe;AAC1D,WAAO,aAAa,WAAW,MAAM,CAAC,IAAI,CAAC;AAAA,EAC5C;AAAA,EAEO,8BAAuD;AAC7D,WAAO,KAAK,eAAe,MAAM,CAAC;AAAA,EACnC;AAAA,EAEO,cAAoD;AAC1D,WAAO,IAAI;AAAA,MACV,KAAK;AAAA,MACL,KAAK,4BAA4B;AAAA,IAClC;AAAA,EACD;AAAA,EAEO,wBACN,aACoC;AACpC,UAAM,YAAY,KAAK,eAAe,IAAI,WAAW;AACrD,WAAO,YAAY,YAAY;AAAA,EAChC;AAAA,EAEO,8BACN,MACoC;AACpC,eAAW,wBAAwB,KAAK,gBAAgB;AACvD,UAAI,qBAAqB,SAAS,MAAM;AACvC,eAAO;AAAA,MACR;AAAA,IACD;AACA,WAAO;AAAA,EACR;AAAA,EAEO,kCACN,aACA,MACoC;AACpC,WACC,KAAK,wBAAwB,WAAW,MACvC,OAAO,KAAK,8BAA8B,IAAI,IAAI;AAAA,EAErD;AACD;AAEO,MAAM,qCAAqC;AAAA,EACjD,YACiB,WACA,YACf;AAFe;AACA;AAAA,EACd;AAAA,EAnUJ,OA+TkD;AAAA;AAAA;AAKlD;AAMO,MAAM,qCAEb;AAAA,EA5UA,OA4UA;AAAA;AAAA;AAAA,EACkB;AAAA,EACA,QAAQ,IAAI,KAAK;AAAA,EAElC,YAAY,wBAAiD;AAC5D,SAAK,UAAU,IAAI;AAAA,MAClB;AAAA,MACA,CAAC;AAAA,IACF;AAAA,EACD;AAAA,EAEA,MAAa,YACZ,cAC4C;AAC5C,UAAM,OAAO,MAAM,KAAK,MAAM,QAAQ,YAAY;AAClD,WAAO,IAAI,iCAAiC,MAAM,IAAI;AAAA,EACvD;AAAA,EAEO,gBACN,cACA,OACA,UACwB;AACxB,QAAI,CAAC,aAAa,cAAc,IAAI,GAAG;AACtC,YAAM,IAAI,MAAM,kBAAkB;AAAA,IACnC;AACA,WAAO,KAAK,QAAQ,gBAAgB,OAAO,QAAQ;AAAA,EACpD;AAAA,EAEO,wBAAwB,iBAAkC;AAChE,WAAO,KAAK,QAAQ,wBAAwB,eAAe;AAAA,EAC5D;AAAA,EACO,kBAAkB,aAA2C;AACnE,WAAO,KAAK,QAAQ,kBAAkB,WAAW;AAAA,EAClD;AAAA,EACO,2CACN,iBAC0B;AAC1B,WAAO,KAAK,QAAQ;AAAA,MACnB;AAAA,IACD;AAAA,EACD;AAAA,EACO,8BAAuD;AAC7D,WAAO,KAAK,QAAQ,4BAA4B;AAAA,EACjD;AAAA,EACO,cAAoD;AAC1D,WAAO,KAAK,QAAQ,YAAY;AAAA,EACjC;AAAA,EACO,wBACN,aACoC;AACpC,WAAO,KAAK,QAAQ,wBAAwB,WAAW;AAAA,EACxD;AAAA,EACO,8BACN,MACoC;AACpC,WAAO,KAAK,QAAQ,8BAA8B,IAAI;AAAA,EACvD;AAAA,EACO,kCACN,aACA,MACoC;AACpC,WAAO,KAAK,QAAQ;AAAA,MACnB;AAAA,MACA;AAAA,IACD;AAAA,EACD;AACD;AAEO,MAAM,yCAAyC,WAAW;AAAA,EAGhE,YACkB,WACjB,MACC;AACD,UAAM;AAHW;AAIjB,SAAK,UAAU,IAAI;AAAA,EACpB;AAAA,EA1ZD,OAiZiE;AAAA;AAAA;AAAA,EACxD,cAAc;AAAA,EAUf,cACN,UACU;AACV,WAAO,CAAC,KAAK,eAAe,KAAK,cAAc;AAAA,EAChD;AACD;AAEA,MAAM,aAAa;AAAA,EAIlB,YAA4B,MAAc;AAAd;AAC3B,UAAM,gBAAgB,qBAAkC;AACxD,SAAK,UAAU,cAAc;AAC7B,SAAK,WAAW,cAAc;AAAA,EAC/B;AAAA,EA3aD,OAmamB;AAAA;AAAA;AAAA,EACF;AAAA,EACC;AAAA,EAQjB,QAAQ,OAA0B;AACjC,SAAK,SAAS,KAAK;AAAA,EACpB;AACD;AAEA,MAAM,KAAK;AAAA,EAlbX,OAkbW;AAAA;AAAA;AAAA,EACO,oBAAoC,CAAC;AAAA,EAC9C,YAAY;AAAA,EAEpB,MAAa,QAAQ,cAA4C;AAChE,UAAM,WAAW,IAAI,aAAa,YAAY;AAC9C,SAAK,kBAAkB,KAAK,QAAQ;AACpC,SAAK,SAAS;AACd,WAAO,SAAS;AAAA,EACjB;AAAA,EAEQ,WAAiB;AACxB,QAAI,KAAK,WAAW;AAEnB;AAAA,IACD;AACA,QAAI,KAAK,kBAAkB,WAAW,GAAG;AAExC;AAAA,IACD;AAEA,UAAM,WAAW,KAAK,kBAAkB,MAAM;AAE9C,SAAK,YAAY;AACjB,QAAI,oBAAoB;AAExB,UAAM,gCAAgC;AAAA,MAAW,MAAM;AACtD,YAAI,mBAAmB;AACtB,kBAAQ;AAAA,YACP,sBAAsB,SAAS,IAAI;AAAA,UACpC;AAAA,QACD;AAAA,MACD;AAAA,MAAG,KAAK;AAAA;AAAA,IAAqB;AAE7B,UAAM,cAAc,6BAAM;AACzB,UAAI,CAAC,mBAAmB;AACvB;AAAA,MACD;AACA,mBAAa,6BAA6B;AAC1C,0BAAoB;AACpB,WAAK,YAAY;AACjB,WAAK,SAAS;AAAA,IACf,GARoB;AAUpB,aAAS,QAAQ,aAAa,WAAW,CAAC;AAAA,EAC3C;AACD;AAEA,IAAK,aAAL,kBAAKC,gBAAL;AACC,EAAAA,wBAAA,aAAU,KAAV;AACA,EAAAA,wBAAA,UAAO,KAAP;AACA,EAAAA,wBAAA,SAAM,KAAN;AAHI,SAAAA;AAAA,GAAA;AAcL,SAAS,aACR,GACA,GACS;AACT,QAAM,cAAc,EAAE,YACnB,kBACA,EAAE,qBACD,cACA;AACJ,QAAM,cAAc,EAAE,YACnB,kBACA,EAAE,qBACD,cACA;AACJ,MAAI,gBAAgB,aAAa;AAChC,WAAO,cAAc;AAAA,EACtB;AACA,QAAM,eAAe,KAAK,MAAM,SAAS,EAAE,kBAAkB,IAAI;AACjE,QAAM,eAAe,KAAK,MAAM,SAAS,EAAE,kBAAkB,IAAI;AACjE,MAAI,eAAe,cAAc;AAChC,WAAO;AAAA,EACR;AACA,MAAI,eAAe,cAAc;AAChC,WAAO;AAAA,EACR;AACA,SAAO;AACR;AA1BS;AA4BT,SAAS,iBACR,KACA,UAC0B;AAC1B,QAAM,cAAc,IAAI,uBAAuB,QAAQ;AACvD,SAAO,IAAI,OAAO,CAAC,cAAc,CAAC,YAAY,IAAI,UAAU,UAAU,CAAC;AACxE;AANS;",
  "names": ["good", "SortBucket"]
}
