{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/extensions/common/extensions.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../../../base/common/event.js';\nimport Severity from '../../../../base/common/severity.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IMessagePassingProtocol } from '../../../../base/parts/ipc/common/ipc.js';\nimport { getExtensionId, getGalleryExtensionId } from '../../../../platform/extensionManagement/common/extensionManagementUtil.js';\nimport { ImplicitActivationEvents } from '../../../../platform/extensionManagement/common/implicitActivationEvents.js';\nimport { ExtensionIdentifier, ExtensionIdentifierMap, ExtensionIdentifierSet, ExtensionType, IExtension, IExtensionContributions, IExtensionDescription, TargetPlatform } from '../../../../platform/extensions/common/extensions.js';\nimport { ApiProposalName } from '../../../../platform/extensions/common/extensionsApiProposals.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IV8Profile } from '../../../../platform/profiling/common/profiling.js';\nimport { ExtensionHostKind } from './extensionHostKind.js';\nimport { IExtensionDescriptionDelta, IExtensionDescriptionSnapshot } from './extensionHostProtocol.js';\nimport { ExtensionRunningLocation } from './extensionRunningLocation.js';\nimport { IExtensionPoint } from './extensionsRegistry.js';\n\nexport const nullExtensionDescription = Object.freeze<IExtensionDescription>({\n\tidentifier: new ExtensionIdentifier('nullExtensionDescription'),\n\tname: 'Null Extension Description',\n\tversion: '0.0.0',\n\tpublisher: 'vscode',\n\tengines: { vscode: '' },\n\textensionLocation: URI.parse('void:location'),\n\tisBuiltin: false,\n\ttargetPlatform: TargetPlatform.UNDEFINED,\n\tisUserBuiltin: false,\n\tisUnderDevelopment: false\n});\n\nexport type WebWorkerExtHostConfigValue = boolean | 'auto';\nexport const webWorkerExtHostConfig = 'extensions.webWorker';\n\nexport const IExtensionService = createDecorator<IExtensionService>('extensionService');\n\nexport interface IMessage {\n\ttype: Severity;\n\tmessage: string;\n\textensionId: ExtensionIdentifier;\n\textensionPointId: string;\n}\n\nexport interface IExtensionsStatus {\n\tid: ExtensionIdentifier;\n\tmessages: IMessage[];\n\tactivationStarted: boolean;\n\tactivationTimes: ActivationTimes | undefined;\n\truntimeErrors: Error[];\n\trunningLocation: ExtensionRunningLocation | null;\n}\n\nexport class MissingExtensionDependency {\n\tconstructor(readonly dependency: string) { }\n}\n\n/**\n * e.g.\n * ```\n * {\n *    startTime: 1511954813493000,\n *    endTime: 1511954835590000,\n *    deltas: [ 100, 1500, 123456, 1500, 100000 ],\n *    ids: [ 'idle', 'self', 'extension1', 'self', 'idle' ]\n * }\n * ```\n */\nexport interface IExtensionHostProfile {\n\t/**\n\t * Profiling start timestamp in microseconds.\n\t */\n\tstartTime: number;\n\t/**\n\t * Profiling end timestamp in microseconds.\n\t */\n\tendTime: number;\n\t/**\n\t * Duration of segment in microseconds.\n\t */\n\tdeltas: number[];\n\t/**\n\t * Segment identifier: extension id or one of the four known strings.\n\t */\n\tids: ProfileSegmentId[];\n\n\t/**\n\t * Get the information as a .cpuprofile.\n\t */\n\tdata: IV8Profile;\n\n\t/**\n\t * Get the aggregated time per segmentId\n\t */\n\tgetAggregatedTimes(): Map<ProfileSegmentId, number>;\n}\n\nexport const enum ExtensionHostStartup {\n\t/**\n\t * The extension host should be launched immediately and doesn't require a `$startExtensionHost` call.\n\t */\n\tEagerAutoStart = 1,\n\t/**\n\t * The extension host should be launched immediately and needs a `$startExtensionHost` call.\n\t */\n\tEagerManualStart = 2,\n\t/**\n\t * The extension host should be launched lazily and only when it has extensions it needs to host. It needs a `$startExtensionHost` call.\n\t */\n\tLazy = 3,\n}\n\nexport interface IExtensionHost {\n\treadonly pid: number | null;\n\treadonly runningLocation: ExtensionRunningLocation;\n\treadonly remoteAuthority: string | null;\n\treadonly startup: ExtensionHostStartup;\n\t/**\n\t * A collection of extensions which includes information about which\n\t * extension will execute or is executing on this extension host.\n\t * **NOTE**: this will reflect extensions correctly only after `start()` resolves.\n\t */\n\treadonly extensions: ExtensionHostExtensions | null;\n\treadonly onExit: Event<[number, string | null]>;\n\n\tstart(): Promise<IMessagePassingProtocol>;\n\tgetInspectPort(): { port: number; host: string } | undefined;\n\tenableInspectPort(): Promise<boolean>;\n\tdisconnect?(): Promise<void>;\n\tdispose(): void;\n}\n\nexport class ExtensionHostExtensions {\n\tprivate _versionId: number;\n\tprivate _allExtensions: IExtensionDescription[];\n\tprivate _myExtensions: ExtensionIdentifier[];\n\tprivate _myActivationEvents: Set<string> | null;\n\n\tpublic get versionId(): number {\n\t\treturn this._versionId;\n\t}\n\n\tpublic get allExtensions(): IExtensionDescription[] {\n\t\treturn this._allExtensions;\n\t}\n\n\tpublic get myExtensions(): ExtensionIdentifier[] {\n\t\treturn this._myExtensions;\n\t}\n\n\tconstructor(versionId: number, allExtensions: readonly IExtensionDescription[], myExtensions: ExtensionIdentifier[]) {\n\t\tthis._versionId = versionId;\n\t\tthis._allExtensions = allExtensions.slice(0);\n\t\tthis._myExtensions = myExtensions.slice(0);\n\t\tthis._myActivationEvents = null;\n\t}\n\n\ttoSnapshot(): IExtensionDescriptionSnapshot {\n\t\treturn {\n\t\t\tversionId: this._versionId,\n\t\t\tallExtensions: this._allExtensions,\n\t\t\tmyExtensions: this._myExtensions,\n\t\t\tactivationEvents: ImplicitActivationEvents.createActivationEventsMap(this._allExtensions)\n\t\t};\n\t}\n\n\tpublic set(versionId: number, allExtensions: IExtensionDescription[], myExtensions: ExtensionIdentifier[]): IExtensionDescriptionDelta {\n\t\tif (this._versionId > versionId) {\n\t\t\tthrow new Error(`ExtensionHostExtensions: invalid versionId ${versionId} (current: ${this._versionId})`);\n\t\t}\n\t\tconst toRemove: ExtensionIdentifier[] = [];\n\t\tconst toAdd: IExtensionDescription[] = [];\n\t\tconst myToRemove: ExtensionIdentifier[] = [];\n\t\tconst myToAdd: ExtensionIdentifier[] = [];\n\n\t\tconst oldExtensionsMap = extensionDescriptionArrayToMap(this._allExtensions);\n\t\tconst newExtensionsMap = extensionDescriptionArrayToMap(allExtensions);\n\t\tconst extensionsAreTheSame = (a: IExtensionDescription, b: IExtensionDescription) => {\n\t\t\treturn (\n\t\t\t\t(a.extensionLocation.toString() === b.extensionLocation.toString())\n\t\t\t\t|| (a.isBuiltin === b.isBuiltin)\n\t\t\t\t|| (a.isUserBuiltin === b.isUserBuiltin)\n\t\t\t\t|| (a.isUnderDevelopment === b.isUnderDevelopment)\n\t\t\t);\n\t\t};\n\n\t\tfor (const oldExtension of this._allExtensions) {\n\t\t\tconst newExtension = newExtensionsMap.get(oldExtension.identifier);\n\t\t\tif (!newExtension) {\n\t\t\t\ttoRemove.push(oldExtension.identifier);\n\t\t\t\toldExtensionsMap.delete(oldExtension.identifier);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!extensionsAreTheSame(oldExtension, newExtension)) {\n\t\t\t\t// The new extension is different than the old one\n\t\t\t\t// (e.g. maybe it executes in a different location)\n\t\t\t\ttoRemove.push(oldExtension.identifier);\n\t\t\t\toldExtensionsMap.delete(oldExtension.identifier);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tfor (const newExtension of allExtensions) {\n\t\t\tconst oldExtension = oldExtensionsMap.get(newExtension.identifier);\n\t\t\tif (!oldExtension) {\n\t\t\t\ttoAdd.push(newExtension);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!extensionsAreTheSame(oldExtension, newExtension)) {\n\t\t\t\t// The new extension is different than the old one\n\t\t\t\t// (e.g. maybe it executes in a different location)\n\t\t\t\ttoRemove.push(oldExtension.identifier);\n\t\t\t\toldExtensionsMap.delete(oldExtension.identifier);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tconst myOldExtensionsSet = new ExtensionIdentifierSet(this._myExtensions);\n\t\tconst myNewExtensionsSet = new ExtensionIdentifierSet(myExtensions);\n\t\tfor (const oldExtensionId of this._myExtensions) {\n\t\t\tif (!myNewExtensionsSet.has(oldExtensionId)) {\n\t\t\t\tmyToRemove.push(oldExtensionId);\n\t\t\t}\n\t\t}\n\t\tfor (const newExtensionId of myExtensions) {\n\t\t\tif (!myOldExtensionsSet.has(newExtensionId)) {\n\t\t\t\tmyToAdd.push(newExtensionId);\n\t\t\t}\n\t\t}\n\n\t\tconst addActivationEvents = ImplicitActivationEvents.createActivationEventsMap(toAdd);\n\t\tconst delta = { versionId, toRemove, toAdd, addActivationEvents, myToRemove, myToAdd };\n\t\tthis.delta(delta);\n\t\treturn delta;\n\t}\n\n\tpublic delta(extensionsDelta: IExtensionDescriptionDelta): IExtensionDescriptionDelta | null {\n\t\tif (this._versionId >= extensionsDelta.versionId) {\n\t\t\t// ignore older deltas\n\t\t\treturn null;\n\t\t}\n\n\t\tconst { toRemove, toAdd, myToRemove, myToAdd } = extensionsDelta;\n\t\t// First handle removals\n\t\tconst toRemoveSet = new ExtensionIdentifierSet(toRemove);\n\t\tconst myToRemoveSet = new ExtensionIdentifierSet(myToRemove);\n\t\tfor (let i = 0; i < this._allExtensions.length; i++) {\n\t\t\tif (toRemoveSet.has(this._allExtensions[i].identifier)) {\n\t\t\t\tthis._allExtensions.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0; i < this._myExtensions.length; i++) {\n\t\t\tif (myToRemoveSet.has(this._myExtensions[i])) {\n\t\t\t\tthis._myExtensions.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\t// Then handle additions\n\t\tfor (const extension of toAdd) {\n\t\t\tthis._allExtensions.push(extension);\n\t\t}\n\t\tfor (const extensionId of myToAdd) {\n\t\t\tthis._myExtensions.push(extensionId);\n\t\t}\n\n\t\t// clear cached activation events\n\t\tthis._myActivationEvents = null;\n\n\t\treturn extensionsDelta;\n\t}\n\n\tpublic containsExtension(extensionId: ExtensionIdentifier): boolean {\n\t\tfor (const myExtensionId of this._myExtensions) {\n\t\t\tif (ExtensionIdentifier.equals(myExtensionId, extensionId)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic containsActivationEvent(activationEvent: string): boolean {\n\t\tif (!this._myActivationEvents) {\n\t\t\tthis._myActivationEvents = this._readMyActivationEvents();\n\t\t}\n\t\treturn this._myActivationEvents.has(activationEvent);\n\t}\n\n\tprivate _readMyActivationEvents(): Set<string> {\n\t\tconst result = new Set<string>();\n\n\t\tfor (const extensionDescription of this._allExtensions) {\n\t\t\tif (!this.containsExtension(extensionDescription.identifier)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst activationEvents = ImplicitActivationEvents.readActivationEvents(extensionDescription);\n\t\t\tfor (const activationEvent of activationEvents) {\n\t\t\t\tresult.add(activationEvent);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n}\n\nfunction extensionDescriptionArrayToMap(extensions: IExtensionDescription[]): ExtensionIdentifierMap<IExtensionDescription> {\n\tconst result = new ExtensionIdentifierMap<IExtensionDescription>();\n\tfor (const extension of extensions) {\n\t\tresult.set(extension.identifier, extension);\n\t}\n\treturn result;\n}\n\nexport function isProposedApiEnabled(extension: IExtensionDescription, proposal: ApiProposalName): boolean {\n\tif (!extension.enabledApiProposals) {\n\t\treturn false;\n\t}\n\treturn extension.enabledApiProposals.includes(proposal);\n}\n\nexport function checkProposedApiEnabled(extension: IExtensionDescription, proposal: ApiProposalName): void {\n\tif (!isProposedApiEnabled(extension, proposal)) {\n\t\tthrow new Error(`Extension '${extension.identifier.value}' CANNOT use API proposal: ${proposal}.\\nIts package.json#enabledApiProposals-property declares: ${extension.enabledApiProposals?.join(', ') ?? '[]'} but NOT ${proposal}.\\n The missing proposal MUST be added and you must start in extension development mode or use the following command line switch: --enable-proposed-api ${extension.identifier.value}`);\n\t}\n}\n\n\n/**\n * Extension id or one of the four known program states.\n */\nexport type ProfileSegmentId = string | 'idle' | 'program' | 'gc' | 'self';\n\nexport interface ExtensionActivationReason {\n\treadonly startup: boolean;\n\treadonly extensionId: ExtensionIdentifier;\n\treadonly activationEvent: string;\n}\n\nexport class ActivationTimes {\n\tconstructor(\n\t\tpublic readonly codeLoadingTime: number,\n\t\tpublic readonly activateCallTime: number,\n\t\tpublic readonly activateResolvedTime: number,\n\t\tpublic readonly activationReason: ExtensionActivationReason\n\t) {\n\t}\n}\n\nexport class ExtensionPointContribution<T> {\n\treadonly description: IExtensionDescription;\n\treadonly value: T;\n\n\tconstructor(description: IExtensionDescription, value: T) {\n\t\tthis.description = description;\n\t\tthis.value = value;\n\t}\n}\n\nexport interface IWillActivateEvent {\n\treadonly event: string;\n\treadonly activation: Promise<void>;\n}\n\nexport interface IResponsiveStateChangeEvent {\n\textensionHostKind: ExtensionHostKind;\n\tisResponsive: boolean;\n\t/**\n\t * Return the inspect port or `0`. `0` means inspection is not possible.\n\t */\n\tgetInspectListener(tryEnableInspector: boolean): Promise<{ port: number; host: string } | undefined>;\n}\n\nexport const enum ActivationKind {\n\tNormal = 0,\n\tImmediate = 1\n}\n\nexport interface WillStopExtensionHostsEvent {\n\n\t/**\n\t * A human readable reason for stopping the extension hosts\n\t * that e.g. can be shown in a confirmation dialog to the\n\t * user.\n\t */\n\treadonly reason: string;\n\n\t/**\n\t * A flag to indicate if the operation was triggered automatically\n\t */\n\treadonly auto: boolean;\n\n\t/**\n\t * Allows to veto the stopping of extension hosts. The veto can be a long running\n\t * operation.\n\t *\n\t * @param reason a human readable reason for vetoing the extension host stop in case\n\t * where the resolved `value: true`.\n\t */\n\tveto(value: boolean | Promise<boolean>, reason: string): void;\n}\n\nexport interface IExtensionService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * An event emitted when extensions are registered after their extension points got handled.\n\t *\n\t * This event will also fire on startup to signal the installed extensions.\n\t *\n\t * @returns the extensions that got registered\n\t */\n\tonDidRegisterExtensions: Event<void>;\n\n\t/**\n\t * @event\n\t * Fired when extensions status changes.\n\t * The event contains the ids of the extensions that have changed.\n\t */\n\tonDidChangeExtensionsStatus: Event<ExtensionIdentifier[]>;\n\n\t/**\n\t * Fired when the available extensions change (i.e. when extensions are added or removed).\n\t */\n\tonDidChangeExtensions: Event<{ readonly added: readonly IExtensionDescription[]; readonly removed: readonly IExtensionDescription[] }>;\n\n\t/**\n\t * All registered extensions.\n\t * - List will be empty initially during workbench startup and will be filled with extensions as they are registered\n\t * - Listen to `onDidChangeExtensions` event for any changes to the extensions list. It will change as extensions get registered or de-reigstered.\n\t * - Listen to `onDidRegisterExtensions` event or wait for `whenInstalledExtensionsRegistered` promise to get the initial list of registered extensions.\n\t */\n\treadonly extensions: readonly IExtensionDescription[];\n\n\t/**\n\t * An event that is fired when activation happens.\n\t */\n\tonWillActivateByEvent: Event<IWillActivateEvent>;\n\n\t/**\n\t * An event that is fired when an extension host changes its\n\t * responsive-state.\n\t */\n\tonDidChangeResponsiveChange: Event<IResponsiveStateChangeEvent>;\n\n\t/**\n\t * Fired before stop of extension hosts happens. Allows listeners to veto against the\n\t * stop to prevent it from happening.\n\t */\n\tonWillStop: Event<WillStopExtensionHostsEvent>;\n\n\t/**\n\t * Send an activation event and activate interested extensions.\n\t *\n\t * This will wait for the normal startup of the extension host(s).\n\t *\n\t * In extraordinary circumstances, if the activation event needs to activate\n\t * one or more extensions before the normal startup is finished, then you can use\n\t * `ActivationKind.Immediate`. Please do not use this flag unless really necessary\n\t * and you understand all consequences.\n\t */\n\tactivateByEvent(activationEvent: string, activationKind?: ActivationKind): Promise<void>;\n\n\t/**\n\t * Send an activation ID and activate interested extensions.\n\t *\n\t */\n\tactivateById(extensionId: ExtensionIdentifier, reason: ExtensionActivationReason): Promise<void>;\n\n\t/**\n\t * Determine if `activateByEvent(activationEvent)` has resolved already.\n\t *\n\t * i.e. the activation event is finished and all interested extensions are already active.\n\t */\n\tactivationEventIsDone(activationEvent: string): boolean;\n\n\t/**\n\t * An promise that resolves when the installed extensions are registered after\n\t * their extension points got handled.\n\t */\n\twhenInstalledExtensionsRegistered(): Promise<boolean>;\n\n\t/**\n\t * Return a specific extension\n\t * @param id An extension id\n\t */\n\tgetExtension(id: string): Promise<IExtensionDescription | undefined>;\n\n\t/**\n\t * Returns `true` if the given extension can be added. Otherwise `false`.\n\t * @param extension An extension\n\t */\n\tcanAddExtension(extension: IExtensionDescription): boolean;\n\n\t/**\n\t * Returns `true` if the given extension can be removed. Otherwise `false`.\n\t * @param extension An extension\n\t */\n\tcanRemoveExtension(extension: IExtensionDescription): boolean;\n\n\t/**\n\t * Read all contributions to an extension point.\n\t */\n\treadExtensionPointContributions<T extends IExtensionContributions[keyof IExtensionContributions]>(extPoint: IExtensionPoint<T>): Promise<ExtensionPointContribution<T>[]>;\n\n\t/**\n\t * Get information about extensions status.\n\t */\n\tgetExtensionsStatus(): { [id: string]: IExtensionsStatus };\n\n\t/**\n\t * Return the inspect ports (if inspection is possible) for extension hosts of kind `extensionHostKind`.\n\t */\n\tgetInspectPorts(extensionHostKind: ExtensionHostKind, tryEnableInspector: boolean): Promise<{ port: number; host: string }[]>;\n\n\t/**\n\t * Stops the extension hosts.\n\t *\n\t * @param reason a human readable reason for stopping the extension hosts. This maybe\n\t * can be presented to the user when showing dialogs.\n\t *\n\t * @param auto indicates if the operation was triggered by an automatic action\n\t *\n\t * @returns a promise that resolves to `true` if the extension hosts were stopped, `false`\n\t * if the operation was vetoed by listeners of the `onWillStop` event.\n\t */\n\tstopExtensionHosts(reason: string, auto?: boolean): Promise<boolean>;\n\n\t/**\n\t * Starts the extension hosts. If updates are provided, the extension hosts are started with the given updates.\n\t */\n\tstartExtensionHosts(updates?: { readonly toAdd: readonly IExtension[]; readonly toRemove: readonly string[] }): Promise<void>;\n\n\t/**\n\t * Modify the environment of the remote extension host\n\t * @param env New properties for the remote extension host\n\t */\n\tsetRemoteEnvironment(env: { [key: string]: string | null }): Promise<void>;\n}\n\nexport interface IInternalExtensionService {\n\t_activateById(extensionId: ExtensionIdentifier, reason: ExtensionActivationReason): Promise<void>;\n\t_onWillActivateExtension(extensionId: ExtensionIdentifier): void;\n\t_onDidActivateExtension(extensionId: ExtensionIdentifier, codeLoadingTime: number, activateCallTime: number, activateResolvedTime: number, activationReason: ExtensionActivationReason): void;\n\t_onDidActivateExtensionError(extensionId: ExtensionIdentifier, error: Error): void;\n\t_onExtensionRuntimeError(extensionId: ExtensionIdentifier, err: Error): void;\n}\n\nexport interface ProfileSession {\n\tstop(): Promise<IExtensionHostProfile>;\n}\n\nexport function toExtension(extensionDescription: IExtensionDescription): IExtension {\n\treturn {\n\t\ttype: extensionDescription.isBuiltin ? ExtensionType.System : ExtensionType.User,\n\t\tisBuiltin: extensionDescription.isBuiltin || extensionDescription.isUserBuiltin,\n\t\tidentifier: { id: getGalleryExtensionId(extensionDescription.publisher, extensionDescription.name), uuid: extensionDescription.uuid },\n\t\tmanifest: extensionDescription,\n\t\tlocation: extensionDescription.extensionLocation,\n\t\ttargetPlatform: extensionDescription.targetPlatform,\n\t\tvalidations: [],\n\t\tisValid: true\n\t};\n}\n\nexport function toExtensionDescription(extension: IExtension, isUnderDevelopment?: boolean): IExtensionDescription {\n\tconst id = getExtensionId(extension.manifest.publisher, extension.manifest.name);\n\treturn {\n\t\tid,\n\t\tidentifier: new ExtensionIdentifier(id),\n\t\tisBuiltin: extension.type === ExtensionType.System,\n\t\tisUserBuiltin: extension.type === ExtensionType.User && extension.isBuiltin,\n\t\tisUnderDevelopment: !!isUnderDevelopment,\n\t\textensionLocation: extension.location,\n\t\tuuid: extension.identifier.uuid,\n\t\ttargetPlatform: extension.targetPlatform,\n\t\tpublisherDisplayName: extension.publisherDisplayName,\n\t\t...extension.manifest\n\t};\n}\n\n\nexport class NullExtensionService implements IExtensionService {\n\tdeclare readonly _serviceBrand: undefined;\n\tonDidRegisterExtensions: Event<void> = Event.None;\n\tonDidChangeExtensionsStatus: Event<ExtensionIdentifier[]> = Event.None;\n\tonDidChangeExtensions = Event.None;\n\tonWillActivateByEvent: Event<IWillActivateEvent> = Event.None;\n\tonDidChangeResponsiveChange: Event<IResponsiveStateChangeEvent> = Event.None;\n\tonWillStop: Event<WillStopExtensionHostsEvent> = Event.None;\n\treadonly extensions = [];\n\tactivateByEvent(_activationEvent: string): Promise<void> { return Promise.resolve(undefined); }\n\tactivateById(extensionId: ExtensionIdentifier, reason: ExtensionActivationReason): Promise<void> { return Promise.resolve(undefined); }\n\tactivationEventIsDone(_activationEvent: string): boolean { return false; }\n\twhenInstalledExtensionsRegistered(): Promise<boolean> { return Promise.resolve(true); }\n\tgetExtension() { return Promise.resolve(undefined); }\n\treadExtensionPointContributions<T>(_extPoint: IExtensionPoint<T>): Promise<ExtensionPointContribution<T>[]> { return Promise.resolve(Object.create(null)); }\n\tgetExtensionsStatus(): { [id: string]: IExtensionsStatus } { return Object.create(null); }\n\tgetInspectPorts(_extensionHostKind: ExtensionHostKind, _tryEnableInspector: boolean): Promise<{ port: number; host: string }[]> { return Promise.resolve([]); }\n\tstopExtensionHosts(): any { }\n\tasync startExtensionHosts(): Promise<void> { }\n\tasync setRemoteEnvironment(_env: { [key: string]: string | null }): Promise<void> { }\n\tcanAddExtension(): boolean { return false; }\n\tcanRemoveExtension(): boolean { return false; }\n}\n"],
  "mappings": ";;AAKA,SAAS,aAAa;AACtB,OAAO,cAAc;AACrB,SAAS,WAAW;AACpB,SAAS,+BAA+B;AACxC,SAAS,gBAAgB,6BAA6B;AACtD,SAAS,gCAAgC;AACzC,SAAS,qBAAqB,wBAAwB,wBAAwB,eAAe,YAAY,yBAAyB,uBAAuB,sBAAsB;AAC/K,SAAS,uBAAuB;AAChC,SAAS,uBAAuB;AAChC,SAAS,kBAAkB;AAC3B,SAAS,yBAAyB;AAClC,SAAS,4BAA4B,qCAAqC;AAC1E,SAAS,gCAAgC;AACzC,SAAS,uBAAuB;AAEzB,MAAM,2BAA2B,OAAO,OAA8B;AAAA,EAC5E,YAAY,IAAI,oBAAoB,0BAA0B;AAAA,EAC9D,MAAM;AAAA,EACN,SAAS;AAAA,EACT,WAAW;AAAA,EACX,SAAS,EAAE,QAAQ,GAAG;AAAA,EACtB,mBAAmB,IAAI,MAAM,eAAe;AAAA,EAC5C,WAAW;AAAA,EACX,gBAAgB,eAAe;AAAA,EAC/B,eAAe;AAAA,EACf,oBAAoB;AACrB,CAAC;AAGM,MAAM,yBAAyB;AAE/B,MAAM,oBAAoB,gBAAmC,kBAAkB;AAkB/E,MAAM,2BAA2B;AAAA,EACvC,YAAqB,YAAoB;AAApB;AAAA,EAAsB;AAAA,EAvD5C,OAsDwC;AAAA;AAAA;AAExC;AA0CO,IAAW,uBAAX,kBAAWA,0BAAX;AAIN,EAAAA,4CAAA,oBAAiB,KAAjB;AAIA,EAAAA,4CAAA,sBAAmB,KAAnB;AAIA,EAAAA,4CAAA,UAAO,KAAP;AAZiB,SAAAA;AAAA,GAAA;AAmCX,MAAM,wBAAwB;AAAA,EArIrC,OAqIqC;AAAA;AAAA;AAAA,EAC5B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAER,IAAW,YAAoB;AAC9B,WAAO,KAAK;AAAA,EACb;AAAA,EAEA,IAAW,gBAAyC;AACnD,WAAO,KAAK;AAAA,EACb;AAAA,EAEA,IAAW,eAAsC;AAChD,WAAO,KAAK;AAAA,EACb;AAAA,EAEA,YAAY,WAAmB,eAAiD,cAAqC;AACpH,SAAK,aAAa;AAClB,SAAK,iBAAiB,cAAc,MAAM,CAAC;AAC3C,SAAK,gBAAgB,aAAa,MAAM,CAAC;AACzC,SAAK,sBAAsB;AAAA,EAC5B;AAAA,EAEA,aAA4C;AAC3C,WAAO;AAAA,MACN,WAAW,KAAK;AAAA,MAChB,eAAe,KAAK;AAAA,MACpB,cAAc,KAAK;AAAA,MACnB,kBAAkB,yBAAyB,0BAA0B,KAAK,cAAc;AAAA,IACzF;AAAA,EACD;AAAA,EAEO,IAAI,WAAmB,eAAwC,cAAiE;AACtI,QAAI,KAAK,aAAa,WAAW;AAChC,YAAM,IAAI,MAAM,8CAA8C,SAAS,cAAc,KAAK,UAAU,GAAG;AAAA,IACxG;AACA,UAAM,WAAkC,CAAC;AACzC,UAAM,QAAiC,CAAC;AACxC,UAAM,aAAoC,CAAC;AAC3C,UAAM,UAAiC,CAAC;AAExC,UAAM,mBAAmB,+BAA+B,KAAK,cAAc;AAC3E,UAAM,mBAAmB,+BAA+B,aAAa;AACrE,UAAM,uBAAuB,wBAAC,GAA0B,MAA6B;AACpF,aACE,EAAE,kBAAkB,SAAS,MAAM,EAAE,kBAAkB,SAAS,KAC7D,EAAE,cAAc,EAAE,aAClB,EAAE,kBAAkB,EAAE,iBACtB,EAAE,uBAAuB,EAAE;AAAA,IAEjC,GAP6B;AAS7B,eAAW,gBAAgB,KAAK,gBAAgB;AAC/C,YAAM,eAAe,iBAAiB,IAAI,aAAa,UAAU;AACjE,UAAI,CAAC,cAAc;AAClB,iBAAS,KAAK,aAAa,UAAU;AACrC,yBAAiB,OAAO,aAAa,UAAU;AAC/C;AAAA,MACD;AACA,UAAI,CAAC,qBAAqB,cAAc,YAAY,GAAG;AAGtD,iBAAS,KAAK,aAAa,UAAU;AACrC,yBAAiB,OAAO,aAAa,UAAU;AAC/C;AAAA,MACD;AAAA,IACD;AACA,eAAW,gBAAgB,eAAe;AACzC,YAAM,eAAe,iBAAiB,IAAI,aAAa,UAAU;AACjE,UAAI,CAAC,cAAc;AAClB,cAAM,KAAK,YAAY;AACvB;AAAA,MACD;AACA,UAAI,CAAC,qBAAqB,cAAc,YAAY,GAAG;AAGtD,iBAAS,KAAK,aAAa,UAAU;AACrC,yBAAiB,OAAO,aAAa,UAAU;AAC/C;AAAA,MACD;AAAA,IACD;AAEA,UAAM,qBAAqB,IAAI,uBAAuB,KAAK,aAAa;AACxE,UAAM,qBAAqB,IAAI,uBAAuB,YAAY;AAClE,eAAW,kBAAkB,KAAK,eAAe;AAChD,UAAI,CAAC,mBAAmB,IAAI,cAAc,GAAG;AAC5C,mBAAW,KAAK,cAAc;AAAA,MAC/B;AAAA,IACD;AACA,eAAW,kBAAkB,cAAc;AAC1C,UAAI,CAAC,mBAAmB,IAAI,cAAc,GAAG;AAC5C,gBAAQ,KAAK,cAAc;AAAA,MAC5B;AAAA,IACD;AAEA,UAAM,sBAAsB,yBAAyB,0BAA0B,KAAK;AACpF,UAAM,QAAQ,EAAE,WAAW,UAAU,OAAO,qBAAqB,YAAY,QAAQ;AACrF,SAAK,MAAM,KAAK;AAChB,WAAO;AAAA,EACR;AAAA,EAEO,MAAM,iBAAgF;AAC5F,QAAI,KAAK,cAAc,gBAAgB,WAAW;AAEjD,aAAO;AAAA,IACR;AAEA,UAAM,EAAE,UAAU,OAAO,YAAY,QAAQ,IAAI;AAEjD,UAAM,cAAc,IAAI,uBAAuB,QAAQ;AACvD,UAAM,gBAAgB,IAAI,uBAAuB,UAAU;AAC3D,aAAS,IAAI,GAAG,IAAI,KAAK,eAAe,QAAQ,KAAK;AACpD,UAAI,YAAY,IAAI,KAAK,eAAe,CAAC,EAAE,UAAU,GAAG;AACvD,aAAK,eAAe,OAAO,GAAG,CAAC;AAC/B;AAAA,MACD;AAAA,IACD;AACA,aAAS,IAAI,GAAG,IAAI,KAAK,cAAc,QAAQ,KAAK;AACnD,UAAI,cAAc,IAAI,KAAK,cAAc,CAAC,CAAC,GAAG;AAC7C,aAAK,cAAc,OAAO,GAAG,CAAC;AAC9B;AAAA,MACD;AAAA,IACD;AAEA,eAAW,aAAa,OAAO;AAC9B,WAAK,eAAe,KAAK,SAAS;AAAA,IACnC;AACA,eAAW,eAAe,SAAS;AAClC,WAAK,cAAc,KAAK,WAAW;AAAA,IACpC;AAGA,SAAK,sBAAsB;AAE3B,WAAO;AAAA,EACR;AAAA,EAEO,kBAAkB,aAA2C;AACnE,eAAW,iBAAiB,KAAK,eAAe;AAC/C,UAAI,oBAAoB,OAAO,eAAe,WAAW,GAAG;AAC3D,eAAO;AAAA,MACR;AAAA,IACD;AACA,WAAO;AAAA,EACR;AAAA,EAEO,wBAAwB,iBAAkC;AAChE,QAAI,CAAC,KAAK,qBAAqB;AAC9B,WAAK,sBAAsB,KAAK,wBAAwB;AAAA,IACzD;AACA,WAAO,KAAK,oBAAoB,IAAI,eAAe;AAAA,EACpD;AAAA,EAEQ,0BAAuC;AAC9C,UAAM,SAAS,oBAAI,IAAY;AAE/B,eAAW,wBAAwB,KAAK,gBAAgB;AACvD,UAAI,CAAC,KAAK,kBAAkB,qBAAqB,UAAU,GAAG;AAC7D;AAAA,MACD;AAEA,YAAM,mBAAmB,yBAAyB,qBAAqB,oBAAoB;AAC3F,iBAAW,mBAAmB,kBAAkB;AAC/C,eAAO,IAAI,eAAe;AAAA,MAC3B;AAAA,IACD;AAEA,WAAO;AAAA,EACR;AACD;AAEA,SAAS,+BAA+B,YAAoF;AAC3H,QAAM,SAAS,IAAI,uBAA8C;AACjE,aAAW,aAAa,YAAY;AACnC,WAAO,IAAI,UAAU,YAAY,SAAS;AAAA,EAC3C;AACA,SAAO;AACR;AANS;AAQF,SAAS,qBAAqB,WAAkC,UAAoC;AAC1G,MAAI,CAAC,UAAU,qBAAqB;AACnC,WAAO;AAAA,EACR;AACA,SAAO,UAAU,oBAAoB,SAAS,QAAQ;AACvD;AALgB;AAOT,SAAS,wBAAwB,WAAkC,UAAiC;AAC1G,MAAI,CAAC,qBAAqB,WAAW,QAAQ,GAAG;AAC/C,UAAM,IAAI,MAAM,cAAc,UAAU,WAAW,KAAK,8BAA8B,QAAQ;AAAA,0DAA8D,UAAU,qBAAqB,KAAK,IAAI,KAAK,IAAI,YAAY,QAAQ;AAAA,uJAA2J,UAAU,WAAW,KAAK,EAAE;AAAA,EACzZ;AACD;AAJgB;AAkBT,MAAM,gBAAgB;AAAA,EAC5B,YACiB,iBACA,kBACA,sBACA,kBACf;AAJe;AACA;AACA;AACA;AAAA,EAEjB;AAAA,EA1VD,OAmV6B;AAAA;AAAA;AAQ7B;AAEO,MAAM,2BAA8B;AAAA,EA7V3C,OA6V2C;AAAA;AAAA;AAAA,EACjC;AAAA,EACA;AAAA,EAET,YAAY,aAAoC,OAAU;AACzD,SAAK,cAAc;AACnB,SAAK,QAAQ;AAAA,EACd;AACD;AAgBO,IAAW,iBAAX,kBAAWC,oBAAX;AACN,EAAAA,gCAAA,YAAS,KAAT;AACA,EAAAA,gCAAA,eAAY,KAAZ;AAFiB,SAAAA;AAAA,GAAA;AAmLX,SAAS,YAAY,sBAAyD;AACpF,SAAO;AAAA,IACN,MAAM,qBAAqB,YAAY,cAAc,SAAS,cAAc;AAAA,IAC5E,WAAW,qBAAqB,aAAa,qBAAqB;AAAA,IAClE,YAAY,EAAE,IAAI,sBAAsB,qBAAqB,WAAW,qBAAqB,IAAI,GAAG,MAAM,qBAAqB,KAAK;AAAA,IACpI,UAAU;AAAA,IACV,UAAU,qBAAqB;AAAA,IAC/B,gBAAgB,qBAAqB;AAAA,IACrC,aAAa,CAAC;AAAA,IACd,SAAS;AAAA,EACV;AACD;AAXgB;AAaT,SAAS,uBAAuB,WAAuB,oBAAqD;AAClH,QAAM,KAAK,eAAe,UAAU,SAAS,WAAW,UAAU,SAAS,IAAI;AAC/E,SAAO;AAAA,IACN;AAAA,IACA,YAAY,IAAI,oBAAoB,EAAE;AAAA,IACtC,WAAW,UAAU,SAAS,cAAc;AAAA,IAC5C,eAAe,UAAU,SAAS,cAAc,QAAQ,UAAU;AAAA,IAClE,oBAAoB,CAAC,CAAC;AAAA,IACtB,mBAAmB,UAAU;AAAA,IAC7B,MAAM,UAAU,WAAW;AAAA,IAC3B,gBAAgB,UAAU;AAAA,IAC1B,sBAAsB,UAAU;AAAA,IAChC,GAAG,UAAU;AAAA,EACd;AACD;AAdgB;AAiBT,MAAM,qBAAkD;AAAA,EAtkB/D,OAskB+D;AAAA;AAAA;AAAA,EAE9D,0BAAuC,MAAM;AAAA,EAC7C,8BAA4D,MAAM;AAAA,EAClE,wBAAwB,MAAM;AAAA,EAC9B,wBAAmD,MAAM;AAAA,EACzD,8BAAkE,MAAM;AAAA,EACxE,aAAiD,MAAM;AAAA,EAC9C,aAAa,CAAC;AAAA,EACvB,gBAAgB,kBAAyC;AAAE,WAAO,QAAQ,QAAQ,MAAS;AAAA,EAAG;AAAA,EAC9F,aAAa,aAAkC,QAAkD;AAAE,WAAO,QAAQ,QAAQ,MAAS;AAAA,EAAG;AAAA,EACtI,sBAAsB,kBAAmC;AAAE,WAAO;AAAA,EAAO;AAAA,EACzE,oCAAsD;AAAE,WAAO,QAAQ,QAAQ,IAAI;AAAA,EAAG;AAAA,EACtF,eAAe;AAAE,WAAO,QAAQ,QAAQ,MAAS;AAAA,EAAG;AAAA,EACpD,gCAAmC,WAAyE;AAAE,WAAO,QAAQ,QAAQ,uBAAO,OAAO,IAAI,CAAC;AAAA,EAAG;AAAA,EAC3J,sBAA2D;AAAE,WAAO,uBAAO,OAAO,IAAI;AAAA,EAAG;AAAA,EACzF,gBAAgB,oBAAuC,qBAAyE;AAAE,WAAO,QAAQ,QAAQ,CAAC,CAAC;AAAA,EAAG;AAAA,EAC9J,qBAA0B;AAAA,EAAE;AAAA,EAC5B,MAAM,sBAAqC;AAAA,EAAE;AAAA,EAC7C,MAAM,qBAAqB,MAAuD;AAAA,EAAE;AAAA,EACpF,kBAA2B;AAAE,WAAO;AAAA,EAAO;AAAA,EAC3C,qBAA8B;AAAE,WAAO;AAAA,EAAO;AAC/C;",
  "names": ["ExtensionHostStartup", "ActivationKind"]
}
