{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/extensions/common/extensions.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from \"../../../../base/common/event.js\";\nimport type Severity from \"../../../../base/common/severity.js\";\nimport { URI } from \"../../../../base/common/uri.js\";\nimport type { IMessagePassingProtocol } from \"../../../../base/parts/ipc/common/ipc.js\";\nimport {\n\tgetExtensionId,\n\tgetGalleryExtensionId,\n} from \"../../../../platform/extensionManagement/common/extensionManagementUtil.js\";\nimport { ImplicitActivationEvents } from \"../../../../platform/extensionManagement/common/implicitActivationEvents.js\";\nimport {\n\tExtensionIdentifier,\n\tExtensionIdentifierMap,\n\tExtensionIdentifierSet,\n\tExtensionType,\n\ttype IExtension,\n\ttype IExtensionContributions,\n\ttype IExtensionDescription,\n\tTargetPlatform,\n} from \"../../../../platform/extensions/common/extensions.js\";\nimport type { ApiProposalName } from \"../../../../platform/extensions/common/extensionsApiProposals.js\";\nimport { createDecorator } from \"../../../../platform/instantiation/common/instantiation.js\";\nimport type { IV8Profile } from \"../../../../platform/profiling/common/profiling.js\";\nimport type { ExtensionHostKind } from \"./extensionHostKind.js\";\nimport type {\n\tIExtensionDescriptionDelta,\n\tIExtensionDescriptionSnapshot,\n} from \"./extensionHostProtocol.js\";\nimport type { ExtensionRunningLocation } from \"./extensionRunningLocation.js\";\nimport type { IExtensionPoint } from \"./extensionsRegistry.js\";\n\nexport const nullExtensionDescription = Object.freeze<IExtensionDescription>({\n\tidentifier: new ExtensionIdentifier(\"nullExtensionDescription\"),\n\tname: \"Null Extension Description\",\n\tversion: \"0.0.0\",\n\tpublisher: \"vscode\",\n\tengines: { vscode: \"\" },\n\textensionLocation: URI.parse(\"void:location\"),\n\tisBuiltin: false,\n\ttargetPlatform: TargetPlatform.UNDEFINED,\n\tisUserBuiltin: false,\n\tisUnderDevelopment: false,\n});\n\nexport type WebWorkerExtHostConfigValue = boolean | \"auto\";\nexport const webWorkerExtHostConfig = \"extensions.webWorker\";\n\nexport const IExtensionService =\n\tcreateDecorator<IExtensionService>(\"extensionService\");\n\nexport interface IMessage {\n\ttype: Severity;\n\tmessage: string;\n\textensionId: ExtensionIdentifier;\n\textensionPointId: string;\n}\n\nexport interface IExtensionsStatus {\n\tid: ExtensionIdentifier;\n\tmessages: IMessage[];\n\tactivationStarted: boolean;\n\tactivationTimes: ActivationTimes | undefined;\n\truntimeErrors: Error[];\n\trunningLocation: ExtensionRunningLocation | null;\n}\n\nexport class MissingExtensionDependency {\n\tconstructor(readonly dependency: string) {}\n}\n\n/**\n * e.g.\n * ```\n * {\n *    startTime: 1511954813493000,\n *    endTime: 1511954835590000,\n *    deltas: [ 100, 1500, 123456, 1500, 100000 ],\n *    ids: [ 'idle', 'self', 'extension1', 'self', 'idle' ]\n * }\n * ```\n */\nexport interface IExtensionHostProfile {\n\t/**\n\t * Profiling start timestamp in microseconds.\n\t */\n\tstartTime: number;\n\t/**\n\t * Profiling end timestamp in microseconds.\n\t */\n\tendTime: number;\n\t/**\n\t * Duration of segment in microseconds.\n\t */\n\tdeltas: number[];\n\t/**\n\t * Segment identifier: extension id or one of the four known strings.\n\t */\n\tids: ProfileSegmentId[];\n\n\t/**\n\t * Get the information as a .cpuprofile.\n\t */\n\tdata: IV8Profile;\n\n\t/**\n\t * Get the aggregated time per segmentId\n\t */\n\tgetAggregatedTimes(): Map<ProfileSegmentId, number>;\n}\n\nexport enum ExtensionHostStartup {\n\t/**\n\t * The extension host should be launched immediately and doesn't require a `$startExtensionHost` call.\n\t */\n\tEagerAutoStart = 1,\n\t/**\n\t * The extension host should be launched immediately and needs a `$startExtensionHost` call.\n\t */\n\tEagerManualStart = 2,\n\t/**\n\t * The extension host should be launched lazily and only when it has extensions it needs to host. It needs a `$startExtensionHost` call.\n\t */\n\tLazy = 3,\n}\n\nexport interface IExtensionHost {\n\treadonly pid: number | null;\n\treadonly runningLocation: ExtensionRunningLocation;\n\treadonly remoteAuthority: string | null;\n\treadonly startup: ExtensionHostStartup;\n\t/**\n\t * A collection of extensions which includes information about which\n\t * extension will execute or is executing on this extension host.\n\t * **NOTE**: this will reflect extensions correctly only after `start()` resolves.\n\t */\n\treadonly extensions: ExtensionHostExtensions | null;\n\treadonly onExit: Event<[number, string | null]>;\n\n\tstart(): Promise<IMessagePassingProtocol>;\n\tgetInspectPort(): { port: number; host: string } | undefined;\n\tenableInspectPort(): Promise<boolean>;\n\tdisconnect?(): Promise<void>;\n\tdispose(): void;\n}\n\nexport class ExtensionHostExtensions {\n\tprivate _versionId: number;\n\tprivate _allExtensions: IExtensionDescription[];\n\tprivate _myExtensions: ExtensionIdentifier[];\n\tprivate _myActivationEvents: Set<string> | null;\n\n\tpublic get versionId(): number {\n\t\treturn this._versionId;\n\t}\n\n\tpublic get allExtensions(): IExtensionDescription[] {\n\t\treturn this._allExtensions;\n\t}\n\n\tpublic get myExtensions(): ExtensionIdentifier[] {\n\t\treturn this._myExtensions;\n\t}\n\n\tconstructor(\n\t\tversionId: number,\n\t\tallExtensions: readonly IExtensionDescription[],\n\t\tmyExtensions: ExtensionIdentifier[],\n\t) {\n\t\tthis._versionId = versionId;\n\t\tthis._allExtensions = allExtensions.slice(0);\n\t\tthis._myExtensions = myExtensions.slice(0);\n\t\tthis._myActivationEvents = null;\n\t}\n\n\ttoSnapshot(): IExtensionDescriptionSnapshot {\n\t\treturn {\n\t\t\tversionId: this._versionId,\n\t\t\tallExtensions: this._allExtensions,\n\t\t\tmyExtensions: this._myExtensions,\n\t\t\tactivationEvents:\n\t\t\t\tImplicitActivationEvents.createActivationEventsMap(\n\t\t\t\t\tthis._allExtensions,\n\t\t\t\t),\n\t\t};\n\t}\n\n\tpublic set(\n\t\tversionId: number,\n\t\tallExtensions: IExtensionDescription[],\n\t\tmyExtensions: ExtensionIdentifier[],\n\t): IExtensionDescriptionDelta {\n\t\tif (this._versionId > versionId) {\n\t\t\tthrow new Error(\n\t\t\t\t`ExtensionHostExtensions: invalid versionId ${versionId} (current: ${this._versionId})`,\n\t\t\t);\n\t\t}\n\t\tconst toRemove: ExtensionIdentifier[] = [];\n\t\tconst toAdd: IExtensionDescription[] = [];\n\t\tconst myToRemove: ExtensionIdentifier[] = [];\n\t\tconst myToAdd: ExtensionIdentifier[] = [];\n\n\t\tconst oldExtensionsMap = extensionDescriptionArrayToMap(\n\t\t\tthis._allExtensions,\n\t\t);\n\t\tconst newExtensionsMap = extensionDescriptionArrayToMap(allExtensions);\n\t\tconst extensionsAreTheSame = (\n\t\t\ta: IExtensionDescription,\n\t\t\tb: IExtensionDescription,\n\t\t) => {\n\t\t\treturn (\n\t\t\t\ta.extensionLocation.toString() ===\n\t\t\t\t\tb.extensionLocation.toString() ||\n\t\t\t\ta.isBuiltin === b.isBuiltin ||\n\t\t\t\ta.isUserBuiltin === b.isUserBuiltin ||\n\t\t\t\ta.isUnderDevelopment === b.isUnderDevelopment\n\t\t\t);\n\t\t};\n\n\t\tfor (const oldExtension of this._allExtensions) {\n\t\t\tconst newExtension = newExtensionsMap.get(oldExtension.identifier);\n\t\t\tif (!newExtension) {\n\t\t\t\ttoRemove.push(oldExtension.identifier);\n\t\t\t\toldExtensionsMap.delete(oldExtension.identifier);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!extensionsAreTheSame(oldExtension, newExtension)) {\n\t\t\t\t// The new extension is different than the old one\n\t\t\t\t// (e.g. maybe it executes in a different location)\n\t\t\t\ttoRemove.push(oldExtension.identifier);\n\t\t\t\toldExtensionsMap.delete(oldExtension.identifier);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tfor (const newExtension of allExtensions) {\n\t\t\tconst oldExtension = oldExtensionsMap.get(newExtension.identifier);\n\t\t\tif (!oldExtension) {\n\t\t\t\ttoAdd.push(newExtension);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!extensionsAreTheSame(oldExtension, newExtension)) {\n\t\t\t\t// The new extension is different than the old one\n\t\t\t\t// (e.g. maybe it executes in a different location)\n\t\t\t\ttoRemove.push(oldExtension.identifier);\n\t\t\t\toldExtensionsMap.delete(oldExtension.identifier);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tconst myOldExtensionsSet = new ExtensionIdentifierSet(\n\t\t\tthis._myExtensions,\n\t\t);\n\t\tconst myNewExtensionsSet = new ExtensionIdentifierSet(myExtensions);\n\t\tfor (const oldExtensionId of this._myExtensions) {\n\t\t\tif (!myNewExtensionsSet.has(oldExtensionId)) {\n\t\t\t\tmyToRemove.push(oldExtensionId);\n\t\t\t}\n\t\t}\n\t\tfor (const newExtensionId of myExtensions) {\n\t\t\tif (!myOldExtensionsSet.has(newExtensionId)) {\n\t\t\t\tmyToAdd.push(newExtensionId);\n\t\t\t}\n\t\t}\n\n\t\tconst addActivationEvents =\n\t\t\tImplicitActivationEvents.createActivationEventsMap(toAdd);\n\t\tconst delta = {\n\t\t\tversionId,\n\t\t\ttoRemove,\n\t\t\ttoAdd,\n\t\t\taddActivationEvents,\n\t\t\tmyToRemove,\n\t\t\tmyToAdd,\n\t\t};\n\t\tthis.delta(delta);\n\t\treturn delta;\n\t}\n\n\tpublic delta(\n\t\textensionsDelta: IExtensionDescriptionDelta,\n\t): IExtensionDescriptionDelta | null {\n\t\tif (this._versionId >= extensionsDelta.versionId) {\n\t\t\t// ignore older deltas\n\t\t\treturn null;\n\t\t}\n\n\t\tconst { toRemove, toAdd, myToRemove, myToAdd } = extensionsDelta;\n\t\t// First handle removals\n\t\tconst toRemoveSet = new ExtensionIdentifierSet(toRemove);\n\t\tconst myToRemoveSet = new ExtensionIdentifierSet(myToRemove);\n\t\tfor (let i = 0; i < this._allExtensions.length; i++) {\n\t\t\tif (toRemoveSet.has(this._allExtensions[i].identifier)) {\n\t\t\t\tthis._allExtensions.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0; i < this._myExtensions.length; i++) {\n\t\t\tif (myToRemoveSet.has(this._myExtensions[i])) {\n\t\t\t\tthis._myExtensions.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\t// Then handle additions\n\t\tfor (const extension of toAdd) {\n\t\t\tthis._allExtensions.push(extension);\n\t\t}\n\t\tfor (const extensionId of myToAdd) {\n\t\t\tthis._myExtensions.push(extensionId);\n\t\t}\n\n\t\t// clear cached activation events\n\t\tthis._myActivationEvents = null;\n\n\t\treturn extensionsDelta;\n\t}\n\n\tpublic containsExtension(extensionId: ExtensionIdentifier): boolean {\n\t\tfor (const myExtensionId of this._myExtensions) {\n\t\t\tif (ExtensionIdentifier.equals(myExtensionId, extensionId)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic containsActivationEvent(activationEvent: string): boolean {\n\t\tif (!this._myActivationEvents) {\n\t\t\tthis._myActivationEvents = this._readMyActivationEvents();\n\t\t}\n\t\treturn this._myActivationEvents.has(activationEvent);\n\t}\n\n\tprivate _readMyActivationEvents(): Set<string> {\n\t\tconst result = new Set<string>();\n\n\t\tfor (const extensionDescription of this._allExtensions) {\n\t\t\tif (!this.containsExtension(extensionDescription.identifier)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst activationEvents =\n\t\t\t\tImplicitActivationEvents.readActivationEvents(\n\t\t\t\t\textensionDescription,\n\t\t\t\t);\n\t\t\tfor (const activationEvent of activationEvents) {\n\t\t\t\tresult.add(activationEvent);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n}\n\nfunction extensionDescriptionArrayToMap(\n\textensions: IExtensionDescription[],\n): ExtensionIdentifierMap<IExtensionDescription> {\n\tconst result = new ExtensionIdentifierMap<IExtensionDescription>();\n\tfor (const extension of extensions) {\n\t\tresult.set(extension.identifier, extension);\n\t}\n\treturn result;\n}\n\nexport function isProposedApiEnabled(\n\textension: IExtensionDescription,\n\tproposal: ApiProposalName,\n): boolean {\n\tif (!extension.enabledApiProposals) {\n\t\treturn false;\n\t}\n\treturn extension.enabledApiProposals.includes(proposal);\n}\n\nexport function checkProposedApiEnabled(\n\textension: IExtensionDescription,\n\tproposal: ApiProposalName,\n): void {\n\tif (!isProposedApiEnabled(extension, proposal)) {\n\t\tthrow new Error(\n\t\t\t`Extension '${extension.identifier.value}' CANNOT use API proposal: ${proposal}.\\nIts package.json#enabledApiProposals-property declares: ${extension.enabledApiProposals?.join(\", \") ?? \"[]\"} but NOT ${proposal}.\\n The missing proposal MUST be added and you must start in extension development mode or use the following command line switch: --enable-proposed-api ${extension.identifier.value}`,\n\t\t);\n\t}\n}\n\n/**\n * Extension id or one of the four known program states.\n */\nexport type ProfileSegmentId = string | \"idle\" | \"program\" | \"gc\" | \"self\";\n\nexport interface ExtensionActivationReason {\n\treadonly startup: boolean;\n\treadonly extensionId: ExtensionIdentifier;\n\treadonly activationEvent: string;\n}\n\nexport class ActivationTimes {\n\tconstructor(\n\t\tpublic readonly codeLoadingTime: number,\n\t\tpublic readonly activateCallTime: number,\n\t\tpublic readonly activateResolvedTime: number,\n\t\tpublic readonly activationReason: ExtensionActivationReason,\n\t) {}\n}\n\nexport class ExtensionPointContribution<T> {\n\treadonly description: IExtensionDescription;\n\treadonly value: T;\n\n\tconstructor(description: IExtensionDescription, value: T) {\n\t\tthis.description = description;\n\t\tthis.value = value;\n\t}\n}\n\nexport interface IWillActivateEvent {\n\treadonly event: string;\n\treadonly activation: Promise<void>;\n}\n\nexport interface IResponsiveStateChangeEvent {\n\textensionHostKind: ExtensionHostKind;\n\tisResponsive: boolean;\n\t/**\n\t * Return the inspect port or `0`. `0` means inspection is not possible.\n\t */\n\tgetInspectListener(\n\t\ttryEnableInspector: boolean,\n\t): Promise<{ port: number; host: string } | undefined>;\n}\n\nexport enum ActivationKind {\n\tNormal = 0,\n\tImmediate = 1,\n}\n\nexport interface WillStopExtensionHostsEvent {\n\t/**\n\t * A human readable reason for stopping the extension hosts\n\t * that e.g. can be shown in a confirmation dialog to the\n\t * user.\n\t */\n\treadonly reason: string;\n\n\t/**\n\t * A flag to indicate if the operation was triggered automatically\n\t */\n\treadonly auto: boolean;\n\n\t/**\n\t * Allows to veto the stopping of extension hosts. The veto can be a long running\n\t * operation.\n\t *\n\t * @param reason a human readable reason for vetoing the extension host stop in case\n\t * where the resolved `value: true`.\n\t */\n\tveto(value: boolean | Promise<boolean>, reason: string): void;\n}\n\nexport interface IExtensionService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * An event emitted when extensions are registered after their extension points got handled.\n\t *\n\t * This event will also fire on startup to signal the installed extensions.\n\t *\n\t * @returns the extensions that got registered\n\t */\n\tonDidRegisterExtensions: Event<void>;\n\n\t/**\n\t * @event\n\t * Fired when extensions status changes.\n\t * The event contains the ids of the extensions that have changed.\n\t */\n\tonDidChangeExtensionsStatus: Event<ExtensionIdentifier[]>;\n\n\t/**\n\t * Fired when the available extensions change (i.e. when extensions are added or removed).\n\t */\n\tonDidChangeExtensions: Event<{\n\t\treadonly added: readonly IExtensionDescription[];\n\t\treadonly removed: readonly IExtensionDescription[];\n\t}>;\n\n\t/**\n\t * All registered extensions.\n\t * - List will be empty initially during workbench startup and will be filled with extensions as they are registered\n\t * - Listen to `onDidChangeExtensions` event for any changes to the extensions list. It will change as extensions get registered or de-reigstered.\n\t * - Listen to `onDidRegisterExtensions` event or wait for `whenInstalledExtensionsRegistered` promise to get the initial list of registered extensions.\n\t */\n\treadonly extensions: readonly IExtensionDescription[];\n\n\t/**\n\t * An event that is fired when activation happens.\n\t */\n\tonWillActivateByEvent: Event<IWillActivateEvent>;\n\n\t/**\n\t * An event that is fired when an extension host changes its\n\t * responsive-state.\n\t */\n\tonDidChangeResponsiveChange: Event<IResponsiveStateChangeEvent>;\n\n\t/**\n\t * Fired before stop of extension hosts happens. Allows listeners to veto against the\n\t * stop to prevent it from happening.\n\t */\n\tonWillStop: Event<WillStopExtensionHostsEvent>;\n\n\t/**\n\t * Send an activation event and activate interested extensions.\n\t *\n\t * This will wait for the normal startup of the extension host(s).\n\t *\n\t * In extraordinary circumstances, if the activation event needs to activate\n\t * one or more extensions before the normal startup is finished, then you can use\n\t * `ActivationKind.Immediate`. Please do not use this flag unless really necessary\n\t * and you understand all consequences.\n\t */\n\tactivateByEvent(\n\t\tactivationEvent: string,\n\t\tactivationKind?: ActivationKind,\n\t): Promise<void>;\n\n\t/**\n\t * Send an activation ID and activate interested extensions.\n\t *\n\t */\n\tactivateById(\n\t\textensionId: ExtensionIdentifier,\n\t\treason: ExtensionActivationReason,\n\t): Promise<void>;\n\n\t/**\n\t * Determine if `activateByEvent(activationEvent)` has resolved already.\n\t *\n\t * i.e. the activation event is finished and all interested extensions are already active.\n\t */\n\tactivationEventIsDone(activationEvent: string): boolean;\n\n\t/**\n\t * An promise that resolves when the installed extensions are registered after\n\t * their extension points got handled.\n\t */\n\twhenInstalledExtensionsRegistered(): Promise<boolean>;\n\n\t/**\n\t * Return a specific extension\n\t * @param id An extension id\n\t */\n\tgetExtension(id: string): Promise<IExtensionDescription | undefined>;\n\n\t/**\n\t * Returns `true` if the given extension can be added. Otherwise `false`.\n\t * @param extension An extension\n\t */\n\tcanAddExtension(extension: IExtensionDescription): boolean;\n\n\t/**\n\t * Returns `true` if the given extension can be removed. Otherwise `false`.\n\t * @param extension An extension\n\t */\n\tcanRemoveExtension(extension: IExtensionDescription): boolean;\n\n\t/**\n\t * Read all contributions to an extension point.\n\t */\n\treadExtensionPointContributions<\n\t\tT extends IExtensionContributions[keyof IExtensionContributions],\n\t>(extPoint: IExtensionPoint<T>): Promise<ExtensionPointContribution<T>[]>;\n\n\t/**\n\t * Get information about extensions status.\n\t */\n\tgetExtensionsStatus(): { [id: string]: IExtensionsStatus };\n\n\t/**\n\t * Return the inspect ports (if inspection is possible) for extension hosts of kind `extensionHostKind`.\n\t */\n\tgetInspectPorts(\n\t\textensionHostKind: ExtensionHostKind,\n\t\ttryEnableInspector: boolean,\n\t): Promise<{ port: number; host: string }[]>;\n\n\t/**\n\t * Stops the extension hosts.\n\t *\n\t * @param reason a human readable reason for stopping the extension hosts. This maybe\n\t * can be presented to the user when showing dialogs.\n\t *\n\t * @param auto indicates if the operation was triggered by an automatic action\n\t *\n\t * @returns a promise that resolves to `true` if the extension hosts were stopped, `false`\n\t * if the operation was vetoed by listeners of the `onWillStop` event.\n\t */\n\tstopExtensionHosts(reason: string, auto?: boolean): Promise<boolean>;\n\n\t/**\n\t * Starts the extension hosts. If updates are provided, the extension hosts are started with the given updates.\n\t */\n\tstartExtensionHosts(updates?: {\n\t\treadonly toAdd: readonly IExtension[];\n\t\treadonly toRemove: readonly string[];\n\t}): Promise<void>;\n\n\t/**\n\t * Modify the environment of the remote extension host\n\t * @param env New properties for the remote extension host\n\t */\n\tsetRemoteEnvironment(env: { [key: string]: string | null }): Promise<void>;\n}\n\nexport interface IInternalExtensionService {\n\t_activateById(\n\t\textensionId: ExtensionIdentifier,\n\t\treason: ExtensionActivationReason,\n\t): Promise<void>;\n\t_onWillActivateExtension(extensionId: ExtensionIdentifier): void;\n\t_onDidActivateExtension(\n\t\textensionId: ExtensionIdentifier,\n\t\tcodeLoadingTime: number,\n\t\tactivateCallTime: number,\n\t\tactivateResolvedTime: number,\n\t\tactivationReason: ExtensionActivationReason,\n\t): void;\n\t_onDidActivateExtensionError(\n\t\textensionId: ExtensionIdentifier,\n\t\terror: Error,\n\t): void;\n\t_onExtensionRuntimeError(\n\t\textensionId: ExtensionIdentifier,\n\t\terr: Error,\n\t): void;\n}\n\nexport interface ProfileSession {\n\tstop(): Promise<IExtensionHostProfile>;\n}\n\nexport function toExtension(\n\textensionDescription: IExtensionDescription,\n): IExtension {\n\treturn {\n\t\ttype: extensionDescription.isBuiltin\n\t\t\t? ExtensionType.System\n\t\t\t: ExtensionType.User,\n\t\tisBuiltin:\n\t\t\textensionDescription.isBuiltin ||\n\t\t\textensionDescription.isUserBuiltin,\n\t\tidentifier: {\n\t\t\tid: getGalleryExtensionId(\n\t\t\t\textensionDescription.publisher,\n\t\t\t\textensionDescription.name,\n\t\t\t),\n\t\t\tuuid: extensionDescription.uuid,\n\t\t},\n\t\tmanifest: extensionDescription,\n\t\tlocation: extensionDescription.extensionLocation,\n\t\ttargetPlatform: extensionDescription.targetPlatform,\n\t\tvalidations: [],\n\t\tisValid: true,\n\t};\n}\n\nexport function toExtensionDescription(\n\textension: IExtension,\n\tisUnderDevelopment?: boolean,\n): IExtensionDescription {\n\tconst id = getExtensionId(\n\t\textension.manifest.publisher,\n\t\textension.manifest.name,\n\t);\n\treturn {\n\t\tid,\n\t\tidentifier: new ExtensionIdentifier(id),\n\t\tisBuiltin: extension.type === ExtensionType.System,\n\t\tisUserBuiltin:\n\t\t\textension.type === ExtensionType.User && extension.isBuiltin,\n\t\tisUnderDevelopment: !!isUnderDevelopment,\n\t\textensionLocation: extension.location,\n\t\tuuid: extension.identifier.uuid,\n\t\ttargetPlatform: extension.targetPlatform,\n\t\tpublisherDisplayName: extension.publisherDisplayName,\n\t\t...extension.manifest,\n\t};\n}\n\nexport class NullExtensionService implements IExtensionService {\n\tdeclare readonly _serviceBrand: undefined;\n\tonDidRegisterExtensions: Event<void> = Event.None;\n\tonDidChangeExtensionsStatus: Event<ExtensionIdentifier[]> = Event.None;\n\tonDidChangeExtensions = Event.None;\n\tonWillActivateByEvent: Event<IWillActivateEvent> = Event.None;\n\tonDidChangeResponsiveChange: Event<IResponsiveStateChangeEvent> =\n\t\tEvent.None;\n\tonWillStop: Event<WillStopExtensionHostsEvent> = Event.None;\n\treadonly extensions = [];\n\tactivateByEvent(_activationEvent: string): Promise<void> {\n\t\treturn Promise.resolve(undefined);\n\t}\n\tactivateById(\n\t\textensionId: ExtensionIdentifier,\n\t\treason: ExtensionActivationReason,\n\t): Promise<void> {\n\t\treturn Promise.resolve(undefined);\n\t}\n\tactivationEventIsDone(_activationEvent: string): boolean {\n\t\treturn false;\n\t}\n\twhenInstalledExtensionsRegistered(): Promise<boolean> {\n\t\treturn Promise.resolve(true);\n\t}\n\tgetExtension() {\n\t\treturn Promise.resolve(undefined);\n\t}\n\treadExtensionPointContributions<T>(\n\t\t_extPoint: IExtensionPoint<T>,\n\t): Promise<ExtensionPointContribution<T>[]> {\n\t\treturn Promise.resolve(Object.create(null));\n\t}\n\tgetExtensionsStatus(): { [id: string]: IExtensionsStatus } {\n\t\treturn Object.create(null);\n\t}\n\tgetInspectPorts(\n\t\t_extensionHostKind: ExtensionHostKind,\n\t\t_tryEnableInspector: boolean,\n\t): Promise<{ port: number; host: string }[]> {\n\t\treturn Promise.resolve([]);\n\t}\n\tstopExtensionHosts(): any {}\n\tasync startExtensionHosts(): Promise<void> {}\n\tasync setRemoteEnvironment(_env: {\n\t\t[key: string]: string | null;\n\t}): Promise<void> {}\n\tcanAddExtension(): boolean {\n\t\treturn false;\n\t}\n\tcanRemoveExtension(): boolean {\n\t\treturn false;\n\t}\n}\n"],
  "mappings": "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",
  "names": ["ExtensionHostStartup", "ActivationKind"]
}
