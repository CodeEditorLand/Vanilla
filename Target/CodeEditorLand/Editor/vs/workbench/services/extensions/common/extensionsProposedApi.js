var f=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var b=(i,e,o,s)=>{for(var n=s>1?void 0:s?m(e,o):e,t=i.length-1,r;t>=0;t--)(r=i[t])&&(n=(s?r(e,o,n):r(n))||n);return s&&n&&f(e,o,n),n},a=(i,e)=>(o,s)=>e(o,s,i);import{isNonEmptyArray as c}from"../../../../base/common/arrays.js";import{MarkdownString as A}from"../../../../base/common/htmlContent.js";import{Disposable as P}from"../../../../base/common/lifecycle.js";import{localize as h}from"../../../../nls.js";import{ExtensionIdentifier as d}from"../../../../platform/extensions/common/extensions.js";import{allApiProposals as u}from"../../../../platform/extensions/common/extensionsApiProposals.js";import{SyncDescriptor as y}from"../../../../platform/instantiation/common/descriptors.js";import{ILogService as I}from"../../../../platform/log/common/log.js";import{IProductService as S}from"../../../../platform/product/common/productService.js";import{Registry as g}from"../../../../platform/registry/common/platform.js";import{IWorkbenchEnvironmentService as v}from"../../environment/common/environmentService.js";import{Extensions as x}from"../../extensionManagement/common/extensionFeatures.js";let p=class{constructor(e,o,s){this._logService=e;this._environmentService=o;if(this._envEnabledExtensions=new Set((o.extensionEnabledProposedApi??[]).map(n=>d.toKey(n))),this._envEnablesProposedApiForAll=!o.isBuilt||o.isExtensionDevelopment&&s.quality!=="stable"||this._envEnabledExtensions.size===0&&Array.isArray(o.extensionEnabledProposedApi),this._productEnabledExtensions=new Map,s.extensionEnabledApiProposals)for(const[n,t]of Object.entries(s.extensionEnabledApiProposals)){const r=d.toKey(n),l=t.filter(E=>u[E]?!0:(e.warn(`Via 'product.json#extensionEnabledApiProposals' extension '${r}' wants API proposal '${E}' but that proposal DOES NOT EXIST. Likely, the proposal has been finalized (check 'vscode.d.ts') or was abandoned.`),!1));this._productEnabledExtensions.set(r,l)}}_envEnablesProposedApiForAll;_envEnabledExtensions;_productEnabledExtensions;updateEnabledApiProposals(e){for(const o of e)this.doUpdateEnabledApiProposals(o)}doUpdateEnabledApiProposals(e){const o=d.toKey(e.identifier);if(c(e.enabledApiProposals)&&(e.enabledApiProposals=e.enabledApiProposals.filter(s=>{const n=!!u[s];return n||this._logService.error(`Extension '${o}' wants API proposal '${s}' but that proposal DOES NOT EXIST. Likely, the proposal has been finalized (check 'vscode.d.ts') or was abandoned.`),n})),this._productEnabledExtensions.has(o)){const s=this._productEnabledExtensions.get(o),n=new Set(s),t=new Set(e.enabledApiProposals),r=new Set([...t].filter(l=>!n.has(l)));r.size>0&&(this._logService.error(`Extension '${o}' appears in product.json but enables LESS API proposals than the extension wants.
package.json (LOSES): ${[...t].join(", ")}
product.json (WINS): ${[...n].join(", ")}`),this._environmentService.isExtensionDevelopment&&(this._logService.error(`Proceeding with EXTRA proposals (${[...r].join(", ")}) because extension is in development mode. Still, this EXTENSION WILL BE BROKEN unless product.json is updated.`),s.push(...r))),e.enabledApiProposals=s;return}this._envEnablesProposedApiForAll||this._envEnabledExtensions.has(o)||!e.isBuiltin&&c(e.enabledApiProposals)&&(this._logService.error(`Extension '${e.identifier.value} CANNOT USE these API proposals '${e.enabledApiProposals?.join(", ")||"*"}'. You MUST start in extension development mode or use the --enable-proposed-api command line flag`),e.enabledApiProposals=[])}};p=b([a(0,I),a(1,v),a(2,S)],p);class w extends P{type="markdown";shouldRender(e){return!!e.originalEnabledApiProposals?.length||!!e.enabledApiProposals?.length}render(e){const o=e.originalEnabledApiProposals??e.enabledApiProposals??[],s=new A;if(o.length)for(const n of o)s.appendMarkdown(`- \`${n}\`
`);return{data:s,dispose:()=>{}}}}g.as(x.ExtensionFeaturesRegistry).registerExtensionFeature({id:"enabledApiProposals",label:h("enabledProposedAPIs","API Proposals"),access:{canToggle:!1},renderer:new y(w)});export{p as ExtensionsProposedApi};
