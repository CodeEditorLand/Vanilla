var _=Object.defineProperty;var y=Object.getOwnPropertyDescriptor;var m=(c,a,e,n)=>{for(var r=n>1?void 0:n?y(a,e):a,o=c.length-1,i;o>=0;o--)(i=c[o])&&(r=(n?i(a,e,r):i(r))||r);return n&&r&&_(a,e,r),r},t=(c,a)=>(e,n)=>a(e,n,c);import{Disposable as T}from"../../../../base/common/lifecycle.js";import{OS as f}from"../../../../base/common/platform.js";import"../../../../base/common/uri.js";import{IConfigurationService as I}from"../../../../platform/configuration/common/configuration.js";import{InstantiationType as g,registerSingleton as b}from"../../../../platform/instantiation/common/extensions.js";import{IInstantiationService as P}from"../../../../platform/instantiation/common/instantiation.js";import{ILogService as A}from"../../../../platform/log/common/log.js";import"../../../../platform/remote/common/remoteAgentConnection.js";import{IRemoteAuthorityResolverService as R}from"../../../../platform/remote/common/remoteAuthorityResolver.js";import{ISharedProcessTunnelService as S}from"../../../../platform/remote/common/sharedProcessTunnelService.js";import{AbstractTunnelService as w,isPortPrivileged as D,isTunnelProvider as E,ITunnelService as W,TunnelPrivacyId as k}from"../../../../platform/tunnel/common/tunnel.js";import{IWorkbenchEnvironmentService as C}from"../../environment/common/environmentService.js";import{INativeWorkbenchEnvironmentService as L}from"../../environment/electron-sandbox/environmentService.js";import{ILifecycleService as x}from"../../lifecycle/common/lifecycle.js";let v=class extends T{constructor(e,n,r,o,i,l,s,u,d){super();this._id=e;this._addressProvider=n;this.tunnelRemoteHost=r;this.tunnelRemotePort=o;this.tunnelLocalPort=i;this.localAddress=l;this._onBeforeDispose=s;this._sharedProcessTunnelService=u;this._remoteAuthorityResolverService=d;this._updateAddress(),this._register(this._remoteAuthorityResolverService.onDidChangeConnectionData(()=>this._updateAddress()))}privacy=k.Private;protocol=void 0;_updateAddress(){this._addressProvider.getAddress().then(e=>{this._sharedProcessTunnelService.setAddress(this._id,e)})}async dispose(){this._onBeforeDispose(),super.dispose(),await this._sharedProcessTunnelService.destroyTunnel(this._id)}};v=m([t(7,S),t(8,R)],v);let h=class extends w{constructor(e,n,r,o,i,l,s){super(e,s);this._environmentService=n;this._sharedProcessTunnelService=r;this._instantiationService=o;this._nativeWorkbenchEnvironmentService=l;this._register(i.onDidShutdown(()=>{this._activeSharedProcessTunnels.forEach(u=>{this._sharedProcessTunnelService.destroyTunnel(u)})}))}_activeSharedProcessTunnels=new Set;isPortPrivileged(e){return D(e,this.defaultTunnelHost,f,this._nativeWorkbenchEnvironmentService.os.release)}retainOrCreateTunnel(e,n,r,o,i,l,s,u){const d=this.getTunnelFromMap(n,r);if(d)return++d.refcount,d.value;if(E(e))return this.createWithProvider(e,n,r,i,l,s,u);{this.logService.trace(`ForwardedPorts: (TunnelService) Creating tunnel without provider ${n}:${r} on local port ${i}.`);const p=this._createSharedProcessTunnel(e,n,r,o,i,l);return this.logService.trace("ForwardedPorts: (TunnelService) Tunnel created without provider."),this.addTunnelToMap(n,r,p),p}}async _createSharedProcessTunnel(e,n,r,o,i,l){const{id:s}=await this._sharedProcessTunnelService.createTunnel();this._activeSharedProcessTunnels.add(s);const u=this._environmentService.remoteAuthority,d=await this._sharedProcessTunnelService.startTunnel(u,s,n,r,o,i,l);return this._instantiationService.createInstance(v,s,e,n,r,d.tunnelLocalPort,d.localAddress,()=>{this._activeSharedProcessTunnels.delete(s)})}canTunnel(e){return super.canTunnel(e)&&!!this._environmentService.remoteAuthority}};h=m([t(0,A),t(1,C),t(2,S),t(3,P),t(4,x),t(5,L),t(6,I)],h),b(W,h,g.Delayed);export{h as TunnelService};
