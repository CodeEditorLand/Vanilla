var h=Object.defineProperty;var K=Object.getOwnPropertyDescriptor;var m=(c,a,i,e)=>{for(var t=e>1?void 0:e?K(a,i):a,n=c.length-1,r;n>=0;n--)(r=c[n])&&(t=(e?r(a,i,t):r(t))||t);return e&&t&&h(a,i,t),t},f=(c,a)=>(i,e)=>a(i,e,c);import{Queue as E}from"../../../../base/common/async.js";import*as u from"../../../../base/common/json.js";import{setProperty as l}from"../../../../base/common/jsonEdit.js";import{Disposable as I}from"../../../../base/common/lifecycle.js";import*as x from"../../../../base/common/objects.js";import{EditOperation as b}from"../../../../editor/common/core/editOperation.js";import{Range as R}from"../../../../editor/common/core/range.js";import{Selection as w}from"../../../../editor/common/core/selection.js";import{ITextModelService as P}from"../../../../editor/common/services/resolverService.js";import{localize as p}from"../../../../nls.js";import{ContextKeyExpr as v}from"../../../../platform/contextkey/common/contextkey.js";import{IFileService as S}from"../../../../platform/files/common/files.js";import{InstantiationType as T,registerSingleton as U}from"../../../../platform/instantiation/common/extensions.js";import{createDecorator as D}from"../../../../platform/instantiation/common/instantiation.js";import{ITextFileService as F}from"../../textfile/common/textfiles.js";import{IUserDataProfileService as M}from"../../userDataProfile/common/userDataProfile.js";const j=D("keybindingEditingService");let g=class extends I{constructor(i,e,t,n){super();this.textModelResolverService=i;this.textFileService=e;this.fileService=t;this.userDataProfileService=n;this.queue=new E}_serviceBrand;queue;addKeybinding(i,e,t){return this.queue.queue(()=>this.doEditKeybinding(i,e,t,!0))}editKeybinding(i,e,t){return this.queue.queue(()=>this.doEditKeybinding(i,e,t,!1))}resetKeybinding(i){return this.queue.queue(()=>this.doResetKeybinding(i))}removeKeybinding(i){return this.queue.queue(()=>this.doRemoveKeybinding(i))}async doEditKeybinding(i,e,t,n){const r=await this.resolveAndValidate(),s=r.object.textEditorModel;if(n)this.updateKeybinding(i,e,t,s,-1);else{const o=u.parse(s.getValue()),d=this.findUserKeybindingEntryIndex(i,o);this.updateKeybinding(i,e,t,s,d),i.isDefault&&i.resolvedKeybinding&&this.removeDefaultKeybinding(i,s)}try{await this.save()}finally{r.dispose()}}async doRemoveKeybinding(i){const e=await this.resolveAndValidate(),t=e.object.textEditorModel;i.isDefault?this.removeDefaultKeybinding(i,t):this.removeUserKeybinding(i,t);try{return await this.save()}finally{e.dispose()}}async doResetKeybinding(i){const e=await this.resolveAndValidate(),t=e.object.textEditorModel;i.isDefault||(this.removeUserKeybinding(i,t),this.removeUnassignedDefaultKeybinding(i,t));try{return await this.save()}finally{e.dispose()}}save(){return this.textFileService.save(this.userDataProfileService.currentProfile.keybindingsResource)}updateKeybinding(i,e,t,n,r){const{tabSize:s,insertSpaces:o}=n.getOptions(),d=n.getEOL();if(r!==-1){this.applyEditsToBuffer(l(n.getValue(),[r,"key"],e,{tabSize:s,insertSpaces:o,eol:d})[0],n);const y=l(n.getValue(),[r,"when"],t,{tabSize:s,insertSpaces:o,eol:d});y.length>0&&this.applyEditsToBuffer(y[0],n)}else this.applyEditsToBuffer(l(n.getValue(),[-1],this.asObject(e,i.command,t,!1),{tabSize:s,insertSpaces:o,eol:d})[0],n)}removeUserKeybinding(i,e){const{tabSize:t,insertSpaces:n}=e.getOptions(),r=e.getEOL(),s=u.parse(e.getValue()),o=this.findUserKeybindingEntryIndex(i,s);o!==-1&&this.applyEditsToBuffer(l(e.getValue(),[o],void 0,{tabSize:t,insertSpaces:n,eol:r})[0],e)}removeDefaultKeybinding(i,e){const{tabSize:t,insertSpaces:n}=e.getOptions(),r=e.getEOL(),s=i.resolvedKeybinding?i.resolvedKeybinding.getUserSettingsLabel():null;if(s){const o=this.asObject(s,i.command,i.when?i.when.serialize():void 0,!0);u.parse(e.getValue()).every(y=>!this.areSame(y,o))&&this.applyEditsToBuffer(l(e.getValue(),[-1],o,{tabSize:t,insertSpaces:n,eol:r})[0],e)}}removeUnassignedDefaultKeybinding(i,e){const{tabSize:t,insertSpaces:n}=e.getOptions(),r=e.getEOL(),s=u.parse(e.getValue()),o=this.findUnassignedDefaultKeybindingEntryIndex(i,s).reverse();for(const d of o)this.applyEditsToBuffer(l(e.getValue(),[d],void 0,{tabSize:t,insertSpaces:n,eol:r})[0],e)}findUserKeybindingEntryIndex(i,e){for(let t=0;t<e.length;t++){const n=e[t];if(n.command===i.command){if(!n.when&&!i.when)return t;if(n.when&&i.when){const r=v.deserialize(n.when);if(r&&r.serialize()===i.when.serialize())return t}}}return-1}findUnassignedDefaultKeybindingEntryIndex(i,e){const t=[];for(let n=0;n<e.length;n++)e[n].command===`-${i.command}`&&t.push(n);return t}asObject(i,e,t,n){const r={key:i};return e&&(r.command=n?`-${e}`:e),t&&(r.when=t),r}areSame(i,e){if(i.command!==e.command||i.key!==e.key)return!1;const t=v.deserialize(i.when),n=v.deserialize(e.when);return!(t&&!n||!t&&n||t&&n&&!t.equals(n)||!x.equals(i.args,e.args))}applyEditsToBuffer(i,e){const t=e.getPositionAt(i.offset),n=e.getPositionAt(i.offset+i.length),r=new R(t.lineNumber,t.column,n.lineNumber,n.column),o=e.getValueInRange(r)?b.replace(r,i.content):b.insert(t,i.content);e.pushEditOperations([new w(t.lineNumber,t.column,t.lineNumber,t.column)],[o],()=>[])}async resolveModelReference(){return await this.fileService.exists(this.userDataProfileService.currentProfile.keybindingsResource)||await this.textFileService.write(this.userDataProfileService.currentProfile.keybindingsResource,this.getEmptyContent(),{encoding:"utf8"}),this.textModelResolverService.createModelReference(this.userDataProfileService.currentProfile.keybindingsResource)}async resolveAndValidate(){if(this.textFileService.isDirty(this.userDataProfileService.currentProfile.keybindingsResource))throw new Error(p("errorKeybindingsFileDirty","Unable to write because the keybindings configuration file has unsaved changes. Please save it first and then try again."));const i=await this.resolveModelReference(),e=i.object.textEditorModel,t=e.getEOL();if(e.getValue()){const n=this.parse(e);if(n.parseErrors.length)throw i.dispose(),new Error(p("parseErrors","Unable to write to the keybindings configuration file. Please open it to correct errors/warnings in the file and try again."));if(n.result){if(!Array.isArray(n.result))throw i.dispose(),new Error(p("errorInvalidConfiguration","Unable to write to the keybindings configuration file. It has an object which is not of type Array. Please open the file to clean up and try again."))}else{const r=t+"[]";this.applyEditsToBuffer({content:r,length:r.length,offset:e.getValue().length},e)}}else{const n=this.getEmptyContent();this.applyEditsToBuffer({content:n,length:n.length,offset:0},e)}return i}parse(i){const e=[];return{result:u.parse(i.getValue(),e,{allowTrailingComma:!0,allowEmptyContent:!0}),parseErrors:e}}getEmptyContent(){return"// "+p("emptyKeybindingsHeader","Place your key bindings in this file to override the defaults")+`
[
]`}};g=m([f(0,P),f(1,F),f(2,S),f(3,M)],g),U(j,g,T.Delayed);export{j as IKeybindingEditingService,g as KeybindingsEditingService};
