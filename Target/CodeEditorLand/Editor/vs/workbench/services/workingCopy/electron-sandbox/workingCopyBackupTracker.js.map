{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/workingCopy/electron-sandbox/workingCopyBackupTracker.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { localize } from '../../../../nls.js';\nimport { IWorkingCopyBackupService } from '../common/workingCopyBackup.js';\nimport { IWorkbenchContribution } from '../../../common/contributions.js';\nimport { IFilesConfigurationService, AutoSaveMode } from '../../filesConfiguration/common/filesConfigurationService.js';\nimport { IWorkingCopyService } from '../common/workingCopyService.js';\nimport { IWorkingCopy, IWorkingCopyIdentifier, WorkingCopyCapabilities } from '../common/workingCopy.js';\nimport { ILifecycleService, ShutdownReason } from '../../lifecycle/common/lifecycle.js';\nimport { ConfirmResult, IFileDialogService, IDialogService, getFileNamesMessage } from '../../../../platform/dialogs/common/dialogs.js';\nimport { WorkbenchState, IWorkspaceContextService } from '../../../../platform/workspace/common/workspace.js';\nimport { isMacintosh } from '../../../../base/common/platform.js';\nimport { HotExitConfiguration } from '../../../../platform/files/common/files.js';\nimport { INativeHostService } from '../../../../platform/native/common/native.js';\nimport { WorkingCopyBackupTracker } from '../common/workingCopyBackupTracker.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { IEditorService } from '../../editor/common/editorService.js';\nimport { SaveReason } from '../../../common/editor.js';\nimport { IEnvironmentService } from '../../../../platform/environment/common/environment.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { IProgressService, ProgressLocation } from '../../../../platform/progress/common/progress.js';\nimport { Promises, raceCancellation } from '../../../../base/common/async.js';\nimport { IWorkingCopyEditorService } from '../common/workingCopyEditorService.js';\nimport { IEditorGroupsService } from '../../editor/common/editorGroupsService.js';\n\nexport class NativeWorkingCopyBackupTracker extends WorkingCopyBackupTracker implements IWorkbenchContribution {\n\n\tstatic readonly ID = 'workbench.contrib.nativeWorkingCopyBackupTracker';\n\n\tconstructor(\n\t\t@IWorkingCopyBackupService workingCopyBackupService: IWorkingCopyBackupService,\n\t\t@IFilesConfigurationService filesConfigurationService: IFilesConfigurationService,\n\t\t@IWorkingCopyService workingCopyService: IWorkingCopyService,\n\t\t@ILifecycleService lifecycleService: ILifecycleService,\n\t\t@IFileDialogService private readonly fileDialogService: IFileDialogService,\n\t\t@IDialogService private readonly dialogService: IDialogService,\n\t\t@IWorkspaceContextService private readonly contextService: IWorkspaceContextService,\n\t\t@INativeHostService private readonly nativeHostService: INativeHostService,\n\t\t@ILogService logService: ILogService,\n\t\t@IEnvironmentService private readonly environmentService: IEnvironmentService,\n\t\t@IProgressService private readonly progressService: IProgressService,\n\t\t@IWorkingCopyEditorService workingCopyEditorService: IWorkingCopyEditorService,\n\t\t@IEditorService editorService: IEditorService,\n\t\t@IEditorGroupsService editorGroupService: IEditorGroupsService\n\t) {\n\t\tsuper(workingCopyBackupService, workingCopyService, logService, lifecycleService, filesConfigurationService, workingCopyEditorService, editorService, editorGroupService);\n\t}\n\n\tprotected async onFinalBeforeShutdown(reason: ShutdownReason): Promise<boolean> {\n\n\t\t// Important: we are about to shutdown and handle modified working copies\n\t\t// and backups. We do not want any pending backup ops to interfer with\n\t\t// this because there is a risk of a backup being scheduled after we have\n\t\t// acknowledged to shutdown and then might end up with partial backups\n\t\t// written to disk, or even empty backups or deletes after writes.\n\t\t// (https://github.com/microsoft/vscode/issues/138055)\n\n\t\tthis.cancelBackupOperations();\n\n\t\t// For the duration of the shutdown handling, suspend backup operations\n\t\t// and only resume after we have handled backups. Similar to above, we\n\t\t// do not want to trigger backup tracking during our shutdown handling\n\t\t// but we must resume, in case of a veto afterwards.\n\n\t\tconst { resume } = this.suspendBackupOperations();\n\n\t\ttry {\n\n\t\t\t// Modified working copies need treatment on shutdown\n\t\t\tconst modifiedWorkingCopies = this.workingCopyService.modifiedWorkingCopies;\n\t\t\tif (modifiedWorkingCopies.length) {\n\t\t\t\treturn await this.onBeforeShutdownWithModified(reason, modifiedWorkingCopies);\n\t\t\t}\n\n\t\t\t// No modified working copies\n\t\t\telse {\n\t\t\t\treturn await this.onBeforeShutdownWithoutModified();\n\t\t\t}\n\t\t} finally {\n\t\t\tresume();\n\t\t}\n\t}\n\n\tprotected async onBeforeShutdownWithModified(reason: ShutdownReason, modifiedWorkingCopies: readonly IWorkingCopy[]): Promise<boolean> {\n\n\t\t// If auto save is enabled, save all non-untitled working copies\n\t\t// and then check again for modified copies\n\n\t\tconst workingCopiesToAutoSave = modifiedWorkingCopies.filter(wc => !(wc.capabilities & WorkingCopyCapabilities.Untitled) && this.filesConfigurationService.getAutoSaveMode(wc.resource).mode !== AutoSaveMode.OFF);\n\t\tif (workingCopiesToAutoSave.length > 0) {\n\n\t\t\t// Save all modified working copies that can be auto-saved\n\t\t\ttry {\n\t\t\t\tawait this.doSaveAllBeforeShutdown(workingCopiesToAutoSave, SaveReason.AUTO);\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.error(`[backup tracker] error saving modified working copies: ${error}`); // guard against misbehaving saves, we handle remaining modified below\n\t\t\t}\n\n\t\t\t// If we still have modified working copies, we either have untitled ones or working copies that cannot be saved\n\t\t\tconst remainingModifiedWorkingCopies = this.workingCopyService.modifiedWorkingCopies;\n\t\t\tif (remainingModifiedWorkingCopies.length) {\n\t\t\t\treturn this.handleModifiedBeforeShutdown(remainingModifiedWorkingCopies, reason);\n\t\t\t}\n\n\t\t\treturn this.noVeto([...modifiedWorkingCopies]); // no veto (modified auto-saved)\n\t\t}\n\n\t\t// Auto save is not enabled\n\t\treturn this.handleModifiedBeforeShutdown(modifiedWorkingCopies, reason);\n\t}\n\n\tprivate async handleModifiedBeforeShutdown(modifiedWorkingCopies: readonly IWorkingCopy[], reason: ShutdownReason): Promise<boolean> {\n\n\t\t// Trigger backup if configured and enabled for shutdown reason\n\t\tlet backups: IWorkingCopy[] = [];\n\t\tlet backupError: Error | undefined = undefined;\n\t\tconst modifiedWorkingCopiesToBackup = await this.shouldBackupBeforeShutdown(reason, modifiedWorkingCopies);\n\t\tif (modifiedWorkingCopiesToBackup.length > 0) {\n\t\t\ttry {\n\t\t\t\tconst backupResult = await this.backupBeforeShutdown(modifiedWorkingCopiesToBackup);\n\t\t\t\tbackups = backupResult.backups;\n\t\t\t\tbackupError = backupResult.error;\n\n\t\t\t\tif (backups.length === modifiedWorkingCopies.length) {\n\t\t\t\t\treturn false; // no veto (backup was successful for all working copies)\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tbackupError = error;\n\t\t\t}\n\t\t}\n\n\t\tconst remainingModifiedWorkingCopies = modifiedWorkingCopies.filter(workingCopy => !backups.includes(workingCopy));\n\n\t\t// We ran a backup but received an error that we show to the user\n\t\tif (backupError) {\n\t\t\tif (this.environmentService.isExtensionDevelopment) {\n\t\t\t\tthis.logService.error(`[backup tracker] error creating backups: ${backupError}`);\n\n\t\t\t\treturn false; // do not block shutdown during extension development (https://github.com/microsoft/vscode/issues/115028)\n\t\t\t}\n\n\t\t\treturn this.showErrorDialog(localize('backupTrackerBackupFailed', \"The following editors with unsaved changes could not be saved to the backup location.\"), remainingModifiedWorkingCopies, backupError, reason);\n\t\t}\n\n\t\t// Since a backup did not happen, we have to confirm for\n\t\t// the working copies that did not successfully backup\n\n\t\ttry {\n\t\t\treturn await this.confirmBeforeShutdown(remainingModifiedWorkingCopies);\n\t\t} catch (error) {\n\t\t\tif (this.environmentService.isExtensionDevelopment) {\n\t\t\t\tthis.logService.error(`[backup tracker] error saving or reverting modified working copies: ${error}`);\n\n\t\t\t\treturn false; // do not block shutdown during extension development (https://github.com/microsoft/vscode/issues/115028)\n\t\t\t}\n\n\t\t\treturn this.showErrorDialog(localize('backupTrackerConfirmFailed', \"The following editors with unsaved changes could not be saved or reverted.\"), remainingModifiedWorkingCopies, error, reason);\n\t\t}\n\t}\n\n\tprivate async shouldBackupBeforeShutdown(reason: ShutdownReason, modifiedWorkingCopies: readonly IWorkingCopy[]): Promise<readonly IWorkingCopy[]> {\n\t\tif (!this.filesConfigurationService.isHotExitEnabled) {\n\t\t\treturn []; // never backup when hot exit is disabled via settings\n\t\t}\n\n\t\tif (this.environmentService.isExtensionDevelopment) {\n\t\t\treturn modifiedWorkingCopies; // always backup closing extension development window without asking to speed up debugging\n\t\t}\n\n\t\tswitch (reason) {\n\n\t\t\t// Window Close\n\t\t\tcase ShutdownReason.CLOSE:\n\t\t\t\tif (this.contextService.getWorkbenchState() !== WorkbenchState.EMPTY && this.filesConfigurationService.hotExitConfiguration === HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE) {\n\t\t\t\t\treturn modifiedWorkingCopies; // backup if a workspace/folder is open and onExitAndWindowClose is configured\n\t\t\t\t}\n\n\t\t\t\tif (isMacintosh || await this.nativeHostService.getWindowCount() > 1) {\n\t\t\t\t\tif (this.contextService.getWorkbenchState() !== WorkbenchState.EMPTY) {\n\t\t\t\t\t\treturn modifiedWorkingCopies.filter(modifiedWorkingCopy => modifiedWorkingCopy.capabilities & WorkingCopyCapabilities.Scratchpad); // backup scratchpads automatically to avoid user confirmation\n\t\t\t\t\t}\n\n\t\t\t\t\treturn []; // do not backup if a window is closed that does not cause quitting of the application\n\t\t\t\t}\n\n\t\t\t\treturn modifiedWorkingCopies; // backup if last window is closed on win/linux where the application quits right after\n\n\t\t\t// Application Quit\n\t\t\tcase ShutdownReason.QUIT:\n\t\t\t\treturn modifiedWorkingCopies; // backup because next start we restore all backups\n\n\t\t\t// Window Reload\n\t\t\tcase ShutdownReason.RELOAD:\n\t\t\t\treturn modifiedWorkingCopies; // backup because after window reload, backups restore\n\n\t\t\t// Workspace Change\n\t\t\tcase ShutdownReason.LOAD:\n\t\t\t\tif (this.contextService.getWorkbenchState() !== WorkbenchState.EMPTY) {\n\t\t\t\t\tif (this.filesConfigurationService.hotExitConfiguration === HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE) {\n\t\t\t\t\t\treturn modifiedWorkingCopies; // backup if a workspace/folder is open and onExitAndWindowClose is configured\n\t\t\t\t\t}\n\n\t\t\t\t\treturn modifiedWorkingCopies.filter(modifiedWorkingCopy => modifiedWorkingCopy.capabilities & WorkingCopyCapabilities.Scratchpad); // backup scratchpads automatically to avoid user confirmation\n\t\t\t\t}\n\n\t\t\t\treturn []; // do not backup because we are switching contexts with no workspace/folder open\n\t\t}\n\t}\n\n\tprivate async showErrorDialog(message: string, workingCopies: readonly IWorkingCopy[], error: Error, reason: ShutdownReason): Promise<boolean> {\n\t\tthis.logService.error(`[backup tracker] ${message}: ${error}`);\n\n\t\tconst modifiedWorkingCopies = workingCopies.filter(workingCopy => workingCopy.isModified());\n\n\t\tconst advice = localize('backupErrorDetails', \"Try saving or reverting the editors with unsaved changes first and then try again.\");\n\t\tconst detail = modifiedWorkingCopies.length\n\t\t\t? `${getFileNamesMessage(modifiedWorkingCopies.map(x => x.name))}\\n${advice}`\n\t\t\t: advice;\n\n\t\tconst { result } = await this.dialogService.prompt({\n\t\t\ttype: 'error',\n\t\t\tmessage,\n\t\t\tdetail,\n\t\t\tbuttons: [\n\t\t\t\t{\n\t\t\t\t\tlabel: localize({ key: 'ok', comment: ['&& denotes a mnemonic'] }, \"&&OK\"),\n\t\t\t\t\trun: () => true // veto\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tlabel: this.toForceShutdownLabel(reason),\n\t\t\t\t\trun: () => false // no veto\n\t\t\t\t}\n\t\t\t],\n\t\t});\n\n\t\treturn result ?? true;\n\t}\n\n\tprivate toForceShutdownLabel(reason: ShutdownReason): string {\n\t\tswitch (reason) {\n\t\t\tcase ShutdownReason.CLOSE:\n\t\t\tcase ShutdownReason.LOAD:\n\t\t\t\treturn localize('shutdownForceClose', \"Close Anyway\");\n\t\t\tcase ShutdownReason.QUIT:\n\t\t\t\treturn localize('shutdownForceQuit', \"Quit Anyway\");\n\t\t\tcase ShutdownReason.RELOAD:\n\t\t\t\treturn localize('shutdownForceReload', \"Reload Anyway\");\n\t\t}\n\t}\n\n\tprivate async backupBeforeShutdown(modifiedWorkingCopies: readonly IWorkingCopy[]): Promise<{ backups: IWorkingCopy[]; error?: Error }> {\n\t\tconst backups: IWorkingCopy[] = [];\n\t\tlet error: Error | undefined = undefined;\n\n\t\tawait this.withProgressAndCancellation(async token => {\n\n\t\t\t// Perform a backup of all modified working copies unless a backup already exists\n\t\t\ttry {\n\t\t\t\tawait Promises.settled(modifiedWorkingCopies.map(async workingCopy => {\n\n\t\t\t\t\t// Backup exists\n\t\t\t\t\tconst contentVersion = this.getContentVersion(workingCopy);\n\t\t\t\t\tif (this.workingCopyBackupService.hasBackupSync(workingCopy, contentVersion)) {\n\t\t\t\t\t\tbackups.push(workingCopy);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Backup does not exist\n\t\t\t\t\telse {\n\t\t\t\t\t\tconst backup = await workingCopy.backup(token);\n\t\t\t\t\t\tif (token.isCancellationRequested) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tawait this.workingCopyBackupService.backup(workingCopy, backup.content, contentVersion, backup.meta, token);\n\t\t\t\t\t\tif (token.isCancellationRequested) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbackups.push(workingCopy);\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t} catch (backupError) {\n\t\t\t\terror = backupError;\n\t\t\t}\n\t\t},\n\t\t\tlocalize('backupBeforeShutdownMessage', \"Backing up editors with unsaved changes is taking a bit longer...\"),\n\t\t\tlocalize('backupBeforeShutdownDetail', \"Click 'Cancel' to stop waiting and to save or revert editors with unsaved changes.\")\n\t\t);\n\n\t\treturn { backups, error };\n\t}\n\n\tprivate async confirmBeforeShutdown(modifiedWorkingCopies: IWorkingCopy[]): Promise<boolean> {\n\n\t\t// Save\n\t\tconst confirm = await this.fileDialogService.showSaveConfirm(modifiedWorkingCopies.map(workingCopy => workingCopy.name));\n\t\tif (confirm === ConfirmResult.SAVE) {\n\t\t\tconst modifiedCountBeforeSave = this.workingCopyService.modifiedCount;\n\n\t\t\ttry {\n\t\t\t\tawait this.doSaveAllBeforeShutdown(modifiedWorkingCopies, SaveReason.EXPLICIT);\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.error(`[backup tracker] error saving modified working copies: ${error}`); // guard against misbehaving saves, we handle remaining modified below\n\t\t\t}\n\n\t\t\tconst savedWorkingCopies = modifiedCountBeforeSave - this.workingCopyService.modifiedCount;\n\t\t\tif (savedWorkingCopies < modifiedWorkingCopies.length) {\n\t\t\t\treturn true; // veto (save failed or was canceled)\n\t\t\t}\n\n\t\t\treturn this.noVeto(modifiedWorkingCopies); // no veto (modified saved)\n\t\t}\n\n\t\t// Don't Save\n\t\telse if (confirm === ConfirmResult.DONT_SAVE) {\n\t\t\ttry {\n\t\t\t\tawait this.doRevertAllBeforeShutdown(modifiedWorkingCopies);\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.error(`[backup tracker] error reverting modified working copies: ${error}`); // do not block the shutdown on errors from revert\n\t\t\t}\n\n\t\t\treturn this.noVeto(modifiedWorkingCopies); // no veto (modified reverted)\n\t\t}\n\n\t\t// Cancel\n\t\treturn true; // veto (user canceled)\n\t}\n\n\tprivate doSaveAllBeforeShutdown(workingCopies: IWorkingCopy[], reason: SaveReason): Promise<void> {\n\t\treturn this.withProgressAndCancellation(async () => {\n\n\t\t\t// Skip save participants on shutdown for performance reasons\n\t\t\tconst saveOptions = { skipSaveParticipants: true, reason };\n\n\t\t\t// First save through the editor service if we save all to benefit\n\t\t\t// from some extras like switching to untitled modified editors before saving.\n\t\t\tlet result: boolean | undefined = undefined;\n\t\t\tif (workingCopies.length === this.workingCopyService.modifiedCount) {\n\t\t\t\tresult = (await this.editorService.saveAll({\n\t\t\t\t\tincludeUntitled: { includeScratchpad: true },\n\t\t\t\t\t...saveOptions\n\t\t\t\t})).success;\n\t\t\t}\n\n\t\t\t// If we still have modified working copies, save those directly\n\t\t\t// unless the save was not successful (e.g. cancelled)\n\t\t\tif (result !== false) {\n\t\t\t\tawait Promises.settled(workingCopies.map(workingCopy => workingCopy.isModified() ? workingCopy.save(saveOptions) : Promise.resolve(true)));\n\t\t\t}\n\t\t},\n\t\t\tlocalize('saveBeforeShutdown', \"Saving editors with unsaved changes is taking a bit longer...\"),\n\t\t\tundefined,\n\t\t\t// Do not pick `Dialog` as location for reporting progress if it is likely\n\t\t\t// that the save operation will itself open a dialog for asking for the\n\t\t\t// location to save to for untitled or scratchpad working copies.\n\t\t\t// https://github.com/microsoft/vscode-internalbacklog/issues/4943\n\t\t\tworkingCopies.some(workingCopy => workingCopy.capabilities & WorkingCopyCapabilities.Untitled || workingCopy.capabilities & WorkingCopyCapabilities.Scratchpad) ? ProgressLocation.Window : ProgressLocation.Dialog);\n\t}\n\n\tprivate doRevertAllBeforeShutdown(modifiedWorkingCopies: IWorkingCopy[]): Promise<void> {\n\t\treturn this.withProgressAndCancellation(async () => {\n\n\t\t\t// Soft revert is good enough on shutdown\n\t\t\tconst revertOptions = { soft: true };\n\n\t\t\t// First revert through the editor service if we revert all\n\t\t\tif (modifiedWorkingCopies.length === this.workingCopyService.modifiedCount) {\n\t\t\t\tawait this.editorService.revertAll(revertOptions);\n\t\t\t}\n\n\t\t\t// If we still have modified working copies, revert those directly\n\t\t\tawait Promises.settled(modifiedWorkingCopies.map(workingCopy => workingCopy.isModified() ? workingCopy.revert(revertOptions) : Promise.resolve()));\n\t\t}, localize('revertBeforeShutdown', \"Reverting editors with unsaved changes is taking a bit longer...\"));\n\t}\n\n\tprivate onBeforeShutdownWithoutModified(): Promise<boolean> {\n\n\t\t// We are about to shutdown without modified editors\n\t\t// and will discard any backups that are still\n\t\t// around that have not been handled depending\n\t\t// on the window state.\n\t\t//\n\t\t// Empty window: discard even unrestored backups to\n\t\t// prevent empty windows from restoring that cannot\n\t\t// be closed (workaround for not having implemented\n\t\t// https://github.com/microsoft/vscode/issues/127163\n\t\t// and a fix for what users have reported in issue\n\t\t// https://github.com/microsoft/vscode/issues/126725)\n\t\t//\n\t\t// Workspace/Folder window: do not discard unrestored\n\t\t// backups to give a chance to restore them in the\n\t\t// future. Since we do not restore workspace/folder\n\t\t// windows with backups, this is fine.\n\n\t\treturn this.noVeto({ except: this.contextService.getWorkbenchState() === WorkbenchState.EMPTY ? [] : Array.from(this.unrestoredBackups) });\n\t}\n\n\tprivate noVeto(backupsToDiscard: IWorkingCopyIdentifier[]): Promise<boolean>;\n\tprivate noVeto(backupsToKeep: { except: IWorkingCopyIdentifier[] }): Promise<boolean>;\n\tprivate async noVeto(arg1: IWorkingCopyIdentifier[] | { except: IWorkingCopyIdentifier[] }): Promise<boolean> {\n\n\t\t// Discard backups from working copies the\n\t\t// user either saved or reverted\n\n\t\tawait this.discardBackupsBeforeShutdown(arg1);\n\n\t\treturn false; // no veto (no modified)\n\t}\n\n\tprivate discardBackupsBeforeShutdown(backupsToDiscard: IWorkingCopyIdentifier[]): Promise<void>;\n\tprivate discardBackupsBeforeShutdown(backupsToKeep: { except: IWorkingCopyIdentifier[] }): Promise<void>;\n\tprivate discardBackupsBeforeShutdown(backupsToDiscardOrKeep: IWorkingCopyIdentifier[] | { except: IWorkingCopyIdentifier[] }): Promise<void>;\n\tprivate async discardBackupsBeforeShutdown(arg1: IWorkingCopyIdentifier[] | { except: IWorkingCopyIdentifier[] }): Promise<void> {\n\n\t\t// We never discard any backups before we are ready\n\t\t// and have resolved all backups that exist. This\n\t\t// is important to not loose backups that have not\n\t\t// been handled.\n\n\t\tif (!this.isReady) {\n\t\t\treturn;\n\t\t}\n\n\t\tawait this.withProgressAndCancellation(async () => {\n\n\t\t\t// When we shutdown either with no modified working copies left\n\t\t\t// or with some handled, we start to discard these backups\n\t\t\t// to free them up. This helps to get rid of stale backups\n\t\t\t// as reported in https://github.com/microsoft/vscode/issues/92962\n\t\t\t//\n\t\t\t// However, we never want to discard backups that we know\n\t\t\t// were not restored in the session.\n\n\t\t\ttry {\n\t\t\t\tif (Array.isArray(arg1)) {\n\t\t\t\t\tawait Promises.settled(arg1.map(workingCopy => this.workingCopyBackupService.discardBackup(workingCopy)));\n\t\t\t\t} else {\n\t\t\t\t\tawait this.workingCopyBackupService.discardBackups(arg1);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.error(`[backup tracker] error discarding backups: ${error}`);\n\t\t\t}\n\t\t}, localize('discardBackupsBeforeShutdown', \"Discarding backups is taking a bit longer...\"));\n\t}\n\n\tprivate withProgressAndCancellation(promiseFactory: (token: CancellationToken) => Promise<void>, title: string, detail?: string, location = ProgressLocation.Dialog): Promise<void> {\n\t\tconst cts = new CancellationTokenSource();\n\n\t\treturn this.progressService.withProgress({\n\t\t\tlocation, \t\t\t// by default use a dialog to prevent the user from making any more changes now (https://github.com/microsoft/vscode/issues/122774)\n\t\t\tcancellable: true, \t// allow to cancel (https://github.com/microsoft/vscode/issues/112278)\n\t\t\tdelay: 800, \t\t// delay so that it only appears when operation takes a long time\n\t\t\ttitle,\n\t\t\tdetail\n\t\t}, () => raceCancellation(promiseFactory(cts.token), cts.token), () => cts.dispose(true));\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
