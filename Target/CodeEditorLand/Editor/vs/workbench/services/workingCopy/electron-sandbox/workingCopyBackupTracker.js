var E=Object.defineProperty;var W=Object.getOwnPropertyDescriptor;var m=(l,u,e,r)=>{for(var i=r>1?void 0:r?W(u,e):u,o=l.length-1,t;o>=0;o--)(t=l[o])&&(i=(r?t(u,e,i):t(i))||i);return r&&i&&E(u,e,i),i},a=(l,u)=>(e,r)=>u(e,r,l);import{Promises as v,raceCancellation as P}from"../../../../base/common/async.js";import{CancellationTokenSource as A}from"../../../../base/common/cancellation.js";import{isMacintosh as D}from"../../../../base/common/platform.js";import{localize as s}from"../../../../nls.js";import{ConfirmResult as w,getFileNamesMessage as T,IDialogService as x,IFileDialogService as M}from"../../../../platform/dialogs/common/dialogs.js";import{IEnvironmentService as O}from"../../../../platform/environment/common/environment.js";import{HotExitConfiguration as y}from"../../../../platform/files/common/files.js";import{ILogService as R}from"../../../../platform/log/common/log.js";import{INativeHostService as L}from"../../../../platform/native/common/native.js";import{IProgressService as F,ProgressLocation as g}from"../../../../platform/progress/common/progress.js";import{IWorkspaceContextService as V,WorkbenchState as f}from"../../../../platform/workspace/common/workspace.js";import"../../../common/contributions.js";import{SaveReason as I}from"../../../common/editor.js";import{IEditorGroupsService as $}from"../../editor/common/editorGroupsService.js";import{IEditorService as _}from"../../editor/common/editorService.js";import{AutoSaveMode as N,IFilesConfigurationService as H}from"../../filesConfiguration/common/filesConfigurationService.js";import{ILifecycleService as U,ShutdownReason as d}from"../../lifecycle/common/lifecycle.js";import{WorkingCopyCapabilities as h}from"../common/workingCopy.js";import{IWorkingCopyBackupService as K}from"../common/workingCopyBackup.js";import{WorkingCopyBackupTracker as Q}from"../common/workingCopyBackupTracker.js";import{IWorkingCopyEditorService as Y}from"../common/workingCopyEditorService.js";import{IWorkingCopyService as X}from"../common/workingCopyService.js";let S=class extends Q{constructor(e,r,i,o,t,c,n,k,p,q,G,b,C,B){super(e,i,p,o,r,b,C,B);this.fileDialogService=t;this.dialogService=c;this.contextService=n;this.nativeHostService=k;this.environmentService=q;this.progressService=G}static ID="workbench.contrib.nativeWorkingCopyBackupTracker";async onFinalBeforeShutdown(e){this.cancelBackupOperations();const{resume:r}=this.suspendBackupOperations();try{const i=this.workingCopyService.modifiedWorkingCopies;return i.length?await this.onBeforeShutdownWithModified(e,i):await this.onBeforeShutdownWithoutModified()}finally{r()}}async onBeforeShutdownWithModified(e,r){const i=r.filter(o=>!(o.capabilities&h.Untitled)&&this.filesConfigurationService.getAutoSaveMode(o.resource).mode!==N.OFF);if(i.length>0){try{await this.doSaveAllBeforeShutdown(i,I.AUTO)}catch(t){this.logService.error(`[backup tracker] error saving modified working copies: ${t}`)}const o=this.workingCopyService.modifiedWorkingCopies;return o.length?this.handleModifiedBeforeShutdown(o,e):this.noVeto([...r])}return this.handleModifiedBeforeShutdown(r,e)}async handleModifiedBeforeShutdown(e,r){let i=[],o;const t=await this.shouldBackupBeforeShutdown(r,e);if(t.length>0)try{const n=await this.backupBeforeShutdown(t);if(i=n.backups,o=n.error,i.length===e.length)return!1}catch(n){o=n}const c=e.filter(n=>!i.includes(n));if(o)return this.environmentService.isExtensionDevelopment?(this.logService.error(`[backup tracker] error creating backups: ${o}`),!1):this.showErrorDialog(s("backupTrackerBackupFailed","The following editors with unsaved changes could not be saved to the backup location."),c,o,r);try{return await this.confirmBeforeShutdown(c)}catch(n){return this.environmentService.isExtensionDevelopment?(this.logService.error(`[backup tracker] error saving or reverting modified working copies: ${n}`),!1):this.showErrorDialog(s("backupTrackerConfirmFailed","The following editors with unsaved changes could not be saved or reverted."),c,n,r)}}async shouldBackupBeforeShutdown(e,r){if(!this.filesConfigurationService.isHotExitEnabled)return[];if(this.environmentService.isExtensionDevelopment)return r;switch(e){case d.CLOSE:return this.contextService.getWorkbenchState()!==f.EMPTY&&this.filesConfigurationService.hotExitConfiguration===y.ON_EXIT_AND_WINDOW_CLOSE?r:D||await this.nativeHostService.getWindowCount()>1?this.contextService.getWorkbenchState()!==f.EMPTY?r.filter(i=>i.capabilities&h.Scratchpad):[]:r;case d.QUIT:return r;case d.RELOAD:return r;case d.LOAD:return this.contextService.getWorkbenchState()!==f.EMPTY?this.filesConfigurationService.hotExitConfiguration===y.ON_EXIT_AND_WINDOW_CLOSE?r:r.filter(i=>i.capabilities&h.Scratchpad):[]}}async showErrorDialog(e,r,i,o){this.logService.error(`[backup tracker] ${e}: ${i}`);const t=r.filter(p=>p.isModified()),c=s("backupErrorDetails","Try saving or reverting the editors with unsaved changes first and then try again."),n=t.length?`${T(t.map(p=>p.name))}
${c}`:c,{result:k}=await this.dialogService.prompt({type:"error",message:e,detail:n,buttons:[{label:s({key:"ok",comment:["&& denotes a mnemonic"]},"&&OK"),run:()=>!0},{label:this.toForceShutdownLabel(o),run:()=>!1}]});return k??!0}toForceShutdownLabel(e){switch(e){case d.CLOSE:case d.LOAD:return s("shutdownForceClose","Close Anyway");case d.QUIT:return s("shutdownForceQuit","Quit Anyway");case d.RELOAD:return s("shutdownForceReload","Reload Anyway")}}async backupBeforeShutdown(e){const r=[];let i;return await this.withProgressAndCancellation(async o=>{try{await v.settled(e.map(async t=>{const c=this.getContentVersion(t);if(this.workingCopyBackupService.hasBackupSync(t,c))r.push(t);else{const n=await t.backup(o);if(o.isCancellationRequested||(await this.workingCopyBackupService.backup(t,n.content,c,n.meta,o),o.isCancellationRequested))return;r.push(t)}}))}catch(t){i=t}},s("backupBeforeShutdownMessage","Backing up editors with unsaved changes is taking a bit longer..."),s("backupBeforeShutdownDetail","Click 'Cancel' to stop waiting and to save or revert editors with unsaved changes.")),{backups:r,error:i}}async confirmBeforeShutdown(e){const r=await this.fileDialogService.showSaveConfirm(e.map(i=>i.name));if(r===w.SAVE){const i=this.workingCopyService.modifiedCount;try{await this.doSaveAllBeforeShutdown(e,I.EXPLICIT)}catch(t){this.logService.error(`[backup tracker] error saving modified working copies: ${t}`)}return i-this.workingCopyService.modifiedCount<e.length?!0:this.noVeto(e)}else if(r===w.DONT_SAVE){try{await this.doRevertAllBeforeShutdown(e)}catch(i){this.logService.error(`[backup tracker] error reverting modified working copies: ${i}`)}return this.noVeto(e)}return!0}doSaveAllBeforeShutdown(e,r){return this.withProgressAndCancellation(async()=>{const i={skipSaveParticipants:!0,reason:r};let o;e.length===this.workingCopyService.modifiedCount&&(o=(await this.editorService.saveAll({includeUntitled:{includeScratchpad:!0},...i})).success),o!==!1&&await v.settled(e.map(t=>t.isModified()?t.save(i):Promise.resolve(!0)))},s("saveBeforeShutdown","Saving editors with unsaved changes is taking a bit longer..."),void 0,e.some(i=>i.capabilities&h.Untitled||i.capabilities&h.Scratchpad)?g.Window:g.Dialog)}doRevertAllBeforeShutdown(e){return this.withProgressAndCancellation(async()=>{const r={soft:!0};e.length===this.workingCopyService.modifiedCount&&await this.editorService.revertAll(r),await v.settled(e.map(i=>i.isModified()?i.revert(r):Promise.resolve()))},s("revertBeforeShutdown","Reverting editors with unsaved changes is taking a bit longer..."))}onBeforeShutdownWithoutModified(){return this.noVeto({except:this.contextService.getWorkbenchState()===f.EMPTY?[]:Array.from(this.unrestoredBackups)})}async noVeto(e){return await this.discardBackupsBeforeShutdown(e),!1}async discardBackupsBeforeShutdown(e){this.isReady&&await this.withProgressAndCancellation(async()=>{try{Array.isArray(e)?await v.settled(e.map(r=>this.workingCopyBackupService.discardBackup(r))):await this.workingCopyBackupService.discardBackups(e)}catch(r){this.logService.error(`[backup tracker] error discarding backups: ${r}`)}},s("discardBackupsBeforeShutdown","Discarding backups is taking a bit longer..."))}withProgressAndCancellation(e,r,i,o=g.Dialog){const t=new A;return this.progressService.withProgress({location:o,cancellable:!0,delay:800,title:r,detail:i},()=>P(e(t.token),t.token),()=>t.dispose(!0))}};S=m([a(0,K),a(1,H),a(2,X),a(3,U),a(4,M),a(5,x),a(6,V),a(7,L),a(8,R),a(9,O),a(10,F),a(11,Y),a(12,_),a(13,$)],S);export{S as NativeWorkingCopyBackupTracker};
