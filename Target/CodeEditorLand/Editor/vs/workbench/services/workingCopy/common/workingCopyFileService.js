var S=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var u=(I,y,e,i)=>{for(var r=i>1?void 0:i?h(y,e):y,n=I.length-1,a;n>=0;n--)(a=I[n])&&(r=(i?a(y,e,r):a(r))||r);return i&&r&&S(y,e,r),r},f=(I,y)=>(e,i)=>y(e,i,I);import{insert as O}from"../../../../base/common/arrays.js";import{Promises as v}from"../../../../base/common/async.js";import{CancellationToken as d}from"../../../../base/common/cancellation.js";import{AsyncEmitter as F}from"../../../../base/common/event.js";import{Disposable as W,toDisposable as m}from"../../../../base/common/lifecycle.js";import{FileOperation as c,IFileService as P}from"../../../../platform/files/common/files.js";import{InstantiationType as w,registerSingleton as R}from"../../../../platform/instantiation/common/extensions.js";import{IInstantiationService as D,createDecorator as T}from"../../../../platform/instantiation/common/instantiation.js";import{IUriIdentityService as U}from"../../../../platform/uriIdentity/common/uriIdentity.js";import{StoredFileWorkingCopySaveParticipant as E}from"./storedFileWorkingCopySaveParticipant.js";import{WorkingCopyFileOperationParticipant as M}from"./workingCopyFileOperationParticipant.js";import{IWorkingCopyService as b}from"./workingCopyService.js";const x=T("workingCopyFileService");let C=class extends W{constructor(e,i,r,n){super();this.fileService=e;this.workingCopyService=i;this.instantiationService=r;this.uriIdentityService=n;this._register(this.registerWorkingCopyProvider(a=>this.workingCopyService.workingCopies.filter(t=>this.fileService.hasProvider(a)?this.uriIdentityService.extUri.isEqualOrParent(t.resource,a):this.uriIdentityService.extUri.isEqual(t.resource,a))))}_onWillRunWorkingCopyFileOperation=this._register(new F);onWillRunWorkingCopyFileOperation=this._onWillRunWorkingCopyFileOperation.event;_onDidFailWorkingCopyFileOperation=this._register(new F);onDidFailWorkingCopyFileOperation=this._onDidFailWorkingCopyFileOperation.event;_onDidRunWorkingCopyFileOperation=this._register(new F);onDidRunWorkingCopyFileOperation=this._onDidRunWorkingCopyFileOperation.event;correlationIds=0;create(e,i,r){return this.doCreateFileOrFolder(e,!0,i,r)}createFolder(e,i,r){return this.doCreateFileOrFolder(e,!1,i,r)}async doCreateFileOrFolder(e,i,r,n){if(e.length===0)return[];if(i){const s=(await v.settled(e.map(l=>this.fileService.canCreateFile(l.resource,{overwrite:l.overwrite})))).find(l=>l instanceof Error);if(s instanceof Error)throw s}const a=e.map(o=>({target:o.resource}));await this.runFileOperationParticipants(a,c.CREATE,n,r);const t={correlationId:this.correlationIds++,operation:c.CREATE,files:a};await this._onWillRunWorkingCopyFileOperation.fireAsync(t,d.None);let p;try{i?p=await v.settled(e.map(o=>this.fileService.createFile(o.resource,o.contents,{overwrite:o.overwrite}))):p=await v.settled(e.map(o=>this.fileService.createFolder(o.resource)))}catch(o){throw await this._onDidFailWorkingCopyFileOperation.fireAsync(t,d.None),o}return await this._onDidRunWorkingCopyFileOperation.fireAsync(t,d.None),p}async move(e,i,r){return this.doMoveOrCopy(e,!0,i,r)}async copy(e,i,r){return this.doMoveOrCopy(e,!1,i,r)}async doMoveOrCopy(e,i,r,n){const a=[];for(const{file:{source:o,target:s},overwrite:l}of e){const g=await(i?this.fileService.canMove(o,s,l):this.fileService.canCopy(o,s,l));if(g instanceof Error)throw g}const t=e.map(o=>o.file);await this.runFileOperationParticipants(t,i?c.MOVE:c.COPY,n,r);const p={correlationId:this.correlationIds++,operation:i?c.MOVE:c.COPY,files:t};await this._onWillRunWorkingCopyFileOperation.fireAsync(p,d.None);try{for(const{file:{source:o,target:s},overwrite:l}of e){if(!this.uriIdentityService.extUri.isEqual(o,s)){const g=i?[...this.getDirty(o),...this.getDirty(s)]:this.getDirty(s);await v.settled(g.map(k=>k.revert({soft:!0})))}i?a.push(await this.fileService.move(o,s,l)):a.push(await this.fileService.copy(o,s,l))}}catch(o){throw await this._onDidFailWorkingCopyFileOperation.fireAsync(p,d.None),o}return await this._onDidRunWorkingCopyFileOperation.fireAsync(p,d.None),a}async delete(e,i,r){for(const t of e){const p=await this.fileService.canDelete(t.resource,{recursive:t.recursive,useTrash:t.useTrash});if(p instanceof Error)throw p}const n=e.map(t=>({target:t.resource}));await this.runFileOperationParticipants(n,c.DELETE,r,i);const a={correlationId:this.correlationIds++,operation:c.DELETE,files:n};await this._onWillRunWorkingCopyFileOperation.fireAsync(a,d.None);for(const t of e){const p=this.getDirty(t.resource);await v.settled(p.map(o=>o.revert({soft:!0})))}try{for(const t of e)await this.fileService.del(t.resource,{recursive:t.recursive,useTrash:t.useTrash})}catch(t){throw await this._onDidFailWorkingCopyFileOperation.fireAsync(a,d.None),t}await this._onDidRunWorkingCopyFileOperation.fireAsync(a,d.None)}fileOperationParticipants=this._register(this.instantiationService.createInstance(M));addFileOperationParticipant(e){return this.fileOperationParticipants.addFileOperationParticipant(e)}runFileOperationParticipants(e,i,r,n){return this.fileOperationParticipants.participate(e,i,r,n)}saveParticipants=this._register(this.instantiationService.createInstance(E));get hasSaveParticipants(){return this.saveParticipants.length>0}addSaveParticipant(e){return this.saveParticipants.addSaveParticipant(e)}runSaveParticipants(e,i,r,n){return this.saveParticipants.participate(e,i,r,n)}workingCopyProviders=[];registerWorkingCopyProvider(e){const i=O(this.workingCopyProviders,e);return m(i)}getDirty(e){const i=new Set;for(const r of this.workingCopyProviders)for(const n of r(e))n.isDirty()&&i.add(n);return Array.from(i)}};C=u([f(0,P),f(1,b),f(2,D),f(3,U)],C),R(x,C,w.Delayed);export{x as IWorkingCopyFileService,C as WorkingCopyFileService};
