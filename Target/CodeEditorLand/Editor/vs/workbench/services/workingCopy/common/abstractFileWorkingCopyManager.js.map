{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/workingCopy/common/abstractFileWorkingCopyManager.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Promises } from \"../../../../base/common/async.js\";\nimport { Emitter, type Event } from \"../../../../base/common/event.js\";\nimport {\n\tDisposable,\n\ttype IDisposable,\n\tdispose,\n} from \"../../../../base/common/lifecycle.js\";\nimport { ResourceMap } from \"../../../../base/common/map.js\";\nimport type { URI } from \"../../../../base/common/uri.js\";\nimport { IFileService } from \"../../../../platform/files/common/files.js\";\nimport { ILogService } from \"../../../../platform/log/common/log.js\";\nimport type {\n\tIFileWorkingCopy,\n\tIFileWorkingCopyModel,\n} from \"./fileWorkingCopy.js\";\nimport { IWorkingCopyBackupService } from \"./workingCopyBackup.js\";\n\nexport interface IBaseFileWorkingCopyManager<\n\tM extends IFileWorkingCopyModel,\n\tW extends IFileWorkingCopy<M>,\n> extends IDisposable {\n\t/**\n\t * An event for when a file working copy was created.\n\t */\n\treadonly onDidCreate: Event<W>;\n\n\t/**\n\t * Access to all known file working copies within the manager.\n\t */\n\treadonly workingCopies: readonly W[];\n\n\t/**\n\t * Returns the file working copy for the provided resource\n\t * or `undefined` if none.\n\t */\n\tget(resource: URI): W | undefined;\n\n\t/**\n\t * Disposes all working copies of the manager and disposes the manager. This\n\t * method is different from `dispose` in that it will unregister any working\n\t * copy from the `IWorkingCopyService`. Since this impact things like backups,\n\t * the method is `async` because it needs to trigger `save` for any dirty\n\t * working copy to preserve the data.\n\t *\n\t * Callers should make sure to e.g. close any editors associated with the\n\t * working copy.\n\t */\n\tdestroy(): Promise<void>;\n}\n\nexport abstract class BaseFileWorkingCopyManager<\n\t\tM extends IFileWorkingCopyModel,\n\t\tW extends IFileWorkingCopy<M>,\n\t>\n\textends Disposable\n\timplements IBaseFileWorkingCopyManager<M, W>\n{\n\tprivate readonly _onDidCreate = this._register(new Emitter<W>());\n\treadonly onDidCreate = this._onDidCreate.event;\n\n\tprivate readonly mapResourceToWorkingCopy = new ResourceMap<W>();\n\tprivate readonly mapResourceToDisposeListener =\n\t\tnew ResourceMap<IDisposable>();\n\n\tconstructor(\n\t\t@IFileService protected readonly fileService: IFileService,\n\t\t@ILogService protected readonly logService: ILogService,\n\t\t@IWorkingCopyBackupService\n\t\tprotected readonly workingCopyBackupService: IWorkingCopyBackupService,\n\t) {\n\t\tsuper();\n\t}\n\n\tprotected has(resource: URI): boolean {\n\t\treturn this.mapResourceToWorkingCopy.has(resource);\n\t}\n\n\tprotected add(resource: URI, workingCopy: W): void {\n\t\tconst knownWorkingCopy = this.get(resource);\n\t\tif (knownWorkingCopy === workingCopy) {\n\t\t\treturn; // already cached\n\t\t}\n\n\t\t// Add to our working copy map\n\t\tthis.mapResourceToWorkingCopy.set(resource, workingCopy);\n\n\t\t// Update our dispose listener to remove it on dispose\n\t\tthis.mapResourceToDisposeListener.get(resource)?.dispose();\n\t\tthis.mapResourceToDisposeListener.set(\n\t\t\tresource,\n\t\t\tworkingCopy.onWillDispose(() => this.remove(resource)),\n\t\t);\n\n\t\t// Signal creation event\n\t\tthis._onDidCreate.fire(workingCopy);\n\t}\n\n\tprotected remove(resource: URI): boolean {\n\t\t// Dispose any existing listener\n\t\tconst disposeListener = this.mapResourceToDisposeListener.get(resource);\n\t\tif (disposeListener) {\n\t\t\tdispose(disposeListener);\n\t\t\tthis.mapResourceToDisposeListener.delete(resource);\n\t\t}\n\n\t\t// Remove from our working copy map\n\t\treturn this.mapResourceToWorkingCopy.delete(resource);\n\t}\n\n\t//#region Get / Get all\n\n\tget workingCopies(): W[] {\n\t\treturn [...this.mapResourceToWorkingCopy.values()];\n\t}\n\n\tget(resource: URI): W | undefined {\n\t\treturn this.mapResourceToWorkingCopy.get(resource);\n\t}\n\n\t//#endregion\n\n\t//#region Lifecycle\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\t// Clear working copy caches\n\t\t//\n\t\t// Note: we are not explicitly disposing the working copies\n\t\t// known to the manager because this can have unwanted side\n\t\t// effects such as backups getting discarded once the working\n\t\t// copy unregisters. We have an explicit `destroy`\n\t\t// for that purpose (https://github.com/microsoft/vscode/pull/123555)\n\t\t//\n\t\tthis.mapResourceToWorkingCopy.clear();\n\n\t\t// Dispose the dispose listeners\n\t\tdispose(this.mapResourceToDisposeListener.values());\n\t\tthis.mapResourceToDisposeListener.clear();\n\t}\n\n\tasync destroy(): Promise<void> {\n\t\t// Make sure all dirty working copies are saved to disk\n\t\ttry {\n\t\t\tawait Promises.settled(\n\t\t\t\tthis.workingCopies.map(async (workingCopy) => {\n\t\t\t\t\tif (workingCopy.isDirty()) {\n\t\t\t\t\t\tawait this.saveWithFallback(workingCopy);\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tthis.logService.error(error);\n\t\t}\n\n\t\t// Dispose all working copies\n\t\tdispose(this.mapResourceToWorkingCopy.values());\n\n\t\t// Finally dispose manager\n\t\tthis.dispose();\n\t}\n\n\tprivate async saveWithFallback(workingCopy: W): Promise<void> {\n\t\t// First try regular save\n\t\tlet saveSuccess = false;\n\t\ttry {\n\t\t\tsaveSuccess = await workingCopy.save();\n\t\t} catch (error) {\n\t\t\t// Ignore\n\t\t}\n\n\t\t// Then fallback to backup if that exists\n\t\tif (!saveSuccess || workingCopy.isDirty()) {\n\t\t\tconst backup =\n\t\t\t\tawait this.workingCopyBackupService.resolve(workingCopy);\n\t\t\tif (backup) {\n\t\t\t\tawait this.fileService.writeFile(\n\t\t\t\t\tworkingCopy.resource,\n\t\t\t\t\tbackup.value,\n\t\t\t\t\t{ unlock: true },\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t//#endregion\n}\n"],
  "mappings": ";;;;;;;;;;;;AAKA,SAAS,gBAAgB;AACzB,SAAS,eAA2B;AACpC;AAAA,EACC;AAAA,EAEA;AAAA,OACM;AACP,SAAS,mBAAmB;AAE5B,SAAS,oBAAoB;AAC7B,SAAS,mBAAmB;AAK5B,SAAS,iCAAiC;AAmCnC,IAAe,6BAAf,cAIE,WAET;AAAA,EAQC,YACkC,aACD,YAEb,0BAClB;AACD,UAAM;AAL2B;AACD;AAEb;AAAA,EAGpB;AAAA,EA5ED,OA6DA;AAAA;AAAA;AAAA,EACkB,eAAe,KAAK,UAAU,IAAI,QAAW,CAAC;AAAA,EACtD,cAAc,KAAK,aAAa;AAAA,EAExB,2BAA2B,IAAI,YAAe;AAAA,EAC9C,+BAChB,IAAI,YAAyB;AAAA,EAWpB,IAAI,UAAwB;AACrC,WAAO,KAAK,yBAAyB,IAAI,QAAQ;AAAA,EAClD;AAAA,EAEU,IAAI,UAAe,aAAsB;AAClD,UAAM,mBAAmB,KAAK,IAAI,QAAQ;AAC1C,QAAI,qBAAqB,aAAa;AACrC;AAAA,IACD;AAGA,SAAK,yBAAyB,IAAI,UAAU,WAAW;AAGvD,SAAK,6BAA6B,IAAI,QAAQ,GAAG,QAAQ;AACzD,SAAK,6BAA6B;AAAA,MACjC;AAAA,MACA,YAAY,cAAc,MAAM,KAAK,OAAO,QAAQ,CAAC;AAAA,IACtD;AAGA,SAAK,aAAa,KAAK,WAAW;AAAA,EACnC;AAAA,EAEU,OAAO,UAAwB;AAExC,UAAM,kBAAkB,KAAK,6BAA6B,IAAI,QAAQ;AACtE,QAAI,iBAAiB;AACpB,cAAQ,eAAe;AACvB,WAAK,6BAA6B,OAAO,QAAQ;AAAA,IAClD;AAGA,WAAO,KAAK,yBAAyB,OAAO,QAAQ;AAAA,EACrD;AAAA;AAAA,EAIA,IAAI,gBAAqB;AACxB,WAAO,CAAC,GAAG,KAAK,yBAAyB,OAAO,CAAC;AAAA,EAClD;AAAA,EAEA,IAAI,UAA8B;AACjC,WAAO,KAAK,yBAAyB,IAAI,QAAQ;AAAA,EAClD;AAAA;AAAA;AAAA,EAMS,UAAgB;AACxB,UAAM,QAAQ;AAUd,SAAK,yBAAyB,MAAM;AAGpC,YAAQ,KAAK,6BAA6B,OAAO,CAAC;AAClD,SAAK,6BAA6B,MAAM;AAAA,EACzC;AAAA,EAEA,MAAM,UAAyB;AAE9B,QAAI;AACH,YAAM,SAAS;AAAA,QACd,KAAK,cAAc,IAAI,OAAO,gBAAgB;AAC7C,cAAI,YAAY,QAAQ,GAAG;AAC1B,kBAAM,KAAK,iBAAiB,WAAW;AAAA,UACxC;AAAA,QACD,CAAC;AAAA,MACF;AAAA,IACD,SAAS,OAAO;AACf,WAAK,WAAW,MAAM,KAAK;AAAA,IAC5B;AAGA,YAAQ,KAAK,yBAAyB,OAAO,CAAC;AAG9C,SAAK,QAAQ;AAAA,EACd;AAAA,EAEA,MAAc,iBAAiB,aAA+B;AAE7D,QAAI,cAAc;AAClB,QAAI;AACH,oBAAc,MAAM,YAAY,KAAK;AAAA,IACtC,SAAS,OAAO;AAAA,IAEhB;AAGA,QAAI,CAAC,eAAe,YAAY,QAAQ,GAAG;AAC1C,YAAM,SACL,MAAM,KAAK,yBAAyB,QAAQ,WAAW;AACxD,UAAI,QAAQ;AACX,cAAM,KAAK,YAAY;AAAA,UACtB,YAAY;AAAA,UACZ,OAAO;AAAA,UACP,EAAE,QAAQ,KAAK;AAAA,QAChB;AAAA,MACD;AAAA,IACD;AAAA,EACD;AAAA;AAGD;AAxIsB,6BAAf;AAAA,EAeJ;AAAA,EACA;AAAA,EACA;AAAA,GAjBmB;",
  "names": []
}
