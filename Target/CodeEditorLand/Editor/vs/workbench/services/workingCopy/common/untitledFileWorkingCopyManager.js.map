{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/workingCopy/common/untitledFileWorkingCopyManager.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DisposableStore, dispose, IDisposable } from '../../../../base/common/lifecycle.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IUntitledFileWorkingCopy, IUntitledFileWorkingCopyInitialContents, IUntitledFileWorkingCopyModel, IUntitledFileWorkingCopyModelFactory, IUntitledFileWorkingCopySaveDelegate, UntitledFileWorkingCopy } from './untitledFileWorkingCopy.js';\nimport { Event, Emitter } from '../../../../base/common/event.js';\nimport { Schemas } from '../../../../base/common/network.js';\nimport { IWorkingCopyService } from './workingCopyService.js';\nimport { ILabelService } from '../../../../platform/label/common/label.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { IWorkingCopyBackupService } from './workingCopyBackup.js';\nimport { IFileService } from '../../../../platform/files/common/files.js';\nimport { BaseFileWorkingCopyManager, IBaseFileWorkingCopyManager } from './abstractFileWorkingCopyManager.js';\nimport { ResourceMap } from '../../../../base/common/map.js';\n\n/**\n * The only one that should be dealing with `IUntitledFileWorkingCopy` and\n * handle all operations that are working copy related, such as save/revert,\n * backup and resolving.\n */\nexport interface IUntitledFileWorkingCopyManager<M extends IUntitledFileWorkingCopyModel> extends IBaseFileWorkingCopyManager<M, IUntitledFileWorkingCopy<M>> {\n\n\t/**\n\t * An event for when a untitled file working copy changed it's dirty state.\n\t */\n\treadonly onDidChangeDirty: Event<IUntitledFileWorkingCopy<M>>;\n\n\t/**\n\t * An event for when a untitled file working copy is about to be disposed.\n\t */\n\treadonly onWillDispose: Event<IUntitledFileWorkingCopy<M>>;\n\n\t/**\n\t * Create a new untitled file working copy with optional initial contents.\n\t *\n\t * Note: Callers must `dispose` the working copy when no longer needed.\n\t */\n\tresolve(options?: INewUntitledFileWorkingCopyOptions): Promise<IUntitledFileWorkingCopy<M>>;\n\n\t/**\n\t * Create a new untitled file working copy with optional initial contents\n\t * and associated resource. The associated resource will be used when\n\t * saving and will not require to ask the user for a file path.\n\t *\n\t * Note: Callers must `dispose` the working copy when no longer needed.\n\t */\n\tresolve(options?: INewUntitledFileWorkingCopyWithAssociatedResourceOptions): Promise<IUntitledFileWorkingCopy<M>>;\n\n\t/**\n\t * Creates a new untitled file working copy with optional initial contents\n\t * with the provided resource or return an existing untitled file working\n\t * copy otherwise.\n\t *\n\t * Note: Callers must `dispose` the working copy when no longer needed.\n\t */\n\tresolve(options?: INewOrExistingUntitledFileWorkingCopyOptions): Promise<IUntitledFileWorkingCopy<M>>;\n}\n\nexport interface INewUntitledFileWorkingCopyOptions {\n\n\t/**\n\t * Initial value of the untitled file working copy\n\t * with support to indicate whether this should turn\n\t * the working copy dirty or not.\n\t */\n\tcontents?: IUntitledFileWorkingCopyInitialContents;\n}\n\nexport interface INewUntitledFileWorkingCopyWithAssociatedResourceOptions extends INewUntitledFileWorkingCopyOptions {\n\n\t/**\n\t * Resource components to associate with the untitled file working copy.\n\t * When saving, the associated components will be used and the user\n\t * is not being asked to provide a file path.\n\t *\n\t * Note: currently it is not possible to specify the `scheme` to use. The\n\t * untitled file working copy will saved to the default local or remote resource.\n\t */\n\tassociatedResource: { authority?: string; path?: string; query?: string; fragment?: string };\n}\n\nexport interface INewOrExistingUntitledFileWorkingCopyOptions extends INewUntitledFileWorkingCopyOptions {\n\n\t/**\n\t * A resource to identify the untitled file working copy\n\t * to create or return if already existing.\n\t *\n\t * Note: the resource will not be used unless the scheme is `untitled`.\n\t */\n\tuntitledResource: URI;\n\n\t/**\n\t * A flag that will prevent the working copy from appearing dirty in the UI\n\t * and not show a confirmation dialog when closed with unsaved content.\n\t */\n\tisScratchpad?: boolean;\n}\n\ntype IInternalUntitledFileWorkingCopyOptions = INewUntitledFileWorkingCopyOptions & INewUntitledFileWorkingCopyWithAssociatedResourceOptions & INewOrExistingUntitledFileWorkingCopyOptions;\n\nexport class UntitledFileWorkingCopyManager<M extends IUntitledFileWorkingCopyModel> extends BaseFileWorkingCopyManager<M, IUntitledFileWorkingCopy<M>> implements IUntitledFileWorkingCopyManager<M> {\n\n\t//#region Events\n\n\tprivate readonly _onDidChangeDirty = this._register(new Emitter<IUntitledFileWorkingCopy<M>>());\n\treadonly onDidChangeDirty = this._onDidChangeDirty.event;\n\n\tprivate readonly _onWillDispose = this._register(new Emitter<IUntitledFileWorkingCopy<M>>());\n\treadonly onWillDispose = this._onWillDispose.event;\n\n\t//#endregion\n\n\tprivate readonly mapResourceToWorkingCopyListeners = new ResourceMap<IDisposable>();\n\n\tconstructor(\n\t\tprivate readonly workingCopyTypeId: string,\n\t\tprivate readonly modelFactory: IUntitledFileWorkingCopyModelFactory<M>,\n\t\tprivate readonly saveDelegate: IUntitledFileWorkingCopySaveDelegate<M>,\n\t\t@IFileService fileService: IFileService,\n\t\t@ILabelService private readonly labelService: ILabelService,\n\t\t@ILogService logService: ILogService,\n\t\t@IWorkingCopyBackupService workingCopyBackupService: IWorkingCopyBackupService,\n\t\t@IWorkingCopyService private readonly workingCopyService: IWorkingCopyService\n\t) {\n\t\tsuper(fileService, logService, workingCopyBackupService);\n\t}\n\n\t//#region Resolve\n\n\tresolve(options?: INewUntitledFileWorkingCopyOptions): Promise<IUntitledFileWorkingCopy<M>>;\n\tresolve(options?: INewUntitledFileWorkingCopyWithAssociatedResourceOptions): Promise<IUntitledFileWorkingCopy<M>>;\n\tresolve(options?: INewOrExistingUntitledFileWorkingCopyOptions): Promise<IUntitledFileWorkingCopy<M>>;\n\tasync resolve(options?: IInternalUntitledFileWorkingCopyOptions): Promise<IUntitledFileWorkingCopy<M>> {\n\t\tconst workingCopy = this.doCreateOrGet(options);\n\t\tawait workingCopy.resolve();\n\n\t\treturn workingCopy;\n\t}\n\n\tprivate doCreateOrGet(options: IInternalUntitledFileWorkingCopyOptions = Object.create(null)): IUntitledFileWorkingCopy<M> {\n\t\tconst massagedOptions = this.massageOptions(options);\n\n\t\t// Return existing instance if asked for it\n\t\tif (massagedOptions.untitledResource) {\n\t\t\tconst existingWorkingCopy = this.get(massagedOptions.untitledResource);\n\t\t\tif (existingWorkingCopy) {\n\t\t\t\treturn existingWorkingCopy;\n\t\t\t}\n\t\t}\n\n\t\t// Create new instance otherwise\n\t\treturn this.doCreate(massagedOptions);\n\t}\n\n\tprivate massageOptions(options: IInternalUntitledFileWorkingCopyOptions): IInternalUntitledFileWorkingCopyOptions {\n\t\tconst massagedOptions: IInternalUntitledFileWorkingCopyOptions = Object.create(null);\n\n\t\t// Handle associated resource\n\t\tif (options.associatedResource) {\n\t\t\tmassagedOptions.untitledResource = URI.from({\n\t\t\t\tscheme: Schemas.untitled,\n\t\t\t\tauthority: options.associatedResource.authority,\n\t\t\t\tfragment: options.associatedResource.fragment,\n\t\t\t\tpath: options.associatedResource.path,\n\t\t\t\tquery: options.associatedResource.query\n\t\t\t});\n\t\t\tmassagedOptions.associatedResource = options.associatedResource;\n\t\t}\n\n\t\t// Handle untitled resource\n\t\telse {\n\t\t\tif (options.untitledResource?.scheme === Schemas.untitled) {\n\t\t\t\tmassagedOptions.untitledResource = options.untitledResource;\n\t\t\t}\n\t\t\tmassagedOptions.isScratchpad = options.isScratchpad;\n\t\t}\n\n\t\t// Take over initial value\n\t\tmassagedOptions.contents = options.contents;\n\n\t\treturn massagedOptions;\n\t}\n\n\tprivate doCreate(options: IInternalUntitledFileWorkingCopyOptions): IUntitledFileWorkingCopy<M> {\n\n\t\t// Create a new untitled resource if none is provided\n\t\tlet untitledResource = options.untitledResource;\n\t\tif (!untitledResource) {\n\t\t\tlet counter = 1;\n\t\t\tdo {\n\t\t\t\tuntitledResource = URI.from({\n\t\t\t\t\tscheme: Schemas.untitled,\n\t\t\t\t\tpath: options.isScratchpad ? `Scratchpad-${counter}` : `Untitled-${counter}`,\n\t\t\t\t\tquery: this.workingCopyTypeId ?\n\t\t\t\t\t\t`typeId=${this.workingCopyTypeId}` : // distinguish untitled resources among others by encoding the `typeId` as query param\n\t\t\t\t\t\tundefined\t\t\t\t\t\t\t // keep untitled resources for text files as they are (when `typeId === ''`)\n\t\t\t\t});\n\t\t\t\tcounter++;\n\t\t\t} while (this.has(untitledResource));\n\t\t}\n\n\t\t// Create new working copy with provided options\n\t\tconst workingCopy = new UntitledFileWorkingCopy(\n\t\t\tthis.workingCopyTypeId,\n\t\t\tuntitledResource,\n\t\t\tthis.labelService.getUriBasenameLabel(untitledResource),\n\t\t\t!!options.associatedResource,\n\t\t\t!!options.isScratchpad,\n\t\t\toptions.contents,\n\t\t\tthis.modelFactory,\n\t\t\tthis.saveDelegate,\n\t\t\tthis.workingCopyService,\n\t\t\tthis.workingCopyBackupService,\n\t\t\tthis.logService\n\t\t);\n\n\t\t// Register\n\t\tthis.registerWorkingCopy(workingCopy);\n\n\t\treturn workingCopy;\n\t}\n\n\tprivate registerWorkingCopy(workingCopy: IUntitledFileWorkingCopy<M>): void {\n\n\t\t// Install working copy listeners\n\t\tconst workingCopyListeners = new DisposableStore();\n\t\tworkingCopyListeners.add(workingCopy.onDidChangeDirty(() => this._onDidChangeDirty.fire(workingCopy)));\n\t\tworkingCopyListeners.add(workingCopy.onWillDispose(() => this._onWillDispose.fire(workingCopy)));\n\n\t\t// Keep for disposal\n\t\tthis.mapResourceToWorkingCopyListeners.set(workingCopy.resource, workingCopyListeners);\n\n\t\t// Add to cache\n\t\tthis.add(workingCopy.resource, workingCopy);\n\n\t\t// If the working copy is dirty right from the beginning,\n\t\t// make sure to emit this as an event\n\t\tif (workingCopy.isDirty()) {\n\t\t\tthis._onDidChangeDirty.fire(workingCopy);\n\t\t}\n\t}\n\n\tprotected override remove(resource: URI): boolean {\n\t\tconst removed = super.remove(resource);\n\n\t\t// Dispose any existing working copy listeners\n\t\tconst workingCopyListener = this.mapResourceToWorkingCopyListeners.get(resource);\n\t\tif (workingCopyListener) {\n\t\t\tdispose(workingCopyListener);\n\t\t\tthis.mapResourceToWorkingCopyListeners.delete(resource);\n\t\t}\n\n\t\treturn removed;\n\t}\n\n\t//#endregion\n\n\t//#region Lifecycle\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\t// Dispose the working copy change listeners\n\t\tdispose(this.mapResourceToWorkingCopyListeners.values());\n\t\tthis.mapResourceToWorkingCopyListeners.clear();\n\t}\n\n\t//#endregion\n}\n"],
  "mappings": "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",
  "names": []
}
