var M=Object.defineProperty;var _=Object.getOwnPropertyDescriptor;var E=(f,p,e,i)=>{for(var r=i>1?void 0:i?_(p,e):p,o=f.length-1,t;o>=0;o--)(t=f[o])&&(r=(i?t(p,e,r):t(r))||r);return i&&r&&M(p,e,r),r},l=(f,p)=>(e,i)=>p(e,i,f);import{localize as n}from"../../../../nls.js";import{Event as R,Emitter as S}from"../../../../base/common/event.js";import{CancellationToken as D,CancellationTokenSource as b}from"../../../../base/common/cancellation.js";import{ETAG_DISABLED as g,FileOperationResult as c,IFileService as P,NotModifiedSinceFileOperationError as A}from"../../../../platform/files/common/files.js";import{SaveReason as d}from"../../../common/editor.js";import{IWorkingCopyService as T}from"./workingCopyService.js";import{WorkingCopyCapabilities as N}from"./workingCopy.js";import{raceCancellation as w,TaskSequentializer as L,timeout as x}from"../../../../base/common/async.js";import{ILogService as B}from"../../../../platform/log/common/log.js";import{assertIsDefined as k}from"../../../../base/common/types.js";import{IWorkingCopyFileService as U}from"./workingCopyFileService.js";import{IFilesConfigurationService as V}from"../../filesConfiguration/common/filesConfigurationService.js";import{IWorkingCopyBackupService as z}from"./workingCopyBackup.js";import{INotificationService as q,Severity as H}from"../../../../platform/notification/common/notification.js";import{hash as $}from"../../../../base/common/hash.js";import{isErrorWithActions as G,toErrorMessage as X}from"../../../../base/common/errorMessage.js";import{toAction as y}from"../../../../base/common/actions.js";import{isWindows as C}from"../../../../base/common/platform.js";import{IWorkingCopyEditorService as j}from"./workingCopyEditorService.js";import{IEditorService as Y}from"../../editor/common/editorService.js";import{IElevatedFileService as K}from"../../files/common/elevatedFileService.js";import{ResourceWorkingCopy as J}from"./resourceWorkingCopy.js";import{SnapshotContext as O}from"./fileWorkingCopy.js";import{IProgressService as Q,ProgressLocation as Z}from"../../../../platform/progress/common/progress.js";var ee=(t=>(t[t.SAVED=0]="SAVED",t[t.DIRTY=1]="DIRTY",t[t.PENDING_SAVE=2]="PENDING_SAVE",t[t.CONFLICT=3]="CONFLICT",t[t.ORPHAN=4]="ORPHAN",t[t.ERROR=5]="ERROR",t))(ee||{});function Ze(f){return!!f.stat}let u=class extends J{constructor(e,i,r,o,t,s,a,h,v,I,m,F,W,ie,te,re){super(i,s);this.typeId=e;this.name=r;this.modelFactory=o;this.externalResolver=t;this.logService=a;this.workingCopyFileService=h;this.filesConfigurationService=v;this.workingCopyBackupService=I;this.notificationService=F;this.workingCopyEditorService=W;this.editorService=ie;this.elevatedFileService=te;this.progressService=re;this._register(m.registerWorkingCopy(this)),this.registerListeners()}capabilities=N.None;_model=void 0;get model(){return this._model}_onDidChangeContent=this._register(new S);onDidChangeContent=this._onDidChangeContent.event;_onDidResolve=this._register(new S);onDidResolve=this._onDidResolve.event;_onDidChangeDirty=this._register(new S);onDidChangeDirty=this._onDidChangeDirty.event;_onDidSaveError=this._register(new S);onDidSaveError=this._onDidSaveError.event;_onDidSave=this._register(new S);onDidSave=this._onDidSave.event;_onDidRevert=this._register(new S);onDidRevert=this._onDidRevert.event;_onDidChangeReadonly=this._register(new S);onDidChangeReadonly=this._onDidChangeReadonly.event;registerListeners(){this._register(this.filesConfigurationService.onDidChangeReadonly(()=>this._onDidChangeReadonly.fire()))}dirty=!1;savedVersionId;isDirty(){return this.dirty}markModified(){this.setDirty(!0)}setDirty(e){if(!this.isResolved())return;const i=this.dirty;this.doSetDirty(e),e!==i&&this._onDidChangeDirty.fire()}doSetDirty(e){const i=this.dirty,r=this.inConflictMode,o=this.inErrorMode,t=this.savedVersionId;return e?this.dirty=!0:(this.dirty=!1,this.inConflictMode=!1,this.inErrorMode=!1,this.isResolved()&&(this.savedVersionId=this.model.versionId)),()=>{this.dirty=i,this.inConflictMode=r,this.inErrorMode=o,this.savedVersionId=t}}lastResolvedFileStat;isResolved(){return!!this.model}async resolve(e){if(this.trace("resolve() - enter"),this.isDisposed()){this.trace("resolve() - exit - without resolving because file working copy is disposed");return}if(!e?.contents&&(this.dirty||this.saveSequentializer.isRunning())){this.trace("resolve() - exit - without resolving because file working copy is dirty or being saved");return}return this.doResolve(e)}async doResolve(e){if(e?.contents)return this.resolveFromBuffer(e.contents);if(!(!this.isResolved()&&await this.resolveFromBackup()))return this.resolveFromFile(e)}async resolveFromBuffer(e){this.trace("resolveFromBuffer()");let i,r,o,t;try{const s=await this.fileService.stat(this.resource);i=s.mtime,r=s.ctime,o=s.size,t=s.etag,this.setOrphaned(!1)}catch(s){i=Date.now(),r=Date.now(),o=0,t=g,this.setOrphaned(s.fileOperationResult===c.FILE_NOT_FOUND)}return this.resolveFromContent({resource:this.resource,name:this.name,mtime:i,ctime:r,size:o,etag:t,value:e,readonly:!1,locked:!1},!0)}async resolveFromBackup(){const e=await this.workingCopyBackupService.resolve(this);return this.isResolved()?(this.trace("resolveFromBackup() - exit - withoutresolving because previously new file working copy got created meanwhile"),!0):e?(await this.doResolveFromBackup(e),!0):!1}async doResolveFromBackup(e){this.trace("doResolveFromBackup()"),await this.resolveFromContent({resource:this.resource,name:this.name,mtime:e.meta?e.meta.mtime:Date.now(),ctime:e.meta?e.meta.ctime:Date.now(),size:e.meta?e.meta.size:0,etag:e.meta?e.meta.etag:g,value:e.value,readonly:!1,locked:!1},!0),e.meta&&e.meta.orphaned&&this.setOrphaned(!0)}async resolveFromFile(e){this.trace("resolveFromFile()");const i=e?.forceReadFromFile;let r;i?r=g:this.lastResolvedFileStat&&(r=this.lastResolvedFileStat.etag);const o=this.versionId;try{const t=await this.fileService.readFileStream(this.resource,{etag:r,limits:e?.limits});if(this.setOrphaned(!1),o!==this.versionId){this.trace("resolveFromFile() - exit - without resolving because file working copy content changed");return}await this.resolveFromContent(t,!1)}catch(t){const s=t.fileOperationResult;if(this.setOrphaned(s===c.FILE_NOT_FOUND),this.isResolved()&&s===c.FILE_NOT_MODIFIED_SINCE){t instanceof A&&this.updateLastResolvedFileStat(t.stat);return}if(this.isResolved()&&s===c.FILE_NOT_FOUND&&!i)return;throw t}}async resolveFromContent(e,i){if(this.trace("resolveFromContent() - enter"),this.isDisposed()){this.trace("resolveFromContent() - exit - because working copy is disposed");return}this.updateLastResolvedFileStat({resource:this.resource,name:e.name,mtime:e.mtime,ctime:e.ctime,size:e.size,etag:e.etag,readonly:e.readonly,locked:e.locked,isFile:!0,isDirectory:!1,isSymbolicLink:!1,children:void 0}),this.isResolved()?await this.doUpdateModel(e.value):await this.doCreateModel(e.value),this.setDirty(!!i),this._onDidResolve.fire()}async doCreateModel(e){this.trace("doCreateModel()"),this._model=this._register(await this.modelFactory.createModel(this.resource,e,D.None)),this.installModelListeners(this._model)}ignoreDirtyOnModelContentChange=!1;async doUpdateModel(e){this.trace("doUpdateModel()"),this.ignoreDirtyOnModelContentChange=!0;try{await this.model?.update(e,D.None)}finally{this.ignoreDirtyOnModelContentChange=!1}}installModelListeners(e){this._register(e.onDidChangeContent(i=>this.onModelContentChanged(e,i.isUndoing||i.isRedoing))),this._register(e.onWillDispose(()=>this.dispose()))}onModelContentChanged(e,i){if(this.trace("onModelContentChanged() - enter"),this.versionId++,this.trace(`onModelContentChanged() - new versionId ${this.versionId}`),i&&(this.lastContentChangeFromUndoRedo=Date.now()),!this.ignoreDirtyOnModelContentChange&&!this.isReadonly())if(e.versionId===this.savedVersionId){this.trace("onModelContentChanged() - model content changed back to last saved version");const r=this.dirty;this.setDirty(!1),r&&this._onDidRevert.fire()}else this.trace("onModelContentChanged() - model content changed and marked as dirty"),this.setDirty(!0);this._onDidChangeContent.fire()}async forceResolveFromFile(){this.isDisposed()||await this.externalResolver({forceReadFromFile:!0})}get backupDelay(){return this.model?.configuration?.backupDelay}async backup(e){let i;this.lastResolvedFileStat&&(i={mtime:this.lastResolvedFileStat.mtime,ctime:this.lastResolvedFileStat.ctime,size:this.lastResolvedFileStat.size,etag:this.lastResolvedFileStat.etag,orphaned:this.isOrphaned()});let r;return this.isResolved()&&(r=await w(this.model.snapshot(O.Backup,e),e)),{meta:i,content:r}}versionId=0;static UNDO_REDO_SAVE_PARTICIPANTS_AUTO_SAVE_THROTTLE_THRESHOLD=500;lastContentChangeFromUndoRedo=void 0;saveSequentializer=new L;ignoreSaveFromSaveParticipants=!1;async save(e=Object.create(null)){return this.isResolved()?this.isReadonly()?(this.trace("save() - ignoring request for readonly resource"),!1):(this.hasState(3)||this.hasState(5))&&(e.reason===d.AUTO||e.reason===d.FOCUS_CHANGE||e.reason===d.WINDOW_CHANGE)?(this.trace("save() - ignoring auto save request for file working copy that is in conflict or error"),!1):(this.trace("save() - enter"),await this.doSave(e),this.trace("save() - exit"),this.hasState(0)):!1}async doSave(e){typeof e.reason!="number"&&(e.reason=d.EXPLICIT);const i=this.versionId;if(this.trace(`doSave(${i}) - enter with versionId ${i}`),this.ignoreSaveFromSaveParticipants){this.trace(`doSave(${i}) - exit - refusing to save() recursively from save participant`);return}if(this.saveSequentializer.isRunning(i))return this.trace(`doSave(${i}) - exit - found a running save for versionId ${i}`),this.saveSequentializer.running;if(!e.force&&!this.dirty){this.trace(`doSave(${i}) - exit - because not dirty and/or versionId is different (this.isDirty: ${this.dirty}, this.versionId: ${this.versionId})`);return}if(this.saveSequentializer.isRunning())return this.trace(`doSave(${i}) - exit - because busy saving`),this.saveSequentializer.cancelRunning(),this.saveSequentializer.queue(()=>this.doSave(e));this.isResolved()&&this.model.pushStackElement();const r=new b;return this.progressService.withProgress({title:n("saveParticipants","Saving '{0}'",this.name),location:Z.Window,cancellable:!0,delay:this.isDirty()?3e3:5e3},o=>this.doSaveSequential(i,e,o,r),()=>{r.cancel()}).finally(()=>{r.dispose()})}doSaveSequential(e,i,r,o){return this.saveSequentializer.run(e,(async()=>{if(this.isResolved()&&!i.skipSaveParticipants&&this.workingCopyFileService.hasSaveParticipants)try{if(i.reason===d.AUTO&&typeof this.lastContentChangeFromUndoRedo=="number"){const a=Date.now()-this.lastContentChangeFromUndoRedo;a<u.UNDO_REDO_SAVE_PARTICIPANTS_AUTO_SAVE_THROTTLE_THRESHOLD&&await x(u.UNDO_REDO_SAVE_PARTICIPANTS_AUTO_SAVE_THROTTLE_THRESHOLD-a)}if(!o.token.isCancellationRequested){this.ignoreSaveFromSaveParticipants=!0;try{await this.workingCopyFileService.runSaveParticipants(this,{reason:i.reason??d.EXPLICIT,savedFrom:i.from},r,o.token)}finally{this.ignoreSaveFromSaveParticipants=!1}}}catch(a){this.logService.error(`[stored file working copy] runSaveParticipants(${e}) - resulted in an error: ${a.toString()}`,this.resource.toString(),this.typeId)}if(o.token.isCancellationRequested||this.isDisposed()||!this.isResolved())return;e=this.versionId,this.inErrorMode=!1,r.report({message:n("saveTextFile","Writing into file...")}),this.trace(`doSave(${e}) - before write()`);const t=k(this.lastResolvedFileStat),s=this;return this.saveSequentializer.run(e,(async()=>{try{const a={mtime:t.mtime,etag:i.ignoreModifiedSince||!this.filesConfigurationService.preventSaveConflicts(t.resource)?g:t.etag,unlock:i.writeUnlock};let h;if(typeof s.model.save=="function")try{h=await s.model.save(a,o.token)}catch(v){if(o.token.isCancellationRequested)return;throw v}else{const v=await w(s.model.snapshot(O.Save,o.token),o.token);if(o.token.isCancellationRequested)return;o.dispose(),i?.writeElevated&&this.elevatedFileService.isSupported(t.resource)?h=await this.elevatedFileService.writeFileElevated(t.resource,k(v),a):h=await this.fileService.writeFile(t.resource,k(v),a)}this.handleSaveSuccess(h,e,i)}catch(a){this.handleSaveError(a,e,i)}})(),()=>o.cancel())})(),()=>o.cancel())}handleSaveSuccess(e,i,r){this.updateLastResolvedFileStat(e),i===this.versionId?(this.trace(`handleSaveSuccess(${i}) - setting dirty to false because versionId did not change`),this.setDirty(!1)):this.trace(`handleSaveSuccess(${i}) - not setting dirty to false because versionId did change meanwhile`),this.setOrphaned(!1),this._onDidSave.fire({reason:r.reason,stat:e,source:r.source})}handleSaveError(e,i,r){if((r.ignoreErrorHandler?this.logService.trace:this.logService.error).apply(this.logService,[`[stored file working copy] handleSaveError(${i}) - exit - resulted in a save error: ${e.toString()}`,this.resource.toString(),this.typeId]),r.ignoreErrorHandler)throw e;this.setDirty(!0),this.inErrorMode=!0,e.fileOperationResult===c.FILE_MODIFIED_SINCE&&(this.inConflictMode=!0),this.doHandleSaveError(e,r),this._onDidSaveError.fire()}doHandleSaveError(e,i){const r=e,o=[];let t;if(r.fileOperationResult===c.FILE_MODIFIED_SINCE)t=n("staleSaveError","Failed to save '{0}': The content of the file is newer. Do you want to overwrite the file with your changes?",this.name),o.push(y({id:"fileWorkingCopy.overwrite",label:n("overwrite","Overwrite"),run:()=>this.save({...i,ignoreModifiedSince:!0,reason:d.EXPLICIT})})),o.push(y({id:"fileWorkingCopy.revert",label:n("revert","Revert"),run:()=>this.revert()}));else{const h=r.fileOperationResult===c.FILE_WRITE_LOCKED,v=h&&r.options?.unlock,I=r.fileOperationResult===c.FILE_PERMISSION_DENIED,m=this.elevatedFileService.isSupported(this.resource);G(e)&&o.push(...e.actions),m&&(I||v)?o.push(y({id:"fileWorkingCopy.saveElevated",label:v?C?n("overwriteElevated","Overwrite as Admin..."):n("overwriteElevatedSudo","Overwrite as Sudo..."):C?n("saveElevated","Retry as Admin..."):n("saveElevatedSudo","Retry as Sudo..."),run:()=>{this.save({...i,writeElevated:!0,writeUnlock:v,reason:d.EXPLICIT})}})):h?o.push(y({id:"fileWorkingCopy.unlock",label:n("overwrite","Overwrite"),run:()=>this.save({...i,writeUnlock:!0,reason:d.EXPLICIT})})):o.push(y({id:"fileWorkingCopy.retry",label:n("retry","Retry"),run:()=>this.save({...i,reason:d.EXPLICIT})})),o.push(y({id:"fileWorkingCopy.saveAs",label:n("saveAs","Save As..."),run:async()=>{const F=this.workingCopyEditorService.findEditor(this);F&&((await this.editorService.save(F,{saveAs:!0,reason:d.EXPLICIT})).success||this.doHandleSaveError(e,i))}})),o.push(y({id:"fileWorkingCopy.revert",label:n("revert","Revert"),run:()=>this.revert()})),h?v&&m?t=C?n("readonlySaveErrorAdmin","Failed to save '{0}': File is read-only. Select 'Overwrite as Admin' to retry as administrator.",this.name):n("readonlySaveErrorSudo","Failed to save '{0}': File is read-only. Select 'Overwrite as Sudo' to retry as superuser.",this.name):t=n("readonlySaveError","Failed to save '{0}': File is read-only. Select 'Overwrite' to attempt to make it writeable.",this.name):m&&I?t=C?n("permissionDeniedSaveError","Failed to save '{0}': Insufficient permissions. Select 'Retry as Admin' to retry as administrator.",this.name):n("permissionDeniedSaveErrorSudo","Failed to save '{0}': Insufficient permissions. Select 'Retry as Sudo' to retry as superuser.",this.name):t=n({key:"genericSaveError",comment:["{0} is the resource that failed to save and {1} the error message"]},"Failed to save '{0}': {1}",this.name,X(e,!1))}const s=this.notificationService.notify({id:`${$(this.resource.toString())}`,severity:H.Error,message:t,actions:{primary:o}}),a=this._register(R.once(R.any(this.onDidSave,this.onDidRevert))(()=>s.close()));this._register(R.once(s.onDidClose)(()=>a.dispose()))}updateLastResolvedFileStat(e){const i=this.isReadonly();this.lastResolvedFileStat?this.lastResolvedFileStat.mtime<=e.mtime?this.lastResolvedFileStat=e:this.lastResolvedFileStat={...this.lastResolvedFileStat,readonly:e.readonly,locked:e.locked}:this.lastResolvedFileStat=e,this.isReadonly()!==i&&this._onDidChangeReadonly.fire()}async revert(e){if(!this.isResolved()||!this.dirty&&!e?.force)return;this.trace("revert()");const i=this.dirty,r=this.doSetDirty(!1);if(!e?.soft)try{await this.forceResolveFromFile()}catch(t){if(t.fileOperationResult!==c.FILE_NOT_FOUND)throw r(),t}this._onDidRevert.fire(),i&&this._onDidChangeDirty.fire()}inConflictMode=!1;inErrorMode=!1;hasState(e){switch(e){case 3:return this.inConflictMode;case 1:return this.dirty;case 5:return this.inErrorMode;case 4:return this.isOrphaned();case 2:return this.saveSequentializer.isRunning();case 0:return!this.dirty}}async joinState(e){return this.saveSequentializer.running}isReadonly(){return this.filesConfigurationService.isReadonly(this.resource,this.lastResolvedFileStat)}trace(e){this.logService.trace(`[stored file working copy] ${e}`,this.resource.toString(),this.typeId)}dispose(){this.trace("dispose()"),this.inConflictMode=!1,this.inErrorMode=!1,this._model=void 0,super.dispose()}};u=E([l(5,P),l(6,B),l(7,U),l(8,V),l(9,z),l(10,T),l(11,q),l(12,j),l(13,Y),l(14,K),l(15,Q)],u);export{u as StoredFileWorkingCopy,ee as StoredFileWorkingCopyState,Ze as isStoredFileWorkingCopySaveEvent};
