{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/workingCopy/common/storedFileWorkingCopyManager.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Promises, ResourceQueue } from \"../../../../base/common/async.js\";\nimport type { VSBufferReadableStream } from \"../../../../base/common/buffer.js\";\nimport { CancellationToken } from \"../../../../base/common/cancellation.js\";\nimport { onUnexpectedError } from \"../../../../base/common/errors.js\";\nimport { Emitter, Event } from \"../../../../base/common/event.js\";\nimport {\n\tDisposableStore,\n\ttype IDisposable,\n\tdispose,\n} from \"../../../../base/common/lifecycle.js\";\nimport { ResourceMap } from \"../../../../base/common/map.js\";\nimport { isWeb } from \"../../../../base/common/platform.js\";\nimport { joinPath } from \"../../../../base/common/resources.js\";\nimport { URI } from \"../../../../base/common/uri.js\";\nimport { localize } from \"../../../../nls.js\";\nimport {\n\tFileChangeType,\n\ttype FileChangesEvent,\n\tFileOperation,\n\tIFileService,\n\ttype IFileSystemProviderCapabilitiesChangeEvent,\n\ttype IFileSystemProviderRegistrationEvent,\n} from \"../../../../platform/files/common/files.js\";\nimport { ILabelService } from \"../../../../platform/label/common/label.js\";\nimport { ILogService } from \"../../../../platform/log/common/log.js\";\nimport { INotificationService } from \"../../../../platform/notification/common/notification.js\";\nimport { IProgressService } from \"../../../../platform/progress/common/progress.js\";\nimport { IUriIdentityService } from \"../../../../platform/uriIdentity/common/uriIdentity.js\";\nimport { IEditorService } from \"../../editor/common/editorService.js\";\nimport { IElevatedFileService } from \"../../files/common/elevatedFileService.js\";\nimport { IFilesConfigurationService } from \"../../filesConfiguration/common/filesConfigurationService.js\";\nimport { ILifecycleService } from \"../../lifecycle/common/lifecycle.js\";\nimport {\n\tBaseFileWorkingCopyManager,\n\ttype IBaseFileWorkingCopyManager,\n} from \"./abstractFileWorkingCopyManager.js\";\nimport { SnapshotContext } from \"./fileWorkingCopy.js\";\nimport {\n\ttype IStoredFileWorkingCopySaveEvent as IBaseStoredFileWorkingCopySaveEvent,\n\ttype IStoredFileWorkingCopy,\n\ttype IStoredFileWorkingCopyModel,\n\ttype IStoredFileWorkingCopyModelFactory,\n\ttype IStoredFileWorkingCopyResolveOptions,\n\tStoredFileWorkingCopy,\n\tStoredFileWorkingCopyState,\n} from \"./storedFileWorkingCopy.js\";\nimport { IWorkingCopyBackupService } from \"./workingCopyBackup.js\";\nimport { IWorkingCopyEditorService } from \"./workingCopyEditorService.js\";\nimport {\n\tIWorkingCopyFileService,\n\ttype WorkingCopyFileEvent,\n} from \"./workingCopyFileService.js\";\nimport { IWorkingCopyService } from \"./workingCopyService.js\";\n\n/**\n * The only one that should be dealing with `IStoredFileWorkingCopy` and handle all\n * operations that are working copy related, such as save/revert, backup\n * and resolving.\n */\nexport interface IStoredFileWorkingCopyManager<\n\tM extends IStoredFileWorkingCopyModel,\n> extends IBaseFileWorkingCopyManager<M, IStoredFileWorkingCopy<M>> {\n\t/**\n\t * An event for when a stored file working copy was resolved.\n\t */\n\treadonly onDidResolve: Event<IStoredFileWorkingCopy<M>>;\n\n\t/**\n\t * An event for when a stored file working copy changed it's dirty state.\n\t */\n\treadonly onDidChangeDirty: Event<IStoredFileWorkingCopy<M>>;\n\n\t/**\n\t * An event for when a stored file working copy changed it's readonly state.\n\t */\n\treadonly onDidChangeReadonly: Event<IStoredFileWorkingCopy<M>>;\n\n\t/**\n\t * An event for when a stored file working copy changed it's orphaned state.\n\t */\n\treadonly onDidChangeOrphaned: Event<IStoredFileWorkingCopy<M>>;\n\n\t/**\n\t * An event for when a stored file working copy failed to save.\n\t */\n\treadonly onDidSaveError: Event<IStoredFileWorkingCopy<M>>;\n\n\t/**\n\t * An event for when a stored file working copy successfully saved.\n\t */\n\treadonly onDidSave: Event<IStoredFileWorkingCopySaveEvent<M>>;\n\n\t/**\n\t * An event for when a stored file working copy was reverted.\n\t */\n\treadonly onDidRevert: Event<IStoredFileWorkingCopy<M>>;\n\n\t/**\n\t * An event for when a stored file working copy is removed from the manager.\n\t */\n\treadonly onDidRemove: Event<URI>;\n\n\t/**\n\t * Allows to resolve a stored file working copy. If the manager already knows\n\t * about a stored file working copy with the same `URI`, it will return that\n\t * existing stored file working copy. There will never be more than one\n\t * stored file working copy per `URI` until the stored file working copy is\n\t * disposed.\n\t *\n\t * Use the `IStoredFileWorkingCopyResolveOptions.reload` option to control the\n\t * behaviour for when a stored file working copy was previously already resolved\n\t * with regards to resolving it again from the underlying file resource\n\t * or not.\n\t *\n\t * Note: Callers must `dispose` the working copy when no longer needed.\n\t *\n\t * @param resource used as unique identifier of the stored file working copy in\n\t * case one is already known for this `URI`.\n\t * @param options\n\t */\n\tresolve(\n\t\tresource: URI,\n\t\toptions?: IStoredFileWorkingCopyManagerResolveOptions,\n\t): Promise<IStoredFileWorkingCopy<M>>;\n\n\t/**\n\t * Waits for the stored file working copy to be ready to be disposed. There may be\n\t * conditions under which the stored file working copy cannot be disposed, e.g. when\n\t * it is dirty. Once the promise is settled, it is safe to dispose.\n\t */\n\tcanDispose(workingCopy: IStoredFileWorkingCopy<M>): true | Promise<true>;\n}\n\nexport interface IStoredFileWorkingCopySaveEvent<\n\tM extends IStoredFileWorkingCopyModel,\n> extends IBaseStoredFileWorkingCopySaveEvent {\n\t/**\n\t * The stored file working copy that was successfully saved.\n\t */\n\treadonly workingCopy: IStoredFileWorkingCopy<M>;\n}\n\nexport interface IStoredFileWorkingCopyManagerResolveOptions\n\textends IStoredFileWorkingCopyResolveOptions {\n\t/**\n\t * If the stored file working copy was already resolved before,\n\t * allows to trigger a reload of it to fetch the latest contents.\n\t */\n\treadonly reload?: {\n\t\t/**\n\t\t * Controls whether the reload happens in the background\n\t\t * or whether `resolve` will await the reload to happen.\n\t\t */\n\t\treadonly async: boolean;\n\n\t\t/**\n\t\t * Controls whether to force reading the contents from the\n\t\t * underlying resource even if the resource did not change.\n\t\t */\n\t\treadonly force?: boolean;\n\t};\n}\n\nexport class StoredFileWorkingCopyManager<M extends IStoredFileWorkingCopyModel>\n\textends BaseFileWorkingCopyManager<M, IStoredFileWorkingCopy<M>>\n\timplements IStoredFileWorkingCopyManager<M>\n{\n\t//#region Events\n\n\tprivate readonly _onDidResolve = this._register(\n\t\tnew Emitter<IStoredFileWorkingCopy<M>>(),\n\t);\n\treadonly onDidResolve = this._onDidResolve.event;\n\n\tprivate readonly _onDidChangeDirty = this._register(\n\t\tnew Emitter<IStoredFileWorkingCopy<M>>(),\n\t);\n\treadonly onDidChangeDirty = this._onDidChangeDirty.event;\n\n\tprivate readonly _onDidChangeReadonly = this._register(\n\t\tnew Emitter<IStoredFileWorkingCopy<M>>(),\n\t);\n\treadonly onDidChangeReadonly = this._onDidChangeReadonly.event;\n\n\tprivate readonly _onDidChangeOrphaned = this._register(\n\t\tnew Emitter<IStoredFileWorkingCopy<M>>(),\n\t);\n\treadonly onDidChangeOrphaned = this._onDidChangeOrphaned.event;\n\n\tprivate readonly _onDidSaveError = this._register(\n\t\tnew Emitter<IStoredFileWorkingCopy<M>>(),\n\t);\n\treadonly onDidSaveError = this._onDidSaveError.event;\n\n\tprivate readonly _onDidSave = this._register(\n\t\tnew Emitter<IStoredFileWorkingCopySaveEvent<M>>(),\n\t);\n\treadonly onDidSave = this._onDidSave.event;\n\n\tprivate readonly _onDidRevert = this._register(\n\t\tnew Emitter<IStoredFileWorkingCopy<M>>(),\n\t);\n\treadonly onDidRevert = this._onDidRevert.event;\n\n\tprivate readonly _onDidRemove = this._register(new Emitter<URI>());\n\treadonly onDidRemove = this._onDidRemove.event;\n\n\t//#endregion\n\n\tprivate readonly mapResourceToWorkingCopyListeners =\n\t\tnew ResourceMap<IDisposable>();\n\tprivate readonly mapResourceToPendingWorkingCopyResolve = new ResourceMap<\n\t\tPromise<void>\n\t>();\n\n\tprivate readonly workingCopyResolveQueue = this._register(\n\t\tnew ResourceQueue(),\n\t);\n\n\tconstructor(\n\t\tprivate readonly workingCopyTypeId: string,\n\t\tprivate readonly modelFactory: IStoredFileWorkingCopyModelFactory<M>,\n\t\t@IFileService fileService: IFileService,\n\t\t@ILifecycleService private readonly lifecycleService: ILifecycleService,\n\t\t@ILabelService private readonly labelService: ILabelService,\n\t\t@ILogService logService: ILogService,\n\t\t@IWorkingCopyFileService private readonly workingCopyFileService: IWorkingCopyFileService,\n\t\t@IWorkingCopyBackupService workingCopyBackupService: IWorkingCopyBackupService,\n\t\t@IUriIdentityService private readonly uriIdentityService: IUriIdentityService,\n\t\t@IFilesConfigurationService private readonly filesConfigurationService: IFilesConfigurationService,\n\t\t@IWorkingCopyService private readonly workingCopyService: IWorkingCopyService,\n\t\t@INotificationService private readonly notificationService: INotificationService,\n\t\t@IWorkingCopyEditorService private readonly workingCopyEditorService: IWorkingCopyEditorService,\n\t\t@IEditorService private readonly editorService: IEditorService,\n\t\t@IElevatedFileService private readonly elevatedFileService: IElevatedFileService,\n\t\t@IProgressService private readonly progressService: IProgressService\n\t) {\n\t\tsuper(fileService, logService, workingCopyBackupService);\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\t// Update working copies from file change events\n\t\tthis._register(\n\t\t\tthis.fileService.onDidFilesChange((e) => this.onDidFilesChange(e)),\n\t\t);\n\n\t\t// File system provider changes\n\t\tthis._register(\n\t\t\tthis.fileService.onDidChangeFileSystemProviderCapabilities((e) =>\n\t\t\t\tthis.onDidChangeFileSystemProviderCapabilities(e),\n\t\t\t),\n\t\t);\n\t\tthis._register(\n\t\t\tthis.fileService.onDidChangeFileSystemProviderRegistrations((e) =>\n\t\t\t\tthis.onDidChangeFileSystemProviderRegistrations(e),\n\t\t\t),\n\t\t);\n\n\t\t// Working copy operations\n\t\tthis._register(\n\t\t\tthis.workingCopyFileService.onWillRunWorkingCopyFileOperation((e) =>\n\t\t\t\tthis.onWillRunWorkingCopyFileOperation(e),\n\t\t\t),\n\t\t);\n\t\tthis._register(\n\t\t\tthis.workingCopyFileService.onDidFailWorkingCopyFileOperation((e) =>\n\t\t\t\tthis.onDidFailWorkingCopyFileOperation(e),\n\t\t\t),\n\t\t);\n\t\tthis._register(\n\t\t\tthis.workingCopyFileService.onDidRunWorkingCopyFileOperation((e) =>\n\t\t\t\tthis.onDidRunWorkingCopyFileOperation(e),\n\t\t\t),\n\t\t);\n\n\t\t// Lifecycle\n\t\tif (isWeb) {\n\t\t\tthis._register(\n\t\t\t\tthis.lifecycleService.onBeforeShutdown((event) =>\n\t\t\t\t\tevent.veto(\n\t\t\t\t\t\tthis.onBeforeShutdownWeb(),\n\t\t\t\t\t\t\"veto.fileWorkingCopyManager\",\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t);\n\t\t} else {\n\t\t\tthis._register(\n\t\t\t\tthis.lifecycleService.onWillShutdown((event) =>\n\t\t\t\t\tevent.join(this.onWillShutdownDesktop(), {\n\t\t\t\t\t\tid: \"join.fileWorkingCopyManager\",\n\t\t\t\t\t\tlabel: localize(\n\t\t\t\t\t\t\t\"join.fileWorkingCopyManager\",\n\t\t\t\t\t\t\t\"Saving working copies\",\n\t\t\t\t\t\t),\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate onBeforeShutdownWeb(): boolean {\n\t\tif (\n\t\t\tthis.workingCopies.some((workingCopy) =>\n\t\t\t\tworkingCopy.hasState(StoredFileWorkingCopyState.PENDING_SAVE),\n\t\t\t)\n\t\t) {\n\t\t\t// stored file working copies are pending to be saved:\n\t\t\t// veto because web does not support long running shutdown\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate async onWillShutdownDesktop(): Promise<void> {\n\t\tlet pendingSavedWorkingCopies: IStoredFileWorkingCopy<M>[];\n\n\t\t// As long as stored file working copies are pending to be saved, we prolong the shutdown\n\t\t// until that has happened to ensure we are not shutting down in the middle of\n\t\t// writing to the working copy (https://github.com/microsoft/vscode/issues/116600).\n\t\twhile (\n\t\t\t(pendingSavedWorkingCopies = this.workingCopies.filter(\n\t\t\t\t(workingCopy) =>\n\t\t\t\t\tworkingCopy.hasState(\n\t\t\t\t\t\tStoredFileWorkingCopyState.PENDING_SAVE,\n\t\t\t\t\t),\n\t\t\t)).length > 0\n\t\t) {\n\t\t\tawait Promises.settled(\n\t\t\t\tpendingSavedWorkingCopies.map((workingCopy) =>\n\t\t\t\t\tworkingCopy.joinState(\n\t\t\t\t\t\tStoredFileWorkingCopyState.PENDING_SAVE,\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\t}\n\n\t//#region Resolve from file or file provider changes\n\n\tprivate onDidChangeFileSystemProviderCapabilities(\n\t\te: IFileSystemProviderCapabilitiesChangeEvent,\n\t): void {\n\t\t// Resolve working copies again for file systems that changed\n\t\t// capabilities to fetch latest metadata (e.g. readonly)\n\t\t// into all working copies.\n\t\tthis.queueWorkingCopyReloads(e.scheme);\n\t}\n\n\tprivate onDidChangeFileSystemProviderRegistrations(\n\t\te: IFileSystemProviderRegistrationEvent,\n\t): void {\n\t\tif (!e.added) {\n\t\t\treturn; // only if added\n\t\t}\n\n\t\t// Resolve working copies again for file systems that registered\n\t\t// to account for capability changes: extensions may unregister\n\t\t// and register the same provider with different capabilities,\n\t\t// so we want to ensure to fetch latest metadata (e.g. readonly)\n\t\t// into all working copies.\n\t\tthis.queueWorkingCopyReloads(e.scheme);\n\t}\n\n\tprivate onDidFilesChange(e: FileChangesEvent): void {\n\t\t// Trigger a resolve for any update or add event that impacts\n\t\t// the working copy. We also consider the added event\n\t\t// because it could be that a file was added and updated\n\t\t// right after.\n\t\tthis.queueWorkingCopyReloads(e);\n\t}\n\n\tprivate queueWorkingCopyReloads(scheme: string): void;\n\tprivate queueWorkingCopyReloads(e: FileChangesEvent): void;\n\tprivate queueWorkingCopyReloads(\n\t\tschemeOrEvent: string | FileChangesEvent,\n\t): void {\n\t\tfor (const workingCopy of this.workingCopies) {\n\t\t\tif (workingCopy.isDirty()) {\n\t\t\t\tcontinue; // never reload dirty working copies\n\t\t\t}\n\n\t\t\tlet resolveWorkingCopy = false;\n\t\t\tif (typeof schemeOrEvent === \"string\") {\n\t\t\t\tresolveWorkingCopy =\n\t\t\t\t\tschemeOrEvent === workingCopy.resource.scheme;\n\t\t\t} else {\n\t\t\t\tresolveWorkingCopy = schemeOrEvent.contains(\n\t\t\t\t\tworkingCopy.resource,\n\t\t\t\t\tFileChangeType.UPDATED,\n\t\t\t\t\tFileChangeType.ADDED,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (resolveWorkingCopy) {\n\t\t\t\tthis.queueWorkingCopyReload(workingCopy);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate queueWorkingCopyReload(\n\t\tworkingCopy: IStoredFileWorkingCopy<M>,\n\t): void {\n\t\t// Resolves a working copy to update (use a queue to prevent accumulation of\n\t\t// resolve when the resolving actually takes long. At most we only want the\n\t\t// queue to have a size of 2 (1 running resolve and 1 queued resolve).\n\t\tconst queueSize = this.workingCopyResolveQueue.queueSize(\n\t\t\tworkingCopy.resource,\n\t\t);\n\t\tif (queueSize <= 1) {\n\t\t\tthis.workingCopyResolveQueue.queueFor(\n\t\t\t\tworkingCopy.resource,\n\t\t\t\tasync () => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait this.reload(workingCopy);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tthis.logService.error(error);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t);\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region Working Copy File Events\n\n\tprivate readonly mapCorrelationIdToWorkingCopiesToRestore = new Map<\n\t\tnumber,\n\t\t{ source: URI; target: URI; snapshot?: VSBufferReadableStream }[]\n\t>();\n\n\tprivate onWillRunWorkingCopyFileOperation(e: WorkingCopyFileEvent): void {\n\t\t// Move / Copy: remember working copies to restore after the operation\n\t\tif (\n\t\t\te.operation === FileOperation.MOVE ||\n\t\t\te.operation === FileOperation.COPY\n\t\t) {\n\t\t\te.waitUntil(\n\t\t\t\t(async () => {\n\t\t\t\t\tconst workingCopiesToRestore: {\n\t\t\t\t\t\tsource: URI;\n\t\t\t\t\t\ttarget: URI;\n\t\t\t\t\t\tsnapshot?: VSBufferReadableStream;\n\t\t\t\t\t}[] = [];\n\n\t\t\t\t\tfor (const { source, target } of e.files) {\n\t\t\t\t\t\tif (source) {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tthis.uriIdentityService.extUri.isEqual(\n\t\t\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tcontinue; // ignore if resources are considered equal\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Find all working copies that related to source (can be many if resource is a folder)\n\t\t\t\t\t\t\tconst sourceWorkingCopies: IStoredFileWorkingCopy<M>[] =\n\t\t\t\t\t\t\t\t[];\n\t\t\t\t\t\t\tfor (const workingCopy of this.workingCopies) {\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tthis.uriIdentityService.extUri.isEqualOrParent(\n\t\t\t\t\t\t\t\t\t\tworkingCopy.resource,\n\t\t\t\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tsourceWorkingCopies.push(workingCopy);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Remember each source working copy to load again after move is done\n\t\t\t\t\t\t\t// with optional content to restore if it was dirty\n\t\t\t\t\t\t\tfor (const sourceWorkingCopy of sourceWorkingCopies) {\n\t\t\t\t\t\t\t\tconst sourceResource =\n\t\t\t\t\t\t\t\t\tsourceWorkingCopy.resource;\n\n\t\t\t\t\t\t\t\t// If the source is the actual working copy, just use target as new resource\n\t\t\t\t\t\t\t\tlet targetResource: URI;\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tthis.uriIdentityService.extUri.isEqual(\n\t\t\t\t\t\t\t\t\t\tsourceResource,\n\t\t\t\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\ttargetResource = target;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Otherwise a parent folder of the source is being moved, so we need\n\t\t\t\t\t\t\t\t// to compute the target resource based on that\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\ttargetResource = joinPath(\n\t\t\t\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\t\t\t\tsourceResource.path.substr(\n\t\t\t\t\t\t\t\t\t\t\tsource.path.length + 1,\n\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tworkingCopiesToRestore.push({\n\t\t\t\t\t\t\t\t\tsource: sourceResource,\n\t\t\t\t\t\t\t\t\ttarget: targetResource,\n\t\t\t\t\t\t\t\t\tsnapshot: sourceWorkingCopy.isDirty()\n\t\t\t\t\t\t\t\t\t\t? await sourceWorkingCopy.model?.snapshot(\n\t\t\t\t\t\t\t\t\t\t\t\tSnapshotContext.Save,\n\t\t\t\t\t\t\t\t\t\t\t\tCancellationToken.None,\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.mapCorrelationIdToWorkingCopiesToRestore.set(\n\t\t\t\t\t\te.correlationId,\n\t\t\t\t\t\tworkingCopiesToRestore,\n\t\t\t\t\t);\n\t\t\t\t})(),\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate onDidFailWorkingCopyFileOperation(e: WorkingCopyFileEvent): void {\n\t\t// Move / Copy: restore dirty flag on working copies to restore that were dirty\n\t\tif (\n\t\t\te.operation === FileOperation.MOVE ||\n\t\t\te.operation === FileOperation.COPY\n\t\t) {\n\t\t\tconst workingCopiesToRestore =\n\t\t\t\tthis.mapCorrelationIdToWorkingCopiesToRestore.get(\n\t\t\t\t\te.correlationId,\n\t\t\t\t);\n\t\t\tif (workingCopiesToRestore) {\n\t\t\t\tthis.mapCorrelationIdToWorkingCopiesToRestore.delete(\n\t\t\t\t\te.correlationId,\n\t\t\t\t);\n\n\t\t\t\tfor (const workingCopy of workingCopiesToRestore) {\n\t\t\t\t\t// Snapshot presence means this working copy used to be modified and so we restore that\n\t\t\t\t\t// flag. we do NOT have to restore the content because the working copy was only soft\n\t\t\t\t\t// reverted and did not loose its original modified contents.\n\n\t\t\t\t\tif (workingCopy.snapshot) {\n\t\t\t\t\t\tthis.get(workingCopy.source)?.markModified();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate onDidRunWorkingCopyFileOperation(e: WorkingCopyFileEvent): void {\n\t\tswitch (e.operation) {\n\t\t\t// Create: Revert existing working copies\n\t\t\tcase FileOperation.CREATE:\n\t\t\t\te.waitUntil(\n\t\t\t\t\t(async () => {\n\t\t\t\t\t\tfor (const { target } of e.files) {\n\t\t\t\t\t\t\tconst workingCopy = this.get(target);\n\t\t\t\t\t\t\tif (workingCopy && !workingCopy.isDisposed()) {\n\t\t\t\t\t\t\t\tawait workingCopy.revert();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t})(),\n\t\t\t\t);\n\t\t\t\tbreak;\n\n\t\t\t// Move/Copy: restore working copies that were loaded before the operation took place\n\t\t\tcase FileOperation.MOVE:\n\t\t\tcase FileOperation.COPY:\n\t\t\t\te.waitUntil(\n\t\t\t\t\t(async () => {\n\t\t\t\t\t\tconst workingCopiesToRestore =\n\t\t\t\t\t\t\tthis.mapCorrelationIdToWorkingCopiesToRestore.get(\n\t\t\t\t\t\t\t\te.correlationId,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\tif (workingCopiesToRestore) {\n\t\t\t\t\t\t\tthis.mapCorrelationIdToWorkingCopiesToRestore.delete(\n\t\t\t\t\t\t\t\te.correlationId,\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tawait Promises.settled(\n\t\t\t\t\t\t\t\tworkingCopiesToRestore.map(\n\t\t\t\t\t\t\t\t\tasync (workingCopyToRestore) => {\n\t\t\t\t\t\t\t\t\t\t// From this moment on, only operate on the canonical resource\n\t\t\t\t\t\t\t\t\t\t// to fix a potential data loss issue:\n\t\t\t\t\t\t\t\t\t\t// https://github.com/microsoft/vscode/issues/211374\n\t\t\t\t\t\t\t\t\t\tconst target =\n\t\t\t\t\t\t\t\t\t\t\tthis.uriIdentityService.asCanonicalUri(\n\t\t\t\t\t\t\t\t\t\t\t\tworkingCopyToRestore.target,\n\t\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\t// Restore the working copy at the target. if we have previous dirty content, we pass it\n\t\t\t\t\t\t\t\t\t\t// over to be used, otherwise we force a reload from disk. this is important\n\t\t\t\t\t\t\t\t\t\t// because we know the file has changed on disk after the move and the working copy might\n\t\t\t\t\t\t\t\t\t\t// have still existed with the previous state. this ensures that the working copy is not\n\t\t\t\t\t\t\t\t\t\t// tracking a stale state.\n\t\t\t\t\t\t\t\t\t\tawait this.resolve(target, {\n\t\t\t\t\t\t\t\t\t\t\treload: { async: false }, // enforce a reload\n\t\t\t\t\t\t\t\t\t\t\tcontents:\n\t\t\t\t\t\t\t\t\t\t\t\tworkingCopyToRestore.snapshot,\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t})(),\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region Reload & Resolve\n\n\tprivate async reload(\n\t\tworkingCopy: IStoredFileWorkingCopy<M>,\n\t): Promise<void> {\n\t\t// Await a pending working copy resolve first before proceeding\n\t\t// to ensure that we never resolve a working copy more than once\n\t\t// in parallel.\n\t\tawait this.joinPendingResolves(workingCopy.resource);\n\n\t\tif (\n\t\t\tworkingCopy.isDirty() ||\n\t\t\tworkingCopy.isDisposed() ||\n\t\t\t!this.has(workingCopy.resource)\n\t\t) {\n\t\t\treturn; // the working copy possibly got dirty or disposed, so return early then\n\t\t}\n\n\t\t// Trigger reload\n\t\tawait this.doResolve(workingCopy, { reload: { async: false } });\n\t}\n\n\tasync resolve(\n\t\tresource: URI,\n\t\toptions?: IStoredFileWorkingCopyManagerResolveOptions,\n\t): Promise<IStoredFileWorkingCopy<M>> {\n\t\t// Await a pending working copy resolve first before proceeding\n\t\t// to ensure that we never resolve a working copy more than once\n\t\t// in parallel.\n\t\tconst pendingResolve = this.joinPendingResolves(resource);\n\t\tif (pendingResolve) {\n\t\t\tawait pendingResolve;\n\t\t}\n\n\t\t// Trigger resolve\n\t\treturn this.doResolve(resource, options);\n\t}\n\n\tprivate async doResolve(\n\t\tresourceOrWorkingCopy: URI | IStoredFileWorkingCopy<M>,\n\t\toptions?: IStoredFileWorkingCopyManagerResolveOptions,\n\t): Promise<IStoredFileWorkingCopy<M>> {\n\t\tlet workingCopy: IStoredFileWorkingCopy<M> | undefined;\n\t\tlet resource: URI;\n\t\tif (URI.isUri(resourceOrWorkingCopy)) {\n\t\t\tresource = resourceOrWorkingCopy;\n\t\t\tworkingCopy = this.get(resource);\n\t\t} else {\n\t\t\tresource = resourceOrWorkingCopy.resource;\n\t\t\tworkingCopy = resourceOrWorkingCopy;\n\t\t}\n\n\t\tlet workingCopyResolve: Promise<void>;\n\t\tlet didCreateWorkingCopy = false;\n\n\t\tconst resolveOptions: IStoredFileWorkingCopyResolveOptions = {\n\t\t\tcontents: options?.contents,\n\t\t\tforceReadFromFile: options?.reload?.force,\n\t\t\tlimits: options?.limits,\n\t\t};\n\n\t\t// Working copy exists\n\t\tif (workingCopy) {\n\t\t\t// Always reload if contents are provided\n\t\t\tif (options?.contents) {\n\t\t\t\tworkingCopyResolve = workingCopy.resolve(resolveOptions);\n\t\t\t}\n\n\t\t\t// Reload async or sync based on options\n\t\t\telse if (options?.reload) {\n\t\t\t\t// Async reload: trigger a reload but return immediately\n\t\t\t\tif (options.reload.async) {\n\t\t\t\t\tworkingCopyResolve = Promise.resolve();\n\t\t\t\t\t(async () => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait workingCopy.resolve(resolveOptions);\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tonUnexpectedError(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t})();\n\t\t\t\t}\n\n\t\t\t\t// Sync reload: do not return until working copy reloaded\n\t\t\t\telse {\n\t\t\t\t\tworkingCopyResolve = workingCopy.resolve(resolveOptions);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Do not reload\n\t\t\telse {\n\t\t\t\tworkingCopyResolve = Promise.resolve();\n\t\t\t}\n\t\t}\n\n\t\t// Stored file working copy does not exist\n\t\telse {\n\t\t\tdidCreateWorkingCopy = true;\n\n\t\t\tworkingCopy = new StoredFileWorkingCopy(\n\t\t\t\tthis.workingCopyTypeId,\n\t\t\t\tresource,\n\t\t\t\tthis.labelService.getUriBasenameLabel(resource),\n\t\t\t\tthis.modelFactory,\n\t\t\t\tasync (options) => {\n\t\t\t\t\tawait this.resolve(resource, {\n\t\t\t\t\t\t...options,\n\t\t\t\t\t\treload: { async: false },\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tthis.fileService,\n\t\t\t\tthis.logService,\n\t\t\t\tthis.workingCopyFileService,\n\t\t\t\tthis.filesConfigurationService,\n\t\t\t\tthis.workingCopyBackupService,\n\t\t\t\tthis.workingCopyService,\n\t\t\t\tthis.notificationService,\n\t\t\t\tthis.workingCopyEditorService,\n\t\t\t\tthis.editorService,\n\t\t\t\tthis.elevatedFileService,\n\t\t\t\tthis.progressService,\n\t\t\t);\n\n\t\t\tworkingCopyResolve = workingCopy.resolve(resolveOptions);\n\n\t\t\tthis.registerWorkingCopy(workingCopy);\n\t\t}\n\n\t\t// Store pending resolve to avoid race conditions\n\t\tthis.mapResourceToPendingWorkingCopyResolve.set(\n\t\t\tresource,\n\t\t\tworkingCopyResolve,\n\t\t);\n\n\t\t// Make known to manager (if not already known)\n\t\tthis.add(resource, workingCopy);\n\n\t\t// Emit some events if we created the working copy\n\t\tif (didCreateWorkingCopy) {\n\t\t\t// If the working copy is dirty right from the beginning,\n\t\t\t// make sure to emit this as an event\n\t\t\tif (workingCopy.isDirty()) {\n\t\t\t\tthis._onDidChangeDirty.fire(workingCopy);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tawait workingCopyResolve;\n\t\t} catch (error) {\n\t\t\t// Automatically dispose the working copy if we created\n\t\t\t// it because we cannot dispose a working copy we do not\n\t\t\t// own (https://github.com/microsoft/vscode/issues/138850)\n\t\t\tif (didCreateWorkingCopy) {\n\t\t\t\tworkingCopy.dispose();\n\t\t\t}\n\n\t\t\tthrow error;\n\t\t} finally {\n\t\t\t// Remove from pending resolves\n\t\t\tthis.mapResourceToPendingWorkingCopyResolve.delete(resource);\n\t\t}\n\n\t\t// Stored file working copy can be dirty if a backup was restored, so we make sure to\n\t\t// have this event delivered if we created the working copy here\n\t\tif (didCreateWorkingCopy && workingCopy.isDirty()) {\n\t\t\tthis._onDidChangeDirty.fire(workingCopy);\n\t\t}\n\n\t\treturn workingCopy;\n\t}\n\n\tprivate joinPendingResolves(resource: URI): Promise<void> | undefined {\n\t\tconst pendingWorkingCopyResolve =\n\t\t\tthis.mapResourceToPendingWorkingCopyResolve.get(resource);\n\t\tif (!pendingWorkingCopyResolve) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn this.doJoinPendingResolves(resource);\n\t}\n\n\tprivate async doJoinPendingResolves(resource: URI): Promise<void> {\n\t\t// While we have pending working copy resolves, ensure\n\t\t// to await the last one finishing before returning.\n\t\t// This prevents a race when multiple clients await\n\t\t// the pending resolve and then all trigger the resolve\n\t\t// at the same time.\n\t\tlet currentWorkingCopyResolve: Promise<void> | undefined;\n\t\twhile (this.mapResourceToPendingWorkingCopyResolve.has(resource)) {\n\t\t\tconst nextPendingWorkingCopyResolve =\n\t\t\t\tthis.mapResourceToPendingWorkingCopyResolve.get(resource);\n\t\t\tif (nextPendingWorkingCopyResolve === currentWorkingCopyResolve) {\n\t\t\t\treturn; // already awaited on - return\n\t\t\t}\n\n\t\t\tcurrentWorkingCopyResolve = nextPendingWorkingCopyResolve;\n\t\t\ttry {\n\t\t\t\tawait nextPendingWorkingCopyResolve;\n\t\t\t} catch (error) {\n\t\t\t\t// ignore any error here, it will bubble to the original requestor\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate registerWorkingCopy(workingCopy: IStoredFileWorkingCopy<M>): void {\n\t\t// Install working copy listeners\n\t\tconst workingCopyListeners = new DisposableStore();\n\t\tworkingCopyListeners.add(\n\t\t\tworkingCopy.onDidResolve(() =>\n\t\t\t\tthis._onDidResolve.fire(workingCopy),\n\t\t\t),\n\t\t);\n\t\tworkingCopyListeners.add(\n\t\t\tworkingCopy.onDidChangeDirty(() =>\n\t\t\t\tthis._onDidChangeDirty.fire(workingCopy),\n\t\t\t),\n\t\t);\n\t\tworkingCopyListeners.add(\n\t\t\tworkingCopy.onDidChangeReadonly(() =>\n\t\t\t\tthis._onDidChangeReadonly.fire(workingCopy),\n\t\t\t),\n\t\t);\n\t\tworkingCopyListeners.add(\n\t\t\tworkingCopy.onDidChangeOrphaned(() =>\n\t\t\t\tthis._onDidChangeOrphaned.fire(workingCopy),\n\t\t\t),\n\t\t);\n\t\tworkingCopyListeners.add(\n\t\t\tworkingCopy.onDidSaveError(() =>\n\t\t\t\tthis._onDidSaveError.fire(workingCopy),\n\t\t\t),\n\t\t);\n\t\tworkingCopyListeners.add(\n\t\t\tworkingCopy.onDidSave((e) =>\n\t\t\t\tthis._onDidSave.fire({ workingCopy, ...e }),\n\t\t\t),\n\t\t);\n\t\tworkingCopyListeners.add(\n\t\t\tworkingCopy.onDidRevert(() => this._onDidRevert.fire(workingCopy)),\n\t\t);\n\n\t\t// Keep for disposal\n\t\tthis.mapResourceToWorkingCopyListeners.set(\n\t\t\tworkingCopy.resource,\n\t\t\tworkingCopyListeners,\n\t\t);\n\t}\n\n\tprotected override remove(resource: URI): boolean {\n\t\tconst removed = super.remove(resource);\n\n\t\t// Dispose any existing working copy listeners\n\t\tconst workingCopyListener =\n\t\t\tthis.mapResourceToWorkingCopyListeners.get(resource);\n\t\tif (workingCopyListener) {\n\t\t\tdispose(workingCopyListener);\n\t\t\tthis.mapResourceToWorkingCopyListeners.delete(resource);\n\t\t}\n\n\t\tif (removed) {\n\t\t\tthis._onDidRemove.fire(resource);\n\t\t}\n\n\t\treturn removed;\n\t}\n\n\t//#endregion\n\n\t//#region Lifecycle\n\n\tcanDispose(workingCopy: IStoredFileWorkingCopy<M>): true | Promise<true> {\n\t\t// Quick return if working copy already disposed or not dirty and not resolving\n\t\tif (\n\t\t\tworkingCopy.isDisposed() ||\n\t\t\t(!this.mapResourceToPendingWorkingCopyResolve.has(\n\t\t\t\tworkingCopy.resource,\n\t\t\t) &&\n\t\t\t\t!workingCopy.isDirty())\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Promise based return in all other cases\n\t\treturn this.doCanDispose(workingCopy);\n\t}\n\n\tprivate async doCanDispose(\n\t\tworkingCopy: IStoredFileWorkingCopy<M>,\n\t): Promise<true> {\n\t\t// Await any pending resolves first before proceeding\n\t\tconst pendingResolve = this.joinPendingResolves(workingCopy.resource);\n\t\tif (pendingResolve) {\n\t\t\tawait pendingResolve;\n\n\t\t\treturn this.canDispose(workingCopy);\n\t\t}\n\n\t\t// Dirty working copy: we do not allow to dispose dirty working copys\n\t\t// to prevent data loss cases. dirty working copys can only be disposed when\n\t\t// they are either saved or reverted\n\t\tif (workingCopy.isDirty()) {\n\t\t\tawait Event.toPromise(workingCopy.onDidChangeDirty);\n\n\t\t\treturn this.canDispose(workingCopy);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\t// Clear pending working copy resolves\n\t\tthis.mapResourceToPendingWorkingCopyResolve.clear();\n\n\t\t// Dispose the working copy change listeners\n\t\tdispose(this.mapResourceToWorkingCopyListeners.values());\n\t\tthis.mapResourceToWorkingCopyListeners.clear();\n\t}\n\n\t//#endregion\n}\n"],
  "mappings": "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",
  "names": ["options"]
}
