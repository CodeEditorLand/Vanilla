{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/workingCopy/common/storedFileWorkingCopy.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { type IAction, toAction } from \"../../../../base/common/actions.js\";\nimport {\n\tTaskSequentializer,\n\traceCancellation,\n\ttimeout,\n} from \"../../../../base/common/async.js\";\nimport type { VSBufferReadableStream } from \"../../../../base/common/buffer.js\";\nimport {\n\tCancellationToken,\n\tCancellationTokenSource,\n} from \"../../../../base/common/cancellation.js\";\nimport {\n\tisErrorWithActions,\n\ttoErrorMessage,\n} from \"../../../../base/common/errorMessage.js\";\nimport { Emitter, Event } from \"../../../../base/common/event.js\";\nimport { hash } from \"../../../../base/common/hash.js\";\nimport type { IMarkdownString } from \"../../../../base/common/htmlContent.js\";\nimport { isWindows } from \"../../../../base/common/platform.js\";\nimport { assertIsDefined } from \"../../../../base/common/types.js\";\nimport type { URI } from \"../../../../base/common/uri.js\";\nimport { localize } from \"../../../../nls.js\";\nimport {\n\tETAG_DISABLED,\n\ttype FileOperationError,\n\tFileOperationResult,\n\ttype IFileReadLimits,\n\tIFileService,\n\ttype IFileStatWithMetadata,\n\ttype IFileStreamContent,\n\ttype IWriteFileOptions,\n\tNotModifiedSinceFileOperationError,\n} from \"../../../../platform/files/common/files.js\";\nimport { ILogService } from \"../../../../platform/log/common/log.js\";\nimport {\n\tINotificationService,\n\tSeverity,\n} from \"../../../../platform/notification/common/notification.js\";\nimport {\n\ttype IProgress,\n\tIProgressService,\n\ttype IProgressStep,\n\tProgressLocation,\n} from \"../../../../platform/progress/common/progress.js\";\nimport {\n\ttype IRevertOptions,\n\ttype ISaveOptions,\n\tSaveReason,\n} from \"../../../common/editor.js\";\nimport { IEditorService } from \"../../editor/common/editorService.js\";\nimport { IElevatedFileService } from \"../../files/common/elevatedFileService.js\";\nimport { IFilesConfigurationService } from \"../../filesConfiguration/common/filesConfigurationService.js\";\nimport {\n\ttype IFileWorkingCopy,\n\ttype IFileWorkingCopyModel,\n\ttype IFileWorkingCopyModelFactory,\n\tSnapshotContext,\n} from \"./fileWorkingCopy.js\";\nimport {\n\ttype IResourceWorkingCopy,\n\tResourceWorkingCopy,\n} from \"./resourceWorkingCopy.js\";\nimport {\n\ttype IWorkingCopyBackup,\n\ttype IWorkingCopyBackupMeta,\n\ttype IWorkingCopySaveEvent,\n\tWorkingCopyCapabilities,\n} from \"./workingCopy.js\";\nimport {\n\ttype IResolvedWorkingCopyBackup,\n\tIWorkingCopyBackupService,\n} from \"./workingCopyBackup.js\";\nimport { IWorkingCopyEditorService } from \"./workingCopyEditorService.js\";\nimport { IWorkingCopyFileService } from \"./workingCopyFileService.js\";\nimport { IWorkingCopyService } from \"./workingCopyService.js\";\n\n/**\n * Stored file specific working copy model factory.\n */\nexport interface IStoredFileWorkingCopyModelFactory<\n\tM extends IStoredFileWorkingCopyModel,\n> extends IFileWorkingCopyModelFactory<M> {}\n\n/**\n * The underlying model of a stored file working copy provides some\n * methods for the stored file working copy to function. The model is\n * typically only available after the working copy has been\n * resolved via it's `resolve()` method.\n */\nexport interface IStoredFileWorkingCopyModel extends IFileWorkingCopyModel {\n\treadonly onDidChangeContent: Event<IStoredFileWorkingCopyModelContentChangedEvent>;\n\n\t/**\n\t * A version ID of the model. If a `onDidChangeContent` is fired\n\t * from the model and the last known saved `versionId` matches\n\t * with the `model.versionId`, the stored file working copy will\n\t * discard any dirty state.\n\t *\n\t * A use case is the following:\n\t * - a stored file working copy gets edited and thus dirty\n\t * - the user triggers undo to revert the changes\n\t * - at this point the `versionId` should match the one we had saved\n\t *\n\t * This requires the model to be aware of undo/redo operations.\n\t */\n\treadonly versionId: unknown;\n\n\t/**\n\t * Close the current undo-redo element. This offers a way\n\t * to create an undo/redo stop point.\n\t *\n\t * This method may for example be called right before the\n\t * save is triggered so that the user can always undo back\n\t * to the state before saving.\n\t */\n\tpushStackElement(): void;\n\n\t/**\n\t * Optionally allows a stored file working copy model to\n\t * implement the `save` method. This allows to implement\n\t * a more efficient save logic compared to the default\n\t * which is to ask the model for a `snapshot` and then\n\t * writing that to the model's resource.\n\t */\n\tsave?(\n\t\toptions: IWriteFileOptions,\n\t\ttoken: CancellationToken,\n\t): Promise<IFileStatWithMetadata>;\n}\n\nexport interface IStoredFileWorkingCopyModelContentChangedEvent {\n\t/**\n\t * Flag that indicates that this event was generated while undoing.\n\t */\n\treadonly isUndoing: boolean;\n\n\t/**\n\t * Flag that indicates that this event was generated while redoing.\n\t */\n\treadonly isRedoing: boolean;\n}\n\n/**\n * A stored file based `IWorkingCopy` is backed by a `URI` from a\n * known file system provider. Given this assumption, a lot\n * of functionality can be built on top, such as saving in\n * a secure way to prevent data loss.\n */\nexport interface IStoredFileWorkingCopy<M extends IStoredFileWorkingCopyModel>\n\textends IResourceWorkingCopy,\n\t\tIFileWorkingCopy<M> {\n\t/**\n\t * An event for when a stored file working copy was resolved.\n\t */\n\treadonly onDidResolve: Event<void>;\n\n\t/**\n\t * An event for when a stored file working copy was saved successfully.\n\t */\n\treadonly onDidSave: Event<IStoredFileWorkingCopySaveEvent>;\n\n\t/**\n\t * An event indicating that a stored file working copy save operation failed.\n\t */\n\treadonly onDidSaveError: Event<void>;\n\n\t/**\n\t * An event for when the readonly state of the stored file working copy changes.\n\t */\n\treadonly onDidChangeReadonly: Event<void>;\n\n\t/**\n\t * Resolves a stored file working copy.\n\t */\n\tresolve(options?: IStoredFileWorkingCopyResolveOptions): Promise<void>;\n\n\t/**\n\t * Explicitly sets the working copy to be modified.\n\t */\n\tmarkModified(): void;\n\n\t/**\n\t * Whether the stored file working copy is in the provided `state`\n\t * or not.\n\t *\n\t * @param state the `FileWorkingCopyState` to check on.\n\t */\n\thasState(state: StoredFileWorkingCopyState): boolean;\n\n\t/**\n\t * Allows to join a state change away from the provided `state`.\n\t *\n\t * @param state currently only `FileWorkingCopyState.PENDING_SAVE`\n\t * can be awaited on to resolve.\n\t */\n\tjoinState(state: StoredFileWorkingCopyState.PENDING_SAVE): Promise<void>;\n\n\t/**\n\t * Whether we have a resolved model or not.\n\t */\n\tisResolved(): this is IResolvedStoredFileWorkingCopy<M>;\n\n\t/**\n\t * Whether the stored file working copy is readonly or not.\n\t */\n\tisReadonly(): boolean | IMarkdownString;\n\n\t/**\n\t * Asks the stored file working copy to save. If the stored file\n\t * working copy was dirty, it is expected to be non-dirty after\n\t * this operation has finished.\n\t *\n\t * @returns `true` if the operation was successful and `false` otherwise.\n\t */\n\tsave(options?: IStoredFileWorkingCopySaveAsOptions): Promise<boolean>;\n}\n\nexport interface IResolvedStoredFileWorkingCopy<\n\tM extends IStoredFileWorkingCopyModel,\n> extends IStoredFileWorkingCopy<M> {\n\t/**\n\t * A resolved stored file working copy has a resolved model.\n\t */\n\treadonly model: M;\n}\n\n/**\n * States the stored file working copy can be in.\n */\nexport enum StoredFileWorkingCopyState {\n\t/**\n\t * A stored file working copy is saved.\n\t */\n\tSAVED = 0,\n\n\t/**\n\t * A stored file working copy is dirty.\n\t */\n\tDIRTY = 1,\n\n\t/**\n\t * A stored file working copy is currently being saved but\n\t * this operation has not completed yet.\n\t */\n\tPENDING_SAVE = 2,\n\n\t/**\n\t * A stored file working copy is in conflict mode when changes\n\t * cannot be saved because the underlying file has changed.\n\t * Stored file working copies in conflict mode are always dirty.\n\t */\n\tCONFLICT = 3,\n\n\t/**\n\t * A stored file working copy is in orphan state when the underlying\n\t * file has been deleted.\n\t */\n\tORPHAN = 4,\n\n\t/**\n\t * Any error that happens during a save that is not causing\n\t * the `StoredFileWorkingCopyState.CONFLICT` state.\n\t * Stored file working copies in error mode are always dirty.\n\t */\n\tERROR = 5,\n}\n\nexport interface IStoredFileWorkingCopySaveOptions extends ISaveOptions {\n\t/**\n\t * Save the stored file working copy with an attempt to unlock it.\n\t */\n\treadonly writeUnlock?: boolean;\n\n\t/**\n\t * Save the stored file working copy with elevated privileges.\n\t *\n\t * Note: This may not be supported in all environments.\n\t */\n\treadonly writeElevated?: boolean;\n\n\t/**\n\t * Allows to write to a stored file working copy even if it has been\n\t * modified on disk. This should only be triggered from an\n\t * explicit user action.\n\t */\n\treadonly ignoreModifiedSince?: boolean;\n\n\t/**\n\t * If set, will bubble up the stored file working copy save error to\n\t * the caller instead of handling it.\n\t */\n\treadonly ignoreErrorHandler?: boolean;\n}\n\nexport interface IStoredFileWorkingCopySaveAsOptions\n\textends IStoredFileWorkingCopySaveOptions {\n\t/**\n\t * Optional URI of the resource the text file is saved from if known.\n\t */\n\treadonly from?: URI;\n}\n\nexport interface IStoredFileWorkingCopyResolver {\n\t/**\n\t * Resolves the working copy in a safe way from an external\n\t * working copy manager that can make sure multiple parallel\n\t * resolves execute properly.\n\t */\n\t(options?: IStoredFileWorkingCopyResolveOptions): Promise<void>;\n}\n\nexport interface IStoredFileWorkingCopyResolveOptions {\n\t/**\n\t * The contents to use for the stored file working copy if known. If not\n\t * provided, the contents will be retrieved from the underlying\n\t * resource or backup if present.\n\t *\n\t * If contents are provided, the stored file working copy will be marked\n\t * as dirty right from the beginning.\n\t */\n\treadonly contents?: VSBufferReadableStream;\n\n\t/**\n\t * Go to disk bypassing any cache of the stored file working copy if any.\n\t */\n\treadonly forceReadFromFile?: boolean;\n\n\t/**\n\t * If provided, the size of the file will be checked against the limits\n\t * and an error will be thrown if any limit is exceeded.\n\t */\n\treadonly limits?: IFileReadLimits;\n}\n\n/**\n * Metadata associated with a stored file working copy backup.\n */\ninterface IStoredFileWorkingCopyBackupMetaData extends IWorkingCopyBackupMeta {\n\treadonly mtime: number;\n\treadonly ctime: number;\n\treadonly size: number;\n\treadonly etag: string;\n\treadonly orphaned: boolean;\n}\n\nexport interface IStoredFileWorkingCopySaveEvent extends IWorkingCopySaveEvent {\n\t/**\n\t * The resolved stat from the save operation.\n\t */\n\treadonly stat: IFileStatWithMetadata;\n}\n\nexport function isStoredFileWorkingCopySaveEvent(\n\te: IWorkingCopySaveEvent,\n): e is IStoredFileWorkingCopySaveEvent {\n\tconst candidate = e as IStoredFileWorkingCopySaveEvent;\n\n\treturn !!candidate.stat;\n}\n\nexport class StoredFileWorkingCopy<M extends IStoredFileWorkingCopyModel>\n\textends ResourceWorkingCopy\n\timplements IStoredFileWorkingCopy<M>\n{\n\treadonly capabilities: WorkingCopyCapabilities =\n\t\tWorkingCopyCapabilities.None;\n\n\tprivate _model: M | undefined = undefined;\n\tget model(): M | undefined {\n\t\treturn this._model;\n\t}\n\n\t//#region events\n\n\tprivate readonly _onDidChangeContent = this._register(new Emitter<void>());\n\treadonly onDidChangeContent = this._onDidChangeContent.event;\n\n\tprivate readonly _onDidResolve = this._register(new Emitter<void>());\n\treadonly onDidResolve = this._onDidResolve.event;\n\n\tprivate readonly _onDidChangeDirty = this._register(new Emitter<void>());\n\treadonly onDidChangeDirty = this._onDidChangeDirty.event;\n\n\tprivate readonly _onDidSaveError = this._register(new Emitter<void>());\n\treadonly onDidSaveError = this._onDidSaveError.event;\n\n\tprivate readonly _onDidSave = this._register(\n\t\tnew Emitter<IStoredFileWorkingCopySaveEvent>(),\n\t);\n\treadonly onDidSave = this._onDidSave.event;\n\n\tprivate readonly _onDidRevert = this._register(new Emitter<void>());\n\treadonly onDidRevert = this._onDidRevert.event;\n\n\tprivate readonly _onDidChangeReadonly = this._register(new Emitter<void>());\n\treadonly onDidChangeReadonly = this._onDidChangeReadonly.event;\n\n\t//#endregion\n\n\tconstructor(\n\t\treadonly typeId: string,\n\t\tresource: URI,\n\t\treadonly name: string,\n\t\tprivate readonly modelFactory: IStoredFileWorkingCopyModelFactory<M>,\n\t\tprivate readonly externalResolver: IStoredFileWorkingCopyResolver,\n\t\t@IFileService fileService: IFileService,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IWorkingCopyFileService\n\t\tprivate readonly workingCopyFileService: IWorkingCopyFileService,\n\t\t@IFilesConfigurationService\n\t\tprivate readonly filesConfigurationService: IFilesConfigurationService,\n\t\t@IWorkingCopyBackupService\n\t\tprivate readonly workingCopyBackupService: IWorkingCopyBackupService,\n\t\t@IWorkingCopyService workingCopyService: IWorkingCopyService,\n\t\t@INotificationService\n\t\tprivate readonly notificationService: INotificationService,\n\t\t@IWorkingCopyEditorService\n\t\tprivate readonly workingCopyEditorService: IWorkingCopyEditorService,\n\t\t@IEditorService private readonly editorService: IEditorService,\n\t\t@IElevatedFileService\n\t\tprivate readonly elevatedFileService: IElevatedFileService,\n\t\t@IProgressService private readonly progressService: IProgressService,\n\t) {\n\t\tsuper(resource, fileService);\n\n\t\t// Make known to working copy service\n\t\tthis._register(workingCopyService.registerWorkingCopy(this));\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tthis._register(\n\t\t\tthis.filesConfigurationService.onDidChangeReadonly(() =>\n\t\t\t\tthis._onDidChangeReadonly.fire(),\n\t\t\t),\n\t\t);\n\t}\n\n\t//#region Dirty\n\n\tprivate dirty = false;\n\tprivate savedVersionId: unknown;\n\n\tisDirty(): this is IResolvedStoredFileWorkingCopy<M> {\n\t\treturn this.dirty;\n\t}\n\n\tmarkModified(): void {\n\t\tthis.setDirty(true); // stored file working copy tracks modified via dirty\n\t}\n\n\tprivate setDirty(dirty: boolean): void {\n\t\tif (!this.isResolved()) {\n\t\t\treturn; // only resolved working copies can be marked dirty\n\t\t}\n\n\t\t// Track dirty state and version id\n\t\tconst wasDirty = this.dirty;\n\t\tthis.doSetDirty(dirty);\n\n\t\t// Emit as Event if dirty changed\n\t\tif (dirty !== wasDirty) {\n\t\t\tthis._onDidChangeDirty.fire();\n\t\t}\n\t}\n\n\tprivate doSetDirty(dirty: boolean): () => void {\n\t\tconst wasDirty = this.dirty;\n\t\tconst wasInConflictMode = this.inConflictMode;\n\t\tconst wasInErrorMode = this.inErrorMode;\n\t\tconst oldSavedVersionId = this.savedVersionId;\n\n\t\tif (dirty) {\n\t\t\tthis.dirty = true;\n\t\t} else {\n\t\t\tthis.dirty = false;\n\t\t\tthis.inConflictMode = false;\n\t\t\tthis.inErrorMode = false;\n\n\t\t\t// we remember the models alternate version id to remember when the version\n\t\t\t// of the model matches with the saved version on disk. we need to keep this\n\t\t\t// in order to find out if the model changed back to a saved version (e.g.\n\t\t\t// when undoing long enough to reach to a version that is saved and then to\n\t\t\t// clear the dirty flag)\n\t\t\tif (this.isResolved()) {\n\t\t\t\tthis.savedVersionId = this.model.versionId;\n\t\t\t}\n\t\t}\n\n\t\t// Return function to revert this call\n\t\treturn () => {\n\t\t\tthis.dirty = wasDirty;\n\t\t\tthis.inConflictMode = wasInConflictMode;\n\t\t\tthis.inErrorMode = wasInErrorMode;\n\t\t\tthis.savedVersionId = oldSavedVersionId;\n\t\t};\n\t}\n\n\t//#endregion\n\n\t//#region Resolve\n\n\tlastResolvedFileStat: IFileStatWithMetadata | undefined; // !!! DO NOT MARK PRIVATE! USED IN TESTS !!!\n\n\tisResolved(): this is IResolvedStoredFileWorkingCopy<M> {\n\t\treturn !!this.model;\n\t}\n\n\tasync resolve(\n\t\toptions?: IStoredFileWorkingCopyResolveOptions,\n\t): Promise<void> {\n\t\tthis.trace(\"resolve() - enter\");\n\n\t\t// Return early if we are disposed\n\t\tif (this.isDisposed()) {\n\t\t\tthis.trace(\n\t\t\t\t\"resolve() - exit - without resolving because file working copy is disposed\",\n\t\t\t);\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Unless there are explicit contents provided, it is important that we do not\n\t\t// resolve a working copy that is dirty or is in the process of saving to prevent\n\t\t// data loss.\n\t\tif (\n\t\t\t!options?.contents &&\n\t\t\t(this.dirty || this.saveSequentializer.isRunning())\n\t\t) {\n\t\t\tthis.trace(\n\t\t\t\t\"resolve() - exit - without resolving because file working copy is dirty or being saved\",\n\t\t\t);\n\n\t\t\treturn;\n\t\t}\n\n\t\treturn this.doResolve(options);\n\t}\n\n\tprivate async doResolve(\n\t\toptions?: IStoredFileWorkingCopyResolveOptions,\n\t): Promise<void> {\n\t\t// First check if we have contents to use for the working copy\n\t\tif (options?.contents) {\n\t\t\treturn this.resolveFromBuffer(options.contents);\n\t\t}\n\n\t\t// Second, check if we have a backup to resolve from (only for new working copies)\n\t\tconst isNew = !this.isResolved();\n\t\tif (isNew) {\n\t\t\tconst resolvedFromBackup = await this.resolveFromBackup();\n\t\t\tif (resolvedFromBackup) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Finally, resolve from file resource\n\t\treturn this.resolveFromFile(options);\n\t}\n\n\tprivate async resolveFromBuffer(\n\t\tbuffer: VSBufferReadableStream,\n\t): Promise<void> {\n\t\tthis.trace(\"resolveFromBuffer()\");\n\n\t\t// Try to resolve metdata from disk\n\t\tlet mtime: number;\n\t\tlet ctime: number;\n\t\tlet size: number;\n\t\tlet etag: string;\n\t\ttry {\n\t\t\tconst metadata = await this.fileService.stat(this.resource);\n\t\t\tmtime = metadata.mtime;\n\t\t\tctime = metadata.ctime;\n\t\t\tsize = metadata.size;\n\t\t\tetag = metadata.etag;\n\n\t\t\t// Clear orphaned state when resolving was successful\n\t\t\tthis.setOrphaned(false);\n\t\t} catch (error) {\n\t\t\t// Put some fallback values in error case\n\t\t\tmtime = Date.now();\n\t\t\tctime = Date.now();\n\t\t\tsize = 0;\n\t\t\tetag = ETAG_DISABLED;\n\n\t\t\t// Apply orphaned state based on error code\n\t\t\tthis.setOrphaned(\n\t\t\t\terror.fileOperationResult ===\n\t\t\t\t\tFileOperationResult.FILE_NOT_FOUND,\n\t\t\t);\n\t\t}\n\n\t\t// Resolve with buffer\n\t\treturn this.resolveFromContent(\n\t\t\t{\n\t\t\t\tresource: this.resource,\n\t\t\t\tname: this.name,\n\t\t\t\tmtime,\n\t\t\t\tctime,\n\t\t\t\tsize,\n\t\t\t\tetag,\n\t\t\t\tvalue: buffer,\n\t\t\t\treadonly: false,\n\t\t\t\tlocked: false,\n\t\t\t},\n\t\t\ttrue /* dirty (resolved from buffer) */,\n\t\t);\n\t}\n\n\tprivate async resolveFromBackup(): Promise<boolean> {\n\t\t// Resolve backup if any\n\t\tconst backup =\n\t\t\tawait this.workingCopyBackupService.resolve<IStoredFileWorkingCopyBackupMetaData>(\n\t\t\t\tthis,\n\t\t\t);\n\n\t\t// Abort if someone else managed to resolve the working copy by now\n\t\tconst isNew = !this.isResolved();\n\t\tif (!isNew) {\n\t\t\tthis.trace(\n\t\t\t\t\"resolveFromBackup() - exit - withoutresolving because previously new file working copy got created meanwhile\",\n\t\t\t);\n\n\t\t\treturn true; // imply that resolving has happened in another operation\n\t\t}\n\n\t\t// Try to resolve from backup if we have any\n\t\tif (backup) {\n\t\t\tawait this.doResolveFromBackup(backup);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// Otherwise signal back that resolving did not happen\n\t\treturn false;\n\t}\n\n\tprivate async doResolveFromBackup(\n\t\tbackup: IResolvedWorkingCopyBackup<IStoredFileWorkingCopyBackupMetaData>,\n\t): Promise<void> {\n\t\tthis.trace(\"doResolveFromBackup()\");\n\n\t\t// Resolve with backup\n\t\tawait this.resolveFromContent(\n\t\t\t{\n\t\t\t\tresource: this.resource,\n\t\t\t\tname: this.name,\n\t\t\t\tmtime: backup.meta ? backup.meta.mtime : Date.now(),\n\t\t\t\tctime: backup.meta ? backup.meta.ctime : Date.now(),\n\t\t\t\tsize: backup.meta ? backup.meta.size : 0,\n\t\t\t\tetag: backup.meta ? backup.meta.etag : ETAG_DISABLED, // etag disabled if unknown!\n\t\t\t\tvalue: backup.value,\n\t\t\t\treadonly: false,\n\t\t\t\tlocked: false,\n\t\t\t},\n\t\t\ttrue /* dirty (resolved from backup) */,\n\t\t);\n\n\t\t// Restore orphaned flag based on state\n\t\tif (backup.meta && backup.meta.orphaned) {\n\t\t\tthis.setOrphaned(true);\n\t\t}\n\t}\n\n\tprivate async resolveFromFile(\n\t\toptions?: IStoredFileWorkingCopyResolveOptions,\n\t): Promise<void> {\n\t\tthis.trace(\"resolveFromFile()\");\n\n\t\tconst forceReadFromFile = options?.forceReadFromFile;\n\n\t\t// Decide on etag\n\t\tlet etag: string | undefined;\n\t\tif (forceReadFromFile) {\n\t\t\tetag = ETAG_DISABLED; // disable ETag if we enforce to read from disk\n\t\t} else if (this.lastResolvedFileStat) {\n\t\t\tetag = this.lastResolvedFileStat.etag; // otherwise respect etag to support caching\n\t\t}\n\n\t\t// Remember current version before doing any long running operation\n\t\t// to ensure we are not changing a working copy that was changed\n\t\t// meanwhile\n\t\tconst currentVersionId = this.versionId;\n\n\t\t// Resolve Content\n\t\ttry {\n\t\t\tconst content = await this.fileService.readFileStream(\n\t\t\t\tthis.resource,\n\t\t\t\t{\n\t\t\t\t\tetag,\n\t\t\t\t\tlimits: options?.limits,\n\t\t\t\t},\n\t\t\t);\n\n\t\t\t// Clear orphaned state when resolving was successful\n\t\t\tthis.setOrphaned(false);\n\n\t\t\t// Return early if the working copy content has changed\n\t\t\t// meanwhile to prevent loosing any changes\n\t\t\tif (currentVersionId !== this.versionId) {\n\t\t\t\tthis.trace(\n\t\t\t\t\t\"resolveFromFile() - exit - without resolving because file working copy content changed\",\n\t\t\t\t);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tawait this.resolveFromContent(\n\t\t\t\tcontent,\n\t\t\t\tfalse /* not dirty (resolved from file) */,\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tconst result = error.fileOperationResult;\n\n\t\t\t// Apply orphaned state based on error code\n\t\t\tthis.setOrphaned(result === FileOperationResult.FILE_NOT_FOUND);\n\n\t\t\t// NotModified status is expected and can be handled gracefully\n\t\t\t// if we are resolved. We still want to update our last resolved\n\t\t\t// stat to e.g. detect changes to the file's readonly state\n\t\t\tif (\n\t\t\t\tthis.isResolved() &&\n\t\t\t\tresult === FileOperationResult.FILE_NOT_MODIFIED_SINCE\n\t\t\t) {\n\t\t\t\tif (error instanceof NotModifiedSinceFileOperationError) {\n\t\t\t\t\tthis.updateLastResolvedFileStat(error.stat);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Unless we are forced to read from the file, ignore when a working copy has\n\t\t\t// been resolved once and the file was deleted meanwhile. Since we already have\n\t\t\t// the working copy resolved, we can return to this state and update the orphaned\n\t\t\t// flag to indicate that this working copy has no version on disk anymore.\n\t\t\tif (\n\t\t\t\tthis.isResolved() &&\n\t\t\t\tresult === FileOperationResult.FILE_NOT_FOUND &&\n\t\t\t\t!forceReadFromFile\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Otherwise bubble up the error\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tprivate async resolveFromContent(\n\t\tcontent: IFileStreamContent,\n\t\tdirty: boolean,\n\t): Promise<void> {\n\t\tthis.trace(\"resolveFromContent() - enter\");\n\n\t\t// Return early if we are disposed\n\t\tif (this.isDisposed()) {\n\t\t\tthis.trace(\n\t\t\t\t\"resolveFromContent() - exit - because working copy is disposed\",\n\t\t\t);\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Update our resolved disk stat\n\t\tthis.updateLastResolvedFileStat({\n\t\t\tresource: this.resource,\n\t\t\tname: content.name,\n\t\t\tmtime: content.mtime,\n\t\t\tctime: content.ctime,\n\t\t\tsize: content.size,\n\t\t\tetag: content.etag,\n\t\t\treadonly: content.readonly,\n\t\t\tlocked: content.locked,\n\t\t\tisFile: true,\n\t\t\tisDirectory: false,\n\t\t\tisSymbolicLink: false,\n\t\t\tchildren: undefined,\n\t\t});\n\n\t\t// Update existing model if we had been resolved\n\t\tif (this.isResolved()) {\n\t\t\tawait this.doUpdateModel(content.value);\n\t\t}\n\n\t\t// Create new model otherwise\n\t\telse {\n\t\t\tawait this.doCreateModel(content.value);\n\t\t}\n\n\t\t// Update working copy dirty flag. This is very important to call\n\t\t// in both cases of dirty or not because it conditionally updates\n\t\t// the `savedVersionId` to determine the version when to consider\n\t\t// the working copy as saved again (e.g. when undoing back to the\n\t\t// saved state)\n\t\tthis.setDirty(!!dirty);\n\n\t\t// Emit as event\n\t\tthis._onDidResolve.fire();\n\t}\n\n\tprivate async doCreateModel(\n\t\tcontents: VSBufferReadableStream,\n\t): Promise<void> {\n\t\tthis.trace(\"doCreateModel()\");\n\n\t\t// Create model and dispose it when we get disposed\n\t\tthis._model = this._register(\n\t\t\tawait this.modelFactory.createModel(\n\t\t\t\tthis.resource,\n\t\t\t\tcontents,\n\t\t\t\tCancellationToken.None,\n\t\t\t),\n\t\t);\n\n\t\t// Model listeners\n\t\tthis.installModelListeners(this._model);\n\t}\n\n\tprivate ignoreDirtyOnModelContentChange = false;\n\n\tprivate async doUpdateModel(\n\t\tcontents: VSBufferReadableStream,\n\t): Promise<void> {\n\t\tthis.trace(\"doUpdateModel()\");\n\n\t\t// Update model value in a block that ignores content change events for dirty tracking\n\t\tthis.ignoreDirtyOnModelContentChange = true;\n\t\ttry {\n\t\t\tawait this.model?.update(contents, CancellationToken.None);\n\t\t} finally {\n\t\t\tthis.ignoreDirtyOnModelContentChange = false;\n\t\t}\n\t}\n\n\tprivate installModelListeners(model: M): void {\n\t\t// See https://github.com/microsoft/vscode/issues/30189\n\t\t// This code has been extracted to a different method because it caused a memory leak\n\t\t// where `value` was captured in the content change listener closure scope.\n\n\t\t// Content Change\n\t\tthis._register(\n\t\t\tmodel.onDidChangeContent((e) =>\n\t\t\t\tthis.onModelContentChanged(model, e.isUndoing || e.isRedoing),\n\t\t\t),\n\t\t);\n\n\t\t// Lifecycle\n\t\tthis._register(model.onWillDispose(() => this.dispose()));\n\t}\n\n\tprivate onModelContentChanged(model: M, isUndoingOrRedoing: boolean): void {\n\t\tthis.trace(`onModelContentChanged() - enter`);\n\n\t\t// In any case increment the version id because it tracks the content state of the model at all times\n\t\tthis.versionId++;\n\t\tthis.trace(`onModelContentChanged() - new versionId ${this.versionId}`);\n\n\t\t// Remember when the user changed the model through a undo/redo operation.\n\t\t// We need this information to throttle save participants to fix\n\t\t// https://github.com/microsoft/vscode/issues/102542\n\t\tif (isUndoingOrRedoing) {\n\t\t\tthis.lastContentChangeFromUndoRedo = Date.now();\n\t\t}\n\n\t\t// We mark check for a dirty-state change upon model content change, unless:\n\t\t// - explicitly instructed to ignore it (e.g. from model.resolve())\n\t\t// - the model is readonly (in that case we never assume the change was done by the user)\n\t\tif (!this.ignoreDirtyOnModelContentChange && !this.isReadonly()) {\n\t\t\t// The contents changed as a matter of Undo and the version reached matches the saved one\n\t\t\t// In this case we clear the dirty flag and emit a SAVED event to indicate this state.\n\t\t\tif (model.versionId === this.savedVersionId) {\n\t\t\t\tthis.trace(\n\t\t\t\t\t\"onModelContentChanged() - model content changed back to last saved version\",\n\t\t\t\t);\n\n\t\t\t\t// Clear flags\n\t\t\t\tconst wasDirty = this.dirty;\n\t\t\t\tthis.setDirty(false);\n\n\t\t\t\t// Emit revert event if we were dirty\n\t\t\t\tif (wasDirty) {\n\t\t\t\t\tthis._onDidRevert.fire();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Otherwise the content has changed and we signal this as becoming dirty\n\t\t\telse {\n\t\t\t\tthis.trace(\n\t\t\t\t\t\"onModelContentChanged() - model content changed and marked as dirty\",\n\t\t\t\t);\n\n\t\t\t\t// Mark as dirty\n\t\t\t\tthis.setDirty(true);\n\t\t\t}\n\t\t}\n\n\t\t// Emit as event\n\t\tthis._onDidChangeContent.fire();\n\t}\n\n\tprivate async forceResolveFromFile(): Promise<void> {\n\t\tif (this.isDisposed()) {\n\t\t\treturn; // return early when the working copy is invalid\n\t\t}\n\n\t\t// We go through the resolver to make\n\t\t// sure this kind of `resolve` is properly\n\t\t// running in sequence with any other running\n\t\t// `resolve` if any, including subsequent runs\n\t\t// that are triggered right after.\n\n\t\tawait this.externalResolver({\n\t\t\tforceReadFromFile: true,\n\t\t});\n\t}\n\n\t//#endregion\n\n\t//#region Backup\n\n\tget backupDelay(): number | undefined {\n\t\treturn this.model?.configuration?.backupDelay;\n\t}\n\n\tasync backup(token: CancellationToken): Promise<IWorkingCopyBackup> {\n\t\t// Fill in metadata if we are resolved\n\t\tlet meta: IStoredFileWorkingCopyBackupMetaData | undefined;\n\t\tif (this.lastResolvedFileStat) {\n\t\t\tmeta = {\n\t\t\t\tmtime: this.lastResolvedFileStat.mtime,\n\t\t\t\tctime: this.lastResolvedFileStat.ctime,\n\t\t\t\tsize: this.lastResolvedFileStat.size,\n\t\t\t\tetag: this.lastResolvedFileStat.etag,\n\t\t\t\torphaned: this.isOrphaned(),\n\t\t\t};\n\t\t}\n\n\t\t// Fill in content if we are resolved\n\t\tlet content: VSBufferReadableStream | undefined;\n\t\tif (this.isResolved()) {\n\t\t\tcontent = await raceCancellation(\n\t\t\t\tthis.model.snapshot(SnapshotContext.Backup, token),\n\t\t\t\ttoken,\n\t\t\t);\n\t\t}\n\n\t\treturn { meta, content };\n\t}\n\n\t//#endregion\n\n\t//#region Save\n\n\tprivate versionId = 0;\n\n\tprivate static readonly UNDO_REDO_SAVE_PARTICIPANTS_AUTO_SAVE_THROTTLE_THRESHOLD =\n\t\t500;\n\tprivate lastContentChangeFromUndoRedo: number | undefined = undefined;\n\n\tprivate readonly saveSequentializer = new TaskSequentializer();\n\n\tprivate ignoreSaveFromSaveParticipants = false;\n\n\tasync save(\n\t\toptions: IStoredFileWorkingCopySaveAsOptions = Object.create(null),\n\t): Promise<boolean> {\n\t\tif (!this.isResolved()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.isReadonly()) {\n\t\t\tthis.trace(\"save() - ignoring request for readonly resource\");\n\n\t\t\treturn false; // if working copy is readonly we do not attempt to save at all\n\t\t}\n\n\t\tif (\n\t\t\t(this.hasState(StoredFileWorkingCopyState.CONFLICT) ||\n\t\t\t\tthis.hasState(StoredFileWorkingCopyState.ERROR)) &&\n\t\t\t(options.reason === SaveReason.AUTO ||\n\t\t\t\toptions.reason === SaveReason.FOCUS_CHANGE ||\n\t\t\t\toptions.reason === SaveReason.WINDOW_CHANGE)\n\t\t) {\n\t\t\tthis.trace(\n\t\t\t\t\"save() - ignoring auto save request for file working copy that is in conflict or error\",\n\t\t\t);\n\n\t\t\treturn false; // if working copy is in save conflict or error, do not save unless save reason is explicit\n\t\t}\n\n\t\t// Actually do save\n\t\tthis.trace(\"save() - enter\");\n\t\tawait this.doSave(options);\n\t\tthis.trace(\"save() - exit\");\n\n\t\treturn this.hasState(StoredFileWorkingCopyState.SAVED);\n\t}\n\n\tprivate async doSave(\n\t\toptions: IStoredFileWorkingCopySaveAsOptions,\n\t): Promise<void> {\n\t\tif (typeof options.reason !== \"number\") {\n\t\t\toptions.reason = SaveReason.EXPLICIT;\n\t\t}\n\n\t\tconst versionId = this.versionId;\n\t\tthis.trace(`doSave(${versionId}) - enter with versionId ${versionId}`);\n\n\t\t// Return early if saved from within save participant to break recursion\n\t\t//\n\t\t// Scenario: a save participant triggers a save() on the working copy\n\t\tif (this.ignoreSaveFromSaveParticipants) {\n\t\t\tthis.trace(\n\t\t\t\t`doSave(${versionId}) - exit - refusing to save() recursively from save participant`,\n\t\t\t);\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Lookup any running save for this versionId and return it if found\n\t\t//\n\t\t// Scenario: user invoked the save action multiple times quickly for the same contents\n\t\t//           while the save was not yet finished to disk\n\t\t//\n\t\tif (this.saveSequentializer.isRunning(versionId)) {\n\t\t\tthis.trace(\n\t\t\t\t`doSave(${versionId}) - exit - found a running save for versionId ${versionId}`,\n\t\t\t);\n\n\t\t\treturn this.saveSequentializer.running;\n\t\t}\n\n\t\t// Return early if not dirty (unless forced)\n\t\t//\n\t\t// Scenario: user invoked save action even though the working copy is not dirty\n\t\tif (!options.force && !this.dirty) {\n\t\t\tthis.trace(\n\t\t\t\t`doSave(${versionId}) - exit - because not dirty and/or versionId is different (this.isDirty: ${this.dirty}, this.versionId: ${this.versionId})`,\n\t\t\t);\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Return if currently saving by storing this save request as the next save that should happen.\n\t\t// Never ever must 2 saves execute at the same time because this can lead to dirty writes and race conditions.\n\t\t//\n\t\t// Scenario A: auto save was triggered and is currently busy saving to disk. this takes long enough that another auto save\n\t\t//             kicks in.\n\t\t// Scenario B: save is very slow (e.g. network share) and the user manages to change the working copy and trigger another save\n\t\t//             while the first save has not returned yet.\n\t\t//\n\t\tif (this.saveSequentializer.isRunning()) {\n\t\t\tthis.trace(`doSave(${versionId}) - exit - because busy saving`);\n\n\t\t\t// Indicate to the save sequentializer that we want to\n\t\t\t// cancel the running operation so that ours can run\n\t\t\t// before the running one finishes.\n\t\t\t// Currently this will try to cancel running save\n\t\t\t// participants and running snapshots from the\n\t\t\t// save operation, but not the actual save which does\n\t\t\t// not support cancellation yet.\n\t\t\tthis.saveSequentializer.cancelRunning();\n\n\t\t\t// Queue this as the upcoming save and return\n\t\t\treturn this.saveSequentializer.queue(() => this.doSave(options));\n\t\t}\n\n\t\t// Push all edit operations to the undo stack so that the user has a chance to\n\t\t// Ctrl+Z back to the saved version.\n\t\tif (this.isResolved()) {\n\t\t\tthis.model.pushStackElement();\n\t\t}\n\n\t\tconst saveCancellation = new CancellationTokenSource();\n\n\t\treturn this.progressService\n\t\t\t.withProgress(\n\t\t\t\t{\n\t\t\t\t\ttitle: localize(\n\t\t\t\t\t\t\"saveParticipants\",\n\t\t\t\t\t\t\"Saving '{0}'\",\n\t\t\t\t\t\tthis.name,\n\t\t\t\t\t),\n\t\t\t\t\tlocation: ProgressLocation.Window,\n\t\t\t\t\tcancellable: true,\n\t\t\t\t\tdelay: this.isDirty() ? 3000 : 5000,\n\t\t\t\t},\n\t\t\t\t(progress) => {\n\t\t\t\t\treturn this.doSaveSequential(\n\t\t\t\t\t\tversionId,\n\t\t\t\t\t\toptions,\n\t\t\t\t\t\tprogress,\n\t\t\t\t\t\tsaveCancellation,\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t\t() => {\n\t\t\t\t\tsaveCancellation.cancel();\n\t\t\t\t},\n\t\t\t)\n\t\t\t.finally(() => {\n\t\t\t\tsaveCancellation.dispose();\n\t\t\t});\n\t}\n\n\tprivate doSaveSequential(\n\t\tversionId: number,\n\t\toptions: IStoredFileWorkingCopySaveAsOptions,\n\t\tprogress: IProgress<IProgressStep>,\n\t\tsaveCancellation: CancellationTokenSource,\n\t): Promise<void> {\n\t\treturn this.saveSequentializer.run(\n\t\t\tversionId,\n\t\t\t(async () => {\n\t\t\t\t// A save participant can still change the working copy now\n\t\t\t\t// and since we are so close to saving we do not want to trigger\n\t\t\t\t// another auto save or similar, so we block this\n\t\t\t\t// In addition we update our version right after in case it changed\n\t\t\t\t// because of a working copy change\n\t\t\t\t// Save participants can also be skipped through API.\n\t\t\t\tif (\n\t\t\t\t\tthis.isResolved() &&\n\t\t\t\t\t!options.skipSaveParticipants &&\n\t\t\t\t\tthis.workingCopyFileService.hasSaveParticipants\n\t\t\t\t) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Measure the time it took from the last undo/redo operation to this save. If this\n\t\t\t\t\t\t// time is below `UNDO_REDO_SAVE_PARTICIPANTS_THROTTLE_THRESHOLD`, we make sure to\n\t\t\t\t\t\t// delay the save participant for the remaining time if the reason is auto save.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// This fixes the following issue:\n\t\t\t\t\t\t// - the user has configured auto save with delay of 100ms or shorter\n\t\t\t\t\t\t// - the user has a save participant enabled that modifies the file on each save\n\t\t\t\t\t\t// - the user types into the file and the file gets saved\n\t\t\t\t\t\t// - the user triggers undo operation\n\t\t\t\t\t\t// - this will undo the save participant change but trigger the save participant right after\n\t\t\t\t\t\t// - the user has no chance to undo over the save participant\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Reported as: https://github.com/microsoft/vscode/issues/102542\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\toptions.reason === SaveReason.AUTO &&\n\t\t\t\t\t\t\ttypeof this.lastContentChangeFromUndoRedo ===\n\t\t\t\t\t\t\t\t\"number\"\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst timeFromUndoRedoToSave =\n\t\t\t\t\t\t\t\tDate.now() - this.lastContentChangeFromUndoRedo;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\ttimeFromUndoRedoToSave <\n\t\t\t\t\t\t\t\tStoredFileWorkingCopy.UNDO_REDO_SAVE_PARTICIPANTS_AUTO_SAVE_THROTTLE_THRESHOLD\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tawait timeout(\n\t\t\t\t\t\t\t\t\tStoredFileWorkingCopy.UNDO_REDO_SAVE_PARTICIPANTS_AUTO_SAVE_THROTTLE_THRESHOLD -\n\t\t\t\t\t\t\t\t\t\ttimeFromUndoRedoToSave,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Run save participants unless save was cancelled meanwhile\n\t\t\t\t\t\tif (!saveCancellation.token.isCancellationRequested) {\n\t\t\t\t\t\t\tthis.ignoreSaveFromSaveParticipants = true;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tawait this.workingCopyFileService.runSaveParticipants(\n\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\treason:\n\t\t\t\t\t\t\t\t\t\t\toptions.reason ??\n\t\t\t\t\t\t\t\t\t\t\tSaveReason.EXPLICIT,\n\t\t\t\t\t\t\t\t\t\tsavedFrom: options.from,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tprogress,\n\t\t\t\t\t\t\t\t\tsaveCancellation.token,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\tthis.ignoreSaveFromSaveParticipants = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tthis.logService.error(\n\t\t\t\t\t\t\t`[stored file working copy] runSaveParticipants(${versionId}) - resulted in an error: ${error.toString()}`,\n\t\t\t\t\t\t\tthis.resource.toString(),\n\t\t\t\t\t\t\tthis.typeId,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// It is possible that a subsequent save is cancelling this\n\t\t\t\t// running save. As such we return early when we detect that.\n\t\t\t\tif (saveCancellation.token.isCancellationRequested) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// We have to protect against being disposed at this point. It could be that the save() operation\n\t\t\t\t// was triggerd followed by a dispose() operation right after without waiting. Typically we cannot\n\t\t\t\t// be disposed if we are dirty, but if we are not dirty, save() and dispose() can still be triggered\n\t\t\t\t// one after the other without waiting for the save() to complete. If we are disposed(), we risk\n\t\t\t\t// saving contents to disk that are stale (see https://github.com/microsoft/vscode/issues/50942).\n\t\t\t\t// To fix this issue, we will not store the contents to disk when we got disposed.\n\t\t\t\tif (this.isDisposed()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// We require a resolved working copy from this point on, since we are about to write data to disk.\n\t\t\t\tif (!this.isResolved()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// update versionId with its new value (if pre-save changes happened)\n\t\t\t\tversionId = this.versionId;\n\n\t\t\t\t// Clear error flag since we are trying to save again\n\t\t\t\tthis.inErrorMode = false;\n\n\t\t\t\t// Save to Disk. We mark the save operation as currently running with\n\t\t\t\t// the latest versionId because it might have changed from a save\n\t\t\t\t// participant triggering\n\t\t\t\tprogress.report({\n\t\t\t\t\tmessage: localize(\"saveTextFile\", \"Writing into file...\"),\n\t\t\t\t});\n\t\t\t\tthis.trace(`doSave(${versionId}) - before write()`);\n\t\t\t\tconst lastResolvedFileStat = assertIsDefined(\n\t\t\t\t\tthis.lastResolvedFileStat,\n\t\t\t\t);\n\t\t\t\tconst resolvedFileWorkingCopy = this;\n\t\t\t\treturn this.saveSequentializer.run(\n\t\t\t\t\tversionId,\n\t\t\t\t\t(async () => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst writeFileOptions: IWriteFileOptions = {\n\t\t\t\t\t\t\t\tmtime: lastResolvedFileStat.mtime,\n\t\t\t\t\t\t\t\tetag:\n\t\t\t\t\t\t\t\t\toptions.ignoreModifiedSince ||\n\t\t\t\t\t\t\t\t\t!this.filesConfigurationService.preventSaveConflicts(\n\t\t\t\t\t\t\t\t\t\tlastResolvedFileStat.resource,\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t? ETAG_DISABLED\n\t\t\t\t\t\t\t\t\t\t: lastResolvedFileStat.etag,\n\t\t\t\t\t\t\t\tunlock: options.writeUnlock,\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tlet stat: IFileStatWithMetadata;\n\n\t\t\t\t\t\t\t// Delegate to working copy model save method if any\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\ttypeof resolvedFileWorkingCopy.model.save ===\n\t\t\t\t\t\t\t\t\"function\"\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tstat =\n\t\t\t\t\t\t\t\t\t\tawait resolvedFileWorkingCopy.model.save(\n\t\t\t\t\t\t\t\t\t\t\twriteFileOptions,\n\t\t\t\t\t\t\t\t\t\t\tsaveCancellation.token,\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tsaveCancellation.token\n\t\t\t\t\t\t\t\t\t\t\t.isCancellationRequested\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\treturn undefined; // save was cancelled\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Otherwise ask for a snapshot and save via file services\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Snapshot working copy model contents\n\t\t\t\t\t\t\t\tconst snapshot = await raceCancellation(\n\t\t\t\t\t\t\t\t\tresolvedFileWorkingCopy.model.snapshot(\n\t\t\t\t\t\t\t\t\t\tSnapshotContext.Save,\n\t\t\t\t\t\t\t\t\t\tsaveCancellation.token,\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\tsaveCancellation.token,\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t// It is possible that a subsequent save is cancelling this\n\t\t\t\t\t\t\t\t// running save. As such we return early when we detect that\n\t\t\t\t\t\t\t\t// However, we do not pass the token into the file service\n\t\t\t\t\t\t\t\t// because that is an atomic operation currently without\n\t\t\t\t\t\t\t\t// cancellation support, so we dispose the cancellation if\n\t\t\t\t\t\t\t\t// it was not cancelled yet.\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tsaveCancellation.token\n\t\t\t\t\t\t\t\t\t\t.isCancellationRequested\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tsaveCancellation.dispose();\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Write them to disk\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\toptions?.writeElevated &&\n\t\t\t\t\t\t\t\t\tthis.elevatedFileService.isSupported(\n\t\t\t\t\t\t\t\t\t\tlastResolvedFileStat.resource,\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tstat =\n\t\t\t\t\t\t\t\t\t\tawait this.elevatedFileService.writeFileElevated(\n\t\t\t\t\t\t\t\t\t\t\tlastResolvedFileStat.resource,\n\t\t\t\t\t\t\t\t\t\t\tassertIsDefined(snapshot),\n\t\t\t\t\t\t\t\t\t\t\twriteFileOptions,\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tstat = await this.fileService.writeFile(\n\t\t\t\t\t\t\t\t\t\tlastResolvedFileStat.resource,\n\t\t\t\t\t\t\t\t\t\tassertIsDefined(snapshot),\n\t\t\t\t\t\t\t\t\t\twriteFileOptions,\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.handleSaveSuccess(stat, versionId, options);\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tthis.handleSaveError(error, versionId, options);\n\t\t\t\t\t\t}\n\t\t\t\t\t})(),\n\t\t\t\t\t() => saveCancellation.cancel(),\n\t\t\t\t);\n\t\t\t})(),\n\t\t\t() => saveCancellation.cancel(),\n\t\t);\n\t}\n\n\tprivate handleSaveSuccess(\n\t\tstat: IFileStatWithMetadata,\n\t\tversionId: number,\n\t\toptions: IStoredFileWorkingCopySaveAsOptions,\n\t): void {\n\t\t// Updated resolved stat with updated stat\n\t\tthis.updateLastResolvedFileStat(stat);\n\n\t\t// Update dirty state unless working copy has changed meanwhile\n\t\tif (versionId === this.versionId) {\n\t\t\tthis.trace(\n\t\t\t\t`handleSaveSuccess(${versionId}) - setting dirty to false because versionId did not change`,\n\t\t\t);\n\t\t\tthis.setDirty(false);\n\t\t} else {\n\t\t\tthis.trace(\n\t\t\t\t`handleSaveSuccess(${versionId}) - not setting dirty to false because versionId did change meanwhile`,\n\t\t\t);\n\t\t}\n\n\t\t// Update orphan state given save was successful\n\t\tthis.setOrphaned(false);\n\n\t\t// Emit Save Event\n\t\tthis._onDidSave.fire({\n\t\t\treason: options.reason,\n\t\t\tstat,\n\t\t\tsource: options.source,\n\t\t});\n\t}\n\n\tprivate handleSaveError(\n\t\terror: Error,\n\t\tversionId: number,\n\t\toptions: IStoredFileWorkingCopySaveAsOptions,\n\t): void {\n\t\t(options.ignoreErrorHandler\n\t\t\t? this.logService.trace\n\t\t\t: this.logService.error\n\t\t).apply(this.logService, [\n\t\t\t`[stored file working copy] handleSaveError(${versionId}) - exit - resulted in a save error: ${error.toString()}`,\n\t\t\tthis.resource.toString(),\n\t\t\tthis.typeId,\n\t\t]);\n\n\t\t// Return early if the save() call was made asking to\n\t\t// handle the save error itself.\n\t\tif (options.ignoreErrorHandler) {\n\t\t\tthrow error;\n\t\t}\n\n\t\t// In any case of an error, we mark the working copy as dirty to prevent data loss\n\t\t// It could be possible that the write corrupted the file on disk (e.g. when\n\t\t// an error happened after truncating the file) and as such we want to preserve\n\t\t// the working copy contents to prevent data loss.\n\t\tthis.setDirty(true);\n\n\t\t// Flag as error state\n\t\tthis.inErrorMode = true;\n\n\t\t// Look out for a save conflict\n\t\tif (\n\t\t\t(error as FileOperationError).fileOperationResult ===\n\t\t\tFileOperationResult.FILE_MODIFIED_SINCE\n\t\t) {\n\t\t\tthis.inConflictMode = true;\n\t\t}\n\n\t\t// Show save error to user for handling\n\t\tthis.doHandleSaveError(error, options);\n\n\t\t// Emit as event\n\t\tthis._onDidSaveError.fire();\n\t}\n\n\tprivate doHandleSaveError(\n\t\terror: Error,\n\t\toptions: IStoredFileWorkingCopySaveAsOptions,\n\t): void {\n\t\tconst fileOperationError = error as FileOperationError;\n\t\tconst primaryActions: IAction[] = [];\n\n\t\tlet message: string;\n\n\t\t// Dirty write prevention\n\t\tif (\n\t\t\tfileOperationError.fileOperationResult ===\n\t\t\tFileOperationResult.FILE_MODIFIED_SINCE\n\t\t) {\n\t\t\tmessage = localize(\n\t\t\t\t\"staleSaveError\",\n\t\t\t\t\"Failed to save '{0}': The content of the file is newer. Do you want to overwrite the file with your changes?\",\n\t\t\t\tthis.name,\n\t\t\t);\n\n\t\t\tprimaryActions.push(\n\t\t\t\ttoAction({\n\t\t\t\t\tid: \"fileWorkingCopy.overwrite\",\n\t\t\t\t\tlabel: localize(\"overwrite\", \"Overwrite\"),\n\t\t\t\t\trun: () =>\n\t\t\t\t\t\tthis.save({\n\t\t\t\t\t\t\t...options,\n\t\t\t\t\t\t\tignoreModifiedSince: true,\n\t\t\t\t\t\t\treason: SaveReason.EXPLICIT,\n\t\t\t\t\t\t}),\n\t\t\t\t}),\n\t\t\t);\n\t\t\tprimaryActions.push(\n\t\t\t\ttoAction({\n\t\t\t\t\tid: \"fileWorkingCopy.revert\",\n\t\t\t\t\tlabel: localize(\"revert\", \"Revert\"),\n\t\t\t\t\trun: () => this.revert(),\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\t// Any other save error\n\t\telse {\n\t\t\tconst isWriteLocked =\n\t\t\t\tfileOperationError.fileOperationResult ===\n\t\t\t\tFileOperationResult.FILE_WRITE_LOCKED;\n\t\t\tconst triedToUnlock =\n\t\t\t\tisWriteLocked &&\n\t\t\t\t(fileOperationError.options as IWriteFileOptions | undefined)\n\t\t\t\t\t?.unlock;\n\t\t\tconst isPermissionDenied =\n\t\t\t\tfileOperationError.fileOperationResult ===\n\t\t\t\tFileOperationResult.FILE_PERMISSION_DENIED;\n\t\t\tconst canSaveElevated = this.elevatedFileService.isSupported(\n\t\t\t\tthis.resource,\n\t\t\t);\n\n\t\t\t// Error with Actions\n\t\t\tif (isErrorWithActions(error)) {\n\t\t\t\tprimaryActions.push(...error.actions);\n\t\t\t}\n\n\t\t\t// Save Elevated\n\t\t\tif (canSaveElevated && (isPermissionDenied || triedToUnlock)) {\n\t\t\t\tprimaryActions.push(\n\t\t\t\t\ttoAction({\n\t\t\t\t\t\tid: \"fileWorkingCopy.saveElevated\",\n\t\t\t\t\t\tlabel: triedToUnlock\n\t\t\t\t\t\t\t? isWindows\n\t\t\t\t\t\t\t\t? localize(\n\t\t\t\t\t\t\t\t\t\t\"overwriteElevated\",\n\t\t\t\t\t\t\t\t\t\t\"Overwrite as Admin...\",\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t: localize(\n\t\t\t\t\t\t\t\t\t\t\"overwriteElevatedSudo\",\n\t\t\t\t\t\t\t\t\t\t\"Overwrite as Sudo...\",\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t: isWindows\n\t\t\t\t\t\t\t\t? localize(\"saveElevated\", \"Retry as Admin...\")\n\t\t\t\t\t\t\t\t: localize(\n\t\t\t\t\t\t\t\t\t\t\"saveElevatedSudo\",\n\t\t\t\t\t\t\t\t\t\t\"Retry as Sudo...\",\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\trun: () => {\n\t\t\t\t\t\t\tthis.save({\n\t\t\t\t\t\t\t\t...options,\n\t\t\t\t\t\t\t\twriteElevated: true,\n\t\t\t\t\t\t\t\twriteUnlock: triedToUnlock,\n\t\t\t\t\t\t\t\treason: SaveReason.EXPLICIT,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Unlock\n\t\t\telse if (isWriteLocked) {\n\t\t\t\tprimaryActions.push(\n\t\t\t\t\ttoAction({\n\t\t\t\t\t\tid: \"fileWorkingCopy.unlock\",\n\t\t\t\t\t\tlabel: localize(\"overwrite\", \"Overwrite\"),\n\t\t\t\t\t\trun: () =>\n\t\t\t\t\t\t\tthis.save({\n\t\t\t\t\t\t\t\t...options,\n\t\t\t\t\t\t\t\twriteUnlock: true,\n\t\t\t\t\t\t\t\treason: SaveReason.EXPLICIT,\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Retry\n\t\t\telse {\n\t\t\t\tprimaryActions.push(\n\t\t\t\t\ttoAction({\n\t\t\t\t\t\tid: \"fileWorkingCopy.retry\",\n\t\t\t\t\t\tlabel: localize(\"retry\", \"Retry\"),\n\t\t\t\t\t\trun: () =>\n\t\t\t\t\t\t\tthis.save({\n\t\t\t\t\t\t\t\t...options,\n\t\t\t\t\t\t\t\treason: SaveReason.EXPLICIT,\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Save As\n\t\t\tprimaryActions.push(\n\t\t\t\ttoAction({\n\t\t\t\t\tid: \"fileWorkingCopy.saveAs\",\n\t\t\t\t\tlabel: localize(\"saveAs\", \"Save As...\"),\n\t\t\t\t\trun: async () => {\n\t\t\t\t\t\tconst editor =\n\t\t\t\t\t\t\tthis.workingCopyEditorService.findEditor(this);\n\t\t\t\t\t\tif (editor) {\n\t\t\t\t\t\t\tconst result = await this.editorService.save(\n\t\t\t\t\t\t\t\teditor,\n\t\t\t\t\t\t\t\t{ saveAs: true, reason: SaveReason.EXPLICIT },\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (!result.success) {\n\t\t\t\t\t\t\t\tthis.doHandleSaveError(error, options); // show error again given the operation failed\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\t// Revert\n\t\t\tprimaryActions.push(\n\t\t\t\ttoAction({\n\t\t\t\t\tid: \"fileWorkingCopy.revert\",\n\t\t\t\t\tlabel: localize(\"revert\", \"Revert\"),\n\t\t\t\t\trun: () => this.revert(),\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\t// Message\n\t\t\tif (isWriteLocked) {\n\t\t\t\tif (triedToUnlock && canSaveElevated) {\n\t\t\t\t\tmessage = isWindows\n\t\t\t\t\t\t? localize(\n\t\t\t\t\t\t\t\t\"readonlySaveErrorAdmin\",\n\t\t\t\t\t\t\t\t\"Failed to save '{0}': File is read-only. Select 'Overwrite as Admin' to retry as administrator.\",\n\t\t\t\t\t\t\t\tthis.name,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t: localize(\n\t\t\t\t\t\t\t\t\"readonlySaveErrorSudo\",\n\t\t\t\t\t\t\t\t\"Failed to save '{0}': File is read-only. Select 'Overwrite as Sudo' to retry as superuser.\",\n\t\t\t\t\t\t\t\tthis.name,\n\t\t\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tmessage = localize(\n\t\t\t\t\t\t\"readonlySaveError\",\n\t\t\t\t\t\t\"Failed to save '{0}': File is read-only. Select 'Overwrite' to attempt to make it writeable.\",\n\t\t\t\t\t\tthis.name,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else if (canSaveElevated && isPermissionDenied) {\n\t\t\t\tmessage = isWindows\n\t\t\t\t\t? localize(\n\t\t\t\t\t\t\t\"permissionDeniedSaveError\",\n\t\t\t\t\t\t\t\"Failed to save '{0}': Insufficient permissions. Select 'Retry as Admin' to retry as administrator.\",\n\t\t\t\t\t\t\tthis.name,\n\t\t\t\t\t\t)\n\t\t\t\t\t: localize(\n\t\t\t\t\t\t\t\"permissionDeniedSaveErrorSudo\",\n\t\t\t\t\t\t\t\"Failed to save '{0}': Insufficient permissions. Select 'Retry as Sudo' to retry as superuser.\",\n\t\t\t\t\t\t\tthis.name,\n\t\t\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tmessage = localize(\n\t\t\t\t\t{\n\t\t\t\t\t\tkey: \"genericSaveError\",\n\t\t\t\t\t\tcomment: [\n\t\t\t\t\t\t\t\"{0} is the resource that failed to save and {1} the error message\",\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t\t\"Failed to save '{0}': {1}\",\n\t\t\t\t\tthis.name,\n\t\t\t\t\ttoErrorMessage(error, false),\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Show to the user as notification\n\t\tconst handle = this.notificationService.notify({\n\t\t\tid: `${hash(this.resource.toString())}`,\n\t\t\tseverity: Severity.Error,\n\t\t\tmessage,\n\t\t\tactions: { primary: primaryActions },\n\t\t});\n\n\t\t// Remove automatically when we get saved/reverted\n\t\tconst listener = this._register(\n\t\t\tEvent.once(Event.any(this.onDidSave, this.onDidRevert))(() =>\n\t\t\t\thandle.close(),\n\t\t\t),\n\t\t);\n\t\tthis._register(Event.once(handle.onDidClose)(() => listener.dispose()));\n\t}\n\n\tprivate updateLastResolvedFileStat(\n\t\tnewFileStat: IFileStatWithMetadata,\n\t): void {\n\t\tconst oldReadonly = this.isReadonly();\n\n\t\t// First resolve - just take\n\t\tif (!this.lastResolvedFileStat) {\n\t\t\tthis.lastResolvedFileStat = newFileStat;\n\t\t}\n\n\t\t// Subsequent resolve - make sure that we only assign it if the mtime\n\t\t// is equal or has advanced.\n\t\t// This prevents race conditions from resolving and saving. If a save\n\t\t// comes in late after a revert was called, the mtime could be out of\n\t\t// sync.\n\t\telse if (this.lastResolvedFileStat.mtime <= newFileStat.mtime) {\n\t\t\tthis.lastResolvedFileStat = newFileStat;\n\t\t}\n\n\t\t// In all other cases update only the readonly and locked flags\n\t\telse {\n\t\t\tthis.lastResolvedFileStat = {\n\t\t\t\t...this.lastResolvedFileStat,\n\t\t\t\treadonly: newFileStat.readonly,\n\t\t\t\tlocked: newFileStat.locked,\n\t\t\t};\n\t\t}\n\n\t\t// Signal that the readonly state changed\n\t\tif (this.isReadonly() !== oldReadonly) {\n\t\t\tthis._onDidChangeReadonly.fire();\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region Revert\n\n\tasync revert(options?: IRevertOptions): Promise<void> {\n\t\tif (!this.isResolved() || (!this.dirty && !options?.force)) {\n\t\t\treturn; // ignore if not resolved or not dirty and not enforced\n\t\t}\n\n\t\tthis.trace(\"revert()\");\n\n\t\t// Unset flags\n\t\tconst wasDirty = this.dirty;\n\t\tconst undoSetDirty = this.doSetDirty(false);\n\n\t\t// Force read from disk unless reverting soft\n\t\tconst softUndo = options?.soft;\n\t\tif (!softUndo) {\n\t\t\ttry {\n\t\t\t\tawait this.forceResolveFromFile();\n\t\t\t} catch (error) {\n\t\t\t\t// FileNotFound means the file got deleted meanwhile, so ignore it\n\t\t\t\tif (\n\t\t\t\t\t(error as FileOperationError).fileOperationResult !==\n\t\t\t\t\tFileOperationResult.FILE_NOT_FOUND\n\t\t\t\t) {\n\t\t\t\t\t// Set flags back to previous values, we are still dirty if revert failed\n\t\t\t\t\tundoSetDirty();\n\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Emit file change event\n\t\tthis._onDidRevert.fire();\n\n\t\t// Emit dirty change event\n\t\tif (wasDirty) {\n\t\t\tthis._onDidChangeDirty.fire();\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region State\n\n\tprivate inConflictMode = false;\n\tprivate inErrorMode = false;\n\n\thasState(state: StoredFileWorkingCopyState): boolean {\n\t\tswitch (state) {\n\t\t\tcase StoredFileWorkingCopyState.CONFLICT:\n\t\t\t\treturn this.inConflictMode;\n\t\t\tcase StoredFileWorkingCopyState.DIRTY:\n\t\t\t\treturn this.dirty;\n\t\t\tcase StoredFileWorkingCopyState.ERROR:\n\t\t\t\treturn this.inErrorMode;\n\t\t\tcase StoredFileWorkingCopyState.ORPHAN:\n\t\t\t\treturn this.isOrphaned();\n\t\t\tcase StoredFileWorkingCopyState.PENDING_SAVE:\n\t\t\t\treturn this.saveSequentializer.isRunning();\n\t\t\tcase StoredFileWorkingCopyState.SAVED:\n\t\t\t\treturn !this.dirty;\n\t\t}\n\t}\n\n\tasync joinState(\n\t\tstate: StoredFileWorkingCopyState.PENDING_SAVE,\n\t): Promise<void> {\n\t\treturn this.saveSequentializer.running;\n\t}\n\n\t//#endregion\n\n\t//#region Utilities\n\n\tisReadonly(): boolean | IMarkdownString {\n\t\treturn this.filesConfigurationService.isReadonly(\n\t\t\tthis.resource,\n\t\t\tthis.lastResolvedFileStat,\n\t\t);\n\t}\n\n\tprivate trace(msg: string): void {\n\t\tthis.logService.trace(\n\t\t\t`[stored file working copy] ${msg}`,\n\t\t\tthis.resource.toString(),\n\t\t\tthis.typeId,\n\t\t);\n\t}\n\n\t//#endregion\n\n\t//#region Dispose\n\n\toverride dispose(): void {\n\t\tthis.trace(\"dispose()\");\n\n\t\t// State\n\t\tthis.inConflictMode = false;\n\t\tthis.inErrorMode = false;\n\n\t\t// Free up model for GC\n\t\tthis._model = undefined;\n\n\t\tsuper.dispose();\n\t}\n\n\t//#endregion\n}\n"],
  "mappings": "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",
  "names": ["StoredFileWorkingCopyState"]
}
