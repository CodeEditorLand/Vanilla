{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/workingCopy/common/workingCopy.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../../../base/common/event.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { ISaveOptions, IRevertOptions, SaveReason, SaveSource } from '../../../common/editor.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { VSBufferReadable, VSBufferReadableStream } from '../../../../base/common/buffer.js';\n\nexport const enum WorkingCopyCapabilities {\n\n\t/**\n\t * Signals no specific capability for the working copy.\n\t */\n\tNone = 0,\n\n\t/**\n\t * Signals that the working copy requires\n\t * additional input when saving, e.g. an\n\t * associated path to save to.\n\t */\n\tUntitled = 1 << 1,\n\n\t/**\n\t * The working copy will not indicate that\n\t * it is dirty and unsaved content will be\n\t * discarded without prompting if closed.\n\t */\n\tScratchpad = 1 << 2\n}\n\n/**\n * Data to be associated with working copy backups. Use\n * `IWorkingCopyBackupService.resolve(workingCopy)` to\n * retrieve the backup when loading the working copy.\n */\nexport interface IWorkingCopyBackup {\n\n\t/**\n\t * Any serializable metadata to be associated with the backup.\n\t */\n\tmeta?: IWorkingCopyBackupMeta;\n\n\t/**\n\t * The actual snapshot of the contents of the working copy at\n\t * the time the backup was made.\n\t */\n\tcontent?: VSBufferReadable | VSBufferReadableStream;\n}\n\n/**\n * Working copy backup metadata that can be associated\n * with the backup.\n *\n * Some properties may be reserved as outlined here and\n * cannot be used.\n */\nexport interface IWorkingCopyBackupMeta {\n\n\t/**\n\t * Any property needs to be serializable through JSON.\n\t */\n\t[key: string]: unknown;\n\n\t/**\n\t * `typeId` is a reserved property that cannot be used\n\t * as backup metadata.\n\t */\n\ttypeId?: never;\n}\n\n/**\n * @deprecated it is important to provide a type identifier\n * for working copies to enable all capabilities.\n */\nexport const NO_TYPE_ID = '';\n\n/**\n * Every working copy has in common that it is identified by\n * a resource `URI` and a `typeId`. There can only be one\n * working copy registered with the same `URI` and `typeId`.\n */\nexport interface IWorkingCopyIdentifier {\n\n\t/**\n\t * The type identifier of the working copy for grouping\n\t * working copies of the same domain together.\n\t *\n\t * There can only be one working copy for a given resource\n\t * and type identifier.\n\t */\n\treadonly typeId: string;\n\n\t/**\n\t * The resource of the working copy must be unique for\n\t * working copies of the same `typeId`.\n\t */\n\treadonly resource: URI;\n}\n\nexport interface IWorkingCopySaveEvent {\n\n\t/**\n\t * The reason why the working copy was saved.\n\t */\n\treadonly reason?: SaveReason;\n\n\t/**\n\t * The source of the working copy save request.\n\t */\n\treadonly source?: SaveSource;\n}\n\n/**\n * A working copy is an abstract concept to unify handling of\n * data that can be worked on (e.g. edited) in an editor.\n *\n *\n * A working copy resource may be the backing store of the data\n * (e.g. a file on disk), but that is not a requirement. If\n * your working copy is file based, consider to use the\n * `IFileWorkingCopy` instead that simplifies a lot of things\n * when working with file based working copies.\n */\nexport interface IWorkingCopy extends IWorkingCopyIdentifier {\n\n\t/**\n\t * Human readable name of the working copy.\n\t */\n\treadonly name: string;\n\n\t/**\n\t * The capabilities of the working copy.\n\t */\n\treadonly capabilities: WorkingCopyCapabilities;\n\n\n\t//#region Events\n\n\t/**\n\t * Used by the workbench to signal if the working copy\n\t * is dirty or not. Typically a working copy is dirty\n\t * once changed until saved or reverted.\n\t */\n\treadonly onDidChangeDirty: Event<void>;\n\n\t/**\n\t * Used by the workbench e.g. to trigger auto-save\n\t * (unless this working copy is untitled) and backups.\n\t */\n\treadonly onDidChangeContent: Event<void>;\n\n\t/**\n\t * Used by the workbench e.g. to track local history\n\t * (unless this working copy is untitled).\n\t */\n\treadonly onDidSave: Event<IWorkingCopySaveEvent>;\n\n\t//#endregion\n\n\n\t//#region Dirty Tracking\n\n\t/**\n\t * Indicates that the file has unsaved changes\n\t * and should confirm before closing.\n\t */\n\tisDirty(): boolean;\n\n\t/**\n\t * Indicates that the file has unsaved changes.\n\t * Used for backup tracking and accounts for\n\t * working copies that are never dirty e.g.\n\t * scratchpads.\n\t */\n\tisModified(): boolean;\n\n\t//#endregion\n\n\n\t//#region Save / Backup\n\n\t/**\n\t * The delay in milliseconds to wait before triggering\n\t * a backup after the content of the model has changed.\n\t *\n\t * If not configured, a sensible default will be taken\n\t * based on user settings.\n\t */\n\treadonly backupDelay?: number;\n\n\t/**\n\t * The workbench may call this method often after it receives\n\t * the `onDidChangeContent` event for the working copy. The motivation\n\t * is to allow to quit VSCode with dirty working copies present.\n\t *\n\t * Providers of working copies should use `IWorkingCopyBackupService.resolve(workingCopy)`\n\t * to retrieve the backup metadata associated when loading the working copy.\n\t *\n\t * @param token support for cancellation\n\t */\n\tbackup(token: CancellationToken): Promise<IWorkingCopyBackup>;\n\n\t/**\n\t * Asks the working copy to save. If the working copy was dirty, it is\n\t * expected to be non-dirty after this operation has finished.\n\t *\n\t * @returns `true` if the operation was successful and `false` otherwise.\n\t */\n\tsave(options?: ISaveOptions): Promise<boolean>;\n\n\t/**\n\t * Asks the working copy to revert. If the working copy was dirty, it is\n\t * expected to be non-dirty after this operation has finished.\n\t */\n\trevert(options?: IRevertOptions): Promise<void>;\n\n\t//#endregion\n}\n"],
  "mappings": "AAKA,SAAS,aAAa;AACtB,SAAS,WAAW;AACpB,SAAS,cAAc,gBAAgB,YAAY,kBAAkB;AACrE,SAAS,yBAAyB;AAClC,SAAS,kBAAkB,8BAA8B;AAElD,IAAW,0BAAX,kBAAWA,6BAAX;AAKN,EAAAA,kDAAA,UAAO,KAAP;AAOA,EAAAA,kDAAA,cAAW,KAAX;AAOA,EAAAA,kDAAA,gBAAa,KAAb;AAnBiB,SAAAA;AAAA,GAAA;AAkEX,MAAM,aAAa;",
  "names": ["WorkingCopyCapabilities"]
}
