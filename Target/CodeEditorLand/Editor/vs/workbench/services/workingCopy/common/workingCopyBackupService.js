var F=Object.defineProperty;var U=Object.getOwnPropertyDescriptor;var I=(n,t,e,r)=>{for(var i=r>1?void 0:r?U(t,e):t,a=n.length-1,o;a>=0;a--)(o=n[a])&&(i=(r?o(t,e,i):o(i))||i);return r&&i&&F(t,e,i),i},m=(n,t)=>(e,r)=>t(e,r,n);import{coalesce as L}from"../../../../base/common/arrays.js";import{Promises as S,ResourceQueue as D}from"../../../../base/common/async.js";import{VSBuffer as f,bufferToStream as C,prefixedBufferReadable as N,prefixedBufferStream as P,readableToBuffer as V,streamToBuffer as z}from"../../../../base/common/buffer.js";import{hash as j}from"../../../../base/common/hash.js";import{Disposable as g}from"../../../../base/common/lifecycle.js";import{ResourceMap as k}from"../../../../base/common/map.js";import{Schemas as B}from"../../../../base/common/network.js";import{deepClone as M,equals as q}from"../../../../base/common/objects.js";import{joinPath as E}from"../../../../base/common/resources.js";import{isReadableStream as W,peekStream as H}from"../../../../base/common/stream.js";import{isEmptyObject as Q}from"../../../../base/common/types.js";import{URI as w}from"../../../../base/common/uri.js";import{FileOperationResult as $,IFileService as A}from"../../../../platform/files/common/files.js";import{ILogService as T}from"../../../../platform/log/common/log.js";import{NO_TYPE_ID as K}from"./workingCopy.js";class R{constructor(t,e){this.backupRoot=t;this.fileService=e}cache=new k;static async create(t,e){const r=new R(t,e);return await r.resolve(),r}async resolve(){try{const t=await this.fileService.resolve(this.backupRoot);t.children&&await S.settled(t.children.filter(e=>e.isDirectory).map(async e=>{const r=await this.fileService.resolve(e.resource);if(r.children)for(const i of r.children)i.isDirectory||this.add(i.resource)}))}catch{}}add(t,e=0,r){this.cache.set(t,{versionId:e,meta:M(r)})}update(t,e){const r=this.cache.get(t);r&&(r.meta=M(e))}count(){return this.cache.size}has(t,e,r){const i=this.cache.get(t);return!(!i||typeof e=="number"&&e!==i.versionId||r&&!q(r,i.meta))}get(){return Array.from(this.cache.keys())}remove(t){this.cache.delete(t)}clear(){this.cache.clear()}}let h=class extends g{constructor(e,r,i){super();this.fileService=r;this.logService=i;this.impl=this._register(this.initialize(e))}impl;initialize(e){return e?new s(e,this.fileService,this.logService):new x}reinitialize(e){this.impl instanceof s&&(e?this.impl.initialize(e):this.impl=new x)}hasBackups(){return this.impl.hasBackups()}hasBackupSync(e,r,i){return this.impl.hasBackupSync(e,r,i)}backup(e,r,i,a,o){return this.impl.backup(e,r,i,a,o)}discardBackup(e,r){return this.impl.discardBackup(e,r)}discardBackups(e){return this.impl.discardBackups(e)}getBackups(){return this.impl.getBackups()}resolve(e){return this.impl.resolve(e)}toBackupResource(e){return this.impl.toBackupResource(e)}joinBackups(){return this.impl.joinBackups()}};h=I([m(1,A),m(2,T)],h);let s=class extends g{constructor(e,r,i){super();this.backupWorkspaceHome=e;this.fileService=r;this.logService=i;this.initialize(e)}static PREAMBLE_END_MARKER=`
`;static PREAMBLE_END_MARKER_CHARCODE=10;static PREAMBLE_META_SEPARATOR=" ";static PREAMBLE_MAX_LENGTH=1e4;ioOperationQueues=this._register(new D);ready;model=void 0;initialize(e){this.backupWorkspaceHome=e,this.ready=this.doInitialize()}async doInitialize(){return this.model=await R.create(this.backupWorkspaceHome,this.fileService),this.model}async hasBackups(){const e=await this.ready;return await this.joinBackups(),e.count()>0}hasBackupSync(e,r,i){if(!this.model)return!1;const a=this.toBackupResource(e);return this.model.has(a,r,i)}async backup(e,r,i,a,o){const u=await this.ready;if(o?.isCancellationRequested)return;const c=this.toBackupResource(e);if(!u.has(c,i,a))return this.ioOperationQueues.queueFor(c,async()=>{if(o?.isCancellationRequested||u.has(c,i,a))return;let p=this.createPreamble(e,a);p.length>=s.PREAMBLE_MAX_LENGTH&&(p=this.createPreamble(e));const d=f.fromString(p);let l;W(r)?l=P(d,r):r?l=N(d,r):l=f.concat([d,f.fromString("")]),await this.fileService.writeFile(c,l),u.add(c,i,a)})}createPreamble(e,r){return`${e.resource.toString()}${s.PREAMBLE_META_SEPARATOR}${JSON.stringify({...r,typeId:e.typeId})}${s.PREAMBLE_END_MARKER}`}async discardBackups(e){const r=await this.ready,i=e?.except;if(Array.isArray(i)&&i.length>0){const a=new k;for(const o of i)a.set(this.toBackupResource(o),!0);await S.settled(r.get().map(async o=>{a.has(o)||await this.doDiscardBackup(o)}))}else await this.deleteIgnoreFileNotFound(this.backupWorkspaceHome),r.clear()}discardBackup(e,r){const i=this.toBackupResource(e);return this.doDiscardBackup(i,r)}async doDiscardBackup(e,r){const i=await this.ready;if(!r?.isCancellationRequested)return this.ioOperationQueues.queueFor(e,async()=>{r?.isCancellationRequested||(await this.deleteIgnoreFileNotFound(e),i.remove(e))})}async deleteIgnoreFileNotFound(e){try{await this.fileService.del(e,{recursive:!0})}catch(r){if(r.fileOperationResult!==$.FILE_NOT_FOUND)throw r}}async getBackups(){const e=await this.ready;await this.joinBackups();const r=await Promise.all(e.get().map(i=>this.resolveIdentifier(i,e)));return L(r)}async resolveIdentifier(e,r){let i;return await this.ioOperationQueues.queueFor(e,async()=>{if(!r.has(e))return;const a=await this.readToMatchingString(e,s.PREAMBLE_END_MARKER,s.PREAMBLE_MAX_LENGTH);if(!a)return;const o=a.indexOf(s.PREAMBLE_META_SEPARATOR);let u,c;o>0?(u=a.substring(0,o),c=a.substr(o+1)):(u=a,c=void 0);const{typeId:p,meta:d}=this.parsePreambleMeta(c);r.update(e,d),i={typeId:p??K,resource:w.parse(u)}}),i}async readToMatchingString(e,r,i){const a=(await this.fileService.readFile(e,{length:i})).value.toString(),o=a.indexOf(r);if(o>=0)return a.substr(0,o)}async resolve(e){const r=this.toBackupResource(e),i=await this.ready;let a;return await this.ioOperationQueues.queueFor(r,async()=>{if(!i.has(r))return;const o=await this.fileService.readFileStream(r),u=await H(o.value,1),c=f.concat(u.buffer),p=c.buffer.indexOf(s.PREAMBLE_END_MARKER_CHARCODE);if(p===-1){this.logService.trace(`Backup: Could not find meta end marker in ${r}. The file is probably corrupt (filesize: ${o.size}).`);return}const d=c.slice(0,p).toString();let l;const v=d.indexOf(s.PREAMBLE_META_SEPARATOR);v!==-1&&(l=this.parsePreambleMeta(d.substr(v+1)).meta),i.update(r,l);const b=c.slice(p+1);let y;u.ended?y=C(b):y=P(b,u.stream),a={value:y,meta:l}}),a}parsePreambleMeta(e){let r,i;if(e)try{i=JSON.parse(e),r=i?.typeId,typeof i?.typeId=="string"&&(delete i.typeId,Q(i)&&(i=void 0))}catch{}return{typeId:r,meta:i}}toBackupResource(e){return E(this.backupWorkspaceHome,e.resource.scheme,O(e))}joinBackups(){return this.ioOperationQueues.whenDrained()}};s=I([m(1,A),m(2,T)],s);class x extends g{backups=new k;constructor(){super()}async hasBackups(){return this.backups.size>0}hasBackupSync(t,e){const r=this.toBackupResource(t);return this.backups.has(r)}async backup(t,e,r,i,a){const o=this.toBackupResource(t);this.backups.set(o,{typeId:t.typeId,content:e instanceof f?e:e?W(e)?await z(e):V(e):f.fromString(""),meta:i})}async resolve(t){const e=this.toBackupResource(t),r=this.backups.get(e);if(r)return{value:C(r.content),meta:r.meta}}async getBackups(){return Array.from(this.backups.entries()).map(([t,e])=>({typeId:e.typeId,resource:t}))}async discardBackup(t){this.backups.delete(this.toBackupResource(t))}async discardBackups(t){const e=t?.except;if(Array.isArray(e)&&e.length>0){const r=new k;for(const i of e)r.set(this.toBackupResource(i),!0);for(const i of await this.getBackups())r.has(this.toBackupResource(i))||await this.discardBackup(i)}else this.backups.clear()}toBackupResource(t){return w.from({scheme:B.inMemory,path:O(t)})}async joinBackups(){}}function O(n){let t;if(n.typeId.length>0){const e=_(n.typeId);n.resource.path?t=E(n.resource,e):t=n.resource.with({path:e})}else t=n.resource;return G(t)}function G(n){const t=n.scheme===B.file||n.scheme===B.untitled?n.fsPath:n.toString();return _(t)}function _(n){return j(n).toString(16)}export{x as InMemoryWorkingCopyBackupService,h as WorkingCopyBackupService,R as WorkingCopyBackupsModel,O as hashIdentifier};
