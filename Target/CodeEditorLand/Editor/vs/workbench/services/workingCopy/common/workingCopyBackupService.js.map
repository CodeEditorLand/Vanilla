{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/workingCopy/common/workingCopyBackupService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { joinPath } from '../../../../base/common/resources.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { coalesce } from '../../../../base/common/arrays.js';\nimport { equals, deepClone } from '../../../../base/common/objects.js';\nimport { Promises, ResourceQueue } from '../../../../base/common/async.js';\nimport { IResolvedWorkingCopyBackup, IWorkingCopyBackupService } from './workingCopyBackup.js';\nimport { IFileService, FileOperationError, FileOperationResult } from '../../../../platform/files/common/files.js';\nimport { ResourceMap } from '../../../../base/common/map.js';\nimport { isReadableStream, peekStream } from '../../../../base/common/stream.js';\nimport { bufferToStream, prefixedBufferReadable, prefixedBufferStream, readableToBuffer, streamToBuffer, VSBuffer, VSBufferReadable, VSBufferReadableStream } from '../../../../base/common/buffer.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { Schemas } from '../../../../base/common/network.js';\nimport { hash } from '../../../../base/common/hash.js';\nimport { isEmptyObject } from '../../../../base/common/types.js';\nimport { IWorkingCopyBackupMeta, IWorkingCopyIdentifier, NO_TYPE_ID } from './workingCopy.js';\n\nexport class WorkingCopyBackupsModel {\n\n\tprivate readonly cache = new ResourceMap<{ versionId?: number; meta?: IWorkingCopyBackupMeta }>();\n\n\tstatic async create(backupRoot: URI, fileService: IFileService): Promise<WorkingCopyBackupsModel> {\n\t\tconst model = new WorkingCopyBackupsModel(backupRoot, fileService);\n\n\t\tawait model.resolve();\n\n\t\treturn model;\n\t}\n\n\tprivate constructor(private backupRoot: URI, private fileService: IFileService) { }\n\n\tprivate async resolve(): Promise<void> {\n\t\ttry {\n\t\t\tconst backupRootStat = await this.fileService.resolve(this.backupRoot);\n\t\t\tif (backupRootStat.children) {\n\t\t\t\tawait Promises.settled(backupRootStat.children\n\t\t\t\t\t.filter(child => child.isDirectory)\n\t\t\t\t\t.map(async backupSchemaFolder => {\n\n\t\t\t\t\t\t// Read backup directory for backups\n\t\t\t\t\t\tconst backupSchemaFolderStat = await this.fileService.resolve(backupSchemaFolder.resource);\n\n\t\t\t\t\t\t// Remember known backups in our caches\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Note: this does NOT account for resolving\n\t\t\t\t\t\t// associated meta data because that requires\n\t\t\t\t\t\t// opening the backup and reading the meta\n\t\t\t\t\t\t// preamble. Instead, when backups are actually\n\t\t\t\t\t\t// resolved, the meta data will be added via\n\t\t\t\t\t\t// additional `update` calls.\n\t\t\t\t\t\tif (backupSchemaFolderStat.children) {\n\t\t\t\t\t\t\tfor (const backupForSchema of backupSchemaFolderStat.children) {\n\t\t\t\t\t\t\t\tif (!backupForSchema.isDirectory) {\n\t\t\t\t\t\t\t\t\tthis.add(backupForSchema.resource);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// ignore any errors\n\t\t}\n\t}\n\n\tadd(resource: URI, versionId = 0, meta?: IWorkingCopyBackupMeta): void {\n\t\tthis.cache.set(resource, {\n\t\t\tversionId,\n\t\t\tmeta: deepClone(meta)\n\t\t});\n\t}\n\n\tupdate(resource: URI, meta?: IWorkingCopyBackupMeta): void {\n\t\tconst entry = this.cache.get(resource);\n\t\tif (entry) {\n\t\t\tentry.meta = deepClone(meta);\n\t\t}\n\t}\n\n\tcount(): number {\n\t\treturn this.cache.size;\n\t}\n\n\thas(resource: URI, versionId?: number, meta?: IWorkingCopyBackupMeta): boolean {\n\t\tconst entry = this.cache.get(resource);\n\t\tif (!entry) {\n\t\t\treturn false; // unknown resource\n\t\t}\n\n\t\tif (typeof versionId === 'number' && versionId !== entry.versionId) {\n\t\t\treturn false; // different versionId\n\t\t}\n\n\t\tif (meta && !equals(meta, entry.meta)) {\n\t\t\treturn false; // different metadata\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tget(): URI[] {\n\t\treturn Array.from(this.cache.keys());\n\t}\n\n\tremove(resource: URI): void {\n\t\tthis.cache.delete(resource);\n\t}\n\n\tclear(): void {\n\t\tthis.cache.clear();\n\t}\n}\n\nexport abstract class WorkingCopyBackupService extends Disposable implements IWorkingCopyBackupService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate impl: WorkingCopyBackupServiceImpl | InMemoryWorkingCopyBackupService;\n\n\tconstructor(\n\t\tbackupWorkspaceHome: URI | undefined,\n\t\t@IFileService protected fileService: IFileService,\n\t\t@ILogService private readonly logService: ILogService\n\t) {\n\t\tsuper();\n\n\t\tthis.impl = this._register(this.initialize(backupWorkspaceHome));\n\t}\n\n\tprivate initialize(backupWorkspaceHome: URI | undefined): WorkingCopyBackupServiceImpl | InMemoryWorkingCopyBackupService {\n\t\tif (backupWorkspaceHome) {\n\t\t\treturn new WorkingCopyBackupServiceImpl(backupWorkspaceHome, this.fileService, this.logService);\n\t\t}\n\n\t\treturn new InMemoryWorkingCopyBackupService();\n\t}\n\n\treinitialize(backupWorkspaceHome: URI | undefined): void {\n\n\t\t// Re-init implementation (unless we are running in-memory)\n\t\tif (this.impl instanceof WorkingCopyBackupServiceImpl) {\n\t\t\tif (backupWorkspaceHome) {\n\t\t\t\tthis.impl.initialize(backupWorkspaceHome);\n\t\t\t} else {\n\t\t\t\tthis.impl = new InMemoryWorkingCopyBackupService();\n\t\t\t}\n\t\t}\n\t}\n\n\thasBackups(): Promise<boolean> {\n\t\treturn this.impl.hasBackups();\n\t}\n\n\thasBackupSync(identifier: IWorkingCopyIdentifier, versionId?: number, meta?: IWorkingCopyBackupMeta): boolean {\n\t\treturn this.impl.hasBackupSync(identifier, versionId, meta);\n\t}\n\n\tbackup(identifier: IWorkingCopyIdentifier, content?: VSBufferReadableStream | VSBufferReadable, versionId?: number, meta?: IWorkingCopyBackupMeta, token?: CancellationToken): Promise<void> {\n\t\treturn this.impl.backup(identifier, content, versionId, meta, token);\n\t}\n\n\tdiscardBackup(identifier: IWorkingCopyIdentifier, token?: CancellationToken): Promise<void> {\n\t\treturn this.impl.discardBackup(identifier, token);\n\t}\n\n\tdiscardBackups(filter?: { except: IWorkingCopyIdentifier[] }): Promise<void> {\n\t\treturn this.impl.discardBackups(filter);\n\t}\n\n\tgetBackups(): Promise<IWorkingCopyIdentifier[]> {\n\t\treturn this.impl.getBackups();\n\t}\n\n\tresolve<T extends IWorkingCopyBackupMeta>(identifier: IWorkingCopyIdentifier): Promise<IResolvedWorkingCopyBackup<T> | undefined> {\n\t\treturn this.impl.resolve(identifier);\n\t}\n\n\ttoBackupResource(identifier: IWorkingCopyIdentifier): URI {\n\t\treturn this.impl.toBackupResource(identifier);\n\t}\n\n\tjoinBackups(): Promise<void> {\n\t\treturn this.impl.joinBackups();\n\t}\n}\n\nclass WorkingCopyBackupServiceImpl extends Disposable implements IWorkingCopyBackupService {\n\n\tprivate static readonly PREAMBLE_END_MARKER = '\\n';\n\tprivate static readonly PREAMBLE_END_MARKER_CHARCODE = '\\n'.charCodeAt(0);\n\tprivate static readonly PREAMBLE_META_SEPARATOR = ' '; // using a character that is know to be escaped in a URI as separator\n\tprivate static readonly PREAMBLE_MAX_LENGTH = 10000;\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly ioOperationQueues = this._register(new ResourceQueue()); // queue IO operations to ensure write/delete file order\n\n\tprivate ready!: Promise<WorkingCopyBackupsModel>;\n\tprivate model: WorkingCopyBackupsModel | undefined = undefined;\n\n\tconstructor(\n\t\tprivate backupWorkspaceHome: URI,\n\t\t@IFileService private readonly fileService: IFileService,\n\t\t@ILogService private readonly logService: ILogService\n\t) {\n\t\tsuper();\n\n\t\tthis.initialize(backupWorkspaceHome);\n\t}\n\n\tinitialize(backupWorkspaceResource: URI): void {\n\t\tthis.backupWorkspaceHome = backupWorkspaceResource;\n\n\t\tthis.ready = this.doInitialize();\n\t}\n\n\tprivate async doInitialize(): Promise<WorkingCopyBackupsModel> {\n\n\t\t// Create backup model\n\t\tthis.model = await WorkingCopyBackupsModel.create(this.backupWorkspaceHome, this.fileService);\n\n\t\treturn this.model;\n\t}\n\n\tasync hasBackups(): Promise<boolean> {\n\t\tconst model = await this.ready;\n\n\t\t// Ensure to await any pending backup operations\n\t\tawait this.joinBackups();\n\n\t\treturn model.count() > 0;\n\t}\n\n\thasBackupSync(identifier: IWorkingCopyIdentifier, versionId?: number, meta?: IWorkingCopyBackupMeta): boolean {\n\t\tif (!this.model) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst backupResource = this.toBackupResource(identifier);\n\n\t\treturn this.model.has(backupResource, versionId, meta);\n\t}\n\n\tasync backup(identifier: IWorkingCopyIdentifier, content?: VSBufferReadable | VSBufferReadableStream, versionId?: number, meta?: IWorkingCopyBackupMeta, token?: CancellationToken): Promise<void> {\n\t\tconst model = await this.ready;\n\t\tif (token?.isCancellationRequested) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst backupResource = this.toBackupResource(identifier);\n\t\tif (model.has(backupResource, versionId, meta)) {\n\t\t\t// return early if backup version id matches requested one\n\t\t\treturn;\n\t\t}\n\n\t\treturn this.ioOperationQueues.queueFor(backupResource, async () => {\n\t\t\tif (token?.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (model.has(backupResource, versionId, meta)) {\n\t\t\t\t// return early if backup version id matches requested one\n\t\t\t\t// this can happen when multiple backup IO operations got\n\t\t\t\t// scheduled, racing against each other.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Encode as: Resource + META-START + Meta + END\n\t\t\t// and respect max length restrictions in case\n\t\t\t// meta is too large.\n\t\t\tlet preamble = this.createPreamble(identifier, meta);\n\t\t\tif (preamble.length >= WorkingCopyBackupServiceImpl.PREAMBLE_MAX_LENGTH) {\n\t\t\t\tpreamble = this.createPreamble(identifier);\n\t\t\t}\n\n\t\t\t// Update backup with value\n\t\t\tconst preambleBuffer = VSBuffer.fromString(preamble);\n\t\t\tlet backupBuffer: VSBuffer | VSBufferReadableStream | VSBufferReadable;\n\t\t\tif (isReadableStream(content)) {\n\t\t\t\tbackupBuffer = prefixedBufferStream(preambleBuffer, content);\n\t\t\t} else if (content) {\n\t\t\t\tbackupBuffer = prefixedBufferReadable(preambleBuffer, content);\n\t\t\t} else {\n\t\t\t\tbackupBuffer = VSBuffer.concat([preambleBuffer, VSBuffer.fromString('')]);\n\t\t\t}\n\n\t\t\t// Write backup via file service\n\t\t\tawait this.fileService.writeFile(backupResource, backupBuffer);\n\n\t\t\t//\n\t\t\t// Update model\n\t\t\t//\n\t\t\t// Note: not checking for cancellation here because a successful\n\t\t\t// write into the backup file should be noted in the model to\n\t\t\t// prevent the model being out of sync with the backup file\n\t\t\tmodel.add(backupResource, versionId, meta);\n\t\t});\n\t}\n\n\tprivate createPreamble(identifier: IWorkingCopyIdentifier, meta?: IWorkingCopyBackupMeta): string {\n\t\treturn `${identifier.resource.toString()}${WorkingCopyBackupServiceImpl.PREAMBLE_META_SEPARATOR}${JSON.stringify({ ...meta, typeId: identifier.typeId })}${WorkingCopyBackupServiceImpl.PREAMBLE_END_MARKER}`;\n\t}\n\n\tasync discardBackups(filter?: { except: IWorkingCopyIdentifier[] }): Promise<void> {\n\t\tconst model = await this.ready;\n\n\t\t// Discard all but some backups\n\t\tconst except = filter?.except;\n\t\tif (Array.isArray(except) && except.length > 0) {\n\t\t\tconst exceptMap = new ResourceMap<boolean>();\n\t\t\tfor (const exceptWorkingCopy of except) {\n\t\t\t\texceptMap.set(this.toBackupResource(exceptWorkingCopy), true);\n\t\t\t}\n\n\t\t\tawait Promises.settled(model.get().map(async backupResource => {\n\t\t\t\tif (!exceptMap.has(backupResource)) {\n\t\t\t\t\tawait this.doDiscardBackup(backupResource);\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\n\t\t// Discard all backups\n\t\telse {\n\t\t\tawait this.deleteIgnoreFileNotFound(this.backupWorkspaceHome);\n\n\t\t\tmodel.clear();\n\t\t}\n\t}\n\n\tdiscardBackup(identifier: IWorkingCopyIdentifier, token?: CancellationToken): Promise<void> {\n\t\tconst backupResource = this.toBackupResource(identifier);\n\n\t\treturn this.doDiscardBackup(backupResource, token);\n\t}\n\n\tprivate async doDiscardBackup(backupResource: URI, token?: CancellationToken): Promise<void> {\n\t\tconst model = await this.ready;\n\t\tif (token?.isCancellationRequested) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn this.ioOperationQueues.queueFor(backupResource, async () => {\n\t\t\tif (token?.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Delete backup file ignoring any file not found errors\n\t\t\tawait this.deleteIgnoreFileNotFound(backupResource);\n\n\t\t\t//\n\t\t\t// Update model\n\t\t\t//\n\t\t\t// Note: not checking for cancellation here because a successful\n\t\t\t// delete of the backup file should be noted in the model to\n\t\t\t// prevent the model being out of sync with the backup file\n\t\t\tmodel.remove(backupResource);\n\t\t});\n\t}\n\n\tprivate async deleteIgnoreFileNotFound(backupResource: URI): Promise<void> {\n\t\ttry {\n\t\t\tawait this.fileService.del(backupResource, { recursive: true });\n\t\t} catch (error) {\n\t\t\tif ((<FileOperationError>error).fileOperationResult !== FileOperationResult.FILE_NOT_FOUND) {\n\t\t\t\tthrow error; // re-throw any other error than file not found which is OK\n\t\t\t}\n\t\t}\n\t}\n\n\tasync getBackups(): Promise<IWorkingCopyIdentifier[]> {\n\t\tconst model = await this.ready;\n\n\t\t// Ensure to await any pending backup operations\n\t\tawait this.joinBackups();\n\n\t\tconst backups = await Promise.all(model.get().map(backupResource => this.resolveIdentifier(backupResource, model)));\n\n\t\treturn coalesce(backups);\n\t}\n\n\tprivate async resolveIdentifier(backupResource: URI, model: WorkingCopyBackupsModel): Promise<IWorkingCopyIdentifier | undefined> {\n\t\tlet res: IWorkingCopyIdentifier | undefined = undefined;\n\n\t\tawait this.ioOperationQueues.queueFor(backupResource, async () => {\n\t\t\tif (!model.has(backupResource)) {\n\t\t\t\treturn; // require backup to be present\n\t\t\t}\n\n\t\t\t// Read the entire backup preamble by reading up to\n\t\t\t// `PREAMBLE_MAX_LENGTH` in the backup file until\n\t\t\t// the `PREAMBLE_END_MARKER` is found\n\t\t\tconst backupPreamble = await this.readToMatchingString(backupResource, WorkingCopyBackupServiceImpl.PREAMBLE_END_MARKER, WorkingCopyBackupServiceImpl.PREAMBLE_MAX_LENGTH);\n\t\t\tif (!backupPreamble) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Figure out the offset in the preamble where meta\n\t\t\t// information possibly starts. This can be `-1` for\n\t\t\t// older backups without meta.\n\t\t\tconst metaStartIndex = backupPreamble.indexOf(WorkingCopyBackupServiceImpl.PREAMBLE_META_SEPARATOR);\n\n\t\t\t// Extract the preamble content for resource and meta\n\t\t\tlet resourcePreamble: string;\n\t\t\tlet metaPreamble: string | undefined;\n\t\t\tif (metaStartIndex > 0) {\n\t\t\t\tresourcePreamble = backupPreamble.substring(0, metaStartIndex);\n\t\t\t\tmetaPreamble = backupPreamble.substr(metaStartIndex + 1);\n\t\t\t} else {\n\t\t\t\tresourcePreamble = backupPreamble;\n\t\t\t\tmetaPreamble = undefined;\n\t\t\t}\n\n\t\t\t// Try to parse the meta preamble for figuring out\n\t\t\t// `typeId` and `meta` if defined.\n\t\t\tconst { typeId, meta } = this.parsePreambleMeta(metaPreamble);\n\n\t\t\t// Update model entry with now resolved meta\n\t\t\tmodel.update(backupResource, meta);\n\n\t\t\tres = {\n\t\t\t\ttypeId: typeId ?? NO_TYPE_ID,\n\t\t\t\tresource: URI.parse(resourcePreamble)\n\t\t\t};\n\t\t});\n\n\t\treturn res;\n\t}\n\n\tprivate async readToMatchingString(backupResource: URI, matchingString: string, maximumBytesToRead: number): Promise<string | undefined> {\n\t\tconst contents = (await this.fileService.readFile(backupResource, { length: maximumBytesToRead })).value.toString();\n\n\t\tconst matchingStringIndex = contents.indexOf(matchingString);\n\t\tif (matchingStringIndex >= 0) {\n\t\t\treturn contents.substr(0, matchingStringIndex);\n\t\t}\n\n\t\t// Unable to find matching string in file\n\t\treturn undefined;\n\t}\n\n\tasync resolve<T extends IWorkingCopyBackupMeta>(identifier: IWorkingCopyIdentifier): Promise<IResolvedWorkingCopyBackup<T> | undefined> {\n\t\tconst backupResource = this.toBackupResource(identifier);\n\n\t\tconst model = await this.ready;\n\n\t\tlet res: IResolvedWorkingCopyBackup<T> | undefined = undefined;\n\n\t\tawait this.ioOperationQueues.queueFor(backupResource, async () => {\n\t\t\tif (!model.has(backupResource)) {\n\t\t\t\treturn; // require backup to be present\n\t\t\t}\n\n\t\t\t// Load the backup content and peek into the first chunk\n\t\t\t// to be able to resolve the meta data\n\t\t\tconst backupStream = await this.fileService.readFileStream(backupResource);\n\t\t\tconst peekedBackupStream = await peekStream(backupStream.value, 1);\n\t\t\tconst firstBackupChunk = VSBuffer.concat(peekedBackupStream.buffer);\n\n\t\t\t// We have seen reports (e.g. https://github.com/microsoft/vscode/issues/78500) where\n\t\t\t// if VSCode goes down while writing the backup file, the file can turn empty because\n\t\t\t// it always first gets truncated and then written to. In this case, we will not find\n\t\t\t// the meta-end marker ('\\n') and as such the backup can only be invalid. We bail out\n\t\t\t// here if that is the case.\n\t\t\tconst preambleEndIndex = firstBackupChunk.buffer.indexOf(WorkingCopyBackupServiceImpl.PREAMBLE_END_MARKER_CHARCODE);\n\t\t\tif (preambleEndIndex === -1) {\n\t\t\t\tthis.logService.trace(`Backup: Could not find meta end marker in ${backupResource}. The file is probably corrupt (filesize: ${backupStream.size}).`);\n\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst preambelRaw = firstBackupChunk.slice(0, preambleEndIndex).toString();\n\n\t\t\t// Extract meta data (if any)\n\t\t\tlet meta: T | undefined;\n\t\t\tconst metaStartIndex = preambelRaw.indexOf(WorkingCopyBackupServiceImpl.PREAMBLE_META_SEPARATOR);\n\t\t\tif (metaStartIndex !== -1) {\n\t\t\t\tmeta = this.parsePreambleMeta(preambelRaw.substr(metaStartIndex + 1)).meta as T;\n\t\t\t}\n\n\t\t\t// Update model entry with now resolved meta\n\t\t\tmodel.update(backupResource, meta);\n\n\t\t\t// Build a new stream without the preamble\n\t\t\tconst firstBackupChunkWithoutPreamble = firstBackupChunk.slice(preambleEndIndex + 1);\n\t\t\tlet value: VSBufferReadableStream;\n\t\t\tif (peekedBackupStream.ended) {\n\t\t\t\tvalue = bufferToStream(firstBackupChunkWithoutPreamble);\n\t\t\t} else {\n\t\t\t\tvalue = prefixedBufferStream(firstBackupChunkWithoutPreamble, peekedBackupStream.stream);\n\t\t\t}\n\n\t\t\tres = { value, meta };\n\t\t});\n\n\t\treturn res;\n\t}\n\n\tprivate parsePreambleMeta<T extends IWorkingCopyBackupMeta>(preambleMetaRaw: string | undefined): { typeId: string | undefined; meta: T | undefined } {\n\t\tlet typeId: string | undefined = undefined;\n\t\tlet meta: T | undefined = undefined;\n\n\t\tif (preambleMetaRaw) {\n\t\t\ttry {\n\t\t\t\tmeta = JSON.parse(preambleMetaRaw);\n\t\t\t\ttypeId = meta?.typeId;\n\n\t\t\t\t// `typeId` is a property that we add so we\n\t\t\t\t// remove it when returning to clients.\n\t\t\t\tif (typeof meta?.typeId === 'string') {\n\t\t\t\t\tdelete meta.typeId;\n\n\t\t\t\t\tif (isEmptyObject(meta)) {\n\t\t\t\t\t\tmeta = undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\t// ignore JSON parse errors\n\t\t\t}\n\t\t}\n\n\t\treturn { typeId, meta };\n\t}\n\n\ttoBackupResource(identifier: IWorkingCopyIdentifier): URI {\n\t\treturn joinPath(this.backupWorkspaceHome, identifier.resource.scheme, hashIdentifier(identifier));\n\t}\n\n\tjoinBackups(): Promise<void> {\n\t\treturn this.ioOperationQueues.whenDrained();\n\t}\n}\n\nexport class InMemoryWorkingCopyBackupService extends Disposable implements IWorkingCopyBackupService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate backups = new ResourceMap<{ typeId: string; content: VSBuffer; meta?: IWorkingCopyBackupMeta }>();\n\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\tasync hasBackups(): Promise<boolean> {\n\t\treturn this.backups.size > 0;\n\t}\n\n\thasBackupSync(identifier: IWorkingCopyIdentifier, versionId?: number): boolean {\n\t\tconst backupResource = this.toBackupResource(identifier);\n\n\t\treturn this.backups.has(backupResource);\n\t}\n\n\tasync backup(identifier: IWorkingCopyIdentifier, content?: VSBufferReadable | VSBufferReadableStream, versionId?: number, meta?: IWorkingCopyBackupMeta, token?: CancellationToken): Promise<void> {\n\t\tconst backupResource = this.toBackupResource(identifier);\n\t\tthis.backups.set(backupResource, {\n\t\t\ttypeId: identifier.typeId,\n\t\t\tcontent: content instanceof VSBuffer ? content : content ? isReadableStream(content) ? await streamToBuffer(content) : readableToBuffer(content) : VSBuffer.fromString(''),\n\t\t\tmeta\n\t\t});\n\t}\n\n\tasync resolve<T extends IWorkingCopyBackupMeta>(identifier: IWorkingCopyIdentifier): Promise<IResolvedWorkingCopyBackup<T> | undefined> {\n\t\tconst backupResource = this.toBackupResource(identifier);\n\t\tconst backup = this.backups.get(backupResource);\n\t\tif (backup) {\n\t\t\treturn { value: bufferToStream(backup.content), meta: backup.meta as T | undefined };\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tasync getBackups(): Promise<IWorkingCopyIdentifier[]> {\n\t\treturn Array.from(this.backups.entries()).map(([resource, backup]) => ({ typeId: backup.typeId, resource }));\n\t}\n\n\tasync discardBackup(identifier: IWorkingCopyIdentifier): Promise<void> {\n\t\tthis.backups.delete(this.toBackupResource(identifier));\n\t}\n\n\tasync discardBackups(filter?: { except: IWorkingCopyIdentifier[] }): Promise<void> {\n\t\tconst except = filter?.except;\n\t\tif (Array.isArray(except) && except.length > 0) {\n\t\t\tconst exceptMap = new ResourceMap<boolean>();\n\t\t\tfor (const exceptWorkingCopy of except) {\n\t\t\t\texceptMap.set(this.toBackupResource(exceptWorkingCopy), true);\n\t\t\t}\n\n\t\t\tfor (const backup of await this.getBackups()) {\n\t\t\t\tif (!exceptMap.has(this.toBackupResource(backup))) {\n\t\t\t\t\tawait this.discardBackup(backup);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthis.backups.clear();\n\t\t}\n\t}\n\n\ttoBackupResource(identifier: IWorkingCopyIdentifier): URI {\n\t\treturn URI.from({ scheme: Schemas.inMemory, path: hashIdentifier(identifier) });\n\t}\n\n\tasync joinBackups(): Promise<void> {\n\t\treturn;\n\t}\n}\n\n/*\n * Exported only for testing\n */\nexport function hashIdentifier(identifier: IWorkingCopyIdentifier): string {\n\n\t// IMPORTANT: for backwards compatibility, ensure that\n\t// we ignore the `typeId` unless a value is provided.\n\t// To preserve previous backups without type id, we\n\t// need to just hash the resource. Otherwise we use\n\t// the type id as a seed to the resource path.\n\tlet resource: URI;\n\tif (identifier.typeId.length > 0) {\n\t\tconst typeIdHash = hashString(identifier.typeId);\n\t\tif (identifier.resource.path) {\n\t\t\tresource = joinPath(identifier.resource, typeIdHash);\n\t\t} else {\n\t\t\tresource = identifier.resource.with({ path: typeIdHash });\n\t\t}\n\t} else {\n\t\tresource = identifier.resource;\n\t}\n\n\treturn hashPath(resource);\n}\n\nfunction hashPath(resource: URI): string {\n\tconst str = resource.scheme === Schemas.file || resource.scheme === Schemas.untitled ? resource.fsPath : resource.toString();\n\n\treturn hashString(str);\n}\n\nfunction hashString(str: string): string {\n\treturn hash(str).toString(16);\n}\n"],
  "mappings": ";;;;;;;;;;;;AAKA,SAAS,gBAAgB;AACzB,SAAS,WAAW;AACpB,SAAS,gBAAgB;AACzB,SAAS,QAAQ,iBAAiB;AAClC,SAAS,UAAU,qBAAqB;AACxC,SAAS,4BAA4B,iCAAiC;AACtE,SAAS,cAAc,oBAAoB,2BAA2B;AACtE,SAAS,mBAAmB;AAC5B,SAAS,kBAAkB,kBAAkB;AAC7C,SAAS,gBAAgB,wBAAwB,sBAAsB,kBAAkB,gBAAgB,UAAU,kBAAkB,8BAA8B;AACnK,SAAS,kBAAkB;AAC3B,SAAS,mBAAmB;AAC5B,SAAS,yBAAyB;AAClC,SAAS,eAAe;AACxB,SAAS,YAAY;AACrB,SAAS,qBAAqB;AAC9B,SAAS,wBAAwB,wBAAwB,kBAAkB;AAEpE,MAAM,wBAAwB;AAAA,EAY5B,YAAoB,YAAyB,aAA2B;AAApD;AAAyB;AAAA,EAA6B;AAAA,EAnCnF,OAuBqC;AAAA;AAAA;AAAA,EAEnB,QAAQ,IAAI,YAAmE;AAAA,EAEhG,aAAa,OAAO,YAAiB,aAA6D;AACjG,UAAM,QAAQ,IAAI,wBAAwB,YAAY,WAAW;AAEjE,UAAM,MAAM,QAAQ;AAEpB,WAAO;AAAA,EACR;AAAA,EAIA,MAAc,UAAyB;AACtC,QAAI;AACH,YAAM,iBAAiB,MAAM,KAAK,YAAY,QAAQ,KAAK,UAAU;AACrE,UAAI,eAAe,UAAU;AAC5B,cAAM,SAAS,QAAQ,eAAe,SACpC,OAAO,WAAS,MAAM,WAAW,EACjC,IAAI,OAAM,uBAAsB;AAGhC,gBAAM,yBAAyB,MAAM,KAAK,YAAY,QAAQ,mBAAmB,QAAQ;AAUzF,cAAI,uBAAuB,UAAU;AACpC,uBAAW,mBAAmB,uBAAuB,UAAU;AAC9D,kBAAI,CAAC,gBAAgB,aAAa;AACjC,qBAAK,IAAI,gBAAgB,QAAQ;AAAA,cAClC;AAAA,YACD;AAAA,UACD;AAAA,QACD,CAAC,CAAC;AAAA,MACJ;AAAA,IACD,SAAS,OAAO;AAAA,IAEhB;AAAA,EACD;AAAA,EAEA,IAAI,UAAe,YAAY,GAAG,MAAqC;AACtE,SAAK,MAAM,IAAI,UAAU;AAAA,MACxB;AAAA,MACA,MAAM,UAAU,IAAI;AAAA,IACrB,CAAC;AAAA,EACF;AAAA,EAEA,OAAO,UAAe,MAAqC;AAC1D,UAAM,QAAQ,KAAK,MAAM,IAAI,QAAQ;AACrC,QAAI,OAAO;AACV,YAAM,OAAO,UAAU,IAAI;AAAA,IAC5B;AAAA,EACD;AAAA,EAEA,QAAgB;AACf,WAAO,KAAK,MAAM;AAAA,EACnB;AAAA,EAEA,IAAI,UAAe,WAAoB,MAAwC;AAC9E,UAAM,QAAQ,KAAK,MAAM,IAAI,QAAQ;AACrC,QAAI,CAAC,OAAO;AACX,aAAO;AAAA,IACR;AAEA,QAAI,OAAO,cAAc,YAAY,cAAc,MAAM,WAAW;AACnE,aAAO;AAAA,IACR;AAEA,QAAI,QAAQ,CAAC,OAAO,MAAM,MAAM,IAAI,GAAG;AACtC,aAAO;AAAA,IACR;AAEA,WAAO;AAAA,EACR;AAAA,EAEA,MAAa;AACZ,WAAO,MAAM,KAAK,KAAK,MAAM,KAAK,CAAC;AAAA,EACpC;AAAA,EAEA,OAAO,UAAqB;AAC3B,SAAK,MAAM,OAAO,QAAQ;AAAA,EAC3B;AAAA,EAEA,QAAc;AACb,SAAK,MAAM,MAAM;AAAA,EAClB;AACD;AAEO,IAAe,2BAAf,cAAgD,WAAgD;AAAA,EAMtG,YACC,qBACwB,aACM,YAC7B;AACD,UAAM;AAHkB;AACM;AAI9B,SAAK,OAAO,KAAK,UAAU,KAAK,WAAW,mBAAmB,CAAC;AAAA,EAChE;AAAA,EApID,OAsHuG;AAAA;AAAA;AAAA,EAI9F;AAAA,EAYA,WAAW,qBAAuG;AACzH,QAAI,qBAAqB;AACxB,aAAO,IAAI,6BAA6B,qBAAqB,KAAK,aAAa,KAAK,UAAU;AAAA,IAC/F;AAEA,WAAO,IAAI,iCAAiC;AAAA,EAC7C;AAAA,EAEA,aAAa,qBAA4C;AAGxD,QAAI,KAAK,gBAAgB,8BAA8B;AACtD,UAAI,qBAAqB;AACxB,aAAK,KAAK,WAAW,mBAAmB;AAAA,MACzC,OAAO;AACN,aAAK,OAAO,IAAI,iCAAiC;AAAA,MAClD;AAAA,IACD;AAAA,EACD;AAAA,EAEA,aAA+B;AAC9B,WAAO,KAAK,KAAK,WAAW;AAAA,EAC7B;AAAA,EAEA,cAAc,YAAoC,WAAoB,MAAwC;AAC7G,WAAO,KAAK,KAAK,cAAc,YAAY,WAAW,IAAI;AAAA,EAC3D;AAAA,EAEA,OAAO,YAAoC,SAAqD,WAAoB,MAA+B,OAA0C;AAC5L,WAAO,KAAK,KAAK,OAAO,YAAY,SAAS,WAAW,MAAM,KAAK;AAAA,EACpE;AAAA,EAEA,cAAc,YAAoC,OAA0C;AAC3F,WAAO,KAAK,KAAK,cAAc,YAAY,KAAK;AAAA,EACjD;AAAA,EAEA,eAAe,QAA8D;AAC5E,WAAO,KAAK,KAAK,eAAe,MAAM;AAAA,EACvC;AAAA,EAEA,aAAgD;AAC/C,WAAO,KAAK,KAAK,WAAW;AAAA,EAC7B;AAAA,EAEA,QAA0C,YAAwF;AACjI,WAAO,KAAK,KAAK,QAAQ,UAAU;AAAA,EACpC;AAAA,EAEA,iBAAiB,YAAyC;AACzD,WAAO,KAAK,KAAK,iBAAiB,UAAU;AAAA,EAC7C;AAAA,EAEA,cAA6B;AAC5B,WAAO,KAAK,KAAK,YAAY;AAAA,EAC9B;AACD;AAvEsB,2BAAf;AAAA,EAQJ;AAAA,EACA;AAAA,GATmB;AAyEtB,IAAM,+BAAN,cAA2C,WAAgD;AAAA,EAc1F,YACS,qBACuB,aACD,YAC7B;AACD,UAAM;AAJE;AACuB;AACD;AAI9B,SAAK,WAAW,mBAAmB;AAAA,EACpC;AAAA,EArND,OA+L2F;AAAA;AAAA;AAAA,EAE1F,OAAwB,sBAAsB;AAAA,EAC9C,OAAwB,+BAA+B,KAAK,WAAW,CAAC;AAAA,EACxE,OAAwB,0BAA0B;AAAA;AAAA,EAClD,OAAwB,sBAAsB;AAAA,EAI7B,oBAAoB,KAAK,UAAU,IAAI,cAAc,CAAC;AAAA;AAAA,EAE/D;AAAA,EACA,QAA6C;AAAA,EAYrD,WAAW,yBAAoC;AAC9C,SAAK,sBAAsB;AAE3B,SAAK,QAAQ,KAAK,aAAa;AAAA,EAChC;AAAA,EAEA,MAAc,eAAiD;AAG9D,SAAK,QAAQ,MAAM,wBAAwB,OAAO,KAAK,qBAAqB,KAAK,WAAW;AAE5F,WAAO,KAAK;AAAA,EACb;AAAA,EAEA,MAAM,aAA+B;AACpC,UAAM,QAAQ,MAAM,KAAK;AAGzB,UAAM,KAAK,YAAY;AAEvB,WAAO,MAAM,MAAM,IAAI;AAAA,EACxB;AAAA,EAEA,cAAc,YAAoC,WAAoB,MAAwC;AAC7G,QAAI,CAAC,KAAK,OAAO;AAChB,aAAO;AAAA,IACR;AAEA,UAAM,iBAAiB,KAAK,iBAAiB,UAAU;AAEvD,WAAO,KAAK,MAAM,IAAI,gBAAgB,WAAW,IAAI;AAAA,EACtD;AAAA,EAEA,MAAM,OAAO,YAAoC,SAAqD,WAAoB,MAA+B,OAA0C;AAClM,UAAM,QAAQ,MAAM,KAAK;AACzB,QAAI,OAAO,yBAAyB;AACnC;AAAA,IACD;AAEA,UAAM,iBAAiB,KAAK,iBAAiB,UAAU;AACvD,QAAI,MAAM,IAAI,gBAAgB,WAAW,IAAI,GAAG;AAE/C;AAAA,IACD;AAEA,WAAO,KAAK,kBAAkB,SAAS,gBAAgB,YAAY;AAClE,UAAI,OAAO,yBAAyB;AACnC;AAAA,MACD;AAEA,UAAI,MAAM,IAAI,gBAAgB,WAAW,IAAI,GAAG;AAI/C;AAAA,MACD;AAKA,UAAI,WAAW,KAAK,eAAe,YAAY,IAAI;AACnD,UAAI,SAAS,UAAU,6BAA6B,qBAAqB;AACxE,mBAAW,KAAK,eAAe,UAAU;AAAA,MAC1C;AAGA,YAAM,iBAAiB,SAAS,WAAW,QAAQ;AACnD,UAAI;AACJ,UAAI,iBAAiB,OAAO,GAAG;AAC9B,uBAAe,qBAAqB,gBAAgB,OAAO;AAAA,MAC5D,WAAW,SAAS;AACnB,uBAAe,uBAAuB,gBAAgB,OAAO;AAAA,MAC9D,OAAO;AACN,uBAAe,SAAS,OAAO,CAAC,gBAAgB,SAAS,WAAW,EAAE,CAAC,CAAC;AAAA,MACzE;AAGA,YAAM,KAAK,YAAY,UAAU,gBAAgB,YAAY;AAQ7D,YAAM,IAAI,gBAAgB,WAAW,IAAI;AAAA,IAC1C,CAAC;AAAA,EACF;AAAA,EAEQ,eAAe,YAAoC,MAAuC;AACjG,WAAO,GAAG,WAAW,SAAS,SAAS,CAAC,GAAG,6BAA6B,uBAAuB,GAAG,KAAK,UAAU,EAAE,GAAG,MAAM,QAAQ,WAAW,OAAO,CAAC,CAAC,GAAG,6BAA6B,mBAAmB;AAAA,EAC5M;AAAA,EAEA,MAAM,eAAe,QAA8D;AAClF,UAAM,QAAQ,MAAM,KAAK;AAGzB,UAAM,SAAS,QAAQ;AACvB,QAAI,MAAM,QAAQ,MAAM,KAAK,OAAO,SAAS,GAAG;AAC/C,YAAM,YAAY,IAAI,YAAqB;AAC3C,iBAAW,qBAAqB,QAAQ;AACvC,kBAAU,IAAI,KAAK,iBAAiB,iBAAiB,GAAG,IAAI;AAAA,MAC7D;AAEA,YAAM,SAAS,QAAQ,MAAM,IAAI,EAAE,IAAI,OAAM,mBAAkB;AAC9D,YAAI,CAAC,UAAU,IAAI,cAAc,GAAG;AACnC,gBAAM,KAAK,gBAAgB,cAAc;AAAA,QAC1C;AAAA,MACD,CAAC,CAAC;AAAA,IACH,OAGK;AACJ,YAAM,KAAK,yBAAyB,KAAK,mBAAmB;AAE5D,YAAM,MAAM;AAAA,IACb;AAAA,EACD;AAAA,EAEA,cAAc,YAAoC,OAA0C;AAC3F,UAAM,iBAAiB,KAAK,iBAAiB,UAAU;AAEvD,WAAO,KAAK,gBAAgB,gBAAgB,KAAK;AAAA,EAClD;AAAA,EAEA,MAAc,gBAAgB,gBAAqB,OAA0C;AAC5F,UAAM,QAAQ,MAAM,KAAK;AACzB,QAAI,OAAO,yBAAyB;AACnC;AAAA,IACD;AAEA,WAAO,KAAK,kBAAkB,SAAS,gBAAgB,YAAY;AAClE,UAAI,OAAO,yBAAyB;AACnC;AAAA,MACD;AAGA,YAAM,KAAK,yBAAyB,cAAc;AAQlD,YAAM,OAAO,cAAc;AAAA,IAC5B,CAAC;AAAA,EACF;AAAA,EAEA,MAAc,yBAAyB,gBAAoC;AAC1E,QAAI;AACH,YAAM,KAAK,YAAY,IAAI,gBAAgB,EAAE,WAAW,KAAK,CAAC;AAAA,IAC/D,SAAS,OAAO;AACf,UAAyB,MAAO,wBAAwB,oBAAoB,gBAAgB;AAC3F,cAAM;AAAA,MACP;AAAA,IACD;AAAA,EACD;AAAA,EAEA,MAAM,aAAgD;AACrD,UAAM,QAAQ,MAAM,KAAK;AAGzB,UAAM,KAAK,YAAY;AAEvB,UAAM,UAAU,MAAM,QAAQ,IAAI,MAAM,IAAI,EAAE,IAAI,oBAAkB,KAAK,kBAAkB,gBAAgB,KAAK,CAAC,CAAC;AAElH,WAAO,SAAS,OAAO;AAAA,EACxB;AAAA,EAEA,MAAc,kBAAkB,gBAAqB,OAA6E;AACjI,QAAI,MAA0C;AAE9C,UAAM,KAAK,kBAAkB,SAAS,gBAAgB,YAAY;AACjE,UAAI,CAAC,MAAM,IAAI,cAAc,GAAG;AAC/B;AAAA,MACD;AAKA,YAAM,iBAAiB,MAAM,KAAK,qBAAqB,gBAAgB,6BAA6B,qBAAqB,6BAA6B,mBAAmB;AACzK,UAAI,CAAC,gBAAgB;AACpB;AAAA,MACD;AAKA,YAAM,iBAAiB,eAAe,QAAQ,6BAA6B,uBAAuB;AAGlG,UAAI;AACJ,UAAI;AACJ,UAAI,iBAAiB,GAAG;AACvB,2BAAmB,eAAe,UAAU,GAAG,cAAc;AAC7D,uBAAe,eAAe,OAAO,iBAAiB,CAAC;AAAA,MACxD,OAAO;AACN,2BAAmB;AACnB,uBAAe;AAAA,MAChB;AAIA,YAAM,EAAE,QAAQ,KAAK,IAAI,KAAK,kBAAkB,YAAY;AAG5D,YAAM,OAAO,gBAAgB,IAAI;AAEjC,YAAM;AAAA,QACL,QAAQ,UAAU;AAAA,QAClB,UAAU,IAAI,MAAM,gBAAgB;AAAA,MACrC;AAAA,IACD,CAAC;AAED,WAAO;AAAA,EACR;AAAA,EAEA,MAAc,qBAAqB,gBAAqB,gBAAwB,oBAAyD;AACxI,UAAM,YAAY,MAAM,KAAK,YAAY,SAAS,gBAAgB,EAAE,QAAQ,mBAAmB,CAAC,GAAG,MAAM,SAAS;AAElH,UAAM,sBAAsB,SAAS,QAAQ,cAAc;AAC3D,QAAI,uBAAuB,GAAG;AAC7B,aAAO,SAAS,OAAO,GAAG,mBAAmB;AAAA,IAC9C;AAGA,WAAO;AAAA,EACR;AAAA,EAEA,MAAM,QAA0C,YAAwF;AACvI,UAAM,iBAAiB,KAAK,iBAAiB,UAAU;AAEvD,UAAM,QAAQ,MAAM,KAAK;AAEzB,QAAI,MAAiD;AAErD,UAAM,KAAK,kBAAkB,SAAS,gBAAgB,YAAY;AACjE,UAAI,CAAC,MAAM,IAAI,cAAc,GAAG;AAC/B;AAAA,MACD;AAIA,YAAM,eAAe,MAAM,KAAK,YAAY,eAAe,cAAc;AACzE,YAAM,qBAAqB,MAAM,WAAW,aAAa,OAAO,CAAC;AACjE,YAAM,mBAAmB,SAAS,OAAO,mBAAmB,MAAM;AAOlE,YAAM,mBAAmB,iBAAiB,OAAO,QAAQ,6BAA6B,4BAA4B;AAClH,UAAI,qBAAqB,IAAI;AAC5B,aAAK,WAAW,MAAM,6CAA6C,cAAc,6CAA6C,aAAa,IAAI,IAAI;AAEnJ,eAAO;AAAA,MACR;AAEA,YAAM,cAAc,iBAAiB,MAAM,GAAG,gBAAgB,EAAE,SAAS;AAGzE,UAAI;AACJ,YAAM,iBAAiB,YAAY,QAAQ,6BAA6B,uBAAuB;AAC/F,UAAI,mBAAmB,IAAI;AAC1B,eAAO,KAAK,kBAAkB,YAAY,OAAO,iBAAiB,CAAC,CAAC,EAAE;AAAA,MACvE;AAGA,YAAM,OAAO,gBAAgB,IAAI;AAGjC,YAAM,kCAAkC,iBAAiB,MAAM,mBAAmB,CAAC;AACnF,UAAI;AACJ,UAAI,mBAAmB,OAAO;AAC7B,gBAAQ,eAAe,+BAA+B;AAAA,MACvD,OAAO;AACN,gBAAQ,qBAAqB,iCAAiC,mBAAmB,MAAM;AAAA,MACxF;AAEA,YAAM,EAAE,OAAO,KAAK;AAAA,IACrB,CAAC;AAED,WAAO;AAAA,EACR;AAAA,EAEQ,kBAAoD,iBAA0F;AACrJ,QAAI,SAA6B;AACjC,QAAI,OAAsB;AAE1B,QAAI,iBAAiB;AACpB,UAAI;AACH,eAAO,KAAK,MAAM,eAAe;AACjC,iBAAS,MAAM;AAIf,YAAI,OAAO,MAAM,WAAW,UAAU;AACrC,iBAAO,KAAK;AAEZ,cAAI,cAAc,IAAI,GAAG;AACxB,mBAAO;AAAA,UACR;AAAA,QACD;AAAA,MACD,SAAS,OAAO;AAAA,MAEhB;AAAA,IACD;AAEA,WAAO,EAAE,QAAQ,KAAK;AAAA,EACvB;AAAA,EAEA,iBAAiB,YAAyC;AACzD,WAAO,SAAS,KAAK,qBAAqB,WAAW,SAAS,QAAQ,eAAe,UAAU,CAAC;AAAA,EACjG;AAAA,EAEA,cAA6B;AAC5B,WAAO,KAAK,kBAAkB,YAAY;AAAA,EAC3C;AACD;AAxVM,+BAAN;AAAA,EAgBG;AAAA,EACA;AAAA,GAjBG;AA0VC,MAAM,yCAAyC,WAAgD;AAAA,EAzhBtG,OAyhBsG;AAAA;AAAA;AAAA,EAI7F,UAAU,IAAI,YAAkF;AAAA,EAExG,cAAc;AACb,UAAM;AAAA,EACP;AAAA,EAEA,MAAM,aAA+B;AACpC,WAAO,KAAK,QAAQ,OAAO;AAAA,EAC5B;AAAA,EAEA,cAAc,YAAoC,WAA6B;AAC9E,UAAM,iBAAiB,KAAK,iBAAiB,UAAU;AAEvD,WAAO,KAAK,QAAQ,IAAI,cAAc;AAAA,EACvC;AAAA,EAEA,MAAM,OAAO,YAAoC,SAAqD,WAAoB,MAA+B,OAA0C;AAClM,UAAM,iBAAiB,KAAK,iBAAiB,UAAU;AACvD,SAAK,QAAQ,IAAI,gBAAgB;AAAA,MAChC,QAAQ,WAAW;AAAA,MACnB,SAAS,mBAAmB,WAAW,UAAU,UAAU,iBAAiB,OAAO,IAAI,MAAM,eAAe,OAAO,IAAI,iBAAiB,OAAO,IAAI,SAAS,WAAW,EAAE;AAAA,MACzK;AAAA,IACD,CAAC;AAAA,EACF;AAAA,EAEA,MAAM,QAA0C,YAAwF;AACvI,UAAM,iBAAiB,KAAK,iBAAiB,UAAU;AACvD,UAAM,SAAS,KAAK,QAAQ,IAAI,cAAc;AAC9C,QAAI,QAAQ;AACX,aAAO,EAAE,OAAO,eAAe,OAAO,OAAO,GAAG,MAAM,OAAO,KAAsB;AAAA,IACpF;AAEA,WAAO;AAAA,EACR;AAAA,EAEA,MAAM,aAAgD;AACrD,WAAO,MAAM,KAAK,KAAK,QAAQ,QAAQ,CAAC,EAAE,IAAI,CAAC,CAAC,UAAU,MAAM,OAAO,EAAE,QAAQ,OAAO,QAAQ,SAAS,EAAE;AAAA,EAC5G;AAAA,EAEA,MAAM,cAAc,YAAmD;AACtE,SAAK,QAAQ,OAAO,KAAK,iBAAiB,UAAU,CAAC;AAAA,EACtD;AAAA,EAEA,MAAM,eAAe,QAA8D;AAClF,UAAM,SAAS,QAAQ;AACvB,QAAI,MAAM,QAAQ,MAAM,KAAK,OAAO,SAAS,GAAG;AAC/C,YAAM,YAAY,IAAI,YAAqB;AAC3C,iBAAW,qBAAqB,QAAQ;AACvC,kBAAU,IAAI,KAAK,iBAAiB,iBAAiB,GAAG,IAAI;AAAA,MAC7D;AAEA,iBAAW,UAAU,MAAM,KAAK,WAAW,GAAG;AAC7C,YAAI,CAAC,UAAU,IAAI,KAAK,iBAAiB,MAAM,CAAC,GAAG;AAClD,gBAAM,KAAK,cAAc,MAAM;AAAA,QAChC;AAAA,MACD;AAAA,IACD,OAAO;AACN,WAAK,QAAQ,MAAM;AAAA,IACpB;AAAA,EACD;AAAA,EAEA,iBAAiB,YAAyC;AACzD,WAAO,IAAI,KAAK,EAAE,QAAQ,QAAQ,UAAU,MAAM,eAAe,UAAU,EAAE,CAAC;AAAA,EAC/E;AAAA,EAEA,MAAM,cAA6B;AAClC;AAAA,EACD;AACD;AAKO,SAAS,eAAe,YAA4C;AAO1E,MAAI;AACJ,MAAI,WAAW,OAAO,SAAS,GAAG;AACjC,UAAM,aAAa,WAAW,WAAW,MAAM;AAC/C,QAAI,WAAW,SAAS,MAAM;AAC7B,iBAAW,SAAS,WAAW,UAAU,UAAU;AAAA,IACpD,OAAO;AACN,iBAAW,WAAW,SAAS,KAAK,EAAE,MAAM,WAAW,CAAC;AAAA,IACzD;AAAA,EACD,OAAO;AACN,eAAW,WAAW;AAAA,EACvB;AAEA,SAAO,SAAS,QAAQ;AACzB;AApBgB;AAsBhB,SAAS,SAAS,UAAuB;AACxC,QAAM,MAAM,SAAS,WAAW,QAAQ,QAAQ,SAAS,WAAW,QAAQ,WAAW,SAAS,SAAS,SAAS,SAAS;AAE3H,SAAO,WAAW,GAAG;AACtB;AAJS;AAMT,SAAS,WAAW,KAAqB;AACxC,SAAO,KAAK,GAAG,EAAE,SAAS,EAAE;AAC7B;AAFS;",
  "names": []
}
