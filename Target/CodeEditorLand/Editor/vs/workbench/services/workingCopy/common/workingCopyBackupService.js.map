{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/workingCopy/common/workingCopyBackupService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { coalesce } from \"../../../../base/common/arrays.js\";\nimport { Promises, ResourceQueue } from \"../../../../base/common/async.js\";\nimport {\n\tVSBuffer,\n\ttype VSBufferReadable,\n\ttype VSBufferReadableStream,\n\tbufferToStream,\n\tprefixedBufferReadable,\n\tprefixedBufferStream,\n\treadableToBuffer,\n\tstreamToBuffer,\n} from \"../../../../base/common/buffer.js\";\nimport type { CancellationToken } from \"../../../../base/common/cancellation.js\";\nimport { hash } from \"../../../../base/common/hash.js\";\nimport { Disposable } from \"../../../../base/common/lifecycle.js\";\nimport { ResourceMap } from \"../../../../base/common/map.js\";\nimport { Schemas } from \"../../../../base/common/network.js\";\nimport { deepClone, equals } from \"../../../../base/common/objects.js\";\nimport { joinPath } from \"../../../../base/common/resources.js\";\nimport {\n\tisReadableStream,\n\tpeekStream,\n} from \"../../../../base/common/stream.js\";\nimport { isEmptyObject } from \"../../../../base/common/types.js\";\nimport { URI } from \"../../../../base/common/uri.js\";\nimport {\n\ttype FileOperationError,\n\tFileOperationResult,\n\tIFileService,\n} from \"../../../../platform/files/common/files.js\";\nimport { ILogService } from \"../../../../platform/log/common/log.js\";\nimport {\n\ttype IWorkingCopyBackupMeta,\n\ttype IWorkingCopyIdentifier,\n\tNO_TYPE_ID,\n} from \"./workingCopy.js\";\nimport type {\n\tIResolvedWorkingCopyBackup,\n\tIWorkingCopyBackupService,\n} from \"./workingCopyBackup.js\";\n\nexport class WorkingCopyBackupsModel {\n\tprivate readonly cache = new ResourceMap<{\n\t\tversionId?: number;\n\t\tmeta?: IWorkingCopyBackupMeta;\n\t}>();\n\n\tstatic async create(\n\t\tbackupRoot: URI,\n\t\tfileService: IFileService,\n\t): Promise<WorkingCopyBackupsModel> {\n\t\tconst model = new WorkingCopyBackupsModel(backupRoot, fileService);\n\n\t\tawait model.resolve();\n\n\t\treturn model;\n\t}\n\n\tprivate constructor(\n\t\tprivate backupRoot: URI,\n\t\tprivate fileService: IFileService,\n\t) {}\n\n\tprivate async resolve(): Promise<void> {\n\t\ttry {\n\t\t\tconst backupRootStat = await this.fileService.resolve(\n\t\t\t\tthis.backupRoot,\n\t\t\t);\n\t\t\tif (backupRootStat.children) {\n\t\t\t\tawait Promises.settled(\n\t\t\t\t\tbackupRootStat.children\n\t\t\t\t\t\t.filter((child) => child.isDirectory)\n\t\t\t\t\t\t.map(async (backupSchemaFolder) => {\n\t\t\t\t\t\t\t// Read backup directory for backups\n\t\t\t\t\t\t\tconst backupSchemaFolderStat =\n\t\t\t\t\t\t\t\tawait this.fileService.resolve(\n\t\t\t\t\t\t\t\t\tbackupSchemaFolder.resource,\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// Remember known backups in our caches\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t// Note: this does NOT account for resolving\n\t\t\t\t\t\t\t// associated meta data because that requires\n\t\t\t\t\t\t\t// opening the backup and reading the meta\n\t\t\t\t\t\t\t// preamble. Instead, when backups are actually\n\t\t\t\t\t\t\t// resolved, the meta data will be added via\n\t\t\t\t\t\t\t// additional `update` calls.\n\t\t\t\t\t\t\tif (backupSchemaFolderStat.children) {\n\t\t\t\t\t\t\t\tfor (const backupForSchema of backupSchemaFolderStat.children) {\n\t\t\t\t\t\t\t\t\tif (!backupForSchema.isDirectory) {\n\t\t\t\t\t\t\t\t\t\tthis.add(backupForSchema.resource);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// ignore any errors\n\t\t}\n\t}\n\n\tadd(resource: URI, versionId = 0, meta?: IWorkingCopyBackupMeta): void {\n\t\tthis.cache.set(resource, {\n\t\t\tversionId,\n\t\t\tmeta: deepClone(meta),\n\t\t});\n\t}\n\n\tupdate(resource: URI, meta?: IWorkingCopyBackupMeta): void {\n\t\tconst entry = this.cache.get(resource);\n\t\tif (entry) {\n\t\t\tentry.meta = deepClone(meta);\n\t\t}\n\t}\n\n\tcount(): number {\n\t\treturn this.cache.size;\n\t}\n\n\thas(\n\t\tresource: URI,\n\t\tversionId?: number,\n\t\tmeta?: IWorkingCopyBackupMeta,\n\t): boolean {\n\t\tconst entry = this.cache.get(resource);\n\t\tif (!entry) {\n\t\t\treturn false; // unknown resource\n\t\t}\n\n\t\tif (typeof versionId === \"number\" && versionId !== entry.versionId) {\n\t\t\treturn false; // different versionId\n\t\t}\n\n\t\tif (meta && !equals(meta, entry.meta)) {\n\t\t\treturn false; // different metadata\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tget(): URI[] {\n\t\treturn Array.from(this.cache.keys());\n\t}\n\n\tremove(resource: URI): void {\n\t\tthis.cache.delete(resource);\n\t}\n\n\tclear(): void {\n\t\tthis.cache.clear();\n\t}\n}\n\nexport abstract class WorkingCopyBackupService\n\textends Disposable\n\timplements IWorkingCopyBackupService\n{\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate impl:\n\t\t| WorkingCopyBackupServiceImpl\n\t\t| InMemoryWorkingCopyBackupService;\n\n\tconstructor(\n\t\tbackupWorkspaceHome: URI | undefined,\n\t\t@IFileService protected fileService: IFileService,\n\t\t@ILogService private readonly logService: ILogService,\n\t) {\n\t\tsuper();\n\n\t\tthis.impl = this._register(this.initialize(backupWorkspaceHome));\n\t}\n\n\tprivate initialize(\n\t\tbackupWorkspaceHome: URI | undefined,\n\t): WorkingCopyBackupServiceImpl | InMemoryWorkingCopyBackupService {\n\t\tif (backupWorkspaceHome) {\n\t\t\treturn new WorkingCopyBackupServiceImpl(\n\t\t\t\tbackupWorkspaceHome,\n\t\t\t\tthis.fileService,\n\t\t\t\tthis.logService,\n\t\t\t);\n\t\t}\n\n\t\treturn new InMemoryWorkingCopyBackupService();\n\t}\n\n\treinitialize(backupWorkspaceHome: URI | undefined): void {\n\t\t// Re-init implementation (unless we are running in-memory)\n\t\tif (this.impl instanceof WorkingCopyBackupServiceImpl) {\n\t\t\tif (backupWorkspaceHome) {\n\t\t\t\tthis.impl.initialize(backupWorkspaceHome);\n\t\t\t} else {\n\t\t\t\tthis.impl = new InMemoryWorkingCopyBackupService();\n\t\t\t}\n\t\t}\n\t}\n\n\thasBackups(): Promise<boolean> {\n\t\treturn this.impl.hasBackups();\n\t}\n\n\thasBackupSync(\n\t\tidentifier: IWorkingCopyIdentifier,\n\t\tversionId?: number,\n\t\tmeta?: IWorkingCopyBackupMeta,\n\t): boolean {\n\t\treturn this.impl.hasBackupSync(identifier, versionId, meta);\n\t}\n\n\tbackup(\n\t\tidentifier: IWorkingCopyIdentifier,\n\t\tcontent?: VSBufferReadableStream | VSBufferReadable,\n\t\tversionId?: number,\n\t\tmeta?: IWorkingCopyBackupMeta,\n\t\ttoken?: CancellationToken,\n\t): Promise<void> {\n\t\treturn this.impl.backup(identifier, content, versionId, meta, token);\n\t}\n\n\tdiscardBackup(\n\t\tidentifier: IWorkingCopyIdentifier,\n\t\ttoken?: CancellationToken,\n\t): Promise<void> {\n\t\treturn this.impl.discardBackup(identifier, token);\n\t}\n\n\tdiscardBackups(filter?: {\n\t\texcept: IWorkingCopyIdentifier[];\n\t}): Promise<void> {\n\t\treturn this.impl.discardBackups(filter);\n\t}\n\n\tgetBackups(): Promise<IWorkingCopyIdentifier[]> {\n\t\treturn this.impl.getBackups();\n\t}\n\n\tresolve<T extends IWorkingCopyBackupMeta>(\n\t\tidentifier: IWorkingCopyIdentifier,\n\t): Promise<IResolvedWorkingCopyBackup<T> | undefined> {\n\t\treturn this.impl.resolve(identifier);\n\t}\n\n\ttoBackupResource(identifier: IWorkingCopyIdentifier): URI {\n\t\treturn this.impl.toBackupResource(identifier);\n\t}\n\n\tjoinBackups(): Promise<void> {\n\t\treturn this.impl.joinBackups();\n\t}\n}\n\nclass WorkingCopyBackupServiceImpl\n\textends Disposable\n\timplements IWorkingCopyBackupService\n{\n\tprivate static readonly PREAMBLE_END_MARKER = \"\\n\";\n\tprivate static readonly PREAMBLE_END_MARKER_CHARCODE = \"\\n\".charCodeAt(0);\n\tprivate static readonly PREAMBLE_META_SEPARATOR = \" \"; // using a character that is know to be escaped in a URI as separator\n\tprivate static readonly PREAMBLE_MAX_LENGTH = 10000;\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly ioOperationQueues = this._register(new ResourceQueue()); // queue IO operations to ensure write/delete file order\n\n\tprivate ready!: Promise<WorkingCopyBackupsModel>;\n\tprivate model: WorkingCopyBackupsModel | undefined = undefined;\n\n\tconstructor(\n\t\tprivate backupWorkspaceHome: URI,\n\t\t@IFileService private readonly fileService: IFileService,\n\t\t@ILogService private readonly logService: ILogService,\n\t) {\n\t\tsuper();\n\n\t\tthis.initialize(backupWorkspaceHome);\n\t}\n\n\tinitialize(backupWorkspaceResource: URI): void {\n\t\tthis.backupWorkspaceHome = backupWorkspaceResource;\n\n\t\tthis.ready = this.doInitialize();\n\t}\n\n\tprivate async doInitialize(): Promise<WorkingCopyBackupsModel> {\n\t\t// Create backup model\n\t\tthis.model = await WorkingCopyBackupsModel.create(\n\t\t\tthis.backupWorkspaceHome,\n\t\t\tthis.fileService,\n\t\t);\n\n\t\treturn this.model;\n\t}\n\n\tasync hasBackups(): Promise<boolean> {\n\t\tconst model = await this.ready;\n\n\t\t// Ensure to await any pending backup operations\n\t\tawait this.joinBackups();\n\n\t\treturn model.count() > 0;\n\t}\n\n\thasBackupSync(\n\t\tidentifier: IWorkingCopyIdentifier,\n\t\tversionId?: number,\n\t\tmeta?: IWorkingCopyBackupMeta,\n\t): boolean {\n\t\tif (!this.model) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst backupResource = this.toBackupResource(identifier);\n\n\t\treturn this.model.has(backupResource, versionId, meta);\n\t}\n\n\tasync backup(\n\t\tidentifier: IWorkingCopyIdentifier,\n\t\tcontent?: VSBufferReadable | VSBufferReadableStream,\n\t\tversionId?: number,\n\t\tmeta?: IWorkingCopyBackupMeta,\n\t\ttoken?: CancellationToken,\n\t): Promise<void> {\n\t\tconst model = await this.ready;\n\t\tif (token?.isCancellationRequested) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst backupResource = this.toBackupResource(identifier);\n\t\tif (model.has(backupResource, versionId, meta)) {\n\t\t\t// return early if backup version id matches requested one\n\t\t\treturn;\n\t\t}\n\n\t\treturn this.ioOperationQueues.queueFor(backupResource, async () => {\n\t\t\tif (token?.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (model.has(backupResource, versionId, meta)) {\n\t\t\t\t// return early if backup version id matches requested one\n\t\t\t\t// this can happen when multiple backup IO operations got\n\t\t\t\t// scheduled, racing against each other.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Encode as: Resource + META-START + Meta + END\n\t\t\t// and respect max length restrictions in case\n\t\t\t// meta is too large.\n\t\t\tlet preamble = this.createPreamble(identifier, meta);\n\t\t\tif (\n\t\t\t\tpreamble.length >=\n\t\t\t\tWorkingCopyBackupServiceImpl.PREAMBLE_MAX_LENGTH\n\t\t\t) {\n\t\t\t\tpreamble = this.createPreamble(identifier);\n\t\t\t}\n\n\t\t\t// Update backup with value\n\t\t\tconst preambleBuffer = VSBuffer.fromString(preamble);\n\t\t\tlet backupBuffer:\n\t\t\t\t| VSBuffer\n\t\t\t\t| VSBufferReadableStream\n\t\t\t\t| VSBufferReadable;\n\t\t\tif (isReadableStream(content)) {\n\t\t\t\tbackupBuffer = prefixedBufferStream(preambleBuffer, content);\n\t\t\t} else if (content) {\n\t\t\t\tbackupBuffer = prefixedBufferReadable(preambleBuffer, content);\n\t\t\t} else {\n\t\t\t\tbackupBuffer = VSBuffer.concat([\n\t\t\t\t\tpreambleBuffer,\n\t\t\t\t\tVSBuffer.fromString(\"\"),\n\t\t\t\t]);\n\t\t\t}\n\n\t\t\t// Write backup via file service\n\t\t\tawait this.fileService.writeFile(backupResource, backupBuffer);\n\n\t\t\t//\n\t\t\t// Update model\n\t\t\t//\n\t\t\t// Note: not checking for cancellation here because a successful\n\t\t\t// write into the backup file should be noted in the model to\n\t\t\t// prevent the model being out of sync with the backup file\n\t\t\tmodel.add(backupResource, versionId, meta);\n\t\t});\n\t}\n\n\tprivate createPreamble(\n\t\tidentifier: IWorkingCopyIdentifier,\n\t\tmeta?: IWorkingCopyBackupMeta,\n\t): string {\n\t\treturn `${identifier.resource.toString()}${WorkingCopyBackupServiceImpl.PREAMBLE_META_SEPARATOR}${JSON.stringify({ ...meta, typeId: identifier.typeId })}${WorkingCopyBackupServiceImpl.PREAMBLE_END_MARKER}`;\n\t}\n\n\tasync discardBackups(filter?: {\n\t\texcept: IWorkingCopyIdentifier[];\n\t}): Promise<void> {\n\t\tconst model = await this.ready;\n\n\t\t// Discard all but some backups\n\t\tconst except = filter?.except;\n\t\tif (Array.isArray(except) && except.length > 0) {\n\t\t\tconst exceptMap = new ResourceMap<boolean>();\n\t\t\tfor (const exceptWorkingCopy of except) {\n\t\t\t\texceptMap.set(this.toBackupResource(exceptWorkingCopy), true);\n\t\t\t}\n\n\t\t\tawait Promises.settled(\n\t\t\t\tmodel.get().map(async (backupResource) => {\n\t\t\t\t\tif (!exceptMap.has(backupResource)) {\n\t\t\t\t\t\tawait this.doDiscardBackup(backupResource);\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\t// Discard all backups\n\t\telse {\n\t\t\tawait this.deleteIgnoreFileNotFound(this.backupWorkspaceHome);\n\n\t\t\tmodel.clear();\n\t\t}\n\t}\n\n\tdiscardBackup(\n\t\tidentifier: IWorkingCopyIdentifier,\n\t\ttoken?: CancellationToken,\n\t): Promise<void> {\n\t\tconst backupResource = this.toBackupResource(identifier);\n\n\t\treturn this.doDiscardBackup(backupResource, token);\n\t}\n\n\tprivate async doDiscardBackup(\n\t\tbackupResource: URI,\n\t\ttoken?: CancellationToken,\n\t): Promise<void> {\n\t\tconst model = await this.ready;\n\t\tif (token?.isCancellationRequested) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn this.ioOperationQueues.queueFor(backupResource, async () => {\n\t\t\tif (token?.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Delete backup file ignoring any file not found errors\n\t\t\tawait this.deleteIgnoreFileNotFound(backupResource);\n\n\t\t\t//\n\t\t\t// Update model\n\t\t\t//\n\t\t\t// Note: not checking for cancellation here because a successful\n\t\t\t// delete of the backup file should be noted in the model to\n\t\t\t// prevent the model being out of sync with the backup file\n\t\t\tmodel.remove(backupResource);\n\t\t});\n\t}\n\n\tprivate async deleteIgnoreFileNotFound(backupResource: URI): Promise<void> {\n\t\ttry {\n\t\t\tawait this.fileService.del(backupResource, { recursive: true });\n\t\t} catch (error) {\n\t\t\tif (\n\t\t\t\t(<FileOperationError>error).fileOperationResult !==\n\t\t\t\tFileOperationResult.FILE_NOT_FOUND\n\t\t\t) {\n\t\t\t\tthrow error; // re-throw any other error than file not found which is OK\n\t\t\t}\n\t\t}\n\t}\n\n\tasync getBackups(): Promise<IWorkingCopyIdentifier[]> {\n\t\tconst model = await this.ready;\n\n\t\t// Ensure to await any pending backup operations\n\t\tawait this.joinBackups();\n\n\t\tconst backups = await Promise.all(\n\t\t\tmodel\n\t\t\t\t.get()\n\t\t\t\t.map((backupResource) =>\n\t\t\t\t\tthis.resolveIdentifier(backupResource, model),\n\t\t\t\t),\n\t\t);\n\n\t\treturn coalesce(backups);\n\t}\n\n\tprivate async resolveIdentifier(\n\t\tbackupResource: URI,\n\t\tmodel: WorkingCopyBackupsModel,\n\t): Promise<IWorkingCopyIdentifier | undefined> {\n\t\tlet res: IWorkingCopyIdentifier | undefined;\n\n\t\tawait this.ioOperationQueues.queueFor(backupResource, async () => {\n\t\t\tif (!model.has(backupResource)) {\n\t\t\t\treturn; // require backup to be present\n\t\t\t}\n\n\t\t\t// Read the entire backup preamble by reading up to\n\t\t\t// `PREAMBLE_MAX_LENGTH` in the backup file until\n\t\t\t// the `PREAMBLE_END_MARKER` is found\n\t\t\tconst backupPreamble = await this.readToMatchingString(\n\t\t\t\tbackupResource,\n\t\t\t\tWorkingCopyBackupServiceImpl.PREAMBLE_END_MARKER,\n\t\t\t\tWorkingCopyBackupServiceImpl.PREAMBLE_MAX_LENGTH,\n\t\t\t);\n\t\t\tif (!backupPreamble) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Figure out the offset in the preamble where meta\n\t\t\t// information possibly starts. This can be `-1` for\n\t\t\t// older backups without meta.\n\t\t\tconst metaStartIndex = backupPreamble.indexOf(\n\t\t\t\tWorkingCopyBackupServiceImpl.PREAMBLE_META_SEPARATOR,\n\t\t\t);\n\n\t\t\t// Extract the preamble content for resource and meta\n\t\t\tlet resourcePreamble: string;\n\t\t\tlet metaPreamble: string | undefined;\n\t\t\tif (metaStartIndex > 0) {\n\t\t\t\tresourcePreamble = backupPreamble.substring(0, metaStartIndex);\n\t\t\t\tmetaPreamble = backupPreamble.substr(metaStartIndex + 1);\n\t\t\t} else {\n\t\t\t\tresourcePreamble = backupPreamble;\n\t\t\t\tmetaPreamble = undefined;\n\t\t\t}\n\n\t\t\t// Try to parse the meta preamble for figuring out\n\t\t\t// `typeId` and `meta` if defined.\n\t\t\tconst { typeId, meta } = this.parsePreambleMeta(metaPreamble);\n\n\t\t\t// Update model entry with now resolved meta\n\t\t\tmodel.update(backupResource, meta);\n\n\t\t\tres = {\n\t\t\t\ttypeId: typeId ?? NO_TYPE_ID,\n\t\t\t\tresource: URI.parse(resourcePreamble),\n\t\t\t};\n\t\t});\n\n\t\treturn res;\n\t}\n\n\tprivate async readToMatchingString(\n\t\tbackupResource: URI,\n\t\tmatchingString: string,\n\t\tmaximumBytesToRead: number,\n\t): Promise<string | undefined> {\n\t\tconst contents = (\n\t\t\tawait this.fileService.readFile(backupResource, {\n\t\t\t\tlength: maximumBytesToRead,\n\t\t\t})\n\t\t).value.toString();\n\n\t\tconst matchingStringIndex = contents.indexOf(matchingString);\n\t\tif (matchingStringIndex >= 0) {\n\t\t\treturn contents.substr(0, matchingStringIndex);\n\t\t}\n\n\t\t// Unable to find matching string in file\n\t\treturn undefined;\n\t}\n\n\tasync resolve<T extends IWorkingCopyBackupMeta>(\n\t\tidentifier: IWorkingCopyIdentifier,\n\t): Promise<IResolvedWorkingCopyBackup<T> | undefined> {\n\t\tconst backupResource = this.toBackupResource(identifier);\n\n\t\tconst model = await this.ready;\n\n\t\tlet res: IResolvedWorkingCopyBackup<T> | undefined;\n\n\t\tawait this.ioOperationQueues.queueFor(backupResource, async () => {\n\t\t\tif (!model.has(backupResource)) {\n\t\t\t\treturn; // require backup to be present\n\t\t\t}\n\n\t\t\t// Load the backup content and peek into the first chunk\n\t\t\t// to be able to resolve the meta data\n\t\t\tconst backupStream =\n\t\t\t\tawait this.fileService.readFileStream(backupResource);\n\t\t\tconst peekedBackupStream = await peekStream(backupStream.value, 1);\n\t\t\tconst firstBackupChunk = VSBuffer.concat(peekedBackupStream.buffer);\n\n\t\t\t// We have seen reports (e.g. https://github.com/microsoft/vscode/issues/78500) where\n\t\t\t// if VSCode goes down while writing the backup file, the file can turn empty because\n\t\t\t// it always first gets truncated and then written to. In this case, we will not find\n\t\t\t// the meta-end marker ('\\n') and as such the backup can only be invalid. We bail out\n\t\t\t// here if that is the case.\n\t\t\tconst preambleEndIndex = firstBackupChunk.buffer.indexOf(\n\t\t\t\tWorkingCopyBackupServiceImpl.PREAMBLE_END_MARKER_CHARCODE,\n\t\t\t);\n\t\t\tif (preambleEndIndex === -1) {\n\t\t\t\tthis.logService.trace(\n\t\t\t\t\t`Backup: Could not find meta end marker in ${backupResource}. The file is probably corrupt (filesize: ${backupStream.size}).`,\n\t\t\t\t);\n\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst preambelRaw = firstBackupChunk\n\t\t\t\t.slice(0, preambleEndIndex)\n\t\t\t\t.toString();\n\n\t\t\t// Extract meta data (if any)\n\t\t\tlet meta: T | undefined;\n\t\t\tconst metaStartIndex = preambelRaw.indexOf(\n\t\t\t\tWorkingCopyBackupServiceImpl.PREAMBLE_META_SEPARATOR,\n\t\t\t);\n\t\t\tif (metaStartIndex !== -1) {\n\t\t\t\tmeta = this.parsePreambleMeta(\n\t\t\t\t\tpreambelRaw.substr(metaStartIndex + 1),\n\t\t\t\t).meta as T;\n\t\t\t}\n\n\t\t\t// Update model entry with now resolved meta\n\t\t\tmodel.update(backupResource, meta);\n\n\t\t\t// Build a new stream without the preamble\n\t\t\tconst firstBackupChunkWithoutPreamble = firstBackupChunk.slice(\n\t\t\t\tpreambleEndIndex + 1,\n\t\t\t);\n\t\t\tlet value: VSBufferReadableStream;\n\t\t\tif (peekedBackupStream.ended) {\n\t\t\t\tvalue = bufferToStream(firstBackupChunkWithoutPreamble);\n\t\t\t} else {\n\t\t\t\tvalue = prefixedBufferStream(\n\t\t\t\t\tfirstBackupChunkWithoutPreamble,\n\t\t\t\t\tpeekedBackupStream.stream,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tres = { value, meta };\n\t\t});\n\n\t\treturn res;\n\t}\n\n\tprivate parsePreambleMeta<T extends IWorkingCopyBackupMeta>(\n\t\tpreambleMetaRaw: string | undefined,\n\t): { typeId: string | undefined; meta: T | undefined } {\n\t\tlet typeId: string | undefined;\n\t\tlet meta: T | undefined;\n\n\t\tif (preambleMetaRaw) {\n\t\t\ttry {\n\t\t\t\tmeta = JSON.parse(preambleMetaRaw);\n\t\t\t\ttypeId = meta?.typeId;\n\n\t\t\t\t// `typeId` is a property that we add so we\n\t\t\t\t// remove it when returning to clients.\n\t\t\t\tif (typeof meta?.typeId === \"string\") {\n\t\t\t\t\tdelete meta.typeId;\n\n\t\t\t\t\tif (isEmptyObject(meta)) {\n\t\t\t\t\t\tmeta = undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\t// ignore JSON parse errors\n\t\t\t}\n\t\t}\n\n\t\treturn { typeId, meta };\n\t}\n\n\ttoBackupResource(identifier: IWorkingCopyIdentifier): URI {\n\t\treturn joinPath(\n\t\t\tthis.backupWorkspaceHome,\n\t\t\tidentifier.resource.scheme,\n\t\t\thashIdentifier(identifier),\n\t\t);\n\t}\n\n\tjoinBackups(): Promise<void> {\n\t\treturn this.ioOperationQueues.whenDrained();\n\t}\n}\n\nexport class InMemoryWorkingCopyBackupService\n\textends Disposable\n\timplements IWorkingCopyBackupService\n{\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate backups = new ResourceMap<{\n\t\ttypeId: string;\n\t\tcontent: VSBuffer;\n\t\tmeta?: IWorkingCopyBackupMeta;\n\t}>();\n\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\tasync hasBackups(): Promise<boolean> {\n\t\treturn this.backups.size > 0;\n\t}\n\n\thasBackupSync(\n\t\tidentifier: IWorkingCopyIdentifier,\n\t\tversionId?: number,\n\t): boolean {\n\t\tconst backupResource = this.toBackupResource(identifier);\n\n\t\treturn this.backups.has(backupResource);\n\t}\n\n\tasync backup(\n\t\tidentifier: IWorkingCopyIdentifier,\n\t\tcontent?: VSBufferReadable | VSBufferReadableStream,\n\t\tversionId?: number,\n\t\tmeta?: IWorkingCopyBackupMeta,\n\t\ttoken?: CancellationToken,\n\t): Promise<void> {\n\t\tconst backupResource = this.toBackupResource(identifier);\n\t\tthis.backups.set(backupResource, {\n\t\t\ttypeId: identifier.typeId,\n\t\t\tcontent:\n\t\t\t\tcontent instanceof VSBuffer\n\t\t\t\t\t? content\n\t\t\t\t\t: content\n\t\t\t\t\t\t? isReadableStream(content)\n\t\t\t\t\t\t\t? await streamToBuffer(content)\n\t\t\t\t\t\t\t: readableToBuffer(content)\n\t\t\t\t\t\t: VSBuffer.fromString(\"\"),\n\t\t\tmeta,\n\t\t});\n\t}\n\n\tasync resolve<T extends IWorkingCopyBackupMeta>(\n\t\tidentifier: IWorkingCopyIdentifier,\n\t): Promise<IResolvedWorkingCopyBackup<T> | undefined> {\n\t\tconst backupResource = this.toBackupResource(identifier);\n\t\tconst backup = this.backups.get(backupResource);\n\t\tif (backup) {\n\t\t\treturn {\n\t\t\t\tvalue: bufferToStream(backup.content),\n\t\t\t\tmeta: backup.meta as T | undefined,\n\t\t\t};\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tasync getBackups(): Promise<IWorkingCopyIdentifier[]> {\n\t\treturn Array.from(this.backups.entries()).map(([resource, backup]) => ({\n\t\t\ttypeId: backup.typeId,\n\t\t\tresource,\n\t\t}));\n\t}\n\n\tasync discardBackup(identifier: IWorkingCopyIdentifier): Promise<void> {\n\t\tthis.backups.delete(this.toBackupResource(identifier));\n\t}\n\n\tasync discardBackups(filter?: {\n\t\texcept: IWorkingCopyIdentifier[];\n\t}): Promise<void> {\n\t\tconst except = filter?.except;\n\t\tif (Array.isArray(except) && except.length > 0) {\n\t\t\tconst exceptMap = new ResourceMap<boolean>();\n\t\t\tfor (const exceptWorkingCopy of except) {\n\t\t\t\texceptMap.set(this.toBackupResource(exceptWorkingCopy), true);\n\t\t\t}\n\n\t\t\tfor (const backup of await this.getBackups()) {\n\t\t\t\tif (!exceptMap.has(this.toBackupResource(backup))) {\n\t\t\t\t\tawait this.discardBackup(backup);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthis.backups.clear();\n\t\t}\n\t}\n\n\ttoBackupResource(identifier: IWorkingCopyIdentifier): URI {\n\t\treturn URI.from({\n\t\t\tscheme: Schemas.inMemory,\n\t\t\tpath: hashIdentifier(identifier),\n\t\t});\n\t}\n\n\tasync joinBackups(): Promise<void> {\n\t\treturn;\n\t}\n}\n\n/*\n * Exported only for testing\n */\nexport function hashIdentifier(identifier: IWorkingCopyIdentifier): string {\n\t// IMPORTANT: for backwards compatibility, ensure that\n\t// we ignore the `typeId` unless a value is provided.\n\t// To preserve previous backups without type id, we\n\t// need to just hash the resource. Otherwise we use\n\t// the type id as a seed to the resource path.\n\tlet resource: URI;\n\tif (identifier.typeId.length > 0) {\n\t\tconst typeIdHash = hashString(identifier.typeId);\n\t\tif (identifier.resource.path) {\n\t\t\tresource = joinPath(identifier.resource, typeIdHash);\n\t\t} else {\n\t\t\tresource = identifier.resource.with({ path: typeIdHash });\n\t\t}\n\t} else {\n\t\tresource = identifier.resource;\n\t}\n\n\treturn hashPath(resource);\n}\n\nfunction hashPath(resource: URI): string {\n\tconst str =\n\t\tresource.scheme === Schemas.file || resource.scheme === Schemas.untitled\n\t\t\t? resource.fsPath\n\t\t\t: resource.toString();\n\n\treturn hashString(str);\n}\n\nfunction hashString(str: string): string {\n\treturn hash(str).toString(16);\n}\n"],
  "mappings": "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",
  "names": []
}
