{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/workingCopy/common/workingCopyHistoryService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { localize } from '../../../../nls.js';\nimport { Event, Emitter } from '../../../../base/common/event.js';\nimport { assertIsDefined } from '../../../../base/common/types.js';\nimport { Registry } from '../../../../platform/registry/common/platform.js';\nimport { IWorkbenchContributionsRegistry, Extensions as WorkbenchExtensions } from '../../../common/contributions.js';\nimport { ILifecycleService, LifecyclePhase, WillShutdownEvent } from '../../lifecycle/common/lifecycle.js';\nimport { WorkingCopyHistoryTracker } from './workingCopyHistoryTracker.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { IWorkingCopyHistoryEntry, IWorkingCopyHistoryEntryDescriptor, IWorkingCopyHistoryEvent, IWorkingCopyHistoryService, MAX_PARALLEL_HISTORY_IO_OPS } from './workingCopyHistory.js';\nimport { FileOperationError, FileOperationResult, IFileService, IFileStatWithMetadata } from '../../../../platform/files/common/files.js';\nimport { IRemoteAgentService } from '../../remote/common/remoteAgentService.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { DeferredPromise, Limiter, RunOnceScheduler } from '../../../../base/common/async.js';\nimport { dirname, extname, isEqual, joinPath } from '../../../../base/common/resources.js';\nimport { IWorkbenchEnvironmentService } from '../../environment/common/environmentService.js';\nimport { hash } from '../../../../base/common/hash.js';\nimport { indexOfPath, randomPath } from '../../../../base/common/extpath.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { ResourceMap } from '../../../../base/common/map.js';\nimport { IUriIdentityService } from '../../../../platform/uriIdentity/common/uriIdentity.js';\nimport { ILabelService } from '../../../../platform/label/common/label.js';\nimport { VSBuffer } from '../../../../base/common/buffer.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { SaveSource, SaveSourceRegistry } from '../../../common/editor.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { distinct } from '../../../../base/common/arrays.js';\nimport { escapeRegExpCharacters } from '../../../../base/common/strings.js';\n\ninterface ISerializedWorkingCopyHistoryModel {\n\treadonly version: number;\n\treadonly resource: string;\n\treadonly entries: ISerializedWorkingCopyHistoryModelEntry[];\n}\n\ninterface ISerializedWorkingCopyHistoryModelEntry {\n\treadonly id: string;\n\treadonly timestamp: number;\n\treadonly source?: SaveSource;\n\treadonly sourceDescription?: string;\n}\n\nexport interface IWorkingCopyHistoryModelOptions {\n\n\t/**\n\t * Whether to flush when the model changes. If not\n\t * configured, `model.store()` has to be called\n\t * explicitly.\n\t */\n\tflushOnChange: boolean;\n}\n\nexport class WorkingCopyHistoryModel {\n\n\tstatic readonly ENTRIES_FILE = 'entries.json';\n\n\tprivate static readonly FILE_SAVED_SOURCE = SaveSourceRegistry.registerSource('default.source', localize('default.source', \"File Saved\"));\n\n\tprivate static readonly SETTINGS = {\n\t\tMAX_ENTRIES: 'workbench.localHistory.maxFileEntries',\n\t\tMERGE_PERIOD: 'workbench.localHistory.mergeWindow'\n\t};\n\n\tprivate entries: IWorkingCopyHistoryEntry[] = [];\n\n\tprivate whenResolved: Promise<void> | undefined = undefined;\n\n\tprivate workingCopyResource: URI | undefined = undefined;\n\tprivate workingCopyName: string | undefined = undefined;\n\n\tprivate historyEntriesFolder: URI | undefined = undefined;\n\tprivate historyEntriesListingFile: URI | undefined = undefined;\n\n\tprivate historyEntriesNameMatcher: RegExp | undefined = undefined;\n\n\tprivate versionId = 0;\n\tprivate storedVersionId = this.versionId;\n\n\tprivate readonly storeLimiter = new Limiter(1);\n\n\tconstructor(\n\t\tworkingCopyResource: URI,\n\t\tprivate readonly historyHome: URI,\n\t\tprivate readonly entryAddedEmitter: Emitter<IWorkingCopyHistoryEvent>,\n\t\tprivate readonly entryChangedEmitter: Emitter<IWorkingCopyHistoryEvent>,\n\t\tprivate readonly entryReplacedEmitter: Emitter<IWorkingCopyHistoryEvent>,\n\t\tprivate readonly entryRemovedEmitter: Emitter<IWorkingCopyHistoryEvent>,\n\t\tprivate readonly options: IWorkingCopyHistoryModelOptions,\n\t\tprivate readonly fileService: IFileService,\n\t\tprivate readonly labelService: ILabelService,\n\t\tprivate readonly logService: ILogService,\n\t\tprivate readonly configurationService: IConfigurationService\n\t) {\n\t\tthis.setWorkingCopy(workingCopyResource);\n\t}\n\n\tprivate setWorkingCopy(workingCopyResource: URI): void {\n\n\t\t// Update working copy\n\t\tthis.workingCopyResource = workingCopyResource;\n\t\tthis.workingCopyName = this.labelService.getUriBasenameLabel(workingCopyResource);\n\n\t\tthis.historyEntriesNameMatcher = new RegExp(`[A-Za-z0-9]{4}${escapeRegExpCharacters(extname(workingCopyResource))}`);\n\n\t\t// Update locations\n\t\tthis.historyEntriesFolder = this.toHistoryEntriesFolder(this.historyHome, workingCopyResource);\n\t\tthis.historyEntriesListingFile = joinPath(this.historyEntriesFolder, WorkingCopyHistoryModel.ENTRIES_FILE);\n\n\t\t// Reset entries and resolved cache\n\t\tthis.entries = [];\n\t\tthis.whenResolved = undefined;\n\t}\n\n\tprivate toHistoryEntriesFolder(historyHome: URI, workingCopyResource: URI): URI {\n\t\treturn joinPath(historyHome, hash(workingCopyResource.toString()).toString(16));\n\t}\n\n\tasync addEntry(source = WorkingCopyHistoryModel.FILE_SAVED_SOURCE, sourceDescription: string | undefined = undefined, timestamp = Date.now(), token: CancellationToken): Promise<IWorkingCopyHistoryEntry> {\n\t\tlet entryToReplace: IWorkingCopyHistoryEntry | undefined = undefined;\n\n\t\t// Figure out if the last entry should be replaced based\n\t\t// on settings that can define a interval for when an\n\t\t// entry is not added as new entry but should replace.\n\t\t// However, when save source is different, never replace.\n\t\tconst lastEntry = this.entries.at(-1);\n\t\tif (lastEntry && lastEntry.source === source) {\n\t\t\tconst configuredReplaceInterval = this.configurationService.getValue<number>(WorkingCopyHistoryModel.SETTINGS.MERGE_PERIOD, { resource: this.workingCopyResource });\n\t\t\tif (timestamp - lastEntry.timestamp <= (configuredReplaceInterval * 1000 /* convert to millies */)) {\n\t\t\t\tentryToReplace = lastEntry;\n\t\t\t}\n\t\t}\n\n\t\tlet entry: IWorkingCopyHistoryEntry;\n\n\t\t// Replace lastest entry in history\n\t\tif (entryToReplace) {\n\t\t\tentry = await this.doReplaceEntry(entryToReplace, source, sourceDescription, timestamp, token);\n\t\t}\n\n\t\t// Add entry to history\n\t\telse {\n\t\t\tentry = await this.doAddEntry(source, sourceDescription, timestamp, token);\n\t\t}\n\n\t\t// Flush now if configured\n\t\tif (this.options.flushOnChange && !token.isCancellationRequested) {\n\t\t\tawait this.store(token);\n\t\t}\n\n\t\treturn entry;\n\t}\n\n\tprivate async doAddEntry(source: SaveSource, sourceDescription: string | undefined = undefined, timestamp: number, token: CancellationToken): Promise<IWorkingCopyHistoryEntry> {\n\t\tconst workingCopyResource = assertIsDefined(this.workingCopyResource);\n\t\tconst workingCopyName = assertIsDefined(this.workingCopyName);\n\t\tconst historyEntriesFolder = assertIsDefined(this.historyEntriesFolder);\n\n\t\t// Perform a fast clone operation with minimal overhead to a new random location\n\t\tconst id = `${randomPath(undefined, undefined, 4)}${extname(workingCopyResource)}`;\n\t\tconst location = joinPath(historyEntriesFolder, id);\n\t\tawait this.fileService.cloneFile(workingCopyResource, location);\n\n\t\t// Add to list of entries\n\t\tconst entry: IWorkingCopyHistoryEntry = {\n\t\t\tid,\n\t\t\tworkingCopy: { resource: workingCopyResource, name: workingCopyName },\n\t\t\tlocation,\n\t\t\ttimestamp,\n\t\t\tsource,\n\t\t\tsourceDescription\n\t\t};\n\t\tthis.entries.push(entry);\n\n\t\t// Update version ID of model to use for storing later\n\t\tthis.versionId++;\n\n\t\t// Events\n\t\tthis.entryAddedEmitter.fire({ entry });\n\n\t\treturn entry;\n\t}\n\n\tprivate async doReplaceEntry(entry: IWorkingCopyHistoryEntry, source: SaveSource, sourceDescription: string | undefined = undefined, timestamp: number, token: CancellationToken): Promise<IWorkingCopyHistoryEntry> {\n\t\tconst workingCopyResource = assertIsDefined(this.workingCopyResource);\n\n\t\t// Perform a fast clone operation with minimal overhead to the existing location\n\t\tawait this.fileService.cloneFile(workingCopyResource, entry.location);\n\n\t\t// Update entry\n\t\tentry.source = source;\n\t\tentry.sourceDescription = sourceDescription;\n\t\tentry.timestamp = timestamp;\n\n\t\t// Update version ID of model to use for storing later\n\t\tthis.versionId++;\n\n\t\t// Events\n\t\tthis.entryReplacedEmitter.fire({ entry });\n\n\t\treturn entry;\n\t}\n\n\tasync removeEntry(entry: IWorkingCopyHistoryEntry, token: CancellationToken): Promise<boolean> {\n\n\t\t// Make sure to await resolving when removing entries\n\t\tawait this.resolveEntriesOnce();\n\n\t\tif (token.isCancellationRequested) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst index = this.entries.indexOf(entry);\n\t\tif (index === -1) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Delete from disk\n\t\tawait this.deleteEntry(entry);\n\n\t\t// Remove from model\n\t\tthis.entries.splice(index, 1);\n\n\t\t// Update version ID of model to use for storing later\n\t\tthis.versionId++;\n\n\t\t// Events\n\t\tthis.entryRemovedEmitter.fire({ entry });\n\n\t\t// Flush now if configured\n\t\tif (this.options.flushOnChange && !token.isCancellationRequested) {\n\t\t\tawait this.store(token);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tasync updateEntry(entry: IWorkingCopyHistoryEntry, properties: { source: SaveSource }, token: CancellationToken): Promise<void> {\n\n\t\t// Make sure to await resolving when updating entries\n\t\tawait this.resolveEntriesOnce();\n\n\t\tif (token.isCancellationRequested) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst index = this.entries.indexOf(entry);\n\t\tif (index === -1) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Update entry\n\t\tentry.source = properties.source;\n\n\t\t// Update version ID of model to use for storing later\n\t\tthis.versionId++;\n\n\t\t// Events\n\t\tthis.entryChangedEmitter.fire({ entry });\n\n\t\t// Flush now if configured\n\t\tif (this.options.flushOnChange && !token.isCancellationRequested) {\n\t\t\tawait this.store(token);\n\t\t}\n\t}\n\n\tasync getEntries(): Promise<readonly IWorkingCopyHistoryEntry[]> {\n\n\t\t// Make sure to await resolving when all entries are asked for\n\t\tawait this.resolveEntriesOnce();\n\n\t\t// Return as many entries as configured by user settings\n\t\tconst configuredMaxEntries = this.configurationService.getValue<number>(WorkingCopyHistoryModel.SETTINGS.MAX_ENTRIES, { resource: this.workingCopyResource });\n\t\tif (this.entries.length > configuredMaxEntries) {\n\t\t\treturn this.entries.slice(this.entries.length - configuredMaxEntries);\n\t\t}\n\n\t\treturn this.entries;\n\t}\n\n\tasync hasEntries(skipResolve: boolean): Promise<boolean> {\n\n\t\t// Make sure to await resolving unless explicitly skipped\n\t\tif (!skipResolve) {\n\t\t\tawait this.resolveEntriesOnce();\n\t\t}\n\n\t\treturn this.entries.length > 0;\n\t}\n\n\tprivate resolveEntriesOnce(): Promise<void> {\n\t\tif (!this.whenResolved) {\n\t\t\tthis.whenResolved = this.doResolveEntries();\n\t\t}\n\n\t\treturn this.whenResolved;\n\t}\n\n\tprivate async doResolveEntries(): Promise<void> {\n\n\t\t// Resolve from disk\n\t\tconst entries = await this.resolveEntriesFromDisk();\n\n\t\t// We now need to merge our in-memory entries with the\n\t\t// entries we have found on disk because it is possible\n\t\t// that new entries have been added before the entries\n\t\t// listing file was updated\n\t\tfor (const entry of this.entries) {\n\t\t\tentries.set(entry.id, entry);\n\t\t}\n\n\t\t// Set as entries, sorted by timestamp\n\t\tthis.entries = Array.from(entries.values()).sort((entryA, entryB) => entryA.timestamp - entryB.timestamp);\n\t}\n\n\tprivate async resolveEntriesFromDisk(): Promise<Map<string /* ID */, IWorkingCopyHistoryEntry>> {\n\t\tconst workingCopyResource = assertIsDefined(this.workingCopyResource);\n\t\tconst workingCopyName = assertIsDefined(this.workingCopyName);\n\n\t\tconst [entryListing, entryStats] = await Promise.all([\n\n\t\t\t// Resolve entries listing file\n\t\t\tthis.readEntriesFile(),\n\n\t\t\t// Resolve children of history folder\n\t\t\tthis.readEntriesFolder()\n\t\t]);\n\n\t\t// Add from raw folder children\n\t\tconst entries = new Map<string, IWorkingCopyHistoryEntry>();\n\t\tif (entryStats) {\n\t\t\tfor (const entryStat of entryStats) {\n\t\t\t\tentries.set(entryStat.name, {\n\t\t\t\t\tid: entryStat.name,\n\t\t\t\t\tworkingCopy: { resource: workingCopyResource, name: workingCopyName },\n\t\t\t\t\tlocation: entryStat.resource,\n\t\t\t\t\ttimestamp: entryStat.mtime,\n\t\t\t\t\tsource: WorkingCopyHistoryModel.FILE_SAVED_SOURCE,\n\t\t\t\t\tsourceDescription: undefined\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Update from listing (to have more specific metadata)\n\t\tif (entryListing) {\n\t\t\tfor (const entry of entryListing.entries) {\n\t\t\t\tconst existingEntry = entries.get(entry.id);\n\t\t\t\tif (existingEntry) {\n\t\t\t\t\tentries.set(entry.id, {\n\t\t\t\t\t\t...existingEntry,\n\t\t\t\t\t\ttimestamp: entry.timestamp,\n\t\t\t\t\t\tsource: entry.source ?? existingEntry.source,\n\t\t\t\t\t\tsourceDescription: entry.sourceDescription ?? existingEntry.sourceDescription\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn entries;\n\t}\n\n\tasync moveEntries(target: WorkingCopyHistoryModel, source: SaveSource, token: CancellationToken): Promise<void> {\n\t\tconst timestamp = Date.now();\n\t\tconst sourceDescription = this.labelService.getUriLabel(assertIsDefined(this.workingCopyResource));\n\n\t\t// Move all entries into the target folder so that we preserve\n\t\t// any existing history entries that might already be present\n\n\t\tconst sourceHistoryEntriesFolder = assertIsDefined(this.historyEntriesFolder);\n\t\tconst targetHistoryEntriesFolder = assertIsDefined(target.historyEntriesFolder);\n\t\ttry {\n\t\t\tfor (const entry of this.entries) {\n\t\t\t\tawait this.fileService.move(entry.location, joinPath(targetHistoryEntriesFolder, entry.id), true);\n\t\t\t}\n\t\t\tawait this.fileService.del(sourceHistoryEntriesFolder, { recursive: true });\n\t\t} catch (error) {\n\t\t\tif (!this.isFileNotFound(error)) {\n\t\t\t\ttry {\n\t\t\t\t\t// In case of an error (unless not found), fallback to moving the entire folder\n\t\t\t\t\tawait this.fileService.move(sourceHistoryEntriesFolder, targetHistoryEntriesFolder, true);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (!this.isFileNotFound(error)) {\n\t\t\t\t\t\tthis.traceError(error);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Merge our entries with target entries before updating associated working copy\n\t\tconst allEntries = distinct([...this.entries, ...target.entries], entry => entry.id).sort((entryA, entryB) => entryA.timestamp - entryB.timestamp);\n\n\t\t// Update our associated working copy\n\t\tconst targetWorkingCopyResource = assertIsDefined(target.workingCopyResource);\n\t\tthis.setWorkingCopy(targetWorkingCopyResource);\n\n\t\t// Restore our entries and ensure correct metadata\n\t\tconst targetWorkingCopyName = assertIsDefined(target.workingCopyName);\n\t\tfor (const entry of allEntries) {\n\t\t\tthis.entries.push({\n\t\t\t\tid: entry.id,\n\t\t\t\tlocation: joinPath(targetHistoryEntriesFolder, entry.id),\n\t\t\t\tsource: entry.source,\n\t\t\t\tsourceDescription: entry.sourceDescription,\n\t\t\t\ttimestamp: entry.timestamp,\n\t\t\t\tworkingCopy: {\n\t\t\t\t\tresource: targetWorkingCopyResource,\n\t\t\t\t\tname: targetWorkingCopyName\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Add entry for the move\n\t\tawait this.addEntry(source, sourceDescription, timestamp, token);\n\n\t\t// Store model again to updated location\n\t\tawait this.store(token);\n\t}\n\n\tasync store(token: CancellationToken): Promise<void> {\n\t\tif (!this.shouldStore()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Use a `Limiter` to prevent multiple `store` operations\n\t\t// potentially running at the same time\n\n\t\tawait this.storeLimiter.queue(async () => {\n\t\t\tif (token.isCancellationRequested || !this.shouldStore()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treturn this.doStore(token);\n\t\t});\n\t}\n\n\tprivate shouldStore(): boolean {\n\t\treturn this.storedVersionId !== this.versionId;\n\t}\n\n\tprivate async doStore(token: CancellationToken): Promise<void> {\n\t\tconst historyEntriesFolder = assertIsDefined(this.historyEntriesFolder);\n\n\t\t// Make sure to await resolving when persisting\n\t\tawait this.resolveEntriesOnce();\n\n\t\tif (token.isCancellationRequested) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Cleanup based on max-entries setting\n\t\tawait this.cleanUpEntries();\n\n\t\t// Without entries, remove the history folder\n\t\tconst storedVersion = this.versionId;\n\t\tif (this.entries.length === 0) {\n\t\t\ttry {\n\t\t\t\tawait this.fileService.del(historyEntriesFolder, { recursive: true });\n\t\t\t} catch (error) {\n\t\t\t\tthis.traceError(error);\n\t\t\t}\n\t\t}\n\n\t\t// If we still have entries, update the entries meta file\n\t\telse {\n\t\t\tawait this.writeEntriesFile();\n\t\t}\n\n\t\t// Mark as stored version\n\t\tthis.storedVersionId = storedVersion;\n\t}\n\n\tprivate async cleanUpEntries(): Promise<void> {\n\t\tconst configuredMaxEntries = this.configurationService.getValue<number>(WorkingCopyHistoryModel.SETTINGS.MAX_ENTRIES, { resource: this.workingCopyResource });\n\t\tif (this.entries.length <= configuredMaxEntries) {\n\t\t\treturn; // nothing to cleanup\n\t\t}\n\n\t\tconst entriesToDelete = this.entries.slice(0, this.entries.length - configuredMaxEntries);\n\t\tconst entriesToKeep = this.entries.slice(this.entries.length - configuredMaxEntries);\n\n\t\t// Delete entries from disk as instructed\n\t\tfor (const entryToDelete of entriesToDelete) {\n\t\t\tawait this.deleteEntry(entryToDelete);\n\t\t}\n\n\t\t// Make sure to update our in-memory model as well\n\t\t// because it will be persisted right after\n\t\tthis.entries = entriesToKeep;\n\n\t\t// Events\n\t\tfor (const entry of entriesToDelete) {\n\t\t\tthis.entryRemovedEmitter.fire({ entry });\n\t\t}\n\t}\n\n\tprivate async deleteEntry(entry: IWorkingCopyHistoryEntry): Promise<void> {\n\t\ttry {\n\t\t\tawait this.fileService.del(entry.location);\n\t\t} catch (error) {\n\t\t\tthis.traceError(error);\n\t\t}\n\t}\n\n\tprivate async writeEntriesFile(): Promise<void> {\n\t\tconst workingCopyResource = assertIsDefined(this.workingCopyResource);\n\t\tconst historyEntriesListingFile = assertIsDefined(this.historyEntriesListingFile);\n\n\t\tconst serializedModel: ISerializedWorkingCopyHistoryModel = {\n\t\t\tversion: 1,\n\t\t\tresource: workingCopyResource.toString(),\n\t\t\tentries: this.entries.map(entry => {\n\t\t\t\treturn {\n\t\t\t\t\tid: entry.id,\n\t\t\t\t\tsource: entry.source !== WorkingCopyHistoryModel.FILE_SAVED_SOURCE ? entry.source : undefined,\n\t\t\t\t\tsourceDescription: entry.sourceDescription,\n\t\t\t\t\ttimestamp: entry.timestamp\n\t\t\t\t};\n\t\t\t})\n\t\t};\n\n\t\tawait this.fileService.writeFile(historyEntriesListingFile, VSBuffer.fromString(JSON.stringify(serializedModel)));\n\t}\n\n\tprivate async readEntriesFile(): Promise<ISerializedWorkingCopyHistoryModel | undefined> {\n\t\tconst historyEntriesListingFile = assertIsDefined(this.historyEntriesListingFile);\n\n\t\tlet serializedModel: ISerializedWorkingCopyHistoryModel | undefined = undefined;\n\t\ttry {\n\t\t\tserializedModel = JSON.parse((await this.fileService.readFile(historyEntriesListingFile)).value.toString());\n\t\t} catch (error) {\n\t\t\tif (!this.isFileNotFound(error)) {\n\t\t\t\tthis.traceError(error);\n\t\t\t}\n\t\t}\n\n\t\treturn serializedModel;\n\t}\n\n\tprivate async readEntriesFolder(): Promise<IFileStatWithMetadata[] | undefined> {\n\t\tconst historyEntriesFolder = assertIsDefined(this.historyEntriesFolder);\n\t\tconst historyEntriesNameMatcher = assertIsDefined(this.historyEntriesNameMatcher);\n\n\t\tlet rawEntries: IFileStatWithMetadata[] | undefined = undefined;\n\n\t\t// Resolve children of folder on disk\n\t\ttry {\n\t\t\trawEntries = (await this.fileService.resolve(historyEntriesFolder, { resolveMetadata: true })).children;\n\t\t} catch (error) {\n\t\t\tif (!this.isFileNotFound(error)) {\n\t\t\t\tthis.traceError(error);\n\t\t\t}\n\t\t}\n\n\t\tif (!rawEntries) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Skip entries that do not seem to have valid file name\n\t\treturn rawEntries.filter(entry =>\n\t\t\t!isEqual(entry.resource, this.historyEntriesListingFile) && // not the listings file\n\t\t\thistoryEntriesNameMatcher.test(entry.name)\t\t\t\t\t// matching our expected file pattern for entries\n\t\t);\n\t}\n\n\tprivate isFileNotFound(error: unknown): boolean {\n\t\treturn error instanceof FileOperationError && error.fileOperationResult === FileOperationResult.FILE_NOT_FOUND;\n\t}\n\n\tprivate traceError(error: Error): void {\n\t\tthis.logService.trace('[Working Copy History Service]', error);\n\t}\n}\n\nexport abstract class WorkingCopyHistoryService extends Disposable implements IWorkingCopyHistoryService {\n\n\tprivate static readonly FILE_MOVED_SOURCE = SaveSourceRegistry.registerSource('moved.source', localize('moved.source', \"File Moved\"));\n\tprivate static readonly FILE_RENAMED_SOURCE = SaveSourceRegistry.registerSource('renamed.source', localize('renamed.source', \"File Renamed\"));\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprotected readonly _onDidAddEntry = this._register(new Emitter<IWorkingCopyHistoryEvent>());\n\treadonly onDidAddEntry = this._onDidAddEntry.event;\n\n\tprotected readonly _onDidChangeEntry = this._register(new Emitter<IWorkingCopyHistoryEvent>());\n\treadonly onDidChangeEntry = this._onDidChangeEntry.event;\n\n\tprotected readonly _onDidReplaceEntry = this._register(new Emitter<IWorkingCopyHistoryEvent>());\n\treadonly onDidReplaceEntry = this._onDidReplaceEntry.event;\n\n\tprivate readonly _onDidMoveEntries = this._register(new Emitter<void>());\n\treadonly onDidMoveEntries = this._onDidMoveEntries.event;\n\n\tprotected readonly _onDidRemoveEntry = this._register(new Emitter<IWorkingCopyHistoryEvent>());\n\treadonly onDidRemoveEntry = this._onDidRemoveEntry.event;\n\n\tprivate readonly _onDidRemoveEntries = this._register(new Emitter<void>());\n\treadonly onDidRemoveEntries = this._onDidRemoveEntries.event;\n\n\tprivate readonly localHistoryHome = new DeferredPromise<URI>();\n\n\tprotected readonly models = new ResourceMap<WorkingCopyHistoryModel>(resource => this.uriIdentityService.extUri.getComparisonKey(resource));\n\n\tconstructor(\n\t\t@IFileService protected readonly fileService: IFileService,\n\t\t@IRemoteAgentService protected readonly remoteAgentService: IRemoteAgentService,\n\t\t@IWorkbenchEnvironmentService protected readonly environmentService: IWorkbenchEnvironmentService,\n\t\t@IUriIdentityService protected readonly uriIdentityService: IUriIdentityService,\n\t\t@ILabelService protected readonly labelService: ILabelService,\n\t\t@ILogService protected readonly logService: ILogService,\n\t\t@IConfigurationService protected readonly configurationService: IConfigurationService\n\t) {\n\t\tsuper();\n\n\t\tthis.resolveLocalHistoryHome();\n\t}\n\n\tprivate async resolveLocalHistoryHome(): Promise<void> {\n\t\tlet historyHome: URI | undefined = undefined;\n\n\t\t// Prefer history to be stored in the remote if we are connected to a remote\n\t\ttry {\n\t\t\tconst remoteEnv = await this.remoteAgentService.getEnvironment();\n\t\t\tif (remoteEnv) {\n\t\t\t\thistoryHome = remoteEnv.localHistoryHome;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.logService.trace(error); // ignore and fallback to local\n\t\t}\n\n\t\t// But fallback to local if there is no remote\n\t\tif (!historyHome) {\n\t\t\thistoryHome = this.environmentService.localHistoryHome;\n\t\t}\n\n\t\tthis.localHistoryHome.complete(historyHome);\n\t}\n\n\tasync moveEntries(source: URI, target: URI): Promise<URI[]> {\n\t\tconst limiter = new Limiter<URI>(MAX_PARALLEL_HISTORY_IO_OPS);\n\t\tconst promises: Promise<URI>[] = [];\n\n\t\tfor (const [resource, model] of this.models) {\n\t\t\tif (!this.uriIdentityService.extUri.isEqualOrParent(resource, source)) {\n\t\t\t\tcontinue; // model does not match moved resource\n\t\t\t}\n\n\t\t\t// Determine new resulting target resource\n\t\t\tlet targetResource: URI;\n\t\t\tif (this.uriIdentityService.extUri.isEqual(source, resource)) {\n\t\t\t\ttargetResource = target; // file got moved\n\t\t\t} else {\n\t\t\t\tconst index = indexOfPath(resource.path, source.path);\n\t\t\t\ttargetResource = joinPath(target, resource.path.substr(index + source.path.length + 1)); // parent folder got moved\n\t\t\t}\n\n\t\t\t// Figure out save source\n\t\t\tlet saveSource: SaveSource;\n\t\t\tif (this.uriIdentityService.extUri.isEqual(dirname(resource), dirname(targetResource))) {\n\t\t\t\tsaveSource = WorkingCopyHistoryService.FILE_RENAMED_SOURCE;\n\t\t\t} else {\n\t\t\t\tsaveSource = WorkingCopyHistoryService.FILE_MOVED_SOURCE;\n\t\t\t}\n\n\t\t\t// Move entries to target queued\n\t\t\tpromises.push(limiter.queue(() => this.doMoveEntries(model, saveSource, resource, targetResource)));\n\t\t}\n\n\t\tif (!promises.length) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// Await move operations\n\t\tconst resources = await Promise.all(promises);\n\n\t\t// Events\n\t\tthis._onDidMoveEntries.fire();\n\n\t\treturn resources;\n\t}\n\n\tprivate async doMoveEntries(source: WorkingCopyHistoryModel, saveSource: SaveSource, sourceWorkingCopyResource: URI, targetWorkingCopyResource: URI): Promise<URI> {\n\n\t\t// Move to target via model\n\t\tconst target = await this.getModel(targetWorkingCopyResource);\n\t\tawait source.moveEntries(target, saveSource, CancellationToken.None);\n\n\t\t// Update model in our map\n\t\tthis.models.delete(sourceWorkingCopyResource);\n\t\tthis.models.set(targetWorkingCopyResource, source);\n\n\t\treturn targetWorkingCopyResource;\n\t}\n\n\tasync addEntry({ resource, source, timestamp }: IWorkingCopyHistoryEntryDescriptor, token: CancellationToken): Promise<IWorkingCopyHistoryEntry | undefined> {\n\t\tif (!this.fileService.hasProvider(resource)) {\n\t\t\treturn undefined; // we require the working copy resource to be file service accessible\n\t\t}\n\n\t\t// Resolve history model for working copy\n\t\tconst model = await this.getModel(resource);\n\t\tif (token.isCancellationRequested) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Add to model\n\t\treturn model.addEntry(source, undefined, timestamp, token);\n\t}\n\n\tasync updateEntry(entry: IWorkingCopyHistoryEntry, properties: { source: SaveSource }, token: CancellationToken): Promise<void> {\n\n\t\t// Resolve history model for working copy\n\t\tconst model = await this.getModel(entry.workingCopy.resource);\n\t\tif (token.isCancellationRequested) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Rename in model\n\t\treturn model.updateEntry(entry, properties, token);\n\t}\n\n\tasync removeEntry(entry: IWorkingCopyHistoryEntry, token: CancellationToken): Promise<boolean> {\n\n\t\t// Resolve history model for working copy\n\t\tconst model = await this.getModel(entry.workingCopy.resource);\n\t\tif (token.isCancellationRequested) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Remove from model\n\t\treturn model.removeEntry(entry, token);\n\t}\n\n\tasync removeAll(token: CancellationToken): Promise<void> {\n\t\tconst historyHome = await this.localHistoryHome.p;\n\t\tif (token.isCancellationRequested) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Clear models\n\t\tthis.models.clear();\n\n\t\t// Remove from disk\n\t\tawait this.fileService.del(historyHome, { recursive: true });\n\n\t\t// Events\n\t\tthis._onDidRemoveEntries.fire();\n\t}\n\n\tasync getEntries(resource: URI, token: CancellationToken): Promise<readonly IWorkingCopyHistoryEntry[]> {\n\t\tconst model = await this.getModel(resource);\n\t\tif (token.isCancellationRequested) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst entries = await model.getEntries();\n\t\treturn entries ?? [];\n\t}\n\n\tasync getAll(token: CancellationToken): Promise<readonly URI[]> {\n\t\tconst historyHome = await this.localHistoryHome.p;\n\t\tif (token.isCancellationRequested) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst all = new ResourceMap<true>();\n\n\t\t// Fill in all known model resources (they might not have yet persisted to disk)\n\t\tfor (const [resource, model] of this.models) {\n\t\t\tconst hasInMemoryEntries = await model.hasEntries(true /* skip resolving because we resolve below from disk */);\n\t\t\tif (hasInMemoryEntries) {\n\t\t\t\tall.set(resource, true);\n\t\t\t}\n\t\t}\n\n\t\t// Resolve all other resources by iterating the history home folder\n\t\ttry {\n\t\t\tconst resolvedHistoryHome = await this.fileService.resolve(historyHome);\n\t\t\tif (resolvedHistoryHome.children) {\n\t\t\t\tconst limiter = new Limiter(MAX_PARALLEL_HISTORY_IO_OPS);\n\t\t\t\tconst promises = [];\n\n\t\t\t\tfor (const child of resolvedHistoryHome.children) {\n\t\t\t\t\tpromises.push(limiter.queue(async () => {\n\t\t\t\t\t\tif (token.isCancellationRequested) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst serializedModel: ISerializedWorkingCopyHistoryModel = JSON.parse((await this.fileService.readFile(joinPath(child.resource, WorkingCopyHistoryModel.ENTRIES_FILE))).value.toString());\n\t\t\t\t\t\t\tif (serializedModel.entries.length > 0) {\n\t\t\t\t\t\t\t\tall.set(URI.parse(serializedModel.resource), true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t// ignore - model might be missing or corrupt, but we need it\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t\t\t}\n\n\t\t\t\tawait Promise.all(promises);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// ignore - history might be entirely empty\n\t\t}\n\n\t\treturn Array.from(all.keys());\n\t}\n\n\tprivate async getModel(resource: URI): Promise<WorkingCopyHistoryModel> {\n\t\tconst historyHome = await this.localHistoryHome.p;\n\n\t\tlet model = this.models.get(resource);\n\t\tif (!model) {\n\t\t\tmodel = new WorkingCopyHistoryModel(resource, historyHome, this._onDidAddEntry, this._onDidChangeEntry, this._onDidReplaceEntry, this._onDidRemoveEntry, this.getModelOptions(), this.fileService, this.labelService, this.logService, this.configurationService);\n\t\t\tthis.models.set(resource, model);\n\t\t}\n\n\t\treturn model;\n\t}\n\n\tprotected abstract getModelOptions(): IWorkingCopyHistoryModelOptions;\n\n}\n\nexport class NativeWorkingCopyHistoryService extends WorkingCopyHistoryService {\n\n\tprivate static readonly STORE_ALL_INTERVAL = 5 * 60 * 1000; // 5min\n\n\tprivate readonly isRemotelyStored = typeof this.environmentService.remoteAuthority === 'string';\n\n\tprivate readonly storeAllCts = this._register(new CancellationTokenSource());\n\tprivate readonly storeAllScheduler = this._register(new RunOnceScheduler(() => this.storeAll(this.storeAllCts.token), NativeWorkingCopyHistoryService.STORE_ALL_INTERVAL));\n\n\tconstructor(\n\t\t@IFileService fileService: IFileService,\n\t\t@IRemoteAgentService remoteAgentService: IRemoteAgentService,\n\t\t@IWorkbenchEnvironmentService environmentService: IWorkbenchEnvironmentService,\n\t\t@IUriIdentityService uriIdentityService: IUriIdentityService,\n\t\t@ILabelService labelService: ILabelService,\n\t\t@ILifecycleService private readonly lifecycleService: ILifecycleService,\n\t\t@ILogService logService: ILogService,\n\t\t@IConfigurationService configurationService: IConfigurationService\n\t) {\n\t\tsuper(fileService, remoteAgentService, environmentService, uriIdentityService, labelService, logService, configurationService);\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tif (!this.isRemotelyStored) {\n\n\t\t\t// Local: persist all on shutdown\n\t\t\tthis._register(this.lifecycleService.onWillShutdown(e => this.onWillShutdown(e)));\n\n\t\t\t// Local: schedule persist on change\n\t\t\tthis._register(Event.any(this.onDidAddEntry, this.onDidChangeEntry, this.onDidReplaceEntry, this.onDidRemoveEntry)(() => this.onDidChangeModels()));\n\t\t}\n\t}\n\n\tprotected getModelOptions(): IWorkingCopyHistoryModelOptions {\n\t\treturn { flushOnChange: this.isRemotelyStored /* because the connection might drop anytime */ };\n\t}\n\n\tprivate onWillShutdown(e: WillShutdownEvent): void {\n\n\t\t// Dispose the scheduler...\n\t\tthis.storeAllScheduler.dispose();\n\t\tthis.storeAllCts.dispose(true);\n\n\t\t// ...because we now explicitly store all models\n\t\te.join(this.storeAll(e.token), { id: 'join.workingCopyHistory', label: localize('join.workingCopyHistory', \"Saving local history\") });\n\t}\n\n\tprivate onDidChangeModels(): void {\n\t\tif (!this.storeAllScheduler.isScheduled()) {\n\t\t\tthis.storeAllScheduler.schedule();\n\t\t}\n\t}\n\n\tprivate async storeAll(token: CancellationToken): Promise<void> {\n\t\tconst limiter = new Limiter(MAX_PARALLEL_HISTORY_IO_OPS);\n\t\tconst promises = [];\n\n\t\tconst models = Array.from(this.models.values());\n\t\tfor (const model of models) {\n\t\t\tpromises.push(limiter.queue(async () => {\n\t\t\t\tif (token.isCancellationRequested) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tawait model.store(token);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.logService.trace(error);\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\n\t\tawait Promise.all(promises);\n\t}\n}\n\n// Register History Tracker\nRegistry.as<IWorkbenchContributionsRegistry>(WorkbenchExtensions.Workbench).registerWorkbenchContribution(WorkingCopyHistoryTracker, LifecyclePhase.Restored);\n"],
  "mappings": "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",
  "names": ["error"]
}
