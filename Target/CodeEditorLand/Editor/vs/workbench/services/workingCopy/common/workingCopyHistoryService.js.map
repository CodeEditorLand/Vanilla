{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/workingCopy/common/workingCopyHistoryService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { distinct } from \"../../../../base/common/arrays.js\";\nimport {\n\tDeferredPromise,\n\tLimiter,\n\tRunOnceScheduler,\n} from \"../../../../base/common/async.js\";\nimport { VSBuffer } from \"../../../../base/common/buffer.js\";\nimport {\n\tCancellationToken,\n\tCancellationTokenSource,\n} from \"../../../../base/common/cancellation.js\";\nimport { Emitter, Event } from \"../../../../base/common/event.js\";\nimport { indexOfPath, randomPath } from \"../../../../base/common/extpath.js\";\nimport { hash } from \"../../../../base/common/hash.js\";\nimport { Disposable } from \"../../../../base/common/lifecycle.js\";\nimport { ResourceMap } from \"../../../../base/common/map.js\";\nimport {\n\tdirname,\n\textname,\n\tisEqual,\n\tjoinPath,\n} from \"../../../../base/common/resources.js\";\nimport { escapeRegExpCharacters } from \"../../../../base/common/strings.js\";\nimport { assertIsDefined } from \"../../../../base/common/types.js\";\nimport { URI } from \"../../../../base/common/uri.js\";\nimport { localize } from \"../../../../nls.js\";\nimport { IConfigurationService } from \"../../../../platform/configuration/common/configuration.js\";\nimport {\n\tFileOperationError,\n\tFileOperationResult,\n\tIFileService,\n\ttype IFileStatWithMetadata,\n} from \"../../../../platform/files/common/files.js\";\nimport { ILabelService } from \"../../../../platform/label/common/label.js\";\nimport { ILogService } from \"../../../../platform/log/common/log.js\";\nimport { Registry } from \"../../../../platform/registry/common/platform.js\";\nimport { IUriIdentityService } from \"../../../../platform/uriIdentity/common/uriIdentity.js\";\nimport {\n\ttype IWorkbenchContributionsRegistry,\n\tExtensions as WorkbenchExtensions,\n} from \"../../../common/contributions.js\";\nimport { type SaveSource, SaveSourceRegistry } from \"../../../common/editor.js\";\nimport { IWorkbenchEnvironmentService } from \"../../environment/common/environmentService.js\";\nimport {\n\tILifecycleService,\n\tLifecyclePhase,\n\ttype WillShutdownEvent,\n} from \"../../lifecycle/common/lifecycle.js\";\nimport { IRemoteAgentService } from \"../../remote/common/remoteAgentService.js\";\nimport {\n\ttype IWorkingCopyHistoryEntry,\n\ttype IWorkingCopyHistoryEntryDescriptor,\n\ttype IWorkingCopyHistoryEvent,\n\ttype IWorkingCopyHistoryService,\n\tMAX_PARALLEL_HISTORY_IO_OPS,\n} from \"./workingCopyHistory.js\";\nimport { WorkingCopyHistoryTracker } from \"./workingCopyHistoryTracker.js\";\n\ninterface ISerializedWorkingCopyHistoryModel {\n\treadonly version: number;\n\treadonly resource: string;\n\treadonly entries: ISerializedWorkingCopyHistoryModelEntry[];\n}\n\ninterface ISerializedWorkingCopyHistoryModelEntry {\n\treadonly id: string;\n\treadonly timestamp: number;\n\treadonly source?: SaveSource;\n\treadonly sourceDescription?: string;\n}\n\nexport interface IWorkingCopyHistoryModelOptions {\n\t/**\n\t * Whether to flush when the model changes. If not\n\t * configured, `model.store()` has to be called\n\t * explicitly.\n\t */\n\tflushOnChange: boolean;\n}\n\nexport class WorkingCopyHistoryModel {\n\tstatic readonly ENTRIES_FILE = \"entries.json\";\n\n\tprivate static readonly FILE_SAVED_SOURCE =\n\t\tSaveSourceRegistry.registerSource(\n\t\t\t\"default.source\",\n\t\t\tlocalize(\"default.source\", \"File Saved\"),\n\t\t);\n\n\tprivate static readonly SETTINGS = {\n\t\tMAX_ENTRIES: \"workbench.localHistory.maxFileEntries\",\n\t\tMERGE_PERIOD: \"workbench.localHistory.mergeWindow\",\n\t};\n\n\tprivate entries: IWorkingCopyHistoryEntry[] = [];\n\n\tprivate whenResolved: Promise<void> | undefined = undefined;\n\n\tprivate workingCopyResource: URI | undefined = undefined;\n\tprivate workingCopyName: string | undefined = undefined;\n\n\tprivate historyEntriesFolder: URI | undefined = undefined;\n\tprivate historyEntriesListingFile: URI | undefined = undefined;\n\n\tprivate historyEntriesNameMatcher: RegExp | undefined = undefined;\n\n\tprivate versionId = 0;\n\tprivate storedVersionId = this.versionId;\n\n\tprivate readonly storeLimiter = new Limiter(1);\n\n\tconstructor(\n\t\tworkingCopyResource: URI,\n\t\tprivate readonly historyHome: URI,\n\t\tprivate readonly entryAddedEmitter: Emitter<IWorkingCopyHistoryEvent>,\n\t\tprivate readonly entryChangedEmitter: Emitter<IWorkingCopyHistoryEvent>,\n\t\tprivate readonly entryReplacedEmitter: Emitter<IWorkingCopyHistoryEvent>,\n\t\tprivate readonly entryRemovedEmitter: Emitter<IWorkingCopyHistoryEvent>,\n\t\tprivate readonly options: IWorkingCopyHistoryModelOptions,\n\t\tprivate readonly fileService: IFileService,\n\t\tprivate readonly labelService: ILabelService,\n\t\tprivate readonly logService: ILogService,\n\t\tprivate readonly configurationService: IConfigurationService,\n\t) {\n\t\tthis.setWorkingCopy(workingCopyResource);\n\t}\n\n\tprivate setWorkingCopy(workingCopyResource: URI): void {\n\t\t// Update working copy\n\t\tthis.workingCopyResource = workingCopyResource;\n\t\tthis.workingCopyName =\n\t\t\tthis.labelService.getUriBasenameLabel(workingCopyResource);\n\n\t\tthis.historyEntriesNameMatcher = new RegExp(\n\t\t\t`[A-Za-z0-9]{4}${escapeRegExpCharacters(extname(workingCopyResource))}`,\n\t\t);\n\n\t\t// Update locations\n\t\tthis.historyEntriesFolder = this.toHistoryEntriesFolder(\n\t\t\tthis.historyHome,\n\t\t\tworkingCopyResource,\n\t\t);\n\t\tthis.historyEntriesListingFile = joinPath(\n\t\t\tthis.historyEntriesFolder,\n\t\t\tWorkingCopyHistoryModel.ENTRIES_FILE,\n\t\t);\n\n\t\t// Reset entries and resolved cache\n\t\tthis.entries = [];\n\t\tthis.whenResolved = undefined;\n\t}\n\n\tprivate toHistoryEntriesFolder(\n\t\thistoryHome: URI,\n\t\tworkingCopyResource: URI,\n\t): URI {\n\t\treturn joinPath(\n\t\t\thistoryHome,\n\t\t\thash(workingCopyResource.toString()).toString(16),\n\t\t);\n\t}\n\n\tasync addEntry(\n\t\tsource = WorkingCopyHistoryModel.FILE_SAVED_SOURCE,\n\t\tsourceDescription: string | undefined = undefined,\n\t\ttimestamp = Date.now(),\n\t\ttoken: CancellationToken,\n\t): Promise<IWorkingCopyHistoryEntry> {\n\t\tlet entryToReplace: IWorkingCopyHistoryEntry | undefined;\n\n\t\t// Figure out if the last entry should be replaced based\n\t\t// on settings that can define a interval for when an\n\t\t// entry is not added as new entry but should replace.\n\t\t// However, when save source is different, never replace.\n\t\tconst lastEntry = this.entries.at(-1);\n\t\tif (lastEntry && lastEntry.source === source) {\n\t\t\tconst configuredReplaceInterval =\n\t\t\t\tthis.configurationService.getValue<number>(\n\t\t\t\t\tWorkingCopyHistoryModel.SETTINGS.MERGE_PERIOD,\n\t\t\t\t\t{ resource: this.workingCopyResource },\n\t\t\t\t);\n\t\t\tif (\n\t\t\t\ttimestamp - lastEntry.timestamp <=\n\t\t\t\tconfiguredReplaceInterval * 1000 /* convert to millies */\n\t\t\t) {\n\t\t\t\tentryToReplace = lastEntry;\n\t\t\t}\n\t\t}\n\n\t\tlet entry: IWorkingCopyHistoryEntry;\n\n\t\t// Replace lastest entry in history\n\t\tif (entryToReplace) {\n\t\t\tentry = await this.doReplaceEntry(\n\t\t\t\tentryToReplace,\n\t\t\t\tsource,\n\t\t\t\tsourceDescription,\n\t\t\t\ttimestamp,\n\t\t\t\ttoken,\n\t\t\t);\n\t\t}\n\n\t\t// Add entry to history\n\t\telse {\n\t\t\tentry = await this.doAddEntry(\n\t\t\t\tsource,\n\t\t\t\tsourceDescription,\n\t\t\t\ttimestamp,\n\t\t\t\ttoken,\n\t\t\t);\n\t\t}\n\n\t\t// Flush now if configured\n\t\tif (this.options.flushOnChange && !token.isCancellationRequested) {\n\t\t\tawait this.store(token);\n\t\t}\n\n\t\treturn entry;\n\t}\n\n\tprivate async doAddEntry(\n\t\tsource: SaveSource,\n\t\tsourceDescription: string | undefined = undefined,\n\t\ttimestamp: number,\n\t\ttoken: CancellationToken,\n\t): Promise<IWorkingCopyHistoryEntry> {\n\t\tconst workingCopyResource = assertIsDefined(this.workingCopyResource);\n\t\tconst workingCopyName = assertIsDefined(this.workingCopyName);\n\t\tconst historyEntriesFolder = assertIsDefined(this.historyEntriesFolder);\n\n\t\t// Perform a fast clone operation with minimal overhead to a new random location\n\t\tconst id = `${randomPath(undefined, undefined, 4)}${extname(workingCopyResource)}`;\n\t\tconst location = joinPath(historyEntriesFolder, id);\n\t\tawait this.fileService.cloneFile(workingCopyResource, location);\n\n\t\t// Add to list of entries\n\t\tconst entry: IWorkingCopyHistoryEntry = {\n\t\t\tid,\n\t\t\tworkingCopy: {\n\t\t\t\tresource: workingCopyResource,\n\t\t\t\tname: workingCopyName,\n\t\t\t},\n\t\t\tlocation,\n\t\t\ttimestamp,\n\t\t\tsource,\n\t\t\tsourceDescription,\n\t\t};\n\t\tthis.entries.push(entry);\n\n\t\t// Update version ID of model to use for storing later\n\t\tthis.versionId++;\n\n\t\t// Events\n\t\tthis.entryAddedEmitter.fire({ entry });\n\n\t\treturn entry;\n\t}\n\n\tprivate async doReplaceEntry(\n\t\tentry: IWorkingCopyHistoryEntry,\n\t\tsource: SaveSource,\n\t\tsourceDescription: string | undefined = undefined,\n\t\ttimestamp: number,\n\t\ttoken: CancellationToken,\n\t): Promise<IWorkingCopyHistoryEntry> {\n\t\tconst workingCopyResource = assertIsDefined(this.workingCopyResource);\n\n\t\t// Perform a fast clone operation with minimal overhead to the existing location\n\t\tawait this.fileService.cloneFile(workingCopyResource, entry.location);\n\n\t\t// Update entry\n\t\tentry.source = source;\n\t\tentry.sourceDescription = sourceDescription;\n\t\tentry.timestamp = timestamp;\n\n\t\t// Update version ID of model to use for storing later\n\t\tthis.versionId++;\n\n\t\t// Events\n\t\tthis.entryReplacedEmitter.fire({ entry });\n\n\t\treturn entry;\n\t}\n\n\tasync removeEntry(\n\t\tentry: IWorkingCopyHistoryEntry,\n\t\ttoken: CancellationToken,\n\t): Promise<boolean> {\n\t\t// Make sure to await resolving when removing entries\n\t\tawait this.resolveEntriesOnce();\n\n\t\tif (token.isCancellationRequested) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst index = this.entries.indexOf(entry);\n\t\tif (index === -1) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Delete from disk\n\t\tawait this.deleteEntry(entry);\n\n\t\t// Remove from model\n\t\tthis.entries.splice(index, 1);\n\n\t\t// Update version ID of model to use for storing later\n\t\tthis.versionId++;\n\n\t\t// Events\n\t\tthis.entryRemovedEmitter.fire({ entry });\n\n\t\t// Flush now if configured\n\t\tif (this.options.flushOnChange && !token.isCancellationRequested) {\n\t\t\tawait this.store(token);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tasync updateEntry(\n\t\tentry: IWorkingCopyHistoryEntry,\n\t\tproperties: { source: SaveSource },\n\t\ttoken: CancellationToken,\n\t): Promise<void> {\n\t\t// Make sure to await resolving when updating entries\n\t\tawait this.resolveEntriesOnce();\n\n\t\tif (token.isCancellationRequested) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst index = this.entries.indexOf(entry);\n\t\tif (index === -1) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Update entry\n\t\tentry.source = properties.source;\n\n\t\t// Update version ID of model to use for storing later\n\t\tthis.versionId++;\n\n\t\t// Events\n\t\tthis.entryChangedEmitter.fire({ entry });\n\n\t\t// Flush now if configured\n\t\tif (this.options.flushOnChange && !token.isCancellationRequested) {\n\t\t\tawait this.store(token);\n\t\t}\n\t}\n\n\tasync getEntries(): Promise<readonly IWorkingCopyHistoryEntry[]> {\n\t\t// Make sure to await resolving when all entries are asked for\n\t\tawait this.resolveEntriesOnce();\n\n\t\t// Return as many entries as configured by user settings\n\t\tconst configuredMaxEntries = this.configurationService.getValue<number>(\n\t\t\tWorkingCopyHistoryModel.SETTINGS.MAX_ENTRIES,\n\t\t\t{ resource: this.workingCopyResource },\n\t\t);\n\t\tif (this.entries.length > configuredMaxEntries) {\n\t\t\treturn this.entries.slice(\n\t\t\t\tthis.entries.length - configuredMaxEntries,\n\t\t\t);\n\t\t}\n\n\t\treturn this.entries;\n\t}\n\n\tasync hasEntries(skipResolve: boolean): Promise<boolean> {\n\t\t// Make sure to await resolving unless explicitly skipped\n\t\tif (!skipResolve) {\n\t\t\tawait this.resolveEntriesOnce();\n\t\t}\n\n\t\treturn this.entries.length > 0;\n\t}\n\n\tprivate resolveEntriesOnce(): Promise<void> {\n\t\tif (!this.whenResolved) {\n\t\t\tthis.whenResolved = this.doResolveEntries();\n\t\t}\n\n\t\treturn this.whenResolved;\n\t}\n\n\tprivate async doResolveEntries(): Promise<void> {\n\t\t// Resolve from disk\n\t\tconst entries = await this.resolveEntriesFromDisk();\n\n\t\t// We now need to merge our in-memory entries with the\n\t\t// entries we have found on disk because it is possible\n\t\t// that new entries have been added before the entries\n\t\t// listing file was updated\n\t\tfor (const entry of this.entries) {\n\t\t\tentries.set(entry.id, entry);\n\t\t}\n\n\t\t// Set as entries, sorted by timestamp\n\t\tthis.entries = Array.from(entries.values()).sort(\n\t\t\t(entryA, entryB) => entryA.timestamp - entryB.timestamp,\n\t\t);\n\t}\n\n\tprivate async resolveEntriesFromDisk(): Promise<\n\t\tMap<string /* ID */, IWorkingCopyHistoryEntry>\n\t> {\n\t\tconst workingCopyResource = assertIsDefined(this.workingCopyResource);\n\t\tconst workingCopyName = assertIsDefined(this.workingCopyName);\n\n\t\tconst [entryListing, entryStats] = await Promise.all([\n\t\t\t// Resolve entries listing file\n\t\t\tthis.readEntriesFile(),\n\n\t\t\t// Resolve children of history folder\n\t\t\tthis.readEntriesFolder(),\n\t\t]);\n\n\t\t// Add from raw folder children\n\t\tconst entries = new Map<string, IWorkingCopyHistoryEntry>();\n\t\tif (entryStats) {\n\t\t\tfor (const entryStat of entryStats) {\n\t\t\t\tentries.set(entryStat.name, {\n\t\t\t\t\tid: entryStat.name,\n\t\t\t\t\tworkingCopy: {\n\t\t\t\t\t\tresource: workingCopyResource,\n\t\t\t\t\t\tname: workingCopyName,\n\t\t\t\t\t},\n\t\t\t\t\tlocation: entryStat.resource,\n\t\t\t\t\ttimestamp: entryStat.mtime,\n\t\t\t\t\tsource: WorkingCopyHistoryModel.FILE_SAVED_SOURCE,\n\t\t\t\t\tsourceDescription: undefined,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Update from listing (to have more specific metadata)\n\t\tif (entryListing) {\n\t\t\tfor (const entry of entryListing.entries) {\n\t\t\t\tconst existingEntry = entries.get(entry.id);\n\t\t\t\tif (existingEntry) {\n\t\t\t\t\tentries.set(entry.id, {\n\t\t\t\t\t\t...existingEntry,\n\t\t\t\t\t\ttimestamp: entry.timestamp,\n\t\t\t\t\t\tsource: entry.source ?? existingEntry.source,\n\t\t\t\t\t\tsourceDescription:\n\t\t\t\t\t\t\tentry.sourceDescription ??\n\t\t\t\t\t\t\texistingEntry.sourceDescription,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn entries;\n\t}\n\n\tasync moveEntries(\n\t\ttarget: WorkingCopyHistoryModel,\n\t\tsource: SaveSource,\n\t\ttoken: CancellationToken,\n\t): Promise<void> {\n\t\tconst timestamp = Date.now();\n\t\tconst sourceDescription = this.labelService.getUriLabel(\n\t\t\tassertIsDefined(this.workingCopyResource),\n\t\t);\n\n\t\t// Move all entries into the target folder so that we preserve\n\t\t// any existing history entries that might already be present\n\n\t\tconst sourceHistoryEntriesFolder = assertIsDefined(\n\t\t\tthis.historyEntriesFolder,\n\t\t);\n\t\tconst targetHistoryEntriesFolder = assertIsDefined(\n\t\t\ttarget.historyEntriesFolder,\n\t\t);\n\t\ttry {\n\t\t\tfor (const entry of this.entries) {\n\t\t\t\tawait this.fileService.move(\n\t\t\t\t\tentry.location,\n\t\t\t\t\tjoinPath(targetHistoryEntriesFolder, entry.id),\n\t\t\t\t\ttrue,\n\t\t\t\t);\n\t\t\t}\n\t\t\tawait this.fileService.del(sourceHistoryEntriesFolder, {\n\t\t\t\trecursive: true,\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tif (!this.isFileNotFound(error)) {\n\t\t\t\ttry {\n\t\t\t\t\t// In case of an error (unless not found), fallback to moving the entire folder\n\t\t\t\t\tawait this.fileService.move(\n\t\t\t\t\t\tsourceHistoryEntriesFolder,\n\t\t\t\t\t\ttargetHistoryEntriesFolder,\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (!this.isFileNotFound(error)) {\n\t\t\t\t\t\tthis.traceError(error);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Merge our entries with target entries before updating associated working copy\n\t\tconst allEntries = distinct(\n\t\t\t[...this.entries, ...target.entries],\n\t\t\t(entry) => entry.id,\n\t\t).sort((entryA, entryB) => entryA.timestamp - entryB.timestamp);\n\n\t\t// Update our associated working copy\n\t\tconst targetWorkingCopyResource = assertIsDefined(\n\t\t\ttarget.workingCopyResource,\n\t\t);\n\t\tthis.setWorkingCopy(targetWorkingCopyResource);\n\n\t\t// Restore our entries and ensure correct metadata\n\t\tconst targetWorkingCopyName = assertIsDefined(target.workingCopyName);\n\t\tfor (const entry of allEntries) {\n\t\t\tthis.entries.push({\n\t\t\t\tid: entry.id,\n\t\t\t\tlocation: joinPath(targetHistoryEntriesFolder, entry.id),\n\t\t\t\tsource: entry.source,\n\t\t\t\tsourceDescription: entry.sourceDescription,\n\t\t\t\ttimestamp: entry.timestamp,\n\t\t\t\tworkingCopy: {\n\t\t\t\t\tresource: targetWorkingCopyResource,\n\t\t\t\t\tname: targetWorkingCopyName,\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\t// Add entry for the move\n\t\tawait this.addEntry(source, sourceDescription, timestamp, token);\n\n\t\t// Store model again to updated location\n\t\tawait this.store(token);\n\t}\n\n\tasync store(token: CancellationToken): Promise<void> {\n\t\tif (!this.shouldStore()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Use a `Limiter` to prevent multiple `store` operations\n\t\t// potentially running at the same time\n\n\t\tawait this.storeLimiter.queue(async () => {\n\t\t\tif (token.isCancellationRequested || !this.shouldStore()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treturn this.doStore(token);\n\t\t});\n\t}\n\n\tprivate shouldStore(): boolean {\n\t\treturn this.storedVersionId !== this.versionId;\n\t}\n\n\tprivate async doStore(token: CancellationToken): Promise<void> {\n\t\tconst historyEntriesFolder = assertIsDefined(this.historyEntriesFolder);\n\n\t\t// Make sure to await resolving when persisting\n\t\tawait this.resolveEntriesOnce();\n\n\t\tif (token.isCancellationRequested) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Cleanup based on max-entries setting\n\t\tawait this.cleanUpEntries();\n\n\t\t// Without entries, remove the history folder\n\t\tconst storedVersion = this.versionId;\n\t\tif (this.entries.length === 0) {\n\t\t\ttry {\n\t\t\t\tawait this.fileService.del(historyEntriesFolder, {\n\t\t\t\t\trecursive: true,\n\t\t\t\t});\n\t\t\t} catch (error) {\n\t\t\t\tthis.traceError(error);\n\t\t\t}\n\t\t}\n\n\t\t// If we still have entries, update the entries meta file\n\t\telse {\n\t\t\tawait this.writeEntriesFile();\n\t\t}\n\n\t\t// Mark as stored version\n\t\tthis.storedVersionId = storedVersion;\n\t}\n\n\tprivate async cleanUpEntries(): Promise<void> {\n\t\tconst configuredMaxEntries = this.configurationService.getValue<number>(\n\t\t\tWorkingCopyHistoryModel.SETTINGS.MAX_ENTRIES,\n\t\t\t{ resource: this.workingCopyResource },\n\t\t);\n\t\tif (this.entries.length <= configuredMaxEntries) {\n\t\t\treturn; // nothing to cleanup\n\t\t}\n\n\t\tconst entriesToDelete = this.entries.slice(\n\t\t\t0,\n\t\t\tthis.entries.length - configuredMaxEntries,\n\t\t);\n\t\tconst entriesToKeep = this.entries.slice(\n\t\t\tthis.entries.length - configuredMaxEntries,\n\t\t);\n\n\t\t// Delete entries from disk as instructed\n\t\tfor (const entryToDelete of entriesToDelete) {\n\t\t\tawait this.deleteEntry(entryToDelete);\n\t\t}\n\n\t\t// Make sure to update our in-memory model as well\n\t\t// because it will be persisted right after\n\t\tthis.entries = entriesToKeep;\n\n\t\t// Events\n\t\tfor (const entry of entriesToDelete) {\n\t\t\tthis.entryRemovedEmitter.fire({ entry });\n\t\t}\n\t}\n\n\tprivate async deleteEntry(entry: IWorkingCopyHistoryEntry): Promise<void> {\n\t\ttry {\n\t\t\tawait this.fileService.del(entry.location);\n\t\t} catch (error) {\n\t\t\tthis.traceError(error);\n\t\t}\n\t}\n\n\tprivate async writeEntriesFile(): Promise<void> {\n\t\tconst workingCopyResource = assertIsDefined(this.workingCopyResource);\n\t\tconst historyEntriesListingFile = assertIsDefined(\n\t\t\tthis.historyEntriesListingFile,\n\t\t);\n\n\t\tconst serializedModel: ISerializedWorkingCopyHistoryModel = {\n\t\t\tversion: 1,\n\t\t\tresource: workingCopyResource.toString(),\n\t\t\tentries: this.entries.map((entry) => {\n\t\t\t\treturn {\n\t\t\t\t\tid: entry.id,\n\t\t\t\t\tsource:\n\t\t\t\t\t\tentry.source !==\n\t\t\t\t\t\tWorkingCopyHistoryModel.FILE_SAVED_SOURCE\n\t\t\t\t\t\t\t? entry.source\n\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\tsourceDescription: entry.sourceDescription,\n\t\t\t\t\ttimestamp: entry.timestamp,\n\t\t\t\t};\n\t\t\t}),\n\t\t};\n\n\t\tawait this.fileService.writeFile(\n\t\t\thistoryEntriesListingFile,\n\t\t\tVSBuffer.fromString(JSON.stringify(serializedModel)),\n\t\t);\n\t}\n\n\tprivate async readEntriesFile(): Promise<\n\t\tISerializedWorkingCopyHistoryModel | undefined\n\t> {\n\t\tconst historyEntriesListingFile = assertIsDefined(\n\t\t\tthis.historyEntriesListingFile,\n\t\t);\n\n\t\tlet serializedModel: ISerializedWorkingCopyHistoryModel | undefined;\n\t\ttry {\n\t\t\tserializedModel = JSON.parse(\n\t\t\t\t(\n\t\t\t\t\tawait this.fileService.readFile(historyEntriesListingFile)\n\t\t\t\t).value.toString(),\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tif (!this.isFileNotFound(error)) {\n\t\t\t\tthis.traceError(error);\n\t\t\t}\n\t\t}\n\n\t\treturn serializedModel;\n\t}\n\n\tprivate async readEntriesFolder(): Promise<\n\t\tIFileStatWithMetadata[] | undefined\n\t> {\n\t\tconst historyEntriesFolder = assertIsDefined(this.historyEntriesFolder);\n\t\tconst historyEntriesNameMatcher = assertIsDefined(\n\t\t\tthis.historyEntriesNameMatcher,\n\t\t);\n\n\t\tlet rawEntries: IFileStatWithMetadata[] | undefined;\n\n\t\t// Resolve children of folder on disk\n\t\ttry {\n\t\t\trawEntries = (\n\t\t\t\tawait this.fileService.resolve(historyEntriesFolder, {\n\t\t\t\t\tresolveMetadata: true,\n\t\t\t\t})\n\t\t\t).children;\n\t\t} catch (error) {\n\t\t\tif (!this.isFileNotFound(error)) {\n\t\t\t\tthis.traceError(error);\n\t\t\t}\n\t\t}\n\n\t\tif (!rawEntries) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Skip entries that do not seem to have valid file name\n\t\treturn rawEntries.filter(\n\t\t\t(entry) =>\n\t\t\t\t!isEqual(entry.resource, this.historyEntriesListingFile) && // not the listings file\n\t\t\t\thistoryEntriesNameMatcher.test(entry.name), // matching our expected file pattern for entries\n\t\t);\n\t}\n\n\tprivate isFileNotFound(error: unknown): boolean {\n\t\treturn (\n\t\t\terror instanceof FileOperationError &&\n\t\t\terror.fileOperationResult === FileOperationResult.FILE_NOT_FOUND\n\t\t);\n\t}\n\n\tprivate traceError(error: Error): void {\n\t\tthis.logService.trace(\"[Working Copy History Service]\", error);\n\t}\n}\n\nexport abstract class WorkingCopyHistoryService\n\textends Disposable\n\timplements IWorkingCopyHistoryService\n{\n\tprivate static readonly FILE_MOVED_SOURCE =\n\t\tSaveSourceRegistry.registerSource(\n\t\t\t\"moved.source\",\n\t\t\tlocalize(\"moved.source\", \"File Moved\"),\n\t\t);\n\tprivate static readonly FILE_RENAMED_SOURCE =\n\t\tSaveSourceRegistry.registerSource(\n\t\t\t\"renamed.source\",\n\t\t\tlocalize(\"renamed.source\", \"File Renamed\"),\n\t\t);\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprotected readonly _onDidAddEntry = this._register(\n\t\tnew Emitter<IWorkingCopyHistoryEvent>(),\n\t);\n\treadonly onDidAddEntry = this._onDidAddEntry.event;\n\n\tprotected readonly _onDidChangeEntry = this._register(\n\t\tnew Emitter<IWorkingCopyHistoryEvent>(),\n\t);\n\treadonly onDidChangeEntry = this._onDidChangeEntry.event;\n\n\tprotected readonly _onDidReplaceEntry = this._register(\n\t\tnew Emitter<IWorkingCopyHistoryEvent>(),\n\t);\n\treadonly onDidReplaceEntry = this._onDidReplaceEntry.event;\n\n\tprivate readonly _onDidMoveEntries = this._register(new Emitter<void>());\n\treadonly onDidMoveEntries = this._onDidMoveEntries.event;\n\n\tprotected readonly _onDidRemoveEntry = this._register(\n\t\tnew Emitter<IWorkingCopyHistoryEvent>(),\n\t);\n\treadonly onDidRemoveEntry = this._onDidRemoveEntry.event;\n\n\tprivate readonly _onDidRemoveEntries = this._register(new Emitter<void>());\n\treadonly onDidRemoveEntries = this._onDidRemoveEntries.event;\n\n\tprivate readonly localHistoryHome = new DeferredPromise<URI>();\n\n\tprotected readonly models = new ResourceMap<WorkingCopyHistoryModel>(\n\t\t(resource) => this.uriIdentityService.extUri.getComparisonKey(resource),\n\t);\n\n\tconstructor(\n\t\t@IFileService protected readonly fileService: IFileService,\n\t\t@IRemoteAgentService protected readonly remoteAgentService: IRemoteAgentService,\n\t\t@IWorkbenchEnvironmentService protected readonly environmentService: IWorkbenchEnvironmentService,\n\t\t@IUriIdentityService protected readonly uriIdentityService: IUriIdentityService,\n\t\t@ILabelService protected readonly labelService: ILabelService,\n\t\t@ILogService protected readonly logService: ILogService,\n\t\t@IConfigurationService protected readonly configurationService: IConfigurationService\n\t) {\n\t\tsuper();\n\n\t\tthis.resolveLocalHistoryHome();\n\t}\n\n\tprivate async resolveLocalHistoryHome(): Promise<void> {\n\t\tlet historyHome: URI | undefined;\n\n\t\t// Prefer history to be stored in the remote if we are connected to a remote\n\t\ttry {\n\t\t\tconst remoteEnv = await this.remoteAgentService.getEnvironment();\n\t\t\tif (remoteEnv) {\n\t\t\t\thistoryHome = remoteEnv.localHistoryHome;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.logService.trace(error); // ignore and fallback to local\n\t\t}\n\n\t\t// But fallback to local if there is no remote\n\t\tif (!historyHome) {\n\t\t\thistoryHome = this.environmentService.localHistoryHome;\n\t\t}\n\n\t\tthis.localHistoryHome.complete(historyHome);\n\t}\n\n\tasync moveEntries(source: URI, target: URI): Promise<URI[]> {\n\t\tconst limiter = new Limiter<URI>(MAX_PARALLEL_HISTORY_IO_OPS);\n\t\tconst promises: Promise<URI>[] = [];\n\n\t\tfor (const [resource, model] of this.models) {\n\t\t\tif (\n\t\t\t\t!this.uriIdentityService.extUri.isEqualOrParent(\n\t\t\t\t\tresource,\n\t\t\t\t\tsource,\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tcontinue; // model does not match moved resource\n\t\t\t}\n\n\t\t\t// Determine new resulting target resource\n\t\t\tlet targetResource: URI;\n\t\t\tif (this.uriIdentityService.extUri.isEqual(source, resource)) {\n\t\t\t\ttargetResource = target; // file got moved\n\t\t\t} else {\n\t\t\t\tconst index = indexOfPath(resource.path, source.path);\n\t\t\t\ttargetResource = joinPath(\n\t\t\t\t\ttarget,\n\t\t\t\t\tresource.path.substr(index + source.path.length + 1),\n\t\t\t\t); // parent folder got moved\n\t\t\t}\n\n\t\t\t// Figure out save source\n\t\t\tlet saveSource: SaveSource;\n\t\t\tif (\n\t\t\t\tthis.uriIdentityService.extUri.isEqual(\n\t\t\t\t\tdirname(resource),\n\t\t\t\t\tdirname(targetResource),\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tsaveSource = WorkingCopyHistoryService.FILE_RENAMED_SOURCE;\n\t\t\t} else {\n\t\t\t\tsaveSource = WorkingCopyHistoryService.FILE_MOVED_SOURCE;\n\t\t\t}\n\n\t\t\t// Move entries to target queued\n\t\t\tpromises.push(\n\t\t\t\tlimiter.queue(() =>\n\t\t\t\t\tthis.doMoveEntries(\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\tsaveSource,\n\t\t\t\t\t\tresource,\n\t\t\t\t\t\ttargetResource,\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\n\t\tif (!promises.length) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// Await move operations\n\t\tconst resources = await Promise.all(promises);\n\n\t\t// Events\n\t\tthis._onDidMoveEntries.fire();\n\n\t\treturn resources;\n\t}\n\n\tprivate async doMoveEntries(\n\t\tsource: WorkingCopyHistoryModel,\n\t\tsaveSource: SaveSource,\n\t\tsourceWorkingCopyResource: URI,\n\t\ttargetWorkingCopyResource: URI,\n\t): Promise<URI> {\n\t\t// Move to target via model\n\t\tconst target = await this.getModel(targetWorkingCopyResource);\n\t\tawait source.moveEntries(target, saveSource, CancellationToken.None);\n\n\t\t// Update model in our map\n\t\tthis.models.delete(sourceWorkingCopyResource);\n\t\tthis.models.set(targetWorkingCopyResource, source);\n\n\t\treturn targetWorkingCopyResource;\n\t}\n\n\tasync addEntry(\n\t\t{ resource, source, timestamp }: IWorkingCopyHistoryEntryDescriptor,\n\t\ttoken: CancellationToken,\n\t): Promise<IWorkingCopyHistoryEntry | undefined> {\n\t\tif (!this.fileService.hasProvider(resource)) {\n\t\t\treturn undefined; // we require the working copy resource to be file service accessible\n\t\t}\n\n\t\t// Resolve history model for working copy\n\t\tconst model = await this.getModel(resource);\n\t\tif (token.isCancellationRequested) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Add to model\n\t\treturn model.addEntry(source, undefined, timestamp, token);\n\t}\n\n\tasync updateEntry(\n\t\tentry: IWorkingCopyHistoryEntry,\n\t\tproperties: { source: SaveSource },\n\t\ttoken: CancellationToken,\n\t): Promise<void> {\n\t\t// Resolve history model for working copy\n\t\tconst model = await this.getModel(entry.workingCopy.resource);\n\t\tif (token.isCancellationRequested) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Rename in model\n\t\treturn model.updateEntry(entry, properties, token);\n\t}\n\n\tasync removeEntry(\n\t\tentry: IWorkingCopyHistoryEntry,\n\t\ttoken: CancellationToken,\n\t): Promise<boolean> {\n\t\t// Resolve history model for working copy\n\t\tconst model = await this.getModel(entry.workingCopy.resource);\n\t\tif (token.isCancellationRequested) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Remove from model\n\t\treturn model.removeEntry(entry, token);\n\t}\n\n\tasync removeAll(token: CancellationToken): Promise<void> {\n\t\tconst historyHome = await this.localHistoryHome.p;\n\t\tif (token.isCancellationRequested) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Clear models\n\t\tthis.models.clear();\n\n\t\t// Remove from disk\n\t\tawait this.fileService.del(historyHome, { recursive: true });\n\n\t\t// Events\n\t\tthis._onDidRemoveEntries.fire();\n\t}\n\n\tasync getEntries(\n\t\tresource: URI,\n\t\ttoken: CancellationToken,\n\t): Promise<readonly IWorkingCopyHistoryEntry[]> {\n\t\tconst model = await this.getModel(resource);\n\t\tif (token.isCancellationRequested) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst entries = await model.getEntries();\n\t\treturn entries ?? [];\n\t}\n\n\tasync getAll(token: CancellationToken): Promise<readonly URI[]> {\n\t\tconst historyHome = await this.localHistoryHome.p;\n\t\tif (token.isCancellationRequested) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst all = new ResourceMap<true>();\n\n\t\t// Fill in all known model resources (they might not have yet persisted to disk)\n\t\tfor (const [resource, model] of this.models) {\n\t\t\tconst hasInMemoryEntries = await model.hasEntries(\n\t\t\t\ttrue /* skip resolving because we resolve below from disk */,\n\t\t\t);\n\t\t\tif (hasInMemoryEntries) {\n\t\t\t\tall.set(resource, true);\n\t\t\t}\n\t\t}\n\n\t\t// Resolve all other resources by iterating the history home folder\n\t\ttry {\n\t\t\tconst resolvedHistoryHome =\n\t\t\t\tawait this.fileService.resolve(historyHome);\n\t\t\tif (resolvedHistoryHome.children) {\n\t\t\t\tconst limiter = new Limiter(MAX_PARALLEL_HISTORY_IO_OPS);\n\t\t\t\tconst promises = [];\n\n\t\t\t\tfor (const child of resolvedHistoryHome.children) {\n\t\t\t\t\tpromises.push(\n\t\t\t\t\t\tlimiter.queue(async () => {\n\t\t\t\t\t\t\tif (token.isCancellationRequested) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tconst serializedModel: ISerializedWorkingCopyHistoryModel =\n\t\t\t\t\t\t\t\t\tJSON.parse(\n\t\t\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\t\t\tawait this.fileService.readFile(\n\t\t\t\t\t\t\t\t\t\t\t\tjoinPath(\n\t\t\t\t\t\t\t\t\t\t\t\t\tchild.resource,\n\t\t\t\t\t\t\t\t\t\t\t\t\tWorkingCopyHistoryModel.ENTRIES_FILE,\n\t\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t).value.toString(),\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (serializedModel.entries.length > 0) {\n\t\t\t\t\t\t\t\t\tall.set(\n\t\t\t\t\t\t\t\t\t\tURI.parse(serializedModel.resource),\n\t\t\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\t// ignore - model might be missing or corrupt, but we need it\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tawait Promise.all(promises);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// ignore - history might be entirely empty\n\t\t}\n\n\t\treturn Array.from(all.keys());\n\t}\n\n\tprivate async getModel(resource: URI): Promise<WorkingCopyHistoryModel> {\n\t\tconst historyHome = await this.localHistoryHome.p;\n\n\t\tlet model = this.models.get(resource);\n\t\tif (!model) {\n\t\t\tmodel = new WorkingCopyHistoryModel(\n\t\t\t\tresource,\n\t\t\t\thistoryHome,\n\t\t\t\tthis._onDidAddEntry,\n\t\t\t\tthis._onDidChangeEntry,\n\t\t\t\tthis._onDidReplaceEntry,\n\t\t\t\tthis._onDidRemoveEntry,\n\t\t\t\tthis.getModelOptions(),\n\t\t\t\tthis.fileService,\n\t\t\t\tthis.labelService,\n\t\t\t\tthis.logService,\n\t\t\t\tthis.configurationService,\n\t\t\t);\n\t\t\tthis.models.set(resource, model);\n\t\t}\n\n\t\treturn model;\n\t}\n\n\tprotected abstract getModelOptions(): IWorkingCopyHistoryModelOptions;\n}\n\nexport class NativeWorkingCopyHistoryService extends WorkingCopyHistoryService {\n\tprivate static readonly STORE_ALL_INTERVAL = 5 * 60 * 1000; // 5min\n\n\tprivate readonly isRemotelyStored =\n\t\ttypeof this.environmentService.remoteAuthority === \"string\";\n\n\tprivate readonly storeAllCts = this._register(\n\t\tnew CancellationTokenSource(),\n\t);\n\tprivate readonly storeAllScheduler = this._register(\n\t\tnew RunOnceScheduler(\n\t\t\t() => this.storeAll(this.storeAllCts.token),\n\t\t\tNativeWorkingCopyHistoryService.STORE_ALL_INTERVAL,\n\t\t),\n\t);\n\n\tconstructor(\n\t\t@IFileService fileService: IFileService,\n\t\t@IRemoteAgentService remoteAgentService: IRemoteAgentService,\n\t\t@IWorkbenchEnvironmentService environmentService: IWorkbenchEnvironmentService,\n\t\t@IUriIdentityService uriIdentityService: IUriIdentityService,\n\t\t@ILabelService labelService: ILabelService,\n\t\t@ILifecycleService private readonly lifecycleService: ILifecycleService,\n\t\t@ILogService logService: ILogService,\n\t\t@IConfigurationService configurationService: IConfigurationService\n\t) {\n\t\tsuper(fileService, remoteAgentService, environmentService, uriIdentityService, labelService, logService, configurationService);\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tif (!this.isRemotelyStored) {\n\t\t\t// Local: persist all on shutdown\n\t\t\tthis._register(\n\t\t\t\tthis.lifecycleService.onWillShutdown((e) =>\n\t\t\t\t\tthis.onWillShutdown(e),\n\t\t\t\t),\n\t\t\t);\n\n\t\t\t// Local: schedule persist on change\n\t\t\tthis._register(\n\t\t\t\tEvent.any(\n\t\t\t\t\tthis.onDidAddEntry,\n\t\t\t\t\tthis.onDidChangeEntry,\n\t\t\t\t\tthis.onDidReplaceEntry,\n\t\t\t\t\tthis.onDidRemoveEntry,\n\t\t\t\t)(() => this.onDidChangeModels()),\n\t\t\t);\n\t\t}\n\t}\n\n\tprotected getModelOptions(): IWorkingCopyHistoryModelOptions {\n\t\treturn {\n\t\t\tflushOnChange:\n\t\t\t\tthis\n\t\t\t\t\t.isRemotelyStored /* because the connection might drop anytime */,\n\t\t};\n\t}\n\n\tprivate onWillShutdown(e: WillShutdownEvent): void {\n\t\t// Dispose the scheduler...\n\t\tthis.storeAllScheduler.dispose();\n\t\tthis.storeAllCts.dispose(true);\n\n\t\t// ...because we now explicitly store all models\n\t\te.join(this.storeAll(e.token), {\n\t\t\tid: \"join.workingCopyHistory\",\n\t\t\tlabel: localize(\"join.workingCopyHistory\", \"Saving local history\"),\n\t\t});\n\t}\n\n\tprivate onDidChangeModels(): void {\n\t\tif (!this.storeAllScheduler.isScheduled()) {\n\t\t\tthis.storeAllScheduler.schedule();\n\t\t}\n\t}\n\n\tprivate async storeAll(token: CancellationToken): Promise<void> {\n\t\tconst limiter = new Limiter(MAX_PARALLEL_HISTORY_IO_OPS);\n\t\tconst promises = [];\n\n\t\tconst models = Array.from(this.models.values());\n\t\tfor (const model of models) {\n\t\t\tpromises.push(\n\t\t\t\tlimiter.queue(async () => {\n\t\t\t\t\tif (token.isCancellationRequested) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait model.store(token);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tthis.logService.trace(error);\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\tawait Promise.all(promises);\n\t}\n}\n\n// Register History Tracker\nRegistry.as<IWorkbenchContributionsRegistry>(\n\tWorkbenchExtensions.Workbench,\n).registerWorkbenchContribution(\n\tWorkingCopyHistoryTracker,\n\tLifecyclePhase.Restored,\n);\n"],
  "mappings": "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",
  "names": ["error"]
}
