{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/workingCopy/common/workingCopyService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { InstantiationType, registerSingleton } from '../../../../platform/instantiation/common/extensions.js';\nimport { Event, Emitter } from '../../../../base/common/event.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { Disposable, IDisposable, toDisposable, DisposableStore, DisposableMap } from '../../../../base/common/lifecycle.js';\nimport { ResourceMap } from '../../../../base/common/map.js';\nimport { IWorkingCopy, IWorkingCopyIdentifier, IWorkingCopySaveEvent as IBaseWorkingCopySaveEvent } from './workingCopy.js';\n\nexport const IWorkingCopyService = createDecorator<IWorkingCopyService>('workingCopyService');\n\nexport interface IWorkingCopySaveEvent extends IBaseWorkingCopySaveEvent {\n\n\t/**\n\t * The working copy that was saved.\n\t */\n\treadonly workingCopy: IWorkingCopy;\n}\n\nexport interface IWorkingCopyService {\n\n\treadonly _serviceBrand: undefined;\n\n\n\t//#region Events\n\n\t/**\n\t * An event for when a working copy was registered.\n\t */\n\treadonly onDidRegister: Event<IWorkingCopy>;\n\n\t/**\n\t * An event for when a working copy was unregistered.\n\t */\n\treadonly onDidUnregister: Event<IWorkingCopy>;\n\n\t/**\n\t * An event for when a working copy dirty state changed.\n\t */\n\treadonly onDidChangeDirty: Event<IWorkingCopy>;\n\n\t/**\n\t * An event for when a working copy's content changed.\n\t */\n\treadonly onDidChangeContent: Event<IWorkingCopy>;\n\n\t/**\n\t * An event for when a working copy was saved.\n\t */\n\treadonly onDidSave: Event<IWorkingCopySaveEvent>;\n\n\t//#endregion\n\n\n\t//#region Dirty Tracking\n\n\t/**\n\t * The number of dirty working copies that are registered.\n\t */\n\treadonly dirtyCount: number;\n\n\t/**\n\t * All dirty working copies that are registered.\n\t */\n\treadonly dirtyWorkingCopies: readonly IWorkingCopy[];\n\n\t/**\n\t * The number of modified working copies that are registered,\n\t * including scratchpads, which are never dirty.\n\t */\n\treadonly modifiedCount: number;\n\n\t/**\n\t * All working copies with unsaved changes,\n\t * including scratchpads, which are never dirty.\n\t */\n\treadonly modifiedWorkingCopies: readonly IWorkingCopy[];\n\n\t/**\n\t * Whether there is any registered working copy that is dirty.\n\t */\n\treadonly hasDirty: boolean;\n\n\t/**\n\t * Figure out if working copies with the given\n\t * resource are dirty or not.\n\t *\n\t * @param resource the URI of the working copy\n\t * @param typeId optional type identifier to only\n\t * consider working copies of that type.\n\t */\n\tisDirty(resource: URI, typeId?: string): boolean;\n\n\t//#endregion\n\n\n\t//#region Registry\n\n\t/**\n\t * All working copies that are registered.\n\t */\n\treadonly workingCopies: readonly IWorkingCopy[];\n\n\t/**\n\t * Register a new working copy with the service. This method will\n\t * throw if you try to register a working copy on a resource that\n\t * has already been registered.\n\t *\n\t * Overall there can only ever be 1 working copy with the same\n\t * resource.\n\t */\n\tregisterWorkingCopy(workingCopy: IWorkingCopy): IDisposable;\n\n\t/**\n\t * Whether a working copy with the given resource or identifier\n\t * exists.\n\t */\n\thas(identifier: IWorkingCopyIdentifier): boolean;\n\thas(resource: URI): boolean;\n\n\t/**\n\t * Returns a working copy with the given identifier or `undefined`\n\t * if no such working copy exists.\n\t */\n\tget(identifier: IWorkingCopyIdentifier): IWorkingCopy | undefined;\n\n\t/**\n\t * Returns all working copies with the given resource or `undefined`\n\t * if no such working copy exists.\n\t */\n\tgetAll(resource: URI): readonly IWorkingCopy[] | undefined;\n\n\t//#endregion\n}\n\nexport class WorkingCopyService extends Disposable implements IWorkingCopyService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\t//#region Events\n\n\tprivate readonly _onDidRegister = this._register(new Emitter<IWorkingCopy>());\n\treadonly onDidRegister = this._onDidRegister.event;\n\n\tprivate readonly _onDidUnregister = this._register(new Emitter<IWorkingCopy>());\n\treadonly onDidUnregister = this._onDidUnregister.event;\n\n\tprivate readonly _onDidChangeDirty = this._register(new Emitter<IWorkingCopy>());\n\treadonly onDidChangeDirty = this._onDidChangeDirty.event;\n\n\tprivate readonly _onDidChangeContent = this._register(new Emitter<IWorkingCopy>());\n\treadonly onDidChangeContent = this._onDidChangeContent.event;\n\n\tprivate readonly _onDidSave = this._register(new Emitter<IWorkingCopySaveEvent>());\n\treadonly onDidSave = this._onDidSave.event;\n\n\t//#endregion\n\n\n\t//#region Registry\n\n\tget workingCopies(): IWorkingCopy[] { return Array.from(this._workingCopies.values()); }\n\tprivate _workingCopies = new Set<IWorkingCopy>();\n\n\tprivate readonly mapResourceToWorkingCopies = new ResourceMap<Map<string, IWorkingCopy>>();\n\tprivate readonly mapWorkingCopyToListeners = this._register(new DisposableMap<IWorkingCopy>());\n\n\tregisterWorkingCopy(workingCopy: IWorkingCopy): IDisposable {\n\t\tlet workingCopiesForResource = this.mapResourceToWorkingCopies.get(workingCopy.resource);\n\t\tif (workingCopiesForResource?.has(workingCopy.typeId)) {\n\t\t\tthrow new Error(`Cannot register more than one working copy with the same resource ${workingCopy.resource.toString()} and type ${workingCopy.typeId}.`);\n\t\t}\n\n\t\t// Registry (all)\n\t\tthis._workingCopies.add(workingCopy);\n\n\t\t// Registry (type based)\n\t\tif (!workingCopiesForResource) {\n\t\t\tworkingCopiesForResource = new Map();\n\t\t\tthis.mapResourceToWorkingCopies.set(workingCopy.resource, workingCopiesForResource);\n\t\t}\n\t\tworkingCopiesForResource.set(workingCopy.typeId, workingCopy);\n\n\t\t// Wire in Events\n\t\tconst disposables = new DisposableStore();\n\t\tdisposables.add(workingCopy.onDidChangeContent(() => this._onDidChangeContent.fire(workingCopy)));\n\t\tdisposables.add(workingCopy.onDidChangeDirty(() => this._onDidChangeDirty.fire(workingCopy)));\n\t\tdisposables.add(workingCopy.onDidSave(e => this._onDidSave.fire({ workingCopy, ...e })));\n\t\tthis.mapWorkingCopyToListeners.set(workingCopy, disposables);\n\n\t\t// Send some initial events\n\t\tthis._onDidRegister.fire(workingCopy);\n\t\tif (workingCopy.isDirty()) {\n\t\t\tthis._onDidChangeDirty.fire(workingCopy);\n\t\t}\n\n\t\treturn toDisposable(() => {\n\n\t\t\t// Unregister working copy\n\t\t\tthis.unregisterWorkingCopy(workingCopy);\n\n\t\t\t// Signal as event\n\t\t\tthis._onDidUnregister.fire(workingCopy);\n\t\t});\n\t}\n\n\tprotected unregisterWorkingCopy(workingCopy: IWorkingCopy): void {\n\n\t\t// Registry (all)\n\t\tthis._workingCopies.delete(workingCopy);\n\n\t\t// Registry (type based)\n\t\tconst workingCopiesForResource = this.mapResourceToWorkingCopies.get(workingCopy.resource);\n\t\tif (workingCopiesForResource?.delete(workingCopy.typeId) && workingCopiesForResource.size === 0) {\n\t\t\tthis.mapResourceToWorkingCopies.delete(workingCopy.resource);\n\t\t}\n\n\t\t// If copy is dirty, ensure to fire an event to signal the dirty change\n\t\t// (a disposed working copy cannot account for being dirty in our model)\n\t\tif (workingCopy.isDirty()) {\n\t\t\tthis._onDidChangeDirty.fire(workingCopy);\n\t\t}\n\n\t\t// Remove all listeners associated to working copy\n\t\tthis.mapWorkingCopyToListeners.deleteAndDispose(workingCopy);\n\t}\n\n\thas(identifier: IWorkingCopyIdentifier): boolean;\n\thas(resource: URI): boolean;\n\thas(resourceOrIdentifier: URI | IWorkingCopyIdentifier): boolean {\n\t\tif (URI.isUri(resourceOrIdentifier)) {\n\t\t\treturn this.mapResourceToWorkingCopies.has(resourceOrIdentifier);\n\t\t}\n\n\t\treturn this.mapResourceToWorkingCopies.get(resourceOrIdentifier.resource)?.has(resourceOrIdentifier.typeId) ?? false;\n\t}\n\n\tget(identifier: IWorkingCopyIdentifier): IWorkingCopy | undefined {\n\t\treturn this.mapResourceToWorkingCopies.get(identifier.resource)?.get(identifier.typeId);\n\t}\n\n\tgetAll(resource: URI): readonly IWorkingCopy[] | undefined {\n\t\tconst workingCopies = this.mapResourceToWorkingCopies.get(resource);\n\t\tif (!workingCopies) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn Array.from(workingCopies.values());\n\t}\n\n\t//#endregion\n\n\n\t//#region Dirty Tracking\n\n\tget hasDirty(): boolean {\n\t\tfor (const workingCopy of this._workingCopies) {\n\t\t\tif (workingCopy.isDirty()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tget dirtyCount(): number {\n\t\tlet totalDirtyCount = 0;\n\n\t\tfor (const workingCopy of this._workingCopies) {\n\t\t\tif (workingCopy.isDirty()) {\n\t\t\t\ttotalDirtyCount++;\n\t\t\t}\n\t\t}\n\n\t\treturn totalDirtyCount;\n\t}\n\n\tget dirtyWorkingCopies(): IWorkingCopy[] {\n\t\treturn this.workingCopies.filter(workingCopy => workingCopy.isDirty());\n\t}\n\n\tget modifiedCount(): number {\n\t\tlet totalModifiedCount = 0;\n\n\t\tfor (const workingCopy of this._workingCopies) {\n\t\t\tif (workingCopy.isModified()) {\n\t\t\t\ttotalModifiedCount++;\n\t\t\t}\n\t\t}\n\n\t\treturn totalModifiedCount;\n\t}\n\n\tget modifiedWorkingCopies(): IWorkingCopy[] {\n\t\treturn this.workingCopies.filter(workingCopy => workingCopy.isModified());\n\t}\n\n\tisDirty(resource: URI, typeId?: string): boolean {\n\t\tconst workingCopies = this.mapResourceToWorkingCopies.get(resource);\n\t\tif (workingCopies) {\n\n\t\t\t// For a specific type\n\t\t\tif (typeof typeId === 'string') {\n\t\t\t\treturn workingCopies.get(typeId)?.isDirty() ?? false;\n\t\t\t}\n\n\t\t\t// Across all working copies\n\t\t\telse {\n\t\t\t\tfor (const [, workingCopy] of workingCopies) {\n\t\t\t\t\tif (workingCopy.isDirty()) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t//#endregion\n}\n\nregisterSingleton(IWorkingCopyService, WorkingCopyService, InstantiationType.Delayed);\n"],
  "mappings": "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",
  "names": []
}
