{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/workingCopy/common/workingCopyService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, type Event } from \"../../../../base/common/event.js\";\nimport {\n\tDisposable,\n\tDisposableMap,\n\tDisposableStore,\n\ttype IDisposable,\n\ttoDisposable,\n} from \"../../../../base/common/lifecycle.js\";\nimport { ResourceMap } from \"../../../../base/common/map.js\";\nimport { URI } from \"../../../../base/common/uri.js\";\nimport {\n\tInstantiationType,\n\tregisterSingleton,\n} from \"../../../../platform/instantiation/common/extensions.js\";\nimport { createDecorator } from \"../../../../platform/instantiation/common/instantiation.js\";\nimport type {\n\tIWorkingCopySaveEvent as IBaseWorkingCopySaveEvent,\n\tIWorkingCopy,\n\tIWorkingCopyIdentifier,\n} from \"./workingCopy.js\";\n\nexport const IWorkingCopyService =\n\tcreateDecorator<IWorkingCopyService>(\"workingCopyService\");\n\nexport interface IWorkingCopySaveEvent extends IBaseWorkingCopySaveEvent {\n\t/**\n\t * The working copy that was saved.\n\t */\n\treadonly workingCopy: IWorkingCopy;\n}\n\nexport interface IWorkingCopyService {\n\treadonly _serviceBrand: undefined;\n\n\t//#region Events\n\n\t/**\n\t * An event for when a working copy was registered.\n\t */\n\treadonly onDidRegister: Event<IWorkingCopy>;\n\n\t/**\n\t * An event for when a working copy was unregistered.\n\t */\n\treadonly onDidUnregister: Event<IWorkingCopy>;\n\n\t/**\n\t * An event for when a working copy dirty state changed.\n\t */\n\treadonly onDidChangeDirty: Event<IWorkingCopy>;\n\n\t/**\n\t * An event for when a working copy's content changed.\n\t */\n\treadonly onDidChangeContent: Event<IWorkingCopy>;\n\n\t/**\n\t * An event for when a working copy was saved.\n\t */\n\treadonly onDidSave: Event<IWorkingCopySaveEvent>;\n\n\t//#endregion\n\n\t//#region Dirty Tracking\n\n\t/**\n\t * The number of dirty working copies that are registered.\n\t */\n\treadonly dirtyCount: number;\n\n\t/**\n\t * All dirty working copies that are registered.\n\t */\n\treadonly dirtyWorkingCopies: readonly IWorkingCopy[];\n\n\t/**\n\t * The number of modified working copies that are registered,\n\t * including scratchpads, which are never dirty.\n\t */\n\treadonly modifiedCount: number;\n\n\t/**\n\t * All working copies with unsaved changes,\n\t * including scratchpads, which are never dirty.\n\t */\n\treadonly modifiedWorkingCopies: readonly IWorkingCopy[];\n\n\t/**\n\t * Whether there is any registered working copy that is dirty.\n\t */\n\treadonly hasDirty: boolean;\n\n\t/**\n\t * Figure out if working copies with the given\n\t * resource are dirty or not.\n\t *\n\t * @param resource the URI of the working copy\n\t * @param typeId optional type identifier to only\n\t * consider working copies of that type.\n\t */\n\tisDirty(resource: URI, typeId?: string): boolean;\n\n\t//#endregion\n\n\t//#region Registry\n\n\t/**\n\t * All working copies that are registered.\n\t */\n\treadonly workingCopies: readonly IWorkingCopy[];\n\n\t/**\n\t * Register a new working copy with the service. This method will\n\t * throw if you try to register a working copy on a resource that\n\t * has already been registered.\n\t *\n\t * Overall there can only ever be 1 working copy with the same\n\t * resource.\n\t */\n\tregisterWorkingCopy(workingCopy: IWorkingCopy): IDisposable;\n\n\t/**\n\t * Whether a working copy with the given resource or identifier\n\t * exists.\n\t */\n\thas(identifier: IWorkingCopyIdentifier): boolean;\n\thas(resource: URI): boolean;\n\n\t/**\n\t * Returns a working copy with the given identifier or `undefined`\n\t * if no such working copy exists.\n\t */\n\tget(identifier: IWorkingCopyIdentifier): IWorkingCopy | undefined;\n\n\t/**\n\t * Returns all working copies with the given resource or `undefined`\n\t * if no such working copy exists.\n\t */\n\tgetAll(resource: URI): readonly IWorkingCopy[] | undefined;\n\n\t//#endregion\n}\n\nexport class WorkingCopyService\n\textends Disposable\n\timplements IWorkingCopyService\n{\n\tdeclare readonly _serviceBrand: undefined;\n\n\t//#region Events\n\n\tprivate readonly _onDidRegister = this._register(\n\t\tnew Emitter<IWorkingCopy>(),\n\t);\n\treadonly onDidRegister = this._onDidRegister.event;\n\n\tprivate readonly _onDidUnregister = this._register(\n\t\tnew Emitter<IWorkingCopy>(),\n\t);\n\treadonly onDidUnregister = this._onDidUnregister.event;\n\n\tprivate readonly _onDidChangeDirty = this._register(\n\t\tnew Emitter<IWorkingCopy>(),\n\t);\n\treadonly onDidChangeDirty = this._onDidChangeDirty.event;\n\n\tprivate readonly _onDidChangeContent = this._register(\n\t\tnew Emitter<IWorkingCopy>(),\n\t);\n\treadonly onDidChangeContent = this._onDidChangeContent.event;\n\n\tprivate readonly _onDidSave = this._register(\n\t\tnew Emitter<IWorkingCopySaveEvent>(),\n\t);\n\treadonly onDidSave = this._onDidSave.event;\n\n\t//#endregion\n\n\t//#region Registry\n\n\tget workingCopies(): IWorkingCopy[] {\n\t\treturn Array.from(this._workingCopies.values());\n\t}\n\tprivate _workingCopies = new Set<IWorkingCopy>();\n\n\tprivate readonly mapResourceToWorkingCopies = new ResourceMap<\n\t\tMap<string, IWorkingCopy>\n\t>();\n\tprivate readonly mapWorkingCopyToListeners = this._register(\n\t\tnew DisposableMap<IWorkingCopy>(),\n\t);\n\n\tregisterWorkingCopy(workingCopy: IWorkingCopy): IDisposable {\n\t\tlet workingCopiesForResource = this.mapResourceToWorkingCopies.get(\n\t\t\tworkingCopy.resource,\n\t\t);\n\t\tif (workingCopiesForResource?.has(workingCopy.typeId)) {\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot register more than one working copy with the same resource ${workingCopy.resource.toString()} and type ${workingCopy.typeId}.`,\n\t\t\t);\n\t\t}\n\n\t\t// Registry (all)\n\t\tthis._workingCopies.add(workingCopy);\n\n\t\t// Registry (type based)\n\t\tif (!workingCopiesForResource) {\n\t\t\tworkingCopiesForResource = new Map();\n\t\t\tthis.mapResourceToWorkingCopies.set(\n\t\t\t\tworkingCopy.resource,\n\t\t\t\tworkingCopiesForResource,\n\t\t\t);\n\t\t}\n\t\tworkingCopiesForResource.set(workingCopy.typeId, workingCopy);\n\n\t\t// Wire in Events\n\t\tconst disposables = new DisposableStore();\n\t\tdisposables.add(\n\t\t\tworkingCopy.onDidChangeContent(() =>\n\t\t\t\tthis._onDidChangeContent.fire(workingCopy),\n\t\t\t),\n\t\t);\n\t\tdisposables.add(\n\t\t\tworkingCopy.onDidChangeDirty(() =>\n\t\t\t\tthis._onDidChangeDirty.fire(workingCopy),\n\t\t\t),\n\t\t);\n\t\tdisposables.add(\n\t\t\tworkingCopy.onDidSave((e) =>\n\t\t\t\tthis._onDidSave.fire({ workingCopy, ...e }),\n\t\t\t),\n\t\t);\n\t\tthis.mapWorkingCopyToListeners.set(workingCopy, disposables);\n\n\t\t// Send some initial events\n\t\tthis._onDidRegister.fire(workingCopy);\n\t\tif (workingCopy.isDirty()) {\n\t\t\tthis._onDidChangeDirty.fire(workingCopy);\n\t\t}\n\n\t\treturn toDisposable(() => {\n\t\t\t// Unregister working copy\n\t\t\tthis.unregisterWorkingCopy(workingCopy);\n\n\t\t\t// Signal as event\n\t\t\tthis._onDidUnregister.fire(workingCopy);\n\t\t});\n\t}\n\n\tprotected unregisterWorkingCopy(workingCopy: IWorkingCopy): void {\n\t\t// Registry (all)\n\t\tthis._workingCopies.delete(workingCopy);\n\n\t\t// Registry (type based)\n\t\tconst workingCopiesForResource = this.mapResourceToWorkingCopies.get(\n\t\t\tworkingCopy.resource,\n\t\t);\n\t\tif (\n\t\t\tworkingCopiesForResource?.delete(workingCopy.typeId) &&\n\t\t\tworkingCopiesForResource.size === 0\n\t\t) {\n\t\t\tthis.mapResourceToWorkingCopies.delete(workingCopy.resource);\n\t\t}\n\n\t\t// If copy is dirty, ensure to fire an event to signal the dirty change\n\t\t// (a disposed working copy cannot account for being dirty in our model)\n\t\tif (workingCopy.isDirty()) {\n\t\t\tthis._onDidChangeDirty.fire(workingCopy);\n\t\t}\n\n\t\t// Remove all listeners associated to working copy\n\t\tthis.mapWorkingCopyToListeners.deleteAndDispose(workingCopy);\n\t}\n\n\thas(identifier: IWorkingCopyIdentifier): boolean;\n\thas(resource: URI): boolean;\n\thas(resourceOrIdentifier: URI | IWorkingCopyIdentifier): boolean {\n\t\tif (URI.isUri(resourceOrIdentifier)) {\n\t\t\treturn this.mapResourceToWorkingCopies.has(resourceOrIdentifier);\n\t\t}\n\n\t\treturn (\n\t\t\tthis.mapResourceToWorkingCopies\n\t\t\t\t.get(resourceOrIdentifier.resource)\n\t\t\t\t?.has(resourceOrIdentifier.typeId) ?? false\n\t\t);\n\t}\n\n\tget(identifier: IWorkingCopyIdentifier): IWorkingCopy | undefined {\n\t\treturn this.mapResourceToWorkingCopies\n\t\t\t.get(identifier.resource)\n\t\t\t?.get(identifier.typeId);\n\t}\n\n\tgetAll(resource: URI): readonly IWorkingCopy[] | undefined {\n\t\tconst workingCopies = this.mapResourceToWorkingCopies.get(resource);\n\t\tif (!workingCopies) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn Array.from(workingCopies.values());\n\t}\n\n\t//#endregion\n\n\t//#region Dirty Tracking\n\n\tget hasDirty(): boolean {\n\t\tfor (const workingCopy of this._workingCopies) {\n\t\t\tif (workingCopy.isDirty()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tget dirtyCount(): number {\n\t\tlet totalDirtyCount = 0;\n\n\t\tfor (const workingCopy of this._workingCopies) {\n\t\t\tif (workingCopy.isDirty()) {\n\t\t\t\ttotalDirtyCount++;\n\t\t\t}\n\t\t}\n\n\t\treturn totalDirtyCount;\n\t}\n\n\tget dirtyWorkingCopies(): IWorkingCopy[] {\n\t\treturn this.workingCopies.filter((workingCopy) =>\n\t\t\tworkingCopy.isDirty(),\n\t\t);\n\t}\n\n\tget modifiedCount(): number {\n\t\tlet totalModifiedCount = 0;\n\n\t\tfor (const workingCopy of this._workingCopies) {\n\t\t\tif (workingCopy.isModified()) {\n\t\t\t\ttotalModifiedCount++;\n\t\t\t}\n\t\t}\n\n\t\treturn totalModifiedCount;\n\t}\n\n\tget modifiedWorkingCopies(): IWorkingCopy[] {\n\t\treturn this.workingCopies.filter((workingCopy) =>\n\t\t\tworkingCopy.isModified(),\n\t\t);\n\t}\n\n\tisDirty(resource: URI, typeId?: string): boolean {\n\t\tconst workingCopies = this.mapResourceToWorkingCopies.get(resource);\n\t\tif (workingCopies) {\n\t\t\t// For a specific type\n\t\t\tif (typeof typeId === \"string\") {\n\t\t\t\treturn workingCopies.get(typeId)?.isDirty() ?? false;\n\t\t\t}\n\n\t\t\t// Across all working copies\n\t\t\telse {\n\t\t\t\tfor (const [, workingCopy] of workingCopies) {\n\t\t\t\t\tif (workingCopy.isDirty()) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t//#endregion\n}\n\nregisterSingleton(\n\tIWorkingCopyService,\n\tWorkingCopyService,\n\tInstantiationType.Delayed,\n);\n"],
  "mappings": "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",
  "names": []
}
