{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/workingCopy/common/workingCopyBackupTracker.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Promises } from \"../../../../base/common/async.js\";\nimport { CancellationTokenSource } from \"../../../../base/common/cancellation.js\";\nimport {\n\tDisposable,\n\ttype IDisposable,\n\ttoDisposable,\n} from \"../../../../base/common/lifecycle.js\";\nimport type { ILogService } from \"../../../../platform/log/common/log.js\";\nimport { EditorsOrder } from \"../../../common/editor.js\";\nimport type { EditorInput } from \"../../../common/editor/editorInput.js\";\nimport type { IEditorGroupsService } from \"../../editor/common/editorGroupsService.js\";\nimport type { IEditorService } from \"../../editor/common/editorService.js\";\nimport type { IFilesConfigurationService } from \"../../filesConfiguration/common/filesConfigurationService.js\";\nimport {\n\ttype ILifecycleService,\n\ttype InternalBeforeShutdownEvent,\n\tLifecyclePhase,\n\ttype ShutdownReason,\n} from \"../../lifecycle/common/lifecycle.js\";\nimport {\n\ttype IWorkingCopy,\n\ttype IWorkingCopyIdentifier,\n\tWorkingCopyCapabilities,\n} from \"./workingCopy.js\";\nimport type { IWorkingCopyBackupService } from \"./workingCopyBackup.js\";\nimport type {\n\tIWorkingCopyEditorHandler,\n\tIWorkingCopyEditorService,\n} from \"./workingCopyEditorService.js\";\nimport type { IWorkingCopyService } from \"./workingCopyService.js\";\n\n/**\n * The working copy backup tracker deals with:\n * - restoring backups that exist\n * - creating backups for modified working copies\n * - deleting backups for saved working copies\n * - handling backups on shutdown\n */\nexport abstract class WorkingCopyBackupTracker extends Disposable {\n\tconstructor(\n\t\tprotected readonly workingCopyBackupService: IWorkingCopyBackupService,\n\t\tprotected readonly workingCopyService: IWorkingCopyService,\n\t\tprotected readonly logService: ILogService,\n\t\tprivate readonly lifecycleService: ILifecycleService,\n\t\tprotected readonly filesConfigurationService: IFilesConfigurationService,\n\t\tprivate readonly workingCopyEditorService: IWorkingCopyEditorService,\n\t\tprotected readonly editorService: IEditorService,\n\t\tprivate readonly editorGroupService: IEditorGroupsService,\n\t) {\n\t\tsuper();\n\n\t\t// Fill in initial modified working copies\n\t\tfor (const workingCopy of this.workingCopyService\n\t\t\t.modifiedWorkingCopies) {\n\t\t\tthis.onDidRegister(workingCopy);\n\t\t}\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners() {\n\t\t// Working Copy events\n\t\tthis._register(\n\t\t\tthis.workingCopyService.onDidRegister((workingCopy) =>\n\t\t\t\tthis.onDidRegister(workingCopy),\n\t\t\t),\n\t\t);\n\t\tthis._register(\n\t\t\tthis.workingCopyService.onDidUnregister((workingCopy) =>\n\t\t\t\tthis.onDidUnregister(workingCopy),\n\t\t\t),\n\t\t);\n\t\tthis._register(\n\t\t\tthis.workingCopyService.onDidChangeDirty((workingCopy) =>\n\t\t\t\tthis.onDidChangeDirty(workingCopy),\n\t\t\t),\n\t\t);\n\t\tthis._register(\n\t\t\tthis.workingCopyService.onDidChangeContent((workingCopy) =>\n\t\t\t\tthis.onDidChangeContent(workingCopy),\n\t\t\t),\n\t\t);\n\n\t\t// Lifecycle\n\t\tthis._register(\n\t\t\tthis.lifecycleService.onBeforeShutdown((event) =>\n\t\t\t\t(event as InternalBeforeShutdownEvent).finalVeto(\n\t\t\t\t\t() => this.onFinalBeforeShutdown(event.reason),\n\t\t\t\t\t\"veto.backups\",\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\t\tthis._register(\n\t\t\tthis.lifecycleService.onWillShutdown(() => this.onWillShutdown()),\n\t\t);\n\n\t\t// Once a handler registers, restore backups\n\t\tthis._register(\n\t\t\tthis.workingCopyEditorService.onDidRegisterHandler((handler) =>\n\t\t\t\tthis.restoreBackups(handler),\n\t\t\t),\n\t\t);\n\t}\n\n\tprotected abstract onFinalBeforeShutdown(\n\t\treason: ShutdownReason,\n\t): boolean | Promise<boolean>;\n\n\tprivate onWillShutdown(): void {\n\t\t// Here we know that we will shutdown. Any backup operation that is\n\t\t// already scheduled or being scheduled from this moment on runs\n\t\t// at the risk of corrupting a backup because the backup operation\n\t\t// might terminate at any given time now. As such, we need to disable\n\t\t// this tracker from performing more backups by cancelling pending\n\t\t// operations and suspending the tracker without resuming.\n\n\t\tthis.cancelBackupOperations();\n\t\tthis.suspendBackupOperations();\n\t}\n\n\t//#region Backup Creator\n\n\t// Delay creation of backups when content changes to avoid too much\n\t// load on the backup service when the user is typing into the editor\n\t// Since we always schedule a backup, even when auto save is on, we\n\t// have different scheduling delays based on auto save configuration.\n\t// With 'delayed' we avoid a (not critical but also not really wanted)\n\t// race between saving (after 1s per default) and making a backup of\n\t// the working copy.\n\tprivate static readonly DEFAULT_BACKUP_SCHEDULE_DELAYS = {\n\t\t[\"default\"]: 1000,\n\t\t[\"delayed\"]: 2000,\n\t};\n\n\t// A map from working copy to a version ID we compute on each content\n\t// change. This version ID allows to e.g. ask if a backup for a specific\n\t// content has been made before closing.\n\tprivate readonly mapWorkingCopyToContentVersion = new Map<\n\t\tIWorkingCopy,\n\t\tnumber\n\t>();\n\n\t// A map of scheduled pending backup operations for working copies\n\t// Given https://github.com/microsoft/vscode/issues/158038, we explicitly\n\t// do not store `IWorkingCopy` but the identifier in the map, since it\n\t// looks like GC is not running for the working copy otherwise.\n\tprotected readonly pendingBackupOperations = new Map<\n\t\tIWorkingCopyIdentifier,\n\t\t{ disposable: IDisposable; cancel: () => void }\n\t>();\n\n\tprivate suspended = false;\n\n\tprivate onDidRegister(workingCopy: IWorkingCopy): void {\n\t\tif (this.suspended) {\n\t\t\tthis.logService.warn(\n\t\t\t\t`[backup tracker] suspended, ignoring register event`,\n\t\t\t\tworkingCopy.resource.toString(),\n\t\t\t\tworkingCopy.typeId,\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tif (workingCopy.isModified()) {\n\t\t\tthis.scheduleBackup(workingCopy);\n\t\t}\n\t}\n\n\tprivate onDidUnregister(workingCopy: IWorkingCopy): void {\n\t\t// Remove from content version map\n\t\tthis.mapWorkingCopyToContentVersion.delete(workingCopy);\n\n\t\t// Check suspended\n\t\tif (this.suspended) {\n\t\t\tthis.logService.warn(\n\t\t\t\t`[backup tracker] suspended, ignoring unregister event`,\n\t\t\t\tworkingCopy.resource.toString(),\n\t\t\t\tworkingCopy.typeId,\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\t// Discard backup\n\t\tthis.discardBackup(workingCopy);\n\t}\n\n\tprivate onDidChangeDirty(workingCopy: IWorkingCopy): void {\n\t\tif (this.suspended) {\n\t\t\tthis.logService.warn(\n\t\t\t\t`[backup tracker] suspended, ignoring dirty change event`,\n\t\t\t\tworkingCopy.resource.toString(),\n\t\t\t\tworkingCopy.typeId,\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tif (workingCopy.isDirty()) {\n\t\t\tthis.scheduleBackup(workingCopy);\n\t\t} else {\n\t\t\tthis.discardBackup(workingCopy);\n\t\t}\n\t}\n\n\tprivate onDidChangeContent(workingCopy: IWorkingCopy): void {\n\t\t// Increment content version ID\n\t\tconst contentVersionId = this.getContentVersion(workingCopy);\n\t\tthis.mapWorkingCopyToContentVersion.set(\n\t\t\tworkingCopy,\n\t\t\tcontentVersionId + 1,\n\t\t);\n\n\t\t// Check suspended\n\t\tif (this.suspended) {\n\t\t\tthis.logService.warn(\n\t\t\t\t`[backup tracker] suspended, ignoring content change event`,\n\t\t\t\tworkingCopy.resource.toString(),\n\t\t\t\tworkingCopy.typeId,\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\t// Schedule backup for modified working copies\n\t\tif (workingCopy.isModified()) {\n\t\t\t// this listener will make sure that the backup is\n\t\t\t// pushed out for as long as the user is still changing\n\t\t\t// the content of the working copy.\n\t\t\tthis.scheduleBackup(workingCopy);\n\t\t}\n\t}\n\n\tprivate scheduleBackup(workingCopy: IWorkingCopy): void {\n\t\t// Clear any running backup operation\n\t\tthis.cancelBackupOperation(workingCopy);\n\n\t\tthis.logService.trace(\n\t\t\t`[backup tracker] scheduling backup`,\n\t\t\tworkingCopy.resource.toString(),\n\t\t\tworkingCopy.typeId,\n\t\t);\n\n\t\t// Schedule new backup\n\t\tconst workingCopyIdentifier = {\n\t\t\tresource: workingCopy.resource,\n\t\t\ttypeId: workingCopy.typeId,\n\t\t};\n\t\tconst cts = new CancellationTokenSource();\n\t\tconst handle = setTimeout(async () => {\n\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Backup if modified\n\t\t\tif (workingCopy.isModified()) {\n\t\t\t\tthis.logService.trace(\n\t\t\t\t\t`[backup tracker] creating backup`,\n\t\t\t\t\tworkingCopy.resource.toString(),\n\t\t\t\t\tworkingCopy.typeId,\n\t\t\t\t);\n\n\t\t\t\ttry {\n\t\t\t\t\tconst backup = await workingCopy.backup(cts.token);\n\t\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (workingCopy.isModified()) {\n\t\t\t\t\t\tthis.logService.trace(\n\t\t\t\t\t\t\t`[backup tracker] storing backup`,\n\t\t\t\t\t\t\tworkingCopy.resource.toString(),\n\t\t\t\t\t\t\tworkingCopy.typeId,\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tawait this.workingCopyBackupService.backup(\n\t\t\t\t\t\t\tworkingCopy,\n\t\t\t\t\t\t\tbackup.content,\n\t\t\t\t\t\t\tthis.getContentVersion(workingCopy),\n\t\t\t\t\t\t\tbackup.meta,\n\t\t\t\t\t\t\tcts.token,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.logService.error(error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Clear disposable unless we got canceled which would\n\t\t\t// indicate another operation has started meanwhile\n\t\t\tif (!cts.token.isCancellationRequested) {\n\t\t\t\tthis.doClearPendingBackupOperation(workingCopyIdentifier);\n\t\t\t}\n\t\t}, this.getBackupScheduleDelay(workingCopy));\n\n\t\t// Keep in map for disposal as needed\n\t\tthis.pendingBackupOperations.set(workingCopyIdentifier, {\n\t\t\tcancel: () => {\n\t\t\t\tthis.logService.trace(\n\t\t\t\t\t`[backup tracker] clearing pending backup creation`,\n\t\t\t\t\tworkingCopy.resource.toString(),\n\t\t\t\t\tworkingCopy.typeId,\n\t\t\t\t);\n\n\t\t\t\tcts.cancel();\n\t\t\t},\n\t\t\tdisposable: toDisposable(() => {\n\t\t\t\tcts.dispose();\n\t\t\t\tclearTimeout(handle);\n\t\t\t}),\n\t\t});\n\t}\n\n\tprotected getBackupScheduleDelay(workingCopy: IWorkingCopy): number {\n\t\tif (typeof workingCopy.backupDelay === \"number\") {\n\t\t\treturn workingCopy.backupDelay; // respect working copy override\n\t\t}\n\n\t\tlet backupScheduleDelay: \"default\" | \"delayed\";\n\t\tif (workingCopy.capabilities & WorkingCopyCapabilities.Untitled) {\n\t\t\tbackupScheduleDelay = \"default\"; // auto-save is never on for untitled working copies\n\t\t} else {\n\t\t\tbackupScheduleDelay =\n\t\t\t\tthis.filesConfigurationService.hasShortAutoSaveDelay(\n\t\t\t\t\tworkingCopy.resource,\n\t\t\t\t)\n\t\t\t\t\t? \"delayed\"\n\t\t\t\t\t: \"default\";\n\t\t}\n\n\t\treturn WorkingCopyBackupTracker.DEFAULT_BACKUP_SCHEDULE_DELAYS[\n\t\t\tbackupScheduleDelay\n\t\t];\n\t}\n\n\tprotected getContentVersion(workingCopy: IWorkingCopy): number {\n\t\treturn this.mapWorkingCopyToContentVersion.get(workingCopy) || 0;\n\t}\n\n\tprivate discardBackup(workingCopy: IWorkingCopy): void {\n\t\t// Clear any running backup operation\n\t\tthis.cancelBackupOperation(workingCopy);\n\n\t\t// Schedule backup discard asap\n\t\tconst workingCopyIdentifier = {\n\t\t\tresource: workingCopy.resource,\n\t\t\ttypeId: workingCopy.typeId,\n\t\t};\n\t\tconst cts = new CancellationTokenSource();\n\t\tthis.doDiscardBackup(workingCopyIdentifier, cts);\n\n\t\t// Keep in map for disposal as needed\n\t\tthis.pendingBackupOperations.set(workingCopyIdentifier, {\n\t\t\tcancel: () => {\n\t\t\t\tthis.logService.trace(\n\t\t\t\t\t`[backup tracker] clearing pending backup discard`,\n\t\t\t\t\tworkingCopy.resource.toString(),\n\t\t\t\t\tworkingCopy.typeId,\n\t\t\t\t);\n\n\t\t\t\tcts.cancel();\n\t\t\t},\n\t\t\tdisposable: cts,\n\t\t});\n\t}\n\n\tprivate async doDiscardBackup(\n\t\tworkingCopyIdentifier: IWorkingCopyIdentifier,\n\t\tcts: CancellationTokenSource,\n\t) {\n\t\tthis.logService.trace(\n\t\t\t`[backup tracker] discarding backup`,\n\t\t\tworkingCopyIdentifier.resource.toString(),\n\t\t\tworkingCopyIdentifier.typeId,\n\t\t);\n\n\t\t// Discard backup\n\t\ttry {\n\t\t\tawait this.workingCopyBackupService.discardBackup(\n\t\t\t\tworkingCopyIdentifier,\n\t\t\t\tcts.token,\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tthis.logService.error(error);\n\t\t}\n\n\t\t// Clear disposable unless we got canceled which would\n\t\t// indicate another operation has started meanwhile\n\t\tif (!cts.token.isCancellationRequested) {\n\t\t\tthis.doClearPendingBackupOperation(workingCopyIdentifier);\n\t\t}\n\t}\n\n\tprivate cancelBackupOperation(workingCopy: IWorkingCopy): void {\n\t\t// Given a working copy we want to find the matching\n\t\t// identifier in our pending operations map because\n\t\t// we cannot use the working copy directly, as the\n\t\t// identifier might have different object identity.\n\n\t\tlet workingCopyIdentifier: IWorkingCopyIdentifier | undefined;\n\t\tfor (const [identifier] of this.pendingBackupOperations) {\n\t\t\tif (\n\t\t\t\tidentifier.resource.toString() ===\n\t\t\t\t\tworkingCopy.resource.toString() &&\n\t\t\t\tidentifier.typeId === workingCopy.typeId\n\t\t\t) {\n\t\t\t\tworkingCopyIdentifier = identifier;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (workingCopyIdentifier) {\n\t\t\tthis.doClearPendingBackupOperation(workingCopyIdentifier, {\n\t\t\t\tcancel: true,\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate doClearPendingBackupOperation(\n\t\tworkingCopyIdentifier: IWorkingCopyIdentifier,\n\t\toptions?: { cancel: boolean },\n\t): void {\n\t\tconst pendingBackupOperation = this.pendingBackupOperations.get(\n\t\t\tworkingCopyIdentifier,\n\t\t);\n\t\tif (!pendingBackupOperation) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (options?.cancel) {\n\t\t\tpendingBackupOperation.cancel();\n\t\t}\n\n\t\tpendingBackupOperation.disposable.dispose();\n\n\t\tthis.pendingBackupOperations.delete(workingCopyIdentifier);\n\t}\n\n\tprotected cancelBackupOperations(): void {\n\t\tfor (const [, operation] of this.pendingBackupOperations) {\n\t\t\toperation.cancel();\n\t\t\toperation.disposable.dispose();\n\t\t}\n\n\t\tthis.pendingBackupOperations.clear();\n\t}\n\n\tprotected suspendBackupOperations(): { resume: () => void } {\n\t\tthis.suspended = true;\n\n\t\treturn { resume: () => (this.suspended = false) };\n\t}\n\n\t//#endregion\n\n\t//#region Backup Restorer\n\n\tprotected readonly unrestoredBackups = new Set<IWorkingCopyIdentifier>();\n\tprotected readonly whenReady = this.resolveBackupsToRestore();\n\n\tprivate _isReady = false;\n\tprotected get isReady(): boolean {\n\t\treturn this._isReady;\n\t}\n\n\tprivate async resolveBackupsToRestore(): Promise<void> {\n\t\t// Wait for resolving backups until we are restored to reduce startup pressure\n\t\tawait this.lifecycleService.when(LifecyclePhase.Restored);\n\n\t\t// Remember each backup that needs to restore\n\t\tfor (const backup of await this.workingCopyBackupService.getBackups()) {\n\t\t\tthis.unrestoredBackups.add(backup);\n\t\t}\n\n\t\tthis._isReady = true;\n\t}\n\n\tprotected async restoreBackups(\n\t\thandler: IWorkingCopyEditorHandler,\n\t): Promise<void> {\n\t\t// Wait for backups to be resolved\n\t\tawait this.whenReady;\n\n\t\t// Figure out already opened editors for backups vs\n\t\t// non-opened.\n\t\tconst openedEditorsForBackups = new Set<EditorInput>();\n\t\tconst nonOpenedEditorsForBackups = new Set<EditorInput>();\n\n\t\t// Ensure each backup that can be handled has an\n\t\t// associated editor.\n\t\tconst restoredBackups = new Set<IWorkingCopyIdentifier>();\n\t\tfor (const unrestoredBackup of this.unrestoredBackups) {\n\t\t\tconst canHandleUnrestoredBackup =\n\t\t\t\tawait handler.handles(unrestoredBackup);\n\t\t\tif (!canHandleUnrestoredBackup) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Collect already opened editors for backup\n\t\t\tlet hasOpenedEditorForBackup = false;\n\t\t\tfor (const { editor } of this.editorService.getEditors(\n\t\t\t\tEditorsOrder.MOST_RECENTLY_ACTIVE,\n\t\t\t)) {\n\t\t\t\tconst isUnrestoredBackupOpened = handler.isOpen(\n\t\t\t\t\tunrestoredBackup,\n\t\t\t\t\teditor,\n\t\t\t\t);\n\t\t\t\tif (isUnrestoredBackupOpened) {\n\t\t\t\t\topenedEditorsForBackups.add(editor);\n\t\t\t\t\thasOpenedEditorForBackup = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Otherwise, make sure to create at least one editor\n\t\t\t// for the backup to show\n\t\t\tif (!hasOpenedEditorForBackup) {\n\t\t\t\tnonOpenedEditorsForBackups.add(\n\t\t\t\t\tawait handler.createEditor(unrestoredBackup),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Remember as (potentially) restored\n\t\t\trestoredBackups.add(unrestoredBackup);\n\t\t}\n\n\t\t// Ensure editors are opened for each backup without editor\n\t\t// in the background without stealing focus\n\t\tif (nonOpenedEditorsForBackups.size > 0) {\n\t\t\tawait this.editorGroupService.activeGroup.openEditors(\n\t\t\t\t[...nonOpenedEditorsForBackups].map(\n\t\t\t\t\t(nonOpenedEditorForBackup) => ({\n\t\t\t\t\t\teditor: nonOpenedEditorForBackup,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tpinned: true,\n\t\t\t\t\t\t\tpreserveFocus: true,\n\t\t\t\t\t\t\tinactive: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t);\n\n\t\t\tfor (const nonOpenedEditorForBackup of nonOpenedEditorsForBackups) {\n\t\t\t\topenedEditorsForBackups.add(nonOpenedEditorForBackup);\n\t\t\t}\n\t\t}\n\n\t\t// Then, resolve each opened editor to make sure the working copy\n\t\t// is loaded and the modified editor appears properly.\n\t\t// We only do that for editors that are not active in a group\n\t\t// already to prevent calling `resolve` twice!\n\t\tawait Promises.settled(\n\t\t\t[...openedEditorsForBackups].map(async (openedEditorForBackup) => {\n\t\t\t\tif (this.editorService.isVisible(openedEditorForBackup)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\treturn openedEditorForBackup.resolve();\n\t\t\t}),\n\t\t);\n\n\t\t// Finally, remove all handled backups from the list\n\t\tfor (const restoredBackup of restoredBackups) {\n\t\t\tthis.unrestoredBackups.delete(restoredBackup);\n\t\t}\n\t}\n\n\t//#endregion\n}\n"],
  "mappings": "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",
  "names": []
}
