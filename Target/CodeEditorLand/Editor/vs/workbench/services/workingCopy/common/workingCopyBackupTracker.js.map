{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/workingCopy/common/workingCopyBackupTracker.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IWorkingCopyBackupService } from './workingCopyBackup.js';\nimport { Disposable, IDisposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { IWorkingCopyService } from './workingCopyService.js';\nimport { IWorkingCopy, IWorkingCopyIdentifier, WorkingCopyCapabilities } from './workingCopy.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { ShutdownReason, ILifecycleService, LifecyclePhase, InternalBeforeShutdownEvent } from '../../lifecycle/common/lifecycle.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { IFilesConfigurationService } from '../../filesConfiguration/common/filesConfigurationService.js';\nimport { IWorkingCopyEditorHandler, IWorkingCopyEditorService } from './workingCopyEditorService.js';\nimport { Promises } from '../../../../base/common/async.js';\nimport { IEditorService } from '../../editor/common/editorService.js';\nimport { EditorsOrder } from '../../../common/editor.js';\nimport { EditorInput } from '../../../common/editor/editorInput.js';\nimport { IEditorGroupsService } from '../../editor/common/editorGroupsService.js';\n\n/**\n * The working copy backup tracker deals with:\n * - restoring backups that exist\n * - creating backups for modified working copies\n * - deleting backups for saved working copies\n * - handling backups on shutdown\n */\nexport abstract class WorkingCopyBackupTracker extends Disposable {\n\n\tconstructor(\n\t\tprotected readonly workingCopyBackupService: IWorkingCopyBackupService,\n\t\tprotected readonly workingCopyService: IWorkingCopyService,\n\t\tprotected readonly logService: ILogService,\n\t\tprivate readonly lifecycleService: ILifecycleService,\n\t\tprotected readonly filesConfigurationService: IFilesConfigurationService,\n\t\tprivate readonly workingCopyEditorService: IWorkingCopyEditorService,\n\t\tprotected readonly editorService: IEditorService,\n\t\tprivate readonly editorGroupService: IEditorGroupsService\n\t) {\n\t\tsuper();\n\n\t\t// Fill in initial modified working copies\n\t\tfor (const workingCopy of this.workingCopyService.modifiedWorkingCopies) {\n\t\t\tthis.onDidRegister(workingCopy);\n\t\t}\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners() {\n\n\t\t// Working Copy events\n\t\tthis._register(this.workingCopyService.onDidRegister(workingCopy => this.onDidRegister(workingCopy)));\n\t\tthis._register(this.workingCopyService.onDidUnregister(workingCopy => this.onDidUnregister(workingCopy)));\n\t\tthis._register(this.workingCopyService.onDidChangeDirty(workingCopy => this.onDidChangeDirty(workingCopy)));\n\t\tthis._register(this.workingCopyService.onDidChangeContent(workingCopy => this.onDidChangeContent(workingCopy)));\n\n\t\t// Lifecycle\n\t\tthis._register(this.lifecycleService.onBeforeShutdown(event => (event as InternalBeforeShutdownEvent).finalVeto(() => this.onFinalBeforeShutdown(event.reason), 'veto.backups')));\n\t\tthis._register(this.lifecycleService.onWillShutdown(() => this.onWillShutdown()));\n\n\t\t// Once a handler registers, restore backups\n\t\tthis._register(this.workingCopyEditorService.onDidRegisterHandler(handler => this.restoreBackups(handler)));\n\t}\n\n\tprotected abstract onFinalBeforeShutdown(reason: ShutdownReason): boolean | Promise<boolean>;\n\n\tprivate onWillShutdown(): void {\n\n\t\t// Here we know that we will shutdown. Any backup operation that is\n\t\t// already scheduled or being scheduled from this moment on runs\n\t\t// at the risk of corrupting a backup because the backup operation\n\t\t// might terminate at any given time now. As such, we need to disable\n\t\t// this tracker from performing more backups by cancelling pending\n\t\t// operations and suspending the tracker without resuming.\n\n\t\tthis.cancelBackupOperations();\n\t\tthis.suspendBackupOperations();\n\t}\n\n\n\t//#region Backup Creator\n\n\t// Delay creation of backups when content changes to avoid too much\n\t// load on the backup service when the user is typing into the editor\n\t// Since we always schedule a backup, even when auto save is on, we\n\t// have different scheduling delays based on auto save configuration.\n\t// With 'delayed' we avoid a (not critical but also not really wanted)\n\t// race between saving (after 1s per default) and making a backup of\n\t// the working copy.\n\tprivate static readonly DEFAULT_BACKUP_SCHEDULE_DELAYS = {\n\t\t['default']: 1000,\n\t\t['delayed']: 2000\n\t};\n\n\t// A map from working copy to a version ID we compute on each content\n\t// change. This version ID allows to e.g. ask if a backup for a specific\n\t// content has been made before closing.\n\tprivate readonly mapWorkingCopyToContentVersion = new Map<IWorkingCopy, number>();\n\n\t// A map of scheduled pending backup operations for working copies\n\t// Given https://github.com/microsoft/vscode/issues/158038, we explicitly\n\t// do not store `IWorkingCopy` but the identifier in the map, since it\n\t// looks like GC is not running for the working copy otherwise.\n\tprotected readonly pendingBackupOperations = new Map<IWorkingCopyIdentifier, { disposable: IDisposable; cancel: () => void }>();\n\n\tprivate suspended = false;\n\n\tprivate onDidRegister(workingCopy: IWorkingCopy): void {\n\t\tif (this.suspended) {\n\t\t\tthis.logService.warn(`[backup tracker] suspended, ignoring register event`, workingCopy.resource.toString(), workingCopy.typeId);\n\t\t\treturn;\n\t\t}\n\n\t\tif (workingCopy.isModified()) {\n\t\t\tthis.scheduleBackup(workingCopy);\n\t\t}\n\t}\n\n\tprivate onDidUnregister(workingCopy: IWorkingCopy): void {\n\n\t\t// Remove from content version map\n\t\tthis.mapWorkingCopyToContentVersion.delete(workingCopy);\n\n\t\t// Check suspended\n\t\tif (this.suspended) {\n\t\t\tthis.logService.warn(`[backup tracker] suspended, ignoring unregister event`, workingCopy.resource.toString(), workingCopy.typeId);\n\t\t\treturn;\n\t\t}\n\n\t\t// Discard backup\n\t\tthis.discardBackup(workingCopy);\n\t}\n\n\tprivate onDidChangeDirty(workingCopy: IWorkingCopy): void {\n\t\tif (this.suspended) {\n\t\t\tthis.logService.warn(`[backup tracker] suspended, ignoring dirty change event`, workingCopy.resource.toString(), workingCopy.typeId);\n\t\t\treturn;\n\t\t}\n\n\t\tif (workingCopy.isDirty()) {\n\t\t\tthis.scheduleBackup(workingCopy);\n\t\t} else {\n\t\t\tthis.discardBackup(workingCopy);\n\t\t}\n\t}\n\n\tprivate onDidChangeContent(workingCopy: IWorkingCopy): void {\n\n\t\t// Increment content version ID\n\t\tconst contentVersionId = this.getContentVersion(workingCopy);\n\t\tthis.mapWorkingCopyToContentVersion.set(workingCopy, contentVersionId + 1);\n\n\t\t// Check suspended\n\t\tif (this.suspended) {\n\t\t\tthis.logService.warn(`[backup tracker] suspended, ignoring content change event`, workingCopy.resource.toString(), workingCopy.typeId);\n\t\t\treturn;\n\t\t}\n\n\t\t// Schedule backup for modified working copies\n\t\tif (workingCopy.isModified()) {\n\t\t\t// this listener will make sure that the backup is\n\t\t\t// pushed out for as long as the user is still changing\n\t\t\t// the content of the working copy.\n\t\t\tthis.scheduleBackup(workingCopy);\n\t\t}\n\t}\n\n\tprivate scheduleBackup(workingCopy: IWorkingCopy): void {\n\n\t\t// Clear any running backup operation\n\t\tthis.cancelBackupOperation(workingCopy);\n\n\t\tthis.logService.trace(`[backup tracker] scheduling backup`, workingCopy.resource.toString(), workingCopy.typeId);\n\n\t\t// Schedule new backup\n\t\tconst workingCopyIdentifier = { resource: workingCopy.resource, typeId: workingCopy.typeId };\n\t\tconst cts = new CancellationTokenSource();\n\t\tconst handle = setTimeout(async () => {\n\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Backup if modified\n\t\t\tif (workingCopy.isModified()) {\n\t\t\t\tthis.logService.trace(`[backup tracker] creating backup`, workingCopy.resource.toString(), workingCopy.typeId);\n\n\t\t\t\ttry {\n\t\t\t\t\tconst backup = await workingCopy.backup(cts.token);\n\t\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (workingCopy.isModified()) {\n\t\t\t\t\t\tthis.logService.trace(`[backup tracker] storing backup`, workingCopy.resource.toString(), workingCopy.typeId);\n\n\t\t\t\t\t\tawait this.workingCopyBackupService.backup(workingCopy, backup.content, this.getContentVersion(workingCopy), backup.meta, cts.token);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.logService.error(error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Clear disposable unless we got canceled which would\n\t\t\t// indicate another operation has started meanwhile\n\t\t\tif (!cts.token.isCancellationRequested) {\n\t\t\t\tthis.doClearPendingBackupOperation(workingCopyIdentifier);\n\t\t\t}\n\t\t}, this.getBackupScheduleDelay(workingCopy));\n\n\t\t// Keep in map for disposal as needed\n\t\tthis.pendingBackupOperations.set(workingCopyIdentifier, {\n\t\t\tcancel: () => {\n\t\t\t\tthis.logService.trace(`[backup tracker] clearing pending backup creation`, workingCopy.resource.toString(), workingCopy.typeId);\n\n\t\t\t\tcts.cancel();\n\t\t\t},\n\t\t\tdisposable: toDisposable(() => {\n\t\t\t\tcts.dispose();\n\t\t\t\tclearTimeout(handle);\n\t\t\t})\n\t\t});\n\t}\n\n\tprotected getBackupScheduleDelay(workingCopy: IWorkingCopy): number {\n\t\tif (typeof workingCopy.backupDelay === 'number') {\n\t\t\treturn workingCopy.backupDelay; // respect working copy override\n\t\t}\n\n\t\tlet backupScheduleDelay: 'default' | 'delayed';\n\t\tif (workingCopy.capabilities & WorkingCopyCapabilities.Untitled) {\n\t\t\tbackupScheduleDelay = 'default'; // auto-save is never on for untitled working copies\n\t\t} else {\n\t\t\tbackupScheduleDelay = this.filesConfigurationService.hasShortAutoSaveDelay(workingCopy.resource) ? 'delayed' : 'default';\n\t\t}\n\n\t\treturn WorkingCopyBackupTracker.DEFAULT_BACKUP_SCHEDULE_DELAYS[backupScheduleDelay];\n\t}\n\n\tprotected getContentVersion(workingCopy: IWorkingCopy): number {\n\t\treturn this.mapWorkingCopyToContentVersion.get(workingCopy) || 0;\n\t}\n\n\tprivate discardBackup(workingCopy: IWorkingCopy): void {\n\n\t\t// Clear any running backup operation\n\t\tthis.cancelBackupOperation(workingCopy);\n\n\t\t// Schedule backup discard asap\n\t\tconst workingCopyIdentifier = { resource: workingCopy.resource, typeId: workingCopy.typeId };\n\t\tconst cts = new CancellationTokenSource();\n\t\tthis.doDiscardBackup(workingCopyIdentifier, cts);\n\n\t\t// Keep in map for disposal as needed\n\t\tthis.pendingBackupOperations.set(workingCopyIdentifier, {\n\t\t\tcancel: () => {\n\t\t\t\tthis.logService.trace(`[backup tracker] clearing pending backup discard`, workingCopy.resource.toString(), workingCopy.typeId);\n\n\t\t\t\tcts.cancel();\n\t\t\t},\n\t\t\tdisposable: cts\n\t\t});\n\t}\n\n\tprivate async doDiscardBackup(workingCopyIdentifier: IWorkingCopyIdentifier, cts: CancellationTokenSource) {\n\t\tthis.logService.trace(`[backup tracker] discarding backup`, workingCopyIdentifier.resource.toString(), workingCopyIdentifier.typeId);\n\n\t\t// Discard backup\n\t\ttry {\n\t\t\tawait this.workingCopyBackupService.discardBackup(workingCopyIdentifier, cts.token);\n\t\t} catch (error) {\n\t\t\tthis.logService.error(error);\n\t\t}\n\n\t\t// Clear disposable unless we got canceled which would\n\t\t// indicate another operation has started meanwhile\n\t\tif (!cts.token.isCancellationRequested) {\n\t\t\tthis.doClearPendingBackupOperation(workingCopyIdentifier);\n\t\t}\n\t}\n\n\tprivate cancelBackupOperation(workingCopy: IWorkingCopy): void {\n\n\t\t// Given a working copy we want to find the matching\n\t\t// identifier in our pending operations map because\n\t\t// we cannot use the working copy directly, as the\n\t\t// identifier might have different object identity.\n\n\t\tlet workingCopyIdentifier: IWorkingCopyIdentifier | undefined = undefined;\n\t\tfor (const [identifier] of this.pendingBackupOperations) {\n\t\t\tif (identifier.resource.toString() === workingCopy.resource.toString() && identifier.typeId === workingCopy.typeId) {\n\t\t\t\tworkingCopyIdentifier = identifier;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (workingCopyIdentifier) {\n\t\t\tthis.doClearPendingBackupOperation(workingCopyIdentifier, { cancel: true });\n\t\t}\n\t}\n\n\tprivate doClearPendingBackupOperation(workingCopyIdentifier: IWorkingCopyIdentifier, options?: { cancel: boolean }): void {\n\t\tconst pendingBackupOperation = this.pendingBackupOperations.get(workingCopyIdentifier);\n\t\tif (!pendingBackupOperation) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (options?.cancel) {\n\t\t\tpendingBackupOperation.cancel();\n\t\t}\n\n\t\tpendingBackupOperation.disposable.dispose();\n\n\t\tthis.pendingBackupOperations.delete(workingCopyIdentifier);\n\t}\n\n\tprotected cancelBackupOperations(): void {\n\t\tfor (const [, operation] of this.pendingBackupOperations) {\n\t\t\toperation.cancel();\n\t\t\toperation.disposable.dispose();\n\t\t}\n\n\t\tthis.pendingBackupOperations.clear();\n\t}\n\n\tprotected suspendBackupOperations(): { resume: () => void } {\n\t\tthis.suspended = true;\n\n\t\treturn { resume: () => this.suspended = false };\n\t}\n\n\t//#endregion\n\n\n\t//#region Backup Restorer\n\n\tprotected readonly unrestoredBackups = new Set<IWorkingCopyIdentifier>();\n\tprotected readonly whenReady = this.resolveBackupsToRestore();\n\n\tprivate _isReady = false;\n\tprotected get isReady(): boolean { return this._isReady; }\n\n\tprivate async resolveBackupsToRestore(): Promise<void> {\n\n\t\t// Wait for resolving backups until we are restored to reduce startup pressure\n\t\tawait this.lifecycleService.when(LifecyclePhase.Restored);\n\n\t\t// Remember each backup that needs to restore\n\t\tfor (const backup of await this.workingCopyBackupService.getBackups()) {\n\t\t\tthis.unrestoredBackups.add(backup);\n\t\t}\n\n\t\tthis._isReady = true;\n\t}\n\n\tprotected async restoreBackups(handler: IWorkingCopyEditorHandler): Promise<void> {\n\n\t\t// Wait for backups to be resolved\n\t\tawait this.whenReady;\n\n\t\t// Figure out already opened editors for backups vs\n\t\t// non-opened.\n\t\tconst openedEditorsForBackups = new Set<EditorInput>();\n\t\tconst nonOpenedEditorsForBackups = new Set<EditorInput>();\n\n\t\t// Ensure each backup that can be handled has an\n\t\t// associated editor.\n\t\tconst restoredBackups = new Set<IWorkingCopyIdentifier>();\n\t\tfor (const unrestoredBackup of this.unrestoredBackups) {\n\t\t\tconst canHandleUnrestoredBackup = await handler.handles(unrestoredBackup);\n\t\t\tif (!canHandleUnrestoredBackup) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Collect already opened editors for backup\n\t\t\tlet hasOpenedEditorForBackup = false;\n\t\t\tfor (const { editor } of this.editorService.getEditors(EditorsOrder.MOST_RECENTLY_ACTIVE)) {\n\t\t\t\tconst isUnrestoredBackupOpened = handler.isOpen(unrestoredBackup, editor);\n\t\t\t\tif (isUnrestoredBackupOpened) {\n\t\t\t\t\topenedEditorsForBackups.add(editor);\n\t\t\t\t\thasOpenedEditorForBackup = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Otherwise, make sure to create at least one editor\n\t\t\t// for the backup to show\n\t\t\tif (!hasOpenedEditorForBackup) {\n\t\t\t\tnonOpenedEditorsForBackups.add(await handler.createEditor(unrestoredBackup));\n\t\t\t}\n\n\t\t\t// Remember as (potentially) restored\n\t\t\trestoredBackups.add(unrestoredBackup);\n\t\t}\n\n\t\t// Ensure editors are opened for each backup without editor\n\t\t// in the background without stealing focus\n\t\tif (nonOpenedEditorsForBackups.size > 0) {\n\t\t\tawait this.editorGroupService.activeGroup.openEditors([...nonOpenedEditorsForBackups].map(nonOpenedEditorForBackup => ({\n\t\t\t\teditor: nonOpenedEditorForBackup,\n\t\t\t\toptions: {\n\t\t\t\t\tpinned: true,\n\t\t\t\t\tpreserveFocus: true,\n\t\t\t\t\tinactive: true\n\t\t\t\t}\n\t\t\t})));\n\n\t\t\tfor (const nonOpenedEditorForBackup of nonOpenedEditorsForBackups) {\n\t\t\t\topenedEditorsForBackups.add(nonOpenedEditorForBackup);\n\t\t\t}\n\t\t}\n\n\t\t// Then, resolve each opened editor to make sure the working copy\n\t\t// is loaded and the modified editor appears properly.\n\t\t// We only do that for editors that are not active in a group\n\t\t// already to prevent calling `resolve` twice!\n\t\tawait Promises.settled([...openedEditorsForBackups].map(async openedEditorForBackup => {\n\t\t\tif (this.editorService.isVisible(openedEditorForBackup)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treturn openedEditorForBackup.resolve();\n\t\t}));\n\n\t\t// Finally, remove all handled backups from the list\n\t\tfor (const restoredBackup of restoredBackups) {\n\t\t\tthis.unrestoredBackups.delete(restoredBackup);\n\t\t}\n\t}\n\n\t//#endregion\n}\n"],
  "mappings": "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",
  "names": []
}
