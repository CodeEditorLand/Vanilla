{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/workingCopy/common/workingCopyFileService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { insert } from \"../../../../base/common/arrays.js\";\nimport { Promises } from \"../../../../base/common/async.js\";\nimport type {\n\tVSBuffer,\n\tVSBufferReadable,\n\tVSBufferReadableStream,\n} from \"../../../../base/common/buffer.js\";\nimport { CancellationToken } from \"../../../../base/common/cancellation.js\";\nimport {\n\tAsyncEmitter,\n\ttype Event,\n\ttype IWaitUntil,\n} from \"../../../../base/common/event.js\";\nimport {\n\tDisposable,\n\ttype IDisposable,\n\ttoDisposable,\n} from \"../../../../base/common/lifecycle.js\";\nimport type { URI } from \"../../../../base/common/uri.js\";\nimport {\n\tFileOperation,\n\tIFileService,\n\ttype IFileStatWithMetadata,\n} from \"../../../../platform/files/common/files.js\";\nimport {\n\tInstantiationType,\n\tregisterSingleton,\n} from \"../../../../platform/instantiation/common/extensions.js\";\nimport {\n\tIInstantiationService,\n\tcreateDecorator,\n} from \"../../../../platform/instantiation/common/instantiation.js\";\nimport type {\n\tIProgress,\n\tIProgressStep,\n} from \"../../../../platform/progress/common/progress.js\";\nimport { IUriIdentityService } from \"../../../../platform/uriIdentity/common/uriIdentity.js\";\nimport type { SaveReason } from \"../../../common/editor.js\";\nimport type {\n\tIStoredFileWorkingCopy,\n\tIStoredFileWorkingCopyModel,\n} from \"./storedFileWorkingCopy.js\";\nimport { StoredFileWorkingCopySaveParticipant } from \"./storedFileWorkingCopySaveParticipant.js\";\nimport type { IWorkingCopy } from \"./workingCopy.js\";\nimport { WorkingCopyFileOperationParticipant } from \"./workingCopyFileOperationParticipant.js\";\nimport { IWorkingCopyService } from \"./workingCopyService.js\";\n\nexport const IWorkingCopyFileService = createDecorator<IWorkingCopyFileService>(\n\t\"workingCopyFileService\",\n);\n\nexport interface SourceTargetPair {\n\t/**\n\t * The source resource that is defined for move operations.\n\t */\n\treadonly source?: URI;\n\n\t/**\n\t * The target resource the event is about.\n\t */\n\treadonly target: URI;\n}\n\nexport interface IFileOperationUndoRedoInfo {\n\t/**\n\t * Id of the undo group that the file operation belongs to.\n\t */\n\tundoRedoGroupId?: number;\n\n\t/**\n\t * Flag indicates if the operation is an undo.\n\t */\n\tisUndoing?: boolean;\n}\n\nexport interface WorkingCopyFileEvent extends IWaitUntil {\n\t/**\n\t * An identifier to correlate the operation through the\n\t * different event types (before, after, error).\n\t */\n\treadonly correlationId: number;\n\n\t/**\n\t * The file operation that is taking place.\n\t */\n\treadonly operation: FileOperation;\n\n\t/**\n\t * The array of source/target pair of files involved in given operation.\n\t */\n\treadonly files: readonly SourceTargetPair[];\n}\n\nexport interface IWorkingCopyFileOperationParticipant {\n\t/**\n\t * Participate in a file operation of working copies. Allows to\n\t * change the working copies before they are being saved to disk.\n\t */\n\tparticipate(\n\t\tfiles: SourceTargetPair[],\n\t\toperation: FileOperation,\n\t\tundoInfo: IFileOperationUndoRedoInfo | undefined,\n\t\ttimeout: number,\n\t\ttoken: CancellationToken,\n\t): Promise<void>;\n}\n\nexport interface IStoredFileWorkingCopySaveParticipantContext {\n\t/**\n\t * The reason why the save was triggered.\n\t */\n\treadonly reason: SaveReason;\n\n\t/**\n\t * Only applies to when a text file was saved as, for\n\t * example when starting with untitled and saving. This\n\t * provides access to the initial resource the text\n\t * file had before.\n\t */\n\treadonly savedFrom?: URI;\n}\n\nexport interface IStoredFileWorkingCopySaveParticipant {\n\t/**\n\t * Participate in a save operation of file stored working copies.\n\t * Allows to make changes before content is being saved to disk.\n\t */\n\tparticipate(\n\t\tworkingCopy: IStoredFileWorkingCopy<IStoredFileWorkingCopyModel>,\n\t\tcontext: IStoredFileWorkingCopySaveParticipantContext,\n\t\tprogress: IProgress<IProgressStep>,\n\t\ttoken: CancellationToken,\n\t): Promise<void>;\n}\n\nexport interface ICreateOperation {\n\tresource: URI;\n\toverwrite?: boolean;\n}\n\nexport interface ICreateFileOperation extends ICreateOperation {\n\tcontents?: VSBuffer | VSBufferReadable | VSBufferReadableStream;\n}\n\nexport interface IDeleteOperation {\n\tresource: URI;\n\tuseTrash?: boolean;\n\trecursive?: boolean;\n}\n\nexport interface IMoveOperation {\n\tfile: Required<SourceTargetPair>;\n\toverwrite?: boolean;\n}\n\nexport interface ICopyOperation extends IMoveOperation {}\n\n/**\n * Returns the working copies for a given resource.\n */\ntype WorkingCopyProvider = (resourceOrFolder: URI) => IWorkingCopy[];\n\n/**\n * A service that allows to perform file operations with working copy support.\n * Any operation that would leave a stale dirty working copy behind will make\n * sure to revert the working copy first.\n *\n * On top of that events are provided to participate in each state of the\n * operation to perform additional work.\n */\nexport interface IWorkingCopyFileService {\n\treadonly _serviceBrand: undefined;\n\n\t//#region Events\n\n\t/**\n\t * An event that is fired when a certain working copy IO operation is about to run.\n\t *\n\t * Participants can join this event with a long running operation to keep some state\n\t * before the operation is started, but working copies should not be changed at this\n\t * point in time. For that purpose, use the `IWorkingCopyFileOperationParticipant` API.\n\t */\n\treadonly onWillRunWorkingCopyFileOperation: Event<WorkingCopyFileEvent>;\n\n\t/**\n\t * An event that is fired after a working copy IO operation has failed.\n\t *\n\t * Participants can join this event with a long running operation to clean up as needed.\n\t */\n\treadonly onDidFailWorkingCopyFileOperation: Event<WorkingCopyFileEvent>;\n\n\t/**\n\t * An event that is fired after a working copy IO operation has been performed.\n\t *\n\t * Participants can join this event with a long running operation to make changes\n\t * after the operation has finished.\n\t */\n\treadonly onDidRunWorkingCopyFileOperation: Event<WorkingCopyFileEvent>;\n\n\t//#endregion\n\n\t//#region File operation participants\n\n\t/**\n\t * Adds a participant for file operations on working copies.\n\t */\n\taddFileOperationParticipant(\n\t\tparticipant: IWorkingCopyFileOperationParticipant,\n\t): IDisposable;\n\n\t//#endregion\n\n\t//#region Stored File Working Copy save participants\n\n\t/**\n\t * Whether save participants are present for stored file working copies.\n\t */\n\tget hasSaveParticipants(): boolean;\n\n\t/**\n\t * Adds a participant for save operations on stored file working copies.\n\t */\n\taddSaveParticipant(\n\t\tparticipant: IStoredFileWorkingCopySaveParticipant,\n\t): IDisposable;\n\n\t/**\n\t * Runs all available save participants for stored file working copies.\n\t */\n\trunSaveParticipants(\n\t\tworkingCopy: IStoredFileWorkingCopy<IStoredFileWorkingCopyModel>,\n\t\tcontext: IStoredFileWorkingCopySaveParticipantContext,\n\t\tprogress: IProgress<IProgressStep>,\n\t\ttoken: CancellationToken,\n\t): Promise<void>;\n\n\t//#endregion\n\n\t//#region File operations\n\n\t/**\n\t * Will create a resource with the provided optional contents, optionally overwriting any target.\n\t *\n\t * Working copy owners can listen to the `onWillRunWorkingCopyFileOperation` and\n\t * `onDidRunWorkingCopyFileOperation` events to participate.\n\t */\n\tcreate(\n\t\toperations: ICreateFileOperation[],\n\t\ttoken: CancellationToken,\n\t\tundoInfo?: IFileOperationUndoRedoInfo,\n\t): Promise<readonly IFileStatWithMetadata[]>;\n\n\t/**\n\t * Will create a folder and any parent folder that needs to be created.\n\t *\n\t * Working copy owners can listen to the `onWillRunWorkingCopyFileOperation` and\n\t * `onDidRunWorkingCopyFileOperation` events to participate.\n\t *\n\t * Note: events will only be emitted for the provided resource, but not any\n\t * parent folders that are being created as part of the operation.\n\t */\n\tcreateFolder(\n\t\toperations: ICreateOperation[],\n\t\ttoken: CancellationToken,\n\t\tundoInfo?: IFileOperationUndoRedoInfo,\n\t): Promise<readonly IFileStatWithMetadata[]>;\n\n\t/**\n\t * Will move working copies matching the provided resources and corresponding children\n\t * to the target resources using the associated file service for those resources.\n\t *\n\t * Working copy owners can listen to the `onWillRunWorkingCopyFileOperation` and\n\t * `onDidRunWorkingCopyFileOperation` events to participate.\n\t */\n\tmove(\n\t\toperations: IMoveOperation[],\n\t\ttoken: CancellationToken,\n\t\tundoInfo?: IFileOperationUndoRedoInfo,\n\t): Promise<readonly IFileStatWithMetadata[]>;\n\n\t/**\n\t * Will copy working copies matching the provided resources and corresponding children\n\t * to the target resources using the associated file service for those resources.\n\t *\n\t * Working copy owners can listen to the `onWillRunWorkingCopyFileOperation` and\n\t * `onDidRunWorkingCopyFileOperation` events to participate.\n\t */\n\tcopy(\n\t\toperations: ICopyOperation[],\n\t\ttoken: CancellationToken,\n\t\tundoInfo?: IFileOperationUndoRedoInfo,\n\t): Promise<readonly IFileStatWithMetadata[]>;\n\n\t/**\n\t * Will delete working copies matching the provided resources and children\n\t * using the associated file service for those resources.\n\t *\n\t * Working copy owners can listen to the `onWillRunWorkingCopyFileOperation` and\n\t * `onDidRunWorkingCopyFileOperation` events to participate.\n\t */\n\tdelete(\n\t\toperations: IDeleteOperation[],\n\t\ttoken: CancellationToken,\n\t\tundoInfo?: IFileOperationUndoRedoInfo,\n\t): Promise<void>;\n\n\t//#endregion\n\n\t//#region Path related\n\n\t/**\n\t * Register a new provider for working copies based on a resource.\n\t *\n\t * @return a disposable that unregisters the provider.\n\t */\n\tregisterWorkingCopyProvider(provider: WorkingCopyProvider): IDisposable;\n\n\t/**\n\t * Will return all working copies that are dirty matching the provided resource.\n\t * If the resource is a folder and the scheme supports file operations, a working\n\t * copy that is dirty and is a child of that folder will also be returned.\n\t */\n\tgetDirty(resource: URI): readonly IWorkingCopy[];\n\n\t//#endregion\n}\n\nexport class WorkingCopyFileService\n\textends Disposable\n\timplements IWorkingCopyFileService\n{\n\tdeclare readonly _serviceBrand: undefined;\n\n\t//#region Events\n\n\tprivate readonly _onWillRunWorkingCopyFileOperation = this._register(\n\t\tnew AsyncEmitter<WorkingCopyFileEvent>(),\n\t);\n\treadonly onWillRunWorkingCopyFileOperation =\n\t\tthis._onWillRunWorkingCopyFileOperation.event;\n\n\tprivate readonly _onDidFailWorkingCopyFileOperation = this._register(\n\t\tnew AsyncEmitter<WorkingCopyFileEvent>(),\n\t);\n\treadonly onDidFailWorkingCopyFileOperation =\n\t\tthis._onDidFailWorkingCopyFileOperation.event;\n\n\tprivate readonly _onDidRunWorkingCopyFileOperation = this._register(\n\t\tnew AsyncEmitter<WorkingCopyFileEvent>(),\n\t);\n\treadonly onDidRunWorkingCopyFileOperation =\n\t\tthis._onDidRunWorkingCopyFileOperation.event;\n\n\t//#endregion\n\n\tprivate correlationIds = 0;\n\n\tconstructor(\n\t\t@IFileService private readonly fileService: IFileService,\n\t\t@IWorkingCopyService\n\t\tprivate readonly workingCopyService: IWorkingCopyService,\n\t\t@IInstantiationService\n\t\tprivate readonly instantiationService: IInstantiationService,\n\t\t@IUriIdentityService\n\t\tprivate readonly uriIdentityService: IUriIdentityService,\n\t) {\n\t\tsuper();\n\n\t\t// register a default working copy provider that uses the working copy service\n\t\tthis._register(\n\t\t\tthis.registerWorkingCopyProvider((resource) => {\n\t\t\t\treturn this.workingCopyService.workingCopies.filter(\n\t\t\t\t\t(workingCopy) => {\n\t\t\t\t\t\tif (this.fileService.hasProvider(resource)) {\n\t\t\t\t\t\t\t// only check for parents if the resource can be handled\n\t\t\t\t\t\t\t// by the file system where we then assume a folder like\n\t\t\t\t\t\t\t// path structure\n\t\t\t\t\t\t\treturn this.uriIdentityService.extUri.isEqualOrParent(\n\t\t\t\t\t\t\t\tworkingCopy.resource,\n\t\t\t\t\t\t\t\tresource,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn this.uriIdentityService.extUri.isEqual(\n\t\t\t\t\t\t\tworkingCopy.resource,\n\t\t\t\t\t\t\tresource,\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t}),\n\t\t);\n\t}\n\n\t//#region File operations\n\n\tcreate(\n\t\toperations: ICreateFileOperation[],\n\t\ttoken: CancellationToken,\n\t\tundoInfo?: IFileOperationUndoRedoInfo,\n\t): Promise<IFileStatWithMetadata[]> {\n\t\treturn this.doCreateFileOrFolder(operations, true, token, undoInfo);\n\t}\n\n\tcreateFolder(\n\t\toperations: ICreateOperation[],\n\t\ttoken: CancellationToken,\n\t\tundoInfo?: IFileOperationUndoRedoInfo,\n\t): Promise<IFileStatWithMetadata[]> {\n\t\treturn this.doCreateFileOrFolder(operations, false, token, undoInfo);\n\t}\n\n\tasync doCreateFileOrFolder(\n\t\toperations: (ICreateFileOperation | ICreateOperation)[],\n\t\tisFile: boolean,\n\t\ttoken: CancellationToken,\n\t\tundoInfo?: IFileOperationUndoRedoInfo,\n\t): Promise<IFileStatWithMetadata[]> {\n\t\tif (operations.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// validate create operation before starting\n\t\tif (isFile) {\n\t\t\tconst validateCreates = await Promises.settled(\n\t\t\t\toperations.map((operation) =>\n\t\t\t\t\tthis.fileService.canCreateFile(operation.resource, {\n\t\t\t\t\t\toverwrite: operation.overwrite,\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t);\n\t\t\tconst error = validateCreates.find(\n\t\t\t\t(validateCreate) => validateCreate instanceof Error,\n\t\t\t);\n\t\t\tif (error instanceof Error) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\n\t\t// file operation participant\n\t\tconst files = operations.map((operation) => ({\n\t\t\ttarget: operation.resource,\n\t\t}));\n\t\tawait this.runFileOperationParticipants(\n\t\t\tfiles,\n\t\t\tFileOperation.CREATE,\n\t\t\tundoInfo,\n\t\t\ttoken,\n\t\t);\n\n\t\t// before events\n\t\tconst event = {\n\t\t\tcorrelationId: this.correlationIds++,\n\t\t\toperation: FileOperation.CREATE,\n\t\t\tfiles,\n\t\t};\n\t\tawait this._onWillRunWorkingCopyFileOperation.fireAsync(\n\t\t\tevent,\n\t\t\tCancellationToken.None /* intentional: we currently only forward cancellation to participants */,\n\t\t);\n\n\t\t// now actually create on disk\n\t\tlet stats: IFileStatWithMetadata[];\n\t\ttry {\n\t\t\tif (isFile) {\n\t\t\t\tstats = await Promises.settled(\n\t\t\t\t\toperations.map((operation) =>\n\t\t\t\t\t\tthis.fileService.createFile(\n\t\t\t\t\t\t\toperation.resource,\n\t\t\t\t\t\t\t(operation as ICreateFileOperation).contents,\n\t\t\t\t\t\t\t{ overwrite: operation.overwrite },\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tstats = await Promises.settled(\n\t\t\t\t\toperations.map((operation) =>\n\t\t\t\t\t\tthis.fileService.createFolder(operation.resource),\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// error event\n\t\t\tawait this._onDidFailWorkingCopyFileOperation.fireAsync(\n\t\t\t\tevent,\n\t\t\t\tCancellationToken.None /* intentional: we currently only forward cancellation to participants */,\n\t\t\t);\n\n\t\t\tthrow error;\n\t\t}\n\n\t\t// after event\n\t\tawait this._onDidRunWorkingCopyFileOperation.fireAsync(\n\t\t\tevent,\n\t\t\tCancellationToken.None /* intentional: we currently only forward cancellation to participants */,\n\t\t);\n\n\t\treturn stats;\n\t}\n\n\tasync move(\n\t\toperations: IMoveOperation[],\n\t\ttoken: CancellationToken,\n\t\tundoInfo?: IFileOperationUndoRedoInfo,\n\t): Promise<IFileStatWithMetadata[]> {\n\t\treturn this.doMoveOrCopy(operations, true, token, undoInfo);\n\t}\n\n\tasync copy(\n\t\toperations: ICopyOperation[],\n\t\ttoken: CancellationToken,\n\t\tundoInfo?: IFileOperationUndoRedoInfo,\n\t): Promise<IFileStatWithMetadata[]> {\n\t\treturn this.doMoveOrCopy(operations, false, token, undoInfo);\n\t}\n\n\tprivate async doMoveOrCopy(\n\t\toperations: IMoveOperation[] | ICopyOperation[],\n\t\tmove: boolean,\n\t\ttoken: CancellationToken,\n\t\tundoInfo?: IFileOperationUndoRedoInfo,\n\t): Promise<IFileStatWithMetadata[]> {\n\t\tconst stats: IFileStatWithMetadata[] = [];\n\n\t\t// validate move/copy operation before starting\n\t\tfor (const {\n\t\t\tfile: { source, target },\n\t\t\toverwrite,\n\t\t} of operations) {\n\t\t\tconst validateMoveOrCopy = await (move\n\t\t\t\t? this.fileService.canMove(source, target, overwrite)\n\t\t\t\t: this.fileService.canCopy(source, target, overwrite));\n\t\t\tif (validateMoveOrCopy instanceof Error) {\n\t\t\t\tthrow validateMoveOrCopy;\n\t\t\t}\n\t\t}\n\n\t\t// file operation participant\n\t\tconst files = operations.map((o) => o.file);\n\t\tawait this.runFileOperationParticipants(\n\t\t\tfiles,\n\t\t\tmove ? FileOperation.MOVE : FileOperation.COPY,\n\t\t\tundoInfo,\n\t\t\ttoken,\n\t\t);\n\n\t\t// before event\n\t\tconst event = {\n\t\t\tcorrelationId: this.correlationIds++,\n\t\t\toperation: move ? FileOperation.MOVE : FileOperation.COPY,\n\t\t\tfiles,\n\t\t};\n\t\tawait this._onWillRunWorkingCopyFileOperation.fireAsync(\n\t\t\tevent,\n\t\t\tCancellationToken.None /* intentional: we currently only forward cancellation to participants */,\n\t\t);\n\n\t\ttry {\n\t\t\tfor (const {\n\t\t\t\tfile: { source, target },\n\t\t\t\toverwrite,\n\t\t\t} of operations) {\n\t\t\t\t// if source and target are not equal, handle dirty working copies\n\t\t\t\t// depending on the operation:\n\t\t\t\t// - move: revert both source and target (if any)\n\t\t\t\t// - copy: revert target (if any)\n\t\t\t\tif (!this.uriIdentityService.extUri.isEqual(source, target)) {\n\t\t\t\t\tconst dirtyWorkingCopies = move\n\t\t\t\t\t\t? [...this.getDirty(source), ...this.getDirty(target)]\n\t\t\t\t\t\t: this.getDirty(target);\n\t\t\t\t\tawait Promises.settled(\n\t\t\t\t\t\tdirtyWorkingCopies.map((dirtyWorkingCopy) =>\n\t\t\t\t\t\t\tdirtyWorkingCopy.revert({ soft: true }),\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// now we can rename the source to target via file operation\n\t\t\t\tif (move) {\n\t\t\t\t\tstats.push(\n\t\t\t\t\t\tawait this.fileService.move(source, target, overwrite),\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tstats.push(\n\t\t\t\t\t\tawait this.fileService.copy(source, target, overwrite),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// error event\n\t\t\tawait this._onDidFailWorkingCopyFileOperation.fireAsync(\n\t\t\t\tevent,\n\t\t\t\tCancellationToken.None /* intentional: we currently only forward cancellation to participants */,\n\t\t\t);\n\n\t\t\tthrow error;\n\t\t}\n\n\t\t// after event\n\t\tawait this._onDidRunWorkingCopyFileOperation.fireAsync(\n\t\t\tevent,\n\t\t\tCancellationToken.None /* intentional: we currently only forward cancellation to participants */,\n\t\t);\n\n\t\treturn stats;\n\t}\n\n\tasync delete(\n\t\toperations: IDeleteOperation[],\n\t\ttoken: CancellationToken,\n\t\tundoInfo?: IFileOperationUndoRedoInfo,\n\t): Promise<void> {\n\t\t// validate delete operation before starting\n\t\tfor (const operation of operations) {\n\t\t\tconst validateDelete = await this.fileService.canDelete(\n\t\t\t\toperation.resource,\n\t\t\t\t{\n\t\t\t\t\trecursive: operation.recursive,\n\t\t\t\t\tuseTrash: operation.useTrash,\n\t\t\t\t},\n\t\t\t);\n\t\t\tif (validateDelete instanceof Error) {\n\t\t\t\tthrow validateDelete;\n\t\t\t}\n\t\t}\n\n\t\t// file operation participant\n\t\tconst files = operations.map((operation) => ({\n\t\t\ttarget: operation.resource,\n\t\t}));\n\t\tawait this.runFileOperationParticipants(\n\t\t\tfiles,\n\t\t\tFileOperation.DELETE,\n\t\t\tundoInfo,\n\t\t\ttoken,\n\t\t);\n\n\t\t// before events\n\t\tconst event = {\n\t\t\tcorrelationId: this.correlationIds++,\n\t\t\toperation: FileOperation.DELETE,\n\t\t\tfiles,\n\t\t};\n\t\tawait this._onWillRunWorkingCopyFileOperation.fireAsync(\n\t\t\tevent,\n\t\t\tCancellationToken.None /* intentional: we currently only forward cancellation to participants */,\n\t\t);\n\n\t\t// check for any existing dirty working copies for the resource\n\t\t// and do a soft revert before deleting to be able to close\n\t\t// any opened editor with these working copies\n\t\tfor (const operation of operations) {\n\t\t\tconst dirtyWorkingCopies = this.getDirty(operation.resource);\n\t\t\tawait Promises.settled(\n\t\t\t\tdirtyWorkingCopies.map((dirtyWorkingCopy) =>\n\t\t\t\t\tdirtyWorkingCopy.revert({ soft: true }),\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\n\t\t// now actually delete from disk\n\t\ttry {\n\t\t\tfor (const operation of operations) {\n\t\t\t\tawait this.fileService.del(operation.resource, {\n\t\t\t\t\trecursive: operation.recursive,\n\t\t\t\t\tuseTrash: operation.useTrash,\n\t\t\t\t});\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// error event\n\t\t\tawait this._onDidFailWorkingCopyFileOperation.fireAsync(\n\t\t\t\tevent,\n\t\t\t\tCancellationToken.None /* intentional: we currently only forward cancellation to participants */,\n\t\t\t);\n\n\t\t\tthrow error;\n\t\t}\n\n\t\t// after event\n\t\tawait this._onDidRunWorkingCopyFileOperation.fireAsync(\n\t\t\tevent,\n\t\t\tCancellationToken.None /* intentional: we currently only forward cancellation to participants */,\n\t\t);\n\t}\n\n\t//#endregion\n\n\t//#region File operation participants\n\n\tprivate readonly fileOperationParticipants = this._register(\n\t\tthis.instantiationService.createInstance(\n\t\t\tWorkingCopyFileOperationParticipant,\n\t\t),\n\t);\n\n\taddFileOperationParticipant(\n\t\tparticipant: IWorkingCopyFileOperationParticipant,\n\t): IDisposable {\n\t\treturn this.fileOperationParticipants.addFileOperationParticipant(\n\t\t\tparticipant,\n\t\t);\n\t}\n\n\tprivate runFileOperationParticipants(\n\t\tfiles: SourceTargetPair[],\n\t\toperation: FileOperation,\n\t\tundoInfo: IFileOperationUndoRedoInfo | undefined,\n\t\ttoken: CancellationToken,\n\t): Promise<void> {\n\t\treturn this.fileOperationParticipants.participate(\n\t\t\tfiles,\n\t\t\toperation,\n\t\t\tundoInfo,\n\t\t\ttoken,\n\t\t);\n\t}\n\n\t//#endregion\n\n\t//#region Save participants (stored file working copies only)\n\n\tprivate readonly saveParticipants = this._register(\n\t\tthis.instantiationService.createInstance(\n\t\t\tStoredFileWorkingCopySaveParticipant,\n\t\t),\n\t);\n\n\tget hasSaveParticipants(): boolean {\n\t\treturn this.saveParticipants.length > 0;\n\t}\n\n\taddSaveParticipant(\n\t\tparticipant: IStoredFileWorkingCopySaveParticipant,\n\t): IDisposable {\n\t\treturn this.saveParticipants.addSaveParticipant(participant);\n\t}\n\n\trunSaveParticipants(\n\t\tworkingCopy: IStoredFileWorkingCopy<IStoredFileWorkingCopyModel>,\n\t\tcontext: IStoredFileWorkingCopySaveParticipantContext,\n\t\tprogress: IProgress<IProgressStep>,\n\t\ttoken: CancellationToken,\n\t): Promise<void> {\n\t\treturn this.saveParticipants.participate(\n\t\t\tworkingCopy,\n\t\t\tcontext,\n\t\t\tprogress,\n\t\t\ttoken,\n\t\t);\n\t}\n\n\t//#endregion\n\n\t//#region Path related\n\n\tprivate readonly workingCopyProviders: WorkingCopyProvider[] = [];\n\n\tregisterWorkingCopyProvider(provider: WorkingCopyProvider): IDisposable {\n\t\tconst remove = insert(this.workingCopyProviders, provider);\n\n\t\treturn toDisposable(remove);\n\t}\n\n\tgetDirty(resource: URI): IWorkingCopy[] {\n\t\tconst dirtyWorkingCopies = new Set<IWorkingCopy>();\n\t\tfor (const provider of this.workingCopyProviders) {\n\t\t\tfor (const workingCopy of provider(resource)) {\n\t\t\t\tif (workingCopy.isDirty()) {\n\t\t\t\t\tdirtyWorkingCopies.add(workingCopy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn Array.from(dirtyWorkingCopies);\n\t}\n\n\t//#endregion\n}\n\nregisterSingleton(\n\tIWorkingCopyFileService,\n\tWorkingCopyFileService,\n\tInstantiationType.Delayed,\n);\n"],
  "mappings": "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",
  "names": []
}
