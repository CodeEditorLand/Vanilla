{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/workingCopy/common/workingCopyFileService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createDecorator, IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { InstantiationType, registerSingleton } from '../../../../platform/instantiation/common/extensions.js';\nimport { Event, AsyncEmitter, IWaitUntil } from '../../../../base/common/event.js';\nimport { Promises } from '../../../../base/common/async.js';\nimport { insert } from '../../../../base/common/arrays.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { Disposable, IDisposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { IFileService, FileOperation, IFileStatWithMetadata } from '../../../../platform/files/common/files.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { IWorkingCopyService } from './workingCopyService.js';\nimport { IWorkingCopy } from './workingCopy.js';\nimport { IUriIdentityService } from '../../../../platform/uriIdentity/common/uriIdentity.js';\nimport { WorkingCopyFileOperationParticipant } from './workingCopyFileOperationParticipant.js';\nimport { VSBuffer, VSBufferReadable, VSBufferReadableStream } from '../../../../base/common/buffer.js';\nimport { SaveReason } from '../../../common/editor.js';\nimport { IProgress, IProgressStep } from '../../../../platform/progress/common/progress.js';\nimport { StoredFileWorkingCopySaveParticipant } from './storedFileWorkingCopySaveParticipant.js';\nimport { IStoredFileWorkingCopy, IStoredFileWorkingCopyModel } from './storedFileWorkingCopy.js';\n\nexport const IWorkingCopyFileService = createDecorator<IWorkingCopyFileService>('workingCopyFileService');\n\nexport interface SourceTargetPair {\n\n\t/**\n\t * The source resource that is defined for move operations.\n\t */\n\treadonly source?: URI;\n\n\t/**\n\t * The target resource the event is about.\n\t */\n\treadonly target: URI;\n}\n\nexport interface IFileOperationUndoRedoInfo {\n\n\t/**\n\t * Id of the undo group that the file operation belongs to.\n\t */\n\tundoRedoGroupId?: number;\n\n\t/**\n\t * Flag indicates if the operation is an undo.\n\t */\n\tisUndoing?: boolean;\n}\n\nexport interface WorkingCopyFileEvent extends IWaitUntil {\n\n\t/**\n\t * An identifier to correlate the operation through the\n\t * different event types (before, after, error).\n\t */\n\treadonly correlationId: number;\n\n\t/**\n\t * The file operation that is taking place.\n\t */\n\treadonly operation: FileOperation;\n\n\t/**\n\t * The array of source/target pair of files involved in given operation.\n\t */\n\treadonly files: readonly SourceTargetPair[];\n}\n\nexport interface IWorkingCopyFileOperationParticipant {\n\n\t/**\n\t * Participate in a file operation of working copies. Allows to\n\t * change the working copies before they are being saved to disk.\n\t */\n\tparticipate(\n\t\tfiles: SourceTargetPair[],\n\t\toperation: FileOperation,\n\t\tundoInfo: IFileOperationUndoRedoInfo | undefined,\n\t\ttimeout: number,\n\t\ttoken: CancellationToken\n\t): Promise<void>;\n}\n\nexport interface IStoredFileWorkingCopySaveParticipantContext {\n\t/**\n\t * The reason why the save was triggered.\n\t */\n\treadonly reason: SaveReason;\n\n\t/**\n\t * Only applies to when a text file was saved as, for\n\t * example when starting with untitled and saving. This\n\t * provides access to the initial resource the text\n\t * file had before.\n\t */\n\treadonly savedFrom?: URI;\n}\n\nexport interface IStoredFileWorkingCopySaveParticipant {\n\n\t/**\n\t * Participate in a save operation of file stored working copies.\n\t * Allows to make changes before content is being saved to disk.\n\t */\n\tparticipate(\n\t\tworkingCopy: IStoredFileWorkingCopy<IStoredFileWorkingCopyModel>,\n\t\tcontext: IStoredFileWorkingCopySaveParticipantContext,\n\t\tprogress: IProgress<IProgressStep>,\n\t\ttoken: CancellationToken\n\t): Promise<void>;\n}\n\nexport interface ICreateOperation {\n\tresource: URI;\n\toverwrite?: boolean;\n}\n\nexport interface ICreateFileOperation extends ICreateOperation {\n\tcontents?: VSBuffer | VSBufferReadable | VSBufferReadableStream;\n}\n\nexport interface IDeleteOperation {\n\tresource: URI;\n\tuseTrash?: boolean;\n\trecursive?: boolean;\n}\n\nexport interface IMoveOperation {\n\tfile: Required<SourceTargetPair>;\n\toverwrite?: boolean;\n}\n\nexport interface ICopyOperation extends IMoveOperation { }\n\n/**\n * Returns the working copies for a given resource.\n */\ntype WorkingCopyProvider = (resourceOrFolder: URI) => IWorkingCopy[];\n\n/**\n * A service that allows to perform file operations with working copy support.\n * Any operation that would leave a stale dirty working copy behind will make\n * sure to revert the working copy first.\n *\n * On top of that events are provided to participate in each state of the\n * operation to perform additional work.\n */\nexport interface IWorkingCopyFileService {\n\n\treadonly _serviceBrand: undefined;\n\n\t//#region Events\n\n\t/**\n\t * An event that is fired when a certain working copy IO operation is about to run.\n\t *\n\t * Participants can join this event with a long running operation to keep some state\n\t * before the operation is started, but working copies should not be changed at this\n\t * point in time. For that purpose, use the `IWorkingCopyFileOperationParticipant` API.\n\t */\n\treadonly onWillRunWorkingCopyFileOperation: Event<WorkingCopyFileEvent>;\n\n\t/**\n\t * An event that is fired after a working copy IO operation has failed.\n\t *\n\t * Participants can join this event with a long running operation to clean up as needed.\n\t */\n\treadonly onDidFailWorkingCopyFileOperation: Event<WorkingCopyFileEvent>;\n\n\t/**\n\t * An event that is fired after a working copy IO operation has been performed.\n\t *\n\t * Participants can join this event with a long running operation to make changes\n\t * after the operation has finished.\n\t */\n\treadonly onDidRunWorkingCopyFileOperation: Event<WorkingCopyFileEvent>;\n\n\t//#endregion\n\n\n\t//#region File operation participants\n\n\t/**\n\t * Adds a participant for file operations on working copies.\n\t */\n\taddFileOperationParticipant(participant: IWorkingCopyFileOperationParticipant): IDisposable;\n\n\t//#endregion\n\n\n\t//#region Stored File Working Copy save participants\n\n\t/**\n\t * Whether save participants are present for stored file working copies.\n\t */\n\tget hasSaveParticipants(): boolean;\n\n\t/**\n\t * Adds a participant for save operations on stored file working copies.\n\t */\n\taddSaveParticipant(participant: IStoredFileWorkingCopySaveParticipant): IDisposable;\n\n\t/**\n\t * Runs all available save participants for stored file working copies.\n\t */\n\trunSaveParticipants(workingCopy: IStoredFileWorkingCopy<IStoredFileWorkingCopyModel>, context: IStoredFileWorkingCopySaveParticipantContext, progress: IProgress<IProgressStep>, token: CancellationToken): Promise<void>;\n\n\t//#endregion\n\n\n\t//#region File operations\n\n\t/**\n\t * Will create a resource with the provided optional contents, optionally overwriting any target.\n\t *\n\t * Working copy owners can listen to the `onWillRunWorkingCopyFileOperation` and\n\t * `onDidRunWorkingCopyFileOperation` events to participate.\n\t */\n\tcreate(operations: ICreateFileOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<readonly IFileStatWithMetadata[]>;\n\n\t/**\n\t * Will create a folder and any parent folder that needs to be created.\n\t *\n\t * Working copy owners can listen to the `onWillRunWorkingCopyFileOperation` and\n\t * `onDidRunWorkingCopyFileOperation` events to participate.\n\t *\n\t * Note: events will only be emitted for the provided resource, but not any\n\t * parent folders that are being created as part of the operation.\n\t */\n\tcreateFolder(operations: ICreateOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<readonly IFileStatWithMetadata[]>;\n\n\t/**\n\t * Will move working copies matching the provided resources and corresponding children\n\t * to the target resources using the associated file service for those resources.\n\t *\n\t * Working copy owners can listen to the `onWillRunWorkingCopyFileOperation` and\n\t * `onDidRunWorkingCopyFileOperation` events to participate.\n\t */\n\tmove(operations: IMoveOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<readonly IFileStatWithMetadata[]>;\n\n\t/**\n\t * Will copy working copies matching the provided resources and corresponding children\n\t * to the target resources using the associated file service for those resources.\n\t *\n\t * Working copy owners can listen to the `onWillRunWorkingCopyFileOperation` and\n\t * `onDidRunWorkingCopyFileOperation` events to participate.\n\t */\n\tcopy(operations: ICopyOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<readonly IFileStatWithMetadata[]>;\n\n\t/**\n\t * Will delete working copies matching the provided resources and children\n\t * using the associated file service for those resources.\n\t *\n\t * Working copy owners can listen to the `onWillRunWorkingCopyFileOperation` and\n\t * `onDidRunWorkingCopyFileOperation` events to participate.\n\t */\n\tdelete(operations: IDeleteOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<void>;\n\n\t//#endregion\n\n\n\t//#region Path related\n\n\t/**\n\t * Register a new provider for working copies based on a resource.\n\t *\n\t * @return a disposable that unregisters the provider.\n\t */\n\tregisterWorkingCopyProvider(provider: WorkingCopyProvider): IDisposable;\n\n\t/**\n\t * Will return all working copies that are dirty matching the provided resource.\n\t * If the resource is a folder and the scheme supports file operations, a working\n\t * copy that is dirty and is a child of that folder will also be returned.\n\t */\n\tgetDirty(resource: URI): readonly IWorkingCopy[];\n\n\t//#endregion\n}\n\nexport class WorkingCopyFileService extends Disposable implements IWorkingCopyFileService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\t//#region Events\n\n\tprivate readonly _onWillRunWorkingCopyFileOperation = this._register(new AsyncEmitter<WorkingCopyFileEvent>());\n\treadonly onWillRunWorkingCopyFileOperation = this._onWillRunWorkingCopyFileOperation.event;\n\n\tprivate readonly _onDidFailWorkingCopyFileOperation = this._register(new AsyncEmitter<WorkingCopyFileEvent>());\n\treadonly onDidFailWorkingCopyFileOperation = this._onDidFailWorkingCopyFileOperation.event;\n\n\tprivate readonly _onDidRunWorkingCopyFileOperation = this._register(new AsyncEmitter<WorkingCopyFileEvent>());\n\treadonly onDidRunWorkingCopyFileOperation = this._onDidRunWorkingCopyFileOperation.event;\n\n\t//#endregion\n\n\tprivate correlationIds = 0;\n\n\tconstructor(\n\t\t@IFileService private readonly fileService: IFileService,\n\t\t@IWorkingCopyService private readonly workingCopyService: IWorkingCopyService,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService,\n\t\t@IUriIdentityService private readonly uriIdentityService: IUriIdentityService\n\t) {\n\t\tsuper();\n\n\t\t// register a default working copy provider that uses the working copy service\n\t\tthis._register(this.registerWorkingCopyProvider(resource => {\n\t\t\treturn this.workingCopyService.workingCopies.filter(workingCopy => {\n\t\t\t\tif (this.fileService.hasProvider(resource)) {\n\t\t\t\t\t// only check for parents if the resource can be handled\n\t\t\t\t\t// by the file system where we then assume a folder like\n\t\t\t\t\t// path structure\n\t\t\t\t\treturn this.uriIdentityService.extUri.isEqualOrParent(workingCopy.resource, resource);\n\t\t\t\t}\n\n\t\t\t\treturn this.uriIdentityService.extUri.isEqual(workingCopy.resource, resource);\n\t\t\t});\n\t\t}));\n\t}\n\n\n\t//#region File operations\n\n\tcreate(operations: ICreateFileOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<IFileStatWithMetadata[]> {\n\t\treturn this.doCreateFileOrFolder(operations, true, token, undoInfo);\n\t}\n\n\tcreateFolder(operations: ICreateOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<IFileStatWithMetadata[]> {\n\t\treturn this.doCreateFileOrFolder(operations, false, token, undoInfo);\n\t}\n\n\tasync doCreateFileOrFolder(operations: (ICreateFileOperation | ICreateOperation)[], isFile: boolean, token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<IFileStatWithMetadata[]> {\n\t\tif (operations.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// validate create operation before starting\n\t\tif (isFile) {\n\t\t\tconst validateCreates = await Promises.settled(operations.map(operation => this.fileService.canCreateFile(operation.resource, { overwrite: operation.overwrite })));\n\t\t\tconst error = validateCreates.find(validateCreate => validateCreate instanceof Error);\n\t\t\tif (error instanceof Error) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\n\t\t// file operation participant\n\t\tconst files = operations.map(operation => ({ target: operation.resource }));\n\t\tawait this.runFileOperationParticipants(files, FileOperation.CREATE, undoInfo, token);\n\n\t\t// before events\n\t\tconst event = { correlationId: this.correlationIds++, operation: FileOperation.CREATE, files };\n\t\tawait this._onWillRunWorkingCopyFileOperation.fireAsync(event, CancellationToken.None /* intentional: we currently only forward cancellation to participants */);\n\n\t\t// now actually create on disk\n\t\tlet stats: IFileStatWithMetadata[];\n\t\ttry {\n\t\t\tif (isFile) {\n\t\t\t\tstats = await Promises.settled(operations.map(operation => this.fileService.createFile(operation.resource, (operation as ICreateFileOperation).contents, { overwrite: operation.overwrite })));\n\t\t\t} else {\n\t\t\t\tstats = await Promises.settled(operations.map(operation => this.fileService.createFolder(operation.resource)));\n\t\t\t}\n\t\t} catch (error) {\n\n\t\t\t// error event\n\t\t\tawait this._onDidFailWorkingCopyFileOperation.fireAsync(event, CancellationToken.None /* intentional: we currently only forward cancellation to participants */);\n\n\t\t\tthrow error;\n\t\t}\n\n\t\t// after event\n\t\tawait this._onDidRunWorkingCopyFileOperation.fireAsync(event, CancellationToken.None /* intentional: we currently only forward cancellation to participants */);\n\n\t\treturn stats;\n\t}\n\n\tasync move(operations: IMoveOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<IFileStatWithMetadata[]> {\n\t\treturn this.doMoveOrCopy(operations, true, token, undoInfo);\n\t}\n\n\tasync copy(operations: ICopyOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<IFileStatWithMetadata[]> {\n\t\treturn this.doMoveOrCopy(operations, false, token, undoInfo);\n\t}\n\n\tprivate async doMoveOrCopy(operations: IMoveOperation[] | ICopyOperation[], move: boolean, token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<IFileStatWithMetadata[]> {\n\t\tconst stats: IFileStatWithMetadata[] = [];\n\n\t\t// validate move/copy operation before starting\n\t\tfor (const { file: { source, target }, overwrite } of operations) {\n\t\t\tconst validateMoveOrCopy = await (move ? this.fileService.canMove(source, target, overwrite) : this.fileService.canCopy(source, target, overwrite));\n\t\t\tif (validateMoveOrCopy instanceof Error) {\n\t\t\t\tthrow validateMoveOrCopy;\n\t\t\t}\n\t\t}\n\n\t\t// file operation participant\n\t\tconst files = operations.map(o => o.file);\n\t\tawait this.runFileOperationParticipants(files, move ? FileOperation.MOVE : FileOperation.COPY, undoInfo, token);\n\n\t\t// before event\n\t\tconst event = { correlationId: this.correlationIds++, operation: move ? FileOperation.MOVE : FileOperation.COPY, files };\n\t\tawait this._onWillRunWorkingCopyFileOperation.fireAsync(event, CancellationToken.None /* intentional: we currently only forward cancellation to participants */);\n\n\t\ttry {\n\t\t\tfor (const { file: { source, target }, overwrite } of operations) {\n\t\t\t\t// if source and target are not equal, handle dirty working copies\n\t\t\t\t// depending on the operation:\n\t\t\t\t// - move: revert both source and target (if any)\n\t\t\t\t// - copy: revert target (if any)\n\t\t\t\tif (!this.uriIdentityService.extUri.isEqual(source, target)) {\n\t\t\t\t\tconst dirtyWorkingCopies = (move ? [...this.getDirty(source), ...this.getDirty(target)] : this.getDirty(target));\n\t\t\t\t\tawait Promises.settled(dirtyWorkingCopies.map(dirtyWorkingCopy => dirtyWorkingCopy.revert({ soft: true })));\n\t\t\t\t}\n\n\t\t\t\t// now we can rename the source to target via file operation\n\t\t\t\tif (move) {\n\t\t\t\t\tstats.push(await this.fileService.move(source, target, overwrite));\n\t\t\t\t} else {\n\t\t\t\t\tstats.push(await this.fileService.copy(source, target, overwrite));\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\n\t\t\t// error event\n\t\t\tawait this._onDidFailWorkingCopyFileOperation.fireAsync(event, CancellationToken.None /* intentional: we currently only forward cancellation to participants */);\n\n\t\t\tthrow error;\n\t\t}\n\n\t\t// after event\n\t\tawait this._onDidRunWorkingCopyFileOperation.fireAsync(event, CancellationToken.None /* intentional: we currently only forward cancellation to participants */);\n\n\t\treturn stats;\n\t}\n\n\tasync delete(operations: IDeleteOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<void> {\n\n\t\t// validate delete operation before starting\n\t\tfor (const operation of operations) {\n\t\t\tconst validateDelete = await this.fileService.canDelete(operation.resource, { recursive: operation.recursive, useTrash: operation.useTrash });\n\t\t\tif (validateDelete instanceof Error) {\n\t\t\t\tthrow validateDelete;\n\t\t\t}\n\t\t}\n\n\t\t// file operation participant\n\t\tconst files = operations.map(operation => ({ target: operation.resource }));\n\t\tawait this.runFileOperationParticipants(files, FileOperation.DELETE, undoInfo, token);\n\n\t\t// before events\n\t\tconst event = { correlationId: this.correlationIds++, operation: FileOperation.DELETE, files };\n\t\tawait this._onWillRunWorkingCopyFileOperation.fireAsync(event, CancellationToken.None /* intentional: we currently only forward cancellation to participants */);\n\n\t\t// check for any existing dirty working copies for the resource\n\t\t// and do a soft revert before deleting to be able to close\n\t\t// any opened editor with these working copies\n\t\tfor (const operation of operations) {\n\t\t\tconst dirtyWorkingCopies = this.getDirty(operation.resource);\n\t\t\tawait Promises.settled(dirtyWorkingCopies.map(dirtyWorkingCopy => dirtyWorkingCopy.revert({ soft: true })));\n\t\t}\n\n\t\t// now actually delete from disk\n\t\ttry {\n\t\t\tfor (const operation of operations) {\n\t\t\t\tawait this.fileService.del(operation.resource, { recursive: operation.recursive, useTrash: operation.useTrash });\n\t\t\t}\n\t\t} catch (error) {\n\n\t\t\t// error event\n\t\t\tawait this._onDidFailWorkingCopyFileOperation.fireAsync(event, CancellationToken.None /* intentional: we currently only forward cancellation to participants */);\n\n\t\t\tthrow error;\n\t\t}\n\n\t\t// after event\n\t\tawait this._onDidRunWorkingCopyFileOperation.fireAsync(event, CancellationToken.None /* intentional: we currently only forward cancellation to participants */);\n\t}\n\n\t//#endregion\n\n\n\t//#region File operation participants\n\n\tprivate readonly fileOperationParticipants = this._register(this.instantiationService.createInstance(WorkingCopyFileOperationParticipant));\n\n\taddFileOperationParticipant(participant: IWorkingCopyFileOperationParticipant): IDisposable {\n\t\treturn this.fileOperationParticipants.addFileOperationParticipant(participant);\n\t}\n\n\tprivate runFileOperationParticipants(files: SourceTargetPair[], operation: FileOperation, undoInfo: IFileOperationUndoRedoInfo | undefined, token: CancellationToken): Promise<void> {\n\t\treturn this.fileOperationParticipants.participate(files, operation, undoInfo, token);\n\t}\n\n\t//#endregion\n\n\t//#region Save participants (stored file working copies only)\n\n\tprivate readonly saveParticipants = this._register(this.instantiationService.createInstance(StoredFileWorkingCopySaveParticipant));\n\n\tget hasSaveParticipants(): boolean { return this.saveParticipants.length > 0; }\n\n\taddSaveParticipant(participant: IStoredFileWorkingCopySaveParticipant): IDisposable {\n\t\treturn this.saveParticipants.addSaveParticipant(participant);\n\t}\n\n\trunSaveParticipants(workingCopy: IStoredFileWorkingCopy<IStoredFileWorkingCopyModel>, context: IStoredFileWorkingCopySaveParticipantContext, progress: IProgress<IProgressStep>, token: CancellationToken): Promise<void> {\n\t\treturn this.saveParticipants.participate(workingCopy, context, progress, token);\n\t}\n\n\t//#endregion\n\n\n\t//#region Path related\n\n\tprivate readonly workingCopyProviders: WorkingCopyProvider[] = [];\n\n\tregisterWorkingCopyProvider(provider: WorkingCopyProvider): IDisposable {\n\t\tconst remove = insert(this.workingCopyProviders, provider);\n\n\t\treturn toDisposable(remove);\n\t}\n\n\tgetDirty(resource: URI): IWorkingCopy[] {\n\t\tconst dirtyWorkingCopies = new Set<IWorkingCopy>();\n\t\tfor (const provider of this.workingCopyProviders) {\n\t\t\tfor (const workingCopy of provider(resource)) {\n\t\t\t\tif (workingCopy.isDirty()) {\n\t\t\t\t\tdirtyWorkingCopies.add(workingCopy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn Array.from(dirtyWorkingCopies);\n\t}\n\n\t//#endregion\n}\n\nregisterSingleton(IWorkingCopyFileService, WorkingCopyFileService, InstantiationType.Delayed);\n"],
  "mappings": ";;;;;;;;;;;;AAKA,SAAS,iBAAiB,6BAA6B;AACvD,SAAS,mBAAmB,yBAAyB;AACrD,SAAS,OAAO,cAAc,kBAAkB;AAChD,SAAS,gBAAgB;AACzB,SAAS,cAAc;AACvB,SAAS,WAAW;AACpB,SAAS,YAAY,aAAa,oBAAoB;AACtD,SAAS,cAAc,eAAe,6BAA6B;AACnE,SAAS,yBAAyB;AAClC,SAAS,2BAA2B;AACpC,SAAS,oBAAoB;AAC7B,SAAS,2BAA2B;AACpC,SAAS,2CAA2C;AACpD,SAAS,UAAU,kBAAkB,8BAA8B;AACnE,SAAS,kBAAkB;AAC3B,SAAS,WAAW,qBAAqB;AACzC,SAAS,4CAA4C;AACrD,SAAS,wBAAwB,mCAAmC;AAE7D,MAAM,0BAA0B,gBAAyC,wBAAwB;AAmQjG,IAAM,yBAAN,cAAqC,WAA8C;AAAA,EAmBzF,YACgC,aACO,oBACE,sBACF,oBACrC;AACD,UAAM;AALyB;AACO;AACE;AACF;AAKtC,SAAK,UAAU,KAAK,4BAA4B,cAAY;AAC3D,aAAO,KAAK,mBAAmB,cAAc,OAAO,iBAAe;AAClE,YAAI,KAAK,YAAY,YAAY,QAAQ,GAAG;AAI3C,iBAAO,KAAK,mBAAmB,OAAO,gBAAgB,YAAY,UAAU,QAAQ;AAAA,QACrF;AAEA,eAAO,KAAK,mBAAmB,OAAO,QAAQ,YAAY,UAAU,QAAQ;AAAA,MAC7E,CAAC;AAAA,IACF,CAAC,CAAC;AAAA,EACH;AAAA,EAnUD,OA2R0F;AAAA;AAAA;AAAA;AAAA,EAMxE,qCAAqC,KAAK,UAAU,IAAI,aAAmC,CAAC;AAAA,EACpG,oCAAoC,KAAK,mCAAmC;AAAA,EAEpE,qCAAqC,KAAK,UAAU,IAAI,aAAmC,CAAC;AAAA,EACpG,oCAAoC,KAAK,mCAAmC;AAAA,EAEpE,oCAAoC,KAAK,UAAU,IAAI,aAAmC,CAAC;AAAA,EACnG,mCAAmC,KAAK,kCAAkC;AAAA;AAAA,EAI3E,iBAAiB;AAAA;AAAA,EA4BzB,OAAO,YAAoC,OAA0B,UAAyE;AAC7I,WAAO,KAAK,qBAAqB,YAAY,MAAM,OAAO,QAAQ;AAAA,EACnE;AAAA,EAEA,aAAa,YAAgC,OAA0B,UAAyE;AAC/I,WAAO,KAAK,qBAAqB,YAAY,OAAO,OAAO,QAAQ;AAAA,EACpE;AAAA,EAEA,MAAM,qBAAqB,YAAyD,QAAiB,OAA0B,UAAyE;AACvM,QAAI,WAAW,WAAW,GAAG;AAC5B,aAAO,CAAC;AAAA,IACT;AAGA,QAAI,QAAQ;AACX,YAAM,kBAAkB,MAAM,SAAS,QAAQ,WAAW,IAAI,eAAa,KAAK,YAAY,cAAc,UAAU,UAAU,EAAE,WAAW,UAAU,UAAU,CAAC,CAAC,CAAC;AAClK,YAAM,QAAQ,gBAAgB,KAAK,oBAAkB,0BAA0B,KAAK;AACpF,UAAI,iBAAiB,OAAO;AAC3B,cAAM;AAAA,MACP;AAAA,IACD;AAGA,UAAM,QAAQ,WAAW,IAAI,gBAAc,EAAE,QAAQ,UAAU,SAAS,EAAE;AAC1E,UAAM,KAAK,6BAA6B,OAAO,cAAc,QAAQ,UAAU,KAAK;AAGpF,UAAM,QAAQ,EAAE,eAAe,KAAK,kBAAkB,WAAW,cAAc,QAAQ,MAAM;AAC7F,UAAM,KAAK,mCAAmC;AAAA,MAAU;AAAA,MAAO,kBAAkB;AAAA;AAAA,IAA8E;AAG/J,QAAI;AACJ,QAAI;AACH,UAAI,QAAQ;AACX,gBAAQ,MAAM,SAAS,QAAQ,WAAW,IAAI,eAAa,KAAK,YAAY,WAAW,UAAU,UAAW,UAAmC,UAAU,EAAE,WAAW,UAAU,UAAU,CAAC,CAAC,CAAC;AAAA,MAC9L,OAAO;AACN,gBAAQ,MAAM,SAAS,QAAQ,WAAW,IAAI,eAAa,KAAK,YAAY,aAAa,UAAU,QAAQ,CAAC,CAAC;AAAA,MAC9G;AAAA,IACD,SAAS,OAAO;AAGf,YAAM,KAAK,mCAAmC;AAAA,QAAU;AAAA,QAAO,kBAAkB;AAAA;AAAA,MAA8E;AAE/J,YAAM;AAAA,IACP;AAGA,UAAM,KAAK,kCAAkC;AAAA,MAAU;AAAA,MAAO,kBAAkB;AAAA;AAAA,IAA8E;AAE9J,WAAO;AAAA,EACR;AAAA,EAEA,MAAM,KAAK,YAA8B,OAA0B,UAAyE;AAC3I,WAAO,KAAK,aAAa,YAAY,MAAM,OAAO,QAAQ;AAAA,EAC3D;AAAA,EAEA,MAAM,KAAK,YAA8B,OAA0B,UAAyE;AAC3I,WAAO,KAAK,aAAa,YAAY,OAAO,OAAO,QAAQ;AAAA,EAC5D;AAAA,EAEA,MAAc,aAAa,YAAiD,MAAe,OAA0B,UAAyE;AAC7L,UAAM,QAAiC,CAAC;AAGxC,eAAW,EAAE,MAAM,EAAE,QAAQ,OAAO,GAAG,UAAU,KAAK,YAAY;AACjE,YAAM,qBAAqB,OAAO,OAAO,KAAK,YAAY,QAAQ,QAAQ,QAAQ,SAAS,IAAI,KAAK,YAAY,QAAQ,QAAQ,QAAQ,SAAS;AACjJ,UAAI,8BAA8B,OAAO;AACxC,cAAM;AAAA,MACP;AAAA,IACD;AAGA,UAAM,QAAQ,WAAW,IAAI,OAAK,EAAE,IAAI;AACxC,UAAM,KAAK,6BAA6B,OAAO,OAAO,cAAc,OAAO,cAAc,MAAM,UAAU,KAAK;AAG9G,UAAM,QAAQ,EAAE,eAAe,KAAK,kBAAkB,WAAW,OAAO,cAAc,OAAO,cAAc,MAAM,MAAM;AACvH,UAAM,KAAK,mCAAmC;AAAA,MAAU;AAAA,MAAO,kBAAkB;AAAA;AAAA,IAA8E;AAE/J,QAAI;AACH,iBAAW,EAAE,MAAM,EAAE,QAAQ,OAAO,GAAG,UAAU,KAAK,YAAY;AAKjE,YAAI,CAAC,KAAK,mBAAmB,OAAO,QAAQ,QAAQ,MAAM,GAAG;AAC5D,gBAAM,qBAAsB,OAAO,CAAC,GAAG,KAAK,SAAS,MAAM,GAAG,GAAG,KAAK,SAAS,MAAM,CAAC,IAAI,KAAK,SAAS,MAAM;AAC9G,gBAAM,SAAS,QAAQ,mBAAmB,IAAI,sBAAoB,iBAAiB,OAAO,EAAE,MAAM,KAAK,CAAC,CAAC,CAAC;AAAA,QAC3G;AAGA,YAAI,MAAM;AACT,gBAAM,KAAK,MAAM,KAAK,YAAY,KAAK,QAAQ,QAAQ,SAAS,CAAC;AAAA,QAClE,OAAO;AACN,gBAAM,KAAK,MAAM,KAAK,YAAY,KAAK,QAAQ,QAAQ,SAAS,CAAC;AAAA,QAClE;AAAA,MACD;AAAA,IACD,SAAS,OAAO;AAGf,YAAM,KAAK,mCAAmC;AAAA,QAAU;AAAA,QAAO,kBAAkB;AAAA;AAAA,MAA8E;AAE/J,YAAM;AAAA,IACP;AAGA,UAAM,KAAK,kCAAkC;AAAA,MAAU;AAAA,MAAO,kBAAkB;AAAA;AAAA,IAA8E;AAE9J,WAAO;AAAA,EACR;AAAA,EAEA,MAAM,OAAO,YAAgC,OAA0B,UAAsD;AAG5H,eAAW,aAAa,YAAY;AACnC,YAAM,iBAAiB,MAAM,KAAK,YAAY,UAAU,UAAU,UAAU,EAAE,WAAW,UAAU,WAAW,UAAU,UAAU,SAAS,CAAC;AAC5I,UAAI,0BAA0B,OAAO;AACpC,cAAM;AAAA,MACP;AAAA,IACD;AAGA,UAAM,QAAQ,WAAW,IAAI,gBAAc,EAAE,QAAQ,UAAU,SAAS,EAAE;AAC1E,UAAM,KAAK,6BAA6B,OAAO,cAAc,QAAQ,UAAU,KAAK;AAGpF,UAAM,QAAQ,EAAE,eAAe,KAAK,kBAAkB,WAAW,cAAc,QAAQ,MAAM;AAC7F,UAAM,KAAK,mCAAmC;AAAA,MAAU;AAAA,MAAO,kBAAkB;AAAA;AAAA,IAA8E;AAK/J,eAAW,aAAa,YAAY;AACnC,YAAM,qBAAqB,KAAK,SAAS,UAAU,QAAQ;AAC3D,YAAM,SAAS,QAAQ,mBAAmB,IAAI,sBAAoB,iBAAiB,OAAO,EAAE,MAAM,KAAK,CAAC,CAAC,CAAC;AAAA,IAC3G;AAGA,QAAI;AACH,iBAAW,aAAa,YAAY;AACnC,cAAM,KAAK,YAAY,IAAI,UAAU,UAAU,EAAE,WAAW,UAAU,WAAW,UAAU,UAAU,SAAS,CAAC;AAAA,MAChH;AAAA,IACD,SAAS,OAAO;AAGf,YAAM,KAAK,mCAAmC;AAAA,QAAU;AAAA,QAAO,kBAAkB;AAAA;AAAA,MAA8E;AAE/J,YAAM;AAAA,IACP;AAGA,UAAM,KAAK,kCAAkC;AAAA,MAAU;AAAA,MAAO,kBAAkB;AAAA;AAAA,IAA8E;AAAA,EAC/J;AAAA;AAAA;AAAA,EAOiB,4BAA4B,KAAK,UAAU,KAAK,qBAAqB,eAAe,mCAAmC,CAAC;AAAA,EAEzI,4BAA4B,aAAgE;AAC3F,WAAO,KAAK,0BAA0B,4BAA4B,WAAW;AAAA,EAC9E;AAAA,EAEQ,6BAA6B,OAA2B,WAA0B,UAAkD,OAAyC;AACpL,WAAO,KAAK,0BAA0B,YAAY,OAAO,WAAW,UAAU,KAAK;AAAA,EACpF;AAAA;AAAA;AAAA,EAMiB,mBAAmB,KAAK,UAAU,KAAK,qBAAqB,eAAe,oCAAoC,CAAC;AAAA,EAEjI,IAAI,sBAA+B;AAAE,WAAO,KAAK,iBAAiB,SAAS;AAAA,EAAG;AAAA,EAE9E,mBAAmB,aAAiE;AACnF,WAAO,KAAK,iBAAiB,mBAAmB,WAAW;AAAA,EAC5D;AAAA,EAEA,oBAAoB,aAAkE,SAAuD,UAAoC,OAAyC;AACzN,WAAO,KAAK,iBAAiB,YAAY,aAAa,SAAS,UAAU,KAAK;AAAA,EAC/E;AAAA;AAAA;AAAA,EAOiB,uBAA8C,CAAC;AAAA,EAEhE,4BAA4B,UAA4C;AACvE,UAAM,SAAS,OAAO,KAAK,sBAAsB,QAAQ;AAEzD,WAAO,aAAa,MAAM;AAAA,EAC3B;AAAA,EAEA,SAAS,UAA+B;AACvC,UAAM,qBAAqB,oBAAI,IAAkB;AACjD,eAAW,YAAY,KAAK,sBAAsB;AACjD,iBAAW,eAAe,SAAS,QAAQ,GAAG;AAC7C,YAAI,YAAY,QAAQ,GAAG;AAC1B,6BAAmB,IAAI,WAAW;AAAA,QACnC;AAAA,MACD;AAAA,IACD;AAEA,WAAO,MAAM,KAAK,kBAAkB;AAAA,EACrC;AAAA;AAGD;AAjQa,yBAAN;AAAA,EAoBJ;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,GAvBU;AAmQb,kBAAkB,yBAAyB,wBAAwB,kBAAkB,OAAO;",
  "names": []
}
