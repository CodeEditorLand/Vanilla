var m=Object.defineProperty;var v=Object.getOwnPropertyDescriptor;var d=(s,r,e,o)=>{for(var i=o>1?void 0:o?v(r,e):r,p=s.length-1,n;p>=0;p--)(n=s[p])&&(i=(o?n(r,e,i):n(i))||i);return o&&i&&m(r,e,i),i},t=(s,r)=>(e,o)=>r(e,o,s);import{Promises as u}from"../../../../../vs/base/common/async.js";import{Emitter as W}from"../../../../../vs/base/common/event.js";import{Disposable as y,dispose as c}from"../../../../../vs/base/common/lifecycle.js";import{ResourceMap as l}from"../../../../../vs/base/common/map.js";import"../../../../../vs/base/common/uri.js";import{IFileService as h}from"../../../../../vs/platform/files/common/files.js";import{ILogService as g}from"../../../../../vs/platform/log/common/log.js";import"../../../../../vs/workbench/services/workingCopy/common/fileWorkingCopy.js";import{IWorkingCopyBackupService as k}from"../../../../../vs/workbench/services/workingCopy/common/workingCopyBackup.js";let a=class extends y{constructor(e,o,i){super();this.fileService=e;this.logService=o;this.workingCopyBackupService=i}_onDidCreate=this._register(new W);onDidCreate=this._onDidCreate.event;mapResourceToWorkingCopy=new l;mapResourceToDisposeListener=new l;has(e){return this.mapResourceToWorkingCopy.has(e)}add(e,o){this.get(e)!==o&&(this.mapResourceToWorkingCopy.set(e,o),this.mapResourceToDisposeListener.get(e)?.dispose(),this.mapResourceToDisposeListener.set(e,o.onWillDispose(()=>this.remove(e))),this._onDidCreate.fire(o))}remove(e){const o=this.mapResourceToDisposeListener.get(e);return o&&(c(o),this.mapResourceToDisposeListener.delete(e)),this.mapResourceToWorkingCopy.delete(e)}get workingCopies(){return[...this.mapResourceToWorkingCopy.values()]}get(e){return this.mapResourceToWorkingCopy.get(e)}dispose(){super.dispose(),this.mapResourceToWorkingCopy.clear(),c(this.mapResourceToDisposeListener.values()),this.mapResourceToDisposeListener.clear()}async destroy(){try{await u.settled(this.workingCopies.map(async e=>{e.isDirty()&&await this.saveWithFallback(e)}))}catch(e){this.logService.error(e)}c(this.mapResourceToWorkingCopy.values()),this.dispose()}async saveWithFallback(e){let o=!1;try{o=await e.save()}catch{}if(!o||e.isDirty()){const i=await this.workingCopyBackupService.resolve(e);i&&await this.fileService.writeFile(e.resource,i.value,{unlock:!0})}}};a=d([t(0,h),t(1,g),t(2,k)],a);export{a as BaseFileWorkingCopyManager};
