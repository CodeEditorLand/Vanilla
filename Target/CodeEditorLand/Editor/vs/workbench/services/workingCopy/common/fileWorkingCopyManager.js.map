{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/workingCopy/common/fileWorkingCopyManager.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { localize } from '../../../../nls.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { Promises } from '../../../../base/common/async.js';\nimport { VSBufferReadableStream } from '../../../../base/common/buffer.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { toLocalResource, joinPath, isEqual, basename, dirname } from '../../../../base/common/resources.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IFileDialogService, IDialogService } from '../../../../platform/dialogs/common/dialogs.js';\nimport { IFileService } from '../../../../platform/files/common/files.js';\nimport { ISaveOptions, SaveSourceRegistry } from '../../../common/editor.js';\nimport { IWorkbenchEnvironmentService } from '../../environment/common/environmentService.js';\nimport { IPathService } from '../../path/common/pathService.js';\nimport { IUriIdentityService } from '../../../../platform/uriIdentity/common/uriIdentity.js';\nimport { IStoredFileWorkingCopy, IStoredFileWorkingCopyModel, IStoredFileWorkingCopyModelFactory, IStoredFileWorkingCopyResolveOptions, StoredFileWorkingCopyState } from './storedFileWorkingCopy.js';\nimport { StoredFileWorkingCopyManager, IStoredFileWorkingCopyManager, IStoredFileWorkingCopyManagerResolveOptions } from './storedFileWorkingCopyManager.js';\nimport { IUntitledFileWorkingCopy, IUntitledFileWorkingCopyModel, IUntitledFileWorkingCopyModelFactory, UntitledFileWorkingCopy } from './untitledFileWorkingCopy.js';\nimport { INewOrExistingUntitledFileWorkingCopyOptions, INewUntitledFileWorkingCopyOptions, INewUntitledFileWorkingCopyWithAssociatedResourceOptions, IUntitledFileWorkingCopyManager, UntitledFileWorkingCopyManager } from './untitledFileWorkingCopyManager.js';\nimport { IWorkingCopyFileService } from './workingCopyFileService.js';\nimport { IBaseFileWorkingCopyManager } from './abstractFileWorkingCopyManager.js';\nimport { IFileWorkingCopy, SnapshotContext } from './fileWorkingCopy.js';\nimport { ILabelService } from '../../../../platform/label/common/label.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { INotificationService } from '../../../../platform/notification/common/notification.js';\nimport { IEditorService } from '../../editor/common/editorService.js';\nimport { IElevatedFileService } from '../../files/common/elevatedFileService.js';\nimport { IFilesConfigurationService } from '../../filesConfiguration/common/filesConfigurationService.js';\nimport { ILifecycleService } from '../../lifecycle/common/lifecycle.js';\nimport { IWorkingCopyBackupService } from './workingCopyBackup.js';\nimport { IWorkingCopyEditorService } from './workingCopyEditorService.js';\nimport { IWorkingCopyService } from './workingCopyService.js';\nimport { Schemas } from '../../../../base/common/network.js';\nimport { IDecorationData, IDecorationsProvider, IDecorationsService } from '../../decorations/common/decorations.js';\nimport { Codicon } from '../../../../base/common/codicons.js';\nimport { listErrorForeground } from '../../../../platform/theme/common/colorRegistry.js';\nimport { IProgressService } from '../../../../platform/progress/common/progress.js';\n\nexport interface IFileWorkingCopyManager<S extends IStoredFileWorkingCopyModel, U extends IUntitledFileWorkingCopyModel> extends IBaseFileWorkingCopyManager<S | U, IFileWorkingCopy<S | U>> {\n\n\t/**\n\t * Provides access to the manager for stored file working copies.\n\t */\n\treadonly stored: IStoredFileWorkingCopyManager<S>;\n\n\t/**\n\t * Provides access to the manager for untitled file working copies.\n\t */\n\treadonly untitled: IUntitledFileWorkingCopyManager<U>;\n\n\t/**\n\t * Allows to resolve a stored file working copy. If the manager already knows\n\t * about a stored file working copy with the same `URI`, it will return that\n\t * existing stored file working copy. There will never be more than one\n\t * stored file working copy per `URI` until the stored file working copy is\n\t * disposed.\n\t *\n\t * Use the `IStoredFileWorkingCopyResolveOptions.reload` option to control the\n\t * behaviour for when a stored file working copy was previously already resolved\n\t * with regards to resolving it again from the underlying file resource\n\t * or not.\n\t *\n\t * Note: Callers must `dispose` the working copy when no longer needed.\n\t *\n\t * @param resource used as unique identifier of the stored file working copy in\n\t * case one is already known for this `URI`.\n\t * @param options\n\t */\n\tresolve(resource: URI, options?: IStoredFileWorkingCopyManagerResolveOptions): Promise<IStoredFileWorkingCopy<S>>;\n\n\t/**\n\t * Create a new untitled file working copy with optional initial contents.\n\t *\n\t * Note: Callers must `dispose` the working copy when no longer needed.\n\t */\n\tresolve(options?: INewUntitledFileWorkingCopyOptions): Promise<IUntitledFileWorkingCopy<U>>;\n\n\t/**\n\t * Create a new untitled file working copy with optional initial contents\n\t * and associated resource. The associated resource will be used when\n\t * saving and will not require to ask the user for a file path.\n\t *\n\t * Note: Callers must `dispose` the working copy when no longer needed.\n\t */\n\tresolve(options?: INewUntitledFileWorkingCopyWithAssociatedResourceOptions): Promise<IUntitledFileWorkingCopy<U>>;\n\n\t/**\n\t * Creates a new untitled file working copy with optional initial contents\n\t * with the provided resource or return an existing untitled file working\n\t * copy otherwise.\n\t *\n\t * Note: Callers must `dispose` the working copy when no longer needed.\n\t */\n\tresolve(options?: INewOrExistingUntitledFileWorkingCopyOptions): Promise<IUntitledFileWorkingCopy<U>>;\n\n\t/**\n\t * Implements \"Save As\" for file based working copies. The API is `URI` based\n\t * because it works even without resolved file working copies. If a file working\n\t * copy exists for any given `URI`, the implementation will deal with them properly\n\t * (e.g. dirty contents of the source will be written to the target and the source\n\t * will be reverted).\n\t *\n\t * Note: it is possible that the returned file working copy has a different `URI`\n\t * than the `target` that was passed in. Based on URI identity, the file working\n\t * copy may chose to return an existing file working copy with different casing\n\t * to respect file systems that are case insensitive.\n\t *\n\t * Note: Callers must `dispose` the working copy when no longer needed.\n\t *\n\t * Note: Untitled file working copies are being disposed when saved.\n\t *\n\t * @param source the source resource to save as\n\t * @param target the optional target resource to save to. if not defined, the user\n\t * will be asked for input\n\t * @returns the target stored working copy that was saved to or `undefined` in case of\n\t * cancellation\n\t */\n\tsaveAs(source: URI, target: URI, options?: ISaveOptions): Promise<IStoredFileWorkingCopy<S> | undefined>;\n\tsaveAs(source: URI, target: undefined, options?: IFileWorkingCopySaveAsOptions): Promise<IStoredFileWorkingCopy<S> | undefined>;\n}\n\nexport interface IFileWorkingCopySaveAsOptions extends ISaveOptions {\n\n\t/**\n\t * Optional target resource to suggest to the user in case\n\t * no target resource is provided to save to.\n\t */\n\tsuggestedTarget?: URI;\n}\n\nexport class FileWorkingCopyManager<S extends IStoredFileWorkingCopyModel, U extends IUntitledFileWorkingCopyModel> extends Disposable implements IFileWorkingCopyManager<S, U> {\n\n\treadonly onDidCreate: Event<IFileWorkingCopy<S | U>>;\n\n\tprivate static readonly FILE_WORKING_COPY_SAVE_CREATE_SOURCE = SaveSourceRegistry.registerSource('fileWorkingCopyCreate.source', localize('fileWorkingCopyCreate.source', \"File Created\"));\n\tprivate static readonly FILE_WORKING_COPY_SAVE_REPLACE_SOURCE = SaveSourceRegistry.registerSource('fileWorkingCopyReplace.source', localize('fileWorkingCopyReplace.source', \"File Replaced\"));\n\n\treadonly stored: IStoredFileWorkingCopyManager<S>;\n\treadonly untitled: IUntitledFileWorkingCopyManager<U>;\n\n\tconstructor(\n\t\tprivate readonly workingCopyTypeId: string,\n\t\tprivate readonly storedWorkingCopyModelFactory: IStoredFileWorkingCopyModelFactory<S>,\n\t\tprivate readonly untitledWorkingCopyModelFactory: IUntitledFileWorkingCopyModelFactory<U>,\n\t\t@IFileService private readonly fileService: IFileService,\n\t\t@ILifecycleService lifecycleService: ILifecycleService,\n\t\t@ILabelService labelService: ILabelService,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IWorkingCopyFileService private readonly workingCopyFileService: IWorkingCopyFileService,\n\t\t@IWorkingCopyBackupService workingCopyBackupService: IWorkingCopyBackupService,\n\t\t@IUriIdentityService private readonly uriIdentityService: IUriIdentityService,\n\t\t@IFileDialogService private readonly fileDialogService: IFileDialogService,\n\t\t@IFilesConfigurationService private readonly filesConfigurationService: IFilesConfigurationService,\n\t\t@IWorkingCopyService workingCopyService: IWorkingCopyService,\n\t\t@INotificationService notificationService: INotificationService,\n\t\t@IWorkingCopyEditorService workingCopyEditorService: IWorkingCopyEditorService,\n\t\t@IEditorService editorService: IEditorService,\n\t\t@IElevatedFileService elevatedFileService: IElevatedFileService,\n\t\t@IPathService private readonly pathService: IPathService,\n\t\t@IWorkbenchEnvironmentService private readonly environmentService: IWorkbenchEnvironmentService,\n\t\t@IDialogService private readonly dialogService: IDialogService,\n\t\t@IDecorationsService private readonly decorationsService: IDecorationsService,\n\t\t@IProgressService progressService: IProgressService\n\t) {\n\t\tsuper();\n\n\t\t// Stored file working copies manager\n\t\tthis.stored = this._register(new StoredFileWorkingCopyManager(\n\t\t\tthis.workingCopyTypeId,\n\t\t\tthis.storedWorkingCopyModelFactory,\n\t\t\tfileService, lifecycleService, labelService, logService, workingCopyFileService,\n\t\t\tworkingCopyBackupService, uriIdentityService, filesConfigurationService, workingCopyService,\n\t\t\tnotificationService, workingCopyEditorService, editorService, elevatedFileService, progressService\n\t\t));\n\n\t\t// Untitled file working copies manager\n\t\tthis.untitled = this._register(new UntitledFileWorkingCopyManager(\n\t\t\tthis.workingCopyTypeId,\n\t\t\tthis.untitledWorkingCopyModelFactory,\n\t\t\tasync (workingCopy, options) => {\n\t\t\t\tconst result = await this.saveAs(workingCopy.resource, undefined, options);\n\n\t\t\t\treturn result ? true : false;\n\t\t\t},\n\t\t\tfileService, labelService, logService, workingCopyBackupService, workingCopyService\n\t\t));\n\n\t\t// Events\n\t\tthis.onDidCreate = Event.any<IFileWorkingCopy<S | U>>(this.stored.onDidCreate, this.untitled.onDidCreate);\n\n\t\t// Decorations\n\t\tthis.provideDecorations();\n\t}\n\n\t//#region decorations\n\n\tprivate provideDecorations(): void {\n\n\t\t// File working copy decorations\n\t\tconst provider = this._register(new class extends Disposable implements IDecorationsProvider {\n\n\t\t\treadonly label = localize('fileWorkingCopyDecorations', \"File Working Copy Decorations\");\n\n\t\t\tprivate readonly _onDidChange = this._register(new Emitter<URI[]>());\n\t\t\treadonly onDidChange = this._onDidChange.event;\n\n\t\t\tconstructor(private readonly stored: IStoredFileWorkingCopyManager<S>) {\n\t\t\t\tsuper();\n\n\t\t\t\tthis.registerListeners();\n\t\t\t}\n\n\t\t\tprivate registerListeners(): void {\n\n\t\t\t\t// Creates\n\t\t\t\tthis._register(this.stored.onDidResolve(workingCopy => {\n\t\t\t\t\tif (workingCopy.isReadonly() || workingCopy.hasState(StoredFileWorkingCopyState.ORPHAN)) {\n\t\t\t\t\t\tthis._onDidChange.fire([workingCopy.resource]);\n\t\t\t\t\t}\n\t\t\t\t}));\n\n\t\t\t\t// Removals: once a stored working copy is no longer\n\t\t\t\t// under our control, make sure to signal this as\n\t\t\t\t// decoration change because from this point on we\n\t\t\t\t// have no way of updating the decoration anymore.\n\t\t\t\tthis._register(this.stored.onDidRemove(workingCopyUri => this._onDidChange.fire([workingCopyUri])));\n\n\t\t\t\t// Changes\n\t\t\t\tthis._register(this.stored.onDidChangeReadonly(workingCopy => this._onDidChange.fire([workingCopy.resource])));\n\t\t\t\tthis._register(this.stored.onDidChangeOrphaned(workingCopy => this._onDidChange.fire([workingCopy.resource])));\n\t\t\t}\n\n\t\t\tprovideDecorations(uri: URI): IDecorationData | undefined {\n\t\t\t\tconst workingCopy = this.stored.get(uri);\n\t\t\t\tif (!workingCopy || workingCopy.isDisposed()) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\tconst isReadonly = workingCopy.isReadonly();\n\t\t\t\tconst isOrphaned = workingCopy.hasState(StoredFileWorkingCopyState.ORPHAN);\n\n\t\t\t\t// Readonly + Orphaned\n\t\t\t\tif (isReadonly && isOrphaned) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tcolor: listErrorForeground,\n\t\t\t\t\t\tletter: Codicon.lockSmall,\n\t\t\t\t\t\tstrikethrough: true,\n\t\t\t\t\t\ttooltip: localize('readonlyAndDeleted', \"Deleted, Read-only\"),\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Readonly\n\t\t\t\telse if (isReadonly) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tletter: Codicon.lockSmall,\n\t\t\t\t\t\ttooltip: localize('readonly', \"Read-only\"),\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Orphaned\n\t\t\t\telse if (isOrphaned) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tcolor: listErrorForeground,\n\t\t\t\t\t\tstrikethrough: true,\n\t\t\t\t\t\ttooltip: localize('deleted', \"Deleted\"),\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}(this.stored));\n\n\t\tthis._register(this.decorationsService.registerDecorationsProvider(provider));\n\t}\n\n\t//#endregin\n\n\t//#region get / get all\n\n\tget workingCopies(): (IUntitledFileWorkingCopy<U> | IStoredFileWorkingCopy<S>)[] {\n\t\treturn [...this.stored.workingCopies, ...this.untitled.workingCopies];\n\t}\n\n\tget(resource: URI): IUntitledFileWorkingCopy<U> | IStoredFileWorkingCopy<S> | undefined {\n\t\treturn this.stored.get(resource) ?? this.untitled.get(resource);\n\t}\n\n\t//#endregion\n\n\t//#region resolve\n\n\tresolve(options?: INewUntitledFileWorkingCopyOptions): Promise<IUntitledFileWorkingCopy<U>>;\n\tresolve(options?: INewUntitledFileWorkingCopyWithAssociatedResourceOptions): Promise<IUntitledFileWorkingCopy<U>>;\n\tresolve(options?: INewOrExistingUntitledFileWorkingCopyOptions): Promise<IUntitledFileWorkingCopy<U>>;\n\tresolve(resource: URI, options?: IStoredFileWorkingCopyResolveOptions): Promise<IStoredFileWorkingCopy<S>>;\n\tresolve(arg1?: URI | INewUntitledFileWorkingCopyOptions | INewUntitledFileWorkingCopyWithAssociatedResourceOptions | INewOrExistingUntitledFileWorkingCopyOptions, arg2?: IStoredFileWorkingCopyResolveOptions): Promise<IUntitledFileWorkingCopy<U> | IStoredFileWorkingCopy<S>> {\n\t\tif (URI.isUri(arg1)) {\n\n\t\t\t// Untitled: via untitled manager\n\t\t\tif (arg1.scheme === Schemas.untitled) {\n\t\t\t\treturn this.untitled.resolve({ untitledResource: arg1 });\n\t\t\t}\n\n\t\t\t// else: via stored file manager\n\t\t\telse {\n\t\t\t\treturn this.stored.resolve(arg1, arg2);\n\t\t\t}\n\t\t}\n\n\t\treturn this.untitled.resolve(arg1);\n\t}\n\n\t//#endregion\n\n\t//#region Save\n\n\tasync saveAs(source: URI, target?: URI, options?: IFileWorkingCopySaveAsOptions): Promise<IStoredFileWorkingCopy<S> | undefined> {\n\n\t\t// Get to target resource\n\t\tif (!target) {\n\t\t\tconst workingCopy = this.get(source);\n\t\t\tif (workingCopy instanceof UntitledFileWorkingCopy && workingCopy.hasAssociatedFilePath) {\n\t\t\t\ttarget = await this.suggestSavePath(source);\n\t\t\t} else {\n\t\t\t\ttarget = await this.fileDialogService.pickFileToSave(await this.suggestSavePath(options?.suggestedTarget ?? source), options?.availableFileSystems);\n\t\t\t}\n\t\t}\n\n\t\tif (!target) {\n\t\t\treturn; // user canceled\n\t\t}\n\n\t\t// Ensure target is not marked as readonly and prompt otherwise\n\t\tif (this.filesConfigurationService.isReadonly(target)) {\n\t\t\tconst confirmed = await this.confirmMakeWriteable(target);\n\t\t\tif (!confirmed) {\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tthis.filesConfigurationService.updateReadonly(target, false);\n\t\t\t}\n\t\t}\n\n\t\t// Just save if target is same as working copies own resource\n\t\t// and we are not saving an untitled file working copy\n\t\tif (this.fileService.hasProvider(source) && isEqual(source, target)) {\n\t\t\treturn this.doSave(source, { ...options, force: true  /* force to save, even if not dirty (https://github.com/microsoft/vscode/issues/99619) */ });\n\t\t}\n\n\t\t// If the target is different but of same identity, we\n\t\t// move the source to the target, knowing that the\n\t\t// underlying file system cannot have both and then save.\n\t\t// However, this will only work if the source exists\n\t\t// and is not orphaned, so we need to check that too.\n\t\tif (this.fileService.hasProvider(source) && this.uriIdentityService.extUri.isEqual(source, target) && (await this.fileService.exists(source))) {\n\n\t\t\t// Move via working copy file service to enable participants\n\t\t\tawait this.workingCopyFileService.move([{ file: { source, target } }], CancellationToken.None);\n\n\t\t\t// At this point we don't know whether we have a\n\t\t\t// working copy for the source or the target URI so we\n\t\t\t// simply try to save with both resources.\n\t\t\treturn (await this.doSave(source, options)) ?? (await this.doSave(target, options));\n\t\t}\n\n\t\t// Perform normal \"Save As\"\n\t\treturn this.doSaveAs(source, target, options);\n\t}\n\n\tprivate async doSave(resource: URI, options?: ISaveOptions): Promise<IStoredFileWorkingCopy<S> | undefined> {\n\n\t\t// Save is only possible with stored file working copies,\n\t\t// any other have to go via `saveAs` flow.\n\t\tconst storedFileWorkingCopy = this.stored.get(resource);\n\t\tif (storedFileWorkingCopy) {\n\t\t\tconst success = await storedFileWorkingCopy.save(options);\n\t\t\tif (success) {\n\t\t\t\treturn storedFileWorkingCopy;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate async doSaveAs(source: URI, target: URI, options?: IFileWorkingCopySaveAsOptions): Promise<IStoredFileWorkingCopy<S> | undefined> {\n\t\tlet sourceContents: VSBufferReadableStream;\n\n\t\t// If the source is an existing file working copy, we can directly\n\t\t// use that to copy the contents to the target destination\n\t\tconst sourceWorkingCopy = this.get(source);\n\t\tif (sourceWorkingCopy?.isResolved()) {\n\t\t\tsourceContents = await sourceWorkingCopy.model.snapshot(SnapshotContext.Save, CancellationToken.None);\n\t\t}\n\n\t\t// Otherwise we resolve the contents from the underlying file\n\t\telse {\n\t\t\tsourceContents = (await this.fileService.readFileStream(source)).value;\n\t\t}\n\n\t\t// Resolve target\n\t\tconst { targetFileExists, targetStoredFileWorkingCopy } = await this.doResolveSaveTarget(source, target);\n\n\t\t// Confirm to overwrite if we have an untitled file working copy with associated path where\n\t\t// the file actually exists on disk and we are instructed to save to that file path.\n\t\t// This can happen if the file was created after the untitled file was opened.\n\t\t// See https://github.com/microsoft/vscode/issues/67946\n\t\tif (\n\t\t\tsourceWorkingCopy instanceof UntitledFileWorkingCopy &&\n\t\t\tsourceWorkingCopy.hasAssociatedFilePath &&\n\t\t\ttargetFileExists &&\n\t\t\tthis.uriIdentityService.extUri.isEqual(target, toLocalResource(sourceWorkingCopy.resource, this.environmentService.remoteAuthority, this.pathService.defaultUriScheme))\n\t\t) {\n\t\t\tconst overwrite = await this.confirmOverwrite(target);\n\t\t\tif (!overwrite) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\n\t\t// Take over content from source to target\n\t\tawait targetStoredFileWorkingCopy.model?.update(sourceContents, CancellationToken.None);\n\n\t\t// Set source options depending on target exists or not\n\t\tif (!options?.source) {\n\t\t\toptions = {\n\t\t\t\t...options,\n\t\t\t\tsource: targetFileExists ? FileWorkingCopyManager.FILE_WORKING_COPY_SAVE_REPLACE_SOURCE : FileWorkingCopyManager.FILE_WORKING_COPY_SAVE_CREATE_SOURCE\n\t\t\t};\n\t\t}\n\n\t\t// Save target\n\t\tconst success = await targetStoredFileWorkingCopy.save({\n\t\t\t...options,\n\t\t\tfrom: source,\n\t\t\tforce: true  /* force to save, even if not dirty (https://github.com/microsoft/vscode/issues/99619) */\n\t\t});\n\t\tif (!success) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Revert the source\n\t\ttry {\n\t\t\tawait sourceWorkingCopy?.revert();\n\t\t} catch (error) {\n\n\t\t\t// It is possible that reverting the source fails, for example\n\t\t\t// when a remote is disconnected and we cannot read it anymore.\n\t\t\t// However, this should not interrupt the \"Save As\" flow, so\n\t\t\t// we gracefully catch the error and just log it.\n\n\t\t\tthis.logService.error(error);\n\t\t}\n\n\t\treturn targetStoredFileWorkingCopy;\n\t}\n\n\tprivate async doResolveSaveTarget(source: URI, target: URI): Promise<{ targetFileExists: boolean; targetStoredFileWorkingCopy: IStoredFileWorkingCopy<S> }> {\n\n\t\t// Prefer an existing stored file working copy if it is already resolved\n\t\t// for the given target resource\n\t\tlet targetFileExists = false;\n\t\tlet targetStoredFileWorkingCopy = this.stored.get(target);\n\t\tif (targetStoredFileWorkingCopy?.isResolved()) {\n\t\t\ttargetFileExists = true;\n\t\t}\n\n\t\t// Otherwise create the target working copy empty if\n\t\t// it does not exist already and resolve it from there\n\t\telse {\n\t\t\ttargetFileExists = await this.fileService.exists(target);\n\n\t\t\t// Create target file adhoc if it does not exist yet\n\t\t\tif (!targetFileExists) {\n\t\t\t\tawait this.workingCopyFileService.create([{ resource: target }], CancellationToken.None);\n\t\t\t}\n\n\t\t\t// At this point we need to resolve the target working copy\n\t\t\t// and we have to do an explicit check if the source URI\n\t\t\t// equals the target via URI identity. If they match and we\n\t\t\t// have had an existing working copy with the source, we\n\t\t\t// prefer that one over resolving the target. Otherwise we\n\t\t\t// would potentially introduce a\n\t\t\tif (this.uriIdentityService.extUri.isEqual(source, target) && this.get(source)) {\n\t\t\t\ttargetStoredFileWorkingCopy = await this.stored.resolve(source);\n\t\t\t} else {\n\t\t\t\ttargetStoredFileWorkingCopy = await this.stored.resolve(target);\n\t\t\t}\n\t\t}\n\n\t\treturn { targetFileExists, targetStoredFileWorkingCopy };\n\t}\n\n\tprivate async confirmOverwrite(resource: URI): Promise<boolean> {\n\t\tconst { confirmed } = await this.dialogService.confirm({\n\t\t\ttype: 'warning',\n\t\t\tmessage: localize('confirmOverwrite', \"'{0}' already exists. Do you want to replace it?\", basename(resource)),\n\t\t\tdetail: localize('overwriteIrreversible', \"A file or folder with the name '{0}' already exists in the folder '{1}'. Replacing it will overwrite its current contents.\", basename(resource), basename(dirname(resource))),\n\t\t\tprimaryButton: localize({ key: 'replaceButtonLabel', comment: ['&& denotes a mnemonic'] }, \"&&Replace\")\n\t\t});\n\n\t\treturn confirmed;\n\t}\n\n\tprivate async confirmMakeWriteable(resource: URI): Promise<boolean> {\n\t\tconst { confirmed } = await this.dialogService.confirm({\n\t\t\ttype: 'warning',\n\t\t\tmessage: localize('confirmMakeWriteable', \"'{0}' is marked as read-only. Do you want to save anyway?\", basename(resource)),\n\t\t\tdetail: localize('confirmMakeWriteableDetail', \"Paths can be configured as read-only via settings.\"),\n\t\t\tprimaryButton: localize({ key: 'makeWriteableButtonLabel', comment: ['&& denotes a mnemonic'] }, \"&&Save Anyway\")\n\t\t});\n\n\t\treturn confirmed;\n\t}\n\n\tprivate async suggestSavePath(resource: URI): Promise<URI> {\n\n\t\t// 1.) Just take the resource as is if the file service can handle it\n\t\tif (this.fileService.hasProvider(resource)) {\n\t\t\treturn resource;\n\t\t}\n\n\t\t// 2.) Pick the associated file path for untitled working copies if any\n\t\tconst workingCopy = this.get(resource);\n\t\tif (workingCopy instanceof UntitledFileWorkingCopy && workingCopy.hasAssociatedFilePath) {\n\t\t\treturn toLocalResource(resource, this.environmentService.remoteAuthority, this.pathService.defaultUriScheme);\n\t\t}\n\n\t\tconst defaultFilePath = await this.fileDialogService.defaultFilePath();\n\n\t\t// 3.) Pick the working copy name if valid joined with default path\n\t\tif (workingCopy) {\n\t\t\tconst candidatePath = joinPath(defaultFilePath, workingCopy.name);\n\t\t\tif (await this.pathService.hasValidBasename(candidatePath, workingCopy.name)) {\n\t\t\t\treturn candidatePath;\n\t\t\t}\n\t\t}\n\n\t\t// 4.) Finally fallback to the name of the resource joined with default path\n\t\treturn joinPath(defaultFilePath, basename(resource));\n\t}\n\n\t//#endregion\n\n\t//#region Lifecycle\n\n\tasync destroy(): Promise<void> {\n\t\tawait Promises.settled([\n\t\t\tthis.stored.destroy(),\n\t\t\tthis.untitled.destroy()\n\t\t]);\n\t}\n\n\t//#endregion\n}\n"],
  "mappings": "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",
  "names": []
}
