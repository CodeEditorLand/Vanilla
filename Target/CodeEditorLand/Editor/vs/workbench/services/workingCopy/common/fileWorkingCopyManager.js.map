{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/workingCopy/common/fileWorkingCopyManager.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Promises } from \"../../../../base/common/async.js\";\nimport type { VSBufferReadableStream } from \"../../../../base/common/buffer.js\";\nimport { CancellationToken } from \"../../../../base/common/cancellation.js\";\nimport { Codicon } from \"../../../../base/common/codicons.js\";\nimport { Emitter, Event } from \"../../../../base/common/event.js\";\nimport { Disposable } from \"../../../../base/common/lifecycle.js\";\nimport { Schemas } from \"../../../../base/common/network.js\";\nimport {\n\tbasename,\n\tdirname,\n\tisEqual,\n\tjoinPath,\n\ttoLocalResource,\n} from \"../../../../base/common/resources.js\";\nimport { URI } from \"../../../../base/common/uri.js\";\nimport { localize } from \"../../../../nls.js\";\nimport {\n\tIDialogService,\n\tIFileDialogService,\n} from \"../../../../platform/dialogs/common/dialogs.js\";\nimport { IFileService } from \"../../../../platform/files/common/files.js\";\nimport { ILabelService } from \"../../../../platform/label/common/label.js\";\nimport { ILogService } from \"../../../../platform/log/common/log.js\";\nimport { INotificationService } from \"../../../../platform/notification/common/notification.js\";\nimport { IProgressService } from \"../../../../platform/progress/common/progress.js\";\nimport { listErrorForeground } from \"../../../../platform/theme/common/colorRegistry.js\";\nimport { IUriIdentityService } from \"../../../../platform/uriIdentity/common/uriIdentity.js\";\nimport {\n\ttype ISaveOptions,\n\tSaveSourceRegistry,\n} from \"../../../common/editor.js\";\nimport {\n\ttype IDecorationData,\n\ttype IDecorationsProvider,\n\tIDecorationsService,\n} from \"../../decorations/common/decorations.js\";\nimport { IEditorService } from \"../../editor/common/editorService.js\";\nimport { IWorkbenchEnvironmentService } from \"../../environment/common/environmentService.js\";\nimport { IElevatedFileService } from \"../../files/common/elevatedFileService.js\";\nimport { IFilesConfigurationService } from \"../../filesConfiguration/common/filesConfigurationService.js\";\nimport { ILifecycleService } from \"../../lifecycle/common/lifecycle.js\";\nimport { IPathService } from \"../../path/common/pathService.js\";\nimport type { IBaseFileWorkingCopyManager } from \"./abstractFileWorkingCopyManager.js\";\nimport { type IFileWorkingCopy, SnapshotContext } from \"./fileWorkingCopy.js\";\nimport {\n\ttype IStoredFileWorkingCopy,\n\ttype IStoredFileWorkingCopyModel,\n\ttype IStoredFileWorkingCopyModelFactory,\n\ttype IStoredFileWorkingCopyResolveOptions,\n\tStoredFileWorkingCopyState,\n} from \"./storedFileWorkingCopy.js\";\nimport {\n\ttype IStoredFileWorkingCopyManager,\n\ttype IStoredFileWorkingCopyManagerResolveOptions,\n\tStoredFileWorkingCopyManager,\n} from \"./storedFileWorkingCopyManager.js\";\nimport {\n\ttype IUntitledFileWorkingCopy,\n\ttype IUntitledFileWorkingCopyModel,\n\ttype IUntitledFileWorkingCopyModelFactory,\n\tUntitledFileWorkingCopy,\n} from \"./untitledFileWorkingCopy.js\";\nimport {\n\ttype INewOrExistingUntitledFileWorkingCopyOptions,\n\ttype INewUntitledFileWorkingCopyOptions,\n\ttype INewUntitledFileWorkingCopyWithAssociatedResourceOptions,\n\ttype IUntitledFileWorkingCopyManager,\n\tUntitledFileWorkingCopyManager,\n} from \"./untitledFileWorkingCopyManager.js\";\nimport { IWorkingCopyBackupService } from \"./workingCopyBackup.js\";\nimport { IWorkingCopyEditorService } from \"./workingCopyEditorService.js\";\nimport { IWorkingCopyFileService } from \"./workingCopyFileService.js\";\nimport { IWorkingCopyService } from \"./workingCopyService.js\";\n\nexport interface IFileWorkingCopyManager<\n\tS extends IStoredFileWorkingCopyModel,\n\tU extends IUntitledFileWorkingCopyModel,\n> extends IBaseFileWorkingCopyManager<S | U, IFileWorkingCopy<S | U>> {\n\t/**\n\t * Provides access to the manager for stored file working copies.\n\t */\n\treadonly stored: IStoredFileWorkingCopyManager<S>;\n\n\t/**\n\t * Provides access to the manager for untitled file working copies.\n\t */\n\treadonly untitled: IUntitledFileWorkingCopyManager<U>;\n\n\t/**\n\t * Allows to resolve a stored file working copy. If the manager already knows\n\t * about a stored file working copy with the same `URI`, it will return that\n\t * existing stored file working copy. There will never be more than one\n\t * stored file working copy per `URI` until the stored file working copy is\n\t * disposed.\n\t *\n\t * Use the `IStoredFileWorkingCopyResolveOptions.reload` option to control the\n\t * behaviour for when a stored file working copy was previously already resolved\n\t * with regards to resolving it again from the underlying file resource\n\t * or not.\n\t *\n\t * Note: Callers must `dispose` the working copy when no longer needed.\n\t *\n\t * @param resource used as unique identifier of the stored file working copy in\n\t * case one is already known for this `URI`.\n\t * @param options\n\t */\n\tresolve(\n\t\tresource: URI,\n\t\toptions?: IStoredFileWorkingCopyManagerResolveOptions,\n\t): Promise<IStoredFileWorkingCopy<S>>;\n\n\t/**\n\t * Create a new untitled file working copy with optional initial contents.\n\t *\n\t * Note: Callers must `dispose` the working copy when no longer needed.\n\t */\n\tresolve(\n\t\toptions?: INewUntitledFileWorkingCopyOptions,\n\t): Promise<IUntitledFileWorkingCopy<U>>;\n\n\t/**\n\t * Create a new untitled file working copy with optional initial contents\n\t * and associated resource. The associated resource will be used when\n\t * saving and will not require to ask the user for a file path.\n\t *\n\t * Note: Callers must `dispose` the working copy when no longer needed.\n\t */\n\tresolve(\n\t\toptions?: INewUntitledFileWorkingCopyWithAssociatedResourceOptions,\n\t): Promise<IUntitledFileWorkingCopy<U>>;\n\n\t/**\n\t * Creates a new untitled file working copy with optional initial contents\n\t * with the provided resource or return an existing untitled file working\n\t * copy otherwise.\n\t *\n\t * Note: Callers must `dispose` the working copy when no longer needed.\n\t */\n\tresolve(\n\t\toptions?: INewOrExistingUntitledFileWorkingCopyOptions,\n\t): Promise<IUntitledFileWorkingCopy<U>>;\n\n\t/**\n\t * Implements \"Save As\" for file based working copies. The API is `URI` based\n\t * because it works even without resolved file working copies. If a file working\n\t * copy exists for any given `URI`, the implementation will deal with them properly\n\t * (e.g. dirty contents of the source will be written to the target and the source\n\t * will be reverted).\n\t *\n\t * Note: it is possible that the returned file working copy has a different `URI`\n\t * than the `target` that was passed in. Based on URI identity, the file working\n\t * copy may chose to return an existing file working copy with different casing\n\t * to respect file systems that are case insensitive.\n\t *\n\t * Note: Callers must `dispose` the working copy when no longer needed.\n\t *\n\t * Note: Untitled file working copies are being disposed when saved.\n\t *\n\t * @param source the source resource to save as\n\t * @param target the optional target resource to save to. if not defined, the user\n\t * will be asked for input\n\t * @returns the target stored working copy that was saved to or `undefined` in case of\n\t * cancellation\n\t */\n\tsaveAs(\n\t\tsource: URI,\n\t\ttarget: URI,\n\t\toptions?: ISaveOptions,\n\t): Promise<IStoredFileWorkingCopy<S> | undefined>;\n\tsaveAs(\n\t\tsource: URI,\n\t\ttarget: undefined,\n\t\toptions?: IFileWorkingCopySaveAsOptions,\n\t): Promise<IStoredFileWorkingCopy<S> | undefined>;\n}\n\nexport interface IFileWorkingCopySaveAsOptions extends ISaveOptions {\n\t/**\n\t * Optional target resource to suggest to the user in case\n\t * no target resource is provided to save to.\n\t */\n\tsuggestedTarget?: URI;\n}\n\nexport class FileWorkingCopyManager<\n\t\tS extends IStoredFileWorkingCopyModel,\n\t\tU extends IUntitledFileWorkingCopyModel,\n\t>\n\textends Disposable\n\timplements IFileWorkingCopyManager<S, U>\n{\n\treadonly onDidCreate: Event<IFileWorkingCopy<S | U>>;\n\n\tprivate static readonly FILE_WORKING_COPY_SAVE_CREATE_SOURCE =\n\t\tSaveSourceRegistry.registerSource(\n\t\t\t\"fileWorkingCopyCreate.source\",\n\t\t\tlocalize(\"fileWorkingCopyCreate.source\", \"File Created\"),\n\t\t);\n\tprivate static readonly FILE_WORKING_COPY_SAVE_REPLACE_SOURCE =\n\t\tSaveSourceRegistry.registerSource(\n\t\t\t\"fileWorkingCopyReplace.source\",\n\t\t\tlocalize(\"fileWorkingCopyReplace.source\", \"File Replaced\"),\n\t\t);\n\n\treadonly stored: IStoredFileWorkingCopyManager<S>;\n\treadonly untitled: IUntitledFileWorkingCopyManager<U>;\n\n\tconstructor(\n\t\tprivate readonly workingCopyTypeId: string,\n\t\tprivate readonly storedWorkingCopyModelFactory: IStoredFileWorkingCopyModelFactory<S>,\n\t\tprivate readonly untitledWorkingCopyModelFactory: IUntitledFileWorkingCopyModelFactory<U>,\n\t\t@IFileService private readonly fileService: IFileService,\n\t\t@ILifecycleService lifecycleService: ILifecycleService,\n\t\t@ILabelService labelService: ILabelService,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IWorkingCopyFileService\n\t\tprivate readonly workingCopyFileService: IWorkingCopyFileService,\n\t\t@IWorkingCopyBackupService\n\t\tworkingCopyBackupService: IWorkingCopyBackupService,\n\t\t@IUriIdentityService\n\t\tprivate readonly uriIdentityService: IUriIdentityService,\n\t\t@IFileDialogService\n\t\tprivate readonly fileDialogService: IFileDialogService,\n\t\t@IFilesConfigurationService\n\t\tprivate readonly filesConfigurationService: IFilesConfigurationService,\n\t\t@IWorkingCopyService workingCopyService: IWorkingCopyService,\n\t\t@INotificationService notificationService: INotificationService,\n\t\t@IWorkingCopyEditorService\n\t\tworkingCopyEditorService: IWorkingCopyEditorService,\n\t\t@IEditorService editorService: IEditorService,\n\t\t@IElevatedFileService elevatedFileService: IElevatedFileService,\n\t\t@IPathService private readonly pathService: IPathService,\n\t\t@IWorkbenchEnvironmentService\n\t\tprivate readonly environmentService: IWorkbenchEnvironmentService,\n\t\t@IDialogService private readonly dialogService: IDialogService,\n\t\t@IDecorationsService\n\t\tprivate readonly decorationsService: IDecorationsService,\n\t\t@IProgressService progressService: IProgressService,\n\t) {\n\t\tsuper();\n\n\t\t// Stored file working copies manager\n\t\tthis.stored = this._register(\n\t\t\tnew StoredFileWorkingCopyManager(\n\t\t\t\tthis.workingCopyTypeId,\n\t\t\t\tthis.storedWorkingCopyModelFactory,\n\t\t\t\tfileService,\n\t\t\t\tlifecycleService,\n\t\t\t\tlabelService,\n\t\t\t\tlogService,\n\t\t\t\tworkingCopyFileService,\n\t\t\t\tworkingCopyBackupService,\n\t\t\t\turiIdentityService,\n\t\t\t\tfilesConfigurationService,\n\t\t\t\tworkingCopyService,\n\t\t\t\tnotificationService,\n\t\t\t\tworkingCopyEditorService,\n\t\t\t\teditorService,\n\t\t\t\televatedFileService,\n\t\t\t\tprogressService,\n\t\t\t),\n\t\t);\n\n\t\t// Untitled file working copies manager\n\t\tthis.untitled = this._register(\n\t\t\tnew UntitledFileWorkingCopyManager(\n\t\t\t\tthis.workingCopyTypeId,\n\t\t\t\tthis.untitledWorkingCopyModelFactory,\n\t\t\t\tasync (workingCopy, options) => {\n\t\t\t\t\tconst result = await this.saveAs(\n\t\t\t\t\t\tworkingCopy.resource,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\toptions,\n\t\t\t\t\t);\n\n\t\t\t\t\treturn result ? true : false;\n\t\t\t\t},\n\t\t\t\tfileService,\n\t\t\t\tlabelService,\n\t\t\t\tlogService,\n\t\t\t\tworkingCopyBackupService,\n\t\t\t\tworkingCopyService,\n\t\t\t),\n\t\t);\n\n\t\t// Events\n\t\tthis.onDidCreate = Event.any<IFileWorkingCopy<S | U>>(\n\t\t\tthis.stored.onDidCreate,\n\t\t\tthis.untitled.onDidCreate,\n\t\t);\n\n\t\t// Decorations\n\t\tthis.provideDecorations();\n\t}\n\n\t//#region decorations\n\n\tprivate provideDecorations(): void {\n\t\t// File working copy decorations\n\t\tconst provider = this._register(\n\t\t\tnew (class extends Disposable implements IDecorationsProvider {\n\t\t\t\treadonly label = localize(\n\t\t\t\t\t\"fileWorkingCopyDecorations\",\n\t\t\t\t\t\"File Working Copy Decorations\",\n\t\t\t\t);\n\n\t\t\t\tprivate readonly _onDidChange = this._register(\n\t\t\t\t\tnew Emitter<URI[]>(),\n\t\t\t\t);\n\t\t\t\treadonly onDidChange = this._onDidChange.event;\n\n\t\t\t\tconstructor(\n\t\t\t\t\tprivate readonly stored: IStoredFileWorkingCopyManager<S>,\n\t\t\t\t) {\n\t\t\t\t\tsuper();\n\n\t\t\t\t\tthis.registerListeners();\n\t\t\t\t}\n\n\t\t\t\tprivate registerListeners(): void {\n\t\t\t\t\t// Creates\n\t\t\t\t\tthis._register(\n\t\t\t\t\t\tthis.stored.onDidResolve((workingCopy) => {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tworkingCopy.isReadonly() ||\n\t\t\t\t\t\t\t\tworkingCopy.hasState(\n\t\t\t\t\t\t\t\t\tStoredFileWorkingCopyState.ORPHAN,\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tthis._onDidChange.fire([workingCopy.resource]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\n\t\t\t\t\t// Removals: once a stored working copy is no longer\n\t\t\t\t\t// under our control, make sure to signal this as\n\t\t\t\t\t// decoration change because from this point on we\n\t\t\t\t\t// have no way of updating the decoration anymore.\n\t\t\t\t\tthis._register(\n\t\t\t\t\t\tthis.stored.onDidRemove((workingCopyUri) =>\n\t\t\t\t\t\t\tthis._onDidChange.fire([workingCopyUri]),\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\n\t\t\t\t\t// Changes\n\t\t\t\t\tthis._register(\n\t\t\t\t\t\tthis.stored.onDidChangeReadonly((workingCopy) =>\n\t\t\t\t\t\t\tthis._onDidChange.fire([workingCopy.resource]),\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t\tthis._register(\n\t\t\t\t\t\tthis.stored.onDidChangeOrphaned((workingCopy) =>\n\t\t\t\t\t\t\tthis._onDidChange.fire([workingCopy.resource]),\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tprovideDecorations(uri: URI): IDecorationData | undefined {\n\t\t\t\t\tconst workingCopy = this.stored.get(uri);\n\t\t\t\t\tif (!workingCopy || workingCopy.isDisposed()) {\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst isReadonly = workingCopy.isReadonly();\n\t\t\t\t\tconst isOrphaned = workingCopy.hasState(\n\t\t\t\t\t\tStoredFileWorkingCopyState.ORPHAN,\n\t\t\t\t\t);\n\n\t\t\t\t\t// Readonly + Orphaned\n\t\t\t\t\tif (isReadonly && isOrphaned) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tcolor: listErrorForeground,\n\t\t\t\t\t\t\tletter: Codicon.lockSmall,\n\t\t\t\t\t\t\tstrikethrough: true,\n\t\t\t\t\t\t\ttooltip: localize(\n\t\t\t\t\t\t\t\t\"readonlyAndDeleted\",\n\t\t\t\t\t\t\t\t\"Deleted, Read-only\",\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Readonly\n\t\t\t\t\telse if (isReadonly) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tletter: Codicon.lockSmall,\n\t\t\t\t\t\t\ttooltip: localize(\"readonly\", \"Read-only\"),\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Orphaned\n\t\t\t\t\telse if (isOrphaned) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tcolor: listErrorForeground,\n\t\t\t\t\t\t\tstrikethrough: true,\n\t\t\t\t\t\t\ttooltip: localize(\"deleted\", \"Deleted\"),\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t})(this.stored),\n\t\t);\n\n\t\tthis._register(\n\t\t\tthis.decorationsService.registerDecorationsProvider(provider),\n\t\t);\n\t}\n\n\t//#endregin\n\n\t//#region get / get all\n\n\tget workingCopies(): (\n\t\t| IUntitledFileWorkingCopy<U>\n\t\t| IStoredFileWorkingCopy<S>\n\t)[] {\n\t\treturn [...this.stored.workingCopies, ...this.untitled.workingCopies];\n\t}\n\n\tget(\n\t\tresource: URI,\n\t): IUntitledFileWorkingCopy<U> | IStoredFileWorkingCopy<S> | undefined {\n\t\treturn this.stored.get(resource) ?? this.untitled.get(resource);\n\t}\n\n\t//#endregion\n\n\t//#region resolve\n\n\tresolve(\n\t\toptions?: INewUntitledFileWorkingCopyOptions,\n\t): Promise<IUntitledFileWorkingCopy<U>>;\n\tresolve(\n\t\toptions?: INewUntitledFileWorkingCopyWithAssociatedResourceOptions,\n\t): Promise<IUntitledFileWorkingCopy<U>>;\n\tresolve(\n\t\toptions?: INewOrExistingUntitledFileWorkingCopyOptions,\n\t): Promise<IUntitledFileWorkingCopy<U>>;\n\tresolve(\n\t\tresource: URI,\n\t\toptions?: IStoredFileWorkingCopyResolveOptions,\n\t): Promise<IStoredFileWorkingCopy<S>>;\n\tresolve(\n\t\targ1?:\n\t\t\t| URI\n\t\t\t| INewUntitledFileWorkingCopyOptions\n\t\t\t| INewUntitledFileWorkingCopyWithAssociatedResourceOptions\n\t\t\t| INewOrExistingUntitledFileWorkingCopyOptions,\n\t\targ2?: IStoredFileWorkingCopyResolveOptions,\n\t): Promise<IUntitledFileWorkingCopy<U> | IStoredFileWorkingCopy<S>> {\n\t\tif (URI.isUri(arg1)) {\n\t\t\t// Untitled: via untitled manager\n\t\t\tif (arg1.scheme === Schemas.untitled) {\n\t\t\t\treturn this.untitled.resolve({ untitledResource: arg1 });\n\t\t\t}\n\n\t\t\t// else: via stored file manager\n\t\t\telse {\n\t\t\t\treturn this.stored.resolve(arg1, arg2);\n\t\t\t}\n\t\t}\n\n\t\treturn this.untitled.resolve(arg1);\n\t}\n\n\t//#endregion\n\n\t//#region Save\n\n\tasync saveAs(\n\t\tsource: URI,\n\t\ttarget?: URI,\n\t\toptions?: IFileWorkingCopySaveAsOptions,\n\t): Promise<IStoredFileWorkingCopy<S> | undefined> {\n\t\t// Get to target resource\n\t\tif (!target) {\n\t\t\tconst workingCopy = this.get(source);\n\t\t\tif (\n\t\t\t\tworkingCopy instanceof UntitledFileWorkingCopy &&\n\t\t\t\tworkingCopy.hasAssociatedFilePath\n\t\t\t) {\n\t\t\t\ttarget = await this.suggestSavePath(source);\n\t\t\t} else {\n\t\t\t\ttarget = await this.fileDialogService.pickFileToSave(\n\t\t\t\t\tawait this.suggestSavePath(\n\t\t\t\t\t\toptions?.suggestedTarget ?? source,\n\t\t\t\t\t),\n\t\t\t\t\toptions?.availableFileSystems,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tif (!target) {\n\t\t\treturn; // user canceled\n\t\t}\n\n\t\t// Ensure target is not marked as readonly and prompt otherwise\n\t\tif (this.filesConfigurationService.isReadonly(target)) {\n\t\t\tconst confirmed = await this.confirmMakeWriteable(target);\n\t\t\tif (confirmed) {\n\t\t\t\tthis.filesConfigurationService.updateReadonly(target, false);\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Just save if target is same as working copies own resource\n\t\t// and we are not saving an untitled file working copy\n\t\tif (this.fileService.hasProvider(source) && isEqual(source, target)) {\n\t\t\treturn this.doSave(source, {\n\t\t\t\t...options,\n\t\t\t\tforce: true /* force to save, even if not dirty (https://github.com/microsoft/vscode/issues/99619) */,\n\t\t\t});\n\t\t}\n\n\t\t// If the target is different but of same identity, we\n\t\t// move the source to the target, knowing that the\n\t\t// underlying file system cannot have both and then save.\n\t\t// However, this will only work if the source exists\n\t\t// and is not orphaned, so we need to check that too.\n\t\tif (\n\t\t\tthis.fileService.hasProvider(source) &&\n\t\t\tthis.uriIdentityService.extUri.isEqual(source, target) &&\n\t\t\t(await this.fileService.exists(source))\n\t\t) {\n\t\t\t// Move via working copy file service to enable participants\n\t\t\tawait this.workingCopyFileService.move(\n\t\t\t\t[{ file: { source, target } }],\n\t\t\t\tCancellationToken.None,\n\t\t\t);\n\n\t\t\t// At this point we don't know whether we have a\n\t\t\t// working copy for the source or the target URI so we\n\t\t\t// simply try to save with both resources.\n\t\t\treturn (\n\t\t\t\t(await this.doSave(source, options)) ??\n\t\t\t\t(await this.doSave(target, options))\n\t\t\t);\n\t\t}\n\n\t\t// Perform normal \"Save As\"\n\t\treturn this.doSaveAs(source, target, options);\n\t}\n\n\tprivate async doSave(\n\t\tresource: URI,\n\t\toptions?: ISaveOptions,\n\t): Promise<IStoredFileWorkingCopy<S> | undefined> {\n\t\t// Save is only possible with stored file working copies,\n\t\t// any other have to go via `saveAs` flow.\n\t\tconst storedFileWorkingCopy = this.stored.get(resource);\n\t\tif (storedFileWorkingCopy) {\n\t\t\tconst success = await storedFileWorkingCopy.save(options);\n\t\t\tif (success) {\n\t\t\t\treturn storedFileWorkingCopy;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate async doSaveAs(\n\t\tsource: URI,\n\t\ttarget: URI,\n\t\toptions?: IFileWorkingCopySaveAsOptions,\n\t): Promise<IStoredFileWorkingCopy<S> | undefined> {\n\t\tlet sourceContents: VSBufferReadableStream;\n\n\t\t// If the source is an existing file working copy, we can directly\n\t\t// use that to copy the contents to the target destination\n\t\tconst sourceWorkingCopy = this.get(source);\n\t\tif (sourceWorkingCopy?.isResolved()) {\n\t\t\tsourceContents = await sourceWorkingCopy.model.snapshot(\n\t\t\t\tSnapshotContext.Save,\n\t\t\t\tCancellationToken.None,\n\t\t\t);\n\t\t}\n\n\t\t// Otherwise we resolve the contents from the underlying file\n\t\telse {\n\t\t\tsourceContents = (await this.fileService.readFileStream(source))\n\t\t\t\t.value;\n\t\t}\n\n\t\t// Resolve target\n\t\tconst { targetFileExists, targetStoredFileWorkingCopy } =\n\t\t\tawait this.doResolveSaveTarget(source, target);\n\n\t\t// Confirm to overwrite if we have an untitled file working copy with associated path where\n\t\t// the file actually exists on disk and we are instructed to save to that file path.\n\t\t// This can happen if the file was created after the untitled file was opened.\n\t\t// See https://github.com/microsoft/vscode/issues/67946\n\t\tif (\n\t\t\tsourceWorkingCopy instanceof UntitledFileWorkingCopy &&\n\t\t\tsourceWorkingCopy.hasAssociatedFilePath &&\n\t\t\ttargetFileExists &&\n\t\t\tthis.uriIdentityService.extUri.isEqual(\n\t\t\t\ttarget,\n\t\t\t\ttoLocalResource(\n\t\t\t\t\tsourceWorkingCopy.resource,\n\t\t\t\t\tthis.environmentService.remoteAuthority,\n\t\t\t\t\tthis.pathService.defaultUriScheme,\n\t\t\t\t),\n\t\t\t)\n\t\t) {\n\t\t\tconst overwrite = await this.confirmOverwrite(target);\n\t\t\tif (!overwrite) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\n\t\t// Take over content from source to target\n\t\tawait targetStoredFileWorkingCopy.model?.update(\n\t\t\tsourceContents,\n\t\t\tCancellationToken.None,\n\t\t);\n\n\t\t// Set source options depending on target exists or not\n\t\tif (!options?.source) {\n\t\t\toptions = {\n\t\t\t\t...options,\n\t\t\t\tsource: targetFileExists\n\t\t\t\t\t? FileWorkingCopyManager.FILE_WORKING_COPY_SAVE_REPLACE_SOURCE\n\t\t\t\t\t: FileWorkingCopyManager.FILE_WORKING_COPY_SAVE_CREATE_SOURCE,\n\t\t\t};\n\t\t}\n\n\t\t// Save target\n\t\tconst success = await targetStoredFileWorkingCopy.save({\n\t\t\t...options,\n\t\t\tfrom: source,\n\t\t\tforce: true /* force to save, even if not dirty (https://github.com/microsoft/vscode/issues/99619) */,\n\t\t});\n\t\tif (!success) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Revert the source\n\t\ttry {\n\t\t\tawait sourceWorkingCopy?.revert();\n\t\t} catch (error) {\n\t\t\t// It is possible that reverting the source fails, for example\n\t\t\t// when a remote is disconnected and we cannot read it anymore.\n\t\t\t// However, this should not interrupt the \"Save As\" flow, so\n\t\t\t// we gracefully catch the error and just log it.\n\n\t\t\tthis.logService.error(error);\n\t\t}\n\n\t\treturn targetStoredFileWorkingCopy;\n\t}\n\n\tprivate async doResolveSaveTarget(\n\t\tsource: URI,\n\t\ttarget: URI,\n\t): Promise<{\n\t\ttargetFileExists: boolean;\n\t\ttargetStoredFileWorkingCopy: IStoredFileWorkingCopy<S>;\n\t}> {\n\t\t// Prefer an existing stored file working copy if it is already resolved\n\t\t// for the given target resource\n\t\tlet targetFileExists = false;\n\t\tlet targetStoredFileWorkingCopy = this.stored.get(target);\n\t\tif (targetStoredFileWorkingCopy?.isResolved()) {\n\t\t\ttargetFileExists = true;\n\t\t}\n\n\t\t// Otherwise create the target working copy empty if\n\t\t// it does not exist already and resolve it from there\n\t\telse {\n\t\t\ttargetFileExists = await this.fileService.exists(target);\n\n\t\t\t// Create target file adhoc if it does not exist yet\n\t\t\tif (!targetFileExists) {\n\t\t\t\tawait this.workingCopyFileService.create(\n\t\t\t\t\t[{ resource: target }],\n\t\t\t\t\tCancellationToken.None,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// At this point we need to resolve the target working copy\n\t\t\t// and we have to do an explicit check if the source URI\n\t\t\t// equals the target via URI identity. If they match and we\n\t\t\t// have had an existing working copy with the source, we\n\t\t\t// prefer that one over resolving the target. Otherwise we\n\t\t\t// would potentially introduce a\n\t\t\tif (\n\t\t\t\tthis.uriIdentityService.extUri.isEqual(source, target) &&\n\t\t\t\tthis.get(source)\n\t\t\t) {\n\t\t\t\ttargetStoredFileWorkingCopy = await this.stored.resolve(source);\n\t\t\t} else {\n\t\t\t\ttargetStoredFileWorkingCopy = await this.stored.resolve(target);\n\t\t\t}\n\t\t}\n\n\t\treturn { targetFileExists, targetStoredFileWorkingCopy };\n\t}\n\n\tprivate async confirmOverwrite(resource: URI): Promise<boolean> {\n\t\tconst { confirmed } = await this.dialogService.confirm({\n\t\t\ttype: \"warning\",\n\t\t\tmessage: localize(\n\t\t\t\t\"confirmOverwrite\",\n\t\t\t\t\"'{0}' already exists. Do you want to replace it?\",\n\t\t\t\tbasename(resource),\n\t\t\t),\n\t\t\tdetail: localize(\n\t\t\t\t\"overwriteIrreversible\",\n\t\t\t\t\"A file or folder with the name '{0}' already exists in the folder '{1}'. Replacing it will overwrite its current contents.\",\n\t\t\t\tbasename(resource),\n\t\t\t\tbasename(dirname(resource)),\n\t\t\t),\n\t\t\tprimaryButton: localize(\n\t\t\t\t{\n\t\t\t\t\tkey: \"replaceButtonLabel\",\n\t\t\t\t\tcomment: [\"&& denotes a mnemonic\"],\n\t\t\t\t},\n\t\t\t\t\"&&Replace\",\n\t\t\t),\n\t\t});\n\n\t\treturn confirmed;\n\t}\n\n\tprivate async confirmMakeWriteable(resource: URI): Promise<boolean> {\n\t\tconst { confirmed } = await this.dialogService.confirm({\n\t\t\ttype: \"warning\",\n\t\t\tmessage: localize(\n\t\t\t\t\"confirmMakeWriteable\",\n\t\t\t\t\"'{0}' is marked as read-only. Do you want to save anyway?\",\n\t\t\t\tbasename(resource),\n\t\t\t),\n\t\t\tdetail: localize(\n\t\t\t\t\"confirmMakeWriteableDetail\",\n\t\t\t\t\"Paths can be configured as read-only via settings.\",\n\t\t\t),\n\t\t\tprimaryButton: localize(\n\t\t\t\t{\n\t\t\t\t\tkey: \"makeWriteableButtonLabel\",\n\t\t\t\t\tcomment: [\"&& denotes a mnemonic\"],\n\t\t\t\t},\n\t\t\t\t\"&&Save Anyway\",\n\t\t\t),\n\t\t});\n\n\t\treturn confirmed;\n\t}\n\n\tprivate async suggestSavePath(resource: URI): Promise<URI> {\n\t\t// 1.) Just take the resource as is if the file service can handle it\n\t\tif (this.fileService.hasProvider(resource)) {\n\t\t\treturn resource;\n\t\t}\n\n\t\t// 2.) Pick the associated file path for untitled working copies if any\n\t\tconst workingCopy = this.get(resource);\n\t\tif (\n\t\t\tworkingCopy instanceof UntitledFileWorkingCopy &&\n\t\t\tworkingCopy.hasAssociatedFilePath\n\t\t) {\n\t\t\treturn toLocalResource(\n\t\t\t\tresource,\n\t\t\t\tthis.environmentService.remoteAuthority,\n\t\t\t\tthis.pathService.defaultUriScheme,\n\t\t\t);\n\t\t}\n\n\t\tconst defaultFilePath = await this.fileDialogService.defaultFilePath();\n\n\t\t// 3.) Pick the working copy name if valid joined with default path\n\t\tif (workingCopy) {\n\t\t\tconst candidatePath = joinPath(defaultFilePath, workingCopy.name);\n\t\t\tif (\n\t\t\t\tawait this.pathService.hasValidBasename(\n\t\t\t\t\tcandidatePath,\n\t\t\t\t\tworkingCopy.name,\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\treturn candidatePath;\n\t\t\t}\n\t\t}\n\n\t\t// 4.) Finally fallback to the name of the resource joined with default path\n\t\treturn joinPath(defaultFilePath, basename(resource));\n\t}\n\n\t//#endregion\n\n\t//#region Lifecycle\n\n\tasync destroy(): Promise<void> {\n\t\tawait Promises.settled([\n\t\t\tthis.stored.destroy(),\n\t\t\tthis.untitled.destroy(),\n\t\t]);\n\t}\n\n\t//#endregion\n}\n"],
  "mappings": "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",
  "names": []
}
