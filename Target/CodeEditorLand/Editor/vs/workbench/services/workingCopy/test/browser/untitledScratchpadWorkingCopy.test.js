import t from"assert";import{VSBuffer as u,streamToBuffer as f,bufferToStream as g,readableToBuffer as k}from"../../../../../base/common/buffer.js";import{CancellationToken as c}from"../../../../../base/common/cancellation.js";import{DisposableStore as y}from"../../../../../base/common/lifecycle.js";import{Schemas as v}from"../../../../../base/common/network.js";import{basename as w}from"../../../../../base/common/resources.js";import{consumeReadable as E,consumeStream as q,isReadable as h,isReadableStream as m}from"../../../../../base/common/stream.js";import{URI as S}from"../../../../../base/common/uri.js";import{ensureNoDisposablesAreLeakedInTestSuite as b}from"../../../../../base/test/common/utils.js";import"../../../../../platform/instantiation/common/instantiation.js";import{UntitledFileWorkingCopy as M}from"../../common/untitledFileWorkingCopy.js";import{TestUntitledFileWorkingCopyModel as I}from"./untitledFileWorkingCopy.test.js";import{TestServiceAccessor as B,workbenchInstantiationService as U}from"../../../../test/browser/workbenchTestServices.js";class F{async createModel(a,n,d){return new I(a,(await f(n)).toString())}}suite("UntitledScratchpadWorkingCopy",()=>{const p=new F,a=new y,n=S.from({scheme:v.untitled,path:"Untitled-1"});let d,s,e;function r(i=n,o=!1,l=""){return a.add(new M("testUntitledWorkingCopyType",i,w(i),o,!0,l.length>0?{value:g(u.fromString(l))}:void 0,p,async C=>(await C.revert(),!0),s.workingCopyService,s.workingCopyBackupService,s.logService))}setup(()=>{d=U(void 0,a),s=d.createInstance(B),e=a.add(r())}),teardown(()=>{a.clear()}),test("registers with working copy service",async()=>{t.strictEqual(s.workingCopyService.workingCopies.length,1),e.dispose(),t.strictEqual(s.workingCopyService.workingCopies.length,0)}),test("modified - not dirty",async()=>{t.strictEqual(e.isDirty(),!1);let i=0;a.add(e.onDidChangeDirty(()=>{i++}));let o=0;a.add(e.onDidChangeContent(()=>{o++})),await e.resolve(),t.strictEqual(e.isResolved(),!0),e.model?.updateContents("hello modified"),t.strictEqual(o,1),t.strictEqual(e.isDirty(),!1),t.strictEqual(e.isModified(),!0),t.strictEqual(i,0),await e.save(),t.strictEqual(e.isDirty(),!1),t.strictEqual(i,0)}),test("modified - cleared when content event signals isEmpty",async()=>{t.strictEqual(e.isModified(),!1),await e.resolve(),e.model?.updateContents("hello modified"),t.strictEqual(e.isModified(),!0),e.model?.fireContentChangeEvent({isInitial:!0}),t.strictEqual(e.isModified(),!1)}),test("modified - not cleared when content event signals isEmpty when associated resource",async()=>{e.dispose(),e=r(n,!0),await e.resolve(),e.model?.updateContents("hello modified"),t.strictEqual(e.isModified(),!0),e.model?.fireContentChangeEvent({isInitial:!0}),t.strictEqual(e.isModified(),!0)}),test("revert",async()=>{let i=0;a.add(e.onDidRevert(()=>{i++}));let o=0;a.add(e.onWillDispose(()=>{o++})),await e.resolve(),e.model?.updateContents("hello modified"),t.strictEqual(e.isModified(),!0),await e.revert(),t.strictEqual(i,1),t.strictEqual(o,1),t.strictEqual(e.isModified(),!1)}),test("dispose",async()=>{let i=0;a.add(e.onWillDispose(()=>{i++})),await e.resolve(),e.dispose(),t.strictEqual(i,1)}),test("backup",async()=>{t.strictEqual((await e.backup(c.None)).content,void 0),await e.resolve(),e.model?.updateContents("Hello Backup");const i=await e.backup(c.None);let o;m(i.content)?o=(await q(i.content,l=>u.concat(l))).toString():i.content&&(o=E(i.content,l=>u.concat(l)).toString()),t.strictEqual(o,"Hello Backup")}),test("resolve - without contents",async()=>{t.strictEqual(e.isResolved(),!1),t.strictEqual(e.hasAssociatedFilePath,!1),t.strictEqual(e.model,void 0),await e.resolve(),t.strictEqual(e.isResolved(),!0),t.ok(e.model)}),test("resolve - with initial contents",async()=>{e.dispose(),e=r(n,!1,"Hello Initial");let i=0;a.add(e.onDidChangeContent(()=>{i++})),t.strictEqual(e.isModified(),!0),await e.resolve(),t.strictEqual(e.isModified(),!0),t.strictEqual(e.model?.contents,"Hello Initial"),t.strictEqual(i,1),e.model.updateContents("Changed contents"),await e.resolve(),t.strictEqual(e.model?.contents,"Changed contents")}),test("backup - with initial contents uses those even if unresolved",async()=>{e.dispose(),e=r(n,!1,"Hello Initial"),t.strictEqual(e.isModified(),!0);const i=(await e.backup(c.None)).content;if(m(i)){const o=await f(i);t.strictEqual(o.toString(),"Hello Initial")}else if(h(i)){const o=k(i);t.strictEqual(o.toString(),"Hello Initial")}else t.fail("Missing untitled backup")}),test("resolve - with associated resource",async()=>{e.dispose(),e=r(n,!0),await e.resolve(),t.strictEqual(e.isModified(),!0),t.strictEqual(e.hasAssociatedFilePath,!0)}),test("resolve - with backup",async()=>{await e.resolve(),e.model?.updateContents("Hello Backup");const i=await e.backup(c.None);await s.workingCopyBackupService.backup(e,i.content,void 0,i.meta),t.strictEqual(s.workingCopyBackupService.hasBackupSync(e),!0),e.dispose(),e=r();let o=0;a.add(e.onDidChangeContent(()=>{o++})),await e.resolve(),t.strictEqual(e.isModified(),!0),t.strictEqual(e.model?.contents,"Hello Backup"),t.strictEqual(o,1)}),b()});export{F as TestUntitledFileWorkingCopyModelFactory};
