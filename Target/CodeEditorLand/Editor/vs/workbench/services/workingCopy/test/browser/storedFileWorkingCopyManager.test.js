import e from"assert";import{URI as l}from"../../../../../base/common/uri.js";import"../../../../../platform/instantiation/common/instantiation.js";import{workbenchInstantiationService as P,TestServiceAccessor as R,TestWillShutdownEvent as W}from"../../../../test/browser/workbenchTestServices.js";import{StoredFileWorkingCopyManager as T}from"../../common/storedFileWorkingCopyManager.js";import"../../common/storedFileWorkingCopy.js";import{bufferToStream as w,VSBuffer as f}from"../../../../../base/common/buffer.js";import{FileChangesEvent as S,FileChangeType as m,FileOperationError as k,FileOperationResult as E}from"../../../../../platform/files/common/files.js";import{timeout as I}from"../../../../../base/common/async.js";import{TestStoredFileWorkingCopyModelFactory as M}from"./storedFileWorkingCopy.test.js";import{CancellationToken as h}from"../../../../../base/common/cancellation.js";import{InMemoryFileSystemProvider as b}from"../../../../../platform/files/common/inMemoryFilesystemProvider.js";import{DisposableStore as N}from"../../../../../base/common/lifecycle.js";import{isWeb as _}from"../../../../../base/common/platform.js";import{ensureNoDisposablesAreLeakedInTestSuite as O}from"../../../../../base/test/common/utils.js";suite("StoredFileWorkingCopyManager",()=>{const a=new N;let q,s,o;setup(()=>{q=P(void 0,a),s=q.createInstance(R),o=a.add(new T("testStoredFileWorkingCopyType",new M,s.fileService,s.lifecycleService,s.labelService,s.logService,s.workingCopyFileService,s.workingCopyBackupService,s.uriIdentityService,s.filesConfigurationService,s.workingCopyService,s.notificationService,s.workingCopyEditorService,s.editorService,s.elevatedFileService,s.progressService))}),teardown(()=>{for(const r of o.workingCopies)r.dispose();a.clear()}),test("resolve",async()=>{const r=l.file("/test.html"),t=[],i=o.onDidCreate(v=>{t.push(v)}),c=o.resolve(r);e.ok(o.get(r)),e.strictEqual(o.workingCopies.length,1);const n=await c;e.ok(n),e.ok(n.model),e.strictEqual(n.typeId,"testStoredFileWorkingCopyType"),e.strictEqual(n.resource.toString(),r.toString()),e.strictEqual(o.get(r),n);const d=await o.resolve(r);e.strictEqual(d,n),e.strictEqual(o.workingCopies.length,1),n.dispose();const u=await o.resolve(r);e.notStrictEqual(u,d),e.strictEqual(o.workingCopies.length,1),e.strictEqual(o.get(r),u),u.dispose(),e.strictEqual(o.workingCopies.length,0),e.strictEqual(t.length,2),e.strictEqual(t[0].resource.toString(),n.resource.toString()),e.strictEqual(t[1].resource.toString(),d.resource.toString()),i.dispose(),n.dispose(),d.dispose(),u.dispose()}),test("resolve (async)",async()=>{const r=l.file("/path/index.txt");a.add(await o.resolve(r));let t=!1,i=new Promise(n=>{a.add(o.onDidResolve(({model:d})=>{d?.resource.toString()===r.toString()&&(t=!0,n())}))});const c=o.resolve(r,{reload:{async:!0}});await i,e.strictEqual(t,!0),t=!1,i=new Promise(n=>{a.add(o.onDidResolve(({model:d})=>{d?.resource.toString()===r.toString()&&(t=!0,n())}))}),o.resolve(r,{reload:{async:!0,force:!0}}),await i,e.strictEqual(t,!0),a.add(await c)}),test("resolve (sync)",async()=>{const r=l.file("/path/index.txt");await o.resolve(r);let t=!1;a.add(o.onDidResolve(({model:i})=>{i?.resource.toString()===r.toString()&&(t=!0)})),a.add(await o.resolve(r,{reload:{async:!1}})),e.strictEqual(t,!0),t=!1,a.add(await o.resolve(r,{reload:{async:!1,force:!0}})),e.strictEqual(t,!0)}),test("resolve (sync) - model disposed when error and first call to resolve",async()=>{const r=l.file("/path/index.txt");s.fileService.readShouldThrowError=new k("fail",E.FILE_OTHER_ERROR);try{let t;try{await o.resolve(r)}catch(i){t=i}e.ok(t),e.strictEqual(o.workingCopies.length,0)}finally{s.fileService.readShouldThrowError=void 0}}),test("resolve (sync) - model not disposed when error and model existed before",async()=>{const r=l.file("/path/index.txt");a.add(await o.resolve(r)),s.fileService.readShouldThrowError=new k("fail",E.FILE_OTHER_ERROR);try{let t;try{await o.resolve(r,{reload:{async:!1}})}catch(i){t=i}e.ok(t),e.strictEqual(o.workingCopies.length,1)}finally{s.fileService.readShouldThrowError=void 0}}),test("resolve with initial contents",async()=>{const r=l.file("/test.html"),t=await o.resolve(r,{contents:w(f.fromString("Hello World"))});e.strictEqual(t.model?.contents,"Hello World"),e.strictEqual(t.isDirty(),!0),await o.resolve(r,{contents:w(f.fromString("More Changes"))}),e.strictEqual(t.model?.contents,"More Changes"),e.strictEqual(t.isDirty(),!0),t.dispose()}),test("multiple resolves execute in sequence (same resources)",async()=>{const r=l.file("/test.html"),t=o.resolve(r),i=o.resolve(r,{contents:w(f.fromString("Hello World"))}),c=o.resolve(r,{contents:w(f.fromString("More Changes"))});await t,await i;const n=await c;e.strictEqual(n.model?.contents,"More Changes"),e.strictEqual(n.isDirty(),!0),n.dispose()}),test("multiple resolves execute in parallel (different resources)",async()=>{const r=l.file("/test1.html"),t=l.file("/test2.html"),i=l.file("/test3.html"),c=o.resolve(r),n=o.resolve(t),d=o.resolve(i),[u,v,y]=await Promise.all([c,n,d]);e.strictEqual(o.workingCopies.length,3),e.strictEqual(u.resource.toString(),r.toString()),e.strictEqual(v.resource.toString(),t.toString()),e.strictEqual(y.resource.toString(),i.toString()),u.dispose(),v.dispose(),y.dispose()}),test("removed from cache when working copy or model gets disposed",async()=>{const r=l.file("/test.html");let t=await o.resolve(r,{contents:w(f.fromString("Hello World"))});e.strictEqual(o.get(l.file("/test.html")),t),t.dispose(),e(!o.get(l.file("/test.html"))),t=await o.resolve(r,{contents:w(f.fromString("Hello World"))}),e.strictEqual(o.get(l.file("/test.html")),t),t.model?.dispose(),e(!o.get(l.file("/test.html")))}),test("events",async()=>{const r=l.file("/path/index.txt"),t=l.file("/path/other.txt");let i=0,c=0,n=0,d=0,u=0,v=0,y=0,F=0;a.add(o.onDidCreate(()=>{i++})),a.add(o.onDidRemove(g=>{(g.toString()===r.toString()||g.toString()===t.toString())&&n++})),a.add(o.onDidResolve(g=>{g.resource.toString()===r.toString()&&c++})),a.add(o.onDidChangeDirty(g=>{g.resource.toString()===r.toString()&&(g.isDirty()?d++:u++)})),a.add(o.onDidRevert(g=>{g.resource.toString()===r.toString()&&v++}));let C;a.add(o.onDidSave(g=>{g.workingCopy.resource.toString()===r.toString()&&(C=g,y++)})),a.add(o.onDidSaveError(g=>{g.resource.toString()===r.toString()&&F++}));const p=a.add(await o.resolve(r));e.strictEqual(c,1),e.strictEqual(i,1),s.fileService.fireFileChanges(new S([{resource:r,type:m.DELETED}],!1)),s.fileService.fireFileChanges(new S([{resource:r,type:m.ADDED}],!1));const x=a.add(await o.resolve(t));e.strictEqual(c,2),e.strictEqual(i,2),p.model?.updateContents("changed"),await p.revert(),p.model?.updateContents("changed again"),await p.save();try{s.fileService.writeShouldThrowError=new k("write error",E.FILE_PERMISSION_DENIED),await p.save({force:!0})}finally{s.fileService.writeShouldThrowError=void 0}p.dispose(),x.dispose(),await p.revert(),e.strictEqual(n,2),e.strictEqual(d,3),e.strictEqual(u,2),e.strictEqual(v,1),e.strictEqual(y,1),e.strictEqual(C.workingCopy,p),e.ok(C.stat),e.strictEqual(F,1),e.strictEqual(i,2),p.dispose(),x.dispose()}),test("resolve registers as working copy and dispose clears",async()=>{const r=l.file("/test1.html"),t=l.file("/test2.html"),i=l.file("/test3.html");e.strictEqual(s.workingCopyService.workingCopies.length,0);const c=o.resolve(r),n=o.resolve(t),d=o.resolve(i);await Promise.all([c,n,d]),e.strictEqual(s.workingCopyService.workingCopies.length,3),e.strictEqual(o.workingCopies.length,3),o.dispose(),e.strictEqual(o.workingCopies.length,0),e.strictEqual(s.workingCopyService.workingCopies.length,3),a.add(await c),a.add(await n),a.add(await d)}),test("destroy",async()=>{const r=l.file("/test1.html"),t=l.file("/test2.html"),i=l.file("/test3.html");e.strictEqual(s.workingCopyService.workingCopies.length,0);const c=o.resolve(r),n=o.resolve(t),d=o.resolve(i);await Promise.all([c,n,d]),e.strictEqual(s.workingCopyService.workingCopies.length,3),e.strictEqual(o.workingCopies.length,3),await o.destroy(),e.strictEqual(s.workingCopyService.workingCopies.length,0),e.strictEqual(o.workingCopies.length,0)}),test("destroy saves dirty working copies",async()=>{const r=l.file("/path/source.txt"),t=await o.resolve(r);let i=!1;a.add(t.onDidSave(()=>{i=!0})),t.model?.updateContents("hello create"),e.strictEqual(t.isDirty(),!0),e.strictEqual(s.workingCopyService.workingCopies.length,1),e.strictEqual(o.workingCopies.length,1),await o.destroy(),e.strictEqual(s.workingCopyService.workingCopies.length,0),e.strictEqual(o.workingCopies.length,0),e.strictEqual(i,!0)}),test("destroy falls back to using backup when save fails",async()=>{const r=l.file("/path/source.txt"),t=await o.resolve(r);t.model?.setThrowOnSnapshot();let i=!1;a.add(t.onDidSave(()=>{i=!0})),t.model?.updateContents("hello create"),e.strictEqual(t.isDirty(),!0),e.strictEqual(s.workingCopyService.workingCopies.length,1),e.strictEqual(o.workingCopies.length,1),e.strictEqual(s.workingCopyBackupService.resolved.has(t),!0),await o.destroy(),e.strictEqual(s.workingCopyService.workingCopies.length,0),e.strictEqual(o.workingCopies.length,0),e.strictEqual(i,!1)}),test("file change event triggers working copy resolve",async()=>{const r=l.file("/path/index.txt");await o.resolve(r);let t=!1;const i=new Promise(c=>{a.add(o.onDidResolve(({model:n})=>{n?.resource.toString()===r.toString()&&(t=!0,c())}))});s.fileService.fireFileChanges(new S([{resource:r,type:m.UPDATED}],!1)),await i,e.strictEqual(t,!0)}),test("file change event triggers working copy resolve (when working copy is pending to resolve)",async()=>{const r=l.file("/path/index.txt");o.resolve(r);let t=!1,i=0;const c=new Promise(n=>{a.add(o.onDidResolve(({model:d})=>{d?.resource.toString()===r.toString()&&(i++,i===2&&(t=!0,n()))}))});s.fileService.fireFileChanges(new S([{resource:r,type:m.UPDATED}],!1)),await c,e.strictEqual(t,!0)}),test("file system provider change triggers working copy resolve",async()=>{const r=l.file("/path/index.txt");a.add(await o.resolve(r));let t=!1;const i=new Promise(c=>{a.add(o.onDidResolve(({model:n})=>{n?.resource.toString()===r.toString()&&(t=!0,c())}))});s.fileService.fireFileSystemProviderCapabilitiesChangeEvent({provider:a.add(new b),scheme:r.scheme}),await i,e.strictEqual(t,!0)}),test("working copy file event handling: create",async()=>{const r=l.file("/path/source.txt"),t=await o.resolve(r);t.model?.updateContents("hello create"),e.strictEqual(t.isDirty(),!0),await s.workingCopyFileService.create([{resource:r}],h.None),e.strictEqual(t.isDirty(),!1)}),test("working copy file event handling: move",()=>D(!0)),test("working copy file event handling: copy",()=>D(!1));async function D(r){const t=l.file("/path/source.txt"),i=l.file("/path/other.txt"),c=await o.resolve(t);c.model?.updateContents("hello move or copy"),e.strictEqual(c.isDirty(),!0),r?await s.workingCopyFileService.move([{file:{source:t,target:i}}],h.None):await s.workingCopyFileService.copy([{file:{source:t,target:i}}],h.None);const n=await o.resolve(i);e.strictEqual(n.isDirty(),!0),e.strictEqual(n.model?.contents,"hello move or copy")}test("working copy file event handling: delete",async()=>{const r=l.file("/path/source.txt"),t=await o.resolve(r);t.model?.updateContents("hello delete"),e.strictEqual(t.isDirty(),!0),await s.workingCopyFileService.delete([{resource:r}],h.None),e.strictEqual(t.isDirty(),!1)}),test("working copy file event handling: move to same resource",async()=>{const r=l.file("/path/source.txt"),t=await o.resolve(r);t.model?.updateContents("hello move"),e.strictEqual(t.isDirty(),!0),await s.workingCopyFileService.move([{file:{source:r,target:r}}],h.None),e.strictEqual(t.isDirty(),!0),e.strictEqual(t.model?.contents,"hello move")}),test("canDispose with dirty working copy",async()=>{const r=l.file("/path/index_something.txt"),t=await o.resolve(r);t.model?.updateContents("make dirty");const i=o.canDispose(t);e.ok(i instanceof Promise);let c=!1;(async()=>c=await i)(),e.strictEqual(c,!1),t.revert({soft:!0}),await I(0),e.strictEqual(c,!0);const n=o.canDispose(t);e.strictEqual(n,!0)}),(_?test.skip:test)("pending saves join on shutdown",async()=>{const r=l.file("/path/index_something1.txt"),t=l.file("/path/index_something2.txt"),i=a.add(await o.resolve(r));i.model?.updateContents("make dirty");const c=a.add(await o.resolve(t));c.model?.updateContents("make dirty");let n=!1;i.save().then(()=>{n=!0});let d=!1;c.save().then(()=>{d=!0});const u=new W;s.lifecycleService.fireWillShutdown(u),e.ok(u.value.length>0),await Promise.all(u.value),e.strictEqual(n,!0),e.strictEqual(d,!0)}),O()});
