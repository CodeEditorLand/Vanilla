import e from"assert";import{bufferToStream as p,VSBuffer as v}from"../../../../../base/common/buffer.js";import{DisposableStore as C}from"../../../../../base/common/lifecycle.js";import{Schemas as c}from"../../../../../base/common/network.js";import{URI as u}from"../../../../../base/common/uri.js";import{ensureNoDisposablesAreLeakedInTestSuite as m}from"../../../../../base/test/common/utils.js";import"../../../../../platform/instantiation/common/instantiation.js";import{FileWorkingCopyManager as g}from"../../common/fileWorkingCopyManager.js";import{NO_TYPE_ID as k,WorkingCopyCapabilities as E}from"../../common/workingCopy.js";import{TestStoredFileWorkingCopyModelFactory as y}from"./storedFileWorkingCopy.test.js";import{TestUntitledFileWorkingCopyModelFactory as S}from"./untitledFileWorkingCopy.test.js";import{TestInMemoryFileSystemProvider as f,TestServiceAccessor as q,workbenchInstantiationService as h}from"../../../../test/browser/workbenchTestServices.js";suite("UntitledFileWorkingCopyManager",()=>{const n=new C;let w,t,i;setup(()=>{w=h(void 0,n),t=w.createInstance(q),n.add(t.fileService.registerProvider(c.file,n.add(new f))),n.add(t.fileService.registerProvider(c.vscodeRemote,n.add(new f))),i=n.add(new g("testUntitledFileWorkingCopyType",new y,new S,t.fileService,t.lifecycleService,t.labelService,t.logService,t.workingCopyFileService,t.workingCopyBackupService,t.uriIdentityService,t.fileDialogService,t.filesConfigurationService,t.workingCopyService,t.notificationService,t.workingCopyEditorService,t.editorService,t.elevatedFileService,t.pathService,t.environmentService,t.dialogService,t.decorationsService,t.progressService))}),teardown(()=>{for(const r of[...i.untitled.workingCopies,...i.stored.workingCopies])r.dispose();n.clear()}),test("basics",async()=>{let r=0;n.add(i.untitled.onDidCreate(d=>{r++}));let o=0;n.add(i.untitled.onWillDispose(d=>{o++}));let l=0;n.add(i.untitled.onDidChangeDirty(d=>{l++})),e.strictEqual(t.workingCopyService.workingCopies.length,0),e.strictEqual(i.untitled.workingCopies.length,0),e.strictEqual(i.untitled.get(u.file("/some/invalidPath")),void 0),e.strictEqual(i.untitled.get(u.file("/some/invalidPath").with({scheme:c.untitled})),void 0);const s=await i.untitled.resolve(),a=await i.untitled.resolve();e.strictEqual(s.typeId,"testUntitledFileWorkingCopyType"),e.strictEqual(s.resource.scheme,c.untitled),e.strictEqual(r,2),e.strictEqual(i.untitled.get(s.resource),s),e.strictEqual(i.untitled.get(a.resource),a),e.strictEqual(t.workingCopyService.workingCopies.length,2),e.strictEqual(i.untitled.workingCopies.length,2),e.notStrictEqual(s.resource.toString(),a.resource.toString());for(const d of[s,a])e.strictEqual(d.capabilities,E.Untitled),e.strictEqual(d.isDirty(),!1),e.strictEqual(d.isModified(),!1),e.ok(d.model);s.model?.updateContents("Hello World"),e.strictEqual(s.isDirty(),!0),e.strictEqual(s.isModified(),!0),e.strictEqual(l,1),s.model?.updateContents(""),e.strictEqual(s.isDirty(),!1),e.strictEqual(s.isModified(),!1),e.strictEqual(l,2),a.model?.fireContentChangeEvent({isInitial:!1}),e.strictEqual(a.isDirty(),!0),e.strictEqual(a.isModified(),!0),e.strictEqual(l,3),s.dispose(),e.strictEqual(i.untitled.workingCopies.length,1),e.strictEqual(i.untitled.get(s.resource),void 0),a.dispose(),e.strictEqual(i.untitled.workingCopies.length,0),e.strictEqual(i.untitled.get(a.resource),void 0),e.strictEqual(o,2)}),test("dirty - scratchpads are never dirty",async()=>{let r=0;n.add(i.untitled.onDidChangeDirty(l=>{r++}));const o=await i.resolve({untitledResource:u.from({scheme:c.untitled,path:"/myscratchpad"}),isScratchpad:!0});e.strictEqual(o.resource.scheme,c.untitled),e.strictEqual(i.untitled.workingCopies.length,1),o.model?.updateContents("contents"),e.strictEqual(o.isDirty(),!1),e.strictEqual(o.isModified(),!0),o.model?.fireContentChangeEvent({isInitial:!0}),e.strictEqual(o.isDirty(),!1),e.strictEqual(o.isModified(),!1),e.strictEqual(r,0),o.dispose()}),test("resolve - with initial value",async()=>{let r=0;n.add(i.untitled.onDidChangeDirty(s=>{r++}));const o=await i.untitled.resolve({contents:{value:p(v.fromString("Hello World"))}});e.strictEqual(o.isModified(),!0),e.strictEqual(o.isDirty(),!0),e.strictEqual(r,1),e.strictEqual(o.model?.contents,"Hello World"),o.dispose();const l=await i.untitled.resolve({contents:{value:p(v.fromString("Hello World")),markModified:!0}});e.strictEqual(l.isModified(),!0),e.strictEqual(l.isDirty(),!0),e.strictEqual(r,2),e.strictEqual(l.model?.contents,"Hello World"),l.dispose()}),test("resolve - with initial value but markDirty: false",async()=>{let r=0;n.add(i.untitled.onDidChangeDirty(l=>{r++}));const o=await i.untitled.resolve({contents:{value:p(v.fromString("Hello World")),markModified:!1}});e.strictEqual(o.isModified(),!1),e.strictEqual(o.isDirty(),!1),e.strictEqual(r,0),e.strictEqual(o.model?.contents,"Hello World"),o.dispose()}),test("resolve begins counter from 1 for disposed untitled",async()=>{const r=await i.untitled.resolve();r.dispose();const o=n.add(await i.untitled.resolve());e.strictEqual(r.resource.toString(),o.resource.toString())}),test("resolve - existing",async()=>{let r=0;n.add(i.untitled.onDidCreate(a=>{r++}));const o=await i.untitled.resolve();e.strictEqual(r,1);const l=await i.untitled.resolve({untitledResource:o.resource});e.strictEqual(o,l),e.strictEqual(r,1);const s=await i.untitled.resolve({untitledResource:u.file("/invalid/untitled")});e.strictEqual(s.resource.scheme,c.untitled),o.dispose(),l.dispose(),s.dispose()}),test("resolve - untitled resource used for new working copy",async()=>{const r=u.file("my/untitled.txt"),o=r.with({scheme:c.untitled}),l=await i.untitled.resolve({untitledResource:r});e.notStrictEqual(l.resource.toString(),r.toString());const s=await i.untitled.resolve({untitledResource:o});e.strictEqual(s.resource.toString(),o.toString()),l.dispose(),s.dispose()}),test("resolve - with associated resource",async()=>{const r=await i.untitled.resolve({associatedResource:{path:"/some/associated.txt"}});e.strictEqual(r.hasAssociatedFilePath,!0),e.strictEqual(r.resource.path,"/some/associated.txt"),r.dispose()}),test("save - without associated resource",async()=>{const r=await i.untitled.resolve();r.model?.updateContents("Simple Save"),t.fileDialogService.setPickFileToSave(u.file("simple/file.txt"));const o=await r.save();e.ok(o),e.strictEqual(i.untitled.get(r.resource),void 0),r.dispose()}),test("save - with associated resource",async()=>{const r=await i.untitled.resolve({associatedResource:{path:"/some/associated.txt"}});r.model?.updateContents("Simple Save with associated resource"),t.fileService.notExistsSet.set(u.from({scheme:c.file,path:"/some/associated.txt"}),!0);const o=await r.save();e.ok(o),e.strictEqual(i.untitled.get(r.resource),void 0),r.dispose()}),test("save - with associated resource (asks to overwrite)",async()=>{const r=await i.untitled.resolve({associatedResource:{path:"/some/associated.txt"}});r.model?.updateContents("Simple Save with associated resource");let o=await r.save();e.ok(!o),e.strictEqual(i.untitled.get(r.resource),r),t.dialogService.setConfirmResult({confirmed:!0}),o=await r.save(),e.ok(o),e.strictEqual(i.untitled.get(r.resource),void 0),r.dispose()}),test("destroy",async()=>{e.strictEqual(t.workingCopyService.workingCopies.length,0),await i.untitled.resolve(),await i.untitled.resolve(),await i.untitled.resolve(),e.strictEqual(t.workingCopyService.workingCopies.length,3),e.strictEqual(i.untitled.workingCopies.length,3),await i.untitled.destroy(),e.strictEqual(t.workingCopyService.workingCopies.length,0),e.strictEqual(i.untitled.workingCopies.length,0)}),test("manager with different types produce different URIs",async()=>{try{i=n.add(new g("someOtherUntitledTypeId",new y,new S,t.fileService,t.lifecycleService,t.labelService,t.logService,t.workingCopyFileService,t.workingCopyBackupService,t.uriIdentityService,t.fileDialogService,t.filesConfigurationService,t.workingCopyService,t.notificationService,t.workingCopyEditorService,t.editorService,t.elevatedFileService,t.pathService,t.environmentService,t.dialogService,t.decorationsService,t.progressService));const r=n.add(await i.untitled.resolve()),o=n.add(await i.untitled.resolve());e.notStrictEqual(r.resource.toString(),o.resource.toString())}finally{i.destroy()}}),test("manager without typeId produces backwards compatible URIs",async()=>{try{i=n.add(new g(k,new y,new S,t.fileService,t.lifecycleService,t.labelService,t.logService,t.workingCopyFileService,t.workingCopyBackupService,t.uriIdentityService,t.fileDialogService,t.filesConfigurationService,t.workingCopyService,t.notificationService,t.workingCopyEditorService,t.editorService,t.elevatedFileService,t.pathService,t.environmentService,t.dialogService,t.decorationsService,t.progressService));const r=n.add(await i.untitled.resolve());e.strictEqual(r.resource.scheme,c.untitled),e.ok(r.resource.path.length>0),e.strictEqual(r.resource.query,""),e.strictEqual(r.resource.authority,""),e.strictEqual(r.resource.fragment,"")}finally{i.destroy()}}),m()});
