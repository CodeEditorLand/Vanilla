import e from"assert";import{TextFileEditorModel as y}from"../../../textfile/common/textFileEditorModel.js";import"../../../textfile/common/textFileEditorModelManager.js";import"../../../../../platform/instantiation/common/instantiation.js";import{ensureNoDisposablesAreLeakedInTestSuite as I,toResource as l}from"../../../../../base/test/common/utils.js";import{workbenchInstantiationService as D,TestServiceAccessor as O}from"../../../../test/browser/workbenchTestServices.js";import"../../../../../base/common/uri.js";import{FileOperation as E}from"../../../../../platform/files/common/files.js";import{TestWorkingCopy as R}from"../../../../test/common/workbenchTestServices.js";import{VSBuffer as W}from"../../../../../base/common/buffer.js";import"../../common/workingCopyFileService.js";import{CancellationToken as x,CancellationTokenSource as C}from"../../../../../base/common/cancellation.js";import{timeout as P}from"../../../../../base/common/async.js";import{DisposableStore as b}from"../../../../../base/common/lifecycle.js";suite("WorkingCopyFileService",()=>{const h=new b;let f,r;setup(()=>{f=D(void 0,h),r=f.createInstance(O),h.add(r.textFileService.files)}),teardown(()=>{h.clear()}),test("create - dirty file",async function(){await q(l.call(this,"/path/file.txt"),W.fromString("Hello World"))}),test("delete - dirty file",async function(){await m([l.call(this,"/path/file.txt")])}),test("delete multiple - dirty files",async function(){await m([l.call(this,"/path/file1.txt"),l.call(this,"/path/file2.txt"),l.call(this,"/path/file3.txt"),l.call(this,"/path/file4.txt")])}),test("move - dirty file",async function(){await w([{source:l.call(this,"/path/file.txt"),target:l.call(this,"/path/file_target.txt")}],!0)}),test("move - source identical to target",async function(){const t=f.createInstance(y,l.call(this,"/path/file.txt"),"utf8",void 0);r.textFileService.files.add(t.resource,t);const o=await k([{file:{source:t.resource,target:t.resource},overwrite:!0}],!0);t.dispose(),e.strictEqual(o,3)}),test("move - one source == target and another source != target",async function(){const t=f.createInstance(y,l.call(this,"/path/file1.txt"),"utf8",void 0),o=f.createInstance(y,l.call(this,"/path/file2.txt"),"utf8",void 0),i=f.createInstance(y,l.call(this,"/path/file_target2.txt"),"utf8",void 0);r.textFileService.files.add(t.resource,t),r.textFileService.files.add(o.resource,o),r.textFileService.files.add(i.resource,i);const a=await k([{file:{source:t.resource,target:t.resource},overwrite:!0},{file:{source:o.resource,target:i.resource},overwrite:!0}],!0);t.dispose(),o.dispose(),i.dispose(),e.strictEqual(a,3)}),test("move multiple - dirty file",async function(){await w([{source:l.call(this,"/path/file1.txt"),target:l.call(this,"/path/file1_target.txt")},{source:l.call(this,"/path/file2.txt"),target:l.call(this,"/path/file2_target.txt")}],!0)}),test("move - dirty file (target exists and is dirty)",async function(){await w([{source:l.call(this,"/path/file.txt"),target:l.call(this,"/path/file_target.txt")}],!0,!0)}),test("copy - dirty file",async function(){await w([{source:l.call(this,"/path/file.txt"),target:l.call(this,"/path/file_target.txt")}],!1)}),test("copy - source identical to target",async function(){const t=f.createInstance(y,l.call(this,"/path/file.txt"),"utf8",void 0);r.textFileService.files.add(t.resource,t);const o=await k([{file:{source:t.resource,target:t.resource},overwrite:!0}]);t.dispose(),e.strictEqual(o,3)}),test("copy - one source == target and another source != target",async function(){const t=f.createInstance(y,l.call(this,"/path/file1.txt"),"utf8",void 0),o=f.createInstance(y,l.call(this,"/path/file2.txt"),"utf8",void 0),i=f.createInstance(y,l.call(this,"/path/file_target2.txt"),"utf8",void 0);r.textFileService.files.add(t.resource,t),r.textFileService.files.add(o.resource,o),r.textFileService.files.add(i.resource,i);const a=await k([{file:{source:t.resource,target:t.resource},overwrite:!0},{file:{source:o.resource,target:i.resource},overwrite:!0}]);t.dispose(),o.dispose(),i.dispose(),e.strictEqual(a,3)}),test("copy multiple - dirty file",async function(){await w([{source:l.call(this,"/path/file1.txt"),target:l.call(this,"/path/file_target1.txt")},{source:l.call(this,"/path/file2.txt"),target:l.call(this,"/path/file_target2.txt")},{source:l.call(this,"/path/file3.txt"),target:l.call(this,"/path/file_target3.txt")}],!1)}),test("copy - dirty file (target exists and is dirty)",async function(){await w([{source:l.call(this,"/path/file.txt"),target:l.call(this,"/path/file_target.txt")}],!1,!0)}),test("getDirty",async function(){const t=f.createInstance(y,l.call(this,"/path/file-1.txt"),"utf8",void 0);r.textFileService.files.add(t.resource,t);const o=f.createInstance(y,l.call(this,"/path/file-2.txt"),"utf8",void 0);r.textFileService.files.add(o.resource,o);let i=r.workingCopyFileService.getDirty(t.resource);e.strictEqual(i.length,0),await t.resolve(),t.textEditorModel.setValue("foo"),i=r.workingCopyFileService.getDirty(t.resource),e.strictEqual(i.length,1),e.strictEqual(i[0],t),i=r.workingCopyFileService.getDirty(l.call(this,"/path")),e.strictEqual(i.length,1),e.strictEqual(i[0],t),await o.resolve(),o.textEditorModel.setValue("bar"),i=r.workingCopyFileService.getDirty(l.call(this,"/path")),e.strictEqual(i.length,2),t.dispose(),o.dispose()}),test("registerWorkingCopyProvider",async function(){const t=h.add(f.createInstance(y,l.call(this,"/path/file-1.txt"),"utf8",void 0));r.textFileService.files.add(t.resource,t),await t.resolve(),t.textEditorModel.setValue("foo");const o=h.add(new R(l.call(this,"/path/file-2.txt"),!0)),i=r.workingCopyFileService.registerWorkingCopyProvider(()=>[t,o]);let a=r.workingCopyFileService.getDirty(t.resource);e.strictEqual(a.length,2,"Should return default working copy + working copy from provider"),e.strictEqual(a[0],t),e.strictEqual(a[1],o),i.dispose(),a=r.workingCopyFileService.getDirty(t.resource),e.strictEqual(a.length,1,"Should have unregistered our provider"),e.strictEqual(a[0],t)}),test("createFolder",async function(){let t=0,o;const i=l.call(this,"/path/folder");h.add(r.workingCopyFileService.addFileOperationParticipant({participate:async(a,u)=>{e.strictEqual(a.length,1);const d=a[0];e.strictEqual(d.target.toString(),i.toString()),e.strictEqual(u,E.CREATE),t++}})),h.add(r.workingCopyFileService.onWillRunWorkingCopyFileOperation(a=>{e.strictEqual(a.files.length,1);const u=a.files[0];e.strictEqual(u.target.toString(),i.toString()),e.strictEqual(a.operation,E.CREATE),o=a.correlationId,t++})),h.add(r.workingCopyFileService.onDidRunWorkingCopyFileOperation(a=>{e.strictEqual(a.files.length,1);const u=a.files[0];e.strictEqual(u.target.toString(),i.toString()),e.strictEqual(a.operation,E.CREATE),e.strictEqual(a.correlationId,o),t++})),await r.workingCopyFileService.createFolder([{resource:i}],x.None),e.strictEqual(t,3)}),test("cancellation of participants",async function(){const t=l.call(this,"/path/folder");let o=!1;h.add(r.workingCopyFileService.addFileOperationParticipant({participate:async(u,d,F,p,c)=>{await P(0),o=c.isCancellationRequested}}));let i=new C,a=r.workingCopyFileService.create([{resource:t}],i.token);i.cancel(),await a,e.strictEqual(o,!0),o=!1,i=new C,a=r.workingCopyFileService.createFolder([{resource:t}],i.token),i.cancel(),await a,e.strictEqual(o,!0),o=!1,i=new C,a=r.workingCopyFileService.move([{file:{source:t,target:t}}],i.token),i.cancel(),await a,e.strictEqual(o,!0),o=!1,i=new C,a=r.workingCopyFileService.copy([{file:{source:t,target:t}}],i.token),i.cancel(),await a,e.strictEqual(o,!0),o=!1,i=new C,a=r.workingCopyFileService.delete([{resource:t}],i.token),i.cancel(),await a,e.strictEqual(o,!0),o=!1});async function k(t,o){let i=0;const a=r.workingCopyFileService.addFileOperationParticipant({participate:async F=>{i++}}),u=r.workingCopyFileService.onWillRunWorkingCopyFileOperation(F=>{i++}),d=r.workingCopyFileService.onDidRunWorkingCopyFileOperation(F=>{i++});return o?await r.workingCopyFileService.move(t,x.None):await r.workingCopyFileService.copy(t,x.None),a.dispose(),u.dispose(),d.dispose(),i}async function w(t,o,i){let a=0;const u=await Promise.all(t.map(async({source:s,target:n},g)=>{const S=f.createInstance(y,s,"utf8",void 0),v=f.createInstance(y,n,"utf8",void 0);return r.textFileService.files.add(S.resource,S),r.textFileService.files.add(v.resource,v),await S.resolve(),S.textEditorModel.setValue("foo"+g),e.ok(r.textFileService.isDirty(S.resource)),i&&(await v.resolve(),v.textEditorModel.setValue("bar"+g),e.ok(r.textFileService.isDirty(v.resource))),{sourceModel:S,targetModel:v}})),d=r.workingCopyFileService.addFileOperationParticipant({participate:async(s,n)=>{for(let g=0;g<s.length;g++){const{target:S,source:v}=s[g],{targetModel:M,sourceModel:T}=u[g];e.strictEqual(S.toString(),M.resource.toString()),e.strictEqual(v?.toString(),T.resource.toString())}a++,e.strictEqual(n,o?E.MOVE:E.COPY)}});let F;const p=r.workingCopyFileService.onWillRunWorkingCopyFileOperation(s=>{for(let n=0;n<s.files.length;n++){const{target:g,source:S}=t[n],{targetModel:v,sourceModel:M}=u[n];e.strictEqual(g.toString(),v.resource.toString()),e.strictEqual(S?.toString(),M.resource.toString())}a++,F=s.correlationId,e.strictEqual(s.operation,o?E.MOVE:E.COPY)}),c=r.workingCopyFileService.onDidRunWorkingCopyFileOperation(s=>{for(let n=0;n<s.files.length;n++){const{target:g,source:S}=t[n],{targetModel:v,sourceModel:M}=u[n];e.strictEqual(g.toString(),v.resource.toString()),e.strictEqual(S?.toString(),M.resource.toString())}a++,e.strictEqual(s.operation,o?E.MOVE:E.COPY),e.strictEqual(s.correlationId,F)});o?await r.workingCopyFileService.move(u.map(s=>({file:{source:s.sourceModel.resource,target:s.targetModel.resource},options:{overwrite:!0}})),x.None):await r.workingCopyFileService.copy(u.map(s=>({file:{source:s.sourceModel.resource,target:s.targetModel.resource},options:{overwrite:!0}})),x.None);for(let s=0;s<u.length;s++){const{sourceModel:n,targetModel:g}=u[s];e.strictEqual(g.textEditorModel.getValue(),"foo"+s),o?e.ok(!r.textFileService.isDirty(n.resource)):e.ok(r.textFileService.isDirty(n.resource)),e.ok(r.textFileService.isDirty(g.resource)),n.dispose(),g.dispose()}e.strictEqual(a,3),d.dispose(),p.dispose(),c.dispose()}async function m(t){const o=await Promise.all(t.map(async p=>{const c=f.createInstance(y,p,"utf8",void 0);return r.textFileService.files.add(c.resource,c),await c.resolve(),c.textEditorModel.setValue("foo"),e.ok(r.workingCopyService.isDirty(c.resource)),c}));let i=0,a;const u=r.workingCopyFileService.addFileOperationParticipant({participate:async(p,c)=>{for(let s=0;s<o.length;s++){const n=o[s],g=p[s];e.strictEqual(g.target.toString(),n.resource.toString())}e.strictEqual(c,E.DELETE),i++}}),d=r.workingCopyFileService.onWillRunWorkingCopyFileOperation(p=>{for(let c=0;c<o.length;c++){const s=o[c],n=p.files[c];e.strictEqual(n.target.toString(),s.resource.toString())}e.strictEqual(p.operation,E.DELETE),a=p.correlationId,i++}),F=r.workingCopyFileService.onDidRunWorkingCopyFileOperation(p=>{for(let c=0;c<o.length;c++){const s=o[c],n=p.files[c];e.strictEqual(n.target.toString(),s.resource.toString())}e.strictEqual(p.operation,E.DELETE),e.strictEqual(p.correlationId,a),i++});await r.workingCopyFileService.delete(o.map(p=>({resource:p.resource})),x.None);for(const p of o)e.ok(!r.workingCopyService.isDirty(p.resource)),p.dispose();e.strictEqual(i,3),u.dispose(),d.dispose(),F.dispose()}async function q(t,o){const i=f.createInstance(y,t,"utf8",void 0);r.textFileService.files.add(i.resource,i),await i.resolve(),i.textEditorModel.setValue("foo"),e.ok(r.workingCopyService.isDirty(i.resource));let a=0,u;h.add(r.workingCopyFileService.addFileOperationParticipant({participate:async(d,F)=>{e.strictEqual(d.length,1);const p=d[0];e.strictEqual(p.target.toString(),i.resource.toString()),e.strictEqual(F,E.CREATE),a++}})),h.add(r.workingCopyFileService.onWillRunWorkingCopyFileOperation(d=>{e.strictEqual(d.files.length,1);const F=d.files[0];e.strictEqual(F.target.toString(),i.resource.toString()),e.strictEqual(d.operation,E.CREATE),u=d.correlationId,a++})),h.add(r.workingCopyFileService.onDidRunWorkingCopyFileOperation(d=>{e.strictEqual(d.files.length,1);const F=d.files[0];e.strictEqual(F.target.toString(),i.resource.toString()),e.strictEqual(d.operation,E.CREATE),e.strictEqual(d.correlationId,u),a++})),await r.workingCopyFileService.create([{resource:t,contents:o}],x.None),e.ok(!r.workingCopyService.isDirty(i.resource)),i.dispose(),e.strictEqual(a,3)}I()});
