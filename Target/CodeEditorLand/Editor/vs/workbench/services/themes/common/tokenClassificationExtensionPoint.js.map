{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/themes/common/tokenClassificationExtensionPoint.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as nls from '../../../../nls.js';\nimport { ExtensionsRegistry, ExtensionMessageCollector } from '../../extensions/common/extensionsRegistry.js';\nimport { getTokenClassificationRegistry, ITokenClassificationRegistry, typeAndModifierIdPattern } from '../../../../platform/theme/common/tokenClassificationRegistry.js';\n\ninterface ITokenTypeExtensionPoint {\n\tid: string;\n\tdescription: string;\n\tsuperType?: string;\n}\n\ninterface ITokenModifierExtensionPoint {\n\tid: string;\n\tdescription: string;\n}\n\ninterface ITokenStyleDefaultExtensionPoint {\n\tlanguage?: string;\n\tscopes: { [selector: string]: string[] };\n}\n\nconst tokenClassificationRegistry: ITokenClassificationRegistry = getTokenClassificationRegistry();\n\nconst tokenTypeExtPoint = ExtensionsRegistry.registerExtensionPoint<ITokenTypeExtensionPoint[]>({\n\textensionPoint: 'semanticTokenTypes',\n\tjsonSchema: {\n\t\tdescription: nls.localize('contributes.semanticTokenTypes', 'Contributes semantic token types.'),\n\t\ttype: 'array',\n\t\titems: {\n\t\t\ttype: 'object',\n\t\t\tproperties: {\n\t\t\t\tid: {\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdescription: nls.localize('contributes.semanticTokenTypes.id', 'The identifier of the semantic token type'),\n\t\t\t\t\tpattern: typeAndModifierIdPattern,\n\t\t\t\t\tpatternErrorMessage: nls.localize('contributes.semanticTokenTypes.id.format', 'Identifiers should be in the form letterOrDigit[_-letterOrDigit]*'),\n\t\t\t\t},\n\t\t\t\tsuperType: {\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdescription: nls.localize('contributes.semanticTokenTypes.superType', 'The super type of the semantic token type'),\n\t\t\t\t\tpattern: typeAndModifierIdPattern,\n\t\t\t\t\tpatternErrorMessage: nls.localize('contributes.semanticTokenTypes.superType.format', 'Super types should be in the form letterOrDigit[_-letterOrDigit]*'),\n\t\t\t\t},\n\t\t\t\tdescription: {\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdescription: nls.localize('contributes.color.description', 'The description of the semantic token type'),\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n\nconst tokenModifierExtPoint = ExtensionsRegistry.registerExtensionPoint<ITokenModifierExtensionPoint[]>({\n\textensionPoint: 'semanticTokenModifiers',\n\tjsonSchema: {\n\t\tdescription: nls.localize('contributes.semanticTokenModifiers', 'Contributes semantic token modifiers.'),\n\t\ttype: 'array',\n\t\titems: {\n\t\t\ttype: 'object',\n\t\t\tproperties: {\n\t\t\t\tid: {\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdescription: nls.localize('contributes.semanticTokenModifiers.id', 'The identifier of the semantic token modifier'),\n\t\t\t\t\tpattern: typeAndModifierIdPattern,\n\t\t\t\t\tpatternErrorMessage: nls.localize('contributes.semanticTokenModifiers.id.format', 'Identifiers should be in the form letterOrDigit[_-letterOrDigit]*')\n\t\t\t\t},\n\t\t\t\tdescription: {\n\t\t\t\t\tdescription: nls.localize('contributes.semanticTokenModifiers.description', 'The description of the semantic token modifier')\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n\nconst tokenStyleDefaultsExtPoint = ExtensionsRegistry.registerExtensionPoint<ITokenStyleDefaultExtensionPoint[]>({\n\textensionPoint: 'semanticTokenScopes',\n\tjsonSchema: {\n\t\tdescription: nls.localize('contributes.semanticTokenScopes', 'Contributes semantic token scope maps.'),\n\t\ttype: 'array',\n\t\titems: {\n\t\t\ttype: 'object',\n\t\t\tproperties: {\n\t\t\t\tlanguage: {\n\t\t\t\t\tdescription: nls.localize('contributes.semanticTokenScopes.languages', 'Lists the languge for which the defaults are.'),\n\t\t\t\t\ttype: 'string'\n\t\t\t\t},\n\t\t\t\tscopes: {\n\t\t\t\t\tdescription: nls.localize('contributes.semanticTokenScopes.scopes', 'Maps a semantic token (described by semantic token selector) to one or more textMate scopes used to represent that token.'),\n\t\t\t\t\ttype: 'object',\n\t\t\t\t\tadditionalProperties: {\n\t\t\t\t\t\ttype: 'array',\n\t\t\t\t\t\titems: {\n\t\t\t\t\t\t\ttype: 'string'\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n\n\nexport class TokenClassificationExtensionPoints {\n\n\tconstructor() {\n\t\tfunction validateTypeOrModifier(contribution: ITokenTypeExtensionPoint | ITokenModifierExtensionPoint, extensionPoint: string, collector: ExtensionMessageCollector): boolean {\n\t\t\tif (typeof contribution.id !== 'string' || contribution.id.length === 0) {\n\t\t\t\tcollector.error(nls.localize('invalid.id', \"'configuration.{0}.id' must be defined and can not be empty\", extensionPoint));\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!contribution.id.match(typeAndModifierIdPattern)) {\n\t\t\t\tcollector.error(nls.localize('invalid.id.format', \"'configuration.{0}.id' must follow the pattern letterOrDigit[-_letterOrDigit]*\", extensionPoint));\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tconst superType = (contribution as ITokenTypeExtensionPoint).superType;\n\t\t\tif (superType && !superType.match(typeAndModifierIdPattern)) {\n\t\t\t\tcollector.error(nls.localize('invalid.superType.format', \"'configuration.{0}.superType' must follow the pattern letterOrDigit[-_letterOrDigit]*\", extensionPoint));\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (typeof contribution.description !== 'string' || contribution.id.length === 0) {\n\t\t\t\tcollector.error(nls.localize('invalid.description', \"'configuration.{0}.description' must be defined and can not be empty\", extensionPoint));\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\ttokenTypeExtPoint.setHandler((extensions, delta) => {\n\t\t\tfor (const extension of delta.added) {\n\t\t\t\tconst extensionValue = <ITokenTypeExtensionPoint[]>extension.value;\n\t\t\t\tconst collector = extension.collector;\n\n\t\t\t\tif (!extensionValue || !Array.isArray(extensionValue)) {\n\t\t\t\t\tcollector.error(nls.localize('invalid.semanticTokenTypeConfiguration', \"'configuration.semanticTokenType' must be an array\"));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfor (const contribution of extensionValue) {\n\t\t\t\t\tif (validateTypeOrModifier(contribution, 'semanticTokenType', collector)) {\n\t\t\t\t\t\ttokenClassificationRegistry.registerTokenType(contribution.id, contribution.description, contribution.superType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const extension of delta.removed) {\n\t\t\t\tconst extensionValue = <ITokenTypeExtensionPoint[]>extension.value;\n\t\t\t\tfor (const contribution of extensionValue) {\n\t\t\t\t\ttokenClassificationRegistry.deregisterTokenType(contribution.id);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\ttokenModifierExtPoint.setHandler((extensions, delta) => {\n\t\t\tfor (const extension of delta.added) {\n\t\t\t\tconst extensionValue = <ITokenModifierExtensionPoint[]>extension.value;\n\t\t\t\tconst collector = extension.collector;\n\n\t\t\t\tif (!extensionValue || !Array.isArray(extensionValue)) {\n\t\t\t\t\tcollector.error(nls.localize('invalid.semanticTokenModifierConfiguration', \"'configuration.semanticTokenModifier' must be an array\"));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfor (const contribution of extensionValue) {\n\t\t\t\t\tif (validateTypeOrModifier(contribution, 'semanticTokenModifier', collector)) {\n\t\t\t\t\t\ttokenClassificationRegistry.registerTokenModifier(contribution.id, contribution.description);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const extension of delta.removed) {\n\t\t\t\tconst extensionValue = <ITokenModifierExtensionPoint[]>extension.value;\n\t\t\t\tfor (const contribution of extensionValue) {\n\t\t\t\t\ttokenClassificationRegistry.deregisterTokenModifier(contribution.id);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\ttokenStyleDefaultsExtPoint.setHandler((extensions, delta) => {\n\t\t\tfor (const extension of delta.added) {\n\t\t\t\tconst extensionValue = <ITokenStyleDefaultExtensionPoint[]>extension.value;\n\t\t\t\tconst collector = extension.collector;\n\n\t\t\t\tif (!extensionValue || !Array.isArray(extensionValue)) {\n\t\t\t\t\tcollector.error(nls.localize('invalid.semanticTokenScopes.configuration', \"'configuration.semanticTokenScopes' must be an array\"));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfor (const contribution of extensionValue) {\n\t\t\t\t\tif (contribution.language && typeof contribution.language !== 'string') {\n\t\t\t\t\t\tcollector.error(nls.localize('invalid.semanticTokenScopes.language', \"'configuration.semanticTokenScopes.language' must be a string\"));\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!contribution.scopes || typeof contribution.scopes !== 'object') {\n\t\t\t\t\t\tcollector.error(nls.localize('invalid.semanticTokenScopes.scopes', \"'configuration.semanticTokenScopes.scopes' must be defined as an object\"));\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (const selectorString in contribution.scopes) {\n\t\t\t\t\t\tconst tmScopes = contribution.scopes[selectorString];\n\t\t\t\t\t\tif (!Array.isArray(tmScopes) || tmScopes.some(l => typeof l !== 'string')) {\n\t\t\t\t\t\t\tcollector.error(nls.localize('invalid.semanticTokenScopes.scopes.value', \"'configuration.semanticTokenScopes.scopes' values must be an array of strings\"));\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst selector = tokenClassificationRegistry.parseTokenSelector(selectorString, contribution.language);\n\t\t\t\t\t\t\ttokenClassificationRegistry.registerTokenStyleDefault(selector, { scopesToProbe: tmScopes.map(s => s.split(' ')) });\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tcollector.error(nls.localize('invalid.semanticTokenScopes.scopes.selector', \"configuration.semanticTokenScopes.scopes': Problems parsing selector {0}.\", selectorString));\n\t\t\t\t\t\t\t// invalid selector, ignore\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const extension of delta.removed) {\n\t\t\t\tconst extensionValue = <ITokenStyleDefaultExtensionPoint[]>extension.value;\n\t\t\t\tfor (const contribution of extensionValue) {\n\t\t\t\t\tfor (const selectorString in contribution.scopes) {\n\t\t\t\t\t\tconst tmScopes = contribution.scopes[selectorString];\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst selector = tokenClassificationRegistry.parseTokenSelector(selectorString, contribution.language);\n\t\t\t\t\t\t\ttokenClassificationRegistry.registerTokenStyleDefault(selector, { scopesToProbe: tmScopes.map(s => s.split(' ')) });\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t// invalid selector, ignore\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n\n\n\n"],
  "mappings": "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",
  "names": []
}
