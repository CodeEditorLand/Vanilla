{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/sharedProcess/electron-sandbox/sharedProcessService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Barrier, timeout } from \"../../../../base/common/async.js\";\nimport { Disposable } from \"../../../../base/common/lifecycle.js\";\nimport { mark } from \"../../../../base/common/performance.js\";\nimport {\n\ttype IChannel,\n\ttype IServerChannel,\n\tgetDelayedChannel,\n} from \"../../../../base/parts/ipc/common/ipc.js\";\nimport { Client as MessagePortClient } from \"../../../../base/parts/ipc/common/ipc.mp.js\";\nimport { acquirePort } from \"../../../../base/parts/ipc/electron-sandbox/ipc.mp.js\";\nimport type { ISharedProcessService } from \"../../../../platform/ipc/electron-sandbox/services.js\";\nimport { ILogService } from \"../../../../platform/log/common/log.js\";\nimport {\n\tSharedProcessChannelConnection,\n\tSharedProcessRawConnection,\n} from \"../../../../platform/sharedProcess/common/sharedProcess.js\";\n\nexport class SharedProcessService\n\textends Disposable\n\timplements ISharedProcessService\n{\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly withSharedProcessConnection: Promise<MessagePortClient>;\n\n\tprivate readonly restoredBarrier = new Barrier();\n\n\tconstructor(\n\t\treadonly windowId: number,\n\t\t@ILogService private readonly logService: ILogService\n\t) {\n\t\tsuper();\n\n\t\tthis.withSharedProcessConnection = this.connect();\n\t}\n\n\tprivate async connect(): Promise<MessagePortClient> {\n\t\tthis.logService.trace(\"Renderer->SharedProcess#connect\");\n\n\t\t// Our performance tests show that a connection to the shared\n\t\t// process can have significant overhead to the startup time\n\t\t// of the window because the shared process could be created\n\t\t// as a result. As such, make sure we await the `Restored`\n\t\t// phase before making a connection attempt, but also add a\n\t\t// timeout to be safe against possible deadlocks.\n\n\t\tawait Promise.race([this.restoredBarrier.wait(), timeout(2000)]);\n\n\t\t// Acquire a message port connected to the shared process\n\t\tmark(\"code/willConnectSharedProcess\");\n\t\tthis.logService.trace(\n\t\t\t\"Renderer->SharedProcess#connect: before acquirePort\",\n\t\t);\n\t\tconst port = await acquirePort(\n\t\t\tSharedProcessChannelConnection.request,\n\t\t\tSharedProcessChannelConnection.response,\n\t\t);\n\t\tmark(\"code/didConnectSharedProcess\");\n\t\tthis.logService.trace(\n\t\t\t\"Renderer->SharedProcess#connect: connection established\",\n\t\t);\n\n\t\treturn this._register(\n\t\t\tnew MessagePortClient(port, `window:${this.windowId}`),\n\t\t);\n\t}\n\n\tnotifyRestored(): void {\n\t\tif (!this.restoredBarrier.isOpen()) {\n\t\t\tthis.restoredBarrier.open();\n\t\t}\n\t}\n\n\tgetChannel(channelName: string): IChannel {\n\t\treturn getDelayedChannel(\n\t\t\tthis.withSharedProcessConnection.then((connection) =>\n\t\t\t\tconnection.getChannel(channelName),\n\t\t\t),\n\t\t);\n\t}\n\n\tregisterChannel(\n\t\tchannelName: string,\n\t\tchannel: IServerChannel<string>,\n\t): void {\n\t\tthis.withSharedProcessConnection.then((connection) =>\n\t\t\tconnection.registerChannel(channelName, channel),\n\t\t);\n\t}\n\n\tasync createRawConnection(): Promise<MessagePort> {\n\t\t// Await initialization of the shared process\n\t\tawait this.withSharedProcessConnection;\n\n\t\t// Create a new port to the shared process\n\t\tthis.logService.trace(\n\t\t\t\"Renderer->SharedProcess#createRawConnection: before acquirePort\",\n\t\t);\n\t\tconst port = await acquirePort(\n\t\t\tSharedProcessRawConnection.request,\n\t\t\tSharedProcessRawConnection.response,\n\t\t);\n\t\tthis.logService.trace(\n\t\t\t\"Renderer->SharedProcess#createRawConnection: connection established\",\n\t\t);\n\n\t\treturn port;\n\t}\n}\n"],
  "mappings": ";;;;;;;;;;;;AAKA,SAAS,SAAS,eAAe;AACjC,SAAS,kBAAkB;AAC3B,SAAS,YAAY;AACrB;AAAA,EAGC;AAAA,OACM;AACP,SAAS,UAAU,yBAAyB;AAC5C,SAAS,mBAAmB;AAE5B,SAAS,mBAAmB;AAC5B;AAAA,EACC;AAAA,EACA;AAAA,OACM;AAEA,IAAM,uBAAN,cACE,WAET;AAAA,EAOC,YACU,UACqB,YAC7B;AACD,UAAM;AAHG;AACqB;AAI9B,SAAK,8BAA8B,KAAK,QAAQ;AAAA,EACjD;AAAA,EAvCD,OAyBA;AAAA;AAAA;AAAA,EAGkB;AAAA,EAEA,kBAAkB,IAAI,QAAQ;AAAA,EAW/C,MAAc,UAAsC;AACnD,SAAK,WAAW,MAAM,iCAAiC;AASvD,UAAM,QAAQ,KAAK,CAAC,KAAK,gBAAgB,KAAK,GAAG,QAAQ,GAAI,CAAC,CAAC;AAG/D,SAAK,+BAA+B;AACpC,SAAK,WAAW;AAAA,MACf;AAAA,IACD;AACA,UAAM,OAAO,MAAM;AAAA,MAClB,+BAA+B;AAAA,MAC/B,+BAA+B;AAAA,IAChC;AACA,SAAK,8BAA8B;AACnC,SAAK,WAAW;AAAA,MACf;AAAA,IACD;AAEA,WAAO,KAAK;AAAA,MACX,IAAI,kBAAkB,MAAM,UAAU,KAAK,QAAQ,EAAE;AAAA,IACtD;AAAA,EACD;AAAA,EAEA,iBAAuB;AACtB,QAAI,CAAC,KAAK,gBAAgB,OAAO,GAAG;AACnC,WAAK,gBAAgB,KAAK;AAAA,IAC3B;AAAA,EACD;AAAA,EAEA,WAAW,aAA+B;AACzC,WAAO;AAAA,MACN,KAAK,4BAA4B;AAAA,QAAK,CAAC,eACtC,WAAW,WAAW,WAAW;AAAA,MAClC;AAAA,IACD;AAAA,EACD;AAAA,EAEA,gBACC,aACA,SACO;AACP,SAAK,4BAA4B;AAAA,MAAK,CAAC,eACtC,WAAW,gBAAgB,aAAa,OAAO;AAAA,IAChD;AAAA,EACD;AAAA,EAEA,MAAM,sBAA4C;AAEjD,UAAM,KAAK;AAGX,SAAK,WAAW;AAAA,MACf;AAAA,IACD;AACA,UAAM,OAAO,MAAM;AAAA,MAClB,2BAA2B;AAAA,MAC3B,2BAA2B;AAAA,IAC5B;AACA,SAAK,WAAW;AAAA,MACf;AAAA,IACD;AAEA,WAAO;AAAA,EACR;AACD;AA3Fa,uBAAN;AAAA,EAYJ;AAAA,GAZU;",
  "names": []
}
