{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/sharedProcess/electron-sandbox/sharedProcessService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Client as MessagePortClient } from '../../../../base/parts/ipc/common/ipc.mp.js';\nimport { IChannel, IServerChannel, getDelayedChannel } from '../../../../base/parts/ipc/common/ipc.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { ISharedProcessService } from '../../../../platform/ipc/electron-sandbox/services.js';\nimport { SharedProcessChannelConnection, SharedProcessRawConnection } from '../../../../platform/sharedProcess/common/sharedProcess.js';\nimport { mark } from '../../../../base/common/performance.js';\nimport { Barrier, timeout } from '../../../../base/common/async.js';\nimport { acquirePort } from '../../../../base/parts/ipc/electron-sandbox/ipc.mp.js';\n\nexport class SharedProcessService extends Disposable implements ISharedProcessService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly withSharedProcessConnection: Promise<MessagePortClient>;\n\n\tprivate readonly restoredBarrier = new Barrier();\n\n\tconstructor(\n\t\treadonly windowId: number,\n\t\t@ILogService private readonly logService: ILogService\n\t) {\n\t\tsuper();\n\n\t\tthis.withSharedProcessConnection = this.connect();\n\t}\n\n\tprivate async connect(): Promise<MessagePortClient> {\n\t\tthis.logService.trace('Renderer->SharedProcess#connect');\n\n\t\t// Our performance tests show that a connection to the shared\n\t\t// process can have significant overhead to the startup time\n\t\t// of the window because the shared process could be created\n\t\t// as a result. As such, make sure we await the `Restored`\n\t\t// phase before making a connection attempt, but also add a\n\t\t// timeout to be safe against possible deadlocks.\n\n\t\tawait Promise.race([this.restoredBarrier.wait(), timeout(2000)]);\n\n\t\t// Acquire a message port connected to the shared process\n\t\tmark('code/willConnectSharedProcess');\n\t\tthis.logService.trace('Renderer->SharedProcess#connect: before acquirePort');\n\t\tconst port = await acquirePort(SharedProcessChannelConnection.request, SharedProcessChannelConnection.response);\n\t\tmark('code/didConnectSharedProcess');\n\t\tthis.logService.trace('Renderer->SharedProcess#connect: connection established');\n\n\t\treturn this._register(new MessagePortClient(port, `window:${this.windowId}`));\n\t}\n\n\tnotifyRestored(): void {\n\t\tif (!this.restoredBarrier.isOpen()) {\n\t\t\tthis.restoredBarrier.open();\n\t\t}\n\t}\n\n\tgetChannel(channelName: string): IChannel {\n\t\treturn getDelayedChannel(this.withSharedProcessConnection.then(connection => connection.getChannel(channelName)));\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<string>): void {\n\t\tthis.withSharedProcessConnection.then(connection => connection.registerChannel(channelName, channel));\n\t}\n\n\tasync createRawConnection(): Promise<MessagePort> {\n\n\t\t// Await initialization of the shared process\n\t\tawait this.withSharedProcessConnection;\n\n\t\t// Create a new port to the shared process\n\t\tthis.logService.trace('Renderer->SharedProcess#createRawConnection: before acquirePort');\n\t\tconst port = await acquirePort(SharedProcessRawConnection.request, SharedProcessRawConnection.response);\n\t\tthis.logService.trace('Renderer->SharedProcess#createRawConnection: connection established');\n\n\t\treturn port;\n\t}\n}\n"],
  "mappings": ";;;;;;;;;;;;AAKA,SAAS,UAAU,yBAAyB;AAC5C,SAAS,UAAU,gBAAgB,yBAAyB;AAC5D,SAAS,mBAAmB;AAC5B,SAAS,kBAAkB;AAC3B,SAAS,6BAA6B;AACtC,SAAS,gCAAgC,kCAAkC;AAC3E,SAAS,YAAY;AACrB,SAAS,SAAS,eAAe;AACjC,SAAS,mBAAmB;AAErB,IAAM,uBAAN,cAAmC,WAA4C;AAAA,EAQrF,YACU,UACqB,YAC7B;AACD,UAAM;AAHG;AACqB;AAI9B,SAAK,8BAA8B,KAAK,QAAQ;AAAA,EACjD;AAAA,EA9BD,OAesF;AAAA;AAAA;AAAA,EAIpE;AAAA,EAEA,kBAAkB,IAAI,QAAQ;AAAA,EAW/C,MAAc,UAAsC;AACnD,SAAK,WAAW,MAAM,iCAAiC;AASvD,UAAM,QAAQ,KAAK,CAAC,KAAK,gBAAgB,KAAK,GAAG,QAAQ,GAAI,CAAC,CAAC;AAG/D,SAAK,+BAA+B;AACpC,SAAK,WAAW,MAAM,qDAAqD;AAC3E,UAAM,OAAO,MAAM,YAAY,+BAA+B,SAAS,+BAA+B,QAAQ;AAC9G,SAAK,8BAA8B;AACnC,SAAK,WAAW,MAAM,yDAAyD;AAE/E,WAAO,KAAK,UAAU,IAAI,kBAAkB,MAAM,UAAU,KAAK,QAAQ,EAAE,CAAC;AAAA,EAC7E;AAAA,EAEA,iBAAuB;AACtB,QAAI,CAAC,KAAK,gBAAgB,OAAO,GAAG;AACnC,WAAK,gBAAgB,KAAK;AAAA,IAC3B;AAAA,EACD;AAAA,EAEA,WAAW,aAA+B;AACzC,WAAO,kBAAkB,KAAK,4BAA4B,KAAK,gBAAc,WAAW,WAAW,WAAW,CAAC,CAAC;AAAA,EACjH;AAAA,EAEA,gBAAgB,aAAqB,SAAuC;AAC3E,SAAK,4BAA4B,KAAK,gBAAc,WAAW,gBAAgB,aAAa,OAAO,CAAC;AAAA,EACrG;AAAA,EAEA,MAAM,sBAA4C;AAGjD,UAAM,KAAK;AAGX,SAAK,WAAW,MAAM,iEAAiE;AACvF,UAAM,OAAO,MAAM,YAAY,2BAA2B,SAAS,2BAA2B,QAAQ;AACtG,SAAK,WAAW,MAAM,qEAAqE;AAE3F,WAAO;AAAA,EACR;AACD;AAjEa,uBAAN;AAAA,EAUJ;AAAA,GAVU;",
  "names": []
}
