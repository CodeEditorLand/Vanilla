{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/suggest/browser/simpleCompletionModel.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { SimpleCompletionItem } from './simpleCompletionItem.js';\nimport { quickSelect } from '../../../../base/common/arrays.js';\nimport { CharCode } from '../../../../base/common/charCode.js';\nimport { FuzzyScore, fuzzyScore, fuzzyScoreGracefulAggressive, FuzzyScoreOptions, FuzzyScorer } from '../../../../base/common/filters.js';\nimport { isWindows } from '../../../../base/common/platform.js';\n\nexport interface ISimpleCompletionStats {\n\tpLabelLen: number;\n}\n\nexport class LineContext {\n\tconstructor(\n\t\treadonly leadingLineContent: string,\n\t\treadonly characterCountDelta: number,\n\t) { }\n}\n\nconst enum Refilter {\n\tNothing = 0,\n\tAll = 1,\n\tIncr = 2\n}\n\nexport class SimpleCompletionModel {\n\tprivate _stats?: ISimpleCompletionStats;\n\tprivate _filteredItems?: SimpleCompletionItem[];\n\tprivate _refilterKind: Refilter = Refilter.All;\n\tprivate _fuzzyScoreOptions: FuzzyScoreOptions | undefined = FuzzyScoreOptions.default;\n\n\t// TODO: Pass in options\n\tprivate _options: {\n\t\tfilterGraceful?: boolean;\n\t} = {};\n\n\tconstructor(\n\t\tprivate readonly _items: SimpleCompletionItem[],\n\t\tprivate _lineContext: LineContext,\n\t\treadonly replacementIndex: number,\n\t\treadonly replacementLength: number,\n\t) {\n\t}\n\n\tget items(): SimpleCompletionItem[] {\n\t\tthis._ensureCachedState();\n\t\treturn this._filteredItems!;\n\t}\n\n\tget stats(): ISimpleCompletionStats {\n\t\tthis._ensureCachedState();\n\t\treturn this._stats!;\n\t}\n\n\n\tget lineContext(): LineContext {\n\t\treturn this._lineContext;\n\t}\n\n\tset lineContext(value: LineContext) {\n\t\tif (this._lineContext.leadingLineContent !== value.leadingLineContent\n\t\t\t|| this._lineContext.characterCountDelta !== value.characterCountDelta\n\t\t) {\n\t\t\tthis._refilterKind = this._lineContext.characterCountDelta < value.characterCountDelta && this._filteredItems ? Refilter.Incr : Refilter.All;\n\t\t\tthis._lineContext = value;\n\t\t}\n\t}\n\n\tprivate _ensureCachedState(): void {\n\t\tif (this._refilterKind !== Refilter.Nothing) {\n\t\t\tthis._createCachedState();\n\t\t}\n\t}\n\tprivate _createCachedState(): void {\n\n\t\t// this._providerInfo = new Map();\n\n\t\tconst labelLengths: number[] = [];\n\n\t\tconst { leadingLineContent, characterCountDelta } = this._lineContext;\n\t\tlet word = '';\n\t\tlet wordLow = '';\n\n\t\t// incrementally filter less\n\t\tconst source = this._refilterKind === Refilter.All ? this._items : this._filteredItems!;\n\t\tconst target: SimpleCompletionItem[] = [];\n\n\t\t// picks a score function based on the number of\n\t\t// items that we have to score/filter and based on the\n\t\t// user-configuration\n\t\tconst scoreFn: FuzzyScorer = (!this._options.filterGraceful || source.length > 2000) ? fuzzyScore : fuzzyScoreGracefulAggressive;\n\n\t\tfor (let i = 0; i < source.length; i++) {\n\n\t\t\tconst item = source[i];\n\n\t\t\t// if (item.isInvalid) {\n\t\t\t// \tcontinue; // SKIP invalid items\n\t\t\t// }\n\n\t\t\t// collect all support, know if their result is incomplete\n\t\t\t// this._providerInfo.set(item.provider, Boolean(item.container.incomplete));\n\n\t\t\t// 'word' is that remainder of the current line that we\n\t\t\t// filter and score against. In theory each suggestion uses a\n\t\t\t// different word, but in practice not - that's why we cache\n\t\t\t// TODO: Fix\n\t\t\tconst overwriteBefore = this.replacementLength; // item.position.column - item.editStart.column;\n\t\t\tconst wordLen = overwriteBefore + characterCountDelta; // - (item.position.column - this._column);\n\t\t\tif (word.length !== wordLen) {\n\t\t\t\tword = wordLen === 0 ? '' : leadingLineContent.slice(-wordLen);\n\t\t\t\twordLow = word.toLowerCase();\n\t\t\t}\n\n\t\t\t// remember the word against which this item was\n\t\t\t// scored\n\t\t\titem.word = word;\n\n\t\t\tif (wordLen === 0) {\n\t\t\t\t// when there is nothing to score against, don't\n\t\t\t\t// event try to do. Use a const rank and rely on\n\t\t\t\t// the fallback-sort using the initial sort order.\n\t\t\t\t// use a score of `-100` because that is out of the\n\t\t\t\t// bound of values `fuzzyScore` will return\n\t\t\t\titem.score = FuzzyScore.Default;\n\n\t\t\t} else {\n\t\t\t\t// skip word characters that are whitespace until\n\t\t\t\t// we have hit the replace range (overwriteBefore)\n\t\t\t\tlet wordPos = 0;\n\t\t\t\twhile (wordPos < overwriteBefore) {\n\t\t\t\t\tconst ch = word.charCodeAt(wordPos);\n\t\t\t\t\tif (ch === CharCode.Space || ch === CharCode.Tab) {\n\t\t\t\t\t\twordPos += 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (wordPos >= wordLen) {\n\t\t\t\t\t// the wordPos at which scoring starts is the whole word\n\t\t\t\t\t// and therefore the same rules as not having a word apply\n\t\t\t\t\titem.score = FuzzyScore.Default;\n\n\t\t\t\t\t// } else if (typeof item.completion.filterText === 'string') {\n\t\t\t\t\t// \t// when there is a `filterText` it must match the `word`.\n\t\t\t\t\t// \t// if it matches we check with the label to compute highlights\n\t\t\t\t\t// \t// and if that doesn't yield a result we have no highlights,\n\t\t\t\t\t// \t// despite having the match\n\t\t\t\t\t// \tconst match = scoreFn(word, wordLow, wordPos, item.completion.filterText, item.filterTextLow!, 0, this._fuzzyScoreOptions);\n\t\t\t\t\t// \tif (!match) {\n\t\t\t\t\t// \t\tcontinue; // NO match\n\t\t\t\t\t// \t}\n\t\t\t\t\t// \tif (compareIgnoreCase(item.completion.filterText, item.textLabel) === 0) {\n\t\t\t\t\t// \t\t// filterText and label are actually the same -> use good highlights\n\t\t\t\t\t// \t\titem.score = match;\n\t\t\t\t\t// \t} else {\n\t\t\t\t\t// \t\t// re-run the scorer on the label in the hope of a result BUT use the rank\n\t\t\t\t\t// \t\t// of the filterText-match\n\t\t\t\t\t// \t\titem.score = anyScore(word, wordLow, wordPos, item.textLabel, item.labelLow, 0);\n\t\t\t\t\t// \t\titem.score[0] = match[0]; // use score from filterText\n\t\t\t\t\t// \t}\n\n\t\t\t\t} else {\n\t\t\t\t\t// by default match `word` against the `label`\n\t\t\t\t\tconst match = scoreFn(word, wordLow, wordPos, item.completion.label, item.labelLow, 0, this._fuzzyScoreOptions);\n\t\t\t\t\tif (!match) {\n\t\t\t\t\t\tcontinue; // NO match\n\t\t\t\t\t}\n\t\t\t\t\titem.score = match;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\titem.idx = i;\n\t\t\ttarget.push(item);\n\n\t\t\t// update stats\n\t\t\tlabelLengths.push(item.completion.label.length);\n\t\t}\n\n\t\tthis._filteredItems = target.sort((a, b) => {\n\t\t\t// Keywords should always appear at the bottom when they are not an exact match\n\t\t\tlet score = 0;\n\t\t\tif (a.completion.isKeyword && a.labelLow !== wordLow || b.completion.isKeyword && b.labelLow !== wordLow) {\n\t\t\t\tscore = (a.completion.isKeyword ? 1 : 0) - (b.completion.isKeyword ? 1 : 0);\n\t\t\t\tif (score !== 0) {\n\t\t\t\t\treturn score;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort by the score\n\t\t\tscore = b.score[0] - a.score[0];\n\t\t\tif (score !== 0) {\n\t\t\t\treturn score;\n\t\t\t}\n\t\t\t// Sort files with the same score against each other specially\n\t\t\tconst isArg = leadingLineContent.includes(' ');\n\t\t\tif (!isArg && a.fileExtLow.length > 0 && b.fileExtLow.length > 0) {\n\t\t\t\t// Then by label length ascending (excluding file extension if it's a file)\n\t\t\t\tscore = a.labelLowExcludeFileExt.length - b.labelLowExcludeFileExt.length;\n\t\t\t\tif (score !== 0) {\n\t\t\t\t\treturn score;\n\t\t\t\t}\n\t\t\t\t// If they're files at the start of the command line, boost extensions depending on the operating system\n\t\t\t\tscore = fileExtScore(b.fileExtLow) - fileExtScore(a.fileExtLow);\n\t\t\t\tif (score !== 0) {\n\t\t\t\t\treturn score;\n\t\t\t\t}\n\t\t\t\t// Then by file extension length ascending\n\t\t\t\tscore = a.fileExtLow.length - b.fileExtLow.length;\n\t\t\t}\n\t\t\treturn score;\n\t\t});\n\t\tthis._refilterKind = Refilter.Nothing;\n\n\t\tthis._stats = {\n\t\t\tpLabelLen: labelLengths.length ?\n\t\t\t\tquickSelect(labelLengths.length - .85, labelLengths, (a, b) => a - b)\n\t\t\t\t: 0\n\t\t};\n\t}\n}\n\n// TODO: This should be based on the process OS, not the local OS\n// File score boosts for specific file extensions on Windows. This only applies when the file is the\n// _first_ part of the command line.\nconst fileExtScores = new Map<string, number>(isWindows ? [\n\t// Windows - .ps1 > .exe > .bat > .cmd. This is the command precedence when running the files\n\t//           without an extension, tested manually in pwsh v7.4.4\n\t['ps1', 0.09],\n\t['exe', 0.08],\n\t['bat', 0.07],\n\t['cmd', 0.07],\n\t// Non-Windows\n\t['sh', -0.05],\n\t['bash', -0.05],\n\t['zsh', -0.05],\n\t['fish', -0.05],\n\t['csh', -0.06], // C shell\n\t['ksh', -0.06], // Korn shell\n\t// Scripting language files are excluded here as the standard behavior on Windows will just open\n\t// the file in a text editor, not run the file\n] : [\n\t// Pwsh\n\t['ps1', 0.05],\n\t// Windows\n\t['bat', -0.05],\n\t['cmd', -0.05],\n\t['exe', -0.05],\n\t// Non-Windows\n\t['sh', 0.05],\n\t['bash', 0.05],\n\t['zsh', 0.05],\n\t['fish', 0.05],\n\t['csh', 0.04], // C shell\n\t['ksh', 0.04], // Korn shell\n\t// Scripting languages\n\t['py', 0.05], // Python\n\t['pl', 0.05], // Perl\n]);\n\nfunction fileExtScore(ext: string): number {\n\treturn fileExtScores.get(ext) || 0;\n}\n"],
  "mappings": "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",
  "names": ["Refilter"]
}
