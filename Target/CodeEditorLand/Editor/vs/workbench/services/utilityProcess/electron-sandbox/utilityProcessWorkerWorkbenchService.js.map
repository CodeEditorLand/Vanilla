{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/services/utilityProcess/electron-sandbox/utilityProcessWorkerWorkbenchService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Barrier, timeout } from \"../../../../base/common/async.js\";\nimport {\n\tDisposable,\n\tDisposableStore,\n\ttype IDisposable,\n\ttoDisposable,\n} from \"../../../../base/common/lifecycle.js\";\nimport { generateUuid } from \"../../../../base/common/uuid.js\";\nimport {\n\ttype IPCClient,\n\tProxyChannel,\n} from \"../../../../base/parts/ipc/common/ipc.js\";\nimport { Client as MessagePortClient } from \"../../../../base/parts/ipc/common/ipc.mp.js\";\nimport { acquirePort } from \"../../../../base/parts/ipc/electron-sandbox/ipc.mp.js\";\nimport { createDecorator } from \"../../../../platform/instantiation/common/instantiation.js\";\nimport { IMainProcessService } from \"../../../../platform/ipc/common/mainProcessService.js\";\nimport { ILogService } from \"../../../../platform/log/common/log.js\";\nimport {\n\ttype IOnDidTerminateUtilityrocessWorkerProcess,\n\ttype IUtilityProcessWorkerProcess,\n\ttype IUtilityProcessWorkerService,\n\tipcUtilityProcessWorkerChannelName,\n} from \"../../../../platform/utilityProcess/common/utilityProcessWorkerService.js\";\n\nexport const IUtilityProcessWorkerWorkbenchService =\n\tcreateDecorator<IUtilityProcessWorkerWorkbenchService>(\n\t\t\"utilityProcessWorkerWorkbenchService\",\n\t);\n\nexport interface IUtilityProcessWorker extends IDisposable {\n\t/**\n\t * A IPC client to communicate to the worker process.\n\t */\n\tclient: IPCClient<string>;\n\n\t/**\n\t * A promise that resolves to an object once the\n\t * worker process terminates, giving information\n\t * how the process terminated.\n\t *\n\t * This can be used to figure out whether the worker\n\t * should be restarted in case of an unexpected\n\t * termination.\n\t */\n\tonDidTerminate: Promise<IOnDidTerminateUtilityrocessWorkerProcess>;\n}\n\nexport interface IUtilityProcessWorkerWorkbenchService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Will fork a new process with the provided module identifier in a utility\n\t * process and establishes a message port connection to that process.\n\t *\n\t * Requires the forked process to be AMD module that uses our IPC channel framework\n\t * to respond to the provided `channelName` as a server.\n\t *\n\t * The process will be automatically terminated when the workbench window closes,\n\t * crashes or loads/reloads.\n\t *\n\t * Note on affinity: repeated calls to `createWorkerChannel` with the same `moduleId`\n\t * from the same window will result in any previous forked process to get terminated.\n\t * In other words, it is not possible, nor intended to create multiple workers of\n\t * the same process from one window. The intent of these workers is to be reused per\n\t * window and the communication channel allows to dynamically update the processes\n\t * after the fact.\n\t *\n\t * @param process information around the process to fork as worker\n\t *\n\t * @returns the worker IPC client to communicate with. Provides a `dispose` method that\n\t * allows to terminate the worker if needed.\n\t */\n\tcreateWorker(\n\t\tprocess: IUtilityProcessWorkerProcess,\n\t): Promise<IUtilityProcessWorker>;\n\n\t/**\n\t * Notifies the service that the workbench window has restored.\n\t */\n\tnotifyRestored(): void;\n}\n\nexport class UtilityProcessWorkerWorkbenchService\n\textends Disposable\n\timplements IUtilityProcessWorkerWorkbenchService\n{\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate _utilityProcessWorkerService:\n\t\t| IUtilityProcessWorkerService\n\t\t| undefined = undefined;\n\tprivate get utilityProcessWorkerService(): IUtilityProcessWorkerService {\n\t\tif (!this._utilityProcessWorkerService) {\n\t\t\tconst channel = this.mainProcessService.getChannel(\n\t\t\t\tipcUtilityProcessWorkerChannelName,\n\t\t\t);\n\t\t\tthis._utilityProcessWorkerService =\n\t\t\t\tProxyChannel.toService<IUtilityProcessWorkerService>(channel);\n\t\t}\n\n\t\treturn this._utilityProcessWorkerService;\n\t}\n\n\tprivate readonly restoredBarrier = new Barrier();\n\n\tconstructor(\n\t\treadonly windowId: number,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IMainProcessService private readonly mainProcessService: IMainProcessService\n\t) {\n\t\tsuper();\n\t}\n\n\tasync createWorker(\n\t\tprocess: IUtilityProcessWorkerProcess,\n\t): Promise<IUtilityProcessWorker> {\n\t\tthis.logService.trace(\"Renderer->UtilityProcess#createWorker\");\n\n\t\t// We want to avoid heavy utility process work to happen before\n\t\t// the window has restored. As such, make sure we await the\n\t\t// `Restored` phase before making a connection attempt, but also\n\t\t// add a timeout to be safe against possible deadlocks.\n\n\t\tawait Promise.race([this.restoredBarrier.wait(), timeout(2000)]);\n\n\t\t// Get ready to acquire the message port from the utility process worker\n\t\tconst nonce = generateUuid();\n\t\tconst responseChannel =\n\t\t\t\"vscode:createUtilityProcessWorkerMessageChannelResult\";\n\t\tconst portPromise = acquirePort(\n\t\t\tundefined /* we trigger the request via service call! */,\n\t\t\tresponseChannel,\n\t\t\tnonce,\n\t\t);\n\n\t\t// Actually talk with the utility process service\n\t\t// to create a new process from a worker\n\t\tconst onDidTerminate = this.utilityProcessWorkerService.createWorker({\n\t\t\tprocess,\n\t\t\treply: { windowId: this.windowId, channel: responseChannel, nonce },\n\t\t});\n\n\t\t// Dispose worker upon disposal via utility process service\n\t\tconst disposables = new DisposableStore();\n\t\tdisposables.add(\n\t\t\ttoDisposable(() => {\n\t\t\t\tthis.logService.trace(\n\t\t\t\t\t\"Renderer->UtilityProcess#disposeWorker\",\n\t\t\t\t\tprocess,\n\t\t\t\t);\n\n\t\t\t\tthis.utilityProcessWorkerService.disposeWorker({\n\t\t\t\t\tprocess,\n\t\t\t\t\treply: { windowId: this.windowId },\n\t\t\t\t});\n\t\t\t}),\n\t\t);\n\n\t\tconst port = await portPromise;\n\t\tconst client = disposables.add(\n\t\t\tnew MessagePortClient(\n\t\t\t\tport,\n\t\t\t\t`window:${this.windowId},module:${process.moduleId}`,\n\t\t\t),\n\t\t);\n\t\tthis.logService.trace(\n\t\t\t\"Renderer->UtilityProcess#createWorkerChannel: connection established\",\n\t\t);\n\n\t\tonDidTerminate.then(({ reason }) => {\n\t\t\tif (reason?.code === 0) {\n\t\t\t\tthis.logService.trace(\n\t\t\t\t\t`[UtilityProcessWorker]: terminated normally with code ${reason.code}, signal: ${reason.signal}`,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthis.logService.error(\n\t\t\t\t\t`[UtilityProcessWorker]: terminated unexpectedly with code ${reason?.code}, signal: ${reason?.signal}`,\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\n\t\treturn { client, onDidTerminate, dispose: () => disposables.dispose() };\n\t}\n\n\tnotifyRestored(): void {\n\t\tif (!this.restoredBarrier.isOpen()) {\n\t\t\tthis.restoredBarrier.open();\n\t\t}\n\t}\n}\n"],
  "mappings": ";;;;;;;;;;;;AAKA,SAAS,SAAS,eAAe;AACjC;AAAA,EACC;AAAA,EACA;AAAA,EAEA;AAAA,OACM;AACP,SAAS,oBAAoB;AAC7B;AAAA,EAEC;AAAA,OACM;AACP,SAAS,UAAU,yBAAyB;AAC5C,SAAS,mBAAmB;AAC5B,SAAS,uBAAuB;AAChC,SAAS,2BAA2B;AACpC,SAAS,mBAAmB;AAC5B;AAAA,EAIC;AAAA,OACM;AAEA,MAAM,wCACZ;AAAA,EACC;AACD;AAuDM,IAAM,uCAAN,cACE,WAET;AAAA,EAoBC,YACU,UACqB,YACQ,oBACrC;AACD,UAAM;AAJG;AACqB;AACQ;AAAA,EAGvC;AAAA,EApHD,OA0FA;AAAA;AAAA;AAAA,EAGS,+BAEO;AAAA,EACf,IAAY,8BAA4D;AACvE,QAAI,CAAC,KAAK,8BAA8B;AACvC,YAAM,UAAU,KAAK,mBAAmB;AAAA,QACvC;AAAA,MACD;AACA,WAAK,+BACJ,aAAa,UAAwC,OAAO;AAAA,IAC9D;AAEA,WAAO,KAAK;AAAA,EACb;AAAA,EAEiB,kBAAkB,IAAI,QAAQ;AAAA,EAU/C,MAAM,aACL,SACiC;AACjC,SAAK,WAAW,MAAM,uCAAuC;AAO7D,UAAM,QAAQ,KAAK,CAAC,KAAK,gBAAgB,KAAK,GAAG,QAAQ,GAAI,CAAC,CAAC;AAG/D,UAAM,QAAQ,aAAa;AAC3B,UAAM,kBACL;AACD,UAAM,cAAc;AAAA,MACnB;AAAA,MACA;AAAA,MACA;AAAA,IACD;AAIA,UAAM,iBAAiB,KAAK,4BAA4B,aAAa;AAAA,MACpE;AAAA,MACA,OAAO,EAAE,UAAU,KAAK,UAAU,SAAS,iBAAiB,MAAM;AAAA,IACnE,CAAC;AAGD,UAAM,cAAc,IAAI,gBAAgB;AACxC,gBAAY;AAAA,MACX,aAAa,MAAM;AAClB,aAAK,WAAW;AAAA,UACf;AAAA,UACA;AAAA,QACD;AAEA,aAAK,4BAA4B,cAAc;AAAA,UAC9C;AAAA,UACA,OAAO,EAAE,UAAU,KAAK,SAAS;AAAA,QAClC,CAAC;AAAA,MACF,CAAC;AAAA,IACF;AAEA,UAAM,OAAO,MAAM;AACnB,UAAM,SAAS,YAAY;AAAA,MAC1B,IAAI;AAAA,QACH;AAAA,QACA,UAAU,KAAK,QAAQ,WAAW,QAAQ,QAAQ;AAAA,MACnD;AAAA,IACD;AACA,SAAK,WAAW;AAAA,MACf;AAAA,IACD;AAEA,mBAAe,KAAK,CAAC,EAAE,OAAO,MAAM;AACnC,UAAI,QAAQ,SAAS,GAAG;AACvB,aAAK,WAAW;AAAA,UACf,yDAAyD,OAAO,IAAI,aAAa,OAAO,MAAM;AAAA,QAC/F;AAAA,MACD,OAAO;AACN,aAAK,WAAW;AAAA,UACf,6DAA6D,QAAQ,IAAI,aAAa,QAAQ,MAAM;AAAA,QACrG;AAAA,MACD;AAAA,IACD,CAAC;AAED,WAAO,EAAE,QAAQ,gBAAgB,SAAS,6BAAM,YAAY,QAAQ,GAA1B,WAA4B;AAAA,EACvE;AAAA,EAEA,iBAAuB;AACtB,QAAI,CAAC,KAAK,gBAAgB,OAAO,GAAG;AACnC,WAAK,gBAAgB,KAAK;AAAA,IAC3B;AAAA,EACD;AACD;AA3Ga,uCAAN;AAAA,EAyBJ;AAAA,EACA;AAAA,GA1BU;",
  "names": []
}
