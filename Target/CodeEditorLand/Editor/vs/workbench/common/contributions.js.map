{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/common/contributions.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport {\n\tDeferredPromise,\n\ttype IdleDeadline,\n\trunWhenGlobalIdle,\n} from \"../../base/common/async.js\";\nimport {\n\tDisposable,\n\tDisposableStore,\n\tisDisposable,\n} from \"../../base/common/lifecycle.js\";\nimport { getOrSet } from \"../../base/common/map.js\";\nimport { mark } from \"../../base/common/performance.js\";\nimport { IEnvironmentService } from \"../../platform/environment/common/environment.js\";\nimport {\n\ttype BrandedService,\n\ttype IConstructorSignature,\n\tIInstantiationService,\n\ttype ServicesAccessor,\n} from \"../../platform/instantiation/common/instantiation.js\";\nimport { ILogService } from \"../../platform/log/common/log.js\";\nimport { Registry } from \"../../platform/registry/common/platform.js\";\nimport { IEditorPaneService } from \"../services/editor/common/editorPaneService.js\";\nimport {\n\tILifecycleService,\n\tLifecyclePhase,\n} from \"../services/lifecycle/common/lifecycle.js\";\n\n/**\n * A workbench contribution that will be loaded when the workbench starts and disposed when the workbench shuts down.\n */\nexport type IWorkbenchContribution = {};\n\nexport namespace Extensions {\n\t/**\n\t * @deprecated use `registerWorkbenchContribution2` instead.\n\t */\n\texport const Workbench = \"workbench.contributions.kind\";\n}\n\nexport enum WorkbenchPhase {\n\t/**\n\t * The first phase signals that we are about to startup getting ready.\n\t *\n\t * Note: doing work in this phase blocks an editor from showing to\n\t * the user, so please rather consider to use the other types, preferable\n\t * `Lazy` to only instantiate the contribution when really needed.\n\t */\n\tBlockStartup = LifecyclePhase.Starting,\n\n\t/**\n\t * Services are ready and the window is about to restore its UI state.\n\t *\n\t * Note: doing work in this phase blocks an editor from showing to\n\t * the user, so please rather consider to use the other types, preferable\n\t * `Lazy` to only instantiate the contribution when really needed.\n\t */\n\tBlockRestore = LifecyclePhase.Ready,\n\n\t/**\n\t * Views, panels and editors have restored. Editors are given a bit of\n\t * time to restore their contents.\n\t */\n\tAfterRestored = LifecyclePhase.Restored,\n\n\t/**\n\t * The last phase after views, panels and editors have restored and\n\t * some time has passed (2-5 seconds).\n\t */\n\tEventually = LifecyclePhase.Eventually,\n}\n\n/**\n * A workbenchch contribution that will only be instantiated\n * when calling `getWorkbenchContribution`.\n */\nexport interface ILazyWorkbenchContributionInstantiation {\n\treadonly lazy: true;\n}\n\n/**\n * A workbench contribution that will be instantiated when the\n * corresponding editor is being created.\n */\nexport interface IOnEditorWorkbenchContributionInstantiation {\n\treadonly editorTypeId: string;\n}\n\nfunction isOnEditorWorkbenchContributionInstantiation(\n\tobj: unknown,\n): obj is IOnEditorWorkbenchContributionInstantiation {\n\tconst candidate = obj as\n\t\t| IOnEditorWorkbenchContributionInstantiation\n\t\t| undefined;\n\treturn !!candidate && typeof candidate.editorTypeId === \"string\";\n}\n\nexport type WorkbenchContributionInstantiation =\n\t| WorkbenchPhase\n\t| ILazyWorkbenchContributionInstantiation\n\t| IOnEditorWorkbenchContributionInstantiation;\n\nfunction toWorkbenchPhase(\n\tphase: LifecyclePhase.Restored | LifecyclePhase.Eventually,\n): WorkbenchPhase.AfterRestored | WorkbenchPhase.Eventually {\n\tswitch (phase) {\n\t\tcase LifecyclePhase.Restored:\n\t\t\treturn WorkbenchPhase.AfterRestored;\n\t\tcase LifecyclePhase.Eventually:\n\t\t\treturn WorkbenchPhase.Eventually;\n\t}\n}\n\nfunction toLifecyclePhase(instantiation: WorkbenchPhase): LifecyclePhase {\n\tswitch (instantiation) {\n\t\tcase WorkbenchPhase.BlockStartup:\n\t\t\treturn LifecyclePhase.Starting;\n\t\tcase WorkbenchPhase.BlockRestore:\n\t\t\treturn LifecyclePhase.Ready;\n\t\tcase WorkbenchPhase.AfterRestored:\n\t\t\treturn LifecyclePhase.Restored;\n\t\tcase WorkbenchPhase.Eventually:\n\t\t\treturn LifecyclePhase.Eventually;\n\t}\n}\n\ntype IWorkbenchContributionSignature<Service extends BrandedService[]> = new (\n\t...services: Service\n) => IWorkbenchContribution;\n\nexport interface IWorkbenchContributionsRegistry {\n\t/**\n\t * @deprecated use `registerWorkbenchContribution2` instead.\n\t */\n\tregisterWorkbenchContribution<Services extends BrandedService[]>(\n\t\tcontribution: IWorkbenchContributionSignature<Services>,\n\t\tphase: LifecyclePhase.Restored | LifecyclePhase.Eventually,\n\t): void;\n\n\t/**\n\t * Starts the registry by providing the required services.\n\t */\n\tstart(accessor: ServicesAccessor): void;\n\n\t/**\n\t * A promise that resolves when all contributions up to the `Restored`\n\t * phase have been instantiated.\n\t */\n\treadonly whenRestored: Promise<void>;\n\n\t/**\n\t * Provides access to the instantiation times of all contributions by\n\t * lifecycle phase.\n\t */\n\treadonly timings: Map<\n\t\tLifecyclePhase,\n\t\tArray<[string /* ID */, number /* Creation Time */]>\n\t>;\n}\n\ninterface IWorkbenchContributionRegistration {\n\treadonly id: string | undefined;\n\treadonly ctor: IConstructorSignature<IWorkbenchContribution>;\n}\n\nexport class WorkbenchContributionsRegistry\n\textends Disposable\n\timplements IWorkbenchContributionsRegistry\n{\n\tstatic readonly INSTANCE = new WorkbenchContributionsRegistry();\n\n\tprivate static readonly BLOCK_BEFORE_RESTORE_WARN_THRESHOLD = 20;\n\tprivate static readonly BLOCK_AFTER_RESTORE_WARN_THRESHOLD = 100;\n\n\tprivate instantiationService: IInstantiationService | undefined;\n\tprivate lifecycleService: ILifecycleService | undefined;\n\tprivate logService: ILogService | undefined;\n\tprivate environmentService: IEnvironmentService | undefined;\n\tprivate editorPaneService: IEditorPaneService | undefined;\n\n\tprivate readonly contributionsByPhase = new Map<\n\t\tLifecyclePhase,\n\t\tIWorkbenchContributionRegistration[]\n\t>();\n\tprivate readonly contributionsByEditor = new Map<\n\t\tstring,\n\t\tIWorkbenchContributionRegistration[]\n\t>();\n\tprivate readonly contributionsById = new Map<\n\t\tstring,\n\t\tIWorkbenchContributionRegistration\n\t>();\n\n\tprivate readonly instancesById = new Map<string, IWorkbenchContribution>();\n\tprivate readonly instanceDisposables = this._register(\n\t\tnew DisposableStore(),\n\t);\n\n\tprivate readonly timingsByPhase = new Map<\n\t\tLifecyclePhase,\n\t\tArray<[string /* ID */, number /* Creation Time */]>\n\t>();\n\tget timings() {\n\t\treturn this.timingsByPhase;\n\t}\n\n\tprivate readonly pendingRestoredContributions = new DeferredPromise<void>();\n\treadonly whenRestored = this.pendingRestoredContributions.p;\n\n\tregisterWorkbenchContribution2(\n\t\tid: string,\n\t\tctor: IConstructorSignature<IWorkbenchContribution>,\n\t\tphase: WorkbenchPhase.BlockStartup | WorkbenchPhase.BlockRestore,\n\t): void;\n\tregisterWorkbenchContribution2(\n\t\tid: string | undefined,\n\t\tctor: IConstructorSignature<IWorkbenchContribution>,\n\t\tphase: WorkbenchPhase.AfterRestored | WorkbenchPhase.Eventually,\n\t): void;\n\tregisterWorkbenchContribution2(\n\t\tid: string,\n\t\tctor: IConstructorSignature<IWorkbenchContribution>,\n\t\tlazy: ILazyWorkbenchContributionInstantiation,\n\t): void;\n\tregisterWorkbenchContribution2(\n\t\tid: string,\n\t\tctor: IConstructorSignature<IWorkbenchContribution>,\n\t\tonEditor: IOnEditorWorkbenchContributionInstantiation,\n\t): void;\n\tregisterWorkbenchContribution2(\n\t\tid: string | undefined,\n\t\tctor: IConstructorSignature<IWorkbenchContribution>,\n\t\tinstantiation: WorkbenchContributionInstantiation,\n\t): void {\n\t\tconst contribution: IWorkbenchContributionRegistration = { id, ctor };\n\n\t\t// Instantiate directly if we already have a matching instantiation condition\n\t\tif (\n\t\t\tthis.instantiationService &&\n\t\t\tthis.lifecycleService &&\n\t\t\tthis.logService &&\n\t\t\tthis.environmentService &&\n\t\t\tthis.editorPaneService &&\n\t\t\t((typeof instantiation === \"number\" &&\n\t\t\t\tthis.lifecycleService.phase >= instantiation) ||\n\t\t\t\t(typeof id === \"string\" &&\n\t\t\t\t\tisOnEditorWorkbenchContributionInstantiation(\n\t\t\t\t\t\tinstantiation,\n\t\t\t\t\t) &&\n\t\t\t\t\tthis.editorPaneService.didInstantiateEditorPane(\n\t\t\t\t\t\tinstantiation.editorTypeId,\n\t\t\t\t\t)))\n\t\t) {\n\t\t\tthis.safeCreateContribution(\n\t\t\t\tthis.instantiationService,\n\t\t\t\tthis.logService,\n\t\t\t\tthis.environmentService,\n\t\t\t\tcontribution,\n\t\t\t\ttypeof instantiation === \"number\"\n\t\t\t\t\t? toLifecyclePhase(instantiation)\n\t\t\t\t\t: this.lifecycleService.phase,\n\t\t\t);\n\t\t}\n\n\t\t// Otherwise keep contributions by instantiation kind for later instantiation\n\t\telse {\n\t\t\t// by phase\n\t\t\tif (typeof instantiation === \"number\") {\n\t\t\t\tgetOrSet(\n\t\t\t\t\tthis.contributionsByPhase,\n\t\t\t\t\ttoLifecyclePhase(instantiation),\n\t\t\t\t\t[],\n\t\t\t\t).push(contribution);\n\t\t\t}\n\n\t\t\tif (typeof id === \"string\") {\n\t\t\t\t// by id\n\t\t\t\tif (this.contributionsById.has(id)) {\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t`IWorkbenchContributionsRegistry#registerWorkbenchContribution(): Can't register multiple contributions with same id '${id}'`,\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tthis.contributionsById.set(id, contribution);\n\t\t\t\t}\n\n\t\t\t\t// by editor\n\t\t\t\tif (\n\t\t\t\t\tisOnEditorWorkbenchContributionInstantiation(instantiation)\n\t\t\t\t) {\n\t\t\t\t\tgetOrSet(\n\t\t\t\t\t\tthis.contributionsByEditor,\n\t\t\t\t\t\tinstantiation.editorTypeId,\n\t\t\t\t\t\t[],\n\t\t\t\t\t).push(contribution);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tregisterWorkbenchContribution(\n\t\tctor: IConstructorSignature<IWorkbenchContribution>,\n\t\tphase: LifecyclePhase.Restored | LifecyclePhase.Eventually,\n\t): void {\n\t\tthis.registerWorkbenchContribution2(\n\t\t\tundefined,\n\t\t\tctor,\n\t\t\ttoWorkbenchPhase(phase),\n\t\t);\n\t}\n\n\tgetWorkbenchContribution<T extends IWorkbenchContribution>(id: string): T {\n\t\tif (this.instancesById.has(id)) {\n\t\t\treturn this.instancesById.get(id) as T;\n\t\t}\n\n\t\tconst instantiationService = this.instantiationService;\n\t\tconst lifecycleService = this.lifecycleService;\n\t\tconst logService = this.logService;\n\t\tconst environmentService = this.environmentService;\n\t\tif (\n\t\t\t!instantiationService ||\n\t\t\t!lifecycleService ||\n\t\t\t!logService ||\n\t\t\t!environmentService\n\t\t) {\n\t\t\tthrow new Error(\n\t\t\t\t`IWorkbenchContributionsRegistry#getContribution('${id}'): cannot be called before registry started`,\n\t\t\t);\n\t\t}\n\n\t\tconst contribution = this.contributionsById.get(id);\n\t\tif (!contribution) {\n\t\t\tthrow new Error(\n\t\t\t\t`IWorkbenchContributionsRegistry#getContribution('${id}'): contribution with that identifier is unknown.`,\n\t\t\t);\n\t\t}\n\n\t\tif (lifecycleService.phase < LifecyclePhase.Restored) {\n\t\t\tlogService.warn(\n\t\t\t\t`IWorkbenchContributionsRegistry#getContribution('${id}'): contribution instantiated before LifecyclePhase.Restored!`,\n\t\t\t);\n\t\t}\n\n\t\tthis.safeCreateContribution(\n\t\t\tinstantiationService,\n\t\t\tlogService,\n\t\t\tenvironmentService,\n\t\t\tcontribution,\n\t\t\tlifecycleService.phase,\n\t\t);\n\n\t\tconst instance = this.instancesById.get(id);\n\t\tif (!instance) {\n\t\t\tthrow new Error(\n\t\t\t\t`IWorkbenchContributionsRegistry#getContribution('${id}'): failed to create contribution.`,\n\t\t\t);\n\t\t}\n\n\t\treturn instance as T;\n\t}\n\n\tstart(accessor: ServicesAccessor): void {\n\t\tconst instantiationService = (this.instantiationService = accessor.get(\n\t\t\tIInstantiationService,\n\t\t));\n\t\tconst lifecycleService = (this.lifecycleService =\n\t\t\taccessor.get(ILifecycleService));\n\t\tconst logService = (this.logService = accessor.get(ILogService));\n\t\tconst environmentService = (this.environmentService =\n\t\t\taccessor.get(IEnvironmentService));\n\t\tconst editorPaneService = (this.editorPaneService =\n\t\t\taccessor.get(IEditorPaneService));\n\n\t\t// Dispose contributions on shutdown\n\t\tthis._register(\n\t\t\tlifecycleService.onDidShutdown(() => {\n\t\t\t\tthis.instanceDisposables.clear();\n\t\t\t}),\n\t\t);\n\n\t\t// Instantiate contributions by phase when they are ready\n\t\tfor (const phase of [\n\t\t\tLifecyclePhase.Starting,\n\t\t\tLifecyclePhase.Ready,\n\t\t\tLifecyclePhase.Restored,\n\t\t\tLifecyclePhase.Eventually,\n\t\t]) {\n\t\t\tthis.instantiateByPhase(\n\t\t\t\tinstantiationService,\n\t\t\t\tlifecycleService,\n\t\t\t\tlogService,\n\t\t\t\tenvironmentService,\n\t\t\t\tphase,\n\t\t\t);\n\t\t}\n\n\t\t// Instantiate contributions by editor when they are created or have been\n\t\tfor (const editorTypeId of this.contributionsByEditor.keys()) {\n\t\t\tif (editorPaneService.didInstantiateEditorPane(editorTypeId)) {\n\t\t\t\tthis.onEditor(\n\t\t\t\t\teditorTypeId,\n\t\t\t\t\tinstantiationService,\n\t\t\t\t\tlifecycleService,\n\t\t\t\t\tlogService,\n\t\t\t\t\tenvironmentService,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tthis._register(\n\t\t\teditorPaneService.onWillInstantiateEditorPane((e) =>\n\t\t\t\tthis.onEditor(\n\t\t\t\t\te.typeId,\n\t\t\t\t\tinstantiationService,\n\t\t\t\t\tlifecycleService,\n\t\t\t\t\tlogService,\n\t\t\t\t\tenvironmentService,\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\t}\n\n\tprivate onEditor(\n\t\teditorTypeId: string,\n\t\tinstantiationService: IInstantiationService,\n\t\tlifecycleService: ILifecycleService,\n\t\tlogService: ILogService,\n\t\tenvironmentService: IEnvironmentService,\n\t): void {\n\t\tconst contributions = this.contributionsByEditor.get(editorTypeId);\n\t\tif (contributions) {\n\t\t\tthis.contributionsByEditor.delete(editorTypeId);\n\n\t\t\tfor (const contribution of contributions) {\n\t\t\t\tthis.safeCreateContribution(\n\t\t\t\t\tinstantiationService,\n\t\t\t\t\tlogService,\n\t\t\t\t\tenvironmentService,\n\t\t\t\t\tcontribution,\n\t\t\t\t\tlifecycleService.phase,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate instantiateByPhase(\n\t\tinstantiationService: IInstantiationService,\n\t\tlifecycleService: ILifecycleService,\n\t\tlogService: ILogService,\n\t\tenvironmentService: IEnvironmentService,\n\t\tphase: LifecyclePhase,\n\t): void {\n\t\t// Instantiate contributions directly when phase is already reached\n\t\tif (lifecycleService.phase >= phase) {\n\t\t\tthis.doInstantiateByPhase(\n\t\t\t\tinstantiationService,\n\t\t\t\tlogService,\n\t\t\t\tenvironmentService,\n\t\t\t\tphase,\n\t\t\t);\n\t\t}\n\n\t\t// Otherwise wait for phase to be reached\n\t\telse {\n\t\t\tlifecycleService\n\t\t\t\t.when(phase)\n\t\t\t\t.then(() =>\n\t\t\t\t\tthis.doInstantiateByPhase(\n\t\t\t\t\t\tinstantiationService,\n\t\t\t\t\t\tlogService,\n\t\t\t\t\t\tenvironmentService,\n\t\t\t\t\t\tphase,\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t}\n\t}\n\n\tprivate async doInstantiateByPhase(\n\t\tinstantiationService: IInstantiationService,\n\t\tlogService: ILogService,\n\t\tenvironmentService: IEnvironmentService,\n\t\tphase: LifecyclePhase,\n\t): Promise<void> {\n\t\tconst contributions = this.contributionsByPhase.get(phase);\n\t\tif (contributions) {\n\t\t\tthis.contributionsByPhase.delete(phase);\n\n\t\t\tswitch (phase) {\n\t\t\t\tcase LifecyclePhase.Starting:\n\t\t\t\tcase LifecyclePhase.Ready: {\n\t\t\t\t\t// instantiate everything synchronously and blocking\n\t\t\t\t\t// measure the time it takes as perf marks for diagnosis\n\n\t\t\t\t\tmark(`code/willCreateWorkbenchContributions/${phase}`);\n\n\t\t\t\t\tfor (const contribution of contributions) {\n\t\t\t\t\t\tthis.safeCreateContribution(\n\t\t\t\t\t\t\tinstantiationService,\n\t\t\t\t\t\t\tlogService,\n\t\t\t\t\t\t\tenvironmentService,\n\t\t\t\t\t\t\tcontribution,\n\t\t\t\t\t\t\tphase,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tmark(`code/didCreateWorkbenchContributions/${phase}`);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase LifecyclePhase.Restored:\n\t\t\t\tcase LifecyclePhase.Eventually: {\n\t\t\t\t\t// for the Restored/Eventually-phase we instantiate contributions\n\t\t\t\t\t// only when idle. this might take a few idle-busy-cycles but will\n\t\t\t\t\t// finish within the timeouts\n\t\t\t\t\t// given that, we must ensure to await the contributions from the\n\t\t\t\t\t// Restored-phase before we instantiate the Eventually-phase\n\n\t\t\t\t\tif (phase === LifecyclePhase.Eventually) {\n\t\t\t\t\t\tawait this.pendingRestoredContributions.p;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.doInstantiateWhenIdle(\n\t\t\t\t\t\tcontributions,\n\t\t\t\t\t\tinstantiationService,\n\t\t\t\t\t\tlogService,\n\t\t\t\t\t\tenvironmentService,\n\t\t\t\t\t\tphase,\n\t\t\t\t\t);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate doInstantiateWhenIdle(\n\t\tcontributions: IWorkbenchContributionRegistration[],\n\t\tinstantiationService: IInstantiationService,\n\t\tlogService: ILogService,\n\t\tenvironmentService: IEnvironmentService,\n\t\tphase: LifecyclePhase,\n\t): void {\n\t\tmark(`code/willCreateWorkbenchContributions/${phase}`);\n\n\t\tlet i = 0;\n\t\tconst forcedTimeout = phase === LifecyclePhase.Eventually ? 3000 : 500;\n\n\t\tconst instantiateSome = (idle: IdleDeadline) => {\n\t\t\twhile (i < contributions.length) {\n\t\t\t\tconst contribution = contributions[i++];\n\t\t\t\tthis.safeCreateContribution(\n\t\t\t\t\tinstantiationService,\n\t\t\t\t\tlogService,\n\t\t\t\t\tenvironmentService,\n\t\t\t\t\tcontribution,\n\t\t\t\t\tphase,\n\t\t\t\t);\n\t\t\t\tif (idle.timeRemaining() < 1) {\n\t\t\t\t\t// time is up -> reschedule\n\t\t\t\t\trunWhenGlobalIdle(instantiateSome, forcedTimeout);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (i === contributions.length) {\n\t\t\t\tmark(`code/didCreateWorkbenchContributions/${phase}`);\n\n\t\t\t\tif (phase === LifecyclePhase.Restored) {\n\t\t\t\t\tthis.pendingRestoredContributions.complete();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\trunWhenGlobalIdle(instantiateSome, forcedTimeout);\n\t}\n\n\tprivate safeCreateContribution(\n\t\tinstantiationService: IInstantiationService,\n\t\tlogService: ILogService,\n\t\tenvironmentService: IEnvironmentService,\n\t\tcontribution: IWorkbenchContributionRegistration,\n\t\tphase: LifecyclePhase,\n\t): void {\n\t\tif (\n\t\t\ttypeof contribution.id === \"string\" &&\n\t\t\tthis.instancesById.has(contribution.id)\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst now = Date.now();\n\n\t\ttry {\n\t\t\tif (typeof contribution.id === \"string\") {\n\t\t\t\tmark(\n\t\t\t\t\t`code/willCreateWorkbenchContribution/${phase}/${contribution.id}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst instance = instantiationService.createInstance(\n\t\t\t\tcontribution.ctor,\n\t\t\t);\n\t\t\tif (typeof contribution.id === \"string\") {\n\t\t\t\tthis.instancesById.set(contribution.id, instance);\n\t\t\t\tthis.contributionsById.delete(contribution.id);\n\t\t\t}\n\t\t\tif (isDisposable(instance)) {\n\t\t\t\tthis.instanceDisposables.add(instance);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogService.error(\n\t\t\t\t`Unable to create workbench contribution '${contribution.id ?? contribution.ctor.name}'.`,\n\t\t\t\terror,\n\t\t\t);\n\t\t} finally {\n\t\t\tif (typeof contribution.id === \"string\") {\n\t\t\t\tmark(\n\t\t\t\t\t`code/didCreateWorkbenchContribution/${phase}/${contribution.id}`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tif (\n\t\t\ttypeof contribution.id === \"string\" ||\n\t\t\t!environmentService.isBuilt /* only log out of sources where we have good ctor names */\n\t\t) {\n\t\t\tconst time = Date.now() - now;\n\t\t\tif (\n\t\t\t\ttime >\n\t\t\t\t(phase < LifecyclePhase.Restored\n\t\t\t\t\t? WorkbenchContributionsRegistry.BLOCK_BEFORE_RESTORE_WARN_THRESHOLD\n\t\t\t\t\t: WorkbenchContributionsRegistry.BLOCK_AFTER_RESTORE_WARN_THRESHOLD)\n\t\t\t) {\n\t\t\t\tlogService.warn(\n\t\t\t\t\t`Creation of workbench contribution '${contribution.id ?? contribution.ctor.name}' took ${time}ms.`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (typeof contribution.id === \"string\") {\n\t\t\t\tlet timingsForPhase = this.timingsByPhase.get(phase);\n\t\t\t\tif (!timingsForPhase) {\n\t\t\t\t\ttimingsForPhase = [];\n\t\t\t\t\tthis.timingsByPhase.set(phase, timingsForPhase);\n\t\t\t\t}\n\n\t\t\t\ttimingsForPhase.push([contribution.id, time]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Register a workbench contribution that will be instantiated\n * based on the `instantiation` property.\n */\nexport const registerWorkbenchContribution2 =\n\tWorkbenchContributionsRegistry.INSTANCE.registerWorkbenchContribution2.bind(\n\t\tWorkbenchContributionsRegistry.INSTANCE,\n\t) as {\n\t\t<Services extends BrandedService[]>(\n\t\t\tid: string,\n\t\t\tctor: IWorkbenchContributionSignature<Services>,\n\t\t\tinstantiation: WorkbenchContributionInstantiation,\n\t\t): void;\n\t};\n\n/**\n * Provides access to a workbench contribution with a specific identifier.\n * The contribution is created if not yet done.\n *\n * Note: will throw an error if\n * - called too early before the registry has started\n * - no contribution is known for the given identifier\n */\nexport const getWorkbenchContribution =\n\tWorkbenchContributionsRegistry.INSTANCE.getWorkbenchContribution.bind(\n\t\tWorkbenchContributionsRegistry.INSTANCE,\n\t);\n\nRegistry.add(Extensions.Workbench, WorkbenchContributionsRegistry.INSTANCE);\n"],
  "mappings": "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",
  "names": ["Extensions", "WorkbenchPhase"]
}
