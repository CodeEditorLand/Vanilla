{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/common/contributions.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IInstantiationService, IConstructorSignature, ServicesAccessor, BrandedService } from '../../platform/instantiation/common/instantiation.js';\nimport { ILifecycleService, LifecyclePhase } from '../services/lifecycle/common/lifecycle.js';\nimport { Registry } from '../../platform/registry/common/platform.js';\nimport { IdleDeadline, DeferredPromise, runWhenGlobalIdle } from '../../base/common/async.js';\nimport { mark } from '../../base/common/performance.js';\nimport { ILogService } from '../../platform/log/common/log.js';\nimport { IEnvironmentService } from '../../platform/environment/common/environment.js';\nimport { getOrSet } from '../../base/common/map.js';\nimport { Disposable, DisposableStore, isDisposable } from '../../base/common/lifecycle.js';\nimport { IEditorPaneService } from '../services/editor/common/editorPaneService.js';\n\n/**\n * A workbench contribution that will be loaded when the workbench starts and disposed when the workbench shuts down.\n */\nexport interface IWorkbenchContribution {\n\t// Marker Interface\n}\n\nexport namespace Extensions {\n\t/**\n\t * @deprecated use `registerWorkbenchContribution2` instead.\n\t */\n\texport const Workbench = 'workbench.contributions.kind';\n}\n\nexport const enum WorkbenchPhase {\n\n\t/**\n\t * The first phase signals that we are about to startup getting ready.\n\t *\n\t * Note: doing work in this phase blocks an editor from showing to\n\t * the user, so please rather consider to use the other types, preferable\n\t * `Lazy` to only instantiate the contribution when really needed.\n\t */\n\tBlockStartup = LifecyclePhase.Starting,\n\n\t/**\n\t * Services are ready and the window is about to restore its UI state.\n\t *\n\t * Note: doing work in this phase blocks an editor from showing to\n\t * the user, so please rather consider to use the other types, preferable\n\t * `Lazy` to only instantiate the contribution when really needed.\n\t */\n\tBlockRestore = LifecyclePhase.Ready,\n\n\t/**\n\t * Views, panels and editors have restored. Editors are given a bit of\n\t * time to restore their contents.\n\t */\n\tAfterRestored = LifecyclePhase.Restored,\n\n\t/**\n\t * The last phase after views, panels and editors have restored and\n\t * some time has passed (2-5 seconds).\n\t */\n\tEventually = LifecyclePhase.Eventually\n}\n\n/**\n * A workbenchch contribution that will only be instantiated\n * when calling `getWorkbenchContribution`.\n */\nexport interface ILazyWorkbenchContributionInstantiation {\n\treadonly lazy: true;\n}\n\n/**\n * A workbench contribution that will be instantiated when the\n * corresponding editor is being created.\n */\nexport interface IOnEditorWorkbenchContributionInstantiation {\n\treadonly editorTypeId: string;\n}\n\nfunction isOnEditorWorkbenchContributionInstantiation(obj: unknown): obj is IOnEditorWorkbenchContributionInstantiation {\n\tconst candidate = obj as IOnEditorWorkbenchContributionInstantiation | undefined;\n\treturn !!candidate && typeof candidate.editorTypeId === 'string';\n}\n\nexport type WorkbenchContributionInstantiation = WorkbenchPhase | ILazyWorkbenchContributionInstantiation | IOnEditorWorkbenchContributionInstantiation;\n\nfunction toWorkbenchPhase(phase: LifecyclePhase.Restored | LifecyclePhase.Eventually): WorkbenchPhase.AfterRestored | WorkbenchPhase.Eventually {\n\tswitch (phase) {\n\t\tcase LifecyclePhase.Restored:\n\t\t\treturn WorkbenchPhase.AfterRestored;\n\t\tcase LifecyclePhase.Eventually:\n\t\t\treturn WorkbenchPhase.Eventually;\n\t}\n}\n\nfunction toLifecyclePhase(instantiation: WorkbenchPhase): LifecyclePhase {\n\tswitch (instantiation) {\n\t\tcase WorkbenchPhase.BlockStartup:\n\t\t\treturn LifecyclePhase.Starting;\n\t\tcase WorkbenchPhase.BlockRestore:\n\t\t\treturn LifecyclePhase.Ready;\n\t\tcase WorkbenchPhase.AfterRestored:\n\t\t\treturn LifecyclePhase.Restored;\n\t\tcase WorkbenchPhase.Eventually:\n\t\t\treturn LifecyclePhase.Eventually;\n\t}\n}\n\ntype IWorkbenchContributionSignature<Service extends BrandedService[]> = new (...services: Service) => IWorkbenchContribution;\n\nexport interface IWorkbenchContributionsRegistry {\n\n\t/**\n\t * @deprecated use `registerWorkbenchContribution2` instead.\n\t */\n\tregisterWorkbenchContribution<Services extends BrandedService[]>(contribution: IWorkbenchContributionSignature<Services>, phase: LifecyclePhase.Restored | LifecyclePhase.Eventually): void;\n\n\t/**\n\t * Starts the registry by providing the required services.\n\t */\n\tstart(accessor: ServicesAccessor): void;\n\n\t/**\n\t * A promise that resolves when all contributions up to the `Restored`\n\t * phase have been instantiated.\n\t */\n\treadonly whenRestored: Promise<void>;\n\n\t/**\n\t * Provides access to the instantiation times of all contributions by\n\t * lifecycle phase.\n\t */\n\treadonly timings: Map<LifecyclePhase, Array<[string /* ID */, number /* Creation Time */]>>;\n}\n\ninterface IWorkbenchContributionRegistration {\n\treadonly id: string | undefined;\n\treadonly ctor: IConstructorSignature<IWorkbenchContribution>;\n}\n\nexport class WorkbenchContributionsRegistry extends Disposable implements IWorkbenchContributionsRegistry {\n\n\tstatic readonly INSTANCE = new WorkbenchContributionsRegistry();\n\n\tprivate static readonly BLOCK_BEFORE_RESTORE_WARN_THRESHOLD = 20;\n\tprivate static readonly BLOCK_AFTER_RESTORE_WARN_THRESHOLD = 100;\n\n\tprivate instantiationService: IInstantiationService | undefined;\n\tprivate lifecycleService: ILifecycleService | undefined;\n\tprivate logService: ILogService | undefined;\n\tprivate environmentService: IEnvironmentService | undefined;\n\tprivate editorPaneService: IEditorPaneService | undefined;\n\n\tprivate readonly contributionsByPhase = new Map<LifecyclePhase, IWorkbenchContributionRegistration[]>();\n\tprivate readonly contributionsByEditor = new Map<string, IWorkbenchContributionRegistration[]>();\n\tprivate readonly contributionsById = new Map<string, IWorkbenchContributionRegistration>();\n\n\tprivate readonly instancesById = new Map<string, IWorkbenchContribution>();\n\tprivate readonly instanceDisposables = this._register(new DisposableStore());\n\n\tprivate readonly timingsByPhase = new Map<LifecyclePhase, Array<[string /* ID */, number /* Creation Time */]>>();\n\tget timings() { return this.timingsByPhase; }\n\n\tprivate readonly pendingRestoredContributions = new DeferredPromise<void>();\n\treadonly whenRestored = this.pendingRestoredContributions.p;\n\n\tregisterWorkbenchContribution2(id: string, ctor: IConstructorSignature<IWorkbenchContribution>, phase: WorkbenchPhase.BlockStartup | WorkbenchPhase.BlockRestore): void;\n\tregisterWorkbenchContribution2(id: string | undefined, ctor: IConstructorSignature<IWorkbenchContribution>, phase: WorkbenchPhase.AfterRestored | WorkbenchPhase.Eventually): void;\n\tregisterWorkbenchContribution2(id: string, ctor: IConstructorSignature<IWorkbenchContribution>, lazy: ILazyWorkbenchContributionInstantiation): void;\n\tregisterWorkbenchContribution2(id: string, ctor: IConstructorSignature<IWorkbenchContribution>, onEditor: IOnEditorWorkbenchContributionInstantiation): void;\n\tregisterWorkbenchContribution2(id: string | undefined, ctor: IConstructorSignature<IWorkbenchContribution>, instantiation: WorkbenchContributionInstantiation): void {\n\t\tconst contribution: IWorkbenchContributionRegistration = { id, ctor };\n\n\t\t// Instantiate directly if we already have a matching instantiation condition\n\t\tif (\n\t\t\tthis.instantiationService && this.lifecycleService && this.logService && this.environmentService && this.editorPaneService &&\n\t\t\t(\n\t\t\t\t(typeof instantiation === 'number' && this.lifecycleService.phase >= instantiation) ||\n\t\t\t\t(typeof id === 'string' && isOnEditorWorkbenchContributionInstantiation(instantiation) && this.editorPaneService.didInstantiateEditorPane(instantiation.editorTypeId))\n\t\t\t)\n\t\t) {\n\t\t\tthis.safeCreateContribution(this.instantiationService, this.logService, this.environmentService, contribution, typeof instantiation === 'number' ? toLifecyclePhase(instantiation) : this.lifecycleService.phase);\n\t\t}\n\n\t\t// Otherwise keep contributions by instantiation kind for later instantiation\n\t\telse {\n\n\t\t\t// by phase\n\t\t\tif (typeof instantiation === 'number') {\n\t\t\t\tgetOrSet(this.contributionsByPhase, toLifecyclePhase(instantiation), []).push(contribution);\n\t\t\t}\n\n\t\t\tif (typeof id === 'string') {\n\n\t\t\t\t// by id\n\t\t\t\tif (!this.contributionsById.has(id)) {\n\t\t\t\t\tthis.contributionsById.set(id, contribution);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error(`IWorkbenchContributionsRegistry#registerWorkbenchContribution(): Can't register multiple contributions with same id '${id}'`);\n\t\t\t\t}\n\n\t\t\t\t// by editor\n\t\t\t\tif (isOnEditorWorkbenchContributionInstantiation(instantiation)) {\n\t\t\t\t\tgetOrSet(this.contributionsByEditor, instantiation.editorTypeId, []).push(contribution);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tregisterWorkbenchContribution(ctor: IConstructorSignature<IWorkbenchContribution>, phase: LifecyclePhase.Restored | LifecyclePhase.Eventually): void {\n\t\tthis.registerWorkbenchContribution2(undefined, ctor, toWorkbenchPhase(phase));\n\t}\n\n\tgetWorkbenchContribution<T extends IWorkbenchContribution>(id: string): T {\n\t\tif (this.instancesById.has(id)) {\n\t\t\treturn this.instancesById.get(id) as T;\n\t\t}\n\n\t\tconst instantiationService = this.instantiationService;\n\t\tconst lifecycleService = this.lifecycleService;\n\t\tconst logService = this.logService;\n\t\tconst environmentService = this.environmentService;\n\t\tif (!instantiationService || !lifecycleService || !logService || !environmentService) {\n\t\t\tthrow new Error(`IWorkbenchContributionsRegistry#getContribution('${id}'): cannot be called before registry started`);\n\t\t}\n\n\t\tconst contribution = this.contributionsById.get(id);\n\t\tif (!contribution) {\n\t\t\tthrow new Error(`IWorkbenchContributionsRegistry#getContribution('${id}'): contribution with that identifier is unknown.`);\n\t\t}\n\n\t\tif (lifecycleService.phase < LifecyclePhase.Restored) {\n\t\t\tlogService.warn(`IWorkbenchContributionsRegistry#getContribution('${id}'): contribution instantiated before LifecyclePhase.Restored!`);\n\t\t}\n\n\t\tthis.safeCreateContribution(instantiationService, logService, environmentService, contribution, lifecycleService.phase);\n\n\t\tconst instance = this.instancesById.get(id);\n\t\tif (!instance) {\n\t\t\tthrow new Error(`IWorkbenchContributionsRegistry#getContribution('${id}'): failed to create contribution.`);\n\t\t}\n\n\t\treturn instance as T;\n\t}\n\n\tstart(accessor: ServicesAccessor): void {\n\t\tconst instantiationService = this.instantiationService = accessor.get(IInstantiationService);\n\t\tconst lifecycleService = this.lifecycleService = accessor.get(ILifecycleService);\n\t\tconst logService = this.logService = accessor.get(ILogService);\n\t\tconst environmentService = this.environmentService = accessor.get(IEnvironmentService);\n\t\tconst editorPaneService = this.editorPaneService = accessor.get(IEditorPaneService);\n\n\t\t// Dispose contributions on shutdown\n\t\tthis._register(lifecycleService.onDidShutdown(() => {\n\t\t\tthis.instanceDisposables.clear();\n\t\t}));\n\n\t\t// Instantiate contributions by phase when they are ready\n\t\tfor (const phase of [LifecyclePhase.Starting, LifecyclePhase.Ready, LifecyclePhase.Restored, LifecyclePhase.Eventually]) {\n\t\t\tthis.instantiateByPhase(instantiationService, lifecycleService, logService, environmentService, phase);\n\t\t}\n\n\t\t// Instantiate contributions by editor when they are created or have been\n\t\tfor (const editorTypeId of this.contributionsByEditor.keys()) {\n\t\t\tif (editorPaneService.didInstantiateEditorPane(editorTypeId)) {\n\t\t\t\tthis.onEditor(editorTypeId, instantiationService, lifecycleService, logService, environmentService);\n\t\t\t}\n\t\t}\n\t\tthis._register(editorPaneService.onWillInstantiateEditorPane(e => this.onEditor(e.typeId, instantiationService, lifecycleService, logService, environmentService)));\n\t}\n\n\tprivate onEditor(editorTypeId: string, instantiationService: IInstantiationService, lifecycleService: ILifecycleService, logService: ILogService, environmentService: IEnvironmentService): void {\n\t\tconst contributions = this.contributionsByEditor.get(editorTypeId);\n\t\tif (contributions) {\n\t\t\tthis.contributionsByEditor.delete(editorTypeId);\n\n\t\t\tfor (const contribution of contributions) {\n\t\t\t\tthis.safeCreateContribution(instantiationService, logService, environmentService, contribution, lifecycleService.phase);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate instantiateByPhase(instantiationService: IInstantiationService, lifecycleService: ILifecycleService, logService: ILogService, environmentService: IEnvironmentService, phase: LifecyclePhase): void {\n\n\t\t// Instantiate contributions directly when phase is already reached\n\t\tif (lifecycleService.phase >= phase) {\n\t\t\tthis.doInstantiateByPhase(instantiationService, logService, environmentService, phase);\n\t\t}\n\n\t\t// Otherwise wait for phase to be reached\n\t\telse {\n\t\t\tlifecycleService.when(phase).then(() => this.doInstantiateByPhase(instantiationService, logService, environmentService, phase));\n\t\t}\n\t}\n\n\tprivate async doInstantiateByPhase(instantiationService: IInstantiationService, logService: ILogService, environmentService: IEnvironmentService, phase: LifecyclePhase): Promise<void> {\n\t\tconst contributions = this.contributionsByPhase.get(phase);\n\t\tif (contributions) {\n\t\t\tthis.contributionsByPhase.delete(phase);\n\n\t\t\tswitch (phase) {\n\t\t\t\tcase LifecyclePhase.Starting:\n\t\t\t\tcase LifecyclePhase.Ready: {\n\n\t\t\t\t\t// instantiate everything synchronously and blocking\n\t\t\t\t\t// measure the time it takes as perf marks for diagnosis\n\n\t\t\t\t\tmark(`code/willCreateWorkbenchContributions/${phase}`);\n\n\t\t\t\t\tfor (const contribution of contributions) {\n\t\t\t\t\t\tthis.safeCreateContribution(instantiationService, logService, environmentService, contribution, phase);\n\t\t\t\t\t}\n\n\t\t\t\t\tmark(`code/didCreateWorkbenchContributions/${phase}`);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase LifecyclePhase.Restored:\n\t\t\t\tcase LifecyclePhase.Eventually: {\n\n\t\t\t\t\t// for the Restored/Eventually-phase we instantiate contributions\n\t\t\t\t\t// only when idle. this might take a few idle-busy-cycles but will\n\t\t\t\t\t// finish within the timeouts\n\t\t\t\t\t// given that, we must ensure to await the contributions from the\n\t\t\t\t\t// Restored-phase before we instantiate the Eventually-phase\n\n\t\t\t\t\tif (phase === LifecyclePhase.Eventually) {\n\t\t\t\t\t\tawait this.pendingRestoredContributions.p;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.doInstantiateWhenIdle(contributions, instantiationService, logService, environmentService, phase);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate doInstantiateWhenIdle(contributions: IWorkbenchContributionRegistration[], instantiationService: IInstantiationService, logService: ILogService, environmentService: IEnvironmentService, phase: LifecyclePhase): void {\n\t\tmark(`code/willCreateWorkbenchContributions/${phase}`);\n\n\t\tlet i = 0;\n\t\tconst forcedTimeout = phase === LifecyclePhase.Eventually ? 3000 : 500;\n\n\t\tconst instantiateSome = (idle: IdleDeadline) => {\n\t\t\twhile (i < contributions.length) {\n\t\t\t\tconst contribution = contributions[i++];\n\t\t\t\tthis.safeCreateContribution(instantiationService, logService, environmentService, contribution, phase);\n\t\t\t\tif (idle.timeRemaining() < 1) {\n\t\t\t\t\t// time is up -> reschedule\n\t\t\t\t\trunWhenGlobalIdle(instantiateSome, forcedTimeout);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (i === contributions.length) {\n\t\t\t\tmark(`code/didCreateWorkbenchContributions/${phase}`);\n\n\t\t\t\tif (phase === LifecyclePhase.Restored) {\n\t\t\t\t\tthis.pendingRestoredContributions.complete();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\trunWhenGlobalIdle(instantiateSome, forcedTimeout);\n\t}\n\n\tprivate safeCreateContribution(instantiationService: IInstantiationService, logService: ILogService, environmentService: IEnvironmentService, contribution: IWorkbenchContributionRegistration, phase: LifecyclePhase): void {\n\t\tif (typeof contribution.id === 'string' && this.instancesById.has(contribution.id)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst now = Date.now();\n\n\t\ttry {\n\t\t\tif (typeof contribution.id === 'string') {\n\t\t\t\tmark(`code/willCreateWorkbenchContribution/${phase}/${contribution.id}`);\n\t\t\t}\n\n\t\t\tconst instance = instantiationService.createInstance(contribution.ctor);\n\t\t\tif (typeof contribution.id === 'string') {\n\t\t\t\tthis.instancesById.set(contribution.id, instance);\n\t\t\t\tthis.contributionsById.delete(contribution.id);\n\t\t\t}\n\t\t\tif (isDisposable(instance)) {\n\t\t\t\tthis.instanceDisposables.add(instance);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogService.error(`Unable to create workbench contribution '${contribution.id ?? contribution.ctor.name}'.`, error);\n\t\t} finally {\n\t\t\tif (typeof contribution.id === 'string') {\n\t\t\t\tmark(`code/didCreateWorkbenchContribution/${phase}/${contribution.id}`);\n\t\t\t}\n\t\t}\n\n\t\tif (typeof contribution.id === 'string' || !environmentService.isBuilt /* only log out of sources where we have good ctor names */) {\n\t\t\tconst time = Date.now() - now;\n\t\t\tif (time > (phase < LifecyclePhase.Restored ? WorkbenchContributionsRegistry.BLOCK_BEFORE_RESTORE_WARN_THRESHOLD : WorkbenchContributionsRegistry.BLOCK_AFTER_RESTORE_WARN_THRESHOLD)) {\n\t\t\t\tlogService.warn(`Creation of workbench contribution '${contribution.id ?? contribution.ctor.name}' took ${time}ms.`);\n\t\t\t}\n\n\t\t\tif (typeof contribution.id === 'string') {\n\t\t\t\tlet timingsForPhase = this.timingsByPhase.get(phase);\n\t\t\t\tif (!timingsForPhase) {\n\t\t\t\t\ttimingsForPhase = [];\n\t\t\t\t\tthis.timingsByPhase.set(phase, timingsForPhase);\n\t\t\t\t}\n\n\t\t\t\ttimingsForPhase.push([contribution.id, time]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Register a workbench contribution that will be instantiated\n * based on the `instantiation` property.\n */\nexport const registerWorkbenchContribution2 = WorkbenchContributionsRegistry.INSTANCE.registerWorkbenchContribution2.bind(WorkbenchContributionsRegistry.INSTANCE) as {\n\t<Services extends BrandedService[]>(id: string, ctor: IWorkbenchContributionSignature<Services>, instantiation: WorkbenchContributionInstantiation): void;\n};\n\n/**\n * Provides access to a workbench contribution with a specific identifier.\n * The contribution is created if not yet done.\n *\n * Note: will throw an error if\n * - called too early before the registry has started\n * - no contribution is known for the given identifier\n */\nexport const getWorkbenchContribution = WorkbenchContributionsRegistry.INSTANCE.getWorkbenchContribution.bind(WorkbenchContributionsRegistry.INSTANCE);\n\nRegistry.add(Extensions.Workbench, WorkbenchContributionsRegistry.INSTANCE);\n"],
  "mappings": "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",
  "names": ["Extensions", "WorkbenchPhase"]
}
