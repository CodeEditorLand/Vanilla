{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/common/editor.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { localize } from '../../nls.js';\nimport { Event } from '../../base/common/event.js';\nimport { DeepRequiredNonNullable, assertIsDefined } from '../../base/common/types.js';\nimport { URI } from '../../base/common/uri.js';\nimport { Disposable, IDisposable, toDisposable } from '../../base/common/lifecycle.js';\nimport { ICodeEditorViewState, IDiffEditor, IDiffEditorViewState, IEditor, IEditorViewState } from '../../editor/common/editorCommon.js';\nimport { IEditorOptions, IResourceEditorInput, ITextResourceEditorInput, IBaseTextResourceEditorInput, IBaseUntypedEditorInput, ITextEditorOptions } from '../../platform/editor/common/editor.js';\nimport type { EditorInput } from './editor/editorInput.js';\nimport { IInstantiationService, IConstructorSignature, ServicesAccessor, BrandedService } from '../../platform/instantiation/common/instantiation.js';\nimport { IContextKeyService } from '../../platform/contextkey/common/contextkey.js';\nimport { Registry } from '../../platform/registry/common/platform.js';\nimport { IEncodingSupport, ILanguageSupport } from '../services/textfile/common/textfiles.js';\nimport { IEditorGroup } from '../services/editor/common/editorGroupsService.js';\nimport { ICompositeControl, IComposite } from './composite.js';\nimport { FileType, IFileReadLimits, IFileService } from '../../platform/files/common/files.js';\nimport { IPathData } from '../../platform/window/common/window.js';\nimport { IExtUri } from '../../base/common/resources.js';\nimport { Schemas } from '../../base/common/network.js';\nimport { IEditorService } from '../services/editor/common/editorService.js';\nimport { ILogService } from '../../platform/log/common/log.js';\nimport { IErrorWithActions, createErrorWithActions, isErrorWithActions } from '../../base/common/errorMessage.js';\nimport { IAction, toAction } from '../../base/common/actions.js';\nimport Severity from '../../base/common/severity.js';\nimport { IPreferencesService } from '../services/preferences/common/preferences.js';\nimport { IReadonlyEditorGroupModel } from './editor/editorGroupModel.js';\n\n// Static values for editor contributions\nexport const EditorExtensions = {\n\tEditorPane: 'workbench.contributions.editors',\n\tEditorFactory: 'workbench.contributions.editor.inputFactories'\n};\n\n// Static information regarding the text editor\nexport const DEFAULT_EDITOR_ASSOCIATION = {\n\tid: 'default',\n\tdisplayName: localize('promptOpenWith.defaultEditor.displayName', \"Text Editor\"),\n\tproviderDisplayName: localize('builtinProviderDisplayName', \"Built-in\")\n};\n\n/**\n * Side by side editor id.\n */\nexport const SIDE_BY_SIDE_EDITOR_ID = 'workbench.editor.sidebysideEditor';\n\n/**\n * Text diff editor id.\n */\nexport const TEXT_DIFF_EDITOR_ID = 'workbench.editors.textDiffEditor';\n\n/**\n * Binary diff editor id.\n */\nexport const BINARY_DIFF_EDITOR_ID = 'workbench.editors.binaryResourceDiffEditor';\n\nexport interface IEditorDescriptor<T extends IEditorPane> {\n\n\t/**\n\t * The unique type identifier of the editor. All instances\n\t * of the same `IEditorPane` should have the same type\n\t * identifier.\n\t */\n\treadonly typeId: string;\n\n\t/**\n\t * The display name of the editor.\n\t */\n\treadonly name: string;\n\n\t/**\n\t * Instantiates the editor pane using the provided services.\n\t */\n\tinstantiate(instantiationService: IInstantiationService, group: IEditorGroup): T;\n\n\t/**\n\t * Whether the descriptor is for the provided editor pane.\n\t */\n\tdescribes(editorPane: T): boolean;\n}\n\n/**\n * The editor pane is the container for workbench editors.\n */\nexport interface IEditorPane extends IComposite {\n\n\t/**\n\t * An event to notify when the `IEditorControl` in this\n\t * editor pane changes.\n\t *\n\t * This can be used for editor panes that are a compound\n\t * of multiple editor controls to signal that the active\n\t * editor control has changed when the user clicks around.\n\t */\n\treadonly onDidChangeControl: Event<void>;\n\n\t/**\n\t * An optional event to notify when the selection inside the editor\n\t * pane changed in case the editor has a selection concept.\n\t *\n\t * For example, in a text editor pane, the selection changes whenever\n\t * the cursor is set to a new location.\n\t */\n\treadonly onDidChangeSelection?: Event<IEditorPaneSelectionChangeEvent>;\n\n\t/**\n\t * An optional event to notify when the editor inside the pane scrolled\n\t */\n\treadonly onDidChangeScroll?: Event<void>;\n\n\t/**\n\t * The assigned input of this editor.\n\t */\n\treadonly input: EditorInput | undefined;\n\n\t/**\n\t * The assigned options of the editor.\n\t */\n\treadonly options: IEditorOptions | undefined;\n\n\t/**\n\t * The assigned group this editor is showing in.\n\t */\n\treadonly group: IEditorGroup;\n\n\t/**\n\t * The minimum width of this editor.\n\t */\n\treadonly minimumWidth: number;\n\n\t/**\n\t * The maximum width of this editor.\n\t */\n\treadonly maximumWidth: number;\n\n\t/**\n\t * The minimum height of this editor.\n\t */\n\treadonly minimumHeight: number;\n\n\t/**\n\t * The maximum height of this editor.\n\t */\n\treadonly maximumHeight: number;\n\n\t/**\n\t * An event to notify whenever minimum/maximum width/height changes.\n\t */\n\treadonly onDidChangeSizeConstraints: Event<{ width: number; height: number } | undefined>;\n\n\t/**\n\t * The context key service for this editor. Should be overridden by\n\t * editors that have their own ScopedContextKeyService\n\t */\n\treadonly scopedContextKeyService: IContextKeyService | undefined;\n\n\t/**\n\t * Returns the underlying control of this editor. Callers need to cast\n\t * the control to a specific instance as needed, e.g. by using the\n\t * `isCodeEditor` helper method to access the text code editor.\n\t *\n\t * Use the `onDidChangeControl` event to track whenever the control\n\t * changes.\n\t */\n\tgetControl(): IEditorControl | undefined;\n\n\t/**\n\t * Returns the current view state of the editor if any.\n\t *\n\t * This method is optional to override for the editor pane\n\t * and should only be overridden when the pane can deal with\n\t * `IEditorOptions.viewState` to be applied when opening.\n\t */\n\tgetViewState(): object | undefined;\n\n\t/**\n\t * An optional method to return the current selection in\n\t * the editor pane in case the editor pane has a selection\n\t * concept.\n\t *\n\t * Clients of this method will typically react to the\n\t * `onDidChangeSelection` event to receive the current\n\t * selection as needed.\n\t */\n\tgetSelection?(): IEditorPaneSelection | undefined;\n\n\t/**\n\t * An optional method to return the current scroll position\n\t * of an editor inside the pane.\n\t *\n\t * Clients of this method will typically react to the\n\t * `onDidChangeScroll` event to receive the current\n\t * scroll position as needed.\n\t */\n\tgetScrollPosition?(): IEditorPaneScrollPosition;\n\n\t/**\n\t * An optional method to set the current scroll position\n\t * of an editor inside the pane.\n\t */\n\tsetScrollPosition?(scrollPosition: IEditorPaneScrollPosition): void;\n\n\t/**\n\t * Finds out if this editor is visible or not.\n\t */\n\tisVisible(): boolean;\n}\n\nexport interface IEditorPaneSelectionChangeEvent {\n\n\t/**\n\t * More details for how the selection was made.\n\t */\n\treason: EditorPaneSelectionChangeReason;\n}\n\nexport const enum EditorPaneSelectionChangeReason {\n\n\t/**\n\t * The selection was changed as a result of a programmatic\n\t * method invocation.\n\t *\n\t * For a text editor pane, this for example can be a selection\n\t * being restored from previous view state automatically.\n\t */\n\tPROGRAMMATIC = 1,\n\n\t/**\n\t * The selection was changed by the user.\n\t *\n\t * This typically means the user changed the selection\n\t * with mouse or keyboard.\n\t */\n\tUSER,\n\n\t/**\n\t * The selection was changed as a result of editing in\n\t * the editor pane.\n\t *\n\t * For a text editor pane, this for example can be typing\n\t * in the text of the editor pane.\n\t */\n\tEDIT,\n\n\t/**\n\t * The selection was changed as a result of a navigation\n\t * action.\n\t *\n\t * For a text editor pane, this for example can be a result\n\t * of selecting an entry from a text outline view.\n\t */\n\tNAVIGATION,\n\n\t/**\n\t * The selection was changed as a result of a jump action\n\t * from within the editor pane.\n\t *\n\t * For a text editor pane, this for example can be a result\n\t * of invoking \"Go to definition\" from a symbol.\n\t */\n\tJUMP\n}\n\nexport interface IEditorPaneSelection {\n\n\t/**\n\t * Asks to compare this selection to another selection.\n\t */\n\tcompare(otherSelection: IEditorPaneSelection): EditorPaneSelectionCompareResult;\n\n\t/**\n\t * Asks to massage the provided `options` in a way\n\t * that the selection can be restored when the editor\n\t * is opened again.\n\t *\n\t * For a text editor this means to apply the selected\n\t * line and column as text editor options.\n\t */\n\trestore(options: IEditorOptions): IEditorOptions;\n\n\t/**\n\t * Only used for logging to print more info about the selection.\n\t */\n\tlog?(): string;\n}\n\nexport const enum EditorPaneSelectionCompareResult {\n\n\t/**\n\t * The selections are identical.\n\t */\n\tIDENTICAL = 1,\n\n\t/**\n\t * The selections are similar.\n\t *\n\t * For a text editor this can mean that the one\n\t * selection is in close proximity to the other\n\t * selection.\n\t *\n\t * Upstream clients may decide in this case to\n\t * not treat the selection different from the\n\t * previous one because it is not distinct enough.\n\t */\n\tSIMILAR = 2,\n\n\t/**\n\t * The selections are entirely different.\n\t */\n\tDIFFERENT = 3\n}\n\nexport interface IEditorPaneWithSelection extends IEditorPane {\n\n\treadonly onDidChangeSelection: Event<IEditorPaneSelectionChangeEvent>;\n\n\tgetSelection(): IEditorPaneSelection | undefined;\n}\n\nexport function isEditorPaneWithSelection(editorPane: IEditorPane | undefined): editorPane is IEditorPaneWithSelection {\n\tconst candidate = editorPane as IEditorPaneWithSelection | undefined;\n\n\treturn !!candidate && typeof candidate.getSelection === 'function' && !!candidate.onDidChangeSelection;\n}\n\nexport interface IEditorPaneWithScrolling extends IEditorPane {\n\n\treadonly onDidChangeScroll: Event<void>;\n\n\tgetScrollPosition(): IEditorPaneScrollPosition;\n\n\tsetScrollPosition(position: IEditorPaneScrollPosition): void;\n}\n\nexport function isEditorPaneWithScrolling(editorPane: IEditorPane | undefined): editorPane is IEditorPaneWithScrolling {\n\tconst candidate = editorPane as IEditorPaneWithScrolling | undefined;\n\n\treturn !!candidate && typeof candidate.getScrollPosition === 'function' && typeof candidate.setScrollPosition === 'function' && !!candidate.onDidChangeScroll;\n}\n\n/**\n * Scroll position of a pane\n */\nexport interface IEditorPaneScrollPosition {\n\treadonly scrollTop: number;\n\treadonly scrollLeft?: number;\n}\n\n/**\n * Try to retrieve the view state for the editor pane that\n * has the provided editor input opened, if at all.\n *\n * This method will return `undefined` if the editor input\n * is not visible in any of the opened editor panes.\n */\nexport function findViewStateForEditor(input: EditorInput, group: GroupIdentifier, editorService: IEditorService): object | undefined {\n\tfor (const editorPane of editorService.visibleEditorPanes) {\n\t\tif (editorPane.group.id === group && input.matches(editorPane.input)) {\n\t\t\treturn editorPane.getViewState();\n\t\t}\n\t}\n\n\treturn undefined;\n}\n\n/**\n * Overrides `IEditorPane` where `input` and `group` are known to be set.\n */\nexport interface IVisibleEditorPane extends IEditorPane {\n\treadonly input: EditorInput;\n}\n\n/**\n * The text editor pane is the container for workbench text editors.\n */\nexport interface ITextEditorPane extends IEditorPane {\n\n\t/**\n\t * Returns the underlying text editor widget of this editor.\n\t */\n\tgetControl(): IEditor | undefined;\n}\n\n/**\n * The text editor pane is the container for workbench text diff editors.\n */\nexport interface ITextDiffEditorPane extends IEditorPane {\n\n\t/**\n\t * Returns the underlying text diff editor widget of this editor.\n\t */\n\tgetControl(): IDiffEditor | undefined;\n}\n\n/**\n * Marker interface for the control inside an editor pane. Callers\n * have to cast the control to work with it, e.g. via methods\n * such as `isCodeEditor(control)`.\n */\nexport interface IEditorControl extends ICompositeControl { }\n\nexport interface IFileEditorFactory {\n\n\t/**\n\t * The type identifier of the file editor.\n\t */\n\ttypeId: string;\n\n\t/**\n\t * Creates new new editor capable of showing files.\n\t */\n\tcreateFileEditor(resource: URI, preferredResource: URI | undefined, preferredName: string | undefined, preferredDescription: string | undefined, preferredEncoding: string | undefined, preferredLanguageId: string | undefined, preferredContents: string | undefined, instantiationService: IInstantiationService): IFileEditorInput;\n\n\t/**\n\t * Check if the provided object is a file editor.\n\t */\n\tisFileEditor(obj: unknown): obj is IFileEditorInput;\n}\n\nexport interface IEditorFactoryRegistry {\n\n\t/**\n\t * Registers the file editor factory to use for file editors.\n\t */\n\tregisterFileEditorFactory(factory: IFileEditorFactory): void;\n\n\t/**\n\t * Returns the file editor factory to use for file editors.\n\t */\n\tgetFileEditorFactory(): IFileEditorFactory;\n\n\t/**\n\t * Registers a editor serializer for the given editor to the registry.\n\t * An editor serializer is capable of serializing and deserializing editor\n\t * from string data.\n\t *\n\t * @param editorTypeId the type identifier of the editor\n\t * @param serializer the editor serializer for serialization/deserialization\n\t */\n\tregisterEditorSerializer<Services extends BrandedService[]>(editorTypeId: string, ctor: { new(...Services: Services): IEditorSerializer }): IDisposable;\n\n\t/**\n\t * Returns the editor serializer for the given editor.\n\t */\n\tgetEditorSerializer(editor: EditorInput): IEditorSerializer | undefined;\n\tgetEditorSerializer(editorTypeId: string): IEditorSerializer | undefined;\n\n\t/**\n\t * Starts the registry by providing the required services.\n\t */\n\tstart(accessor: ServicesAccessor): void;\n}\n\nexport interface IEditorSerializer {\n\n\t/**\n\t * Determines whether the given editor can be serialized by the serializer.\n\t */\n\tcanSerialize(editor: EditorInput): boolean;\n\n\t/**\n\t * Returns a string representation of the provided editor that contains enough information\n\t * to deserialize back to the original editor from the deserialize() method.\n\t */\n\tserialize(editor: EditorInput): string | undefined;\n\n\t/**\n\t * Returns an editor from the provided serialized form of the editor. This form matches\n\t * the value returned from the serialize() method.\n\t */\n\tdeserialize(instantiationService: IInstantiationService, serializedEditor: string): EditorInput | undefined;\n}\n\nexport interface IUntitledTextResourceEditorInput extends IBaseTextResourceEditorInput {\n\n\t/**\n\t * Optional resource for the untitled editor. Depending on the value, the editor:\n\t * - should get a unique name if `undefined` (for example `Untitled-1`)\n\t * - should use the resource directly if the scheme is `untitled:`\n\t * - should change the scheme to `untitled:` otherwise and assume an associated path\n\t *\n\t * Untitled editors with associated path behave slightly different from other untitled\n\t * editors:\n\t * - they are dirty right when opening\n\t * - they will not ask for a file path when saving but use the associated path\n\t */\n\treadonly resource: URI | undefined;\n}\n\n/**\n * A resource side by side editor input shows 2 editors side by side but\n * without highlighting any differences.\n *\n * Note: both sides will be resolved as editor individually. As such, it is\n * possible to show 2 different editors side by side.\n *\n * @see {@link IResourceDiffEditorInput} for a variant that compares 2 editors.\n */\nexport interface IResourceSideBySideEditorInput extends IBaseUntypedEditorInput {\n\n\t/**\n\t * The right hand side editor to open inside a side-by-side editor.\n\t */\n\treadonly primary: IResourceEditorInput | ITextResourceEditorInput | IUntitledTextResourceEditorInput;\n\n\t/**\n\t * The left hand side editor to open inside a side-by-side editor.\n\t */\n\treadonly secondary: IResourceEditorInput | ITextResourceEditorInput | IUntitledTextResourceEditorInput;\n}\n\n/**\n * A resource diff editor input compares 2 editors side by side\n * highlighting the differences.\n *\n * Note: both sides must be resolvable to the same editor, or\n * a text based presentation will be used as fallback.\n */\nexport interface IResourceDiffEditorInput extends IBaseUntypedEditorInput {\n\n\t/**\n\t * The left hand side editor to open inside a diff editor.\n\t */\n\treadonly original: IResourceEditorInput | ITextResourceEditorInput | IUntitledTextResourceEditorInput;\n\n\t/**\n\t * The right hand side editor to open inside a diff editor.\n\t */\n\treadonly modified: IResourceEditorInput | ITextResourceEditorInput | IUntitledTextResourceEditorInput;\n}\n\n/**\n * A resource list diff editor input compares multiple resources side by side\n * highlighting the differences.\n */\nexport interface IResourceMultiDiffEditorInput extends IBaseUntypedEditorInput {\n\t/**\n\t * A unique identifier of this multi diff editor input.\n\t * If a second multi diff editor with the same uri is opened, the existing one is revealed instead (even if the resources list is different!).\n\t */\n\treadonly multiDiffSource?: URI;\n\n\t/**\n\t * The list of resources to compare.\n\t * If not set, the resources are dynamically derived from the {@link multiDiffSource}.\n\t */\n\treadonly resources?: IMultiDiffEditorResource[];\n\n\t/**\n\t * Whether the editor should be serialized and stored for subsequent sessions.\n\t */\n\treadonly isTransient?: boolean;\n}\n\nexport interface IMultiDiffEditorResource extends IResourceDiffEditorInput {\n\treadonly goToFileResource?: URI;\n}\nexport type IResourceMergeEditorInputSide = (IResourceEditorInput | ITextResourceEditorInput) & { detail?: string };\n\n/**\n * A resource merge editor input compares multiple editors\n * highlighting the differences for merging.\n *\n * Note: all sides must be resolvable to the same editor, or\n * a text based presentation will be used as fallback.\n */\nexport interface IResourceMergeEditorInput extends IBaseUntypedEditorInput {\n\n\t/**\n\t * The one changed version of the file.\n\t */\n\treadonly input1: IResourceMergeEditorInputSide;\n\n\t/**\n\t * The second changed version of the file.\n\t */\n\treadonly input2: IResourceMergeEditorInputSide;\n\n\t/**\n\t * The base common ancestor of the file to merge.\n\t */\n\treadonly base: IResourceEditorInput | ITextResourceEditorInput;\n\n\t/**\n\t * The resulting output of the merge.\n\t */\n\treadonly result: IResourceEditorInput | ITextResourceEditorInput;\n}\n\nexport function isResourceEditorInput(editor: unknown): editor is IResourceEditorInput {\n\tif (isEditorInput(editor)) {\n\t\treturn false; // make sure to not accidentally match on typed editor inputs\n\t}\n\n\tconst candidate = editor as IResourceEditorInput | undefined;\n\n\treturn URI.isUri(candidate?.resource);\n}\n\nexport function isResourceDiffEditorInput(editor: unknown): editor is IResourceDiffEditorInput {\n\tif (isEditorInput(editor)) {\n\t\treturn false; // make sure to not accidentally match on typed editor inputs\n\t}\n\n\tconst candidate = editor as IResourceDiffEditorInput | undefined;\n\n\treturn candidate?.original !== undefined && candidate.modified !== undefined;\n}\n\nexport function isResourceMultiDiffEditorInput(editor: unknown): editor is IResourceMultiDiffEditorInput {\n\tif (isEditorInput(editor)) {\n\t\treturn false; // make sure to not accidentally match on typed editor inputs\n\t}\n\n\tconst candidate = editor as IResourceMultiDiffEditorInput | undefined;\n\tif (!candidate) {\n\t\treturn false;\n\t}\n\tif (candidate.resources && !Array.isArray(candidate.resources)) {\n\t\treturn false;\n\t}\n\n\treturn !!candidate.resources || !!candidate.multiDiffSource;\n}\n\nexport function isResourceSideBySideEditorInput(editor: unknown): editor is IResourceSideBySideEditorInput {\n\tif (isEditorInput(editor)) {\n\t\treturn false; // make sure to not accidentally match on typed editor inputs\n\t}\n\n\tif (isResourceDiffEditorInput(editor)) {\n\t\treturn false; // make sure to not accidentally match on diff editors\n\t}\n\n\tconst candidate = editor as IResourceSideBySideEditorInput | undefined;\n\n\treturn candidate?.primary !== undefined && candidate.secondary !== undefined;\n}\n\nexport function isUntitledResourceEditorInput(editor: unknown): editor is IUntitledTextResourceEditorInput {\n\tif (isEditorInput(editor)) {\n\t\treturn false; // make sure to not accidentally match on typed editor inputs\n\t}\n\n\tconst candidate = editor as IUntitledTextResourceEditorInput | undefined;\n\tif (!candidate) {\n\t\treturn false;\n\t}\n\n\treturn candidate.resource === undefined || candidate.resource.scheme === Schemas.untitled || candidate.forceUntitled === true;\n}\n\nexport function isResourceMergeEditorInput(editor: unknown): editor is IResourceMergeEditorInput {\n\tif (isEditorInput(editor)) {\n\t\treturn false; // make sure to not accidentally match on typed editor inputs\n\t}\n\n\tconst candidate = editor as IResourceMergeEditorInput | undefined;\n\n\treturn URI.isUri(candidate?.base?.resource) && URI.isUri(candidate?.input1?.resource) && URI.isUri(candidate?.input2?.resource) && URI.isUri(candidate?.result?.resource);\n}\n\nexport const enum Verbosity {\n\tSHORT,\n\tMEDIUM,\n\tLONG\n}\n\nexport const enum SaveReason {\n\n\t/**\n\t * Explicit user gesture.\n\t */\n\tEXPLICIT = 1,\n\n\t/**\n\t * Auto save after a timeout.\n\t */\n\tAUTO = 2,\n\n\t/**\n\t * Auto save after editor focus change.\n\t */\n\tFOCUS_CHANGE = 3,\n\n\t/**\n\t * Auto save after window change.\n\t */\n\tWINDOW_CHANGE = 4\n}\n\nexport type SaveSource = string;\n\ninterface ISaveSourceDescriptor {\n\tsource: SaveSource;\n\tlabel: string;\n}\n\nclass SaveSourceFactory {\n\n\tprivate readonly mapIdToSaveSource = new Map<SaveSource, ISaveSourceDescriptor>();\n\n\t/**\n\t * Registers a `SaveSource` with an identifier and label\n\t * to the registry so that it can be used in save operations.\n\t */\n\tregisterSource(id: string, label: string): SaveSource {\n\t\tlet sourceDescriptor = this.mapIdToSaveSource.get(id);\n\t\tif (!sourceDescriptor) {\n\t\t\tsourceDescriptor = { source: id, label };\n\t\t\tthis.mapIdToSaveSource.set(id, sourceDescriptor);\n\t\t}\n\n\t\treturn sourceDescriptor.source;\n\t}\n\n\tgetSourceLabel(source: SaveSource): string {\n\t\treturn this.mapIdToSaveSource.get(source)?.label ?? source;\n\t}\n}\n\nexport const SaveSourceRegistry = new SaveSourceFactory();\n\nexport interface ISaveOptions {\n\n\t/**\n\t * An indicator how the save operation was triggered.\n\t */\n\treason?: SaveReason;\n\n\t/**\n\t * An indicator about the source of the save operation.\n\t *\n\t * Must use `SaveSourceRegistry.registerSource()` to obtain.\n\t */\n\treadonly source?: SaveSource;\n\n\t/**\n\t * Forces to save the contents of the working copy\n\t * again even if the working copy is not dirty.\n\t */\n\treadonly force?: boolean;\n\n\t/**\n\t * Instructs the save operation to skip any save participants.\n\t */\n\treadonly skipSaveParticipants?: boolean;\n\n\t/**\n\t * A hint as to which file systems should be available for saving.\n\t */\n\treadonly availableFileSystems?: string[];\n}\n\nexport interface IRevertOptions {\n\n\t/**\n\t * Forces to load the contents of the working copy\n\t * again even if the working copy is not dirty.\n\t */\n\treadonly force?: boolean;\n\n\t/**\n\t * A soft revert will clear dirty state of a working copy\n\t * but will not attempt to load it from its persisted state.\n\t *\n\t * This option may be used in scenarios where an editor is\n\t * closed and where we do not require to load the contents.\n\t */\n\treadonly soft?: boolean;\n}\n\nexport interface IMoveResult {\n\teditor: EditorInput | IUntypedEditorInput;\n\toptions?: IEditorOptions;\n}\n\nexport const enum EditorInputCapabilities {\n\n\t/**\n\t * Signals no specific capability for the input.\n\t */\n\tNone = 0,\n\n\t/**\n\t * Signals that the input is readonly.\n\t */\n\tReadonly = 1 << 1,\n\n\t/**\n\t * Signals that the input is untitled.\n\t */\n\tUntitled = 1 << 2,\n\n\t/**\n\t * Signals that the input can only be shown in one group\n\t * and not be split into multiple groups.\n\t */\n\tSingleton = 1 << 3,\n\n\t/**\n\t * Signals that the input requires workspace trust.\n\t */\n\tRequiresTrust = 1 << 4,\n\n\t/**\n\t * Signals that the editor can split into 2 in the same\n\t * editor group.\n\t */\n\tCanSplitInGroup = 1 << 5,\n\n\t/**\n\t * Signals that the editor wants its description to be\n\t * visible when presented to the user. By default, a UI\n\t * component may decide to hide the description portion\n\t * for brevity.\n\t */\n\tForceDescription = 1 << 6,\n\n\t/**\n\t * Signals that the editor supports dropping into the\n\t * editor by holding shift.\n\t */\n\tCanDropIntoEditor = 1 << 7,\n\n\t/**\n\t * Signals that the editor is composed of multiple editors\n\t * within.\n\t */\n\tMultipleEditors = 1 << 8,\n\n\t/**\n\t * Signals that the editor cannot be in a dirty state\n\t * and may still have unsaved changes\n\t */\n\tScratchpad = 1 << 9\n}\n\nexport type IUntypedEditorInput = IResourceEditorInput | ITextResourceEditorInput | IUntitledTextResourceEditorInput | IResourceDiffEditorInput | IResourceMultiDiffEditorInput | IResourceSideBySideEditorInput | IResourceMergeEditorInput;\n\nexport abstract class AbstractEditorInput extends Disposable {\n\t// Marker class for implementing `isEditorInput`\n}\n\nexport function isEditorInput(editor: unknown): editor is EditorInput {\n\treturn editor instanceof AbstractEditorInput;\n}\n\nexport interface EditorInputWithPreferredResource {\n\n\t/**\n\t * An editor may provide an additional preferred resource alongside\n\t * the `resource` property. While the `resource` property serves as\n\t * unique identifier of the editor that should be used whenever we\n\t * compare to other editors, the `preferredResource` should be used\n\t * in places where e.g. the resource is shown to the user.\n\t *\n\t * For example: on Windows and macOS, the same URI with different\n\t * casing may point to the same file. The editor may chose to\n\t * \"normalize\" the URIs so that only one editor opens for different\n\t * URIs. But when displaying the editor label to the user, the\n\t * preferred URI should be used.\n\t *\n\t * Not all editors have a `preferredResource`. The `EditorResourceAccessor`\n\t * utility can be used to always get the right resource without having\n\t * to do instanceof checks.\n\t */\n\treadonly preferredResource: URI;\n}\n\nfunction isEditorInputWithPreferredResource(editor: unknown): editor is EditorInputWithPreferredResource {\n\tconst candidate = editor as EditorInputWithPreferredResource | undefined;\n\n\treturn URI.isUri(candidate?.preferredResource);\n}\n\nexport interface ISideBySideEditorInput extends EditorInput {\n\n\t/**\n\t * The primary editor input is shown on the right hand side.\n\t */\n\tprimary: EditorInput;\n\n\t/**\n\t * The secondary editor input is shown on the left hand side.\n\t */\n\tsecondary: EditorInput;\n}\n\nexport function isSideBySideEditorInput(editor: unknown): editor is ISideBySideEditorInput {\n\tconst candidate = editor as ISideBySideEditorInput | undefined;\n\n\treturn isEditorInput(candidate?.primary) && isEditorInput(candidate?.secondary);\n}\n\nexport interface IDiffEditorInput extends EditorInput {\n\n\t/**\n\t * The modified (primary) editor input is shown on the right hand side.\n\t */\n\tmodified: EditorInput;\n\n\t/**\n\t * The original (secondary) editor input is shown on the left hand side.\n\t */\n\toriginal: EditorInput;\n}\n\nexport function isDiffEditorInput(editor: unknown): editor is IDiffEditorInput {\n\tconst candidate = editor as IDiffEditorInput | undefined;\n\n\treturn isEditorInput(candidate?.modified) && isEditorInput(candidate?.original);\n}\n\nexport interface IUntypedFileEditorInput extends ITextResourceEditorInput {\n\n\t/**\n\t * A marker to create a `IFileEditorInput` from this untyped input.\n\t */\n\tforceFile: true;\n}\n\n/**\n * This is a tagging interface to declare an editor input being capable of dealing with files. It is only used in the editor registry\n * to register this kind of input to the platform.\n */\nexport interface IFileEditorInput extends EditorInput, IEncodingSupport, ILanguageSupport, EditorInputWithPreferredResource {\n\n\t/**\n\t * Gets the resource this file input is about. This will always be the\n\t * canonical form of the resource, so it may differ from the original\n\t * resource that was provided to create the input. Use `preferredResource`\n\t * for the form as it was created.\n\t */\n\treadonly resource: URI;\n\n\t/**\n\t * Sets the preferred resource to use for this file input.\n\t */\n\tsetPreferredResource(preferredResource: URI): void;\n\n\t/**\n\t * Sets the preferred name to use for this file input.\n\t *\n\t * Note: for certain file schemes the input may decide to ignore this\n\t * name and use our standard naming. Specifically for schemes we own,\n\t * we do not let others override the name.\n\t */\n\tsetPreferredName(name: string): void;\n\n\t/**\n\t * Sets the preferred description to use for this file input.\n\t *\n\t * Note: for certain file schemes the input may decide to ignore this\n\t * description and use our standard naming. Specifically for schemes we own,\n\t * we do not let others override the description.\n\t */\n\tsetPreferredDescription(description: string): void;\n\n\t/**\n\t * Sets the preferred encoding to use for this file input.\n\t */\n\tsetPreferredEncoding(encoding: string): void;\n\n\t/**\n\t * Sets the preferred language id to use for this file input.\n\t */\n\tsetPreferredLanguageId(languageId: string): void;\n\n\t/**\n\t * Sets the preferred contents to use for this file input.\n\t */\n\tsetPreferredContents(contents: string): void;\n\n\t/**\n\t * Forces this file input to open as binary instead of text.\n\t */\n\tsetForceOpenAsBinary(): void;\n\n\t/**\n\t * Figure out if the file input has been resolved or not.\n\t */\n\tisResolved(): boolean;\n}\n\nexport interface IFileLimitedEditorInputOptions extends IEditorOptions {\n\n\t/**\n\t * If provided, the size of the file will be checked against the limits\n\t * and an error will be thrown if any limit is exceeded.\n\t */\n\treadonly limits?: IFileReadLimits;\n}\n\nexport interface IFileEditorInputOptions extends ITextEditorOptions, IFileLimitedEditorInputOptions { }\n\nexport function createTooLargeFileError(group: IEditorGroup, input: EditorInput, options: IEditorOptions | undefined, message: string, preferencesService: IPreferencesService): Error {\n\treturn createEditorOpenError(message, [\n\t\ttoAction({\n\t\t\tid: 'workbench.action.openLargeFile', label: localize('openLargeFile', \"Open Anyway\"), run: () => {\n\t\t\t\tconst fileEditorOptions: IFileEditorInputOptions = {\n\t\t\t\t\t...options,\n\t\t\t\t\tlimits: {\n\t\t\t\t\t\tsize: Number.MAX_VALUE\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tgroup.openEditor(input, fileEditorOptions);\n\t\t\t}\n\t\t}),\n\t\ttoAction({\n\t\t\tid: 'workbench.action.configureEditorLargeFileConfirmation', label: localize('configureEditorLargeFileConfirmation', \"Configure Limit\"), run: () => {\n\t\t\t\treturn preferencesService.openUserSettings({ query: 'workbench.editorLargeFileConfirmation' });\n\t\t\t}\n\t\t}),\n\t], {\n\t\tforceMessage: true,\n\t\tforceSeverity: Severity.Warning\n\t});\n}\n\nexport interface EditorInputWithOptions {\n\teditor: EditorInput;\n\toptions?: IEditorOptions;\n}\n\nexport interface EditorInputWithOptionsAndGroup extends EditorInputWithOptions {\n\tgroup: IEditorGroup;\n}\n\nexport function isEditorInputWithOptions(editor: unknown): editor is EditorInputWithOptions {\n\tconst candidate = editor as EditorInputWithOptions | undefined;\n\n\treturn isEditorInput(candidate?.editor);\n}\n\nexport function isEditorInputWithOptionsAndGroup(editor: unknown): editor is EditorInputWithOptionsAndGroup {\n\tconst candidate = editor as EditorInputWithOptionsAndGroup | undefined;\n\n\treturn isEditorInputWithOptions(editor) && candidate?.group !== undefined;\n}\n\n/**\n * Context passed into `EditorPane#setInput` to give additional\n * context information around why the editor was opened.\n */\nexport interface IEditorOpenContext {\n\n\t/**\n\t * An indicator if the editor input is new for the group the editor is in.\n\t * An editor is new for a group if it was not part of the group before and\n\t * otherwise was already opened in the group and just became the active editor.\n\t *\n\t * This hint can e.g. be used to decide whether to restore view state or not.\n\t */\n\tnewInGroup?: boolean;\n}\n\nexport interface IEditorIdentifier {\n\tgroupId: GroupIdentifier;\n\teditor: EditorInput;\n}\n\nexport function isEditorIdentifier(identifier: unknown): identifier is IEditorIdentifier {\n\tconst candidate = identifier as IEditorIdentifier | undefined;\n\n\treturn typeof candidate?.groupId === 'number' && isEditorInput(candidate.editor);\n}\n\n/**\n * The editor commands context is used for editor commands (e.g. in the editor title)\n * and we must ensure that the context is serializable because it potentially travels\n * to the extension host!\n */\nexport interface IEditorCommandsContext {\n\tgroupId: GroupIdentifier;\n\teditorIndex?: number;\n\n\tpreserveFocus?: boolean;\n}\n\nexport function isEditorCommandsContext(context: unknown): context is IEditorCommandsContext {\n\tconst candidate = context as IEditorCommandsContext | undefined;\n\n\treturn typeof candidate?.groupId === 'number';\n}\n\n/**\n * More information around why an editor was closed in the model.\n */\nexport enum EditorCloseContext {\n\n\t/**\n\t * No specific context for closing (e.g. explicit user gesture).\n\t */\n\tUNKNOWN,\n\n\t/**\n\t * The editor closed because it was replaced with another editor.\n\t * This can either happen via explicit replace call or when an\n\t * editor is in preview mode and another editor opens.\n\t */\n\tREPLACE,\n\n\t/**\n\t * The editor closed as a result of moving it to another group.\n\t */\n\tMOVE,\n\n\t/**\n\t * The editor closed because another editor turned into preview\n\t * and this used to be the preview editor before.\n\t */\n\tUNPIN\n}\n\nexport interface IEditorCloseEvent extends IEditorIdentifier {\n\n\t/**\n\t * More information around why the editor was closed.\n\t */\n\treadonly context: EditorCloseContext;\n\n\t/**\n\t * The index of the editor before closing.\n\t */\n\treadonly index: number;\n\n\t/**\n\t * Whether the editor was sticky or not.\n\t */\n\treadonly sticky: boolean;\n}\n\nexport interface IActiveEditorChangeEvent {\n\n\t/**\n\t * The new active editor or `undefined` if the group is empty.\n\t */\n\teditor: EditorInput | undefined;\n}\n\nexport interface IEditorWillMoveEvent extends IEditorIdentifier {\n\n\t/**\n\t * The target group of the move operation.\n\t */\n\treadonly target: GroupIdentifier;\n}\n\nexport interface IEditorWillOpenEvent extends IEditorIdentifier { }\n\nexport interface IWillInstantiateEditorPaneEvent {\n\n\t/**\n\t * @see {@link IEditorDescriptor.typeId}\n\t */\n\treadonly typeId: string;\n}\n\nexport type GroupIdentifier = number;\n\nexport const enum GroupModelChangeKind {\n\n\t/* Group Changes */\n\tGROUP_ACTIVE,\n\tGROUP_INDEX,\n\tGROUP_LABEL,\n\tGROUP_LOCKED,\n\n\t/* Editors Change */\n\tEDITORS_SELECTION,\n\n\t/* Editor Changes */\n\tEDITOR_OPEN,\n\tEDITOR_CLOSE,\n\tEDITOR_MOVE,\n\tEDITOR_ACTIVE,\n\tEDITOR_LABEL,\n\tEDITOR_CAPABILITIES,\n\tEDITOR_PIN,\n\tEDITOR_TRANSIENT,\n\tEDITOR_STICKY,\n\tEDITOR_DIRTY,\n\tEDITOR_WILL_DISPOSE\n}\n\nexport interface IWorkbenchEditorConfiguration {\n\tworkbench?: {\n\t\teditor?: IEditorPartConfiguration;\n\t\ticonTheme?: string;\n\t};\n}\n\ninterface IEditorPartLimitConfiguration {\n\tenabled?: boolean;\n\texcludeDirty?: boolean;\n\tvalue?: number;\n\tperEditorGroup?: boolean;\n}\n\nexport interface IEditorPartLimitOptions extends Required<IEditorPartLimitConfiguration> { }\n\ninterface IEditorPartDecorationsConfiguration {\n\tbadges?: boolean;\n\tcolors?: boolean;\n}\n\nexport interface IEditorPartDecorationOptions extends Required<IEditorPartDecorationsConfiguration> { }\n\ninterface IEditorPartConfiguration {\n\tshowTabs?: 'multiple' | 'single' | 'none';\n\twrapTabs?: boolean;\n\tscrollToSwitchTabs?: boolean;\n\thighlightModifiedTabs?: boolean;\n\ttabActionLocation?: 'left' | 'right';\n\ttabActionCloseVisibility?: boolean;\n\ttabActionUnpinVisibility?: boolean;\n\talwaysShowEditorActions?: boolean;\n\ttabSizing?: 'fit' | 'shrink' | 'fixed';\n\ttabSizingFixedMinWidth?: number;\n\ttabSizingFixedMaxWidth?: number;\n\tpinnedTabSizing?: 'normal' | 'compact' | 'shrink';\n\tpinnedTabsOnSeparateRow?: boolean;\n\ttabHeight?: 'default' | 'compact';\n\tpreventPinnedEditorClose?: PreventPinnedEditorClose;\n\ttitleScrollbarSizing?: 'default' | 'large';\n\tfocusRecentEditorAfterClose?: boolean;\n\tshowIcons?: boolean;\n\tenablePreview?: boolean;\n\tenablePreviewFromQuickOpen?: boolean;\n\tenablePreviewFromCodeNavigation?: boolean;\n\tcloseOnFileDelete?: boolean;\n\topenPositioning?: 'left' | 'right' | 'first' | 'last';\n\topenSideBySideDirection?: 'right' | 'down';\n\tcloseEmptyGroups?: boolean;\n\tautoLockGroups?: Set<string>;\n\trevealIfOpen?: boolean;\n\tmouseBackForwardToNavigate?: boolean;\n\tlabelFormat?: 'default' | 'short' | 'medium' | 'long';\n\trestoreViewState?: boolean;\n\tsplitInGroupLayout?: 'vertical' | 'horizontal';\n\tsplitSizing?: 'auto' | 'split' | 'distribute';\n\tsplitOnDragAndDrop?: boolean;\n\tdragToOpenWindow?: boolean;\n\tcenteredLayoutFixedWidth?: boolean;\n\tdoubleClickTabToToggleEditorGroupSizes?: 'maximize' | 'expand' | 'off';\n\teditorActionsLocation?: 'default' | 'titleBar' | 'hidden';\n\tlimit?: IEditorPartLimitConfiguration;\n\tdecorations?: IEditorPartDecorationsConfiguration;\n}\n\nexport interface IEditorPartOptions extends DeepRequiredNonNullable<IEditorPartConfiguration> {\n\thasIcons: boolean;\n}\n\nexport interface IEditorPartOptionsChangeEvent {\n\toldPartOptions: IEditorPartOptions;\n\tnewPartOptions: IEditorPartOptions;\n}\n\nexport enum SideBySideEditor {\n\tPRIMARY = 1,\n\tSECONDARY = 2,\n\tBOTH = 3,\n\tANY = 4\n}\n\nexport interface IFindEditorOptions {\n\n\t/**\n\t * Whether to consider any or both side by side editor as matching.\n\t * By default, side by side editors will not be considered\n\t * as matching, even if the editor is opened in one of the sides.\n\t */\n\tsupportSideBySide?: SideBySideEditor.PRIMARY | SideBySideEditor.SECONDARY | SideBySideEditor.ANY;\n}\n\nexport interface IMatchEditorOptions {\n\n\t/**\n\t * Whether to consider a side by side editor as matching.\n\t * By default, side by side editors will not be considered\n\t * as matching, even if the editor is opened in one of the sides.\n\t */\n\tsupportSideBySide?: SideBySideEditor.ANY | SideBySideEditor.BOTH;\n\n\t/**\n\t * Only consider an editor to match when the\n\t * `candidate === editor` but not when\n\t * `candidate.matches(editor)`.\n\t */\n\tstrictEquals?: boolean;\n}\n\nexport interface IEditorResourceAccessorOptions {\n\n\t/**\n\t * Allows to access the `resource(s)` of side by side editors. If not\n\t * specified, a `resource` for a side by side editor will always be\n\t * `undefined`.\n\t */\n\tsupportSideBySide?: SideBySideEditor;\n\n\t/**\n\t * Allows to filter the scheme to consider. A resource scheme that does\n\t * not match a filter will not be considered.\n\t */\n\tfilterByScheme?: string | string[];\n}\n\nclass EditorResourceAccessorImpl {\n\n\t/**\n\t * The original URI of an editor is the URI that was used originally to open\n\t * the editor and should be used whenever the URI is presented to the user,\n\t * e.g. as a label together with utility methods such as `ResourceLabel` or\n\t * `ILabelService` that can turn this original URI into the best form for\n\t * presenting.\n\t *\n\t * In contrast, the canonical URI (#getCanonicalUri) may be different and should\n\t * be used whenever the URI is used to e.g. compare with other editors or when\n\t * caching certain data based on the URI.\n\t *\n\t * For example: on Windows and macOS, the same file URI with different casing may\n\t * point to the same file. The editor may chose to \"normalize\" the URI into a canonical\n\t * form so that only one editor opens for same file URIs with different casing. As\n\t * such, the original URI and the canonical URI can be different.\n\t */\n\tgetOriginalUri(editor: EditorInput | IUntypedEditorInput | undefined | null): URI | undefined;\n\tgetOriginalUri(editor: EditorInput | IUntypedEditorInput | undefined | null, options: IEditorResourceAccessorOptions & { supportSideBySide?: SideBySideEditor.PRIMARY | SideBySideEditor.SECONDARY | SideBySideEditor.ANY }): URI | undefined;\n\tgetOriginalUri(editor: EditorInput | IUntypedEditorInput | undefined | null, options: IEditorResourceAccessorOptions & { supportSideBySide: SideBySideEditor.BOTH }): URI | { primary?: URI; secondary?: URI } | undefined;\n\tgetOriginalUri(editor: EditorInput | IUntypedEditorInput | undefined | null, options?: IEditorResourceAccessorOptions): URI | { primary?: URI; secondary?: URI } | undefined;\n\tgetOriginalUri(editor: EditorInput | IUntypedEditorInput | undefined | null, options?: IEditorResourceAccessorOptions): URI | { primary?: URI; secondary?: URI } | undefined {\n\t\tif (!editor) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Merge editors are handled with `merged` result editor\n\t\tif (isResourceMergeEditorInput(editor)) {\n\t\t\treturn EditorResourceAccessor.getOriginalUri(editor.result, options);\n\t\t}\n\n\t\t// Optionally support side-by-side editors\n\t\tif (options?.supportSideBySide) {\n\t\t\tconst { primary, secondary } = this.getSideEditors(editor);\n\t\t\tif (primary && secondary) {\n\t\t\t\tif (options?.supportSideBySide === SideBySideEditor.BOTH) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tprimary: this.getOriginalUri(primary, { filterByScheme: options.filterByScheme }),\n\t\t\t\t\t\tsecondary: this.getOriginalUri(secondary, { filterByScheme: options.filterByScheme })\n\t\t\t\t\t};\n\t\t\t\t} else if (options?.supportSideBySide === SideBySideEditor.ANY) {\n\t\t\t\t\treturn this.getOriginalUri(primary, { filterByScheme: options.filterByScheme }) ?? this.getOriginalUri(secondary, { filterByScheme: options.filterByScheme });\n\t\t\t\t}\n\n\t\t\t\teditor = options.supportSideBySide === SideBySideEditor.PRIMARY ? primary : secondary;\n\t\t\t}\n\t\t}\n\n\t\tif (isResourceDiffEditorInput(editor) || isResourceMultiDiffEditorInput(editor) || isResourceSideBySideEditorInput(editor) || isResourceMergeEditorInput(editor)) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Original URI is the `preferredResource` of an editor if any\n\t\tconst originalResource = isEditorInputWithPreferredResource(editor) ? editor.preferredResource : editor.resource;\n\t\tif (!originalResource || !options || !options.filterByScheme) {\n\t\t\treturn originalResource;\n\t\t}\n\n\t\treturn this.filterUri(originalResource, options.filterByScheme);\n\t}\n\n\tprivate getSideEditors(editor: EditorInput | IUntypedEditorInput): { primary: EditorInput | IUntypedEditorInput | undefined; secondary: EditorInput | IUntypedEditorInput | undefined } {\n\t\tif (isSideBySideEditorInput(editor) || isResourceSideBySideEditorInput(editor)) {\n\t\t\treturn { primary: editor.primary, secondary: editor.secondary };\n\t\t}\n\n\t\tif (isDiffEditorInput(editor) || isResourceDiffEditorInput(editor)) {\n\t\t\treturn { primary: editor.modified, secondary: editor.original };\n\t\t}\n\n\t\treturn { primary: undefined, secondary: undefined };\n\t}\n\n\t/**\n\t * The canonical URI of an editor is the true unique identifier of the editor\n\t * and should be used whenever the URI is used e.g. to compare with other\n\t * editors or when caching certain data based on the URI.\n\t *\n\t * In contrast, the original URI (#getOriginalUri) may be different and should\n\t * be used whenever the URI is presented to the user, e.g. as a label.\n\t *\n\t * For example: on Windows and macOS, the same file URI with different casing may\n\t * point to the same file. The editor may chose to \"normalize\" the URI into a canonical\n\t * form so that only one editor opens for same file URIs with different casing. As\n\t * such, the original URI and the canonical URI can be different.\n\t */\n\tgetCanonicalUri(editor: EditorInput | IUntypedEditorInput | undefined | null): URI | undefined;\n\tgetCanonicalUri(editor: EditorInput | IUntypedEditorInput | undefined | null, options: IEditorResourceAccessorOptions & { supportSideBySide?: SideBySideEditor.PRIMARY | SideBySideEditor.SECONDARY | SideBySideEditor.ANY }): URI | undefined;\n\tgetCanonicalUri(editor: EditorInput | IUntypedEditorInput | undefined | null, options: IEditorResourceAccessorOptions & { supportSideBySide: SideBySideEditor.BOTH }): URI | { primary?: URI; secondary?: URI } | undefined;\n\tgetCanonicalUri(editor: EditorInput | IUntypedEditorInput | undefined | null, options?: IEditorResourceAccessorOptions): URI | { primary?: URI; secondary?: URI } | undefined;\n\tgetCanonicalUri(editor: EditorInput | IUntypedEditorInput | undefined | null, options?: IEditorResourceAccessorOptions): URI | { primary?: URI; secondary?: URI } | undefined {\n\t\tif (!editor) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Merge editors are handled with `merged` result editor\n\t\tif (isResourceMergeEditorInput(editor)) {\n\t\t\treturn EditorResourceAccessor.getCanonicalUri(editor.result, options);\n\t\t}\n\n\t\t// Optionally support side-by-side editors\n\t\tif (options?.supportSideBySide) {\n\t\t\tconst { primary, secondary } = this.getSideEditors(editor);\n\t\t\tif (primary && secondary) {\n\t\t\t\tif (options?.supportSideBySide === SideBySideEditor.BOTH) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tprimary: this.getCanonicalUri(primary, { filterByScheme: options.filterByScheme }),\n\t\t\t\t\t\tsecondary: this.getCanonicalUri(secondary, { filterByScheme: options.filterByScheme })\n\t\t\t\t\t};\n\t\t\t\t} else if (options?.supportSideBySide === SideBySideEditor.ANY) {\n\t\t\t\t\treturn this.getCanonicalUri(primary, { filterByScheme: options.filterByScheme }) ?? this.getCanonicalUri(secondary, { filterByScheme: options.filterByScheme });\n\t\t\t\t}\n\n\t\t\t\teditor = options.supportSideBySide === SideBySideEditor.PRIMARY ? primary : secondary;\n\t\t\t}\n\t\t}\n\n\t\tif (isResourceDiffEditorInput(editor) || isResourceMultiDiffEditorInput(editor) || isResourceSideBySideEditorInput(editor) || isResourceMergeEditorInput(editor)) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Canonical URI is the `resource` of an editor\n\t\tconst canonicalResource = editor.resource;\n\t\tif (!canonicalResource || !options || !options.filterByScheme) {\n\t\t\treturn canonicalResource;\n\t\t}\n\n\t\treturn this.filterUri(canonicalResource, options.filterByScheme);\n\t}\n\n\tprivate filterUri(resource: URI, filter: string | string[]): URI | undefined {\n\n\t\t// Multiple scheme filter\n\t\tif (Array.isArray(filter)) {\n\t\t\tif (filter.some(scheme => resource.scheme === scheme)) {\n\t\t\t\treturn resource;\n\t\t\t}\n\t\t}\n\n\t\t// Single scheme filter\n\t\telse {\n\t\t\tif (filter === resource.scheme) {\n\t\t\t\treturn resource;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n}\n\nexport type PreventPinnedEditorClose = 'keyboardAndMouse' | 'keyboard' | 'mouse' | 'never' | undefined;\n\nexport enum EditorCloseMethod {\n\tUNKNOWN,\n\tKEYBOARD,\n\tMOUSE\n}\n\nexport function preventEditorClose(group: IEditorGroup | IReadonlyEditorGroupModel, editor: EditorInput, method: EditorCloseMethod, configuration: IEditorPartConfiguration): boolean {\n\tif (!group.isSticky(editor)) {\n\t\treturn false; // only interested in sticky editors\n\t}\n\n\tswitch (configuration.preventPinnedEditorClose) {\n\t\tcase 'keyboardAndMouse': return method === EditorCloseMethod.MOUSE || method === EditorCloseMethod.KEYBOARD;\n\t\tcase 'mouse': return method === EditorCloseMethod.MOUSE;\n\t\tcase 'keyboard': return method === EditorCloseMethod.KEYBOARD;\n\t}\n\n\treturn false;\n}\n\nexport const EditorResourceAccessor = new EditorResourceAccessorImpl();\n\nexport const enum CloseDirection {\n\tLEFT,\n\tRIGHT\n}\n\nexport interface IEditorMemento<T> {\n\n\tsaveEditorState(group: IEditorGroup, resource: URI, state: T): void;\n\tsaveEditorState(group: IEditorGroup, editor: EditorInput, state: T): void;\n\n\tloadEditorState(group: IEditorGroup, resource: URI): T | undefined;\n\tloadEditorState(group: IEditorGroup, editor: EditorInput): T | undefined;\n\n\tclearEditorState(resource: URI, group?: IEditorGroup): void;\n\tclearEditorState(editor: EditorInput, group?: IEditorGroup): void;\n\n\tclearEditorStateOnDispose(resource: URI, editor: EditorInput): void;\n\n\tmoveEditorState(source: URI, target: URI, comparer: IExtUri): void;\n}\n\nclass EditorFactoryRegistry implements IEditorFactoryRegistry {\n\tprivate instantiationService: IInstantiationService | undefined;\n\n\tprivate fileEditorFactory: IFileEditorFactory | undefined;\n\n\tprivate readonly editorSerializerConstructors = new Map<string /* Type ID */, IConstructorSignature<IEditorSerializer>>();\n\tprivate readonly editorSerializerInstances = new Map<string /* Type ID */, IEditorSerializer>();\n\n\tstart(accessor: ServicesAccessor): void {\n\t\tconst instantiationService = this.instantiationService = accessor.get(IInstantiationService);\n\n\t\tfor (const [key, ctor] of this.editorSerializerConstructors) {\n\t\t\tthis.createEditorSerializer(key, ctor, instantiationService);\n\t\t}\n\n\t\tthis.editorSerializerConstructors.clear();\n\t}\n\n\tprivate createEditorSerializer(editorTypeId: string, ctor: IConstructorSignature<IEditorSerializer>, instantiationService: IInstantiationService): void {\n\t\tconst instance = instantiationService.createInstance(ctor);\n\t\tthis.editorSerializerInstances.set(editorTypeId, instance);\n\t}\n\n\tregisterFileEditorFactory(factory: IFileEditorFactory): void {\n\t\tif (this.fileEditorFactory) {\n\t\t\tthrow new Error('Can only register one file editor factory.');\n\t\t}\n\n\t\tthis.fileEditorFactory = factory;\n\t}\n\n\tgetFileEditorFactory(): IFileEditorFactory {\n\t\treturn assertIsDefined(this.fileEditorFactory);\n\t}\n\n\tregisterEditorSerializer(editorTypeId: string, ctor: IConstructorSignature<IEditorSerializer>): IDisposable {\n\t\tif (this.editorSerializerConstructors.has(editorTypeId) || this.editorSerializerInstances.has(editorTypeId)) {\n\t\t\tthrow new Error(`A editor serializer with type ID '${editorTypeId}' was already registered.`);\n\t\t}\n\n\t\tif (!this.instantiationService) {\n\t\t\tthis.editorSerializerConstructors.set(editorTypeId, ctor);\n\t\t} else {\n\t\t\tthis.createEditorSerializer(editorTypeId, ctor, this.instantiationService);\n\t\t}\n\n\t\treturn toDisposable(() => {\n\t\t\tthis.editorSerializerConstructors.delete(editorTypeId);\n\t\t\tthis.editorSerializerInstances.delete(editorTypeId);\n\t\t});\n\t}\n\n\tgetEditorSerializer(editor: EditorInput): IEditorSerializer | undefined;\n\tgetEditorSerializer(editorTypeId: string): IEditorSerializer | undefined;\n\tgetEditorSerializer(arg1: string | EditorInput): IEditorSerializer | undefined {\n\t\treturn this.editorSerializerInstances.get(typeof arg1 === 'string' ? arg1 : arg1.typeId);\n\t}\n}\n\nRegistry.add(EditorExtensions.EditorFactory, new EditorFactoryRegistry());\n\nexport async function pathsToEditors(paths: IPathData[] | undefined, fileService: IFileService, logService: ILogService): Promise<ReadonlyArray<IResourceEditorInput | IUntitledTextResourceEditorInput | undefined>> {\n\tif (!paths || !paths.length) {\n\t\treturn [];\n\t}\n\n\treturn await Promise.all(paths.map(async path => {\n\t\tconst resource = URI.revive(path.fileUri);\n\t\tif (!resource) {\n\t\t\tlogService.info('Cannot resolve the path because it is not valid.', path);\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst canHandleResource = await fileService.canHandleResource(resource);\n\t\tif (!canHandleResource) {\n\t\t\tlogService.info('Cannot resolve the path because it cannot be handled', path);\n\t\t\treturn undefined;\n\t\t}\n\n\t\tlet exists = path.exists;\n\t\tlet type = path.type;\n\t\tif (typeof exists !== 'boolean' || typeof type !== 'number') {\n\t\t\ttry {\n\t\t\t\ttype = (await fileService.stat(resource)).isDirectory ? FileType.Directory : FileType.Unknown;\n\t\t\t\texists = true;\n\t\t\t} catch (error) {\n\t\t\t\tlogService.error(error);\n\t\t\t\texists = false;\n\t\t\t}\n\t\t}\n\n\t\tif (!exists && path.openOnlyIfExists) {\n\t\t\tlogService.info('Cannot resolve the path because it does not exist', path);\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (type === FileType.Directory) {\n\t\t\tlogService.info('Cannot resolve the path because it is a directory', path);\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst options: IEditorOptions = {\n\t\t\t...path.options,\n\t\t\tpinned: true\n\t\t};\n\n\t\tif (!exists) {\n\t\t\treturn { resource, options, forceUntitled: true };\n\t\t}\n\n\t\treturn { resource, options };\n\t}));\n}\n\nexport const enum EditorsOrder {\n\n\t/**\n\t * Editors sorted by most recent activity (most recent active first)\n\t */\n\tMOST_RECENTLY_ACTIVE,\n\n\t/**\n\t * Editors sorted by sequential order\n\t */\n\tSEQUENTIAL\n}\n\nexport function isTextEditorViewState(candidate: unknown): candidate is IEditorViewState {\n\tconst viewState = candidate as IEditorViewState | undefined;\n\tif (!viewState) {\n\t\treturn false;\n\t}\n\n\tconst diffEditorViewState = viewState as IDiffEditorViewState;\n\tif (diffEditorViewState.modified) {\n\t\treturn isTextEditorViewState(diffEditorViewState.modified);\n\t}\n\n\tconst codeEditorViewState = viewState as ICodeEditorViewState;\n\n\treturn !!(codeEditorViewState.contributionsState && codeEditorViewState.viewState && Array.isArray(codeEditorViewState.cursorState));\n}\n\nexport interface IEditorOpenErrorOptions {\n\n\t/**\n\t * If set to true, the message will be taken\n\t * from the error message entirely and not be\n\t * composed with more text.\n\t */\n\tforceMessage?: boolean;\n\n\t/**\n\t * If set, will override the severity of the error.\n\t */\n\tforceSeverity?: Severity;\n\n\t/**\n\t * If set to true, the error may be shown in a dialog\n\t * to the user if the editor opening was triggered by\n\t * user action. Otherwise and by default, the error will\n\t * be shown as place holder in the editor area.\n\t */\n\tallowDialog?: boolean;\n}\n\nexport interface IEditorOpenError extends IErrorWithActions, IEditorOpenErrorOptions { }\n\nexport function isEditorOpenError(obj: unknown): obj is IEditorOpenError {\n\treturn isErrorWithActions(obj);\n}\n\nexport function createEditorOpenError(messageOrError: string | Error, actions: IAction[], options?: IEditorOpenErrorOptions): IEditorOpenError {\n\tconst error: IEditorOpenError = createErrorWithActions(messageOrError, actions);\n\n\terror.forceMessage = options?.forceMessage;\n\terror.forceSeverity = options?.forceSeverity;\n\terror.allowDialog = options?.allowDialog;\n\n\treturn error;\n}\n\nexport interface IToolbarActions {\n\treadonly primary: IAction[];\n\treadonly secondary: IAction[];\n}\n"],
  "mappings": "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",
  "names": ["EditorPaneSelectionChangeReason", "EditorPaneSelectionCompareResult", "Verbosity", "SaveReason", "EditorInputCapabilities", "EditorCloseContext", "GroupModelChangeKind", "SideBySideEditor", "EditorCloseMethod", "CloseDirection", "EditorsOrder"]
}
