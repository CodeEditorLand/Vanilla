{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/common/editor.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { type IAction, toAction } from \"../../base/common/actions.js\";\nimport {\n\ttype IErrorWithActions,\n\tcreateErrorWithActions,\n\tisErrorWithActions,\n} from \"../../base/common/errorMessage.js\";\nimport type { Event } from \"../../base/common/event.js\";\nimport {\n\tDisposable,\n\ttype IDisposable,\n\ttoDisposable,\n} from \"../../base/common/lifecycle.js\";\nimport { Schemas } from \"../../base/common/network.js\";\nimport type { IExtUri } from \"../../base/common/resources.js\";\nimport Severity from \"../../base/common/severity.js\";\nimport {\n\ttype DeepRequiredNonNullable,\n\tassertIsDefined,\n} from \"../../base/common/types.js\";\nimport { URI } from \"../../base/common/uri.js\";\nimport type {\n\tICodeEditorViewState,\n\tIDiffEditor,\n\tIDiffEditorViewState,\n\tIEditor,\n\tIEditorViewState,\n} from \"../../editor/common/editorCommon.js\";\nimport { localize } from \"../../nls.js\";\nimport type { IContextKeyService } from \"../../platform/contextkey/common/contextkey.js\";\nimport type {\n\tIBaseTextResourceEditorInput,\n\tIBaseUntypedEditorInput,\n\tIEditorOptions,\n\tIResourceEditorInput,\n\tITextEditorOptions,\n\tITextResourceEditorInput,\n} from \"../../platform/editor/common/editor.js\";\nimport {\n\tFileType,\n\ttype IFileReadLimits,\n\ttype IFileService,\n} from \"../../platform/files/common/files.js\";\nimport {\n\ttype BrandedService,\n\ttype IConstructorSignature,\n\tIInstantiationService,\n\ttype ServicesAccessor,\n} from \"../../platform/instantiation/common/instantiation.js\";\nimport type { ILogService } from \"../../platform/log/common/log.js\";\nimport { Registry } from \"../../platform/registry/common/platform.js\";\nimport type { IPathData } from \"../../platform/window/common/window.js\";\nimport type { IEditorGroup } from \"../services/editor/common/editorGroupsService.js\";\nimport type { IEditorService } from \"../services/editor/common/editorService.js\";\nimport type { IPreferencesService } from \"../services/preferences/common/preferences.js\";\nimport type {\n\tIEncodingSupport,\n\tILanguageSupport,\n} from \"../services/textfile/common/textfiles.js\";\nimport type { IComposite, ICompositeControl } from \"./composite.js\";\nimport type { IReadonlyEditorGroupModel } from \"./editor/editorGroupModel.js\";\nimport type { EditorInput } from \"./editor/editorInput.js\";\n\n// Static values for editor contributions\nexport const EditorExtensions = {\n\tEditorPane: \"workbench.contributions.editors\",\n\tEditorFactory: \"workbench.contributions.editor.inputFactories\",\n};\n\n// Static information regarding the text editor\nexport const DEFAULT_EDITOR_ASSOCIATION = {\n\tid: \"default\",\n\tdisplayName: localize(\n\t\t\"promptOpenWith.defaultEditor.displayName\",\n\t\t\"Text Editor\",\n\t),\n\tproviderDisplayName: localize(\"builtinProviderDisplayName\", \"Built-in\"),\n};\n\n/**\n * Side by side editor id.\n */\nexport const SIDE_BY_SIDE_EDITOR_ID = \"workbench.editor.sidebysideEditor\";\n\n/**\n * Text diff editor id.\n */\nexport const TEXT_DIFF_EDITOR_ID = \"workbench.editors.textDiffEditor\";\n\n/**\n * Binary diff editor id.\n */\nexport const BINARY_DIFF_EDITOR_ID =\n\t\"workbench.editors.binaryResourceDiffEditor\";\n\nexport interface IEditorDescriptor<T extends IEditorPane> {\n\t/**\n\t * The unique type identifier of the editor. All instances\n\t * of the same `IEditorPane` should have the same type\n\t * identifier.\n\t */\n\treadonly typeId: string;\n\n\t/**\n\t * The display name of the editor.\n\t */\n\treadonly name: string;\n\n\t/**\n\t * Instantiates the editor pane using the provided services.\n\t */\n\tinstantiate(\n\t\tinstantiationService: IInstantiationService,\n\t\tgroup: IEditorGroup,\n\t): T;\n\n\t/**\n\t * Whether the descriptor is for the provided editor pane.\n\t */\n\tdescribes(editorPane: T): boolean;\n}\n\n/**\n * The editor pane is the container for workbench editors.\n */\nexport interface IEditorPane extends IComposite {\n\t/**\n\t * An event to notify when the `IEditorControl` in this\n\t * editor pane changes.\n\t *\n\t * This can be used for editor panes that are a compound\n\t * of multiple editor controls to signal that the active\n\t * editor control has changed when the user clicks around.\n\t */\n\treadonly onDidChangeControl: Event<void>;\n\n\t/**\n\t * An optional event to notify when the selection inside the editor\n\t * pane changed in case the editor has a selection concept.\n\t *\n\t * For example, in a text editor pane, the selection changes whenever\n\t * the cursor is set to a new location.\n\t */\n\treadonly onDidChangeSelection?: Event<IEditorPaneSelectionChangeEvent>;\n\n\t/**\n\t * An optional event to notify when the editor inside the pane scrolled\n\t */\n\treadonly onDidChangeScroll?: Event<void>;\n\n\t/**\n\t * The assigned input of this editor.\n\t */\n\treadonly input: EditorInput | undefined;\n\n\t/**\n\t * The assigned options of the editor.\n\t */\n\treadonly options: IEditorOptions | undefined;\n\n\t/**\n\t * The assigned group this editor is showing in.\n\t */\n\treadonly group: IEditorGroup;\n\n\t/**\n\t * The minimum width of this editor.\n\t */\n\treadonly minimumWidth: number;\n\n\t/**\n\t * The maximum width of this editor.\n\t */\n\treadonly maximumWidth: number;\n\n\t/**\n\t * The minimum height of this editor.\n\t */\n\treadonly minimumHeight: number;\n\n\t/**\n\t * The maximum height of this editor.\n\t */\n\treadonly maximumHeight: number;\n\n\t/**\n\t * An event to notify whenever minimum/maximum width/height changes.\n\t */\n\treadonly onDidChangeSizeConstraints: Event<\n\t\t{ width: number; height: number } | undefined\n\t>;\n\n\t/**\n\t * The context key service for this editor. Should be overridden by\n\t * editors that have their own ScopedContextKeyService\n\t */\n\treadonly scopedContextKeyService: IContextKeyService | undefined;\n\n\t/**\n\t * Returns the underlying control of this editor. Callers need to cast\n\t * the control to a specific instance as needed, e.g. by using the\n\t * `isCodeEditor` helper method to access the text code editor.\n\t *\n\t * Use the `onDidChangeControl` event to track whenever the control\n\t * changes.\n\t */\n\tgetControl(): IEditorControl | undefined;\n\n\t/**\n\t * Returns the current view state of the editor if any.\n\t *\n\t * This method is optional to override for the editor pane\n\t * and should only be overridden when the pane can deal with\n\t * `IEditorOptions.viewState` to be applied when opening.\n\t */\n\tgetViewState(): object | undefined;\n\n\t/**\n\t * An optional method to return the current selection in\n\t * the editor pane in case the editor pane has a selection\n\t * concept.\n\t *\n\t * Clients of this method will typically react to the\n\t * `onDidChangeSelection` event to receive the current\n\t * selection as needed.\n\t */\n\tgetSelection?(): IEditorPaneSelection | undefined;\n\n\t/**\n\t * An optional method to return the current scroll position\n\t * of an editor inside the pane.\n\t *\n\t * Clients of this method will typically react to the\n\t * `onDidChangeScroll` event to receive the current\n\t * scroll position as needed.\n\t */\n\tgetScrollPosition?(): IEditorPaneScrollPosition;\n\n\t/**\n\t * An optional method to set the current scroll position\n\t * of an editor inside the pane.\n\t */\n\tsetScrollPosition?(scrollPosition: IEditorPaneScrollPosition): void;\n\n\t/**\n\t * Finds out if this editor is visible or not.\n\t */\n\tisVisible(): boolean;\n}\n\nexport interface IEditorPaneSelectionChangeEvent {\n\t/**\n\t * More details for how the selection was made.\n\t */\n\treason: EditorPaneSelectionChangeReason;\n}\n\nexport enum EditorPaneSelectionChangeReason {\n\t/**\n\t * The selection was changed as a result of a programmatic\n\t * method invocation.\n\t *\n\t * For a text editor pane, this for example can be a selection\n\t * being restored from previous view state automatically.\n\t */\n\tPROGRAMMATIC = 1,\n\n\t/**\n\t * The selection was changed by the user.\n\t *\n\t * This typically means the user changed the selection\n\t * with mouse or keyboard.\n\t */\n\tUSER = 2,\n\n\t/**\n\t * The selection was changed as a result of editing in\n\t * the editor pane.\n\t *\n\t * For a text editor pane, this for example can be typing\n\t * in the text of the editor pane.\n\t */\n\tEDIT = 3,\n\n\t/**\n\t * The selection was changed as a result of a navigation\n\t * action.\n\t *\n\t * For a text editor pane, this for example can be a result\n\t * of selecting an entry from a text outline view.\n\t */\n\tNAVIGATION = 4,\n\n\t/**\n\t * The selection was changed as a result of a jump action\n\t * from within the editor pane.\n\t *\n\t * For a text editor pane, this for example can be a result\n\t * of invoking \"Go to definition\" from a symbol.\n\t */\n\tJUMP = 5,\n}\n\nexport interface IEditorPaneSelection {\n\t/**\n\t * Asks to compare this selection to another selection.\n\t */\n\tcompare(\n\t\totherSelection: IEditorPaneSelection,\n\t): EditorPaneSelectionCompareResult;\n\n\t/**\n\t * Asks to massage the provided `options` in a way\n\t * that the selection can be restored when the editor\n\t * is opened again.\n\t *\n\t * For a text editor this means to apply the selected\n\t * line and column as text editor options.\n\t */\n\trestore(options: IEditorOptions): IEditorOptions;\n\n\t/**\n\t * Only used for logging to print more info about the selection.\n\t */\n\tlog?(): string;\n}\n\nexport enum EditorPaneSelectionCompareResult {\n\t/**\n\t * The selections are identical.\n\t */\n\tIDENTICAL = 1,\n\n\t/**\n\t * The selections are similar.\n\t *\n\t * For a text editor this can mean that the one\n\t * selection is in close proximity to the other\n\t * selection.\n\t *\n\t * Upstream clients may decide in this case to\n\t * not treat the selection different from the\n\t * previous one because it is not distinct enough.\n\t */\n\tSIMILAR = 2,\n\n\t/**\n\t * The selections are entirely different.\n\t */\n\tDIFFERENT = 3,\n}\n\nexport interface IEditorPaneWithSelection extends IEditorPane {\n\treadonly onDidChangeSelection: Event<IEditorPaneSelectionChangeEvent>;\n\n\tgetSelection(): IEditorPaneSelection | undefined;\n}\n\nexport function isEditorPaneWithSelection(\n\teditorPane: IEditorPane | undefined,\n): editorPane is IEditorPaneWithSelection {\n\tconst candidate = editorPane as IEditorPaneWithSelection | undefined;\n\n\treturn (\n\t\t!!candidate &&\n\t\ttypeof candidate.getSelection === \"function\" &&\n\t\t!!candidate.onDidChangeSelection\n\t);\n}\n\nexport interface IEditorPaneWithScrolling extends IEditorPane {\n\treadonly onDidChangeScroll: Event<void>;\n\n\tgetScrollPosition(): IEditorPaneScrollPosition;\n\n\tsetScrollPosition(position: IEditorPaneScrollPosition): void;\n}\n\nexport function isEditorPaneWithScrolling(\n\teditorPane: IEditorPane | undefined,\n): editorPane is IEditorPaneWithScrolling {\n\tconst candidate = editorPane as IEditorPaneWithScrolling | undefined;\n\n\treturn (\n\t\t!!candidate &&\n\t\ttypeof candidate.getScrollPosition === \"function\" &&\n\t\ttypeof candidate.setScrollPosition === \"function\" &&\n\t\t!!candidate.onDidChangeScroll\n\t);\n}\n\n/**\n * Scroll position of a pane\n */\nexport interface IEditorPaneScrollPosition {\n\treadonly scrollTop: number;\n\treadonly scrollLeft?: number;\n}\n\n/**\n * Try to retrieve the view state for the editor pane that\n * has the provided editor input opened, if at all.\n *\n * This method will return `undefined` if the editor input\n * is not visible in any of the opened editor panes.\n */\nexport function findViewStateForEditor(\n\tinput: EditorInput,\n\tgroup: GroupIdentifier,\n\teditorService: IEditorService,\n): object | undefined {\n\tfor (const editorPane of editorService.visibleEditorPanes) {\n\t\tif (editorPane.group.id === group && input.matches(editorPane.input)) {\n\t\t\treturn editorPane.getViewState();\n\t\t}\n\t}\n\n\treturn undefined;\n}\n\n/**\n * Overrides `IEditorPane` where `input` and `group` are known to be set.\n */\nexport interface IVisibleEditorPane extends IEditorPane {\n\treadonly input: EditorInput;\n}\n\n/**\n * The text editor pane is the container for workbench text editors.\n */\nexport interface ITextEditorPane extends IEditorPane {\n\t/**\n\t * Returns the underlying text editor widget of this editor.\n\t */\n\tgetControl(): IEditor | undefined;\n}\n\n/**\n * The text editor pane is the container for workbench text diff editors.\n */\nexport interface ITextDiffEditorPane extends IEditorPane {\n\t/**\n\t * Returns the underlying text diff editor widget of this editor.\n\t */\n\tgetControl(): IDiffEditor | undefined;\n}\n\n/**\n * Marker interface for the control inside an editor pane. Callers\n * have to cast the control to work with it, e.g. via methods\n * such as `isCodeEditor(control)`.\n */\nexport interface IEditorControl extends ICompositeControl {}\n\nexport interface IFileEditorFactory {\n\t/**\n\t * The type identifier of the file editor.\n\t */\n\ttypeId: string;\n\n\t/**\n\t * Creates new new editor capable of showing files.\n\t */\n\tcreateFileEditor(\n\t\tresource: URI,\n\t\tpreferredResource: URI | undefined,\n\t\tpreferredName: string | undefined,\n\t\tpreferredDescription: string | undefined,\n\t\tpreferredEncoding: string | undefined,\n\t\tpreferredLanguageId: string | undefined,\n\t\tpreferredContents: string | undefined,\n\t\tinstantiationService: IInstantiationService,\n\t): IFileEditorInput;\n\n\t/**\n\t * Check if the provided object is a file editor.\n\t */\n\tisFileEditor(obj: unknown): obj is IFileEditorInput;\n}\n\nexport interface IEditorFactoryRegistry {\n\t/**\n\t * Registers the file editor factory to use for file editors.\n\t */\n\tregisterFileEditorFactory(factory: IFileEditorFactory): void;\n\n\t/**\n\t * Returns the file editor factory to use for file editors.\n\t */\n\tgetFileEditorFactory(): IFileEditorFactory;\n\n\t/**\n\t * Registers a editor serializer for the given editor to the registry.\n\t * An editor serializer is capable of serializing and deserializing editor\n\t * from string data.\n\t *\n\t * @param editorTypeId the type identifier of the editor\n\t * @param serializer the editor serializer for serialization/deserialization\n\t */\n\tregisterEditorSerializer<Services extends BrandedService[]>(\n\t\teditorTypeId: string,\n\t\tctor: { new (...Services: Services): IEditorSerializer },\n\t): IDisposable;\n\n\t/**\n\t * Returns the editor serializer for the given editor.\n\t */\n\tgetEditorSerializer(editor: EditorInput): IEditorSerializer | undefined;\n\tgetEditorSerializer(editorTypeId: string): IEditorSerializer | undefined;\n\n\t/**\n\t * Starts the registry by providing the required services.\n\t */\n\tstart(accessor: ServicesAccessor): void;\n}\n\nexport interface IEditorSerializer {\n\t/**\n\t * Determines whether the given editor can be serialized by the serializer.\n\t */\n\tcanSerialize(editor: EditorInput): boolean;\n\n\t/**\n\t * Returns a string representation of the provided editor that contains enough information\n\t * to deserialize back to the original editor from the deserialize() method.\n\t */\n\tserialize(editor: EditorInput): string | undefined;\n\n\t/**\n\t * Returns an editor from the provided serialized form of the editor. This form matches\n\t * the value returned from the serialize() method.\n\t */\n\tdeserialize(\n\t\tinstantiationService: IInstantiationService,\n\t\tserializedEditor: string,\n\t): EditorInput | undefined;\n}\n\nexport interface IUntitledTextResourceEditorInput\n\textends IBaseTextResourceEditorInput {\n\t/**\n\t * Optional resource for the untitled editor. Depending on the value, the editor:\n\t * - should get a unique name if `undefined` (for example `Untitled-1`)\n\t * - should use the resource directly if the scheme is `untitled:`\n\t * - should change the scheme to `untitled:` otherwise and assume an associated path\n\t *\n\t * Untitled editors with associated path behave slightly different from other untitled\n\t * editors:\n\t * - they are dirty right when opening\n\t * - they will not ask for a file path when saving but use the associated path\n\t */\n\treadonly resource: URI | undefined;\n}\n\n/**\n * A resource side by side editor input shows 2 editors side by side but\n * without highlighting any differences.\n *\n * Note: both sides will be resolved as editor individually. As such, it is\n * possible to show 2 different editors side by side.\n *\n * @see {@link IResourceDiffEditorInput} for a variant that compares 2 editors.\n */\nexport interface IResourceSideBySideEditorInput\n\textends IBaseUntypedEditorInput {\n\t/**\n\t * The right hand side editor to open inside a side-by-side editor.\n\t */\n\treadonly primary:\n\t\t| IResourceEditorInput\n\t\t| ITextResourceEditorInput\n\t\t| IUntitledTextResourceEditorInput;\n\n\t/**\n\t * The left hand side editor to open inside a side-by-side editor.\n\t */\n\treadonly secondary:\n\t\t| IResourceEditorInput\n\t\t| ITextResourceEditorInput\n\t\t| IUntitledTextResourceEditorInput;\n}\n\n/**\n * A resource diff editor input compares 2 editors side by side\n * highlighting the differences.\n *\n * Note: both sides must be resolvable to the same editor, or\n * a text based presentation will be used as fallback.\n */\nexport interface IResourceDiffEditorInput extends IBaseUntypedEditorInput {\n\t/**\n\t * The left hand side editor to open inside a diff editor.\n\t */\n\treadonly original:\n\t\t| IResourceEditorInput\n\t\t| ITextResourceEditorInput\n\t\t| IUntitledTextResourceEditorInput;\n\n\t/**\n\t * The right hand side editor to open inside a diff editor.\n\t */\n\treadonly modified:\n\t\t| IResourceEditorInput\n\t\t| ITextResourceEditorInput\n\t\t| IUntitledTextResourceEditorInput;\n}\n\n/**\n * A resource list diff editor input compares multiple resources side by side\n * highlighting the differences.\n */\nexport interface IResourceMultiDiffEditorInput extends IBaseUntypedEditorInput {\n\t/**\n\t * A unique identifier of this multi diff editor input.\n\t * If a second multi diff editor with the same uri is opened, the existing one is revealed instead (even if the resources list is different!).\n\t */\n\treadonly multiDiffSource?: URI;\n\n\t/**\n\t * The list of resources to compare.\n\t * If not set, the resources are dynamically derived from the {@link multiDiffSource}.\n\t */\n\treadonly resources?: IMultiDiffEditorResource[];\n\n\t/**\n\t * Whether the editor should be serialized and stored for subsequent sessions.\n\t */\n\treadonly isTransient?: boolean;\n}\n\nexport interface IMultiDiffEditorResource extends IResourceDiffEditorInput {\n\treadonly goToFileResource?: URI;\n}\nexport type IResourceMergeEditorInputSide = (\n\t| IResourceEditorInput\n\t| ITextResourceEditorInput\n) & { detail?: string };\n\n/**\n * A resource merge editor input compares multiple editors\n * highlighting the differences for merging.\n *\n * Note: all sides must be resolvable to the same editor, or\n * a text based presentation will be used as fallback.\n */\nexport interface IResourceMergeEditorInput extends IBaseUntypedEditorInput {\n\t/**\n\t * The one changed version of the file.\n\t */\n\treadonly input1: IResourceMergeEditorInputSide;\n\n\t/**\n\t * The second changed version of the file.\n\t */\n\treadonly input2: IResourceMergeEditorInputSide;\n\n\t/**\n\t * The base common ancestor of the file to merge.\n\t */\n\treadonly base: IResourceEditorInput | ITextResourceEditorInput;\n\n\t/**\n\t * The resulting output of the merge.\n\t */\n\treadonly result: IResourceEditorInput | ITextResourceEditorInput;\n}\n\nexport function isResourceEditorInput(\n\teditor: unknown,\n): editor is IResourceEditorInput {\n\tif (isEditorInput(editor)) {\n\t\treturn false; // make sure to not accidentally match on typed editor inputs\n\t}\n\n\tconst candidate = editor as IResourceEditorInput | undefined;\n\n\treturn URI.isUri(candidate?.resource);\n}\n\nexport function isResourceDiffEditorInput(\n\teditor: unknown,\n): editor is IResourceDiffEditorInput {\n\tif (isEditorInput(editor)) {\n\t\treturn false; // make sure to not accidentally match on typed editor inputs\n\t}\n\n\tconst candidate = editor as IResourceDiffEditorInput | undefined;\n\n\treturn (\n\t\tcandidate?.original !== undefined && candidate.modified !== undefined\n\t);\n}\n\nexport function isResourceMultiDiffEditorInput(\n\teditor: unknown,\n): editor is IResourceMultiDiffEditorInput {\n\tif (isEditorInput(editor)) {\n\t\treturn false; // make sure to not accidentally match on typed editor inputs\n\t}\n\n\tconst candidate = editor as IResourceMultiDiffEditorInput | undefined;\n\tif (!candidate) {\n\t\treturn false;\n\t}\n\tif (candidate.resources && !Array.isArray(candidate.resources)) {\n\t\treturn false;\n\t}\n\n\treturn !!candidate.resources || !!candidate.multiDiffSource;\n}\n\nexport function isResourceSideBySideEditorInput(\n\teditor: unknown,\n): editor is IResourceSideBySideEditorInput {\n\tif (isEditorInput(editor)) {\n\t\treturn false; // make sure to not accidentally match on typed editor inputs\n\t}\n\n\tif (isResourceDiffEditorInput(editor)) {\n\t\treturn false; // make sure to not accidentally match on diff editors\n\t}\n\n\tconst candidate = editor as IResourceSideBySideEditorInput | undefined;\n\n\treturn (\n\t\tcandidate?.primary !== undefined && candidate.secondary !== undefined\n\t);\n}\n\nexport function isUntitledResourceEditorInput(\n\teditor: unknown,\n): editor is IUntitledTextResourceEditorInput {\n\tif (isEditorInput(editor)) {\n\t\treturn false; // make sure to not accidentally match on typed editor inputs\n\t}\n\n\tconst candidate = editor as IUntitledTextResourceEditorInput | undefined;\n\tif (!candidate) {\n\t\treturn false;\n\t}\n\n\treturn (\n\t\tcandidate.resource === undefined ||\n\t\tcandidate.resource.scheme === Schemas.untitled ||\n\t\tcandidate.forceUntitled === true\n\t);\n}\n\nexport function isResourceMergeEditorInput(\n\teditor: unknown,\n): editor is IResourceMergeEditorInput {\n\tif (isEditorInput(editor)) {\n\t\treturn false; // make sure to not accidentally match on typed editor inputs\n\t}\n\n\tconst candidate = editor as IResourceMergeEditorInput | undefined;\n\n\treturn (\n\t\tURI.isUri(candidate?.base?.resource) &&\n\t\tURI.isUri(candidate?.input1?.resource) &&\n\t\tURI.isUri(candidate?.input2?.resource) &&\n\t\tURI.isUri(candidate?.result?.resource)\n\t);\n}\n\nexport enum Verbosity {\n\tSHORT = 0,\n\tMEDIUM = 1,\n\tLONG = 2,\n}\n\nexport enum SaveReason {\n\t/**\n\t * Explicit user gesture.\n\t */\n\tEXPLICIT = 1,\n\n\t/**\n\t * Auto save after a timeout.\n\t */\n\tAUTO = 2,\n\n\t/**\n\t * Auto save after editor focus change.\n\t */\n\tFOCUS_CHANGE = 3,\n\n\t/**\n\t * Auto save after window change.\n\t */\n\tWINDOW_CHANGE = 4,\n}\n\nexport type SaveSource = string;\n\ninterface ISaveSourceDescriptor {\n\tsource: SaveSource;\n\tlabel: string;\n}\n\nclass SaveSourceFactory {\n\tprivate readonly mapIdToSaveSource = new Map<\n\t\tSaveSource,\n\t\tISaveSourceDescriptor\n\t>();\n\n\t/**\n\t * Registers a `SaveSource` with an identifier and label\n\t * to the registry so that it can be used in save operations.\n\t */\n\tregisterSource(id: string, label: string): SaveSource {\n\t\tlet sourceDescriptor = this.mapIdToSaveSource.get(id);\n\t\tif (!sourceDescriptor) {\n\t\t\tsourceDescriptor = { source: id, label };\n\t\t\tthis.mapIdToSaveSource.set(id, sourceDescriptor);\n\t\t}\n\n\t\treturn sourceDescriptor.source;\n\t}\n\n\tgetSourceLabel(source: SaveSource): string {\n\t\treturn this.mapIdToSaveSource.get(source)?.label ?? source;\n\t}\n}\n\nexport const SaveSourceRegistry = new SaveSourceFactory();\n\nexport interface ISaveOptions {\n\t/**\n\t * An indicator how the save operation was triggered.\n\t */\n\treason?: SaveReason;\n\n\t/**\n\t * An indicator about the source of the save operation.\n\t *\n\t * Must use `SaveSourceRegistry.registerSource()` to obtain.\n\t */\n\treadonly source?: SaveSource;\n\n\t/**\n\t * Forces to save the contents of the working copy\n\t * again even if the working copy is not dirty.\n\t */\n\treadonly force?: boolean;\n\n\t/**\n\t * Instructs the save operation to skip any save participants.\n\t */\n\treadonly skipSaveParticipants?: boolean;\n\n\t/**\n\t * A hint as to which file systems should be available for saving.\n\t */\n\treadonly availableFileSystems?: string[];\n}\n\nexport interface IRevertOptions {\n\t/**\n\t * Forces to load the contents of the working copy\n\t * again even if the working copy is not dirty.\n\t */\n\treadonly force?: boolean;\n\n\t/**\n\t * A soft revert will clear dirty state of a working copy\n\t * but will not attempt to load it from its persisted state.\n\t *\n\t * This option may be used in scenarios where an editor is\n\t * closed and where we do not require to load the contents.\n\t */\n\treadonly soft?: boolean;\n}\n\nexport interface IMoveResult {\n\teditor: EditorInput | IUntypedEditorInput;\n\toptions?: IEditorOptions;\n}\n\nexport enum EditorInputCapabilities {\n\t/**\n\t * Signals no specific capability for the input.\n\t */\n\tNone = 0,\n\n\t/**\n\t * Signals that the input is readonly.\n\t */\n\tReadonly = 1 << 1,\n\n\t/**\n\t * Signals that the input is untitled.\n\t */\n\tUntitled = 1 << 2,\n\n\t/**\n\t * Signals that the input can only be shown in one group\n\t * and not be split into multiple groups.\n\t */\n\tSingleton = 1 << 3,\n\n\t/**\n\t * Signals that the input requires workspace trust.\n\t */\n\tRequiresTrust = 1 << 4,\n\n\t/**\n\t * Signals that the editor can split into 2 in the same\n\t * editor group.\n\t */\n\tCanSplitInGroup = 1 << 5,\n\n\t/**\n\t * Signals that the editor wants its description to be\n\t * visible when presented to the user. By default, a UI\n\t * component may decide to hide the description portion\n\t * for brevity.\n\t */\n\tForceDescription = 1 << 6,\n\n\t/**\n\t * Signals that the editor supports dropping into the\n\t * editor by holding shift.\n\t */\n\tCanDropIntoEditor = 1 << 7,\n\n\t/**\n\t * Signals that the editor is composed of multiple editors\n\t * within.\n\t */\n\tMultipleEditors = 1 << 8,\n\n\t/**\n\t * Signals that the editor cannot be in a dirty state\n\t * and may still have unsaved changes\n\t */\n\tScratchpad = 1 << 9,\n}\n\nexport type IUntypedEditorInput =\n\t| IResourceEditorInput\n\t| ITextResourceEditorInput\n\t| IUntitledTextResourceEditorInput\n\t| IResourceDiffEditorInput\n\t| IResourceMultiDiffEditorInput\n\t| IResourceSideBySideEditorInput\n\t| IResourceMergeEditorInput;\n\nexport abstract class AbstractEditorInput extends Disposable {\n\t// Marker class for implementing `isEditorInput`\n}\n\nexport function isEditorInput(editor: unknown): editor is EditorInput {\n\treturn editor instanceof AbstractEditorInput;\n}\n\nexport interface EditorInputWithPreferredResource {\n\t/**\n\t * An editor may provide an additional preferred resource alongside\n\t * the `resource` property. While the `resource` property serves as\n\t * unique identifier of the editor that should be used whenever we\n\t * compare to other editors, the `preferredResource` should be used\n\t * in places where e.g. the resource is shown to the user.\n\t *\n\t * For example: on Windows and macOS, the same URI with different\n\t * casing may point to the same file. The editor may chose to\n\t * \"normalize\" the URIs so that only one editor opens for different\n\t * URIs. But when displaying the editor label to the user, the\n\t * preferred URI should be used.\n\t *\n\t * Not all editors have a `preferredResource`. The `EditorResourceAccessor`\n\t * utility can be used to always get the right resource without having\n\t * to do instanceof checks.\n\t */\n\treadonly preferredResource: URI;\n}\n\nfunction isEditorInputWithPreferredResource(\n\teditor: unknown,\n): editor is EditorInputWithPreferredResource {\n\tconst candidate = editor as EditorInputWithPreferredResource | undefined;\n\n\treturn URI.isUri(candidate?.preferredResource);\n}\n\nexport interface ISideBySideEditorInput extends EditorInput {\n\t/**\n\t * The primary editor input is shown on the right hand side.\n\t */\n\tprimary: EditorInput;\n\n\t/**\n\t * The secondary editor input is shown on the left hand side.\n\t */\n\tsecondary: EditorInput;\n}\n\nexport function isSideBySideEditorInput(\n\teditor: unknown,\n): editor is ISideBySideEditorInput {\n\tconst candidate = editor as ISideBySideEditorInput | undefined;\n\n\treturn (\n\t\tisEditorInput(candidate?.primary) && isEditorInput(candidate?.secondary)\n\t);\n}\n\nexport interface IDiffEditorInput extends EditorInput {\n\t/**\n\t * The modified (primary) editor input is shown on the right hand side.\n\t */\n\tmodified: EditorInput;\n\n\t/**\n\t * The original (secondary) editor input is shown on the left hand side.\n\t */\n\toriginal: EditorInput;\n}\n\nexport function isDiffEditorInput(editor: unknown): editor is IDiffEditorInput {\n\tconst candidate = editor as IDiffEditorInput | undefined;\n\n\treturn (\n\t\tisEditorInput(candidate?.modified) && isEditorInput(candidate?.original)\n\t);\n}\n\nexport interface IUntypedFileEditorInput extends ITextResourceEditorInput {\n\t/**\n\t * A marker to create a `IFileEditorInput` from this untyped input.\n\t */\n\tforceFile: true;\n}\n\n/**\n * This is a tagging interface to declare an editor input being capable of dealing with files. It is only used in the editor registry\n * to register this kind of input to the platform.\n */\nexport interface IFileEditorInput\n\textends EditorInput,\n\t\tIEncodingSupport,\n\t\tILanguageSupport,\n\t\tEditorInputWithPreferredResource {\n\t/**\n\t * Gets the resource this file input is about. This will always be the\n\t * canonical form of the resource, so it may differ from the original\n\t * resource that was provided to create the input. Use `preferredResource`\n\t * for the form as it was created.\n\t */\n\treadonly resource: URI;\n\n\t/**\n\t * Sets the preferred resource to use for this file input.\n\t */\n\tsetPreferredResource(preferredResource: URI): void;\n\n\t/**\n\t * Sets the preferred name to use for this file input.\n\t *\n\t * Note: for certain file schemes the input may decide to ignore this\n\t * name and use our standard naming. Specifically for schemes we own,\n\t * we do not let others override the name.\n\t */\n\tsetPreferredName(name: string): void;\n\n\t/**\n\t * Sets the preferred description to use for this file input.\n\t *\n\t * Note: for certain file schemes the input may decide to ignore this\n\t * description and use our standard naming. Specifically for schemes we own,\n\t * we do not let others override the description.\n\t */\n\tsetPreferredDescription(description: string): void;\n\n\t/**\n\t * Sets the preferred encoding to use for this file input.\n\t */\n\tsetPreferredEncoding(encoding: string): void;\n\n\t/**\n\t * Sets the preferred language id to use for this file input.\n\t */\n\tsetPreferredLanguageId(languageId: string): void;\n\n\t/**\n\t * Sets the preferred contents to use for this file input.\n\t */\n\tsetPreferredContents(contents: string): void;\n\n\t/**\n\t * Forces this file input to open as binary instead of text.\n\t */\n\tsetForceOpenAsBinary(): void;\n\n\t/**\n\t * Figure out if the file input has been resolved or not.\n\t */\n\tisResolved(): boolean;\n}\n\nexport interface IFileLimitedEditorInputOptions extends IEditorOptions {\n\t/**\n\t * If provided, the size of the file will be checked against the limits\n\t * and an error will be thrown if any limit is exceeded.\n\t */\n\treadonly limits?: IFileReadLimits;\n}\n\nexport interface IFileEditorInputOptions\n\textends ITextEditorOptions,\n\t\tIFileLimitedEditorInputOptions {}\n\nexport function createTooLargeFileError(\n\tgroup: IEditorGroup,\n\tinput: EditorInput,\n\toptions: IEditorOptions | undefined,\n\tmessage: string,\n\tpreferencesService: IPreferencesService,\n): Error {\n\treturn createEditorOpenError(\n\t\tmessage,\n\t\t[\n\t\t\ttoAction({\n\t\t\t\tid: \"workbench.action.openLargeFile\",\n\t\t\t\tlabel: localize(\"openLargeFile\", \"Open Anyway\"),\n\t\t\t\trun: () => {\n\t\t\t\t\tconst fileEditorOptions: IFileEditorInputOptions = {\n\t\t\t\t\t\t...options,\n\t\t\t\t\t\tlimits: {\n\t\t\t\t\t\t\tsize: Number.MAX_VALUE,\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\n\t\t\t\t\tgroup.openEditor(input, fileEditorOptions);\n\t\t\t\t},\n\t\t\t}),\n\t\t\ttoAction({\n\t\t\t\tid: \"workbench.action.configureEditorLargeFileConfirmation\",\n\t\t\t\tlabel: localize(\n\t\t\t\t\t\"configureEditorLargeFileConfirmation\",\n\t\t\t\t\t\"Configure Limit\",\n\t\t\t\t),\n\t\t\t\trun: () => {\n\t\t\t\t\treturn preferencesService.openUserSettings({\n\t\t\t\t\t\tquery: \"workbench.editorLargeFileConfirmation\",\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t}),\n\t\t],\n\t\t{\n\t\t\tforceMessage: true,\n\t\t\tforceSeverity: Severity.Warning,\n\t\t},\n\t);\n}\n\nexport interface EditorInputWithOptions {\n\teditor: EditorInput;\n\toptions?: IEditorOptions;\n}\n\nexport interface EditorInputWithOptionsAndGroup extends EditorInputWithOptions {\n\tgroup: IEditorGroup;\n}\n\nexport function isEditorInputWithOptions(\n\teditor: unknown,\n): editor is EditorInputWithOptions {\n\tconst candidate = editor as EditorInputWithOptions | undefined;\n\n\treturn isEditorInput(candidate?.editor);\n}\n\nexport function isEditorInputWithOptionsAndGroup(\n\teditor: unknown,\n): editor is EditorInputWithOptionsAndGroup {\n\tconst candidate = editor as EditorInputWithOptionsAndGroup | undefined;\n\n\treturn isEditorInputWithOptions(editor) && candidate?.group !== undefined;\n}\n\n/**\n * Context passed into `EditorPane#setInput` to give additional\n * context information around why the editor was opened.\n */\nexport interface IEditorOpenContext {\n\t/**\n\t * An indicator if the editor input is new for the group the editor is in.\n\t * An editor is new for a group if it was not part of the group before and\n\t * otherwise was already opened in the group and just became the active editor.\n\t *\n\t * This hint can e.g. be used to decide whether to restore view state or not.\n\t */\n\tnewInGroup?: boolean;\n}\n\nexport interface IEditorIdentifier {\n\tgroupId: GroupIdentifier;\n\teditor: EditorInput;\n}\n\nexport function isEditorIdentifier(\n\tidentifier: unknown,\n): identifier is IEditorIdentifier {\n\tconst candidate = identifier as IEditorIdentifier | undefined;\n\n\treturn (\n\t\ttypeof candidate?.groupId === \"number\" &&\n\t\tisEditorInput(candidate.editor)\n\t);\n}\n\n/**\n * The editor commands context is used for editor commands (e.g. in the editor title)\n * and we must ensure that the context is serializable because it potentially travels\n * to the extension host!\n */\nexport interface IEditorCommandsContext {\n\tgroupId: GroupIdentifier;\n\teditorIndex?: number;\n\n\tpreserveFocus?: boolean;\n}\n\nexport function isEditorCommandsContext(\n\tcontext: unknown,\n): context is IEditorCommandsContext {\n\tconst candidate = context as IEditorCommandsContext | undefined;\n\n\treturn typeof candidate?.groupId === \"number\";\n}\n\n/**\n * More information around why an editor was closed in the model.\n */\nexport enum EditorCloseContext {\n\t/**\n\t * No specific context for closing (e.g. explicit user gesture).\n\t */\n\tUNKNOWN = 0,\n\n\t/**\n\t * The editor closed because it was replaced with another editor.\n\t * This can either happen via explicit replace call or when an\n\t * editor is in preview mode and another editor opens.\n\t */\n\tREPLACE = 1,\n\n\t/**\n\t * The editor closed as a result of moving it to another group.\n\t */\n\tMOVE = 2,\n\n\t/**\n\t * The editor closed because another editor turned into preview\n\t * and this used to be the preview editor before.\n\t */\n\tUNPIN = 3,\n}\n\nexport interface IEditorCloseEvent extends IEditorIdentifier {\n\t/**\n\t * More information around why the editor was closed.\n\t */\n\treadonly context: EditorCloseContext;\n\n\t/**\n\t * The index of the editor before closing.\n\t */\n\treadonly index: number;\n\n\t/**\n\t * Whether the editor was sticky or not.\n\t */\n\treadonly sticky: boolean;\n}\n\nexport interface IActiveEditorChangeEvent {\n\t/**\n\t * The new active editor or `undefined` if the group is empty.\n\t */\n\teditor: EditorInput | undefined;\n}\n\nexport interface IEditorWillMoveEvent extends IEditorIdentifier {\n\t/**\n\t * The target group of the move operation.\n\t */\n\treadonly target: GroupIdentifier;\n}\n\nexport interface IEditorWillOpenEvent extends IEditorIdentifier {}\n\nexport interface IWillInstantiateEditorPaneEvent {\n\t/**\n\t * @see {@link IEditorDescriptor.typeId}\n\t */\n\treadonly typeId: string;\n}\n\nexport type GroupIdentifier = number;\n\nexport enum GroupModelChangeKind {\n\t/* Group Changes */\n\tGROUP_ACTIVE = 0,\n\tGROUP_INDEX = 1,\n\tGROUP_LABEL = 2,\n\tGROUP_LOCKED = 3,\n\n\t/* Editors Change */\n\tEDITORS_SELECTION = 4,\n\n\t/* Editor Changes */\n\tEDITOR_OPEN = 5,\n\tEDITOR_CLOSE = 6,\n\tEDITOR_MOVE = 7,\n\tEDITOR_ACTIVE = 8,\n\tEDITOR_LABEL = 9,\n\tEDITOR_CAPABILITIES = 10,\n\tEDITOR_PIN = 11,\n\tEDITOR_TRANSIENT = 12,\n\tEDITOR_STICKY = 13,\n\tEDITOR_DIRTY = 14,\n\tEDITOR_WILL_DISPOSE = 15,\n}\n\nexport interface IWorkbenchEditorConfiguration {\n\tworkbench?: {\n\t\teditor?: IEditorPartConfiguration;\n\t\ticonTheme?: string;\n\t};\n}\n\ninterface IEditorPartLimitConfiguration {\n\tenabled?: boolean;\n\texcludeDirty?: boolean;\n\tvalue?: number;\n\tperEditorGroup?: boolean;\n}\n\nexport interface IEditorPartLimitOptions\n\textends Required<IEditorPartLimitConfiguration> {}\n\ninterface IEditorPartDecorationsConfiguration {\n\tbadges?: boolean;\n\tcolors?: boolean;\n}\n\nexport interface IEditorPartDecorationOptions\n\textends Required<IEditorPartDecorationsConfiguration> {}\n\ninterface IEditorPartConfiguration {\n\tshowTabs?: \"multiple\" | \"single\" | \"none\";\n\twrapTabs?: boolean;\n\tscrollToSwitchTabs?: boolean;\n\thighlightModifiedTabs?: boolean;\n\ttabActionLocation?: \"left\" | \"right\";\n\ttabActionCloseVisibility?: boolean;\n\ttabActionUnpinVisibility?: boolean;\n\talwaysShowEditorActions?: boolean;\n\ttabSizing?: \"fit\" | \"shrink\" | \"fixed\";\n\ttabSizingFixedMinWidth?: number;\n\ttabSizingFixedMaxWidth?: number;\n\tpinnedTabSizing?: \"normal\" | \"compact\" | \"shrink\";\n\tpinnedTabsOnSeparateRow?: boolean;\n\ttabHeight?: \"default\" | \"compact\";\n\tpreventPinnedEditorClose?: PreventPinnedEditorClose;\n\ttitleScrollbarSizing?: \"default\" | \"large\";\n\tfocusRecentEditorAfterClose?: boolean;\n\tshowIcons?: boolean;\n\tenablePreview?: boolean;\n\tenablePreviewFromQuickOpen?: boolean;\n\tenablePreviewFromCodeNavigation?: boolean;\n\tcloseOnFileDelete?: boolean;\n\topenPositioning?: \"left\" | \"right\" | \"first\" | \"last\";\n\topenSideBySideDirection?: \"right\" | \"down\";\n\tcloseEmptyGroups?: boolean;\n\tautoLockGroups?: Set<string>;\n\trevealIfOpen?: boolean;\n\tmouseBackForwardToNavigate?: boolean;\n\tlabelFormat?: \"default\" | \"short\" | \"medium\" | \"long\";\n\trestoreViewState?: boolean;\n\tsplitInGroupLayout?: \"vertical\" | \"horizontal\";\n\tsplitSizing?: \"auto\" | \"split\" | \"distribute\";\n\tsplitOnDragAndDrop?: boolean;\n\tdragToOpenWindow?: boolean;\n\tcenteredLayoutFixedWidth?: boolean;\n\tdoubleClickTabToToggleEditorGroupSizes?: \"maximize\" | \"expand\" | \"off\";\n\teditorActionsLocation?: \"default\" | \"titleBar\" | \"hidden\";\n\tlimit?: IEditorPartLimitConfiguration;\n\tdecorations?: IEditorPartDecorationsConfiguration;\n}\n\nexport interface IEditorPartOptions\n\textends DeepRequiredNonNullable<IEditorPartConfiguration> {\n\thasIcons: boolean;\n}\n\nexport interface IEditorPartOptionsChangeEvent {\n\toldPartOptions: IEditorPartOptions;\n\tnewPartOptions: IEditorPartOptions;\n}\n\nexport enum SideBySideEditor {\n\tPRIMARY = 1,\n\tSECONDARY = 2,\n\tBOTH = 3,\n\tANY = 4,\n}\n\nexport interface IFindEditorOptions {\n\t/**\n\t * Whether to consider any or both side by side editor as matching.\n\t * By default, side by side editors will not be considered\n\t * as matching, even if the editor is opened in one of the sides.\n\t */\n\tsupportSideBySide?:\n\t\t| SideBySideEditor.PRIMARY\n\t\t| SideBySideEditor.SECONDARY\n\t\t| SideBySideEditor.ANY;\n}\n\nexport interface IMatchEditorOptions {\n\t/**\n\t * Whether to consider a side by side editor as matching.\n\t * By default, side by side editors will not be considered\n\t * as matching, even if the editor is opened in one of the sides.\n\t */\n\tsupportSideBySide?: SideBySideEditor.ANY | SideBySideEditor.BOTH;\n\n\t/**\n\t * Only consider an editor to match when the\n\t * `candidate === editor` but not when\n\t * `candidate.matches(editor)`.\n\t */\n\tstrictEquals?: boolean;\n}\n\nexport interface IEditorResourceAccessorOptions {\n\t/**\n\t * Allows to access the `resource(s)` of side by side editors. If not\n\t * specified, a `resource` for a side by side editor will always be\n\t * `undefined`.\n\t */\n\tsupportSideBySide?: SideBySideEditor;\n\n\t/**\n\t * Allows to filter the scheme to consider. A resource scheme that does\n\t * not match a filter will not be considered.\n\t */\n\tfilterByScheme?: string | string[];\n}\n\nclass EditorResourceAccessorImpl {\n\t/**\n\t * The original URI of an editor is the URI that was used originally to open\n\t * the editor and should be used whenever the URI is presented to the user,\n\t * e.g. as a label together with utility methods such as `ResourceLabel` or\n\t * `ILabelService` that can turn this original URI into the best form for\n\t * presenting.\n\t *\n\t * In contrast, the canonical URI (#getCanonicalUri) may be different and should\n\t * be used whenever the URI is used to e.g. compare with other editors or when\n\t * caching certain data based on the URI.\n\t *\n\t * For example: on Windows and macOS, the same file URI with different casing may\n\t * point to the same file. The editor may chose to \"normalize\" the URI into a canonical\n\t * form so that only one editor opens for same file URIs with different casing. As\n\t * such, the original URI and the canonical URI can be different.\n\t */\n\tgetOriginalUri(\n\t\teditor: EditorInput | IUntypedEditorInput | undefined | null,\n\t): URI | undefined;\n\tgetOriginalUri(\n\t\teditor: EditorInput | IUntypedEditorInput | undefined | null,\n\t\toptions: IEditorResourceAccessorOptions & {\n\t\t\tsupportSideBySide?:\n\t\t\t\t| SideBySideEditor.PRIMARY\n\t\t\t\t| SideBySideEditor.SECONDARY\n\t\t\t\t| SideBySideEditor.ANY;\n\t\t},\n\t): URI | undefined;\n\tgetOriginalUri(\n\t\teditor: EditorInput | IUntypedEditorInput | undefined | null,\n\t\toptions: IEditorResourceAccessorOptions & {\n\t\t\tsupportSideBySide: SideBySideEditor.BOTH;\n\t\t},\n\t): URI | { primary?: URI; secondary?: URI } | undefined;\n\tgetOriginalUri(\n\t\teditor: EditorInput | IUntypedEditorInput | undefined | null,\n\t\toptions?: IEditorResourceAccessorOptions,\n\t): URI | { primary?: URI; secondary?: URI } | undefined;\n\tgetOriginalUri(\n\t\teditor: EditorInput | IUntypedEditorInput | undefined | null,\n\t\toptions?: IEditorResourceAccessorOptions,\n\t): URI | { primary?: URI; secondary?: URI } | undefined {\n\t\tif (!editor) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Merge editors are handled with `merged` result editor\n\t\tif (isResourceMergeEditorInput(editor)) {\n\t\t\treturn EditorResourceAccessor.getOriginalUri(\n\t\t\t\teditor.result,\n\t\t\t\toptions,\n\t\t\t);\n\t\t}\n\n\t\t// Optionally support side-by-side editors\n\t\tif (options?.supportSideBySide) {\n\t\t\tconst { primary, secondary } = this.getSideEditors(editor);\n\t\t\tif (primary && secondary) {\n\t\t\t\tif (options?.supportSideBySide === SideBySideEditor.BOTH) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tprimary: this.getOriginalUri(primary, {\n\t\t\t\t\t\t\tfilterByScheme: options.filterByScheme,\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tsecondary: this.getOriginalUri(secondary, {\n\t\t\t\t\t\t\tfilterByScheme: options.filterByScheme,\n\t\t\t\t\t\t}),\n\t\t\t\t\t};\n\t\t\t\t} else if (\n\t\t\t\t\toptions?.supportSideBySide === SideBySideEditor.ANY\n\t\t\t\t) {\n\t\t\t\t\treturn (\n\t\t\t\t\t\tthis.getOriginalUri(primary, {\n\t\t\t\t\t\t\tfilterByScheme: options.filterByScheme,\n\t\t\t\t\t\t}) ??\n\t\t\t\t\t\tthis.getOriginalUri(secondary, {\n\t\t\t\t\t\t\tfilterByScheme: options.filterByScheme,\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\teditor =\n\t\t\t\t\toptions.supportSideBySide === SideBySideEditor.PRIMARY\n\t\t\t\t\t\t? primary\n\t\t\t\t\t\t: secondary;\n\t\t\t}\n\t\t}\n\n\t\tif (\n\t\t\tisResourceDiffEditorInput(editor) ||\n\t\t\tisResourceMultiDiffEditorInput(editor) ||\n\t\t\tisResourceSideBySideEditorInput(editor) ||\n\t\t\tisResourceMergeEditorInput(editor)\n\t\t) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Original URI is the `preferredResource` of an editor if any\n\t\tconst originalResource = isEditorInputWithPreferredResource(editor)\n\t\t\t? editor.preferredResource\n\t\t\t: editor.resource;\n\t\tif (!originalResource || !options || !options.filterByScheme) {\n\t\t\treturn originalResource;\n\t\t}\n\n\t\treturn this.filterUri(originalResource, options.filterByScheme);\n\t}\n\n\tprivate getSideEditors(editor: EditorInput | IUntypedEditorInput): {\n\t\tprimary: EditorInput | IUntypedEditorInput | undefined;\n\t\tsecondary: EditorInput | IUntypedEditorInput | undefined;\n\t} {\n\t\tif (\n\t\t\tisSideBySideEditorInput(editor) ||\n\t\t\tisResourceSideBySideEditorInput(editor)\n\t\t) {\n\t\t\treturn { primary: editor.primary, secondary: editor.secondary };\n\t\t}\n\n\t\tif (isDiffEditorInput(editor) || isResourceDiffEditorInput(editor)) {\n\t\t\treturn { primary: editor.modified, secondary: editor.original };\n\t\t}\n\n\t\treturn { primary: undefined, secondary: undefined };\n\t}\n\n\t/**\n\t * The canonical URI of an editor is the true unique identifier of the editor\n\t * and should be used whenever the URI is used e.g. to compare with other\n\t * editors or when caching certain data based on the URI.\n\t *\n\t * In contrast, the original URI (#getOriginalUri) may be different and should\n\t * be used whenever the URI is presented to the user, e.g. as a label.\n\t *\n\t * For example: on Windows and macOS, the same file URI with different casing may\n\t * point to the same file. The editor may chose to \"normalize\" the URI into a canonical\n\t * form so that only one editor opens for same file URIs with different casing. As\n\t * such, the original URI and the canonical URI can be different.\n\t */\n\tgetCanonicalUri(\n\t\teditor: EditorInput | IUntypedEditorInput | undefined | null,\n\t): URI | undefined;\n\tgetCanonicalUri(\n\t\teditor: EditorInput | IUntypedEditorInput | undefined | null,\n\t\toptions: IEditorResourceAccessorOptions & {\n\t\t\tsupportSideBySide?:\n\t\t\t\t| SideBySideEditor.PRIMARY\n\t\t\t\t| SideBySideEditor.SECONDARY\n\t\t\t\t| SideBySideEditor.ANY;\n\t\t},\n\t): URI | undefined;\n\tgetCanonicalUri(\n\t\teditor: EditorInput | IUntypedEditorInput | undefined | null,\n\t\toptions: IEditorResourceAccessorOptions & {\n\t\t\tsupportSideBySide: SideBySideEditor.BOTH;\n\t\t},\n\t): URI | { primary?: URI; secondary?: URI } | undefined;\n\tgetCanonicalUri(\n\t\teditor: EditorInput | IUntypedEditorInput | undefined | null,\n\t\toptions?: IEditorResourceAccessorOptions,\n\t): URI | { primary?: URI; secondary?: URI } | undefined;\n\tgetCanonicalUri(\n\t\teditor: EditorInput | IUntypedEditorInput | undefined | null,\n\t\toptions?: IEditorResourceAccessorOptions,\n\t): URI | { primary?: URI; secondary?: URI } | undefined {\n\t\tif (!editor) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Merge editors are handled with `merged` result editor\n\t\tif (isResourceMergeEditorInput(editor)) {\n\t\t\treturn EditorResourceAccessor.getCanonicalUri(\n\t\t\t\teditor.result,\n\t\t\t\toptions,\n\t\t\t);\n\t\t}\n\n\t\t// Optionally support side-by-side editors\n\t\tif (options?.supportSideBySide) {\n\t\t\tconst { primary, secondary } = this.getSideEditors(editor);\n\t\t\tif (primary && secondary) {\n\t\t\t\tif (options?.supportSideBySide === SideBySideEditor.BOTH) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tprimary: this.getCanonicalUri(primary, {\n\t\t\t\t\t\t\tfilterByScheme: options.filterByScheme,\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tsecondary: this.getCanonicalUri(secondary, {\n\t\t\t\t\t\t\tfilterByScheme: options.filterByScheme,\n\t\t\t\t\t\t}),\n\t\t\t\t\t};\n\t\t\t\t} else if (\n\t\t\t\t\toptions?.supportSideBySide === SideBySideEditor.ANY\n\t\t\t\t) {\n\t\t\t\t\treturn (\n\t\t\t\t\t\tthis.getCanonicalUri(primary, {\n\t\t\t\t\t\t\tfilterByScheme: options.filterByScheme,\n\t\t\t\t\t\t}) ??\n\t\t\t\t\t\tthis.getCanonicalUri(secondary, {\n\t\t\t\t\t\t\tfilterByScheme: options.filterByScheme,\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\teditor =\n\t\t\t\t\toptions.supportSideBySide === SideBySideEditor.PRIMARY\n\t\t\t\t\t\t? primary\n\t\t\t\t\t\t: secondary;\n\t\t\t}\n\t\t}\n\n\t\tif (\n\t\t\tisResourceDiffEditorInput(editor) ||\n\t\t\tisResourceMultiDiffEditorInput(editor) ||\n\t\t\tisResourceSideBySideEditorInput(editor) ||\n\t\t\tisResourceMergeEditorInput(editor)\n\t\t) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Canonical URI is the `resource` of an editor\n\t\tconst canonicalResource = editor.resource;\n\t\tif (!canonicalResource || !options || !options.filterByScheme) {\n\t\t\treturn canonicalResource;\n\t\t}\n\n\t\treturn this.filterUri(canonicalResource, options.filterByScheme);\n\t}\n\n\tprivate filterUri(\n\t\tresource: URI,\n\t\tfilter: string | string[],\n\t): URI | undefined {\n\t\t// Multiple scheme filter\n\t\tif (Array.isArray(filter)) {\n\t\t\tif (filter.some((scheme) => resource.scheme === scheme)) {\n\t\t\t\treturn resource;\n\t\t\t}\n\t\t}\n\n\t\t// Single scheme filter\n\t\telse if (filter === resource.scheme) {\n\t\t\treturn resource;\n\t\t}\n\n\t\treturn undefined;\n\t}\n}\n\nexport type PreventPinnedEditorClose =\n\t| \"keyboardAndMouse\"\n\t| \"keyboard\"\n\t| \"mouse\"\n\t| \"never\"\n\t| undefined;\n\nexport enum EditorCloseMethod {\n\tUNKNOWN = 0,\n\tKEYBOARD = 1,\n\tMOUSE = 2,\n}\n\nexport function preventEditorClose(\n\tgroup: IEditorGroup | IReadonlyEditorGroupModel,\n\teditor: EditorInput,\n\tmethod: EditorCloseMethod,\n\tconfiguration: IEditorPartConfiguration,\n): boolean {\n\tif (!group.isSticky(editor)) {\n\t\treturn false; // only interested in sticky editors\n\t}\n\n\tswitch (configuration.preventPinnedEditorClose) {\n\t\tcase \"keyboardAndMouse\":\n\t\t\treturn (\n\t\t\t\tmethod === EditorCloseMethod.MOUSE ||\n\t\t\t\tmethod === EditorCloseMethod.KEYBOARD\n\t\t\t);\n\t\tcase \"mouse\":\n\t\t\treturn method === EditorCloseMethod.MOUSE;\n\t\tcase \"keyboard\":\n\t\t\treturn method === EditorCloseMethod.KEYBOARD;\n\t}\n\n\treturn false;\n}\n\nexport const EditorResourceAccessor = new EditorResourceAccessorImpl();\n\nexport enum CloseDirection {\n\tLEFT = 0,\n\tRIGHT = 1,\n}\n\nexport interface IEditorMemento<T> {\n\tsaveEditorState(group: IEditorGroup, resource: URI, state: T): void;\n\tsaveEditorState(group: IEditorGroup, editor: EditorInput, state: T): void;\n\n\tloadEditorState(group: IEditorGroup, resource: URI): T | undefined;\n\tloadEditorState(group: IEditorGroup, editor: EditorInput): T | undefined;\n\n\tclearEditorState(resource: URI, group?: IEditorGroup): void;\n\tclearEditorState(editor: EditorInput, group?: IEditorGroup): void;\n\n\tclearEditorStateOnDispose(resource: URI, editor: EditorInput): void;\n\n\tmoveEditorState(source: URI, target: URI, comparer: IExtUri): void;\n}\n\nclass EditorFactoryRegistry implements IEditorFactoryRegistry {\n\tprivate instantiationService: IInstantiationService | undefined;\n\n\tprivate fileEditorFactory: IFileEditorFactory | undefined;\n\n\tprivate readonly editorSerializerConstructors = new Map<\n\t\tstring /* Type ID */,\n\t\tIConstructorSignature<IEditorSerializer>\n\t>();\n\tprivate readonly editorSerializerInstances = new Map<\n\t\tstring /* Type ID */,\n\t\tIEditorSerializer\n\t>();\n\n\tstart(accessor: ServicesAccessor): void {\n\t\tconst instantiationService = (this.instantiationService = accessor.get(\n\t\t\tIInstantiationService,\n\t\t));\n\n\t\tfor (const [key, ctor] of this.editorSerializerConstructors) {\n\t\t\tthis.createEditorSerializer(key, ctor, instantiationService);\n\t\t}\n\n\t\tthis.editorSerializerConstructors.clear();\n\t}\n\n\tprivate createEditorSerializer(\n\t\teditorTypeId: string,\n\t\tctor: IConstructorSignature<IEditorSerializer>,\n\t\tinstantiationService: IInstantiationService,\n\t): void {\n\t\tconst instance = instantiationService.createInstance(ctor);\n\t\tthis.editorSerializerInstances.set(editorTypeId, instance);\n\t}\n\n\tregisterFileEditorFactory(factory: IFileEditorFactory): void {\n\t\tif (this.fileEditorFactory) {\n\t\t\tthrow new Error(\"Can only register one file editor factory.\");\n\t\t}\n\n\t\tthis.fileEditorFactory = factory;\n\t}\n\n\tgetFileEditorFactory(): IFileEditorFactory {\n\t\treturn assertIsDefined(this.fileEditorFactory);\n\t}\n\n\tregisterEditorSerializer(\n\t\teditorTypeId: string,\n\t\tctor: IConstructorSignature<IEditorSerializer>,\n\t): IDisposable {\n\t\tif (\n\t\t\tthis.editorSerializerConstructors.has(editorTypeId) ||\n\t\t\tthis.editorSerializerInstances.has(editorTypeId)\n\t\t) {\n\t\t\tthrow new Error(\n\t\t\t\t`A editor serializer with type ID '${editorTypeId}' was already registered.`,\n\t\t\t);\n\t\t}\n\n\t\tif (this.instantiationService) {\n\t\t\tthis.createEditorSerializer(\n\t\t\t\teditorTypeId,\n\t\t\t\tctor,\n\t\t\t\tthis.instantiationService,\n\t\t\t);\n\t\t} else {\n\t\t\tthis.editorSerializerConstructors.set(editorTypeId, ctor);\n\t\t}\n\n\t\treturn toDisposable(() => {\n\t\t\tthis.editorSerializerConstructors.delete(editorTypeId);\n\t\t\tthis.editorSerializerInstances.delete(editorTypeId);\n\t\t});\n\t}\n\n\tgetEditorSerializer(editor: EditorInput): IEditorSerializer | undefined;\n\tgetEditorSerializer(editorTypeId: string): IEditorSerializer | undefined;\n\tgetEditorSerializer(\n\t\targ1: string | EditorInput,\n\t): IEditorSerializer | undefined {\n\t\treturn this.editorSerializerInstances.get(\n\t\t\ttypeof arg1 === \"string\" ? arg1 : arg1.typeId,\n\t\t);\n\t}\n}\n\nRegistry.add(EditorExtensions.EditorFactory, new EditorFactoryRegistry());\n\nexport async function pathsToEditors(\n\tpaths: IPathData[] | undefined,\n\tfileService: IFileService,\n\tlogService: ILogService,\n): Promise<\n\tReadonlyArray<\n\t\tIResourceEditorInput | IUntitledTextResourceEditorInput | undefined\n\t>\n> {\n\tif (!paths || !paths.length) {\n\t\treturn [];\n\t}\n\n\treturn await Promise.all(\n\t\tpaths.map(async (path) => {\n\t\t\tconst resource = URI.revive(path.fileUri);\n\t\t\tif (!resource) {\n\t\t\t\tlogService.info(\n\t\t\t\t\t\"Cannot resolve the path because it is not valid.\",\n\t\t\t\t\tpath,\n\t\t\t\t);\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst canHandleResource =\n\t\t\t\tawait fileService.canHandleResource(resource);\n\t\t\tif (!canHandleResource) {\n\t\t\t\tlogService.info(\n\t\t\t\t\t\"Cannot resolve the path because it cannot be handled\",\n\t\t\t\t\tpath,\n\t\t\t\t);\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tlet exists = path.exists;\n\t\t\tlet type = path.type;\n\t\t\tif (typeof exists !== \"boolean\" || typeof type !== \"number\") {\n\t\t\t\ttry {\n\t\t\t\t\ttype = (await fileService.stat(resource)).isDirectory\n\t\t\t\t\t\t? FileType.Directory\n\t\t\t\t\t\t: FileType.Unknown;\n\t\t\t\t\texists = true;\n\t\t\t\t} catch (error) {\n\t\t\t\t\tlogService.error(error);\n\t\t\t\t\texists = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!exists && path.openOnlyIfExists) {\n\t\t\t\tlogService.info(\n\t\t\t\t\t\"Cannot resolve the path because it does not exist\",\n\t\t\t\t\tpath,\n\t\t\t\t);\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tif (type === FileType.Directory) {\n\t\t\t\tlogService.info(\n\t\t\t\t\t\"Cannot resolve the path because it is a directory\",\n\t\t\t\t\tpath,\n\t\t\t\t);\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst options: IEditorOptions = {\n\t\t\t\t...path.options,\n\t\t\t\tpinned: true,\n\t\t\t};\n\n\t\t\tif (!exists) {\n\t\t\t\treturn { resource, options, forceUntitled: true };\n\t\t\t}\n\n\t\t\treturn { resource, options };\n\t\t}),\n\t);\n}\n\nexport enum EditorsOrder {\n\t/**\n\t * Editors sorted by most recent activity (most recent active first)\n\t */\n\tMOST_RECENTLY_ACTIVE = 0,\n\n\t/**\n\t * Editors sorted by sequential order\n\t */\n\tSEQUENTIAL = 1,\n}\n\nexport function isTextEditorViewState(\n\tcandidate: unknown,\n): candidate is IEditorViewState {\n\tconst viewState = candidate as IEditorViewState | undefined;\n\tif (!viewState) {\n\t\treturn false;\n\t}\n\n\tconst diffEditorViewState = viewState as IDiffEditorViewState;\n\tif (diffEditorViewState.modified) {\n\t\treturn isTextEditorViewState(diffEditorViewState.modified);\n\t}\n\n\tconst codeEditorViewState = viewState as ICodeEditorViewState;\n\n\treturn !!(\n\t\tcodeEditorViewState.contributionsState &&\n\t\tcodeEditorViewState.viewState &&\n\t\tArray.isArray(codeEditorViewState.cursorState)\n\t);\n}\n\nexport interface IEditorOpenErrorOptions {\n\t/**\n\t * If set to true, the message will be taken\n\t * from the error message entirely and not be\n\t * composed with more text.\n\t */\n\tforceMessage?: boolean;\n\n\t/**\n\t * If set, will override the severity of the error.\n\t */\n\tforceSeverity?: Severity;\n\n\t/**\n\t * If set to true, the error may be shown in a dialog\n\t * to the user if the editor opening was triggered by\n\t * user action. Otherwise and by default, the error will\n\t * be shown as place holder in the editor area.\n\t */\n\tallowDialog?: boolean;\n}\n\nexport interface IEditorOpenError\n\textends IErrorWithActions,\n\t\tIEditorOpenErrorOptions {}\n\nexport function isEditorOpenError(obj: unknown): obj is IEditorOpenError {\n\treturn isErrorWithActions(obj);\n}\n\nexport function createEditorOpenError(\n\tmessageOrError: string | Error,\n\tactions: IAction[],\n\toptions?: IEditorOpenErrorOptions,\n): IEditorOpenError {\n\tconst error: IEditorOpenError = createErrorWithActions(\n\t\tmessageOrError,\n\t\tactions,\n\t);\n\n\terror.forceMessage = options?.forceMessage;\n\terror.forceSeverity = options?.forceSeverity;\n\terror.allowDialog = options?.allowDialog;\n\n\treturn error;\n}\n\nexport interface IToolbarActions {\n\treadonly primary: IAction[];\n\treadonly secondary: IAction[];\n}\n"],
  "mappings": ";;AAKA,SAAuB,gBAAgB;AACvC;AAAA,EAEC;AAAA,EACA;AAAA,OACM;AAEP;AAAA,EACC;AAAA,EAEA;AAAA,OACM;AACP,SAAS,eAAe;AAExB,OAAO,cAAc;AACrB;AAAA,EAEC;AAAA,OACM;AACP,SAAS,WAAW;AAQpB,SAAS,gBAAgB;AAUzB;AAAA,EACC;AAAA,OAGM;AACP;AAAA,EAGC;AAAA,OAEM;AAEP,SAAS,gBAAgB;AAclB,MAAM,mBAAmB;AAAA,EAC/B,YAAY;AAAA,EACZ,eAAe;AAChB;AAGO,MAAM,6BAA6B;AAAA,EACzC,IAAI;AAAA,EACJ,aAAa;AAAA,IACZ;AAAA,IACA;AAAA,EACD;AAAA,EACA,qBAAqB,SAAS,8BAA8B,UAAU;AACvE;AAKO,MAAM,yBAAyB;AAK/B,MAAM,sBAAsB;AAK5B,MAAM,wBACZ;AAoKM,IAAK,kCAAL,kBAAKA,qCAAL;AAQN,EAAAA,kEAAA,kBAAe,KAAf;AAQA,EAAAA,kEAAA,UAAO,KAAP;AASA,EAAAA,kEAAA,UAAO,KAAP;AASA,EAAAA,kEAAA,gBAAa,KAAb;AASA,EAAAA,kEAAA,UAAO,KAAP;AA3CW,SAAAA;AAAA,GAAA;AAsEL,IAAK,mCAAL,kBAAKC,sCAAL;AAIN,EAAAA,oEAAA,eAAY,KAAZ;AAaA,EAAAA,oEAAA,aAAU,KAAV;AAKA,EAAAA,oEAAA,eAAY,KAAZ;AAtBW,SAAAA;AAAA,GAAA;AA+BL,SAAS,0BACf,YACyC;AACzC,QAAM,YAAY;AAElB,SACC,CAAC,CAAC,aACF,OAAO,UAAU,iBAAiB,cAClC,CAAC,CAAC,UAAU;AAEd;AAVgB;AAoBT,SAAS,0BACf,YACyC;AACzC,QAAM,YAAY;AAElB,SACC,CAAC,CAAC,aACF,OAAO,UAAU,sBAAsB,cACvC,OAAO,UAAU,sBAAsB,cACvC,CAAC,CAAC,UAAU;AAEd;AAXgB;AA4BT,SAAS,uBACf,OACA,OACA,eACqB;AACrB,aAAW,cAAc,cAAc,oBAAoB;AAC1D,QAAI,WAAW,MAAM,OAAO,SAAS,MAAM,QAAQ,WAAW,KAAK,GAAG;AACrE,aAAO,WAAW,aAAa;AAAA,IAChC;AAAA,EACD;AAEA,SAAO;AACR;AAZgB;AAqQT,SAAS,sBACf,QACiC;AACjC,MAAI,cAAc,MAAM,GAAG;AAC1B,WAAO;AAAA,EACR;AAEA,QAAM,YAAY;AAElB,SAAO,IAAI,MAAM,WAAW,QAAQ;AACrC;AAVgB;AAYT,SAAS,0BACf,QACqC;AACrC,MAAI,cAAc,MAAM,GAAG;AAC1B,WAAO;AAAA,EACR;AAEA,QAAM,YAAY;AAElB,SACC,WAAW,aAAa,UAAa,UAAU,aAAa;AAE9D;AAZgB;AAcT,SAAS,+BACf,QAC0C;AAC1C,MAAI,cAAc,MAAM,GAAG;AAC1B,WAAO;AAAA,EACR;AAEA,QAAM,YAAY;AAClB,MAAI,CAAC,WAAW;AACf,WAAO;AAAA,EACR;AACA,MAAI,UAAU,aAAa,CAAC,MAAM,QAAQ,UAAU,SAAS,GAAG;AAC/D,WAAO;AAAA,EACR;AAEA,SAAO,CAAC,CAAC,UAAU,aAAa,CAAC,CAAC,UAAU;AAC7C;AAhBgB;AAkBT,SAAS,gCACf,QAC2C;AAC3C,MAAI,cAAc,MAAM,GAAG;AAC1B,WAAO;AAAA,EACR;AAEA,MAAI,0BAA0B,MAAM,GAAG;AACtC,WAAO;AAAA,EACR;AAEA,QAAM,YAAY;AAElB,SACC,WAAW,YAAY,UAAa,UAAU,cAAc;AAE9D;AAhBgB;AAkBT,SAAS,8BACf,QAC6C;AAC7C,MAAI,cAAc,MAAM,GAAG;AAC1B,WAAO;AAAA,EACR;AAEA,QAAM,YAAY;AAClB,MAAI,CAAC,WAAW;AACf,WAAO;AAAA,EACR;AAEA,SACC,UAAU,aAAa,UACvB,UAAU,SAAS,WAAW,QAAQ,YACtC,UAAU,kBAAkB;AAE9B;AAjBgB;AAmBT,SAAS,2BACf,QACsC;AACtC,MAAI,cAAc,MAAM,GAAG;AAC1B,WAAO;AAAA,EACR;AAEA,QAAM,YAAY;AAElB,SACC,IAAI,MAAM,WAAW,MAAM,QAAQ,KACnC,IAAI,MAAM,WAAW,QAAQ,QAAQ,KACrC,IAAI,MAAM,WAAW,QAAQ,QAAQ,KACrC,IAAI,MAAM,WAAW,QAAQ,QAAQ;AAEvC;AAfgB;AAiBT,IAAK,YAAL,kBAAKC,eAAL;AACN,EAAAA,sBAAA,WAAQ,KAAR;AACA,EAAAA,sBAAA,YAAS,KAAT;AACA,EAAAA,sBAAA,UAAO,KAAP;AAHW,SAAAA;AAAA,GAAA;AAML,IAAK,aAAL,kBAAKC,gBAAL;AAIN,EAAAA,wBAAA,cAAW,KAAX;AAKA,EAAAA,wBAAA,UAAO,KAAP;AAKA,EAAAA,wBAAA,kBAAe,KAAf;AAKA,EAAAA,wBAAA,mBAAgB,KAAhB;AAnBW,SAAAA;AAAA,GAAA;AA6BZ,MAAM,kBAAkB;AAAA,EApyBxB,OAoyBwB;AAAA;AAAA;AAAA,EACN,oBAAoB,oBAAI,IAGvC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMF,eAAe,IAAY,OAA2B;AACrD,QAAI,mBAAmB,KAAK,kBAAkB,IAAI,EAAE;AACpD,QAAI,CAAC,kBAAkB;AACtB,yBAAmB,EAAE,QAAQ,IAAI,MAAM;AACvC,WAAK,kBAAkB,IAAI,IAAI,gBAAgB;AAAA,IAChD;AAEA,WAAO,iBAAiB;AAAA,EACzB;AAAA,EAEA,eAAe,QAA4B;AAC1C,WAAO,KAAK,kBAAkB,IAAI,MAAM,GAAG,SAAS;AAAA,EACrD;AACD;AAEO,MAAM,qBAAqB,IAAI,kBAAkB;AAsDjD,IAAK,0BAAL,kBAAKC,6BAAL;AAIN,EAAAA,kDAAA,UAAO,KAAP;AAKA,EAAAA,kDAAA,cAAW,KAAX;AAKA,EAAAA,kDAAA,cAAW,KAAX;AAMA,EAAAA,kDAAA,eAAY,KAAZ;AAKA,EAAAA,kDAAA,mBAAgB,MAAhB;AAMA,EAAAA,kDAAA,qBAAkB,MAAlB;AAQA,EAAAA,kDAAA,sBAAmB,MAAnB;AAMA,EAAAA,kDAAA,uBAAoB,OAApB;AAMA,EAAAA,kDAAA,qBAAkB,OAAlB;AAMA,EAAAA,kDAAA,gBAAa,OAAb;AAzDW,SAAAA;AAAA,GAAA;AAqEL,MAAe,4BAA4B,WAAW;AAAA,EAx7B7D,OAw7B6D;AAAA;AAAA;AAAA;AAE7D;AAEO,SAAS,cAAc,QAAwC;AACrE,SAAO,kBAAkB;AAC1B;AAFgB;AAyBhB,SAAS,mCACR,QAC6C;AAC7C,QAAM,YAAY;AAElB,SAAO,IAAI,MAAM,WAAW,iBAAiB;AAC9C;AANS;AAoBF,SAAS,wBACf,QACmC;AACnC,QAAM,YAAY;AAElB,SACC,cAAc,WAAW,OAAO,KAAK,cAAc,WAAW,SAAS;AAEzE;AARgB;AAsBT,SAAS,kBAAkB,QAA6C;AAC9E,QAAM,YAAY;AAElB,SACC,cAAc,WAAW,QAAQ,KAAK,cAAc,WAAW,QAAQ;AAEzE;AANgB;AA6FT,SAAS,wBACf,OACA,OACA,SACA,SACA,oBACQ;AACR,SAAO;AAAA,IACN;AAAA,IACA;AAAA,MACC,SAAS;AAAA,QACR,IAAI;AAAA,QACJ,OAAO,SAAS,iBAAiB,aAAa;AAAA,QAC9C,KAAK,6BAAM;AACV,gBAAM,oBAA6C;AAAA,YAClD,GAAG;AAAA,YACH,QAAQ;AAAA,cACP,MAAM,OAAO;AAAA,YACd;AAAA,UACD;AAEA,gBAAM,WAAW,OAAO,iBAAiB;AAAA,QAC1C,GATK;AAAA,MAUN,CAAC;AAAA,MACD,SAAS;AAAA,QACR,IAAI;AAAA,QACJ,OAAO;AAAA,UACN;AAAA,UACA;AAAA,QACD;AAAA,QACA,KAAK,6BAAM;AACV,iBAAO,mBAAmB,iBAAiB;AAAA,YAC1C,OAAO;AAAA,UACR,CAAC;AAAA,QACF,GAJK;AAAA,MAKN,CAAC;AAAA,IACF;AAAA,IACA;AAAA,MACC,cAAc;AAAA,MACd,eAAe,SAAS;AAAA,IACzB;AAAA,EACD;AACD;AA1CgB;AAqDT,SAAS,yBACf,QACmC;AACnC,QAAM,YAAY;AAElB,SAAO,cAAc,WAAW,MAAM;AACvC;AANgB;AAQT,SAAS,iCACf,QAC2C;AAC3C,QAAM,YAAY;AAElB,SAAO,yBAAyB,MAAM,KAAK,WAAW,UAAU;AACjE;AANgB;AA4BT,SAAS,mBACf,YACkC;AAClC,QAAM,YAAY;AAElB,SACC,OAAO,WAAW,YAAY,YAC9B,cAAc,UAAU,MAAM;AAEhC;AATgB;AAuBT,SAAS,wBACf,SACoC;AACpC,QAAM,YAAY;AAElB,SAAO,OAAO,WAAW,YAAY;AACtC;AANgB;AAWT,IAAK,qBAAL,kBAAKC,wBAAL;AAIN,EAAAA,wCAAA,aAAU,KAAV;AAOA,EAAAA,wCAAA,aAAU,KAAV;AAKA,EAAAA,wCAAA,UAAO,KAAP;AAMA,EAAAA,wCAAA,WAAQ,KAAR;AAtBW,SAAAA;AAAA,GAAA;AAmEL,IAAK,uBAAL,kBAAKC,0BAAL;AAEN,EAAAA,4CAAA,kBAAe,KAAf;AACA,EAAAA,4CAAA,iBAAc,KAAd;AACA,EAAAA,4CAAA,iBAAc,KAAd;AACA,EAAAA,4CAAA,kBAAe,KAAf;AAGA,EAAAA,4CAAA,uBAAoB,KAApB;AAGA,EAAAA,4CAAA,iBAAc,KAAd;AACA,EAAAA,4CAAA,kBAAe,KAAf;AACA,EAAAA,4CAAA,iBAAc,KAAd;AACA,EAAAA,4CAAA,mBAAgB,KAAhB;AACA,EAAAA,4CAAA,kBAAe,KAAf;AACA,EAAAA,4CAAA,yBAAsB,MAAtB;AACA,EAAAA,4CAAA,gBAAa,MAAb;AACA,EAAAA,4CAAA,sBAAmB,MAAnB;AACA,EAAAA,4CAAA,mBAAgB,MAAhB;AACA,EAAAA,4CAAA,kBAAe,MAAf;AACA,EAAAA,4CAAA,yBAAsB,MAAtB;AArBW,SAAAA;AAAA,GAAA;AAqGL,IAAK,mBAAL,kBAAKC,sBAAL;AACN,EAAAA,oCAAA,aAAU,KAAV;AACA,EAAAA,oCAAA,eAAY,KAAZ;AACA,EAAAA,oCAAA,UAAO,KAAP;AACA,EAAAA,oCAAA,SAAM,KAAN;AAJW,SAAAA;AAAA,GAAA;AAkDZ,MAAM,2BAA2B;AAAA,EAj7CjC,OAi7CiC;AAAA;AAAA;AAAA,EAuChC,eACC,QACA,SACuD;AACvD,QAAI,CAAC,QAAQ;AACZ,aAAO;AAAA,IACR;AAGA,QAAI,2BAA2B,MAAM,GAAG;AACvC,aAAO,uBAAuB;AAAA,QAC7B,OAAO;AAAA,QACP;AAAA,MACD;AAAA,IACD;AAGA,QAAI,SAAS,mBAAmB;AAC/B,YAAM,EAAE,SAAS,UAAU,IAAI,KAAK,eAAe,MAAM;AACzD,UAAI,WAAW,WAAW;AACzB,YAAI,SAAS,sBAAsB,cAAuB;AACzD,iBAAO;AAAA,YACN,SAAS,KAAK,eAAe,SAAS;AAAA,cACrC,gBAAgB,QAAQ;AAAA,YACzB,CAAC;AAAA,YACD,WAAW,KAAK,eAAe,WAAW;AAAA,cACzC,gBAAgB,QAAQ;AAAA,YACzB,CAAC;AAAA,UACF;AAAA,QACD,WACC,SAAS,sBAAsB,aAC9B;AACD,iBACC,KAAK,eAAe,SAAS;AAAA,YAC5B,gBAAgB,QAAQ;AAAA,UACzB,CAAC,KACD,KAAK,eAAe,WAAW;AAAA,YAC9B,gBAAgB,QAAQ;AAAA,UACzB,CAAC;AAAA,QAEH;AAEA,iBACC,QAAQ,sBAAsB,kBAC3B,UACA;AAAA,MACL;AAAA,IACD;AAEA,QACC,0BAA0B,MAAM,KAChC,+BAA+B,MAAM,KACrC,gCAAgC,MAAM,KACtC,2BAA2B,MAAM,GAChC;AACD,aAAO;AAAA,IACR;AAGA,UAAM,mBAAmB,mCAAmC,MAAM,IAC/D,OAAO,oBACP,OAAO;AACV,QAAI,CAAC,oBAAoB,CAAC,WAAW,CAAC,QAAQ,gBAAgB;AAC7D,aAAO;AAAA,IACR;AAEA,WAAO,KAAK,UAAU,kBAAkB,QAAQ,cAAc;AAAA,EAC/D;AAAA,EAEQ,eAAe,QAGrB;AACD,QACC,wBAAwB,MAAM,KAC9B,gCAAgC,MAAM,GACrC;AACD,aAAO,EAAE,SAAS,OAAO,SAAS,WAAW,OAAO,UAAU;AAAA,IAC/D;AAEA,QAAI,kBAAkB,MAAM,KAAK,0BAA0B,MAAM,GAAG;AACnE,aAAO,EAAE,SAAS,OAAO,UAAU,WAAW,OAAO,SAAS;AAAA,IAC/D;AAEA,WAAO,EAAE,SAAS,QAAW,WAAW,OAAU;AAAA,EACnD;AAAA,EAqCA,gBACC,QACA,SACuD;AACvD,QAAI,CAAC,QAAQ;AACZ,aAAO;AAAA,IACR;AAGA,QAAI,2BAA2B,MAAM,GAAG;AACvC,aAAO,uBAAuB;AAAA,QAC7B,OAAO;AAAA,QACP;AAAA,MACD;AAAA,IACD;AAGA,QAAI,SAAS,mBAAmB;AAC/B,YAAM,EAAE,SAAS,UAAU,IAAI,KAAK,eAAe,MAAM;AACzD,UAAI,WAAW,WAAW;AACzB,YAAI,SAAS,sBAAsB,cAAuB;AACzD,iBAAO;AAAA,YACN,SAAS,KAAK,gBAAgB,SAAS;AAAA,cACtC,gBAAgB,QAAQ;AAAA,YACzB,CAAC;AAAA,YACD,WAAW,KAAK,gBAAgB,WAAW;AAAA,cAC1C,gBAAgB,QAAQ;AAAA,YACzB,CAAC;AAAA,UACF;AAAA,QACD,WACC,SAAS,sBAAsB,aAC9B;AACD,iBACC,KAAK,gBAAgB,SAAS;AAAA,YAC7B,gBAAgB,QAAQ;AAAA,UACzB,CAAC,KACD,KAAK,gBAAgB,WAAW;AAAA,YAC/B,gBAAgB,QAAQ;AAAA,UACzB,CAAC;AAAA,QAEH;AAEA,iBACC,QAAQ,sBAAsB,kBAC3B,UACA;AAAA,MACL;AAAA,IACD;AAEA,QACC,0BAA0B,MAAM,KAChC,+BAA+B,MAAM,KACrC,gCAAgC,MAAM,KACtC,2BAA2B,MAAM,GAChC;AACD,aAAO;AAAA,IACR;AAGA,UAAM,oBAAoB,OAAO;AACjC,QAAI,CAAC,qBAAqB,CAAC,WAAW,CAAC,QAAQ,gBAAgB;AAC9D,aAAO;AAAA,IACR;AAEA,WAAO,KAAK,UAAU,mBAAmB,QAAQ,cAAc;AAAA,EAChE;AAAA,EAEQ,UACP,UACA,QACkB;AAElB,QAAI,MAAM,QAAQ,MAAM,GAAG;AAC1B,UAAI,OAAO,KAAK,CAAC,WAAW,SAAS,WAAW,MAAM,GAAG;AACxD,eAAO;AAAA,MACR;AAAA,IACD,WAGS,WAAW,SAAS,QAAQ;AACpC,aAAO;AAAA,IACR;AAEA,WAAO;AAAA,EACR;AACD;AASO,IAAK,oBAAL,kBAAKC,uBAAL;AACN,EAAAA,sCAAA,aAAU,KAAV;AACA,EAAAA,sCAAA,cAAW,KAAX;AACA,EAAAA,sCAAA,WAAQ,KAAR;AAHW,SAAAA;AAAA,GAAA;AAML,SAAS,mBACf,OACA,QACA,QACA,eACU;AACV,MAAI,CAAC,MAAM,SAAS,MAAM,GAAG;AAC5B,WAAO;AAAA,EACR;AAEA,UAAQ,cAAc,0BAA0B;AAAA,IAC/C,KAAK;AACJ,aACC,WAAW,iBACX,WAAW;AAAA,IAEb,KAAK;AACJ,aAAO,WAAW;AAAA,IACnB,KAAK;AACJ,aAAO,WAAW;AAAA,EACpB;AAEA,SAAO;AACR;AAvBgB;AAyBT,MAAM,yBAAyB,IAAI,2BAA2B;AAE9D,IAAK,iBAAL,kBAAKC,oBAAL;AACN,EAAAA,gCAAA,UAAO,KAAP;AACA,EAAAA,gCAAA,WAAQ,KAAR;AAFW,SAAAA;AAAA,GAAA;AAoBZ,MAAM,sBAAwD;AAAA,EAruD9D,OAquD8D;AAAA;AAAA;AAAA,EACrD;AAAA,EAEA;AAAA,EAES,+BAA+B,oBAAI,IAGlD;AAAA,EACe,4BAA4B,oBAAI,IAG/C;AAAA,EAEF,MAAM,UAAkC;AACvC,UAAM,uBAAwB,KAAK,uBAAuB,SAAS;AAAA,MAClE;AAAA,IACD;AAEA,eAAW,CAAC,KAAK,IAAI,KAAK,KAAK,8BAA8B;AAC5D,WAAK,uBAAuB,KAAK,MAAM,oBAAoB;AAAA,IAC5D;AAEA,SAAK,6BAA6B,MAAM;AAAA,EACzC;AAAA,EAEQ,uBACP,cACA,MACA,sBACO;AACP,UAAM,WAAW,qBAAqB,eAAe,IAAI;AACzD,SAAK,0BAA0B,IAAI,cAAc,QAAQ;AAAA,EAC1D;AAAA,EAEA,0BAA0B,SAAmC;AAC5D,QAAI,KAAK,mBAAmB;AAC3B,YAAM,IAAI,MAAM,4CAA4C;AAAA,IAC7D;AAEA,SAAK,oBAAoB;AAAA,EAC1B;AAAA,EAEA,uBAA2C;AAC1C,WAAO,gBAAgB,KAAK,iBAAiB;AAAA,EAC9C;AAAA,EAEA,yBACC,cACA,MACc;AACd,QACC,KAAK,6BAA6B,IAAI,YAAY,KAClD,KAAK,0BAA0B,IAAI,YAAY,GAC9C;AACD,YAAM,IAAI;AAAA,QACT,qCAAqC,YAAY;AAAA,MAClD;AAAA,IACD;AAEA,QAAI,KAAK,sBAAsB;AAC9B,WAAK;AAAA,QACJ;AAAA,QACA;AAAA,QACA,KAAK;AAAA,MACN;AAAA,IACD,OAAO;AACN,WAAK,6BAA6B,IAAI,cAAc,IAAI;AAAA,IACzD;AAEA,WAAO,aAAa,MAAM;AACzB,WAAK,6BAA6B,OAAO,YAAY;AACrD,WAAK,0BAA0B,OAAO,YAAY;AAAA,IACnD,CAAC;AAAA,EACF;AAAA,EAIA,oBACC,MACgC;AAChC,WAAO,KAAK,0BAA0B;AAAA,MACrC,OAAO,SAAS,WAAW,OAAO,KAAK;AAAA,IACxC;AAAA,EACD;AACD;AAEA,SAAS,IAAI,iBAAiB,eAAe,IAAI,sBAAsB,CAAC;AAExE,eAAsB,eACrB,OACA,aACA,YAKC;AACD,MAAI,CAAC,SAAS,CAAC,MAAM,QAAQ;AAC5B,WAAO,CAAC;AAAA,EACT;AAEA,SAAO,MAAM,QAAQ;AAAA,IACpB,MAAM,IAAI,OAAO,SAAS;AACzB,YAAM,WAAW,IAAI,OAAO,KAAK,OAAO;AACxC,UAAI,CAAC,UAAU;AACd,mBAAW;AAAA,UACV;AAAA,UACA;AAAA,QACD;AACA,eAAO;AAAA,MACR;AAEA,YAAM,oBACL,MAAM,YAAY,kBAAkB,QAAQ;AAC7C,UAAI,CAAC,mBAAmB;AACvB,mBAAW;AAAA,UACV;AAAA,UACA;AAAA,QACD;AACA,eAAO;AAAA,MACR;AAEA,UAAI,SAAS,KAAK;AAClB,UAAI,OAAO,KAAK;AAChB,UAAI,OAAO,WAAW,aAAa,OAAO,SAAS,UAAU;AAC5D,YAAI;AACH,kBAAQ,MAAM,YAAY,KAAK,QAAQ,GAAG,cACvC,SAAS,YACT,SAAS;AACZ,mBAAS;AAAA,QACV,SAAS,OAAO;AACf,qBAAW,MAAM,KAAK;AACtB,mBAAS;AAAA,QACV;AAAA,MACD;AAEA,UAAI,CAAC,UAAU,KAAK,kBAAkB;AACrC,mBAAW;AAAA,UACV;AAAA,UACA;AAAA,QACD;AACA,eAAO;AAAA,MACR;AAEA,UAAI,SAAS,SAAS,WAAW;AAChC,mBAAW;AAAA,UACV;AAAA,UACA;AAAA,QACD;AACA,eAAO;AAAA,MACR;AAEA,YAAM,UAA0B;AAAA,QAC/B,GAAG,KAAK;AAAA,QACR,QAAQ;AAAA,MACT;AAEA,UAAI,CAAC,QAAQ;AACZ,eAAO,EAAE,UAAU,SAAS,eAAe,KAAK;AAAA,MACjD;AAEA,aAAO,EAAE,UAAU,QAAQ;AAAA,IAC5B,CAAC;AAAA,EACF;AACD;AA5EsB;AA8Ef,IAAK,eAAL,kBAAKC,kBAAL;AAIN,EAAAA,4BAAA,0BAAuB,KAAvB;AAKA,EAAAA,4BAAA,gBAAa,KAAb;AATW,SAAAA;AAAA,GAAA;AAYL,SAAS,sBACf,WACgC;AAChC,QAAM,YAAY;AAClB,MAAI,CAAC,WAAW;AACf,WAAO;AAAA,EACR;AAEA,QAAM,sBAAsB;AAC5B,MAAI,oBAAoB,UAAU;AACjC,WAAO,sBAAsB,oBAAoB,QAAQ;AAAA,EAC1D;AAEA,QAAM,sBAAsB;AAE5B,SAAO,CAAC,EACP,oBAAoB,sBACpB,oBAAoB,aACpB,MAAM,QAAQ,oBAAoB,WAAW;AAE/C;AApBgB;AAgDT,SAAS,kBAAkB,KAAuC;AACxE,SAAO,mBAAmB,GAAG;AAC9B;AAFgB;AAIT,SAAS,sBACf,gBACA,SACA,SACmB;AACnB,QAAM,QAA0B;AAAA,IAC/B;AAAA,IACA;AAAA,EACD;AAEA,QAAM,eAAe,SAAS;AAC9B,QAAM,gBAAgB,SAAS;AAC/B,QAAM,cAAc,SAAS;AAE7B,SAAO;AACR;AAfgB;",
  "names": ["EditorPaneSelectionChangeReason", "EditorPaneSelectionCompareResult", "Verbosity", "SaveReason", "EditorInputCapabilities", "EditorCloseContext", "GroupModelChangeKind", "SideBySideEditor", "EditorCloseMethod", "CloseDirection", "EditorsOrder"]
}
