{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/common/editor/editorGroupModel.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { coalesce } from \"../../../base/common/arrays.js\";\nimport { Emitter, Event } from \"../../../base/common/event.js\";\nimport {\n\tDisposable,\n\tDisposableStore,\n\tdispose,\n} from \"../../../base/common/lifecycle.js\";\nimport {\n\ttype IConfigurationChangeEvent,\n\tIConfigurationService,\n} from \"../../../platform/configuration/common/configuration.js\";\nimport { IInstantiationService } from \"../../../platform/instantiation/common/instantiation.js\";\nimport { Registry } from \"../../../platform/registry/common/platform.js\";\nimport {\n\tEditorCloseContext,\n\tEditorExtensions,\n\tEditorsOrder,\n\ttype GroupIdentifier,\n\tGroupModelChangeKind,\n\ttype IEditorFactoryRegistry,\n\ttype IMatchEditorOptions,\n\ttype IUntypedEditorInput,\n\tSideBySideEditor,\n} from \"../editor.js\";\nimport { EditorInput } from \"./editorInput.js\";\nimport { SideBySideEditorInput } from \"./sideBySideEditorInput.js\";\n\nconst EditorOpenPositioning = {\n\tLEFT: \"left\",\n\tRIGHT: \"right\",\n\tFIRST: \"first\",\n\tLAST: \"last\",\n};\n\nexport interface IEditorOpenOptions {\n\treadonly pinned?: boolean;\n\treadonly sticky?: boolean;\n\treadonly transient?: boolean;\n\tactive?: boolean;\n\treadonly inactiveSelection?: EditorInput[];\n\treadonly index?: number;\n\treadonly supportSideBySide?: SideBySideEditor.ANY | SideBySideEditor.BOTH;\n}\n\nexport interface IEditorOpenResult {\n\treadonly editor: EditorInput;\n\treadonly isNew: boolean;\n}\n\nexport interface ISerializedEditorInput {\n\treadonly id: string;\n\treadonly value: string;\n}\n\nexport interface ISerializedEditorGroupModel {\n\treadonly id: number;\n\treadonly locked?: boolean;\n\treadonly editors: ISerializedEditorInput[];\n\treadonly mru: number[];\n\treadonly preview?: number;\n\tsticky?: number;\n}\n\nexport function isSerializedEditorGroupModel(\n\tgroup?: unknown,\n): group is ISerializedEditorGroupModel {\n\tconst candidate = group as ISerializedEditorGroupModel | undefined;\n\n\treturn !!(\n\t\tcandidate &&\n\t\ttypeof candidate === \"object\" &&\n\t\tArray.isArray(candidate.editors) &&\n\t\tArray.isArray(candidate.mru)\n\t);\n}\n\nexport interface IMatchOptions {\n\t/**\n\t * Whether to consider a side by side editor as matching.\n\t * By default, side by side editors will not be considered\n\t * as matching, even if the editor is opened in one of the sides.\n\t */\n\treadonly supportSideBySide?: SideBySideEditor.ANY | SideBySideEditor.BOTH;\n\n\t/**\n\t * Only consider an editor to match when the\n\t * `candidate === editor` but not when\n\t * `candidate.matches(editor)`.\n\t */\n\treadonly strictEquals?: boolean;\n}\n\nexport interface IGroupModelChangeEvent {\n\t/**\n\t * The kind of change that occurred in the group model.\n\t */\n\treadonly kind: GroupModelChangeKind;\n\n\t/**\n\t * Only applies when editors change providing\n\t * access to the editor the event is about.\n\t */\n\treadonly editor?: EditorInput;\n\n\t/**\n\t * Only applies when editors change providing\n\t * access to the index of the editor the event\n\t * is about.\n\t */\n\treadonly editorIndex?: number;\n}\n\nexport interface IGroupEditorChangeEvent extends IGroupModelChangeEvent {\n\treadonly editor: EditorInput;\n\treadonly editorIndex: number;\n}\n\nexport function isGroupEditorChangeEvent(\n\te: IGroupModelChangeEvent,\n): e is IGroupEditorChangeEvent {\n\tconst candidate = e as IGroupEditorOpenEvent;\n\n\treturn candidate.editor && candidate.editorIndex !== undefined;\n}\n\nexport interface IGroupEditorOpenEvent extends IGroupEditorChangeEvent {\n\treadonly kind: GroupModelChangeKind.EDITOR_OPEN;\n}\n\nexport function isGroupEditorOpenEvent(\n\te: IGroupModelChangeEvent,\n): e is IGroupEditorOpenEvent {\n\tconst candidate = e as IGroupEditorOpenEvent;\n\n\treturn (\n\t\tcandidate.kind === GroupModelChangeKind.EDITOR_OPEN &&\n\t\tcandidate.editorIndex !== undefined\n\t);\n}\n\nexport interface IGroupEditorMoveEvent extends IGroupEditorChangeEvent {\n\treadonly kind: GroupModelChangeKind.EDITOR_MOVE;\n\n\t/**\n\t * Signifies the index the editor is moving from.\n\t * `editorIndex` will contain the index the editor\n\t * is moving to.\n\t */\n\treadonly oldEditorIndex: number;\n}\n\nexport function isGroupEditorMoveEvent(\n\te: IGroupModelChangeEvent,\n): e is IGroupEditorMoveEvent {\n\tconst candidate = e as IGroupEditorMoveEvent;\n\n\treturn (\n\t\tcandidate.kind === GroupModelChangeKind.EDITOR_MOVE &&\n\t\tcandidate.editorIndex !== undefined &&\n\t\tcandidate.oldEditorIndex !== undefined\n\t);\n}\n\nexport interface IGroupEditorCloseEvent extends IGroupEditorChangeEvent {\n\treadonly kind: GroupModelChangeKind.EDITOR_CLOSE;\n\n\t/**\n\t * Signifies the context in which the editor\n\t * is being closed. This allows for understanding\n\t * if a replace or reopen is occurring\n\t */\n\treadonly context: EditorCloseContext;\n\n\t/**\n\t * Signifies whether or not the closed editor was\n\t * sticky. This is necessary becasue state is lost\n\t * after closing.\n\t */\n\treadonly sticky: boolean;\n}\n\nexport function isGroupEditorCloseEvent(\n\te: IGroupModelChangeEvent,\n): e is IGroupEditorCloseEvent {\n\tconst candidate = e as IGroupEditorCloseEvent;\n\n\treturn (\n\t\tcandidate.kind === GroupModelChangeKind.EDITOR_CLOSE &&\n\t\tcandidate.editorIndex !== undefined &&\n\t\tcandidate.context !== undefined &&\n\t\tcandidate.sticky !== undefined\n\t);\n}\n\ninterface IEditorCloseResult {\n\treadonly editor: EditorInput;\n\treadonly context: EditorCloseContext;\n\treadonly editorIndex: number;\n\treadonly sticky: boolean;\n}\n\nexport interface IReadonlyEditorGroupModel {\n\treadonly onDidModelChange: Event<IGroupModelChangeEvent>;\n\n\treadonly id: GroupIdentifier;\n\treadonly count: number;\n\treadonly stickyCount: number;\n\treadonly isLocked: boolean;\n\treadonly activeEditor: EditorInput | null;\n\treadonly previewEditor: EditorInput | null;\n\treadonly selectedEditors: EditorInput[];\n\n\tgetEditors(\n\t\torder: EditorsOrder,\n\t\toptions?: { excludeSticky?: boolean },\n\t): EditorInput[];\n\tgetEditorByIndex(index: number): EditorInput | undefined;\n\tindexOf(\n\t\teditor: EditorInput | IUntypedEditorInput | null,\n\t\teditors?: EditorInput[],\n\t\toptions?: IMatchEditorOptions,\n\t): number;\n\tisActive(editor: EditorInput | IUntypedEditorInput): boolean;\n\tisPinned(editorOrIndex: EditorInput | number): boolean;\n\tisSticky(editorOrIndex: EditorInput | number): boolean;\n\tisSelected(editorOrIndex: EditorInput | number): boolean;\n\tisTransient(editorOrIndex: EditorInput | number): boolean;\n\tisFirst(editor: EditorInput, editors?: EditorInput[]): boolean;\n\tisLast(editor: EditorInput, editors?: EditorInput[]): boolean;\n\tfindEditor(\n\t\teditor: EditorInput | null,\n\t\toptions?: IMatchEditorOptions,\n\t): [EditorInput, number /* index */] | undefined;\n\tcontains(\n\t\teditor: EditorInput | IUntypedEditorInput,\n\t\toptions?: IMatchEditorOptions,\n\t): boolean;\n}\n\ninterface IEditorGroupModel extends IReadonlyEditorGroupModel {\n\topenEditor(\n\t\teditor: EditorInput,\n\t\toptions?: IEditorOpenOptions,\n\t): IEditorOpenResult;\n\tcloseEditor(\n\t\teditor: EditorInput,\n\t\tcontext?: EditorCloseContext,\n\t\topenNext?: boolean,\n\t): IEditorCloseResult | undefined;\n\tmoveEditor(editor: EditorInput, toIndex: number): EditorInput | undefined;\n\tsetActive(editor: EditorInput | undefined): EditorInput | undefined;\n\tsetSelection(\n\t\tactiveSelectedEditor: EditorInput,\n\t\tinactiveSelectedEditors: EditorInput[],\n\t): void;\n}\n\nexport class EditorGroupModel extends Disposable implements IEditorGroupModel {\n\tprivate static IDS = 0;\n\n\t//#region events\n\n\tprivate readonly _onDidModelChange = this._register(\n\t\tnew Emitter<IGroupModelChangeEvent>({\n\t\t\tleakWarningThreshold: 500 /* increased for users with hundreds of inputs opened */,\n\t\t}),\n\t);\n\treadonly onDidModelChange = this._onDidModelChange.event;\n\n\t//#endregion\n\n\tprivate _id: GroupIdentifier;\n\tget id(): GroupIdentifier {\n\t\treturn this._id;\n\t}\n\n\tprivate editors: EditorInput[] = [];\n\tprivate mru: EditorInput[] = [];\n\n\tprivate readonly editorListeners = new Set<DisposableStore>();\n\n\tprivate locked = false;\n\n\tprivate selection: EditorInput[] = []; // editors in selected state, first one is active\n\n\tprivate get active(): EditorInput | null {\n\t\treturn this.selection[0] ?? null;\n\t}\n\n\tprivate preview: EditorInput | null = null; // editor in preview state\n\tprivate sticky = -1; // index of first editor in sticky state\n\tprivate readonly transient = new Set<EditorInput>(); // editors in transient state\n\n\tprivate editorOpenPositioning:\n\t\t| (\"left\" | \"right\" | \"first\" | \"last\")\n\t\t| undefined;\n\tprivate focusRecentEditorAfterClose: boolean | undefined;\n\n\tconstructor(\n\t\tlabelOrSerializedGroup: ISerializedEditorGroupModel | undefined,\n\t\t@IInstantiationService\n\t\tprivate readonly instantiationService: IInstantiationService,\n\t\t@IConfigurationService\n\t\tprivate readonly configurationService: IConfigurationService,\n\t) {\n\t\tsuper();\n\n\t\tif (isSerializedEditorGroupModel(labelOrSerializedGroup)) {\n\t\t\tthis._id = this.deserialize(labelOrSerializedGroup);\n\t\t} else {\n\t\t\tthis._id = EditorGroupModel.IDS++;\n\t\t}\n\n\t\tthis.onConfigurationUpdated();\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tthis._register(\n\t\t\tthis.configurationService.onDidChangeConfiguration((e) =>\n\t\t\t\tthis.onConfigurationUpdated(e),\n\t\t\t),\n\t\t);\n\t}\n\n\tprivate onConfigurationUpdated(e?: IConfigurationChangeEvent): void {\n\t\tif (\n\t\t\te &&\n\t\t\t!e.affectsConfiguration(\"workbench.editor.openPositioning\") &&\n\t\t\t!e.affectsConfiguration(\n\t\t\t\t\"workbench.editor.focusRecentEditorAfterClose\",\n\t\t\t)\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.editorOpenPositioning = this.configurationService.getValue(\n\t\t\t\"workbench.editor.openPositioning\",\n\t\t);\n\t\tthis.focusRecentEditorAfterClose = this.configurationService.getValue(\n\t\t\t\"workbench.editor.focusRecentEditorAfterClose\",\n\t\t);\n\t}\n\n\tget count(): number {\n\t\treturn this.editors.length;\n\t}\n\n\tget stickyCount(): number {\n\t\treturn this.sticky + 1;\n\t}\n\n\tgetEditors(\n\t\torder: EditorsOrder,\n\t\toptions?: { excludeSticky?: boolean },\n\t): EditorInput[] {\n\t\tconst editors =\n\t\t\torder === EditorsOrder.MOST_RECENTLY_ACTIVE\n\t\t\t\t? this.mru.slice(0)\n\t\t\t\t: this.editors.slice(0);\n\n\t\tif (options?.excludeSticky) {\n\t\t\t// MRU: need to check for index on each\n\t\t\tif (order === EditorsOrder.MOST_RECENTLY_ACTIVE) {\n\t\t\t\treturn editors.filter((editor) => !this.isSticky(editor));\n\t\t\t}\n\n\t\t\t// Sequential: simply start after sticky index\n\t\t\treturn editors.slice(this.sticky + 1);\n\t\t}\n\n\t\treturn editors;\n\t}\n\n\tgetEditorByIndex(index: number): EditorInput | undefined {\n\t\treturn this.editors[index];\n\t}\n\n\tget activeEditor(): EditorInput | null {\n\t\treturn this.active;\n\t}\n\n\tisActive(candidate: EditorInput | IUntypedEditorInput): boolean {\n\t\treturn this.matches(this.active, candidate);\n\t}\n\n\tget previewEditor(): EditorInput | null {\n\t\treturn this.preview;\n\t}\n\n\topenEditor(\n\t\tcandidate: EditorInput,\n\t\toptions?: IEditorOpenOptions,\n\t): IEditorOpenResult {\n\t\tconst makeSticky =\n\t\t\toptions?.sticky ||\n\t\t\t(typeof options?.index === \"number\" &&\n\t\t\t\tthis.isSticky(options.index));\n\t\tconst makePinned = options?.pinned || options?.sticky;\n\t\tconst makeTransient = !!options?.transient;\n\t\tconst makeActive =\n\t\t\toptions?.active ||\n\t\t\t!this.activeEditor ||\n\t\t\t(!makePinned && this.preview === this.activeEditor);\n\n\t\tconst existingEditorAndIndex = this.findEditor(candidate, options);\n\n\t\t// New editor\n\t\tif (existingEditorAndIndex) {\n\t\t\tconst [existingEditor, existingEditorIndex] =\n\t\t\t\texistingEditorAndIndex;\n\n\t\t\t// Update transient (existing editors do not turn transient if they were not before)\n\t\t\tthis.doSetTransient(\n\t\t\t\texistingEditor,\n\t\t\t\texistingEditorIndex,\n\t\t\t\tmakeTransient === false\n\t\t\t\t\t? false\n\t\t\t\t\t: this.isTransient(existingEditor),\n\t\t\t);\n\n\t\t\t// Pin it\n\t\t\tif (makePinned) {\n\t\t\t\tthis.doPin(existingEditor, existingEditorIndex);\n\t\t\t}\n\n\t\t\t// Handle active editor / selected editors\n\t\t\tthis.setSelection(\n\t\t\t\tmakeActive ? existingEditor : this.activeEditor,\n\t\t\t\toptions?.inactiveSelection ?? [],\n\t\t\t);\n\n\t\t\t// Respect index\n\t\t\tif (options && typeof options.index === \"number\") {\n\t\t\t\tthis.moveEditor(existingEditor, options.index);\n\t\t\t}\n\n\t\t\t// Stick it (intentionally after the moveEditor call in case\n\t\t\t// the editor was already moved into the sticky range)\n\t\t\tif (makeSticky) {\n\t\t\t\tthis.doStick(existingEditor, this.indexOf(existingEditor));\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\teditor: existingEditor,\n\t\t\t\tisNew: false,\n\t\t\t};\n\t\t} else {\n\t\t\tconst newEditor = candidate;\n\t\t\tconst indexOfActive = this.indexOf(this.active);\n\n\t\t\t// Insert into specific position\n\t\t\tlet targetIndex: number;\n\t\t\tif (options && typeof options.index === \"number\") {\n\t\t\t\ttargetIndex = options.index;\n\t\t\t}\n\n\t\t\t// Insert to the BEGINNING\n\t\t\telse if (\n\t\t\t\tthis.editorOpenPositioning === EditorOpenPositioning.FIRST\n\t\t\t) {\n\t\t\t\ttargetIndex = 0;\n\n\t\t\t\t// Always make sure targetIndex is after sticky editors\n\t\t\t\t// unless we are explicitly told to make the editor sticky\n\t\t\t\tif (!makeSticky && this.isSticky(targetIndex)) {\n\t\t\t\t\ttargetIndex = this.sticky + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Insert to the END\n\t\t\telse if (\n\t\t\t\tthis.editorOpenPositioning === EditorOpenPositioning.LAST\n\t\t\t) {\n\t\t\t\ttargetIndex = this.editors.length;\n\t\t\t}\n\n\t\t\t// Insert to LEFT or RIGHT of active editor\n\t\t\telse {\n\t\t\t\t// Insert to the LEFT of active editor\n\t\t\t\tif (this.editorOpenPositioning === EditorOpenPositioning.LEFT) {\n\t\t\t\t\tif (indexOfActive === 0 || !this.editors.length) {\n\t\t\t\t\t\ttargetIndex = 0; // to the left becoming first editor in list\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttargetIndex = indexOfActive; // to the left of active editor\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Insert to the RIGHT of active editor\n\t\t\t\telse {\n\t\t\t\t\ttargetIndex = indexOfActive + 1;\n\t\t\t\t}\n\n\t\t\t\t// Always make sure targetIndex is after sticky editors\n\t\t\t\t// unless we are explicitly told to make the editor sticky\n\t\t\t\tif (!makeSticky && this.isSticky(targetIndex)) {\n\t\t\t\t\ttargetIndex = this.sticky + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If the editor becomes sticky, increment the sticky index and adjust\n\t\t\t// the targetIndex to be at the end of sticky editors unless already.\n\t\t\tif (makeSticky) {\n\t\t\t\tthis.sticky++;\n\n\t\t\t\tif (!this.isSticky(targetIndex)) {\n\t\t\t\t\ttargetIndex = this.sticky;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Insert into our list of editors if pinned or we have no preview editor\n\t\t\tif (makePinned || !this.preview) {\n\t\t\t\tthis.splice(targetIndex, false, newEditor);\n\t\t\t}\n\n\t\t\t// Handle transient\n\t\t\tif (makeTransient) {\n\t\t\t\tthis.doSetTransient(newEditor, targetIndex, true);\n\t\t\t}\n\n\t\t\t// Handle preview\n\t\t\tif (!makePinned) {\n\t\t\t\t// Replace existing preview with this editor if we have a preview\n\t\t\t\tif (this.preview) {\n\t\t\t\t\tconst indexOfPreview = this.indexOf(this.preview);\n\t\t\t\t\tif (targetIndex > indexOfPreview) {\n\t\t\t\t\t\ttargetIndex--; // accomodate for the fact that the preview editor closes\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.replaceEditor(\n\t\t\t\t\t\tthis.preview,\n\t\t\t\t\t\tnewEditor,\n\t\t\t\t\t\ttargetIndex,\n\t\t\t\t\t\t!makeActive,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tthis.preview = newEditor;\n\t\t\t}\n\n\t\t\t// Listeners\n\t\t\tthis.registerEditorListeners(newEditor);\n\n\t\t\t// Event\n\t\t\tconst event: IGroupEditorOpenEvent = {\n\t\t\t\tkind: GroupModelChangeKind.EDITOR_OPEN,\n\t\t\t\teditor: newEditor,\n\t\t\t\teditorIndex: targetIndex,\n\t\t\t};\n\t\t\tthis._onDidModelChange.fire(event);\n\n\t\t\t// Handle active editor / selected editors\n\t\t\tthis.setSelection(\n\t\t\t\tmakeActive ? newEditor : this.activeEditor,\n\t\t\t\toptions?.inactiveSelection ?? [],\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\teditor: newEditor,\n\t\t\t\tisNew: true,\n\t\t\t};\n\t\t}\n\t}\n\n\tprivate registerEditorListeners(editor: EditorInput): void {\n\t\tconst listeners = new DisposableStore();\n\t\tthis.editorListeners.add(listeners);\n\n\t\t// Re-emit disposal of editor input as our own event\n\t\tlisteners.add(\n\t\t\tEvent.once(editor.onWillDispose)(() => {\n\t\t\t\tconst editorIndex = this.editors.indexOf(editor);\n\t\t\t\tif (editorIndex >= 0) {\n\t\t\t\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\t\t\t\tkind: GroupModelChangeKind.EDITOR_WILL_DISPOSE,\n\t\t\t\t\t\teditor,\n\t\t\t\t\t\teditorIndex,\n\t\t\t\t\t};\n\t\t\t\t\tthis._onDidModelChange.fire(event);\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\n\t\t// Re-Emit dirty state changes\n\t\tlisteners.add(\n\t\t\teditor.onDidChangeDirty(() => {\n\t\t\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\t\t\tkind: GroupModelChangeKind.EDITOR_DIRTY,\n\t\t\t\t\teditor,\n\t\t\t\t\teditorIndex: this.editors.indexOf(editor),\n\t\t\t\t};\n\t\t\t\tthis._onDidModelChange.fire(event);\n\t\t\t}),\n\t\t);\n\n\t\t// Re-Emit label changes\n\t\tlisteners.add(\n\t\t\teditor.onDidChangeLabel(() => {\n\t\t\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\t\t\tkind: GroupModelChangeKind.EDITOR_LABEL,\n\t\t\t\t\teditor,\n\t\t\t\t\teditorIndex: this.editors.indexOf(editor),\n\t\t\t\t};\n\t\t\t\tthis._onDidModelChange.fire(event);\n\t\t\t}),\n\t\t);\n\n\t\t// Re-Emit capability changes\n\t\tlisteners.add(\n\t\t\teditor.onDidChangeCapabilities(() => {\n\t\t\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\t\t\tkind: GroupModelChangeKind.EDITOR_CAPABILITIES,\n\t\t\t\t\teditor,\n\t\t\t\t\teditorIndex: this.editors.indexOf(editor),\n\t\t\t\t};\n\t\t\t\tthis._onDidModelChange.fire(event);\n\t\t\t}),\n\t\t);\n\n\t\t// Clean up dispose listeners once the editor gets closed\n\t\tlisteners.add(\n\t\t\tthis.onDidModelChange((event) => {\n\t\t\t\tif (\n\t\t\t\t\tevent.kind === GroupModelChangeKind.EDITOR_CLOSE &&\n\t\t\t\t\tevent.editor?.matches(editor)\n\t\t\t\t) {\n\t\t\t\t\tdispose(listeners);\n\t\t\t\t\tthis.editorListeners.delete(listeners);\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\t}\n\n\tprivate replaceEditor(\n\t\ttoReplace: EditorInput,\n\t\treplaceWith: EditorInput,\n\t\treplaceIndex: number,\n\t\topenNext = true,\n\t): void {\n\t\tconst closeResult = this.doCloseEditor(\n\t\t\ttoReplace,\n\t\t\tEditorCloseContext.REPLACE,\n\t\t\topenNext,\n\t\t); // optimization to prevent multiple setActive() in one call\n\n\t\t// We want to first add the new editor into our model before emitting the close event because\n\t\t// firing the close event can trigger a dispose on the same editor that is now being added.\n\t\t// This can lead into opening a disposed editor which is not what we want.\n\t\tthis.splice(replaceIndex, false, replaceWith);\n\n\t\tif (closeResult) {\n\t\t\tconst event: IGroupEditorCloseEvent = {\n\t\t\t\tkind: GroupModelChangeKind.EDITOR_CLOSE,\n\t\t\t\t...closeResult,\n\t\t\t};\n\t\t\tthis._onDidModelChange.fire(event);\n\t\t}\n\t}\n\n\tcloseEditor(\n\t\tcandidate: EditorInput,\n\t\tcontext = EditorCloseContext.UNKNOWN,\n\t\topenNext = true,\n\t): IEditorCloseResult | undefined {\n\t\tconst closeResult = this.doCloseEditor(candidate, context, openNext);\n\n\t\tif (closeResult) {\n\t\t\tconst event: IGroupEditorCloseEvent = {\n\t\t\t\tkind: GroupModelChangeKind.EDITOR_CLOSE,\n\t\t\t\t...closeResult,\n\t\t\t};\n\t\t\tthis._onDidModelChange.fire(event);\n\n\t\t\treturn closeResult;\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate doCloseEditor(\n\t\tcandidate: EditorInput,\n\t\tcontext: EditorCloseContext,\n\t\topenNext: boolean,\n\t): IEditorCloseResult | undefined {\n\t\tconst index = this.indexOf(candidate);\n\t\tif (index === -1) {\n\t\t\treturn undefined; // not found\n\t\t}\n\n\t\tconst editor = this.editors[index];\n\t\tconst sticky = this.isSticky(index);\n\n\t\t// Active editor closed\n\t\tconst isActiveEditor = this.active === editor;\n\t\tif (openNext && isActiveEditor) {\n\t\t\t// More than one editor\n\t\t\tif (this.mru.length > 1) {\n\t\t\t\tlet newActive: EditorInput;\n\t\t\t\tif (this.focusRecentEditorAfterClose) {\n\t\t\t\t\tnewActive = this.mru[1]; // active editor is always first in MRU, so pick second editor after as new active\n\t\t\t\t} else if (index === this.editors.length - 1) {\n\t\t\t\t\tnewActive = this.editors[index - 1]; // last editor is closed, pick previous as new active\n\t\t\t\t} else {\n\t\t\t\t\tnewActive = this.editors[index + 1]; // pick next editor as new active\n\t\t\t\t}\n\n\t\t\t\t// Select editor as active\n\t\t\t\tconst newInactiveSelectedEditors = this.selection.filter(\n\t\t\t\t\t(selected) => selected !== editor && selected !== newActive,\n\t\t\t\t);\n\t\t\t\tthis.doSetSelection(\n\t\t\t\t\tnewActive,\n\t\t\t\t\tthis.editors.indexOf(newActive),\n\t\t\t\t\tnewInactiveSelectedEditors,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Last editor closed: clear selection\n\t\t\telse {\n\t\t\t\tthis.doSetSelection(null, undefined, []);\n\t\t\t}\n\t\t}\n\n\t\t// Inactive editor closed\n\t\telse if (!isActiveEditor) {\n\t\t\t// Remove editor from inactive selection\n\t\t\tif (this.doIsSelected(editor)) {\n\t\t\t\tconst newInactiveSelectedEditors = this.selection.filter(\n\t\t\t\t\t(selected) =>\n\t\t\t\t\t\tselected !== editor && selected !== this.activeEditor,\n\t\t\t\t);\n\t\t\t\tthis.doSetSelection(\n\t\t\t\t\tthis.activeEditor,\n\t\t\t\t\tthis.indexOf(this.activeEditor),\n\t\t\t\t\tnewInactiveSelectedEditors,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Preview Editor closed\n\t\tif (this.preview === editor) {\n\t\t\tthis.preview = null;\n\t\t}\n\n\t\t// Remove from transient\n\t\tthis.transient.delete(editor);\n\n\t\t// Remove from arrays\n\t\tthis.splice(index, true);\n\n\t\t// Event\n\t\treturn { editor, sticky, editorIndex: index, context };\n\t}\n\n\tmoveEditor(\n\t\tcandidate: EditorInput,\n\t\ttoIndex: number,\n\t): EditorInput | undefined {\n\t\t// Ensure toIndex is in bounds of our model\n\t\tif (toIndex >= this.editors.length) {\n\t\t\ttoIndex = this.editors.length - 1;\n\t\t} else if (toIndex < 0) {\n\t\t\ttoIndex = 0;\n\t\t}\n\n\t\tconst index = this.indexOf(candidate);\n\t\tif (index < 0 || toIndex === index) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst editor = this.editors[index];\n\t\tconst sticky = this.sticky;\n\n\t\t// Adjust sticky index: editor moved out of sticky state into unsticky state\n\t\tif (this.isSticky(index) && toIndex > this.sticky) {\n\t\t\tthis.sticky--;\n\t\t}\n\n\t\t// ...or editor moved into sticky state from unsticky state\n\t\telse if (!this.isSticky(index) && toIndex <= this.sticky) {\n\t\t\tthis.sticky++;\n\t\t}\n\n\t\t// Move\n\t\tthis.editors.splice(index, 1);\n\t\tthis.editors.splice(toIndex, 0, editor);\n\n\t\t// Move Event\n\t\tconst event: IGroupEditorMoveEvent = {\n\t\t\tkind: GroupModelChangeKind.EDITOR_MOVE,\n\t\t\teditor,\n\t\t\toldEditorIndex: index,\n\t\t\teditorIndex: toIndex,\n\t\t};\n\t\tthis._onDidModelChange.fire(event);\n\n\t\t// Sticky Event (if sticky changed as part of the move)\n\t\tif (sticky !== this.sticky) {\n\t\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\t\tkind: GroupModelChangeKind.EDITOR_STICKY,\n\t\t\t\teditor,\n\t\t\t\teditorIndex: toIndex,\n\t\t\t};\n\t\t\tthis._onDidModelChange.fire(event);\n\t\t}\n\n\t\treturn editor;\n\t}\n\n\tsetActive(candidate: EditorInput | undefined): EditorInput | undefined {\n\t\tlet result: EditorInput | undefined;\n\n\t\tif (candidate) {\n\t\t\tresult = this.setEditorActive(candidate);\n\t\t} else {\n\t\t\tthis.setGroupActive();\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate setGroupActive(): void {\n\t\t// We do not really keep the `active` state in our model because\n\t\t// it has no special meaning to us here. But for consistency\n\t\t// we emit a `onDidModelChange` event so that components can\n\t\t// react.\n\t\tthis._onDidModelChange.fire({\n\t\t\tkind: GroupModelChangeKind.GROUP_ACTIVE,\n\t\t});\n\t}\n\n\tprivate setEditorActive(candidate: EditorInput): EditorInput | undefined {\n\t\tconst res = this.findEditor(candidate);\n\t\tif (!res) {\n\t\t\treturn; // not found\n\t\t}\n\n\t\tconst [editor, editorIndex] = res;\n\n\t\tthis.doSetSelection(editor, editorIndex, []);\n\n\t\treturn editor;\n\t}\n\n\tget selectedEditors(): EditorInput[] {\n\t\treturn this.editors.filter((editor) => this.doIsSelected(editor)); // return in sequential order\n\t}\n\n\tisSelected(editorCandidateOrIndex: EditorInput | number): boolean {\n\t\tlet editor: EditorInput | undefined;\n\t\tif (typeof editorCandidateOrIndex === \"number\") {\n\t\t\teditor = this.editors[editorCandidateOrIndex];\n\t\t} else {\n\t\t\teditor = this.findEditor(editorCandidateOrIndex)?.[0];\n\t\t}\n\n\t\treturn !!editor && this.doIsSelected(editor);\n\t}\n\n\tprivate doIsSelected(editor: EditorInput): boolean {\n\t\treturn this.selection.includes(editor);\n\t}\n\n\tsetSelection(\n\t\tactiveSelectedEditorCandidate: EditorInput,\n\t\tinactiveSelectedEditorCandidates: EditorInput[],\n\t): void {\n\t\tconst res = this.findEditor(activeSelectedEditorCandidate);\n\t\tif (!res) {\n\t\t\treturn; // not found\n\t\t}\n\n\t\tconst [activeSelectedEditor, activeSelectedEditorIndex] = res;\n\n\t\tconst inactiveSelectedEditors = new Set<EditorInput>();\n\t\tfor (const inactiveSelectedEditorCandidate of inactiveSelectedEditorCandidates) {\n\t\t\tconst res = this.findEditor(inactiveSelectedEditorCandidate);\n\t\t\tif (!res) {\n\t\t\t\treturn; // not found\n\t\t\t}\n\n\t\t\tconst [inactiveSelectedEditor] = res;\n\t\t\tif (inactiveSelectedEditor === activeSelectedEditor) {\n\t\t\t\tcontinue; // already selected\n\t\t\t}\n\n\t\t\tinactiveSelectedEditors.add(inactiveSelectedEditor);\n\t\t}\n\n\t\tthis.doSetSelection(\n\t\t\tactiveSelectedEditor,\n\t\t\tactiveSelectedEditorIndex,\n\t\t\tArray.from(inactiveSelectedEditors),\n\t\t);\n\t}\n\n\tprivate doSetSelection(\n\t\tactiveSelectedEditor: EditorInput | null,\n\t\tactiveSelectedEditorIndex: number | undefined,\n\t\tinactiveSelectedEditors: EditorInput[],\n\t): void {\n\t\tconst previousActiveEditor = this.activeEditor;\n\t\tconst previousSelection = this.selection;\n\n\t\tlet newSelection: EditorInput[];\n\t\tif (activeSelectedEditor) {\n\t\t\tnewSelection = [activeSelectedEditor, ...inactiveSelectedEditors];\n\t\t} else {\n\t\t\tnewSelection = [];\n\t\t}\n\n\t\t// Update selection\n\t\tthis.selection = newSelection;\n\n\t\t// Update active editor if it has changed\n\t\tconst activeEditorChanged =\n\t\t\tactiveSelectedEditor &&\n\t\t\ttypeof activeSelectedEditorIndex === \"number\" &&\n\t\t\tpreviousActiveEditor !== activeSelectedEditor;\n\t\tif (activeEditorChanged) {\n\t\t\t// Bring to front in MRU list\n\t\t\tconst mruIndex = this.indexOf(activeSelectedEditor, this.mru);\n\t\t\tthis.mru.splice(mruIndex, 1);\n\t\t\tthis.mru.unshift(activeSelectedEditor);\n\n\t\t\t// Event\n\t\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\t\tkind: GroupModelChangeKind.EDITOR_ACTIVE,\n\t\t\t\teditor: activeSelectedEditor,\n\t\t\t\teditorIndex: activeSelectedEditorIndex,\n\t\t\t};\n\t\t\tthis._onDidModelChange.fire(event);\n\t\t}\n\n\t\t// Fire event if the selection has changed\n\t\tif (\n\t\t\tactiveEditorChanged ||\n\t\t\tpreviousSelection.length !== newSelection.length ||\n\t\t\tpreviousSelection.some((editor) => !newSelection.includes(editor))\n\t\t) {\n\t\t\tconst event: IGroupModelChangeEvent = {\n\t\t\t\tkind: GroupModelChangeKind.EDITORS_SELECTION,\n\t\t\t};\n\t\t\tthis._onDidModelChange.fire(event);\n\t\t}\n\t}\n\n\tsetIndex(index: number) {\n\t\t// We do not really keep the `index` in our model because\n\t\t// it has no special meaning to us here. But for consistency\n\t\t// we emit a `onDidModelChange` event so that components can\n\t\t// react.\n\t\tthis._onDidModelChange.fire({ kind: GroupModelChangeKind.GROUP_INDEX });\n\t}\n\n\tsetLabel(label: string) {\n\t\t// We do not really keep the `label` in our model because\n\t\t// it has no special meaning to us here. But for consistency\n\t\t// we emit a `onDidModelChange` event so that components can\n\t\t// react.\n\t\tthis._onDidModelChange.fire({ kind: GroupModelChangeKind.GROUP_LABEL });\n\t}\n\n\tpin(candidate: EditorInput): EditorInput | undefined {\n\t\tconst res = this.findEditor(candidate);\n\t\tif (!res) {\n\t\t\treturn; // not found\n\t\t}\n\n\t\tconst [editor, editorIndex] = res;\n\n\t\tthis.doPin(editor, editorIndex);\n\n\t\treturn editor;\n\t}\n\n\tprivate doPin(editor: EditorInput, editorIndex: number): void {\n\t\tif (this.isPinned(editor)) {\n\t\t\treturn; // can only pin a preview editor\n\t\t}\n\n\t\t// Clear Transient\n\t\tthis.setTransient(editor, false);\n\n\t\t// Convert the preview editor to be a pinned editor\n\t\tthis.preview = null;\n\n\t\t// Event\n\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\tkind: GroupModelChangeKind.EDITOR_PIN,\n\t\t\teditor,\n\t\t\teditorIndex,\n\t\t};\n\t\tthis._onDidModelChange.fire(event);\n\t}\n\n\tunpin(candidate: EditorInput): EditorInput | undefined {\n\t\tconst res = this.findEditor(candidate);\n\t\tif (!res) {\n\t\t\treturn; // not found\n\t\t}\n\n\t\tconst [editor, editorIndex] = res;\n\n\t\tthis.doUnpin(editor, editorIndex);\n\n\t\treturn editor;\n\t}\n\n\tprivate doUnpin(editor: EditorInput, editorIndex: number): void {\n\t\tif (!this.isPinned(editor)) {\n\t\t\treturn; // can only unpin a pinned editor\n\t\t}\n\n\t\t// Set new\n\t\tconst oldPreview = this.preview;\n\t\tthis.preview = editor;\n\n\t\t// Event\n\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\tkind: GroupModelChangeKind.EDITOR_PIN,\n\t\t\teditor,\n\t\t\teditorIndex,\n\t\t};\n\t\tthis._onDidModelChange.fire(event);\n\n\t\t// Close old preview editor if any\n\t\tif (oldPreview) {\n\t\t\tthis.closeEditor(oldPreview, EditorCloseContext.UNPIN);\n\t\t}\n\t}\n\n\tisPinned(editorCandidateOrIndex: EditorInput | number): boolean {\n\t\tlet editor: EditorInput;\n\t\tif (typeof editorCandidateOrIndex === \"number\") {\n\t\t\teditor = this.editors[editorCandidateOrIndex];\n\t\t} else {\n\t\t\teditor = editorCandidateOrIndex;\n\t\t}\n\n\t\treturn !this.matches(this.preview, editor);\n\t}\n\n\tstick(candidate: EditorInput): EditorInput | undefined {\n\t\tconst res = this.findEditor(candidate);\n\t\tif (!res) {\n\t\t\treturn; // not found\n\t\t}\n\n\t\tconst [editor, editorIndex] = res;\n\n\t\tthis.doStick(editor, editorIndex);\n\n\t\treturn editor;\n\t}\n\n\tprivate doStick(editor: EditorInput, editorIndex: number): void {\n\t\tif (this.isSticky(editorIndex)) {\n\t\t\treturn; // can only stick a non-sticky editor\n\t\t}\n\n\t\t// Pin editor\n\t\tthis.pin(editor);\n\n\t\t// Move editor to be the last sticky editor\n\t\tconst newEditorIndex = this.sticky + 1;\n\t\tthis.moveEditor(editor, newEditorIndex);\n\n\t\t// Adjust sticky index\n\t\tthis.sticky++;\n\n\t\t// Event\n\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\tkind: GroupModelChangeKind.EDITOR_STICKY,\n\t\t\teditor,\n\t\t\teditorIndex: newEditorIndex,\n\t\t};\n\t\tthis._onDidModelChange.fire(event);\n\t}\n\n\tunstick(candidate: EditorInput): EditorInput | undefined {\n\t\tconst res = this.findEditor(candidate);\n\t\tif (!res) {\n\t\t\treturn; // not found\n\t\t}\n\n\t\tconst [editor, editorIndex] = res;\n\n\t\tthis.doUnstick(editor, editorIndex);\n\n\t\treturn editor;\n\t}\n\n\tprivate doUnstick(editor: EditorInput, editorIndex: number): void {\n\t\tif (!this.isSticky(editorIndex)) {\n\t\t\treturn; // can only unstick a sticky editor\n\t\t}\n\n\t\t// Move editor to be the first non-sticky editor\n\t\tconst newEditorIndex = this.sticky;\n\t\tthis.moveEditor(editor, newEditorIndex);\n\n\t\t// Adjust sticky index\n\t\tthis.sticky--;\n\n\t\t// Event\n\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\tkind: GroupModelChangeKind.EDITOR_STICKY,\n\t\t\teditor,\n\t\t\teditorIndex: newEditorIndex,\n\t\t};\n\t\tthis._onDidModelChange.fire(event);\n\t}\n\n\tisSticky(candidateOrIndex: EditorInput | number): boolean {\n\t\tif (this.sticky < 0) {\n\t\t\treturn false; // no sticky editor\n\t\t}\n\n\t\tlet index: number;\n\t\tif (typeof candidateOrIndex === \"number\") {\n\t\t\tindex = candidateOrIndex;\n\t\t} else {\n\t\t\tindex = this.indexOf(candidateOrIndex);\n\t\t}\n\n\t\tif (index < 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn index <= this.sticky;\n\t}\n\n\tsetTransient(\n\t\tcandidate: EditorInput,\n\t\ttransient: boolean,\n\t): EditorInput | undefined {\n\t\tif (!transient && this.transient.size === 0) {\n\t\t\treturn; // no transient editor\n\t\t}\n\n\t\tconst res = this.findEditor(candidate);\n\t\tif (!res) {\n\t\t\treturn; // not found\n\t\t}\n\n\t\tconst [editor, editorIndex] = res;\n\n\t\tthis.doSetTransient(editor, editorIndex, transient);\n\n\t\treturn editor;\n\t}\n\n\tprivate doSetTransient(\n\t\teditor: EditorInput,\n\t\teditorIndex: number,\n\t\ttransient: boolean,\n\t): void {\n\t\tif (transient) {\n\t\t\tif (this.transient.has(editor)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.transient.add(editor);\n\t\t} else {\n\t\t\tif (!this.transient.has(editor)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.transient.delete(editor);\n\t\t}\n\n\t\t// Event\n\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\tkind: GroupModelChangeKind.EDITOR_TRANSIENT,\n\t\t\teditor,\n\t\t\teditorIndex,\n\t\t};\n\t\tthis._onDidModelChange.fire(event);\n\t}\n\n\tisTransient(editorCandidateOrIndex: EditorInput | number): boolean {\n\t\tif (this.transient.size === 0) {\n\t\t\treturn false; // no transient editor\n\t\t}\n\n\t\tlet editor: EditorInput | undefined;\n\t\tif (typeof editorCandidateOrIndex === \"number\") {\n\t\t\teditor = this.editors[editorCandidateOrIndex];\n\t\t} else {\n\t\t\teditor = this.findEditor(editorCandidateOrIndex)?.[0];\n\t\t}\n\n\t\treturn !!editor && this.transient.has(editor);\n\t}\n\n\tprivate splice(index: number, del: boolean, editor?: EditorInput): void {\n\t\tconst editorToDeleteOrReplace = this.editors[index];\n\n\t\t// Perform on sticky index\n\t\tif (del && this.isSticky(index)) {\n\t\t\tthis.sticky--;\n\t\t}\n\n\t\t// Perform on editors array\n\t\tif (editor) {\n\t\t\tthis.editors.splice(index, del ? 1 : 0, editor);\n\t\t} else {\n\t\t\tthis.editors.splice(index, del ? 1 : 0);\n\t\t}\n\n\t\t// Perform on MRU\n\t\t{\n\t\t\t// Add\n\t\t\tif (!del && editor) {\n\t\t\t\tif (this.mru.length === 0) {\n\t\t\t\t\t// the list of most recent editors is empty\n\t\t\t\t\t// so this editor can only be the most recent\n\t\t\t\t\tthis.mru.push(editor);\n\t\t\t\t} else {\n\t\t\t\t\t// we have most recent editors. as such we\n\t\t\t\t\t// put this newly opened editor right after\n\t\t\t\t\t// the current most recent one because it cannot\n\t\t\t\t\t// be the most recently active one unless\n\t\t\t\t\t// it becomes active. but it is still more\n\t\t\t\t\t// active then any other editor in the list.\n\t\t\t\t\tthis.mru.splice(1, 0, editor);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove / Replace\n\t\t\telse {\n\t\t\t\tconst indexInMRU = this.indexOf(\n\t\t\t\t\teditorToDeleteOrReplace,\n\t\t\t\t\tthis.mru,\n\t\t\t\t);\n\n\t\t\t\t// Remove\n\t\t\t\tif (del && !editor) {\n\t\t\t\t\tthis.mru.splice(indexInMRU, 1); // remove from MRU\n\t\t\t\t}\n\n\t\t\t\t// Replace\n\t\t\t\telse if (del && editor) {\n\t\t\t\t\tthis.mru.splice(indexInMRU, 1, editor); // replace MRU at location\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tindexOf(\n\t\tcandidate: EditorInput | IUntypedEditorInput | null,\n\t\teditors = this.editors,\n\t\toptions?: IMatchEditorOptions,\n\t): number {\n\t\tlet index = -1;\n\t\tif (!candidate) {\n\t\t\treturn index;\n\t\t}\n\n\t\tfor (let i = 0; i < editors.length; i++) {\n\t\t\tconst editor = editors[i];\n\n\t\t\tif (this.matches(editor, candidate, options)) {\n\t\t\t\t// If we are to support side by side matching, it is possible that\n\t\t\t\t// a better direct match is found later. As such, we continue finding\n\t\t\t\t// a matching editor and prefer that match over the side by side one.\n\t\t\t\tif (\n\t\t\t\t\toptions?.supportSideBySide &&\n\t\t\t\t\teditor instanceof SideBySideEditorInput &&\n\t\t\t\t\t!(candidate instanceof SideBySideEditorInput)\n\t\t\t\t) {\n\t\t\t\t\tindex = i;\n\t\t\t\t} else {\n\t\t\t\t\tindex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn index;\n\t}\n\n\tfindEditor(\n\t\tcandidate: EditorInput | null,\n\t\toptions?: IMatchEditorOptions,\n\t): [EditorInput, number /* index */] | undefined {\n\t\tconst index = this.indexOf(candidate, this.editors, options);\n\t\tif (index === -1) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn [this.editors[index], index];\n\t}\n\n\tisFirst(candidate: EditorInput | null, editors = this.editors): boolean {\n\t\treturn this.matches(editors[0], candidate);\n\t}\n\n\tisLast(candidate: EditorInput | null, editors = this.editors): boolean {\n\t\treturn this.matches(editors[editors.length - 1], candidate);\n\t}\n\n\tcontains(\n\t\tcandidate: EditorInput | IUntypedEditorInput,\n\t\toptions?: IMatchEditorOptions,\n\t): boolean {\n\t\treturn this.indexOf(candidate, this.editors, options) !== -1;\n\t}\n\n\tprivate matches(\n\t\teditor: EditorInput | null | undefined,\n\t\tcandidate: EditorInput | IUntypedEditorInput | null,\n\t\toptions?: IMatchEditorOptions,\n\t): boolean {\n\t\tif (!editor || !candidate) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (\n\t\t\toptions?.supportSideBySide &&\n\t\t\teditor instanceof SideBySideEditorInput &&\n\t\t\t!(candidate instanceof SideBySideEditorInput)\n\t\t) {\n\t\t\tswitch (options.supportSideBySide) {\n\t\t\t\tcase SideBySideEditor.ANY:\n\t\t\t\t\tif (\n\t\t\t\t\t\tthis.matches(editor.primary, candidate, options) ||\n\t\t\t\t\t\tthis.matches(editor.secondary, candidate, options)\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SideBySideEditor.BOTH:\n\t\t\t\t\tif (\n\t\t\t\t\t\tthis.matches(editor.primary, candidate, options) &&\n\t\t\t\t\t\tthis.matches(editor.secondary, candidate, options)\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tconst strictEquals = editor === candidate;\n\n\t\tif (options?.strictEquals) {\n\t\t\treturn strictEquals;\n\t\t}\n\n\t\treturn strictEquals || editor.matches(candidate);\n\t}\n\n\tget isLocked(): boolean {\n\t\treturn this.locked;\n\t}\n\n\tlock(locked: boolean): void {\n\t\tif (this.isLocked !== locked) {\n\t\t\tthis.locked = locked;\n\n\t\t\tthis._onDidModelChange.fire({\n\t\t\t\tkind: GroupModelChangeKind.GROUP_LOCKED,\n\t\t\t});\n\t\t}\n\t}\n\n\tclone(): EditorGroupModel {\n\t\tconst clone = this.instantiationService.createInstance(\n\t\t\tEditorGroupModel,\n\t\t\tundefined,\n\t\t);\n\n\t\t// Copy over group properties\n\t\tclone.editors = this.editors.slice(0);\n\t\tclone.mru = this.mru.slice(0);\n\t\tclone.preview = this.preview;\n\t\tclone.selection = this.selection.slice(0);\n\t\tclone.sticky = this.sticky;\n\n\t\t// Ensure to register listeners for each editor\n\t\tfor (const editor of clone.editors) {\n\t\t\tclone.registerEditorListeners(editor);\n\t\t}\n\n\t\treturn clone;\n\t}\n\n\tserialize(): ISerializedEditorGroupModel {\n\t\tconst registry = Registry.as<IEditorFactoryRegistry>(\n\t\t\tEditorExtensions.EditorFactory,\n\t\t);\n\n\t\t// Serialize all editor inputs so that we can store them.\n\t\t// Editors that cannot be serialized need to be ignored\n\t\t// from mru, active, preview and sticky if any.\n\t\tconst serializableEditors: EditorInput[] = [];\n\t\tconst serializedEditors: ISerializedEditorInput[] = [];\n\t\tlet serializablePreviewIndex: number | undefined;\n\t\tlet serializableSticky = this.sticky;\n\n\t\tfor (let i = 0; i < this.editors.length; i++) {\n\t\t\tconst editor = this.editors[i];\n\t\t\tlet canSerializeEditor = false;\n\n\t\t\tconst editorSerializer = registry.getEditorSerializer(editor);\n\t\t\tif (editorSerializer) {\n\t\t\t\tconst value = editorSerializer.canSerialize(editor)\n\t\t\t\t\t? editorSerializer.serialize(editor)\n\t\t\t\t\t: undefined;\n\n\t\t\t\t// Editor can be serialized\n\t\t\t\tif (typeof value === \"string\") {\n\t\t\t\t\tcanSerializeEditor = true;\n\n\t\t\t\t\tserializedEditors.push({ id: editor.typeId, value });\n\t\t\t\t\tserializableEditors.push(editor);\n\n\t\t\t\t\tif (this.preview === editor) {\n\t\t\t\t\t\tserializablePreviewIndex =\n\t\t\t\t\t\t\tserializableEditors.length - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Editor cannot be serialized\n\t\t\t\telse {\n\t\t\t\t\tcanSerializeEditor = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Adjust index of sticky editors if the editor cannot be serialized and is pinned\n\t\t\tif (!canSerializeEditor && this.isSticky(i)) {\n\t\t\t\tserializableSticky--;\n\t\t\t}\n\t\t}\n\n\t\tconst serializableMru = this.mru\n\t\t\t.map((editor) => this.indexOf(editor, serializableEditors))\n\t\t\t.filter((i) => i >= 0);\n\n\t\treturn {\n\t\t\tid: this.id,\n\t\t\tlocked: this.locked ? true : undefined,\n\t\t\teditors: serializedEditors,\n\t\t\tmru: serializableMru,\n\t\t\tpreview: serializablePreviewIndex,\n\t\t\tsticky: serializableSticky >= 0 ? serializableSticky : undefined,\n\t\t};\n\t}\n\n\tprivate deserialize(data: ISerializedEditorGroupModel): number {\n\t\tconst registry = Registry.as<IEditorFactoryRegistry>(\n\t\t\tEditorExtensions.EditorFactory,\n\t\t);\n\n\t\tif (typeof data.id === \"number\") {\n\t\t\tthis._id = data.id;\n\n\t\t\tEditorGroupModel.IDS = Math.max(data.id + 1, EditorGroupModel.IDS); // make sure our ID generator is always larger\n\t\t} else {\n\t\t\tthis._id = EditorGroupModel.IDS++; // backwards compatibility\n\t\t}\n\n\t\tif (data.locked) {\n\t\t\tthis.locked = true;\n\t\t}\n\n\t\tthis.editors = coalesce(\n\t\t\tdata.editors.map((e, index) => {\n\t\t\t\tlet editor: EditorInput | undefined;\n\n\t\t\t\tconst editorSerializer = registry.getEditorSerializer(e.id);\n\t\t\t\tif (editorSerializer) {\n\t\t\t\t\tconst deserializedEditor = editorSerializer.deserialize(\n\t\t\t\t\t\tthis.instantiationService,\n\t\t\t\t\t\te.value,\n\t\t\t\t\t);\n\t\t\t\t\tif (deserializedEditor instanceof EditorInput) {\n\t\t\t\t\t\teditor = deserializedEditor;\n\t\t\t\t\t\tthis.registerEditorListeners(editor);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t!editor &&\n\t\t\t\t\ttypeof data.sticky === \"number\" &&\n\t\t\t\t\tindex <= data.sticky\n\t\t\t\t) {\n\t\t\t\t\tdata.sticky--; // if editor cannot be deserialized but was sticky, we need to decrease sticky index\n\t\t\t\t}\n\n\t\t\t\treturn editor;\n\t\t\t}),\n\t\t);\n\n\t\tthis.mru = coalesce(data.mru.map((i) => this.editors[i]));\n\n\t\tthis.selection = this.mru.length > 0 ? [this.mru[0]] : [];\n\n\t\tif (typeof data.preview === \"number\") {\n\t\t\tthis.preview = this.editors[data.preview];\n\t\t}\n\n\t\tif (typeof data.sticky === \"number\") {\n\t\t\tthis.sticky = data.sticky;\n\t\t}\n\n\t\treturn this._id;\n\t}\n\n\toverride dispose(): void {\n\t\tdispose(Array.from(this.editorListeners));\n\t\tthis.editorListeners.clear();\n\n\t\tthis.transient.clear();\n\n\t\tsuper.dispose();\n\t}\n}\n"],
  "mappings": "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",
  "names": ["event", "res"]
}
