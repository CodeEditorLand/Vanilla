{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/common/editor/editorGroupModel.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event, Emitter } from '../../../base/common/event.js';\nimport { IEditorFactoryRegistry, GroupIdentifier, EditorsOrder, EditorExtensions, IUntypedEditorInput, SideBySideEditor, EditorCloseContext, IMatchEditorOptions, GroupModelChangeKind } from '../editor.js';\nimport { EditorInput } from './editorInput.js';\nimport { SideBySideEditorInput } from './sideBySideEditorInput.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nimport { IConfigurationChangeEvent, IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { dispose, Disposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport { Registry } from '../../../platform/registry/common/platform.js';\nimport { coalesce } from '../../../base/common/arrays.js';\n\nconst EditorOpenPositioning = {\n\tLEFT: 'left',\n\tRIGHT: 'right',\n\tFIRST: 'first',\n\tLAST: 'last'\n};\n\nexport interface IEditorOpenOptions {\n\treadonly pinned?: boolean;\n\treadonly sticky?: boolean;\n\treadonly transient?: boolean;\n\tactive?: boolean;\n\treadonly inactiveSelection?: EditorInput[];\n\treadonly index?: number;\n\treadonly supportSideBySide?: SideBySideEditor.ANY | SideBySideEditor.BOTH;\n}\n\nexport interface IEditorOpenResult {\n\treadonly editor: EditorInput;\n\treadonly isNew: boolean;\n}\n\nexport interface ISerializedEditorInput {\n\treadonly id: string;\n\treadonly value: string;\n}\n\nexport interface ISerializedEditorGroupModel {\n\treadonly id: number;\n\treadonly locked?: boolean;\n\treadonly editors: ISerializedEditorInput[];\n\treadonly mru: number[];\n\treadonly preview?: number;\n\tsticky?: number;\n}\n\nexport function isSerializedEditorGroupModel(group?: unknown): group is ISerializedEditorGroupModel {\n\tconst candidate = group as ISerializedEditorGroupModel | undefined;\n\n\treturn !!(candidate && typeof candidate === 'object' && Array.isArray(candidate.editors) && Array.isArray(candidate.mru));\n}\n\nexport interface IMatchOptions {\n\n\t/**\n\t * Whether to consider a side by side editor as matching.\n\t * By default, side by side editors will not be considered\n\t * as matching, even if the editor is opened in one of the sides.\n\t */\n\treadonly supportSideBySide?: SideBySideEditor.ANY | SideBySideEditor.BOTH;\n\n\t/**\n\t * Only consider an editor to match when the\n\t * `candidate === editor` but not when\n\t * `candidate.matches(editor)`.\n\t */\n\treadonly strictEquals?: boolean;\n}\n\nexport interface IGroupModelChangeEvent {\n\n\t/**\n\t * The kind of change that occurred in the group model.\n\t */\n\treadonly kind: GroupModelChangeKind;\n\n\t/**\n\t * Only applies when editors change providing\n\t * access to the editor the event is about.\n\t */\n\treadonly editor?: EditorInput;\n\n\t/**\n\t * Only applies when editors change providing\n\t * access to the index of the editor the event\n\t * is about.\n\t */\n\treadonly editorIndex?: number;\n}\n\nexport interface IGroupEditorChangeEvent extends IGroupModelChangeEvent {\n\treadonly editor: EditorInput;\n\treadonly editorIndex: number;\n}\n\nexport function isGroupEditorChangeEvent(e: IGroupModelChangeEvent): e is IGroupEditorChangeEvent {\n\tconst candidate = e as IGroupEditorOpenEvent;\n\n\treturn candidate.editor && candidate.editorIndex !== undefined;\n}\n\nexport interface IGroupEditorOpenEvent extends IGroupEditorChangeEvent {\n\n\treadonly kind: GroupModelChangeKind.EDITOR_OPEN;\n}\n\nexport function isGroupEditorOpenEvent(e: IGroupModelChangeEvent): e is IGroupEditorOpenEvent {\n\tconst candidate = e as IGroupEditorOpenEvent;\n\n\treturn candidate.kind === GroupModelChangeKind.EDITOR_OPEN && candidate.editorIndex !== undefined;\n}\n\nexport interface IGroupEditorMoveEvent extends IGroupEditorChangeEvent {\n\n\treadonly kind: GroupModelChangeKind.EDITOR_MOVE;\n\n\t/**\n\t * Signifies the index the editor is moving from.\n\t * `editorIndex` will contain the index the editor\n\t * is moving to.\n\t */\n\treadonly oldEditorIndex: number;\n}\n\nexport function isGroupEditorMoveEvent(e: IGroupModelChangeEvent): e is IGroupEditorMoveEvent {\n\tconst candidate = e as IGroupEditorMoveEvent;\n\n\treturn candidate.kind === GroupModelChangeKind.EDITOR_MOVE && candidate.editorIndex !== undefined && candidate.oldEditorIndex !== undefined;\n}\n\nexport interface IGroupEditorCloseEvent extends IGroupEditorChangeEvent {\n\n\treadonly kind: GroupModelChangeKind.EDITOR_CLOSE;\n\n\t/**\n\t * Signifies the context in which the editor\n\t * is being closed. This allows for understanding\n\t * if a replace or reopen is occurring\n\t */\n\treadonly context: EditorCloseContext;\n\n\t/**\n\t * Signifies whether or not the closed editor was\n\t * sticky. This is necessary becasue state is lost\n\t * after closing.\n\t */\n\treadonly sticky: boolean;\n}\n\nexport function isGroupEditorCloseEvent(e: IGroupModelChangeEvent): e is IGroupEditorCloseEvent {\n\tconst candidate = e as IGroupEditorCloseEvent;\n\n\treturn candidate.kind === GroupModelChangeKind.EDITOR_CLOSE && candidate.editorIndex !== undefined && candidate.context !== undefined && candidate.sticky !== undefined;\n}\n\ninterface IEditorCloseResult {\n\treadonly editor: EditorInput;\n\treadonly context: EditorCloseContext;\n\treadonly editorIndex: number;\n\treadonly sticky: boolean;\n}\n\nexport interface IReadonlyEditorGroupModel {\n\n\treadonly onDidModelChange: Event<IGroupModelChangeEvent>;\n\n\treadonly id: GroupIdentifier;\n\treadonly count: number;\n\treadonly stickyCount: number;\n\treadonly isLocked: boolean;\n\treadonly activeEditor: EditorInput | null;\n\treadonly previewEditor: EditorInput | null;\n\treadonly selectedEditors: EditorInput[];\n\n\tgetEditors(order: EditorsOrder, options?: { excludeSticky?: boolean }): EditorInput[];\n\tgetEditorByIndex(index: number): EditorInput | undefined;\n\tindexOf(editor: EditorInput | IUntypedEditorInput | null, editors?: EditorInput[], options?: IMatchEditorOptions): number;\n\tisActive(editor: EditorInput | IUntypedEditorInput): boolean;\n\tisPinned(editorOrIndex: EditorInput | number): boolean;\n\tisSticky(editorOrIndex: EditorInput | number): boolean;\n\tisSelected(editorOrIndex: EditorInput | number): boolean;\n\tisTransient(editorOrIndex: EditorInput | number): boolean;\n\tisFirst(editor: EditorInput, editors?: EditorInput[]): boolean;\n\tisLast(editor: EditorInput, editors?: EditorInput[]): boolean;\n\tfindEditor(editor: EditorInput | null, options?: IMatchEditorOptions): [EditorInput, number /* index */] | undefined;\n\tcontains(editor: EditorInput | IUntypedEditorInput, options?: IMatchEditorOptions): boolean;\n}\n\ninterface IEditorGroupModel extends IReadonlyEditorGroupModel {\n\topenEditor(editor: EditorInput, options?: IEditorOpenOptions): IEditorOpenResult;\n\tcloseEditor(editor: EditorInput, context?: EditorCloseContext, openNext?: boolean): IEditorCloseResult | undefined;\n\tmoveEditor(editor: EditorInput, toIndex: number): EditorInput | undefined;\n\tsetActive(editor: EditorInput | undefined): EditorInput | undefined;\n\tsetSelection(activeSelectedEditor: EditorInput, inactiveSelectedEditors: EditorInput[]): void;\n}\n\nexport class EditorGroupModel extends Disposable implements IEditorGroupModel {\n\n\tprivate static IDS = 0;\n\n\t//#region events\n\n\tprivate readonly _onDidModelChange = this._register(new Emitter<IGroupModelChangeEvent>({ leakWarningThreshold: 500 /* increased for users with hundreds of inputs opened */ }));\n\treadonly onDidModelChange = this._onDidModelChange.event;\n\n\t//#endregion\n\n\tprivate _id: GroupIdentifier;\n\tget id(): GroupIdentifier { return this._id; }\n\n\tprivate editors: EditorInput[] = [];\n\tprivate mru: EditorInput[] = [];\n\n\tprivate readonly editorListeners = new Set<DisposableStore>();\n\n\tprivate locked = false;\n\n\tprivate selection: EditorInput[] = [];\t\t\t\t\t// editors in selected state, first one is active\n\n\tprivate get active(): EditorInput | null {\n\t\treturn this.selection[0] ?? null;\n\t}\n\n\tprivate preview: EditorInput | null = null; \t\t\t// editor in preview state\n\tprivate sticky = -1;\t\t\t\t\t\t\t\t\t// index of first editor in sticky state\n\tprivate readonly transient = new Set<EditorInput>(); \t// editors in transient state\n\n\tprivate editorOpenPositioning: ('left' | 'right' | 'first' | 'last') | undefined;\n\tprivate focusRecentEditorAfterClose: boolean | undefined;\n\n\tconstructor(\n\t\tlabelOrSerializedGroup: ISerializedEditorGroupModel | undefined,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService\n\t) {\n\t\tsuper();\n\n\t\tif (isSerializedEditorGroupModel(labelOrSerializedGroup)) {\n\t\t\tthis._id = this.deserialize(labelOrSerializedGroup);\n\t\t} else {\n\t\t\tthis._id = EditorGroupModel.IDS++;\n\t\t}\n\n\t\tthis.onConfigurationUpdated();\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tthis._register(this.configurationService.onDidChangeConfiguration(e => this.onConfigurationUpdated(e)));\n\t}\n\n\tprivate onConfigurationUpdated(e?: IConfigurationChangeEvent): void {\n\t\tif (e && !e.affectsConfiguration('workbench.editor.openPositioning') && !e.affectsConfiguration('workbench.editor.focusRecentEditorAfterClose')) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.editorOpenPositioning = this.configurationService.getValue('workbench.editor.openPositioning');\n\t\tthis.focusRecentEditorAfterClose = this.configurationService.getValue('workbench.editor.focusRecentEditorAfterClose');\n\t}\n\n\tget count(): number {\n\t\treturn this.editors.length;\n\t}\n\n\tget stickyCount(): number {\n\t\treturn this.sticky + 1;\n\t}\n\n\tgetEditors(order: EditorsOrder, options?: { excludeSticky?: boolean }): EditorInput[] {\n\t\tconst editors = order === EditorsOrder.MOST_RECENTLY_ACTIVE ? this.mru.slice(0) : this.editors.slice(0);\n\n\t\tif (options?.excludeSticky) {\n\n\t\t\t// MRU: need to check for index on each\n\t\t\tif (order === EditorsOrder.MOST_RECENTLY_ACTIVE) {\n\t\t\t\treturn editors.filter(editor => !this.isSticky(editor));\n\t\t\t}\n\n\t\t\t// Sequential: simply start after sticky index\n\t\t\treturn editors.slice(this.sticky + 1);\n\t\t}\n\n\t\treturn editors;\n\t}\n\n\tgetEditorByIndex(index: number): EditorInput | undefined {\n\t\treturn this.editors[index];\n\t}\n\n\tget activeEditor(): EditorInput | null {\n\t\treturn this.active;\n\t}\n\n\tisActive(candidate: EditorInput | IUntypedEditorInput): boolean {\n\t\treturn this.matches(this.active, candidate);\n\t}\n\n\tget previewEditor(): EditorInput | null {\n\t\treturn this.preview;\n\t}\n\n\topenEditor(candidate: EditorInput, options?: IEditorOpenOptions): IEditorOpenResult {\n\t\tconst makeSticky = options?.sticky || (typeof options?.index === 'number' && this.isSticky(options.index));\n\t\tconst makePinned = options?.pinned || options?.sticky;\n\t\tconst makeTransient = !!options?.transient;\n\t\tconst makeActive = options?.active || !this.activeEditor || (!makePinned && this.preview === this.activeEditor);\n\n\t\tconst existingEditorAndIndex = this.findEditor(candidate, options);\n\n\t\t// New editor\n\t\tif (!existingEditorAndIndex) {\n\t\t\tconst newEditor = candidate;\n\t\t\tconst indexOfActive = this.indexOf(this.active);\n\n\t\t\t// Insert into specific position\n\t\t\tlet targetIndex: number;\n\t\t\tif (options && typeof options.index === 'number') {\n\t\t\t\ttargetIndex = options.index;\n\t\t\t}\n\n\t\t\t// Insert to the BEGINNING\n\t\t\telse if (this.editorOpenPositioning === EditorOpenPositioning.FIRST) {\n\t\t\t\ttargetIndex = 0;\n\n\t\t\t\t// Always make sure targetIndex is after sticky editors\n\t\t\t\t// unless we are explicitly told to make the editor sticky\n\t\t\t\tif (!makeSticky && this.isSticky(targetIndex)) {\n\t\t\t\t\ttargetIndex = this.sticky + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Insert to the END\n\t\t\telse if (this.editorOpenPositioning === EditorOpenPositioning.LAST) {\n\t\t\t\ttargetIndex = this.editors.length;\n\t\t\t}\n\n\t\t\t// Insert to LEFT or RIGHT of active editor\n\t\t\telse {\n\n\t\t\t\t// Insert to the LEFT of active editor\n\t\t\t\tif (this.editorOpenPositioning === EditorOpenPositioning.LEFT) {\n\t\t\t\t\tif (indexOfActive === 0 || !this.editors.length) {\n\t\t\t\t\t\ttargetIndex = 0; // to the left becoming first editor in list\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttargetIndex = indexOfActive; // to the left of active editor\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Insert to the RIGHT of active editor\n\t\t\t\telse {\n\t\t\t\t\ttargetIndex = indexOfActive + 1;\n\t\t\t\t}\n\n\t\t\t\t// Always make sure targetIndex is after sticky editors\n\t\t\t\t// unless we are explicitly told to make the editor sticky\n\t\t\t\tif (!makeSticky && this.isSticky(targetIndex)) {\n\t\t\t\t\ttargetIndex = this.sticky + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If the editor becomes sticky, increment the sticky index and adjust\n\t\t\t// the targetIndex to be at the end of sticky editors unless already.\n\t\t\tif (makeSticky) {\n\t\t\t\tthis.sticky++;\n\n\t\t\t\tif (!this.isSticky(targetIndex)) {\n\t\t\t\t\ttargetIndex = this.sticky;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Insert into our list of editors if pinned or we have no preview editor\n\t\t\tif (makePinned || !this.preview) {\n\t\t\t\tthis.splice(targetIndex, false, newEditor);\n\t\t\t}\n\n\t\t\t// Handle transient\n\t\t\tif (makeTransient) {\n\t\t\t\tthis.doSetTransient(newEditor, targetIndex, true);\n\t\t\t}\n\n\t\t\t// Handle preview\n\t\t\tif (!makePinned) {\n\n\t\t\t\t// Replace existing preview with this editor if we have a preview\n\t\t\t\tif (this.preview) {\n\t\t\t\t\tconst indexOfPreview = this.indexOf(this.preview);\n\t\t\t\t\tif (targetIndex > indexOfPreview) {\n\t\t\t\t\t\ttargetIndex--; // accomodate for the fact that the preview editor closes\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.replaceEditor(this.preview, newEditor, targetIndex, !makeActive);\n\t\t\t\t}\n\n\t\t\t\tthis.preview = newEditor;\n\t\t\t}\n\n\t\t\t// Listeners\n\t\t\tthis.registerEditorListeners(newEditor);\n\n\t\t\t// Event\n\t\t\tconst event: IGroupEditorOpenEvent = {\n\t\t\t\tkind: GroupModelChangeKind.EDITOR_OPEN,\n\t\t\t\teditor: newEditor,\n\t\t\t\teditorIndex: targetIndex\n\t\t\t};\n\t\t\tthis._onDidModelChange.fire(event);\n\n\t\t\t// Handle active editor / selected editors\n\t\t\tthis.setSelection(makeActive ? newEditor : this.activeEditor, options?.inactiveSelection ?? []);\n\n\t\t\treturn {\n\t\t\t\teditor: newEditor,\n\t\t\t\tisNew: true\n\t\t\t};\n\t\t}\n\n\t\t// Existing editor\n\t\telse {\n\t\t\tconst [existingEditor, existingEditorIndex] = existingEditorAndIndex;\n\n\t\t\t// Update transient (existing editors do not turn transient if they were not before)\n\t\t\tthis.doSetTransient(existingEditor, existingEditorIndex, makeTransient === false ? false : this.isTransient(existingEditor));\n\n\t\t\t// Pin it\n\t\t\tif (makePinned) {\n\t\t\t\tthis.doPin(existingEditor, existingEditorIndex);\n\t\t\t}\n\n\t\t\t// Handle active editor / selected editors\n\t\t\tthis.setSelection(makeActive ? existingEditor : this.activeEditor, options?.inactiveSelection ?? []);\n\n\t\t\t// Respect index\n\t\t\tif (options && typeof options.index === 'number') {\n\t\t\t\tthis.moveEditor(existingEditor, options.index);\n\t\t\t}\n\n\t\t\t// Stick it (intentionally after the moveEditor call in case\n\t\t\t// the editor was already moved into the sticky range)\n\t\t\tif (makeSticky) {\n\t\t\t\tthis.doStick(existingEditor, this.indexOf(existingEditor));\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\teditor: existingEditor,\n\t\t\t\tisNew: false\n\t\t\t};\n\t\t}\n\t}\n\n\tprivate registerEditorListeners(editor: EditorInput): void {\n\t\tconst listeners = new DisposableStore();\n\t\tthis.editorListeners.add(listeners);\n\n\t\t// Re-emit disposal of editor input as our own event\n\t\tlisteners.add(Event.once(editor.onWillDispose)(() => {\n\t\t\tconst editorIndex = this.editors.indexOf(editor);\n\t\t\tif (editorIndex >= 0) {\n\t\t\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\t\t\tkind: GroupModelChangeKind.EDITOR_WILL_DISPOSE,\n\t\t\t\t\teditor,\n\t\t\t\t\teditorIndex\n\t\t\t\t};\n\t\t\t\tthis._onDidModelChange.fire(event);\n\t\t\t}\n\t\t}));\n\n\t\t// Re-Emit dirty state changes\n\t\tlisteners.add(editor.onDidChangeDirty(() => {\n\t\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\t\tkind: GroupModelChangeKind.EDITOR_DIRTY,\n\t\t\t\teditor,\n\t\t\t\teditorIndex: this.editors.indexOf(editor)\n\t\t\t};\n\t\t\tthis._onDidModelChange.fire(event);\n\t\t}));\n\n\t\t// Re-Emit label changes\n\t\tlisteners.add(editor.onDidChangeLabel(() => {\n\t\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\t\tkind: GroupModelChangeKind.EDITOR_LABEL,\n\t\t\t\teditor,\n\t\t\t\teditorIndex: this.editors.indexOf(editor)\n\t\t\t};\n\t\t\tthis._onDidModelChange.fire(event);\n\t\t}));\n\n\t\t// Re-Emit capability changes\n\t\tlisteners.add(editor.onDidChangeCapabilities(() => {\n\t\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\t\tkind: GroupModelChangeKind.EDITOR_CAPABILITIES,\n\t\t\t\teditor,\n\t\t\t\teditorIndex: this.editors.indexOf(editor)\n\t\t\t};\n\t\t\tthis._onDidModelChange.fire(event);\n\t\t}));\n\n\t\t// Clean up dispose listeners once the editor gets closed\n\t\tlisteners.add(this.onDidModelChange(event => {\n\t\t\tif (event.kind === GroupModelChangeKind.EDITOR_CLOSE && event.editor?.matches(editor)) {\n\t\t\t\tdispose(listeners);\n\t\t\t\tthis.editorListeners.delete(listeners);\n\t\t\t}\n\t\t}));\n\t}\n\n\tprivate replaceEditor(toReplace: EditorInput, replaceWith: EditorInput, replaceIndex: number, openNext = true): void {\n\t\tconst closeResult = this.doCloseEditor(toReplace, EditorCloseContext.REPLACE, openNext); // optimization to prevent multiple setActive() in one call\n\n\t\t// We want to first add the new editor into our model before emitting the close event because\n\t\t// firing the close event can trigger a dispose on the same editor that is now being added.\n\t\t// This can lead into opening a disposed editor which is not what we want.\n\t\tthis.splice(replaceIndex, false, replaceWith);\n\n\t\tif (closeResult) {\n\t\t\tconst event: IGroupEditorCloseEvent = {\n\t\t\t\tkind: GroupModelChangeKind.EDITOR_CLOSE,\n\t\t\t\t...closeResult\n\t\t\t};\n\t\t\tthis._onDidModelChange.fire(event);\n\t\t}\n\t}\n\n\tcloseEditor(candidate: EditorInput, context = EditorCloseContext.UNKNOWN, openNext = true): IEditorCloseResult | undefined {\n\t\tconst closeResult = this.doCloseEditor(candidate, context, openNext);\n\n\t\tif (closeResult) {\n\t\t\tconst event: IGroupEditorCloseEvent = {\n\t\t\t\tkind: GroupModelChangeKind.EDITOR_CLOSE,\n\t\t\t\t...closeResult\n\t\t\t};\n\t\t\tthis._onDidModelChange.fire(event);\n\n\t\t\treturn closeResult;\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate doCloseEditor(candidate: EditorInput, context: EditorCloseContext, openNext: boolean): IEditorCloseResult | undefined {\n\t\tconst index = this.indexOf(candidate);\n\t\tif (index === -1) {\n\t\t\treturn undefined; // not found\n\t\t}\n\n\t\tconst editor = this.editors[index];\n\t\tconst sticky = this.isSticky(index);\n\n\t\t// Active editor closed\n\t\tconst isActiveEditor = this.active === editor;\n\t\tif (openNext && isActiveEditor) {\n\n\t\t\t// More than one editor\n\t\t\tif (this.mru.length > 1) {\n\t\t\t\tlet newActive: EditorInput;\n\t\t\t\tif (this.focusRecentEditorAfterClose) {\n\t\t\t\t\tnewActive = this.mru[1]; // active editor is always first in MRU, so pick second editor after as new active\n\t\t\t\t} else {\n\t\t\t\t\tif (index === this.editors.length - 1) {\n\t\t\t\t\t\tnewActive = this.editors[index - 1]; // last editor is closed, pick previous as new active\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewActive = this.editors[index + 1]; // pick next editor as new active\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Select editor as active\n\t\t\t\tconst newInactiveSelectedEditors = this.selection.filter(selected => selected !== editor && selected !== newActive);\n\t\t\t\tthis.doSetSelection(newActive, this.editors.indexOf(newActive), newInactiveSelectedEditors);\n\t\t\t}\n\n\t\t\t// Last editor closed: clear selection\n\t\t\telse {\n\t\t\t\tthis.doSetSelection(null, undefined, []);\n\t\t\t}\n\t\t}\n\n\t\t// Inactive editor closed\n\t\telse if (!isActiveEditor) {\n\n\t\t\t// Remove editor from inactive selection\n\t\t\tif (this.doIsSelected(editor)) {\n\t\t\t\tconst newInactiveSelectedEditors = this.selection.filter(selected => selected !== editor && selected !== this.activeEditor);\n\t\t\t\tthis.doSetSelection(this.activeEditor, this.indexOf(this.activeEditor), newInactiveSelectedEditors);\n\t\t\t}\n\t\t}\n\n\t\t// Preview Editor closed\n\t\tif (this.preview === editor) {\n\t\t\tthis.preview = null;\n\t\t}\n\n\t\t// Remove from transient\n\t\tthis.transient.delete(editor);\n\n\t\t// Remove from arrays\n\t\tthis.splice(index, true);\n\n\t\t// Event\n\t\treturn { editor, sticky, editorIndex: index, context };\n\t}\n\n\tmoveEditor(candidate: EditorInput, toIndex: number): EditorInput | undefined {\n\n\t\t// Ensure toIndex is in bounds of our model\n\t\tif (toIndex >= this.editors.length) {\n\t\t\ttoIndex = this.editors.length - 1;\n\t\t} else if (toIndex < 0) {\n\t\t\ttoIndex = 0;\n\t\t}\n\n\t\tconst index = this.indexOf(candidate);\n\t\tif (index < 0 || toIndex === index) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst editor = this.editors[index];\n\t\tconst sticky = this.sticky;\n\n\t\t// Adjust sticky index: editor moved out of sticky state into unsticky state\n\t\tif (this.isSticky(index) && toIndex > this.sticky) {\n\t\t\tthis.sticky--;\n\t\t}\n\n\t\t// ...or editor moved into sticky state from unsticky state\n\t\telse if (!this.isSticky(index) && toIndex <= this.sticky) {\n\t\t\tthis.sticky++;\n\t\t}\n\n\t\t// Move\n\t\tthis.editors.splice(index, 1);\n\t\tthis.editors.splice(toIndex, 0, editor);\n\n\t\t// Move Event\n\t\tconst event: IGroupEditorMoveEvent = {\n\t\t\tkind: GroupModelChangeKind.EDITOR_MOVE,\n\t\t\teditor,\n\t\t\toldEditorIndex: index,\n\t\t\teditorIndex: toIndex\n\t\t};\n\t\tthis._onDidModelChange.fire(event);\n\n\t\t// Sticky Event (if sticky changed as part of the move)\n\t\tif (sticky !== this.sticky) {\n\t\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\t\tkind: GroupModelChangeKind.EDITOR_STICKY,\n\t\t\t\teditor,\n\t\t\t\teditorIndex: toIndex\n\t\t\t};\n\t\t\tthis._onDidModelChange.fire(event);\n\t\t}\n\n\t\treturn editor;\n\t}\n\n\tsetActive(candidate: EditorInput | undefined): EditorInput | undefined {\n\t\tlet result: EditorInput | undefined = undefined;\n\n\t\tif (!candidate) {\n\t\t\tthis.setGroupActive();\n\t\t} else {\n\t\t\tresult = this.setEditorActive(candidate);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate setGroupActive(): void {\n\t\t// We do not really keep the `active` state in our model because\n\t\t// it has no special meaning to us here. But for consistency\n\t\t// we emit a `onDidModelChange` event so that components can\n\t\t// react.\n\t\tthis._onDidModelChange.fire({ kind: GroupModelChangeKind.GROUP_ACTIVE });\n\t}\n\n\tprivate setEditorActive(candidate: EditorInput): EditorInput | undefined {\n\t\tconst res = this.findEditor(candidate);\n\t\tif (!res) {\n\t\t\treturn; // not found\n\t\t}\n\n\t\tconst [editor, editorIndex] = res;\n\n\t\tthis.doSetSelection(editor, editorIndex, []);\n\n\t\treturn editor;\n\t}\n\n\tget selectedEditors(): EditorInput[] {\n\t\treturn this.editors.filter(editor => this.doIsSelected(editor)); // return in sequential order\n\t}\n\n\tisSelected(editorCandidateOrIndex: EditorInput | number): boolean {\n\t\tlet editor: EditorInput | undefined;\n\t\tif (typeof editorCandidateOrIndex === 'number') {\n\t\t\teditor = this.editors[editorCandidateOrIndex];\n\t\t} else {\n\t\t\teditor = this.findEditor(editorCandidateOrIndex)?.[0];\n\t\t}\n\n\t\treturn !!editor && this.doIsSelected(editor);\n\t}\n\n\tprivate doIsSelected(editor: EditorInput): boolean {\n\t\treturn this.selection.includes(editor);\n\t}\n\n\tsetSelection(activeSelectedEditorCandidate: EditorInput, inactiveSelectedEditorCandidates: EditorInput[]): void {\n\t\tconst res = this.findEditor(activeSelectedEditorCandidate);\n\t\tif (!res) {\n\t\t\treturn; // not found\n\t\t}\n\n\t\tconst [activeSelectedEditor, activeSelectedEditorIndex] = res;\n\n\t\tconst inactiveSelectedEditors = new Set<EditorInput>();\n\t\tfor (const inactiveSelectedEditorCandidate of inactiveSelectedEditorCandidates) {\n\t\t\tconst res = this.findEditor(inactiveSelectedEditorCandidate);\n\t\t\tif (!res) {\n\t\t\t\treturn; // not found\n\t\t\t}\n\n\t\t\tconst [inactiveSelectedEditor] = res;\n\t\t\tif (inactiveSelectedEditor === activeSelectedEditor) {\n\t\t\t\tcontinue; // already selected\n\t\t\t}\n\n\t\t\tinactiveSelectedEditors.add(inactiveSelectedEditor);\n\t\t}\n\n\t\tthis.doSetSelection(activeSelectedEditor, activeSelectedEditorIndex, Array.from(inactiveSelectedEditors));\n\t}\n\n\tprivate doSetSelection(activeSelectedEditor: EditorInput | null, activeSelectedEditorIndex: number | undefined, inactiveSelectedEditors: EditorInput[]): void {\n\t\tconst previousActiveEditor = this.activeEditor;\n\t\tconst previousSelection = this.selection;\n\n\t\tlet newSelection: EditorInput[];\n\t\tif (activeSelectedEditor) {\n\t\t\tnewSelection = [activeSelectedEditor, ...inactiveSelectedEditors];\n\t\t} else {\n\t\t\tnewSelection = [];\n\t\t}\n\n\t\t// Update selection\n\t\tthis.selection = newSelection;\n\n\t\t// Update active editor if it has changed\n\t\tconst activeEditorChanged = activeSelectedEditor && typeof activeSelectedEditorIndex === 'number' && previousActiveEditor !== activeSelectedEditor;\n\t\tif (activeEditorChanged) {\n\n\t\t\t// Bring to front in MRU list\n\t\t\tconst mruIndex = this.indexOf(activeSelectedEditor, this.mru);\n\t\t\tthis.mru.splice(mruIndex, 1);\n\t\t\tthis.mru.unshift(activeSelectedEditor);\n\n\t\t\t// Event\n\t\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\t\tkind: GroupModelChangeKind.EDITOR_ACTIVE,\n\t\t\t\teditor: activeSelectedEditor,\n\t\t\t\teditorIndex: activeSelectedEditorIndex\n\t\t\t};\n\t\t\tthis._onDidModelChange.fire(event);\n\t\t}\n\n\t\t// Fire event if the selection has changed\n\t\tif (\n\t\t\tactiveEditorChanged ||\n\t\t\tpreviousSelection.length !== newSelection.length ||\n\t\t\tpreviousSelection.some(editor => !newSelection.includes(editor))\n\t\t) {\n\t\t\tconst event: IGroupModelChangeEvent = {\n\t\t\t\tkind: GroupModelChangeKind.EDITORS_SELECTION\n\t\t\t};\n\t\t\tthis._onDidModelChange.fire(event);\n\t\t}\n\t}\n\n\tsetIndex(index: number) {\n\t\t// We do not really keep the `index` in our model because\n\t\t// it has no special meaning to us here. But for consistency\n\t\t// we emit a `onDidModelChange` event so that components can\n\t\t// react.\n\t\tthis._onDidModelChange.fire({ kind: GroupModelChangeKind.GROUP_INDEX });\n\t}\n\n\tsetLabel(label: string) {\n\t\t// We do not really keep the `label` in our model because\n\t\t// it has no special meaning to us here. But for consistency\n\t\t// we emit a `onDidModelChange` event so that components can\n\t\t// react.\n\t\tthis._onDidModelChange.fire({ kind: GroupModelChangeKind.GROUP_LABEL });\n\t}\n\n\tpin(candidate: EditorInput): EditorInput | undefined {\n\t\tconst res = this.findEditor(candidate);\n\t\tif (!res) {\n\t\t\treturn; // not found\n\t\t}\n\n\t\tconst [editor, editorIndex] = res;\n\n\t\tthis.doPin(editor, editorIndex);\n\n\t\treturn editor;\n\t}\n\n\tprivate doPin(editor: EditorInput, editorIndex: number): void {\n\t\tif (this.isPinned(editor)) {\n\t\t\treturn; // can only pin a preview editor\n\t\t}\n\n\t\t// Clear Transient\n\t\tthis.setTransient(editor, false);\n\n\t\t// Convert the preview editor to be a pinned editor\n\t\tthis.preview = null;\n\n\t\t// Event\n\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\tkind: GroupModelChangeKind.EDITOR_PIN,\n\t\t\teditor,\n\t\t\teditorIndex\n\t\t};\n\t\tthis._onDidModelChange.fire(event);\n\t}\n\n\tunpin(candidate: EditorInput): EditorInput | undefined {\n\t\tconst res = this.findEditor(candidate);\n\t\tif (!res) {\n\t\t\treturn; // not found\n\t\t}\n\n\t\tconst [editor, editorIndex] = res;\n\n\t\tthis.doUnpin(editor, editorIndex);\n\n\t\treturn editor;\n\t}\n\n\tprivate doUnpin(editor: EditorInput, editorIndex: number): void {\n\t\tif (!this.isPinned(editor)) {\n\t\t\treturn; // can only unpin a pinned editor\n\t\t}\n\n\t\t// Set new\n\t\tconst oldPreview = this.preview;\n\t\tthis.preview = editor;\n\n\t\t// Event\n\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\tkind: GroupModelChangeKind.EDITOR_PIN,\n\t\t\teditor,\n\t\t\teditorIndex\n\t\t};\n\t\tthis._onDidModelChange.fire(event);\n\n\t\t// Close old preview editor if any\n\t\tif (oldPreview) {\n\t\t\tthis.closeEditor(oldPreview, EditorCloseContext.UNPIN);\n\t\t}\n\t}\n\n\tisPinned(editorCandidateOrIndex: EditorInput | number): boolean {\n\t\tlet editor: EditorInput;\n\t\tif (typeof editorCandidateOrIndex === 'number') {\n\t\t\teditor = this.editors[editorCandidateOrIndex];\n\t\t} else {\n\t\t\teditor = editorCandidateOrIndex;\n\t\t}\n\n\t\treturn !this.matches(this.preview, editor);\n\t}\n\n\tstick(candidate: EditorInput): EditorInput | undefined {\n\t\tconst res = this.findEditor(candidate);\n\t\tif (!res) {\n\t\t\treturn; // not found\n\t\t}\n\n\t\tconst [editor, editorIndex] = res;\n\n\t\tthis.doStick(editor, editorIndex);\n\n\t\treturn editor;\n\t}\n\n\tprivate doStick(editor: EditorInput, editorIndex: number): void {\n\t\tif (this.isSticky(editorIndex)) {\n\t\t\treturn; // can only stick a non-sticky editor\n\t\t}\n\n\t\t// Pin editor\n\t\tthis.pin(editor);\n\n\t\t// Move editor to be the last sticky editor\n\t\tconst newEditorIndex = this.sticky + 1;\n\t\tthis.moveEditor(editor, newEditorIndex);\n\n\t\t// Adjust sticky index\n\t\tthis.sticky++;\n\n\t\t// Event\n\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\tkind: GroupModelChangeKind.EDITOR_STICKY,\n\t\t\teditor,\n\t\t\teditorIndex: newEditorIndex\n\t\t};\n\t\tthis._onDidModelChange.fire(event);\n\t}\n\n\tunstick(candidate: EditorInput): EditorInput | undefined {\n\t\tconst res = this.findEditor(candidate);\n\t\tif (!res) {\n\t\t\treturn; // not found\n\t\t}\n\n\t\tconst [editor, editorIndex] = res;\n\n\t\tthis.doUnstick(editor, editorIndex);\n\n\t\treturn editor;\n\t}\n\n\tprivate doUnstick(editor: EditorInput, editorIndex: number): void {\n\t\tif (!this.isSticky(editorIndex)) {\n\t\t\treturn; // can only unstick a sticky editor\n\t\t}\n\n\t\t// Move editor to be the first non-sticky editor\n\t\tconst newEditorIndex = this.sticky;\n\t\tthis.moveEditor(editor, newEditorIndex);\n\n\t\t// Adjust sticky index\n\t\tthis.sticky--;\n\n\t\t// Event\n\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\tkind: GroupModelChangeKind.EDITOR_STICKY,\n\t\t\teditor,\n\t\t\teditorIndex: newEditorIndex\n\t\t};\n\t\tthis._onDidModelChange.fire(event);\n\t}\n\n\tisSticky(candidateOrIndex: EditorInput | number): boolean {\n\t\tif (this.sticky < 0) {\n\t\t\treturn false; // no sticky editor\n\t\t}\n\n\t\tlet index: number;\n\t\tif (typeof candidateOrIndex === 'number') {\n\t\t\tindex = candidateOrIndex;\n\t\t} else {\n\t\t\tindex = this.indexOf(candidateOrIndex);\n\t\t}\n\n\t\tif (index < 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn index <= this.sticky;\n\t}\n\n\tsetTransient(candidate: EditorInput, transient: boolean): EditorInput | undefined {\n\t\tif (!transient && this.transient.size === 0) {\n\t\t\treturn; // no transient editor\n\t\t}\n\n\t\tconst res = this.findEditor(candidate);\n\t\tif (!res) {\n\t\t\treturn; // not found\n\t\t}\n\n\t\tconst [editor, editorIndex] = res;\n\n\t\tthis.doSetTransient(editor, editorIndex, transient);\n\n\t\treturn editor;\n\t}\n\n\tprivate doSetTransient(editor: EditorInput, editorIndex: number, transient: boolean): void {\n\t\tif (transient) {\n\t\t\tif (this.transient.has(editor)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.transient.add(editor);\n\t\t} else {\n\t\t\tif (!this.transient.has(editor)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.transient.delete(editor);\n\t\t}\n\n\t\t// Event\n\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\tkind: GroupModelChangeKind.EDITOR_TRANSIENT,\n\t\t\teditor,\n\t\t\teditorIndex\n\t\t};\n\t\tthis._onDidModelChange.fire(event);\n\t}\n\n\tisTransient(editorCandidateOrIndex: EditorInput | number): boolean {\n\t\tif (this.transient.size === 0) {\n\t\t\treturn false; // no transient editor\n\t\t}\n\n\t\tlet editor: EditorInput | undefined;\n\t\tif (typeof editorCandidateOrIndex === 'number') {\n\t\t\teditor = this.editors[editorCandidateOrIndex];\n\t\t} else {\n\t\t\teditor = this.findEditor(editorCandidateOrIndex)?.[0];\n\t\t}\n\n\t\treturn !!editor && this.transient.has(editor);\n\t}\n\n\tprivate splice(index: number, del: boolean, editor?: EditorInput): void {\n\t\tconst editorToDeleteOrReplace = this.editors[index];\n\n\t\t// Perform on sticky index\n\t\tif (del && this.isSticky(index)) {\n\t\t\tthis.sticky--;\n\t\t}\n\n\t\t// Perform on editors array\n\t\tif (editor) {\n\t\t\tthis.editors.splice(index, del ? 1 : 0, editor);\n\t\t} else {\n\t\t\tthis.editors.splice(index, del ? 1 : 0);\n\t\t}\n\n\t\t// Perform on MRU\n\t\t{\n\t\t\t// Add\n\t\t\tif (!del && editor) {\n\t\t\t\tif (this.mru.length === 0) {\n\t\t\t\t\t// the list of most recent editors is empty\n\t\t\t\t\t// so this editor can only be the most recent\n\t\t\t\t\tthis.mru.push(editor);\n\t\t\t\t} else {\n\t\t\t\t\t// we have most recent editors. as such we\n\t\t\t\t\t// put this newly opened editor right after\n\t\t\t\t\t// the current most recent one because it cannot\n\t\t\t\t\t// be the most recently active one unless\n\t\t\t\t\t// it becomes active. but it is still more\n\t\t\t\t\t// active then any other editor in the list.\n\t\t\t\t\tthis.mru.splice(1, 0, editor);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove / Replace\n\t\t\telse {\n\t\t\t\tconst indexInMRU = this.indexOf(editorToDeleteOrReplace, this.mru);\n\n\t\t\t\t// Remove\n\t\t\t\tif (del && !editor) {\n\t\t\t\t\tthis.mru.splice(indexInMRU, 1); // remove from MRU\n\t\t\t\t}\n\n\t\t\t\t// Replace\n\t\t\t\telse if (del && editor) {\n\t\t\t\t\tthis.mru.splice(indexInMRU, 1, editor); // replace MRU at location\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tindexOf(candidate: EditorInput | IUntypedEditorInput | null, editors = this.editors, options?: IMatchEditorOptions): number {\n\t\tlet index = -1;\n\t\tif (!candidate) {\n\t\t\treturn index;\n\t\t}\n\n\t\tfor (let i = 0; i < editors.length; i++) {\n\t\t\tconst editor = editors[i];\n\n\t\t\tif (this.matches(editor, candidate, options)) {\n\t\t\t\t// If we are to support side by side matching, it is possible that\n\t\t\t\t// a better direct match is found later. As such, we continue finding\n\t\t\t\t// a matching editor and prefer that match over the side by side one.\n\t\t\t\tif (options?.supportSideBySide && editor instanceof SideBySideEditorInput && !(candidate instanceof SideBySideEditorInput)) {\n\t\t\t\t\tindex = i;\n\t\t\t\t} else {\n\t\t\t\t\tindex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn index;\n\t}\n\n\tfindEditor(candidate: EditorInput | null, options?: IMatchEditorOptions): [EditorInput, number /* index */] | undefined {\n\t\tconst index = this.indexOf(candidate, this.editors, options);\n\t\tif (index === -1) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn [this.editors[index], index];\n\t}\n\n\tisFirst(candidate: EditorInput | null, editors = this.editors): boolean {\n\t\treturn this.matches(editors[0], candidate);\n\t}\n\n\tisLast(candidate: EditorInput | null, editors = this.editors): boolean {\n\t\treturn this.matches(editors[editors.length - 1], candidate);\n\t}\n\n\tcontains(candidate: EditorInput | IUntypedEditorInput, options?: IMatchEditorOptions): boolean {\n\t\treturn this.indexOf(candidate, this.editors, options) !== -1;\n\t}\n\n\tprivate matches(editor: EditorInput | null | undefined, candidate: EditorInput | IUntypedEditorInput | null, options?: IMatchEditorOptions): boolean {\n\t\tif (!editor || !candidate) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (options?.supportSideBySide && editor instanceof SideBySideEditorInput && !(candidate instanceof SideBySideEditorInput)) {\n\t\t\tswitch (options.supportSideBySide) {\n\t\t\t\tcase SideBySideEditor.ANY:\n\t\t\t\t\tif (this.matches(editor.primary, candidate, options) || this.matches(editor.secondary, candidate, options)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SideBySideEditor.BOTH:\n\t\t\t\t\tif (this.matches(editor.primary, candidate, options) && this.matches(editor.secondary, candidate, options)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tconst strictEquals = editor === candidate;\n\n\t\tif (options?.strictEquals) {\n\t\t\treturn strictEquals;\n\t\t}\n\n\t\treturn strictEquals || editor.matches(candidate);\n\t}\n\n\tget isLocked(): boolean {\n\t\treturn this.locked;\n\t}\n\n\tlock(locked: boolean): void {\n\t\tif (this.isLocked !== locked) {\n\t\t\tthis.locked = locked;\n\n\t\t\tthis._onDidModelChange.fire({ kind: GroupModelChangeKind.GROUP_LOCKED });\n\t\t}\n\t}\n\n\tclone(): EditorGroupModel {\n\t\tconst clone = this.instantiationService.createInstance(EditorGroupModel, undefined);\n\n\t\t// Copy over group properties\n\t\tclone.editors = this.editors.slice(0);\n\t\tclone.mru = this.mru.slice(0);\n\t\tclone.preview = this.preview;\n\t\tclone.selection = this.selection.slice(0);\n\t\tclone.sticky = this.sticky;\n\n\t\t// Ensure to register listeners for each editor\n\t\tfor (const editor of clone.editors) {\n\t\t\tclone.registerEditorListeners(editor);\n\t\t}\n\n\t\treturn clone;\n\t}\n\n\tserialize(): ISerializedEditorGroupModel {\n\t\tconst registry = Registry.as<IEditorFactoryRegistry>(EditorExtensions.EditorFactory);\n\n\t\t// Serialize all editor inputs so that we can store them.\n\t\t// Editors that cannot be serialized need to be ignored\n\t\t// from mru, active, preview and sticky if any.\n\t\tconst serializableEditors: EditorInput[] = [];\n\t\tconst serializedEditors: ISerializedEditorInput[] = [];\n\t\tlet serializablePreviewIndex: number | undefined;\n\t\tlet serializableSticky = this.sticky;\n\n\t\tfor (let i = 0; i < this.editors.length; i++) {\n\t\t\tconst editor = this.editors[i];\n\t\t\tlet canSerializeEditor = false;\n\n\t\t\tconst editorSerializer = registry.getEditorSerializer(editor);\n\t\t\tif (editorSerializer) {\n\t\t\t\tconst value = editorSerializer.canSerialize(editor) ? editorSerializer.serialize(editor) : undefined;\n\n\t\t\t\t// Editor can be serialized\n\t\t\t\tif (typeof value === 'string') {\n\t\t\t\t\tcanSerializeEditor = true;\n\n\t\t\t\t\tserializedEditors.push({ id: editor.typeId, value });\n\t\t\t\t\tserializableEditors.push(editor);\n\n\t\t\t\t\tif (this.preview === editor) {\n\t\t\t\t\t\tserializablePreviewIndex = serializableEditors.length - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Editor cannot be serialized\n\t\t\t\telse {\n\t\t\t\t\tcanSerializeEditor = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Adjust index of sticky editors if the editor cannot be serialized and is pinned\n\t\t\tif (!canSerializeEditor && this.isSticky(i)) {\n\t\t\t\tserializableSticky--;\n\t\t\t}\n\t\t}\n\n\t\tconst serializableMru = this.mru.map(editor => this.indexOf(editor, serializableEditors)).filter(i => i >= 0);\n\n\t\treturn {\n\t\t\tid: this.id,\n\t\t\tlocked: this.locked ? true : undefined,\n\t\t\teditors: serializedEditors,\n\t\t\tmru: serializableMru,\n\t\t\tpreview: serializablePreviewIndex,\n\t\t\tsticky: serializableSticky >= 0 ? serializableSticky : undefined\n\t\t};\n\t}\n\n\tprivate deserialize(data: ISerializedEditorGroupModel): number {\n\t\tconst registry = Registry.as<IEditorFactoryRegistry>(EditorExtensions.EditorFactory);\n\n\t\tif (typeof data.id === 'number') {\n\t\t\tthis._id = data.id;\n\n\t\t\tEditorGroupModel.IDS = Math.max(data.id + 1, EditorGroupModel.IDS); // make sure our ID generator is always larger\n\t\t} else {\n\t\t\tthis._id = EditorGroupModel.IDS++; // backwards compatibility\n\t\t}\n\n\t\tif (data.locked) {\n\t\t\tthis.locked = true;\n\t\t}\n\n\t\tthis.editors = coalesce(data.editors.map((e, index) => {\n\t\t\tlet editor: EditorInput | undefined = undefined;\n\n\t\t\tconst editorSerializer = registry.getEditorSerializer(e.id);\n\t\t\tif (editorSerializer) {\n\t\t\t\tconst deserializedEditor = editorSerializer.deserialize(this.instantiationService, e.value);\n\t\t\t\tif (deserializedEditor instanceof EditorInput) {\n\t\t\t\t\teditor = deserializedEditor;\n\t\t\t\t\tthis.registerEditorListeners(editor);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!editor && typeof data.sticky === 'number' && index <= data.sticky) {\n\t\t\t\tdata.sticky--; // if editor cannot be deserialized but was sticky, we need to decrease sticky index\n\t\t\t}\n\n\t\t\treturn editor;\n\t\t}));\n\n\t\tthis.mru = coalesce(data.mru.map(i => this.editors[i]));\n\n\t\tthis.selection = this.mru.length > 0 ? [this.mru[0]] : [];\n\n\t\tif (typeof data.preview === 'number') {\n\t\t\tthis.preview = this.editors[data.preview];\n\t\t}\n\n\t\tif (typeof data.sticky === 'number') {\n\t\t\tthis.sticky = data.sticky;\n\t\t}\n\n\t\treturn this._id;\n\t}\n\n\toverride dispose(): void {\n\t\tdispose(Array.from(this.editorListeners));\n\t\tthis.editorListeners.clear();\n\n\t\tthis.transient.clear();\n\n\t\tsuper.dispose();\n\t}\n}\n"],
  "mappings": "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",
  "names": ["event", "res"]
}
