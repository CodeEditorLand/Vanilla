{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/workbench/browser/editor.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { localize } from '../../nls.js';\nimport { EditorResourceAccessor, EditorExtensions, SideBySideEditor, IEditorDescriptor as ICommonEditorDescriptor, EditorCloseContext, IWillInstantiateEditorPaneEvent } from '../common/editor.js';\nimport { EditorInput } from '../common/editor/editorInput.js';\nimport { SyncDescriptor } from '../../platform/instantiation/common/descriptors.js';\nimport { Registry } from '../../platform/registry/common/platform.js';\nimport { EditorPane } from './parts/editor/editorPane.js';\nimport { IConstructorSignature, IInstantiationService, BrandedService, ServicesAccessor } from '../../platform/instantiation/common/instantiation.js';\nimport { IDisposable, toDisposable } from '../../base/common/lifecycle.js';\nimport { Promises } from '../../base/common/async.js';\nimport { IEditorService } from '../services/editor/common/editorService.js';\nimport { IUriIdentityService } from '../../platform/uriIdentity/common/uriIdentity.js';\nimport { IWorkingCopyService } from '../services/workingCopy/common/workingCopyService.js';\nimport { URI } from '../../base/common/uri.js';\nimport { Schemas } from '../../base/common/network.js';\nimport { IEditorGroup } from '../services/editor/common/editorGroupsService.js';\nimport { Iterable } from '../../base/common/iterator.js';\nimport { Emitter } from '../../base/common/event.js';\n\n//#region Editor Pane Registry\n\nexport interface IEditorPaneDescriptor extends ICommonEditorDescriptor<EditorPane> { }\n\nexport interface IEditorPaneRegistry {\n\n\t/**\n\t * Registers an editor pane to the platform for the given editor type. The second parameter also supports an\n\t * array of input classes to be passed in. If the more than one editor is registered for the same editor\n\t * input, the input itself will be asked which editor it prefers if this method is provided. Otherwise\n\t * the first editor in the list will be returned.\n\t *\n\t * @param editorDescriptors A set of constructor functions that return an instance of `EditorInput` for which the\n\t * registered editor should be used for.\n\t */\n\tregisterEditorPane(editorPaneDescriptor: IEditorPaneDescriptor, editorDescriptors: readonly SyncDescriptor<EditorInput>[]): IDisposable;\n\n\t/**\n\t * Returns the editor pane descriptor for the given editor or `undefined` if none.\n\t */\n\tgetEditorPane(editor: EditorInput): IEditorPaneDescriptor | undefined;\n}\n\n/**\n * A lightweight descriptor of an editor pane. The descriptor is deferred so that heavy editor\n * panes can load lazily in the workbench.\n */\nexport class EditorPaneDescriptor implements IEditorPaneDescriptor {\n\n\tprivate static readonly instantiatedEditorPanes = new Set<string>();\n\tstatic didInstantiateEditorPane(typeId: string): boolean {\n\t\treturn EditorPaneDescriptor.instantiatedEditorPanes.has(typeId);\n\t}\n\n\tprivate static readonly _onWillInstantiateEditorPane = new Emitter<IWillInstantiateEditorPaneEvent>();\n\tstatic readonly onWillInstantiateEditorPane = EditorPaneDescriptor._onWillInstantiateEditorPane.event;\n\n\tstatic create<Services extends BrandedService[]>(\n\t\tctor: { new(group: IEditorGroup, ...services: Services): EditorPane },\n\t\ttypeId: string,\n\t\tname: string\n\t): EditorPaneDescriptor {\n\t\treturn new EditorPaneDescriptor(ctor as IConstructorSignature<EditorPane, [IEditorGroup]>, typeId, name);\n\t}\n\n\tprivate constructor(\n\t\tprivate readonly ctor: IConstructorSignature<EditorPane, [IEditorGroup]>,\n\t\treadonly typeId: string,\n\t\treadonly name: string\n\t) { }\n\n\tinstantiate(instantiationService: IInstantiationService, group: IEditorGroup): EditorPane {\n\t\tEditorPaneDescriptor._onWillInstantiateEditorPane.fire({ typeId: this.typeId });\n\n\t\tconst pane = instantiationService.createInstance(this.ctor, group);\n\t\tEditorPaneDescriptor.instantiatedEditorPanes.add(this.typeId);\n\n\t\treturn pane;\n\t}\n\n\tdescribes(editorPane: EditorPane): boolean {\n\t\treturn editorPane.getId() === this.typeId;\n\t}\n}\n\nexport class EditorPaneRegistry implements IEditorPaneRegistry {\n\n\tprivate readonly mapEditorPanesToEditors = new Map<EditorPaneDescriptor, readonly SyncDescriptor<EditorInput>[]>();\n\n\tregisterEditorPane(editorPaneDescriptor: EditorPaneDescriptor, editorDescriptors: readonly SyncDescriptor<EditorInput>[]): IDisposable {\n\t\tthis.mapEditorPanesToEditors.set(editorPaneDescriptor, editorDescriptors);\n\n\t\treturn toDisposable(() => {\n\t\t\tthis.mapEditorPanesToEditors.delete(editorPaneDescriptor);\n\t\t});\n\t}\n\n\tgetEditorPane(editor: EditorInput): EditorPaneDescriptor | undefined {\n\t\tconst descriptors = this.findEditorPaneDescriptors(editor);\n\n\t\tif (descriptors.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (descriptors.length === 1) {\n\t\t\treturn descriptors[0];\n\t\t}\n\n\t\treturn editor.prefersEditorPane(descriptors);\n\t}\n\n\tprivate findEditorPaneDescriptors(editor: EditorInput, byInstanceOf?: boolean): EditorPaneDescriptor[] {\n\t\tconst matchingEditorPaneDescriptors: EditorPaneDescriptor[] = [];\n\n\t\tfor (const editorPane of this.mapEditorPanesToEditors.keys()) {\n\t\t\tconst editorDescriptors = this.mapEditorPanesToEditors.get(editorPane) || [];\n\t\t\tfor (const editorDescriptor of editorDescriptors) {\n\t\t\t\tconst editorClass = editorDescriptor.ctor;\n\n\t\t\t\t// Direct check on constructor type (ignores prototype chain)\n\t\t\t\tif (!byInstanceOf && editor.constructor === editorClass) {\n\t\t\t\t\tmatchingEditorPaneDescriptors.push(editorPane);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Normal instanceof check\n\t\t\t\telse if (byInstanceOf && editor instanceof editorClass) {\n\t\t\t\t\tmatchingEditorPaneDescriptors.push(editorPane);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If no descriptors found, continue search using instanceof and prototype chain\n\t\tif (!byInstanceOf && matchingEditorPaneDescriptors.length === 0) {\n\t\t\treturn this.findEditorPaneDescriptors(editor, true);\n\t\t}\n\n\t\treturn matchingEditorPaneDescriptors;\n\t}\n\n\t//#region Used for tests only\n\n\tgetEditorPaneByType(typeId: string): EditorPaneDescriptor | undefined {\n\t\treturn Iterable.find(this.mapEditorPanesToEditors.keys(), editor => editor.typeId === typeId);\n\t}\n\n\tgetEditorPanes(): readonly EditorPaneDescriptor[] {\n\t\treturn Array.from(this.mapEditorPanesToEditors.keys());\n\t}\n\n\tgetEditors(): SyncDescriptor<EditorInput>[] {\n\t\tconst editorClasses: SyncDescriptor<EditorInput>[] = [];\n\t\tfor (const editorPane of this.mapEditorPanesToEditors.keys()) {\n\t\t\tconst editorDescriptors = this.mapEditorPanesToEditors.get(editorPane);\n\t\t\tif (editorDescriptors) {\n\t\t\t\teditorClasses.push(...editorDescriptors.map(editorDescriptor => editorDescriptor.ctor));\n\t\t\t}\n\t\t}\n\n\t\treturn editorClasses;\n\t}\n\n\t//#endregion\n}\n\nRegistry.add(EditorExtensions.EditorPane, new EditorPaneRegistry());\n\n//#endregion\n\n//#region Editor Close Tracker\n\nexport function whenEditorClosed(accessor: ServicesAccessor, resources: URI[]): Promise<void> {\n\tconst editorService = accessor.get(IEditorService);\n\tconst uriIdentityService = accessor.get(IUriIdentityService);\n\tconst workingCopyService = accessor.get(IWorkingCopyService);\n\n\treturn new Promise(resolve => {\n\t\tlet remainingResources = [...resources];\n\n\t\t// Observe any editor closing from this moment on\n\t\tconst listener = editorService.onDidCloseEditor(async event => {\n\t\t\tif (event.context === EditorCloseContext.MOVE) {\n\t\t\t\treturn; // ignore move events where the editor will open in another group\n\t\t\t}\n\n\t\t\tlet primaryResource = EditorResourceAccessor.getOriginalUri(event.editor, { supportSideBySide: SideBySideEditor.PRIMARY });\n\t\t\tlet secondaryResource = EditorResourceAccessor.getOriginalUri(event.editor, { supportSideBySide: SideBySideEditor.SECONDARY });\n\n\t\t\t// Specially handle an editor getting replaced: if the new active editor\n\t\t\t// matches any of the resources from the closed editor, ignore those\n\t\t\t// resources because they were actually not closed, but replaced.\n\t\t\t// (see https://github.com/microsoft/vscode/issues/134299)\n\t\t\tif (event.context === EditorCloseContext.REPLACE) {\n\t\t\t\tconst newPrimaryResource = EditorResourceAccessor.getOriginalUri(editorService.activeEditor, { supportSideBySide: SideBySideEditor.PRIMARY });\n\t\t\t\tconst newSecondaryResource = EditorResourceAccessor.getOriginalUri(editorService.activeEditor, { supportSideBySide: SideBySideEditor.SECONDARY });\n\n\t\t\t\tif (uriIdentityService.extUri.isEqual(primaryResource, newPrimaryResource)) {\n\t\t\t\t\tprimaryResource = undefined;\n\t\t\t\t}\n\n\t\t\t\tif (uriIdentityService.extUri.isEqual(secondaryResource, newSecondaryResource)) {\n\t\t\t\t\tsecondaryResource = undefined;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove from resources to wait for being closed based on the\n\t\t\t// resources from editors that got closed\n\t\t\tremainingResources = remainingResources.filter(resource => {\n\n\t\t\t\t// Closing editor matches resource directly: remove from remaining\n\t\t\t\tif (uriIdentityService.extUri.isEqual(resource, primaryResource) || uriIdentityService.extUri.isEqual(resource, secondaryResource)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Closing editor is untitled with associated resource\n\t\t\t\t// that matches resource directly: remove from remaining\n\t\t\t\t// but only if the editor was not replaced, otherwise\n\t\t\t\t// saving an untitled with associated resource would\n\t\t\t\t// release the `--wait` call.\n\t\t\t\t// (see https://github.com/microsoft/vscode/issues/141237)\n\t\t\t\tif (event.context !== EditorCloseContext.REPLACE) {\n\t\t\t\t\tif (\n\t\t\t\t\t\t(primaryResource?.scheme === Schemas.untitled && uriIdentityService.extUri.isEqual(resource, primaryResource.with({ scheme: resource.scheme }))) ||\n\t\t\t\t\t\t(secondaryResource?.scheme === Schemas.untitled && uriIdentityService.extUri.isEqual(resource, secondaryResource.with({ scheme: resource.scheme })))\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Editor is not yet closed, so keep it in waiting mode\n\t\t\t\treturn true;\n\t\t\t});\n\n\t\t\t// All resources to wait for being closed are closed\n\t\t\tif (remainingResources.length === 0) {\n\n\t\t\t\t// If auto save is configured with the default delay (1s) it is possible\n\t\t\t\t// to close the editor while the save still continues in the background. As such\n\t\t\t\t// we have to also check if the editors to track for are dirty and if so wait\n\t\t\t\t// for them to get saved.\n\t\t\t\tconst dirtyResources = resources.filter(resource => workingCopyService.isDirty(resource));\n\t\t\t\tif (dirtyResources.length > 0) {\n\t\t\t\t\tawait Promises.settled(dirtyResources.map(async resource => await new Promise<void>(resolve => {\n\t\t\t\t\t\tif (!workingCopyService.isDirty(resource)) {\n\t\t\t\t\t\t\treturn resolve(); // return early if resource is not dirty\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Otherwise resolve promise when resource is saved\n\t\t\t\t\t\tconst listener = workingCopyService.onDidChangeDirty(workingCopy => {\n\t\t\t\t\t\t\tif (!workingCopy.isDirty() && uriIdentityService.extUri.isEqual(resource, workingCopy.resource)) {\n\t\t\t\t\t\t\t\tlistener.dispose();\n\n\t\t\t\t\t\t\t\treturn resolve();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t})));\n\t\t\t\t}\n\n\t\t\t\tlistener.dispose();\n\n\t\t\t\treturn resolve();\n\t\t\t}\n\t\t});\n\t});\n}\n\n//#endregion\n\n//#region ARIA\n\nexport function computeEditorAriaLabel(input: EditorInput, index: number | undefined, group: IEditorGroup | undefined, groupCount: number | undefined): string {\n\tlet ariaLabel = input.getAriaLabel();\n\tif (group && !group.isPinned(input)) {\n\t\tariaLabel = localize('preview', \"{0}, preview\", ariaLabel);\n\t}\n\n\tif (group?.isSticky(index ?? input)) {\n\t\tariaLabel = localize('pinned', \"{0}, pinned\", ariaLabel);\n\t}\n\n\t// Apply group information to help identify in\n\t// which group we are (only if more than one group\n\t// is actually opened)\n\tif (group && typeof groupCount === 'number' && groupCount > 1) {\n\t\tariaLabel = `${ariaLabel}, ${group.ariaLabel}`;\n\t}\n\n\treturn ariaLabel;\n}\n\n//#endregion\n"],
  "mappings": "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",
  "names": ["resolve", "listener"]
}
