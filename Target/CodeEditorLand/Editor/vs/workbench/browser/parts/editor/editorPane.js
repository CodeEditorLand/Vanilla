import{getWindowById as S}from"../../../../base/browser/dom.js";import{Emitter as g,Event as m}from"../../../../base/common/event.js";import{indexOfPath as v}from"../../../../base/common/extpath.js";import{Disposable as T}from"../../../../base/common/lifecycle.js";import{LRUCache as y,Touch as R}from"../../../../base/common/map.js";import{isEqual as M,joinPath as D}from"../../../../base/common/resources.js";import{isEmptyObject as h}from"../../../../base/common/types.js";import{URI as C}from"../../../../base/common/uri.js";import{StorageScope as b,StorageTarget as G}from"../../../../platform/storage/common/storage.js";import{isEditorInput as u}from"../../../common/editor.js";import{Composite as O}from"../../composite.js";import{DEFAULT_EDITOR_MAX_DIMENSIONS as f,DEFAULT_EDITOR_MIN_DIMENSIONS as I}from"./editor.js";class a extends O{constructor(e,t,r,o,n){super(e,r,o,n);this.group=t}onDidChangeSizeConstraints=m.None;_onDidChangeControl=this._register(new g);onDidChangeControl=this._onDidChangeControl.event;static EDITOR_MEMENTOS=new Map;get minimumWidth(){return I.width}get maximumWidth(){return f.width}get minimumHeight(){return I.height}get maximumHeight(){return f.height}_input;get input(){return this._input}_options;get options(){return this._options}get window(){return S(this.group.windowId,!0).window}get scopedContextKeyService(){}create(e){super.create(e),this.createEditor(e)}async setInput(e,t,r,o){this._input=e,this._options=t}clearInput(){this._input=void 0,this._options=void 0}setOptions(e){this._options=e}setVisible(e){super.setVisible(e),this.setEditorVisible(e)}setEditorVisible(e){}setBoundarySashes(e){}getEditorMemento(e,t,r,o=10){const n=`${this.getId()}${r}`;let i=a.EDITOR_MEMENTOS.get(n);return i||(i=this._register(new s(this.getId(),r,this.getMemento(b.WORKSPACE,G.MACHINE),o,e,t)),a.EDITOR_MEMENTOS.set(n,i)),i}getViewState(){}saveState(){for(const[,e]of a.EDITOR_MEMENTOS)e.id===this.getId()&&e.saveState();super.saveState()}dispose(){this._input=void 0,this._options=void 0,super.dispose()}}class s extends T{constructor(e,t,r,o,n,i){super();this.id=e;this.key=t;this.memento=r;this.limit=o;this.editorGroupService=n;this.configurationService=i;this.updateConfiguration(void 0),this.registerListeners()}static SHARED_EDITOR_STATE=-1;cache;cleanedUp=!1;editorDisposables;shareEditorState=!1;registerListeners(){this._register(this.configurationService.onDidChangeConfiguration(e=>this.updateConfiguration(e)))}updateConfiguration(e){(!e||e.affectsConfiguration(void 0,"workbench.editor.sharedViewState"))&&(this.shareEditorState=this.configurationService.getValue(void 0,"workbench.editor.sharedViewState")===!0)}saveEditorState(e,t,r){const o=this.doGetResource(t);if(!o||!e)return;const n=this.doLoad();let i=n.get(o.toString());i||(i=Object.create(null),n.set(o.toString(),i)),i[e.id]=r,this.shareEditorState&&(i[s.SHARED_EDITOR_STATE]=r),u(t)&&this.clearEditorStateOnDispose(o,t)}loadEditorState(e,t){const r=this.doGetResource(t);if(!r||!e)return;const n=this.doLoad().get(r.toString());if(n){const i=n[e.id];if(i)return i;if(this.shareEditorState)return n[s.SHARED_EDITOR_STATE]}}clearEditorState(e,t){u(e)&&this.editorDisposables?.delete(e);const r=this.doGetResource(e);if(r){const o=this.doLoad();if(t){const n=o.get(r.toString());n&&(delete n[t.id],h(n)&&o.delete(r.toString()))}else o.delete(r.toString())}}clearEditorStateOnDispose(e,t){this.editorDisposables||(this.editorDisposables=new Map),this.editorDisposables.has(t)||this.editorDisposables.set(t,m.once(t.onWillDispose)(()=>{this.clearEditorState(e),this.editorDisposables?.delete(t)}))}moveEditorState(e,t,r){const o=this.doLoad(),n=[...o.keys()];for(const i of n){const d=C.parse(i);if(!r.isEqualOrParent(d,e))continue;let p;if(M(e,d))p=t;else{const l=v(d.path,e.path);p=D(t,d.path.substr(l+e.path.length+1))}const c=o.get(i,R.None);c&&(o.delete(i),o.set(p.toString(),c))}}doGetResource(e){return u(e)?e.resource:e}doLoad(){if(!this.cache){this.cache=new y(this.limit);const e=this.memento[this.key];Array.isArray(e)&&this.cache.fromJSON(e)}return this.cache}saveState(){const e=this.doLoad();this.cleanedUp||(this.cleanUp(),this.cleanedUp=!0),this.memento[this.key]=e.toJSON()}cleanUp(){const e=this.doLoad(),t=[...e.entries()];for(const[r,o]of t)for(const n of Object.keys(o)){const i=Number(n);i===s.SHARED_EDITOR_STATE&&this.shareEditorState||this.editorGroupService.getGroup(i)||(delete o[i],h(o)&&e.delete(r))}}}export{s as EditorMemento,a as EditorPane};
