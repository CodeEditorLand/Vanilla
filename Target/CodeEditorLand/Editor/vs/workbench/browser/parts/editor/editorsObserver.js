var G=Object.defineProperty;var S=Object.getOwnPropertyDescriptor;var v=(f,c,e,i)=>{for(var t=i>1?void 0:i?S(c,e):c,r=f.length-1,o;r>=0;r--)(o=f[r])&&(t=(i?o(c,e,t):o(t))||t);return i&&t&&G(c,e,t),t},l=(f,c)=>(e,i)=>c(e,i,f);import{EditorExtensions as R,EditorsOrder as E,GroupModelChangeKind as m,EditorInputCapabilities as g}from"../../../common/editor.js";import{SideBySideEditorInput as C}from"../../../common/editor/sideBySideEditorInput.js";import{dispose as y,Disposable as M,DisposableStore as O}from"../../../../base/common/lifecycle.js";import{IStorageService as A,StorageScope as h,StorageTarget as T}from"../../../../platform/storage/common/storage.js";import{Registry as P}from"../../../../platform/registry/common/platform.js";import{Event as L,Emitter as b}from"../../../../base/common/event.js";import{IEditorGroupsService as D,GroupsOrder as z}from"../../../services/editor/common/editorGroupsService.js";import{coalesce as _}from"../../../../base/common/arrays.js";import{LinkedMap as w,Touch as I,ResourceMap as k}from"../../../../base/common/map.js";import{equals as K}from"../../../../base/common/objects.js";let u=class extends M{constructor(e,i,t){super();this.editorGroupService=i;this.storageService=t;this.editorGroupsContainer=e??i,this.isScoped=!!e,this.registerListeners(),this.loadState()}static STORAGE_KEY="editors.mru";keyMap=new Map;mostRecentEditorsMap=new w;editorsPerResourceCounter=new k;_onDidMostRecentlyActiveEditorsChange=this._register(new b);onDidMostRecentlyActiveEditorsChange=this._onDidMostRecentlyActiveEditorsChange.event;get count(){return this.mostRecentEditorsMap.size}get editors(){return[...this.mostRecentEditorsMap.values()]}hasEditor(e){return this.editorsPerResourceCounter.get(e.resource)?.has(this.toIdentifier(e))??!1}hasEditors(e){return this.editorsPerResourceCounter.has(e)}toIdentifier(e,i){return typeof e!="string"?this.toIdentifier(e.typeId,e.editorId):i?`${e}/${i}`:e}editorGroupsContainer;isScoped;registerListeners(){this._register(this.editorGroupsContainer.onDidAddGroup(e=>this.onGroupAdded(e))),this._register(this.editorGroupService.onDidChangeEditorPartOptions(e=>this.onDidChangeEditorPartOptions(e))),this._register(this.storageService.onWillSaveState(()=>this.saveState()))}onGroupAdded(e){const i=e.getEditors(E.MOST_RECENTLY_ACTIVE);for(let t=i.length-1;t>=0;t--)this.addMostRecentEditor(e,i[t],!1,!0);this.editorGroupsContainer.activeGroup===e&&e.activeEditor&&this.addMostRecentEditor(e,e.activeEditor,!0,!1),this.registerGroupListeners(e)}registerGroupListeners(e){const i=new O;i.add(e.onDidModelChange(t=>{switch(t.kind){case m.GROUP_ACTIVE:{this.editorGroupsContainer.activeGroup===e&&e.activeEditor&&this.addMostRecentEditor(e,e.activeEditor,!0,!1);break}case m.EDITOR_OPEN:{t.editor&&(this.addMostRecentEditor(e,t.editor,!1,!0),this.ensureOpenedEditorsLimit({groupId:e.id,editor:t.editor},e.id));break}}})),i.add(e.onDidCloseEditor(t=>{this.removeMostRecentEditor(e,t.editor)})),i.add(e.onDidActiveEditorChange(t=>{t.editor&&this.addMostRecentEditor(e,t.editor,this.editorGroupsContainer.activeGroup===e,!1)})),L.once(e.onWillDispose)(()=>y(i))}onDidChangeEditorPartOptions(e){if(!K(e.newPartOptions.limit,e.oldPartOptions.limit)){const i=this.editorGroupsContainer.activeGroup;let t;i.activeEditor&&(t={editor:i.activeEditor,groupId:i.id}),this.ensureOpenedEditorsLimit(t)}}addMostRecentEditor(e,i,t,r){const o=this.ensureKey(e,i),s=this.mostRecentEditorsMap.first;t||!s?this.mostRecentEditorsMap.set(o,o,s?I.AsOld:void 0):(this.mostRecentEditorsMap.set(o,o,I.AsOld),this.mostRecentEditorsMap.set(s,s,I.AsOld)),r&&this.updateEditorResourcesMap(i,!0),this._onDidMostRecentlyActiveEditorsChange.fire()}updateEditorResourcesMap(e,i){let t,r,o;if(e instanceof C?(t=e.primary.resource,r=e.primary.typeId,o=e.primary.editorId):(t=e.resource,r=e.typeId,o=e.editorId),!t)return;const s=this.toIdentifier(r,o);if(i){let n=this.editorsPerResourceCounter.get(t);n||(n=new Map,this.editorsPerResourceCounter.set(t,n)),n.set(s,(n.get(s)??0)+1)}else{const n=this.editorsPerResourceCounter.get(t);if(n){const d=n.get(s)??0;d>1?n.set(s,d-1):(n.delete(s),n.size===0&&this.editorsPerResourceCounter.delete(t))}}}removeMostRecentEditor(e,i){this.updateEditorResourcesMap(i,!1);const t=this.findKey(e,i);if(t){this.mostRecentEditorsMap.delete(t);const r=this.keyMap.get(e.id);r&&r.delete(t.editor)&&r.size===0&&this.keyMap.delete(e.id),this._onDidMostRecentlyActiveEditorsChange.fire()}}findKey(e,i){const t=this.keyMap.get(e.id);if(t)return t.get(i)}ensureKey(e,i){let t=this.keyMap.get(e.id);t||(t=new Map,this.keyMap.set(e.id,t));let r=t.get(i);return r||(r={groupId:e.id,editor:i},t.set(i,r)),r}async ensureOpenedEditorsLimit(e,i){if(!this.editorGroupService.partOptions.limit?.enabled||typeof this.editorGroupService.partOptions.limit.value!="number"||this.editorGroupService.partOptions.limit.value<=0)return;const t=this.editorGroupService.partOptions.limit.value;if(this.editorGroupService.partOptions.limit?.perEditorGroup)if(typeof i=="number"){const r=this.editorGroupsContainer.getGroup(i);r&&await this.doEnsureOpenedEditorsLimit(t,r.getEditors(E.MOST_RECENTLY_ACTIVE).map(o=>({editor:o,groupId:i})),e)}else for(const r of this.editorGroupsContainer.groups)await this.ensureOpenedEditorsLimit(e,r.id);else await this.doEnsureOpenedEditorsLimit(t,[...this.mostRecentEditorsMap.values()],e)}async doEnsureOpenedEditorsLimit(e,i,t){let r;if(this.editorGroupService.partOptions.limit?.excludeDirty?r=i.filter(({editor:d})=>!(d.isDirty()&&!d.isSaving()||d.hasCapability(g.Scratchpad))):r=i,e>=r.length)return;const o=r.reverse().filter(({editor:d,groupId:a})=>!(d.isDirty()&&!d.isSaving()||d.hasCapability(g.Scratchpad)||t&&d===t.editor&&a===t.groupId||this.editorGroupsContainer.getGroup(a)?.isSticky(d)));let s=r.length-e;const n=new Map;for(const{groupId:d,editor:a}of o){let p=n.get(d);if(p||(p=[],n.set(d,p)),p.push(a),s--,s===0)break}for(const[d,a]of n){const p=this.editorGroupsContainer.getGroup(d);p&&await p.closeEditors(a,{preserveFocus:!0})}}saveState(){this.isScoped||(this.mostRecentEditorsMap.isEmpty()?this.storageService.remove(u.STORAGE_KEY,h.WORKSPACE):this.storageService.store(u.STORAGE_KEY,JSON.stringify(this.serialize()),h.WORKSPACE,T.MACHINE))}serialize(){const e=P.as(R.EditorFactory),i=[...this.mostRecentEditorsMap.values()],t=new Map;return{entries:_(i.map(({editor:r,groupId:o})=>{const s=this.editorGroupsContainer.getGroup(o);if(!s)return;let n=t.get(s);n||(n=s.getEditors(E.SEQUENTIAL).filter(a=>e.getEditorSerializer(a)?.canSerialize(a)),t.set(s,n));const d=n.indexOf(r);if(d!==-1)return{groupId:o,index:d}}))}}async loadState(){(this.editorGroupsContainer===this.editorGroupService.mainPart||this.editorGroupsContainer===this.editorGroupService)&&await this.editorGroupService.whenReady;let e=!1;if(!this.isScoped){const i=this.storageService.get(u.STORAGE_KEY,h.WORKSPACE);i&&(e=!0,this.deserialize(JSON.parse(i)))}if(!e){const i=this.editorGroupsContainer.getGroups(z.MOST_RECENTLY_ACTIVE);for(let t=i.length-1;t>=0;t--){const r=i[t],o=r.getEditors(E.MOST_RECENTLY_ACTIVE);for(let s=o.length-1;s>=0;s--)this.addMostRecentEditor(r,o[s],!0,!0)}}for(const i of this.editorGroupsContainer.groups)this.registerGroupListeners(i)}deserialize(e){const i=[];for(const{groupId:t,index:r}of e.entries){const o=this.editorGroupsContainer.getGroup(t);if(!o)continue;const s=o.getEditorByIndex(r);if(!s)continue;const n=this.ensureKey(o,s);i.push([n,n]),this.updateEditorResourcesMap(s,!0)}this.mostRecentEditorsMap.fromJSON(i)}};u=v([l(1,D),l(2,A)],u);export{u as EditorsObserver};
