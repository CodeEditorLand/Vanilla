import{spawn as $}from"child_process";import{chmodSync as D,existsSync as I,readFileSync as q,statSync as R,truncateSync as B,unlinkSync as M}from"fs";import{homedir as W,release as G,tmpdir as z}from"os";import{Event as g}from"../../base/common/event.js";import{isAbsolute as L,resolve as J,join as k,dirname as _}from"../../base/common/path.js";import{isMacintosh as K,isWindows as y}from"../../base/common/platform.js";import{randomPort as Q}from"../../base/common/ports.js";import{whenDeleted as U,writeFileSync as P}from"../../base/node/pfs.js";import{findFreePort as T}from"../../base/node/ports.js";import{watchFileContents as X}from"../../platform/files/node/watcher/nodejs/nodejsWatcherLib.js";import"../../platform/environment/common/argv.js";import{buildHelpMessage as Y,buildVersionMessage as Z,NATIVE_CLI_COMMANDS as ee,OPTIONS as te}from"../../platform/environment/node/argv.js";import{addArg as d,parseCLIProcessArgv as oe}from"../../platform/environment/node/argvHelper.js";import{getStdinFilePath as re,hasStdinWithoutTty as ie,readFromStdin as se,stdinDataListener as ne}from"../../platform/environment/node/stdin.js";import{createWaitMarkerFileSync as ae}from"../../platform/environment/node/wait.js";import c from"../../platform/product/common/product.js";import{CancellationTokenSource as le}from"../../base/common/cancellation.js";import{isUNC as ce,randomPath as H}from"../../base/common/extpath.js";import{Utils as pe}from"../../platform/profiling/common/profiling.js";import{FileAccess as fe}from"../../base/common/network.js";import{cwd as me}from"../../base/common/process.js";import{addUNCHostToAllowlist as de}from"../../base/node/unc.js";import{URI as ue}from"../../base/common/uri.js";import{DeferredPromise as he}from"../../base/common/async.js";function we(o){return!!o["install-source"]||!!o["list-extensions"]||!!o["install-extension"]||!!o["uninstall-extension"]||!!o["update-extensions"]||!!o["locate-extension"]||!!o.telemetry}async function ge(o){let r;try{r=oe(o)}catch(t){console.error(t.message);return}for(const t of ee)if(r[t]){if(!c.tunnelApplicationName){console.error(`'${t}' command not supported in ${c.applicationName}`);return}const s={...process.env};delete s.ELECTRON_RUN_AS_NODE;const n=o.slice(o.indexOf(t)+1);return new Promise((l,u)=>{let p;const h=["ignore","pipe","pipe"];if(process.env.VSCODE_DEV)p=$("cargo",["run","--",t,...n],{cwd:k(V(),"cli"),stdio:h,env:s});else{const b=process.platform==="darwin"?k(_(_(process.execPath)),"Resources","app"):_(process.execPath),e=k(b,"bin",`${c.tunnelApplicationName}${y?".exe":""}`);p=$(e,[t,...n],{cwd:me(),stdio:h,env:s})}p.stdout.pipe(process.stdout),p.stderr.pipe(process.stderr),p.on("exit",l),p.on("error",u)})}if(r.help){const t=`${c.applicationName}${y?".exe":""}`;console.log(Y(c.nameLong,t,c.version,te))}else if(r.version)console.log(Z(c.version,c.commit));else if(r["locate-shell-integration-path"]){let t;switch(r["locate-shell-integration-path"]){case"bash":t="shellIntegration-bash.sh";break;case"pwsh":t="shellIntegration.ps1";break;case"zsh":t="shellIntegration-rc.zsh";break;case"fish":t="fish_xdg_data/fish/vendor_conf.d/shellIntegration.fish";break;default:throw new Error("Error using --locate-shell-integration-path: Invalid shell type")}console.log(k(V(),"out","vs","workbench","contrib","terminal","common","scripts",t))}else if(we(r)){await(await import(["./cliProcessMain.js"].join("/"))).main(r);return}else if(r["file-write"]){const t=r._[0],s=r._[1];if(y)for(const n of[t,s])ce(n)&&de(ue.file(n).authority);if(!t||!s||t===s||!L(t)||!L(s)||!I(t)||!R(t).isFile()||!I(s)||!R(s).isFile())throw new Error("Using --file-write with invalid arguments.");try{let n=0,l=!1;r["file-chmod"]&&(n=R(s).mode,n&128||(D(s,n|128),l=!0));const u=q(t);y?(B(s,0),P(s,u,{flag:"r+"})):P(s,u),l&&D(s,n)}catch(n){throw n.message=`Error using --file-write: ${n.message}`,n}}else{const t={...process.env,ELECTRON_NO_ATTACH_CONSOLE:"1"};delete t.ELECTRON_RUN_AS_NODE;const s=[];r.verbose&&(t.ELECTRON_ENABLE_LOGGING="1"),(r.verbose||r.status)&&s.push(async e=>{e.stdout?.on("data",i=>console.log(i.toString("utf8").trim())),e.stderr?.on("data",i=>console.log(i.toString("utf8").trim())),await g.toPromise(g.fromNodeEventEmitter(e,"exit"))});const n=r._.some(e=>e==="-");n&&(r._=r._.filter(e=>e!=="-"),o=o.filter(e=>e!=="-"));let l;if(ie())if(n){l=re();try{const e=new he;await se(l,!!r.verbose,()=>e.complete()),r.wait||s.push(()=>e.p),d(o,l),d(o,"--skip-add-to-recently-opened"),console.log(`Reading from stdin via: ${l}`)}catch(e){console.log(`Failed to create file to read via stdin: ${e.toString()}`),l=void 0}}else s.push(e=>ne(1e3).then(i=>{i&&console.log(y?`Run with '${c.applicationName} -' to read output from another program (e.g. 'echo Hello World | ${c.applicationName} -').`:`Run with '${c.applicationName} -' to read from stdin (e.g. 'ps aux | grep code | ${c.applicationName} -').`)}));const u=K&&G()>"20.0.0";let p;if(r.wait&&(p=ae(r.verbose),p&&d(o,"--waitMarkerFilePath",p),s.push(async e=>{let i;u?i=new Promise(a=>{e.on("exit",(w,f)=>{(w!==0||f)&&a()})}):i=g.toPromise(g.fromNodeEventEmitter(e,"exit"));try{await Promise.race([U(p),g.toPromise(g.fromNodeEventEmitter(e,"error")),i])}finally{l&&M(l)}})),r["prof-startup"]){const e="127.0.0.1",i=await T(Q(),10,3e3),a=await T(i+1,10,3e3),w=await T(a+1,10,3e3);if(i*a*w===0)throw new Error("Failed to find free ports for profiler. Make sure to shutdown all instances of the editor first.");const f=H(W(),"prof");d(o,`--inspect-brk=${e}:${i}`),d(o,`--remote-debugging-port=${e}:${a}`),d(o,`--inspect-brk-extensions=${e}:${w}`),d(o,"--prof-startup-prefix",f),d(o,"--no-cached-data"),P(f,o.slice(-6).join("|")),s.push(async v=>{class x{static async start(N,A,O){const F=await import("v8-inspect-profiler");let E;try{E=await F.startProfiling({...O,host:e})}catch{console.error(`FAILED to start profiling for '${N}' on port '${O.port}'`)}return{async stop(){if(!E)return;let S="";const m=await E.stop();process.env.VSCODE_DEV||(m.profile=pe.rewriteAbsolutePaths(m.profile,"piiRemoved"),S=".txt"),P(`${A}.${N}.cpuprofile${S}`,JSON.stringify(m.profile,void 0,4))}}}}try{const C=x.start("main",f,{port:i}),N=x.start("extHost",f,{port:w,tries:300}),A=x.start("renderer",f,{port:a,tries:200,target:function(S){return S.filter(m=>m.webSocketDebuggerUrl?m.type==="page"?m.url.indexOf("workbench/workbench.html")>0||m.url.indexOf("workbench/workbench-dev.html")>0||m.url.indexOf("workbench/workbench.esm.html")>0||m.url.indexOf("workbench/workbench-dev.esm.html")>0:!0:!1)[0]}}),O=await C,F=await N,E=await A;await U(f),await O.stop(),await E.stop(),await F.stop(),P(f,"")}catch{console.error("Failed to profile startup. Make sure to quit Code first.")}})}const h={detached:!0,env:t};r.verbose||(h.stdio="ignore");let b;if(!u)!r.verbose&&r.status&&(h.stdio=["ignore","pipe","ignore"]),b=$(process.execPath,o.slice(2),h);else{const e=["-n","-g"];if(e.push("-a",process.execPath),r.verbose||r.status){e.push("--wait-apps");for(const i of r.verbose?["stdout","stderr"]:["stdout"]){const a=H(z(),`code-${i}`);P(a,""),e.push(`--${i}`,a),s.push(async w=>{try{const f=i==="stdout"?process.stdout:process.stderr,v=new le;w.on("close",()=>{setTimeout(()=>v.dispose(!0),200)}),await X(a,x=>f.write(x),()=>{},v.token)}finally{M(a)}})}}for(const i in t)i!=="_"&&(e.push("--env"),e.push(`${i}=${t[i]}`));if(e.push("--args",...o.slice(2)),t.VSCODE_DEV){const i=".",a=e.indexOf(i);a!==-1&&(e[a]=J(i))}b=$("open",e,{...h,env:{}})}return Promise.all(s.map(e=>e(b)))}}function V(){return _(fe.asFileUri("").fsPath)}function j(o){setTimeout(()=>process.exit(o),0)}ge(process.argv).then(()=>j(0)).then(null,o=>{console.error(o.message||o.stack||o),j(1)});export{ge as main};
