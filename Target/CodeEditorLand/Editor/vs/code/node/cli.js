import{spawn as $}from"child_process";import{chmodSync as D,existsSync as I,readFileSync as B,statSync as R,truncateSync as W,unlinkSync as M}from"fs";import{homedir as j,release as G,tmpdir as z}from"os";import{DeferredPromise as J}from"../../base/common/async.js";import{CancellationTokenSource as K}from"../../base/common/cancellation.js";import{Event as g}from"../../base/common/event.js";import{isUNC as Q,randomPath as L}from"../../base/common/extpath.js";import{FileAccess as X}from"../../base/common/network.js";import{dirname as k,isAbsolute as U,join as v,resolve as Y}from"../../base/common/path.js";import{isMacintosh as Z,isWindows as y}from"../../base/common/platform.js";import{randomPort as ee}from"../../base/common/ports.js";import{cwd as te}from"../../base/common/process.js";import{URI as oe}from"../../base/common/uri.js";import{whenDeleted as H,writeFileSync as P}from"../../base/node/pfs.js";import{findFreePort as T}from"../../base/node/ports.js";import{addUNCHostToAllowlist as re}from"../../base/node/unc.js";import"../../platform/environment/common/argv.js";import{buildHelpMessage as ie,buildVersionMessage as se,NATIVE_CLI_COMMANDS as ne,OPTIONS as ae}from"../../platform/environment/node/argv.js";import{addArg as d,parseCLIProcessArgv as le}from"../../platform/environment/node/argvHelper.js";import{getStdinFilePath as ce,hasStdinWithoutTty as pe,readFromStdin as fe,stdinDataListener as me}from"../../platform/environment/node/stdin.js";import{createWaitMarkerFileSync as de}from"../../platform/environment/node/wait.js";import{watchFileContents as ue}from"../../platform/files/node/watcher/nodejs/nodejsWatcherLib.js";import c from"../../platform/product/common/product.js";import{Utils as he}from"../../platform/profiling/common/profiling.js";function we(o){return!!o["install-source"]||!!o["list-extensions"]||!!o["install-extension"]||!!o["uninstall-extension"]||!!o["update-extensions"]||!!o["locate-extension"]||!!o.telemetry}async function ge(o){let r;try{r=le(o)}catch(t){console.error(t.message);return}for(const t of ne)if(r[t]){if(!c.tunnelApplicationName){console.error(`'${t}' command not supported in ${c.applicationName}`);return}const s={...process.env};delete s.ELECTRON_RUN_AS_NODE;const n=o.slice(o.indexOf(t)+1);return new Promise((l,u)=>{let p;const h=["ignore","pipe","pipe"];if(process.env.VSCODE_DEV)p=$("cargo",["run","--",t,...n],{cwd:v(V(),"cli"),stdio:h,env:s});else{const b=process.platform==="darwin"?v(k(k(process.execPath)),"Resources","app"):k(process.execPath),e=v(b,"bin",`${c.tunnelApplicationName}${y?".exe":""}`);p=$(e,[t,...n],{cwd:te(),stdio:h,env:s})}p.stdout.pipe(process.stdout),p.stderr.pipe(process.stderr),p.on("exit",l),p.on("error",u)})}if(r.help){const t=`${c.applicationName}${y?".exe":""}`;console.log(ie(c.nameLong,t,c.version,ae))}else if(r.version)console.log(se(c.version,c.commit));else if(r["locate-shell-integration-path"]){let t;switch(r["locate-shell-integration-path"]){case"bash":t="shellIntegration-bash.sh";break;case"pwsh":t="shellIntegration.ps1";break;case"zsh":t="shellIntegration-rc.zsh";break;case"fish":t="fish_xdg_data/fish/vendor_conf.d/shellIntegration.fish";break;default:throw new Error("Error using --locate-shell-integration-path: Invalid shell type")}console.log(v(V(),"out","vs","workbench","contrib","terminal","common","scripts",t))}else if(we(r)){await(await import(["vs","code","node","cliProcessMain"].join("/"))).main(r);return}else if(r["file-write"]){const t=r._[0],s=r._[1];if(y)for(const n of[t,s])Q(n)&&re(oe.file(n).authority);if(!t||!s||t===s||!U(t)||!U(s)||!I(t)||!R(t).isFile()||!I(s)||!R(s).isFile())throw new Error("Using --file-write with invalid arguments.");try{let n=0,l=!1;r["file-chmod"]&&(n=R(s).mode,n&128||(D(s,n|128),l=!0));const u=B(t);y?(W(s,0),P(s,u,{flag:"r+"})):P(s,u),l&&D(s,n)}catch(n){throw n.message=`Error using --file-write: ${n.message}`,n}}else{const t={...process.env,ELECTRON_NO_ATTACH_CONSOLE:"1"};delete t.ELECTRON_RUN_AS_NODE;const s=[];r.verbose&&(t.ELECTRON_ENABLE_LOGGING="1"),(r.verbose||r.status)&&s.push(async e=>{e.stdout?.on("data",i=>console.log(i.toString("utf8").trim())),e.stderr?.on("data",i=>console.log(i.toString("utf8").trim())),await g.toPromise(g.fromNodeEventEmitter(e,"exit"))});const n=r._.some(e=>e==="-");n&&(r._=r._.filter(e=>e!=="-"),o=o.filter(e=>e!=="-"));let l;if(pe())if(n){l=ce();try{const e=new J;await fe(l,!!r.verbose,()=>e.complete()),r.wait||s.push(()=>e.p),d(o,l),d(o,"--skip-add-to-recently-opened"),console.log(`Reading from stdin via: ${l}`)}catch(e){console.log(`Failed to create file to read via stdin: ${e.toString()}`),l=void 0}}else s.push(e=>me(1e3).then(i=>{i&&console.log(y?`Run with '${c.applicationName} -' to read output from another program (e.g. 'echo Hello World | ${c.applicationName} -').`:`Run with '${c.applicationName} -' to read from stdin (e.g. 'ps aux | grep code | ${c.applicationName} -').`)}));const u=Z&&G()>"20.0.0";let p;if(r.wait&&(p=de(r.verbose),p&&d(o,"--waitMarkerFilePath",p),s.push(async e=>{let i;u?i=new Promise(a=>{e.on("exit",(w,f)=>{(w!==0||f)&&a()})}):i=g.toPromise(g.fromNodeEventEmitter(e,"exit"));try{await Promise.race([H(p),g.toPromise(g.fromNodeEventEmitter(e,"error")),i])}finally{l&&M(l)}})),r["prof-startup"]){const e="127.0.0.1",i=await T(ee(),10,3e3),a=await T(i+1,10,3e3),w=await T(a+1,10,3e3);if(i*a*w===0)throw new Error("Failed to find free ports for profiler. Make sure to shutdown all instances of the editor first.");const f=L(j(),"prof");d(o,`--inspect-brk=${e}:${i}`),d(o,`--remote-debugging-port=${e}:${a}`),d(o,`--inspect-brk-extensions=${e}:${w}`),d(o,"--prof-startup-prefix",f),d(o,"--no-cached-data"),P(f,o.slice(-6).join("|")),s.push(async _=>{class x{static async start(N,A,O){const F=await import("v8-inspect-profiler");let E;try{E=await F.startProfiling({...O,host:e})}catch{console.error(`FAILED to start profiling for '${N}' on port '${O.port}'`)}return{async stop(){if(!E)return;let S="";const m=await E.stop();process.env.VSCODE_DEV||(m.profile=he.rewriteAbsolutePaths(m.profile,"piiRemoved"),S=".txt"),P(`${A}.${N}.cpuprofile${S}`,JSON.stringify(m.profile,void 0,4))}}}}try{const C=x.start("main",f,{port:i}),N=x.start("extHost",f,{port:w,tries:300}),A=x.start("renderer",f,{port:a,tries:200,target:function(S){return S.filter(m=>m.webSocketDebuggerUrl?m.type==="page"?m.url.indexOf("workbench/workbench.html")>0||m.url.indexOf("workbench/workbench-dev.html")>0||m.url.indexOf("workbench/workbench.esm.html")>0||m.url.indexOf("workbench/workbench-dev.esm.html")>0:!0:!1)[0]}}),O=await C,F=await N,E=await A;await H(f),await O.stop(),await E.stop(),await F.stop(),P(f,"")}catch{console.error("Failed to profile startup. Make sure to quit Code first.")}})}const h={detached:!0,env:t};r.verbose||(h.stdio="ignore");let b;if(!u)!r.verbose&&r.status&&(h.stdio=["ignore","pipe","ignore"]),b=$(process.execPath,o.slice(2),h);else{const e=["-n","-g"];if(e.push("-a",process.execPath),r.verbose||r.status){e.push("--wait-apps");for(const i of r.verbose?["stdout","stderr"]:["stdout"]){const a=L(z(),`code-${i}`);P(a,""),e.push(`--${i}`,a),s.push(async w=>{try{const f=i==="stdout"?process.stdout:process.stderr,_=new K;w.on("close",()=>{setTimeout(()=>_.dispose(!0),200)}),await ue(a,x=>f.write(x),()=>{},_.token)}finally{M(a)}})}}for(const i in t)i!=="_"&&(e.push("--env"),e.push(`${i}=${t[i]}`));if(e.push("--args",...o.slice(2)),t.VSCODE_DEV){const i=".",a=e.indexOf(i);a!==-1&&(e[a]=Y(i))}b=$("open",e,{...h,env:{}})}return Promise.all(s.map(e=>e(b)))}}function V(){return k(X.asFileUri("").fsPath)}function q(o){setTimeout(()=>process.exit(o),0)}ge(process.argv).then(()=>q(0)).then(null,o=>{console.error(o.message||o.stack||o),q(1)});export{ge as main};
