{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/browser/view/domLineBreaksComputer.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createTrustedTypesPolicy } from \"../../../base/browser/trustedTypes.js\";\nimport { CharCode } from \"../../../base/common/charCode.js\";\nimport * as strings from \"../../../base/common/strings.js\";\nimport { assertIsDefined } from \"../../../base/common/types.js\";\nimport { WrappingIndent } from \"../../common/config/editorOptions.js\";\nimport type { FontInfo } from \"../../common/config/fontInfo.js\";\nimport { StringBuilder } from \"../../common/core/stringBuilder.js\";\nimport type { InjectedTextOptions } from \"../../common/model.js\";\nimport {\n\ttype ILineBreaksComputer,\n\ttype ILineBreaksComputerFactory,\n\tModelLineProjectionData,\n} from \"../../common/modelLineProjectionData.js\";\nimport { LineInjectedText } from \"../../common/textModelEvents.js\";\nimport { applyFontInfo } from \"../config/domFontInfo.js\";\n\nconst ttPolicy = createTrustedTypesPolicy(\"domLineBreaksComputer\", {\n\tcreateHTML: (value) => value,\n});\n\nexport class DOMLineBreaksComputerFactory\n\timplements ILineBreaksComputerFactory\n{\n\tpublic static create(targetWindow: Window): DOMLineBreaksComputerFactory {\n\t\treturn new DOMLineBreaksComputerFactory(new WeakRef(targetWindow));\n\t}\n\n\tconstructor(private targetWindow: WeakRef<Window>) {}\n\n\tpublic createLineBreaksComputer(\n\t\tfontInfo: FontInfo,\n\t\ttabSize: number,\n\t\twrappingColumn: number,\n\t\twrappingIndent: WrappingIndent,\n\t\twordBreak: \"normal\" | \"keepAll\",\n\t): ILineBreaksComputer {\n\t\tconst requests: string[] = [];\n\t\tconst injectedTexts: (LineInjectedText[] | null)[] = [];\n\t\treturn {\n\t\t\taddRequest: (\n\t\t\t\tlineText: string,\n\t\t\t\tinjectedText: LineInjectedText[] | null,\n\t\t\t\tpreviousLineBreakData: ModelLineProjectionData | null,\n\t\t\t) => {\n\t\t\t\trequests.push(lineText);\n\t\t\t\tinjectedTexts.push(injectedText);\n\t\t\t},\n\t\t\tfinalize: () => {\n\t\t\t\treturn createLineBreaks(\n\t\t\t\t\tassertIsDefined(this.targetWindow.deref()),\n\t\t\t\t\trequests,\n\t\t\t\t\tfontInfo,\n\t\t\t\t\ttabSize,\n\t\t\t\t\twrappingColumn,\n\t\t\t\t\twrappingIndent,\n\t\t\t\t\twordBreak,\n\t\t\t\t\tinjectedTexts,\n\t\t\t\t);\n\t\t\t},\n\t\t};\n\t}\n}\n\nfunction createLineBreaks(\n\ttargetWindow: Window,\n\trequests: string[],\n\tfontInfo: FontInfo,\n\ttabSize: number,\n\tfirstLineBreakColumn: number,\n\twrappingIndent: WrappingIndent,\n\twordBreak: \"normal\" | \"keepAll\",\n\tinjectedTextsPerLine: (LineInjectedText[] | null)[],\n): (ModelLineProjectionData | null)[] {\n\tfunction createEmptyLineBreakWithPossiblyInjectedText(\n\t\trequestIdx: number,\n\t): ModelLineProjectionData | null {\n\t\tconst injectedTexts = injectedTextsPerLine[requestIdx];\n\t\tif (injectedTexts) {\n\t\t\tconst lineText = LineInjectedText.applyInjectedText(\n\t\t\t\trequests[requestIdx],\n\t\t\t\tinjectedTexts,\n\t\t\t);\n\n\t\t\tconst injectionOptions = injectedTexts.map((t) => t.options);\n\t\t\tconst injectionOffsets = injectedTexts.map(\n\t\t\t\t(text) => text.column - 1,\n\t\t\t);\n\n\t\t\t// creating a `LineBreakData` with an invalid `breakOffsetsVisibleColumn` is OK\n\t\t\t// because `breakOffsetsVisibleColumn` will never be used because it contains injected text\n\t\t\treturn new ModelLineProjectionData(\n\t\t\t\tinjectionOffsets,\n\t\t\t\tinjectionOptions,\n\t\t\t\t[lineText.length],\n\t\t\t\t[],\n\t\t\t\t0,\n\t\t\t);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tif (firstLineBreakColumn === -1) {\n\t\tconst result: (ModelLineProjectionData | null)[] = [];\n\t\tfor (let i = 0, len = requests.length; i < len; i++) {\n\t\t\tresult[i] = createEmptyLineBreakWithPossiblyInjectedText(i);\n\t\t}\n\t\treturn result;\n\t}\n\n\tconst overallWidth = Math.round(\n\t\tfirstLineBreakColumn * fontInfo.typicalHalfwidthCharacterWidth,\n\t);\n\tconst additionalIndent =\n\t\twrappingIndent === WrappingIndent.DeepIndent\n\t\t\t? 2\n\t\t\t: wrappingIndent === WrappingIndent.Indent\n\t\t\t\t? 1\n\t\t\t\t: 0;\n\tconst additionalIndentSize = Math.round(tabSize * additionalIndent);\n\tconst additionalIndentLength = Math.ceil(\n\t\tfontInfo.spaceWidth * additionalIndentSize,\n\t);\n\n\tconst containerDomNode = document.createElement(\"div\");\n\tapplyFontInfo(containerDomNode, fontInfo);\n\n\tconst sb = new StringBuilder(10000);\n\tconst firstNonWhitespaceIndices: number[] = [];\n\tconst wrappedTextIndentLengths: number[] = [];\n\tconst renderLineContents: string[] = [];\n\tconst allCharOffsets: number[][] = [];\n\tconst allVisibleColumns: number[][] = [];\n\tfor (let i = 0; i < requests.length; i++) {\n\t\tconst lineContent = LineInjectedText.applyInjectedText(\n\t\t\trequests[i],\n\t\t\tinjectedTextsPerLine[i],\n\t\t);\n\n\t\tlet firstNonWhitespaceIndex = 0;\n\t\tlet wrappedTextIndentLength = 0;\n\t\tlet width = overallWidth;\n\n\t\tif (wrappingIndent !== WrappingIndent.None) {\n\t\t\tfirstNonWhitespaceIndex =\n\t\t\t\tstrings.firstNonWhitespaceIndex(lineContent);\n\t\t\tif (firstNonWhitespaceIndex === -1) {\n\t\t\t\t// all whitespace line\n\t\t\t\tfirstNonWhitespaceIndex = 0;\n\t\t\t} else {\n\t\t\t\t// Track existing indent\n\n\t\t\t\tfor (let i = 0; i < firstNonWhitespaceIndex; i++) {\n\t\t\t\t\tconst charWidth =\n\t\t\t\t\t\tlineContent.charCodeAt(i) === CharCode.Tab\n\t\t\t\t\t\t\t? tabSize - (wrappedTextIndentLength % tabSize)\n\t\t\t\t\t\t\t: 1;\n\t\t\t\t\twrappedTextIndentLength += charWidth;\n\t\t\t\t}\n\n\t\t\t\tconst indentWidth = Math.ceil(\n\t\t\t\t\tfontInfo.spaceWidth * wrappedTextIndentLength,\n\t\t\t\t);\n\n\t\t\t\t// Force sticking to beginning of line if no character would fit except for the indentation\n\t\t\t\tif (\n\t\t\t\t\tindentWidth + fontInfo.typicalFullwidthCharacterWidth >\n\t\t\t\t\toverallWidth\n\t\t\t\t) {\n\t\t\t\t\tfirstNonWhitespaceIndex = 0;\n\t\t\t\t\twrappedTextIndentLength = 0;\n\t\t\t\t} else {\n\t\t\t\t\twidth = overallWidth - indentWidth;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst renderLineContent = lineContent.substr(firstNonWhitespaceIndex);\n\t\tconst tmp = renderLine(\n\t\t\trenderLineContent,\n\t\t\twrappedTextIndentLength,\n\t\t\ttabSize,\n\t\t\twidth,\n\t\t\tsb,\n\t\t\tadditionalIndentLength,\n\t\t);\n\t\tfirstNonWhitespaceIndices[i] = firstNonWhitespaceIndex;\n\t\twrappedTextIndentLengths[i] = wrappedTextIndentLength;\n\t\trenderLineContents[i] = renderLineContent;\n\t\tallCharOffsets[i] = tmp[0];\n\t\tallVisibleColumns[i] = tmp[1];\n\t}\n\tconst html = sb.build();\n\tconst trustedhtml = ttPolicy?.createHTML(html) ?? html;\n\tcontainerDomNode.innerHTML = trustedhtml as string;\n\n\tcontainerDomNode.style.position = \"absolute\";\n\tcontainerDomNode.style.top = \"10000\";\n\tif (wordBreak === \"keepAll\") {\n\t\t// word-break: keep-all; overflow-wrap: anywhere\n\t\tcontainerDomNode.style.wordBreak = \"keep-all\";\n\t\tcontainerDomNode.style.overflowWrap = \"anywhere\";\n\t} else {\n\t\t// overflow-wrap: break-word\n\t\tcontainerDomNode.style.wordBreak = \"inherit\";\n\t\tcontainerDomNode.style.overflowWrap = \"break-word\";\n\t}\n\ttargetWindow.document.body.appendChild(containerDomNode);\n\n\tconst range = document.createRange();\n\tconst lineDomNodes = Array.prototype.slice.call(\n\t\tcontainerDomNode.children,\n\t\t0,\n\t);\n\n\tconst result: (ModelLineProjectionData | null)[] = [];\n\tfor (let i = 0; i < requests.length; i++) {\n\t\tconst lineDomNode = lineDomNodes[i];\n\t\tconst breakOffsets: number[] | null = readLineBreaks(\n\t\t\trange,\n\t\t\tlineDomNode,\n\t\t\trenderLineContents[i],\n\t\t\tallCharOffsets[i],\n\t\t);\n\t\tif (breakOffsets === null) {\n\t\t\tresult[i] = createEmptyLineBreakWithPossiblyInjectedText(i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst firstNonWhitespaceIndex = firstNonWhitespaceIndices[i];\n\t\tconst wrappedTextIndentLength =\n\t\t\twrappedTextIndentLengths[i] + additionalIndentSize;\n\t\tconst visibleColumns = allVisibleColumns[i];\n\n\t\tconst breakOffsetsVisibleColumn: number[] = [];\n\t\tfor (let j = 0, len = breakOffsets.length; j < len; j++) {\n\t\t\tbreakOffsetsVisibleColumn[j] = visibleColumns[breakOffsets[j]];\n\t\t}\n\n\t\tif (firstNonWhitespaceIndex !== 0) {\n\t\t\t// All break offsets are relative to the renderLineContent, make them absolute again\n\t\t\tfor (let j = 0, len = breakOffsets.length; j < len; j++) {\n\t\t\t\tbreakOffsets[j] += firstNonWhitespaceIndex;\n\t\t\t}\n\t\t}\n\n\t\tlet injectionOptions: InjectedTextOptions[] | null;\n\t\tlet injectionOffsets: number[] | null;\n\t\tconst curInjectedTexts = injectedTextsPerLine[i];\n\t\tif (curInjectedTexts) {\n\t\t\tinjectionOptions = curInjectedTexts.map((t) => t.options);\n\t\t\tinjectionOffsets = curInjectedTexts.map((text) => text.column - 1);\n\t\t} else {\n\t\t\tinjectionOptions = null;\n\t\t\tinjectionOffsets = null;\n\t\t}\n\n\t\tresult[i] = new ModelLineProjectionData(\n\t\t\tinjectionOffsets,\n\t\t\tinjectionOptions,\n\t\t\tbreakOffsets,\n\t\t\tbreakOffsetsVisibleColumn,\n\t\t\twrappedTextIndentLength,\n\t\t);\n\t}\n\n\tcontainerDomNode.remove();\n\treturn result;\n}\n\nenum Constants {\n\tSPAN_MODULO_LIMIT = 16384,\n}\n\nfunction renderLine(\n\tlineContent: string,\n\tinitialVisibleColumn: number,\n\ttabSize: number,\n\twidth: number,\n\tsb: StringBuilder,\n\twrappingIndentLength: number,\n): [number[], number[]] {\n\tif (wrappingIndentLength !== 0) {\n\t\tconst hangingOffset = String(wrappingIndentLength);\n\t\tsb.appendString('<div style=\"text-indent: -');\n\t\tsb.appendString(hangingOffset);\n\t\tsb.appendString(\"px; padding-left: \");\n\t\tsb.appendString(hangingOffset);\n\t\tsb.appendString(\"px; box-sizing: border-box; width:\");\n\t} else {\n\t\tsb.appendString('<div style=\"width:');\n\t}\n\tsb.appendString(String(width));\n\tsb.appendString('px;\">');\n\t// if (containsRTL) {\n\t// \tsb.appendASCIIString('\" dir=\"ltr');\n\t// }\n\n\tconst len = lineContent.length;\n\tlet visibleColumn = initialVisibleColumn;\n\tlet charOffset = 0;\n\tconst charOffsets: number[] = [];\n\tconst visibleColumns: number[] = [];\n\tlet nextCharCode = len > 0 ? lineContent.charCodeAt(0) : CharCode.Null;\n\n\tsb.appendString(\"<span>\");\n\tfor (let charIndex = 0; charIndex < len; charIndex++) {\n\t\tif (charIndex !== 0 && charIndex % Constants.SPAN_MODULO_LIMIT === 0) {\n\t\t\tsb.appendString(\"</span><span>\");\n\t\t}\n\t\tcharOffsets[charIndex] = charOffset;\n\t\tvisibleColumns[charIndex] = visibleColumn;\n\t\tconst charCode = nextCharCode;\n\t\tnextCharCode =\n\t\t\tcharIndex + 1 < len\n\t\t\t\t? lineContent.charCodeAt(charIndex + 1)\n\t\t\t\t: CharCode.Null;\n\t\tlet producedCharacters = 1;\n\t\tlet charWidth = 1;\n\t\tswitch (charCode) {\n\t\t\tcase CharCode.Tab:\n\t\t\t\tproducedCharacters = tabSize - (visibleColumn % tabSize);\n\t\t\t\tcharWidth = producedCharacters;\n\t\t\t\tfor (let space = 1; space <= producedCharacters; space++) {\n\t\t\t\t\tif (space < producedCharacters) {\n\t\t\t\t\t\tsb.appendCharCode(0xa0); // &nbsp;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsb.appendASCIICharCode(CharCode.Space);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CharCode.Space:\n\t\t\t\tif (nextCharCode === CharCode.Space) {\n\t\t\t\t\tsb.appendCharCode(0xa0); // &nbsp;\n\t\t\t\t} else {\n\t\t\t\t\tsb.appendASCIICharCode(CharCode.Space);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CharCode.LessThan:\n\t\t\t\tsb.appendString(\"&lt;\");\n\t\t\t\tbreak;\n\n\t\t\tcase CharCode.GreaterThan:\n\t\t\t\tsb.appendString(\"&gt;\");\n\t\t\t\tbreak;\n\n\t\t\tcase CharCode.Ampersand:\n\t\t\t\tsb.appendString(\"&amp;\");\n\t\t\t\tbreak;\n\n\t\t\tcase CharCode.Null:\n\t\t\t\tsb.appendString(\"&#00;\");\n\t\t\t\tbreak;\n\n\t\t\tcase CharCode.UTF8_BOM:\n\t\t\tcase CharCode.LINE_SEPARATOR:\n\t\t\tcase CharCode.PARAGRAPH_SEPARATOR:\n\t\t\tcase CharCode.NEXT_LINE:\n\t\t\t\tsb.appendCharCode(0xfffd);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tif (strings.isFullWidthCharacter(charCode)) {\n\t\t\t\t\tcharWidth++;\n\t\t\t\t}\n\t\t\t\tif (charCode < 32) {\n\t\t\t\t\tsb.appendCharCode(9216 + charCode);\n\t\t\t\t} else {\n\t\t\t\t\tsb.appendCharCode(charCode);\n\t\t\t\t}\n\t\t}\n\n\t\tcharOffset += producedCharacters;\n\t\tvisibleColumn += charWidth;\n\t}\n\tsb.appendString(\"</span>\");\n\n\tcharOffsets[lineContent.length] = charOffset;\n\tvisibleColumns[lineContent.length] = visibleColumn;\n\n\tsb.appendString(\"</div>\");\n\n\treturn [charOffsets, visibleColumns];\n}\n\nfunction readLineBreaks(\n\trange: Range,\n\tlineDomNode: HTMLDivElement,\n\tlineContent: string,\n\tcharOffsets: number[],\n): number[] | null {\n\tif (lineContent.length <= 1) {\n\t\treturn null;\n\t}\n\tconst spans = <HTMLSpanElement[]>(\n\t\tArray.prototype.slice.call(lineDomNode.children, 0)\n\t);\n\n\tconst breakOffsets: number[] = [];\n\ttry {\n\t\tdiscoverBreaks(\n\t\t\trange,\n\t\t\tspans,\n\t\t\tcharOffsets,\n\t\t\t0,\n\t\t\tnull,\n\t\t\tlineContent.length - 1,\n\t\t\tnull,\n\t\t\tbreakOffsets,\n\t\t);\n\t} catch (err) {\n\t\tconsole.log(err);\n\t\treturn null;\n\t}\n\n\tif (breakOffsets.length === 0) {\n\t\treturn null;\n\t}\n\n\tbreakOffsets.push(lineContent.length);\n\treturn breakOffsets;\n}\n\nfunction discoverBreaks(\n\trange: Range,\n\tspans: HTMLSpanElement[],\n\tcharOffsets: number[],\n\tlow: number,\n\tlowRects: DOMRectList | null,\n\thigh: number,\n\thighRects: DOMRectList | null,\n\tresult: number[],\n): void {\n\tif (low === high) {\n\t\treturn;\n\t}\n\n\tlowRects =\n\t\tlowRects ||\n\t\treadClientRect(range, spans, charOffsets[low], charOffsets[low + 1]);\n\thighRects =\n\t\thighRects ||\n\t\treadClientRect(range, spans, charOffsets[high], charOffsets[high + 1]);\n\n\tif (Math.abs(lowRects[0].top - highRects[0].top) <= 0.1) {\n\t\t// same line\n\t\treturn;\n\t}\n\n\t// there is at least one line break between these two offsets\n\tif (low + 1 === high) {\n\t\t// the two characters are adjacent, so the line break must be exactly between them\n\t\tresult.push(high);\n\t\treturn;\n\t}\n\n\tconst mid = (low + (high - low) / 2) | 0;\n\tconst midRects = readClientRect(\n\t\trange,\n\t\tspans,\n\t\tcharOffsets[mid],\n\t\tcharOffsets[mid + 1],\n\t);\n\tdiscoverBreaks(\n\t\trange,\n\t\tspans,\n\t\tcharOffsets,\n\t\tlow,\n\t\tlowRects,\n\t\tmid,\n\t\tmidRects,\n\t\tresult,\n\t);\n\tdiscoverBreaks(\n\t\trange,\n\t\tspans,\n\t\tcharOffsets,\n\t\tmid,\n\t\tmidRects,\n\t\thigh,\n\t\thighRects,\n\t\tresult,\n\t);\n}\n\nfunction readClientRect(\n\trange: Range,\n\tspans: HTMLSpanElement[],\n\tstartOffset: number,\n\tendOffset: number,\n): DOMRectList {\n\trange.setStart(\n\t\tspans[(startOffset / Constants.SPAN_MODULO_LIMIT) | 0].firstChild!,\n\t\tstartOffset % Constants.SPAN_MODULO_LIMIT,\n\t);\n\trange.setEnd(\n\t\tspans[(endOffset / Constants.SPAN_MODULO_LIMIT) | 0].firstChild!,\n\t\tendOffset % Constants.SPAN_MODULO_LIMIT,\n\t);\n\treturn range.getClientRects();\n}\n"],
  "mappings": "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",
  "names": ["result", "i", "Constants"]
}
