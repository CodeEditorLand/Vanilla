{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/browser/gpu/gpuUtils.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from \"../../../base/common/errors.js\";\nimport {\n\ttype IDisposable,\n\ttoDisposable,\n} from \"../../../base/common/lifecycle.js\";\n\nexport const quadVertices = new Float32Array([\n\t1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0,\n]);\n\nexport function ensureNonNullable<T>(value: T | null): T {\n\tif (!value) {\n\t\tthrow new Error(`Value \"${value}\" cannot be null`);\n\t}\n\treturn value;\n}\n\n// TODO: Move capabilities into ElementSizeObserver?\nexport function observeDevicePixelDimensions(\n\telement: HTMLElement,\n\tparentWindow: Window & typeof globalThis,\n\tcallback: (deviceWidth: number, deviceHeight: number) => void,\n): IDisposable {\n\t// Observe any resizes to the element and extract the actual pixel size of the element if the\n\t// devicePixelContentBoxSize API is supported. This allows correcting rounding errors when\n\t// converting between CSS pixels and device pixels which causes blurry rendering when device\n\t// pixel ratio is not a round number.\n\tlet observer: ResizeObserver | undefined = new parentWindow.ResizeObserver(\n\t\t(entries) => {\n\t\t\tconst entry = entries.find((entry) => entry.target === element);\n\t\t\tif (!entry) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Disconnect if devicePixelContentBoxSize isn't supported by the browser\n\t\t\tif (!(\"devicePixelContentBoxSize\" in entry)) {\n\t\t\t\tobserver?.disconnect();\n\t\t\t\tobserver = undefined;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Fire the callback, ignore events where the dimensions are 0x0 as the canvas is likely hidden\n\t\t\tconst width = entry.devicePixelContentBoxSize[0].inlineSize;\n\t\t\tconst height = entry.devicePixelContentBoxSize[0].blockSize;\n\t\t\tif (width > 0 && height > 0) {\n\t\t\t\tcallback(width, height);\n\t\t\t}\n\t\t},\n\t);\n\ttry {\n\t\tobserver.observe(element, { box: [\"device-pixel-content-box\"] } as any);\n\t} catch {\n\t\tobserver.disconnect();\n\t\tobserver = undefined;\n\t\tthrow new BugIndicatingError(\n\t\t\t\"Could not observe device pixel dimensions\",\n\t\t);\n\t}\n\treturn toDisposable(() => observer?.disconnect());\n}\n"],
  "mappings": ";;AAKA,SAAS,0BAA0B;AACnC;AAAA,EAEC;AAAA,OACM;AAEA,MAAM,eAAe,IAAI,aAAa;AAAA,EAC5C;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAClC,CAAC;AAEM,SAAS,kBAAqB,OAAoB;AACxD,MAAI,CAAC,OAAO;AACX,UAAM,IAAI,MAAM,UAAU,KAAK,kBAAkB;AAAA,EAClD;AACA,SAAO;AACR;AALgB;AAQT,SAAS,6BACf,SACA,cACA,UACc;AAKd,MAAI,WAAuC,IAAI,aAAa;AAAA,IAC3D,CAAC,YAAY;AACZ,YAAM,QAAQ,QAAQ,KAAK,CAACA,WAAUA,OAAM,WAAW,OAAO;AAC9D,UAAI,CAAC,OAAO;AACX;AAAA,MACD;AAGA,UAAI,EAAE,+BAA+B,QAAQ;AAC5C,kBAAU,WAAW;AACrB,mBAAW;AACX;AAAA,MACD;AAGA,YAAM,QAAQ,MAAM,0BAA0B,CAAC,EAAE;AACjD,YAAM,SAAS,MAAM,0BAA0B,CAAC,EAAE;AAClD,UAAI,QAAQ,KAAK,SAAS,GAAG;AAC5B,iBAAS,OAAO,MAAM;AAAA,MACvB;AAAA,IACD;AAAA,EACD;AACA,MAAI;AACH,aAAS,QAAQ,SAAS,EAAE,KAAK,CAAC,0BAA0B,EAAE,CAAQ;AAAA,EACvE,QAAQ;AACP,aAAS,WAAW;AACpB,eAAW;AACX,UAAM,IAAI;AAAA,MACT;AAAA,IACD;AAAA,EACD;AACA,SAAO,aAAa,MAAM,UAAU,WAAW,CAAC;AACjD;AAzCgB;",
  "names": ["entry"]
}
