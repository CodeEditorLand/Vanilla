{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/browser/gpu/gpuUtils.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { toDisposable, type IDisposable } from '../../../base/common/lifecycle.js';\n\nexport const quadVertices = new Float32Array([\n\t1, 0,\n\t1, 1,\n\t0, 1,\n\t0, 0,\n\t0, 1,\n\t1, 0,\n]);\n\nexport function ensureNonNullable<T>(value: T | null): T {\n\tif (!value) {\n\t\tthrow new Error(`Value \"${value}\" cannot be null`);\n\t}\n\treturn value;\n}\n\n// TODO: Move capabilities into ElementSizeObserver?\nexport function observeDevicePixelDimensions(element: HTMLElement, parentWindow: Window & typeof globalThis, callback: (deviceWidth: number, deviceHeight: number) => void): IDisposable {\n\t// Observe any resizes to the element and extract the actual pixel size of the element if the\n\t// devicePixelContentBoxSize API is supported. This allows correcting rounding errors when\n\t// converting between CSS pixels and device pixels which causes blurry rendering when device\n\t// pixel ratio is not a round number.\n\tlet observer: ResizeObserver | undefined = new parentWindow.ResizeObserver((entries) => {\n\t\tconst entry = entries.find((entry) => entry.target === element);\n\t\tif (!entry) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Disconnect if devicePixelContentBoxSize isn't supported by the browser\n\t\tif (!('devicePixelContentBoxSize' in entry)) {\n\t\t\tobserver?.disconnect();\n\t\t\tobserver = undefined;\n\t\t\treturn;\n\t\t}\n\n\t\t// Fire the callback, ignore events where the dimensions are 0x0 as the canvas is likely hidden\n\t\tconst width = entry.devicePixelContentBoxSize[0].inlineSize;\n\t\tconst height = entry.devicePixelContentBoxSize[0].blockSize;\n\t\tif (width > 0 && height > 0) {\n\t\t\tcallback(width, height);\n\t\t}\n\t});\n\ttry {\n\t\tobserver.observe(element, { box: ['device-pixel-content-box'] } as any);\n\t} catch {\n\t\tobserver.disconnect();\n\t\tobserver = undefined;\n\t\tthrow new BugIndicatingError('Could not observe device pixel dimensions');\n\t}\n\treturn toDisposable(() => observer?.disconnect());\n}\n"],
  "mappings": ";;AAKA,SAAS,0BAA0B;AACnC,SAAS,oBAAsC;AAExC,MAAM,eAAe,IAAI,aAAa;AAAA,EAC5C;AAAA,EAAG;AAAA,EACH;AAAA,EAAG;AAAA,EACH;AAAA,EAAG;AAAA,EACH;AAAA,EAAG;AAAA,EACH;AAAA,EAAG;AAAA,EACH;AAAA,EAAG;AACJ,CAAC;AAEM,SAAS,kBAAqB,OAAoB;AACxD,MAAI,CAAC,OAAO;AACX,UAAM,IAAI,MAAM,UAAU,KAAK,kBAAkB;AAAA,EAClD;AACA,SAAO;AACR;AALgB;AAQT,SAAS,6BAA6B,SAAsB,cAA0C,UAA4E;AAKxL,MAAI,WAAuC,IAAI,aAAa,eAAe,CAAC,YAAY;AACvF,UAAM,QAAQ,QAAQ,KAAK,CAACA,WAAUA,OAAM,WAAW,OAAO;AAC9D,QAAI,CAAC,OAAO;AACX;AAAA,IACD;AAGA,QAAI,EAAE,+BAA+B,QAAQ;AAC5C,gBAAU,WAAW;AACrB,iBAAW;AACX;AAAA,IACD;AAGA,UAAM,QAAQ,MAAM,0BAA0B,CAAC,EAAE;AACjD,UAAM,SAAS,MAAM,0BAA0B,CAAC,EAAE;AAClD,QAAI,QAAQ,KAAK,SAAS,GAAG;AAC5B,eAAS,OAAO,MAAM;AAAA,IACvB;AAAA,EACD,CAAC;AACD,MAAI;AACH,aAAS,QAAQ,SAAS,EAAE,KAAK,CAAC,0BAA0B,EAAE,CAAQ;AAAA,EACvE,QAAQ;AACP,aAAS,WAAW;AACpB,eAAW;AACX,UAAM,IAAI,mBAAmB,2CAA2C;AAAA,EACzE;AACA,SAAO,aAAa,MAAM,UAAU,WAAW,CAAC;AACjD;AAjCgB;",
  "names": ["entry"]
}
