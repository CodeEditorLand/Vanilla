{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/browser/gpu/fullFileRenderStrategy.wgsl.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BindingId } from \"./gpu.js\";\n\nexport const fullFileRenderStrategyWgsl = /*wgsl*/ `\nstruct GlyphInfo {\n\tposition: vec2f,\n\tsize: vec2f,\n\torigin: vec2f,\n};\n\nstruct Vertex {\n\t@location(0) position: vec2f,\n};\n\nstruct Cell {\n\tposition: vec2f,\n\tunused1: vec2f,\n\tglyphIndex: f32,\n\ttextureIndex: f32\n};\n\nstruct LayoutInfo {\n\tcanvasDims: vec2f,\n\tviewportOffset: vec2f,\n\tviewportDims: vec2f,\n}\n\nstruct ScrollOffset {\n\toffset: vec2f\n}\n\nstruct VSOutput {\n\t@builtin(position) position:   vec4f,\n\t@location(1)       layerIndex: f32,\n\t@location(0)       texcoord:   vec2f,\n};\n\n// Uniforms\n@group(0) @binding(${BindingId.ViewportUniform})         var<uniform>       layoutInfo:      LayoutInfo;\n@group(0) @binding(${BindingId.AtlasDimensionsUniform})  var<uniform>       atlasDims:       vec2f;\n@group(0) @binding(${BindingId.ScrollOffset})            var<uniform>       scrollOffset:    ScrollOffset;\n\n// Storage buffers\n@group(0) @binding(${BindingId.GlyphInfo0})              var<storage, read> glyphInfo0:      array<GlyphInfo>;\n@group(0) @binding(${BindingId.GlyphInfo1})              var<storage, read> glyphInfo1:      array<GlyphInfo>;\n@group(0) @binding(${BindingId.Cells})                   var<storage, read> cells:           array<Cell>;\n\n@vertex fn vs(\n\tvert: Vertex,\n\t@builtin(instance_index) instanceIndex: u32,\n\t@builtin(vertex_index) vertexIndex : u32\n) -> VSOutput {\n\tlet cell = cells[instanceIndex];\n\t// TODO: Is there a nicer way to init this?\n\tvar glyph = glyphInfo0[0];\n\tlet glyphIndex = u32(cell.glyphIndex);\n\tif (u32(cell.textureIndex) == 0) {\n\t\tglyph = glyphInfo0[glyphIndex];\n\t} else {\n\t\tglyph = glyphInfo1[glyphIndex];\n\t}\n\n\tvar vsOut: VSOutput;\n\t// Multiple vert.position by 2,-2 to get it into clipspace which ranged from -1 to 1\n\tvsOut.position = vec4f(\n\t\t(((vert.position * vec2f(2, -2)) / layoutInfo.canvasDims)) * glyph.size + cell.position + ((glyph.origin * vec2f(2, -2)) / layoutInfo.canvasDims) + (((scrollOffset.offset + layoutInfo.viewportOffset) * 2) / layoutInfo.canvasDims),\n\t\t0.0,\n\t\t1.0\n\t);\n\n\tvsOut.layerIndex = cell.textureIndex;\n\t// Textures are flipped from natural direction on the y-axis, so flip it back\n\tvsOut.texcoord = vert.position;\n\tvsOut.texcoord = (\n\t\t// Glyph offset (0-1)\n\t\t(glyph.position / atlasDims) +\n\t\t// Glyph coordinate (0-1)\n\t\t(vsOut.texcoord * (glyph.size / atlasDims))\n\t);\n\n\treturn vsOut;\n}\n\n@group(0) @binding(${BindingId.TextureSampler}) var ourSampler: sampler;\n@group(0) @binding(${BindingId.Texture})        var ourTexture: texture_2d_array<f32>;\n\n@fragment fn fs(vsOut: VSOutput) -> @location(0) vec4f {\n\treturn textureSample(ourTexture, ourSampler, vsOut.texcoord, u32(vsOut.layerIndex));\n}\n`;\n"],
  "mappings": "AAKA,SAAS,iBAAiB;AAEnB,MAAM;AAAA;AAAA,EAAsC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qBAmC9B,UAAU,eAAe;AAAA,qBACzB,UAAU,sBAAsB;AAAA,qBAChC,UAAU,YAAY;AAAA;AAAA;AAAA,qBAGtB,UAAU,UAAU;AAAA,qBACpB,UAAU,UAAU;AAAA,qBACpB,UAAU,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qBAsCf,UAAU,cAAc;AAAA,qBACxB,UAAU,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;",
  "names": []
}
