{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/browser/gpu/raster/glyphRasterizer.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Disposable } from \"../../../../base/common/lifecycle.js\";\nimport { StringBuilder } from \"../../../common/core/stringBuilder.js\";\nimport {\n\tFontStyle,\n\tTokenMetadata,\n} from \"../../../common/encodedTokenAttributes.js\";\nimport { ensureNonNullable } from \"../gpuUtils.js\";\nimport type {\n\tIBoundingBox,\n\tIGlyphRasterizer,\n\tIRasterizedGlyph,\n} from \"./raster.js\";\n\nlet nextId = 0;\n\nexport class GlyphRasterizer extends Disposable implements IGlyphRasterizer {\n\tpublic readonly id = nextId++;\n\n\tprivate _canvas: OffscreenCanvas;\n\tprivate _ctx: OffscreenCanvasRenderingContext2D;\n\n\tprivate _workGlyph: IRasterizedGlyph = {\n\t\tsource: null!,\n\t\tboundingBox: {\n\t\t\tleft: 0,\n\t\t\tbottom: 0,\n\t\t\tright: 0,\n\t\t\ttop: 0,\n\t\t},\n\t\toriginOffset: {\n\t\t\tx: 0,\n\t\t\ty: 0,\n\t\t},\n\t};\n\tprivate _workGlyphConfig: { chars: string | undefined; metadata: number } =\n\t\t{ chars: undefined, metadata: 0 };\n\n\tconstructor(\n\t\tprivate readonly _fontSize: number,\n\t\tprivate readonly _fontFamily: string,\n\t) {\n\t\tsuper();\n\n\t\tthis._canvas = new OffscreenCanvas(\n\t\t\tthis._fontSize * 3,\n\t\t\tthis._fontSize * 3,\n\t\t);\n\t\tthis._ctx = ensureNonNullable(\n\t\t\tthis._canvas.getContext(\"2d\", {\n\t\t\t\twillReadFrequently: true,\n\t\t\t}),\n\t\t);\n\t\tthis._ctx.textBaseline = \"top\";\n\t\tthis._ctx.fillStyle = \"#FFFFFF\";\n\t}\n\n\t// TODO: Support drawing multiple fonts and sizes\n\t/**\n\t * Rasterizes a glyph. Note that the returned object is reused across different glyphs and\n\t * therefore is only safe for synchronous access.\n\t */\n\tpublic rasterizeGlyph(\n\t\tchars: string,\n\t\tmetadata: number,\n\t\tcolorMap: string[],\n\t): Readonly<IRasterizedGlyph> {\n\t\tif (chars === \"\") {\n\t\t\treturn {\n\t\t\t\tsource: this._canvas,\n\t\t\t\tboundingBox: { top: 0, left: 0, bottom: -1, right: -1 },\n\t\t\t\toriginOffset: { x: 0, y: 0 },\n\t\t\t};\n\t\t}\n\t\t// Check if the last glyph matches the config, reuse if so. This helps avoid unnecessary\n\t\t// work when the rasterizer is called multiple times like when the glyph doesn't fit into a\n\t\t// page.\n\t\tif (\n\t\t\tthis._workGlyphConfig.chars === chars &&\n\t\t\tthis._workGlyphConfig.metadata === metadata\n\t\t) {\n\t\t\treturn this._workGlyph;\n\t\t}\n\t\tthis._workGlyphConfig.chars = chars;\n\t\tthis._workGlyphConfig.metadata = metadata;\n\t\treturn this._rasterizeGlyph(chars, metadata, colorMap);\n\t}\n\n\tpublic _rasterizeGlyph(\n\t\tchars: string,\n\t\tmetadata: number,\n\t\tcolorMap: string[],\n\t): Readonly<IRasterizedGlyph> {\n\t\t// TODO: Support workbench.fontAliasing\n\t\tthis._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\n\n\t\tconst fontSb = new StringBuilder(200);\n\t\tconst fontStyle = TokenMetadata.getFontStyle(metadata);\n\t\tif (fontStyle & FontStyle.Italic) {\n\t\t\tfontSb.appendString(\"italic \");\n\t\t}\n\t\tif (fontStyle & FontStyle.Bold) {\n\t\t\tfontSb.appendString(\"bold \");\n\t\t}\n\t\tfontSb.appendString(`${this._fontSize}px ${this._fontFamily}`);\n\t\tthis._ctx.font = fontSb.build();\n\n\t\t// TODO: Support FontStyle.Strikethrough and FontStyle.Underline text decorations, these\n\t\t//       need to be drawn manually to the canvas. See xterm.js for \"dodging\" the text for\n\t\t//       underlines.\n\n\t\tconst originX = this._fontSize;\n\t\tconst originY = this._fontSize;\n\t\tthis._ctx.fillStyle = colorMap[TokenMetadata.getForeground(metadata)];\n\t\t// TODO: This might actually be slower\n\t\t// const textMetrics = this._ctx.measureText(chars);\n\t\tthis._ctx.fillText(chars, originX, originY);\n\n\t\tconst imageData = this._ctx.getImageData(\n\t\t\t0,\n\t\t\t0,\n\t\t\tthis._canvas.width,\n\t\t\tthis._canvas.height,\n\t\t);\n\t\tthis._findGlyphBoundingBox(imageData, this._workGlyph.boundingBox);\n\t\t// const offset = {\n\t\t// \tx: textMetrics.actualBoundingBoxLeft,\n\t\t// \ty: textMetrics.actualBoundingBoxAscent\n\t\t// };\n\t\t// const size = {\n\t\t// \tw: textMetrics.actualBoundingBoxRight + textMetrics.actualBoundingBoxLeft,\n\t\t// \ty: textMetrics.actualBoundingBoxDescent + textMetrics.actualBoundingBoxAscent,\n\t\t// \twInt: Math.ceil(textMetrics.actualBoundingBoxRight + textMetrics.actualBoundingBoxLeft),\n\t\t// \tyInt: Math.ceil(textMetrics.actualBoundingBoxDescent + textMetrics.actualBoundingBoxAscent),\n\t\t// };\n\t\t// console.log(`${chars}_${fg}`, textMetrics, boundingBox, originX, originY, { width: boundingBox.right - boundingBox.left, height: boundingBox.bottom - boundingBox.top });\n\t\tthis._workGlyph.source = this._canvas;\n\t\tthis._workGlyph.originOffset.x =\n\t\t\tthis._workGlyph.boundingBox.left - originX;\n\t\tthis._workGlyph.originOffset.y =\n\t\t\tthis._workGlyph.boundingBox.top - originY;\n\n\t\t// const result2: IRasterizedGlyph = {\n\t\t// \tsource: this._canvas,\n\t\t// \tboundingBox: {\n\t\t// \t\tleft: Math.floor(originX - textMetrics.actualBoundingBoxLeft),\n\t\t// \t\tright: Math.ceil(originX + textMetrics.actualBoundingBoxRight),\n\t\t// \t\ttop: Math.floor(originY - textMetrics.actualBoundingBoxAscent),\n\t\t// \t\tbottom: Math.ceil(originY + textMetrics.actualBoundingBoxDescent),\n\t\t// \t},\n\t\t// \toriginOffset: {\n\t\t// \t\tx: Math.floor(boundingBox.left - originX),\n\t\t// \t\ty: Math.floor(boundingBox.top - originY)\n\t\t// \t}\n\t\t// };\n\n\t\t// TODO: Verify result 1 and 2 are the same\n\n\t\t// if (result2.boundingBox.left > result.boundingBox.left) {\n\t\t// \tdebugger;\n\t\t// }\n\t\t// if (result2.boundingBox.top > result.boundingBox.top) {\n\t\t// \tdebugger;\n\t\t// }\n\t\t// if (result2.boundingBox.right < result.boundingBox.right) {\n\t\t// \tdebugger;\n\t\t// }\n\t\t// if (result2.boundingBox.bottom < result.boundingBox.bottom) {\n\t\t// \tdebugger;\n\t\t// }\n\t\t// if (JSON.stringify(result2.originOffset) !== JSON.stringify(result.originOffset)) {\n\t\t// \tdebugger;\n\t\t// }\n\n\t\treturn this._workGlyph;\n\t}\n\n\t// TODO: Does this even need to happen when measure text is used?\n\tprivate _findGlyphBoundingBox(\n\t\timageData: ImageData,\n\t\toutBoundingBox: IBoundingBox,\n\t) {\n\t\tconst height = this._canvas.height;\n\t\tconst width = this._canvas.width;\n\t\tlet found = false;\n\t\tfor (let y = 0; y < height; y++) {\n\t\t\tfor (let x = 0; x < width; x++) {\n\t\t\t\tconst alphaOffset = y * width * 4 + x * 4 + 3;\n\t\t\t\tif (imageData.data[alphaOffset] !== 0) {\n\t\t\t\t\toutBoundingBox.top = y;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\toutBoundingBox.left = 0;\n\t\tfound = false;\n\t\tfor (let x = 0; x < width; x++) {\n\t\t\tfor (let y = 0; y < height; y++) {\n\t\t\t\tconst alphaOffset = y * width * 4 + x * 4 + 3;\n\t\t\t\tif (imageData.data[alphaOffset] !== 0) {\n\t\t\t\t\toutBoundingBox.left = x;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\toutBoundingBox.right = width;\n\t\tfound = false;\n\t\tfor (let x = width - 1; x >= outBoundingBox.left; x--) {\n\t\t\tfor (let y = 0; y < height; y++) {\n\t\t\t\tconst alphaOffset = y * width * 4 + x * 4 + 3;\n\t\t\t\tif (imageData.data[alphaOffset] !== 0) {\n\t\t\t\t\toutBoundingBox.right = x;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\toutBoundingBox.bottom = outBoundingBox.top;\n\t\tfound = false;\n\t\tfor (let y = height - 1; y >= 0; y--) {\n\t\t\tfor (let x = 0; x < width; x++) {\n\t\t\t\tconst alphaOffset = y * width * 4 + x * 4 + 3;\n\t\t\t\tif (imageData.data[alphaOffset] !== 0) {\n\t\t\t\t\toutBoundingBox.bottom = y;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
