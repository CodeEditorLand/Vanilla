{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/browser/gpu/atlas/textureAtlas.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getActiveWindow } from '../../../../base/browser/dom.js';\nimport { CharCode } from '../../../../base/common/charCode.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { Disposable, dispose, MutableDisposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { ThreeKeyMap } from '../../../../base/common/map.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IThemeService } from '../../../../platform/theme/common/themeService.js';\nimport { MetadataConsts } from '../../../common/encodedTokenAttributes.js';\nimport { GlyphRasterizer } from '../raster/glyphRasterizer.js';\nimport type { IGlyphRasterizer } from '../raster/raster.js';\nimport { IdleTaskQueue } from '../taskQueue.js';\nimport type { IReadableTextureAtlasPage, ITextureAtlasPageGlyph, GlyphMap } from './atlas.js';\nimport { AllocatorType, TextureAtlasPage } from './textureAtlasPage.js';\n\nexport interface ITextureAtlasOptions {\n\tallocatorType?: AllocatorType;\n}\n\nexport class TextureAtlas extends Disposable {\n\tprivate _colorMap!: string[];\n\tprivate readonly _warmUpTask: MutableDisposable<IdleTaskQueue> = this._register(new MutableDisposable());\n\tprivate readonly _warmedUpRasterizers = new Set<number>();\n\tprivate readonly _allocatorType: AllocatorType;\n\n\t/**\n\t * The main texture atlas pages which are both larger textures and more efficiently packed\n\t * relative to the scratch page. The idea is the main pages are drawn to and uploaded to the GPU\n\t * much less frequently so as to not drop frames.\n\t */\n\tprivate readonly _pages: TextureAtlasPage[] = [];\n\tget pages(): IReadableTextureAtlasPage[] { return this._pages; }\n\n\treadonly pageSize: number;\n\n\t/**\n\t * A maps of glyph keys to the page to start searching for the glyph. This is set before\n\t * searching to have as little runtime overhead (branching, intermediate variables) as possible,\n\t * so it is not guaranteed to be the actual page the glyph is on. But it is guaranteed that all\n\t * pages with a lower index do not contain the glyph.\n\t */\n\tprivate readonly _glyphPageIndex: GlyphMap<number> = new ThreeKeyMap();\n\n\tprivate readonly _onDidDeleteGlyphs = this._register(new Emitter<void>());\n\treadonly onDidDeleteGlyphs = this._onDidDeleteGlyphs.event;\n\n\tconstructor(\n\t\t/** The maximum texture size supported by the GPU. */\n\t\tprivate readonly _maxTextureSize: number,\n\t\toptions: ITextureAtlasOptions | undefined,\n\t\t@IThemeService private readonly _themeService: IThemeService,\n\t\t@IInstantiationService private readonly _instantiationService: IInstantiationService\n\t) {\n\t\tsuper();\n\n\t\tthis._allocatorType = options?.allocatorType ?? 'slab';\n\n\t\tthis._register(Event.runAndSubscribe(this._themeService.onDidColorThemeChange, () => {\n\t\t\t// TODO: Clear entire atlas on theme change\n\t\t\tthis._colorMap = this._themeService.getColorTheme().tokenColorMap;\n\t\t}));\n\n\t\tconst dprFactor = Math.max(1, Math.floor(getActiveWindow().devicePixelRatio));\n\n\t\tthis.pageSize = Math.min(1024 * dprFactor, this._maxTextureSize);\n\t\tthis._initFirstPage();\n\n\t\tthis._register(toDisposable(() => dispose(this._pages)));\n\t}\n\n\tprivate _initFirstPage() {\n\t\tconst firstPage = this._instantiationService.createInstance(TextureAtlasPage, 0, this.pageSize, this._allocatorType);\n\t\tthis._pages.push(firstPage);\n\n\t\t// IMPORTANT: The first glyph on the first page must be an empty glyph such that zeroed out\n\t\t// cells end up rendering nothing\n\t\t// TODO: This currently means the first slab is for 0x0 glyphs and is wasted\n\t\tconst nullRasterizer = new GlyphRasterizer(1, '');\n\t\tfirstPage.getGlyph(nullRasterizer, '', 0);\n\t\tnullRasterizer.dispose();\n\t}\n\n\tclear() {\n\t\t// Clear all pages\n\t\tfor (const page of this._pages) {\n\t\t\tpage.dispose();\n\t\t}\n\t\tthis._pages.length = 0;\n\t\tthis._glyphPageIndex.clear();\n\t\tthis._warmedUpRasterizers.clear();\n\t\tthis._warmUpTask.clear();\n\n\t\t// Recreate first\n\t\tthis._initFirstPage();\n\n\t\t// Tell listeners\n\t\tthis._onDidDeleteGlyphs.fire();\n\t}\n\n\tgetGlyph(rasterizer: IGlyphRasterizer, chars: string, metadata: number): Readonly<ITextureAtlasPageGlyph> {\n\t\t// TODO: Encode font size and family into key\n\t\t// Ignore metadata that doesn't affect the glyph\n\t\tmetadata &= ~(MetadataConsts.LANGUAGEID_MASK | MetadataConsts.TOKEN_TYPE_MASK | MetadataConsts.BALANCED_BRACKETS_MASK);\n\n\t\t// Warm up common glyphs\n\t\tif (!this._warmedUpRasterizers.has(rasterizer.id)) {\n\t\t\tthis._warmUpAtlas(rasterizer);\n\t\t\tthis._warmedUpRasterizers.add(rasterizer.id);\n\t\t}\n\n\t\t// Try get the glyph, overflowing to a new page if necessary\n\t\treturn this._tryGetGlyph(this._glyphPageIndex.get(chars, metadata, rasterizer.cacheKey) ?? 0, rasterizer, chars, metadata);\n\t}\n\n\tprivate _tryGetGlyph(pageIndex: number, rasterizer: IGlyphRasterizer, chars: string, metadata: number): Readonly<ITextureAtlasPageGlyph> {\n\t\tthis._glyphPageIndex.set(chars, metadata, rasterizer.cacheKey, pageIndex);\n\t\treturn (\n\t\t\tthis._pages[pageIndex].getGlyph(rasterizer, chars, metadata)\n\t\t\t?? (pageIndex + 1 < this._pages.length\n\t\t\t\t? this._tryGetGlyph(pageIndex + 1, rasterizer, chars, metadata)\n\t\t\t\t: undefined)\n\t\t\t?? this._getGlyphFromNewPage(rasterizer, chars, metadata)\n\t\t);\n\t}\n\n\tprivate _getGlyphFromNewPage(rasterizer: IGlyphRasterizer, chars: string, metadata: number): Readonly<ITextureAtlasPageGlyph> {\n\t\t// TODO: Support more than 2 pages and the GPU texture layer limit\n\t\tthis._pages.push(this._instantiationService.createInstance(TextureAtlasPage, this._pages.length, this.pageSize, this._allocatorType));\n\t\tthis._glyphPageIndex.set(chars, metadata, rasterizer.cacheKey, this._pages.length - 1);\n\t\treturn this._pages[this._pages.length - 1].getGlyph(rasterizer, chars, metadata)!;\n\t}\n\n\tpublic getUsagePreview(): Promise<Blob[]> {\n\t\treturn Promise.all(this._pages.map(e => e.getUsagePreview()));\n\t}\n\n\tpublic getStats(): string[] {\n\t\treturn this._pages.map(e => e.getStats());\n\t}\n\n\t/**\n\t * Warms up the atlas by rasterizing all printable ASCII characters for each token color. This\n\t * is distrubuted over multiple idle callbacks to avoid blocking the main thread.\n\t */\n\tprivate _warmUpAtlas(rasterizer: IGlyphRasterizer): void {\n\t\tthis._warmUpTask.value?.clear();\n\t\tconst taskQueue = this._warmUpTask.value = new IdleTaskQueue();\n\t\t// Warm up using roughly the larger glyphs first to help optimize atlas allocation\n\t\t// A-Z\n\t\tfor (let code = CharCode.A; code <= CharCode.Z; code++) {\n\t\t\ttaskQueue.enqueue(() => {\n\t\t\t\tfor (const fgColor of this._colorMap.keys()) {\n\t\t\t\t\tthis.getGlyph(rasterizer, String.fromCharCode(code), (fgColor << MetadataConsts.FOREGROUND_OFFSET) & MetadataConsts.FOREGROUND_MASK);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t// a-z\n\t\tfor (let code = CharCode.a; code <= CharCode.z; code++) {\n\t\t\ttaskQueue.enqueue(() => {\n\t\t\t\tfor (const fgColor of this._colorMap.keys()) {\n\t\t\t\t\tthis.getGlyph(rasterizer, String.fromCharCode(code), (fgColor << MetadataConsts.FOREGROUND_OFFSET) & MetadataConsts.FOREGROUND_MASK);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t// Remaining ascii\n\t\tfor (let code = CharCode.ExclamationMark; code <= CharCode.Tilde; code++) {\n\t\t\ttaskQueue.enqueue(() => {\n\t\t\t\tfor (const fgColor of this._colorMap.keys()) {\n\t\t\t\t\tthis.getGlyph(rasterizer, String.fromCharCode(code), (fgColor << MetadataConsts.FOREGROUND_OFFSET) & MetadataConsts.FOREGROUND_MASK);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n}\n\n"],
  "mappings": ";;;;;;;;;;;;AAKA,SAAS,uBAAuB;AAChC,SAAS,gBAAgB;AACzB,SAAS,SAAS,aAAa;AAC/B,SAAS,YAAY,SAAS,mBAAmB,oBAAoB;AACrE,SAAS,mBAAmB;AAC5B,SAAS,6BAA6B;AACtC,SAAS,qBAAqB;AAC9B,SAAS,sBAAsB;AAC/B,SAAS,uBAAuB;AAEhC,SAAS,qBAAqB;AAE9B,SAAS,eAAe,wBAAwB;AAMzC,IAAM,eAAN,cAA2B,WAAW;AAAA,EA2B5C,YAEkB,iBACjB,SACgC,eACQ,uBACvC;AACD,UAAM;AALW;AAEe;AACQ;AAIxC,SAAK,iBAAiB,SAAS,iBAAiB;AAEhD,SAAK,UAAU,MAAM,gBAAgB,KAAK,cAAc,uBAAuB,MAAM;AAEpF,WAAK,YAAY,KAAK,cAAc,cAAc,EAAE;AAAA,IACrD,CAAC,CAAC;AAEF,UAAM,YAAY,KAAK,IAAI,GAAG,KAAK,MAAM,gBAAgB,EAAE,gBAAgB,CAAC;AAE5E,SAAK,WAAW,KAAK,IAAI,OAAO,WAAW,KAAK,eAAe;AAC/D,SAAK,eAAe;AAEpB,SAAK,UAAU,aAAa,MAAM,QAAQ,KAAK,MAAM,CAAC,CAAC;AAAA,EACxD;AAAA,EAxED,OAuB6C;AAAA;AAAA;AAAA,EACpC;AAAA,EACS,cAAgD,KAAK,UAAU,IAAI,kBAAkB,CAAC;AAAA,EACtF,uBAAuB,oBAAI,IAAY;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,SAA6B,CAAC;AAAA,EAC/C,IAAI,QAAqC;AAAE,WAAO,KAAK;AAAA,EAAQ;AAAA,EAEtD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,kBAAoC,IAAI,YAAY;AAAA,EAEpD,qBAAqB,KAAK,UAAU,IAAI,QAAc,CAAC;AAAA,EAC/D,oBAAoB,KAAK,mBAAmB;AAAA,EA0B7C,iBAAiB;AACxB,UAAM,YAAY,KAAK,sBAAsB,eAAe,kBAAkB,GAAG,KAAK,UAAU,KAAK,cAAc;AACnH,SAAK,OAAO,KAAK,SAAS;AAK1B,UAAM,iBAAiB,IAAI,gBAAgB,GAAG,EAAE;AAChD,cAAU,SAAS,gBAAgB,IAAI,CAAC;AACxC,mBAAe,QAAQ;AAAA,EACxB;AAAA,EAEA,QAAQ;AAEP,eAAW,QAAQ,KAAK,QAAQ;AAC/B,WAAK,QAAQ;AAAA,IACd;AACA,SAAK,OAAO,SAAS;AACrB,SAAK,gBAAgB,MAAM;AAC3B,SAAK,qBAAqB,MAAM;AAChC,SAAK,YAAY,MAAM;AAGvB,SAAK,eAAe;AAGpB,SAAK,mBAAmB,KAAK;AAAA,EAC9B;AAAA,EAEA,SAAS,YAA8B,OAAe,UAAoD;AAGzG,gBAAY,EAAE,eAAe,kBAAkB,eAAe,kBAAkB,eAAe;AAG/F,QAAI,CAAC,KAAK,qBAAqB,IAAI,WAAW,EAAE,GAAG;AAClD,WAAK,aAAa,UAAU;AAC5B,WAAK,qBAAqB,IAAI,WAAW,EAAE;AAAA,IAC5C;AAGA,WAAO,KAAK,aAAa,KAAK,gBAAgB,IAAI,OAAO,UAAU,WAAW,QAAQ,KAAK,GAAG,YAAY,OAAO,QAAQ;AAAA,EAC1H;AAAA,EAEQ,aAAa,WAAmB,YAA8B,OAAe,UAAoD;AACxI,SAAK,gBAAgB,IAAI,OAAO,UAAU,WAAW,UAAU,SAAS;AACxE,WACC,KAAK,OAAO,SAAS,EAAE,SAAS,YAAY,OAAO,QAAQ,MACvD,YAAY,IAAI,KAAK,OAAO,SAC7B,KAAK,aAAa,YAAY,GAAG,YAAY,OAAO,QAAQ,IAC5D,WACA,KAAK,qBAAqB,YAAY,OAAO,QAAQ;AAAA,EAE1D;AAAA,EAEQ,qBAAqB,YAA8B,OAAe,UAAoD;AAE7H,SAAK,OAAO,KAAK,KAAK,sBAAsB,eAAe,kBAAkB,KAAK,OAAO,QAAQ,KAAK,UAAU,KAAK,cAAc,CAAC;AACpI,SAAK,gBAAgB,IAAI,OAAO,UAAU,WAAW,UAAU,KAAK,OAAO,SAAS,CAAC;AACrF,WAAO,KAAK,OAAO,KAAK,OAAO,SAAS,CAAC,EAAE,SAAS,YAAY,OAAO,QAAQ;AAAA,EAChF;AAAA,EAEO,kBAAmC;AACzC,WAAO,QAAQ,IAAI,KAAK,OAAO,IAAI,OAAK,EAAE,gBAAgB,CAAC,CAAC;AAAA,EAC7D;AAAA,EAEO,WAAqB;AAC3B,WAAO,KAAK,OAAO,IAAI,OAAK,EAAE,SAAS,CAAC;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,aAAa,YAAoC;AACxD,SAAK,YAAY,OAAO,MAAM;AAC9B,UAAM,YAAY,KAAK,YAAY,QAAQ,IAAI,cAAc;AAG7D,aAAS,OAAO,SAAS,GAAG,QAAQ,SAAS,GAAG,QAAQ;AACvD,gBAAU,QAAQ,MAAM;AACvB,mBAAW,WAAW,KAAK,UAAU,KAAK,GAAG;AAC5C,eAAK,SAAS,YAAY,OAAO,aAAa,IAAI,GAAI,WAAW,eAAe,oBAAqB,eAAe,eAAe;AAAA,QACpI;AAAA,MACD,CAAC;AAAA,IACF;AAEA,aAAS,OAAO,SAAS,GAAG,QAAQ,SAAS,GAAG,QAAQ;AACvD,gBAAU,QAAQ,MAAM;AACvB,mBAAW,WAAW,KAAK,UAAU,KAAK,GAAG;AAC5C,eAAK,SAAS,YAAY,OAAO,aAAa,IAAI,GAAI,WAAW,eAAe,oBAAqB,eAAe,eAAe;AAAA,QACpI;AAAA,MACD,CAAC;AAAA,IACF;AAEA,aAAS,OAAO,SAAS,iBAAiB,QAAQ,SAAS,OAAO,QAAQ;AACzE,gBAAU,QAAQ,MAAM;AACvB,mBAAW,WAAW,KAAK,UAAU,KAAK,GAAG;AAC5C,eAAK,SAAS,YAAY,OAAO,aAAa,IAAI,GAAI,WAAW,eAAe,oBAAqB,eAAe,eAAe;AAAA,QACpI;AAAA,MACD,CAAC;AAAA,IACF;AAAA,EACD;AACD;AA1Ja,eAAN;AAAA,EA+BJ;AAAA,EACA;AAAA,GAhCU;",
  "names": []
}
