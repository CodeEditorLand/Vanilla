{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/browser/gpu/atlas/textureAtlas.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getActiveWindow } from \"../../../../base/browser/dom.js\";\nimport { CharCode } from \"../../../../base/common/charCode.js\";\nimport { Emitter, Event } from \"../../../../base/common/event.js\";\nimport {\n\tDisposable,\n\tMutableDisposable,\n\tdispose,\n\ttoDisposable,\n} from \"../../../../base/common/lifecycle.js\";\nimport { ThreeKeyMap } from \"../../../../base/common/map.js\";\nimport { IInstantiationService } from \"../../../../platform/instantiation/common/instantiation.js\";\nimport { IThemeService } from \"../../../../platform/theme/common/themeService.js\";\nimport { MetadataConsts } from \"../../../common/encodedTokenAttributes.js\";\nimport { GlyphRasterizer } from \"../raster/glyphRasterizer.js\";\nimport type { IGlyphRasterizer } from \"../raster/raster.js\";\nimport { IdleTaskQueue } from \"../taskQueue.js\";\nimport type {\n\tGlyphMap,\n\tIReadableTextureAtlasPage,\n\tITextureAtlasPageGlyph,\n} from \"./atlas.js\";\nimport { type AllocatorType, TextureAtlasPage } from \"./textureAtlasPage.js\";\n\nexport interface ITextureAtlasOptions {\n\tallocatorType?: AllocatorType;\n}\n\nexport class TextureAtlas extends Disposable {\n\tprivate _colorMap!: string[];\n\tprivate readonly _warmUpTask: MutableDisposable<IdleTaskQueue> =\n\t\tthis._register(new MutableDisposable());\n\tprivate readonly _warmedUpRasterizers = new Set<number>();\n\tprivate readonly _allocatorType: AllocatorType;\n\n\t/**\n\t * The main texture atlas pages which are both larger textures and more efficiently packed\n\t * relative to the scratch page. The idea is the main pages are drawn to and uploaded to the GPU\n\t * much less frequently so as to not drop frames.\n\t */\n\tprivate readonly _pages: TextureAtlasPage[] = [];\n\tget pages(): IReadableTextureAtlasPage[] {\n\t\treturn this._pages;\n\t}\n\n\treadonly pageSize: number;\n\n\t/**\n\t * A maps of glyph keys to the page to start searching for the glyph. This is set before\n\t * searching to have as little runtime overhead (branching, intermediate variables) as possible,\n\t * so it is not guaranteed to be the actual page the glyph is on. But it is guaranteed that all\n\t * pages with a lower index do not contain the glyph.\n\t */\n\tprivate readonly _glyphPageIndex: GlyphMap<number> = new ThreeKeyMap();\n\n\tprivate readonly _onDidDeleteGlyphs = this._register(new Emitter<void>());\n\treadonly onDidDeleteGlyphs = this._onDidDeleteGlyphs.event;\n\n\tconstructor(\n\t\t/** The maximum texture size supported by the GPU. */\n\t\tprivate readonly _maxTextureSize: number,\n\t\toptions: ITextureAtlasOptions | undefined,\n\t\t@IThemeService private readonly _themeService: IThemeService,\n\t\t@IInstantiationService\n\t\tprivate readonly _instantiationService: IInstantiationService,\n\t) {\n\t\tsuper();\n\n\t\tthis._allocatorType = options?.allocatorType ?? \"slab\";\n\n\t\tthis._register(\n\t\t\tEvent.runAndSubscribe(\n\t\t\t\tthis._themeService.onDidColorThemeChange,\n\t\t\t\t() => {\n\t\t\t\t\t// TODO: Clear entire atlas on theme change\n\t\t\t\t\tthis._colorMap =\n\t\t\t\t\t\tthis._themeService.getColorTheme().tokenColorMap;\n\t\t\t\t},\n\t\t\t),\n\t\t);\n\n\t\tconst dprFactor = Math.max(\n\t\t\t1,\n\t\t\tMath.floor(getActiveWindow().devicePixelRatio),\n\t\t);\n\n\t\tthis.pageSize = Math.min(1024 * dprFactor, this._maxTextureSize);\n\t\tthis._initFirstPage();\n\n\t\tthis._register(toDisposable(() => dispose(this._pages)));\n\t}\n\n\tprivate _initFirstPage() {\n\t\tconst firstPage = this._instantiationService.createInstance(\n\t\t\tTextureAtlasPage,\n\t\t\t0,\n\t\t\tthis.pageSize,\n\t\t\tthis._allocatorType,\n\t\t);\n\t\tthis._pages.push(firstPage);\n\n\t\t// IMPORTANT: The first glyph on the first page must be an empty glyph such that zeroed out\n\t\t// cells end up rendering nothing\n\t\t// TODO: This currently means the first slab is for 0x0 glyphs and is wasted\n\t\tconst nullRasterizer = new GlyphRasterizer(1, \"\");\n\t\tfirstPage.getGlyph(nullRasterizer, \"\", 0);\n\t\tnullRasterizer.dispose();\n\t}\n\n\tclear() {\n\t\t// Clear all pages\n\t\tfor (const page of this._pages) {\n\t\t\tpage.dispose();\n\t\t}\n\t\tthis._pages.length = 0;\n\t\tthis._glyphPageIndex.clear();\n\t\tthis._warmedUpRasterizers.clear();\n\t\tthis._warmUpTask.clear();\n\n\t\t// Recreate first\n\t\tthis._initFirstPage();\n\n\t\t// Tell listeners\n\t\tthis._onDidDeleteGlyphs.fire();\n\t}\n\n\tgetGlyph(\n\t\trasterizer: IGlyphRasterizer,\n\t\tchars: string,\n\t\tmetadata: number,\n\t): Readonly<ITextureAtlasPageGlyph> {\n\t\t// TODO: Encode font size and family into key\n\t\t// Ignore metadata that doesn't affect the glyph\n\t\tmetadata &= ~(\n\t\t\tMetadataConsts.LANGUAGEID_MASK |\n\t\t\tMetadataConsts.TOKEN_TYPE_MASK |\n\t\t\tMetadataConsts.BALANCED_BRACKETS_MASK\n\t\t);\n\n\t\t// Warm up common glyphs\n\t\tif (!this._warmedUpRasterizers.has(rasterizer.id)) {\n\t\t\tthis._warmUpAtlas(rasterizer);\n\t\t\tthis._warmedUpRasterizers.add(rasterizer.id);\n\t\t}\n\n\t\t// Try get the glyph, overflowing to a new page if necessary\n\t\treturn this._tryGetGlyph(\n\t\t\tthis._glyphPageIndex.get(chars, metadata, rasterizer.cacheKey) ?? 0,\n\t\t\trasterizer,\n\t\t\tchars,\n\t\t\tmetadata,\n\t\t);\n\t}\n\n\tprivate _tryGetGlyph(\n\t\tpageIndex: number,\n\t\trasterizer: IGlyphRasterizer,\n\t\tchars: string,\n\t\tmetadata: number,\n\t): Readonly<ITextureAtlasPageGlyph> {\n\t\tthis._glyphPageIndex.set(\n\t\t\tchars,\n\t\t\tmetadata,\n\t\t\trasterizer.cacheKey,\n\t\t\tpageIndex,\n\t\t);\n\t\treturn (\n\t\t\tthis._pages[pageIndex].getGlyph(rasterizer, chars, metadata) ??\n\t\t\t(pageIndex + 1 < this._pages.length\n\t\t\t\t? this._tryGetGlyph(pageIndex + 1, rasterizer, chars, metadata)\n\t\t\t\t: undefined) ??\n\t\t\tthis._getGlyphFromNewPage(rasterizer, chars, metadata)\n\t\t);\n\t}\n\n\tprivate _getGlyphFromNewPage(\n\t\trasterizer: IGlyphRasterizer,\n\t\tchars: string,\n\t\tmetadata: number,\n\t): Readonly<ITextureAtlasPageGlyph> {\n\t\t// TODO: Support more than 2 pages and the GPU texture layer limit\n\t\tthis._pages.push(\n\t\t\tthis._instantiationService.createInstance(\n\t\t\t\tTextureAtlasPage,\n\t\t\t\tthis._pages.length,\n\t\t\t\tthis.pageSize,\n\t\t\t\tthis._allocatorType,\n\t\t\t),\n\t\t);\n\t\tthis._glyphPageIndex.set(\n\t\t\tchars,\n\t\t\tmetadata,\n\t\t\trasterizer.cacheKey,\n\t\t\tthis._pages.length - 1,\n\t\t);\n\t\treturn this._pages[this._pages.length - 1].getGlyph(\n\t\t\trasterizer,\n\t\t\tchars,\n\t\t\tmetadata,\n\t\t)!;\n\t}\n\n\tpublic getUsagePreview(): Promise<Blob[]> {\n\t\treturn Promise.all(this._pages.map((e) => e.getUsagePreview()));\n\t}\n\n\tpublic getStats(): string[] {\n\t\treturn this._pages.map((e) => e.getStats());\n\t}\n\n\t/**\n\t * Warms up the atlas by rasterizing all printable ASCII characters for each token color. This\n\t * is distrubuted over multiple idle callbacks to avoid blocking the main thread.\n\t */\n\tprivate _warmUpAtlas(rasterizer: IGlyphRasterizer): void {\n\t\tthis._warmUpTask.value?.clear();\n\t\tconst taskQueue = (this._warmUpTask.value = new IdleTaskQueue());\n\t\t// Warm up using roughly the larger glyphs first to help optimize atlas allocation\n\t\t// A-Z\n\t\tfor (let code = CharCode.A; code <= CharCode.Z; code++) {\n\t\t\ttaskQueue.enqueue(() => {\n\t\t\t\tfor (const fgColor of this._colorMap.keys()) {\n\t\t\t\t\tthis.getGlyph(\n\t\t\t\t\t\trasterizer,\n\t\t\t\t\t\tString.fromCharCode(code),\n\t\t\t\t\t\t(fgColor << MetadataConsts.FOREGROUND_OFFSET) &\n\t\t\t\t\t\t\tMetadataConsts.FOREGROUND_MASK,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t// a-z\n\t\tfor (let code = CharCode.a; code <= CharCode.z; code++) {\n\t\t\ttaskQueue.enqueue(() => {\n\t\t\t\tfor (const fgColor of this._colorMap.keys()) {\n\t\t\t\t\tthis.getGlyph(\n\t\t\t\t\t\trasterizer,\n\t\t\t\t\t\tString.fromCharCode(code),\n\t\t\t\t\t\t(fgColor << MetadataConsts.FOREGROUND_OFFSET) &\n\t\t\t\t\t\t\tMetadataConsts.FOREGROUND_MASK,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t// Remaining ascii\n\t\tfor (\n\t\t\tlet code = CharCode.ExclamationMark;\n\t\t\tcode <= CharCode.Tilde;\n\t\t\tcode++\n\t\t) {\n\t\t\ttaskQueue.enqueue(() => {\n\t\t\t\tfor (const fgColor of this._colorMap.keys()) {\n\t\t\t\t\tthis.getGlyph(\n\t\t\t\t\t\trasterizer,\n\t\t\t\t\t\tString.fromCharCode(code),\n\t\t\t\t\t\t(fgColor << MetadataConsts.FOREGROUND_OFFSET) &\n\t\t\t\t\t\t\tMetadataConsts.FOREGROUND_MASK,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
