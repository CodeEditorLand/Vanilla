import{getActiveWindow as w}from"../../../../base/browser/dom.js";import{BugIndicatingError as P}from"../../../../base/common/errors.js";import{TwoKeyMap as H}from"../../../../base/common/map.js";import{ensureNonNullable as v}from"../gpuUtils.js";import{UsagePreviewColors as x}from"./atlas.js";class T{constructor(r,l,s){this._canvas=r;this._textureIndex=l;this._ctx=v(this._canvas.getContext("2d",{willReadFrequently:!0})),this._slabW=Math.min(s?.slabW??64<<Math.floor(w().devicePixelRatio)-1,this._canvas.width),this._slabH=Math.min(s?.slabH??this._slabW,this._canvas.height),this._slabsPerRow=Math.floor(this._canvas.width/this._slabW),this._slabsPerColumn=Math.floor(this._canvas.height/this._slabH)}_ctx;_slabs=[];_activeSlabsByDims=new H;_unusedRects=[];_openRegionsByHeight=new Map;_openRegionsByWidth=new Map;_allocatedGlyphs=new Set;_slabW;_slabH;_slabsPerRow;_slabsPerColumn;_nextIndex=0;allocate(r){const l=r.boundingBox.right-r.boundingBox.left+1,s=r.boundingBox.bottom-r.boundingBox.top+1;if(l>this._canvas.width||s>this._canvas.height)throw new P("Glyph is too large for the atlas page");if(l>this._slabW||s>this._slabH){if(this._allocatedGlyphs.size>0)return;let t=this._canvas.width;for(;l<t/2&&s<t/2;)t/=2;this._slabW=t,this._slabH=t,this._slabsPerRow=Math.floor(this._canvas.width/this._slabW),this._slabsPerColumn=Math.floor(this._canvas.height/this._slabH)}const a={w:l,h:s};let i=this._activeSlabsByDims.get(a.w,a.h);if(i){const t=Math.floor(this._slabW/i.entryW)*Math.floor(this._slabH/i.entryH);i.count>=t&&(i=void 0)}let f,c;if(!i)if(l<s){const t=this._openRegionsByWidth.get(l);if(t?.length)for(let o=t.length-1;o>=0;o--){const e=t[o];if(e.w>=l&&e.h>=s){f=e.x,c=e.y,l<e.w&&this._unusedRects.push({x:e.x+l,y:e.y,w:e.w-l,h:s}),e.y+=s,e.h-=s,e.h===0&&(o===t.length-1?t.pop():this._unusedRects.splice(o,1));break}}}else{const t=this._openRegionsByHeight.get(s);if(t?.length)for(let o=t.length-1;o>=0;o--){const e=t[o];if(e.w>=l&&e.h>=s){f=e.x,c=e.y,s<e.h&&this._unusedRects.push({x:e.x,y:e.y+s,w:l,h:e.h-s}),e.x+=l,e.w-=l,e.h===0&&(o===t.length-1?t.pop():this._unusedRects.splice(o,1));break}}}if(f===void 0||c===void 0){if(!i){if(this._slabs.length>=this._slabsPerRow*this._slabsPerColumn)return;i={x:Math.floor(this._slabs.length%this._slabsPerRow)*this._slabW,y:Math.floor(this._slabs.length/this._slabsPerRow)*this._slabH,entryW:a.w,entryH:a.h,count:0};const o=this._slabW%i.entryW,e=this._slabH%i.entryH;o&&R(this._openRegionsByWidth,o,{x:i.x+this._slabW-o,w:o,y:i.y,h:this._slabH-(e??0)}),e&&R(this._openRegionsByHeight,e,{x:i.x,w:this._slabW,y:i.y+this._slabH-e,h:e}),this._slabs.push(i),this._activeSlabsByDims.set(a.w,a.h,i)}const t=Math.floor(this._slabW/i.entryW);f=i.x+Math.floor(i.count%t)*i.entryW,c=i.y+Math.floor(i.count/t)*i.entryH,i.count++}this._ctx.drawImage(r.source,r.boundingBox.left,r.boundingBox.top,l,s,f,c,l,s);const u={pageIndex:this._textureIndex,glyphIndex:this._nextIndex++,x:f,y:c,w:l,h:s,originOffsetX:r.originOffset.x,originOffsetY:r.originOffset.y};return this._allocatedGlyphs.add(u),u}getUsagePreview(){const r=this._canvas.width,l=this._canvas.height,s=new OffscreenCanvas(r,l),a=v(s.getContext("2d"));a.fillStyle=x.Unused,a.fillRect(0,0,r,l);let i=0,f=0,c=0,u=0;const t=64<<Math.floor(w().devicePixelRatio)-1,o=t;for(const n of this._slabs){let b=0,h=0;for(let y=0;y<n.count;y++)b+n.entryW>t&&(b=0,h+=n.entryH),a.fillStyle=x.Wasted,a.fillRect(n.x+b,n.y+h,n.entryW,n.entryH),i+=n.entryW*n.entryH,b+=n.entryW;const d=Math.floor(t/n.entryW),g=Math.floor(o/n.entryH),p=n.entryW*d*n.entryH*g;c+=t*o-p}for(const n of this._allocatedGlyphs)f+=n.w*n.h,a.fillStyle=x.Used,a.fillRect(n.x,n.y,n.w,n.h);const e=Array.from(this._openRegionsByWidth.values()).flat().concat(Array.from(this._openRegionsByHeight.values()).flat());for(const n of e)a.fillStyle=x.Restricted,a.fillRect(n.x,n.y,n.w,n.h),u+=n.w*n.h;return a.globalAlpha=.5,a.drawImage(this._canvas,0,0),a.globalAlpha=1,s.convertToBlob()}getStats(){const r=this._canvas.width,l=this._canvas.height;let s=0,a=0,i=0,f=0,c=0;const u=r*l,t=64<<Math.floor(w().devicePixelRatio)-1,o=t;for(const h of this._slabs){let d=0,g=0;for(let m=0;m<h.count;m++)d+h.entryW>t&&(d=0,g+=h.entryH),s+=h.entryW*h.entryH,d+=h.entryW;const p=Math.floor(t/h.entryW),y=Math.floor(o/h.entryH),W=h.entryW*p*h.entryH*y;i+=t*o-W}for(const h of this._allocatedGlyphs)a+=h.w*h.h;const e=Array.from(this._openRegionsByWidth.values()).flat().concat(Array.from(this._openRegionsByHeight.values()).flat());for(const h of e)c+=h.w*h.h;const n=i-c;f=s-(a-n);const b=a/(a+f+c);return[`page[${this._textureIndex}]:`,`     Total: ${u}px (${r}x${l})`,`      Used: ${a}px (${(a/u*100).toFixed(2)}%)`,`    Wasted: ${f}px (${(f/u*100).toFixed(2)}%)`,`Restricted: ${c}px (${(c/u*100).toFixed(2)}%) (hard to allocate)`,`Efficiency: ${b===1?"100":(b*100).toFixed(2)}%`,`     Slabs: ${this._slabs.length} of ${Math.floor(this._canvas.width/t)*Math.floor(this._canvas.height/o)}`].join(`
`)}}function R(_,r,l){let s=_.get(r);s||(s=[],_.set(r,s)),s.push(l)}export{T as TextureAtlasSlabAllocator};
