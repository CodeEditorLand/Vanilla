{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/browser/gpu/atlas/textureAtlasShelfAllocator.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from \"../../../../base/common/errors.js\";\nimport { ensureNonNullable } from \"../gpuUtils.js\";\nimport type { IRasterizedGlyph } from \"../raster/raster.js\";\nimport {\n\ttype ITextureAtlasAllocator,\n\ttype ITextureAtlasPageGlyph,\n\tUsagePreviewColors,\n} from \"./atlas.js\";\n\n/**\n * The shelf allocator is a simple allocator that places glyphs in rows, starting a new row when the\n * current row is full. Due to its simplicity, it can waste space but it is very fast.\n */\nexport class TextureAtlasShelfAllocator implements ITextureAtlasAllocator {\n\tprivate readonly _ctx: OffscreenCanvasRenderingContext2D;\n\n\tprivate _currentRow: ITextureAtlasShelf = {\n\t\tx: 0,\n\t\ty: 0,\n\t\th: 0,\n\t};\n\n\t/** A set of all glyphs allocated, this is only tracked to enable debug related functionality */\n\tprivate readonly _allocatedGlyphs: Set<Readonly<ITextureAtlasPageGlyph>> =\n\t\tnew Set();\n\n\tprivate _nextIndex = 0;\n\n\tconstructor(\n\t\tprivate readonly _canvas: OffscreenCanvas,\n\t\tprivate readonly _textureIndex: number,\n\t) {\n\t\tthis._ctx = ensureNonNullable(\n\t\t\tthis._canvas.getContext(\"2d\", {\n\t\t\t\twillReadFrequently: true,\n\t\t\t}),\n\t\t);\n\t}\n\n\tpublic allocate(\n\t\trasterizedGlyph: IRasterizedGlyph,\n\t): ITextureAtlasPageGlyph | undefined {\n\t\t// The glyph does not fit into the atlas page\n\t\tconst glyphWidth =\n\t\t\trasterizedGlyph.boundingBox.right -\n\t\t\trasterizedGlyph.boundingBox.left +\n\t\t\t1;\n\t\tconst glyphHeight =\n\t\t\trasterizedGlyph.boundingBox.bottom -\n\t\t\trasterizedGlyph.boundingBox.top +\n\t\t\t1;\n\t\tif (\n\t\t\tglyphWidth > this._canvas.width ||\n\t\t\tglyphHeight > this._canvas.height\n\t\t) {\n\t\t\tthrow new BugIndicatingError(\n\t\t\t\t\"Glyph is too large for the atlas page\",\n\t\t\t);\n\t\t}\n\n\t\t// Finalize and increment row if it doesn't fix horizontally\n\t\tif (\n\t\t\trasterizedGlyph.boundingBox.right -\n\t\t\t\trasterizedGlyph.boundingBox.left +\n\t\t\t\t1 >\n\t\t\tthis._canvas.width - this._currentRow.x\n\t\t) {\n\t\t\tthis._currentRow.x = 0;\n\t\t\tthis._currentRow.y += this._currentRow.h;\n\t\t\tthis._currentRow.h = 1;\n\t\t}\n\n\t\t// Return undefined if there isn't any room left\n\t\tif (\n\t\t\tthis._currentRow.y +\n\t\t\t\trasterizedGlyph.boundingBox.bottom -\n\t\t\t\trasterizedGlyph.boundingBox.top +\n\t\t\t\t1 >\n\t\t\tthis._canvas.height\n\t\t) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Draw glyph\n\t\tthis._ctx.drawImage(\n\t\t\trasterizedGlyph.source,\n\t\t\t// source\n\t\t\trasterizedGlyph.boundingBox.left,\n\t\t\trasterizedGlyph.boundingBox.top,\n\t\t\tglyphWidth,\n\t\t\tglyphHeight,\n\t\t\t// destination\n\t\t\tthis._currentRow.x,\n\t\t\tthis._currentRow.y,\n\t\t\tglyphWidth,\n\t\t\tglyphHeight,\n\t\t);\n\n\t\t// Create glyph object\n\t\tconst glyph: ITextureAtlasPageGlyph = {\n\t\t\tpageIndex: this._textureIndex,\n\t\t\tglyphIndex: this._nextIndex++,\n\t\t\tx: this._currentRow.x,\n\t\t\ty: this._currentRow.y,\n\t\t\tw: glyphWidth,\n\t\t\th: glyphHeight,\n\t\t\toriginOffsetX: rasterizedGlyph.originOffset.x,\n\t\t\toriginOffsetY: rasterizedGlyph.originOffset.y,\n\t\t};\n\n\t\t// Shift current row\n\t\tthis._currentRow.x += glyphWidth;\n\t\tthis._currentRow.h = Math.max(this._currentRow.h, glyphHeight);\n\n\t\t// Set the glyph\n\t\tthis._allocatedGlyphs.add(glyph);\n\n\t\treturn glyph;\n\t}\n\n\tpublic getUsagePreview(): Promise<Blob> {\n\t\tconst w = this._canvas.width;\n\t\tconst h = this._canvas.height;\n\t\tconst canvas = new OffscreenCanvas(w, h);\n\t\tconst ctx = ensureNonNullable(canvas.getContext(\"2d\"));\n\t\tctx.fillStyle = UsagePreviewColors.Unused;\n\t\tctx.fillRect(0, 0, w, h);\n\n\t\tconst rowHeight: Map<number, number> = new Map(); // y -> h\n\t\tconst rowWidth: Map<number, number> = new Map(); // y -> w\n\t\tfor (const g of this._allocatedGlyphs) {\n\t\t\trowHeight.set(g.y, Math.max(rowHeight.get(g.y) ?? 0, g.h));\n\t\t\trowWidth.set(g.y, Math.max(rowWidth.get(g.y) ?? 0, g.x + g.w));\n\t\t}\n\t\tfor (const g of this._allocatedGlyphs) {\n\t\t\tctx.fillStyle = UsagePreviewColors.Used;\n\t\t\tctx.fillRect(g.x, g.y, g.w, g.h);\n\t\t\tctx.fillStyle = UsagePreviewColors.Wasted;\n\t\t\tctx.fillRect(g.x, g.y + g.h, g.w, rowHeight.get(g.y)! - g.h);\n\t\t}\n\t\tfor (const [rowY, rowW] of rowWidth.entries()) {\n\t\t\tif (rowY !== this._currentRow.y) {\n\t\t\t\tctx.fillStyle = UsagePreviewColors.Wasted;\n\t\t\t\tctx.fillRect(rowW, rowY, w - rowW, rowHeight.get(rowY)!);\n\t\t\t}\n\t\t}\n\t\treturn canvas.convertToBlob();\n\t}\n\n\tgetStats(): string {\n\t\tconst w = this._canvas.width;\n\t\tconst h = this._canvas.height;\n\n\t\tlet usedPixels = 0;\n\t\tlet wastedPixels = 0;\n\t\tconst totalPixels = w * h;\n\n\t\tconst rowHeight: Map<number, number> = new Map(); // y -> h\n\t\tconst rowWidth: Map<number, number> = new Map(); // y -> w\n\t\tfor (const g of this._allocatedGlyphs) {\n\t\t\trowHeight.set(g.y, Math.max(rowHeight.get(g.y) ?? 0, g.h));\n\t\t\trowWidth.set(g.y, Math.max(rowWidth.get(g.y) ?? 0, g.x + g.w));\n\t\t}\n\t\tfor (const g of this._allocatedGlyphs) {\n\t\t\tusedPixels += g.w * g.h;\n\t\t\twastedPixels += g.w * (rowHeight.get(g.y)! - g.h);\n\t\t}\n\t\tfor (const [rowY, rowW] of rowWidth.entries()) {\n\t\t\tif (rowY !== this._currentRow.y) {\n\t\t\t\twastedPixels += (w - rowW) * rowHeight.get(rowY)!;\n\t\t\t}\n\t\t}\n\t\treturn [\n\t\t\t`page${this._textureIndex}:`,\n\t\t\t`     Total: ${totalPixels} (${w}x${h})`,\n\t\t\t`      Used: ${usedPixels} (${((usedPixels / totalPixels) * 100).toPrecision(2)}%)`,\n\t\t\t`    Wasted: ${wastedPixels} (${((wastedPixels / totalPixels) * 100).toPrecision(2)}%)`,\n\t\t\t`Efficiency: ${((usedPixels / (usedPixels + wastedPixels)) * 100).toPrecision(2)}%`,\n\t\t].join(\"\\n\");\n\t}\n}\n\ninterface ITextureAtlasShelf {\n\tx: number;\n\ty: number;\n\th: number;\n}\n"],
  "mappings": "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",
  "names": []
}
