{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/browser/gpu/atlas/textureAtlasShelfAllocator.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { ensureNonNullable } from '../gpuUtils.js';\nimport type { IRasterizedGlyph } from '../raster/raster.js';\nimport { UsagePreviewColors, type ITextureAtlasAllocator, type ITextureAtlasPageGlyph } from './atlas.js';\n\n/**\n * The shelf allocator is a simple allocator that places glyphs in rows, starting a new row when the\n * current row is full. Due to its simplicity, it can waste space but it is very fast.\n */\nexport class TextureAtlasShelfAllocator implements ITextureAtlasAllocator {\n\n\tprivate readonly _ctx: OffscreenCanvasRenderingContext2D;\n\n\tprivate _currentRow: ITextureAtlasShelf = {\n\t\tx: 0,\n\t\ty: 0,\n\t\th: 0\n\t};\n\n\t/** A set of all glyphs allocated, this is only tracked to enable debug related functionality */\n\tprivate readonly _allocatedGlyphs: Set<Readonly<ITextureAtlasPageGlyph>> = new Set();\n\n\tprivate _nextIndex = 0;\n\n\tconstructor(\n\t\tprivate readonly _canvas: OffscreenCanvas,\n\t\tprivate readonly _textureIndex: number,\n\t) {\n\t\tthis._ctx = ensureNonNullable(this._canvas.getContext('2d', {\n\t\t\twillReadFrequently: true\n\t\t}));\n\t}\n\n\tpublic allocate(rasterizedGlyph: IRasterizedGlyph): ITextureAtlasPageGlyph | undefined {\n\t\t// The glyph does not fit into the atlas page\n\t\tconst glyphWidth = rasterizedGlyph.boundingBox.right - rasterizedGlyph.boundingBox.left + 1;\n\t\tconst glyphHeight = rasterizedGlyph.boundingBox.bottom - rasterizedGlyph.boundingBox.top + 1;\n\t\tif (glyphWidth > this._canvas.width || glyphHeight > this._canvas.height) {\n\t\t\tthrow new BugIndicatingError('Glyph is too large for the atlas page');\n\t\t}\n\n\t\t// Finalize and increment row if it doesn't fix horizontally\n\t\tif (rasterizedGlyph.boundingBox.right - rasterizedGlyph.boundingBox.left + 1 > this._canvas.width - this._currentRow.x) {\n\t\t\tthis._currentRow.x = 0;\n\t\t\tthis._currentRow.y += this._currentRow.h;\n\t\t\tthis._currentRow.h = 1;\n\t\t}\n\n\t\t// Return undefined if there isn't any room left\n\t\tif (this._currentRow.y + rasterizedGlyph.boundingBox.bottom - rasterizedGlyph.boundingBox.top + 1 > this._canvas.height) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Draw glyph\n\t\tthis._ctx.drawImage(\n\t\t\trasterizedGlyph.source,\n\t\t\t// source\n\t\t\trasterizedGlyph.boundingBox.left,\n\t\t\trasterizedGlyph.boundingBox.top,\n\t\t\tglyphWidth,\n\t\t\tglyphHeight,\n\t\t\t// destination\n\t\t\tthis._currentRow.x,\n\t\t\tthis._currentRow.y,\n\t\t\tglyphWidth,\n\t\t\tglyphHeight\n\t\t);\n\n\t\t// Create glyph object\n\t\tconst glyph: ITextureAtlasPageGlyph = {\n\t\t\tpageIndex: this._textureIndex,\n\t\t\tglyphIndex: this._nextIndex++,\n\t\t\tx: this._currentRow.x,\n\t\t\ty: this._currentRow.y,\n\t\t\tw: glyphWidth,\n\t\t\th: glyphHeight,\n\t\t\toriginOffsetX: rasterizedGlyph.originOffset.x,\n\t\t\toriginOffsetY: rasterizedGlyph.originOffset.y\n\t\t};\n\n\t\t// Shift current row\n\t\tthis._currentRow.x += glyphWidth;\n\t\tthis._currentRow.h = Math.max(this._currentRow.h, glyphHeight);\n\n\t\t// Set the glyph\n\t\tthis._allocatedGlyphs.add(glyph);\n\n\t\treturn glyph;\n\t}\n\n\tpublic getUsagePreview(): Promise<Blob> {\n\t\tconst w = this._canvas.width;\n\t\tconst h = this._canvas.height;\n\t\tconst canvas = new OffscreenCanvas(w, h);\n\t\tconst ctx = ensureNonNullable(canvas.getContext('2d'));\n\t\tctx.fillStyle = UsagePreviewColors.Unused;\n\t\tctx.fillRect(0, 0, w, h);\n\n\t\tconst rowHeight: Map<number, number> = new Map(); // y -> h\n\t\tconst rowWidth: Map<number, number> = new Map(); // y -> w\n\t\tfor (const g of this._allocatedGlyphs) {\n\t\t\trowHeight.set(g.y, Math.max(rowHeight.get(g.y) ?? 0, g.h));\n\t\t\trowWidth.set(g.y, Math.max(rowWidth.get(g.y) ?? 0, g.x + g.w));\n\t\t}\n\t\tfor (const g of this._allocatedGlyphs) {\n\t\t\tctx.fillStyle = UsagePreviewColors.Used;\n\t\t\tctx.fillRect(g.x, g.y, g.w, g.h);\n\t\t\tctx.fillStyle = UsagePreviewColors.Wasted;\n\t\t\tctx.fillRect(g.x, g.y + g.h, g.w, rowHeight.get(g.y)! - g.h);\n\t\t}\n\t\tfor (const [rowY, rowW] of rowWidth.entries()) {\n\t\t\tif (rowY !== this._currentRow.y) {\n\t\t\t\tctx.fillStyle = UsagePreviewColors.Wasted;\n\t\t\t\tctx.fillRect(rowW, rowY, w - rowW, rowHeight.get(rowY)!);\n\t\t\t}\n\t\t}\n\t\treturn canvas.convertToBlob();\n\t}\n\n\tgetStats(): string {\n\t\tconst w = this._canvas.width;\n\t\tconst h = this._canvas.height;\n\n\t\tlet usedPixels = 0;\n\t\tlet wastedPixels = 0;\n\t\tconst totalPixels = w * h;\n\n\t\tconst rowHeight: Map<number, number> = new Map(); // y -> h\n\t\tconst rowWidth: Map<number, number> = new Map(); // y -> w\n\t\tfor (const g of this._allocatedGlyphs) {\n\t\t\trowHeight.set(g.y, Math.max(rowHeight.get(g.y) ?? 0, g.h));\n\t\t\trowWidth.set(g.y, Math.max(rowWidth.get(g.y) ?? 0, g.x + g.w));\n\t\t}\n\t\tfor (const g of this._allocatedGlyphs) {\n\t\t\tusedPixels += g.w * g.h;\n\t\t\twastedPixels += g.w * (rowHeight.get(g.y)! - g.h);\n\t\t}\n\t\tfor (const [rowY, rowW] of rowWidth.entries()) {\n\t\t\tif (rowY !== this._currentRow.y) {\n\t\t\t\twastedPixels += (w - rowW) * rowHeight.get(rowY)!;\n\t\t\t}\n\t\t}\n\t\treturn [\n\t\t\t`page${this._textureIndex}:`,\n\t\t\t`     Total: ${totalPixels} (${w}x${h})`,\n\t\t\t`      Used: ${usedPixels} (${((usedPixels / totalPixels) * 100).toPrecision(2)}%)`,\n\t\t\t`    Wasted: ${wastedPixels} (${((wastedPixels / totalPixels) * 100).toPrecision(2)}%)`,\n\t\t\t`Efficiency: ${((usedPixels / (usedPixels + wastedPixels)) * 100).toPrecision(2)}%`,\n\t\t].join('\\n');\n\t}\n}\n\ninterface ITextureAtlasShelf {\n\tx: number;\n\ty: number;\n\th: number;\n}\n"],
  "mappings": "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",
  "names": []
}
