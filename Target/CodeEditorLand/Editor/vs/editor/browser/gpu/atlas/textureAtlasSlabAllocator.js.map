{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/browser/gpu/atlas/textureAtlasSlabAllocator.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getActiveWindow } from \"../../../../base/browser/dom.js\";\nimport { BugIndicatingError } from \"../../../../base/common/errors.js\";\nimport { TwoKeyMap } from \"../../../../base/common/map.js\";\nimport { ensureNonNullable } from \"../gpuUtils.js\";\nimport type { IRasterizedGlyph } from \"../raster/raster.js\";\nimport {\n\ttype ITextureAtlasAllocator,\n\ttype ITextureAtlasPageGlyph,\n\tUsagePreviewColors,\n} from \"./atlas.js\";\n\nexport interface TextureAtlasSlabAllocatorOptions {\n\tslabW?: number;\n\tslabH?: number;\n}\n\n/**\n * The slab allocator is a more complex allocator that places glyphs in square slabs of a fixed\n * size. Slabs are defined by a small range of glyphs sizes they can house, this places like-sized\n * glyphs in the same slab which reduces wasted space.\n *\n * Slabs also may contain \"unused\" regions on the left and bottom depending on the size of the\n * glyphs they include. This space is used to place very thin or short glyphs, which would otherwise\n * waste a lot of space in their own slab.\n */\nexport class TextureAtlasSlabAllocator implements ITextureAtlasAllocator {\n\tprivate readonly _ctx: OffscreenCanvasRenderingContext2D;\n\n\tprivate readonly _slabs: ITextureAtlasSlab[] = [];\n\tprivate readonly _activeSlabsByDims: TwoKeyMap<\n\t\tnumber,\n\t\tnumber,\n\t\tITextureAtlasSlab\n\t> = new TwoKeyMap();\n\n\tprivate readonly _unusedRects: ITextureAtlasSlabUnusedRect[] = [];\n\n\tprivate readonly _openRegionsByHeight: Map<\n\t\tnumber,\n\t\tITextureAtlasSlabUnusedRect[]\n\t> = new Map();\n\tprivate readonly _openRegionsByWidth: Map<\n\t\tnumber,\n\t\tITextureAtlasSlabUnusedRect[]\n\t> = new Map();\n\n\t/** A set of all glyphs allocated, this is only tracked to enable debug related functionality */\n\tprivate readonly _allocatedGlyphs: Set<Readonly<ITextureAtlasPageGlyph>> =\n\t\tnew Set();\n\n\tprivate _slabW: number;\n\tprivate _slabH: number;\n\tprivate _slabsPerRow: number;\n\tprivate _slabsPerColumn: number;\n\tprivate _nextIndex = 0;\n\n\tconstructor(\n\t\tprivate readonly _canvas: OffscreenCanvas,\n\t\tprivate readonly _textureIndex: number,\n\t\toptions?: TextureAtlasSlabAllocatorOptions,\n\t) {\n\t\tthis._ctx = ensureNonNullable(\n\t\t\tthis._canvas.getContext(\"2d\", {\n\t\t\t\twillReadFrequently: true,\n\t\t\t}),\n\t\t);\n\n\t\tthis._slabW = Math.min(\n\t\t\toptions?.slabW ??\n\t\t\t\t64 << (Math.floor(getActiveWindow().devicePixelRatio) - 1),\n\t\t\tthis._canvas.width,\n\t\t);\n\t\tthis._slabH = Math.min(\n\t\t\toptions?.slabH ?? this._slabW,\n\t\t\tthis._canvas.height,\n\t\t);\n\t\tthis._slabsPerRow = Math.floor(this._canvas.width / this._slabW);\n\t\tthis._slabsPerColumn = Math.floor(this._canvas.height / this._slabH);\n\t}\n\n\tpublic allocate(\n\t\trasterizedGlyph: IRasterizedGlyph,\n\t): ITextureAtlasPageGlyph | undefined {\n\t\t// Find ideal slab, creating it if there is none suitable\n\t\tconst glyphWidth =\n\t\t\trasterizedGlyph.boundingBox.right -\n\t\t\trasterizedGlyph.boundingBox.left +\n\t\t\t1;\n\t\tconst glyphHeight =\n\t\t\trasterizedGlyph.boundingBox.bottom -\n\t\t\trasterizedGlyph.boundingBox.top +\n\t\t\t1;\n\n\t\t// The glyph does not fit into the atlas page, glyphs should never be this large in practice\n\t\tif (\n\t\t\tglyphWidth > this._canvas.width ||\n\t\t\tglyphHeight > this._canvas.height\n\t\t) {\n\t\t\tthrow new BugIndicatingError(\n\t\t\t\t\"Glyph is too large for the atlas page\",\n\t\t\t);\n\t\t}\n\n\t\t// The glyph does not fit into a slab\n\t\tif (glyphWidth > this._slabW || glyphHeight > this._slabH) {\n\t\t\t// Only if this is the allocator's first glyph, resize the slab size to fit the glyph.\n\t\t\tif (this._allocatedGlyphs.size > 0) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\t// Find the largest power of 2 devisor that the glyph fits into, this ensure there is no\n\t\t\t// wasted space outside the allocated slabs.\n\t\t\tlet sizeCandidate = this._canvas.width;\n\t\t\twhile (\n\t\t\t\tglyphWidth < sizeCandidate / 2 &&\n\t\t\t\tglyphHeight < sizeCandidate / 2\n\t\t\t) {\n\t\t\t\tsizeCandidate /= 2;\n\t\t\t}\n\t\t\tthis._slabW = sizeCandidate;\n\t\t\tthis._slabH = sizeCandidate;\n\t\t\tthis._slabsPerRow = Math.floor(this._canvas.width / this._slabW);\n\t\t\tthis._slabsPerColumn = Math.floor(\n\t\t\t\tthis._canvas.height / this._slabH,\n\t\t\t);\n\t\t}\n\n\t\t// const dpr = getActiveWindow().devicePixelRatio;\n\n\t\t// TODO: Include font size as well as DPR in nearestXPixels calculation\n\n\t\t// Round slab glyph dimensions to the nearest x pixels, where x scaled with device pixel ratio\n\t\t// const nearestXPixels = Math.max(1, Math.floor(dpr / 0.5));\n\t\t// const nearestXPixels = Math.max(1, Math.floor(dpr));\n\t\tconst desiredSlabSize = {\n\t\t\t// Nearest square number\n\t\t\t// TODO: This can probably be optimized\n\t\t\t// w: 1 << Math.ceil(Math.sqrt(glyphWidth)),\n\t\t\t// h: 1 << Math.ceil(Math.sqrt(glyphHeight)),\n\n\t\t\t// Nearest x px\n\t\t\t// w: Math.ceil(glyphWidth / nearestXPixels) * nearestXPixels,\n\t\t\t// h: Math.ceil(glyphHeight / nearestXPixels) * nearestXPixels,\n\n\t\t\t// Round odd numbers up\n\t\t\t// w: glyphWidth % 0 === 1 ? glyphWidth + 1 : glyphWidth,\n\t\t\t// h: glyphHeight % 0 === 1 ? glyphHeight + 1 : glyphHeight,\n\n\t\t\t// Exact number only\n\t\t\tw: glyphWidth,\n\t\t\th: glyphHeight,\n\t\t};\n\n\t\t// Get any existing slab\n\t\tlet slab = this._activeSlabsByDims.get(\n\t\t\tdesiredSlabSize.w,\n\t\t\tdesiredSlabSize.h,\n\t\t);\n\n\t\t// Check if the slab is full\n\t\tif (slab) {\n\t\t\tconst glyphsPerSlab =\n\t\t\t\tMath.floor(this._slabW / slab.entryW) *\n\t\t\t\tMath.floor(this._slabH / slab.entryH);\n\t\t\tif (slab.count >= glyphsPerSlab) {\n\t\t\t\tslab = undefined;\n\t\t\t}\n\t\t}\n\n\t\tlet dx: number | undefined;\n\t\tlet dy: number | undefined;\n\n\t\t// Search for suitable space in unused rectangles\n\t\tif (!slab) {\n\t\t\t// Only check availability for the smallest side\n\t\t\tif (glyphWidth < glyphHeight) {\n\t\t\t\tconst openRegions = this._openRegionsByWidth.get(glyphWidth);\n\t\t\t\tif (openRegions?.length) {\n\t\t\t\t\t// TODO: Don't search everything?\n\t\t\t\t\t// Search from the end so we can typically pop it off the stack\n\t\t\t\t\tfor (let i = openRegions.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tconst r = openRegions[i];\n\t\t\t\t\t\tif (r.w >= glyphWidth && r.h >= glyphHeight) {\n\t\t\t\t\t\t\tdx = r.x;\n\t\t\t\t\t\t\tdy = r.y;\n\t\t\t\t\t\t\tif (glyphWidth < r.w) {\n\t\t\t\t\t\t\t\tthis._unusedRects.push({\n\t\t\t\t\t\t\t\t\tx: r.x + glyphWidth,\n\t\t\t\t\t\t\t\t\ty: r.y,\n\t\t\t\t\t\t\t\t\tw: r.w - glyphWidth,\n\t\t\t\t\t\t\t\t\th: glyphHeight,\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tr.y += glyphHeight;\n\t\t\t\t\t\t\tr.h -= glyphHeight;\n\t\t\t\t\t\t\tif (r.h === 0) {\n\t\t\t\t\t\t\t\tif (i === openRegions.length - 1) {\n\t\t\t\t\t\t\t\t\topenRegions.pop();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthis._unusedRects.splice(i, 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst openRegions = this._openRegionsByHeight.get(glyphHeight);\n\t\t\t\tif (openRegions?.length) {\n\t\t\t\t\t// TODO: Don't search everything?\n\t\t\t\t\t// Search from the end so we can typically pop it off the stack\n\t\t\t\t\tfor (let i = openRegions.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tconst r = openRegions[i];\n\t\t\t\t\t\tif (r.w >= glyphWidth && r.h >= glyphHeight) {\n\t\t\t\t\t\t\tdx = r.x;\n\t\t\t\t\t\t\tdy = r.y;\n\t\t\t\t\t\t\tif (glyphHeight < r.h) {\n\t\t\t\t\t\t\t\tthis._unusedRects.push({\n\t\t\t\t\t\t\t\t\tx: r.x,\n\t\t\t\t\t\t\t\t\ty: r.y + glyphHeight,\n\t\t\t\t\t\t\t\t\tw: glyphWidth,\n\t\t\t\t\t\t\t\t\th: r.h - glyphHeight,\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tr.x += glyphWidth;\n\t\t\t\t\t\t\tr.w -= glyphWidth;\n\t\t\t\t\t\t\tif (r.h === 0) {\n\t\t\t\t\t\t\t\tif (i === openRegions.length - 1) {\n\t\t\t\t\t\t\t\t\topenRegions.pop();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthis._unusedRects.splice(i, 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Create a new slab\n\t\tif (dx === undefined || dy === undefined) {\n\t\t\tif (!slab) {\n\t\t\t\tif (\n\t\t\t\t\tthis._slabs.length >=\n\t\t\t\t\tthis._slabsPerRow * this._slabsPerColumn\n\t\t\t\t) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\tslab = {\n\t\t\t\t\tx:\n\t\t\t\t\t\tMath.floor(this._slabs.length % this._slabsPerRow) *\n\t\t\t\t\t\tthis._slabW,\n\t\t\t\t\ty:\n\t\t\t\t\t\tMath.floor(this._slabs.length / this._slabsPerRow) *\n\t\t\t\t\t\tthis._slabH,\n\t\t\t\t\tentryW: desiredSlabSize.w,\n\t\t\t\t\tentryH: desiredSlabSize.h,\n\t\t\t\t\tcount: 0,\n\t\t\t\t};\n\t\t\t\t// Track unused regions to use for small glyphs\n\t\t\t\t// +-------------+----+\n\t\t\t\t// |             |    |\n\t\t\t\t// |             |    | <- Unused W region\n\t\t\t\t// |             |    |\n\t\t\t\t// |-------------+----+\n\t\t\t\t// |                  | <- Unused H region\n\t\t\t\t// +------------------+\n\t\t\t\tconst unusedW = this._slabW % slab.entryW;\n\t\t\t\tconst unusedH = this._slabH % slab.entryH;\n\t\t\t\tif (unusedW) {\n\t\t\t\t\taddEntryToMapArray(this._openRegionsByWidth, unusedW, {\n\t\t\t\t\t\tx: slab.x + this._slabW - unusedW,\n\t\t\t\t\t\tw: unusedW,\n\t\t\t\t\t\ty: slab.y,\n\t\t\t\t\t\th: this._slabH - (unusedH ?? 0),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (unusedH) {\n\t\t\t\t\taddEntryToMapArray(this._openRegionsByHeight, unusedH, {\n\t\t\t\t\t\tx: slab.x,\n\t\t\t\t\t\tw: this._slabW,\n\t\t\t\t\t\ty: slab.y + this._slabH - unusedH,\n\t\t\t\t\t\th: unusedH,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tthis._slabs.push(slab);\n\t\t\t\tthis._activeSlabsByDims.set(\n\t\t\t\t\tdesiredSlabSize.w,\n\t\t\t\t\tdesiredSlabSize.h,\n\t\t\t\t\tslab,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst glyphsPerRow = Math.floor(this._slabW / slab.entryW);\n\t\t\tdx = slab.x + Math.floor(slab.count % glyphsPerRow) * slab.entryW;\n\t\t\tdy = slab.y + Math.floor(slab.count / glyphsPerRow) * slab.entryH;\n\n\t\t\t// Shift current row\n\t\t\tslab.count++;\n\t\t}\n\n\t\t// Draw glyph\n\t\tthis._ctx.drawImage(\n\t\t\trasterizedGlyph.source,\n\t\t\t// source\n\t\t\trasterizedGlyph.boundingBox.left,\n\t\t\trasterizedGlyph.boundingBox.top,\n\t\t\tglyphWidth,\n\t\t\tglyphHeight,\n\t\t\t// destination\n\t\t\tdx,\n\t\t\tdy,\n\t\t\tglyphWidth,\n\t\t\tglyphHeight,\n\t\t);\n\n\t\t// Create glyph object\n\t\tconst glyph: ITextureAtlasPageGlyph = {\n\t\t\tpageIndex: this._textureIndex,\n\t\t\tglyphIndex: this._nextIndex++,\n\t\t\tx: dx,\n\t\t\ty: dy,\n\t\t\tw: glyphWidth,\n\t\t\th: glyphHeight,\n\t\t\toriginOffsetX: rasterizedGlyph.originOffset.x,\n\t\t\toriginOffsetY: rasterizedGlyph.originOffset.y,\n\t\t};\n\n\t\t// Set the glyph\n\t\tthis._allocatedGlyphs.add(glyph);\n\n\t\treturn glyph;\n\t}\n\n\tpublic getUsagePreview(): Promise<Blob> {\n\t\tconst w = this._canvas.width;\n\t\tconst h = this._canvas.height;\n\t\tconst canvas = new OffscreenCanvas(w, h);\n\t\tconst ctx = ensureNonNullable(canvas.getContext(\"2d\"));\n\n\t\tctx.fillStyle = UsagePreviewColors.Unused;\n\t\tctx.fillRect(0, 0, w, h);\n\n\t\tlet slabEntryPixels = 0;\n\t\tlet usedPixels = 0;\n\t\tlet slabEdgePixels = 0;\n\t\tlet restrictedPixels = 0;\n\t\tconst slabW =\n\t\t\t64 << (Math.floor(getActiveWindow().devicePixelRatio) - 1);\n\t\tconst slabH = slabW;\n\n\t\t// Draw wasted underneath glyphs first\n\t\tfor (const slab of this._slabs) {\n\t\t\tlet x = 0;\n\t\t\tlet y = 0;\n\t\t\tfor (let i = 0; i < slab.count; i++) {\n\t\t\t\tif (x + slab.entryW > slabW) {\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty += slab.entryH;\n\t\t\t\t}\n\t\t\t\tctx.fillStyle = UsagePreviewColors.Wasted;\n\t\t\t\tctx.fillRect(slab.x + x, slab.y + y, slab.entryW, slab.entryH);\n\n\t\t\t\tslabEntryPixels += slab.entryW * slab.entryH;\n\t\t\t\tx += slab.entryW;\n\t\t\t}\n\t\t\tconst entriesPerRow = Math.floor(slabW / slab.entryW);\n\t\t\tconst entriesPerCol = Math.floor(slabH / slab.entryH);\n\t\t\tconst thisSlabPixels =\n\t\t\t\tslab.entryW * entriesPerRow * slab.entryH * entriesPerCol;\n\t\t\tslabEdgePixels += slabW * slabH - thisSlabPixels;\n\t\t}\n\n\t\t// Draw glyphs\n\t\tfor (const g of this._allocatedGlyphs) {\n\t\t\tusedPixels += g.w * g.h;\n\t\t\tctx.fillStyle = UsagePreviewColors.Used;\n\t\t\tctx.fillRect(g.x, g.y, g.w, g.h);\n\t\t}\n\n\t\t// Draw unused space on side\n\t\tconst unusedRegions = Array.from(this._openRegionsByWidth.values())\n\t\t\t.flat()\n\t\t\t.concat(Array.from(this._openRegionsByHeight.values()).flat());\n\t\tfor (const r of unusedRegions) {\n\t\t\tctx.fillStyle = UsagePreviewColors.Restricted;\n\t\t\tctx.fillRect(r.x, r.y, r.w, r.h);\n\t\t\trestrictedPixels += r.w * r.h;\n\t\t}\n\n\t\t// Overlay actual glyphs on top\n\t\tctx.globalAlpha = 0.5;\n\t\tctx.drawImage(this._canvas, 0, 0);\n\t\tctx.globalAlpha = 1;\n\n\t\treturn canvas.convertToBlob();\n\t}\n\n\tpublic getStats(): string {\n\t\tconst w = this._canvas.width;\n\t\tconst h = this._canvas.height;\n\n\t\tlet slabEntryPixels = 0;\n\t\tlet usedPixels = 0;\n\t\tlet slabEdgePixels = 0;\n\t\tlet wastedPixels = 0;\n\t\tlet restrictedPixels = 0;\n\t\tconst totalPixels = w * h;\n\t\tconst slabW =\n\t\t\t64 << (Math.floor(getActiveWindow().devicePixelRatio) - 1);\n\t\tconst slabH = slabW;\n\n\t\t// Draw wasted underneath glyphs first\n\t\tfor (const slab of this._slabs) {\n\t\t\tlet x = 0;\n\t\t\tlet y = 0;\n\t\t\tfor (let i = 0; i < slab.count; i++) {\n\t\t\t\tif (x + slab.entryW > slabW) {\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty += slab.entryH;\n\t\t\t\t}\n\t\t\t\tslabEntryPixels += slab.entryW * slab.entryH;\n\t\t\t\tx += slab.entryW;\n\t\t\t}\n\t\t\tconst entriesPerRow = Math.floor(slabW / slab.entryW);\n\t\t\tconst entriesPerCol = Math.floor(slabH / slab.entryH);\n\t\t\tconst thisSlabPixels =\n\t\t\t\tslab.entryW * entriesPerRow * slab.entryH * entriesPerCol;\n\t\t\tslabEdgePixels += slabW * slabH - thisSlabPixels;\n\t\t}\n\n\t\t// Draw glyphs\n\t\tfor (const g of this._allocatedGlyphs) {\n\t\t\tusedPixels += g.w * g.h;\n\t\t}\n\n\t\t// Draw unused space on side\n\t\tconst unusedRegions = Array.from(this._openRegionsByWidth.values())\n\t\t\t.flat()\n\t\t\t.concat(Array.from(this._openRegionsByHeight.values()).flat());\n\t\tfor (const r of unusedRegions) {\n\t\t\trestrictedPixels += r.w * r.h;\n\t\t}\n\n\t\tconst edgeUsedPixels = slabEdgePixels - restrictedPixels;\n\t\twastedPixels = slabEntryPixels - (usedPixels - edgeUsedPixels);\n\n\t\t// usedPixels += slabEdgePixels - restrictedPixels;\n\t\tconst efficiency =\n\t\t\tusedPixels / (usedPixels + wastedPixels + restrictedPixels);\n\n\t\treturn [\n\t\t\t`page[${this._textureIndex}]:`,\n\t\t\t`     Total: ${totalPixels}px (${w}x${h})`,\n\t\t\t`      Used: ${usedPixels}px (${((usedPixels / totalPixels) * 100).toFixed(2)}%)`,\n\t\t\t`    Wasted: ${wastedPixels}px (${((wastedPixels / totalPixels) * 100).toFixed(2)}%)`,\n\t\t\t`Restricted: ${restrictedPixels}px (${((restrictedPixels / totalPixels) * 100).toFixed(2)}%) (hard to allocate)`,\n\t\t\t`Efficiency: ${efficiency === 1 ? \"100\" : (efficiency * 100).toFixed(2)}%`,\n\t\t\t`     Slabs: ${this._slabs.length} of ${Math.floor(this._canvas.width / slabW) * Math.floor(this._canvas.height / slabH)}`,\n\t\t].join(\"\\n\");\n\t}\n}\n\ninterface ITextureAtlasSlab {\n\tx: number;\n\ty: number;\n\tentryH: number;\n\tentryW: number;\n\tcount: number;\n}\n\ninterface ITextureAtlasSlabUnusedRect {\n\tx: number;\n\ty: number;\n\tw: number;\n\th: number;\n}\n\nfunction addEntryToMapArray<K, V>(map: Map<K, V[]>, key: K, entry: V) {\n\tlet list = map.get(key);\n\tif (!list) {\n\t\tlist = [];\n\t\tmap.set(key, list);\n\t}\n\tlist.push(entry);\n}\n"],
  "mappings": "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",
  "names": []
}
