{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/browser/gpu/atlas/textureAtlasPage.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../../../base/common/event.js';\nimport { Disposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { TwoKeyMap } from '../../../../base/common/map.js';\nimport { ILogService, LogLevel } from '../../../../platform/log/common/log.js';\nimport { IThemeService } from '../../../../platform/theme/common/themeService.js';\nimport type { IBoundingBox, IGlyphRasterizer } from '../raster/raster.js';\nimport type { IReadableTextureAtlasPage, ITextureAtlasAllocator, ITextureAtlasPageGlyph } from './atlas.js';\nimport { TextureAtlasShelfAllocator } from './textureAtlasShelfAllocator.js';\nimport { TextureAtlasSlabAllocator } from './textureAtlasSlabAllocator.js';\n\nexport type AllocatorType = 'shelf' | 'slab' | ((canvas: OffscreenCanvas, textureIndex: number) => ITextureAtlasAllocator);\n\nexport class TextureAtlasPage extends Disposable implements IReadableTextureAtlasPage {\n\n\tprivate _version: number = 0;\n\tget version(): number { return this._version; }\n\n\t/**\n\t * The maximum number of glyphs that can be drawn to the page. This is currently a hard static\n\t * cap that must not be reached as it will cause the GPU buffer to overflow.\n\t */\n\tstatic readonly maximumGlyphCount = 5_000;\n\n\tprivate _usedArea: IBoundingBox = { left: 0, top: 0, right: 0, bottom: 0 };\n\tpublic get usedArea(): Readonly<IBoundingBox> { return this._usedArea; }\n\n\tprivate readonly _canvas: OffscreenCanvas;\n\tget source(): OffscreenCanvas { return this._canvas; }\n\n\tprivate readonly _glyphMap: TwoKeyMap<string, number, ITextureAtlasPageGlyph> = new TwoKeyMap();\n\tprivate readonly _glyphInOrderSet: Set<ITextureAtlasPageGlyph> = new Set();\n\tget glyphs(): IterableIterator<ITextureAtlasPageGlyph> {\n\t\treturn this._glyphInOrderSet.values();\n\t}\n\n\tprivate readonly _allocator: ITextureAtlasAllocator;\n\tprivate _colorMap!: string[];\n\n\tconstructor(\n\t\ttextureIndex: number,\n\t\tpageSize: number,\n\t\tallocatorType: AllocatorType,\n\t\t@ILogService private readonly _logService: ILogService,\n\t\t@IThemeService private readonly _themeService: IThemeService,\n\t) {\n\t\tsuper();\n\n\t\tthis._canvas = new OffscreenCanvas(pageSize, pageSize);\n\n\t\tswitch (allocatorType) {\n\t\t\tcase 'shelf': this._allocator = new TextureAtlasShelfAllocator(this._canvas, textureIndex); break;\n\t\t\tcase 'slab': this._allocator = new TextureAtlasSlabAllocator(this._canvas, textureIndex); break;\n\t\t\tdefault: this._allocator = allocatorType(this._canvas, textureIndex); break;\n\t\t}\n\n\t\tthis._register(Event.runAndSubscribe(this._themeService.onDidColorThemeChange, () => {\n\t\t\t// TODO: Clear entire atlas on theme change\n\t\t\tthis._colorMap = this._themeService.getColorTheme().tokenColorMap;\n\t\t}));\n\n\t\t// Reduce impact of a memory leak if this object is not released\n\t\tthis._register(toDisposable(() => {\n\t\t\tthis._canvas.width = 1;\n\t\t\tthis._canvas.height = 1;\n\t\t}));\n\t}\n\n\tpublic getGlyph(rasterizer: IGlyphRasterizer, chars: string, metadata: number): Readonly<ITextureAtlasPageGlyph> | undefined {\n\t\t// IMPORTANT: There are intentionally no intermediate variables here to aid in runtime\n\t\t// optimization as it's a very hot function\n\t\treturn this._glyphMap.get(chars, metadata) ?? this._createGlyph(rasterizer, chars, metadata);\n\t}\n\n\tprivate _createGlyph(rasterizer: IGlyphRasterizer, chars: string, metadata: number): Readonly<ITextureAtlasPageGlyph> | undefined {\n\t\t// Ensure the glyph can fit on the page\n\t\tif (this._glyphInOrderSet.size >= TextureAtlasPage.maximumGlyphCount) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Rasterize and allocate the glyph\n\t\tconst rasterizedGlyph = rasterizer.rasterizeGlyph(chars, metadata, this._colorMap);\n\t\tconst glyph = this._allocator.allocate(rasterizedGlyph);\n\n\t\t// Ensure the glyph was allocated\n\t\tif (glyph === undefined) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Save the glyph\n\t\tthis._glyphMap.set(chars, metadata, glyph);\n\t\tthis._glyphInOrderSet.add(glyph);\n\n\t\t// Update page version and it's tracked used area\n\t\tthis._version++;\n\t\tthis._usedArea.right = Math.max(this._usedArea.right, glyph.x + glyph.w - 1);\n\t\tthis._usedArea.bottom = Math.max(this._usedArea.bottom, glyph.y + glyph.h - 1);\n\n\t\tif (this._logService.getLevel() === LogLevel.Trace) {\n\t\t\tthis._logService.trace('New glyph', {\n\t\t\t\tchars,\n\t\t\t\tmetadata,\n\t\t\t\trasterizedGlyph,\n\t\t\t\tglyph\n\t\t\t});\n\t\t}\n\n\t\treturn glyph;\n\t}\n\n\tgetUsagePreview(): Promise<Blob> {\n\t\treturn this._allocator.getUsagePreview();\n\t}\n\n\tgetStats(): string {\n\t\treturn this._allocator.getStats();\n\t}\n}\n"],
  "mappings": ";;;;;;;;;;;;AAKA,SAAS,aAAa;AACtB,SAAS,YAAY,oBAAoB;AACzC,SAAS,iBAAiB;AAC1B,SAAS,aAAa,gBAAgB;AACtC,SAAS,qBAAqB;AAG9B,SAAS,kCAAkC;AAC3C,SAAS,iCAAiC;AAInC,IAAM,mBAAN,cAA+B,WAAgD;AAAA,EA0BrF,YACC,cACA,UACA,eAC8B,aACE,eAC/B;AACD,UAAM;AAHwB;AACE;AAIhC,SAAK,UAAU,IAAI,gBAAgB,UAAU,QAAQ;AAErD,YAAQ,eAAe;AAAA,MACtB,KAAK;AAAS,aAAK,aAAa,IAAI,2BAA2B,KAAK,SAAS,YAAY;AAAG;AAAA,MAC5F,KAAK;AAAQ,aAAK,aAAa,IAAI,0BAA0B,KAAK,SAAS,YAAY;AAAG;AAAA,MAC1F;AAAS,aAAK,aAAa,cAAc,KAAK,SAAS,YAAY;AAAG;AAAA,IACvE;AAEA,SAAK,UAAU,MAAM,gBAAgB,KAAK,cAAc,uBAAuB,MAAM;AAEpF,WAAK,YAAY,KAAK,cAAc,cAAc,EAAE;AAAA,IACrD,CAAC,CAAC;AAGF,SAAK,UAAU,aAAa,MAAM;AACjC,WAAK,QAAQ,QAAQ;AACrB,WAAK,QAAQ,SAAS;AAAA,IACvB,CAAC,CAAC;AAAA,EACH;AAAA,EAtED,OAiBsF;AAAA;AAAA;AAAA,EAE7E,WAAmB;AAAA,EAC3B,IAAI,UAAkB;AAAE,WAAO,KAAK;AAAA,EAAU;AAAA;AAAA;AAAA;AAAA;AAAA,EAM9C,OAAgB,oBAAoB;AAAA,EAE5B,YAA0B,EAAE,MAAM,GAAG,KAAK,GAAG,OAAO,GAAG,QAAQ,EAAE;AAAA,EACzE,IAAW,WAAmC;AAAE,WAAO,KAAK;AAAA,EAAW;AAAA,EAEtD;AAAA,EACjB,IAAI,SAA0B;AAAE,WAAO,KAAK;AAAA,EAAS;AAAA,EAEpC,YAA+D,IAAI,UAAU;AAAA,EAC7E,mBAAgD,oBAAI,IAAI;AAAA,EACzE,IAAI,SAAmD;AACtD,WAAO,KAAK,iBAAiB,OAAO;AAAA,EACrC;AAAA,EAEiB;AAAA,EACT;AAAA,EA+BD,SAAS,YAA8B,OAAe,UAAgE;AAG5H,WAAO,KAAK,UAAU,IAAI,OAAO,QAAQ,KAAK,KAAK,aAAa,YAAY,OAAO,QAAQ;AAAA,EAC5F;AAAA,EAEQ,aAAa,YAA8B,OAAe,UAAgE;AAEjI,QAAI,KAAK,iBAAiB,QAAQ,iBAAiB,mBAAmB;AACrE,aAAO;AAAA,IACR;AAGA,UAAM,kBAAkB,WAAW,eAAe,OAAO,UAAU,KAAK,SAAS;AACjF,UAAM,QAAQ,KAAK,WAAW,SAAS,eAAe;AAGtD,QAAI,UAAU,QAAW;AACxB,aAAO;AAAA,IACR;AAGA,SAAK,UAAU,IAAI,OAAO,UAAU,KAAK;AACzC,SAAK,iBAAiB,IAAI,KAAK;AAG/B,SAAK;AACL,SAAK,UAAU,QAAQ,KAAK,IAAI,KAAK,UAAU,OAAO,MAAM,IAAI,MAAM,IAAI,CAAC;AAC3E,SAAK,UAAU,SAAS,KAAK,IAAI,KAAK,UAAU,QAAQ,MAAM,IAAI,MAAM,IAAI,CAAC;AAE7E,QAAI,KAAK,YAAY,SAAS,MAAM,SAAS,OAAO;AACnD,WAAK,YAAY,MAAM,aAAa;AAAA,QACnC;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACD,CAAC;AAAA,IACF;AAEA,WAAO;AAAA,EACR;AAAA,EAEA,kBAAiC;AAChC,WAAO,KAAK,WAAW,gBAAgB;AAAA,EACxC;AAAA,EAEA,WAAmB;AAClB,WAAO,KAAK,WAAW,SAAS;AAAA,EACjC;AACD;AAxGa,mBAAN;AAAA,EA8BJ;AAAA,EACA;AAAA,GA/BU;",
  "names": []
}
