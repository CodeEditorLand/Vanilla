{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/browser/gpu/atlas/textureAtlasPage.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from \"../../../../base/common/event.js\";\nimport { Disposable, toDisposable } from \"../../../../base/common/lifecycle.js\";\nimport { TwoKeyMap } from \"../../../../base/common/map.js\";\nimport { ILogService, LogLevel } from \"../../../../platform/log/common/log.js\";\nimport { IThemeService } from \"../../../../platform/theme/common/themeService.js\";\nimport type { IBoundingBox, IGlyphRasterizer } from \"../raster/raster.js\";\nimport type {\n\tIReadableTextureAtlasPage,\n\tITextureAtlasAllocator,\n\tITextureAtlasPageGlyph,\n} from \"./atlas.js\";\nimport { TextureAtlasShelfAllocator } from \"./textureAtlasShelfAllocator.js\";\nimport { TextureAtlasSlabAllocator } from \"./textureAtlasSlabAllocator.js\";\n\nexport type AllocatorType =\n\t| \"shelf\"\n\t| \"slab\"\n\t| ((\n\t\t\tcanvas: OffscreenCanvas,\n\t\t\ttextureIndex: number,\n\t  ) => ITextureAtlasAllocator);\n\nexport class TextureAtlasPage\n\textends Disposable\n\timplements IReadableTextureAtlasPage\n{\n\tprivate _version = 0;\n\tget version(): number {\n\t\treturn this._version;\n\t}\n\n\t/**\n\t * The maximum number of glyphs that can be drawn to the page. This is currently a hard static\n\t * cap that must not be reached as it will cause the GPU buffer to overflow.\n\t */\n\tstatic readonly maximumGlyphCount = 5_000;\n\n\tprivate _usedArea: IBoundingBox = { left: 0, top: 0, right: 0, bottom: 0 };\n\tpublic get usedArea(): Readonly<IBoundingBox> {\n\t\treturn this._usedArea;\n\t}\n\n\tprivate readonly _canvas: OffscreenCanvas;\n\tget source(): OffscreenCanvas {\n\t\treturn this._canvas;\n\t}\n\n\tprivate readonly _glyphMap: TwoKeyMap<\n\t\tstring,\n\t\tnumber,\n\t\tITextureAtlasPageGlyph\n\t> = new TwoKeyMap();\n\tprivate readonly _glyphInOrderSet: Set<ITextureAtlasPageGlyph> = new Set();\n\tget glyphs(): IterableIterator<ITextureAtlasPageGlyph> {\n\t\treturn this._glyphInOrderSet.values();\n\t}\n\n\tprivate readonly _allocator: ITextureAtlasAllocator;\n\tprivate _colorMap!: string[];\n\n\tconstructor(\n\t\ttextureIndex: number,\n\t\tpageSize: number,\n\t\tallocatorType: AllocatorType,\n\t\t@ILogService private readonly _logService: ILogService,\n\t\t@IThemeService private readonly _themeService: IThemeService,\n\t) {\n\t\tsuper();\n\n\t\tthis._canvas = new OffscreenCanvas(pageSize, pageSize);\n\n\t\tswitch (allocatorType) {\n\t\t\tcase 'shelf': this._allocator = new TextureAtlasShelfAllocator(this._canvas, textureIndex); break;\n\t\t\tcase 'slab': this._allocator = new TextureAtlasSlabAllocator(this._canvas, textureIndex); break;\n\t\t\tdefault: this._allocator = allocatorType(this._canvas, textureIndex); break;\n\t\t}\n\n\t\tthis._register(Event.runAndSubscribe(this._themeService.onDidColorThemeChange, () => {\n\t\t\t// TODO: Clear entire atlas on theme change\n\t\t\tthis._colorMap = this._themeService.getColorTheme().tokenColorMap;\n\t\t}));\n\n\t\t// Reduce impact of a memory leak if this object is not released\n\t\tthis._register(toDisposable(() => {\n\t\t\tthis._canvas.width = 1;\n\t\t\tthis._canvas.height = 1;\n\t\t}));\n\t}\n\n\tpublic getGlyph(\n\t\trasterizer: IGlyphRasterizer,\n\t\tchars: string,\n\t\tmetadata: number,\n\t): Readonly<ITextureAtlasPageGlyph> | undefined {\n\t\t// IMPORTANT: There are intentionally no intermediate variables here to aid in runtime\n\t\t// optimization as it's a very hot function\n\t\treturn (\n\t\t\tthis._glyphMap.get(chars, metadata) ??\n\t\t\tthis._createGlyph(rasterizer, chars, metadata)\n\t\t);\n\t}\n\n\tprivate _createGlyph(\n\t\trasterizer: IGlyphRasterizer,\n\t\tchars: string,\n\t\tmetadata: number,\n\t): Readonly<ITextureAtlasPageGlyph> | undefined {\n\t\t// Ensure the glyph can fit on the page\n\t\tif (this._glyphInOrderSet.size >= TextureAtlasPage.maximumGlyphCount) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Rasterize and allocate the glyph\n\t\tconst rasterizedGlyph = rasterizer.rasterizeGlyph(\n\t\t\tchars,\n\t\t\tmetadata,\n\t\t\tthis._colorMap,\n\t\t);\n\t\tconst glyph = this._allocator.allocate(rasterizedGlyph);\n\n\t\t// Ensure the glyph was allocated\n\t\tif (glyph === undefined) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Save the glyph\n\t\tthis._glyphMap.set(chars, metadata, glyph);\n\t\tthis._glyphInOrderSet.add(glyph);\n\n\t\t// Update page version and it's tracked used area\n\t\tthis._version++;\n\t\tthis._usedArea.right = Math.max(\n\t\t\tthis._usedArea.right,\n\t\t\tglyph.x + glyph.w - 1,\n\t\t);\n\t\tthis._usedArea.bottom = Math.max(\n\t\t\tthis._usedArea.bottom,\n\t\t\tglyph.y + glyph.h - 1,\n\t\t);\n\n\t\tif (this._logService.getLevel() === LogLevel.Trace) {\n\t\t\tthis._logService.trace(\"New glyph\", {\n\t\t\t\tchars,\n\t\t\t\tmetadata,\n\t\t\t\trasterizedGlyph,\n\t\t\t\tglyph,\n\t\t\t});\n\t\t}\n\n\t\treturn glyph;\n\t}\n\n\tgetUsagePreview(): Promise<Blob> {\n\t\treturn this._allocator.getUsagePreview();\n\t}\n\n\tgetStats(): string {\n\t\treturn this._allocator.getStats();\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
