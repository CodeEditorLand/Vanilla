import{Emitter as o,Event as l}from"../../../base/common/event.js";import{Disposable as f,dispose as c,toDisposable as h}from"../../../base/common/lifecycle.js";import{LinkedList as y}from"../../../base/common/linkedList.js";import{BufferDirtyTracker as u}from"./bufferDirtyTracker.js";function C(a,p){return new d(a,p)}class d extends f{constructor(e,t){super();this.propertySpecs=e;this.capacity=t;this.view=new Float32Array(t*e.length),this.buffer=this.view.buffer,this._entrySize=e.length;for(let r=0;r<e.length;r++){const i={offset:r,...e[r]};this._propertySpecsMap.set(i.name,i)}this._register(h(()=>c(this._entries)))}buffer;view;get bufferUsedSize(){return this.viewUsedSize*Float32Array.BYTES_PER_ELEMENT}get viewUsedSize(){return this._entries.size*this._entrySize}get entryCount(){return this._entries.size}_dirtyTracker=new u;get dirtyTracker(){return this._dirtyTracker}_propertySpecsMap=new Map;_entrySize;_entries=new y;_onDidChange=this._register(new o);onDidChange=this._onDidChange.event;_onDidChangeBuffer=this._register(new o);onDidChangeBuffer=this._onDidChangeBuffer.event;createEntry(e){this._entries.size===this.capacity&&(this._expandBuffer(),this._onDidChangeBuffer.fire());const t=new _(this.view,this._propertySpecsMap,this._dirtyTracker,this._entries.size,e),r=this._entries.push(t),i=[];return i.push(l.forward(t.onDidChange,this._onDidChange)),i.push(t.onWillDispose(()=>{const s=t.i;r(),this.view.set(this.view.subarray(s*this._entrySize+2,this._entries.size*this._entrySize+2),s*this._entrySize);for(const n of this._entries)n.i>s&&n.i--;this._dirtyTracker.flag(s,(this._entries.size-s)*this._entrySize),c(i)})),t}_expandBuffer(){this.capacity*=2;const e=new Float32Array(this.capacity*this._entrySize);e.set(this.view),this.view=e,this.buffer=this.view.buffer}}class _ extends f{constructor(e,t,r,i,s){super();this._view=e;this._propertySpecsMap=t;this._dirtyTracker=r;this.i=i;for(const n of this._propertySpecsMap.values())this._view[this.i*this._propertySpecsMap.size+n.offset]=s[n.name];this._dirtyTracker.flag(this.i*this._propertySpecsMap.size,this._propertySpecsMap.size)}_onDidChange=this._register(new o);onDidChange=this._onDidChange.event;_onWillDispose=this._register(new o);onWillDispose=this._onWillDispose.event;dispose(){this._onWillDispose.fire(),super.dispose()}set(e,t){const r=this.i*this._propertySpecsMap.size+this._propertySpecsMap.get(e).offset;this._view[this._dirtyTracker.flag(r)]=t,this._onDidChange.fire()}get(e){return this._view[this.i*this._propertySpecsMap.size+this._propertySpecsMap.get(e).offset]}setRaw(e){if(e.length!==this._propertySpecsMap.size)throw new Error(`Data length ${e.length} does not match the number of properties in the collection (${this._propertySpecsMap.size})`);this._view.set(e,this.i*this._propertySpecsMap.size),this._dirtyTracker.flag(this.i*this._propertySpecsMap.size,this._propertySpecsMap.size)}}export{C as createObjectCollectionBuffer};
