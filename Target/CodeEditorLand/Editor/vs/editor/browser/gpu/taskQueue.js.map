{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/browser/gpu/taskQueue.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getActiveWindow } from '../../../base/browser/dom.js';\nimport { Disposable, toDisposable } from '../../../base/common/lifecycle.js';\n\n/**\n * Copyright (c) 2022 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\ninterface ITaskQueue {\n\t/**\n\t * Adds a task to the queue which will run in a future idle callback.\n\t * To avoid perceivable stalls on the mainthread, tasks with heavy workload\n\t * should split their work into smaller pieces and return `true` to get\n\t * called again until the work is done (on falsy return value).\n\t */\n\tenqueue(task: () => boolean | void): void;\n\n\t/**\n\t * Flushes the queue, running all remaining tasks synchronously.\n\t */\n\tflush(): void;\n\n\t/**\n\t * Clears any remaining tasks from the queue, these will not be run.\n\t */\n\tclear(): void;\n}\n\ninterface ITaskDeadline {\n\ttimeRemaining(): number;\n}\ntype CallbackWithDeadline = (deadline: ITaskDeadline) => void;\n\nabstract class TaskQueue extends Disposable implements ITaskQueue {\n\tprivate _tasks: (() => boolean | void)[] = [];\n\tprivate _idleCallback?: number;\n\tprivate _i = 0;\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._register(toDisposable(() => this.clear()));\n\t}\n\n\tprotected abstract _requestCallback(callback: CallbackWithDeadline): number;\n\tprotected abstract _cancelCallback(identifier: number): void;\n\n\tpublic enqueue(task: () => boolean | void): void {\n\t\tthis._tasks.push(task);\n\t\tthis._start();\n\t}\n\n\tpublic flush(): void {\n\t\twhile (this._i < this._tasks.length) {\n\t\t\tif (!this._tasks[this._i]()) {\n\t\t\t\tthis._i++;\n\t\t\t}\n\t\t}\n\t\tthis.clear();\n\t}\n\n\tpublic clear(): void {\n\t\tif (this._idleCallback) {\n\t\t\tthis._cancelCallback(this._idleCallback);\n\t\t\tthis._idleCallback = undefined;\n\t\t}\n\t\tthis._i = 0;\n\t\tthis._tasks.length = 0;\n\t}\n\n\tprivate _start(): void {\n\t\tif (!this._idleCallback) {\n\t\t\tthis._idleCallback = this._requestCallback(this._process.bind(this));\n\t\t}\n\t}\n\n\tprivate _process(deadline: ITaskDeadline): void {\n\t\tthis._idleCallback = undefined;\n\t\tlet taskDuration = 0;\n\t\tlet longestTask = 0;\n\t\tlet lastDeadlineRemaining = deadline.timeRemaining();\n\t\tlet deadlineRemaining = 0;\n\t\twhile (this._i < this._tasks.length) {\n\t\t\ttaskDuration = Date.now();\n\t\t\tif (!this._tasks[this._i]()) {\n\t\t\t\tthis._i++;\n\t\t\t}\n\t\t\t// other than performance.now, Date.now might not be stable (changes on wall clock changes),\n\t\t\t// this is not an issue here as a clock change during a short running task is very unlikely\n\t\t\t// in case it still happened and leads to negative duration, simply assume 1 msec\n\t\t\ttaskDuration = Math.max(1, Date.now() - taskDuration);\n\t\t\tlongestTask = Math.max(taskDuration, longestTask);\n\t\t\t// Guess the following task will take a similar time to the longest task in this batch, allow\n\t\t\t// additional room to try avoid exceeding the deadline\n\t\t\tdeadlineRemaining = deadline.timeRemaining();\n\t\t\tif (longestTask * 1.5 > deadlineRemaining) {\n\t\t\t\t// Warn when the time exceeding the deadline is over 20ms, if this happens in practice the\n\t\t\t\t// task should be split into sub-tasks to ensure the UI remains responsive.\n\t\t\t\tif (lastDeadlineRemaining - taskDuration < -20) {\n\t\t\t\t\tconsole.warn(`task queue exceeded allotted deadline by ${Math.abs(Math.round(lastDeadlineRemaining - taskDuration))}ms`);\n\t\t\t\t}\n\t\t\t\tthis._start();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlastDeadlineRemaining = deadlineRemaining;\n\t\t}\n\t\tthis.clear();\n\t}\n}\n\n/**\n * A queue of that runs tasks over several tasks via setTimeout, trying to maintain above 60 frames\n * per second. The tasks will run in the order they are enqueued, but they will run some time later,\n * and care should be taken to ensure they're non-urgent and will not introduce race conditions.\n */\nexport class PriorityTaskQueue extends TaskQueue {\n\tprotected _requestCallback(callback: CallbackWithDeadline): number {\n\t\treturn getActiveWindow().setTimeout(() => callback(this._createDeadline(16)));\n\t}\n\n\tprotected _cancelCallback(identifier: number): void {\n\t\tgetActiveWindow().clearTimeout(identifier);\n\t}\n\n\tprivate _createDeadline(duration: number): ITaskDeadline {\n\t\tconst end = Date.now() + duration;\n\t\treturn {\n\t\t\ttimeRemaining: () => Math.max(0, end - Date.now())\n\t\t};\n\t}\n}\n\n/**\n * A queue of that runs tasks over several idle callbacks, trying to respect the idle callback's\n * deadline given by the environment. The tasks will run in the order they are enqueued, but they\n * will run some time later, and care should be taken to ensure they're non-urgent and will not\n * introduce race conditions.\n */\nexport class IdleTaskQueue extends TaskQueue {\n\tprotected _requestCallback(callback: IdleRequestCallback): number {\n\t\treturn getActiveWindow().requestIdleCallback(callback);\n\t}\n\n\tprotected _cancelCallback(identifier: number): void {\n\t\tgetActiveWindow().cancelIdleCallback(identifier);\n\t}\n}\n\n/**\n * An object that tracks a single debounced task that will run on the next idle frame. When called\n * multiple times, only the last set task will run.\n */\nexport class DebouncedIdleTask {\n\tprivate _queue: ITaskQueue;\n\n\tconstructor() {\n\t\tthis._queue = new IdleTaskQueue();\n\t}\n\n\tpublic set(task: () => boolean | void): void {\n\t\tthis._queue.clear();\n\t\tthis._queue.enqueue(task);\n\t}\n\n\tpublic flush(): void {\n\t\tthis._queue.flush();\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
