{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/browser/gpu/fullFileRenderStrategy.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getActiveWindow } from '../../../base/browser/dom.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { EditorOption } from '../../common/config/editorOptions.js';\nimport type { IViewLineTokens } from '../../common/tokens/lineTokens.js';\nimport type { ViewportData } from '../../common/viewLayout/viewLinesViewportData.js';\nimport type { ViewLineRenderingData } from '../../common/viewModel.js';\nimport type { ViewContext } from '../../common/viewModel/viewContext.js';\nimport type { ViewLineOptions } from '../viewParts/lines/viewLineOptions.js';\nimport type { ITextureAtlasPageGlyph } from './atlas/atlas.js';\nimport type { TextureAtlas } from './atlas/textureAtlas.js';\nimport { fullFileRenderStrategyWgsl } from './fullFileRenderStrategy.wgsl.js';\nimport { BindingId, type IGpuRenderStrategy } from './gpu.js';\nimport { GPULifecycle } from './gpuDisposable.js';\nimport { quadVertices } from './gpuUtils.js';\nimport { GlyphRasterizer } from './raster/glyphRasterizer.js';\n\n\nconst enum Constants {\n\tIndicesPerCell = 6,\n}\n\nconst enum CellBufferInfo {\n\tFloatsPerEntry = 6,\n\tBytesPerEntry = CellBufferInfo.FloatsPerEntry * 4,\n\tOffset_X = 0,\n\tOffset_Y = 1,\n\tOffset_Unused1 = 2,\n\tOffset_Unused2 = 3,\n\tGlyphIndex = 4,\n\tTextureIndex = 5,\n}\n\nexport class FullFileRenderStrategy extends Disposable implements IGpuRenderStrategy {\n\n\tprivate static _lineCount = 3000;\n\tprivate static _columnCount = 200;\n\n\treadonly wgsl: string = fullFileRenderStrategyWgsl;\n\n\tprivate readonly _glyphRasterizer: GlyphRasterizer;\n\n\tprivate _cellBindBuffer!: GPUBuffer;\n\n\t/**\n\t * The cell value buffers, these hold the cells and their glyphs. It's double buffers such that\n\t * the thread doesn't block when one is being uploaded to the GPU.\n\t */\n\tprivate _cellValueBuffers!: [ArrayBuffer, ArrayBuffer];\n\tprivate _activeDoubleBufferIndex: 0 | 1 = 0;\n\n\tprivate readonly _upToDateLines: [Set<number>, Set<number>] = [new Set(), new Set()];\n\tprivate _visibleObjectCount: number = 0;\n\n\tprivate _scrollOffsetBindBuffer!: GPUBuffer;\n\tprivate _scrollOffsetValueBuffers!: [Float32Array, Float32Array];\n\n\tget bindGroupEntries(): GPUBindGroupEntry[] {\n\t\treturn [\n\t\t\t{ binding: BindingId.Cells, resource: { buffer: this._cellBindBuffer } },\n\t\t\t{ binding: BindingId.ScrollOffset, resource: { buffer: this._scrollOffsetBindBuffer } }\n\t\t];\n\t}\n\n\tconstructor(\n\t\tprivate readonly _context: ViewContext,\n\t\tprivate readonly _device: GPUDevice,\n\t\tprivate readonly _canvas: HTMLCanvasElement,\n\t\tprivate readonly _atlas: TextureAtlas,\n\t) {\n\t\tsuper();\n\n\t\t// TODO: Detect when lines have been tokenized and clear _upToDateLines\n\t\tconst activeWindow = getActiveWindow();\n\t\tconst fontFamily = this._context.configuration.options.get(EditorOption.fontFamily);\n\t\tconst fontSize = Math.ceil(this._context.configuration.options.get(EditorOption.fontSize) * activeWindow.devicePixelRatio);\n\n\t\tthis._glyphRasterizer = this._register(new GlyphRasterizer(fontSize, fontFamily));\n\n\t\tconst bufferSize = FullFileRenderStrategy._lineCount * FullFileRenderStrategy._columnCount * Constants.IndicesPerCell * Float32Array.BYTES_PER_ELEMENT;\n\t\tthis._cellBindBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n\t\t\tlabel: 'Monaco full file cell buffer',\n\t\t\tsize: bufferSize,\n\t\t\tusage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n\t\t})).object;\n\t\tthis._cellValueBuffers = [\n\t\t\tnew ArrayBuffer(bufferSize),\n\t\t\tnew ArrayBuffer(bufferSize),\n\t\t];\n\n\t\tconst scrollOffsetBufferSize = 2;\n\t\tthis._scrollOffsetBindBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n\t\t\tlabel: 'Monaco scroll offset buffer',\n\t\t\tsize: scrollOffsetBufferSize * Float32Array.BYTES_PER_ELEMENT,\n\t\t\tusage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n\t\t})).object;\n\t\tthis._scrollOffsetValueBuffers = [\n\t\t\tnew Float32Array(scrollOffsetBufferSize),\n\t\t\tnew Float32Array(scrollOffsetBufferSize),\n\t\t];\n\t}\n\n\tupdate(viewportData: ViewportData, viewLineOptions: ViewLineOptions): number {\n\t\t// Pre-allocate variables to be shared within the loop - don't trust the JIT compiler to do\n\t\t// this optimization to avoid additional blocking time in garbage collector\n\t\tlet chars = '';\n\t\tlet y = 0;\n\t\tlet x = 0;\n\t\tlet screenAbsoluteX = 0;\n\t\tlet screenAbsoluteY = 0;\n\t\tlet zeroToOneX = 0;\n\t\tlet zeroToOneY = 0;\n\t\tlet wgslX = 0;\n\t\tlet wgslY = 0;\n\t\tlet xOffset = 0;\n\t\tlet glyph: Readonly<ITextureAtlasPageGlyph>;\n\t\tlet cellIndex = 0;\n\n\t\tlet tokenStartIndex = 0;\n\t\tlet tokenEndIndex = 0;\n\t\tlet tokenMetadata = 0;\n\n\t\tlet lineData: ViewLineRenderingData;\n\t\tlet content: string = '';\n\t\tlet fillStartIndex = 0;\n\t\tlet fillEndIndex = 0;\n\n\t\tlet tokens: IViewLineTokens;\n\n\t\tconst activeWindow = getActiveWindow();\n\n\t\t// Update scroll offset\n\t\tconst scrollTop = this._context.viewLayout.getCurrentScrollTop() * activeWindow.devicePixelRatio;\n\t\tconst scrollOffsetBuffer = this._scrollOffsetValueBuffers[this._activeDoubleBufferIndex];\n\t\tscrollOffsetBuffer[1] = scrollTop;\n\t\tthis._device.queue.writeBuffer(this._scrollOffsetBindBuffer, 0, scrollOffsetBuffer);\n\n\t\t// Update cell data\n\t\tconst cellBuffer = new Float32Array(this._cellValueBuffers[this._activeDoubleBufferIndex]);\n\t\tconst lineIndexCount = FullFileRenderStrategy._columnCount * Constants.IndicesPerCell;\n\n\t\tconst upToDateLines = this._upToDateLines[this._activeDoubleBufferIndex];\n\t\tlet dirtyLineStart = Number.MAX_SAFE_INTEGER;\n\t\tlet dirtyLineEnd = 0;\n\n\t\tfor (y = viewportData.startLineNumber; y <= viewportData.endLineNumber; y++) {\n\t\t\t// TODO: Update on dirty lines; is this known by line before rendering?\n\t\t\t// if (upToDateLines.has(y)) {\n\t\t\t// \tcontinue;\n\t\t\t// }\n\t\t\tdirtyLineStart = Math.min(dirtyLineStart, y);\n\t\t\tdirtyLineEnd = Math.max(dirtyLineEnd, y);\n\n\t\t\tlineData = viewportData.getViewLineRenderingData(y);\n\t\t\tcontent = lineData.content;\n\t\t\txOffset = 0;\n\n\t\t\t// See ViewLine#renderLine\n\t\t\t// const renderLineInput = new RenderLineInput(\n\t\t\t// \toptions.useMonospaceOptimizations,\n\t\t\t// \toptions.canUseHalfwidthRightwardsArrow,\n\t\t\t// \tlineData.content,\n\t\t\t// \tlineData.continuesWithWrappedLine,\n\t\t\t// \tlineData.isBasicASCII,\n\t\t\t// \tlineData.containsRTL,\n\t\t\t// \tlineData.minColumn - 1,\n\t\t\t// \tlineData.tokens,\n\t\t\t// \tactualInlineDecorations,\n\t\t\t// \tlineData.tabSize,\n\t\t\t// \tlineData.startVisibleColumn,\n\t\t\t// \toptions.spaceWidth,\n\t\t\t// \toptions.middotWidth,\n\t\t\t// \toptions.wsmiddotWidth,\n\t\t\t// \toptions.stopRenderingLineAfter,\n\t\t\t// \toptions.renderWhitespace,\n\t\t\t// \toptions.renderControlCharacters,\n\t\t\t// \toptions.fontLigatures !== EditorFontLigatures.OFF,\n\t\t\t// \tselectionsOnLine\n\t\t\t// );\n\n\t\t\ttokens = lineData.tokens;\n\t\t\ttokenStartIndex = lineData.minColumn - 1;\n\t\t\ttokenEndIndex = 0;\n\t\t\tfor (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n\t\t\t\ttokenEndIndex = tokens.getEndOffset(tokenIndex);\n\t\t\t\tif (tokenEndIndex <= tokenStartIndex) {\n\t\t\t\t\t// The faux indent part of the line should have no token type\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\n\t\t\t\ttokenMetadata = tokens.getMetadata(tokenIndex);\n\n\t\t\t\t// console.log(`token: start=${tokenStartIndex}, end=${tokenEndIndex}, fg=${colorMap[tokenFg]}`);\n\n\n\t\t\t\tfor (x = tokenStartIndex; x < tokenEndIndex; x++) {\n\t\t\t\t\t// HACK: Prevent rendering past the end of the render buffer\n\t\t\t\t\t// TODO: This needs to move to a dynamic long line rendering strategy\n\t\t\t\t\tif (x > FullFileRenderStrategy._columnCount) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tchars = content.charAt(x);\n\t\t\t\t\tif (chars === ' ') {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (chars === '\\t') {\n\t\t\t\t\t\t// TODO: Pull actual tab size\n\t\t\t\t\t\txOffset += 3;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tglyph = this._atlas.getGlyph(this._glyphRasterizer, chars, tokenMetadata);\n\n\t\t\t\t\t// TODO: Support non-standard character widths\n\t\t\t\t\tscreenAbsoluteX = Math.round((x + xOffset) * viewLineOptions.spaceWidth * activeWindow.devicePixelRatio);\n\t\t\t\t\tscreenAbsoluteY = (\n\t\t\t\t\t\tMath.ceil((\n\t\t\t\t\t\t\t// Top of line including line height\n\t\t\t\t\t\t\tviewportData.relativeVerticalOffset[y - viewportData.startLineNumber] +\n\t\t\t\t\t\t\t// Delta to top of line after line height\n\t\t\t\t\t\t\tMath.floor((viewportData.lineHeight - this._context.configuration.options.get(EditorOption.fontSize)) / 2)\n\t\t\t\t\t\t) * activeWindow.devicePixelRatio)\n\t\t\t\t\t);\n\t\t\t\t\tzeroToOneX = screenAbsoluteX / this._canvas.width;\n\t\t\t\t\tzeroToOneY = screenAbsoluteY / this._canvas.height;\n\t\t\t\t\twgslX = zeroToOneX * 2 - 1;\n\t\t\t\t\twgslY = zeroToOneY * 2 - 1;\n\n\t\t\t\t\tcellIndex = ((y - 1) * FullFileRenderStrategy._columnCount + (x + xOffset)) * Constants.IndicesPerCell;\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.Offset_X] = wgslX;\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.Offset_Y] = -wgslY;\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.GlyphIndex] = glyph.glyphIndex;\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.TextureIndex] = glyph.pageIndex;\n\t\t\t\t}\n\n\t\t\t\ttokenStartIndex = tokenEndIndex;\n\t\t\t}\n\n\t\t\t// Clear to end of line\n\t\t\tfillStartIndex = ((y - 1) * FullFileRenderStrategy._columnCount + (tokenEndIndex + xOffset)) * Constants.IndicesPerCell;\n\t\t\tfillEndIndex = (y * FullFileRenderStrategy._columnCount) * Constants.IndicesPerCell;\n\t\t\tcellBuffer.fill(0, fillStartIndex, fillEndIndex);\n\n\t\t\tupToDateLines.add(y);\n\t\t}\n\n\t\tconst visibleObjectCount = (viewportData.endLineNumber - viewportData.startLineNumber + 1) * lineIndexCount;\n\n\t\t// Only write when there is changed data\n\t\tif (dirtyLineStart <= dirtyLineEnd) {\n\t\t\t// Write buffer and swap it out to unblock writes\n\t\t\tthis._device.queue.writeBuffer(\n\t\t\t\tthis._cellBindBuffer,\n\t\t\t\t(dirtyLineStart - 1) * lineIndexCount * Float32Array.BYTES_PER_ELEMENT,\n\t\t\t\tcellBuffer.buffer,\n\t\t\t\t(dirtyLineStart - 1) * lineIndexCount * Float32Array.BYTES_PER_ELEMENT,\n\t\t\t\t(dirtyLineEnd - dirtyLineStart + 1) * lineIndexCount * Float32Array.BYTES_PER_ELEMENT\n\t\t\t);\n\t\t}\n\n\t\tthis._activeDoubleBufferIndex = this._activeDoubleBufferIndex ? 0 : 1;\n\n\t\tthis._visibleObjectCount = visibleObjectCount;\n\t\treturn visibleObjectCount;\n\t}\n\n\tdraw(pass: GPURenderPassEncoder, viewportData: ViewportData): void {\n\t\tif (this._visibleObjectCount <= 0) {\n\t\t\tthrow new BugIndicatingError('Attempt to draw 0 objects');\n\t\t}\n\t\tpass.draw(\n\t\t\tquadVertices.length / 2,\n\t\t\tthis._visibleObjectCount,\n\t\t\tundefined,\n\t\t\t(viewportData.startLineNumber - 1) * FullFileRenderStrategy._columnCount\n\t\t);\n\t}\n}\n"],
  "mappings": "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",
  "names": ["Constants", "CellBufferInfo"]
}
