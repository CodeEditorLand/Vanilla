{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/browser/gpu/fullFileRenderStrategy.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getActiveWindow } from \"../../../base/browser/dom.js\";\nimport { BugIndicatingError } from \"../../../base/common/errors.js\";\nimport { Disposable } from \"../../../base/common/lifecycle.js\";\nimport { EditorOption } from \"../../common/config/editorOptions.js\";\nimport { CursorColumns } from \"../../common/core/cursorColumns.js\";\nimport type { IViewLineTokens } from \"../../common/tokens/lineTokens.js\";\nimport type { ViewportData } from \"../../common/viewLayout/viewLinesViewportData.js\";\nimport type { ViewLineRenderingData } from \"../../common/viewModel.js\";\nimport type { ViewContext } from \"../../common/viewModel/viewContext.js\";\nimport type { ViewLineOptions } from \"../viewParts/viewLines/viewLineOptions.js\";\nimport type { ITextureAtlasPageGlyph } from \"./atlas/atlas.js\";\nimport type { TextureAtlas } from \"./atlas/textureAtlas.js\";\nimport { fullFileRenderStrategyWgsl } from \"./fullFileRenderStrategy.wgsl.js\";\nimport { BindingId, type IGpuRenderStrategy } from \"./gpu.js\";\nimport { GPULifecycle } from \"./gpuDisposable.js\";\nimport { quadVertices } from \"./gpuUtils.js\";\nimport { GlyphRasterizer } from \"./raster/glyphRasterizer.js\";\nimport { ViewGpuContext } from \"./viewGpuContext.js\";\n\nenum Constants {\n\tIndicesPerCell = 6,\n}\n\nenum CellBufferInfo {\n\tFloatsPerEntry = 6,\n\tBytesPerEntry = CellBufferInfo.FloatsPerEntry * 4,\n\tOffset_X = 0,\n\tOffset_Y = 1,\n\tOffset_Unused1 = 2,\n\tOffset_Unused2 = 3,\n\tGlyphIndex = 4,\n\tTextureIndex = 5,\n}\n\nexport class FullFileRenderStrategy\n\textends Disposable\n\timplements IGpuRenderStrategy\n{\n\tprivate static _lineCount = 3000;\n\tprivate static _columnCount = 200;\n\n\treadonly wgsl: string = fullFileRenderStrategyWgsl;\n\n\tprivate readonly _glyphRasterizer: GlyphRasterizer;\n\n\tprivate _cellBindBuffer!: GPUBuffer;\n\n\t/**\n\t * The cell value buffers, these hold the cells and their glyphs. It's double buffers such that\n\t * the thread doesn't block when one is being uploaded to the GPU.\n\t */\n\tprivate _cellValueBuffers!: [ArrayBuffer, ArrayBuffer];\n\tprivate _activeDoubleBufferIndex: 0 | 1 = 0;\n\n\tprivate readonly _upToDateLines: [Set<number>, Set<number>] = [\n\t\tnew Set(),\n\t\tnew Set(),\n\t];\n\tprivate _visibleObjectCount = 0;\n\n\tprivate _scrollOffsetBindBuffer!: GPUBuffer;\n\tprivate _scrollOffsetValueBuffers!: [Float32Array, Float32Array];\n\n\tget bindGroupEntries(): GPUBindGroupEntry[] {\n\t\treturn [\n\t\t\t{\n\t\t\t\tbinding: BindingId.Cells,\n\t\t\t\tresource: { buffer: this._cellBindBuffer },\n\t\t\t},\n\t\t\t{\n\t\t\t\tbinding: BindingId.ScrollOffset,\n\t\t\t\tresource: { buffer: this._scrollOffsetBindBuffer },\n\t\t\t},\n\t\t];\n\t}\n\n\tconstructor(\n\t\tprivate readonly _context: ViewContext,\n\t\tprivate readonly _device: GPUDevice,\n\t\tprivate readonly _canvas: HTMLCanvasElement,\n\t\tprivate readonly _atlas: TextureAtlas,\n\t) {\n\t\tsuper();\n\n\t\t// TODO: Detect when lines have been tokenized and clear _upToDateLines\n\t\tconst fontFamily = this._context.configuration.options.get(\n\t\t\tEditorOption.fontFamily,\n\t\t);\n\t\tconst fontSize = this._context.configuration.options.get(\n\t\t\tEditorOption.fontSize,\n\t\t);\n\n\t\tthis._glyphRasterizer = this._register(\n\t\t\tnew GlyphRasterizer(fontSize, fontFamily),\n\t\t);\n\n\t\tconst bufferSize =\n\t\t\tFullFileRenderStrategy._lineCount *\n\t\t\tFullFileRenderStrategy._columnCount *\n\t\t\tConstants.IndicesPerCell *\n\t\t\tFloat32Array.BYTES_PER_ELEMENT;\n\t\tthis._cellBindBuffer = this._register(\n\t\t\tGPULifecycle.createBuffer(this._device, {\n\t\t\t\tlabel: \"Monaco full file cell buffer\",\n\t\t\t\tsize: bufferSize,\n\t\t\t\tusage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n\t\t\t}),\n\t\t).object;\n\t\tthis._cellValueBuffers = [\n\t\t\tnew ArrayBuffer(bufferSize),\n\t\t\tnew ArrayBuffer(bufferSize),\n\t\t];\n\n\t\tconst scrollOffsetBufferSize = 2;\n\t\tthis._scrollOffsetBindBuffer = this._register(\n\t\t\tGPULifecycle.createBuffer(this._device, {\n\t\t\t\tlabel: \"Monaco scroll offset buffer\",\n\t\t\t\tsize: scrollOffsetBufferSize * Float32Array.BYTES_PER_ELEMENT,\n\t\t\t\tusage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n\t\t\t}),\n\t\t).object;\n\t\tthis._scrollOffsetValueBuffers = [\n\t\t\tnew Float32Array(scrollOffsetBufferSize),\n\t\t\tnew Float32Array(scrollOffsetBufferSize),\n\t\t];\n\t}\n\n\treset() {\n\t\tfor (const bufferIndex of [0, 1]) {\n\t\t\t// Zero out buffer and upload to GPU to prevent stale rows from rendering\n\t\t\tconst buffer = new Float32Array(\n\t\t\t\tthis._cellValueBuffers[bufferIndex],\n\t\t\t);\n\t\t\tbuffer.fill(0, 0, buffer.length);\n\t\t\tthis._device.queue.writeBuffer(\n\t\t\t\tthis._cellBindBuffer,\n\t\t\t\t0,\n\t\t\t\tbuffer.buffer,\n\t\t\t\t0,\n\t\t\t\tbuffer.byteLength,\n\t\t\t);\n\t\t\tthis._upToDateLines[bufferIndex].clear();\n\t\t}\n\t\tthis._visibleObjectCount = 0;\n\t}\n\n\tupdate(\n\t\tviewportData: ViewportData,\n\t\tviewLineOptions: ViewLineOptions,\n\t): number {\n\t\t// Pre-allocate variables to be shared within the loop - don't trust the JIT compiler to do\n\t\t// this optimization to avoid additional blocking time in garbage collector\n\t\tlet chars = \"\";\n\t\tlet y = 0;\n\t\tlet x = 0;\n\t\tlet screenAbsoluteX = 0;\n\t\tlet screenAbsoluteY = 0;\n\t\tlet zeroToOneX = 0;\n\t\tlet zeroToOneY = 0;\n\t\tlet wgslX = 0;\n\t\tlet wgslY = 0;\n\t\tlet xOffset = 0;\n\t\tlet glyph: Readonly<ITextureAtlasPageGlyph>;\n\t\tlet cellIndex = 0;\n\n\t\tlet tokenStartIndex = 0;\n\t\tlet tokenEndIndex = 0;\n\t\tlet tokenMetadata = 0;\n\n\t\tlet lineData: ViewLineRenderingData;\n\t\tlet content = \"\";\n\t\tlet fillStartIndex = 0;\n\t\tlet fillEndIndex = 0;\n\n\t\tlet tokens: IViewLineTokens;\n\n\t\tconst activeWindow = getActiveWindow();\n\n\t\t// Update scroll offset\n\t\tconst scrollTop =\n\t\t\tthis._context.viewLayout.getCurrentScrollTop() *\n\t\t\tactiveWindow.devicePixelRatio;\n\t\tconst scrollOffsetBuffer =\n\t\t\tthis._scrollOffsetValueBuffers[this._activeDoubleBufferIndex];\n\t\tscrollOffsetBuffer[1] = scrollTop;\n\t\tthis._device.queue.writeBuffer(\n\t\t\tthis._scrollOffsetBindBuffer,\n\t\t\t0,\n\t\t\tscrollOffsetBuffer,\n\t\t);\n\n\t\t// Update cell data\n\t\tconst cellBuffer = new Float32Array(\n\t\t\tthis._cellValueBuffers[this._activeDoubleBufferIndex],\n\t\t);\n\t\tconst lineIndexCount =\n\t\t\tFullFileRenderStrategy._columnCount * Constants.IndicesPerCell;\n\n\t\tconst upToDateLines =\n\t\t\tthis._upToDateLines[this._activeDoubleBufferIndex];\n\t\tlet dirtyLineStart = Number.MAX_SAFE_INTEGER;\n\t\tlet dirtyLineEnd = 0;\n\n\t\tfor (\n\t\t\ty = viewportData.startLineNumber;\n\t\t\ty <= viewportData.endLineNumber;\n\t\t\ty++\n\t\t) {\n\t\t\t// Only attempt to render lines that the GPU renderer can handle\n\t\t\tif (!ViewGpuContext.canRender(viewLineOptions, viewportData, y)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// TODO: Update on dirty lines; is this known by line before rendering?\n\t\t\t// if (upToDateLines.has(y)) {\n\t\t\t// \tcontinue;\n\t\t\t// }\n\t\t\tdirtyLineStart = Math.min(dirtyLineStart, y);\n\t\t\tdirtyLineEnd = Math.max(dirtyLineEnd, y);\n\n\t\t\tlineData = viewportData.getViewLineRenderingData(y);\n\t\t\tcontent = lineData.content;\n\t\t\txOffset = 0;\n\n\t\t\t// See ViewLine#renderLine\n\t\t\t// const renderLineInput = new RenderLineInput(\n\t\t\t// \toptions.useMonospaceOptimizations,\n\t\t\t// \toptions.canUseHalfwidthRightwardsArrow,\n\t\t\t// \tlineData.content,\n\t\t\t// \tlineData.continuesWithWrappedLine,\n\t\t\t// \tlineData.isBasicASCII,\n\t\t\t// \tlineData.containsRTL,\n\t\t\t// \tlineData.minColumn - 1,\n\t\t\t// \tlineData.tokens,\n\t\t\t// \tactualInlineDecorations,\n\t\t\t// \tlineData.tabSize,\n\t\t\t// \tlineData.startVisibleColumn,\n\t\t\t// \toptions.spaceWidth,\n\t\t\t// \toptions.middotWidth,\n\t\t\t// \toptions.wsmiddotWidth,\n\t\t\t// \toptions.stopRenderingLineAfter,\n\t\t\t// \toptions.renderWhitespace,\n\t\t\t// \toptions.renderControlCharacters,\n\t\t\t// \toptions.fontLigatures !== EditorFontLigatures.OFF,\n\t\t\t// \tselectionsOnLine\n\t\t\t// );\n\n\t\t\ttokens = lineData.tokens;\n\t\t\ttokenStartIndex = lineData.minColumn - 1;\n\t\t\ttokenEndIndex = 0;\n\t\t\tfor (\n\t\t\t\tlet tokenIndex = 0, tokensLen = tokens.getCount();\n\t\t\t\ttokenIndex < tokensLen;\n\t\t\t\ttokenIndex++\n\t\t\t) {\n\t\t\t\ttokenEndIndex = tokens.getEndOffset(tokenIndex);\n\t\t\t\tif (tokenEndIndex <= tokenStartIndex) {\n\t\t\t\t\t// The faux indent part of the line should have no token type\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttokenMetadata = tokens.getMetadata(tokenIndex);\n\n\t\t\t\t// console.log(`token: start=${tokenStartIndex}, end=${tokenEndIndex}, fg=${colorMap[tokenFg]}`);\n\n\t\t\t\tfor (x = tokenStartIndex; x < tokenEndIndex; x++) {\n\t\t\t\t\t// HACK: Prevent rendering past the end of the render buffer\n\t\t\t\t\t// TODO: This needs to move to a dynamic long line rendering strategy\n\t\t\t\t\tif (x > FullFileRenderStrategy._columnCount) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tchars = content.charAt(x);\n\t\t\t\t\tif (chars === \" \") {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (chars === \"\\t\") {\n\t\t\t\t\t\txOffset =\n\t\t\t\t\t\t\tCursorColumns.nextRenderTabStop(\n\t\t\t\t\t\t\t\tx + xOffset,\n\t\t\t\t\t\t\t\tlineData.tabSize,\n\t\t\t\t\t\t\t) -\n\t\t\t\t\t\t\tx -\n\t\t\t\t\t\t\t1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tglyph = this._atlas.getGlyph(\n\t\t\t\t\t\tthis._glyphRasterizer,\n\t\t\t\t\t\tchars,\n\t\t\t\t\t\ttokenMetadata,\n\t\t\t\t\t);\n\n\t\t\t\t\t// TODO: Support non-standard character widths\n\t\t\t\t\tscreenAbsoluteX = Math.round(\n\t\t\t\t\t\t(x + xOffset) *\n\t\t\t\t\t\t\tviewLineOptions.spaceWidth *\n\t\t\t\t\t\t\tactiveWindow.devicePixelRatio,\n\t\t\t\t\t);\n\t\t\t\t\tscreenAbsoluteY = Math.ceil(\n\t\t\t\t\t\t// Top of line including line height\n\t\t\t\t\t\t(viewportData.relativeVerticalOffset[\n\t\t\t\t\t\t\ty - viewportData.startLineNumber\n\t\t\t\t\t\t] +\n\t\t\t\t\t\t\t// Delta to top of line after line height\n\t\t\t\t\t\t\tMath.floor(\n\t\t\t\t\t\t\t\t(viewportData.lineHeight -\n\t\t\t\t\t\t\t\t\tthis._context.configuration.options.get(\n\t\t\t\t\t\t\t\t\t\tEditorOption.fontSize,\n\t\t\t\t\t\t\t\t\t)) /\n\t\t\t\t\t\t\t\t\t2,\n\t\t\t\t\t\t\t)) *\n\t\t\t\t\t\t\tactiveWindow.devicePixelRatio,\n\t\t\t\t\t);\n\t\t\t\t\tzeroToOneX = screenAbsoluteX / this._canvas.width;\n\t\t\t\t\tzeroToOneY = screenAbsoluteY / this._canvas.height;\n\t\t\t\t\twgslX = zeroToOneX * 2 - 1;\n\t\t\t\t\twgslY = zeroToOneY * 2 - 1;\n\n\t\t\t\t\tcellIndex =\n\t\t\t\t\t\t((y - 1) * FullFileRenderStrategy._columnCount +\n\t\t\t\t\t\t\t(x + xOffset)) *\n\t\t\t\t\t\tConstants.IndicesPerCell;\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.Offset_X] = wgslX;\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.Offset_Y] = -wgslY;\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.GlyphIndex] =\n\t\t\t\t\t\tglyph.glyphIndex;\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.TextureIndex] =\n\t\t\t\t\t\tglyph.pageIndex;\n\t\t\t\t}\n\n\t\t\t\ttokenStartIndex = tokenEndIndex;\n\t\t\t}\n\n\t\t\t// Clear to end of line\n\t\t\tfillStartIndex =\n\t\t\t\t((y - 1) * FullFileRenderStrategy._columnCount +\n\t\t\t\t\t(tokenEndIndex + xOffset)) *\n\t\t\t\tConstants.IndicesPerCell;\n\t\t\tfillEndIndex =\n\t\t\t\ty *\n\t\t\t\tFullFileRenderStrategy._columnCount *\n\t\t\t\tConstants.IndicesPerCell;\n\t\t\tcellBuffer.fill(0, fillStartIndex, fillEndIndex);\n\n\t\t\tupToDateLines.add(y);\n\t\t}\n\n\t\tconst visibleObjectCount =\n\t\t\t(viewportData.endLineNumber - viewportData.startLineNumber + 1) *\n\t\t\tlineIndexCount;\n\n\t\t// Only write when there is changed data\n\t\tif (dirtyLineStart <= dirtyLineEnd) {\n\t\t\t// Write buffer and swap it out to unblock writes\n\t\t\tthis._device.queue.writeBuffer(\n\t\t\t\tthis._cellBindBuffer,\n\t\t\t\t(dirtyLineStart - 1) *\n\t\t\t\t\tlineIndexCount *\n\t\t\t\t\tFloat32Array.BYTES_PER_ELEMENT,\n\t\t\t\tcellBuffer.buffer,\n\t\t\t\t(dirtyLineStart - 1) *\n\t\t\t\t\tlineIndexCount *\n\t\t\t\t\tFloat32Array.BYTES_PER_ELEMENT,\n\t\t\t\t(dirtyLineEnd - dirtyLineStart + 1) *\n\t\t\t\t\tlineIndexCount *\n\t\t\t\t\tFloat32Array.BYTES_PER_ELEMENT,\n\t\t\t);\n\t\t}\n\n\t\tthis._activeDoubleBufferIndex = this._activeDoubleBufferIndex ? 0 : 1;\n\n\t\tthis._visibleObjectCount = visibleObjectCount;\n\t\treturn visibleObjectCount;\n\t}\n\n\tdraw(pass: GPURenderPassEncoder, viewportData: ViewportData): void {\n\t\tif (this._visibleObjectCount <= 0) {\n\t\t\tthrow new BugIndicatingError(\"Attempt to draw 0 objects\");\n\t\t}\n\t\tpass.draw(\n\t\t\tquadVertices.length / 2,\n\t\t\tthis._visibleObjectCount,\n\t\t\tundefined,\n\t\t\t(viewportData.startLineNumber - 1) *\n\t\t\t\tFullFileRenderStrategy._columnCount,\n\t\t);\n\t}\n}\n"],
  "mappings": "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",
  "names": ["Constants", "CellBufferInfo"]
}
