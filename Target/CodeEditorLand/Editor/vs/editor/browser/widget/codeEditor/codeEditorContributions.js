import{getWindow as r,runWhenWindowIdle as s}from"../../../../base/browser/dom.js";import{onUnexpectedError as a}from"../../../../base/common/errors.js";import{Disposable as d,DisposableMap as c}from"../../../../base/common/lifecycle.js";import"../../editorBrowser.js";import{EditorContributionInstantiation as e}from"../../editorExtensions.js";import"../../../common/editorCommon.js";import"../../../../platform/instantiation/common/instantiation.js";class y extends d{_editor=null;_instantiationService=null;_instances=this._register(new c);_pending=new Map;_finishedInstantiation=[];constructor(){super(),this._finishedInstantiation[e.Eager]=!1,this._finishedInstantiation[e.AfterFirstRender]=!1,this._finishedInstantiation[e.BeforeFirstInteraction]=!1,this._finishedInstantiation[e.Eventually]=!1}initialize(t,i,n){this._editor=t,this._instantiationService=n;for(const o of i){if(this._pending.has(o.id)){a(new Error(`Cannot have two contributions with the same id ${o.id}`));continue}this._pending.set(o.id,o)}this._instantiateSome(e.Eager),this._register(s(r(this._editor.getDomNode()),()=>{this._instantiateSome(e.AfterFirstRender)})),this._register(s(r(this._editor.getDomNode()),()=>{this._instantiateSome(e.BeforeFirstInteraction)})),this._register(s(r(this._editor.getDomNode()),()=>{this._instantiateSome(e.Eventually)},5e3))}saveViewState(){const t={};for(const[i,n]of this._instances)typeof n.saveViewState=="function"&&(t[i]=n.saveViewState());return t}restoreViewState(t){for(const[i,n]of this._instances)typeof n.restoreViewState=="function"&&n.restoreViewState(t[i])}get(t){return this._instantiateById(t),this._instances.get(t)||null}set(t,i){this._instances.set(t,i)}onBeforeInteractionEvent(){this._instantiateSome(e.BeforeFirstInteraction)}onAfterModelAttached(){return s(r(this._editor?.getDomNode()),()=>{this._instantiateSome(e.AfterFirstRender)},50)}_instantiateSome(t){if(this._finishedInstantiation[t])return;this._finishedInstantiation[t]=!0;const i=this._findPendingContributionsByInstantiation(t);for(const n of i)this._instantiateById(n.id)}_findPendingContributionsByInstantiation(t){const i=[];for(const[,n]of this._pending)n.instantiation===t&&i.push(n);return i}_instantiateById(t){const i=this._pending.get(t);if(i){if(this._pending.delete(t),!this._instantiationService||!this._editor)throw new Error("Cannot instantiate contributions before being initialized!");try{const n=this._instantiationService.createInstance(i.ctor,this._editor);this._instances.set(i.id,n),typeof n.restoreViewState=="function"&&(i.instantiation,e.Eager)}catch(n){a(n)}}}}export{y as CodeEditorContributions};
