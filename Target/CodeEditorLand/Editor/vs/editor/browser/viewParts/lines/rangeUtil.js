import{Constants as m}from"../../../../../vs/base/common/uint.js";import{FloatHorizontalRange as g}from"../../../../../vs/editor/browser/view/renderingContext.js";import"../../../../../vs/editor/browser/viewParts/lines/domReadingContext.js";class H{static _handyReadyRange;static _createRange(){return this._handyReadyRange||(this._handyReadyRange=document.createRange()),this._handyReadyRange}static _detachRange(t,n){t.selectNodeContents(n)}static _readClientRects(t,n,l,e,a){const i=this._createRange();try{return i.setStart(t,n),i.setEnd(l,e),i.getClientRects()}catch{return null}finally{this._detachRange(i,a)}}static _mergeAdjacentRanges(t){if(t.length===1)return t;t.sort(g.compare);const n=[];let l=0,e=t[0];for(let a=1,i=t.length;a<i;a++){const r=t[a];e.left+e.width+.9>=r.left?e.width=Math.max(e.width,r.left+r.width-e.left):(n[l++]=e,e=r)}return n[l++]=e,n}static _createHorizontalRangesFromClientRects(t,n,l){if(!t||t.length===0)return null;const e=[];for(let a=0,i=t.length;a<i;a++){const r=t[a];e[a]=new g(Math.max(0,(r.left-n)/l),r.width/l)}return this._mergeAdjacentRanges(e)}static readHorizontalRanges(t,n,l,e,a,i){const R=t.children.length-1;if(0>R)return null;if(n=Math.min(R,Math.max(0,n)),e=Math.min(R,Math.max(0,e)),n===e&&l===a&&l===0&&!t.children[n].firstChild){const u=t.children[n].getClientRects();return i.markDidDomLayout(),this._createHorizontalRangesFromClientRects(u,i.clientRectDeltaLeft,i.clientRectScale)}n!==e&&e>0&&a===0&&(e--,a=m.MAX_SAFE_SMALL_INTEGER);let o=t.children[n].firstChild,c=t.children[e].firstChild;if((!o||!c)&&(!o&&l===0&&n>0&&(o=t.children[n-1].firstChild,l=m.MAX_SAFE_SMALL_INTEGER),!c&&a===0&&e>0&&(c=t.children[e-1].firstChild,a=m.MAX_SAFE_SMALL_INTEGER)),!o||!c)return null;l=Math.min(o.textContent.length,Math.max(0,l)),a=Math.min(c.textContent.length,Math.max(0,a));const h=this._readClientRects(o,l,c,a,i.endNode);return i.markDidDomLayout(),this._createHorizontalRangesFromClientRects(h,i.clientRectDeltaLeft,i.clientRectScale)}}export{H as RangeUtil};
