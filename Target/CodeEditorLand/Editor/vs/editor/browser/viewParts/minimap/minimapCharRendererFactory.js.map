{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/browser/viewParts/minimap/minimapCharRendererFactory.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { MinimapCharRenderer } from './minimapCharRenderer.js';\nimport { allCharCodes, Constants } from './minimapCharSheet.js';\nimport { prebakedMiniMaps } from './minimapPreBaked.js';\nimport { toUint8 } from '../../../../base/common/uint.js';\n\n/**\n * Creates character renderers. It takes a 'scale' that determines how large\n * characters should be drawn. Using this, it draws data into a canvas and\n * then downsamples the characters as necessary for the current display.\n * This makes rendering more efficient, rather than drawing a full (tiny)\n * font, or downsampling in real-time.\n */\nexport class MinimapCharRendererFactory {\n\tprivate static lastCreated?: MinimapCharRenderer;\n\tprivate static lastFontFamily?: string;\n\n\t/**\n\t * Creates a new character renderer factory with the given scale.\n\t */\n\tpublic static create(scale: number, fontFamily: string) {\n\t\t// renderers are immutable. By default we'll 'create' a new minimap\n\t\t// character renderer whenever we switch editors, no need to do extra work.\n\t\tif (this.lastCreated && scale === this.lastCreated.scale && fontFamily === this.lastFontFamily) {\n\t\t\treturn this.lastCreated;\n\t\t}\n\n\t\tlet factory: MinimapCharRenderer;\n\t\tif (prebakedMiniMaps[scale]) {\n\t\t\tfactory = new MinimapCharRenderer(prebakedMiniMaps[scale](), scale);\n\t\t} else {\n\t\t\tfactory = MinimapCharRendererFactory.createFromSampleData(\n\t\t\t\tMinimapCharRendererFactory.createSampleData(fontFamily).data,\n\t\t\t\tscale\n\t\t\t);\n\t\t}\n\n\t\tthis.lastFontFamily = fontFamily;\n\t\tthis.lastCreated = factory;\n\t\treturn factory;\n\t}\n\n\t/**\n\t * Creates the font sample data, writing to a canvas.\n\t */\n\tpublic static createSampleData(fontFamily: string): ImageData {\n\t\tconst canvas = document.createElement('canvas');\n\t\tconst ctx = canvas.getContext('2d')!;\n\n\t\tcanvas.style.height = `${Constants.SAMPLED_CHAR_HEIGHT}px`;\n\t\tcanvas.height = Constants.SAMPLED_CHAR_HEIGHT;\n\t\tcanvas.width = Constants.CHAR_COUNT * Constants.SAMPLED_CHAR_WIDTH;\n\t\tcanvas.style.width = Constants.CHAR_COUNT * Constants.SAMPLED_CHAR_WIDTH + 'px';\n\n\t\tctx.fillStyle = '#ffffff';\n\t\tctx.font = `bold ${Constants.SAMPLED_CHAR_HEIGHT}px ${fontFamily}`;\n\t\tctx.textBaseline = 'middle';\n\n\t\tlet x = 0;\n\t\tfor (const code of allCharCodes) {\n\t\t\tctx.fillText(String.fromCharCode(code), x, Constants.SAMPLED_CHAR_HEIGHT / 2);\n\t\t\tx += Constants.SAMPLED_CHAR_WIDTH;\n\t\t}\n\n\t\treturn ctx.getImageData(0, 0, Constants.CHAR_COUNT * Constants.SAMPLED_CHAR_WIDTH, Constants.SAMPLED_CHAR_HEIGHT);\n\t}\n\n\t/**\n\t * Creates a character renderer from the canvas sample data.\n\t */\n\tpublic static createFromSampleData(source: Uint8ClampedArray, scale: number): MinimapCharRenderer {\n\t\tconst expectedLength =\n\t\t\tConstants.SAMPLED_CHAR_HEIGHT * Constants.SAMPLED_CHAR_WIDTH * Constants.RGBA_CHANNELS_CNT * Constants.CHAR_COUNT;\n\t\tif (source.length !== expectedLength) {\n\t\t\tthrow new Error('Unexpected source in MinimapCharRenderer');\n\t\t}\n\n\t\tconst charData = MinimapCharRendererFactory._downsample(source, scale);\n\t\treturn new MinimapCharRenderer(charData, scale);\n\t}\n\n\tprivate static _downsampleChar(\n\t\tsource: Uint8ClampedArray,\n\t\tsourceOffset: number,\n\t\tdest: Uint8ClampedArray,\n\t\tdestOffset: number,\n\t\tscale: number\n\t): number {\n\t\tconst width = Constants.BASE_CHAR_WIDTH * scale;\n\t\tconst height = Constants.BASE_CHAR_HEIGHT * scale;\n\n\t\tlet targetIndex = destOffset;\n\t\tlet brightest = 0;\n\n\t\t// This is essentially an ad-hoc rescaling algorithm. Standard approaches\n\t\t// like bicubic interpolation are awesome for scaling between image sizes,\n\t\t// but don't work so well when scaling to very small pixel values, we end\n\t\t// up with blurry, indistinct forms.\n\t\t//\n\t\t// The approach taken here is simply mapping each source pixel to the target\n\t\t// pixels, and taking the weighted values for all pixels in each, and then\n\t\t// averaging them out. Finally we apply an intensity boost in _downsample,\n\t\t// since when scaling to the smallest pixel sizes there's more black space\n\t\t// which causes characters to be much less distinct.\n\t\tfor (let y = 0; y < height; y++) {\n\t\t\t// 1. For this destination pixel, get the source pixels we're sampling\n\t\t\t// from (x1, y1) to the next pixel (x2, y2)\n\t\t\tconst sourceY1 = (y / height) * Constants.SAMPLED_CHAR_HEIGHT;\n\t\t\tconst sourceY2 = ((y + 1) / height) * Constants.SAMPLED_CHAR_HEIGHT;\n\n\t\t\tfor (let x = 0; x < width; x++) {\n\t\t\t\tconst sourceX1 = (x / width) * Constants.SAMPLED_CHAR_WIDTH;\n\t\t\t\tconst sourceX2 = ((x + 1) / width) * Constants.SAMPLED_CHAR_WIDTH;\n\n\t\t\t\t// 2. Sample all of them, summing them up and weighting them. Similar\n\t\t\t\t// to bilinear interpolation.\n\t\t\t\tlet value = 0;\n\t\t\t\tlet samples = 0;\n\t\t\t\tfor (let sy = sourceY1; sy < sourceY2; sy++) {\n\t\t\t\t\tconst sourceRow = sourceOffset + Math.floor(sy) * Constants.RGBA_SAMPLED_ROW_WIDTH;\n\t\t\t\t\tconst yBalance = 1 - (sy - Math.floor(sy));\n\t\t\t\t\tfor (let sx = sourceX1; sx < sourceX2; sx++) {\n\t\t\t\t\t\tconst xBalance = 1 - (sx - Math.floor(sx));\n\t\t\t\t\t\tconst sourceIndex = sourceRow + Math.floor(sx) * Constants.RGBA_CHANNELS_CNT;\n\n\t\t\t\t\t\tconst weight = xBalance * yBalance;\n\t\t\t\t\t\tsamples += weight;\n\t\t\t\t\t\tvalue += ((source[sourceIndex] * source[sourceIndex + 3]) / 255) * weight;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst final = value / samples;\n\t\t\t\tbrightest = Math.max(brightest, final);\n\t\t\t\tdest[targetIndex++] = toUint8(final);\n\t\t\t}\n\t\t}\n\n\t\treturn brightest;\n\t}\n\n\tprivate static _downsample(data: Uint8ClampedArray, scale: number): Uint8ClampedArray {\n\t\tconst pixelsPerCharacter = Constants.BASE_CHAR_HEIGHT * scale * Constants.BASE_CHAR_WIDTH * scale;\n\t\tconst resultLen = pixelsPerCharacter * Constants.CHAR_COUNT;\n\t\tconst result = new Uint8ClampedArray(resultLen);\n\n\t\tlet resultOffset = 0;\n\t\tlet sourceOffset = 0;\n\t\tlet brightest = 0;\n\t\tfor (let charIndex = 0; charIndex < Constants.CHAR_COUNT; charIndex++) {\n\t\t\tbrightest = Math.max(brightest, this._downsampleChar(data, sourceOffset, result, resultOffset, scale));\n\t\t\tresultOffset += pixelsPerCharacter;\n\t\t\tsourceOffset += Constants.SAMPLED_CHAR_WIDTH * Constants.RGBA_CHANNELS_CNT;\n\t\t}\n\n\t\tif (brightest > 0) {\n\t\t\tconst adjust = 255 / brightest;\n\t\t\tfor (let i = 0; i < resultLen; i++) {\n\t\t\t\tresult[i] *= adjust;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
