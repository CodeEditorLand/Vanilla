import*as I from"../../../../vs/base/common/strings.js";import"../../../../vs/editor/common/core/position.js";import{Range as b}from"../../../../vs/editor/common/core/range.js";import{EndOfLinePreference as g}from"../../../../vs/editor/common/model.js";const d=!1;class C{constructor(e,n,i,t,o){this.value=e;this.selectionStart=n;this.selectionEnd=i;this.selection=t;this.newlineCountBeforeSelection=o}static EMPTY=new C("",0,0,null,void 0);toString(){return`[ <${this.value}>, selectionStart: ${this.selectionStart}, selectionEnd: ${this.selectionEnd}]`}static readFromTextArea(e,n){const i=e.getValue(),t=e.getSelectionStart(),o=e.getSelectionEnd();let s;if(n){const a=i.substring(0,t),r=n.value.substring(0,n.selectionStart);a===r&&(s=n.newlineCountBeforeSelection)}return new C(i,t,o,null,s)}collapseSelection(){return this.selectionStart===this.value.length?this:new C(this.value,this.value.length,this.value.length,null,void 0)}writeToTextArea(e,n,i){d&&console.log(`writeToTextArea ${e}: ${this.toString()}`),n.setValue(e,this.value),i&&n.setSelectionRange(e,this.selectionStart,this.selectionEnd)}deduceEditorPosition(e){if(e<=this.selectionStart){const t=this.value.substring(e,this.selectionStart);return this._finishDeduceEditorPosition(this.selection?.getStartPosition()??null,t,-1)}if(e>=this.selectionEnd){const t=this.value.substring(this.selectionEnd,e);return this._finishDeduceEditorPosition(this.selection?.getEndPosition()??null,t,1)}const n=this.value.substring(this.selectionStart,e);if(n.indexOf("\u2026")===-1)return this._finishDeduceEditorPosition(this.selection?.getStartPosition()??null,n,1);const i=this.value.substring(e,this.selectionEnd);return this._finishDeduceEditorPosition(this.selection?.getEndPosition()??null,i,-1)}_finishDeduceEditorPosition(e,n,i){let t=0,o=-1;for(;(o=n.indexOf(`
`,o+1))!==-1;)t++;return[e,i*n.length,t]}static deduceInput(e,n,i){if(!e)return{text:"",replacePrevCharCnt:0,replaceNextCharCnt:0,positionDelta:0};d&&(console.log("------------------------deduceInput"),console.log(`PREVIOUS STATE: ${e.toString()}`),console.log(`CURRENT STATE: ${n.toString()}`));const t=Math.min(I.commonPrefixLength(e.value,n.value),e.selectionStart,n.selectionStart),o=Math.min(I.commonSuffixLength(e.value,n.value),e.value.length-e.selectionEnd,n.value.length-n.selectionEnd),s=e.value.substring(t,e.value.length-o),a=n.value.substring(t,n.value.length-o),r=e.selectionStart-t,u=e.selectionEnd-t,l=n.selectionStart-t,h=n.selectionEnd-t;if(d&&(console.log(`AFTER DIFFING PREVIOUS STATE: <${s}>, selectionStart: ${r}, selectionEnd: ${u}`),console.log(`AFTER DIFFING CURRENT STATE: <${a}>, selectionStart: ${l}, selectionEnd: ${h}`)),l===h){const R=e.selectionStart-t;return d&&console.log(`REMOVE PREVIOUS: ${R} chars`),{text:a,replacePrevCharCnt:R,replaceNextCharCnt:0,positionDelta:0}}const p=u-r;return{text:a,replacePrevCharCnt:p,replaceNextCharCnt:0,positionDelta:0}}static deduceAndroidCompositionInput(e,n){if(!e)return{text:"",replacePrevCharCnt:0,replaceNextCharCnt:0,positionDelta:0};if(d&&(console.log("------------------------deduceAndroidCompositionInput"),console.log(`PREVIOUS STATE: ${e.toString()}`),console.log(`CURRENT STATE: ${n.toString()}`)),e.value===n.value)return{text:"",replacePrevCharCnt:0,replaceNextCharCnt:0,positionDelta:n.selectionEnd-e.selectionEnd};const i=Math.min(I.commonPrefixLength(e.value,n.value),e.selectionEnd),t=Math.min(I.commonSuffixLength(e.value,n.value),e.value.length-e.selectionEnd),o=e.value.substring(i,e.value.length-t),s=n.value.substring(i,n.value.length-t),a=e.selectionStart-i,r=e.selectionEnd-i,u=n.selectionStart-i,l=n.selectionEnd-i;return d&&(console.log(`AFTER DIFFING PREVIOUS STATE: <${o}>, selectionStart: ${a}, selectionEnd: ${r}`),console.log(`AFTER DIFFING CURRENT STATE: <${s}>, selectionStart: ${u}, selectionEnd: ${l}`)),{text:s,replacePrevCharCnt:r,replaceNextCharCnt:o.length-r,positionDelta:l-s.length}}}class m{static _getPageOfLine(e,n){return Math.floor((e-1)/n)}static _getRangeForPage(e,n){const i=e*n,t=i+1,o=i+n;return new b(t,1,o+1,1)}static fromEditorSelection(e,n,i,t){const s=m._getPageOfLine(n.startLineNumber,i),a=m._getRangeForPage(s,i),r=m._getPageOfLine(n.endLineNumber,i),u=m._getRangeForPage(r,i);let l=a.intersectRanges(new b(1,1,n.startLineNumber,n.startColumn));if(t&&e.getValueLengthInRange(l,g.LF)>500){const E=e.modifyPosition(l.getEndPosition(),-500);l=b.fromPositions(E,l.getEndPosition())}const h=e.getValueInRange(l,g.LF),p=e.getLineCount(),R=e.getLineMaxColumn(p);let f=u.intersectRanges(new b(n.endLineNumber,n.endColumn,p,R));if(t&&e.getValueLengthInRange(f,g.LF)>500){const E=e.modifyPosition(f.getStartPosition(),500);f=b.fromPositions(f.getStartPosition(),E)}const S=e.getValueInRange(f,g.LF);let c;if(s===r||s+1===r)c=e.getValueInRange(n,g.LF);else{const E=a.intersectRanges(n),x=u.intersectRanges(n);c=e.getValueInRange(E,g.LF)+"\u2026"+e.getValueInRange(x,g.LF)}return t&&c.length>2*500&&(c=c.substring(0,500)+"\u2026"+c.substring(c.length-500,c.length)),new C(h+c+S,h.length,h.length+c.length,n,l.endLineNumber-l.startLineNumber)}}export{m as PagedScreenReaderStrategy,C as TextAreaState,d as _debugComposition};
