{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/languages/supports/electricCharacter.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { distinct } from '../../../../base/common/arrays.js';\nimport { ScopedLineTokens, ignoreBracketsInToken } from '../supports.js';\nimport { BracketsUtils, RichEditBrackets } from './richEditBrackets.js';\n\n/**\n * Interface used to support electric characters\n * @internal\n */\nexport interface IElectricAction {\n\t// The line will be indented at the same level of the line\n\t// which contains the matching given bracket type.\n\tmatchOpenBracket: string;\n}\n\nexport class BracketElectricCharacterSupport {\n\n\tprivate readonly _richEditBrackets: RichEditBrackets | null;\n\n\tconstructor(richEditBrackets: RichEditBrackets | null) {\n\t\tthis._richEditBrackets = richEditBrackets;\n\t}\n\n\tpublic getElectricCharacters(): string[] {\n\t\tconst result: string[] = [];\n\n\t\tif (this._richEditBrackets) {\n\t\t\tfor (const bracket of this._richEditBrackets.brackets) {\n\t\t\t\tfor (const close of bracket.close) {\n\t\t\t\t\tconst lastChar = close.charAt(close.length - 1);\n\t\t\t\t\tresult.push(lastChar);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn distinct(result);\n\t}\n\n\tpublic onElectricCharacter(character: string, context: ScopedLineTokens, column: number): IElectricAction | null {\n\t\tif (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst tokenIndex = context.findTokenIndexAtOffset(column - 1);\n\t\tif (ignoreBracketsInToken(context.getStandardTokenType(tokenIndex))) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst reversedBracketRegex = this._richEditBrackets.reversedRegex;\n\t\tconst text = context.getLineContent().substring(0, column - 1) + character;\n\n\t\tconst r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, 1, text, 0, text.length);\n\t\tif (!r) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst bracketText = text.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n\n\t\tconst isOpen = this._richEditBrackets.textIsOpenBracket[bracketText];\n\t\tif (isOpen) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst textBeforeBracket = context.getActualLineContentBefore(r.startColumn - 1);\n\t\tif (!/^\\s*$/.test(textBeforeBracket)) {\n\t\t\t// There is other text on the line before the bracket\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\tmatchOpenBracket: bracketText\n\t\t};\n\t}\n}\n"],
  "mappings": ";;AAKA,SAAS,gBAAgB;AACzB,SAAS,kBAAkB,6BAA6B;AACxD,SAAS,eAAe,wBAAwB;AAYzC,MAAM,gCAAgC;AAAA,EAnB7C,OAmB6C;AAAA;AAAA;AAAA,EAE3B;AAAA,EAEjB,YAAY,kBAA2C;AACtD,SAAK,oBAAoB;AAAA,EAC1B;AAAA,EAEO,wBAAkC;AACxC,UAAM,SAAmB,CAAC;AAE1B,QAAI,KAAK,mBAAmB;AAC3B,iBAAW,WAAW,KAAK,kBAAkB,UAAU;AACtD,mBAAW,SAAS,QAAQ,OAAO;AAClC,gBAAM,WAAW,MAAM,OAAO,MAAM,SAAS,CAAC;AAC9C,iBAAO,KAAK,QAAQ;AAAA,QACrB;AAAA,MACD;AAAA,IACD;AAEA,WAAO,SAAS,MAAM;AAAA,EACvB;AAAA,EAEO,oBAAoB,WAAmB,SAA2B,QAAwC;AAChH,QAAI,CAAC,KAAK,qBAAqB,KAAK,kBAAkB,SAAS,WAAW,GAAG;AAC5E,aAAO;AAAA,IACR;AAEA,UAAM,aAAa,QAAQ,uBAAuB,SAAS,CAAC;AAC5D,QAAI,sBAAsB,QAAQ,qBAAqB,UAAU,CAAC,GAAG;AACpE,aAAO;AAAA,IACR;AAEA,UAAM,uBAAuB,KAAK,kBAAkB;AACpD,UAAM,OAAO,QAAQ,eAAe,EAAE,UAAU,GAAG,SAAS,CAAC,IAAI;AAEjE,UAAM,IAAI,cAAc,uBAAuB,sBAAsB,GAAG,MAAM,GAAG,KAAK,MAAM;AAC5F,QAAI,CAAC,GAAG;AACP,aAAO;AAAA,IACR;AAEA,UAAM,cAAc,KAAK,UAAU,EAAE,cAAc,GAAG,EAAE,YAAY,CAAC,EAAE,YAAY;AAEnF,UAAM,SAAS,KAAK,kBAAkB,kBAAkB,WAAW;AACnE,QAAI,QAAQ;AACX,aAAO;AAAA,IACR;AAEA,UAAM,oBAAoB,QAAQ,2BAA2B,EAAE,cAAc,CAAC;AAC9E,QAAI,CAAC,QAAQ,KAAK,iBAAiB,GAAG;AAErC,aAAO;AAAA,IACR;AAEA,WAAO;AAAA,MACN,kBAAkB;AAAA,IACnB;AAAA,EACD;AACD;",
  "names": []
}
