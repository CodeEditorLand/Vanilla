import*as h from"../../../../base/common/strings.js";import"../../core/range.js";import"../../model.js";import"../languageConfigurationRegistry.js";import{createScopedLineTokens as u}from"../supports.js";import"../autoIndent.js";import{LineTokens as f}from"../../tokens/lineTokens.js";import"./indentRules.js";import{StandardTokenType as p}from"../../encodedTokenAttributes.js";import"../../core/position.js";class B{_indentRulesSupport;_indentationLineProcessor;constructor(e,n,o){this._indentRulesSupport=n,this._indentationLineProcessor=new k(e,o)}shouldIncrease(e,n){const o=this._indentationLineProcessor.getProcessedLine(e,n);return this._indentRulesSupport.shouldIncrease(o)}shouldDecrease(e,n){const o=this._indentationLineProcessor.getProcessedLine(e,n);return this._indentRulesSupport.shouldDecrease(o)}shouldIgnore(e,n){const o=this._indentationLineProcessor.getProcessedLine(e,n);return this._indentRulesSupport.shouldIgnore(o)}shouldIndentNextLine(e,n){const o=this._indentationLineProcessor.getProcessedLine(e,n);return this._indentRulesSupport.shouldIndentNextLine(o)}}class W{model;indentationLineProcessor;constructor(e,n){this.model=e,this.indentationLineProcessor=new k(e,n)}getProcessedTokenContextAroundRange(e){const n=this._getProcessedTokensBeforeRange(e),o=this._getProcessedTokensAfterRange(e),t=this._getProcessedPreviousLineTokens(e);return{beforeRangeProcessedTokens:n,afterRangeProcessedTokens:o,previousLineProcessedTokens:t}}_getProcessedTokensBeforeRange(e){this.model.tokenization.forceTokenization(e.startLineNumber);const n=this.model.tokenization.getLineTokens(e.startLineNumber),o=u(n,e.startColumn-1);let t;if(P(this.model,e.getStartPosition())){const s=e.startColumn-1-o.firstCharOffset,a=o.firstCharOffset,r=a+s;t=n.sliceAndInflate(a,r,0)}else{const s=e.startColumn-1;t=n.sliceAndInflate(0,s,0)}return this.indentationLineProcessor.getProcessedTokens(t)}_getProcessedTokensAfterRange(e){const n=e.isEmpty()?e.getStartPosition():e.getEndPosition();this.model.tokenization.forceTokenization(n.lineNumber);const o=this.model.tokenization.getLineTokens(n.lineNumber),t=u(o,n.column-1),i=n.column-1-t.firstCharOffset,s=t.firstCharOffset+i,a=t.firstCharOffset+t.getLineLength(),r=o.sliceAndInflate(s,a,0);return this.indentationLineProcessor.getProcessedTokens(r)}_getProcessedPreviousLineTokens(e){const n=L=>{this.model.tokenization.forceTokenization(L);const T=this.model.tokenization.getLineTokens(L),m=this.model.getLineMaxColumn(L)-1;return u(T,m)};this.model.tokenization.forceTokenization(e.startLineNumber);const o=this.model.tokenization.getLineTokens(e.startLineNumber),t=u(o,e.startColumn-1),i=f.createEmpty("",t.languageIdCodec),s=e.startLineNumber-1;if(s===0||!(t.firstCharOffset===0))return i;const c=n(s);if(!(t.languageId===c.languageId))return i;const l=c.toIViewLineTokens();return this.indentationLineProcessor.getProcessedTokens(l)}}class k{constructor(e,n){this.model=e;this.languageConfigurationService=n}getProcessedLine(e,n){const o=(s,a)=>{const r=h.getLeadingWhitespace(s);return a+s.substring(r.length)};this.model.tokenization.forceTokenization?.(e);const t=this.model.tokenization.getLineTokens(e);let i=this.getProcessedTokens(t).getLineContent();return n!==void 0&&(i=o(i,n)),i}getProcessedTokens(e){const n=r=>r===p.String||r===p.RegEx||r===p.Comment,o=e.getLanguageId(0),i=this.languageConfigurationService.getLanguageConfiguration(o).bracketsNew.getBracketRegExp({global:!0}),s=[];return e.forEach(r=>{const c=e.getStandardTokenType(r);let g=e.getTokenText(r);n(c)&&(g=g.replace(i,""));const l=e.getMetadata(r);s.push({text:g,metadata:l})}),f.createFromTextAndMetadata(s,e.languageIdCodec)}}function P(d,e){d.tokenization.forceTokenization(e.lineNumber);const n=d.tokenization.getLineTokens(e.lineNumber),o=u(n,e.column-1),t=o.firstCharOffset===0,i=n.getLanguageId(0)===o.languageId;return!t&&!i}export{W as IndentationContextProcessor,B as ProcessedIndentRulesSupport,P as isLanguageDifferentFromLineStart};
