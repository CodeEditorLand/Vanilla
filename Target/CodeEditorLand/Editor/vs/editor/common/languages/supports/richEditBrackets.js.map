{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/languages/supports/richEditBrackets.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from \"../../../../base/common/strings.js\";\nimport { Range } from \"../../core/range.js\";\nimport * as stringBuilder from \"../../core/stringBuilder.js\";\nimport type { CharacterPair } from \"../languageConfiguration.js\";\n\ninterface InternalBracket {\n\topen: string[];\n\tclose: string[];\n}\n\n/**\n * Represents a grouping of colliding bracket pairs.\n *\n * Most of the times this contains a single bracket pair,\n * but sometimes this contains multiple bracket pairs in cases\n * where the same string appears as a closing bracket for multiple\n * bracket pairs, or the same string appears an opening bracket for\n * multiple bracket pairs.\n *\n * e.g. of a group containing a single pair:\n *   open: ['{'], close: ['}']\n *\n * e.g. of a group containing multiple pairs:\n *   open: ['if', 'for'], close: ['end', 'end']\n */\nexport class RichEditBracket {\n\t_richEditBracketBrand: void = undefined;\n\n\treadonly languageId: string;\n\t/**\n\t * A 0-based consecutive unique identifier for this bracket pair.\n\t * If a language has 5 bracket pairs, out of which 2 are grouped together,\n\t * it is expected that the `index` goes from 0 to 4.\n\t */\n\treadonly index: number;\n\t/**\n\t * The open sequence for each bracket pair contained in this group.\n\t *\n\t * The open sequence at a specific index corresponds to the\n\t * closing sequence at the same index.\n\t *\n\t * [ open[i], closed[i] ] represent a bracket pair.\n\t */\n\treadonly open: string[];\n\t/**\n\t * The close sequence for each bracket pair contained in this group.\n\t *\n\t * The close sequence at a specific index corresponds to the\n\t * opening sequence at the same index.\n\t *\n\t * [ open[i], closed[i] ] represent a bracket pair.\n\t */\n\treadonly close: string[];\n\t/**\n\t * A regular expression that is useful to search for this bracket pair group in a string.\n\t *\n\t * This regular expression is built in a way that it is aware of the other bracket\n\t * pairs defined for the language, so it might match brackets from other groups.\n\t *\n\t * See the fine details in `getRegexForBracketPair`.\n\t */\n\treadonly forwardRegex: RegExp;\n\t/**\n\t * A regular expression that is useful to search for this bracket pair group in a string backwards.\n\t *\n\t * This regular expression is built in a way that it is aware of the other bracket\n\t * pairs defined for the language, so it might match brackets from other groups.\n\t *\n\t * See the fine defails in `getReversedRegexForBracketPair`.\n\t */\n\treadonly reversedRegex: RegExp;\n\tprivate readonly _openSet: Set<string>;\n\tprivate readonly _closeSet: Set<string>;\n\n\tconstructor(\n\t\tlanguageId: string,\n\t\tindex: number,\n\t\topen: string[],\n\t\tclose: string[],\n\t\tforwardRegex: RegExp,\n\t\treversedRegex: RegExp,\n\t) {\n\t\tthis.languageId = languageId;\n\t\tthis.index = index;\n\t\tthis.open = open;\n\t\tthis.close = close;\n\t\tthis.forwardRegex = forwardRegex;\n\t\tthis.reversedRegex = reversedRegex;\n\t\tthis._openSet = RichEditBracket._toSet(this.open);\n\t\tthis._closeSet = RichEditBracket._toSet(this.close);\n\t}\n\n\t/**\n\t * Check if the provided `text` is an open bracket in this group.\n\t */\n\tpublic isOpen(text: string) {\n\t\treturn this._openSet.has(text);\n\t}\n\n\t/**\n\t * Check if the provided `text` is a close bracket in this group.\n\t */\n\tpublic isClose(text: string) {\n\t\treturn this._closeSet.has(text);\n\t}\n\n\tprivate static _toSet(arr: string[]): Set<string> {\n\t\tconst result = new Set<string>();\n\t\tfor (const element of arr) {\n\t\t\tresult.add(element);\n\t\t}\n\t\treturn result;\n\t}\n}\n\n/**\n * Groups together brackets that have equal open or close sequences.\n *\n * For example, if the following brackets are defined:\n *   ['IF','END']\n *   ['for','end']\n *   ['{','}']\n *\n * Then the grouped brackets would be:\n *   { open: ['if', 'for'], close: ['end', 'end'] }\n *   { open: ['{'], close: ['}'] }\n *\n */\nfunction groupFuzzyBrackets(\n\tbrackets: readonly CharacterPair[],\n): InternalBracket[] {\n\tconst N = brackets.length;\n\n\tbrackets = brackets.map((b) => [b[0].toLowerCase(), b[1].toLowerCase()]);\n\n\tconst group: number[] = [];\n\tfor (let i = 0; i < N; i++) {\n\t\tgroup[i] = i;\n\t}\n\n\tconst areOverlapping = (a: CharacterPair, b: CharacterPair) => {\n\t\tconst [aOpen, aClose] = a;\n\t\tconst [bOpen, bClose] = b;\n\t\treturn (\n\t\t\taOpen === bOpen ||\n\t\t\taOpen === bClose ||\n\t\t\taClose === bOpen ||\n\t\t\taClose === bClose\n\t\t);\n\t};\n\n\tconst mergeGroups = (g1: number, g2: number) => {\n\t\tconst newG = Math.min(g1, g2);\n\t\tconst oldG = Math.max(g1, g2);\n\t\tfor (let i = 0; i < N; i++) {\n\t\t\tif (group[i] === oldG) {\n\t\t\t\tgroup[i] = newG;\n\t\t\t}\n\t\t}\n\t};\n\n\t// group together brackets that have the same open or the same close sequence\n\tfor (let i = 0; i < N; i++) {\n\t\tconst a = brackets[i];\n\t\tfor (let j = i + 1; j < N; j++) {\n\t\t\tconst b = brackets[j];\n\t\t\tif (areOverlapping(a, b)) {\n\t\t\t\tmergeGroups(group[i], group[j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tconst result: InternalBracket[] = [];\n\tfor (let g = 0; g < N; g++) {\n\t\tconst currentOpen: string[] = [];\n\t\tconst currentClose: string[] = [];\n\t\tfor (let i = 0; i < N; i++) {\n\t\t\tif (group[i] === g) {\n\t\t\t\tconst [open, close] = brackets[i];\n\t\t\t\tcurrentOpen.push(open);\n\t\t\t\tcurrentClose.push(close);\n\t\t\t}\n\t\t}\n\t\tif (currentOpen.length > 0) {\n\t\t\tresult.push({\n\t\t\t\topen: currentOpen,\n\t\t\t\tclose: currentClose,\n\t\t\t});\n\t\t}\n\t}\n\treturn result;\n}\n\nexport class RichEditBrackets {\n\t_richEditBracketsBrand: void = undefined;\n\n\t/**\n\t * All groups of brackets defined for this language.\n\t */\n\tpublic readonly brackets: RichEditBracket[];\n\t/**\n\t * A regular expression that is useful to search for all bracket pairs in a string.\n\t *\n\t * See the fine details in `getRegexForBrackets`.\n\t */\n\tpublic readonly forwardRegex: RegExp;\n\t/**\n\t * A regular expression that is useful to search for all bracket pairs in a string backwards.\n\t *\n\t * See the fine details in `getReversedRegexForBrackets`.\n\t */\n\tpublic readonly reversedRegex: RegExp;\n\t/**\n\t * The length (i.e. str.length) for the longest bracket pair.\n\t */\n\tpublic readonly maxBracketLength: number;\n\t/**\n\t * A map useful for decoding a regex match and finding which bracket group was matched.\n\t */\n\tpublic readonly textIsBracket: { [text: string]: RichEditBracket };\n\t/**\n\t * A set useful for decoding if a regex match is the open bracket of a bracket pair.\n\t */\n\tpublic readonly textIsOpenBracket: { [text: string]: boolean };\n\n\tconstructor(languageId: string, _brackets: readonly CharacterPair[]) {\n\t\tconst brackets = groupFuzzyBrackets(_brackets);\n\n\t\tthis.brackets = brackets.map((b, index) => {\n\t\t\treturn new RichEditBracket(\n\t\t\t\tlanguageId,\n\t\t\t\tindex,\n\t\t\t\tb.open,\n\t\t\t\tb.close,\n\t\t\t\tgetRegexForBracketPair(b.open, b.close, brackets, index),\n\t\t\t\tgetReversedRegexForBracketPair(\n\t\t\t\t\tb.open,\n\t\t\t\t\tb.close,\n\t\t\t\t\tbrackets,\n\t\t\t\t\tindex,\n\t\t\t\t),\n\t\t\t);\n\t\t});\n\n\t\tthis.forwardRegex = getRegexForBrackets(this.brackets);\n\t\tthis.reversedRegex = getReversedRegexForBrackets(this.brackets);\n\n\t\tthis.textIsBracket = {};\n\t\tthis.textIsOpenBracket = {};\n\n\t\tthis.maxBracketLength = 0;\n\t\tfor (const bracket of this.brackets) {\n\t\t\tfor (const open of bracket.open) {\n\t\t\t\tthis.textIsBracket[open] = bracket;\n\t\t\t\tthis.textIsOpenBracket[open] = true;\n\t\t\t\tthis.maxBracketLength = Math.max(\n\t\t\t\t\tthis.maxBracketLength,\n\t\t\t\t\topen.length,\n\t\t\t\t);\n\t\t\t}\n\t\t\tfor (const close of bracket.close) {\n\t\t\t\tthis.textIsBracket[close] = bracket;\n\t\t\t\tthis.textIsOpenBracket[close] = false;\n\t\t\t\tthis.maxBracketLength = Math.max(\n\t\t\t\t\tthis.maxBracketLength,\n\t\t\t\t\tclose.length,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction collectSuperstrings(\n\tstr: string,\n\tbrackets: InternalBracket[],\n\tcurrentIndex: number,\n\tdest: string[],\n): void {\n\tfor (let i = 0, len = brackets.length; i < len; i++) {\n\t\tif (i === currentIndex) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst bracket = brackets[i];\n\t\tfor (const open of bracket.open) {\n\t\t\tif (open.indexOf(str) >= 0) {\n\t\t\t\tdest.push(open);\n\t\t\t}\n\t\t}\n\t\tfor (const close of bracket.close) {\n\t\t\tif (close.indexOf(str) >= 0) {\n\t\t\t\tdest.push(close);\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction lengthcmp(a: string, b: string) {\n\treturn a.length - b.length;\n}\n\nfunction unique(arr: string[]): string[] {\n\tif (arr.length <= 1) {\n\t\treturn arr;\n\t}\n\tconst result: string[] = [];\n\tconst seen = new Set<string>();\n\tfor (const element of arr) {\n\t\tif (seen.has(element)) {\n\t\t\tcontinue;\n\t\t}\n\t\tresult.push(element);\n\t\tseen.add(element);\n\t}\n\treturn result;\n}\n\n/**\n * Create a regular expression that can be used to search forward in a piece of text\n * for a group of bracket pairs. But this regex must be built in a way in which\n * it is aware of the other bracket pairs defined for the language.\n *\n * For example, if a language contains the following bracket pairs:\n *   ['begin', 'end']\n *   ['if', 'end if']\n * The two bracket pairs do not collide because no open or close brackets are equal.\n * So the function getRegexForBracketPair is called twice, once with\n * the ['begin'], ['end'] group consisting of one bracket pair, and once with\n * the ['if'], ['end if'] group consiting of the other bracket pair.\n *\n * But there could be a situation where an occurrence of 'end if' is mistaken\n * for an occurrence of 'end'.\n *\n * Therefore, for the bracket pair ['begin', 'end'], the regex will also\n * target 'end if'. The regex will be something like:\n *   /(\\bend if\\b)|(\\bend\\b)|(\\bif\\b)/\n *\n * The regex also searches for \"superstrings\" (other brackets that might be mistaken with the current bracket).\n *\n */\nfunction getRegexForBracketPair(\n\topen: string[],\n\tclose: string[],\n\tbrackets: InternalBracket[],\n\tcurrentIndex: number,\n): RegExp {\n\t// search in all brackets for other brackets that are a superstring of these brackets\n\tlet pieces: string[] = [];\n\tpieces = pieces.concat(open);\n\tpieces = pieces.concat(close);\n\tfor (let i = 0, len = pieces.length; i < len; i++) {\n\t\tcollectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n\t}\n\tpieces = unique(pieces);\n\tpieces.sort(lengthcmp);\n\tpieces.reverse();\n\treturn createBracketOrRegExp(pieces);\n}\n\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * This function also has the fine details of `getRegexForBracketPair`. For the same example\n * given above, the regex produced here would look like:\n *   /(\\bfi dne\\b)|(\\bdne\\b)|(\\bfi\\b)/\n */\nfunction getReversedRegexForBracketPair(\n\topen: string[],\n\tclose: string[],\n\tbrackets: InternalBracket[],\n\tcurrentIndex: number,\n): RegExp {\n\t// search in all brackets for other brackets that are a superstring of these brackets\n\tlet pieces: string[] = [];\n\tpieces = pieces.concat(open);\n\tpieces = pieces.concat(close);\n\tfor (let i = 0, len = pieces.length; i < len; i++) {\n\t\tcollectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n\t}\n\tpieces = unique(pieces);\n\tpieces.sort(lengthcmp);\n\tpieces.reverse();\n\treturn createBracketOrRegExp(pieces.map(toReversedString));\n}\n\n/**\n * Creates a regular expression that targets all bracket pairs.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bbegin\\b)|(\\bend\\b)|(\\bfor\\b)/\n */\nfunction getRegexForBrackets(brackets: RichEditBracket[]): RegExp {\n\tlet pieces: string[] = [];\n\tfor (const bracket of brackets) {\n\t\tfor (const open of bracket.open) {\n\t\t\tpieces.push(open);\n\t\t}\n\t\tfor (const close of bracket.close) {\n\t\t\tpieces.push(close);\n\t\t}\n\t}\n\tpieces = unique(pieces);\n\treturn createBracketOrRegExp(pieces);\n}\n\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bnigeb\\b)|(\\bdne\\b)|(\\brof\\b)/\n */\nfunction getReversedRegexForBrackets(brackets: RichEditBracket[]): RegExp {\n\tlet pieces: string[] = [];\n\tfor (const bracket of brackets) {\n\t\tfor (const open of bracket.open) {\n\t\t\tpieces.push(open);\n\t\t}\n\t\tfor (const close of bracket.close) {\n\t\t\tpieces.push(close);\n\t\t}\n\t}\n\tpieces = unique(pieces);\n\treturn createBracketOrRegExp(pieces.map(toReversedString));\n}\n\nfunction prepareBracketForRegExp(str: string): string {\n\t// This bracket pair uses letters like e.g. \"begin\" - \"end\"\n\tconst insertWordBoundaries = /^[\\w ]+$/.test(str);\n\tstr = strings.escapeRegExpCharacters(str);\n\treturn insertWordBoundaries ? `\\\\b${str}\\\\b` : str;\n}\n\nexport function createBracketOrRegExp(\n\tpieces: string[],\n\toptions?: strings.RegExpOptions,\n): RegExp {\n\tconst regexStr = `(${pieces.map(prepareBracketForRegExp).join(\")|(\")})`;\n\treturn strings.createRegExp(regexStr, true, options);\n}\n\nconst toReversedString = (() => {\n\tfunction reverse(str: string): string {\n\t\t// create a Uint16Array and then use a TextDecoder to create a string\n\t\tconst arr = new Uint16Array(str.length);\n\t\tlet offset = 0;\n\t\tfor (let i = str.length - 1; i >= 0; i--) {\n\t\t\tarr[offset++] = str.charCodeAt(i);\n\t\t}\n\t\treturn stringBuilder.getPlatformTextDecoder().decode(arr);\n\t}\n\n\tlet lastInput: string | null = null;\n\tlet lastOutput: string | null = null;\n\treturn function toReversedString(str: string): string {\n\t\tif (lastInput !== str) {\n\t\t\tlastInput = str;\n\t\t\tlastOutput = reverse(lastInput);\n\t\t}\n\t\treturn lastOutput!;\n\t};\n})();\n\nexport class BracketsUtils {\n\tprivate static _findPrevBracketInText(\n\t\treversedBracketRegex: RegExp,\n\t\tlineNumber: number,\n\t\treversedText: string,\n\t\toffset: number,\n\t): Range | null {\n\t\tconst m = reversedText.match(reversedBracketRegex);\n\n\t\tif (!m) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst matchOffset = reversedText.length - (m.index || 0);\n\t\tconst matchLength = m[0].length;\n\t\tconst absoluteMatchOffset = offset + matchOffset;\n\n\t\treturn new Range(\n\t\t\tlineNumber,\n\t\t\tabsoluteMatchOffset - matchLength + 1,\n\t\t\tlineNumber,\n\t\t\tabsoluteMatchOffset + 1,\n\t\t);\n\t}\n\n\tpublic static findPrevBracketInRange(\n\t\treversedBracketRegex: RegExp,\n\t\tlineNumber: number,\n\t\tlineText: string,\n\t\tstartOffset: number,\n\t\tendOffset: number,\n\t): Range | null {\n\t\t// Because JS does not support backwards regex search, we search forwards in a reversed string with a reversed regex ;)\n\t\tconst reversedLineText = toReversedString(lineText);\n\t\tconst reversedSubstr = reversedLineText.substring(\n\t\t\tlineText.length - endOffset,\n\t\t\tlineText.length - startOffset,\n\t\t);\n\t\treturn this._findPrevBracketInText(\n\t\t\treversedBracketRegex,\n\t\t\tlineNumber,\n\t\t\treversedSubstr,\n\t\t\tstartOffset,\n\t\t);\n\t}\n\n\tpublic static findNextBracketInText(\n\t\tbracketRegex: RegExp,\n\t\tlineNumber: number,\n\t\ttext: string,\n\t\toffset: number,\n\t): Range | null {\n\t\tconst m = text.match(bracketRegex);\n\n\t\tif (!m) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst matchOffset = m.index || 0;\n\t\tconst matchLength = m[0].length;\n\t\tif (matchLength === 0) {\n\t\t\treturn null;\n\t\t}\n\t\tconst absoluteMatchOffset = offset + matchOffset;\n\n\t\treturn new Range(\n\t\t\tlineNumber,\n\t\t\tabsoluteMatchOffset + 1,\n\t\t\tlineNumber,\n\t\t\tabsoluteMatchOffset + 1 + matchLength,\n\t\t);\n\t}\n\n\tpublic static findNextBracketInRange(\n\t\tbracketRegex: RegExp,\n\t\tlineNumber: number,\n\t\tlineText: string,\n\t\tstartOffset: number,\n\t\tendOffset: number,\n\t): Range | null {\n\t\tconst substr = lineText.substring(startOffset, endOffset);\n\t\treturn this.findNextBracketInText(\n\t\t\tbracketRegex,\n\t\t\tlineNumber,\n\t\t\tsubstr,\n\t\t\tstartOffset,\n\t\t);\n\t}\n}\n"],
  "mappings": "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",
  "names": ["toReversedString"]
}
