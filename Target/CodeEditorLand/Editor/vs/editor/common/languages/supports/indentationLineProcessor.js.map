{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/languages/supports/indentationLineProcessor.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from \"../../../../base/common/strings.js\";\nimport type { Position } from \"../../core/position.js\";\nimport type { Range } from \"../../core/range.js\";\nimport { StandardTokenType } from \"../../encodedTokenAttributes.js\";\nimport type { ITextModel } from \"../../model.js\";\nimport { type IViewLineTokens, LineTokens } from \"../../tokens/lineTokens.js\";\nimport type { IVirtualModel } from \"../autoIndent.js\";\nimport type { ILanguageConfigurationService } from \"../languageConfigurationRegistry.js\";\nimport { type ScopedLineTokens, createScopedLineTokens } from \"../supports.js\";\nimport type { IndentRulesSupport } from \"./indentRules.js\";\n\n/**\n * This class is a wrapper class around {@link IndentRulesSupport}.\n * It processes the lines by removing the language configuration brackets from the regex, string and comment tokens.\n * It then calls into the {@link IndentRulesSupport} to validate the indentation conditions.\n */\nexport class ProcessedIndentRulesSupport {\n\tprivate readonly _indentRulesSupport: IndentRulesSupport;\n\tprivate readonly _indentationLineProcessor: IndentationLineProcessor;\n\n\tconstructor(\n\t\tmodel: IVirtualModel,\n\t\tindentRulesSupport: IndentRulesSupport,\n\t\tlanguageConfigurationService: ILanguageConfigurationService,\n\t) {\n\t\tthis._indentRulesSupport = indentRulesSupport;\n\t\tthis._indentationLineProcessor = new IndentationLineProcessor(\n\t\t\tmodel,\n\t\t\tlanguageConfigurationService,\n\t\t);\n\t}\n\n\t/**\n\t * Apply the new indentation and return whether the indentation level should be increased after the given line number\n\t */\n\tpublic shouldIncrease(\n\t\tlineNumber: number,\n\t\tnewIndentation?: string,\n\t): boolean {\n\t\tconst processedLine = this._indentationLineProcessor.getProcessedLine(\n\t\t\tlineNumber,\n\t\t\tnewIndentation,\n\t\t);\n\t\treturn this._indentRulesSupport.shouldIncrease(processedLine);\n\t}\n\n\t/**\n\t * Apply the new indentation and return whether the indentation level should be decreased after the given line number\n\t */\n\tpublic shouldDecrease(\n\t\tlineNumber: number,\n\t\tnewIndentation?: string,\n\t): boolean {\n\t\tconst processedLine = this._indentationLineProcessor.getProcessedLine(\n\t\t\tlineNumber,\n\t\t\tnewIndentation,\n\t\t);\n\t\treturn this._indentRulesSupport.shouldDecrease(processedLine);\n\t}\n\n\t/**\n\t * Apply the new indentation and return whether the indentation level should remain unchanged at the given line number\n\t */\n\tpublic shouldIgnore(lineNumber: number, newIndentation?: string): boolean {\n\t\tconst processedLine = this._indentationLineProcessor.getProcessedLine(\n\t\t\tlineNumber,\n\t\t\tnewIndentation,\n\t\t);\n\t\treturn this._indentRulesSupport.shouldIgnore(processedLine);\n\t}\n\n\t/**\n\t * Apply the new indentation and return whether the indentation level should increase on the line after the given line number\n\t */\n\tpublic shouldIndentNextLine(\n\t\tlineNumber: number,\n\t\tnewIndentation?: string,\n\t): boolean {\n\t\tconst processedLine = this._indentationLineProcessor.getProcessedLine(\n\t\t\tlineNumber,\n\t\t\tnewIndentation,\n\t\t);\n\t\treturn this._indentRulesSupport.shouldIndentNextLine(processedLine);\n\t}\n}\n\n/**\n * This class fetches the processed text around a range which can be used for indentation evaluation.\n * It returns:\n * - The processed text before the given range and on the same start line\n * - The processed text after the given range and on the same end line\n * - The processed text on the previous line\n */\nexport class IndentationContextProcessor {\n\tprivate readonly model: ITextModel;\n\tprivate readonly indentationLineProcessor: IndentationLineProcessor;\n\n\tconstructor(\n\t\tmodel: ITextModel,\n\t\tlanguageConfigurationService: ILanguageConfigurationService,\n\t) {\n\t\tthis.model = model;\n\t\tthis.indentationLineProcessor = new IndentationLineProcessor(\n\t\t\tmodel,\n\t\t\tlanguageConfigurationService,\n\t\t);\n\t}\n\n\t/**\n\t * Returns the processed text, stripped from the language configuration brackets within the string, comment and regex tokens, around the given range\n\t */\n\tgetProcessedTokenContextAroundRange(range: Range): {\n\t\tbeforeRangeProcessedTokens: IViewLineTokens;\n\t\tafterRangeProcessedTokens: IViewLineTokens;\n\t\tpreviousLineProcessedTokens: IViewLineTokens;\n\t} {\n\t\tconst beforeRangeProcessedTokens =\n\t\t\tthis._getProcessedTokensBeforeRange(range);\n\t\tconst afterRangeProcessedTokens =\n\t\t\tthis._getProcessedTokensAfterRange(range);\n\t\tconst previousLineProcessedTokens =\n\t\t\tthis._getProcessedPreviousLineTokens(range);\n\t\treturn {\n\t\t\tbeforeRangeProcessedTokens,\n\t\t\tafterRangeProcessedTokens,\n\t\t\tpreviousLineProcessedTokens,\n\t\t};\n\t}\n\n\tprivate _getProcessedTokensBeforeRange(range: Range): IViewLineTokens {\n\t\tthis.model.tokenization.forceTokenization(range.startLineNumber);\n\t\tconst lineTokens = this.model.tokenization.getLineTokens(\n\t\t\trange.startLineNumber,\n\t\t);\n\t\tconst scopedLineTokens = createScopedLineTokens(\n\t\t\tlineTokens,\n\t\t\trange.startColumn - 1,\n\t\t);\n\t\tlet slicedTokens: IViewLineTokens;\n\t\tif (\n\t\t\tisLanguageDifferentFromLineStart(\n\t\t\t\tthis.model,\n\t\t\t\trange.getStartPosition(),\n\t\t\t)\n\t\t) {\n\t\t\tconst columnIndexWithinScope =\n\t\t\t\trange.startColumn - 1 - scopedLineTokens.firstCharOffset;\n\t\t\tconst firstCharacterOffset = scopedLineTokens.firstCharOffset;\n\t\t\tconst lastCharacterOffset =\n\t\t\t\tfirstCharacterOffset + columnIndexWithinScope;\n\t\t\tslicedTokens = lineTokens.sliceAndInflate(\n\t\t\t\tfirstCharacterOffset,\n\t\t\t\tlastCharacterOffset,\n\t\t\t\t0,\n\t\t\t);\n\t\t} else {\n\t\t\tconst columnWithinLine = range.startColumn - 1;\n\t\t\tslicedTokens = lineTokens.sliceAndInflate(0, columnWithinLine, 0);\n\t\t}\n\t\tconst processedTokens =\n\t\t\tthis.indentationLineProcessor.getProcessedTokens(slicedTokens);\n\t\treturn processedTokens;\n\t}\n\n\tprivate _getProcessedTokensAfterRange(range: Range): IViewLineTokens {\n\t\tconst position: Position = range.isEmpty()\n\t\t\t? range.getStartPosition()\n\t\t\t: range.getEndPosition();\n\t\tthis.model.tokenization.forceTokenization(position.lineNumber);\n\t\tconst lineTokens = this.model.tokenization.getLineTokens(\n\t\t\tposition.lineNumber,\n\t\t);\n\t\tconst scopedLineTokens = createScopedLineTokens(\n\t\t\tlineTokens,\n\t\t\tposition.column - 1,\n\t\t);\n\t\tconst columnIndexWithinScope =\n\t\t\tposition.column - 1 - scopedLineTokens.firstCharOffset;\n\t\tconst firstCharacterOffset =\n\t\t\tscopedLineTokens.firstCharOffset + columnIndexWithinScope;\n\t\tconst lastCharacterOffset =\n\t\t\tscopedLineTokens.firstCharOffset + scopedLineTokens.getLineLength();\n\t\tconst slicedTokens = lineTokens.sliceAndInflate(\n\t\t\tfirstCharacterOffset,\n\t\t\tlastCharacterOffset,\n\t\t\t0,\n\t\t);\n\t\tconst processedTokens =\n\t\t\tthis.indentationLineProcessor.getProcessedTokens(slicedTokens);\n\t\treturn processedTokens;\n\t}\n\n\tprivate _getProcessedPreviousLineTokens(range: Range): IViewLineTokens {\n\t\tconst getScopedLineTokensAtEndColumnOfLine = (\n\t\t\tlineNumber: number,\n\t\t): ScopedLineTokens => {\n\t\t\tthis.model.tokenization.forceTokenization(lineNumber);\n\t\t\tconst lineTokens =\n\t\t\t\tthis.model.tokenization.getLineTokens(lineNumber);\n\t\t\tconst endColumnOfLine = this.model.getLineMaxColumn(lineNumber) - 1;\n\t\t\tconst scopedLineTokensAtEndColumn = createScopedLineTokens(\n\t\t\t\tlineTokens,\n\t\t\t\tendColumnOfLine,\n\t\t\t);\n\t\t\treturn scopedLineTokensAtEndColumn;\n\t\t};\n\n\t\tthis.model.tokenization.forceTokenization(range.startLineNumber);\n\t\tconst lineTokens = this.model.tokenization.getLineTokens(\n\t\t\trange.startLineNumber,\n\t\t);\n\t\tconst scopedLineTokens = createScopedLineTokens(\n\t\t\tlineTokens,\n\t\t\trange.startColumn - 1,\n\t\t);\n\t\tconst emptyTokens = LineTokens.createEmpty(\n\t\t\t\"\",\n\t\t\tscopedLineTokens.languageIdCodec,\n\t\t);\n\t\tconst previousLineNumber = range.startLineNumber - 1;\n\t\tconst isFirstLine = previousLineNumber === 0;\n\t\tif (isFirstLine) {\n\t\t\treturn emptyTokens;\n\t\t}\n\t\tconst canScopeExtendOnPreviousLine =\n\t\t\tscopedLineTokens.firstCharOffset === 0;\n\t\tif (!canScopeExtendOnPreviousLine) {\n\t\t\treturn emptyTokens;\n\t\t}\n\t\tconst scopedLineTokensAtEndColumnOfPreviousLine =\n\t\t\tgetScopedLineTokensAtEndColumnOfLine(previousLineNumber);\n\t\tconst doesLanguageContinueOnPreviousLine =\n\t\t\tscopedLineTokens.languageId ===\n\t\t\tscopedLineTokensAtEndColumnOfPreviousLine.languageId;\n\t\tif (!doesLanguageContinueOnPreviousLine) {\n\t\t\treturn emptyTokens;\n\t\t}\n\t\tconst previousSlicedLineTokens =\n\t\t\tscopedLineTokensAtEndColumnOfPreviousLine.toIViewLineTokens();\n\t\tconst processedTokens =\n\t\t\tthis.indentationLineProcessor.getProcessedTokens(\n\t\t\t\tpreviousSlicedLineTokens,\n\t\t\t);\n\t\treturn processedTokens;\n\t}\n}\n\n/**\n * This class performs the actual processing of the indentation lines.\n * The brackets of the language configuration are removed from the regex, string and comment tokens.\n */\nclass IndentationLineProcessor {\n\tconstructor(\n\t\tprivate readonly model: IVirtualModel,\n\t\tprivate readonly languageConfigurationService: ILanguageConfigurationService,\n\t) {}\n\n\t/**\n\t * Get the processed line for the given line number and potentially adjust the indentation level.\n\t * Remove the language configuration brackets from the regex, string and comment tokens.\n\t */\n\tgetProcessedLine(lineNumber: number, newIndentation?: string): string {\n\t\tconst replaceIndentation = (\n\t\t\tline: string,\n\t\t\tnewIndentation: string,\n\t\t): string => {\n\t\t\tconst currentIndentation = strings.getLeadingWhitespace(line);\n\t\t\tconst adjustedLine =\n\t\t\t\tnewIndentation + line.substring(currentIndentation.length);\n\t\t\treturn adjustedLine;\n\t\t};\n\n\t\tthis.model.tokenization.forceTokenization?.(lineNumber);\n\t\tconst tokens = this.model.tokenization.getLineTokens(lineNumber);\n\t\tlet processedLine = this.getProcessedTokens(tokens).getLineContent();\n\t\tif (newIndentation !== undefined) {\n\t\t\tprocessedLine = replaceIndentation(processedLine, newIndentation);\n\t\t}\n\t\treturn processedLine;\n\t}\n\n\t/**\n\t * Process the line with the given tokens, remove the language configuration brackets from the regex, string and comment tokens.\n\t */\n\tgetProcessedTokens(tokens: IViewLineTokens): IViewLineTokens {\n\t\tconst shouldRemoveBracketsFromTokenType = (\n\t\t\ttokenType: StandardTokenType,\n\t\t): boolean => {\n\t\t\treturn (\n\t\t\t\ttokenType === StandardTokenType.String ||\n\t\t\t\ttokenType === StandardTokenType.RegEx ||\n\t\t\t\ttokenType === StandardTokenType.Comment\n\t\t\t);\n\t\t};\n\n\t\tconst languageId = tokens.getLanguageId(0);\n\t\tconst bracketsConfiguration =\n\t\t\tthis.languageConfigurationService.getLanguageConfiguration(\n\t\t\t\tlanguageId,\n\t\t\t).bracketsNew;\n\t\tconst bracketsRegExp = bracketsConfiguration.getBracketRegExp({\n\t\t\tglobal: true,\n\t\t});\n\t\tconst textAndMetadata: { text: string; metadata: number }[] = [];\n\t\ttokens.forEach((tokenIndex: number) => {\n\t\t\tconst tokenType = tokens.getStandardTokenType(tokenIndex);\n\t\t\tlet text = tokens.getTokenText(tokenIndex);\n\t\t\tif (shouldRemoveBracketsFromTokenType(tokenType)) {\n\t\t\t\ttext = text.replace(bracketsRegExp, \"\");\n\t\t\t}\n\t\t\tconst metadata = tokens.getMetadata(tokenIndex);\n\t\t\ttextAndMetadata.push({ text, metadata });\n\t\t});\n\t\tconst processedLineTokens = LineTokens.createFromTextAndMetadata(\n\t\t\ttextAndMetadata,\n\t\t\ttokens.languageIdCodec,\n\t\t);\n\t\treturn processedLineTokens;\n\t}\n}\n\nexport function isLanguageDifferentFromLineStart(\n\tmodel: ITextModel,\n\tposition: Position,\n): boolean {\n\tmodel.tokenization.forceTokenization(position.lineNumber);\n\tconst lineTokens = model.tokenization.getLineTokens(position.lineNumber);\n\tconst scopedLineTokens = createScopedLineTokens(\n\t\tlineTokens,\n\t\tposition.column - 1,\n\t);\n\tconst doesScopeStartAtOffsetZero = scopedLineTokens.firstCharOffset === 0;\n\tconst isScopedLanguageEqualToFirstLanguageOnLine =\n\t\tlineTokens.getLanguageId(0) === scopedLineTokens.languageId;\n\tconst languageIsDifferentFromLineStart =\n\t\t!doesScopeStartAtOffsetZero &&\n\t\t!isScopedLanguageEqualToFirstLanguageOnLine;\n\treturn languageIsDifferentFromLineStart;\n}\n"],
  "mappings": "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",
  "names": ["lineTokens", "newIndentation"]
}
