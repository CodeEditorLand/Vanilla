{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/languages/supports/indentationLineProcessor.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from '../../../../base/common/strings.js';\nimport { Range } from '../../core/range.js';\nimport { ITextModel } from '../../model.js';\nimport { ILanguageConfigurationService } from '../languageConfigurationRegistry.js';\nimport { createScopedLineTokens, ScopedLineTokens } from '../supports.js';\nimport { IVirtualModel } from '../autoIndent.js';\nimport { IViewLineTokens, LineTokens } from '../../tokens/lineTokens.js';\nimport { IndentRulesSupport } from './indentRules.js';\nimport { StandardTokenType } from '../../encodedTokenAttributes.js';\nimport { Position } from '../../core/position.js';\n\n/**\n * This class is a wrapper class around {@link IndentRulesSupport}.\n * It processes the lines by removing the language configuration brackets from the regex, string and comment tokens.\n * It then calls into the {@link IndentRulesSupport} to validate the indentation conditions.\n */\nexport class ProcessedIndentRulesSupport {\n\n\tprivate readonly _indentRulesSupport: IndentRulesSupport;\n\tprivate readonly _indentationLineProcessor: IndentationLineProcessor;\n\n\tconstructor(\n\t\tmodel: IVirtualModel,\n\t\tindentRulesSupport: IndentRulesSupport,\n\t\tlanguageConfigurationService: ILanguageConfigurationService\n\t) {\n\t\tthis._indentRulesSupport = indentRulesSupport;\n\t\tthis._indentationLineProcessor = new IndentationLineProcessor(model, languageConfigurationService);\n\t}\n\n\t/**\n\t * Apply the new indentation and return whether the indentation level should be increased after the given line number\n\t */\n\tpublic shouldIncrease(lineNumber: number, newIndentation?: string): boolean {\n\t\tconst processedLine = this._indentationLineProcessor.getProcessedLine(lineNumber, newIndentation);\n\t\treturn this._indentRulesSupport.shouldIncrease(processedLine);\n\t}\n\n\t/**\n\t * Apply the new indentation and return whether the indentation level should be decreased after the given line number\n\t */\n\tpublic shouldDecrease(lineNumber: number, newIndentation?: string): boolean {\n\t\tconst processedLine = this._indentationLineProcessor.getProcessedLine(lineNumber, newIndentation);\n\t\treturn this._indentRulesSupport.shouldDecrease(processedLine);\n\t}\n\n\t/**\n\t * Apply the new indentation and return whether the indentation level should remain unchanged at the given line number\n\t */\n\tpublic shouldIgnore(lineNumber: number, newIndentation?: string): boolean {\n\t\tconst processedLine = this._indentationLineProcessor.getProcessedLine(lineNumber, newIndentation);\n\t\treturn this._indentRulesSupport.shouldIgnore(processedLine);\n\t}\n\n\t/**\n\t * Apply the new indentation and return whether the indentation level should increase on the line after the given line number\n\t */\n\tpublic shouldIndentNextLine(lineNumber: number, newIndentation?: string): boolean {\n\t\tconst processedLine = this._indentationLineProcessor.getProcessedLine(lineNumber, newIndentation);\n\t\treturn this._indentRulesSupport.shouldIndentNextLine(processedLine);\n\t}\n\n}\n\n/**\n * This class fetches the processed text around a range which can be used for indentation evaluation.\n * It returns:\n * - The processed text before the given range and on the same start line\n * - The processed text after the given range and on the same end line\n * - The processed text on the previous line\n */\nexport class IndentationContextProcessor {\n\n\tprivate readonly model: ITextModel;\n\tprivate readonly indentationLineProcessor: IndentationLineProcessor;\n\n\tconstructor(\n\t\tmodel: ITextModel,\n\t\tlanguageConfigurationService: ILanguageConfigurationService\n\t) {\n\t\tthis.model = model;\n\t\tthis.indentationLineProcessor = new IndentationLineProcessor(model, languageConfigurationService);\n\t}\n\n\t/**\n\t * Returns the processed text, stripped from the language configuration brackets within the string, comment and regex tokens, around the given range\n\t */\n\tgetProcessedTokenContextAroundRange(range: Range): {\n\t\tbeforeRangeProcessedTokens: IViewLineTokens;\n\t\tafterRangeProcessedTokens: IViewLineTokens;\n\t\tpreviousLineProcessedTokens: IViewLineTokens;\n\t} {\n\t\tconst beforeRangeProcessedTokens = this._getProcessedTokensBeforeRange(range);\n\t\tconst afterRangeProcessedTokens = this._getProcessedTokensAfterRange(range);\n\t\tconst previousLineProcessedTokens = this._getProcessedPreviousLineTokens(range);\n\t\treturn { beforeRangeProcessedTokens, afterRangeProcessedTokens, previousLineProcessedTokens };\n\t}\n\n\tprivate _getProcessedTokensBeforeRange(range: Range): IViewLineTokens {\n\t\tthis.model.tokenization.forceTokenization(range.startLineNumber);\n\t\tconst lineTokens = this.model.tokenization.getLineTokens(range.startLineNumber);\n\t\tconst scopedLineTokens = createScopedLineTokens(lineTokens, range.startColumn - 1);\n\t\tlet slicedTokens: IViewLineTokens;\n\t\tif (isLanguageDifferentFromLineStart(this.model, range.getStartPosition())) {\n\t\t\tconst columnIndexWithinScope = (range.startColumn - 1) - scopedLineTokens.firstCharOffset;\n\t\t\tconst firstCharacterOffset = scopedLineTokens.firstCharOffset;\n\t\t\tconst lastCharacterOffset = firstCharacterOffset + columnIndexWithinScope;\n\t\t\tslicedTokens = lineTokens.sliceAndInflate(firstCharacterOffset, lastCharacterOffset, 0);\n\t\t} else {\n\t\t\tconst columnWithinLine = range.startColumn - 1;\n\t\t\tslicedTokens = lineTokens.sliceAndInflate(0, columnWithinLine, 0);\n\t\t}\n\t\tconst processedTokens = this.indentationLineProcessor.getProcessedTokens(slicedTokens);\n\t\treturn processedTokens;\n\t}\n\n\tprivate _getProcessedTokensAfterRange(range: Range): IViewLineTokens {\n\t\tconst position: Position = range.isEmpty() ? range.getStartPosition() : range.getEndPosition();\n\t\tthis.model.tokenization.forceTokenization(position.lineNumber);\n\t\tconst lineTokens = this.model.tokenization.getLineTokens(position.lineNumber);\n\t\tconst scopedLineTokens = createScopedLineTokens(lineTokens, position.column - 1);\n\t\tconst columnIndexWithinScope = position.column - 1 - scopedLineTokens.firstCharOffset;\n\t\tconst firstCharacterOffset = scopedLineTokens.firstCharOffset + columnIndexWithinScope;\n\t\tconst lastCharacterOffset = scopedLineTokens.firstCharOffset + scopedLineTokens.getLineLength();\n\t\tconst slicedTokens = lineTokens.sliceAndInflate(firstCharacterOffset, lastCharacterOffset, 0);\n\t\tconst processedTokens = this.indentationLineProcessor.getProcessedTokens(slicedTokens);\n\t\treturn processedTokens;\n\t}\n\n\tprivate _getProcessedPreviousLineTokens(range: Range): IViewLineTokens {\n\t\tconst getScopedLineTokensAtEndColumnOfLine = (lineNumber: number): ScopedLineTokens => {\n\t\t\tthis.model.tokenization.forceTokenization(lineNumber);\n\t\t\tconst lineTokens = this.model.tokenization.getLineTokens(lineNumber);\n\t\t\tconst endColumnOfLine = this.model.getLineMaxColumn(lineNumber) - 1;\n\t\t\tconst scopedLineTokensAtEndColumn = createScopedLineTokens(lineTokens, endColumnOfLine);\n\t\t\treturn scopedLineTokensAtEndColumn;\n\t\t};\n\n\t\tthis.model.tokenization.forceTokenization(range.startLineNumber);\n\t\tconst lineTokens = this.model.tokenization.getLineTokens(range.startLineNumber);\n\t\tconst scopedLineTokens = createScopedLineTokens(lineTokens, range.startColumn - 1);\n\t\tconst emptyTokens = LineTokens.createEmpty('', scopedLineTokens.languageIdCodec);\n\t\tconst previousLineNumber = range.startLineNumber - 1;\n\t\tconst isFirstLine = previousLineNumber === 0;\n\t\tif (isFirstLine) {\n\t\t\treturn emptyTokens;\n\t\t}\n\t\tconst canScopeExtendOnPreviousLine = scopedLineTokens.firstCharOffset === 0;\n\t\tif (!canScopeExtendOnPreviousLine) {\n\t\t\treturn emptyTokens;\n\t\t}\n\t\tconst scopedLineTokensAtEndColumnOfPreviousLine = getScopedLineTokensAtEndColumnOfLine(previousLineNumber);\n\t\tconst doesLanguageContinueOnPreviousLine = scopedLineTokens.languageId === scopedLineTokensAtEndColumnOfPreviousLine.languageId;\n\t\tif (!doesLanguageContinueOnPreviousLine) {\n\t\t\treturn emptyTokens;\n\t\t}\n\t\tconst previousSlicedLineTokens = scopedLineTokensAtEndColumnOfPreviousLine.toIViewLineTokens();\n\t\tconst processedTokens = this.indentationLineProcessor.getProcessedTokens(previousSlicedLineTokens);\n\t\treturn processedTokens;\n\t}\n}\n\n/**\n * This class performs the actual processing of the indentation lines.\n * The brackets of the language configuration are removed from the regex, string and comment tokens.\n */\nclass IndentationLineProcessor {\n\n\tconstructor(\n\t\tprivate readonly model: IVirtualModel,\n\t\tprivate readonly languageConfigurationService: ILanguageConfigurationService\n\t) { }\n\n\t/**\n\t * Get the processed line for the given line number and potentially adjust the indentation level.\n\t * Remove the language configuration brackets from the regex, string and comment tokens.\n\t */\n\tgetProcessedLine(lineNumber: number, newIndentation?: string): string {\n\t\tconst replaceIndentation = (line: string, newIndentation: string): string => {\n\t\t\tconst currentIndentation = strings.getLeadingWhitespace(line);\n\t\t\tconst adjustedLine = newIndentation + line.substring(currentIndentation.length);\n\t\t\treturn adjustedLine;\n\t\t};\n\n\t\tthis.model.tokenization.forceTokenization?.(lineNumber);\n\t\tconst tokens = this.model.tokenization.getLineTokens(lineNumber);\n\t\tlet processedLine = this.getProcessedTokens(tokens).getLineContent();\n\t\tif (newIndentation !== undefined) {\n\t\t\tprocessedLine = replaceIndentation(processedLine, newIndentation);\n\t\t}\n\t\treturn processedLine;\n\t}\n\n\t/**\n\t * Process the line with the given tokens, remove the language configuration brackets from the regex, string and comment tokens.\n\t */\n\tgetProcessedTokens(tokens: IViewLineTokens): IViewLineTokens {\n\n\t\tconst shouldRemoveBracketsFromTokenType = (tokenType: StandardTokenType): boolean => {\n\t\t\treturn tokenType === StandardTokenType.String\n\t\t\t\t|| tokenType === StandardTokenType.RegEx\n\t\t\t\t|| tokenType === StandardTokenType.Comment;\n\t\t};\n\n\t\tconst languageId = tokens.getLanguageId(0);\n\t\tconst bracketsConfiguration = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n\t\tconst bracketsRegExp = bracketsConfiguration.getBracketRegExp({ global: true });\n\t\tconst textAndMetadata: { text: string; metadata: number }[] = [];\n\t\ttokens.forEach((tokenIndex: number) => {\n\t\t\tconst tokenType = tokens.getStandardTokenType(tokenIndex);\n\t\t\tlet text = tokens.getTokenText(tokenIndex);\n\t\t\tif (shouldRemoveBracketsFromTokenType(tokenType)) {\n\t\t\t\ttext = text.replace(bracketsRegExp, '');\n\t\t\t}\n\t\t\tconst metadata = tokens.getMetadata(tokenIndex);\n\t\t\ttextAndMetadata.push({ text, metadata });\n\t\t});\n\t\tconst processedLineTokens = LineTokens.createFromTextAndMetadata(textAndMetadata, tokens.languageIdCodec);\n\t\treturn processedLineTokens;\n\t}\n}\n\nexport function isLanguageDifferentFromLineStart(model: ITextModel, position: Position): boolean {\n\tmodel.tokenization.forceTokenization(position.lineNumber);\n\tconst lineTokens = model.tokenization.getLineTokens(position.lineNumber);\n\tconst scopedLineTokens = createScopedLineTokens(lineTokens, position.column - 1);\n\tconst doesScopeStartAtOffsetZero = scopedLineTokens.firstCharOffset === 0;\n\tconst isScopedLanguageEqualToFirstLanguageOnLine = lineTokens.getLanguageId(0) === scopedLineTokens.languageId;\n\tconst languageIsDifferentFromLineStart = !doesScopeStartAtOffsetZero && !isScopedLanguageEqualToFirstLanguageOnLine;\n\treturn languageIsDifferentFromLineStart;\n}\n"],
  "mappings": "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",
  "names": ["lineTokens", "newIndentation"]
}
