{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/languages/textToHtmlTokenizer.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from \"../../../base/common/charCode.js\";\nimport * as strings from \"../../../base/common/strings.js\";\nimport { LanguageId } from \"../encodedTokenAttributes.js\";\nimport {\n\ttype ILanguageIdCodec,\n\ttype IState,\n\ttype ITokenizationSupport,\n\tTokenizationRegistry,\n} from \"../languages.js\";\nimport { type IViewLineTokens, LineTokens } from \"../tokens/lineTokens.js\";\nimport type { ILanguageService } from \"./language.js\";\nimport { NullState, nullTokenizeEncoded } from \"./nullTokenize.js\";\n\nexport type IReducedTokenizationSupport = Omit<\n\tITokenizationSupport,\n\t\"tokenize\"\n>;\n\nconst fallback: IReducedTokenizationSupport = {\n\tgetInitialState: () => NullState,\n\ttokenizeEncoded: (buffer: string, hasEOL: boolean, state: IState) =>\n\t\tnullTokenizeEncoded(LanguageId.Null, state),\n};\n\nexport function tokenizeToStringSync(\n\tlanguageService: ILanguageService,\n\ttext: string,\n\tlanguageId: string,\n): string {\n\treturn _tokenizeToString(\n\t\ttext,\n\t\tlanguageService.languageIdCodec,\n\t\tTokenizationRegistry.get(languageId) || fallback,\n\t);\n}\n\nexport async function tokenizeToString(\n\tlanguageService: ILanguageService,\n\ttext: string,\n\tlanguageId: string | null,\n): Promise<string> {\n\tif (!languageId) {\n\t\treturn _tokenizeToString(\n\t\t\ttext,\n\t\t\tlanguageService.languageIdCodec,\n\t\t\tfallback,\n\t\t);\n\t}\n\tconst tokenizationSupport =\n\t\tawait TokenizationRegistry.getOrCreate(languageId);\n\treturn _tokenizeToString(\n\t\ttext,\n\t\tlanguageService.languageIdCodec,\n\t\ttokenizationSupport || fallback,\n\t);\n}\n\nexport function tokenizeLineToHTML(\n\ttext: string,\n\tviewLineTokens: IViewLineTokens,\n\tcolorMap: string[],\n\tstartOffset: number,\n\tendOffset: number,\n\ttabSize: number,\n\tuseNbsp: boolean,\n): string {\n\tlet result = `<div>`;\n\tlet charIndex = startOffset;\n\tlet tabsCharDelta = 0;\n\n\tlet prevIsSpace = true;\n\n\tfor (\n\t\tlet tokenIndex = 0, tokenCount = viewLineTokens.getCount();\n\t\ttokenIndex < tokenCount;\n\t\ttokenIndex++\n\t) {\n\t\tconst tokenEndIndex = viewLineTokens.getEndOffset(tokenIndex);\n\n\t\tif (tokenEndIndex <= startOffset) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet partContent = \"\";\n\n\t\tfor (\n\t\t\t;\n\t\t\tcharIndex < tokenEndIndex && charIndex < endOffset;\n\t\t\tcharIndex++\n\t\t) {\n\t\t\tconst charCode = text.charCodeAt(charIndex);\n\n\t\t\tswitch (charCode) {\n\t\t\t\tcase CharCode.Tab: {\n\t\t\t\t\tlet insertSpacesCount =\n\t\t\t\t\t\ttabSize - ((charIndex + tabsCharDelta) % tabSize);\n\t\t\t\t\ttabsCharDelta += insertSpacesCount - 1;\n\t\t\t\t\twhile (insertSpacesCount > 0) {\n\t\t\t\t\t\tif (useNbsp && prevIsSpace) {\n\t\t\t\t\t\t\tpartContent += \"&#160;\";\n\t\t\t\t\t\t\tprevIsSpace = false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpartContent += \" \";\n\t\t\t\t\t\t\tprevIsSpace = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinsertSpacesCount--;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase CharCode.LessThan:\n\t\t\t\t\tpartContent += \"&lt;\";\n\t\t\t\t\tprevIsSpace = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CharCode.GreaterThan:\n\t\t\t\t\tpartContent += \"&gt;\";\n\t\t\t\t\tprevIsSpace = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CharCode.Ampersand:\n\t\t\t\t\tpartContent += \"&amp;\";\n\t\t\t\t\tprevIsSpace = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CharCode.Null:\n\t\t\t\t\tpartContent += \"&#00;\";\n\t\t\t\t\tprevIsSpace = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CharCode.UTF8_BOM:\n\t\t\t\tcase CharCode.LINE_SEPARATOR:\n\t\t\t\tcase CharCode.PARAGRAPH_SEPARATOR:\n\t\t\t\tcase CharCode.NEXT_LINE:\n\t\t\t\t\tpartContent += \"\\ufffd\";\n\t\t\t\t\tprevIsSpace = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CharCode.CarriageReturn:\n\t\t\t\t\t// zero width space, because carriage return would introduce a line break\n\t\t\t\t\tpartContent += \"&#8203\";\n\t\t\t\t\tprevIsSpace = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CharCode.Space:\n\t\t\t\t\tif (useNbsp && prevIsSpace) {\n\t\t\t\t\t\tpartContent += \"&#160;\";\n\t\t\t\t\t\tprevIsSpace = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpartContent += \" \";\n\t\t\t\t\t\tprevIsSpace = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tpartContent += String.fromCharCode(charCode);\n\t\t\t\t\tprevIsSpace = false;\n\t\t\t}\n\t\t}\n\n\t\tresult += `<span style=\"${viewLineTokens.getInlineStyle(tokenIndex, colorMap)}\">${partContent}</span>`;\n\n\t\tif (tokenEndIndex > endOffset || charIndex >= endOffset) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tresult += `</div>`;\n\treturn result;\n}\n\nexport function _tokenizeToString(\n\ttext: string,\n\tlanguageIdCodec: ILanguageIdCodec,\n\ttokenizationSupport: IReducedTokenizationSupport,\n): string {\n\tlet result = `<div class=\"monaco-tokenized-source\">`;\n\tconst lines = strings.splitLines(text);\n\tlet currentState = tokenizationSupport.getInitialState();\n\tfor (let i = 0, len = lines.length; i < len; i++) {\n\t\tconst line = lines[i];\n\n\t\tif (i > 0) {\n\t\t\tresult += `<br/>`;\n\t\t}\n\n\t\tconst tokenizationResult = tokenizationSupport.tokenizeEncoded(\n\t\t\tline,\n\t\t\ttrue,\n\t\t\tcurrentState,\n\t\t);\n\t\tLineTokens.convertToEndOffset(tokenizationResult.tokens, line.length);\n\t\tconst lineTokens = new LineTokens(\n\t\t\ttokenizationResult.tokens,\n\t\t\tline,\n\t\t\tlanguageIdCodec,\n\t\t);\n\t\tconst viewLineTokens = lineTokens.inflate();\n\n\t\tlet startOffset = 0;\n\t\tfor (let j = 0, lenJ = viewLineTokens.getCount(); j < lenJ; j++) {\n\t\t\tconst type = viewLineTokens.getClassName(j);\n\t\t\tconst endIndex = viewLineTokens.getEndOffset(j);\n\t\t\tresult += `<span class=\"${type}\">${strings.escape(line.substring(startOffset, endIndex))}</span>`;\n\t\t\tstartOffset = endIndex;\n\t\t}\n\n\t\tcurrentState = tokenizationResult.endState;\n\t}\n\n\tresult += `</div>`;\n\treturn result;\n}\n"],
  "mappings": "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",
  "names": []
}
