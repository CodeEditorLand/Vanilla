{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/languages/languageConfiguration.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport { StandardTokenType } from '../encodedTokenAttributes.js';\nimport { ScopedLineTokens } from './supports.js';\n\n/**\n * Describes how comments for a language work.\n */\nexport interface CommentRule {\n\t/**\n\t * The line comment token, like `// this is a comment`\n\t */\n\tlineComment?: string | null;\n\t/**\n\t * The block comment character pair, like `/* block comment *&#47;`\n\t */\n\tblockComment?: CharacterPair | null;\n}\n\n/**\n * The language configuration interface defines the contract between extensions and\n * various editor features, like automatic bracket insertion, automatic indentation etc.\n */\nexport interface LanguageConfiguration {\n\t/**\n\t * The language's comment settings.\n\t */\n\tcomments?: CommentRule;\n\t/**\n\t * The language's brackets.\n\t * This configuration implicitly affects pressing Enter around these brackets.\n\t */\n\tbrackets?: CharacterPair[];\n\t/**\n\t * The language's word definition.\n\t * If the language supports Unicode identifiers (e.g. JavaScript), it is preferable\n\t * to provide a word definition that uses exclusion of known separators.\n\t * e.g.: A regex that matches anything except known separators (and dot is allowed to occur in a floating point number):\n\t *   /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\n\t */\n\twordPattern?: RegExp;\n\t/**\n\t * The language's indentation settings.\n\t */\n\tindentationRules?: IndentationRule;\n\t/**\n\t * The language's rules to be evaluated when pressing Enter.\n\t */\n\tonEnterRules?: OnEnterRule[];\n\t/**\n\t * The language's auto closing pairs. The 'close' character is automatically inserted with the\n\t * 'open' character is typed. If not set, the configured brackets will be used.\n\t */\n\tautoClosingPairs?: IAutoClosingPairConditional[];\n\t/**\n\t * The language's surrounding pairs. When the 'open' character is typed on a selection, the\n\t * selected string is surrounded by the open and close characters. If not set, the autoclosing pairs\n\t * settings will be used.\n\t */\n\tsurroundingPairs?: IAutoClosingPair[];\n\t/**\n\t * Defines a list of bracket pairs that are colorized depending on their nesting level.\n\t * If not set, the configured brackets will be used.\n\t*/\n\tcolorizedBracketPairs?: CharacterPair[];\n\t/**\n\t * Defines what characters must be after the cursor for bracket or quote autoclosing to occur when using the \\'languageDefined\\' autoclosing setting.\n\t *\n\t * This is typically the set of characters which can not start an expression, such as whitespace, closing brackets, non-unary operators, etc.\n\t */\n\tautoCloseBefore?: string;\n\n\t/**\n\t * The language's folding rules.\n\t */\n\tfolding?: FoldingRules;\n\n\t/**\n\t * **Deprecated** Do not use.\n\t *\n\t * @deprecated Will be replaced by a better API soon.\n\t */\n\t__electricCharacterSupport?: {\n\t\tdocComment?: IDocComment;\n\t};\n}\n\n/**\n * @internal\n */\ntype OrUndefined<T> = { [P in keyof T]: T[P] | undefined };\n\n/**\n * @internal\n */\nexport type ExplicitLanguageConfiguration = OrUndefined<Required<LanguageConfiguration>>;\n\n/**\n * Describes indentation rules for a language.\n */\nexport interface IndentationRule {\n\t/**\n\t * If a line matches this pattern, then all the lines after it should be unindented once (until another rule matches).\n\t */\n\tdecreaseIndentPattern: RegExp;\n\t/**\n\t * If a line matches this pattern, then all the lines after it should be indented once (until another rule matches).\n\t */\n\tincreaseIndentPattern: RegExp;\n\t/**\n\t * If a line matches this pattern, then **only the next line** after it should be indented once.\n\t */\n\tindentNextLinePattern?: RegExp | null;\n\t/**\n\t * If a line matches this pattern, then its indentation should not be changed and it should not be evaluated against the other rules.\n\t */\n\tunIndentedLinePattern?: RegExp | null;\n\n}\n\n/**\n * Describes language specific folding markers such as '#region' and '#endregion'.\n * The start and end regexes will be tested against the contents of all lines and must be designed efficiently:\n * - the regex should start with '^'\n * - regexp flags (i, g) are ignored\n */\nexport interface FoldingMarkers {\n\tstart: RegExp;\n\tend: RegExp;\n}\n\n/**\n * Describes folding rules for a language.\n */\nexport interface FoldingRules {\n\t/**\n\t * Used by the indentation based strategy to decide whether empty lines belong to the previous or the next block.\n\t * A language adheres to the off-side rule if blocks in that language are expressed by their indentation.\n\t * See [wikipedia](https://en.wikipedia.org/wiki/Off-side_rule) for more information.\n\t * If not set, `false` is used and empty lines belong to the previous block.\n\t */\n\toffSide?: boolean;\n\n\t/**\n\t * Region markers used by the language.\n\t */\n\tmarkers?: FoldingMarkers;\n}\n\n/**\n * Describes a rule to be evaluated when pressing Enter.\n */\nexport interface OnEnterRule {\n\t/**\n\t * This rule will only execute if the text before the cursor matches this regular expression.\n\t */\n\tbeforeText: RegExp;\n\t/**\n\t * This rule will only execute if the text after the cursor matches this regular expression.\n\t */\n\tafterText?: RegExp;\n\t/**\n\t * This rule will only execute if the text above the this line matches this regular expression.\n\t */\n\tpreviousLineText?: RegExp;\n\t/**\n\t * The action to execute.\n\t */\n\taction: EnterAction;\n}\n\n/**\n * Definition of documentation comments (e.g. Javadoc/JSdoc)\n */\nexport interface IDocComment {\n\t/**\n\t * The string that starts a doc comment (e.g. '/**')\n\t */\n\topen: string;\n\t/**\n\t * The string that appears on the last line and closes the doc comment (e.g. ' * /').\n\t */\n\tclose?: string;\n}\n\n/**\n * A tuple of two characters, like a pair of\n * opening and closing brackets.\n */\nexport type CharacterPair = [string, string];\n\nexport interface IAutoClosingPair {\n\topen: string;\n\tclose: string;\n}\n\nexport interface IAutoClosingPairConditional extends IAutoClosingPair {\n\tnotIn?: string[];\n}\n\n/**\n * Describes what to do with the indentation when pressing Enter.\n */\nexport enum IndentAction {\n\t/**\n\t * Insert new line and copy the previous line's indentation.\n\t */\n\tNone = 0,\n\t/**\n\t * Insert new line and indent once (relative to the previous line's indentation).\n\t */\n\tIndent = 1,\n\t/**\n\t * Insert two new lines:\n\t *  - the first one indented which will hold the cursor\n\t *  - the second one at the same indentation level\n\t */\n\tIndentOutdent = 2,\n\t/**\n\t * Insert new line and outdent once (relative to the previous line's indentation).\n\t */\n\tOutdent = 3\n}\n\n/**\n * Describes what to do when pressing Enter.\n */\nexport interface EnterAction {\n\t/**\n\t * Describe what to do with the indentation.\n\t */\n\tindentAction: IndentAction;\n\t/**\n\t * Describes text to be appended after the new line and after the indentation.\n\t */\n\tappendText?: string;\n\t/**\n\t * Describes the number of characters to remove from the new line's indentation.\n\t */\n\tremoveText?: number;\n}\n\n/**\n * @internal\n */\nexport interface CompleteEnterAction {\n\t/**\n\t * Describe what to do with the indentation.\n\t */\n\tindentAction: IndentAction;\n\t/**\n\t * Describes text to be appended after the new line and after the indentation.\n\t */\n\tappendText: string;\n\t/**\n\t * Describes the number of characters to remove from the new line's indentation.\n\t */\n\tremoveText: number;\n\t/**\n\t * The line's indentation minus removeText\n\t */\n\tindentation: string;\n}\n\n/**\n * @internal\n */\nexport class StandardAutoClosingPairConditional {\n\n\treadonly open: string;\n\treadonly close: string;\n\tprivate readonly _inString: boolean;\n\tprivate readonly _inComment: boolean;\n\tprivate readonly _inRegEx: boolean;\n\tprivate _neutralCharacter: string | null = null;\n\tprivate _neutralCharacterSearched: boolean = false;\n\n\tconstructor(source: IAutoClosingPairConditional) {\n\t\tthis.open = source.open;\n\t\tthis.close = source.close;\n\n\t\t// initially allowed in all tokens\n\t\tthis._inString = true;\n\t\tthis._inComment = true;\n\t\tthis._inRegEx = true;\n\n\t\tif (Array.isArray(source.notIn)) {\n\t\t\tfor (let i = 0, len = source.notIn.length; i < len; i++) {\n\t\t\t\tconst notIn: string = source.notIn[i];\n\t\t\t\tswitch (notIn) {\n\t\t\t\t\tcase 'string':\n\t\t\t\t\t\tthis._inString = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'comment':\n\t\t\t\t\t\tthis._inComment = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'regex':\n\t\t\t\t\t\tthis._inRegEx = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic isOK(standardToken: StandardTokenType): boolean {\n\t\tswitch (standardToken) {\n\t\t\tcase StandardTokenType.Other:\n\t\t\t\treturn true;\n\t\t\tcase StandardTokenType.Comment:\n\t\t\t\treturn this._inComment;\n\t\t\tcase StandardTokenType.String:\n\t\t\t\treturn this._inString;\n\t\t\tcase StandardTokenType.RegEx:\n\t\t\t\treturn this._inRegEx;\n\t\t}\n\t}\n\n\tpublic shouldAutoClose(context: ScopedLineTokens, column: number): boolean {\n\t\t// Always complete on empty line\n\t\tif (context.getTokenCount() === 0) {\n\t\t\treturn true;\n\t\t}\n\n\t\tconst tokenIndex = context.findTokenIndexAtOffset(column - 2);\n\t\tconst standardTokenType = context.getStandardTokenType(tokenIndex);\n\t\treturn this.isOK(standardTokenType);\n\t}\n\n\tprivate _findNeutralCharacterInRange(fromCharCode: number, toCharCode: number): string | null {\n\t\tfor (let charCode = fromCharCode; charCode <= toCharCode; charCode++) {\n\t\t\tconst character = String.fromCharCode(charCode);\n\t\t\tif (!this.open.includes(character) && !this.close.includes(character)) {\n\t\t\t\treturn character;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Find a character in the range [0-9a-zA-Z] that does not appear in the open or close\n\t */\n\tpublic findNeutralCharacter(): string | null {\n\t\tif (!this._neutralCharacterSearched) {\n\t\t\tthis._neutralCharacterSearched = true;\n\t\t\tif (!this._neutralCharacter) {\n\t\t\t\tthis._neutralCharacter = this._findNeutralCharacterInRange(CharCode.Digit0, CharCode.Digit9);\n\t\t\t}\n\t\t\tif (!this._neutralCharacter) {\n\t\t\t\tthis._neutralCharacter = this._findNeutralCharacterInRange(CharCode.a, CharCode.z);\n\t\t\t}\n\t\t\tif (!this._neutralCharacter) {\n\t\t\t\tthis._neutralCharacter = this._findNeutralCharacterInRange(CharCode.A, CharCode.Z);\n\t\t\t}\n\t\t}\n\t\treturn this._neutralCharacter;\n\t}\n}\n\n/**\n * @internal\n */\nexport class AutoClosingPairs {\n\t// it is useful to be able to get pairs using either end of open and close\n\n\t/** Key is first character of open */\n\tpublic readonly autoClosingPairsOpenByStart: Map<string, StandardAutoClosingPairConditional[]>;\n\t/** Key is last character of open */\n\tpublic readonly autoClosingPairsOpenByEnd: Map<string, StandardAutoClosingPairConditional[]>;\n\t/** Key is first character of close */\n\tpublic readonly autoClosingPairsCloseByStart: Map<string, StandardAutoClosingPairConditional[]>;\n\t/** Key is last character of close */\n\tpublic readonly autoClosingPairsCloseByEnd: Map<string, StandardAutoClosingPairConditional[]>;\n\t/** Key is close. Only has pairs that are a single character */\n\tpublic readonly autoClosingPairsCloseSingleChar: Map<string, StandardAutoClosingPairConditional[]>;\n\n\tconstructor(autoClosingPairs: StandardAutoClosingPairConditional[]) {\n\t\tthis.autoClosingPairsOpenByStart = new Map<string, StandardAutoClosingPairConditional[]>();\n\t\tthis.autoClosingPairsOpenByEnd = new Map<string, StandardAutoClosingPairConditional[]>();\n\t\tthis.autoClosingPairsCloseByStart = new Map<string, StandardAutoClosingPairConditional[]>();\n\t\tthis.autoClosingPairsCloseByEnd = new Map<string, StandardAutoClosingPairConditional[]>();\n\t\tthis.autoClosingPairsCloseSingleChar = new Map<string, StandardAutoClosingPairConditional[]>();\n\t\tfor (const pair of autoClosingPairs) {\n\t\t\tappendEntry(this.autoClosingPairsOpenByStart, pair.open.charAt(0), pair);\n\t\t\tappendEntry(this.autoClosingPairsOpenByEnd, pair.open.charAt(pair.open.length - 1), pair);\n\t\t\tappendEntry(this.autoClosingPairsCloseByStart, pair.close.charAt(0), pair);\n\t\t\tappendEntry(this.autoClosingPairsCloseByEnd, pair.close.charAt(pair.close.length - 1), pair);\n\t\t\tif (pair.close.length === 1 && pair.open.length === 1) {\n\t\t\t\tappendEntry(this.autoClosingPairsCloseSingleChar, pair.close, pair);\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction appendEntry<K, V>(target: Map<K, V[]>, key: K, value: V): void {\n\tif (target.has(key)) {\n\t\ttarget.get(key)!.push(value);\n\t} else {\n\t\ttarget.set(key, [value]);\n\t}\n}\n"],
  "mappings": "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",
  "names": ["IndentAction"]
}
