{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/languages/autoIndent.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from \"../../../base/common/strings.js\";\nimport { EditorAutoIndentStrategy } from \"../config/editorOptions.js\";\nimport type { Range } from \"../core/range.js\";\nimport type { CursorConfiguration } from \"../cursorCommon.js\";\nimport type { ITextModel } from \"../model.js\";\nimport type { IViewLineTokens } from \"../tokens/lineTokens.js\";\nimport { IndentAction } from \"./languageConfiguration.js\";\nimport type { ILanguageConfigurationService } from \"./languageConfigurationRegistry.js\";\nimport { IndentConsts } from \"./supports/indentRules.js\";\nimport {\n\tIndentationContextProcessor,\n\tProcessedIndentRulesSupport,\n\tisLanguageDifferentFromLineStart,\n} from \"./supports/indentationLineProcessor.js\";\n\nexport interface IVirtualModel {\n\ttokenization: {\n\t\tgetLineTokens(lineNumber: number): IViewLineTokens;\n\t\tgetLanguageId(): string;\n\t\tgetLanguageIdAtPosition(lineNumber: number, column: number): string;\n\t\tforceTokenization?(lineNumber: number): void;\n\t};\n\tgetLineContent(lineNumber: number): string;\n}\n\nexport interface IIndentConverter {\n\tshiftIndent(indentation: string): string;\n\tunshiftIndent(indentation: string): string;\n\tnormalizeIndentation?(indentation: string): string;\n}\n\n/**\n * Get nearest preceding line which doesn't match unIndentPattern or contains all whitespace.\n * Result:\n * -1: run into the boundary of embedded languages\n * 0: every line above are invalid\n * else: nearest preceding line of the same language\n */\nfunction getPrecedingValidLine(\n\tmodel: IVirtualModel,\n\tlineNumber: number,\n\tprocessedIndentRulesSupport: ProcessedIndentRulesSupport,\n) {\n\tconst languageId = model.tokenization.getLanguageIdAtPosition(\n\t\tlineNumber,\n\t\t0,\n\t);\n\tif (lineNumber > 1) {\n\t\tlet lastLineNumber: number;\n\t\tlet resultLineNumber = -1;\n\n\t\tfor (\n\t\t\tlastLineNumber = lineNumber - 1;\n\t\t\tlastLineNumber >= 1;\n\t\t\tlastLineNumber--\n\t\t) {\n\t\t\tif (\n\t\t\t\tmodel.tokenization.getLanguageIdAtPosition(\n\t\t\t\t\tlastLineNumber,\n\t\t\t\t\t0,\n\t\t\t\t) !== languageId\n\t\t\t) {\n\t\t\t\treturn resultLineNumber;\n\t\t\t}\n\t\t\tconst text = model.getLineContent(lastLineNumber);\n\t\t\tif (\n\t\t\t\tprocessedIndentRulesSupport.shouldIgnore(lastLineNumber) ||\n\t\t\t\t/^\\s+$/.test(text) ||\n\t\t\t\ttext === \"\"\n\t\t\t) {\n\t\t\t\tresultLineNumber = lastLineNumber;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treturn lastLineNumber;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/**\n * Get inherited indentation from above lines.\n * 1. Find the nearest preceding line which doesn't match unIndentedLinePattern.\n * 2. If this line matches indentNextLinePattern or increaseIndentPattern, it means that the indent level of `lineNumber` should be 1 greater than this line.\n * 3. If this line doesn't match any indent rules\n *   a. check whether the line above it matches indentNextLinePattern\n *   b. If not, the indent level of this line is the result\n *   c. If so, it means the indent of this line is *temporary*, go upward utill we find a line whose indent is not temporary (the same workflow a -> b -> c).\n * 4. Otherwise, we fail to get an inherited indent from aboves. Return null and we should not touch the indent of `lineNumber`\n *\n * This function only return the inherited indent based on above lines, it doesn't check whether current line should decrease or not.\n */\nexport function getInheritIndentForLine(\n\tautoIndent: EditorAutoIndentStrategy,\n\tmodel: IVirtualModel,\n\tlineNumber: number,\n\thonorIntentialIndent = true,\n\tlanguageConfigurationService: ILanguageConfigurationService,\n): { indentation: string; action: IndentAction | null; line?: number } | null {\n\tif (autoIndent < EditorAutoIndentStrategy.Full) {\n\t\treturn null;\n\t}\n\n\tconst indentRulesSupport =\n\t\tlanguageConfigurationService.getLanguageConfiguration(\n\t\t\tmodel.tokenization.getLanguageId(),\n\t\t).indentRulesSupport;\n\tif (!indentRulesSupport) {\n\t\treturn null;\n\t}\n\tconst processedIndentRulesSupport = new ProcessedIndentRulesSupport(\n\t\tmodel,\n\t\tindentRulesSupport,\n\t\tlanguageConfigurationService,\n\t);\n\n\tif (lineNumber <= 1) {\n\t\treturn {\n\t\t\tindentation: \"\",\n\t\t\taction: null,\n\t\t};\n\t}\n\n\t// Use no indent if this is the first non-blank line\n\tfor (\n\t\tlet priorLineNumber = lineNumber - 1;\n\t\tpriorLineNumber > 0;\n\t\tpriorLineNumber--\n\t) {\n\t\tif (model.getLineContent(priorLineNumber) !== \"\") {\n\t\t\tbreak;\n\t\t}\n\t\tif (priorLineNumber === 1) {\n\t\t\treturn {\n\t\t\t\tindentation: \"\",\n\t\t\t\taction: null,\n\t\t\t};\n\t\t}\n\t}\n\n\tconst precedingUnIgnoredLine = getPrecedingValidLine(\n\t\tmodel,\n\t\tlineNumber,\n\t\tprocessedIndentRulesSupport,\n\t);\n\tif (precedingUnIgnoredLine < 0) {\n\t\treturn null;\n\t} else if (precedingUnIgnoredLine < 1) {\n\t\treturn {\n\t\t\tindentation: \"\",\n\t\t\taction: null,\n\t\t};\n\t}\n\n\tif (\n\t\tprocessedIndentRulesSupport.shouldIncrease(precedingUnIgnoredLine) ||\n\t\tprocessedIndentRulesSupport.shouldIndentNextLine(precedingUnIgnoredLine)\n\t) {\n\t\tconst precedingUnIgnoredLineContent = model.getLineContent(\n\t\t\tprecedingUnIgnoredLine,\n\t\t);\n\t\treturn {\n\t\t\tindentation: strings.getLeadingWhitespace(\n\t\t\t\tprecedingUnIgnoredLineContent,\n\t\t\t),\n\t\t\taction: IndentAction.Indent,\n\t\t\tline: precedingUnIgnoredLine,\n\t\t};\n\t} else if (\n\t\tprocessedIndentRulesSupport.shouldDecrease(precedingUnIgnoredLine)\n\t) {\n\t\tconst precedingUnIgnoredLineContent = model.getLineContent(\n\t\t\tprecedingUnIgnoredLine,\n\t\t);\n\t\treturn {\n\t\t\tindentation: strings.getLeadingWhitespace(\n\t\t\t\tprecedingUnIgnoredLineContent,\n\t\t\t),\n\t\t\taction: null,\n\t\t\tline: precedingUnIgnoredLine,\n\t\t};\n\t} else {\n\t\t// precedingUnIgnoredLine can not be ignored.\n\t\t// it doesn't increase indent of following lines\n\t\t// it doesn't increase just next line\n\t\t// so current line is not affect by precedingUnIgnoredLine\n\t\t// and then we should get a correct inheritted indentation from above lines\n\t\tif (precedingUnIgnoredLine === 1) {\n\t\t\treturn {\n\t\t\t\tindentation: strings.getLeadingWhitespace(\n\t\t\t\t\tmodel.getLineContent(precedingUnIgnoredLine),\n\t\t\t\t),\n\t\t\t\taction: null,\n\t\t\t\tline: precedingUnIgnoredLine,\n\t\t\t};\n\t\t}\n\n\t\tconst previousLine = precedingUnIgnoredLine - 1;\n\n\t\tconst previousLineIndentMetadata = indentRulesSupport.getIndentMetadata(\n\t\t\tmodel.getLineContent(previousLine),\n\t\t);\n\t\tif (\n\t\t\t!(\n\t\t\t\tpreviousLineIndentMetadata &\n\t\t\t\t(IndentConsts.INCREASE_MASK | IndentConsts.DECREASE_MASK)\n\t\t\t) &&\n\t\t\tpreviousLineIndentMetadata & IndentConsts.INDENT_NEXTLINE_MASK\n\t\t) {\n\t\t\tlet stopLine = 0;\n\t\t\tfor (let i = previousLine - 1; i > 0; i--) {\n\t\t\t\tif (processedIndentRulesSupport.shouldIndentNextLine(i)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tstopLine = i;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tindentation: strings.getLeadingWhitespace(\n\t\t\t\t\tmodel.getLineContent(stopLine + 1),\n\t\t\t\t),\n\t\t\t\taction: null,\n\t\t\t\tline: stopLine + 1,\n\t\t\t};\n\t\t}\n\n\t\tif (honorIntentialIndent) {\n\t\t\treturn {\n\t\t\t\tindentation: strings.getLeadingWhitespace(\n\t\t\t\t\tmodel.getLineContent(precedingUnIgnoredLine),\n\t\t\t\t),\n\t\t\t\taction: null,\n\t\t\t\tline: precedingUnIgnoredLine,\n\t\t\t};\n\t\t} else {\n\t\t\t// search from precedingUnIgnoredLine until we find one whose indent is not temporary\n\t\t\tfor (let i = precedingUnIgnoredLine; i > 0; i--) {\n\t\t\t\tif (processedIndentRulesSupport.shouldIncrease(i)) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tindentation: strings.getLeadingWhitespace(\n\t\t\t\t\t\t\tmodel.getLineContent(i),\n\t\t\t\t\t\t),\n\t\t\t\t\t\taction: IndentAction.Indent,\n\t\t\t\t\t\tline: i,\n\t\t\t\t\t};\n\t\t\t\t} else if (\n\t\t\t\t\tprocessedIndentRulesSupport.shouldIndentNextLine(i)\n\t\t\t\t) {\n\t\t\t\t\tlet stopLine = 0;\n\t\t\t\t\tfor (let j = i - 1; j > 0; j--) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tprocessedIndentRulesSupport.shouldIndentNextLine(i)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstopLine = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tindentation: strings.getLeadingWhitespace(\n\t\t\t\t\t\t\tmodel.getLineContent(stopLine + 1),\n\t\t\t\t\t\t),\n\t\t\t\t\t\taction: null,\n\t\t\t\t\t\tline: stopLine + 1,\n\t\t\t\t\t};\n\t\t\t\t} else if (processedIndentRulesSupport.shouldDecrease(i)) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tindentation: strings.getLeadingWhitespace(\n\t\t\t\t\t\t\tmodel.getLineContent(i),\n\t\t\t\t\t\t),\n\t\t\t\t\t\taction: null,\n\t\t\t\t\t\tline: i,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tindentation: strings.getLeadingWhitespace(\n\t\t\t\t\tmodel.getLineContent(1),\n\t\t\t\t),\n\t\t\t\taction: null,\n\t\t\t\tline: 1,\n\t\t\t};\n\t\t}\n\t}\n}\n\nexport function getGoodIndentForLine(\n\tautoIndent: EditorAutoIndentStrategy,\n\tvirtualModel: IVirtualModel,\n\tlanguageId: string,\n\tlineNumber: number,\n\tindentConverter: IIndentConverter,\n\tlanguageConfigurationService: ILanguageConfigurationService,\n): string | null {\n\tif (autoIndent < EditorAutoIndentStrategy.Full) {\n\t\treturn null;\n\t}\n\n\tconst richEditSupport =\n\t\tlanguageConfigurationService.getLanguageConfiguration(languageId);\n\tif (!richEditSupport) {\n\t\treturn null;\n\t}\n\n\tconst indentRulesSupport =\n\t\tlanguageConfigurationService.getLanguageConfiguration(\n\t\t\tlanguageId,\n\t\t).indentRulesSupport;\n\tif (!indentRulesSupport) {\n\t\treturn null;\n\t}\n\n\tconst processedIndentRulesSupport = new ProcessedIndentRulesSupport(\n\t\tvirtualModel,\n\t\tindentRulesSupport,\n\t\tlanguageConfigurationService,\n\t);\n\tconst indent = getInheritIndentForLine(\n\t\tautoIndent,\n\t\tvirtualModel,\n\t\tlineNumber,\n\t\tundefined,\n\t\tlanguageConfigurationService,\n\t);\n\n\tif (indent) {\n\t\tconst inheritLine = indent.line;\n\t\tif (inheritLine !== undefined) {\n\t\t\t// Apply enter action as long as there are only whitespace lines between inherited line and this line.\n\t\t\tlet shouldApplyEnterRules = true;\n\t\t\tfor (\n\t\t\t\tlet inBetweenLine = inheritLine;\n\t\t\t\tinBetweenLine < lineNumber - 1;\n\t\t\t\tinBetweenLine++\n\t\t\t) {\n\t\t\t\tif (!/^\\s*$/.test(virtualModel.getLineContent(inBetweenLine))) {\n\t\t\t\t\tshouldApplyEnterRules = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (shouldApplyEnterRules) {\n\t\t\t\tconst enterResult = richEditSupport.onEnter(\n\t\t\t\t\tautoIndent,\n\t\t\t\t\t\"\",\n\t\t\t\t\tvirtualModel.getLineContent(inheritLine),\n\t\t\t\t\t\"\",\n\t\t\t\t);\n\n\t\t\t\tif (enterResult) {\n\t\t\t\t\tlet indentation = strings.getLeadingWhitespace(\n\t\t\t\t\t\tvirtualModel.getLineContent(inheritLine),\n\t\t\t\t\t);\n\n\t\t\t\t\tif (enterResult.removeText) {\n\t\t\t\t\t\tindentation = indentation.substring(\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\tindentation.length - enterResult.removeText,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tenterResult.indentAction === IndentAction.Indent ||\n\t\t\t\t\t\tenterResult.indentAction === IndentAction.IndentOutdent\n\t\t\t\t\t) {\n\t\t\t\t\t\tindentation = indentConverter.shiftIndent(indentation);\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tenterResult.indentAction === IndentAction.Outdent\n\t\t\t\t\t) {\n\t\t\t\t\t\tindentation =\n\t\t\t\t\t\t\tindentConverter.unshiftIndent(indentation);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tprocessedIndentRulesSupport.shouldDecrease(lineNumber)\n\t\t\t\t\t) {\n\t\t\t\t\t\tindentation =\n\t\t\t\t\t\t\tindentConverter.unshiftIndent(indentation);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (enterResult.appendText) {\n\t\t\t\t\t\tindentation += enterResult.appendText;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn strings.getLeadingWhitespace(indentation);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (processedIndentRulesSupport.shouldDecrease(lineNumber)) {\n\t\t\tif (indent.action === IndentAction.Indent) {\n\t\t\t\treturn indent.indentation;\n\t\t\t} else {\n\t\t\t\treturn indentConverter.unshiftIndent(indent.indentation);\n\t\t\t}\n\t\t} else if (indent.action === IndentAction.Indent) {\n\t\t\treturn indentConverter.shiftIndent(indent.indentation);\n\t\t} else {\n\t\t\treturn indent.indentation;\n\t\t}\n\t}\n\treturn null;\n}\n\nexport function getIndentForEnter(\n\tautoIndent: EditorAutoIndentStrategy,\n\tmodel: ITextModel,\n\trange: Range,\n\tindentConverter: IIndentConverter,\n\tlanguageConfigurationService: ILanguageConfigurationService,\n): { beforeEnter: string; afterEnter: string } | null {\n\tif (autoIndent < EditorAutoIndentStrategy.Full) {\n\t\treturn null;\n\t}\n\tconst languageId = model.getLanguageIdAtPosition(\n\t\trange.startLineNumber,\n\t\trange.startColumn,\n\t);\n\tconst indentRulesSupport =\n\t\tlanguageConfigurationService.getLanguageConfiguration(\n\t\t\tlanguageId,\n\t\t).indentRulesSupport;\n\tif (!indentRulesSupport) {\n\t\treturn null;\n\t}\n\n\tmodel.tokenization.forceTokenization(range.startLineNumber);\n\tconst indentationContextProcessor = new IndentationContextProcessor(\n\t\tmodel,\n\t\tlanguageConfigurationService,\n\t);\n\tconst processedContextTokens =\n\t\tindentationContextProcessor.getProcessedTokenContextAroundRange(range);\n\tconst afterEnterProcessedTokens =\n\t\tprocessedContextTokens.afterRangeProcessedTokens;\n\tconst beforeEnterProcessedTokens =\n\t\tprocessedContextTokens.beforeRangeProcessedTokens;\n\tconst beforeEnterIndent = strings.getLeadingWhitespace(\n\t\tbeforeEnterProcessedTokens.getLineContent(),\n\t);\n\n\tconst virtualModel = createVirtualModelWithModifiedTokensAtLine(\n\t\tmodel,\n\t\trange.startLineNumber,\n\t\tbeforeEnterProcessedTokens,\n\t);\n\tconst languageIsDifferentFromLineStart = isLanguageDifferentFromLineStart(\n\t\tmodel,\n\t\trange.getStartPosition(),\n\t);\n\tconst currentLine = model.getLineContent(range.startLineNumber);\n\tconst currentLineIndent = strings.getLeadingWhitespace(currentLine);\n\tconst afterEnterAction = getInheritIndentForLine(\n\t\tautoIndent,\n\t\tvirtualModel,\n\t\trange.startLineNumber + 1,\n\t\tundefined,\n\t\tlanguageConfigurationService,\n\t);\n\tif (!afterEnterAction) {\n\t\tconst beforeEnter = languageIsDifferentFromLineStart\n\t\t\t? currentLineIndent\n\t\t\t: beforeEnterIndent;\n\t\treturn {\n\t\t\tbeforeEnter: beforeEnter,\n\t\t\tafterEnter: beforeEnter,\n\t\t};\n\t}\n\n\tlet afterEnterIndent = languageIsDifferentFromLineStart\n\t\t? currentLineIndent\n\t\t: afterEnterAction.indentation;\n\n\tif (afterEnterAction.action === IndentAction.Indent) {\n\t\tafterEnterIndent = indentConverter.shiftIndent(afterEnterIndent);\n\t}\n\n\tif (\n\t\tindentRulesSupport.shouldDecrease(\n\t\t\tafterEnterProcessedTokens.getLineContent(),\n\t\t)\n\t) {\n\t\tafterEnterIndent = indentConverter.unshiftIndent(afterEnterIndent);\n\t}\n\n\treturn {\n\t\tbeforeEnter: languageIsDifferentFromLineStart\n\t\t\t? currentLineIndent\n\t\t\t: beforeEnterIndent,\n\t\tafterEnter: afterEnterIndent,\n\t};\n}\n\n/**\n * We should always allow intentional indentation. It means, if users change the indentation of `lineNumber` and the content of\n * this line doesn't match decreaseIndentPattern, we should not adjust the indentation.\n */\nexport function getIndentActionForType(\n\tcursorConfig: CursorConfiguration,\n\tmodel: ITextModel,\n\trange: Range,\n\tch: string,\n\tindentConverter: IIndentConverter,\n\tlanguageConfigurationService: ILanguageConfigurationService,\n): string | null {\n\tconst autoIndent = cursorConfig.autoIndent;\n\tif (autoIndent < EditorAutoIndentStrategy.Full) {\n\t\treturn null;\n\t}\n\tconst languageIsDifferentFromLineStart = isLanguageDifferentFromLineStart(\n\t\tmodel,\n\t\trange.getStartPosition(),\n\t);\n\tif (languageIsDifferentFromLineStart) {\n\t\t// this line has mixed languages and indentation rules will not work\n\t\treturn null;\n\t}\n\n\tconst languageId = model.getLanguageIdAtPosition(\n\t\trange.startLineNumber,\n\t\trange.startColumn,\n\t);\n\tconst indentRulesSupport =\n\t\tlanguageConfigurationService.getLanguageConfiguration(\n\t\t\tlanguageId,\n\t\t).indentRulesSupport;\n\tif (!indentRulesSupport) {\n\t\treturn null;\n\t}\n\n\tconst indentationContextProcessor = new IndentationContextProcessor(\n\t\tmodel,\n\t\tlanguageConfigurationService,\n\t);\n\tconst processedContextTokens =\n\t\tindentationContextProcessor.getProcessedTokenContextAroundRange(range);\n\tconst beforeRangeText =\n\t\tprocessedContextTokens.beforeRangeProcessedTokens.getLineContent();\n\tconst afterRangeText =\n\t\tprocessedContextTokens.afterRangeProcessedTokens.getLineContent();\n\tconst textAroundRange = beforeRangeText + afterRangeText;\n\tconst textAroundRangeWithCharacter = beforeRangeText + ch + afterRangeText;\n\n\t// If previous content already matches decreaseIndentPattern, it means indentation of this line should already be adjusted\n\t// Users might change the indentation by purpose and we should honor that instead of readjusting.\n\tif (\n\t\t!indentRulesSupport.shouldDecrease(textAroundRange) &&\n\t\tindentRulesSupport.shouldDecrease(textAroundRangeWithCharacter)\n\t) {\n\t\t// after typing `ch`, the content matches decreaseIndentPattern, we should adjust the indent to a good manner.\n\t\t// 1. Get inherited indent action\n\t\tconst r = getInheritIndentForLine(\n\t\t\tautoIndent,\n\t\t\tmodel,\n\t\t\trange.startLineNumber,\n\t\t\tfalse,\n\t\t\tlanguageConfigurationService,\n\t\t);\n\t\tif (!r) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet indentation = r.indentation;\n\t\tif (r.action !== IndentAction.Indent) {\n\t\t\tindentation = indentConverter.unshiftIndent(indentation);\n\t\t}\n\n\t\treturn indentation;\n\t}\n\n\tconst previousLineNumber = range.startLineNumber - 1;\n\tif (previousLineNumber > 0) {\n\t\tconst previousLine = model.getLineContent(previousLineNumber);\n\t\tif (\n\t\t\tindentRulesSupport.shouldIndentNextLine(previousLine) &&\n\t\t\tindentRulesSupport.shouldIncrease(textAroundRangeWithCharacter)\n\t\t) {\n\t\t\tconst inheritedIndentationData = getInheritIndentForLine(\n\t\t\t\tautoIndent,\n\t\t\t\tmodel,\n\t\t\t\trange.startLineNumber,\n\t\t\t\tfalse,\n\t\t\t\tlanguageConfigurationService,\n\t\t\t);\n\t\t\tconst inheritedIndentation = inheritedIndentationData?.indentation;\n\t\t\tif (inheritedIndentation !== undefined) {\n\t\t\t\tconst currentLine = model.getLineContent(range.startLineNumber);\n\t\t\t\tconst actualCurrentIndentation =\n\t\t\t\t\tstrings.getLeadingWhitespace(currentLine);\n\t\t\t\tconst inferredCurrentIndentation =\n\t\t\t\t\tindentConverter.shiftIndent(inheritedIndentation);\n\t\t\t\t// If the inferred current indentation is not equal to the actual current indentation, then the indentation has been intentionally changed, in that case keep it\n\t\t\t\tconst inferredIndentationEqualsActual =\n\t\t\t\t\tinferredCurrentIndentation === actualCurrentIndentation;\n\t\t\t\tconst textAroundRangeContainsOnlyWhitespace = /^\\s*$/.test(\n\t\t\t\t\ttextAroundRange,\n\t\t\t\t);\n\t\t\t\tconst autoClosingPairs =\n\t\t\t\t\tcursorConfig.autoClosingPairs.autoClosingPairsOpenByEnd.get(\n\t\t\t\t\t\tch,\n\t\t\t\t\t);\n\t\t\t\tconst autoClosingPairExists =\n\t\t\t\t\tautoClosingPairs && autoClosingPairs.length > 0;\n\t\t\t\tconst isChFirstNonWhitespaceCharacterAndInAutoClosingPair =\n\t\t\t\t\tautoClosingPairExists &&\n\t\t\t\t\ttextAroundRangeContainsOnlyWhitespace;\n\t\t\t\tif (\n\t\t\t\t\tinferredIndentationEqualsActual &&\n\t\t\t\t\tisChFirstNonWhitespaceCharacterAndInAutoClosingPair\n\t\t\t\t) {\n\t\t\t\t\treturn inheritedIndentation;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n}\n\nexport function getIndentMetadata(\n\tmodel: ITextModel,\n\tlineNumber: number,\n\tlanguageConfigurationService: ILanguageConfigurationService,\n): number | null {\n\tconst indentRulesSupport =\n\t\tlanguageConfigurationService.getLanguageConfiguration(\n\t\t\tmodel.getLanguageId(),\n\t\t).indentRulesSupport;\n\tif (!indentRulesSupport) {\n\t\treturn null;\n\t}\n\tif (lineNumber < 1 || lineNumber > model.getLineCount()) {\n\t\treturn null;\n\t}\n\treturn indentRulesSupport.getIndentMetadata(\n\t\tmodel.getLineContent(lineNumber),\n\t);\n}\n\nfunction createVirtualModelWithModifiedTokensAtLine(\n\tmodel: ITextModel,\n\tmodifiedLineNumber: number,\n\tmodifiedTokens: IViewLineTokens,\n): IVirtualModel {\n\tconst virtualModel: IVirtualModel = {\n\t\ttokenization: {\n\t\t\tgetLineTokens: (lineNumber: number): IViewLineTokens => {\n\t\t\t\tif (lineNumber === modifiedLineNumber) {\n\t\t\t\t\treturn modifiedTokens;\n\t\t\t\t} else {\n\t\t\t\t\treturn model.tokenization.getLineTokens(lineNumber);\n\t\t\t\t}\n\t\t\t},\n\t\t\tgetLanguageId: (): string => {\n\t\t\t\treturn model.getLanguageId();\n\t\t\t},\n\t\t\tgetLanguageIdAtPosition: (\n\t\t\t\tlineNumber: number,\n\t\t\t\tcolumn: number,\n\t\t\t): string => {\n\t\t\t\treturn model.getLanguageIdAtPosition(lineNumber, column);\n\t\t\t},\n\t\t},\n\t\tgetLineContent: (lineNumber: number): string => {\n\t\t\tif (lineNumber === modifiedLineNumber) {\n\t\t\t\treturn modifiedTokens.getLineContent();\n\t\t\t} else {\n\t\t\t\treturn model.getLineContent(lineNumber);\n\t\t\t}\n\t\t},\n\t};\n\treturn virtualModel;\n}\n"],
  "mappings": ";;AAKA,YAAY,aAAa;AACzB,SAAS,gCAAgC;AAKzC,SAAS,oBAAoB;AAE7B,SAAS,oBAAoB;AAC7B;AAAA,EACC;AAAA,EACA;AAAA,EACA;AAAA,OACM;AAyBP,SAAS,sBACR,OACA,YACA,6BACC;AACD,QAAM,aAAa,MAAM,aAAa;AAAA,IACrC;AAAA,IACA;AAAA,EACD;AACA,MAAI,aAAa,GAAG;AACnB,QAAI;AACJ,QAAI,mBAAmB;AAEvB,SACC,iBAAiB,aAAa,GAC9B,kBAAkB,GAClB,kBACC;AACD,UACC,MAAM,aAAa;AAAA,QAClB;AAAA,QACA;AAAA,MACD,MAAM,YACL;AACD,eAAO;AAAA,MACR;AACA,YAAM,OAAO,MAAM,eAAe,cAAc;AAChD,UACC,4BAA4B,aAAa,cAAc,KACvD,QAAQ,KAAK,IAAI,KACjB,SAAS,IACR;AACD,2BAAmB;AACnB;AAAA,MACD;AAEA,aAAO;AAAA,IACR;AAAA,EACD;AAEA,SAAO;AACR;AAzCS;AAuDF,SAAS,wBACf,YACA,OACA,YACA,uBAAuB,MACvB,8BAC6E;AAC7E,MAAI,aAAa,yBAAyB,MAAM;AAC/C,WAAO;AAAA,EACR;AAEA,QAAM,qBACL,6BAA6B;AAAA,IAC5B,MAAM,aAAa,cAAc;AAAA,EAClC,EAAE;AACH,MAAI,CAAC,oBAAoB;AACxB,WAAO;AAAA,EACR;AACA,QAAM,8BAA8B,IAAI;AAAA,IACvC;AAAA,IACA;AAAA,IACA;AAAA,EACD;AAEA,MAAI,cAAc,GAAG;AACpB,WAAO;AAAA,MACN,aAAa;AAAA,MACb,QAAQ;AAAA,IACT;AAAA,EACD;AAGA,WACK,kBAAkB,aAAa,GACnC,kBAAkB,GAClB,mBACC;AACD,QAAI,MAAM,eAAe,eAAe,MAAM,IAAI;AACjD;AAAA,IACD;AACA,QAAI,oBAAoB,GAAG;AAC1B,aAAO;AAAA,QACN,aAAa;AAAA,QACb,QAAQ;AAAA,MACT;AAAA,IACD;AAAA,EACD;AAEA,QAAM,yBAAyB;AAAA,IAC9B;AAAA,IACA;AAAA,IACA;AAAA,EACD;AACA,MAAI,yBAAyB,GAAG;AAC/B,WAAO;AAAA,EACR,WAAW,yBAAyB,GAAG;AACtC,WAAO;AAAA,MACN,aAAa;AAAA,MACb,QAAQ;AAAA,IACT;AAAA,EACD;AAEA,MACC,4BAA4B,eAAe,sBAAsB,KACjE,4BAA4B,qBAAqB,sBAAsB,GACtE;AACD,UAAM,gCAAgC,MAAM;AAAA,MAC3C;AAAA,IACD;AACA,WAAO;AAAA,MACN,aAAa,QAAQ;AAAA,QACpB;AAAA,MACD;AAAA,MACA,QAAQ,aAAa;AAAA,MACrB,MAAM;AAAA,IACP;AAAA,EACD,WACC,4BAA4B,eAAe,sBAAsB,GAChE;AACD,UAAM,gCAAgC,MAAM;AAAA,MAC3C;AAAA,IACD;AACA,WAAO;AAAA,MACN,aAAa,QAAQ;AAAA,QACpB;AAAA,MACD;AAAA,MACA,QAAQ;AAAA,MACR,MAAM;AAAA,IACP;AAAA,EACD,OAAO;AAMN,QAAI,2BAA2B,GAAG;AACjC,aAAO;AAAA,QACN,aAAa,QAAQ;AAAA,UACpB,MAAM,eAAe,sBAAsB;AAAA,QAC5C;AAAA,QACA,QAAQ;AAAA,QACR,MAAM;AAAA,MACP;AAAA,IACD;AAEA,UAAM,eAAe,yBAAyB;AAE9C,UAAM,6BAA6B,mBAAmB;AAAA,MACrD,MAAM,eAAe,YAAY;AAAA,IAClC;AACA,QACC,EACC,8BACC,aAAa,gBAAgB,aAAa,mBAE5C,6BAA6B,aAAa,sBACzC;AACD,UAAI,WAAW;AACf,eAAS,IAAI,eAAe,GAAG,IAAI,GAAG,KAAK;AAC1C,YAAI,4BAA4B,qBAAqB,CAAC,GAAG;AACxD;AAAA,QACD;AACA,mBAAW;AACX;AAAA,MACD;AAEA,aAAO;AAAA,QACN,aAAa,QAAQ;AAAA,UACpB,MAAM,eAAe,WAAW,CAAC;AAAA,QAClC;AAAA,QACA,QAAQ;AAAA,QACR,MAAM,WAAW;AAAA,MAClB;AAAA,IACD;AAEA,QAAI,sBAAsB;AACzB,aAAO;AAAA,QACN,aAAa,QAAQ;AAAA,UACpB,MAAM,eAAe,sBAAsB;AAAA,QAC5C;AAAA,QACA,QAAQ;AAAA,QACR,MAAM;AAAA,MACP;AAAA,IACD,OAAO;AAEN,eAAS,IAAI,wBAAwB,IAAI,GAAG,KAAK;AAChD,YAAI,4BAA4B,eAAe,CAAC,GAAG;AAClD,iBAAO;AAAA,YACN,aAAa,QAAQ;AAAA,cACpB,MAAM,eAAe,CAAC;AAAA,YACvB;AAAA,YACA,QAAQ,aAAa;AAAA,YACrB,MAAM;AAAA,UACP;AAAA,QACD,WACC,4BAA4B,qBAAqB,CAAC,GACjD;AACD,cAAI,WAAW;AACf,mBAAS,IAAI,IAAI,GAAG,IAAI,GAAG,KAAK;AAC/B,gBACC,4BAA4B,qBAAqB,CAAC,GACjD;AACD;AAAA,YACD;AACA,uBAAW;AACX;AAAA,UACD;AAEA,iBAAO;AAAA,YACN,aAAa,QAAQ;AAAA,cACpB,MAAM,eAAe,WAAW,CAAC;AAAA,YAClC;AAAA,YACA,QAAQ;AAAA,YACR,MAAM,WAAW;AAAA,UAClB;AAAA,QACD,WAAW,4BAA4B,eAAe,CAAC,GAAG;AACzD,iBAAO;AAAA,YACN,aAAa,QAAQ;AAAA,cACpB,MAAM,eAAe,CAAC;AAAA,YACvB;AAAA,YACA,QAAQ;AAAA,YACR,MAAM;AAAA,UACP;AAAA,QACD;AAAA,MACD;AAEA,aAAO;AAAA,QACN,aAAa,QAAQ;AAAA,UACpB,MAAM,eAAe,CAAC;AAAA,QACvB;AAAA,QACA,QAAQ;AAAA,QACR,MAAM;AAAA,MACP;AAAA,IACD;AAAA,EACD;AACD;AAnMgB;AAqMT,SAAS,qBACf,YACA,cACA,YACA,YACA,iBACA,8BACgB;AAChB,MAAI,aAAa,yBAAyB,MAAM;AAC/C,WAAO;AAAA,EACR;AAEA,QAAM,kBACL,6BAA6B,yBAAyB,UAAU;AACjE,MAAI,CAAC,iBAAiB;AACrB,WAAO;AAAA,EACR;AAEA,QAAM,qBACL,6BAA6B;AAAA,IAC5B;AAAA,EACD,EAAE;AACH,MAAI,CAAC,oBAAoB;AACxB,WAAO;AAAA,EACR;AAEA,QAAM,8BAA8B,IAAI;AAAA,IACvC;AAAA,IACA;AAAA,IACA;AAAA,EACD;AACA,QAAM,SAAS;AAAA,IACd;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACD;AAEA,MAAI,QAAQ;AACX,UAAM,cAAc,OAAO;AAC3B,QAAI,gBAAgB,QAAW;AAE9B,UAAI,wBAAwB;AAC5B,eACK,gBAAgB,aACpB,gBAAgB,aAAa,GAC7B,iBACC;AACD,YAAI,CAAC,QAAQ,KAAK,aAAa,eAAe,aAAa,CAAC,GAAG;AAC9D,kCAAwB;AACxB;AAAA,QACD;AAAA,MACD;AACA,UAAI,uBAAuB;AAC1B,cAAM,cAAc,gBAAgB;AAAA,UACnC;AAAA,UACA;AAAA,UACA,aAAa,eAAe,WAAW;AAAA,UACvC;AAAA,QACD;AAEA,YAAI,aAAa;AAChB,cAAI,cAAc,QAAQ;AAAA,YACzB,aAAa,eAAe,WAAW;AAAA,UACxC;AAEA,cAAI,YAAY,YAAY;AAC3B,0BAAc,YAAY;AAAA,cACzB;AAAA,cACA,YAAY,SAAS,YAAY;AAAA,YAClC;AAAA,UACD;AAEA,cACC,YAAY,iBAAiB,aAAa,UAC1C,YAAY,iBAAiB,aAAa,eACzC;AACD,0BAAc,gBAAgB,YAAY,WAAW;AAAA,UACtD,WACC,YAAY,iBAAiB,aAAa,SACzC;AACD,0BACC,gBAAgB,cAAc,WAAW;AAAA,UAC3C;AAEA,cACC,4BAA4B,eAAe,UAAU,GACpD;AACD,0BACC,gBAAgB,cAAc,WAAW;AAAA,UAC3C;AAEA,cAAI,YAAY,YAAY;AAC3B,2BAAe,YAAY;AAAA,UAC5B;AAEA,iBAAO,QAAQ,qBAAqB,WAAW;AAAA,QAChD;AAAA,MACD;AAAA,IACD;AAEA,QAAI,4BAA4B,eAAe,UAAU,GAAG;AAC3D,UAAI,OAAO,WAAW,aAAa,QAAQ;AAC1C,eAAO,OAAO;AAAA,MACf,OAAO;AACN,eAAO,gBAAgB,cAAc,OAAO,WAAW;AAAA,MACxD;AAAA,IACD,WAAW,OAAO,WAAW,aAAa,QAAQ;AACjD,aAAO,gBAAgB,YAAY,OAAO,WAAW;AAAA,IACtD,OAAO;AACN,aAAO,OAAO;AAAA,IACf;AAAA,EACD;AACA,SAAO;AACR;AAnHgB;AAqHT,SAAS,kBACf,YACA,OACA,OACA,iBACA,8BACqD;AACrD,MAAI,aAAa,yBAAyB,MAAM;AAC/C,WAAO;AAAA,EACR;AACA,QAAM,aAAa,MAAM;AAAA,IACxB,MAAM;AAAA,IACN,MAAM;AAAA,EACP;AACA,QAAM,qBACL,6BAA6B;AAAA,IAC5B;AAAA,EACD,EAAE;AACH,MAAI,CAAC,oBAAoB;AACxB,WAAO;AAAA,EACR;AAEA,QAAM,aAAa,kBAAkB,MAAM,eAAe;AAC1D,QAAM,8BAA8B,IAAI;AAAA,IACvC;AAAA,IACA;AAAA,EACD;AACA,QAAM,yBACL,4BAA4B,oCAAoC,KAAK;AACtE,QAAM,4BACL,uBAAuB;AACxB,QAAM,6BACL,uBAAuB;AACxB,QAAM,oBAAoB,QAAQ;AAAA,IACjC,2BAA2B,eAAe;AAAA,EAC3C;AAEA,QAAM,eAAe;AAAA,IACpB;AAAA,IACA,MAAM;AAAA,IACN;AAAA,EACD;AACA,QAAM,mCAAmC;AAAA,IACxC;AAAA,IACA,MAAM,iBAAiB;AAAA,EACxB;AACA,QAAM,cAAc,MAAM,eAAe,MAAM,eAAe;AAC9D,QAAM,oBAAoB,QAAQ,qBAAqB,WAAW;AAClE,QAAM,mBAAmB;AAAA,IACxB;AAAA,IACA;AAAA,IACA,MAAM,kBAAkB;AAAA,IACxB;AAAA,IACA;AAAA,EACD;AACA,MAAI,CAAC,kBAAkB;AACtB,UAAM,cAAc,mCACjB,oBACA;AACH,WAAO;AAAA,MACN;AAAA,MACA,YAAY;AAAA,IACb;AAAA,EACD;AAEA,MAAI,mBAAmB,mCACpB,oBACA,iBAAiB;AAEpB,MAAI,iBAAiB,WAAW,aAAa,QAAQ;AACpD,uBAAmB,gBAAgB,YAAY,gBAAgB;AAAA,EAChE;AAEA,MACC,mBAAmB;AAAA,IAClB,0BAA0B,eAAe;AAAA,EAC1C,GACC;AACD,uBAAmB,gBAAgB,cAAc,gBAAgB;AAAA,EAClE;AAEA,SAAO;AAAA,IACN,aAAa,mCACV,oBACA;AAAA,IACH,YAAY;AAAA,EACb;AACD;AAvFgB;AA6FT,SAAS,uBACf,cACA,OACA,OACA,IACA,iBACA,8BACgB;AAChB,QAAM,aAAa,aAAa;AAChC,MAAI,aAAa,yBAAyB,MAAM;AAC/C,WAAO;AAAA,EACR;AACA,QAAM,mCAAmC;AAAA,IACxC;AAAA,IACA,MAAM,iBAAiB;AAAA,EACxB;AACA,MAAI,kCAAkC;AAErC,WAAO;AAAA,EACR;AAEA,QAAM,aAAa,MAAM;AAAA,IACxB,MAAM;AAAA,IACN,MAAM;AAAA,EACP;AACA,QAAM,qBACL,6BAA6B;AAAA,IAC5B;AAAA,EACD,EAAE;AACH,MAAI,CAAC,oBAAoB;AACxB,WAAO;AAAA,EACR;AAEA,QAAM,8BAA8B,IAAI;AAAA,IACvC;AAAA,IACA;AAAA,EACD;AACA,QAAM,yBACL,4BAA4B,oCAAoC,KAAK;AACtE,QAAM,kBACL,uBAAuB,2BAA2B,eAAe;AAClE,QAAM,iBACL,uBAAuB,0BAA0B,eAAe;AACjE,QAAM,kBAAkB,kBAAkB;AAC1C,QAAM,+BAA+B,kBAAkB,KAAK;AAI5D,MACC,CAAC,mBAAmB,eAAe,eAAe,KAClD,mBAAmB,eAAe,4BAA4B,GAC7D;AAGD,UAAM,IAAI;AAAA,MACT;AAAA,MACA;AAAA,MACA,MAAM;AAAA,MACN;AAAA,MACA;AAAA,IACD;AACA,QAAI,CAAC,GAAG;AACP,aAAO;AAAA,IACR;AAEA,QAAI,cAAc,EAAE;AACpB,QAAI,EAAE,WAAW,aAAa,QAAQ;AACrC,oBAAc,gBAAgB,cAAc,WAAW;AAAA,IACxD;AAEA,WAAO;AAAA,EACR;AAEA,QAAM,qBAAqB,MAAM,kBAAkB;AACnD,MAAI,qBAAqB,GAAG;AAC3B,UAAM,eAAe,MAAM,eAAe,kBAAkB;AAC5D,QACC,mBAAmB,qBAAqB,YAAY,KACpD,mBAAmB,eAAe,4BAA4B,GAC7D;AACD,YAAM,2BAA2B;AAAA,QAChC;AAAA,QACA;AAAA,QACA,MAAM;AAAA,QACN;AAAA,QACA;AAAA,MACD;AACA,YAAM,uBAAuB,0BAA0B;AACvD,UAAI,yBAAyB,QAAW;AACvC,cAAM,cAAc,MAAM,eAAe,MAAM,eAAe;AAC9D,cAAM,2BACL,QAAQ,qBAAqB,WAAW;AACzC,cAAM,6BACL,gBAAgB,YAAY,oBAAoB;AAEjD,cAAM,kCACL,+BAA+B;AAChC,cAAM,wCAAwC,QAAQ;AAAA,UACrD;AAAA,QACD;AACA,cAAM,mBACL,aAAa,iBAAiB,0BAA0B;AAAA,UACvD;AAAA,QACD;AACD,cAAM,wBACL,oBAAoB,iBAAiB,SAAS;AAC/C,cAAM,sDACL,yBACA;AACD,YACC,mCACA,qDACC;AACD,iBAAO;AAAA,QACR;AAAA,MACD;AAAA,IACD;AAAA,EACD;AAEA,SAAO;AACR;AAxHgB;AA0HT,SAAS,kBACf,OACA,YACA,8BACgB;AAChB,QAAM,qBACL,6BAA6B;AAAA,IAC5B,MAAM,cAAc;AAAA,EACrB,EAAE;AACH,MAAI,CAAC,oBAAoB;AACxB,WAAO;AAAA,EACR;AACA,MAAI,aAAa,KAAK,aAAa,MAAM,aAAa,GAAG;AACxD,WAAO;AAAA,EACR;AACA,SAAO,mBAAmB;AAAA,IACzB,MAAM,eAAe,UAAU;AAAA,EAChC;AACD;AAlBgB;AAoBhB,SAAS,2CACR,OACA,oBACA,gBACgB;AAChB,QAAM,eAA8B;AAAA,IACnC,cAAc;AAAA,MACb,eAAe,wBAAC,eAAwC;AACvD,YAAI,eAAe,oBAAoB;AACtC,iBAAO;AAAA,QACR,OAAO;AACN,iBAAO,MAAM,aAAa,cAAc,UAAU;AAAA,QACnD;AAAA,MACD,GANe;AAAA,MAOf,eAAe,6BAAc;AAC5B,eAAO,MAAM,cAAc;AAAA,MAC5B,GAFe;AAAA,MAGf,yBAAyB,wBACxB,YACA,WACY;AACZ,eAAO,MAAM,wBAAwB,YAAY,MAAM;AAAA,MACxD,GALyB;AAAA,IAM1B;AAAA,IACA,gBAAgB,wBAAC,eAA+B;AAC/C,UAAI,eAAe,oBAAoB;AACtC,eAAO,eAAe,eAAe;AAAA,MACtC,OAAO;AACN,eAAO,MAAM,eAAe,UAAU;AAAA,MACvC;AAAA,IACD,GANgB;AAAA,EAOjB;AACA,SAAO;AACR;AAjCS;",
  "names": []
}
