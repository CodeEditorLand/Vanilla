import"../tokens/lineTokens.js";import{StandardTokenType as o}from"../encodedTokenAttributes.js";import"../languages.js";function k(n,e){const s=n.getCount(),r=n.findTokenIndexAtOffset(e),a=n.getLanguageId(r);let t=r;for(;t+1<s&&n.getLanguageId(t+1)===a;)t++;let i=r;for(;i>0&&n.getLanguageId(i-1)===a;)i--;return new d(n,a,i,t+1,n.getStartOffset(i),n.getEndOffset(t))}class d{_scopedLineTokensBrand=void 0;languageIdCodec;languageId;_actual;_firstTokenIndex;_lastTokenIndex;firstCharOffset;_lastCharOffset;constructor(e,s,r,a,t,i){this._actual=e,this.languageId=s,this._firstTokenIndex=r,this._lastTokenIndex=a,this.firstCharOffset=t,this._lastCharOffset=i,this.languageIdCodec=e.languageIdCodec}getLineContent(){return this._actual.getLineContent().substring(this.firstCharOffset,this._lastCharOffset)}getLineLength(){return this._lastCharOffset-this.firstCharOffset}getActualLineContentBefore(e){return this._actual.getLineContent().substring(0,this.firstCharOffset+e)}getTokenCount(){return this._lastTokenIndex-this._firstTokenIndex}findTokenIndexAtOffset(e){return this._actual.findTokenIndexAtOffset(e+this.firstCharOffset)-this._firstTokenIndex}getStandardTokenType(e){return this._actual.getStandardTokenType(e+this._firstTokenIndex)}toIViewLineTokens(){return this._actual.sliceAndInflate(this.firstCharOffset,this._lastCharOffset,0)}}var u=(e=>(e[e.value=o.Comment|o.String|o.RegEx]="value",e))(u||{});function p(n){return(n&u.value)!==0}export{d as ScopedLineTokens,k as createScopedLineTokens,p as ignoreBracketsInToken};
