{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/cursor/cursorTypeEditOperations.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand, ReplaceCommandWithOffsetCursorState, ReplaceCommandWithoutChangingPosition, ReplaceCommandThatPreservesSelection } from '../commands/replaceCommand.js';\nimport { ShiftCommand } from '../commands/shiftCommand.js';\nimport { SurroundSelectionCommand } from '../commands/surroundSelectionCommand.js';\nimport { CursorConfiguration, EditOperationResult, EditOperationType, ICursorSimpleModel, isQuote } from '../cursorCommon.js';\nimport { WordCharacterClass, getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { Position } from '../core/position.js';\nimport { ICommand, ICursorStateComputerData, IEditOperationBuilder } from '../editorCommon.js';\nimport { ITextModel } from '../model.js';\nimport { EnterAction, IndentAction, StandardAutoClosingPairConditional } from '../languages/languageConfiguration.js';\nimport { getIndentationAtPosition } from '../languages/languageConfigurationRegistry.js';\nimport { IElectricAction } from '../languages/supports/electricCharacter.js';\nimport { EditorAutoClosingStrategy, EditorAutoIndentStrategy } from '../config/editorOptions.js';\nimport { createScopedLineTokens } from '../languages/supports.js';\nimport { getIndentActionForType, getIndentForEnter, getInheritIndentForLine } from '../languages/autoIndent.js';\nimport { getEnterAction } from '../languages/enterAction.js';\n\nexport class AutoIndentOperation {\n\n\tpublic static getEdits(config: CursorConfiguration, model: ITextModel, selections: Selection[], ch: string, isDoingComposition: boolean): EditOperationResult | undefined {\n\t\tif (!isDoingComposition && this._isAutoIndentType(config, model, selections)) {\n\t\t\tconst indentationForSelections: { selection: Selection; indentation: string }[] = [];\n\t\t\tfor (const selection of selections) {\n\t\t\t\tconst indentation = this._findActualIndentationForSelection(config, model, selection, ch);\n\t\t\t\tif (indentation === null) {\n\t\t\t\t\t// Auto indentation failed\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tindentationForSelections.push({ selection, indentation });\n\t\t\t}\n\t\t\tconst autoClosingPairClose = AutoClosingOpenCharTypeOperation.getAutoClosingPairClose(config, model, selections, ch, false);\n\t\t\treturn this._getIndentationAndAutoClosingPairEdits(config, model, indentationForSelections, ch, autoClosingPairClose);\n\t\t}\n\t\treturn;\n\t}\n\n\tprivate static _isAutoIndentType(config: CursorConfiguration, model: ITextModel, selections: Selection[]): boolean {\n\t\tif (config.autoIndent < EditorAutoIndentStrategy.Full) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tif (!model.tokenization.isCheapToTokenize(selections[i].getEndPosition().lineNumber)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate static _findActualIndentationForSelection(config: CursorConfiguration, model: ITextModel, selection: Selection, ch: string): string | null {\n\t\tconst actualIndentation = getIndentActionForType(config, model, selection, ch, {\n\t\t\tshiftIndent: (indentation) => {\n\t\t\t\treturn shiftIndent(config, indentation);\n\t\t\t},\n\t\t\tunshiftIndent: (indentation) => {\n\t\t\t\treturn unshiftIndent(config, indentation);\n\t\t\t},\n\t\t}, config.languageConfigurationService);\n\n\t\tif (actualIndentation === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst currentIndentation = getIndentationAtPosition(model, selection.startLineNumber, selection.startColumn);\n\t\tif (actualIndentation === config.normalizeIndentation(currentIndentation)) {\n\t\t\treturn null;\n\t\t}\n\t\treturn actualIndentation;\n\t}\n\n\tprivate static _getIndentationAndAutoClosingPairEdits(config: CursorConfiguration, model: ITextModel, indentationForSelections: { selection: Selection; indentation: string }[], ch: string, autoClosingPairClose: string | null): EditOperationResult {\n\t\tconst commands: ICommand[] = indentationForSelections.map(({ selection, indentation }) => {\n\t\t\tif (autoClosingPairClose !== null) {\n\t\t\t\t// Apply both auto closing pair edits and auto indentation edits\n\t\t\t\tconst indentationEdit = this._getEditFromIndentationAndSelection(config, model, indentation, selection, ch, false);\n\t\t\t\treturn new TypeWithIndentationAndAutoClosingCommand(indentationEdit, selection, ch, autoClosingPairClose);\n\t\t\t} else {\n\t\t\t\t// Apply only auto indentation edits\n\t\t\t\tconst indentationEdit = this._getEditFromIndentationAndSelection(config, model, indentation, selection, ch, true);\n\t\t\t\treturn typeCommand(indentationEdit.range, indentationEdit.text, false);\n\t\t\t}\n\t\t});\n\t\tconst editOptions = { shouldPushStackElementBefore: true, shouldPushStackElementAfter: false };\n\t\treturn new EditOperationResult(EditOperationType.TypingOther, commands, editOptions);\n\t}\n\n\tprivate static _getEditFromIndentationAndSelection(config: CursorConfiguration, model: ITextModel, indentation: string, selection: Selection, ch: string, includeChInEdit: boolean = true): { range: Range; text: string } {\n\t\tconst startLineNumber = selection.startLineNumber;\n\t\tconst firstNonWhitespaceColumn = model.getLineFirstNonWhitespaceColumn(startLineNumber);\n\t\tlet text: string = config.normalizeIndentation(indentation);\n\t\tif (firstNonWhitespaceColumn !== 0) {\n\t\t\tconst startLine = model.getLineContent(startLineNumber);\n\t\t\ttext += startLine.substring(firstNonWhitespaceColumn - 1, selection.startColumn - 1);\n\t\t}\n\t\ttext += includeChInEdit ? ch : '';\n\t\tconst range = new Range(startLineNumber, 1, selection.endLineNumber, selection.endColumn);\n\t\treturn { range, text };\n\t}\n}\n\nexport class AutoClosingOvertypeOperation {\n\n\tpublic static getEdits(prevEditOperationType: EditOperationType, config: CursorConfiguration, model: ITextModel, selections: Selection[], autoClosedCharacters: Range[], ch: string): EditOperationResult | undefined {\n\t\tif (isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n\t\t\treturn this._runAutoClosingOvertype(prevEditOperationType, selections, ch);\n\t\t}\n\t\treturn;\n\t}\n\n\tprivate static _runAutoClosingOvertype(prevEditOperationType: EditOperationType, selections: Selection[], ch: string): EditOperationResult {\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst selection = selections[i];\n\t\t\tconst position = selection.getPosition();\n\t\t\tconst typeSelection = new Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);\n\t\t\tcommands[i] = new ReplaceCommand(typeSelection, ch);\n\t\t}\n\t\treturn new EditOperationResult(EditOperationType.TypingOther, commands, {\n\t\t\tshouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, EditOperationType.TypingOther),\n\t\t\tshouldPushStackElementAfter: false\n\t\t});\n\t}\n}\n\nexport class AutoClosingOvertypeWithInterceptorsOperation {\n\n\tpublic static getEdits(config: CursorConfiguration, model: ITextModel, selections: Selection[], autoClosedCharacters: Range[], ch: string): EditOperationResult | undefined {\n\t\tif (isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n\t\t\t// Unfortunately, the close character is at this point \"doubled\", so we need to delete it...\n\t\t\tconst commands = selections.map(s => new ReplaceCommand(new Range(s.positionLineNumber, s.positionColumn, s.positionLineNumber, s.positionColumn + 1), '', false));\n\t\t\treturn new EditOperationResult(EditOperationType.TypingOther, commands, {\n\t\t\t\tshouldPushStackElementBefore: true,\n\t\t\t\tshouldPushStackElementAfter: false\n\t\t\t});\n\t\t}\n\t\treturn;\n\t}\n}\n\nexport class AutoClosingOpenCharTypeOperation {\n\n\tpublic static getEdits(config: CursorConfiguration, model: ITextModel, selections: Selection[], ch: string, chIsAlreadyTyped: boolean, isDoingComposition: boolean): EditOperationResult | undefined {\n\t\tif (!isDoingComposition) {\n\t\t\tconst autoClosingPairClose = this.getAutoClosingPairClose(config, model, selections, ch, chIsAlreadyTyped);\n\t\t\tif (autoClosingPairClose !== null) {\n\t\t\t\treturn this._runAutoClosingOpenCharType(selections, ch, chIsAlreadyTyped, autoClosingPairClose);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tprivate static _runAutoClosingOpenCharType(selections: Selection[], ch: string, chIsAlreadyTyped: boolean, autoClosingPairClose: string): EditOperationResult {\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst selection = selections[i];\n\t\t\tcommands[i] = new TypeWithAutoClosingCommand(selection, ch, !chIsAlreadyTyped, autoClosingPairClose);\n\t\t}\n\t\treturn new EditOperationResult(EditOperationType.TypingOther, commands, {\n\t\t\tshouldPushStackElementBefore: true,\n\t\t\tshouldPushStackElementAfter: false\n\t\t});\n\t}\n\n\tpublic static getAutoClosingPairClose(config: CursorConfiguration, model: ITextModel, selections: Selection[], ch: string, chIsAlreadyTyped: boolean): string | null {\n\t\tfor (const selection of selections) {\n\t\t\tif (!selection.isEmpty()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t// This method is called both when typing (regularly) and when composition ends\n\t\t// This means that we need to work with a text buffer where sometimes `ch` is not\n\t\t// there (it is being typed right now) or with a text buffer where `ch` has already been typed\n\t\t//\n\t\t// In order to avoid adding checks for `chIsAlreadyTyped` in all places, we will work\n\t\t// with two conceptual positions, the position before `ch` and the position after `ch`\n\t\t//\n\t\tconst positions: { lineNumber: number; beforeColumn: number; afterColumn: number }[] = selections.map((s) => {\n\t\t\tconst position = s.getPosition();\n\t\t\tif (chIsAlreadyTyped) {\n\t\t\t\treturn { lineNumber: position.lineNumber, beforeColumn: position.column - ch.length, afterColumn: position.column };\n\t\t\t} else {\n\t\t\t\treturn { lineNumber: position.lineNumber, beforeColumn: position.column, afterColumn: position.column };\n\t\t\t}\n\t\t});\n\t\t// Find the longest auto-closing open pair in case of multiple ending in `ch`\n\t\t// e.g. when having [f\",\"] and [\",\"], it picks [f\",\"] if the character before is f\n\t\tconst pair = this._findAutoClosingPairOpen(config, model, positions.map(p => new Position(p.lineNumber, p.beforeColumn)), ch);\n\t\tif (!pair) {\n\t\t\treturn null;\n\t\t}\n\t\tlet autoCloseConfig: EditorAutoClosingStrategy;\n\t\tlet shouldAutoCloseBefore: (ch: string) => boolean;\n\n\t\tconst chIsQuote = isQuote(ch);\n\t\tif (chIsQuote) {\n\t\t\tautoCloseConfig = config.autoClosingQuotes;\n\t\t\tshouldAutoCloseBefore = config.shouldAutoCloseBefore.quote;\n\t\t} else {\n\t\t\tconst pairIsForComments = config.blockCommentStartToken ? pair.open.includes(config.blockCommentStartToken) : false;\n\t\t\tif (pairIsForComments) {\n\t\t\t\tautoCloseConfig = config.autoClosingComments;\n\t\t\t\tshouldAutoCloseBefore = config.shouldAutoCloseBefore.comment;\n\t\t\t} else {\n\t\t\t\tautoCloseConfig = config.autoClosingBrackets;\n\t\t\t\tshouldAutoCloseBefore = config.shouldAutoCloseBefore.bracket;\n\t\t\t}\n\t\t}\n\t\tif (autoCloseConfig === 'never') {\n\t\t\treturn null;\n\t\t}\n\t\t// Sometimes, it is possible to have two auto-closing pairs that have a containment relationship\n\t\t// e.g. when having [(,)] and [(*,*)]\n\t\t// - when typing (, the resulting state is (|)\n\t\t// - when typing *, the desired resulting state is (*|*), not (*|*))\n\t\tconst containedPair = this._findContainedAutoClosingPair(config, pair);\n\t\tconst containedPairClose = containedPair ? containedPair.close : '';\n\t\tlet isContainedPairPresent = true;\n\n\t\tfor (const position of positions) {\n\t\t\tconst { lineNumber, beforeColumn, afterColumn } = position;\n\t\t\tconst lineText = model.getLineContent(lineNumber);\n\t\t\tconst lineBefore = lineText.substring(0, beforeColumn - 1);\n\t\t\tconst lineAfter = lineText.substring(afterColumn - 1);\n\n\t\t\tif (!lineAfter.startsWith(containedPairClose)) {\n\t\t\t\tisContainedPairPresent = false;\n\t\t\t}\n\t\t\t// Only consider auto closing the pair if an allowed character follows or if another autoclosed pair closing brace follows\n\t\t\tif (lineAfter.length > 0) {\n\t\t\t\tconst characterAfter = lineAfter.charAt(0);\n\t\t\t\tconst isBeforeCloseBrace = this._isBeforeClosingBrace(config, lineAfter);\n\t\t\t\tif (!isBeforeCloseBrace && !shouldAutoCloseBefore(characterAfter)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Do not auto-close ' or \" after a word character\n\t\t\tif (pair.open.length === 1 && (ch === '\\'' || ch === '\"') && autoCloseConfig !== 'always') {\n\t\t\t\tconst wordSeparators = getMapForWordSeparators(config.wordSeparators, []);\n\t\t\t\tif (lineBefore.length > 0) {\n\t\t\t\t\tconst characterBefore = lineBefore.charCodeAt(lineBefore.length - 1);\n\t\t\t\t\tif (wordSeparators.get(characterBefore) === WordCharacterClass.Regular) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!model.tokenization.isCheapToTokenize(lineNumber)) {\n\t\t\t\t// Do not force tokenization\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tmodel.tokenization.forceTokenization(lineNumber);\n\t\t\tconst lineTokens = model.tokenization.getLineTokens(lineNumber);\n\t\t\tconst scopedLineTokens = createScopedLineTokens(lineTokens, beforeColumn - 1);\n\t\t\tif (!pair.shouldAutoClose(scopedLineTokens, beforeColumn - scopedLineTokens.firstCharOffset)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// Typing for example a quote could either start a new string, in which case auto-closing is desirable\n\t\t\t// or it could end a previously started string, in which case auto-closing is not desirable\n\t\t\t//\n\t\t\t// In certain cases, it is really not possible to look at the previous token to determine\n\t\t\t// what would happen. That's why we do something really unusual, we pretend to type a different\n\t\t\t// character and ask the tokenizer what the outcome of doing that is: after typing a neutral\n\t\t\t// character, are we in a string (i.e. the quote would most likely end a string) or not?\n\t\t\t//\n\t\t\tconst neutralCharacter = pair.findNeutralCharacter();\n\t\t\tif (neutralCharacter) {\n\t\t\t\tconst tokenType = model.tokenization.getTokenTypeIfInsertingCharacter(lineNumber, beforeColumn, neutralCharacter);\n\t\t\t\tif (!pair.isOK(tokenType)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (isContainedPairPresent) {\n\t\t\treturn pair.close.substring(0, pair.close.length - containedPairClose.length);\n\t\t} else {\n\t\t\treturn pair.close;\n\t\t}\n\t}\n\n\t/**\n\t * Find another auto-closing pair that is contained by the one passed in.\n\t *\n\t * e.g. when having [(,)] and [(*,*)] as auto-closing pairs\n\t * this method will find [(,)] as a containment pair for [(*,*)]\n\t */\n\tprivate static _findContainedAutoClosingPair(config: CursorConfiguration, pair: StandardAutoClosingPairConditional): StandardAutoClosingPairConditional | null {\n\t\tif (pair.open.length <= 1) {\n\t\t\treturn null;\n\t\t}\n\t\tconst lastChar = pair.close.charAt(pair.close.length - 1);\n\t\t// get candidates with the same last character as close\n\t\tconst candidates = config.autoClosingPairs.autoClosingPairsCloseByEnd.get(lastChar) || [];\n\t\tlet result: StandardAutoClosingPairConditional | null = null;\n\t\tfor (const candidate of candidates) {\n\t\t\tif (candidate.open !== pair.open && pair.open.includes(candidate.open) && pair.close.endsWith(candidate.close)) {\n\t\t\t\tif (!result || candidate.open.length > result.open.length) {\n\t\t\t\t\tresult = candidate;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Determine if typing `ch` at all `positions` in the `model` results in an\n\t * auto closing open sequence being typed.\n\t *\n\t * Auto closing open sequences can consist of multiple characters, which\n\t * can lead to ambiguities. In such a case, the longest auto-closing open\n\t * sequence is returned.\n\t */\n\tprivate static _findAutoClosingPairOpen(config: CursorConfiguration, model: ITextModel, positions: Position[], ch: string): StandardAutoClosingPairConditional | null {\n\t\tconst candidates = config.autoClosingPairs.autoClosingPairsOpenByEnd.get(ch);\n\t\tif (!candidates) {\n\t\t\treturn null;\n\t\t}\n\t\t// Determine which auto-closing pair it is\n\t\tlet result: StandardAutoClosingPairConditional | null = null;\n\t\tfor (const candidate of candidates) {\n\t\t\tif (result === null || candidate.open.length > result.open.length) {\n\t\t\t\tlet candidateIsMatch = true;\n\t\t\t\tfor (const position of positions) {\n\t\t\t\t\tconst relevantText = model.getValueInRange(new Range(position.lineNumber, position.column - candidate.open.length + 1, position.lineNumber, position.column));\n\t\t\t\t\tif (relevantText + ch !== candidate.open) {\n\t\t\t\t\t\tcandidateIsMatch = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (candidateIsMatch) {\n\t\t\t\t\tresult = candidate;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static _isBeforeClosingBrace(config: CursorConfiguration, lineAfter: string) {\n\t\t// If the start of lineAfter can be interpretted as both a starting or ending brace, default to returning false\n\t\tconst nextChar = lineAfter.charAt(0);\n\t\tconst potentialStartingBraces = config.autoClosingPairs.autoClosingPairsOpenByStart.get(nextChar) || [];\n\t\tconst potentialClosingBraces = config.autoClosingPairs.autoClosingPairsCloseByStart.get(nextChar) || [];\n\n\t\tconst isBeforeStartingBrace = potentialStartingBraces.some(x => lineAfter.startsWith(x.open));\n\t\tconst isBeforeClosingBrace = potentialClosingBraces.some(x => lineAfter.startsWith(x.close));\n\n\t\treturn !isBeforeStartingBrace && isBeforeClosingBrace;\n\t}\n}\n\nexport class SurroundSelectionOperation {\n\n\tpublic static getEdits(config: CursorConfiguration, model: ITextModel, selections: Selection[], ch: string, isDoingComposition: boolean): EditOperationResult | undefined {\n\t\tif (!isDoingComposition && this._isSurroundSelectionType(config, model, selections, ch)) {\n\t\t\treturn this._runSurroundSelectionType(config, selections, ch);\n\t\t}\n\t\treturn;\n\t}\n\n\tprivate static _runSurroundSelectionType(config: CursorConfiguration, selections: Selection[], ch: string): EditOperationResult {\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst selection = selections[i];\n\t\t\tconst closeCharacter = config.surroundingPairs[ch];\n\t\t\tcommands[i] = new SurroundSelectionCommand(selection, ch, closeCharacter);\n\t\t}\n\t\treturn new EditOperationResult(EditOperationType.Other, commands, {\n\t\t\tshouldPushStackElementBefore: true,\n\t\t\tshouldPushStackElementAfter: true\n\t\t});\n\t}\n\n\tprivate static _isSurroundSelectionType(config: CursorConfiguration, model: ITextModel, selections: Selection[], ch: string): boolean {\n\t\tif (!shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n\t\t\treturn false;\n\t\t}\n\t\tconst isTypingAQuoteCharacter = isQuote(ch);\n\t\tfor (const selection of selections) {\n\t\t\tif (selection.isEmpty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tlet selectionContainsOnlyWhitespace = true;\n\t\t\tfor (let lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {\n\t\t\t\tconst lineText = model.getLineContent(lineNumber);\n\t\t\t\tconst startIndex = (lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0);\n\t\t\t\tconst endIndex = (lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length);\n\t\t\t\tconst selectedText = lineText.substring(startIndex, endIndex);\n\t\t\t\tif (/[^ \\t]/.test(selectedText)) {\n\t\t\t\t\t// this selected text contains something other than whitespace\n\t\t\t\t\tselectionContainsOnlyWhitespace = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (selectionContainsOnlyWhitespace) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (isTypingAQuoteCharacter && selection.startLineNumber === selection.endLineNumber && selection.startColumn + 1 === selection.endColumn) {\n\t\t\t\tconst selectionText = model.getValueInRange(selection);\n\t\t\t\tif (isQuote(selectionText)) {\n\t\t\t\t\t// Typing a quote character on top of another quote character\n\t\t\t\t\t// => disable surround selection type\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n\nexport class InterceptorElectricCharOperation {\n\n\tpublic static getEdits(prevEditOperationType: EditOperationType, config: CursorConfiguration, model: ITextModel, selections: Selection[], ch: string, isDoingComposition: boolean): EditOperationResult | undefined {\n\t\t// Electric characters make sense only when dealing with a single cursor,\n\t\t// as multiple cursors typing brackets for example would interfer with bracket matching\n\t\tif (!isDoingComposition && this._isTypeInterceptorElectricChar(config, model, selections)) {\n\t\t\tconst r = this._typeInterceptorElectricChar(prevEditOperationType, config, model, selections[0], ch);\n\t\t\tif (r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tprivate static _isTypeInterceptorElectricChar(config: CursorConfiguration, model: ITextModel, selections: Selection[]) {\n\t\tif (selections.length === 1 && model.tokenization.isCheapToTokenize(selections[0].getEndPosition().lineNumber)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate static _typeInterceptorElectricChar(prevEditOperationType: EditOperationType, config: CursorConfiguration, model: ITextModel, selection: Selection, ch: string): EditOperationResult | null {\n\t\tif (!config.electricChars.hasOwnProperty(ch) || !selection.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\t\tconst position = selection.getPosition();\n\t\tmodel.tokenization.forceTokenization(position.lineNumber);\n\t\tconst lineTokens = model.tokenization.getLineTokens(position.lineNumber);\n\t\tlet electricAction: IElectricAction | null;\n\t\ttry {\n\t\t\telectricAction = config.onElectricCharacter(ch, lineTokens, position.column);\n\t\t} catch (e) {\n\t\t\tonUnexpectedError(e);\n\t\t\treturn null;\n\t\t}\n\t\tif (!electricAction) {\n\t\t\treturn null;\n\t\t}\n\t\tif (electricAction.matchOpenBracket) {\n\t\t\tconst endColumn = (lineTokens.getLineContent() + ch).lastIndexOf(electricAction.matchOpenBracket) + 1;\n\t\t\tconst match = model.bracketPairs.findMatchingBracketUp(electricAction.matchOpenBracket, {\n\t\t\t\tlineNumber: position.lineNumber,\n\t\t\t\tcolumn: endColumn\n\t\t\t}, 500 /* give at most 500ms to compute */);\n\t\t\tif (match) {\n\t\t\t\tif (match.startLineNumber === position.lineNumber) {\n\t\t\t\t\t// matched something on the same line => no change in indentation\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tconst matchLine = model.getLineContent(match.startLineNumber);\n\t\t\t\tconst matchLineIndentation = strings.getLeadingWhitespace(matchLine);\n\t\t\t\tconst newIndentation = config.normalizeIndentation(matchLineIndentation);\n\t\t\t\tconst lineText = model.getLineContent(position.lineNumber);\n\t\t\t\tconst lineFirstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;\n\t\t\t\tconst prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);\n\t\t\t\tconst typeText = newIndentation + prefix + ch;\n\t\t\t\tconst typeSelection = new Range(position.lineNumber, 1, position.lineNumber, position.column);\n\t\t\t\tconst command = new ReplaceCommand(typeSelection, typeText);\n\t\t\t\treturn new EditOperationResult(getTypingOperation(typeText, prevEditOperationType), [command], {\n\t\t\t\t\tshouldPushStackElementBefore: false,\n\t\t\t\t\tshouldPushStackElementAfter: true\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n}\n\nexport class SimpleCharacterTypeOperation {\n\n\tpublic static getEdits(prevEditOperationType: EditOperationType, selections: Selection[], ch: string): EditOperationResult {\n\t\t// A simple character type\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tcommands[i] = new ReplaceCommand(selections[i], ch);\n\t\t}\n\n\t\tconst opType = getTypingOperation(ch, prevEditOperationType);\n\t\treturn new EditOperationResult(opType, commands, {\n\t\t\tshouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n\t\t\tshouldPushStackElementAfter: false\n\t\t});\n\t}\n}\n\nexport class EnterOperation {\n\n\tpublic static getEdits(config: CursorConfiguration, model: ITextModel, selections: Selection[], ch: string, isDoingComposition: boolean): EditOperationResult | undefined {\n\t\tif (!isDoingComposition && ch === '\\n') {\n\t\t\tconst commands: ICommand[] = [];\n\t\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\t\tcommands[i] = this._enter(config, model, false, selections[i]);\n\t\t\t}\n\t\t\treturn new EditOperationResult(EditOperationType.TypingOther, commands, {\n\t\t\t\tshouldPushStackElementBefore: true,\n\t\t\t\tshouldPushStackElementAfter: false,\n\t\t\t});\n\t\t}\n\t\treturn;\n\t}\n\n\tprivate static _enter(config: CursorConfiguration, model: ITextModel, keepPosition: boolean, range: Range): ICommand {\n\t\tif (config.autoIndent === EditorAutoIndentStrategy.None) {\n\t\t\treturn typeCommand(range, '\\n', keepPosition);\n\t\t}\n\t\tif (!model.tokenization.isCheapToTokenize(range.getStartPosition().lineNumber) || config.autoIndent === EditorAutoIndentStrategy.Keep) {\n\t\t\tconst lineText = model.getLineContent(range.startLineNumber);\n\t\t\tconst indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n\t\t\treturn typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n\t\t}\n\t\tconst r = getEnterAction(config.autoIndent, model, range, config.languageConfigurationService);\n\t\tif (r) {\n\t\t\tif (r.indentAction === IndentAction.None) {\n\t\t\t\t// Nothing special\n\t\t\t\treturn typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n\n\t\t\t} else if (r.indentAction === IndentAction.Indent) {\n\t\t\t\t// Indent once\n\t\t\t\treturn typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n\n\t\t\t} else if (r.indentAction === IndentAction.IndentOutdent) {\n\t\t\t\t// Ultra special\n\t\t\t\tconst normalIndent = config.normalizeIndentation(r.indentation);\n\t\t\t\tconst increasedIndent = config.normalizeIndentation(r.indentation + r.appendText);\n\t\t\t\tconst typeText = '\\n' + increasedIndent + '\\n' + normalIndent;\n\t\t\t\tif (keepPosition) {\n\t\t\t\t\treturn new ReplaceCommandWithoutChangingPosition(range, typeText, true);\n\t\t\t\t} else {\n\t\t\t\t\treturn new ReplaceCommandWithOffsetCursorState(range, typeText, -1, increasedIndent.length - normalIndent.length, true);\n\t\t\t\t}\n\t\t\t} else if (r.indentAction === IndentAction.Outdent) {\n\t\t\t\tconst actualIndentation = unshiftIndent(config, r.indentation);\n\t\t\t\treturn typeCommand(range, '\\n' + config.normalizeIndentation(actualIndentation + r.appendText), keepPosition);\n\t\t\t}\n\t\t}\n\n\t\tconst lineText = model.getLineContent(range.startLineNumber);\n\t\tconst indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n\n\t\tif (config.autoIndent >= EditorAutoIndentStrategy.Full) {\n\t\t\tconst ir = getIndentForEnter(config.autoIndent, model, range, {\n\t\t\t\tunshiftIndent: (indent) => {\n\t\t\t\t\treturn unshiftIndent(config, indent);\n\t\t\t\t},\n\t\t\t\tshiftIndent: (indent) => {\n\t\t\t\t\treturn shiftIndent(config, indent);\n\t\t\t\t},\n\t\t\t\tnormalizeIndentation: (indent) => {\n\t\t\t\t\treturn config.normalizeIndentation(indent);\n\t\t\t\t}\n\t\t\t}, config.languageConfigurationService);\n\n\t\t\tif (ir) {\n\t\t\t\tlet oldEndViewColumn = config.visibleColumnFromColumn(model, range.getEndPosition());\n\t\t\t\tconst oldEndColumn = range.endColumn;\n\t\t\t\tconst newLineContent = model.getLineContent(range.endLineNumber);\n\t\t\t\tconst firstNonWhitespace = strings.firstNonWhitespaceIndex(newLineContent);\n\t\t\t\tif (firstNonWhitespace >= 0) {\n\t\t\t\t\trange = range.setEndPosition(range.endLineNumber, Math.max(range.endColumn, firstNonWhitespace + 1));\n\t\t\t\t} else {\n\t\t\t\t\trange = range.setEndPosition(range.endLineNumber, model.getLineMaxColumn(range.endLineNumber));\n\t\t\t\t}\n\t\t\t\tif (keepPosition) {\n\t\t\t\t\treturn new ReplaceCommandWithoutChangingPosition(range, '\\n' + config.normalizeIndentation(ir.afterEnter), true);\n\t\t\t\t} else {\n\t\t\t\t\tlet offset = 0;\n\t\t\t\t\tif (oldEndColumn <= firstNonWhitespace + 1) {\n\t\t\t\t\t\tif (!config.insertSpaces) {\n\t\t\t\t\t\t\toldEndViewColumn = Math.ceil(oldEndViewColumn / config.indentSize);\n\t\t\t\t\t\t}\n\t\t\t\t\t\toffset = Math.min(oldEndViewColumn + 1 - config.normalizeIndentation(ir.afterEnter).length - 1, 0);\n\t\t\t\t\t}\n\t\t\t\t\treturn new ReplaceCommandWithOffsetCursorState(range, '\\n' + config.normalizeIndentation(ir.afterEnter), 0, offset, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n\t}\n\n\n\tpublic static lineInsertBefore(config: CursorConfiguration, model: ITextModel | null, selections: Selection[] | null): ICommand[] {\n\t\tif (model === null || selections === null) {\n\t\t\treturn [];\n\t\t}\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tlet lineNumber = selections[i].positionLineNumber;\n\t\t\tif (lineNumber === 1) {\n\t\t\t\tcommands[i] = new ReplaceCommandWithoutChangingPosition(new Range(1, 1, 1, 1), '\\n');\n\t\t\t} else {\n\t\t\t\tlineNumber--;\n\t\t\t\tconst column = model.getLineMaxColumn(lineNumber);\n\n\t\t\t\tcommands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n\t\t\t}\n\t\t}\n\t\treturn commands;\n\t}\n\n\tpublic static lineInsertAfter(config: CursorConfiguration, model: ITextModel | null, selections: Selection[] | null): ICommand[] {\n\t\tif (model === null || selections === null) {\n\t\t\treturn [];\n\t\t}\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst lineNumber = selections[i].positionLineNumber;\n\t\t\tconst column = model.getLineMaxColumn(lineNumber);\n\t\t\tcommands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n\t\t}\n\t\treturn commands;\n\t}\n\n\tpublic static lineBreakInsert(config: CursorConfiguration, model: ITextModel, selections: Selection[]): ICommand[] {\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tcommands[i] = this._enter(config, model, true, selections[i]);\n\t\t}\n\t\treturn commands;\n\t}\n}\n\nexport class PasteOperation {\n\n\tpublic static getEdits(config: CursorConfiguration, model: ICursorSimpleModel, selections: Selection[], text: string, pasteOnNewLine: boolean, multicursorText: string[]) {\n\t\tconst distributedPaste = this._distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText);\n\t\tif (distributedPaste) {\n\t\t\tselections = selections.sort(Range.compareRangesUsingStarts);\n\t\t\treturn this._distributedPaste(config, model, selections, distributedPaste);\n\t\t} else {\n\t\t\treturn this._simplePaste(config, model, selections, text, pasteOnNewLine);\n\t\t}\n\t}\n\n\tprivate static _distributePasteToCursors(config: CursorConfiguration, selections: Selection[], text: string, pasteOnNewLine: boolean, multicursorText: string[]): string[] | null {\n\t\tif (pasteOnNewLine) {\n\t\t\treturn null;\n\t\t}\n\t\tif (selections.length === 1) {\n\t\t\treturn null;\n\t\t}\n\t\tif (multicursorText && multicursorText.length === selections.length) {\n\t\t\treturn multicursorText;\n\t\t}\n\t\tif (config.multiCursorPaste === 'spread') {\n\t\t\t// Try to spread the pasted text in case the line count matches the cursor count\n\t\t\t// Remove trailing \\n if present\n\t\t\tif (text.charCodeAt(text.length - 1) === CharCode.LineFeed) {\n\t\t\t\ttext = text.substring(0, text.length - 1);\n\t\t\t}\n\t\t\t// Remove trailing \\r if present\n\t\t\tif (text.charCodeAt(text.length - 1) === CharCode.CarriageReturn) {\n\t\t\t\ttext = text.substring(0, text.length - 1);\n\t\t\t}\n\t\t\tconst lines = strings.splitLines(text);\n\t\t\tif (lines.length === selections.length) {\n\t\t\t\treturn lines;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate static _distributedPaste(config: CursorConfiguration, model: ICursorSimpleModel, selections: Selection[], text: string[]): EditOperationResult {\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tcommands[i] = new ReplaceCommand(selections[i], text[i]);\n\t\t}\n\t\treturn new EditOperationResult(EditOperationType.Other, commands, {\n\t\t\tshouldPushStackElementBefore: true,\n\t\t\tshouldPushStackElementAfter: true\n\t\t});\n\t}\n\n\tprivate static _simplePaste(config: CursorConfiguration, model: ICursorSimpleModel, selections: Selection[], text: string, pasteOnNewLine: boolean): EditOperationResult {\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst selection = selections[i];\n\t\t\tconst position = selection.getPosition();\n\t\t\tif (pasteOnNewLine && !selection.isEmpty()) {\n\t\t\t\tpasteOnNewLine = false;\n\t\t\t}\n\t\t\tif (pasteOnNewLine && text.indexOf('\\n') !== text.length - 1) {\n\t\t\t\tpasteOnNewLine = false;\n\t\t\t}\n\t\t\tif (pasteOnNewLine) {\n\t\t\t\t// Paste entire line at the beginning of line\n\t\t\t\tconst typeSelection = new Range(position.lineNumber, 1, position.lineNumber, 1);\n\t\t\t\tcommands[i] = new ReplaceCommandThatPreservesSelection(typeSelection, text, selection, true);\n\t\t\t} else {\n\t\t\t\tcommands[i] = new ReplaceCommand(selection, text);\n\t\t\t}\n\t\t}\n\t\treturn new EditOperationResult(EditOperationType.Other, commands, {\n\t\t\tshouldPushStackElementBefore: true,\n\t\t\tshouldPushStackElementAfter: true\n\t\t});\n\t}\n}\n\nexport class CompositionOperation {\n\n\tpublic static getEdits(prevEditOperationType: EditOperationType, config: CursorConfiguration, model: ITextModel, selections: Selection[], text: string, replacePrevCharCnt: number, replaceNextCharCnt: number, positionDelta: number) {\n\t\tconst commands = selections.map(selection => this._compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n\t\treturn new EditOperationResult(EditOperationType.TypingOther, commands, {\n\t\t\tshouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, EditOperationType.TypingOther),\n\t\t\tshouldPushStackElementAfter: false\n\t\t});\n\t}\n\n\tprivate static _compositionType(model: ITextModel, selection: Selection, text: string, replacePrevCharCnt: number, replaceNextCharCnt: number, positionDelta: number): ICommand | null {\n\t\tif (!selection.isEmpty()) {\n\t\t\t// looks like https://github.com/microsoft/vscode/issues/2773\n\t\t\t// where a cursor operation occurred before a canceled composition\n\t\t\t// => ignore composition\n\t\t\treturn null;\n\t\t}\n\t\tconst pos = selection.getPosition();\n\t\tconst startColumn = Math.max(1, pos.column - replacePrevCharCnt);\n\t\tconst endColumn = Math.min(model.getLineMaxColumn(pos.lineNumber), pos.column + replaceNextCharCnt);\n\t\tconst range = new Range(pos.lineNumber, startColumn, pos.lineNumber, endColumn);\n\t\tconst oldText = model.getValueInRange(range);\n\t\tif (oldText === text && positionDelta === 0) {\n\t\t\t// => ignore composition that doesn't do anything\n\t\t\treturn null;\n\t\t}\n\t\treturn new ReplaceCommandWithOffsetCursorState(range, text, 0, positionDelta);\n\t}\n}\n\nexport class TypeWithoutInterceptorsOperation {\n\n\tpublic static getEdits(prevEditOperationType: EditOperationType, selections: Selection[], str: string): EditOperationResult {\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tcommands[i] = new ReplaceCommand(selections[i], str);\n\t\t}\n\t\tconst opType = getTypingOperation(str, prevEditOperationType);\n\t\treturn new EditOperationResult(opType, commands, {\n\t\t\tshouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n\t\t\tshouldPushStackElementAfter: false\n\t\t});\n\t}\n}\n\nexport class TabOperation {\n\n\tpublic static getCommands(config: CursorConfiguration, model: ITextModel, selections: Selection[]) {\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst selection = selections[i];\n\t\t\tif (selection.isEmpty()) {\n\t\t\t\tconst lineText = model.getLineContent(selection.startLineNumber);\n\t\t\t\tif (/^\\s*$/.test(lineText) && model.tokenization.isCheapToTokenize(selection.startLineNumber)) {\n\t\t\t\t\tlet goodIndent = this._goodIndentForLine(config, model, selection.startLineNumber);\n\t\t\t\t\tgoodIndent = goodIndent || '\\t';\n\t\t\t\t\tconst possibleTypeText = config.normalizeIndentation(goodIndent);\n\t\t\t\t\tif (!lineText.startsWith(possibleTypeText)) {\n\t\t\t\t\t\tcommands[i] = new ReplaceCommand(new Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), possibleTypeText, true);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcommands[i] = this._replaceJumpToNextIndent(config, model, selection, true);\n\t\t\t} else {\n\t\t\t\tif (selection.startLineNumber === selection.endLineNumber) {\n\t\t\t\t\tconst lineMaxColumn = model.getLineMaxColumn(selection.startLineNumber);\n\t\t\t\t\tif (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {\n\t\t\t\t\t\t// This is a single line selection that is not the entire line\n\t\t\t\t\t\tcommands[i] = this._replaceJumpToNextIndent(config, model, selection, false);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcommands[i] = new ShiftCommand(selection, {\n\t\t\t\t\tisUnshift: false,\n\t\t\t\t\ttabSize: config.tabSize,\n\t\t\t\t\tindentSize: config.indentSize,\n\t\t\t\t\tinsertSpaces: config.insertSpaces,\n\t\t\t\t\tuseTabStops: config.useTabStops,\n\t\t\t\t\tautoIndent: config.autoIndent\n\t\t\t\t}, config.languageConfigurationService);\n\t\t\t}\n\t\t}\n\t\treturn commands;\n\t}\n\n\tprivate static _goodIndentForLine(config: CursorConfiguration, model: ITextModel, lineNumber: number): string | null {\n\t\tlet action: IndentAction | EnterAction | null = null;\n\t\tlet indentation: string = '';\n\t\tconst expectedIndentAction = getInheritIndentForLine(config.autoIndent, model, lineNumber, false, config.languageConfigurationService);\n\t\tif (expectedIndentAction) {\n\t\t\taction = expectedIndentAction.action;\n\t\t\tindentation = expectedIndentAction.indentation;\n\t\t} else if (lineNumber > 1) {\n\t\t\tlet lastLineNumber: number;\n\t\t\tfor (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n\t\t\t\tconst lineText = model.getLineContent(lastLineNumber);\n\t\t\t\tconst nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineText);\n\t\t\t\tif (nonWhitespaceIdx >= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lastLineNumber < 1) {\n\t\t\t\t// No previous line with content found\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst maxColumn = model.getLineMaxColumn(lastLineNumber);\n\t\t\tconst expectedEnterAction = getEnterAction(config.autoIndent, model, new Range(lastLineNumber, maxColumn, lastLineNumber, maxColumn), config.languageConfigurationService);\n\t\t\tif (expectedEnterAction) {\n\t\t\t\tindentation = expectedEnterAction.indentation + expectedEnterAction.appendText;\n\t\t\t}\n\t\t}\n\t\tif (action) {\n\t\t\tif (action === IndentAction.Indent) {\n\t\t\t\tindentation = shiftIndent(config, indentation);\n\t\t\t}\n\t\t\tif (action === IndentAction.Outdent) {\n\t\t\t\tindentation = unshiftIndent(config, indentation);\n\t\t\t}\n\t\t\tindentation = config.normalizeIndentation(indentation);\n\t\t}\n\t\tif (!indentation) {\n\t\t\treturn null;\n\t\t}\n\t\treturn indentation;\n\t}\n\n\tprivate static _replaceJumpToNextIndent(config: CursorConfiguration, model: ICursorSimpleModel, selection: Selection, insertsAutoWhitespace: boolean): ReplaceCommand {\n\t\tlet typeText = '';\n\t\tconst position = selection.getStartPosition();\n\t\tif (config.insertSpaces) {\n\t\t\tconst visibleColumnFromColumn = config.visibleColumnFromColumn(model, position);\n\t\t\tconst indentSize = config.indentSize;\n\t\t\tconst spacesCnt = indentSize - (visibleColumnFromColumn % indentSize);\n\t\t\tfor (let i = 0; i < spacesCnt; i++) {\n\t\t\t\ttypeText += ' ';\n\t\t\t}\n\t\t} else {\n\t\t\ttypeText = '\\t';\n\t\t}\n\t\treturn new ReplaceCommand(selection, typeText, insertsAutoWhitespace);\n\t}\n}\n\nexport class BaseTypeWithAutoClosingCommand extends ReplaceCommandWithOffsetCursorState {\n\n\tprivate readonly _openCharacter: string;\n\tprivate readonly _closeCharacter: string;\n\tpublic closeCharacterRange: Range | null;\n\tpublic enclosingRange: Range | null;\n\n\tconstructor(selection: Selection, text: string, lineNumberDeltaOffset: number, columnDeltaOffset: number, openCharacter: string, closeCharacter: string) {\n\t\tsuper(selection, text, lineNumberDeltaOffset, columnDeltaOffset);\n\t\tthis._openCharacter = openCharacter;\n\t\tthis._closeCharacter = closeCharacter;\n\t\tthis.closeCharacterRange = null;\n\t\tthis.enclosingRange = null;\n\t}\n\n\tprotected _computeCursorStateWithRange(model: ITextModel, range: Range, helper: ICursorStateComputerData): Selection {\n\t\tthis.closeCharacterRange = new Range(range.startLineNumber, range.endColumn - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n\t\tthis.enclosingRange = new Range(range.startLineNumber, range.endColumn - this._openCharacter.length - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n\t\treturn super.computeCursorState(model, helper);\n\t}\n}\n\nclass TypeWithAutoClosingCommand extends BaseTypeWithAutoClosingCommand {\n\n\tconstructor(selection: Selection, openCharacter: string, insertOpenCharacter: boolean, closeCharacter: string) {\n\t\tconst text = (insertOpenCharacter ? openCharacter : '') + closeCharacter;\n\t\tconst lineNumberDeltaOffset = 0;\n\t\tconst columnDeltaOffset = -closeCharacter.length;\n\t\tsuper(selection, text, lineNumberDeltaOffset, columnDeltaOffset, openCharacter, closeCharacter);\n\t}\n\n\tpublic override computeCursorState(model: ITextModel, helper: ICursorStateComputerData): Selection {\n\t\tconst inverseEditOperations = helper.getInverseEditOperations();\n\t\tconst range = inverseEditOperations[0].range;\n\t\treturn this._computeCursorStateWithRange(model, range, helper);\n\t}\n}\n\nclass TypeWithIndentationAndAutoClosingCommand extends BaseTypeWithAutoClosingCommand {\n\n\tprivate readonly _autoIndentationEdit: { range: Range; text: string };\n\tprivate readonly _autoClosingEdit: { range: Range; text: string };\n\n\tconstructor(autoIndentationEdit: { range: Range; text: string }, selection: Selection, openCharacter: string, closeCharacter: string) {\n\t\tconst text = openCharacter + closeCharacter;\n\t\tconst lineNumberDeltaOffset = 0;\n\t\tconst columnDeltaOffset = openCharacter.length;\n\t\tsuper(selection, text, lineNumberDeltaOffset, columnDeltaOffset, openCharacter, closeCharacter);\n\t\tthis._autoIndentationEdit = autoIndentationEdit;\n\t\tthis._autoClosingEdit = { range: selection, text };\n\t}\n\n\tpublic override getEditOperations(model: ITextModel, builder: IEditOperationBuilder): void {\n\t\tbuilder.addTrackedEditOperation(this._autoIndentationEdit.range, this._autoIndentationEdit.text);\n\t\tbuilder.addTrackedEditOperation(this._autoClosingEdit.range, this._autoClosingEdit.text);\n\t}\n\n\tpublic override computeCursorState(model: ITextModel, helper: ICursorStateComputerData): Selection {\n\t\tconst inverseEditOperations = helper.getInverseEditOperations();\n\t\tif (inverseEditOperations.length !== 2) {\n\t\t\tthrow new Error('There should be two inverse edit operations!');\n\t\t}\n\t\tconst range1 = inverseEditOperations[0].range;\n\t\tconst range2 = inverseEditOperations[1].range;\n\t\tconst range = range1.plusRange(range2);\n\t\treturn this._computeCursorStateWithRange(model, range, helper);\n\t}\n}\n\nfunction getTypingOperation(typedText: string, previousTypingOperation: EditOperationType): EditOperationType {\n\tif (typedText === ' ') {\n\t\treturn previousTypingOperation === EditOperationType.TypingFirstSpace\n\t\t\t|| previousTypingOperation === EditOperationType.TypingConsecutiveSpace\n\t\t\t? EditOperationType.TypingConsecutiveSpace\n\t\t\t: EditOperationType.TypingFirstSpace;\n\t}\n\n\treturn EditOperationType.TypingOther;\n}\n\nfunction shouldPushStackElementBetween(previousTypingOperation: EditOperationType, typingOperation: EditOperationType): boolean {\n\tif (isTypingOperation(previousTypingOperation) && !isTypingOperation(typingOperation)) {\n\t\t// Always set an undo stop before non-type operations\n\t\treturn true;\n\t}\n\tif (previousTypingOperation === EditOperationType.TypingFirstSpace) {\n\t\t// `abc |d`: No undo stop\n\t\t// `abc  |d`: Undo stop\n\t\treturn false;\n\t}\n\t// Insert undo stop between different operation types\n\treturn normalizeOperationType(previousTypingOperation) !== normalizeOperationType(typingOperation);\n}\n\nfunction normalizeOperationType(type: EditOperationType): EditOperationType | 'space' {\n\treturn (type === EditOperationType.TypingConsecutiveSpace || type === EditOperationType.TypingFirstSpace)\n\t\t? 'space'\n\t\t: type;\n}\n\nfunction isTypingOperation(type: EditOperationType): boolean {\n\treturn type === EditOperationType.TypingOther\n\t\t|| type === EditOperationType.TypingFirstSpace\n\t\t|| type === EditOperationType.TypingConsecutiveSpace;\n}\n\nfunction isAutoClosingOvertype(config: CursorConfiguration, model: ITextModel, selections: Selection[], autoClosedCharacters: Range[], ch: string): boolean {\n\tif (config.autoClosingOvertype === 'never') {\n\t\treturn false;\n\t}\n\tif (!config.autoClosingPairs.autoClosingPairsCloseSingleChar.has(ch)) {\n\t\treturn false;\n\t}\n\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\tconst selection = selections[i];\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn false;\n\t\t}\n\t\tconst position = selection.getPosition();\n\t\tconst lineText = model.getLineContent(position.lineNumber);\n\t\tconst afterCharacter = lineText.charAt(position.column - 1);\n\t\tif (afterCharacter !== ch) {\n\t\t\treturn false;\n\t\t}\n\t\t// Do not over-type quotes after a backslash\n\t\tconst chIsQuote = isQuote(ch);\n\t\tconst beforeCharacter = position.column > 2 ? lineText.charCodeAt(position.column - 2) : CharCode.Null;\n\t\tif (beforeCharacter === CharCode.Backslash && chIsQuote) {\n\t\t\treturn false;\n\t\t}\n\t\t// Must over-type a closing character typed by the editor\n\t\tif (config.autoClosingOvertype === 'auto') {\n\t\t\tlet found = false;\n\t\t\tfor (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n\t\t\t\tconst autoClosedCharacter = autoClosedCharacters[j];\n\t\t\t\tif (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nfunction typeCommand(range: Range, text: string, keepPosition: boolean): ICommand {\n\tif (keepPosition) {\n\t\treturn new ReplaceCommandWithoutChangingPosition(range, text, true);\n\t} else {\n\t\treturn new ReplaceCommand(range, text, true);\n\t}\n}\n\nexport function shiftIndent(config: CursorConfiguration, indentation: string, count?: number): string {\n\tcount = count || 1;\n\treturn ShiftCommand.shiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n}\n\nexport function unshiftIndent(config: CursorConfiguration, indentation: string, count?: number): string {\n\tcount = count || 1;\n\treturn ShiftCommand.unshiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n}\n\nexport function shouldSurroundChar(config: CursorConfiguration, ch: string): boolean {\n\tif (isQuote(ch)) {\n\t\treturn (config.autoSurround === 'quotes' || config.autoSurround === 'languageDefined');\n\t} else {\n\t\t// Character is a bracket\n\t\treturn (config.autoSurround === 'brackets' || config.autoSurround === 'languageDefined');\n\t}\n}\n"],
  "mappings": "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",
  "names": ["lineText", "indentation"]
}
