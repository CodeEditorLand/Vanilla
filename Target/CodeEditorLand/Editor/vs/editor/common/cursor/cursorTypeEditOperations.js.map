{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/cursor/cursorTypeEditOperations.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from \"../../../base/common/charCode.js\";\nimport { onUnexpectedError } from \"../../../base/common/errors.js\";\nimport * as strings from \"../../../base/common/strings.js\";\nimport {\n\tReplaceCommand,\n\tReplaceCommandThatPreservesSelection,\n\tReplaceCommandWithOffsetCursorState,\n\tReplaceCommandWithoutChangingPosition,\n} from \"../commands/replaceCommand.js\";\nimport { ShiftCommand } from \"../commands/shiftCommand.js\";\nimport { SurroundSelectionCommand } from \"../commands/surroundSelectionCommand.js\";\nimport {\n\ttype EditorAutoClosingStrategy,\n\tEditorAutoIndentStrategy,\n} from \"../config/editorOptions.js\";\nimport { Position } from \"../core/position.js\";\nimport { Range } from \"../core/range.js\";\nimport type { Selection } from \"../core/selection.js\";\nimport {\n\tWordCharacterClass,\n\tgetMapForWordSeparators,\n} from \"../core/wordCharacterClassifier.js\";\nimport {\n\ttype CursorConfiguration,\n\tEditOperationResult,\n\tEditOperationType,\n\ttype ICursorSimpleModel,\n\tisQuote,\n} from \"../cursorCommon.js\";\nimport type {\n\tICommand,\n\tICursorStateComputerData,\n\tIEditOperationBuilder,\n} from \"../editorCommon.js\";\nimport {\n\tgetIndentActionForType,\n\tgetIndentForEnter,\n\tgetInheritIndentForLine,\n} from \"../languages/autoIndent.js\";\nimport { getEnterAction } from \"../languages/enterAction.js\";\nimport {\n\ttype EnterAction,\n\tIndentAction,\n\ttype StandardAutoClosingPairConditional,\n} from \"../languages/languageConfiguration.js\";\nimport { getIndentationAtPosition } from \"../languages/languageConfigurationRegistry.js\";\nimport { createScopedLineTokens } from \"../languages/supports.js\";\nimport type { IElectricAction } from \"../languages/supports/electricCharacter.js\";\nimport type { ITextModel } from \"../model.js\";\n\nexport class AutoIndentOperation {\n\tpublic static getEdits(\n\t\tconfig: CursorConfiguration,\n\t\tmodel: ITextModel,\n\t\tselections: Selection[],\n\t\tch: string,\n\t\tisDoingComposition: boolean,\n\t): EditOperationResult | undefined {\n\t\tif (\n\t\t\t!isDoingComposition &&\n\t\t\tthis._isAutoIndentType(config, model, selections)\n\t\t) {\n\t\t\tconst indentationForSelections: {\n\t\t\t\tselection: Selection;\n\t\t\t\tindentation: string;\n\t\t\t}[] = [];\n\t\t\tfor (const selection of selections) {\n\t\t\t\tconst indentation = this._findActualIndentationForSelection(\n\t\t\t\t\tconfig,\n\t\t\t\t\tmodel,\n\t\t\t\t\tselection,\n\t\t\t\t\tch,\n\t\t\t\t);\n\t\t\t\tif (indentation === null) {\n\t\t\t\t\t// Auto indentation failed\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tindentationForSelections.push({ selection, indentation });\n\t\t\t}\n\t\t\tconst autoClosingPairClose =\n\t\t\t\tAutoClosingOpenCharTypeOperation.getAutoClosingPairClose(\n\t\t\t\t\tconfig,\n\t\t\t\t\tmodel,\n\t\t\t\t\tselections,\n\t\t\t\t\tch,\n\t\t\t\t\tfalse,\n\t\t\t\t);\n\t\t\treturn this._getIndentationAndAutoClosingPairEdits(\n\t\t\t\tconfig,\n\t\t\t\tmodel,\n\t\t\t\tindentationForSelections,\n\t\t\t\tch,\n\t\t\t\tautoClosingPairClose,\n\t\t\t);\n\t\t}\n\t\treturn;\n\t}\n\n\tprivate static _isAutoIndentType(\n\t\tconfig: CursorConfiguration,\n\t\tmodel: ITextModel,\n\t\tselections: Selection[],\n\t): boolean {\n\t\tif (config.autoIndent < EditorAutoIndentStrategy.Full) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tif (\n\t\t\t\t!model.tokenization.isCheapToTokenize(\n\t\t\t\t\tselections[i].getEndPosition().lineNumber,\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate static _findActualIndentationForSelection(\n\t\tconfig: CursorConfiguration,\n\t\tmodel: ITextModel,\n\t\tselection: Selection,\n\t\tch: string,\n\t): string | null {\n\t\tconst actualIndentation = getIndentActionForType(\n\t\t\tconfig,\n\t\t\tmodel,\n\t\t\tselection,\n\t\t\tch,\n\t\t\t{\n\t\t\t\tshiftIndent: (indentation) => {\n\t\t\t\t\treturn shiftIndent(config, indentation);\n\t\t\t\t},\n\t\t\t\tunshiftIndent: (indentation) => {\n\t\t\t\t\treturn unshiftIndent(config, indentation);\n\t\t\t\t},\n\t\t\t},\n\t\t\tconfig.languageConfigurationService,\n\t\t);\n\n\t\tif (actualIndentation === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst currentIndentation = getIndentationAtPosition(\n\t\t\tmodel,\n\t\t\tselection.startLineNumber,\n\t\t\tselection.startColumn,\n\t\t);\n\t\tif (\n\t\t\tactualIndentation ===\n\t\t\tconfig.normalizeIndentation(currentIndentation)\n\t\t) {\n\t\t\treturn null;\n\t\t}\n\t\treturn actualIndentation;\n\t}\n\n\tprivate static _getIndentationAndAutoClosingPairEdits(\n\t\tconfig: CursorConfiguration,\n\t\tmodel: ITextModel,\n\t\tindentationForSelections: {\n\t\t\tselection: Selection;\n\t\t\tindentation: string;\n\t\t}[],\n\t\tch: string,\n\t\tautoClosingPairClose: string | null,\n\t): EditOperationResult {\n\t\tconst commands: ICommand[] = indentationForSelections.map(\n\t\t\t({ selection, indentation }) => {\n\t\t\t\tif (autoClosingPairClose !== null) {\n\t\t\t\t\t// Apply both auto closing pair edits and auto indentation edits\n\t\t\t\t\tconst indentationEdit =\n\t\t\t\t\t\tthis._getEditFromIndentationAndSelection(\n\t\t\t\t\t\t\tconfig,\n\t\t\t\t\t\t\tmodel,\n\t\t\t\t\t\t\tindentation,\n\t\t\t\t\t\t\tselection,\n\t\t\t\t\t\t\tch,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t);\n\t\t\t\t\treturn new TypeWithIndentationAndAutoClosingCommand(\n\t\t\t\t\t\tindentationEdit,\n\t\t\t\t\t\tselection,\n\t\t\t\t\t\tch,\n\t\t\t\t\t\tautoClosingPairClose,\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\t// Apply only auto indentation edits\n\t\t\t\t\tconst indentationEdit =\n\t\t\t\t\t\tthis._getEditFromIndentationAndSelection(\n\t\t\t\t\t\t\tconfig,\n\t\t\t\t\t\t\tmodel,\n\t\t\t\t\t\t\tindentation,\n\t\t\t\t\t\t\tselection,\n\t\t\t\t\t\t\tch,\n\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t);\n\t\t\t\t\treturn typeCommand(\n\t\t\t\t\t\tindentationEdit.range,\n\t\t\t\t\t\tindentationEdit.text,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t},\n\t\t);\n\t\tconst editOptions = {\n\t\t\tshouldPushStackElementBefore: true,\n\t\t\tshouldPushStackElementAfter: false,\n\t\t};\n\t\treturn new EditOperationResult(\n\t\t\tEditOperationType.TypingOther,\n\t\t\tcommands,\n\t\t\teditOptions,\n\t\t);\n\t}\n\n\tprivate static _getEditFromIndentationAndSelection(\n\t\tconfig: CursorConfiguration,\n\t\tmodel: ITextModel,\n\t\tindentation: string,\n\t\tselection: Selection,\n\t\tch: string,\n\t\tincludeChInEdit = true,\n\t): { range: Range; text: string } {\n\t\tconst startLineNumber = selection.startLineNumber;\n\t\tconst firstNonWhitespaceColumn =\n\t\t\tmodel.getLineFirstNonWhitespaceColumn(startLineNumber);\n\t\tlet text: string = config.normalizeIndentation(indentation);\n\t\tif (firstNonWhitespaceColumn !== 0) {\n\t\t\tconst startLine = model.getLineContent(startLineNumber);\n\t\t\ttext += startLine.substring(\n\t\t\t\tfirstNonWhitespaceColumn - 1,\n\t\t\t\tselection.startColumn - 1,\n\t\t\t);\n\t\t}\n\t\ttext += includeChInEdit ? ch : \"\";\n\t\tconst range = new Range(\n\t\t\tstartLineNumber,\n\t\t\t1,\n\t\t\tselection.endLineNumber,\n\t\t\tselection.endColumn,\n\t\t);\n\t\treturn { range, text };\n\t}\n}\n\nexport class AutoClosingOvertypeOperation {\n\tpublic static getEdits(\n\t\tprevEditOperationType: EditOperationType,\n\t\tconfig: CursorConfiguration,\n\t\tmodel: ITextModel,\n\t\tselections: Selection[],\n\t\tautoClosedCharacters: Range[],\n\t\tch: string,\n\t): EditOperationResult | undefined {\n\t\tif (\n\t\t\tisAutoClosingOvertype(\n\t\t\t\tconfig,\n\t\t\t\tmodel,\n\t\t\t\tselections,\n\t\t\t\tautoClosedCharacters,\n\t\t\t\tch,\n\t\t\t)\n\t\t) {\n\t\t\treturn this._runAutoClosingOvertype(\n\t\t\t\tprevEditOperationType,\n\t\t\t\tselections,\n\t\t\t\tch,\n\t\t\t);\n\t\t}\n\t\treturn;\n\t}\n\n\tprivate static _runAutoClosingOvertype(\n\t\tprevEditOperationType: EditOperationType,\n\t\tselections: Selection[],\n\t\tch: string,\n\t): EditOperationResult {\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst selection = selections[i];\n\t\t\tconst position = selection.getPosition();\n\t\t\tconst typeSelection = new Range(\n\t\t\t\tposition.lineNumber,\n\t\t\t\tposition.column,\n\t\t\t\tposition.lineNumber,\n\t\t\t\tposition.column + 1,\n\t\t\t);\n\t\t\tcommands[i] = new ReplaceCommand(typeSelection, ch);\n\t\t}\n\t\treturn new EditOperationResult(\n\t\t\tEditOperationType.TypingOther,\n\t\t\tcommands,\n\t\t\t{\n\t\t\t\tshouldPushStackElementBefore: shouldPushStackElementBetween(\n\t\t\t\t\tprevEditOperationType,\n\t\t\t\t\tEditOperationType.TypingOther,\n\t\t\t\t),\n\t\t\t\tshouldPushStackElementAfter: false,\n\t\t\t},\n\t\t);\n\t}\n}\n\nexport class AutoClosingOvertypeWithInterceptorsOperation {\n\tpublic static getEdits(\n\t\tconfig: CursorConfiguration,\n\t\tmodel: ITextModel,\n\t\tselections: Selection[],\n\t\tautoClosedCharacters: Range[],\n\t\tch: string,\n\t): EditOperationResult | undefined {\n\t\tif (\n\t\t\tisAutoClosingOvertype(\n\t\t\t\tconfig,\n\t\t\t\tmodel,\n\t\t\t\tselections,\n\t\t\t\tautoClosedCharacters,\n\t\t\t\tch,\n\t\t\t)\n\t\t) {\n\t\t\t// Unfortunately, the close character is at this point \"doubled\", so we need to delete it...\n\t\t\tconst commands = selections.map(\n\t\t\t\t(s) =>\n\t\t\t\t\tnew ReplaceCommand(\n\t\t\t\t\t\tnew Range(\n\t\t\t\t\t\t\ts.positionLineNumber,\n\t\t\t\t\t\t\ts.positionColumn,\n\t\t\t\t\t\t\ts.positionLineNumber,\n\t\t\t\t\t\t\ts.positionColumn + 1,\n\t\t\t\t\t\t),\n\t\t\t\t\t\t\"\",\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t),\n\t\t\t);\n\t\t\treturn new EditOperationResult(\n\t\t\t\tEditOperationType.TypingOther,\n\t\t\t\tcommands,\n\t\t\t\t{\n\t\t\t\t\tshouldPushStackElementBefore: true,\n\t\t\t\t\tshouldPushStackElementAfter: false,\n\t\t\t\t},\n\t\t\t);\n\t\t}\n\t\treturn;\n\t}\n}\n\nexport class AutoClosingOpenCharTypeOperation {\n\tpublic static getEdits(\n\t\tconfig: CursorConfiguration,\n\t\tmodel: ITextModel,\n\t\tselections: Selection[],\n\t\tch: string,\n\t\tchIsAlreadyTyped: boolean,\n\t\tisDoingComposition: boolean,\n\t): EditOperationResult | undefined {\n\t\tif (!isDoingComposition) {\n\t\t\tconst autoClosingPairClose = this.getAutoClosingPairClose(\n\t\t\t\tconfig,\n\t\t\t\tmodel,\n\t\t\t\tselections,\n\t\t\t\tch,\n\t\t\t\tchIsAlreadyTyped,\n\t\t\t);\n\t\t\tif (autoClosingPairClose !== null) {\n\t\t\t\treturn this._runAutoClosingOpenCharType(\n\t\t\t\t\tselections,\n\t\t\t\t\tch,\n\t\t\t\t\tchIsAlreadyTyped,\n\t\t\t\t\tautoClosingPairClose,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tprivate static _runAutoClosingOpenCharType(\n\t\tselections: Selection[],\n\t\tch: string,\n\t\tchIsAlreadyTyped: boolean,\n\t\tautoClosingPairClose: string,\n\t): EditOperationResult {\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst selection = selections[i];\n\t\t\tcommands[i] = new TypeWithAutoClosingCommand(\n\t\t\t\tselection,\n\t\t\t\tch,\n\t\t\t\t!chIsAlreadyTyped,\n\t\t\t\tautoClosingPairClose,\n\t\t\t);\n\t\t}\n\t\treturn new EditOperationResult(\n\t\t\tEditOperationType.TypingOther,\n\t\t\tcommands,\n\t\t\t{\n\t\t\t\tshouldPushStackElementBefore: true,\n\t\t\t\tshouldPushStackElementAfter: false,\n\t\t\t},\n\t\t);\n\t}\n\n\tpublic static getAutoClosingPairClose(\n\t\tconfig: CursorConfiguration,\n\t\tmodel: ITextModel,\n\t\tselections: Selection[],\n\t\tch: string,\n\t\tchIsAlreadyTyped: boolean,\n\t): string | null {\n\t\tfor (const selection of selections) {\n\t\t\tif (!selection.isEmpty()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t// This method is called both when typing (regularly) and when composition ends\n\t\t// This means that we need to work with a text buffer where sometimes `ch` is not\n\t\t// there (it is being typed right now) or with a text buffer where `ch` has already been typed\n\t\t//\n\t\t// In order to avoid adding checks for `chIsAlreadyTyped` in all places, we will work\n\t\t// with two conceptual positions, the position before `ch` and the position after `ch`\n\t\t//\n\t\tconst positions: {\n\t\t\tlineNumber: number;\n\t\t\tbeforeColumn: number;\n\t\t\tafterColumn: number;\n\t\t}[] = selections.map((s) => {\n\t\t\tconst position = s.getPosition();\n\t\t\tif (chIsAlreadyTyped) {\n\t\t\t\treturn {\n\t\t\t\t\tlineNumber: position.lineNumber,\n\t\t\t\t\tbeforeColumn: position.column - ch.length,\n\t\t\t\t\tafterColumn: position.column,\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\tlineNumber: position.lineNumber,\n\t\t\t\t\tbeforeColumn: position.column,\n\t\t\t\t\tafterColumn: position.column,\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t\t// Find the longest auto-closing open pair in case of multiple ending in `ch`\n\t\t// e.g. when having [f\",\"] and [\",\"], it picks [f\",\"] if the character before is f\n\t\tconst pair = this._findAutoClosingPairOpen(\n\t\t\tconfig,\n\t\t\tmodel,\n\t\t\tpositions.map((p) => new Position(p.lineNumber, p.beforeColumn)),\n\t\t\tch,\n\t\t);\n\t\tif (!pair) {\n\t\t\treturn null;\n\t\t}\n\t\tlet autoCloseConfig: EditorAutoClosingStrategy;\n\t\tlet shouldAutoCloseBefore: (ch: string) => boolean;\n\n\t\tconst chIsQuote = isQuote(ch);\n\t\tif (chIsQuote) {\n\t\t\tautoCloseConfig = config.autoClosingQuotes;\n\t\t\tshouldAutoCloseBefore = config.shouldAutoCloseBefore.quote;\n\t\t} else {\n\t\t\tconst pairIsForComments = config.blockCommentStartToken\n\t\t\t\t? pair.open.includes(config.blockCommentStartToken)\n\t\t\t\t: false;\n\t\t\tif (pairIsForComments) {\n\t\t\t\tautoCloseConfig = config.autoClosingComments;\n\t\t\t\tshouldAutoCloseBefore = config.shouldAutoCloseBefore.comment;\n\t\t\t} else {\n\t\t\t\tautoCloseConfig = config.autoClosingBrackets;\n\t\t\t\tshouldAutoCloseBefore = config.shouldAutoCloseBefore.bracket;\n\t\t\t}\n\t\t}\n\t\tif (autoCloseConfig === \"never\") {\n\t\t\treturn null;\n\t\t}\n\t\t// Sometimes, it is possible to have two auto-closing pairs that have a containment relationship\n\t\t// e.g. when having [(,)] and [(*,*)]\n\t\t// - when typing (, the resulting state is (|)\n\t\t// - when typing *, the desired resulting state is (*|*), not (*|*))\n\t\tconst containedPair = this._findContainedAutoClosingPair(config, pair);\n\t\tconst containedPairClose = containedPair ? containedPair.close : \"\";\n\t\tlet isContainedPairPresent = true;\n\n\t\tfor (const position of positions) {\n\t\t\tconst { lineNumber, beforeColumn, afterColumn } = position;\n\t\t\tconst lineText = model.getLineContent(lineNumber);\n\t\t\tconst lineBefore = lineText.substring(0, beforeColumn - 1);\n\t\t\tconst lineAfter = lineText.substring(afterColumn - 1);\n\n\t\t\tif (!lineAfter.startsWith(containedPairClose)) {\n\t\t\t\tisContainedPairPresent = false;\n\t\t\t}\n\t\t\t// Only consider auto closing the pair if an allowed character follows or if another autoclosed pair closing brace follows\n\t\t\tif (lineAfter.length > 0) {\n\t\t\t\tconst characterAfter = lineAfter.charAt(0);\n\t\t\t\tconst isBeforeCloseBrace = this._isBeforeClosingBrace(\n\t\t\t\t\tconfig,\n\t\t\t\t\tlineAfter,\n\t\t\t\t);\n\t\t\t\tif (\n\t\t\t\t\t!isBeforeCloseBrace &&\n\t\t\t\t\t!shouldAutoCloseBefore(characterAfter)\n\t\t\t\t) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Do not auto-close ' or \" after a word character\n\t\t\tif (\n\t\t\t\tpair.open.length === 1 &&\n\t\t\t\t(ch === \"'\" || ch === '\"') &&\n\t\t\t\tautoCloseConfig !== \"always\"\n\t\t\t) {\n\t\t\t\tconst wordSeparators = getMapForWordSeparators(\n\t\t\t\t\tconfig.wordSeparators,\n\t\t\t\t\t[],\n\t\t\t\t);\n\t\t\t\tif (lineBefore.length > 0) {\n\t\t\t\t\tconst characterBefore = lineBefore.charCodeAt(\n\t\t\t\t\t\tlineBefore.length - 1,\n\t\t\t\t\t);\n\t\t\t\t\tif (\n\t\t\t\t\t\twordSeparators.get(characterBefore) ===\n\t\t\t\t\t\tWordCharacterClass.Regular\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!model.tokenization.isCheapToTokenize(lineNumber)) {\n\t\t\t\t// Do not force tokenization\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tmodel.tokenization.forceTokenization(lineNumber);\n\t\t\tconst lineTokens = model.tokenization.getLineTokens(lineNumber);\n\t\t\tconst scopedLineTokens = createScopedLineTokens(\n\t\t\t\tlineTokens,\n\t\t\t\tbeforeColumn - 1,\n\t\t\t);\n\t\t\tif (\n\t\t\t\t!pair.shouldAutoClose(\n\t\t\t\t\tscopedLineTokens,\n\t\t\t\t\tbeforeColumn - scopedLineTokens.firstCharOffset,\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// Typing for example a quote could either start a new string, in which case auto-closing is desirable\n\t\t\t// or it could end a previously started string, in which case auto-closing is not desirable\n\t\t\t//\n\t\t\t// In certain cases, it is really not possible to look at the previous token to determine\n\t\t\t// what would happen. That's why we do something really unusual, we pretend to type a different\n\t\t\t// character and ask the tokenizer what the outcome of doing that is: after typing a neutral\n\t\t\t// character, are we in a string (i.e. the quote would most likely end a string) or not?\n\t\t\t//\n\t\t\tconst neutralCharacter = pair.findNeutralCharacter();\n\t\t\tif (neutralCharacter) {\n\t\t\t\tconst tokenType =\n\t\t\t\t\tmodel.tokenization.getTokenTypeIfInsertingCharacter(\n\t\t\t\t\t\tlineNumber,\n\t\t\t\t\t\tbeforeColumn,\n\t\t\t\t\t\tneutralCharacter,\n\t\t\t\t\t);\n\t\t\t\tif (!pair.isOK(tokenType)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (isContainedPairPresent) {\n\t\t\treturn pair.close.substring(\n\t\t\t\t0,\n\t\t\t\tpair.close.length - containedPairClose.length,\n\t\t\t);\n\t\t} else {\n\t\t\treturn pair.close;\n\t\t}\n\t}\n\n\t/**\n\t * Find another auto-closing pair that is contained by the one passed in.\n\t *\n\t * e.g. when having [(,)] and [(*,*)] as auto-closing pairs\n\t * this method will find [(,)] as a containment pair for [(*,*)]\n\t */\n\tprivate static _findContainedAutoClosingPair(\n\t\tconfig: CursorConfiguration,\n\t\tpair: StandardAutoClosingPairConditional,\n\t): StandardAutoClosingPairConditional | null {\n\t\tif (pair.open.length <= 1) {\n\t\t\treturn null;\n\t\t}\n\t\tconst lastChar = pair.close.charAt(pair.close.length - 1);\n\t\t// get candidates with the same last character as close\n\t\tconst candidates =\n\t\t\tconfig.autoClosingPairs.autoClosingPairsCloseByEnd.get(lastChar) ||\n\t\t\t[];\n\t\tlet result: StandardAutoClosingPairConditional | null = null;\n\t\tfor (const candidate of candidates) {\n\t\t\tif (\n\t\t\t\tcandidate.open !== pair.open &&\n\t\t\t\tpair.open.includes(candidate.open) &&\n\t\t\t\tpair.close.endsWith(candidate.close)\n\t\t\t) {\n\t\t\t\tif (!result || candidate.open.length > result.open.length) {\n\t\t\t\t\tresult = candidate;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Determine if typing `ch` at all `positions` in the `model` results in an\n\t * auto closing open sequence being typed.\n\t *\n\t * Auto closing open sequences can consist of multiple characters, which\n\t * can lead to ambiguities. In such a case, the longest auto-closing open\n\t * sequence is returned.\n\t */\n\tprivate static _findAutoClosingPairOpen(\n\t\tconfig: CursorConfiguration,\n\t\tmodel: ITextModel,\n\t\tpositions: Position[],\n\t\tch: string,\n\t): StandardAutoClosingPairConditional | null {\n\t\tconst candidates =\n\t\t\tconfig.autoClosingPairs.autoClosingPairsOpenByEnd.get(ch);\n\t\tif (!candidates) {\n\t\t\treturn null;\n\t\t}\n\t\t// Determine which auto-closing pair it is\n\t\tlet result: StandardAutoClosingPairConditional | null = null;\n\t\tfor (const candidate of candidates) {\n\t\t\tif (result === null || candidate.open.length > result.open.length) {\n\t\t\t\tlet candidateIsMatch = true;\n\t\t\t\tfor (const position of positions) {\n\t\t\t\t\tconst relevantText = model.getValueInRange(\n\t\t\t\t\t\tnew Range(\n\t\t\t\t\t\t\tposition.lineNumber,\n\t\t\t\t\t\t\tposition.column - candidate.open.length + 1,\n\t\t\t\t\t\t\tposition.lineNumber,\n\t\t\t\t\t\t\tposition.column,\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t\tif (relevantText + ch !== candidate.open) {\n\t\t\t\t\t\tcandidateIsMatch = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (candidateIsMatch) {\n\t\t\t\t\tresult = candidate;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static _isBeforeClosingBrace(\n\t\tconfig: CursorConfiguration,\n\t\tlineAfter: string,\n\t) {\n\t\t// If the start of lineAfter can be interpretted as both a starting or ending brace, default to returning false\n\t\tconst nextChar = lineAfter.charAt(0);\n\t\tconst potentialStartingBraces =\n\t\t\tconfig.autoClosingPairs.autoClosingPairsOpenByStart.get(nextChar) ||\n\t\t\t[];\n\t\tconst potentialClosingBraces =\n\t\t\tconfig.autoClosingPairs.autoClosingPairsCloseByStart.get(\n\t\t\t\tnextChar,\n\t\t\t) || [];\n\n\t\tconst isBeforeStartingBrace = potentialStartingBraces.some((x) =>\n\t\t\tlineAfter.startsWith(x.open),\n\t\t);\n\t\tconst isBeforeClosingBrace = potentialClosingBraces.some((x) =>\n\t\t\tlineAfter.startsWith(x.close),\n\t\t);\n\n\t\treturn !isBeforeStartingBrace && isBeforeClosingBrace;\n\t}\n}\n\nexport class SurroundSelectionOperation {\n\tpublic static getEdits(\n\t\tconfig: CursorConfiguration,\n\t\tmodel: ITextModel,\n\t\tselections: Selection[],\n\t\tch: string,\n\t\tisDoingComposition: boolean,\n\t): EditOperationResult | undefined {\n\t\tif (\n\t\t\t!isDoingComposition &&\n\t\t\tthis._isSurroundSelectionType(config, model, selections, ch)\n\t\t) {\n\t\t\treturn this._runSurroundSelectionType(config, selections, ch);\n\t\t}\n\t\treturn;\n\t}\n\n\tprivate static _runSurroundSelectionType(\n\t\tconfig: CursorConfiguration,\n\t\tselections: Selection[],\n\t\tch: string,\n\t): EditOperationResult {\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst selection = selections[i];\n\t\t\tconst closeCharacter = config.surroundingPairs[ch];\n\t\t\tcommands[i] = new SurroundSelectionCommand(\n\t\t\t\tselection,\n\t\t\t\tch,\n\t\t\t\tcloseCharacter,\n\t\t\t);\n\t\t}\n\t\treturn new EditOperationResult(EditOperationType.Other, commands, {\n\t\t\tshouldPushStackElementBefore: true,\n\t\t\tshouldPushStackElementAfter: true,\n\t\t});\n\t}\n\n\tprivate static _isSurroundSelectionType(\n\t\tconfig: CursorConfiguration,\n\t\tmodel: ITextModel,\n\t\tselections: Selection[],\n\t\tch: string,\n\t): boolean {\n\t\tif (\n\t\t\t!shouldSurroundChar(config, ch) ||\n\t\t\t!config.surroundingPairs.hasOwnProperty(ch)\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t\tconst isTypingAQuoteCharacter = isQuote(ch);\n\t\tfor (const selection of selections) {\n\t\t\tif (selection.isEmpty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tlet selectionContainsOnlyWhitespace = true;\n\t\t\tfor (\n\t\t\t\tlet lineNumber = selection.startLineNumber;\n\t\t\t\tlineNumber <= selection.endLineNumber;\n\t\t\t\tlineNumber++\n\t\t\t) {\n\t\t\t\tconst lineText = model.getLineContent(lineNumber);\n\t\t\t\tconst startIndex =\n\t\t\t\t\tlineNumber === selection.startLineNumber\n\t\t\t\t\t\t? selection.startColumn - 1\n\t\t\t\t\t\t: 0;\n\t\t\t\tconst endIndex =\n\t\t\t\t\tlineNumber === selection.endLineNumber\n\t\t\t\t\t\t? selection.endColumn - 1\n\t\t\t\t\t\t: lineText.length;\n\t\t\t\tconst selectedText = lineText.substring(startIndex, endIndex);\n\t\t\t\tif (/[^ \\t]/.test(selectedText)) {\n\t\t\t\t\t// this selected text contains something other than whitespace\n\t\t\t\t\tselectionContainsOnlyWhitespace = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (selectionContainsOnlyWhitespace) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (\n\t\t\t\tisTypingAQuoteCharacter &&\n\t\t\t\tselection.startLineNumber === selection.endLineNumber &&\n\t\t\t\tselection.startColumn + 1 === selection.endColumn\n\t\t\t) {\n\t\t\t\tconst selectionText = model.getValueInRange(selection);\n\t\t\t\tif (isQuote(selectionText)) {\n\t\t\t\t\t// Typing a quote character on top of another quote character\n\t\t\t\t\t// => disable surround selection type\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n\nexport class InterceptorElectricCharOperation {\n\tpublic static getEdits(\n\t\tprevEditOperationType: EditOperationType,\n\t\tconfig: CursorConfiguration,\n\t\tmodel: ITextModel,\n\t\tselections: Selection[],\n\t\tch: string,\n\t\tisDoingComposition: boolean,\n\t): EditOperationResult | undefined {\n\t\t// Electric characters make sense only when dealing with a single cursor,\n\t\t// as multiple cursors typing brackets for example would interfer with bracket matching\n\t\tif (\n\t\t\t!isDoingComposition &&\n\t\t\tthis._isTypeInterceptorElectricChar(config, model, selections)\n\t\t) {\n\t\t\tconst r = this._typeInterceptorElectricChar(\n\t\t\t\tprevEditOperationType,\n\t\t\t\tconfig,\n\t\t\t\tmodel,\n\t\t\t\tselections[0],\n\t\t\t\tch,\n\t\t\t);\n\t\t\tif (r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tprivate static _isTypeInterceptorElectricChar(\n\t\tconfig: CursorConfiguration,\n\t\tmodel: ITextModel,\n\t\tselections: Selection[],\n\t) {\n\t\tif (\n\t\t\tselections.length === 1 &&\n\t\t\tmodel.tokenization.isCheapToTokenize(\n\t\t\t\tselections[0].getEndPosition().lineNumber,\n\t\t\t)\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate static _typeInterceptorElectricChar(\n\t\tprevEditOperationType: EditOperationType,\n\t\tconfig: CursorConfiguration,\n\t\tmodel: ITextModel,\n\t\tselection: Selection,\n\t\tch: string,\n\t): EditOperationResult | null {\n\t\tif (!config.electricChars.hasOwnProperty(ch) || !selection.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\t\tconst position = selection.getPosition();\n\t\tmodel.tokenization.forceTokenization(position.lineNumber);\n\t\tconst lineTokens = model.tokenization.getLineTokens(\n\t\t\tposition.lineNumber,\n\t\t);\n\t\tlet electricAction: IElectricAction | null;\n\t\ttry {\n\t\t\telectricAction = config.onElectricCharacter(\n\t\t\t\tch,\n\t\t\t\tlineTokens,\n\t\t\t\tposition.column,\n\t\t\t);\n\t\t} catch (e) {\n\t\t\tonUnexpectedError(e);\n\t\t\treturn null;\n\t\t}\n\t\tif (!electricAction) {\n\t\t\treturn null;\n\t\t}\n\t\tif (electricAction.matchOpenBracket) {\n\t\t\tconst endColumn =\n\t\t\t\t(lineTokens.getLineContent() + ch).lastIndexOf(\n\t\t\t\t\telectricAction.matchOpenBracket,\n\t\t\t\t) + 1;\n\t\t\tconst match = model.bracketPairs.findMatchingBracketUp(\n\t\t\t\telectricAction.matchOpenBracket,\n\t\t\t\t{\n\t\t\t\t\tlineNumber: position.lineNumber,\n\t\t\t\t\tcolumn: endColumn,\n\t\t\t\t},\n\t\t\t\t500 /* give at most 500ms to compute */,\n\t\t\t);\n\t\t\tif (match) {\n\t\t\t\tif (match.startLineNumber === position.lineNumber) {\n\t\t\t\t\t// matched something on the same line => no change in indentation\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tconst matchLine = model.getLineContent(match.startLineNumber);\n\t\t\t\tconst matchLineIndentation =\n\t\t\t\t\tstrings.getLeadingWhitespace(matchLine);\n\t\t\t\tconst newIndentation =\n\t\t\t\t\tconfig.normalizeIndentation(matchLineIndentation);\n\t\t\t\tconst lineText = model.getLineContent(position.lineNumber);\n\t\t\t\tconst lineFirstNonBlankColumn =\n\t\t\t\t\tmodel.getLineFirstNonWhitespaceColumn(\n\t\t\t\t\t\tposition.lineNumber,\n\t\t\t\t\t) || position.column;\n\t\t\t\tconst prefix = lineText.substring(\n\t\t\t\t\tlineFirstNonBlankColumn - 1,\n\t\t\t\t\tposition.column - 1,\n\t\t\t\t);\n\t\t\t\tconst typeText = newIndentation + prefix + ch;\n\t\t\t\tconst typeSelection = new Range(\n\t\t\t\t\tposition.lineNumber,\n\t\t\t\t\t1,\n\t\t\t\t\tposition.lineNumber,\n\t\t\t\t\tposition.column,\n\t\t\t\t);\n\t\t\t\tconst command = new ReplaceCommand(typeSelection, typeText);\n\t\t\t\treturn new EditOperationResult(\n\t\t\t\t\tgetTypingOperation(typeText, prevEditOperationType),\n\t\t\t\t\t[command],\n\t\t\t\t\t{\n\t\t\t\t\t\tshouldPushStackElementBefore: false,\n\t\t\t\t\t\tshouldPushStackElementAfter: true,\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n}\n\nexport class SimpleCharacterTypeOperation {\n\tpublic static getEdits(\n\t\tprevEditOperationType: EditOperationType,\n\t\tselections: Selection[],\n\t\tch: string,\n\t): EditOperationResult {\n\t\t// A simple character type\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tcommands[i] = new ReplaceCommand(selections[i], ch);\n\t\t}\n\n\t\tconst opType = getTypingOperation(ch, prevEditOperationType);\n\t\treturn new EditOperationResult(opType, commands, {\n\t\t\tshouldPushStackElementBefore: shouldPushStackElementBetween(\n\t\t\t\tprevEditOperationType,\n\t\t\t\topType,\n\t\t\t),\n\t\t\tshouldPushStackElementAfter: false,\n\t\t});\n\t}\n}\n\nexport class EnterOperation {\n\tpublic static getEdits(\n\t\tconfig: CursorConfiguration,\n\t\tmodel: ITextModel,\n\t\tselections: Selection[],\n\t\tch: string,\n\t\tisDoingComposition: boolean,\n\t): EditOperationResult | undefined {\n\t\tif (!isDoingComposition && ch === \"\\n\") {\n\t\t\tconst commands: ICommand[] = [];\n\t\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\t\tcommands[i] = this._enter(config, model, false, selections[i]);\n\t\t\t}\n\t\t\treturn new EditOperationResult(\n\t\t\t\tEditOperationType.TypingOther,\n\t\t\t\tcommands,\n\t\t\t\t{\n\t\t\t\t\tshouldPushStackElementBefore: true,\n\t\t\t\t\tshouldPushStackElementAfter: false,\n\t\t\t\t},\n\t\t\t);\n\t\t}\n\t\treturn;\n\t}\n\n\tprivate static _enter(\n\t\tconfig: CursorConfiguration,\n\t\tmodel: ITextModel,\n\t\tkeepPosition: boolean,\n\t\trange: Range,\n\t): ICommand {\n\t\tif (config.autoIndent === EditorAutoIndentStrategy.None) {\n\t\t\treturn typeCommand(range, \"\\n\", keepPosition);\n\t\t}\n\t\tif (\n\t\t\t!model.tokenization.isCheapToTokenize(\n\t\t\t\trange.getStartPosition().lineNumber,\n\t\t\t) ||\n\t\t\tconfig.autoIndent === EditorAutoIndentStrategy.Keep\n\t\t) {\n\t\t\tconst lineText = model.getLineContent(range.startLineNumber);\n\t\t\tconst indentation = strings\n\t\t\t\t.getLeadingWhitespace(lineText)\n\t\t\t\t.substring(0, range.startColumn - 1);\n\t\t\treturn typeCommand(\n\t\t\t\trange,\n\t\t\t\t\"\\n\" + config.normalizeIndentation(indentation),\n\t\t\t\tkeepPosition,\n\t\t\t);\n\t\t}\n\t\tconst r = getEnterAction(\n\t\t\tconfig.autoIndent,\n\t\t\tmodel,\n\t\t\trange,\n\t\t\tconfig.languageConfigurationService,\n\t\t);\n\t\tif (r) {\n\t\t\tif (r.indentAction === IndentAction.None) {\n\t\t\t\t// Nothing special\n\t\t\t\treturn typeCommand(\n\t\t\t\t\trange,\n\t\t\t\t\t\"\\n\" +\n\t\t\t\t\t\tconfig.normalizeIndentation(\n\t\t\t\t\t\t\tr.indentation + r.appendText,\n\t\t\t\t\t\t),\n\t\t\t\t\tkeepPosition,\n\t\t\t\t);\n\t\t\t} else if (r.indentAction === IndentAction.Indent) {\n\t\t\t\t// Indent once\n\t\t\t\treturn typeCommand(\n\t\t\t\t\trange,\n\t\t\t\t\t\"\\n\" +\n\t\t\t\t\t\tconfig.normalizeIndentation(\n\t\t\t\t\t\t\tr.indentation + r.appendText,\n\t\t\t\t\t\t),\n\t\t\t\t\tkeepPosition,\n\t\t\t\t);\n\t\t\t} else if (r.indentAction === IndentAction.IndentOutdent) {\n\t\t\t\t// Ultra special\n\t\t\t\tconst normalIndent = config.normalizeIndentation(r.indentation);\n\t\t\t\tconst increasedIndent = config.normalizeIndentation(\n\t\t\t\t\tr.indentation + r.appendText,\n\t\t\t\t);\n\t\t\t\tconst typeText = \"\\n\" + increasedIndent + \"\\n\" + normalIndent;\n\t\t\t\tif (keepPosition) {\n\t\t\t\t\treturn new ReplaceCommandWithoutChangingPosition(\n\t\t\t\t\t\trange,\n\t\t\t\t\t\ttypeText,\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\treturn new ReplaceCommandWithOffsetCursorState(\n\t\t\t\t\t\trange,\n\t\t\t\t\t\ttypeText,\n\t\t\t\t\t\t-1,\n\t\t\t\t\t\tincreasedIndent.length - normalIndent.length,\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else if (r.indentAction === IndentAction.Outdent) {\n\t\t\t\tconst actualIndentation = unshiftIndent(config, r.indentation);\n\t\t\t\treturn typeCommand(\n\t\t\t\t\trange,\n\t\t\t\t\t\"\\n\" +\n\t\t\t\t\t\tconfig.normalizeIndentation(\n\t\t\t\t\t\t\tactualIndentation + r.appendText,\n\t\t\t\t\t\t),\n\t\t\t\t\tkeepPosition,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tconst lineText = model.getLineContent(range.startLineNumber);\n\t\tconst indentation = strings\n\t\t\t.getLeadingWhitespace(lineText)\n\t\t\t.substring(0, range.startColumn - 1);\n\n\t\tif (config.autoIndent >= EditorAutoIndentStrategy.Full) {\n\t\t\tconst ir = getIndentForEnter(\n\t\t\t\tconfig.autoIndent,\n\t\t\t\tmodel,\n\t\t\t\trange,\n\t\t\t\t{\n\t\t\t\t\tunshiftIndent: (indent) => {\n\t\t\t\t\t\treturn unshiftIndent(config, indent);\n\t\t\t\t\t},\n\t\t\t\t\tshiftIndent: (indent) => {\n\t\t\t\t\t\treturn shiftIndent(config, indent);\n\t\t\t\t\t},\n\t\t\t\t\tnormalizeIndentation: (indent) => {\n\t\t\t\t\t\treturn config.normalizeIndentation(indent);\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tconfig.languageConfigurationService,\n\t\t\t);\n\n\t\t\tif (ir) {\n\t\t\t\tlet oldEndViewColumn = config.visibleColumnFromColumn(\n\t\t\t\t\tmodel,\n\t\t\t\t\trange.getEndPosition(),\n\t\t\t\t);\n\t\t\t\tconst oldEndColumn = range.endColumn;\n\t\t\t\tconst newLineContent = model.getLineContent(\n\t\t\t\t\trange.endLineNumber,\n\t\t\t\t);\n\t\t\t\tconst firstNonWhitespace =\n\t\t\t\t\tstrings.firstNonWhitespaceIndex(newLineContent);\n\t\t\t\tif (firstNonWhitespace >= 0) {\n\t\t\t\t\trange = range.setEndPosition(\n\t\t\t\t\t\trange.endLineNumber,\n\t\t\t\t\t\tMath.max(range.endColumn, firstNonWhitespace + 1),\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\trange = range.setEndPosition(\n\t\t\t\t\t\trange.endLineNumber,\n\t\t\t\t\t\tmodel.getLineMaxColumn(range.endLineNumber),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif (keepPosition) {\n\t\t\t\t\treturn new ReplaceCommandWithoutChangingPosition(\n\t\t\t\t\t\trange,\n\t\t\t\t\t\t\"\\n\" + config.normalizeIndentation(ir.afterEnter),\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tlet offset = 0;\n\t\t\t\t\tif (oldEndColumn <= firstNonWhitespace + 1) {\n\t\t\t\t\t\tif (!config.insertSpaces) {\n\t\t\t\t\t\t\toldEndViewColumn = Math.ceil(\n\t\t\t\t\t\t\t\toldEndViewColumn / config.indentSize,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\toffset = Math.min(\n\t\t\t\t\t\t\toldEndViewColumn +\n\t\t\t\t\t\t\t\t1 -\n\t\t\t\t\t\t\t\tconfig.normalizeIndentation(ir.afterEnter)\n\t\t\t\t\t\t\t\t\t.length -\n\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn new ReplaceCommandWithOffsetCursorState(\n\t\t\t\t\t\trange,\n\t\t\t\t\t\t\"\\n\" + config.normalizeIndentation(ir.afterEnter),\n\t\t\t\t\t\t0,\n\t\t\t\t\t\toffset,\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn typeCommand(\n\t\t\trange,\n\t\t\t\"\\n\" + config.normalizeIndentation(indentation),\n\t\t\tkeepPosition,\n\t\t);\n\t}\n\n\tpublic static lineInsertBefore(\n\t\tconfig: CursorConfiguration,\n\t\tmodel: ITextModel | null,\n\t\tselections: Selection[] | null,\n\t): ICommand[] {\n\t\tif (model === null || selections === null) {\n\t\t\treturn [];\n\t\t}\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tlet lineNumber = selections[i].positionLineNumber;\n\t\t\tif (lineNumber === 1) {\n\t\t\t\tcommands[i] = new ReplaceCommandWithoutChangingPosition(\n\t\t\t\t\tnew Range(1, 1, 1, 1),\n\t\t\t\t\t\"\\n\",\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tlineNumber--;\n\t\t\t\tconst column = model.getLineMaxColumn(lineNumber);\n\n\t\t\t\tcommands[i] = this._enter(\n\t\t\t\t\tconfig,\n\t\t\t\t\tmodel,\n\t\t\t\t\tfalse,\n\t\t\t\t\tnew Range(lineNumber, column, lineNumber, column),\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn commands;\n\t}\n\n\tpublic static lineInsertAfter(\n\t\tconfig: CursorConfiguration,\n\t\tmodel: ITextModel | null,\n\t\tselections: Selection[] | null,\n\t): ICommand[] {\n\t\tif (model === null || selections === null) {\n\t\t\treturn [];\n\t\t}\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst lineNumber = selections[i].positionLineNumber;\n\t\t\tconst column = model.getLineMaxColumn(lineNumber);\n\t\t\tcommands[i] = this._enter(\n\t\t\t\tconfig,\n\t\t\t\tmodel,\n\t\t\t\tfalse,\n\t\t\t\tnew Range(lineNumber, column, lineNumber, column),\n\t\t\t);\n\t\t}\n\t\treturn commands;\n\t}\n\n\tpublic static lineBreakInsert(\n\t\tconfig: CursorConfiguration,\n\t\tmodel: ITextModel,\n\t\tselections: Selection[],\n\t): ICommand[] {\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tcommands[i] = this._enter(config, model, true, selections[i]);\n\t\t}\n\t\treturn commands;\n\t}\n}\n\nexport class PasteOperation {\n\tpublic static getEdits(\n\t\tconfig: CursorConfiguration,\n\t\tmodel: ICursorSimpleModel,\n\t\tselections: Selection[],\n\t\ttext: string,\n\t\tpasteOnNewLine: boolean,\n\t\tmulticursorText: string[],\n\t) {\n\t\tconst distributedPaste = this._distributePasteToCursors(\n\t\t\tconfig,\n\t\t\tselections,\n\t\t\ttext,\n\t\t\tpasteOnNewLine,\n\t\t\tmulticursorText,\n\t\t);\n\t\tif (distributedPaste) {\n\t\t\tselections = selections.sort(Range.compareRangesUsingStarts);\n\t\t\treturn this._distributedPaste(\n\t\t\t\tconfig,\n\t\t\t\tmodel,\n\t\t\t\tselections,\n\t\t\t\tdistributedPaste,\n\t\t\t);\n\t\t} else {\n\t\t\treturn this._simplePaste(\n\t\t\t\tconfig,\n\t\t\t\tmodel,\n\t\t\t\tselections,\n\t\t\t\ttext,\n\t\t\t\tpasteOnNewLine,\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate static _distributePasteToCursors(\n\t\tconfig: CursorConfiguration,\n\t\tselections: Selection[],\n\t\ttext: string,\n\t\tpasteOnNewLine: boolean,\n\t\tmulticursorText: string[],\n\t): string[] | null {\n\t\tif (pasteOnNewLine) {\n\t\t\treturn null;\n\t\t}\n\t\tif (selections.length === 1) {\n\t\t\treturn null;\n\t\t}\n\t\tif (multicursorText && multicursorText.length === selections.length) {\n\t\t\treturn multicursorText;\n\t\t}\n\t\tif (config.multiCursorPaste === \"spread\") {\n\t\t\t// Try to spread the pasted text in case the line count matches the cursor count\n\t\t\t// Remove trailing \\n if present\n\t\t\tif (text.charCodeAt(text.length - 1) === CharCode.LineFeed) {\n\t\t\t\ttext = text.substring(0, text.length - 1);\n\t\t\t}\n\t\t\t// Remove trailing \\r if present\n\t\t\tif (text.charCodeAt(text.length - 1) === CharCode.CarriageReturn) {\n\t\t\t\ttext = text.substring(0, text.length - 1);\n\t\t\t}\n\t\t\tconst lines = strings.splitLines(text);\n\t\t\tif (lines.length === selections.length) {\n\t\t\t\treturn lines;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate static _distributedPaste(\n\t\tconfig: CursorConfiguration,\n\t\tmodel: ICursorSimpleModel,\n\t\tselections: Selection[],\n\t\ttext: string[],\n\t): EditOperationResult {\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tcommands[i] = new ReplaceCommand(selections[i], text[i]);\n\t\t}\n\t\treturn new EditOperationResult(EditOperationType.Other, commands, {\n\t\t\tshouldPushStackElementBefore: true,\n\t\t\tshouldPushStackElementAfter: true,\n\t\t});\n\t}\n\n\tprivate static _simplePaste(\n\t\tconfig: CursorConfiguration,\n\t\tmodel: ICursorSimpleModel,\n\t\tselections: Selection[],\n\t\ttext: string,\n\t\tpasteOnNewLine: boolean,\n\t): EditOperationResult {\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst selection = selections[i];\n\t\t\tconst position = selection.getPosition();\n\t\t\tif (pasteOnNewLine && !selection.isEmpty()) {\n\t\t\t\tpasteOnNewLine = false;\n\t\t\t}\n\t\t\tif (pasteOnNewLine && text.indexOf(\"\\n\") !== text.length - 1) {\n\t\t\t\tpasteOnNewLine = false;\n\t\t\t}\n\t\t\tif (pasteOnNewLine) {\n\t\t\t\t// Paste entire line at the beginning of line\n\t\t\t\tconst typeSelection = new Range(\n\t\t\t\t\tposition.lineNumber,\n\t\t\t\t\t1,\n\t\t\t\t\tposition.lineNumber,\n\t\t\t\t\t1,\n\t\t\t\t);\n\t\t\t\tcommands[i] = new ReplaceCommandThatPreservesSelection(\n\t\t\t\t\ttypeSelection,\n\t\t\t\t\ttext,\n\t\t\t\t\tselection,\n\t\t\t\t\ttrue,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tcommands[i] = new ReplaceCommand(selection, text);\n\t\t\t}\n\t\t}\n\t\treturn new EditOperationResult(EditOperationType.Other, commands, {\n\t\t\tshouldPushStackElementBefore: true,\n\t\t\tshouldPushStackElementAfter: true,\n\t\t});\n\t}\n}\n\nexport class CompositionOperation {\n\tpublic static getEdits(\n\t\tprevEditOperationType: EditOperationType,\n\t\tconfig: CursorConfiguration,\n\t\tmodel: ITextModel,\n\t\tselections: Selection[],\n\t\ttext: string,\n\t\treplacePrevCharCnt: number,\n\t\treplaceNextCharCnt: number,\n\t\tpositionDelta: number,\n\t) {\n\t\tconst commands = selections.map((selection) =>\n\t\t\tthis._compositionType(\n\t\t\t\tmodel,\n\t\t\t\tselection,\n\t\t\t\ttext,\n\t\t\t\treplacePrevCharCnt,\n\t\t\t\treplaceNextCharCnt,\n\t\t\t\tpositionDelta,\n\t\t\t),\n\t\t);\n\t\treturn new EditOperationResult(\n\t\t\tEditOperationType.TypingOther,\n\t\t\tcommands,\n\t\t\t{\n\t\t\t\tshouldPushStackElementBefore: shouldPushStackElementBetween(\n\t\t\t\t\tprevEditOperationType,\n\t\t\t\t\tEditOperationType.TypingOther,\n\t\t\t\t),\n\t\t\t\tshouldPushStackElementAfter: false,\n\t\t\t},\n\t\t);\n\t}\n\n\tprivate static _compositionType(\n\t\tmodel: ITextModel,\n\t\tselection: Selection,\n\t\ttext: string,\n\t\treplacePrevCharCnt: number,\n\t\treplaceNextCharCnt: number,\n\t\tpositionDelta: number,\n\t): ICommand | null {\n\t\tif (!selection.isEmpty()) {\n\t\t\t// looks like https://github.com/microsoft/vscode/issues/2773\n\t\t\t// where a cursor operation occurred before a canceled composition\n\t\t\t// => ignore composition\n\t\t\treturn null;\n\t\t}\n\t\tconst pos = selection.getPosition();\n\t\tconst startColumn = Math.max(1, pos.column - replacePrevCharCnt);\n\t\tconst endColumn = Math.min(\n\t\t\tmodel.getLineMaxColumn(pos.lineNumber),\n\t\t\tpos.column + replaceNextCharCnt,\n\t\t);\n\t\tconst range = new Range(\n\t\t\tpos.lineNumber,\n\t\t\tstartColumn,\n\t\t\tpos.lineNumber,\n\t\t\tendColumn,\n\t\t);\n\t\tconst oldText = model.getValueInRange(range);\n\t\tif (oldText === text && positionDelta === 0) {\n\t\t\t// => ignore composition that doesn't do anything\n\t\t\treturn null;\n\t\t}\n\t\treturn new ReplaceCommandWithOffsetCursorState(\n\t\t\trange,\n\t\t\ttext,\n\t\t\t0,\n\t\t\tpositionDelta,\n\t\t);\n\t}\n}\n\nexport class TypeWithoutInterceptorsOperation {\n\tpublic static getEdits(\n\t\tprevEditOperationType: EditOperationType,\n\t\tselections: Selection[],\n\t\tstr: string,\n\t): EditOperationResult {\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tcommands[i] = new ReplaceCommand(selections[i], str);\n\t\t}\n\t\tconst opType = getTypingOperation(str, prevEditOperationType);\n\t\treturn new EditOperationResult(opType, commands, {\n\t\t\tshouldPushStackElementBefore: shouldPushStackElementBetween(\n\t\t\t\tprevEditOperationType,\n\t\t\t\topType,\n\t\t\t),\n\t\t\tshouldPushStackElementAfter: false,\n\t\t});\n\t}\n}\n\nexport class TabOperation {\n\tpublic static getCommands(\n\t\tconfig: CursorConfiguration,\n\t\tmodel: ITextModel,\n\t\tselections: Selection[],\n\t) {\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst selection = selections[i];\n\t\t\tif (selection.isEmpty()) {\n\t\t\t\tconst lineText = model.getLineContent(\n\t\t\t\t\tselection.startLineNumber,\n\t\t\t\t);\n\t\t\t\tif (\n\t\t\t\t\t/^\\s*$/.test(lineText) &&\n\t\t\t\t\tmodel.tokenization.isCheapToTokenize(\n\t\t\t\t\t\tselection.startLineNumber,\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tlet goodIndent = this._goodIndentForLine(\n\t\t\t\t\t\tconfig,\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\tselection.startLineNumber,\n\t\t\t\t\t);\n\t\t\t\t\tgoodIndent = goodIndent || \"\\t\";\n\t\t\t\t\tconst possibleTypeText =\n\t\t\t\t\t\tconfig.normalizeIndentation(goodIndent);\n\t\t\t\t\tif (!lineText.startsWith(possibleTypeText)) {\n\t\t\t\t\t\tcommands[i] = new ReplaceCommand(\n\t\t\t\t\t\t\tnew Range(\n\t\t\t\t\t\t\t\tselection.startLineNumber,\n\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\tselection.startLineNumber,\n\t\t\t\t\t\t\t\tlineText.length + 1,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tpossibleTypeText,\n\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcommands[i] = this._replaceJumpToNextIndent(\n\t\t\t\t\tconfig,\n\t\t\t\t\tmodel,\n\t\t\t\t\tselection,\n\t\t\t\t\ttrue,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tif (selection.startLineNumber === selection.endLineNumber) {\n\t\t\t\t\tconst lineMaxColumn = model.getLineMaxColumn(\n\t\t\t\t\t\tselection.startLineNumber,\n\t\t\t\t\t);\n\t\t\t\t\tif (\n\t\t\t\t\t\tselection.startColumn !== 1 ||\n\t\t\t\t\t\tselection.endColumn !== lineMaxColumn\n\t\t\t\t\t) {\n\t\t\t\t\t\t// This is a single line selection that is not the entire line\n\t\t\t\t\t\tcommands[i] = this._replaceJumpToNextIndent(\n\t\t\t\t\t\t\tconfig,\n\t\t\t\t\t\t\tmodel,\n\t\t\t\t\t\t\tselection,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcommands[i] = new ShiftCommand(\n\t\t\t\t\tselection,\n\t\t\t\t\t{\n\t\t\t\t\t\tisUnshift: false,\n\t\t\t\t\t\ttabSize: config.tabSize,\n\t\t\t\t\t\tindentSize: config.indentSize,\n\t\t\t\t\t\tinsertSpaces: config.insertSpaces,\n\t\t\t\t\t\tuseTabStops: config.useTabStops,\n\t\t\t\t\t\tautoIndent: config.autoIndent,\n\t\t\t\t\t},\n\t\t\t\t\tconfig.languageConfigurationService,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn commands;\n\t}\n\n\tprivate static _goodIndentForLine(\n\t\tconfig: CursorConfiguration,\n\t\tmodel: ITextModel,\n\t\tlineNumber: number,\n\t): string | null {\n\t\tlet action: IndentAction | EnterAction | null = null;\n\t\tlet indentation = \"\";\n\t\tconst expectedIndentAction = getInheritIndentForLine(\n\t\t\tconfig.autoIndent,\n\t\t\tmodel,\n\t\t\tlineNumber,\n\t\t\tfalse,\n\t\t\tconfig.languageConfigurationService,\n\t\t);\n\t\tif (expectedIndentAction) {\n\t\t\taction = expectedIndentAction.action;\n\t\t\tindentation = expectedIndentAction.indentation;\n\t\t} else if (lineNumber > 1) {\n\t\t\tlet lastLineNumber: number;\n\t\t\tfor (\n\t\t\t\tlastLineNumber = lineNumber - 1;\n\t\t\t\tlastLineNumber >= 1;\n\t\t\t\tlastLineNumber--\n\t\t\t) {\n\t\t\t\tconst lineText = model.getLineContent(lastLineNumber);\n\t\t\t\tconst nonWhitespaceIdx =\n\t\t\t\t\tstrings.lastNonWhitespaceIndex(lineText);\n\t\t\t\tif (nonWhitespaceIdx >= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lastLineNumber < 1) {\n\t\t\t\t// No previous line with content found\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst maxColumn = model.getLineMaxColumn(lastLineNumber);\n\t\t\tconst expectedEnterAction = getEnterAction(\n\t\t\t\tconfig.autoIndent,\n\t\t\t\tmodel,\n\t\t\t\tnew Range(lastLineNumber, maxColumn, lastLineNumber, maxColumn),\n\t\t\t\tconfig.languageConfigurationService,\n\t\t\t);\n\t\t\tif (expectedEnterAction) {\n\t\t\t\tindentation =\n\t\t\t\t\texpectedEnterAction.indentation +\n\t\t\t\t\texpectedEnterAction.appendText;\n\t\t\t}\n\t\t}\n\t\tif (action) {\n\t\t\tif (action === IndentAction.Indent) {\n\t\t\t\tindentation = shiftIndent(config, indentation);\n\t\t\t}\n\t\t\tif (action === IndentAction.Outdent) {\n\t\t\t\tindentation = unshiftIndent(config, indentation);\n\t\t\t}\n\t\t\tindentation = config.normalizeIndentation(indentation);\n\t\t}\n\t\tif (!indentation) {\n\t\t\treturn null;\n\t\t}\n\t\treturn indentation;\n\t}\n\n\tprivate static _replaceJumpToNextIndent(\n\t\tconfig: CursorConfiguration,\n\t\tmodel: ICursorSimpleModel,\n\t\tselection: Selection,\n\t\tinsertsAutoWhitespace: boolean,\n\t): ReplaceCommand {\n\t\tlet typeText = \"\";\n\t\tconst position = selection.getStartPosition();\n\t\tif (config.insertSpaces) {\n\t\t\tconst visibleColumnFromColumn = config.visibleColumnFromColumn(\n\t\t\t\tmodel,\n\t\t\t\tposition,\n\t\t\t);\n\t\t\tconst indentSize = config.indentSize;\n\t\t\tconst spacesCnt =\n\t\t\t\tindentSize - (visibleColumnFromColumn % indentSize);\n\t\t\tfor (let i = 0; i < spacesCnt; i++) {\n\t\t\t\ttypeText += \" \";\n\t\t\t}\n\t\t} else {\n\t\t\ttypeText = \"\\t\";\n\t\t}\n\t\treturn new ReplaceCommand(selection, typeText, insertsAutoWhitespace);\n\t}\n}\n\nexport class BaseTypeWithAutoClosingCommand extends ReplaceCommandWithOffsetCursorState {\n\tprivate readonly _openCharacter: string;\n\tprivate readonly _closeCharacter: string;\n\tpublic closeCharacterRange: Range | null;\n\tpublic enclosingRange: Range | null;\n\n\tconstructor(\n\t\tselection: Selection,\n\t\ttext: string,\n\t\tlineNumberDeltaOffset: number,\n\t\tcolumnDeltaOffset: number,\n\t\topenCharacter: string,\n\t\tcloseCharacter: string,\n\t) {\n\t\tsuper(selection, text, lineNumberDeltaOffset, columnDeltaOffset);\n\t\tthis._openCharacter = openCharacter;\n\t\tthis._closeCharacter = closeCharacter;\n\t\tthis.closeCharacterRange = null;\n\t\tthis.enclosingRange = null;\n\t}\n\n\tprotected _computeCursorStateWithRange(\n\t\tmodel: ITextModel,\n\t\trange: Range,\n\t\thelper: ICursorStateComputerData,\n\t): Selection {\n\t\tthis.closeCharacterRange = new Range(\n\t\t\trange.startLineNumber,\n\t\t\trange.endColumn - this._closeCharacter.length,\n\t\t\trange.endLineNumber,\n\t\t\trange.endColumn,\n\t\t);\n\t\tthis.enclosingRange = new Range(\n\t\t\trange.startLineNumber,\n\t\t\trange.endColumn -\n\t\t\t\tthis._openCharacter.length -\n\t\t\t\tthis._closeCharacter.length,\n\t\t\trange.endLineNumber,\n\t\t\trange.endColumn,\n\t\t);\n\t\treturn super.computeCursorState(model, helper);\n\t}\n}\n\nclass TypeWithAutoClosingCommand extends BaseTypeWithAutoClosingCommand {\n\tconstructor(\n\t\tselection: Selection,\n\t\topenCharacter: string,\n\t\tinsertOpenCharacter: boolean,\n\t\tcloseCharacter: string,\n\t) {\n\t\tconst text =\n\t\t\t(insertOpenCharacter ? openCharacter : \"\") + closeCharacter;\n\t\tconst lineNumberDeltaOffset = 0;\n\t\tconst columnDeltaOffset = -closeCharacter.length;\n\t\tsuper(\n\t\t\tselection,\n\t\t\ttext,\n\t\t\tlineNumberDeltaOffset,\n\t\t\tcolumnDeltaOffset,\n\t\t\topenCharacter,\n\t\t\tcloseCharacter,\n\t\t);\n\t}\n\n\tpublic override computeCursorState(\n\t\tmodel: ITextModel,\n\t\thelper: ICursorStateComputerData,\n\t): Selection {\n\t\tconst inverseEditOperations = helper.getInverseEditOperations();\n\t\tconst range = inverseEditOperations[0].range;\n\t\treturn this._computeCursorStateWithRange(model, range, helper);\n\t}\n}\n\nclass TypeWithIndentationAndAutoClosingCommand extends BaseTypeWithAutoClosingCommand {\n\tprivate readonly _autoIndentationEdit: { range: Range; text: string };\n\tprivate readonly _autoClosingEdit: { range: Range; text: string };\n\n\tconstructor(\n\t\tautoIndentationEdit: { range: Range; text: string },\n\t\tselection: Selection,\n\t\topenCharacter: string,\n\t\tcloseCharacter: string,\n\t) {\n\t\tconst text = openCharacter + closeCharacter;\n\t\tconst lineNumberDeltaOffset = 0;\n\t\tconst columnDeltaOffset = openCharacter.length;\n\t\tsuper(\n\t\t\tselection,\n\t\t\ttext,\n\t\t\tlineNumberDeltaOffset,\n\t\t\tcolumnDeltaOffset,\n\t\t\topenCharacter,\n\t\t\tcloseCharacter,\n\t\t);\n\t\tthis._autoIndentationEdit = autoIndentationEdit;\n\t\tthis._autoClosingEdit = { range: selection, text };\n\t}\n\n\tpublic override getEditOperations(\n\t\tmodel: ITextModel,\n\t\tbuilder: IEditOperationBuilder,\n\t): void {\n\t\tbuilder.addTrackedEditOperation(\n\t\t\tthis._autoIndentationEdit.range,\n\t\t\tthis._autoIndentationEdit.text,\n\t\t);\n\t\tbuilder.addTrackedEditOperation(\n\t\t\tthis._autoClosingEdit.range,\n\t\t\tthis._autoClosingEdit.text,\n\t\t);\n\t}\n\n\tpublic override computeCursorState(\n\t\tmodel: ITextModel,\n\t\thelper: ICursorStateComputerData,\n\t): Selection {\n\t\tconst inverseEditOperations = helper.getInverseEditOperations();\n\t\tif (inverseEditOperations.length !== 2) {\n\t\t\tthrow new Error(\"There should be two inverse edit operations!\");\n\t\t}\n\t\tconst range1 = inverseEditOperations[0].range;\n\t\tconst range2 = inverseEditOperations[1].range;\n\t\tconst range = range1.plusRange(range2);\n\t\treturn this._computeCursorStateWithRange(model, range, helper);\n\t}\n}\n\nfunction getTypingOperation(\n\ttypedText: string,\n\tpreviousTypingOperation: EditOperationType,\n): EditOperationType {\n\tif (typedText === \" \") {\n\t\treturn previousTypingOperation === EditOperationType.TypingFirstSpace ||\n\t\t\tpreviousTypingOperation === EditOperationType.TypingConsecutiveSpace\n\t\t\t? EditOperationType.TypingConsecutiveSpace\n\t\t\t: EditOperationType.TypingFirstSpace;\n\t}\n\n\treturn EditOperationType.TypingOther;\n}\n\nfunction shouldPushStackElementBetween(\n\tpreviousTypingOperation: EditOperationType,\n\ttypingOperation: EditOperationType,\n): boolean {\n\tif (\n\t\tisTypingOperation(previousTypingOperation) &&\n\t\t!isTypingOperation(typingOperation)\n\t) {\n\t\t// Always set an undo stop before non-type operations\n\t\treturn true;\n\t}\n\tif (previousTypingOperation === EditOperationType.TypingFirstSpace) {\n\t\t// `abc |d`: No undo stop\n\t\t// `abc  |d`: Undo stop\n\t\treturn false;\n\t}\n\t// Insert undo stop between different operation types\n\treturn (\n\t\tnormalizeOperationType(previousTypingOperation) !==\n\t\tnormalizeOperationType(typingOperation)\n\t);\n}\n\nfunction normalizeOperationType(\n\ttype: EditOperationType,\n): EditOperationType | \"space\" {\n\treturn type === EditOperationType.TypingConsecutiveSpace ||\n\t\ttype === EditOperationType.TypingFirstSpace\n\t\t? \"space\"\n\t\t: type;\n}\n\nfunction isTypingOperation(type: EditOperationType): boolean {\n\treturn (\n\t\ttype === EditOperationType.TypingOther ||\n\t\ttype === EditOperationType.TypingFirstSpace ||\n\t\ttype === EditOperationType.TypingConsecutiveSpace\n\t);\n}\n\nfunction isAutoClosingOvertype(\n\tconfig: CursorConfiguration,\n\tmodel: ITextModel,\n\tselections: Selection[],\n\tautoClosedCharacters: Range[],\n\tch: string,\n): boolean {\n\tif (config.autoClosingOvertype === \"never\") {\n\t\treturn false;\n\t}\n\tif (!config.autoClosingPairs.autoClosingPairsCloseSingleChar.has(ch)) {\n\t\treturn false;\n\t}\n\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\tconst selection = selections[i];\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn false;\n\t\t}\n\t\tconst position = selection.getPosition();\n\t\tconst lineText = model.getLineContent(position.lineNumber);\n\t\tconst afterCharacter = lineText.charAt(position.column - 1);\n\t\tif (afterCharacter !== ch) {\n\t\t\treturn false;\n\t\t}\n\t\t// Do not over-type quotes after a backslash\n\t\tconst chIsQuote = isQuote(ch);\n\t\tconst beforeCharacter =\n\t\t\tposition.column > 2\n\t\t\t\t? lineText.charCodeAt(position.column - 2)\n\t\t\t\t: CharCode.Null;\n\t\tif (beforeCharacter === CharCode.Backslash && chIsQuote) {\n\t\t\treturn false;\n\t\t}\n\t\t// Must over-type a closing character typed by the editor\n\t\tif (config.autoClosingOvertype === \"auto\") {\n\t\t\tlet found = false;\n\t\t\tfor (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n\t\t\t\tconst autoClosedCharacter = autoClosedCharacters[j];\n\t\t\t\tif (\n\t\t\t\t\tposition.lineNumber ===\n\t\t\t\t\t\tautoClosedCharacter.startLineNumber &&\n\t\t\t\t\tposition.column === autoClosedCharacter.startColumn\n\t\t\t\t) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nfunction typeCommand(\n\trange: Range,\n\ttext: string,\n\tkeepPosition: boolean,\n): ICommand {\n\tif (keepPosition) {\n\t\treturn new ReplaceCommandWithoutChangingPosition(range, text, true);\n\t} else {\n\t\treturn new ReplaceCommand(range, text, true);\n\t}\n}\n\nexport function shiftIndent(\n\tconfig: CursorConfiguration,\n\tindentation: string,\n\tcount?: number,\n): string {\n\tcount = count || 1;\n\treturn ShiftCommand.shiftIndent(\n\t\tindentation,\n\t\tindentation.length + count,\n\t\tconfig.tabSize,\n\t\tconfig.indentSize,\n\t\tconfig.insertSpaces,\n\t);\n}\n\nexport function unshiftIndent(\n\tconfig: CursorConfiguration,\n\tindentation: string,\n\tcount?: number,\n): string {\n\tcount = count || 1;\n\treturn ShiftCommand.unshiftIndent(\n\t\tindentation,\n\t\tindentation.length + count,\n\t\tconfig.tabSize,\n\t\tconfig.indentSize,\n\t\tconfig.insertSpaces,\n\t);\n}\n\nexport function shouldSurroundChar(\n\tconfig: CursorConfiguration,\n\tch: string,\n): boolean {\n\tif (isQuote(ch)) {\n\t\treturn (\n\t\t\tconfig.autoSurround === \"quotes\" ||\n\t\t\tconfig.autoSurround === \"languageDefined\"\n\t\t);\n\t} else {\n\t\t// Character is a bracket\n\t\treturn (\n\t\t\tconfig.autoSurround === \"brackets\" ||\n\t\t\tconfig.autoSurround === \"languageDefined\"\n\t\t);\n\t}\n}\n"],
  "mappings": "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",
  "names": ["lineText", "indentation"]
}
