import*as S from"../../../base/common/types.js";import{CursorState as u,SelectionStartKind as d,SingleCursorState as w}from"../cursorCommon.js";import{MoveOperations as p}from"./cursorMoveOperations.js";import{WordOperations as g}from"./cursorWordOperations.js";import{Position as b}from"../core/position.js";import{Range as h}from"../core/range.js";import"../../../platform/commands/common/commands.js";import"../viewModel.js";class O{static addCursorDown(t,e,i){const n=[];let r=0;for(let a=0,o=e.length;a<o;a++){const l=e[a];n[r++]=new u(l.modelState,l.viewState),i?n[r++]=u.fromModelState(p.translateDown(t.cursorConfig,t.model,l.modelState)):n[r++]=u.fromViewState(p.translateDown(t.cursorConfig,t,l.viewState))}return n}static addCursorUp(t,e,i){const n=[];let r=0;for(let a=0,o=e.length;a<o;a++){const l=e[a];n[r++]=new u(l.modelState,l.viewState),i?n[r++]=u.fromModelState(p.translateUp(t.cursorConfig,t.model,l.modelState)):n[r++]=u.fromViewState(p.translateUp(t.cursorConfig,t,l.viewState))}return n}static moveToBeginningOfLine(t,e,i){const n=[];for(let r=0,a=e.length;r<a;r++){const o=e[r];n[r]=this._moveToLineStart(t,o,i)}return n}static _moveToLineStart(t,e,i){const n=e.viewState.position.column,r=e.modelState.position.column,a=n===r,o=e.viewState.position.lineNumber,l=t.getLineFirstNonWhitespaceColumn(o);return!a&&!(n===l)?this._moveToLineStartByView(t,e,i):this._moveToLineStartByModel(t,e,i)}static _moveToLineStartByView(t,e,i){return u.fromViewState(p.moveToBeginningOfLine(t.cursorConfig,t,e.viewState,i))}static _moveToLineStartByModel(t,e,i){return u.fromModelState(p.moveToBeginningOfLine(t.cursorConfig,t.model,e.modelState,i))}static moveToEndOfLine(t,e,i,n){const r=[];for(let a=0,o=e.length;a<o;a++){const l=e[a];r[a]=this._moveToLineEnd(t,l,i,n)}return r}static _moveToLineEnd(t,e,i,n){const r=e.viewState.position,a=t.getLineMaxColumn(r.lineNumber),o=r.column===a,l=e.modelState.position,s=t.model.getLineMaxColumn(l.lineNumber),c=a-r.column===s-l.column;return o||c?this._moveToLineEndByModel(t,e,i,n):this._moveToLineEndByView(t,e,i,n)}static _moveToLineEndByView(t,e,i,n){return u.fromViewState(p.moveToEndOfLine(t.cursorConfig,t,e.viewState,i,n))}static _moveToLineEndByModel(t,e,i,n){return u.fromModelState(p.moveToEndOfLine(t.cursorConfig,t.model,e.modelState,i,n))}static expandLineSelection(t,e){const i=[];for(let n=0,r=e.length;n<r;n++){const a=e[n],o=a.modelState.selection.startLineNumber,l=t.model.getLineCount();let s=a.modelState.selection.endLineNumber,c;s===l?c=t.model.getLineMaxColumn(l):(s++,c=1),i[n]=u.fromModelState(new w(new h(o,1,o,1),d.Simple,0,new b(s,c),0))}return i}static moveToBeginningOfBuffer(t,e,i){const n=[];for(let r=0,a=e.length;r<a;r++){const o=e[r];n[r]=u.fromModelState(p.moveToBeginningOfBuffer(t.cursorConfig,t.model,o.modelState,i))}return n}static moveToEndOfBuffer(t,e,i){const n=[];for(let r=0,a=e.length;r<a;r++){const o=e[r];n[r]=u.fromModelState(p.moveToEndOfBuffer(t.cursorConfig,t.model,o.modelState,i))}return n}static selectAll(t,e){const i=t.model.getLineCount(),n=t.model.getLineMaxColumn(i);return u.fromModelState(new w(new h(1,1,1,1),d.Simple,0,new b(i,n),0))}static line(t,e,i,n,r){const a=t.model.validatePosition(n),o=r?t.coordinatesConverter.validateViewPosition(new b(r.lineNumber,r.column),a):t.coordinatesConverter.convertModelPositionToViewPosition(a);if(!i){const s=t.model.getLineCount();let c=a.lineNumber+1,f=1;return c>s&&(c=s,f=t.model.getLineMaxColumn(c)),u.fromModelState(new w(new h(a.lineNumber,1,c,f),d.Line,0,new b(c,f),0))}const l=e.modelState.selectionStart.getStartPosition().lineNumber;if(a.lineNumber<l)return u.fromViewState(e.viewState.move(!0,o.lineNumber,1,0));if(a.lineNumber>l){const s=t.getLineCount();let c=o.lineNumber+1,f=1;return c>s&&(c=s,f=t.getLineMaxColumn(c)),u.fromViewState(e.viewState.move(!0,c,f,0))}else{const s=e.modelState.selectionStart.getEndPosition();return u.fromModelState(e.modelState.move(!0,s.lineNumber,s.column,0))}}static word(t,e,i,n){const r=t.model.validatePosition(n);return u.fromModelState(g.word(t.cursorConfig,t.model,e.modelState,i,r))}static cancelSelection(t,e){if(!e.modelState.hasSelection())return new u(e.modelState,e.viewState);const i=e.viewState.position.lineNumber,n=e.viewState.position.column;return u.fromViewState(new w(new h(i,n,i,n),d.Simple,0,new b(i,n),0))}static moveTo(t,e,i,n,r){if(i){if(e.modelState.selectionStartKind===d.Word)return this.word(t,e,i,n);if(e.modelState.selectionStartKind===d.Line)return this.line(t,e,i,n,r)}const a=t.model.validatePosition(n),o=r?t.coordinatesConverter.validateViewPosition(new b(r.lineNumber,r.column),a):t.coordinatesConverter.convertModelPositionToViewPosition(a);return u.fromViewState(e.viewState.move(i,o.lineNumber,o.column,0))}static simpleMove(t,e,i,n,r,a){switch(i){case C.Direction.Left:return a===C.Unit.HalfLine?this._moveHalfLineLeft(t,e,n):this._moveLeft(t,e,n,r);case C.Direction.Right:return a===C.Unit.HalfLine?this._moveHalfLineRight(t,e,n):this._moveRight(t,e,n,r);case C.Direction.Up:return a===C.Unit.WrappedLine?this._moveUpByViewLines(t,e,n,r):this._moveUpByModelLines(t,e,n,r);case C.Direction.Down:return a===C.Unit.WrappedLine?this._moveDownByViewLines(t,e,n,r):this._moveDownByModelLines(t,e,n,r);case C.Direction.PrevBlankLine:return a===C.Unit.WrappedLine?e.map(o=>u.fromViewState(p.moveToPrevBlankLine(t.cursorConfig,t,o.viewState,n))):e.map(o=>u.fromModelState(p.moveToPrevBlankLine(t.cursorConfig,t.model,o.modelState,n)));case C.Direction.NextBlankLine:return a===C.Unit.WrappedLine?e.map(o=>u.fromViewState(p.moveToNextBlankLine(t.cursorConfig,t,o.viewState,n))):e.map(o=>u.fromModelState(p.moveToNextBlankLine(t.cursorConfig,t.model,o.modelState,n)));case C.Direction.WrappedLineStart:return this._moveToViewMinColumn(t,e,n);case C.Direction.WrappedLineFirstNonWhitespaceCharacter:return this._moveToViewFirstNonWhitespaceColumn(t,e,n);case C.Direction.WrappedLineColumnCenter:return this._moveToViewCenterColumn(t,e,n);case C.Direction.WrappedLineEnd:return this._moveToViewMaxColumn(t,e,n);case C.Direction.WrappedLineLastNonWhitespaceCharacter:return this._moveToViewLastNonWhitespaceColumn(t,e,n);default:return null}}static viewportMove(t,e,i,n,r){const a=t.getCompletelyVisibleViewRange(),o=t.coordinatesConverter.convertViewRangeToModelRange(a);switch(i){case C.Direction.ViewPortTop:{const l=this._firstLineNumberInRange(t.model,o,r),s=t.model.getLineFirstNonWhitespaceColumn(l);return[this._moveToModelPosition(t,e[0],n,l,s)]}case C.Direction.ViewPortBottom:{const l=this._lastLineNumberInRange(t.model,o,r),s=t.model.getLineFirstNonWhitespaceColumn(l);return[this._moveToModelPosition(t,e[0],n,l,s)]}case C.Direction.ViewPortCenter:{const l=Math.round((o.startLineNumber+o.endLineNumber)/2),s=t.model.getLineFirstNonWhitespaceColumn(l);return[this._moveToModelPosition(t,e[0],n,l,s)]}case C.Direction.ViewPortIfOutside:{const l=[];for(let s=0,c=e.length;s<c;s++){const f=e[s];l[s]=this.findPositionInViewportIfOutside(t,f,a,n)}return l}default:return null}}static findPositionInViewportIfOutside(t,e,i,n){const r=e.viewState.position.lineNumber;if(i.startLineNumber<=r&&r<=i.endLineNumber-1)return new u(e.modelState,e.viewState);{let a;r>i.endLineNumber-1?a=i.endLineNumber-1:r<i.startLineNumber?a=i.startLineNumber:a=r;const o=p.vertical(t.cursorConfig,t,r,e.viewState.position.column,e.viewState.leftoverVisibleColumns,a,!1);return u.fromViewState(e.viewState.move(n,o.lineNumber,o.column,o.leftoverVisibleColumns))}}static _firstLineNumberInRange(t,e,i){let n=e.startLineNumber;return e.startColumn!==t.getLineMinColumn(n)&&n++,Math.min(e.endLineNumber,n+i-1)}static _lastLineNumberInRange(t,e,i){let n=e.startLineNumber;return e.startColumn!==t.getLineMinColumn(n)&&n++,Math.max(n,e.endLineNumber-i+1)}static _moveLeft(t,e,i,n){return e.map(r=>u.fromViewState(p.moveLeft(t.cursorConfig,t,r.viewState,i,n)))}static _moveHalfLineLeft(t,e,i){const n=[];for(let r=0,a=e.length;r<a;r++){const o=e[r],l=o.viewState.position.lineNumber,s=Math.round(t.getLineLength(l)/2);n[r]=u.fromViewState(p.moveLeft(t.cursorConfig,t,o.viewState,i,s))}return n}static _moveRight(t,e,i,n){return e.map(r=>u.fromViewState(p.moveRight(t.cursorConfig,t,r.viewState,i,n)))}static _moveHalfLineRight(t,e,i){const n=[];for(let r=0,a=e.length;r<a;r++){const o=e[r],l=o.viewState.position.lineNumber,s=Math.round(t.getLineLength(l)/2);n[r]=u.fromViewState(p.moveRight(t.cursorConfig,t,o.viewState,i,s))}return n}static _moveDownByViewLines(t,e,i,n){const r=[];for(let a=0,o=e.length;a<o;a++){const l=e[a];r[a]=u.fromViewState(p.moveDown(t.cursorConfig,t,l.viewState,i,n))}return r}static _moveDownByModelLines(t,e,i,n){const r=[];for(let a=0,o=e.length;a<o;a++){const l=e[a];r[a]=u.fromModelState(p.moveDown(t.cursorConfig,t.model,l.modelState,i,n))}return r}static _moveUpByViewLines(t,e,i,n){const r=[];for(let a=0,o=e.length;a<o;a++){const l=e[a];r[a]=u.fromViewState(p.moveUp(t.cursorConfig,t,l.viewState,i,n))}return r}static _moveUpByModelLines(t,e,i,n){const r=[];for(let a=0,o=e.length;a<o;a++){const l=e[a];r[a]=u.fromModelState(p.moveUp(t.cursorConfig,t.model,l.modelState,i,n))}return r}static _moveToViewPosition(t,e,i,n,r){return u.fromViewState(e.viewState.move(i,n,r,0))}static _moveToModelPosition(t,e,i,n,r){return u.fromModelState(e.modelState.move(i,n,r,0))}static _moveToViewMinColumn(t,e,i){const n=[];for(let r=0,a=e.length;r<a;r++){const o=e[r],l=o.viewState.position.lineNumber,s=t.getLineMinColumn(l);n[r]=this._moveToViewPosition(t,o,i,l,s)}return n}static _moveToViewFirstNonWhitespaceColumn(t,e,i){const n=[];for(let r=0,a=e.length;r<a;r++){const o=e[r],l=o.viewState.position.lineNumber,s=t.getLineFirstNonWhitespaceColumn(l);n[r]=this._moveToViewPosition(t,o,i,l,s)}return n}static _moveToViewCenterColumn(t,e,i){const n=[];for(let r=0,a=e.length;r<a;r++){const o=e[r],l=o.viewState.position.lineNumber,s=Math.round((t.getLineMaxColumn(l)+t.getLineMinColumn(l))/2);n[r]=this._moveToViewPosition(t,o,i,l,s)}return n}static _moveToViewMaxColumn(t,e,i){const n=[];for(let r=0,a=e.length;r<a;r++){const o=e[r],l=o.viewState.position.lineNumber,s=t.getLineMaxColumn(l);n[r]=this._moveToViewPosition(t,o,i,l,s)}return n}static _moveToViewLastNonWhitespaceColumn(t,e,i){const n=[];for(let r=0,a=e.length;r<a;r++){const o=e[r],l=o.viewState.position.lineNumber,s=t.getLineLastNonWhitespaceColumn(l);n[r]=this._moveToViewPosition(t,o,i,l,s)}return n}}var C;(o=>{const P=function(l){if(!S.isObject(l))return!1;const s=l;return!(!S.isString(s.to)||!S.isUndefined(s.select)&&!S.isBoolean(s.select)||!S.isUndefined(s.by)&&!S.isString(s.by)||!S.isUndefined(s.value)&&!S.isNumber(s.value))};o.metadata={description:"Move cursor to a logical position in the view",args:[{name:"Cursor move argument object",description:`Property-value pairs that can be passed through this argument:
					* 'to': A mandatory logical position value providing where to move the cursor.
						\`\`\`
						'left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine',
						'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter'
						'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter'
						'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside'
						\`\`\`
					* 'by': Unit to move. Default is computed based on 'to' value.
						\`\`\`
						'line', 'wrappedLine', 'character', 'halfLine'
						\`\`\`
					* 'value': Number of units to move. Default is '1'.
					* 'select': If 'true' makes the selection. Default is 'false'.
				`,constraint:P,schema:{type:"object",required:["to"],properties:{to:{type:"string",enum:["left","right","up","down","prevBlankLine","nextBlankLine","wrappedLineStart","wrappedLineEnd","wrappedLineColumnCenter","wrappedLineFirstNonWhitespaceCharacter","wrappedLineLastNonWhitespaceCharacter","viewPortTop","viewPortCenter","viewPortBottom","viewPortIfOutside"]},by:{type:"string",enum:["line","wrappedLine","character","halfLine"]},value:{type:"number",default:1},select:{type:"boolean",default:!1}}}}]},o.RawDirection={Left:"left",Right:"right",Up:"up",Down:"down",PrevBlankLine:"prevBlankLine",NextBlankLine:"nextBlankLine",WrappedLineStart:"wrappedLineStart",WrappedLineFirstNonWhitespaceCharacter:"wrappedLineFirstNonWhitespaceCharacter",WrappedLineColumnCenter:"wrappedLineColumnCenter",WrappedLineEnd:"wrappedLineEnd",WrappedLineLastNonWhitespaceCharacter:"wrappedLineLastNonWhitespaceCharacter",ViewPortTop:"viewPortTop",ViewPortCenter:"viewPortCenter",ViewPortBottom:"viewPortBottom",ViewPortIfOutside:"viewPortIfOutside"},o.RawUnit={Line:"line",WrappedLine:"wrappedLine",Character:"character",HalfLine:"halfLine"};function n(l){if(!l.to)return null;let s;switch(l.to){case o.RawDirection.Left:s=0;break;case o.RawDirection.Right:s=1;break;case o.RawDirection.Up:s=2;break;case o.RawDirection.Down:s=3;break;case o.RawDirection.PrevBlankLine:s=4;break;case o.RawDirection.NextBlankLine:s=5;break;case o.RawDirection.WrappedLineStart:s=6;break;case o.RawDirection.WrappedLineFirstNonWhitespaceCharacter:s=7;break;case o.RawDirection.WrappedLineColumnCenter:s=8;break;case o.RawDirection.WrappedLineEnd:s=9;break;case o.RawDirection.WrappedLineLastNonWhitespaceCharacter:s=10;break;case o.RawDirection.ViewPortTop:s=11;break;case o.RawDirection.ViewPortBottom:s=13;break;case o.RawDirection.ViewPortCenter:s=12;break;case o.RawDirection.ViewPortIfOutside:s=14;break;default:return null}let c=0;switch(l.by){case o.RawUnit.Line:c=1;break;case o.RawUnit.WrappedLine:c=2;break;case o.RawUnit.Character:c=3;break;case o.RawUnit.HalfLine:c=4;break}return{direction:s,unit:c,select:!!l.select,value:l.value||1}}o.parse=n;let r;(m=>(m[m.Left=0]="Left",m[m.Right=1]="Right",m[m.Up=2]="Up",m[m.Down=3]="Down",m[m.PrevBlankLine=4]="PrevBlankLine",m[m.NextBlankLine=5]="NextBlankLine",m[m.WrappedLineStart=6]="WrappedLineStart",m[m.WrappedLineFirstNonWhitespaceCharacter=7]="WrappedLineFirstNonWhitespaceCharacter",m[m.WrappedLineColumnCenter=8]="WrappedLineColumnCenter",m[m.WrappedLineEnd=9]="WrappedLineEnd",m[m.WrappedLineLastNonWhitespaceCharacter=10]="WrappedLineLastNonWhitespaceCharacter",m[m.ViewPortTop=11]="ViewPortTop",m[m.ViewPortCenter=12]="ViewPortCenter",m[m.ViewPortBottom=13]="ViewPortBottom",m[m.ViewPortIfOutside=14]="ViewPortIfOutside"))(r=o.Direction||={});let a;(L=>(L[L.None=0]="None",L[L.Line=1]="Line",L[L.WrappedLine=2]="WrappedLine",L[L.Character=3]="Character",L[L.HalfLine=4]="HalfLine"))(a=o.Unit||={})})(C||={});export{C as CursorMove,O as CursorMoveCommands};
