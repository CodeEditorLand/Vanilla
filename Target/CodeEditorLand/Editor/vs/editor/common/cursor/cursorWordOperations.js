import{CharCode as b}from"../../../base/common/charCode.js";import*as C from"../../../base/common/strings.js";import"../config/editorOptions.js";import{SelectionStartKind as I,SingleCursorState as R}from"../cursorCommon.js";import{DeleteOperations as S}from"./cursorDeleteOperations.js";import{WordCharacterClass as h,getMapForWordSeparators as P}from"../core/wordCharacterClassifier.js";import{Position as d}from"../core/position.js";import{Range as g}from"../core/range.js";import"../core/selection.js";import"../model.js";import"../core/wordHelper.js";import"../languages/languageConfiguration.js";var w=(e=>(e[e.None=0]="None",e[e.Regular=1]="Regular",e[e.Separator=2]="Separator",e))(w||{}),y=(t=>(t[t.WordStart=0]="WordStart",t[t.WordStartFast=1]="WordStartFast",t[t.WordEnd=2]="WordEnd",t[t.WordAccessibility=3]="WordAccessibility",t))(y||{});class u{static _createWord(r,n,e,t,o){return{start:t,end:o,wordType:n,nextCharClass:e}}static _createIntlWord(r,n){return{start:r.index,end:r.index+r.segment.length,wordType:1,nextCharClass:n}}static _findPreviousWordOnLine(r,n,e){const t=n.getLineContent(e.lineNumber);return this._doFindPreviousWordOnLine(t,r,e)}static _doFindPreviousWordOnLine(r,n,e){let t=0;const o=n.findPrevIntlWordBeforeOrAtOffset(r,e.column-2);for(let s=e.column-2;s>=0;s--){const l=r.charCodeAt(s),i=n.get(l);if(o&&s===o.index)return this._createIntlWord(o,i);if(i===h.Regular){if(t===2)return this._createWord(r,t,i,s+1,this._findEndOfWord(r,n,t,s+1));t=1}else if(i===h.WordSeparator){if(t===1)return this._createWord(r,t,i,s+1,this._findEndOfWord(r,n,t,s+1));t=2}else if(i===h.Whitespace&&t!==0)return this._createWord(r,t,i,s+1,this._findEndOfWord(r,n,t,s+1))}return t!==0?this._createWord(r,t,h.Whitespace,0,this._findEndOfWord(r,n,t,0)):null}static _findEndOfWord(r,n,e,t){const o=n.findNextIntlWordAtOrAfterOffset(r,t),s=r.length;for(let l=t;l<s;l++){const i=r.charCodeAt(l),a=n.get(i);if(o&&l===o.index+o.segment.length||a===h.Whitespace||e===1&&a===h.WordSeparator||e===2&&a===h.Regular)return l}return s}static _findNextWordOnLine(r,n,e){const t=n.getLineContent(e.lineNumber);return this._doFindNextWordOnLine(t,r,e)}static _doFindNextWordOnLine(r,n,e){let t=0;const o=r.length,s=n.findNextIntlWordAtOrAfterOffset(r,e.column-1);for(let l=e.column-1;l<o;l++){const i=r.charCodeAt(l),a=n.get(i);if(s&&l===s.index)return this._createIntlWord(s,a);if(a===h.Regular){if(t===2)return this._createWord(r,t,a,this._findStartOfWord(r,n,t,l-1),l);t=1}else if(a===h.WordSeparator){if(t===1)return this._createWord(r,t,a,this._findStartOfWord(r,n,t,l-1),l);t=2}else if(a===h.Whitespace&&t!==0)return this._createWord(r,t,a,this._findStartOfWord(r,n,t,l-1),l)}return t!==0?this._createWord(r,t,h.Whitespace,this._findStartOfWord(r,n,t,o-1),o):null}static _findStartOfWord(r,n,e,t){const o=n.findPrevIntlWordBeforeOrAtOffset(r,t);for(let s=t;s>=0;s--){const l=r.charCodeAt(s),i=n.get(l);if(o&&s===o.index)return s;if(i===h.Whitespace||e===1&&i===h.WordSeparator||e===2&&i===h.Regular)return s+1}return 0}static moveWordLeft(r,n,e,t,o){let s=e.lineNumber,l=e.column;l===1&&s>1&&(s=s-1,l=n.getLineMaxColumn(s));let i=u._findPreviousWordOnLine(r,n,new d(s,l));if(t===0)return new d(s,i?i.start+1:1);if(t===1)return!o&&i&&i.wordType===2&&i.end-i.start===1&&i.nextCharClass===h.Regular&&(i=u._findPreviousWordOnLine(r,n,new d(s,i.start+1))),new d(s,i?i.start+1:1);if(t===3){for(;i&&i.wordType===2;)i=u._findPreviousWordOnLine(r,n,new d(s,i.start+1));return new d(s,i?i.start+1:1)}return i&&l<=i.end+1&&(i=u._findPreviousWordOnLine(r,n,new d(s,i.start+1))),new d(s,i?i.end+1:1)}static _moveWordPartLeft(r,n){const e=n.lineNumber,t=r.getLineMaxColumn(e);if(n.column===1)return e>1?new d(e-1,r.getLineMaxColumn(e-1)):n;const o=r.getLineContent(e);for(let s=n.column-1;s>1;s--){const l=o.charCodeAt(s-2),i=o.charCodeAt(s-1);if(l===b.Underline&&i!==b.Underline)return new d(e,s);if(l===b.Dash&&i!==b.Dash)return new d(e,s);if((C.isLowerAsciiLetter(l)||C.isAsciiDigit(l))&&C.isUpperAsciiLetter(i))return new d(e,s);if(C.isUpperAsciiLetter(l)&&C.isUpperAsciiLetter(i)&&s+1<t){const a=o.charCodeAt(s);if(C.isLowerAsciiLetter(a)||C.isAsciiDigit(a))return new d(e,s)}}return new d(e,1)}static moveWordRight(r,n,e,t){let o=e.lineNumber,s=e.column,l=!1;s===n.getLineMaxColumn(o)&&o<n.getLineCount()&&(l=!0,o=o+1,s=1);let i=u._findNextWordOnLine(r,n,new d(o,s));if(t===2)i&&i.wordType===2&&i.end-i.start===1&&i.nextCharClass===h.Regular&&(i=u._findNextWordOnLine(r,n,new d(o,i.end+1))),i?s=i.end+1:s=n.getLineMaxColumn(o);else if(t===3){for(l&&(s=0);i&&(i.wordType===2||i.start+1<=s);)i=u._findNextWordOnLine(r,n,new d(o,i.end+1));i?s=i.start+1:s=n.getLineMaxColumn(o)}else i&&!l&&s>=i.start+1&&(i=u._findNextWordOnLine(r,n,new d(o,i.end+1))),i?s=i.start+1:s=n.getLineMaxColumn(o);return new d(o,s)}static _moveWordPartRight(r,n){const e=n.lineNumber,t=r.getLineMaxColumn(e);if(n.column===t)return e<r.getLineCount()?new d(e+1,1):n;const o=r.getLineContent(e);for(let s=n.column+1;s<t;s++){const l=o.charCodeAt(s-2),i=o.charCodeAt(s-1);if(l!==b.Underline&&i===b.Underline)return new d(e,s);if(l!==b.Dash&&i===b.Dash)return new d(e,s);if((C.isLowerAsciiLetter(l)||C.isAsciiDigit(l))&&C.isUpperAsciiLetter(i))return new d(e,s);if(C.isUpperAsciiLetter(l)&&C.isUpperAsciiLetter(i)&&s+1<t){const a=o.charCodeAt(s);if(C.isLowerAsciiLetter(a)||C.isAsciiDigit(a))return new d(e,s)}}return new d(e,t)}static _deleteWordLeftWhitespace(r,n){const e=r.getLineContent(n.lineNumber),t=n.column-2,o=C.lastNonWhitespaceIndex(e,t);return o+1<t?new g(n.lineNumber,o+2,n.lineNumber,n.column):null}static deleteWordLeft(r,n){const e=r.wordSeparators,t=r.model,o=r.selection,s=r.whitespaceHeuristics;if(!o.isEmpty())return o;if(S.isAutoClosingPairDelete(r.autoClosingDelete,r.autoClosingBrackets,r.autoClosingQuotes,r.autoClosingPairs.autoClosingPairsOpenByEnd,r.model,[r.selection],r.autoClosedCharacters)){const f=r.selection.getPosition();return new g(f.lineNumber,f.column-1,f.lineNumber,f.column+1)}const l=new d(o.positionLineNumber,o.positionColumn);let i=l.lineNumber,a=l.column;if(i===1&&a===1)return null;if(s){const f=this._deleteWordLeftWhitespace(t,l);if(f)return f}let m=u._findPreviousWordOnLine(e,t,l);return n===0?m?a=m.start+1:a>1?a=1:(i--,a=t.getLineMaxColumn(i)):(m&&a<=m.end+1&&(m=u._findPreviousWordOnLine(e,t,new d(i,m.start+1))),m?a=m.end+1:a>1?a=1:(i--,a=t.getLineMaxColumn(i))),new g(i,a,l.lineNumber,l.column)}static deleteInsideWord(r,n,e){if(!e.isEmpty())return e;const t=new d(e.positionLineNumber,e.positionColumn),o=this._deleteInsideWordWhitespace(n,t);return o||this._deleteInsideWordDetermineDeleteRange(r,n,t)}static _charAtIsWhitespace(r,n){const e=r.charCodeAt(n);return e===b.Space||e===b.Tab}static _deleteInsideWordWhitespace(r,n){const e=r.getLineContent(n.lineNumber),t=e.length;if(t===0)return null;let o=Math.max(n.column-2,0);if(!this._charAtIsWhitespace(e,o))return null;let s=Math.min(n.column-1,t-1);if(!this._charAtIsWhitespace(e,s))return null;for(;o>0&&this._charAtIsWhitespace(e,o-1);)o--;for(;s+1<t&&this._charAtIsWhitespace(e,s+1);)s++;return new g(n.lineNumber,o+1,n.lineNumber,s+2)}static _deleteInsideWordDetermineDeleteRange(r,n,e){const t=n.getLineContent(e.lineNumber),o=t.length;if(o===0)return e.lineNumber>1?new g(e.lineNumber-1,n.getLineMaxColumn(e.lineNumber-1),e.lineNumber,1):e.lineNumber<n.getLineCount()?new g(e.lineNumber,1,e.lineNumber+1,1):new g(e.lineNumber,1,e.lineNumber,1);const s=f=>f.start+1<=e.column&&e.column<=f.end+1,l=(f,c)=>(f=Math.min(f,e.column),c=Math.max(c,e.column),new g(e.lineNumber,f,e.lineNumber,c)),i=f=>{let c=f.start+1,W=f.end+1,p=!1;for(;W-1<o&&this._charAtIsWhitespace(t,W-1);)p=!0,W++;if(!p)for(;c>1&&this._charAtIsWhitespace(t,c-2);)c--;return l(c,W)},a=u._findPreviousWordOnLine(r,n,e);if(a&&s(a))return i(a);const m=u._findNextWordOnLine(r,n,e);return m&&s(m)?i(m):a&&m?l(a.end+1,m.start+1):a?l(a.start+1,a.end+1):m?l(m.start+1,m.end+1):l(1,o+1)}static _deleteWordPartLeft(r,n){if(!n.isEmpty())return n;const e=n.getPosition(),t=u._moveWordPartLeft(r,e);return new g(e.lineNumber,e.column,t.lineNumber,t.column)}static _findFirstNonWhitespaceChar(r,n){const e=r.length;for(let t=n;t<e;t++){const o=r.charAt(t);if(o!==" "&&o!=="	")return t}return e}static _deleteWordRightWhitespace(r,n){const e=r.getLineContent(n.lineNumber),t=n.column-1,o=this._findFirstNonWhitespaceChar(e,t);return t+1<o?new g(n.lineNumber,n.column,n.lineNumber,o+1):null}static deleteWordRight(r,n){const e=r.wordSeparators,t=r.model,o=r.selection,s=r.whitespaceHeuristics;if(!o.isEmpty())return o;const l=new d(o.positionLineNumber,o.positionColumn);let i=l.lineNumber,a=l.column;const m=t.getLineCount(),f=t.getLineMaxColumn(i);if(i===m&&a===f)return null;if(s){const W=this._deleteWordRightWhitespace(t,l);if(W)return W}let c=u._findNextWordOnLine(e,t,l);return n===2?c?a=c.end+1:a<f||i===m?a=f:(i++,c=u._findNextWordOnLine(e,t,new d(i,1)),c?a=c.start+1:a=t.getLineMaxColumn(i)):(c&&a>=c.start+1&&(c=u._findNextWordOnLine(e,t,new d(i,c.end+1))),c?a=c.start+1:a<f||i===m?a=f:(i++,c=u._findNextWordOnLine(e,t,new d(i,1)),c?a=c.start+1:a=t.getLineMaxColumn(i))),new g(i,a,l.lineNumber,l.column)}static _deleteWordPartRight(r,n){if(!n.isEmpty())return n;const e=n.getPosition(),t=u._moveWordPartRight(r,e);return new g(e.lineNumber,e.column,t.lineNumber,t.column)}static _createWordAtPosition(r,n,e){const t=new g(n,e.start+1,n,e.end+1);return{word:r.getValueInRange(t),startColumn:t.startColumn,endColumn:t.endColumn}}static getWordAtPosition(r,n,e,t){const o=P(n,e),s=u._findPreviousWordOnLine(o,r,t);if(s&&s.wordType===1&&s.start<=t.column-1&&t.column-1<=s.end)return u._createWordAtPosition(r,t.lineNumber,s);const l=u._findNextWordOnLine(o,r,t);return l&&l.wordType===1&&l.start<=t.column-1&&t.column-1<=l.end?u._createWordAtPosition(r,t.lineNumber,l):null}static word(r,n,e,t,o){const s=P(r.wordSeparators,r.wordSegmenterLocales),l=u._findPreviousWordOnLine(s,n,o),i=u._findNextWordOnLine(s,n,o);if(!t){let W,p;return l&&l.wordType===1&&l.start<=o.column-1&&o.column-1<=l.end?(W=l.start+1,p=l.end+1):i&&i.wordType===1&&i.start<=o.column-1&&o.column-1<=i.end?(W=i.start+1,p=i.end+1):(l?W=l.end+1:W=1,i?p=i.start+1:p=n.getLineMaxColumn(o.lineNumber)),new R(new g(o.lineNumber,W,o.lineNumber,p),I.Word,0,new d(o.lineNumber,p),0)}let a,m;l&&l.wordType===1&&l.start<o.column-1&&o.column-1<l.end?(a=l.start+1,m=l.end+1):i&&i.wordType===1&&i.start<o.column-1&&o.column-1<i.end?(a=i.start+1,m=i.end+1):(a=o.column,m=o.column);const f=o.lineNumber;let c;if(e.selectionStart.containsPosition(o))c=e.selectionStart.endColumn;else if(o.isBeforeOrEqual(e.selectionStart.getStartPosition())){c=a;const W=new d(f,c);e.selectionStart.containsPosition(W)&&(c=e.selectionStart.endColumn)}else{c=m;const W=new d(f,c);e.selectionStart.containsPosition(W)&&(c=e.selectionStart.startColumn)}return e.move(!0,f,c,0)}}class J extends u{static deleteWordPartLeft(r){const n=L([u.deleteWordLeft(r,0),u.deleteWordLeft(r,2),u._deleteWordPartLeft(r.model,r.selection)]);return n.sort(g.compareRangesUsingEnds),n[2]}static deleteWordPartRight(r){const n=L([u.deleteWordRight(r,0),u.deleteWordRight(r,2),u._deleteWordPartRight(r.model,r.selection)]);return n.sort(g.compareRangesUsingStarts),n[0]}static moveWordPartLeft(r,n,e,t){const o=L([u.moveWordLeft(r,n,e,0,t),u.moveWordLeft(r,n,e,2,t),u._moveWordPartLeft(n,e)]);return o.sort(d.compare),o[2]}static moveWordPartRight(r,n,e){const t=L([u.moveWordRight(r,n,e,0),u.moveWordRight(r,n,e,2),u._moveWordPartRight(n,e)]);return t.sort(d.compare),t[0]}}function L(N){return N.filter(r=>!!r)}export{y as WordNavigationType,u as WordOperations,J as WordPartOperations};
