import*as y from"../../../base/common/strings.js";import{ReplaceCommand as d}from"../commands/replaceCommand.js";import{CursorColumns as I}from"../core/cursorColumns.js";import{Position as E}from"../core/position.js";import{Range as p}from"../core/range.js";import{EditOperationResult as R,EditOperationType as N,isQuote as M}from"../cursorCommon.js";import{MoveOperations as w}from"./cursorMoveOperations.js";class S{static deleteRight(r,t,n,e){const a=[];let o=r!==N.DeletingRight;for(let i=0,s=e.length;i<s;i++){const l=e[i];let u=l;if(u.isEmpty()){const m=l.getPosition(),f=w.right(t,n,m);u=new p(f.lineNumber,f.column,m.lineNumber,m.column)}if(u.isEmpty()){a[i]=null;continue}u.startLineNumber!==u.endLineNumber&&(o=!0),a[i]=new d(u,"")}return[o,a]}static isAutoClosingPairDelete(r,t,n,e,a,o,i){if(t==="never"&&n==="never"||r==="never")return!1;for(let s=0,l=o.length;s<l;s++){const u=o[s],m=u.getPosition();if(!u.isEmpty())return!1;const f=a.getLineContent(m.lineNumber);if(m.column<2||m.column>=f.length+1)return!1;const c=f.charAt(m.column-2),C=e.get(c);if(!C)return!1;if(M(c)){if(n==="never")return!1}else if(t==="never")return!1;const A=f.charAt(m.column-1);let h=!1;for(const g of C)g.open===c&&g.close===A&&(h=!0);if(!h)return!1;if(r==="auto"){let g=!1;for(let b=0,L=i.length;b<L;b++){const P=i[b];if(m.lineNumber===P.startLineNumber&&m.column===P.startColumn){g=!0;break}}if(!g)return!1}}return!0}static _runAutoClosingPairDelete(r,t,n){const e=[];for(let a=0,o=n.length;a<o;a++){const i=n[a].getPosition(),s=new p(i.lineNumber,i.column-1,i.lineNumber,i.column+1);e[a]=new d(s,"")}return[!0,e]}static deleteLeft(r,t,n,e,a){if(this.isAutoClosingPairDelete(t.autoClosingDelete,t.autoClosingBrackets,t.autoClosingQuotes,t.autoClosingPairs.autoClosingPairsOpenByEnd,n,e,a))return this._runAutoClosingPairDelete(t,n,e);const o=[];let i=r!==N.DeletingLeft;for(let s=0,l=e.length;s<l;s++){const u=S.getDeleteRange(e[s],n,t);if(u.isEmpty()){o[s]=null;continue}u.startLineNumber!==u.endLineNumber&&(i=!0),o[s]=new d(u,"")}return[i,o]}static getDeleteRange(r,t,n){if(!r.isEmpty())return r;const e=r.getPosition();if(n.useTabStops&&e.column>1){const a=t.getLineContent(e.lineNumber),o=y.firstNonWhitespaceIndex(a),i=o===-1?a.length+1:o+1;if(e.column<=i){const s=n.visibleColumnFromColumn(t,e),l=I.prevIndentTabStop(s,n.indentSize),u=n.columnFromVisibleColumn(t,e.lineNumber,l);return new p(e.lineNumber,u,e.lineNumber,e.column)}}return p.fromPositions(S.getPositionAfterDeleteLeft(e,t),e)}static getPositionAfterDeleteLeft(r,t){if(r.column>1){const n=y.getLeftDeleteOffset(r.column-1,t.getLineContent(r.lineNumber));return r.with(void 0,n+1)}else if(r.lineNumber>1){const n=r.lineNumber-1;return new E(n,t.getLineMaxColumn(n))}else return r}static cut(r,t,n){const e=[];let a=null;n.sort((o,i)=>E.compare(o.getStartPosition(),i.getEndPosition()));for(let o=0,i=n.length;o<i;o++){const s=n[o];if(s.isEmpty())if(r.emptySelectionClipboard){const l=s.getPosition();let u,m,f,c;l.lineNumber<t.getLineCount()?(u=l.lineNumber,m=1,f=l.lineNumber+1,c=1):l.lineNumber>1&&a?.endLineNumber!==l.lineNumber?(u=l.lineNumber-1,m=t.getLineMaxColumn(l.lineNumber-1),f=l.lineNumber,c=t.getLineMaxColumn(l.lineNumber)):(u=l.lineNumber,m=1,f=l.lineNumber,c=t.getLineMaxColumn(l.lineNumber));const C=new p(u,m,f,c);a=C,C.isEmpty()?e[o]=null:e[o]=new d(C,"")}else e[o]=null;else e[o]=new d(s,"")}return new R(N.Other,e,{shouldPushStackElementBefore:!0,shouldPushStackElementAfter:!0})}}export{S as DeleteOperations};
