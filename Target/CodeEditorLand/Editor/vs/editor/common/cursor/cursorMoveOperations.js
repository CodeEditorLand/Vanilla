import*as f from"../../../base/common/strings.js";import{Constants as d}from"../../../base/common/uint.js";import{CursorColumns as g}from"../core/cursorColumns.js";import{Position as a}from"../core/position.js";import{Range as p}from"../core/range.js";import{SelectionStartKind as L,SingleCursorState as P}from"../cursorCommon.js";import{PositionAffinity as b}from"../model.js";import{AtomicTabMoveOperations as h,Direction as w}from"./cursorAtomicMoveOperations.js";class S{_cursorPositionBrand=void 0;lineNumber;column;leftoverVisibleColumns;constructor(t,n,e){this.lineNumber=t,this.column=n,this.leftoverVisibleColumns=e}}class s{static leftPosition(t,n){if(n.column>t.getLineMinColumn(n.lineNumber))return n.delta(void 0,-f.prevCharLength(t.getLineContent(n.lineNumber),n.column-1));if(n.lineNumber>1){const e=n.lineNumber-1;return new a(e,t.getLineMaxColumn(e))}else return n}static leftPositionAtomicSoftTabs(t,n,e){if(n.column<=t.getLineIndentColumn(n.lineNumber)){const i=t.getLineMinColumn(n.lineNumber),r=t.getLineContent(n.lineNumber),o=h.atomicPosition(r,n.column-1,e,w.Left);if(o!==-1&&o+1>=i)return new a(n.lineNumber,o+1)}return this.leftPosition(t,n)}static left(t,n,e){const i=t.stickyTabStops?s.leftPositionAtomicSoftTabs(n,e,t.tabSize):s.leftPosition(n,e);return new S(i.lineNumber,i.column,0)}static moveLeft(t,n,e,i,r){let o,u;if(e.hasSelection()&&!i)o=e.selection.startLineNumber,u=e.selection.startColumn;else{const l=e.position.delta(void 0,-(r-1)),m=n.normalizePosition(s.clipPositionColumn(l,n),b.Left),C=s.left(t,n,m);o=C.lineNumber,u=C.column}return e.move(i,o,u,0)}static clipPositionColumn(t,n){return new a(t.lineNumber,s.clipRange(t.column,n.getLineMinColumn(t.lineNumber),n.getLineMaxColumn(t.lineNumber)))}static clipRange(t,n,e){return t<n?n:t>e?e:t}static rightPosition(t,n,e){return e<t.getLineMaxColumn(n)?e=e+f.nextCharLength(t.getLineContent(n),e-1):n<t.getLineCount()&&(n=n+1,e=t.getLineMinColumn(n)),new a(n,e)}static rightPositionAtomicSoftTabs(t,n,e,i,r){if(e<t.getLineIndentColumn(n)){const o=t.getLineContent(n),u=h.atomicPosition(o,e-1,i,w.Right);if(u!==-1)return new a(n,u+1)}return this.rightPosition(t,n,e)}static right(t,n,e){const i=t.stickyTabStops?s.rightPositionAtomicSoftTabs(n,e.lineNumber,e.column,t.tabSize,t.indentSize):s.rightPosition(n,e.lineNumber,e.column);return new S(i.lineNumber,i.column,0)}static moveRight(t,n,e,i,r){let o,u;if(e.hasSelection()&&!i)o=e.selection.endLineNumber,u=e.selection.endColumn;else{const l=e.position.delta(void 0,r-1),m=n.normalizePosition(s.clipPositionColumn(l,n),b.Right),C=s.right(t,n,m);o=C.lineNumber,u=C.column}return e.move(i,o,u,0)}static vertical(t,n,e,i,r,o,u,l){const m=g.visibleColumnFromColumn(n.getLineContent(e),i,t.tabSize)+r,C=n.getLineCount(),N=e===1&&i===1,I=e===C&&i===n.getLineMaxColumn(e),v=o<e?N:I;if(e=o,e<1?(e=1,u?i=n.getLineMinColumn(e):i=Math.min(n.getLineMaxColumn(e),i)):e>C?(e=C,u?i=n.getLineMaxColumn(e):i=Math.min(n.getLineMaxColumn(e),i)):i=t.columnFromVisibleColumn(n,e,m),v?r=0:r=m-g.visibleColumnFromColumn(n.getLineContent(e),i,t.tabSize),l!==void 0){const M=new a(e,i),c=n.normalizePosition(M,l);r=r+(i-c.column),e=c.lineNumber,i=c.column}return new S(e,i,r)}static down(t,n,e,i,r,o,u){return this.vertical(t,n,e,i,r,e+o,u,b.RightOfInjectedText)}static moveDown(t,n,e,i,r){let o,u;e.hasSelection()&&!i?(o=e.selection.endLineNumber,u=e.selection.endColumn):(o=e.position.lineNumber,u=e.position.column);let l=0,m;do if(m=s.down(t,n,o+l,u,e.leftoverVisibleColumns,r,!0),n.normalizePosition(new a(m.lineNumber,m.column),b.None).lineNumber>o)break;while(l++<10&&o+l<n.getLineCount());return e.move(i,m.lineNumber,m.column,m.leftoverVisibleColumns)}static translateDown(t,n,e){const i=e.selection,r=s.down(t,n,i.selectionStartLineNumber,i.selectionStartColumn,e.selectionStartLeftoverVisibleColumns,1,!1),o=s.down(t,n,i.positionLineNumber,i.positionColumn,e.leftoverVisibleColumns,1,!1);return new P(new p(r.lineNumber,r.column,r.lineNumber,r.column),L.Simple,r.leftoverVisibleColumns,new a(o.lineNumber,o.column),o.leftoverVisibleColumns)}static up(t,n,e,i,r,o,u){return this.vertical(t,n,e,i,r,e-o,u,b.LeftOfInjectedText)}static moveUp(t,n,e,i,r){let o,u;e.hasSelection()&&!i?(o=e.selection.startLineNumber,u=e.selection.startColumn):(o=e.position.lineNumber,u=e.position.column);const l=s.up(t,n,o,u,e.leftoverVisibleColumns,r,!0);return e.move(i,l.lineNumber,l.column,l.leftoverVisibleColumns)}static translateUp(t,n,e){const i=e.selection,r=s.up(t,n,i.selectionStartLineNumber,i.selectionStartColumn,e.selectionStartLeftoverVisibleColumns,1,!1),o=s.up(t,n,i.positionLineNumber,i.positionColumn,e.leftoverVisibleColumns,1,!1);return new P(new p(r.lineNumber,r.column,r.lineNumber,r.column),L.Simple,r.leftoverVisibleColumns,new a(o.lineNumber,o.column),o.leftoverVisibleColumns)}static _isBlankLine(t,n){return t.getLineFirstNonWhitespaceColumn(n)===0}static moveToPrevBlankLine(t,n,e,i){let r=e.position.lineNumber;for(;r>1&&this._isBlankLine(n,r);)r--;for(;r>1&&!this._isBlankLine(n,r);)r--;return e.move(i,r,n.getLineMinColumn(r),0)}static moveToNextBlankLine(t,n,e,i){const r=n.getLineCount();let o=e.position.lineNumber;for(;o<r&&this._isBlankLine(n,o);)o++;for(;o<r&&!this._isBlankLine(n,o);)o++;return e.move(i,o,n.getLineMinColumn(o),0)}static moveToBeginningOfLine(t,n,e,i){const r=e.position.lineNumber,o=n.getLineMinColumn(r),u=n.getLineFirstNonWhitespaceColumn(r)||o;let l;return e.position.column===u?l=o:l=u,e.move(i,r,l,0)}static moveToEndOfLine(t,n,e,i,r){const o=e.position.lineNumber,u=n.getLineMaxColumn(o);return e.move(i,o,u,r?d.MAX_SAFE_SMALL_INTEGER-u:0)}static moveToBeginningOfBuffer(t,n,e,i){return e.move(i,1,1,0)}static moveToEndOfBuffer(t,n,e,i){const r=n.getLineCount(),o=n.getLineMaxColumn(r);return e.move(i,r,o,0)}}export{S as CursorPosition,s as MoveOperations};
