import*as f from"../../../../vs/base/common/strings.js";import{Constants as d}from"../../../../vs/base/common/uint.js";import{CursorColumns as g}from"../../../../vs/editor/common/core/cursorColumns.js";import{Position as a}from"../../../../vs/editor/common/core/position.js";import{Range as p}from"../../../../vs/editor/common/core/range.js";import{AtomicTabMoveOperations as L,Direction as P}from"../../../../vs/editor/common/cursor/cursorAtomicMoveOperations.js";import{SelectionStartKind as h,SingleCursorState as w}from"../../../../vs/editor/common/cursorCommon.js";import{PositionAffinity as b}from"../../../../vs/editor/common/model.js";class S{_cursorPositionBrand=void 0;lineNumber;column;leftoverVisibleColumns;constructor(i,n,e){this.lineNumber=i,this.column=n,this.leftoverVisibleColumns=e}}class s{static leftPosition(i,n){if(n.column>i.getLineMinColumn(n.lineNumber))return n.delta(void 0,-f.prevCharLength(i.getLineContent(n.lineNumber),n.column-1));if(n.lineNumber>1){const e=n.lineNumber-1;return new a(e,i.getLineMaxColumn(e))}else return n}static leftPositionAtomicSoftTabs(i,n,e){if(n.column<=i.getLineIndentColumn(n.lineNumber)){const t=i.getLineMinColumn(n.lineNumber),r=i.getLineContent(n.lineNumber),o=L.atomicPosition(r,n.column-1,e,P.Left);if(o!==-1&&o+1>=t)return new a(n.lineNumber,o+1)}return this.leftPosition(i,n)}static left(i,n,e){const t=i.stickyTabStops?s.leftPositionAtomicSoftTabs(n,e,i.tabSize):s.leftPosition(n,e);return new S(t.lineNumber,t.column,0)}static moveLeft(i,n,e,t,r){let o,u;if(e.hasSelection()&&!t)o=e.selection.startLineNumber,u=e.selection.startColumn;else{const l=e.position.delta(void 0,-(r-1)),m=n.normalizePosition(s.clipPositionColumn(l,n),b.Left),C=s.left(i,n,m);o=C.lineNumber,u=C.column}return e.move(t,o,u,0)}static clipPositionColumn(i,n){return new a(i.lineNumber,s.clipRange(i.column,n.getLineMinColumn(i.lineNumber),n.getLineMaxColumn(i.lineNumber)))}static clipRange(i,n,e){return i<n?n:i>e?e:i}static rightPosition(i,n,e){return e<i.getLineMaxColumn(n)?e=e+f.nextCharLength(i.getLineContent(n),e-1):n<i.getLineCount()&&(n=n+1,e=i.getLineMinColumn(n)),new a(n,e)}static rightPositionAtomicSoftTabs(i,n,e,t,r){if(e<i.getLineIndentColumn(n)){const o=i.getLineContent(n),u=L.atomicPosition(o,e-1,t,P.Right);if(u!==-1)return new a(n,u+1)}return this.rightPosition(i,n,e)}static right(i,n,e){const t=i.stickyTabStops?s.rightPositionAtomicSoftTabs(n,e.lineNumber,e.column,i.tabSize,i.indentSize):s.rightPosition(n,e.lineNumber,e.column);return new S(t.lineNumber,t.column,0)}static moveRight(i,n,e,t,r){let o,u;if(e.hasSelection()&&!t)o=e.selection.endLineNumber,u=e.selection.endColumn;else{const l=e.position.delta(void 0,r-1),m=n.normalizePosition(s.clipPositionColumn(l,n),b.Right),C=s.right(i,n,m);o=C.lineNumber,u=C.column}return e.move(t,o,u,0)}static vertical(i,n,e,t,r,o,u,l){const m=g.visibleColumnFromColumn(n.getLineContent(e),t,i.tabSize)+r,C=n.getLineCount(),N=e===1&&t===1,I=e===C&&t===n.getLineMaxColumn(e),v=o<e?N:I;if(e=o,e<1?(e=1,u?t=n.getLineMinColumn(e):t=Math.min(n.getLineMaxColumn(e),t)):e>C?(e=C,u?t=n.getLineMaxColumn(e):t=Math.min(n.getLineMaxColumn(e),t)):t=i.columnFromVisibleColumn(n,e,m),v?r=0:r=m-g.visibleColumnFromColumn(n.getLineContent(e),t,i.tabSize),l!==void 0){const M=new a(e,t),c=n.normalizePosition(M,l);r=r+(t-c.column),e=c.lineNumber,t=c.column}return new S(e,t,r)}static down(i,n,e,t,r,o,u){return this.vertical(i,n,e,t,r,e+o,u,b.RightOfInjectedText)}static moveDown(i,n,e,t,r){let o,u;e.hasSelection()&&!t?(o=e.selection.endLineNumber,u=e.selection.endColumn):(o=e.position.lineNumber,u=e.position.column);let l=0,m;do if(m=s.down(i,n,o+l,u,e.leftoverVisibleColumns,r,!0),n.normalizePosition(new a(m.lineNumber,m.column),b.None).lineNumber>o)break;while(l++<10&&o+l<n.getLineCount());return e.move(t,m.lineNumber,m.column,m.leftoverVisibleColumns)}static translateDown(i,n,e){const t=e.selection,r=s.down(i,n,t.selectionStartLineNumber,t.selectionStartColumn,e.selectionStartLeftoverVisibleColumns,1,!1),o=s.down(i,n,t.positionLineNumber,t.positionColumn,e.leftoverVisibleColumns,1,!1);return new w(new p(r.lineNumber,r.column,r.lineNumber,r.column),h.Simple,r.leftoverVisibleColumns,new a(o.lineNumber,o.column),o.leftoverVisibleColumns)}static up(i,n,e,t,r,o,u){return this.vertical(i,n,e,t,r,e-o,u,b.LeftOfInjectedText)}static moveUp(i,n,e,t,r){let o,u;e.hasSelection()&&!t?(o=e.selection.startLineNumber,u=e.selection.startColumn):(o=e.position.lineNumber,u=e.position.column);const l=s.up(i,n,o,u,e.leftoverVisibleColumns,r,!0);return e.move(t,l.lineNumber,l.column,l.leftoverVisibleColumns)}static translateUp(i,n,e){const t=e.selection,r=s.up(i,n,t.selectionStartLineNumber,t.selectionStartColumn,e.selectionStartLeftoverVisibleColumns,1,!1),o=s.up(i,n,t.positionLineNumber,t.positionColumn,e.leftoverVisibleColumns,1,!1);return new w(new p(r.lineNumber,r.column,r.lineNumber,r.column),h.Simple,r.leftoverVisibleColumns,new a(o.lineNumber,o.column),o.leftoverVisibleColumns)}static _isBlankLine(i,n){return i.getLineFirstNonWhitespaceColumn(n)===0}static moveToPrevBlankLine(i,n,e,t){let r=e.position.lineNumber;for(;r>1&&this._isBlankLine(n,r);)r--;for(;r>1&&!this._isBlankLine(n,r);)r--;return e.move(t,r,n.getLineMinColumn(r),0)}static moveToNextBlankLine(i,n,e,t){const r=n.getLineCount();let o=e.position.lineNumber;for(;o<r&&this._isBlankLine(n,o);)o++;for(;o<r&&!this._isBlankLine(n,o);)o++;return e.move(t,o,n.getLineMinColumn(o),0)}static moveToBeginningOfLine(i,n,e,t){const r=e.position.lineNumber,o=n.getLineMinColumn(r),u=n.getLineFirstNonWhitespaceColumn(r)||o;let l;return e.position.column===u?l=o:l=u,e.move(t,r,l,0)}static moveToEndOfLine(i,n,e,t,r){const o=e.position.lineNumber,u=n.getLineMaxColumn(o);return e.move(t,o,u,r?d.MAX_SAFE_SMALL_INTEGER-u:0)}static moveToBeginningOfBuffer(i,n,e,t){return e.move(t,1,1,0)}static moveToEndOfBuffer(i,n,e,t){const r=n.getLineCount(),o=n.getLineMaxColumn(r);return e.move(t,r,o,0)}}export{S as CursorPosition,s as MoveOperations};
