{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/cursor/cursorCollection.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { compareBy } from '../../../base/common/arrays.js';\nimport { findLastMax, findFirstMin } from '../../../base/common/arraysFind.js';\nimport { CursorState, PartialCursorState } from '../cursorCommon.js';\nimport { CursorContext } from './cursorContext.js';\nimport { Cursor } from './oneCursor.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { ISelection, Selection } from '../core/selection.js';\n\nexport class CursorCollection {\n\n\tprivate context: CursorContext;\n\n\t/**\n\t * `cursors[0]` is the primary cursor, thus `cursors.length >= 1` is always true.\n\t * `cursors.slice(1)` are secondary cursors.\n\t*/\n\tprivate cursors: Cursor[];\n\n\t// An index which identifies the last cursor that was added / moved (think Ctrl+drag)\n\t// This index refers to `cursors.slice(1)`, i.e. after removing the primary cursor.\n\tprivate lastAddedCursorIndex: number;\n\n\tconstructor(context: CursorContext) {\n\t\tthis.context = context;\n\t\tthis.cursors = [new Cursor(context)];\n\t\tthis.lastAddedCursorIndex = 0;\n\t}\n\n\tpublic dispose(): void {\n\t\tfor (const cursor of this.cursors) {\n\t\t\tcursor.dispose(this.context);\n\t\t}\n\t}\n\n\tpublic startTrackingSelections(): void {\n\t\tfor (const cursor of this.cursors) {\n\t\t\tcursor.startTrackingSelection(this.context);\n\t\t}\n\t}\n\n\tpublic stopTrackingSelections(): void {\n\t\tfor (const cursor of this.cursors) {\n\t\t\tcursor.stopTrackingSelection(this.context);\n\t\t}\n\t}\n\n\tpublic updateContext(context: CursorContext): void {\n\t\tthis.context = context;\n\t}\n\n\tpublic ensureValidState(): void {\n\t\tfor (const cursor of this.cursors) {\n\t\t\tcursor.ensureValidState(this.context);\n\t\t}\n\t}\n\n\tpublic readSelectionFromMarkers(): Selection[] {\n\t\treturn this.cursors.map(c => c.readSelectionFromMarkers(this.context));\n\t}\n\n\tpublic getAll(): CursorState[] {\n\t\treturn this.cursors.map(c => c.asCursorState());\n\t}\n\n\tpublic getViewPositions(): Position[] {\n\t\treturn this.cursors.map(c => c.viewState.position);\n\t}\n\n\tpublic getTopMostViewPosition(): Position {\n\t\treturn findFirstMin(\n\t\t\tthis.cursors,\n\t\t\tcompareBy(c => c.viewState.position, Position.compare)\n\t\t)!.viewState.position;\n\t}\n\n\tpublic getBottomMostViewPosition(): Position {\n\t\treturn findLastMax(\n\t\t\tthis.cursors,\n\t\t\tcompareBy(c => c.viewState.position, Position.compare)\n\t\t)!.viewState.position;\n\t}\n\n\tpublic getSelections(): Selection[] {\n\t\treturn this.cursors.map(c => c.modelState.selection);\n\t}\n\n\tpublic getViewSelections(): Selection[] {\n\t\treturn this.cursors.map(c => c.viewState.selection);\n\t}\n\n\tpublic setSelections(selections: ISelection[]): void {\n\t\tthis.setStates(CursorState.fromModelSelections(selections));\n\t}\n\n\tpublic getPrimaryCursor(): CursorState {\n\t\treturn this.cursors[0].asCursorState();\n\t}\n\n\tpublic setStates(states: PartialCursorState[] | null): void {\n\t\tif (states === null) {\n\t\t\treturn;\n\t\t}\n\t\tthis.cursors[0].setState(this.context, states[0].modelState, states[0].viewState);\n\t\tthis._setSecondaryStates(states.slice(1));\n\t}\n\n\t/**\n\t * Creates or disposes secondary cursors as necessary to match the number of `secondarySelections`.\n\t */\n\tprivate _setSecondaryStates(secondaryStates: PartialCursorState[]): void {\n\t\tconst secondaryCursorsLength = this.cursors.length - 1;\n\t\tconst secondaryStatesLength = secondaryStates.length;\n\n\t\tif (secondaryCursorsLength < secondaryStatesLength) {\n\t\t\tconst createCnt = secondaryStatesLength - secondaryCursorsLength;\n\t\t\tfor (let i = 0; i < createCnt; i++) {\n\t\t\t\tthis._addSecondaryCursor();\n\t\t\t}\n\t\t} else if (secondaryCursorsLength > secondaryStatesLength) {\n\t\t\tconst removeCnt = secondaryCursorsLength - secondaryStatesLength;\n\t\t\tfor (let i = 0; i < removeCnt; i++) {\n\t\t\t\tthis._removeSecondaryCursor(this.cursors.length - 2);\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < secondaryStatesLength; i++) {\n\t\t\tthis.cursors[i + 1].setState(this.context, secondaryStates[i].modelState, secondaryStates[i].viewState);\n\t\t}\n\t}\n\n\tpublic killSecondaryCursors(): void {\n\t\tthis._setSecondaryStates([]);\n\t}\n\n\tprivate _addSecondaryCursor(): void {\n\t\tthis.cursors.push(new Cursor(this.context));\n\t\tthis.lastAddedCursorIndex = this.cursors.length - 1;\n\t}\n\n\tpublic getLastAddedCursorIndex(): number {\n\t\tif (this.cursors.length === 1 || this.lastAddedCursorIndex === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this.lastAddedCursorIndex;\n\t}\n\n\tprivate _removeSecondaryCursor(removeIndex: number): void {\n\t\tif (this.lastAddedCursorIndex >= removeIndex + 1) {\n\t\t\tthis.lastAddedCursorIndex--;\n\t\t}\n\t\tthis.cursors[removeIndex + 1].dispose(this.context);\n\t\tthis.cursors.splice(removeIndex + 1, 1);\n\t}\n\n\tpublic normalize(): void {\n\t\tif (this.cursors.length === 1) {\n\t\t\treturn;\n\t\t}\n\t\tconst cursors = this.cursors.slice(0);\n\n\t\tinterface SortedCursor {\n\t\t\tindex: number;\n\t\t\tselection: Selection;\n\t\t}\n\t\tconst sortedCursors: SortedCursor[] = [];\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tsortedCursors.push({\n\t\t\t\tindex: i,\n\t\t\t\tselection: cursors[i].modelState.selection,\n\t\t\t});\n\t\t}\n\n\t\tsortedCursors.sort(compareBy(s => s.selection, Range.compareRangesUsingStarts));\n\n\t\tfor (let sortedCursorIndex = 0; sortedCursorIndex < sortedCursors.length - 1; sortedCursorIndex++) {\n\t\t\tconst current = sortedCursors[sortedCursorIndex];\n\t\t\tconst next = sortedCursors[sortedCursorIndex + 1];\n\n\t\t\tconst currentSelection = current.selection;\n\t\t\tconst nextSelection = next.selection;\n\n\t\t\tif (!this.context.cursorConfig.multiCursorMergeOverlapping) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet shouldMergeCursors: boolean;\n\t\t\tif (nextSelection.isEmpty() || currentSelection.isEmpty()) {\n\t\t\t\t// Merge touching cursors if one of them is collapsed\n\t\t\t\tshouldMergeCursors = nextSelection.getStartPosition().isBeforeOrEqual(currentSelection.getEndPosition());\n\t\t\t} else {\n\t\t\t\t// Merge only overlapping cursors (i.e. allow touching ranges)\n\t\t\t\tshouldMergeCursors = nextSelection.getStartPosition().isBefore(currentSelection.getEndPosition());\n\t\t\t}\n\n\t\t\tif (shouldMergeCursors) {\n\t\t\t\tconst winnerSortedCursorIndex = current.index < next.index ? sortedCursorIndex : sortedCursorIndex + 1;\n\t\t\t\tconst looserSortedCursorIndex = current.index < next.index ? sortedCursorIndex + 1 : sortedCursorIndex;\n\n\t\t\t\tconst looserIndex = sortedCursors[looserSortedCursorIndex].index;\n\t\t\t\tconst winnerIndex = sortedCursors[winnerSortedCursorIndex].index;\n\n\t\t\t\tconst looserSelection = sortedCursors[looserSortedCursorIndex].selection;\n\t\t\t\tconst winnerSelection = sortedCursors[winnerSortedCursorIndex].selection;\n\n\t\t\t\tif (!looserSelection.equalsSelection(winnerSelection)) {\n\t\t\t\t\tconst resultingRange = looserSelection.plusRange(winnerSelection);\n\t\t\t\t\tconst looserSelectionIsLTR = (looserSelection.selectionStartLineNumber === looserSelection.startLineNumber && looserSelection.selectionStartColumn === looserSelection.startColumn);\n\t\t\t\t\tconst winnerSelectionIsLTR = (winnerSelection.selectionStartLineNumber === winnerSelection.startLineNumber && winnerSelection.selectionStartColumn === winnerSelection.startColumn);\n\n\t\t\t\t\t// Give more importance to the last added cursor (think Ctrl-dragging + hitting another cursor)\n\t\t\t\t\tlet resultingSelectionIsLTR: boolean;\n\t\t\t\t\tif (looserIndex === this.lastAddedCursorIndex) {\n\t\t\t\t\t\tresultingSelectionIsLTR = looserSelectionIsLTR;\n\t\t\t\t\t\tthis.lastAddedCursorIndex = winnerIndex;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Winner takes it all\n\t\t\t\t\t\tresultingSelectionIsLTR = winnerSelectionIsLTR;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet resultingSelection: Selection;\n\t\t\t\t\tif (resultingSelectionIsLTR) {\n\t\t\t\t\t\tresultingSelection = new Selection(resultingRange.startLineNumber, resultingRange.startColumn, resultingRange.endLineNumber, resultingRange.endColumn);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresultingSelection = new Selection(resultingRange.endLineNumber, resultingRange.endColumn, resultingRange.startLineNumber, resultingRange.startColumn);\n\t\t\t\t\t}\n\n\t\t\t\t\tsortedCursors[winnerSortedCursorIndex].selection = resultingSelection;\n\t\t\t\t\tconst resultingState = CursorState.fromModelSelection(resultingSelection);\n\t\t\t\t\tcursors[winnerIndex].setState(this.context, resultingState.modelState, resultingState.viewState);\n\t\t\t\t}\n\n\t\t\t\tfor (const sortedCursor of sortedCursors) {\n\t\t\t\t\tif (sortedCursor.index > looserIndex) {\n\t\t\t\t\t\tsortedCursor.index--;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcursors.splice(looserIndex, 1);\n\t\t\t\tsortedCursors.splice(looserSortedCursorIndex, 1);\n\t\t\t\tthis._removeSecondaryCursor(looserIndex - 1);\n\n\t\t\t\tsortedCursorIndex--;\n\t\t\t}\n\t\t}\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
