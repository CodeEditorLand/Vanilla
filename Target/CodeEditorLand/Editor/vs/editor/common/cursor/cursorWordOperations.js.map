{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/cursor/cursorWordOperations.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from \"../../../base/common/charCode.js\";\nimport * as strings from \"../../../base/common/strings.js\";\nimport type {\n\tEditorAutoClosingEditStrategy,\n\tEditorAutoClosingStrategy,\n} from \"../config/editorOptions.js\";\nimport { Position } from \"../core/position.js\";\nimport { Range } from \"../core/range.js\";\nimport type { Selection } from \"../core/selection.js\";\nimport {\n\ttype IntlWordSegmentData,\n\tWordCharacterClass,\n\ttype WordCharacterClassifier,\n\tgetMapForWordSeparators,\n} from \"../core/wordCharacterClassifier.js\";\nimport type { IWordAtPosition } from \"../core/wordHelper.js\";\nimport {\n\ttype CursorConfiguration,\n\ttype ICursorSimpleModel,\n\tSelectionStartKind,\n\tSingleCursorState,\n} from \"../cursorCommon.js\";\nimport type { AutoClosingPairs } from \"../languages/languageConfiguration.js\";\nimport type { ITextModel } from \"../model.js\";\nimport { DeleteOperations } from \"./cursorDeleteOperations.js\";\n\ninterface IFindWordResult {\n\t/**\n\t * The index where the word starts.\n\t */\n\tstart: number;\n\t/**\n\t * The index where the word ends.\n\t */\n\tend: number;\n\t/**\n\t * The word type.\n\t */\n\twordType: WordType;\n\t/**\n\t * The reason the word ended.\n\t */\n\tnextCharClass: WordCharacterClass;\n}\n\nenum WordType {\n\tNone = 0,\n\tRegular = 1,\n\tSeparator = 2,\n}\n\nexport enum WordNavigationType {\n\tWordStart = 0,\n\tWordStartFast = 1,\n\tWordEnd = 2,\n\tWordAccessibility = 3, // Respect chrome definition of a word\n}\n\nexport interface DeleteWordContext {\n\twordSeparators: WordCharacterClassifier;\n\tmodel: ITextModel;\n\tselection: Selection;\n\twhitespaceHeuristics: boolean;\n\tautoClosingDelete: EditorAutoClosingEditStrategy;\n\tautoClosingBrackets: EditorAutoClosingStrategy;\n\tautoClosingQuotes: EditorAutoClosingStrategy;\n\tautoClosingPairs: AutoClosingPairs;\n\tautoClosedCharacters: Range[];\n}\n\nexport class WordOperations {\n\tprivate static _createWord(\n\t\tlineContent: string,\n\t\twordType: WordType,\n\t\tnextCharClass: WordCharacterClass,\n\t\tstart: number,\n\t\tend: number,\n\t): IFindWordResult {\n\t\t// console.log('WORD ==> ' + start + ' => ' + end + ':::: <<<' + lineContent.substring(start, end) + '>>>');\n\t\treturn {\n\t\t\tstart: start,\n\t\t\tend: end,\n\t\t\twordType: wordType,\n\t\t\tnextCharClass: nextCharClass,\n\t\t};\n\t}\n\n\tprivate static _createIntlWord(\n\t\tintlWord: IntlWordSegmentData,\n\t\tnextCharClass: WordCharacterClass,\n\t): IFindWordResult {\n\t\t// console.log('INTL WORD ==> ' + intlWord.index + ' => ' + intlWord.index + intlWord.segment.length + ':::: <<<' + intlWord.segment + '>>>');\n\t\treturn {\n\t\t\tstart: intlWord.index,\n\t\t\tend: intlWord.index + intlWord.segment.length,\n\t\t\twordType: WordType.Regular,\n\t\t\tnextCharClass: nextCharClass,\n\t\t};\n\t}\n\n\tprivate static _findPreviousWordOnLine(\n\t\twordSeparators: WordCharacterClassifier,\n\t\tmodel: ICursorSimpleModel,\n\t\tposition: Position,\n\t): IFindWordResult | null {\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\treturn this._doFindPreviousWordOnLine(\n\t\t\tlineContent,\n\t\t\twordSeparators,\n\t\t\tposition,\n\t\t);\n\t}\n\n\tprivate static _doFindPreviousWordOnLine(\n\t\tlineContent: string,\n\t\twordSeparators: WordCharacterClassifier,\n\t\tposition: Position,\n\t): IFindWordResult | null {\n\t\tlet wordType = WordType.None;\n\n\t\tconst previousIntlWord =\n\t\t\twordSeparators.findPrevIntlWordBeforeOrAtOffset(\n\t\t\t\tlineContent,\n\t\t\t\tposition.column - 2,\n\t\t\t);\n\n\t\tfor (let chIndex = position.column - 2; chIndex >= 0; chIndex--) {\n\t\t\tconst chCode = lineContent.charCodeAt(chIndex);\n\t\t\tconst chClass = wordSeparators.get(chCode);\n\n\t\t\tif (previousIntlWord && chIndex === previousIntlWord.index) {\n\t\t\t\treturn this._createIntlWord(previousIntlWord, chClass);\n\t\t\t}\n\n\t\t\tif (chClass === WordCharacterClass.Regular) {\n\t\t\t\tif (wordType === WordType.Separator) {\n\t\t\t\t\treturn this._createWord(\n\t\t\t\t\t\tlineContent,\n\t\t\t\t\t\twordType,\n\t\t\t\t\t\tchClass,\n\t\t\t\t\t\tchIndex + 1,\n\t\t\t\t\t\tthis._findEndOfWord(\n\t\t\t\t\t\t\tlineContent,\n\t\t\t\t\t\t\twordSeparators,\n\t\t\t\t\t\t\twordType,\n\t\t\t\t\t\t\tchIndex + 1,\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\twordType = WordType.Regular;\n\t\t\t} else if (chClass === WordCharacterClass.WordSeparator) {\n\t\t\t\tif (wordType === WordType.Regular) {\n\t\t\t\t\treturn this._createWord(\n\t\t\t\t\t\tlineContent,\n\t\t\t\t\t\twordType,\n\t\t\t\t\t\tchClass,\n\t\t\t\t\t\tchIndex + 1,\n\t\t\t\t\t\tthis._findEndOfWord(\n\t\t\t\t\t\t\tlineContent,\n\t\t\t\t\t\t\twordSeparators,\n\t\t\t\t\t\t\twordType,\n\t\t\t\t\t\t\tchIndex + 1,\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\twordType = WordType.Separator;\n\t\t\t} else if (chClass === WordCharacterClass.Whitespace) {\n\t\t\t\tif (wordType !== WordType.None) {\n\t\t\t\t\treturn this._createWord(\n\t\t\t\t\t\tlineContent,\n\t\t\t\t\t\twordType,\n\t\t\t\t\t\tchClass,\n\t\t\t\t\t\tchIndex + 1,\n\t\t\t\t\t\tthis._findEndOfWord(\n\t\t\t\t\t\t\tlineContent,\n\t\t\t\t\t\t\twordSeparators,\n\t\t\t\t\t\t\twordType,\n\t\t\t\t\t\t\tchIndex + 1,\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (wordType !== WordType.None) {\n\t\t\treturn this._createWord(\n\t\t\t\tlineContent,\n\t\t\t\twordType,\n\t\t\t\tWordCharacterClass.Whitespace,\n\t\t\t\t0,\n\t\t\t\tthis._findEndOfWord(lineContent, wordSeparators, wordType, 0),\n\t\t\t);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _findEndOfWord(\n\t\tlineContent: string,\n\t\twordSeparators: WordCharacterClassifier,\n\t\twordType: WordType,\n\t\tstartIndex: number,\n\t): number {\n\t\tconst nextIntlWord = wordSeparators.findNextIntlWordAtOrAfterOffset(\n\t\t\tlineContent,\n\t\t\tstartIndex,\n\t\t);\n\n\t\tconst len = lineContent.length;\n\t\tfor (let chIndex = startIndex; chIndex < len; chIndex++) {\n\t\t\tconst chCode = lineContent.charCodeAt(chIndex);\n\t\t\tconst chClass = wordSeparators.get(chCode);\n\n\t\t\tif (\n\t\t\t\tnextIntlWord &&\n\t\t\t\tchIndex === nextIntlWord.index + nextIntlWord.segment.length\n\t\t\t) {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\n\t\t\tif (chClass === WordCharacterClass.Whitespace) {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\t\t\tif (\n\t\t\t\twordType === WordType.Regular &&\n\t\t\t\tchClass === WordCharacterClass.WordSeparator\n\t\t\t) {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\t\t\tif (\n\t\t\t\twordType === WordType.Separator &&\n\t\t\t\tchClass === WordCharacterClass.Regular\n\t\t\t) {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\t\t}\n\t\treturn len;\n\t}\n\n\tprivate static _findNextWordOnLine(\n\t\twordSeparators: WordCharacterClassifier,\n\t\tmodel: ICursorSimpleModel,\n\t\tposition: Position,\n\t): IFindWordResult | null {\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\treturn this._doFindNextWordOnLine(\n\t\t\tlineContent,\n\t\t\twordSeparators,\n\t\t\tposition,\n\t\t);\n\t}\n\n\tprivate static _doFindNextWordOnLine(\n\t\tlineContent: string,\n\t\twordSeparators: WordCharacterClassifier,\n\t\tposition: Position,\n\t): IFindWordResult | null {\n\t\tlet wordType = WordType.None;\n\t\tconst len = lineContent.length;\n\n\t\tconst nextIntlWord = wordSeparators.findNextIntlWordAtOrAfterOffset(\n\t\t\tlineContent,\n\t\t\tposition.column - 1,\n\t\t);\n\n\t\tfor (let chIndex = position.column - 1; chIndex < len; chIndex++) {\n\t\t\tconst chCode = lineContent.charCodeAt(chIndex);\n\t\t\tconst chClass = wordSeparators.get(chCode);\n\n\t\t\tif (nextIntlWord && chIndex === nextIntlWord.index) {\n\t\t\t\treturn this._createIntlWord(nextIntlWord, chClass);\n\t\t\t}\n\n\t\t\tif (chClass === WordCharacterClass.Regular) {\n\t\t\t\tif (wordType === WordType.Separator) {\n\t\t\t\t\treturn this._createWord(\n\t\t\t\t\t\tlineContent,\n\t\t\t\t\t\twordType,\n\t\t\t\t\t\tchClass,\n\t\t\t\t\t\tthis._findStartOfWord(\n\t\t\t\t\t\t\tlineContent,\n\t\t\t\t\t\t\twordSeparators,\n\t\t\t\t\t\t\twordType,\n\t\t\t\t\t\t\tchIndex - 1,\n\t\t\t\t\t\t),\n\t\t\t\t\t\tchIndex,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\twordType = WordType.Regular;\n\t\t\t} else if (chClass === WordCharacterClass.WordSeparator) {\n\t\t\t\tif (wordType === WordType.Regular) {\n\t\t\t\t\treturn this._createWord(\n\t\t\t\t\t\tlineContent,\n\t\t\t\t\t\twordType,\n\t\t\t\t\t\tchClass,\n\t\t\t\t\t\tthis._findStartOfWord(\n\t\t\t\t\t\t\tlineContent,\n\t\t\t\t\t\t\twordSeparators,\n\t\t\t\t\t\t\twordType,\n\t\t\t\t\t\t\tchIndex - 1,\n\t\t\t\t\t\t),\n\t\t\t\t\t\tchIndex,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\twordType = WordType.Separator;\n\t\t\t} else if (chClass === WordCharacterClass.Whitespace) {\n\t\t\t\tif (wordType !== WordType.None) {\n\t\t\t\t\treturn this._createWord(\n\t\t\t\t\t\tlineContent,\n\t\t\t\t\t\twordType,\n\t\t\t\t\t\tchClass,\n\t\t\t\t\t\tthis._findStartOfWord(\n\t\t\t\t\t\t\tlineContent,\n\t\t\t\t\t\t\twordSeparators,\n\t\t\t\t\t\t\twordType,\n\t\t\t\t\t\t\tchIndex - 1,\n\t\t\t\t\t\t),\n\t\t\t\t\t\tchIndex,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (wordType !== WordType.None) {\n\t\t\treturn this._createWord(\n\t\t\t\tlineContent,\n\t\t\t\twordType,\n\t\t\t\tWordCharacterClass.Whitespace,\n\t\t\t\tthis._findStartOfWord(\n\t\t\t\t\tlineContent,\n\t\t\t\t\twordSeparators,\n\t\t\t\t\twordType,\n\t\t\t\t\tlen - 1,\n\t\t\t\t),\n\t\t\t\tlen,\n\t\t\t);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _findStartOfWord(\n\t\tlineContent: string,\n\t\twordSeparators: WordCharacterClassifier,\n\t\twordType: WordType,\n\t\tstartIndex: number,\n\t): number {\n\t\tconst previousIntlWord =\n\t\t\twordSeparators.findPrevIntlWordBeforeOrAtOffset(\n\t\t\t\tlineContent,\n\t\t\t\tstartIndex,\n\t\t\t);\n\n\t\tfor (let chIndex = startIndex; chIndex >= 0; chIndex--) {\n\t\t\tconst chCode = lineContent.charCodeAt(chIndex);\n\t\t\tconst chClass = wordSeparators.get(chCode);\n\n\t\t\tif (previousIntlWord && chIndex === previousIntlWord.index) {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\n\t\t\tif (chClass === WordCharacterClass.Whitespace) {\n\t\t\t\treturn chIndex + 1;\n\t\t\t}\n\t\t\tif (\n\t\t\t\twordType === WordType.Regular &&\n\t\t\t\tchClass === WordCharacterClass.WordSeparator\n\t\t\t) {\n\t\t\t\treturn chIndex + 1;\n\t\t\t}\n\t\t\tif (\n\t\t\t\twordType === WordType.Separator &&\n\t\t\t\tchClass === WordCharacterClass.Regular\n\t\t\t) {\n\t\t\t\treturn chIndex + 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic static moveWordLeft(\n\t\twordSeparators: WordCharacterClassifier,\n\t\tmodel: ICursorSimpleModel,\n\t\tposition: Position,\n\t\twordNavigationType: WordNavigationType,\n\t\thasMulticursor: boolean,\n\t): Position {\n\t\tlet lineNumber = position.lineNumber;\n\t\tlet column = position.column;\n\n\t\tif (column === 1) {\n\t\t\tif (lineNumber > 1) {\n\t\t\t\tlineNumber = lineNumber - 1;\n\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t}\n\t\t}\n\n\t\tlet prevWordOnLine = WordOperations._findPreviousWordOnLine(\n\t\t\twordSeparators,\n\t\t\tmodel,\n\t\t\tnew Position(lineNumber, column),\n\t\t);\n\n\t\tif (wordNavigationType === WordNavigationType.WordStart) {\n\t\t\treturn new Position(\n\t\t\t\tlineNumber,\n\t\t\t\tprevWordOnLine ? prevWordOnLine.start + 1 : 1,\n\t\t\t);\n\t\t}\n\n\t\tif (wordNavigationType === WordNavigationType.WordStartFast) {\n\t\t\tif (\n\t\t\t\t!hasMulticursor && // avoid having multiple cursors stop at different locations when doing word start\n\t\t\t\tprevWordOnLine &&\n\t\t\t\tprevWordOnLine.wordType === WordType.Separator &&\n\t\t\t\tprevWordOnLine.end - prevWordOnLine.start === 1 &&\n\t\t\t\tprevWordOnLine.nextCharClass === WordCharacterClass.Regular\n\t\t\t) {\n\t\t\t\t// Skip over a word made up of one single separator and followed by a regular character\n\t\t\t\tprevWordOnLine = WordOperations._findPreviousWordOnLine(\n\t\t\t\t\twordSeparators,\n\t\t\t\t\tmodel,\n\t\t\t\t\tnew Position(lineNumber, prevWordOnLine.start + 1),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn new Position(\n\t\t\t\tlineNumber,\n\t\t\t\tprevWordOnLine ? prevWordOnLine.start + 1 : 1,\n\t\t\t);\n\t\t}\n\n\t\tif (wordNavigationType === WordNavigationType.WordAccessibility) {\n\t\t\twhile (\n\t\t\t\tprevWordOnLine &&\n\t\t\t\tprevWordOnLine.wordType === WordType.Separator\n\t\t\t) {\n\t\t\t\t// Skip over words made up of only separators\n\t\t\t\tprevWordOnLine = WordOperations._findPreviousWordOnLine(\n\t\t\t\t\twordSeparators,\n\t\t\t\t\tmodel,\n\t\t\t\t\tnew Position(lineNumber, prevWordOnLine.start + 1),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn new Position(\n\t\t\t\tlineNumber,\n\t\t\t\tprevWordOnLine ? prevWordOnLine.start + 1 : 1,\n\t\t\t);\n\t\t}\n\n\t\t// We are stopping at the ending of words\n\n\t\tif (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n\t\t\tprevWordOnLine = WordOperations._findPreviousWordOnLine(\n\t\t\t\twordSeparators,\n\t\t\t\tmodel,\n\t\t\t\tnew Position(lineNumber, prevWordOnLine.start + 1),\n\t\t\t);\n\t\t}\n\n\t\treturn new Position(\n\t\t\tlineNumber,\n\t\t\tprevWordOnLine ? prevWordOnLine.end + 1 : 1,\n\t\t);\n\t}\n\n\tpublic static _moveWordPartLeft(\n\t\tmodel: ICursorSimpleModel,\n\t\tposition: Position,\n\t): Position {\n\t\tconst lineNumber = position.lineNumber;\n\t\tconst maxColumn = model.getLineMaxColumn(lineNumber);\n\n\t\tif (position.column === 1) {\n\t\t\treturn lineNumber > 1\n\t\t\t\t? new Position(\n\t\t\t\t\t\tlineNumber - 1,\n\t\t\t\t\t\tmodel.getLineMaxColumn(lineNumber - 1),\n\t\t\t\t\t)\n\t\t\t\t: position;\n\t\t}\n\n\t\tconst lineContent = model.getLineContent(lineNumber);\n\t\tfor (let column = position.column - 1; column > 1; column--) {\n\t\t\tconst left = lineContent.charCodeAt(column - 2);\n\t\t\tconst right = lineContent.charCodeAt(column - 1);\n\n\t\t\tif (left === CharCode.Underline && right !== CharCode.Underline) {\n\t\t\t\t// snake_case_variables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif (left === CharCode.Dash && right !== CharCode.Dash) {\n\t\t\t\t// kebab-case-variables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t(strings.isLowerAsciiLetter(left) ||\n\t\t\t\t\tstrings.isAsciiDigit(left)) &&\n\t\t\t\tstrings.isUpperAsciiLetter(right)\n\t\t\t) {\n\t\t\t\t// camelCaseVariables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tstrings.isUpperAsciiLetter(left) &&\n\t\t\t\tstrings.isUpperAsciiLetter(right)\n\t\t\t) {\n\t\t\t\t// thisIsACamelCaseWithOneLetterWords\n\t\t\t\tif (column + 1 < maxColumn) {\n\t\t\t\t\tconst rightRight = lineContent.charCodeAt(column);\n\t\t\t\t\tif (\n\t\t\t\t\t\tstrings.isLowerAsciiLetter(rightRight) ||\n\t\t\t\t\t\tstrings.isAsciiDigit(rightRight)\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Position(lineNumber, 1);\n\t}\n\n\tpublic static moveWordRight(\n\t\twordSeparators: WordCharacterClassifier,\n\t\tmodel: ICursorSimpleModel,\n\t\tposition: Position,\n\t\twordNavigationType: WordNavigationType,\n\t): Position {\n\t\tlet lineNumber = position.lineNumber;\n\t\tlet column = position.column;\n\n\t\tlet movedDown = false;\n\t\tif (column === model.getLineMaxColumn(lineNumber)) {\n\t\t\tif (lineNumber < model.getLineCount()) {\n\t\t\t\tmovedDown = true;\n\t\t\t\tlineNumber = lineNumber + 1;\n\t\t\t\tcolumn = 1;\n\t\t\t}\n\t\t}\n\n\t\tlet nextWordOnLine = WordOperations._findNextWordOnLine(\n\t\t\twordSeparators,\n\t\t\tmodel,\n\t\t\tnew Position(lineNumber, column),\n\t\t);\n\n\t\tif (wordNavigationType === WordNavigationType.WordEnd) {\n\t\t\tif (\n\t\t\t\tnextWordOnLine &&\n\t\t\t\tnextWordOnLine.wordType === WordType.Separator\n\t\t\t) {\n\t\t\t\tif (\n\t\t\t\t\tnextWordOnLine.end - nextWordOnLine.start === 1 &&\n\t\t\t\t\tnextWordOnLine.nextCharClass === WordCharacterClass.Regular\n\t\t\t\t) {\n\t\t\t\t\t// Skip over a word made up of one single separator and followed by a regular character\n\t\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(\n\t\t\t\t\t\twordSeparators,\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\tnew Position(lineNumber, nextWordOnLine.end + 1),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nextWordOnLine) {\n\t\t\t\tcolumn = nextWordOnLine.end + 1;\n\t\t\t} else {\n\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t}\n\t\t} else if (\n\t\t\twordNavigationType === WordNavigationType.WordAccessibility\n\t\t) {\n\t\t\tif (movedDown) {\n\t\t\t\t// If we move to the next line, pretend that the cursor is right before the first character.\n\t\t\t\t// This is needed when the first word starts right at the first character - and in order not to miss it,\n\t\t\t\t// we need to start before.\n\t\t\t\tcolumn = 0;\n\t\t\t}\n\n\t\t\twhile (\n\t\t\t\tnextWordOnLine &&\n\t\t\t\t(nextWordOnLine.wordType === WordType.Separator ||\n\t\t\t\t\tnextWordOnLine.start + 1 <= column)\n\t\t\t) {\n\t\t\t\t// Skip over a word made up of one single separator\n\t\t\t\t// Also skip over word if it begins before current cursor position to ascertain we're moving forward at least 1 character.\n\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(\n\t\t\t\t\twordSeparators,\n\t\t\t\t\tmodel,\n\t\t\t\t\tnew Position(lineNumber, nextWordOnLine.end + 1),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (nextWordOnLine) {\n\t\t\t\tcolumn = nextWordOnLine.start + 1;\n\t\t\t} else {\n\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t}\n\t\t} else {\n\t\t\tif (\n\t\t\t\tnextWordOnLine &&\n\t\t\t\t!movedDown &&\n\t\t\t\tcolumn >= nextWordOnLine.start + 1\n\t\t\t) {\n\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(\n\t\t\t\t\twordSeparators,\n\t\t\t\t\tmodel,\n\t\t\t\t\tnew Position(lineNumber, nextWordOnLine.end + 1),\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (nextWordOnLine) {\n\t\t\t\tcolumn = nextWordOnLine.start + 1;\n\t\t\t} else {\n\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t}\n\t\t}\n\n\t\treturn new Position(lineNumber, column);\n\t}\n\n\tpublic static _moveWordPartRight(\n\t\tmodel: ICursorSimpleModel,\n\t\tposition: Position,\n\t): Position {\n\t\tconst lineNumber = position.lineNumber;\n\t\tconst maxColumn = model.getLineMaxColumn(lineNumber);\n\n\t\tif (position.column === maxColumn) {\n\t\t\treturn lineNumber < model.getLineCount()\n\t\t\t\t? new Position(lineNumber + 1, 1)\n\t\t\t\t: position;\n\t\t}\n\n\t\tconst lineContent = model.getLineContent(lineNumber);\n\t\tfor (let column = position.column + 1; column < maxColumn; column++) {\n\t\t\tconst left = lineContent.charCodeAt(column - 2);\n\t\t\tconst right = lineContent.charCodeAt(column - 1);\n\n\t\t\tif (left !== CharCode.Underline && right === CharCode.Underline) {\n\t\t\t\t// snake_case_variables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif (left !== CharCode.Dash && right === CharCode.Dash) {\n\t\t\t\t// kebab-case-variables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t(strings.isLowerAsciiLetter(left) ||\n\t\t\t\t\tstrings.isAsciiDigit(left)) &&\n\t\t\t\tstrings.isUpperAsciiLetter(right)\n\t\t\t) {\n\t\t\t\t// camelCaseVariables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tstrings.isUpperAsciiLetter(left) &&\n\t\t\t\tstrings.isUpperAsciiLetter(right)\n\t\t\t) {\n\t\t\t\t// thisIsACamelCaseWithOneLetterWords\n\t\t\t\tif (column + 1 < maxColumn) {\n\t\t\t\t\tconst rightRight = lineContent.charCodeAt(column);\n\t\t\t\t\tif (\n\t\t\t\t\t\tstrings.isLowerAsciiLetter(rightRight) ||\n\t\t\t\t\t\tstrings.isAsciiDigit(rightRight)\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Position(lineNumber, maxColumn);\n\t}\n\n\tprotected static _deleteWordLeftWhitespace(\n\t\tmodel: ICursorSimpleModel,\n\t\tposition: Position,\n\t): Range | null {\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\tconst startIndex = position.column - 2;\n\t\tconst lastNonWhitespace = strings.lastNonWhitespaceIndex(\n\t\t\tlineContent,\n\t\t\tstartIndex,\n\t\t);\n\t\tif (lastNonWhitespace + 1 < startIndex) {\n\t\t\treturn new Range(\n\t\t\t\tposition.lineNumber,\n\t\t\t\tlastNonWhitespace + 2,\n\t\t\t\tposition.lineNumber,\n\t\t\t\tposition.column,\n\t\t\t);\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static deleteWordLeft(\n\t\tctx: DeleteWordContext,\n\t\twordNavigationType: WordNavigationType,\n\t): Range | null {\n\t\tconst wordSeparators = ctx.wordSeparators;\n\t\tconst model = ctx.model;\n\t\tconst selection = ctx.selection;\n\t\tconst whitespaceHeuristics = ctx.whitespaceHeuristics;\n\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn selection;\n\t\t}\n\n\t\tif (\n\t\t\tDeleteOperations.isAutoClosingPairDelete(\n\t\t\t\tctx.autoClosingDelete,\n\t\t\t\tctx.autoClosingBrackets,\n\t\t\t\tctx.autoClosingQuotes,\n\t\t\t\tctx.autoClosingPairs.autoClosingPairsOpenByEnd,\n\t\t\t\tctx.model,\n\t\t\t\t[ctx.selection],\n\t\t\t\tctx.autoClosedCharacters,\n\t\t\t)\n\t\t) {\n\t\t\tconst position = ctx.selection.getPosition();\n\t\t\treturn new Range(\n\t\t\t\tposition.lineNumber,\n\t\t\t\tposition.column - 1,\n\t\t\t\tposition.lineNumber,\n\t\t\t\tposition.column + 1,\n\t\t\t);\n\t\t}\n\n\t\tconst position = new Position(\n\t\t\tselection.positionLineNumber,\n\t\t\tselection.positionColumn,\n\t\t);\n\n\t\tlet lineNumber = position.lineNumber;\n\t\tlet column = position.column;\n\n\t\tif (lineNumber === 1 && column === 1) {\n\t\t\t// Ignore deleting at beginning of file\n\t\t\treturn null;\n\t\t}\n\n\t\tif (whitespaceHeuristics) {\n\t\t\tconst r = this._deleteWordLeftWhitespace(model, position);\n\t\t\tif (r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\tlet prevWordOnLine = WordOperations._findPreviousWordOnLine(\n\t\t\twordSeparators,\n\t\t\tmodel,\n\t\t\tposition,\n\t\t);\n\n\t\tif (wordNavigationType === WordNavigationType.WordStart) {\n\t\t\tif (prevWordOnLine) {\n\t\t\t\tcolumn = prevWordOnLine.start + 1;\n\t\t\t} else if (column > 1) {\n\t\t\t\tcolumn = 1;\n\t\t\t} else {\n\t\t\t\tlineNumber--;\n\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t}\n\t\t} else {\n\t\t\tif (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n\t\t\t\tprevWordOnLine = WordOperations._findPreviousWordOnLine(\n\t\t\t\t\twordSeparators,\n\t\t\t\t\tmodel,\n\t\t\t\t\tnew Position(lineNumber, prevWordOnLine.start + 1),\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (prevWordOnLine) {\n\t\t\t\tcolumn = prevWordOnLine.end + 1;\n\t\t\t} else if (column > 1) {\n\t\t\t\tcolumn = 1;\n\t\t\t} else {\n\t\t\t\tlineNumber--;\n\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t}\n\t\t}\n\n\t\treturn new Range(\n\t\t\tlineNumber,\n\t\t\tcolumn,\n\t\t\tposition.lineNumber,\n\t\t\tposition.column,\n\t\t);\n\t}\n\n\tpublic static deleteInsideWord(\n\t\twordSeparators: WordCharacterClassifier,\n\t\tmodel: ITextModel,\n\t\tselection: Selection,\n\t): Range {\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn selection;\n\t\t}\n\n\t\tconst position = new Position(\n\t\t\tselection.positionLineNumber,\n\t\t\tselection.positionColumn,\n\t\t);\n\n\t\tconst r = this._deleteInsideWordWhitespace(model, position);\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\n\t\treturn this._deleteInsideWordDetermineDeleteRange(\n\t\t\twordSeparators,\n\t\t\tmodel,\n\t\t\tposition,\n\t\t);\n\t}\n\n\tprivate static _charAtIsWhitespace(str: string, index: number): boolean {\n\t\tconst charCode = str.charCodeAt(index);\n\t\treturn charCode === CharCode.Space || charCode === CharCode.Tab;\n\t}\n\n\tprivate static _deleteInsideWordWhitespace(\n\t\tmodel: ICursorSimpleModel,\n\t\tposition: Position,\n\t): Range | null {\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\tconst lineContentLength = lineContent.length;\n\n\t\tif (lineContentLength === 0) {\n\t\t\t// empty line\n\t\t\treturn null;\n\t\t}\n\n\t\tlet leftIndex = Math.max(position.column - 2, 0);\n\t\tif (!this._charAtIsWhitespace(lineContent, leftIndex)) {\n\t\t\t// touches a non-whitespace character to the left\n\t\t\treturn null;\n\t\t}\n\n\t\tlet rightIndex = Math.min(position.column - 1, lineContentLength - 1);\n\t\tif (!this._charAtIsWhitespace(lineContent, rightIndex)) {\n\t\t\t// touches a non-whitespace character to the right\n\t\t\treturn null;\n\t\t}\n\n\t\t// walk over whitespace to the left\n\t\twhile (\n\t\t\tleftIndex > 0 &&\n\t\t\tthis._charAtIsWhitespace(lineContent, leftIndex - 1)\n\t\t) {\n\t\t\tleftIndex--;\n\t\t}\n\n\t\t// walk over whitespace to the right\n\t\twhile (\n\t\t\trightIndex + 1 < lineContentLength &&\n\t\t\tthis._charAtIsWhitespace(lineContent, rightIndex + 1)\n\t\t) {\n\t\t\trightIndex++;\n\t\t}\n\n\t\treturn new Range(\n\t\t\tposition.lineNumber,\n\t\t\tleftIndex + 1,\n\t\t\tposition.lineNumber,\n\t\t\trightIndex + 2,\n\t\t);\n\t}\n\n\tprivate static _deleteInsideWordDetermineDeleteRange(\n\t\twordSeparators: WordCharacterClassifier,\n\t\tmodel: ICursorSimpleModel,\n\t\tposition: Position,\n\t): Range {\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\tconst lineLength = lineContent.length;\n\t\tif (lineLength === 0) {\n\t\t\t// empty line\n\t\t\tif (position.lineNumber > 1) {\n\t\t\t\treturn new Range(\n\t\t\t\t\tposition.lineNumber - 1,\n\t\t\t\t\tmodel.getLineMaxColumn(position.lineNumber - 1),\n\t\t\t\t\tposition.lineNumber,\n\t\t\t\t\t1,\n\t\t\t\t);\n\t\t\t} else if (position.lineNumber < model.getLineCount()) {\n\t\t\t\treturn new Range(\n\t\t\t\t\tposition.lineNumber,\n\t\t\t\t\t1,\n\t\t\t\t\tposition.lineNumber + 1,\n\t\t\t\t\t1,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t// empty model\n\t\t\t\treturn new Range(\n\t\t\t\t\tposition.lineNumber,\n\t\t\t\t\t1,\n\t\t\t\t\tposition.lineNumber,\n\t\t\t\t\t1,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tconst touchesWord = (word: IFindWordResult) => {\n\t\t\treturn (\n\t\t\t\tword.start + 1 <= position.column &&\n\t\t\t\tposition.column <= word.end + 1\n\t\t\t);\n\t\t};\n\t\tconst createRangeWithPosition = (\n\t\t\tstartColumn: number,\n\t\t\tendColumn: number,\n\t\t) => {\n\t\t\tstartColumn = Math.min(startColumn, position.column);\n\t\t\tendColumn = Math.max(endColumn, position.column);\n\t\t\treturn new Range(\n\t\t\t\tposition.lineNumber,\n\t\t\t\tstartColumn,\n\t\t\t\tposition.lineNumber,\n\t\t\t\tendColumn,\n\t\t\t);\n\t\t};\n\t\tconst deleteWordAndAdjacentWhitespace = (word: IFindWordResult) => {\n\t\t\tlet startColumn = word.start + 1;\n\t\t\tlet endColumn = word.end + 1;\n\t\t\tlet expandedToTheRight = false;\n\t\t\twhile (\n\t\t\t\tendColumn - 1 < lineLength &&\n\t\t\t\tthis._charAtIsWhitespace(lineContent, endColumn - 1)\n\t\t\t) {\n\t\t\t\texpandedToTheRight = true;\n\t\t\t\tendColumn++;\n\t\t\t}\n\t\t\tif (!expandedToTheRight) {\n\t\t\t\twhile (\n\t\t\t\t\tstartColumn > 1 &&\n\t\t\t\t\tthis._charAtIsWhitespace(lineContent, startColumn - 2)\n\t\t\t\t) {\n\t\t\t\t\tstartColumn--;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn createRangeWithPosition(startColumn, endColumn);\n\t\t};\n\n\t\tconst prevWordOnLine = WordOperations._findPreviousWordOnLine(\n\t\t\twordSeparators,\n\t\t\tmodel,\n\t\t\tposition,\n\t\t);\n\t\tif (prevWordOnLine && touchesWord(prevWordOnLine)) {\n\t\t\treturn deleteWordAndAdjacentWhitespace(prevWordOnLine);\n\t\t}\n\t\tconst nextWordOnLine = WordOperations._findNextWordOnLine(\n\t\t\twordSeparators,\n\t\t\tmodel,\n\t\t\tposition,\n\t\t);\n\t\tif (nextWordOnLine && touchesWord(nextWordOnLine)) {\n\t\t\treturn deleteWordAndAdjacentWhitespace(nextWordOnLine);\n\t\t}\n\t\tif (prevWordOnLine && nextWordOnLine) {\n\t\t\treturn createRangeWithPosition(\n\t\t\t\tprevWordOnLine.end + 1,\n\t\t\t\tnextWordOnLine.start + 1,\n\t\t\t);\n\t\t}\n\t\tif (prevWordOnLine) {\n\t\t\treturn createRangeWithPosition(\n\t\t\t\tprevWordOnLine.start + 1,\n\t\t\t\tprevWordOnLine.end + 1,\n\t\t\t);\n\t\t}\n\t\tif (nextWordOnLine) {\n\t\t\treturn createRangeWithPosition(\n\t\t\t\tnextWordOnLine.start + 1,\n\t\t\t\tnextWordOnLine.end + 1,\n\t\t\t);\n\t\t}\n\n\t\treturn createRangeWithPosition(1, lineLength + 1);\n\t}\n\n\tpublic static _deleteWordPartLeft(\n\t\tmodel: ICursorSimpleModel,\n\t\tselection: Selection,\n\t): Range {\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn selection;\n\t\t}\n\n\t\tconst pos = selection.getPosition();\n\t\tconst toPosition = WordOperations._moveWordPartLeft(model, pos);\n\t\treturn new Range(\n\t\t\tpos.lineNumber,\n\t\t\tpos.column,\n\t\t\ttoPosition.lineNumber,\n\t\t\ttoPosition.column,\n\t\t);\n\t}\n\n\tprivate static _findFirstNonWhitespaceChar(\n\t\tstr: string,\n\t\tstartIndex: number,\n\t): number {\n\t\tconst len = str.length;\n\t\tfor (let chIndex = startIndex; chIndex < len; chIndex++) {\n\t\t\tconst ch = str.charAt(chIndex);\n\t\t\tif (ch !== \" \" && ch !== \"\\t\") {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\t\t}\n\t\treturn len;\n\t}\n\n\tprotected static _deleteWordRightWhitespace(\n\t\tmodel: ICursorSimpleModel,\n\t\tposition: Position,\n\t): Range | null {\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\tconst startIndex = position.column - 1;\n\t\tconst firstNonWhitespace = this._findFirstNonWhitespaceChar(\n\t\t\tlineContent,\n\t\t\tstartIndex,\n\t\t);\n\t\tif (startIndex + 1 < firstNonWhitespace) {\n\t\t\t// bingo\n\t\t\treturn new Range(\n\t\t\t\tposition.lineNumber,\n\t\t\t\tposition.column,\n\t\t\t\tposition.lineNumber,\n\t\t\t\tfirstNonWhitespace + 1,\n\t\t\t);\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static deleteWordRight(\n\t\tctx: DeleteWordContext,\n\t\twordNavigationType: WordNavigationType,\n\t): Range | null {\n\t\tconst wordSeparators = ctx.wordSeparators;\n\t\tconst model = ctx.model;\n\t\tconst selection = ctx.selection;\n\t\tconst whitespaceHeuristics = ctx.whitespaceHeuristics;\n\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn selection;\n\t\t}\n\n\t\tconst position = new Position(\n\t\t\tselection.positionLineNumber,\n\t\t\tselection.positionColumn,\n\t\t);\n\n\t\tlet lineNumber = position.lineNumber;\n\t\tlet column = position.column;\n\n\t\tconst lineCount = model.getLineCount();\n\t\tconst maxColumn = model.getLineMaxColumn(lineNumber);\n\t\tif (lineNumber === lineCount && column === maxColumn) {\n\t\t\t// Ignore deleting at end of file\n\t\t\treturn null;\n\t\t}\n\n\t\tif (whitespaceHeuristics) {\n\t\t\tconst r = this._deleteWordRightWhitespace(model, position);\n\t\t\tif (r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\tlet nextWordOnLine = WordOperations._findNextWordOnLine(\n\t\t\twordSeparators,\n\t\t\tmodel,\n\t\t\tposition,\n\t\t);\n\n\t\tif (wordNavigationType === WordNavigationType.WordEnd) {\n\t\t\tif (nextWordOnLine) {\n\t\t\t\tcolumn = nextWordOnLine.end + 1;\n\t\t\t} else if (column < maxColumn || lineNumber === lineCount) {\n\t\t\t\tcolumn = maxColumn;\n\t\t\t} else {\n\t\t\t\tlineNumber++;\n\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(\n\t\t\t\t\twordSeparators,\n\t\t\t\t\tmodel,\n\t\t\t\t\tnew Position(lineNumber, 1),\n\t\t\t\t);\n\t\t\t\tif (nextWordOnLine) {\n\t\t\t\t\tcolumn = nextWordOnLine.start + 1;\n\t\t\t\t} else {\n\t\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (nextWordOnLine && column >= nextWordOnLine.start + 1) {\n\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(\n\t\t\t\t\twordSeparators,\n\t\t\t\t\tmodel,\n\t\t\t\t\tnew Position(lineNumber, nextWordOnLine.end + 1),\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (nextWordOnLine) {\n\t\t\t\tcolumn = nextWordOnLine.start + 1;\n\t\t\t} else if (column < maxColumn || lineNumber === lineCount) {\n\t\t\t\tcolumn = maxColumn;\n\t\t\t} else {\n\t\t\t\tlineNumber++;\n\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(\n\t\t\t\t\twordSeparators,\n\t\t\t\t\tmodel,\n\t\t\t\t\tnew Position(lineNumber, 1),\n\t\t\t\t);\n\t\t\t\tif (nextWordOnLine) {\n\t\t\t\t\tcolumn = nextWordOnLine.start + 1;\n\t\t\t\t} else {\n\t\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Range(\n\t\t\tlineNumber,\n\t\t\tcolumn,\n\t\t\tposition.lineNumber,\n\t\t\tposition.column,\n\t\t);\n\t}\n\n\tpublic static _deleteWordPartRight(\n\t\tmodel: ICursorSimpleModel,\n\t\tselection: Selection,\n\t): Range {\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn selection;\n\t\t}\n\n\t\tconst pos = selection.getPosition();\n\t\tconst toPosition = WordOperations._moveWordPartRight(model, pos);\n\t\treturn new Range(\n\t\t\tpos.lineNumber,\n\t\t\tpos.column,\n\t\t\ttoPosition.lineNumber,\n\t\t\ttoPosition.column,\n\t\t);\n\t}\n\n\tprivate static _createWordAtPosition(\n\t\tmodel: ITextModel,\n\t\tlineNumber: number,\n\t\tword: IFindWordResult,\n\t): IWordAtPosition {\n\t\tconst range = new Range(\n\t\t\tlineNumber,\n\t\t\tword.start + 1,\n\t\t\tlineNumber,\n\t\t\tword.end + 1,\n\t\t);\n\t\treturn {\n\t\t\tword: model.getValueInRange(range),\n\t\t\tstartColumn: range.startColumn,\n\t\t\tendColumn: range.endColumn,\n\t\t};\n\t}\n\n\tpublic static getWordAtPosition(\n\t\tmodel: ITextModel,\n\t\t_wordSeparators: string,\n\t\t_intlSegmenterLocales: string[],\n\t\tposition: Position,\n\t): IWordAtPosition | null {\n\t\tconst wordSeparators = getMapForWordSeparators(\n\t\t\t_wordSeparators,\n\t\t\t_intlSegmenterLocales,\n\t\t);\n\t\tconst prevWord = WordOperations._findPreviousWordOnLine(\n\t\t\twordSeparators,\n\t\t\tmodel,\n\t\t\tposition,\n\t\t);\n\t\tif (\n\t\t\tprevWord &&\n\t\t\tprevWord.wordType === WordType.Regular &&\n\t\t\tprevWord.start <= position.column - 1 &&\n\t\t\tposition.column - 1 <= prevWord.end\n\t\t) {\n\t\t\treturn WordOperations._createWordAtPosition(\n\t\t\t\tmodel,\n\t\t\t\tposition.lineNumber,\n\t\t\t\tprevWord,\n\t\t\t);\n\t\t}\n\t\tconst nextWord = WordOperations._findNextWordOnLine(\n\t\t\twordSeparators,\n\t\t\tmodel,\n\t\t\tposition,\n\t\t);\n\t\tif (\n\t\t\tnextWord &&\n\t\t\tnextWord.wordType === WordType.Regular &&\n\t\t\tnextWord.start <= position.column - 1 &&\n\t\t\tposition.column - 1 <= nextWord.end\n\t\t) {\n\t\t\treturn WordOperations._createWordAtPosition(\n\t\t\t\tmodel,\n\t\t\t\tposition.lineNumber,\n\t\t\t\tnextWord,\n\t\t\t);\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static word(\n\t\tconfig: CursorConfiguration,\n\t\tmodel: ICursorSimpleModel,\n\t\tcursor: SingleCursorState,\n\t\tinSelectionMode: boolean,\n\t\tposition: Position,\n\t): SingleCursorState {\n\t\tconst wordSeparators = getMapForWordSeparators(\n\t\t\tconfig.wordSeparators,\n\t\t\tconfig.wordSegmenterLocales,\n\t\t);\n\t\tconst prevWord = WordOperations._findPreviousWordOnLine(\n\t\t\twordSeparators,\n\t\t\tmodel,\n\t\t\tposition,\n\t\t);\n\t\tconst nextWord = WordOperations._findNextWordOnLine(\n\t\t\twordSeparators,\n\t\t\tmodel,\n\t\t\tposition,\n\t\t);\n\n\t\tif (!inSelectionMode) {\n\t\t\t// Entering word selection for the first time\n\t\t\tlet startColumn: number;\n\t\t\tlet endColumn: number;\n\n\t\t\tif (\n\t\t\t\tprevWord &&\n\t\t\t\tprevWord.wordType === WordType.Regular &&\n\t\t\t\tprevWord.start <= position.column - 1 &&\n\t\t\t\tposition.column - 1 <= prevWord.end\n\t\t\t) {\n\t\t\t\t// isTouchingPrevWord\n\t\t\t\tstartColumn = prevWord.start + 1;\n\t\t\t\tendColumn = prevWord.end + 1;\n\t\t\t} else if (\n\t\t\t\tnextWord &&\n\t\t\t\tnextWord.wordType === WordType.Regular &&\n\t\t\t\tnextWord.start <= position.column - 1 &&\n\t\t\t\tposition.column - 1 <= nextWord.end\n\t\t\t) {\n\t\t\t\t// isTouchingNextWord\n\t\t\t\tstartColumn = nextWord.start + 1;\n\t\t\t\tendColumn = nextWord.end + 1;\n\t\t\t} else {\n\t\t\t\tif (prevWord) {\n\t\t\t\t\tstartColumn = prevWord.end + 1;\n\t\t\t\t} else {\n\t\t\t\t\tstartColumn = 1;\n\t\t\t\t}\n\t\t\t\tif (nextWord) {\n\t\t\t\t\tendColumn = nextWord.start + 1;\n\t\t\t\t} else {\n\t\t\t\t\tendColumn = model.getLineMaxColumn(position.lineNumber);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new SingleCursorState(\n\t\t\t\tnew Range(\n\t\t\t\t\tposition.lineNumber,\n\t\t\t\t\tstartColumn,\n\t\t\t\t\tposition.lineNumber,\n\t\t\t\t\tendColumn,\n\t\t\t\t),\n\t\t\t\tSelectionStartKind.Word,\n\t\t\t\t0,\n\t\t\t\tnew Position(position.lineNumber, endColumn),\n\t\t\t\t0,\n\t\t\t);\n\t\t}\n\n\t\tlet startColumn: number;\n\t\tlet endColumn: number;\n\n\t\tif (\n\t\t\tprevWord &&\n\t\t\tprevWord.wordType === WordType.Regular &&\n\t\t\tprevWord.start < position.column - 1 &&\n\t\t\tposition.column - 1 < prevWord.end\n\t\t) {\n\t\t\t// isInsidePrevWord\n\t\t\tstartColumn = prevWord.start + 1;\n\t\t\tendColumn = prevWord.end + 1;\n\t\t} else if (\n\t\t\tnextWord &&\n\t\t\tnextWord.wordType === WordType.Regular &&\n\t\t\tnextWord.start < position.column - 1 &&\n\t\t\tposition.column - 1 < nextWord.end\n\t\t) {\n\t\t\t// isInsideNextWord\n\t\t\tstartColumn = nextWord.start + 1;\n\t\t\tendColumn = nextWord.end + 1;\n\t\t} else {\n\t\t\tstartColumn = position.column;\n\t\t\tendColumn = position.column;\n\t\t}\n\n\t\tconst lineNumber = position.lineNumber;\n\t\tlet column: number;\n\t\tif (cursor.selectionStart.containsPosition(position)) {\n\t\t\tcolumn = cursor.selectionStart.endColumn;\n\t\t} else if (\n\t\t\tposition.isBeforeOrEqual(cursor.selectionStart.getStartPosition())\n\t\t) {\n\t\t\tcolumn = startColumn;\n\t\t\tconst possiblePosition = new Position(lineNumber, column);\n\t\t\tif (cursor.selectionStart.containsPosition(possiblePosition)) {\n\t\t\t\tcolumn = cursor.selectionStart.endColumn;\n\t\t\t}\n\t\t} else {\n\t\t\tcolumn = endColumn;\n\t\t\tconst possiblePosition = new Position(lineNumber, column);\n\t\t\tif (cursor.selectionStart.containsPosition(possiblePosition)) {\n\t\t\t\tcolumn = cursor.selectionStart.startColumn;\n\t\t\t}\n\t\t}\n\n\t\treturn cursor.move(true, lineNumber, column, 0);\n\t}\n}\n\nexport class WordPartOperations extends WordOperations {\n\tpublic static deleteWordPartLeft(ctx: DeleteWordContext): Range {\n\t\tconst candidates = enforceDefined([\n\t\t\tWordOperations.deleteWordLeft(ctx, WordNavigationType.WordStart),\n\t\t\tWordOperations.deleteWordLeft(ctx, WordNavigationType.WordEnd),\n\t\t\tWordOperations._deleteWordPartLeft(ctx.model, ctx.selection),\n\t\t]);\n\t\tcandidates.sort(Range.compareRangesUsingEnds);\n\t\treturn candidates[2];\n\t}\n\n\tpublic static deleteWordPartRight(ctx: DeleteWordContext): Range {\n\t\tconst candidates = enforceDefined([\n\t\t\tWordOperations.deleteWordRight(ctx, WordNavigationType.WordStart),\n\t\t\tWordOperations.deleteWordRight(ctx, WordNavigationType.WordEnd),\n\t\t\tWordOperations._deleteWordPartRight(ctx.model, ctx.selection),\n\t\t]);\n\t\tcandidates.sort(Range.compareRangesUsingStarts);\n\t\treturn candidates[0];\n\t}\n\n\tpublic static moveWordPartLeft(\n\t\twordSeparators: WordCharacterClassifier,\n\t\tmodel: ICursorSimpleModel,\n\t\tposition: Position,\n\t\thasMulticursor: boolean,\n\t): Position {\n\t\tconst candidates = enforceDefined([\n\t\t\tWordOperations.moveWordLeft(\n\t\t\t\twordSeparators,\n\t\t\t\tmodel,\n\t\t\t\tposition,\n\t\t\t\tWordNavigationType.WordStart,\n\t\t\t\thasMulticursor,\n\t\t\t),\n\t\t\tWordOperations.moveWordLeft(\n\t\t\t\twordSeparators,\n\t\t\t\tmodel,\n\t\t\t\tposition,\n\t\t\t\tWordNavigationType.WordEnd,\n\t\t\t\thasMulticursor,\n\t\t\t),\n\t\t\tWordOperations._moveWordPartLeft(model, position),\n\t\t]);\n\t\tcandidates.sort(Position.compare);\n\t\treturn candidates[2];\n\t}\n\n\tpublic static moveWordPartRight(\n\t\twordSeparators: WordCharacterClassifier,\n\t\tmodel: ICursorSimpleModel,\n\t\tposition: Position,\n\t): Position {\n\t\tconst candidates = enforceDefined([\n\t\t\tWordOperations.moveWordRight(\n\t\t\t\twordSeparators,\n\t\t\t\tmodel,\n\t\t\t\tposition,\n\t\t\t\tWordNavigationType.WordStart,\n\t\t\t),\n\t\t\tWordOperations.moveWordRight(\n\t\t\t\twordSeparators,\n\t\t\t\tmodel,\n\t\t\t\tposition,\n\t\t\t\tWordNavigationType.WordEnd,\n\t\t\t),\n\t\t\tWordOperations._moveWordPartRight(model, position),\n\t\t]);\n\t\tcandidates.sort(Position.compare);\n\t\treturn candidates[0];\n\t}\n}\n\nfunction enforceDefined<T>(arr: Array<T | undefined | null>): T[] {\n\treturn <T[]>arr.filter((el) => Boolean(el));\n}\n"],
  "mappings": "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",
  "names": ["WordType", "WordNavigationType", "position", "startColumn", "endColumn"]
}
