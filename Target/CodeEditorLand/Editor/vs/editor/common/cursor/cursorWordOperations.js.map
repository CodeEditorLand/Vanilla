{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/cursor/cursorWordOperations.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { EditorAutoClosingEditStrategy, EditorAutoClosingStrategy } from '../config/editorOptions.js';\nimport { CursorConfiguration, ICursorSimpleModel, SelectionStartKind, SingleCursorState } from '../cursorCommon.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { WordCharacterClass, WordCharacterClassifier, IntlWordSegmentData, getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { ITextModel } from '../model.js';\nimport { IWordAtPosition } from '../core/wordHelper.js';\nimport { AutoClosingPairs } from '../languages/languageConfiguration.js';\n\ninterface IFindWordResult {\n\t/**\n\t * The index where the word starts.\n\t */\n\tstart: number;\n\t/**\n\t * The index where the word ends.\n\t */\n\tend: number;\n\t/**\n\t * The word type.\n\t */\n\twordType: WordType;\n\t/**\n\t * The reason the word ended.\n\t */\n\tnextCharClass: WordCharacterClass;\n}\n\nconst enum WordType {\n\tNone = 0,\n\tRegular = 1,\n\tSeparator = 2\n}\n\nexport const enum WordNavigationType {\n\tWordStart = 0,\n\tWordStartFast = 1,\n\tWordEnd = 2,\n\tWordAccessibility = 3 // Respect chrome definition of a word\n}\n\nexport interface DeleteWordContext {\n\twordSeparators: WordCharacterClassifier;\n\tmodel: ITextModel;\n\tselection: Selection;\n\twhitespaceHeuristics: boolean;\n\tautoClosingDelete: EditorAutoClosingEditStrategy;\n\tautoClosingBrackets: EditorAutoClosingStrategy;\n\tautoClosingQuotes: EditorAutoClosingStrategy;\n\tautoClosingPairs: AutoClosingPairs;\n\tautoClosedCharacters: Range[];\n}\n\nexport class WordOperations {\n\n\tprivate static _createWord(lineContent: string, wordType: WordType, nextCharClass: WordCharacterClass, start: number, end: number): IFindWordResult {\n\t\t// console.log('WORD ==> ' + start + ' => ' + end + ':::: <<<' + lineContent.substring(start, end) + '>>>');\n\t\treturn { start: start, end: end, wordType: wordType, nextCharClass: nextCharClass };\n\t}\n\n\tprivate static _createIntlWord(intlWord: IntlWordSegmentData, nextCharClass: WordCharacterClass): IFindWordResult {\n\t\t// console.log('INTL WORD ==> ' + intlWord.index + ' => ' + intlWord.index + intlWord.segment.length + ':::: <<<' + intlWord.segment + '>>>');\n\t\treturn { start: intlWord.index, end: intlWord.index + intlWord.segment.length, wordType: WordType.Regular, nextCharClass: nextCharClass };\n\t}\n\n\tprivate static _findPreviousWordOnLine(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position): IFindWordResult | null {\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\treturn this._doFindPreviousWordOnLine(lineContent, wordSeparators, position);\n\t}\n\n\tprivate static _doFindPreviousWordOnLine(lineContent: string, wordSeparators: WordCharacterClassifier, position: Position): IFindWordResult | null {\n\t\tlet wordType = WordType.None;\n\n\t\tconst previousIntlWord = wordSeparators.findPrevIntlWordBeforeOrAtOffset(lineContent, position.column - 2);\n\n\t\tfor (let chIndex = position.column - 2; chIndex >= 0; chIndex--) {\n\t\t\tconst chCode = lineContent.charCodeAt(chIndex);\n\t\t\tconst chClass = wordSeparators.get(chCode);\n\n\t\t\tif (previousIntlWord && chIndex === previousIntlWord.index) {\n\t\t\t\treturn this._createIntlWord(previousIntlWord, chClass);\n\t\t\t}\n\n\t\t\tif (chClass === WordCharacterClass.Regular) {\n\t\t\t\tif (wordType === WordType.Separator) {\n\t\t\t\t\treturn this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n\t\t\t\t}\n\t\t\t\twordType = WordType.Regular;\n\t\t\t} else if (chClass === WordCharacterClass.WordSeparator) {\n\t\t\t\tif (wordType === WordType.Regular) {\n\t\t\t\t\treturn this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n\t\t\t\t}\n\t\t\t\twordType = WordType.Separator;\n\t\t\t} else if (chClass === WordCharacterClass.Whitespace) {\n\t\t\t\tif (wordType !== WordType.None) {\n\t\t\t\t\treturn this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (wordType !== WordType.None) {\n\t\t\treturn this._createWord(lineContent, wordType, WordCharacterClass.Whitespace, 0, this._findEndOfWord(lineContent, wordSeparators, wordType, 0));\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _findEndOfWord(lineContent: string, wordSeparators: WordCharacterClassifier, wordType: WordType, startIndex: number): number {\n\n\t\tconst nextIntlWord = wordSeparators.findNextIntlWordAtOrAfterOffset(lineContent, startIndex);\n\n\t\tconst len = lineContent.length;\n\t\tfor (let chIndex = startIndex; chIndex < len; chIndex++) {\n\t\t\tconst chCode = lineContent.charCodeAt(chIndex);\n\t\t\tconst chClass = wordSeparators.get(chCode);\n\n\t\t\tif (nextIntlWord && chIndex === nextIntlWord.index + nextIntlWord.segment.length) {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\n\t\t\tif (chClass === WordCharacterClass.Whitespace) {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\t\t\tif (wordType === WordType.Regular && chClass === WordCharacterClass.WordSeparator) {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\t\t\tif (wordType === WordType.Separator && chClass === WordCharacterClass.Regular) {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\t\t}\n\t\treturn len;\n\t}\n\n\tprivate static _findNextWordOnLine(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position): IFindWordResult | null {\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\treturn this._doFindNextWordOnLine(lineContent, wordSeparators, position);\n\t}\n\n\tprivate static _doFindNextWordOnLine(lineContent: string, wordSeparators: WordCharacterClassifier, position: Position): IFindWordResult | null {\n\t\tlet wordType = WordType.None;\n\t\tconst len = lineContent.length;\n\n\t\tconst nextIntlWord = wordSeparators.findNextIntlWordAtOrAfterOffset(lineContent, position.column - 1);\n\n\t\tfor (let chIndex = position.column - 1; chIndex < len; chIndex++) {\n\t\t\tconst chCode = lineContent.charCodeAt(chIndex);\n\t\t\tconst chClass = wordSeparators.get(chCode);\n\n\t\t\tif (nextIntlWord && chIndex === nextIntlWord.index) {\n\t\t\t\treturn this._createIntlWord(nextIntlWord, chClass);\n\t\t\t}\n\n\t\t\tif (chClass === WordCharacterClass.Regular) {\n\t\t\t\tif (wordType === WordType.Separator) {\n\t\t\t\t\treturn this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n\t\t\t\t}\n\t\t\t\twordType = WordType.Regular;\n\t\t\t} else if (chClass === WordCharacterClass.WordSeparator) {\n\t\t\t\tif (wordType === WordType.Regular) {\n\t\t\t\t\treturn this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n\t\t\t\t}\n\t\t\t\twordType = WordType.Separator;\n\t\t\t} else if (chClass === WordCharacterClass.Whitespace) {\n\t\t\t\tif (wordType !== WordType.None) {\n\t\t\t\t\treturn this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (wordType !== WordType.None) {\n\t\t\treturn this._createWord(lineContent, wordType, WordCharacterClass.Whitespace, this._findStartOfWord(lineContent, wordSeparators, wordType, len - 1), len);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _findStartOfWord(lineContent: string, wordSeparators: WordCharacterClassifier, wordType: WordType, startIndex: number): number {\n\n\t\tconst previousIntlWord = wordSeparators.findPrevIntlWordBeforeOrAtOffset(lineContent, startIndex);\n\n\t\tfor (let chIndex = startIndex; chIndex >= 0; chIndex--) {\n\t\t\tconst chCode = lineContent.charCodeAt(chIndex);\n\t\t\tconst chClass = wordSeparators.get(chCode);\n\n\t\t\tif (previousIntlWord && chIndex === previousIntlWord.index) {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\n\t\t\tif (chClass === WordCharacterClass.Whitespace) {\n\t\t\t\treturn chIndex + 1;\n\t\t\t}\n\t\t\tif (wordType === WordType.Regular && chClass === WordCharacterClass.WordSeparator) {\n\t\t\t\treturn chIndex + 1;\n\t\t\t}\n\t\t\tif (wordType === WordType.Separator && chClass === WordCharacterClass.Regular) {\n\t\t\t\treturn chIndex + 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic static moveWordLeft(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position, wordNavigationType: WordNavigationType, hasMulticursor: boolean): Position {\n\t\tlet lineNumber = position.lineNumber;\n\t\tlet column = position.column;\n\n\t\tif (column === 1) {\n\t\t\tif (lineNumber > 1) {\n\t\t\t\tlineNumber = lineNumber - 1;\n\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t}\n\t\t}\n\n\t\tlet prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n\n\t\tif (wordNavigationType === WordNavigationType.WordStart) {\n\t\t\treturn new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n\t\t}\n\n\t\tif (wordNavigationType === WordNavigationType.WordStartFast) {\n\t\t\tif (\n\t\t\t\t!hasMulticursor // avoid having multiple cursors stop at different locations when doing word start\n\t\t\t\t&& prevWordOnLine\n\t\t\t\t&& prevWordOnLine.wordType === WordType.Separator\n\t\t\t\t&& prevWordOnLine.end - prevWordOnLine.start === 1\n\t\t\t\t&& prevWordOnLine.nextCharClass === WordCharacterClass.Regular\n\t\t\t) {\n\t\t\t\t// Skip over a word made up of one single separator and followed by a regular character\n\t\t\t\tprevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n\t\t\t}\n\n\t\t\treturn new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n\t\t}\n\n\t\tif (wordNavigationType === WordNavigationType.WordAccessibility) {\n\t\t\twhile (\n\t\t\t\tprevWordOnLine\n\t\t\t\t&& prevWordOnLine.wordType === WordType.Separator\n\t\t\t) {\n\t\t\t\t// Skip over words made up of only separators\n\t\t\t\tprevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n\t\t\t}\n\n\t\t\treturn new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n\t\t}\n\n\t\t// We are stopping at the ending of words\n\n\t\tif (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n\t\t\tprevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n\t\t}\n\n\t\treturn new Position(lineNumber, prevWordOnLine ? prevWordOnLine.end + 1 : 1);\n\t}\n\n\tpublic static _moveWordPartLeft(model: ICursorSimpleModel, position: Position): Position {\n\t\tconst lineNumber = position.lineNumber;\n\t\tconst maxColumn = model.getLineMaxColumn(lineNumber);\n\n\t\tif (position.column === 1) {\n\t\t\treturn (lineNumber > 1 ? new Position(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)) : position);\n\t\t}\n\n\t\tconst lineContent = model.getLineContent(lineNumber);\n\t\tfor (let column = position.column - 1; column > 1; column--) {\n\t\t\tconst left = lineContent.charCodeAt(column - 2);\n\t\t\tconst right = lineContent.charCodeAt(column - 1);\n\n\t\t\tif (left === CharCode.Underline && right !== CharCode.Underline) {\n\t\t\t\t// snake_case_variables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif (left === CharCode.Dash && right !== CharCode.Dash) {\n\t\t\t\t// kebab-case-variables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n\t\t\t\t// camelCaseVariables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n\t\t\t\t// thisIsACamelCaseWithOneLetterWords\n\t\t\t\tif (column + 1 < maxColumn) {\n\t\t\t\t\tconst rightRight = lineContent.charCodeAt(column);\n\t\t\t\t\tif (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n\t\t\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Position(lineNumber, 1);\n\t}\n\n\tpublic static moveWordRight(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position, wordNavigationType: WordNavigationType): Position {\n\t\tlet lineNumber = position.lineNumber;\n\t\tlet column = position.column;\n\n\t\tlet movedDown = false;\n\t\tif (column === model.getLineMaxColumn(lineNumber)) {\n\t\t\tif (lineNumber < model.getLineCount()) {\n\t\t\t\tmovedDown = true;\n\t\t\t\tlineNumber = lineNumber + 1;\n\t\t\t\tcolumn = 1;\n\t\t\t}\n\t\t}\n\n\t\tlet nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n\n\t\tif (wordNavigationType === WordNavigationType.WordEnd) {\n\t\t\tif (nextWordOnLine && nextWordOnLine.wordType === WordType.Separator) {\n\t\t\t\tif (nextWordOnLine.end - nextWordOnLine.start === 1 && nextWordOnLine.nextCharClass === WordCharacterClass.Regular) {\n\t\t\t\t\t// Skip over a word made up of one single separator and followed by a regular character\n\t\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nextWordOnLine) {\n\t\t\t\tcolumn = nextWordOnLine.end + 1;\n\t\t\t} else {\n\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t}\n\t\t} else if (wordNavigationType === WordNavigationType.WordAccessibility) {\n\t\t\tif (movedDown) {\n\t\t\t\t// If we move to the next line, pretend that the cursor is right before the first character.\n\t\t\t\t// This is needed when the first word starts right at the first character - and in order not to miss it,\n\t\t\t\t// we need to start before.\n\t\t\t\tcolumn = 0;\n\t\t\t}\n\n\t\t\twhile (\n\t\t\t\tnextWordOnLine\n\t\t\t\t&& (nextWordOnLine.wordType === WordType.Separator\n\t\t\t\t\t|| nextWordOnLine.start + 1 <= column\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\t// Skip over a word made up of one single separator\n\t\t\t\t// Also skip over word if it begins before current cursor position to ascertain we're moving forward at least 1 character.\n\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n\t\t\t}\n\n\t\t\tif (nextWordOnLine) {\n\t\t\t\tcolumn = nextWordOnLine.start + 1;\n\t\t\t} else {\n\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t}\n\t\t} else {\n\t\t\tif (nextWordOnLine && !movedDown && column >= nextWordOnLine.start + 1) {\n\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n\t\t\t}\n\t\t\tif (nextWordOnLine) {\n\t\t\t\tcolumn = nextWordOnLine.start + 1;\n\t\t\t} else {\n\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t}\n\t\t}\n\n\t\treturn new Position(lineNumber, column);\n\t}\n\n\tpublic static _moveWordPartRight(model: ICursorSimpleModel, position: Position): Position {\n\t\tconst lineNumber = position.lineNumber;\n\t\tconst maxColumn = model.getLineMaxColumn(lineNumber);\n\n\t\tif (position.column === maxColumn) {\n\t\t\treturn (lineNumber < model.getLineCount() ? new Position(lineNumber + 1, 1) : position);\n\t\t}\n\n\t\tconst lineContent = model.getLineContent(lineNumber);\n\t\tfor (let column = position.column + 1; column < maxColumn; column++) {\n\t\t\tconst left = lineContent.charCodeAt(column - 2);\n\t\t\tconst right = lineContent.charCodeAt(column - 1);\n\n\t\t\tif (left !== CharCode.Underline && right === CharCode.Underline) {\n\t\t\t\t// snake_case_variables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif (left !== CharCode.Dash && right === CharCode.Dash) {\n\t\t\t\t// kebab-case-variables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n\t\t\t\t// camelCaseVariables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n\t\t\t\t// thisIsACamelCaseWithOneLetterWords\n\t\t\t\tif (column + 1 < maxColumn) {\n\t\t\t\t\tconst rightRight = lineContent.charCodeAt(column);\n\t\t\t\t\tif (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n\t\t\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Position(lineNumber, maxColumn);\n\t}\n\n\tprotected static _deleteWordLeftWhitespace(model: ICursorSimpleModel, position: Position): Range | null {\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\tconst startIndex = position.column - 2;\n\t\tconst lastNonWhitespace = strings.lastNonWhitespaceIndex(lineContent, startIndex);\n\t\tif (lastNonWhitespace + 1 < startIndex) {\n\t\t\treturn new Range(position.lineNumber, lastNonWhitespace + 2, position.lineNumber, position.column);\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static deleteWordLeft(ctx: DeleteWordContext, wordNavigationType: WordNavigationType): Range | null {\n\t\tconst wordSeparators = ctx.wordSeparators;\n\t\tconst model = ctx.model;\n\t\tconst selection = ctx.selection;\n\t\tconst whitespaceHeuristics = ctx.whitespaceHeuristics;\n\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn selection;\n\t\t}\n\n\t\tif (DeleteOperations.isAutoClosingPairDelete(ctx.autoClosingDelete, ctx.autoClosingBrackets, ctx.autoClosingQuotes, ctx.autoClosingPairs.autoClosingPairsOpenByEnd, ctx.model, [ctx.selection], ctx.autoClosedCharacters)) {\n\t\t\tconst position = ctx.selection.getPosition();\n\t\t\treturn new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n\t\t}\n\n\t\tconst position = new Position(selection.positionLineNumber, selection.positionColumn);\n\n\t\tlet lineNumber = position.lineNumber;\n\t\tlet column = position.column;\n\n\t\tif (lineNumber === 1 && column === 1) {\n\t\t\t// Ignore deleting at beginning of file\n\t\t\treturn null;\n\t\t}\n\n\t\tif (whitespaceHeuristics) {\n\t\t\tconst r = this._deleteWordLeftWhitespace(model, position);\n\t\t\tif (r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\tlet prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n\n\t\tif (wordNavigationType === WordNavigationType.WordStart) {\n\t\t\tif (prevWordOnLine) {\n\t\t\t\tcolumn = prevWordOnLine.start + 1;\n\t\t\t} else {\n\t\t\t\tif (column > 1) {\n\t\t\t\t\tcolumn = 1;\n\t\t\t\t} else {\n\t\t\t\t\tlineNumber--;\n\t\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n\t\t\t\tprevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n\t\t\t}\n\t\t\tif (prevWordOnLine) {\n\t\t\t\tcolumn = prevWordOnLine.end + 1;\n\t\t\t} else {\n\t\t\t\tif (column > 1) {\n\t\t\t\t\tcolumn = 1;\n\t\t\t\t} else {\n\t\t\t\t\tlineNumber--;\n\t\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Range(lineNumber, column, position.lineNumber, position.column);\n\t}\n\n\tpublic static deleteInsideWord(wordSeparators: WordCharacterClassifier, model: ITextModel, selection: Selection): Range {\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn selection;\n\t\t}\n\n\t\tconst position = new Position(selection.positionLineNumber, selection.positionColumn);\n\n\t\tconst r = this._deleteInsideWordWhitespace(model, position);\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\n\t\treturn this._deleteInsideWordDetermineDeleteRange(wordSeparators, model, position);\n\t}\n\n\tprivate static _charAtIsWhitespace(str: string, index: number): boolean {\n\t\tconst charCode = str.charCodeAt(index);\n\t\treturn (charCode === CharCode.Space || charCode === CharCode.Tab);\n\t}\n\n\tprivate static _deleteInsideWordWhitespace(model: ICursorSimpleModel, position: Position): Range | null {\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\tconst lineContentLength = lineContent.length;\n\n\t\tif (lineContentLength === 0) {\n\t\t\t// empty line\n\t\t\treturn null;\n\t\t}\n\n\t\tlet leftIndex = Math.max(position.column - 2, 0);\n\t\tif (!this._charAtIsWhitespace(lineContent, leftIndex)) {\n\t\t\t// touches a non-whitespace character to the left\n\t\t\treturn null;\n\t\t}\n\n\t\tlet rightIndex = Math.min(position.column - 1, lineContentLength - 1);\n\t\tif (!this._charAtIsWhitespace(lineContent, rightIndex)) {\n\t\t\t// touches a non-whitespace character to the right\n\t\t\treturn null;\n\t\t}\n\n\t\t// walk over whitespace to the left\n\t\twhile (leftIndex > 0 && this._charAtIsWhitespace(lineContent, leftIndex - 1)) {\n\t\t\tleftIndex--;\n\t\t}\n\n\t\t// walk over whitespace to the right\n\t\twhile (rightIndex + 1 < lineContentLength && this._charAtIsWhitespace(lineContent, rightIndex + 1)) {\n\t\t\trightIndex++;\n\t\t}\n\n\t\treturn new Range(position.lineNumber, leftIndex + 1, position.lineNumber, rightIndex + 2);\n\t}\n\n\tprivate static _deleteInsideWordDetermineDeleteRange(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position): Range {\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\tconst lineLength = lineContent.length;\n\t\tif (lineLength === 0) {\n\t\t\t// empty line\n\t\t\tif (position.lineNumber > 1) {\n\t\t\t\treturn new Range(position.lineNumber - 1, model.getLineMaxColumn(position.lineNumber - 1), position.lineNumber, 1);\n\t\t\t} else {\n\t\t\t\tif (position.lineNumber < model.getLineCount()) {\n\t\t\t\t\treturn new Range(position.lineNumber, 1, position.lineNumber + 1, 1);\n\t\t\t\t} else {\n\t\t\t\t\t// empty model\n\t\t\t\t\treturn new Range(position.lineNumber, 1, position.lineNumber, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst touchesWord = (word: IFindWordResult) => {\n\t\t\treturn (word.start + 1 <= position.column && position.column <= word.end + 1);\n\t\t};\n\t\tconst createRangeWithPosition = (startColumn: number, endColumn: number) => {\n\t\t\tstartColumn = Math.min(startColumn, position.column);\n\t\t\tendColumn = Math.max(endColumn, position.column);\n\t\t\treturn new Range(position.lineNumber, startColumn, position.lineNumber, endColumn);\n\t\t};\n\t\tconst deleteWordAndAdjacentWhitespace = (word: IFindWordResult) => {\n\t\t\tlet startColumn = word.start + 1;\n\t\t\tlet endColumn = word.end + 1;\n\t\t\tlet expandedToTheRight = false;\n\t\t\twhile (endColumn - 1 < lineLength && this._charAtIsWhitespace(lineContent, endColumn - 1)) {\n\t\t\t\texpandedToTheRight = true;\n\t\t\t\tendColumn++;\n\t\t\t}\n\t\t\tif (!expandedToTheRight) {\n\t\t\t\twhile (startColumn > 1 && this._charAtIsWhitespace(lineContent, startColumn - 2)) {\n\t\t\t\t\tstartColumn--;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn createRangeWithPosition(startColumn, endColumn);\n\t\t};\n\n\t\tconst prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n\t\tif (prevWordOnLine && touchesWord(prevWordOnLine)) {\n\t\t\treturn deleteWordAndAdjacentWhitespace(prevWordOnLine);\n\t\t}\n\t\tconst nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n\t\tif (nextWordOnLine && touchesWord(nextWordOnLine)) {\n\t\t\treturn deleteWordAndAdjacentWhitespace(nextWordOnLine);\n\t\t}\n\t\tif (prevWordOnLine && nextWordOnLine) {\n\t\t\treturn createRangeWithPosition(prevWordOnLine.end + 1, nextWordOnLine.start + 1);\n\t\t}\n\t\tif (prevWordOnLine) {\n\t\t\treturn createRangeWithPosition(prevWordOnLine.start + 1, prevWordOnLine.end + 1);\n\t\t}\n\t\tif (nextWordOnLine) {\n\t\t\treturn createRangeWithPosition(nextWordOnLine.start + 1, nextWordOnLine.end + 1);\n\t\t}\n\n\t\treturn createRangeWithPosition(1, lineLength + 1);\n\t}\n\n\tpublic static _deleteWordPartLeft(model: ICursorSimpleModel, selection: Selection): Range {\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn selection;\n\t\t}\n\n\t\tconst pos = selection.getPosition();\n\t\tconst toPosition = WordOperations._moveWordPartLeft(model, pos);\n\t\treturn new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n\t}\n\n\tprivate static _findFirstNonWhitespaceChar(str: string, startIndex: number): number {\n\t\tconst len = str.length;\n\t\tfor (let chIndex = startIndex; chIndex < len; chIndex++) {\n\t\t\tconst ch = str.charAt(chIndex);\n\t\t\tif (ch !== ' ' && ch !== '\\t') {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\t\t}\n\t\treturn len;\n\t}\n\n\tprotected static _deleteWordRightWhitespace(model: ICursorSimpleModel, position: Position): Range | null {\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\tconst startIndex = position.column - 1;\n\t\tconst firstNonWhitespace = this._findFirstNonWhitespaceChar(lineContent, startIndex);\n\t\tif (startIndex + 1 < firstNonWhitespace) {\n\t\t\t// bingo\n\t\t\treturn new Range(position.lineNumber, position.column, position.lineNumber, firstNonWhitespace + 1);\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static deleteWordRight(ctx: DeleteWordContext, wordNavigationType: WordNavigationType): Range | null {\n\t\tconst wordSeparators = ctx.wordSeparators;\n\t\tconst model = ctx.model;\n\t\tconst selection = ctx.selection;\n\t\tconst whitespaceHeuristics = ctx.whitespaceHeuristics;\n\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn selection;\n\t\t}\n\n\t\tconst position = new Position(selection.positionLineNumber, selection.positionColumn);\n\n\t\tlet lineNumber = position.lineNumber;\n\t\tlet column = position.column;\n\n\t\tconst lineCount = model.getLineCount();\n\t\tconst maxColumn = model.getLineMaxColumn(lineNumber);\n\t\tif (lineNumber === lineCount && column === maxColumn) {\n\t\t\t// Ignore deleting at end of file\n\t\t\treturn null;\n\t\t}\n\n\t\tif (whitespaceHeuristics) {\n\t\t\tconst r = this._deleteWordRightWhitespace(model, position);\n\t\t\tif (r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\tlet nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n\n\t\tif (wordNavigationType === WordNavigationType.WordEnd) {\n\t\t\tif (nextWordOnLine) {\n\t\t\t\tcolumn = nextWordOnLine.end + 1;\n\t\t\t} else {\n\t\t\t\tif (column < maxColumn || lineNumber === lineCount) {\n\t\t\t\t\tcolumn = maxColumn;\n\t\t\t\t} else {\n\t\t\t\t\tlineNumber++;\n\t\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n\t\t\t\t\tif (nextWordOnLine) {\n\t\t\t\t\t\tcolumn = nextWordOnLine.start + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (nextWordOnLine && column >= nextWordOnLine.start + 1) {\n\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n\t\t\t}\n\t\t\tif (nextWordOnLine) {\n\t\t\t\tcolumn = nextWordOnLine.start + 1;\n\t\t\t} else {\n\t\t\t\tif (column < maxColumn || lineNumber === lineCount) {\n\t\t\t\t\tcolumn = maxColumn;\n\t\t\t\t} else {\n\t\t\t\t\tlineNumber++;\n\t\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n\t\t\t\t\tif (nextWordOnLine) {\n\t\t\t\t\t\tcolumn = nextWordOnLine.start + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Range(lineNumber, column, position.lineNumber, position.column);\n\t}\n\n\tpublic static _deleteWordPartRight(model: ICursorSimpleModel, selection: Selection): Range {\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn selection;\n\t\t}\n\n\t\tconst pos = selection.getPosition();\n\t\tconst toPosition = WordOperations._moveWordPartRight(model, pos);\n\t\treturn new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n\t}\n\n\tprivate static _createWordAtPosition(model: ITextModel, lineNumber: number, word: IFindWordResult): IWordAtPosition {\n\t\tconst range = new Range(lineNumber, word.start + 1, lineNumber, word.end + 1);\n\t\treturn {\n\t\t\tword: model.getValueInRange(range),\n\t\t\tstartColumn: range.startColumn,\n\t\t\tendColumn: range.endColumn\n\t\t};\n\t}\n\n\tpublic static getWordAtPosition(model: ITextModel, _wordSeparators: string, _intlSegmenterLocales: string[], position: Position): IWordAtPosition | null {\n\t\tconst wordSeparators = getMapForWordSeparators(_wordSeparators, _intlSegmenterLocales);\n\t\tconst prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n\t\tif (prevWord && prevWord.wordType === WordType.Regular && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n\t\t\treturn WordOperations._createWordAtPosition(model, position.lineNumber, prevWord);\n\t\t}\n\t\tconst nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n\t\tif (nextWord && nextWord.wordType === WordType.Regular && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n\t\t\treturn WordOperations._createWordAtPosition(model, position.lineNumber, nextWord);\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static word(config: CursorConfiguration, model: ICursorSimpleModel, cursor: SingleCursorState, inSelectionMode: boolean, position: Position): SingleCursorState {\n\t\tconst wordSeparators = getMapForWordSeparators(config.wordSeparators, config.wordSegmenterLocales);\n\t\tconst prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n\t\tconst nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n\n\t\tif (!inSelectionMode) {\n\t\t\t// Entering word selection for the first time\n\t\t\tlet startColumn: number;\n\t\t\tlet endColumn: number;\n\n\t\t\tif (prevWord && prevWord.wordType === WordType.Regular && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n\t\t\t\t// isTouchingPrevWord\n\t\t\t\tstartColumn = prevWord.start + 1;\n\t\t\t\tendColumn = prevWord.end + 1;\n\t\t\t} else if (nextWord && nextWord.wordType === WordType.Regular && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n\t\t\t\t// isTouchingNextWord\n\t\t\t\tstartColumn = nextWord.start + 1;\n\t\t\t\tendColumn = nextWord.end + 1;\n\t\t\t} else {\n\t\t\t\tif (prevWord) {\n\t\t\t\t\tstartColumn = prevWord.end + 1;\n\t\t\t\t} else {\n\t\t\t\t\tstartColumn = 1;\n\t\t\t\t}\n\t\t\t\tif (nextWord) {\n\t\t\t\t\tendColumn = nextWord.start + 1;\n\t\t\t\t} else {\n\t\t\t\t\tendColumn = model.getLineMaxColumn(position.lineNumber);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new SingleCursorState(\n\t\t\t\tnew Range(position.lineNumber, startColumn, position.lineNumber, endColumn), SelectionStartKind.Word, 0,\n\t\t\t\tnew Position(position.lineNumber, endColumn), 0\n\t\t\t);\n\t\t}\n\n\t\tlet startColumn: number;\n\t\tlet endColumn: number;\n\n\t\tif (prevWord && prevWord.wordType === WordType.Regular && prevWord.start < position.column - 1 && position.column - 1 < prevWord.end) {\n\t\t\t// isInsidePrevWord\n\t\t\tstartColumn = prevWord.start + 1;\n\t\t\tendColumn = prevWord.end + 1;\n\t\t} else if (nextWord && nextWord.wordType === WordType.Regular && nextWord.start < position.column - 1 && position.column - 1 < nextWord.end) {\n\t\t\t// isInsideNextWord\n\t\t\tstartColumn = nextWord.start + 1;\n\t\t\tendColumn = nextWord.end + 1;\n\t\t} else {\n\t\t\tstartColumn = position.column;\n\t\t\tendColumn = position.column;\n\t\t}\n\n\t\tconst lineNumber = position.lineNumber;\n\t\tlet column: number;\n\t\tif (cursor.selectionStart.containsPosition(position)) {\n\t\t\tcolumn = cursor.selectionStart.endColumn;\n\t\t} else if (position.isBeforeOrEqual(cursor.selectionStart.getStartPosition())) {\n\t\t\tcolumn = startColumn;\n\t\t\tconst possiblePosition = new Position(lineNumber, column);\n\t\t\tif (cursor.selectionStart.containsPosition(possiblePosition)) {\n\t\t\t\tcolumn = cursor.selectionStart.endColumn;\n\t\t\t}\n\t\t} else {\n\t\t\tcolumn = endColumn;\n\t\t\tconst possiblePosition = new Position(lineNumber, column);\n\t\t\tif (cursor.selectionStart.containsPosition(possiblePosition)) {\n\t\t\t\tcolumn = cursor.selectionStart.startColumn;\n\t\t\t}\n\t\t}\n\n\t\treturn cursor.move(true, lineNumber, column, 0);\n\t}\n}\n\nexport class WordPartOperations extends WordOperations {\n\tpublic static deleteWordPartLeft(ctx: DeleteWordContext): Range {\n\t\tconst candidates = enforceDefined([\n\t\t\tWordOperations.deleteWordLeft(ctx, WordNavigationType.WordStart),\n\t\t\tWordOperations.deleteWordLeft(ctx, WordNavigationType.WordEnd),\n\t\t\tWordOperations._deleteWordPartLeft(ctx.model, ctx.selection)\n\t\t]);\n\t\tcandidates.sort(Range.compareRangesUsingEnds);\n\t\treturn candidates[2];\n\t}\n\n\tpublic static deleteWordPartRight(ctx: DeleteWordContext): Range {\n\t\tconst candidates = enforceDefined([\n\t\t\tWordOperations.deleteWordRight(ctx, WordNavigationType.WordStart),\n\t\t\tWordOperations.deleteWordRight(ctx, WordNavigationType.WordEnd),\n\t\t\tWordOperations._deleteWordPartRight(ctx.model, ctx.selection)\n\t\t]);\n\t\tcandidates.sort(Range.compareRangesUsingStarts);\n\t\treturn candidates[0];\n\t}\n\n\tpublic static moveWordPartLeft(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position, hasMulticursor: boolean): Position {\n\t\tconst candidates = enforceDefined([\n\t\t\tWordOperations.moveWordLeft(wordSeparators, model, position, WordNavigationType.WordStart, hasMulticursor),\n\t\t\tWordOperations.moveWordLeft(wordSeparators, model, position, WordNavigationType.WordEnd, hasMulticursor),\n\t\t\tWordOperations._moveWordPartLeft(model, position)\n\t\t]);\n\t\tcandidates.sort(Position.compare);\n\t\treturn candidates[2];\n\t}\n\n\tpublic static moveWordPartRight(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position): Position {\n\t\tconst candidates = enforceDefined([\n\t\t\tWordOperations.moveWordRight(wordSeparators, model, position, WordNavigationType.WordStart),\n\t\t\tWordOperations.moveWordRight(wordSeparators, model, position, WordNavigationType.WordEnd),\n\t\t\tWordOperations._moveWordPartRight(model, position)\n\t\t]);\n\t\tcandidates.sort(Position.compare);\n\t\treturn candidates[0];\n\t}\n}\n\nfunction enforceDefined<T>(arr: Array<T | undefined | null>): T[] {\n\treturn <T[]>arr.filter(el => Boolean(el));\n}\n"],
  "mappings": "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",
  "names": ["WordType", "WordNavigationType", "position", "startColumn", "endColumn"]
}
