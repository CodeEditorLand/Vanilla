{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/diff/legacyLinesDiffComputer.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { assertFn, checkAdjacentItems } from \"../../../base/common/assert.js\";\nimport { CharCode } from \"../../../base/common/charCode.js\";\nimport {\n\ttype IDiffChange,\n\ttype IDiffResult,\n\ttype ISequence,\n\tLcsDiff,\n} from \"../../../base/common/diff/diff.js\";\nimport * as strings from \"../../../base/common/strings.js\";\nimport { LineRange } from \"../core/lineRange.js\";\nimport { Range } from \"../core/range.js\";\nimport {\n\ttype ILinesDiffComputer,\n\ttype ILinesDiffComputerOptions,\n\tLinesDiff,\n} from \"./linesDiffComputer.js\";\nimport { DetailedLineRangeMapping, RangeMapping } from \"./rangeMapping.js\";\n\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\n\nexport class LegacyLinesDiffComputer implements ILinesDiffComputer {\n\tcomputeDiff(\n\t\toriginalLines: string[],\n\t\tmodifiedLines: string[],\n\t\toptions: ILinesDiffComputerOptions,\n\t): LinesDiff {\n\t\tconst diffComputer = new DiffComputer(originalLines, modifiedLines, {\n\t\t\tmaxComputationTime: options.maxComputationTimeMs,\n\t\t\tshouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,\n\t\t\tshouldComputeCharChanges: true,\n\t\t\tshouldMakePrettyDiff: true,\n\t\t\tshouldPostProcessCharChanges: true,\n\t\t});\n\t\tconst result = diffComputer.computeDiff();\n\t\tconst changes: DetailedLineRangeMapping[] = [];\n\t\tlet lastChange: DetailedLineRangeMapping | null = null;\n\n\t\tfor (const c of result.changes) {\n\t\t\tlet originalRange: LineRange;\n\t\t\tif (c.originalEndLineNumber === 0) {\n\t\t\t\t// Insertion\n\t\t\t\toriginalRange = new LineRange(\n\t\t\t\t\tc.originalStartLineNumber + 1,\n\t\t\t\t\tc.originalStartLineNumber + 1,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\toriginalRange = new LineRange(\n\t\t\t\t\tc.originalStartLineNumber,\n\t\t\t\t\tc.originalEndLineNumber + 1,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tlet modifiedRange: LineRange;\n\t\t\tif (c.modifiedEndLineNumber === 0) {\n\t\t\t\t// Deletion\n\t\t\t\tmodifiedRange = new LineRange(\n\t\t\t\t\tc.modifiedStartLineNumber + 1,\n\t\t\t\t\tc.modifiedStartLineNumber + 1,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tmodifiedRange = new LineRange(\n\t\t\t\t\tc.modifiedStartLineNumber,\n\t\t\t\t\tc.modifiedEndLineNumber + 1,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tlet change = new DetailedLineRangeMapping(\n\t\t\t\toriginalRange,\n\t\t\t\tmodifiedRange,\n\t\t\t\tc.charChanges?.map(\n\t\t\t\t\t(c) =>\n\t\t\t\t\t\tnew RangeMapping(\n\t\t\t\t\t\t\tnew Range(\n\t\t\t\t\t\t\t\tc.originalStartLineNumber,\n\t\t\t\t\t\t\t\tc.originalStartColumn,\n\t\t\t\t\t\t\t\tc.originalEndLineNumber,\n\t\t\t\t\t\t\t\tc.originalEndColumn,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tnew Range(\n\t\t\t\t\t\t\t\tc.modifiedStartLineNumber,\n\t\t\t\t\t\t\t\tc.modifiedStartColumn,\n\t\t\t\t\t\t\t\tc.modifiedEndLineNumber,\n\t\t\t\t\t\t\t\tc.modifiedEndColumn,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t);\n\t\t\tif (lastChange) {\n\t\t\t\tif (\n\t\t\t\t\tlastChange.modified.endLineNumberExclusive ===\n\t\t\t\t\t\tchange.modified.startLineNumber ||\n\t\t\t\t\tlastChange.original.endLineNumberExclusive ===\n\t\t\t\t\t\tchange.original.startLineNumber\n\t\t\t\t) {\n\t\t\t\t\t// join touching diffs. Probably moving diffs up/down in the algorithm causes touching diffs.\n\t\t\t\t\tchange = new DetailedLineRangeMapping(\n\t\t\t\t\t\tlastChange.original.join(change.original),\n\t\t\t\t\t\tlastChange.modified.join(change.modified),\n\t\t\t\t\t\tlastChange.innerChanges && change.innerChanges\n\t\t\t\t\t\t\t? lastChange.innerChanges.concat(\n\t\t\t\t\t\t\t\t\tchange.innerChanges,\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t);\n\t\t\t\t\tchanges.pop();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchanges.push(change);\n\t\t\tlastChange = change;\n\t\t}\n\n\t\tassertFn(() => {\n\t\t\treturn checkAdjacentItems(\n\t\t\t\tchanges,\n\t\t\t\t(m1, m2) =>\n\t\t\t\t\tm2.original.startLineNumber -\n\t\t\t\t\t\tm1.original.endLineNumberExclusive ===\n\t\t\t\t\t\tm2.modified.startLineNumber -\n\t\t\t\t\t\t\tm1.modified.endLineNumberExclusive &&\n\t\t\t\t\t// There has to be an unchanged line in between (otherwise both diffs should have been joined)\n\t\t\t\t\tm1.original.endLineNumberExclusive <\n\t\t\t\t\t\tm2.original.startLineNumber &&\n\t\t\t\t\tm1.modified.endLineNumberExclusive <\n\t\t\t\t\t\tm2.modified.startLineNumber,\n\t\t\t);\n\t\t});\n\n\t\treturn new LinesDiff(changes, [], result.quitEarly);\n\t}\n}\n\nexport interface IDiffComputationResult {\n\tquitEarly: boolean;\n\tidentical: boolean;\n\n\t/**\n\t * The changes as (legacy) line change array.\n\t * @deprecated Use `changes2` instead.\n\t */\n\tchanges: ILineChange[];\n\n\t/**\n\t * The changes as (modern) line range mapping array.\n\t */\n\tchanges2: readonly DetailedLineRangeMapping[];\n}\n\n/**\n * A change\n */\nexport interface IChange {\n\treadonly originalStartLineNumber: number;\n\treadonly originalEndLineNumber: number;\n\treadonly modifiedStartLineNumber: number;\n\treadonly modifiedEndLineNumber: number;\n}\n\n/**\n * A character level change.\n */\nexport interface ICharChange extends IChange {\n\treadonly originalStartColumn: number;\n\treadonly originalEndColumn: number;\n\treadonly modifiedStartColumn: number;\n\treadonly modifiedEndColumn: number;\n}\n\n/**\n * A line change\n */\nexport interface ILineChange extends IChange {\n\treadonly charChanges: ICharChange[] | undefined;\n}\n\nexport interface IDiffComputerResult {\n\tquitEarly: boolean;\n\tchanges: ILineChange[];\n}\n\nfunction computeDiff(\n\toriginalSequence: ISequence,\n\tmodifiedSequence: ISequence,\n\tcontinueProcessingPredicate: () => boolean,\n\tpretty: boolean,\n): IDiffResult {\n\tconst diffAlgo = new LcsDiff(\n\t\toriginalSequence,\n\t\tmodifiedSequence,\n\t\tcontinueProcessingPredicate,\n\t);\n\treturn diffAlgo.ComputeDiff(pretty);\n}\n\nclass LineSequence implements ISequence {\n\tpublic readonly lines: string[];\n\tprivate readonly _startColumns: number[];\n\tprivate readonly _endColumns: number[];\n\n\tconstructor(lines: string[]) {\n\t\tconst startColumns: number[] = [];\n\t\tconst endColumns: number[] = [];\n\t\tfor (let i = 0, length = lines.length; i < length; i++) {\n\t\t\tstartColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n\t\t\tendColumns[i] = getLastNonBlankColumn(lines[i], 1);\n\t\t}\n\t\tthis.lines = lines;\n\t\tthis._startColumns = startColumns;\n\t\tthis._endColumns = endColumns;\n\t}\n\n\tpublic getElements(): Int32Array | number[] | string[] {\n\t\tconst elements: string[] = [];\n\t\tfor (let i = 0, len = this.lines.length; i < len; i++) {\n\t\t\telements[i] = this.lines[i].substring(\n\t\t\t\tthis._startColumns[i] - 1,\n\t\t\t\tthis._endColumns[i] - 1,\n\t\t\t);\n\t\t}\n\t\treturn elements;\n\t}\n\n\tpublic getStrictElement(index: number): string {\n\t\treturn this.lines[index];\n\t}\n\n\tpublic getStartLineNumber(i: number): number {\n\t\treturn i + 1;\n\t}\n\n\tpublic getEndLineNumber(i: number): number {\n\t\treturn i + 1;\n\t}\n\n\tpublic createCharSequence(\n\t\tshouldIgnoreTrimWhitespace: boolean,\n\t\tstartIndex: number,\n\t\tendIndex: number,\n\t): CharSequence {\n\t\tconst charCodes: number[] = [];\n\t\tconst lineNumbers: number[] = [];\n\t\tconst columns: number[] = [];\n\t\tlet len = 0;\n\t\tfor (let index = startIndex; index <= endIndex; index++) {\n\t\t\tconst lineContent = this.lines[index];\n\t\t\tconst startColumn = shouldIgnoreTrimWhitespace\n\t\t\t\t? this._startColumns[index]\n\t\t\t\t: 1;\n\t\t\tconst endColumn = shouldIgnoreTrimWhitespace\n\t\t\t\t? this._endColumns[index]\n\t\t\t\t: lineContent.length + 1;\n\t\t\tfor (let col = startColumn; col < endColumn; col++) {\n\t\t\t\tcharCodes[len] = lineContent.charCodeAt(col - 1);\n\t\t\t\tlineNumbers[len] = index + 1;\n\t\t\t\tcolumns[len] = col;\n\t\t\t\tlen++;\n\t\t\t}\n\t\t\tif (!shouldIgnoreTrimWhitespace && index < endIndex) {\n\t\t\t\t// Add \\n if trim whitespace is not ignored\n\t\t\t\tcharCodes[len] = CharCode.LineFeed;\n\t\t\t\tlineNumbers[len] = index + 1;\n\t\t\t\tcolumns[len] = lineContent.length + 1;\n\t\t\t\tlen++;\n\t\t\t}\n\t\t}\n\t\treturn new CharSequence(charCodes, lineNumbers, columns);\n\t}\n}\n\nclass CharSequence implements ISequence {\n\tprivate readonly _charCodes: number[];\n\tprivate readonly _lineNumbers: number[];\n\tprivate readonly _columns: number[];\n\n\tconstructor(charCodes: number[], lineNumbers: number[], columns: number[]) {\n\t\tthis._charCodes = charCodes;\n\t\tthis._lineNumbers = lineNumbers;\n\t\tthis._columns = columns;\n\t}\n\n\tpublic toString() {\n\t\treturn (\n\t\t\t\"[\" +\n\t\t\tthis._charCodes\n\t\t\t\t.map(\n\t\t\t\t\t(s, idx) =>\n\t\t\t\t\t\t(s === CharCode.LineFeed\n\t\t\t\t\t\t\t? \"\\\\n\"\n\t\t\t\t\t\t\t: String.fromCharCode(s)) +\n\t\t\t\t\t\t`-(${this._lineNumbers[idx]},${this._columns[idx]})`,\n\t\t\t\t)\n\t\t\t\t.join(\", \") +\n\t\t\t\"]\"\n\t\t);\n\t}\n\n\tprivate _assertIndex(index: number, arr: number[]): void {\n\t\tif (index < 0 || index >= arr.length) {\n\t\t\tthrow new Error(`Illegal index`);\n\t\t}\n\t}\n\n\tpublic getElements(): Int32Array | number[] | string[] {\n\t\treturn this._charCodes;\n\t}\n\n\tpublic getStartLineNumber(i: number): number {\n\t\tif (i > 0 && i === this._lineNumbers.length) {\n\t\t\t// the start line number of the element after the last element\n\t\t\t// is the end line number of the last element\n\t\t\treturn this.getEndLineNumber(i - 1);\n\t\t}\n\t\tthis._assertIndex(i, this._lineNumbers);\n\n\t\treturn this._lineNumbers[i];\n\t}\n\n\tpublic getEndLineNumber(i: number): number {\n\t\tif (i === -1) {\n\t\t\t// the end line number of the element before the first element\n\t\t\t// is the start line number of the first element\n\t\t\treturn this.getStartLineNumber(i + 1);\n\t\t}\n\t\tthis._assertIndex(i, this._lineNumbers);\n\n\t\tif (this._charCodes[i] === CharCode.LineFeed) {\n\t\t\treturn this._lineNumbers[i] + 1;\n\t\t}\n\t\treturn this._lineNumbers[i];\n\t}\n\n\tpublic getStartColumn(i: number): number {\n\t\tif (i > 0 && i === this._columns.length) {\n\t\t\t// the start column of the element after the last element\n\t\t\t// is the end column of the last element\n\t\t\treturn this.getEndColumn(i - 1);\n\t\t}\n\t\tthis._assertIndex(i, this._columns);\n\t\treturn this._columns[i];\n\t}\n\n\tpublic getEndColumn(i: number): number {\n\t\tif (i === -1) {\n\t\t\t// the end column of the element before the first element\n\t\t\t// is the start column of the first element\n\t\t\treturn this.getStartColumn(i + 1);\n\t\t}\n\t\tthis._assertIndex(i, this._columns);\n\n\t\tif (this._charCodes[i] === CharCode.LineFeed) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn this._columns[i] + 1;\n\t}\n}\n\nclass CharChange implements ICharChange {\n\tpublic originalStartLineNumber: number;\n\tpublic originalStartColumn: number;\n\tpublic originalEndLineNumber: number;\n\tpublic originalEndColumn: number;\n\n\tpublic modifiedStartLineNumber: number;\n\tpublic modifiedStartColumn: number;\n\tpublic modifiedEndLineNumber: number;\n\tpublic modifiedEndColumn: number;\n\n\tconstructor(\n\t\toriginalStartLineNumber: number,\n\t\toriginalStartColumn: number,\n\t\toriginalEndLineNumber: number,\n\t\toriginalEndColumn: number,\n\t\tmodifiedStartLineNumber: number,\n\t\tmodifiedStartColumn: number,\n\t\tmodifiedEndLineNumber: number,\n\t\tmodifiedEndColumn: number,\n\t) {\n\t\tthis.originalStartLineNumber = originalStartLineNumber;\n\t\tthis.originalStartColumn = originalStartColumn;\n\t\tthis.originalEndLineNumber = originalEndLineNumber;\n\t\tthis.originalEndColumn = originalEndColumn;\n\t\tthis.modifiedStartLineNumber = modifiedStartLineNumber;\n\t\tthis.modifiedStartColumn = modifiedStartColumn;\n\t\tthis.modifiedEndLineNumber = modifiedEndLineNumber;\n\t\tthis.modifiedEndColumn = modifiedEndColumn;\n\t}\n\n\tpublic static createFromDiffChange(\n\t\tdiffChange: IDiffChange,\n\t\toriginalCharSequence: CharSequence,\n\t\tmodifiedCharSequence: CharSequence,\n\t): CharChange {\n\t\tconst originalStartLineNumber = originalCharSequence.getStartLineNumber(\n\t\t\tdiffChange.originalStart,\n\t\t);\n\t\tconst originalStartColumn = originalCharSequence.getStartColumn(\n\t\t\tdiffChange.originalStart,\n\t\t);\n\t\tconst originalEndLineNumber = originalCharSequence.getEndLineNumber(\n\t\t\tdiffChange.originalStart + diffChange.originalLength - 1,\n\t\t);\n\t\tconst originalEndColumn = originalCharSequence.getEndColumn(\n\t\t\tdiffChange.originalStart + diffChange.originalLength - 1,\n\t\t);\n\n\t\tconst modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(\n\t\t\tdiffChange.modifiedStart,\n\t\t);\n\t\tconst modifiedStartColumn = modifiedCharSequence.getStartColumn(\n\t\t\tdiffChange.modifiedStart,\n\t\t);\n\t\tconst modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(\n\t\t\tdiffChange.modifiedStart + diffChange.modifiedLength - 1,\n\t\t);\n\t\tconst modifiedEndColumn = modifiedCharSequence.getEndColumn(\n\t\t\tdiffChange.modifiedStart + diffChange.modifiedLength - 1,\n\t\t);\n\n\t\treturn new CharChange(\n\t\t\toriginalStartLineNumber,\n\t\t\toriginalStartColumn,\n\t\t\toriginalEndLineNumber,\n\t\t\toriginalEndColumn,\n\t\t\tmodifiedStartLineNumber,\n\t\t\tmodifiedStartColumn,\n\t\t\tmodifiedEndLineNumber,\n\t\t\tmodifiedEndColumn,\n\t\t);\n\t}\n}\n\nfunction postProcessCharChanges(rawChanges: IDiffChange[]): IDiffChange[] {\n\tif (rawChanges.length <= 1) {\n\t\treturn rawChanges;\n\t}\n\n\tconst result = [rawChanges[0]];\n\tlet prevChange = result[0];\n\n\tfor (let i = 1, len = rawChanges.length; i < len; i++) {\n\t\tconst currChange = rawChanges[i];\n\n\t\tconst originalMatchingLength =\n\t\t\tcurrChange.originalStart -\n\t\t\t(prevChange.originalStart + prevChange.originalLength);\n\t\tconst modifiedMatchingLength =\n\t\t\tcurrChange.modifiedStart -\n\t\t\t(prevChange.modifiedStart + prevChange.modifiedLength);\n\t\t// Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n\t\tconst matchingLength = Math.min(\n\t\t\toriginalMatchingLength,\n\t\t\tmodifiedMatchingLength,\n\t\t);\n\n\t\tif (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n\t\t\t// Merge the current change into the previous one\n\t\t\tprevChange.originalLength =\n\t\t\t\tcurrChange.originalStart +\n\t\t\t\tcurrChange.originalLength -\n\t\t\t\tprevChange.originalStart;\n\t\t\tprevChange.modifiedLength =\n\t\t\t\tcurrChange.modifiedStart +\n\t\t\t\tcurrChange.modifiedLength -\n\t\t\t\tprevChange.modifiedStart;\n\t\t} else {\n\t\t\t// Add the current change\n\t\t\tresult.push(currChange);\n\t\t\tprevChange = currChange;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nclass LineChange implements ILineChange {\n\tpublic originalStartLineNumber: number;\n\tpublic originalEndLineNumber: number;\n\tpublic modifiedStartLineNumber: number;\n\tpublic modifiedEndLineNumber: number;\n\tpublic charChanges: CharChange[] | undefined;\n\n\tconstructor(\n\t\toriginalStartLineNumber: number,\n\t\toriginalEndLineNumber: number,\n\t\tmodifiedStartLineNumber: number,\n\t\tmodifiedEndLineNumber: number,\n\t\tcharChanges: CharChange[] | undefined,\n\t) {\n\t\tthis.originalStartLineNumber = originalStartLineNumber;\n\t\tthis.originalEndLineNumber = originalEndLineNumber;\n\t\tthis.modifiedStartLineNumber = modifiedStartLineNumber;\n\t\tthis.modifiedEndLineNumber = modifiedEndLineNumber;\n\t\tthis.charChanges = charChanges;\n\t}\n\n\tpublic static createFromDiffResult(\n\t\tshouldIgnoreTrimWhitespace: boolean,\n\t\tdiffChange: IDiffChange,\n\t\toriginalLineSequence: LineSequence,\n\t\tmodifiedLineSequence: LineSequence,\n\t\tcontinueCharDiff: () => boolean,\n\t\tshouldComputeCharChanges: boolean,\n\t\tshouldPostProcessCharChanges: boolean,\n\t): LineChange {\n\t\tlet originalStartLineNumber: number;\n\t\tlet originalEndLineNumber: number;\n\t\tlet modifiedStartLineNumber: number;\n\t\tlet modifiedEndLineNumber: number;\n\t\tlet charChanges: CharChange[] | undefined;\n\n\t\tif (diffChange.originalLength === 0) {\n\t\t\toriginalStartLineNumber =\n\t\t\t\toriginalLineSequence.getStartLineNumber(\n\t\t\t\t\tdiffChange.originalStart,\n\t\t\t\t) - 1;\n\t\t\toriginalEndLineNumber = 0;\n\t\t} else {\n\t\t\toriginalStartLineNumber = originalLineSequence.getStartLineNumber(\n\t\t\t\tdiffChange.originalStart,\n\t\t\t);\n\t\t\toriginalEndLineNumber = originalLineSequence.getEndLineNumber(\n\t\t\t\tdiffChange.originalStart + diffChange.originalLength - 1,\n\t\t\t);\n\t\t}\n\n\t\tif (diffChange.modifiedLength === 0) {\n\t\t\tmodifiedStartLineNumber =\n\t\t\t\tmodifiedLineSequence.getStartLineNumber(\n\t\t\t\t\tdiffChange.modifiedStart,\n\t\t\t\t) - 1;\n\t\t\tmodifiedEndLineNumber = 0;\n\t\t} else {\n\t\t\tmodifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(\n\t\t\t\tdiffChange.modifiedStart,\n\t\t\t);\n\t\t\tmodifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(\n\t\t\t\tdiffChange.modifiedStart + diffChange.modifiedLength - 1,\n\t\t\t);\n\t\t}\n\n\t\tif (\n\t\t\tshouldComputeCharChanges &&\n\t\t\tdiffChange.originalLength > 0 &&\n\t\t\tdiffChange.originalLength < 20 &&\n\t\t\tdiffChange.modifiedLength > 0 &&\n\t\t\tdiffChange.modifiedLength < 20 &&\n\t\t\tcontinueCharDiff()\n\t\t) {\n\t\t\t// Compute character changes for diff chunks of at most 20 lines...\n\t\t\tconst originalCharSequence =\n\t\t\t\toriginalLineSequence.createCharSequence(\n\t\t\t\t\tshouldIgnoreTrimWhitespace,\n\t\t\t\t\tdiffChange.originalStart,\n\t\t\t\t\tdiffChange.originalStart + diffChange.originalLength - 1,\n\t\t\t\t);\n\t\t\tconst modifiedCharSequence =\n\t\t\t\tmodifiedLineSequence.createCharSequence(\n\t\t\t\t\tshouldIgnoreTrimWhitespace,\n\t\t\t\t\tdiffChange.modifiedStart,\n\t\t\t\t\tdiffChange.modifiedStart + diffChange.modifiedLength - 1,\n\t\t\t\t);\n\n\t\t\tif (\n\t\t\t\toriginalCharSequence.getElements().length > 0 &&\n\t\t\t\tmodifiedCharSequence.getElements().length > 0\n\t\t\t) {\n\t\t\t\tlet rawChanges = computeDiff(\n\t\t\t\t\toriginalCharSequence,\n\t\t\t\t\tmodifiedCharSequence,\n\t\t\t\t\tcontinueCharDiff,\n\t\t\t\t\ttrue,\n\t\t\t\t).changes;\n\n\t\t\t\tif (shouldPostProcessCharChanges) {\n\t\t\t\t\trawChanges = postProcessCharChanges(rawChanges);\n\t\t\t\t}\n\n\t\t\t\tcharChanges = [];\n\t\t\t\tfor (let i = 0, length = rawChanges.length; i < length; i++) {\n\t\t\t\t\tcharChanges.push(\n\t\t\t\t\t\tCharChange.createFromDiffChange(\n\t\t\t\t\t\t\trawChanges[i],\n\t\t\t\t\t\t\toriginalCharSequence,\n\t\t\t\t\t\t\tmodifiedCharSequence,\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new LineChange(\n\t\t\toriginalStartLineNumber,\n\t\t\toriginalEndLineNumber,\n\t\t\tmodifiedStartLineNumber,\n\t\t\tmodifiedEndLineNumber,\n\t\t\tcharChanges,\n\t\t);\n\t}\n}\n\nexport interface IDiffComputerOpts {\n\tshouldComputeCharChanges: boolean;\n\tshouldPostProcessCharChanges: boolean;\n\tshouldIgnoreTrimWhitespace: boolean;\n\tshouldMakePrettyDiff: boolean;\n\tmaxComputationTime: number;\n}\n\nexport class DiffComputer {\n\tprivate readonly shouldComputeCharChanges: boolean;\n\tprivate readonly shouldPostProcessCharChanges: boolean;\n\tprivate readonly shouldIgnoreTrimWhitespace: boolean;\n\tprivate readonly shouldMakePrettyDiff: boolean;\n\tprivate readonly originalLines: string[];\n\tprivate readonly modifiedLines: string[];\n\tprivate readonly original: LineSequence;\n\tprivate readonly modified: LineSequence;\n\tprivate readonly continueLineDiff: () => boolean;\n\tprivate readonly continueCharDiff: () => boolean;\n\n\tconstructor(\n\t\toriginalLines: string[],\n\t\tmodifiedLines: string[],\n\t\topts: IDiffComputerOpts,\n\t) {\n\t\tthis.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n\t\tthis.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n\t\tthis.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n\t\tthis.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n\t\tthis.originalLines = originalLines;\n\t\tthis.modifiedLines = modifiedLines;\n\t\tthis.original = new LineSequence(originalLines);\n\t\tthis.modified = new LineSequence(modifiedLines);\n\n\t\tthis.continueLineDiff = createContinueProcessingPredicate(\n\t\t\topts.maxComputationTime,\n\t\t);\n\t\tthis.continueCharDiff = createContinueProcessingPredicate(\n\t\t\topts.maxComputationTime === 0\n\t\t\t\t? 0\n\t\t\t\t: Math.min(opts.maxComputationTime, 5000),\n\t\t); // never run after 5s for character changes...\n\t}\n\n\tpublic computeDiff(): IDiffComputerResult {\n\t\tif (\n\t\t\tthis.original.lines.length === 1 &&\n\t\t\tthis.original.lines[0].length === 0\n\t\t) {\n\t\t\t// empty original => fast path\n\t\t\tif (\n\t\t\t\tthis.modified.lines.length === 1 &&\n\t\t\t\tthis.modified.lines[0].length === 0\n\t\t\t) {\n\t\t\t\treturn {\n\t\t\t\t\tquitEarly: false,\n\t\t\t\t\tchanges: [],\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tquitEarly: false,\n\t\t\t\tchanges: [\n\t\t\t\t\t{\n\t\t\t\t\t\toriginalStartLineNumber: 1,\n\t\t\t\t\t\toriginalEndLineNumber: 1,\n\t\t\t\t\t\tmodifiedStartLineNumber: 1,\n\t\t\t\t\t\tmodifiedEndLineNumber: this.modified.lines.length,\n\t\t\t\t\t\tcharChanges: undefined,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t};\n\t\t}\n\n\t\tif (\n\t\t\tthis.modified.lines.length === 1 &&\n\t\t\tthis.modified.lines[0].length === 0\n\t\t) {\n\t\t\t// empty modified => fast path\n\t\t\treturn {\n\t\t\t\tquitEarly: false,\n\t\t\t\tchanges: [\n\t\t\t\t\t{\n\t\t\t\t\t\toriginalStartLineNumber: 1,\n\t\t\t\t\t\toriginalEndLineNumber: this.original.lines.length,\n\t\t\t\t\t\tmodifiedStartLineNumber: 1,\n\t\t\t\t\t\tmodifiedEndLineNumber: 1,\n\t\t\t\t\t\tcharChanges: undefined,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t};\n\t\t}\n\n\t\tconst diffResult = computeDiff(\n\t\t\tthis.original,\n\t\t\tthis.modified,\n\t\t\tthis.continueLineDiff,\n\t\t\tthis.shouldMakePrettyDiff,\n\t\t);\n\t\tconst rawChanges = diffResult.changes;\n\t\tconst quitEarly = diffResult.quitEarly;\n\n\t\t// The diff is always computed with ignoring trim whitespace\n\t\t// This ensures we get the prettiest diff\n\n\t\tif (this.shouldIgnoreTrimWhitespace) {\n\t\t\tconst lineChanges: LineChange[] = [];\n\t\t\tfor (let i = 0, length = rawChanges.length; i < length; i++) {\n\t\t\t\tlineChanges.push(\n\t\t\t\t\tLineChange.createFromDiffResult(\n\t\t\t\t\t\tthis.shouldIgnoreTrimWhitespace,\n\t\t\t\t\t\trawChanges[i],\n\t\t\t\t\t\tthis.original,\n\t\t\t\t\t\tthis.modified,\n\t\t\t\t\t\tthis.continueCharDiff,\n\t\t\t\t\t\tthis.shouldComputeCharChanges,\n\t\t\t\t\t\tthis.shouldPostProcessCharChanges,\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tquitEarly: quitEarly,\n\t\t\t\tchanges: lineChanges,\n\t\t\t};\n\t\t}\n\n\t\t// Need to post-process and introduce changes where the trim whitespace is different\n\t\t// Note that we are looping starting at -1 to also cover the lines before the first change\n\t\tconst result: LineChange[] = [];\n\n\t\tlet originalLineIndex = 0;\n\t\tlet modifiedLineIndex = 0;\n\t\tfor (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {\n\t\t\tconst nextChange = i + 1 < len ? rawChanges[i + 1] : null;\n\t\t\tconst originalStop = nextChange\n\t\t\t\t? nextChange.originalStart\n\t\t\t\t: this.originalLines.length;\n\t\t\tconst modifiedStop = nextChange\n\t\t\t\t? nextChange.modifiedStart\n\t\t\t\t: this.modifiedLines.length;\n\n\t\t\twhile (\n\t\t\t\toriginalLineIndex < originalStop &&\n\t\t\t\tmodifiedLineIndex < modifiedStop\n\t\t\t) {\n\t\t\t\tconst originalLine = this.originalLines[originalLineIndex];\n\t\t\t\tconst modifiedLine = this.modifiedLines[modifiedLineIndex];\n\n\t\t\t\tif (originalLine !== modifiedLine) {\n\t\t\t\t\t// These lines differ only in trim whitespace\n\n\t\t\t\t\t// Check the leading whitespace\n\t\t\t\t\t{\n\t\t\t\t\t\tlet originalStartColumn = getFirstNonBlankColumn(\n\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tlet modifiedStartColumn = getFirstNonBlankColumn(\n\t\t\t\t\t\t\tmodifiedLine,\n\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t);\n\t\t\t\t\t\twhile (\n\t\t\t\t\t\t\toriginalStartColumn > 1 &&\n\t\t\t\t\t\t\tmodifiedStartColumn > 1\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst originalChar = originalLine.charCodeAt(\n\t\t\t\t\t\t\t\toriginalStartColumn - 2,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst modifiedChar = modifiedLine.charCodeAt(\n\t\t\t\t\t\t\t\tmodifiedStartColumn - 2,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (originalChar !== modifiedChar) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\toriginalStartColumn--;\n\t\t\t\t\t\t\tmodifiedStartColumn--;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\toriginalStartColumn > 1 ||\n\t\t\t\t\t\t\tmodifiedStartColumn > 1\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tthis._pushTrimWhitespaceCharChange(\n\t\t\t\t\t\t\t\tresult,\n\t\t\t\t\t\t\t\toriginalLineIndex + 1,\n\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\toriginalStartColumn,\n\t\t\t\t\t\t\t\tmodifiedLineIndex + 1,\n\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\tmodifiedStartColumn,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check the trailing whitespace\n\t\t\t\t\t{\n\t\t\t\t\t\tlet originalEndColumn = getLastNonBlankColumn(\n\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tlet modifiedEndColumn = getLastNonBlankColumn(\n\t\t\t\t\t\t\tmodifiedLine,\n\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst originalMaxColumn = originalLine.length + 1;\n\t\t\t\t\t\tconst modifiedMaxColumn = modifiedLine.length + 1;\n\t\t\t\t\t\twhile (\n\t\t\t\t\t\t\toriginalEndColumn < originalMaxColumn &&\n\t\t\t\t\t\t\tmodifiedEndColumn < modifiedMaxColumn\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst originalChar = originalLine.charCodeAt(\n\t\t\t\t\t\t\t\toriginalEndColumn - 1,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst modifiedChar = originalLine.charCodeAt(\n\t\t\t\t\t\t\t\tmodifiedEndColumn - 1,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (originalChar !== modifiedChar) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\toriginalEndColumn++;\n\t\t\t\t\t\t\tmodifiedEndColumn++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\toriginalEndColumn < originalMaxColumn ||\n\t\t\t\t\t\t\tmodifiedEndColumn < modifiedMaxColumn\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tthis._pushTrimWhitespaceCharChange(\n\t\t\t\t\t\t\t\tresult,\n\t\t\t\t\t\t\t\toriginalLineIndex + 1,\n\t\t\t\t\t\t\t\toriginalEndColumn,\n\t\t\t\t\t\t\t\toriginalMaxColumn,\n\t\t\t\t\t\t\t\tmodifiedLineIndex + 1,\n\t\t\t\t\t\t\t\tmodifiedEndColumn,\n\t\t\t\t\t\t\t\tmodifiedMaxColumn,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\toriginalLineIndex++;\n\t\t\t\tmodifiedLineIndex++;\n\t\t\t}\n\n\t\t\tif (nextChange) {\n\t\t\t\t// Emit the actual change\n\t\t\t\tresult.push(\n\t\t\t\t\tLineChange.createFromDiffResult(\n\t\t\t\t\t\tthis.shouldIgnoreTrimWhitespace,\n\t\t\t\t\t\tnextChange,\n\t\t\t\t\t\tthis.original,\n\t\t\t\t\t\tthis.modified,\n\t\t\t\t\t\tthis.continueCharDiff,\n\t\t\t\t\t\tthis.shouldComputeCharChanges,\n\t\t\t\t\t\tthis.shouldPostProcessCharChanges,\n\t\t\t\t\t),\n\t\t\t\t);\n\n\t\t\t\toriginalLineIndex += nextChange.originalLength;\n\t\t\t\tmodifiedLineIndex += nextChange.modifiedLength;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tquitEarly: quitEarly,\n\t\t\tchanges: result,\n\t\t};\n\t}\n\n\tprivate _pushTrimWhitespaceCharChange(\n\t\tresult: LineChange[],\n\t\toriginalLineNumber: number,\n\t\toriginalStartColumn: number,\n\t\toriginalEndColumn: number,\n\t\tmodifiedLineNumber: number,\n\t\tmodifiedStartColumn: number,\n\t\tmodifiedEndColumn: number,\n\t): void {\n\t\tif (\n\t\t\tthis._mergeTrimWhitespaceCharChange(\n\t\t\t\tresult,\n\t\t\t\toriginalLineNumber,\n\t\t\t\toriginalStartColumn,\n\t\t\t\toriginalEndColumn,\n\t\t\t\tmodifiedLineNumber,\n\t\t\t\tmodifiedStartColumn,\n\t\t\t\tmodifiedEndColumn,\n\t\t\t)\n\t\t) {\n\t\t\t// Merged into previous\n\t\t\treturn;\n\t\t}\n\n\t\tlet charChanges: CharChange[] | undefined;\n\t\tif (this.shouldComputeCharChanges) {\n\t\t\tcharChanges = [\n\t\t\t\tnew CharChange(\n\t\t\t\t\toriginalLineNumber,\n\t\t\t\t\toriginalStartColumn,\n\t\t\t\t\toriginalLineNumber,\n\t\t\t\t\toriginalEndColumn,\n\t\t\t\t\tmodifiedLineNumber,\n\t\t\t\t\tmodifiedStartColumn,\n\t\t\t\t\tmodifiedLineNumber,\n\t\t\t\t\tmodifiedEndColumn,\n\t\t\t\t),\n\t\t\t];\n\t\t}\n\t\tresult.push(\n\t\t\tnew LineChange(\n\t\t\t\toriginalLineNumber,\n\t\t\t\toriginalLineNumber,\n\t\t\t\tmodifiedLineNumber,\n\t\t\t\tmodifiedLineNumber,\n\t\t\t\tcharChanges,\n\t\t\t),\n\t\t);\n\t}\n\n\tprivate _mergeTrimWhitespaceCharChange(\n\t\tresult: LineChange[],\n\t\toriginalLineNumber: number,\n\t\toriginalStartColumn: number,\n\t\toriginalEndColumn: number,\n\t\tmodifiedLineNumber: number,\n\t\tmodifiedStartColumn: number,\n\t\tmodifiedEndColumn: number,\n\t): boolean {\n\t\tconst len = result.length;\n\t\tif (len === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst prevChange = result[len - 1];\n\n\t\tif (\n\t\t\tprevChange.originalEndLineNumber === 0 ||\n\t\t\tprevChange.modifiedEndLineNumber === 0\n\t\t) {\n\t\t\t// Don't merge with inserts/deletes\n\t\t\treturn false;\n\t\t}\n\n\t\tif (\n\t\t\tprevChange.originalEndLineNumber === originalLineNumber &&\n\t\t\tprevChange.modifiedEndLineNumber === modifiedLineNumber\n\t\t) {\n\t\t\tif (this.shouldComputeCharChanges && prevChange.charChanges) {\n\t\t\t\tprevChange.charChanges.push(\n\t\t\t\t\tnew CharChange(\n\t\t\t\t\t\toriginalLineNumber,\n\t\t\t\t\t\toriginalStartColumn,\n\t\t\t\t\t\toriginalLineNumber,\n\t\t\t\t\t\toriginalEndColumn,\n\t\t\t\t\t\tmodifiedLineNumber,\n\t\t\t\t\t\tmodifiedStartColumn,\n\t\t\t\t\t\tmodifiedLineNumber,\n\t\t\t\t\t\tmodifiedEndColumn,\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (\n\t\t\tprevChange.originalEndLineNumber + 1 === originalLineNumber &&\n\t\t\tprevChange.modifiedEndLineNumber + 1 === modifiedLineNumber\n\t\t) {\n\t\t\tprevChange.originalEndLineNumber = originalLineNumber;\n\t\t\tprevChange.modifiedEndLineNumber = modifiedLineNumber;\n\t\t\tif (this.shouldComputeCharChanges && prevChange.charChanges) {\n\t\t\t\tprevChange.charChanges.push(\n\t\t\t\t\tnew CharChange(\n\t\t\t\t\t\toriginalLineNumber,\n\t\t\t\t\t\toriginalStartColumn,\n\t\t\t\t\t\toriginalLineNumber,\n\t\t\t\t\t\toriginalEndColumn,\n\t\t\t\t\t\tmodifiedLineNumber,\n\t\t\t\t\t\tmodifiedStartColumn,\n\t\t\t\t\t\tmodifiedLineNumber,\n\t\t\t\t\t\tmodifiedEndColumn,\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n}\n\nfunction getFirstNonBlankColumn(txt: string, defaultValue: number): number {\n\tconst r = strings.firstNonWhitespaceIndex(txt);\n\tif (r === -1) {\n\t\treturn defaultValue;\n\t}\n\treturn r + 1;\n}\n\nfunction getLastNonBlankColumn(txt: string, defaultValue: number): number {\n\tconst r = strings.lastNonWhitespaceIndex(txt);\n\tif (r === -1) {\n\t\treturn defaultValue;\n\t}\n\treturn r + 2;\n}\n\nfunction createContinueProcessingPredicate(\n\tmaximumRuntime: number,\n): () => boolean {\n\tif (maximumRuntime === 0) {\n\t\treturn () => true;\n\t}\n\n\tconst startTime = Date.now();\n\treturn () => {\n\t\treturn Date.now() - startTime < maximumRuntime;\n\t};\n}\n"],
  "mappings": "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",
  "names": ["c"]
}
