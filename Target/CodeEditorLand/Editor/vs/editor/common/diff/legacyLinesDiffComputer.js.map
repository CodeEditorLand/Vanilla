{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/diff/legacyLinesDiffComputer.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport { IDiffChange, ISequence, LcsDiff, IDiffResult } from '../../../base/common/diff/diff.js';\nimport { ILinesDiffComputer, ILinesDiffComputerOptions, LinesDiff } from './linesDiffComputer.js';\nimport { RangeMapping, DetailedLineRangeMapping } from './rangeMapping.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { Range } from '../core/range.js';\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { LineRange } from '../core/lineRange.js';\n\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\n\nexport class LegacyLinesDiffComputer implements ILinesDiffComputer {\n\tcomputeDiff(originalLines: string[], modifiedLines: string[], options: ILinesDiffComputerOptions): LinesDiff {\n\t\tconst diffComputer = new DiffComputer(originalLines, modifiedLines, {\n\t\t\tmaxComputationTime: options.maxComputationTimeMs,\n\t\t\tshouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,\n\t\t\tshouldComputeCharChanges: true,\n\t\t\tshouldMakePrettyDiff: true,\n\t\t\tshouldPostProcessCharChanges: true,\n\t\t});\n\t\tconst result = diffComputer.computeDiff();\n\t\tconst changes: DetailedLineRangeMapping[] = [];\n\t\tlet lastChange: DetailedLineRangeMapping | null = null;\n\n\n\t\tfor (const c of result.changes) {\n\t\t\tlet originalRange: LineRange;\n\t\t\tif (c.originalEndLineNumber === 0) {\n\t\t\t\t// Insertion\n\t\t\t\toriginalRange = new LineRange(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1);\n\t\t\t} else {\n\t\t\t\toriginalRange = new LineRange(c.originalStartLineNumber, c.originalEndLineNumber + 1);\n\t\t\t}\n\n\t\t\tlet modifiedRange: LineRange;\n\t\t\tif (c.modifiedEndLineNumber === 0) {\n\t\t\t\t// Deletion\n\t\t\t\tmodifiedRange = new LineRange(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1);\n\t\t\t} else {\n\t\t\t\tmodifiedRange = new LineRange(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);\n\t\t\t}\n\n\t\t\tlet change = new DetailedLineRangeMapping(originalRange, modifiedRange, c.charChanges?.map(c => new RangeMapping(\n\t\t\t\tnew Range(c.originalStartLineNumber, c.originalStartColumn, c.originalEndLineNumber, c.originalEndColumn),\n\t\t\t\tnew Range(c.modifiedStartLineNumber, c.modifiedStartColumn, c.modifiedEndLineNumber, c.modifiedEndColumn),\n\t\t\t)));\n\t\t\tif (lastChange) {\n\t\t\t\tif (lastChange.modified.endLineNumberExclusive === change.modified.startLineNumber\n\t\t\t\t\t|| lastChange.original.endLineNumberExclusive === change.original.startLineNumber) {\n\t\t\t\t\t// join touching diffs. Probably moving diffs up/down in the algorithm causes touching diffs.\n\t\t\t\t\tchange = new DetailedLineRangeMapping(\n\t\t\t\t\t\tlastChange.original.join(change.original),\n\t\t\t\t\t\tlastChange.modified.join(change.modified),\n\t\t\t\t\t\tlastChange.innerChanges && change.innerChanges ?\n\t\t\t\t\t\t\tlastChange.innerChanges.concat(change.innerChanges) : undefined\n\t\t\t\t\t);\n\t\t\t\t\tchanges.pop();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchanges.push(change);\n\t\t\tlastChange = change;\n\t\t}\n\n\t\tassertFn(() => {\n\t\t\treturn checkAdjacentItems(changes,\n\t\t\t\t(m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive &&\n\t\t\t\t\t// There has to be an unchanged line in between (otherwise both diffs should have been joined)\n\t\t\t\t\tm1.original.endLineNumberExclusive < m2.original.startLineNumber &&\n\t\t\t\t\tm1.modified.endLineNumberExclusive < m2.modified.startLineNumber,\n\t\t\t);\n\t\t});\n\n\t\treturn new LinesDiff(changes, [], result.quitEarly);\n\t}\n}\n\nexport interface IDiffComputationResult {\n\tquitEarly: boolean;\n\tidentical: boolean;\n\n\t/**\n\t * The changes as (legacy) line change array.\n\t * @deprecated Use `changes2` instead.\n\t */\n\tchanges: ILineChange[];\n\n\t/**\n\t * The changes as (modern) line range mapping array.\n\t */\n\tchanges2: readonly DetailedLineRangeMapping[];\n}\n\n/**\n * A change\n */\nexport interface IChange {\n\treadonly originalStartLineNumber: number;\n\treadonly originalEndLineNumber: number;\n\treadonly modifiedStartLineNumber: number;\n\treadonly modifiedEndLineNumber: number;\n}\n\n/**\n * A character level change.\n */\nexport interface ICharChange extends IChange {\n\treadonly originalStartColumn: number;\n\treadonly originalEndColumn: number;\n\treadonly modifiedStartColumn: number;\n\treadonly modifiedEndColumn: number;\n}\n\n/**\n * A line change\n */\nexport interface ILineChange extends IChange {\n\treadonly charChanges: ICharChange[] | undefined;\n}\n\nexport interface IDiffComputerResult {\n\tquitEarly: boolean;\n\tchanges: ILineChange[];\n}\n\nfunction computeDiff(originalSequence: ISequence, modifiedSequence: ISequence, continueProcessingPredicate: () => boolean, pretty: boolean): IDiffResult {\n\tconst diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n\treturn diffAlgo.ComputeDiff(pretty);\n}\n\nclass LineSequence implements ISequence {\n\n\tpublic readonly lines: string[];\n\tprivate readonly _startColumns: number[];\n\tprivate readonly _endColumns: number[];\n\n\tconstructor(lines: string[]) {\n\t\tconst startColumns: number[] = [];\n\t\tconst endColumns: number[] = [];\n\t\tfor (let i = 0, length = lines.length; i < length; i++) {\n\t\t\tstartColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n\t\t\tendColumns[i] = getLastNonBlankColumn(lines[i], 1);\n\t\t}\n\t\tthis.lines = lines;\n\t\tthis._startColumns = startColumns;\n\t\tthis._endColumns = endColumns;\n\t}\n\n\tpublic getElements(): Int32Array | number[] | string[] {\n\t\tconst elements: string[] = [];\n\t\tfor (let i = 0, len = this.lines.length; i < len; i++) {\n\t\t\telements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\n\t\t}\n\t\treturn elements;\n\t}\n\n\tpublic getStrictElement(index: number): string {\n\t\treturn this.lines[index];\n\t}\n\n\tpublic getStartLineNumber(i: number): number {\n\t\treturn i + 1;\n\t}\n\n\tpublic getEndLineNumber(i: number): number {\n\t\treturn i + 1;\n\t}\n\n\tpublic createCharSequence(shouldIgnoreTrimWhitespace: boolean, startIndex: number, endIndex: number): CharSequence {\n\t\tconst charCodes: number[] = [];\n\t\tconst lineNumbers: number[] = [];\n\t\tconst columns: number[] = [];\n\t\tlet len = 0;\n\t\tfor (let index = startIndex; index <= endIndex; index++) {\n\t\t\tconst lineContent = this.lines[index];\n\t\t\tconst startColumn = (shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1);\n\t\t\tconst endColumn = (shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1);\n\t\t\tfor (let col = startColumn; col < endColumn; col++) {\n\t\t\t\tcharCodes[len] = lineContent.charCodeAt(col - 1);\n\t\t\t\tlineNumbers[len] = index + 1;\n\t\t\t\tcolumns[len] = col;\n\t\t\t\tlen++;\n\t\t\t}\n\t\t\tif (!shouldIgnoreTrimWhitespace && index < endIndex) {\n\t\t\t\t// Add \\n if trim whitespace is not ignored\n\t\t\t\tcharCodes[len] = CharCode.LineFeed;\n\t\t\t\tlineNumbers[len] = index + 1;\n\t\t\t\tcolumns[len] = lineContent.length + 1;\n\t\t\t\tlen++;\n\t\t\t}\n\t\t}\n\t\treturn new CharSequence(charCodes, lineNumbers, columns);\n\t}\n}\n\nclass CharSequence implements ISequence {\n\n\tprivate readonly _charCodes: number[];\n\tprivate readonly _lineNumbers: number[];\n\tprivate readonly _columns: number[];\n\n\tconstructor(charCodes: number[], lineNumbers: number[], columns: number[]) {\n\t\tthis._charCodes = charCodes;\n\t\tthis._lineNumbers = lineNumbers;\n\t\tthis._columns = columns;\n\t}\n\n\tpublic toString() {\n\t\treturn (\n\t\t\t'[' + this._charCodes.map((s, idx) => (s === CharCode.LineFeed ? '\\\\n' : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(', ') + ']'\n\t\t);\n\t}\n\n\tprivate _assertIndex(index: number, arr: number[]): void {\n\t\tif (index < 0 || index >= arr.length) {\n\t\t\tthrow new Error(`Illegal index`);\n\t\t}\n\t}\n\n\tpublic getElements(): Int32Array | number[] | string[] {\n\t\treturn this._charCodes;\n\t}\n\n\tpublic getStartLineNumber(i: number): number {\n\t\tif (i > 0 && i === this._lineNumbers.length) {\n\t\t\t// the start line number of the element after the last element\n\t\t\t// is the end line number of the last element\n\t\t\treturn this.getEndLineNumber(i - 1);\n\t\t}\n\t\tthis._assertIndex(i, this._lineNumbers);\n\n\t\treturn this._lineNumbers[i];\n\t}\n\n\tpublic getEndLineNumber(i: number): number {\n\t\tif (i === -1) {\n\t\t\t// the end line number of the element before the first element\n\t\t\t// is the start line number of the first element\n\t\t\treturn this.getStartLineNumber(i + 1);\n\t\t}\n\t\tthis._assertIndex(i, this._lineNumbers);\n\n\t\tif (this._charCodes[i] === CharCode.LineFeed) {\n\t\t\treturn this._lineNumbers[i] + 1;\n\t\t}\n\t\treturn this._lineNumbers[i];\n\t}\n\n\tpublic getStartColumn(i: number): number {\n\t\tif (i > 0 && i === this._columns.length) {\n\t\t\t// the start column of the element after the last element\n\t\t\t// is the end column of the last element\n\t\t\treturn this.getEndColumn(i - 1);\n\t\t}\n\t\tthis._assertIndex(i, this._columns);\n\t\treturn this._columns[i];\n\t}\n\n\tpublic getEndColumn(i: number): number {\n\t\tif (i === -1) {\n\t\t\t// the end column of the element before the first element\n\t\t\t// is the start column of the first element\n\t\t\treturn this.getStartColumn(i + 1);\n\t\t}\n\t\tthis._assertIndex(i, this._columns);\n\n\t\tif (this._charCodes[i] === CharCode.LineFeed) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn this._columns[i] + 1;\n\t}\n}\n\nclass CharChange implements ICharChange {\n\n\tpublic originalStartLineNumber: number;\n\tpublic originalStartColumn: number;\n\tpublic originalEndLineNumber: number;\n\tpublic originalEndColumn: number;\n\n\tpublic modifiedStartLineNumber: number;\n\tpublic modifiedStartColumn: number;\n\tpublic modifiedEndLineNumber: number;\n\tpublic modifiedEndColumn: number;\n\n\tconstructor(\n\t\toriginalStartLineNumber: number,\n\t\toriginalStartColumn: number,\n\t\toriginalEndLineNumber: number,\n\t\toriginalEndColumn: number,\n\t\tmodifiedStartLineNumber: number,\n\t\tmodifiedStartColumn: number,\n\t\tmodifiedEndLineNumber: number,\n\t\tmodifiedEndColumn: number\n\t) {\n\t\tthis.originalStartLineNumber = originalStartLineNumber;\n\t\tthis.originalStartColumn = originalStartColumn;\n\t\tthis.originalEndLineNumber = originalEndLineNumber;\n\t\tthis.originalEndColumn = originalEndColumn;\n\t\tthis.modifiedStartLineNumber = modifiedStartLineNumber;\n\t\tthis.modifiedStartColumn = modifiedStartColumn;\n\t\tthis.modifiedEndLineNumber = modifiedEndLineNumber;\n\t\tthis.modifiedEndColumn = modifiedEndColumn;\n\t}\n\n\tpublic static createFromDiffChange(diffChange: IDiffChange, originalCharSequence: CharSequence, modifiedCharSequence: CharSequence): CharChange {\n\t\tconst originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n\t\tconst originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n\t\tconst originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n\t\tconst originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n\n\t\tconst modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n\t\tconst modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n\t\tconst modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n\t\tconst modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n\n\t\treturn new CharChange(\n\t\t\toriginalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn,\n\t\t\tmodifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn,\n\t\t);\n\t}\n}\n\nfunction postProcessCharChanges(rawChanges: IDiffChange[]): IDiffChange[] {\n\tif (rawChanges.length <= 1) {\n\t\treturn rawChanges;\n\t}\n\n\tconst result = [rawChanges[0]];\n\tlet prevChange = result[0];\n\n\tfor (let i = 1, len = rawChanges.length; i < len; i++) {\n\t\tconst currChange = rawChanges[i];\n\n\t\tconst originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n\t\tconst modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n\t\t// Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n\t\tconst matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n\n\t\tif (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n\t\t\t// Merge the current change into the previous one\n\t\t\tprevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\n\t\t\tprevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\n\t\t} else {\n\t\t\t// Add the current change\n\t\t\tresult.push(currChange);\n\t\t\tprevChange = currChange;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nclass LineChange implements ILineChange {\n\tpublic originalStartLineNumber: number;\n\tpublic originalEndLineNumber: number;\n\tpublic modifiedStartLineNumber: number;\n\tpublic modifiedEndLineNumber: number;\n\tpublic charChanges: CharChange[] | undefined;\n\n\tconstructor(\n\t\toriginalStartLineNumber: number,\n\t\toriginalEndLineNumber: number,\n\t\tmodifiedStartLineNumber: number,\n\t\tmodifiedEndLineNumber: number,\n\t\tcharChanges: CharChange[] | undefined\n\t) {\n\t\tthis.originalStartLineNumber = originalStartLineNumber;\n\t\tthis.originalEndLineNumber = originalEndLineNumber;\n\t\tthis.modifiedStartLineNumber = modifiedStartLineNumber;\n\t\tthis.modifiedEndLineNumber = modifiedEndLineNumber;\n\t\tthis.charChanges = charChanges;\n\t}\n\n\tpublic static createFromDiffResult(shouldIgnoreTrimWhitespace: boolean, diffChange: IDiffChange, originalLineSequence: LineSequence, modifiedLineSequence: LineSequence, continueCharDiff: () => boolean, shouldComputeCharChanges: boolean, shouldPostProcessCharChanges: boolean): LineChange {\n\t\tlet originalStartLineNumber: number;\n\t\tlet originalEndLineNumber: number;\n\t\tlet modifiedStartLineNumber: number;\n\t\tlet modifiedEndLineNumber: number;\n\t\tlet charChanges: CharChange[] | undefined = undefined;\n\n\t\tif (diffChange.originalLength === 0) {\n\t\t\toriginalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n\t\t\toriginalEndLineNumber = 0;\n\t\t} else {\n\t\t\toriginalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n\t\t\toriginalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n\t\t}\n\n\t\tif (diffChange.modifiedLength === 0) {\n\t\t\tmodifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n\t\t\tmodifiedEndLineNumber = 0;\n\t\t} else {\n\t\t\tmodifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n\t\t\tmodifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n\t\t}\n\n\t\tif (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\n\t\t\t// Compute character changes for diff chunks of at most 20 lines...\n\t\t\tconst originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n\t\t\tconst modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n\n\t\t\tif (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {\n\t\t\t\tlet rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\n\n\t\t\t\tif (shouldPostProcessCharChanges) {\n\t\t\t\t\trawChanges = postProcessCharChanges(rawChanges);\n\t\t\t\t}\n\n\t\t\t\tcharChanges = [];\n\t\t\t\tfor (let i = 0, length = rawChanges.length; i < length; i++) {\n\t\t\t\t\tcharChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\n\t}\n}\n\nexport interface IDiffComputerOpts {\n\tshouldComputeCharChanges: boolean;\n\tshouldPostProcessCharChanges: boolean;\n\tshouldIgnoreTrimWhitespace: boolean;\n\tshouldMakePrettyDiff: boolean;\n\tmaxComputationTime: number;\n}\n\nexport class DiffComputer {\n\n\tprivate readonly shouldComputeCharChanges: boolean;\n\tprivate readonly shouldPostProcessCharChanges: boolean;\n\tprivate readonly shouldIgnoreTrimWhitespace: boolean;\n\tprivate readonly shouldMakePrettyDiff: boolean;\n\tprivate readonly originalLines: string[];\n\tprivate readonly modifiedLines: string[];\n\tprivate readonly original: LineSequence;\n\tprivate readonly modified: LineSequence;\n\tprivate readonly continueLineDiff: () => boolean;\n\tprivate readonly continueCharDiff: () => boolean;\n\n\tconstructor(originalLines: string[], modifiedLines: string[], opts: IDiffComputerOpts) {\n\t\tthis.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n\t\tthis.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n\t\tthis.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n\t\tthis.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n\t\tthis.originalLines = originalLines;\n\t\tthis.modifiedLines = modifiedLines;\n\t\tthis.original = new LineSequence(originalLines);\n\t\tthis.modified = new LineSequence(modifiedLines);\n\n\t\tthis.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\n\t\tthis.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\n\t}\n\n\tpublic computeDiff(): IDiffComputerResult {\n\n\t\tif (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\n\t\t\t// empty original => fast path\n\t\t\tif (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n\t\t\t\treturn {\n\t\t\t\t\tquitEarly: false,\n\t\t\t\t\tchanges: []\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tquitEarly: false,\n\t\t\t\tchanges: [{\n\t\t\t\t\toriginalStartLineNumber: 1,\n\t\t\t\t\toriginalEndLineNumber: 1,\n\t\t\t\t\tmodifiedStartLineNumber: 1,\n\t\t\t\t\tmodifiedEndLineNumber: this.modified.lines.length,\n\t\t\t\t\tcharChanges: undefined\n\t\t\t\t}]\n\t\t\t};\n\t\t}\n\n\t\tif (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n\t\t\t// empty modified => fast path\n\t\t\treturn {\n\t\t\t\tquitEarly: false,\n\t\t\t\tchanges: [{\n\t\t\t\t\toriginalStartLineNumber: 1,\n\t\t\t\t\toriginalEndLineNumber: this.original.lines.length,\n\t\t\t\t\tmodifiedStartLineNumber: 1,\n\t\t\t\t\tmodifiedEndLineNumber: 1,\n\t\t\t\t\tcharChanges: undefined\n\t\t\t\t}]\n\t\t\t};\n\t\t}\n\n\t\tconst diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\n\t\tconst rawChanges = diffResult.changes;\n\t\tconst quitEarly = diffResult.quitEarly;\n\n\t\t// The diff is always computed with ignoring trim whitespace\n\t\t// This ensures we get the prettiest diff\n\n\t\tif (this.shouldIgnoreTrimWhitespace) {\n\t\t\tconst lineChanges: LineChange[] = [];\n\t\t\tfor (let i = 0, length = rawChanges.length; i < length; i++) {\n\t\t\t\tlineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tquitEarly: quitEarly,\n\t\t\t\tchanges: lineChanges\n\t\t\t};\n\t\t}\n\n\t\t// Need to post-process and introduce changes where the trim whitespace is different\n\t\t// Note that we are looping starting at -1 to also cover the lines before the first change\n\t\tconst result: LineChange[] = [];\n\n\t\tlet originalLineIndex = 0;\n\t\tlet modifiedLineIndex = 0;\n\t\tfor (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {\n\t\t\tconst nextChange = (i + 1 < len ? rawChanges[i + 1] : null);\n\t\t\tconst originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);\n\t\t\tconst modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);\n\n\t\t\twhile (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\n\t\t\t\tconst originalLine = this.originalLines[originalLineIndex];\n\t\t\t\tconst modifiedLine = this.modifiedLines[modifiedLineIndex];\n\n\t\t\t\tif (originalLine !== modifiedLine) {\n\t\t\t\t\t// These lines differ only in trim whitespace\n\n\t\t\t\t\t// Check the leading whitespace\n\t\t\t\t\t{\n\t\t\t\t\t\tlet originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\n\t\t\t\t\t\tlet modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\n\t\t\t\t\t\twhile (originalStartColumn > 1 && modifiedStartColumn > 1) {\n\t\t\t\t\t\t\tconst originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n\t\t\t\t\t\t\tconst modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n\t\t\t\t\t\t\tif (originalChar !== modifiedChar) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\toriginalStartColumn--;\n\t\t\t\t\t\t\tmodifiedStartColumn--;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (originalStartColumn > 1 || modifiedStartColumn > 1) {\n\t\t\t\t\t\t\tthis._pushTrimWhitespaceCharChange(result,\n\t\t\t\t\t\t\t\toriginalLineIndex + 1, 1, originalStartColumn,\n\t\t\t\t\t\t\t\tmodifiedLineIndex + 1, 1, modifiedStartColumn\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check the trailing whitespace\n\t\t\t\t\t{\n\t\t\t\t\t\tlet originalEndColumn = getLastNonBlankColumn(originalLine, 1);\n\t\t\t\t\t\tlet modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\n\t\t\t\t\t\tconst originalMaxColumn = originalLine.length + 1;\n\t\t\t\t\t\tconst modifiedMaxColumn = modifiedLine.length + 1;\n\t\t\t\t\t\twhile (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\n\t\t\t\t\t\t\tconst originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n\t\t\t\t\t\t\tconst modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n\t\t\t\t\t\t\tif (originalChar !== modifiedChar) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\toriginalEndColumn++;\n\t\t\t\t\t\t\tmodifiedEndColumn++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\n\t\t\t\t\t\t\tthis._pushTrimWhitespaceCharChange(result,\n\t\t\t\t\t\t\t\toriginalLineIndex + 1, originalEndColumn, originalMaxColumn,\n\t\t\t\t\t\t\t\tmodifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\toriginalLineIndex++;\n\t\t\t\tmodifiedLineIndex++;\n\t\t\t}\n\n\t\t\tif (nextChange) {\n\t\t\t\t// Emit the actual change\n\t\t\t\tresult.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n\n\t\t\t\toriginalLineIndex += nextChange.originalLength;\n\t\t\t\tmodifiedLineIndex += nextChange.modifiedLength;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tquitEarly: quitEarly,\n\t\t\tchanges: result\n\t\t};\n\t}\n\n\tprivate _pushTrimWhitespaceCharChange(\n\t\tresult: LineChange[],\n\t\toriginalLineNumber: number, originalStartColumn: number, originalEndColumn: number,\n\t\tmodifiedLineNumber: number, modifiedStartColumn: number, modifiedEndColumn: number\n\t): void {\n\t\tif (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n\t\t\t// Merged into previous\n\t\t\treturn;\n\t\t}\n\n\t\tlet charChanges: CharChange[] | undefined = undefined;\n\t\tif (this.shouldComputeCharChanges) {\n\t\t\tcharChanges = [new CharChange(\n\t\t\t\toriginalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn,\n\t\t\t\tmodifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn\n\t\t\t)];\n\t\t}\n\t\tresult.push(new LineChange(\n\t\t\toriginalLineNumber, originalLineNumber,\n\t\t\tmodifiedLineNumber, modifiedLineNumber,\n\t\t\tcharChanges\n\t\t));\n\t}\n\n\tprivate _mergeTrimWhitespaceCharChange(\n\t\tresult: LineChange[],\n\t\toriginalLineNumber: number, originalStartColumn: number, originalEndColumn: number,\n\t\tmodifiedLineNumber: number, modifiedStartColumn: number, modifiedEndColumn: number\n\t): boolean {\n\t\tconst len = result.length;\n\t\tif (len === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst prevChange = result[len - 1];\n\n\t\tif (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n\t\t\t// Don't merge with inserts/deletes\n\t\t\treturn false;\n\t\t}\n\n\t\tif (prevChange.originalEndLineNumber === originalLineNumber && prevChange.modifiedEndLineNumber === modifiedLineNumber) {\n\t\t\tif (this.shouldComputeCharChanges && prevChange.charChanges) {\n\t\t\t\tprevChange.charChanges.push(new CharChange(\n\t\t\t\t\toriginalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn,\n\t\t\t\t\tmodifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn\n\t\t\t\t));\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n\t\t\tprevChange.originalEndLineNumber = originalLineNumber;\n\t\t\tprevChange.modifiedEndLineNumber = modifiedLineNumber;\n\t\t\tif (this.shouldComputeCharChanges && prevChange.charChanges) {\n\t\t\t\tprevChange.charChanges.push(new CharChange(\n\t\t\t\t\toriginalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn,\n\t\t\t\t\tmodifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn\n\t\t\t\t));\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n}\n\nfunction getFirstNonBlankColumn(txt: string, defaultValue: number): number {\n\tconst r = strings.firstNonWhitespaceIndex(txt);\n\tif (r === -1) {\n\t\treturn defaultValue;\n\t}\n\treturn r + 1;\n}\n\nfunction getLastNonBlankColumn(txt: string, defaultValue: number): number {\n\tconst r = strings.lastNonWhitespaceIndex(txt);\n\tif (r === -1) {\n\t\treturn defaultValue;\n\t}\n\treturn r + 2;\n}\n\nfunction createContinueProcessingPredicate(maximumRuntime: number): () => boolean {\n\tif (maximumRuntime === 0) {\n\t\treturn () => true;\n\t}\n\n\tconst startTime = Date.now();\n\treturn () => {\n\t\treturn Date.now() - startTime < maximumRuntime;\n\t};\n}\n"],
  "mappings": "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",
  "names": ["c"]
}
