import{BugIndicatingError as b}from"../../../../vs/base/common/errors.js";import{LineRange as a}from"../../../../vs/editor/common/core/lineRange.js";import{Position as t}from"../../../../vs/editor/common/core/position.js";import{Range as o}from"../../../../vs/editor/common/core/range.js";import{SingleTextEdit as E}from"../../../../vs/editor/common/core/textEdit.js";class l{static inverse(i,e,r){const n=[];let m=1,u=1;for(const h of i){const p=new l(new a(m,h.original.startLineNumber),new a(u,h.modified.startLineNumber));p.modified.isEmpty||n.push(p),m=h.original.endLineNumberExclusive,u=h.modified.endLineNumberExclusive}const d=new l(new a(m,e+1),new a(u,r+1));return d.modified.isEmpty||n.push(d),n}static clip(i,e,r){const n=[];for(const m of i){const u=m.original.intersect(e),d=m.modified.intersect(r);u&&!u.isEmpty&&d&&!d.isEmpty&&n.push(new l(u,d))}return n}original;modified;constructor(i,e){this.original=i,this.modified=e}toString(){return`{${this.original.toString()}->${this.modified.toString()}}`}flip(){return new l(this.modified,this.original)}join(i){return new l(this.original.join(i.original),this.modified.join(i.modified))}get changedLineCount(){return Math.max(this.original.length,this.modified.length)}toRangeMapping(){const i=this.original.toInclusiveRange(),e=this.modified.toInclusiveRange();if(i&&e)return new g(i,e);if(this.original.startLineNumber===1||this.modified.startLineNumber===1){if(!(this.modified.startLineNumber===1&&this.original.startLineNumber===1))throw new b("not a valid diff");return new g(new o(this.original.startLineNumber,1,this.original.endLineNumberExclusive,1),new o(this.modified.startLineNumber,1,this.modified.endLineNumberExclusive,1))}else return new g(new o(this.original.startLineNumber-1,Number.MAX_SAFE_INTEGER,this.original.endLineNumberExclusive-1,Number.MAX_SAFE_INTEGER),new o(this.modified.startLineNumber-1,Number.MAX_SAFE_INTEGER,this.modified.endLineNumberExclusive-1,Number.MAX_SAFE_INTEGER))}toRangeMapping2(i,e){if(R(this.original.endLineNumberExclusive,i)&&R(this.modified.endLineNumberExclusive,e))return new g(new o(this.original.startLineNumber,1,this.original.endLineNumberExclusive,1),new o(this.modified.startLineNumber,1,this.modified.endLineNumberExclusive,1));if(!this.original.isEmpty&&!this.modified.isEmpty)return new g(o.fromPositions(new t(this.original.startLineNumber,1),f(new t(this.original.endLineNumberExclusive-1,Number.MAX_SAFE_INTEGER),i)),o.fromPositions(new t(this.modified.startLineNumber,1),f(new t(this.modified.endLineNumberExclusive-1,Number.MAX_SAFE_INTEGER),e)));if(this.original.startLineNumber>1&&this.modified.startLineNumber>1)return new g(o.fromPositions(f(new t(this.original.startLineNumber-1,Number.MAX_SAFE_INTEGER),i),f(new t(this.original.endLineNumberExclusive-1,Number.MAX_SAFE_INTEGER),i)),o.fromPositions(f(new t(this.modified.startLineNumber-1,Number.MAX_SAFE_INTEGER),e),f(new t(this.modified.endLineNumberExclusive-1,Number.MAX_SAFE_INTEGER),e)));throw new b}}function f(s,i){if(s.lineNumber<1)return new t(1,1);if(s.lineNumber>i.length)return new t(i.length,i[i.length-1].length+1);const e=i[s.lineNumber-1];return s.column>e.length+1?new t(s.lineNumber,e.length+1):s}function R(s,i){return s>=1&&s<=i.length}class c extends l{static fromRangeMappings(i){const e=a.join(i.map(n=>a.fromRangeInclusive(n.originalRange))),r=a.join(i.map(n=>a.fromRangeInclusive(n.modifiedRange)));return new c(e,r,i)}innerChanges;constructor(i,e,r){super(i,e),this.innerChanges=r}flip(){return new c(this.modified,this.original,this.innerChanges?.map(i=>i.flip()))}withInnerChangesFromLineRanges(){return new c(this.original,this.modified,[this.toRangeMapping()])}}class g{static assertSorted(i){for(let e=1;e<i.length;e++){const r=i[e-1],n=i[e];if(!(r.originalRange.getEndPosition().isBeforeOrEqual(n.originalRange.getStartPosition())&&r.modifiedRange.getEndPosition().isBeforeOrEqual(n.modifiedRange.getStartPosition())))throw new b("Range mappings must be sorted")}}originalRange;modifiedRange;constructor(i,e){this.originalRange=i,this.modifiedRange=e}toString(){return`{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`}flip(){return new g(this.modifiedRange,this.originalRange)}toTextEdit(i){const e=i.getValueOfRange(this.modifiedRange);return new E(this.originalRange,e)}}export{c as DetailedLineRangeMapping,l as LineRangeMapping,g as RangeMapping};
