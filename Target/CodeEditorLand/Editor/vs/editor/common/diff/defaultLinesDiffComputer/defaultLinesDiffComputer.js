import{equals as B,groupAdjacentBy as F}from"../../../../base/common/arrays.js";import{assertFn as S,checkAdjacentItems as k}from"../../../../base/common/assert.js";import{LineRange as D}from"../../core/lineRange.js";import{OffsetRange as P}from"../../core/offsetRange.js";import"../../core/position.js";import{Range as I}from"../../core/range.js";import{LinesDiff as C,MovedText as z}from"../linesDiffComputer.js";import{DetailedLineRangeMapping as E,LineRangeMapping as V,RangeMapping as M}from"../rangeMapping.js";import{DateTimeout as G,InfiniteTimeout as J,SequenceDiff as b}from"./algorithms/diffAlgorithm.js";import{DynamicProgrammingDiffing as K}from"./algorithms/dynamicProgrammingDiffing.js";import{MyersDiffAlgorithm as Q}from"./algorithms/myersDiffAlgorithm.js";import{computeMovedLines as U}from"./computeMovedLines.js";import{extendDiffsToEntireWordIfAppropriate as X,optimizeSequenceDiffs as O,removeShortMatches as Y,removeVeryShortMatchingLinesBetweenDiffs as Z,removeVeryShortMatchingTextBetweenLongDiffs as _}from"./heuristicSequenceOptimizations.js";import{LineSequence as A}from"./lineSequence.js";import{LinesSliceCharSequence as W}from"./linesSliceCharSequence.js";class De{dynamicProgrammingDiffing=new K;myersDiffingAlgorithm=new Q;computeDiff(t,e,g){if(t.length<=1&&B(t,e,(r,f)=>r===f))return new C([],[],!1);if(t.length===1&&t[0].length===0||e.length===1&&e[0].length===0)return new C([new E(new D(1,t.length+1),new D(1,e.length+1),[new M(new I(1,1,t.length,t[t.length-1].length+1),new I(1,1,e.length,e[e.length-1].length+1))])],[],!1);const i=g.maxComputationTimeMs===0?J.instance:new G(g.maxComputationTimeMs),s=!g.ignoreTrimWhitespace,o=new Map;function h(r){let f=o.get(r);return f===void 0&&(f=o.size,o.set(r,f)),f}const l=t.map(r=>h(r.trim())),p=e.map(r=>h(r.trim())),R=new A(l,t),c=new A(p,e),m=R.length+c.length<1700?this.dynamicProgrammingDiffing.compute(R,c,i,(r,f)=>t[r]===e[f]?e[f].length===0?.1:1+Math.log(1+e[f].length):.99):this.myersDiffingAlgorithm.compute(R,c,i);let d=m.diffs,v=m.hitTimeout;d=O(R,c,d),d=Z(R,c,d);const q=[],y=r=>{if(s)for(let f=0;f<r;f++){const a=N+f,u=T+f;if(t[a]!==e[u]){const w=this.refineDiff(t,e,new b(new P(a,a+1),new P(u,u+1)),i,s);for(const H of w.mappings)q.push(H);w.hitTimeout&&(v=!0)}}};let N=0,T=0;for(const r of d){S(()=>r.seq1Range.start-N===r.seq2Range.start-T);const f=r.seq1Range.start-N;y(f),N=r.seq1Range.endExclusive,T=r.seq2Range.endExclusive;const a=this.refineDiff(t,e,r,i,s);a.hitTimeout&&(v=!0);for(const u of a.mappings)q.push(u)}y(t.length-N);const x=j(q,t,e);let L=[];return g.computeMoves&&(L=this.computeMoves(x,t,e,l,p,i,s)),S(()=>{function r(a,u){if(a.lineNumber<1||a.lineNumber>u.length)return!1;const w=u[a.lineNumber-1];return!(a.column<1||a.column>w.length+1)}function f(a,u){return!(a.startLineNumber<1||a.startLineNumber>u.length+1||a.endLineNumberExclusive<1||a.endLineNumberExclusive>u.length+1)}for(const a of x){if(!a.innerChanges)return!1;for(const u of a.innerChanges)if(!(r(u.modifiedRange.getStartPosition(),e)&&r(u.modifiedRange.getEndPosition(),e)&&r(u.originalRange.getStartPosition(),t)&&r(u.originalRange.getEndPosition(),t)))return!1;if(!f(a.modified,e)||!f(a.original,t))return!1}return!0}),new C(x,L,v)}computeMoves(t,e,g,i,s,o,h){return U(t,e,g,i,s,o).map(R=>{const c=this.refineDiff(e,g,new b(R.original.toOffsetRange(),R.modified.toOffsetRange()),o,h),m=j(c.mappings,e,g,!0);return new z(R,m)})}refineDiff(t,e,g,i,s){const h=ee(g).toRangeMapping2(t,e),l=new W(t,h.originalRange,s),p=new W(e,h.modifiedRange,s),R=l.length+p.length<500?this.dynamicProgrammingDiffing.compute(l,p,i):this.myersDiffingAlgorithm.compute(l,p,i),c=!1;let m=R.diffs;c&&b.assertSorted(m),m=O(l,p,m),c&&b.assertSorted(m),m=X(l,p,m),c&&b.assertSorted(m),m=Y(l,p,m),c&&b.assertSorted(m),m=_(l,p,m),c&&b.assertSorted(m);const d=m.map(v=>new M(l.translateRange(v.seq1Range),p.translateRange(v.seq2Range)));return c&&M.assertSorted(d),{mappings:d,hitTimeout:R.hitTimeout}}}function j(n,t,e,g=!1){const i=[];for(const s of F(n.map(o=>$(o,t,e)),(o,h)=>o.original.overlapOrTouch(h.original)||o.modified.overlapOrTouch(h.modified))){const o=s[0],h=s[s.length-1];i.push(new E(o.original.join(h.original),o.modified.join(h.modified),s.map(l=>l.innerChanges[0])))}return S(()=>!g&&i.length>0&&(i[0].modified.startLineNumber!==i[0].original.startLineNumber||e.length-i[i.length-1].modified.endLineNumberExclusive!==t.length-i[i.length-1].original.endLineNumberExclusive)?!1:k(i,(s,o)=>o.original.startLineNumber-s.original.endLineNumberExclusive===o.modified.startLineNumber-s.modified.endLineNumberExclusive&&s.original.endLineNumberExclusive<o.original.startLineNumber&&s.modified.endLineNumberExclusive<o.modified.startLineNumber)),i}function $(n,t,e){let g=0,i=0;n.modifiedRange.endColumn===1&&n.originalRange.endColumn===1&&n.originalRange.startLineNumber+g<=n.originalRange.endLineNumber&&n.modifiedRange.startLineNumber+g<=n.modifiedRange.endLineNumber&&(i=-1),n.modifiedRange.startColumn-1>=e[n.modifiedRange.startLineNumber-1].length&&n.originalRange.startColumn-1>=t[n.originalRange.startLineNumber-1].length&&n.originalRange.startLineNumber<=n.originalRange.endLineNumber+i&&n.modifiedRange.startLineNumber<=n.modifiedRange.endLineNumber+i&&(g=1);const s=new D(n.originalRange.startLineNumber+g,n.originalRange.endLineNumber+1+i),o=new D(n.modifiedRange.startLineNumber+g,n.modifiedRange.endLineNumber+1+i);return new E(s,o,[n])}function ee(n){return new V(new D(n.seq1Range.start+1,n.seq1Range.endExclusive+1),new D(n.seq2Range.start+1,n.seq2Range.endExclusive+1))}export{De as DefaultLinesDiffComputer,$ as getLineRangeMapping,j as lineRangeMappingFromRangeMappings};
