{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { forEachAdjacent } from '../../../../../base/common/arrays.js';\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { OffsetRange } from '../../../core/offsetRange.js';\n\n/**\n * Represents a synchronous diff algorithm. Should be executed in a worker.\n*/\nexport interface IDiffAlgorithm {\n\tcompute(sequence1: ISequence, sequence2: ISequence, timeout?: ITimeout): DiffAlgorithmResult;\n}\n\nexport class DiffAlgorithmResult {\n\tstatic trivial(seq1: ISequence, seq2: ISequence): DiffAlgorithmResult {\n\t\treturn new DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], false);\n\t}\n\n\tstatic trivialTimedOut(seq1: ISequence, seq2: ISequence): DiffAlgorithmResult {\n\t\treturn new DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], true);\n\t}\n\n\tconstructor(\n\t\tpublic readonly diffs: SequenceDiff[],\n\t\t/**\n\t\t * Indicates if the time out was reached.\n\t\t * In that case, the diffs might be an approximation and the user should be asked to rerun the diff with more time.\n\t\t */\n\t\tpublic readonly hitTimeout: boolean,\n\t) { }\n}\n\nexport class SequenceDiff {\n\tpublic static invert(sequenceDiffs: SequenceDiff[], doc1Length: number): SequenceDiff[] {\n\t\tconst result: SequenceDiff[] = [];\n\t\tforEachAdjacent(sequenceDiffs, (a, b) => {\n\t\t\tresult.push(SequenceDiff.fromOffsetPairs(\n\t\t\t\ta ? a.getEndExclusives() : OffsetPair.zero,\n\t\t\t\tb ? b.getStarts() : new OffsetPair(doc1Length, (a ? a.seq2Range.endExclusive - a.seq1Range.endExclusive : 0) + doc1Length)\n\t\t\t));\n\t\t});\n\t\treturn result;\n\t}\n\n\tpublic static fromOffsetPairs(start: OffsetPair, endExclusive: OffsetPair): SequenceDiff {\n\t\treturn new SequenceDiff(\n\t\t\tnew OffsetRange(start.offset1, endExclusive.offset1),\n\t\t\tnew OffsetRange(start.offset2, endExclusive.offset2),\n\t\t);\n\t}\n\n\tpublic static assertSorted(sequenceDiffs: SequenceDiff[]): void {\n\t\tlet last: SequenceDiff | undefined = undefined;\n\t\tfor (const cur of sequenceDiffs) {\n\t\t\tif (last) {\n\t\t\t\tif (!(last.seq1Range.endExclusive <= cur.seq1Range.start && last.seq2Range.endExclusive <= cur.seq2Range.start)) {\n\t\t\t\t\tthrow new BugIndicatingError('Sequence diffs must be sorted');\n\t\t\t\t}\n\t\t\t}\n\t\t\tlast = cur;\n\t\t}\n\t}\n\n\tconstructor(\n\t\tpublic readonly seq1Range: OffsetRange,\n\t\tpublic readonly seq2Range: OffsetRange,\n\t) { }\n\n\tpublic swap(): SequenceDiff {\n\t\treturn new SequenceDiff(this.seq2Range, this.seq1Range);\n\t}\n\n\tpublic toString(): string {\n\t\treturn `${this.seq1Range} <-> ${this.seq2Range}`;\n\t}\n\n\tpublic join(other: SequenceDiff): SequenceDiff {\n\t\treturn new SequenceDiff(this.seq1Range.join(other.seq1Range), this.seq2Range.join(other.seq2Range));\n\t}\n\n\tpublic delta(offset: number): SequenceDiff {\n\t\tif (offset === 0) {\n\t\t\treturn this;\n\t\t}\n\t\treturn new SequenceDiff(this.seq1Range.delta(offset), this.seq2Range.delta(offset));\n\t}\n\n\tpublic deltaStart(offset: number): SequenceDiff {\n\t\tif (offset === 0) {\n\t\t\treturn this;\n\t\t}\n\t\treturn new SequenceDiff(this.seq1Range.deltaStart(offset), this.seq2Range.deltaStart(offset));\n\t}\n\n\tpublic deltaEnd(offset: number): SequenceDiff {\n\t\tif (offset === 0) {\n\t\t\treturn this;\n\t\t}\n\t\treturn new SequenceDiff(this.seq1Range.deltaEnd(offset), this.seq2Range.deltaEnd(offset));\n\t}\n\n\tpublic intersectsOrTouches(other: SequenceDiff): boolean {\n\t\treturn this.seq1Range.intersectsOrTouches(other.seq1Range) || this.seq2Range.intersectsOrTouches(other.seq2Range);\n\t}\n\n\tpublic intersect(other: SequenceDiff): SequenceDiff | undefined {\n\t\tconst i1 = this.seq1Range.intersect(other.seq1Range);\n\t\tconst i2 = this.seq2Range.intersect(other.seq2Range);\n\t\tif (!i1 || !i2) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn new SequenceDiff(i1, i2);\n\t}\n\n\tpublic getStarts(): OffsetPair {\n\t\treturn new OffsetPair(this.seq1Range.start, this.seq2Range.start);\n\t}\n\n\tpublic getEndExclusives(): OffsetPair {\n\t\treturn new OffsetPair(this.seq1Range.endExclusive, this.seq2Range.endExclusive);\n\t}\n}\n\nexport class OffsetPair {\n\tpublic static readonly zero = new OffsetPair(0, 0);\n\tpublic static readonly max = new OffsetPair(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\n\n\tconstructor(\n\t\tpublic readonly offset1: number,\n\t\tpublic readonly offset2: number,\n\t) {\n\t}\n\n\tpublic toString(): string {\n\t\treturn `${this.offset1} <-> ${this.offset2}`;\n\t}\n\n\tpublic delta(offset: number): OffsetPair {\n\t\tif (offset === 0) {\n\t\t\treturn this;\n\t\t}\n\t\treturn new OffsetPair(this.offset1 + offset, this.offset2 + offset);\n\t}\n\n\tpublic equals(other: OffsetPair): boolean {\n\t\treturn this.offset1 === other.offset1 && this.offset2 === other.offset2;\n\t}\n}\n\nexport interface ISequence {\n\tgetElement(offset: number): number;\n\tget length(): number;\n\n\t/**\n\t * The higher the score, the better that offset can be used to split the sequence.\n\t * Is used to optimize insertions.\n\t * Must not be negative.\n\t*/\n\tgetBoundaryScore?(length: number): number;\n\n\t/**\n\t * For line sequences, getElement returns a number representing trimmed lines.\n\t * This however checks equality for the original lines.\n\t * It prevents shifting to less matching lines.\n\t */\n\tisStronglyEqual(offset1: number, offset2: number): boolean;\n}\n\nexport interface ITimeout {\n\tisValid(): boolean;\n}\n\nexport class InfiniteTimeout implements ITimeout {\n\tpublic static instance = new InfiniteTimeout();\n\n\tisValid(): boolean {\n\t\treturn true;\n\t}\n}\n\nexport class DateTimeout implements ITimeout {\n\tprivate readonly startTime = Date.now();\n\tprivate valid = true;\n\n\tconstructor(private timeout: number) {\n\t\tif (timeout <= 0) {\n\t\t\tthrow new BugIndicatingError('timeout must be positive');\n\t\t}\n\t}\n\n\t// Recommendation: Set a log-point `{this.disable()}` in the body\n\tpublic isValid(): boolean {\n\t\tconst valid = Date.now() - this.startTime < this.timeout;\n\t\tif (!valid && this.valid) {\n\t\t\tthis.valid = false; // timeout reached\n\t\t}\n\t\treturn this.valid;\n\t}\n\n\tpublic disable() {\n\t\tthis.timeout = Number.MAX_SAFE_INTEGER;\n\t\tthis.isValid = () => true;\n\t\tthis.valid = true;\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
