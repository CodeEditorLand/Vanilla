{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { forEachAdjacent } from \"../../../../../base/common/arrays.js\";\nimport { BugIndicatingError } from \"../../../../../base/common/errors.js\";\nimport { OffsetRange } from \"../../../core/offsetRange.js\";\n\n/**\n * Represents a synchronous diff algorithm. Should be executed in a worker.\n */\nexport interface IDiffAlgorithm {\n\tcompute(\n\t\tsequence1: ISequence,\n\t\tsequence2: ISequence,\n\t\ttimeout?: ITimeout,\n\t): DiffAlgorithmResult;\n}\n\nexport class DiffAlgorithmResult {\n\tstatic trivial(seq1: ISequence, seq2: ISequence): DiffAlgorithmResult {\n\t\treturn new DiffAlgorithmResult(\n\t\t\t[\n\t\t\t\tnew SequenceDiff(\n\t\t\t\t\tOffsetRange.ofLength(seq1.length),\n\t\t\t\t\tOffsetRange.ofLength(seq2.length),\n\t\t\t\t),\n\t\t\t],\n\t\t\tfalse,\n\t\t);\n\t}\n\n\tstatic trivialTimedOut(\n\t\tseq1: ISequence,\n\t\tseq2: ISequence,\n\t): DiffAlgorithmResult {\n\t\treturn new DiffAlgorithmResult(\n\t\t\t[\n\t\t\t\tnew SequenceDiff(\n\t\t\t\t\tOffsetRange.ofLength(seq1.length),\n\t\t\t\t\tOffsetRange.ofLength(seq2.length),\n\t\t\t\t),\n\t\t\t],\n\t\t\ttrue,\n\t\t);\n\t}\n\n\tconstructor(\n\t\tpublic readonly diffs: SequenceDiff[],\n\t\t/**\n\t\t * Indicates if the time out was reached.\n\t\t * In that case, the diffs might be an approximation and the user should be asked to rerun the diff with more time.\n\t\t */\n\t\tpublic readonly hitTimeout: boolean,\n\t) {}\n}\n\nexport class SequenceDiff {\n\tpublic static invert(\n\t\tsequenceDiffs: SequenceDiff[],\n\t\tdoc1Length: number,\n\t): SequenceDiff[] {\n\t\tconst result: SequenceDiff[] = [];\n\t\tforEachAdjacent(sequenceDiffs, (a, b) => {\n\t\t\tresult.push(\n\t\t\t\tSequenceDiff.fromOffsetPairs(\n\t\t\t\t\ta ? a.getEndExclusives() : OffsetPair.zero,\n\t\t\t\t\tb\n\t\t\t\t\t\t? b.getStarts()\n\t\t\t\t\t\t: new OffsetPair(\n\t\t\t\t\t\t\t\tdoc1Length,\n\t\t\t\t\t\t\t\t(a\n\t\t\t\t\t\t\t\t\t? a.seq2Range.endExclusive -\n\t\t\t\t\t\t\t\t\t\ta.seq1Range.endExclusive\n\t\t\t\t\t\t\t\t\t: 0) + doc1Length,\n\t\t\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t);\n\t\t});\n\t\treturn result;\n\t}\n\n\tpublic static fromOffsetPairs(\n\t\tstart: OffsetPair,\n\t\tendExclusive: OffsetPair,\n\t): SequenceDiff {\n\t\treturn new SequenceDiff(\n\t\t\tnew OffsetRange(start.offset1, endExclusive.offset1),\n\t\t\tnew OffsetRange(start.offset2, endExclusive.offset2),\n\t\t);\n\t}\n\n\tpublic static assertSorted(sequenceDiffs: SequenceDiff[]): void {\n\t\tlet last: SequenceDiff | undefined;\n\t\tfor (const cur of sequenceDiffs) {\n\t\t\tif (last) {\n\t\t\t\tif (\n\t\t\t\t\t!(\n\t\t\t\t\t\tlast.seq1Range.endExclusive <= cur.seq1Range.start &&\n\t\t\t\t\t\tlast.seq2Range.endExclusive <= cur.seq2Range.start\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tthrow new BugIndicatingError(\n\t\t\t\t\t\t\"Sequence diffs must be sorted\",\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlast = cur;\n\t\t}\n\t}\n\n\tconstructor(\n\t\tpublic readonly seq1Range: OffsetRange,\n\t\tpublic readonly seq2Range: OffsetRange,\n\t) {}\n\n\tpublic swap(): SequenceDiff {\n\t\treturn new SequenceDiff(this.seq2Range, this.seq1Range);\n\t}\n\n\tpublic toString(): string {\n\t\treturn `${this.seq1Range} <-> ${this.seq2Range}`;\n\t}\n\n\tpublic join(other: SequenceDiff): SequenceDiff {\n\t\treturn new SequenceDiff(\n\t\t\tthis.seq1Range.join(other.seq1Range),\n\t\t\tthis.seq2Range.join(other.seq2Range),\n\t\t);\n\t}\n\n\tpublic delta(offset: number): SequenceDiff {\n\t\tif (offset === 0) {\n\t\t\treturn this;\n\t\t}\n\t\treturn new SequenceDiff(\n\t\t\tthis.seq1Range.delta(offset),\n\t\t\tthis.seq2Range.delta(offset),\n\t\t);\n\t}\n\n\tpublic deltaStart(offset: number): SequenceDiff {\n\t\tif (offset === 0) {\n\t\t\treturn this;\n\t\t}\n\t\treturn new SequenceDiff(\n\t\t\tthis.seq1Range.deltaStart(offset),\n\t\t\tthis.seq2Range.deltaStart(offset),\n\t\t);\n\t}\n\n\tpublic deltaEnd(offset: number): SequenceDiff {\n\t\tif (offset === 0) {\n\t\t\treturn this;\n\t\t}\n\t\treturn new SequenceDiff(\n\t\t\tthis.seq1Range.deltaEnd(offset),\n\t\t\tthis.seq2Range.deltaEnd(offset),\n\t\t);\n\t}\n\n\tpublic intersectsOrTouches(other: SequenceDiff): boolean {\n\t\treturn (\n\t\t\tthis.seq1Range.intersectsOrTouches(other.seq1Range) ||\n\t\t\tthis.seq2Range.intersectsOrTouches(other.seq2Range)\n\t\t);\n\t}\n\n\tpublic intersect(other: SequenceDiff): SequenceDiff | undefined {\n\t\tconst i1 = this.seq1Range.intersect(other.seq1Range);\n\t\tconst i2 = this.seq2Range.intersect(other.seq2Range);\n\t\tif (!i1 || !i2) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn new SequenceDiff(i1, i2);\n\t}\n\n\tpublic getStarts(): OffsetPair {\n\t\treturn new OffsetPair(this.seq1Range.start, this.seq2Range.start);\n\t}\n\n\tpublic getEndExclusives(): OffsetPair {\n\t\treturn new OffsetPair(\n\t\t\tthis.seq1Range.endExclusive,\n\t\t\tthis.seq2Range.endExclusive,\n\t\t);\n\t}\n}\n\nexport class OffsetPair {\n\tpublic static readonly zero = new OffsetPair(0, 0);\n\tpublic static readonly max = new OffsetPair(\n\t\tNumber.MAX_SAFE_INTEGER,\n\t\tNumber.MAX_SAFE_INTEGER,\n\t);\n\n\tconstructor(\n\t\tpublic readonly offset1: number,\n\t\tpublic readonly offset2: number,\n\t) {}\n\n\tpublic toString(): string {\n\t\treturn `${this.offset1} <-> ${this.offset2}`;\n\t}\n\n\tpublic delta(offset: number): OffsetPair {\n\t\tif (offset === 0) {\n\t\t\treturn this;\n\t\t}\n\t\treturn new OffsetPair(this.offset1 + offset, this.offset2 + offset);\n\t}\n\n\tpublic equals(other: OffsetPair): boolean {\n\t\treturn this.offset1 === other.offset1 && this.offset2 === other.offset2;\n\t}\n}\n\nexport interface ISequence {\n\tgetElement(offset: number): number;\n\tget length(): number;\n\n\t/**\n\t * The higher the score, the better that offset can be used to split the sequence.\n\t * Is used to optimize insertions.\n\t * Must not be negative.\n\t */\n\tgetBoundaryScore?(length: number): number;\n\n\t/**\n\t * For line sequences, getElement returns a number representing trimmed lines.\n\t * This however checks equality for the original lines.\n\t * It prevents shifting to less matching lines.\n\t */\n\tisStronglyEqual(offset1: number, offset2: number): boolean;\n}\n\nexport interface ITimeout {\n\tisValid(): boolean;\n}\n\nexport class InfiniteTimeout implements ITimeout {\n\tpublic static instance = new InfiniteTimeout();\n\n\tisValid(): boolean {\n\t\treturn true;\n\t}\n}\n\nexport class DateTimeout implements ITimeout {\n\tprivate readonly startTime = Date.now();\n\tprivate valid = true;\n\n\tconstructor(private timeout: number) {\n\t\tif (timeout <= 0) {\n\t\t\tthrow new BugIndicatingError(\"timeout must be positive\");\n\t\t}\n\t}\n\n\t// Recommendation: Set a log-point `{this.disable()}` in the body\n\tpublic isValid(): boolean {\n\t\tconst valid = Date.now() - this.startTime < this.timeout;\n\t\tif (!valid && this.valid) {\n\t\t\tthis.valid = false; // timeout reached\n\t\t}\n\t\treturn this.valid;\n\t}\n\n\tpublic disable() {\n\t\tthis.timeout = Number.MAX_SAFE_INTEGER;\n\t\tthis.isValid = () => true;\n\t\tthis.valid = true;\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
