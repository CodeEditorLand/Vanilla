{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { equals, groupAdjacentBy } from '../../../../base/common/arrays.js';\nimport { assertFn, checkAdjacentItems } from '../../../../base/common/assert.js';\nimport { LineRange } from '../../core/lineRange.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { DateTimeout, ITimeout, InfiniteTimeout, SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { DynamicProgrammingDiffing } from './algorithms/dynamicProgrammingDiffing.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nimport { computeMovedLines } from './computeMovedLines.js';\nimport { extendDiffsToEntireWordIfAppropriate, optimizeSequenceDiffs, removeShortMatches, removeVeryShortMatchingLinesBetweenDiffs, removeVeryShortMatchingTextBetweenLongDiffs } from './heuristicSequenceOptimizations.js';\nimport { LineSequence } from './lineSequence.js';\nimport { LinesSliceCharSequence } from './linesSliceCharSequence.js';\nimport { ILinesDiffComputer, ILinesDiffComputerOptions, LinesDiff, MovedText } from '../linesDiffComputer.js';\nimport { DetailedLineRangeMapping, LineRangeMapping, RangeMapping } from '../rangeMapping.js';\n\nexport class DefaultLinesDiffComputer implements ILinesDiffComputer {\n\tprivate readonly dynamicProgrammingDiffing = new DynamicProgrammingDiffing();\n\tprivate readonly myersDiffingAlgorithm = new MyersDiffAlgorithm();\n\n\tcomputeDiff(originalLines: string[], modifiedLines: string[], options: ILinesDiffComputerOptions): LinesDiff {\n\t\tif (originalLines.length <= 1 && equals(originalLines, modifiedLines, (a, b) => a === b)) {\n\t\t\treturn new LinesDiff([], [], false);\n\t\t}\n\n\t\tif (originalLines.length === 1 && originalLines[0].length === 0 || modifiedLines.length === 1 && modifiedLines[0].length === 0) {\n\t\t\treturn new LinesDiff([\n\t\t\t\tnew DetailedLineRangeMapping(\n\t\t\t\t\tnew LineRange(1, originalLines.length + 1),\n\t\t\t\t\tnew LineRange(1, modifiedLines.length + 1),\n\t\t\t\t\t[\n\t\t\t\t\t\tnew RangeMapping(\n\t\t\t\t\t\t\tnew Range(1, 1, originalLines.length, originalLines[originalLines.length - 1].length + 1),\n\t\t\t\t\t\t\tnew Range(1, 1, modifiedLines.length, modifiedLines[modifiedLines.length - 1].length + 1),\n\t\t\t\t\t\t)\n\t\t\t\t\t]\n\t\t\t\t)\n\t\t\t], [], false);\n\t\t}\n\n\t\tconst timeout = options.maxComputationTimeMs === 0 ? InfiniteTimeout.instance : new DateTimeout(options.maxComputationTimeMs);\n\t\tconst considerWhitespaceChanges = !options.ignoreTrimWhitespace;\n\n\t\tconst perfectHashes = new Map<string, number>();\n\t\tfunction getOrCreateHash(text: string): number {\n\t\t\tlet hash = perfectHashes.get(text);\n\t\t\tif (hash === undefined) {\n\t\t\t\thash = perfectHashes.size;\n\t\t\t\tperfectHashes.set(text, hash);\n\t\t\t}\n\t\t\treturn hash;\n\t\t}\n\n\t\tconst originalLinesHashes = originalLines.map((l) => getOrCreateHash(l.trim()));\n\t\tconst modifiedLinesHashes = modifiedLines.map((l) => getOrCreateHash(l.trim()));\n\n\t\tconst sequence1 = new LineSequence(originalLinesHashes, originalLines);\n\t\tconst sequence2 = new LineSequence(modifiedLinesHashes, modifiedLines);\n\n\t\tconst lineAlignmentResult = (() => {\n\t\t\tif (sequence1.length + sequence2.length < 1700) {\n\t\t\t\t// Use the improved algorithm for small files\n\t\t\t\treturn this.dynamicProgrammingDiffing.compute(\n\t\t\t\t\tsequence1,\n\t\t\t\t\tsequence2,\n\t\t\t\t\ttimeout,\n\t\t\t\t\t(offset1, offset2) =>\n\t\t\t\t\t\toriginalLines[offset1] === modifiedLines[offset2]\n\t\t\t\t\t\t\t? modifiedLines[offset2].length === 0\n\t\t\t\t\t\t\t\t? 0.1\n\t\t\t\t\t\t\t\t: 1 + Math.log(1 + modifiedLines[offset2].length)\n\t\t\t\t\t\t\t: 0.99\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn this.myersDiffingAlgorithm.compute(\n\t\t\t\tsequence1,\n\t\t\t\tsequence2,\n\t\t\t\ttimeout\n\t\t\t);\n\t\t})();\n\n\t\tlet lineAlignments = lineAlignmentResult.diffs;\n\t\tlet hitTimeout = lineAlignmentResult.hitTimeout;\n\t\tlineAlignments = optimizeSequenceDiffs(sequence1, sequence2, lineAlignments);\n\t\tlineAlignments = removeVeryShortMatchingLinesBetweenDiffs(sequence1, sequence2, lineAlignments);\n\n\t\tconst alignments: RangeMapping[] = [];\n\n\t\tconst scanForWhitespaceChanges = (equalLinesCount: number) => {\n\t\t\tif (!considerWhitespaceChanges) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < equalLinesCount; i++) {\n\t\t\t\tconst seq1Offset = seq1LastStart + i;\n\t\t\t\tconst seq2Offset = seq2LastStart + i;\n\t\t\t\tif (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {\n\t\t\t\t\t// This is because of whitespace changes, diff these lines\n\t\t\t\t\tconst characterDiffs = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(\n\t\t\t\t\t\tnew OffsetRange(seq1Offset, seq1Offset + 1),\n\t\t\t\t\t\tnew OffsetRange(seq2Offset, seq2Offset + 1),\n\t\t\t\t\t), timeout, considerWhitespaceChanges);\n\t\t\t\t\tfor (const a of characterDiffs.mappings) {\n\t\t\t\t\t\talignments.push(a);\n\t\t\t\t\t}\n\t\t\t\t\tif (characterDiffs.hitTimeout) {\n\t\t\t\t\t\thitTimeout = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tlet seq1LastStart = 0;\n\t\tlet seq2LastStart = 0;\n\n\t\tfor (const diff of lineAlignments) {\n\t\t\tassertFn(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);\n\n\t\t\tconst equalLinesCount = diff.seq1Range.start - seq1LastStart;\n\n\t\t\tscanForWhitespaceChanges(equalLinesCount);\n\n\t\t\tseq1LastStart = diff.seq1Range.endExclusive;\n\t\t\tseq2LastStart = diff.seq2Range.endExclusive;\n\n\t\t\tconst characterDiffs = this.refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges);\n\t\t\tif (characterDiffs.hitTimeout) {\n\t\t\t\thitTimeout = true;\n\t\t\t}\n\t\t\tfor (const a of characterDiffs.mappings) {\n\t\t\t\talignments.push(a);\n\t\t\t}\n\t\t}\n\n\t\tscanForWhitespaceChanges(originalLines.length - seq1LastStart);\n\n\t\tconst changes = lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines);\n\n\t\tlet moves: MovedText[] = [];\n\t\tif (options.computeMoves) {\n\t\t\tmoves = this.computeMoves(changes, originalLines, modifiedLines, originalLinesHashes, modifiedLinesHashes, timeout, considerWhitespaceChanges);\n\t\t}\n\n\t\t// Make sure all ranges are valid\n\t\tassertFn(() => {\n\t\t\tfunction validatePosition(pos: Position, lines: string[]): boolean {\n\t\t\t\tif (pos.lineNumber < 1 || pos.lineNumber > lines.length) { return false; }\n\t\t\t\tconst line = lines[pos.lineNumber - 1];\n\t\t\t\tif (pos.column < 1 || pos.column > line.length + 1) { return false; }\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tfunction validateRange(range: LineRange, lines: string[]): boolean {\n\t\t\t\tif (range.startLineNumber < 1 || range.startLineNumber > lines.length + 1) { return false; }\n\t\t\t\tif (range.endLineNumberExclusive < 1 || range.endLineNumberExclusive > lines.length + 1) { return false; }\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tfor (const c of changes) {\n\t\t\t\tif (!c.innerChanges) { return false; }\n\t\t\t\tfor (const ic of c.innerChanges) {\n\t\t\t\t\tconst valid = validatePosition(ic.modifiedRange.getStartPosition(), modifiedLines) && validatePosition(ic.modifiedRange.getEndPosition(), modifiedLines) &&\n\t\t\t\t\t\tvalidatePosition(ic.originalRange.getStartPosition(), originalLines) && validatePosition(ic.originalRange.getEndPosition(), originalLines);\n\t\t\t\t\tif (!valid) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!validateRange(c.modified, modifiedLines) || !validateRange(c.original, originalLines)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\n\t\treturn new LinesDiff(changes, moves, hitTimeout);\n\t}\n\n\tprivate computeMoves(\n\t\tchanges: DetailedLineRangeMapping[],\n\t\toriginalLines: string[],\n\t\tmodifiedLines: string[],\n\t\thashedOriginalLines: number[],\n\t\thashedModifiedLines: number[],\n\t\ttimeout: ITimeout,\n\t\tconsiderWhitespaceChanges: boolean,\n\t): MovedText[] {\n\t\tconst moves = computeMovedLines(\n\t\t\tchanges,\n\t\t\toriginalLines,\n\t\t\tmodifiedLines,\n\t\t\thashedOriginalLines,\n\t\t\thashedModifiedLines,\n\t\t\ttimeout,\n\t\t);\n\t\tconst movesWithDiffs = moves.map(m => {\n\t\t\tconst moveChanges = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(\n\t\t\t\tm.original.toOffsetRange(),\n\t\t\t\tm.modified.toOffsetRange(),\n\t\t\t), timeout, considerWhitespaceChanges);\n\t\t\tconst mappings = lineRangeMappingFromRangeMappings(moveChanges.mappings, originalLines, modifiedLines, true);\n\t\t\treturn new MovedText(m, mappings);\n\t\t});\n\t\treturn movesWithDiffs;\n\t}\n\n\tprivate refineDiff(originalLines: string[], modifiedLines: string[], diff: SequenceDiff, timeout: ITimeout, considerWhitespaceChanges: boolean): { mappings: RangeMapping[]; hitTimeout: boolean } {\n\t\tconst lineRangeMapping = toLineRangeMapping(diff);\n\t\tconst rangeMapping = lineRangeMapping.toRangeMapping2(originalLines, modifiedLines);\n\n\t\tconst slice1 = new LinesSliceCharSequence(originalLines, rangeMapping.originalRange, considerWhitespaceChanges);\n\t\tconst slice2 = new LinesSliceCharSequence(modifiedLines, rangeMapping.modifiedRange, considerWhitespaceChanges);\n\n\t\tconst diffResult = slice1.length + slice2.length < 500\n\t\t\t? this.dynamicProgrammingDiffing.compute(slice1, slice2, timeout)\n\t\t\t: this.myersDiffingAlgorithm.compute(slice1, slice2, timeout);\n\n\t\tconst check = false;\n\n\t\tlet diffs = diffResult.diffs;\n\t\tif (check) { SequenceDiff.assertSorted(diffs); }\n\t\tdiffs = optimizeSequenceDiffs(slice1, slice2, diffs);\n\t\tif (check) { SequenceDiff.assertSorted(diffs); }\n\t\tdiffs = extendDiffsToEntireWordIfAppropriate(slice1, slice2, diffs);\n\t\tif (check) { SequenceDiff.assertSorted(diffs); }\n\t\tdiffs = removeShortMatches(slice1, slice2, diffs);\n\t\tif (check) { SequenceDiff.assertSorted(diffs); }\n\t\tdiffs = removeVeryShortMatchingTextBetweenLongDiffs(slice1, slice2, diffs);\n\t\tif (check) { SequenceDiff.assertSorted(diffs); }\n\n\t\tconst result = diffs.map(\n\t\t\t(d) =>\n\t\t\t\tnew RangeMapping(\n\t\t\t\t\tslice1.translateRange(d.seq1Range),\n\t\t\t\t\tslice2.translateRange(d.seq2Range)\n\t\t\t\t)\n\t\t);\n\n\t\tif (check) { RangeMapping.assertSorted(result); }\n\n\t\t// Assert: result applied on original should be the same as diff applied to original\n\n\t\treturn {\n\t\t\tmappings: result,\n\t\t\thitTimeout: diffResult.hitTimeout,\n\t\t};\n\t}\n}\n\nexport function lineRangeMappingFromRangeMappings(alignments: RangeMapping[], originalLines: string[], modifiedLines: string[], dontAssertStartLine: boolean = false): DetailedLineRangeMapping[] {\n\tconst changes: DetailedLineRangeMapping[] = [];\n\tfor (const g of groupAdjacentBy(\n\t\talignments.map(a => getLineRangeMapping(a, originalLines, modifiedLines)),\n\t\t(a1, a2) =>\n\t\t\ta1.original.overlapOrTouch(a2.original)\n\t\t\t|| a1.modified.overlapOrTouch(a2.modified)\n\t)) {\n\t\tconst first = g[0];\n\t\tconst last = g[g.length - 1];\n\n\t\tchanges.push(new DetailedLineRangeMapping(\n\t\t\tfirst.original.join(last.original),\n\t\t\tfirst.modified.join(last.modified),\n\t\t\tg.map(a => a.innerChanges![0]),\n\t\t));\n\t}\n\n\tassertFn(() => {\n\t\tif (!dontAssertStartLine && changes.length > 0) {\n\t\t\tif (changes[0].modified.startLineNumber !== changes[0].original.startLineNumber) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (modifiedLines.length - changes[changes.length - 1].modified.endLineNumberExclusive !== originalLines.length - changes[changes.length - 1].original.endLineNumberExclusive) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn checkAdjacentItems(changes,\n\t\t\t(m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive &&\n\t\t\t\t// There has to be an unchanged line in between (otherwise both diffs should have been joined)\n\t\t\t\tm1.original.endLineNumberExclusive < m2.original.startLineNumber &&\n\t\t\t\tm1.modified.endLineNumberExclusive < m2.modified.startLineNumber,\n\t\t);\n\t});\n\n\treturn changes;\n}\n\nexport function getLineRangeMapping(rangeMapping: RangeMapping, originalLines: string[], modifiedLines: string[]): DetailedLineRangeMapping {\n\tlet lineStartDelta = 0;\n\tlet lineEndDelta = 0;\n\n\t// rangeMapping describes the edit that replaces `rangeMapping.originalRange` with `newText := getText(modifiedLines, rangeMapping.modifiedRange)`.\n\n\t// original: ]xxx \\n <- this line is not modified\n\t// modified: ]xx  \\n\n\tif (rangeMapping.modifiedRange.endColumn === 1 && rangeMapping.originalRange.endColumn === 1\n\t\t&& rangeMapping.originalRange.startLineNumber + lineStartDelta <= rangeMapping.originalRange.endLineNumber\n\t\t&& rangeMapping.modifiedRange.startLineNumber + lineStartDelta <= rangeMapping.modifiedRange.endLineNumber) {\n\t\t// We can only do this if the range is not empty yet\n\t\tlineEndDelta = -1;\n\t}\n\n\t// original: xxx[ \\n <- this line is not modified\n\t// modified: xxx[ \\n\n\tif (rangeMapping.modifiedRange.startColumn - 1 >= modifiedLines[rangeMapping.modifiedRange.startLineNumber - 1].length\n\t\t&& rangeMapping.originalRange.startColumn - 1 >= originalLines[rangeMapping.originalRange.startLineNumber - 1].length\n\t\t&& rangeMapping.originalRange.startLineNumber <= rangeMapping.originalRange.endLineNumber + lineEndDelta\n\t\t&& rangeMapping.modifiedRange.startLineNumber <= rangeMapping.modifiedRange.endLineNumber + lineEndDelta) {\n\t\t// We can only do this if the range is not empty yet\n\t\tlineStartDelta = 1;\n\t}\n\n\tconst originalLineRange = new LineRange(\n\t\trangeMapping.originalRange.startLineNumber + lineStartDelta,\n\t\trangeMapping.originalRange.endLineNumber + 1 + lineEndDelta\n\t);\n\tconst modifiedLineRange = new LineRange(\n\t\trangeMapping.modifiedRange.startLineNumber + lineStartDelta,\n\t\trangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta\n\t);\n\n\treturn new DetailedLineRangeMapping(originalLineRange, modifiedLineRange, [rangeMapping]);\n}\n\nfunction toLineRangeMapping(sequenceDiff: SequenceDiff) {\n\treturn new LineRangeMapping(\n\t\tnew LineRange(sequenceDiff.seq1Range.start + 1, sequenceDiff.seq1Range.endExclusive + 1),\n\t\tnew LineRange(sequenceDiff.seq2Range.start + 1, sequenceDiff.seq2Range.endExclusive + 1),\n\t);\n}\n"],
  "mappings": ";;AAKA,SAAS,QAAQ,uBAAuB;AACxC,SAAS,UAAU,0BAA0B;AAC7C,SAAS,iBAAiB;AAC1B,SAAS,mBAAmB;AAC5B,SAAS,gBAAgB;AACzB,SAAS,aAAa;AACtB,SAAS,aAAa,UAAU,iBAAiB,oBAAoB;AACrE,SAAS,iCAAiC;AAC1C,SAAS,0BAA0B;AACnC,SAAS,yBAAyB;AAClC,SAAS,sCAAsC,uBAAuB,oBAAoB,0CAA0C,mDAAmD;AACvL,SAAS,oBAAoB;AAC7B,SAAS,8BAA8B;AACvC,SAAS,oBAAoB,2BAA2B,WAAW,iBAAiB;AACpF,SAAS,0BAA0B,kBAAkB,oBAAoB;AAElE,MAAM,yBAAuD;AAAA,EArBpE,OAqBoE;AAAA;AAAA;AAAA,EAClD,4BAA4B,IAAI,0BAA0B;AAAA,EAC1D,wBAAwB,IAAI,mBAAmB;AAAA,EAEhE,YAAY,eAAyB,eAAyB,SAA+C;AAC5G,QAAI,cAAc,UAAU,KAAK,OAAO,eAAe,eAAe,CAAC,GAAG,MAAM,MAAM,CAAC,GAAG;AACzF,aAAO,IAAI,UAAU,CAAC,GAAG,CAAC,GAAG,KAAK;AAAA,IACnC;AAEA,QAAI,cAAc,WAAW,KAAK,cAAc,CAAC,EAAE,WAAW,KAAK,cAAc,WAAW,KAAK,cAAc,CAAC,EAAE,WAAW,GAAG;AAC/H,aAAO,IAAI,UAAU;AAAA,QACpB,IAAI;AAAA,UACH,IAAI,UAAU,GAAG,cAAc,SAAS,CAAC;AAAA,UACzC,IAAI,UAAU,GAAG,cAAc,SAAS,CAAC;AAAA,UACzC;AAAA,YACC,IAAI;AAAA,cACH,IAAI,MAAM,GAAG,GAAG,cAAc,QAAQ,cAAc,cAAc,SAAS,CAAC,EAAE,SAAS,CAAC;AAAA,cACxF,IAAI,MAAM,GAAG,GAAG,cAAc,QAAQ,cAAc,cAAc,SAAS,CAAC,EAAE,SAAS,CAAC;AAAA,YACzF;AAAA,UACD;AAAA,QACD;AAAA,MACD,GAAG,CAAC,GAAG,KAAK;AAAA,IACb;AAEA,UAAM,UAAU,QAAQ,yBAAyB,IAAI,gBAAgB,WAAW,IAAI,YAAY,QAAQ,oBAAoB;AAC5H,UAAM,4BAA4B,CAAC,QAAQ;AAE3C,UAAM,gBAAgB,oBAAI,IAAoB;AAC9C,aAAS,gBAAgB,MAAsB;AAC9C,UAAI,OAAO,cAAc,IAAI,IAAI;AACjC,UAAI,SAAS,QAAW;AACvB,eAAO,cAAc;AACrB,sBAAc,IAAI,MAAM,IAAI;AAAA,MAC7B;AACA,aAAO;AAAA,IACR;AAPS;AAST,UAAM,sBAAsB,cAAc,IAAI,CAAC,MAAM,gBAAgB,EAAE,KAAK,CAAC,CAAC;AAC9E,UAAM,sBAAsB,cAAc,IAAI,CAAC,MAAM,gBAAgB,EAAE,KAAK,CAAC,CAAC;AAE9E,UAAM,YAAY,IAAI,aAAa,qBAAqB,aAAa;AACrE,UAAM,YAAY,IAAI,aAAa,qBAAqB,aAAa;AAErE,UAAM,uBAAuB,MAAM;AAClC,UAAI,UAAU,SAAS,UAAU,SAAS,MAAM;AAE/C,eAAO,KAAK,0BAA0B;AAAA,UACrC;AAAA,UACA;AAAA,UACA;AAAA,UACA,CAAC,SAAS,YACT,cAAc,OAAO,MAAM,cAAc,OAAO,IAC7C,cAAc,OAAO,EAAE,WAAW,IACjC,MACA,IAAI,KAAK,IAAI,IAAI,cAAc,OAAO,EAAE,MAAM,IAC/C;AAAA,QACL;AAAA,MACD;AAEA,aAAO,KAAK,sBAAsB;AAAA,QACjC;AAAA,QACA;AAAA,QACA;AAAA,MACD;AAAA,IACD,GAAG;AAEH,QAAI,iBAAiB,oBAAoB;AACzC,QAAI,aAAa,oBAAoB;AACrC,qBAAiB,sBAAsB,WAAW,WAAW,cAAc;AAC3E,qBAAiB,yCAAyC,WAAW,WAAW,cAAc;AAE9F,UAAM,aAA6B,CAAC;AAEpC,UAAM,2BAA2B,wBAAC,oBAA4B;AAC7D,UAAI,CAAC,2BAA2B;AAC/B;AAAA,MACD;AAEA,eAAS,IAAI,GAAG,IAAI,iBAAiB,KAAK;AACzC,cAAM,aAAa,gBAAgB;AACnC,cAAM,aAAa,gBAAgB;AACnC,YAAI,cAAc,UAAU,MAAM,cAAc,UAAU,GAAG;AAE5D,gBAAM,iBAAiB,KAAK,WAAW,eAAe,eAAe,IAAI;AAAA,YACxE,IAAI,YAAY,YAAY,aAAa,CAAC;AAAA,YAC1C,IAAI,YAAY,YAAY,aAAa,CAAC;AAAA,UAC3C,GAAG,SAAS,yBAAyB;AACrC,qBAAW,KAAK,eAAe,UAAU;AACxC,uBAAW,KAAK,CAAC;AAAA,UAClB;AACA,cAAI,eAAe,YAAY;AAC9B,yBAAa;AAAA,UACd;AAAA,QACD;AAAA,MACD;AAAA,IACD,GAtBiC;AAwBjC,QAAI,gBAAgB;AACpB,QAAI,gBAAgB;AAEpB,eAAW,QAAQ,gBAAgB;AAClC,eAAS,MAAM,KAAK,UAAU,QAAQ,kBAAkB,KAAK,UAAU,QAAQ,aAAa;AAE5F,YAAM,kBAAkB,KAAK,UAAU,QAAQ;AAE/C,+BAAyB,eAAe;AAExC,sBAAgB,KAAK,UAAU;AAC/B,sBAAgB,KAAK,UAAU;AAE/B,YAAM,iBAAiB,KAAK,WAAW,eAAe,eAAe,MAAM,SAAS,yBAAyB;AAC7G,UAAI,eAAe,YAAY;AAC9B,qBAAa;AAAA,MACd;AACA,iBAAW,KAAK,eAAe,UAAU;AACxC,mBAAW,KAAK,CAAC;AAAA,MAClB;AAAA,IACD;AAEA,6BAAyB,cAAc,SAAS,aAAa;AAE7D,UAAM,UAAU,kCAAkC,YAAY,eAAe,aAAa;AAE1F,QAAI,QAAqB,CAAC;AAC1B,QAAI,QAAQ,cAAc;AACzB,cAAQ,KAAK,aAAa,SAAS,eAAe,eAAe,qBAAqB,qBAAqB,SAAS,yBAAyB;AAAA,IAC9I;AAGA,aAAS,MAAM;AACd,eAAS,iBAAiB,KAAe,OAA0B;AAClE,YAAI,IAAI,aAAa,KAAK,IAAI,aAAa,MAAM,QAAQ;AAAE,iBAAO;AAAA,QAAO;AACzE,cAAM,OAAO,MAAM,IAAI,aAAa,CAAC;AACrC,YAAI,IAAI,SAAS,KAAK,IAAI,SAAS,KAAK,SAAS,GAAG;AAAE,iBAAO;AAAA,QAAO;AACpE,eAAO;AAAA,MACR;AALS;AAOT,eAAS,cAAc,OAAkB,OAA0B;AAClE,YAAI,MAAM,kBAAkB,KAAK,MAAM,kBAAkB,MAAM,SAAS,GAAG;AAAE,iBAAO;AAAA,QAAO;AAC3F,YAAI,MAAM,yBAAyB,KAAK,MAAM,yBAAyB,MAAM,SAAS,GAAG;AAAE,iBAAO;AAAA,QAAO;AACzG,eAAO;AAAA,MACR;AAJS;AAMT,iBAAW,KAAK,SAAS;AACxB,YAAI,CAAC,EAAE,cAAc;AAAE,iBAAO;AAAA,QAAO;AACrC,mBAAW,MAAM,EAAE,cAAc;AAChC,gBAAM,QAAQ,iBAAiB,GAAG,cAAc,iBAAiB,GAAG,aAAa,KAAK,iBAAiB,GAAG,cAAc,eAAe,GAAG,aAAa,KACtJ,iBAAiB,GAAG,cAAc,iBAAiB,GAAG,aAAa,KAAK,iBAAiB,GAAG,cAAc,eAAe,GAAG,aAAa;AAC1I,cAAI,CAAC,OAAO;AACX,mBAAO;AAAA,UACR;AAAA,QACD;AACA,YAAI,CAAC,cAAc,EAAE,UAAU,aAAa,KAAK,CAAC,cAAc,EAAE,UAAU,aAAa,GAAG;AAC3F,iBAAO;AAAA,QACR;AAAA,MACD;AACA,aAAO;AAAA,IACR,CAAC;AAED,WAAO,IAAI,UAAU,SAAS,OAAO,UAAU;AAAA,EAChD;AAAA,EAEQ,aACP,SACA,eACA,eACA,qBACA,qBACA,SACA,2BACc;AACd,UAAM,QAAQ;AAAA,MACb;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACD;AACA,UAAM,iBAAiB,MAAM,IAAI,OAAK;AACrC,YAAM,cAAc,KAAK,WAAW,eAAe,eAAe,IAAI;AAAA,QACrE,EAAE,SAAS,cAAc;AAAA,QACzB,EAAE,SAAS,cAAc;AAAA,MAC1B,GAAG,SAAS,yBAAyB;AACrC,YAAM,WAAW,kCAAkC,YAAY,UAAU,eAAe,eAAe,IAAI;AAC3G,aAAO,IAAI,UAAU,GAAG,QAAQ;AAAA,IACjC,CAAC;AACD,WAAO;AAAA,EACR;AAAA,EAEQ,WAAW,eAAyB,eAAyB,MAAoB,SAAmB,2BAAuF;AAClM,UAAM,mBAAmB,mBAAmB,IAAI;AAChD,UAAM,eAAe,iBAAiB,gBAAgB,eAAe,aAAa;AAElF,UAAM,SAAS,IAAI,uBAAuB,eAAe,aAAa,eAAe,yBAAyB;AAC9G,UAAM,SAAS,IAAI,uBAAuB,eAAe,aAAa,eAAe,yBAAyB;AAE9G,UAAM,aAAa,OAAO,SAAS,OAAO,SAAS,MAChD,KAAK,0BAA0B,QAAQ,QAAQ,QAAQ,OAAO,IAC9D,KAAK,sBAAsB,QAAQ,QAAQ,QAAQ,OAAO;AAE7D,UAAM,QAAQ;AAEd,QAAI,QAAQ,WAAW;AACvB,QAAI,OAAO;AAAE,mBAAa,aAAa,KAAK;AAAA,IAAG;AAC/C,YAAQ,sBAAsB,QAAQ,QAAQ,KAAK;AACnD,QAAI,OAAO;AAAE,mBAAa,aAAa,KAAK;AAAA,IAAG;AAC/C,YAAQ,qCAAqC,QAAQ,QAAQ,KAAK;AAClE,QAAI,OAAO;AAAE,mBAAa,aAAa,KAAK;AAAA,IAAG;AAC/C,YAAQ,mBAAmB,QAAQ,QAAQ,KAAK;AAChD,QAAI,OAAO;AAAE,mBAAa,aAAa,KAAK;AAAA,IAAG;AAC/C,YAAQ,4CAA4C,QAAQ,QAAQ,KAAK;AACzE,QAAI,OAAO;AAAE,mBAAa,aAAa,KAAK;AAAA,IAAG;AAE/C,UAAM,SAAS,MAAM;AAAA,MACpB,CAAC,MACA,IAAI;AAAA,QACH,OAAO,eAAe,EAAE,SAAS;AAAA,QACjC,OAAO,eAAe,EAAE,SAAS;AAAA,MAClC;AAAA,IACF;AAEA,QAAI,OAAO;AAAE,mBAAa,aAAa,MAAM;AAAA,IAAG;AAIhD,WAAO;AAAA,MACN,UAAU;AAAA,MACV,YAAY,WAAW;AAAA,IACxB;AAAA,EACD;AACD;AAEO,SAAS,kCAAkC,YAA4B,eAAyB,eAAyB,sBAA+B,OAAmC;AACjM,QAAM,UAAsC,CAAC;AAC7C,aAAW,KAAK;AAAA,IACf,WAAW,IAAI,OAAK,oBAAoB,GAAG,eAAe,aAAa,CAAC;AAAA,IACxE,CAAC,IAAI,OACJ,GAAG,SAAS,eAAe,GAAG,QAAQ,KACnC,GAAG,SAAS,eAAe,GAAG,QAAQ;AAAA,EAC3C,GAAG;AACF,UAAM,QAAQ,EAAE,CAAC;AACjB,UAAM,OAAO,EAAE,EAAE,SAAS,CAAC;AAE3B,YAAQ,KAAK,IAAI;AAAA,MAChB,MAAM,SAAS,KAAK,KAAK,QAAQ;AAAA,MACjC,MAAM,SAAS,KAAK,KAAK,QAAQ;AAAA,MACjC,EAAE,IAAI,OAAK,EAAE,aAAc,CAAC,CAAC;AAAA,IAC9B,CAAC;AAAA,EACF;AAEA,WAAS,MAAM;AACd,QAAI,CAAC,uBAAuB,QAAQ,SAAS,GAAG;AAC/C,UAAI,QAAQ,CAAC,EAAE,SAAS,oBAAoB,QAAQ,CAAC,EAAE,SAAS,iBAAiB;AAChF,eAAO;AAAA,MACR;AACA,UAAI,cAAc,SAAS,QAAQ,QAAQ,SAAS,CAAC,EAAE,SAAS,2BAA2B,cAAc,SAAS,QAAQ,QAAQ,SAAS,CAAC,EAAE,SAAS,wBAAwB;AAC9K,eAAO;AAAA,MACR;AAAA,IACD;AACA,WAAO;AAAA,MAAmB;AAAA,MACzB,CAAC,IAAI,OAAO,GAAG,SAAS,kBAAkB,GAAG,SAAS,2BAA2B,GAAG,SAAS,kBAAkB,GAAG,SAAS;AAAA,MAE1H,GAAG,SAAS,yBAAyB,GAAG,SAAS,mBACjD,GAAG,SAAS,yBAAyB,GAAG,SAAS;AAAA,IACnD;AAAA,EACD,CAAC;AAED,SAAO;AACR;AApCgB;AAsCT,SAAS,oBAAoB,cAA4B,eAAyB,eAAmD;AAC3I,MAAI,iBAAiB;AACrB,MAAI,eAAe;AAMnB,MAAI,aAAa,cAAc,cAAc,KAAK,aAAa,cAAc,cAAc,KACvF,aAAa,cAAc,kBAAkB,kBAAkB,aAAa,cAAc,iBAC1F,aAAa,cAAc,kBAAkB,kBAAkB,aAAa,cAAc,eAAe;AAE5G,mBAAe;AAAA,EAChB;AAIA,MAAI,aAAa,cAAc,cAAc,KAAK,cAAc,aAAa,cAAc,kBAAkB,CAAC,EAAE,UAC5G,aAAa,cAAc,cAAc,KAAK,cAAc,aAAa,cAAc,kBAAkB,CAAC,EAAE,UAC5G,aAAa,cAAc,mBAAmB,aAAa,cAAc,gBAAgB,gBACzF,aAAa,cAAc,mBAAmB,aAAa,cAAc,gBAAgB,cAAc;AAE1G,qBAAiB;AAAA,EAClB;AAEA,QAAM,oBAAoB,IAAI;AAAA,IAC7B,aAAa,cAAc,kBAAkB;AAAA,IAC7C,aAAa,cAAc,gBAAgB,IAAI;AAAA,EAChD;AACA,QAAM,oBAAoB,IAAI;AAAA,IAC7B,aAAa,cAAc,kBAAkB;AAAA,IAC7C,aAAa,cAAc,gBAAgB,IAAI;AAAA,EAChD;AAEA,SAAO,IAAI,yBAAyB,mBAAmB,mBAAmB,CAAC,YAAY,CAAC;AACzF;AAnCgB;AAqChB,SAAS,mBAAmB,cAA4B;AACvD,SAAO,IAAI;AAAA,IACV,IAAI,UAAU,aAAa,UAAU,QAAQ,GAAG,aAAa,UAAU,eAAe,CAAC;AAAA,IACvF,IAAI,UAAU,aAAa,UAAU,QAAQ,GAAG,aAAa,UAAU,eAAe,CAAC;AAAA,EACxF;AACD;AALS;",
  "names": []
}
