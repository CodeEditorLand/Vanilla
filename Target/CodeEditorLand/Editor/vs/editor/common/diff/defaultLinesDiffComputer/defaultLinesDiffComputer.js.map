{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { equals, groupAdjacentBy } from \"../../../../base/common/arrays.js\";\nimport {\n\tassertFn,\n\tcheckAdjacentItems,\n} from \"../../../../base/common/assert.js\";\nimport { LineRange } from \"../../core/lineRange.js\";\nimport { OffsetRange } from \"../../core/offsetRange.js\";\nimport type { Position } from \"../../core/position.js\";\nimport { Range } from \"../../core/range.js\";\nimport {\n\ttype ILinesDiffComputer,\n\ttype ILinesDiffComputerOptions,\n\tLinesDiff,\n\tMovedText,\n} from \"../linesDiffComputer.js\";\nimport {\n\tDetailedLineRangeMapping,\n\tLineRangeMapping,\n\tRangeMapping,\n} from \"../rangeMapping.js\";\nimport {\n\tDateTimeout,\n\ttype ITimeout,\n\tInfiniteTimeout,\n\tSequenceDiff,\n} from \"./algorithms/diffAlgorithm.js\";\nimport { DynamicProgrammingDiffing } from \"./algorithms/dynamicProgrammingDiffing.js\";\nimport { MyersDiffAlgorithm } from \"./algorithms/myersDiffAlgorithm.js\";\nimport { computeMovedLines } from \"./computeMovedLines.js\";\nimport {\n\textendDiffsToEntireWordIfAppropriate,\n\toptimizeSequenceDiffs,\n\tremoveShortMatches,\n\tremoveVeryShortMatchingLinesBetweenDiffs,\n\tremoveVeryShortMatchingTextBetweenLongDiffs,\n} from \"./heuristicSequenceOptimizations.js\";\nimport { LineSequence } from \"./lineSequence.js\";\nimport { LinesSliceCharSequence } from \"./linesSliceCharSequence.js\";\n\nexport class DefaultLinesDiffComputer implements ILinesDiffComputer {\n\tprivate readonly dynamicProgrammingDiffing =\n\t\tnew DynamicProgrammingDiffing();\n\tprivate readonly myersDiffingAlgorithm = new MyersDiffAlgorithm();\n\n\tcomputeDiff(\n\t\toriginalLines: string[],\n\t\tmodifiedLines: string[],\n\t\toptions: ILinesDiffComputerOptions,\n\t): LinesDiff {\n\t\tif (\n\t\t\toriginalLines.length <= 1 &&\n\t\t\tequals(originalLines, modifiedLines, (a, b) => a === b)\n\t\t) {\n\t\t\treturn new LinesDiff([], [], false);\n\t\t}\n\n\t\tif (\n\t\t\t(originalLines.length === 1 && originalLines[0].length === 0) ||\n\t\t\t(modifiedLines.length === 1 && modifiedLines[0].length === 0)\n\t\t) {\n\t\t\treturn new LinesDiff(\n\t\t\t\t[\n\t\t\t\t\tnew DetailedLineRangeMapping(\n\t\t\t\t\t\tnew LineRange(1, originalLines.length + 1),\n\t\t\t\t\t\tnew LineRange(1, modifiedLines.length + 1),\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\tnew RangeMapping(\n\t\t\t\t\t\t\t\tnew Range(\n\t\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\t\toriginalLines.length,\n\t\t\t\t\t\t\t\t\toriginalLines[originalLines.length - 1]\n\t\t\t\t\t\t\t\t\t\t.length + 1,\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\tnew Range(\n\t\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\t\tmodifiedLines.length,\n\t\t\t\t\t\t\t\t\tmodifiedLines[modifiedLines.length - 1]\n\t\t\t\t\t\t\t\t\t\t.length + 1,\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t],\n\t\t\t\t\t),\n\t\t\t\t],\n\t\t\t\t[],\n\t\t\t\tfalse,\n\t\t\t);\n\t\t}\n\n\t\tconst timeout =\n\t\t\toptions.maxComputationTimeMs === 0\n\t\t\t\t? InfiniteTimeout.instance\n\t\t\t\t: new DateTimeout(options.maxComputationTimeMs);\n\t\tconst considerWhitespaceChanges = !options.ignoreTrimWhitespace;\n\n\t\tconst perfectHashes = new Map<string, number>();\n\t\tfunction getOrCreateHash(text: string): number {\n\t\t\tlet hash = perfectHashes.get(text);\n\t\t\tif (hash === undefined) {\n\t\t\t\thash = perfectHashes.size;\n\t\t\t\tperfectHashes.set(text, hash);\n\t\t\t}\n\t\t\treturn hash;\n\t\t}\n\n\t\tconst originalLinesHashes = originalLines.map((l) =>\n\t\t\tgetOrCreateHash(l.trim()),\n\t\t);\n\t\tconst modifiedLinesHashes = modifiedLines.map((l) =>\n\t\t\tgetOrCreateHash(l.trim()),\n\t\t);\n\n\t\tconst sequence1 = new LineSequence(originalLinesHashes, originalLines);\n\t\tconst sequence2 = new LineSequence(modifiedLinesHashes, modifiedLines);\n\n\t\tconst lineAlignmentResult = (() => {\n\t\t\tif (sequence1.length + sequence2.length < 1700) {\n\t\t\t\t// Use the improved algorithm for small files\n\t\t\t\treturn this.dynamicProgrammingDiffing.compute(\n\t\t\t\t\tsequence1,\n\t\t\t\t\tsequence2,\n\t\t\t\t\ttimeout,\n\t\t\t\t\t(offset1, offset2) =>\n\t\t\t\t\t\toriginalLines[offset1] === modifiedLines[offset2]\n\t\t\t\t\t\t\t? modifiedLines[offset2].length === 0\n\t\t\t\t\t\t\t\t? 0.1\n\t\t\t\t\t\t\t\t: 1 +\n\t\t\t\t\t\t\t\t\tMath.log(1 + modifiedLines[offset2].length)\n\t\t\t\t\t\t\t: 0.99,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn this.myersDiffingAlgorithm.compute(\n\t\t\t\tsequence1,\n\t\t\t\tsequence2,\n\t\t\t\ttimeout,\n\t\t\t);\n\t\t})();\n\n\t\tlet lineAlignments = lineAlignmentResult.diffs;\n\t\tlet hitTimeout = lineAlignmentResult.hitTimeout;\n\t\tlineAlignments = optimizeSequenceDiffs(\n\t\t\tsequence1,\n\t\t\tsequence2,\n\t\t\tlineAlignments,\n\t\t);\n\t\tlineAlignments = removeVeryShortMatchingLinesBetweenDiffs(\n\t\t\tsequence1,\n\t\t\tsequence2,\n\t\t\tlineAlignments,\n\t\t);\n\n\t\tconst alignments: RangeMapping[] = [];\n\n\t\tconst scanForWhitespaceChanges = (equalLinesCount: number) => {\n\t\t\tif (!considerWhitespaceChanges) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < equalLinesCount; i++) {\n\t\t\t\tconst seq1Offset = seq1LastStart + i;\n\t\t\t\tconst seq2Offset = seq2LastStart + i;\n\t\t\t\tif (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {\n\t\t\t\t\t// This is because of whitespace changes, diff these lines\n\t\t\t\t\tconst characterDiffs = this.refineDiff(\n\t\t\t\t\t\toriginalLines,\n\t\t\t\t\t\tmodifiedLines,\n\t\t\t\t\t\tnew SequenceDiff(\n\t\t\t\t\t\t\tnew OffsetRange(seq1Offset, seq1Offset + 1),\n\t\t\t\t\t\t\tnew OffsetRange(seq2Offset, seq2Offset + 1),\n\t\t\t\t\t\t),\n\t\t\t\t\t\ttimeout,\n\t\t\t\t\t\tconsiderWhitespaceChanges,\n\t\t\t\t\t);\n\t\t\t\t\tfor (const a of characterDiffs.mappings) {\n\t\t\t\t\t\talignments.push(a);\n\t\t\t\t\t}\n\t\t\t\t\tif (characterDiffs.hitTimeout) {\n\t\t\t\t\t\thitTimeout = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tlet seq1LastStart = 0;\n\t\tlet seq2LastStart = 0;\n\n\t\tfor (const diff of lineAlignments) {\n\t\t\tassertFn(\n\t\t\t\t() =>\n\t\t\t\t\tdiff.seq1Range.start - seq1LastStart ===\n\t\t\t\t\tdiff.seq2Range.start - seq2LastStart,\n\t\t\t);\n\n\t\t\tconst equalLinesCount = diff.seq1Range.start - seq1LastStart;\n\n\t\t\tscanForWhitespaceChanges(equalLinesCount);\n\n\t\t\tseq1LastStart = diff.seq1Range.endExclusive;\n\t\t\tseq2LastStart = diff.seq2Range.endExclusive;\n\n\t\t\tconst characterDiffs = this.refineDiff(\n\t\t\t\toriginalLines,\n\t\t\t\tmodifiedLines,\n\t\t\t\tdiff,\n\t\t\t\ttimeout,\n\t\t\t\tconsiderWhitespaceChanges,\n\t\t\t);\n\t\t\tif (characterDiffs.hitTimeout) {\n\t\t\t\thitTimeout = true;\n\t\t\t}\n\t\t\tfor (const a of characterDiffs.mappings) {\n\t\t\t\talignments.push(a);\n\t\t\t}\n\t\t}\n\n\t\tscanForWhitespaceChanges(originalLines.length - seq1LastStart);\n\n\t\tconst changes = lineRangeMappingFromRangeMappings(\n\t\t\talignments,\n\t\t\toriginalLines,\n\t\t\tmodifiedLines,\n\t\t);\n\n\t\tlet moves: MovedText[] = [];\n\t\tif (options.computeMoves) {\n\t\t\tmoves = this.computeMoves(\n\t\t\t\tchanges,\n\t\t\t\toriginalLines,\n\t\t\t\tmodifiedLines,\n\t\t\t\toriginalLinesHashes,\n\t\t\t\tmodifiedLinesHashes,\n\t\t\t\ttimeout,\n\t\t\t\tconsiderWhitespaceChanges,\n\t\t\t);\n\t\t}\n\n\t\t// Make sure all ranges are valid\n\t\tassertFn(() => {\n\t\t\tfunction validatePosition(pos: Position, lines: string[]): boolean {\n\t\t\t\tif (pos.lineNumber < 1 || pos.lineNumber > lines.length) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tconst line = lines[pos.lineNumber - 1];\n\t\t\t\tif (pos.column < 1 || pos.column > line.length + 1) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tfunction validateRange(range: LineRange, lines: string[]): boolean {\n\t\t\t\tif (\n\t\t\t\t\trange.startLineNumber < 1 ||\n\t\t\t\t\trange.startLineNumber > lines.length + 1\n\t\t\t\t) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\trange.endLineNumberExclusive < 1 ||\n\t\t\t\t\trange.endLineNumberExclusive > lines.length + 1\n\t\t\t\t) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tfor (const c of changes) {\n\t\t\t\tif (!c.innerChanges) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tfor (const ic of c.innerChanges) {\n\t\t\t\t\tconst valid =\n\t\t\t\t\t\tvalidatePosition(\n\t\t\t\t\t\t\tic.modifiedRange.getStartPosition(),\n\t\t\t\t\t\t\tmodifiedLines,\n\t\t\t\t\t\t) &&\n\t\t\t\t\t\tvalidatePosition(\n\t\t\t\t\t\t\tic.modifiedRange.getEndPosition(),\n\t\t\t\t\t\t\tmodifiedLines,\n\t\t\t\t\t\t) &&\n\t\t\t\t\t\tvalidatePosition(\n\t\t\t\t\t\t\tic.originalRange.getStartPosition(),\n\t\t\t\t\t\t\toriginalLines,\n\t\t\t\t\t\t) &&\n\t\t\t\t\t\tvalidatePosition(\n\t\t\t\t\t\t\tic.originalRange.getEndPosition(),\n\t\t\t\t\t\t\toriginalLines,\n\t\t\t\t\t\t);\n\t\t\t\t\tif (!valid) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\t!validateRange(c.modified, modifiedLines) ||\n\t\t\t\t\t!validateRange(c.original, originalLines)\n\t\t\t\t) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\n\t\treturn new LinesDiff(changes, moves, hitTimeout);\n\t}\n\n\tprivate computeMoves(\n\t\tchanges: DetailedLineRangeMapping[],\n\t\toriginalLines: string[],\n\t\tmodifiedLines: string[],\n\t\thashedOriginalLines: number[],\n\t\thashedModifiedLines: number[],\n\t\ttimeout: ITimeout,\n\t\tconsiderWhitespaceChanges: boolean,\n\t): MovedText[] {\n\t\tconst moves = computeMovedLines(\n\t\t\tchanges,\n\t\t\toriginalLines,\n\t\t\tmodifiedLines,\n\t\t\thashedOriginalLines,\n\t\t\thashedModifiedLines,\n\t\t\ttimeout,\n\t\t);\n\t\tconst movesWithDiffs = moves.map((m) => {\n\t\t\tconst moveChanges = this.refineDiff(\n\t\t\t\toriginalLines,\n\t\t\t\tmodifiedLines,\n\t\t\t\tnew SequenceDiff(\n\t\t\t\t\tm.original.toOffsetRange(),\n\t\t\t\t\tm.modified.toOffsetRange(),\n\t\t\t\t),\n\t\t\t\ttimeout,\n\t\t\t\tconsiderWhitespaceChanges,\n\t\t\t);\n\t\t\tconst mappings = lineRangeMappingFromRangeMappings(\n\t\t\t\tmoveChanges.mappings,\n\t\t\t\toriginalLines,\n\t\t\t\tmodifiedLines,\n\t\t\t\ttrue,\n\t\t\t);\n\t\t\treturn new MovedText(m, mappings);\n\t\t});\n\t\treturn movesWithDiffs;\n\t}\n\n\tprivate refineDiff(\n\t\toriginalLines: string[],\n\t\tmodifiedLines: string[],\n\t\tdiff: SequenceDiff,\n\t\ttimeout: ITimeout,\n\t\tconsiderWhitespaceChanges: boolean,\n\t): { mappings: RangeMapping[]; hitTimeout: boolean } {\n\t\tconst lineRangeMapping = toLineRangeMapping(diff);\n\t\tconst rangeMapping = lineRangeMapping.toRangeMapping2(\n\t\t\toriginalLines,\n\t\t\tmodifiedLines,\n\t\t);\n\n\t\tconst slice1 = new LinesSliceCharSequence(\n\t\t\toriginalLines,\n\t\t\trangeMapping.originalRange,\n\t\t\tconsiderWhitespaceChanges,\n\t\t);\n\t\tconst slice2 = new LinesSliceCharSequence(\n\t\t\tmodifiedLines,\n\t\t\trangeMapping.modifiedRange,\n\t\t\tconsiderWhitespaceChanges,\n\t\t);\n\n\t\tconst diffResult =\n\t\t\tslice1.length + slice2.length < 500\n\t\t\t\t? this.dynamicProgrammingDiffing.compute(\n\t\t\t\t\t\tslice1,\n\t\t\t\t\t\tslice2,\n\t\t\t\t\t\ttimeout,\n\t\t\t\t\t)\n\t\t\t\t: this.myersDiffingAlgorithm.compute(slice1, slice2, timeout);\n\n\t\tconst check = false;\n\n\t\tlet diffs = diffResult.diffs;\n\t\tif (check) {\n\t\t\tSequenceDiff.assertSorted(diffs);\n\t\t}\n\t\tdiffs = optimizeSequenceDiffs(slice1, slice2, diffs);\n\t\tif (check) {\n\t\t\tSequenceDiff.assertSorted(diffs);\n\t\t}\n\t\tdiffs = extendDiffsToEntireWordIfAppropriate(slice1, slice2, diffs);\n\t\tif (check) {\n\t\t\tSequenceDiff.assertSorted(diffs);\n\t\t}\n\t\tdiffs = removeShortMatches(slice1, slice2, diffs);\n\t\tif (check) {\n\t\t\tSequenceDiff.assertSorted(diffs);\n\t\t}\n\t\tdiffs = removeVeryShortMatchingTextBetweenLongDiffs(\n\t\t\tslice1,\n\t\t\tslice2,\n\t\t\tdiffs,\n\t\t);\n\t\tif (check) {\n\t\t\tSequenceDiff.assertSorted(diffs);\n\t\t}\n\n\t\tconst result = diffs.map(\n\t\t\t(d) =>\n\t\t\t\tnew RangeMapping(\n\t\t\t\t\tslice1.translateRange(d.seq1Range),\n\t\t\t\t\tslice2.translateRange(d.seq2Range),\n\t\t\t\t),\n\t\t);\n\n\t\tif (check) {\n\t\t\tRangeMapping.assertSorted(result);\n\t\t}\n\n\t\t// Assert: result applied on original should be the same as diff applied to original\n\n\t\treturn {\n\t\t\tmappings: result,\n\t\t\thitTimeout: diffResult.hitTimeout,\n\t\t};\n\t}\n}\n\nexport function lineRangeMappingFromRangeMappings(\n\talignments: RangeMapping[],\n\toriginalLines: string[],\n\tmodifiedLines: string[],\n\tdontAssertStartLine = false,\n): DetailedLineRangeMapping[] {\n\tconst changes: DetailedLineRangeMapping[] = [];\n\tfor (const g of groupAdjacentBy(\n\t\talignments.map((a) =>\n\t\t\tgetLineRangeMapping(a, originalLines, modifiedLines),\n\t\t),\n\t\t(a1, a2) =>\n\t\t\ta1.original.overlapOrTouch(a2.original) ||\n\t\t\ta1.modified.overlapOrTouch(a2.modified),\n\t)) {\n\t\tconst first = g[0];\n\t\tconst last = g[g.length - 1];\n\n\t\tchanges.push(\n\t\t\tnew DetailedLineRangeMapping(\n\t\t\t\tfirst.original.join(last.original),\n\t\t\t\tfirst.modified.join(last.modified),\n\t\t\t\tg.map((a) => a.innerChanges![0]),\n\t\t\t),\n\t\t);\n\t}\n\n\tassertFn(() => {\n\t\tif (!dontAssertStartLine && changes.length > 0) {\n\t\t\tif (\n\t\t\t\tchanges[0].modified.startLineNumber !==\n\t\t\t\tchanges[0].original.startLineNumber\n\t\t\t) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (\n\t\t\t\tmodifiedLines.length -\n\t\t\t\t\tchanges[changes.length - 1].modified\n\t\t\t\t\t\t.endLineNumberExclusive !==\n\t\t\t\toriginalLines.length -\n\t\t\t\t\tchanges[changes.length - 1].original.endLineNumberExclusive\n\t\t\t) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn checkAdjacentItems(\n\t\t\tchanges,\n\t\t\t(m1, m2) =>\n\t\t\t\tm2.original.startLineNumber -\n\t\t\t\t\tm1.original.endLineNumberExclusive ===\n\t\t\t\t\tm2.modified.startLineNumber -\n\t\t\t\t\t\tm1.modified.endLineNumberExclusive &&\n\t\t\t\t// There has to be an unchanged line in between (otherwise both diffs should have been joined)\n\t\t\t\tm1.original.endLineNumberExclusive <\n\t\t\t\t\tm2.original.startLineNumber &&\n\t\t\t\tm1.modified.endLineNumberExclusive <\n\t\t\t\t\tm2.modified.startLineNumber,\n\t\t);\n\t});\n\n\treturn changes;\n}\n\nexport function getLineRangeMapping(\n\trangeMapping: RangeMapping,\n\toriginalLines: string[],\n\tmodifiedLines: string[],\n): DetailedLineRangeMapping {\n\tlet lineStartDelta = 0;\n\tlet lineEndDelta = 0;\n\n\t// rangeMapping describes the edit that replaces `rangeMapping.originalRange` with `newText := getText(modifiedLines, rangeMapping.modifiedRange)`.\n\n\t// original: ]xxx \\n <- this line is not modified\n\t// modified: ]xx  \\n\n\tif (\n\t\trangeMapping.modifiedRange.endColumn === 1 &&\n\t\trangeMapping.originalRange.endColumn === 1 &&\n\t\trangeMapping.originalRange.startLineNumber + lineStartDelta <=\n\t\t\trangeMapping.originalRange.endLineNumber &&\n\t\trangeMapping.modifiedRange.startLineNumber + lineStartDelta <=\n\t\t\trangeMapping.modifiedRange.endLineNumber\n\t) {\n\t\t// We can only do this if the range is not empty yet\n\t\tlineEndDelta = -1;\n\t}\n\n\t// original: xxx[ \\n <- this line is not modified\n\t// modified: xxx[ \\n\n\tif (\n\t\trangeMapping.modifiedRange.startColumn - 1 >=\n\t\t\tmodifiedLines[rangeMapping.modifiedRange.startLineNumber - 1]\n\t\t\t\t.length &&\n\t\trangeMapping.originalRange.startColumn - 1 >=\n\t\t\toriginalLines[rangeMapping.originalRange.startLineNumber - 1]\n\t\t\t\t.length &&\n\t\trangeMapping.originalRange.startLineNumber <=\n\t\t\trangeMapping.originalRange.endLineNumber + lineEndDelta &&\n\t\trangeMapping.modifiedRange.startLineNumber <=\n\t\t\trangeMapping.modifiedRange.endLineNumber + lineEndDelta\n\t) {\n\t\t// We can only do this if the range is not empty yet\n\t\tlineStartDelta = 1;\n\t}\n\n\tconst originalLineRange = new LineRange(\n\t\trangeMapping.originalRange.startLineNumber + lineStartDelta,\n\t\trangeMapping.originalRange.endLineNumber + 1 + lineEndDelta,\n\t);\n\tconst modifiedLineRange = new LineRange(\n\t\trangeMapping.modifiedRange.startLineNumber + lineStartDelta,\n\t\trangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta,\n\t);\n\n\treturn new DetailedLineRangeMapping(originalLineRange, modifiedLineRange, [\n\t\trangeMapping,\n\t]);\n}\n\nfunction toLineRangeMapping(sequenceDiff: SequenceDiff) {\n\treturn new LineRangeMapping(\n\t\tnew LineRange(\n\t\t\tsequenceDiff.seq1Range.start + 1,\n\t\t\tsequenceDiff.seq1Range.endExclusive + 1,\n\t\t),\n\t\tnew LineRange(\n\t\t\tsequenceDiff.seq2Range.start + 1,\n\t\t\tsequenceDiff.seq2Range.endExclusive + 1,\n\t\t),\n\t);\n}\n"],
  "mappings": "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",
  "names": []
}
