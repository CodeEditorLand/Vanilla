import{SequenceDiff as B}from"./algorithms/diffAlgorithm.js";import{LineRangeMapping as w}from"../rangeMapping.js";import{pushMany as F,compareBy as S,numberComparator as T,reverseOrder as P}from"../../../../base/common/arrays.js";import{MonotonousArray as D,findLastMonotonous as C}from"../../../../base/common/arraysFind.js";import{SetMap as q}from"../../../../base/common/map.js";import{LineRange as b,LineRangeSet as y}from"../../core/lineRange.js";import{LinesSliceCharSequence as A}from"./linesSliceCharSequence.js";import{LineRangeFragment as I,isSpace as k}from"./utils.js";import{MyersDiffAlgorithm as j}from"./algorithms/myersDiffAlgorithm.js";import{Range as O}from"../../core/range.js";function oe(n,i,a,m,g,d){let{moves:o,excludedChanges:f}=W(n,i,a,d);if(!d.isValid())return[];const r=n.filter(s=>!f.has(s)),c=H(r,m,g,i,a,d);return F(o,c),o=U(o),o=o.filter(s=>{const L=s.original.toOffsetRange().slice(i).map(e=>e.trim());return L.join(`
`).length>=15&&V(L,e=>e.length>=2)>=2}),o=z(n,o),o}function V(n,i){let a=0;for(const m of n)i(m)&&a++;return a}function W(n,i,a,m){const g=[],d=n.filter(r=>r.modified.isEmpty&&r.original.length>=3).map(r=>new I(r.original,i,r)),o=new Set(n.filter(r=>r.original.isEmpty&&r.modified.length>=3).map(r=>new I(r.modified,a,r))),f=new Set;for(const r of d){let c=-1,s;for(const L of o){const t=r.computeSimilarity(L);t>c&&(c=t,s=L)}if(c>.9&&s&&(o.delete(s),g.push(new w(r.range,s.range)),f.add(r.source),f.add(s.source)),!m.isValid())return{moves:g,excludedChanges:f}}return{moves:g,excludedChanges:f}}function H(n,i,a,m,g,d){const o=[],f=new q;for(const t of n)for(let e=t.original.startLineNumber;e<t.original.endLineNumberExclusive-2;e++){const p=`${i[e-1]}:${i[e+1-1]}:${i[e+2-1]}`;f.add(p,{range:new b(e,e+3)})}const r=[];n.sort(S(t=>t.modified.startLineNumber,T));for(const t of n){let e=[];for(let p=t.modified.startLineNumber;p<t.modified.endLineNumberExclusive-2;p++){const E=`${a[p-1]}:${a[p+1-1]}:${a[p+2-1]}`,M=new b(p,p+3),h=[];f.forEach(E,({range:R})=>{for(const u of e)if(u.originalLineRange.endLineNumberExclusive+1===R.endLineNumberExclusive&&u.modifiedLineRange.endLineNumberExclusive+1===M.endLineNumberExclusive){u.originalLineRange=new b(u.originalLineRange.startLineNumber,R.endLineNumberExclusive),u.modifiedLineRange=new b(u.modifiedLineRange.startLineNumber,M.endLineNumberExclusive),h.push(u);return}const v={modifiedLineRange:M,originalLineRange:R};r.push(v),h.push(v)}),e=h}if(!d.isValid())return[]}r.sort(P(S(t=>t.modifiedLineRange.length,T)));const c=new y,s=new y;for(const t of r){const e=t.modifiedLineRange.startLineNumber-t.originalLineRange.startLineNumber,p=c.subtractFrom(t.modifiedLineRange),E=s.subtractFrom(t.originalLineRange).getWithDelta(e),M=p.getIntersection(E);for(const h of M.ranges){if(h.length<3)continue;const R=h,v=h.delta(-e);o.push(new w(v,R)),c.addRange(R),s.addRange(v)}}o.sort(S(t=>t.original.startLineNumber,T));const L=new D(n);for(let t=0;t<o.length;t++){const e=o[t],p=L.findLastMonotonous(l=>l.original.startLineNumber<=e.original.startLineNumber),E=C(n,l=>l.modified.startLineNumber<=e.modified.startLineNumber),M=Math.max(e.original.startLineNumber-p.original.startLineNumber,e.modified.startLineNumber-E.modified.startLineNumber),h=L.findLastMonotonous(l=>l.original.startLineNumber<e.original.endLineNumberExclusive),R=C(n,l=>l.modified.startLineNumber<e.modified.endLineNumberExclusive),v=Math.max(h.original.endLineNumberExclusive-e.original.endLineNumberExclusive,R.modified.endLineNumberExclusive-e.modified.endLineNumberExclusive);let u;for(u=0;u<M;u++){const l=e.original.startLineNumber-u-1,x=e.modified.startLineNumber-u-1;if(l>m.length||x>g.length||c.contains(x)||s.contains(l)||!$(m[l-1],g[x-1],d))break}u>0&&(s.addRange(new b(e.original.startLineNumber-u,e.original.startLineNumber)),c.addRange(new b(e.modified.startLineNumber-u,e.modified.startLineNumber)));let N;for(N=0;N<v;N++){const l=e.original.endLineNumberExclusive+N,x=e.modified.endLineNumberExclusive+N;if(l>m.length||x>g.length||c.contains(x)||s.contains(l)||!$(m[l-1],g[x-1],d))break}N>0&&(s.addRange(new b(e.original.endLineNumberExclusive,e.original.endLineNumberExclusive+N)),c.addRange(new b(e.modified.endLineNumberExclusive,e.modified.endLineNumberExclusive+N))),(u>0||N>0)&&(o[t]=new w(new b(e.original.startLineNumber-u,e.original.endLineNumberExclusive+N),new b(e.modified.startLineNumber-u,e.modified.endLineNumberExclusive+N)))}return o}function $(n,i,a){if(n.trim()===i.trim())return!0;if(n.length>300&&i.length>300)return!1;const g=new j().compute(new A([n],new O(1,1,1,n.length),!1),new A([i],new O(1,1,1,i.length),!1),a);let d=0;const o=B.invert(g.diffs,n.length);for(const s of o)s.seq1Range.forEach(L=>{k(n.charCodeAt(L))||d++});function f(s){let L=0;for(let t=0;t<n.length;t++)k(s.charCodeAt(t))||L++;return L}const r=f(n.length>i.length?n:i);return d/r>.6&&r>10}function U(n){if(n.length===0)return n;n.sort(S(a=>a.original.startLineNumber,T));const i=[n[0]];for(let a=1;a<n.length;a++){const m=i[i.length-1],g=n[a],d=g.original.startLineNumber-m.original.endLineNumberExclusive,o=g.modified.startLineNumber-m.modified.endLineNumberExclusive;if(d>=0&&o>=0&&d+o<=2){i[i.length-1]=m.join(g);continue}i.push(g)}return i}function z(n,i){const a=new D(n);return i=i.filter(m=>{const g=a.findLastMonotonous(f=>f.original.startLineNumber<m.original.endLineNumberExclusive)||new w(new b(1,1),new b(1,1)),d=C(n,f=>f.modified.startLineNumber<m.modified.endLineNumberExclusive);return g!==d}),i}export{oe as computeMovedLines};
