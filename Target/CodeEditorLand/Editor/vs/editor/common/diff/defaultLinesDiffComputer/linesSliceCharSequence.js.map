{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport {\n\tfindFirstMonotonous,\n\tfindLastIdxMonotonous,\n\tfindLastMonotonous,\n} from \"../../../../base/common/arraysFind.js\";\nimport { CharCode } from \"../../../../base/common/charCode.js\";\nimport { OffsetRange } from \"../../core/offsetRange.js\";\nimport { Position } from \"../../core/position.js\";\nimport { Range } from \"../../core/range.js\";\nimport type { ISequence } from \"./algorithms/diffAlgorithm.js\";\nimport { isSpace } from \"./utils.js\";\n\nexport class LinesSliceCharSequence implements ISequence {\n\tprivate readonly elements: number[] = [];\n\tprivate readonly firstElementOffsetByLineIdx: number[] = [];\n\tprivate readonly lineStartOffsets: number[] = [];\n\tprivate readonly trimmedWsLengthsByLineIdx: number[] = [];\n\n\tconstructor(\n\t\tpublic readonly lines: string[],\n\t\tprivate readonly range: Range,\n\t\tpublic readonly considerWhitespaceChanges: boolean,\n\t) {\n\t\tthis.firstElementOffsetByLineIdx.push(0);\n\t\tfor (\n\t\t\tlet lineNumber = this.range.startLineNumber;\n\t\t\tlineNumber <= this.range.endLineNumber;\n\t\t\tlineNumber++\n\t\t) {\n\t\t\tlet line = lines[lineNumber - 1];\n\t\t\tlet lineStartOffset = 0;\n\t\t\tif (\n\t\t\t\tlineNumber === this.range.startLineNumber &&\n\t\t\t\tthis.range.startColumn > 1\n\t\t\t) {\n\t\t\t\tlineStartOffset = this.range.startColumn - 1;\n\t\t\t\tline = line.substring(lineStartOffset);\n\t\t\t}\n\t\t\tthis.lineStartOffsets.push(lineStartOffset);\n\n\t\t\tlet trimmedWsLength = 0;\n\t\t\tif (!considerWhitespaceChanges) {\n\t\t\t\tconst trimmedStartLine = line.trimStart();\n\t\t\t\ttrimmedWsLength = line.length - trimmedStartLine.length;\n\t\t\t\tline = trimmedStartLine.trimEnd();\n\t\t\t}\n\t\t\tthis.trimmedWsLengthsByLineIdx.push(trimmedWsLength);\n\n\t\t\tconst lineLength =\n\t\t\t\tlineNumber === this.range.endLineNumber\n\t\t\t\t\t? Math.min(\n\t\t\t\t\t\t\tthis.range.endColumn -\n\t\t\t\t\t\t\t\t1 -\n\t\t\t\t\t\t\t\tlineStartOffset -\n\t\t\t\t\t\t\t\ttrimmedWsLength,\n\t\t\t\t\t\t\tline.length,\n\t\t\t\t\t\t)\n\t\t\t\t\t: line.length;\n\t\t\tfor (let i = 0; i < lineLength; i++) {\n\t\t\t\tthis.elements.push(line.charCodeAt(i));\n\t\t\t}\n\n\t\t\tif (lineNumber < this.range.endLineNumber) {\n\t\t\t\tthis.elements.push(\"\\n\".charCodeAt(0));\n\t\t\t\tthis.firstElementOffsetByLineIdx.push(this.elements.length);\n\t\t\t}\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn `Slice: \"${this.text}\"`;\n\t}\n\n\tget text(): string {\n\t\treturn this.getText(new OffsetRange(0, this.length));\n\t}\n\n\tgetText(range: OffsetRange): string {\n\t\treturn this.elements\n\t\t\t.slice(range.start, range.endExclusive)\n\t\t\t.map((e) => String.fromCharCode(e))\n\t\t\t.join(\"\");\n\t}\n\n\tgetElement(offset: number): number {\n\t\treturn this.elements[offset];\n\t}\n\n\tget length(): number {\n\t\treturn this.elements.length;\n\t}\n\n\tpublic getBoundaryScore(length: number): number {\n\t\t//   a   b   c   ,           d   e   f\n\t\t// 11  0   0   12  15  6   13  0   0   11\n\n\t\tconst prevCategory = getCategory(\n\t\t\tlength > 0 ? this.elements[length - 1] : -1,\n\t\t);\n\t\tconst nextCategory = getCategory(\n\t\t\tlength < this.elements.length ? this.elements[length] : -1,\n\t\t);\n\n\t\tif (\n\t\t\tprevCategory === CharBoundaryCategory.LineBreakCR &&\n\t\t\tnextCategory === CharBoundaryCategory.LineBreakLF\n\t\t) {\n\t\t\t// don't break between \\r and \\n\n\t\t\treturn 0;\n\t\t}\n\t\tif (prevCategory === CharBoundaryCategory.LineBreakLF) {\n\t\t\t// prefer the linebreak before the change\n\t\t\treturn 150;\n\t\t}\n\n\t\tlet score = 0;\n\t\tif (prevCategory !== nextCategory) {\n\t\t\tscore += 10;\n\t\t\tif (\n\t\t\t\tprevCategory === CharBoundaryCategory.WordLower &&\n\t\t\t\tnextCategory === CharBoundaryCategory.WordUpper\n\t\t\t) {\n\t\t\t\tscore += 1;\n\t\t\t}\n\t\t}\n\n\t\tscore += getCategoryBoundaryScore(prevCategory);\n\t\tscore += getCategoryBoundaryScore(nextCategory);\n\n\t\treturn score;\n\t}\n\n\tpublic translateOffset(\n\t\toffset: number,\n\t\tpreference: \"left\" | \"right\" = \"right\",\n\t): Position {\n\t\t// find smallest i, so that lineBreakOffsets[i] <= offset using binary search\n\t\tconst i = findLastIdxMonotonous(\n\t\t\tthis.firstElementOffsetByLineIdx,\n\t\t\t(value) => value <= offset,\n\t\t);\n\t\tconst lineOffset = offset - this.firstElementOffsetByLineIdx[i];\n\t\treturn new Position(\n\t\t\tthis.range.startLineNumber + i,\n\t\t\t1 +\n\t\t\t\tthis.lineStartOffsets[i] +\n\t\t\t\tlineOffset +\n\t\t\t\t(lineOffset === 0 && preference === \"left\"\n\t\t\t\t\t? 0\n\t\t\t\t\t: this.trimmedWsLengthsByLineIdx[i]),\n\t\t);\n\t}\n\n\tpublic translateRange(range: OffsetRange): Range {\n\t\tconst pos1 = this.translateOffset(range.start, \"right\");\n\t\tconst pos2 = this.translateOffset(range.endExclusive, \"left\");\n\t\tif (pos2.isBefore(pos1)) {\n\t\t\treturn Range.fromPositions(pos2, pos2);\n\t\t}\n\t\treturn Range.fromPositions(pos1, pos2);\n\t}\n\n\t/**\n\t * Finds the word that contains the character at the given offset\n\t */\n\tpublic findWordContaining(offset: number): OffsetRange | undefined {\n\t\tif (offset < 0 || offset >= this.elements.length) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!isWordChar(this.elements[offset])) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// find start\n\t\tlet start = offset;\n\t\twhile (start > 0 && isWordChar(this.elements[start - 1])) {\n\t\t\tstart--;\n\t\t}\n\n\t\t// find end\n\t\tlet end = offset;\n\t\twhile (end < this.elements.length && isWordChar(this.elements[end])) {\n\t\t\tend++;\n\t\t}\n\n\t\treturn new OffsetRange(start, end);\n\t}\n\n\tpublic countLinesIn(range: OffsetRange): number {\n\t\treturn (\n\t\t\tthis.translateOffset(range.endExclusive).lineNumber -\n\t\t\tthis.translateOffset(range.start).lineNumber\n\t\t);\n\t}\n\n\tpublic isStronglyEqual(offset1: number, offset2: number): boolean {\n\t\treturn this.elements[offset1] === this.elements[offset2];\n\t}\n\n\tpublic extendToFullLines(range: OffsetRange): OffsetRange {\n\t\tconst start =\n\t\t\tfindLastMonotonous(\n\t\t\t\tthis.firstElementOffsetByLineIdx,\n\t\t\t\t(x) => x <= range.start,\n\t\t\t) ?? 0;\n\t\tconst end =\n\t\t\tfindFirstMonotonous(\n\t\t\t\tthis.firstElementOffsetByLineIdx,\n\t\t\t\t(x) => range.endExclusive <= x,\n\t\t\t) ?? this.elements.length;\n\t\treturn new OffsetRange(start, end);\n\t}\n}\n\nfunction isWordChar(charCode: number): boolean {\n\treturn (\n\t\t(charCode >= CharCode.a && charCode <= CharCode.z) ||\n\t\t(charCode >= CharCode.A && charCode <= CharCode.Z) ||\n\t\t(charCode >= CharCode.Digit0 && charCode <= CharCode.Digit9)\n\t);\n}\n\nenum CharBoundaryCategory {\n\tWordLower = 0,\n\tWordUpper = 1,\n\tWordNumber = 2,\n\tEnd = 3,\n\tOther = 4,\n\tSeparator = 5,\n\tSpace = 6,\n\tLineBreakCR = 7,\n\tLineBreakLF = 8,\n}\n\nconst score: Record<CharBoundaryCategory, number> = {\n\t[CharBoundaryCategory.WordLower]: 0,\n\t[CharBoundaryCategory.WordUpper]: 0,\n\t[CharBoundaryCategory.WordNumber]: 0,\n\t[CharBoundaryCategory.End]: 10,\n\t[CharBoundaryCategory.Other]: 2,\n\t[CharBoundaryCategory.Separator]: 30,\n\t[CharBoundaryCategory.Space]: 3,\n\t[CharBoundaryCategory.LineBreakCR]: 10,\n\t[CharBoundaryCategory.LineBreakLF]: 10,\n};\n\nfunction getCategoryBoundaryScore(category: CharBoundaryCategory): number {\n\treturn score[category];\n}\n\nfunction getCategory(charCode: number): CharBoundaryCategory {\n\tif (charCode === CharCode.LineFeed) {\n\t\treturn CharBoundaryCategory.LineBreakLF;\n\t} else if (charCode === CharCode.CarriageReturn) {\n\t\treturn CharBoundaryCategory.LineBreakCR;\n\t} else if (isSpace(charCode)) {\n\t\treturn CharBoundaryCategory.Space;\n\t} else if (charCode >= CharCode.a && charCode <= CharCode.z) {\n\t\treturn CharBoundaryCategory.WordLower;\n\t} else if (charCode >= CharCode.A && charCode <= CharCode.Z) {\n\t\treturn CharBoundaryCategory.WordUpper;\n\t} else if (charCode >= CharCode.Digit0 && charCode <= CharCode.Digit9) {\n\t\treturn CharBoundaryCategory.WordNumber;\n\t} else if (charCode === -1) {\n\t\treturn CharBoundaryCategory.End;\n\t} else if (charCode === CharCode.Comma || charCode === CharCode.Semicolon) {\n\t\treturn CharBoundaryCategory.Separator;\n\t} else {\n\t\treturn CharBoundaryCategory.Other;\n\t}\n}\n"],
  "mappings": "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",
  "names": ["score", "CharBoundaryCategory"]
}
