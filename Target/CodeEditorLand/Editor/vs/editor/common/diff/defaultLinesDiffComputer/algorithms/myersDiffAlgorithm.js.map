{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/myersDiffAlgorithm.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { OffsetRange } from \"../../../core/offsetRange.js\";\nimport {\n\tDiffAlgorithmResult,\n\ttype IDiffAlgorithm,\n\ttype ISequence,\n\ttype ITimeout,\n\tInfiniteTimeout,\n\tSequenceDiff,\n} from \"./diffAlgorithm.js\";\n\n/**\n * An O(ND) diff algorithm that has a quadratic space worst-case complexity.\n */\nexport class MyersDiffAlgorithm implements IDiffAlgorithm {\n\tcompute(\n\t\tseq1: ISequence,\n\t\tseq2: ISequence,\n\t\ttimeout: ITimeout = InfiniteTimeout.instance,\n\t): DiffAlgorithmResult {\n\t\t// These are common special cases.\n\t\t// The early return improves performance dramatically.\n\t\tif (seq1.length === 0 || seq2.length === 0) {\n\t\t\treturn DiffAlgorithmResult.trivial(seq1, seq2);\n\t\t}\n\n\t\tconst seqX = seq1; // Text on the x axis\n\t\tconst seqY = seq2; // Text on the y axis\n\n\t\tfunction getXAfterSnake(x: number, y: number): number {\n\t\t\twhile (\n\t\t\t\tx < seqX.length &&\n\t\t\t\ty < seqY.length &&\n\t\t\t\tseqX.getElement(x) === seqY.getElement(y)\n\t\t\t) {\n\t\t\t\tx++;\n\t\t\t\ty++;\n\t\t\t}\n\t\t\treturn x;\n\t\t}\n\n\t\tlet d = 0;\n\t\t// V[k]: X value of longest d-line that ends in diagonal k.\n\t\t// d-line: path from (0,0) to (x,y) that uses exactly d non-diagonals.\n\t\t// diagonal k: Set of points (x,y) with x-y = k.\n\t\t// k=1 -> (1,0),(2,1)\n\t\tconst V = new FastInt32Array();\n\t\tV.set(0, getXAfterSnake(0, 0));\n\n\t\tconst paths = new FastArrayNegativeIndices<SnakePath | null>();\n\t\tpaths.set(\n\t\t\t0,\n\t\t\tV.get(0) === 0 ? null : new SnakePath(null, 0, 0, V.get(0)),\n\t\t);\n\n\t\tlet k = 0;\n\n\t\tloop: while (true) {\n\t\t\td++;\n\t\t\tif (!timeout.isValid()) {\n\t\t\t\treturn DiffAlgorithmResult.trivialTimedOut(seqX, seqY);\n\t\t\t}\n\t\t\t// The paper has `for (k = -d; k <= d; k += 2)`, but we can ignore diagonals that cannot influence the result.\n\t\t\tconst lowerBound = -Math.min(d, seqY.length + (d % 2));\n\t\t\tconst upperBound = Math.min(d, seqX.length + (d % 2));\n\t\t\tfor (k = lowerBound; k <= upperBound; k += 2) {\n\t\t\t\tlet step = 0;\n\t\t\t\t// We can use the X values of (d-1)-lines to compute X value of the longest d-lines.\n\t\t\t\tconst maxXofDLineTop = k === upperBound ? -1 : V.get(k + 1); // We take a vertical non-diagonal (add a symbol in seqX)\n\t\t\t\tconst maxXofDLineLeft =\n\t\t\t\t\tk === lowerBound ? -1 : V.get(k - 1) + 1; // We take a horizontal non-diagonal (+1 x) (delete a symbol in seqX)\n\t\t\t\tstep++;\n\t\t\t\tconst x = Math.min(\n\t\t\t\t\tMath.max(maxXofDLineTop, maxXofDLineLeft),\n\t\t\t\t\tseqX.length,\n\t\t\t\t);\n\t\t\t\tconst y = x - k;\n\t\t\t\tstep++;\n\t\t\t\tif (x > seqX.length || y > seqY.length) {\n\t\t\t\t\t// This diagonal is irrelevant for the result.\n\t\t\t\t\t// TODO: Don't pay the cost for this in the next iteration.\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst newMaxX = getXAfterSnake(x, y);\n\t\t\t\tV.set(k, newMaxX);\n\t\t\t\tconst lastPath =\n\t\t\t\t\tx === maxXofDLineTop ? paths.get(k + 1) : paths.get(k - 1);\n\t\t\t\tpaths.set(\n\t\t\t\t\tk,\n\t\t\t\t\tnewMaxX !== x\n\t\t\t\t\t\t? new SnakePath(lastPath, x, y, newMaxX - x)\n\t\t\t\t\t\t: lastPath,\n\t\t\t\t);\n\n\t\t\t\tif (V.get(k) === seqX.length && V.get(k) - k === seqY.length) {\n\t\t\t\t\tbreak loop;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet path = paths.get(k);\n\t\tconst result: SequenceDiff[] = [];\n\t\tlet lastAligningPosS1: number = seqX.length;\n\t\tlet lastAligningPosS2: number = seqY.length;\n\n\t\twhile (true) {\n\t\t\tconst endX = path ? path.x + path.length : 0;\n\t\t\tconst endY = path ? path.y + path.length : 0;\n\n\t\t\tif (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {\n\t\t\t\tresult.push(\n\t\t\t\t\tnew SequenceDiff(\n\t\t\t\t\t\tnew OffsetRange(endX, lastAligningPosS1),\n\t\t\t\t\t\tnew OffsetRange(endY, lastAligningPosS2),\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (!path) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlastAligningPosS1 = path.x;\n\t\t\tlastAligningPosS2 = path.y;\n\n\t\t\tpath = path.prev;\n\t\t}\n\n\t\tresult.reverse();\n\t\treturn new DiffAlgorithmResult(result, false);\n\t}\n}\n\nclass SnakePath {\n\tconstructor(\n\t\tpublic readonly prev: SnakePath | null,\n\t\tpublic readonly x: number,\n\t\tpublic readonly y: number,\n\t\tpublic readonly length: number,\n\t) {}\n}\n\n/**\n * An array that supports fast negative indices.\n */\nclass FastInt32Array {\n\tprivate positiveArr: Int32Array = new Int32Array(10);\n\tprivate negativeArr: Int32Array = new Int32Array(10);\n\n\tget(idx: number): number {\n\t\tif (idx < 0) {\n\t\t\tidx = -idx - 1;\n\t\t\treturn this.negativeArr[idx];\n\t\t} else {\n\t\t\treturn this.positiveArr[idx];\n\t\t}\n\t}\n\n\tset(idx: number, value: number): void {\n\t\tif (idx < 0) {\n\t\t\tidx = -idx - 1;\n\t\t\tif (idx >= this.negativeArr.length) {\n\t\t\t\tconst arr = this.negativeArr;\n\t\t\t\tthis.negativeArr = new Int32Array(arr.length * 2);\n\t\t\t\tthis.negativeArr.set(arr);\n\t\t\t}\n\t\t\tthis.negativeArr[idx] = value;\n\t\t} else {\n\t\t\tif (idx >= this.positiveArr.length) {\n\t\t\t\tconst arr = this.positiveArr;\n\t\t\t\tthis.positiveArr = new Int32Array(arr.length * 2);\n\t\t\t\tthis.positiveArr.set(arr);\n\t\t\t}\n\t\t\tthis.positiveArr[idx] = value;\n\t\t}\n\t}\n}\n\n/**\n * An array that supports fast negative indices.\n */\nclass FastArrayNegativeIndices<T> {\n\tprivate readonly positiveArr: T[] = [];\n\tprivate readonly negativeArr: T[] = [];\n\n\tget(idx: number): T {\n\t\tif (idx < 0) {\n\t\t\tidx = -idx - 1;\n\t\t\treturn this.negativeArr[idx];\n\t\t} else {\n\t\t\treturn this.positiveArr[idx];\n\t\t}\n\t}\n\n\tset(idx: number, value: T): void {\n\t\tif (idx < 0) {\n\t\t\tidx = -idx - 1;\n\t\t\tthis.negativeArr[idx] = value;\n\t\t} else {\n\t\t\tthis.positiveArr[idx] = value;\n\t\t}\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
