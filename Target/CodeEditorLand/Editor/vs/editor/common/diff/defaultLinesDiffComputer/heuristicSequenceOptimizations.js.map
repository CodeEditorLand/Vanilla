{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { forEachWithNeighbors } from '../../../../base/common/arrays.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { ISequence, OffsetPair, SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { LineSequence } from './lineSequence.js';\nimport { LinesSliceCharSequence } from './linesSliceCharSequence.js';\n\nexport function optimizeSequenceDiffs(sequence1: ISequence, sequence2: ISequence, sequenceDiffs: SequenceDiff[]): SequenceDiff[] {\n\tlet result = sequenceDiffs;\n\tresult = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n\t// Sometimes, calling this function twice improves the result.\n\t// Uncomment the second invocation and run the tests to see the difference.\n\tresult = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n\tresult = shiftSequenceDiffs(sequence1, sequence2, result);\n\treturn result;\n}\n\n/**\n * This function fixes issues like this:\n * ```\n * import { Baz, Bar } from \"foo\";\n * ```\n * <->\n * ```\n * import { Baz, Bar, Foo } from \"foo\";\n * ```\n * Computed diff: [ {Add \",\" after Bar}, {Add \"Foo \" after space} }\n * Improved diff: [{Add \", Foo\" after Bar}]\n */\nfunction joinSequenceDiffsByShifting(sequence1: ISequence, sequence2: ISequence, sequenceDiffs: SequenceDiff[]): SequenceDiff[] {\n\tif (sequenceDiffs.length === 0) {\n\t\treturn sequenceDiffs;\n\t}\n\n\tconst result: SequenceDiff[] = [];\n\tresult.push(sequenceDiffs[0]);\n\n\t// First move them all to the left as much as possible and join them if possible\n\tfor (let i = 1; i < sequenceDiffs.length; i++) {\n\t\tconst prevResult = result[result.length - 1];\n\t\tlet cur = sequenceDiffs[i];\n\n\t\tif (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n\t\t\tconst length = cur.seq1Range.start - prevResult.seq1Range.endExclusive;\n\t\t\tlet d;\n\t\t\tfor (d = 1; d <= length; d++) {\n\t\t\t\tif (\n\t\t\t\t\tsequence1.getElement(cur.seq1Range.start - d) !== sequence1.getElement(cur.seq1Range.endExclusive - d) ||\n\t\t\t\t\tsequence2.getElement(cur.seq2Range.start - d) !== sequence2.getElement(cur.seq2Range.endExclusive - d)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\td--;\n\n\t\t\tif (d === length) {\n\t\t\t\t// Merge previous and current diff\n\t\t\t\tresult[result.length - 1] = new SequenceDiff(\n\t\t\t\t\tnew OffsetRange(prevResult.seq1Range.start, cur.seq1Range.endExclusive - length),\n\t\t\t\t\tnew OffsetRange(prevResult.seq2Range.start, cur.seq2Range.endExclusive - length),\n\t\t\t\t);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcur = cur.delta(-d);\n\t\t}\n\n\t\tresult.push(cur);\n\t}\n\n\tconst result2: SequenceDiff[] = [];\n\t// Then move them all to the right and join them again if possible\n\tfor (let i = 0; i < result.length - 1; i++) {\n\t\tconst nextResult = result[i + 1];\n\t\tlet cur = result[i];\n\n\t\tif (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n\t\t\tconst length = nextResult.seq1Range.start - cur.seq1Range.endExclusive;\n\t\t\tlet d;\n\t\t\tfor (d = 0; d < length; d++) {\n\t\t\t\tif (\n\t\t\t\t\t!sequence1.isStronglyEqual(cur.seq1Range.start + d, cur.seq1Range.endExclusive + d) ||\n\t\t\t\t\t!sequence2.isStronglyEqual(cur.seq2Range.start + d, cur.seq2Range.endExclusive + d)\n\t\t\t\t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (d === length) {\n\t\t\t\t// Merge previous and current diff, write to result!\n\t\t\t\tresult[i + 1] = new SequenceDiff(\n\t\t\t\t\tnew OffsetRange(cur.seq1Range.start + length, nextResult.seq1Range.endExclusive),\n\t\t\t\t\tnew OffsetRange(cur.seq2Range.start + length, nextResult.seq2Range.endExclusive),\n\t\t\t\t);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (d > 0) {\n\t\t\t\tcur = cur.delta(d);\n\t\t\t}\n\t\t}\n\n\t\tresult2.push(cur);\n\t}\n\n\tif (result.length > 0) {\n\t\tresult2.push(result[result.length - 1]);\n\t}\n\n\treturn result2;\n}\n\n// align character level diffs at whitespace characters\n// import { IBar } from \"foo\";\n// import { I[Arr, I]Bar } from \"foo\";\n// ->\n// import { [IArr, ]IBar } from \"foo\";\n\n// import { ITransaction, observableValue, transaction } from 'vs/base/common/observable';\n// import { ITransaction, observable[FromEvent, observable]Value, transaction } from 'vs/base/common/observable';\n// ->\n// import { ITransaction, [observableFromEvent, ]observableValue, transaction } from 'vs/base/common/observable';\n\n// collectBrackets(level + 1, levelPerBracketType);\n// collectBrackets(level + 1, levelPerBracket[ + 1, levelPerBracket]Type);\n// ->\n// collectBrackets(level + 1, [levelPerBracket + 1, ]levelPerBracketType);\n\nfunction shiftSequenceDiffs(sequence1: ISequence, sequence2: ISequence, sequenceDiffs: SequenceDiff[]): SequenceDiff[] {\n\tif (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {\n\t\treturn sequenceDiffs;\n\t}\n\n\tfor (let i = 0; i < sequenceDiffs.length; i++) {\n\t\tconst prevDiff = (i > 0 ? sequenceDiffs[i - 1] : undefined);\n\t\tconst diff = sequenceDiffs[i];\n\t\tconst nextDiff = (i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1] : undefined);\n\n\t\tconst seq1ValidRange = new OffsetRange(prevDiff ? prevDiff.seq1Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq1Range.start - 1 : sequence1.length);\n\t\tconst seq2ValidRange = new OffsetRange(prevDiff ? prevDiff.seq2Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq2Range.start - 1 : sequence2.length);\n\n\t\tif (diff.seq1Range.isEmpty) {\n\t\t\tsequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange);\n\t\t} else if (diff.seq2Range.isEmpty) {\n\t\t\tsequenceDiffs[i] = shiftDiffToBetterPosition(diff.swap(), sequence2, sequence1, seq2ValidRange, seq1ValidRange).swap();\n\t\t}\n\t}\n\n\treturn sequenceDiffs;\n}\n\nfunction shiftDiffToBetterPosition(diff: SequenceDiff, sequence1: ISequence, sequence2: ISequence, seq1ValidRange: OffsetRange, seq2ValidRange: OffsetRange,) {\n\tconst maxShiftLimit = 100; // To prevent performance issues\n\n\t// don't touch previous or next!\n\tlet deltaBefore = 1;\n\twhile (\n\t\tdiff.seq1Range.start - deltaBefore >= seq1ValidRange.start &&\n\t\tdiff.seq2Range.start - deltaBefore >= seq2ValidRange.start &&\n\t\tsequence2.isStronglyEqual(diff.seq2Range.start - deltaBefore, diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit\n\t) {\n\t\tdeltaBefore++;\n\t}\n\tdeltaBefore--;\n\n\tlet deltaAfter = 0;\n\twhile (\n\t\tdiff.seq1Range.start + deltaAfter < seq1ValidRange.endExclusive &&\n\t\tdiff.seq2Range.endExclusive + deltaAfter < seq2ValidRange.endExclusive &&\n\t\tsequence2.isStronglyEqual(diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit\n\t) {\n\t\tdeltaAfter++;\n\t}\n\n\tif (deltaBefore === 0 && deltaAfter === 0) {\n\t\treturn diff;\n\t}\n\n\t// Visualize `[sequence1.text, diff.seq1Range.start + deltaAfter]`\n\t// and `[sequence2.text, diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter]`\n\n\tlet bestDelta = 0;\n\tlet bestScore = -1;\n\t// find best scored delta\n\tfor (let delta = -deltaBefore; delta <= deltaAfter; delta++) {\n\t\tconst seq2OffsetStart = diff.seq2Range.start + delta;\n\t\tconst seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;\n\t\tconst seq1Offset = diff.seq1Range.start + delta;\n\n\t\tconst score = sequence1.getBoundaryScore!(seq1Offset) + sequence2.getBoundaryScore!(seq2OffsetStart) + sequence2.getBoundaryScore!(seq2OffsetEndExclusive);\n\t\tif (score > bestScore) {\n\t\t\tbestScore = score;\n\t\t\tbestDelta = delta;\n\t\t}\n\t}\n\n\treturn diff.delta(bestDelta);\n}\n\nexport function removeShortMatches(sequence1: ISequence, sequence2: ISequence, sequenceDiffs: SequenceDiff[]): SequenceDiff[] {\n\tconst result: SequenceDiff[] = [];\n\tfor (const s of sequenceDiffs) {\n\t\tconst last = result[result.length - 1];\n\t\tif (!last) {\n\t\t\tresult.push(s);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (s.seq1Range.start - last.seq1Range.endExclusive <= 2 || s.seq2Range.start - last.seq2Range.endExclusive <= 2) {\n\t\t\tresult[result.length - 1] = new SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range));\n\t\t} else {\n\t\t\tresult.push(s);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport function extendDiffsToEntireWordIfAppropriate(sequence1: LinesSliceCharSequence, sequence2: LinesSliceCharSequence, sequenceDiffs: SequenceDiff[]): SequenceDiff[] {\n\tconst equalMappings = SequenceDiff.invert(sequenceDiffs, sequence1.length);\n\n\tconst additional: SequenceDiff[] = [];\n\n\tlet lastPoint = new OffsetPair(0, 0);\n\n\tfunction scanWord(pair: OffsetPair, equalMapping: SequenceDiff) {\n\t\tif (pair.offset1 < lastPoint.offset1 || pair.offset2 < lastPoint.offset2) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst w1 = sequence1.findWordContaining(pair.offset1);\n\t\tconst w2 = sequence2.findWordContaining(pair.offset2);\n\t\tif (!w1 || !w2) {\n\t\t\treturn;\n\t\t}\n\t\tlet w = new SequenceDiff(w1, w2);\n\t\tconst equalPart = w.intersect(equalMapping)!;\n\n\t\tlet equalChars1 = equalPart.seq1Range.length;\n\t\tlet equalChars2 = equalPart.seq2Range.length;\n\n\t\t// The words do not touch previous equals mappings, as we would have processed them already.\n\t\t// But they might touch the next ones.\n\n\t\twhile (equalMappings.length > 0) {\n\t\t\tconst next = equalMappings[0];\n\t\t\tconst intersects = next.seq1Range.intersects(w.seq1Range) || next.seq2Range.intersects(w.seq2Range);\n\t\t\tif (!intersects) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst v1 = sequence1.findWordContaining(next.seq1Range.start);\n\t\t\tconst v2 = sequence2.findWordContaining(next.seq2Range.start);\n\t\t\t// Because there is an intersection, we know that the words are not empty.\n\t\t\tconst v = new SequenceDiff(v1!, v2!);\n\t\t\tconst equalPart = v.intersect(next)!;\n\n\t\t\tequalChars1 += equalPart.seq1Range.length;\n\t\t\tequalChars2 += equalPart.seq2Range.length;\n\n\t\t\tw = w.join(v);\n\n\t\t\tif (w.seq1Range.endExclusive >= next.seq1Range.endExclusive) {\n\t\t\t\t// The word extends beyond the next equal mapping.\n\t\t\t\tequalMappings.shift();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (equalChars1 + equalChars2 < (w.seq1Range.length + w.seq2Range.length) * 2 / 3) {\n\t\t\tadditional.push(w);\n\t\t}\n\n\t\tlastPoint = w.getEndExclusives();\n\t}\n\n\twhile (equalMappings.length > 0) {\n\t\tconst next = equalMappings.shift()!;\n\t\tif (next.seq1Range.isEmpty) {\n\t\t\tcontinue;\n\t\t}\n\t\tscanWord(next.getStarts(), next);\n\t\t// The equal parts are not empty, so -1 gives us a character that is equal in both parts.\n\t\tscanWord(next.getEndExclusives().delta(-1), next);\n\t}\n\n\tconst merged = mergeSequenceDiffs(sequenceDiffs, additional);\n\treturn merged;\n}\n\nfunction mergeSequenceDiffs(sequenceDiffs1: SequenceDiff[], sequenceDiffs2: SequenceDiff[]): SequenceDiff[] {\n\tconst result: SequenceDiff[] = [];\n\n\twhile (sequenceDiffs1.length > 0 || sequenceDiffs2.length > 0) {\n\t\tconst sd1 = sequenceDiffs1[0];\n\t\tconst sd2 = sequenceDiffs2[0];\n\n\t\tlet next: SequenceDiff;\n\t\tif (sd1 && (!sd2 || sd1.seq1Range.start < sd2.seq1Range.start)) {\n\t\t\tnext = sequenceDiffs1.shift()!;\n\t\t} else {\n\t\t\tnext = sequenceDiffs2.shift()!;\n\t\t}\n\n\t\tif (result.length > 0 && result[result.length - 1].seq1Range.endExclusive >= next.seq1Range.start) {\n\t\t\tresult[result.length - 1] = result[result.length - 1].join(next);\n\t\t} else {\n\t\t\tresult.push(next);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport function removeVeryShortMatchingLinesBetweenDiffs(sequence1: LineSequence, _sequence2: LineSequence, sequenceDiffs: SequenceDiff[]): SequenceDiff[] {\n\tlet diffs = sequenceDiffs;\n\tif (diffs.length === 0) {\n\t\treturn diffs;\n\t}\n\n\tlet counter = 0;\n\tlet shouldRepeat: boolean;\n\tdo {\n\t\tshouldRepeat = false;\n\n\t\tconst result: SequenceDiff[] = [\n\t\t\tdiffs[0]\n\t\t];\n\n\t\tfor (let i = 1; i < diffs.length; i++) {\n\t\t\tconst cur = diffs[i];\n\t\t\tconst lastResult = result[result.length - 1];\n\n\t\t\tfunction shouldJoinDiffs(before: SequenceDiff, after: SequenceDiff): boolean {\n\t\t\t\tconst unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n\n\t\t\t\tconst unchangedText = sequence1.getText(unchangedRange);\n\t\t\t\tconst unchangedTextWithoutWs = unchangedText.replace(/\\s/g, '');\n\t\t\t\tif (unchangedTextWithoutWs.length <= 4\n\t\t\t\t\t&& (before.seq1Range.length + before.seq2Range.length > 5 || after.seq1Range.length + after.seq2Range.length > 5)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst shouldJoin = shouldJoinDiffs(lastResult, cur);\n\t\t\tif (shouldJoin) {\n\t\t\t\tshouldRepeat = true;\n\t\t\t\tresult[result.length - 1] = result[result.length - 1].join(cur);\n\t\t\t} else {\n\t\t\t\tresult.push(cur);\n\t\t\t}\n\t\t}\n\n\t\tdiffs = result;\n\t} while (counter++ < 10 && shouldRepeat);\n\n\treturn diffs;\n}\n\nexport function removeVeryShortMatchingTextBetweenLongDiffs(sequence1: LinesSliceCharSequence, sequence2: LinesSliceCharSequence, sequenceDiffs: SequenceDiff[]): SequenceDiff[] {\n\tlet diffs = sequenceDiffs;\n\tif (diffs.length === 0) {\n\t\treturn diffs;\n\t}\n\n\tlet counter = 0;\n\tlet shouldRepeat: boolean;\n\tdo {\n\t\tshouldRepeat = false;\n\n\t\tconst result: SequenceDiff[] = [\n\t\t\tdiffs[0]\n\t\t];\n\n\t\tfor (let i = 1; i < diffs.length; i++) {\n\t\t\tconst cur = diffs[i];\n\t\t\tconst lastResult = result[result.length - 1];\n\n\t\t\tfunction shouldJoinDiffs(before: SequenceDiff, after: SequenceDiff): boolean {\n\t\t\t\tconst unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n\n\t\t\t\tconst unchangedLineCount = sequence1.countLinesIn(unchangedRange);\n\t\t\t\tif (unchangedLineCount > 5 || unchangedRange.length > 500) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tconst unchangedText = sequence1.getText(unchangedRange).trim();\n\t\t\t\tif (unchangedText.length > 20 || unchangedText.split(/\\r\\n|\\r|\\n/).length > 1) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tconst beforeLineCount1 = sequence1.countLinesIn(before.seq1Range);\n\t\t\t\tconst beforeSeq1Length = before.seq1Range.length;\n\t\t\t\tconst beforeLineCount2 = sequence2.countLinesIn(before.seq2Range);\n\t\t\t\tconst beforeSeq2Length = before.seq2Range.length;\n\n\t\t\t\tconst afterLineCount1 = sequence1.countLinesIn(after.seq1Range);\n\t\t\t\tconst afterSeq1Length = after.seq1Range.length;\n\t\t\t\tconst afterLineCount2 = sequence2.countLinesIn(after.seq2Range);\n\t\t\t\tconst afterSeq2Length = after.seq2Range.length;\n\n\t\t\t\t// TODO: Maybe a neural net can be used to derive the result from these numbers\n\n\t\t\t\tconst max = 2 * 40 + 50;\n\t\t\t\tfunction cap(v: number): number {\n\t\t\t\t\treturn Math.min(v, max);\n\t\t\t\t}\n\n\t\t\t\tif (Math.pow(Math.pow(cap(beforeLineCount1 * 40 + beforeSeq1Length), 1.5) + Math.pow(cap(beforeLineCount2 * 40 + beforeSeq2Length), 1.5), 1.5)\n\t\t\t\t\t+ Math.pow(Math.pow(cap(afterLineCount1 * 40 + afterSeq1Length), 1.5) + Math.pow(cap(afterLineCount2 * 40 + afterSeq2Length), 1.5), 1.5) > ((max ** 1.5) ** 1.5) * 1.3) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst shouldJoin = shouldJoinDiffs(lastResult, cur);\n\t\t\tif (shouldJoin) {\n\t\t\t\tshouldRepeat = true;\n\t\t\t\tresult[result.length - 1] = result[result.length - 1].join(cur);\n\t\t\t} else {\n\t\t\t\tresult.push(cur);\n\t\t\t}\n\t\t}\n\n\t\tdiffs = result;\n\t} while (counter++ < 10 && shouldRepeat);\n\n\tconst newDiffs: SequenceDiff[] = [];\n\n\t// Remove short suffixes/prefixes\n\tforEachWithNeighbors(diffs, (prev, cur, next) => {\n\t\tlet newDiff = cur;\n\n\t\tfunction shouldMarkAsChanged(text: string): boolean {\n\t\t\treturn text.length > 0 && text.trim().length <= 3 && cur.seq1Range.length + cur.seq2Range.length > 100;\n\t\t}\n\n\t\tconst fullRange1 = sequence1.extendToFullLines(cur.seq1Range);\n\t\tconst prefix = sequence1.getText(new OffsetRange(fullRange1.start, cur.seq1Range.start));\n\t\tif (shouldMarkAsChanged(prefix)) {\n\t\t\tnewDiff = newDiff.deltaStart(-prefix.length);\n\t\t}\n\t\tconst suffix = sequence1.getText(new OffsetRange(cur.seq1Range.endExclusive, fullRange1.endExclusive));\n\t\tif (shouldMarkAsChanged(suffix)) {\n\t\t\tnewDiff = newDiff.deltaEnd(suffix.length);\n\t\t}\n\n\t\tconst availableSpace = SequenceDiff.fromOffsetPairs(\n\t\t\tprev ? prev.getEndExclusives() : OffsetPair.zero,\n\t\t\tnext ? next.getStarts() : OffsetPair.max,\n\t\t);\n\t\tconst result = newDiff.intersect(availableSpace)!;\n\t\tif (newDiffs.length > 0 && result.getStarts().equals(newDiffs[newDiffs.length - 1].getEndExclusives())) {\n\t\t\tnewDiffs[newDiffs.length - 1] = newDiffs[newDiffs.length - 1].join(result);\n\t\t} else {\n\t\t\tnewDiffs.push(result);\n\t\t}\n\t});\n\n\treturn newDiffs;\n}\n"],
  "mappings": "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",
  "names": ["equalPart", "shouldJoinDiffs"]
}
