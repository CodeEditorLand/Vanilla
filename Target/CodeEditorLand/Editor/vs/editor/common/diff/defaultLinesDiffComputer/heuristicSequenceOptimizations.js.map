{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { forEachWithNeighbors } from \"../../../../base/common/arrays.js\";\nimport { OffsetRange } from \"../../core/offsetRange.js\";\nimport {\n\ttype ISequence,\n\tOffsetPair,\n\tSequenceDiff,\n} from \"./algorithms/diffAlgorithm.js\";\nimport type { LineSequence } from \"./lineSequence.js\";\nimport type { LinesSliceCharSequence } from \"./linesSliceCharSequence.js\";\n\nexport function optimizeSequenceDiffs(\n\tsequence1: ISequence,\n\tsequence2: ISequence,\n\tsequenceDiffs: SequenceDiff[],\n): SequenceDiff[] {\n\tlet result = sequenceDiffs;\n\tresult = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n\t// Sometimes, calling this function twice improves the result.\n\t// Uncomment the second invocation and run the tests to see the difference.\n\tresult = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n\tresult = shiftSequenceDiffs(sequence1, sequence2, result);\n\treturn result;\n}\n\n/**\n * This function fixes issues like this:\n * ```\n * import { Baz, Bar } from \"foo\";\n * ```\n * <->\n * ```\n * import { Baz, Bar, Foo } from \"foo\";\n * ```\n * Computed diff: [ {Add \",\" after Bar}, {Add \"Foo \" after space} }\n * Improved diff: [{Add \", Foo\" after Bar}]\n */\nfunction joinSequenceDiffsByShifting(\n\tsequence1: ISequence,\n\tsequence2: ISequence,\n\tsequenceDiffs: SequenceDiff[],\n): SequenceDiff[] {\n\tif (sequenceDiffs.length === 0) {\n\t\treturn sequenceDiffs;\n\t}\n\n\tconst result: SequenceDiff[] = [];\n\tresult.push(sequenceDiffs[0]);\n\n\t// First move them all to the left as much as possible and join them if possible\n\tfor (let i = 1; i < sequenceDiffs.length; i++) {\n\t\tconst prevResult = result[result.length - 1];\n\t\tlet cur = sequenceDiffs[i];\n\n\t\tif (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n\t\t\tconst length =\n\t\t\t\tcur.seq1Range.start - prevResult.seq1Range.endExclusive;\n\t\t\tlet d;\n\t\t\tfor (d = 1; d <= length; d++) {\n\t\t\t\tif (\n\t\t\t\t\tsequence1.getElement(cur.seq1Range.start - d) !==\n\t\t\t\t\t\tsequence1.getElement(cur.seq1Range.endExclusive - d) ||\n\t\t\t\t\tsequence2.getElement(cur.seq2Range.start - d) !==\n\t\t\t\t\t\tsequence2.getElement(cur.seq2Range.endExclusive - d)\n\t\t\t\t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\td--;\n\n\t\t\tif (d === length) {\n\t\t\t\t// Merge previous and current diff\n\t\t\t\tresult[result.length - 1] = new SequenceDiff(\n\t\t\t\t\tnew OffsetRange(\n\t\t\t\t\t\tprevResult.seq1Range.start,\n\t\t\t\t\t\tcur.seq1Range.endExclusive - length,\n\t\t\t\t\t),\n\t\t\t\t\tnew OffsetRange(\n\t\t\t\t\t\tprevResult.seq2Range.start,\n\t\t\t\t\t\tcur.seq2Range.endExclusive - length,\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcur = cur.delta(-d);\n\t\t}\n\n\t\tresult.push(cur);\n\t}\n\n\tconst result2: SequenceDiff[] = [];\n\t// Then move them all to the right and join them again if possible\n\tfor (let i = 0; i < result.length - 1; i++) {\n\t\tconst nextResult = result[i + 1];\n\t\tlet cur = result[i];\n\n\t\tif (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n\t\t\tconst length =\n\t\t\t\tnextResult.seq1Range.start - cur.seq1Range.endExclusive;\n\t\t\tlet d;\n\t\t\tfor (d = 0; d < length; d++) {\n\t\t\t\tif (\n\t\t\t\t\t!sequence1.isStronglyEqual(\n\t\t\t\t\t\tcur.seq1Range.start + d,\n\t\t\t\t\t\tcur.seq1Range.endExclusive + d,\n\t\t\t\t\t) ||\n\t\t\t\t\t!sequence2.isStronglyEqual(\n\t\t\t\t\t\tcur.seq2Range.start + d,\n\t\t\t\t\t\tcur.seq2Range.endExclusive + d,\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (d === length) {\n\t\t\t\t// Merge previous and current diff, write to result!\n\t\t\t\tresult[i + 1] = new SequenceDiff(\n\t\t\t\t\tnew OffsetRange(\n\t\t\t\t\t\tcur.seq1Range.start + length,\n\t\t\t\t\t\tnextResult.seq1Range.endExclusive,\n\t\t\t\t\t),\n\t\t\t\t\tnew OffsetRange(\n\t\t\t\t\t\tcur.seq2Range.start + length,\n\t\t\t\t\t\tnextResult.seq2Range.endExclusive,\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (d > 0) {\n\t\t\t\tcur = cur.delta(d);\n\t\t\t}\n\t\t}\n\n\t\tresult2.push(cur);\n\t}\n\n\tif (result.length > 0) {\n\t\tresult2.push(result[result.length - 1]);\n\t}\n\n\treturn result2;\n}\n\n// align character level diffs at whitespace characters\n// import { IBar } from \"foo\";\n// import { I[Arr, I]Bar } from \"foo\";\n// ->\n// import { [IArr, ]IBar } from \"foo\";\n\n// import { ITransaction, observableValue, transaction } from 'vs/base/common/observable';\n// import { ITransaction, observable[FromEvent, observable]Value, transaction } from 'vs/base/common/observable';\n// ->\n// import { ITransaction, [observableFromEvent, ]observableValue, transaction } from 'vs/base/common/observable';\n\n// collectBrackets(level + 1, levelPerBracketType);\n// collectBrackets(level + 1, levelPerBracket[ + 1, levelPerBracket]Type);\n// ->\n// collectBrackets(level + 1, [levelPerBracket + 1, ]levelPerBracketType);\n\nfunction shiftSequenceDiffs(\n\tsequence1: ISequence,\n\tsequence2: ISequence,\n\tsequenceDiffs: SequenceDiff[],\n): SequenceDiff[] {\n\tif (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {\n\t\treturn sequenceDiffs;\n\t}\n\n\tfor (let i = 0; i < sequenceDiffs.length; i++) {\n\t\tconst prevDiff = i > 0 ? sequenceDiffs[i - 1] : undefined;\n\t\tconst diff = sequenceDiffs[i];\n\t\tconst nextDiff =\n\t\t\ti + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1] : undefined;\n\n\t\tconst seq1ValidRange = new OffsetRange(\n\t\t\tprevDiff ? prevDiff.seq1Range.endExclusive + 1 : 0,\n\t\t\tnextDiff ? nextDiff.seq1Range.start - 1 : sequence1.length,\n\t\t);\n\t\tconst seq2ValidRange = new OffsetRange(\n\t\t\tprevDiff ? prevDiff.seq2Range.endExclusive + 1 : 0,\n\t\t\tnextDiff ? nextDiff.seq2Range.start - 1 : sequence2.length,\n\t\t);\n\n\t\tif (diff.seq1Range.isEmpty) {\n\t\t\tsequenceDiffs[i] = shiftDiffToBetterPosition(\n\t\t\t\tdiff,\n\t\t\t\tsequence1,\n\t\t\t\tsequence2,\n\t\t\t\tseq1ValidRange,\n\t\t\t\tseq2ValidRange,\n\t\t\t);\n\t\t} else if (diff.seq2Range.isEmpty) {\n\t\t\tsequenceDiffs[i] = shiftDiffToBetterPosition(\n\t\t\t\tdiff.swap(),\n\t\t\t\tsequence2,\n\t\t\t\tsequence1,\n\t\t\t\tseq2ValidRange,\n\t\t\t\tseq1ValidRange,\n\t\t\t).swap();\n\t\t}\n\t}\n\n\treturn sequenceDiffs;\n}\n\nfunction shiftDiffToBetterPosition(\n\tdiff: SequenceDiff,\n\tsequence1: ISequence,\n\tsequence2: ISequence,\n\tseq1ValidRange: OffsetRange,\n\tseq2ValidRange: OffsetRange,\n) {\n\tconst maxShiftLimit = 100; // To prevent performance issues\n\n\t// don't touch previous or next!\n\tlet deltaBefore = 1;\n\twhile (\n\t\tdiff.seq1Range.start - deltaBefore >= seq1ValidRange.start &&\n\t\tdiff.seq2Range.start - deltaBefore >= seq2ValidRange.start &&\n\t\tsequence2.isStronglyEqual(\n\t\t\tdiff.seq2Range.start - deltaBefore,\n\t\t\tdiff.seq2Range.endExclusive - deltaBefore,\n\t\t) &&\n\t\tdeltaBefore < maxShiftLimit\n\t) {\n\t\tdeltaBefore++;\n\t}\n\tdeltaBefore--;\n\n\tlet deltaAfter = 0;\n\twhile (\n\t\tdiff.seq1Range.start + deltaAfter < seq1ValidRange.endExclusive &&\n\t\tdiff.seq2Range.endExclusive + deltaAfter <\n\t\t\tseq2ValidRange.endExclusive &&\n\t\tsequence2.isStronglyEqual(\n\t\t\tdiff.seq2Range.start + deltaAfter,\n\t\t\tdiff.seq2Range.endExclusive + deltaAfter,\n\t\t) &&\n\t\tdeltaAfter < maxShiftLimit\n\t) {\n\t\tdeltaAfter++;\n\t}\n\n\tif (deltaBefore === 0 && deltaAfter === 0) {\n\t\treturn diff;\n\t}\n\n\t// Visualize `[sequence1.text, diff.seq1Range.start + deltaAfter]`\n\t// and `[sequence2.text, diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter]`\n\n\tlet bestDelta = 0;\n\tlet bestScore = -1;\n\t// find best scored delta\n\tfor (let delta = -deltaBefore; delta <= deltaAfter; delta++) {\n\t\tconst seq2OffsetStart = diff.seq2Range.start + delta;\n\t\tconst seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;\n\t\tconst seq1Offset = diff.seq1Range.start + delta;\n\n\t\tconst score =\n\t\t\tsequence1.getBoundaryScore!(seq1Offset) +\n\t\t\tsequence2.getBoundaryScore!(seq2OffsetStart) +\n\t\t\tsequence2.getBoundaryScore!(seq2OffsetEndExclusive);\n\t\tif (score > bestScore) {\n\t\t\tbestScore = score;\n\t\t\tbestDelta = delta;\n\t\t}\n\t}\n\n\treturn diff.delta(bestDelta);\n}\n\nexport function removeShortMatches(\n\tsequence1: ISequence,\n\tsequence2: ISequence,\n\tsequenceDiffs: SequenceDiff[],\n): SequenceDiff[] {\n\tconst result: SequenceDiff[] = [];\n\tfor (const s of sequenceDiffs) {\n\t\tconst last = result[result.length - 1];\n\t\tif (!last) {\n\t\t\tresult.push(s);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (\n\t\t\ts.seq1Range.start - last.seq1Range.endExclusive <= 2 ||\n\t\t\ts.seq2Range.start - last.seq2Range.endExclusive <= 2\n\t\t) {\n\t\t\tresult[result.length - 1] = new SequenceDiff(\n\t\t\t\tlast.seq1Range.join(s.seq1Range),\n\t\t\t\tlast.seq2Range.join(s.seq2Range),\n\t\t\t);\n\t\t} else {\n\t\t\tresult.push(s);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport function extendDiffsToEntireWordIfAppropriate(\n\tsequence1: LinesSliceCharSequence,\n\tsequence2: LinesSliceCharSequence,\n\tsequenceDiffs: SequenceDiff[],\n): SequenceDiff[] {\n\tconst equalMappings = SequenceDiff.invert(sequenceDiffs, sequence1.length);\n\n\tconst additional: SequenceDiff[] = [];\n\n\tlet lastPoint = new OffsetPair(0, 0);\n\n\tfunction scanWord(pair: OffsetPair, equalMapping: SequenceDiff) {\n\t\tif (\n\t\t\tpair.offset1 < lastPoint.offset1 ||\n\t\t\tpair.offset2 < lastPoint.offset2\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst w1 = sequence1.findWordContaining(pair.offset1);\n\t\tconst w2 = sequence2.findWordContaining(pair.offset2);\n\t\tif (!w1 || !w2) {\n\t\t\treturn;\n\t\t}\n\t\tlet w = new SequenceDiff(w1, w2);\n\t\tconst equalPart = w.intersect(equalMapping)!;\n\n\t\tlet equalChars1 = equalPart.seq1Range.length;\n\t\tlet equalChars2 = equalPart.seq2Range.length;\n\n\t\t// The words do not touch previous equals mappings, as we would have processed them already.\n\t\t// But they might touch the next ones.\n\n\t\twhile (equalMappings.length > 0) {\n\t\t\tconst next = equalMappings[0];\n\t\t\tconst intersects =\n\t\t\t\tnext.seq1Range.intersects(w.seq1Range) ||\n\t\t\t\tnext.seq2Range.intersects(w.seq2Range);\n\t\t\tif (!intersects) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst v1 = sequence1.findWordContaining(next.seq1Range.start);\n\t\t\tconst v2 = sequence2.findWordContaining(next.seq2Range.start);\n\t\t\t// Because there is an intersection, we know that the words are not empty.\n\t\t\tconst v = new SequenceDiff(v1!, v2!);\n\t\t\tconst equalPart = v.intersect(next)!;\n\n\t\t\tequalChars1 += equalPart.seq1Range.length;\n\t\t\tequalChars2 += equalPart.seq2Range.length;\n\n\t\t\tw = w.join(v);\n\n\t\t\tif (w.seq1Range.endExclusive >= next.seq1Range.endExclusive) {\n\t\t\t\t// The word extends beyond the next equal mapping.\n\t\t\t\tequalMappings.shift();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (\n\t\t\tequalChars1 + equalChars2 <\n\t\t\t((w.seq1Range.length + w.seq2Range.length) * 2) / 3\n\t\t) {\n\t\t\tadditional.push(w);\n\t\t}\n\n\t\tlastPoint = w.getEndExclusives();\n\t}\n\n\twhile (equalMappings.length > 0) {\n\t\tconst next = equalMappings.shift()!;\n\t\tif (next.seq1Range.isEmpty) {\n\t\t\tcontinue;\n\t\t}\n\t\tscanWord(next.getStarts(), next);\n\t\t// The equal parts are not empty, so -1 gives us a character that is equal in both parts.\n\t\tscanWord(next.getEndExclusives().delta(-1), next);\n\t}\n\n\tconst merged = mergeSequenceDiffs(sequenceDiffs, additional);\n\treturn merged;\n}\n\nfunction mergeSequenceDiffs(\n\tsequenceDiffs1: SequenceDiff[],\n\tsequenceDiffs2: SequenceDiff[],\n): SequenceDiff[] {\n\tconst result: SequenceDiff[] = [];\n\n\twhile (sequenceDiffs1.length > 0 || sequenceDiffs2.length > 0) {\n\t\tconst sd1 = sequenceDiffs1[0];\n\t\tconst sd2 = sequenceDiffs2[0];\n\n\t\tlet next: SequenceDiff;\n\t\tif (sd1 && (!sd2 || sd1.seq1Range.start < sd2.seq1Range.start)) {\n\t\t\tnext = sequenceDiffs1.shift()!;\n\t\t} else {\n\t\t\tnext = sequenceDiffs2.shift()!;\n\t\t}\n\n\t\tif (\n\t\t\tresult.length > 0 &&\n\t\t\tresult[result.length - 1].seq1Range.endExclusive >=\n\t\t\t\tnext.seq1Range.start\n\t\t) {\n\t\t\tresult[result.length - 1] = result[result.length - 1].join(next);\n\t\t} else {\n\t\t\tresult.push(next);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport function removeVeryShortMatchingLinesBetweenDiffs(\n\tsequence1: LineSequence,\n\t_sequence2: LineSequence,\n\tsequenceDiffs: SequenceDiff[],\n): SequenceDiff[] {\n\tlet diffs = sequenceDiffs;\n\tif (diffs.length === 0) {\n\t\treturn diffs;\n\t}\n\n\tlet counter = 0;\n\tlet shouldRepeat: boolean;\n\tdo {\n\t\tshouldRepeat = false;\n\n\t\tconst result: SequenceDiff[] = [diffs[0]];\n\n\t\tfor (let i = 1; i < diffs.length; i++) {\n\t\t\tconst cur = diffs[i];\n\t\t\tconst lastResult = result[result.length - 1];\n\n\t\t\tfunction shouldJoinDiffs(\n\t\t\t\tbefore: SequenceDiff,\n\t\t\t\tafter: SequenceDiff,\n\t\t\t): boolean {\n\t\t\t\tconst unchangedRange = new OffsetRange(\n\t\t\t\t\tlastResult.seq1Range.endExclusive,\n\t\t\t\t\tcur.seq1Range.start,\n\t\t\t\t);\n\n\t\t\t\tconst unchangedText = sequence1.getText(unchangedRange);\n\t\t\t\tconst unchangedTextWithoutWs = unchangedText.replace(/\\s/g, \"\");\n\t\t\t\tif (\n\t\t\t\t\tunchangedTextWithoutWs.length <= 4 &&\n\t\t\t\t\t(before.seq1Range.length + before.seq2Range.length > 5 ||\n\t\t\t\t\t\tafter.seq1Range.length + after.seq2Range.length > 5)\n\t\t\t\t) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst shouldJoin = shouldJoinDiffs(lastResult, cur);\n\t\t\tif (shouldJoin) {\n\t\t\t\tshouldRepeat = true;\n\t\t\t\tresult[result.length - 1] = result[result.length - 1].join(cur);\n\t\t\t} else {\n\t\t\t\tresult.push(cur);\n\t\t\t}\n\t\t}\n\n\t\tdiffs = result;\n\t} while (counter++ < 10 && shouldRepeat);\n\n\treturn diffs;\n}\n\nexport function removeVeryShortMatchingTextBetweenLongDiffs(\n\tsequence1: LinesSliceCharSequence,\n\tsequence2: LinesSliceCharSequence,\n\tsequenceDiffs: SequenceDiff[],\n): SequenceDiff[] {\n\tlet diffs = sequenceDiffs;\n\tif (diffs.length === 0) {\n\t\treturn diffs;\n\t}\n\n\tlet counter = 0;\n\tlet shouldRepeat: boolean;\n\tdo {\n\t\tshouldRepeat = false;\n\n\t\tconst result: SequenceDiff[] = [diffs[0]];\n\n\t\tfor (let i = 1; i < diffs.length; i++) {\n\t\t\tconst cur = diffs[i];\n\t\t\tconst lastResult = result[result.length - 1];\n\n\t\t\tfunction shouldJoinDiffs(\n\t\t\t\tbefore: SequenceDiff,\n\t\t\t\tafter: SequenceDiff,\n\t\t\t): boolean {\n\t\t\t\tconst unchangedRange = new OffsetRange(\n\t\t\t\t\tlastResult.seq1Range.endExclusive,\n\t\t\t\t\tcur.seq1Range.start,\n\t\t\t\t);\n\n\t\t\t\tconst unchangedLineCount =\n\t\t\t\t\tsequence1.countLinesIn(unchangedRange);\n\t\t\t\tif (unchangedLineCount > 5 || unchangedRange.length > 500) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tconst unchangedText = sequence1.getText(unchangedRange).trim();\n\t\t\t\tif (\n\t\t\t\t\tunchangedText.length > 20 ||\n\t\t\t\t\tunchangedText.split(/\\r\\n|\\r|\\n/).length > 1\n\t\t\t\t) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tconst beforeLineCount1 = sequence1.countLinesIn(\n\t\t\t\t\tbefore.seq1Range,\n\t\t\t\t);\n\t\t\t\tconst beforeSeq1Length = before.seq1Range.length;\n\t\t\t\tconst beforeLineCount2 = sequence2.countLinesIn(\n\t\t\t\t\tbefore.seq2Range,\n\t\t\t\t);\n\t\t\t\tconst beforeSeq2Length = before.seq2Range.length;\n\n\t\t\t\tconst afterLineCount1 = sequence1.countLinesIn(after.seq1Range);\n\t\t\t\tconst afterSeq1Length = after.seq1Range.length;\n\t\t\t\tconst afterLineCount2 = sequence2.countLinesIn(after.seq2Range);\n\t\t\t\tconst afterSeq2Length = after.seq2Range.length;\n\n\t\t\t\t// TODO: Maybe a neural net can be used to derive the result from these numbers\n\n\t\t\t\tconst max = 2 * 40 + 50;\n\t\t\t\tfunction cap(v: number): number {\n\t\t\t\t\treturn Math.min(v, max);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tMath.pow(\n\t\t\t\t\t\tMath.pow(\n\t\t\t\t\t\t\tcap(beforeLineCount1 * 40 + beforeSeq1Length),\n\t\t\t\t\t\t\t1.5,\n\t\t\t\t\t\t) +\n\t\t\t\t\t\t\tMath.pow(\n\t\t\t\t\t\t\t\tcap(beforeLineCount2 * 40 + beforeSeq2Length),\n\t\t\t\t\t\t\t\t1.5,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t1.5,\n\t\t\t\t\t) +\n\t\t\t\t\t\tMath.pow(\n\t\t\t\t\t\t\tMath.pow(\n\t\t\t\t\t\t\t\tcap(afterLineCount1 * 40 + afterSeq1Length),\n\t\t\t\t\t\t\t\t1.5,\n\t\t\t\t\t\t\t) +\n\t\t\t\t\t\t\t\tMath.pow(\n\t\t\t\t\t\t\t\t\tcap(afterLineCount2 * 40 + afterSeq2Length),\n\t\t\t\t\t\t\t\t\t1.5,\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t1.5,\n\t\t\t\t\t\t) >\n\t\t\t\t\t(max ** 1.5) ** 1.5 * 1.3\n\t\t\t\t) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst shouldJoin = shouldJoinDiffs(lastResult, cur);\n\t\t\tif (shouldJoin) {\n\t\t\t\tshouldRepeat = true;\n\t\t\t\tresult[result.length - 1] = result[result.length - 1].join(cur);\n\t\t\t} else {\n\t\t\t\tresult.push(cur);\n\t\t\t}\n\t\t}\n\n\t\tdiffs = result;\n\t} while (counter++ < 10 && shouldRepeat);\n\n\tconst newDiffs: SequenceDiff[] = [];\n\n\t// Remove short suffixes/prefixes\n\tforEachWithNeighbors(diffs, (prev, cur, next) => {\n\t\tlet newDiff = cur;\n\n\t\tfunction shouldMarkAsChanged(text: string): boolean {\n\t\t\treturn (\n\t\t\t\ttext.length > 0 &&\n\t\t\t\ttext.trim().length <= 3 &&\n\t\t\t\tcur.seq1Range.length + cur.seq2Range.length > 100\n\t\t\t);\n\t\t}\n\n\t\tconst fullRange1 = sequence1.extendToFullLines(cur.seq1Range);\n\t\tconst prefix = sequence1.getText(\n\t\t\tnew OffsetRange(fullRange1.start, cur.seq1Range.start),\n\t\t);\n\t\tif (shouldMarkAsChanged(prefix)) {\n\t\t\tnewDiff = newDiff.deltaStart(-prefix.length);\n\t\t}\n\t\tconst suffix = sequence1.getText(\n\t\t\tnew OffsetRange(\n\t\t\t\tcur.seq1Range.endExclusive,\n\t\t\t\tfullRange1.endExclusive,\n\t\t\t),\n\t\t);\n\t\tif (shouldMarkAsChanged(suffix)) {\n\t\t\tnewDiff = newDiff.deltaEnd(suffix.length);\n\t\t}\n\n\t\tconst availableSpace = SequenceDiff.fromOffsetPairs(\n\t\t\tprev ? prev.getEndExclusives() : OffsetPair.zero,\n\t\t\tnext ? next.getStarts() : OffsetPair.max,\n\t\t);\n\t\tconst result = newDiff.intersect(availableSpace)!;\n\t\tif (\n\t\t\tnewDiffs.length > 0 &&\n\t\t\tresult\n\t\t\t\t.getStarts()\n\t\t\t\t.equals(newDiffs[newDiffs.length - 1].getEndExclusives())\n\t\t) {\n\t\t\tnewDiffs[newDiffs.length - 1] =\n\t\t\t\tnewDiffs[newDiffs.length - 1].join(result);\n\t\t} else {\n\t\t\tnewDiffs.push(result);\n\t\t}\n\t});\n\n\treturn newDiffs;\n}\n"],
  "mappings": "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",
  "names": ["equalPart", "shouldJoinDiffs"]
}
