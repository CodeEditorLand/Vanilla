{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/tokenizationTextModelPart.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { OffsetEdit } from \"./core/offsetEdit.js\";\nimport type { OffsetRange } from \"./core/offsetRange.js\";\nimport type { Range } from \"./core/range.js\";\nimport type { StandardTokenType } from \"./encodedTokenAttributes.js\";\nimport type { LineTokens } from \"./tokens/lineTokens.js\";\nimport type { SparseMultilineTokens } from \"./tokens/sparseMultilineTokens.js\";\n\n/**\n * Provides tokenization related functionality of the text model.\n */\nexport interface ITokenizationTextModelPart {\n\treadonly hasTokens: boolean;\n\n\t/**\n\t * Replaces all semantic tokens with the provided `tokens`.\n\t * @internal\n\t */\n\tsetSemanticTokens(\n\t\ttokens: SparseMultilineTokens[] | null,\n\t\tisComplete: boolean,\n\t): void;\n\n\t/**\n\t * Merges the provided semantic tokens into existing semantic tokens.\n\t * @internal\n\t */\n\tsetPartialSemanticTokens(\n\t\trange: Range,\n\t\ttokens: SparseMultilineTokens[] | null,\n\t): void;\n\n\t/**\n\t * @internal\n\t */\n\thasCompleteSemanticTokens(): boolean;\n\n\t/**\n\t * @internal\n\t */\n\thasSomeSemanticTokens(): boolean;\n\n\t/**\n\t * Flush all tokenization state.\n\t * @internal\n\t */\n\tresetTokenization(): void;\n\n\t/**\n\t * Force tokenization information for `lineNumber` to be accurate.\n\t * @internal\n\t */\n\tforceTokenization(lineNumber: number): void;\n\n\t/**\n\t * If it is cheap, force tokenization information for `lineNumber` to be accurate.\n\t * This is based on a heuristic.\n\t * @internal\n\t */\n\ttokenizeIfCheap(lineNumber: number): void;\n\n\t/**\n\t * Check if tokenization information is accurate for `lineNumber`.\n\t * @internal\n\t */\n\thasAccurateTokensForLine(lineNumber: number): boolean;\n\n\t/**\n\t * Check if calling `forceTokenization` for this `lineNumber` will be cheap (time-wise).\n\t * This is based on a heuristic.\n\t * @internal\n\t */\n\tisCheapToTokenize(lineNumber: number): boolean;\n\n\t/**\n\t * Get the tokens for the line `lineNumber`.\n\t * The tokens might be inaccurate. Use `forceTokenization` to ensure accurate tokens.\n\t * @internal\n\t */\n\tgetLineTokens(lineNumber: number): LineTokens;\n\n\t/**\n\t * Returns the standard token type for a character if the character were to be inserted at\n\t * the given position. If the result cannot be accurate, it returns null.\n\t * @internal\n\t */\n\tgetTokenTypeIfInsertingCharacter(\n\t\tlineNumber: number,\n\t\tcolumn: number,\n\t\tcharacter: string,\n\t): StandardTokenType;\n\n\t/**\n\t * @internal\n\t */\n\ttokenizeLineWithEdit(\n\t\tlineNumber: number,\n\t\tedit: LineEditWithAdditionalLines,\n\t): ITokenizeLineWithEditResult;\n\n\tgetLanguageId(): string;\n\tgetLanguageIdAtPosition(lineNumber: number, column: number): string;\n\n\tsetLanguageId(languageId: string, source?: string): void;\n\n\treadonly backgroundTokenizationState: BackgroundTokenizationState;\n}\n\nexport class LineEditWithAdditionalLines {\n\tpublic static replace(\n\t\trange: OffsetRange,\n\t\ttext: string,\n\t): LineEditWithAdditionalLines {\n\t\treturn new LineEditWithAdditionalLines(\n\t\t\tOffsetEdit.replace(range, text),\n\t\t\tnull,\n\t\t);\n\t}\n\n\tconstructor(\n\t\t/**\n\t\t * The edit for the main line.\n\t\t */\n\t\treadonly lineEdit: OffsetEdit,\n\n\t\t/**\n\t\t * Full lines appended after the main line.\n\t\t */\n\t\treadonly additionalLines: string[] | null,\n\t) {}\n}\n\nexport interface ITokenizeLineWithEditResult {\n\treadonly mainLineTokens: LineTokens | null;\n\treadonly additionalLines: LineTokens[] | null;\n}\n\nexport enum BackgroundTokenizationState {\n\tInProgress = 1,\n\tCompleted = 2,\n}\n"],
  "mappings": ";;AAKA,SAAS,kBAAkB;AA2GpB,MAAM,4BAA4B;AAAA,EAWxC,YAIU,UAKA,iBACR;AANQ;AAKA;AAAA,EACP;AAAA,EArIJ,OAgHyC;AAAA;AAAA;AAAA,EACxC,OAAc,QACb,OACA,MAC8B;AAC9B,WAAO,IAAI;AAAA,MACV,WAAW,QAAQ,OAAO,IAAI;AAAA,MAC9B;AAAA,IACD;AAAA,EACD;AAaD;AAOO,IAAK,8BAAL,kBAAKA,iCAAL;AACN,EAAAA,0DAAA,gBAAa,KAAb;AACA,EAAAA,0DAAA,eAAY,KAAZ;AAFW,SAAAA;AAAA,GAAA;",
  "names": ["BackgroundTokenizationState"]
}
