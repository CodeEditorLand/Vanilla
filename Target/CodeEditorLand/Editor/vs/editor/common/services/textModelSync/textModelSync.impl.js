import{IntervalTimer as p}from"../../../../base/common/async.js";import{Disposable as g,DisposableStore as b,dispose as l,toDisposable as _}from"../../../../base/common/lifecycle.js";import{URI as M}from"../../../../base/common/uri.js";import{Position as d}from"../../core/position.js";import{Range as I}from"../../core/range.js";import{ensureValidWordDefinition as f,getWordAtText as x}from"../../core/wordHelper.js";import{MirrorTextModel as C}from"../../model/mirrorTextModel.js";const u=60*1e3,c="workerTextModelSync";class m extends g{static create(e,n){return new m(e.getChannel(c),n)}_proxy;_modelService;_syncedModels=Object.create(null);_syncedModelsLastUsedTime=Object.create(null);constructor(e,n,t=!1){if(super(),this._proxy=e,this._modelService=n,!t){const o=new p;o.cancelAndSet(()=>this._checkStopModelSync(),Math.round(u/2)),this._register(o)}}dispose(){for(const e in this._syncedModels)l(this._syncedModels[e]);this._syncedModels=Object.create(null),this._syncedModelsLastUsedTime=Object.create(null),super.dispose()}ensureSyncedResources(e,n=!1){for(const t of e){const o=t.toString();this._syncedModels[o]||this._beginModelSync(t,n),this._syncedModels[o]&&(this._syncedModelsLastUsedTime[o]=new Date().getTime())}}_checkStopModelSync(){const e=new Date().getTime(),n=[];for(const t in this._syncedModelsLastUsedTime)e-this._syncedModelsLastUsedTime[t]>u&&n.push(t);for(const t of n)this._stopModelSync(t)}_beginModelSync(e,n){const t=this._modelService.getModel(e);if(!t||!n&&t.isTooLargeForSyncing())return;const o=e.toString();this._proxy.$acceptNewModel({url:t.uri.toString(),lines:t.getLinesContent(),EOL:t.getEOL(),versionId:t.getVersionId()});const r=new b;r.add(t.onDidChangeContent(i=>{this._proxy.$acceptModelChanged(o.toString(),i)})),r.add(t.onWillDispose(()=>{this._stopModelSync(o)})),r.add(_(()=>{this._proxy.$acceptRemovedModel(o)})),this._syncedModels[o]=r}_stopModelSync(e){const n=this._syncedModels[e];delete this._syncedModels[e],delete this._syncedModelsLastUsedTime[e],l(n)}}class N{_models;constructor(){this._models=Object.create(null)}bindToServer(e){e.setChannel(c,this)}getModel(e){return this._models[e]}getModels(){const e=[];return Object.keys(this._models).forEach(n=>e.push(this._models[n])),e}$acceptNewModel(e){this._models[e.url]=new y(M.parse(e.url),e.lines,e.EOL,e.versionId)}$acceptModelChanged(e,n){if(!this._models[e])return;this._models[e].onEvents(n)}$acceptRemovedModel(e){this._models[e]&&delete this._models[e]}}class y extends C{get uri(){return this._uri}get eol(){return this._eol}getValue(){return this.getText()}findMatches(e){const n=[];for(let t=0;t<this._lines.length;t++){const o=this._lines[t],r=this.offsetAt(new d(t+1,1)),i=o.matchAll(e);for(const s of i)(s.index||s.index===0)&&(s.index=s.index+r),n.push(s)}return n}getLinesContent(){return this._lines.slice(0)}getLineCount(){return this._lines.length}getLineContent(e){return this._lines[e-1]}getWordAtPosition(e,n){const t=x(e.column,f(n),this._lines[e.lineNumber-1],0);return t?new I(e.lineNumber,t.startColumn,e.lineNumber,t.endColumn):null}getWordUntilPosition(e,n){const t=this.getWordAtPosition(e,n);return t?{word:this._lines[e.lineNumber-1].substring(t.startColumn-1,e.column-1),startColumn:t.startColumn,endColumn:e.column}:{word:"",startColumn:e.column,endColumn:e.column}}words(e){const n=this._lines,t=this._wordenize.bind(this);let o=0,r="",i=0,s=[];return{*[Symbol.iterator](){for(;;)if(i<s.length){const h=r.substring(s[i].start,s[i].end);i+=1,yield h}else if(o<n.length)r=n[o],s=t(r,e),i=0,o+=1;else break}}}getLineWords(e,n){const t=this._lines[e-1],o=this._wordenize(t,n),r=[];for(const i of o)r.push({word:t.substring(i.start,i.end),startColumn:i.start+1,endColumn:i.end+1});return r}_wordenize(e,n){const t=[];let o;for(n.lastIndex=0;(o=n.exec(e))&&o[0].length!==0;)t.push({start:o.index,end:o.index+o[0].length});return t}getValueInRange(e){if(e=this._validateRange(e),e.startLineNumber===e.endLineNumber)return this._lines[e.startLineNumber-1].substring(e.startColumn-1,e.endColumn-1);const n=this._eol,t=e.startLineNumber-1,o=e.endLineNumber-1,r=[];r.push(this._lines[t].substring(e.startColumn-1));for(let i=t+1;i<o;i++)r.push(this._lines[i]);return r.push(this._lines[o].substring(0,e.endColumn-1)),r.join(n)}offsetAt(e){return e=this._validatePosition(e),this._ensureLineStarts(),this._lineStarts.getPrefixSum(e.lineNumber-2)+(e.column-1)}positionAt(e){e=Math.floor(e),e=Math.max(0,e),this._ensureLineStarts();const n=this._lineStarts.getIndexOf(e),t=this._lines[n.index].length;return{lineNumber:1+n.index,column:1+Math.min(n.remainder,t)}}_validateRange(e){const n=this._validatePosition({lineNumber:e.startLineNumber,column:e.startColumn}),t=this._validatePosition({lineNumber:e.endLineNumber,column:e.endColumn});return n.lineNumber!==e.startLineNumber||n.column!==e.startColumn||t.lineNumber!==e.endLineNumber||t.column!==e.endColumn?{startLineNumber:n.lineNumber,startColumn:n.column,endLineNumber:t.lineNumber,endColumn:t.column}:e}_validatePosition(e){if(!d.isIPosition(e))throw new Error("bad position");let{lineNumber:n,column:t}=e,o=!1;if(n<1)n=1,t=1,o=!0;else if(n>this._lines.length)n=this._lines.length,t=this._lines[n-1].length+1,o=!0;else{const r=this._lines[n-1].length+1;t<1?(t=1,o=!0):t>r&&(t=r,o=!0)}return o?{lineNumber:n,column:t}:e}}export{y as MirrorModel,u as STOP_SYNC_MODEL_DELTA_TIME_MS,c as WORKER_TEXT_MODEL_SYNC_CHANNEL,m as WorkerTextModelSyncClient,N as WorkerTextModelSyncServer};
