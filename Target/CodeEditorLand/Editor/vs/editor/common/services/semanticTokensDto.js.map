{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/services/semanticTokensDto.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport * as platform from '../../../base/common/platform.js';\n\nexport interface IFullSemanticTokensDto {\n\tid: number;\n\ttype: 'full';\n\tdata: Uint32Array;\n}\n\nexport interface IDeltaSemanticTokensDto {\n\tid: number;\n\ttype: 'delta';\n\tdeltas: { start: number; deleteCount: number; data?: Uint32Array }[];\n}\n\nexport type ISemanticTokensDto = IFullSemanticTokensDto | IDeltaSemanticTokensDto;\n\nconst enum EncodedSemanticTokensType {\n\tFull = 1,\n\tDelta = 2\n}\n\nfunction reverseEndianness(arr: Uint8Array): void {\n\tfor (let i = 0, len = arr.length; i < len; i += 4) {\n\t\t// flip bytes 0<->3 and 1<->2\n\t\tconst b0 = arr[i + 0];\n\t\tconst b1 = arr[i + 1];\n\t\tconst b2 = arr[i + 2];\n\t\tconst b3 = arr[i + 3];\n\t\tarr[i + 0] = b3;\n\t\tarr[i + 1] = b2;\n\t\tarr[i + 2] = b1;\n\t\tarr[i + 3] = b0;\n\t}\n}\n\nfunction toLittleEndianBuffer(arr: Uint32Array): VSBuffer {\n\tconst uint8Arr = new Uint8Array(arr.buffer, arr.byteOffset, arr.length * 4);\n\tif (!platform.isLittleEndian()) {\n\t\t// the byte order must be changed\n\t\treverseEndianness(uint8Arr);\n\t}\n\treturn VSBuffer.wrap(uint8Arr);\n}\n\nfunction fromLittleEndianBuffer(buff: VSBuffer): Uint32Array {\n\tconst uint8Arr = buff.buffer;\n\tif (!platform.isLittleEndian()) {\n\t\t// the byte order must be changed\n\t\treverseEndianness(uint8Arr);\n\t}\n\tif (uint8Arr.byteOffset % 4 === 0) {\n\t\treturn new Uint32Array(uint8Arr.buffer, uint8Arr.byteOffset, uint8Arr.length / 4);\n\t} else {\n\t\t// unaligned memory access doesn't work on all platforms\n\t\tconst data = new Uint8Array(uint8Arr.byteLength);\n\t\tdata.set(uint8Arr);\n\t\treturn new Uint32Array(data.buffer, data.byteOffset, data.length / 4);\n\t}\n}\n\nexport function encodeSemanticTokensDto(semanticTokens: ISemanticTokensDto): VSBuffer {\n\tconst dest = new Uint32Array(encodeSemanticTokensDtoSize(semanticTokens));\n\tlet offset = 0;\n\tdest[offset++] = semanticTokens.id;\n\tif (semanticTokens.type === 'full') {\n\t\tdest[offset++] = EncodedSemanticTokensType.Full;\n\t\tdest[offset++] = semanticTokens.data.length;\n\t\tdest.set(semanticTokens.data, offset); offset += semanticTokens.data.length;\n\t} else {\n\t\tdest[offset++] = EncodedSemanticTokensType.Delta;\n\t\tdest[offset++] = semanticTokens.deltas.length;\n\t\tfor (const delta of semanticTokens.deltas) {\n\t\t\tdest[offset++] = delta.start;\n\t\t\tdest[offset++] = delta.deleteCount;\n\t\t\tif (delta.data) {\n\t\t\t\tdest[offset++] = delta.data.length;\n\t\t\t\tdest.set(delta.data, offset); offset += delta.data.length;\n\t\t\t} else {\n\t\t\t\tdest[offset++] = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn toLittleEndianBuffer(dest);\n}\n\nfunction encodeSemanticTokensDtoSize(semanticTokens: ISemanticTokensDto): number {\n\tlet result = 0;\n\tresult += (\n\t\t+ 1 // id\n\t\t+ 1 // type\n\t);\n\tif (semanticTokens.type === 'full') {\n\t\tresult += (\n\t\t\t+ 1 // data length\n\t\t\t+ semanticTokens.data.length\n\t\t);\n\t} else {\n\t\tresult += (\n\t\t\t+ 1 // delta count\n\t\t);\n\t\tresult += (\n\t\t\t+ 1 // start\n\t\t\t+ 1 // deleteCount\n\t\t\t+ 1 // data length\n\t\t) * semanticTokens.deltas.length;\n\t\tfor (const delta of semanticTokens.deltas) {\n\t\t\tif (delta.data) {\n\t\t\t\tresult += delta.data.length;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nexport function decodeSemanticTokensDto(_buff: VSBuffer): ISemanticTokensDto {\n\tconst src = fromLittleEndianBuffer(_buff);\n\tlet offset = 0;\n\tconst id = src[offset++];\n\tconst type: EncodedSemanticTokensType = src[offset++];\n\tif (type === EncodedSemanticTokensType.Full) {\n\t\tconst length = src[offset++];\n\t\tconst data = src.subarray(offset, offset + length); offset += length;\n\t\treturn {\n\t\t\tid: id,\n\t\t\ttype: 'full',\n\t\t\tdata: data\n\t\t};\n\t}\n\tconst deltaCount = src[offset++];\n\tconst deltas: { start: number; deleteCount: number; data?: Uint32Array }[] = [];\n\tfor (let i = 0; i < deltaCount; i++) {\n\t\tconst start = src[offset++];\n\t\tconst deleteCount = src[offset++];\n\t\tconst length = src[offset++];\n\t\tlet data: Uint32Array | undefined;\n\t\tif (length > 0) {\n\t\t\tdata = src.subarray(offset, offset + length); offset += length;\n\t\t}\n\t\tdeltas[i] = { start, deleteCount, data };\n\t}\n\treturn {\n\t\tid: id,\n\t\ttype: 'delta',\n\t\tdeltas: deltas\n\t};\n}\n"],
  "mappings": "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",
  "names": ["EncodedSemanticTokensType"]
}
