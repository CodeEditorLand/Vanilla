{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/services/semanticTokensDto.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { VSBuffer } from \"../../../base/common/buffer.js\";\nimport * as platform from \"../../../base/common/platform.js\";\n\nexport interface IFullSemanticTokensDto {\n\tid: number;\n\ttype: \"full\";\n\tdata: Uint32Array;\n}\n\nexport interface IDeltaSemanticTokensDto {\n\tid: number;\n\ttype: \"delta\";\n\tdeltas: { start: number; deleteCount: number; data?: Uint32Array }[];\n}\n\nexport type ISemanticTokensDto =\n\t| IFullSemanticTokensDto\n\t| IDeltaSemanticTokensDto;\n\nenum EncodedSemanticTokensType {\n\tFull = 1,\n\tDelta = 2,\n}\n\nfunction reverseEndianness(arr: Uint8Array): void {\n\tfor (let i = 0, len = arr.length; i < len; i += 4) {\n\t\t// flip bytes 0<->3 and 1<->2\n\t\tconst b0 = arr[i + 0];\n\t\tconst b1 = arr[i + 1];\n\t\tconst b2 = arr[i + 2];\n\t\tconst b3 = arr[i + 3];\n\t\tarr[i + 0] = b3;\n\t\tarr[i + 1] = b2;\n\t\tarr[i + 2] = b1;\n\t\tarr[i + 3] = b0;\n\t}\n}\n\nfunction toLittleEndianBuffer(arr: Uint32Array): VSBuffer {\n\tconst uint8Arr = new Uint8Array(arr.buffer, arr.byteOffset, arr.length * 4);\n\tif (!platform.isLittleEndian()) {\n\t\t// the byte order must be changed\n\t\treverseEndianness(uint8Arr);\n\t}\n\treturn VSBuffer.wrap(uint8Arr);\n}\n\nfunction fromLittleEndianBuffer(buff: VSBuffer): Uint32Array {\n\tconst uint8Arr = buff.buffer;\n\tif (!platform.isLittleEndian()) {\n\t\t// the byte order must be changed\n\t\treverseEndianness(uint8Arr);\n\t}\n\tif (uint8Arr.byteOffset % 4 === 0) {\n\t\treturn new Uint32Array(\n\t\t\tuint8Arr.buffer,\n\t\t\tuint8Arr.byteOffset,\n\t\t\tuint8Arr.length / 4,\n\t\t);\n\t} else {\n\t\t// unaligned memory access doesn't work on all platforms\n\t\tconst data = new Uint8Array(uint8Arr.byteLength);\n\t\tdata.set(uint8Arr);\n\t\treturn new Uint32Array(data.buffer, data.byteOffset, data.length / 4);\n\t}\n}\n\nexport function encodeSemanticTokensDto(\n\tsemanticTokens: ISemanticTokensDto,\n): VSBuffer {\n\tconst dest = new Uint32Array(encodeSemanticTokensDtoSize(semanticTokens));\n\tlet offset = 0;\n\tdest[offset++] = semanticTokens.id;\n\tif (semanticTokens.type === \"full\") {\n\t\tdest[offset++] = EncodedSemanticTokensType.Full;\n\t\tdest[offset++] = semanticTokens.data.length;\n\t\tdest.set(semanticTokens.data, offset);\n\t\toffset += semanticTokens.data.length;\n\t} else {\n\t\tdest[offset++] = EncodedSemanticTokensType.Delta;\n\t\tdest[offset++] = semanticTokens.deltas.length;\n\t\tfor (const delta of semanticTokens.deltas) {\n\t\t\tdest[offset++] = delta.start;\n\t\t\tdest[offset++] = delta.deleteCount;\n\t\t\tif (delta.data) {\n\t\t\t\tdest[offset++] = delta.data.length;\n\t\t\t\tdest.set(delta.data, offset);\n\t\t\t\toffset += delta.data.length;\n\t\t\t} else {\n\t\t\t\tdest[offset++] = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn toLittleEndianBuffer(dest);\n}\n\nfunction encodeSemanticTokensDtoSize(\n\tsemanticTokens: ISemanticTokensDto,\n): number {\n\tlet result = 0;\n\tresult +=\n\t\t+1 + // id\n\t\t1; // type\n\tif (semanticTokens.type === \"full\") {\n\t\tresult +=\n\t\t\t+1 + // data length\n\t\t\tsemanticTokens.data.length;\n\t} else {\n\t\tresult +=\n\t\t\t+1; // delta count\n\t\tresult +=\n\t\t\t(+1 + // start\n\t\t\t\t1 + // deleteCount\n\t\t\t\t1) * // data length\n\t\t\tsemanticTokens.deltas.length;\n\t\tfor (const delta of semanticTokens.deltas) {\n\t\t\tif (delta.data) {\n\t\t\t\tresult += delta.data.length;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nexport function decodeSemanticTokensDto(_buff: VSBuffer): ISemanticTokensDto {\n\tconst src = fromLittleEndianBuffer(_buff);\n\tlet offset = 0;\n\tconst id = src[offset++];\n\tconst type: EncodedSemanticTokensType = src[offset++];\n\tif (type === EncodedSemanticTokensType.Full) {\n\t\tconst length = src[offset++];\n\t\tconst data = src.subarray(offset, offset + length);\n\t\toffset += length;\n\t\treturn {\n\t\t\tid: id,\n\t\t\ttype: \"full\",\n\t\t\tdata: data,\n\t\t};\n\t}\n\tconst deltaCount = src[offset++];\n\tconst deltas: { start: number; deleteCount: number; data?: Uint32Array }[] =\n\t\t[];\n\tfor (let i = 0; i < deltaCount; i++) {\n\t\tconst start = src[offset++];\n\t\tconst deleteCount = src[offset++];\n\t\tconst length = src[offset++];\n\t\tlet data: Uint32Array | undefined;\n\t\tif (length > 0) {\n\t\t\tdata = src.subarray(offset, offset + length);\n\t\t\toffset += length;\n\t\t}\n\t\tdeltas[i] = { start, deleteCount, data };\n\t}\n\treturn {\n\t\tid: id,\n\t\ttype: \"delta\",\n\t\tdeltas: deltas,\n\t};\n}\n"],
  "mappings": "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",
  "names": ["EncodedSemanticTokensType"]
}
