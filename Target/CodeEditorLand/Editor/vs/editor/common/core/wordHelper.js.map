{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/core/wordHelper.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Iterable } from '../../../base/common/iterator.js';\nimport { toDisposable } from '../../../base/common/lifecycle.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\n\nexport const USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\n\n/**\n * Word inside a model.\n */\nexport interface IWordAtPosition {\n\t/**\n\t * The word.\n\t */\n\treadonly word: string;\n\t/**\n\t * The column where the word starts.\n\t */\n\treadonly startColumn: number;\n\t/**\n\t * The column where the word ends.\n\t */\n\treadonly endColumn: number;\n}\n\n/**\n * Create a word definition regular expression based on default word separators.\n * Optionally provide allowed separators that should be included in words.\n *\n * The default would look like this:\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\n */\nfunction createWordRegExp(allowInWords: string = ''): RegExp {\n\tlet source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\n\tfor (const sep of USUAL_WORD_SEPARATORS) {\n\t\tif (allowInWords.indexOf(sep) >= 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tsource += '\\\\' + sep;\n\t}\n\tsource += '\\\\s]+)';\n\treturn new RegExp(source, 'g');\n}\n\n// catches numbers (including floating numbers) in the first group, and alphanum in the second\nexport const DEFAULT_WORD_REGEXP = createWordRegExp();\n\nexport function ensureValidWordDefinition(wordDefinition?: RegExp | null): RegExp {\n\tlet result: RegExp = DEFAULT_WORD_REGEXP;\n\n\tif (wordDefinition && (wordDefinition instanceof RegExp)) {\n\t\tif (!wordDefinition.global) {\n\t\t\tlet flags = 'g';\n\t\t\tif (wordDefinition.ignoreCase) {\n\t\t\t\tflags += 'i';\n\t\t\t}\n\t\t\tif (wordDefinition.multiline) {\n\t\t\t\tflags += 'm';\n\t\t\t}\n\t\t\tif (wordDefinition.unicode) {\n\t\t\t\tflags += 'u';\n\t\t\t}\n\t\t\tresult = new RegExp(wordDefinition.source, flags);\n\t\t} else {\n\t\t\tresult = wordDefinition;\n\t\t}\n\t}\n\n\tresult.lastIndex = 0;\n\n\treturn result;\n}\n\n\nexport interface IGetWordAtTextConfig {\n\tmaxLen: number;\n\twindowSize: number;\n\ttimeBudget: number;\n}\n\n\nconst _defaultConfig = new LinkedList<IGetWordAtTextConfig>();\n_defaultConfig.unshift({\n\tmaxLen: 1000,\n\twindowSize: 15,\n\ttimeBudget: 150\n});\n\nexport function setDefaultGetWordAtTextConfig(value: IGetWordAtTextConfig) {\n\tconst rm = _defaultConfig.unshift(value);\n\treturn toDisposable(rm);\n}\n\nexport function getWordAtText(column: number, wordDefinition: RegExp, text: string, textOffset: number, config?: IGetWordAtTextConfig): IWordAtPosition | null {\n\t// Ensure the regex has the 'g' flag, otherwise this will loop forever\n\twordDefinition = ensureValidWordDefinition(wordDefinition);\n\n\tif (!config) {\n\t\tconfig = Iterable.first(_defaultConfig)!;\n\t}\n\n\tif (text.length > config.maxLen) {\n\t\t// don't throw strings that long at the regexp\n\t\t// but use a sub-string in which a word must occur\n\t\tlet start = column - config.maxLen / 2;\n\t\tif (start < 0) {\n\t\t\tstart = 0;\n\t\t} else {\n\t\t\ttextOffset += start;\n\t\t}\n\t\ttext = text.substring(start, column + config.maxLen / 2);\n\t\treturn getWordAtText(column, wordDefinition, text, textOffset, config);\n\t}\n\n\tconst t1 = Date.now();\n\tconst pos = column - 1 - textOffset;\n\n\tlet prevRegexIndex = -1;\n\tlet match: RegExpExecArray | null = null;\n\n\tfor (let i = 1; ; i++) {\n\t\t// check time budget\n\t\tif (Date.now() - t1 >= config.timeBudget) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// reset the index at which the regexp should start matching, also know where it\n\t\t// should stop so that subsequent search don't repeat previous searches\n\t\tconst regexIndex = pos - config.windowSize * i;\n\t\twordDefinition.lastIndex = Math.max(0, regexIndex);\n\t\tconst thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);\n\n\t\tif (!thisMatch && match) {\n\t\t\t// stop: we have something\n\t\t\tbreak;\n\t\t}\n\n\t\tmatch = thisMatch;\n\n\t\t// stop: searched at start\n\t\tif (regexIndex <= 0) {\n\t\t\tbreak;\n\t\t}\n\t\tprevRegexIndex = regexIndex;\n\t}\n\n\tif (match) {\n\t\tconst result = {\n\t\t\tword: match[0],\n\t\t\tstartColumn: textOffset + 1 + match.index,\n\t\t\tendColumn: textOffset + 1 + match.index + match[0].length\n\t\t};\n\t\twordDefinition.lastIndex = 0;\n\t\treturn result;\n\t}\n\n\treturn null;\n}\n\nfunction _findRegexMatchEnclosingPosition(wordDefinition: RegExp, text: string, pos: number, stopPos: number): RegExpExecArray | null {\n\tlet match: RegExpExecArray | null;\n\twhile (match = wordDefinition.exec(text)) {\n\t\tconst matchIndex = match.index || 0;\n\t\tif (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\n\t\t\treturn match;\n\t\t} else if (stopPos > 0 && matchIndex > stopPos) {\n\t\t\treturn null;\n\t\t}\n\t}\n\treturn null;\n}\n"],
  "mappings": "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",
  "names": []
}
