{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/core/textEdit.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { assert, assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { ISingleEditOperation } from './editOperation.js';\nimport { Position } from './position.js';\nimport { PositionOffsetTransformer } from './positionToOffset.js';\nimport { Range } from './range.js';\nimport { TextLength } from './textLength.js';\n\nexport class TextEdit {\n\tpublic static single(originalRange: Range, newText: string): TextEdit {\n\t\treturn new TextEdit([new SingleTextEdit(originalRange, newText)]);\n\t}\n\n\tconstructor(public readonly edits: readonly SingleTextEdit[]) {\n\t\tassertFn(() => checkAdjacentItems(edits, (a, b) => a.range.getEndPosition().isBeforeOrEqual(b.range.getStartPosition())));\n\t}\n\n\t/**\n\t * Joins touching edits and removes empty edits.\n\t */\n\tnormalize(): TextEdit {\n\t\tconst edits: SingleTextEdit[] = [];\n\t\tfor (const edit of this.edits) {\n\t\t\tif (edits.length > 0 && edits[edits.length - 1].range.getEndPosition().equals(edit.range.getStartPosition())) {\n\t\t\t\tconst last = edits[edits.length - 1];\n\t\t\t\tedits[edits.length - 1] = new SingleTextEdit(last.range.plusRange(edit.range), last.text + edit.text);\n\t\t\t} else if (!edit.isEmpty) {\n\t\t\t\tedits.push(edit);\n\t\t\t}\n\t\t}\n\t\treturn new TextEdit(edits);\n\t}\n\n\tmapPosition(position: Position): Position | Range {\n\t\tlet lineDelta = 0;\n\t\tlet curLine = 0;\n\t\tlet columnDeltaInCurLine = 0;\n\n\t\tfor (const edit of this.edits) {\n\t\t\tconst start = edit.range.getStartPosition();\n\t\t\tconst end = edit.range.getEndPosition();\n\n\t\t\tif (position.isBeforeOrEqual(start)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst len = TextLength.ofText(edit.text);\n\t\t\tif (position.isBefore(end)) {\n\t\t\t\tconst startPos = new Position(start.lineNumber + lineDelta, start.column + (start.lineNumber + lineDelta === curLine ? columnDeltaInCurLine : 0));\n\t\t\t\tconst endPos = len.addToPosition(startPos);\n\t\t\t\treturn rangeFromPositions(startPos, endPos);\n\t\t\t}\n\n\t\t\tlineDelta += len.lineCount - (edit.range.endLineNumber - edit.range.startLineNumber);\n\n\t\t\tif (len.lineCount === 0) {\n\t\t\t\tif (end.lineNumber !== start.lineNumber) {\n\t\t\t\t\tcolumnDeltaInCurLine += len.columnCount - (end.column - 1);\n\t\t\t\t} else {\n\t\t\t\t\tcolumnDeltaInCurLine += len.columnCount - (end.column - start.column);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcolumnDeltaInCurLine = len.columnCount;\n\t\t\t}\n\t\t\tcurLine = end.lineNumber + lineDelta;\n\t\t}\n\n\t\treturn new Position(position.lineNumber + lineDelta, position.column + (position.lineNumber + lineDelta === curLine ? columnDeltaInCurLine : 0));\n\t}\n\n\tmapRange(range: Range): Range {\n\t\tfunction getStart(p: Position | Range) {\n\t\t\treturn p instanceof Position ? p : p.getStartPosition();\n\t\t}\n\n\t\tfunction getEnd(p: Position | Range) {\n\t\t\treturn p instanceof Position ? p : p.getEndPosition();\n\t\t}\n\n\t\tconst start = getStart(this.mapPosition(range.getStartPosition()));\n\t\tconst end = getEnd(this.mapPosition(range.getEndPosition()));\n\n\t\treturn rangeFromPositions(start, end);\n\t}\n\n\t// TODO: `doc` is not needed for this!\n\tinverseMapPosition(positionAfterEdit: Position, doc: AbstractText): Position | Range {\n\t\tconst reversed = this.inverse(doc);\n\t\treturn reversed.mapPosition(positionAfterEdit);\n\t}\n\n\tinverseMapRange(range: Range, doc: AbstractText): Range {\n\t\tconst reversed = this.inverse(doc);\n\t\treturn reversed.mapRange(range);\n\t}\n\n\tapply(text: AbstractText): string {\n\t\tlet result = '';\n\t\tlet lastEditEnd = new Position(1, 1);\n\t\tfor (const edit of this.edits) {\n\t\t\tconst editRange = edit.range;\n\t\t\tconst editStart = editRange.getStartPosition();\n\t\t\tconst editEnd = editRange.getEndPosition();\n\n\t\t\tconst r = rangeFromPositions(lastEditEnd, editStart);\n\t\t\tif (!r.isEmpty()) {\n\t\t\t\tresult += text.getValueOfRange(r);\n\t\t\t}\n\t\t\tresult += edit.text;\n\t\t\tlastEditEnd = editEnd;\n\t\t}\n\t\tconst r = rangeFromPositions(lastEditEnd, text.endPositionExclusive);\n\t\tif (!r.isEmpty()) {\n\t\t\tresult += text.getValueOfRange(r);\n\t\t}\n\t\treturn result;\n\t}\n\n\tapplyToString(str: string): string {\n\t\tconst strText = new StringText(str);\n\t\treturn this.apply(strText);\n\t}\n\n\tinverse(doc: AbstractText): TextEdit {\n\t\tconst ranges = this.getNewRanges();\n\t\treturn new TextEdit(this.edits.map((e, idx) => new SingleTextEdit(ranges[idx], doc.getValueOfRange(e.range))));\n\t}\n\n\tgetNewRanges(): Range[] {\n\t\tconst newRanges: Range[] = [];\n\t\tlet previousEditEndLineNumber = 0;\n\t\tlet lineOffset = 0;\n\t\tlet columnOffset = 0;\n\t\tfor (const edit of this.edits) {\n\t\t\tconst textLength = TextLength.ofText(edit.text);\n\t\t\tconst newRangeStart = Position.lift({\n\t\t\t\tlineNumber: edit.range.startLineNumber + lineOffset,\n\t\t\t\tcolumn: edit.range.startColumn + (edit.range.startLineNumber === previousEditEndLineNumber ? columnOffset : 0)\n\t\t\t});\n\t\t\tconst newRange = textLength.createRange(newRangeStart);\n\t\t\tnewRanges.push(newRange);\n\t\t\tlineOffset = newRange.endLineNumber - edit.range.endLineNumber;\n\t\t\tcolumnOffset = newRange.endColumn - edit.range.endColumn;\n\t\t\tpreviousEditEndLineNumber = edit.range.endLineNumber;\n\t\t}\n\t\treturn newRanges;\n\t}\n}\n\nexport class SingleTextEdit {\n\tconstructor(\n\t\tpublic readonly range: Range,\n\t\tpublic readonly text: string,\n\t) {\n\t}\n\n\tget isEmpty(): boolean {\n\t\treturn this.range.isEmpty() && this.text.length === 0;\n\t}\n\n\tstatic equals(first: SingleTextEdit, second: SingleTextEdit) {\n\t\treturn first.range.equalsRange(second.range) && first.text === second.text;\n\t}\n\n\tpublic toSingleEditOperation(): ISingleEditOperation {\n\t\treturn {\n\t\t\trange: this.range,\n\t\t\ttext: this.text,\n\t\t};\n\t}\n}\n\nfunction rangeFromPositions(start: Position, end: Position): Range {\n\tif (start.lineNumber === end.lineNumber && start.column === Number.MAX_SAFE_INTEGER) {\n\t\treturn Range.fromPositions(end, end);\n\t} else if (!start.isBeforeOrEqual(end)) {\n\t\tthrow new BugIndicatingError('start must be before end');\n\t}\n\treturn new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n}\n\nexport abstract class AbstractText {\n\tabstract getValueOfRange(range: Range): string;\n\tabstract readonly length: TextLength;\n\n\tget endPositionExclusive(): Position {\n\t\treturn this.length.addToPosition(new Position(1, 1));\n\t}\n\n\tgetValue() {\n\t\treturn this.getValueOfRange(this.length.toRange());\n\t}\n}\n\nexport class LineBasedText extends AbstractText {\n\tconstructor(\n\t\tprivate readonly _getLineContent: (lineNumber: number) => string,\n\t\tprivate readonly _lineCount: number,\n\t) {\n\t\tassert(_lineCount >= 1);\n\n\t\tsuper();\n\t}\n\n\tgetValueOfRange(range: Range): string {\n\t\tif (range.startLineNumber === range.endLineNumber) {\n\t\t\treturn this._getLineContent(range.startLineNumber).substring(range.startColumn - 1, range.endColumn - 1);\n\t\t}\n\t\tlet result = this._getLineContent(range.startLineNumber).substring(range.startColumn - 1);\n\t\tfor (let i = range.startLineNumber + 1; i < range.endLineNumber; i++) {\n\t\t\tresult += '\\n' + this._getLineContent(i);\n\t\t}\n\t\tresult += '\\n' + this._getLineContent(range.endLineNumber).substring(0, range.endColumn - 1);\n\t\treturn result;\n\t}\n\n\tget length(): TextLength {\n\t\tconst lastLine = this._getLineContent(this._lineCount);\n\t\treturn new TextLength(this._lineCount - 1, lastLine.length);\n\t}\n}\n\nexport class ArrayText extends LineBasedText {\n\tconstructor(lines: string[]) {\n\t\tsuper(\n\t\t\tlineNumber => lines[lineNumber - 1],\n\t\t\tlines.length\n\t\t);\n\t}\n}\n\nexport class StringText extends AbstractText {\n\tprivate readonly _t = new PositionOffsetTransformer(this.value);\n\n\tconstructor(public readonly value: string) {\n\t\tsuper();\n\t}\n\n\tgetValueOfRange(range: Range): string {\n\t\treturn this._t.getOffsetRange(range).substring(this.value);\n\t}\n\n\tget length(): TextLength {\n\t\treturn this._t.textLength;\n\t}\n}\n"],
  "mappings": "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",
  "names": ["r"]
}
