{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/core/textEdit.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport {\n\tassert,\n\tassertFn,\n\tcheckAdjacentItems,\n} from \"../../../base/common/assert.js\";\nimport { BugIndicatingError } from \"../../../base/common/errors.js\";\nimport type { ISingleEditOperation } from \"./editOperation.js\";\nimport { Position } from \"./position.js\";\nimport { PositionOffsetTransformer } from \"./positionToOffset.js\";\nimport { Range } from \"./range.js\";\nimport { TextLength } from \"./textLength.js\";\n\nexport class TextEdit {\n\tpublic static single(originalRange: Range, newText: string): TextEdit {\n\t\treturn new TextEdit([new SingleTextEdit(originalRange, newText)]);\n\t}\n\n\tconstructor(public readonly edits: readonly SingleTextEdit[]) {\n\t\tassertFn(() =>\n\t\t\tcheckAdjacentItems(edits, (a, b) =>\n\t\t\t\ta.range\n\t\t\t\t\t.getEndPosition()\n\t\t\t\t\t.isBeforeOrEqual(b.range.getStartPosition()),\n\t\t\t),\n\t\t);\n\t}\n\n\t/**\n\t * Joins touching edits and removes empty edits.\n\t */\n\tnormalize(): TextEdit {\n\t\tconst edits: SingleTextEdit[] = [];\n\t\tfor (const edit of this.edits) {\n\t\t\tif (\n\t\t\t\tedits.length > 0 &&\n\t\t\t\tedits[edits.length - 1].range\n\t\t\t\t\t.getEndPosition()\n\t\t\t\t\t.equals(edit.range.getStartPosition())\n\t\t\t) {\n\t\t\t\tconst last = edits[edits.length - 1];\n\t\t\t\tedits[edits.length - 1] = new SingleTextEdit(\n\t\t\t\t\tlast.range.plusRange(edit.range),\n\t\t\t\t\tlast.text + edit.text,\n\t\t\t\t);\n\t\t\t} else if (!edit.isEmpty) {\n\t\t\t\tedits.push(edit);\n\t\t\t}\n\t\t}\n\t\treturn new TextEdit(edits);\n\t}\n\n\tmapPosition(position: Position): Position | Range {\n\t\tlet lineDelta = 0;\n\t\tlet curLine = 0;\n\t\tlet columnDeltaInCurLine = 0;\n\n\t\tfor (const edit of this.edits) {\n\t\t\tconst start = edit.range.getStartPosition();\n\t\t\tconst end = edit.range.getEndPosition();\n\n\t\t\tif (position.isBeforeOrEqual(start)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst len = TextLength.ofText(edit.text);\n\t\t\tif (position.isBefore(end)) {\n\t\t\t\tconst startPos = new Position(\n\t\t\t\t\tstart.lineNumber + lineDelta,\n\t\t\t\t\tstart.column +\n\t\t\t\t\t\t(start.lineNumber + lineDelta === curLine\n\t\t\t\t\t\t\t? columnDeltaInCurLine\n\t\t\t\t\t\t\t: 0),\n\t\t\t\t);\n\t\t\t\tconst endPos = len.addToPosition(startPos);\n\t\t\t\treturn rangeFromPositions(startPos, endPos);\n\t\t\t}\n\n\t\t\tlineDelta +=\n\t\t\t\tlen.lineCount -\n\t\t\t\t(edit.range.endLineNumber - edit.range.startLineNumber);\n\n\t\t\tif (len.lineCount === 0) {\n\t\t\t\tif (end.lineNumber !== start.lineNumber) {\n\t\t\t\t\tcolumnDeltaInCurLine += len.columnCount - (end.column - 1);\n\t\t\t\t} else {\n\t\t\t\t\tcolumnDeltaInCurLine +=\n\t\t\t\t\t\tlen.columnCount - (end.column - start.column);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcolumnDeltaInCurLine = len.columnCount;\n\t\t\t}\n\t\t\tcurLine = end.lineNumber + lineDelta;\n\t\t}\n\n\t\treturn new Position(\n\t\t\tposition.lineNumber + lineDelta,\n\t\t\tposition.column +\n\t\t\t\t(position.lineNumber + lineDelta === curLine\n\t\t\t\t\t? columnDeltaInCurLine\n\t\t\t\t\t: 0),\n\t\t);\n\t}\n\n\tmapRange(range: Range): Range {\n\t\tfunction getStart(p: Position | Range) {\n\t\t\treturn p instanceof Position ? p : p.getStartPosition();\n\t\t}\n\n\t\tfunction getEnd(p: Position | Range) {\n\t\t\treturn p instanceof Position ? p : p.getEndPosition();\n\t\t}\n\n\t\tconst start = getStart(this.mapPosition(range.getStartPosition()));\n\t\tconst end = getEnd(this.mapPosition(range.getEndPosition()));\n\n\t\treturn rangeFromPositions(start, end);\n\t}\n\n\t// TODO: `doc` is not needed for this!\n\tinverseMapPosition(\n\t\tpositionAfterEdit: Position,\n\t\tdoc: AbstractText,\n\t): Position | Range {\n\t\tconst reversed = this.inverse(doc);\n\t\treturn reversed.mapPosition(positionAfterEdit);\n\t}\n\n\tinverseMapRange(range: Range, doc: AbstractText): Range {\n\t\tconst reversed = this.inverse(doc);\n\t\treturn reversed.mapRange(range);\n\t}\n\n\tapply(text: AbstractText): string {\n\t\tlet result = \"\";\n\t\tlet lastEditEnd = new Position(1, 1);\n\t\tfor (const edit of this.edits) {\n\t\t\tconst editRange = edit.range;\n\t\t\tconst editStart = editRange.getStartPosition();\n\t\t\tconst editEnd = editRange.getEndPosition();\n\n\t\t\tconst r = rangeFromPositions(lastEditEnd, editStart);\n\t\t\tif (!r.isEmpty()) {\n\t\t\t\tresult += text.getValueOfRange(r);\n\t\t\t}\n\t\t\tresult += edit.text;\n\t\t\tlastEditEnd = editEnd;\n\t\t}\n\t\tconst r = rangeFromPositions(lastEditEnd, text.endPositionExclusive);\n\t\tif (!r.isEmpty()) {\n\t\t\tresult += text.getValueOfRange(r);\n\t\t}\n\t\treturn result;\n\t}\n\n\tapplyToString(str: string): string {\n\t\tconst strText = new StringText(str);\n\t\treturn this.apply(strText);\n\t}\n\n\tinverse(doc: AbstractText): TextEdit {\n\t\tconst ranges = this.getNewRanges();\n\t\treturn new TextEdit(\n\t\t\tthis.edits.map(\n\t\t\t\t(e, idx) =>\n\t\t\t\t\tnew SingleTextEdit(\n\t\t\t\t\t\tranges[idx],\n\t\t\t\t\t\tdoc.getValueOfRange(e.range),\n\t\t\t\t\t),\n\t\t\t),\n\t\t);\n\t}\n\n\tgetNewRanges(): Range[] {\n\t\tconst newRanges: Range[] = [];\n\t\tlet previousEditEndLineNumber = 0;\n\t\tlet lineOffset = 0;\n\t\tlet columnOffset = 0;\n\t\tfor (const edit of this.edits) {\n\t\t\tconst textLength = TextLength.ofText(edit.text);\n\t\t\tconst newRangeStart = Position.lift({\n\t\t\t\tlineNumber: edit.range.startLineNumber + lineOffset,\n\t\t\t\tcolumn:\n\t\t\t\t\tedit.range.startColumn +\n\t\t\t\t\t(edit.range.startLineNumber === previousEditEndLineNumber\n\t\t\t\t\t\t? columnOffset\n\t\t\t\t\t\t: 0),\n\t\t\t});\n\t\t\tconst newRange = textLength.createRange(newRangeStart);\n\t\t\tnewRanges.push(newRange);\n\t\t\tlineOffset = newRange.endLineNumber - edit.range.endLineNumber;\n\t\t\tcolumnOffset = newRange.endColumn - edit.range.endColumn;\n\t\t\tpreviousEditEndLineNumber = edit.range.endLineNumber;\n\t\t}\n\t\treturn newRanges;\n\t}\n}\n\nexport class SingleTextEdit {\n\tconstructor(\n\t\tpublic readonly range: Range,\n\t\tpublic readonly text: string,\n\t) {}\n\n\tget isEmpty(): boolean {\n\t\treturn this.range.isEmpty() && this.text.length === 0;\n\t}\n\n\tstatic equals(first: SingleTextEdit, second: SingleTextEdit) {\n\t\treturn (\n\t\t\tfirst.range.equalsRange(second.range) && first.text === second.text\n\t\t);\n\t}\n\n\tpublic toSingleEditOperation(): ISingleEditOperation {\n\t\treturn {\n\t\t\trange: this.range,\n\t\t\ttext: this.text,\n\t\t};\n\t}\n}\n\nfunction rangeFromPositions(start: Position, end: Position): Range {\n\tif (\n\t\tstart.lineNumber === end.lineNumber &&\n\t\tstart.column === Number.MAX_SAFE_INTEGER\n\t) {\n\t\treturn Range.fromPositions(end, end);\n\t} else if (!start.isBeforeOrEqual(end)) {\n\t\tthrow new BugIndicatingError(\"start must be before end\");\n\t}\n\treturn new Range(\n\t\tstart.lineNumber,\n\t\tstart.column,\n\t\tend.lineNumber,\n\t\tend.column,\n\t);\n}\n\nexport abstract class AbstractText {\n\tabstract getValueOfRange(range: Range): string;\n\tabstract readonly length: TextLength;\n\n\tget endPositionExclusive(): Position {\n\t\treturn this.length.addToPosition(new Position(1, 1));\n\t}\n\n\tgetValue() {\n\t\treturn this.getValueOfRange(this.length.toRange());\n\t}\n}\n\nexport class LineBasedText extends AbstractText {\n\tconstructor(\n\t\tprivate readonly _getLineContent: (lineNumber: number) => string,\n\t\tprivate readonly _lineCount: number,\n\t) {\n\t\tassert(_lineCount >= 1);\n\n\t\tsuper();\n\t}\n\n\tgetValueOfRange(range: Range): string {\n\t\tif (range.startLineNumber === range.endLineNumber) {\n\t\t\treturn this._getLineContent(range.startLineNumber).substring(\n\t\t\t\trange.startColumn - 1,\n\t\t\t\trange.endColumn - 1,\n\t\t\t);\n\t\t}\n\t\tlet result = this._getLineContent(range.startLineNumber).substring(\n\t\t\trange.startColumn - 1,\n\t\t);\n\t\tfor (let i = range.startLineNumber + 1; i < range.endLineNumber; i++) {\n\t\t\tresult += \"\\n\" + this._getLineContent(i);\n\t\t}\n\t\tresult +=\n\t\t\t\"\\n\" +\n\t\t\tthis._getLineContent(range.endLineNumber).substring(\n\t\t\t\t0,\n\t\t\t\trange.endColumn - 1,\n\t\t\t);\n\t\treturn result;\n\t}\n\n\tget length(): TextLength {\n\t\tconst lastLine = this._getLineContent(this._lineCount);\n\t\treturn new TextLength(this._lineCount - 1, lastLine.length);\n\t}\n}\n\nexport class ArrayText extends LineBasedText {\n\tconstructor(lines: string[]) {\n\t\tsuper((lineNumber) => lines[lineNumber - 1], lines.length);\n\t}\n}\n\nexport class StringText extends AbstractText {\n\tprivate readonly _t = new PositionOffsetTransformer(this.value);\n\n\tconstructor(public readonly value: string) {\n\t\tsuper();\n\t}\n\n\tgetValueOfRange(range: Range): string {\n\t\treturn this._t.getOffsetRange(range).substring(this.value);\n\t}\n\n\tget length(): TextLength {\n\t\treturn this._t.textLength;\n\t}\n}\n"],
  "mappings": "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",
  "names": ["r"]
}
