{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/core/lineRange.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport {\n\tfindFirstIdxMonotonousOrArrLen,\n\tfindLastIdxMonotonous,\n\tfindLastMonotonous,\n} from \"../../../base/common/arraysFind.js\";\nimport { BugIndicatingError } from \"../../../base/common/errors.js\";\nimport { OffsetRange } from \"./offsetRange.js\";\nimport { Range } from \"./range.js\";\n\n/**\n * A range of lines (1-based).\n */\nexport class LineRange {\n\tpublic static fromRange(range: Range): LineRange {\n\t\treturn new LineRange(range.startLineNumber, range.endLineNumber);\n\t}\n\n\tpublic static fromRangeInclusive(range: Range): LineRange {\n\t\treturn new LineRange(range.startLineNumber, range.endLineNumber + 1);\n\t}\n\n\tpublic static subtract(\n\t\ta: LineRange,\n\t\tb: LineRange | undefined,\n\t): LineRange[] {\n\t\tif (!b) {\n\t\t\treturn [a];\n\t\t}\n\t\tif (\n\t\t\ta.startLineNumber < b.startLineNumber &&\n\t\t\tb.endLineNumberExclusive < a.endLineNumberExclusive\n\t\t) {\n\t\t\treturn [\n\t\t\t\tnew LineRange(a.startLineNumber, b.startLineNumber),\n\t\t\t\tnew LineRange(\n\t\t\t\t\tb.endLineNumberExclusive,\n\t\t\t\t\ta.endLineNumberExclusive,\n\t\t\t\t),\n\t\t\t];\n\t\t} else if (\n\t\t\tb.startLineNumber <= a.startLineNumber &&\n\t\t\ta.endLineNumberExclusive <= b.endLineNumberExclusive\n\t\t) {\n\t\t\treturn [];\n\t\t} else if (b.endLineNumberExclusive < a.endLineNumberExclusive) {\n\t\t\treturn [\n\t\t\t\tnew LineRange(\n\t\t\t\t\tMath.max(b.endLineNumberExclusive, a.startLineNumber),\n\t\t\t\t\ta.endLineNumberExclusive,\n\t\t\t\t),\n\t\t\t];\n\t\t} else {\n\t\t\treturn [\n\t\t\t\tnew LineRange(\n\t\t\t\t\ta.startLineNumber,\n\t\t\t\t\tMath.min(b.startLineNumber, a.endLineNumberExclusive),\n\t\t\t\t),\n\t\t\t];\n\t\t}\n\t}\n\n\t/**\n\t * @param lineRanges An array of sorted line ranges.\n\t */\n\tpublic static joinMany(\n\t\tlineRanges: readonly (readonly LineRange[])[],\n\t): readonly LineRange[] {\n\t\tif (lineRanges.length === 0) {\n\t\t\treturn [];\n\t\t}\n\t\tlet result = new LineRangeSet(lineRanges[0].slice());\n\t\tfor (let i = 1; i < lineRanges.length; i++) {\n\t\t\tresult = result.getUnion(new LineRangeSet(lineRanges[i].slice()));\n\t\t}\n\t\treturn result.ranges;\n\t}\n\n\tpublic static join(lineRanges: LineRange[]): LineRange {\n\t\tif (lineRanges.length === 0) {\n\t\t\tthrow new BugIndicatingError(\"lineRanges cannot be empty\");\n\t\t}\n\t\tlet startLineNumber = lineRanges[0].startLineNumber;\n\t\tlet endLineNumberExclusive = lineRanges[0].endLineNumberExclusive;\n\t\tfor (let i = 1; i < lineRanges.length; i++) {\n\t\t\tstartLineNumber = Math.min(\n\t\t\t\tstartLineNumber,\n\t\t\t\tlineRanges[i].startLineNumber,\n\t\t\t);\n\t\t\tendLineNumberExclusive = Math.max(\n\t\t\t\tendLineNumberExclusive,\n\t\t\t\tlineRanges[i].endLineNumberExclusive,\n\t\t\t);\n\t\t}\n\t\treturn new LineRange(startLineNumber, endLineNumberExclusive);\n\t}\n\n\tpublic static ofLength(startLineNumber: number, length: number): LineRange {\n\t\treturn new LineRange(startLineNumber, startLineNumber + length);\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tpublic static deserialize(lineRange: ISerializedLineRange): LineRange {\n\t\treturn new LineRange(lineRange[0], lineRange[1]);\n\t}\n\n\t/**\n\t * The start line number.\n\t */\n\tpublic readonly startLineNumber: number;\n\n\t/**\n\t * The end line number (exclusive).\n\t */\n\tpublic readonly endLineNumberExclusive: number;\n\n\tconstructor(startLineNumber: number, endLineNumberExclusive: number) {\n\t\tif (startLineNumber > endLineNumberExclusive) {\n\t\t\tthrow new BugIndicatingError(\n\t\t\t\t`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`,\n\t\t\t);\n\t\t}\n\t\tthis.startLineNumber = startLineNumber;\n\t\tthis.endLineNumberExclusive = endLineNumberExclusive;\n\t}\n\n\t/**\n\t * Indicates if this line range contains the given line number.\n\t */\n\tpublic contains(lineNumber: number): boolean {\n\t\treturn (\n\t\t\tthis.startLineNumber <= lineNumber &&\n\t\t\tlineNumber < this.endLineNumberExclusive\n\t\t);\n\t}\n\n\t/**\n\t * Indicates if this line range is empty.\n\t */\n\tget isEmpty(): boolean {\n\t\treturn this.startLineNumber === this.endLineNumberExclusive;\n\t}\n\n\t/**\n\t * Moves this line range by the given offset of line numbers.\n\t */\n\tpublic delta(offset: number): LineRange {\n\t\treturn new LineRange(\n\t\t\tthis.startLineNumber + offset,\n\t\t\tthis.endLineNumberExclusive + offset,\n\t\t);\n\t}\n\n\tpublic deltaLength(offset: number): LineRange {\n\t\treturn new LineRange(\n\t\t\tthis.startLineNumber,\n\t\t\tthis.endLineNumberExclusive + offset,\n\t\t);\n\t}\n\n\t/**\n\t * The number of lines this line range spans.\n\t */\n\tpublic get length(): number {\n\t\treturn this.endLineNumberExclusive - this.startLineNumber;\n\t}\n\n\t/**\n\t * Creates a line range that combines this and the given line range.\n\t */\n\tpublic join(other: LineRange): LineRange {\n\t\treturn new LineRange(\n\t\t\tMath.min(this.startLineNumber, other.startLineNumber),\n\t\t\tMath.max(this.endLineNumberExclusive, other.endLineNumberExclusive),\n\t\t);\n\t}\n\n\tpublic toString(): string {\n\t\treturn `[${this.startLineNumber},${this.endLineNumberExclusive})`;\n\t}\n\n\t/**\n\t * The resulting range is empty if the ranges do not intersect, but touch.\n\t * If the ranges don't even touch, the result is undefined.\n\t */\n\tpublic intersect(other: LineRange): LineRange | undefined {\n\t\tconst startLineNumber = Math.max(\n\t\t\tthis.startLineNumber,\n\t\t\tother.startLineNumber,\n\t\t);\n\t\tconst endLineNumberExclusive = Math.min(\n\t\t\tthis.endLineNumberExclusive,\n\t\t\tother.endLineNumberExclusive,\n\t\t);\n\t\tif (startLineNumber <= endLineNumberExclusive) {\n\t\t\treturn new LineRange(startLineNumber, endLineNumberExclusive);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tpublic intersectsStrict(other: LineRange): boolean {\n\t\treturn (\n\t\t\tthis.startLineNumber < other.endLineNumberExclusive &&\n\t\t\tother.startLineNumber < this.endLineNumberExclusive\n\t\t);\n\t}\n\n\tpublic overlapOrTouch(other: LineRange): boolean {\n\t\treturn (\n\t\t\tthis.startLineNumber <= other.endLineNumberExclusive &&\n\t\t\tother.startLineNumber <= this.endLineNumberExclusive\n\t\t);\n\t}\n\n\tpublic equals(b: LineRange): boolean {\n\t\treturn (\n\t\t\tthis.startLineNumber === b.startLineNumber &&\n\t\t\tthis.endLineNumberExclusive === b.endLineNumberExclusive\n\t\t);\n\t}\n\n\tpublic toInclusiveRange(): Range | null {\n\t\tif (this.isEmpty) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new Range(\n\t\t\tthis.startLineNumber,\n\t\t\t1,\n\t\t\tthis.endLineNumberExclusive - 1,\n\t\t\tNumber.MAX_SAFE_INTEGER,\n\t\t);\n\t}\n\n\t/**\n\t * @deprecated Using this function is discouraged because it might lead to bugs: The end position is not guaranteed to be a valid position!\n\t */\n\tpublic toExclusiveRange(): Range {\n\t\treturn new Range(\n\t\t\tthis.startLineNumber,\n\t\t\t1,\n\t\t\tthis.endLineNumberExclusive,\n\t\t\t1,\n\t\t);\n\t}\n\n\tpublic mapToLineArray<T>(f: (lineNumber: number) => T): T[] {\n\t\tconst result: T[] = [];\n\t\tfor (\n\t\t\tlet lineNumber = this.startLineNumber;\n\t\t\tlineNumber < this.endLineNumberExclusive;\n\t\t\tlineNumber++\n\t\t) {\n\t\t\tresult.push(f(lineNumber));\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic forEach(f: (lineNumber: number) => void): void {\n\t\tfor (\n\t\t\tlet lineNumber = this.startLineNumber;\n\t\t\tlineNumber < this.endLineNumberExclusive;\n\t\t\tlineNumber++\n\t\t) {\n\t\t\tf(lineNumber);\n\t\t}\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tpublic serialize(): ISerializedLineRange {\n\t\treturn [this.startLineNumber, this.endLineNumberExclusive];\n\t}\n\n\tpublic includes(lineNumber: number): boolean {\n\t\treturn (\n\t\t\tthis.startLineNumber <= lineNumber &&\n\t\t\tlineNumber < this.endLineNumberExclusive\n\t\t);\n\t}\n\n\t/**\n\t * Converts this 1-based line range to a 0-based offset range (subtracts 1!).\n\t * @internal\n\t */\n\tpublic toOffsetRange(): OffsetRange {\n\t\treturn new OffsetRange(\n\t\t\tthis.startLineNumber - 1,\n\t\t\tthis.endLineNumberExclusive - 1,\n\t\t);\n\t}\n}\n\nexport type ISerializedLineRange = [\n\tstartLineNumber: number,\n\tendLineNumberExclusive: number,\n];\n\nexport class LineRangeSet {\n\tconstructor(\n\t\t/**\n\t\t * Sorted by start line number.\n\t\t * No two line ranges are touching or intersecting.\n\t\t */\n\t\tprivate readonly _normalizedRanges: LineRange[] = [],\n\t) {}\n\n\tget ranges(): readonly LineRange[] {\n\t\treturn this._normalizedRanges;\n\t}\n\n\taddRange(range: LineRange): void {\n\t\tif (range.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Idea: Find joinRange such that:\n\t\t// replaceRange = _normalizedRanges.replaceRange(joinRange, range.joinAll(joinRange.map(idx => this._normalizedRanges[idx])))\n\n\t\t// idx of first element that touches range or that is after range\n\t\tconst joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(\n\t\t\tthis._normalizedRanges,\n\t\t\t(r) => r.endLineNumberExclusive >= range.startLineNumber,\n\t\t);\n\t\t// idx of element after { last element that touches range or that is before range }\n\t\tconst joinRangeEndIdxExclusive =\n\t\t\tfindLastIdxMonotonous(\n\t\t\t\tthis._normalizedRanges,\n\t\t\t\t(r) => r.startLineNumber <= range.endLineNumberExclusive,\n\t\t\t) + 1;\n\n\t\tif (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n\t\t\t// If there is no element that touches range, then joinRangeStartIdx === joinRangeEndIdxExclusive and that value is the index of the element after range\n\t\t\tthis._normalizedRanges.splice(joinRangeStartIdx, 0, range);\n\t\t} else if (joinRangeStartIdx === joinRangeEndIdxExclusive - 1) {\n\t\t\t// Else, there is an element that touches range and in this case it is both the first and last element. Thus we can replace it\n\t\t\tconst joinRange = this._normalizedRanges[joinRangeStartIdx];\n\t\t\tthis._normalizedRanges[joinRangeStartIdx] = joinRange.join(range);\n\t\t} else {\n\t\t\t// First and last element are different - we need to replace the entire range\n\t\t\tconst joinRange = this._normalizedRanges[joinRangeStartIdx]\n\t\t\t\t.join(this._normalizedRanges[joinRangeEndIdxExclusive - 1])\n\t\t\t\t.join(range);\n\t\t\tthis._normalizedRanges.splice(\n\t\t\t\tjoinRangeStartIdx,\n\t\t\t\tjoinRangeEndIdxExclusive - joinRangeStartIdx,\n\t\t\t\tjoinRange,\n\t\t\t);\n\t\t}\n\t}\n\n\tcontains(lineNumber: number): boolean {\n\t\tconst rangeThatStartsBeforeEnd = findLastMonotonous(\n\t\t\tthis._normalizedRanges,\n\t\t\t(r) => r.startLineNumber <= lineNumber,\n\t\t);\n\t\treturn (\n\t\t\t!!rangeThatStartsBeforeEnd &&\n\t\t\trangeThatStartsBeforeEnd.endLineNumberExclusive > lineNumber\n\t\t);\n\t}\n\n\tintersects(range: LineRange): boolean {\n\t\tconst rangeThatStartsBeforeEnd = findLastMonotonous(\n\t\t\tthis._normalizedRanges,\n\t\t\t(r) => r.startLineNumber < range.endLineNumberExclusive,\n\t\t);\n\t\treturn (\n\t\t\t!!rangeThatStartsBeforeEnd &&\n\t\t\trangeThatStartsBeforeEnd.endLineNumberExclusive >\n\t\t\t\trange.startLineNumber\n\t\t);\n\t}\n\n\tgetUnion(other: LineRangeSet): LineRangeSet {\n\t\tif (this._normalizedRanges.length === 0) {\n\t\t\treturn other;\n\t\t}\n\t\tif (other._normalizedRanges.length === 0) {\n\t\t\treturn this;\n\t\t}\n\n\t\tconst result: LineRange[] = [];\n\t\tlet i1 = 0;\n\t\tlet i2 = 0;\n\t\tlet current: LineRange | null = null;\n\t\twhile (\n\t\t\ti1 < this._normalizedRanges.length ||\n\t\t\ti2 < other._normalizedRanges.length\n\t\t) {\n\t\t\tlet next: LineRange | null = null;\n\t\t\tif (\n\t\t\t\ti1 < this._normalizedRanges.length &&\n\t\t\t\ti2 < other._normalizedRanges.length\n\t\t\t) {\n\t\t\t\tconst lineRange1 = this._normalizedRanges[i1];\n\t\t\t\tconst lineRange2 = other._normalizedRanges[i2];\n\t\t\t\tif (lineRange1.startLineNumber < lineRange2.startLineNumber) {\n\t\t\t\t\tnext = lineRange1;\n\t\t\t\t\ti1++;\n\t\t\t\t} else {\n\t\t\t\t\tnext = lineRange2;\n\t\t\t\t\ti2++;\n\t\t\t\t}\n\t\t\t} else if (i1 < this._normalizedRanges.length) {\n\t\t\t\tnext = this._normalizedRanges[i1];\n\t\t\t\ti1++;\n\t\t\t} else {\n\t\t\t\tnext = other._normalizedRanges[i2];\n\t\t\t\ti2++;\n\t\t\t}\n\n\t\t\tif (current === null) {\n\t\t\t\tcurrent = next;\n\t\t\t} else if (current.endLineNumberExclusive >= next.startLineNumber) {\n\t\t\t\t// merge\n\t\t\t\tcurrent = new LineRange(\n\t\t\t\t\tcurrent.startLineNumber,\n\t\t\t\t\tMath.max(\n\t\t\t\t\t\tcurrent.endLineNumberExclusive,\n\t\t\t\t\t\tnext.endLineNumberExclusive,\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t// push\n\t\t\t\tresult.push(current);\n\t\t\t\tcurrent = next;\n\t\t\t}\n\t\t}\n\t\tif (current !== null) {\n\t\t\tresult.push(current);\n\t\t}\n\t\treturn new LineRangeSet(result);\n\t}\n\n\t/**\n\t * Subtracts all ranges in this set from `range` and returns the result.\n\t */\n\tsubtractFrom(range: LineRange): LineRangeSet {\n\t\t// idx of first element that touches range or that is after range\n\t\tconst joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(\n\t\t\tthis._normalizedRanges,\n\t\t\t(r) => r.endLineNumberExclusive >= range.startLineNumber,\n\t\t);\n\t\t// idx of element after { last element that touches range or that is before range }\n\t\tconst joinRangeEndIdxExclusive =\n\t\t\tfindLastIdxMonotonous(\n\t\t\t\tthis._normalizedRanges,\n\t\t\t\t(r) => r.startLineNumber <= range.endLineNumberExclusive,\n\t\t\t) + 1;\n\n\t\tif (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n\t\t\treturn new LineRangeSet([range]);\n\t\t}\n\n\t\tconst result: LineRange[] = [];\n\t\tlet startLineNumber = range.startLineNumber;\n\t\tfor (let i = joinRangeStartIdx; i < joinRangeEndIdxExclusive; i++) {\n\t\t\tconst r = this._normalizedRanges[i];\n\t\t\tif (r.startLineNumber > startLineNumber) {\n\t\t\t\tresult.push(new LineRange(startLineNumber, r.startLineNumber));\n\t\t\t}\n\t\t\tstartLineNumber = r.endLineNumberExclusive;\n\t\t}\n\t\tif (startLineNumber < range.endLineNumberExclusive) {\n\t\t\tresult.push(\n\t\t\t\tnew LineRange(startLineNumber, range.endLineNumberExclusive),\n\t\t\t);\n\t\t}\n\n\t\treturn new LineRangeSet(result);\n\t}\n\n\ttoString() {\n\t\treturn this._normalizedRanges.map((r) => r.toString()).join(\", \");\n\t}\n\n\tgetIntersection(other: LineRangeSet): LineRangeSet {\n\t\tconst result: LineRange[] = [];\n\n\t\tlet i1 = 0;\n\t\tlet i2 = 0;\n\t\twhile (\n\t\t\ti1 < this._normalizedRanges.length &&\n\t\t\ti2 < other._normalizedRanges.length\n\t\t) {\n\t\t\tconst r1 = this._normalizedRanges[i1];\n\t\t\tconst r2 = other._normalizedRanges[i2];\n\n\t\t\tconst i = r1.intersect(r2);\n\t\t\tif (i && !i.isEmpty) {\n\t\t\t\tresult.push(i);\n\t\t\t}\n\n\t\t\tif (r1.endLineNumberExclusive < r2.endLineNumberExclusive) {\n\t\t\t\ti1++;\n\t\t\t} else {\n\t\t\t\ti2++;\n\t\t\t}\n\t\t}\n\n\t\treturn new LineRangeSet(result);\n\t}\n\n\tgetWithDelta(value: number): LineRangeSet {\n\t\treturn new LineRangeSet(\n\t\t\tthis._normalizedRanges.map((r) => r.delta(value)),\n\t\t);\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
