{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/core/lineRange.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { OffsetRange } from './offsetRange.js';\nimport { Range } from './range.js';\nimport { findFirstIdxMonotonousOrArrLen, findLastIdxMonotonous, findLastMonotonous } from '../../../base/common/arraysFind.js';\n\n/**\n * A range of lines (1-based).\n */\nexport class LineRange {\n\tpublic static fromRange(range: Range): LineRange {\n\t\treturn new LineRange(range.startLineNumber, range.endLineNumber);\n\t}\n\n\tpublic static fromRangeInclusive(range: Range): LineRange {\n\t\treturn new LineRange(range.startLineNumber, range.endLineNumber + 1);\n\t}\n\n\tpublic static subtract(a: LineRange, b: LineRange | undefined): LineRange[] {\n\t\tif (!b) {\n\t\t\treturn [a];\n\t\t}\n\t\tif (a.startLineNumber < b.startLineNumber && b.endLineNumberExclusive < a.endLineNumberExclusive) {\n\t\t\treturn [\n\t\t\t\tnew LineRange(a.startLineNumber, b.startLineNumber),\n\t\t\t\tnew LineRange(b.endLineNumberExclusive, a.endLineNumberExclusive)\n\t\t\t];\n\t\t} else if (b.startLineNumber <= a.startLineNumber && a.endLineNumberExclusive <= b.endLineNumberExclusive) {\n\t\t\treturn [];\n\t\t} else if (b.endLineNumberExclusive < a.endLineNumberExclusive) {\n\t\t\treturn [new LineRange(Math.max(b.endLineNumberExclusive, a.startLineNumber), a.endLineNumberExclusive)];\n\t\t} else {\n\t\t\treturn [new LineRange(a.startLineNumber, Math.min(b.startLineNumber, a.endLineNumberExclusive))];\n\t\t}\n\t}\n\n\t/**\n\t * @param lineRanges An array of sorted line ranges.\n\t */\n\tpublic static joinMany(lineRanges: readonly (readonly LineRange[])[]): readonly LineRange[] {\n\t\tif (lineRanges.length === 0) {\n\t\t\treturn [];\n\t\t}\n\t\tlet result = new LineRangeSet(lineRanges[0].slice());\n\t\tfor (let i = 1; i < lineRanges.length; i++) {\n\t\t\tresult = result.getUnion(new LineRangeSet(lineRanges[i].slice()));\n\t\t}\n\t\treturn result.ranges;\n\t}\n\n\tpublic static join(lineRanges: LineRange[]): LineRange {\n\t\tif (lineRanges.length === 0) {\n\t\t\tthrow new BugIndicatingError('lineRanges cannot be empty');\n\t\t}\n\t\tlet startLineNumber = lineRanges[0].startLineNumber;\n\t\tlet endLineNumberExclusive = lineRanges[0].endLineNumberExclusive;\n\t\tfor (let i = 1; i < lineRanges.length; i++) {\n\t\t\tstartLineNumber = Math.min(startLineNumber, lineRanges[i].startLineNumber);\n\t\t\tendLineNumberExclusive = Math.max(endLineNumberExclusive, lineRanges[i].endLineNumberExclusive);\n\t\t}\n\t\treturn new LineRange(startLineNumber, endLineNumberExclusive);\n\t}\n\n\tpublic static ofLength(startLineNumber: number, length: number): LineRange {\n\t\treturn new LineRange(startLineNumber, startLineNumber + length);\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tpublic static deserialize(lineRange: ISerializedLineRange): LineRange {\n\t\treturn new LineRange(lineRange[0], lineRange[1]);\n\t}\n\n\t/**\n\t * The start line number.\n\t */\n\tpublic readonly startLineNumber: number;\n\n\t/**\n\t * The end line number (exclusive).\n\t */\n\tpublic readonly endLineNumberExclusive: number;\n\n\tconstructor(\n\t\tstartLineNumber: number,\n\t\tendLineNumberExclusive: number,\n\t) {\n\t\tif (startLineNumber > endLineNumberExclusive) {\n\t\t\tthrow new BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);\n\t\t}\n\t\tthis.startLineNumber = startLineNumber;\n\t\tthis.endLineNumberExclusive = endLineNumberExclusive;\n\t}\n\n\t/**\n\t * Indicates if this line range contains the given line number.\n\t */\n\tpublic contains(lineNumber: number): boolean {\n\t\treturn this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n\t}\n\n\t/**\n\t * Indicates if this line range is empty.\n\t */\n\tget isEmpty(): boolean {\n\t\treturn this.startLineNumber === this.endLineNumberExclusive;\n\t}\n\n\t/**\n\t * Moves this line range by the given offset of line numbers.\n\t */\n\tpublic delta(offset: number): LineRange {\n\t\treturn new LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);\n\t}\n\n\tpublic deltaLength(offset: number): LineRange {\n\t\treturn new LineRange(this.startLineNumber, this.endLineNumberExclusive + offset);\n\t}\n\n\t/**\n\t * The number of lines this line range spans.\n\t */\n\tpublic get length(): number {\n\t\treturn this.endLineNumberExclusive - this.startLineNumber;\n\t}\n\n\t/**\n\t * Creates a line range that combines this and the given line range.\n\t */\n\tpublic join(other: LineRange): LineRange {\n\t\treturn new LineRange(\n\t\t\tMath.min(this.startLineNumber, other.startLineNumber),\n\t\t\tMath.max(this.endLineNumberExclusive, other.endLineNumberExclusive)\n\t\t);\n\t}\n\n\tpublic toString(): string {\n\t\treturn `[${this.startLineNumber},${this.endLineNumberExclusive})`;\n\t}\n\n\t/**\n\t * The resulting range is empty if the ranges do not intersect, but touch.\n\t * If the ranges don't even touch, the result is undefined.\n\t */\n\tpublic intersect(other: LineRange): LineRange | undefined {\n\t\tconst startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);\n\t\tconst endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);\n\t\tif (startLineNumber <= endLineNumberExclusive) {\n\t\t\treturn new LineRange(startLineNumber, endLineNumberExclusive);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tpublic intersectsStrict(other: LineRange): boolean {\n\t\treturn this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;\n\t}\n\n\tpublic overlapOrTouch(other: LineRange): boolean {\n\t\treturn this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;\n\t}\n\n\tpublic equals(b: LineRange): boolean {\n\t\treturn this.startLineNumber === b.startLineNumber && this.endLineNumberExclusive === b.endLineNumberExclusive;\n\t}\n\n\tpublic toInclusiveRange(): Range | null {\n\t\tif (this.isEmpty) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);\n\t}\n\n\t/**\n\t * @deprecated Using this function is discouraged because it might lead to bugs: The end position is not guaranteed to be a valid position!\n\t*/\n\tpublic toExclusiveRange(): Range {\n\t\treturn new Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);\n\t}\n\n\tpublic mapToLineArray<T>(f: (lineNumber: number) => T): T[] {\n\t\tconst result: T[] = [];\n\t\tfor (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n\t\t\tresult.push(f(lineNumber));\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic forEach(f: (lineNumber: number) => void): void {\n\t\tfor (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n\t\t\tf(lineNumber);\n\t\t}\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tpublic serialize(): ISerializedLineRange {\n\t\treturn [this.startLineNumber, this.endLineNumberExclusive];\n\t}\n\n\tpublic includes(lineNumber: number): boolean {\n\t\treturn this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n\t}\n\n\t/**\n\t * Converts this 1-based line range to a 0-based offset range (subtracts 1!).\n\t * @internal\n\t */\n\tpublic toOffsetRange(): OffsetRange {\n\t\treturn new OffsetRange(this.startLineNumber - 1, this.endLineNumberExclusive - 1);\n\t}\n}\n\nexport type ISerializedLineRange = [startLineNumber: number, endLineNumberExclusive: number];\n\n\nexport class LineRangeSet {\n\tconstructor(\n\t\t/**\n\t\t * Sorted by start line number.\n\t\t * No two line ranges are touching or intersecting.\n\t\t */\n\t\tprivate readonly _normalizedRanges: LineRange[] = []\n\t) {\n\t}\n\n\tget ranges(): readonly LineRange[] {\n\t\treturn this._normalizedRanges;\n\t}\n\n\taddRange(range: LineRange): void {\n\t\tif (range.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Idea: Find joinRange such that:\n\t\t// replaceRange = _normalizedRanges.replaceRange(joinRange, range.joinAll(joinRange.map(idx => this._normalizedRanges[idx])))\n\n\t\t// idx of first element that touches range or that is after range\n\t\tconst joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n\t\t// idx of element after { last element that touches range or that is before range }\n\t\tconst joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n\n\t\tif (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n\t\t\t// If there is no element that touches range, then joinRangeStartIdx === joinRangeEndIdxExclusive and that value is the index of the element after range\n\t\t\tthis._normalizedRanges.splice(joinRangeStartIdx, 0, range);\n\t\t} else if (joinRangeStartIdx === joinRangeEndIdxExclusive - 1) {\n\t\t\t// Else, there is an element that touches range and in this case it is both the first and last element. Thus we can replace it\n\t\t\tconst joinRange = this._normalizedRanges[joinRangeStartIdx];\n\t\t\tthis._normalizedRanges[joinRangeStartIdx] = joinRange.join(range);\n\t\t} else {\n\t\t\t// First and last element are different - we need to replace the entire range\n\t\t\tconst joinRange = this._normalizedRanges[joinRangeStartIdx].join(this._normalizedRanges[joinRangeEndIdxExclusive - 1]).join(range);\n\t\t\tthis._normalizedRanges.splice(joinRangeStartIdx, joinRangeEndIdxExclusive - joinRangeStartIdx, joinRange);\n\t\t}\n\t}\n\n\tcontains(lineNumber: number): boolean {\n\t\tconst rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber <= lineNumber);\n\t\treturn !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > lineNumber;\n\t}\n\n\tintersects(range: LineRange): boolean {\n\t\tconst rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber < range.endLineNumberExclusive);\n\t\treturn !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > range.startLineNumber;\n\t}\n\n\tgetUnion(other: LineRangeSet): LineRangeSet {\n\t\tif (this._normalizedRanges.length === 0) {\n\t\t\treturn other;\n\t\t}\n\t\tif (other._normalizedRanges.length === 0) {\n\t\t\treturn this;\n\t\t}\n\n\t\tconst result: LineRange[] = [];\n\t\tlet i1 = 0;\n\t\tlet i2 = 0;\n\t\tlet current: LineRange | null = null;\n\t\twhile (i1 < this._normalizedRanges.length || i2 < other._normalizedRanges.length) {\n\t\t\tlet next: LineRange | null = null;\n\t\t\tif (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n\t\t\t\tconst lineRange1 = this._normalizedRanges[i1];\n\t\t\t\tconst lineRange2 = other._normalizedRanges[i2];\n\t\t\t\tif (lineRange1.startLineNumber < lineRange2.startLineNumber) {\n\t\t\t\t\tnext = lineRange1;\n\t\t\t\t\ti1++;\n\t\t\t\t} else {\n\t\t\t\t\tnext = lineRange2;\n\t\t\t\t\ti2++;\n\t\t\t\t}\n\t\t\t} else if (i1 < this._normalizedRanges.length) {\n\t\t\t\tnext = this._normalizedRanges[i1];\n\t\t\t\ti1++;\n\t\t\t} else {\n\t\t\t\tnext = other._normalizedRanges[i2];\n\t\t\t\ti2++;\n\t\t\t}\n\n\t\t\tif (current === null) {\n\t\t\t\tcurrent = next;\n\t\t\t} else {\n\t\t\t\tif (current.endLineNumberExclusive >= next.startLineNumber) {\n\t\t\t\t\t// merge\n\t\t\t\t\tcurrent = new LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive));\n\t\t\t\t} else {\n\t\t\t\t\t// push\n\t\t\t\t\tresult.push(current);\n\t\t\t\t\tcurrent = next;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (current !== null) {\n\t\t\tresult.push(current);\n\t\t}\n\t\treturn new LineRangeSet(result);\n\t}\n\n\t/**\n\t * Subtracts all ranges in this set from `range` and returns the result.\n\t */\n\tsubtractFrom(range: LineRange): LineRangeSet {\n\t\t// idx of first element that touches range or that is after range\n\t\tconst joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n\t\t// idx of element after { last element that touches range or that is before range }\n\t\tconst joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n\n\t\tif (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n\t\t\treturn new LineRangeSet([range]);\n\t\t}\n\n\t\tconst result: LineRange[] = [];\n\t\tlet startLineNumber = range.startLineNumber;\n\t\tfor (let i = joinRangeStartIdx; i < joinRangeEndIdxExclusive; i++) {\n\t\t\tconst r = this._normalizedRanges[i];\n\t\t\tif (r.startLineNumber > startLineNumber) {\n\t\t\t\tresult.push(new LineRange(startLineNumber, r.startLineNumber));\n\t\t\t}\n\t\t\tstartLineNumber = r.endLineNumberExclusive;\n\t\t}\n\t\tif (startLineNumber < range.endLineNumberExclusive) {\n\t\t\tresult.push(new LineRange(startLineNumber, range.endLineNumberExclusive));\n\t\t}\n\n\t\treturn new LineRangeSet(result);\n\t}\n\n\ttoString() {\n\t\treturn this._normalizedRanges.map(r => r.toString()).join(', ');\n\t}\n\n\tgetIntersection(other: LineRangeSet): LineRangeSet {\n\t\tconst result: LineRange[] = [];\n\n\t\tlet i1 = 0;\n\t\tlet i2 = 0;\n\t\twhile (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n\t\t\tconst r1 = this._normalizedRanges[i1];\n\t\t\tconst r2 = other._normalizedRanges[i2];\n\n\t\t\tconst i = r1.intersect(r2);\n\t\t\tif (i && !i.isEmpty) {\n\t\t\t\tresult.push(i);\n\t\t\t}\n\n\t\t\tif (r1.endLineNumberExclusive < r2.endLineNumberExclusive) {\n\t\t\t\ti1++;\n\t\t\t} else {\n\t\t\t\ti2++;\n\t\t\t}\n\t\t}\n\n\t\treturn new LineRangeSet(result);\n\t}\n\n\tgetWithDelta(value: number): LineRangeSet {\n\t\treturn new LineRangeSet(this._normalizedRanges.map(r => r.delta(value)));\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
