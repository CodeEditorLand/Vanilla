import{BugIndicatingError as x}from"../../../base/common/errors.js";import{OffsetRange as g}from"./offsetRange.js";class c{constructor(t){this.edits=t;let e=-1;for(const n of t){if(!(n.replaceRange.start>=e))throw new x(`Edits must be disjoint and sorted. Found ${n} after ${e}`);e=n.replaceRange.endExclusive}}static empty=new c([]);static fromJson(t){return new c(t.map(l.fromJson))}static replace(t,e){return new c([new l(t,e)])}static insert(t,e){return c.replace(g.emptyAt(t),e)}normalize(){const t=[];let e;for(const n of this.edits)n.newText.length===0&&n.replaceRange.length===0||(e&&e.replaceRange.endExclusive===n.replaceRange.start?e=new l(e.replaceRange.join(n.replaceRange),e.newText+n.newText):(e&&t.push(e),e=n));return e&&t.push(e),new c(t)}toString(){return`[${this.edits.map(e=>e.toString()).join(", ")}]`}apply(t){const e=[];let n=0;for(const r of this.edits)e.push(t.substring(n,r.replaceRange.start)),e.push(r.newText),n=r.replaceRange.endExclusive;return e.push(t.substring(n)),e.join("")}compose(t){return E(this,t)}inverse(t){const e=[];let n=0;for(const r of this.edits)e.push(new l(g.ofStartAndLength(r.replaceRange.start+n,r.newText.length),t.substring(r.replaceRange.start,r.replaceRange.endExclusive))),n+=r.newText.length-r.replaceRange.length;return new c(e)}getNewTextRanges(){const t=[];let e=0;for(const n of this.edits)t.push(g.ofStartAndLength(n.replaceRange.start+e,n.newText.length)),e+=n.newText.length-n.replaceRange.length;return t}get isEmpty(){return this.edits.length===0}tryRebase(t){const e=[];let n=0,r=0,s=0;for(;r<this.edits.length||n<t.edits.length;){const f=t.edits[n],a=this.edits[r];if(a)f?a.replaceRange.intersects(f.replaceRange)?r++:a.replaceRange.start<f.replaceRange.start?(e.push(new l(a.replaceRange.delta(s),a.newText)),r++):(n++,s+=f.newText.length-f.replaceRange.length):(e.push(new l(a.replaceRange.delta(s),a.newText)),r++);else break}return new c(e)}applyToOffset(t){let e=0;for(const n of this.edits)if(n.replaceRange.start<=t){if(t<n.replaceRange.endExclusive)return n.replaceRange.start+e;e+=n.newText.length-n.replaceRange.length}else break;return t+e}applyToOffsetRange(t){return new g(this.applyToOffset(t.start),this.applyToOffset(t.endExclusive))}applyInverseToOffset(t){let e=0;for(const n of this.edits){const r=n.newText.length;if(n.replaceRange.start<=t-e){if(t-e<n.replaceRange.start+r)return n.replaceRange.start;e+=r-n.replaceRange.length}else break}return t-e}}class l{constructor(t,e){this.replaceRange=t;this.newText=e}static fromJson(t){return new l(g.ofStartAndLength(t.pos,t.len),t.txt)}static insert(t,e){return new l(g.emptyAt(t),e)}toString(){return`${this.replaceRange} -> "${this.newText}"`}get isEmpty(){return this.newText.length===0&&this.replaceRange.length===0}}function E(p,t){if(p=p.normalize(),t=t.normalize(),p.isEmpty)return t;if(t.isEmpty)return p;const e=[...p.edits],n=[];let r=0;for(const s of t.edits){for(;;){const i=e[0];if(!i||i.replaceRange.start+r+i.newText.length>=s.replaceRange.start)break;e.shift(),n.push(i),r+=i.newText.length-i.replaceRange.length}const f=r;let a,o;for(;;){const i=e[0];if(!i||i.replaceRange.start+r>s.replaceRange.endExclusive)break;a||(a=i),o=i,e.shift(),r+=i.newText.length-i.replaceRange.length}if(a){let i="";const d=s.replaceRange.start-(a.replaceRange.start+f);d>0&&(i=a.newText.slice(0,d));const h=o.replaceRange.endExclusive+r-s.replaceRange.endExclusive;if(h>0){const u=new l(g.ofStartAndLength(o.replaceRange.endExclusive,0),o.newText.slice(-h));e.unshift(u),r-=u.newText.length-u.replaceRange.length}const R=i+s.newText,w=new g(Math.min(a.replaceRange.start,s.replaceRange.start-f),s.replaceRange.endExclusive-r);n.push(new l(w,R))}else n.push(new l(s.replaceRange.delta(-r),s.newText))}for(;;){const s=e.shift();if(!s)break;n.push(s)}return new c(n).normalize()}export{c as OffsetEdit,l as SingleOffsetEdit};
