{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/core/offsetEdit.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { OffsetRange } from './offsetRange.js';\n\n/**\n * Describes an edit to a (0-based) string.\n * Use `TextEdit` to describe edits for a 1-based line/column text.\n*/\nexport class OffsetEdit {\n\tpublic static readonly empty = new OffsetEdit([]);\n\n\tpublic static fromJson(data: IOffsetEdit): OffsetEdit {\n\t\treturn new OffsetEdit(data.map(SingleOffsetEdit.fromJson));\n\t}\n\n\tpublic static replace(\n\t\trange: OffsetRange,\n\t\tnewText: string,\n\t): OffsetEdit {\n\t\treturn new OffsetEdit([new SingleOffsetEdit(range, newText)]);\n\t}\n\n\tpublic static insert(\n\t\toffset: number,\n\t\tinsertText: string,\n\t): OffsetEdit {\n\t\treturn OffsetEdit.replace(OffsetRange.emptyAt(offset), insertText);\n\t}\n\n\tconstructor(\n\t\tpublic readonly edits: readonly SingleOffsetEdit[],\n\t) {\n\t\tlet lastEndEx = -1;\n\t\tfor (const edit of edits) {\n\t\t\tif (!(edit.replaceRange.start >= lastEndEx)) {\n\t\t\t\tthrow new BugIndicatingError(`Edits must be disjoint and sorted. Found ${edit} after ${lastEndEx}`);\n\t\t\t}\n\t\t\tlastEndEx = edit.replaceRange.endExclusive;\n\t\t}\n\t}\n\n\tnormalize(): OffsetEdit {\n\t\tconst edits: SingleOffsetEdit[] = [];\n\t\tlet lastEdit: SingleOffsetEdit | undefined;\n\t\tfor (const edit of this.edits) {\n\t\t\tif (edit.newText.length === 0 && edit.replaceRange.length === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (lastEdit && lastEdit.replaceRange.endExclusive === edit.replaceRange.start) {\n\t\t\t\tlastEdit = new SingleOffsetEdit(\n\t\t\t\t\tlastEdit.replaceRange.join(edit.replaceRange),\n\t\t\t\t\tlastEdit.newText + edit.newText,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tif (lastEdit) {\n\t\t\t\t\tedits.push(lastEdit);\n\t\t\t\t}\n\t\t\t\tlastEdit = edit;\n\t\t\t}\n\t\t}\n\t\tif (lastEdit) {\n\t\t\tedits.push(lastEdit);\n\t\t}\n\t\treturn new OffsetEdit(edits);\n\t}\n\n\ttoString() {\n\t\tconst edits = this.edits.map(e => e.toString()).join(', ');\n\t\treturn `[${edits}]`;\n\t}\n\n\tapply(str: string): string {\n\t\tconst resultText: string[] = [];\n\t\tlet pos = 0;\n\t\tfor (const edit of this.edits) {\n\t\t\tresultText.push(str.substring(pos, edit.replaceRange.start));\n\t\t\tresultText.push(edit.newText);\n\t\t\tpos = edit.replaceRange.endExclusive;\n\t\t}\n\t\tresultText.push(str.substring(pos));\n\t\treturn resultText.join('');\n\t}\n\n\tcompose(other: OffsetEdit): OffsetEdit {\n\t\treturn joinEdits(this, other);\n\t}\n\n\t/**\n\t * Creates an edit that reverts this edit.\n\t */\n\tinverse(originalStr: string): OffsetEdit {\n\t\tconst edits: SingleOffsetEdit[] = [];\n\t\tlet offset = 0;\n\t\tfor (const e of this.edits) {\n\t\t\tedits.push(new SingleOffsetEdit(\n\t\t\t\tOffsetRange.ofStartAndLength(e.replaceRange.start + offset, e.newText.length),\n\t\t\t\toriginalStr.substring(e.replaceRange.start, e.replaceRange.endExclusive),\n\t\t\t));\n\t\t\toffset += e.newText.length - e.replaceRange.length;\n\t\t}\n\t\treturn new OffsetEdit(edits);\n\t}\n\n\tgetNewTextRanges(): OffsetRange[] {\n\t\tconst ranges: OffsetRange[] = [];\n\t\tlet offset = 0;\n\t\tfor (const e of this.edits) {\n\t\t\tranges.push(OffsetRange.ofStartAndLength(e.replaceRange.start + offset, e.newText.length),);\n\t\t\toffset += e.newText.length - e.replaceRange.length;\n\t\t}\n\t\treturn ranges;\n\t}\n\n\tget isEmpty(): boolean {\n\t\treturn this.edits.length === 0;\n\t}\n\n\t/**\n\t * Consider `t1 := text o base` and `t2 := text o this`.\n\t * We are interested in `tm := tryMerge(t1, t2, base: text)`.\n\t * For that, we compute `tm' := t1 o base o this.rebase(base)`\n\t * such that `tm' === tm`.\n\t */\n\ttryRebase(base: OffsetEdit): OffsetEdit {\n\t\tconst newEdits: SingleOffsetEdit[] = [];\n\n\t\tlet baseIdx = 0;\n\t\tlet ourIdx = 0;\n\t\tlet offset = 0;\n\n\t\twhile (ourIdx < this.edits.length || baseIdx < base.edits.length) {\n\t\t\t// take the edit that starts first\n\t\t\tconst baseEdit = base.edits[baseIdx];\n\t\t\tconst ourEdit = this.edits[ourIdx];\n\n\t\t\tif (!ourEdit) {\n\t\t\t\t// We processed all our edits\n\t\t\t\tbreak;\n\t\t\t} else if (!baseEdit) {\n\t\t\t\t// no more edits from base\n\t\t\t\tnewEdits.push(new SingleOffsetEdit(\n\t\t\t\t\tourEdit.replaceRange.delta(offset),\n\t\t\t\t\tourEdit.newText,\n\t\t\t\t));\n\t\t\t\tourIdx++;\n\t\t\t} else if (ourEdit.replaceRange.intersects(baseEdit.replaceRange)) {\n\t\t\t\tourIdx++; // Don't take our edit, as it is conflicting -> skip\n\t\t\t} else if (ourEdit.replaceRange.start < baseEdit.replaceRange.start) {\n\t\t\t\t// Our edit starts first\n\t\t\t\tnewEdits.push(new SingleOffsetEdit(\n\t\t\t\t\tourEdit.replaceRange.delta(offset),\n\t\t\t\t\tourEdit.newText,\n\t\t\t\t));\n\t\t\t\tourIdx++;\n\t\t\t} else {\n\t\t\t\tbaseIdx++;\n\t\t\t\toffset += baseEdit.newText.length - baseEdit.replaceRange.length;\n\t\t\t}\n\t\t}\n\n\t\treturn new OffsetEdit(newEdits);\n\t}\n\n\tapplyToOffset(originalOffset: number): number {\n\t\tlet accumulatedDelta = 0;\n\t\tfor (const edit of this.edits) {\n\t\t\tif (edit.replaceRange.start <= originalOffset) {\n\t\t\t\tif (originalOffset < edit.replaceRange.endExclusive) {\n\t\t\t\t\t// the offset is in the replaced range\n\t\t\t\t\treturn edit.replaceRange.start + accumulatedDelta;\n\t\t\t\t}\n\t\t\t\taccumulatedDelta += edit.newText.length - edit.replaceRange.length;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn originalOffset + accumulatedDelta;\n\t}\n\n\tapplyToOffsetRange(originalRange: OffsetRange): OffsetRange {\n\t\treturn new OffsetRange(\n\t\t\tthis.applyToOffset(originalRange.start),\n\t\t\tthis.applyToOffset(originalRange.endExclusive)\n\t\t);\n\t}\n\n\tapplyInverseToOffset(postEditsOffset: number): number {\n\t\tlet accumulatedDelta = 0;\n\t\tfor (const edit of this.edits) {\n\t\t\tconst editLength = edit.newText.length;\n\t\t\tif (edit.replaceRange.start <= postEditsOffset - accumulatedDelta) {\n\t\t\t\tif (postEditsOffset - accumulatedDelta < edit.replaceRange.start + editLength) {\n\t\t\t\t\t// the offset is in the replaced range\n\t\t\t\t\treturn edit.replaceRange.start;\n\t\t\t\t}\n\t\t\t\taccumulatedDelta += editLength - edit.replaceRange.length;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn postEditsOffset - accumulatedDelta;\n\t}\n}\n\nexport type IOffsetEdit = ISingleOffsetEdit[];\n\nexport interface ISingleOffsetEdit {\n\ttxt: string;\n\tpos: number;\n\tlen: number;\n}\n\nexport class SingleOffsetEdit {\n\tpublic static fromJson(data: ISingleOffsetEdit): SingleOffsetEdit {\n\t\treturn new SingleOffsetEdit(OffsetRange.ofStartAndLength(data.pos, data.len), data.txt);\n\t}\n\n\tpublic static insert(offset: number, text: string): SingleOffsetEdit {\n\t\treturn new SingleOffsetEdit(OffsetRange.emptyAt(offset), text);\n\t}\n\n\tconstructor(\n\t\tpublic readonly replaceRange: OffsetRange,\n\t\tpublic readonly newText: string,\n\t) { }\n\n\ttoString(): string {\n\t\treturn `${this.replaceRange} -> \"${this.newText}\"`;\n\t}\n\n\tget isEmpty() {\n\t\treturn this.newText.length === 0 && this.replaceRange.length === 0;\n\t}\n}\n\n/**\n * Invariant:\n * ```\n * edits2.apply(edits1.apply(str)) = join(edits1, edits2).apply(str)\n * ```\n */\nfunction joinEdits(edits1: OffsetEdit, edits2: OffsetEdit): OffsetEdit {\n\tedits1 = edits1.normalize();\n\tedits2 = edits2.normalize();\n\n\tif (edits1.isEmpty) { return edits2; }\n\tif (edits2.isEmpty) { return edits1; }\n\n\tconst edit1Queue = [...edits1.edits];\n\tconst result: SingleOffsetEdit[] = [];\n\n\tlet edit1ToEdit2 = 0;\n\n\tfor (const edit2 of edits2.edits) {\n\t\t// Copy over edit1 unmodified until it touches edit2.\n\t\twhile (true) {\n\t\t\tconst edit1 = edit1Queue[0]!;\n\t\t\tif (!edit1 || edit1.replaceRange.start + edit1ToEdit2 + edit1.newText.length >= edit2.replaceRange.start) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tedit1Queue.shift();\n\n\t\t\tresult.push(edit1);\n\t\t\tedit1ToEdit2 += edit1.newText.length - edit1.replaceRange.length;\n\t\t}\n\n\t\tconst firstEdit1ToEdit2 = edit1ToEdit2;\n\t\tlet firstIntersecting: SingleOffsetEdit | undefined; // or touching\n\t\tlet lastIntersecting: SingleOffsetEdit | undefined; // or touching\n\n\t\twhile (true) {\n\t\t\tconst edit1 = edit1Queue[0];\n\t\t\tif (!edit1 || edit1.replaceRange.start + edit1ToEdit2 > edit2.replaceRange.endExclusive) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// else we intersect, because the new end of edit1 is after or equal to our start\n\n\t\t\tif (!firstIntersecting) {\n\t\t\t\tfirstIntersecting = edit1;\n\t\t\t}\n\t\t\tlastIntersecting = edit1;\n\t\t\tedit1Queue.shift();\n\n\t\t\tedit1ToEdit2 += edit1.newText.length - edit1.replaceRange.length;\n\t\t}\n\n\t\tif (!firstIntersecting) {\n\t\t\tresult.push(new SingleOffsetEdit(edit2.replaceRange.delta(-edit1ToEdit2), edit2.newText));\n\t\t} else {\n\t\t\tlet prefix = '';\n\t\t\tconst prefixLength = edit2.replaceRange.start - (firstIntersecting.replaceRange.start + firstEdit1ToEdit2);\n\t\t\tif (prefixLength > 0) {\n\t\t\t\tprefix = firstIntersecting.newText.slice(0, prefixLength);\n\t\t\t}\n\t\t\tconst suffixLength = (lastIntersecting!.replaceRange.endExclusive + edit1ToEdit2) - edit2.replaceRange.endExclusive;\n\t\t\tif (suffixLength > 0) {\n\t\t\t\tconst e = new SingleOffsetEdit(OffsetRange.ofStartAndLength(lastIntersecting!.replaceRange.endExclusive, 0), lastIntersecting!.newText.slice(-suffixLength));\n\t\t\t\tedit1Queue.unshift(e);\n\t\t\t\tedit1ToEdit2 -= e.newText.length - e.replaceRange.length;\n\t\t\t}\n\t\t\tconst newText = prefix + edit2.newText;\n\n\t\t\tconst newReplaceRange = new OffsetRange(\n\t\t\t\tMath.min(firstIntersecting.replaceRange.start, edit2.replaceRange.start - firstEdit1ToEdit2),\n\t\t\t\tedit2.replaceRange.endExclusive - edit1ToEdit2\n\t\t\t);\n\t\t\tresult.push(new SingleOffsetEdit(newReplaceRange, newText));\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tconst item = edit1Queue.shift();\n\t\tif (!item) { break; }\n\t\tresult.push(item);\n\t}\n\n\treturn new OffsetEdit(result).normalize();\n}\n"],
  "mappings": "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",
  "names": []
}
