{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/core/offsetEdit.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from \"../../../base/common/errors.js\";\nimport { OffsetRange } from \"./offsetRange.js\";\n\n/**\n * Describes an edit to a (0-based) string.\n * Use `TextEdit` to describe edits for a 1-based line/column text.\n */\nexport class OffsetEdit {\n\tpublic static readonly empty = new OffsetEdit([]);\n\n\tpublic static fromJson(data: IOffsetEdit): OffsetEdit {\n\t\treturn new OffsetEdit(data.map(SingleOffsetEdit.fromJson));\n\t}\n\n\tpublic static replace(range: OffsetRange, newText: string): OffsetEdit {\n\t\treturn new OffsetEdit([new SingleOffsetEdit(range, newText)]);\n\t}\n\n\tpublic static insert(offset: number, insertText: string): OffsetEdit {\n\t\treturn OffsetEdit.replace(OffsetRange.emptyAt(offset), insertText);\n\t}\n\n\tconstructor(public readonly edits: readonly SingleOffsetEdit[]) {\n\t\tlet lastEndEx = -1;\n\t\tfor (const edit of edits) {\n\t\t\tif (!(edit.replaceRange.start >= lastEndEx)) {\n\t\t\t\tthrow new BugIndicatingError(\n\t\t\t\t\t`Edits must be disjoint and sorted. Found ${edit} after ${lastEndEx}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\tlastEndEx = edit.replaceRange.endExclusive;\n\t\t}\n\t}\n\n\tnormalize(): OffsetEdit {\n\t\tconst edits: SingleOffsetEdit[] = [];\n\t\tlet lastEdit: SingleOffsetEdit | undefined;\n\t\tfor (const edit of this.edits) {\n\t\t\tif (edit.newText.length === 0 && edit.replaceRange.length === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (\n\t\t\t\tlastEdit &&\n\t\t\t\tlastEdit.replaceRange.endExclusive === edit.replaceRange.start\n\t\t\t) {\n\t\t\t\tlastEdit = new SingleOffsetEdit(\n\t\t\t\t\tlastEdit.replaceRange.join(edit.replaceRange),\n\t\t\t\t\tlastEdit.newText + edit.newText,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tif (lastEdit) {\n\t\t\t\t\tedits.push(lastEdit);\n\t\t\t\t}\n\t\t\t\tlastEdit = edit;\n\t\t\t}\n\t\t}\n\t\tif (lastEdit) {\n\t\t\tedits.push(lastEdit);\n\t\t}\n\t\treturn new OffsetEdit(edits);\n\t}\n\n\ttoString() {\n\t\tconst edits = this.edits.map((e) => e.toString()).join(\", \");\n\t\treturn `[${edits}]`;\n\t}\n\n\tapply(str: string): string {\n\t\tconst resultText: string[] = [];\n\t\tlet pos = 0;\n\t\tfor (const edit of this.edits) {\n\t\t\tresultText.push(str.substring(pos, edit.replaceRange.start));\n\t\t\tresultText.push(edit.newText);\n\t\t\tpos = edit.replaceRange.endExclusive;\n\t\t}\n\t\tresultText.push(str.substring(pos));\n\t\treturn resultText.join(\"\");\n\t}\n\n\tcompose(other: OffsetEdit): OffsetEdit {\n\t\treturn joinEdits(this, other);\n\t}\n\n\t/**\n\t * Creates an edit that reverts this edit.\n\t */\n\tinverse(originalStr: string): OffsetEdit {\n\t\tconst edits: SingleOffsetEdit[] = [];\n\t\tlet offset = 0;\n\t\tfor (const e of this.edits) {\n\t\t\tedits.push(\n\t\t\t\tnew SingleOffsetEdit(\n\t\t\t\t\tOffsetRange.ofStartAndLength(\n\t\t\t\t\t\te.replaceRange.start + offset,\n\t\t\t\t\t\te.newText.length,\n\t\t\t\t\t),\n\t\t\t\t\toriginalStr.substring(\n\t\t\t\t\t\te.replaceRange.start,\n\t\t\t\t\t\te.replaceRange.endExclusive,\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t);\n\t\t\toffset += e.newText.length - e.replaceRange.length;\n\t\t}\n\t\treturn new OffsetEdit(edits);\n\t}\n\n\tgetNewTextRanges(): OffsetRange[] {\n\t\tconst ranges: OffsetRange[] = [];\n\t\tlet offset = 0;\n\t\tfor (const e of this.edits) {\n\t\t\tranges.push(\n\t\t\t\tOffsetRange.ofStartAndLength(\n\t\t\t\t\te.replaceRange.start + offset,\n\t\t\t\t\te.newText.length,\n\t\t\t\t),\n\t\t\t);\n\t\t\toffset += e.newText.length - e.replaceRange.length;\n\t\t}\n\t\treturn ranges;\n\t}\n\n\tget isEmpty(): boolean {\n\t\treturn this.edits.length === 0;\n\t}\n\n\t/**\n\t * Consider `t1 := text o base` and `t2 := text o this`.\n\t * We are interested in `tm := tryMerge(t1, t2, base: text)`.\n\t * For that, we compute `tm' := t1 o base o this.rebase(base)`\n\t * such that `tm' === tm`.\n\t */\n\ttryRebase(base: OffsetEdit): OffsetEdit {\n\t\tconst newEdits: SingleOffsetEdit[] = [];\n\n\t\tlet baseIdx = 0;\n\t\tlet ourIdx = 0;\n\t\tlet offset = 0;\n\n\t\twhile (ourIdx < this.edits.length || baseIdx < base.edits.length) {\n\t\t\t// take the edit that starts first\n\t\t\tconst baseEdit = base.edits[baseIdx];\n\t\t\tconst ourEdit = this.edits[ourIdx];\n\n\t\t\tif (!ourEdit) {\n\t\t\t\t// We processed all our edits\n\t\t\t\tbreak;\n\t\t\t} else if (!baseEdit) {\n\t\t\t\t// no more edits from base\n\t\t\t\tnewEdits.push(\n\t\t\t\t\tnew SingleOffsetEdit(\n\t\t\t\t\t\tourEdit.replaceRange.delta(offset),\n\t\t\t\t\t\tourEdit.newText,\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t\tourIdx++;\n\t\t\t} else if (ourEdit.replaceRange.intersects(baseEdit.replaceRange)) {\n\t\t\t\tourIdx++; // Don't take our edit, as it is conflicting -> skip\n\t\t\t} else if (\n\t\t\t\tourEdit.replaceRange.start < baseEdit.replaceRange.start\n\t\t\t) {\n\t\t\t\t// Our edit starts first\n\t\t\t\tnewEdits.push(\n\t\t\t\t\tnew SingleOffsetEdit(\n\t\t\t\t\t\tourEdit.replaceRange.delta(offset),\n\t\t\t\t\t\tourEdit.newText,\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t\tourIdx++;\n\t\t\t} else {\n\t\t\t\tbaseIdx++;\n\t\t\t\toffset +=\n\t\t\t\t\tbaseEdit.newText.length - baseEdit.replaceRange.length;\n\t\t\t}\n\t\t}\n\n\t\treturn new OffsetEdit(newEdits);\n\t}\n\n\tapplyToOffset(originalOffset: number): number {\n\t\tlet accumulatedDelta = 0;\n\t\tfor (const edit of this.edits) {\n\t\t\tif (edit.replaceRange.start <= originalOffset) {\n\t\t\t\tif (originalOffset < edit.replaceRange.endExclusive) {\n\t\t\t\t\t// the offset is in the replaced range\n\t\t\t\t\treturn edit.replaceRange.start + accumulatedDelta;\n\t\t\t\t}\n\t\t\t\taccumulatedDelta +=\n\t\t\t\t\tedit.newText.length - edit.replaceRange.length;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn originalOffset + accumulatedDelta;\n\t}\n\n\tapplyToOffsetRange(originalRange: OffsetRange): OffsetRange {\n\t\treturn new OffsetRange(\n\t\t\tthis.applyToOffset(originalRange.start),\n\t\t\tthis.applyToOffset(originalRange.endExclusive),\n\t\t);\n\t}\n\n\tapplyInverseToOffset(postEditsOffset: number): number {\n\t\tlet accumulatedDelta = 0;\n\t\tfor (const edit of this.edits) {\n\t\t\tconst editLength = edit.newText.length;\n\t\t\tif (edit.replaceRange.start <= postEditsOffset - accumulatedDelta) {\n\t\t\t\tif (\n\t\t\t\t\tpostEditsOffset - accumulatedDelta <\n\t\t\t\t\tedit.replaceRange.start + editLength\n\t\t\t\t) {\n\t\t\t\t\t// the offset is in the replaced range\n\t\t\t\t\treturn edit.replaceRange.start;\n\t\t\t\t}\n\t\t\t\taccumulatedDelta += editLength - edit.replaceRange.length;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn postEditsOffset - accumulatedDelta;\n\t}\n}\n\nexport type IOffsetEdit = ISingleOffsetEdit[];\n\nexport interface ISingleOffsetEdit {\n\ttxt: string;\n\tpos: number;\n\tlen: number;\n}\n\nexport class SingleOffsetEdit {\n\tpublic static fromJson(data: ISingleOffsetEdit): SingleOffsetEdit {\n\t\treturn new SingleOffsetEdit(\n\t\t\tOffsetRange.ofStartAndLength(data.pos, data.len),\n\t\t\tdata.txt,\n\t\t);\n\t}\n\n\tpublic static insert(offset: number, text: string): SingleOffsetEdit {\n\t\treturn new SingleOffsetEdit(OffsetRange.emptyAt(offset), text);\n\t}\n\n\tconstructor(\n\t\tpublic readonly replaceRange: OffsetRange,\n\t\tpublic readonly newText: string,\n\t) {}\n\n\ttoString(): string {\n\t\treturn `${this.replaceRange} -> \"${this.newText}\"`;\n\t}\n\n\tget isEmpty() {\n\t\treturn this.newText.length === 0 && this.replaceRange.length === 0;\n\t}\n}\n\n/**\n * Invariant:\n * ```\n * edits2.apply(edits1.apply(str)) = join(edits1, edits2).apply(str)\n * ```\n */\nfunction joinEdits(edits1: OffsetEdit, edits2: OffsetEdit): OffsetEdit {\n\tedits1 = edits1.normalize();\n\tedits2 = edits2.normalize();\n\n\tif (edits1.isEmpty) {\n\t\treturn edits2;\n\t}\n\tif (edits2.isEmpty) {\n\t\treturn edits1;\n\t}\n\n\tconst edit1Queue = [...edits1.edits];\n\tconst result: SingleOffsetEdit[] = [];\n\n\tlet edit1ToEdit2 = 0;\n\n\tfor (const edit2 of edits2.edits) {\n\t\t// Copy over edit1 unmodified until it touches edit2.\n\t\twhile (true) {\n\t\t\tconst edit1 = edit1Queue[0]!;\n\t\t\tif (\n\t\t\t\t!edit1 ||\n\t\t\t\tedit1.replaceRange.start +\n\t\t\t\t\tedit1ToEdit2 +\n\t\t\t\t\tedit1.newText.length >=\n\t\t\t\t\tedit2.replaceRange.start\n\t\t\t) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tedit1Queue.shift();\n\n\t\t\tresult.push(edit1);\n\t\t\tedit1ToEdit2 += edit1.newText.length - edit1.replaceRange.length;\n\t\t}\n\n\t\tconst firstEdit1ToEdit2 = edit1ToEdit2;\n\t\tlet firstIntersecting: SingleOffsetEdit | undefined; // or touching\n\t\tlet lastIntersecting: SingleOffsetEdit | undefined; // or touching\n\n\t\twhile (true) {\n\t\t\tconst edit1 = edit1Queue[0];\n\t\t\tif (\n\t\t\t\t!edit1 ||\n\t\t\t\tedit1.replaceRange.start + edit1ToEdit2 >\n\t\t\t\t\tedit2.replaceRange.endExclusive\n\t\t\t) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// else we intersect, because the new end of edit1 is after or equal to our start\n\n\t\t\tif (!firstIntersecting) {\n\t\t\t\tfirstIntersecting = edit1;\n\t\t\t}\n\t\t\tlastIntersecting = edit1;\n\t\t\tedit1Queue.shift();\n\n\t\t\tedit1ToEdit2 += edit1.newText.length - edit1.replaceRange.length;\n\t\t}\n\n\t\tif (firstIntersecting) {\n\t\t\tlet prefix = \"\";\n\t\t\tconst prefixLength =\n\t\t\t\tedit2.replaceRange.start -\n\t\t\t\t(firstIntersecting.replaceRange.start + firstEdit1ToEdit2);\n\t\t\tif (prefixLength > 0) {\n\t\t\t\tprefix = firstIntersecting.newText.slice(0, prefixLength);\n\t\t\t}\n\t\t\tconst suffixLength =\n\t\t\t\tlastIntersecting!.replaceRange.endExclusive +\n\t\t\t\tedit1ToEdit2 -\n\t\t\t\tedit2.replaceRange.endExclusive;\n\t\t\tif (suffixLength > 0) {\n\t\t\t\tconst e = new SingleOffsetEdit(\n\t\t\t\t\tOffsetRange.ofStartAndLength(\n\t\t\t\t\t\tlastIntersecting!.replaceRange.endExclusive,\n\t\t\t\t\t\t0,\n\t\t\t\t\t),\n\t\t\t\t\tlastIntersecting!.newText.slice(-suffixLength),\n\t\t\t\t);\n\t\t\t\tedit1Queue.unshift(e);\n\t\t\t\tedit1ToEdit2 -= e.newText.length - e.replaceRange.length;\n\t\t\t}\n\t\t\tconst newText = prefix + edit2.newText;\n\n\t\t\tconst newReplaceRange = new OffsetRange(\n\t\t\t\tMath.min(\n\t\t\t\t\tfirstIntersecting.replaceRange.start,\n\t\t\t\t\tedit2.replaceRange.start - firstEdit1ToEdit2,\n\t\t\t\t),\n\t\t\t\tedit2.replaceRange.endExclusive - edit1ToEdit2,\n\t\t\t);\n\t\t\tresult.push(new SingleOffsetEdit(newReplaceRange, newText));\n\t\t} else {\n\t\t\tresult.push(\n\t\t\t\tnew SingleOffsetEdit(\n\t\t\t\t\tedit2.replaceRange.delta(-edit1ToEdit2),\n\t\t\t\t\tedit2.newText,\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tconst item = edit1Queue.shift();\n\t\tif (!item) {\n\t\t\tbreak;\n\t\t}\n\t\tresult.push(item);\n\t}\n\n\treturn new OffsetEdit(result).normalize();\n}\n"],
  "mappings": ";;AAKA,SAAS,0BAA0B;AACnC,SAAS,mBAAmB;AAMrB,MAAM,WAAW;AAAA,EAevB,YAA4B,OAAoC;AAApC;AAC3B,QAAI,YAAY;AAChB,eAAW,QAAQ,OAAO;AACzB,UAAI,EAAE,KAAK,aAAa,SAAS,YAAY;AAC5C,cAAM,IAAI;AAAA,UACT,4CAA4C,IAAI,UAAU,SAAS;AAAA,QACpE;AAAA,MACD;AACA,kBAAY,KAAK,aAAa;AAAA,IAC/B;AAAA,EACD;AAAA,EArCD,OAYwB;AAAA;AAAA;AAAA,EACvB,OAAuB,QAAQ,IAAI,WAAW,CAAC,CAAC;AAAA,EAEhD,OAAc,SAAS,MAA+B;AACrD,WAAO,IAAI,WAAW,KAAK,IAAI,iBAAiB,QAAQ,CAAC;AAAA,EAC1D;AAAA,EAEA,OAAc,QAAQ,OAAoB,SAA6B;AACtE,WAAO,IAAI,WAAW,CAAC,IAAI,iBAAiB,OAAO,OAAO,CAAC,CAAC;AAAA,EAC7D;AAAA,EAEA,OAAc,OAAO,QAAgB,YAAgC;AACpE,WAAO,WAAW,QAAQ,YAAY,QAAQ,MAAM,GAAG,UAAU;AAAA,EAClE;AAAA,EAcA,YAAwB;AACvB,UAAM,QAA4B,CAAC;AACnC,QAAI;AACJ,eAAW,QAAQ,KAAK,OAAO;AAC9B,UAAI,KAAK,QAAQ,WAAW,KAAK,KAAK,aAAa,WAAW,GAAG;AAChE;AAAA,MACD;AACA,UACC,YACA,SAAS,aAAa,iBAAiB,KAAK,aAAa,OACxD;AACD,mBAAW,IAAI;AAAA,UACd,SAAS,aAAa,KAAK,KAAK,YAAY;AAAA,UAC5C,SAAS,UAAU,KAAK;AAAA,QACzB;AAAA,MACD,OAAO;AACN,YAAI,UAAU;AACb,gBAAM,KAAK,QAAQ;AAAA,QACpB;AACA,mBAAW;AAAA,MACZ;AAAA,IACD;AACA,QAAI,UAAU;AACb,YAAM,KAAK,QAAQ;AAAA,IACpB;AACA,WAAO,IAAI,WAAW,KAAK;AAAA,EAC5B;AAAA,EAEA,WAAW;AACV,UAAM,QAAQ,KAAK,MAAM,IAAI,CAAC,MAAM,EAAE,SAAS,CAAC,EAAE,KAAK,IAAI;AAC3D,WAAO,IAAI,KAAK;AAAA,EACjB;AAAA,EAEA,MAAM,KAAqB;AAC1B,UAAM,aAAuB,CAAC;AAC9B,QAAI,MAAM;AACV,eAAW,QAAQ,KAAK,OAAO;AAC9B,iBAAW,KAAK,IAAI,UAAU,KAAK,KAAK,aAAa,KAAK,CAAC;AAC3D,iBAAW,KAAK,KAAK,OAAO;AAC5B,YAAM,KAAK,aAAa;AAAA,IACzB;AACA,eAAW,KAAK,IAAI,UAAU,GAAG,CAAC;AAClC,WAAO,WAAW,KAAK,EAAE;AAAA,EAC1B;AAAA,EAEA,QAAQ,OAA+B;AACtC,WAAO,UAAU,MAAM,KAAK;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA,EAKA,QAAQ,aAAiC;AACxC,UAAM,QAA4B,CAAC;AACnC,QAAI,SAAS;AACb,eAAW,KAAK,KAAK,OAAO;AAC3B,YAAM;AAAA,QACL,IAAI;AAAA,UACH,YAAY;AAAA,YACX,EAAE,aAAa,QAAQ;AAAA,YACvB,EAAE,QAAQ;AAAA,UACX;AAAA,UACA,YAAY;AAAA,YACX,EAAE,aAAa;AAAA,YACf,EAAE,aAAa;AAAA,UAChB;AAAA,QACD;AAAA,MACD;AACA,gBAAU,EAAE,QAAQ,SAAS,EAAE,aAAa;AAAA,IAC7C;AACA,WAAO,IAAI,WAAW,KAAK;AAAA,EAC5B;AAAA,EAEA,mBAAkC;AACjC,UAAM,SAAwB,CAAC;AAC/B,QAAI,SAAS;AACb,eAAW,KAAK,KAAK,OAAO;AAC3B,aAAO;AAAA,QACN,YAAY;AAAA,UACX,EAAE,aAAa,QAAQ;AAAA,UACvB,EAAE,QAAQ;AAAA,QACX;AAAA,MACD;AACA,gBAAU,EAAE,QAAQ,SAAS,EAAE,aAAa;AAAA,IAC7C;AACA,WAAO;AAAA,EACR;AAAA,EAEA,IAAI,UAAmB;AACtB,WAAO,KAAK,MAAM,WAAW;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,UAAU,MAA8B;AACvC,UAAM,WAA+B,CAAC;AAEtC,QAAI,UAAU;AACd,QAAI,SAAS;AACb,QAAI,SAAS;AAEb,WAAO,SAAS,KAAK,MAAM,UAAU,UAAU,KAAK,MAAM,QAAQ;AAEjE,YAAM,WAAW,KAAK,MAAM,OAAO;AACnC,YAAM,UAAU,KAAK,MAAM,MAAM;AAEjC,UAAI,CAAC,SAAS;AAEb;AAAA,MACD,WAAW,CAAC,UAAU;AAErB,iBAAS;AAAA,UACR,IAAI;AAAA,YACH,QAAQ,aAAa,MAAM,MAAM;AAAA,YACjC,QAAQ;AAAA,UACT;AAAA,QACD;AACA;AAAA,MACD,WAAW,QAAQ,aAAa,WAAW,SAAS,YAAY,GAAG;AAClE;AAAA,MACD,WACC,QAAQ,aAAa,QAAQ,SAAS,aAAa,OAClD;AAED,iBAAS;AAAA,UACR,IAAI;AAAA,YACH,QAAQ,aAAa,MAAM,MAAM;AAAA,YACjC,QAAQ;AAAA,UACT;AAAA,QACD;AACA;AAAA,MACD,OAAO;AACN;AACA,kBACC,SAAS,QAAQ,SAAS,SAAS,aAAa;AAAA,MAClD;AAAA,IACD;AAEA,WAAO,IAAI,WAAW,QAAQ;AAAA,EAC/B;AAAA,EAEA,cAAc,gBAAgC;AAC7C,QAAI,mBAAmB;AACvB,eAAW,QAAQ,KAAK,OAAO;AAC9B,UAAI,KAAK,aAAa,SAAS,gBAAgB;AAC9C,YAAI,iBAAiB,KAAK,aAAa,cAAc;AAEpD,iBAAO,KAAK,aAAa,QAAQ;AAAA,QAClC;AACA,4BACC,KAAK,QAAQ,SAAS,KAAK,aAAa;AAAA,MAC1C,OAAO;AACN;AAAA,MACD;AAAA,IACD;AACA,WAAO,iBAAiB;AAAA,EACzB;AAAA,EAEA,mBAAmB,eAAyC;AAC3D,WAAO,IAAI;AAAA,MACV,KAAK,cAAc,cAAc,KAAK;AAAA,MACtC,KAAK,cAAc,cAAc,YAAY;AAAA,IAC9C;AAAA,EACD;AAAA,EAEA,qBAAqB,iBAAiC;AACrD,QAAI,mBAAmB;AACvB,eAAW,QAAQ,KAAK,OAAO;AAC9B,YAAM,aAAa,KAAK,QAAQ;AAChC,UAAI,KAAK,aAAa,SAAS,kBAAkB,kBAAkB;AAClE,YACC,kBAAkB,mBAClB,KAAK,aAAa,QAAQ,YACzB;AAED,iBAAO,KAAK,aAAa;AAAA,QAC1B;AACA,4BAAoB,aAAa,KAAK,aAAa;AAAA,MACpD,OAAO;AACN;AAAA,MACD;AAAA,IACD;AACA,WAAO,kBAAkB;AAAA,EAC1B;AACD;AAUO,MAAM,iBAAiB;AAAA,EAY7B,YACiB,cACA,SACf;AAFe;AACA;AAAA,EACd;AAAA,EA5PJ,OA6O8B;AAAA;AAAA;AAAA,EAC7B,OAAc,SAAS,MAA2C;AACjE,WAAO,IAAI;AAAA,MACV,YAAY,iBAAiB,KAAK,KAAK,KAAK,GAAG;AAAA,MAC/C,KAAK;AAAA,IACN;AAAA,EACD;AAAA,EAEA,OAAc,OAAO,QAAgB,MAAgC;AACpE,WAAO,IAAI,iBAAiB,YAAY,QAAQ,MAAM,GAAG,IAAI;AAAA,EAC9D;AAAA,EAOA,WAAmB;AAClB,WAAO,GAAG,KAAK,YAAY,QAAQ,KAAK,OAAO;AAAA,EAChD;AAAA,EAEA,IAAI,UAAU;AACb,WAAO,KAAK,QAAQ,WAAW,KAAK,KAAK,aAAa,WAAW;AAAA,EAClE;AACD;AAQA,SAAS,UAAU,QAAoB,QAAgC;AACtE,WAAS,OAAO,UAAU;AAC1B,WAAS,OAAO,UAAU;AAE1B,MAAI,OAAO,SAAS;AACnB,WAAO;AAAA,EACR;AACA,MAAI,OAAO,SAAS;AACnB,WAAO;AAAA,EACR;AAEA,QAAM,aAAa,CAAC,GAAG,OAAO,KAAK;AACnC,QAAM,SAA6B,CAAC;AAEpC,MAAI,eAAe;AAEnB,aAAW,SAAS,OAAO,OAAO;AAEjC,WAAO,MAAM;AACZ,YAAM,QAAQ,WAAW,CAAC;AAC1B,UACC,CAAC,SACD,MAAM,aAAa,QAClB,eACA,MAAM,QAAQ,UACd,MAAM,aAAa,OACnB;AACD;AAAA,MACD;AACA,iBAAW,MAAM;AAEjB,aAAO,KAAK,KAAK;AACjB,sBAAgB,MAAM,QAAQ,SAAS,MAAM,aAAa;AAAA,IAC3D;AAEA,UAAM,oBAAoB;AAC1B,QAAI;AACJ,QAAI;AAEJ,WAAO,MAAM;AACZ,YAAM,QAAQ,WAAW,CAAC;AAC1B,UACC,CAAC,SACD,MAAM,aAAa,QAAQ,eAC1B,MAAM,aAAa,cACnB;AACD;AAAA,MACD;AAGA,UAAI,CAAC,mBAAmB;AACvB,4BAAoB;AAAA,MACrB;AACA,yBAAmB;AACnB,iBAAW,MAAM;AAEjB,sBAAgB,MAAM,QAAQ,SAAS,MAAM,aAAa;AAAA,IAC3D;AAEA,QAAI,mBAAmB;AACtB,UAAI,SAAS;AACb,YAAM,eACL,MAAM,aAAa,SAClB,kBAAkB,aAAa,QAAQ;AACzC,UAAI,eAAe,GAAG;AACrB,iBAAS,kBAAkB,QAAQ,MAAM,GAAG,YAAY;AAAA,MACzD;AACA,YAAM,eACL,iBAAkB,aAAa,eAC/B,eACA,MAAM,aAAa;AACpB,UAAI,eAAe,GAAG;AACrB,cAAM,IAAI,IAAI;AAAA,UACb,YAAY;AAAA,YACX,iBAAkB,aAAa;AAAA,YAC/B;AAAA,UACD;AAAA,UACA,iBAAkB,QAAQ,MAAM,CAAC,YAAY;AAAA,QAC9C;AACA,mBAAW,QAAQ,CAAC;AACpB,wBAAgB,EAAE,QAAQ,SAAS,EAAE,aAAa;AAAA,MACnD;AACA,YAAM,UAAU,SAAS,MAAM;AAE/B,YAAM,kBAAkB,IAAI;AAAA,QAC3B,KAAK;AAAA,UACJ,kBAAkB,aAAa;AAAA,UAC/B,MAAM,aAAa,QAAQ;AAAA,QAC5B;AAAA,QACA,MAAM,aAAa,eAAe;AAAA,MACnC;AACA,aAAO,KAAK,IAAI,iBAAiB,iBAAiB,OAAO,CAAC;AAAA,IAC3D,OAAO;AACN,aAAO;AAAA,QACN,IAAI;AAAA,UACH,MAAM,aAAa,MAAM,CAAC,YAAY;AAAA,UACtC,MAAM;AAAA,QACP;AAAA,MACD;AAAA,IACD;AAAA,EACD;AAEA,SAAO,MAAM;AACZ,UAAM,OAAO,WAAW,MAAM;AAC9B,QAAI,CAAC,MAAM;AACV;AAAA,IACD;AACA,WAAO,KAAK,IAAI;AAAA,EACjB;AAEA,SAAO,IAAI,WAAW,MAAM,EAAE,UAAU;AACzC;AA/GS;",
  "names": []
}
