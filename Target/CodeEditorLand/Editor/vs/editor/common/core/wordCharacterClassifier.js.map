{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/core/wordCharacterClassifier.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from \"../../../base/common/charCode.js\";\nimport { LRUCache } from \"../../../base/common/map.js\";\nimport { CharacterClassifier } from \"./characterClassifier.js\";\n\nexport enum WordCharacterClass {\n\tRegular = 0,\n\tWhitespace = 1,\n\tWordSeparator = 2,\n}\n\nexport class WordCharacterClassifier extends CharacterClassifier<WordCharacterClass> {\n\tpublic readonly intlSegmenterLocales: Intl.UnicodeBCP47LocaleIdentifier[];\n\tprivate readonly _segmenter: Intl.Segmenter | null = null;\n\tprivate _cachedLine: string | null = null;\n\tprivate _cachedSegments: IntlWordSegmentData[] = [];\n\n\tconstructor(\n\t\twordSeparators: string,\n\t\tintlSegmenterLocales: Intl.UnicodeBCP47LocaleIdentifier[],\n\t) {\n\t\tsuper(WordCharacterClass.Regular);\n\t\tthis.intlSegmenterLocales = intlSegmenterLocales;\n\t\tif (this.intlSegmenterLocales.length > 0) {\n\t\t\tthis._segmenter = new Intl.Segmenter(this.intlSegmenterLocales, {\n\t\t\t\tgranularity: \"word\",\n\t\t\t});\n\t\t} else {\n\t\t\tthis._segmenter = null;\n\t\t}\n\n\t\tfor (let i = 0, len = wordSeparators.length; i < len; i++) {\n\t\t\tthis.set(\n\t\t\t\twordSeparators.charCodeAt(i),\n\t\t\t\tWordCharacterClass.WordSeparator,\n\t\t\t);\n\t\t}\n\n\t\tthis.set(CharCode.Space, WordCharacterClass.Whitespace);\n\t\tthis.set(CharCode.Tab, WordCharacterClass.Whitespace);\n\t}\n\n\tpublic findPrevIntlWordBeforeOrAtOffset(\n\t\tline: string,\n\t\toffset: number,\n\t): IntlWordSegmentData | null {\n\t\tlet candidate: IntlWordSegmentData | null = null;\n\t\tfor (const segment of this._getIntlSegmenterWordsOnLine(line)) {\n\t\t\tif (segment.index > offset) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcandidate = segment;\n\t\t}\n\t\treturn candidate;\n\t}\n\n\tpublic findNextIntlWordAtOrAfterOffset(\n\t\tlineContent: string,\n\t\toffset: number,\n\t): IntlWordSegmentData | null {\n\t\tfor (const segment of this._getIntlSegmenterWordsOnLine(lineContent)) {\n\t\t\tif (segment.index < offset) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn segment;\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate _getIntlSegmenterWordsOnLine(line: string): IntlWordSegmentData[] {\n\t\tif (!this._segmenter) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// Check if the line has changed from the previous call\n\t\tif (this._cachedLine === line) {\n\t\t\treturn this._cachedSegments;\n\t\t}\n\n\t\t// Update the cache with the new line\n\t\tthis._cachedLine = line;\n\t\tthis._cachedSegments = this._filterWordSegments(\n\t\t\tthis._segmenter.segment(line),\n\t\t);\n\n\t\treturn this._cachedSegments;\n\t}\n\n\tprivate _filterWordSegments(\n\t\tsegments: Intl.Segments,\n\t): IntlWordSegmentData[] {\n\t\tconst result: IntlWordSegmentData[] = [];\n\t\tfor (const segment of segments) {\n\t\t\tif (this._isWordLike(segment)) {\n\t\t\t\tresult.push(segment);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate _isWordLike(\n\t\tsegment: Intl.SegmentData,\n\t): segment is IntlWordSegmentData {\n\t\tif (segment.isWordLike) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nexport interface IntlWordSegmentData extends Intl.SegmentData {\n\tisWordLike: true;\n}\n\nconst wordClassifierCache = new LRUCache<string, WordCharacterClassifier>(10);\n\nexport function getMapForWordSeparators(\n\twordSeparators: string,\n\tintlSegmenterLocales: Intl.UnicodeBCP47LocaleIdentifier[],\n): WordCharacterClassifier {\n\tconst key = `${wordSeparators}/${intlSegmenterLocales.join(\",\")}`;\n\tlet result = wordClassifierCache.get(key)!;\n\tif (!result) {\n\t\tresult = new WordCharacterClassifier(\n\t\t\twordSeparators,\n\t\t\tintlSegmenterLocales,\n\t\t);\n\t\twordClassifierCache.set(key, result);\n\t}\n\treturn result;\n}\n"],
  "mappings": ";;AAKA,SAAS,gBAAgB;AACzB,SAAS,gBAAgB;AACzB,SAAS,2BAA2B;AAE7B,IAAK,qBAAL,kBAAKA,wBAAL;AACN,EAAAA,wCAAA,aAAU,KAAV;AACA,EAAAA,wCAAA,gBAAa,KAAb;AACA,EAAAA,wCAAA,mBAAgB,KAAhB;AAHW,SAAAA;AAAA,GAAA;AAML,MAAM,gCAAgC,oBAAwC;AAAA,EAfrF,OAeqF;AAAA;AAAA;AAAA,EACpE;AAAA,EACC,aAAoC;AAAA,EAC7C,cAA6B;AAAA,EAC7B,kBAAyC,CAAC;AAAA,EAElD,YACC,gBACA,sBACC;AACD,UAAM,eAA0B;AAChC,SAAK,uBAAuB;AAC5B,QAAI,KAAK,qBAAqB,SAAS,GAAG;AACzC,WAAK,aAAa,IAAI,KAAK,UAAU,KAAK,sBAAsB;AAAA,QAC/D,aAAa;AAAA,MACd,CAAC;AAAA,IACF,OAAO;AACN,WAAK,aAAa;AAAA,IACnB;AAEA,aAAS,IAAI,GAAG,MAAM,eAAe,QAAQ,IAAI,KAAK,KAAK;AAC1D,WAAK;AAAA,QACJ,eAAe,WAAW,CAAC;AAAA,QAC3B;AAAA,MACD;AAAA,IACD;AAEA,SAAK,IAAI,SAAS,OAAO,kBAA6B;AACtD,SAAK,IAAI,SAAS,KAAK,kBAA6B;AAAA,EACrD;AAAA,EAEO,iCACN,MACA,QAC6B;AAC7B,QAAI,YAAwC;AAC5C,eAAW,WAAW,KAAK,6BAA6B,IAAI,GAAG;AAC9D,UAAI,QAAQ,QAAQ,QAAQ;AAC3B;AAAA,MACD;AACA,kBAAY;AAAA,IACb;AACA,WAAO;AAAA,EACR;AAAA,EAEO,gCACN,aACA,QAC6B;AAC7B,eAAW,WAAW,KAAK,6BAA6B,WAAW,GAAG;AACrE,UAAI,QAAQ,QAAQ,QAAQ;AAC3B;AAAA,MACD;AACA,aAAO;AAAA,IACR;AACA,WAAO;AAAA,EACR;AAAA,EAEQ,6BAA6B,MAAqC;AACzE,QAAI,CAAC,KAAK,YAAY;AACrB,aAAO,CAAC;AAAA,IACT;AAGA,QAAI,KAAK,gBAAgB,MAAM;AAC9B,aAAO,KAAK;AAAA,IACb;AAGA,SAAK,cAAc;AACnB,SAAK,kBAAkB,KAAK;AAAA,MAC3B,KAAK,WAAW,QAAQ,IAAI;AAAA,IAC7B;AAEA,WAAO,KAAK;AAAA,EACb;AAAA,EAEQ,oBACP,UACwB;AACxB,UAAM,SAAgC,CAAC;AACvC,eAAW,WAAW,UAAU;AAC/B,UAAI,KAAK,YAAY,OAAO,GAAG;AAC9B,eAAO,KAAK,OAAO;AAAA,MACpB;AAAA,IACD;AACA,WAAO;AAAA,EACR;AAAA,EAEQ,YACP,SACiC;AACjC,QAAI,QAAQ,YAAY;AACvB,aAAO;AAAA,IACR;AACA,WAAO;AAAA,EACR;AACD;AAMA,MAAM,sBAAsB,IAAI,SAA0C,EAAE;AAErE,SAAS,wBACf,gBACA,sBAC0B;AAC1B,QAAM,MAAM,GAAG,cAAc,IAAI,qBAAqB,KAAK,GAAG,CAAC;AAC/D,MAAI,SAAS,oBAAoB,IAAI,GAAG;AACxC,MAAI,CAAC,QAAQ;AACZ,aAAS,IAAI;AAAA,MACZ;AAAA,MACA;AAAA,IACD;AACA,wBAAoB,IAAI,KAAK,MAAM;AAAA,EACpC;AACA,SAAO;AACR;AAdgB;",
  "names": ["WordCharacterClass"]
}
