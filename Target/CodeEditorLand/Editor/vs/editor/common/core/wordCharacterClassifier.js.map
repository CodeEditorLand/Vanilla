{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/core/wordCharacterClassifier.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport { LRUCache } from '../../../base/common/map.js';\nimport { CharacterClassifier } from './characterClassifier.js';\n\nexport const enum WordCharacterClass {\n\tRegular = 0,\n\tWhitespace = 1,\n\tWordSeparator = 2\n}\n\nexport class WordCharacterClassifier extends CharacterClassifier<WordCharacterClass> {\n\n\tpublic readonly intlSegmenterLocales: Intl.UnicodeBCP47LocaleIdentifier[];\n\tprivate readonly _segmenter: Intl.Segmenter | null = null;\n\tprivate _cachedLine: string | null = null;\n\tprivate _cachedSegments: IntlWordSegmentData[] = [];\n\n\tconstructor(wordSeparators: string, intlSegmenterLocales: Intl.UnicodeBCP47LocaleIdentifier[]) {\n\t\tsuper(WordCharacterClass.Regular);\n\t\tthis.intlSegmenterLocales = intlSegmenterLocales;\n\t\tif (this.intlSegmenterLocales.length > 0) {\n\t\t\tthis._segmenter = new Intl.Segmenter(this.intlSegmenterLocales, { granularity: 'word' });\n\t\t} else {\n\t\t\tthis._segmenter = null;\n\t\t}\n\n\t\tfor (let i = 0, len = wordSeparators.length; i < len; i++) {\n\t\t\tthis.set(wordSeparators.charCodeAt(i), WordCharacterClass.WordSeparator);\n\t\t}\n\n\t\tthis.set(CharCode.Space, WordCharacterClass.Whitespace);\n\t\tthis.set(CharCode.Tab, WordCharacterClass.Whitespace);\n\t}\n\n\tpublic findPrevIntlWordBeforeOrAtOffset(line: string, offset: number): IntlWordSegmentData | null {\n\t\tlet candidate: IntlWordSegmentData | null = null;\n\t\tfor (const segment of this._getIntlSegmenterWordsOnLine(line)) {\n\t\t\tif (segment.index > offset) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcandidate = segment;\n\t\t}\n\t\treturn candidate;\n\t}\n\n\tpublic findNextIntlWordAtOrAfterOffset(lineContent: string, offset: number): IntlWordSegmentData | null {\n\t\tfor (const segment of this._getIntlSegmenterWordsOnLine(lineContent)) {\n\t\t\tif (segment.index < offset) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn segment;\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate _getIntlSegmenterWordsOnLine(line: string): IntlWordSegmentData[] {\n\t\tif (!this._segmenter) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// Check if the line has changed from the previous call\n\t\tif (this._cachedLine === line) {\n\t\t\treturn this._cachedSegments;\n\t\t}\n\n\t\t// Update the cache with the new line\n\t\tthis._cachedLine = line;\n\t\tthis._cachedSegments = this._filterWordSegments(this._segmenter.segment(line));\n\n\t\treturn this._cachedSegments;\n\t}\n\n\tprivate _filterWordSegments(segments: Intl.Segments): IntlWordSegmentData[] {\n\t\tconst result: IntlWordSegmentData[] = [];\n\t\tfor (const segment of segments) {\n\t\t\tif (this._isWordLike(segment)) {\n\t\t\t\tresult.push(segment);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate _isWordLike(segment: Intl.SegmentData): segment is IntlWordSegmentData {\n\t\tif (segment.isWordLike) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nexport interface IntlWordSegmentData extends Intl.SegmentData {\n\tisWordLike: true;\n}\n\nconst wordClassifierCache = new LRUCache<string, WordCharacterClassifier>(10);\n\nexport function getMapForWordSeparators(wordSeparators: string, intlSegmenterLocales: Intl.UnicodeBCP47LocaleIdentifier[]): WordCharacterClassifier {\n\tconst key = `${wordSeparators}/${intlSegmenterLocales.join(',')}`;\n\tlet result = wordClassifierCache.get(key)!;\n\tif (!result) {\n\t\tresult = new WordCharacterClassifier(wordSeparators, intlSegmenterLocales);\n\t\twordClassifierCache.set(key, result);\n\t}\n\treturn result;\n}\n"],
  "mappings": ";;AAKA,SAAS,gBAAgB;AACzB,SAAS,gBAAgB;AACzB,SAAS,2BAA2B;AAE7B,IAAW,qBAAX,kBAAWA,wBAAX;AACN,EAAAA,wCAAA,aAAU,KAAV;AACA,EAAAA,wCAAA,gBAAa,KAAb;AACA,EAAAA,wCAAA,mBAAgB,KAAhB;AAHiB,SAAAA;AAAA,GAAA;AAMX,MAAM,gCAAgC,oBAAwC;AAAA,EAfrF,OAeqF;AAAA;AAAA;AAAA,EAEpE;AAAA,EACC,aAAoC;AAAA,EAC7C,cAA6B;AAAA,EAC7B,kBAAyC,CAAC;AAAA,EAElD,YAAY,gBAAwB,sBAA2D;AAC9F,UAAM,eAA0B;AAChC,SAAK,uBAAuB;AAC5B,QAAI,KAAK,qBAAqB,SAAS,GAAG;AACzC,WAAK,aAAa,IAAI,KAAK,UAAU,KAAK,sBAAsB,EAAE,aAAa,OAAO,CAAC;AAAA,IACxF,OAAO;AACN,WAAK,aAAa;AAAA,IACnB;AAEA,aAAS,IAAI,GAAG,MAAM,eAAe,QAAQ,IAAI,KAAK,KAAK;AAC1D,WAAK,IAAI,eAAe,WAAW,CAAC,GAAG,qBAAgC;AAAA,IACxE;AAEA,SAAK,IAAI,SAAS,OAAO,kBAA6B;AACtD,SAAK,IAAI,SAAS,KAAK,kBAA6B;AAAA,EACrD;AAAA,EAEO,iCAAiC,MAAc,QAA4C;AACjG,QAAI,YAAwC;AAC5C,eAAW,WAAW,KAAK,6BAA6B,IAAI,GAAG;AAC9D,UAAI,QAAQ,QAAQ,QAAQ;AAC3B;AAAA,MACD;AACA,kBAAY;AAAA,IACb;AACA,WAAO;AAAA,EACR;AAAA,EAEO,gCAAgC,aAAqB,QAA4C;AACvG,eAAW,WAAW,KAAK,6BAA6B,WAAW,GAAG;AACrE,UAAI,QAAQ,QAAQ,QAAQ;AAC3B;AAAA,MACD;AACA,aAAO;AAAA,IACR;AACA,WAAO;AAAA,EACR;AAAA,EAEQ,6BAA6B,MAAqC;AACzE,QAAI,CAAC,KAAK,YAAY;AACrB,aAAO,CAAC;AAAA,IACT;AAGA,QAAI,KAAK,gBAAgB,MAAM;AAC9B,aAAO,KAAK;AAAA,IACb;AAGA,SAAK,cAAc;AACnB,SAAK,kBAAkB,KAAK,oBAAoB,KAAK,WAAW,QAAQ,IAAI,CAAC;AAE7E,WAAO,KAAK;AAAA,EACb;AAAA,EAEQ,oBAAoB,UAAgD;AAC3E,UAAM,SAAgC,CAAC;AACvC,eAAW,WAAW,UAAU;AAC/B,UAAI,KAAK,YAAY,OAAO,GAAG;AAC9B,eAAO,KAAK,OAAO;AAAA,MACpB;AAAA,IACD;AACA,WAAO;AAAA,EACR;AAAA,EAEQ,YAAY,SAA2D;AAC9E,QAAI,QAAQ,YAAY;AACvB,aAAO;AAAA,IACR;AACA,WAAO;AAAA,EACR;AACD;AAMA,MAAM,sBAAsB,IAAI,SAA0C,EAAE;AAErE,SAAS,wBAAwB,gBAAwB,sBAAoF;AACnJ,QAAM,MAAM,GAAG,cAAc,IAAI,qBAAqB,KAAK,GAAG,CAAC;AAC/D,MAAI,SAAS,oBAAoB,IAAI,GAAG;AACxC,MAAI,CAAC,QAAQ;AACZ,aAAS,IAAI,wBAAwB,gBAAgB,oBAAoB;AACzE,wBAAoB,IAAI,KAAK,MAAM;AAAA,EACpC;AACA,SAAO;AACR;AARgB;",
  "names": ["WordCharacterClass"]
}
