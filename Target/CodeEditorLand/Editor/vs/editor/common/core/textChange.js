import*as g from"../../../base/common/buffer.js";import{decodeUTF16LE as _}from"./stringBuilder.js";function p(w){return w.replace(/\n/g,"\\n").replace(/\r/g,"\\r")}class i{constructor(e,t,r,n){this.oldPosition=e;this.oldText=t;this.newPosition=r;this.newText=n}get oldLength(){return this.oldText.length}get oldEnd(){return this.oldPosition+this.oldText.length}get newLength(){return this.newText.length}get newEnd(){return this.newPosition+this.newText.length}toString(){return this.oldText.length===0?`(insert@${this.oldPosition} "${p(this.newText)}")`:this.newText.length===0?`(delete@${this.oldPosition} "${p(this.oldText)}")`:`(replace@${this.oldPosition} "${p(this.oldText)}" with "${p(this.newText)}")`}static _writeStringSize(e){return 4+2*e.length}static _writeString(e,t,r){const n=t.length;g.writeUInt32BE(e,n,r),r+=4;for(let s=0;s<n;s++)g.writeUInt16LE(e,t.charCodeAt(s),r),r+=2;return r}static _readString(e,t){const r=g.readUInt32BE(e,t);return t+=4,_(e,t,r)}writeSize(){return 8+i._writeStringSize(this.oldText)+i._writeStringSize(this.newText)}write(e,t){return g.writeUInt32BE(e,this.oldPosition,t),t+=4,g.writeUInt32BE(e,this.newPosition,t),t+=4,t=i._writeString(e,this.oldText,t),t=i._writeString(e,this.newText,t),t}static read(e,t,r){const n=g.readUInt32BE(e,t);t+=4;const s=g.readUInt32BE(e,t);t+=4;const u=i._readString(e,t);t+=i._writeStringSize(u);const l=i._readString(e,t);return t+=i._writeStringSize(l),r.push(new i(n,u,s,l)),t}}function x(w,e){return w===null||w.length===0?e:new o(w,e).compress()}class o{_prevEdits;_currEdits;_result;_resultLen;_prevLen;_prevDeltaOffset;_currLen;_currDeltaOffset;constructor(e,t){this._prevEdits=e,this._currEdits=t,this._result=[],this._resultLen=0,this._prevLen=this._prevEdits.length,this._prevDeltaOffset=0,this._currLen=this._currEdits.length,this._currDeltaOffset=0}compress(){let e=0,t=0,r=this._getPrev(e),n=this._getCurr(t);for(;e<this._prevLen||t<this._currLen;){if(r===null){this._acceptCurr(n),n=this._getCurr(++t);continue}if(n===null){this._acceptPrev(r),r=this._getPrev(++e);continue}if(n.oldEnd<=r.newPosition){this._acceptCurr(n),n=this._getCurr(++t);continue}if(r.newEnd<=n.oldPosition){this._acceptPrev(r),r=this._getPrev(++e);continue}if(n.oldPosition<r.newPosition){const[c,a]=o._splitCurr(n,r.newPosition-n.oldPosition);this._acceptCurr(c),n=a;continue}if(r.newPosition<n.oldPosition){const[c,a]=o._splitPrev(r,n.oldPosition-r.newPosition);this._acceptPrev(c),r=a;continue}let l,h;if(n.oldEnd===r.newEnd)l=r,h=n,r=this._getPrev(++e),n=this._getCurr(++t);else if(n.oldEnd<r.newEnd){const[c,a]=o._splitPrev(r,n.oldLength);l=c,h=n,r=a,n=this._getCurr(++t)}else{const[c,a]=o._splitCurr(n,r.newLength);l=r,h=c,r=this._getPrev(++e),n=a}this._result[this._resultLen++]=new i(l.oldPosition,l.oldText,h.newPosition,h.newText),this._prevDeltaOffset+=l.newLength-l.oldLength,this._currDeltaOffset+=h.newLength-h.oldLength}const s=o._merge(this._result);return o._removeNoOps(s)}_acceptCurr(e){this._result[this._resultLen++]=o._rebaseCurr(this._prevDeltaOffset,e),this._currDeltaOffset+=e.newLength-e.oldLength}_getCurr(e){return e<this._currLen?this._currEdits[e]:null}_acceptPrev(e){this._result[this._resultLen++]=o._rebasePrev(this._currDeltaOffset,e),this._prevDeltaOffset+=e.newLength-e.oldLength}_getPrev(e){return e<this._prevLen?this._prevEdits[e]:null}static _rebaseCurr(e,t){return new i(t.oldPosition-e,t.oldText,t.newPosition,t.newText)}static _rebasePrev(e,t){return new i(t.oldPosition,t.oldText,t.newPosition+e,t.newText)}static _splitPrev(e,t){const r=e.newText.substr(0,t),n=e.newText.substr(t);return[new i(e.oldPosition,e.oldText,e.newPosition,r),new i(e.oldEnd,"",e.newPosition+t,n)]}static _splitCurr(e,t){const r=e.oldText.substr(0,t),n=e.oldText.substr(t);return[new i(e.oldPosition,r,e.newPosition,e.newText),new i(e.oldPosition+t,n,e.newEnd,"")]}static _merge(e){if(e.length===0)return e;const t=[];let r=0,n=e[0];for(let s=1;s<e.length;s++){const u=e[s];n.oldEnd===u.oldPosition?n=new i(n.oldPosition,n.oldText+u.oldText,n.newPosition,n.newText+u.newText):(t[r++]=n,n=u)}return t[r++]=n,t}static _removeNoOps(e){if(e.length===0)return e;const t=[];let r=0;for(let n=0;n<e.length;n++){const s=e[n];s.oldText!==s.newText&&(t[r++]=s)}return t}}export{i as TextChange,x as compressConsecutiveTextChanges};
