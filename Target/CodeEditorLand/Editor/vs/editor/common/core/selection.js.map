{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/core/selection.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IPosition, Position } from './position.js';\nimport { Range } from './range.js';\n\n/**\n * A selection in the editor.\n * The selection is a range that has an orientation.\n */\nexport interface ISelection {\n\t/**\n\t * The line number on which the selection has started.\n\t */\n\treadonly selectionStartLineNumber: number;\n\t/**\n\t * The column on `selectionStartLineNumber` where the selection has started.\n\t */\n\treadonly selectionStartColumn: number;\n\t/**\n\t * The line number on which the selection has ended.\n\t */\n\treadonly positionLineNumber: number;\n\t/**\n\t * The column on `positionLineNumber` where the selection has ended.\n\t */\n\treadonly positionColumn: number;\n}\n\n/**\n * The direction of a selection.\n */\nexport const enum SelectionDirection {\n\t/**\n\t * The selection starts above where it ends.\n\t */\n\tLTR,\n\t/**\n\t * The selection starts below where it ends.\n\t */\n\tRTL\n}\n\n/**\n * A selection in the editor.\n * The selection is a range that has an orientation.\n */\nexport class Selection extends Range {\n\t/**\n\t * The line number on which the selection has started.\n\t */\n\tpublic readonly selectionStartLineNumber: number;\n\t/**\n\t * The column on `selectionStartLineNumber` where the selection has started.\n\t */\n\tpublic readonly selectionStartColumn: number;\n\t/**\n\t * The line number on which the selection has ended.\n\t */\n\tpublic readonly positionLineNumber: number;\n\t/**\n\t * The column on `positionLineNumber` where the selection has ended.\n\t */\n\tpublic readonly positionColumn: number;\n\n\tconstructor(selectionStartLineNumber: number, selectionStartColumn: number, positionLineNumber: number, positionColumn: number) {\n\t\tsuper(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);\n\t\tthis.selectionStartLineNumber = selectionStartLineNumber;\n\t\tthis.selectionStartColumn = selectionStartColumn;\n\t\tthis.positionLineNumber = positionLineNumber;\n\t\tthis.positionColumn = positionColumn;\n\t}\n\n\t/**\n\t * Transform to a human-readable representation.\n\t */\n\tpublic override toString(): string {\n\t\treturn '[' + this.selectionStartLineNumber + ',' + this.selectionStartColumn + ' -> ' + this.positionLineNumber + ',' + this.positionColumn + ']';\n\t}\n\n\t/**\n\t * Test if equals other selection.\n\t */\n\tpublic equalsSelection(other: ISelection): boolean {\n\t\treturn (\n\t\t\tSelection.selectionsEqual(this, other)\n\t\t);\n\t}\n\n\t/**\n\t * Test if the two selections are equal.\n\t */\n\tpublic static selectionsEqual(a: ISelection, b: ISelection): boolean {\n\t\treturn (\n\t\t\ta.selectionStartLineNumber === b.selectionStartLineNumber &&\n\t\t\ta.selectionStartColumn === b.selectionStartColumn &&\n\t\t\ta.positionLineNumber === b.positionLineNumber &&\n\t\t\ta.positionColumn === b.positionColumn\n\t\t);\n\t}\n\n\t/**\n\t * Get directions (LTR or RTL).\n\t */\n\tpublic getDirection(): SelectionDirection {\n\t\tif (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {\n\t\t\treturn SelectionDirection.LTR;\n\t\t}\n\t\treturn SelectionDirection.RTL;\n\t}\n\n\t/**\n\t * Create a new selection with a different `positionLineNumber` and `positionColumn`.\n\t */\n\tpublic override setEndPosition(endLineNumber: number, endColumn: number): Selection {\n\t\tif (this.getDirection() === SelectionDirection.LTR) {\n\t\t\treturn new Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n\t\t}\n\t\treturn new Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);\n\t}\n\n\t/**\n\t * Get the position at `positionLineNumber` and `positionColumn`.\n\t */\n\tpublic getPosition(): Position {\n\t\treturn new Position(this.positionLineNumber, this.positionColumn);\n\t}\n\n\t/**\n\t * Get the position at the start of the selection.\n\t*/\n\tpublic getSelectionStart(): Position {\n\t\treturn new Position(this.selectionStartLineNumber, this.selectionStartColumn);\n\t}\n\n\t/**\n\t * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.\n\t */\n\tpublic override setStartPosition(startLineNumber: number, startColumn: number): Selection {\n\t\tif (this.getDirection() === SelectionDirection.LTR) {\n\t\t\treturn new Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n\t\t}\n\t\treturn new Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);\n\t}\n\n\t// ----\n\n\t/**\n\t * Create a `Selection` from one or two positions\n\t */\n\tpublic static override fromPositions(start: IPosition, end: IPosition = start): Selection {\n\t\treturn new Selection(start.lineNumber, start.column, end.lineNumber, end.column);\n\t}\n\n\t/**\n\t * Creates a `Selection` from a range, given a direction.\n\t */\n\tpublic static fromRange(range: Range, direction: SelectionDirection): Selection {\n\t\tif (direction === SelectionDirection.LTR) {\n\t\t\treturn new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n\t\t} else {\n\t\t\treturn new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n\t\t}\n\t}\n\n\t/**\n\t * Create a `Selection` from an `ISelection`.\n\t */\n\tpublic static liftSelection(sel: ISelection): Selection {\n\t\treturn new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);\n\t}\n\n\t/**\n\t * `a` equals `b`.\n\t */\n\tpublic static selectionsArrEqual(a: ISelection[], b: ISelection[]): boolean {\n\t\tif (a && !b || !a && b) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!a && !b) {\n\t\t\treturn true;\n\t\t}\n\t\tif (a.length !== b.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0, len = a.length; i < len; i++) {\n\t\t\tif (!this.selectionsEqual(a[i], b[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Test if `obj` is an `ISelection`.\n\t */\n\tpublic static isISelection(obj: any): obj is ISelection {\n\t\treturn (\n\t\t\tobj\n\t\t\t&& (typeof obj.selectionStartLineNumber === 'number')\n\t\t\t&& (typeof obj.selectionStartColumn === 'number')\n\t\t\t&& (typeof obj.positionLineNumber === 'number')\n\t\t\t&& (typeof obj.positionColumn === 'number')\n\t\t);\n\t}\n\n\t/**\n\t * Create with a direction.\n\t */\n\tpublic static createWithDirection(startLineNumber: number, startColumn: number, endLineNumber: number, endColumn: number, direction: SelectionDirection): Selection {\n\n\t\tif (direction === SelectionDirection.LTR) {\n\t\t\treturn new Selection(startLineNumber, startColumn, endLineNumber, endColumn);\n\t\t}\n\n\t\treturn new Selection(endLineNumber, endColumn, startLineNumber, startColumn);\n\t}\n}\n"],
  "mappings": "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",
  "names": ["SelectionDirection"]
}
