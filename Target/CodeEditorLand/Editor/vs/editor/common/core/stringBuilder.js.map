{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/core/stringBuilder.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as buffer from \"../../../base/common/buffer.js\";\nimport * as platform from \"../../../base/common/platform.js\";\nimport * as strings from \"../../../base/common/strings.js\";\n\nlet _utf16LE_TextDecoder: TextDecoder | null;\nfunction getUTF16LE_TextDecoder(): TextDecoder {\n\tif (!_utf16LE_TextDecoder) {\n\t\t_utf16LE_TextDecoder = new TextDecoder(\"UTF-16LE\");\n\t}\n\treturn _utf16LE_TextDecoder;\n}\n\nlet _utf16BE_TextDecoder: TextDecoder | null;\nfunction getUTF16BE_TextDecoder(): TextDecoder {\n\tif (!_utf16BE_TextDecoder) {\n\t\t_utf16BE_TextDecoder = new TextDecoder(\"UTF-16BE\");\n\t}\n\treturn _utf16BE_TextDecoder;\n}\n\nlet _platformTextDecoder: TextDecoder | null;\nexport function getPlatformTextDecoder(): TextDecoder {\n\tif (!_platformTextDecoder) {\n\t\t_platformTextDecoder = platform.isLittleEndian()\n\t\t\t? getUTF16LE_TextDecoder()\n\t\t\t: getUTF16BE_TextDecoder();\n\t}\n\treturn _platformTextDecoder;\n}\n\nexport function decodeUTF16LE(\n\tsource: Uint8Array,\n\toffset: number,\n\tlen: number,\n): string {\n\tconst view = new Uint16Array(source.buffer, offset, len);\n\tif (len > 0 && (view[0] === 0xfeff || view[0] === 0xfffe)) {\n\t\t// UTF16 sometimes starts with a BOM https://de.wikipedia.org/wiki/Byte_Order_Mark\n\t\t// It looks like TextDecoder.decode will eat up a leading BOM (0xFEFF or 0xFFFE)\n\t\t// We don't want that behavior because we know the string is UTF16LE and the BOM should be maintained\n\t\t// So we use the manual decoder\n\t\treturn compatDecodeUTF16LE(source, offset, len);\n\t}\n\treturn getUTF16LE_TextDecoder().decode(view);\n}\n\nfunction compatDecodeUTF16LE(\n\tsource: Uint8Array,\n\toffset: number,\n\tlen: number,\n): string {\n\tconst result: string[] = [];\n\tlet resultLen = 0;\n\tfor (let i = 0; i < len; i++) {\n\t\tconst charCode = buffer.readUInt16LE(source, offset);\n\t\toffset += 2;\n\t\tresult[resultLen++] = String.fromCharCode(charCode);\n\t}\n\treturn result.join(\"\");\n}\n\nexport class StringBuilder {\n\tprivate readonly _capacity: number;\n\tprivate readonly _buffer: Uint16Array;\n\n\tprivate _completedStrings: string[] | null;\n\tprivate _bufferLength: number;\n\n\tconstructor(capacity: number) {\n\t\tthis._capacity = capacity | 0;\n\t\tthis._buffer = new Uint16Array(this._capacity);\n\n\t\tthis._completedStrings = null;\n\t\tthis._bufferLength = 0;\n\t}\n\n\tpublic reset(): void {\n\t\tthis._completedStrings = null;\n\t\tthis._bufferLength = 0;\n\t}\n\n\tpublic build(): string {\n\t\tif (this._completedStrings !== null) {\n\t\t\tthis._flushBuffer();\n\t\t\treturn this._completedStrings.join(\"\");\n\t\t}\n\t\treturn this._buildBuffer();\n\t}\n\n\tprivate _buildBuffer(): string {\n\t\tif (this._bufferLength === 0) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tconst view = new Uint16Array(\n\t\t\tthis._buffer.buffer,\n\t\t\t0,\n\t\t\tthis._bufferLength,\n\t\t);\n\t\treturn getPlatformTextDecoder().decode(view);\n\t}\n\n\tprivate _flushBuffer(): void {\n\t\tconst bufferString = this._buildBuffer();\n\t\tthis._bufferLength = 0;\n\n\t\tif (this._completedStrings === null) {\n\t\t\tthis._completedStrings = [bufferString];\n\t\t} else {\n\t\t\tthis._completedStrings[this._completedStrings.length] =\n\t\t\t\tbufferString;\n\t\t}\n\t}\n\n\t/**\n\t * Append a char code (<2^16)\n\t */\n\tpublic appendCharCode(charCode: number): void {\n\t\tconst remainingSpace = this._capacity - this._bufferLength;\n\n\t\tif (remainingSpace <= 1) {\n\t\t\tif (remainingSpace === 0 || strings.isHighSurrogate(charCode)) {\n\t\t\t\tthis._flushBuffer();\n\t\t\t}\n\t\t}\n\n\t\tthis._buffer[this._bufferLength++] = charCode;\n\t}\n\n\t/**\n\t * Append an ASCII char code (<2^8)\n\t */\n\tpublic appendASCIICharCode(charCode: number): void {\n\t\tif (this._bufferLength === this._capacity) {\n\t\t\t// buffer is full\n\t\t\tthis._flushBuffer();\n\t\t}\n\t\tthis._buffer[this._bufferLength++] = charCode;\n\t}\n\n\tpublic appendString(str: string): void {\n\t\tconst strLen = str.length;\n\n\t\tif (this._bufferLength + strLen >= this._capacity) {\n\t\t\t// This string does not fit in the remaining buffer space\n\n\t\t\tthis._flushBuffer();\n\t\t\tthis._completedStrings![this._completedStrings!.length] = str;\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let i = 0; i < strLen; i++) {\n\t\t\tthis._buffer[this._bufferLength++] = str.charCodeAt(i);\n\t\t}\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
