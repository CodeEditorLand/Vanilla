{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/core/range.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { type IPosition, Position } from \"./position.js\";\n\n/**\n * A range in the editor. This interface is suitable for serialization.\n */\nexport interface IRange {\n\t/**\n\t * Line number on which the range starts (starts at 1).\n\t */\n\treadonly startLineNumber: number;\n\t/**\n\t * Column on which the range starts in line `startLineNumber` (starts at 1).\n\t */\n\treadonly startColumn: number;\n\t/**\n\t * Line number on which the range ends.\n\t */\n\treadonly endLineNumber: number;\n\t/**\n\t * Column on which the range ends in line `endLineNumber`.\n\t */\n\treadonly endColumn: number;\n}\n\n/**\n * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)\n */\nexport class Range {\n\t/**\n\t * Line number on which the range starts (starts at 1).\n\t */\n\tpublic readonly startLineNumber: number;\n\t/**\n\t * Column on which the range starts in line `startLineNumber` (starts at 1).\n\t */\n\tpublic readonly startColumn: number;\n\t/**\n\t * Line number on which the range ends.\n\t */\n\tpublic readonly endLineNumber: number;\n\t/**\n\t * Column on which the range ends in line `endLineNumber`.\n\t */\n\tpublic readonly endColumn: number;\n\n\tconstructor(\n\t\tstartLineNumber: number,\n\t\tstartColumn: number,\n\t\tendLineNumber: number,\n\t\tendColumn: number,\n\t) {\n\t\tif (\n\t\t\tstartLineNumber > endLineNumber ||\n\t\t\t(startLineNumber === endLineNumber && startColumn > endColumn)\n\t\t) {\n\t\t\tthis.startLineNumber = endLineNumber;\n\t\t\tthis.startColumn = endColumn;\n\t\t\tthis.endLineNumber = startLineNumber;\n\t\t\tthis.endColumn = startColumn;\n\t\t} else {\n\t\t\tthis.startLineNumber = startLineNumber;\n\t\t\tthis.startColumn = startColumn;\n\t\t\tthis.endLineNumber = endLineNumber;\n\t\t\tthis.endColumn = endColumn;\n\t\t}\n\t}\n\n\t/**\n\t * Test if this range is empty.\n\t */\n\tpublic isEmpty(): boolean {\n\t\treturn Range.isEmpty(this);\n\t}\n\n\t/**\n\t * Test if `range` is empty.\n\t */\n\tpublic static isEmpty(range: IRange): boolean {\n\t\treturn (\n\t\t\trange.startLineNumber === range.endLineNumber &&\n\t\t\trange.startColumn === range.endColumn\n\t\t);\n\t}\n\n\t/**\n\t * Test if position is in this range. If the position is at the edges, will return true.\n\t */\n\tpublic containsPosition(position: IPosition): boolean {\n\t\treturn Range.containsPosition(this, position);\n\t}\n\n\t/**\n\t * Test if `position` is in `range`. If the position is at the edges, will return true.\n\t */\n\tpublic static containsPosition(\n\t\trange: IRange,\n\t\tposition: IPosition,\n\t): boolean {\n\t\tif (\n\t\t\tposition.lineNumber < range.startLineNumber ||\n\t\t\tposition.lineNumber > range.endLineNumber\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t\tif (\n\t\t\tposition.lineNumber === range.startLineNumber &&\n\t\t\tposition.column < range.startColumn\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t\tif (\n\t\t\tposition.lineNumber === range.endLineNumber &&\n\t\t\tposition.column > range.endColumn\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Test if `position` is in `range`. If the position is at the edges, will return false.\n\t * @internal\n\t */\n\tpublic static strictContainsPosition(\n\t\trange: IRange,\n\t\tposition: IPosition,\n\t): boolean {\n\t\tif (\n\t\t\tposition.lineNumber < range.startLineNumber ||\n\t\t\tposition.lineNumber > range.endLineNumber\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t\tif (\n\t\t\tposition.lineNumber === range.startLineNumber &&\n\t\t\tposition.column <= range.startColumn\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t\tif (\n\t\t\tposition.lineNumber === range.endLineNumber &&\n\t\t\tposition.column >= range.endColumn\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Test if range is in this range. If the range is equal to this range, will return true.\n\t */\n\tpublic containsRange(range: IRange): boolean {\n\t\treturn Range.containsRange(this, range);\n\t}\n\n\t/**\n\t * Test if `otherRange` is in `range`. If the ranges are equal, will return true.\n\t */\n\tpublic static containsRange(range: IRange, otherRange: IRange): boolean {\n\t\tif (\n\t\t\totherRange.startLineNumber < range.startLineNumber ||\n\t\t\totherRange.endLineNumber < range.startLineNumber\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t\tif (\n\t\t\totherRange.startLineNumber > range.endLineNumber ||\n\t\t\totherRange.endLineNumber > range.endLineNumber\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t\tif (\n\t\t\totherRange.startLineNumber === range.startLineNumber &&\n\t\t\totherRange.startColumn < range.startColumn\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t\tif (\n\t\t\totherRange.endLineNumber === range.endLineNumber &&\n\t\t\totherRange.endColumn > range.endColumn\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.\n\t */\n\tpublic strictContainsRange(range: IRange): boolean {\n\t\treturn Range.strictContainsRange(this, range);\n\t}\n\n\t/**\n\t * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.\n\t */\n\tpublic static strictContainsRange(\n\t\trange: IRange,\n\t\totherRange: IRange,\n\t): boolean {\n\t\tif (\n\t\t\totherRange.startLineNumber < range.startLineNumber ||\n\t\t\totherRange.endLineNumber < range.startLineNumber\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t\tif (\n\t\t\totherRange.startLineNumber > range.endLineNumber ||\n\t\t\totherRange.endLineNumber > range.endLineNumber\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t\tif (\n\t\t\totherRange.startLineNumber === range.startLineNumber &&\n\t\t\totherRange.startColumn <= range.startColumn\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t\tif (\n\t\t\totherRange.endLineNumber === range.endLineNumber &&\n\t\t\totherRange.endColumn >= range.endColumn\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * A reunion of the two ranges.\n\t * The smallest position will be used as the start point, and the largest one as the end point.\n\t */\n\tpublic plusRange(range: IRange): Range {\n\t\treturn Range.plusRange(this, range);\n\t}\n\n\t/**\n\t * A reunion of the two ranges.\n\t * The smallest position will be used as the start point, and the largest one as the end point.\n\t */\n\tpublic static plusRange(a: IRange, b: IRange): Range {\n\t\tlet startLineNumber: number;\n\t\tlet startColumn: number;\n\t\tlet endLineNumber: number;\n\t\tlet endColumn: number;\n\n\t\tif (b.startLineNumber < a.startLineNumber) {\n\t\t\tstartLineNumber = b.startLineNumber;\n\t\t\tstartColumn = b.startColumn;\n\t\t} else if (b.startLineNumber === a.startLineNumber) {\n\t\t\tstartLineNumber = b.startLineNumber;\n\t\t\tstartColumn = Math.min(b.startColumn, a.startColumn);\n\t\t} else {\n\t\t\tstartLineNumber = a.startLineNumber;\n\t\t\tstartColumn = a.startColumn;\n\t\t}\n\n\t\tif (b.endLineNumber > a.endLineNumber) {\n\t\t\tendLineNumber = b.endLineNumber;\n\t\t\tendColumn = b.endColumn;\n\t\t} else if (b.endLineNumber === a.endLineNumber) {\n\t\t\tendLineNumber = b.endLineNumber;\n\t\t\tendColumn = Math.max(b.endColumn, a.endColumn);\n\t\t} else {\n\t\t\tendLineNumber = a.endLineNumber;\n\t\t\tendColumn = a.endColumn;\n\t\t}\n\n\t\treturn new Range(\n\t\t\tstartLineNumber,\n\t\t\tstartColumn,\n\t\t\tendLineNumber,\n\t\t\tendColumn,\n\t\t);\n\t}\n\n\t/**\n\t * A intersection of the two ranges.\n\t */\n\tpublic intersectRanges(range: IRange): Range | null {\n\t\treturn Range.intersectRanges(this, range);\n\t}\n\n\t/**\n\t * A intersection of the two ranges.\n\t */\n\tpublic static intersectRanges(a: IRange, b: IRange): Range | null {\n\t\tlet resultStartLineNumber = a.startLineNumber;\n\t\tlet resultStartColumn = a.startColumn;\n\t\tlet resultEndLineNumber = a.endLineNumber;\n\t\tlet resultEndColumn = a.endColumn;\n\t\tconst otherStartLineNumber = b.startLineNumber;\n\t\tconst otherStartColumn = b.startColumn;\n\t\tconst otherEndLineNumber = b.endLineNumber;\n\t\tconst otherEndColumn = b.endColumn;\n\n\t\tif (resultStartLineNumber < otherStartLineNumber) {\n\t\t\tresultStartLineNumber = otherStartLineNumber;\n\t\t\tresultStartColumn = otherStartColumn;\n\t\t} else if (resultStartLineNumber === otherStartLineNumber) {\n\t\t\tresultStartColumn = Math.max(resultStartColumn, otherStartColumn);\n\t\t}\n\n\t\tif (resultEndLineNumber > otherEndLineNumber) {\n\t\t\tresultEndLineNumber = otherEndLineNumber;\n\t\t\tresultEndColumn = otherEndColumn;\n\t\t} else if (resultEndLineNumber === otherEndLineNumber) {\n\t\t\tresultEndColumn = Math.min(resultEndColumn, otherEndColumn);\n\t\t}\n\n\t\t// Check if selection is now empty\n\t\tif (resultStartLineNumber > resultEndLineNumber) {\n\t\t\treturn null;\n\t\t}\n\t\tif (\n\t\t\tresultStartLineNumber === resultEndLineNumber &&\n\t\t\tresultStartColumn > resultEndColumn\n\t\t) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new Range(\n\t\t\tresultStartLineNumber,\n\t\t\tresultStartColumn,\n\t\t\tresultEndLineNumber,\n\t\t\tresultEndColumn,\n\t\t);\n\t}\n\n\t/**\n\t * Test if this range equals other.\n\t */\n\tpublic equalsRange(other: IRange | null | undefined): boolean {\n\t\treturn Range.equalsRange(this, other);\n\t}\n\n\t/**\n\t * Test if range `a` equals `b`.\n\t */\n\tpublic static equalsRange(\n\t\ta: IRange | null | undefined,\n\t\tb: IRange | null | undefined,\n\t): boolean {\n\t\tif (!a && !b) {\n\t\t\treturn true;\n\t\t}\n\t\treturn (\n\t\t\t!!a &&\n\t\t\t!!b &&\n\t\t\ta.startLineNumber === b.startLineNumber &&\n\t\t\ta.startColumn === b.startColumn &&\n\t\t\ta.endLineNumber === b.endLineNumber &&\n\t\t\ta.endColumn === b.endColumn\n\t\t);\n\t}\n\n\t/**\n\t * Return the end position (which will be after or equal to the start position)\n\t */\n\tpublic getEndPosition(): Position {\n\t\treturn Range.getEndPosition(this);\n\t}\n\n\t/**\n\t * Return the end position (which will be after or equal to the start position)\n\t */\n\tpublic static getEndPosition(range: IRange): Position {\n\t\treturn new Position(range.endLineNumber, range.endColumn);\n\t}\n\n\t/**\n\t * Return the start position (which will be before or equal to the end position)\n\t */\n\tpublic getStartPosition(): Position {\n\t\treturn Range.getStartPosition(this);\n\t}\n\n\t/**\n\t * Return the start position (which will be before or equal to the end position)\n\t */\n\tpublic static getStartPosition(range: IRange): Position {\n\t\treturn new Position(range.startLineNumber, range.startColumn);\n\t}\n\n\t/**\n\t * Transform to a user presentable string representation.\n\t */\n\tpublic toString(): string {\n\t\treturn (\n\t\t\t\"[\" +\n\t\t\tthis.startLineNumber +\n\t\t\t\",\" +\n\t\t\tthis.startColumn +\n\t\t\t\" -> \" +\n\t\t\tthis.endLineNumber +\n\t\t\t\",\" +\n\t\t\tthis.endColumn +\n\t\t\t\"]\"\n\t\t);\n\t}\n\n\t/**\n\t * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\n\t */\n\tpublic setEndPosition(endLineNumber: number, endColumn: number): Range {\n\t\treturn new Range(\n\t\t\tthis.startLineNumber,\n\t\t\tthis.startColumn,\n\t\t\tendLineNumber,\n\t\t\tendColumn,\n\t\t);\n\t}\n\n\t/**\n\t * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\n\t */\n\tpublic setStartPosition(\n\t\tstartLineNumber: number,\n\t\tstartColumn: number,\n\t): Range {\n\t\treturn new Range(\n\t\t\tstartLineNumber,\n\t\t\tstartColumn,\n\t\t\tthis.endLineNumber,\n\t\t\tthis.endColumn,\n\t\t);\n\t}\n\n\t/**\n\t * Create a new empty range using this range's start position.\n\t */\n\tpublic collapseToStart(): Range {\n\t\treturn Range.collapseToStart(this);\n\t}\n\n\t/**\n\t * Create a new empty range using this range's start position.\n\t */\n\tpublic static collapseToStart(range: IRange): Range {\n\t\treturn new Range(\n\t\t\trange.startLineNumber,\n\t\t\trange.startColumn,\n\t\t\trange.startLineNumber,\n\t\t\trange.startColumn,\n\t\t);\n\t}\n\n\t/**\n\t * Create a new empty range using this range's end position.\n\t */\n\tpublic collapseToEnd(): Range {\n\t\treturn Range.collapseToEnd(this);\n\t}\n\n\t/**\n\t * Create a new empty range using this range's end position.\n\t */\n\tpublic static collapseToEnd(range: IRange): Range {\n\t\treturn new Range(\n\t\t\trange.endLineNumber,\n\t\t\trange.endColumn,\n\t\t\trange.endLineNumber,\n\t\t\trange.endColumn,\n\t\t);\n\t}\n\n\t/**\n\t * Moves the range by the given amount of lines.\n\t */\n\tpublic delta(lineCount: number): Range {\n\t\treturn new Range(\n\t\t\tthis.startLineNumber + lineCount,\n\t\t\tthis.startColumn,\n\t\t\tthis.endLineNumber + lineCount,\n\t\t\tthis.endColumn,\n\t\t);\n\t}\n\n\t// ---\n\n\tpublic static fromPositions(\n\t\tstart: IPosition,\n\t\tend: IPosition = start,\n\t): Range {\n\t\treturn new Range(\n\t\t\tstart.lineNumber,\n\t\t\tstart.column,\n\t\t\tend.lineNumber,\n\t\t\tend.column,\n\t\t);\n\t}\n\n\t/**\n\t * Create a `Range` from an `IRange`.\n\t */\n\tpublic static lift(range: undefined | null): null;\n\tpublic static lift(range: IRange): Range;\n\tpublic static lift(range: IRange | undefined | null): Range | null;\n\tpublic static lift(range: IRange | undefined | null): Range | null {\n\t\tif (!range) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new Range(\n\t\t\trange.startLineNumber,\n\t\t\trange.startColumn,\n\t\t\trange.endLineNumber,\n\t\t\trange.endColumn,\n\t\t);\n\t}\n\n\t/**\n\t * Test if `obj` is an `IRange`.\n\t */\n\tpublic static isIRange(obj: any): obj is IRange {\n\t\treturn (\n\t\t\tobj &&\n\t\t\ttypeof obj.startLineNumber === \"number\" &&\n\t\t\ttypeof obj.startColumn === \"number\" &&\n\t\t\ttypeof obj.endLineNumber === \"number\" &&\n\t\t\ttypeof obj.endColumn === \"number\"\n\t\t);\n\t}\n\n\t/**\n\t * Test if the two ranges are touching in any way.\n\t */\n\tpublic static areIntersectingOrTouching(a: IRange, b: IRange): boolean {\n\t\t// Check if `a` is before `b`\n\t\tif (\n\t\t\ta.endLineNumber < b.startLineNumber ||\n\t\t\t(a.endLineNumber === b.startLineNumber &&\n\t\t\t\ta.endColumn < b.startColumn)\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if `b` is before `a`\n\t\tif (\n\t\t\tb.endLineNumber < a.startLineNumber ||\n\t\t\t(b.endLineNumber === a.startLineNumber &&\n\t\t\t\tb.endColumn < a.startColumn)\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// These ranges must intersect\n\t\treturn true;\n\t}\n\n\t/**\n\t * Test if the two ranges are intersecting. If the ranges are touching it returns true.\n\t */\n\tpublic static areIntersecting(a: IRange, b: IRange): boolean {\n\t\t// Check if `a` is before `b`\n\t\tif (\n\t\t\ta.endLineNumber < b.startLineNumber ||\n\t\t\t(a.endLineNumber === b.startLineNumber &&\n\t\t\t\ta.endColumn <= b.startColumn)\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if `b` is before `a`\n\t\tif (\n\t\t\tb.endLineNumber < a.startLineNumber ||\n\t\t\t(b.endLineNumber === a.startLineNumber &&\n\t\t\t\tb.endColumn <= a.startColumn)\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// These ranges must intersect\n\t\treturn true;\n\t}\n\n\t/**\n\t * A function that compares ranges, useful for sorting ranges\n\t * It will first compare ranges on the startPosition and then on the endPosition\n\t */\n\tpublic static compareRangesUsingStarts(\n\t\ta: IRange | null | undefined,\n\t\tb: IRange | null | undefined,\n\t): number {\n\t\tif (a && b) {\n\t\t\tconst aStartLineNumber = a.startLineNumber | 0;\n\t\t\tconst bStartLineNumber = b.startLineNumber | 0;\n\n\t\t\tif (aStartLineNumber === bStartLineNumber) {\n\t\t\t\tconst aStartColumn = a.startColumn | 0;\n\t\t\t\tconst bStartColumn = b.startColumn | 0;\n\n\t\t\t\tif (aStartColumn === bStartColumn) {\n\t\t\t\t\tconst aEndLineNumber = a.endLineNumber | 0;\n\t\t\t\t\tconst bEndLineNumber = b.endLineNumber | 0;\n\n\t\t\t\t\tif (aEndLineNumber === bEndLineNumber) {\n\t\t\t\t\t\tconst aEndColumn = a.endColumn | 0;\n\t\t\t\t\t\tconst bEndColumn = b.endColumn | 0;\n\t\t\t\t\t\treturn aEndColumn - bEndColumn;\n\t\t\t\t\t}\n\t\t\t\t\treturn aEndLineNumber - bEndLineNumber;\n\t\t\t\t}\n\t\t\t\treturn aStartColumn - bStartColumn;\n\t\t\t}\n\t\t\treturn aStartLineNumber - bStartLineNumber;\n\t\t}\n\t\tconst aExists = a ? 1 : 0;\n\t\tconst bExists = b ? 1 : 0;\n\t\treturn aExists - bExists;\n\t}\n\n\t/**\n\t * A function that compares ranges, useful for sorting ranges\n\t * It will first compare ranges on the endPosition and then on the startPosition\n\t */\n\tpublic static compareRangesUsingEnds(a: IRange, b: IRange): number {\n\t\tif (a.endLineNumber === b.endLineNumber) {\n\t\t\tif (a.endColumn === b.endColumn) {\n\t\t\t\tif (a.startLineNumber === b.startLineNumber) {\n\t\t\t\t\treturn a.startColumn - b.startColumn;\n\t\t\t\t}\n\t\t\t\treturn a.startLineNumber - b.startLineNumber;\n\t\t\t}\n\t\t\treturn a.endColumn - b.endColumn;\n\t\t}\n\t\treturn a.endLineNumber - b.endLineNumber;\n\t}\n\n\t/**\n\t * Test if the range spans multiple lines.\n\t */\n\tpublic static spansMultipleLines(range: IRange): boolean {\n\t\treturn range.endLineNumber > range.startLineNumber;\n\t}\n\n\tpublic toJSON(): IRange {\n\t\treturn this;\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
