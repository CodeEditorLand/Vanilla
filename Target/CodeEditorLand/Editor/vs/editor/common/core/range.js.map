{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/core/range.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IPosition, Position } from './position.js';\n\n/**\n * A range in the editor. This interface is suitable for serialization.\n */\nexport interface IRange {\n\t/**\n\t * Line number on which the range starts (starts at 1).\n\t */\n\treadonly startLineNumber: number;\n\t/**\n\t * Column on which the range starts in line `startLineNumber` (starts at 1).\n\t */\n\treadonly startColumn: number;\n\t/**\n\t * Line number on which the range ends.\n\t */\n\treadonly endLineNumber: number;\n\t/**\n\t * Column on which the range ends in line `endLineNumber`.\n\t */\n\treadonly endColumn: number;\n}\n\n/**\n * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)\n */\nexport class Range {\n\n\t/**\n\t * Line number on which the range starts (starts at 1).\n\t */\n\tpublic readonly startLineNumber: number;\n\t/**\n\t * Column on which the range starts in line `startLineNumber` (starts at 1).\n\t */\n\tpublic readonly startColumn: number;\n\t/**\n\t * Line number on which the range ends.\n\t */\n\tpublic readonly endLineNumber: number;\n\t/**\n\t * Column on which the range ends in line `endLineNumber`.\n\t */\n\tpublic readonly endColumn: number;\n\n\tconstructor(startLineNumber: number, startColumn: number, endLineNumber: number, endColumn: number) {\n\t\tif ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {\n\t\t\tthis.startLineNumber = endLineNumber;\n\t\t\tthis.startColumn = endColumn;\n\t\t\tthis.endLineNumber = startLineNumber;\n\t\t\tthis.endColumn = startColumn;\n\t\t} else {\n\t\t\tthis.startLineNumber = startLineNumber;\n\t\t\tthis.startColumn = startColumn;\n\t\t\tthis.endLineNumber = endLineNumber;\n\t\t\tthis.endColumn = endColumn;\n\t\t}\n\t}\n\n\t/**\n\t * Test if this range is empty.\n\t */\n\tpublic isEmpty(): boolean {\n\t\treturn Range.isEmpty(this);\n\t}\n\n\t/**\n\t * Test if `range` is empty.\n\t */\n\tpublic static isEmpty(range: IRange): boolean {\n\t\treturn (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);\n\t}\n\n\t/**\n\t * Test if position is in this range. If the position is at the edges, will return true.\n\t */\n\tpublic containsPosition(position: IPosition): boolean {\n\t\treturn Range.containsPosition(this, position);\n\t}\n\n\t/**\n\t * Test if `position` is in `range`. If the position is at the edges, will return true.\n\t */\n\tpublic static containsPosition(range: IRange, position: IPosition): boolean {\n\t\tif (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\tif (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {\n\t\t\treturn false;\n\t\t}\n\t\tif (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Test if `position` is in `range`. If the position is at the edges, will return false.\n\t * @internal\n\t */\n\tpublic static strictContainsPosition(range: IRange, position: IPosition): boolean {\n\t\tif (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\tif (position.lineNumber === range.startLineNumber && position.column <= range.startColumn) {\n\t\t\treturn false;\n\t\t}\n\t\tif (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Test if range is in this range. If the range is equal to this range, will return true.\n\t */\n\tpublic containsRange(range: IRange): boolean {\n\t\treturn Range.containsRange(this, range);\n\t}\n\n\t/**\n\t * Test if `otherRange` is in `range`. If the ranges are equal, will return true.\n\t */\n\tpublic static containsRange(range: IRange, otherRange: IRange): boolean {\n\t\tif (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\tif (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\tif (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {\n\t\t\treturn false;\n\t\t}\n\t\tif (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.\n\t */\n\tpublic strictContainsRange(range: IRange): boolean {\n\t\treturn Range.strictContainsRange(this, range);\n\t}\n\n\t/**\n\t * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.\n\t */\n\tpublic static strictContainsRange(range: IRange, otherRange: IRange): boolean {\n\t\tif (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\tif (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\tif (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {\n\t\t\treturn false;\n\t\t}\n\t\tif (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * A reunion of the two ranges.\n\t * The smallest position will be used as the start point, and the largest one as the end point.\n\t */\n\tpublic plusRange(range: IRange): Range {\n\t\treturn Range.plusRange(this, range);\n\t}\n\n\t/**\n\t * A reunion of the two ranges.\n\t * The smallest position will be used as the start point, and the largest one as the end point.\n\t */\n\tpublic static plusRange(a: IRange, b: IRange): Range {\n\t\tlet startLineNumber: number;\n\t\tlet startColumn: number;\n\t\tlet endLineNumber: number;\n\t\tlet endColumn: number;\n\n\t\tif (b.startLineNumber < a.startLineNumber) {\n\t\t\tstartLineNumber = b.startLineNumber;\n\t\t\tstartColumn = b.startColumn;\n\t\t} else if (b.startLineNumber === a.startLineNumber) {\n\t\t\tstartLineNumber = b.startLineNumber;\n\t\t\tstartColumn = Math.min(b.startColumn, a.startColumn);\n\t\t} else {\n\t\t\tstartLineNumber = a.startLineNumber;\n\t\t\tstartColumn = a.startColumn;\n\t\t}\n\n\t\tif (b.endLineNumber > a.endLineNumber) {\n\t\t\tendLineNumber = b.endLineNumber;\n\t\t\tendColumn = b.endColumn;\n\t\t} else if (b.endLineNumber === a.endLineNumber) {\n\t\t\tendLineNumber = b.endLineNumber;\n\t\t\tendColumn = Math.max(b.endColumn, a.endColumn);\n\t\t} else {\n\t\t\tendLineNumber = a.endLineNumber;\n\t\t\tendColumn = a.endColumn;\n\t\t}\n\n\t\treturn new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n\t}\n\n\t/**\n\t * A intersection of the two ranges.\n\t */\n\tpublic intersectRanges(range: IRange): Range | null {\n\t\treturn Range.intersectRanges(this, range);\n\t}\n\n\t/**\n\t * A intersection of the two ranges.\n\t */\n\tpublic static intersectRanges(a: IRange, b: IRange): Range | null {\n\t\tlet resultStartLineNumber = a.startLineNumber;\n\t\tlet resultStartColumn = a.startColumn;\n\t\tlet resultEndLineNumber = a.endLineNumber;\n\t\tlet resultEndColumn = a.endColumn;\n\t\tconst otherStartLineNumber = b.startLineNumber;\n\t\tconst otherStartColumn = b.startColumn;\n\t\tconst otherEndLineNumber = b.endLineNumber;\n\t\tconst otherEndColumn = b.endColumn;\n\n\t\tif (resultStartLineNumber < otherStartLineNumber) {\n\t\t\tresultStartLineNumber = otherStartLineNumber;\n\t\t\tresultStartColumn = otherStartColumn;\n\t\t} else if (resultStartLineNumber === otherStartLineNumber) {\n\t\t\tresultStartColumn = Math.max(resultStartColumn, otherStartColumn);\n\t\t}\n\n\t\tif (resultEndLineNumber > otherEndLineNumber) {\n\t\t\tresultEndLineNumber = otherEndLineNumber;\n\t\t\tresultEndColumn = otherEndColumn;\n\t\t} else if (resultEndLineNumber === otherEndLineNumber) {\n\t\t\tresultEndColumn = Math.min(resultEndColumn, otherEndColumn);\n\t\t}\n\n\t\t// Check if selection is now empty\n\t\tif (resultStartLineNumber > resultEndLineNumber) {\n\t\t\treturn null;\n\t\t}\n\t\tif (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\n\t}\n\n\t/**\n\t * Test if this range equals other.\n\t */\n\tpublic equalsRange(other: IRange | null | undefined): boolean {\n\t\treturn Range.equalsRange(this, other);\n\t}\n\n\t/**\n\t * Test if range `a` equals `b`.\n\t */\n\tpublic static equalsRange(a: IRange | null | undefined, b: IRange | null | undefined): boolean {\n\t\tif (!a && !b) {\n\t\t\treturn true;\n\t\t}\n\t\treturn (\n\t\t\t!!a &&\n\t\t\t!!b &&\n\t\t\ta.startLineNumber === b.startLineNumber &&\n\t\t\ta.startColumn === b.startColumn &&\n\t\t\ta.endLineNumber === b.endLineNumber &&\n\t\t\ta.endColumn === b.endColumn\n\t\t);\n\t}\n\n\t/**\n\t * Return the end position (which will be after or equal to the start position)\n\t */\n\tpublic getEndPosition(): Position {\n\t\treturn Range.getEndPosition(this);\n\t}\n\n\t/**\n\t * Return the end position (which will be after or equal to the start position)\n\t */\n\tpublic static getEndPosition(range: IRange): Position {\n\t\treturn new Position(range.endLineNumber, range.endColumn);\n\t}\n\n\t/**\n\t * Return the start position (which will be before or equal to the end position)\n\t */\n\tpublic getStartPosition(): Position {\n\t\treturn Range.getStartPosition(this);\n\t}\n\n\t/**\n\t * Return the start position (which will be before or equal to the end position)\n\t */\n\tpublic static getStartPosition(range: IRange): Position {\n\t\treturn new Position(range.startLineNumber, range.startColumn);\n\t}\n\n\t/**\n\t * Transform to a user presentable string representation.\n\t */\n\tpublic toString(): string {\n\t\treturn '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';\n\t}\n\n\t/**\n\t * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\n\t */\n\tpublic setEndPosition(endLineNumber: number, endColumn: number): Range {\n\t\treturn new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n\t}\n\n\t/**\n\t * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\n\t */\n\tpublic setStartPosition(startLineNumber: number, startColumn: number): Range {\n\t\treturn new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n\t}\n\n\t/**\n\t * Create a new empty range using this range's start position.\n\t */\n\tpublic collapseToStart(): Range {\n\t\treturn Range.collapseToStart(this);\n\t}\n\n\t/**\n\t * Create a new empty range using this range's start position.\n\t */\n\tpublic static collapseToStart(range: IRange): Range {\n\t\treturn new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\n\t}\n\n\t/**\n\t * Create a new empty range using this range's end position.\n\t */\n\tpublic collapseToEnd(): Range {\n\t\treturn Range.collapseToEnd(this);\n\t}\n\n\t/**\n\t * Create a new empty range using this range's end position.\n\t */\n\tpublic static collapseToEnd(range: IRange): Range {\n\t\treturn new Range(range.endLineNumber, range.endColumn, range.endLineNumber, range.endColumn);\n\t}\n\n\t/**\n\t * Moves the range by the given amount of lines.\n\t */\n\tpublic delta(lineCount: number): Range {\n\t\treturn new Range(this.startLineNumber + lineCount, this.startColumn, this.endLineNumber + lineCount, this.endColumn);\n\t}\n\n\t// ---\n\n\tpublic static fromPositions(start: IPosition, end: IPosition = start): Range {\n\t\treturn new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n\t}\n\n\t/**\n\t * Create a `Range` from an `IRange`.\n\t */\n\tpublic static lift(range: undefined | null): null;\n\tpublic static lift(range: IRange): Range;\n\tpublic static lift(range: IRange | undefined | null): Range | null;\n\tpublic static lift(range: IRange | undefined | null): Range | null {\n\t\tif (!range) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n\t}\n\n\t/**\n\t * Test if `obj` is an `IRange`.\n\t */\n\tpublic static isIRange(obj: any): obj is IRange {\n\t\treturn (\n\t\t\tobj\n\t\t\t&& (typeof obj.startLineNumber === 'number')\n\t\t\t&& (typeof obj.startColumn === 'number')\n\t\t\t&& (typeof obj.endLineNumber === 'number')\n\t\t\t&& (typeof obj.endColumn === 'number')\n\t\t);\n\t}\n\n\t/**\n\t * Test if the two ranges are touching in any way.\n\t */\n\tpublic static areIntersectingOrTouching(a: IRange, b: IRange): boolean {\n\t\t// Check if `a` is before `b`\n\t\tif (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if `b` is before `a`\n\t\tif (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// These ranges must intersect\n\t\treturn true;\n\t}\n\n\t/**\n\t * Test if the two ranges are intersecting. If the ranges are touching it returns true.\n\t */\n\tpublic static areIntersecting(a: IRange, b: IRange): boolean {\n\t\t// Check if `a` is before `b`\n\t\tif (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if `b` is before `a`\n\t\tif (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// These ranges must intersect\n\t\treturn true;\n\t}\n\n\t/**\n\t * A function that compares ranges, useful for sorting ranges\n\t * It will first compare ranges on the startPosition and then on the endPosition\n\t */\n\tpublic static compareRangesUsingStarts(a: IRange | null | undefined, b: IRange | null | undefined): number {\n\t\tif (a && b) {\n\t\t\tconst aStartLineNumber = a.startLineNumber | 0;\n\t\t\tconst bStartLineNumber = b.startLineNumber | 0;\n\n\t\t\tif (aStartLineNumber === bStartLineNumber) {\n\t\t\t\tconst aStartColumn = a.startColumn | 0;\n\t\t\t\tconst bStartColumn = b.startColumn | 0;\n\n\t\t\t\tif (aStartColumn === bStartColumn) {\n\t\t\t\t\tconst aEndLineNumber = a.endLineNumber | 0;\n\t\t\t\t\tconst bEndLineNumber = b.endLineNumber | 0;\n\n\t\t\t\t\tif (aEndLineNumber === bEndLineNumber) {\n\t\t\t\t\t\tconst aEndColumn = a.endColumn | 0;\n\t\t\t\t\t\tconst bEndColumn = b.endColumn | 0;\n\t\t\t\t\t\treturn aEndColumn - bEndColumn;\n\t\t\t\t\t}\n\t\t\t\t\treturn aEndLineNumber - bEndLineNumber;\n\t\t\t\t}\n\t\t\t\treturn aStartColumn - bStartColumn;\n\t\t\t}\n\t\t\treturn aStartLineNumber - bStartLineNumber;\n\t\t}\n\t\tconst aExists = (a ? 1 : 0);\n\t\tconst bExists = (b ? 1 : 0);\n\t\treturn aExists - bExists;\n\t}\n\n\t/**\n\t * A function that compares ranges, useful for sorting ranges\n\t * It will first compare ranges on the endPosition and then on the startPosition\n\t */\n\tpublic static compareRangesUsingEnds(a: IRange, b: IRange): number {\n\t\tif (a.endLineNumber === b.endLineNumber) {\n\t\t\tif (a.endColumn === b.endColumn) {\n\t\t\t\tif (a.startLineNumber === b.startLineNumber) {\n\t\t\t\t\treturn a.startColumn - b.startColumn;\n\t\t\t\t}\n\t\t\t\treturn a.startLineNumber - b.startLineNumber;\n\t\t\t}\n\t\t\treturn a.endColumn - b.endColumn;\n\t\t}\n\t\treturn a.endLineNumber - b.endLineNumber;\n\t}\n\n\t/**\n\t * Test if the range spans multiple lines.\n\t */\n\tpublic static spansMultipleLines(range: IRange): boolean {\n\t\treturn range.endLineNumber > range.startLineNumber;\n\t}\n\n\tpublic toJSON(): IRange {\n\t\treturn this;\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
