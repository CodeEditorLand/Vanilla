{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/modelLineProjectionData.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { assertNever } from '../../base/common/assert.js';\nimport { WrappingIndent } from './config/editorOptions.js';\nimport { FontInfo } from './config/fontInfo.js';\nimport { Position } from './core/position.js';\nimport { InjectedTextCursorStops, InjectedTextOptions, PositionAffinity } from './model.js';\nimport { LineInjectedText } from './textModelEvents.js';\n\n/**\n * *input*:\n * ```\n * xxxxxxxxxxxxxxxxxxxxxxxxxxx\n * ```\n *\n * -> Applying injections `[i...i]`, *inputWithInjections*:\n * ```\n * xxxxxx[iiiiiiiiii]xxxxxxxxxxxxxxxxx[ii]xxxx\n * ```\n *\n * -> breaking at offsets `|` in `xxxxxx[iiiiiii|iii]xxxxxxxxxxx|xxxxxx[ii]xxxx|`:\n * ```\n * xxxxxx[iiiiiii\n * iii]xxxxxxxxxxx\n * xxxxxx[ii]xxxx\n * ```\n *\n * -> applying wrappedTextIndentLength, *output*:\n * ```\n * xxxxxx[iiiiiii\n *    iii]xxxxxxxxxxx\n *    xxxxxx[ii]xxxx\n * ```\n */\nexport class ModelLineProjectionData {\n\tconstructor(\n\t\tpublic injectionOffsets: number[] | null,\n\t\t/**\n\t\t * `injectionOptions.length` must equal `injectionOffsets.length`\n\t\t */\n\t\tpublic injectionOptions: InjectedTextOptions[] | null,\n\t\t/**\n\t\t * Refers to offsets after applying injections to the source.\n\t\t * The last break offset indicates the length of the source after applying injections.\n\t\t */\n\t\tpublic breakOffsets: number[],\n\t\t/**\n\t\t * Refers to offsets after applying injections\n\t\t */\n\t\tpublic breakOffsetsVisibleColumn: number[],\n\t\tpublic wrappedTextIndentLength: number\n\t) {\n\t}\n\n\tpublic getOutputLineCount(): number {\n\t\treturn this.breakOffsets.length;\n\t}\n\n\tpublic getMinOutputOffset(outputLineIndex: number): number {\n\t\tif (outputLineIndex > 0) {\n\t\t\treturn this.wrappedTextIndentLength;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic getLineLength(outputLineIndex: number): number {\n\t\t// These offsets refer to model text with injected text.\n\t\tconst startOffset = outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0;\n\t\tconst endOffset = this.breakOffsets[outputLineIndex];\n\n\t\tlet lineLength = endOffset - startOffset;\n\t\tif (outputLineIndex > 0) {\n\t\t\tlineLength += this.wrappedTextIndentLength;\n\t\t}\n\t\treturn lineLength;\n\t}\n\n\tpublic getMaxOutputOffset(outputLineIndex: number): number {\n\t\treturn this.getLineLength(outputLineIndex);\n\t}\n\n\tpublic translateToInputOffset(outputLineIndex: number, outputOffset: number): number {\n\t\tif (outputLineIndex > 0) {\n\t\t\toutputOffset = Math.max(0, outputOffset - this.wrappedTextIndentLength);\n\t\t}\n\n\t\tconst offsetInInputWithInjection = outputLineIndex === 0 ? outputOffset : this.breakOffsets[outputLineIndex - 1] + outputOffset;\n\t\tlet offsetInInput = offsetInInputWithInjection;\n\n\t\tif (this.injectionOffsets !== null) {\n\t\t\tfor (let i = 0; i < this.injectionOffsets.length; i++) {\n\t\t\t\tif (offsetInInput > this.injectionOffsets[i]) {\n\t\t\t\t\tif (offsetInInput < this.injectionOffsets[i] + this.injectionOptions![i].content.length) {\n\t\t\t\t\t\t// `inputOffset` is within injected text\n\t\t\t\t\t\toffsetInInput = this.injectionOffsets[i];\n\t\t\t\t\t} else {\n\t\t\t\t\t\toffsetInInput -= this.injectionOptions![i].content.length;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn offsetInInput;\n\t}\n\n\tpublic translateToOutputPosition(inputOffset: number, affinity: PositionAffinity = PositionAffinity.None): OutputPosition {\n\t\tlet inputOffsetInInputWithInjection = inputOffset;\n\t\tif (this.injectionOffsets !== null) {\n\t\t\tfor (let i = 0; i < this.injectionOffsets.length; i++) {\n\t\t\t\tif (inputOffset < this.injectionOffsets[i]) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (affinity !== PositionAffinity.Right && inputOffset === this.injectionOffsets[i]) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tinputOffsetInInputWithInjection += this.injectionOptions![i].content.length;\n\t\t\t}\n\t\t}\n\n\t\treturn this.offsetInInputWithInjectionsToOutputPosition(inputOffsetInInputWithInjection, affinity);\n\t}\n\n\tprivate offsetInInputWithInjectionsToOutputPosition(offsetInInputWithInjections: number, affinity: PositionAffinity = PositionAffinity.None): OutputPosition {\n\t\tlet low = 0;\n\t\tlet high = this.breakOffsets.length - 1;\n\t\tlet mid = 0;\n\t\tlet midStart = 0;\n\n\t\twhile (low <= high) {\n\t\t\tmid = low + ((high - low) / 2) | 0;\n\n\t\t\tconst midStop = this.breakOffsets[mid];\n\t\t\tmidStart = mid > 0 ? this.breakOffsets[mid - 1] : 0;\n\n\t\t\tif (affinity === PositionAffinity.Left) {\n\t\t\t\tif (offsetInInputWithInjections <= midStart) {\n\t\t\t\t\thigh = mid - 1;\n\t\t\t\t} else if (offsetInInputWithInjections > midStop) {\n\t\t\t\t\tlow = mid + 1;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (offsetInInputWithInjections < midStart) {\n\t\t\t\t\thigh = mid - 1;\n\t\t\t\t} else if (offsetInInputWithInjections >= midStop) {\n\t\t\t\t\tlow = mid + 1;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet outputOffset = offsetInInputWithInjections - midStart;\n\t\tif (mid > 0) {\n\t\t\toutputOffset += this.wrappedTextIndentLength;\n\t\t}\n\n\t\treturn new OutputPosition(mid, outputOffset);\n\t}\n\n\tpublic normalizeOutputPosition(outputLineIndex: number, outputOffset: number, affinity: PositionAffinity): OutputPosition {\n\t\tif (this.injectionOffsets !== null) {\n\t\t\tconst offsetInInputWithInjections = this.outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset);\n\t\t\tconst normalizedOffsetInUnwrappedLine = this.normalizeOffsetInInputWithInjectionsAroundInjections(offsetInInputWithInjections, affinity);\n\t\t\tif (normalizedOffsetInUnwrappedLine !== offsetInInputWithInjections) {\n\t\t\t\t// injected text caused a change\n\t\t\t\treturn this.offsetInInputWithInjectionsToOutputPosition(normalizedOffsetInUnwrappedLine, affinity);\n\t\t\t}\n\t\t}\n\n\t\tif (affinity === PositionAffinity.Left) {\n\t\t\tif (outputLineIndex > 0 && outputOffset === this.getMinOutputOffset(outputLineIndex)) {\n\t\t\t\treturn new OutputPosition(outputLineIndex - 1, this.getMaxOutputOffset(outputLineIndex - 1));\n\t\t\t}\n\t\t}\n\t\telse if (affinity === PositionAffinity.Right) {\n\t\t\tconst maxOutputLineIndex = this.getOutputLineCount() - 1;\n\t\t\tif (outputLineIndex < maxOutputLineIndex && outputOffset === this.getMaxOutputOffset(outputLineIndex)) {\n\t\t\t\treturn new OutputPosition(outputLineIndex + 1, this.getMinOutputOffset(outputLineIndex + 1));\n\t\t\t}\n\t\t}\n\n\t\treturn new OutputPosition(outputLineIndex, outputOffset);\n\t}\n\n\tprivate outputPositionToOffsetInInputWithInjections(outputLineIndex: number, outputOffset: number): number {\n\t\tif (outputLineIndex > 0) {\n\t\t\toutputOffset = Math.max(0, outputOffset - this.wrappedTextIndentLength);\n\t\t}\n\t\tconst result = (outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0) + outputOffset;\n\t\treturn result;\n\t}\n\n\tprivate normalizeOffsetInInputWithInjectionsAroundInjections(offsetInInputWithInjections: number, affinity: PositionAffinity): number {\n\t\tconst injectedText = this.getInjectedTextAtOffset(offsetInInputWithInjections);\n\t\tif (!injectedText) {\n\t\t\treturn offsetInInputWithInjections;\n\t\t}\n\n\t\tif (affinity === PositionAffinity.None) {\n\t\t\tif (offsetInInputWithInjections === injectedText.offsetInInputWithInjections + injectedText.length\n\t\t\t\t&& hasRightCursorStop(this.injectionOptions![injectedText.injectedTextIndex].cursorStops)) {\n\t\t\t\treturn injectedText.offsetInInputWithInjections + injectedText.length;\n\t\t\t} else {\n\t\t\t\tlet result = injectedText.offsetInInputWithInjections;\n\t\t\t\tif (hasLeftCursorStop(this.injectionOptions![injectedText.injectedTextIndex].cursorStops)) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tlet index = injectedText.injectedTextIndex - 1;\n\t\t\t\twhile (index >= 0 && this.injectionOffsets![index] === this.injectionOffsets![injectedText.injectedTextIndex]) {\n\t\t\t\t\tif (hasRightCursorStop(this.injectionOptions![index].cursorStops)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tresult -= this.injectionOptions![index].content.length;\n\t\t\t\t\tif (hasLeftCursorStop(this.injectionOptions![index].cursorStops)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t} else if (affinity === PositionAffinity.Right || affinity === PositionAffinity.RightOfInjectedText) {\n\t\t\tlet result = injectedText.offsetInInputWithInjections + injectedText.length;\n\t\t\tlet index = injectedText.injectedTextIndex;\n\t\t\t// traverse all injected text that touch each other\n\t\t\twhile (index + 1 < this.injectionOffsets!.length && this.injectionOffsets![index + 1] === this.injectionOffsets![index]) {\n\t\t\t\tresult += this.injectionOptions![index + 1].content.length;\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\treturn result;\n\t\t} else if (affinity === PositionAffinity.Left || affinity === PositionAffinity.LeftOfInjectedText) {\n\t\t\t// affinity is left\n\t\t\tlet result = injectedText.offsetInInputWithInjections;\n\t\t\tlet index = injectedText.injectedTextIndex;\n\t\t\t// traverse all injected text that touch each other\n\t\t\twhile (index - 1 >= 0 && this.injectionOffsets![index - 1] === this.injectionOffsets![index]) {\n\t\t\t\tresult -= this.injectionOptions![index - 1].content.length;\n\t\t\t\tindex--;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tassertNever(affinity);\n\t}\n\n\tpublic getInjectedText(outputLineIndex: number, outputOffset: number): InjectedText | null {\n\t\tconst offset = this.outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset);\n\t\tconst injectedText = this.getInjectedTextAtOffset(offset);\n\t\tif (!injectedText) {\n\t\t\treturn null;\n\t\t}\n\t\treturn {\n\t\t\toptions: this.injectionOptions![injectedText.injectedTextIndex]\n\t\t};\n\t}\n\n\tprivate getInjectedTextAtOffset(offsetInInputWithInjections: number): { injectedTextIndex: number; offsetInInputWithInjections: number; length: number } | undefined {\n\t\tconst injectionOffsets = this.injectionOffsets;\n\t\tconst injectionOptions = this.injectionOptions;\n\n\t\tif (injectionOffsets !== null) {\n\t\t\tlet totalInjectedTextLengthBefore = 0;\n\t\t\tfor (let i = 0; i < injectionOffsets.length; i++) {\n\t\t\t\tconst length = injectionOptions![i].content.length;\n\t\t\t\tconst injectedTextStartOffsetInInputWithInjections = injectionOffsets[i] + totalInjectedTextLengthBefore;\n\t\t\t\tconst injectedTextEndOffsetInInputWithInjections = injectionOffsets[i] + totalInjectedTextLengthBefore + length;\n\n\t\t\t\tif (injectedTextStartOffsetInInputWithInjections > offsetInInputWithInjections) {\n\t\t\t\t\t// Injected text starts later.\n\t\t\t\t\tbreak; // All later injected texts have an even larger offset.\n\t\t\t\t}\n\n\t\t\t\tif (offsetInInputWithInjections <= injectedTextEndOffsetInInputWithInjections) {\n\t\t\t\t\t// Injected text ends after or with the given position (but also starts with or before it).\n\t\t\t\t\treturn {\n\t\t\t\t\t\tinjectedTextIndex: i,\n\t\t\t\t\t\toffsetInInputWithInjections: injectedTextStartOffsetInInputWithInjections,\n\t\t\t\t\t\tlength\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\ttotalInjectedTextLengthBefore += length;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n}\n\nfunction hasRightCursorStop(cursorStop: InjectedTextCursorStops | null | undefined): boolean {\n\tif (cursorStop === null || cursorStop === undefined) { return true; }\n\treturn cursorStop === InjectedTextCursorStops.Right || cursorStop === InjectedTextCursorStops.Both;\n}\nfunction hasLeftCursorStop(cursorStop: InjectedTextCursorStops | null | undefined): boolean {\n\tif (cursorStop === null || cursorStop === undefined) { return true; }\n\treturn cursorStop === InjectedTextCursorStops.Left || cursorStop === InjectedTextCursorStops.Both;\n}\n\nexport class InjectedText {\n\tconstructor(public readonly options: InjectedTextOptions) { }\n}\n\nexport class OutputPosition {\n\toutputLineIndex: number;\n\toutputOffset: number;\n\n\tconstructor(outputLineIndex: number, outputOffset: number) {\n\t\tthis.outputLineIndex = outputLineIndex;\n\t\tthis.outputOffset = outputOffset;\n\t}\n\n\ttoString(): string {\n\t\treturn `${this.outputLineIndex}:${this.outputOffset}`;\n\t}\n\n\ttoPosition(baseLineNumber: number): Position {\n\t\treturn new Position(baseLineNumber + this.outputLineIndex, this.outputOffset + 1);\n\t}\n}\n\nexport interface ILineBreaksComputerFactory {\n\tcreateLineBreaksComputer(fontInfo: FontInfo, tabSize: number, wrappingColumn: number, wrappingIndent: WrappingIndent, wordBreak: 'normal' | 'keepAll'): ILineBreaksComputer;\n}\n\nexport interface ILineBreaksComputer {\n\t/**\n\t * Pass in `previousLineBreakData` if the only difference is in breaking columns!!!\n\t */\n\taddRequest(lineText: string, injectedText: LineInjectedText[] | null, previousLineBreakData: ModelLineProjectionData | null): void;\n\tfinalize(): (ModelLineProjectionData | null)[];\n}\n"],
  "mappings": "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",
  "names": []
}
