{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/modelLineProjectionData.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { assertNever } from \"../../base/common/assert.js\";\nimport type { WrappingIndent } from \"./config/editorOptions.js\";\nimport type { FontInfo } from \"./config/fontInfo.js\";\nimport { Position } from \"./core/position.js\";\nimport {\n\tInjectedTextCursorStops,\n\ttype InjectedTextOptions,\n\tPositionAffinity,\n} from \"./model.js\";\nimport type { LineInjectedText } from \"./textModelEvents.js\";\n\n/**\n * *input*:\n * ```\n * xxxxxxxxxxxxxxxxxxxxxxxxxxx\n * ```\n *\n * -> Applying injections `[i...i]`, *inputWithInjections*:\n * ```\n * xxxxxx[iiiiiiiiii]xxxxxxxxxxxxxxxxx[ii]xxxx\n * ```\n *\n * -> breaking at offsets `|` in `xxxxxx[iiiiiii|iii]xxxxxxxxxxx|xxxxxx[ii]xxxx|`:\n * ```\n * xxxxxx[iiiiiii\n * iii]xxxxxxxxxxx\n * xxxxxx[ii]xxxx\n * ```\n *\n * -> applying wrappedTextIndentLength, *output*:\n * ```\n * xxxxxx[iiiiiii\n *    iii]xxxxxxxxxxx\n *    xxxxxx[ii]xxxx\n * ```\n */\nexport class ModelLineProjectionData {\n\tconstructor(\n\t\tpublic injectionOffsets: number[] | null,\n\t\t/**\n\t\t * `injectionOptions.length` must equal `injectionOffsets.length`\n\t\t */\n\t\tpublic injectionOptions: InjectedTextOptions[] | null,\n\t\t/**\n\t\t * Refers to offsets after applying injections to the source.\n\t\t * The last break offset indicates the length of the source after applying injections.\n\t\t */\n\t\tpublic breakOffsets: number[],\n\t\t/**\n\t\t * Refers to offsets after applying injections\n\t\t */\n\t\tpublic breakOffsetsVisibleColumn: number[],\n\t\tpublic wrappedTextIndentLength: number,\n\t) {}\n\n\tpublic getOutputLineCount(): number {\n\t\treturn this.breakOffsets.length;\n\t}\n\n\tpublic getMinOutputOffset(outputLineIndex: number): number {\n\t\tif (outputLineIndex > 0) {\n\t\t\treturn this.wrappedTextIndentLength;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic getLineLength(outputLineIndex: number): number {\n\t\t// These offsets refer to model text with injected text.\n\t\tconst startOffset =\n\t\t\toutputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0;\n\t\tconst endOffset = this.breakOffsets[outputLineIndex];\n\n\t\tlet lineLength = endOffset - startOffset;\n\t\tif (outputLineIndex > 0) {\n\t\t\tlineLength += this.wrappedTextIndentLength;\n\t\t}\n\t\treturn lineLength;\n\t}\n\n\tpublic getMaxOutputOffset(outputLineIndex: number): number {\n\t\treturn this.getLineLength(outputLineIndex);\n\t}\n\n\tpublic translateToInputOffset(\n\t\toutputLineIndex: number,\n\t\toutputOffset: number,\n\t): number {\n\t\tif (outputLineIndex > 0) {\n\t\t\toutputOffset = Math.max(\n\t\t\t\t0,\n\t\t\t\toutputOffset - this.wrappedTextIndentLength,\n\t\t\t);\n\t\t}\n\n\t\tconst offsetInInputWithInjection =\n\t\t\toutputLineIndex === 0\n\t\t\t\t? outputOffset\n\t\t\t\t: this.breakOffsets[outputLineIndex - 1] + outputOffset;\n\t\tlet offsetInInput = offsetInInputWithInjection;\n\n\t\tif (this.injectionOffsets !== null) {\n\t\t\tfor (let i = 0; i < this.injectionOffsets.length; i++) {\n\t\t\t\tif (offsetInInput > this.injectionOffsets[i]) {\n\t\t\t\t\tif (\n\t\t\t\t\t\toffsetInInput <\n\t\t\t\t\t\tthis.injectionOffsets[i] +\n\t\t\t\t\t\t\tthis.injectionOptions![i].content.length\n\t\t\t\t\t) {\n\t\t\t\t\t\t// `inputOffset` is within injected text\n\t\t\t\t\t\toffsetInInput = this.injectionOffsets[i];\n\t\t\t\t\t} else {\n\t\t\t\t\t\toffsetInInput -=\n\t\t\t\t\t\t\tthis.injectionOptions![i].content.length;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn offsetInInput;\n\t}\n\n\tpublic translateToOutputPosition(\n\t\tinputOffset: number,\n\t\taffinity: PositionAffinity = PositionAffinity.None,\n\t): OutputPosition {\n\t\tlet inputOffsetInInputWithInjection = inputOffset;\n\t\tif (this.injectionOffsets !== null) {\n\t\t\tfor (let i = 0; i < this.injectionOffsets.length; i++) {\n\t\t\t\tif (inputOffset < this.injectionOffsets[i]) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\taffinity !== PositionAffinity.Right &&\n\t\t\t\t\tinputOffset === this.injectionOffsets[i]\n\t\t\t\t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tinputOffsetInInputWithInjection +=\n\t\t\t\t\tthis.injectionOptions![i].content.length;\n\t\t\t}\n\t\t}\n\n\t\treturn this.offsetInInputWithInjectionsToOutputPosition(\n\t\t\tinputOffsetInInputWithInjection,\n\t\t\taffinity,\n\t\t);\n\t}\n\n\tprivate offsetInInputWithInjectionsToOutputPosition(\n\t\toffsetInInputWithInjections: number,\n\t\taffinity: PositionAffinity = PositionAffinity.None,\n\t): OutputPosition {\n\t\tlet low = 0;\n\t\tlet high = this.breakOffsets.length - 1;\n\t\tlet mid = 0;\n\t\tlet midStart = 0;\n\n\t\twhile (low <= high) {\n\t\t\tmid = (low + (high - low) / 2) | 0;\n\n\t\t\tconst midStop = this.breakOffsets[mid];\n\t\t\tmidStart = mid > 0 ? this.breakOffsets[mid - 1] : 0;\n\n\t\t\tif (affinity === PositionAffinity.Left) {\n\t\t\t\tif (offsetInInputWithInjections <= midStart) {\n\t\t\t\t\thigh = mid - 1;\n\t\t\t\t} else if (offsetInInputWithInjections > midStop) {\n\t\t\t\t\tlow = mid + 1;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (offsetInInputWithInjections < midStart) {\n\t\t\t\thigh = mid - 1;\n\t\t\t} else if (offsetInInputWithInjections >= midStop) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tlet outputOffset = offsetInInputWithInjections - midStart;\n\t\tif (mid > 0) {\n\t\t\toutputOffset += this.wrappedTextIndentLength;\n\t\t}\n\n\t\treturn new OutputPosition(mid, outputOffset);\n\t}\n\n\tpublic normalizeOutputPosition(\n\t\toutputLineIndex: number,\n\t\toutputOffset: number,\n\t\taffinity: PositionAffinity,\n\t): OutputPosition {\n\t\tif (this.injectionOffsets !== null) {\n\t\t\tconst offsetInInputWithInjections =\n\t\t\t\tthis.outputPositionToOffsetInInputWithInjections(\n\t\t\t\t\toutputLineIndex,\n\t\t\t\t\toutputOffset,\n\t\t\t\t);\n\t\t\tconst normalizedOffsetInUnwrappedLine =\n\t\t\t\tthis.normalizeOffsetInInputWithInjectionsAroundInjections(\n\t\t\t\t\toffsetInInputWithInjections,\n\t\t\t\t\taffinity,\n\t\t\t\t);\n\t\t\tif (\n\t\t\t\tnormalizedOffsetInUnwrappedLine !== offsetInInputWithInjections\n\t\t\t) {\n\t\t\t\t// injected text caused a change\n\t\t\t\treturn this.offsetInInputWithInjectionsToOutputPosition(\n\t\t\t\t\tnormalizedOffsetInUnwrappedLine,\n\t\t\t\t\taffinity,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tif (affinity === PositionAffinity.Left) {\n\t\t\tif (\n\t\t\t\toutputLineIndex > 0 &&\n\t\t\t\toutputOffset === this.getMinOutputOffset(outputLineIndex)\n\t\t\t) {\n\t\t\t\treturn new OutputPosition(\n\t\t\t\t\toutputLineIndex - 1,\n\t\t\t\t\tthis.getMaxOutputOffset(outputLineIndex - 1),\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (affinity === PositionAffinity.Right) {\n\t\t\tconst maxOutputLineIndex = this.getOutputLineCount() - 1;\n\t\t\tif (\n\t\t\t\toutputLineIndex < maxOutputLineIndex &&\n\t\t\t\toutputOffset === this.getMaxOutputOffset(outputLineIndex)\n\t\t\t) {\n\t\t\t\treturn new OutputPosition(\n\t\t\t\t\toutputLineIndex + 1,\n\t\t\t\t\tthis.getMinOutputOffset(outputLineIndex + 1),\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn new OutputPosition(outputLineIndex, outputOffset);\n\t}\n\n\tprivate outputPositionToOffsetInInputWithInjections(\n\t\toutputLineIndex: number,\n\t\toutputOffset: number,\n\t): number {\n\t\tif (outputLineIndex > 0) {\n\t\t\toutputOffset = Math.max(\n\t\t\t\t0,\n\t\t\t\toutputOffset - this.wrappedTextIndentLength,\n\t\t\t);\n\t\t}\n\t\tconst result =\n\t\t\t(outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0) +\n\t\t\toutputOffset;\n\t\treturn result;\n\t}\n\n\tprivate normalizeOffsetInInputWithInjectionsAroundInjections(\n\t\toffsetInInputWithInjections: number,\n\t\taffinity: PositionAffinity,\n\t): number {\n\t\tconst injectedText = this.getInjectedTextAtOffset(\n\t\t\toffsetInInputWithInjections,\n\t\t);\n\t\tif (!injectedText) {\n\t\t\treturn offsetInInputWithInjections;\n\t\t}\n\n\t\tif (affinity === PositionAffinity.None) {\n\t\t\tif (\n\t\t\t\toffsetInInputWithInjections ===\n\t\t\t\t\tinjectedText.offsetInInputWithInjections +\n\t\t\t\t\t\tinjectedText.length &&\n\t\t\t\thasRightCursorStop(\n\t\t\t\t\tthis.injectionOptions![injectedText.injectedTextIndex]\n\t\t\t\t\t\t.cursorStops,\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\treturn (\n\t\t\t\t\tinjectedText.offsetInInputWithInjections +\n\t\t\t\t\tinjectedText.length\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tlet result = injectedText.offsetInInputWithInjections;\n\t\t\t\tif (\n\t\t\t\t\thasLeftCursorStop(\n\t\t\t\t\t\tthis.injectionOptions![injectedText.injectedTextIndex]\n\t\t\t\t\t\t\t.cursorStops,\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tlet index = injectedText.injectedTextIndex - 1;\n\t\t\t\twhile (\n\t\t\t\t\tindex >= 0 &&\n\t\t\t\t\tthis.injectionOffsets![index] ===\n\t\t\t\t\t\tthis.injectionOffsets![injectedText.injectedTextIndex]\n\t\t\t\t) {\n\t\t\t\t\tif (\n\t\t\t\t\t\thasRightCursorStop(\n\t\t\t\t\t\t\tthis.injectionOptions![index].cursorStops,\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tresult -= this.injectionOptions![index].content.length;\n\t\t\t\t\tif (\n\t\t\t\t\t\thasLeftCursorStop(\n\t\t\t\t\t\t\tthis.injectionOptions![index].cursorStops,\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t} else if (\n\t\t\taffinity === PositionAffinity.Right ||\n\t\t\taffinity === PositionAffinity.RightOfInjectedText\n\t\t) {\n\t\t\tlet result =\n\t\t\t\tinjectedText.offsetInInputWithInjections + injectedText.length;\n\t\t\tlet index = injectedText.injectedTextIndex;\n\t\t\t// traverse all injected text that touch each other\n\t\t\twhile (\n\t\t\t\tindex + 1 < this.injectionOffsets!.length &&\n\t\t\t\tthis.injectionOffsets![index + 1] ===\n\t\t\t\t\tthis.injectionOffsets![index]\n\t\t\t) {\n\t\t\t\tresult += this.injectionOptions![index + 1].content.length;\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\treturn result;\n\t\t} else if (\n\t\t\taffinity === PositionAffinity.Left ||\n\t\t\taffinity === PositionAffinity.LeftOfInjectedText\n\t\t) {\n\t\t\t// affinity is left\n\t\t\tlet result = injectedText.offsetInInputWithInjections;\n\t\t\tlet index = injectedText.injectedTextIndex;\n\t\t\t// traverse all injected text that touch each other\n\t\t\twhile (\n\t\t\t\tindex - 1 >= 0 &&\n\t\t\t\tthis.injectionOffsets![index - 1] ===\n\t\t\t\t\tthis.injectionOffsets![index]\n\t\t\t) {\n\t\t\t\tresult -= this.injectionOptions![index - 1].content.length;\n\t\t\t\tindex--;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tassertNever(affinity);\n\t}\n\n\tpublic getInjectedText(\n\t\toutputLineIndex: number,\n\t\toutputOffset: number,\n\t): InjectedText | null {\n\t\tconst offset = this.outputPositionToOffsetInInputWithInjections(\n\t\t\toutputLineIndex,\n\t\t\toutputOffset,\n\t\t);\n\t\tconst injectedText = this.getInjectedTextAtOffset(offset);\n\t\tif (!injectedText) {\n\t\t\treturn null;\n\t\t}\n\t\treturn {\n\t\t\toptions: this.injectionOptions![injectedText.injectedTextIndex],\n\t\t};\n\t}\n\n\tprivate getInjectedTextAtOffset(\n\t\toffsetInInputWithInjections: number,\n\t):\n\t\t| {\n\t\t\t\tinjectedTextIndex: number;\n\t\t\t\toffsetInInputWithInjections: number;\n\t\t\t\tlength: number;\n\t\t  }\n\t\t| undefined {\n\t\tconst injectionOffsets = this.injectionOffsets;\n\t\tconst injectionOptions = this.injectionOptions;\n\n\t\tif (injectionOffsets !== null) {\n\t\t\tlet totalInjectedTextLengthBefore = 0;\n\t\t\tfor (let i = 0; i < injectionOffsets.length; i++) {\n\t\t\t\tconst length = injectionOptions![i].content.length;\n\t\t\t\tconst injectedTextStartOffsetInInputWithInjections =\n\t\t\t\t\tinjectionOffsets[i] + totalInjectedTextLengthBefore;\n\t\t\t\tconst injectedTextEndOffsetInInputWithInjections =\n\t\t\t\t\tinjectionOffsets[i] +\n\t\t\t\t\ttotalInjectedTextLengthBefore +\n\t\t\t\t\tlength;\n\n\t\t\t\tif (\n\t\t\t\t\tinjectedTextStartOffsetInInputWithInjections >\n\t\t\t\t\toffsetInInputWithInjections\n\t\t\t\t) {\n\t\t\t\t\t// Injected text starts later.\n\t\t\t\t\tbreak; // All later injected texts have an even larger offset.\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\toffsetInInputWithInjections <=\n\t\t\t\t\tinjectedTextEndOffsetInInputWithInjections\n\t\t\t\t) {\n\t\t\t\t\t// Injected text ends after or with the given position (but also starts with or before it).\n\t\t\t\t\treturn {\n\t\t\t\t\t\tinjectedTextIndex: i,\n\t\t\t\t\t\toffsetInInputWithInjections:\n\t\t\t\t\t\t\tinjectedTextStartOffsetInInputWithInjections,\n\t\t\t\t\t\tlength,\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\ttotalInjectedTextLengthBefore += length;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n}\n\nfunction hasRightCursorStop(\n\tcursorStop: InjectedTextCursorStops | null | undefined,\n): boolean {\n\tif (cursorStop === null || cursorStop === undefined) {\n\t\treturn true;\n\t}\n\treturn (\n\t\tcursorStop === InjectedTextCursorStops.Right ||\n\t\tcursorStop === InjectedTextCursorStops.Both\n\t);\n}\nfunction hasLeftCursorStop(\n\tcursorStop: InjectedTextCursorStops | null | undefined,\n): boolean {\n\tif (cursorStop === null || cursorStop === undefined) {\n\t\treturn true;\n\t}\n\treturn (\n\t\tcursorStop === InjectedTextCursorStops.Left ||\n\t\tcursorStop === InjectedTextCursorStops.Both\n\t);\n}\n\nexport class InjectedText {\n\tconstructor(public readonly options: InjectedTextOptions) {}\n}\n\nexport class OutputPosition {\n\toutputLineIndex: number;\n\toutputOffset: number;\n\n\tconstructor(outputLineIndex: number, outputOffset: number) {\n\t\tthis.outputLineIndex = outputLineIndex;\n\t\tthis.outputOffset = outputOffset;\n\t}\n\n\ttoString(): string {\n\t\treturn `${this.outputLineIndex}:${this.outputOffset}`;\n\t}\n\n\ttoPosition(baseLineNumber: number): Position {\n\t\treturn new Position(\n\t\t\tbaseLineNumber + this.outputLineIndex,\n\t\t\tthis.outputOffset + 1,\n\t\t);\n\t}\n}\n\nexport interface ILineBreaksComputerFactory {\n\tcreateLineBreaksComputer(\n\t\tfontInfo: FontInfo,\n\t\ttabSize: number,\n\t\twrappingColumn: number,\n\t\twrappingIndent: WrappingIndent,\n\t\twordBreak: \"normal\" | \"keepAll\",\n\t): ILineBreaksComputer;\n}\n\nexport interface ILineBreaksComputer {\n\t/**\n\t * Pass in `previousLineBreakData` if the only difference is in breaking columns!!!\n\t */\n\taddRequest(\n\t\tlineText: string,\n\t\tinjectedText: LineInjectedText[] | null,\n\t\tpreviousLineBreakData: ModelLineProjectionData | null,\n\t): void;\n\tfinalize(): (ModelLineProjectionData | null)[];\n}\n"],
  "mappings": "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",
  "names": []
}
