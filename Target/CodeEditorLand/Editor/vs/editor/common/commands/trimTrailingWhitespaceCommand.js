import*as h from"../../../base/common/strings.js";import{EditOperation as S}from"../core/editOperation.js";import"../core/position.js";import{Range as x}from"../core/range.js";import"../core/selection.js";import"../editorCommon.js";import{StandardTokenType as I}from"../encodedTokenAttributes.js";import"../model.js";class W{_selection;_selectionId;_cursors;_trimInRegexesAndStrings;constructor(t,n,i){this._selection=t,this._cursors=n,this._selectionId=null,this._trimInRegexesAndStrings=i}getEditOperations(t,n){const i=T(t,this._cursors,this._trimInRegexesAndStrings);for(let s=0,o=i.length;s<o;s++){const m=i[s];n.addEditOperation(m.range,m.text)}this._selectionId=n.trackSelection(this._selection)}computeCursorState(t,n){return n.getTrackedSelection(this._selectionId)}}function T(l,t,n){t.sort((e,a)=>e.lineNumber===a.lineNumber?e.column-a.column:e.lineNumber-a.lineNumber);for(let e=t.length-2;e>=0;e--)t[e].lineNumber===t[e+1].lineNumber&&t.splice(e,1);const i=[];let s=0,o=0;const m=t.length;for(let e=1,a=l.getLineCount();e<=a;e++){const c=l.getLineContent(e),u=c.length+1;let d=0;if(o<m&&t[o].lineNumber===e&&(d=t[o].column,o++,d===u)||c.length===0)continue;const p=h.lastNonWhitespaceIndex(c);let r=0;if(p===-1)r=1;else if(p!==c.length-1)r=p+2;else continue;if(!n){if(!l.tokenization.hasAccurateTokensForLine(e))continue;const g=l.tokenization.getLineTokens(e),f=g.getStandardTokenType(g.findTokenIndexAtOffset(r));if(f===I.String||f===I.RegEx)continue}r=Math.max(d,r),i[s++]=S.delete(new x(e,r,e,u))}return i}export{W as TrimTrailingWhitespaceCommand,T as trimTrailingWhitespace};
