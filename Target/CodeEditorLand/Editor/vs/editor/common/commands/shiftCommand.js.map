{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/commands/shiftCommand.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from \"../../../base/common/charCode.js\";\nimport * as strings from \"../../../base/common/strings.js\";\nimport type { EditorAutoIndentStrategy } from \"../config/editorOptions.js\";\nimport { CursorColumns } from \"../core/cursorColumns.js\";\nimport { Range } from \"../core/range.js\";\nimport { Selection, SelectionDirection } from \"../core/selection.js\";\nimport type {\n\tICommand,\n\tICursorStateComputerData,\n\tIEditOperationBuilder,\n} from \"../editorCommon.js\";\nimport { getEnterAction } from \"../languages/enterAction.js\";\nimport { ILanguageConfigurationService } from \"../languages/languageConfigurationRegistry.js\";\nimport type { ITextModel } from \"../model.js\";\n\nexport interface IShiftCommandOpts {\n\tisUnshift: boolean;\n\ttabSize: number;\n\tindentSize: number;\n\tinsertSpaces: boolean;\n\tuseTabStops: boolean;\n\tautoIndent: EditorAutoIndentStrategy;\n}\n\nconst repeatCache: { [str: string]: string[] } = Object.create(null);\nfunction cachedStringRepeat(str: string, count: number): string {\n\tif (count <= 0) {\n\t\treturn \"\";\n\t}\n\tif (!repeatCache[str]) {\n\t\trepeatCache[str] = [\"\", str];\n\t}\n\tconst cache = repeatCache[str];\n\tfor (let i = cache.length; i <= count; i++) {\n\t\tcache[i] = cache[i - 1] + str;\n\t}\n\treturn cache[count];\n}\n\nexport class ShiftCommand implements ICommand {\n\tpublic static unshiftIndent(\n\t\tline: string,\n\t\tcolumn: number,\n\t\ttabSize: number,\n\t\tindentSize: number,\n\t\tinsertSpaces: boolean,\n\t): string {\n\t\t// Determine the visible column where the content starts\n\t\tconst contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(\n\t\t\tline,\n\t\t\tcolumn,\n\t\t\ttabSize,\n\t\t);\n\n\t\tif (insertSpaces) {\n\t\t\tconst indent = cachedStringRepeat(\" \", indentSize);\n\t\t\tconst desiredTabStop = CursorColumns.prevIndentTabStop(\n\t\t\t\tcontentStartVisibleColumn,\n\t\t\t\tindentSize,\n\t\t\t);\n\t\t\tconst indentCount = desiredTabStop / indentSize; // will be an integer\n\t\t\treturn cachedStringRepeat(indent, indentCount);\n\t\t} else {\n\t\t\tconst indent = \"\\t\";\n\t\t\tconst desiredTabStop = CursorColumns.prevRenderTabStop(\n\t\t\t\tcontentStartVisibleColumn,\n\t\t\t\ttabSize,\n\t\t\t);\n\t\t\tconst indentCount = desiredTabStop / tabSize; // will be an integer\n\t\t\treturn cachedStringRepeat(indent, indentCount);\n\t\t}\n\t}\n\n\tpublic static shiftIndent(\n\t\tline: string,\n\t\tcolumn: number,\n\t\ttabSize: number,\n\t\tindentSize: number,\n\t\tinsertSpaces: boolean,\n\t): string {\n\t\t// Determine the visible column where the content starts\n\t\tconst contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(\n\t\t\tline,\n\t\t\tcolumn,\n\t\t\ttabSize,\n\t\t);\n\n\t\tif (insertSpaces) {\n\t\t\tconst indent = cachedStringRepeat(\" \", indentSize);\n\t\t\tconst desiredTabStop = CursorColumns.nextIndentTabStop(\n\t\t\t\tcontentStartVisibleColumn,\n\t\t\t\tindentSize,\n\t\t\t);\n\t\t\tconst indentCount = desiredTabStop / indentSize; // will be an integer\n\t\t\treturn cachedStringRepeat(indent, indentCount);\n\t\t} else {\n\t\t\tconst indent = \"\\t\";\n\t\t\tconst desiredTabStop = CursorColumns.nextRenderTabStop(\n\t\t\t\tcontentStartVisibleColumn,\n\t\t\t\ttabSize,\n\t\t\t);\n\t\t\tconst indentCount = desiredTabStop / tabSize; // will be an integer\n\t\t\treturn cachedStringRepeat(indent, indentCount);\n\t\t}\n\t}\n\n\tprivate readonly _opts: IShiftCommandOpts;\n\tprivate readonly _selection: Selection;\n\tprivate _selectionId: string | null;\n\tprivate _useLastEditRangeForCursorEndPosition: boolean;\n\tprivate _selectionStartColumnStaysPut: boolean;\n\n\tconstructor(\n\t\trange: Selection,\n\t\topts: IShiftCommandOpts,\n\t\t@ILanguageConfigurationService private readonly _languageConfigurationService: ILanguageConfigurationService\n\t) {\n\t\tthis._opts = opts;\n\t\tthis._selection = range;\n\t\tthis._selectionId = null;\n\t\tthis._useLastEditRangeForCursorEndPosition = false;\n\t\tthis._selectionStartColumnStaysPut = false;\n\t}\n\n\tprivate _addEditOperation(\n\t\tbuilder: IEditOperationBuilder,\n\t\trange: Range,\n\t\ttext: string,\n\t) {\n\t\tif (this._useLastEditRangeForCursorEndPosition) {\n\t\t\tbuilder.addTrackedEditOperation(range, text);\n\t\t} else {\n\t\t\tbuilder.addEditOperation(range, text);\n\t\t}\n\t}\n\n\tpublic getEditOperations(\n\t\tmodel: ITextModel,\n\t\tbuilder: IEditOperationBuilder,\n\t): void {\n\t\tconst startLine = this._selection.startLineNumber;\n\n\t\tlet endLine = this._selection.endLineNumber;\n\t\tif (this._selection.endColumn === 1 && startLine !== endLine) {\n\t\t\tendLine = endLine - 1;\n\t\t}\n\n\t\tconst { tabSize, indentSize, insertSpaces } = this._opts;\n\t\tconst shouldIndentEmptyLines = startLine === endLine;\n\n\t\tif (this._opts.useTabStops) {\n\t\t\t// if indenting or outdenting on a whitespace only line\n\t\t\tif (this._selection.isEmpty()) {\n\t\t\t\tif (/^\\s*$/.test(model.getLineContent(startLine))) {\n\t\t\t\t\tthis._useLastEditRangeForCursorEndPosition = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// keep track of previous line's \"miss-alignment\"\n\t\t\tlet previousLineExtraSpaces = 0,\n\t\t\t\textraSpaces = 0;\n\t\t\tfor (\n\t\t\t\tlet lineNumber = startLine;\n\t\t\t\tlineNumber <= endLine;\n\t\t\t\tlineNumber++, previousLineExtraSpaces = extraSpaces\n\t\t\t) {\n\t\t\t\textraSpaces = 0;\n\t\t\t\tconst lineText = model.getLineContent(lineNumber);\n\t\t\t\tlet indentationEndIndex =\n\t\t\t\t\tstrings.firstNonWhitespaceIndex(lineText);\n\n\t\t\t\tif (\n\t\t\t\t\tthis._opts.isUnshift &&\n\t\t\t\t\t(lineText.length === 0 || indentationEndIndex === 0)\n\t\t\t\t) {\n\t\t\t\t\t// empty line or line with no leading whitespace => nothing to do\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t!shouldIndentEmptyLines &&\n\t\t\t\t\t!this._opts.isUnshift &&\n\t\t\t\t\tlineText.length === 0\n\t\t\t\t) {\n\t\t\t\t\t// do not indent empty lines => nothing to do\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (indentationEndIndex === -1) {\n\t\t\t\t\t// the entire line is whitespace\n\t\t\t\t\tindentationEndIndex = lineText.length;\n\t\t\t\t}\n\n\t\t\t\tif (lineNumber > 1) {\n\t\t\t\t\tconst contentStartVisibleColumn =\n\t\t\t\t\t\tCursorColumns.visibleColumnFromColumn(\n\t\t\t\t\t\t\tlineText,\n\t\t\t\t\t\t\tindentationEndIndex + 1,\n\t\t\t\t\t\t\ttabSize,\n\t\t\t\t\t\t);\n\t\t\t\t\tif (contentStartVisibleColumn % indentSize !== 0) {\n\t\t\t\t\t\t// The current line is \"miss-aligned\", so let's see if this is expected...\n\t\t\t\t\t\t// This can only happen when it has trailing commas in the indent\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tmodel.tokenization.isCheapToTokenize(lineNumber - 1)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst enterAction = getEnterAction(\n\t\t\t\t\t\t\t\tthis._opts.autoIndent,\n\t\t\t\t\t\t\t\tmodel,\n\t\t\t\t\t\t\t\tnew Range(\n\t\t\t\t\t\t\t\t\tlineNumber - 1,\n\t\t\t\t\t\t\t\t\tmodel.getLineMaxColumn(lineNumber - 1),\n\t\t\t\t\t\t\t\t\tlineNumber - 1,\n\t\t\t\t\t\t\t\t\tmodel.getLineMaxColumn(lineNumber - 1),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\tthis._languageConfigurationService,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (enterAction) {\n\t\t\t\t\t\t\t\textraSpaces = previousLineExtraSpaces;\n\t\t\t\t\t\t\t\tif (enterAction.appendText) {\n\t\t\t\t\t\t\t\t\tfor (\n\t\t\t\t\t\t\t\t\t\tlet j = 0,\n\t\t\t\t\t\t\t\t\t\t\tlenJ =\n\t\t\t\t\t\t\t\t\t\t\t\tenterAction.appendText.length;\n\t\t\t\t\t\t\t\t\t\tj < lenJ && extraSpaces < indentSize;\n\t\t\t\t\t\t\t\t\t\tj++\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\tenterAction.appendText.charCodeAt(\n\t\t\t\t\t\t\t\t\t\t\t\tj,\n\t\t\t\t\t\t\t\t\t\t\t) === CharCode.Space\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\textraSpaces++;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (enterAction.removeText) {\n\t\t\t\t\t\t\t\t\textraSpaces = Math.max(\n\t\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t\t\textraSpaces - enterAction.removeText,\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Act as if `prefixSpaces` is not part of the indentation\n\t\t\t\t\t\t\t\tfor (let j = 0; j < extraSpaces; j++) {\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tindentationEndIndex === 0 ||\n\t\t\t\t\t\t\t\t\t\tlineText.charCodeAt(\n\t\t\t\t\t\t\t\t\t\t\tindentationEndIndex - 1,\n\t\t\t\t\t\t\t\t\t\t) !== CharCode.Space\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tindentationEndIndex--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (this._opts.isUnshift && indentationEndIndex === 0) {\n\t\t\t\t\t// line with no leading whitespace => nothing to do\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet desiredIndent: string;\n\t\t\t\tif (this._opts.isUnshift) {\n\t\t\t\t\tdesiredIndent = ShiftCommand.unshiftIndent(\n\t\t\t\t\t\tlineText,\n\t\t\t\t\t\tindentationEndIndex + 1,\n\t\t\t\t\t\ttabSize,\n\t\t\t\t\t\tindentSize,\n\t\t\t\t\t\tinsertSpaces,\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tdesiredIndent = ShiftCommand.shiftIndent(\n\t\t\t\t\t\tlineText,\n\t\t\t\t\t\tindentationEndIndex + 1,\n\t\t\t\t\t\ttabSize,\n\t\t\t\t\t\tindentSize,\n\t\t\t\t\t\tinsertSpaces,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tthis._addEditOperation(\n\t\t\t\t\tbuilder,\n\t\t\t\t\tnew Range(\n\t\t\t\t\t\tlineNumber,\n\t\t\t\t\t\t1,\n\t\t\t\t\t\tlineNumber,\n\t\t\t\t\t\tindentationEndIndex + 1,\n\t\t\t\t\t),\n\t\t\t\t\tdesiredIndent,\n\t\t\t\t);\n\t\t\t\tif (lineNumber === startLine && !this._selection.isEmpty()) {\n\t\t\t\t\t// Force the startColumn to stay put because we're inserting after it\n\t\t\t\t\tthis._selectionStartColumnStaysPut =\n\t\t\t\t\t\tthis._selection.startColumn <= indentationEndIndex + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// if indenting or outdenting on a whitespace only line\n\t\t\tif (\n\t\t\t\t!this._opts.isUnshift &&\n\t\t\t\tthis._selection.isEmpty() &&\n\t\t\t\tmodel.getLineLength(startLine) === 0\n\t\t\t) {\n\t\t\t\tthis._useLastEditRangeForCursorEndPosition = true;\n\t\t\t}\n\n\t\t\tconst oneIndent = insertSpaces\n\t\t\t\t? cachedStringRepeat(\" \", indentSize)\n\t\t\t\t: \"\\t\";\n\n\t\t\tfor (\n\t\t\t\tlet lineNumber = startLine;\n\t\t\t\tlineNumber <= endLine;\n\t\t\t\tlineNumber++\n\t\t\t) {\n\t\t\t\tconst lineText = model.getLineContent(lineNumber);\n\t\t\t\tlet indentationEndIndex =\n\t\t\t\t\tstrings.firstNonWhitespaceIndex(lineText);\n\n\t\t\t\tif (\n\t\t\t\t\tthis._opts.isUnshift &&\n\t\t\t\t\t(lineText.length === 0 || indentationEndIndex === 0)\n\t\t\t\t) {\n\t\t\t\t\t// empty line or line with no leading whitespace => nothing to do\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t!shouldIndentEmptyLines &&\n\t\t\t\t\t!this._opts.isUnshift &&\n\t\t\t\t\tlineText.length === 0\n\t\t\t\t) {\n\t\t\t\t\t// do not indent empty lines => nothing to do\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (indentationEndIndex === -1) {\n\t\t\t\t\t// the entire line is whitespace\n\t\t\t\t\tindentationEndIndex = lineText.length;\n\t\t\t\t}\n\n\t\t\t\tif (this._opts.isUnshift && indentationEndIndex === 0) {\n\t\t\t\t\t// line with no leading whitespace => nothing to do\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (this._opts.isUnshift) {\n\t\t\t\t\tindentationEndIndex = Math.min(\n\t\t\t\t\t\tindentationEndIndex,\n\t\t\t\t\t\tindentSize,\n\t\t\t\t\t);\n\t\t\t\t\tfor (let i = 0; i < indentationEndIndex; i++) {\n\t\t\t\t\t\tconst chr = lineText.charCodeAt(i);\n\t\t\t\t\t\tif (chr === CharCode.Tab) {\n\t\t\t\t\t\t\tindentationEndIndex = i + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._addEditOperation(\n\t\t\t\t\t\tbuilder,\n\t\t\t\t\t\tnew Range(\n\t\t\t\t\t\t\tlineNumber,\n\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\tlineNumber,\n\t\t\t\t\t\t\tindentationEndIndex + 1,\n\t\t\t\t\t\t),\n\t\t\t\t\t\t\"\",\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tthis._addEditOperation(\n\t\t\t\t\t\tbuilder,\n\t\t\t\t\t\tnew Range(lineNumber, 1, lineNumber, 1),\n\t\t\t\t\t\toneIndent,\n\t\t\t\t\t);\n\t\t\t\t\tif (\n\t\t\t\t\t\tlineNumber === startLine &&\n\t\t\t\t\t\t!this._selection.isEmpty()\n\t\t\t\t\t) {\n\t\t\t\t\t\t// Force the startColumn to stay put because we're inserting after it\n\t\t\t\t\t\tthis._selectionStartColumnStaysPut =\n\t\t\t\t\t\t\tthis._selection.startColumn === 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._selectionId = builder.trackSelection(this._selection);\n\t}\n\n\tpublic computeCursorState(\n\t\tmodel: ITextModel,\n\t\thelper: ICursorStateComputerData,\n\t): Selection {\n\t\tif (this._useLastEditRangeForCursorEndPosition) {\n\t\t\tconst lastOp = helper.getInverseEditOperations()[0];\n\t\t\treturn new Selection(\n\t\t\t\tlastOp.range.endLineNumber,\n\t\t\t\tlastOp.range.endColumn,\n\t\t\t\tlastOp.range.endLineNumber,\n\t\t\t\tlastOp.range.endColumn,\n\t\t\t);\n\t\t}\n\t\tconst result = helper.getTrackedSelection(this._selectionId!);\n\n\t\tif (this._selectionStartColumnStaysPut) {\n\t\t\t// The selection start should not move\n\t\t\tconst initialStartColumn = this._selection.startColumn;\n\t\t\tconst resultStartColumn = result.startColumn;\n\t\t\tif (resultStartColumn <= initialStartColumn) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tif (result.getDirection() === SelectionDirection.LTR) {\n\t\t\t\treturn new Selection(\n\t\t\t\t\tresult.startLineNumber,\n\t\t\t\t\tinitialStartColumn,\n\t\t\t\t\tresult.endLineNumber,\n\t\t\t\t\tresult.endColumn,\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn new Selection(\n\t\t\t\tresult.endLineNumber,\n\t\t\t\tresult.endColumn,\n\t\t\t\tresult.startLineNumber,\n\t\t\t\tinitialStartColumn,\n\t\t\t);\n\t\t}\n\n\t\treturn result;\n\t}\n}\n"],
  "mappings": ";;;;;;;;;;;;AAKA,SAAS,gBAAgB;AACzB,YAAY,aAAa;AAEzB,SAAS,qBAAqB;AAC9B,SAAS,aAAa;AACtB,SAAS,WAAW,0BAA0B;AAM9C,SAAS,sBAAsB;AAC/B,SAAS,qCAAqC;AAY9C,MAAM,cAA2C,uBAAO,OAAO,IAAI;AACnE,SAAS,mBAAmB,KAAa,OAAuB;AAC/D,MAAI,SAAS,GAAG;AACf,WAAO;AAAA,EACR;AACA,MAAI,CAAC,YAAY,GAAG,GAAG;AACtB,gBAAY,GAAG,IAAI,CAAC,IAAI,GAAG;AAAA,EAC5B;AACA,QAAM,QAAQ,YAAY,GAAG;AAC7B,WAAS,IAAI,MAAM,QAAQ,KAAK,OAAO,KAAK;AAC3C,UAAM,CAAC,IAAI,MAAM,IAAI,CAAC,IAAI;AAAA,EAC3B;AACA,SAAO,MAAM,KAAK;AACnB;AAZS;AAcF,IAAM,eAAN,MAAuC;AAAA,EAyE7C,YACC,OACA,MACgD,+BAC/C;AAD+C;AAEhD,SAAK,QAAQ;AACb,SAAK,aAAa;AAClB,SAAK,eAAe;AACpB,SAAK,wCAAwC;AAC7C,SAAK,gCAAgC;AAAA,EACtC;AAAA,EA/HD,OA4C8C;AAAA;AAAA;AAAA,EAC7C,OAAc,cACb,MACA,QACA,SACA,YACA,cACS;AAET,UAAM,4BAA4B,cAAc;AAAA,MAC/C;AAAA,MACA;AAAA,MACA;AAAA,IACD;AAEA,QAAI,cAAc;AACjB,YAAM,SAAS,mBAAmB,KAAK,UAAU;AACjD,YAAM,iBAAiB,cAAc;AAAA,QACpC;AAAA,QACA;AAAA,MACD;AACA,YAAM,cAAc,iBAAiB;AACrC,aAAO,mBAAmB,QAAQ,WAAW;AAAA,IAC9C,OAAO;AACN,YAAM,SAAS;AACf,YAAM,iBAAiB,cAAc;AAAA,QACpC;AAAA,QACA;AAAA,MACD;AACA,YAAM,cAAc,iBAAiB;AACrC,aAAO,mBAAmB,QAAQ,WAAW;AAAA,IAC9C;AAAA,EACD;AAAA,EAEA,OAAc,YACb,MACA,QACA,SACA,YACA,cACS;AAET,UAAM,4BAA4B,cAAc;AAAA,MAC/C;AAAA,MACA;AAAA,MACA;AAAA,IACD;AAEA,QAAI,cAAc;AACjB,YAAM,SAAS,mBAAmB,KAAK,UAAU;AACjD,YAAM,iBAAiB,cAAc;AAAA,QACpC;AAAA,QACA;AAAA,MACD;AACA,YAAM,cAAc,iBAAiB;AACrC,aAAO,mBAAmB,QAAQ,WAAW;AAAA,IAC9C,OAAO;AACN,YAAM,SAAS;AACf,YAAM,iBAAiB,cAAc;AAAA,QACpC;AAAA,QACA;AAAA,MACD;AACA,YAAM,cAAc,iBAAiB;AACrC,aAAO,mBAAmB,QAAQ,WAAW;AAAA,IAC9C;AAAA,EACD;AAAA,EAEiB;AAAA,EACA;AAAA,EACT;AAAA,EACA;AAAA,EACA;AAAA,EAcA,kBACP,SACA,OACA,MACC;AACD,QAAI,KAAK,uCAAuC;AAC/C,cAAQ,wBAAwB,OAAO,IAAI;AAAA,IAC5C,OAAO;AACN,cAAQ,iBAAiB,OAAO,IAAI;AAAA,IACrC;AAAA,EACD;AAAA,EAEO,kBACN,OACA,SACO;AACP,UAAM,YAAY,KAAK,WAAW;AAElC,QAAI,UAAU,KAAK,WAAW;AAC9B,QAAI,KAAK,WAAW,cAAc,KAAK,cAAc,SAAS;AAC7D,gBAAU,UAAU;AAAA,IACrB;AAEA,UAAM,EAAE,SAAS,YAAY,aAAa,IAAI,KAAK;AACnD,UAAM,yBAAyB,cAAc;AAE7C,QAAI,KAAK,MAAM,aAAa;AAE3B,UAAI,KAAK,WAAW,QAAQ,GAAG;AAC9B,YAAI,QAAQ,KAAK,MAAM,eAAe,SAAS,CAAC,GAAG;AAClD,eAAK,wCAAwC;AAAA,QAC9C;AAAA,MACD;AAGA,UAAI,0BAA0B,GAC7B,cAAc;AACf,eACK,aAAa,WACjB,cAAc,SACd,cAAc,0BAA0B,aACvC;AACD,sBAAc;AACd,cAAM,WAAW,MAAM,eAAe,UAAU;AAChD,YAAI,sBACH,QAAQ,wBAAwB,QAAQ;AAEzC,YACC,KAAK,MAAM,cACV,SAAS,WAAW,KAAK,wBAAwB,IACjD;AAED;AAAA,QACD;AAEA,YACC,CAAC,0BACD,CAAC,KAAK,MAAM,aACZ,SAAS,WAAW,GACnB;AAED;AAAA,QACD;AAEA,YAAI,wBAAwB,IAAI;AAE/B,gCAAsB,SAAS;AAAA,QAChC;AAEA,YAAI,aAAa,GAAG;AACnB,gBAAM,4BACL,cAAc;AAAA,YACb;AAAA,YACA,sBAAsB;AAAA,YACtB;AAAA,UACD;AACD,cAAI,4BAA4B,eAAe,GAAG;AAGjD,gBACC,MAAM,aAAa,kBAAkB,aAAa,CAAC,GAClD;AACD,oBAAM,cAAc;AAAA,gBACnB,KAAK,MAAM;AAAA,gBACX;AAAA,gBACA,IAAI;AAAA,kBACH,aAAa;AAAA,kBACb,MAAM,iBAAiB,aAAa,CAAC;AAAA,kBACrC,aAAa;AAAA,kBACb,MAAM,iBAAiB,aAAa,CAAC;AAAA,gBACtC;AAAA,gBACA,KAAK;AAAA,cACN;AACA,kBAAI,aAAa;AAChB,8BAAc;AACd,oBAAI,YAAY,YAAY;AAC3B,2BACK,IAAI,GACP,OACC,YAAY,WAAW,QACzB,IAAI,QAAQ,cAAc,YAC1B,KACC;AACD,wBACC,YAAY,WAAW;AAAA,sBACtB;AAAA,oBACD,MAAM,SAAS,OACd;AACD;AAAA,oBACD,OAAO;AACN;AAAA,oBACD;AAAA,kBACD;AAAA,gBACD;AACA,oBAAI,YAAY,YAAY;AAC3B,gCAAc,KAAK;AAAA,oBAClB;AAAA,oBACA,cAAc,YAAY;AAAA,kBAC3B;AAAA,gBACD;AAGA,yBAAS,IAAI,GAAG,IAAI,aAAa,KAAK;AACrC,sBACC,wBAAwB,KACxB,SAAS;AAAA,oBACR,sBAAsB;AAAA,kBACvB,MAAM,SAAS,OACd;AACD;AAAA,kBACD;AACA;AAAA,gBACD;AAAA,cACD;AAAA,YACD;AAAA,UACD;AAAA,QACD;AAEA,YAAI,KAAK,MAAM,aAAa,wBAAwB,GAAG;AAEtD;AAAA,QACD;AAEA,YAAI;AACJ,YAAI,KAAK,MAAM,WAAW;AACzB,0BAAgB,aAAa;AAAA,YAC5B;AAAA,YACA,sBAAsB;AAAA,YACtB;AAAA,YACA;AAAA,YACA;AAAA,UACD;AAAA,QACD,OAAO;AACN,0BAAgB,aAAa;AAAA,YAC5B;AAAA,YACA,sBAAsB;AAAA,YACtB;AAAA,YACA;AAAA,YACA;AAAA,UACD;AAAA,QACD;AAEA,aAAK;AAAA,UACJ;AAAA,UACA,IAAI;AAAA,YACH;AAAA,YACA;AAAA,YACA;AAAA,YACA,sBAAsB;AAAA,UACvB;AAAA,UACA;AAAA,QACD;AACA,YAAI,eAAe,aAAa,CAAC,KAAK,WAAW,QAAQ,GAAG;AAE3D,eAAK,gCACJ,KAAK,WAAW,eAAe,sBAAsB;AAAA,QACvD;AAAA,MACD;AAAA,IACD,OAAO;AAEN,UACC,CAAC,KAAK,MAAM,aACZ,KAAK,WAAW,QAAQ,KACxB,MAAM,cAAc,SAAS,MAAM,GAClC;AACD,aAAK,wCAAwC;AAAA,MAC9C;AAEA,YAAM,YAAY,eACf,mBAAmB,KAAK,UAAU,IAClC;AAEH,eACK,aAAa,WACjB,cAAc,SACd,cACC;AACD,cAAM,WAAW,MAAM,eAAe,UAAU;AAChD,YAAI,sBACH,QAAQ,wBAAwB,QAAQ;AAEzC,YACC,KAAK,MAAM,cACV,SAAS,WAAW,KAAK,wBAAwB,IACjD;AAED;AAAA,QACD;AAEA,YACC,CAAC,0BACD,CAAC,KAAK,MAAM,aACZ,SAAS,WAAW,GACnB;AAED;AAAA,QACD;AAEA,YAAI,wBAAwB,IAAI;AAE/B,gCAAsB,SAAS;AAAA,QAChC;AAEA,YAAI,KAAK,MAAM,aAAa,wBAAwB,GAAG;AAEtD;AAAA,QACD;AAEA,YAAI,KAAK,MAAM,WAAW;AACzB,gCAAsB,KAAK;AAAA,YAC1B;AAAA,YACA;AAAA,UACD;AACA,mBAAS,IAAI,GAAG,IAAI,qBAAqB,KAAK;AAC7C,kBAAM,MAAM,SAAS,WAAW,CAAC;AACjC,gBAAI,QAAQ,SAAS,KAAK;AACzB,oCAAsB,IAAI;AAC1B;AAAA,YACD;AAAA,UACD;AAEA,eAAK;AAAA,YACJ;AAAA,YACA,IAAI;AAAA,cACH;AAAA,cACA;AAAA,cACA;AAAA,cACA,sBAAsB;AAAA,YACvB;AAAA,YACA;AAAA,UACD;AAAA,QACD,OAAO;AACN,eAAK;AAAA,YACJ;AAAA,YACA,IAAI,MAAM,YAAY,GAAG,YAAY,CAAC;AAAA,YACtC;AAAA,UACD;AACA,cACC,eAAe,aACf,CAAC,KAAK,WAAW,QAAQ,GACxB;AAED,iBAAK,gCACJ,KAAK,WAAW,gBAAgB;AAAA,UAClC;AAAA,QACD;AAAA,MACD;AAAA,IACD;AAEA,SAAK,eAAe,QAAQ,eAAe,KAAK,UAAU;AAAA,EAC3D;AAAA,EAEO,mBACN,OACA,QACY;AACZ,QAAI,KAAK,uCAAuC;AAC/C,YAAM,SAAS,OAAO,yBAAyB,EAAE,CAAC;AAClD,aAAO,IAAI;AAAA,QACV,OAAO,MAAM;AAAA,QACb,OAAO,MAAM;AAAA,QACb,OAAO,MAAM;AAAA,QACb,OAAO,MAAM;AAAA,MACd;AAAA,IACD;AACA,UAAM,SAAS,OAAO,oBAAoB,KAAK,YAAa;AAE5D,QAAI,KAAK,+BAA+B;AAEvC,YAAM,qBAAqB,KAAK,WAAW;AAC3C,YAAM,oBAAoB,OAAO;AACjC,UAAI,qBAAqB,oBAAoB;AAC5C,eAAO;AAAA,MACR;AAEA,UAAI,OAAO,aAAa,MAAM,mBAAmB,KAAK;AACrD,eAAO,IAAI;AAAA,UACV,OAAO;AAAA,UACP;AAAA,UACA,OAAO;AAAA,UACP,OAAO;AAAA,QACR;AAAA,MACD;AACA,aAAO,IAAI;AAAA,QACV,OAAO;AAAA,QACP,OAAO;AAAA,QACP,OAAO;AAAA,QACP;AAAA,MACD;AAAA,IACD;AAEA,WAAO;AAAA,EACR;AACD;AA9Ya,eAAN;AAAA,EA4EJ;AAAA,GA5EU;",
  "names": []
}
