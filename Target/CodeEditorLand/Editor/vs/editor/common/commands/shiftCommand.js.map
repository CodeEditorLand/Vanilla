{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/commands/shiftCommand.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Range } from '../core/range.js';\nimport { Selection, SelectionDirection } from '../core/selection.js';\nimport { ICommand, ICursorStateComputerData, IEditOperationBuilder } from '../editorCommon.js';\nimport { ITextModel } from '../model.js';\nimport { EditorAutoIndentStrategy } from '../config/editorOptions.js';\nimport { getEnterAction } from '../languages/enterAction.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\n\nexport interface IShiftCommandOpts {\n\tisUnshift: boolean;\n\ttabSize: number;\n\tindentSize: number;\n\tinsertSpaces: boolean;\n\tuseTabStops: boolean;\n\tautoIndent: EditorAutoIndentStrategy;\n}\n\nconst repeatCache: { [str: string]: string[] } = Object.create(null);\nfunction cachedStringRepeat(str: string, count: number): string {\n\tif (count <= 0) {\n\t\treturn '';\n\t}\n\tif (!repeatCache[str]) {\n\t\trepeatCache[str] = ['', str];\n\t}\n\tconst cache = repeatCache[str];\n\tfor (let i = cache.length; i <= count; i++) {\n\t\tcache[i] = cache[i - 1] + str;\n\t}\n\treturn cache[count];\n}\n\nexport class ShiftCommand implements ICommand {\n\n\tpublic static unshiftIndent(line: string, column: number, tabSize: number, indentSize: number, insertSpaces: boolean): string {\n\t\t// Determine the visible column where the content starts\n\t\tconst contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);\n\n\t\tif (insertSpaces) {\n\t\t\tconst indent = cachedStringRepeat(' ', indentSize);\n\t\t\tconst desiredTabStop = CursorColumns.prevIndentTabStop(contentStartVisibleColumn, indentSize);\n\t\t\tconst indentCount = desiredTabStop / indentSize; // will be an integer\n\t\t\treturn cachedStringRepeat(indent, indentCount);\n\t\t} else {\n\t\t\tconst indent = '\\t';\n\t\t\tconst desiredTabStop = CursorColumns.prevRenderTabStop(contentStartVisibleColumn, tabSize);\n\t\t\tconst indentCount = desiredTabStop / tabSize; // will be an integer\n\t\t\treturn cachedStringRepeat(indent, indentCount);\n\t\t}\n\t}\n\n\tpublic static shiftIndent(line: string, column: number, tabSize: number, indentSize: number, insertSpaces: boolean): string {\n\t\t// Determine the visible column where the content starts\n\t\tconst contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);\n\n\t\tif (insertSpaces) {\n\t\t\tconst indent = cachedStringRepeat(' ', indentSize);\n\t\t\tconst desiredTabStop = CursorColumns.nextIndentTabStop(contentStartVisibleColumn, indentSize);\n\t\t\tconst indentCount = desiredTabStop / indentSize; // will be an integer\n\t\t\treturn cachedStringRepeat(indent, indentCount);\n\t\t} else {\n\t\t\tconst indent = '\\t';\n\t\t\tconst desiredTabStop = CursorColumns.nextRenderTabStop(contentStartVisibleColumn, tabSize);\n\t\t\tconst indentCount = desiredTabStop / tabSize; // will be an integer\n\t\t\treturn cachedStringRepeat(indent, indentCount);\n\t\t}\n\t}\n\n\tprivate readonly _opts: IShiftCommandOpts;\n\tprivate readonly _selection: Selection;\n\tprivate _selectionId: string | null;\n\tprivate _useLastEditRangeForCursorEndPosition: boolean;\n\tprivate _selectionStartColumnStaysPut: boolean;\n\n\tconstructor(\n\t\trange: Selection,\n\t\topts: IShiftCommandOpts,\n\t\t@ILanguageConfigurationService private readonly _languageConfigurationService: ILanguageConfigurationService\n\t) {\n\t\tthis._opts = opts;\n\t\tthis._selection = range;\n\t\tthis._selectionId = null;\n\t\tthis._useLastEditRangeForCursorEndPosition = false;\n\t\tthis._selectionStartColumnStaysPut = false;\n\t}\n\n\tprivate _addEditOperation(builder: IEditOperationBuilder, range: Range, text: string) {\n\t\tif (this._useLastEditRangeForCursorEndPosition) {\n\t\t\tbuilder.addTrackedEditOperation(range, text);\n\t\t} else {\n\t\t\tbuilder.addEditOperation(range, text);\n\t\t}\n\t}\n\n\tpublic getEditOperations(model: ITextModel, builder: IEditOperationBuilder): void {\n\t\tconst startLine = this._selection.startLineNumber;\n\n\t\tlet endLine = this._selection.endLineNumber;\n\t\tif (this._selection.endColumn === 1 && startLine !== endLine) {\n\t\t\tendLine = endLine - 1;\n\t\t}\n\n\t\tconst { tabSize, indentSize, insertSpaces } = this._opts;\n\t\tconst shouldIndentEmptyLines = (startLine === endLine);\n\n\t\tif (this._opts.useTabStops) {\n\t\t\t// if indenting or outdenting on a whitespace only line\n\t\t\tif (this._selection.isEmpty()) {\n\t\t\t\tif (/^\\s*$/.test(model.getLineContent(startLine))) {\n\t\t\t\t\tthis._useLastEditRangeForCursorEndPosition = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// keep track of previous line's \"miss-alignment\"\n\t\t\tlet previousLineExtraSpaces = 0, extraSpaces = 0;\n\t\t\tfor (let lineNumber = startLine; lineNumber <= endLine; lineNumber++, previousLineExtraSpaces = extraSpaces) {\n\t\t\t\textraSpaces = 0;\n\t\t\t\tconst lineText = model.getLineContent(lineNumber);\n\t\t\t\tlet indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);\n\n\t\t\t\tif (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {\n\t\t\t\t\t// empty line or line with no leading whitespace => nothing to do\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {\n\t\t\t\t\t// do not indent empty lines => nothing to do\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (indentationEndIndex === -1) {\n\t\t\t\t\t// the entire line is whitespace\n\t\t\t\t\tindentationEndIndex = lineText.length;\n\t\t\t\t}\n\n\t\t\t\tif (lineNumber > 1) {\n\t\t\t\t\tconst contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(lineText, indentationEndIndex + 1, tabSize);\n\t\t\t\t\tif (contentStartVisibleColumn % indentSize !== 0) {\n\t\t\t\t\t\t// The current line is \"miss-aligned\", so let's see if this is expected...\n\t\t\t\t\t\t// This can only happen when it has trailing commas in the indent\n\t\t\t\t\t\tif (model.tokenization.isCheapToTokenize(lineNumber - 1)) {\n\t\t\t\t\t\t\tconst enterAction = getEnterAction(this._opts.autoIndent, model, new Range(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1), lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)), this._languageConfigurationService);\n\t\t\t\t\t\t\tif (enterAction) {\n\t\t\t\t\t\t\t\textraSpaces = previousLineExtraSpaces;\n\t\t\t\t\t\t\t\tif (enterAction.appendText) {\n\t\t\t\t\t\t\t\t\tfor (let j = 0, lenJ = enterAction.appendText.length; j < lenJ && extraSpaces < indentSize; j++) {\n\t\t\t\t\t\t\t\t\t\tif (enterAction.appendText.charCodeAt(j) === CharCode.Space) {\n\t\t\t\t\t\t\t\t\t\t\textraSpaces++;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (enterAction.removeText) {\n\t\t\t\t\t\t\t\t\textraSpaces = Math.max(0, extraSpaces - enterAction.removeText);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Act as if `prefixSpaces` is not part of the indentation\n\t\t\t\t\t\t\t\tfor (let j = 0; j < extraSpaces; j++) {\n\t\t\t\t\t\t\t\t\tif (indentationEndIndex === 0 || lineText.charCodeAt(indentationEndIndex - 1) !== CharCode.Space) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tindentationEndIndex--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\tif (this._opts.isUnshift && indentationEndIndex === 0) {\n\t\t\t\t\t// line with no leading whitespace => nothing to do\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet desiredIndent: string;\n\t\t\t\tif (this._opts.isUnshift) {\n\t\t\t\t\tdesiredIndent = ShiftCommand.unshiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\n\t\t\t\t} else {\n\t\t\t\t\tdesiredIndent = ShiftCommand.shiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\n\t\t\t\t}\n\n\t\t\t\tthis._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), desiredIndent);\n\t\t\t\tif (lineNumber === startLine && !this._selection.isEmpty()) {\n\t\t\t\t\t// Force the startColumn to stay put because we're inserting after it\n\t\t\t\t\tthis._selectionStartColumnStaysPut = (this._selection.startColumn <= indentationEndIndex + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\n\t\t\t// if indenting or outdenting on a whitespace only line\n\t\t\tif (!this._opts.isUnshift && this._selection.isEmpty() && model.getLineLength(startLine) === 0) {\n\t\t\t\tthis._useLastEditRangeForCursorEndPosition = true;\n\t\t\t}\n\n\t\t\tconst oneIndent = (insertSpaces ? cachedStringRepeat(' ', indentSize) : '\\t');\n\n\t\t\tfor (let lineNumber = startLine; lineNumber <= endLine; lineNumber++) {\n\t\t\t\tconst lineText = model.getLineContent(lineNumber);\n\t\t\t\tlet indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);\n\n\t\t\t\tif (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {\n\t\t\t\t\t// empty line or line with no leading whitespace => nothing to do\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {\n\t\t\t\t\t// do not indent empty lines => nothing to do\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (indentationEndIndex === -1) {\n\t\t\t\t\t// the entire line is whitespace\n\t\t\t\t\tindentationEndIndex = lineText.length;\n\t\t\t\t}\n\n\t\t\t\tif (this._opts.isUnshift && indentationEndIndex === 0) {\n\t\t\t\t\t// line with no leading whitespace => nothing to do\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (this._opts.isUnshift) {\n\n\t\t\t\t\tindentationEndIndex = Math.min(indentationEndIndex, indentSize);\n\t\t\t\t\tfor (let i = 0; i < indentationEndIndex; i++) {\n\t\t\t\t\t\tconst chr = lineText.charCodeAt(i);\n\t\t\t\t\t\tif (chr === CharCode.Tab) {\n\t\t\t\t\t\t\tindentationEndIndex = i + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), '');\n\t\t\t\t} else {\n\t\t\t\t\tthis._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, 1), oneIndent);\n\t\t\t\t\tif (lineNumber === startLine && !this._selection.isEmpty()) {\n\t\t\t\t\t\t// Force the startColumn to stay put because we're inserting after it\n\t\t\t\t\t\tthis._selectionStartColumnStaysPut = (this._selection.startColumn === 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._selectionId = builder.trackSelection(this._selection);\n\t}\n\n\tpublic computeCursorState(model: ITextModel, helper: ICursorStateComputerData): Selection {\n\t\tif (this._useLastEditRangeForCursorEndPosition) {\n\t\t\tconst lastOp = helper.getInverseEditOperations()[0];\n\t\t\treturn new Selection(lastOp.range.endLineNumber, lastOp.range.endColumn, lastOp.range.endLineNumber, lastOp.range.endColumn);\n\t\t}\n\t\tconst result = helper.getTrackedSelection(this._selectionId!);\n\n\t\tif (this._selectionStartColumnStaysPut) {\n\t\t\t// The selection start should not move\n\t\t\tconst initialStartColumn = this._selection.startColumn;\n\t\t\tconst resultStartColumn = result.startColumn;\n\t\t\tif (resultStartColumn <= initialStartColumn) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tif (result.getDirection() === SelectionDirection.LTR) {\n\t\t\t\treturn new Selection(result.startLineNumber, initialStartColumn, result.endLineNumber, result.endColumn);\n\t\t\t}\n\t\t\treturn new Selection(result.endLineNumber, result.endColumn, result.startLineNumber, initialStartColumn);\n\t\t}\n\n\t\treturn result;\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
