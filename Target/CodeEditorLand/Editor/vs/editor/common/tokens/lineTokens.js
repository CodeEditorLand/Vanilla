import"../languages.js";import{FontStyle as b,ColorId as k,MetadataConsts as g,TokenMetadata as d}from"../encodedTokenAttributes.js";import"../core/position.js";import"../model.js";import{OffsetRange as h}from"../core/offsetRange.js";import{TokenArrayBuilder as m}from"./tokenArray.js";class u{static createEmpty(e,t){const n=u.defaultTokenMetadata,r=new Uint32Array(2);return r[0]=e.length,r[1]=n,new u(r,e,t)}static createFromTextAndMetadata(e,t){let n=0,r="";const s=new Array;for(const{text:o,metadata:i}of e)s.push(n+o.length,i),n+=o.length,r+=o;return new u(new Uint32Array(s),r,t)}static convertToEndOffset(e,t){const r=(e.length>>>1)-1;for(let s=0;s<r;s++)e[s<<1]=e[s+1<<1];e[r<<1]=t}static findIndexInTokensArray(e,t){if(e.length<=2)return 0;let n=0,r=(e.length>>>1)-1;for(;n<r;){const s=n+Math.floor((r-n)/2),o=e[s<<1];if(o===t)return s+1;o<t?n=s+1:o>t&&(r=s)}return n}_lineTokensBrand=void 0;_tokens;_tokensCount;_text;languageIdCodec;static defaultTokenMetadata=(b.None<<g.FONT_STYLE_OFFSET|k.DefaultForeground<<g.FOREGROUND_OFFSET|k.DefaultBackground<<g.BACKGROUND_OFFSET)>>>0;constructor(e,t,n){this._tokens=e,this._tokensCount=this._tokens.length>>>1,this._text=t,this.languageIdCodec=n}equals(e){return e instanceof u?this.slicedEquals(e,0,this._tokensCount):!1}slicedEquals(e,t,n){if(this._text!==e._text||this._tokensCount!==e._tokensCount)return!1;const r=t<<1,s=r+(n<<1);for(let o=r;o<s;o++)if(this._tokens[o]!==e._tokens[o])return!1;return!0}getLineContent(){return this._text}getCount(){return this._tokensCount}getStartOffset(e){return e>0?this._tokens[e-1<<1]:0}getMetadata(e){return this._tokens[(e<<1)+1]}getLanguageId(e){const t=this._tokens[(e<<1)+1],n=d.getLanguageId(t);return this.languageIdCodec.decodeLanguageId(n)}getStandardTokenType(e){const t=this._tokens[(e<<1)+1];return d.getTokenType(t)}getForeground(e){const t=this._tokens[(e<<1)+1];return d.getForeground(t)}getClassName(e){const t=this._tokens[(e<<1)+1];return d.getClassNameFromMetadata(t)}getInlineStyle(e,t){const n=this._tokens[(e<<1)+1];return d.getInlineStyleFromMetadata(n,t)}getPresentation(e){const t=this._tokens[(e<<1)+1];return d.getPresentationFromMetadata(t)}getEndOffset(e){return this._tokens[e<<1]}findTokenIndexAtOffset(e){return u.findIndexInTokensArray(this._tokens,e)}inflate(){return this}sliceAndInflate(e,t,n){return new c(this,e,t,n)}withInserted(e){if(e.length===0)return this;let t=0,n=0,r="";const s=new Array;let o=0;for(;;){const i=t<this._tokensCount?this._tokens[t<<1]:-1,a=n<e.length?e[n]:null;if(i!==-1&&(a===null||i<=a.offset)){r+=this._text.substring(o,i);const l=this._tokens[(t<<1)+1];s.push(r.length,l),t++,o=i}else if(a){if(a.offset>o){r+=this._text.substring(o,a.offset);const l=this._tokens[(t<<1)+1];s.push(r.length,l),o=a.offset}r+=a.text,s.push(r.length,a.tokenMetadata),n++}else break}return new u(new Uint32Array(s),r,this.languageIdCodec)}getTokensInRange(e){const t=new m,n=this.findTokenIndexAtOffset(e.start),r=this.findTokenIndexAtOffset(e.endExclusive);for(let s=n;s<=r;s++){const i=new h(this.getStartOffset(s),this.getEndOffset(s)).intersectionLength(e);i>0&&t.add(i,this.getMetadata(s))}return t.build()}getTokenText(e){const t=this.getStartOffset(e),n=this.getEndOffset(e);return this._text.substring(t,n)}forEach(e){const t=this.getCount();for(let n=0;n<t;n++)e(n)}}class c{_source;_startOffset;_endOffset;_deltaOffset;_firstTokenIndex;_tokensCount;languageIdCodec;constructor(e,t,n,r){this._source=e,this._startOffset=t,this._endOffset=n,this._deltaOffset=r,this._firstTokenIndex=e.findTokenIndexAtOffset(t),this.languageIdCodec=e.languageIdCodec,this._tokensCount=0;for(let s=this._firstTokenIndex,o=e.getCount();s<o&&!(e.getStartOffset(s)>=n);s++)this._tokensCount++}getMetadata(e){return this._source.getMetadata(this._firstTokenIndex+e)}getLanguageId(e){return this._source.getLanguageId(this._firstTokenIndex+e)}getLineContent(){return this._source.getLineContent().substring(this._startOffset,this._endOffset)}equals(e){return e instanceof c?this._startOffset===e._startOffset&&this._endOffset===e._endOffset&&this._deltaOffset===e._deltaOffset&&this._source.slicedEquals(e._source,this._firstTokenIndex,this._tokensCount):!1}getCount(){return this._tokensCount}getStandardTokenType(e){return this._source.getStandardTokenType(this._firstTokenIndex+e)}getForeground(e){return this._source.getForeground(this._firstTokenIndex+e)}getEndOffset(e){const t=this._source.getEndOffset(this._firstTokenIndex+e);return Math.min(this._endOffset,t)-this._startOffset+this._deltaOffset}getClassName(e){return this._source.getClassName(this._firstTokenIndex+e)}getInlineStyle(e,t){return this._source.getInlineStyle(this._firstTokenIndex+e,t)}getPresentation(e){return this._source.getPresentation(this._firstTokenIndex+e)}findTokenIndexAtOffset(e){return this._source.findTokenIndexAtOffset(e+this._startOffset-this._deltaOffset)-this._firstTokenIndex}getTokenText(e){const t=this._firstTokenIndex+e,n=this._source.getStartOffset(t),r=this._source.getEndOffset(t);let s=this._source.getTokenText(t);return n<this._startOffset&&(s=s.substring(this._startOffset-n)),r>this._endOffset&&(s=s.substring(0,s.length-(r-this._endOffset))),s}forEach(e){for(let t=0;t<this.getCount();t++)e(t)}}function w(f,e){const t=e.lineNumber;if(!f.tokenization.isCheapToTokenize(t))return;f.tokenization.forceTokenization(t);const n=f.tokenization.getLineTokens(t),r=n.findTokenIndexAtOffset(e.column-1);return n.getStandardTokenType(r)}export{u as LineTokens,w as getStandardTokenTypeAtPosition};
