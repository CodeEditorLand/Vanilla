{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/tokens/contiguousTokensStore.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from \"../../../base/common/arrays.js\";\nimport { Position } from \"../core/position.js\";\nimport type { IRange } from \"../core/range.js\";\nimport {\n\tColorId,\n\tFontStyle,\n\ttype LanguageId,\n\tMetadataConsts,\n\tStandardTokenType,\n\tTokenMetadata,\n} from \"../encodedTokenAttributes.js\";\nimport type { ILanguageIdCodec } from \"../languages.js\";\nimport type { ITextModel } from \"../model.js\";\nimport type { ContiguousMultilineTokens } from \"./contiguousMultilineTokens.js\";\nimport {\n\tContiguousTokensEditing,\n\tEMPTY_LINE_TOKENS,\n\ttoUint32Array,\n} from \"./contiguousTokensEditing.js\";\nimport { LineTokens } from \"./lineTokens.js\";\n\n/**\n * Represents contiguous tokens in a text model.\n */\nexport class ContiguousTokensStore {\n\tprivate _lineTokens: (Uint32Array | ArrayBuffer | null)[];\n\tprivate _len: number;\n\tprivate readonly _languageIdCodec: ILanguageIdCodec;\n\n\tconstructor(languageIdCodec: ILanguageIdCodec) {\n\t\tthis._lineTokens = [];\n\t\tthis._len = 0;\n\t\tthis._languageIdCodec = languageIdCodec;\n\t}\n\n\tpublic flush(): void {\n\t\tthis._lineTokens = [];\n\t\tthis._len = 0;\n\t}\n\n\tget hasTokens(): boolean {\n\t\treturn this._lineTokens.length > 0;\n\t}\n\n\tpublic getTokens(\n\t\ttopLevelLanguageId: string,\n\t\tlineIndex: number,\n\t\tlineText: string,\n\t): LineTokens {\n\t\tlet rawLineTokens: Uint32Array | ArrayBuffer | null = null;\n\t\tif (lineIndex < this._len) {\n\t\t\trawLineTokens = this._lineTokens[lineIndex];\n\t\t}\n\n\t\tif (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {\n\t\t\treturn new LineTokens(\n\t\t\t\ttoUint32Array(rawLineTokens),\n\t\t\t\tlineText,\n\t\t\t\tthis._languageIdCodec,\n\t\t\t);\n\t\t}\n\n\t\tconst lineTokens = new Uint32Array(2);\n\t\tlineTokens[0] = lineText.length;\n\t\tlineTokens[1] = getDefaultMetadata(\n\t\t\tthis._languageIdCodec.encodeLanguageId(topLevelLanguageId),\n\t\t);\n\t\treturn new LineTokens(lineTokens, lineText, this._languageIdCodec);\n\t}\n\n\tprivate static _massageTokens(\n\t\ttopLevelLanguageId: LanguageId,\n\t\tlineTextLength: number,\n\t\t_tokens: Uint32Array | ArrayBuffer | null,\n\t): Uint32Array | ArrayBuffer {\n\t\tconst tokens = _tokens ? toUint32Array(_tokens) : null;\n\n\t\tif (lineTextLength === 0) {\n\t\t\tlet hasDifferentLanguageId = false;\n\t\t\tif (tokens && tokens.length > 1) {\n\t\t\t\thasDifferentLanguageId =\n\t\t\t\t\tTokenMetadata.getLanguageId(tokens[1]) !==\n\t\t\t\t\ttopLevelLanguageId;\n\t\t\t}\n\n\t\t\tif (!hasDifferentLanguageId) {\n\t\t\t\treturn EMPTY_LINE_TOKENS;\n\t\t\t}\n\t\t}\n\n\t\tif (!tokens || tokens.length === 0) {\n\t\t\tconst tokens = new Uint32Array(2);\n\t\t\ttokens[0] = lineTextLength;\n\t\t\ttokens[1] = getDefaultMetadata(topLevelLanguageId);\n\t\t\treturn tokens.buffer;\n\t\t}\n\n\t\t// Ensure the last token covers the end of the text\n\t\ttokens[tokens.length - 2] = lineTextLength;\n\n\t\tif (\n\t\t\ttokens.byteOffset === 0 &&\n\t\t\ttokens.byteLength === tokens.buffer.byteLength\n\t\t) {\n\t\t\t// Store directly the ArrayBuffer pointer to save an object\n\t\t\treturn tokens.buffer;\n\t\t}\n\t\treturn tokens;\n\t}\n\n\tprivate _ensureLine(lineIndex: number): void {\n\t\twhile (lineIndex >= this._len) {\n\t\t\tthis._lineTokens[this._len] = null;\n\t\t\tthis._len++;\n\t\t}\n\t}\n\n\tprivate _deleteLines(start: number, deleteCount: number): void {\n\t\tif (deleteCount === 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (start + deleteCount > this._len) {\n\t\t\tdeleteCount = this._len - start;\n\t\t}\n\t\tthis._lineTokens.splice(start, deleteCount);\n\t\tthis._len -= deleteCount;\n\t}\n\n\tprivate _insertLines(insertIndex: number, insertCount: number): void {\n\t\tif (insertCount === 0) {\n\t\t\treturn;\n\t\t}\n\t\tconst lineTokens: (Uint32Array | ArrayBuffer | null)[] = [];\n\t\tfor (let i = 0; i < insertCount; i++) {\n\t\t\tlineTokens[i] = null;\n\t\t}\n\t\tthis._lineTokens = arrays.arrayInsert(\n\t\t\tthis._lineTokens,\n\t\t\tinsertIndex,\n\t\t\tlineTokens,\n\t\t);\n\t\tthis._len += insertCount;\n\t}\n\n\tpublic setTokens(\n\t\ttopLevelLanguageId: string,\n\t\tlineIndex: number,\n\t\tlineTextLength: number,\n\t\t_tokens: Uint32Array | ArrayBuffer | null,\n\t\tcheckEquality: boolean,\n\t): boolean {\n\t\tconst tokens = ContiguousTokensStore._massageTokens(\n\t\t\tthis._languageIdCodec.encodeLanguageId(topLevelLanguageId),\n\t\t\tlineTextLength,\n\t\t\t_tokens,\n\t\t);\n\t\tthis._ensureLine(lineIndex);\n\t\tconst oldTokens = this._lineTokens[lineIndex];\n\t\tthis._lineTokens[lineIndex] = tokens;\n\n\t\tif (checkEquality) {\n\t\t\treturn !ContiguousTokensStore._equals(oldTokens, tokens);\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate static _equals(\n\t\t_a: Uint32Array | ArrayBuffer | null,\n\t\t_b: Uint32Array | ArrayBuffer | null,\n\t) {\n\t\tif (!_a || !_b) {\n\t\t\treturn !_a && !_b;\n\t\t}\n\n\t\tconst a = toUint32Array(_a);\n\t\tconst b = toUint32Array(_b);\n\n\t\tif (a.length !== b.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0, len = a.length; i < len; i++) {\n\t\t\tif (a[i] !== b[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t//#region Editing\n\n\tpublic acceptEdit(\n\t\trange: IRange,\n\t\teolCount: number,\n\t\tfirstLineLength: number,\n\t): void {\n\t\tthis._acceptDeleteRange(range);\n\t\tthis._acceptInsertText(\n\t\t\tnew Position(range.startLineNumber, range.startColumn),\n\t\t\teolCount,\n\t\t\tfirstLineLength,\n\t\t);\n\t}\n\n\tprivate _acceptDeleteRange(range: IRange): void {\n\t\tconst firstLineIndex = range.startLineNumber - 1;\n\t\tif (firstLineIndex >= this._len) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (range.startLineNumber === range.endLineNumber) {\n\t\t\tif (range.startColumn === range.endColumn) {\n\t\t\t\t// Nothing to delete\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._lineTokens[firstLineIndex] = ContiguousTokensEditing.delete(\n\t\t\t\tthis._lineTokens[firstLineIndex],\n\t\t\t\trange.startColumn - 1,\n\t\t\t\trange.endColumn - 1,\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._lineTokens[firstLineIndex] = ContiguousTokensEditing.deleteEnding(\n\t\t\tthis._lineTokens[firstLineIndex],\n\t\t\trange.startColumn - 1,\n\t\t);\n\n\t\tconst lastLineIndex = range.endLineNumber - 1;\n\t\tlet lastLineTokens: Uint32Array | ArrayBuffer | null = null;\n\t\tif (lastLineIndex < this._len) {\n\t\t\tlastLineTokens = ContiguousTokensEditing.deleteBeginning(\n\t\t\t\tthis._lineTokens[lastLineIndex],\n\t\t\t\trange.endColumn - 1,\n\t\t\t);\n\t\t}\n\n\t\t// Take remaining text on last line and append it to remaining text on first line\n\t\tthis._lineTokens[firstLineIndex] = ContiguousTokensEditing.append(\n\t\t\tthis._lineTokens[firstLineIndex],\n\t\t\tlastLineTokens,\n\t\t);\n\n\t\t// Delete middle lines\n\t\tthis._deleteLines(\n\t\t\trange.startLineNumber,\n\t\t\trange.endLineNumber - range.startLineNumber,\n\t\t);\n\t}\n\n\tprivate _acceptInsertText(\n\t\tposition: Position,\n\t\teolCount: number,\n\t\tfirstLineLength: number,\n\t): void {\n\t\tif (eolCount === 0 && firstLineLength === 0) {\n\t\t\t// Nothing to insert\n\t\t\treturn;\n\t\t}\n\n\t\tconst lineIndex = position.lineNumber - 1;\n\t\tif (lineIndex >= this._len) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (eolCount === 0) {\n\t\t\t// Inserting text on one line\n\t\t\tthis._lineTokens[lineIndex] = ContiguousTokensEditing.insert(\n\t\t\t\tthis._lineTokens[lineIndex],\n\t\t\t\tposition.column - 1,\n\t\t\t\tfirstLineLength,\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._lineTokens[lineIndex] = ContiguousTokensEditing.deleteEnding(\n\t\t\tthis._lineTokens[lineIndex],\n\t\t\tposition.column - 1,\n\t\t);\n\t\tthis._lineTokens[lineIndex] = ContiguousTokensEditing.insert(\n\t\t\tthis._lineTokens[lineIndex],\n\t\t\tposition.column - 1,\n\t\t\tfirstLineLength,\n\t\t);\n\n\t\tthis._insertLines(position.lineNumber, eolCount);\n\t}\n\n\t//#endregion\n\n\tpublic setMultilineTokens(\n\t\ttokens: ContiguousMultilineTokens[],\n\t\ttextModel: ITextModel,\n\t): { changes: { fromLineNumber: number; toLineNumber: number }[] } {\n\t\tif (tokens.length === 0) {\n\t\t\treturn { changes: [] };\n\t\t}\n\n\t\tconst ranges: { fromLineNumber: number; toLineNumber: number }[] = [];\n\n\t\tfor (let i = 0, len = tokens.length; i < len; i++) {\n\t\t\tconst element = tokens[i];\n\t\t\tlet minChangedLineNumber = 0;\n\t\t\tlet maxChangedLineNumber = 0;\n\t\t\tlet hasChange = false;\n\t\t\tfor (\n\t\t\t\tlet lineNumber = element.startLineNumber;\n\t\t\t\tlineNumber <= element.endLineNumber;\n\t\t\t\tlineNumber++\n\t\t\t) {\n\t\t\t\tif (hasChange) {\n\t\t\t\t\tthis.setTokens(\n\t\t\t\t\t\ttextModel.getLanguageId(),\n\t\t\t\t\t\tlineNumber - 1,\n\t\t\t\t\t\ttextModel.getLineLength(lineNumber),\n\t\t\t\t\t\telement.getLineTokens(lineNumber),\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t);\n\t\t\t\t\tmaxChangedLineNumber = lineNumber;\n\t\t\t\t} else {\n\t\t\t\t\tconst lineHasChange = this.setTokens(\n\t\t\t\t\t\ttextModel.getLanguageId(),\n\t\t\t\t\t\tlineNumber - 1,\n\t\t\t\t\t\ttextModel.getLineLength(lineNumber),\n\t\t\t\t\t\telement.getLineTokens(lineNumber),\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t);\n\t\t\t\t\tif (lineHasChange) {\n\t\t\t\t\t\thasChange = true;\n\t\t\t\t\t\tminChangedLineNumber = lineNumber;\n\t\t\t\t\t\tmaxChangedLineNumber = lineNumber;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasChange) {\n\t\t\t\tranges.push({\n\t\t\t\t\tfromLineNumber: minChangedLineNumber,\n\t\t\t\t\ttoLineNumber: maxChangedLineNumber,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn { changes: ranges };\n\t}\n}\n\nfunction getDefaultMetadata(topLevelLanguageId: LanguageId): number {\n\treturn (\n\t\t((topLevelLanguageId << MetadataConsts.LANGUAGEID_OFFSET) |\n\t\t\t(StandardTokenType.Other << MetadataConsts.TOKEN_TYPE_OFFSET) |\n\t\t\t(FontStyle.None << MetadataConsts.FONT_STYLE_OFFSET) |\n\t\t\t(ColorId.DefaultForeground << MetadataConsts.FOREGROUND_OFFSET) |\n\t\t\t(ColorId.DefaultBackground << MetadataConsts.BACKGROUND_OFFSET) |\n\t\t\t// If there is no grammar, we just take a guess and try to match brackets.\n\t\t\tMetadataConsts.BALANCED_BRACKETS_MASK) >>>\n\t\t0\n\t);\n}\n"],
  "mappings": "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",
  "names": ["tokens"]
}
