{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/tokens/contiguousTokensStore.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from '../../../base/common/arrays.js';\nimport { Position } from '../core/position.js';\nimport { IRange } from '../core/range.js';\nimport { ContiguousTokensEditing, EMPTY_LINE_TOKENS, toUint32Array } from './contiguousTokensEditing.js';\nimport { LineTokens } from './lineTokens.js';\nimport { ILanguageIdCodec } from '../languages.js';\nimport { LanguageId, FontStyle, ColorId, StandardTokenType, MetadataConsts, TokenMetadata } from '../encodedTokenAttributes.js';\nimport { ITextModel } from '../model.js';\nimport { ContiguousMultilineTokens } from './contiguousMultilineTokens.js';\n\n/**\n * Represents contiguous tokens in a text model.\n */\nexport class ContiguousTokensStore {\n\tprivate _lineTokens: (Uint32Array | ArrayBuffer | null)[];\n\tprivate _len: number;\n\tprivate readonly _languageIdCodec: ILanguageIdCodec;\n\n\tconstructor(languageIdCodec: ILanguageIdCodec) {\n\t\tthis._lineTokens = [];\n\t\tthis._len = 0;\n\t\tthis._languageIdCodec = languageIdCodec;\n\t}\n\n\tpublic flush(): void {\n\t\tthis._lineTokens = [];\n\t\tthis._len = 0;\n\t}\n\n\tget hasTokens(): boolean {\n\t\treturn this._lineTokens.length > 0;\n\t}\n\n\tpublic getTokens(topLevelLanguageId: string, lineIndex: number, lineText: string): LineTokens {\n\t\tlet rawLineTokens: Uint32Array | ArrayBuffer | null = null;\n\t\tif (lineIndex < this._len) {\n\t\t\trawLineTokens = this._lineTokens[lineIndex];\n\t\t}\n\n\t\tif (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {\n\t\t\treturn new LineTokens(toUint32Array(rawLineTokens), lineText, this._languageIdCodec);\n\t\t}\n\n\t\tconst lineTokens = new Uint32Array(2);\n\t\tlineTokens[0] = lineText.length;\n\t\tlineTokens[1] = getDefaultMetadata(this._languageIdCodec.encodeLanguageId(topLevelLanguageId));\n\t\treturn new LineTokens(lineTokens, lineText, this._languageIdCodec);\n\t}\n\n\tprivate static _massageTokens(topLevelLanguageId: LanguageId, lineTextLength: number, _tokens: Uint32Array | ArrayBuffer | null): Uint32Array | ArrayBuffer {\n\n\t\tconst tokens = _tokens ? toUint32Array(_tokens) : null;\n\n\t\tif (lineTextLength === 0) {\n\t\t\tlet hasDifferentLanguageId = false;\n\t\t\tif (tokens && tokens.length > 1) {\n\t\t\t\thasDifferentLanguageId = (TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId);\n\t\t\t}\n\n\t\t\tif (!hasDifferentLanguageId) {\n\t\t\t\treturn EMPTY_LINE_TOKENS;\n\t\t\t}\n\t\t}\n\n\t\tif (!tokens || tokens.length === 0) {\n\t\t\tconst tokens = new Uint32Array(2);\n\t\t\ttokens[0] = lineTextLength;\n\t\t\ttokens[1] = getDefaultMetadata(topLevelLanguageId);\n\t\t\treturn tokens.buffer;\n\t\t}\n\n\t\t// Ensure the last token covers the end of the text\n\t\ttokens[tokens.length - 2] = lineTextLength;\n\n\t\tif (tokens.byteOffset === 0 && tokens.byteLength === tokens.buffer.byteLength) {\n\t\t\t// Store directly the ArrayBuffer pointer to save an object\n\t\t\treturn tokens.buffer;\n\t\t}\n\t\treturn tokens;\n\t}\n\n\tprivate _ensureLine(lineIndex: number): void {\n\t\twhile (lineIndex >= this._len) {\n\t\t\tthis._lineTokens[this._len] = null;\n\t\t\tthis._len++;\n\t\t}\n\t}\n\n\tprivate _deleteLines(start: number, deleteCount: number): void {\n\t\tif (deleteCount === 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (start + deleteCount > this._len) {\n\t\t\tdeleteCount = this._len - start;\n\t\t}\n\t\tthis._lineTokens.splice(start, deleteCount);\n\t\tthis._len -= deleteCount;\n\t}\n\n\tprivate _insertLines(insertIndex: number, insertCount: number): void {\n\t\tif (insertCount === 0) {\n\t\t\treturn;\n\t\t}\n\t\tconst lineTokens: (Uint32Array | ArrayBuffer | null)[] = [];\n\t\tfor (let i = 0; i < insertCount; i++) {\n\t\t\tlineTokens[i] = null;\n\t\t}\n\t\tthis._lineTokens = arrays.arrayInsert(this._lineTokens, insertIndex, lineTokens);\n\t\tthis._len += insertCount;\n\t}\n\n\tpublic setTokens(topLevelLanguageId: string, lineIndex: number, lineTextLength: number, _tokens: Uint32Array | ArrayBuffer | null, checkEquality: boolean): boolean {\n\t\tconst tokens = ContiguousTokensStore._massageTokens(this._languageIdCodec.encodeLanguageId(topLevelLanguageId), lineTextLength, _tokens);\n\t\tthis._ensureLine(lineIndex);\n\t\tconst oldTokens = this._lineTokens[lineIndex];\n\t\tthis._lineTokens[lineIndex] = tokens;\n\n\t\tif (checkEquality) {\n\t\t\treturn !ContiguousTokensStore._equals(oldTokens, tokens);\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate static _equals(_a: Uint32Array | ArrayBuffer | null, _b: Uint32Array | ArrayBuffer | null) {\n\t\tif (!_a || !_b) {\n\t\t\treturn !_a && !_b;\n\t\t}\n\n\t\tconst a = toUint32Array(_a);\n\t\tconst b = toUint32Array(_b);\n\n\t\tif (a.length !== b.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0, len = a.length; i < len; i++) {\n\t\t\tif (a[i] !== b[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t//#region Editing\n\n\tpublic acceptEdit(range: IRange, eolCount: number, firstLineLength: number): void {\n\t\tthis._acceptDeleteRange(range);\n\t\tthis._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\n\t}\n\n\tprivate _acceptDeleteRange(range: IRange): void {\n\n\t\tconst firstLineIndex = range.startLineNumber - 1;\n\t\tif (firstLineIndex >= this._len) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (range.startLineNumber === range.endLineNumber) {\n\t\t\tif (range.startColumn === range.endColumn) {\n\t\t\t\t// Nothing to delete\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._lineTokens[firstLineIndex] = ContiguousTokensEditing.delete(this._lineTokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._lineTokens[firstLineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[firstLineIndex], range.startColumn - 1);\n\n\t\tconst lastLineIndex = range.endLineNumber - 1;\n\t\tlet lastLineTokens: Uint32Array | ArrayBuffer | null = null;\n\t\tif (lastLineIndex < this._len) {\n\t\t\tlastLineTokens = ContiguousTokensEditing.deleteBeginning(this._lineTokens[lastLineIndex], range.endColumn - 1);\n\t\t}\n\n\t\t// Take remaining text on last line and append it to remaining text on first line\n\t\tthis._lineTokens[firstLineIndex] = ContiguousTokensEditing.append(this._lineTokens[firstLineIndex], lastLineTokens);\n\n\t\t// Delete middle lines\n\t\tthis._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n\t}\n\n\tprivate _acceptInsertText(position: Position, eolCount: number, firstLineLength: number): void {\n\n\t\tif (eolCount === 0 && firstLineLength === 0) {\n\t\t\t// Nothing to insert\n\t\t\treturn;\n\t\t}\n\n\t\tconst lineIndex = position.lineNumber - 1;\n\t\tif (lineIndex >= this._len) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (eolCount === 0) {\n\t\t\t// Inserting text on one line\n\t\t\tthis._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._lineTokens[lineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[lineIndex], position.column - 1);\n\t\tthis._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n\n\t\tthis._insertLines(position.lineNumber, eolCount);\n\t}\n\n\t//#endregion\n\n\tpublic setMultilineTokens(tokens: ContiguousMultilineTokens[], textModel: ITextModel): { changes: { fromLineNumber: number; toLineNumber: number }[] } {\n\t\tif (tokens.length === 0) {\n\t\t\treturn { changes: [] };\n\t\t}\n\n\t\tconst ranges: { fromLineNumber: number; toLineNumber: number }[] = [];\n\n\t\tfor (let i = 0, len = tokens.length; i < len; i++) {\n\t\t\tconst element = tokens[i];\n\t\t\tlet minChangedLineNumber = 0;\n\t\t\tlet maxChangedLineNumber = 0;\n\t\t\tlet hasChange = false;\n\t\t\tfor (let lineNumber = element.startLineNumber; lineNumber <= element.endLineNumber; lineNumber++) {\n\t\t\t\tif (hasChange) {\n\t\t\t\t\tthis.setTokens(textModel.getLanguageId(), lineNumber - 1, textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), false);\n\t\t\t\t\tmaxChangedLineNumber = lineNumber;\n\t\t\t\t} else {\n\t\t\t\t\tconst lineHasChange = this.setTokens(textModel.getLanguageId(), lineNumber - 1, textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), true);\n\t\t\t\t\tif (lineHasChange) {\n\t\t\t\t\t\thasChange = true;\n\t\t\t\t\t\tminChangedLineNumber = lineNumber;\n\t\t\t\t\t\tmaxChangedLineNumber = lineNumber;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasChange) {\n\t\t\t\tranges.push({ fromLineNumber: minChangedLineNumber, toLineNumber: maxChangedLineNumber, });\n\t\t\t}\n\t\t}\n\n\t\treturn { changes: ranges };\n\t}\n}\n\nfunction getDefaultMetadata(topLevelLanguageId: LanguageId): number {\n\treturn (\n\t\t(topLevelLanguageId << MetadataConsts.LANGUAGEID_OFFSET)\n\t\t| (StandardTokenType.Other << MetadataConsts.TOKEN_TYPE_OFFSET)\n\t\t| (FontStyle.None << MetadataConsts.FONT_STYLE_OFFSET)\n\t\t| (ColorId.DefaultForeground << MetadataConsts.FOREGROUND_OFFSET)\n\t\t| (ColorId.DefaultBackground << MetadataConsts.BACKGROUND_OFFSET)\n\t\t// If there is no grammar, we just take a guess and try to match brackets.\n\t\t| (MetadataConsts.BALANCED_BRACKETS_MASK)\n\t) >>> 0;\n}\n"],
  "mappings": "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",
  "names": ["tokens"]
}
