import*as L from"../../../base/common/arrays.js";import{MetadataConsts as l}from"../encodedTokenAttributes.js";import{LineTokens as C}from"./lineTokens.js";class E{_pieces;_isComplete;_languageIdCodec;constructor(s){this._pieces=[],this._isComplete=!1,this._languageIdCodec=s}flush(){this._pieces=[],this._isComplete=!1}isEmpty(){return this._pieces.length===0}set(s,e){this._pieces=s||[],this._isComplete=e}setPartial(s,e){let i=s;if(e.length>0){const t=e[0].getRange(),a=e[e.length-1].getRange();if(!t||!a)return s;i=s.plusRange(t).plusRange(a)}let r=null;for(let t=0,a=this._pieces.length;t<a;t++){const o=this._pieces[t];if(o.endLineNumber<i.startLineNumber)continue;if(o.startLineNumber>i.endLineNumber){r=r||{index:t};break}if(o.removeTokens(i),o.isEmpty()){this._pieces.splice(t,1),t--,a--;continue}if(o.endLineNumber<i.startLineNumber)continue;if(o.startLineNumber>i.endLineNumber){r=r||{index:t};continue}const[n,g]=o.split(i);if(n.isEmpty()){r=r||{index:t};continue}g.isEmpty()||(this._pieces.splice(t,1,n,g),t++,a++,r=r||{index:t})}return r=r||{index:this._pieces.length},e.length>0&&(this._pieces=L.arrayInsert(this._pieces,r.index,e)),i}isComplete(){return this._isComplete}addSparseTokens(s,e){if(e.getLineContent().length===0)return e;const i=this._pieces;if(i.length===0)return e;const r=E._findFirstPieceWithLine(i,s),t=i[r].getLineTokens(s);if(!t)return e;const a=e.getCount(),o=t.getCount();let n=0;const g=[];let _=0,b=0;const d=(u,p)=>{u!==b&&(b=u,g[_++]=u,g[_++]=p)};for(let u=0;u<o;u++){const p=t.getStartCharacter(u),f=t.getEndCharacter(u),c=t.getMetadata(u),m=((c&l.SEMANTIC_USE_ITALIC?l.ITALIC_MASK:0)|(c&l.SEMANTIC_USE_BOLD?l.BOLD_MASK:0)|(c&l.SEMANTIC_USE_UNDERLINE?l.UNDERLINE_MASK:0)|(c&l.SEMANTIC_USE_STRIKETHROUGH?l.STRIKETHROUGH_MASK:0)|(c&l.SEMANTIC_USE_FOREGROUND?l.FOREGROUND_MASK:0)|(c&l.SEMANTIC_USE_BACKGROUND?l.BACKGROUND_MASK:0))>>>0,h=~m>>>0;for(;n<a&&e.getEndOffset(n)<=p;)d(e.getEndOffset(n),e.getMetadata(n)),n++;for(n<a&&e.getStartOffset(n)<p&&d(p,e.getMetadata(n));n<a&&e.getEndOffset(n)<f;)d(e.getEndOffset(n),e.getMetadata(n)&h|c&m),n++;if(n<a)d(f,e.getMetadata(n)&h|c&m),e.getEndOffset(n)===f&&n++;else{const M=Math.min(Math.max(0,n-1),a-1);d(f,e.getMetadata(M)&h|c&m)}}for(;n<a;)d(e.getEndOffset(n),e.getMetadata(n)),n++;return new C(new Uint32Array(g),e.getLineContent(),this._languageIdCodec)}static _findFirstPieceWithLine(s,e){let i=0,r=s.length-1;for(;i<r;){let t=i+Math.floor((r-i)/2);if(s[t].endLineNumber<e)i=t+1;else if(s[t].startLineNumber>e)r=t-1;else{for(;t>i&&s[t-1].startLineNumber<=e&&e<=s[t-1].endLineNumber;)t--;return t}}return i}acceptEdit(s,e,i,r,t){for(const a of this._pieces)a.acceptEdit(s,e,i,r,t)}}export{E as SparseTokensStore};
