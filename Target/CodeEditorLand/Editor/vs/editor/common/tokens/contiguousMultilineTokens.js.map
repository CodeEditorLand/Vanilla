{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/tokens/contiguousMultilineTokens.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from \"../../../base/common/arrays.js\";\nimport { readUInt32BE, writeUInt32BE } from \"../../../base/common/buffer.js\";\nimport { countEOL } from \"../core/eolCounter.js\";\nimport { LineRange } from \"../core/lineRange.js\";\nimport { Position } from \"../core/position.js\";\nimport type { IRange } from \"../core/range.js\";\nimport { ContiguousTokensEditing } from \"./contiguousTokensEditing.js\";\n\n/**\n * Represents contiguous tokens over a contiguous range of lines.\n */\nexport class ContiguousMultilineTokens {\n\tpublic static deserialize(\n\t\tbuff: Uint8Array,\n\t\toffset: number,\n\t\tresult: ContiguousMultilineTokens[],\n\t): number {\n\t\tconst view32 = new Uint32Array(buff.buffer);\n\t\tconst startLineNumber = readUInt32BE(buff, offset);\n\t\toffset += 4;\n\t\tconst count = readUInt32BE(buff, offset);\n\t\toffset += 4;\n\t\tconst tokens: Uint32Array[] = [];\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst byteCount = readUInt32BE(buff, offset);\n\t\t\toffset += 4;\n\t\t\ttokens.push(\n\t\t\t\tview32.subarray(offset / 4, offset / 4 + byteCount / 4),\n\t\t\t);\n\t\t\toffset += byteCount;\n\t\t}\n\t\tresult.push(new ContiguousMultilineTokens(startLineNumber, tokens));\n\t\treturn offset;\n\t}\n\n\t/**\n\t * The start line number for this block of tokens.\n\t */\n\tprivate _startLineNumber: number;\n\n\t/**\n\t * The tokens are stored in a binary format. There is an element for each line,\n\t * so `tokens[index]` contains all tokens on line `startLineNumber + index`.\n\t *\n\t * On a specific line, each token occupies two array indices. For token i:\n\t *  - at offset 2*i => endOffset\n\t *  - at offset 2*i + 1 => metadata\n\t *\n\t */\n\tprivate _tokens: (Uint32Array | ArrayBuffer | null)[];\n\n\t/**\n\t * (Inclusive) start line number for these tokens.\n\t */\n\tpublic get startLineNumber(): number {\n\t\treturn this._startLineNumber;\n\t}\n\n\t/**\n\t * (Inclusive) end line number for these tokens.\n\t */\n\tpublic get endLineNumber(): number {\n\t\treturn this._startLineNumber + this._tokens.length - 1;\n\t}\n\n\tconstructor(startLineNumber: number, tokens: Uint32Array[]) {\n\t\tthis._startLineNumber = startLineNumber;\n\t\tthis._tokens = tokens;\n\t}\n\n\tgetLineRange(): LineRange {\n\t\treturn new LineRange(\n\t\t\tthis._startLineNumber,\n\t\t\tthis._startLineNumber + this._tokens.length,\n\t\t);\n\t}\n\n\t/**\n\t * @see {@link _tokens}\n\t */\n\tpublic getLineTokens(lineNumber: number): Uint32Array | ArrayBuffer | null {\n\t\treturn this._tokens[lineNumber - this._startLineNumber];\n\t}\n\n\tpublic appendLineTokens(lineTokens: Uint32Array): void {\n\t\tthis._tokens.push(lineTokens);\n\t}\n\n\tpublic serializeSize(): number {\n\t\tlet result = 0;\n\t\tresult += 4; // 4 bytes for the start line number\n\t\tresult += 4; // 4 bytes for the line count\n\t\tfor (let i = 0; i < this._tokens.length; i++) {\n\t\t\tconst lineTokens = this._tokens[i];\n\t\t\tif (!(lineTokens instanceof Uint32Array)) {\n\t\t\t\tthrow new Error(`Not supported!`);\n\t\t\t}\n\t\t\tresult += 4; // 4 bytes for the byte count\n\t\t\tresult += lineTokens.byteLength;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic serialize(destination: Uint8Array, offset: number): number {\n\t\twriteUInt32BE(destination, this._startLineNumber, offset);\n\t\toffset += 4;\n\t\twriteUInt32BE(destination, this._tokens.length, offset);\n\t\toffset += 4;\n\t\tfor (let i = 0; i < this._tokens.length; i++) {\n\t\t\tconst lineTokens = this._tokens[i];\n\t\t\tif (!(lineTokens instanceof Uint32Array)) {\n\t\t\t\tthrow new Error(`Not supported!`);\n\t\t\t}\n\t\t\twriteUInt32BE(destination, lineTokens.byteLength, offset);\n\t\t\toffset += 4;\n\t\t\tdestination.set(new Uint8Array(lineTokens.buffer), offset);\n\t\t\toffset += lineTokens.byteLength;\n\t\t}\n\t\treturn offset;\n\t}\n\n\tpublic applyEdit(range: IRange, text: string): void {\n\t\tconst [eolCount, firstLineLength] = countEOL(text);\n\t\tthis._acceptDeleteRange(range);\n\t\tthis._acceptInsertText(\n\t\t\tnew Position(range.startLineNumber, range.startColumn),\n\t\t\teolCount,\n\t\t\tfirstLineLength,\n\t\t);\n\t}\n\n\tprivate _acceptDeleteRange(range: IRange): void {\n\t\tif (\n\t\t\trange.startLineNumber === range.endLineNumber &&\n\t\t\trange.startColumn === range.endColumn\n\t\t) {\n\t\t\t// Nothing to delete\n\t\t\treturn;\n\t\t}\n\n\t\tconst firstLineIndex = range.startLineNumber - this._startLineNumber;\n\t\tconst lastLineIndex = range.endLineNumber - this._startLineNumber;\n\n\t\tif (lastLineIndex < 0) {\n\t\t\t// this deletion occurs entirely before this block, so we only need to adjust line numbers\n\t\t\tconst deletedLinesCount = lastLineIndex - firstLineIndex;\n\t\t\tthis._startLineNumber -= deletedLinesCount;\n\t\t\treturn;\n\t\t}\n\n\t\tif (firstLineIndex >= this._tokens.length) {\n\t\t\t// this deletion occurs entirely after this block, so there is nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif (firstLineIndex < 0 && lastLineIndex >= this._tokens.length) {\n\t\t\t// this deletion completely encompasses this block\n\t\t\tthis._startLineNumber = 0;\n\t\t\tthis._tokens = [];\n\t\t\treturn;\n\t\t}\n\n\t\tif (firstLineIndex === lastLineIndex) {\n\t\t\t// a delete on a single line\n\t\t\tthis._tokens[firstLineIndex] = ContiguousTokensEditing.delete(\n\t\t\t\tthis._tokens[firstLineIndex],\n\t\t\t\trange.startColumn - 1,\n\t\t\t\trange.endColumn - 1,\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tif (firstLineIndex >= 0) {\n\t\t\t// The first line survives\n\t\t\tthis._tokens[firstLineIndex] = ContiguousTokensEditing.deleteEnding(\n\t\t\t\tthis._tokens[firstLineIndex],\n\t\t\t\trange.startColumn - 1,\n\t\t\t);\n\n\t\t\tif (lastLineIndex < this._tokens.length) {\n\t\t\t\t// The last line survives\n\t\t\t\tconst lastLineTokens = ContiguousTokensEditing.deleteBeginning(\n\t\t\t\t\tthis._tokens[lastLineIndex],\n\t\t\t\t\trange.endColumn - 1,\n\t\t\t\t);\n\n\t\t\t\t// Take remaining text on last line and append it to remaining text on first line\n\t\t\t\tthis._tokens[firstLineIndex] = ContiguousTokensEditing.append(\n\t\t\t\t\tthis._tokens[firstLineIndex],\n\t\t\t\t\tlastLineTokens,\n\t\t\t\t);\n\n\t\t\t\t// Delete middle lines\n\t\t\t\tthis._tokens.splice(\n\t\t\t\t\tfirstLineIndex + 1,\n\t\t\t\t\tlastLineIndex - firstLineIndex,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t// The last line does not survive\n\n\t\t\t\t// Take remaining text on last line and append it to remaining text on first line\n\t\t\t\tthis._tokens[firstLineIndex] = ContiguousTokensEditing.append(\n\t\t\t\t\tthis._tokens[firstLineIndex],\n\t\t\t\t\tnull,\n\t\t\t\t);\n\n\t\t\t\t// Delete lines\n\t\t\t\tthis._tokens = this._tokens.slice(0, firstLineIndex + 1);\n\t\t\t}\n\t\t} else {\n\t\t\t// The first line does not survive\n\n\t\t\tconst deletedBefore = -firstLineIndex;\n\t\t\tthis._startLineNumber -= deletedBefore;\n\n\t\t\t// Remove beginning from last line\n\t\t\tthis._tokens[lastLineIndex] =\n\t\t\t\tContiguousTokensEditing.deleteBeginning(\n\t\t\t\t\tthis._tokens[lastLineIndex],\n\t\t\t\t\trange.endColumn - 1,\n\t\t\t\t);\n\n\t\t\t// Delete lines\n\t\t\tthis._tokens = this._tokens.slice(lastLineIndex);\n\t\t}\n\t}\n\n\tprivate _acceptInsertText(\n\t\tposition: Position,\n\t\teolCount: number,\n\t\tfirstLineLength: number,\n\t): void {\n\t\tif (eolCount === 0 && firstLineLength === 0) {\n\t\t\t// Nothing to insert\n\t\t\treturn;\n\t\t}\n\n\t\tconst lineIndex = position.lineNumber - this._startLineNumber;\n\n\t\tif (lineIndex < 0) {\n\t\t\t// this insertion occurs before this block, so we only need to adjust line numbers\n\t\t\tthis._startLineNumber += eolCount;\n\t\t\treturn;\n\t\t}\n\n\t\tif (lineIndex >= this._tokens.length) {\n\t\t\t// this insertion occurs after this block, so there is nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif (eolCount === 0) {\n\t\t\t// Inserting text on one line\n\t\t\tthis._tokens[lineIndex] = ContiguousTokensEditing.insert(\n\t\t\t\tthis._tokens[lineIndex],\n\t\t\t\tposition.column - 1,\n\t\t\t\tfirstLineLength,\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._tokens[lineIndex] = ContiguousTokensEditing.deleteEnding(\n\t\t\tthis._tokens[lineIndex],\n\t\t\tposition.column - 1,\n\t\t);\n\t\tthis._tokens[lineIndex] = ContiguousTokensEditing.insert(\n\t\t\tthis._tokens[lineIndex],\n\t\t\tposition.column - 1,\n\t\t\tfirstLineLength,\n\t\t);\n\n\t\tthis._insertLines(position.lineNumber, eolCount);\n\t}\n\n\tprivate _insertLines(insertIndex: number, insertCount: number): void {\n\t\tif (insertCount === 0) {\n\t\t\treturn;\n\t\t}\n\t\tconst lineTokens: (Uint32Array | ArrayBuffer | null)[] = [];\n\t\tfor (let i = 0; i < insertCount; i++) {\n\t\t\tlineTokens[i] = null;\n\t\t}\n\t\tthis._tokens = arrays.arrayInsert(\n\t\t\tthis._tokens,\n\t\t\tinsertIndex,\n\t\t\tlineTokens,\n\t\t);\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
