{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/tokens/sparseMultilineTokens.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport { Position } from '../core/position.js';\nimport { IRange, Range } from '../core/range.js';\nimport { countEOL } from '../core/eolCounter.js';\n\n/**\n * Represents sparse tokens over a contiguous range of lines.\n */\nexport class SparseMultilineTokens {\n\n\tpublic static create(startLineNumber: number, tokens: Uint32Array): SparseMultilineTokens {\n\t\treturn new SparseMultilineTokens(startLineNumber, new SparseMultilineTokensStorage(tokens));\n\t}\n\n\tprivate _startLineNumber: number;\n\tprivate _endLineNumber: number;\n\tprivate readonly _tokens: SparseMultilineTokensStorage;\n\n\t/**\n\t * (Inclusive) start line number for these tokens.\n\t */\n\tpublic get startLineNumber(): number {\n\t\treturn this._startLineNumber;\n\t}\n\n\t/**\n\t * (Inclusive) end line number for these tokens.\n\t */\n\tpublic get endLineNumber(): number {\n\t\treturn this._endLineNumber;\n\t}\n\n\tprivate constructor(startLineNumber: number, tokens: SparseMultilineTokensStorage) {\n\t\tthis._startLineNumber = startLineNumber;\n\t\tthis._tokens = tokens;\n\t\tthis._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();\n\t}\n\n\tpublic toString(): string {\n\t\treturn this._tokens.toString(this._startLineNumber);\n\t}\n\n\tprivate _updateEndLineNumber(): void {\n\t\tthis._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();\n\t}\n\n\tpublic isEmpty(): boolean {\n\t\treturn this._tokens.isEmpty();\n\t}\n\n\tpublic getLineTokens(lineNumber: number): SparseLineTokens | null {\n\t\tif (this._startLineNumber <= lineNumber && lineNumber <= this._endLineNumber) {\n\t\t\treturn this._tokens.getLineTokens(lineNumber - this._startLineNumber);\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic getRange(): Range | null {\n\t\tconst deltaRange = this._tokens.getRange();\n\t\tif (!deltaRange) {\n\t\t\treturn deltaRange;\n\t\t}\n\t\treturn new Range(this._startLineNumber + deltaRange.startLineNumber, deltaRange.startColumn, this._startLineNumber + deltaRange.endLineNumber, deltaRange.endColumn);\n\t}\n\n\tpublic removeTokens(range: Range): void {\n\t\tconst startLineIndex = range.startLineNumber - this._startLineNumber;\n\t\tconst endLineIndex = range.endLineNumber - this._startLineNumber;\n\n\t\tthis._startLineNumber += this._tokens.removeTokens(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\n\t\tthis._updateEndLineNumber();\n\t}\n\n\tpublic split(range: Range): [SparseMultilineTokens, SparseMultilineTokens] {\n\t\t// split tokens to two:\n\t\t// a) all the tokens before `range`\n\t\t// b) all the tokens after `range`\n\t\tconst startLineIndex = range.startLineNumber - this._startLineNumber;\n\t\tconst endLineIndex = range.endLineNumber - this._startLineNumber;\n\n\t\tconst [a, b, bDeltaLine] = this._tokens.split(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\n\t\treturn [new SparseMultilineTokens(this._startLineNumber, a), new SparseMultilineTokens(this._startLineNumber + bDeltaLine, b)];\n\t}\n\n\tpublic applyEdit(range: IRange, text: string): void {\n\t\tconst [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n\t\tthis.acceptEdit(range, eolCount, firstLineLength, lastLineLength, text.length > 0 ? text.charCodeAt(0) : CharCode.Null);\n\t}\n\n\tpublic acceptEdit(range: IRange, eolCount: number, firstLineLength: number, lastLineLength: number, firstCharCode: number): void {\n\t\tthis._acceptDeleteRange(range);\n\t\tthis._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength, lastLineLength, firstCharCode);\n\t\tthis._updateEndLineNumber();\n\t}\n\n\tprivate _acceptDeleteRange(range: IRange): void {\n\t\tif (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n\t\t\t// Nothing to delete\n\t\t\treturn;\n\t\t}\n\n\t\tconst firstLineIndex = range.startLineNumber - this._startLineNumber;\n\t\tconst lastLineIndex = range.endLineNumber - this._startLineNumber;\n\n\t\tif (lastLineIndex < 0) {\n\t\t\t// this deletion occurs entirely before this block, so we only need to adjust line numbers\n\t\t\tconst deletedLinesCount = lastLineIndex - firstLineIndex;\n\t\t\tthis._startLineNumber -= deletedLinesCount;\n\t\t\treturn;\n\t\t}\n\n\t\tconst tokenMaxDeltaLine = this._tokens.getMaxDeltaLine();\n\n\t\tif (firstLineIndex >= tokenMaxDeltaLine + 1) {\n\t\t\t// this deletion occurs entirely after this block, so there is nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif (firstLineIndex < 0 && lastLineIndex >= tokenMaxDeltaLine + 1) {\n\t\t\t// this deletion completely encompasses this block\n\t\t\tthis._startLineNumber = 0;\n\t\t\tthis._tokens.clear();\n\t\t\treturn;\n\t\t}\n\n\t\tif (firstLineIndex < 0) {\n\t\t\tconst deletedBefore = -firstLineIndex;\n\t\t\tthis._startLineNumber -= deletedBefore;\n\n\t\t\tthis._tokens.acceptDeleteRange(range.startColumn - 1, 0, 0, lastLineIndex, range.endColumn - 1);\n\t\t} else {\n\t\t\tthis._tokens.acceptDeleteRange(0, firstLineIndex, range.startColumn - 1, lastLineIndex, range.endColumn - 1);\n\t\t}\n\t}\n\n\tprivate _acceptInsertText(position: Position, eolCount: number, firstLineLength: number, lastLineLength: number, firstCharCode: number): void {\n\n\t\tif (eolCount === 0 && firstLineLength === 0) {\n\t\t\t// Nothing to insert\n\t\t\treturn;\n\t\t}\n\n\t\tconst lineIndex = position.lineNumber - this._startLineNumber;\n\n\t\tif (lineIndex < 0) {\n\t\t\t// this insertion occurs before this block, so we only need to adjust line numbers\n\t\t\tthis._startLineNumber += eolCount;\n\t\t\treturn;\n\t\t}\n\n\t\tconst tokenMaxDeltaLine = this._tokens.getMaxDeltaLine();\n\n\t\tif (lineIndex >= tokenMaxDeltaLine + 1) {\n\t\t\t// this insertion occurs after this block, so there is nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tthis._tokens.acceptInsertText(lineIndex, position.column - 1, eolCount, firstLineLength, lastLineLength, firstCharCode);\n\t}\n}\n\nclass SparseMultilineTokensStorage {\n\t/**\n\t * The encoding of tokens is:\n\t *  4*i    deltaLine (from `startLineNumber`)\n\t *  4*i+1  startCharacter (from the line start)\n\t *  4*i+2  endCharacter (from the line start)\n\t *  4*i+3  metadata\n\t */\n\tprivate readonly _tokens: Uint32Array;\n\tprivate _tokenCount: number;\n\n\tconstructor(tokens: Uint32Array) {\n\t\tthis._tokens = tokens;\n\t\tthis._tokenCount = tokens.length / 4;\n\t}\n\n\tpublic toString(startLineNumber: number): string {\n\t\tconst pieces: string[] = [];\n\t\tfor (let i = 0; i < this._tokenCount; i++) {\n\t\t\tpieces.push(`(${this._getDeltaLine(i) + startLineNumber},${this._getStartCharacter(i)}-${this._getEndCharacter(i)})`);\n\t\t}\n\t\treturn `[${pieces.join(',')}]`;\n\t}\n\n\tpublic getMaxDeltaLine(): number {\n\t\tconst tokenCount = this._getTokenCount();\n\t\tif (tokenCount === 0) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn this._getDeltaLine(tokenCount - 1);\n\t}\n\n\tpublic getRange(): Range | null {\n\t\tconst tokenCount = this._getTokenCount();\n\t\tif (tokenCount === 0) {\n\t\t\treturn null;\n\t\t}\n\t\tconst startChar = this._getStartCharacter(0);\n\t\tconst maxDeltaLine = this._getDeltaLine(tokenCount - 1);\n\t\tconst endChar = this._getEndCharacter(tokenCount - 1);\n\t\treturn new Range(0, startChar + 1, maxDeltaLine, endChar + 1);\n\t}\n\n\tprivate _getTokenCount(): number {\n\t\treturn this._tokenCount;\n\t}\n\n\tprivate _getDeltaLine(tokenIndex: number): number {\n\t\treturn this._tokens[4 * tokenIndex];\n\t}\n\n\tprivate _getStartCharacter(tokenIndex: number): number {\n\t\treturn this._tokens[4 * tokenIndex + 1];\n\t}\n\n\tprivate _getEndCharacter(tokenIndex: number): number {\n\t\treturn this._tokens[4 * tokenIndex + 2];\n\t}\n\n\tpublic isEmpty(): boolean {\n\t\treturn (this._getTokenCount() === 0);\n\t}\n\n\tpublic getLineTokens(deltaLine: number): SparseLineTokens | null {\n\t\tlet low = 0;\n\t\tlet high = this._getTokenCount() - 1;\n\n\t\twhile (low < high) {\n\t\t\tconst mid = low + Math.floor((high - low) / 2);\n\t\t\tconst midDeltaLine = this._getDeltaLine(mid);\n\n\t\t\tif (midDeltaLine < deltaLine) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else if (midDeltaLine > deltaLine) {\n\t\t\t\thigh = mid - 1;\n\t\t\t} else {\n\t\t\t\tlet min = mid;\n\t\t\t\twhile (min > low && this._getDeltaLine(min - 1) === deltaLine) {\n\t\t\t\t\tmin--;\n\t\t\t\t}\n\t\t\t\tlet max = mid;\n\t\t\t\twhile (max < high && this._getDeltaLine(max + 1) === deltaLine) {\n\t\t\t\t\tmax++;\n\t\t\t\t}\n\t\t\t\treturn new SparseLineTokens(this._tokens.subarray(4 * min, 4 * max + 4));\n\t\t\t}\n\t\t}\n\n\t\tif (this._getDeltaLine(low) === deltaLine) {\n\t\t\treturn new SparseLineTokens(this._tokens.subarray(4 * low, 4 * low + 4));\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic clear(): void {\n\t\tthis._tokenCount = 0;\n\t}\n\n\tpublic removeTokens(startDeltaLine: number, startChar: number, endDeltaLine: number, endChar: number): number {\n\t\tconst tokens = this._tokens;\n\t\tconst tokenCount = this._tokenCount;\n\t\tlet newTokenCount = 0;\n\t\tlet hasDeletedTokens = false;\n\t\tlet firstDeltaLine = 0;\n\t\tfor (let i = 0; i < tokenCount; i++) {\n\t\t\tconst srcOffset = 4 * i;\n\t\t\tconst tokenDeltaLine = tokens[srcOffset];\n\t\t\tconst tokenStartCharacter = tokens[srcOffset + 1];\n\t\t\tconst tokenEndCharacter = tokens[srcOffset + 2];\n\t\t\tconst tokenMetadata = tokens[srcOffset + 3];\n\n\t\t\tif (\n\t\t\t\t(tokenDeltaLine > startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar))\n\t\t\t\t&& (tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar))\n\t\t\t) {\n\t\t\t\thasDeletedTokens = true;\n\t\t\t} else {\n\t\t\t\tif (newTokenCount === 0) {\n\t\t\t\t\tfirstDeltaLine = tokenDeltaLine;\n\t\t\t\t}\n\t\t\t\tif (hasDeletedTokens) {\n\t\t\t\t\t// must move the token to the left\n\t\t\t\t\tconst destOffset = 4 * newTokenCount;\n\t\t\t\t\ttokens[destOffset] = tokenDeltaLine - firstDeltaLine;\n\t\t\t\t\ttokens[destOffset + 1] = tokenStartCharacter;\n\t\t\t\t\ttokens[destOffset + 2] = tokenEndCharacter;\n\t\t\t\t\ttokens[destOffset + 3] = tokenMetadata;\n\t\t\t\t}\n\t\t\t\tnewTokenCount++;\n\t\t\t}\n\t\t}\n\n\t\tthis._tokenCount = newTokenCount;\n\n\t\treturn firstDeltaLine;\n\t}\n\n\tpublic split(startDeltaLine: number, startChar: number, endDeltaLine: number, endChar: number): [SparseMultilineTokensStorage, SparseMultilineTokensStorage, number] {\n\t\tconst tokens = this._tokens;\n\t\tconst tokenCount = this._tokenCount;\n\t\tconst aTokens: number[] = [];\n\t\tconst bTokens: number[] = [];\n\t\tlet destTokens: number[] = aTokens;\n\t\tlet destOffset = 0;\n\t\tlet destFirstDeltaLine: number = 0;\n\t\tfor (let i = 0; i < tokenCount; i++) {\n\t\t\tconst srcOffset = 4 * i;\n\t\t\tconst tokenDeltaLine = tokens[srcOffset];\n\t\t\tconst tokenStartCharacter = tokens[srcOffset + 1];\n\t\t\tconst tokenEndCharacter = tokens[srcOffset + 2];\n\t\t\tconst tokenMetadata = tokens[srcOffset + 3];\n\n\t\t\tif ((tokenDeltaLine > startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar))) {\n\t\t\t\tif ((tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar))) {\n\t\t\t\t\t// this token is touching the range\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\t// this token is after the range\n\t\t\t\t\tif (destTokens !== bTokens) {\n\t\t\t\t\t\t// this token is the first token after the range\n\t\t\t\t\t\tdestTokens = bTokens;\n\t\t\t\t\t\tdestOffset = 0;\n\t\t\t\t\t\tdestFirstDeltaLine = tokenDeltaLine;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdestTokens[destOffset++] = tokenDeltaLine - destFirstDeltaLine;\n\t\t\tdestTokens[destOffset++] = tokenStartCharacter;\n\t\t\tdestTokens[destOffset++] = tokenEndCharacter;\n\t\t\tdestTokens[destOffset++] = tokenMetadata;\n\t\t}\n\n\t\treturn [new SparseMultilineTokensStorage(new Uint32Array(aTokens)), new SparseMultilineTokensStorage(new Uint32Array(bTokens)), destFirstDeltaLine];\n\t}\n\n\tpublic acceptDeleteRange(horizontalShiftForFirstLineTokens: number, startDeltaLine: number, startCharacter: number, endDeltaLine: number, endCharacter: number): void {\n\t\t// This is a bit complex, here are the cases I used to think about this:\n\t\t//\n\t\t// 1. The token starts before the deletion range\n\t\t// 1a. The token is completely before the deletion range\n\t\t//               -----------\n\t\t//                          xxxxxxxxxxx\n\t\t// 1b. The token starts before, the deletion range ends after the token\n\t\t//               -----------\n\t\t//                      xxxxxxxxxxx\n\t\t// 1c. The token starts before, the deletion range ends precisely with the token\n\t\t//               ---------------\n\t\t//                      xxxxxxxx\n\t\t// 1d. The token starts before, the deletion range is inside the token\n\t\t//               ---------------\n\t\t//                    xxxxx\n\t\t//\n\t\t// 2. The token starts at the same position with the deletion range\n\t\t// 2a. The token starts at the same position, and ends inside the deletion range\n\t\t//               -------\n\t\t//               xxxxxxxxxxx\n\t\t// 2b. The token starts at the same position, and ends at the same position as the deletion range\n\t\t//               ----------\n\t\t//               xxxxxxxxxx\n\t\t// 2c. The token starts at the same position, and ends after the deletion range\n\t\t//               -------------\n\t\t//               xxxxxxx\n\t\t//\n\t\t// 3. The token starts inside the deletion range\n\t\t// 3a. The token is inside the deletion range\n\t\t//                -------\n\t\t//             xxxxxxxxxxxxx\n\t\t// 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n\t\t//                ----------\n\t\t//             xxxxxxxxxxxxx\n\t\t// 3c. The token starts inside the deletion range, and ends after the deletion range\n\t\t//                ------------\n\t\t//             xxxxxxxxxxx\n\t\t//\n\t\t// 4. The token starts after the deletion range\n\t\t//                  -----------\n\t\t//          xxxxxxxx\n\t\t//\n\t\tconst tokens = this._tokens;\n\t\tconst tokenCount = this._tokenCount;\n\t\tconst deletedLineCount = (endDeltaLine - startDeltaLine);\n\t\tlet newTokenCount = 0;\n\t\tlet hasDeletedTokens = false;\n\t\tfor (let i = 0; i < tokenCount; i++) {\n\t\t\tconst srcOffset = 4 * i;\n\t\t\tlet tokenDeltaLine = tokens[srcOffset];\n\t\t\tlet tokenStartCharacter = tokens[srcOffset + 1];\n\t\t\tlet tokenEndCharacter = tokens[srcOffset + 2];\n\t\t\tconst tokenMetadata = tokens[srcOffset + 3];\n\n\t\t\tif (tokenDeltaLine < startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter <= startCharacter)) {\n\t\t\t\t// 1a. The token is completely before the deletion range\n\t\t\t\t// => nothing to do\n\t\t\t\tnewTokenCount++;\n\t\t\t\tcontinue;\n\t\t\t} else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter < startCharacter) {\n\t\t\t\t// 1b, 1c, 1d\n\t\t\t\t// => the token survives, but it needs to shrink\n\t\t\t\tif (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n\t\t\t\t\t// 1d. The token starts before, the deletion range is inside the token\n\t\t\t\t\t// => the token shrinks by the deletion character count\n\t\t\t\t\ttokenEndCharacter -= (endCharacter - startCharacter);\n\t\t\t\t} else {\n\t\t\t\t\t// 1b. The token starts before, the deletion range ends after the token\n\t\t\t\t\t// 1c. The token starts before, the deletion range ends precisely with the token\n\t\t\t\t\t// => the token shrinks its ending to the deletion start\n\t\t\t\t\ttokenEndCharacter = startCharacter;\n\t\t\t\t}\n\t\t\t} else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter === startCharacter) {\n\t\t\t\t// 2a, 2b, 2c\n\t\t\t\tif (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n\t\t\t\t\t// 2c. The token starts at the same position, and ends after the deletion range\n\t\t\t\t\t// => the token shrinks by the deletion character count\n\t\t\t\t\ttokenEndCharacter -= (endCharacter - startCharacter);\n\t\t\t\t} else {\n\t\t\t\t\t// 2a. The token starts at the same position, and ends inside the deletion range\n\t\t\t\t\t// 2b. The token starts at the same position, and ends at the same position as the deletion range\n\t\t\t\t\t// => the token is deleted\n\t\t\t\t\thasDeletedTokens = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter < endCharacter)) {\n\t\t\t\t// 3a, 3b, 3c\n\t\t\t\tif (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n\t\t\t\t\t// 3c. The token starts inside the deletion range, and ends after the deletion range\n\t\t\t\t\t// => the token moves to continue right after the deletion\n\t\t\t\t\ttokenDeltaLine = startDeltaLine;\n\t\t\t\t\ttokenStartCharacter = startCharacter;\n\t\t\t\t\ttokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\n\t\t\t\t} else {\n\t\t\t\t\t// 3a. The token is inside the deletion range\n\t\t\t\t\t// 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n\t\t\t\t\t// => the token is deleted\n\t\t\t\t\thasDeletedTokens = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (tokenDeltaLine > endDeltaLine) {\n\t\t\t\t// 4. (partial) The token starts after the deletion range, on a line below...\n\t\t\t\tif (deletedLineCount === 0 && !hasDeletedTokens) {\n\t\t\t\t\t// early stop, there is no need to walk all the tokens and do nothing...\n\t\t\t\t\tnewTokenCount = tokenCount;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttokenDeltaLine -= deletedLineCount;\n\t\t\t} else if (tokenDeltaLine === endDeltaLine && tokenStartCharacter >= endCharacter) {\n\t\t\t\t// 4. (continued) The token starts after the deletion range, on the last line where a deletion occurs\n\t\t\t\tif (horizontalShiftForFirstLineTokens && tokenDeltaLine === 0) {\n\t\t\t\t\ttokenStartCharacter += horizontalShiftForFirstLineTokens;\n\t\t\t\t\ttokenEndCharacter += horizontalShiftForFirstLineTokens;\n\t\t\t\t}\n\t\t\t\ttokenDeltaLine -= deletedLineCount;\n\t\t\t\ttokenStartCharacter -= (endCharacter - startCharacter);\n\t\t\t\ttokenEndCharacter -= (endCharacter - startCharacter);\n\t\t\t} else {\n\t\t\t\tthrow new Error(`Not possible!`);\n\t\t\t}\n\n\t\t\tconst destOffset = 4 * newTokenCount;\n\t\t\ttokens[destOffset] = tokenDeltaLine;\n\t\t\ttokens[destOffset + 1] = tokenStartCharacter;\n\t\t\ttokens[destOffset + 2] = tokenEndCharacter;\n\t\t\ttokens[destOffset + 3] = tokenMetadata;\n\t\t\tnewTokenCount++;\n\t\t}\n\n\t\tthis._tokenCount = newTokenCount;\n\t}\n\n\tpublic acceptInsertText(deltaLine: number, character: number, eolCount: number, firstLineLength: number, lastLineLength: number, firstCharCode: number): void {\n\t\t// Here are the cases I used to think about this:\n\t\t//\n\t\t// 1. The token is completely before the insertion point\n\t\t//            -----------   |\n\t\t// 2. The token ends precisely at the insertion point\n\t\t//            -----------|\n\t\t// 3. The token contains the insertion point\n\t\t//            -----|------\n\t\t// 4. The token starts precisely at the insertion point\n\t\t//            |-----------\n\t\t// 5. The token is completely after the insertion point\n\t\t//            |   -----------\n\t\t//\n\t\tconst isInsertingPreciselyOneWordCharacter = (\n\t\t\teolCount === 0\n\t\t\t&& firstLineLength === 1\n\t\t\t&& (\n\t\t\t\t(firstCharCode >= CharCode.Digit0 && firstCharCode <= CharCode.Digit9)\n\t\t\t\t|| (firstCharCode >= CharCode.A && firstCharCode <= CharCode.Z)\n\t\t\t\t|| (firstCharCode >= CharCode.a && firstCharCode <= CharCode.z)\n\t\t\t)\n\t\t);\n\t\tconst tokens = this._tokens;\n\t\tconst tokenCount = this._tokenCount;\n\t\tfor (let i = 0; i < tokenCount; i++) {\n\t\t\tconst offset = 4 * i;\n\t\t\tlet tokenDeltaLine = tokens[offset];\n\t\t\tlet tokenStartCharacter = tokens[offset + 1];\n\t\t\tlet tokenEndCharacter = tokens[offset + 2];\n\n\t\t\tif (tokenDeltaLine < deltaLine || (tokenDeltaLine === deltaLine && tokenEndCharacter < character)) {\n\t\t\t\t// 1. The token is completely before the insertion point\n\t\t\t\t// => nothing to do\n\t\t\t\tcontinue;\n\t\t\t} else if (tokenDeltaLine === deltaLine && tokenEndCharacter === character) {\n\t\t\t\t// 2. The token ends precisely at the insertion point\n\t\t\t\t// => expand the end character only if inserting precisely one character that is a word character\n\t\t\t\tif (isInsertingPreciselyOneWordCharacter) {\n\t\t\t\t\ttokenEndCharacter += 1;\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (tokenDeltaLine === deltaLine && tokenStartCharacter < character && character < tokenEndCharacter) {\n\t\t\t\t// 3. The token contains the insertion point\n\t\t\t\tif (eolCount === 0) {\n\t\t\t\t\t// => just expand the end character\n\t\t\t\t\ttokenEndCharacter += firstLineLength;\n\t\t\t\t} else {\n\t\t\t\t\t// => cut off the token\n\t\t\t\t\ttokenEndCharacter = character;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// 4. or 5.\n\t\t\t\tif (tokenDeltaLine === deltaLine && tokenStartCharacter === character) {\n\t\t\t\t\t// 4. The token starts precisely at the insertion point\n\t\t\t\t\t// => grow the token (by keeping its start constant) only if inserting precisely one character that is a word character\n\t\t\t\t\t// => otherwise behave as in case 5.\n\t\t\t\t\tif (isInsertingPreciselyOneWordCharacter) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// => the token must move and keep its size constant\n\t\t\t\tif (tokenDeltaLine === deltaLine) {\n\t\t\t\t\ttokenDeltaLine += eolCount;\n\t\t\t\t\t// this token is on the line where the insertion is taking place\n\t\t\t\t\tif (eolCount === 0) {\n\t\t\t\t\t\ttokenStartCharacter += firstLineLength;\n\t\t\t\t\t\ttokenEndCharacter += firstLineLength;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst tokenLength = tokenEndCharacter - tokenStartCharacter;\n\t\t\t\t\t\ttokenStartCharacter = lastLineLength + (tokenStartCharacter - character);\n\t\t\t\t\t\ttokenEndCharacter = tokenStartCharacter + tokenLength;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttokenDeltaLine += eolCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttokens[offset] = tokenDeltaLine;\n\t\t\ttokens[offset + 1] = tokenStartCharacter;\n\t\t\ttokens[offset + 2] = tokenEndCharacter;\n\t\t}\n\t}\n}\n\nexport class SparseLineTokens {\n\n\tprivate readonly _tokens: Uint32Array;\n\n\tconstructor(tokens: Uint32Array) {\n\t\tthis._tokens = tokens;\n\t}\n\n\tpublic getCount(): number {\n\t\treturn this._tokens.length / 4;\n\t}\n\n\tpublic getStartCharacter(tokenIndex: number): number {\n\t\treturn this._tokens[4 * tokenIndex + 1];\n\t}\n\n\tpublic getEndCharacter(tokenIndex: number): number {\n\t\treturn this._tokens[4 * tokenIndex + 2];\n\t}\n\n\tpublic getMetadata(tokenIndex: number): number {\n\t\treturn this._tokens[4 * tokenIndex + 3];\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
