{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/tokens/sparseMultilineTokens.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from \"../../../base/common/charCode.js\";\nimport { countEOL } from \"../core/eolCounter.js\";\nimport { Position } from \"../core/position.js\";\nimport { type IRange, Range } from \"../core/range.js\";\n\n/**\n * Represents sparse tokens over a contiguous range of lines.\n */\nexport class SparseMultilineTokens {\n\tpublic static create(\n\t\tstartLineNumber: number,\n\t\ttokens: Uint32Array,\n\t): SparseMultilineTokens {\n\t\treturn new SparseMultilineTokens(\n\t\t\tstartLineNumber,\n\t\t\tnew SparseMultilineTokensStorage(tokens),\n\t\t);\n\t}\n\n\tprivate _startLineNumber: number;\n\tprivate _endLineNumber: number;\n\tprivate readonly _tokens: SparseMultilineTokensStorage;\n\n\t/**\n\t * (Inclusive) start line number for these tokens.\n\t */\n\tpublic get startLineNumber(): number {\n\t\treturn this._startLineNumber;\n\t}\n\n\t/**\n\t * (Inclusive) end line number for these tokens.\n\t */\n\tpublic get endLineNumber(): number {\n\t\treturn this._endLineNumber;\n\t}\n\n\tprivate constructor(\n\t\tstartLineNumber: number,\n\t\ttokens: SparseMultilineTokensStorage,\n\t) {\n\t\tthis._startLineNumber = startLineNumber;\n\t\tthis._tokens = tokens;\n\t\tthis._endLineNumber =\n\t\t\tthis._startLineNumber + this._tokens.getMaxDeltaLine();\n\t}\n\n\tpublic toString(): string {\n\t\treturn this._tokens.toString(this._startLineNumber);\n\t}\n\n\tprivate _updateEndLineNumber(): void {\n\t\tthis._endLineNumber =\n\t\t\tthis._startLineNumber + this._tokens.getMaxDeltaLine();\n\t}\n\n\tpublic isEmpty(): boolean {\n\t\treturn this._tokens.isEmpty();\n\t}\n\n\tpublic getLineTokens(lineNumber: number): SparseLineTokens | null {\n\t\tif (\n\t\t\tthis._startLineNumber <= lineNumber &&\n\t\t\tlineNumber <= this._endLineNumber\n\t\t) {\n\t\t\treturn this._tokens.getLineTokens(\n\t\t\t\tlineNumber - this._startLineNumber,\n\t\t\t);\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic getRange(): Range | null {\n\t\tconst deltaRange = this._tokens.getRange();\n\t\tif (!deltaRange) {\n\t\t\treturn deltaRange;\n\t\t}\n\t\treturn new Range(\n\t\t\tthis._startLineNumber + deltaRange.startLineNumber,\n\t\t\tdeltaRange.startColumn,\n\t\t\tthis._startLineNumber + deltaRange.endLineNumber,\n\t\t\tdeltaRange.endColumn,\n\t\t);\n\t}\n\n\tpublic removeTokens(range: Range): void {\n\t\tconst startLineIndex = range.startLineNumber - this._startLineNumber;\n\t\tconst endLineIndex = range.endLineNumber - this._startLineNumber;\n\n\t\tthis._startLineNumber += this._tokens.removeTokens(\n\t\t\tstartLineIndex,\n\t\t\trange.startColumn - 1,\n\t\t\tendLineIndex,\n\t\t\trange.endColumn - 1,\n\t\t);\n\t\tthis._updateEndLineNumber();\n\t}\n\n\tpublic split(range: Range): [SparseMultilineTokens, SparseMultilineTokens] {\n\t\t// split tokens to two:\n\t\t// a) all the tokens before `range`\n\t\t// b) all the tokens after `range`\n\t\tconst startLineIndex = range.startLineNumber - this._startLineNumber;\n\t\tconst endLineIndex = range.endLineNumber - this._startLineNumber;\n\n\t\tconst [a, b, bDeltaLine] = this._tokens.split(\n\t\t\tstartLineIndex,\n\t\t\trange.startColumn - 1,\n\t\t\tendLineIndex,\n\t\t\trange.endColumn - 1,\n\t\t);\n\t\treturn [\n\t\t\tnew SparseMultilineTokens(this._startLineNumber, a),\n\t\t\tnew SparseMultilineTokens(this._startLineNumber + bDeltaLine, b),\n\t\t];\n\t}\n\n\tpublic applyEdit(range: IRange, text: string): void {\n\t\tconst [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n\t\tthis.acceptEdit(\n\t\t\trange,\n\t\t\teolCount,\n\t\t\tfirstLineLength,\n\t\t\tlastLineLength,\n\t\t\ttext.length > 0 ? text.charCodeAt(0) : CharCode.Null,\n\t\t);\n\t}\n\n\tpublic acceptEdit(\n\t\trange: IRange,\n\t\teolCount: number,\n\t\tfirstLineLength: number,\n\t\tlastLineLength: number,\n\t\tfirstCharCode: number,\n\t): void {\n\t\tthis._acceptDeleteRange(range);\n\t\tthis._acceptInsertText(\n\t\t\tnew Position(range.startLineNumber, range.startColumn),\n\t\t\teolCount,\n\t\t\tfirstLineLength,\n\t\t\tlastLineLength,\n\t\t\tfirstCharCode,\n\t\t);\n\t\tthis._updateEndLineNumber();\n\t}\n\n\tprivate _acceptDeleteRange(range: IRange): void {\n\t\tif (\n\t\t\trange.startLineNumber === range.endLineNumber &&\n\t\t\trange.startColumn === range.endColumn\n\t\t) {\n\t\t\t// Nothing to delete\n\t\t\treturn;\n\t\t}\n\n\t\tconst firstLineIndex = range.startLineNumber - this._startLineNumber;\n\t\tconst lastLineIndex = range.endLineNumber - this._startLineNumber;\n\n\t\tif (lastLineIndex < 0) {\n\t\t\t// this deletion occurs entirely before this block, so we only need to adjust line numbers\n\t\t\tconst deletedLinesCount = lastLineIndex - firstLineIndex;\n\t\t\tthis._startLineNumber -= deletedLinesCount;\n\t\t\treturn;\n\t\t}\n\n\t\tconst tokenMaxDeltaLine = this._tokens.getMaxDeltaLine();\n\n\t\tif (firstLineIndex >= tokenMaxDeltaLine + 1) {\n\t\t\t// this deletion occurs entirely after this block, so there is nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif (firstLineIndex < 0 && lastLineIndex >= tokenMaxDeltaLine + 1) {\n\t\t\t// this deletion completely encompasses this block\n\t\t\tthis._startLineNumber = 0;\n\t\t\tthis._tokens.clear();\n\t\t\treturn;\n\t\t}\n\n\t\tif (firstLineIndex < 0) {\n\t\t\tconst deletedBefore = -firstLineIndex;\n\t\t\tthis._startLineNumber -= deletedBefore;\n\n\t\t\tthis._tokens.acceptDeleteRange(\n\t\t\t\trange.startColumn - 1,\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tlastLineIndex,\n\t\t\t\trange.endColumn - 1,\n\t\t\t);\n\t\t} else {\n\t\t\tthis._tokens.acceptDeleteRange(\n\t\t\t\t0,\n\t\t\t\tfirstLineIndex,\n\t\t\t\trange.startColumn - 1,\n\t\t\t\tlastLineIndex,\n\t\t\t\trange.endColumn - 1,\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate _acceptInsertText(\n\t\tposition: Position,\n\t\teolCount: number,\n\t\tfirstLineLength: number,\n\t\tlastLineLength: number,\n\t\tfirstCharCode: number,\n\t): void {\n\t\tif (eolCount === 0 && firstLineLength === 0) {\n\t\t\t// Nothing to insert\n\t\t\treturn;\n\t\t}\n\n\t\tconst lineIndex = position.lineNumber - this._startLineNumber;\n\n\t\tif (lineIndex < 0) {\n\t\t\t// this insertion occurs before this block, so we only need to adjust line numbers\n\t\t\tthis._startLineNumber += eolCount;\n\t\t\treturn;\n\t\t}\n\n\t\tconst tokenMaxDeltaLine = this._tokens.getMaxDeltaLine();\n\n\t\tif (lineIndex >= tokenMaxDeltaLine + 1) {\n\t\t\t// this insertion occurs after this block, so there is nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tthis._tokens.acceptInsertText(\n\t\t\tlineIndex,\n\t\t\tposition.column - 1,\n\t\t\teolCount,\n\t\t\tfirstLineLength,\n\t\t\tlastLineLength,\n\t\t\tfirstCharCode,\n\t\t);\n\t}\n}\n\nclass SparseMultilineTokensStorage {\n\t/**\n\t * The encoding of tokens is:\n\t *  4*i    deltaLine (from `startLineNumber`)\n\t *  4*i+1  startCharacter (from the line start)\n\t *  4*i+2  endCharacter (from the line start)\n\t *  4*i+3  metadata\n\t */\n\tprivate readonly _tokens: Uint32Array;\n\tprivate _tokenCount: number;\n\n\tconstructor(tokens: Uint32Array) {\n\t\tthis._tokens = tokens;\n\t\tthis._tokenCount = tokens.length / 4;\n\t}\n\n\tpublic toString(startLineNumber: number): string {\n\t\tconst pieces: string[] = [];\n\t\tfor (let i = 0; i < this._tokenCount; i++) {\n\t\t\tpieces.push(\n\t\t\t\t`(${this._getDeltaLine(i) + startLineNumber},${this._getStartCharacter(i)}-${this._getEndCharacter(i)})`,\n\t\t\t);\n\t\t}\n\t\treturn `[${pieces.join(\",\")}]`;\n\t}\n\n\tpublic getMaxDeltaLine(): number {\n\t\tconst tokenCount = this._getTokenCount();\n\t\tif (tokenCount === 0) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn this._getDeltaLine(tokenCount - 1);\n\t}\n\n\tpublic getRange(): Range | null {\n\t\tconst tokenCount = this._getTokenCount();\n\t\tif (tokenCount === 0) {\n\t\t\treturn null;\n\t\t}\n\t\tconst startChar = this._getStartCharacter(0);\n\t\tconst maxDeltaLine = this._getDeltaLine(tokenCount - 1);\n\t\tconst endChar = this._getEndCharacter(tokenCount - 1);\n\t\treturn new Range(0, startChar + 1, maxDeltaLine, endChar + 1);\n\t}\n\n\tprivate _getTokenCount(): number {\n\t\treturn this._tokenCount;\n\t}\n\n\tprivate _getDeltaLine(tokenIndex: number): number {\n\t\treturn this._tokens[4 * tokenIndex];\n\t}\n\n\tprivate _getStartCharacter(tokenIndex: number): number {\n\t\treturn this._tokens[4 * tokenIndex + 1];\n\t}\n\n\tprivate _getEndCharacter(tokenIndex: number): number {\n\t\treturn this._tokens[4 * tokenIndex + 2];\n\t}\n\n\tpublic isEmpty(): boolean {\n\t\treturn this._getTokenCount() === 0;\n\t}\n\n\tpublic getLineTokens(deltaLine: number): SparseLineTokens | null {\n\t\tlet low = 0;\n\t\tlet high = this._getTokenCount() - 1;\n\n\t\twhile (low < high) {\n\t\t\tconst mid = low + Math.floor((high - low) / 2);\n\t\t\tconst midDeltaLine = this._getDeltaLine(mid);\n\n\t\t\tif (midDeltaLine < deltaLine) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else if (midDeltaLine > deltaLine) {\n\t\t\t\thigh = mid - 1;\n\t\t\t} else {\n\t\t\t\tlet min = mid;\n\t\t\t\twhile (min > low && this._getDeltaLine(min - 1) === deltaLine) {\n\t\t\t\t\tmin--;\n\t\t\t\t}\n\t\t\t\tlet max = mid;\n\t\t\t\twhile (\n\t\t\t\t\tmax < high &&\n\t\t\t\t\tthis._getDeltaLine(max + 1) === deltaLine\n\t\t\t\t) {\n\t\t\t\t\tmax++;\n\t\t\t\t}\n\t\t\t\treturn new SparseLineTokens(\n\t\t\t\t\tthis._tokens.subarray(4 * min, 4 * max + 4),\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tif (this._getDeltaLine(low) === deltaLine) {\n\t\t\treturn new SparseLineTokens(\n\t\t\t\tthis._tokens.subarray(4 * low, 4 * low + 4),\n\t\t\t);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic clear(): void {\n\t\tthis._tokenCount = 0;\n\t}\n\n\tpublic removeTokens(\n\t\tstartDeltaLine: number,\n\t\tstartChar: number,\n\t\tendDeltaLine: number,\n\t\tendChar: number,\n\t): number {\n\t\tconst tokens = this._tokens;\n\t\tconst tokenCount = this._tokenCount;\n\t\tlet newTokenCount = 0;\n\t\tlet hasDeletedTokens = false;\n\t\tlet firstDeltaLine = 0;\n\t\tfor (let i = 0; i < tokenCount; i++) {\n\t\t\tconst srcOffset = 4 * i;\n\t\t\tconst tokenDeltaLine = tokens[srcOffset];\n\t\t\tconst tokenStartCharacter = tokens[srcOffset + 1];\n\t\t\tconst tokenEndCharacter = tokens[srcOffset + 2];\n\t\t\tconst tokenMetadata = tokens[srcOffset + 3];\n\n\t\t\tif (\n\t\t\t\t(tokenDeltaLine > startDeltaLine ||\n\t\t\t\t\t(tokenDeltaLine === startDeltaLine &&\n\t\t\t\t\t\ttokenEndCharacter >= startChar)) &&\n\t\t\t\t(tokenDeltaLine < endDeltaLine ||\n\t\t\t\t\t(tokenDeltaLine === endDeltaLine &&\n\t\t\t\t\t\ttokenStartCharacter <= endChar))\n\t\t\t) {\n\t\t\t\thasDeletedTokens = true;\n\t\t\t} else {\n\t\t\t\tif (newTokenCount === 0) {\n\t\t\t\t\tfirstDeltaLine = tokenDeltaLine;\n\t\t\t\t}\n\t\t\t\tif (hasDeletedTokens) {\n\t\t\t\t\t// must move the token to the left\n\t\t\t\t\tconst destOffset = 4 * newTokenCount;\n\t\t\t\t\ttokens[destOffset] = tokenDeltaLine - firstDeltaLine;\n\t\t\t\t\ttokens[destOffset + 1] = tokenStartCharacter;\n\t\t\t\t\ttokens[destOffset + 2] = tokenEndCharacter;\n\t\t\t\t\ttokens[destOffset + 3] = tokenMetadata;\n\t\t\t\t}\n\t\t\t\tnewTokenCount++;\n\t\t\t}\n\t\t}\n\n\t\tthis._tokenCount = newTokenCount;\n\n\t\treturn firstDeltaLine;\n\t}\n\n\tpublic split(\n\t\tstartDeltaLine: number,\n\t\tstartChar: number,\n\t\tendDeltaLine: number,\n\t\tendChar: number,\n\t): [SparseMultilineTokensStorage, SparseMultilineTokensStorage, number] {\n\t\tconst tokens = this._tokens;\n\t\tconst tokenCount = this._tokenCount;\n\t\tconst aTokens: number[] = [];\n\t\tconst bTokens: number[] = [];\n\t\tlet destTokens: number[] = aTokens;\n\t\tlet destOffset = 0;\n\t\tlet destFirstDeltaLine = 0;\n\t\tfor (let i = 0; i < tokenCount; i++) {\n\t\t\tconst srcOffset = 4 * i;\n\t\t\tconst tokenDeltaLine = tokens[srcOffset];\n\t\t\tconst tokenStartCharacter = tokens[srcOffset + 1];\n\t\t\tconst tokenEndCharacter = tokens[srcOffset + 2];\n\t\t\tconst tokenMetadata = tokens[srcOffset + 3];\n\n\t\t\tif (\n\t\t\t\ttokenDeltaLine > startDeltaLine ||\n\t\t\t\t(tokenDeltaLine === startDeltaLine &&\n\t\t\t\t\ttokenEndCharacter >= startChar)\n\t\t\t) {\n\t\t\t\tif (\n\t\t\t\t\ttokenDeltaLine < endDeltaLine ||\n\t\t\t\t\t(tokenDeltaLine === endDeltaLine &&\n\t\t\t\t\t\ttokenStartCharacter <= endChar)\n\t\t\t\t) {\n\t\t\t\t\t// this token is touching the range\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\t// this token is after the range\n\t\t\t\t\tif (destTokens !== bTokens) {\n\t\t\t\t\t\t// this token is the first token after the range\n\t\t\t\t\t\tdestTokens = bTokens;\n\t\t\t\t\t\tdestOffset = 0;\n\t\t\t\t\t\tdestFirstDeltaLine = tokenDeltaLine;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdestTokens[destOffset++] = tokenDeltaLine - destFirstDeltaLine;\n\t\t\tdestTokens[destOffset++] = tokenStartCharacter;\n\t\t\tdestTokens[destOffset++] = tokenEndCharacter;\n\t\t\tdestTokens[destOffset++] = tokenMetadata;\n\t\t}\n\n\t\treturn [\n\t\t\tnew SparseMultilineTokensStorage(new Uint32Array(aTokens)),\n\t\t\tnew SparseMultilineTokensStorage(new Uint32Array(bTokens)),\n\t\t\tdestFirstDeltaLine,\n\t\t];\n\t}\n\n\tpublic acceptDeleteRange(\n\t\thorizontalShiftForFirstLineTokens: number,\n\t\tstartDeltaLine: number,\n\t\tstartCharacter: number,\n\t\tendDeltaLine: number,\n\t\tendCharacter: number,\n\t): void {\n\t\t// This is a bit complex, here are the cases I used to think about this:\n\t\t//\n\t\t// 1. The token starts before the deletion range\n\t\t// 1a. The token is completely before the deletion range\n\t\t//               -----------\n\t\t//                          xxxxxxxxxxx\n\t\t// 1b. The token starts before, the deletion range ends after the token\n\t\t//               -----------\n\t\t//                      xxxxxxxxxxx\n\t\t// 1c. The token starts before, the deletion range ends precisely with the token\n\t\t//               ---------------\n\t\t//                      xxxxxxxx\n\t\t// 1d. The token starts before, the deletion range is inside the token\n\t\t//               ---------------\n\t\t//                    xxxxx\n\t\t//\n\t\t// 2. The token starts at the same position with the deletion range\n\t\t// 2a. The token starts at the same position, and ends inside the deletion range\n\t\t//               -------\n\t\t//               xxxxxxxxxxx\n\t\t// 2b. The token starts at the same position, and ends at the same position as the deletion range\n\t\t//               ----------\n\t\t//               xxxxxxxxxx\n\t\t// 2c. The token starts at the same position, and ends after the deletion range\n\t\t//               -------------\n\t\t//               xxxxxxx\n\t\t//\n\t\t// 3. The token starts inside the deletion range\n\t\t// 3a. The token is inside the deletion range\n\t\t//                -------\n\t\t//             xxxxxxxxxxxxx\n\t\t// 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n\t\t//                ----------\n\t\t//             xxxxxxxxxxxxx\n\t\t// 3c. The token starts inside the deletion range, and ends after the deletion range\n\t\t//                ------------\n\t\t//             xxxxxxxxxxx\n\t\t//\n\t\t// 4. The token starts after the deletion range\n\t\t//                  -----------\n\t\t//          xxxxxxxx\n\t\t//\n\t\tconst tokens = this._tokens;\n\t\tconst tokenCount = this._tokenCount;\n\t\tconst deletedLineCount = endDeltaLine - startDeltaLine;\n\t\tlet newTokenCount = 0;\n\t\tlet hasDeletedTokens = false;\n\t\tfor (let i = 0; i < tokenCount; i++) {\n\t\t\tconst srcOffset = 4 * i;\n\t\t\tlet tokenDeltaLine = tokens[srcOffset];\n\t\t\tlet tokenStartCharacter = tokens[srcOffset + 1];\n\t\t\tlet tokenEndCharacter = tokens[srcOffset + 2];\n\t\t\tconst tokenMetadata = tokens[srcOffset + 3];\n\n\t\t\tif (\n\t\t\t\ttokenDeltaLine < startDeltaLine ||\n\t\t\t\t(tokenDeltaLine === startDeltaLine &&\n\t\t\t\t\ttokenEndCharacter <= startCharacter)\n\t\t\t) {\n\t\t\t\t// 1a. The token is completely before the deletion range\n\t\t\t\t// => nothing to do\n\t\t\t\tnewTokenCount++;\n\t\t\t\tcontinue;\n\t\t\t} else if (\n\t\t\t\ttokenDeltaLine === startDeltaLine &&\n\t\t\t\ttokenStartCharacter < startCharacter\n\t\t\t) {\n\t\t\t\t// 1b, 1c, 1d\n\t\t\t\t// => the token survives, but it needs to shrink\n\t\t\t\tif (\n\t\t\t\t\ttokenDeltaLine === endDeltaLine &&\n\t\t\t\t\ttokenEndCharacter > endCharacter\n\t\t\t\t) {\n\t\t\t\t\t// 1d. The token starts before, the deletion range is inside the token\n\t\t\t\t\t// => the token shrinks by the deletion character count\n\t\t\t\t\ttokenEndCharacter -= endCharacter - startCharacter;\n\t\t\t\t} else {\n\t\t\t\t\t// 1b. The token starts before, the deletion range ends after the token\n\t\t\t\t\t// 1c. The token starts before, the deletion range ends precisely with the token\n\t\t\t\t\t// => the token shrinks its ending to the deletion start\n\t\t\t\t\ttokenEndCharacter = startCharacter;\n\t\t\t\t}\n\t\t\t} else if (\n\t\t\t\ttokenDeltaLine === startDeltaLine &&\n\t\t\t\ttokenStartCharacter === startCharacter\n\t\t\t) {\n\t\t\t\t// 2a, 2b, 2c\n\t\t\t\tif (\n\t\t\t\t\ttokenDeltaLine === endDeltaLine &&\n\t\t\t\t\ttokenEndCharacter > endCharacter\n\t\t\t\t) {\n\t\t\t\t\t// 2c. The token starts at the same position, and ends after the deletion range\n\t\t\t\t\t// => the token shrinks by the deletion character count\n\t\t\t\t\ttokenEndCharacter -= endCharacter - startCharacter;\n\t\t\t\t} else {\n\t\t\t\t\t// 2a. The token starts at the same position, and ends inside the deletion range\n\t\t\t\t\t// 2b. The token starts at the same position, and ends at the same position as the deletion range\n\t\t\t\t\t// => the token is deleted\n\t\t\t\t\thasDeletedTokens = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (\n\t\t\t\ttokenDeltaLine < endDeltaLine ||\n\t\t\t\t(tokenDeltaLine === endDeltaLine &&\n\t\t\t\t\ttokenStartCharacter < endCharacter)\n\t\t\t) {\n\t\t\t\t// 3a, 3b, 3c\n\t\t\t\tif (\n\t\t\t\t\ttokenDeltaLine === endDeltaLine &&\n\t\t\t\t\ttokenEndCharacter > endCharacter\n\t\t\t\t) {\n\t\t\t\t\t// 3c. The token starts inside the deletion range, and ends after the deletion range\n\t\t\t\t\t// => the token moves to continue right after the deletion\n\t\t\t\t\ttokenDeltaLine = startDeltaLine;\n\t\t\t\t\ttokenStartCharacter = startCharacter;\n\t\t\t\t\ttokenEndCharacter =\n\t\t\t\t\t\ttokenStartCharacter +\n\t\t\t\t\t\t(tokenEndCharacter - endCharacter);\n\t\t\t\t} else {\n\t\t\t\t\t// 3a. The token is inside the deletion range\n\t\t\t\t\t// 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n\t\t\t\t\t// => the token is deleted\n\t\t\t\t\thasDeletedTokens = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (tokenDeltaLine > endDeltaLine) {\n\t\t\t\t// 4. (partial) The token starts after the deletion range, on a line below...\n\t\t\t\tif (deletedLineCount === 0 && !hasDeletedTokens) {\n\t\t\t\t\t// early stop, there is no need to walk all the tokens and do nothing...\n\t\t\t\t\tnewTokenCount = tokenCount;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttokenDeltaLine -= deletedLineCount;\n\t\t\t} else if (\n\t\t\t\ttokenDeltaLine === endDeltaLine &&\n\t\t\t\ttokenStartCharacter >= endCharacter\n\t\t\t) {\n\t\t\t\t// 4. (continued) The token starts after the deletion range, on the last line where a deletion occurs\n\t\t\t\tif (horizontalShiftForFirstLineTokens && tokenDeltaLine === 0) {\n\t\t\t\t\ttokenStartCharacter += horizontalShiftForFirstLineTokens;\n\t\t\t\t\ttokenEndCharacter += horizontalShiftForFirstLineTokens;\n\t\t\t\t}\n\t\t\t\ttokenDeltaLine -= deletedLineCount;\n\t\t\t\ttokenStartCharacter -= endCharacter - startCharacter;\n\t\t\t\ttokenEndCharacter -= endCharacter - startCharacter;\n\t\t\t} else {\n\t\t\t\tthrow new Error(`Not possible!`);\n\t\t\t}\n\n\t\t\tconst destOffset = 4 * newTokenCount;\n\t\t\ttokens[destOffset] = tokenDeltaLine;\n\t\t\ttokens[destOffset + 1] = tokenStartCharacter;\n\t\t\ttokens[destOffset + 2] = tokenEndCharacter;\n\t\t\ttokens[destOffset + 3] = tokenMetadata;\n\t\t\tnewTokenCount++;\n\t\t}\n\n\t\tthis._tokenCount = newTokenCount;\n\t}\n\n\tpublic acceptInsertText(\n\t\tdeltaLine: number,\n\t\tcharacter: number,\n\t\teolCount: number,\n\t\tfirstLineLength: number,\n\t\tlastLineLength: number,\n\t\tfirstCharCode: number,\n\t): void {\n\t\t// Here are the cases I used to think about this:\n\t\t//\n\t\t// 1. The token is completely before the insertion point\n\t\t//            -----------   |\n\t\t// 2. The token ends precisely at the insertion point\n\t\t//            -----------|\n\t\t// 3. The token contains the insertion point\n\t\t//            -----|------\n\t\t// 4. The token starts precisely at the insertion point\n\t\t//            |-----------\n\t\t// 5. The token is completely after the insertion point\n\t\t//            |   -----------\n\t\t//\n\t\tconst isInsertingPreciselyOneWordCharacter =\n\t\t\teolCount === 0 &&\n\t\t\tfirstLineLength === 1 &&\n\t\t\t((firstCharCode >= CharCode.Digit0 &&\n\t\t\t\tfirstCharCode <= CharCode.Digit9) ||\n\t\t\t\t(firstCharCode >= CharCode.A && firstCharCode <= CharCode.Z) ||\n\t\t\t\t(firstCharCode >= CharCode.a && firstCharCode <= CharCode.z));\n\t\tconst tokens = this._tokens;\n\t\tconst tokenCount = this._tokenCount;\n\t\tfor (let i = 0; i < tokenCount; i++) {\n\t\t\tconst offset = 4 * i;\n\t\t\tlet tokenDeltaLine = tokens[offset];\n\t\t\tlet tokenStartCharacter = tokens[offset + 1];\n\t\t\tlet tokenEndCharacter = tokens[offset + 2];\n\n\t\t\tif (\n\t\t\t\ttokenDeltaLine < deltaLine ||\n\t\t\t\t(tokenDeltaLine === deltaLine && tokenEndCharacter < character)\n\t\t\t) {\n\t\t\t\t// 1. The token is completely before the insertion point\n\t\t\t\t// => nothing to do\n\t\t\t\tcontinue;\n\t\t\t} else if (\n\t\t\t\ttokenDeltaLine === deltaLine &&\n\t\t\t\ttokenEndCharacter === character\n\t\t\t) {\n\t\t\t\t// 2. The token ends precisely at the insertion point\n\t\t\t\t// => expand the end character only if inserting precisely one character that is a word character\n\t\t\t\tif (isInsertingPreciselyOneWordCharacter) {\n\t\t\t\t\ttokenEndCharacter += 1;\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (\n\t\t\t\ttokenDeltaLine === deltaLine &&\n\t\t\t\ttokenStartCharacter < character &&\n\t\t\t\tcharacter < tokenEndCharacter\n\t\t\t) {\n\t\t\t\t// 3. The token contains the insertion point\n\t\t\t\tif (eolCount === 0) {\n\t\t\t\t\t// => just expand the end character\n\t\t\t\t\ttokenEndCharacter += firstLineLength;\n\t\t\t\t} else {\n\t\t\t\t\t// => cut off the token\n\t\t\t\t\ttokenEndCharacter = character;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// 4. or 5.\n\t\t\t\tif (\n\t\t\t\t\ttokenDeltaLine === deltaLine &&\n\t\t\t\t\ttokenStartCharacter === character\n\t\t\t\t) {\n\t\t\t\t\t// 4. The token starts precisely at the insertion point\n\t\t\t\t\t// => grow the token (by keeping its start constant) only if inserting precisely one character that is a word character\n\t\t\t\t\t// => otherwise behave as in case 5.\n\t\t\t\t\tif (isInsertingPreciselyOneWordCharacter) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// => the token must move and keep its size constant\n\t\t\t\tif (tokenDeltaLine === deltaLine) {\n\t\t\t\t\ttokenDeltaLine += eolCount;\n\t\t\t\t\t// this token is on the line where the insertion is taking place\n\t\t\t\t\tif (eolCount === 0) {\n\t\t\t\t\t\ttokenStartCharacter += firstLineLength;\n\t\t\t\t\t\ttokenEndCharacter += firstLineLength;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst tokenLength =\n\t\t\t\t\t\t\ttokenEndCharacter - tokenStartCharacter;\n\t\t\t\t\t\ttokenStartCharacter =\n\t\t\t\t\t\t\tlastLineLength + (tokenStartCharacter - character);\n\t\t\t\t\t\ttokenEndCharacter = tokenStartCharacter + tokenLength;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttokenDeltaLine += eolCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttokens[offset] = tokenDeltaLine;\n\t\t\ttokens[offset + 1] = tokenStartCharacter;\n\t\t\ttokens[offset + 2] = tokenEndCharacter;\n\t\t}\n\t}\n}\n\nexport class SparseLineTokens {\n\tprivate readonly _tokens: Uint32Array;\n\n\tconstructor(tokens: Uint32Array) {\n\t\tthis._tokens = tokens;\n\t}\n\n\tpublic getCount(): number {\n\t\treturn this._tokens.length / 4;\n\t}\n\n\tpublic getStartCharacter(tokenIndex: number): number {\n\t\treturn this._tokens[4 * tokenIndex + 1];\n\t}\n\n\tpublic getEndCharacter(tokenIndex: number): number {\n\t\treturn this._tokens[4 * tokenIndex + 2];\n\t}\n\n\tpublic getMetadata(tokenIndex: number): number {\n\t\treturn this._tokens[4 * tokenIndex + 3];\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
