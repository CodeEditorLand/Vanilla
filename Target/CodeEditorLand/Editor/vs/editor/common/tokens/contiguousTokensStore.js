import*as k from"../../../base/common/arrays.js";import{Position as L}from"../core/position.js";import{ColorId as _,FontStyle as p,MetadataConsts as a,StandardTokenType as y,TokenMetadata as I}from"../encodedTokenAttributes.js";import{ContiguousTokensEditing as u,EMPTY_LINE_TOKENS as d,toUint32Array as f}from"./contiguousTokensEditing.js";import{LineTokens as T}from"./lineTokens.js";class g{_lineTokens;_len;_languageIdCodec;constructor(e){this._lineTokens=[],this._len=0,this._languageIdCodec=e}flush(){this._lineTokens=[],this._len=0}get hasTokens(){return this._lineTokens.length>0}getTokens(e,n,i){let t=null;if(n<this._len&&(t=this._lineTokens[n]),t!==null&&t!==d)return new T(f(t),i,this._languageIdCodec);const r=new Uint32Array(2);return r[0]=i.length,r[1]=c(this._languageIdCodec.encodeLanguageId(e)),new T(r,i,this._languageIdCodec)}static _massageTokens(e,n,i){const t=i?f(i):null;if(n===0){let r=!1;if(t&&t.length>1&&(r=I.getLanguageId(t[1])!==e),!r)return d}if(!t||t.length===0){const r=new Uint32Array(2);return r[0]=n,r[1]=c(e),r.buffer}return t[t.length-2]=n,t.byteOffset===0&&t.byteLength===t.buffer.byteLength?t.buffer:t}_ensureLine(e){for(;e>=this._len;)this._lineTokens[this._len]=null,this._len++}_deleteLines(e,n){n!==0&&(e+n>this._len&&(n=this._len-e),this._lineTokens.splice(e,n),this._len-=n)}_insertLines(e,n){if(n===0)return;const i=[];for(let t=0;t<n;t++)i[t]=null;this._lineTokens=k.arrayInsert(this._lineTokens,e,i),this._len+=n}setTokens(e,n,i,t,r){const l=g._massageTokens(this._languageIdCodec.encodeLanguageId(e),i,t);this._ensureLine(n);const o=this._lineTokens[n];return this._lineTokens[n]=l,r?!g._equals(o,l):!1}static _equals(e,n){if(!e||!n)return!e&&!n;const i=f(e),t=f(n);if(i.length!==t.length)return!1;for(let r=0,l=i.length;r<l;r++)if(i[r]!==t[r])return!1;return!0}acceptEdit(e,n,i){this._acceptDeleteRange(e),this._acceptInsertText(new L(e.startLineNumber,e.startColumn),n,i)}_acceptDeleteRange(e){const n=e.startLineNumber-1;if(n>=this._len)return;if(e.startLineNumber===e.endLineNumber){if(e.startColumn===e.endColumn)return;this._lineTokens[n]=u.delete(this._lineTokens[n],e.startColumn-1,e.endColumn-1);return}this._lineTokens[n]=u.deleteEnding(this._lineTokens[n],e.startColumn-1);const i=e.endLineNumber-1;let t=null;i<this._len&&(t=u.deleteBeginning(this._lineTokens[i],e.endColumn-1)),this._lineTokens[n]=u.append(this._lineTokens[n],t),this._deleteLines(e.startLineNumber,e.endLineNumber-e.startLineNumber)}_acceptInsertText(e,n,i){if(n===0&&i===0)return;const t=e.lineNumber-1;if(!(t>=this._len)){if(n===0){this._lineTokens[t]=u.insert(this._lineTokens[t],e.column-1,i);return}this._lineTokens[t]=u.deleteEnding(this._lineTokens[t],e.column-1),this._lineTokens[t]=u.insert(this._lineTokens[t],e.column-1,i),this._insertLines(e.lineNumber,n)}}setMultilineTokens(e,n){if(e.length===0)return{changes:[]};const i=[];for(let t=0,r=e.length;t<r;t++){const l=e[t];let o=0,m=0,h=!1;for(let s=l.startLineNumber;s<=l.endLineNumber;s++)h?(this.setTokens(n.getLanguageId(),s-1,n.getLineLength(s),l.getLineTokens(s),!1),m=s):this.setTokens(n.getLanguageId(),s-1,n.getLineLength(s),l.getLineTokens(s),!0)&&(h=!0,o=s,m=s);h&&i.push({fromLineNumber:o,toLineNumber:m})}return{changes:i}}}function c(b){return(b<<a.LANGUAGEID_OFFSET|y.Other<<a.TOKEN_TYPE_OFFSET|p.None<<a.FONT_STYLE_OFFSET|_.DefaultForeground<<a.FOREGROUND_OFFSET|_.DefaultBackground<<a.BACKGROUND_OFFSET|a.BALANCED_BRACKETS_MASK)>>>0}export{g as ContiguousTokensStore};
