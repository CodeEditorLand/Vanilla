{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/tokens/sparseTokensStore.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from '../../../base/common/arrays.js';\nimport { IRange, Range } from '../core/range.js';\nimport { LineTokens } from './lineTokens.js';\nimport { SparseMultilineTokens } from './sparseMultilineTokens.js';\nimport { ILanguageIdCodec } from '../languages.js';\nimport { MetadataConsts } from '../encodedTokenAttributes.js';\n\n/**\n * Represents sparse tokens in a text model.\n */\nexport class SparseTokensStore {\n\n\tprivate _pieces: SparseMultilineTokens[];\n\tprivate _isComplete: boolean;\n\tprivate readonly _languageIdCodec: ILanguageIdCodec;\n\n\tconstructor(languageIdCodec: ILanguageIdCodec) {\n\t\tthis._pieces = [];\n\t\tthis._isComplete = false;\n\t\tthis._languageIdCodec = languageIdCodec;\n\t}\n\n\tpublic flush(): void {\n\t\tthis._pieces = [];\n\t\tthis._isComplete = false;\n\t}\n\n\tpublic isEmpty(): boolean {\n\t\treturn (this._pieces.length === 0);\n\t}\n\n\tpublic set(pieces: SparseMultilineTokens[] | null, isComplete: boolean): void {\n\t\tthis._pieces = pieces || [];\n\t\tthis._isComplete = isComplete;\n\t}\n\n\tpublic setPartial(_range: Range, pieces: SparseMultilineTokens[]): Range {\n\t\t// console.log(`setPartial ${_range} ${pieces.map(p => p.toString()).join(', ')}`);\n\n\t\tlet range = _range;\n\t\tif (pieces.length > 0) {\n\t\t\tconst _firstRange = pieces[0].getRange();\n\t\t\tconst _lastRange = pieces[pieces.length - 1].getRange();\n\t\t\tif (!_firstRange || !_lastRange) {\n\t\t\t\treturn _range;\n\t\t\t}\n\t\t\trange = _range.plusRange(_firstRange).plusRange(_lastRange);\n\t\t}\n\n\t\tlet insertPosition: { index: number } | null = null;\n\t\tfor (let i = 0, len = this._pieces.length; i < len; i++) {\n\t\t\tconst piece = this._pieces[i];\n\t\t\tif (piece.endLineNumber < range.startLineNumber) {\n\t\t\t\t// this piece is before the range\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (piece.startLineNumber > range.endLineNumber) {\n\t\t\t\t// this piece is after the range, so mark the spot before this piece\n\t\t\t\t// as a good insertion position and stop looping\n\t\t\t\tinsertPosition = insertPosition || { index: i };\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// this piece might intersect with the range\n\t\t\tpiece.removeTokens(range);\n\n\t\t\tif (piece.isEmpty()) {\n\t\t\t\t// remove the piece if it became empty\n\t\t\t\tthis._pieces.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t\tlen--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (piece.endLineNumber < range.startLineNumber) {\n\t\t\t\t// after removal, this piece is before the range\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (piece.startLineNumber > range.endLineNumber) {\n\t\t\t\t// after removal, this piece is after the range\n\t\t\t\tinsertPosition = insertPosition || { index: i };\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// after removal, this piece contains the range\n\t\t\tconst [a, b] = piece.split(range);\n\t\t\tif (a.isEmpty()) {\n\t\t\t\t// this piece is actually after the range\n\t\t\t\tinsertPosition = insertPosition || { index: i };\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (b.isEmpty()) {\n\t\t\t\t// this piece is actually before the range\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis._pieces.splice(i, 1, a, b);\n\t\t\ti++;\n\t\t\tlen++;\n\n\t\t\tinsertPosition = insertPosition || { index: i };\n\t\t}\n\n\t\tinsertPosition = insertPosition || { index: this._pieces.length };\n\n\t\tif (pieces.length > 0) {\n\t\t\tthis._pieces = arrays.arrayInsert(this._pieces, insertPosition.index, pieces);\n\t\t}\n\n\t\t// console.log(`I HAVE ${this._pieces.length} pieces`);\n\t\t// console.log(`${this._pieces.map(p => p.toString()).join('\\n')}`);\n\n\t\treturn range;\n\t}\n\n\tpublic isComplete(): boolean {\n\t\treturn this._isComplete;\n\t}\n\n\tpublic addSparseTokens(lineNumber: number, aTokens: LineTokens): LineTokens {\n\t\tif (aTokens.getLineContent().length === 0) {\n\t\t\t// Don't do anything for empty lines\n\t\t\treturn aTokens;\n\t\t}\n\n\t\tconst pieces = this._pieces;\n\n\t\tif (pieces.length === 0) {\n\t\t\treturn aTokens;\n\t\t}\n\n\t\tconst pieceIndex = SparseTokensStore._findFirstPieceWithLine(pieces, lineNumber);\n\t\tconst bTokens = pieces[pieceIndex].getLineTokens(lineNumber);\n\n\t\tif (!bTokens) {\n\t\t\treturn aTokens;\n\t\t}\n\n\t\tconst aLen = aTokens.getCount();\n\t\tconst bLen = bTokens.getCount();\n\n\t\tlet aIndex = 0;\n\t\tconst result: number[] = [];\n\t\tlet resultLen = 0;\n\t\tlet lastEndOffset = 0;\n\n\t\tconst emitToken = (endOffset: number, metadata: number) => {\n\t\t\tif (endOffset === lastEndOffset) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlastEndOffset = endOffset;\n\t\t\tresult[resultLen++] = endOffset;\n\t\t\tresult[resultLen++] = metadata;\n\t\t};\n\n\t\tfor (let bIndex = 0; bIndex < bLen; bIndex++) {\n\t\t\tconst bStartCharacter = bTokens.getStartCharacter(bIndex);\n\t\t\tconst bEndCharacter = bTokens.getEndCharacter(bIndex);\n\t\t\tconst bMetadata = bTokens.getMetadata(bIndex);\n\n\t\t\tconst bMask = (\n\t\t\t\t((bMetadata & MetadataConsts.SEMANTIC_USE_ITALIC) ? MetadataConsts.ITALIC_MASK : 0)\n\t\t\t\t| ((bMetadata & MetadataConsts.SEMANTIC_USE_BOLD) ? MetadataConsts.BOLD_MASK : 0)\n\t\t\t\t| ((bMetadata & MetadataConsts.SEMANTIC_USE_UNDERLINE) ? MetadataConsts.UNDERLINE_MASK : 0)\n\t\t\t\t| ((bMetadata & MetadataConsts.SEMANTIC_USE_STRIKETHROUGH) ? MetadataConsts.STRIKETHROUGH_MASK : 0)\n\t\t\t\t| ((bMetadata & MetadataConsts.SEMANTIC_USE_FOREGROUND) ? MetadataConsts.FOREGROUND_MASK : 0)\n\t\t\t\t| ((bMetadata & MetadataConsts.SEMANTIC_USE_BACKGROUND) ? MetadataConsts.BACKGROUND_MASK : 0)\n\t\t\t) >>> 0;\n\t\t\tconst aMask = (~bMask) >>> 0;\n\n\t\t\t// push any token from `a` that is before `b`\n\t\t\twhile (aIndex < aLen && aTokens.getEndOffset(aIndex) <= bStartCharacter) {\n\t\t\t\temitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n\t\t\t\taIndex++;\n\t\t\t}\n\n\t\t\t// push the token from `a` if it intersects the token from `b`\n\t\t\tif (aIndex < aLen && aTokens.getStartOffset(aIndex) < bStartCharacter) {\n\t\t\t\temitToken(bStartCharacter, aTokens.getMetadata(aIndex));\n\t\t\t}\n\n\t\t\t// skip any tokens from `a` that are contained inside `b`\n\t\t\twhile (aIndex < aLen && aTokens.getEndOffset(aIndex) < bEndCharacter) {\n\t\t\t\temitToken(aTokens.getEndOffset(aIndex), (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n\t\t\t\taIndex++;\n\t\t\t}\n\n\t\t\tif (aIndex < aLen) {\n\t\t\t\temitToken(bEndCharacter, (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n\t\t\t\tif (aTokens.getEndOffset(aIndex) === bEndCharacter) {\n\t\t\t\t\t// `a` ends exactly at the same spot as `b`!\n\t\t\t\t\taIndex++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst aMergeIndex = Math.min(Math.max(0, aIndex - 1), aLen - 1);\n\n\t\t\t\t// push the token from `b`\n\t\t\t\temitToken(bEndCharacter, (aTokens.getMetadata(aMergeIndex) & aMask) | (bMetadata & bMask));\n\t\t\t}\n\t\t}\n\n\t\t// push the remaining tokens from `a`\n\t\twhile (aIndex < aLen) {\n\t\t\temitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n\t\t\taIndex++;\n\t\t}\n\n\t\treturn new LineTokens(new Uint32Array(result), aTokens.getLineContent(), this._languageIdCodec);\n\t}\n\n\tprivate static _findFirstPieceWithLine(pieces: SparseMultilineTokens[], lineNumber: number): number {\n\t\tlet low = 0;\n\t\tlet high = pieces.length - 1;\n\n\t\twhile (low < high) {\n\t\t\tlet mid = low + Math.floor((high - low) / 2);\n\n\t\t\tif (pieces[mid].endLineNumber < lineNumber) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else if (pieces[mid].startLineNumber > lineNumber) {\n\t\t\t\thigh = mid - 1;\n\t\t\t} else {\n\t\t\t\twhile (mid > low && pieces[mid - 1].startLineNumber <= lineNumber && lineNumber <= pieces[mid - 1].endLineNumber) {\n\t\t\t\t\tmid--;\n\t\t\t\t}\n\t\t\t\treturn mid;\n\t\t\t}\n\t\t}\n\n\t\treturn low;\n\t}\n\n\tpublic acceptEdit(range: IRange, eolCount: number, firstLineLength: number, lastLineLength: number, firstCharCode: number): void {\n\t\tfor (const piece of this._pieces) {\n\t\t\tpiece.acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode);\n\t\t}\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
