{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/tokens/sparseTokensStore.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from \"../../../base/common/arrays.js\";\nimport type { IRange, Range } from \"../core/range.js\";\nimport { MetadataConsts } from \"../encodedTokenAttributes.js\";\nimport type { ILanguageIdCodec } from \"../languages.js\";\nimport { LineTokens } from \"./lineTokens.js\";\nimport type { SparseMultilineTokens } from \"./sparseMultilineTokens.js\";\n\n/**\n * Represents sparse tokens in a text model.\n */\nexport class SparseTokensStore {\n\tprivate _pieces: SparseMultilineTokens[];\n\tprivate _isComplete: boolean;\n\tprivate readonly _languageIdCodec: ILanguageIdCodec;\n\n\tconstructor(languageIdCodec: ILanguageIdCodec) {\n\t\tthis._pieces = [];\n\t\tthis._isComplete = false;\n\t\tthis._languageIdCodec = languageIdCodec;\n\t}\n\n\tpublic flush(): void {\n\t\tthis._pieces = [];\n\t\tthis._isComplete = false;\n\t}\n\n\tpublic isEmpty(): boolean {\n\t\treturn this._pieces.length === 0;\n\t}\n\n\tpublic set(\n\t\tpieces: SparseMultilineTokens[] | null,\n\t\tisComplete: boolean,\n\t): void {\n\t\tthis._pieces = pieces || [];\n\t\tthis._isComplete = isComplete;\n\t}\n\n\tpublic setPartial(_range: Range, pieces: SparseMultilineTokens[]): Range {\n\t\t// console.log(`setPartial ${_range} ${pieces.map(p => p.toString()).join(', ')}`);\n\n\t\tlet range = _range;\n\t\tif (pieces.length > 0) {\n\t\t\tconst _firstRange = pieces[0].getRange();\n\t\t\tconst _lastRange = pieces[pieces.length - 1].getRange();\n\t\t\tif (!_firstRange || !_lastRange) {\n\t\t\t\treturn _range;\n\t\t\t}\n\t\t\trange = _range.plusRange(_firstRange).plusRange(_lastRange);\n\t\t}\n\n\t\tlet insertPosition: { index: number } | null = null;\n\t\tfor (let i = 0, len = this._pieces.length; i < len; i++) {\n\t\t\tconst piece = this._pieces[i];\n\t\t\tif (piece.endLineNumber < range.startLineNumber) {\n\t\t\t\t// this piece is before the range\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (piece.startLineNumber > range.endLineNumber) {\n\t\t\t\t// this piece is after the range, so mark the spot before this piece\n\t\t\t\t// as a good insertion position and stop looping\n\t\t\t\tinsertPosition = insertPosition || { index: i };\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// this piece might intersect with the range\n\t\t\tpiece.removeTokens(range);\n\n\t\t\tif (piece.isEmpty()) {\n\t\t\t\t// remove the piece if it became empty\n\t\t\t\tthis._pieces.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t\tlen--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (piece.endLineNumber < range.startLineNumber) {\n\t\t\t\t// after removal, this piece is before the range\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (piece.startLineNumber > range.endLineNumber) {\n\t\t\t\t// after removal, this piece is after the range\n\t\t\t\tinsertPosition = insertPosition || { index: i };\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// after removal, this piece contains the range\n\t\t\tconst [a, b] = piece.split(range);\n\t\t\tif (a.isEmpty()) {\n\t\t\t\t// this piece is actually after the range\n\t\t\t\tinsertPosition = insertPosition || { index: i };\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (b.isEmpty()) {\n\t\t\t\t// this piece is actually before the range\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis._pieces.splice(i, 1, a, b);\n\t\t\ti++;\n\t\t\tlen++;\n\n\t\t\tinsertPosition = insertPosition || { index: i };\n\t\t}\n\n\t\tinsertPosition = insertPosition || { index: this._pieces.length };\n\n\t\tif (pieces.length > 0) {\n\t\t\tthis._pieces = arrays.arrayInsert(\n\t\t\t\tthis._pieces,\n\t\t\t\tinsertPosition.index,\n\t\t\t\tpieces,\n\t\t\t);\n\t\t}\n\n\t\t// console.log(`I HAVE ${this._pieces.length} pieces`);\n\t\t// console.log(`${this._pieces.map(p => p.toString()).join('\\n')}`);\n\n\t\treturn range;\n\t}\n\n\tpublic isComplete(): boolean {\n\t\treturn this._isComplete;\n\t}\n\n\tpublic addSparseTokens(\n\t\tlineNumber: number,\n\t\taTokens: LineTokens,\n\t): LineTokens {\n\t\tif (aTokens.getLineContent().length === 0) {\n\t\t\t// Don't do anything for empty lines\n\t\t\treturn aTokens;\n\t\t}\n\n\t\tconst pieces = this._pieces;\n\n\t\tif (pieces.length === 0) {\n\t\t\treturn aTokens;\n\t\t}\n\n\t\tconst pieceIndex = SparseTokensStore._findFirstPieceWithLine(\n\t\t\tpieces,\n\t\t\tlineNumber,\n\t\t);\n\t\tconst bTokens = pieces[pieceIndex].getLineTokens(lineNumber);\n\n\t\tif (!bTokens) {\n\t\t\treturn aTokens;\n\t\t}\n\n\t\tconst aLen = aTokens.getCount();\n\t\tconst bLen = bTokens.getCount();\n\n\t\tlet aIndex = 0;\n\t\tconst result: number[] = [];\n\t\tlet resultLen = 0;\n\t\tlet lastEndOffset = 0;\n\n\t\tconst emitToken = (endOffset: number, metadata: number) => {\n\t\t\tif (endOffset === lastEndOffset) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlastEndOffset = endOffset;\n\t\t\tresult[resultLen++] = endOffset;\n\t\t\tresult[resultLen++] = metadata;\n\t\t};\n\n\t\tfor (let bIndex = 0; bIndex < bLen; bIndex++) {\n\t\t\tconst bStartCharacter = bTokens.getStartCharacter(bIndex);\n\t\t\tconst bEndCharacter = bTokens.getEndCharacter(bIndex);\n\t\t\tconst bMetadata = bTokens.getMetadata(bIndex);\n\n\t\t\tconst bMask =\n\t\t\t\t((bMetadata & MetadataConsts.SEMANTIC_USE_ITALIC\n\t\t\t\t\t? MetadataConsts.ITALIC_MASK\n\t\t\t\t\t: 0) |\n\t\t\t\t\t(bMetadata & MetadataConsts.SEMANTIC_USE_BOLD\n\t\t\t\t\t\t? MetadataConsts.BOLD_MASK\n\t\t\t\t\t\t: 0) |\n\t\t\t\t\t(bMetadata & MetadataConsts.SEMANTIC_USE_UNDERLINE\n\t\t\t\t\t\t? MetadataConsts.UNDERLINE_MASK\n\t\t\t\t\t\t: 0) |\n\t\t\t\t\t(bMetadata & MetadataConsts.SEMANTIC_USE_STRIKETHROUGH\n\t\t\t\t\t\t? MetadataConsts.STRIKETHROUGH_MASK\n\t\t\t\t\t\t: 0) |\n\t\t\t\t\t(bMetadata & MetadataConsts.SEMANTIC_USE_FOREGROUND\n\t\t\t\t\t\t? MetadataConsts.FOREGROUND_MASK\n\t\t\t\t\t\t: 0) |\n\t\t\t\t\t(bMetadata & MetadataConsts.SEMANTIC_USE_BACKGROUND\n\t\t\t\t\t\t? MetadataConsts.BACKGROUND_MASK\n\t\t\t\t\t\t: 0)) >>>\n\t\t\t\t0;\n\t\t\tconst aMask = ~bMask >>> 0;\n\n\t\t\t// push any token from `a` that is before `b`\n\t\t\twhile (\n\t\t\t\taIndex < aLen &&\n\t\t\t\taTokens.getEndOffset(aIndex) <= bStartCharacter\n\t\t\t) {\n\t\t\t\temitToken(\n\t\t\t\t\taTokens.getEndOffset(aIndex),\n\t\t\t\t\taTokens.getMetadata(aIndex),\n\t\t\t\t);\n\t\t\t\taIndex++;\n\t\t\t}\n\n\t\t\t// push the token from `a` if it intersects the token from `b`\n\t\t\tif (\n\t\t\t\taIndex < aLen &&\n\t\t\t\taTokens.getStartOffset(aIndex) < bStartCharacter\n\t\t\t) {\n\t\t\t\temitToken(bStartCharacter, aTokens.getMetadata(aIndex));\n\t\t\t}\n\n\t\t\t// skip any tokens from `a` that are contained inside `b`\n\t\t\twhile (\n\t\t\t\taIndex < aLen &&\n\t\t\t\taTokens.getEndOffset(aIndex) < bEndCharacter\n\t\t\t) {\n\t\t\t\temitToken(\n\t\t\t\t\taTokens.getEndOffset(aIndex),\n\t\t\t\t\t(aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask),\n\t\t\t\t);\n\t\t\t\taIndex++;\n\t\t\t}\n\n\t\t\tif (aIndex < aLen) {\n\t\t\t\temitToken(\n\t\t\t\t\tbEndCharacter,\n\t\t\t\t\t(aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask),\n\t\t\t\t);\n\t\t\t\tif (aTokens.getEndOffset(aIndex) === bEndCharacter) {\n\t\t\t\t\t// `a` ends exactly at the same spot as `b`!\n\t\t\t\t\taIndex++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst aMergeIndex = Math.min(Math.max(0, aIndex - 1), aLen - 1);\n\n\t\t\t\t// push the token from `b`\n\t\t\t\temitToken(\n\t\t\t\t\tbEndCharacter,\n\t\t\t\t\t(aTokens.getMetadata(aMergeIndex) & aMask) |\n\t\t\t\t\t\t(bMetadata & bMask),\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// push the remaining tokens from `a`\n\t\twhile (aIndex < aLen) {\n\t\t\temitToken(\n\t\t\t\taTokens.getEndOffset(aIndex),\n\t\t\t\taTokens.getMetadata(aIndex),\n\t\t\t);\n\t\t\taIndex++;\n\t\t}\n\n\t\treturn new LineTokens(\n\t\t\tnew Uint32Array(result),\n\t\t\taTokens.getLineContent(),\n\t\t\tthis._languageIdCodec,\n\t\t);\n\t}\n\n\tprivate static _findFirstPieceWithLine(\n\t\tpieces: SparseMultilineTokens[],\n\t\tlineNumber: number,\n\t): number {\n\t\tlet low = 0;\n\t\tlet high = pieces.length - 1;\n\n\t\twhile (low < high) {\n\t\t\tlet mid = low + Math.floor((high - low) / 2);\n\n\t\t\tif (pieces[mid].endLineNumber < lineNumber) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else if (pieces[mid].startLineNumber > lineNumber) {\n\t\t\t\thigh = mid - 1;\n\t\t\t} else {\n\t\t\t\twhile (\n\t\t\t\t\tmid > low &&\n\t\t\t\t\tpieces[mid - 1].startLineNumber <= lineNumber &&\n\t\t\t\t\tlineNumber <= pieces[mid - 1].endLineNumber\n\t\t\t\t) {\n\t\t\t\t\tmid--;\n\t\t\t\t}\n\t\t\t\treturn mid;\n\t\t\t}\n\t\t}\n\n\t\treturn low;\n\t}\n\n\tpublic acceptEdit(\n\t\trange: IRange,\n\t\teolCount: number,\n\t\tfirstLineLength: number,\n\t\tlastLineLength: number,\n\t\tfirstCharCode: number,\n\t): void {\n\t\tfor (const piece of this._pieces) {\n\t\t\tpiece.acceptEdit(\n\t\t\t\trange,\n\t\t\t\teolCount,\n\t\t\t\tfirstLineLength,\n\t\t\t\tlastLineLength,\n\t\t\t\tfirstCharCode,\n\t\t\t);\n\t\t}\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
