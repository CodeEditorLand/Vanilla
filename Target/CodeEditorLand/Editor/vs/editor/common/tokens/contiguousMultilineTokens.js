import*as b from"../../../base/common/arrays.js";import{readUInt32BE as s,writeUInt32BE as u}from"../../../base/common/buffer.js";import{Position as k}from"../core/position.js";import"../core/range.js";import{countEOL as c}from"../core/eolCounter.js";import{ContiguousTokensEditing as i}from"./contiguousTokensEditing.js";import{LineRange as p}from"../core/lineRange.js";class m{static deserialize(e,t,n){const r=new Uint32Array(e.buffer),a=s(e,t);t+=4;const _=s(e,t);t+=4;const o=[];for(let h=0;h<_;h++){const l=s(e,t);t+=4,o.push(r.subarray(t/4,t/4+l/4)),t+=l}return n.push(new m(a,o)),t}_startLineNumber;_tokens;get startLineNumber(){return this._startLineNumber}get endLineNumber(){return this._startLineNumber+this._tokens.length-1}constructor(e,t){this._startLineNumber=e,this._tokens=t}getLineRange(){return new p(this._startLineNumber,this._startLineNumber+this._tokens.length)}getLineTokens(e){return this._tokens[e-this._startLineNumber]}appendLineTokens(e){this._tokens.push(e)}serializeSize(){let e=0;e+=4,e+=4;for(let t=0;t<this._tokens.length;t++){const n=this._tokens[t];if(!(n instanceof Uint32Array))throw new Error("Not supported!");e+=4,e+=n.byteLength}return e}serialize(e,t){u(e,this._startLineNumber,t),t+=4,u(e,this._tokens.length,t),t+=4;for(let n=0;n<this._tokens.length;n++){const r=this._tokens[n];if(!(r instanceof Uint32Array))throw new Error("Not supported!");u(e,r.byteLength,t),t+=4,e.set(new Uint8Array(r.buffer),t),t+=r.byteLength}return t}applyEdit(e,t){const[n,r]=c(t);this._acceptDeleteRange(e),this._acceptInsertText(new k(e.startLineNumber,e.startColumn),n,r)}_acceptDeleteRange(e){if(e.startLineNumber===e.endLineNumber&&e.startColumn===e.endColumn)return;const t=e.startLineNumber-this._startLineNumber,n=e.endLineNumber-this._startLineNumber;if(n<0){const r=n-t;this._startLineNumber-=r;return}if(!(t>=this._tokens.length)){if(t<0&&n>=this._tokens.length){this._startLineNumber=0,this._tokens=[];return}if(t===n){this._tokens[t]=i.delete(this._tokens[t],e.startColumn-1,e.endColumn-1);return}if(t>=0)if(this._tokens[t]=i.deleteEnding(this._tokens[t],e.startColumn-1),n<this._tokens.length){const r=i.deleteBeginning(this._tokens[n],e.endColumn-1);this._tokens[t]=i.append(this._tokens[t],r),this._tokens.splice(t+1,n-t)}else this._tokens[t]=i.append(this._tokens[t],null),this._tokens=this._tokens.slice(0,t+1);else{const r=-t;this._startLineNumber-=r,this._tokens[n]=i.deleteBeginning(this._tokens[n],e.endColumn-1),this._tokens=this._tokens.slice(n)}}}_acceptInsertText(e,t,n){if(t===0&&n===0)return;const r=e.lineNumber-this._startLineNumber;if(r<0){this._startLineNumber+=t;return}if(!(r>=this._tokens.length)){if(t===0){this._tokens[r]=i.insert(this._tokens[r],e.column-1,n);return}this._tokens[r]=i.deleteEnding(this._tokens[r],e.column-1),this._tokens[r]=i.insert(this._tokens[r],e.column-1,n),this._insertLines(e.lineNumber,t)}}_insertLines(e,t){if(t===0)return;const n=[];for(let r=0;r<t;r++)n[r]=null;this._tokens=b.arrayInsert(this._tokens,e,n)}}export{m as ContiguousMultilineTokens};
