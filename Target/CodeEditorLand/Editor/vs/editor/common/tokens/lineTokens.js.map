{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/tokens/lineTokens.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ILanguageIdCodec } from '../languages.js';\nimport { FontStyle, ColorId, StandardTokenType, MetadataConsts, TokenMetadata, ITokenPresentation } from '../encodedTokenAttributes.js';\nimport { IPosition } from '../core/position.js';\nimport { ITextModel } from '../model.js';\nimport { OffsetRange } from '../core/offsetRange.js';\nimport { TokenArray, TokenArrayBuilder } from './tokenArray.js';\n\n\nexport interface IViewLineTokens {\n\tlanguageIdCodec: ILanguageIdCodec;\n\tequals(other: IViewLineTokens): boolean;\n\tgetCount(): number;\n\tgetStandardTokenType(tokenIndex: number): StandardTokenType;\n\tgetForeground(tokenIndex: number): ColorId;\n\tgetEndOffset(tokenIndex: number): number;\n\tgetClassName(tokenIndex: number): string;\n\tgetInlineStyle(tokenIndex: number, colorMap: string[]): string;\n\tgetPresentation(tokenIndex: number): ITokenPresentation;\n\tfindTokenIndexAtOffset(offset: number): number;\n\tgetLineContent(): string;\n\tgetMetadata(tokenIndex: number): number;\n\tgetLanguageId(tokenIndex: number): string;\n\tgetTokenText(tokenIndex: number): string;\n\tforEach(callback: (tokenIndex: number) => void): void;\n}\n\nexport class LineTokens implements IViewLineTokens {\n\tpublic static createEmpty(lineContent: string, decoder: ILanguageIdCodec): LineTokens {\n\t\tconst defaultMetadata = LineTokens.defaultTokenMetadata;\n\n\t\tconst tokens = new Uint32Array(2);\n\t\ttokens[0] = lineContent.length;\n\t\ttokens[1] = defaultMetadata;\n\n\t\treturn new LineTokens(tokens, lineContent, decoder);\n\t}\n\n\tpublic static createFromTextAndMetadata(data: { text: string; metadata: number }[], decoder: ILanguageIdCodec): LineTokens {\n\t\tlet offset: number = 0;\n\t\tlet fullText: string = '';\n\t\tconst tokens = new Array<number>();\n\t\tfor (const { text, metadata } of data) {\n\t\t\ttokens.push(offset + text.length, metadata);\n\t\t\toffset += text.length;\n\t\t\tfullText += text;\n\t\t}\n\t\treturn new LineTokens(new Uint32Array(tokens), fullText, decoder);\n\t}\n\n\tpublic static convertToEndOffset(tokens: Uint32Array, lineTextLength: number): void {\n\t\tconst tokenCount = (tokens.length >>> 1);\n\t\tconst lastTokenIndex = tokenCount - 1;\n\t\tfor (let tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {\n\t\t\ttokens[tokenIndex << 1] = tokens[(tokenIndex + 1) << 1];\n\t\t}\n\t\ttokens[lastTokenIndex << 1] = lineTextLength;\n\t}\n\n\tpublic static findIndexInTokensArray(tokens: Uint32Array, desiredIndex: number): number {\n\t\tif (tokens.length <= 2) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet low = 0;\n\t\tlet high = (tokens.length >>> 1) - 1;\n\n\t\twhile (low < high) {\n\n\t\t\tconst mid = low + Math.floor((high - low) / 2);\n\t\t\tconst endOffset = tokens[(mid << 1)];\n\n\t\t\tif (endOffset === desiredIndex) {\n\t\t\t\treturn mid + 1;\n\t\t\t} else if (endOffset < desiredIndex) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else if (endOffset > desiredIndex) {\n\t\t\t\thigh = mid;\n\t\t\t}\n\t\t}\n\n\t\treturn low;\n\t}\n\n\t_lineTokensBrand: void = undefined;\n\n\tprivate readonly _tokens: Uint32Array;\n\tprivate readonly _tokensCount: number;\n\tprivate readonly _text: string;\n\n\tpublic readonly languageIdCodec: ILanguageIdCodec;\n\n\tpublic static defaultTokenMetadata = (\n\t\t(FontStyle.None << MetadataConsts.FONT_STYLE_OFFSET)\n\t\t| (ColorId.DefaultForeground << MetadataConsts.FOREGROUND_OFFSET)\n\t\t| (ColorId.DefaultBackground << MetadataConsts.BACKGROUND_OFFSET)\n\t) >>> 0;\n\n\tconstructor(tokens: Uint32Array, text: string, decoder: ILanguageIdCodec) {\n\t\tthis._tokens = tokens;\n\t\tthis._tokensCount = (this._tokens.length >>> 1);\n\t\tthis._text = text;\n\t\tthis.languageIdCodec = decoder;\n\t}\n\n\tpublic equals(other: IViewLineTokens): boolean {\n\t\tif (other instanceof LineTokens) {\n\t\t\treturn this.slicedEquals(other, 0, this._tokensCount);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic slicedEquals(other: LineTokens, sliceFromTokenIndex: number, sliceTokenCount: number): boolean {\n\t\tif (this._text !== other._text) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this._tokensCount !== other._tokensCount) {\n\t\t\treturn false;\n\t\t}\n\t\tconst from = (sliceFromTokenIndex << 1);\n\t\tconst to = from + (sliceTokenCount << 1);\n\t\tfor (let i = from; i < to; i++) {\n\t\t\tif (this._tokens[i] !== other._tokens[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic getLineContent(): string {\n\t\treturn this._text;\n\t}\n\n\tpublic getCount(): number {\n\t\treturn this._tokensCount;\n\t}\n\n\tpublic getStartOffset(tokenIndex: number): number {\n\t\tif (tokenIndex > 0) {\n\t\t\treturn this._tokens[(tokenIndex - 1) << 1];\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic getMetadata(tokenIndex: number): number {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\treturn metadata;\n\t}\n\n\tpublic getLanguageId(tokenIndex: number): string {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\tconst languageId = TokenMetadata.getLanguageId(metadata);\n\t\treturn this.languageIdCodec.decodeLanguageId(languageId);\n\t}\n\n\tpublic getStandardTokenType(tokenIndex: number): StandardTokenType {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\treturn TokenMetadata.getTokenType(metadata);\n\t}\n\n\tpublic getForeground(tokenIndex: number): ColorId {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\treturn TokenMetadata.getForeground(metadata);\n\t}\n\n\tpublic getClassName(tokenIndex: number): string {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\treturn TokenMetadata.getClassNameFromMetadata(metadata);\n\t}\n\n\tpublic getInlineStyle(tokenIndex: number, colorMap: string[]): string {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\treturn TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);\n\t}\n\n\tpublic getPresentation(tokenIndex: number): ITokenPresentation {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\treturn TokenMetadata.getPresentationFromMetadata(metadata);\n\t}\n\n\tpublic getEndOffset(tokenIndex: number): number {\n\t\treturn this._tokens[tokenIndex << 1];\n\t}\n\n\t/**\n\t * Find the token containing offset `offset`.\n\t * @param offset The search offset\n\t * @return The index of the token containing the offset.\n\t */\n\tpublic findTokenIndexAtOffset(offset: number): number {\n\t\treturn LineTokens.findIndexInTokensArray(this._tokens, offset);\n\t}\n\n\tpublic inflate(): IViewLineTokens {\n\t\treturn this;\n\t}\n\n\tpublic sliceAndInflate(startOffset: number, endOffset: number, deltaOffset: number): IViewLineTokens {\n\t\treturn new SliceLineTokens(this, startOffset, endOffset, deltaOffset);\n\t}\n\n\t/**\n\t * @pure\n\t * @param insertTokens Must be sorted by offset.\n\t*/\n\tpublic withInserted(insertTokens: { offset: number; text: string; tokenMetadata: number }[]): LineTokens {\n\t\tif (insertTokens.length === 0) {\n\t\t\treturn this;\n\t\t}\n\n\t\tlet nextOriginalTokenIdx = 0;\n\t\tlet nextInsertTokenIdx = 0;\n\t\tlet text = '';\n\t\tconst newTokens = new Array<number>();\n\n\t\tlet originalEndOffset = 0;\n\t\twhile (true) {\n\t\t\tconst nextOriginalTokenEndOffset = nextOriginalTokenIdx < this._tokensCount ? this._tokens[nextOriginalTokenIdx << 1] : -1;\n\t\t\tconst nextInsertToken = nextInsertTokenIdx < insertTokens.length ? insertTokens[nextInsertTokenIdx] : null;\n\n\t\t\tif (nextOriginalTokenEndOffset !== -1 && (nextInsertToken === null || nextOriginalTokenEndOffset <= nextInsertToken.offset)) {\n\t\t\t\t// original token ends before next insert token\n\t\t\t\ttext += this._text.substring(originalEndOffset, nextOriginalTokenEndOffset);\n\t\t\t\tconst metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n\t\t\t\tnewTokens.push(text.length, metadata);\n\t\t\t\tnextOriginalTokenIdx++;\n\t\t\t\toriginalEndOffset = nextOriginalTokenEndOffset;\n\n\t\t\t} else if (nextInsertToken) {\n\t\t\t\tif (nextInsertToken.offset > originalEndOffset) {\n\t\t\t\t\t// insert token is in the middle of the next token.\n\t\t\t\t\ttext += this._text.substring(originalEndOffset, nextInsertToken.offset);\n\t\t\t\t\tconst metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n\t\t\t\t\tnewTokens.push(text.length, metadata);\n\t\t\t\t\toriginalEndOffset = nextInsertToken.offset;\n\t\t\t\t}\n\n\t\t\t\ttext += nextInsertToken.text;\n\t\t\t\tnewTokens.push(text.length, nextInsertToken.tokenMetadata);\n\t\t\t\tnextInsertTokenIdx++;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn new LineTokens(new Uint32Array(newTokens), text, this.languageIdCodec);\n\t}\n\n\tpublic getTokensInRange(range: OffsetRange): TokenArray {\n\t\tconst builder = new TokenArrayBuilder();\n\n\t\tconst startTokenIndex = this.findTokenIndexAtOffset(range.start);\n\t\tconst endTokenIndex = this.findTokenIndexAtOffset(range.endExclusive);\n\n\t\tfor (let tokenIndex = startTokenIndex; tokenIndex <= endTokenIndex; tokenIndex++) {\n\t\t\tconst tokenRange = new OffsetRange(this.getStartOffset(tokenIndex), this.getEndOffset(tokenIndex));\n\t\t\tconst length = tokenRange.intersectionLength(range);\n\t\t\tif (length > 0) {\n\t\t\t\tbuilder.add(length, this.getMetadata(tokenIndex));\n\t\t\t}\n\t\t}\n\n\t\treturn builder.build();\n\t}\n\n\tpublic getTokenText(tokenIndex: number): string {\n\t\tconst startOffset = this.getStartOffset(tokenIndex);\n\t\tconst endOffset = this.getEndOffset(tokenIndex);\n\t\tconst text = this._text.substring(startOffset, endOffset);\n\t\treturn text;\n\t}\n\n\tpublic forEach(callback: (tokenIndex: number) => void): void {\n\t\tconst tokenCount = this.getCount();\n\t\tfor (let tokenIndex = 0; tokenIndex < tokenCount; tokenIndex++) {\n\t\t\tcallback(tokenIndex);\n\t\t}\n\t}\n}\n\nclass SliceLineTokens implements IViewLineTokens {\n\n\tprivate readonly _source: LineTokens;\n\tprivate readonly _startOffset: number;\n\tprivate readonly _endOffset: number;\n\tprivate readonly _deltaOffset: number;\n\n\tprivate readonly _firstTokenIndex: number;\n\tprivate readonly _tokensCount: number;\n\n\tpublic readonly languageIdCodec: ILanguageIdCodec;\n\n\tconstructor(source: LineTokens, startOffset: number, endOffset: number, deltaOffset: number) {\n\t\tthis._source = source;\n\t\tthis._startOffset = startOffset;\n\t\tthis._endOffset = endOffset;\n\t\tthis._deltaOffset = deltaOffset;\n\t\tthis._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);\n\t\tthis.languageIdCodec = source.languageIdCodec;\n\n\t\tthis._tokensCount = 0;\n\t\tfor (let i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {\n\t\t\tconst tokenStartOffset = source.getStartOffset(i);\n\t\t\tif (tokenStartOffset >= endOffset) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis._tokensCount++;\n\t\t}\n\t}\n\n\tpublic getMetadata(tokenIndex: number): number {\n\t\treturn this._source.getMetadata(this._firstTokenIndex + tokenIndex);\n\t}\n\n\tpublic getLanguageId(tokenIndex: number): string {\n\t\treturn this._source.getLanguageId(this._firstTokenIndex + tokenIndex);\n\t}\n\n\tpublic getLineContent(): string {\n\t\treturn this._source.getLineContent().substring(this._startOffset, this._endOffset);\n\t}\n\n\tpublic equals(other: IViewLineTokens): boolean {\n\t\tif (other instanceof SliceLineTokens) {\n\t\t\treturn (\n\t\t\t\tthis._startOffset === other._startOffset\n\t\t\t\t&& this._endOffset === other._endOffset\n\t\t\t\t&& this._deltaOffset === other._deltaOffset\n\t\t\t\t&& this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount)\n\t\t\t);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic getCount(): number {\n\t\treturn this._tokensCount;\n\t}\n\n\tpublic getStandardTokenType(tokenIndex: number): StandardTokenType {\n\t\treturn this._source.getStandardTokenType(this._firstTokenIndex + tokenIndex);\n\t}\n\n\tpublic getForeground(tokenIndex: number): ColorId {\n\t\treturn this._source.getForeground(this._firstTokenIndex + tokenIndex);\n\t}\n\n\tpublic getEndOffset(tokenIndex: number): number {\n\t\tconst tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);\n\t\treturn Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;\n\t}\n\n\tpublic getClassName(tokenIndex: number): string {\n\t\treturn this._source.getClassName(this._firstTokenIndex + tokenIndex);\n\t}\n\n\tpublic getInlineStyle(tokenIndex: number, colorMap: string[]): string {\n\t\treturn this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);\n\t}\n\n\tpublic getPresentation(tokenIndex: number): ITokenPresentation {\n\t\treturn this._source.getPresentation(this._firstTokenIndex + tokenIndex);\n\t}\n\n\tpublic findTokenIndexAtOffset(offset: number): number {\n\t\treturn this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;\n\t}\n\n\tpublic getTokenText(tokenIndex: number): string {\n\t\tconst adjustedTokenIndex = this._firstTokenIndex + tokenIndex;\n\t\tconst tokenStartOffset = this._source.getStartOffset(adjustedTokenIndex);\n\t\tconst tokenEndOffset = this._source.getEndOffset(adjustedTokenIndex);\n\t\tlet text = this._source.getTokenText(adjustedTokenIndex);\n\t\tif (tokenStartOffset < this._startOffset) {\n\t\t\ttext = text.substring(this._startOffset - tokenStartOffset);\n\t\t}\n\t\tif (tokenEndOffset > this._endOffset) {\n\t\t\ttext = text.substring(0, text.length - (tokenEndOffset - this._endOffset));\n\t\t}\n\t\treturn text;\n\t}\n\n\tpublic forEach(callback: (tokenIndex: number) => void): void {\n\t\tfor (let tokenIndex = 0; tokenIndex < this.getCount(); tokenIndex++) {\n\t\t\tcallback(tokenIndex);\n\t\t}\n\t}\n}\n\nexport function getStandardTokenTypeAtPosition(model: ITextModel, position: IPosition): StandardTokenType | undefined {\n\tconst lineNumber = position.lineNumber;\n\tif (!model.tokenization.isCheapToTokenize(lineNumber)) {\n\t\treturn undefined;\n\t}\n\tmodel.tokenization.forceTokenization(lineNumber);\n\tconst lineTokens = model.tokenization.getLineTokens(lineNumber);\n\tconst tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n\tconst tokenType = lineTokens.getStandardTokenType(tokenIndex);\n\treturn tokenType;\n}\n"],
  "mappings": ";;AAKA,SAAS,wBAAwB;AACjC,SAAS,WAAW,SAAS,mBAAmB,gBAAgB,eAAe,0BAA0B;AACzG,SAAS,iBAAiB;AAC1B,SAAS,kBAAkB;AAC3B,SAAS,mBAAmB;AAC5B,SAAS,YAAY,yBAAyB;AAqBvC,MAAM,WAAsC;AAAA,EA/BnD,OA+BmD;AAAA;AAAA;AAAA,EAClD,OAAc,YAAY,aAAqB,SAAuC;AACrF,UAAM,kBAAkB,WAAW;AAEnC,UAAM,SAAS,IAAI,YAAY,CAAC;AAChC,WAAO,CAAC,IAAI,YAAY;AACxB,WAAO,CAAC,IAAI;AAEZ,WAAO,IAAI,WAAW,QAAQ,aAAa,OAAO;AAAA,EACnD;AAAA,EAEA,OAAc,0BAA0B,MAA4C,SAAuC;AAC1H,QAAI,SAAiB;AACrB,QAAI,WAAmB;AACvB,UAAM,SAAS,IAAI,MAAc;AACjC,eAAW,EAAE,MAAM,SAAS,KAAK,MAAM;AACtC,aAAO,KAAK,SAAS,KAAK,QAAQ,QAAQ;AAC1C,gBAAU,KAAK;AACf,kBAAY;AAAA,IACb;AACA,WAAO,IAAI,WAAW,IAAI,YAAY,MAAM,GAAG,UAAU,OAAO;AAAA,EACjE;AAAA,EAEA,OAAc,mBAAmB,QAAqB,gBAA8B;AACnF,UAAM,aAAc,OAAO,WAAW;AACtC,UAAM,iBAAiB,aAAa;AACpC,aAAS,aAAa,GAAG,aAAa,gBAAgB,cAAc;AACnE,aAAO,cAAc,CAAC,IAAI,OAAQ,aAAa,KAAM,CAAC;AAAA,IACvD;AACA,WAAO,kBAAkB,CAAC,IAAI;AAAA,EAC/B;AAAA,EAEA,OAAc,uBAAuB,QAAqB,cAA8B;AACvF,QAAI,OAAO,UAAU,GAAG;AACvB,aAAO;AAAA,IACR;AAEA,QAAI,MAAM;AACV,QAAI,QAAQ,OAAO,WAAW,KAAK;AAEnC,WAAO,MAAM,MAAM;AAElB,YAAM,MAAM,MAAM,KAAK,OAAO,OAAO,OAAO,CAAC;AAC7C,YAAM,YAAY,OAAQ,OAAO,CAAE;AAEnC,UAAI,cAAc,cAAc;AAC/B,eAAO,MAAM;AAAA,MACd,WAAW,YAAY,cAAc;AACpC,cAAM,MAAM;AAAA,MACb,WAAW,YAAY,cAAc;AACpC,eAAO;AAAA,MACR;AAAA,IACD;AAEA,WAAO;AAAA,EACR;AAAA,EAEA,mBAAyB;AAAA,EAER;AAAA,EACA;AAAA,EACA;AAAA,EAED;AAAA,EAEhB,OAAc,wBACZ,UAAU,QAAQ,eAAe,oBAC/B,QAAQ,qBAAqB,eAAe,oBAC5C,QAAQ,qBAAqB,eAAe,uBAC1C;AAAA,EAEN,YAAY,QAAqB,MAAc,SAA2B;AACzE,SAAK,UAAU;AACf,SAAK,eAAgB,KAAK,QAAQ,WAAW;AAC7C,SAAK,QAAQ;AACb,SAAK,kBAAkB;AAAA,EACxB;AAAA,EAEO,OAAO,OAAiC;AAC9C,QAAI,iBAAiB,YAAY;AAChC,aAAO,KAAK,aAAa,OAAO,GAAG,KAAK,YAAY;AAAA,IACrD;AACA,WAAO;AAAA,EACR;AAAA,EAEO,aAAa,OAAmB,qBAA6B,iBAAkC;AACrG,QAAI,KAAK,UAAU,MAAM,OAAO;AAC/B,aAAO;AAAA,IACR;AACA,QAAI,KAAK,iBAAiB,MAAM,cAAc;AAC7C,aAAO;AAAA,IACR;AACA,UAAM,OAAQ,uBAAuB;AACrC,UAAM,KAAK,QAAQ,mBAAmB;AACtC,aAAS,IAAI,MAAM,IAAI,IAAI,KAAK;AAC/B,UAAI,KAAK,QAAQ,CAAC,MAAM,MAAM,QAAQ,CAAC,GAAG;AACzC,eAAO;AAAA,MACR;AAAA,IACD;AACA,WAAO;AAAA,EACR;AAAA,EAEO,iBAAyB;AAC/B,WAAO,KAAK;AAAA,EACb;AAAA,EAEO,WAAmB;AACzB,WAAO,KAAK;AAAA,EACb;AAAA,EAEO,eAAe,YAA4B;AACjD,QAAI,aAAa,GAAG;AACnB,aAAO,KAAK,QAAS,aAAa,KAAM,CAAC;AAAA,IAC1C;AACA,WAAO;AAAA,EACR;AAAA,EAEO,YAAY,YAA4B;AAC9C,UAAM,WAAW,KAAK,SAAS,cAAc,KAAK,CAAC;AACnD,WAAO;AAAA,EACR;AAAA,EAEO,cAAc,YAA4B;AAChD,UAAM,WAAW,KAAK,SAAS,cAAc,KAAK,CAAC;AACnD,UAAM,aAAa,cAAc,cAAc,QAAQ;AACvD,WAAO,KAAK,gBAAgB,iBAAiB,UAAU;AAAA,EACxD;AAAA,EAEO,qBAAqB,YAAuC;AAClE,UAAM,WAAW,KAAK,SAAS,cAAc,KAAK,CAAC;AACnD,WAAO,cAAc,aAAa,QAAQ;AAAA,EAC3C;AAAA,EAEO,cAAc,YAA6B;AACjD,UAAM,WAAW,KAAK,SAAS,cAAc,KAAK,CAAC;AACnD,WAAO,cAAc,cAAc,QAAQ;AAAA,EAC5C;AAAA,EAEO,aAAa,YAA4B;AAC/C,UAAM,WAAW,KAAK,SAAS,cAAc,KAAK,CAAC;AACnD,WAAO,cAAc,yBAAyB,QAAQ;AAAA,EACvD;AAAA,EAEO,eAAe,YAAoB,UAA4B;AACrE,UAAM,WAAW,KAAK,SAAS,cAAc,KAAK,CAAC;AACnD,WAAO,cAAc,2BAA2B,UAAU,QAAQ;AAAA,EACnE;AAAA,EAEO,gBAAgB,YAAwC;AAC9D,UAAM,WAAW,KAAK,SAAS,cAAc,KAAK,CAAC;AACnD,WAAO,cAAc,4BAA4B,QAAQ;AAAA,EAC1D;AAAA,EAEO,aAAa,YAA4B;AAC/C,WAAO,KAAK,QAAQ,cAAc,CAAC;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,uBAAuB,QAAwB;AACrD,WAAO,WAAW,uBAAuB,KAAK,SAAS,MAAM;AAAA,EAC9D;AAAA,EAEO,UAA2B;AACjC,WAAO;AAAA,EACR;AAAA,EAEO,gBAAgB,aAAqB,WAAmB,aAAsC;AACpG,WAAO,IAAI,gBAAgB,MAAM,aAAa,WAAW,WAAW;AAAA,EACrE;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,aAAa,cAAqF;AACxG,QAAI,aAAa,WAAW,GAAG;AAC9B,aAAO;AAAA,IACR;AAEA,QAAI,uBAAuB;AAC3B,QAAI,qBAAqB;AACzB,QAAI,OAAO;AACX,UAAM,YAAY,IAAI,MAAc;AAEpC,QAAI,oBAAoB;AACxB,WAAO,MAAM;AACZ,YAAM,6BAA6B,uBAAuB,KAAK,eAAe,KAAK,QAAQ,wBAAwB,CAAC,IAAI;AACxH,YAAM,kBAAkB,qBAAqB,aAAa,SAAS,aAAa,kBAAkB,IAAI;AAEtG,UAAI,+BAA+B,OAAO,oBAAoB,QAAQ,8BAA8B,gBAAgB,SAAS;AAE5H,gBAAQ,KAAK,MAAM,UAAU,mBAAmB,0BAA0B;AAC1E,cAAM,WAAW,KAAK,SAAS,wBAAwB,KAAK,CAAC;AAC7D,kBAAU,KAAK,KAAK,QAAQ,QAAQ;AACpC;AACA,4BAAoB;AAAA,MAErB,WAAW,iBAAiB;AAC3B,YAAI,gBAAgB,SAAS,mBAAmB;AAE/C,kBAAQ,KAAK,MAAM,UAAU,mBAAmB,gBAAgB,MAAM;AACtE,gBAAM,WAAW,KAAK,SAAS,wBAAwB,KAAK,CAAC;AAC7D,oBAAU,KAAK,KAAK,QAAQ,QAAQ;AACpC,8BAAoB,gBAAgB;AAAA,QACrC;AAEA,gBAAQ,gBAAgB;AACxB,kBAAU,KAAK,KAAK,QAAQ,gBAAgB,aAAa;AACzD;AAAA,MACD,OAAO;AACN;AAAA,MACD;AAAA,IACD;AAEA,WAAO,IAAI,WAAW,IAAI,YAAY,SAAS,GAAG,MAAM,KAAK,eAAe;AAAA,EAC7E;AAAA,EAEO,iBAAiB,OAAgC;AACvD,UAAM,UAAU,IAAI,kBAAkB;AAEtC,UAAM,kBAAkB,KAAK,uBAAuB,MAAM,KAAK;AAC/D,UAAM,gBAAgB,KAAK,uBAAuB,MAAM,YAAY;AAEpE,aAAS,aAAa,iBAAiB,cAAc,eAAe,cAAc;AACjF,YAAM,aAAa,IAAI,YAAY,KAAK,eAAe,UAAU,GAAG,KAAK,aAAa,UAAU,CAAC;AACjG,YAAM,SAAS,WAAW,mBAAmB,KAAK;AAClD,UAAI,SAAS,GAAG;AACf,gBAAQ,IAAI,QAAQ,KAAK,YAAY,UAAU,CAAC;AAAA,MACjD;AAAA,IACD;AAEA,WAAO,QAAQ,MAAM;AAAA,EACtB;AAAA,EAEO,aAAa,YAA4B;AAC/C,UAAM,cAAc,KAAK,eAAe,UAAU;AAClD,UAAM,YAAY,KAAK,aAAa,UAAU;AAC9C,UAAM,OAAO,KAAK,MAAM,UAAU,aAAa,SAAS;AACxD,WAAO;AAAA,EACR;AAAA,EAEO,QAAQ,UAA8C;AAC5D,UAAM,aAAa,KAAK,SAAS;AACjC,aAAS,aAAa,GAAG,aAAa,YAAY,cAAc;AAC/D,eAAS,UAAU;AAAA,IACpB;AAAA,EACD;AACD;AAEA,MAAM,gBAA2C;AAAA,EA5RjD,OA4RiD;AAAA;AAAA;AAAA,EAE/B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAEA;AAAA,EACA;AAAA,EAED;AAAA,EAEhB,YAAY,QAAoB,aAAqB,WAAmB,aAAqB;AAC5F,SAAK,UAAU;AACf,SAAK,eAAe;AACpB,SAAK,aAAa;AAClB,SAAK,eAAe;AACpB,SAAK,mBAAmB,OAAO,uBAAuB,WAAW;AACjE,SAAK,kBAAkB,OAAO;AAE9B,SAAK,eAAe;AACpB,aAAS,IAAI,KAAK,kBAAkB,MAAM,OAAO,SAAS,GAAG,IAAI,KAAK,KAAK;AAC1E,YAAM,mBAAmB,OAAO,eAAe,CAAC;AAChD,UAAI,oBAAoB,WAAW;AAClC;AAAA,MACD;AACA,WAAK;AAAA,IACN;AAAA,EACD;AAAA,EAEO,YAAY,YAA4B;AAC9C,WAAO,KAAK,QAAQ,YAAY,KAAK,mBAAmB,UAAU;AAAA,EACnE;AAAA,EAEO,cAAc,YAA4B;AAChD,WAAO,KAAK,QAAQ,cAAc,KAAK,mBAAmB,UAAU;AAAA,EACrE;AAAA,EAEO,iBAAyB;AAC/B,WAAO,KAAK,QAAQ,eAAe,EAAE,UAAU,KAAK,cAAc,KAAK,UAAU;AAAA,EAClF;AAAA,EAEO,OAAO,OAAiC;AAC9C,QAAI,iBAAiB,iBAAiB;AACrC,aACC,KAAK,iBAAiB,MAAM,gBACzB,KAAK,eAAe,MAAM,cAC1B,KAAK,iBAAiB,MAAM,gBAC5B,KAAK,QAAQ,aAAa,MAAM,SAAS,KAAK,kBAAkB,KAAK,YAAY;AAAA,IAEtF;AACA,WAAO;AAAA,EACR;AAAA,EAEO,WAAmB;AACzB,WAAO,KAAK;AAAA,EACb;AAAA,EAEO,qBAAqB,YAAuC;AAClE,WAAO,KAAK,QAAQ,qBAAqB,KAAK,mBAAmB,UAAU;AAAA,EAC5E;AAAA,EAEO,cAAc,YAA6B;AACjD,WAAO,KAAK,QAAQ,cAAc,KAAK,mBAAmB,UAAU;AAAA,EACrE;AAAA,EAEO,aAAa,YAA4B;AAC/C,UAAM,iBAAiB,KAAK,QAAQ,aAAa,KAAK,mBAAmB,UAAU;AACnF,WAAO,KAAK,IAAI,KAAK,YAAY,cAAc,IAAI,KAAK,eAAe,KAAK;AAAA,EAC7E;AAAA,EAEO,aAAa,YAA4B;AAC/C,WAAO,KAAK,QAAQ,aAAa,KAAK,mBAAmB,UAAU;AAAA,EACpE;AAAA,EAEO,eAAe,YAAoB,UAA4B;AACrE,WAAO,KAAK,QAAQ,eAAe,KAAK,mBAAmB,YAAY,QAAQ;AAAA,EAChF;AAAA,EAEO,gBAAgB,YAAwC;AAC9D,WAAO,KAAK,QAAQ,gBAAgB,KAAK,mBAAmB,UAAU;AAAA,EACvE;AAAA,EAEO,uBAAuB,QAAwB;AACrD,WAAO,KAAK,QAAQ,uBAAuB,SAAS,KAAK,eAAe,KAAK,YAAY,IAAI,KAAK;AAAA,EACnG;AAAA,EAEO,aAAa,YAA4B;AAC/C,UAAM,qBAAqB,KAAK,mBAAmB;AACnD,UAAM,mBAAmB,KAAK,QAAQ,eAAe,kBAAkB;AACvE,UAAM,iBAAiB,KAAK,QAAQ,aAAa,kBAAkB;AACnE,QAAI,OAAO,KAAK,QAAQ,aAAa,kBAAkB;AACvD,QAAI,mBAAmB,KAAK,cAAc;AACzC,aAAO,KAAK,UAAU,KAAK,eAAe,gBAAgB;AAAA,IAC3D;AACA,QAAI,iBAAiB,KAAK,YAAY;AACrC,aAAO,KAAK,UAAU,GAAG,KAAK,UAAU,iBAAiB,KAAK,WAAW;AAAA,IAC1E;AACA,WAAO;AAAA,EACR;AAAA,EAEO,QAAQ,UAA8C;AAC5D,aAAS,aAAa,GAAG,aAAa,KAAK,SAAS,GAAG,cAAc;AACpE,eAAS,UAAU;AAAA,IACpB;AAAA,EACD;AACD;AAEO,SAAS,+BAA+B,OAAmB,UAAoD;AACrH,QAAM,aAAa,SAAS;AAC5B,MAAI,CAAC,MAAM,aAAa,kBAAkB,UAAU,GAAG;AACtD,WAAO;AAAA,EACR;AACA,QAAM,aAAa,kBAAkB,UAAU;AAC/C,QAAM,aAAa,MAAM,aAAa,cAAc,UAAU;AAC9D,QAAM,aAAa,WAAW,uBAAuB,SAAS,SAAS,CAAC;AACxE,QAAM,YAAY,WAAW,qBAAqB,UAAU;AAC5D,SAAO;AACR;AAVgB;",
  "names": []
}
