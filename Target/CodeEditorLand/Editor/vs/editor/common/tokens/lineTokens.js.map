{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/tokens/lineTokens.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { OffsetRange } from \"../core/offsetRange.js\";\nimport type { IPosition } from \"../core/position.js\";\nimport {\n\tColorId,\n\tFontStyle,\n\ttype ITokenPresentation,\n\tMetadataConsts,\n\ttype StandardTokenType,\n\tTokenMetadata,\n} from \"../encodedTokenAttributes.js\";\nimport type { ILanguageIdCodec } from \"../languages.js\";\nimport type { ITextModel } from \"../model.js\";\nimport { type TokenArray, TokenArrayBuilder } from \"./tokenArray.js\";\n\nexport interface IViewLineTokens {\n\tlanguageIdCodec: ILanguageIdCodec;\n\tequals(other: IViewLineTokens): boolean;\n\tgetCount(): number;\n\tgetStandardTokenType(tokenIndex: number): StandardTokenType;\n\tgetForeground(tokenIndex: number): ColorId;\n\tgetEndOffset(tokenIndex: number): number;\n\tgetClassName(tokenIndex: number): string;\n\tgetInlineStyle(tokenIndex: number, colorMap: string[]): string;\n\tgetPresentation(tokenIndex: number): ITokenPresentation;\n\tfindTokenIndexAtOffset(offset: number): number;\n\tgetLineContent(): string;\n\tgetMetadata(tokenIndex: number): number;\n\tgetLanguageId(tokenIndex: number): string;\n\tgetTokenText(tokenIndex: number): string;\n\tforEach(callback: (tokenIndex: number) => void): void;\n}\n\nexport class LineTokens implements IViewLineTokens {\n\tpublic static createEmpty(\n\t\tlineContent: string,\n\t\tdecoder: ILanguageIdCodec,\n\t): LineTokens {\n\t\tconst defaultMetadata = LineTokens.defaultTokenMetadata;\n\n\t\tconst tokens = new Uint32Array(2);\n\t\ttokens[0] = lineContent.length;\n\t\ttokens[1] = defaultMetadata;\n\n\t\treturn new LineTokens(tokens, lineContent, decoder);\n\t}\n\n\tpublic static createFromTextAndMetadata(\n\t\tdata: { text: string; metadata: number }[],\n\t\tdecoder: ILanguageIdCodec,\n\t): LineTokens {\n\t\tlet offset = 0;\n\t\tlet fullText = \"\";\n\t\tconst tokens = new Array<number>();\n\t\tfor (const { text, metadata } of data) {\n\t\t\ttokens.push(offset + text.length, metadata);\n\t\t\toffset += text.length;\n\t\t\tfullText += text;\n\t\t}\n\t\treturn new LineTokens(new Uint32Array(tokens), fullText, decoder);\n\t}\n\n\tpublic static convertToEndOffset(\n\t\ttokens: Uint32Array,\n\t\tlineTextLength: number,\n\t): void {\n\t\tconst tokenCount = tokens.length >>> 1;\n\t\tconst lastTokenIndex = tokenCount - 1;\n\t\tfor (let tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {\n\t\t\ttokens[tokenIndex << 1] = tokens[(tokenIndex + 1) << 1];\n\t\t}\n\t\ttokens[lastTokenIndex << 1] = lineTextLength;\n\t}\n\n\tpublic static findIndexInTokensArray(\n\t\ttokens: Uint32Array,\n\t\tdesiredIndex: number,\n\t): number {\n\t\tif (tokens.length <= 2) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet low = 0;\n\t\tlet high = (tokens.length >>> 1) - 1;\n\n\t\twhile (low < high) {\n\t\t\tconst mid = low + Math.floor((high - low) / 2);\n\t\t\tconst endOffset = tokens[mid << 1];\n\n\t\t\tif (endOffset === desiredIndex) {\n\t\t\t\treturn mid + 1;\n\t\t\t} else if (endOffset < desiredIndex) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else if (endOffset > desiredIndex) {\n\t\t\t\thigh = mid;\n\t\t\t}\n\t\t}\n\n\t\treturn low;\n\t}\n\n\t_lineTokensBrand: void = undefined;\n\n\tprivate readonly _tokens: Uint32Array;\n\tprivate readonly _tokensCount: number;\n\tprivate readonly _text: string;\n\n\tpublic readonly languageIdCodec: ILanguageIdCodec;\n\n\tpublic static defaultTokenMetadata =\n\t\t((FontStyle.None << MetadataConsts.FONT_STYLE_OFFSET) |\n\t\t\t(ColorId.DefaultForeground << MetadataConsts.FOREGROUND_OFFSET) |\n\t\t\t(ColorId.DefaultBackground << MetadataConsts.BACKGROUND_OFFSET)) >>>\n\t\t0;\n\n\tconstructor(tokens: Uint32Array, text: string, decoder: ILanguageIdCodec) {\n\t\tthis._tokens = tokens;\n\t\tthis._tokensCount = this._tokens.length >>> 1;\n\t\tthis._text = text;\n\t\tthis.languageIdCodec = decoder;\n\t}\n\n\tpublic equals(other: IViewLineTokens): boolean {\n\t\tif (other instanceof LineTokens) {\n\t\t\treturn this.slicedEquals(other, 0, this._tokensCount);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic slicedEquals(\n\t\tother: LineTokens,\n\t\tsliceFromTokenIndex: number,\n\t\tsliceTokenCount: number,\n\t): boolean {\n\t\tif (this._text !== other._text) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this._tokensCount !== other._tokensCount) {\n\t\t\treturn false;\n\t\t}\n\t\tconst from = sliceFromTokenIndex << 1;\n\t\tconst to = from + (sliceTokenCount << 1);\n\t\tfor (let i = from; i < to; i++) {\n\t\t\tif (this._tokens[i] !== other._tokens[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic getLineContent(): string {\n\t\treturn this._text;\n\t}\n\n\tpublic getCount(): number {\n\t\treturn this._tokensCount;\n\t}\n\n\tpublic getStartOffset(tokenIndex: number): number {\n\t\tif (tokenIndex > 0) {\n\t\t\treturn this._tokens[(tokenIndex - 1) << 1];\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic getMetadata(tokenIndex: number): number {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\treturn metadata;\n\t}\n\n\tpublic getLanguageId(tokenIndex: number): string {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\tconst languageId = TokenMetadata.getLanguageId(metadata);\n\t\treturn this.languageIdCodec.decodeLanguageId(languageId);\n\t}\n\n\tpublic getStandardTokenType(tokenIndex: number): StandardTokenType {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\treturn TokenMetadata.getTokenType(metadata);\n\t}\n\n\tpublic getForeground(tokenIndex: number): ColorId {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\treturn TokenMetadata.getForeground(metadata);\n\t}\n\n\tpublic getClassName(tokenIndex: number): string {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\treturn TokenMetadata.getClassNameFromMetadata(metadata);\n\t}\n\n\tpublic getInlineStyle(tokenIndex: number, colorMap: string[]): string {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\treturn TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);\n\t}\n\n\tpublic getPresentation(tokenIndex: number): ITokenPresentation {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\treturn TokenMetadata.getPresentationFromMetadata(metadata);\n\t}\n\n\tpublic getEndOffset(tokenIndex: number): number {\n\t\treturn this._tokens[tokenIndex << 1];\n\t}\n\n\t/**\n\t * Find the token containing offset `offset`.\n\t * @param offset The search offset\n\t * @return The index of the token containing the offset.\n\t */\n\tpublic findTokenIndexAtOffset(offset: number): number {\n\t\treturn LineTokens.findIndexInTokensArray(this._tokens, offset);\n\t}\n\n\tpublic inflate(): IViewLineTokens {\n\t\treturn this;\n\t}\n\n\tpublic sliceAndInflate(\n\t\tstartOffset: number,\n\t\tendOffset: number,\n\t\tdeltaOffset: number,\n\t): IViewLineTokens {\n\t\treturn new SliceLineTokens(this, startOffset, endOffset, deltaOffset);\n\t}\n\n\t/**\n\t * @pure\n\t * @param insertTokens Must be sorted by offset.\n\t */\n\tpublic withInserted(\n\t\tinsertTokens: { offset: number; text: string; tokenMetadata: number }[],\n\t): LineTokens {\n\t\tif (insertTokens.length === 0) {\n\t\t\treturn this;\n\t\t}\n\n\t\tlet nextOriginalTokenIdx = 0;\n\t\tlet nextInsertTokenIdx = 0;\n\t\tlet text = \"\";\n\t\tconst newTokens = new Array<number>();\n\n\t\tlet originalEndOffset = 0;\n\t\twhile (true) {\n\t\t\tconst nextOriginalTokenEndOffset =\n\t\t\t\tnextOriginalTokenIdx < this._tokensCount\n\t\t\t\t\t? this._tokens[nextOriginalTokenIdx << 1]\n\t\t\t\t\t: -1;\n\t\t\tconst nextInsertToken =\n\t\t\t\tnextInsertTokenIdx < insertTokens.length\n\t\t\t\t\t? insertTokens[nextInsertTokenIdx]\n\t\t\t\t\t: null;\n\n\t\t\tif (\n\t\t\t\tnextOriginalTokenEndOffset !== -1 &&\n\t\t\t\t(nextInsertToken === null ||\n\t\t\t\t\tnextOriginalTokenEndOffset <= nextInsertToken.offset)\n\t\t\t) {\n\t\t\t\t// original token ends before next insert token\n\t\t\t\ttext += this._text.substring(\n\t\t\t\t\toriginalEndOffset,\n\t\t\t\t\tnextOriginalTokenEndOffset,\n\t\t\t\t);\n\t\t\t\tconst metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n\t\t\t\tnewTokens.push(text.length, metadata);\n\t\t\t\tnextOriginalTokenIdx++;\n\t\t\t\toriginalEndOffset = nextOriginalTokenEndOffset;\n\t\t\t} else if (nextInsertToken) {\n\t\t\t\tif (nextInsertToken.offset > originalEndOffset) {\n\t\t\t\t\t// insert token is in the middle of the next token.\n\t\t\t\t\ttext += this._text.substring(\n\t\t\t\t\t\toriginalEndOffset,\n\t\t\t\t\t\tnextInsertToken.offset,\n\t\t\t\t\t);\n\t\t\t\t\tconst metadata =\n\t\t\t\t\t\tthis._tokens[(nextOriginalTokenIdx << 1) + 1];\n\t\t\t\t\tnewTokens.push(text.length, metadata);\n\t\t\t\t\toriginalEndOffset = nextInsertToken.offset;\n\t\t\t\t}\n\n\t\t\t\ttext += nextInsertToken.text;\n\t\t\t\tnewTokens.push(text.length, nextInsertToken.tokenMetadata);\n\t\t\t\tnextInsertTokenIdx++;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn new LineTokens(\n\t\t\tnew Uint32Array(newTokens),\n\t\t\ttext,\n\t\t\tthis.languageIdCodec,\n\t\t);\n\t}\n\n\tpublic getTokensInRange(range: OffsetRange): TokenArray {\n\t\tconst builder = new TokenArrayBuilder();\n\n\t\tconst startTokenIndex = this.findTokenIndexAtOffset(range.start);\n\t\tconst endTokenIndex = this.findTokenIndexAtOffset(range.endExclusive);\n\n\t\tfor (\n\t\t\tlet tokenIndex = startTokenIndex;\n\t\t\ttokenIndex <= endTokenIndex;\n\t\t\ttokenIndex++\n\t\t) {\n\t\t\tconst tokenRange = new OffsetRange(\n\t\t\t\tthis.getStartOffset(tokenIndex),\n\t\t\t\tthis.getEndOffset(tokenIndex),\n\t\t\t);\n\t\t\tconst length = tokenRange.intersectionLength(range);\n\t\t\tif (length > 0) {\n\t\t\t\tbuilder.add(length, this.getMetadata(tokenIndex));\n\t\t\t}\n\t\t}\n\n\t\treturn builder.build();\n\t}\n\n\tpublic getTokenText(tokenIndex: number): string {\n\t\tconst startOffset = this.getStartOffset(tokenIndex);\n\t\tconst endOffset = this.getEndOffset(tokenIndex);\n\t\tconst text = this._text.substring(startOffset, endOffset);\n\t\treturn text;\n\t}\n\n\tpublic forEach(callback: (tokenIndex: number) => void): void {\n\t\tconst tokenCount = this.getCount();\n\t\tfor (let tokenIndex = 0; tokenIndex < tokenCount; tokenIndex++) {\n\t\t\tcallback(tokenIndex);\n\t\t}\n\t}\n}\n\nclass SliceLineTokens implements IViewLineTokens {\n\tprivate readonly _source: LineTokens;\n\tprivate readonly _startOffset: number;\n\tprivate readonly _endOffset: number;\n\tprivate readonly _deltaOffset: number;\n\n\tprivate readonly _firstTokenIndex: number;\n\tprivate readonly _tokensCount: number;\n\n\tpublic readonly languageIdCodec: ILanguageIdCodec;\n\n\tconstructor(\n\t\tsource: LineTokens,\n\t\tstartOffset: number,\n\t\tendOffset: number,\n\t\tdeltaOffset: number,\n\t) {\n\t\tthis._source = source;\n\t\tthis._startOffset = startOffset;\n\t\tthis._endOffset = endOffset;\n\t\tthis._deltaOffset = deltaOffset;\n\t\tthis._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);\n\t\tthis.languageIdCodec = source.languageIdCodec;\n\n\t\tthis._tokensCount = 0;\n\t\tfor (\n\t\t\tlet i = this._firstTokenIndex, len = source.getCount();\n\t\t\ti < len;\n\t\t\ti++\n\t\t) {\n\t\t\tconst tokenStartOffset = source.getStartOffset(i);\n\t\t\tif (tokenStartOffset >= endOffset) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis._tokensCount++;\n\t\t}\n\t}\n\n\tpublic getMetadata(tokenIndex: number): number {\n\t\treturn this._source.getMetadata(this._firstTokenIndex + tokenIndex);\n\t}\n\n\tpublic getLanguageId(tokenIndex: number): string {\n\t\treturn this._source.getLanguageId(this._firstTokenIndex + tokenIndex);\n\t}\n\n\tpublic getLineContent(): string {\n\t\treturn this._source\n\t\t\t.getLineContent()\n\t\t\t.substring(this._startOffset, this._endOffset);\n\t}\n\n\tpublic equals(other: IViewLineTokens): boolean {\n\t\tif (other instanceof SliceLineTokens) {\n\t\t\treturn (\n\t\t\t\tthis._startOffset === other._startOffset &&\n\t\t\t\tthis._endOffset === other._endOffset &&\n\t\t\t\tthis._deltaOffset === other._deltaOffset &&\n\t\t\t\tthis._source.slicedEquals(\n\t\t\t\t\tother._source,\n\t\t\t\t\tthis._firstTokenIndex,\n\t\t\t\t\tthis._tokensCount,\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic getCount(): number {\n\t\treturn this._tokensCount;\n\t}\n\n\tpublic getStandardTokenType(tokenIndex: number): StandardTokenType {\n\t\treturn this._source.getStandardTokenType(\n\t\t\tthis._firstTokenIndex + tokenIndex,\n\t\t);\n\t}\n\n\tpublic getForeground(tokenIndex: number): ColorId {\n\t\treturn this._source.getForeground(this._firstTokenIndex + tokenIndex);\n\t}\n\n\tpublic getEndOffset(tokenIndex: number): number {\n\t\tconst tokenEndOffset = this._source.getEndOffset(\n\t\t\tthis._firstTokenIndex + tokenIndex,\n\t\t);\n\t\treturn (\n\t\t\tMath.min(this._endOffset, tokenEndOffset) -\n\t\t\tthis._startOffset +\n\t\t\tthis._deltaOffset\n\t\t);\n\t}\n\n\tpublic getClassName(tokenIndex: number): string {\n\t\treturn this._source.getClassName(this._firstTokenIndex + tokenIndex);\n\t}\n\n\tpublic getInlineStyle(tokenIndex: number, colorMap: string[]): string {\n\t\treturn this._source.getInlineStyle(\n\t\t\tthis._firstTokenIndex + tokenIndex,\n\t\t\tcolorMap,\n\t\t);\n\t}\n\n\tpublic getPresentation(tokenIndex: number): ITokenPresentation {\n\t\treturn this._source.getPresentation(this._firstTokenIndex + tokenIndex);\n\t}\n\n\tpublic findTokenIndexAtOffset(offset: number): number {\n\t\treturn (\n\t\t\tthis._source.findTokenIndexAtOffset(\n\t\t\t\toffset + this._startOffset - this._deltaOffset,\n\t\t\t) - this._firstTokenIndex\n\t\t);\n\t}\n\n\tpublic getTokenText(tokenIndex: number): string {\n\t\tconst adjustedTokenIndex = this._firstTokenIndex + tokenIndex;\n\t\tconst tokenStartOffset =\n\t\t\tthis._source.getStartOffset(adjustedTokenIndex);\n\t\tconst tokenEndOffset = this._source.getEndOffset(adjustedTokenIndex);\n\t\tlet text = this._source.getTokenText(adjustedTokenIndex);\n\t\tif (tokenStartOffset < this._startOffset) {\n\t\t\ttext = text.substring(this._startOffset - tokenStartOffset);\n\t\t}\n\t\tif (tokenEndOffset > this._endOffset) {\n\t\t\ttext = text.substring(\n\t\t\t\t0,\n\t\t\t\ttext.length - (tokenEndOffset - this._endOffset),\n\t\t\t);\n\t\t}\n\t\treturn text;\n\t}\n\n\tpublic forEach(callback: (tokenIndex: number) => void): void {\n\t\tfor (let tokenIndex = 0; tokenIndex < this.getCount(); tokenIndex++) {\n\t\t\tcallback(tokenIndex);\n\t\t}\n\t}\n}\n\nexport function getStandardTokenTypeAtPosition(\n\tmodel: ITextModel,\n\tposition: IPosition,\n): StandardTokenType | undefined {\n\tconst lineNumber = position.lineNumber;\n\tif (!model.tokenization.isCheapToTokenize(lineNumber)) {\n\t\treturn undefined;\n\t}\n\tmodel.tokenization.forceTokenization(lineNumber);\n\tconst lineTokens = model.tokenization.getLineTokens(lineNumber);\n\tconst tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n\tconst tokenType = lineTokens.getStandardTokenType(tokenIndex);\n\treturn tokenType;\n}\n"],
  "mappings": "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",
  "names": []
}
