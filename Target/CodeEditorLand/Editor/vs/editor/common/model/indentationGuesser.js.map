{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/model/indentationGuesser.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from \"../../../base/common/charCode.js\";\nimport type { ITextBuffer } from \"../model.js\";\n\nclass SpacesDiffResult {\n\tpublic spacesDiff = 0;\n\tpublic looksLikeAlignment = false;\n}\n\n/**\n * Compute the diff in spaces between two line's indentation.\n */\nfunction spacesDiff(\n\ta: string,\n\taLength: number,\n\tb: string,\n\tbLength: number,\n\tresult: SpacesDiffResult,\n): void {\n\tresult.spacesDiff = 0;\n\tresult.looksLikeAlignment = false;\n\n\t// This can go both ways (e.g.):\n\t//  - a: \"\\t\"\n\t//  - b: \"\\t    \"\n\t//  => This should count 1 tab and 4 spaces\n\n\tlet i: number;\n\n\tfor (i = 0; i < aLength && i < bLength; i++) {\n\t\tconst aCharCode = a.charCodeAt(i);\n\t\tconst bCharCode = b.charCodeAt(i);\n\n\t\tif (aCharCode !== bCharCode) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlet aSpacesCnt = 0,\n\t\taTabsCount = 0;\n\tfor (let j = i; j < aLength; j++) {\n\t\tconst aCharCode = a.charCodeAt(j);\n\t\tif (aCharCode === CharCode.Space) {\n\t\t\taSpacesCnt++;\n\t\t} else {\n\t\t\taTabsCount++;\n\t\t}\n\t}\n\n\tlet bSpacesCnt = 0,\n\t\tbTabsCount = 0;\n\tfor (let j = i; j < bLength; j++) {\n\t\tconst bCharCode = b.charCodeAt(j);\n\t\tif (bCharCode === CharCode.Space) {\n\t\t\tbSpacesCnt++;\n\t\t} else {\n\t\t\tbTabsCount++;\n\t\t}\n\t}\n\n\tif (aSpacesCnt > 0 && aTabsCount > 0) {\n\t\treturn;\n\t}\n\tif (bSpacesCnt > 0 && bTabsCount > 0) {\n\t\treturn;\n\t}\n\n\tconst tabsDiff = Math.abs(aTabsCount - bTabsCount);\n\tconst spacesDiff = Math.abs(aSpacesCnt - bSpacesCnt);\n\n\tif (tabsDiff === 0) {\n\t\t// check if the indentation difference might be caused by alignment reasons\n\t\t// sometime folks like to align their code, but this should not be used as a hint\n\t\tresult.spacesDiff = spacesDiff;\n\n\t\tif (\n\t\t\tspacesDiff > 0 &&\n\t\t\tbSpacesCnt - 1 >= 0 &&\n\t\t\tbSpacesCnt - 1 < a.length &&\n\t\t\tbSpacesCnt < b.length\n\t\t) {\n\t\t\tif (\n\t\t\t\tb.charCodeAt(bSpacesCnt) !== CharCode.Space &&\n\t\t\t\ta.charCodeAt(bSpacesCnt - 1) === CharCode.Space\n\t\t\t) {\n\t\t\t\tif (a.charCodeAt(a.length - 1) === CharCode.Comma) {\n\t\t\t\t\t// This looks like an alignment desire: e.g.\n\t\t\t\t\t// const a = b + c,\n\t\t\t\t\t//       d = b - c;\n\t\t\t\t\tresult.looksLikeAlignment = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tif (spacesDiff % tabsDiff === 0) {\n\t\tresult.spacesDiff = spacesDiff / tabsDiff;\n\t\treturn;\n\t}\n}\n\n/**\n * Result for a guessIndentation\n */\nexport interface IGuessedIndentation {\n\t/**\n\t * If indentation is based on spaces (`insertSpaces` = true), then what is the number of spaces that make an indent?\n\t */\n\ttabSize: number;\n\t/**\n\t * Is indentation based on spaces?\n\t */\n\tinsertSpaces: boolean;\n}\n\nexport function guessIndentation(\n\tsource: ITextBuffer,\n\tdefaultTabSize: number,\n\tdefaultInsertSpaces: boolean,\n): IGuessedIndentation {\n\t// Look at most at the first 10k lines\n\tconst linesCount = Math.min(source.getLineCount(), 10000);\n\n\tlet linesIndentedWithTabsCount = 0; // number of lines that contain at least one tab in indentation\n\tlet linesIndentedWithSpacesCount = 0; // number of lines that contain only spaces in indentation\n\n\tlet previousLineText = \"\"; // content of latest line that contained non-whitespace chars\n\tlet previousLineIndentation = 0; // index at which latest line contained the first non-whitespace char\n\n\tconst ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8, 3, 5, 7]; // prefer even guesses for `tabSize`, limit to [2, 8].\n\tconst MAX_ALLOWED_TAB_SIZE_GUESS = 8; // max(ALLOWED_TAB_SIZE_GUESSES) = 8\n\n\tconst spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0]; // `tabSize` scores\n\tconst tmp = new SpacesDiffResult();\n\n\tfor (let lineNumber = 1; lineNumber <= linesCount; lineNumber++) {\n\t\tconst currentLineLength = source.getLineLength(lineNumber);\n\t\tconst currentLineText = source.getLineContent(lineNumber);\n\n\t\t// if the text buffer is chunk based, so long lines are cons-string, v8 will flattern the string when we check charCode.\n\t\t// checking charCode on chunks directly is cheaper.\n\t\tconst useCurrentLineText = currentLineLength <= 65536;\n\n\t\tlet currentLineHasContent = false; // does `currentLineText` contain non-whitespace chars\n\t\tlet currentLineIndentation = 0; // index at which `currentLineText` contains the first non-whitespace char\n\t\tlet currentLineSpacesCount = 0; // count of spaces found in `currentLineText` indentation\n\t\tlet currentLineTabsCount = 0; // count of tabs found in `currentLineText` indentation\n\t\tfor (let j = 0, lenJ = currentLineLength; j < lenJ; j++) {\n\t\t\tconst charCode = useCurrentLineText\n\t\t\t\t? currentLineText.charCodeAt(j)\n\t\t\t\t: source.getLineCharCode(lineNumber, j);\n\n\t\t\tif (charCode === CharCode.Tab) {\n\t\t\t\tcurrentLineTabsCount++;\n\t\t\t} else if (charCode === CharCode.Space) {\n\t\t\t\tcurrentLineSpacesCount++;\n\t\t\t} else {\n\t\t\t\t// Hit non whitespace character on this line\n\t\t\t\tcurrentLineHasContent = true;\n\t\t\t\tcurrentLineIndentation = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Ignore empty or only whitespace lines\n\t\tif (!currentLineHasContent) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (currentLineTabsCount > 0) {\n\t\t\tlinesIndentedWithTabsCount++;\n\t\t} else if (currentLineSpacesCount > 1) {\n\t\t\tlinesIndentedWithSpacesCount++;\n\t\t}\n\n\t\tspacesDiff(\n\t\t\tpreviousLineText,\n\t\t\tpreviousLineIndentation,\n\t\t\tcurrentLineText,\n\t\t\tcurrentLineIndentation,\n\t\t\ttmp,\n\t\t);\n\n\t\tif (tmp.looksLikeAlignment) {\n\t\t\t// if defaultInsertSpaces === true && the spaces count == tabSize, we may want to count it as valid indentation\n\t\t\t//\n\t\t\t// - item1\n\t\t\t//   - item2\n\t\t\t//\n\t\t\t// otherwise skip this line entirely\n\t\t\t//\n\t\t\t// const a = 1,\n\t\t\t//       b = 2;\n\n\t\t\tif (!(defaultInsertSpaces && defaultTabSize === tmp.spacesDiff)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tconst currentSpacesDiff = tmp.spacesDiff;\n\t\tif (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {\n\t\t\tspacesDiffCount[currentSpacesDiff]++;\n\t\t}\n\n\t\tpreviousLineText = currentLineText;\n\t\tpreviousLineIndentation = currentLineIndentation;\n\t}\n\n\tlet insertSpaces = defaultInsertSpaces;\n\tif (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {\n\t\tinsertSpaces =\n\t\t\tlinesIndentedWithTabsCount < linesIndentedWithSpacesCount;\n\t}\n\n\tlet tabSize = defaultTabSize;\n\n\t// Guess tabSize only if inserting spaces...\n\tif (insertSpaces) {\n\t\tlet tabSizeScore = insertSpaces ? 0 : 0.1 * linesCount;\n\n\t\t// console.log(\"score threshold: \" + tabSizeScore);\n\n\t\tALLOWED_TAB_SIZE_GUESSES.forEach((possibleTabSize) => {\n\t\t\tconst possibleTabSizeScore = spacesDiffCount[possibleTabSize];\n\t\t\tif (possibleTabSizeScore > tabSizeScore) {\n\t\t\t\ttabSizeScore = possibleTabSizeScore;\n\t\t\t\ttabSize = possibleTabSize;\n\t\t\t}\n\t\t});\n\n\t\t// Let a tabSize of 2 win even if it is not the maximum\n\t\t// (only in case 4 was guessed)\n\t\tif (\n\t\t\ttabSize === 4 &&\n\t\t\tspacesDiffCount[4] > 0 &&\n\t\t\tspacesDiffCount[2] > 0 &&\n\t\t\tspacesDiffCount[2] >= spacesDiffCount[4] / 2\n\t\t) {\n\t\t\ttabSize = 2;\n\t\t}\n\t}\n\n\t// console.log('--------------------------');\n\t// console.log('linesIndentedWithTabsCount: ' + linesIndentedWithTabsCount + ', linesIndentedWithSpacesCount: ' + linesIndentedWithSpacesCount);\n\t// console.log('spacesDiffCount: ' + spacesDiffCount);\n\t// console.log('tabSize: ' + tabSize + ', tabSizeScore: ' + tabSizeScore);\n\n\treturn {\n\t\tinsertSpaces: insertSpaces,\n\t\ttabSize: tabSize,\n\t};\n}\n"],
  "mappings": "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",
  "names": ["spacesDiff"]
}
