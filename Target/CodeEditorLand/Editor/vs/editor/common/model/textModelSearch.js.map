{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/model/textModelSearch.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { WordCharacterClass, WordCharacterClassifier, getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { EndOfLinePreference, FindMatch, SearchData } from '../model.js';\nimport { TextModel } from './textModel.js';\n\nconst LIMIT_FIND_COUNT = 999;\n\nexport class SearchParams {\n\tpublic readonly searchString: string;\n\tpublic readonly isRegex: boolean;\n\tpublic readonly matchCase: boolean;\n\tpublic readonly wordSeparators: string | null;\n\n\tconstructor(searchString: string, isRegex: boolean, matchCase: boolean, wordSeparators: string | null) {\n\t\tthis.searchString = searchString;\n\t\tthis.isRegex = isRegex;\n\t\tthis.matchCase = matchCase;\n\t\tthis.wordSeparators = wordSeparators;\n\t}\n\n\tpublic parseSearchRequest(): SearchData | null {\n\t\tif (this.searchString === '') {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Try to create a RegExp out of the params\n\t\tlet multiline: boolean;\n\t\tif (this.isRegex) {\n\t\t\tmultiline = isMultilineRegexSource(this.searchString);\n\t\t} else {\n\t\t\tmultiline = (this.searchString.indexOf('\\n') >= 0);\n\t\t}\n\n\t\tlet regex: RegExp | null = null;\n\t\ttry {\n\t\t\tregex = strings.createRegExp(this.searchString, this.isRegex, {\n\t\t\t\tmatchCase: this.matchCase,\n\t\t\t\twholeWord: false,\n\t\t\t\tmultiline: multiline,\n\t\t\t\tglobal: true,\n\t\t\t\tunicode: true\n\t\t\t});\n\t\t} catch (err) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!regex) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet canUseSimpleSearch = (!this.isRegex && !multiline);\n\t\tif (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {\n\t\t\t// casing might make a difference\n\t\t\tcanUseSimpleSearch = this.matchCase;\n\t\t}\n\n\t\treturn new SearchData(regex, this.wordSeparators ? getMapForWordSeparators(this.wordSeparators, []) : null, canUseSimpleSearch ? this.searchString : null);\n\t}\n}\n\nexport function isMultilineRegexSource(searchString: string): boolean {\n\tif (!searchString || searchString.length === 0) {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0, len = searchString.length; i < len; i++) {\n\t\tconst chCode = searchString.charCodeAt(i);\n\n\t\tif (chCode === CharCode.LineFeed) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (chCode === CharCode.Backslash) {\n\n\t\t\t// move to next char\n\t\t\ti++;\n\n\t\t\tif (i >= len) {\n\t\t\t\t// string ends with a \\\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst nextChCode = searchString.charCodeAt(i);\n\t\t\tif (nextChCode === CharCode.n || nextChCode === CharCode.r || nextChCode === CharCode.W) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport function createFindMatch(range: Range, rawMatches: RegExpExecArray, captureMatches: boolean): FindMatch {\n\tif (!captureMatches) {\n\t\treturn new FindMatch(range, null);\n\t}\n\tconst matches: string[] = [];\n\tfor (let i = 0, len = rawMatches.length; i < len; i++) {\n\t\tmatches[i] = rawMatches[i];\n\t}\n\treturn new FindMatch(range, matches);\n}\n\nclass LineFeedCounter {\n\n\tprivate readonly _lineFeedsOffsets: number[];\n\n\tconstructor(text: string) {\n\t\tconst lineFeedsOffsets: number[] = [];\n\t\tlet lineFeedsOffsetsLen = 0;\n\t\tfor (let i = 0, textLen = text.length; i < textLen; i++) {\n\t\t\tif (text.charCodeAt(i) === CharCode.LineFeed) {\n\t\t\t\tlineFeedsOffsets[lineFeedsOffsetsLen++] = i;\n\t\t\t}\n\t\t}\n\t\tthis._lineFeedsOffsets = lineFeedsOffsets;\n\t}\n\n\tpublic findLineFeedCountBeforeOffset(offset: number): number {\n\t\tconst lineFeedsOffsets = this._lineFeedsOffsets;\n\t\tlet min = 0;\n\t\tlet max = lineFeedsOffsets.length - 1;\n\n\t\tif (max === -1) {\n\t\t\t// no line feeds\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (offset <= lineFeedsOffsets[0]) {\n\t\t\t// before first line feed\n\t\t\treturn 0;\n\t\t}\n\n\t\twhile (min < max) {\n\t\t\tconst mid = min + ((max - min) / 2 >> 0);\n\n\t\t\tif (lineFeedsOffsets[mid] >= offset) {\n\t\t\t\tmax = mid - 1;\n\t\t\t} else {\n\t\t\t\tif (lineFeedsOffsets[mid + 1] >= offset) {\n\t\t\t\t\t// bingo!\n\t\t\t\t\tmin = mid;\n\t\t\t\t\tmax = mid;\n\t\t\t\t} else {\n\t\t\t\t\tmin = mid + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn min + 1;\n\t}\n}\n\nexport class TextModelSearch {\n\n\tpublic static findMatches(model: TextModel, searchParams: SearchParams, searchRange: Range, captureMatches: boolean, limitResultCount: number): FindMatch[] {\n\t\tconst searchData = searchParams.parseSearchRequest();\n\t\tif (!searchData) {\n\t\t\treturn [];\n\t\t}\n\n\t\tif (searchData.regex.multiline) {\n\t\t\treturn this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);\n\t\t}\n\t\treturn this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);\n\t}\n\n\t/**\n\t * Multiline search always executes on the lines concatenated with \\n.\n\t * We must therefore compensate for the count of \\n in case the model is CRLF\n\t */\n\tprivate static _getMultilineMatchRange(model: TextModel, deltaOffset: number, text: string, lfCounter: LineFeedCounter | null, matchIndex: number, match0: string): Range {\n\t\tlet startOffset: number;\n\t\tlet lineFeedCountBeforeMatch = 0;\n\t\tif (lfCounter) {\n\t\t\tlineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);\n\t\t\tstartOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch /* add as many \\r as there were \\n */;\n\t\t} else {\n\t\t\tstartOffset = deltaOffset + matchIndex;\n\t\t}\n\n\t\tlet endOffset: number;\n\t\tif (lfCounter) {\n\t\t\tconst lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);\n\t\t\tconst lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;\n\t\t\tendOffset = startOffset + match0.length + lineFeedCountInMatch /* add as many \\r as there were \\n */;\n\t\t} else {\n\t\t\tendOffset = startOffset + match0.length;\n\t\t}\n\n\t\tconst startPosition = model.getPositionAt(startOffset);\n\t\tconst endPosition = model.getPositionAt(endOffset);\n\t\treturn new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n\t}\n\n\tprivate static _doFindMatchesMultiline(model: TextModel, searchRange: Range, searcher: Searcher, captureMatches: boolean, limitResultCount: number): FindMatch[] {\n\t\tconst deltaOffset = model.getOffsetAt(searchRange.getStartPosition());\n\t\t// We always execute multiline search over the lines joined with \\n\n\t\t// This makes it that \\n will match the EOL for both CRLF and LF models\n\t\t// We compensate for offset errors in `_getMultilineMatchRange`\n\t\tconst text = model.getValueInRange(searchRange, EndOfLinePreference.LF);\n\t\tconst lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n\n\t\tconst result: FindMatch[] = [];\n\t\tlet counter = 0;\n\n\t\tlet m: RegExpExecArray | null;\n\t\tsearcher.reset(0);\n\t\twhile ((m = searcher.next(text))) {\n\t\t\tresult[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n\t\t\tif (counter >= limitResultCount) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate static _doFindMatchesLineByLine(model: TextModel, searchRange: Range, searchData: SearchData, captureMatches: boolean, limitResultCount: number): FindMatch[] {\n\t\tconst result: FindMatch[] = [];\n\t\tlet resultLen = 0;\n\n\t\t// Early case for a search range that starts & stops on the same line number\n\t\tif (searchRange.startLineNumber === searchRange.endLineNumber) {\n\t\t\tconst text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);\n\t\t\tresultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n\t\t\treturn result;\n\t\t}\n\n\t\t// Collect results from first line\n\t\tconst text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);\n\t\tresultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n\n\t\t// Collect results from middle lines\n\t\tfor (let lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {\n\t\t\tresultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n\t\t}\n\n\t\t// Collect results from last line\n\t\tif (resultLen < limitResultCount) {\n\t\t\tconst text = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);\n\t\t\tresultLen = this._findMatchesInLine(searchData, text, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate static _findMatchesInLine(searchData: SearchData, text: string, lineNumber: number, deltaOffset: number, resultLen: number, result: FindMatch[], captureMatches: boolean, limitResultCount: number): number {\n\t\tconst wordSeparators = searchData.wordSeparators;\n\t\tif (!captureMatches && searchData.simpleSearch) {\n\t\t\tconst searchString = searchData.simpleSearch;\n\t\t\tconst searchStringLen = searchString.length;\n\t\t\tconst textLength = text.length;\n\n\t\t\tlet lastMatchIndex = -searchStringLen;\n\t\t\twhile ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n\t\t\t\tif (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n\t\t\t\t\tresult[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n\t\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\t\treturn resultLen;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn resultLen;\n\t\t}\n\n\t\tconst searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n\t\tlet m: RegExpExecArray | null;\n\t\t// Reset regex to search from the beginning\n\t\tsearcher.reset(0);\n\t\tdo {\n\t\t\tm = searcher.next(text);\n\t\t\tif (m) {\n\t\t\t\tresult[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\treturn resultLen;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (m);\n\t\treturn resultLen;\n\t}\n\n\tpublic static findNextMatch(model: TextModel, searchParams: SearchParams, searchStart: Position, captureMatches: boolean): FindMatch | null {\n\t\tconst searchData = searchParams.parseSearchRequest();\n\t\tif (!searchData) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n\n\t\tif (searchData.regex.multiline) {\n\t\t\treturn this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);\n\t\t}\n\t\treturn this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);\n\t}\n\n\tprivate static _doFindNextMatchMultiline(model: TextModel, searchStart: Position, searcher: Searcher, captureMatches: boolean): FindMatch | null {\n\t\tconst searchTextStart = new Position(searchStart.lineNumber, 1);\n\t\tconst deltaOffset = model.getOffsetAt(searchTextStart);\n\t\tconst lineCount = model.getLineCount();\n\t\t// We always execute multiline search over the lines joined with \\n\n\t\t// This makes it that \\n will match the EOL for both CRLF and LF models\n\t\t// We compensate for offset errors in `_getMultilineMatchRange`\n\t\tconst text = model.getValueInRange(new Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)), EndOfLinePreference.LF);\n\t\tconst lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n\t\tsearcher.reset(searchStart.column - 1);\n\t\tconst m = searcher.next(text);\n\t\tif (m) {\n\t\t\treturn createFindMatch(\n\t\t\t\tthis._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]),\n\t\t\t\tm,\n\t\t\t\tcaptureMatches\n\t\t\t);\n\t\t}\n\n\t\tif (searchStart.lineNumber !== 1 || searchStart.column !== 1) {\n\t\t\t// Try again from the top\n\t\t\treturn this._doFindNextMatchMultiline(model, new Position(1, 1), searcher, captureMatches);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _doFindNextMatchLineByLine(model: TextModel, searchStart: Position, searcher: Searcher, captureMatches: boolean): FindMatch | null {\n\t\tconst lineCount = model.getLineCount();\n\t\tconst startLineNumber = searchStart.lineNumber;\n\n\t\t// Look in first line\n\t\tconst text = model.getLineContent(startLineNumber);\n\t\tconst r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\n\t\tfor (let i = 1; i <= lineCount; i++) {\n\t\t\tconst lineIndex = (startLineNumber + i - 1) % lineCount;\n\t\t\tconst text = model.getLineContent(lineIndex + 1);\n\t\t\tconst r = this._findFirstMatchInLine(searcher, text, lineIndex + 1, 1, captureMatches);\n\t\t\tif (r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _findFirstMatchInLine(searcher: Searcher, text: string, lineNumber: number, fromColumn: number, captureMatches: boolean): FindMatch | null {\n\t\t// Set regex to search from column\n\t\tsearcher.reset(fromColumn - 1);\n\t\tconst m: RegExpExecArray | null = searcher.next(text);\n\t\tif (m) {\n\t\t\treturn createFindMatch(\n\t\t\t\tnew Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length),\n\t\t\t\tm,\n\t\t\t\tcaptureMatches\n\t\t\t);\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static findPreviousMatch(model: TextModel, searchParams: SearchParams, searchStart: Position, captureMatches: boolean): FindMatch | null {\n\t\tconst searchData = searchParams.parseSearchRequest();\n\t\tif (!searchData) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n\n\t\tif (searchData.regex.multiline) {\n\t\t\treturn this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);\n\t\t}\n\t\treturn this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);\n\t}\n\n\tprivate static _doFindPreviousMatchMultiline(model: TextModel, searchStart: Position, searcher: Searcher, captureMatches: boolean): FindMatch | null {\n\t\tconst matches = this._doFindMatchesMultiline(model, new Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);\n\t\tif (matches.length > 0) {\n\t\t\treturn matches[matches.length - 1];\n\t\t}\n\n\t\tconst lineCount = model.getLineCount();\n\t\tif (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {\n\t\t\t// Try again with all content\n\t\t\treturn this._doFindPreviousMatchMultiline(model, new Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _doFindPreviousMatchLineByLine(model: TextModel, searchStart: Position, searcher: Searcher, captureMatches: boolean): FindMatch | null {\n\t\tconst lineCount = model.getLineCount();\n\t\tconst startLineNumber = searchStart.lineNumber;\n\n\t\t// Look in first line\n\t\tconst text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);\n\t\tconst r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\n\t\tfor (let i = 1; i <= lineCount; i++) {\n\t\t\tconst lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;\n\t\t\tconst text = model.getLineContent(lineIndex + 1);\n\t\t\tconst r = this._findLastMatchInLine(searcher, text, lineIndex + 1, captureMatches);\n\t\t\tif (r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _findLastMatchInLine(searcher: Searcher, text: string, lineNumber: number, captureMatches: boolean): FindMatch | null {\n\t\tlet bestResult: FindMatch | null = null;\n\t\tlet m: RegExpExecArray | null;\n\t\tsearcher.reset(0);\n\t\twhile ((m = searcher.next(text))) {\n\t\t\tbestResult = createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n\t\t}\n\t\treturn bestResult;\n\t}\n}\n\nfunction leftIsWordBounday(wordSeparators: WordCharacterClassifier, text: string, textLength: number, matchStartIndex: number, matchLength: number): boolean {\n\tif (matchStartIndex === 0) {\n\t\t// Match starts at start of string\n\t\treturn true;\n\t}\n\n\tconst charBefore = text.charCodeAt(matchStartIndex - 1);\n\tif (wordSeparators.get(charBefore) !== WordCharacterClass.Regular) {\n\t\t// The character before the match is a word separator\n\t\treturn true;\n\t}\n\n\tif (charBefore === CharCode.CarriageReturn || charBefore === CharCode.LineFeed) {\n\t\t// The character before the match is line break or carriage return.\n\t\treturn true;\n\t}\n\n\tif (matchLength > 0) {\n\t\tconst firstCharInMatch = text.charCodeAt(matchStartIndex);\n\t\tif (wordSeparators.get(firstCharInMatch) !== WordCharacterClass.Regular) {\n\t\t\t// The first character inside the match is a word separator\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nfunction rightIsWordBounday(wordSeparators: WordCharacterClassifier, text: string, textLength: number, matchStartIndex: number, matchLength: number): boolean {\n\tif (matchStartIndex + matchLength === textLength) {\n\t\t// Match ends at end of string\n\t\treturn true;\n\t}\n\n\tconst charAfter = text.charCodeAt(matchStartIndex + matchLength);\n\tif (wordSeparators.get(charAfter) !== WordCharacterClass.Regular) {\n\t\t// The character after the match is a word separator\n\t\treturn true;\n\t}\n\n\tif (charAfter === CharCode.CarriageReturn || charAfter === CharCode.LineFeed) {\n\t\t// The character after the match is line break or carriage return.\n\t\treturn true;\n\t}\n\n\tif (matchLength > 0) {\n\t\tconst lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);\n\t\tif (wordSeparators.get(lastCharInMatch) !== WordCharacterClass.Regular) {\n\t\t\t// The last character in the match is a word separator\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport function isValidMatch(wordSeparators: WordCharacterClassifier, text: string, textLength: number, matchStartIndex: number, matchLength: number): boolean {\n\treturn (\n\t\tleftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength)\n\t\t&& rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength)\n\t);\n}\n\nexport class Searcher {\n\tpublic readonly _wordSeparators: WordCharacterClassifier | null;\n\tprivate readonly _searchRegex: RegExp;\n\tprivate _prevMatchStartIndex: number;\n\tprivate _prevMatchLength: number;\n\n\tconstructor(wordSeparators: WordCharacterClassifier | null, searchRegex: RegExp,) {\n\t\tthis._wordSeparators = wordSeparators;\n\t\tthis._searchRegex = searchRegex;\n\t\tthis._prevMatchStartIndex = -1;\n\t\tthis._prevMatchLength = 0;\n\t}\n\n\tpublic reset(lastIndex: number): void {\n\t\tthis._searchRegex.lastIndex = lastIndex;\n\t\tthis._prevMatchStartIndex = -1;\n\t\tthis._prevMatchLength = 0;\n\t}\n\n\tpublic next(text: string): RegExpExecArray | null {\n\t\tconst textLength = text.length;\n\n\t\tlet m: RegExpExecArray | null;\n\t\tdo {\n\t\t\tif (this._prevMatchStartIndex + this._prevMatchLength === textLength) {\n\t\t\t\t// Reached the end of the line\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tm = this._searchRegex.exec(text);\n\t\t\tif (!m) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst matchStartIndex = m.index;\n\t\t\tconst matchLength = m[0].length;\n\t\t\tif (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {\n\t\t\t\tif (matchLength === 0) {\n\t\t\t\t\t// the search result is an empty string and won't advance `regex.lastIndex`, so `regex.exec` will stuck here\n\t\t\t\t\t// we attempt to recover from that by advancing by two if surrogate pair found and by one otherwise\n\t\t\t\t\tif (strings.getNextCodePoint(text, textLength, this._searchRegex.lastIndex) > 0xFFFF) {\n\t\t\t\t\t\tthis._searchRegex.lastIndex += 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._searchRegex.lastIndex += 1;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// Exit early if the regex matches the same range twice\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tthis._prevMatchStartIndex = matchStartIndex;\n\t\t\tthis._prevMatchLength = matchLength;\n\n\t\t\tif (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {\n\t\t\t\treturn m;\n\t\t\t}\n\n\t\t} while (m);\n\n\t\treturn null;\n\t}\n}\n"],
  "mappings": "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",
  "names": ["text", "r"]
}
