{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/model/textModelSearch.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from \"../../../base/common/charCode.js\";\nimport * as strings from \"../../../base/common/strings.js\";\nimport { Position } from \"../core/position.js\";\nimport { Range } from \"../core/range.js\";\nimport {\n\tWordCharacterClass,\n\ttype WordCharacterClassifier,\n\tgetMapForWordSeparators,\n} from \"../core/wordCharacterClassifier.js\";\nimport { EndOfLinePreference, FindMatch, SearchData } from \"../model.js\";\nimport type { TextModel } from \"./textModel.js\";\n\nconst LIMIT_FIND_COUNT = 999;\n\nexport class SearchParams {\n\tpublic readonly searchString: string;\n\tpublic readonly isRegex: boolean;\n\tpublic readonly matchCase: boolean;\n\tpublic readonly wordSeparators: string | null;\n\n\tconstructor(\n\t\tsearchString: string,\n\t\tisRegex: boolean,\n\t\tmatchCase: boolean,\n\t\twordSeparators: string | null,\n\t) {\n\t\tthis.searchString = searchString;\n\t\tthis.isRegex = isRegex;\n\t\tthis.matchCase = matchCase;\n\t\tthis.wordSeparators = wordSeparators;\n\t}\n\n\tpublic parseSearchRequest(): SearchData | null {\n\t\tif (this.searchString === \"\") {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Try to create a RegExp out of the params\n\t\tlet multiline: boolean;\n\t\tif (this.isRegex) {\n\t\t\tmultiline = isMultilineRegexSource(this.searchString);\n\t\t} else {\n\t\t\tmultiline = this.searchString.indexOf(\"\\n\") >= 0;\n\t\t}\n\n\t\tlet regex: RegExp | null = null;\n\t\ttry {\n\t\t\tregex = strings.createRegExp(this.searchString, this.isRegex, {\n\t\t\t\tmatchCase: this.matchCase,\n\t\t\t\twholeWord: false,\n\t\t\t\tmultiline: multiline,\n\t\t\t\tglobal: true,\n\t\t\t\tunicode: true,\n\t\t\t});\n\t\t} catch (err) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!regex) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet canUseSimpleSearch = !this.isRegex && !multiline;\n\t\tif (\n\t\t\tcanUseSimpleSearch &&\n\t\t\tthis.searchString.toLowerCase() !== this.searchString.toUpperCase()\n\t\t) {\n\t\t\t// casing might make a difference\n\t\t\tcanUseSimpleSearch = this.matchCase;\n\t\t}\n\n\t\treturn new SearchData(\n\t\t\tregex,\n\t\t\tthis.wordSeparators\n\t\t\t\t? getMapForWordSeparators(this.wordSeparators, [])\n\t\t\t\t: null,\n\t\t\tcanUseSimpleSearch ? this.searchString : null,\n\t\t);\n\t}\n}\n\nexport function isMultilineRegexSource(searchString: string): boolean {\n\tif (!searchString || searchString.length === 0) {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0, len = searchString.length; i < len; i++) {\n\t\tconst chCode = searchString.charCodeAt(i);\n\n\t\tif (chCode === CharCode.LineFeed) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (chCode === CharCode.Backslash) {\n\t\t\t// move to next char\n\t\t\ti++;\n\n\t\t\tif (i >= len) {\n\t\t\t\t// string ends with a \\\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst nextChCode = searchString.charCodeAt(i);\n\t\t\tif (\n\t\t\t\tnextChCode === CharCode.n ||\n\t\t\t\tnextChCode === CharCode.r ||\n\t\t\t\tnextChCode === CharCode.W\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport function createFindMatch(\n\trange: Range,\n\trawMatches: RegExpExecArray,\n\tcaptureMatches: boolean,\n): FindMatch {\n\tif (!captureMatches) {\n\t\treturn new FindMatch(range, null);\n\t}\n\tconst matches: string[] = [];\n\tfor (let i = 0, len = rawMatches.length; i < len; i++) {\n\t\tmatches[i] = rawMatches[i];\n\t}\n\treturn new FindMatch(range, matches);\n}\n\nclass LineFeedCounter {\n\tprivate readonly _lineFeedsOffsets: number[];\n\n\tconstructor(text: string) {\n\t\tconst lineFeedsOffsets: number[] = [];\n\t\tlet lineFeedsOffsetsLen = 0;\n\t\tfor (let i = 0, textLen = text.length; i < textLen; i++) {\n\t\t\tif (text.charCodeAt(i) === CharCode.LineFeed) {\n\t\t\t\tlineFeedsOffsets[lineFeedsOffsetsLen++] = i;\n\t\t\t}\n\t\t}\n\t\tthis._lineFeedsOffsets = lineFeedsOffsets;\n\t}\n\n\tpublic findLineFeedCountBeforeOffset(offset: number): number {\n\t\tconst lineFeedsOffsets = this._lineFeedsOffsets;\n\t\tlet min = 0;\n\t\tlet max = lineFeedsOffsets.length - 1;\n\n\t\tif (max === -1) {\n\t\t\t// no line feeds\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (offset <= lineFeedsOffsets[0]) {\n\t\t\t// before first line feed\n\t\t\treturn 0;\n\t\t}\n\n\t\twhile (min < max) {\n\t\t\tconst mid = min + (((max - min) / 2) >> 0);\n\n\t\t\tif (lineFeedsOffsets[mid] >= offset) {\n\t\t\t\tmax = mid - 1;\n\t\t\t} else if (lineFeedsOffsets[mid + 1] >= offset) {\n\t\t\t\t// bingo!\n\t\t\t\tmin = mid;\n\t\t\t\tmax = mid;\n\t\t\t} else {\n\t\t\t\tmin = mid + 1;\n\t\t\t}\n\t\t}\n\t\treturn min + 1;\n\t}\n}\n\nexport class TextModelSearch {\n\tpublic static findMatches(\n\t\tmodel: TextModel,\n\t\tsearchParams: SearchParams,\n\t\tsearchRange: Range,\n\t\tcaptureMatches: boolean,\n\t\tlimitResultCount: number,\n\t): FindMatch[] {\n\t\tconst searchData = searchParams.parseSearchRequest();\n\t\tif (!searchData) {\n\t\t\treturn [];\n\t\t}\n\n\t\tif (searchData.regex.multiline) {\n\t\t\treturn this._doFindMatchesMultiline(\n\t\t\t\tmodel,\n\t\t\t\tsearchRange,\n\t\t\t\tnew Searcher(searchData.wordSeparators, searchData.regex),\n\t\t\t\tcaptureMatches,\n\t\t\t\tlimitResultCount,\n\t\t\t);\n\t\t}\n\t\treturn this._doFindMatchesLineByLine(\n\t\t\tmodel,\n\t\t\tsearchRange,\n\t\t\tsearchData,\n\t\t\tcaptureMatches,\n\t\t\tlimitResultCount,\n\t\t);\n\t}\n\n\t/**\n\t * Multiline search always executes on the lines concatenated with \\n.\n\t * We must therefore compensate for the count of \\n in case the model is CRLF\n\t */\n\tprivate static _getMultilineMatchRange(\n\t\tmodel: TextModel,\n\t\tdeltaOffset: number,\n\t\ttext: string,\n\t\tlfCounter: LineFeedCounter | null,\n\t\tmatchIndex: number,\n\t\tmatch0: string,\n\t): Range {\n\t\tlet startOffset: number;\n\t\tlet lineFeedCountBeforeMatch = 0;\n\t\tif (lfCounter) {\n\t\t\tlineFeedCountBeforeMatch =\n\t\t\t\tlfCounter.findLineFeedCountBeforeOffset(matchIndex);\n\t\t\tstartOffset =\n\t\t\t\tdeltaOffset +\n\t\t\t\tmatchIndex +\n\t\t\t\tlineFeedCountBeforeMatch /* add as many \\r as there were \\n */;\n\t\t} else {\n\t\t\tstartOffset = deltaOffset + matchIndex;\n\t\t}\n\n\t\tlet endOffset: number;\n\t\tif (lfCounter) {\n\t\t\tconst lineFeedCountBeforeEndOfMatch =\n\t\t\t\tlfCounter.findLineFeedCountBeforeOffset(\n\t\t\t\t\tmatchIndex + match0.length,\n\t\t\t\t);\n\t\t\tconst lineFeedCountInMatch =\n\t\t\t\tlineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;\n\t\t\tendOffset =\n\t\t\t\tstartOffset +\n\t\t\t\tmatch0.length +\n\t\t\t\tlineFeedCountInMatch /* add as many \\r as there were \\n */;\n\t\t} else {\n\t\t\tendOffset = startOffset + match0.length;\n\t\t}\n\n\t\tconst startPosition = model.getPositionAt(startOffset);\n\t\tconst endPosition = model.getPositionAt(endOffset);\n\t\treturn new Range(\n\t\t\tstartPosition.lineNumber,\n\t\t\tstartPosition.column,\n\t\t\tendPosition.lineNumber,\n\t\t\tendPosition.column,\n\t\t);\n\t}\n\n\tprivate static _doFindMatchesMultiline(\n\t\tmodel: TextModel,\n\t\tsearchRange: Range,\n\t\tsearcher: Searcher,\n\t\tcaptureMatches: boolean,\n\t\tlimitResultCount: number,\n\t): FindMatch[] {\n\t\tconst deltaOffset = model.getOffsetAt(searchRange.getStartPosition());\n\t\t// We always execute multiline search over the lines joined with \\n\n\t\t// This makes it that \\n will match the EOL for both CRLF and LF models\n\t\t// We compensate for offset errors in `_getMultilineMatchRange`\n\t\tconst text = model.getValueInRange(searchRange, EndOfLinePreference.LF);\n\t\tconst lfCounter =\n\t\t\tmodel.getEOL() === \"\\r\\n\" ? new LineFeedCounter(text) : null;\n\n\t\tconst result: FindMatch[] = [];\n\t\tlet counter = 0;\n\n\t\tlet m: RegExpExecArray | null;\n\t\tsearcher.reset(0);\n\t\twhile ((m = searcher.next(text))) {\n\t\t\tresult[counter++] = createFindMatch(\n\t\t\t\tthis._getMultilineMatchRange(\n\t\t\t\t\tmodel,\n\t\t\t\t\tdeltaOffset,\n\t\t\t\t\ttext,\n\t\t\t\t\tlfCounter,\n\t\t\t\t\tm.index,\n\t\t\t\t\tm[0],\n\t\t\t\t),\n\t\t\t\tm,\n\t\t\t\tcaptureMatches,\n\t\t\t);\n\t\t\tif (counter >= limitResultCount) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate static _doFindMatchesLineByLine(\n\t\tmodel: TextModel,\n\t\tsearchRange: Range,\n\t\tsearchData: SearchData,\n\t\tcaptureMatches: boolean,\n\t\tlimitResultCount: number,\n\t): FindMatch[] {\n\t\tconst result: FindMatch[] = [];\n\t\tlet resultLen = 0;\n\n\t\t// Early case for a search range that starts & stops on the same line number\n\t\tif (searchRange.startLineNumber === searchRange.endLineNumber) {\n\t\t\tconst text = model\n\t\t\t\t.getLineContent(searchRange.startLineNumber)\n\t\t\t\t.substring(\n\t\t\t\t\tsearchRange.startColumn - 1,\n\t\t\t\t\tsearchRange.endColumn - 1,\n\t\t\t\t);\n\t\t\tresultLen = this._findMatchesInLine(\n\t\t\t\tsearchData,\n\t\t\t\ttext,\n\t\t\t\tsearchRange.startLineNumber,\n\t\t\t\tsearchRange.startColumn - 1,\n\t\t\t\tresultLen,\n\t\t\t\tresult,\n\t\t\t\tcaptureMatches,\n\t\t\t\tlimitResultCount,\n\t\t\t);\n\t\t\treturn result;\n\t\t}\n\n\t\t// Collect results from first line\n\t\tconst text = model\n\t\t\t.getLineContent(searchRange.startLineNumber)\n\t\t\t.substring(searchRange.startColumn - 1);\n\t\tresultLen = this._findMatchesInLine(\n\t\t\tsearchData,\n\t\t\ttext,\n\t\t\tsearchRange.startLineNumber,\n\t\t\tsearchRange.startColumn - 1,\n\t\t\tresultLen,\n\t\t\tresult,\n\t\t\tcaptureMatches,\n\t\t\tlimitResultCount,\n\t\t);\n\n\t\t// Collect results from middle lines\n\t\tfor (\n\t\t\tlet lineNumber = searchRange.startLineNumber + 1;\n\t\t\tlineNumber < searchRange.endLineNumber &&\n\t\t\tresultLen < limitResultCount;\n\t\t\tlineNumber++\n\t\t) {\n\t\t\tresultLen = this._findMatchesInLine(\n\t\t\t\tsearchData,\n\t\t\t\tmodel.getLineContent(lineNumber),\n\t\t\t\tlineNumber,\n\t\t\t\t0,\n\t\t\t\tresultLen,\n\t\t\t\tresult,\n\t\t\t\tcaptureMatches,\n\t\t\t\tlimitResultCount,\n\t\t\t);\n\t\t}\n\n\t\t// Collect results from last line\n\t\tif (resultLen < limitResultCount) {\n\t\t\tconst text = model\n\t\t\t\t.getLineContent(searchRange.endLineNumber)\n\t\t\t\t.substring(0, searchRange.endColumn - 1);\n\t\t\tresultLen = this._findMatchesInLine(\n\t\t\t\tsearchData,\n\t\t\t\ttext,\n\t\t\t\tsearchRange.endLineNumber,\n\t\t\t\t0,\n\t\t\t\tresultLen,\n\t\t\t\tresult,\n\t\t\t\tcaptureMatches,\n\t\t\t\tlimitResultCount,\n\t\t\t);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate static _findMatchesInLine(\n\t\tsearchData: SearchData,\n\t\ttext: string,\n\t\tlineNumber: number,\n\t\tdeltaOffset: number,\n\t\tresultLen: number,\n\t\tresult: FindMatch[],\n\t\tcaptureMatches: boolean,\n\t\tlimitResultCount: number,\n\t): number {\n\t\tconst wordSeparators = searchData.wordSeparators;\n\t\tif (!captureMatches && searchData.simpleSearch) {\n\t\t\tconst searchString = searchData.simpleSearch;\n\t\t\tconst searchStringLen = searchString.length;\n\t\t\tconst textLength = text.length;\n\n\t\t\tlet lastMatchIndex = -searchStringLen;\n\t\t\twhile (\n\t\t\t\t(lastMatchIndex = text.indexOf(\n\t\t\t\t\tsearchString,\n\t\t\t\t\tlastMatchIndex + searchStringLen,\n\t\t\t\t)) !== -1\n\t\t\t) {\n\t\t\t\tif (\n\t\t\t\t\t!wordSeparators ||\n\t\t\t\t\tisValidMatch(\n\t\t\t\t\t\twordSeparators,\n\t\t\t\t\t\ttext,\n\t\t\t\t\t\ttextLength,\n\t\t\t\t\t\tlastMatchIndex,\n\t\t\t\t\t\tsearchStringLen,\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tresult[resultLen++] = new FindMatch(\n\t\t\t\t\t\tnew Range(\n\t\t\t\t\t\t\tlineNumber,\n\t\t\t\t\t\t\tlastMatchIndex + 1 + deltaOffset,\n\t\t\t\t\t\t\tlineNumber,\n\t\t\t\t\t\t\tlastMatchIndex + 1 + searchStringLen + deltaOffset,\n\t\t\t\t\t\t),\n\t\t\t\t\t\tnull,\n\t\t\t\t\t);\n\t\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\t\treturn resultLen;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn resultLen;\n\t\t}\n\n\t\tconst searcher = new Searcher(\n\t\t\tsearchData.wordSeparators,\n\t\t\tsearchData.regex,\n\t\t);\n\t\tlet m: RegExpExecArray | null;\n\t\t// Reset regex to search from the beginning\n\t\tsearcher.reset(0);\n\t\tdo {\n\t\t\tm = searcher.next(text);\n\t\t\tif (m) {\n\t\t\t\tresult[resultLen++] = createFindMatch(\n\t\t\t\t\tnew Range(\n\t\t\t\t\t\tlineNumber,\n\t\t\t\t\t\tm.index + 1 + deltaOffset,\n\t\t\t\t\t\tlineNumber,\n\t\t\t\t\t\tm.index + 1 + m[0].length + deltaOffset,\n\t\t\t\t\t),\n\t\t\t\t\tm,\n\t\t\t\t\tcaptureMatches,\n\t\t\t\t);\n\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\treturn resultLen;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (m);\n\t\treturn resultLen;\n\t}\n\n\tpublic static findNextMatch(\n\t\tmodel: TextModel,\n\t\tsearchParams: SearchParams,\n\t\tsearchStart: Position,\n\t\tcaptureMatches: boolean,\n\t): FindMatch | null {\n\t\tconst searchData = searchParams.parseSearchRequest();\n\t\tif (!searchData) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst searcher = new Searcher(\n\t\t\tsearchData.wordSeparators,\n\t\t\tsearchData.regex,\n\t\t);\n\n\t\tif (searchData.regex.multiline) {\n\t\t\treturn this._doFindNextMatchMultiline(\n\t\t\t\tmodel,\n\t\t\t\tsearchStart,\n\t\t\t\tsearcher,\n\t\t\t\tcaptureMatches,\n\t\t\t);\n\t\t}\n\t\treturn this._doFindNextMatchLineByLine(\n\t\t\tmodel,\n\t\t\tsearchStart,\n\t\t\tsearcher,\n\t\t\tcaptureMatches,\n\t\t);\n\t}\n\n\tprivate static _doFindNextMatchMultiline(\n\t\tmodel: TextModel,\n\t\tsearchStart: Position,\n\t\tsearcher: Searcher,\n\t\tcaptureMatches: boolean,\n\t): FindMatch | null {\n\t\tconst searchTextStart = new Position(searchStart.lineNumber, 1);\n\t\tconst deltaOffset = model.getOffsetAt(searchTextStart);\n\t\tconst lineCount = model.getLineCount();\n\t\t// We always execute multiline search over the lines joined with \\n\n\t\t// This makes it that \\n will match the EOL for both CRLF and LF models\n\t\t// We compensate for offset errors in `_getMultilineMatchRange`\n\t\tconst text = model.getValueInRange(\n\t\t\tnew Range(\n\t\t\t\tsearchTextStart.lineNumber,\n\t\t\t\tsearchTextStart.column,\n\t\t\t\tlineCount,\n\t\t\t\tmodel.getLineMaxColumn(lineCount),\n\t\t\t),\n\t\t\tEndOfLinePreference.LF,\n\t\t);\n\t\tconst lfCounter =\n\t\t\tmodel.getEOL() === \"\\r\\n\" ? new LineFeedCounter(text) : null;\n\t\tsearcher.reset(searchStart.column - 1);\n\t\tconst m = searcher.next(text);\n\t\tif (m) {\n\t\t\treturn createFindMatch(\n\t\t\t\tthis._getMultilineMatchRange(\n\t\t\t\t\tmodel,\n\t\t\t\t\tdeltaOffset,\n\t\t\t\t\ttext,\n\t\t\t\t\tlfCounter,\n\t\t\t\t\tm.index,\n\t\t\t\t\tm[0],\n\t\t\t\t),\n\t\t\t\tm,\n\t\t\t\tcaptureMatches,\n\t\t\t);\n\t\t}\n\n\t\tif (searchStart.lineNumber !== 1 || searchStart.column !== 1) {\n\t\t\t// Try again from the top\n\t\t\treturn this._doFindNextMatchMultiline(\n\t\t\t\tmodel,\n\t\t\t\tnew Position(1, 1),\n\t\t\t\tsearcher,\n\t\t\t\tcaptureMatches,\n\t\t\t);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _doFindNextMatchLineByLine(\n\t\tmodel: TextModel,\n\t\tsearchStart: Position,\n\t\tsearcher: Searcher,\n\t\tcaptureMatches: boolean,\n\t): FindMatch | null {\n\t\tconst lineCount = model.getLineCount();\n\t\tconst startLineNumber = searchStart.lineNumber;\n\n\t\t// Look in first line\n\t\tconst text = model.getLineContent(startLineNumber);\n\t\tconst r = this._findFirstMatchInLine(\n\t\t\tsearcher,\n\t\t\ttext,\n\t\t\tstartLineNumber,\n\t\t\tsearchStart.column,\n\t\t\tcaptureMatches,\n\t\t);\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\n\t\tfor (let i = 1; i <= lineCount; i++) {\n\t\t\tconst lineIndex = (startLineNumber + i - 1) % lineCount;\n\t\t\tconst text = model.getLineContent(lineIndex + 1);\n\t\t\tconst r = this._findFirstMatchInLine(\n\t\t\t\tsearcher,\n\t\t\t\ttext,\n\t\t\t\tlineIndex + 1,\n\t\t\t\t1,\n\t\t\t\tcaptureMatches,\n\t\t\t);\n\t\t\tif (r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _findFirstMatchInLine(\n\t\tsearcher: Searcher,\n\t\ttext: string,\n\t\tlineNumber: number,\n\t\tfromColumn: number,\n\t\tcaptureMatches: boolean,\n\t): FindMatch | null {\n\t\t// Set regex to search from column\n\t\tsearcher.reset(fromColumn - 1);\n\t\tconst m: RegExpExecArray | null = searcher.next(text);\n\t\tif (m) {\n\t\t\treturn createFindMatch(\n\t\t\t\tnew Range(\n\t\t\t\t\tlineNumber,\n\t\t\t\t\tm.index + 1,\n\t\t\t\t\tlineNumber,\n\t\t\t\t\tm.index + 1 + m[0].length,\n\t\t\t\t),\n\t\t\t\tm,\n\t\t\t\tcaptureMatches,\n\t\t\t);\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static findPreviousMatch(\n\t\tmodel: TextModel,\n\t\tsearchParams: SearchParams,\n\t\tsearchStart: Position,\n\t\tcaptureMatches: boolean,\n\t): FindMatch | null {\n\t\tconst searchData = searchParams.parseSearchRequest();\n\t\tif (!searchData) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst searcher = new Searcher(\n\t\t\tsearchData.wordSeparators,\n\t\t\tsearchData.regex,\n\t\t);\n\n\t\tif (searchData.regex.multiline) {\n\t\t\treturn this._doFindPreviousMatchMultiline(\n\t\t\t\tmodel,\n\t\t\t\tsearchStart,\n\t\t\t\tsearcher,\n\t\t\t\tcaptureMatches,\n\t\t\t);\n\t\t}\n\t\treturn this._doFindPreviousMatchLineByLine(\n\t\t\tmodel,\n\t\t\tsearchStart,\n\t\t\tsearcher,\n\t\t\tcaptureMatches,\n\t\t);\n\t}\n\n\tprivate static _doFindPreviousMatchMultiline(\n\t\tmodel: TextModel,\n\t\tsearchStart: Position,\n\t\tsearcher: Searcher,\n\t\tcaptureMatches: boolean,\n\t): FindMatch | null {\n\t\tconst matches = this._doFindMatchesMultiline(\n\t\t\tmodel,\n\t\t\tnew Range(1, 1, searchStart.lineNumber, searchStart.column),\n\t\t\tsearcher,\n\t\t\tcaptureMatches,\n\t\t\t10 * LIMIT_FIND_COUNT,\n\t\t);\n\t\tif (matches.length > 0) {\n\t\t\treturn matches[matches.length - 1];\n\t\t}\n\n\t\tconst lineCount = model.getLineCount();\n\t\tif (\n\t\t\tsearchStart.lineNumber !== lineCount ||\n\t\t\tsearchStart.column !== model.getLineMaxColumn(lineCount)\n\t\t) {\n\t\t\t// Try again with all content\n\t\t\treturn this._doFindPreviousMatchMultiline(\n\t\t\t\tmodel,\n\t\t\t\tnew Position(lineCount, model.getLineMaxColumn(lineCount)),\n\t\t\t\tsearcher,\n\t\t\t\tcaptureMatches,\n\t\t\t);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _doFindPreviousMatchLineByLine(\n\t\tmodel: TextModel,\n\t\tsearchStart: Position,\n\t\tsearcher: Searcher,\n\t\tcaptureMatches: boolean,\n\t): FindMatch | null {\n\t\tconst lineCount = model.getLineCount();\n\t\tconst startLineNumber = searchStart.lineNumber;\n\n\t\t// Look in first line\n\t\tconst text = model\n\t\t\t.getLineContent(startLineNumber)\n\t\t\t.substring(0, searchStart.column - 1);\n\t\tconst r = this._findLastMatchInLine(\n\t\t\tsearcher,\n\t\t\ttext,\n\t\t\tstartLineNumber,\n\t\t\tcaptureMatches,\n\t\t);\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\n\t\tfor (let i = 1; i <= lineCount; i++) {\n\t\t\tconst lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;\n\t\t\tconst text = model.getLineContent(lineIndex + 1);\n\t\t\tconst r = this._findLastMatchInLine(\n\t\t\t\tsearcher,\n\t\t\t\ttext,\n\t\t\t\tlineIndex + 1,\n\t\t\t\tcaptureMatches,\n\t\t\t);\n\t\t\tif (r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _findLastMatchInLine(\n\t\tsearcher: Searcher,\n\t\ttext: string,\n\t\tlineNumber: number,\n\t\tcaptureMatches: boolean,\n\t): FindMatch | null {\n\t\tlet bestResult: FindMatch | null = null;\n\t\tlet m: RegExpExecArray | null;\n\t\tsearcher.reset(0);\n\t\twhile ((m = searcher.next(text))) {\n\t\t\tbestResult = createFindMatch(\n\t\t\t\tnew Range(\n\t\t\t\t\tlineNumber,\n\t\t\t\t\tm.index + 1,\n\t\t\t\t\tlineNumber,\n\t\t\t\t\tm.index + 1 + m[0].length,\n\t\t\t\t),\n\t\t\t\tm,\n\t\t\t\tcaptureMatches,\n\t\t\t);\n\t\t}\n\t\treturn bestResult;\n\t}\n}\n\nfunction leftIsWordBounday(\n\twordSeparators: WordCharacterClassifier,\n\ttext: string,\n\ttextLength: number,\n\tmatchStartIndex: number,\n\tmatchLength: number,\n): boolean {\n\tif (matchStartIndex === 0) {\n\t\t// Match starts at start of string\n\t\treturn true;\n\t}\n\n\tconst charBefore = text.charCodeAt(matchStartIndex - 1);\n\tif (wordSeparators.get(charBefore) !== WordCharacterClass.Regular) {\n\t\t// The character before the match is a word separator\n\t\treturn true;\n\t}\n\n\tif (\n\t\tcharBefore === CharCode.CarriageReturn ||\n\t\tcharBefore === CharCode.LineFeed\n\t) {\n\t\t// The character before the match is line break or carriage return.\n\t\treturn true;\n\t}\n\n\tif (matchLength > 0) {\n\t\tconst firstCharInMatch = text.charCodeAt(matchStartIndex);\n\t\tif (\n\t\t\twordSeparators.get(firstCharInMatch) !== WordCharacterClass.Regular\n\t\t) {\n\t\t\t// The first character inside the match is a word separator\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nfunction rightIsWordBounday(\n\twordSeparators: WordCharacterClassifier,\n\ttext: string,\n\ttextLength: number,\n\tmatchStartIndex: number,\n\tmatchLength: number,\n): boolean {\n\tif (matchStartIndex + matchLength === textLength) {\n\t\t// Match ends at end of string\n\t\treturn true;\n\t}\n\n\tconst charAfter = text.charCodeAt(matchStartIndex + matchLength);\n\tif (wordSeparators.get(charAfter) !== WordCharacterClass.Regular) {\n\t\t// The character after the match is a word separator\n\t\treturn true;\n\t}\n\n\tif (\n\t\tcharAfter === CharCode.CarriageReturn ||\n\t\tcharAfter === CharCode.LineFeed\n\t) {\n\t\t// The character after the match is line break or carriage return.\n\t\treturn true;\n\t}\n\n\tif (matchLength > 0) {\n\t\tconst lastCharInMatch = text.charCodeAt(\n\t\t\tmatchStartIndex + matchLength - 1,\n\t\t);\n\t\tif (\n\t\t\twordSeparators.get(lastCharInMatch) !== WordCharacterClass.Regular\n\t\t) {\n\t\t\t// The last character in the match is a word separator\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport function isValidMatch(\n\twordSeparators: WordCharacterClassifier,\n\ttext: string,\n\ttextLength: number,\n\tmatchStartIndex: number,\n\tmatchLength: number,\n): boolean {\n\treturn (\n\t\tleftIsWordBounday(\n\t\t\twordSeparators,\n\t\t\ttext,\n\t\t\ttextLength,\n\t\t\tmatchStartIndex,\n\t\t\tmatchLength,\n\t\t) &&\n\t\trightIsWordBounday(\n\t\t\twordSeparators,\n\t\t\ttext,\n\t\t\ttextLength,\n\t\t\tmatchStartIndex,\n\t\t\tmatchLength,\n\t\t)\n\t);\n}\n\nexport class Searcher {\n\tpublic readonly _wordSeparators: WordCharacterClassifier | null;\n\tprivate readonly _searchRegex: RegExp;\n\tprivate _prevMatchStartIndex: number;\n\tprivate _prevMatchLength: number;\n\n\tconstructor(\n\t\twordSeparators: WordCharacterClassifier | null,\n\t\tsearchRegex: RegExp,\n\t) {\n\t\tthis._wordSeparators = wordSeparators;\n\t\tthis._searchRegex = searchRegex;\n\t\tthis._prevMatchStartIndex = -1;\n\t\tthis._prevMatchLength = 0;\n\t}\n\n\tpublic reset(lastIndex: number): void {\n\t\tthis._searchRegex.lastIndex = lastIndex;\n\t\tthis._prevMatchStartIndex = -1;\n\t\tthis._prevMatchLength = 0;\n\t}\n\n\tpublic next(text: string): RegExpExecArray | null {\n\t\tconst textLength = text.length;\n\n\t\tlet m: RegExpExecArray | null;\n\t\tdo {\n\t\t\tif (\n\t\t\t\tthis._prevMatchStartIndex + this._prevMatchLength ===\n\t\t\t\ttextLength\n\t\t\t) {\n\t\t\t\t// Reached the end of the line\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tm = this._searchRegex.exec(text);\n\t\t\tif (!m) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst matchStartIndex = m.index;\n\t\t\tconst matchLength = m[0].length;\n\t\t\tif (\n\t\t\t\tmatchStartIndex === this._prevMatchStartIndex &&\n\t\t\t\tmatchLength === this._prevMatchLength\n\t\t\t) {\n\t\t\t\tif (matchLength === 0) {\n\t\t\t\t\t// the search result is an empty string and won't advance `regex.lastIndex`, so `regex.exec` will stuck here\n\t\t\t\t\t// we attempt to recover from that by advancing by two if surrogate pair found and by one otherwise\n\t\t\t\t\tif (\n\t\t\t\t\t\tstrings.getNextCodePoint(\n\t\t\t\t\t\t\ttext,\n\t\t\t\t\t\t\ttextLength,\n\t\t\t\t\t\t\tthis._searchRegex.lastIndex,\n\t\t\t\t\t\t) > 0xffff\n\t\t\t\t\t) {\n\t\t\t\t\t\tthis._searchRegex.lastIndex += 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._searchRegex.lastIndex += 1;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// Exit early if the regex matches the same range twice\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tthis._prevMatchStartIndex = matchStartIndex;\n\t\t\tthis._prevMatchLength = matchLength;\n\n\t\t\tif (\n\t\t\t\t!this._wordSeparators ||\n\t\t\t\tisValidMatch(\n\t\t\t\t\tthis._wordSeparators,\n\t\t\t\t\ttext,\n\t\t\t\t\ttextLength,\n\t\t\t\t\tmatchStartIndex,\n\t\t\t\t\tmatchLength,\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\treturn m;\n\t\t\t}\n\t\t} while (m);\n\n\t\treturn null;\n\t}\n}\n"],
  "mappings": "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",
  "names": ["text", "r"]
}
