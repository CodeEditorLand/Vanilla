{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/model/textModelTokens.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport {\n\ttype IdleDeadline,\n\trunWhenGlobalIdle,\n} from \"../../../base/common/async.js\";\nimport {\n\tBugIndicatingError,\n\tonUnexpectedError,\n} from \"../../../base/common/errors.js\";\nimport { setTimeout0 } from \"../../../base/common/platform.js\";\nimport { StopWatch } from \"../../../base/common/stopwatch.js\";\nimport { countEOL } from \"../core/eolCounter.js\";\nimport { LineRange } from \"../core/lineRange.js\";\nimport { OffsetRange } from \"../core/offsetRange.js\";\nimport type { Position } from \"../core/position.js\";\nimport { StandardTokenType } from \"../encodedTokenAttributes.js\";\nimport type {\n\tEncodedTokenizationResult,\n\tIBackgroundTokenizationStore,\n\tIBackgroundTokenizer,\n\tILanguageIdCodec,\n\tIState,\n\tITokenizationSupport,\n} from \"../languages.js\";\nimport { nullTokenizeEncoded } from \"../languages/nullTokenize.js\";\nimport type { ITextModel } from \"../model.js\";\nimport type { IModelContentChange } from \"../textModelEvents.js\";\nimport type {\n\tITokenizeLineWithEditResult,\n\tLineEditWithAdditionalLines,\n} from \"../tokenizationTextModelPart.js\";\nimport { ContiguousMultilineTokensBuilder } from \"../tokens/contiguousMultilineTokensBuilder.js\";\nimport { LineTokens } from \"../tokens/lineTokens.js\";\nimport { FixedArray } from \"./fixedArray.js\";\n\nenum Constants {\n\tCHEAP_TOKENIZATION_LENGTH_LIMIT = 2048,\n}\n\nexport class TokenizerWithStateStore<TState extends IState = IState> {\n\tprivate readonly initialState =\n\t\tthis.tokenizationSupport.getInitialState() as TState;\n\n\tpublic readonly store: TrackingTokenizationStateStore<TState>;\n\n\tconstructor(\n\t\tlineCount: number,\n\t\tpublic readonly tokenizationSupport: ITokenizationSupport,\n\t) {\n\t\tthis.store = new TrackingTokenizationStateStore<TState>(lineCount);\n\t}\n\n\tpublic getStartState(lineNumber: number): TState | null {\n\t\treturn this.store.getStartState(lineNumber, this.initialState);\n\t}\n\n\tpublic getFirstInvalidLine(): {\n\t\tlineNumber: number;\n\t\tstartState: TState;\n\t} | null {\n\t\treturn this.store.getFirstInvalidLine(this.initialState);\n\t}\n}\n\nexport class TokenizerWithStateStoreAndTextModel<\n\tTState extends IState = IState,\n> extends TokenizerWithStateStore<TState> {\n\tconstructor(\n\t\tlineCount: number,\n\t\ttokenizationSupport: ITokenizationSupport,\n\t\tpublic readonly _textModel: ITextModel,\n\t\tpublic readonly _languageIdCodec: ILanguageIdCodec,\n\t) {\n\t\tsuper(lineCount, tokenizationSupport);\n\t}\n\n\tpublic updateTokensUntilLine(\n\t\tbuilder: ContiguousMultilineTokensBuilder,\n\t\tlineNumber: number,\n\t): void {\n\t\tconst languageId = this._textModel.getLanguageId();\n\n\t\twhile (true) {\n\t\t\tconst lineToTokenize = this.getFirstInvalidLine();\n\t\t\tif (!lineToTokenize || lineToTokenize.lineNumber > lineNumber) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst text = this._textModel.getLineContent(\n\t\t\t\tlineToTokenize.lineNumber,\n\t\t\t);\n\n\t\t\tconst r = safeTokenize(\n\t\t\t\tthis._languageIdCodec,\n\t\t\t\tlanguageId,\n\t\t\t\tthis.tokenizationSupport,\n\t\t\t\ttext,\n\t\t\t\ttrue,\n\t\t\t\tlineToTokenize.startState,\n\t\t\t);\n\t\t\tbuilder.add(lineToTokenize.lineNumber, r.tokens);\n\t\t\tthis.store.setEndState(\n\t\t\t\tlineToTokenize.lineNumber,\n\t\t\t\tr.endState as TState,\n\t\t\t);\n\t\t}\n\t}\n\n\t/** assumes state is up to date */\n\tpublic getTokenTypeIfInsertingCharacter(\n\t\tposition: Position,\n\t\tcharacter: string,\n\t): StandardTokenType {\n\t\t// TODO@hediet: use tokenizeLineWithEdit\n\t\tconst lineStartState = this.getStartState(position.lineNumber);\n\t\tif (!lineStartState) {\n\t\t\treturn StandardTokenType.Other;\n\t\t}\n\n\t\tconst languageId = this._textModel.getLanguageId();\n\t\tconst lineContent = this._textModel.getLineContent(position.lineNumber);\n\n\t\t// Create the text as if `character` was inserted\n\t\tconst text =\n\t\t\tlineContent.substring(0, position.column - 1) +\n\t\t\tcharacter +\n\t\t\tlineContent.substring(position.column - 1);\n\n\t\tconst r = safeTokenize(\n\t\t\tthis._languageIdCodec,\n\t\t\tlanguageId,\n\t\t\tthis.tokenizationSupport,\n\t\t\ttext,\n\t\t\ttrue,\n\t\t\tlineStartState,\n\t\t);\n\t\tconst lineTokens = new LineTokens(\n\t\t\tr.tokens,\n\t\t\ttext,\n\t\t\tthis._languageIdCodec,\n\t\t);\n\t\tif (lineTokens.getCount() === 0) {\n\t\t\treturn StandardTokenType.Other;\n\t\t}\n\n\t\tconst tokenIndex = lineTokens.findTokenIndexAtOffset(\n\t\t\tposition.column - 1,\n\t\t);\n\t\treturn lineTokens.getStandardTokenType(tokenIndex);\n\t}\n\n\t/** assumes state is up to date */\n\tpublic tokenizeLineWithEdit(\n\t\tlineNumber: number,\n\t\tedit: LineEditWithAdditionalLines,\n\t): ITokenizeLineWithEditResult {\n\t\tconst lineStartState = this.getStartState(lineNumber);\n\t\tif (!lineStartState) {\n\t\t\treturn { mainLineTokens: null, additionalLines: null };\n\t\t}\n\n\t\tconst curLineContent = this._textModel.getLineContent(lineNumber);\n\t\tconst newLineContent = edit.lineEdit.apply(curLineContent);\n\n\t\tconst languageId = this._textModel.getLanguageIdAtPosition(\n\t\t\tlineNumber,\n\t\t\t0,\n\t\t);\n\t\tconst result = safeTokenize(\n\t\t\tthis._languageIdCodec,\n\t\t\tlanguageId,\n\t\t\tthis.tokenizationSupport,\n\t\t\tnewLineContent,\n\t\t\ttrue,\n\t\t\tlineStartState,\n\t\t);\n\n\t\tlet additionalLines: LineTokens[] | null = null;\n\t\tif (edit.additionalLines) {\n\t\t\tadditionalLines = [];\n\t\t\tlet state = result.endState;\n\t\t\tfor (const line of edit.additionalLines) {\n\t\t\t\tconst r = safeTokenize(\n\t\t\t\t\tthis._languageIdCodec,\n\t\t\t\t\tlanguageId,\n\t\t\t\t\tthis.tokenizationSupport,\n\t\t\t\t\tline,\n\t\t\t\t\ttrue,\n\t\t\t\t\tstate,\n\t\t\t\t);\n\t\t\t\tadditionalLines.push(\n\t\t\t\t\tnew LineTokens(r.tokens, line, this._languageIdCodec),\n\t\t\t\t);\n\t\t\t\tstate = r.endState;\n\t\t\t}\n\t\t}\n\n\t\tconst mainLineTokens = new LineTokens(\n\t\t\tresult.tokens,\n\t\t\tnewLineContent,\n\t\t\tthis._languageIdCodec,\n\t\t);\n\t\treturn { mainLineTokens, additionalLines };\n\t}\n\n\tpublic hasAccurateTokensForLine(lineNumber: number): boolean {\n\t\tconst firstInvalidLineNumber =\n\t\t\tthis.store.getFirstInvalidEndStateLineNumberOrMax();\n\t\treturn lineNumber < firstInvalidLineNumber;\n\t}\n\n\tpublic isCheapToTokenize(lineNumber: number): boolean {\n\t\tconst firstInvalidLineNumber =\n\t\t\tthis.store.getFirstInvalidEndStateLineNumberOrMax();\n\t\tif (lineNumber < firstInvalidLineNumber) {\n\t\t\treturn true;\n\t\t}\n\t\tif (\n\t\t\tlineNumber === firstInvalidLineNumber &&\n\t\t\tthis._textModel.getLineLength(lineNumber) <\n\t\t\t\tConstants.CHEAP_TOKENIZATION_LENGTH_LIMIT\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * The result is not cached.\n\t */\n\tpublic tokenizeHeuristically(\n\t\tbuilder: ContiguousMultilineTokensBuilder,\n\t\tstartLineNumber: number,\n\t\tendLineNumber: number,\n\t): { heuristicTokens: boolean } {\n\t\tif (\n\t\t\tendLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()\n\t\t) {\n\t\t\t// nothing to do\n\t\t\treturn { heuristicTokens: false };\n\t\t}\n\n\t\tif (\n\t\t\tstartLineNumber <=\n\t\t\tthis.store.getFirstInvalidEndStateLineNumberOrMax()\n\t\t) {\n\t\t\t// tokenization has reached the viewport start...\n\t\t\tthis.updateTokensUntilLine(builder, endLineNumber);\n\t\t\treturn { heuristicTokens: false };\n\t\t}\n\n\t\tlet state = this.guessStartState(startLineNumber);\n\t\tconst languageId = this._textModel.getLanguageId();\n\n\t\tfor (\n\t\t\tlet lineNumber = startLineNumber;\n\t\t\tlineNumber <= endLineNumber;\n\t\t\tlineNumber++\n\t\t) {\n\t\t\tconst text = this._textModel.getLineContent(lineNumber);\n\t\t\tconst r = safeTokenize(\n\t\t\t\tthis._languageIdCodec,\n\t\t\t\tlanguageId,\n\t\t\t\tthis.tokenizationSupport,\n\t\t\t\ttext,\n\t\t\t\ttrue,\n\t\t\t\tstate,\n\t\t\t);\n\t\t\tbuilder.add(lineNumber, r.tokens);\n\t\t\tstate = r.endState;\n\t\t}\n\n\t\treturn { heuristicTokens: true };\n\t}\n\n\tprivate guessStartState(lineNumber: number): IState {\n\t\tlet nonWhitespaceColumn =\n\t\t\tthis._textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n\t\tconst likelyRelevantLines: string[] = [];\n\t\tlet initialState: IState | null = null;\n\t\tfor (let i = lineNumber - 1; nonWhitespaceColumn > 1 && i >= 1; i--) {\n\t\t\tconst newNonWhitespaceIndex =\n\t\t\t\tthis._textModel.getLineFirstNonWhitespaceColumn(i);\n\t\t\t// Ignore lines full of whitespace\n\t\t\tif (newNonWhitespaceIndex === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (newNonWhitespaceIndex < nonWhitespaceColumn) {\n\t\t\t\tlikelyRelevantLines.push(this._textModel.getLineContent(i));\n\t\t\t\tnonWhitespaceColumn = newNonWhitespaceIndex;\n\t\t\t\tinitialState = this.getStartState(i);\n\t\t\t\tif (initialState) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!initialState) {\n\t\t\tinitialState = this.tokenizationSupport.getInitialState();\n\t\t}\n\t\tlikelyRelevantLines.reverse();\n\n\t\tconst languageId = this._textModel.getLanguageId();\n\t\tlet state = initialState;\n\t\tfor (const line of likelyRelevantLines) {\n\t\t\tconst r = safeTokenize(\n\t\t\t\tthis._languageIdCodec,\n\t\t\t\tlanguageId,\n\t\t\t\tthis.tokenizationSupport,\n\t\t\t\tline,\n\t\t\t\tfalse,\n\t\t\t\tstate,\n\t\t\t);\n\t\t\tstate = r.endState;\n\t\t}\n\t\treturn state;\n\t}\n}\n\n/**\n * **Invariant:**\n * If the text model is retokenized from line 1 to {@link getFirstInvalidEndStateLineNumber}() - 1,\n * then the recomputed end state for line l will be equal to {@link getEndState}(l).\n */\nexport class TrackingTokenizationStateStore<TState extends IState> {\n\tprivate readonly _tokenizationStateStore =\n\t\tnew TokenizationStateStore<TState>();\n\tprivate readonly _invalidEndStatesLineNumbers =\n\t\tnew RangePriorityQueueImpl();\n\n\tconstructor(private lineCount: number) {\n\t\tthis._invalidEndStatesLineNumbers.addRange(\n\t\t\tnew OffsetRange(1, lineCount + 1),\n\t\t);\n\t}\n\n\tpublic getEndState(lineNumber: number): TState | null {\n\t\treturn this._tokenizationStateStore.getEndState(lineNumber);\n\t}\n\n\t/**\n\t * @returns if the end state has changed.\n\t */\n\tpublic setEndState(lineNumber: number, state: TState): boolean {\n\t\tif (!state) {\n\t\t\tthrow new BugIndicatingError(\"Cannot set null/undefined state\");\n\t\t}\n\n\t\tthis._invalidEndStatesLineNumbers.delete(lineNumber);\n\t\tconst r = this._tokenizationStateStore.setEndState(lineNumber, state);\n\t\tif (r && lineNumber < this.lineCount) {\n\t\t\t// because the state changed, we cannot trust the next state anymore and have to invalidate it.\n\t\t\tthis._invalidEndStatesLineNumbers.addRange(\n\t\t\t\tnew OffsetRange(lineNumber + 1, lineNumber + 2),\n\t\t\t);\n\t\t}\n\n\t\treturn r;\n\t}\n\n\tpublic acceptChange(range: LineRange, newLineCount: number): void {\n\t\tthis.lineCount += newLineCount - range.length;\n\t\tthis._tokenizationStateStore.acceptChange(range, newLineCount);\n\t\tthis._invalidEndStatesLineNumbers.addRangeAndResize(\n\t\t\tnew OffsetRange(\n\t\t\t\trange.startLineNumber,\n\t\t\t\trange.endLineNumberExclusive,\n\t\t\t),\n\t\t\tnewLineCount,\n\t\t);\n\t}\n\n\tpublic acceptChanges(changes: IModelContentChange[]) {\n\t\tfor (const c of changes) {\n\t\t\tconst [eolCount] = countEOL(c.text);\n\t\t\tthis.acceptChange(\n\t\t\t\tnew LineRange(\n\t\t\t\t\tc.range.startLineNumber,\n\t\t\t\t\tc.range.endLineNumber + 1,\n\t\t\t\t),\n\t\t\t\teolCount + 1,\n\t\t\t);\n\t\t}\n\t}\n\n\tpublic invalidateEndStateRange(range: LineRange): void {\n\t\tthis._invalidEndStatesLineNumbers.addRange(\n\t\t\tnew OffsetRange(\n\t\t\t\trange.startLineNumber,\n\t\t\t\trange.endLineNumberExclusive,\n\t\t\t),\n\t\t);\n\t}\n\n\tpublic getFirstInvalidEndStateLineNumber(): number | null {\n\t\treturn this._invalidEndStatesLineNumbers.min;\n\t}\n\n\tpublic getFirstInvalidEndStateLineNumberOrMax(): number {\n\t\treturn (\n\t\t\tthis.getFirstInvalidEndStateLineNumber() || Number.MAX_SAFE_INTEGER\n\t\t);\n\t}\n\n\tpublic allStatesValid(): boolean {\n\t\treturn this._invalidEndStatesLineNumbers.min === null;\n\t}\n\n\tpublic getStartState(\n\t\tlineNumber: number,\n\t\tinitialState: TState,\n\t): TState | null {\n\t\tif (lineNumber === 1) {\n\t\t\treturn initialState;\n\t\t}\n\t\treturn this.getEndState(lineNumber - 1);\n\t}\n\n\tpublic getFirstInvalidLine(\n\t\tinitialState: TState,\n\t): { lineNumber: number; startState: TState } | null {\n\t\tconst lineNumber = this.getFirstInvalidEndStateLineNumber();\n\t\tif (lineNumber === null) {\n\t\t\treturn null;\n\t\t}\n\t\tconst startState = this.getStartState(lineNumber, initialState);\n\t\tif (!startState) {\n\t\t\tthrow new BugIndicatingError(\"Start state must be defined\");\n\t\t}\n\n\t\treturn { lineNumber, startState };\n\t}\n}\n\nexport class TokenizationStateStore<TState extends IState> {\n\tprivate readonly _lineEndStates = new FixedArray<TState | null>(null);\n\n\tpublic getEndState(lineNumber: number): TState | null {\n\t\treturn this._lineEndStates.get(lineNumber);\n\t}\n\n\tpublic setEndState(lineNumber: number, state: TState): boolean {\n\t\tconst oldState = this._lineEndStates.get(lineNumber);\n\t\tif (oldState && oldState.equals(state)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._lineEndStates.set(lineNumber, state);\n\t\treturn true;\n\t}\n\n\tpublic acceptChange(range: LineRange, newLineCount: number): void {\n\t\tlet length = range.length;\n\t\tif (newLineCount > 0 && length > 0) {\n\t\t\t// Keep the last state, even though it is unrelated.\n\t\t\t// But if the new state happens to agree with this last state, then we know we can stop tokenizing.\n\t\t\tlength--;\n\t\t\tnewLineCount--;\n\t\t}\n\n\t\tthis._lineEndStates.replace(\n\t\t\trange.startLineNumber,\n\t\t\tlength,\n\t\t\tnewLineCount,\n\t\t);\n\t}\n\n\tpublic acceptChanges(changes: IModelContentChange[]) {\n\t\tfor (const c of changes) {\n\t\t\tconst [eolCount] = countEOL(c.text);\n\t\t\tthis.acceptChange(\n\t\t\t\tnew LineRange(\n\t\t\t\t\tc.range.startLineNumber,\n\t\t\t\t\tc.range.endLineNumber + 1,\n\t\t\t\t),\n\t\t\t\teolCount + 1,\n\t\t\t);\n\t\t}\n\t}\n}\n\ninterface RangePriorityQueue {\n\tget min(): number | null;\n\tremoveMin(): number | null;\n\n\taddRange(range: OffsetRange): void;\n\n\taddRangeAndResize(range: OffsetRange, newLength: number): void;\n}\n\nexport class RangePriorityQueueImpl implements RangePriorityQueue {\n\tprivate readonly _ranges: OffsetRange[] = [];\n\n\tpublic getRanges(): OffsetRange[] {\n\t\treturn this._ranges;\n\t}\n\n\tpublic get min(): number | null {\n\t\tif (this._ranges.length === 0) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this._ranges[0].start;\n\t}\n\n\tpublic removeMin(): number | null {\n\t\tif (this._ranges.length === 0) {\n\t\t\treturn null;\n\t\t}\n\t\tconst range = this._ranges[0];\n\t\tif (range.start + 1 === range.endExclusive) {\n\t\t\tthis._ranges.shift();\n\t\t} else {\n\t\t\tthis._ranges[0] = new OffsetRange(\n\t\t\t\trange.start + 1,\n\t\t\t\trange.endExclusive,\n\t\t\t);\n\t\t}\n\t\treturn range.start;\n\t}\n\n\tpublic delete(value: number): void {\n\t\tconst idx = this._ranges.findIndex((r) => r.contains(value));\n\t\tif (idx !== -1) {\n\t\t\tconst range = this._ranges[idx];\n\t\t\tif (range.start === value) {\n\t\t\t\tif (range.endExclusive === value + 1) {\n\t\t\t\t\tthis._ranges.splice(idx, 1);\n\t\t\t\t} else {\n\t\t\t\t\tthis._ranges[idx] = new OffsetRange(\n\t\t\t\t\t\tvalue + 1,\n\t\t\t\t\t\trange.endExclusive,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else if (range.endExclusive === value + 1) {\n\t\t\t\tthis._ranges[idx] = new OffsetRange(range.start, value);\n\t\t\t} else {\n\t\t\t\tthis._ranges.splice(\n\t\t\t\t\tidx,\n\t\t\t\t\t1,\n\t\t\t\t\tnew OffsetRange(range.start, value),\n\t\t\t\t\tnew OffsetRange(value + 1, range.endExclusive),\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic addRange(range: OffsetRange): void {\n\t\tOffsetRange.addRange(range, this._ranges);\n\t}\n\n\tpublic addRangeAndResize(range: OffsetRange, newLength: number): void {\n\t\tlet idxFirstMightBeIntersecting = 0;\n\t\twhile (\n\t\t\t!(\n\t\t\t\tidxFirstMightBeIntersecting >= this._ranges.length ||\n\t\t\t\trange.start <=\n\t\t\t\t\tthis._ranges[idxFirstMightBeIntersecting].endExclusive\n\t\t\t)\n\t\t) {\n\t\t\tidxFirstMightBeIntersecting++;\n\t\t}\n\t\tlet idxFirstIsAfter = idxFirstMightBeIntersecting;\n\t\twhile (\n\t\t\t!(\n\t\t\t\tidxFirstIsAfter >= this._ranges.length ||\n\t\t\t\trange.endExclusive < this._ranges[idxFirstIsAfter].start\n\t\t\t)\n\t\t) {\n\t\t\tidxFirstIsAfter++;\n\t\t}\n\t\tconst delta = newLength - range.length;\n\n\t\tfor (let i = idxFirstIsAfter; i < this._ranges.length; i++) {\n\t\t\tthis._ranges[i] = this._ranges[i].delta(delta);\n\t\t}\n\n\t\tif (idxFirstMightBeIntersecting === idxFirstIsAfter) {\n\t\t\tconst newRange = new OffsetRange(\n\t\t\t\trange.start,\n\t\t\t\trange.start + newLength,\n\t\t\t);\n\t\t\tif (!newRange.isEmpty) {\n\t\t\t\tthis._ranges.splice(idxFirstMightBeIntersecting, 0, newRange);\n\t\t\t}\n\t\t} else {\n\t\t\tconst start = Math.min(\n\t\t\t\trange.start,\n\t\t\t\tthis._ranges[idxFirstMightBeIntersecting].start,\n\t\t\t);\n\t\t\tconst endEx = Math.max(\n\t\t\t\trange.endExclusive,\n\t\t\t\tthis._ranges[idxFirstIsAfter - 1].endExclusive,\n\t\t\t);\n\n\t\t\tconst newRange = new OffsetRange(start, endEx + delta);\n\t\t\tif (newRange.isEmpty) {\n\t\t\t\tthis._ranges.splice(\n\t\t\t\t\tidxFirstMightBeIntersecting,\n\t\t\t\t\tidxFirstIsAfter - idxFirstMightBeIntersecting,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthis._ranges.splice(\n\t\t\t\t\tidxFirstMightBeIntersecting,\n\t\t\t\t\tidxFirstIsAfter - idxFirstMightBeIntersecting,\n\t\t\t\t\tnewRange,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn this._ranges.map((r) => r.toString()).join(\" + \");\n\t}\n}\n\nfunction safeTokenize(\n\tlanguageIdCodec: ILanguageIdCodec,\n\tlanguageId: string,\n\ttokenizationSupport: ITokenizationSupport | null,\n\ttext: string,\n\thasEOL: boolean,\n\tstate: IState,\n): EncodedTokenizationResult {\n\tlet r: EncodedTokenizationResult | null = null;\n\n\tif (tokenizationSupport) {\n\t\ttry {\n\t\t\tr = tokenizationSupport.tokenizeEncoded(\n\t\t\t\ttext,\n\t\t\t\thasEOL,\n\t\t\t\tstate.clone(),\n\t\t\t);\n\t\t} catch (e) {\n\t\t\tonUnexpectedError(e);\n\t\t}\n\t}\n\n\tif (!r) {\n\t\tr = nullTokenizeEncoded(\n\t\t\tlanguageIdCodec.encodeLanguageId(languageId),\n\t\t\tstate,\n\t\t);\n\t}\n\n\tLineTokens.convertToEndOffset(r.tokens, text.length);\n\treturn r;\n}\n\nexport class DefaultBackgroundTokenizer implements IBackgroundTokenizer {\n\tprivate _isDisposed = false;\n\n\tconstructor(\n\t\tprivate readonly _tokenizerWithStateStore: TokenizerWithStateStoreAndTextModel,\n\t\tprivate readonly _backgroundTokenStore: IBackgroundTokenizationStore,\n\t) {}\n\n\tpublic dispose(): void {\n\t\tthis._isDisposed = true;\n\t}\n\n\tpublic handleChanges(): void {\n\t\tthis._beginBackgroundTokenization();\n\t}\n\n\tprivate _isScheduled = false;\n\tprivate _beginBackgroundTokenization(): void {\n\t\tif (\n\t\t\tthis._isScheduled ||\n\t\t\t!this._tokenizerWithStateStore._textModel.isAttachedToEditor() ||\n\t\t\t!this._hasLinesToTokenize()\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._isScheduled = true;\n\t\trunWhenGlobalIdle((deadline) => {\n\t\t\tthis._isScheduled = false;\n\n\t\t\tthis._backgroundTokenizeWithDeadline(deadline);\n\t\t});\n\t}\n\n\t/**\n\t * Tokenize until the deadline occurs, but try to yield every 1-2ms.\n\t */\n\tprivate _backgroundTokenizeWithDeadline(deadline: IdleDeadline): void {\n\t\t// Read the time remaining from the `deadline` immediately because it is unclear\n\t\t// if the `deadline` object will be valid after execution leaves this function.\n\t\tconst endTime = Date.now() + deadline.timeRemaining();\n\n\t\tconst execute = () => {\n\t\t\tif (\n\t\t\t\tthis._isDisposed ||\n\t\t\t\t!this._tokenizerWithStateStore._textModel.isAttachedToEditor() ||\n\t\t\t\t!this._hasLinesToTokenize()\n\t\t\t) {\n\t\t\t\t// disposed in the meantime or detached or finished\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._backgroundTokenizeForAtLeast1ms();\n\n\t\t\tif (Date.now() < endTime) {\n\t\t\t\t// There is still time before reaching the deadline, so yield to the browser and then\n\t\t\t\t// continue execution\n\t\t\t\tsetTimeout0(execute);\n\t\t\t} else {\n\t\t\t\t// The deadline has been reached, so schedule a new idle callback if necessary\n\t\t\t\tthis._beginBackgroundTokenization();\n\t\t\t}\n\t\t};\n\t\texecute();\n\t}\n\n\t/**\n\t * Tokenize for at least 1ms.\n\t */\n\tprivate _backgroundTokenizeForAtLeast1ms(): void {\n\t\tconst lineCount =\n\t\t\tthis._tokenizerWithStateStore._textModel.getLineCount();\n\t\tconst builder = new ContiguousMultilineTokensBuilder();\n\t\tconst sw = StopWatch.create(false);\n\n\t\tdo {\n\t\t\tif (sw.elapsed() > 1) {\n\t\t\t\t// the comparison is intentionally > 1 and not >= 1 to ensure that\n\t\t\t\t// a full millisecond has elapsed, given how microseconds are rounded\n\t\t\t\t// to milliseconds\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);\n\n\t\t\tif (tokenizedLineNumber >= lineCount) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (this._hasLinesToTokenize());\n\n\t\tthis._backgroundTokenStore.setTokens(builder.finalize());\n\t\tthis.checkFinished();\n\t}\n\n\tprivate _hasLinesToTokenize(): boolean {\n\t\tif (!this._tokenizerWithStateStore) {\n\t\t\treturn false;\n\t\t}\n\t\treturn !this._tokenizerWithStateStore.store.allStatesValid();\n\t}\n\n\tprivate _tokenizeOneInvalidLine(\n\t\tbuilder: ContiguousMultilineTokensBuilder,\n\t): number {\n\t\tconst firstInvalidLine =\n\t\t\tthis._tokenizerWithStateStore?.getFirstInvalidLine();\n\t\tif (!firstInvalidLine) {\n\t\t\treturn this._tokenizerWithStateStore._textModel.getLineCount() + 1;\n\t\t}\n\t\tthis._tokenizerWithStateStore.updateTokensUntilLine(\n\t\t\tbuilder,\n\t\t\tfirstInvalidLine.lineNumber,\n\t\t);\n\t\treturn firstInvalidLine.lineNumber;\n\t}\n\n\tpublic checkFinished(): void {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._tokenizerWithStateStore.store.allStatesValid()) {\n\t\t\tthis._backgroundTokenStore.backgroundTokenizationFinished();\n\t\t}\n\t}\n\n\tpublic requestTokens(\n\t\tstartLineNumber: number,\n\t\tendLineNumberExclusive: number,\n\t): void {\n\t\tthis._tokenizerWithStateStore.store.invalidateEndStateRange(\n\t\t\tnew LineRange(startLineNumber, endLineNumberExclusive),\n\t\t);\n\t}\n}\n"],
  "mappings": "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",
  "names": ["Constants"]
}
