{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/model/textModelTokens.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IdleDeadline, runWhenGlobalIdle } from '../../../base/common/async.js';\nimport { BugIndicatingError, onUnexpectedError } from '../../../base/common/errors.js';\nimport { setTimeout0 } from '../../../base/common/platform.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { OffsetRange } from '../core/offsetRange.js';\nimport { Position } from '../core/position.js';\nimport { StandardTokenType } from '../encodedTokenAttributes.js';\nimport { EncodedTokenizationResult, IBackgroundTokenizationStore, IBackgroundTokenizer, ILanguageIdCodec, IState, ITokenizationSupport } from '../languages.js';\nimport { nullTokenizeEncoded } from '../languages/nullTokenize.js';\nimport { ITextModel } from '../model.js';\nimport { FixedArray } from './fixedArray.js';\nimport { IModelContentChange } from '../textModelEvents.js';\nimport { ITokenizeLineWithEditResult, LineEditWithAdditionalLines } from '../tokenizationTextModelPart.js';\nimport { ContiguousMultilineTokensBuilder } from '../tokens/contiguousMultilineTokensBuilder.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\n\nconst enum Constants {\n\tCHEAP_TOKENIZATION_LENGTH_LIMIT = 2048\n}\n\nexport class TokenizerWithStateStore<TState extends IState = IState> {\n\tprivate readonly initialState = this.tokenizationSupport.getInitialState() as TState;\n\n\tpublic readonly store: TrackingTokenizationStateStore<TState>;\n\n\tconstructor(\n\t\tlineCount: number,\n\t\tpublic readonly tokenizationSupport: ITokenizationSupport\n\t) {\n\t\tthis.store = new TrackingTokenizationStateStore<TState>(lineCount);\n\t}\n\n\tpublic getStartState(lineNumber: number): TState | null {\n\t\treturn this.store.getStartState(lineNumber, this.initialState);\n\t}\n\n\tpublic getFirstInvalidLine(): { lineNumber: number; startState: TState } | null {\n\t\treturn this.store.getFirstInvalidLine(this.initialState);\n\t}\n}\n\nexport class TokenizerWithStateStoreAndTextModel<TState extends IState = IState> extends TokenizerWithStateStore<TState> {\n\tconstructor(\n\t\tlineCount: number,\n\t\ttokenizationSupport: ITokenizationSupport,\n\t\tpublic readonly _textModel: ITextModel,\n\t\tpublic readonly _languageIdCodec: ILanguageIdCodec\n\t) {\n\t\tsuper(lineCount, tokenizationSupport);\n\t}\n\n\tpublic updateTokensUntilLine(builder: ContiguousMultilineTokensBuilder, lineNumber: number): void {\n\t\tconst languageId = this._textModel.getLanguageId();\n\n\t\twhile (true) {\n\t\t\tconst lineToTokenize = this.getFirstInvalidLine();\n\t\t\tif (!lineToTokenize || lineToTokenize.lineNumber > lineNumber) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst text = this._textModel.getLineContent(lineToTokenize.lineNumber);\n\n\t\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineToTokenize.startState);\n\t\t\tbuilder.add(lineToTokenize.lineNumber, r.tokens);\n\t\t\tthis.store.setEndState(lineToTokenize.lineNumber, r.endState as TState);\n\t\t}\n\t}\n\n\t/** assumes state is up to date */\n\tpublic getTokenTypeIfInsertingCharacter(position: Position, character: string): StandardTokenType {\n\t\t// TODO@hediet: use tokenizeLineWithEdit\n\t\tconst lineStartState = this.getStartState(position.lineNumber);\n\t\tif (!lineStartState) {\n\t\t\treturn StandardTokenType.Other;\n\t\t}\n\n\t\tconst languageId = this._textModel.getLanguageId();\n\t\tconst lineContent = this._textModel.getLineContent(position.lineNumber);\n\n\t\t// Create the text as if `character` was inserted\n\t\tconst text = (\n\t\t\tlineContent.substring(0, position.column - 1)\n\t\t\t+ character\n\t\t\t+ lineContent.substring(position.column - 1)\n\t\t);\n\n\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineStartState);\n\t\tconst lineTokens = new LineTokens(r.tokens, text, this._languageIdCodec);\n\t\tif (lineTokens.getCount() === 0) {\n\t\t\treturn StandardTokenType.Other;\n\t\t}\n\n\t\tconst tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n\t\treturn lineTokens.getStandardTokenType(tokenIndex);\n\t}\n\n\t/** assumes state is up to date */\n\tpublic tokenizeLineWithEdit(lineNumber: number, edit: LineEditWithAdditionalLines): ITokenizeLineWithEditResult {\n\t\tconst lineStartState = this.getStartState(lineNumber);\n\t\tif (!lineStartState) {\n\t\t\treturn { mainLineTokens: null, additionalLines: null };\n\t\t}\n\n\t\tconst curLineContent = this._textModel.getLineContent(lineNumber);\n\t\tconst newLineContent = edit.lineEdit.apply(curLineContent);\n\n\t\tconst languageId = this._textModel.getLanguageIdAtPosition(lineNumber, 0);\n\t\tconst result = safeTokenize(\n\t\t\tthis._languageIdCodec,\n\t\t\tlanguageId,\n\t\t\tthis.tokenizationSupport,\n\t\t\tnewLineContent,\n\t\t\ttrue,\n\t\t\tlineStartState\n\t\t);\n\n\t\tlet additionalLines: LineTokens[] | null = null;\n\t\tif (edit.additionalLines) {\n\t\t\tadditionalLines = [];\n\t\t\tlet state = result.endState;\n\t\t\tfor (const line of edit.additionalLines) {\n\t\t\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, line, true, state);\n\t\t\t\tadditionalLines.push(new LineTokens(r.tokens, line, this._languageIdCodec));\n\t\t\t\tstate = r.endState;\n\t\t\t}\n\t\t}\n\n\t\tconst mainLineTokens = new LineTokens(result.tokens, newLineContent, this._languageIdCodec);\n\t\treturn { mainLineTokens, additionalLines };\n\t}\n\n\tpublic hasAccurateTokensForLine(lineNumber: number): boolean {\n\t\tconst firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();\n\t\treturn (lineNumber < firstInvalidLineNumber);\n\t}\n\n\tpublic isCheapToTokenize(lineNumber: number): boolean {\n\t\tconst firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();\n\t\tif (lineNumber < firstInvalidLineNumber) {\n\t\t\treturn true;\n\t\t}\n\t\tif (lineNumber === firstInvalidLineNumber\n\t\t\t&& this._textModel.getLineLength(lineNumber) < Constants.CHEAP_TOKENIZATION_LENGTH_LIMIT) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * The result is not cached.\n\t */\n\tpublic tokenizeHeuristically(builder: ContiguousMultilineTokensBuilder, startLineNumber: number, endLineNumber: number): { heuristicTokens: boolean } {\n\t\tif (endLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n\t\t\t// nothing to do\n\t\t\treturn { heuristicTokens: false };\n\t\t}\n\n\t\tif (startLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n\t\t\t// tokenization has reached the viewport start...\n\t\t\tthis.updateTokensUntilLine(builder, endLineNumber);\n\t\t\treturn { heuristicTokens: false };\n\t\t}\n\n\t\tlet state = this.guessStartState(startLineNumber);\n\t\tconst languageId = this._textModel.getLanguageId();\n\n\t\tfor (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n\t\t\tconst text = this._textModel.getLineContent(lineNumber);\n\t\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, state);\n\t\t\tbuilder.add(lineNumber, r.tokens);\n\t\t\tstate = r.endState;\n\t\t}\n\n\t\treturn { heuristicTokens: true };\n\t}\n\n\tprivate guessStartState(lineNumber: number): IState {\n\t\tlet nonWhitespaceColumn = this._textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n\t\tconst likelyRelevantLines: string[] = [];\n\t\tlet initialState: IState | null = null;\n\t\tfor (let i = lineNumber - 1; nonWhitespaceColumn > 1 && i >= 1; i--) {\n\t\t\tconst newNonWhitespaceIndex = this._textModel.getLineFirstNonWhitespaceColumn(i);\n\t\t\t// Ignore lines full of whitespace\n\t\t\tif (newNonWhitespaceIndex === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (newNonWhitespaceIndex < nonWhitespaceColumn) {\n\t\t\t\tlikelyRelevantLines.push(this._textModel.getLineContent(i));\n\t\t\t\tnonWhitespaceColumn = newNonWhitespaceIndex;\n\t\t\t\tinitialState = this.getStartState(i);\n\t\t\t\tif (initialState) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!initialState) {\n\t\t\tinitialState = this.tokenizationSupport.getInitialState();\n\t\t}\n\t\tlikelyRelevantLines.reverse();\n\n\t\tconst languageId = this._textModel.getLanguageId();\n\t\tlet state = initialState;\n\t\tfor (const line of likelyRelevantLines) {\n\t\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, line, false, state);\n\t\t\tstate = r.endState;\n\t\t}\n\t\treturn state;\n\t}\n}\n\n/**\n * **Invariant:**\n * If the text model is retokenized from line 1 to {@link getFirstInvalidEndStateLineNumber}() - 1,\n * then the recomputed end state for line l will be equal to {@link getEndState}(l).\n */\nexport class TrackingTokenizationStateStore<TState extends IState> {\n\tprivate readonly _tokenizationStateStore = new TokenizationStateStore<TState>();\n\tprivate readonly _invalidEndStatesLineNumbers = new RangePriorityQueueImpl();\n\n\tconstructor(private lineCount: number) {\n\t\tthis._invalidEndStatesLineNumbers.addRange(new OffsetRange(1, lineCount + 1));\n\t}\n\n\tpublic getEndState(lineNumber: number): TState | null {\n\t\treturn this._tokenizationStateStore.getEndState(lineNumber);\n\t}\n\n\t/**\n\t * @returns if the end state has changed.\n\t */\n\tpublic setEndState(lineNumber: number, state: TState): boolean {\n\t\tif (!state) {\n\t\t\tthrow new BugIndicatingError('Cannot set null/undefined state');\n\t\t}\n\n\t\tthis._invalidEndStatesLineNumbers.delete(lineNumber);\n\t\tconst r = this._tokenizationStateStore.setEndState(lineNumber, state);\n\t\tif (r && lineNumber < this.lineCount) {\n\t\t\t// because the state changed, we cannot trust the next state anymore and have to invalidate it.\n\t\t\tthis._invalidEndStatesLineNumbers.addRange(new OffsetRange(lineNumber + 1, lineNumber + 2));\n\t\t}\n\n\t\treturn r;\n\t}\n\n\tpublic acceptChange(range: LineRange, newLineCount: number): void {\n\t\tthis.lineCount += newLineCount - range.length;\n\t\tthis._tokenizationStateStore.acceptChange(range, newLineCount);\n\t\tthis._invalidEndStatesLineNumbers.addRangeAndResize(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive), newLineCount);\n\t}\n\n\tpublic acceptChanges(changes: IModelContentChange[]) {\n\t\tfor (const c of changes) {\n\t\t\tconst [eolCount] = countEOL(c.text);\n\t\t\tthis.acceptChange(new LineRange(c.range.startLineNumber, c.range.endLineNumber + 1), eolCount + 1);\n\t\t}\n\t}\n\n\tpublic invalidateEndStateRange(range: LineRange): void {\n\t\tthis._invalidEndStatesLineNumbers.addRange(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive));\n\t}\n\n\tpublic getFirstInvalidEndStateLineNumber(): number | null { return this._invalidEndStatesLineNumbers.min; }\n\n\tpublic getFirstInvalidEndStateLineNumberOrMax(): number {\n\t\treturn this.getFirstInvalidEndStateLineNumber() || Number.MAX_SAFE_INTEGER;\n\t}\n\n\tpublic allStatesValid(): boolean { return this._invalidEndStatesLineNumbers.min === null; }\n\n\tpublic getStartState(lineNumber: number, initialState: TState): TState | null {\n\t\tif (lineNumber === 1) { return initialState; }\n\t\treturn this.getEndState(lineNumber - 1);\n\t}\n\n\tpublic getFirstInvalidLine(initialState: TState): { lineNumber: number; startState: TState } | null {\n\t\tconst lineNumber = this.getFirstInvalidEndStateLineNumber();\n\t\tif (lineNumber === null) {\n\t\t\treturn null;\n\t\t}\n\t\tconst startState = this.getStartState(lineNumber, initialState);\n\t\tif (!startState) {\n\t\t\tthrow new BugIndicatingError('Start state must be defined');\n\t\t}\n\n\t\treturn { lineNumber, startState };\n\t}\n}\n\nexport class TokenizationStateStore<TState extends IState> {\n\tprivate readonly _lineEndStates = new FixedArray<TState | null>(null);\n\n\tpublic getEndState(lineNumber: number): TState | null {\n\t\treturn this._lineEndStates.get(lineNumber);\n\t}\n\n\tpublic setEndState(lineNumber: number, state: TState): boolean {\n\t\tconst oldState = this._lineEndStates.get(lineNumber);\n\t\tif (oldState && oldState.equals(state)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._lineEndStates.set(lineNumber, state);\n\t\treturn true;\n\t}\n\n\tpublic acceptChange(range: LineRange, newLineCount: number): void {\n\t\tlet length = range.length;\n\t\tif (newLineCount > 0 && length > 0) {\n\t\t\t// Keep the last state, even though it is unrelated.\n\t\t\t// But if the new state happens to agree with this last state, then we know we can stop tokenizing.\n\t\t\tlength--;\n\t\t\tnewLineCount--;\n\t\t}\n\n\t\tthis._lineEndStates.replace(range.startLineNumber, length, newLineCount);\n\t}\n\n\tpublic acceptChanges(changes: IModelContentChange[]) {\n\t\tfor (const c of changes) {\n\t\t\tconst [eolCount] = countEOL(c.text);\n\t\t\tthis.acceptChange(new LineRange(c.range.startLineNumber, c.range.endLineNumber + 1), eolCount + 1);\n\t\t}\n\t}\n}\n\ninterface RangePriorityQueue {\n\tget min(): number | null;\n\tremoveMin(): number | null;\n\n\taddRange(range: OffsetRange): void;\n\n\taddRangeAndResize(range: OffsetRange, newLength: number): void;\n}\n\nexport class RangePriorityQueueImpl implements RangePriorityQueue {\n\tprivate readonly _ranges: OffsetRange[] = [];\n\n\tpublic getRanges(): OffsetRange[] {\n\t\treturn this._ranges;\n\t}\n\n\tpublic get min(): number | null {\n\t\tif (this._ranges.length === 0) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this._ranges[0].start;\n\t}\n\n\tpublic removeMin(): number | null {\n\t\tif (this._ranges.length === 0) {\n\t\t\treturn null;\n\t\t}\n\t\tconst range = this._ranges[0];\n\t\tif (range.start + 1 === range.endExclusive) {\n\t\t\tthis._ranges.shift();\n\t\t} else {\n\t\t\tthis._ranges[0] = new OffsetRange(range.start + 1, range.endExclusive);\n\t\t}\n\t\treturn range.start;\n\t}\n\n\tpublic delete(value: number): void {\n\t\tconst idx = this._ranges.findIndex(r => r.contains(value));\n\t\tif (idx !== -1) {\n\t\t\tconst range = this._ranges[idx];\n\t\t\tif (range.start === value) {\n\t\t\t\tif (range.endExclusive === value + 1) {\n\t\t\t\t\tthis._ranges.splice(idx, 1);\n\t\t\t\t} else {\n\t\t\t\t\tthis._ranges[idx] = new OffsetRange(value + 1, range.endExclusive);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (range.endExclusive === value + 1) {\n\t\t\t\t\tthis._ranges[idx] = new OffsetRange(range.start, value);\n\t\t\t\t} else {\n\t\t\t\t\tthis._ranges.splice(idx, 1, new OffsetRange(range.start, value), new OffsetRange(value + 1, range.endExclusive));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic addRange(range: OffsetRange): void {\n\t\tOffsetRange.addRange(range, this._ranges);\n\t}\n\n\tpublic addRangeAndResize(range: OffsetRange, newLength: number): void {\n\t\tlet idxFirstMightBeIntersecting = 0;\n\t\twhile (!(idxFirstMightBeIntersecting >= this._ranges.length || range.start <= this._ranges[idxFirstMightBeIntersecting].endExclusive)) {\n\t\t\tidxFirstMightBeIntersecting++;\n\t\t}\n\t\tlet idxFirstIsAfter = idxFirstMightBeIntersecting;\n\t\twhile (!(idxFirstIsAfter >= this._ranges.length || range.endExclusive < this._ranges[idxFirstIsAfter].start)) {\n\t\t\tidxFirstIsAfter++;\n\t\t}\n\t\tconst delta = newLength - range.length;\n\n\t\tfor (let i = idxFirstIsAfter; i < this._ranges.length; i++) {\n\t\t\tthis._ranges[i] = this._ranges[i].delta(delta);\n\t\t}\n\n\t\tif (idxFirstMightBeIntersecting === idxFirstIsAfter) {\n\t\t\tconst newRange = new OffsetRange(range.start, range.start + newLength);\n\t\t\tif (!newRange.isEmpty) {\n\t\t\t\tthis._ranges.splice(idxFirstMightBeIntersecting, 0, newRange);\n\t\t\t}\n\t\t} else {\n\t\t\tconst start = Math.min(range.start, this._ranges[idxFirstMightBeIntersecting].start);\n\t\t\tconst endEx = Math.max(range.endExclusive, this._ranges[idxFirstIsAfter - 1].endExclusive);\n\n\t\t\tconst newRange = new OffsetRange(start, endEx + delta);\n\t\t\tif (!newRange.isEmpty) {\n\t\t\t\tthis._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting, newRange);\n\t\t\t} else {\n\t\t\t\tthis._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting);\n\t\t\t}\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn this._ranges.map(r => r.toString()).join(' + ');\n\t}\n}\n\n\nfunction safeTokenize(languageIdCodec: ILanguageIdCodec, languageId: string, tokenizationSupport: ITokenizationSupport | null, text: string, hasEOL: boolean, state: IState): EncodedTokenizationResult {\n\tlet r: EncodedTokenizationResult | null = null;\n\n\tif (tokenizationSupport) {\n\t\ttry {\n\t\t\tr = tokenizationSupport.tokenizeEncoded(text, hasEOL, state.clone());\n\t\t} catch (e) {\n\t\t\tonUnexpectedError(e);\n\t\t}\n\t}\n\n\tif (!r) {\n\t\tr = nullTokenizeEncoded(languageIdCodec.encodeLanguageId(languageId), state);\n\t}\n\n\tLineTokens.convertToEndOffset(r.tokens, text.length);\n\treturn r;\n}\n\nexport class DefaultBackgroundTokenizer implements IBackgroundTokenizer {\n\tprivate _isDisposed = false;\n\n\tconstructor(\n\t\tprivate readonly _tokenizerWithStateStore: TokenizerWithStateStoreAndTextModel,\n\t\tprivate readonly _backgroundTokenStore: IBackgroundTokenizationStore,\n\t) {\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._isDisposed = true;\n\t}\n\n\tpublic handleChanges(): void {\n\t\tthis._beginBackgroundTokenization();\n\t}\n\n\tprivate _isScheduled = false;\n\tprivate _beginBackgroundTokenization(): void {\n\t\tif (this._isScheduled || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._isScheduled = true;\n\t\trunWhenGlobalIdle((deadline) => {\n\t\t\tthis._isScheduled = false;\n\n\t\t\tthis._backgroundTokenizeWithDeadline(deadline);\n\t\t});\n\t}\n\n\t/**\n\t * Tokenize until the deadline occurs, but try to yield every 1-2ms.\n\t */\n\tprivate _backgroundTokenizeWithDeadline(deadline: IdleDeadline): void {\n\t\t// Read the time remaining from the `deadline` immediately because it is unclear\n\t\t// if the `deadline` object will be valid after execution leaves this function.\n\t\tconst endTime = Date.now() + deadline.timeRemaining();\n\n\t\tconst execute = () => {\n\t\t\tif (this._isDisposed || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n\t\t\t\t// disposed in the meantime or detached or finished\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._backgroundTokenizeForAtLeast1ms();\n\n\t\t\tif (Date.now() < endTime) {\n\t\t\t\t// There is still time before reaching the deadline, so yield to the browser and then\n\t\t\t\t// continue execution\n\t\t\t\tsetTimeout0(execute);\n\t\t\t} else {\n\t\t\t\t// The deadline has been reached, so schedule a new idle callback if necessary\n\t\t\t\tthis._beginBackgroundTokenization();\n\t\t\t}\n\t\t};\n\t\texecute();\n\t}\n\n\t/**\n\t * Tokenize for at least 1ms.\n\t */\n\tprivate _backgroundTokenizeForAtLeast1ms(): void {\n\t\tconst lineCount = this._tokenizerWithStateStore._textModel.getLineCount();\n\t\tconst builder = new ContiguousMultilineTokensBuilder();\n\t\tconst sw = StopWatch.create(false);\n\n\t\tdo {\n\t\t\tif (sw.elapsed() > 1) {\n\t\t\t\t// the comparison is intentionally > 1 and not >= 1 to ensure that\n\t\t\t\t// a full millisecond has elapsed, given how microseconds are rounded\n\t\t\t\t// to milliseconds\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);\n\n\t\t\tif (tokenizedLineNumber >= lineCount) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (this._hasLinesToTokenize());\n\n\t\tthis._backgroundTokenStore.setTokens(builder.finalize());\n\t\tthis.checkFinished();\n\t}\n\n\tprivate _hasLinesToTokenize(): boolean {\n\t\tif (!this._tokenizerWithStateStore) {\n\t\t\treturn false;\n\t\t}\n\t\treturn !this._tokenizerWithStateStore.store.allStatesValid();\n\t}\n\n\tprivate _tokenizeOneInvalidLine(builder: ContiguousMultilineTokensBuilder): number {\n\t\tconst firstInvalidLine = this._tokenizerWithStateStore?.getFirstInvalidLine();\n\t\tif (!firstInvalidLine) {\n\t\t\treturn this._tokenizerWithStateStore._textModel.getLineCount() + 1;\n\t\t}\n\t\tthis._tokenizerWithStateStore.updateTokensUntilLine(builder, firstInvalidLine.lineNumber);\n\t\treturn firstInvalidLine.lineNumber;\n\t}\n\n\tpublic checkFinished(): void {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._tokenizerWithStateStore.store.allStatesValid()) {\n\t\t\tthis._backgroundTokenStore.backgroundTokenizationFinished();\n\t\t}\n\t}\n\n\tpublic requestTokens(startLineNumber: number, endLineNumberExclusive: number): void {\n\t\tthis._tokenizerWithStateStore.store.invalidateEndStateRange(new LineRange(startLineNumber, endLineNumberExclusive));\n\t}\n}\n"],
  "mappings": "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",
  "names": ["Constants"]
}
