{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/concat23Trees.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { type AstNode, AstNodeKind, ListAstNode } from \"./ast.js\";\n\n/**\n * Concatenates a list of (2,3) AstNode's into a single (2,3) AstNode.\n * This mutates the items of the input array!\n * If all items have the same height, this method has runtime O(items.length).\n * Otherwise, it has runtime O(items.length * max(log(items.length), items.max(i => i.height))).\n */\nexport function concat23Trees(items: AstNode[]): AstNode | null {\n\tif (items.length === 0) {\n\t\treturn null;\n\t}\n\tif (items.length === 1) {\n\t\treturn items[0];\n\t}\n\n\tlet i = 0;\n\t/**\n\t * Reads nodes of same height and concatenates them to a single node.\n\t */\n\tfunction readNode(): AstNode | null {\n\t\tif (i >= items.length) {\n\t\t\treturn null;\n\t\t}\n\t\tconst start = i;\n\t\tconst height = items[start].listHeight;\n\n\t\ti++;\n\t\twhile (i < items.length && items[i].listHeight === height) {\n\t\t\ti++;\n\t\t}\n\n\t\tif (i - start >= 2) {\n\t\t\treturn concat23TreesOfSameHeight(\n\t\t\t\tstart === 0 && i === items.length\n\t\t\t\t\t? items\n\t\t\t\t\t: items.slice(start, i),\n\t\t\t\tfalse,\n\t\t\t);\n\t\t} else {\n\t\t\treturn items[start];\n\t\t}\n\t}\n\n\t// The items might not have the same height.\n\t// We merge all items by using a binary concat operator.\n\tlet first = readNode()!; // There must be a first item\n\tlet second = readNode();\n\tif (!second) {\n\t\treturn first;\n\t}\n\n\tfor (let item = readNode(); item; item = readNode()) {\n\t\t// Prefer concatenating smaller trees, as the runtime of concat depends on the tree height.\n\t\tif (heightDiff(first, second) <= heightDiff(second, item)) {\n\t\t\tfirst = concat(first, second);\n\t\t\tsecond = item;\n\t\t} else {\n\t\t\tsecond = concat(second, item);\n\t\t}\n\t}\n\n\tconst result = concat(first, second);\n\treturn result;\n}\n\nexport function concat23TreesOfSameHeight(\n\titems: AstNode[],\n\tcreateImmutableLists = false,\n): AstNode | null {\n\tif (items.length === 0) {\n\t\treturn null;\n\t}\n\tif (items.length === 1) {\n\t\treturn items[0];\n\t}\n\n\tlet length = items.length;\n\t// All trees have same height, just create parent nodes.\n\twhile (length > 3) {\n\t\tconst newLength = length >> 1;\n\t\tfor (let i = 0; i < newLength; i++) {\n\t\t\tconst j = i << 1;\n\t\t\titems[i] = ListAstNode.create23(\n\t\t\t\titems[j],\n\t\t\t\titems[j + 1],\n\t\t\t\tj + 3 === length ? items[j + 2] : null,\n\t\t\t\tcreateImmutableLists,\n\t\t\t);\n\t\t}\n\t\tlength = newLength;\n\t}\n\treturn ListAstNode.create23(\n\t\titems[0],\n\t\titems[1],\n\t\tlength >= 3 ? items[2] : null,\n\t\tcreateImmutableLists,\n\t);\n}\n\nfunction heightDiff(node1: AstNode, node2: AstNode): number {\n\treturn Math.abs(node1.listHeight - node2.listHeight);\n}\n\nfunction concat(node1: AstNode, node2: AstNode): AstNode {\n\tif (node1.listHeight === node2.listHeight) {\n\t\treturn ListAstNode.create23(node1, node2, null, false);\n\t} else if (node1.listHeight > node2.listHeight) {\n\t\t// node1 is the tree we want to insert into\n\t\treturn append(node1 as ListAstNode, node2);\n\t} else {\n\t\treturn prepend(node2 as ListAstNode, node1);\n\t}\n}\n\n/**\n * Appends the given node to the end of this (2,3) tree.\n * Returns the new root.\n */\nfunction append(list: ListAstNode, nodeToAppend: AstNode): AstNode {\n\tlist = list.toMutable() as ListAstNode;\n\tlet curNode: AstNode = list;\n\tconst parents: ListAstNode[] = [];\n\tlet nodeToAppendOfCorrectHeight: AstNode | undefined;\n\twhile (true) {\n\t\t// assert nodeToInsert.listHeight <= curNode.listHeight\n\t\tif (nodeToAppend.listHeight === curNode.listHeight) {\n\t\t\tnodeToAppendOfCorrectHeight = nodeToAppend;\n\t\t\tbreak;\n\t\t}\n\t\t// assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n\t\tif (curNode.kind !== AstNodeKind.List) {\n\t\t\tthrow new Error(\"unexpected\");\n\t\t}\n\t\tparents.push(curNode);\n\t\t// assert 2 <= curNode.childrenLength <= 3\n\t\tcurNode = curNode.makeLastElementMutable()!;\n\t}\n\t// assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n\tfor (let i = parents.length - 1; i >= 0; i--) {\n\t\tconst parent = parents[i];\n\t\tif (nodeToAppendOfCorrectHeight) {\n\t\t\t// Can we take the element?\n\t\t\tif (parent.childrenLength >= 3) {\n\t\t\t\t// assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n\n\t\t\t\t// we need to split to maintain (2,3)-tree property.\n\t\t\t\t// Send the third element + the new element to the parent.\n\t\t\t\tnodeToAppendOfCorrectHeight = ListAstNode.create23(\n\t\t\t\t\tparent.unappendChild()!,\n\t\t\t\t\tnodeToAppendOfCorrectHeight,\n\t\t\t\t\tnull,\n\t\t\t\t\tfalse,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tparent.appendChildOfSameHeight(nodeToAppendOfCorrectHeight);\n\t\t\t\tnodeToAppendOfCorrectHeight = undefined;\n\t\t\t}\n\t\t} else {\n\t\t\tparent.handleChildrenChanged();\n\t\t}\n\t}\n\tif (nodeToAppendOfCorrectHeight) {\n\t\treturn ListAstNode.create23(\n\t\t\tlist,\n\t\t\tnodeToAppendOfCorrectHeight,\n\t\t\tnull,\n\t\t\tfalse,\n\t\t);\n\t} else {\n\t\treturn list;\n\t}\n}\n\n/**\n * Prepends the given node to the end of this (2,3) tree.\n * Returns the new root.\n */\nfunction prepend(list: ListAstNode, nodeToAppend: AstNode): AstNode {\n\tlist = list.toMutable() as ListAstNode;\n\tlet curNode: AstNode = list;\n\tconst parents: ListAstNode[] = [];\n\t// assert nodeToInsert.listHeight <= curNode.listHeight\n\twhile (nodeToAppend.listHeight !== curNode.listHeight) {\n\t\t// assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n\t\tif (curNode.kind !== AstNodeKind.List) {\n\t\t\tthrow new Error(\"unexpected\");\n\t\t}\n\t\tparents.push(curNode);\n\t\t// assert 2 <= curNode.childrenFast.length <= 3\n\t\tcurNode = curNode.makeFirstElementMutable()!;\n\t}\n\tlet nodeToPrependOfCorrectHeight: AstNode | undefined = nodeToAppend;\n\t// assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n\tfor (let i = parents.length - 1; i >= 0; i--) {\n\t\tconst parent = parents[i];\n\t\tif (nodeToPrependOfCorrectHeight) {\n\t\t\t// Can we take the element?\n\t\t\tif (parent.childrenLength >= 3) {\n\t\t\t\t// assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n\n\t\t\t\t// we need to split to maintain (2,3)-tree property.\n\t\t\t\t// Send the third element + the new element to the parent.\n\t\t\t\tnodeToPrependOfCorrectHeight = ListAstNode.create23(\n\t\t\t\t\tnodeToPrependOfCorrectHeight,\n\t\t\t\t\tparent.unprependChild()!,\n\t\t\t\t\tnull,\n\t\t\t\t\tfalse,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tparent.prependChildOfSameHeight(nodeToPrependOfCorrectHeight);\n\t\t\t\tnodeToPrependOfCorrectHeight = undefined;\n\t\t\t}\n\t\t} else {\n\t\t\tparent.handleChildrenChanged();\n\t\t}\n\t}\n\tif (nodeToPrependOfCorrectHeight) {\n\t\treturn ListAstNode.create23(\n\t\t\tnodeToPrependOfCorrectHeight,\n\t\t\tlist,\n\t\t\tnull,\n\t\t\tfalse,\n\t\t);\n\t} else {\n\t\treturn list;\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
