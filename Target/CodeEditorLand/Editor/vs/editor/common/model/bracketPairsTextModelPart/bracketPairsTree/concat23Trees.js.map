{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/concat23Trees.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { AstNode, AstNodeKind, ListAstNode } from './ast.js';\n\n/**\n * Concatenates a list of (2,3) AstNode's into a single (2,3) AstNode.\n * This mutates the items of the input array!\n * If all items have the same height, this method has runtime O(items.length).\n * Otherwise, it has runtime O(items.length * max(log(items.length), items.max(i => i.height))).\n*/\nexport function concat23Trees(items: AstNode[]): AstNode | null {\n\tif (items.length === 0) {\n\t\treturn null;\n\t}\n\tif (items.length === 1) {\n\t\treturn items[0];\n\t}\n\n\tlet i = 0;\n\t/**\n\t * Reads nodes of same height and concatenates them to a single node.\n\t*/\n\tfunction readNode(): AstNode | null {\n\t\tif (i >= items.length) {\n\t\t\treturn null;\n\t\t}\n\t\tconst start = i;\n\t\tconst height = items[start].listHeight;\n\n\t\ti++;\n\t\twhile (i < items.length && items[i].listHeight === height) {\n\t\t\ti++;\n\t\t}\n\n\t\tif (i - start >= 2) {\n\t\t\treturn concat23TreesOfSameHeight(start === 0 && i === items.length ? items : items.slice(start, i), false);\n\t\t} else {\n\t\t\treturn items[start];\n\t\t}\n\t}\n\n\t// The items might not have the same height.\n\t// We merge all items by using a binary concat operator.\n\tlet first = readNode()!; // There must be a first item\n\tlet second = readNode();\n\tif (!second) {\n\t\treturn first;\n\t}\n\n\tfor (let item = readNode(); item; item = readNode()) {\n\t\t// Prefer concatenating smaller trees, as the runtime of concat depends on the tree height.\n\t\tif (heightDiff(first, second) <= heightDiff(second, item)) {\n\t\t\tfirst = concat(first, second);\n\t\t\tsecond = item;\n\t\t} else {\n\t\t\tsecond = concat(second, item);\n\t\t}\n\t}\n\n\tconst result = concat(first, second);\n\treturn result;\n}\n\nexport function concat23TreesOfSameHeight(items: AstNode[], createImmutableLists: boolean = false): AstNode | null {\n\tif (items.length === 0) {\n\t\treturn null;\n\t}\n\tif (items.length === 1) {\n\t\treturn items[0];\n\t}\n\n\tlet length = items.length;\n\t// All trees have same height, just create parent nodes.\n\twhile (length > 3) {\n\t\tconst newLength = length >> 1;\n\t\tfor (let i = 0; i < newLength; i++) {\n\t\t\tconst j = i << 1;\n\t\t\titems[i] = ListAstNode.create23(items[j], items[j + 1], j + 3 === length ? items[j + 2] : null, createImmutableLists);\n\t\t}\n\t\tlength = newLength;\n\t}\n\treturn ListAstNode.create23(items[0], items[1], length >= 3 ? items[2] : null, createImmutableLists);\n}\n\nfunction heightDiff(node1: AstNode, node2: AstNode): number {\n\treturn Math.abs(node1.listHeight - node2.listHeight);\n}\n\nfunction concat(node1: AstNode, node2: AstNode): AstNode {\n\tif (node1.listHeight === node2.listHeight) {\n\t\treturn ListAstNode.create23(node1, node2, null, false);\n\t}\n\telse if (node1.listHeight > node2.listHeight) {\n\t\t// node1 is the tree we want to insert into\n\t\treturn append(node1 as ListAstNode, node2);\n\t} else {\n\t\treturn prepend(node2 as ListAstNode, node1);\n\t}\n}\n\n/**\n * Appends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction append(list: ListAstNode, nodeToAppend: AstNode): AstNode {\n\tlist = list.toMutable() as ListAstNode;\n\tlet curNode: AstNode = list;\n\tconst parents: ListAstNode[] = [];\n\tlet nodeToAppendOfCorrectHeight: AstNode | undefined;\n\twhile (true) {\n\t\t// assert nodeToInsert.listHeight <= curNode.listHeight\n\t\tif (nodeToAppend.listHeight === curNode.listHeight) {\n\t\t\tnodeToAppendOfCorrectHeight = nodeToAppend;\n\t\t\tbreak;\n\t\t}\n\t\t// assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n\t\tif (curNode.kind !== AstNodeKind.List) {\n\t\t\tthrow new Error('unexpected');\n\t\t}\n\t\tparents.push(curNode);\n\t\t// assert 2 <= curNode.childrenLength <= 3\n\t\tcurNode = curNode.makeLastElementMutable()!;\n\t}\n\t// assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n\tfor (let i = parents.length - 1; i >= 0; i--) {\n\t\tconst parent = parents[i];\n\t\tif (nodeToAppendOfCorrectHeight) {\n\t\t\t// Can we take the element?\n\t\t\tif (parent.childrenLength >= 3) {\n\t\t\t\t// assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n\n\t\t\t\t// we need to split to maintain (2,3)-tree property.\n\t\t\t\t// Send the third element + the new element to the parent.\n\t\t\t\tnodeToAppendOfCorrectHeight = ListAstNode.create23(parent.unappendChild()!, nodeToAppendOfCorrectHeight, null, false);\n\t\t\t} else {\n\t\t\t\tparent.appendChildOfSameHeight(nodeToAppendOfCorrectHeight);\n\t\t\t\tnodeToAppendOfCorrectHeight = undefined;\n\t\t\t}\n\t\t} else {\n\t\t\tparent.handleChildrenChanged();\n\t\t}\n\t}\n\tif (nodeToAppendOfCorrectHeight) {\n\t\treturn ListAstNode.create23(list, nodeToAppendOfCorrectHeight, null, false);\n\t} else {\n\t\treturn list;\n\t}\n}\n\n/**\n * Prepends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction prepend(list: ListAstNode, nodeToAppend: AstNode): AstNode {\n\tlist = list.toMutable() as ListAstNode;\n\tlet curNode: AstNode = list;\n\tconst parents: ListAstNode[] = [];\n\t// assert nodeToInsert.listHeight <= curNode.listHeight\n\twhile (nodeToAppend.listHeight !== curNode.listHeight) {\n\t\t// assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n\t\tif (curNode.kind !== AstNodeKind.List) {\n\t\t\tthrow new Error('unexpected');\n\t\t}\n\t\tparents.push(curNode);\n\t\t// assert 2 <= curNode.childrenFast.length <= 3\n\t\tcurNode = curNode.makeFirstElementMutable()!;\n\t}\n\tlet nodeToPrependOfCorrectHeight: AstNode | undefined = nodeToAppend;\n\t// assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n\tfor (let i = parents.length - 1; i >= 0; i--) {\n\t\tconst parent = parents[i];\n\t\tif (nodeToPrependOfCorrectHeight) {\n\t\t\t// Can we take the element?\n\t\t\tif (parent.childrenLength >= 3) {\n\t\t\t\t// assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n\n\t\t\t\t// we need to split to maintain (2,3)-tree property.\n\t\t\t\t// Send the third element + the new element to the parent.\n\t\t\t\tnodeToPrependOfCorrectHeight = ListAstNode.create23(nodeToPrependOfCorrectHeight, parent.unprependChild()!, null, false);\n\t\t\t} else {\n\t\t\t\tparent.prependChildOfSameHeight(nodeToPrependOfCorrectHeight);\n\t\t\t\tnodeToPrependOfCorrectHeight = undefined;\n\t\t\t}\n\t\t} else {\n\t\t\tparent.handleChildrenChanged();\n\t\t}\n\t}\n\tif (nodeToPrependOfCorrectHeight) {\n\t\treturn ListAstNode.create23(nodeToPrependOfCorrectHeight, list, null, false);\n\t} else {\n\t\treturn list;\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
