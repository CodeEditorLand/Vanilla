{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/combineTextEditInfos.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ArrayQueue } from '../../../../../base/common/arrays.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { Length, lengthAdd, lengthDiffNonNegative, lengthEquals, lengthIsZero, lengthToObj, lengthZero, sumLengths } from './length.js';\n\nexport function combineTextEditInfos(textEditInfoFirst: TextEditInfo[], textEditInfoSecond: TextEditInfo[]): TextEditInfo[] {\n\tif (textEditInfoFirst.length === 0) {\n\t\treturn textEditInfoSecond;\n\t}\n\tif (textEditInfoSecond.length === 0) {\n\t\treturn textEditInfoFirst;\n\t}\n\n\t// s0: State before any edits\n\tconst s0ToS1Map = new ArrayQueue(toLengthMapping(textEditInfoFirst));\n\t// s1: State after first edit, but before second edit\n\tconst s1ToS2Map = toLengthMapping(textEditInfoSecond) as (LengthMapping | { lengthBefore: undefined; lengthAfter: undefined; modified: false })[];\n\ts1ToS2Map.push({ modified: false, lengthBefore: undefined, lengthAfter: undefined }); // Copy everything from old to new\n\t// s2: State after both edits\n\n\tlet curItem: LengthMapping | undefined = s0ToS1Map.dequeue();\n\n\t/**\n\t * @param s1Length Use undefined for length \"infinity\"\n\t */\n\tfunction nextS0ToS1MapWithS1LengthOf(s1Length: Length | undefined): LengthMapping[] {\n\t\tif (s1Length === undefined) {\n\t\t\tconst arr = s0ToS1Map.takeWhile(v => true) || [];\n\t\t\tif (curItem) {\n\t\t\t\tarr.unshift(curItem);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tconst result: LengthMapping[] = [];\n\t\twhile (curItem && !lengthIsZero(s1Length)) {\n\t\t\tconst [item, remainingItem] = curItem.splitAt(s1Length);\n\t\t\tresult.push(item);\n\t\t\ts1Length = lengthDiffNonNegative(item.lengthAfter, s1Length);\n\t\t\tcurItem = remainingItem ?? s0ToS1Map.dequeue();\n\t\t}\n\t\tif (!lengthIsZero(s1Length)) {\n\t\t\tresult.push(new LengthMapping(false, s1Length, s1Length));\n\t\t}\n\t\treturn result;\n\t}\n\n\tconst result: TextEditInfo[] = [];\n\n\tfunction pushEdit(startOffset: Length, endOffset: Length, newLength: Length): void {\n\t\tif (result.length > 0 && lengthEquals(result[result.length - 1].endOffset, startOffset)) {\n\t\t\tconst lastResult = result[result.length - 1];\n\t\t\tresult[result.length - 1] = new TextEditInfo(lastResult.startOffset, endOffset, lengthAdd(lastResult.newLength, newLength));\n\t\t} else {\n\t\t\tresult.push({ startOffset, endOffset, newLength });\n\t\t}\n\t}\n\n\tlet s0offset = lengthZero;\n\tfor (const s1ToS2 of s1ToS2Map) {\n\t\tconst s0ToS1Map = nextS0ToS1MapWithS1LengthOf(s1ToS2.lengthBefore);\n\t\tif (s1ToS2.modified) {\n\t\t\tconst s0Length = sumLengths(s0ToS1Map, s => s.lengthBefore);\n\t\t\tconst s0EndOffset = lengthAdd(s0offset, s0Length);\n\t\t\tpushEdit(s0offset, s0EndOffset, s1ToS2.lengthAfter);\n\t\t\ts0offset = s0EndOffset;\n\t\t} else {\n\t\t\tfor (const s1 of s0ToS1Map) {\n\t\t\t\tconst s0startOffset = s0offset;\n\t\t\t\ts0offset = lengthAdd(s0offset, s1.lengthBefore);\n\t\t\t\tif (s1.modified) {\n\t\t\t\t\tpushEdit(s0startOffset, s0offset, s1.lengthAfter);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\nclass LengthMapping {\n\tconstructor(\n\t\t/**\n\t\t * If false, length before and length after equal.\n\t\t */\n\t\tpublic readonly modified: boolean,\n\t\tpublic readonly lengthBefore: Length,\n\t\tpublic readonly lengthAfter: Length,\n\t) {\n\t}\n\n\tsplitAt(lengthAfter: Length): [LengthMapping, LengthMapping | undefined] {\n\t\tconst remainingLengthAfter = lengthDiffNonNegative(lengthAfter, this.lengthAfter);\n\t\tif (lengthEquals(remainingLengthAfter, lengthZero)) {\n\t\t\treturn [this, undefined];\n\t\t} else if (this.modified) {\n\t\t\treturn [\n\t\t\t\tnew LengthMapping(this.modified, this.lengthBefore, lengthAfter),\n\t\t\t\tnew LengthMapping(this.modified, lengthZero, remainingLengthAfter)\n\t\t\t];\n\t\t} else {\n\t\t\treturn [\n\t\t\t\tnew LengthMapping(this.modified, lengthAfter, lengthAfter),\n\t\t\t\tnew LengthMapping(this.modified, remainingLengthAfter, remainingLengthAfter)\n\t\t\t];\n\t\t}\n\t}\n\n\ttoString(): string {\n\t\treturn `${this.modified ? 'M' : 'U'}:${lengthToObj(this.lengthBefore)} -> ${lengthToObj(this.lengthAfter)}`;\n\t}\n}\n\nfunction toLengthMapping(textEditInfos: TextEditInfo[]): LengthMapping[] {\n\tconst result: LengthMapping[] = [];\n\tlet lastOffset = lengthZero;\n\tfor (const textEditInfo of textEditInfos) {\n\t\tconst spaceLength = lengthDiffNonNegative(lastOffset, textEditInfo.startOffset);\n\t\tif (!lengthIsZero(spaceLength)) {\n\t\t\tresult.push(new LengthMapping(false, spaceLength, spaceLength));\n\t\t}\n\n\t\tconst lengthBefore = lengthDiffNonNegative(textEditInfo.startOffset, textEditInfo.endOffset);\n\t\tresult.push(new LengthMapping(true, lengthBefore, textEditInfo.newLength));\n\t\tlastOffset = textEditInfo.endOffset;\n\t}\n\treturn result;\n}\n"],
  "mappings": "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",
  "names": ["result", "s0ToS1Map"]
}
