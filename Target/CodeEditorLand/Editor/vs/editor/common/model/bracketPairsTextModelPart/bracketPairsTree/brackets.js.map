{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/brackets.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { escapeRegExpCharacters } from '../../../../../base/common/strings.js';\nimport { ResolvedLanguageConfiguration } from '../../../languages/languageConfigurationRegistry.js';\nimport { BracketKind } from '../../../languages/supports/languageBracketsConfiguration.js';\nimport { BracketAstNode } from './ast.js';\nimport { toLength } from './length.js';\nimport { DenseKeyProvider, identityKeyProvider, SmallImmutableSet } from './smallImmutableSet.js';\nimport { OpeningBracketId, Token, TokenKind } from './tokenizer.js';\n\nexport class BracketTokens {\n\tstatic createFromLanguage(configuration: ResolvedLanguageConfiguration, denseKeyProvider: DenseKeyProvider<string>): BracketTokens {\n\t\tfunction getId(bracketInfo: BracketKind): OpeningBracketId {\n\t\t\treturn denseKeyProvider.getKey(`${bracketInfo.languageId}:::${bracketInfo.bracketText}`);\n\t\t}\n\n\t\tconst map = new Map<string, Token>();\n\t\tfor (const openingBracket of configuration.bracketsNew.openingBrackets) {\n\t\t\tconst length = toLength(0, openingBracket.bracketText.length);\n\t\t\tconst openingTextId = getId(openingBracket);\n\t\t\tconst bracketIds = SmallImmutableSet.getEmpty().add(openingTextId, identityKeyProvider);\n\t\t\tmap.set(openingBracket.bracketText, new Token(\n\t\t\t\tlength,\n\t\t\t\tTokenKind.OpeningBracket,\n\t\t\t\topeningTextId,\n\t\t\t\tbracketIds,\n\t\t\t\tBracketAstNode.create(length, openingBracket, bracketIds)\n\t\t\t));\n\t\t}\n\n\t\tfor (const closingBracket of configuration.bracketsNew.closingBrackets) {\n\t\t\tconst length = toLength(0, closingBracket.bracketText.length);\n\t\t\tlet bracketIds = SmallImmutableSet.getEmpty();\n\t\t\tconst closingBrackets = closingBracket.getOpeningBrackets();\n\t\t\tfor (const bracket of closingBrackets) {\n\t\t\t\tbracketIds = bracketIds.add(getId(bracket), identityKeyProvider);\n\t\t\t}\n\t\t\tmap.set(closingBracket.bracketText, new Token(\n\t\t\t\tlength,\n\t\t\t\tTokenKind.ClosingBracket,\n\t\t\t\tgetId(closingBrackets[0]),\n\t\t\t\tbracketIds,\n\t\t\t\tBracketAstNode.create(length, closingBracket, bracketIds)\n\t\t\t));\n\t\t}\n\n\t\treturn new BracketTokens(map);\n\t}\n\n\tprivate hasRegExp = false;\n\tprivate _regExpGlobal: RegExp | null = null;\n\n\tconstructor(\n\t\tprivate readonly map: Map<string, Token>\n\t) { }\n\n\tgetRegExpStr(): string | null {\n\t\tif (this.isEmpty) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tconst keys = [...this.map.keys()];\n\t\t\tkeys.sort();\n\t\t\tkeys.reverse();\n\t\t\treturn keys.map(k => prepareBracketForRegExp(k)).join('|');\n\t\t}\n\t}\n\n\t/**\n\t * Returns null if there is no such regexp (because there are no brackets).\n\t*/\n\tget regExpGlobal(): RegExp | null {\n\t\tif (!this.hasRegExp) {\n\t\t\tconst regExpStr = this.getRegExpStr();\n\t\t\tthis._regExpGlobal = regExpStr ? new RegExp(regExpStr, 'gi') : null;\n\t\t\tthis.hasRegExp = true;\n\t\t}\n\t\treturn this._regExpGlobal;\n\t}\n\n\tgetToken(value: string): Token | undefined {\n\t\treturn this.map.get(value.toLowerCase());\n\t}\n\n\tfindClosingTokenText(openingBracketIds: SmallImmutableSet<OpeningBracketId>): string | undefined {\n\t\tfor (const [closingText, info] of this.map) {\n\t\t\tif (info.kind === TokenKind.ClosingBracket && info.bracketIds.intersects(openingBracketIds)) {\n\t\t\t\treturn closingText;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tget isEmpty(): boolean {\n\t\treturn this.map.size === 0;\n\t}\n}\n\nfunction prepareBracketForRegExp(str: string): string {\n\tlet escaped = escapeRegExpCharacters(str);\n\t// These bracket pair delimiters start or end with letters\n\t// see https://github.com/microsoft/vscode/issues/132162 https://github.com/microsoft/vscode/issues/150440\n\tif (/^[\\w ]+/.test(str)) {\n\t\tescaped = `\\\\b${escaped}`;\n\t}\n\tif (/[\\w ]+$/.test(str)) {\n\t\tescaped = `${escaped}\\\\b`;\n\t}\n\treturn escaped;\n}\n\nexport class LanguageAgnosticBracketTokens {\n\tprivate readonly languageIdToBracketTokens = new Map<string, BracketTokens>();\n\n\tconstructor(\n\t\tprivate readonly denseKeyProvider: DenseKeyProvider<string>,\n\t\tprivate readonly getLanguageConfiguration: (languageId: string) => ResolvedLanguageConfiguration,\n\t) {\n\t}\n\n\tpublic didLanguageChange(languageId: string): boolean {\n\t\t// Report a change whenever the language configuration updates.\n\t\treturn this.languageIdToBracketTokens.has(languageId);\n\t}\n\n\tgetSingleLanguageBracketTokens(languageId: string): BracketTokens {\n\t\tlet singleLanguageBracketTokens = this.languageIdToBracketTokens.get(languageId);\n\t\tif (!singleLanguageBracketTokens) {\n\t\t\tsingleLanguageBracketTokens = BracketTokens.createFromLanguage(this.getLanguageConfiguration(languageId), this.denseKeyProvider);\n\t\t\tthis.languageIdToBracketTokens.set(languageId, singleLanguageBracketTokens);\n\t\t}\n\t\treturn singleLanguageBracketTokens;\n\t}\n\n\tgetToken(value: string, languageId: string): Token | undefined {\n\t\tconst singleLanguageBracketTokens = this.getSingleLanguageBracketTokens(languageId);\n\t\treturn singleLanguageBracketTokens.getToken(value);\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
