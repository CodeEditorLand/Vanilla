{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/nodeReader.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { AstNode } from './ast.js';\nimport { lengthAdd, lengthZero, Length, lengthLessThan } from './length.js';\n\n/**\n * Allows to efficiently find a longest child at a given offset in a fixed node.\n * The requested offsets must increase monotonously.\n*/\nexport class NodeReader {\n\tprivate readonly nextNodes: AstNode[];\n\tprivate readonly offsets: Length[];\n\tprivate readonly idxs: number[];\n\tprivate lastOffset: Length = lengthZero;\n\n\tconstructor(node: AstNode) {\n\t\tthis.nextNodes = [node];\n\t\tthis.offsets = [lengthZero];\n\t\tthis.idxs = [];\n\t}\n\n\t/**\n\t * Returns the longest node at `offset` that satisfies the predicate.\n\t * @param offset must be greater than or equal to the last offset this method has been called with!\n\t*/\n\treadLongestNodeAt(offset: Length, predicate: (node: AstNode) => boolean): AstNode | undefined {\n\t\tif (lengthLessThan(offset, this.lastOffset)) {\n\t\t\tthrow new Error('Invalid offset');\n\t\t}\n\t\tthis.lastOffset = offset;\n\n\t\t// Find the longest node of all those that are closest to the current offset.\n\t\twhile (true) {\n\t\t\tconst curNode = lastOrUndefined(this.nextNodes);\n\n\t\t\tif (!curNode) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tconst curNodeOffset = lastOrUndefined(this.offsets)!;\n\n\t\t\tif (lengthLessThan(offset, curNodeOffset)) {\n\t\t\t\t// The next best node is not here yet.\n\t\t\t\t// The reader must advance before a cached node is hit.\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tif (lengthLessThan(curNodeOffset, offset)) {\n\t\t\t\t// The reader is ahead of the current node.\n\t\t\t\tif (lengthAdd(curNodeOffset, curNode.length) <= offset) {\n\t\t\t\t\t// The reader is after the end of the current node.\n\t\t\t\t\tthis.nextNodeAfterCurrent();\n\t\t\t\t} else {\n\t\t\t\t\t// The reader is somewhere in the current node.\n\t\t\t\t\tconst nextChildIdx = getNextChildIdx(curNode);\n\t\t\t\t\tif (nextChildIdx !== -1) {\n\t\t\t\t\t\t// Go to the first child and repeat.\n\t\t\t\t\t\tthis.nextNodes.push(curNode.getChild(nextChildIdx)!);\n\t\t\t\t\t\tthis.offsets.push(curNodeOffset);\n\t\t\t\t\t\tthis.idxs.push(nextChildIdx);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// We don't have children\n\t\t\t\t\t\tthis.nextNodeAfterCurrent();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// readerOffsetBeforeChange === curNodeOffset\n\t\t\t\tif (predicate(curNode)) {\n\t\t\t\t\tthis.nextNodeAfterCurrent();\n\t\t\t\t\treturn curNode;\n\t\t\t\t} else {\n\t\t\t\t\tconst nextChildIdx = getNextChildIdx(curNode);\n\t\t\t\t\t// look for shorter node\n\t\t\t\t\tif (nextChildIdx === -1) {\n\t\t\t\t\t\t// There is no shorter node.\n\t\t\t\t\t\tthis.nextNodeAfterCurrent();\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Descend into first child & repeat.\n\t\t\t\t\t\tthis.nextNodes.push(curNode.getChild(nextChildIdx)!);\n\t\t\t\t\t\tthis.offsets.push(curNodeOffset);\n\t\t\t\t\t\tthis.idxs.push(nextChildIdx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Navigates to the longest node that continues after the current node.\n\tprivate nextNodeAfterCurrent(): void {\n\t\twhile (true) {\n\t\t\tconst currentOffset = lastOrUndefined(this.offsets);\n\t\t\tconst currentNode = lastOrUndefined(this.nextNodes);\n\t\t\tthis.nextNodes.pop();\n\t\t\tthis.offsets.pop();\n\n\t\t\tif (this.idxs.length === 0) {\n\t\t\t\t// We just popped the root node, there is no next node.\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Parent is not undefined, because idxs is not empty\n\t\t\tconst parent = lastOrUndefined(this.nextNodes)!;\n\t\t\tconst nextChildIdx = getNextChildIdx(parent, this.idxs[this.idxs.length - 1]);\n\n\t\t\tif (nextChildIdx !== -1) {\n\t\t\t\tthis.nextNodes.push(parent.getChild(nextChildIdx)!);\n\t\t\t\tthis.offsets.push(lengthAdd(currentOffset!, currentNode!.length));\n\t\t\t\tthis.idxs[this.idxs.length - 1] = nextChildIdx;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tthis.idxs.pop();\n\t\t\t}\n\t\t\t// We fully consumed the parent.\n\t\t\t// Current node is now parent, so call nextNodeAfterCurrent again\n\t\t}\n\t}\n}\n\nfunction getNextChildIdx(node: AstNode, curIdx: number = -1): number | -1 {\n\twhile (true) {\n\t\tcurIdx++;\n\t\tif (curIdx >= node.childrenLength) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (node.getChild(curIdx)) {\n\t\t\treturn curIdx;\n\t\t}\n\t}\n}\n\nfunction lastOrUndefined<T>(arr: readonly T[]): T | undefined {\n\treturn arr.length > 0 ? arr[arr.length - 1] : undefined;\n}\n"],
  "mappings": ";;AAKA,SAAS,eAAe;AACxB,SAAS,WAAW,YAAY,QAAQ,sBAAsB;AAMvD,MAAM,WAAW;AAAA,EAZxB,OAYwB;AAAA;AAAA;AAAA,EACN;AAAA,EACA;AAAA,EACA;AAAA,EACT,aAAqB;AAAA,EAE7B,YAAY,MAAe;AAC1B,SAAK,YAAY,CAAC,IAAI;AACtB,SAAK,UAAU,CAAC,UAAU;AAC1B,SAAK,OAAO,CAAC;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,kBAAkB,QAAgB,WAA4D;AAC7F,QAAI,eAAe,QAAQ,KAAK,UAAU,GAAG;AAC5C,YAAM,IAAI,MAAM,gBAAgB;AAAA,IACjC;AACA,SAAK,aAAa;AAGlB,WAAO,MAAM;AACZ,YAAM,UAAU,gBAAgB,KAAK,SAAS;AAE9C,UAAI,CAAC,SAAS;AACb,eAAO;AAAA,MACR;AACA,YAAM,gBAAgB,gBAAgB,KAAK,OAAO;AAElD,UAAI,eAAe,QAAQ,aAAa,GAAG;AAG1C,eAAO;AAAA,MACR;AAEA,UAAI,eAAe,eAAe,MAAM,GAAG;AAE1C,YAAI,UAAU,eAAe,QAAQ,MAAM,KAAK,QAAQ;AAEvD,eAAK,qBAAqB;AAAA,QAC3B,OAAO;AAEN,gBAAM,eAAe,gBAAgB,OAAO;AAC5C,cAAI,iBAAiB,IAAI;AAExB,iBAAK,UAAU,KAAK,QAAQ,SAAS,YAAY,CAAE;AACnD,iBAAK,QAAQ,KAAK,aAAa;AAC/B,iBAAK,KAAK,KAAK,YAAY;AAAA,UAC5B,OAAO;AAEN,iBAAK,qBAAqB;AAAA,UAC3B;AAAA,QACD;AAAA,MACD,OAAO;AAEN,YAAI,UAAU,OAAO,GAAG;AACvB,eAAK,qBAAqB;AAC1B,iBAAO;AAAA,QACR,OAAO;AACN,gBAAM,eAAe,gBAAgB,OAAO;AAE5C,cAAI,iBAAiB,IAAI;AAExB,iBAAK,qBAAqB;AAC1B,mBAAO;AAAA,UACR,OAAO;AAEN,iBAAK,UAAU,KAAK,QAAQ,SAAS,YAAY,CAAE;AACnD,iBAAK,QAAQ,KAAK,aAAa;AAC/B,iBAAK,KAAK,KAAK,YAAY;AAAA,UAC5B;AAAA,QACD;AAAA,MACD;AAAA,IACD;AAAA,EACD;AAAA;AAAA,EAGQ,uBAA6B;AACpC,WAAO,MAAM;AACZ,YAAM,gBAAgB,gBAAgB,KAAK,OAAO;AAClD,YAAM,cAAc,gBAAgB,KAAK,SAAS;AAClD,WAAK,UAAU,IAAI;AACnB,WAAK,QAAQ,IAAI;AAEjB,UAAI,KAAK,KAAK,WAAW,GAAG;AAE3B;AAAA,MACD;AAGA,YAAM,SAAS,gBAAgB,KAAK,SAAS;AAC7C,YAAM,eAAe,gBAAgB,QAAQ,KAAK,KAAK,KAAK,KAAK,SAAS,CAAC,CAAC;AAE5E,UAAI,iBAAiB,IAAI;AACxB,aAAK,UAAU,KAAK,OAAO,SAAS,YAAY,CAAE;AAClD,aAAK,QAAQ,KAAK,UAAU,eAAgB,YAAa,MAAM,CAAC;AAChE,aAAK,KAAK,KAAK,KAAK,SAAS,CAAC,IAAI;AAClC;AAAA,MACD,OAAO;AACN,aAAK,KAAK,IAAI;AAAA,MACf;AAAA,IAGD;AAAA,EACD;AACD;AAEA,SAAS,gBAAgB,MAAe,SAAiB,IAAiB;AACzE,SAAO,MAAM;AACZ;AACA,QAAI,UAAU,KAAK,gBAAgB;AAClC,aAAO;AAAA,IACR;AACA,QAAI,KAAK,SAAS,MAAM,GAAG;AAC1B,aAAO;AAAA,IACR;AAAA,EACD;AACD;AAVS;AAYT,SAAS,gBAAmB,KAAkC;AAC7D,SAAO,IAAI,SAAS,IAAI,IAAI,IAAI,SAAS,CAAC,IAAI;AAC/C;AAFS;",
  "names": []
}
