{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { NotSupportedError } from '../../../../../base/common/errors.js';\nimport { StandardTokenType, TokenMetadata } from '../../../encodedTokenAttributes.js';\nimport { IViewLineTokens } from '../../../tokens/lineTokens.js';\nimport { BracketAstNode, TextAstNode } from './ast.js';\nimport { BracketTokens, LanguageAgnosticBracketTokens } from './brackets.js';\nimport { Length, lengthAdd, lengthDiff, lengthGetColumnCountIfZeroLineCount, lengthToObj, lengthZero, toLength } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\n\nexport interface Tokenizer {\n\treadonly offset: Length;\n\treadonly length: Length;\n\n\tread(): Token | null;\n\tpeek(): Token | null;\n\tskip(length: Length): void;\n\n\tgetText(): string;\n}\n\nexport const enum TokenKind {\n\tText = 0,\n\tOpeningBracket = 1,\n\tClosingBracket = 2,\n}\n\nexport type OpeningBracketId = number;\n\nexport class Token {\n\tconstructor(\n\t\treadonly length: Length,\n\t\treadonly kind: TokenKind,\n\t\t/**\n\t\t * If this token is an opening bracket, this is the id of the opening bracket.\n\t\t * If this token is a closing bracket, this is the id of the first opening bracket that is closed by this bracket.\n\t\t * Otherwise, it is -1.\n\t\t */\n\t\treadonly bracketId: OpeningBracketId,\n\t\t/**\n\t\t * If this token is an opening bracket, this just contains `bracketId`.\n\t\t * If this token is a closing bracket, this lists all opening bracket ids, that it closes.\n\t\t * Otherwise, it is empty.\n\t\t */\n\t\treadonly bracketIds: SmallImmutableSet<OpeningBracketId>,\n\t\treadonly astNode: BracketAstNode | TextAstNode | undefined,\n\t) { }\n}\n\nexport interface ITokenizerSource {\n\tgetValue(): string;\n\tgetLineCount(): number;\n\tgetLineLength(lineNumber: number): number;\n\n\ttokenization: {\n\t\tgetLineTokens(lineNumber: number): IViewLineTokens;\n\t};\n}\n\nexport class TextBufferTokenizer implements Tokenizer {\n\tprivate readonly textBufferLineCount: number;\n\tprivate readonly textBufferLastLineLength: number;\n\n\tprivate readonly reader = new NonPeekableTextBufferTokenizer(this.textModel, this.bracketTokens);\n\n\tconstructor(\n\t\tprivate readonly textModel: ITokenizerSource,\n\t\tprivate readonly bracketTokens: LanguageAgnosticBracketTokens\n\t) {\n\t\tthis.textBufferLineCount = textModel.getLineCount();\n\t\tthis.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n\t}\n\n\tprivate _offset: Length = lengthZero;\n\n\tget offset() {\n\t\treturn this._offset;\n\t}\n\n\tget length() {\n\t\treturn toLength(this.textBufferLineCount - 1, this.textBufferLastLineLength);\n\t}\n\n\tgetText() {\n\t\treturn this.textModel.getValue();\n\t}\n\n\tskip(length: Length): void {\n\t\tthis.didPeek = false;\n\t\tthis._offset = lengthAdd(this._offset, length);\n\t\tconst obj = lengthToObj(this._offset);\n\t\tthis.reader.setPosition(obj.lineCount, obj.columnCount);\n\t}\n\n\tprivate didPeek = false;\n\tprivate peeked: Token | null = null;\n\n\tread(): Token | null {\n\t\tlet token: Token | null;\n\t\tif (this.peeked) {\n\t\t\tthis.didPeek = false;\n\t\t\ttoken = this.peeked;\n\t\t} else {\n\t\t\ttoken = this.reader.read();\n\t\t}\n\t\tif (token) {\n\t\t\tthis._offset = lengthAdd(this._offset, token.length);\n\t\t}\n\t\treturn token;\n\t}\n\n\tpeek(): Token | null {\n\t\tif (!this.didPeek) {\n\t\t\tthis.peeked = this.reader.read();\n\t\t\tthis.didPeek = true;\n\t\t}\n\t\treturn this.peeked;\n\t}\n}\n\n/**\n * Does not support peek.\n*/\nclass NonPeekableTextBufferTokenizer {\n\tprivate readonly textBufferLineCount: number;\n\tprivate readonly textBufferLastLineLength: number;\n\n\tconstructor(private readonly textModel: ITokenizerSource, private readonly bracketTokens: LanguageAgnosticBracketTokens) {\n\t\tthis.textBufferLineCount = textModel.getLineCount();\n\t\tthis.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n\t}\n\n\tprivate lineIdx = 0;\n\tprivate line: string | null = null;\n\tprivate lineCharOffset = 0;\n\tprivate lineTokens: IViewLineTokens | null = null;\n\tprivate lineTokenOffset = 0;\n\n\tpublic setPosition(lineIdx: number, column: number): void {\n\t\t// We must not jump into a token!\n\t\tif (lineIdx === this.lineIdx) {\n\t\t\tthis.lineCharOffset = column;\n\t\t\tif (this.line !== null) {\n\t\t\t\tthis.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens!.findTokenIndexAtOffset(this.lineCharOffset);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.lineIdx = lineIdx;\n\t\t\tthis.lineCharOffset = column;\n\t\t\tthis.line = null;\n\t\t}\n\t\tthis.peekedToken = null;\n\t}\n\n\t/** Must be a zero line token. The end of the document cannot be peeked. */\n\tprivate peekedToken: Token | null = null;\n\n\tpublic read(): Token | null {\n\t\tif (this.peekedToken) {\n\t\t\tconst token = this.peekedToken;\n\t\t\tthis.peekedToken = null;\n\t\t\tthis.lineCharOffset += lengthGetColumnCountIfZeroLineCount(token.length);\n\t\t\treturn token;\n\t\t}\n\n\t\tif (this.lineIdx > this.textBufferLineCount - 1 || (this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength)) {\n\t\t\t// We are after the end\n\t\t\treturn null;\n\t\t}\n\n\t\tif (this.line === null) {\n\t\t\tthis.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n\t\t\tthis.line = this.lineTokens.getLineContent();\n\t\t\tthis.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n\t\t}\n\n\t\tconst startLineIdx = this.lineIdx;\n\t\tconst startLineCharOffset = this.lineCharOffset;\n\n\t\t// limits the length of text tokens.\n\t\t// If text tokens get too long, incremental updates will be slow\n\t\tlet lengthHeuristic = 0;\n\t\twhile (true) {\n\t\t\tconst lineTokens = this.lineTokens!;\n\t\t\tconst tokenCount = lineTokens.getCount();\n\n\t\t\tlet peekedBracketToken: Token | null = null;\n\n\t\t\tif (this.lineTokenOffset < tokenCount) {\n\t\t\t\tconst tokenMetadata = lineTokens.getMetadata(this.lineTokenOffset);\n\t\t\t\twhile (this.lineTokenOffset + 1 < tokenCount && tokenMetadata === lineTokens.getMetadata(this.lineTokenOffset + 1)) {\n\t\t\t\t\t// Skip tokens that are identical.\n\t\t\t\t\t// Sometimes, (bracket) identifiers are split up into multiple tokens.\n\t\t\t\t\tthis.lineTokenOffset++;\n\t\t\t\t}\n\n\t\t\t\tconst isOther = TokenMetadata.getTokenType(tokenMetadata) === StandardTokenType.Other;\n\t\t\t\tconst containsBracketType = TokenMetadata.containsBalancedBrackets(tokenMetadata);\n\n\t\t\t\tconst endOffset = lineTokens.getEndOffset(this.lineTokenOffset);\n\t\t\t\t// Is there a bracket token next? Only consume text.\n\t\t\t\tif (containsBracketType && isOther && this.lineCharOffset < endOffset) {\n\t\t\t\t\tconst languageId = lineTokens.getLanguageId(this.lineTokenOffset);\n\t\t\t\t\tconst text = this.line.substring(this.lineCharOffset, endOffset);\n\n\t\t\t\t\tconst brackets = this.bracketTokens.getSingleLanguageBracketTokens(languageId);\n\t\t\t\t\tconst regexp = brackets.regExpGlobal;\n\t\t\t\t\tif (regexp) {\n\t\t\t\t\t\tregexp.lastIndex = 0;\n\t\t\t\t\t\tconst match = regexp.exec(text);\n\t\t\t\t\t\tif (match) {\n\t\t\t\t\t\t\tpeekedBracketToken = brackets.getToken(match[0])!;\n\t\t\t\t\t\t\tif (peekedBracketToken) {\n\t\t\t\t\t\t\t\t// Consume leading text of the token\n\t\t\t\t\t\t\t\tthis.lineCharOffset += match.index;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlengthHeuristic += endOffset - this.lineCharOffset;\n\n\t\t\t\tif (peekedBracketToken) {\n\t\t\t\t\t// Don't skip the entire token, as a single token could contain multiple brackets.\n\n\t\t\t\t\tif (startLineIdx !== this.lineIdx || startLineCharOffset !== this.lineCharOffset) {\n\t\t\t\t\t\t// There is text before the bracket\n\t\t\t\t\t\tthis.peekedToken = peekedBracketToken;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Consume the peeked token\n\t\t\t\t\t\tthis.lineCharOffset += lengthGetColumnCountIfZeroLineCount(peekedBracketToken.length);\n\t\t\t\t\t\treturn peekedBracketToken;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Skip the entire token, as the token contains no brackets at all.\n\t\t\t\t\tthis.lineTokenOffset++;\n\t\t\t\t\tthis.lineCharOffset = endOffset;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.lineIdx === this.textBufferLineCount - 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tthis.lineIdx++;\n\t\t\t\tthis.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n\t\t\t\tthis.lineTokenOffset = 0;\n\t\t\t\tthis.line = this.lineTokens.getLineContent();\n\t\t\t\tthis.lineCharOffset = 0;\n\n\t\t\t\tlengthHeuristic += 33; // max 1000/33 = 30 lines\n\t\t\t\t// This limits the amount of work to recompute min-indentation\n\n\t\t\t\tif (lengthHeuristic > 1000) {\n\t\t\t\t\t// only break (automatically) at the end of line.\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (lengthHeuristic > 1500) {\n\t\t\t\t// Eventually break regardless of the line length so that\n\t\t\t\t// very long lines do not cause bad performance.\n\t\t\t\t// This effective limits max indentation to 500, as\n\t\t\t\t// indentation is not computed across multiple text nodes.\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// If a token contains some proper indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION}),\n\t\t// unless the line is too long.\n\t\t// Thus, the min indentation of the document is the minimum min indentation of every text node.\n\t\tconst length = lengthDiff(startLineIdx, startLineCharOffset, this.lineIdx, this.lineCharOffset);\n\t\treturn new Token(length, TokenKind.Text, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n\t}\n}\n\nexport class FastTokenizer implements Tokenizer {\n\tprivate _offset: Length = lengthZero;\n\tprivate readonly tokens: readonly Token[];\n\tprivate idx = 0;\n\n\tconstructor(private readonly text: string, brackets: BracketTokens) {\n\t\tconst regExpStr = brackets.getRegExpStr();\n\t\tconst regexp = regExpStr ? new RegExp(regExpStr + '|\\n', 'gi') : null;\n\n\t\tconst tokens: Token[] = [];\n\n\t\tlet match: RegExpExecArray | null;\n\t\tlet curLineCount = 0;\n\t\tlet lastLineBreakOffset = 0;\n\n\t\tlet lastTokenEndOffset = 0;\n\t\tlet lastTokenEndLine = 0;\n\n\t\tconst smallTextTokens0Line: Token[] = [];\n\t\tfor (let i = 0; i < 60; i++) {\n\t\t\tsmallTextTokens0Line.push(\n\t\t\t\tnew Token(\n\t\t\t\t\ttoLength(0, i), TokenKind.Text, -1, SmallImmutableSet.getEmpty(),\n\t\t\t\t\tnew TextAstNode(toLength(0, i))\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tconst smallTextTokens1Line: Token[] = [];\n\t\tfor (let i = 0; i < 60; i++) {\n\t\t\tsmallTextTokens1Line.push(\n\t\t\t\tnew Token(\n\t\t\t\t\ttoLength(1, i), TokenKind.Text, -1, SmallImmutableSet.getEmpty(),\n\t\t\t\t\tnew TextAstNode(toLength(1, i))\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tif (regexp) {\n\t\t\tregexp.lastIndex = 0;\n\t\t\t// If a token contains indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION})\n\t\t\twhile ((match = regexp.exec(text)) !== null) {\n\t\t\t\tconst curOffset = match.index;\n\t\t\t\tconst value = match[0];\n\t\t\t\tif (value === '\\n') {\n\t\t\t\t\tcurLineCount++;\n\t\t\t\t\tlastLineBreakOffset = curOffset + 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (lastTokenEndOffset !== curOffset) {\n\t\t\t\t\t\tlet token: Token;\n\t\t\t\t\t\tif (lastTokenEndLine === curLineCount) {\n\t\t\t\t\t\t\tconst colCount = curOffset - lastTokenEndOffset;\n\t\t\t\t\t\t\tif (colCount < smallTextTokens0Line.length) {\n\t\t\t\t\t\t\t\ttoken = smallTextTokens0Line[colCount];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst length = toLength(0, colCount);\n\t\t\t\t\t\t\t\ttoken = new Token(length, TokenKind.Text, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst lineCount = curLineCount - lastTokenEndLine;\n\t\t\t\t\t\t\tconst colCount = curOffset - lastLineBreakOffset;\n\t\t\t\t\t\t\tif (lineCount === 1 && colCount < smallTextTokens1Line.length) {\n\t\t\t\t\t\t\t\ttoken = smallTextTokens1Line[colCount];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst length = toLength(lineCount, colCount);\n\t\t\t\t\t\t\t\ttoken = new Token(length, TokenKind.Text, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttokens.push(token);\n\t\t\t\t\t}\n\n\t\t\t\t\t// value is matched by regexp, so the token must exist\n\t\t\t\t\ttokens.push(brackets.getToken(value)!);\n\n\t\t\t\t\tlastTokenEndOffset = curOffset + value.length;\n\t\t\t\t\tlastTokenEndLine = curLineCount;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst offset = text.length;\n\n\t\tif (lastTokenEndOffset !== offset) {\n\t\t\tconst length = (lastTokenEndLine === curLineCount)\n\t\t\t\t? toLength(0, offset - lastTokenEndOffset)\n\t\t\t\t: toLength(curLineCount - lastTokenEndLine, offset - lastLineBreakOffset);\n\t\t\ttokens.push(new Token(length, TokenKind.Text, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length)));\n\t\t}\n\n\t\tthis.length = toLength(curLineCount, offset - lastLineBreakOffset);\n\t\tthis.tokens = tokens;\n\t}\n\n\tget offset(): Length {\n\t\treturn this._offset;\n\t}\n\n\treadonly length: Length;\n\n\tread(): Token | null {\n\t\treturn this.tokens[this.idx++] || null;\n\t}\n\n\tpeek(): Token | null {\n\t\treturn this.tokens[this.idx] || null;\n\t}\n\n\tskip(length: Length): void {\n\t\tthrow new NotSupportedError();\n\t}\n\n\tgetText(): string {\n\t\treturn this.text;\n\t}\n}\n"],
  "mappings": "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",
  "names": ["TokenKind"]
}
