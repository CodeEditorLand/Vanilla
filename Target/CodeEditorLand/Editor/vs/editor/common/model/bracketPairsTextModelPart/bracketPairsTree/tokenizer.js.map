{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { NotSupportedError } from \"../../../../../base/common/errors.js\";\nimport {\n\tStandardTokenType,\n\tTokenMetadata,\n} from \"../../../encodedTokenAttributes.js\";\nimport type { IViewLineTokens } from \"../../../tokens/lineTokens.js\";\nimport { type BracketAstNode, TextAstNode } from \"./ast.js\";\nimport type {\n\tBracketTokens,\n\tLanguageAgnosticBracketTokens,\n} from \"./brackets.js\";\nimport {\n\ttype Length,\n\tlengthAdd,\n\tlengthDiff,\n\tlengthGetColumnCountIfZeroLineCount,\n\tlengthToObj,\n\tlengthZero,\n\ttoLength,\n} from \"./length.js\";\nimport { SmallImmutableSet } from \"./smallImmutableSet.js\";\n\nexport interface Tokenizer {\n\treadonly offset: Length;\n\treadonly length: Length;\n\n\tread(): Token | null;\n\tpeek(): Token | null;\n\tskip(length: Length): void;\n\n\tgetText(): string;\n}\n\nexport enum TokenKind {\n\tText = 0,\n\tOpeningBracket = 1,\n\tClosingBracket = 2,\n}\n\nexport type OpeningBracketId = number;\n\nexport class Token {\n\tconstructor(\n\t\treadonly length: Length,\n\t\treadonly kind: TokenKind,\n\t\t/**\n\t\t * If this token is an opening bracket, this is the id of the opening bracket.\n\t\t * If this token is a closing bracket, this is the id of the first opening bracket that is closed by this bracket.\n\t\t * Otherwise, it is -1.\n\t\t */\n\t\treadonly bracketId: OpeningBracketId,\n\t\t/**\n\t\t * If this token is an opening bracket, this just contains `bracketId`.\n\t\t * If this token is a closing bracket, this lists all opening bracket ids, that it closes.\n\t\t * Otherwise, it is empty.\n\t\t */\n\t\treadonly bracketIds: SmallImmutableSet<OpeningBracketId>,\n\t\treadonly astNode: BracketAstNode | TextAstNode | undefined,\n\t) {}\n}\n\nexport interface ITokenizerSource {\n\tgetValue(): string;\n\tgetLineCount(): number;\n\tgetLineLength(lineNumber: number): number;\n\n\ttokenization: {\n\t\tgetLineTokens(lineNumber: number): IViewLineTokens;\n\t};\n}\n\nexport class TextBufferTokenizer implements Tokenizer {\n\tprivate readonly textBufferLineCount: number;\n\tprivate readonly textBufferLastLineLength: number;\n\n\tprivate readonly reader = new NonPeekableTextBufferTokenizer(\n\t\tthis.textModel,\n\t\tthis.bracketTokens,\n\t);\n\n\tconstructor(\n\t\tprivate readonly textModel: ITokenizerSource,\n\t\tprivate readonly bracketTokens: LanguageAgnosticBracketTokens,\n\t) {\n\t\tthis.textBufferLineCount = textModel.getLineCount();\n\t\tthis.textBufferLastLineLength = textModel.getLineLength(\n\t\t\tthis.textBufferLineCount,\n\t\t);\n\t}\n\n\tprivate _offset: Length = lengthZero;\n\n\tget offset() {\n\t\treturn this._offset;\n\t}\n\n\tget length() {\n\t\treturn toLength(\n\t\t\tthis.textBufferLineCount - 1,\n\t\t\tthis.textBufferLastLineLength,\n\t\t);\n\t}\n\n\tgetText() {\n\t\treturn this.textModel.getValue();\n\t}\n\n\tskip(length: Length): void {\n\t\tthis.didPeek = false;\n\t\tthis._offset = lengthAdd(this._offset, length);\n\t\tconst obj = lengthToObj(this._offset);\n\t\tthis.reader.setPosition(obj.lineCount, obj.columnCount);\n\t}\n\n\tprivate didPeek = false;\n\tprivate peeked: Token | null = null;\n\n\tread(): Token | null {\n\t\tlet token: Token | null;\n\t\tif (this.peeked) {\n\t\t\tthis.didPeek = false;\n\t\t\ttoken = this.peeked;\n\t\t} else {\n\t\t\ttoken = this.reader.read();\n\t\t}\n\t\tif (token) {\n\t\t\tthis._offset = lengthAdd(this._offset, token.length);\n\t\t}\n\t\treturn token;\n\t}\n\n\tpeek(): Token | null {\n\t\tif (!this.didPeek) {\n\t\t\tthis.peeked = this.reader.read();\n\t\t\tthis.didPeek = true;\n\t\t}\n\t\treturn this.peeked;\n\t}\n}\n\n/**\n * Does not support peek.\n */\nclass NonPeekableTextBufferTokenizer {\n\tprivate readonly textBufferLineCount: number;\n\tprivate readonly textBufferLastLineLength: number;\n\n\tconstructor(\n\t\tprivate readonly textModel: ITokenizerSource,\n\t\tprivate readonly bracketTokens: LanguageAgnosticBracketTokens,\n\t) {\n\t\tthis.textBufferLineCount = textModel.getLineCount();\n\t\tthis.textBufferLastLineLength = textModel.getLineLength(\n\t\t\tthis.textBufferLineCount,\n\t\t);\n\t}\n\n\tprivate lineIdx = 0;\n\tprivate line: string | null = null;\n\tprivate lineCharOffset = 0;\n\tprivate lineTokens: IViewLineTokens | null = null;\n\tprivate lineTokenOffset = 0;\n\n\tpublic setPosition(lineIdx: number, column: number): void {\n\t\t// We must not jump into a token!\n\t\tif (lineIdx === this.lineIdx) {\n\t\t\tthis.lineCharOffset = column;\n\t\t\tif (this.line !== null) {\n\t\t\t\tthis.lineTokenOffset =\n\t\t\t\t\tthis.lineCharOffset === 0\n\t\t\t\t\t\t? 0\n\t\t\t\t\t\t: this.lineTokens!.findTokenIndexAtOffset(\n\t\t\t\t\t\t\t\tthis.lineCharOffset,\n\t\t\t\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.lineIdx = lineIdx;\n\t\t\tthis.lineCharOffset = column;\n\t\t\tthis.line = null;\n\t\t}\n\t\tthis.peekedToken = null;\n\t}\n\n\t/** Must be a zero line token. The end of the document cannot be peeked. */\n\tprivate peekedToken: Token | null = null;\n\n\tpublic read(): Token | null {\n\t\tif (this.peekedToken) {\n\t\t\tconst token = this.peekedToken;\n\t\t\tthis.peekedToken = null;\n\t\t\tthis.lineCharOffset += lengthGetColumnCountIfZeroLineCount(\n\t\t\t\ttoken.length,\n\t\t\t);\n\t\t\treturn token;\n\t\t}\n\n\t\tif (\n\t\t\tthis.lineIdx > this.textBufferLineCount - 1 ||\n\t\t\t(this.lineIdx === this.textBufferLineCount - 1 &&\n\t\t\t\tthis.lineCharOffset >= this.textBufferLastLineLength)\n\t\t) {\n\t\t\t// We are after the end\n\t\t\treturn null;\n\t\t}\n\n\t\tif (this.line === null) {\n\t\t\tthis.lineTokens = this.textModel.tokenization.getLineTokens(\n\t\t\t\tthis.lineIdx + 1,\n\t\t\t);\n\t\t\tthis.line = this.lineTokens.getLineContent();\n\t\t\tthis.lineTokenOffset =\n\t\t\t\tthis.lineCharOffset === 0\n\t\t\t\t\t? 0\n\t\t\t\t\t: this.lineTokens.findTokenIndexAtOffset(\n\t\t\t\t\t\t\tthis.lineCharOffset,\n\t\t\t\t\t\t);\n\t\t}\n\n\t\tconst startLineIdx = this.lineIdx;\n\t\tconst startLineCharOffset = this.lineCharOffset;\n\n\t\t// limits the length of text tokens.\n\t\t// If text tokens get too long, incremental updates will be slow\n\t\tlet lengthHeuristic = 0;\n\t\twhile (true) {\n\t\t\tconst lineTokens = this.lineTokens!;\n\t\t\tconst tokenCount = lineTokens.getCount();\n\n\t\t\tlet peekedBracketToken: Token | null = null;\n\n\t\t\tif (this.lineTokenOffset < tokenCount) {\n\t\t\t\tconst tokenMetadata = lineTokens.getMetadata(\n\t\t\t\t\tthis.lineTokenOffset,\n\t\t\t\t);\n\t\t\t\twhile (\n\t\t\t\t\tthis.lineTokenOffset + 1 < tokenCount &&\n\t\t\t\t\ttokenMetadata ===\n\t\t\t\t\t\tlineTokens.getMetadata(this.lineTokenOffset + 1)\n\t\t\t\t) {\n\t\t\t\t\t// Skip tokens that are identical.\n\t\t\t\t\t// Sometimes, (bracket) identifiers are split up into multiple tokens.\n\t\t\t\t\tthis.lineTokenOffset++;\n\t\t\t\t}\n\n\t\t\t\tconst isOther =\n\t\t\t\t\tTokenMetadata.getTokenType(tokenMetadata) ===\n\t\t\t\t\tStandardTokenType.Other;\n\t\t\t\tconst containsBracketType =\n\t\t\t\t\tTokenMetadata.containsBalancedBrackets(tokenMetadata);\n\n\t\t\t\tconst endOffset = lineTokens.getEndOffset(this.lineTokenOffset);\n\t\t\t\t// Is there a bracket token next? Only consume text.\n\t\t\t\tif (\n\t\t\t\t\tcontainsBracketType &&\n\t\t\t\t\tisOther &&\n\t\t\t\t\tthis.lineCharOffset < endOffset\n\t\t\t\t) {\n\t\t\t\t\tconst languageId = lineTokens.getLanguageId(\n\t\t\t\t\t\tthis.lineTokenOffset,\n\t\t\t\t\t);\n\t\t\t\t\tconst text = this.line.substring(\n\t\t\t\t\t\tthis.lineCharOffset,\n\t\t\t\t\t\tendOffset,\n\t\t\t\t\t);\n\n\t\t\t\t\tconst brackets =\n\t\t\t\t\t\tthis.bracketTokens.getSingleLanguageBracketTokens(\n\t\t\t\t\t\t\tlanguageId,\n\t\t\t\t\t\t);\n\t\t\t\t\tconst regexp = brackets.regExpGlobal;\n\t\t\t\t\tif (regexp) {\n\t\t\t\t\t\tregexp.lastIndex = 0;\n\t\t\t\t\t\tconst match = regexp.exec(text);\n\t\t\t\t\t\tif (match) {\n\t\t\t\t\t\t\tpeekedBracketToken = brackets.getToken(match[0])!;\n\t\t\t\t\t\t\tif (peekedBracketToken) {\n\t\t\t\t\t\t\t\t// Consume leading text of the token\n\t\t\t\t\t\t\t\tthis.lineCharOffset += match.index;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlengthHeuristic += endOffset - this.lineCharOffset;\n\n\t\t\t\tif (peekedBracketToken) {\n\t\t\t\t\t// Don't skip the entire token, as a single token could contain multiple brackets.\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tstartLineIdx !== this.lineIdx ||\n\t\t\t\t\t\tstartLineCharOffset !== this.lineCharOffset\n\t\t\t\t\t) {\n\t\t\t\t\t\t// There is text before the bracket\n\t\t\t\t\t\tthis.peekedToken = peekedBracketToken;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Consume the peeked token\n\t\t\t\t\t\tthis.lineCharOffset +=\n\t\t\t\t\t\t\tlengthGetColumnCountIfZeroLineCount(\n\t\t\t\t\t\t\t\tpeekedBracketToken.length,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\treturn peekedBracketToken;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Skip the entire token, as the token contains no brackets at all.\n\t\t\t\t\tthis.lineTokenOffset++;\n\t\t\t\t\tthis.lineCharOffset = endOffset;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.lineIdx === this.textBufferLineCount - 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tthis.lineIdx++;\n\t\t\t\tthis.lineTokens = this.textModel.tokenization.getLineTokens(\n\t\t\t\t\tthis.lineIdx + 1,\n\t\t\t\t);\n\t\t\t\tthis.lineTokenOffset = 0;\n\t\t\t\tthis.line = this.lineTokens.getLineContent();\n\t\t\t\tthis.lineCharOffset = 0;\n\n\t\t\t\tlengthHeuristic += 33; // max 1000/33 = 30 lines\n\t\t\t\t// This limits the amount of work to recompute min-indentation\n\n\t\t\t\tif (lengthHeuristic > 1000) {\n\t\t\t\t\t// only break (automatically) at the end of line.\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (lengthHeuristic > 1500) {\n\t\t\t\t// Eventually break regardless of the line length so that\n\t\t\t\t// very long lines do not cause bad performance.\n\t\t\t\t// This effective limits max indentation to 500, as\n\t\t\t\t// indentation is not computed across multiple text nodes.\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// If a token contains some proper indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION}),\n\t\t// unless the line is too long.\n\t\t// Thus, the min indentation of the document is the minimum min indentation of every text node.\n\t\tconst length = lengthDiff(\n\t\t\tstartLineIdx,\n\t\t\tstartLineCharOffset,\n\t\t\tthis.lineIdx,\n\t\t\tthis.lineCharOffset,\n\t\t);\n\t\treturn new Token(\n\t\t\tlength,\n\t\t\tTokenKind.Text,\n\t\t\t-1,\n\t\t\tSmallImmutableSet.getEmpty(),\n\t\t\tnew TextAstNode(length),\n\t\t);\n\t}\n}\n\nexport class FastTokenizer implements Tokenizer {\n\tprivate _offset: Length = lengthZero;\n\tprivate readonly tokens: readonly Token[];\n\tprivate idx = 0;\n\n\tconstructor(\n\t\tprivate readonly text: string,\n\t\tbrackets: BracketTokens,\n\t) {\n\t\tconst regExpStr = brackets.getRegExpStr();\n\t\tconst regexp = regExpStr ? new RegExp(regExpStr + \"|\\n\", \"gi\") : null;\n\n\t\tconst tokens: Token[] = [];\n\n\t\tlet match: RegExpExecArray | null;\n\t\tlet curLineCount = 0;\n\t\tlet lastLineBreakOffset = 0;\n\n\t\tlet lastTokenEndOffset = 0;\n\t\tlet lastTokenEndLine = 0;\n\n\t\tconst smallTextTokens0Line: Token[] = [];\n\t\tfor (let i = 0; i < 60; i++) {\n\t\t\tsmallTextTokens0Line.push(\n\t\t\t\tnew Token(\n\t\t\t\t\ttoLength(0, i),\n\t\t\t\t\tTokenKind.Text,\n\t\t\t\t\t-1,\n\t\t\t\t\tSmallImmutableSet.getEmpty(),\n\t\t\t\t\tnew TextAstNode(toLength(0, i)),\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\n\t\tconst smallTextTokens1Line: Token[] = [];\n\t\tfor (let i = 0; i < 60; i++) {\n\t\t\tsmallTextTokens1Line.push(\n\t\t\t\tnew Token(\n\t\t\t\t\ttoLength(1, i),\n\t\t\t\t\tTokenKind.Text,\n\t\t\t\t\t-1,\n\t\t\t\t\tSmallImmutableSet.getEmpty(),\n\t\t\t\t\tnew TextAstNode(toLength(1, i)),\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\n\t\tif (regexp) {\n\t\t\tregexp.lastIndex = 0;\n\t\t\t// If a token contains indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION})\n\t\t\twhile ((match = regexp.exec(text)) !== null) {\n\t\t\t\tconst curOffset = match.index;\n\t\t\t\tconst value = match[0];\n\t\t\t\tif (value === \"\\n\") {\n\t\t\t\t\tcurLineCount++;\n\t\t\t\t\tlastLineBreakOffset = curOffset + 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (lastTokenEndOffset !== curOffset) {\n\t\t\t\t\t\tlet token: Token;\n\t\t\t\t\t\tif (lastTokenEndLine === curLineCount) {\n\t\t\t\t\t\t\tconst colCount = curOffset - lastTokenEndOffset;\n\t\t\t\t\t\t\tif (colCount < smallTextTokens0Line.length) {\n\t\t\t\t\t\t\t\ttoken = smallTextTokens0Line[colCount];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst length = toLength(0, colCount);\n\t\t\t\t\t\t\t\ttoken = new Token(\n\t\t\t\t\t\t\t\t\tlength,\n\t\t\t\t\t\t\t\t\tTokenKind.Text,\n\t\t\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\t\t\tSmallImmutableSet.getEmpty(),\n\t\t\t\t\t\t\t\t\tnew TextAstNode(length),\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst lineCount = curLineCount - lastTokenEndLine;\n\t\t\t\t\t\t\tconst colCount = curOffset - lastLineBreakOffset;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tlineCount === 1 &&\n\t\t\t\t\t\t\t\tcolCount < smallTextTokens1Line.length\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\ttoken = smallTextTokens1Line[colCount];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst length = toLength(lineCount, colCount);\n\t\t\t\t\t\t\t\ttoken = new Token(\n\t\t\t\t\t\t\t\t\tlength,\n\t\t\t\t\t\t\t\t\tTokenKind.Text,\n\t\t\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\t\t\tSmallImmutableSet.getEmpty(),\n\t\t\t\t\t\t\t\t\tnew TextAstNode(length),\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttokens.push(token);\n\t\t\t\t\t}\n\n\t\t\t\t\t// value is matched by regexp, so the token must exist\n\t\t\t\t\ttokens.push(brackets.getToken(value)!);\n\n\t\t\t\t\tlastTokenEndOffset = curOffset + value.length;\n\t\t\t\t\tlastTokenEndLine = curLineCount;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst offset = text.length;\n\n\t\tif (lastTokenEndOffset !== offset) {\n\t\t\tconst length =\n\t\t\t\tlastTokenEndLine === curLineCount\n\t\t\t\t\t? toLength(0, offset - lastTokenEndOffset)\n\t\t\t\t\t: toLength(\n\t\t\t\t\t\t\tcurLineCount - lastTokenEndLine,\n\t\t\t\t\t\t\toffset - lastLineBreakOffset,\n\t\t\t\t\t\t);\n\t\t\ttokens.push(\n\t\t\t\tnew Token(\n\t\t\t\t\tlength,\n\t\t\t\t\tTokenKind.Text,\n\t\t\t\t\t-1,\n\t\t\t\t\tSmallImmutableSet.getEmpty(),\n\t\t\t\t\tnew TextAstNode(length),\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\n\t\tthis.length = toLength(curLineCount, offset - lastLineBreakOffset);\n\t\tthis.tokens = tokens;\n\t}\n\n\tget offset(): Length {\n\t\treturn this._offset;\n\t}\n\n\treadonly length: Length;\n\n\tread(): Token | null {\n\t\treturn this.tokens[this.idx++] || null;\n\t}\n\n\tpeek(): Token | null {\n\t\treturn this.tokens[this.idx] || null;\n\t}\n\n\tskip(length: Length): void {\n\t\tthrow new NotSupportedError();\n\t}\n\n\tgetText(): string {\n\t\treturn this.text;\n\t}\n}\n"],
  "mappings": "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",
  "names": ["TokenKind"]
}
