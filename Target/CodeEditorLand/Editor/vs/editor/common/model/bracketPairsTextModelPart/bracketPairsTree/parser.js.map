{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { AstNode, AstNodeKind, BracketAstNode, InvalidBracketAstNode, ListAstNode, PairAstNode, TextAstNode } from './ast.js';\nimport { BeforeEditPositionMapper, TextEditInfo } from './beforeEditPositionMapper.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nimport { lengthIsZero, lengthLessThan } from './length.js';\nimport { concat23Trees, concat23TreesOfSameHeight } from './concat23Trees.js';\nimport { NodeReader } from './nodeReader.js';\nimport { OpeningBracketId, Tokenizer, TokenKind } from './tokenizer.js';\n\n/**\n * Non incrementally built ASTs are immutable.\n*/\nexport function parseDocument(tokenizer: Tokenizer, edits: TextEditInfo[], oldNode: AstNode | undefined, createImmutableLists: boolean): AstNode {\n\tconst parser = new Parser(tokenizer, edits, oldNode, createImmutableLists);\n\treturn parser.parseDocument();\n}\n\n/**\n * Non incrementally built ASTs are immutable.\n*/\nclass Parser {\n\tprivate readonly oldNodeReader?: NodeReader;\n\tprivate readonly positionMapper: BeforeEditPositionMapper;\n\tprivate _itemsConstructed: number = 0;\n\tprivate _itemsFromCache: number = 0;\n\n\t/**\n\t * Reports how many nodes were constructed in the last parse operation.\n\t*/\n\tget nodesConstructed() {\n\t\treturn this._itemsConstructed;\n\t}\n\n\t/**\n\t * Reports how many nodes were reused in the last parse operation.\n\t*/\n\tget nodesReused() {\n\t\treturn this._itemsFromCache;\n\t}\n\n\tconstructor(\n\t\tprivate readonly tokenizer: Tokenizer,\n\t\tedits: TextEditInfo[],\n\t\toldNode: AstNode | undefined,\n\t\tprivate readonly createImmutableLists: boolean,\n\t) {\n\t\tif (oldNode && createImmutableLists) {\n\t\t\tthrow new Error('Not supported');\n\t\t}\n\n\t\tthis.oldNodeReader = oldNode ? new NodeReader(oldNode) : undefined;\n\t\tthis.positionMapper = new BeforeEditPositionMapper(edits);\n\t}\n\n\tparseDocument(): AstNode {\n\t\tthis._itemsConstructed = 0;\n\t\tthis._itemsFromCache = 0;\n\n\t\tlet result = this.parseList(SmallImmutableSet.getEmpty(), 0);\n\t\tif (!result) {\n\t\t\tresult = ListAstNode.getEmpty();\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate parseList(\n\t\topenedBracketIds: SmallImmutableSet<OpeningBracketId>,\n\t\tlevel: number,\n\t): AstNode | null {\n\t\tconst items: AstNode[] = [];\n\n\t\twhile (true) {\n\t\t\tlet child = this.tryReadChildFromCache(openedBracketIds);\n\n\t\t\tif (!child) {\n\t\t\t\tconst token = this.tokenizer.peek();\n\t\t\t\tif (\n\t\t\t\t\t!token ||\n\t\t\t\t\t(token.kind === TokenKind.ClosingBracket &&\n\t\t\t\t\t\ttoken.bracketIds.intersects(openedBracketIds))\n\t\t\t\t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tchild = this.parseChild(openedBracketIds, level + 1);\n\t\t\t}\n\n\t\t\tif (child.kind === AstNodeKind.List && child.childrenLength === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\titems.push(child);\n\t\t}\n\n\t\t// When there is no oldNodeReader, all items are created from scratch and must have the same height.\n\t\tconst result = this.oldNodeReader ? concat23Trees(items) : concat23TreesOfSameHeight(items, this.createImmutableLists);\n\t\treturn result;\n\t}\n\n\tprivate tryReadChildFromCache(openedBracketIds: SmallImmutableSet<number>): AstNode | undefined {\n\t\tif (this.oldNodeReader) {\n\t\t\tconst maxCacheableLength = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);\n\t\t\tif (maxCacheableLength === null || !lengthIsZero(maxCacheableLength)) {\n\t\t\t\tconst cachedNode = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), curNode => {\n\t\t\t\t\t// The edit could extend the ending token, thus we cannot re-use nodes that touch the edit.\n\t\t\t\t\t// If there is no edit anymore, we can re-use the node in any case.\n\t\t\t\t\tif (maxCacheableLength !== null && !lengthLessThan(curNode.length, maxCacheableLength)) {\n\t\t\t\t\t\t// Either the node contains edited text or touches edited text.\n\t\t\t\t\t\t// In the latter case, brackets might have been extended (`end` -> `ending`), so even touching nodes cannot be reused.\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tconst canBeReused = curNode.canBeReused(openedBracketIds);\n\t\t\t\t\treturn canBeReused;\n\t\t\t\t});\n\n\t\t\t\tif (cachedNode) {\n\t\t\t\t\tthis._itemsFromCache++;\n\t\t\t\t\tthis.tokenizer.skip(cachedNode.length);\n\t\t\t\t\treturn cachedNode;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tprivate parseChild(\n\t\topenedBracketIds: SmallImmutableSet<number>,\n\t\tlevel: number,\n\t): AstNode {\n\t\tthis._itemsConstructed++;\n\n\t\tconst token = this.tokenizer.read()!;\n\n\t\tswitch (token.kind) {\n\t\t\tcase TokenKind.ClosingBracket:\n\t\t\t\treturn new InvalidBracketAstNode(token.bracketIds, token.length);\n\n\t\t\tcase TokenKind.Text:\n\t\t\t\treturn token.astNode as TextAstNode;\n\n\t\t\tcase TokenKind.OpeningBracket: {\n\t\t\t\tif (level > 300) {\n\t\t\t\t\t// To prevent stack overflows\n\t\t\t\t\treturn new TextAstNode(token.length);\n\t\t\t\t}\n\n\t\t\t\tconst set = openedBracketIds.merge(token.bracketIds);\n\t\t\t\tconst child = this.parseList(set, level + 1);\n\n\t\t\t\tconst nextToken = this.tokenizer.peek();\n\t\t\t\tif (\n\t\t\t\t\tnextToken &&\n\t\t\t\t\tnextToken.kind === TokenKind.ClosingBracket &&\n\t\t\t\t\t(nextToken.bracketId === token.bracketId || nextToken.bracketIds.intersects(token.bracketIds))\n\t\t\t\t) {\n\t\t\t\t\tthis.tokenizer.read();\n\t\t\t\t\treturn PairAstNode.create(\n\t\t\t\t\t\ttoken.astNode as BracketAstNode,\n\t\t\t\t\t\tchild,\n\t\t\t\t\t\tnextToken.astNode as BracketAstNode\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\treturn PairAstNode.create(\n\t\t\t\t\t\ttoken.astNode as BracketAstNode,\n\t\t\t\t\t\tchild,\n\t\t\t\t\t\tnull\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new Error('unexpected');\n\t\t}\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
