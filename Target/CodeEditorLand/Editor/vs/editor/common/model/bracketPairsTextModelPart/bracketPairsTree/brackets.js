import{escapeRegExpCharacters as m}from"../../../../../base/common/strings.js";import{BracketAstNode as k}from"./ast.js";import{toLength as p}from"./length.js";import{SmallImmutableSet as u,identityKeyProvider as d}from"./smallImmutableSet.js";import{Token as f,TokenKind as c}from"./tokenizer.js";class l{constructor(e){this.map=e}static createFromLanguage(e,t){function r(n){return t.getKey(`${n.languageId}:::${n.bracketText}`)}const i=new Map;for(const n of e.bracketsNew.openingBrackets){const g=p(0,n.bracketText.length),a=r(n),o=u.getEmpty().add(a,d);i.set(n.bracketText,new f(g,c.OpeningBracket,a,o,k.create(g,n,o)))}for(const n of e.bracketsNew.closingBrackets){const g=p(0,n.bracketText.length);let a=u.getEmpty();const o=n.getOpeningBrackets();for(const T of o)a=a.add(r(T),d);i.set(n.bracketText,new f(g,c.ClosingBracket,r(o[0]),a,k.create(g,n,a)))}return new l(i)}hasRegExp=!1;_regExpGlobal=null;getRegExpStr(){if(this.isEmpty)return null;{const e=[...this.map.keys()];return e.sort(),e.reverse(),e.map(t=>B(t)).join("|")}}get regExpGlobal(){if(!this.hasRegExp){const e=this.getRegExpStr();this._regExpGlobal=e?new RegExp(e,"gi"):null,this.hasRegExp=!0}return this._regExpGlobal}getToken(e){return this.map.get(e.toLowerCase())}findClosingTokenText(e){for(const[t,r]of this.map)if(r.kind===c.ClosingBracket&&r.bracketIds.intersects(e))return t}get isEmpty(){return this.map.size===0}}function B(s){let e=m(s);return/^[\w ]+/.test(s)&&(e=`\\b${e}`),/[\w ]+$/.test(s)&&(e=`${e}\\b`),e}class v{constructor(e,t){this.denseKeyProvider=e;this.getLanguageConfiguration=t}languageIdToBracketTokens=new Map;didLanguageChange(e){return this.languageIdToBracketTokens.has(e)}getSingleLanguageBracketTokens(e){let t=this.languageIdToBracketTokens.get(e);return t||(t=l.createFromLanguage(this.getLanguageConfiguration(e),this.denseKeyProvider),this.languageIdToBracketTokens.set(e,t)),t}getToken(e,t){return this.getSingleLanguageBracketTokens(t).getToken(e)}}export{l as BracketTokens,v as LanguageAgnosticBracketTokens};
