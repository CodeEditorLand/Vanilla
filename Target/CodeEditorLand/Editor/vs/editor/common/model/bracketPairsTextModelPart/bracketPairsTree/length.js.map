{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { splitLines } from \"../../../../../base/common/strings.js\";\nimport { Position } from \"../../../core/position.js\";\nimport { Range } from \"../../../core/range.js\";\nimport { TextLength } from \"../../../core/textLength.js\";\n\n/**\n * The end must be greater than or equal to the start.\n */\nexport function lengthDiff(\n\tstartLineCount: number,\n\tstartColumnCount: number,\n\tendLineCount: number,\n\tendColumnCount: number,\n): Length {\n\treturn startLineCount !== endLineCount\n\t\t? toLength(endLineCount - startLineCount, endColumnCount)\n\t\t: toLength(0, endColumnCount - startColumnCount);\n}\n\n/**\n * Represents a non-negative length in terms of line and column count.\n * Does not allocate.\n */\nexport type Length = { _brand: \"Length\" };\n\nexport const lengthZero = 0 as any as Length;\n\nexport function lengthIsZero(length: Length): boolean {\n\treturn (length as any as number) === 0;\n}\n\n/*\n * We have 52 bits available in a JS number.\n * We use the upper 26 bits to store the line and the lower 26 bits to store the column.\n */\n///*\nconst factor = 2 ** 26;\n/*/\nconst factor = 1000000;\n// */\n\nexport function toLength(lineCount: number, columnCount: number): Length {\n\t// llllllllllllllllllllllllllcccccccccccccccccccccccccc (52 bits)\n\t//       line count (26 bits)    column count (26 bits)\n\n\t// If there is no overflow (all values/sums below 2^26 = 67108864),\n\t// we have `toLength(lns1, cols1) + toLength(lns2, cols2) = toLength(lns1 + lns2, cols1 + cols2)`.\n\n\treturn (lineCount * factor + columnCount) as any as Length;\n}\n\nexport function lengthToObj(length: Length): TextLength {\n\tconst l = length as any as number;\n\tconst lineCount = Math.floor(l / factor);\n\tconst columnCount = l - lineCount * factor;\n\treturn new TextLength(lineCount, columnCount);\n}\n\nexport function lengthGetLineCount(length: Length): number {\n\treturn Math.floor((length as any as number) / factor);\n}\n\n/**\n * Returns the amount of columns of the given length, assuming that it does not span any line.\n */\nexport function lengthGetColumnCountIfZeroLineCount(length: Length): number {\n\treturn length as any as number;\n}\n\n// [10 lines, 5 cols] + [ 0 lines, 3 cols] = [10 lines, 8 cols]\n// [10 lines, 5 cols] + [20 lines, 3 cols] = [30 lines, 3 cols]\nexport function lengthAdd(length1: Length, length2: Length): Length;\nexport function lengthAdd(l1: any, l2: any): Length {\n\tlet r = l1 + l2;\n\tif (l2 >= factor) {\n\t\tr = r - (l1 % factor);\n\t}\n\treturn r;\n}\n\nexport function sumLengths<T>(\n\titems: readonly T[],\n\tlengthFn: (item: T) => Length,\n): Length {\n\treturn items.reduce((a, b) => lengthAdd(a, lengthFn(b)), lengthZero);\n}\n\nexport function lengthEquals(length1: Length, length2: Length): boolean {\n\treturn length1 === length2;\n}\n\n/**\n * Returns a non negative length `result` such that `lengthAdd(length1, result) = length2`, or zero if such length does not exist.\n */\nexport function lengthDiffNonNegative(\n\tlength1: Length,\n\tlength2: Length,\n): Length {\n\tconst l1 = length1 as any as number;\n\tconst l2 = length2 as any as number;\n\n\tconst diff = l2 - l1;\n\tif (diff <= 0) {\n\t\t// line-count of length1 is higher than line-count of length2\n\t\t// or they are equal and column-count of length1 is higher than column-count of length2\n\t\treturn lengthZero;\n\t}\n\n\tconst lineCount1 = Math.floor(l1 / factor);\n\tconst lineCount2 = Math.floor(l2 / factor);\n\n\tconst colCount2 = l2 - lineCount2 * factor;\n\n\tif (lineCount1 === lineCount2) {\n\t\tconst colCount1 = l1 - lineCount1 * factor;\n\t\treturn toLength(0, colCount2 - colCount1);\n\t} else {\n\t\treturn toLength(lineCount2 - lineCount1, colCount2);\n\t}\n}\n\nexport function lengthLessThan(length1: Length, length2: Length): boolean {\n\t// First, compare line counts, then column counts.\n\treturn (length1 as any as number) < (length2 as any as number);\n}\n\nexport function lengthLessThanEqual(length1: Length, length2: Length): boolean {\n\treturn (length1 as any as number) <= (length2 as any as number);\n}\n\nexport function lengthGreaterThanEqual(\n\tlength1: Length,\n\tlength2: Length,\n): boolean {\n\treturn (length1 as any as number) >= (length2 as any as number);\n}\n\nexport function lengthToPosition(length: Length): Position {\n\tconst l = length as any as number;\n\tconst lineCount = Math.floor(l / factor);\n\tconst colCount = l - lineCount * factor;\n\treturn new Position(lineCount + 1, colCount + 1);\n}\n\nexport function positionToLength(position: Position): Length {\n\treturn toLength(position.lineNumber - 1, position.column - 1);\n}\n\nexport function lengthsToRange(lengthStart: Length, lengthEnd: Length): Range {\n\tconst l = lengthStart as any as number;\n\tconst lineCount = Math.floor(l / factor);\n\tconst colCount = l - lineCount * factor;\n\n\tconst l2 = lengthEnd as any as number;\n\tconst lineCount2 = Math.floor(l2 / factor);\n\tconst colCount2 = l2 - lineCount2 * factor;\n\n\treturn new Range(\n\t\tlineCount + 1,\n\t\tcolCount + 1,\n\t\tlineCount2 + 1,\n\t\tcolCount2 + 1,\n\t);\n}\n\nexport function lengthOfRange(range: Range): TextLength {\n\tif (range.startLineNumber === range.endLineNumber) {\n\t\treturn new TextLength(0, range.endColumn - range.startColumn);\n\t} else {\n\t\treturn new TextLength(\n\t\t\trange.endLineNumber - range.startLineNumber,\n\t\t\trange.endColumn - 1,\n\t\t);\n\t}\n}\n\nexport function lengthCompare(length1: Length, length2: Length): number {\n\tconst l1 = length1 as any as number;\n\tconst l2 = length2 as any as number;\n\treturn l1 - l2;\n}\n\nexport function lengthOfString(str: string): Length {\n\tconst lines = splitLines(str);\n\treturn toLength(lines.length - 1, lines[lines.length - 1].length);\n}\n\nexport function lengthOfStringObj(str: string): TextLength {\n\tconst lines = splitLines(str);\n\treturn new TextLength(lines.length - 1, lines[lines.length - 1].length);\n}\n\n/**\n * Computes a numeric hash of the given length.\n */\nexport function lengthHash(length: Length): number {\n\treturn length as any;\n}\n\nexport function lengthMax(length1: Length, length2: Length): Length {\n\treturn length1 > length2 ? length1 : length2;\n}\n"],
  "mappings": "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",
  "names": []
}
