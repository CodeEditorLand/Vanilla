import{CharCode as _}from"../../../../base/common/charCode.js";import{Position as F}from"../../core/position.js";import{Range as P}from"../../core/range.js";import{FindMatch as M}from"../../model.js";import{Searcher as W,createFindMatch as v,isValidMatch as U}from"../textModelSearch.js";import{NodeColor as A,SENTINEL as d,TreeNode as y,fixInsert as z,leftest as k,rbDelete as T,righttest as j,updateTreeMetadata as S}from"./rbTreeBase.js";const I=65535;function R(b){let e;return b[b.length-1]<65536?e=new Uint16Array(b.length):e=new Uint32Array(b.length),e.set(b,0),e}class H{constructor(e,n,t,i,r){this.lineStarts=e;this.cr=n;this.lf=t;this.crlf=i;this.isBasicASCII=r}}function B(b,e=!0){const n=[0];let t=1;for(let i=0,r=b.length;i<r;i++){const s=b.charCodeAt(i);s===_.CarriageReturn?i+1<r&&b.charCodeAt(i+1)===_.LineFeed?(n[t++]=i+2,i++):n[t++]=i+1:s===_.LineFeed&&(n[t++]=i+1)}return e?R(n):n}function Y(b,e){b.length=0,b[0]=0;let n=1,t=0,i=0,r=0,s=!0;for(let f=0,u=e.length;f<u;f++){const l=e.charCodeAt(f);l===_.CarriageReturn?f+1<u&&e.charCodeAt(f+1)===_.LineFeed?(r++,b[n++]=f+2,f++):(t++,b[n++]=f+1):l===_.LineFeed?(i++,b[n++]=f+1):s&&l!==_.Tab&&(l<32||l>126)&&(s=!1)}const o=new H(R(b),t,i,r,s);return b.length=0,o}class C{bufferIndex;start;end;length;lineFeedCnt;constructor(e,n,t,i,r){this.bufferIndex=e,this.start=n,this.end=t,this.lineFeedCnt=i,this.length=r}}class w{buffer;lineStarts;constructor(e,n){this.buffer=e,this.lineStarts=n}}class ${_pieces;_index;_tree;_BOM;constructor(e,n){this._pieces=[],this._tree=e,this._BOM=n,this._index=0,e.root!==d&&e.iterate(e.root,t=>(t!==d&&this._pieces.push(t.piece),!0))}read(){return this._pieces.length===0?this._index===0?(this._index++,this._BOM):null:this._index>this._pieces.length-1?null:this._index===0?this._BOM+this._tree.getPieceContent(this._pieces[this._index++]):this._tree.getPieceContent(this._pieces[this._index++])}}class q{_limit;_cache;constructor(e){this._limit=e,this._cache=[]}get(e){for(let n=this._cache.length-1;n>=0;n--){const t=this._cache[n];if(t.nodeStartOffset<=e&&t.nodeStartOffset+t.node.piece.length>=e)return t}return null}get2(e){for(let n=this._cache.length-1;n>=0;n--){const t=this._cache[n];if(t.nodeStartLineNumber&&t.nodeStartLineNumber<e&&t.nodeStartLineNumber+t.node.piece.lineFeedCnt>=e)return t}return null}set(e){this._cache.length>=this._limit&&this._cache.shift(),this._cache.push(e)}validate(e){let n=!1;const t=this._cache;for(let i=0;i<t.length;i++){const r=t[i];if(r.node.parent===null||r.nodeStartOffset>=e){t[i]=null,n=!0;continue}}if(n){const i=[];for(const r of t)r!==null&&i.push(r);this._cache=i}}}class Z{root;_buffers;_lineCnt;_length;_EOL;_EOLLength;_EOLNormalized;_lastChangeBufferPos;_searchCache;_lastVisitedLine;constructor(e,n,t){this.create(e,n,t)}create(e,n,t){this._buffers=[new w("",[0])],this._lastChangeBufferPos={line:0,column:0},this.root=d,this._lineCnt=1,this._length=0,this._EOL=n,this._EOLLength=n.length,this._EOLNormalized=t;let i=null;for(let r=0,s=e.length;r<s;r++)if(e[r].buffer.length>0){e[r].lineStarts||(e[r].lineStarts=B(e[r].buffer));const o=new C(r+1,{line:0,column:0},{line:e[r].lineStarts.length-1,column:e[r].buffer.length-e[r].lineStarts[e[r].lineStarts.length-1]},e[r].lineStarts.length-1,e[r].buffer.length);this._buffers.push(e[r]),i=this.rbInsertRight(i,o)}this._searchCache=new q(1),this._lastVisitedLine={lineNumber:0,value:""},this.computeBufferMetadata()}normalizeEOL(e){const n=I,t=n-Math.floor(n/3),i=t*2;let r="",s=0;const o=[];if(this.iterate(this.root,f=>{const u=this.getNodeContent(f),l=u.length;if(s<=t||s+l<i)return r+=u,s+=l,!0;const h=r.replace(/\r\n|\r|\n/g,e);return o.push(new w(h,B(h))),r=u,s=l,!0}),s>0){const f=r.replace(/\r\n|\r|\n/g,e);o.push(new w(f,B(f)))}this.create(o,e,!0)}getEOL(){return this._EOL}setEOL(e){this._EOL=e,this._EOLLength=this._EOL.length,this.normalizeEOL(e)}createSnapshot(e){return new $(this,e)}equal(e){if(this.getLength()!==e.getLength()||this.getLineCount()!==e.getLineCount())return!1;let n=0;return this.iterate(this.root,i=>{if(i===d)return!0;const r=this.getNodeContent(i),s=r.length,o=e.nodeAt(n),f=e.nodeAt(n+s),u=e.getValueInRange2(o,f);return n+=s,r===u})}getOffsetAt(e,n){let t=0,i=this.root;for(;i!==d;)if(i.left!==d&&i.lf_left+1>=e)i=i.left;else if(i.lf_left+i.piece.lineFeedCnt+1>=e){t+=i.size_left;const r=this.getAccumulatedValue(i,e-i.lf_left-2);return t+=r+n-1}else e-=i.lf_left+i.piece.lineFeedCnt,t+=i.size_left+i.piece.length,i=i.right;return t}getPositionAt(e){e=Math.floor(e),e=Math.max(0,e);let n=this.root,t=0;const i=e;for(;n!==d;)if(n.size_left!==0&&n.size_left>=e)n=n.left;else if(n.size_left+n.piece.length>=e){const r=this.getIndexOf(n,e-n.size_left);if(t+=n.lf_left+r.index,r.index===0){const s=this.getOffsetAt(t+1,1),o=i-s;return new F(t+1,o+1)}return new F(t+1,r.remainder+1)}else if(e-=n.size_left+n.piece.length,t+=n.lf_left+n.piece.lineFeedCnt,n.right===d){const r=this.getOffsetAt(t+1,1),s=i-e-r;return new F(t+1,s+1)}else n=n.right;return new F(1,1)}getValueInRange(e,n){if(e.startLineNumber===e.endLineNumber&&e.startColumn===e.endColumn)return"";const t=this.nodeAt2(e.startLineNumber,e.startColumn),i=this.nodeAt2(e.endLineNumber,e.endColumn),r=this.getValueInRange2(t,i);return n?n!==this._EOL||!this._EOLNormalized?r.replace(/\r\n|\r|\n/g,n):n===this.getEOL()&&this._EOLNormalized?r:r.replace(/\r\n|\r|\n/g,n):r}getValueInRange2(e,n){if(e.node===n.node){const o=e.node,f=this._buffers[o.piece.bufferIndex].buffer,u=this.offsetInBuffer(o.piece.bufferIndex,o.piece.start);return f.substring(u+e.remainder,u+n.remainder)}let t=e.node;const i=this._buffers[t.piece.bufferIndex].buffer,r=this.offsetInBuffer(t.piece.bufferIndex,t.piece.start);let s=i.substring(r+e.remainder,r+t.piece.length);for(t=t.next();t!==d;){const o=this._buffers[t.piece.bufferIndex].buffer,f=this.offsetInBuffer(t.piece.bufferIndex,t.piece.start);if(t===n.node){s+=o.substring(f,f+n.remainder);break}else s+=o.substr(f,t.piece.length);t=t.next()}return s}getLinesContent(){const e=[];let n=0,t="",i=!1;return this.iterate(this.root,r=>{if(r===d)return!0;const s=r.piece;let o=s.length;if(o===0)return!0;const f=this._buffers[s.bufferIndex].buffer,u=this._buffers[s.bufferIndex].lineStarts,l=s.start.line,h=s.end.line;let c=u[l]+s.start.column;if(i&&(f.charCodeAt(c)===_.LineFeed&&(c++,o--),e[n++]=t,t="",i=!1,o===0))return!0;if(l===h)return!this._EOLNormalized&&f.charCodeAt(c+o-1)===_.CarriageReturn?(i=!0,t+=f.substr(c,o-1)):t+=f.substr(c,o),!0;t+=this._EOLNormalized?f.substring(c,Math.max(c,u[l+1]-this._EOLLength)):f.substring(c,u[l+1]).replace(/(\r\n|\r|\n)$/,""),e[n++]=t;for(let a=l+1;a<h;a++)t=this._EOLNormalized?f.substring(u[a],u[a+1]-this._EOLLength):f.substring(u[a],u[a+1]).replace(/(\r\n|\r|\n)$/,""),e[n++]=t;return!this._EOLNormalized&&f.charCodeAt(u[h]+s.end.column-1)===_.CarriageReturn?(i=!0,s.end.column===0?n--:t=f.substr(u[h],s.end.column-1)):t=f.substr(u[h],s.end.column),!0}),i&&(e[n++]=t,t=""),e[n++]=t,e}getLength(){return this._length}getLineCount(){return this._lineCnt}getLineContent(e){return this._lastVisitedLine.lineNumber===e?this._lastVisitedLine.value:(this._lastVisitedLine.lineNumber=e,e===this._lineCnt?this._lastVisitedLine.value=this.getLineRawContent(e):this._EOLNormalized?this._lastVisitedLine.value=this.getLineRawContent(e,this._EOLLength):this._lastVisitedLine.value=this.getLineRawContent(e).replace(/(\r\n|\r|\n)$/,""),this._lastVisitedLine.value)}_getCharCode(e){if(e.remainder===e.node.piece.length){const n=e.node.next();if(!n)return 0;const t=this._buffers[n.piece.bufferIndex],i=this.offsetInBuffer(n.piece.bufferIndex,n.piece.start);return t.buffer.charCodeAt(i)}else{const n=this._buffers[e.node.piece.bufferIndex],i=this.offsetInBuffer(e.node.piece.bufferIndex,e.node.piece.start)+e.remainder;return n.buffer.charCodeAt(i)}}getLineCharCode(e,n){const t=this.nodeAt2(e,n+1);return this._getCharCode(t)}getLineLength(e){if(e===this.getLineCount()){const n=this.getOffsetAt(e,1);return this.getLength()-n}return this.getOffsetAt(e+1,1)-this.getOffsetAt(e,1)-this._EOLLength}getCharCode(e){const n=this.nodeAt(e);return this._getCharCode(n)}getNearestChunk(e){const n=this.nodeAt(e);if(n.remainder===n.node.piece.length){const t=n.node.next();if(!t||t===d)return"";const i=this._buffers[t.piece.bufferIndex],r=this.offsetInBuffer(t.piece.bufferIndex,t.piece.start);return i.buffer.substring(r,r+t.piece.length)}else{const t=this._buffers[n.node.piece.bufferIndex],i=this.offsetInBuffer(n.node.piece.bufferIndex,n.node.piece.start),r=i+n.remainder,s=i+n.node.piece.length;return t.buffer.substring(r,s)}}findMatchesInNode(e,n,t,i,r,s,o,f,u,l,h){const c=this._buffers[e.piece.bufferIndex],a=this.offsetInBuffer(e.piece.bufferIndex,e.piece.start),p=this.offsetInBuffer(e.piece.bufferIndex,r),g=this.offsetInBuffer(e.piece.bufferIndex,s);let m;const L={line:0,column:0};let O,N;n._wordSeparators?(O=c.buffer.substring(p,g),N=x=>x+p,n.reset(0)):(O=c.buffer,N=x=>x,n.reset(p));do if(m=n.next(O),m){if(N(m.index)>=g)return l;this.positionInBuffer(e,N(m.index)-a,L);const x=this.getLineFeedCnt(e.piece.bufferIndex,r,L),E=L.line===r.line?L.column-r.column+i:L.column+1,V=E+m[0].length;if(h[l++]=v(new P(t+x,E,t+x,V),m,f),N(m.index)+m[0].length>=g||l>=u)return l}while(m);return l}findMatchesLineByLine(e,n,t,i){const r=[];let s=0;const o=new W(n.wordSeparators,n.regex);let f=this.nodeAt2(e.startLineNumber,e.startColumn);if(f===null)return[];const u=this.nodeAt2(e.endLineNumber,e.endColumn);if(u===null)return[];let l=this.positionInBuffer(f.node,f.remainder);const h=this.positionInBuffer(u.node,u.remainder);if(f.node===u.node)return this.findMatchesInNode(f.node,o,e.startLineNumber,e.startColumn,l,h,n,t,i,s,r),r;let c=e.startLineNumber,a=f.node;for(;a!==u.node;){const g=this.getLineFeedCnt(a.piece.bufferIndex,l,a.piece.end);if(g>=1){const L=this._buffers[a.piece.bufferIndex].lineStarts,O=this.offsetInBuffer(a.piece.bufferIndex,a.piece.start),N=L[l.line+g],x=c===e.startLineNumber?e.startColumn:1;if(s=this.findMatchesInNode(a,o,c,x,l,this.positionInBuffer(a,N-O),n,t,i,s,r),s>=i)return r;c+=g}const m=c===e.startLineNumber?e.startColumn-1:0;if(c===e.endLineNumber){const L=this.getLineContent(c).substring(m,e.endColumn-1);return s=this._findMatchesInLine(n,o,L,e.endLineNumber,m,s,r,t,i),r}if(s=this._findMatchesInLine(n,o,this.getLineContent(c).substr(m),c,m,s,r,t,i),s>=i)return r;c++,f=this.nodeAt2(c,1),a=f.node,l=this.positionInBuffer(f.node,f.remainder)}if(c===e.endLineNumber){const g=c===e.startLineNumber?e.startColumn-1:0,m=this.getLineContent(c).substring(g,e.endColumn-1);return s=this._findMatchesInLine(n,o,m,e.endLineNumber,g,s,r,t,i),r}const p=c===e.startLineNumber?e.startColumn:1;return s=this.findMatchesInNode(u.node,o,c,p,l,h,n,t,i,s,r),r}_findMatchesInLine(e,n,t,i,r,s,o,f,u){const l=e.wordSeparators;if(!f&&e.simpleSearch){const c=e.simpleSearch,a=c.length,p=t.length;let g=-a;for(;(g=t.indexOf(c,g+a))!==-1;)if((!l||U(l,t,p,g,a))&&(o[s++]=new M(new P(i,g+1+r,i,g+1+a+r),null),s>=u))return s;return s}let h;n.reset(0);do if(h=n.next(t),h&&(o[s++]=v(new P(i,h.index+1+r,i,h.index+1+h[0].length+r),h,f),s>=u))return s;while(h);return s}insert(e,n,t=!1){if(this._EOLNormalized=this._EOLNormalized&&t,this._lastVisitedLine.lineNumber=0,this._lastVisitedLine.value="",this.root!==d){const{node:i,remainder:r,nodeStartOffset:s}=this.nodeAt(e),o=i.piece,f=o.bufferIndex,u=this.positionInBuffer(i,r);if(i.piece.bufferIndex===0&&o.end.line===this._lastChangeBufferPos.line&&o.end.column===this._lastChangeBufferPos.column&&s+o.length===e&&n.length<I){this.appendToNode(i,n),this.computeBufferMetadata();return}if(s===e)this.insertContentToNodeLeft(n,i),this._searchCache.validate(e);else if(s+i.piece.length>e){const l=[];let h=new C(o.bufferIndex,u,o.end,this.getLineFeedCnt(o.bufferIndex,u,o.end),this.offsetInBuffer(f,o.end)-this.offsetInBuffer(f,u));if(this.shouldCheckCRLF()&&this.endWithCR(n)&&this.nodeCharCodeAt(i,r)===10){const g={line:h.start.line+1,column:0};h=new C(h.bufferIndex,g,h.end,this.getLineFeedCnt(h.bufferIndex,g,h.end),h.length-1),n+=`
`}if(this.shouldCheckCRLF()&&this.startWithLF(n))if(this.nodeCharCodeAt(i,r-1)===13){const g=this.positionInBuffer(i,r-1);this.deleteNodeTail(i,g),n="\r"+n,i.piece.length===0&&l.push(i)}else this.deleteNodeTail(i,u);else this.deleteNodeTail(i,u);const c=this.createNewPieces(n);h.length>0&&this.rbInsertRight(i,h);let a=i;for(let p=0;p<c.length;p++)a=this.rbInsertRight(a,c[p]);this.deleteNodes(l)}else this.insertContentToNodeRight(n,i)}else{const i=this.createNewPieces(n);let r=this.rbInsertLeft(null,i[0]);for(let s=1;s<i.length;s++)r=this.rbInsertRight(r,i[s])}this.computeBufferMetadata()}delete(e,n){if(this._lastVisitedLine.lineNumber=0,this._lastVisitedLine.value="",n<=0||this.root===d)return;const t=this.nodeAt(e),i=this.nodeAt(e+n),r=t.node,s=i.node;if(r===s){const c=this.positionInBuffer(r,t.remainder),a=this.positionInBuffer(r,i.remainder);if(t.nodeStartOffset===e){if(n===r.piece.length){const p=r.next();T(this,r),this.validateCRLFWithPrevNode(p),this.computeBufferMetadata();return}this.deleteNodeHead(r,a),this._searchCache.validate(e),this.validateCRLFWithPrevNode(r),this.computeBufferMetadata();return}if(t.nodeStartOffset+r.piece.length===e+n){this.deleteNodeTail(r,c),this.validateCRLFWithNextNode(r),this.computeBufferMetadata();return}this.shrinkNode(r,c,a),this.computeBufferMetadata();return}const o=[],f=this.positionInBuffer(r,t.remainder);this.deleteNodeTail(r,f),this._searchCache.validate(e),r.piece.length===0&&o.push(r);const u=this.positionInBuffer(s,i.remainder);this.deleteNodeHead(s,u),s.piece.length===0&&o.push(s);const l=r.next();for(let c=l;c!==d&&c!==s;c=c.next())o.push(c);const h=r.piece.length===0?r.prev():r;this.deleteNodes(o),this.validateCRLFWithNextNode(h),this.computeBufferMetadata()}insertContentToNodeLeft(e,n){const t=[];if(this.shouldCheckCRLF()&&this.endWithCR(e)&&this.startWithLF(n)){const s=n.piece,o={line:s.start.line+1,column:0},f=new C(s.bufferIndex,o,s.end,this.getLineFeedCnt(s.bufferIndex,o,s.end),s.length-1);n.piece=f,e+=`
`,S(this,n,-1,-1),n.piece.length===0&&t.push(n)}const i=this.createNewPieces(e);let r=this.rbInsertLeft(n,i[i.length-1]);for(let s=i.length-2;s>=0;s--)r=this.rbInsertLeft(r,i[s]);this.validateCRLFWithPrevNode(r),this.deleteNodes(t)}insertContentToNodeRight(e,n){this.adjustCarriageReturnFromNext(e,n)&&(e+=`
`);const t=this.createNewPieces(e),i=this.rbInsertRight(n,t[0]);let r=i;for(let s=1;s<t.length;s++)r=this.rbInsertRight(r,t[s]);this.validateCRLFWithPrevNode(i)}positionInBuffer(e,n,t){const i=e.piece,r=e.piece.bufferIndex,s=this._buffers[r].lineStarts,f=s[i.start.line]+i.start.column+n;let u=i.start.line,l=i.end.line,h=0,c=0,a=0;for(;u<=l&&(h=u+(l-u)/2|0,a=s[h],h!==l);)if(c=s[h+1],f<a)l=h-1;else if(f>=c)u=h+1;else break;return t?(t.line=h,t.column=f-a,null):{line:h,column:f-a}}getLineFeedCnt(e,n,t){if(t.column===0)return t.line-n.line;const i=this._buffers[e].lineStarts;if(t.line===i.length-1)return t.line-n.line;const r=i[t.line+1],s=i[t.line]+t.column;if(r>s+1)return t.line-n.line;const o=s-1;return this._buffers[e].buffer.charCodeAt(o)===13?t.line-n.line+1:t.line-n.line}offsetInBuffer(e,n){return this._buffers[e].lineStarts[n.line]+n.column}deleteNodes(e){for(let n=0;n<e.length;n++)T(this,e[n])}createNewPieces(e){if(e.length>I){const l=[];for(;e.length>I;){const c=e.charCodeAt(I-1);let a;c===_.CarriageReturn||c>=55296&&c<=56319?(a=e.substring(0,I-1),e=e.substring(I-1)):(a=e.substring(0,I),e=e.substring(I));const p=B(a);l.push(new C(this._buffers.length,{line:0,column:0},{line:p.length-1,column:a.length-p[p.length-1]},p.length-1,a.length)),this._buffers.push(new w(a,p))}const h=B(e);return l.push(new C(this._buffers.length,{line:0,column:0},{line:h.length-1,column:e.length-h[h.length-1]},h.length-1,e.length)),this._buffers.push(new w(e,h)),l}let n=this._buffers[0].buffer.length;const t=B(e,!1);let i=this._lastChangeBufferPos;if(this._buffers[0].lineStarts[this._buffers[0].lineStarts.length-1]===n&&n!==0&&this.startWithLF(e)&&this.endWithCR(this._buffers[0].buffer)){this._lastChangeBufferPos={line:this._lastChangeBufferPos.line,column:this._lastChangeBufferPos.column+1},i=this._lastChangeBufferPos;for(let l=0;l<t.length;l++)t[l]+=n+1;this._buffers[0].lineStarts=this._buffers[0].lineStarts.concat(t.slice(1)),this._buffers[0].buffer+="_"+e,n+=1}else{if(n!==0)for(let l=0;l<t.length;l++)t[l]+=n;this._buffers[0].lineStarts=this._buffers[0].lineStarts.concat(t.slice(1)),this._buffers[0].buffer+=e}const r=this._buffers[0].buffer.length,s=this._buffers[0].lineStarts.length-1,o=r-this._buffers[0].lineStarts[s],f={line:s,column:o},u=new C(0,i,f,this.getLineFeedCnt(0,i,f),r-n);return this._lastChangeBufferPos=f,[u]}getLinesRawContent(){return this.getContentOfSubTree(this.root)}getLineRawContent(e,n=0){let t=this.root,i="";const r=this._searchCache.get2(e);if(r){t=r.node;const s=this.getAccumulatedValue(t,e-r.nodeStartLineNumber-1),o=this._buffers[t.piece.bufferIndex].buffer,f=this.offsetInBuffer(t.piece.bufferIndex,t.piece.start);if(r.nodeStartLineNumber+t.piece.lineFeedCnt===e)i=o.substring(f+s,f+t.piece.length);else{const u=this.getAccumulatedValue(t,e-r.nodeStartLineNumber);return o.substring(f+s,f+u-n)}}else{let s=0;const o=e;for(;t!==d;)if(t.left!==d&&t.lf_left>=e-1)t=t.left;else if(t.lf_left+t.piece.lineFeedCnt>e-1){const f=this.getAccumulatedValue(t,e-t.lf_left-2),u=this.getAccumulatedValue(t,e-t.lf_left-1),l=this._buffers[t.piece.bufferIndex].buffer,h=this.offsetInBuffer(t.piece.bufferIndex,t.piece.start);return s+=t.size_left,this._searchCache.set({node:t,nodeStartOffset:s,nodeStartLineNumber:o-(e-1-t.lf_left)}),l.substring(h+f,h+u-n)}else if(t.lf_left+t.piece.lineFeedCnt===e-1){const f=this.getAccumulatedValue(t,e-t.lf_left-2),u=this._buffers[t.piece.bufferIndex].buffer,l=this.offsetInBuffer(t.piece.bufferIndex,t.piece.start);i=u.substring(l+f,l+t.piece.length);break}else e-=t.lf_left+t.piece.lineFeedCnt,s+=t.size_left+t.piece.length,t=t.right}for(t=t.next();t!==d;){const s=this._buffers[t.piece.bufferIndex].buffer;if(t.piece.lineFeedCnt>0){const o=this.getAccumulatedValue(t,0),f=this.offsetInBuffer(t.piece.bufferIndex,t.piece.start);return i+=s.substring(f,f+o-n),i}else{const o=this.offsetInBuffer(t.piece.bufferIndex,t.piece.start);i+=s.substr(o,t.piece.length)}t=t.next()}return i}computeBufferMetadata(){let e=this.root,n=1,t=0;for(;e!==d;)n+=e.lf_left+e.piece.lineFeedCnt,t+=e.size_left+e.piece.length,e=e.right;this._lineCnt=n,this._length=t,this._searchCache.validate(this._length)}getIndexOf(e,n){const t=e.piece,i=this.positionInBuffer(e,n),r=i.line-t.start.line;if(this.offsetInBuffer(t.bufferIndex,t.end)-this.offsetInBuffer(t.bufferIndex,t.start)===n){const s=this.getLineFeedCnt(e.piece.bufferIndex,t.start,i);if(s!==r)return{index:s,remainder:0}}return{index:r,remainder:i.column}}getAccumulatedValue(e,n){if(n<0)return 0;const t=e.piece,i=this._buffers[t.bufferIndex].lineStarts,r=t.start.line+n+1;return r>t.end.line?i[t.end.line]+t.end.column-i[t.start.line]-t.start.column:i[r]-i[t.start.line]-t.start.column}deleteNodeTail(e,n){const t=e.piece,i=t.lineFeedCnt,r=this.offsetInBuffer(t.bufferIndex,t.end),s=n,o=this.offsetInBuffer(t.bufferIndex,s),f=this.getLineFeedCnt(t.bufferIndex,t.start,s),u=f-i,l=o-r,h=t.length+l;e.piece=new C(t.bufferIndex,t.start,s,f,h),S(this,e,l,u)}deleteNodeHead(e,n){const t=e.piece,i=t.lineFeedCnt,r=this.offsetInBuffer(t.bufferIndex,t.start),s=n,o=this.getLineFeedCnt(t.bufferIndex,s,t.end),f=this.offsetInBuffer(t.bufferIndex,s),u=o-i,l=r-f,h=t.length+l;e.piece=new C(t.bufferIndex,s,t.end,o,h),S(this,e,l,u)}shrinkNode(e,n,t){const i=e.piece,r=i.start,s=i.end,o=i.length,f=i.lineFeedCnt,u=n,l=this.getLineFeedCnt(i.bufferIndex,i.start,u),h=this.offsetInBuffer(i.bufferIndex,n)-this.offsetInBuffer(i.bufferIndex,r);e.piece=new C(i.bufferIndex,i.start,u,l,h),S(this,e,h-o,l-f);const c=new C(i.bufferIndex,t,s,this.getLineFeedCnt(i.bufferIndex,t,s),this.offsetInBuffer(i.bufferIndex,s)-this.offsetInBuffer(i.bufferIndex,t)),a=this.rbInsertRight(e,c);this.validateCRLFWithPrevNode(a)}appendToNode(e,n){this.adjustCarriageReturnFromNext(n,e)&&(n+=`
`);const t=this.shouldCheckCRLF()&&this.startWithLF(n)&&this.endWithCR(e),i=this._buffers[0].buffer.length;this._buffers[0].buffer+=n;const r=B(n,!1);for(let a=0;a<r.length;a++)r[a]+=i;if(t){const a=this._buffers[0].lineStarts[this._buffers[0].lineStarts.length-2];this._buffers[0].lineStarts.pop(),this._lastChangeBufferPos={line:this._lastChangeBufferPos.line-1,column:i-a}}this._buffers[0].lineStarts=this._buffers[0].lineStarts.concat(r.slice(1));const s=this._buffers[0].lineStarts.length-1,o=this._buffers[0].buffer.length-this._buffers[0].lineStarts[s],f={line:s,column:o},u=e.piece.length+n.length,l=e.piece.lineFeedCnt,h=this.getLineFeedCnt(0,e.piece.start,f),c=h-l;e.piece=new C(e.piece.bufferIndex,e.piece.start,f,h,u),this._lastChangeBufferPos=f,S(this,e,n.length,c)}nodeAt(e){let n=this.root;const t=this._searchCache.get(e);if(t)return{node:t.node,nodeStartOffset:t.nodeStartOffset,remainder:e-t.nodeStartOffset};let i=0;for(;n!==d;)if(n.size_left>e)n=n.left;else if(n.size_left+n.piece.length>=e){i+=n.size_left;const r={node:n,remainder:e-n.size_left,nodeStartOffset:i};return this._searchCache.set(r),r}else e-=n.size_left+n.piece.length,i+=n.size_left+n.piece.length,n=n.right;return null}nodeAt2(e,n){let t=this.root,i=0;for(;t!==d;)if(t.left!==d&&t.lf_left>=e-1)t=t.left;else if(t.lf_left+t.piece.lineFeedCnt>e-1){const r=this.getAccumulatedValue(t,e-t.lf_left-2),s=this.getAccumulatedValue(t,e-t.lf_left-1);return i+=t.size_left,{node:t,remainder:Math.min(r+n-1,s),nodeStartOffset:i}}else if(t.lf_left+t.piece.lineFeedCnt===e-1){const r=this.getAccumulatedValue(t,e-t.lf_left-2);if(r+n-1<=t.piece.length)return{node:t,remainder:r+n-1,nodeStartOffset:i};n-=t.piece.length-r;break}else e-=t.lf_left+t.piece.lineFeedCnt,i+=t.size_left+t.piece.length,t=t.right;for(t=t.next();t!==d;){if(t.piece.lineFeedCnt>0){const r=this.getAccumulatedValue(t,0),s=this.offsetOfNode(t);return{node:t,remainder:Math.min(n-1,r),nodeStartOffset:s}}else if(t.piece.length>=n-1){const r=this.offsetOfNode(t);return{node:t,remainder:n-1,nodeStartOffset:r}}else n-=t.piece.length;t=t.next()}return null}nodeCharCodeAt(e,n){if(e.piece.lineFeedCnt<1)return-1;const t=this._buffers[e.piece.bufferIndex],i=this.offsetInBuffer(e.piece.bufferIndex,e.piece.start)+n;return t.buffer.charCodeAt(i)}offsetOfNode(e){if(!e)return 0;let n=e.size_left;for(;e!==this.root;)e.parent.right===e&&(n+=e.parent.size_left+e.parent.piece.length),e=e.parent;return n}shouldCheckCRLF(){return!(this._EOLNormalized&&this._EOL===`
`)}startWithLF(e){if(typeof e=="string")return e.charCodeAt(0)===10;if(e===d||e.piece.lineFeedCnt===0)return!1;const n=e.piece,t=this._buffers[n.bufferIndex].lineStarts,i=n.start.line,r=t[i]+n.start.column;return i===t.length-1||t[i+1]>r+1?!1:this._buffers[n.bufferIndex].buffer.charCodeAt(r)===10}endWithCR(e){return typeof e=="string"?e.charCodeAt(e.length-1)===13:e===d||e.piece.lineFeedCnt===0?!1:this.nodeCharCodeAt(e,e.piece.length-1)===13}validateCRLFWithPrevNode(e){if(this.shouldCheckCRLF()&&this.startWithLF(e)){const n=e.prev();this.endWithCR(n)&&this.fixCRLF(n,e)}}validateCRLFWithNextNode(e){if(this.shouldCheckCRLF()&&this.endWithCR(e)){const n=e.next();this.startWithLF(n)&&this.fixCRLF(e,n)}}fixCRLF(e,n){const t=[],i=this._buffers[e.piece.bufferIndex].lineStarts;let r;e.piece.end.column===0?r={line:e.piece.end.line-1,column:i[e.piece.end.line]-i[e.piece.end.line-1]-1}:r={line:e.piece.end.line,column:e.piece.end.column-1};const s=e.piece.length-1,o=e.piece.lineFeedCnt-1;e.piece=new C(e.piece.bufferIndex,e.piece.start,r,o,s),S(this,e,-1,-1),e.piece.length===0&&t.push(e);const f={line:n.piece.start.line+1,column:0},u=n.piece.length-1,l=this.getLineFeedCnt(n.piece.bufferIndex,f,n.piece.end);n.piece=new C(n.piece.bufferIndex,f,n.piece.end,l,u),S(this,n,-1,-1),n.piece.length===0&&t.push(n);const h=this.createNewPieces(`\r
`);this.rbInsertRight(e,h[0]);for(let c=0;c<t.length;c++)T(this,t[c])}adjustCarriageReturnFromNext(e,n){if(this.shouldCheckCRLF()&&this.endWithCR(e)){const t=n.next();if(this.startWithLF(t)){if(e+=`
`,t.piece.length===1)T(this,t);else{const i=t.piece,r={line:i.start.line+1,column:0},s=i.length-1,o=this.getLineFeedCnt(i.bufferIndex,r,i.end);t.piece=new C(i.bufferIndex,r,i.end,o,s),S(this,t,-1,-1)}return!0}}return!1}iterate(e,n){if(e===d)return n(d);const t=this.iterate(e.left,n);return t&&n(e)&&this.iterate(e.right,n)}getNodeContent(e){if(e===d)return"";const n=this._buffers[e.piece.bufferIndex],t=e.piece,i=this.offsetInBuffer(t.bufferIndex,t.start),r=this.offsetInBuffer(t.bufferIndex,t.end);return n.buffer.substring(i,r)}getPieceContent(e){const n=this._buffers[e.bufferIndex],t=this.offsetInBuffer(e.bufferIndex,e.start),i=this.offsetInBuffer(e.bufferIndex,e.end);return n.buffer.substring(t,i)}rbInsertRight(e,n){const t=new y(n,A.Red);if(t.left=d,t.right=d,t.parent=d,t.size_left=0,t.lf_left=0,this.root===d)this.root=t,t.color=A.Black;else if(e.right===d)e.right=t,t.parent=e;else{const r=k(e.right);r.left=t,t.parent=r}return z(this,t),t}rbInsertLeft(e,n){const t=new y(n,A.Red);if(t.left=d,t.right=d,t.parent=d,t.size_left=0,t.lf_left=0,this.root===d)this.root=t,t.color=A.Black;else if(e.left===d)e.left=t,t.parent=e;else{const i=j(e.left);i.right=t,t.parent=i}return z(this,t),t}getContentOfSubTree(e){let n="";return this.iterate(e,t=>(n+=this.getNodeContent(t),!0)),n}}export{C as Piece,Z as PieceTreeBase,w as StringBuffer,Y as createLineStarts,B as createLineStartsFast};
