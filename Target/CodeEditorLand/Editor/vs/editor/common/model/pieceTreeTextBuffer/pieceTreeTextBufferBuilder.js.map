{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from \"../../../../base/common/charCode.js\";\nimport type { IDisposable } from \"../../../../base/common/lifecycle.js\";\nimport * as strings from \"../../../../base/common/strings.js\";\nimport {\n\tDefaultEndOfLine,\n\ttype ITextBuffer,\n\ttype ITextBufferBuilder,\n\ttype ITextBufferFactory,\n} from \"../../model.js\";\nimport {\n\tStringBuffer,\n\tcreateLineStarts,\n\tcreateLineStartsFast,\n} from \"./pieceTreeBase.js\";\nimport { PieceTreeTextBuffer } from \"./pieceTreeTextBuffer.js\";\n\nclass PieceTreeTextBufferFactory implements ITextBufferFactory {\n\tconstructor(\n\t\tprivate readonly _chunks: StringBuffer[],\n\t\tprivate readonly _bom: string,\n\t\tprivate readonly _cr: number,\n\t\tprivate readonly _lf: number,\n\t\tprivate readonly _crlf: number,\n\t\tprivate readonly _containsRTL: boolean,\n\t\tprivate readonly _containsUnusualLineTerminators: boolean,\n\t\tprivate readonly _isBasicASCII: boolean,\n\t\tprivate readonly _normalizeEOL: boolean,\n\t) {}\n\n\tprivate _getEOL(defaultEOL: DefaultEndOfLine): \"\\r\\n\" | \"\\n\" {\n\t\tconst totalEOLCount = this._cr + this._lf + this._crlf;\n\t\tconst totalCRCount = this._cr + this._crlf;\n\t\tif (totalEOLCount === 0) {\n\t\t\t// This is an empty file or a file with precisely one line\n\t\t\treturn defaultEOL === DefaultEndOfLine.LF ? \"\\n\" : \"\\r\\n\";\n\t\t}\n\t\tif (totalCRCount > totalEOLCount / 2) {\n\t\t\t// More than half of the file contains \\r\\n ending lines\n\t\t\treturn \"\\r\\n\";\n\t\t}\n\t\t// At least one line more ends in \\n\n\t\treturn \"\\n\";\n\t}\n\n\tpublic create(defaultEOL: DefaultEndOfLine): {\n\t\ttextBuffer: ITextBuffer;\n\t\tdisposable: IDisposable;\n\t} {\n\t\tconst eol = this._getEOL(defaultEOL);\n\t\tconst chunks = this._chunks;\n\n\t\tif (\n\t\t\tthis._normalizeEOL &&\n\t\t\t((eol === \"\\r\\n\" && (this._cr > 0 || this._lf > 0)) ||\n\t\t\t\t(eol === \"\\n\" && (this._cr > 0 || this._crlf > 0)))\n\t\t) {\n\t\t\t// Normalize pieces\n\t\t\tfor (let i = 0, len = chunks.length; i < len; i++) {\n\t\t\t\tconst str = chunks[i].buffer.replace(/\\r\\n|\\r|\\n/g, eol);\n\t\t\t\tconst newLineStart = createLineStartsFast(str);\n\t\t\t\tchunks[i] = new StringBuffer(str, newLineStart);\n\t\t\t}\n\t\t}\n\n\t\tconst textBuffer = new PieceTreeTextBuffer(\n\t\t\tchunks,\n\t\t\tthis._bom,\n\t\t\teol,\n\t\t\tthis._containsRTL,\n\t\t\tthis._containsUnusualLineTerminators,\n\t\t\tthis._isBasicASCII,\n\t\t\tthis._normalizeEOL,\n\t\t);\n\t\treturn { textBuffer: textBuffer, disposable: textBuffer };\n\t}\n\n\tpublic getFirstLineText(lengthLimit: number): string {\n\t\treturn this._chunks[0].buffer\n\t\t\t.substr(0, lengthLimit)\n\t\t\t.split(/\\r\\n|\\r|\\n/)[0];\n\t}\n}\n\nexport class PieceTreeTextBufferBuilder implements ITextBufferBuilder {\n\tprivate readonly chunks: StringBuffer[];\n\tprivate BOM: string;\n\n\tprivate _hasPreviousChar: boolean;\n\tprivate _previousChar: number;\n\tprivate readonly _tmpLineStarts: number[];\n\n\tprivate cr: number;\n\tprivate lf: number;\n\tprivate crlf: number;\n\tprivate containsRTL: boolean;\n\tprivate containsUnusualLineTerminators: boolean;\n\tprivate isBasicASCII: boolean;\n\n\tconstructor() {\n\t\tthis.chunks = [];\n\t\tthis.BOM = \"\";\n\n\t\tthis._hasPreviousChar = false;\n\t\tthis._previousChar = 0;\n\t\tthis._tmpLineStarts = [];\n\n\t\tthis.cr = 0;\n\t\tthis.lf = 0;\n\t\tthis.crlf = 0;\n\t\tthis.containsRTL = false;\n\t\tthis.containsUnusualLineTerminators = false;\n\t\tthis.isBasicASCII = true;\n\t}\n\n\tpublic acceptChunk(chunk: string): void {\n\t\tif (chunk.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.chunks.length === 0) {\n\t\t\tif (strings.startsWithUTF8BOM(chunk)) {\n\t\t\t\tthis.BOM = strings.UTF8_BOM_CHARACTER;\n\t\t\t\tchunk = chunk.substr(1);\n\t\t\t}\n\t\t}\n\n\t\tconst lastChar = chunk.charCodeAt(chunk.length - 1);\n\t\tif (\n\t\t\tlastChar === CharCode.CarriageReturn ||\n\t\t\t(lastChar >= 0xd800 && lastChar <= 0xdbff)\n\t\t) {\n\t\t\t// last character is \\r or a high surrogate => keep it back\n\t\t\tthis._acceptChunk1(chunk.substr(0, chunk.length - 1), false);\n\t\t\tthis._hasPreviousChar = true;\n\t\t\tthis._previousChar = lastChar;\n\t\t} else {\n\t\t\tthis._acceptChunk1(chunk, false);\n\t\t\tthis._hasPreviousChar = false;\n\t\t\tthis._previousChar = lastChar;\n\t\t}\n\t}\n\n\tprivate _acceptChunk1(chunk: string, allowEmptyStrings: boolean): void {\n\t\tif (!allowEmptyStrings && chunk.length === 0) {\n\t\t\t// Nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._hasPreviousChar) {\n\t\t\tthis._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);\n\t\t} else {\n\t\t\tthis._acceptChunk2(chunk);\n\t\t}\n\t}\n\n\tprivate _acceptChunk2(chunk: string): void {\n\t\tconst lineStarts = createLineStarts(this._tmpLineStarts, chunk);\n\n\t\tthis.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));\n\t\tthis.cr += lineStarts.cr;\n\t\tthis.lf += lineStarts.lf;\n\t\tthis.crlf += lineStarts.crlf;\n\n\t\tif (!lineStarts.isBasicASCII) {\n\t\t\t// this chunk contains non basic ASCII characters\n\t\t\tthis.isBasicASCII = false;\n\t\t\tif (!this.containsRTL) {\n\t\t\t\tthis.containsRTL = strings.containsRTL(chunk);\n\t\t\t}\n\t\t\tif (!this.containsUnusualLineTerminators) {\n\t\t\t\tthis.containsUnusualLineTerminators =\n\t\t\t\t\tstrings.containsUnusualLineTerminators(chunk);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic finish(normalizeEOL = true): PieceTreeTextBufferFactory {\n\t\tthis._finish();\n\t\treturn new PieceTreeTextBufferFactory(\n\t\t\tthis.chunks,\n\t\t\tthis.BOM,\n\t\t\tthis.cr,\n\t\t\tthis.lf,\n\t\t\tthis.crlf,\n\t\t\tthis.containsRTL,\n\t\t\tthis.containsUnusualLineTerminators,\n\t\t\tthis.isBasicASCII,\n\t\t\tnormalizeEOL,\n\t\t);\n\t}\n\n\tprivate _finish(): void {\n\t\tif (this.chunks.length === 0) {\n\t\t\tthis._acceptChunk1(\"\", true);\n\t\t}\n\n\t\tif (this._hasPreviousChar) {\n\t\t\tthis._hasPreviousChar = false;\n\t\t\t// recreate last chunk\n\t\t\tconst lastChunk = this.chunks[this.chunks.length - 1];\n\t\t\tlastChunk.buffer += String.fromCharCode(this._previousChar);\n\t\t\tconst newLineStarts = createLineStartsFast(lastChunk.buffer);\n\t\t\tlastChunk.lineStarts = newLineStarts;\n\t\t\tif (this._previousChar === CharCode.CarriageReturn) {\n\t\t\t\tthis.cr++;\n\t\t\t}\n\t\t}\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
