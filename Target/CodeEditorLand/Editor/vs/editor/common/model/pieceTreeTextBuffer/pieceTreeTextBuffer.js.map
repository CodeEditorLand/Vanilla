{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, type Event } from \"../../../../base/common/event.js\";\nimport { Disposable } from \"../../../../base/common/lifecycle.js\";\nimport * as strings from \"../../../../base/common/strings.js\";\nimport { StringEOL, countEOL } from \"../../core/eolCounter.js\";\nimport type { Position } from \"../../core/position.js\";\nimport { Range } from \"../../core/range.js\";\nimport { TextChange } from \"../../core/textChange.js\";\nimport {\n\tApplyEditsResult,\n\tEndOfLinePreference,\n\ttype FindMatch,\n\ttype IInternalModelContentChange,\n\ttype ISingleEditOperationIdentifier,\n\ttype ITextBuffer,\n\ttype ITextSnapshot,\n\ttype IValidEditOperation,\n\ttype SearchData,\n\ttype ValidAnnotatedEditOperation,\n} from \"../../model.js\";\nimport { PieceTreeBase, type StringBuffer } from \"./pieceTreeBase.js\";\n\nexport interface IValidatedEditOperation {\n\tsortIndex: number;\n\tidentifier: ISingleEditOperationIdentifier | null;\n\trange: Range;\n\trangeOffset: number;\n\trangeLength: number;\n\ttext: string;\n\teolCount: number;\n\tfirstLineLength: number;\n\tlastLineLength: number;\n\tforceMoveMarkers: boolean;\n\tisAutoWhitespaceEdit: boolean;\n}\n\ninterface IReverseSingleEditOperation extends IValidEditOperation {\n\tsortIndex: number;\n}\n\nexport class PieceTreeTextBuffer extends Disposable implements ITextBuffer {\n\tprivate _pieceTree: PieceTreeBase;\n\tprivate readonly _BOM: string;\n\tprivate _mightContainRTL: boolean;\n\tprivate _mightContainUnusualLineTerminators: boolean;\n\tprivate _mightContainNonBasicASCII: boolean;\n\n\tprivate readonly _onDidChangeContent: Emitter<void> = this._register(\n\t\tnew Emitter<void>(),\n\t);\n\tpublic readonly onDidChangeContent: Event<void> =\n\t\tthis._onDidChangeContent.event;\n\n\tconstructor(\n\t\tchunks: StringBuffer[],\n\t\tBOM: string,\n\t\teol: \"\\r\\n\" | \"\\n\",\n\t\tcontainsRTL: boolean,\n\t\tcontainsUnusualLineTerminators: boolean,\n\t\tisBasicASCII: boolean,\n\t\teolNormalized: boolean,\n\t) {\n\t\tsuper();\n\t\tthis._BOM = BOM;\n\t\tthis._mightContainNonBasicASCII = !isBasicASCII;\n\t\tthis._mightContainRTL = containsRTL;\n\t\tthis._mightContainUnusualLineTerminators =\n\t\t\tcontainsUnusualLineTerminators;\n\t\tthis._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n\t}\n\n\t// #region TextBuffer\n\tpublic equals(other: ITextBuffer): boolean {\n\t\tif (!(other instanceof PieceTreeTextBuffer)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this._BOM !== other._BOM) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.getEOL() !== other.getEOL()) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this._pieceTree.equal(other._pieceTree);\n\t}\n\tpublic mightContainRTL(): boolean {\n\t\treturn this._mightContainRTL;\n\t}\n\tpublic mightContainUnusualLineTerminators(): boolean {\n\t\treturn this._mightContainUnusualLineTerminators;\n\t}\n\tpublic resetMightContainUnusualLineTerminators(): void {\n\t\tthis._mightContainUnusualLineTerminators = false;\n\t}\n\tpublic mightContainNonBasicASCII(): boolean {\n\t\treturn this._mightContainNonBasicASCII;\n\t}\n\tpublic getBOM(): string {\n\t\treturn this._BOM;\n\t}\n\tpublic getEOL(): \"\\r\\n\" | \"\\n\" {\n\t\treturn this._pieceTree.getEOL();\n\t}\n\n\tpublic createSnapshot(preserveBOM: boolean): ITextSnapshot {\n\t\treturn this._pieceTree.createSnapshot(preserveBOM ? this._BOM : \"\");\n\t}\n\n\tpublic getOffsetAt(lineNumber: number, column: number): number {\n\t\treturn this._pieceTree.getOffsetAt(lineNumber, column);\n\t}\n\n\tpublic getPositionAt(offset: number): Position {\n\t\treturn this._pieceTree.getPositionAt(offset);\n\t}\n\n\tpublic getRangeAt(start: number, length: number): Range {\n\t\tconst end = start + length;\n\t\tconst startPosition = this.getPositionAt(start);\n\t\tconst endPosition = this.getPositionAt(end);\n\t\treturn new Range(\n\t\t\tstartPosition.lineNumber,\n\t\t\tstartPosition.column,\n\t\t\tendPosition.lineNumber,\n\t\t\tendPosition.column,\n\t\t);\n\t}\n\n\tpublic getValueInRange(\n\t\trange: Range,\n\t\teol: EndOfLinePreference = EndOfLinePreference.TextDefined,\n\t): string {\n\t\tif (range.isEmpty()) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tconst lineEnding = this._getEndOfLine(eol);\n\t\treturn this._pieceTree.getValueInRange(range, lineEnding);\n\t}\n\n\tpublic getValueLengthInRange(\n\t\trange: Range,\n\t\teol: EndOfLinePreference = EndOfLinePreference.TextDefined,\n\t): number {\n\t\tif (range.isEmpty()) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (range.startLineNumber === range.endLineNumber) {\n\t\t\treturn range.endColumn - range.startColumn;\n\t\t}\n\n\t\tconst startOffset = this.getOffsetAt(\n\t\t\trange.startLineNumber,\n\t\t\trange.startColumn,\n\t\t);\n\t\tconst endOffset = this.getOffsetAt(\n\t\t\trange.endLineNumber,\n\t\t\trange.endColumn,\n\t\t);\n\n\t\t// offsets use the text EOL, so we need to compensate for length differences\n\t\t// if the requested EOL doesn't match the text EOL\n\t\tlet eolOffsetCompensation = 0;\n\t\tconst desiredEOL = this._getEndOfLine(eol);\n\t\tconst actualEOL = this.getEOL();\n\t\tif (desiredEOL.length !== actualEOL.length) {\n\t\t\tconst delta = desiredEOL.length - actualEOL.length;\n\t\t\tconst eolCount = range.endLineNumber - range.startLineNumber;\n\t\t\teolOffsetCompensation = delta * eolCount;\n\t\t}\n\n\t\treturn endOffset - startOffset + eolOffsetCompensation;\n\t}\n\n\tpublic getCharacterCountInRange(\n\t\trange: Range,\n\t\teol: EndOfLinePreference = EndOfLinePreference.TextDefined,\n\t): number {\n\t\tif (this._mightContainNonBasicASCII) {\n\t\t\t// we must count by iterating\n\n\t\t\tlet result = 0;\n\n\t\t\tconst fromLineNumber = range.startLineNumber;\n\t\t\tconst toLineNumber = range.endLineNumber;\n\t\t\tfor (\n\t\t\t\tlet lineNumber = fromLineNumber;\n\t\t\t\tlineNumber <= toLineNumber;\n\t\t\t\tlineNumber++\n\t\t\t) {\n\t\t\t\tconst lineContent = this.getLineContent(lineNumber);\n\t\t\t\tconst fromOffset =\n\t\t\t\t\tlineNumber === fromLineNumber ? range.startColumn - 1 : 0;\n\t\t\t\tconst toOffset =\n\t\t\t\t\tlineNumber === toLineNumber\n\t\t\t\t\t\t? range.endColumn - 1\n\t\t\t\t\t\t: lineContent.length;\n\n\t\t\t\tfor (let offset = fromOffset; offset < toOffset; offset++) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tstrings.isHighSurrogate(lineContent.charCodeAt(offset))\n\t\t\t\t\t) {\n\t\t\t\t\t\tresult = result + 1;\n\t\t\t\t\t\toffset = offset + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult = result + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresult +=\n\t\t\t\tthis._getEndOfLine(eol).length *\n\t\t\t\t(toLineNumber - fromLineNumber);\n\n\t\t\treturn result;\n\t\t}\n\n\t\treturn this.getValueLengthInRange(range, eol);\n\t}\n\n\tpublic getNearestChunk(offset: number): string {\n\t\treturn this._pieceTree.getNearestChunk(offset);\n\t}\n\n\tpublic getLength(): number {\n\t\treturn this._pieceTree.getLength();\n\t}\n\n\tpublic getLineCount(): number {\n\t\treturn this._pieceTree.getLineCount();\n\t}\n\n\tpublic getLinesContent(): string[] {\n\t\treturn this._pieceTree.getLinesContent();\n\t}\n\n\tpublic getLineContent(lineNumber: number): string {\n\t\treturn this._pieceTree.getLineContent(lineNumber);\n\t}\n\n\tpublic getLineCharCode(lineNumber: number, index: number): number {\n\t\treturn this._pieceTree.getLineCharCode(lineNumber, index);\n\t}\n\n\tpublic getCharCode(offset: number): number {\n\t\treturn this._pieceTree.getCharCode(offset);\n\t}\n\n\tpublic getLineLength(lineNumber: number): number {\n\t\treturn this._pieceTree.getLineLength(lineNumber);\n\t}\n\n\tpublic getLineMinColumn(lineNumber: number): number {\n\t\treturn 1;\n\t}\n\n\tpublic getLineMaxColumn(lineNumber: number): number {\n\t\treturn this.getLineLength(lineNumber) + 1;\n\t}\n\n\tpublic getLineFirstNonWhitespaceColumn(lineNumber: number): number {\n\t\tconst result = strings.firstNonWhitespaceIndex(\n\t\t\tthis.getLineContent(lineNumber),\n\t\t);\n\t\tif (result === -1) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn result + 1;\n\t}\n\n\tpublic getLineLastNonWhitespaceColumn(lineNumber: number): number {\n\t\tconst result = strings.lastNonWhitespaceIndex(\n\t\t\tthis.getLineContent(lineNumber),\n\t\t);\n\t\tif (result === -1) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn result + 2;\n\t}\n\n\tprivate _getEndOfLine(eol: EndOfLinePreference): string {\n\t\tswitch (eol) {\n\t\t\tcase EndOfLinePreference.LF:\n\t\t\t\treturn \"\\n\";\n\t\t\tcase EndOfLinePreference.CRLF:\n\t\t\t\treturn \"\\r\\n\";\n\t\t\tcase EndOfLinePreference.TextDefined:\n\t\t\t\treturn this.getEOL();\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"Unknown EOL preference\");\n\t\t}\n\t}\n\n\tpublic setEOL(newEOL: \"\\r\\n\" | \"\\n\"): void {\n\t\tthis._pieceTree.setEOL(newEOL);\n\t}\n\n\tpublic applyEdits(\n\t\trawOperations: ValidAnnotatedEditOperation[],\n\t\trecordTrimAutoWhitespace: boolean,\n\t\tcomputeUndoEdits: boolean,\n\t): ApplyEditsResult {\n\t\tlet mightContainRTL = this._mightContainRTL;\n\t\tlet mightContainUnusualLineTerminators =\n\t\t\tthis._mightContainUnusualLineTerminators;\n\t\tlet mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n\t\tlet canReduceOperations = true;\n\n\t\tlet operations: IValidatedEditOperation[] = [];\n\t\tfor (let i = 0; i < rawOperations.length; i++) {\n\t\t\tconst op = rawOperations[i];\n\t\t\tif (canReduceOperations && op._isTracked) {\n\t\t\t\tcanReduceOperations = false;\n\t\t\t}\n\t\t\tconst validatedRange = op.range;\n\t\t\tif (op.text) {\n\t\t\t\tlet textMightContainNonBasicASCII = true;\n\t\t\t\tif (!mightContainNonBasicASCII) {\n\t\t\t\t\ttextMightContainNonBasicASCII = !strings.isBasicASCII(\n\t\t\t\t\t\top.text,\n\t\t\t\t\t);\n\t\t\t\t\tmightContainNonBasicASCII = textMightContainNonBasicASCII;\n\t\t\t\t}\n\t\t\t\tif (!mightContainRTL && textMightContainNonBasicASCII) {\n\t\t\t\t\t// check if the new inserted text contains RTL\n\t\t\t\t\tmightContainRTL = strings.containsRTL(op.text);\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\t!mightContainUnusualLineTerminators &&\n\t\t\t\t\ttextMightContainNonBasicASCII\n\t\t\t\t) {\n\t\t\t\t\t// check if the new inserted text contains unusual line terminators\n\t\t\t\t\tmightContainUnusualLineTerminators =\n\t\t\t\t\t\tstrings.containsUnusualLineTerminators(op.text);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet validText = \"\";\n\t\t\tlet eolCount = 0;\n\t\t\tlet firstLineLength = 0;\n\t\t\tlet lastLineLength = 0;\n\t\t\tif (op.text) {\n\t\t\t\tlet strEOL: StringEOL;\n\t\t\t\t[eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(\n\t\t\t\t\top.text,\n\t\t\t\t);\n\n\t\t\t\tconst bufferEOL = this.getEOL();\n\t\t\t\tconst expectedStrEOL =\n\t\t\t\t\tbufferEOL === \"\\r\\n\" ? StringEOL.CRLF : StringEOL.LF;\n\t\t\t\tif (strEOL === StringEOL.Unknown || strEOL === expectedStrEOL) {\n\t\t\t\t\tvalidText = op.text;\n\t\t\t\t} else {\n\t\t\t\t\tvalidText = op.text.replace(/\\r\\n|\\r|\\n/g, bufferEOL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toperations[i] = {\n\t\t\t\tsortIndex: i,\n\t\t\t\tidentifier: op.identifier || null,\n\t\t\t\trange: validatedRange,\n\t\t\t\trangeOffset: this.getOffsetAt(\n\t\t\t\t\tvalidatedRange.startLineNumber,\n\t\t\t\t\tvalidatedRange.startColumn,\n\t\t\t\t),\n\t\t\t\trangeLength: this.getValueLengthInRange(validatedRange),\n\t\t\t\ttext: validText,\n\t\t\t\teolCount: eolCount,\n\t\t\t\tfirstLineLength: firstLineLength,\n\t\t\t\tlastLineLength: lastLineLength,\n\t\t\t\tforceMoveMarkers: Boolean(op.forceMoveMarkers),\n\t\t\t\tisAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false,\n\t\t\t};\n\t\t}\n\n\t\t// Sort operations ascending\n\t\toperations.sort(PieceTreeTextBuffer._sortOpsAscending);\n\n\t\tlet hasTouchingRanges = false;\n\t\tfor (let i = 0, count = operations.length - 1; i < count; i++) {\n\t\t\tconst rangeEnd = operations[i].range.getEndPosition();\n\t\t\tconst nextRangeStart = operations[i + 1].range.getStartPosition();\n\n\t\t\tif (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n\t\t\t\tif (nextRangeStart.isBefore(rangeEnd)) {\n\t\t\t\t\t// overlapping ranges\n\t\t\t\t\tthrow new Error(\"Overlapping ranges are not allowed!\");\n\t\t\t\t}\n\t\t\t\thasTouchingRanges = true;\n\t\t\t}\n\t\t}\n\n\t\tif (canReduceOperations) {\n\t\t\toperations = this._reduceOperations(operations);\n\t\t}\n\n\t\t// Delta encode operations\n\t\tconst reverseRanges =\n\t\t\tcomputeUndoEdits || recordTrimAutoWhitespace\n\t\t\t\t? PieceTreeTextBuffer._getInverseEditRanges(operations)\n\t\t\t\t: [];\n\t\tconst newTrimAutoWhitespaceCandidates: {\n\t\t\tlineNumber: number;\n\t\t\toldContent: string;\n\t\t}[] = [];\n\t\tif (recordTrimAutoWhitespace) {\n\t\t\tfor (let i = 0; i < operations.length; i++) {\n\t\t\t\tconst op = operations[i];\n\t\t\t\tconst reverseRange = reverseRanges[i];\n\n\t\t\t\tif (op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n\t\t\t\t\t// Record already the future line numbers that might be auto whitespace removal candidates on next edit\n\t\t\t\t\tfor (\n\t\t\t\t\t\tlet lineNumber = reverseRange.startLineNumber;\n\t\t\t\t\t\tlineNumber <= reverseRange.endLineNumber;\n\t\t\t\t\t\tlineNumber++\n\t\t\t\t\t) {\n\t\t\t\t\t\tlet currentLineContent = \"\";\n\t\t\t\t\t\tif (lineNumber === reverseRange.startLineNumber) {\n\t\t\t\t\t\t\tcurrentLineContent = this.getLineContent(\n\t\t\t\t\t\t\t\top.range.startLineNumber,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tstrings.firstNonWhitespaceIndex(\n\t\t\t\t\t\t\t\t\tcurrentLineContent,\n\t\t\t\t\t\t\t\t) !== -1\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewTrimAutoWhitespaceCandidates.push({\n\t\t\t\t\t\t\tlineNumber: lineNumber,\n\t\t\t\t\t\t\toldContent: currentLineContent,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet reverseOperations: IReverseSingleEditOperation[] | null = null;\n\t\tif (computeUndoEdits) {\n\t\t\tlet reverseRangeDeltaOffset = 0;\n\t\t\treverseOperations = [];\n\t\t\tfor (let i = 0; i < operations.length; i++) {\n\t\t\t\tconst op = operations[i];\n\t\t\t\tconst reverseRange = reverseRanges[i];\n\t\t\t\tconst bufferText = this.getValueInRange(op.range);\n\t\t\t\tconst reverseRangeOffset =\n\t\t\t\t\top.rangeOffset + reverseRangeDeltaOffset;\n\t\t\t\treverseRangeDeltaOffset += op.text.length - bufferText.length;\n\n\t\t\t\treverseOperations[i] = {\n\t\t\t\t\tsortIndex: op.sortIndex,\n\t\t\t\t\tidentifier: op.identifier,\n\t\t\t\t\trange: reverseRange,\n\t\t\t\t\ttext: bufferText,\n\t\t\t\t\ttextChange: new TextChange(\n\t\t\t\t\t\top.rangeOffset,\n\t\t\t\t\t\tbufferText,\n\t\t\t\t\t\treverseRangeOffset,\n\t\t\t\t\t\top.text,\n\t\t\t\t\t),\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Can only sort reverse operations when the order is not significant\n\t\t\tif (!hasTouchingRanges) {\n\t\t\t\treverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);\n\t\t\t}\n\t\t}\n\n\t\tthis._mightContainRTL = mightContainRTL;\n\t\tthis._mightContainUnusualLineTerminators =\n\t\t\tmightContainUnusualLineTerminators;\n\t\tthis._mightContainNonBasicASCII = mightContainNonBasicASCII;\n\n\t\tconst contentChanges = this._doApplyEdits(operations);\n\n\t\tlet trimAutoWhitespaceLineNumbers: number[] | null = null;\n\t\tif (\n\t\t\trecordTrimAutoWhitespace &&\n\t\t\tnewTrimAutoWhitespaceCandidates.length > 0\n\t\t) {\n\t\t\t// sort line numbers auto whitespace removal candidates for next edit descending\n\t\t\tnewTrimAutoWhitespaceCandidates.sort(\n\t\t\t\t(a, b) => b.lineNumber - a.lineNumber,\n\t\t\t);\n\n\t\t\ttrimAutoWhitespaceLineNumbers = [];\n\t\t\tfor (\n\t\t\t\tlet i = 0, len = newTrimAutoWhitespaceCandidates.length;\n\t\t\t\ti < len;\n\t\t\t\ti++\n\t\t\t) {\n\t\t\t\tconst lineNumber =\n\t\t\t\t\tnewTrimAutoWhitespaceCandidates[i].lineNumber;\n\t\t\t\tif (\n\t\t\t\t\ti > 0 &&\n\t\t\t\t\tnewTrimAutoWhitespaceCandidates[i - 1].lineNumber ===\n\t\t\t\t\t\tlineNumber\n\t\t\t\t) {\n\t\t\t\t\t// Do not have the same line number twice\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst prevContent =\n\t\t\t\t\tnewTrimAutoWhitespaceCandidates[i].oldContent;\n\t\t\t\tconst lineContent = this.getLineContent(lineNumber);\n\n\t\t\t\tif (\n\t\t\t\t\tlineContent.length === 0 ||\n\t\t\t\t\tlineContent === prevContent ||\n\t\t\t\t\tstrings.firstNonWhitespaceIndex(lineContent) !== -1\n\t\t\t\t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttrimAutoWhitespaceLineNumbers.push(lineNumber);\n\t\t\t}\n\t\t}\n\n\t\tthis._onDidChangeContent.fire();\n\n\t\treturn new ApplyEditsResult(\n\t\t\treverseOperations,\n\t\t\tcontentChanges,\n\t\t\ttrimAutoWhitespaceLineNumbers,\n\t\t);\n\t}\n\n\t/**\n\t * Transform operations such that they represent the same logic edit,\n\t * but that they also do not cause OOM crashes.\n\t */\n\tprivate _reduceOperations(\n\t\toperations: IValidatedEditOperation[],\n\t): IValidatedEditOperation[] {\n\t\tif (operations.length < 1000) {\n\t\t\t// We know from empirical testing that a thousand edits work fine regardless of their shape.\n\t\t\treturn operations;\n\t\t}\n\n\t\t// At one point, due to how events are emitted and how each operation is handled,\n\t\t// some operations can trigger a high amount of temporary string allocations,\n\t\t// that will immediately get edited again.\n\t\t// e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n\t\t// Therefore, the strategy is to collapse all the operations into a huge single edit operation\n\t\treturn [this._toSingleEditOperation(operations)];\n\t}\n\n\t_toSingleEditOperation(\n\t\toperations: IValidatedEditOperation[],\n\t): IValidatedEditOperation {\n\t\tlet forceMoveMarkers = false;\n\t\tconst firstEditRange = operations[0].range;\n\t\tconst lastEditRange = operations[operations.length - 1].range;\n\t\tconst entireEditRange = new Range(\n\t\t\tfirstEditRange.startLineNumber,\n\t\t\tfirstEditRange.startColumn,\n\t\t\tlastEditRange.endLineNumber,\n\t\t\tlastEditRange.endColumn,\n\t\t);\n\t\tlet lastEndLineNumber = firstEditRange.startLineNumber;\n\t\tlet lastEndColumn = firstEditRange.startColumn;\n\t\tconst result: string[] = [];\n\n\t\tfor (let i = 0, len = operations.length; i < len; i++) {\n\t\t\tconst operation = operations[i];\n\t\t\tconst range = operation.range;\n\n\t\t\tforceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\n\n\t\t\t// (1) -- Push old text\n\t\t\tresult.push(\n\t\t\t\tthis.getValueInRange(\n\t\t\t\t\tnew Range(\n\t\t\t\t\t\tlastEndLineNumber,\n\t\t\t\t\t\tlastEndColumn,\n\t\t\t\t\t\trange.startLineNumber,\n\t\t\t\t\t\trange.startColumn,\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t);\n\n\t\t\t// (2) -- Push new text\n\t\t\tif (operation.text.length > 0) {\n\t\t\t\tresult.push(operation.text);\n\t\t\t}\n\n\t\t\tlastEndLineNumber = range.endLineNumber;\n\t\t\tlastEndColumn = range.endColumn;\n\t\t}\n\n\t\tconst text = result.join(\"\");\n\t\tconst [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n\n\t\treturn {\n\t\t\tsortIndex: 0,\n\t\t\tidentifier: operations[0].identifier,\n\t\t\trange: entireEditRange,\n\t\t\trangeOffset: this.getOffsetAt(\n\t\t\t\tentireEditRange.startLineNumber,\n\t\t\t\tentireEditRange.startColumn,\n\t\t\t),\n\t\t\trangeLength: this.getValueLengthInRange(\n\t\t\t\tentireEditRange,\n\t\t\t\tEndOfLinePreference.TextDefined,\n\t\t\t),\n\t\t\ttext: text,\n\t\t\teolCount: eolCount,\n\t\t\tfirstLineLength: firstLineLength,\n\t\t\tlastLineLength: lastLineLength,\n\t\t\tforceMoveMarkers: forceMoveMarkers,\n\t\t\tisAutoWhitespaceEdit: false,\n\t\t};\n\t}\n\n\tprivate _doApplyEdits(\n\t\toperations: IValidatedEditOperation[],\n\t): IInternalModelContentChange[] {\n\t\toperations.sort(PieceTreeTextBuffer._sortOpsDescending);\n\n\t\tconst contentChanges: IInternalModelContentChange[] = [];\n\n\t\t// operations are from bottom to top\n\t\tfor (let i = 0; i < operations.length; i++) {\n\t\t\tconst op = operations[i];\n\n\t\t\tconst startLineNumber = op.range.startLineNumber;\n\t\t\tconst startColumn = op.range.startColumn;\n\t\t\tconst endLineNumber = op.range.endLineNumber;\n\t\t\tconst endColumn = op.range.endColumn;\n\n\t\t\tif (\n\t\t\t\tstartLineNumber === endLineNumber &&\n\t\t\t\tstartColumn === endColumn &&\n\t\t\t\top.text.length === 0\n\t\t\t) {\n\t\t\t\t// no-op\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (op.text) {\n\t\t\t\t// replacement\n\t\t\t\tthis._pieceTree.delete(op.rangeOffset, op.rangeLength);\n\t\t\t\tthis._pieceTree.insert(op.rangeOffset, op.text, true);\n\t\t\t} else {\n\t\t\t\t// deletion\n\t\t\t\tthis._pieceTree.delete(op.rangeOffset, op.rangeLength);\n\t\t\t}\n\n\t\t\tconst contentChangeRange = new Range(\n\t\t\t\tstartLineNumber,\n\t\t\t\tstartColumn,\n\t\t\t\tendLineNumber,\n\t\t\t\tendColumn,\n\t\t\t);\n\t\t\tcontentChanges.push({\n\t\t\t\trange: contentChangeRange,\n\t\t\t\trangeLength: op.rangeLength,\n\t\t\t\ttext: op.text,\n\t\t\t\trangeOffset: op.rangeOffset,\n\t\t\t\tforceMoveMarkers: op.forceMoveMarkers,\n\t\t\t});\n\t\t}\n\t\treturn contentChanges;\n\t}\n\n\tfindMatchesLineByLine(\n\t\tsearchRange: Range,\n\t\tsearchData: SearchData,\n\t\tcaptureMatches: boolean,\n\t\tlimitResultCount: number,\n\t): FindMatch[] {\n\t\treturn this._pieceTree.findMatchesLineByLine(\n\t\t\tsearchRange,\n\t\t\tsearchData,\n\t\t\tcaptureMatches,\n\t\t\tlimitResultCount,\n\t\t);\n\t}\n\n\t// #endregion\n\n\t// #region helper\n\t// testing purpose.\n\tpublic getPieceTree(): PieceTreeBase {\n\t\treturn this._pieceTree;\n\t}\n\n\tpublic static _getInverseEditRange(range: Range, text: string) {\n\t\tconst startLineNumber = range.startLineNumber;\n\t\tconst startColumn = range.startColumn;\n\t\tconst [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n\t\tlet resultRange: Range;\n\n\t\tif (text.length > 0) {\n\t\t\t// the operation inserts something\n\t\t\tconst lineCount = eolCount + 1;\n\n\t\t\tif (lineCount === 1) {\n\t\t\t\t// single line insert\n\t\t\t\tresultRange = new Range(\n\t\t\t\t\tstartLineNumber,\n\t\t\t\t\tstartColumn,\n\t\t\t\t\tstartLineNumber,\n\t\t\t\t\tstartColumn + firstLineLength,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t// multi line insert\n\t\t\t\tresultRange = new Range(\n\t\t\t\t\tstartLineNumber,\n\t\t\t\t\tstartColumn,\n\t\t\t\t\tstartLineNumber + lineCount - 1,\n\t\t\t\t\tlastLineLength + 1,\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\t// There is nothing to insert\n\t\t\tresultRange = new Range(\n\t\t\t\tstartLineNumber,\n\t\t\t\tstartColumn,\n\t\t\t\tstartLineNumber,\n\t\t\t\tstartColumn,\n\t\t\t);\n\t\t}\n\n\t\treturn resultRange;\n\t}\n\n\t/**\n\t * Assumes `operations` are validated and sorted ascending\n\t */\n\tpublic static _getInverseEditRanges(\n\t\toperations: IValidatedEditOperation[],\n\t): Range[] {\n\t\tconst result: Range[] = [];\n\n\t\tlet prevOpEndLineNumber = 0;\n\t\tlet prevOpEndColumn = 0;\n\t\tlet prevOp: IValidatedEditOperation | null = null;\n\t\tfor (let i = 0, len = operations.length; i < len; i++) {\n\t\t\tconst op = operations[i];\n\n\t\t\tlet startLineNumber: number;\n\t\t\tlet startColumn: number;\n\n\t\t\tif (prevOp) {\n\t\t\t\tif (prevOp.range.endLineNumber === op.range.startLineNumber) {\n\t\t\t\t\tstartLineNumber = prevOpEndLineNumber;\n\t\t\t\t\tstartColumn =\n\t\t\t\t\t\tprevOpEndColumn +\n\t\t\t\t\t\t(op.range.startColumn - prevOp.range.endColumn);\n\t\t\t\t} else {\n\t\t\t\t\tstartLineNumber =\n\t\t\t\t\t\tprevOpEndLineNumber +\n\t\t\t\t\t\t(op.range.startLineNumber - prevOp.range.endLineNumber);\n\t\t\t\t\tstartColumn = op.range.startColumn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstartLineNumber = op.range.startLineNumber;\n\t\t\t\tstartColumn = op.range.startColumn;\n\t\t\t}\n\n\t\t\tlet resultRange: Range;\n\n\t\t\tif (op.text.length > 0) {\n\t\t\t\t// the operation inserts something\n\t\t\t\tconst lineCount = op.eolCount + 1;\n\n\t\t\t\tif (lineCount === 1) {\n\t\t\t\t\t// single line insert\n\t\t\t\t\tresultRange = new Range(\n\t\t\t\t\t\tstartLineNumber,\n\t\t\t\t\t\tstartColumn,\n\t\t\t\t\t\tstartLineNumber,\n\t\t\t\t\t\tstartColumn + op.firstLineLength,\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\t// multi line insert\n\t\t\t\t\tresultRange = new Range(\n\t\t\t\t\t\tstartLineNumber,\n\t\t\t\t\t\tstartColumn,\n\t\t\t\t\t\tstartLineNumber + lineCount - 1,\n\t\t\t\t\t\top.lastLineLength + 1,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// There is nothing to insert\n\t\t\t\tresultRange = new Range(\n\t\t\t\t\tstartLineNumber,\n\t\t\t\t\tstartColumn,\n\t\t\t\t\tstartLineNumber,\n\t\t\t\t\tstartColumn,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tprevOpEndLineNumber = resultRange.endLineNumber;\n\t\t\tprevOpEndColumn = resultRange.endColumn;\n\n\t\t\tresult.push(resultRange);\n\t\t\tprevOp = op;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate static _sortOpsAscending(\n\t\ta: IValidatedEditOperation,\n\t\tb: IValidatedEditOperation,\n\t): number {\n\t\tconst r = Range.compareRangesUsingEnds(a.range, b.range);\n\t\tif (r === 0) {\n\t\t\treturn a.sortIndex - b.sortIndex;\n\t\t}\n\t\treturn r;\n\t}\n\n\tprivate static _sortOpsDescending(\n\t\ta: IValidatedEditOperation,\n\t\tb: IValidatedEditOperation,\n\t): number {\n\t\tconst r = Range.compareRangesUsingEnds(a.range, b.range);\n\t\tif (r === 0) {\n\t\t\treturn b.sortIndex - a.sortIndex;\n\t\t}\n\t\treturn -r;\n\t}\n\t// #endregion\n}\n"],
  "mappings": "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",
  "names": []
}
