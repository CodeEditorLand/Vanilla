{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { ApplyEditsResult, EndOfLinePreference, FindMatch, IInternalModelContentChange, ISingleEditOperationIdentifier, ITextBuffer, ITextSnapshot, ValidAnnotatedEditOperation, IValidEditOperation, SearchData } from '../../model.js';\nimport { PieceTreeBase, StringBuffer } from './pieceTreeBase.js';\nimport { countEOL, StringEOL } from '../../core/eolCounter.js';\nimport { TextChange } from '../../core/textChange.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\n\nexport interface IValidatedEditOperation {\n\tsortIndex: number;\n\tidentifier: ISingleEditOperationIdentifier | null;\n\trange: Range;\n\trangeOffset: number;\n\trangeLength: number;\n\ttext: string;\n\teolCount: number;\n\tfirstLineLength: number;\n\tlastLineLength: number;\n\tforceMoveMarkers: boolean;\n\tisAutoWhitespaceEdit: boolean;\n}\n\ninterface IReverseSingleEditOperation extends IValidEditOperation {\n\tsortIndex: number;\n}\n\nexport class PieceTreeTextBuffer extends Disposable implements ITextBuffer {\n\tprivate _pieceTree: PieceTreeBase;\n\tprivate readonly _BOM: string;\n\tprivate _mightContainRTL: boolean;\n\tprivate _mightContainUnusualLineTerminators: boolean;\n\tprivate _mightContainNonBasicASCII: boolean;\n\n\tprivate readonly _onDidChangeContent: Emitter<void> = this._register(new Emitter<void>());\n\tpublic readonly onDidChangeContent: Event<void> = this._onDidChangeContent.event;\n\n\tconstructor(chunks: StringBuffer[], BOM: string, eol: '\\r\\n' | '\\n', containsRTL: boolean, containsUnusualLineTerminators: boolean, isBasicASCII: boolean, eolNormalized: boolean) {\n\t\tsuper();\n\t\tthis._BOM = BOM;\n\t\tthis._mightContainNonBasicASCII = !isBasicASCII;\n\t\tthis._mightContainRTL = containsRTL;\n\t\tthis._mightContainUnusualLineTerminators = containsUnusualLineTerminators;\n\t\tthis._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n\t}\n\n\t// #region TextBuffer\n\tpublic equals(other: ITextBuffer): boolean {\n\t\tif (!(other instanceof PieceTreeTextBuffer)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this._BOM !== other._BOM) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.getEOL() !== other.getEOL()) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this._pieceTree.equal(other._pieceTree);\n\t}\n\tpublic mightContainRTL(): boolean {\n\t\treturn this._mightContainRTL;\n\t}\n\tpublic mightContainUnusualLineTerminators(): boolean {\n\t\treturn this._mightContainUnusualLineTerminators;\n\t}\n\tpublic resetMightContainUnusualLineTerminators(): void {\n\t\tthis._mightContainUnusualLineTerminators = false;\n\t}\n\tpublic mightContainNonBasicASCII(): boolean {\n\t\treturn this._mightContainNonBasicASCII;\n\t}\n\tpublic getBOM(): string {\n\t\treturn this._BOM;\n\t}\n\tpublic getEOL(): '\\r\\n' | '\\n' {\n\t\treturn this._pieceTree.getEOL();\n\t}\n\n\tpublic createSnapshot(preserveBOM: boolean): ITextSnapshot {\n\t\treturn this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\n\t}\n\n\tpublic getOffsetAt(lineNumber: number, column: number): number {\n\t\treturn this._pieceTree.getOffsetAt(lineNumber, column);\n\t}\n\n\tpublic getPositionAt(offset: number): Position {\n\t\treturn this._pieceTree.getPositionAt(offset);\n\t}\n\n\tpublic getRangeAt(start: number, length: number): Range {\n\t\tconst end = start + length;\n\t\tconst startPosition = this.getPositionAt(start);\n\t\tconst endPosition = this.getPositionAt(end);\n\t\treturn new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n\t}\n\n\tpublic getValueInRange(range: Range, eol: EndOfLinePreference = EndOfLinePreference.TextDefined): string {\n\t\tif (range.isEmpty()) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst lineEnding = this._getEndOfLine(eol);\n\t\treturn this._pieceTree.getValueInRange(range, lineEnding);\n\t}\n\n\tpublic getValueLengthInRange(range: Range, eol: EndOfLinePreference = EndOfLinePreference.TextDefined): number {\n\t\tif (range.isEmpty()) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (range.startLineNumber === range.endLineNumber) {\n\t\t\treturn (range.endColumn - range.startColumn);\n\t\t}\n\n\t\tconst startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n\t\tconst endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n\n\t\t// offsets use the text EOL, so we need to compensate for length differences\n\t\t// if the requested EOL doesn't match the text EOL\n\t\tlet eolOffsetCompensation = 0;\n\t\tconst desiredEOL = this._getEndOfLine(eol);\n\t\tconst actualEOL = this.getEOL();\n\t\tif (desiredEOL.length !== actualEOL.length) {\n\t\t\tconst delta = desiredEOL.length - actualEOL.length;\n\t\t\tconst eolCount = range.endLineNumber - range.startLineNumber;\n\t\t\teolOffsetCompensation = delta * eolCount;\n\t\t}\n\n\t\treturn endOffset - startOffset + eolOffsetCompensation;\n\t}\n\n\tpublic getCharacterCountInRange(range: Range, eol: EndOfLinePreference = EndOfLinePreference.TextDefined): number {\n\t\tif (this._mightContainNonBasicASCII) {\n\t\t\t// we must count by iterating\n\n\t\t\tlet result = 0;\n\n\t\t\tconst fromLineNumber = range.startLineNumber;\n\t\t\tconst toLineNumber = range.endLineNumber;\n\t\t\tfor (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n\t\t\t\tconst lineContent = this.getLineContent(lineNumber);\n\t\t\t\tconst fromOffset = (lineNumber === fromLineNumber ? range.startColumn - 1 : 0);\n\t\t\t\tconst toOffset = (lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length);\n\n\t\t\t\tfor (let offset = fromOffset; offset < toOffset; offset++) {\n\t\t\t\t\tif (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\n\t\t\t\t\t\tresult = result + 1;\n\t\t\t\t\t\toffset = offset + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult = result + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresult += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\n\n\t\t\treturn result;\n\t\t}\n\n\t\treturn this.getValueLengthInRange(range, eol);\n\t}\n\n\tpublic getNearestChunk(offset: number): string {\n\t\treturn this._pieceTree.getNearestChunk(offset);\n\t}\n\n\tpublic getLength(): number {\n\t\treturn this._pieceTree.getLength();\n\t}\n\n\tpublic getLineCount(): number {\n\t\treturn this._pieceTree.getLineCount();\n\t}\n\n\tpublic getLinesContent(): string[] {\n\t\treturn this._pieceTree.getLinesContent();\n\t}\n\n\tpublic getLineContent(lineNumber: number): string {\n\t\treturn this._pieceTree.getLineContent(lineNumber);\n\t}\n\n\tpublic getLineCharCode(lineNumber: number, index: number): number {\n\t\treturn this._pieceTree.getLineCharCode(lineNumber, index);\n\t}\n\n\tpublic getCharCode(offset: number): number {\n\t\treturn this._pieceTree.getCharCode(offset);\n\t}\n\n\tpublic getLineLength(lineNumber: number): number {\n\t\treturn this._pieceTree.getLineLength(lineNumber);\n\t}\n\n\tpublic getLineMinColumn(lineNumber: number): number {\n\t\treturn 1;\n\t}\n\n\tpublic getLineMaxColumn(lineNumber: number): number {\n\t\treturn this.getLineLength(lineNumber) + 1;\n\t}\n\n\tpublic getLineFirstNonWhitespaceColumn(lineNumber: number): number {\n\t\tconst result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n\t\tif (result === -1) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn result + 1;\n\t}\n\n\tpublic getLineLastNonWhitespaceColumn(lineNumber: number): number {\n\t\tconst result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n\t\tif (result === -1) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn result + 2;\n\t}\n\n\tprivate _getEndOfLine(eol: EndOfLinePreference): string {\n\t\tswitch (eol) {\n\t\t\tcase EndOfLinePreference.LF:\n\t\t\t\treturn '\\n';\n\t\t\tcase EndOfLinePreference.CRLF:\n\t\t\t\treturn '\\r\\n';\n\t\t\tcase EndOfLinePreference.TextDefined:\n\t\t\t\treturn this.getEOL();\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unknown EOL preference');\n\t\t}\n\t}\n\n\tpublic setEOL(newEOL: '\\r\\n' | '\\n'): void {\n\t\tthis._pieceTree.setEOL(newEOL);\n\t}\n\n\tpublic applyEdits(rawOperations: ValidAnnotatedEditOperation[], recordTrimAutoWhitespace: boolean, computeUndoEdits: boolean): ApplyEditsResult {\n\t\tlet mightContainRTL = this._mightContainRTL;\n\t\tlet mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;\n\t\tlet mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n\t\tlet canReduceOperations = true;\n\n\t\tlet operations: IValidatedEditOperation[] = [];\n\t\tfor (let i = 0; i < rawOperations.length; i++) {\n\t\t\tconst op = rawOperations[i];\n\t\t\tif (canReduceOperations && op._isTracked) {\n\t\t\t\tcanReduceOperations = false;\n\t\t\t}\n\t\t\tconst validatedRange = op.range;\n\t\t\tif (op.text) {\n\t\t\t\tlet textMightContainNonBasicASCII = true;\n\t\t\t\tif (!mightContainNonBasicASCII) {\n\t\t\t\t\ttextMightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n\t\t\t\t\tmightContainNonBasicASCII = textMightContainNonBasicASCII;\n\t\t\t\t}\n\t\t\t\tif (!mightContainRTL && textMightContainNonBasicASCII) {\n\t\t\t\t\t// check if the new inserted text contains RTL\n\t\t\t\t\tmightContainRTL = strings.containsRTL(op.text);\n\t\t\t\t}\n\t\t\t\tif (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {\n\t\t\t\t\t// check if the new inserted text contains unusual line terminators\n\t\t\t\t\tmightContainUnusualLineTerminators = strings.containsUnusualLineTerminators(op.text);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet validText = '';\n\t\t\tlet eolCount = 0;\n\t\t\tlet firstLineLength = 0;\n\t\t\tlet lastLineLength = 0;\n\t\t\tif (op.text) {\n\t\t\t\tlet strEOL: StringEOL;\n\t\t\t\t[eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);\n\n\t\t\t\tconst bufferEOL = this.getEOL();\n\t\t\t\tconst expectedStrEOL = (bufferEOL === '\\r\\n' ? StringEOL.CRLF : StringEOL.LF);\n\t\t\t\tif (strEOL === StringEOL.Unknown || strEOL === expectedStrEOL) {\n\t\t\t\t\tvalidText = op.text;\n\t\t\t\t} else {\n\t\t\t\t\tvalidText = op.text.replace(/\\r\\n|\\r|\\n/g, bufferEOL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toperations[i] = {\n\t\t\t\tsortIndex: i,\n\t\t\t\tidentifier: op.identifier || null,\n\t\t\t\trange: validatedRange,\n\t\t\t\trangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n\t\t\t\trangeLength: this.getValueLengthInRange(validatedRange),\n\t\t\t\ttext: validText,\n\t\t\t\teolCount: eolCount,\n\t\t\t\tfirstLineLength: firstLineLength,\n\t\t\t\tlastLineLength: lastLineLength,\n\t\t\t\tforceMoveMarkers: Boolean(op.forceMoveMarkers),\n\t\t\t\tisAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n\t\t\t};\n\t\t}\n\n\t\t// Sort operations ascending\n\t\toperations.sort(PieceTreeTextBuffer._sortOpsAscending);\n\n\t\tlet hasTouchingRanges = false;\n\t\tfor (let i = 0, count = operations.length - 1; i < count; i++) {\n\t\t\tconst rangeEnd = operations[i].range.getEndPosition();\n\t\t\tconst nextRangeStart = operations[i + 1].range.getStartPosition();\n\n\t\t\tif (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n\t\t\t\tif (nextRangeStart.isBefore(rangeEnd)) {\n\t\t\t\t\t// overlapping ranges\n\t\t\t\t\tthrow new Error('Overlapping ranges are not allowed!');\n\t\t\t\t}\n\t\t\t\thasTouchingRanges = true;\n\t\t\t}\n\t\t}\n\n\t\tif (canReduceOperations) {\n\t\t\toperations = this._reduceOperations(operations);\n\t\t}\n\n\t\t// Delta encode operations\n\t\tconst reverseRanges = (computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : []);\n\t\tconst newTrimAutoWhitespaceCandidates: { lineNumber: number; oldContent: string }[] = [];\n\t\tif (recordTrimAutoWhitespace) {\n\t\t\tfor (let i = 0; i < operations.length; i++) {\n\t\t\t\tconst op = operations[i];\n\t\t\t\tconst reverseRange = reverseRanges[i];\n\n\t\t\t\tif (op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n\t\t\t\t\t// Record already the future line numbers that might be auto whitespace removal candidates on next edit\n\t\t\t\t\tfor (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n\t\t\t\t\t\tlet currentLineContent = '';\n\t\t\t\t\t\tif (lineNumber === reverseRange.startLineNumber) {\n\t\t\t\t\t\t\tcurrentLineContent = this.getLineContent(op.range.startLineNumber);\n\t\t\t\t\t\t\tif (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet reverseOperations: IReverseSingleEditOperation[] | null = null;\n\t\tif (computeUndoEdits) {\n\n\t\t\tlet reverseRangeDeltaOffset = 0;\n\t\t\treverseOperations = [];\n\t\t\tfor (let i = 0; i < operations.length; i++) {\n\t\t\t\tconst op = operations[i];\n\t\t\t\tconst reverseRange = reverseRanges[i];\n\t\t\t\tconst bufferText = this.getValueInRange(op.range);\n\t\t\t\tconst reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;\n\t\t\t\treverseRangeDeltaOffset += (op.text.length - bufferText.length);\n\n\t\t\t\treverseOperations[i] = {\n\t\t\t\t\tsortIndex: op.sortIndex,\n\t\t\t\t\tidentifier: op.identifier,\n\t\t\t\t\trange: reverseRange,\n\t\t\t\t\ttext: bufferText,\n\t\t\t\t\ttextChange: new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Can only sort reverse operations when the order is not significant\n\t\t\tif (!hasTouchingRanges) {\n\t\t\t\treverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);\n\t\t\t}\n\t\t}\n\n\n\t\tthis._mightContainRTL = mightContainRTL;\n\t\tthis._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;\n\t\tthis._mightContainNonBasicASCII = mightContainNonBasicASCII;\n\n\t\tconst contentChanges = this._doApplyEdits(operations);\n\n\t\tlet trimAutoWhitespaceLineNumbers: number[] | null = null;\n\t\tif (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n\t\t\t// sort line numbers auto whitespace removal candidates for next edit descending\n\t\t\tnewTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);\n\n\t\t\ttrimAutoWhitespaceLineNumbers = [];\n\t\t\tfor (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n\t\t\t\tconst lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n\t\t\t\tif (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n\t\t\t\t\t// Do not have the same line number twice\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n\t\t\t\tconst lineContent = this.getLineContent(lineNumber);\n\n\t\t\t\tif (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttrimAutoWhitespaceLineNumbers.push(lineNumber);\n\t\t\t}\n\t\t}\n\n\t\tthis._onDidChangeContent.fire();\n\n\t\treturn new ApplyEditsResult(\n\t\t\treverseOperations,\n\t\t\tcontentChanges,\n\t\t\ttrimAutoWhitespaceLineNumbers\n\t\t);\n\t}\n\n\t/**\n\t * Transform operations such that they represent the same logic edit,\n\t * but that they also do not cause OOM crashes.\n\t */\n\tprivate _reduceOperations(operations: IValidatedEditOperation[]): IValidatedEditOperation[] {\n\t\tif (operations.length < 1000) {\n\t\t\t// We know from empirical testing that a thousand edits work fine regardless of their shape.\n\t\t\treturn operations;\n\t\t}\n\n\t\t// At one point, due to how events are emitted and how each operation is handled,\n\t\t// some operations can trigger a high amount of temporary string allocations,\n\t\t// that will immediately get edited again.\n\t\t// e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n\t\t// Therefore, the strategy is to collapse all the operations into a huge single edit operation\n\t\treturn [this._toSingleEditOperation(operations)];\n\t}\n\n\t_toSingleEditOperation(operations: IValidatedEditOperation[]): IValidatedEditOperation {\n\t\tlet forceMoveMarkers = false;\n\t\tconst firstEditRange = operations[0].range;\n\t\tconst lastEditRange = operations[operations.length - 1].range;\n\t\tconst entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);\n\t\tlet lastEndLineNumber = firstEditRange.startLineNumber;\n\t\tlet lastEndColumn = firstEditRange.startColumn;\n\t\tconst result: string[] = [];\n\n\t\tfor (let i = 0, len = operations.length; i < len; i++) {\n\t\t\tconst operation = operations[i];\n\t\t\tconst range = operation.range;\n\n\t\t\tforceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\n\n\t\t\t// (1) -- Push old text\n\t\t\tresult.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn)));\n\n\t\t\t// (2) -- Push new text\n\t\t\tif (operation.text.length > 0) {\n\t\t\t\tresult.push(operation.text);\n\t\t\t}\n\n\t\t\tlastEndLineNumber = range.endLineNumber;\n\t\t\tlastEndColumn = range.endColumn;\n\t\t}\n\n\t\tconst text = result.join('');\n\t\tconst [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n\n\t\treturn {\n\t\t\tsortIndex: 0,\n\t\t\tidentifier: operations[0].identifier,\n\t\t\trange: entireEditRange,\n\t\t\trangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n\t\t\trangeLength: this.getValueLengthInRange(entireEditRange, EndOfLinePreference.TextDefined),\n\t\t\ttext: text,\n\t\t\teolCount: eolCount,\n\t\t\tfirstLineLength: firstLineLength,\n\t\t\tlastLineLength: lastLineLength,\n\t\t\tforceMoveMarkers: forceMoveMarkers,\n\t\t\tisAutoWhitespaceEdit: false\n\t\t};\n\t}\n\n\tprivate _doApplyEdits(operations: IValidatedEditOperation[]): IInternalModelContentChange[] {\n\t\toperations.sort(PieceTreeTextBuffer._sortOpsDescending);\n\n\t\tconst contentChanges: IInternalModelContentChange[] = [];\n\n\t\t// operations are from bottom to top\n\t\tfor (let i = 0; i < operations.length; i++) {\n\t\t\tconst op = operations[i];\n\n\t\t\tconst startLineNumber = op.range.startLineNumber;\n\t\t\tconst startColumn = op.range.startColumn;\n\t\t\tconst endLineNumber = op.range.endLineNumber;\n\t\t\tconst endColumn = op.range.endColumn;\n\n\t\t\tif (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {\n\t\t\t\t// no-op\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (op.text) {\n\t\t\t\t// replacement\n\t\t\t\tthis._pieceTree.delete(op.rangeOffset, op.rangeLength);\n\t\t\t\tthis._pieceTree.insert(op.rangeOffset, op.text, true);\n\n\t\t\t} else {\n\t\t\t\t// deletion\n\t\t\t\tthis._pieceTree.delete(op.rangeOffset, op.rangeLength);\n\t\t\t}\n\n\t\t\tconst contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n\t\t\tcontentChanges.push({\n\t\t\t\trange: contentChangeRange,\n\t\t\t\trangeLength: op.rangeLength,\n\t\t\t\ttext: op.text,\n\t\t\t\trangeOffset: op.rangeOffset,\n\t\t\t\tforceMoveMarkers: op.forceMoveMarkers\n\t\t\t});\n\t\t}\n\t\treturn contentChanges;\n\t}\n\n\tfindMatchesLineByLine(searchRange: Range, searchData: SearchData, captureMatches: boolean, limitResultCount: number): FindMatch[] {\n\t\treturn this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n\t}\n\n\t// #endregion\n\n\t// #region helper\n\t// testing purpose.\n\tpublic getPieceTree(): PieceTreeBase {\n\t\treturn this._pieceTree;\n\t}\n\n\tpublic static _getInverseEditRange(range: Range, text: string) {\n\t\tconst startLineNumber = range.startLineNumber;\n\t\tconst startColumn = range.startColumn;\n\t\tconst [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n\t\tlet resultRange: Range;\n\n\t\tif (text.length > 0) {\n\t\t\t// the operation inserts something\n\t\t\tconst lineCount = eolCount + 1;\n\n\t\t\tif (lineCount === 1) {\n\t\t\t\t// single line insert\n\t\t\t\tresultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + firstLineLength);\n\t\t\t} else {\n\t\t\t\t// multi line insert\n\t\t\t\tresultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, lastLineLength + 1);\n\t\t\t}\n\t\t} else {\n\t\t\t// There is nothing to insert\n\t\t\tresultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n\t\t}\n\n\t\treturn resultRange;\n\t}\n\n\t/**\n\t * Assumes `operations` are validated and sorted ascending\n\t */\n\tpublic static _getInverseEditRanges(operations: IValidatedEditOperation[]): Range[] {\n\t\tconst result: Range[] = [];\n\n\t\tlet prevOpEndLineNumber: number = 0;\n\t\tlet prevOpEndColumn: number = 0;\n\t\tlet prevOp: IValidatedEditOperation | null = null;\n\t\tfor (let i = 0, len = operations.length; i < len; i++) {\n\t\t\tconst op = operations[i];\n\n\t\t\tlet startLineNumber: number;\n\t\t\tlet startColumn: number;\n\n\t\t\tif (prevOp) {\n\t\t\t\tif (prevOp.range.endLineNumber === op.range.startLineNumber) {\n\t\t\t\t\tstartLineNumber = prevOpEndLineNumber;\n\t\t\t\t\tstartColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n\t\t\t\t} else {\n\t\t\t\t\tstartLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n\t\t\t\t\tstartColumn = op.range.startColumn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstartLineNumber = op.range.startLineNumber;\n\t\t\t\tstartColumn = op.range.startColumn;\n\t\t\t}\n\n\t\t\tlet resultRange: Range;\n\n\t\t\tif (op.text.length > 0) {\n\t\t\t\t// the operation inserts something\n\t\t\t\tconst lineCount = op.eolCount + 1;\n\n\t\t\t\tif (lineCount === 1) {\n\t\t\t\t\t// single line insert\n\t\t\t\t\tresultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);\n\t\t\t\t} else {\n\t\t\t\t\t// multi line insert\n\t\t\t\t\tresultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// There is nothing to insert\n\t\t\t\tresultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n\t\t\t}\n\n\t\t\tprevOpEndLineNumber = resultRange.endLineNumber;\n\t\t\tprevOpEndColumn = resultRange.endColumn;\n\n\t\t\tresult.push(resultRange);\n\t\t\tprevOp = op;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate static _sortOpsAscending(a: IValidatedEditOperation, b: IValidatedEditOperation): number {\n\t\tconst r = Range.compareRangesUsingEnds(a.range, b.range);\n\t\tif (r === 0) {\n\t\t\treturn a.sortIndex - b.sortIndex;\n\t\t}\n\t\treturn r;\n\t}\n\n\tprivate static _sortOpsDescending(a: IValidatedEditOperation, b: IValidatedEditOperation): number {\n\t\tconst r = Range.compareRangesUsingEnds(a.range, b.range);\n\t\tif (r === 0) {\n\t\t\treturn b.sortIndex - a.sortIndex;\n\t\t}\n\t\treturn -r;\n\t}\n\t// #endregion\n}\n"],
  "mappings": ";;AAKA,SAAS,SAAS,aAAa;AAC/B,YAAY,aAAa;AACzB,SAAS,gBAAgB;AACzB,SAAS,aAAa;AACtB,SAAS,kBAAkB,qBAAqB,WAAW,6BAA6B,gCAAgC,aAAa,eAAe,6BAA6B,qBAAqB,kBAAkB;AACxN,SAAS,eAAe,oBAAoB;AAC5C,SAAS,UAAU,iBAAiB;AACpC,SAAS,kBAAkB;AAC3B,SAAS,kBAAkB;AAoBpB,MAAM,4BAA4B,WAAkC;AAAA,EAjC3E,OAiC2E;AAAA;AAAA;AAAA,EAClE;AAAA,EACS;AAAA,EACT;AAAA,EACA;AAAA,EACA;AAAA,EAES,sBAAqC,KAAK,UAAU,IAAI,QAAc,CAAC;AAAA,EACxE,qBAAkC,KAAK,oBAAoB;AAAA,EAE3E,YAAY,QAAwB,KAAa,KAAoB,aAAsB,gCAAyC,cAAuB,eAAwB;AAClL,UAAM;AACN,SAAK,OAAO;AACZ,SAAK,6BAA6B,CAAC;AACnC,SAAK,mBAAmB;AACxB,SAAK,sCAAsC;AAC3C,SAAK,aAAa,IAAI,cAAc,QAAQ,KAAK,aAAa;AAAA,EAC/D;AAAA;AAAA,EAGO,OAAO,OAA6B;AAC1C,QAAI,EAAE,iBAAiB,sBAAsB;AAC5C,aAAO;AAAA,IACR;AACA,QAAI,KAAK,SAAS,MAAM,MAAM;AAC7B,aAAO;AAAA,IACR;AACA,QAAI,KAAK,OAAO,MAAM,MAAM,OAAO,GAAG;AACrC,aAAO;AAAA,IACR;AACA,WAAO,KAAK,WAAW,MAAM,MAAM,UAAU;AAAA,EAC9C;AAAA,EACO,kBAA2B;AACjC,WAAO,KAAK;AAAA,EACb;AAAA,EACO,qCAA8C;AACpD,WAAO,KAAK;AAAA,EACb;AAAA,EACO,0CAAgD;AACtD,SAAK,sCAAsC;AAAA,EAC5C;AAAA,EACO,4BAAqC;AAC3C,WAAO,KAAK;AAAA,EACb;AAAA,EACO,SAAiB;AACvB,WAAO,KAAK;AAAA,EACb;AAAA,EACO,SAAwB;AAC9B,WAAO,KAAK,WAAW,OAAO;AAAA,EAC/B;AAAA,EAEO,eAAe,aAAqC;AAC1D,WAAO,KAAK,WAAW,eAAe,cAAc,KAAK,OAAO,EAAE;AAAA,EACnE;AAAA,EAEO,YAAY,YAAoB,QAAwB;AAC9D,WAAO,KAAK,WAAW,YAAY,YAAY,MAAM;AAAA,EACtD;AAAA,EAEO,cAAc,QAA0B;AAC9C,WAAO,KAAK,WAAW,cAAc,MAAM;AAAA,EAC5C;AAAA,EAEO,WAAW,OAAe,QAAuB;AACvD,UAAM,MAAM,QAAQ;AACpB,UAAM,gBAAgB,KAAK,cAAc,KAAK;AAC9C,UAAM,cAAc,KAAK,cAAc,GAAG;AAC1C,WAAO,IAAI,MAAM,cAAc,YAAY,cAAc,QAAQ,YAAY,YAAY,YAAY,MAAM;AAAA,EAC5G;AAAA,EAEO,gBAAgB,OAAc,MAA2B,oBAAoB,aAAqB;AACxG,QAAI,MAAM,QAAQ,GAAG;AACpB,aAAO;AAAA,IACR;AAEA,UAAM,aAAa,KAAK,cAAc,GAAG;AACzC,WAAO,KAAK,WAAW,gBAAgB,OAAO,UAAU;AAAA,EACzD;AAAA,EAEO,sBAAsB,OAAc,MAA2B,oBAAoB,aAAqB;AAC9G,QAAI,MAAM,QAAQ,GAAG;AACpB,aAAO;AAAA,IACR;AAEA,QAAI,MAAM,oBAAoB,MAAM,eAAe;AAClD,aAAQ,MAAM,YAAY,MAAM;AAAA,IACjC;AAEA,UAAM,cAAc,KAAK,YAAY,MAAM,iBAAiB,MAAM,WAAW;AAC7E,UAAM,YAAY,KAAK,YAAY,MAAM,eAAe,MAAM,SAAS;AAIvE,QAAI,wBAAwB;AAC5B,UAAM,aAAa,KAAK,cAAc,GAAG;AACzC,UAAM,YAAY,KAAK,OAAO;AAC9B,QAAI,WAAW,WAAW,UAAU,QAAQ;AAC3C,YAAM,QAAQ,WAAW,SAAS,UAAU;AAC5C,YAAM,WAAW,MAAM,gBAAgB,MAAM;AAC7C,8BAAwB,QAAQ;AAAA,IACjC;AAEA,WAAO,YAAY,cAAc;AAAA,EAClC;AAAA,EAEO,yBAAyB,OAAc,MAA2B,oBAAoB,aAAqB;AACjH,QAAI,KAAK,4BAA4B;AAGpC,UAAI,SAAS;AAEb,YAAM,iBAAiB,MAAM;AAC7B,YAAM,eAAe,MAAM;AAC3B,eAAS,aAAa,gBAAgB,cAAc,cAAc,cAAc;AAC/E,cAAM,cAAc,KAAK,eAAe,UAAU;AAClD,cAAM,aAAc,eAAe,iBAAiB,MAAM,cAAc,IAAI;AAC5E,cAAM,WAAY,eAAe,eAAe,MAAM,YAAY,IAAI,YAAY;AAElF,iBAAS,SAAS,YAAY,SAAS,UAAU,UAAU;AAC1D,cAAI,QAAQ,gBAAgB,YAAY,WAAW,MAAM,CAAC,GAAG;AAC5D,qBAAS,SAAS;AAClB,qBAAS,SAAS;AAAA,UACnB,OAAO;AACN,qBAAS,SAAS;AAAA,UACnB;AAAA,QACD;AAAA,MACD;AAEA,gBAAU,KAAK,cAAc,GAAG,EAAE,UAAU,eAAe;AAE3D,aAAO;AAAA,IACR;AAEA,WAAO,KAAK,sBAAsB,OAAO,GAAG;AAAA,EAC7C;AAAA,EAEO,gBAAgB,QAAwB;AAC9C,WAAO,KAAK,WAAW,gBAAgB,MAAM;AAAA,EAC9C;AAAA,EAEO,YAAoB;AAC1B,WAAO,KAAK,WAAW,UAAU;AAAA,EAClC;AAAA,EAEO,eAAuB;AAC7B,WAAO,KAAK,WAAW,aAAa;AAAA,EACrC;AAAA,EAEO,kBAA4B;AAClC,WAAO,KAAK,WAAW,gBAAgB;AAAA,EACxC;AAAA,EAEO,eAAe,YAA4B;AACjD,WAAO,KAAK,WAAW,eAAe,UAAU;AAAA,EACjD;AAAA,EAEO,gBAAgB,YAAoB,OAAuB;AACjE,WAAO,KAAK,WAAW,gBAAgB,YAAY,KAAK;AAAA,EACzD;AAAA,EAEO,YAAY,QAAwB;AAC1C,WAAO,KAAK,WAAW,YAAY,MAAM;AAAA,EAC1C;AAAA,EAEO,cAAc,YAA4B;AAChD,WAAO,KAAK,WAAW,cAAc,UAAU;AAAA,EAChD;AAAA,EAEO,iBAAiB,YAA4B;AACnD,WAAO;AAAA,EACR;AAAA,EAEO,iBAAiB,YAA4B;AACnD,WAAO,KAAK,cAAc,UAAU,IAAI;AAAA,EACzC;AAAA,EAEO,gCAAgC,YAA4B;AAClE,UAAM,SAAS,QAAQ,wBAAwB,KAAK,eAAe,UAAU,CAAC;AAC9E,QAAI,WAAW,IAAI;AAClB,aAAO;AAAA,IACR;AACA,WAAO,SAAS;AAAA,EACjB;AAAA,EAEO,+BAA+B,YAA4B;AACjE,UAAM,SAAS,QAAQ,uBAAuB,KAAK,eAAe,UAAU,CAAC;AAC7E,QAAI,WAAW,IAAI;AAClB,aAAO;AAAA,IACR;AACA,WAAO,SAAS;AAAA,EACjB;AAAA,EAEQ,cAAc,KAAkC;AACvD,YAAQ,KAAK;AAAA,MACZ,KAAK,oBAAoB;AACxB,eAAO;AAAA,MACR,KAAK,oBAAoB;AACxB,eAAO;AAAA,MACR,KAAK,oBAAoB;AACxB,eAAO,KAAK,OAAO;AAAA,MACpB;AACC,cAAM,IAAI,MAAM,wBAAwB;AAAA,IAC1C;AAAA,EACD;AAAA,EAEO,OAAO,QAA6B;AAC1C,SAAK,WAAW,OAAO,MAAM;AAAA,EAC9B;AAAA,EAEO,WAAW,eAA8C,0BAAmC,kBAA6C;AAC/I,QAAI,kBAAkB,KAAK;AAC3B,QAAI,qCAAqC,KAAK;AAC9C,QAAI,4BAA4B,KAAK;AACrC,QAAI,sBAAsB;AAE1B,QAAI,aAAwC,CAAC;AAC7C,aAAS,IAAI,GAAG,IAAI,cAAc,QAAQ,KAAK;AAC9C,YAAM,KAAK,cAAc,CAAC;AAC1B,UAAI,uBAAuB,GAAG,YAAY;AACzC,8BAAsB;AAAA,MACvB;AACA,YAAM,iBAAiB,GAAG;AAC1B,UAAI,GAAG,MAAM;AACZ,YAAI,gCAAgC;AACpC,YAAI,CAAC,2BAA2B;AAC/B,0CAAgC,CAAC,QAAQ,aAAa,GAAG,IAAI;AAC7D,sCAA4B;AAAA,QAC7B;AACA,YAAI,CAAC,mBAAmB,+BAA+B;AAEtD,4BAAkB,QAAQ,YAAY,GAAG,IAAI;AAAA,QAC9C;AACA,YAAI,CAAC,sCAAsC,+BAA+B;AAEzE,+CAAqC,QAAQ,+BAA+B,GAAG,IAAI;AAAA,QACpF;AAAA,MACD;AAEA,UAAI,YAAY;AAChB,UAAI,WAAW;AACf,UAAI,kBAAkB;AACtB,UAAI,iBAAiB;AACrB,UAAI,GAAG,MAAM;AACZ,YAAI;AACJ,SAAC,UAAU,iBAAiB,gBAAgB,MAAM,IAAI,SAAS,GAAG,IAAI;AAEtE,cAAM,YAAY,KAAK,OAAO;AAC9B,cAAM,iBAAkB,cAAc,SAAS,UAAU,OAAO,UAAU;AAC1E,YAAI,WAAW,UAAU,WAAW,WAAW,gBAAgB;AAC9D,sBAAY,GAAG;AAAA,QAChB,OAAO;AACN,sBAAY,GAAG,KAAK,QAAQ,eAAe,SAAS;AAAA,QACrD;AAAA,MACD;AAEA,iBAAW,CAAC,IAAI;AAAA,QACf,WAAW;AAAA,QACX,YAAY,GAAG,cAAc;AAAA,QAC7B,OAAO;AAAA,QACP,aAAa,KAAK,YAAY,eAAe,iBAAiB,eAAe,WAAW;AAAA,QACxF,aAAa,KAAK,sBAAsB,cAAc;AAAA,QACtD,MAAM;AAAA,QACN;AAAA,QACA;AAAA,QACA;AAAA,QACA,kBAAkB,QAAQ,GAAG,gBAAgB;AAAA,QAC7C,sBAAsB,GAAG,wBAAwB;AAAA,MAClD;AAAA,IACD;AAGA,eAAW,KAAK,oBAAoB,iBAAiB;AAErD,QAAI,oBAAoB;AACxB,aAAS,IAAI,GAAG,QAAQ,WAAW,SAAS,GAAG,IAAI,OAAO,KAAK;AAC9D,YAAM,WAAW,WAAW,CAAC,EAAE,MAAM,eAAe;AACpD,YAAM,iBAAiB,WAAW,IAAI,CAAC,EAAE,MAAM,iBAAiB;AAEhE,UAAI,eAAe,gBAAgB,QAAQ,GAAG;AAC7C,YAAI,eAAe,SAAS,QAAQ,GAAG;AAEtC,gBAAM,IAAI,MAAM,qCAAqC;AAAA,QACtD;AACA,4BAAoB;AAAA,MACrB;AAAA,IACD;AAEA,QAAI,qBAAqB;AACxB,mBAAa,KAAK,kBAAkB,UAAU;AAAA,IAC/C;AAGA,UAAM,gBAAiB,oBAAoB,2BAA2B,oBAAoB,sBAAsB,UAAU,IAAI,CAAC;AAC/H,UAAM,kCAAgF,CAAC;AACvF,QAAI,0BAA0B;AAC7B,eAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;AAC3C,cAAM,KAAK,WAAW,CAAC;AACvB,cAAM,eAAe,cAAc,CAAC;AAEpC,YAAI,GAAG,wBAAwB,GAAG,MAAM,QAAQ,GAAG;AAElD,mBAAS,aAAa,aAAa,iBAAiB,cAAc,aAAa,eAAe,cAAc;AAC3G,gBAAI,qBAAqB;AACzB,gBAAI,eAAe,aAAa,iBAAiB;AAChD,mCAAqB,KAAK,eAAe,GAAG,MAAM,eAAe;AACjE,kBAAI,QAAQ,wBAAwB,kBAAkB,MAAM,IAAI;AAC/D;AAAA,cACD;AAAA,YACD;AACA,4CAAgC,KAAK,EAAE,YAAwB,YAAY,mBAAmB,CAAC;AAAA,UAChG;AAAA,QACD;AAAA,MACD;AAAA,IACD;AAEA,QAAI,oBAA0D;AAC9D,QAAI,kBAAkB;AAErB,UAAI,0BAA0B;AAC9B,0BAAoB,CAAC;AACrB,eAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;AAC3C,cAAM,KAAK,WAAW,CAAC;AACvB,cAAM,eAAe,cAAc,CAAC;AACpC,cAAM,aAAa,KAAK,gBAAgB,GAAG,KAAK;AAChD,cAAM,qBAAqB,GAAG,cAAc;AAC5C,mCAA4B,GAAG,KAAK,SAAS,WAAW;AAExD,0BAAkB,CAAC,IAAI;AAAA,UACtB,WAAW,GAAG;AAAA,UACd,YAAY,GAAG;AAAA,UACf,OAAO;AAAA,UACP,MAAM;AAAA,UACN,YAAY,IAAI,WAAW,GAAG,aAAa,YAAY,oBAAoB,GAAG,IAAI;AAAA,QACnF;AAAA,MACD;AAGA,UAAI,CAAC,mBAAmB;AACvB,0BAAkB,KAAK,CAAC,GAAG,MAAM,EAAE,YAAY,EAAE,SAAS;AAAA,MAC3D;AAAA,IACD;AAGA,SAAK,mBAAmB;AACxB,SAAK,sCAAsC;AAC3C,SAAK,6BAA6B;AAElC,UAAM,iBAAiB,KAAK,cAAc,UAAU;AAEpD,QAAI,gCAAiD;AACrD,QAAI,4BAA4B,gCAAgC,SAAS,GAAG;AAE3E,sCAAgC,KAAK,CAAC,GAAG,MAAM,EAAE,aAAa,EAAE,UAAU;AAE1E,sCAAgC,CAAC;AACjC,eAAS,IAAI,GAAG,MAAM,gCAAgC,QAAQ,IAAI,KAAK,KAAK;AAC3E,cAAM,aAAa,gCAAgC,CAAC,EAAE;AACtD,YAAI,IAAI,KAAK,gCAAgC,IAAI,CAAC,EAAE,eAAe,YAAY;AAE9E;AAAA,QACD;AAEA,cAAM,cAAc,gCAAgC,CAAC,EAAE;AACvD,cAAM,cAAc,KAAK,eAAe,UAAU;AAElD,YAAI,YAAY,WAAW,KAAK,gBAAgB,eAAe,QAAQ,wBAAwB,WAAW,MAAM,IAAI;AACnH;AAAA,QACD;AAEA,sCAA8B,KAAK,UAAU;AAAA,MAC9C;AAAA,IACD;AAEA,SAAK,oBAAoB,KAAK;AAE9B,WAAO,IAAI;AAAA,MACV;AAAA,MACA;AAAA,MACA;AAAA,IACD;AAAA,EACD;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,kBAAkB,YAAkE;AAC3F,QAAI,WAAW,SAAS,KAAM;AAE7B,aAAO;AAAA,IACR;AAOA,WAAO,CAAC,KAAK,uBAAuB,UAAU,CAAC;AAAA,EAChD;AAAA,EAEA,uBAAuB,YAAgE;AACtF,QAAI,mBAAmB;AACvB,UAAM,iBAAiB,WAAW,CAAC,EAAE;AACrC,UAAM,gBAAgB,WAAW,WAAW,SAAS,CAAC,EAAE;AACxD,UAAM,kBAAkB,IAAI,MAAM,eAAe,iBAAiB,eAAe,aAAa,cAAc,eAAe,cAAc,SAAS;AAClJ,QAAI,oBAAoB,eAAe;AACvC,QAAI,gBAAgB,eAAe;AACnC,UAAM,SAAmB,CAAC;AAE1B,aAAS,IAAI,GAAG,MAAM,WAAW,QAAQ,IAAI,KAAK,KAAK;AACtD,YAAM,YAAY,WAAW,CAAC;AAC9B,YAAM,QAAQ,UAAU;AAExB,yBAAmB,oBAAoB,UAAU;AAGjD,aAAO,KAAK,KAAK,gBAAgB,IAAI,MAAM,mBAAmB,eAAe,MAAM,iBAAiB,MAAM,WAAW,CAAC,CAAC;AAGvH,UAAI,UAAU,KAAK,SAAS,GAAG;AAC9B,eAAO,KAAK,UAAU,IAAI;AAAA,MAC3B;AAEA,0BAAoB,MAAM;AAC1B,sBAAgB,MAAM;AAAA,IACvB;AAEA,UAAM,OAAO,OAAO,KAAK,EAAE;AAC3B,UAAM,CAAC,UAAU,iBAAiB,cAAc,IAAI,SAAS,IAAI;AAEjE,WAAO;AAAA,MACN,WAAW;AAAA,MACX,YAAY,WAAW,CAAC,EAAE;AAAA,MAC1B,OAAO;AAAA,MACP,aAAa,KAAK,YAAY,gBAAgB,iBAAiB,gBAAgB,WAAW;AAAA,MAC1F,aAAa,KAAK,sBAAsB,iBAAiB,oBAAoB,WAAW;AAAA,MACxF;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,sBAAsB;AAAA,IACvB;AAAA,EACD;AAAA,EAEQ,cAAc,YAAsE;AAC3F,eAAW,KAAK,oBAAoB,kBAAkB;AAEtD,UAAM,iBAAgD,CAAC;AAGvD,aAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;AAC3C,YAAM,KAAK,WAAW,CAAC;AAEvB,YAAM,kBAAkB,GAAG,MAAM;AACjC,YAAM,cAAc,GAAG,MAAM;AAC7B,YAAM,gBAAgB,GAAG,MAAM;AAC/B,YAAM,YAAY,GAAG,MAAM;AAE3B,UAAI,oBAAoB,iBAAiB,gBAAgB,aAAa,GAAG,KAAK,WAAW,GAAG;AAE3F;AAAA,MACD;AAEA,UAAI,GAAG,MAAM;AAEZ,aAAK,WAAW,OAAO,GAAG,aAAa,GAAG,WAAW;AACrD,aAAK,WAAW,OAAO,GAAG,aAAa,GAAG,MAAM,IAAI;AAAA,MAErD,OAAO;AAEN,aAAK,WAAW,OAAO,GAAG,aAAa,GAAG,WAAW;AAAA,MACtD;AAEA,YAAM,qBAAqB,IAAI,MAAM,iBAAiB,aAAa,eAAe,SAAS;AAC3F,qBAAe,KAAK;AAAA,QACnB,OAAO;AAAA,QACP,aAAa,GAAG;AAAA,QAChB,MAAM,GAAG;AAAA,QACT,aAAa,GAAG;AAAA,QAChB,kBAAkB,GAAG;AAAA,MACtB,CAAC;AAAA,IACF;AACA,WAAO;AAAA,EACR;AAAA,EAEA,sBAAsB,aAAoB,YAAwB,gBAAyB,kBAAuC;AACjI,WAAO,KAAK,WAAW,sBAAsB,aAAa,YAAY,gBAAgB,gBAAgB;AAAA,EACvG;AAAA;AAAA;AAAA;AAAA,EAMO,eAA8B;AACpC,WAAO,KAAK;AAAA,EACb;AAAA,EAEA,OAAc,qBAAqB,OAAc,MAAc;AAC9D,UAAM,kBAAkB,MAAM;AAC9B,UAAM,cAAc,MAAM;AAC1B,UAAM,CAAC,UAAU,iBAAiB,cAAc,IAAI,SAAS,IAAI;AACjE,QAAI;AAEJ,QAAI,KAAK,SAAS,GAAG;AAEpB,YAAM,YAAY,WAAW;AAE7B,UAAI,cAAc,GAAG;AAEpB,sBAAc,IAAI,MAAM,iBAAiB,aAAa,iBAAiB,cAAc,eAAe;AAAA,MACrG,OAAO;AAEN,sBAAc,IAAI,MAAM,iBAAiB,aAAa,kBAAkB,YAAY,GAAG,iBAAiB,CAAC;AAAA,MAC1G;AAAA,IACD,OAAO;AAEN,oBAAc,IAAI,MAAM,iBAAiB,aAAa,iBAAiB,WAAW;AAAA,IACnF;AAEA,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA,EAKA,OAAc,sBAAsB,YAAgD;AACnF,UAAM,SAAkB,CAAC;AAEzB,QAAI,sBAA8B;AAClC,QAAI,kBAA0B;AAC9B,QAAI,SAAyC;AAC7C,aAAS,IAAI,GAAG,MAAM,WAAW,QAAQ,IAAI,KAAK,KAAK;AACtD,YAAM,KAAK,WAAW,CAAC;AAEvB,UAAI;AACJ,UAAI;AAEJ,UAAI,QAAQ;AACX,YAAI,OAAO,MAAM,kBAAkB,GAAG,MAAM,iBAAiB;AAC5D,4BAAkB;AAClB,wBAAc,mBAAmB,GAAG,MAAM,cAAc,OAAO,MAAM;AAAA,QACtE,OAAO;AACN,4BAAkB,uBAAuB,GAAG,MAAM,kBAAkB,OAAO,MAAM;AACjF,wBAAc,GAAG,MAAM;AAAA,QACxB;AAAA,MACD,OAAO;AACN,0BAAkB,GAAG,MAAM;AAC3B,sBAAc,GAAG,MAAM;AAAA,MACxB;AAEA,UAAI;AAEJ,UAAI,GAAG,KAAK,SAAS,GAAG;AAEvB,cAAM,YAAY,GAAG,WAAW;AAEhC,YAAI,cAAc,GAAG;AAEpB,wBAAc,IAAI,MAAM,iBAAiB,aAAa,iBAAiB,cAAc,GAAG,eAAe;AAAA,QACxG,OAAO;AAEN,wBAAc,IAAI,MAAM,iBAAiB,aAAa,kBAAkB,YAAY,GAAG,GAAG,iBAAiB,CAAC;AAAA,QAC7G;AAAA,MACD,OAAO;AAEN,sBAAc,IAAI,MAAM,iBAAiB,aAAa,iBAAiB,WAAW;AAAA,MACnF;AAEA,4BAAsB,YAAY;AAClC,wBAAkB,YAAY;AAE9B,aAAO,KAAK,WAAW;AACvB,eAAS;AAAA,IACV;AAEA,WAAO;AAAA,EACR;AAAA,EAEA,OAAe,kBAAkB,GAA4B,GAAoC;AAChG,UAAM,IAAI,MAAM,uBAAuB,EAAE,OAAO,EAAE,KAAK;AACvD,QAAI,MAAM,GAAG;AACZ,aAAO,EAAE,YAAY,EAAE;AAAA,IACxB;AACA,WAAO;AAAA,EACR;AAAA,EAEA,OAAe,mBAAmB,GAA4B,GAAoC;AACjG,UAAM,IAAI,MAAM,uBAAuB,EAAE,OAAO,EAAE,KAAK;AACvD,QAAI,MAAM,GAAG;AACZ,aAAO,EAAE,YAAY,EAAE;AAAA,IACxB;AACA,WAAO,CAAC;AAAA,EACT;AAAA;AAED;",
  "names": []
}
