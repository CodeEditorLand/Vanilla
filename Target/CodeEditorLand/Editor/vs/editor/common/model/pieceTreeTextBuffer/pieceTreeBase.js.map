{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../../base/common/charCode.js';\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { FindMatch, ITextSnapshot, SearchData } from '../../model.js';\nimport { NodeColor, SENTINEL, TreeNode, fixInsert, leftest, rbDelete, righttest, updateTreeMetadata } from './rbTreeBase.js';\nimport { Searcher, createFindMatch, isValidMatch } from '../textModelSearch.js';\n\n// const lfRegex = new RegExp(/\\r\\n|\\r|\\n/g);\nconst AverageBufferSize = 65535;\n\nfunction createUintArray(arr: number[]): Uint32Array | Uint16Array {\n\tlet r;\n\tif (arr[arr.length - 1] < 65536) {\n\t\tr = new Uint16Array(arr.length);\n\t} else {\n\t\tr = new Uint32Array(arr.length);\n\t}\n\tr.set(arr, 0);\n\treturn r;\n}\n\nclass LineStarts {\n\tconstructor(\n\t\tpublic readonly lineStarts: Uint32Array | Uint16Array | number[],\n\t\tpublic readonly cr: number,\n\t\tpublic readonly lf: number,\n\t\tpublic readonly crlf: number,\n\t\tpublic readonly isBasicASCII: boolean\n\t) { }\n}\n\nexport function createLineStartsFast(str: string, readonly: boolean = true): Uint32Array | Uint16Array | number[] {\n\tconst r: number[] = [0];\n\tlet rLength = 1;\n\n\tfor (let i = 0, len = str.length; i < len; i++) {\n\t\tconst chr = str.charCodeAt(i);\n\n\t\tif (chr === CharCode.CarriageReturn) {\n\t\t\tif (i + 1 < len && str.charCodeAt(i + 1) === CharCode.LineFeed) {\n\t\t\t\t// \\r\\n... case\n\t\t\t\tr[rLength++] = i + 2;\n\t\t\t\ti++; // skip \\n\n\t\t\t} else {\n\t\t\t\t// \\r... case\n\t\t\t\tr[rLength++] = i + 1;\n\t\t\t}\n\t\t} else if (chr === CharCode.LineFeed) {\n\t\t\tr[rLength++] = i + 1;\n\t\t}\n\t}\n\tif (readonly) {\n\t\treturn createUintArray(r);\n\t} else {\n\t\treturn r;\n\t}\n}\n\nexport function createLineStarts(r: number[], str: string): LineStarts {\n\tr.length = 0;\n\tr[0] = 0;\n\tlet rLength = 1;\n\tlet cr = 0, lf = 0, crlf = 0;\n\tlet isBasicASCII = true;\n\tfor (let i = 0, len = str.length; i < len; i++) {\n\t\tconst chr = str.charCodeAt(i);\n\n\t\tif (chr === CharCode.CarriageReturn) {\n\t\t\tif (i + 1 < len && str.charCodeAt(i + 1) === CharCode.LineFeed) {\n\t\t\t\t// \\r\\n... case\n\t\t\t\tcrlf++;\n\t\t\t\tr[rLength++] = i + 2;\n\t\t\t\ti++; // skip \\n\n\t\t\t} else {\n\t\t\t\tcr++;\n\t\t\t\t// \\r... case\n\t\t\t\tr[rLength++] = i + 1;\n\t\t\t}\n\t\t} else if (chr === CharCode.LineFeed) {\n\t\t\tlf++;\n\t\t\tr[rLength++] = i + 1;\n\t\t} else {\n\t\t\tif (isBasicASCII) {\n\t\t\t\tif (chr !== CharCode.Tab && (chr < 32 || chr > 126)) {\n\t\t\t\t\tisBasicASCII = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tconst result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);\n\tr.length = 0;\n\n\treturn result;\n}\n\ninterface NodePosition {\n\t/**\n\t * Piece Index\n\t */\n\tnode: TreeNode;\n\t/**\n\t * remainder in current piece.\n\t*/\n\tremainder: number;\n\t/**\n\t * node start offset in document.\n\t */\n\tnodeStartOffset: number;\n}\n\ninterface BufferCursor {\n\t/**\n\t * Line number in current buffer\n\t */\n\tline: number;\n\t/**\n\t * Column number in current buffer\n\t */\n\tcolumn: number;\n}\n\nexport class Piece {\n\treadonly bufferIndex: number;\n\treadonly start: BufferCursor;\n\treadonly end: BufferCursor;\n\treadonly length: number;\n\treadonly lineFeedCnt: number;\n\n\tconstructor(bufferIndex: number, start: BufferCursor, end: BufferCursor, lineFeedCnt: number, length: number) {\n\t\tthis.bufferIndex = bufferIndex;\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.lineFeedCnt = lineFeedCnt;\n\t\tthis.length = length;\n\t}\n}\n\nexport class StringBuffer {\n\tbuffer: string;\n\tlineStarts: Uint32Array | Uint16Array | number[];\n\n\tconstructor(buffer: string, lineStarts: Uint32Array | Uint16Array | number[]) {\n\t\tthis.buffer = buffer;\n\t\tthis.lineStarts = lineStarts;\n\t}\n}\n\n/**\n * Readonly snapshot for piece tree.\n * In a real multiple thread environment, to make snapshot reading always work correctly, we need to\n * 1. Make TreeNode.piece immutable, then reading and writing can run in parallel.\n * 2. TreeNode/Buffers normalization should not happen during snapshot reading.\n */\nclass PieceTreeSnapshot implements ITextSnapshot {\n\tprivate readonly _pieces: Piece[];\n\tprivate _index: number;\n\tprivate readonly _tree: PieceTreeBase;\n\tprivate readonly _BOM: string;\n\n\tconstructor(tree: PieceTreeBase, BOM: string) {\n\t\tthis._pieces = [];\n\t\tthis._tree = tree;\n\t\tthis._BOM = BOM;\n\t\tthis._index = 0;\n\t\tif (tree.root !== SENTINEL) {\n\t\t\ttree.iterate(tree.root, node => {\n\t\t\t\tif (node !== SENTINEL) {\n\t\t\t\t\tthis._pieces.push(node.piece);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\t}\n\n\tread(): string | null {\n\t\tif (this._pieces.length === 0) {\n\t\t\tif (this._index === 0) {\n\t\t\t\tthis._index++;\n\t\t\t\treturn this._BOM;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tif (this._index > this._pieces.length - 1) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (this._index === 0) {\n\t\t\treturn this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);\n\t\t}\n\t\treturn this._tree.getPieceContent(this._pieces[this._index++]);\n\t}\n}\n\ninterface CacheEntry {\n\tnode: TreeNode;\n\tnodeStartOffset: number;\n\tnodeStartLineNumber?: number;\n}\n\nclass PieceTreeSearchCache {\n\tprivate readonly _limit: number;\n\tprivate _cache: CacheEntry[];\n\n\tconstructor(limit: number) {\n\t\tthis._limit = limit;\n\t\tthis._cache = [];\n\t}\n\n\tpublic get(offset: number): CacheEntry | null {\n\t\tfor (let i = this._cache.length - 1; i >= 0; i--) {\n\t\t\tconst nodePos = this._cache[i];\n\t\t\tif (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {\n\t\t\t\treturn nodePos;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic get2(lineNumber: number): { node: TreeNode; nodeStartOffset: number; nodeStartLineNumber: number } | null {\n\t\tfor (let i = this._cache.length - 1; i >= 0; i--) {\n\t\t\tconst nodePos = this._cache[i];\n\t\t\tif (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {\n\t\t\t\treturn <{ node: TreeNode; nodeStartOffset: number; nodeStartLineNumber: number }>nodePos;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic set(nodePosition: CacheEntry) {\n\t\tif (this._cache.length >= this._limit) {\n\t\t\tthis._cache.shift();\n\t\t}\n\t\tthis._cache.push(nodePosition);\n\t}\n\n\tpublic validate(offset: number) {\n\t\tlet hasInvalidVal = false;\n\t\tconst tmp: Array<CacheEntry | null> = this._cache;\n\t\tfor (let i = 0; i < tmp.length; i++) {\n\t\t\tconst nodePos = tmp[i]!;\n\t\t\tif (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {\n\t\t\t\ttmp[i] = null;\n\t\t\t\thasInvalidVal = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (hasInvalidVal) {\n\t\t\tconst newArr: CacheEntry[] = [];\n\t\t\tfor (const entry of tmp) {\n\t\t\t\tif (entry !== null) {\n\t\t\t\t\tnewArr.push(entry);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._cache = newArr;\n\t\t}\n\t}\n}\n\nexport class PieceTreeBase {\n\troot!: TreeNode;\n\tprotected _buffers!: StringBuffer[]; // 0 is change buffer, others are readonly original buffer.\n\tprotected _lineCnt!: number;\n\tprotected _length!: number;\n\tprotected _EOL!: '\\r\\n' | '\\n';\n\tprotected _EOLLength!: number;\n\tprotected _EOLNormalized!: boolean;\n\tprivate _lastChangeBufferPos!: BufferCursor;\n\tprivate _searchCache!: PieceTreeSearchCache;\n\tprivate _lastVisitedLine!: { lineNumber: number; value: string };\n\n\tconstructor(chunks: StringBuffer[], eol: '\\r\\n' | '\\n', eolNormalized: boolean) {\n\t\tthis.create(chunks, eol, eolNormalized);\n\t}\n\n\tcreate(chunks: StringBuffer[], eol: '\\r\\n' | '\\n', eolNormalized: boolean) {\n\t\tthis._buffers = [\n\t\t\tnew StringBuffer('', [0])\n\t\t];\n\t\tthis._lastChangeBufferPos = { line: 0, column: 0 };\n\t\tthis.root = SENTINEL;\n\t\tthis._lineCnt = 1;\n\t\tthis._length = 0;\n\t\tthis._EOL = eol;\n\t\tthis._EOLLength = eol.length;\n\t\tthis._EOLNormalized = eolNormalized;\n\n\t\tlet lastNode: TreeNode | null = null;\n\t\tfor (let i = 0, len = chunks.length; i < len; i++) {\n\t\t\tif (chunks[i].buffer.length > 0) {\n\t\t\t\tif (!chunks[i].lineStarts) {\n\t\t\t\t\tchunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);\n\t\t\t\t}\n\n\t\t\t\tconst piece = new Piece(\n\t\t\t\t\ti + 1,\n\t\t\t\t\t{ line: 0, column: 0 },\n\t\t\t\t\t{ line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1] },\n\t\t\t\t\tchunks[i].lineStarts.length - 1,\n\t\t\t\t\tchunks[i].buffer.length\n\t\t\t\t);\n\t\t\t\tthis._buffers.push(chunks[i]);\n\t\t\t\tlastNode = this.rbInsertRight(lastNode, piece);\n\t\t\t}\n\t\t}\n\n\t\tthis._searchCache = new PieceTreeSearchCache(1);\n\t\tthis._lastVisitedLine = { lineNumber: 0, value: '' };\n\t\tthis.computeBufferMetadata();\n\t}\n\n\tnormalizeEOL(eol: '\\r\\n' | '\\n') {\n\t\tconst averageBufferSize = AverageBufferSize;\n\t\tconst min = averageBufferSize - Math.floor(averageBufferSize / 3);\n\t\tconst max = min * 2;\n\n\t\tlet tempChunk = '';\n\t\tlet tempChunkLen = 0;\n\t\tconst chunks: StringBuffer[] = [];\n\n\t\tthis.iterate(this.root, node => {\n\t\t\tconst str = this.getNodeContent(node);\n\t\t\tconst len = str.length;\n\t\t\tif (tempChunkLen <= min || tempChunkLen + len < max) {\n\t\t\t\ttempChunk += str;\n\t\t\t\ttempChunkLen += len;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// flush anyways\n\t\t\tconst text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n\t\t\tchunks.push(new StringBuffer(text, createLineStartsFast(text)));\n\t\t\ttempChunk = str;\n\t\t\ttempChunkLen = len;\n\t\t\treturn true;\n\t\t});\n\n\t\tif (tempChunkLen > 0) {\n\t\t\tconst text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n\t\t\tchunks.push(new StringBuffer(text, createLineStartsFast(text)));\n\t\t}\n\n\t\tthis.create(chunks, eol, true);\n\t}\n\n\t// #region Buffer API\n\tpublic getEOL(): '\\r\\n' | '\\n' {\n\t\treturn this._EOL;\n\t}\n\n\tpublic setEOL(newEOL: '\\r\\n' | '\\n'): void {\n\t\tthis._EOL = newEOL;\n\t\tthis._EOLLength = this._EOL.length;\n\t\tthis.normalizeEOL(newEOL);\n\t}\n\n\tpublic createSnapshot(BOM: string): ITextSnapshot {\n\t\treturn new PieceTreeSnapshot(this, BOM);\n\t}\n\n\tpublic equal(other: PieceTreeBase): boolean {\n\t\tif (this.getLength() !== other.getLength()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.getLineCount() !== other.getLineCount()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlet offset = 0;\n\t\tconst ret = this.iterate(this.root, node => {\n\t\t\tif (node === SENTINEL) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tconst str = this.getNodeContent(node);\n\t\t\tconst len = str.length;\n\t\t\tconst startPosition = other.nodeAt(offset);\n\t\t\tconst endPosition = other.nodeAt(offset + len);\n\t\t\tconst val = other.getValueInRange2(startPosition, endPosition);\n\n\t\t\toffset += len;\n\t\t\treturn str === val;\n\t\t});\n\n\t\treturn ret;\n\t}\n\n\tpublic getOffsetAt(lineNumber: number, column: number): number {\n\t\tlet leftLen = 0; // inorder\n\n\t\tlet x = this.root;\n\n\t\twhile (x !== SENTINEL) {\n\t\t\tif (x.left !== SENTINEL && x.lf_left + 1 >= lineNumber) {\n\t\t\t\tx = x.left;\n\t\t\t} else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {\n\t\t\t\tleftLen += x.size_left;\n\t\t\t\t// lineNumber >= 2\n\t\t\t\tconst accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n\t\t\t\treturn leftLen += accumualtedValInCurrentIndex + column - 1;\n\t\t\t} else {\n\t\t\t\tlineNumber -= x.lf_left + x.piece.lineFeedCnt;\n\t\t\t\tleftLen += x.size_left + x.piece.length;\n\t\t\t\tx = x.right;\n\t\t\t}\n\t\t}\n\n\t\treturn leftLen;\n\t}\n\n\tpublic getPositionAt(offset: number): Position {\n\t\toffset = Math.floor(offset);\n\t\toffset = Math.max(0, offset);\n\n\t\tlet x = this.root;\n\t\tlet lfCnt = 0;\n\t\tconst originalOffset = offset;\n\n\t\twhile (x !== SENTINEL) {\n\t\t\tif (x.size_left !== 0 && x.size_left >= offset) {\n\t\t\t\tx = x.left;\n\t\t\t} else if (x.size_left + x.piece.length >= offset) {\n\t\t\t\tconst out = this.getIndexOf(x, offset - x.size_left);\n\n\t\t\t\tlfCnt += x.lf_left + out.index;\n\n\t\t\t\tif (out.index === 0) {\n\t\t\t\t\tconst lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n\t\t\t\t\tconst column = originalOffset - lineStartOffset;\n\t\t\t\t\treturn new Position(lfCnt + 1, column + 1);\n\t\t\t\t}\n\n\t\t\t\treturn new Position(lfCnt + 1, out.remainder + 1);\n\t\t\t} else {\n\t\t\t\toffset -= x.size_left + x.piece.length;\n\t\t\t\tlfCnt += x.lf_left + x.piece.lineFeedCnt;\n\n\t\t\t\tif (x.right === SENTINEL) {\n\t\t\t\t\t// last node\n\t\t\t\t\tconst lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n\t\t\t\t\tconst column = originalOffset - offset - lineStartOffset;\n\t\t\t\t\treturn new Position(lfCnt + 1, column + 1);\n\t\t\t\t} else {\n\t\t\t\t\tx = x.right;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Position(1, 1);\n\t}\n\n\tpublic getValueInRange(range: Range, eol?: string): string {\n\t\tif (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);\n\t\tconst endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);\n\n\t\tconst value = this.getValueInRange2(startPosition, endPosition);\n\t\tif (eol) {\n\t\t\tif (eol !== this._EOL || !this._EOLNormalized) {\n\t\t\t\treturn value.replace(/\\r\\n|\\r|\\n/g, eol);\n\t\t\t}\n\n\t\t\tif (eol === this.getEOL() && this._EOLNormalized) {\n\t\t\t\tif (eol === '\\r\\n') {\n\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\treturn value.replace(/\\r\\n|\\r|\\n/g, eol);\n\t\t}\n\t\treturn value;\n\t}\n\n\tpublic getValueInRange2(startPosition: NodePosition, endPosition: NodePosition): string {\n\t\tif (startPosition.node === endPosition.node) {\n\t\t\tconst node = startPosition.node;\n\t\t\tconst buffer = this._buffers[node.piece.bufferIndex].buffer;\n\t\t\tconst startOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n\t\t\treturn buffer.substring(startOffset + startPosition.remainder, startOffset + endPosition.remainder);\n\t\t}\n\n\t\tlet x = startPosition.node;\n\t\tconst buffer = this._buffers[x.piece.bufferIndex].buffer;\n\t\tconst startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\t\tlet ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);\n\n\t\tx = x.next();\n\t\twhile (x !== SENTINEL) {\n\t\t\tconst buffer = this._buffers[x.piece.bufferIndex].buffer;\n\t\t\tconst startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\n\t\t\tif (x === endPosition.node) {\n\t\t\t\tret += buffer.substring(startOffset, startOffset + endPosition.remainder);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tret += buffer.substr(startOffset, x.piece.length);\n\t\t\t}\n\n\t\t\tx = x.next();\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tpublic getLinesContent(): string[] {\n\t\tconst lines: string[] = [];\n\t\tlet linesLength = 0;\n\t\tlet currentLine = '';\n\t\tlet danglingCR = false;\n\n\t\tthis.iterate(this.root, node => {\n\t\t\tif (node === SENTINEL) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tconst piece = node.piece;\n\t\t\tlet pieceLength = piece.length;\n\t\t\tif (pieceLength === 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tconst buffer = this._buffers[piece.bufferIndex].buffer;\n\t\t\tconst lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n\n\t\t\tconst pieceStartLine = piece.start.line;\n\t\t\tconst pieceEndLine = piece.end.line;\n\t\t\tlet pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;\n\n\t\t\tif (danglingCR) {\n\t\t\t\tif (buffer.charCodeAt(pieceStartOffset) === CharCode.LineFeed) {\n\t\t\t\t\t// pretend the \\n was in the previous piece..\n\t\t\t\t\tpieceStartOffset++;\n\t\t\t\t\tpieceLength--;\n\t\t\t\t}\n\t\t\t\tlines[linesLength++] = currentLine;\n\t\t\t\tcurrentLine = '';\n\t\t\t\tdanglingCR = false;\n\t\t\t\tif (pieceLength === 0) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (pieceStartLine === pieceEndLine) {\n\t\t\t\t// this piece has no new lines\n\t\t\t\tif (!this._EOLNormalized && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === CharCode.CarriageReturn) {\n\t\t\t\t\tdanglingCR = true;\n\t\t\t\t\tcurrentLine += buffer.substr(pieceStartOffset, pieceLength - 1);\n\t\t\t\t} else {\n\t\t\t\t\tcurrentLine += buffer.substr(pieceStartOffset, pieceLength);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// add the text before the first line start in this piece\n\t\t\tcurrentLine += (\n\t\t\t\tthis._EOLNormalized\n\t\t\t\t\t? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - this._EOLLength))\n\t\t\t\t\t: buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\\r\\n|\\r|\\n)$/, '')\n\t\t\t);\n\t\t\tlines[linesLength++] = currentLine;\n\n\t\t\tfor (let line = pieceStartLine + 1; line < pieceEndLine; line++) {\n\t\t\t\tcurrentLine = (\n\t\t\t\t\tthis._EOLNormalized\n\t\t\t\t\t\t? buffer.substring(lineStarts[line], lineStarts[line + 1] - this._EOLLength)\n\t\t\t\t\t\t: buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\\r\\n|\\r|\\n)$/, '')\n\t\t\t\t);\n\t\t\t\tlines[linesLength++] = currentLine;\n\t\t\t}\n\n\t\t\tif (!this._EOLNormalized && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === CharCode.CarriageReturn) {\n\t\t\t\tdanglingCR = true;\n\t\t\t\tif (piece.end.column === 0) {\n\t\t\t\t\t// The last line ended with a \\r, let's undo the push, it will be pushed by next iteration\n\t\t\t\t\tlinesLength--;\n\t\t\t\t} else {\n\t\t\t\t\tcurrentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcurrentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t});\n\n\t\tif (danglingCR) {\n\t\t\tlines[linesLength++] = currentLine;\n\t\t\tcurrentLine = '';\n\t\t}\n\n\t\tlines[linesLength++] = currentLine;\n\t\treturn lines;\n\t}\n\n\tpublic getLength(): number {\n\t\treturn this._length;\n\t}\n\n\tpublic getLineCount(): number {\n\t\treturn this._lineCnt;\n\t}\n\n\tpublic getLineContent(lineNumber: number): string {\n\t\tif (this._lastVisitedLine.lineNumber === lineNumber) {\n\t\t\treturn this._lastVisitedLine.value;\n\t\t}\n\n\t\tthis._lastVisitedLine.lineNumber = lineNumber;\n\n\t\tif (lineNumber === this._lineCnt) {\n\t\t\tthis._lastVisitedLine.value = this.getLineRawContent(lineNumber);\n\t\t} else if (this._EOLNormalized) {\n\t\t\tthis._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);\n\t\t} else {\n\t\t\tthis._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\\r\\n|\\r|\\n)$/, '');\n\t\t}\n\n\t\treturn this._lastVisitedLine.value;\n\t}\n\n\tprivate _getCharCode(nodePos: NodePosition): number {\n\t\tif (nodePos.remainder === nodePos.node.piece.length) {\n\t\t\t// the char we want to fetch is at the head of next node.\n\t\t\tconst matchingNode = nodePos.node.next();\n\t\t\tif (!matchingNode) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tconst buffer = this._buffers[matchingNode.piece.bufferIndex];\n\t\t\tconst startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n\t\t\treturn buffer.buffer.charCodeAt(startOffset);\n\t\t} else {\n\t\t\tconst buffer = this._buffers[nodePos.node.piece.bufferIndex];\n\t\t\tconst startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n\t\t\tconst targetOffset = startOffset + nodePos.remainder;\n\n\t\t\treturn buffer.buffer.charCodeAt(targetOffset);\n\t\t}\n\t}\n\n\tpublic getLineCharCode(lineNumber: number, index: number): number {\n\t\tconst nodePos = this.nodeAt2(lineNumber, index + 1);\n\t\treturn this._getCharCode(nodePos);\n\t}\n\n\tpublic getLineLength(lineNumber: number): number {\n\t\tif (lineNumber === this.getLineCount()) {\n\t\t\tconst startOffset = this.getOffsetAt(lineNumber, 1);\n\t\t\treturn this.getLength() - startOffset;\n\t\t}\n\t\treturn this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;\n\t}\n\n\tpublic getCharCode(offset: number): number {\n\t\tconst nodePos = this.nodeAt(offset);\n\t\treturn this._getCharCode(nodePos);\n\t}\n\n\tpublic getNearestChunk(offset: number): string {\n\t\tconst nodePos = this.nodeAt(offset);\n\t\tif (nodePos.remainder === nodePos.node.piece.length) {\n\t\t\t// the offset is at the head of next node.\n\t\t\tconst matchingNode = nodePos.node.next();\n\t\t\tif (!matchingNode || matchingNode === SENTINEL) {\n\t\t\t\treturn '';\n\t\t\t}\n\n\t\t\tconst buffer = this._buffers[matchingNode.piece.bufferIndex];\n\t\t\tconst startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n\t\t\treturn buffer.buffer.substring(startOffset, startOffset + matchingNode.piece.length);\n\t\t} else {\n\t\t\tconst buffer = this._buffers[nodePos.node.piece.bufferIndex];\n\t\t\tconst startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n\t\t\tconst targetOffset = startOffset + nodePos.remainder;\n\t\t\tconst targetEnd = startOffset + nodePos.node.piece.length;\n\t\t\treturn buffer.buffer.substring(targetOffset, targetEnd);\n\t\t}\n\t}\n\n\tpublic findMatchesInNode(node: TreeNode, searcher: Searcher, startLineNumber: number, startColumn: number, startCursor: BufferCursor, endCursor: BufferCursor, searchData: SearchData, captureMatches: boolean, limitResultCount: number, resultLen: number, result: FindMatch[]) {\n\t\tconst buffer = this._buffers[node.piece.bufferIndex];\n\t\tconst startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n\t\tconst start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);\n\t\tconst end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);\n\n\t\tlet m: RegExpExecArray | null;\n\t\t// Reset regex to search from the beginning\n\t\tconst ret: BufferCursor = { line: 0, column: 0 };\n\t\tlet searchText: string;\n\t\tlet offsetInBuffer: (offset: number) => number;\n\n\t\tif (searcher._wordSeparators) {\n\t\t\tsearchText = buffer.buffer.substring(start, end);\n\t\t\toffsetInBuffer = (offset: number) => offset + start;\n\t\t\tsearcher.reset(0);\n\t\t} else {\n\t\t\tsearchText = buffer.buffer;\n\t\t\toffsetInBuffer = (offset: number) => offset;\n\t\t\tsearcher.reset(start);\n\t\t}\n\n\t\tdo {\n\t\t\tm = searcher.next(searchText);\n\n\t\t\tif (m) {\n\t\t\t\tif (offsetInBuffer(m.index) >= end) {\n\t\t\t\t\treturn resultLen;\n\t\t\t\t}\n\t\t\t\tthis.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);\n\t\t\t\tconst lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);\n\t\t\t\tconst retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;\n\t\t\t\tconst retEndColumn = retStartColumn + m[0].length;\n\t\t\t\tresult[resultLen++] = createFindMatch(new Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);\n\n\t\t\t\tif (offsetInBuffer(m.index) + m[0].length >= end) {\n\t\t\t\t\treturn resultLen;\n\t\t\t\t}\n\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\treturn resultLen;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} while (m);\n\n\t\treturn resultLen;\n\t}\n\n\tpublic findMatchesLineByLine(searchRange: Range, searchData: SearchData, captureMatches: boolean, limitResultCount: number): FindMatch[] {\n\t\tconst result: FindMatch[] = [];\n\t\tlet resultLen = 0;\n\t\tconst searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n\n\t\tlet startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);\n\t\tif (startPosition === null) {\n\t\t\treturn [];\n\t\t}\n\t\tconst endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);\n\t\tif (endPosition === null) {\n\t\t\treturn [];\n\t\t}\n\t\tlet start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n\t\tconst end = this.positionInBuffer(endPosition.node, endPosition.remainder);\n\n\t\tif (startPosition.node === endPosition.node) {\n\t\t\tthis.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n\t\t\treturn result;\n\t\t}\n\n\t\tlet startLineNumber = searchRange.startLineNumber;\n\n\t\tlet currentNode = startPosition.node;\n\t\twhile (currentNode !== endPosition.node) {\n\t\t\tconst lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);\n\n\t\t\tif (lineBreakCnt >= 1) {\n\t\t\t\t// last line break position\n\t\t\t\tconst lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;\n\t\t\t\tconst startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);\n\t\t\t\tconst nextLineStartOffset = lineStarts[start.line + lineBreakCnt];\n\t\t\t\tconst startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n\t\t\t\tresultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);\n\n\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tstartLineNumber += lineBreakCnt;\n\t\t\t}\n\n\t\t\tconst startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n\t\t\t// search for the remaining content\n\t\t\tif (startLineNumber === searchRange.endLineNumber) {\n\t\t\t\tconst text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n\t\t\t\tresultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tresultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn), startLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n\n\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tstartLineNumber++;\n\t\t\tstartPosition = this.nodeAt2(startLineNumber, 1);\n\t\t\tcurrentNode = startPosition.node;\n\t\t\tstart = this.positionInBuffer(startPosition.node, startPosition.remainder);\n\t\t}\n\n\t\tif (startLineNumber === searchRange.endLineNumber) {\n\t\t\tconst startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n\t\t\tconst text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n\t\t\tresultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n\t\t\treturn result;\n\t\t}\n\n\t\tconst startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n\t\tresultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n\t\treturn result;\n\t}\n\n\tprivate _findMatchesInLine(searchData: SearchData, searcher: Searcher, text: string, lineNumber: number, deltaOffset: number, resultLen: number, result: FindMatch[], captureMatches: boolean, limitResultCount: number): number {\n\t\tconst wordSeparators = searchData.wordSeparators;\n\t\tif (!captureMatches && searchData.simpleSearch) {\n\t\t\tconst searchString = searchData.simpleSearch;\n\t\t\tconst searchStringLen = searchString.length;\n\t\t\tconst textLength = text.length;\n\n\t\t\tlet lastMatchIndex = -searchStringLen;\n\t\t\twhile ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n\t\t\t\tif (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n\t\t\t\t\tresult[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n\t\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\t\treturn resultLen;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn resultLen;\n\t\t}\n\n\t\tlet m: RegExpExecArray | null;\n\t\t// Reset regex to search from the beginning\n\t\tsearcher.reset(0);\n\t\tdo {\n\t\t\tm = searcher.next(text);\n\t\t\tif (m) {\n\t\t\t\tresult[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\treturn resultLen;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (m);\n\t\treturn resultLen;\n\t}\n\n\t// #endregion\n\n\t// #region Piece Table\n\tpublic insert(offset: number, value: string, eolNormalized: boolean = false): void {\n\t\tthis._EOLNormalized = this._EOLNormalized && eolNormalized;\n\t\tthis._lastVisitedLine.lineNumber = 0;\n\t\tthis._lastVisitedLine.value = '';\n\n\t\tif (this.root !== SENTINEL) {\n\t\t\tconst { node, remainder, nodeStartOffset } = this.nodeAt(offset);\n\t\t\tconst piece = node.piece;\n\t\t\tconst bufferIndex = piece.bufferIndex;\n\t\t\tconst insertPosInBuffer = this.positionInBuffer(node, remainder);\n\t\t\tif (node.piece.bufferIndex === 0 &&\n\t\t\t\tpiece.end.line === this._lastChangeBufferPos.line &&\n\t\t\t\tpiece.end.column === this._lastChangeBufferPos.column &&\n\t\t\t\t(nodeStartOffset + piece.length === offset) &&\n\t\t\t\tvalue.length < AverageBufferSize\n\t\t\t) {\n\t\t\t\t// changed buffer\n\t\t\t\tthis.appendToNode(node, value);\n\t\t\t\tthis.computeBufferMetadata();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (nodeStartOffset === offset) {\n\t\t\t\tthis.insertContentToNodeLeft(value, node);\n\t\t\t\tthis._searchCache.validate(offset);\n\t\t\t} else if (nodeStartOffset + node.piece.length > offset) {\n\t\t\t\t// we are inserting into the middle of a node.\n\t\t\t\tconst nodesToDel: TreeNode[] = [];\n\t\t\t\tlet newRightPiece = new Piece(\n\t\t\t\t\tpiece.bufferIndex,\n\t\t\t\t\tinsertPosInBuffer,\n\t\t\t\t\tpiece.end,\n\t\t\t\t\tthis.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end),\n\t\t\t\t\tthis.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer)\n\t\t\t\t);\n\n\t\t\t\tif (this.shouldCheckCRLF() && this.endWithCR(value)) {\n\t\t\t\t\tconst headOfRight = this.nodeCharCodeAt(node, remainder);\n\n\t\t\t\t\tif (headOfRight === 10 /** \\n */) {\n\t\t\t\t\t\tconst newStart: BufferCursor = { line: newRightPiece.start.line + 1, column: 0 };\n\t\t\t\t\t\tnewRightPiece = new Piece(\n\t\t\t\t\t\t\tnewRightPiece.bufferIndex,\n\t\t\t\t\t\t\tnewStart,\n\t\t\t\t\t\t\tnewRightPiece.end,\n\t\t\t\t\t\t\tthis.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end),\n\t\t\t\t\t\t\tnewRightPiece.length - 1\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tvalue += '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// reuse node for content before insertion point.\n\t\t\t\tif (this.shouldCheckCRLF() && this.startWithLF(value)) {\n\t\t\t\t\tconst tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);\n\t\t\t\t\tif (tailOfLeft === 13 /** \\r */) {\n\t\t\t\t\t\tconst previousPos = this.positionInBuffer(node, remainder - 1);\n\t\t\t\t\t\tthis.deleteNodeTail(node, previousPos);\n\t\t\t\t\t\tvalue = '\\r' + value;\n\n\t\t\t\t\t\tif (node.piece.length === 0) {\n\t\t\t\t\t\t\tnodesToDel.push(node);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.deleteNodeTail(node, insertPosInBuffer);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.deleteNodeTail(node, insertPosInBuffer);\n\t\t\t\t}\n\n\t\t\t\tconst newPieces = this.createNewPieces(value);\n\t\t\t\tif (newRightPiece.length > 0) {\n\t\t\t\t\tthis.rbInsertRight(node, newRightPiece);\n\t\t\t\t}\n\n\t\t\t\tlet tmpNode = node;\n\t\t\t\tfor (let k = 0; k < newPieces.length; k++) {\n\t\t\t\t\ttmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n\t\t\t\t}\n\t\t\t\tthis.deleteNodes(nodesToDel);\n\t\t\t} else {\n\t\t\t\tthis.insertContentToNodeRight(value, node);\n\t\t\t}\n\t\t} else {\n\t\t\t// insert new node\n\t\t\tconst pieces = this.createNewPieces(value);\n\t\t\tlet node = this.rbInsertLeft(null, pieces[0]);\n\n\t\t\tfor (let k = 1; k < pieces.length; k++) {\n\t\t\t\tnode = this.rbInsertRight(node, pieces[k]);\n\t\t\t}\n\t\t}\n\n\t\t// todo, this is too brutal. Total line feed count should be updated the same way as lf_left.\n\t\tthis.computeBufferMetadata();\n\t}\n\n\tpublic delete(offset: number, cnt: number): void {\n\t\tthis._lastVisitedLine.lineNumber = 0;\n\t\tthis._lastVisitedLine.value = '';\n\n\t\tif (cnt <= 0 || this.root === SENTINEL) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst startPosition = this.nodeAt(offset);\n\t\tconst endPosition = this.nodeAt(offset + cnt);\n\t\tconst startNode = startPosition.node;\n\t\tconst endNode = endPosition.node;\n\n\t\tif (startNode === endNode) {\n\t\t\tconst startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n\t\t\tconst endSplitPosInBuffer = this.positionInBuffer(startNode, endPosition.remainder);\n\n\t\t\tif (startPosition.nodeStartOffset === offset) {\n\t\t\t\tif (cnt === startNode.piece.length) { // delete node\n\t\t\t\t\tconst next = startNode.next();\n\t\t\t\t\trbDelete(this, startNode);\n\t\t\t\t\tthis.validateCRLFWithPrevNode(next);\n\t\t\t\t\tthis.computeBufferMetadata();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.deleteNodeHead(startNode, endSplitPosInBuffer);\n\t\t\t\tthis._searchCache.validate(offset);\n\t\t\t\tthis.validateCRLFWithPrevNode(startNode);\n\t\t\t\tthis.computeBufferMetadata();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {\n\t\t\t\tthis.deleteNodeTail(startNode, startSplitPosInBuffer);\n\t\t\t\tthis.validateCRLFWithNextNode(startNode);\n\t\t\t\tthis.computeBufferMetadata();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// delete content in the middle, this node will be splitted to nodes\n\t\t\tthis.shrinkNode(startNode, startSplitPosInBuffer, endSplitPosInBuffer);\n\t\t\tthis.computeBufferMetadata();\n\t\t\treturn;\n\t\t}\n\n\t\tconst nodesToDel: TreeNode[] = [];\n\n\t\tconst startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n\t\tthis.deleteNodeTail(startNode, startSplitPosInBuffer);\n\t\tthis._searchCache.validate(offset);\n\t\tif (startNode.piece.length === 0) {\n\t\t\tnodesToDel.push(startNode);\n\t\t}\n\n\t\t// update last touched node\n\t\tconst endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);\n\t\tthis.deleteNodeHead(endNode, endSplitPosInBuffer);\n\t\tif (endNode.piece.length === 0) {\n\t\t\tnodesToDel.push(endNode);\n\t\t}\n\n\t\t// delete nodes in between\n\t\tconst secondNode = startNode.next();\n\t\tfor (let node = secondNode; node !== SENTINEL && node !== endNode; node = node.next()) {\n\t\t\tnodesToDel.push(node);\n\t\t}\n\n\t\tconst prev = startNode.piece.length === 0 ? startNode.prev() : startNode;\n\t\tthis.deleteNodes(nodesToDel);\n\t\tthis.validateCRLFWithNextNode(prev);\n\t\tthis.computeBufferMetadata();\n\t}\n\n\tprivate insertContentToNodeLeft(value: string, node: TreeNode) {\n\t\t// we are inserting content to the beginning of node\n\t\tconst nodesToDel: TreeNode[] = [];\n\t\tif (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {\n\t\t\t// move `\\n` to new node.\n\n\t\t\tconst piece = node.piece;\n\t\t\tconst newStart: BufferCursor = { line: piece.start.line + 1, column: 0 };\n\t\t\tconst nPiece = new Piece(\n\t\t\t\tpiece.bufferIndex,\n\t\t\t\tnewStart,\n\t\t\t\tpiece.end,\n\t\t\t\tthis.getLineFeedCnt(piece.bufferIndex, newStart, piece.end),\n\t\t\t\tpiece.length - 1\n\t\t\t);\n\n\t\t\tnode.piece = nPiece;\n\n\t\t\tvalue += '\\n';\n\t\t\tupdateTreeMetadata(this, node, -1, -1);\n\n\t\t\tif (node.piece.length === 0) {\n\t\t\t\tnodesToDel.push(node);\n\t\t\t}\n\t\t}\n\n\t\tconst newPieces = this.createNewPieces(value);\n\t\tlet newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);\n\t\tfor (let k = newPieces.length - 2; k >= 0; k--) {\n\t\t\tnewNode = this.rbInsertLeft(newNode, newPieces[k]);\n\t\t}\n\t\tthis.validateCRLFWithPrevNode(newNode);\n\t\tthis.deleteNodes(nodesToDel);\n\t}\n\n\tprivate insertContentToNodeRight(value: string, node: TreeNode) {\n\t\t// we are inserting to the right of this node.\n\t\tif (this.adjustCarriageReturnFromNext(value, node)) {\n\t\t\t// move \\n to the new node.\n\t\t\tvalue += '\\n';\n\t\t}\n\n\t\tconst newPieces = this.createNewPieces(value);\n\t\tconst newNode = this.rbInsertRight(node, newPieces[0]);\n\t\tlet tmpNode = newNode;\n\n\t\tfor (let k = 1; k < newPieces.length; k++) {\n\t\t\ttmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n\t\t}\n\n\t\tthis.validateCRLFWithPrevNode(newNode);\n\t}\n\n\tprivate positionInBuffer(node: TreeNode, remainder: number): BufferCursor;\n\tprivate positionInBuffer(node: TreeNode, remainder: number, ret: BufferCursor): null;\n\tprivate positionInBuffer(node: TreeNode, remainder: number, ret?: BufferCursor): BufferCursor | null {\n\t\tconst piece = node.piece;\n\t\tconst bufferIndex = node.piece.bufferIndex;\n\t\tconst lineStarts = this._buffers[bufferIndex].lineStarts;\n\n\t\tconst startOffset = lineStarts[piece.start.line] + piece.start.column;\n\n\t\tconst offset = startOffset + remainder;\n\n\t\t// binary search offset between startOffset and endOffset\n\t\tlet low = piece.start.line;\n\t\tlet high = piece.end.line;\n\n\t\tlet mid: number = 0;\n\t\tlet midStop: number = 0;\n\t\tlet midStart: number = 0;\n\n\t\twhile (low <= high) {\n\t\t\tmid = low + ((high - low) / 2) | 0;\n\t\t\tmidStart = lineStarts[mid];\n\n\t\t\tif (mid === high) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmidStop = lineStarts[mid + 1];\n\n\t\t\tif (offset < midStart) {\n\t\t\t\thigh = mid - 1;\n\t\t\t} else if (offset >= midStop) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ret) {\n\t\t\tret.line = mid;\n\t\t\tret.column = offset - midStart;\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\tline: mid,\n\t\t\tcolumn: offset - midStart\n\t\t};\n\t}\n\n\tprivate getLineFeedCnt(bufferIndex: number, start: BufferCursor, end: BufferCursor): number {\n\t\t// we don't need to worry about start: abc\\r|\\n, or abc|\\r, or abc|\\n, or abc|\\r\\n doesn't change the fact that, there is one line break after start.\n\t\t// now let's take care of end: abc\\r|\\n, if end is in between \\r and \\n, we need to add line feed count by 1\n\t\tif (end.column === 0) {\n\t\t\treturn end.line - start.line;\n\t\t}\n\n\t\tconst lineStarts = this._buffers[bufferIndex].lineStarts;\n\t\tif (end.line === lineStarts.length - 1) { // it means, there is no \\n after end, otherwise, there will be one more lineStart.\n\t\t\treturn end.line - start.line;\n\t\t}\n\n\t\tconst nextLineStartOffset = lineStarts[end.line + 1];\n\t\tconst endOffset = lineStarts[end.line] + end.column;\n\t\tif (nextLineStartOffset > endOffset + 1) { // there are more than 1 character after end, which means it can't be \\n\n\t\t\treturn end.line - start.line;\n\t\t}\n\t\t// endOffset + 1 === nextLineStartOffset\n\t\t// character at endOffset is \\n, so we check the character before first\n\t\t// if character at endOffset is \\r, end.column is 0 and we can't get here.\n\t\tconst previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.\n\t\tconst buffer = this._buffers[bufferIndex].buffer;\n\n\t\tif (buffer.charCodeAt(previousCharOffset) === 13) {\n\t\t\treturn end.line - start.line + 1;\n\t\t} else {\n\t\t\treturn end.line - start.line;\n\t\t}\n\t}\n\n\tprivate offsetInBuffer(bufferIndex: number, cursor: BufferCursor): number {\n\t\tconst lineStarts = this._buffers[bufferIndex].lineStarts;\n\t\treturn lineStarts[cursor.line] + cursor.column;\n\t}\n\n\tprivate deleteNodes(nodes: TreeNode[]): void {\n\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\trbDelete(this, nodes[i]);\n\t\t}\n\t}\n\n\tprivate createNewPieces(text: string): Piece[] {\n\t\tif (text.length > AverageBufferSize) {\n\t\t\t// the content is large, operations like substring, charCode becomes slow\n\t\t\t// so here we split it into smaller chunks, just like what we did for CR/LF normalization\n\t\t\tconst newPieces: Piece[] = [];\n\t\t\twhile (text.length > AverageBufferSize) {\n\t\t\t\tconst lastChar = text.charCodeAt(AverageBufferSize - 1);\n\t\t\t\tlet splitText;\n\t\t\t\tif (lastChar === CharCode.CarriageReturn || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n\t\t\t\t\t// last character is \\r or a high surrogate => keep it back\n\t\t\t\t\tsplitText = text.substring(0, AverageBufferSize - 1);\n\t\t\t\t\ttext = text.substring(AverageBufferSize - 1);\n\t\t\t\t} else {\n\t\t\t\t\tsplitText = text.substring(0, AverageBufferSize);\n\t\t\t\t\ttext = text.substring(AverageBufferSize);\n\t\t\t\t}\n\n\t\t\t\tconst lineStarts = createLineStartsFast(splitText);\n\t\t\t\tnewPieces.push(new Piece(\n\t\t\t\t\tthis._buffers.length, /* buffer index */\n\t\t\t\t\t{ line: 0, column: 0 },\n\t\t\t\t\t{ line: lineStarts.length - 1, column: splitText.length - lineStarts[lineStarts.length - 1] },\n\t\t\t\t\tlineStarts.length - 1,\n\t\t\t\t\tsplitText.length\n\t\t\t\t));\n\t\t\t\tthis._buffers.push(new StringBuffer(splitText, lineStarts));\n\t\t\t}\n\n\t\t\tconst lineStarts = createLineStartsFast(text);\n\t\t\tnewPieces.push(new Piece(\n\t\t\t\tthis._buffers.length, /* buffer index */\n\t\t\t\t{ line: 0, column: 0 },\n\t\t\t\t{ line: lineStarts.length - 1, column: text.length - lineStarts[lineStarts.length - 1] },\n\t\t\t\tlineStarts.length - 1,\n\t\t\t\ttext.length\n\t\t\t));\n\t\t\tthis._buffers.push(new StringBuffer(text, lineStarts));\n\n\t\t\treturn newPieces;\n\t\t}\n\n\t\tlet startOffset = this._buffers[0].buffer.length;\n\t\tconst lineStarts = createLineStartsFast(text, false);\n\n\t\tlet start = this._lastChangeBufferPos;\n\t\tif (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset\n\t\t\t&& startOffset !== 0\n\t\t\t&& this.startWithLF(text)\n\t\t\t&& this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one\n\t\t) {\n\t\t\tthis._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 };\n\t\t\tstart = this._lastChangeBufferPos;\n\n\t\t\tfor (let i = 0; i < lineStarts.length; i++) {\n\t\t\t\tlineStarts[i] += startOffset + 1;\n\t\t\t}\n\n\t\t\tthis._buffers[0].lineStarts = (<number[]>this._buffers[0].lineStarts).concat(<number[]>lineStarts.slice(1));\n\t\t\tthis._buffers[0].buffer += '_' + text;\n\t\t\tstartOffset += 1;\n\t\t} else {\n\t\t\tif (startOffset !== 0) {\n\t\t\t\tfor (let i = 0; i < lineStarts.length; i++) {\n\t\t\t\t\tlineStarts[i] += startOffset;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._buffers[0].lineStarts = (<number[]>this._buffers[0].lineStarts).concat(<number[]>lineStarts.slice(1));\n\t\t\tthis._buffers[0].buffer += text;\n\t\t}\n\n\t\tconst endOffset = this._buffers[0].buffer.length;\n\t\tconst endIndex = this._buffers[0].lineStarts.length - 1;\n\t\tconst endColumn = endOffset - this._buffers[0].lineStarts[endIndex];\n\t\tconst endPos = { line: endIndex, column: endColumn };\n\t\tconst newPiece = new Piece(\n\t\t\t0, /** todo@peng */\n\t\t\tstart,\n\t\t\tendPos,\n\t\t\tthis.getLineFeedCnt(0, start, endPos),\n\t\t\tendOffset - startOffset\n\t\t);\n\t\tthis._lastChangeBufferPos = endPos;\n\t\treturn [newPiece];\n\t}\n\n\tpublic getLinesRawContent(): string {\n\t\treturn this.getContentOfSubTree(this.root);\n\t}\n\n\tpublic getLineRawContent(lineNumber: number, endOffset: number = 0): string {\n\t\tlet x = this.root;\n\n\t\tlet ret = '';\n\t\tconst cache = this._searchCache.get2(lineNumber);\n\t\tif (cache) {\n\t\t\tx = cache.node;\n\t\t\tconst prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);\n\t\t\tconst buffer = this._buffers[x.piece.bufferIndex].buffer;\n\t\t\tconst startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\t\t\tif (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {\n\t\t\t\tret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n\t\t\t} else {\n\t\t\t\tconst accumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);\n\t\t\t\treturn buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n\t\t\t}\n\t\t} else {\n\t\t\tlet nodeStartOffset = 0;\n\t\t\tconst originalLineNumber = lineNumber;\n\t\t\twhile (x !== SENTINEL) {\n\t\t\t\tif (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n\t\t\t\t\tx = x.left;\n\t\t\t\t} else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n\t\t\t\t\tconst prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n\t\t\t\t\tconst accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n\t\t\t\t\tconst buffer = this._buffers[x.piece.bufferIndex].buffer;\n\t\t\t\t\tconst startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\t\t\t\t\tnodeStartOffset += x.size_left;\n\t\t\t\t\tthis._searchCache.set({\n\t\t\t\t\t\tnode: x,\n\t\t\t\t\t\tnodeStartOffset,\n\t\t\t\t\t\tnodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)\n\t\t\t\t\t});\n\n\t\t\t\t\treturn buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n\t\t\t\t} else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n\t\t\t\t\tconst prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n\t\t\t\t\tconst buffer = this._buffers[x.piece.bufferIndex].buffer;\n\t\t\t\t\tconst startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\n\t\t\t\t\tret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tlineNumber -= x.lf_left + x.piece.lineFeedCnt;\n\t\t\t\t\tnodeStartOffset += x.size_left + x.piece.length;\n\t\t\t\t\tx = x.right;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// search in order, to find the node contains end column\n\t\tx = x.next();\n\t\twhile (x !== SENTINEL) {\n\t\t\tconst buffer = this._buffers[x.piece.bufferIndex].buffer;\n\n\t\t\tif (x.piece.lineFeedCnt > 0) {\n\t\t\t\tconst accumulatedValue = this.getAccumulatedValue(x, 0);\n\t\t\t\tconst startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\n\t\t\t\tret += buffer.substring(startOffset, startOffset + accumulatedValue - endOffset);\n\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\tconst startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\t\t\t\tret += buffer.substr(startOffset, x.piece.length);\n\t\t\t}\n\n\t\t\tx = x.next();\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tprivate computeBufferMetadata() {\n\t\tlet x = this.root;\n\n\t\tlet lfCnt = 1;\n\t\tlet len = 0;\n\n\t\twhile (x !== SENTINEL) {\n\t\t\tlfCnt += x.lf_left + x.piece.lineFeedCnt;\n\t\t\tlen += x.size_left + x.piece.length;\n\t\t\tx = x.right;\n\t\t}\n\n\t\tthis._lineCnt = lfCnt;\n\t\tthis._length = len;\n\t\tthis._searchCache.validate(this._length);\n\t}\n\n\t// #region node operations\n\tprivate getIndexOf(node: TreeNode, accumulatedValue: number): { index: number; remainder: number } {\n\t\tconst piece = node.piece;\n\t\tconst pos = this.positionInBuffer(node, accumulatedValue);\n\t\tconst lineCnt = pos.line - piece.start.line;\n\n\t\tif (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {\n\t\t\t// we are checking the end of this node, so a CRLF check is necessary.\n\t\t\tconst realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);\n\t\t\tif (realLineCnt !== lineCnt) {\n\t\t\t\t// aha yes, CRLF\n\t\t\t\treturn { index: realLineCnt, remainder: 0 };\n\t\t\t}\n\t\t}\n\n\t\treturn { index: lineCnt, remainder: pos.column };\n\t}\n\n\tprivate getAccumulatedValue(node: TreeNode, index: number) {\n\t\tif (index < 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tconst piece = node.piece;\n\t\tconst lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n\t\tconst expectedLineStartIndex = piece.start.line + index + 1;\n\t\tif (expectedLineStartIndex > piece.end.line) {\n\t\t\treturn lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;\n\t\t} else {\n\t\t\treturn lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;\n\t\t}\n\t}\n\n\tprivate deleteNodeTail(node: TreeNode, pos: BufferCursor) {\n\t\tconst piece = node.piece;\n\t\tconst originalLFCnt = piece.lineFeedCnt;\n\t\tconst originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n\n\t\tconst newEnd = pos;\n\t\tconst newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);\n\t\tconst newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n\n\t\tconst lf_delta = newLineFeedCnt - originalLFCnt;\n\t\tconst size_delta = newEndOffset - originalEndOffset;\n\t\tconst newLength = piece.length + size_delta;\n\n\t\tnode.piece = new Piece(\n\t\t\tpiece.bufferIndex,\n\t\t\tpiece.start,\n\t\t\tnewEnd,\n\t\t\tnewLineFeedCnt,\n\t\t\tnewLength\n\t\t);\n\n\t\tupdateTreeMetadata(this, node, size_delta, lf_delta);\n\t}\n\n\tprivate deleteNodeHead(node: TreeNode, pos: BufferCursor) {\n\t\tconst piece = node.piece;\n\t\tconst originalLFCnt = piece.lineFeedCnt;\n\t\tconst originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n\n\t\tconst newStart = pos;\n\t\tconst newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n\t\tconst newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);\n\t\tconst lf_delta = newLineFeedCnt - originalLFCnt;\n\t\tconst size_delta = originalStartOffset - newStartOffset;\n\t\tconst newLength = piece.length + size_delta;\n\t\tnode.piece = new Piece(\n\t\t\tpiece.bufferIndex,\n\t\t\tnewStart,\n\t\t\tpiece.end,\n\t\t\tnewLineFeedCnt,\n\t\t\tnewLength\n\t\t);\n\n\t\tupdateTreeMetadata(this, node, size_delta, lf_delta);\n\t}\n\n\tprivate shrinkNode(node: TreeNode, start: BufferCursor, end: BufferCursor) {\n\t\tconst piece = node.piece;\n\t\tconst originalStartPos = piece.start;\n\t\tconst originalEndPos = piece.end;\n\n\t\t// old piece, originalStartPos, start\n\t\tconst oldLength = piece.length;\n\t\tconst oldLFCnt = piece.lineFeedCnt;\n\t\tconst newEnd = start;\n\t\tconst newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n\t\tconst newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);\n\n\t\tnode.piece = new Piece(\n\t\t\tpiece.bufferIndex,\n\t\t\tpiece.start,\n\t\t\tnewEnd,\n\t\t\tnewLineFeedCnt,\n\t\t\tnewLength\n\t\t);\n\n\t\tupdateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);\n\n\t\t// new right piece, end, originalEndPos\n\t\tconst newPiece = new Piece(\n\t\t\tpiece.bufferIndex,\n\t\t\tend,\n\t\t\toriginalEndPos,\n\t\t\tthis.getLineFeedCnt(piece.bufferIndex, end, originalEndPos),\n\t\t\tthis.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end)\n\t\t);\n\n\t\tconst newNode = this.rbInsertRight(node, newPiece);\n\t\tthis.validateCRLFWithPrevNode(newNode);\n\t}\n\n\tprivate appendToNode(node: TreeNode, value: string): void {\n\t\tif (this.adjustCarriageReturnFromNext(value, node)) {\n\t\t\tvalue += '\\n';\n\t\t}\n\n\t\tconst hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);\n\t\tconst startOffset = this._buffers[0].buffer.length;\n\t\tthis._buffers[0].buffer += value;\n\t\tconst lineStarts = createLineStartsFast(value, false);\n\t\tfor (let i = 0; i < lineStarts.length; i++) {\n\t\t\tlineStarts[i] += startOffset;\n\t\t}\n\t\tif (hitCRLF) {\n\t\t\tconst prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];\n\t\t\t(<number[]>this._buffers[0].lineStarts).pop();\n\t\t\t// _lastChangeBufferPos is already wrong\n\t\t\tthis._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: startOffset - prevStartOffset };\n\t\t}\n\n\t\tthis._buffers[0].lineStarts = (<number[]>this._buffers[0].lineStarts).concat(<number[]>lineStarts.slice(1));\n\t\tconst endIndex = this._buffers[0].lineStarts.length - 1;\n\t\tconst endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];\n\t\tconst newEnd = { line: endIndex, column: endColumn };\n\t\tconst newLength = node.piece.length + value.length;\n\t\tconst oldLineFeedCnt = node.piece.lineFeedCnt;\n\t\tconst newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);\n\t\tconst lf_delta = newLineFeedCnt - oldLineFeedCnt;\n\n\t\tnode.piece = new Piece(\n\t\t\tnode.piece.bufferIndex,\n\t\t\tnode.piece.start,\n\t\t\tnewEnd,\n\t\t\tnewLineFeedCnt,\n\t\t\tnewLength\n\t\t);\n\n\t\tthis._lastChangeBufferPos = newEnd;\n\t\tupdateTreeMetadata(this, node, value.length, lf_delta);\n\t}\n\n\tprivate nodeAt(offset: number): NodePosition {\n\t\tlet x = this.root;\n\t\tconst cache = this._searchCache.get(offset);\n\t\tif (cache) {\n\t\t\treturn {\n\t\t\t\tnode: cache.node,\n\t\t\t\tnodeStartOffset: cache.nodeStartOffset,\n\t\t\t\tremainder: offset - cache.nodeStartOffset\n\t\t\t};\n\t\t}\n\n\t\tlet nodeStartOffset = 0;\n\n\t\twhile (x !== SENTINEL) {\n\t\t\tif (x.size_left > offset) {\n\t\t\t\tx = x.left;\n\t\t\t} else if (x.size_left + x.piece.length >= offset) {\n\t\t\t\tnodeStartOffset += x.size_left;\n\t\t\t\tconst ret = {\n\t\t\t\t\tnode: x,\n\t\t\t\t\tremainder: offset - x.size_left,\n\t\t\t\t\tnodeStartOffset\n\t\t\t\t};\n\t\t\t\tthis._searchCache.set(ret);\n\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\toffset -= x.size_left + x.piece.length;\n\t\t\t\tnodeStartOffset += x.size_left + x.piece.length;\n\t\t\t\tx = x.right;\n\t\t\t}\n\t\t}\n\n\t\treturn null!;\n\t}\n\n\tprivate nodeAt2(lineNumber: number, column: number): NodePosition {\n\t\tlet x = this.root;\n\t\tlet nodeStartOffset = 0;\n\n\t\twhile (x !== SENTINEL) {\n\t\t\tif (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n\t\t\t\tx = x.left;\n\t\t\t} else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n\t\t\t\tconst prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n\t\t\t\tconst accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n\t\t\t\tnodeStartOffset += x.size_left;\n\n\t\t\t\treturn {\n\t\t\t\t\tnode: x,\n\t\t\t\t\tremainder: Math.min(prevAccumualtedValue + column - 1, accumulatedValue),\n\t\t\t\t\tnodeStartOffset\n\t\t\t\t};\n\t\t\t} else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n\t\t\t\tconst prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n\t\t\t\tif (prevAccumualtedValue + column - 1 <= x.piece.length) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tnode: x,\n\t\t\t\t\t\tremainder: prevAccumualtedValue + column - 1,\n\t\t\t\t\t\tnodeStartOffset\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tcolumn -= x.piece.length - prevAccumualtedValue;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlineNumber -= x.lf_left + x.piece.lineFeedCnt;\n\t\t\t\tnodeStartOffset += x.size_left + x.piece.length;\n\t\t\t\tx = x.right;\n\t\t\t}\n\t\t}\n\n\t\t// search in order, to find the node contains position.column\n\t\tx = x.next();\n\t\twhile (x !== SENTINEL) {\n\n\t\t\tif (x.piece.lineFeedCnt > 0) {\n\t\t\t\tconst accumulatedValue = this.getAccumulatedValue(x, 0);\n\t\t\t\tconst nodeStartOffset = this.offsetOfNode(x);\n\t\t\t\treturn {\n\t\t\t\t\tnode: x,\n\t\t\t\t\tremainder: Math.min(column - 1, accumulatedValue),\n\t\t\t\t\tnodeStartOffset\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tif (x.piece.length >= column - 1) {\n\t\t\t\t\tconst nodeStartOffset = this.offsetOfNode(x);\n\t\t\t\t\treturn {\n\t\t\t\t\t\tnode: x,\n\t\t\t\t\t\tremainder: column - 1,\n\t\t\t\t\t\tnodeStartOffset\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tcolumn -= x.piece.length;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tx = x.next();\n\t\t}\n\n\t\treturn null!;\n\t}\n\n\tprivate nodeCharCodeAt(node: TreeNode, offset: number): number {\n\t\tif (node.piece.lineFeedCnt < 1) {\n\t\t\treturn -1;\n\t\t}\n\t\tconst buffer = this._buffers[node.piece.bufferIndex];\n\t\tconst newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;\n\t\treturn buffer.buffer.charCodeAt(newOffset);\n\t}\n\n\tprivate offsetOfNode(node: TreeNode): number {\n\t\tif (!node) {\n\t\t\treturn 0;\n\t\t}\n\t\tlet pos = node.size_left;\n\t\twhile (node !== this.root) {\n\t\t\tif (node.parent.right === node) {\n\t\t\t\tpos += node.parent.size_left + node.parent.piece.length;\n\t\t\t}\n\n\t\t\tnode = node.parent;\n\t\t}\n\n\t\treturn pos;\n\t}\n\n\t// #endregion\n\n\t// #region CRLF\n\tprivate shouldCheckCRLF() {\n\t\treturn !(this._EOLNormalized && this._EOL === '\\n');\n\t}\n\n\tprivate startWithLF(val: string | TreeNode): boolean {\n\t\tif (typeof val === 'string') {\n\t\t\treturn val.charCodeAt(0) === 10;\n\t\t}\n\n\t\tif (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst piece = val.piece;\n\t\tconst lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n\t\tconst line = piece.start.line;\n\t\tconst startOffset = lineStarts[line] + piece.start.column;\n\t\tif (line === lineStarts.length - 1) {\n\t\t\t// last line, so there is no line feed at the end of this line\n\t\t\treturn false;\n\t\t}\n\t\tconst nextLineOffset = lineStarts[line + 1];\n\t\tif (nextLineOffset > startOffset + 1) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;\n\t}\n\n\tprivate endWithCR(val: string | TreeNode): boolean {\n\t\tif (typeof val === 'string') {\n\t\t\treturn val.charCodeAt(val.length - 1) === 13;\n\t\t}\n\n\t\tif (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this.nodeCharCodeAt(val, val.piece.length - 1) === 13;\n\t}\n\n\tprivate validateCRLFWithPrevNode(nextNode: TreeNode) {\n\t\tif (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {\n\t\t\tconst node = nextNode.prev();\n\t\t\tif (this.endWithCR(node)) {\n\t\t\t\tthis.fixCRLF(node, nextNode);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate validateCRLFWithNextNode(node: TreeNode) {\n\t\tif (this.shouldCheckCRLF() && this.endWithCR(node)) {\n\t\t\tconst nextNode = node.next();\n\t\t\tif (this.startWithLF(nextNode)) {\n\t\t\t\tthis.fixCRLF(node, nextNode);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate fixCRLF(prev: TreeNode, next: TreeNode) {\n\t\tconst nodesToDel: TreeNode[] = [];\n\t\t// update node\n\t\tconst lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;\n\t\tlet newEnd: BufferCursor;\n\t\tif (prev.piece.end.column === 0) {\n\t\t\t// it means, last line ends with \\r, not \\r\\n\n\t\t\tnewEnd = { line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1 };\n\t\t} else {\n\t\t\t// \\r\\n\n\t\t\tnewEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };\n\t\t}\n\n\t\tconst prevNewLength = prev.piece.length - 1;\n\t\tconst prevNewLFCnt = prev.piece.lineFeedCnt - 1;\n\t\tprev.piece = new Piece(\n\t\t\tprev.piece.bufferIndex,\n\t\t\tprev.piece.start,\n\t\t\tnewEnd,\n\t\t\tprevNewLFCnt,\n\t\t\tprevNewLength\n\t\t);\n\n\t\tupdateTreeMetadata(this, prev, - 1, -1);\n\t\tif (prev.piece.length === 0) {\n\t\t\tnodesToDel.push(prev);\n\t\t}\n\n\t\t// update nextNode\n\t\tconst newStart: BufferCursor = { line: next.piece.start.line + 1, column: 0 };\n\t\tconst newLength = next.piece.length - 1;\n\t\tconst newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);\n\t\tnext.piece = new Piece(\n\t\t\tnext.piece.bufferIndex,\n\t\t\tnewStart,\n\t\t\tnext.piece.end,\n\t\t\tnewLineFeedCnt,\n\t\t\tnewLength\n\t\t);\n\n\t\tupdateTreeMetadata(this, next, - 1, -1);\n\t\tif (next.piece.length === 0) {\n\t\t\tnodesToDel.push(next);\n\t\t}\n\n\t\t// create new piece which contains \\r\\n\n\t\tconst pieces = this.createNewPieces('\\r\\n');\n\t\tthis.rbInsertRight(prev, pieces[0]);\n\t\t// delete empty nodes\n\n\t\tfor (let i = 0; i < nodesToDel.length; i++) {\n\t\t\trbDelete(this, nodesToDel[i]);\n\t\t}\n\t}\n\n\tprivate adjustCarriageReturnFromNext(value: string, node: TreeNode): boolean {\n\t\tif (this.shouldCheckCRLF() && this.endWithCR(value)) {\n\t\t\tconst nextNode = node.next();\n\t\t\tif (this.startWithLF(nextNode)) {\n\t\t\t\t// move `\\n` forward\n\t\t\t\tvalue += '\\n';\n\n\t\t\t\tif (nextNode.piece.length === 1) {\n\t\t\t\t\trbDelete(this, nextNode);\n\t\t\t\t} else {\n\n\t\t\t\t\tconst piece = nextNode.piece;\n\t\t\t\t\tconst newStart: BufferCursor = { line: piece.start.line + 1, column: 0 };\n\t\t\t\t\tconst newLength = piece.length - 1;\n\t\t\t\t\tconst newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n\t\t\t\t\tnextNode.piece = new Piece(\n\t\t\t\t\t\tpiece.bufferIndex,\n\t\t\t\t\t\tnewStart,\n\t\t\t\t\t\tpiece.end,\n\t\t\t\t\t\tnewLineFeedCnt,\n\t\t\t\t\t\tnewLength\n\t\t\t\t\t);\n\n\t\t\t\t\tupdateTreeMetadata(this, nextNode, -1, -1);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t// #endregion\n\n\t// #endregion\n\n\t// #region Tree operations\n\titerate(node: TreeNode, callback: (node: TreeNode) => boolean): boolean {\n\t\tif (node === SENTINEL) {\n\t\t\treturn callback(SENTINEL);\n\t\t}\n\n\t\tconst leftRet = this.iterate(node.left, callback);\n\t\tif (!leftRet) {\n\t\t\treturn leftRet;\n\t\t}\n\n\t\treturn callback(node) && this.iterate(node.right, callback);\n\t}\n\n\tprivate getNodeContent(node: TreeNode) {\n\t\tif (node === SENTINEL) {\n\t\t\treturn '';\n\t\t}\n\t\tconst buffer = this._buffers[node.piece.bufferIndex];\n\t\tconst piece = node.piece;\n\t\tconst startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n\t\tconst endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n\t\tconst currentContent = buffer.buffer.substring(startOffset, endOffset);\n\t\treturn currentContent;\n\t}\n\n\tgetPieceContent(piece: Piece) {\n\t\tconst buffer = this._buffers[piece.bufferIndex];\n\t\tconst startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n\t\tconst endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n\t\tconst currentContent = buffer.buffer.substring(startOffset, endOffset);\n\t\treturn currentContent;\n\t}\n\n\t/**\n\t *      node              node\n\t *     /  \\              /  \\\n\t *    a   b    <----   a    b\n\t *                         /\n\t *                        z\n\t */\n\tprivate rbInsertRight(node: TreeNode | null, p: Piece): TreeNode {\n\t\tconst z = new TreeNode(p, NodeColor.Red);\n\t\tz.left = SENTINEL;\n\t\tz.right = SENTINEL;\n\t\tz.parent = SENTINEL;\n\t\tz.size_left = 0;\n\t\tz.lf_left = 0;\n\n\t\tconst x = this.root;\n\t\tif (x === SENTINEL) {\n\t\t\tthis.root = z;\n\t\t\tz.color = NodeColor.Black;\n\t\t} else if (node!.right === SENTINEL) {\n\t\t\tnode!.right = z;\n\t\t\tz.parent = node!;\n\t\t} else {\n\t\t\tconst nextNode = leftest(node!.right);\n\t\t\tnextNode.left = z;\n\t\t\tz.parent = nextNode;\n\t\t}\n\n\t\tfixInsert(this, z);\n\t\treturn z;\n\t}\n\n\t/**\n\t *      node              node\n\t *     /  \\              /  \\\n\t *    a   b     ---->   a    b\n\t *                       \\\n\t *                        z\n\t */\n\tprivate rbInsertLeft(node: TreeNode | null, p: Piece): TreeNode {\n\t\tconst z = new TreeNode(p, NodeColor.Red);\n\t\tz.left = SENTINEL;\n\t\tz.right = SENTINEL;\n\t\tz.parent = SENTINEL;\n\t\tz.size_left = 0;\n\t\tz.lf_left = 0;\n\n\t\tif (this.root === SENTINEL) {\n\t\t\tthis.root = z;\n\t\t\tz.color = NodeColor.Black;\n\t\t} else if (node!.left === SENTINEL) {\n\t\t\tnode!.left = z;\n\t\t\tz.parent = node!;\n\t\t} else {\n\t\t\tconst prevNode = righttest(node!.left); // a\n\t\t\tprevNode.right = z;\n\t\t\tz.parent = prevNode;\n\t\t}\n\n\t\tfixInsert(this, z);\n\t\treturn z;\n\t}\n\n\tprivate getContentOfSubTree(node: TreeNode): string {\n\t\tlet str = '';\n\n\t\tthis.iterate(node, node => {\n\t\t\tstr += this.getNodeContent(node);\n\t\t\treturn true;\n\t\t});\n\n\t\treturn str;\n\t}\n\t// #endregion\n}\n"],
  "mappings": "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",
  "names": ["buffer", "startOffset", "startColumn", "startSplitPosInBuffer", "endSplitPosInBuffer", "lineStarts", "nodeStartOffset", "node"]
}
