{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from \"../../../../base/common/charCode.js\";\nimport { Position } from \"../../core/position.js\";\nimport { Range } from \"../../core/range.js\";\nimport { FindMatch, type ITextSnapshot, type SearchData } from \"../../model.js\";\nimport { Searcher, createFindMatch, isValidMatch } from \"../textModelSearch.js\";\nimport {\n\tNodeColor,\n\tSENTINEL,\n\tTreeNode,\n\tfixInsert,\n\tleftest,\n\trbDelete,\n\trighttest,\n\tupdateTreeMetadata,\n} from \"./rbTreeBase.js\";\n\n// const lfRegex = new RegExp(/\\r\\n|\\r|\\n/g);\nconst AverageBufferSize = 65535;\n\nfunction createUintArray(arr: number[]): Uint32Array | Uint16Array {\n\tlet r;\n\tif (arr[arr.length - 1] < 65536) {\n\t\tr = new Uint16Array(arr.length);\n\t} else {\n\t\tr = new Uint32Array(arr.length);\n\t}\n\tr.set(arr, 0);\n\treturn r;\n}\n\nclass LineStarts {\n\tconstructor(\n\t\tpublic readonly lineStarts: Uint32Array | Uint16Array | number[],\n\t\tpublic readonly cr: number,\n\t\tpublic readonly lf: number,\n\t\tpublic readonly crlf: number,\n\t\tpublic readonly isBasicASCII: boolean,\n\t) {}\n}\n\nexport function createLineStartsFast(\n\tstr: string,\n\treadonly = true,\n): Uint32Array | Uint16Array | number[] {\n\tconst r: number[] = [0];\n\tlet rLength = 1;\n\n\tfor (let i = 0, len = str.length; i < len; i++) {\n\t\tconst chr = str.charCodeAt(i);\n\n\t\tif (chr === CharCode.CarriageReturn) {\n\t\t\tif (i + 1 < len && str.charCodeAt(i + 1) === CharCode.LineFeed) {\n\t\t\t\t// \\r\\n... case\n\t\t\t\tr[rLength++] = i + 2;\n\t\t\t\ti++; // skip \\n\n\t\t\t} else {\n\t\t\t\t// \\r... case\n\t\t\t\tr[rLength++] = i + 1;\n\t\t\t}\n\t\t} else if (chr === CharCode.LineFeed) {\n\t\t\tr[rLength++] = i + 1;\n\t\t}\n\t}\n\tif (readonly) {\n\t\treturn createUintArray(r);\n\t} else {\n\t\treturn r;\n\t}\n}\n\nexport function createLineStarts(r: number[], str: string): LineStarts {\n\tr.length = 0;\n\tr[0] = 0;\n\tlet rLength = 1;\n\tlet cr = 0,\n\t\tlf = 0,\n\t\tcrlf = 0;\n\tlet isBasicASCII = true;\n\tfor (let i = 0, len = str.length; i < len; i++) {\n\t\tconst chr = str.charCodeAt(i);\n\n\t\tif (chr === CharCode.CarriageReturn) {\n\t\t\tif (i + 1 < len && str.charCodeAt(i + 1) === CharCode.LineFeed) {\n\t\t\t\t// \\r\\n... case\n\t\t\t\tcrlf++;\n\t\t\t\tr[rLength++] = i + 2;\n\t\t\t\ti++; // skip \\n\n\t\t\t} else {\n\t\t\t\tcr++;\n\t\t\t\t// \\r... case\n\t\t\t\tr[rLength++] = i + 1;\n\t\t\t}\n\t\t} else if (chr === CharCode.LineFeed) {\n\t\t\tlf++;\n\t\t\tr[rLength++] = i + 1;\n\t\t} else if (isBasicASCII) {\n\t\t\tif (chr !== CharCode.Tab && (chr < 32 || chr > 126)) {\n\t\t\t\tisBasicASCII = false;\n\t\t\t}\n\t\t}\n\t}\n\tconst result = new LineStarts(\n\t\tcreateUintArray(r),\n\t\tcr,\n\t\tlf,\n\t\tcrlf,\n\t\tisBasicASCII,\n\t);\n\tr.length = 0;\n\n\treturn result;\n}\n\ninterface NodePosition {\n\t/**\n\t * Piece Index\n\t */\n\tnode: TreeNode;\n\t/**\n\t * remainder in current piece.\n\t */\n\tremainder: number;\n\t/**\n\t * node start offset in document.\n\t */\n\tnodeStartOffset: number;\n}\n\ninterface BufferCursor {\n\t/**\n\t * Line number in current buffer\n\t */\n\tline: number;\n\t/**\n\t * Column number in current buffer\n\t */\n\tcolumn: number;\n}\n\nexport class Piece {\n\treadonly bufferIndex: number;\n\treadonly start: BufferCursor;\n\treadonly end: BufferCursor;\n\treadonly length: number;\n\treadonly lineFeedCnt: number;\n\n\tconstructor(\n\t\tbufferIndex: number,\n\t\tstart: BufferCursor,\n\t\tend: BufferCursor,\n\t\tlineFeedCnt: number,\n\t\tlength: number,\n\t) {\n\t\tthis.bufferIndex = bufferIndex;\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.lineFeedCnt = lineFeedCnt;\n\t\tthis.length = length;\n\t}\n}\n\nexport class StringBuffer {\n\tbuffer: string;\n\tlineStarts: Uint32Array | Uint16Array | number[];\n\n\tconstructor(\n\t\tbuffer: string,\n\t\tlineStarts: Uint32Array | Uint16Array | number[],\n\t) {\n\t\tthis.buffer = buffer;\n\t\tthis.lineStarts = lineStarts;\n\t}\n}\n\n/**\n * Readonly snapshot for piece tree.\n * In a real multiple thread environment, to make snapshot reading always work correctly, we need to\n * 1. Make TreeNode.piece immutable, then reading and writing can run in parallel.\n * 2. TreeNode/Buffers normalization should not happen during snapshot reading.\n */\nclass PieceTreeSnapshot implements ITextSnapshot {\n\tprivate readonly _pieces: Piece[];\n\tprivate _index: number;\n\tprivate readonly _tree: PieceTreeBase;\n\tprivate readonly _BOM: string;\n\n\tconstructor(tree: PieceTreeBase, BOM: string) {\n\t\tthis._pieces = [];\n\t\tthis._tree = tree;\n\t\tthis._BOM = BOM;\n\t\tthis._index = 0;\n\t\tif (tree.root !== SENTINEL) {\n\t\t\ttree.iterate(tree.root, (node) => {\n\t\t\t\tif (node !== SENTINEL) {\n\t\t\t\t\tthis._pieces.push(node.piece);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\t}\n\n\tread(): string | null {\n\t\tif (this._pieces.length === 0) {\n\t\t\tif (this._index === 0) {\n\t\t\t\tthis._index++;\n\t\t\t\treturn this._BOM;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tif (this._index > this._pieces.length - 1) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (this._index === 0) {\n\t\t\treturn (\n\t\t\t\tthis._BOM +\n\t\t\t\tthis._tree.getPieceContent(this._pieces[this._index++])\n\t\t\t);\n\t\t}\n\t\treturn this._tree.getPieceContent(this._pieces[this._index++]);\n\t}\n}\n\ninterface CacheEntry {\n\tnode: TreeNode;\n\tnodeStartOffset: number;\n\tnodeStartLineNumber?: number;\n}\n\nclass PieceTreeSearchCache {\n\tprivate readonly _limit: number;\n\tprivate _cache: CacheEntry[];\n\n\tconstructor(limit: number) {\n\t\tthis._limit = limit;\n\t\tthis._cache = [];\n\t}\n\n\tpublic get(offset: number): CacheEntry | null {\n\t\tfor (let i = this._cache.length - 1; i >= 0; i--) {\n\t\t\tconst nodePos = this._cache[i];\n\t\t\tif (\n\t\t\t\tnodePos.nodeStartOffset <= offset &&\n\t\t\t\tnodePos.nodeStartOffset + nodePos.node.piece.length >= offset\n\t\t\t) {\n\t\t\t\treturn nodePos;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic get2(\n\t\tlineNumber: number,\n\t): {\n\t\tnode: TreeNode;\n\t\tnodeStartOffset: number;\n\t\tnodeStartLineNumber: number;\n\t} | null {\n\t\tfor (let i = this._cache.length - 1; i >= 0; i--) {\n\t\t\tconst nodePos = this._cache[i];\n\t\t\tif (\n\t\t\t\tnodePos.nodeStartLineNumber &&\n\t\t\t\tnodePos.nodeStartLineNumber < lineNumber &&\n\t\t\t\tnodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >=\n\t\t\t\t\tlineNumber\n\t\t\t) {\n\t\t\t\treturn <\n\t\t\t\t\t{\n\t\t\t\t\t\tnode: TreeNode;\n\t\t\t\t\t\tnodeStartOffset: number;\n\t\t\t\t\t\tnodeStartLineNumber: number;\n\t\t\t\t\t}\n\t\t\t\t>nodePos;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic set(nodePosition: CacheEntry) {\n\t\tif (this._cache.length >= this._limit) {\n\t\t\tthis._cache.shift();\n\t\t}\n\t\tthis._cache.push(nodePosition);\n\t}\n\n\tpublic validate(offset: number) {\n\t\tlet hasInvalidVal = false;\n\t\tconst tmp: Array<CacheEntry | null> = this._cache;\n\t\tfor (let i = 0; i < tmp.length; i++) {\n\t\t\tconst nodePos = tmp[i]!;\n\t\t\tif (\n\t\t\t\tnodePos.node.parent === null ||\n\t\t\t\tnodePos.nodeStartOffset >= offset\n\t\t\t) {\n\t\t\t\ttmp[i] = null;\n\t\t\t\thasInvalidVal = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (hasInvalidVal) {\n\t\t\tconst newArr: CacheEntry[] = [];\n\t\t\tfor (const entry of tmp) {\n\t\t\t\tif (entry !== null) {\n\t\t\t\t\tnewArr.push(entry);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._cache = newArr;\n\t\t}\n\t}\n}\n\nexport class PieceTreeBase {\n\troot!: TreeNode;\n\tprotected _buffers!: StringBuffer[]; // 0 is change buffer, others are readonly original buffer.\n\tprotected _lineCnt!: number;\n\tprotected _length!: number;\n\tprotected _EOL!: \"\\r\\n\" | \"\\n\";\n\tprotected _EOLLength!: number;\n\tprotected _EOLNormalized!: boolean;\n\tprivate _lastChangeBufferPos!: BufferCursor;\n\tprivate _searchCache!: PieceTreeSearchCache;\n\tprivate _lastVisitedLine!: { lineNumber: number; value: string };\n\n\tconstructor(\n\t\tchunks: StringBuffer[],\n\t\teol: \"\\r\\n\" | \"\\n\",\n\t\teolNormalized: boolean,\n\t) {\n\t\tthis.create(chunks, eol, eolNormalized);\n\t}\n\n\tcreate(chunks: StringBuffer[], eol: \"\\r\\n\" | \"\\n\", eolNormalized: boolean) {\n\t\tthis._buffers = [new StringBuffer(\"\", [0])];\n\t\tthis._lastChangeBufferPos = { line: 0, column: 0 };\n\t\tthis.root = SENTINEL;\n\t\tthis._lineCnt = 1;\n\t\tthis._length = 0;\n\t\tthis._EOL = eol;\n\t\tthis._EOLLength = eol.length;\n\t\tthis._EOLNormalized = eolNormalized;\n\n\t\tlet lastNode: TreeNode | null = null;\n\t\tfor (let i = 0, len = chunks.length; i < len; i++) {\n\t\t\tif (chunks[i].buffer.length > 0) {\n\t\t\t\tif (!chunks[i].lineStarts) {\n\t\t\t\t\tchunks[i].lineStarts = createLineStartsFast(\n\t\t\t\t\t\tchunks[i].buffer,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst piece = new Piece(\n\t\t\t\t\ti + 1,\n\t\t\t\t\t{ line: 0, column: 0 },\n\t\t\t\t\t{\n\t\t\t\t\t\tline: chunks[i].lineStarts.length - 1,\n\t\t\t\t\t\tcolumn:\n\t\t\t\t\t\t\tchunks[i].buffer.length -\n\t\t\t\t\t\t\tchunks[i].lineStarts[\n\t\t\t\t\t\t\t\tchunks[i].lineStarts.length - 1\n\t\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t\tchunks[i].lineStarts.length - 1,\n\t\t\t\t\tchunks[i].buffer.length,\n\t\t\t\t);\n\t\t\t\tthis._buffers.push(chunks[i]);\n\t\t\t\tlastNode = this.rbInsertRight(lastNode, piece);\n\t\t\t}\n\t\t}\n\n\t\tthis._searchCache = new PieceTreeSearchCache(1);\n\t\tthis._lastVisitedLine = { lineNumber: 0, value: \"\" };\n\t\tthis.computeBufferMetadata();\n\t}\n\n\tnormalizeEOL(eol: \"\\r\\n\" | \"\\n\") {\n\t\tconst averageBufferSize = AverageBufferSize;\n\t\tconst min = averageBufferSize - Math.floor(averageBufferSize / 3);\n\t\tconst max = min * 2;\n\n\t\tlet tempChunk = \"\";\n\t\tlet tempChunkLen = 0;\n\t\tconst chunks: StringBuffer[] = [];\n\n\t\tthis.iterate(this.root, (node) => {\n\t\t\tconst str = this.getNodeContent(node);\n\t\t\tconst len = str.length;\n\t\t\tif (tempChunkLen <= min || tempChunkLen + len < max) {\n\t\t\t\ttempChunk += str;\n\t\t\t\ttempChunkLen += len;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// flush anyways\n\t\t\tconst text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n\t\t\tchunks.push(new StringBuffer(text, createLineStartsFast(text)));\n\t\t\ttempChunk = str;\n\t\t\ttempChunkLen = len;\n\t\t\treturn true;\n\t\t});\n\n\t\tif (tempChunkLen > 0) {\n\t\t\tconst text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n\t\t\tchunks.push(new StringBuffer(text, createLineStartsFast(text)));\n\t\t}\n\n\t\tthis.create(chunks, eol, true);\n\t}\n\n\t// #region Buffer API\n\tpublic getEOL(): \"\\r\\n\" | \"\\n\" {\n\t\treturn this._EOL;\n\t}\n\n\tpublic setEOL(newEOL: \"\\r\\n\" | \"\\n\"): void {\n\t\tthis._EOL = newEOL;\n\t\tthis._EOLLength = this._EOL.length;\n\t\tthis.normalizeEOL(newEOL);\n\t}\n\n\tpublic createSnapshot(BOM: string): ITextSnapshot {\n\t\treturn new PieceTreeSnapshot(this, BOM);\n\t}\n\n\tpublic equal(other: PieceTreeBase): boolean {\n\t\tif (this.getLength() !== other.getLength()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.getLineCount() !== other.getLineCount()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlet offset = 0;\n\t\tconst ret = this.iterate(this.root, (node) => {\n\t\t\tif (node === SENTINEL) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tconst str = this.getNodeContent(node);\n\t\t\tconst len = str.length;\n\t\t\tconst startPosition = other.nodeAt(offset);\n\t\t\tconst endPosition = other.nodeAt(offset + len);\n\t\t\tconst val = other.getValueInRange2(startPosition, endPosition);\n\n\t\t\toffset += len;\n\t\t\treturn str === val;\n\t\t});\n\n\t\treturn ret;\n\t}\n\n\tpublic getOffsetAt(lineNumber: number, column: number): number {\n\t\tlet leftLen = 0; // inorder\n\n\t\tlet x = this.root;\n\n\t\twhile (x !== SENTINEL) {\n\t\t\tif (x.left !== SENTINEL && x.lf_left + 1 >= lineNumber) {\n\t\t\t\tx = x.left;\n\t\t\t} else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {\n\t\t\t\tleftLen += x.size_left;\n\t\t\t\t// lineNumber >= 2\n\t\t\t\tconst accumualtedValInCurrentIndex = this.getAccumulatedValue(\n\t\t\t\t\tx,\n\t\t\t\t\tlineNumber - x.lf_left - 2,\n\t\t\t\t);\n\t\t\t\treturn (leftLen += accumualtedValInCurrentIndex + column - 1);\n\t\t\t} else {\n\t\t\t\tlineNumber -= x.lf_left + x.piece.lineFeedCnt;\n\t\t\t\tleftLen += x.size_left + x.piece.length;\n\t\t\t\tx = x.right;\n\t\t\t}\n\t\t}\n\n\t\treturn leftLen;\n\t}\n\n\tpublic getPositionAt(offset: number): Position {\n\t\toffset = Math.floor(offset);\n\t\toffset = Math.max(0, offset);\n\n\t\tlet x = this.root;\n\t\tlet lfCnt = 0;\n\t\tconst originalOffset = offset;\n\n\t\twhile (x !== SENTINEL) {\n\t\t\tif (x.size_left !== 0 && x.size_left >= offset) {\n\t\t\t\tx = x.left;\n\t\t\t} else if (x.size_left + x.piece.length >= offset) {\n\t\t\t\tconst out = this.getIndexOf(x, offset - x.size_left);\n\n\t\t\t\tlfCnt += x.lf_left + out.index;\n\n\t\t\t\tif (out.index === 0) {\n\t\t\t\t\tconst lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n\t\t\t\t\tconst column = originalOffset - lineStartOffset;\n\t\t\t\t\treturn new Position(lfCnt + 1, column + 1);\n\t\t\t\t}\n\n\t\t\t\treturn new Position(lfCnt + 1, out.remainder + 1);\n\t\t\t} else {\n\t\t\t\toffset -= x.size_left + x.piece.length;\n\t\t\t\tlfCnt += x.lf_left + x.piece.lineFeedCnt;\n\n\t\t\t\tif (x.right === SENTINEL) {\n\t\t\t\t\t// last node\n\t\t\t\t\tconst lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n\t\t\t\t\tconst column = originalOffset - offset - lineStartOffset;\n\t\t\t\t\treturn new Position(lfCnt + 1, column + 1);\n\t\t\t\t} else {\n\t\t\t\t\tx = x.right;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Position(1, 1);\n\t}\n\n\tpublic getValueInRange(range: Range, eol?: string): string {\n\t\tif (\n\t\t\trange.startLineNumber === range.endLineNumber &&\n\t\t\trange.startColumn === range.endColumn\n\t\t) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tconst startPosition = this.nodeAt2(\n\t\t\trange.startLineNumber,\n\t\t\trange.startColumn,\n\t\t);\n\t\tconst endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);\n\n\t\tconst value = this.getValueInRange2(startPosition, endPosition);\n\t\tif (eol) {\n\t\t\tif (eol !== this._EOL || !this._EOLNormalized) {\n\t\t\t\treturn value.replace(/\\r\\n|\\r|\\n/g, eol);\n\t\t\t}\n\n\t\t\tif (eol === this.getEOL() && this._EOLNormalized) {\n\t\t\t\tif (eol === \"\\r\\n\") {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\treturn value.replace(/\\r\\n|\\r|\\n/g, eol);\n\t\t}\n\t\treturn value;\n\t}\n\n\tpublic getValueInRange2(\n\t\tstartPosition: NodePosition,\n\t\tendPosition: NodePosition,\n\t): string {\n\t\tif (startPosition.node === endPosition.node) {\n\t\t\tconst node = startPosition.node;\n\t\t\tconst buffer = this._buffers[node.piece.bufferIndex].buffer;\n\t\t\tconst startOffset = this.offsetInBuffer(\n\t\t\t\tnode.piece.bufferIndex,\n\t\t\t\tnode.piece.start,\n\t\t\t);\n\t\t\treturn buffer.substring(\n\t\t\t\tstartOffset + startPosition.remainder,\n\t\t\t\tstartOffset + endPosition.remainder,\n\t\t\t);\n\t\t}\n\n\t\tlet x = startPosition.node;\n\t\tconst buffer = this._buffers[x.piece.bufferIndex].buffer;\n\t\tconst startOffset = this.offsetInBuffer(\n\t\t\tx.piece.bufferIndex,\n\t\t\tx.piece.start,\n\t\t);\n\t\tlet ret = buffer.substring(\n\t\t\tstartOffset + startPosition.remainder,\n\t\t\tstartOffset + x.piece.length,\n\t\t);\n\n\t\tx = x.next();\n\t\twhile (x !== SENTINEL) {\n\t\t\tconst buffer = this._buffers[x.piece.bufferIndex].buffer;\n\t\t\tconst startOffset = this.offsetInBuffer(\n\t\t\t\tx.piece.bufferIndex,\n\t\t\t\tx.piece.start,\n\t\t\t);\n\n\t\t\tif (x === endPosition.node) {\n\t\t\t\tret += buffer.substring(\n\t\t\t\t\tstartOffset,\n\t\t\t\t\tstartOffset + endPosition.remainder,\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tret += buffer.substr(startOffset, x.piece.length);\n\t\t\t}\n\n\t\t\tx = x.next();\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tpublic getLinesContent(): string[] {\n\t\tconst lines: string[] = [];\n\t\tlet linesLength = 0;\n\t\tlet currentLine = \"\";\n\t\tlet danglingCR = false;\n\n\t\tthis.iterate(this.root, (node) => {\n\t\t\tif (node === SENTINEL) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tconst piece = node.piece;\n\t\t\tlet pieceLength = piece.length;\n\t\t\tif (pieceLength === 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tconst buffer = this._buffers[piece.bufferIndex].buffer;\n\t\t\tconst lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n\n\t\t\tconst pieceStartLine = piece.start.line;\n\t\t\tconst pieceEndLine = piece.end.line;\n\t\t\tlet pieceStartOffset =\n\t\t\t\tlineStarts[pieceStartLine] + piece.start.column;\n\n\t\t\tif (danglingCR) {\n\t\t\t\tif (buffer.charCodeAt(pieceStartOffset) === CharCode.LineFeed) {\n\t\t\t\t\t// pretend the \\n was in the previous piece..\n\t\t\t\t\tpieceStartOffset++;\n\t\t\t\t\tpieceLength--;\n\t\t\t\t}\n\t\t\t\tlines[linesLength++] = currentLine;\n\t\t\t\tcurrentLine = \"\";\n\t\t\t\tdanglingCR = false;\n\t\t\t\tif (pieceLength === 0) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (pieceStartLine === pieceEndLine) {\n\t\t\t\t// this piece has no new lines\n\t\t\t\tif (\n\t\t\t\t\t!this._EOLNormalized &&\n\t\t\t\t\tbuffer.charCodeAt(pieceStartOffset + pieceLength - 1) ===\n\t\t\t\t\t\tCharCode.CarriageReturn\n\t\t\t\t) {\n\t\t\t\t\tdanglingCR = true;\n\t\t\t\t\tcurrentLine += buffer.substr(\n\t\t\t\t\t\tpieceStartOffset,\n\t\t\t\t\t\tpieceLength - 1,\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tcurrentLine += buffer.substr(pieceStartOffset, pieceLength);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// add the text before the first line start in this piece\n\t\t\tcurrentLine += this._EOLNormalized\n\t\t\t\t? buffer.substring(\n\t\t\t\t\t\tpieceStartOffset,\n\t\t\t\t\t\tMath.max(\n\t\t\t\t\t\t\tpieceStartOffset,\n\t\t\t\t\t\t\tlineStarts[pieceStartLine + 1] - this._EOLLength,\n\t\t\t\t\t\t),\n\t\t\t\t\t)\n\t\t\t\t: buffer\n\t\t\t\t\t\t.substring(\n\t\t\t\t\t\t\tpieceStartOffset,\n\t\t\t\t\t\t\tlineStarts[pieceStartLine + 1],\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.replace(/(\\r\\n|\\r|\\n)$/, \"\");\n\t\t\tlines[linesLength++] = currentLine;\n\n\t\t\tfor (let line = pieceStartLine + 1; line < pieceEndLine; line++) {\n\t\t\t\tcurrentLine = this._EOLNormalized\n\t\t\t\t\t? buffer.substring(\n\t\t\t\t\t\t\tlineStarts[line],\n\t\t\t\t\t\t\tlineStarts[line + 1] - this._EOLLength,\n\t\t\t\t\t\t)\n\t\t\t\t\t: buffer\n\t\t\t\t\t\t\t.substring(lineStarts[line], lineStarts[line + 1])\n\t\t\t\t\t\t\t.replace(/(\\r\\n|\\r|\\n)$/, \"\");\n\t\t\t\tlines[linesLength++] = currentLine;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t!this._EOLNormalized &&\n\t\t\t\tbuffer.charCodeAt(\n\t\t\t\t\tlineStarts[pieceEndLine] + piece.end.column - 1,\n\t\t\t\t) === CharCode.CarriageReturn\n\t\t\t) {\n\t\t\t\tdanglingCR = true;\n\t\t\t\tif (piece.end.column === 0) {\n\t\t\t\t\t// The last line ended with a \\r, let's undo the push, it will be pushed by next iteration\n\t\t\t\t\tlinesLength--;\n\t\t\t\t} else {\n\t\t\t\t\tcurrentLine = buffer.substr(\n\t\t\t\t\t\tlineStarts[pieceEndLine],\n\t\t\t\t\t\tpiece.end.column - 1,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcurrentLine = buffer.substr(\n\t\t\t\t\tlineStarts[pieceEndLine],\n\t\t\t\t\tpiece.end.column,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t});\n\n\t\tif (danglingCR) {\n\t\t\tlines[linesLength++] = currentLine;\n\t\t\tcurrentLine = \"\";\n\t\t}\n\n\t\tlines[linesLength++] = currentLine;\n\t\treturn lines;\n\t}\n\n\tpublic getLength(): number {\n\t\treturn this._length;\n\t}\n\n\tpublic getLineCount(): number {\n\t\treturn this._lineCnt;\n\t}\n\n\tpublic getLineContent(lineNumber: number): string {\n\t\tif (this._lastVisitedLine.lineNumber === lineNumber) {\n\t\t\treturn this._lastVisitedLine.value;\n\t\t}\n\n\t\tthis._lastVisitedLine.lineNumber = lineNumber;\n\n\t\tif (lineNumber === this._lineCnt) {\n\t\t\tthis._lastVisitedLine.value = this.getLineRawContent(lineNumber);\n\t\t} else if (this._EOLNormalized) {\n\t\t\tthis._lastVisitedLine.value = this.getLineRawContent(\n\t\t\t\tlineNumber,\n\t\t\t\tthis._EOLLength,\n\t\t\t);\n\t\t} else {\n\t\t\tthis._lastVisitedLine.value = this.getLineRawContent(\n\t\t\t\tlineNumber,\n\t\t\t).replace(/(\\r\\n|\\r|\\n)$/, \"\");\n\t\t}\n\n\t\treturn this._lastVisitedLine.value;\n\t}\n\n\tprivate _getCharCode(nodePos: NodePosition): number {\n\t\tif (nodePos.remainder === nodePos.node.piece.length) {\n\t\t\t// the char we want to fetch is at the head of next node.\n\t\t\tconst matchingNode = nodePos.node.next();\n\t\t\tif (!matchingNode) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tconst buffer = this._buffers[matchingNode.piece.bufferIndex];\n\t\t\tconst startOffset = this.offsetInBuffer(\n\t\t\t\tmatchingNode.piece.bufferIndex,\n\t\t\t\tmatchingNode.piece.start,\n\t\t\t);\n\t\t\treturn buffer.buffer.charCodeAt(startOffset);\n\t\t} else {\n\t\t\tconst buffer = this._buffers[nodePos.node.piece.bufferIndex];\n\t\t\tconst startOffset = this.offsetInBuffer(\n\t\t\t\tnodePos.node.piece.bufferIndex,\n\t\t\t\tnodePos.node.piece.start,\n\t\t\t);\n\t\t\tconst targetOffset = startOffset + nodePos.remainder;\n\n\t\t\treturn buffer.buffer.charCodeAt(targetOffset);\n\t\t}\n\t}\n\n\tpublic getLineCharCode(lineNumber: number, index: number): number {\n\t\tconst nodePos = this.nodeAt2(lineNumber, index + 1);\n\t\treturn this._getCharCode(nodePos);\n\t}\n\n\tpublic getLineLength(lineNumber: number): number {\n\t\tif (lineNumber === this.getLineCount()) {\n\t\t\tconst startOffset = this.getOffsetAt(lineNumber, 1);\n\t\t\treturn this.getLength() - startOffset;\n\t\t}\n\t\treturn (\n\t\t\tthis.getOffsetAt(lineNumber + 1, 1) -\n\t\t\tthis.getOffsetAt(lineNumber, 1) -\n\t\t\tthis._EOLLength\n\t\t);\n\t}\n\n\tpublic getCharCode(offset: number): number {\n\t\tconst nodePos = this.nodeAt(offset);\n\t\treturn this._getCharCode(nodePos);\n\t}\n\n\tpublic getNearestChunk(offset: number): string {\n\t\tconst nodePos = this.nodeAt(offset);\n\t\tif (nodePos.remainder === nodePos.node.piece.length) {\n\t\t\t// the offset is at the head of next node.\n\t\t\tconst matchingNode = nodePos.node.next();\n\t\t\tif (!matchingNode || matchingNode === SENTINEL) {\n\t\t\t\treturn \"\";\n\t\t\t}\n\n\t\t\tconst buffer = this._buffers[matchingNode.piece.bufferIndex];\n\t\t\tconst startOffset = this.offsetInBuffer(\n\t\t\t\tmatchingNode.piece.bufferIndex,\n\t\t\t\tmatchingNode.piece.start,\n\t\t\t);\n\t\t\treturn buffer.buffer.substring(\n\t\t\t\tstartOffset,\n\t\t\t\tstartOffset + matchingNode.piece.length,\n\t\t\t);\n\t\t} else {\n\t\t\tconst buffer = this._buffers[nodePos.node.piece.bufferIndex];\n\t\t\tconst startOffset = this.offsetInBuffer(\n\t\t\t\tnodePos.node.piece.bufferIndex,\n\t\t\t\tnodePos.node.piece.start,\n\t\t\t);\n\t\t\tconst targetOffset = startOffset + nodePos.remainder;\n\t\t\tconst targetEnd = startOffset + nodePos.node.piece.length;\n\t\t\treturn buffer.buffer.substring(targetOffset, targetEnd);\n\t\t}\n\t}\n\n\tpublic findMatchesInNode(\n\t\tnode: TreeNode,\n\t\tsearcher: Searcher,\n\t\tstartLineNumber: number,\n\t\tstartColumn: number,\n\t\tstartCursor: BufferCursor,\n\t\tendCursor: BufferCursor,\n\t\tsearchData: SearchData,\n\t\tcaptureMatches: boolean,\n\t\tlimitResultCount: number,\n\t\tresultLen: number,\n\t\tresult: FindMatch[],\n\t) {\n\t\tconst buffer = this._buffers[node.piece.bufferIndex];\n\t\tconst startOffsetInBuffer = this.offsetInBuffer(\n\t\t\tnode.piece.bufferIndex,\n\t\t\tnode.piece.start,\n\t\t);\n\t\tconst start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);\n\t\tconst end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);\n\n\t\tlet m: RegExpExecArray | null;\n\t\t// Reset regex to search from the beginning\n\t\tconst ret: BufferCursor = { line: 0, column: 0 };\n\t\tlet searchText: string;\n\t\tlet offsetInBuffer: (offset: number) => number;\n\n\t\tif (searcher._wordSeparators) {\n\t\t\tsearchText = buffer.buffer.substring(start, end);\n\t\t\toffsetInBuffer = (offset: number) => offset + start;\n\t\t\tsearcher.reset(0);\n\t\t} else {\n\t\t\tsearchText = buffer.buffer;\n\t\t\toffsetInBuffer = (offset: number) => offset;\n\t\t\tsearcher.reset(start);\n\t\t}\n\n\t\tdo {\n\t\t\tm = searcher.next(searchText);\n\n\t\t\tif (m) {\n\t\t\t\tif (offsetInBuffer(m.index) >= end) {\n\t\t\t\t\treturn resultLen;\n\t\t\t\t}\n\t\t\t\tthis.positionInBuffer(\n\t\t\t\t\tnode,\n\t\t\t\t\toffsetInBuffer(m.index) - startOffsetInBuffer,\n\t\t\t\t\tret,\n\t\t\t\t);\n\t\t\t\tconst lineFeedCnt = this.getLineFeedCnt(\n\t\t\t\t\tnode.piece.bufferIndex,\n\t\t\t\t\tstartCursor,\n\t\t\t\t\tret,\n\t\t\t\t);\n\t\t\t\tconst retStartColumn =\n\t\t\t\t\tret.line === startCursor.line\n\t\t\t\t\t\t? ret.column - startCursor.column + startColumn\n\t\t\t\t\t\t: ret.column + 1;\n\t\t\t\tconst retEndColumn = retStartColumn + m[0].length;\n\t\t\t\tresult[resultLen++] = createFindMatch(\n\t\t\t\t\tnew Range(\n\t\t\t\t\t\tstartLineNumber + lineFeedCnt,\n\t\t\t\t\t\tretStartColumn,\n\t\t\t\t\t\tstartLineNumber + lineFeedCnt,\n\t\t\t\t\t\tretEndColumn,\n\t\t\t\t\t),\n\t\t\t\t\tm,\n\t\t\t\t\tcaptureMatches,\n\t\t\t\t);\n\n\t\t\t\tif (offsetInBuffer(m.index) + m[0].length >= end) {\n\t\t\t\t\treturn resultLen;\n\t\t\t\t}\n\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\treturn resultLen;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (m);\n\n\t\treturn resultLen;\n\t}\n\n\tpublic findMatchesLineByLine(\n\t\tsearchRange: Range,\n\t\tsearchData: SearchData,\n\t\tcaptureMatches: boolean,\n\t\tlimitResultCount: number,\n\t): FindMatch[] {\n\t\tconst result: FindMatch[] = [];\n\t\tlet resultLen = 0;\n\t\tconst searcher = new Searcher(\n\t\t\tsearchData.wordSeparators,\n\t\t\tsearchData.regex,\n\t\t);\n\n\t\tlet startPosition = this.nodeAt2(\n\t\t\tsearchRange.startLineNumber,\n\t\t\tsearchRange.startColumn,\n\t\t);\n\t\tif (startPosition === null) {\n\t\t\treturn [];\n\t\t}\n\t\tconst endPosition = this.nodeAt2(\n\t\t\tsearchRange.endLineNumber,\n\t\t\tsearchRange.endColumn,\n\t\t);\n\t\tif (endPosition === null) {\n\t\t\treturn [];\n\t\t}\n\t\tlet start = this.positionInBuffer(\n\t\t\tstartPosition.node,\n\t\t\tstartPosition.remainder,\n\t\t);\n\t\tconst end = this.positionInBuffer(\n\t\t\tendPosition.node,\n\t\t\tendPosition.remainder,\n\t\t);\n\n\t\tif (startPosition.node === endPosition.node) {\n\t\t\tthis.findMatchesInNode(\n\t\t\t\tstartPosition.node,\n\t\t\t\tsearcher,\n\t\t\t\tsearchRange.startLineNumber,\n\t\t\t\tsearchRange.startColumn,\n\t\t\t\tstart,\n\t\t\t\tend,\n\t\t\t\tsearchData,\n\t\t\t\tcaptureMatches,\n\t\t\t\tlimitResultCount,\n\t\t\t\tresultLen,\n\t\t\t\tresult,\n\t\t\t);\n\t\t\treturn result;\n\t\t}\n\n\t\tlet startLineNumber = searchRange.startLineNumber;\n\n\t\tlet currentNode = startPosition.node;\n\t\twhile (currentNode !== endPosition.node) {\n\t\t\tconst lineBreakCnt = this.getLineFeedCnt(\n\t\t\t\tcurrentNode.piece.bufferIndex,\n\t\t\t\tstart,\n\t\t\t\tcurrentNode.piece.end,\n\t\t\t);\n\n\t\t\tif (lineBreakCnt >= 1) {\n\t\t\t\t// last line break position\n\t\t\t\tconst lineStarts =\n\t\t\t\t\tthis._buffers[currentNode.piece.bufferIndex].lineStarts;\n\t\t\t\tconst startOffsetInBuffer = this.offsetInBuffer(\n\t\t\t\t\tcurrentNode.piece.bufferIndex,\n\t\t\t\t\tcurrentNode.piece.start,\n\t\t\t\t);\n\t\t\t\tconst nextLineStartOffset =\n\t\t\t\t\tlineStarts[start.line + lineBreakCnt];\n\t\t\t\tconst startColumn =\n\t\t\t\t\tstartLineNumber === searchRange.startLineNumber\n\t\t\t\t\t\t? searchRange.startColumn\n\t\t\t\t\t\t: 1;\n\t\t\t\tresultLen = this.findMatchesInNode(\n\t\t\t\t\tcurrentNode,\n\t\t\t\t\tsearcher,\n\t\t\t\t\tstartLineNumber,\n\t\t\t\t\tstartColumn,\n\t\t\t\t\tstart,\n\t\t\t\t\tthis.positionInBuffer(\n\t\t\t\t\t\tcurrentNode,\n\t\t\t\t\t\tnextLineStartOffset - startOffsetInBuffer,\n\t\t\t\t\t),\n\t\t\t\t\tsearchData,\n\t\t\t\t\tcaptureMatches,\n\t\t\t\t\tlimitResultCount,\n\t\t\t\t\tresultLen,\n\t\t\t\t\tresult,\n\t\t\t\t);\n\n\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tstartLineNumber += lineBreakCnt;\n\t\t\t}\n\n\t\t\tconst startColumn =\n\t\t\t\tstartLineNumber === searchRange.startLineNumber\n\t\t\t\t\t? searchRange.startColumn - 1\n\t\t\t\t\t: 0;\n\t\t\t// search for the remaining content\n\t\t\tif (startLineNumber === searchRange.endLineNumber) {\n\t\t\t\tconst text = this.getLineContent(startLineNumber).substring(\n\t\t\t\t\tstartColumn,\n\t\t\t\t\tsearchRange.endColumn - 1,\n\t\t\t\t);\n\t\t\t\tresultLen = this._findMatchesInLine(\n\t\t\t\t\tsearchData,\n\t\t\t\t\tsearcher,\n\t\t\t\t\ttext,\n\t\t\t\t\tsearchRange.endLineNumber,\n\t\t\t\t\tstartColumn,\n\t\t\t\t\tresultLen,\n\t\t\t\t\tresult,\n\t\t\t\t\tcaptureMatches,\n\t\t\t\t\tlimitResultCount,\n\t\t\t\t);\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tresultLen = this._findMatchesInLine(\n\t\t\t\tsearchData,\n\t\t\t\tsearcher,\n\t\t\t\tthis.getLineContent(startLineNumber).substr(startColumn),\n\t\t\t\tstartLineNumber,\n\t\t\t\tstartColumn,\n\t\t\t\tresultLen,\n\t\t\t\tresult,\n\t\t\t\tcaptureMatches,\n\t\t\t\tlimitResultCount,\n\t\t\t);\n\n\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tstartLineNumber++;\n\t\t\tstartPosition = this.nodeAt2(startLineNumber, 1);\n\t\t\tcurrentNode = startPosition.node;\n\t\t\tstart = this.positionInBuffer(\n\t\t\t\tstartPosition.node,\n\t\t\t\tstartPosition.remainder,\n\t\t\t);\n\t\t}\n\n\t\tif (startLineNumber === searchRange.endLineNumber) {\n\t\t\tconst startColumn =\n\t\t\t\tstartLineNumber === searchRange.startLineNumber\n\t\t\t\t\t? searchRange.startColumn - 1\n\t\t\t\t\t: 0;\n\t\t\tconst text = this.getLineContent(startLineNumber).substring(\n\t\t\t\tstartColumn,\n\t\t\t\tsearchRange.endColumn - 1,\n\t\t\t);\n\t\t\tresultLen = this._findMatchesInLine(\n\t\t\t\tsearchData,\n\t\t\t\tsearcher,\n\t\t\t\ttext,\n\t\t\t\tsearchRange.endLineNumber,\n\t\t\t\tstartColumn,\n\t\t\t\tresultLen,\n\t\t\t\tresult,\n\t\t\t\tcaptureMatches,\n\t\t\t\tlimitResultCount,\n\t\t\t);\n\t\t\treturn result;\n\t\t}\n\n\t\tconst startColumn =\n\t\t\tstartLineNumber === searchRange.startLineNumber\n\t\t\t\t? searchRange.startColumn\n\t\t\t\t: 1;\n\t\tresultLen = this.findMatchesInNode(\n\t\t\tendPosition.node,\n\t\t\tsearcher,\n\t\t\tstartLineNumber,\n\t\t\tstartColumn,\n\t\t\tstart,\n\t\t\tend,\n\t\t\tsearchData,\n\t\t\tcaptureMatches,\n\t\t\tlimitResultCount,\n\t\t\tresultLen,\n\t\t\tresult,\n\t\t);\n\t\treturn result;\n\t}\n\n\tprivate _findMatchesInLine(\n\t\tsearchData: SearchData,\n\t\tsearcher: Searcher,\n\t\ttext: string,\n\t\tlineNumber: number,\n\t\tdeltaOffset: number,\n\t\tresultLen: number,\n\t\tresult: FindMatch[],\n\t\tcaptureMatches: boolean,\n\t\tlimitResultCount: number,\n\t): number {\n\t\tconst wordSeparators = searchData.wordSeparators;\n\t\tif (!captureMatches && searchData.simpleSearch) {\n\t\t\tconst searchString = searchData.simpleSearch;\n\t\t\tconst searchStringLen = searchString.length;\n\t\t\tconst textLength = text.length;\n\n\t\t\tlet lastMatchIndex = -searchStringLen;\n\t\t\twhile (\n\t\t\t\t(lastMatchIndex = text.indexOf(\n\t\t\t\t\tsearchString,\n\t\t\t\t\tlastMatchIndex + searchStringLen,\n\t\t\t\t)) !== -1\n\t\t\t) {\n\t\t\t\tif (\n\t\t\t\t\t!wordSeparators ||\n\t\t\t\t\tisValidMatch(\n\t\t\t\t\t\twordSeparators,\n\t\t\t\t\t\ttext,\n\t\t\t\t\t\ttextLength,\n\t\t\t\t\t\tlastMatchIndex,\n\t\t\t\t\t\tsearchStringLen,\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tresult[resultLen++] = new FindMatch(\n\t\t\t\t\t\tnew Range(\n\t\t\t\t\t\t\tlineNumber,\n\t\t\t\t\t\t\tlastMatchIndex + 1 + deltaOffset,\n\t\t\t\t\t\t\tlineNumber,\n\t\t\t\t\t\t\tlastMatchIndex + 1 + searchStringLen + deltaOffset,\n\t\t\t\t\t\t),\n\t\t\t\t\t\tnull,\n\t\t\t\t\t);\n\t\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\t\treturn resultLen;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn resultLen;\n\t\t}\n\n\t\tlet m: RegExpExecArray | null;\n\t\t// Reset regex to search from the beginning\n\t\tsearcher.reset(0);\n\t\tdo {\n\t\t\tm = searcher.next(text);\n\t\t\tif (m) {\n\t\t\t\tresult[resultLen++] = createFindMatch(\n\t\t\t\t\tnew Range(\n\t\t\t\t\t\tlineNumber,\n\t\t\t\t\t\tm.index + 1 + deltaOffset,\n\t\t\t\t\t\tlineNumber,\n\t\t\t\t\t\tm.index + 1 + m[0].length + deltaOffset,\n\t\t\t\t\t),\n\t\t\t\t\tm,\n\t\t\t\t\tcaptureMatches,\n\t\t\t\t);\n\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\treturn resultLen;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (m);\n\t\treturn resultLen;\n\t}\n\n\t// #endregion\n\n\t// #region Piece Table\n\tpublic insert(offset: number, value: string, eolNormalized = false): void {\n\t\tthis._EOLNormalized = this._EOLNormalized && eolNormalized;\n\t\tthis._lastVisitedLine.lineNumber = 0;\n\t\tthis._lastVisitedLine.value = \"\";\n\n\t\tif (this.root !== SENTINEL) {\n\t\t\tconst { node, remainder, nodeStartOffset } = this.nodeAt(offset);\n\t\t\tconst piece = node.piece;\n\t\t\tconst bufferIndex = piece.bufferIndex;\n\t\t\tconst insertPosInBuffer = this.positionInBuffer(node, remainder);\n\t\t\tif (\n\t\t\t\tnode.piece.bufferIndex === 0 &&\n\t\t\t\tpiece.end.line === this._lastChangeBufferPos.line &&\n\t\t\t\tpiece.end.column === this._lastChangeBufferPos.column &&\n\t\t\t\tnodeStartOffset + piece.length === offset &&\n\t\t\t\tvalue.length < AverageBufferSize\n\t\t\t) {\n\t\t\t\t// changed buffer\n\t\t\t\tthis.appendToNode(node, value);\n\t\t\t\tthis.computeBufferMetadata();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (nodeStartOffset === offset) {\n\t\t\t\tthis.insertContentToNodeLeft(value, node);\n\t\t\t\tthis._searchCache.validate(offset);\n\t\t\t} else if (nodeStartOffset + node.piece.length > offset) {\n\t\t\t\t// we are inserting into the middle of a node.\n\t\t\t\tconst nodesToDel: TreeNode[] = [];\n\t\t\t\tlet newRightPiece = new Piece(\n\t\t\t\t\tpiece.bufferIndex,\n\t\t\t\t\tinsertPosInBuffer,\n\t\t\t\t\tpiece.end,\n\t\t\t\t\tthis.getLineFeedCnt(\n\t\t\t\t\t\tpiece.bufferIndex,\n\t\t\t\t\t\tinsertPosInBuffer,\n\t\t\t\t\t\tpiece.end,\n\t\t\t\t\t),\n\t\t\t\t\tthis.offsetInBuffer(bufferIndex, piece.end) -\n\t\t\t\t\t\tthis.offsetInBuffer(bufferIndex, insertPosInBuffer),\n\t\t\t\t);\n\n\t\t\t\tif (this.shouldCheckCRLF() && this.endWithCR(value)) {\n\t\t\t\t\tconst headOfRight = this.nodeCharCodeAt(node, remainder);\n\n\t\t\t\t\tif (headOfRight === 10 /** \\n */) {\n\t\t\t\t\t\tconst newStart: BufferCursor = {\n\t\t\t\t\t\t\tline: newRightPiece.start.line + 1,\n\t\t\t\t\t\t\tcolumn: 0,\n\t\t\t\t\t\t};\n\t\t\t\t\t\tnewRightPiece = new Piece(\n\t\t\t\t\t\t\tnewRightPiece.bufferIndex,\n\t\t\t\t\t\t\tnewStart,\n\t\t\t\t\t\t\tnewRightPiece.end,\n\t\t\t\t\t\t\tthis.getLineFeedCnt(\n\t\t\t\t\t\t\t\tnewRightPiece.bufferIndex,\n\t\t\t\t\t\t\t\tnewStart,\n\t\t\t\t\t\t\t\tnewRightPiece.end,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tnewRightPiece.length - 1,\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tvalue += \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// reuse node for content before insertion point.\n\t\t\t\tif (this.shouldCheckCRLF() && this.startWithLF(value)) {\n\t\t\t\t\tconst tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);\n\t\t\t\t\tif (tailOfLeft === 13 /** \\r */) {\n\t\t\t\t\t\tconst previousPos = this.positionInBuffer(\n\t\t\t\t\t\t\tnode,\n\t\t\t\t\t\t\tremainder - 1,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tthis.deleteNodeTail(node, previousPos);\n\t\t\t\t\t\tvalue = \"\\r\" + value;\n\n\t\t\t\t\t\tif (node.piece.length === 0) {\n\t\t\t\t\t\t\tnodesToDel.push(node);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.deleteNodeTail(node, insertPosInBuffer);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.deleteNodeTail(node, insertPosInBuffer);\n\t\t\t\t}\n\n\t\t\t\tconst newPieces = this.createNewPieces(value);\n\t\t\t\tif (newRightPiece.length > 0) {\n\t\t\t\t\tthis.rbInsertRight(node, newRightPiece);\n\t\t\t\t}\n\n\t\t\t\tlet tmpNode = node;\n\t\t\t\tfor (let k = 0; k < newPieces.length; k++) {\n\t\t\t\t\ttmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n\t\t\t\t}\n\t\t\t\tthis.deleteNodes(nodesToDel);\n\t\t\t} else {\n\t\t\t\tthis.insertContentToNodeRight(value, node);\n\t\t\t}\n\t\t} else {\n\t\t\t// insert new node\n\t\t\tconst pieces = this.createNewPieces(value);\n\t\t\tlet node = this.rbInsertLeft(null, pieces[0]);\n\n\t\t\tfor (let k = 1; k < pieces.length; k++) {\n\t\t\t\tnode = this.rbInsertRight(node, pieces[k]);\n\t\t\t}\n\t\t}\n\n\t\t// todo, this is too brutal. Total line feed count should be updated the same way as lf_left.\n\t\tthis.computeBufferMetadata();\n\t}\n\n\tpublic delete(offset: number, cnt: number): void {\n\t\tthis._lastVisitedLine.lineNumber = 0;\n\t\tthis._lastVisitedLine.value = \"\";\n\n\t\tif (cnt <= 0 || this.root === SENTINEL) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst startPosition = this.nodeAt(offset);\n\t\tconst endPosition = this.nodeAt(offset + cnt);\n\t\tconst startNode = startPosition.node;\n\t\tconst endNode = endPosition.node;\n\n\t\tif (startNode === endNode) {\n\t\t\tconst startSplitPosInBuffer = this.positionInBuffer(\n\t\t\t\tstartNode,\n\t\t\t\tstartPosition.remainder,\n\t\t\t);\n\t\t\tconst endSplitPosInBuffer = this.positionInBuffer(\n\t\t\t\tstartNode,\n\t\t\t\tendPosition.remainder,\n\t\t\t);\n\n\t\t\tif (startPosition.nodeStartOffset === offset) {\n\t\t\t\tif (cnt === startNode.piece.length) {\n\t\t\t\t\t// delete node\n\t\t\t\t\tconst next = startNode.next();\n\t\t\t\t\trbDelete(this, startNode);\n\t\t\t\t\tthis.validateCRLFWithPrevNode(next);\n\t\t\t\t\tthis.computeBufferMetadata();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.deleteNodeHead(startNode, endSplitPosInBuffer);\n\t\t\t\tthis._searchCache.validate(offset);\n\t\t\t\tthis.validateCRLFWithPrevNode(startNode);\n\t\t\t\tthis.computeBufferMetadata();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tstartPosition.nodeStartOffset + startNode.piece.length ===\n\t\t\t\toffset + cnt\n\t\t\t) {\n\t\t\t\tthis.deleteNodeTail(startNode, startSplitPosInBuffer);\n\t\t\t\tthis.validateCRLFWithNextNode(startNode);\n\t\t\t\tthis.computeBufferMetadata();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// delete content in the middle, this node will be splitted to nodes\n\t\t\tthis.shrinkNode(\n\t\t\t\tstartNode,\n\t\t\t\tstartSplitPosInBuffer,\n\t\t\t\tendSplitPosInBuffer,\n\t\t\t);\n\t\t\tthis.computeBufferMetadata();\n\t\t\treturn;\n\t\t}\n\n\t\tconst nodesToDel: TreeNode[] = [];\n\n\t\tconst startSplitPosInBuffer = this.positionInBuffer(\n\t\t\tstartNode,\n\t\t\tstartPosition.remainder,\n\t\t);\n\t\tthis.deleteNodeTail(startNode, startSplitPosInBuffer);\n\t\tthis._searchCache.validate(offset);\n\t\tif (startNode.piece.length === 0) {\n\t\t\tnodesToDel.push(startNode);\n\t\t}\n\n\t\t// update last touched node\n\t\tconst endSplitPosInBuffer = this.positionInBuffer(\n\t\t\tendNode,\n\t\t\tendPosition.remainder,\n\t\t);\n\t\tthis.deleteNodeHead(endNode, endSplitPosInBuffer);\n\t\tif (endNode.piece.length === 0) {\n\t\t\tnodesToDel.push(endNode);\n\t\t}\n\n\t\t// delete nodes in between\n\t\tconst secondNode = startNode.next();\n\t\tfor (\n\t\t\tlet node = secondNode;\n\t\t\tnode !== SENTINEL && node !== endNode;\n\t\t\tnode = node.next()\n\t\t) {\n\t\t\tnodesToDel.push(node);\n\t\t}\n\n\t\tconst prev =\n\t\t\tstartNode.piece.length === 0 ? startNode.prev() : startNode;\n\t\tthis.deleteNodes(nodesToDel);\n\t\tthis.validateCRLFWithNextNode(prev);\n\t\tthis.computeBufferMetadata();\n\t}\n\n\tprivate insertContentToNodeLeft(value: string, node: TreeNode) {\n\t\t// we are inserting content to the beginning of node\n\t\tconst nodesToDel: TreeNode[] = [];\n\t\tif (\n\t\t\tthis.shouldCheckCRLF() &&\n\t\t\tthis.endWithCR(value) &&\n\t\t\tthis.startWithLF(node)\n\t\t) {\n\t\t\t// move `\\n` to new node.\n\n\t\t\tconst piece = node.piece;\n\t\t\tconst newStart: BufferCursor = {\n\t\t\t\tline: piece.start.line + 1,\n\t\t\t\tcolumn: 0,\n\t\t\t};\n\t\t\tconst nPiece = new Piece(\n\t\t\t\tpiece.bufferIndex,\n\t\t\t\tnewStart,\n\t\t\t\tpiece.end,\n\t\t\t\tthis.getLineFeedCnt(piece.bufferIndex, newStart, piece.end),\n\t\t\t\tpiece.length - 1,\n\t\t\t);\n\n\t\t\tnode.piece = nPiece;\n\n\t\t\tvalue += \"\\n\";\n\t\t\tupdateTreeMetadata(this, node, -1, -1);\n\n\t\t\tif (node.piece.length === 0) {\n\t\t\t\tnodesToDel.push(node);\n\t\t\t}\n\t\t}\n\n\t\tconst newPieces = this.createNewPieces(value);\n\t\tlet newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);\n\t\tfor (let k = newPieces.length - 2; k >= 0; k--) {\n\t\t\tnewNode = this.rbInsertLeft(newNode, newPieces[k]);\n\t\t}\n\t\tthis.validateCRLFWithPrevNode(newNode);\n\t\tthis.deleteNodes(nodesToDel);\n\t}\n\n\tprivate insertContentToNodeRight(value: string, node: TreeNode) {\n\t\t// we are inserting to the right of this node.\n\t\tif (this.adjustCarriageReturnFromNext(value, node)) {\n\t\t\t// move \\n to the new node.\n\t\t\tvalue += \"\\n\";\n\t\t}\n\n\t\tconst newPieces = this.createNewPieces(value);\n\t\tconst newNode = this.rbInsertRight(node, newPieces[0]);\n\t\tlet tmpNode = newNode;\n\n\t\tfor (let k = 1; k < newPieces.length; k++) {\n\t\t\ttmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n\t\t}\n\n\t\tthis.validateCRLFWithPrevNode(newNode);\n\t}\n\n\tprivate positionInBuffer(node: TreeNode, remainder: number): BufferCursor;\n\tprivate positionInBuffer(\n\t\tnode: TreeNode,\n\t\tremainder: number,\n\t\tret: BufferCursor,\n\t): null;\n\tprivate positionInBuffer(\n\t\tnode: TreeNode,\n\t\tremainder: number,\n\t\tret?: BufferCursor,\n\t): BufferCursor | null {\n\t\tconst piece = node.piece;\n\t\tconst bufferIndex = node.piece.bufferIndex;\n\t\tconst lineStarts = this._buffers[bufferIndex].lineStarts;\n\n\t\tconst startOffset = lineStarts[piece.start.line] + piece.start.column;\n\n\t\tconst offset = startOffset + remainder;\n\n\t\t// binary search offset between startOffset and endOffset\n\t\tlet low = piece.start.line;\n\t\tlet high = piece.end.line;\n\n\t\tlet mid = 0;\n\t\tlet midStop = 0;\n\t\tlet midStart = 0;\n\n\t\twhile (low <= high) {\n\t\t\tmid = (low + (high - low) / 2) | 0;\n\t\t\tmidStart = lineStarts[mid];\n\n\t\t\tif (mid === high) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmidStop = lineStarts[mid + 1];\n\n\t\t\tif (offset < midStart) {\n\t\t\t\thigh = mid - 1;\n\t\t\t} else if (offset >= midStop) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ret) {\n\t\t\tret.line = mid;\n\t\t\tret.column = offset - midStart;\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\tline: mid,\n\t\t\tcolumn: offset - midStart,\n\t\t};\n\t}\n\n\tprivate getLineFeedCnt(\n\t\tbufferIndex: number,\n\t\tstart: BufferCursor,\n\t\tend: BufferCursor,\n\t): number {\n\t\t// we don't need to worry about start: abc\\r|\\n, or abc|\\r, or abc|\\n, or abc|\\r\\n doesn't change the fact that, there is one line break after start.\n\t\t// now let's take care of end: abc\\r|\\n, if end is in between \\r and \\n, we need to add line feed count by 1\n\t\tif (end.column === 0) {\n\t\t\treturn end.line - start.line;\n\t\t}\n\n\t\tconst lineStarts = this._buffers[bufferIndex].lineStarts;\n\t\tif (end.line === lineStarts.length - 1) {\n\t\t\t// it means, there is no \\n after end, otherwise, there will be one more lineStart.\n\t\t\treturn end.line - start.line;\n\t\t}\n\n\t\tconst nextLineStartOffset = lineStarts[end.line + 1];\n\t\tconst endOffset = lineStarts[end.line] + end.column;\n\t\tif (nextLineStartOffset > endOffset + 1) {\n\t\t\t// there are more than 1 character after end, which means it can't be \\n\n\t\t\treturn end.line - start.line;\n\t\t}\n\t\t// endOffset + 1 === nextLineStartOffset\n\t\t// character at endOffset is \\n, so we check the character before first\n\t\t// if character at endOffset is \\r, end.column is 0 and we can't get here.\n\t\tconst previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.\n\t\tconst buffer = this._buffers[bufferIndex].buffer;\n\n\t\tif (buffer.charCodeAt(previousCharOffset) === 13) {\n\t\t\treturn end.line - start.line + 1;\n\t\t} else {\n\t\t\treturn end.line - start.line;\n\t\t}\n\t}\n\n\tprivate offsetInBuffer(bufferIndex: number, cursor: BufferCursor): number {\n\t\tconst lineStarts = this._buffers[bufferIndex].lineStarts;\n\t\treturn lineStarts[cursor.line] + cursor.column;\n\t}\n\n\tprivate deleteNodes(nodes: TreeNode[]): void {\n\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\trbDelete(this, nodes[i]);\n\t\t}\n\t}\n\n\tprivate createNewPieces(text: string): Piece[] {\n\t\tif (text.length > AverageBufferSize) {\n\t\t\t// the content is large, operations like substring, charCode becomes slow\n\t\t\t// so here we split it into smaller chunks, just like what we did for CR/LF normalization\n\t\t\tconst newPieces: Piece[] = [];\n\t\t\twhile (text.length > AverageBufferSize) {\n\t\t\t\tconst lastChar = text.charCodeAt(AverageBufferSize - 1);\n\t\t\t\tlet splitText;\n\t\t\t\tif (\n\t\t\t\t\tlastChar === CharCode.CarriageReturn ||\n\t\t\t\t\t(lastChar >= 0xd800 && lastChar <= 0xdbff)\n\t\t\t\t) {\n\t\t\t\t\t// last character is \\r or a high surrogate => keep it back\n\t\t\t\t\tsplitText = text.substring(0, AverageBufferSize - 1);\n\t\t\t\t\ttext = text.substring(AverageBufferSize - 1);\n\t\t\t\t} else {\n\t\t\t\t\tsplitText = text.substring(0, AverageBufferSize);\n\t\t\t\t\ttext = text.substring(AverageBufferSize);\n\t\t\t\t}\n\n\t\t\t\tconst lineStarts = createLineStartsFast(splitText);\n\t\t\t\tnewPieces.push(\n\t\t\t\t\tnew Piece(\n\t\t\t\t\t\tthis._buffers.length /* buffer index */,\n\t\t\t\t\t\t{ line: 0, column: 0 },\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tline: lineStarts.length - 1,\n\t\t\t\t\t\t\tcolumn:\n\t\t\t\t\t\t\t\tsplitText.length -\n\t\t\t\t\t\t\t\tlineStarts[lineStarts.length - 1],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tlineStarts.length - 1,\n\t\t\t\t\t\tsplitText.length,\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t\tthis._buffers.push(new StringBuffer(splitText, lineStarts));\n\t\t\t}\n\n\t\t\tconst lineStarts = createLineStartsFast(text);\n\t\t\tnewPieces.push(\n\t\t\t\tnew Piece(\n\t\t\t\t\tthis._buffers.length /* buffer index */,\n\t\t\t\t\t{ line: 0, column: 0 },\n\t\t\t\t\t{\n\t\t\t\t\t\tline: lineStarts.length - 1,\n\t\t\t\t\t\tcolumn: text.length - lineStarts[lineStarts.length - 1],\n\t\t\t\t\t},\n\t\t\t\t\tlineStarts.length - 1,\n\t\t\t\t\ttext.length,\n\t\t\t\t),\n\t\t\t);\n\t\t\tthis._buffers.push(new StringBuffer(text, lineStarts));\n\n\t\t\treturn newPieces;\n\t\t}\n\n\t\tlet startOffset = this._buffers[0].buffer.length;\n\t\tconst lineStarts = createLineStartsFast(text, false);\n\n\t\tlet start = this._lastChangeBufferPos;\n\t\tif (\n\t\t\tthis._buffers[0].lineStarts[\n\t\t\t\tthis._buffers[0].lineStarts.length - 1\n\t\t\t] === startOffset &&\n\t\t\tstartOffset !== 0 &&\n\t\t\tthis.startWithLF(text) &&\n\t\t\tthis.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one\n\t\t) {\n\t\t\tthis._lastChangeBufferPos = {\n\t\t\t\tline: this._lastChangeBufferPos.line,\n\t\t\t\tcolumn: this._lastChangeBufferPos.column + 1,\n\t\t\t};\n\t\t\tstart = this._lastChangeBufferPos;\n\n\t\t\tfor (let i = 0; i < lineStarts.length; i++) {\n\t\t\t\tlineStarts[i] += startOffset + 1;\n\t\t\t}\n\n\t\t\tthis._buffers[0].lineStarts = (<number[]>(\n\t\t\t\tthis._buffers[0].lineStarts\n\t\t\t)).concat(<number[]>lineStarts.slice(1));\n\t\t\tthis._buffers[0].buffer += \"_\" + text;\n\t\t\tstartOffset += 1;\n\t\t} else {\n\t\t\tif (startOffset !== 0) {\n\t\t\t\tfor (let i = 0; i < lineStarts.length; i++) {\n\t\t\t\t\tlineStarts[i] += startOffset;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._buffers[0].lineStarts = (<number[]>(\n\t\t\t\tthis._buffers[0].lineStarts\n\t\t\t)).concat(<number[]>lineStarts.slice(1));\n\t\t\tthis._buffers[0].buffer += text;\n\t\t}\n\n\t\tconst endOffset = this._buffers[0].buffer.length;\n\t\tconst endIndex = this._buffers[0].lineStarts.length - 1;\n\t\tconst endColumn = endOffset - this._buffers[0].lineStarts[endIndex];\n\t\tconst endPos = { line: endIndex, column: endColumn };\n\t\tconst newPiece = new Piece(\n\t\t\t0 /** todo@peng */,\n\t\t\tstart,\n\t\t\tendPos,\n\t\t\tthis.getLineFeedCnt(0, start, endPos),\n\t\t\tendOffset - startOffset,\n\t\t);\n\t\tthis._lastChangeBufferPos = endPos;\n\t\treturn [newPiece];\n\t}\n\n\tpublic getLinesRawContent(): string {\n\t\treturn this.getContentOfSubTree(this.root);\n\t}\n\n\tpublic getLineRawContent(lineNumber: number, endOffset = 0): string {\n\t\tlet x = this.root;\n\n\t\tlet ret = \"\";\n\t\tconst cache = this._searchCache.get2(lineNumber);\n\t\tif (cache) {\n\t\t\tx = cache.node;\n\t\t\tconst prevAccumulatedValue = this.getAccumulatedValue(\n\t\t\t\tx,\n\t\t\t\tlineNumber - cache.nodeStartLineNumber - 1,\n\t\t\t);\n\t\t\tconst buffer = this._buffers[x.piece.bufferIndex].buffer;\n\t\t\tconst startOffset = this.offsetInBuffer(\n\t\t\t\tx.piece.bufferIndex,\n\t\t\t\tx.piece.start,\n\t\t\t);\n\t\t\tif (\n\t\t\t\tcache.nodeStartLineNumber + x.piece.lineFeedCnt ===\n\t\t\t\tlineNumber\n\t\t\t) {\n\t\t\t\tret = buffer.substring(\n\t\t\t\t\tstartOffset + prevAccumulatedValue,\n\t\t\t\t\tstartOffset + x.piece.length,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tconst accumulatedValue = this.getAccumulatedValue(\n\t\t\t\t\tx,\n\t\t\t\t\tlineNumber - cache.nodeStartLineNumber,\n\t\t\t\t);\n\t\t\t\treturn buffer.substring(\n\t\t\t\t\tstartOffset + prevAccumulatedValue,\n\t\t\t\t\tstartOffset + accumulatedValue - endOffset,\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tlet nodeStartOffset = 0;\n\t\t\tconst originalLineNumber = lineNumber;\n\t\t\twhile (x !== SENTINEL) {\n\t\t\t\tif (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n\t\t\t\t\tx = x.left;\n\t\t\t\t} else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n\t\t\t\t\tconst prevAccumulatedValue = this.getAccumulatedValue(\n\t\t\t\t\t\tx,\n\t\t\t\t\t\tlineNumber - x.lf_left - 2,\n\t\t\t\t\t);\n\t\t\t\t\tconst accumulatedValue = this.getAccumulatedValue(\n\t\t\t\t\t\tx,\n\t\t\t\t\t\tlineNumber - x.lf_left - 1,\n\t\t\t\t\t);\n\t\t\t\t\tconst buffer = this._buffers[x.piece.bufferIndex].buffer;\n\t\t\t\t\tconst startOffset = this.offsetInBuffer(\n\t\t\t\t\t\tx.piece.bufferIndex,\n\t\t\t\t\t\tx.piece.start,\n\t\t\t\t\t);\n\t\t\t\t\tnodeStartOffset += x.size_left;\n\t\t\t\t\tthis._searchCache.set({\n\t\t\t\t\t\tnode: x,\n\t\t\t\t\t\tnodeStartOffset,\n\t\t\t\t\t\tnodeStartLineNumber:\n\t\t\t\t\t\t\toriginalLineNumber - (lineNumber - 1 - x.lf_left),\n\t\t\t\t\t});\n\n\t\t\t\t\treturn buffer.substring(\n\t\t\t\t\t\tstartOffset + prevAccumulatedValue,\n\t\t\t\t\t\tstartOffset + accumulatedValue - endOffset,\n\t\t\t\t\t);\n\t\t\t\t} else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n\t\t\t\t\tconst prevAccumulatedValue = this.getAccumulatedValue(\n\t\t\t\t\t\tx,\n\t\t\t\t\t\tlineNumber - x.lf_left - 2,\n\t\t\t\t\t);\n\t\t\t\t\tconst buffer = this._buffers[x.piece.bufferIndex].buffer;\n\t\t\t\t\tconst startOffset = this.offsetInBuffer(\n\t\t\t\t\t\tx.piece.bufferIndex,\n\t\t\t\t\t\tx.piece.start,\n\t\t\t\t\t);\n\n\t\t\t\t\tret = buffer.substring(\n\t\t\t\t\t\tstartOffset + prevAccumulatedValue,\n\t\t\t\t\t\tstartOffset + x.piece.length,\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tlineNumber -= x.lf_left + x.piece.lineFeedCnt;\n\t\t\t\t\tnodeStartOffset += x.size_left + x.piece.length;\n\t\t\t\t\tx = x.right;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// search in order, to find the node contains end column\n\t\tx = x.next();\n\t\twhile (x !== SENTINEL) {\n\t\t\tconst buffer = this._buffers[x.piece.bufferIndex].buffer;\n\n\t\t\tif (x.piece.lineFeedCnt > 0) {\n\t\t\t\tconst accumulatedValue = this.getAccumulatedValue(x, 0);\n\t\t\t\tconst startOffset = this.offsetInBuffer(\n\t\t\t\t\tx.piece.bufferIndex,\n\t\t\t\t\tx.piece.start,\n\t\t\t\t);\n\n\t\t\t\tret += buffer.substring(\n\t\t\t\t\tstartOffset,\n\t\t\t\t\tstartOffset + accumulatedValue - endOffset,\n\t\t\t\t);\n\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\tconst startOffset = this.offsetInBuffer(\n\t\t\t\t\tx.piece.bufferIndex,\n\t\t\t\t\tx.piece.start,\n\t\t\t\t);\n\t\t\t\tret += buffer.substr(startOffset, x.piece.length);\n\t\t\t}\n\n\t\t\tx = x.next();\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tprivate computeBufferMetadata() {\n\t\tlet x = this.root;\n\n\t\tlet lfCnt = 1;\n\t\tlet len = 0;\n\n\t\twhile (x !== SENTINEL) {\n\t\t\tlfCnt += x.lf_left + x.piece.lineFeedCnt;\n\t\t\tlen += x.size_left + x.piece.length;\n\t\t\tx = x.right;\n\t\t}\n\n\t\tthis._lineCnt = lfCnt;\n\t\tthis._length = len;\n\t\tthis._searchCache.validate(this._length);\n\t}\n\n\t// #region node operations\n\tprivate getIndexOf(\n\t\tnode: TreeNode,\n\t\taccumulatedValue: number,\n\t): { index: number; remainder: number } {\n\t\tconst piece = node.piece;\n\t\tconst pos = this.positionInBuffer(node, accumulatedValue);\n\t\tconst lineCnt = pos.line - piece.start.line;\n\n\t\tif (\n\t\t\tthis.offsetInBuffer(piece.bufferIndex, piece.end) -\n\t\t\t\tthis.offsetInBuffer(piece.bufferIndex, piece.start) ===\n\t\t\taccumulatedValue\n\t\t) {\n\t\t\t// we are checking the end of this node, so a CRLF check is necessary.\n\t\t\tconst realLineCnt = this.getLineFeedCnt(\n\t\t\t\tnode.piece.bufferIndex,\n\t\t\t\tpiece.start,\n\t\t\t\tpos,\n\t\t\t);\n\t\t\tif (realLineCnt !== lineCnt) {\n\t\t\t\t// aha yes, CRLF\n\t\t\t\treturn { index: realLineCnt, remainder: 0 };\n\t\t\t}\n\t\t}\n\n\t\treturn { index: lineCnt, remainder: pos.column };\n\t}\n\n\tprivate getAccumulatedValue(node: TreeNode, index: number) {\n\t\tif (index < 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tconst piece = node.piece;\n\t\tconst lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n\t\tconst expectedLineStartIndex = piece.start.line + index + 1;\n\t\tif (expectedLineStartIndex > piece.end.line) {\n\t\t\treturn (\n\t\t\t\tlineStarts[piece.end.line] +\n\t\t\t\tpiece.end.column -\n\t\t\t\tlineStarts[piece.start.line] -\n\t\t\t\tpiece.start.column\n\t\t\t);\n\t\t} else {\n\t\t\treturn (\n\t\t\t\tlineStarts[expectedLineStartIndex] -\n\t\t\t\tlineStarts[piece.start.line] -\n\t\t\t\tpiece.start.column\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate deleteNodeTail(node: TreeNode, pos: BufferCursor) {\n\t\tconst piece = node.piece;\n\t\tconst originalLFCnt = piece.lineFeedCnt;\n\t\tconst originalEndOffset = this.offsetInBuffer(\n\t\t\tpiece.bufferIndex,\n\t\t\tpiece.end,\n\t\t);\n\n\t\tconst newEnd = pos;\n\t\tconst newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);\n\t\tconst newLineFeedCnt = this.getLineFeedCnt(\n\t\t\tpiece.bufferIndex,\n\t\t\tpiece.start,\n\t\t\tnewEnd,\n\t\t);\n\n\t\tconst lf_delta = newLineFeedCnt - originalLFCnt;\n\t\tconst size_delta = newEndOffset - originalEndOffset;\n\t\tconst newLength = piece.length + size_delta;\n\n\t\tnode.piece = new Piece(\n\t\t\tpiece.bufferIndex,\n\t\t\tpiece.start,\n\t\t\tnewEnd,\n\t\t\tnewLineFeedCnt,\n\t\t\tnewLength,\n\t\t);\n\n\t\tupdateTreeMetadata(this, node, size_delta, lf_delta);\n\t}\n\n\tprivate deleteNodeHead(node: TreeNode, pos: BufferCursor) {\n\t\tconst piece = node.piece;\n\t\tconst originalLFCnt = piece.lineFeedCnt;\n\t\tconst originalStartOffset = this.offsetInBuffer(\n\t\t\tpiece.bufferIndex,\n\t\t\tpiece.start,\n\t\t);\n\n\t\tconst newStart = pos;\n\t\tconst newLineFeedCnt = this.getLineFeedCnt(\n\t\t\tpiece.bufferIndex,\n\t\t\tnewStart,\n\t\t\tpiece.end,\n\t\t);\n\t\tconst newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);\n\t\tconst lf_delta = newLineFeedCnt - originalLFCnt;\n\t\tconst size_delta = originalStartOffset - newStartOffset;\n\t\tconst newLength = piece.length + size_delta;\n\t\tnode.piece = new Piece(\n\t\t\tpiece.bufferIndex,\n\t\t\tnewStart,\n\t\t\tpiece.end,\n\t\t\tnewLineFeedCnt,\n\t\t\tnewLength,\n\t\t);\n\n\t\tupdateTreeMetadata(this, node, size_delta, lf_delta);\n\t}\n\n\tprivate shrinkNode(node: TreeNode, start: BufferCursor, end: BufferCursor) {\n\t\tconst piece = node.piece;\n\t\tconst originalStartPos = piece.start;\n\t\tconst originalEndPos = piece.end;\n\n\t\t// old piece, originalStartPos, start\n\t\tconst oldLength = piece.length;\n\t\tconst oldLFCnt = piece.lineFeedCnt;\n\t\tconst newEnd = start;\n\t\tconst newLineFeedCnt = this.getLineFeedCnt(\n\t\t\tpiece.bufferIndex,\n\t\t\tpiece.start,\n\t\t\tnewEnd,\n\t\t);\n\t\tconst newLength =\n\t\t\tthis.offsetInBuffer(piece.bufferIndex, start) -\n\t\t\tthis.offsetInBuffer(piece.bufferIndex, originalStartPos);\n\n\t\tnode.piece = new Piece(\n\t\t\tpiece.bufferIndex,\n\t\t\tpiece.start,\n\t\t\tnewEnd,\n\t\t\tnewLineFeedCnt,\n\t\t\tnewLength,\n\t\t);\n\n\t\tupdateTreeMetadata(\n\t\t\tthis,\n\t\t\tnode,\n\t\t\tnewLength - oldLength,\n\t\t\tnewLineFeedCnt - oldLFCnt,\n\t\t);\n\n\t\t// new right piece, end, originalEndPos\n\t\tconst newPiece = new Piece(\n\t\t\tpiece.bufferIndex,\n\t\t\tend,\n\t\t\toriginalEndPos,\n\t\t\tthis.getLineFeedCnt(piece.bufferIndex, end, originalEndPos),\n\t\t\tthis.offsetInBuffer(piece.bufferIndex, originalEndPos) -\n\t\t\t\tthis.offsetInBuffer(piece.bufferIndex, end),\n\t\t);\n\n\t\tconst newNode = this.rbInsertRight(node, newPiece);\n\t\tthis.validateCRLFWithPrevNode(newNode);\n\t}\n\n\tprivate appendToNode(node: TreeNode, value: string): void {\n\t\tif (this.adjustCarriageReturnFromNext(value, node)) {\n\t\t\tvalue += \"\\n\";\n\t\t}\n\n\t\tconst hitCRLF =\n\t\t\tthis.shouldCheckCRLF() &&\n\t\t\tthis.startWithLF(value) &&\n\t\t\tthis.endWithCR(node);\n\t\tconst startOffset = this._buffers[0].buffer.length;\n\t\tthis._buffers[0].buffer += value;\n\t\tconst lineStarts = createLineStartsFast(value, false);\n\t\tfor (let i = 0; i < lineStarts.length; i++) {\n\t\t\tlineStarts[i] += startOffset;\n\t\t}\n\t\tif (hitCRLF) {\n\t\t\tconst prevStartOffset =\n\t\t\t\tthis._buffers[0].lineStarts[\n\t\t\t\t\tthis._buffers[0].lineStarts.length - 2\n\t\t\t\t];\n\t\t\t(<number[]>this._buffers[0].lineStarts).pop();\n\t\t\t// _lastChangeBufferPos is already wrong\n\t\t\tthis._lastChangeBufferPos = {\n\t\t\t\tline: this._lastChangeBufferPos.line - 1,\n\t\t\t\tcolumn: startOffset - prevStartOffset,\n\t\t\t};\n\t\t}\n\n\t\tthis._buffers[0].lineStarts = (<number[]>(\n\t\t\tthis._buffers[0].lineStarts\n\t\t)).concat(<number[]>lineStarts.slice(1));\n\t\tconst endIndex = this._buffers[0].lineStarts.length - 1;\n\t\tconst endColumn =\n\t\t\tthis._buffers[0].buffer.length -\n\t\t\tthis._buffers[0].lineStarts[endIndex];\n\t\tconst newEnd = { line: endIndex, column: endColumn };\n\t\tconst newLength = node.piece.length + value.length;\n\t\tconst oldLineFeedCnt = node.piece.lineFeedCnt;\n\t\tconst newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);\n\t\tconst lf_delta = newLineFeedCnt - oldLineFeedCnt;\n\n\t\tnode.piece = new Piece(\n\t\t\tnode.piece.bufferIndex,\n\t\t\tnode.piece.start,\n\t\t\tnewEnd,\n\t\t\tnewLineFeedCnt,\n\t\t\tnewLength,\n\t\t);\n\n\t\tthis._lastChangeBufferPos = newEnd;\n\t\tupdateTreeMetadata(this, node, value.length, lf_delta);\n\t}\n\n\tprivate nodeAt(offset: number): NodePosition {\n\t\tlet x = this.root;\n\t\tconst cache = this._searchCache.get(offset);\n\t\tif (cache) {\n\t\t\treturn {\n\t\t\t\tnode: cache.node,\n\t\t\t\tnodeStartOffset: cache.nodeStartOffset,\n\t\t\t\tremainder: offset - cache.nodeStartOffset,\n\t\t\t};\n\t\t}\n\n\t\tlet nodeStartOffset = 0;\n\n\t\twhile (x !== SENTINEL) {\n\t\t\tif (x.size_left > offset) {\n\t\t\t\tx = x.left;\n\t\t\t} else if (x.size_left + x.piece.length >= offset) {\n\t\t\t\tnodeStartOffset += x.size_left;\n\t\t\t\tconst ret = {\n\t\t\t\t\tnode: x,\n\t\t\t\t\tremainder: offset - x.size_left,\n\t\t\t\t\tnodeStartOffset,\n\t\t\t\t};\n\t\t\t\tthis._searchCache.set(ret);\n\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\toffset -= x.size_left + x.piece.length;\n\t\t\t\tnodeStartOffset += x.size_left + x.piece.length;\n\t\t\t\tx = x.right;\n\t\t\t}\n\t\t}\n\n\t\treturn null!;\n\t}\n\n\tprivate nodeAt2(lineNumber: number, column: number): NodePosition {\n\t\tlet x = this.root;\n\t\tlet nodeStartOffset = 0;\n\n\t\twhile (x !== SENTINEL) {\n\t\t\tif (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n\t\t\t\tx = x.left;\n\t\t\t} else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n\t\t\t\tconst prevAccumualtedValue = this.getAccumulatedValue(\n\t\t\t\t\tx,\n\t\t\t\t\tlineNumber - x.lf_left - 2,\n\t\t\t\t);\n\t\t\t\tconst accumulatedValue = this.getAccumulatedValue(\n\t\t\t\t\tx,\n\t\t\t\t\tlineNumber - x.lf_left - 1,\n\t\t\t\t);\n\t\t\t\tnodeStartOffset += x.size_left;\n\n\t\t\t\treturn {\n\t\t\t\t\tnode: x,\n\t\t\t\t\tremainder: Math.min(\n\t\t\t\t\t\tprevAccumualtedValue + column - 1,\n\t\t\t\t\t\taccumulatedValue,\n\t\t\t\t\t),\n\t\t\t\t\tnodeStartOffset,\n\t\t\t\t};\n\t\t\t} else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n\t\t\t\tconst prevAccumualtedValue = this.getAccumulatedValue(\n\t\t\t\t\tx,\n\t\t\t\t\tlineNumber - x.lf_left - 2,\n\t\t\t\t);\n\t\t\t\tif (prevAccumualtedValue + column - 1 <= x.piece.length) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tnode: x,\n\t\t\t\t\t\tremainder: prevAccumualtedValue + column - 1,\n\t\t\t\t\t\tnodeStartOffset,\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tcolumn -= x.piece.length - prevAccumualtedValue;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlineNumber -= x.lf_left + x.piece.lineFeedCnt;\n\t\t\t\tnodeStartOffset += x.size_left + x.piece.length;\n\t\t\t\tx = x.right;\n\t\t\t}\n\t\t}\n\n\t\t// search in order, to find the node contains position.column\n\t\tx = x.next();\n\t\twhile (x !== SENTINEL) {\n\t\t\tif (x.piece.lineFeedCnt > 0) {\n\t\t\t\tconst accumulatedValue = this.getAccumulatedValue(x, 0);\n\t\t\t\tconst nodeStartOffset = this.offsetOfNode(x);\n\t\t\t\treturn {\n\t\t\t\t\tnode: x,\n\t\t\t\t\tremainder: Math.min(column - 1, accumulatedValue),\n\t\t\t\t\tnodeStartOffset,\n\t\t\t\t};\n\t\t\t} else if (x.piece.length >= column - 1) {\n\t\t\t\tconst nodeStartOffset = this.offsetOfNode(x);\n\t\t\t\treturn {\n\t\t\t\t\tnode: x,\n\t\t\t\t\tremainder: column - 1,\n\t\t\t\t\tnodeStartOffset,\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tcolumn -= x.piece.length;\n\t\t\t}\n\n\t\t\tx = x.next();\n\t\t}\n\n\t\treturn null!;\n\t}\n\n\tprivate nodeCharCodeAt(node: TreeNode, offset: number): number {\n\t\tif (node.piece.lineFeedCnt < 1) {\n\t\t\treturn -1;\n\t\t}\n\t\tconst buffer = this._buffers[node.piece.bufferIndex];\n\t\tconst newOffset =\n\t\t\tthis.offsetInBuffer(node.piece.bufferIndex, node.piece.start) +\n\t\t\toffset;\n\t\treturn buffer.buffer.charCodeAt(newOffset);\n\t}\n\n\tprivate offsetOfNode(node: TreeNode): number {\n\t\tif (!node) {\n\t\t\treturn 0;\n\t\t}\n\t\tlet pos = node.size_left;\n\t\twhile (node !== this.root) {\n\t\t\tif (node.parent.right === node) {\n\t\t\t\tpos += node.parent.size_left + node.parent.piece.length;\n\t\t\t}\n\n\t\t\tnode = node.parent;\n\t\t}\n\n\t\treturn pos;\n\t}\n\n\t// #endregion\n\n\t// #region CRLF\n\tprivate shouldCheckCRLF() {\n\t\treturn !(this._EOLNormalized && this._EOL === \"\\n\");\n\t}\n\n\tprivate startWithLF(val: string | TreeNode): boolean {\n\t\tif (typeof val === \"string\") {\n\t\t\treturn val.charCodeAt(0) === 10;\n\t\t}\n\n\t\tif (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst piece = val.piece;\n\t\tconst lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n\t\tconst line = piece.start.line;\n\t\tconst startOffset = lineStarts[line] + piece.start.column;\n\t\tif (line === lineStarts.length - 1) {\n\t\t\t// last line, so there is no line feed at the end of this line\n\t\t\treturn false;\n\t\t}\n\t\tconst nextLineOffset = lineStarts[line + 1];\n\t\tif (nextLineOffset > startOffset + 1) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (\n\t\t\tthis._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) ===\n\t\t\t10\n\t\t);\n\t}\n\n\tprivate endWithCR(val: string | TreeNode): boolean {\n\t\tif (typeof val === \"string\") {\n\t\t\treturn val.charCodeAt(val.length - 1) === 13;\n\t\t}\n\n\t\tif (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this.nodeCharCodeAt(val, val.piece.length - 1) === 13;\n\t}\n\n\tprivate validateCRLFWithPrevNode(nextNode: TreeNode) {\n\t\tif (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {\n\t\t\tconst node = nextNode.prev();\n\t\t\tif (this.endWithCR(node)) {\n\t\t\t\tthis.fixCRLF(node, nextNode);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate validateCRLFWithNextNode(node: TreeNode) {\n\t\tif (this.shouldCheckCRLF() && this.endWithCR(node)) {\n\t\t\tconst nextNode = node.next();\n\t\t\tif (this.startWithLF(nextNode)) {\n\t\t\t\tthis.fixCRLF(node, nextNode);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate fixCRLF(prev: TreeNode, next: TreeNode) {\n\t\tconst nodesToDel: TreeNode[] = [];\n\t\t// update node\n\t\tconst lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;\n\t\tlet newEnd: BufferCursor;\n\t\tif (prev.piece.end.column === 0) {\n\t\t\t// it means, last line ends with \\r, not \\r\\n\n\t\t\tnewEnd = {\n\t\t\t\tline: prev.piece.end.line - 1,\n\t\t\t\tcolumn:\n\t\t\t\t\tlineStarts[prev.piece.end.line] -\n\t\t\t\t\tlineStarts[prev.piece.end.line - 1] -\n\t\t\t\t\t1,\n\t\t\t};\n\t\t} else {\n\t\t\t// \\r\\n\n\t\t\tnewEnd = {\n\t\t\t\tline: prev.piece.end.line,\n\t\t\t\tcolumn: prev.piece.end.column - 1,\n\t\t\t};\n\t\t}\n\n\t\tconst prevNewLength = prev.piece.length - 1;\n\t\tconst prevNewLFCnt = prev.piece.lineFeedCnt - 1;\n\t\tprev.piece = new Piece(\n\t\t\tprev.piece.bufferIndex,\n\t\t\tprev.piece.start,\n\t\t\tnewEnd,\n\t\t\tprevNewLFCnt,\n\t\t\tprevNewLength,\n\t\t);\n\n\t\tupdateTreeMetadata(this, prev, -1, -1);\n\t\tif (prev.piece.length === 0) {\n\t\t\tnodesToDel.push(prev);\n\t\t}\n\n\t\t// update nextNode\n\t\tconst newStart: BufferCursor = {\n\t\t\tline: next.piece.start.line + 1,\n\t\t\tcolumn: 0,\n\t\t};\n\t\tconst newLength = next.piece.length - 1;\n\t\tconst newLineFeedCnt = this.getLineFeedCnt(\n\t\t\tnext.piece.bufferIndex,\n\t\t\tnewStart,\n\t\t\tnext.piece.end,\n\t\t);\n\t\tnext.piece = new Piece(\n\t\t\tnext.piece.bufferIndex,\n\t\t\tnewStart,\n\t\t\tnext.piece.end,\n\t\t\tnewLineFeedCnt,\n\t\t\tnewLength,\n\t\t);\n\n\t\tupdateTreeMetadata(this, next, -1, -1);\n\t\tif (next.piece.length === 0) {\n\t\t\tnodesToDel.push(next);\n\t\t}\n\n\t\t// create new piece which contains \\r\\n\n\t\tconst pieces = this.createNewPieces(\"\\r\\n\");\n\t\tthis.rbInsertRight(prev, pieces[0]);\n\t\t// delete empty nodes\n\n\t\tfor (let i = 0; i < nodesToDel.length; i++) {\n\t\t\trbDelete(this, nodesToDel[i]);\n\t\t}\n\t}\n\n\tprivate adjustCarriageReturnFromNext(\n\t\tvalue: string,\n\t\tnode: TreeNode,\n\t): boolean {\n\t\tif (this.shouldCheckCRLF() && this.endWithCR(value)) {\n\t\t\tconst nextNode = node.next();\n\t\t\tif (this.startWithLF(nextNode)) {\n\t\t\t\t// move `\\n` forward\n\t\t\t\tvalue += \"\\n\";\n\n\t\t\t\tif (nextNode.piece.length === 1) {\n\t\t\t\t\trbDelete(this, nextNode);\n\t\t\t\t} else {\n\t\t\t\t\tconst piece = nextNode.piece;\n\t\t\t\t\tconst newStart: BufferCursor = {\n\t\t\t\t\t\tline: piece.start.line + 1,\n\t\t\t\t\t\tcolumn: 0,\n\t\t\t\t\t};\n\t\t\t\t\tconst newLength = piece.length - 1;\n\t\t\t\t\tconst newLineFeedCnt = this.getLineFeedCnt(\n\t\t\t\t\t\tpiece.bufferIndex,\n\t\t\t\t\t\tnewStart,\n\t\t\t\t\t\tpiece.end,\n\t\t\t\t\t);\n\t\t\t\t\tnextNode.piece = new Piece(\n\t\t\t\t\t\tpiece.bufferIndex,\n\t\t\t\t\t\tnewStart,\n\t\t\t\t\t\tpiece.end,\n\t\t\t\t\t\tnewLineFeedCnt,\n\t\t\t\t\t\tnewLength,\n\t\t\t\t\t);\n\n\t\t\t\t\tupdateTreeMetadata(this, nextNode, -1, -1);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t// #endregion\n\n\t// #endregion\n\n\t// #region Tree operations\n\titerate(node: TreeNode, callback: (node: TreeNode) => boolean): boolean {\n\t\tif (node === SENTINEL) {\n\t\t\treturn callback(SENTINEL);\n\t\t}\n\n\t\tconst leftRet = this.iterate(node.left, callback);\n\t\tif (!leftRet) {\n\t\t\treturn leftRet;\n\t\t}\n\n\t\treturn callback(node) && this.iterate(node.right, callback);\n\t}\n\n\tprivate getNodeContent(node: TreeNode) {\n\t\tif (node === SENTINEL) {\n\t\t\treturn \"\";\n\t\t}\n\t\tconst buffer = this._buffers[node.piece.bufferIndex];\n\t\tconst piece = node.piece;\n\t\tconst startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n\t\tconst endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n\t\tconst currentContent = buffer.buffer.substring(startOffset, endOffset);\n\t\treturn currentContent;\n\t}\n\n\tgetPieceContent(piece: Piece) {\n\t\tconst buffer = this._buffers[piece.bufferIndex];\n\t\tconst startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n\t\tconst endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n\t\tconst currentContent = buffer.buffer.substring(startOffset, endOffset);\n\t\treturn currentContent;\n\t}\n\n\t/**\n\t *      node              node\n\t *     /  \\              /  \\\n\t *    a   b    <----   a    b\n\t *                         /\n\t *                        z\n\t */\n\tprivate rbInsertRight(node: TreeNode | null, p: Piece): TreeNode {\n\t\tconst z = new TreeNode(p, NodeColor.Red);\n\t\tz.left = SENTINEL;\n\t\tz.right = SENTINEL;\n\t\tz.parent = SENTINEL;\n\t\tz.size_left = 0;\n\t\tz.lf_left = 0;\n\n\t\tconst x = this.root;\n\t\tif (x === SENTINEL) {\n\t\t\tthis.root = z;\n\t\t\tz.color = NodeColor.Black;\n\t\t} else if (node!.right === SENTINEL) {\n\t\t\tnode!.right = z;\n\t\t\tz.parent = node!;\n\t\t} else {\n\t\t\tconst nextNode = leftest(node!.right);\n\t\t\tnextNode.left = z;\n\t\t\tz.parent = nextNode;\n\t\t}\n\n\t\tfixInsert(this, z);\n\t\treturn z;\n\t}\n\n\t/**\n\t *      node              node\n\t *     /  \\              /  \\\n\t *    a   b     ---->   a    b\n\t *                       \\\n\t *                        z\n\t */\n\tprivate rbInsertLeft(node: TreeNode | null, p: Piece): TreeNode {\n\t\tconst z = new TreeNode(p, NodeColor.Red);\n\t\tz.left = SENTINEL;\n\t\tz.right = SENTINEL;\n\t\tz.parent = SENTINEL;\n\t\tz.size_left = 0;\n\t\tz.lf_left = 0;\n\n\t\tif (this.root === SENTINEL) {\n\t\t\tthis.root = z;\n\t\t\tz.color = NodeColor.Black;\n\t\t} else if (node!.left === SENTINEL) {\n\t\t\tnode!.left = z;\n\t\t\tz.parent = node!;\n\t\t} else {\n\t\t\tconst prevNode = righttest(node!.left); // a\n\t\t\tprevNode.right = z;\n\t\t\tz.parent = prevNode;\n\t\t}\n\n\t\tfixInsert(this, z);\n\t\treturn z;\n\t}\n\n\tprivate getContentOfSubTree(node: TreeNode): string {\n\t\tlet str = \"\";\n\n\t\tthis.iterate(node, (node) => {\n\t\t\tstr += this.getNodeContent(node);\n\t\t\treturn true;\n\t\t});\n\n\t\treturn str;\n\t}\n\t// #endregion\n}\n"],
  "mappings": "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",
  "names": ["buffer", "startOffset", "startColumn", "startSplitPosInBuffer", "endSplitPosInBuffer", "lineStarts", "nodeStartOffset", "node"]
}
