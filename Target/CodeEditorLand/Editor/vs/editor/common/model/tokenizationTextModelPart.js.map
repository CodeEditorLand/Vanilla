{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/model/tokenizationTextModelPart.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from \"../../../base/common/charCode.js\";\nimport {\n\tBugIndicatingError,\n\tonUnexpectedError,\n} from \"../../../base/common/errors.js\";\nimport { Emitter, Event } from \"../../../base/common/event.js\";\nimport {\n\tDisposableMap,\n\tDisposableStore,\n\tMutableDisposable,\n} from \"../../../base/common/lifecycle.js\";\nimport { countEOL } from \"../core/eolCounter.js\";\nimport { LineRange } from \"../core/lineRange.js\";\nimport { type IPosition, Position } from \"../core/position.js\";\nimport type { Range } from \"../core/range.js\";\nimport { type IWordAtPosition, getWordAtText } from \"../core/wordHelper.js\";\nimport { StandardTokenType } from \"../encodedTokenAttributes.js\";\nimport {\n\ttype IBackgroundTokenizationStore,\n\ttype IBackgroundTokenizer,\n\ttype ILanguageIdCodec,\n\ttype IState,\n\ttype ITokenizationSupport,\n\tTokenizationRegistry,\n\tTreeSitterTokenizationRegistry,\n} from \"../languages.js\";\nimport { ILanguageService } from \"../languages/language.js\";\nimport {\n\tILanguageConfigurationService,\n\ttype LanguageConfigurationServiceChangeEvent,\n\ttype ResolvedLanguageConfiguration,\n} from \"../languages/languageConfigurationRegistry.js\";\nimport type { IAttachedView } from \"../model.js\";\nimport { ITreeSitterParserService } from \"../services/treeSitterParserService.js\";\nimport type {\n\tIModelContentChangedEvent,\n\tIModelLanguageChangedEvent,\n\tIModelLanguageConfigurationChangedEvent,\n\tIModelTokensChangedEvent,\n} from \"../textModelEvents.js\";\nimport {\n\tBackgroundTokenizationState,\n\ttype ITokenizationTextModelPart,\n\ttype ITokenizeLineWithEditResult,\n\ttype LineEditWithAdditionalLines,\n} from \"../tokenizationTextModelPart.js\";\nimport type { ContiguousMultilineTokens } from \"../tokens/contiguousMultilineTokens.js\";\nimport { ContiguousMultilineTokensBuilder } from \"../tokens/contiguousMultilineTokensBuilder.js\";\nimport { ContiguousTokensStore } from \"../tokens/contiguousTokensStore.js\";\nimport type { LineTokens } from \"../tokens/lineTokens.js\";\nimport type { SparseMultilineTokens } from \"../tokens/sparseMultilineTokens.js\";\nimport { SparseTokensStore } from \"../tokens/sparseTokensStore.js\";\nimport type { BracketPairsTextModelPart } from \"./bracketPairsTextModelPart/bracketPairsImpl.js\";\nimport type { TextModel } from \"./textModel.js\";\nimport { TextModelPart } from \"./textModelPart.js\";\nimport {\n\tDefaultBackgroundTokenizer,\n\tTokenizerWithStateStoreAndTextModel,\n\tTrackingTokenizationStateStore,\n} from \"./textModelTokens.js\";\nimport {\n\tAbstractTokens,\n\tAttachedViewHandler,\n\ttype AttachedViews,\n} from \"./tokens.js\";\nimport { TreeSitterTokens } from \"./treeSitterTokens.js\";\n\nexport class TokenizationTextModelPart\n\textends TextModelPart\n\timplements ITokenizationTextModelPart\n{\n\tprivate readonly _semanticTokens: SparseTokensStore = new SparseTokensStore(\n\t\tthis._languageService.languageIdCodec,\n\t);\n\n\tprivate readonly _onDidChangeLanguage: Emitter<IModelLanguageChangedEvent> =\n\t\tthis._register(new Emitter<IModelLanguageChangedEvent>());\n\tpublic readonly onDidChangeLanguage: Event<IModelLanguageChangedEvent> =\n\t\tthis._onDidChangeLanguage.event;\n\n\tprivate readonly _onDidChangeLanguageConfiguration: Emitter<IModelLanguageConfigurationChangedEvent> =\n\t\tthis._register(new Emitter<IModelLanguageConfigurationChangedEvent>());\n\tpublic readonly onDidChangeLanguageConfiguration: Event<IModelLanguageConfigurationChangedEvent> =\n\t\tthis._onDidChangeLanguageConfiguration.event;\n\n\tprivate readonly _onDidChangeTokens: Emitter<IModelTokensChangedEvent> =\n\t\tthis._register(new Emitter<IModelTokensChangedEvent>());\n\tpublic readonly onDidChangeTokens: Event<IModelTokensChangedEvent> =\n\t\tthis._onDidChangeTokens.event;\n\n\tprivate _tokens!: AbstractTokens;\n\tprivate readonly _tokensDisposables: DisposableStore = this._register(\n\t\tnew DisposableStore(),\n\t);\n\n\tconstructor(\n\t\tprivate readonly _textModel: TextModel,\n\t\tprivate readonly _bracketPairsTextModelPart: BracketPairsTextModelPart,\n\t\tprivate _languageId: string,\n\t\tprivate readonly _attachedViews: AttachedViews,\n\t\t@ILanguageService private readonly _languageService: ILanguageService,\n\t\t@ILanguageConfigurationService private readonly _languageConfigurationService: ILanguageConfigurationService,\n\t\t@ITreeSitterParserService private readonly _treeSitterService: ITreeSitterParserService,\n\t) {\n\t\tsuper();\n\n\t\tthis._register(this._languageConfigurationService.onDidChange(e => {\n\t\t\tif (e.affects(this._languageId)) {\n\t\t\t\tthis._onDidChangeLanguageConfiguration.fire({});\n\t\t\t}\n\t\t}));\n\n\t\t// We just look at registry changes to determine whether to use tree sitter.\n\t\t// This means that removing a language from the setting will not cause a switch to textmate and will require a reload.\n\t\t// Adding a language to the setting will not need a reload, however.\n\t\tthis._register(Event.filter(TreeSitterTokenizationRegistry.onDidChange, (e) => e.changedLanguages.includes(this._languageId))(() => {\n\t\t\tthis.createPreferredTokenProvider();\n\t\t}));\n\t\tthis.createPreferredTokenProvider();\n\t}\n\n\tprivate createGrammarTokens() {\n\t\treturn this._register(\n\t\t\tnew GrammarTokens(\n\t\t\t\tthis._languageService.languageIdCodec,\n\t\t\t\tthis._textModel,\n\t\t\t\t() => this._languageId,\n\t\t\t\tthis._attachedViews,\n\t\t\t),\n\t\t);\n\t}\n\n\tprivate createTreeSitterTokens(): AbstractTokens {\n\t\treturn this._register(\n\t\t\tnew TreeSitterTokens(\n\t\t\t\tthis._treeSitterService,\n\t\t\t\tthis._languageService.languageIdCodec,\n\t\t\t\tthis._textModel,\n\t\t\t\t() => this._languageId,\n\t\t\t),\n\t\t);\n\t}\n\n\tprivate createTokens(useTreeSitter: boolean): void {\n\t\tconst needsReset = this._tokens !== undefined;\n\t\tthis._tokens?.dispose();\n\t\tthis._tokens = useTreeSitter\n\t\t\t? this.createTreeSitterTokens()\n\t\t\t: this.createGrammarTokens();\n\t\tthis._tokensDisposables.clear();\n\t\tthis._tokensDisposables.add(\n\t\t\tthis._tokens.onDidChangeTokens((e) => {\n\t\t\t\tthis._emitModelTokensChangedEvent(e);\n\t\t\t}),\n\t\t);\n\n\t\tthis._tokensDisposables.add(\n\t\t\tthis._tokens.onDidChangeBackgroundTokenizationState((e) => {\n\t\t\t\tthis._bracketPairsTextModelPart.handleDidChangeBackgroundTokenizationState();\n\t\t\t}),\n\t\t);\n\t\tif (needsReset) {\n\t\t\t// We need to reset the tokenization, as the new token provider otherwise won't have a chance to provide tokens until some action happens in the editor.\n\t\t\tthis._tokens.resetTokenization();\n\t\t}\n\t}\n\n\tprivate createPreferredTokenProvider() {\n\t\tif (TreeSitterTokenizationRegistry.get(this._languageId)) {\n\t\t\tif (!(this._tokens instanceof TreeSitterTokens)) {\n\t\t\t\tthis.createTokens(true);\n\t\t\t}\n\t\t} else if (!(this._tokens instanceof GrammarTokens)) {\n\t\t\tthis.createTokens(false);\n\t\t}\n\t}\n\n\t_hasListeners(): boolean {\n\t\treturn (\n\t\t\tthis._onDidChangeLanguage.hasListeners() ||\n\t\t\tthis._onDidChangeLanguageConfiguration.hasListeners() ||\n\t\t\tthis._onDidChangeTokens.hasListeners()\n\t\t);\n\t}\n\n\tpublic handleLanguageConfigurationServiceChange(\n\t\te: LanguageConfigurationServiceChangeEvent,\n\t): void {\n\t\tif (e.affects(this._languageId)) {\n\t\t\tthis._onDidChangeLanguageConfiguration.fire({});\n\t\t}\n\t}\n\n\tpublic handleDidChangeContent(e: IModelContentChangedEvent): void {\n\t\tif (e.isFlush) {\n\t\t\tthis._semanticTokens.flush();\n\t\t} else if (!e.isEolChange) {\n\t\t\t// We don't have to do anything on an EOL change\n\t\t\tfor (const c of e.changes) {\n\t\t\t\tconst [eolCount, firstLineLength, lastLineLength] = countEOL(\n\t\t\t\t\tc.text,\n\t\t\t\t);\n\n\t\t\t\tthis._semanticTokens.acceptEdit(\n\t\t\t\t\tc.range,\n\t\t\t\t\teolCount,\n\t\t\t\t\tfirstLineLength,\n\t\t\t\t\tlastLineLength,\n\t\t\t\t\tc.text.length > 0 ? c.text.charCodeAt(0) : CharCode.Null,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tthis._tokens.handleDidChangeContent(e);\n\t}\n\n\tpublic handleDidChangeAttached(): void {\n\t\tthis._tokens.handleDidChangeAttached();\n\t}\n\n\t/**\n\t * Includes grammar and semantic tokens.\n\t */\n\tpublic getLineTokens(lineNumber: number): LineTokens {\n\t\tthis.validateLineNumber(lineNumber);\n\t\tconst syntacticTokens = this._tokens.getLineTokens(lineNumber);\n\t\treturn this._semanticTokens.addSparseTokens(\n\t\t\tlineNumber,\n\t\t\tsyntacticTokens,\n\t\t);\n\t}\n\n\tprivate _emitModelTokensChangedEvent(e: IModelTokensChangedEvent): void {\n\t\tif (!this._textModel._isDisposing()) {\n\t\t\tthis._bracketPairsTextModelPart.handleDidChangeTokens(e);\n\t\t\tthis._onDidChangeTokens.fire(e);\n\t\t}\n\t}\n\n\t// #region Grammar Tokens\n\n\tprivate validateLineNumber(lineNumber: number): void {\n\t\tif (lineNumber < 1 || lineNumber > this._textModel.getLineCount()) {\n\t\t\tthrow new BugIndicatingError(\"Illegal value for lineNumber\");\n\t\t}\n\t}\n\n\tpublic get hasTokens(): boolean {\n\t\treturn this._tokens.hasTokens;\n\t}\n\n\tpublic resetTokenization() {\n\t\tthis._tokens.resetTokenization();\n\t}\n\n\tpublic get backgroundTokenizationState() {\n\t\treturn this._tokens.backgroundTokenizationState;\n\t}\n\n\tpublic forceTokenization(lineNumber: number): void {\n\t\tthis.validateLineNumber(lineNumber);\n\t\tthis._tokens.forceTokenization(lineNumber);\n\t}\n\n\tpublic hasAccurateTokensForLine(lineNumber: number): boolean {\n\t\tthis.validateLineNumber(lineNumber);\n\t\treturn this._tokens.hasAccurateTokensForLine(lineNumber);\n\t}\n\n\tpublic isCheapToTokenize(lineNumber: number): boolean {\n\t\tthis.validateLineNumber(lineNumber);\n\t\treturn this._tokens.isCheapToTokenize(lineNumber);\n\t}\n\n\tpublic tokenizeIfCheap(lineNumber: number): void {\n\t\tthis.validateLineNumber(lineNumber);\n\t\tthis._tokens.tokenizeIfCheap(lineNumber);\n\t}\n\n\tpublic getTokenTypeIfInsertingCharacter(\n\t\tlineNumber: number,\n\t\tcolumn: number,\n\t\tcharacter: string,\n\t): StandardTokenType {\n\t\treturn this._tokens.getTokenTypeIfInsertingCharacter(\n\t\t\tlineNumber,\n\t\t\tcolumn,\n\t\t\tcharacter,\n\t\t);\n\t}\n\n\tpublic tokenizeLineWithEdit(\n\t\tlineNumber: number,\n\t\tedit: LineEditWithAdditionalLines,\n\t): ITokenizeLineWithEditResult {\n\t\treturn this._tokens.tokenizeLineWithEdit(lineNumber, edit);\n\t}\n\n\t// #endregion\n\n\t// #region Semantic Tokens\n\n\tpublic setSemanticTokens(\n\t\ttokens: SparseMultilineTokens[] | null,\n\t\tisComplete: boolean,\n\t): void {\n\t\tthis._semanticTokens.set(tokens, isComplete);\n\n\t\tthis._emitModelTokensChangedEvent({\n\t\t\tsemanticTokensApplied: tokens !== null,\n\t\t\tranges: [\n\t\t\t\t{\n\t\t\t\t\tfromLineNumber: 1,\n\t\t\t\t\ttoLineNumber: this._textModel.getLineCount(),\n\t\t\t\t},\n\t\t\t],\n\t\t});\n\t}\n\n\tpublic hasCompleteSemanticTokens(): boolean {\n\t\treturn this._semanticTokens.isComplete();\n\t}\n\n\tpublic hasSomeSemanticTokens(): boolean {\n\t\treturn !this._semanticTokens.isEmpty();\n\t}\n\n\tpublic setPartialSemanticTokens(\n\t\trange: Range,\n\t\ttokens: SparseMultilineTokens[],\n\t): void {\n\t\tif (this.hasCompleteSemanticTokens()) {\n\t\t\treturn;\n\t\t}\n\t\tconst changedRange = this._textModel.validateRange(\n\t\t\tthis._semanticTokens.setPartial(range, tokens),\n\t\t);\n\n\t\tthis._emitModelTokensChangedEvent({\n\t\t\tsemanticTokensApplied: true,\n\t\t\tranges: [\n\t\t\t\t{\n\t\t\t\t\tfromLineNumber: changedRange.startLineNumber,\n\t\t\t\t\ttoLineNumber: changedRange.endLineNumber,\n\t\t\t\t},\n\t\t\t],\n\t\t});\n\t}\n\n\t// #endregion\n\n\t// #region Utility Methods\n\n\tpublic getWordAtPosition(_position: IPosition): IWordAtPosition | null {\n\t\tthis.assertNotDisposed();\n\n\t\tconst position = this._textModel.validatePosition(_position);\n\t\tconst lineContent = this._textModel.getLineContent(position.lineNumber);\n\t\tconst lineTokens = this.getLineTokens(position.lineNumber);\n\t\tconst tokenIndex = lineTokens.findTokenIndexAtOffset(\n\t\t\tposition.column - 1,\n\t\t);\n\n\t\t// (1). First try checking right biased word\n\t\tconst [rbStartOffset, rbEndOffset] =\n\t\t\tTokenizationTextModelPart._findLanguageBoundaries(\n\t\t\t\tlineTokens,\n\t\t\t\ttokenIndex,\n\t\t\t);\n\t\tconst rightBiasedWord = getWordAtText(\n\t\t\tposition.column,\n\t\t\tthis.getLanguageConfiguration(\n\t\t\t\tlineTokens.getLanguageId(tokenIndex),\n\t\t\t).getWordDefinition(),\n\t\t\tlineContent.substring(rbStartOffset, rbEndOffset),\n\t\t\trbStartOffset,\n\t\t);\n\t\t// Make sure the result touches the original passed in position\n\t\tif (\n\t\t\trightBiasedWord &&\n\t\t\trightBiasedWord.startColumn <= _position.column &&\n\t\t\t_position.column <= rightBiasedWord.endColumn\n\t\t) {\n\t\t\treturn rightBiasedWord;\n\t\t}\n\n\t\t// (2). Else, if we were at a language boundary, check the left biased word\n\t\tif (tokenIndex > 0 && rbStartOffset === position.column - 1) {\n\t\t\t// edge case, where `position` sits between two tokens belonging to two different languages\n\t\t\tconst [lbStartOffset, lbEndOffset] =\n\t\t\t\tTokenizationTextModelPart._findLanguageBoundaries(\n\t\t\t\t\tlineTokens,\n\t\t\t\t\ttokenIndex - 1,\n\t\t\t\t);\n\t\t\tconst leftBiasedWord = getWordAtText(\n\t\t\t\tposition.column,\n\t\t\t\tthis.getLanguageConfiguration(\n\t\t\t\t\tlineTokens.getLanguageId(tokenIndex - 1),\n\t\t\t\t).getWordDefinition(),\n\t\t\t\tlineContent.substring(lbStartOffset, lbEndOffset),\n\t\t\t\tlbStartOffset,\n\t\t\t);\n\t\t\t// Make sure the result touches the original passed in position\n\t\t\tif (\n\t\t\t\tleftBiasedWord &&\n\t\t\t\tleftBiasedWord.startColumn <= _position.column &&\n\t\t\t\t_position.column <= leftBiasedWord.endColumn\n\t\t\t) {\n\t\t\t\treturn leftBiasedWord;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate getLanguageConfiguration(\n\t\tlanguageId: string,\n\t): ResolvedLanguageConfiguration {\n\t\treturn this._languageConfigurationService.getLanguageConfiguration(\n\t\t\tlanguageId,\n\t\t);\n\t}\n\n\tprivate static _findLanguageBoundaries(\n\t\tlineTokens: LineTokens,\n\t\ttokenIndex: number,\n\t): [number, number] {\n\t\tconst languageId = lineTokens.getLanguageId(tokenIndex);\n\n\t\t// go left until a different language is hit\n\t\tlet startOffset = 0;\n\t\tfor (\n\t\t\tlet i = tokenIndex;\n\t\t\ti >= 0 && lineTokens.getLanguageId(i) === languageId;\n\t\t\ti--\n\t\t) {\n\t\t\tstartOffset = lineTokens.getStartOffset(i);\n\t\t}\n\n\t\t// go right until a different language is hit\n\t\tlet endOffset = lineTokens.getLineContent().length;\n\t\tfor (\n\t\t\tlet i = tokenIndex, tokenCount = lineTokens.getCount();\n\t\t\ti < tokenCount && lineTokens.getLanguageId(i) === languageId;\n\t\t\ti++\n\t\t) {\n\t\t\tendOffset = lineTokens.getEndOffset(i);\n\t\t}\n\n\t\treturn [startOffset, endOffset];\n\t}\n\n\tpublic getWordUntilPosition(position: IPosition): IWordAtPosition {\n\t\tconst wordAtPosition = this.getWordAtPosition(position);\n\t\tif (!wordAtPosition) {\n\t\t\treturn {\n\t\t\t\tword: \"\",\n\t\t\t\tstartColumn: position.column,\n\t\t\t\tendColumn: position.column,\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tword: wordAtPosition.word.substr(\n\t\t\t\t0,\n\t\t\t\tposition.column - wordAtPosition.startColumn,\n\t\t\t),\n\t\t\tstartColumn: wordAtPosition.startColumn,\n\t\t\tendColumn: position.column,\n\t\t};\n\t}\n\n\t// #endregion\n\n\t// #region Language Id handling\n\n\tpublic getLanguageId(): string {\n\t\treturn this._languageId;\n\t}\n\n\tpublic getLanguageIdAtPosition(lineNumber: number, column: number): string {\n\t\tconst position = this._textModel.validatePosition(\n\t\t\tnew Position(lineNumber, column),\n\t\t);\n\t\tconst lineTokens = this.getLineTokens(position.lineNumber);\n\t\treturn lineTokens.getLanguageId(\n\t\t\tlineTokens.findTokenIndexAtOffset(position.column - 1),\n\t\t);\n\t}\n\n\tpublic setLanguageId(languageId: string, source = \"api\"): void {\n\t\tif (this._languageId === languageId) {\n\t\t\t// There's nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tconst e: IModelLanguageChangedEvent = {\n\t\t\toldLanguage: this._languageId,\n\t\t\tnewLanguage: languageId,\n\t\t\tsource,\n\t\t};\n\n\t\tthis._languageId = languageId;\n\n\t\tthis._bracketPairsTextModelPart.handleDidChangeLanguage(e);\n\t\tthis._tokens.resetTokenization();\n\t\tthis.createPreferredTokenProvider();\n\t\tthis._onDidChangeLanguage.fire(e);\n\t\tthis._onDidChangeLanguageConfiguration.fire({});\n\t}\n\n\t// #endregion\n}\n\nclass GrammarTokens extends AbstractTokens {\n\tprivate _tokenizer: TokenizerWithStateStoreAndTextModel | null = null;\n\tprivate _defaultBackgroundTokenizer: DefaultBackgroundTokenizer | null =\n\t\tnull;\n\tprivate readonly _backgroundTokenizer = this._register(\n\t\tnew MutableDisposable<IBackgroundTokenizer>(),\n\t);\n\n\tprivate readonly _tokens = new ContiguousTokensStore(this._languageIdCodec);\n\tprivate _debugBackgroundTokens: ContiguousTokensStore | undefined;\n\tprivate _debugBackgroundStates:\n\t\t| TrackingTokenizationStateStore<IState>\n\t\t| undefined;\n\n\tprivate readonly _debugBackgroundTokenizer = this._register(\n\t\tnew MutableDisposable<IBackgroundTokenizer>(),\n\t);\n\n\tprivate readonly _attachedViewStates = this._register(\n\t\tnew DisposableMap<IAttachedView, AttachedViewHandler>(),\n\t);\n\n\tconstructor(\n\t\tlanguageIdCodec: ILanguageIdCodec,\n\t\ttextModel: TextModel,\n\t\tgetLanguageId: () => string,\n\t\tattachedViews: AttachedViews,\n\t) {\n\t\tsuper(languageIdCodec, textModel, getLanguageId);\n\n\t\tthis._register(\n\t\t\tTokenizationRegistry.onDidChange((e) => {\n\t\t\t\tconst languageId = this.getLanguageId();\n\t\t\t\tif (e.changedLanguages.indexOf(languageId) === -1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.resetTokenization();\n\t\t\t}),\n\t\t);\n\n\t\tthis.resetTokenization();\n\n\t\tthis._register(\n\t\t\tattachedViews.onDidChangeVisibleRanges(({ view, state }) => {\n\t\t\t\tif (state) {\n\t\t\t\t\tlet existing = this._attachedViewStates.get(view);\n\t\t\t\t\tif (!existing) {\n\t\t\t\t\t\texisting = new AttachedViewHandler(() =>\n\t\t\t\t\t\t\tthis.refreshRanges(existing!.lineRanges),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tthis._attachedViewStates.set(view, existing);\n\t\t\t\t\t}\n\t\t\t\t\texisting.handleStateChange(state);\n\t\t\t\t} else {\n\t\t\t\t\tthis._attachedViewStates.deleteAndDispose(view);\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\t}\n\n\tpublic resetTokenization(fireTokenChangeEvent = true): void {\n\t\tthis._tokens.flush();\n\t\tthis._debugBackgroundTokens?.flush();\n\t\tif (this._debugBackgroundStates) {\n\t\t\tthis._debugBackgroundStates = new TrackingTokenizationStateStore(\n\t\t\t\tthis._textModel.getLineCount(),\n\t\t\t);\n\t\t}\n\t\tif (fireTokenChangeEvent) {\n\t\t\tthis._onDidChangeTokens.fire({\n\t\t\t\tsemanticTokensApplied: false,\n\t\t\t\tranges: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfromLineNumber: 1,\n\t\t\t\t\t\ttoLineNumber: this._textModel.getLineCount(),\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\t\t}\n\n\t\tconst initializeTokenization = ():\n\t\t\t| [ITokenizationSupport, IState]\n\t\t\t| [null, null] => {\n\t\t\tif (this._textModel.isTooLargeForTokenization()) {\n\t\t\t\treturn [null, null];\n\t\t\t}\n\t\t\tconst tokenizationSupport = TokenizationRegistry.get(\n\t\t\t\tthis.getLanguageId(),\n\t\t\t);\n\t\t\tif (!tokenizationSupport) {\n\t\t\t\treturn [null, null];\n\t\t\t}\n\t\t\tlet initialState: IState;\n\t\t\ttry {\n\t\t\t\tinitialState = tokenizationSupport.getInitialState();\n\t\t\t} catch (e) {\n\t\t\t\tonUnexpectedError(e);\n\t\t\t\treturn [null, null];\n\t\t\t}\n\t\t\treturn [tokenizationSupport, initialState];\n\t\t};\n\n\t\tconst [tokenizationSupport, initialState] = initializeTokenization();\n\t\tif (tokenizationSupport && initialState) {\n\t\t\tthis._tokenizer = new TokenizerWithStateStoreAndTextModel(\n\t\t\t\tthis._textModel.getLineCount(),\n\t\t\t\ttokenizationSupport,\n\t\t\t\tthis._textModel,\n\t\t\t\tthis._languageIdCodec,\n\t\t\t);\n\t\t} else {\n\t\t\tthis._tokenizer = null;\n\t\t}\n\n\t\tthis._backgroundTokenizer.clear();\n\n\t\tthis._defaultBackgroundTokenizer = null;\n\t\tif (this._tokenizer) {\n\t\t\tconst b: IBackgroundTokenizationStore = {\n\t\t\t\tsetTokens: (tokens) => {\n\t\t\t\t\tthis.setTokens(tokens);\n\t\t\t\t},\n\t\t\t\tbackgroundTokenizationFinished: () => {\n\t\t\t\t\tif (\n\t\t\t\t\t\tthis._backgroundTokenizationState ===\n\t\t\t\t\t\tBackgroundTokenizationState.Completed\n\t\t\t\t\t) {\n\t\t\t\t\t\t// We already did a full tokenization and don't go back to progressing.\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tconst newState = BackgroundTokenizationState.Completed;\n\t\t\t\t\tthis._backgroundTokenizationState = newState;\n\t\t\t\t\tthis._onDidChangeBackgroundTokenizationState.fire();\n\t\t\t\t},\n\t\t\t\tsetEndState: (lineNumber, state) => {\n\t\t\t\t\tif (!this._tokenizer) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tconst firstInvalidEndStateLineNumber =\n\t\t\t\t\t\tthis._tokenizer.store.getFirstInvalidEndStateLineNumber();\n\t\t\t\t\t// Don't accept states for definitely valid states, the renderer is ahead of the worker!\n\t\t\t\t\tif (\n\t\t\t\t\t\tfirstInvalidEndStateLineNumber !== null &&\n\t\t\t\t\t\tlineNumber >= firstInvalidEndStateLineNumber\n\t\t\t\t\t) {\n\t\t\t\t\t\tthis._tokenizer?.store.setEndState(lineNumber, state);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t};\n\n\t\t\tif (\n\t\t\t\ttokenizationSupport &&\n\t\t\t\ttokenizationSupport.createBackgroundTokenizer &&\n\t\t\t\t!tokenizationSupport.backgroundTokenizerShouldOnlyVerifyTokens\n\t\t\t) {\n\t\t\t\tthis._backgroundTokenizer.value =\n\t\t\t\t\ttokenizationSupport.createBackgroundTokenizer(\n\t\t\t\t\t\tthis._textModel,\n\t\t\t\t\t\tb,\n\t\t\t\t\t);\n\t\t\t}\n\t\t\tif (\n\t\t\t\t!this._backgroundTokenizer.value &&\n\t\t\t\t!this._textModel.isTooLargeForTokenization()\n\t\t\t) {\n\t\t\t\tthis._backgroundTokenizer.value =\n\t\t\t\t\tthis._defaultBackgroundTokenizer =\n\t\t\t\t\t\tnew DefaultBackgroundTokenizer(this._tokenizer, b);\n\t\t\t\tthis._defaultBackgroundTokenizer.handleChanges();\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\ttokenizationSupport?.backgroundTokenizerShouldOnlyVerifyTokens &&\n\t\t\t\ttokenizationSupport.createBackgroundTokenizer\n\t\t\t) {\n\t\t\t\tthis._debugBackgroundTokens = new ContiguousTokensStore(\n\t\t\t\t\tthis._languageIdCodec,\n\t\t\t\t);\n\t\t\t\tthis._debugBackgroundStates =\n\t\t\t\t\tnew TrackingTokenizationStateStore(\n\t\t\t\t\t\tthis._textModel.getLineCount(),\n\t\t\t\t\t);\n\t\t\t\tthis._debugBackgroundTokenizer.clear();\n\t\t\t\tthis._debugBackgroundTokenizer.value =\n\t\t\t\t\ttokenizationSupport.createBackgroundTokenizer(\n\t\t\t\t\t\tthis._textModel,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsetTokens: (tokens) => {\n\t\t\t\t\t\t\t\tthis._debugBackgroundTokens?.setMultilineTokens(\n\t\t\t\t\t\t\t\t\ttokens,\n\t\t\t\t\t\t\t\t\tthis._textModel,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbackgroundTokenizationFinished() {\n\t\t\t\t\t\t\t\t// NO OP\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tsetEndState: (lineNumber, state) => {\n\t\t\t\t\t\t\t\tthis._debugBackgroundStates?.setEndState(\n\t\t\t\t\t\t\t\t\tlineNumber,\n\t\t\t\t\t\t\t\t\tstate,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthis._debugBackgroundTokens = undefined;\n\t\t\t\tthis._debugBackgroundStates = undefined;\n\t\t\t\tthis._debugBackgroundTokenizer.value = undefined;\n\t\t\t}\n\t\t}\n\n\t\tthis.refreshAllVisibleLineTokens();\n\t}\n\n\tpublic handleDidChangeAttached() {\n\t\tthis._defaultBackgroundTokenizer?.handleChanges();\n\t}\n\n\tpublic handleDidChangeContent(e: IModelContentChangedEvent): void {\n\t\tif (e.isFlush) {\n\t\t\t// Don't fire the event, as the view might not have got the text change event yet\n\t\t\tthis.resetTokenization(false);\n\t\t} else if (!e.isEolChange) {\n\t\t\t// We don't have to do anything on an EOL change\n\t\t\tfor (const c of e.changes) {\n\t\t\t\tconst [eolCount, firstLineLength] = countEOL(c.text);\n\n\t\t\t\tthis._tokens.acceptEdit(c.range, eolCount, firstLineLength);\n\t\t\t\tthis._debugBackgroundTokens?.acceptEdit(\n\t\t\t\t\tc.range,\n\t\t\t\t\teolCount,\n\t\t\t\t\tfirstLineLength,\n\t\t\t\t);\n\t\t\t}\n\t\t\tthis._debugBackgroundStates?.acceptChanges(e.changes);\n\n\t\t\tif (this._tokenizer) {\n\t\t\t\tthis._tokenizer.store.acceptChanges(e.changes);\n\t\t\t}\n\t\t\tthis._defaultBackgroundTokenizer?.handleChanges();\n\t\t}\n\t}\n\n\tprivate setTokens(tokens: ContiguousMultilineTokens[]): {\n\t\tchanges: { fromLineNumber: number; toLineNumber: number }[];\n\t} {\n\t\tconst { changes } = this._tokens.setMultilineTokens(\n\t\t\ttokens,\n\t\t\tthis._textModel,\n\t\t);\n\n\t\tif (changes.length > 0) {\n\t\t\tthis._onDidChangeTokens.fire({\n\t\t\t\tsemanticTokensApplied: false,\n\t\t\t\tranges: changes,\n\t\t\t});\n\t\t}\n\n\t\treturn { changes: changes };\n\t}\n\n\tprivate refreshAllVisibleLineTokens(): void {\n\t\tconst ranges = LineRange.joinMany(\n\t\t\t[...this._attachedViewStates].map(([_, s]) => s.lineRanges),\n\t\t);\n\t\tthis.refreshRanges(ranges);\n\t}\n\n\tprivate refreshRanges(ranges: readonly LineRange[]): void {\n\t\tfor (const range of ranges) {\n\t\t\tthis.refreshRange(\n\t\t\t\trange.startLineNumber,\n\t\t\t\trange.endLineNumberExclusive - 1,\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate refreshRange(startLineNumber: number, endLineNumber: number): void {\n\t\tif (!this._tokenizer) {\n\t\t\treturn;\n\t\t}\n\n\t\tstartLineNumber = Math.max(\n\t\t\t1,\n\t\t\tMath.min(this._textModel.getLineCount(), startLineNumber),\n\t\t);\n\t\tendLineNumber = Math.min(this._textModel.getLineCount(), endLineNumber);\n\n\t\tconst builder = new ContiguousMultilineTokensBuilder();\n\t\tconst { heuristicTokens } = this._tokenizer.tokenizeHeuristically(\n\t\t\tbuilder,\n\t\t\tstartLineNumber,\n\t\t\tendLineNumber,\n\t\t);\n\t\tconst changedTokens = this.setTokens(builder.finalize());\n\n\t\tif (heuristicTokens) {\n\t\t\t// We overrode tokens with heuristically computed ones.\n\t\t\t// Because old states might get reused (thus stopping invalidation),\n\t\t\t// we have to explicitly request the tokens for the changed ranges again.\n\t\t\tfor (const c of changedTokens.changes) {\n\t\t\t\tthis._backgroundTokenizer.value?.requestTokens(\n\t\t\t\t\tc.fromLineNumber,\n\t\t\t\t\tc.toLineNumber + 1,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tthis._defaultBackgroundTokenizer?.checkFinished();\n\t}\n\n\tpublic forceTokenization(lineNumber: number): void {\n\t\tconst builder = new ContiguousMultilineTokensBuilder();\n\t\tthis._tokenizer?.updateTokensUntilLine(builder, lineNumber);\n\t\tthis.setTokens(builder.finalize());\n\t\tthis._defaultBackgroundTokenizer?.checkFinished();\n\t}\n\n\tpublic hasAccurateTokensForLine(lineNumber: number): boolean {\n\t\tif (!this._tokenizer) {\n\t\t\treturn true;\n\t\t}\n\t\treturn this._tokenizer.hasAccurateTokensForLine(lineNumber);\n\t}\n\n\tpublic isCheapToTokenize(lineNumber: number): boolean {\n\t\tif (!this._tokenizer) {\n\t\t\treturn true;\n\t\t}\n\t\treturn this._tokenizer.isCheapToTokenize(lineNumber);\n\t}\n\n\tpublic getLineTokens(lineNumber: number): LineTokens {\n\t\tconst lineText = this._textModel.getLineContent(lineNumber);\n\t\tconst result = this._tokens.getTokens(\n\t\t\tthis._textModel.getLanguageId(),\n\t\t\tlineNumber - 1,\n\t\t\tlineText,\n\t\t);\n\t\tif (\n\t\t\tthis._debugBackgroundTokens &&\n\t\t\tthis._debugBackgroundStates &&\n\t\t\tthis._tokenizer\n\t\t) {\n\t\t\tif (\n\t\t\t\tthis._debugBackgroundStates.getFirstInvalidEndStateLineNumberOrMax() >\n\t\t\t\t\tlineNumber &&\n\t\t\t\tthis._tokenizer.store.getFirstInvalidEndStateLineNumberOrMax() >\n\t\t\t\t\tlineNumber\n\t\t\t) {\n\t\t\t\tconst backgroundResult = this._debugBackgroundTokens.getTokens(\n\t\t\t\t\tthis._textModel.getLanguageId(),\n\t\t\t\t\tlineNumber - 1,\n\t\t\t\t\tlineText,\n\t\t\t\t);\n\t\t\t\tif (\n\t\t\t\t\t!result.equals(backgroundResult) &&\n\t\t\t\t\tthis._debugBackgroundTokenizer.value\n\t\t\t\t\t\t?.reportMismatchingTokens\n\t\t\t\t) {\n\t\t\t\t\tthis._debugBackgroundTokenizer.value.reportMismatchingTokens(\n\t\t\t\t\t\tlineNumber,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic getTokenTypeIfInsertingCharacter(\n\t\tlineNumber: number,\n\t\tcolumn: number,\n\t\tcharacter: string,\n\t): StandardTokenType {\n\t\tif (!this._tokenizer) {\n\t\t\treturn StandardTokenType.Other;\n\t\t}\n\n\t\tconst position = this._textModel.validatePosition(\n\t\t\tnew Position(lineNumber, column),\n\t\t);\n\t\tthis.forceTokenization(position.lineNumber);\n\t\treturn this._tokenizer.getTokenTypeIfInsertingCharacter(\n\t\t\tposition,\n\t\t\tcharacter,\n\t\t);\n\t}\n\n\tpublic tokenizeLineWithEdit(\n\t\tlineNumber: number,\n\t\tedit: LineEditWithAdditionalLines,\n\t): ITokenizeLineWithEditResult {\n\t\tif (!this._tokenizer) {\n\t\t\treturn { mainLineTokens: null, additionalLines: null };\n\t\t}\n\t\tthis.forceTokenization(lineNumber);\n\t\treturn this._tokenizer.tokenizeLineWithEdit(lineNumber, edit);\n\t}\n\n\tpublic get hasTokens(): boolean {\n\t\treturn this._tokens.hasTokens;\n\t}\n}\n"],
  "mappings": "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",
  "names": ["tokenizationSupport", "initialState"]
}
