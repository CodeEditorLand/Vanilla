import{TreeSitterTokenizationRegistry as r}from"../languages.js";import{LineTokens as n}from"../tokens/lineTokens.js";import{StandardTokenType as a}from"../encodedTokenAttributes.js";import"./textModel.js";import"../services/treeSitterParserService.js";import"../textModelEvents.js";import{AbstractTokens as s}from"./tokens.js";import"../tokenizationTextModelPart.js";import{MutableDisposable as d}from"../../../base/common/lifecycle.js";class x extends s{constructor(e,t,i,o){super(t,i,o);this._treeSitterService=e;this._initialize()}_tokenizationSupport=null;_lastLanguageId;_tokensChangedListener=this._register(new d);_initialize(){const e=this.getLanguageId();(!this._tokenizationSupport||this._lastLanguageId!==e)&&(this._lastLanguageId=e,this._tokenizationSupport=r.get(e),this._tokensChangedListener.value=this._tokenizationSupport?.onDidChangeTokens(t=>{t.textModel===this._textModel&&this._onDidChangeTokens.fire(t.changes)}))}getLineTokens(e){const t=this._textModel.getLineContent(e);if(this._tokenizationSupport){const i=this._tokenizationSupport.tokenizeEncoded(e,this._textModel);if(i)return new n(i,t,this._languageIdCodec)}return n.createEmpty(t,this._languageIdCodec)}resetTokenization(e=!0){e&&this._onDidChangeTokens.fire({semanticTokensApplied:!1,ranges:[{fromLineNumber:1,toLineNumber:this._textModel.getLineCount()}]}),this._initialize()}handleDidChangeAttached(){}handleDidChangeContent(e){e.isFlush&&this.resetTokenization(!1)}forceTokenization(e){}hasAccurateTokensForLine(e){return!0}isCheapToTokenize(e){return!0}getTokenTypeIfInsertingCharacter(e,t,i){return a.Other}tokenizeLineWithEdit(e,t){return{mainLineTokens:null,additionalLines:null}}get hasTokens(){return this._treeSitterService.getParseResult(this._textModel)!==void 0}}export{x as TreeSitterTokens};
