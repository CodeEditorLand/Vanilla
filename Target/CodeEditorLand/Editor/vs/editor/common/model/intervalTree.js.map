{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/model/intervalTree.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { Range } from \"../core/range.js\";\nimport {\n\ttype TrackedRangeStickiness as ActualTrackedRangeStickiness,\n\tTrackedRangeStickiness,\n} from \"../model.js\";\nimport type { ModelDecorationOptions } from \"./textModel.js\";\n\n//\n// The red-black tree is based on the \"Introduction to Algorithms\" by Cormen, Leiserson and Rivest.\n//\n\nexport enum ClassName {\n\tEditorHintDecoration = \"squiggly-hint\",\n\tEditorInfoDecoration = \"squiggly-info\",\n\tEditorWarningDecoration = \"squiggly-warning\",\n\tEditorErrorDecoration = \"squiggly-error\",\n\tEditorUnnecessaryDecoration = \"squiggly-unnecessary\",\n\tEditorUnnecessaryInlineDecoration = \"squiggly-inline-unnecessary\",\n\tEditorDeprecatedInlineDecoration = \"squiggly-inline-deprecated\",\n}\n\nexport enum NodeColor {\n\tBlack = 0,\n\tRed = 1,\n}\n\nenum Constants {\n\tColorMask = 0b00000001,\n\tColorMaskInverse = 0b11111110,\n\tColorOffset = 0,\n\n\tIsVisitedMask = 0b00000010,\n\tIsVisitedMaskInverse = 0b11111101,\n\tIsVisitedOffset = 1,\n\n\tIsForValidationMask = 0b00000100,\n\tIsForValidationMaskInverse = 0b11111011,\n\tIsForValidationOffset = 2,\n\n\tStickinessMask = 0b00011000,\n\tStickinessMaskInverse = 0b11100111,\n\tStickinessOffset = 3,\n\n\tCollapseOnReplaceEditMask = 0b00100000,\n\tCollapseOnReplaceEditMaskInverse = 0b11011111,\n\tCollapseOnReplaceEditOffset = 5,\n\n\tIsMarginMask = 0b01000000,\n\tIsMarginMaskInverse = 0b10111111,\n\tIsMarginOffset = 6,\n\n\t/**\n\t * Due to how deletion works (in order to avoid always walking the right subtree of the deleted node),\n\t * the deltas for nodes can grow and shrink dramatically. It has been observed, in practice, that unless\n\t * the deltas are corrected, integer overflow will occur.\n\t *\n\t * The integer overflow occurs when 53 bits are used in the numbers, but we will try to avoid it as\n\t * a node's delta gets below a negative 30 bits number.\n\t *\n\t * MIN SMI (SMall Integer) as defined in v8.\n\t * one bit is lost for boxing/unboxing flag.\n\t * one bit is lost for sign flag.\n\t * See https://thibaultlaurens.github.io/javascript/2013/04/29/how-the-v8-engine-works/#tagged-values\n\t */\n\tMIN_SAFE_DELTA = -(1 << 30),\n\t/**\n\t * MAX SMI (SMall Integer) as defined in v8.\n\t * one bit is lost for boxing/unboxing flag.\n\t * one bit is lost for sign flag.\n\t * See https://thibaultlaurens.github.io/javascript/2013/04/29/how-the-v8-engine-works/#tagged-values\n\t */\n\tMAX_SAFE_DELTA = 1 << 30,\n}\n\nexport function getNodeColor(node: IntervalNode): NodeColor {\n\treturn (node.metadata & Constants.ColorMask) >>> Constants.ColorOffset;\n}\nfunction setNodeColor(node: IntervalNode, color: NodeColor): void {\n\tnode.metadata =\n\t\t(node.metadata & Constants.ColorMaskInverse) |\n\t\t(color << Constants.ColorOffset);\n}\nfunction getNodeIsVisited(node: IntervalNode): boolean {\n\treturn (\n\t\t(node.metadata & Constants.IsVisitedMask) >>>\n\t\t\tConstants.IsVisitedOffset ===\n\t\t1\n\t);\n}\nfunction setNodeIsVisited(node: IntervalNode, value: boolean): void {\n\tnode.metadata =\n\t\t(node.metadata & Constants.IsVisitedMaskInverse) |\n\t\t((value ? 1 : 0) << Constants.IsVisitedOffset);\n}\nfunction getNodeIsForValidation(node: IntervalNode): boolean {\n\treturn (\n\t\t(node.metadata & Constants.IsForValidationMask) >>>\n\t\t\tConstants.IsForValidationOffset ===\n\t\t1\n\t);\n}\nfunction setNodeIsForValidation(node: IntervalNode, value: boolean): void {\n\tnode.metadata =\n\t\t(node.metadata & Constants.IsForValidationMaskInverse) |\n\t\t((value ? 1 : 0) << Constants.IsForValidationOffset);\n}\nfunction getNodeIsInGlyphMargin(node: IntervalNode): boolean {\n\treturn (\n\t\t(node.metadata & Constants.IsMarginMask) >>>\n\t\t\tConstants.IsMarginOffset ===\n\t\t1\n\t);\n}\nfunction setNodeIsInGlyphMargin(node: IntervalNode, value: boolean): void {\n\tnode.metadata =\n\t\t(node.metadata & Constants.IsMarginMaskInverse) |\n\t\t((value ? 1 : 0) << Constants.IsMarginOffset);\n}\nfunction getNodeStickiness(node: IntervalNode): TrackedRangeStickiness {\n\treturn (\n\t\t(node.metadata & Constants.StickinessMask) >>>\n\t\tConstants.StickinessOffset\n\t);\n}\nfunction _setNodeStickiness(\n\tnode: IntervalNode,\n\tstickiness: TrackedRangeStickiness,\n): void {\n\tnode.metadata =\n\t\t(node.metadata & Constants.StickinessMaskInverse) |\n\t\t(stickiness << Constants.StickinessOffset);\n}\nfunction getCollapseOnReplaceEdit(node: IntervalNode): boolean {\n\treturn (\n\t\t(node.metadata & Constants.CollapseOnReplaceEditMask) >>>\n\t\t\tConstants.CollapseOnReplaceEditOffset ===\n\t\t1\n\t);\n}\nfunction setCollapseOnReplaceEdit(node: IntervalNode, value: boolean): void {\n\tnode.metadata =\n\t\t(node.metadata & Constants.CollapseOnReplaceEditMaskInverse) |\n\t\t((value ? 1 : 0) << Constants.CollapseOnReplaceEditOffset);\n}\nexport function setNodeStickiness(\n\tnode: IntervalNode,\n\tstickiness: ActualTrackedRangeStickiness,\n): void {\n\t_setNodeStickiness(node, <number>stickiness);\n}\n\nexport class IntervalNode {\n\t/**\n\t * contains binary encoded information for color, visited, isForValidation and stickiness.\n\t */\n\tpublic metadata: number;\n\n\tpublic parent: IntervalNode;\n\tpublic left: IntervalNode;\n\tpublic right: IntervalNode;\n\n\tpublic start: number;\n\tpublic end: number;\n\tpublic delta: number;\n\tpublic maxEnd: number;\n\n\tpublic id: string;\n\tpublic ownerId: number;\n\tpublic options: ModelDecorationOptions;\n\n\tpublic cachedVersionId: number;\n\tpublic cachedAbsoluteStart: number;\n\tpublic cachedAbsoluteEnd: number;\n\tpublic range: Range | null;\n\n\tconstructor(id: string, start: number, end: number) {\n\t\tthis.metadata = 0;\n\n\t\tthis.parent = this;\n\t\tthis.left = this;\n\t\tthis.right = this;\n\t\tsetNodeColor(this, NodeColor.Red);\n\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\t// FORCE_OVERFLOWING_TEST: this.delta = start;\n\t\tthis.delta = 0;\n\t\tthis.maxEnd = end;\n\n\t\tthis.id = id;\n\t\tthis.ownerId = 0;\n\t\tthis.options = null!;\n\t\tsetNodeIsForValidation(this, false);\n\t\tsetNodeIsInGlyphMargin(this, false);\n\t\t_setNodeStickiness(\n\t\t\tthis,\n\t\t\tTrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,\n\t\t);\n\t\tsetCollapseOnReplaceEdit(this, false);\n\n\t\tthis.cachedVersionId = 0;\n\t\tthis.cachedAbsoluteStart = start;\n\t\tthis.cachedAbsoluteEnd = end;\n\t\tthis.range = null;\n\n\t\tsetNodeIsVisited(this, false);\n\t}\n\n\tpublic reset(\n\t\tversionId: number,\n\t\tstart: number,\n\t\tend: number,\n\t\trange: Range,\n\t): void {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.maxEnd = end;\n\t\tthis.cachedVersionId = versionId;\n\t\tthis.cachedAbsoluteStart = start;\n\t\tthis.cachedAbsoluteEnd = end;\n\t\tthis.range = range;\n\t}\n\n\tpublic setOptions(options: ModelDecorationOptions) {\n\t\tthis.options = options;\n\t\tconst className = this.options.className;\n\t\tsetNodeIsForValidation(\n\t\t\tthis,\n\t\t\tclassName === ClassName.EditorErrorDecoration ||\n\t\t\t\tclassName === ClassName.EditorWarningDecoration ||\n\t\t\t\tclassName === ClassName.EditorInfoDecoration,\n\t\t);\n\t\tsetNodeIsInGlyphMargin(\n\t\t\tthis,\n\t\t\tthis.options.glyphMarginClassName !== null,\n\t\t);\n\t\t_setNodeStickiness(this, <number>this.options.stickiness);\n\t\tsetCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\n\t}\n\n\tpublic setCachedOffsets(\n\t\tabsoluteStart: number,\n\t\tabsoluteEnd: number,\n\t\tcachedVersionId: number,\n\t): void {\n\t\tif (this.cachedVersionId !== cachedVersionId) {\n\t\t\tthis.range = null;\n\t\t}\n\t\tthis.cachedVersionId = cachedVersionId;\n\t\tthis.cachedAbsoluteStart = absoluteStart;\n\t\tthis.cachedAbsoluteEnd = absoluteEnd;\n\t}\n\n\tpublic detach(): void {\n\t\tthis.parent = null!;\n\t\tthis.left = null!;\n\t\tthis.right = null!;\n\t}\n}\n\nexport const SENTINEL: IntervalNode = new IntervalNode(null!, 0, 0);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nsetNodeColor(SENTINEL, NodeColor.Black);\n\nexport class IntervalTree {\n\tpublic root: IntervalNode;\n\tpublic requestNormalizeDelta: boolean;\n\n\tconstructor() {\n\t\tthis.root = SENTINEL;\n\t\tthis.requestNormalizeDelta = false;\n\t}\n\n\tpublic intervalSearch(\n\t\tstart: number,\n\t\tend: number,\n\t\tfilterOwnerId: number,\n\t\tfilterOutValidation: boolean,\n\t\tcachedVersionId: number,\n\t\tonlyMarginDecorations: boolean,\n\t): IntervalNode[] {\n\t\tif (this.root === SENTINEL) {\n\t\t\treturn [];\n\t\t}\n\t\treturn intervalSearch(\n\t\t\tthis,\n\t\t\tstart,\n\t\t\tend,\n\t\t\tfilterOwnerId,\n\t\t\tfilterOutValidation,\n\t\t\tcachedVersionId,\n\t\t\tonlyMarginDecorations,\n\t\t);\n\t}\n\n\tpublic search(\n\t\tfilterOwnerId: number,\n\t\tfilterOutValidation: boolean,\n\t\tcachedVersionId: number,\n\t\tonlyMarginDecorations: boolean,\n\t): IntervalNode[] {\n\t\tif (this.root === SENTINEL) {\n\t\t\treturn [];\n\t\t}\n\t\treturn search(\n\t\t\tthis,\n\t\t\tfilterOwnerId,\n\t\t\tfilterOutValidation,\n\t\t\tcachedVersionId,\n\t\t\tonlyMarginDecorations,\n\t\t);\n\t}\n\n\t/**\n\t * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n\t */\n\tpublic collectNodesFromOwner(ownerId: number): IntervalNode[] {\n\t\treturn collectNodesFromOwner(this, ownerId);\n\t}\n\n\t/**\n\t * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n\t */\n\tpublic collectNodesPostOrder(): IntervalNode[] {\n\t\treturn collectNodesPostOrder(this);\n\t}\n\n\tpublic insert(node: IntervalNode): void {\n\t\trbTreeInsert(this, node);\n\t\tthis._normalizeDeltaIfNecessary();\n\t}\n\n\tpublic delete(node: IntervalNode): void {\n\t\trbTreeDelete(this, node);\n\t\tthis._normalizeDeltaIfNecessary();\n\t}\n\n\tpublic resolveNode(node: IntervalNode, cachedVersionId: number): void {\n\t\tconst initialNode = node;\n\t\tlet delta = 0;\n\t\twhile (node !== this.root) {\n\t\t\tif (node === node.parent.right) {\n\t\t\t\tdelta += node.parent.delta;\n\t\t\t}\n\t\t\tnode = node.parent;\n\t\t}\n\n\t\tconst nodeStart = initialNode.start + delta;\n\t\tconst nodeEnd = initialNode.end + delta;\n\t\tinitialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n\t}\n\n\tpublic acceptReplace(\n\t\toffset: number,\n\t\tlength: number,\n\t\ttextLength: number,\n\t\tforceMoveMarkers: boolean,\n\t): void {\n\t\t// Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n\n\t\t// (1) collect all nodes that are intersecting this edit as nodes of interest\n\t\tconst nodesOfInterest = searchForEditing(this, offset, offset + length);\n\n\t\t// (2) remove all nodes that are intersecting this edit\n\t\tfor (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n\t\t\tconst node = nodesOfInterest[i];\n\t\t\trbTreeDelete(this, node);\n\t\t}\n\t\tthis._normalizeDeltaIfNecessary();\n\n\t\t// (3) edit all tree nodes except the nodes of interest\n\t\tnoOverlapReplace(this, offset, offset + length, textLength);\n\t\tthis._normalizeDeltaIfNecessary();\n\n\t\t// (4) edit the nodes of interest and insert them back in the tree\n\t\tfor (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n\t\t\tconst node = nodesOfInterest[i];\n\t\t\tnode.start = node.cachedAbsoluteStart;\n\t\t\tnode.end = node.cachedAbsoluteEnd;\n\t\t\tnodeAcceptEdit(\n\t\t\t\tnode,\n\t\t\t\toffset,\n\t\t\t\toffset + length,\n\t\t\t\ttextLength,\n\t\t\t\tforceMoveMarkers,\n\t\t\t);\n\t\t\tnode.maxEnd = node.end;\n\t\t\trbTreeInsert(this, node);\n\t\t}\n\t\tthis._normalizeDeltaIfNecessary();\n\t}\n\n\tpublic getAllInOrder(): IntervalNode[] {\n\t\treturn search(this, 0, false, 0, false);\n\t}\n\n\tprivate _normalizeDeltaIfNecessary(): void {\n\t\tif (!this.requestNormalizeDelta) {\n\t\t\treturn;\n\t\t}\n\t\tthis.requestNormalizeDelta = false;\n\t\tnormalizeDelta(this);\n\t}\n}\n\n//#region Delta Normalization\nfunction normalizeDelta(T: IntervalTree): void {\n\tlet node = T.root;\n\tlet delta = 0;\n\twhile (node !== SENTINEL) {\n\t\tif (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n\t\t\t// go left\n\t\t\tnode = node.left;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n\t\t\t// go right\n\t\t\tdelta += node.delta;\n\t\t\tnode = node.right;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// handle current node\n\t\tnode.start = delta + node.start;\n\t\tnode.end = delta + node.end;\n\t\tnode.delta = 0;\n\t\trecomputeMaxEnd(node);\n\n\t\tsetNodeIsVisited(node, true);\n\n\t\t// going up from this node\n\t\tsetNodeIsVisited(node.left, false);\n\t\tsetNodeIsVisited(node.right, false);\n\t\tif (node === node.parent.right) {\n\t\t\tdelta -= node.parent.delta;\n\t\t}\n\t\tnode = node.parent;\n\t}\n\n\tsetNodeIsVisited(T.root, false);\n}\n//#endregion\n\n//#region Editing\n\nenum MarkerMoveSemantics {\n\tMarkerDefined = 0,\n\tForceMove = 1,\n\tForceStay = 2,\n}\n\nfunction adjustMarkerBeforeColumn(\n\tmarkerOffset: number,\n\tmarkerStickToPreviousCharacter: boolean,\n\tcheckOffset: number,\n\tmoveSemantics: MarkerMoveSemantics,\n): boolean {\n\tif (markerOffset < checkOffset) {\n\t\treturn true;\n\t}\n\tif (markerOffset > checkOffset) {\n\t\treturn false;\n\t}\n\tif (moveSemantics === MarkerMoveSemantics.ForceMove) {\n\t\treturn false;\n\t}\n\tif (moveSemantics === MarkerMoveSemantics.ForceStay) {\n\t\treturn true;\n\t}\n\treturn markerStickToPreviousCharacter;\n}\n\n/**\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\n * as when decorations were implemented using two markers.\n */\nexport function nodeAcceptEdit(\n\tnode: IntervalNode,\n\tstart: number,\n\tend: number,\n\ttextLength: number,\n\tforceMoveMarkers: boolean,\n): void {\n\tconst nodeStickiness = getNodeStickiness(node);\n\tconst startStickToPreviousCharacter =\n\t\tnodeStickiness ===\n\t\t\tTrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges ||\n\t\tnodeStickiness === TrackedRangeStickiness.GrowsOnlyWhenTypingBefore;\n\tconst endStickToPreviousCharacter =\n\t\tnodeStickiness === TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges ||\n\t\tnodeStickiness === TrackedRangeStickiness.GrowsOnlyWhenTypingBefore;\n\n\tconst deletingCnt = end - start;\n\tconst insertingCnt = textLength;\n\tconst commonLength = Math.min(deletingCnt, insertingCnt);\n\n\tconst nodeStart = node.start;\n\tlet startDone = false;\n\n\tconst nodeEnd = node.end;\n\tlet endDone = false;\n\n\tif (\n\t\tstart <= nodeStart &&\n\t\tnodeEnd <= end &&\n\t\tgetCollapseOnReplaceEdit(node)\n\t) {\n\t\t// This edit encompasses the entire decoration range\n\t\t// and the decoration has asked to become collapsed\n\t\tnode.start = start;\n\t\tstartDone = true;\n\t\tnode.end = start;\n\t\tendDone = true;\n\t}\n\n\t{\n\t\tconst moveSemantics = forceMoveMarkers\n\t\t\t? MarkerMoveSemantics.ForceMove\n\t\t\t: deletingCnt > 0\n\t\t\t\t? MarkerMoveSemantics.ForceStay\n\t\t\t\t: MarkerMoveSemantics.MarkerDefined;\n\t\tif (\n\t\t\t!startDone &&\n\t\t\tadjustMarkerBeforeColumn(\n\t\t\t\tnodeStart,\n\t\t\t\tstartStickToPreviousCharacter,\n\t\t\t\tstart,\n\t\t\t\tmoveSemantics,\n\t\t\t)\n\t\t) {\n\t\t\tstartDone = true;\n\t\t}\n\t\tif (\n\t\t\t!endDone &&\n\t\t\tadjustMarkerBeforeColumn(\n\t\t\t\tnodeEnd,\n\t\t\t\tendStickToPreviousCharacter,\n\t\t\t\tstart,\n\t\t\t\tmoveSemantics,\n\t\t\t)\n\t\t) {\n\t\t\tendDone = true;\n\t\t}\n\t}\n\n\tif (commonLength > 0 && !forceMoveMarkers) {\n\t\tconst moveSemantics =\n\t\t\tdeletingCnt > insertingCnt\n\t\t\t\t? MarkerMoveSemantics.ForceStay\n\t\t\t\t: MarkerMoveSemantics.MarkerDefined;\n\t\tif (\n\t\t\t!startDone &&\n\t\t\tadjustMarkerBeforeColumn(\n\t\t\t\tnodeStart,\n\t\t\t\tstartStickToPreviousCharacter,\n\t\t\t\tstart + commonLength,\n\t\t\t\tmoveSemantics,\n\t\t\t)\n\t\t) {\n\t\t\tstartDone = true;\n\t\t}\n\t\tif (\n\t\t\t!endDone &&\n\t\t\tadjustMarkerBeforeColumn(\n\t\t\t\tnodeEnd,\n\t\t\t\tendStickToPreviousCharacter,\n\t\t\t\tstart + commonLength,\n\t\t\t\tmoveSemantics,\n\t\t\t)\n\t\t) {\n\t\t\tendDone = true;\n\t\t}\n\t}\n\n\t{\n\t\tconst moveSemantics = forceMoveMarkers\n\t\t\t? MarkerMoveSemantics.ForceMove\n\t\t\t: MarkerMoveSemantics.MarkerDefined;\n\t\tif (\n\t\t\t!startDone &&\n\t\t\tadjustMarkerBeforeColumn(\n\t\t\t\tnodeStart,\n\t\t\t\tstartStickToPreviousCharacter,\n\t\t\t\tend,\n\t\t\t\tmoveSemantics,\n\t\t\t)\n\t\t) {\n\t\t\tnode.start = start + insertingCnt;\n\t\t\tstartDone = true;\n\t\t}\n\t\tif (\n\t\t\t!endDone &&\n\t\t\tadjustMarkerBeforeColumn(\n\t\t\t\tnodeEnd,\n\t\t\t\tendStickToPreviousCharacter,\n\t\t\t\tend,\n\t\t\t\tmoveSemantics,\n\t\t\t)\n\t\t) {\n\t\t\tnode.end = start + insertingCnt;\n\t\t\tendDone = true;\n\t\t}\n\t}\n\n\t// Finish\n\tconst deltaColumn = insertingCnt - deletingCnt;\n\tif (!startDone) {\n\t\tnode.start = Math.max(0, nodeStart + deltaColumn);\n\t}\n\tif (!endDone) {\n\t\tnode.end = Math.max(0, nodeEnd + deltaColumn);\n\t}\n\n\tif (node.start > node.end) {\n\t\tnode.end = node.start;\n\t}\n}\n\nfunction searchForEditing(\n\tT: IntervalTree,\n\tstart: number,\n\tend: number,\n): IntervalNode[] {\n\t// https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n\t// Now, it is known that two intervals A and B overlap only when both\n\t// A.low <= B.high and A.high >= B.low. When searching the trees for\n\t// nodes overlapping with a given interval, you can immediately skip:\n\t//  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n\t//  b) all nodes that have their maximum 'high' value below the start of the given interval.\n\tlet node = T.root;\n\tlet delta = 0;\n\tlet nodeMaxEnd = 0;\n\tlet nodeStart = 0;\n\tlet nodeEnd = 0;\n\tconst result: IntervalNode[] = [];\n\tlet resultLen = 0;\n\twhile (node !== SENTINEL) {\n\t\tif (getNodeIsVisited(node)) {\n\t\t\t// going up from this node\n\t\t\tsetNodeIsVisited(node.left, false);\n\t\t\tsetNodeIsVisited(node.right, false);\n\t\t\tif (node === node.parent.right) {\n\t\t\t\tdelta -= node.parent.delta;\n\t\t\t}\n\t\t\tnode = node.parent;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!getNodeIsVisited(node.left)) {\n\t\t\t// first time seeing this node\n\t\t\tnodeMaxEnd = delta + node.maxEnd;\n\t\t\tif (nodeMaxEnd < start) {\n\t\t\t\t// cover case b) from above\n\t\t\t\t// there is no need to search this node or its children\n\t\t\t\tsetNodeIsVisited(node, true);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (node.left !== SENTINEL) {\n\t\t\t\t// go left\n\t\t\t\tnode = node.left;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// handle current node\n\t\tnodeStart = delta + node.start;\n\t\tif (nodeStart > end) {\n\t\t\t// cover case a) from above\n\t\t\t// there is no need to search this node or its right subtree\n\t\t\tsetNodeIsVisited(node, true);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnodeEnd = delta + node.end;\n\t\tif (nodeEnd >= start) {\n\t\t\tnode.setCachedOffsets(nodeStart, nodeEnd, 0);\n\t\t\tresult[resultLen++] = node;\n\t\t}\n\t\tsetNodeIsVisited(node, true);\n\n\t\tif (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n\t\t\t// go right\n\t\t\tdelta += node.delta;\n\t\t\tnode = node.right;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tsetNodeIsVisited(T.root, false);\n\n\treturn result;\n}\n\nfunction noOverlapReplace(\n\tT: IntervalTree,\n\tstart: number,\n\tend: number,\n\ttextLength: number,\n): void {\n\t// https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n\t// Now, it is known that two intervals A and B overlap only when both\n\t// A.low <= B.high and A.high >= B.low. When searching the trees for\n\t// nodes overlapping with a given interval, you can immediately skip:\n\t//  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n\t//  b) all nodes that have their maximum 'high' value below the start of the given interval.\n\tlet node = T.root;\n\tlet delta = 0;\n\tlet nodeMaxEnd = 0;\n\tlet nodeStart = 0;\n\tconst editDelta = textLength - (end - start);\n\twhile (node !== SENTINEL) {\n\t\tif (getNodeIsVisited(node)) {\n\t\t\t// going up from this node\n\t\t\tsetNodeIsVisited(node.left, false);\n\t\t\tsetNodeIsVisited(node.right, false);\n\t\t\tif (node === node.parent.right) {\n\t\t\t\tdelta -= node.parent.delta;\n\t\t\t}\n\t\t\trecomputeMaxEnd(node);\n\t\t\tnode = node.parent;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!getNodeIsVisited(node.left)) {\n\t\t\t// first time seeing this node\n\t\t\tnodeMaxEnd = delta + node.maxEnd;\n\t\t\tif (nodeMaxEnd < start) {\n\t\t\t\t// cover case b) from above\n\t\t\t\t// there is no need to search this node or its children\n\t\t\t\tsetNodeIsVisited(node, true);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (node.left !== SENTINEL) {\n\t\t\t\t// go left\n\t\t\t\tnode = node.left;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// handle current node\n\t\tnodeStart = delta + node.start;\n\t\tif (nodeStart > end) {\n\t\t\tnode.start += editDelta;\n\t\t\tnode.end += editDelta;\n\t\t\tnode.delta += editDelta;\n\t\t\tif (\n\t\t\t\tnode.delta < Constants.MIN_SAFE_DELTA ||\n\t\t\t\tnode.delta > Constants.MAX_SAFE_DELTA\n\t\t\t) {\n\t\t\t\tT.requestNormalizeDelta = true;\n\t\t\t}\n\t\t\t// cover case a) from above\n\t\t\t// there is no need to search this node or its right subtree\n\t\t\tsetNodeIsVisited(node, true);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsetNodeIsVisited(node, true);\n\n\t\tif (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n\t\t\t// go right\n\t\t\tdelta += node.delta;\n\t\t\tnode = node.right;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tsetNodeIsVisited(T.root, false);\n}\n\n//#endregion\n\n//#region Searching\n\nfunction collectNodesFromOwner(\n\tT: IntervalTree,\n\townerId: number,\n): IntervalNode[] {\n\tlet node = T.root;\n\tconst result: IntervalNode[] = [];\n\tlet resultLen = 0;\n\twhile (node !== SENTINEL) {\n\t\tif (getNodeIsVisited(node)) {\n\t\t\t// going up from this node\n\t\t\tsetNodeIsVisited(node.left, false);\n\t\t\tsetNodeIsVisited(node.right, false);\n\t\t\tnode = node.parent;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n\t\t\t// go left\n\t\t\tnode = node.left;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// handle current node\n\t\tif (node.ownerId === ownerId) {\n\t\t\tresult[resultLen++] = node;\n\t\t}\n\n\t\tsetNodeIsVisited(node, true);\n\n\t\tif (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n\t\t\t// go right\n\t\t\tnode = node.right;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tsetNodeIsVisited(T.root, false);\n\n\treturn result;\n}\n\nfunction collectNodesPostOrder(T: IntervalTree): IntervalNode[] {\n\tlet node = T.root;\n\tconst result: IntervalNode[] = [];\n\tlet resultLen = 0;\n\twhile (node !== SENTINEL) {\n\t\tif (getNodeIsVisited(node)) {\n\t\t\t// going up from this node\n\t\t\tsetNodeIsVisited(node.left, false);\n\t\t\tsetNodeIsVisited(node.right, false);\n\t\t\tnode = node.parent;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n\t\t\t// go left\n\t\t\tnode = node.left;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n\t\t\t// go right\n\t\t\tnode = node.right;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// handle current node\n\t\tresult[resultLen++] = node;\n\t\tsetNodeIsVisited(node, true);\n\t}\n\n\tsetNodeIsVisited(T.root, false);\n\n\treturn result;\n}\n\nfunction search(\n\tT: IntervalTree,\n\tfilterOwnerId: number,\n\tfilterOutValidation: boolean,\n\tcachedVersionId: number,\n\tonlyMarginDecorations: boolean,\n): IntervalNode[] {\n\tlet node = T.root;\n\tlet delta = 0;\n\tlet nodeStart = 0;\n\tlet nodeEnd = 0;\n\tconst result: IntervalNode[] = [];\n\tlet resultLen = 0;\n\twhile (node !== SENTINEL) {\n\t\tif (getNodeIsVisited(node)) {\n\t\t\t// going up from this node\n\t\t\tsetNodeIsVisited(node.left, false);\n\t\t\tsetNodeIsVisited(node.right, false);\n\t\t\tif (node === node.parent.right) {\n\t\t\t\tdelta -= node.parent.delta;\n\t\t\t}\n\t\t\tnode = node.parent;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n\t\t\t// go left\n\t\t\tnode = node.left;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// handle current node\n\t\tnodeStart = delta + node.start;\n\t\tnodeEnd = delta + node.end;\n\n\t\tnode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n\n\t\tlet include = true;\n\t\tif (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n\t\t\tinclude = false;\n\t\t}\n\t\tif (filterOutValidation && getNodeIsForValidation(node)) {\n\t\t\tinclude = false;\n\t\t}\n\t\tif (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n\t\t\tinclude = false;\n\t\t}\n\n\t\tif (include) {\n\t\t\tresult[resultLen++] = node;\n\t\t}\n\n\t\tsetNodeIsVisited(node, true);\n\n\t\tif (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n\t\t\t// go right\n\t\t\tdelta += node.delta;\n\t\t\tnode = node.right;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tsetNodeIsVisited(T.root, false);\n\n\treturn result;\n}\n\nfunction intervalSearch(\n\tT: IntervalTree,\n\tintervalStart: number,\n\tintervalEnd: number,\n\tfilterOwnerId: number,\n\tfilterOutValidation: boolean,\n\tcachedVersionId: number,\n\tonlyMarginDecorations: boolean,\n): IntervalNode[] {\n\t// https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n\t// Now, it is known that two intervals A and B overlap only when both\n\t// A.low <= B.high and A.high >= B.low. When searching the trees for\n\t// nodes overlapping with a given interval, you can immediately skip:\n\t//  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n\t//  b) all nodes that have their maximum 'high' value below the start of the given interval.\n\n\tlet node = T.root;\n\tlet delta = 0;\n\tlet nodeMaxEnd = 0;\n\tlet nodeStart = 0;\n\tlet nodeEnd = 0;\n\tconst result: IntervalNode[] = [];\n\tlet resultLen = 0;\n\twhile (node !== SENTINEL) {\n\t\tif (getNodeIsVisited(node)) {\n\t\t\t// going up from this node\n\t\t\tsetNodeIsVisited(node.left, false);\n\t\t\tsetNodeIsVisited(node.right, false);\n\t\t\tif (node === node.parent.right) {\n\t\t\t\tdelta -= node.parent.delta;\n\t\t\t}\n\t\t\tnode = node.parent;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!getNodeIsVisited(node.left)) {\n\t\t\t// first time seeing this node\n\t\t\tnodeMaxEnd = delta + node.maxEnd;\n\t\t\tif (nodeMaxEnd < intervalStart) {\n\t\t\t\t// cover case b) from above\n\t\t\t\t// there is no need to search this node or its children\n\t\t\t\tsetNodeIsVisited(node, true);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (node.left !== SENTINEL) {\n\t\t\t\t// go left\n\t\t\t\tnode = node.left;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// handle current node\n\t\tnodeStart = delta + node.start;\n\t\tif (nodeStart > intervalEnd) {\n\t\t\t// cover case a) from above\n\t\t\t// there is no need to search this node or its right subtree\n\t\t\tsetNodeIsVisited(node, true);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnodeEnd = delta + node.end;\n\n\t\tif (nodeEnd >= intervalStart) {\n\t\t\t// There is overlap\n\t\t\tnode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n\n\t\t\tlet include = true;\n\t\t\tif (\n\t\t\t\tfilterOwnerId &&\n\t\t\t\tnode.ownerId &&\n\t\t\t\tnode.ownerId !== filterOwnerId\n\t\t\t) {\n\t\t\t\tinclude = false;\n\t\t\t}\n\t\t\tif (filterOutValidation && getNodeIsForValidation(node)) {\n\t\t\t\tinclude = false;\n\t\t\t}\n\t\t\tif (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n\t\t\t\tinclude = false;\n\t\t\t}\n\n\t\t\tif (include) {\n\t\t\t\tresult[resultLen++] = node;\n\t\t\t}\n\t\t}\n\n\t\tsetNodeIsVisited(node, true);\n\n\t\tif (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n\t\t\t// go right\n\t\t\tdelta += node.delta;\n\t\t\tnode = node.right;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tsetNodeIsVisited(T.root, false);\n\n\treturn result;\n}\n\n//#endregion\n\n//#region Insertion\nfunction rbTreeInsert(T: IntervalTree, newNode: IntervalNode): IntervalNode {\n\tif (T.root === SENTINEL) {\n\t\tnewNode.parent = SENTINEL;\n\t\tnewNode.left = SENTINEL;\n\t\tnewNode.right = SENTINEL;\n\t\tsetNodeColor(newNode, NodeColor.Black);\n\t\tT.root = newNode;\n\t\treturn T.root;\n\t}\n\n\ttreeInsert(T, newNode);\n\n\trecomputeMaxEndWalkToRoot(newNode.parent);\n\n\t// repair tree\n\tlet x = newNode;\n\twhile (x !== T.root && getNodeColor(x.parent) === NodeColor.Red) {\n\t\tif (x.parent === x.parent.parent.left) {\n\t\t\tconst y = x.parent.parent.right;\n\n\t\t\tif (getNodeColor(y) === NodeColor.Red) {\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Black);\n\t\t\t\tsetNodeColor(y, NodeColor.Black);\n\t\t\t\tsetNodeColor(x.parent.parent, NodeColor.Red);\n\t\t\t\tx = x.parent.parent;\n\t\t\t} else {\n\t\t\t\tif (x === x.parent.right) {\n\t\t\t\t\tx = x.parent;\n\t\t\t\t\tleftRotate(T, x);\n\t\t\t\t}\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Black);\n\t\t\t\tsetNodeColor(x.parent.parent, NodeColor.Red);\n\t\t\t\trightRotate(T, x.parent.parent);\n\t\t\t}\n\t\t} else {\n\t\t\tconst y = x.parent.parent.left;\n\n\t\t\tif (getNodeColor(y) === NodeColor.Red) {\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Black);\n\t\t\t\tsetNodeColor(y, NodeColor.Black);\n\t\t\t\tsetNodeColor(x.parent.parent, NodeColor.Red);\n\t\t\t\tx = x.parent.parent;\n\t\t\t} else {\n\t\t\t\tif (x === x.parent.left) {\n\t\t\t\t\tx = x.parent;\n\t\t\t\t\trightRotate(T, x);\n\t\t\t\t}\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Black);\n\t\t\t\tsetNodeColor(x.parent.parent, NodeColor.Red);\n\t\t\t\tleftRotate(T, x.parent.parent);\n\t\t\t}\n\t\t}\n\t}\n\n\tsetNodeColor(T.root, NodeColor.Black);\n\n\treturn newNode;\n}\n\nfunction treeInsert(T: IntervalTree, z: IntervalNode): void {\n\tlet delta = 0;\n\tlet x = T.root;\n\tconst zAbsoluteStart = z.start;\n\tconst zAbsoluteEnd = z.end;\n\twhile (true) {\n\t\tconst cmp = intervalCompare(\n\t\t\tzAbsoluteStart,\n\t\t\tzAbsoluteEnd,\n\t\t\tx.start + delta,\n\t\t\tx.end + delta,\n\t\t);\n\t\tif (cmp < 0) {\n\t\t\t// this node should be inserted to the left\n\t\t\t// => it is not affected by the node's delta\n\t\t\tif (x.left === SENTINEL) {\n\t\t\t\tz.start -= delta;\n\t\t\t\tz.end -= delta;\n\t\t\t\tz.maxEnd -= delta;\n\t\t\t\tx.left = z;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tx = x.left;\n\t\t\t}\n\t\t} else {\n\t\t\t// this node should be inserted to the right\n\t\t\t// => it is not affected by the node's delta\n\t\t\tif (x.right === SENTINEL) {\n\t\t\t\tz.start -= delta + x.delta;\n\t\t\t\tz.end -= delta + x.delta;\n\t\t\t\tz.maxEnd -= delta + x.delta;\n\t\t\t\tx.right = z;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tdelta += x.delta;\n\t\t\t\tx = x.right;\n\t\t\t}\n\t\t}\n\t}\n\n\tz.parent = x;\n\tz.left = SENTINEL;\n\tz.right = SENTINEL;\n\tsetNodeColor(z, NodeColor.Red);\n}\n//#endregion\n\n//#region Deletion\nfunction rbTreeDelete(T: IntervalTree, z: IntervalNode): void {\n\tlet x: IntervalNode;\n\tlet y: IntervalNode;\n\n\t// RB-DELETE except we don't swap z and y in case c)\n\t// i.e. we always delete what's pointed at by z.\n\n\tif (z.left === SENTINEL) {\n\t\tx = z.right;\n\t\ty = z;\n\n\t\t// x's delta is no longer influenced by z's delta\n\t\tx.delta += z.delta;\n\t\tif (\n\t\t\tx.delta < Constants.MIN_SAFE_DELTA ||\n\t\t\tx.delta > Constants.MAX_SAFE_DELTA\n\t\t) {\n\t\t\tT.requestNormalizeDelta = true;\n\t\t}\n\t\tx.start += z.delta;\n\t\tx.end += z.delta;\n\t} else if (z.right === SENTINEL) {\n\t\tx = z.left;\n\t\ty = z;\n\t} else {\n\t\ty = leftest(z.right);\n\t\tx = y.right;\n\n\t\t// y's delta is no longer influenced by z's delta,\n\t\t// but we don't want to walk the entire right-hand-side subtree of x.\n\t\t// we therefore maintain z's delta in y, and adjust only x\n\t\tx.start += y.delta;\n\t\tx.end += y.delta;\n\t\tx.delta += y.delta;\n\t\tif (\n\t\t\tx.delta < Constants.MIN_SAFE_DELTA ||\n\t\t\tx.delta > Constants.MAX_SAFE_DELTA\n\t\t) {\n\t\t\tT.requestNormalizeDelta = true;\n\t\t}\n\n\t\ty.start += z.delta;\n\t\ty.end += z.delta;\n\t\ty.delta = z.delta;\n\t\tif (\n\t\t\ty.delta < Constants.MIN_SAFE_DELTA ||\n\t\t\ty.delta > Constants.MAX_SAFE_DELTA\n\t\t) {\n\t\t\tT.requestNormalizeDelta = true;\n\t\t}\n\t}\n\n\tif (y === T.root) {\n\t\tT.root = x;\n\t\tsetNodeColor(x, NodeColor.Black);\n\n\t\tz.detach();\n\t\tresetSentinel();\n\t\trecomputeMaxEnd(x);\n\t\tT.root.parent = SENTINEL;\n\t\treturn;\n\t}\n\n\tconst yWasRed = getNodeColor(y) === NodeColor.Red;\n\n\tif (y === y.parent.left) {\n\t\ty.parent.left = x;\n\t} else {\n\t\ty.parent.right = x;\n\t}\n\n\tif (y === z) {\n\t\tx.parent = y.parent;\n\t} else {\n\t\tif (y.parent === z) {\n\t\t\tx.parent = y;\n\t\t} else {\n\t\t\tx.parent = y.parent;\n\t\t}\n\n\t\ty.left = z.left;\n\t\ty.right = z.right;\n\t\ty.parent = z.parent;\n\t\tsetNodeColor(y, getNodeColor(z));\n\n\t\tif (z === T.root) {\n\t\t\tT.root = y;\n\t\t} else if (z === z.parent.left) {\n\t\t\tz.parent.left = y;\n\t\t} else {\n\t\t\tz.parent.right = y;\n\t\t}\n\n\t\tif (y.left !== SENTINEL) {\n\t\t\ty.left.parent = y;\n\t\t}\n\t\tif (y.right !== SENTINEL) {\n\t\t\ty.right.parent = y;\n\t\t}\n\t}\n\n\tz.detach();\n\n\tif (yWasRed) {\n\t\trecomputeMaxEndWalkToRoot(x.parent);\n\t\tif (y !== z) {\n\t\t\trecomputeMaxEndWalkToRoot(y);\n\t\t\trecomputeMaxEndWalkToRoot(y.parent);\n\t\t}\n\t\tresetSentinel();\n\t\treturn;\n\t}\n\n\trecomputeMaxEndWalkToRoot(x);\n\trecomputeMaxEndWalkToRoot(x.parent);\n\tif (y !== z) {\n\t\trecomputeMaxEndWalkToRoot(y);\n\t\trecomputeMaxEndWalkToRoot(y.parent);\n\t}\n\n\t// RB-DELETE-FIXUP\n\tlet w: IntervalNode;\n\twhile (x !== T.root && getNodeColor(x) === NodeColor.Black) {\n\t\tif (x === x.parent.left) {\n\t\t\tw = x.parent.right;\n\n\t\t\tif (getNodeColor(w) === NodeColor.Red) {\n\t\t\t\tsetNodeColor(w, NodeColor.Black);\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Red);\n\t\t\t\tleftRotate(T, x.parent);\n\t\t\t\tw = x.parent.right;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tgetNodeColor(w.left) === NodeColor.Black &&\n\t\t\t\tgetNodeColor(w.right) === NodeColor.Black\n\t\t\t) {\n\t\t\t\tsetNodeColor(w, NodeColor.Red);\n\t\t\t\tx = x.parent;\n\t\t\t} else {\n\t\t\t\tif (getNodeColor(w.right) === NodeColor.Black) {\n\t\t\t\t\tsetNodeColor(w.left, NodeColor.Black);\n\t\t\t\t\tsetNodeColor(w, NodeColor.Red);\n\t\t\t\t\trightRotate(T, w);\n\t\t\t\t\tw = x.parent.right;\n\t\t\t\t}\n\n\t\t\t\tsetNodeColor(w, getNodeColor(x.parent));\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Black);\n\t\t\t\tsetNodeColor(w.right, NodeColor.Black);\n\t\t\t\tleftRotate(T, x.parent);\n\t\t\t\tx = T.root;\n\t\t\t}\n\t\t} else {\n\t\t\tw = x.parent.left;\n\n\t\t\tif (getNodeColor(w) === NodeColor.Red) {\n\t\t\t\tsetNodeColor(w, NodeColor.Black);\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Red);\n\t\t\t\trightRotate(T, x.parent);\n\t\t\t\tw = x.parent.left;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tgetNodeColor(w.left) === NodeColor.Black &&\n\t\t\t\tgetNodeColor(w.right) === NodeColor.Black\n\t\t\t) {\n\t\t\t\tsetNodeColor(w, NodeColor.Red);\n\t\t\t\tx = x.parent;\n\t\t\t} else {\n\t\t\t\tif (getNodeColor(w.left) === NodeColor.Black) {\n\t\t\t\t\tsetNodeColor(w.right, NodeColor.Black);\n\t\t\t\t\tsetNodeColor(w, NodeColor.Red);\n\t\t\t\t\tleftRotate(T, w);\n\t\t\t\t\tw = x.parent.left;\n\t\t\t\t}\n\n\t\t\t\tsetNodeColor(w, getNodeColor(x.parent));\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Black);\n\t\t\t\tsetNodeColor(w.left, NodeColor.Black);\n\t\t\t\trightRotate(T, x.parent);\n\t\t\t\tx = T.root;\n\t\t\t}\n\t\t}\n\t}\n\n\tsetNodeColor(x, NodeColor.Black);\n\tresetSentinel();\n}\n\nfunction leftest(node: IntervalNode): IntervalNode {\n\twhile (node.left !== SENTINEL) {\n\t\tnode = node.left;\n\t}\n\treturn node;\n}\n\nfunction resetSentinel(): void {\n\tSENTINEL.parent = SENTINEL;\n\tSENTINEL.delta = 0; // optional\n\tSENTINEL.start = 0; // optional\n\tSENTINEL.end = 0; // optional\n}\n//#endregion\n\n//#region Rotations\nfunction leftRotate(T: IntervalTree, x: IntervalNode): void {\n\tconst y = x.right; // set y.\n\n\ty.delta += x.delta; // y's delta is no longer influenced by x's delta\n\tif (\n\t\ty.delta < Constants.MIN_SAFE_DELTA ||\n\t\ty.delta > Constants.MAX_SAFE_DELTA\n\t) {\n\t\tT.requestNormalizeDelta = true;\n\t}\n\ty.start += x.delta;\n\ty.end += x.delta;\n\n\tx.right = y.left; // turn y's left subtree into x's right subtree.\n\tif (y.left !== SENTINEL) {\n\t\ty.left.parent = x;\n\t}\n\ty.parent = x.parent; // link x's parent to y.\n\tif (x.parent === SENTINEL) {\n\t\tT.root = y;\n\t} else if (x === x.parent.left) {\n\t\tx.parent.left = y;\n\t} else {\n\t\tx.parent.right = y;\n\t}\n\n\ty.left = x; // put x on y's left.\n\tx.parent = y;\n\n\trecomputeMaxEnd(x);\n\trecomputeMaxEnd(y);\n}\n\nfunction rightRotate(T: IntervalTree, y: IntervalNode): void {\n\tconst x = y.left;\n\n\ty.delta -= x.delta;\n\tif (\n\t\ty.delta < Constants.MIN_SAFE_DELTA ||\n\t\ty.delta > Constants.MAX_SAFE_DELTA\n\t) {\n\t\tT.requestNormalizeDelta = true;\n\t}\n\ty.start -= x.delta;\n\ty.end -= x.delta;\n\n\ty.left = x.right;\n\tif (x.right !== SENTINEL) {\n\t\tx.right.parent = y;\n\t}\n\tx.parent = y.parent;\n\tif (y.parent === SENTINEL) {\n\t\tT.root = x;\n\t} else if (y === y.parent.right) {\n\t\ty.parent.right = x;\n\t} else {\n\t\ty.parent.left = x;\n\t}\n\n\tx.right = y;\n\ty.parent = x;\n\n\trecomputeMaxEnd(y);\n\trecomputeMaxEnd(x);\n}\n//#endregion\n\n//#region max end computation\n\nfunction computeMaxEnd(node: IntervalNode): number {\n\tlet maxEnd = node.end;\n\tif (node.left !== SENTINEL) {\n\t\tconst leftMaxEnd = node.left.maxEnd;\n\t\tif (leftMaxEnd > maxEnd) {\n\t\t\tmaxEnd = leftMaxEnd;\n\t\t}\n\t}\n\tif (node.right !== SENTINEL) {\n\t\tconst rightMaxEnd = node.right.maxEnd + node.delta;\n\t\tif (rightMaxEnd > maxEnd) {\n\t\t\tmaxEnd = rightMaxEnd;\n\t\t}\n\t}\n\treturn maxEnd;\n}\n\nexport function recomputeMaxEnd(node: IntervalNode): void {\n\tnode.maxEnd = computeMaxEnd(node);\n}\n\nfunction recomputeMaxEndWalkToRoot(node: IntervalNode): void {\n\twhile (node !== SENTINEL) {\n\t\tconst maxEnd = computeMaxEnd(node);\n\n\t\tif (node.maxEnd === maxEnd) {\n\t\t\t// no need to go further\n\t\t\treturn;\n\t\t}\n\n\t\tnode.maxEnd = maxEnd;\n\t\tnode = node.parent;\n\t}\n}\n\n//#endregion\n\n//#region utils\nexport function intervalCompare(\n\taStart: number,\n\taEnd: number,\n\tbStart: number,\n\tbEnd: number,\n): number {\n\tif (aStart === bStart) {\n\t\treturn aEnd - bEnd;\n\t}\n\treturn aStart - bStart;\n}\n//#endregion\n"],
  "mappings": "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",
  "names": ["ClassName", "NodeColor", "Constants", "MarkerMoveSemantics"]
}
