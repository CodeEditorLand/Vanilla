{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/model/intervalTree.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Range } from '../core/range.js';\nimport { TrackedRangeStickiness, TrackedRangeStickiness as ActualTrackedRangeStickiness } from '../model.js';\nimport { ModelDecorationOptions } from './textModel.js';\n\n//\n// The red-black tree is based on the \"Introduction to Algorithms\" by Cormen, Leiserson and Rivest.\n//\n\nexport const enum ClassName {\n\tEditorHintDecoration = 'squiggly-hint',\n\tEditorInfoDecoration = 'squiggly-info',\n\tEditorWarningDecoration = 'squiggly-warning',\n\tEditorErrorDecoration = 'squiggly-error',\n\tEditorUnnecessaryDecoration = 'squiggly-unnecessary',\n\tEditorUnnecessaryInlineDecoration = 'squiggly-inline-unnecessary',\n\tEditorDeprecatedInlineDecoration = 'squiggly-inline-deprecated'\n}\n\nexport const enum NodeColor {\n\tBlack = 0,\n\tRed = 1,\n}\n\nconst enum Constants {\n\tColorMask = 0b00000001,\n\tColorMaskInverse = 0b11111110,\n\tColorOffset = 0,\n\n\tIsVisitedMask = 0b00000010,\n\tIsVisitedMaskInverse = 0b11111101,\n\tIsVisitedOffset = 1,\n\n\tIsForValidationMask = 0b00000100,\n\tIsForValidationMaskInverse = 0b11111011,\n\tIsForValidationOffset = 2,\n\n\tStickinessMask = 0b00011000,\n\tStickinessMaskInverse = 0b11100111,\n\tStickinessOffset = 3,\n\n\tCollapseOnReplaceEditMask = 0b00100000,\n\tCollapseOnReplaceEditMaskInverse = 0b11011111,\n\tCollapseOnReplaceEditOffset = 5,\n\n\tIsMarginMask = 0b01000000,\n\tIsMarginMaskInverse = 0b10111111,\n\tIsMarginOffset = 6,\n\n\t/**\n\t * Due to how deletion works (in order to avoid always walking the right subtree of the deleted node),\n\t * the deltas for nodes can grow and shrink dramatically. It has been observed, in practice, that unless\n\t * the deltas are corrected, integer overflow will occur.\n\t *\n\t * The integer overflow occurs when 53 bits are used in the numbers, but we will try to avoid it as\n\t * a node's delta gets below a negative 30 bits number.\n\t *\n\t * MIN SMI (SMall Integer) as defined in v8.\n\t * one bit is lost for boxing/unboxing flag.\n\t * one bit is lost for sign flag.\n\t * See https://thibaultlaurens.github.io/javascript/2013/04/29/how-the-v8-engine-works/#tagged-values\n\t */\n\tMIN_SAFE_DELTA = -(1 << 30),\n\t/**\n\t * MAX SMI (SMall Integer) as defined in v8.\n\t * one bit is lost for boxing/unboxing flag.\n\t * one bit is lost for sign flag.\n\t * See https://thibaultlaurens.github.io/javascript/2013/04/29/how-the-v8-engine-works/#tagged-values\n\t */\n\tMAX_SAFE_DELTA = 1 << 30,\n}\n\nexport function getNodeColor(node: IntervalNode): NodeColor {\n\treturn ((node.metadata & Constants.ColorMask) >>> Constants.ColorOffset);\n}\nfunction setNodeColor(node: IntervalNode, color: NodeColor): void {\n\tnode.metadata = (\n\t\t(node.metadata & Constants.ColorMaskInverse) | (color << Constants.ColorOffset)\n\t);\n}\nfunction getNodeIsVisited(node: IntervalNode): boolean {\n\treturn ((node.metadata & Constants.IsVisitedMask) >>> Constants.IsVisitedOffset) === 1;\n}\nfunction setNodeIsVisited(node: IntervalNode, value: boolean): void {\n\tnode.metadata = (\n\t\t(node.metadata & Constants.IsVisitedMaskInverse) | ((value ? 1 : 0) << Constants.IsVisitedOffset)\n\t);\n}\nfunction getNodeIsForValidation(node: IntervalNode): boolean {\n\treturn ((node.metadata & Constants.IsForValidationMask) >>> Constants.IsForValidationOffset) === 1;\n}\nfunction setNodeIsForValidation(node: IntervalNode, value: boolean): void {\n\tnode.metadata = (\n\t\t(node.metadata & Constants.IsForValidationMaskInverse) | ((value ? 1 : 0) << Constants.IsForValidationOffset)\n\t);\n}\nfunction getNodeIsInGlyphMargin(node: IntervalNode): boolean {\n\treturn ((node.metadata & Constants.IsMarginMask) >>> Constants.IsMarginOffset) === 1;\n}\nfunction setNodeIsInGlyphMargin(node: IntervalNode, value: boolean): void {\n\tnode.metadata = (\n\t\t(node.metadata & Constants.IsMarginMaskInverse) | ((value ? 1 : 0) << Constants.IsMarginOffset)\n\t);\n}\nfunction getNodeStickiness(node: IntervalNode): TrackedRangeStickiness {\n\treturn ((node.metadata & Constants.StickinessMask) >>> Constants.StickinessOffset);\n}\nfunction _setNodeStickiness(node: IntervalNode, stickiness: TrackedRangeStickiness): void {\n\tnode.metadata = (\n\t\t(node.metadata & Constants.StickinessMaskInverse) | (stickiness << Constants.StickinessOffset)\n\t);\n}\nfunction getCollapseOnReplaceEdit(node: IntervalNode): boolean {\n\treturn ((node.metadata & Constants.CollapseOnReplaceEditMask) >>> Constants.CollapseOnReplaceEditOffset) === 1;\n}\nfunction setCollapseOnReplaceEdit(node: IntervalNode, value: boolean): void {\n\tnode.metadata = (\n\t\t(node.metadata & Constants.CollapseOnReplaceEditMaskInverse) | ((value ? 1 : 0) << Constants.CollapseOnReplaceEditOffset)\n\t);\n}\nexport function setNodeStickiness(node: IntervalNode, stickiness: ActualTrackedRangeStickiness): void {\n\t_setNodeStickiness(node, <number>stickiness);\n}\n\nexport class IntervalNode {\n\n\t/**\n\t * contains binary encoded information for color, visited, isForValidation and stickiness.\n\t */\n\tpublic metadata: number;\n\n\tpublic parent: IntervalNode;\n\tpublic left: IntervalNode;\n\tpublic right: IntervalNode;\n\n\tpublic start: number;\n\tpublic end: number;\n\tpublic delta: number;\n\tpublic maxEnd: number;\n\n\tpublic id: string;\n\tpublic ownerId: number;\n\tpublic options: ModelDecorationOptions;\n\n\tpublic cachedVersionId: number;\n\tpublic cachedAbsoluteStart: number;\n\tpublic cachedAbsoluteEnd: number;\n\tpublic range: Range | null;\n\n\tconstructor(id: string, start: number, end: number) {\n\t\tthis.metadata = 0;\n\n\t\tthis.parent = this;\n\t\tthis.left = this;\n\t\tthis.right = this;\n\t\tsetNodeColor(this, NodeColor.Red);\n\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\t// FORCE_OVERFLOWING_TEST: this.delta = start;\n\t\tthis.delta = 0;\n\t\tthis.maxEnd = end;\n\n\t\tthis.id = id;\n\t\tthis.ownerId = 0;\n\t\tthis.options = null!;\n\t\tsetNodeIsForValidation(this, false);\n\t\tsetNodeIsInGlyphMargin(this, false);\n\t\t_setNodeStickiness(this, TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges);\n\t\tsetCollapseOnReplaceEdit(this, false);\n\n\t\tthis.cachedVersionId = 0;\n\t\tthis.cachedAbsoluteStart = start;\n\t\tthis.cachedAbsoluteEnd = end;\n\t\tthis.range = null;\n\n\t\tsetNodeIsVisited(this, false);\n\t}\n\n\tpublic reset(versionId: number, start: number, end: number, range: Range): void {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.maxEnd = end;\n\t\tthis.cachedVersionId = versionId;\n\t\tthis.cachedAbsoluteStart = start;\n\t\tthis.cachedAbsoluteEnd = end;\n\t\tthis.range = range;\n\t}\n\n\tpublic setOptions(options: ModelDecorationOptions) {\n\t\tthis.options = options;\n\t\tconst className = this.options.className;\n\t\tsetNodeIsForValidation(this, (\n\t\t\tclassName === ClassName.EditorErrorDecoration\n\t\t\t|| className === ClassName.EditorWarningDecoration\n\t\t\t|| className === ClassName.EditorInfoDecoration\n\t\t));\n\t\tsetNodeIsInGlyphMargin(this, this.options.glyphMarginClassName !== null);\n\t\t_setNodeStickiness(this, <number>this.options.stickiness);\n\t\tsetCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\n\t}\n\n\tpublic setCachedOffsets(absoluteStart: number, absoluteEnd: number, cachedVersionId: number): void {\n\t\tif (this.cachedVersionId !== cachedVersionId) {\n\t\t\tthis.range = null;\n\t\t}\n\t\tthis.cachedVersionId = cachedVersionId;\n\t\tthis.cachedAbsoluteStart = absoluteStart;\n\t\tthis.cachedAbsoluteEnd = absoluteEnd;\n\t}\n\n\tpublic detach(): void {\n\t\tthis.parent = null!;\n\t\tthis.left = null!;\n\t\tthis.right = null!;\n\t}\n}\n\nexport const SENTINEL: IntervalNode = new IntervalNode(null!, 0, 0);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nsetNodeColor(SENTINEL, NodeColor.Black);\n\nexport class IntervalTree {\n\n\tpublic root: IntervalNode;\n\tpublic requestNormalizeDelta: boolean;\n\n\tconstructor() {\n\t\tthis.root = SENTINEL;\n\t\tthis.requestNormalizeDelta = false;\n\t}\n\n\tpublic intervalSearch(start: number, end: number, filterOwnerId: number, filterOutValidation: boolean, cachedVersionId: number, onlyMarginDecorations: boolean): IntervalNode[] {\n\t\tif (this.root === SENTINEL) {\n\t\t\treturn [];\n\t\t}\n\t\treturn intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n\t}\n\n\tpublic search(filterOwnerId: number, filterOutValidation: boolean, cachedVersionId: number, onlyMarginDecorations: boolean): IntervalNode[] {\n\t\tif (this.root === SENTINEL) {\n\t\t\treturn [];\n\t\t}\n\t\treturn search(this, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n\t}\n\n\t/**\n\t * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n\t */\n\tpublic collectNodesFromOwner(ownerId: number): IntervalNode[] {\n\t\treturn collectNodesFromOwner(this, ownerId);\n\t}\n\n\t/**\n\t * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n\t */\n\tpublic collectNodesPostOrder(): IntervalNode[] {\n\t\treturn collectNodesPostOrder(this);\n\t}\n\n\tpublic insert(node: IntervalNode): void {\n\t\trbTreeInsert(this, node);\n\t\tthis._normalizeDeltaIfNecessary();\n\t}\n\n\tpublic delete(node: IntervalNode): void {\n\t\trbTreeDelete(this, node);\n\t\tthis._normalizeDeltaIfNecessary();\n\t}\n\n\tpublic resolveNode(node: IntervalNode, cachedVersionId: number): void {\n\t\tconst initialNode = node;\n\t\tlet delta = 0;\n\t\twhile (node !== this.root) {\n\t\t\tif (node === node.parent.right) {\n\t\t\t\tdelta += node.parent.delta;\n\t\t\t}\n\t\t\tnode = node.parent;\n\t\t}\n\n\t\tconst nodeStart = initialNode.start + delta;\n\t\tconst nodeEnd = initialNode.end + delta;\n\t\tinitialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n\t}\n\n\tpublic acceptReplace(offset: number, length: number, textLength: number, forceMoveMarkers: boolean): void {\n\t\t// Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n\n\t\t// (1) collect all nodes that are intersecting this edit as nodes of interest\n\t\tconst nodesOfInterest = searchForEditing(this, offset, offset + length);\n\n\t\t// (2) remove all nodes that are intersecting this edit\n\t\tfor (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n\t\t\tconst node = nodesOfInterest[i];\n\t\t\trbTreeDelete(this, node);\n\t\t}\n\t\tthis._normalizeDeltaIfNecessary();\n\n\t\t// (3) edit all tree nodes except the nodes of interest\n\t\tnoOverlapReplace(this, offset, offset + length, textLength);\n\t\tthis._normalizeDeltaIfNecessary();\n\n\t\t// (4) edit the nodes of interest and insert them back in the tree\n\t\tfor (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n\t\t\tconst node = nodesOfInterest[i];\n\t\t\tnode.start = node.cachedAbsoluteStart;\n\t\t\tnode.end = node.cachedAbsoluteEnd;\n\t\t\tnodeAcceptEdit(node, offset, (offset + length), textLength, forceMoveMarkers);\n\t\t\tnode.maxEnd = node.end;\n\t\t\trbTreeInsert(this, node);\n\t\t}\n\t\tthis._normalizeDeltaIfNecessary();\n\t}\n\n\tpublic getAllInOrder(): IntervalNode[] {\n\t\treturn search(this, 0, false, 0, false);\n\t}\n\n\tprivate _normalizeDeltaIfNecessary(): void {\n\t\tif (!this.requestNormalizeDelta) {\n\t\t\treturn;\n\t\t}\n\t\tthis.requestNormalizeDelta = false;\n\t\tnormalizeDelta(this);\n\t}\n}\n\n//#region Delta Normalization\nfunction normalizeDelta(T: IntervalTree): void {\n\tlet node = T.root;\n\tlet delta = 0;\n\twhile (node !== SENTINEL) {\n\n\t\tif (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n\t\t\t// go left\n\t\t\tnode = node.left;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n\t\t\t// go right\n\t\t\tdelta += node.delta;\n\t\t\tnode = node.right;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// handle current node\n\t\tnode.start = delta + node.start;\n\t\tnode.end = delta + node.end;\n\t\tnode.delta = 0;\n\t\trecomputeMaxEnd(node);\n\n\t\tsetNodeIsVisited(node, true);\n\n\t\t// going up from this node\n\t\tsetNodeIsVisited(node.left, false);\n\t\tsetNodeIsVisited(node.right, false);\n\t\tif (node === node.parent.right) {\n\t\t\tdelta -= node.parent.delta;\n\t\t}\n\t\tnode = node.parent;\n\t}\n\n\tsetNodeIsVisited(T.root, false);\n}\n//#endregion\n\n//#region Editing\n\nconst enum MarkerMoveSemantics {\n\tMarkerDefined = 0,\n\tForceMove = 1,\n\tForceStay = 2\n}\n\nfunction adjustMarkerBeforeColumn(markerOffset: number, markerStickToPreviousCharacter: boolean, checkOffset: number, moveSemantics: MarkerMoveSemantics): boolean {\n\tif (markerOffset < checkOffset) {\n\t\treturn true;\n\t}\n\tif (markerOffset > checkOffset) {\n\t\treturn false;\n\t}\n\tif (moveSemantics === MarkerMoveSemantics.ForceMove) {\n\t\treturn false;\n\t}\n\tif (moveSemantics === MarkerMoveSemantics.ForceStay) {\n\t\treturn true;\n\t}\n\treturn markerStickToPreviousCharacter;\n}\n\n/**\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\n * as when decorations were implemented using two markers.\n */\nexport function nodeAcceptEdit(node: IntervalNode, start: number, end: number, textLength: number, forceMoveMarkers: boolean): void {\n\tconst nodeStickiness = getNodeStickiness(node);\n\tconst startStickToPreviousCharacter = (\n\t\tnodeStickiness === TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges\n\t\t|| nodeStickiness === TrackedRangeStickiness.GrowsOnlyWhenTypingBefore\n\t);\n\tconst endStickToPreviousCharacter = (\n\t\tnodeStickiness === TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges\n\t\t|| nodeStickiness === TrackedRangeStickiness.GrowsOnlyWhenTypingBefore\n\t);\n\n\tconst deletingCnt = (end - start);\n\tconst insertingCnt = textLength;\n\tconst commonLength = Math.min(deletingCnt, insertingCnt);\n\n\tconst nodeStart = node.start;\n\tlet startDone = false;\n\n\tconst nodeEnd = node.end;\n\tlet endDone = false;\n\n\tif (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\n\t\t// This edit encompasses the entire decoration range\n\t\t// and the decoration has asked to become collapsed\n\t\tnode.start = start;\n\t\tstartDone = true;\n\t\tnode.end = start;\n\t\tendDone = true;\n\t}\n\n\t{\n\t\tconst moveSemantics = forceMoveMarkers ? MarkerMoveSemantics.ForceMove : (deletingCnt > 0 ? MarkerMoveSemantics.ForceStay : MarkerMoveSemantics.MarkerDefined);\n\t\tif (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\n\t\t\tstartDone = true;\n\t\t}\n\t\tif (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\n\t\t\tendDone = true;\n\t\t}\n\t}\n\n\tif (commonLength > 0 && !forceMoveMarkers) {\n\t\tconst moveSemantics = (deletingCnt > insertingCnt ? MarkerMoveSemantics.ForceStay : MarkerMoveSemantics.MarkerDefined);\n\t\tif (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n\t\t\tstartDone = true;\n\t\t}\n\t\tif (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n\t\t\tendDone = true;\n\t\t}\n\t}\n\n\t{\n\t\tconst moveSemantics = forceMoveMarkers ? MarkerMoveSemantics.ForceMove : MarkerMoveSemantics.MarkerDefined;\n\t\tif (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\n\t\t\tnode.start = start + insertingCnt;\n\t\t\tstartDone = true;\n\t\t}\n\t\tif (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\n\t\t\tnode.end = start + insertingCnt;\n\t\t\tendDone = true;\n\t\t}\n\t}\n\n\t// Finish\n\tconst deltaColumn = (insertingCnt - deletingCnt);\n\tif (!startDone) {\n\t\tnode.start = Math.max(0, nodeStart + deltaColumn);\n\t}\n\tif (!endDone) {\n\t\tnode.end = Math.max(0, nodeEnd + deltaColumn);\n\t}\n\n\tif (node.start > node.end) {\n\t\tnode.end = node.start;\n\t}\n}\n\nfunction searchForEditing(T: IntervalTree, start: number, end: number): IntervalNode[] {\n\t// https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n\t// Now, it is known that two intervals A and B overlap only when both\n\t// A.low <= B.high and A.high >= B.low. When searching the trees for\n\t// nodes overlapping with a given interval, you can immediately skip:\n\t//  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n\t//  b) all nodes that have their maximum 'high' value below the start of the given interval.\n\tlet node = T.root;\n\tlet delta = 0;\n\tlet nodeMaxEnd = 0;\n\tlet nodeStart = 0;\n\tlet nodeEnd = 0;\n\tconst result: IntervalNode[] = [];\n\tlet resultLen = 0;\n\twhile (node !== SENTINEL) {\n\t\tif (getNodeIsVisited(node)) {\n\t\t\t// going up from this node\n\t\t\tsetNodeIsVisited(node.left, false);\n\t\t\tsetNodeIsVisited(node.right, false);\n\t\t\tif (node === node.parent.right) {\n\t\t\t\tdelta -= node.parent.delta;\n\t\t\t}\n\t\t\tnode = node.parent;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!getNodeIsVisited(node.left)) {\n\t\t\t// first time seeing this node\n\t\t\tnodeMaxEnd = delta + node.maxEnd;\n\t\t\tif (nodeMaxEnd < start) {\n\t\t\t\t// cover case b) from above\n\t\t\t\t// there is no need to search this node or its children\n\t\t\t\tsetNodeIsVisited(node, true);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (node.left !== SENTINEL) {\n\t\t\t\t// go left\n\t\t\t\tnode = node.left;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// handle current node\n\t\tnodeStart = delta + node.start;\n\t\tif (nodeStart > end) {\n\t\t\t// cover case a) from above\n\t\t\t// there is no need to search this node or its right subtree\n\t\t\tsetNodeIsVisited(node, true);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnodeEnd = delta + node.end;\n\t\tif (nodeEnd >= start) {\n\t\t\tnode.setCachedOffsets(nodeStart, nodeEnd, 0);\n\t\t\tresult[resultLen++] = node;\n\t\t}\n\t\tsetNodeIsVisited(node, true);\n\n\t\tif (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n\t\t\t// go right\n\t\t\tdelta += node.delta;\n\t\t\tnode = node.right;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tsetNodeIsVisited(T.root, false);\n\n\treturn result;\n}\n\nfunction noOverlapReplace(T: IntervalTree, start: number, end: number, textLength: number): void {\n\t// https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n\t// Now, it is known that two intervals A and B overlap only when both\n\t// A.low <= B.high and A.high >= B.low. When searching the trees for\n\t// nodes overlapping with a given interval, you can immediately skip:\n\t//  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n\t//  b) all nodes that have their maximum 'high' value below the start of the given interval.\n\tlet node = T.root;\n\tlet delta = 0;\n\tlet nodeMaxEnd = 0;\n\tlet nodeStart = 0;\n\tconst editDelta = (textLength - (end - start));\n\twhile (node !== SENTINEL) {\n\t\tif (getNodeIsVisited(node)) {\n\t\t\t// going up from this node\n\t\t\tsetNodeIsVisited(node.left, false);\n\t\t\tsetNodeIsVisited(node.right, false);\n\t\t\tif (node === node.parent.right) {\n\t\t\t\tdelta -= node.parent.delta;\n\t\t\t}\n\t\t\trecomputeMaxEnd(node);\n\t\t\tnode = node.parent;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!getNodeIsVisited(node.left)) {\n\t\t\t// first time seeing this node\n\t\t\tnodeMaxEnd = delta + node.maxEnd;\n\t\t\tif (nodeMaxEnd < start) {\n\t\t\t\t// cover case b) from above\n\t\t\t\t// there is no need to search this node or its children\n\t\t\t\tsetNodeIsVisited(node, true);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (node.left !== SENTINEL) {\n\t\t\t\t// go left\n\t\t\t\tnode = node.left;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// handle current node\n\t\tnodeStart = delta + node.start;\n\t\tif (nodeStart > end) {\n\t\t\tnode.start += editDelta;\n\t\t\tnode.end += editDelta;\n\t\t\tnode.delta += editDelta;\n\t\t\tif (node.delta < Constants.MIN_SAFE_DELTA || node.delta > Constants.MAX_SAFE_DELTA) {\n\t\t\t\tT.requestNormalizeDelta = true;\n\t\t\t}\n\t\t\t// cover case a) from above\n\t\t\t// there is no need to search this node or its right subtree\n\t\t\tsetNodeIsVisited(node, true);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsetNodeIsVisited(node, true);\n\n\t\tif (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n\t\t\t// go right\n\t\t\tdelta += node.delta;\n\t\t\tnode = node.right;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tsetNodeIsVisited(T.root, false);\n}\n\n//#endregion\n\n//#region Searching\n\nfunction collectNodesFromOwner(T: IntervalTree, ownerId: number): IntervalNode[] {\n\tlet node = T.root;\n\tconst result: IntervalNode[] = [];\n\tlet resultLen = 0;\n\twhile (node !== SENTINEL) {\n\t\tif (getNodeIsVisited(node)) {\n\t\t\t// going up from this node\n\t\t\tsetNodeIsVisited(node.left, false);\n\t\t\tsetNodeIsVisited(node.right, false);\n\t\t\tnode = node.parent;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n\t\t\t// go left\n\t\t\tnode = node.left;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// handle current node\n\t\tif (node.ownerId === ownerId) {\n\t\t\tresult[resultLen++] = node;\n\t\t}\n\n\t\tsetNodeIsVisited(node, true);\n\n\t\tif (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n\t\t\t// go right\n\t\t\tnode = node.right;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tsetNodeIsVisited(T.root, false);\n\n\treturn result;\n}\n\nfunction collectNodesPostOrder(T: IntervalTree): IntervalNode[] {\n\tlet node = T.root;\n\tconst result: IntervalNode[] = [];\n\tlet resultLen = 0;\n\twhile (node !== SENTINEL) {\n\t\tif (getNodeIsVisited(node)) {\n\t\t\t// going up from this node\n\t\t\tsetNodeIsVisited(node.left, false);\n\t\t\tsetNodeIsVisited(node.right, false);\n\t\t\tnode = node.parent;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n\t\t\t// go left\n\t\t\tnode = node.left;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n\t\t\t// go right\n\t\t\tnode = node.right;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// handle current node\n\t\tresult[resultLen++] = node;\n\t\tsetNodeIsVisited(node, true);\n\t}\n\n\tsetNodeIsVisited(T.root, false);\n\n\treturn result;\n}\n\nfunction search(T: IntervalTree, filterOwnerId: number, filterOutValidation: boolean, cachedVersionId: number, onlyMarginDecorations: boolean): IntervalNode[] {\n\tlet node = T.root;\n\tlet delta = 0;\n\tlet nodeStart = 0;\n\tlet nodeEnd = 0;\n\tconst result: IntervalNode[] = [];\n\tlet resultLen = 0;\n\twhile (node !== SENTINEL) {\n\t\tif (getNodeIsVisited(node)) {\n\t\t\t// going up from this node\n\t\t\tsetNodeIsVisited(node.left, false);\n\t\t\tsetNodeIsVisited(node.right, false);\n\t\t\tif (node === node.parent.right) {\n\t\t\t\tdelta -= node.parent.delta;\n\t\t\t}\n\t\t\tnode = node.parent;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n\t\t\t// go left\n\t\t\tnode = node.left;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// handle current node\n\t\tnodeStart = delta + node.start;\n\t\tnodeEnd = delta + node.end;\n\n\t\tnode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n\n\t\tlet include = true;\n\t\tif (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n\t\t\tinclude = false;\n\t\t}\n\t\tif (filterOutValidation && getNodeIsForValidation(node)) {\n\t\t\tinclude = false;\n\t\t}\n\t\tif (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n\t\t\tinclude = false;\n\t\t}\n\n\t\tif (include) {\n\t\t\tresult[resultLen++] = node;\n\t\t}\n\n\t\tsetNodeIsVisited(node, true);\n\n\t\tif (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n\t\t\t// go right\n\t\t\tdelta += node.delta;\n\t\t\tnode = node.right;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tsetNodeIsVisited(T.root, false);\n\n\treturn result;\n}\n\nfunction intervalSearch(T: IntervalTree, intervalStart: number, intervalEnd: number, filterOwnerId: number, filterOutValidation: boolean, cachedVersionId: number, onlyMarginDecorations: boolean): IntervalNode[] {\n\t// https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n\t// Now, it is known that two intervals A and B overlap only when both\n\t// A.low <= B.high and A.high >= B.low. When searching the trees for\n\t// nodes overlapping with a given interval, you can immediately skip:\n\t//  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n\t//  b) all nodes that have their maximum 'high' value below the start of the given interval.\n\n\tlet node = T.root;\n\tlet delta = 0;\n\tlet nodeMaxEnd = 0;\n\tlet nodeStart = 0;\n\tlet nodeEnd = 0;\n\tconst result: IntervalNode[] = [];\n\tlet resultLen = 0;\n\twhile (node !== SENTINEL) {\n\t\tif (getNodeIsVisited(node)) {\n\t\t\t// going up from this node\n\t\t\tsetNodeIsVisited(node.left, false);\n\t\t\tsetNodeIsVisited(node.right, false);\n\t\t\tif (node === node.parent.right) {\n\t\t\t\tdelta -= node.parent.delta;\n\t\t\t}\n\t\t\tnode = node.parent;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!getNodeIsVisited(node.left)) {\n\t\t\t// first time seeing this node\n\t\t\tnodeMaxEnd = delta + node.maxEnd;\n\t\t\tif (nodeMaxEnd < intervalStart) {\n\t\t\t\t// cover case b) from above\n\t\t\t\t// there is no need to search this node or its children\n\t\t\t\tsetNodeIsVisited(node, true);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (node.left !== SENTINEL) {\n\t\t\t\t// go left\n\t\t\t\tnode = node.left;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// handle current node\n\t\tnodeStart = delta + node.start;\n\t\tif (nodeStart > intervalEnd) {\n\t\t\t// cover case a) from above\n\t\t\t// there is no need to search this node or its right subtree\n\t\t\tsetNodeIsVisited(node, true);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnodeEnd = delta + node.end;\n\n\t\tif (nodeEnd >= intervalStart) {\n\t\t\t// There is overlap\n\t\t\tnode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n\n\t\t\tlet include = true;\n\t\t\tif (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n\t\t\t\tinclude = false;\n\t\t\t}\n\t\t\tif (filterOutValidation && getNodeIsForValidation(node)) {\n\t\t\t\tinclude = false;\n\t\t\t}\n\t\t\tif (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n\t\t\t\tinclude = false;\n\t\t\t}\n\n\t\t\tif (include) {\n\t\t\t\tresult[resultLen++] = node;\n\t\t\t}\n\t\t}\n\n\t\tsetNodeIsVisited(node, true);\n\n\t\tif (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n\t\t\t// go right\n\t\t\tdelta += node.delta;\n\t\t\tnode = node.right;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tsetNodeIsVisited(T.root, false);\n\n\treturn result;\n}\n\n//#endregion\n\n//#region Insertion\nfunction rbTreeInsert(T: IntervalTree, newNode: IntervalNode): IntervalNode {\n\tif (T.root === SENTINEL) {\n\t\tnewNode.parent = SENTINEL;\n\t\tnewNode.left = SENTINEL;\n\t\tnewNode.right = SENTINEL;\n\t\tsetNodeColor(newNode, NodeColor.Black);\n\t\tT.root = newNode;\n\t\treturn T.root;\n\t}\n\n\ttreeInsert(T, newNode);\n\n\trecomputeMaxEndWalkToRoot(newNode.parent);\n\n\t// repair tree\n\tlet x = newNode;\n\twhile (x !== T.root && getNodeColor(x.parent) === NodeColor.Red) {\n\t\tif (x.parent === x.parent.parent.left) {\n\t\t\tconst y = x.parent.parent.right;\n\n\t\t\tif (getNodeColor(y) === NodeColor.Red) {\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Black);\n\t\t\t\tsetNodeColor(y, NodeColor.Black);\n\t\t\t\tsetNodeColor(x.parent.parent, NodeColor.Red);\n\t\t\t\tx = x.parent.parent;\n\t\t\t} else {\n\t\t\t\tif (x === x.parent.right) {\n\t\t\t\t\tx = x.parent;\n\t\t\t\t\tleftRotate(T, x);\n\t\t\t\t}\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Black);\n\t\t\t\tsetNodeColor(x.parent.parent, NodeColor.Red);\n\t\t\t\trightRotate(T, x.parent.parent);\n\t\t\t}\n\t\t} else {\n\t\t\tconst y = x.parent.parent.left;\n\n\t\t\tif (getNodeColor(y) === NodeColor.Red) {\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Black);\n\t\t\t\tsetNodeColor(y, NodeColor.Black);\n\t\t\t\tsetNodeColor(x.parent.parent, NodeColor.Red);\n\t\t\t\tx = x.parent.parent;\n\t\t\t} else {\n\t\t\t\tif (x === x.parent.left) {\n\t\t\t\t\tx = x.parent;\n\t\t\t\t\trightRotate(T, x);\n\t\t\t\t}\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Black);\n\t\t\t\tsetNodeColor(x.parent.parent, NodeColor.Red);\n\t\t\t\tleftRotate(T, x.parent.parent);\n\t\t\t}\n\t\t}\n\t}\n\n\tsetNodeColor(T.root, NodeColor.Black);\n\n\treturn newNode;\n}\n\nfunction treeInsert(T: IntervalTree, z: IntervalNode): void {\n\tlet delta: number = 0;\n\tlet x = T.root;\n\tconst zAbsoluteStart = z.start;\n\tconst zAbsoluteEnd = z.end;\n\twhile (true) {\n\t\tconst cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\n\t\tif (cmp < 0) {\n\t\t\t// this node should be inserted to the left\n\t\t\t// => it is not affected by the node's delta\n\t\t\tif (x.left === SENTINEL) {\n\t\t\t\tz.start -= delta;\n\t\t\t\tz.end -= delta;\n\t\t\t\tz.maxEnd -= delta;\n\t\t\t\tx.left = z;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tx = x.left;\n\t\t\t}\n\t\t} else {\n\t\t\t// this node should be inserted to the right\n\t\t\t// => it is not affected by the node's delta\n\t\t\tif (x.right === SENTINEL) {\n\t\t\t\tz.start -= (delta + x.delta);\n\t\t\t\tz.end -= (delta + x.delta);\n\t\t\t\tz.maxEnd -= (delta + x.delta);\n\t\t\t\tx.right = z;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tdelta += x.delta;\n\t\t\t\tx = x.right;\n\t\t\t}\n\t\t}\n\t}\n\n\tz.parent = x;\n\tz.left = SENTINEL;\n\tz.right = SENTINEL;\n\tsetNodeColor(z, NodeColor.Red);\n}\n//#endregion\n\n//#region Deletion\nfunction rbTreeDelete(T: IntervalTree, z: IntervalNode): void {\n\n\tlet x: IntervalNode;\n\tlet y: IntervalNode;\n\n\t// RB-DELETE except we don't swap z and y in case c)\n\t// i.e. we always delete what's pointed at by z.\n\n\tif (z.left === SENTINEL) {\n\t\tx = z.right;\n\t\ty = z;\n\n\t\t// x's delta is no longer influenced by z's delta\n\t\tx.delta += z.delta;\n\t\tif (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {\n\t\t\tT.requestNormalizeDelta = true;\n\t\t}\n\t\tx.start += z.delta;\n\t\tx.end += z.delta;\n\n\t} else if (z.right === SENTINEL) {\n\t\tx = z.left;\n\t\ty = z;\n\n\t} else {\n\t\ty = leftest(z.right);\n\t\tx = y.right;\n\n\t\t// y's delta is no longer influenced by z's delta,\n\t\t// but we don't want to walk the entire right-hand-side subtree of x.\n\t\t// we therefore maintain z's delta in y, and adjust only x\n\t\tx.start += y.delta;\n\t\tx.end += y.delta;\n\t\tx.delta += y.delta;\n\t\tif (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {\n\t\t\tT.requestNormalizeDelta = true;\n\t\t}\n\n\t\ty.start += z.delta;\n\t\ty.end += z.delta;\n\t\ty.delta = z.delta;\n\t\tif (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {\n\t\t\tT.requestNormalizeDelta = true;\n\t\t}\n\t}\n\n\tif (y === T.root) {\n\t\tT.root = x;\n\t\tsetNodeColor(x, NodeColor.Black);\n\n\t\tz.detach();\n\t\tresetSentinel();\n\t\trecomputeMaxEnd(x);\n\t\tT.root.parent = SENTINEL;\n\t\treturn;\n\t}\n\n\tconst yWasRed = (getNodeColor(y) === NodeColor.Red);\n\n\tif (y === y.parent.left) {\n\t\ty.parent.left = x;\n\t} else {\n\t\ty.parent.right = x;\n\t}\n\n\tif (y === z) {\n\t\tx.parent = y.parent;\n\t} else {\n\n\t\tif (y.parent === z) {\n\t\t\tx.parent = y;\n\t\t} else {\n\t\t\tx.parent = y.parent;\n\t\t}\n\n\t\ty.left = z.left;\n\t\ty.right = z.right;\n\t\ty.parent = z.parent;\n\t\tsetNodeColor(y, getNodeColor(z));\n\n\t\tif (z === T.root) {\n\t\t\tT.root = y;\n\t\t} else {\n\t\t\tif (z === z.parent.left) {\n\t\t\t\tz.parent.left = y;\n\t\t\t} else {\n\t\t\t\tz.parent.right = y;\n\t\t\t}\n\t\t}\n\n\t\tif (y.left !== SENTINEL) {\n\t\t\ty.left.parent = y;\n\t\t}\n\t\tif (y.right !== SENTINEL) {\n\t\t\ty.right.parent = y;\n\t\t}\n\t}\n\n\tz.detach();\n\n\tif (yWasRed) {\n\t\trecomputeMaxEndWalkToRoot(x.parent);\n\t\tif (y !== z) {\n\t\t\trecomputeMaxEndWalkToRoot(y);\n\t\t\trecomputeMaxEndWalkToRoot(y.parent);\n\t\t}\n\t\tresetSentinel();\n\t\treturn;\n\t}\n\n\trecomputeMaxEndWalkToRoot(x);\n\trecomputeMaxEndWalkToRoot(x.parent);\n\tif (y !== z) {\n\t\trecomputeMaxEndWalkToRoot(y);\n\t\trecomputeMaxEndWalkToRoot(y.parent);\n\t}\n\n\t// RB-DELETE-FIXUP\n\tlet w: IntervalNode;\n\twhile (x !== T.root && getNodeColor(x) === NodeColor.Black) {\n\n\t\tif (x === x.parent.left) {\n\t\t\tw = x.parent.right;\n\n\t\t\tif (getNodeColor(w) === NodeColor.Red) {\n\t\t\t\tsetNodeColor(w, NodeColor.Black);\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Red);\n\t\t\t\tleftRotate(T, x.parent);\n\t\t\t\tw = x.parent.right;\n\t\t\t}\n\n\t\t\tif (getNodeColor(w.left) === NodeColor.Black && getNodeColor(w.right) === NodeColor.Black) {\n\t\t\t\tsetNodeColor(w, NodeColor.Red);\n\t\t\t\tx = x.parent;\n\t\t\t} else {\n\t\t\t\tif (getNodeColor(w.right) === NodeColor.Black) {\n\t\t\t\t\tsetNodeColor(w.left, NodeColor.Black);\n\t\t\t\t\tsetNodeColor(w, NodeColor.Red);\n\t\t\t\t\trightRotate(T, w);\n\t\t\t\t\tw = x.parent.right;\n\t\t\t\t}\n\n\t\t\t\tsetNodeColor(w, getNodeColor(x.parent));\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Black);\n\t\t\t\tsetNodeColor(w.right, NodeColor.Black);\n\t\t\t\tleftRotate(T, x.parent);\n\t\t\t\tx = T.root;\n\t\t\t}\n\n\t\t} else {\n\t\t\tw = x.parent.left;\n\n\t\t\tif (getNodeColor(w) === NodeColor.Red) {\n\t\t\t\tsetNodeColor(w, NodeColor.Black);\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Red);\n\t\t\t\trightRotate(T, x.parent);\n\t\t\t\tw = x.parent.left;\n\t\t\t}\n\n\t\t\tif (getNodeColor(w.left) === NodeColor.Black && getNodeColor(w.right) === NodeColor.Black) {\n\t\t\t\tsetNodeColor(w, NodeColor.Red);\n\t\t\t\tx = x.parent;\n\n\t\t\t} else {\n\t\t\t\tif (getNodeColor(w.left) === NodeColor.Black) {\n\t\t\t\t\tsetNodeColor(w.right, NodeColor.Black);\n\t\t\t\t\tsetNodeColor(w, NodeColor.Red);\n\t\t\t\t\tleftRotate(T, w);\n\t\t\t\t\tw = x.parent.left;\n\t\t\t\t}\n\n\t\t\t\tsetNodeColor(w, getNodeColor(x.parent));\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Black);\n\t\t\t\tsetNodeColor(w.left, NodeColor.Black);\n\t\t\t\trightRotate(T, x.parent);\n\t\t\t\tx = T.root;\n\t\t\t}\n\t\t}\n\t}\n\n\tsetNodeColor(x, NodeColor.Black);\n\tresetSentinel();\n}\n\nfunction leftest(node: IntervalNode): IntervalNode {\n\twhile (node.left !== SENTINEL) {\n\t\tnode = node.left;\n\t}\n\treturn node;\n}\n\nfunction resetSentinel(): void {\n\tSENTINEL.parent = SENTINEL;\n\tSENTINEL.delta = 0; // optional\n\tSENTINEL.start = 0; // optional\n\tSENTINEL.end = 0; // optional\n}\n//#endregion\n\n//#region Rotations\nfunction leftRotate(T: IntervalTree, x: IntervalNode): void {\n\tconst y = x.right;\t\t\t\t// set y.\n\n\ty.delta += x.delta;\t\t\t\t// y's delta is no longer influenced by x's delta\n\tif (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {\n\t\tT.requestNormalizeDelta = true;\n\t}\n\ty.start += x.delta;\n\ty.end += x.delta;\n\n\tx.right = y.left;\t\t\t\t// turn y's left subtree into x's right subtree.\n\tif (y.left !== SENTINEL) {\n\t\ty.left.parent = x;\n\t}\n\ty.parent = x.parent;\t\t\t// link x's parent to y.\n\tif (x.parent === SENTINEL) {\n\t\tT.root = y;\n\t} else if (x === x.parent.left) {\n\t\tx.parent.left = y;\n\t} else {\n\t\tx.parent.right = y;\n\t}\n\n\ty.left = x;\t\t\t\t\t\t// put x on y's left.\n\tx.parent = y;\n\n\trecomputeMaxEnd(x);\n\trecomputeMaxEnd(y);\n}\n\nfunction rightRotate(T: IntervalTree, y: IntervalNode): void {\n\tconst x = y.left;\n\n\ty.delta -= x.delta;\n\tif (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {\n\t\tT.requestNormalizeDelta = true;\n\t}\n\ty.start -= x.delta;\n\ty.end -= x.delta;\n\n\ty.left = x.right;\n\tif (x.right !== SENTINEL) {\n\t\tx.right.parent = y;\n\t}\n\tx.parent = y.parent;\n\tif (y.parent === SENTINEL) {\n\t\tT.root = x;\n\t} else if (y === y.parent.right) {\n\t\ty.parent.right = x;\n\t} else {\n\t\ty.parent.left = x;\n\t}\n\n\tx.right = y;\n\ty.parent = x;\n\n\trecomputeMaxEnd(y);\n\trecomputeMaxEnd(x);\n}\n//#endregion\n\n//#region max end computation\n\nfunction computeMaxEnd(node: IntervalNode): number {\n\tlet maxEnd = node.end;\n\tif (node.left !== SENTINEL) {\n\t\tconst leftMaxEnd = node.left.maxEnd;\n\t\tif (leftMaxEnd > maxEnd) {\n\t\t\tmaxEnd = leftMaxEnd;\n\t\t}\n\t}\n\tif (node.right !== SENTINEL) {\n\t\tconst rightMaxEnd = node.right.maxEnd + node.delta;\n\t\tif (rightMaxEnd > maxEnd) {\n\t\t\tmaxEnd = rightMaxEnd;\n\t\t}\n\t}\n\treturn maxEnd;\n}\n\nexport function recomputeMaxEnd(node: IntervalNode): void {\n\tnode.maxEnd = computeMaxEnd(node);\n}\n\nfunction recomputeMaxEndWalkToRoot(node: IntervalNode): void {\n\twhile (node !== SENTINEL) {\n\n\t\tconst maxEnd = computeMaxEnd(node);\n\n\t\tif (node.maxEnd === maxEnd) {\n\t\t\t// no need to go further\n\t\t\treturn;\n\t\t}\n\n\t\tnode.maxEnd = maxEnd;\n\t\tnode = node.parent;\n\t}\n}\n\n//#endregion\n\n//#region utils\nexport function intervalCompare(aStart: number, aEnd: number, bStart: number, bEnd: number): number {\n\tif (aStart === bStart) {\n\t\treturn aEnd - bEnd;\n\t}\n\treturn aStart - bStart;\n}\n//#endregion\n"],
  "mappings": "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",
  "names": ["ClassName", "NodeColor", "Constants", "MarkerMoveSemantics"]
}
