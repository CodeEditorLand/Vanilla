{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/textModelBracketPairs.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CallbackIterable } from '../../base/common/arrays.js';\nimport { Event } from '../../base/common/event.js';\nimport { IPosition } from './core/position.js';\nimport { IRange, Range } from './core/range.js';\nimport { ClosingBracketKind, OpeningBracketKind } from './languages/supports/languageBracketsConfiguration.js';\nimport { PairAstNode } from './model/bracketPairsTextModelPart/bracketPairsTree/ast.js';\n\nexport interface IBracketPairsTextModelPart {\n\t/**\n\t * Is fired when bracket pairs change, either due to a text or a settings change.\n\t*/\n\tonDidChange: Event<void>;\n\n\t/**\n\t * Gets all bracket pairs that intersect the given position.\n\t * The result is sorted by the start position.\n\t */\n\tgetBracketPairsInRange(range: IRange): CallbackIterable<BracketPairInfo>;\n\n\t/**\n\t * Gets all bracket pairs that intersect the given position.\n\t * The result is sorted by the start position.\n\t */\n\tgetBracketPairsInRangeWithMinIndentation(range: IRange): CallbackIterable<BracketPairWithMinIndentationInfo>;\n\n\tgetBracketsInRange(range: IRange, onlyColorizedBrackets?: boolean): CallbackIterable<BracketInfo>;\n\n\t/**\n\t * Find the matching bracket of `request` up, counting brackets.\n\t * @param request The bracket we're searching for\n\t * @param position The position at which to start the search.\n\t * @return The range of the matching bracket, or null if the bracket match was not found.\n\t */\n\tfindMatchingBracketUp(bracket: string, position: IPosition, maxDuration?: number): Range | null;\n\n\t/**\n\t * Find the first bracket in the model before `position`.\n\t * @param position The position at which to start the search.\n\t * @return The info for the first bracket before `position`, or null if there are no more brackets before `positions`.\n\t */\n\tfindPrevBracket(position: IPosition): IFoundBracket | null;\n\n\t/**\n\t * Find the first bracket in the model after `position`.\n\t * @param position The position at which to start the search.\n\t * @return The info for the first bracket after `position`, or null if there are no more brackets after `positions`.\n\t */\n\tfindNextBracket(position: IPosition): IFoundBracket | null;\n\n\t/**\n\t * Find the enclosing brackets that contain `position`.\n\t * @param position The position at which to start the search.\n\t */\n\tfindEnclosingBrackets(position: IPosition, maxDuration?: number): [Range, Range] | null;\n\n\t/**\n\t * Given a `position`, if the position is on top or near a bracket,\n\t * find the matching bracket of that bracket and return the ranges of both brackets.\n\t * @param position The position at which to look for a bracket.\n\t */\n\tmatchBracket(position: IPosition, maxDuration?: number): [Range, Range] | null;\n}\n\nexport interface IFoundBracket {\n\trange: Range;\n\tbracketInfo: OpeningBracketKind | ClosingBracketKind;\n}\n\nexport class BracketInfo {\n\tconstructor(\n\t\tpublic readonly range: Range,\n\t\t/** 0-based level */\n\t\tpublic readonly nestingLevel: number,\n\t\tpublic readonly nestingLevelOfEqualBracketType: number,\n\t\tpublic readonly isInvalid: boolean,\n\t) { }\n}\n\nexport class BracketPairInfo {\n\tconstructor(\n\t\tpublic readonly range: Range,\n\t\tpublic readonly openingBracketRange: Range,\n\t\tpublic readonly closingBracketRange: Range | undefined,\n\t\t/** 0-based */\n\t\tpublic readonly nestingLevel: number,\n\t\tpublic readonly nestingLevelOfEqualBracketType: number,\n\t\tprivate readonly bracketPairNode: PairAstNode,\n\n\t) {\n\t}\n\n\tpublic get openingBracketInfo(): OpeningBracketKind {\n\t\treturn this.bracketPairNode.openingBracket.bracketInfo as OpeningBracketKind;\n\t}\n\n\tpublic get closingBracketInfo(): ClosingBracketKind | undefined {\n\t\treturn this.bracketPairNode.closingBracket?.bracketInfo as ClosingBracketKind | undefined;\n\t}\n}\n\nexport class BracketPairWithMinIndentationInfo extends BracketPairInfo {\n\tconstructor(\n\t\trange: Range,\n\t\topeningBracketRange: Range,\n\t\tclosingBracketRange: Range | undefined,\n\t\t/**\n\t\t * 0-based\n\t\t*/\n\t\tnestingLevel: number,\n\t\tnestingLevelOfEqualBracketType: number,\n\t\tbracketPairNode: PairAstNode,\n\t\t/**\n\t\t * -1 if not requested, otherwise the size of the minimum indentation in the bracket pair in terms of visible columns.\n\t\t*/\n\t\tpublic readonly minVisibleColumnIndentation: number,\n\t) {\n\t\tsuper(range, openingBracketRange, closingBracketRange, nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode);\n\t}\n}\n"],
  "mappings": ";;AAKA,SAAS,wBAAwB;AACjC,SAAS,aAAa;AACtB,SAAS,iBAAiB;AAC1B,SAAS,QAAQ,aAAa;AAC9B,SAAS,oBAAoB,0BAA0B;AACvD,SAAS,mBAAmB;AA+DrB,MAAM,YAAY;AAAA,EACxB,YACiB,OAEA,cACA,gCACA,WACf;AALe;AAEA;AACA;AACA;AAAA,EACb;AAAA,EAhFL,OAyEyB;AAAA;AAAA;AAQzB;AAEO,MAAM,gBAAgB;AAAA,EAC5B,YACiB,OACA,qBACA,qBAEA,cACA,gCACC,iBAEhB;AARe;AACA;AACA;AAEA;AACA;AACC;AAAA,EAGlB;AAAA,EA9FD,OAmF6B;AAAA;AAAA;AAAA,EAa5B,IAAW,qBAAyC;AACnD,WAAO,KAAK,gBAAgB,eAAe;AAAA,EAC5C;AAAA,EAEA,IAAW,qBAAqD;AAC/D,WAAO,KAAK,gBAAgB,gBAAgB;AAAA,EAC7C;AACD;AAEO,MAAM,0CAA0C,gBAAgB;AAAA,EACtE,YACC,OACA,qBACA,qBAIA,cACA,gCACA,iBAIgB,6BACf;AACD,UAAM,OAAO,qBAAqB,qBAAqB,cAAc,gCAAgC,eAAe;AAFpG;AAAA,EAGjB;AAAA,EA1HD,OAyGuE;AAAA;AAAA;AAkBvE;",
  "names": []
}
