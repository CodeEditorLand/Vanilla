{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/textModelBracketPairs.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { CallbackIterable } from \"../../base/common/arrays.js\";\nimport type { Event } from \"../../base/common/event.js\";\nimport type { IPosition } from \"./core/position.js\";\nimport type { IRange, Range } from \"./core/range.js\";\nimport type {\n\tClosingBracketKind,\n\tOpeningBracketKind,\n} from \"./languages/supports/languageBracketsConfiguration.js\";\nimport type { PairAstNode } from \"./model/bracketPairsTextModelPart/bracketPairsTree/ast.js\";\n\nexport interface IBracketPairsTextModelPart {\n\t/**\n\t * Is fired when bracket pairs change, either due to a text or a settings change.\n\t */\n\tonDidChange: Event<void>;\n\n\t/**\n\t * Gets all bracket pairs that intersect the given position.\n\t * The result is sorted by the start position.\n\t */\n\tgetBracketPairsInRange(range: IRange): CallbackIterable<BracketPairInfo>;\n\n\t/**\n\t * Gets all bracket pairs that intersect the given position.\n\t * The result is sorted by the start position.\n\t */\n\tgetBracketPairsInRangeWithMinIndentation(\n\t\trange: IRange,\n\t): CallbackIterable<BracketPairWithMinIndentationInfo>;\n\n\tgetBracketsInRange(\n\t\trange: IRange,\n\t\tonlyColorizedBrackets?: boolean,\n\t): CallbackIterable<BracketInfo>;\n\n\t/**\n\t * Find the matching bracket of `request` up, counting brackets.\n\t * @param request The bracket we're searching for\n\t * @param position The position at which to start the search.\n\t * @return The range of the matching bracket, or null if the bracket match was not found.\n\t */\n\tfindMatchingBracketUp(\n\t\tbracket: string,\n\t\tposition: IPosition,\n\t\tmaxDuration?: number,\n\t): Range | null;\n\n\t/**\n\t * Find the first bracket in the model before `position`.\n\t * @param position The position at which to start the search.\n\t * @return The info for the first bracket before `position`, or null if there are no more brackets before `positions`.\n\t */\n\tfindPrevBracket(position: IPosition): IFoundBracket | null;\n\n\t/**\n\t * Find the first bracket in the model after `position`.\n\t * @param position The position at which to start the search.\n\t * @return The info for the first bracket after `position`, or null if there are no more brackets after `positions`.\n\t */\n\tfindNextBracket(position: IPosition): IFoundBracket | null;\n\n\t/**\n\t * Find the enclosing brackets that contain `position`.\n\t * @param position The position at which to start the search.\n\t */\n\tfindEnclosingBrackets(\n\t\tposition: IPosition,\n\t\tmaxDuration?: number,\n\t): [Range, Range] | null;\n\n\t/**\n\t * Given a `position`, if the position is on top or near a bracket,\n\t * find the matching bracket of that bracket and return the ranges of both brackets.\n\t * @param position The position at which to look for a bracket.\n\t */\n\tmatchBracket(\n\t\tposition: IPosition,\n\t\tmaxDuration?: number,\n\t): [Range, Range] | null;\n}\n\nexport interface IFoundBracket {\n\trange: Range;\n\tbracketInfo: OpeningBracketKind | ClosingBracketKind;\n}\n\nexport class BracketInfo {\n\tconstructor(\n\t\tpublic readonly range: Range,\n\t\t/** 0-based level */\n\t\tpublic readonly nestingLevel: number,\n\t\tpublic readonly nestingLevelOfEqualBracketType: number,\n\t\tpublic readonly isInvalid: boolean,\n\t) {}\n}\n\nexport class BracketPairInfo {\n\tconstructor(\n\t\tpublic readonly range: Range,\n\t\tpublic readonly openingBracketRange: Range,\n\t\tpublic readonly closingBracketRange: Range | undefined,\n\t\t/** 0-based */\n\t\tpublic readonly nestingLevel: number,\n\t\tpublic readonly nestingLevelOfEqualBracketType: number,\n\t\tprivate readonly bracketPairNode: PairAstNode,\n\t) {}\n\n\tpublic get openingBracketInfo(): OpeningBracketKind {\n\t\treturn this.bracketPairNode.openingBracket\n\t\t\t.bracketInfo as OpeningBracketKind;\n\t}\n\n\tpublic get closingBracketInfo(): ClosingBracketKind | undefined {\n\t\treturn this.bracketPairNode.closingBracket?.bracketInfo as\n\t\t\t| ClosingBracketKind\n\t\t\t| undefined;\n\t}\n}\n\nexport class BracketPairWithMinIndentationInfo extends BracketPairInfo {\n\tconstructor(\n\t\trange: Range,\n\t\topeningBracketRange: Range,\n\t\tclosingBracketRange: Range | undefined,\n\t\t/**\n\t\t * 0-based\n\t\t */\n\t\tnestingLevel: number,\n\t\tnestingLevelOfEqualBracketType: number,\n\t\tbracketPairNode: PairAstNode,\n\t\t/**\n\t\t * -1 if not requested, otherwise the size of the minimum indentation in the bracket pair in terms of visible columns.\n\t\t */\n\t\tpublic readonly minVisibleColumnIndentation: number,\n\t) {\n\t\tsuper(\n\t\t\trange,\n\t\t\topeningBracketRange,\n\t\t\tclosingBracketRange,\n\t\t\tnestingLevel,\n\t\t\tnestingLevelOfEqualBracketType,\n\t\t\tbracketPairNode,\n\t\t);\n\t}\n}\n"],
  "mappings": ";;AA2FO,MAAM,YAAY;AAAA,EACxB,YACiB,OAEA,cACA,gCACA,WACf;AALe;AAEA;AACA;AACA;AAAA,EACd;AAAA,EAlGJ,OA2FyB;AAAA;AAAA;AAQzB;AAEO,MAAM,gBAAgB;AAAA,EAC5B,YACiB,OACA,qBACA,qBAEA,cACA,gCACC,iBAChB;AAPe;AACA;AACA;AAEA;AACA;AACC;AAAA,EACf;AAAA,EA9GJ,OAqG6B;AAAA;AAAA;AAAA,EAW5B,IAAW,qBAAyC;AACnD,WAAO,KAAK,gBAAgB,eAC1B;AAAA,EACH;AAAA,EAEA,IAAW,qBAAqD;AAC/D,WAAO,KAAK,gBAAgB,gBAAgB;AAAA,EAG7C;AACD;AAEO,MAAM,0CAA0C,gBAAgB;AAAA,EACtE,YACC,OACA,qBACA,qBAIA,cACA,gCACA,iBAIgB,6BACf;AACD;AAAA,MACC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACD;AATgB;AAAA,EAUjB;AAAA,EApJD,OA4HuE;AAAA;AAAA;AAyBvE;",
  "names": []
}
