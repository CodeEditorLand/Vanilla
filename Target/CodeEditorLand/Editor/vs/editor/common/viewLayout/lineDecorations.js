import*as b from"../../../base/common/strings.js";import{Constants as D}from"../../../base/common/uint.js";import{InlineDecorationType as m}from"../viewModel.js";import{LinePartMetadata as g}from"./linePart.js";class l{constructor(e,t,s,n){this.startColumn=e;this.endColumn=t;this.className=s;this.type=n}_lineDecorationBrand=void 0;static _equals(e,t){return e.startColumn===t.startColumn&&e.endColumn===t.endColumn&&e.className===t.className&&e.type===t.type}static equalsArr(e,t){const s=e.length,n=t.length;if(s!==n)return!1;for(let o=0;o<s;o++)if(!l._equals(e[o],t[o]))return!1;return!0}static extractWrapped(e,t,s){if(e.length===0)return e;const n=t+1,o=s+1,c=s-t,u=[];let a=0;for(const r of e)r.endColumn<=n||r.startColumn>=o||(u[a++]=new l(Math.max(1,r.startColumn-n+1),Math.min(c+1,r.endColumn-n+1),r.className,r.type));return u}static filter(e,t,s,n){if(e.length===0)return[];const o=[];let c=0;for(let u=0,a=e.length;u<a;u++){const r=e[u],i=r.range;if(i.endLineNumber<t||i.startLineNumber>t||i.isEmpty()&&(r.type===m.Regular||r.type===m.RegularAffectingLetterSpacing))continue;const h=i.startLineNumber===t?i.startColumn:s,f=i.endLineNumber===t?i.endColumn:n;o[c++]=new l(h,f,r.inlineClassName,r.type)}return o}static _typeCompare(e,t){const s=[2,0,1,3];return s[e]-s[t]}static compare(e,t){if(e.startColumn!==t.startColumn)return e.startColumn-t.startColumn;if(e.endColumn!==t.endColumn)return e.endColumn-t.endColumn;const s=l._typeCompare(e.type,t.type);return s!==0?s:e.className!==t.className?e.className<t.className?-1:1:0}}class y{startOffset;endOffset;className;metadata;constructor(e,t,s,n){this.startOffset=e,this.endOffset=t,this.className=s,this.metadata=n}}class p{count;stopOffsets;classNames;metadata;constructor(){this.stopOffsets=[],this.classNames=[],this.metadata=[],this.count=0}static _metadata(e){let t=0;for(let s=0,n=e.length;s<n;s++)t|=e[s];return t}consumeLowerThan(e,t,s){for(;this.count>0&&this.stopOffsets[0]<e;){let n=0;for(;n+1<this.count&&this.stopOffsets[n]===this.stopOffsets[n+1];)n++;s.push(new y(t,this.stopOffsets[n],this.classNames.join(" "),p._metadata(this.metadata))),t=this.stopOffsets[n]+1,this.stopOffsets.splice(0,n+1),this.classNames.splice(0,n+1),this.metadata.splice(0,n+1),this.count-=n+1}return this.count>0&&t<e&&(s.push(new y(t,e-1,this.classNames.join(" "),p._metadata(this.metadata))),t=e),t}insert(e,t,s){if(this.count===0||this.stopOffsets[this.count-1]<=e)this.stopOffsets.push(e),this.classNames.push(t),this.metadata.push(s);else for(let n=0;n<this.count;n++)if(this.stopOffsets[n]>=e){this.stopOffsets.splice(n,0,e),this.classNames.splice(n,0,t),this.metadata.splice(n,0,s);break}this.count++}}class T{static normalize(e,t){if(t.length===0)return[];const s=[],n=new p;let o=0;for(let c=0,u=t.length;c<u;c++){const a=t[c];let r=a.startColumn,i=a.endColumn;const h=a.className,f=a.type===m.Before?g.PSEUDO_BEFORE:a.type===m.After?g.PSEUDO_AFTER:0;if(r>1){const d=e.charCodeAt(r-2);b.isHighSurrogate(d)&&r--}if(i>1){const d=e.charCodeAt(i-2);b.isHighSurrogate(d)&&i--}const C=r-1,N=i-2;o=n.consumeLowerThan(C,o,s),n.count===0&&(o=C),n.insert(N,h,f)}return n.consumeLowerThan(D.MAX_SAFE_SMALL_INTEGER,o,s),s}}export{y as DecorationSegment,l as LineDecoration,T as LineDecorationsNormalizer};
