{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/viewLayout/viewLineRenderer.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as nls from '../../../nls.js';\nimport { CharCode } from '../../../base/common/charCode.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { IViewLineTokens } from '../tokens/lineTokens.js';\nimport { StringBuilder } from '../core/stringBuilder.js';\nimport { LineDecoration, LineDecorationsNormalizer } from './lineDecorations.js';\nimport { InlineDecorationType } from '../viewModel.js';\nimport { LinePart, LinePartMetadata } from './linePart.js';\n\nexport const enum RenderWhitespace {\n\tNone = 0,\n\tBoundary = 1,\n\tSelection = 2,\n\tTrailing = 3,\n\tAll = 4\n}\n\nexport class LineRange {\n\t/**\n\t * Zero-based offset on which the range starts, inclusive.\n\t */\n\tpublic readonly startOffset: number;\n\n\t/**\n\t * Zero-based offset on which the range ends, inclusive.\n\t */\n\tpublic readonly endOffset: number;\n\n\tconstructor(startIndex: number, endIndex: number) {\n\t\tthis.startOffset = startIndex;\n\t\tthis.endOffset = endIndex;\n\t}\n\n\tpublic equals(otherLineRange: LineRange) {\n\t\treturn this.startOffset === otherLineRange.startOffset\n\t\t\t&& this.endOffset === otherLineRange.endOffset;\n\t}\n}\n\nexport class RenderLineInput {\n\n\tpublic readonly useMonospaceOptimizations: boolean;\n\tpublic readonly canUseHalfwidthRightwardsArrow: boolean;\n\tpublic readonly lineContent: string;\n\tpublic readonly continuesWithWrappedLine: boolean;\n\tpublic readonly isBasicASCII: boolean;\n\tpublic readonly containsRTL: boolean;\n\tpublic readonly fauxIndentLength: number;\n\tpublic readonly lineTokens: IViewLineTokens;\n\tpublic readonly lineDecorations: LineDecoration[];\n\tpublic readonly tabSize: number;\n\tpublic readonly startVisibleColumn: number;\n\tpublic readonly spaceWidth: number;\n\tpublic readonly renderSpaceWidth: number;\n\tpublic readonly renderSpaceCharCode: number;\n\tpublic readonly stopRenderingLineAfter: number;\n\tpublic readonly renderWhitespace: RenderWhitespace;\n\tpublic readonly renderControlCharacters: boolean;\n\tpublic readonly fontLigatures: boolean;\n\n\t/**\n\t * Defined only when renderWhitespace is 'selection'. Selections are non-overlapping,\n\t * and ordered by position within the line.\n\t */\n\tpublic readonly selectionsOnLine: LineRange[] | null;\n\n\tconstructor(\n\t\tuseMonospaceOptimizations: boolean,\n\t\tcanUseHalfwidthRightwardsArrow: boolean,\n\t\tlineContent: string,\n\t\tcontinuesWithWrappedLine: boolean,\n\t\tisBasicASCII: boolean,\n\t\tcontainsRTL: boolean,\n\t\tfauxIndentLength: number,\n\t\tlineTokens: IViewLineTokens,\n\t\tlineDecorations: LineDecoration[],\n\t\ttabSize: number,\n\t\tstartVisibleColumn: number,\n\t\tspaceWidth: number,\n\t\tmiddotWidth: number,\n\t\twsmiddotWidth: number,\n\t\tstopRenderingLineAfter: number,\n\t\trenderWhitespace: 'none' | 'boundary' | 'selection' | 'trailing' | 'all',\n\t\trenderControlCharacters: boolean,\n\t\tfontLigatures: boolean,\n\t\tselectionsOnLine: LineRange[] | null\n\t) {\n\t\tthis.useMonospaceOptimizations = useMonospaceOptimizations;\n\t\tthis.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n\t\tthis.lineContent = lineContent;\n\t\tthis.continuesWithWrappedLine = continuesWithWrappedLine;\n\t\tthis.isBasicASCII = isBasicASCII;\n\t\tthis.containsRTL = containsRTL;\n\t\tthis.fauxIndentLength = fauxIndentLength;\n\t\tthis.lineTokens = lineTokens;\n\t\tthis.lineDecorations = lineDecorations.sort(LineDecoration.compare);\n\t\tthis.tabSize = tabSize;\n\t\tthis.startVisibleColumn = startVisibleColumn;\n\t\tthis.spaceWidth = spaceWidth;\n\t\tthis.stopRenderingLineAfter = stopRenderingLineAfter;\n\t\tthis.renderWhitespace = (\n\t\t\trenderWhitespace === 'all'\n\t\t\t\t? RenderWhitespace.All\n\t\t\t\t: renderWhitespace === 'boundary'\n\t\t\t\t\t? RenderWhitespace.Boundary\n\t\t\t\t\t: renderWhitespace === 'selection'\n\t\t\t\t\t\t? RenderWhitespace.Selection\n\t\t\t\t\t\t: renderWhitespace === 'trailing'\n\t\t\t\t\t\t\t? RenderWhitespace.Trailing\n\t\t\t\t\t\t\t: RenderWhitespace.None\n\t\t);\n\t\tthis.renderControlCharacters = renderControlCharacters;\n\t\tthis.fontLigatures = fontLigatures;\n\t\tthis.selectionsOnLine = selectionsOnLine && selectionsOnLine.sort((a, b) => a.startOffset < b.startOffset ? -1 : 1);\n\n\t\tconst wsmiddotDiff = Math.abs(wsmiddotWidth - spaceWidth);\n\t\tconst middotDiff = Math.abs(middotWidth - spaceWidth);\n\t\tif (wsmiddotDiff < middotDiff) {\n\t\t\tthis.renderSpaceWidth = wsmiddotWidth;\n\t\t\tthis.renderSpaceCharCode = 0x2E31; // U+2E31 - WORD SEPARATOR MIDDLE DOT\n\t\t} else {\n\t\t\tthis.renderSpaceWidth = middotWidth;\n\t\t\tthis.renderSpaceCharCode = 0xB7; // U+00B7 - MIDDLE DOT\n\t\t}\n\t}\n\n\tprivate sameSelection(otherSelections: LineRange[] | null): boolean {\n\t\tif (this.selectionsOnLine === null) {\n\t\t\treturn otherSelections === null;\n\t\t}\n\n\t\tif (otherSelections === null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (otherSelections.length !== this.selectionsOnLine.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (let i = 0; i < this.selectionsOnLine.length; i++) {\n\t\t\tif (!this.selectionsOnLine[i].equals(otherSelections[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic equals(other: RenderLineInput): boolean {\n\t\treturn (\n\t\t\tthis.useMonospaceOptimizations === other.useMonospaceOptimizations\n\t\t\t&& this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow\n\t\t\t&& this.lineContent === other.lineContent\n\t\t\t&& this.continuesWithWrappedLine === other.continuesWithWrappedLine\n\t\t\t&& this.isBasicASCII === other.isBasicASCII\n\t\t\t&& this.containsRTL === other.containsRTL\n\t\t\t&& this.fauxIndentLength === other.fauxIndentLength\n\t\t\t&& this.tabSize === other.tabSize\n\t\t\t&& this.startVisibleColumn === other.startVisibleColumn\n\t\t\t&& this.spaceWidth === other.spaceWidth\n\t\t\t&& this.renderSpaceWidth === other.renderSpaceWidth\n\t\t\t&& this.renderSpaceCharCode === other.renderSpaceCharCode\n\t\t\t&& this.stopRenderingLineAfter === other.stopRenderingLineAfter\n\t\t\t&& this.renderWhitespace === other.renderWhitespace\n\t\t\t&& this.renderControlCharacters === other.renderControlCharacters\n\t\t\t&& this.fontLigatures === other.fontLigatures\n\t\t\t&& LineDecoration.equalsArr(this.lineDecorations, other.lineDecorations)\n\t\t\t&& this.lineTokens.equals(other.lineTokens)\n\t\t\t&& this.sameSelection(other.selectionsOnLine)\n\t\t);\n\t}\n}\n\nconst enum CharacterMappingConstants {\n\tPART_INDEX_MASK = 0b11111111111111110000000000000000,\n\tCHAR_INDEX_MASK = 0b00000000000000001111111111111111,\n\n\tCHAR_INDEX_OFFSET = 0,\n\tPART_INDEX_OFFSET = 16\n}\n\nexport class DomPosition {\n\tconstructor(\n\t\tpublic readonly partIndex: number,\n\t\tpublic readonly charIndex: number\n\t) { }\n}\n\n/**\n * Provides a both direction mapping between a line's character and its rendered position.\n */\nexport class CharacterMapping {\n\n\tprivate static getPartIndex(partData: number): number {\n\t\treturn (partData & CharacterMappingConstants.PART_INDEX_MASK) >>> CharacterMappingConstants.PART_INDEX_OFFSET;\n\t}\n\n\tprivate static getCharIndex(partData: number): number {\n\t\treturn (partData & CharacterMappingConstants.CHAR_INDEX_MASK) >>> CharacterMappingConstants.CHAR_INDEX_OFFSET;\n\t}\n\n\tpublic readonly length: number;\n\tprivate readonly _data: Uint32Array;\n\tprivate readonly _horizontalOffset: Uint32Array;\n\n\tconstructor(length: number, partCount: number) {\n\t\tthis.length = length;\n\t\tthis._data = new Uint32Array(this.length);\n\t\tthis._horizontalOffset = new Uint32Array(this.length);\n\t}\n\n\tpublic setColumnInfo(column: number, partIndex: number, charIndex: number, horizontalOffset: number): void {\n\t\tconst partData = (\n\t\t\t(partIndex << CharacterMappingConstants.PART_INDEX_OFFSET)\n\t\t\t| (charIndex << CharacterMappingConstants.CHAR_INDEX_OFFSET)\n\t\t) >>> 0;\n\t\tthis._data[column - 1] = partData;\n\t\tthis._horizontalOffset[column - 1] = horizontalOffset;\n\t}\n\n\tpublic getHorizontalOffset(column: number): number {\n\t\tif (this._horizontalOffset.length === 0) {\n\t\t\t// No characters on this line\n\t\t\treturn 0;\n\t\t}\n\t\treturn this._horizontalOffset[column - 1];\n\t}\n\n\tprivate charOffsetToPartData(charOffset: number): number {\n\t\tif (this.length === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (charOffset < 0) {\n\t\t\treturn this._data[0];\n\t\t}\n\t\tif (charOffset >= this.length) {\n\t\t\treturn this._data[this.length - 1];\n\t\t}\n\t\treturn this._data[charOffset];\n\t}\n\n\tpublic getDomPosition(column: number): DomPosition {\n\t\tconst partData = this.charOffsetToPartData(column - 1);\n\t\tconst partIndex = CharacterMapping.getPartIndex(partData);\n\t\tconst charIndex = CharacterMapping.getCharIndex(partData);\n\t\treturn new DomPosition(partIndex, charIndex);\n\t}\n\n\tpublic getColumn(domPosition: DomPosition, partLength: number): number {\n\t\tconst charOffset = this.partDataToCharOffset(domPosition.partIndex, partLength, domPosition.charIndex);\n\t\treturn charOffset + 1;\n\t}\n\n\tprivate partDataToCharOffset(partIndex: number, partLength: number, charIndex: number): number {\n\t\tif (this.length === 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tconst searchEntry = (\n\t\t\t(partIndex << CharacterMappingConstants.PART_INDEX_OFFSET)\n\t\t\t| (charIndex << CharacterMappingConstants.CHAR_INDEX_OFFSET)\n\t\t) >>> 0;\n\n\t\tlet min = 0;\n\t\tlet max = this.length - 1;\n\t\twhile (min + 1 < max) {\n\t\t\tconst mid = ((min + max) >>> 1);\n\t\t\tconst midEntry = this._data[mid];\n\t\t\tif (midEntry === searchEntry) {\n\t\t\t\treturn mid;\n\t\t\t} else if (midEntry > searchEntry) {\n\t\t\t\tmax = mid;\n\t\t\t} else {\n\t\t\t\tmin = mid;\n\t\t\t}\n\t\t}\n\n\t\tif (min === max) {\n\t\t\treturn min;\n\t\t}\n\n\t\tconst minEntry = this._data[min];\n\t\tconst maxEntry = this._data[max];\n\n\t\tif (minEntry === searchEntry) {\n\t\t\treturn min;\n\t\t}\n\t\tif (maxEntry === searchEntry) {\n\t\t\treturn max;\n\t\t}\n\n\t\tconst minPartIndex = CharacterMapping.getPartIndex(minEntry);\n\t\tconst minCharIndex = CharacterMapping.getCharIndex(minEntry);\n\n\t\tconst maxPartIndex = CharacterMapping.getPartIndex(maxEntry);\n\t\tlet maxCharIndex: number;\n\n\t\tif (minPartIndex !== maxPartIndex) {\n\t\t\t// sitting between parts\n\t\t\tmaxCharIndex = partLength;\n\t\t} else {\n\t\t\tmaxCharIndex = CharacterMapping.getCharIndex(maxEntry);\n\t\t}\n\n\t\tconst minEntryDistance = charIndex - minCharIndex;\n\t\tconst maxEntryDistance = maxCharIndex - charIndex;\n\n\t\tif (minEntryDistance <= maxEntryDistance) {\n\t\t\treturn min;\n\t\t}\n\t\treturn max;\n\t}\n\n\tpublic inflate() {\n\t\tconst result: [number, number, number][] = [];\n\t\tfor (let i = 0; i < this.length; i++) {\n\t\t\tconst partData = this._data[i];\n\t\t\tconst partIndex = CharacterMapping.getPartIndex(partData);\n\t\t\tconst charIndex = CharacterMapping.getCharIndex(partData);\n\t\t\tconst visibleColumn = this._horizontalOffset[i];\n\t\t\tresult.push([partIndex, charIndex, visibleColumn]);\n\t\t}\n\t\treturn result;\n\t}\n}\n\nexport const enum ForeignElementType {\n\tNone = 0,\n\tBefore = 1,\n\tAfter = 2\n}\n\nexport class RenderLineOutput {\n\t_renderLineOutputBrand: void = undefined;\n\n\treadonly characterMapping: CharacterMapping;\n\treadonly containsRTL: boolean;\n\treadonly containsForeignElements: ForeignElementType;\n\n\tconstructor(characterMapping: CharacterMapping, containsRTL: boolean, containsForeignElements: ForeignElementType) {\n\t\tthis.characterMapping = characterMapping;\n\t\tthis.containsRTL = containsRTL;\n\t\tthis.containsForeignElements = containsForeignElements;\n\t}\n}\n\nexport function renderViewLine(input: RenderLineInput, sb: StringBuilder): RenderLineOutput {\n\tif (input.lineContent.length === 0) {\n\n\t\tif (input.lineDecorations.length > 0) {\n\t\t\t// This line is empty, but it contains inline decorations\n\t\t\tsb.appendString(`<span>`);\n\n\t\t\tlet beforeCount = 0;\n\t\t\tlet afterCount = 0;\n\t\t\tlet containsForeignElements = ForeignElementType.None;\n\t\t\tfor (const lineDecoration of input.lineDecorations) {\n\t\t\t\tif (lineDecoration.type === InlineDecorationType.Before || lineDecoration.type === InlineDecorationType.After) {\n\t\t\t\t\tsb.appendString(`<span class=\"`);\n\t\t\t\t\tsb.appendString(lineDecoration.className);\n\t\t\t\t\tsb.appendString(`\"></span>`);\n\n\t\t\t\t\tif (lineDecoration.type === InlineDecorationType.Before) {\n\t\t\t\t\t\tcontainsForeignElements |= ForeignElementType.Before;\n\t\t\t\t\t\tbeforeCount++;\n\t\t\t\t\t}\n\t\t\t\t\tif (lineDecoration.type === InlineDecorationType.After) {\n\t\t\t\t\t\tcontainsForeignElements |= ForeignElementType.After;\n\t\t\t\t\t\tafterCount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsb.appendString(`</span>`);\n\n\t\t\tconst characterMapping = new CharacterMapping(1, beforeCount + afterCount);\n\t\t\tcharacterMapping.setColumnInfo(1, beforeCount, 0, 0);\n\n\t\t\treturn new RenderLineOutput(\n\t\t\t\tcharacterMapping,\n\t\t\t\tfalse,\n\t\t\t\tcontainsForeignElements\n\t\t\t);\n\t\t}\n\n\t\t// completely empty line\n\t\tsb.appendString('<span><span></span></span>');\n\t\treturn new RenderLineOutput(\n\t\t\tnew CharacterMapping(0, 0),\n\t\t\tfalse,\n\t\t\tForeignElementType.None\n\t\t);\n\t}\n\n\treturn _renderLine(resolveRenderLineInput(input), sb);\n}\n\nexport class RenderLineOutput2 {\n\tconstructor(\n\t\tpublic readonly characterMapping: CharacterMapping,\n\t\tpublic readonly html: string,\n\t\tpublic readonly containsRTL: boolean,\n\t\tpublic readonly containsForeignElements: ForeignElementType\n\t) {\n\t}\n}\n\nexport function renderViewLine2(input: RenderLineInput): RenderLineOutput2 {\n\tconst sb = new StringBuilder(10000);\n\tconst out = renderViewLine(input, sb);\n\treturn new RenderLineOutput2(out.characterMapping, sb.build(), out.containsRTL, out.containsForeignElements);\n}\n\nclass ResolvedRenderLineInput {\n\tconstructor(\n\t\tpublic readonly fontIsMonospace: boolean,\n\t\tpublic readonly canUseHalfwidthRightwardsArrow: boolean,\n\t\tpublic readonly lineContent: string,\n\t\tpublic readonly len: number,\n\t\tpublic readonly isOverflowing: boolean,\n\t\tpublic readonly overflowingCharCount: number,\n\t\tpublic readonly parts: LinePart[],\n\t\tpublic readonly containsForeignElements: ForeignElementType,\n\t\tpublic readonly fauxIndentLength: number,\n\t\tpublic readonly tabSize: number,\n\t\tpublic readonly startVisibleColumn: number,\n\t\tpublic readonly containsRTL: boolean,\n\t\tpublic readonly spaceWidth: number,\n\t\tpublic readonly renderSpaceCharCode: number,\n\t\tpublic readonly renderWhitespace: RenderWhitespace,\n\t\tpublic readonly renderControlCharacters: boolean,\n\t) {\n\t\t//\n\t}\n}\n\nfunction resolveRenderLineInput(input: RenderLineInput): ResolvedRenderLineInput {\n\tconst lineContent = input.lineContent;\n\n\tlet isOverflowing: boolean;\n\tlet overflowingCharCount: number;\n\tlet len: number;\n\n\tif (input.stopRenderingLineAfter !== -1 && input.stopRenderingLineAfter < lineContent.length) {\n\t\tisOverflowing = true;\n\t\toverflowingCharCount = lineContent.length - input.stopRenderingLineAfter;\n\t\tlen = input.stopRenderingLineAfter;\n\t} else {\n\t\tisOverflowing = false;\n\t\toverflowingCharCount = 0;\n\t\tlen = lineContent.length;\n\t}\n\n\tlet tokens = transformAndRemoveOverflowing(lineContent, input.containsRTL, input.lineTokens, input.fauxIndentLength, len);\n\tif (input.renderControlCharacters && !input.isBasicASCII) {\n\t\t// Calling `extractControlCharacters` before adding (possibly empty) line parts\n\t\t// for inline decorations. `extractControlCharacters` removes empty line parts.\n\t\ttokens = extractControlCharacters(lineContent, tokens);\n\t}\n\tif (input.renderWhitespace === RenderWhitespace.All ||\n\t\tinput.renderWhitespace === RenderWhitespace.Boundary ||\n\t\t(input.renderWhitespace === RenderWhitespace.Selection && !!input.selectionsOnLine) ||\n\t\t(input.renderWhitespace === RenderWhitespace.Trailing && !input.continuesWithWrappedLine)\n\t) {\n\t\ttokens = _applyRenderWhitespace(input, lineContent, len, tokens);\n\t}\n\tlet containsForeignElements = ForeignElementType.None;\n\tif (input.lineDecorations.length > 0) {\n\t\tfor (let i = 0, len = input.lineDecorations.length; i < len; i++) {\n\t\t\tconst lineDecoration = input.lineDecorations[i];\n\t\t\tif (lineDecoration.type === InlineDecorationType.RegularAffectingLetterSpacing) {\n\t\t\t\t// Pretend there are foreign elements... although not 100% accurate.\n\t\t\t\tcontainsForeignElements |= ForeignElementType.Before;\n\t\t\t} else if (lineDecoration.type === InlineDecorationType.Before) {\n\t\t\t\tcontainsForeignElements |= ForeignElementType.Before;\n\t\t\t} else if (lineDecoration.type === InlineDecorationType.After) {\n\t\t\t\tcontainsForeignElements |= ForeignElementType.After;\n\t\t\t}\n\t\t}\n\t\ttokens = _applyInlineDecorations(lineContent, len, tokens, input.lineDecorations);\n\t}\n\tif (!input.containsRTL) {\n\t\t// We can never split RTL text, as it ruins the rendering\n\t\ttokens = splitLargeTokens(lineContent, tokens, !input.isBasicASCII || input.fontLigatures);\n\t}\n\n\treturn new ResolvedRenderLineInput(\n\t\tinput.useMonospaceOptimizations,\n\t\tinput.canUseHalfwidthRightwardsArrow,\n\t\tlineContent,\n\t\tlen,\n\t\tisOverflowing,\n\t\toverflowingCharCount,\n\t\ttokens,\n\t\tcontainsForeignElements,\n\t\tinput.fauxIndentLength,\n\t\tinput.tabSize,\n\t\tinput.startVisibleColumn,\n\t\tinput.containsRTL,\n\t\tinput.spaceWidth,\n\t\tinput.renderSpaceCharCode,\n\t\tinput.renderWhitespace,\n\t\tinput.renderControlCharacters\n\t);\n}\n\n/**\n * In the rendering phase, characters are always looped until token.endIndex.\n * Ensure that all tokens end before `len` and the last one ends precisely at `len`.\n */\nfunction transformAndRemoveOverflowing(lineContent: string, lineContainsRTL: boolean, tokens: IViewLineTokens, fauxIndentLength: number, len: number): LinePart[] {\n\tconst result: LinePart[] = [];\n\tlet resultLen = 0;\n\n\t// The faux indent part of the line should have no token type\n\tif (fauxIndentLength > 0) {\n\t\tresult[resultLen++] = new LinePart(fauxIndentLength, '', 0, false);\n\t}\n\tlet startOffset = fauxIndentLength;\n\tfor (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n\t\tconst endIndex = tokens.getEndOffset(tokenIndex);\n\t\tif (endIndex <= fauxIndentLength) {\n\t\t\t// The faux indent part of the line should have no token type\n\t\t\tcontinue;\n\t\t}\n\t\tconst type = tokens.getClassName(tokenIndex);\n\t\tif (endIndex >= len) {\n\t\t\tconst tokenContainsRTL = (lineContainsRTL ? strings.containsRTL(lineContent.substring(startOffset, len)) : false);\n\t\t\tresult[resultLen++] = new LinePart(len, type, 0, tokenContainsRTL);\n\t\t\tbreak;\n\t\t}\n\t\tconst tokenContainsRTL = (lineContainsRTL ? strings.containsRTL(lineContent.substring(startOffset, endIndex)) : false);\n\t\tresult[resultLen++] = new LinePart(endIndex, type, 0, tokenContainsRTL);\n\t\tstartOffset = endIndex;\n\t}\n\n\treturn result;\n}\n\n/**\n * written as a const enum to get value inlining.\n */\nconst enum Constants {\n\tLongToken = 50\n}\n\n/**\n * See https://github.com/microsoft/vscode/issues/6885.\n * It appears that having very large spans causes very slow reading of character positions.\n * So here we try to avoid that.\n */\nfunction splitLargeTokens(lineContent: string, tokens: LinePart[], onlyAtSpaces: boolean): LinePart[] {\n\tlet lastTokenEndIndex = 0;\n\tconst result: LinePart[] = [];\n\tlet resultLen = 0;\n\n\tif (onlyAtSpaces) {\n\t\t// Split only at spaces => we need to walk each character\n\t\tfor (let i = 0, len = tokens.length; i < len; i++) {\n\t\t\tconst token = tokens[i];\n\t\t\tconst tokenEndIndex = token.endIndex;\n\t\t\tif (lastTokenEndIndex + Constants.LongToken < tokenEndIndex) {\n\t\t\t\tconst tokenType = token.type;\n\t\t\t\tconst tokenMetadata = token.metadata;\n\t\t\t\tconst tokenContainsRTL = token.containsRTL;\n\n\t\t\t\tlet lastSpaceOffset = -1;\n\t\t\t\tlet currTokenStart = lastTokenEndIndex;\n\t\t\t\tfor (let j = lastTokenEndIndex; j < tokenEndIndex; j++) {\n\t\t\t\t\tif (lineContent.charCodeAt(j) === CharCode.Space) {\n\t\t\t\t\t\tlastSpaceOffset = j;\n\t\t\t\t\t}\n\t\t\t\t\tif (lastSpaceOffset !== -1 && j - currTokenStart >= Constants.LongToken) {\n\t\t\t\t\t\t// Split at `lastSpaceOffset` + 1\n\t\t\t\t\t\tresult[resultLen++] = new LinePart(lastSpaceOffset + 1, tokenType, tokenMetadata, tokenContainsRTL);\n\t\t\t\t\t\tcurrTokenStart = lastSpaceOffset + 1;\n\t\t\t\t\t\tlastSpaceOffset = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currTokenStart !== tokenEndIndex) {\n\t\t\t\t\tresult[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult[resultLen++] = token;\n\t\t\t}\n\n\t\t\tlastTokenEndIndex = tokenEndIndex;\n\t\t}\n\t} else {\n\t\t// Split anywhere => we don't need to walk each character\n\t\tfor (let i = 0, len = tokens.length; i < len; i++) {\n\t\t\tconst token = tokens[i];\n\t\t\tconst tokenEndIndex = token.endIndex;\n\t\t\tconst diff = (tokenEndIndex - lastTokenEndIndex);\n\t\t\tif (diff > Constants.LongToken) {\n\t\t\t\tconst tokenType = token.type;\n\t\t\t\tconst tokenMetadata = token.metadata;\n\t\t\t\tconst tokenContainsRTL = token.containsRTL;\n\t\t\t\tconst piecesCount = Math.ceil(diff / Constants.LongToken);\n\t\t\t\tfor (let j = 1; j < piecesCount; j++) {\n\t\t\t\t\tconst pieceEndIndex = lastTokenEndIndex + (j * Constants.LongToken);\n\t\t\t\t\tresult[resultLen++] = new LinePart(pieceEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n\t\t\t\t}\n\t\t\t\tresult[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n\t\t\t} else {\n\t\t\t\tresult[resultLen++] = token;\n\t\t\t}\n\t\t\tlastTokenEndIndex = tokenEndIndex;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nfunction isControlCharacter(charCode: number): boolean {\n\tif (charCode < 32) {\n\t\treturn (charCode !== CharCode.Tab);\n\t}\n\tif (charCode === 127) {\n\t\t// DEL\n\t\treturn true;\n\t}\n\n\tif (\n\t\t(charCode >= 0x202A && charCode <= 0x202E)\n\t\t|| (charCode >= 0x2066 && charCode <= 0x2069)\n\t\t|| (charCode >= 0x200E && charCode <= 0x200F)\n\t\t|| charCode === 0x061C\n\t) {\n\t\t// Unicode Directional Formatting Characters\n\t\t// LRE\tU+202A\tLEFT-TO-RIGHT EMBEDDING\n\t\t// RLE\tU+202B\tRIGHT-TO-LEFT EMBEDDING\n\t\t// PDF\tU+202C\tPOP DIRECTIONAL FORMATTING\n\t\t// LRO\tU+202D\tLEFT-TO-RIGHT OVERRIDE\n\t\t// RLO\tU+202E\tRIGHT-TO-LEFT OVERRIDE\n\t\t// LRI\tU+2066\tLEFT-TO-RIGHT ISOLATE\n\t\t// RLI\tU+2067\tRIGHT-TO-LEFT ISOLATE\n\t\t// FSI\tU+2068\tFIRST STRONG ISOLATE\n\t\t// PDI\tU+2069\tPOP DIRECTIONAL ISOLATE\n\t\t// LRM\tU+200E\tLEFT-TO-RIGHT MARK\n\t\t// RLM\tU+200F\tRIGHT-TO-LEFT MARK\n\t\t// ALM\tU+061C\tARABIC LETTER MARK\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nfunction extractControlCharacters(lineContent: string, tokens: LinePart[]): LinePart[] {\n\tconst result: LinePart[] = [];\n\tlet lastLinePart: LinePart = new LinePart(0, '', 0, false);\n\tlet charOffset = 0;\n\tfor (const token of tokens) {\n\t\tconst tokenEndIndex = token.endIndex;\n\t\tfor (; charOffset < tokenEndIndex; charOffset++) {\n\t\t\tconst charCode = lineContent.charCodeAt(charOffset);\n\t\t\tif (isControlCharacter(charCode)) {\n\t\t\t\tif (charOffset > lastLinePart.endIndex) {\n\t\t\t\t\t// emit previous part if it has text\n\t\t\t\t\tlastLinePart = new LinePart(charOffset, token.type, token.metadata, token.containsRTL);\n\t\t\t\t\tresult.push(lastLinePart);\n\t\t\t\t}\n\t\t\t\tlastLinePart = new LinePart(charOffset + 1, 'mtkcontrol', token.metadata, false);\n\t\t\t\tresult.push(lastLinePart);\n\t\t\t}\n\t\t}\n\t\tif (charOffset > lastLinePart.endIndex) {\n\t\t\t// emit previous part if it has text\n\t\t\tlastLinePart = new LinePart(tokenEndIndex, token.type, token.metadata, token.containsRTL);\n\t\t\tresult.push(lastLinePart);\n\t\t}\n\t}\n\treturn result;\n}\n\n/**\n * Whitespace is rendered by \"replacing\" tokens with a special-purpose `mtkw` type that is later recognized in the rendering phase.\n * Moreover, a token is created for every visual indent because on some fonts the glyphs used for rendering whitespace (&rarr; or &middot;) do not have the same width as &nbsp;.\n * The rendering phase will generate `style=\"width:...\"` for these tokens.\n */\nfunction _applyRenderWhitespace(input: RenderLineInput, lineContent: string, len: number, tokens: LinePart[]): LinePart[] {\n\n\tconst continuesWithWrappedLine = input.continuesWithWrappedLine;\n\tconst fauxIndentLength = input.fauxIndentLength;\n\tconst tabSize = input.tabSize;\n\tconst startVisibleColumn = input.startVisibleColumn;\n\tconst useMonospaceOptimizations = input.useMonospaceOptimizations;\n\tconst selections = input.selectionsOnLine;\n\tconst onlyBoundary = (input.renderWhitespace === RenderWhitespace.Boundary);\n\tconst onlyTrailing = (input.renderWhitespace === RenderWhitespace.Trailing);\n\tconst generateLinePartForEachWhitespace = (input.renderSpaceWidth !== input.spaceWidth);\n\n\tconst result: LinePart[] = [];\n\tlet resultLen = 0;\n\tlet tokenIndex = 0;\n\tlet tokenType = tokens[tokenIndex].type;\n\tlet tokenContainsRTL = tokens[tokenIndex].containsRTL;\n\tlet tokenEndIndex = tokens[tokenIndex].endIndex;\n\tconst tokensLength = tokens.length;\n\n\tlet lineIsEmptyOrWhitespace = false;\n\tlet firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n\tlet lastNonWhitespaceIndex: number;\n\tif (firstNonWhitespaceIndex === -1) {\n\t\tlineIsEmptyOrWhitespace = true;\n\t\tfirstNonWhitespaceIndex = len;\n\t\tlastNonWhitespaceIndex = len;\n\t} else {\n\t\tlastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);\n\t}\n\n\tlet wasInWhitespace = false;\n\tlet currentSelectionIndex = 0;\n\tlet currentSelection = selections && selections[currentSelectionIndex];\n\tlet tmpIndent = startVisibleColumn % tabSize;\n\tfor (let charIndex = fauxIndentLength; charIndex < len; charIndex++) {\n\t\tconst chCode = lineContent.charCodeAt(charIndex);\n\n\t\tif (currentSelection && charIndex >= currentSelection.endOffset) {\n\t\t\tcurrentSelectionIndex++;\n\t\t\tcurrentSelection = selections && selections[currentSelectionIndex];\n\t\t}\n\n\t\tlet isInWhitespace: boolean;\n\t\tif (charIndex < firstNonWhitespaceIndex || charIndex > lastNonWhitespaceIndex) {\n\t\t\t// in leading or trailing whitespace\n\t\t\tisInWhitespace = true;\n\t\t} else if (chCode === CharCode.Tab) {\n\t\t\t// a tab character is rendered both in all and boundary cases\n\t\t\tisInWhitespace = true;\n\t\t} else if (chCode === CharCode.Space) {\n\t\t\t// hit a space character\n\t\t\tif (onlyBoundary) {\n\t\t\t\t// rendering only boundary whitespace\n\t\t\t\tif (wasInWhitespace) {\n\t\t\t\t\tisInWhitespace = true;\n\t\t\t\t} else {\n\t\t\t\t\tconst nextChCode = (charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : CharCode.Null);\n\t\t\t\t\tisInWhitespace = (nextChCode === CharCode.Space || nextChCode === CharCode.Tab);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tisInWhitespace = true;\n\t\t\t}\n\t\t} else {\n\t\t\tisInWhitespace = false;\n\t\t}\n\n\t\t// If rendering whitespace on selection, check that the charIndex falls within a selection\n\t\tif (isInWhitespace && selections) {\n\t\t\tisInWhitespace = !!currentSelection && currentSelection.startOffset <= charIndex && currentSelection.endOffset > charIndex;\n\t\t}\n\n\t\t// If rendering only trailing whitespace, check that the charIndex points to trailing whitespace.\n\t\tif (isInWhitespace && onlyTrailing) {\n\t\t\tisInWhitespace = lineIsEmptyOrWhitespace || charIndex > lastNonWhitespaceIndex;\n\t\t}\n\n\t\tif (isInWhitespace && tokenContainsRTL) {\n\t\t\t// If the token contains RTL text, breaking it up into multiple line parts\n\t\t\t// to render whitespace might affect the browser's bidi layout.\n\t\t\t//\n\t\t\t// We render whitespace in such tokens only if the whitespace\n\t\t\t// is the leading or the trailing whitespace of the line,\n\t\t\t// which doesn't affect the browser's bidi layout.\n\t\t\tif (charIndex >= firstNonWhitespaceIndex && charIndex <= lastNonWhitespaceIndex) {\n\t\t\t\tisInWhitespace = false;\n\t\t\t}\n\t\t}\n\n\t\tif (wasInWhitespace) {\n\t\t\t// was in whitespace token\n\t\t\tif (!isInWhitespace || (!useMonospaceOptimizations && tmpIndent >= tabSize)) {\n\t\t\t\t// leaving whitespace token or entering a new indent\n\t\t\t\tif (generateLinePartForEachWhitespace) {\n\t\t\t\t\tconst lastEndIndex = (resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength);\n\t\t\t\t\tfor (let i = lastEndIndex + 1; i <= charIndex; i++) {\n\t\t\t\t\t\tresult[resultLen++] = new LinePart(i, 'mtkw', LinePartMetadata.IS_WHITESPACE, false);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresult[resultLen++] = new LinePart(charIndex, 'mtkw', LinePartMetadata.IS_WHITESPACE, false);\n\t\t\t\t}\n\t\t\t\ttmpIndent = tmpIndent % tabSize;\n\t\t\t}\n\t\t} else {\n\t\t\t// was in regular token\n\t\t\tif (charIndex === tokenEndIndex || (isInWhitespace && charIndex > fauxIndentLength)) {\n\t\t\t\tresult[resultLen++] = new LinePart(charIndex, tokenType, 0, tokenContainsRTL);\n\t\t\t\ttmpIndent = tmpIndent % tabSize;\n\t\t\t}\n\t\t}\n\n\t\tif (chCode === CharCode.Tab) {\n\t\t\ttmpIndent = tabSize;\n\t\t} else if (strings.isFullWidthCharacter(chCode)) {\n\t\t\ttmpIndent += 2;\n\t\t} else {\n\t\t\ttmpIndent++;\n\t\t}\n\n\t\twasInWhitespace = isInWhitespace;\n\n\t\twhile (charIndex === tokenEndIndex) {\n\t\t\ttokenIndex++;\n\t\t\tif (tokenIndex < tokensLength) {\n\t\t\t\ttokenType = tokens[tokenIndex].type;\n\t\t\t\ttokenContainsRTL = tokens[tokenIndex].containsRTL;\n\t\t\t\ttokenEndIndex = tokens[tokenIndex].endIndex;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tlet generateWhitespace = false;\n\tif (wasInWhitespace) {\n\t\t// was in whitespace token\n\t\tif (continuesWithWrappedLine && onlyBoundary) {\n\t\t\tconst lastCharCode = (len > 0 ? lineContent.charCodeAt(len - 1) : CharCode.Null);\n\t\t\tconst prevCharCode = (len > 1 ? lineContent.charCodeAt(len - 2) : CharCode.Null);\n\t\t\tconst isSingleTrailingSpace = (lastCharCode === CharCode.Space && (prevCharCode !== CharCode.Space && prevCharCode !== CharCode.Tab));\n\t\t\tif (!isSingleTrailingSpace) {\n\t\t\t\tgenerateWhitespace = true;\n\t\t\t}\n\t\t} else {\n\t\t\tgenerateWhitespace = true;\n\t\t}\n\t}\n\n\tif (generateWhitespace) {\n\t\tif (generateLinePartForEachWhitespace) {\n\t\t\tconst lastEndIndex = (resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength);\n\t\t\tfor (let i = lastEndIndex + 1; i <= len; i++) {\n\t\t\t\tresult[resultLen++] = new LinePart(i, 'mtkw', LinePartMetadata.IS_WHITESPACE, false);\n\t\t\t}\n\t\t} else {\n\t\t\tresult[resultLen++] = new LinePart(len, 'mtkw', LinePartMetadata.IS_WHITESPACE, false);\n\t\t}\n\t} else {\n\t\tresult[resultLen++] = new LinePart(len, tokenType, 0, tokenContainsRTL);\n\t}\n\n\treturn result;\n}\n\n/**\n * Inline decorations are \"merged\" on top of tokens.\n * Special care must be taken when multiple inline decorations are at play and they overlap.\n */\nfunction _applyInlineDecorations(lineContent: string, len: number, tokens: LinePart[], _lineDecorations: LineDecoration[]): LinePart[] {\n\t_lineDecorations.sort(LineDecoration.compare);\n\tconst lineDecorations = LineDecorationsNormalizer.normalize(lineContent, _lineDecorations);\n\tconst lineDecorationsLen = lineDecorations.length;\n\n\tlet lineDecorationIndex = 0;\n\tconst result: LinePart[] = [];\n\tlet resultLen = 0;\n\tlet lastResultEndIndex = 0;\n\tfor (let tokenIndex = 0, len = tokens.length; tokenIndex < len; tokenIndex++) {\n\t\tconst token = tokens[tokenIndex];\n\t\tconst tokenEndIndex = token.endIndex;\n\t\tconst tokenType = token.type;\n\t\tconst tokenMetadata = token.metadata;\n\t\tconst tokenContainsRTL = token.containsRTL;\n\n\t\twhile (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset < tokenEndIndex) {\n\t\t\tconst lineDecoration = lineDecorations[lineDecorationIndex];\n\n\t\t\tif (lineDecoration.startOffset > lastResultEndIndex) {\n\t\t\t\tlastResultEndIndex = lineDecoration.startOffset;\n\t\t\t\tresult[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n\t\t\t}\n\n\t\t\tif (lineDecoration.endOffset + 1 <= tokenEndIndex) {\n\t\t\t\t// This line decoration ends before this token ends\n\t\t\t\tlastResultEndIndex = lineDecoration.endOffset + 1;\n\t\t\t\tresult[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata, tokenContainsRTL);\n\t\t\t\tlineDecorationIndex++;\n\t\t\t} else {\n\t\t\t\t// This line decoration continues on to the next token\n\t\t\t\tlastResultEndIndex = tokenEndIndex;\n\t\t\t\tresult[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata, tokenContainsRTL);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (tokenEndIndex > lastResultEndIndex) {\n\t\t\tlastResultEndIndex = tokenEndIndex;\n\t\t\tresult[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n\t\t}\n\t}\n\n\tconst lastTokenEndIndex = tokens[tokens.length - 1].endIndex;\n\tif (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n\t\twhile (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n\t\t\tconst lineDecoration = lineDecorations[lineDecorationIndex];\n\t\t\tresult[resultLen++] = new LinePart(lastResultEndIndex, lineDecoration.className, lineDecoration.metadata, false);\n\t\t\tlineDecorationIndex++;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * This function is on purpose not split up into multiple functions to allow runtime type inference (i.e. performance reasons).\n * Notice how all the needed data is fully resolved and passed in (i.e. no other calls).\n */\nfunction _renderLine(input: ResolvedRenderLineInput, sb: StringBuilder): RenderLineOutput {\n\tconst fontIsMonospace = input.fontIsMonospace;\n\tconst canUseHalfwidthRightwardsArrow = input.canUseHalfwidthRightwardsArrow;\n\tconst containsForeignElements = input.containsForeignElements;\n\tconst lineContent = input.lineContent;\n\tconst len = input.len;\n\tconst isOverflowing = input.isOverflowing;\n\tconst overflowingCharCount = input.overflowingCharCount;\n\tconst parts = input.parts;\n\tconst fauxIndentLength = input.fauxIndentLength;\n\tconst tabSize = input.tabSize;\n\tconst startVisibleColumn = input.startVisibleColumn;\n\tconst containsRTL = input.containsRTL;\n\tconst spaceWidth = input.spaceWidth;\n\tconst renderSpaceCharCode = input.renderSpaceCharCode;\n\tconst renderWhitespace = input.renderWhitespace;\n\tconst renderControlCharacters = input.renderControlCharacters;\n\n\tconst characterMapping = new CharacterMapping(len + 1, parts.length);\n\tlet lastCharacterMappingDefined = false;\n\n\tlet charIndex = 0;\n\tlet visibleColumn = startVisibleColumn;\n\tlet charOffsetInPart = 0; // the character offset in the current part\n\tlet charHorizontalOffset = 0; // the character horizontal position in terms of chars relative to line start\n\n\tlet partDisplacement = 0;\n\n\tif (containsRTL) {\n\t\tsb.appendString('<span dir=\"ltr\">');\n\t} else {\n\t\tsb.appendString('<span>');\n\t}\n\n\tfor (let partIndex = 0, tokensLen = parts.length; partIndex < tokensLen; partIndex++) {\n\n\t\tconst part = parts[partIndex];\n\t\tconst partEndIndex = part.endIndex;\n\t\tconst partType = part.type;\n\t\tconst partContainsRTL = part.containsRTL;\n\t\tconst partRendersWhitespace = (renderWhitespace !== RenderWhitespace.None && part.isWhitespace());\n\t\tconst partRendersWhitespaceWithWidth = partRendersWhitespace && !fontIsMonospace && (partType === 'mtkw'/*only whitespace*/ || !containsForeignElements);\n\t\tconst partIsEmptyAndHasPseudoAfter = (charIndex === partEndIndex && part.isPseudoAfter());\n\t\tcharOffsetInPart = 0;\n\n\t\tsb.appendString('<span ');\n\t\tif (partContainsRTL) {\n\t\t\tsb.appendString('style=\"unicode-bidi:isolate\" ');\n\t\t}\n\t\tsb.appendString('class=\"');\n\t\tsb.appendString(partRendersWhitespaceWithWidth ? 'mtkz' : partType);\n\t\tsb.appendASCIICharCode(CharCode.DoubleQuote);\n\n\t\tif (partRendersWhitespace) {\n\n\t\t\tlet partWidth = 0;\n\t\t\t{\n\t\t\t\tlet _charIndex = charIndex;\n\t\t\t\tlet _visibleColumn = visibleColumn;\n\n\t\t\t\tfor (; _charIndex < partEndIndex; _charIndex++) {\n\t\t\t\t\tconst charCode = lineContent.charCodeAt(_charIndex);\n\t\t\t\t\tconst charWidth = (charCode === CharCode.Tab ? (tabSize - (_visibleColumn % tabSize)) : 1) | 0;\n\t\t\t\t\tpartWidth += charWidth;\n\t\t\t\t\tif (_charIndex >= fauxIndentLength) {\n\t\t\t\t\t\t_visibleColumn += charWidth;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (partRendersWhitespaceWithWidth) {\n\t\t\t\tsb.appendString(' style=\"width:');\n\t\t\t\tsb.appendString(String(spaceWidth * partWidth));\n\t\t\t\tsb.appendString('px\"');\n\t\t\t}\n\t\t\tsb.appendASCIICharCode(CharCode.GreaterThan);\n\n\t\t\tfor (; charIndex < partEndIndex; charIndex++) {\n\t\t\t\tcharacterMapping.setColumnInfo(charIndex + 1, partIndex - partDisplacement, charOffsetInPart, charHorizontalOffset);\n\t\t\t\tpartDisplacement = 0;\n\t\t\t\tconst charCode = lineContent.charCodeAt(charIndex);\n\n\t\t\t\tlet producedCharacters: number;\n\t\t\t\tlet charWidth: number;\n\n\t\t\t\tif (charCode === CharCode.Tab) {\n\t\t\t\t\tproducedCharacters = (tabSize - (visibleColumn % tabSize)) | 0;\n\t\t\t\t\tcharWidth = producedCharacters;\n\n\t\t\t\t\tif (!canUseHalfwidthRightwardsArrow || charWidth > 1) {\n\t\t\t\t\t\tsb.appendCharCode(0x2192); // RIGHTWARDS ARROW\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsb.appendCharCode(0xFFEB); // HALFWIDTH RIGHTWARDS ARROW\n\t\t\t\t\t}\n\t\t\t\t\tfor (let space = 2; space <= charWidth; space++) {\n\t\t\t\t\t\tsb.appendCharCode(0xA0); // &nbsp;\n\t\t\t\t\t}\n\n\t\t\t\t} else { // must be CharCode.Space\n\t\t\t\t\tproducedCharacters = 2;\n\t\t\t\t\tcharWidth = 1;\n\n\t\t\t\t\tsb.appendCharCode(renderSpaceCharCode); // &middot; or word separator middle dot\n\t\t\t\t\tsb.appendCharCode(0x200C); // ZERO WIDTH NON-JOINER\n\t\t\t\t}\n\n\t\t\t\tcharOffsetInPart += producedCharacters;\n\t\t\t\tcharHorizontalOffset += charWidth;\n\t\t\t\tif (charIndex >= fauxIndentLength) {\n\t\t\t\t\tvisibleColumn += charWidth;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tsb.appendASCIICharCode(CharCode.GreaterThan);\n\n\t\t\tfor (; charIndex < partEndIndex; charIndex++) {\n\t\t\t\tcharacterMapping.setColumnInfo(charIndex + 1, partIndex - partDisplacement, charOffsetInPart, charHorizontalOffset);\n\t\t\t\tpartDisplacement = 0;\n\t\t\t\tconst charCode = lineContent.charCodeAt(charIndex);\n\n\t\t\t\tlet producedCharacters = 1;\n\t\t\t\tlet charWidth = 1;\n\n\t\t\t\tswitch (charCode) {\n\t\t\t\t\tcase CharCode.Tab:\n\t\t\t\t\t\tproducedCharacters = (tabSize - (visibleColumn % tabSize));\n\t\t\t\t\t\tcharWidth = producedCharacters;\n\t\t\t\t\t\tfor (let space = 1; space <= producedCharacters; space++) {\n\t\t\t\t\t\t\tsb.appendCharCode(0xA0); // &nbsp;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CharCode.Space:\n\t\t\t\t\t\tsb.appendCharCode(0xA0); // &nbsp;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CharCode.LessThan:\n\t\t\t\t\t\tsb.appendString('&lt;');\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CharCode.GreaterThan:\n\t\t\t\t\t\tsb.appendString('&gt;');\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CharCode.Ampersand:\n\t\t\t\t\t\tsb.appendString('&amp;');\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CharCode.Null:\n\t\t\t\t\t\tif (renderControlCharacters) {\n\t\t\t\t\t\t\t// See https://unicode-table.com/en/blocks/control-pictures/\n\t\t\t\t\t\t\tsb.appendCharCode(9216);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsb.appendString('&#00;');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CharCode.UTF8_BOM:\n\t\t\t\t\tcase CharCode.LINE_SEPARATOR:\n\t\t\t\t\tcase CharCode.PARAGRAPH_SEPARATOR:\n\t\t\t\t\tcase CharCode.NEXT_LINE:\n\t\t\t\t\t\tsb.appendCharCode(0xFFFD);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif (strings.isFullWidthCharacter(charCode)) {\n\t\t\t\t\t\t\tcharWidth++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// See https://unicode-table.com/en/blocks/control-pictures/\n\t\t\t\t\t\tif (renderControlCharacters && charCode < 32) {\n\t\t\t\t\t\t\tsb.appendCharCode(9216 + charCode);\n\t\t\t\t\t\t} else if (renderControlCharacters && charCode === 127) {\n\t\t\t\t\t\t\t// DEL\n\t\t\t\t\t\t\tsb.appendCharCode(9249);\n\t\t\t\t\t\t} else if (renderControlCharacters && isControlCharacter(charCode)) {\n\t\t\t\t\t\t\tsb.appendString('[U+');\n\t\t\t\t\t\t\tsb.appendString(to4CharHex(charCode));\n\t\t\t\t\t\t\tsb.appendString(']');\n\t\t\t\t\t\t\tproducedCharacters = 8;\n\t\t\t\t\t\t\tcharWidth = producedCharacters;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsb.appendCharCode(charCode);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcharOffsetInPart += producedCharacters;\n\t\t\t\tcharHorizontalOffset += charWidth;\n\t\t\t\tif (charIndex >= fauxIndentLength) {\n\t\t\t\t\tvisibleColumn += charWidth;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (partIsEmptyAndHasPseudoAfter) {\n\t\t\tpartDisplacement++;\n\t\t} else {\n\t\t\tpartDisplacement = 0;\n\t\t}\n\n\t\tif (charIndex >= len && !lastCharacterMappingDefined && part.isPseudoAfter()) {\n\t\t\tlastCharacterMappingDefined = true;\n\t\t\tcharacterMapping.setColumnInfo(charIndex + 1, partIndex, charOffsetInPart, charHorizontalOffset);\n\t\t}\n\n\t\tsb.appendString('</span>');\n\n\t}\n\n\tif (!lastCharacterMappingDefined) {\n\t\t// When getting client rects for the last character, we will position the\n\t\t// text range at the end of the span, insteaf of at the beginning of next span\n\t\tcharacterMapping.setColumnInfo(len + 1, parts.length - 1, charOffsetInPart, charHorizontalOffset);\n\t}\n\n\tif (isOverflowing) {\n\t\tsb.appendString('<span class=\"mtkoverflow\">');\n\t\tsb.appendString(nls.localize('showMore', \"Show more ({0})\", renderOverflowingCharCount(overflowingCharCount)));\n\t\tsb.appendString('</span>');\n\t}\n\n\tsb.appendString('</span>');\n\n\treturn new RenderLineOutput(characterMapping, containsRTL, containsForeignElements);\n}\n\nfunction to4CharHex(n: number): string {\n\treturn n.toString(16).toUpperCase().padStart(4, '0');\n}\n\nfunction renderOverflowingCharCount(n: number): string {\n\tif (n < 1024) {\n\t\treturn nls.localize('overflow.chars', \"{0} chars\", n);\n\t}\n\tif (n < 1024 * 1024) {\n\t\treturn `${(n / 1024).toFixed(1)} KB`;\n\t}\n\treturn `${(n / 1024 / 1024).toFixed(1)} MB`;\n}\n"],
  "mappings": "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",
  "names": ["RenderWhitespace", "CharacterMappingConstants", "ForeignElementType", "len", "tokenContainsRTL", "Constants"]
}
