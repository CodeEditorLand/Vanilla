{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/viewLayout/lineDecorations.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from \"../../../base/common/strings.js\";\nimport { Constants } from \"../../../base/common/uint.js\";\nimport { type InlineDecoration, InlineDecorationType } from \"../viewModel.js\";\nimport { LinePartMetadata } from \"./linePart.js\";\n\nexport class LineDecoration {\n\t_lineDecorationBrand: void = undefined;\n\n\tconstructor(\n\t\tpublic readonly startColumn: number,\n\t\tpublic readonly endColumn: number,\n\t\tpublic readonly className: string,\n\t\tpublic readonly type: InlineDecorationType,\n\t) {}\n\n\tprivate static _equals(a: LineDecoration, b: LineDecoration): boolean {\n\t\treturn (\n\t\t\ta.startColumn === b.startColumn &&\n\t\t\ta.endColumn === b.endColumn &&\n\t\t\ta.className === b.className &&\n\t\t\ta.type === b.type\n\t\t);\n\t}\n\n\tpublic static equalsArr(a: LineDecoration[], b: LineDecoration[]): boolean {\n\t\tconst aLen = a.length;\n\t\tconst bLen = b.length;\n\t\tif (aLen !== bLen) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0; i < aLen; i++) {\n\t\t\tif (!LineDecoration._equals(a[i], b[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static extractWrapped(\n\t\tarr: LineDecoration[],\n\t\tstartOffset: number,\n\t\tendOffset: number,\n\t): LineDecoration[] {\n\t\tif (arr.length === 0) {\n\t\t\treturn arr;\n\t\t}\n\t\tconst startColumn = startOffset + 1;\n\t\tconst endColumn = endOffset + 1;\n\t\tconst lineLength = endOffset - startOffset;\n\t\tconst r = [];\n\t\tlet rLength = 0;\n\t\tfor (const dec of arr) {\n\t\t\tif (dec.endColumn <= startColumn || dec.startColumn >= endColumn) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr[rLength++] = new LineDecoration(\n\t\t\t\tMath.max(1, dec.startColumn - startColumn + 1),\n\t\t\t\tMath.min(lineLength + 1, dec.endColumn - startColumn + 1),\n\t\t\t\tdec.className,\n\t\t\t\tdec.type,\n\t\t\t);\n\t\t}\n\t\treturn r;\n\t}\n\n\tpublic static filter(\n\t\tlineDecorations: InlineDecoration[],\n\t\tlineNumber: number,\n\t\tminLineColumn: number,\n\t\tmaxLineColumn: number,\n\t): LineDecoration[] {\n\t\tif (lineDecorations.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst result: LineDecoration[] = [];\n\t\tlet resultLen = 0;\n\n\t\tfor (let i = 0, len = lineDecorations.length; i < len; i++) {\n\t\t\tconst d = lineDecorations[i];\n\t\t\tconst range = d.range;\n\n\t\t\tif (\n\t\t\t\trange.endLineNumber < lineNumber ||\n\t\t\t\trange.startLineNumber > lineNumber\n\t\t\t) {\n\t\t\t\t// Ignore decorations that sit outside this line\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\trange.isEmpty() &&\n\t\t\t\t(d.type === InlineDecorationType.Regular ||\n\t\t\t\t\td.type ===\n\t\t\t\t\t\tInlineDecorationType.RegularAffectingLetterSpacing)\n\t\t\t) {\n\t\t\t\t// Ignore empty range decorations\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst startColumn =\n\t\t\t\trange.startLineNumber === lineNumber\n\t\t\t\t\t? range.startColumn\n\t\t\t\t\t: minLineColumn;\n\t\t\tconst endColumn =\n\t\t\t\trange.endLineNumber === lineNumber\n\t\t\t\t\t? range.endColumn\n\t\t\t\t\t: maxLineColumn;\n\n\t\t\tresult[resultLen++] = new LineDecoration(\n\t\t\t\tstartColumn,\n\t\t\t\tendColumn,\n\t\t\t\td.inlineClassName,\n\t\t\t\td.type,\n\t\t\t);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate static _typeCompare(\n\t\ta: InlineDecorationType,\n\t\tb: InlineDecorationType,\n\t): number {\n\t\tconst ORDER = [2, 0, 1, 3];\n\t\treturn ORDER[a] - ORDER[b];\n\t}\n\n\tpublic static compare(a: LineDecoration, b: LineDecoration): number {\n\t\tif (a.startColumn !== b.startColumn) {\n\t\t\treturn a.startColumn - b.startColumn;\n\t\t}\n\n\t\tif (a.endColumn !== b.endColumn) {\n\t\t\treturn a.endColumn - b.endColumn;\n\t\t}\n\n\t\tconst typeCmp = LineDecoration._typeCompare(a.type, b.type);\n\t\tif (typeCmp !== 0) {\n\t\t\treturn typeCmp;\n\t\t}\n\n\t\tif (a.className !== b.className) {\n\t\t\treturn a.className < b.className ? -1 : 1;\n\t\t}\n\n\t\treturn 0;\n\t}\n}\n\nexport class DecorationSegment {\n\tstartOffset: number;\n\tendOffset: number;\n\tclassName: string;\n\tmetadata: number;\n\n\tconstructor(\n\t\tstartOffset: number,\n\t\tendOffset: number,\n\t\tclassName: string,\n\t\tmetadata: number,\n\t) {\n\t\tthis.startOffset = startOffset;\n\t\tthis.endOffset = endOffset;\n\t\tthis.className = className;\n\t\tthis.metadata = metadata;\n\t}\n}\n\nclass Stack {\n\tpublic count: number;\n\tprivate readonly stopOffsets: number[];\n\tprivate readonly classNames: string[];\n\tprivate readonly metadata: number[];\n\n\tconstructor() {\n\t\tthis.stopOffsets = [];\n\t\tthis.classNames = [];\n\t\tthis.metadata = [];\n\t\tthis.count = 0;\n\t}\n\n\tprivate static _metadata(metadata: number[]): number {\n\t\tlet result = 0;\n\t\tfor (let i = 0, len = metadata.length; i < len; i++) {\n\t\t\tresult |= metadata[i];\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic consumeLowerThan(\n\t\tmaxStopOffset: number,\n\t\tnextStartOffset: number,\n\t\tresult: DecorationSegment[],\n\t): number {\n\t\twhile (this.count > 0 && this.stopOffsets[0] < maxStopOffset) {\n\t\t\tlet i = 0;\n\n\t\t\t// Take all equal stopping offsets\n\t\t\twhile (\n\t\t\t\ti + 1 < this.count &&\n\t\t\t\tthis.stopOffsets[i] === this.stopOffsets[i + 1]\n\t\t\t) {\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\t// Basically we are consuming the first i + 1 elements of the stack\n\t\t\tresult.push(\n\t\t\t\tnew DecorationSegment(\n\t\t\t\t\tnextStartOffset,\n\t\t\t\t\tthis.stopOffsets[i],\n\t\t\t\t\tthis.classNames.join(\" \"),\n\t\t\t\t\tStack._metadata(this.metadata),\n\t\t\t\t),\n\t\t\t);\n\t\t\tnextStartOffset = this.stopOffsets[i] + 1;\n\n\t\t\t// Consume them\n\t\t\tthis.stopOffsets.splice(0, i + 1);\n\t\t\tthis.classNames.splice(0, i + 1);\n\t\t\tthis.metadata.splice(0, i + 1);\n\t\t\tthis.count -= i + 1;\n\t\t}\n\n\t\tif (this.count > 0 && nextStartOffset < maxStopOffset) {\n\t\t\tresult.push(\n\t\t\t\tnew DecorationSegment(\n\t\t\t\t\tnextStartOffset,\n\t\t\t\t\tmaxStopOffset - 1,\n\t\t\t\t\tthis.classNames.join(\" \"),\n\t\t\t\t\tStack._metadata(this.metadata),\n\t\t\t\t),\n\t\t\t);\n\t\t\tnextStartOffset = maxStopOffset;\n\t\t}\n\n\t\treturn nextStartOffset;\n\t}\n\n\tpublic insert(\n\t\tstopOffset: number,\n\t\tclassName: string,\n\t\tmetadata: number,\n\t): void {\n\t\tif (\n\t\t\tthis.count === 0 ||\n\t\t\tthis.stopOffsets[this.count - 1] <= stopOffset\n\t\t) {\n\t\t\t// Insert at the end\n\t\t\tthis.stopOffsets.push(stopOffset);\n\t\t\tthis.classNames.push(className);\n\t\t\tthis.metadata.push(metadata);\n\t\t} else {\n\t\t\t// Find the insertion position for `stopOffset`\n\t\t\tfor (let i = 0; i < this.count; i++) {\n\t\t\t\tif (this.stopOffsets[i] >= stopOffset) {\n\t\t\t\t\tthis.stopOffsets.splice(i, 0, stopOffset);\n\t\t\t\t\tthis.classNames.splice(i, 0, className);\n\t\t\t\t\tthis.metadata.splice(i, 0, metadata);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.count++;\n\t\treturn;\n\t}\n}\n\nexport class LineDecorationsNormalizer {\n\t/**\n\t * Normalize line decorations. Overlapping decorations will generate multiple segments\n\t */\n\tpublic static normalize(\n\t\tlineContent: string,\n\t\tlineDecorations: LineDecoration[],\n\t): DecorationSegment[] {\n\t\tif (lineDecorations.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst result: DecorationSegment[] = [];\n\n\t\tconst stack = new Stack();\n\t\tlet nextStartOffset = 0;\n\n\t\tfor (let i = 0, len = lineDecorations.length; i < len; i++) {\n\t\t\tconst d = lineDecorations[i];\n\t\t\tlet startColumn = d.startColumn;\n\t\t\tlet endColumn = d.endColumn;\n\t\t\tconst className = d.className;\n\t\t\tconst metadata =\n\t\t\t\td.type === InlineDecorationType.Before\n\t\t\t\t\t? LinePartMetadata.PSEUDO_BEFORE\n\t\t\t\t\t: d.type === InlineDecorationType.After\n\t\t\t\t\t\t? LinePartMetadata.PSEUDO_AFTER\n\t\t\t\t\t\t: 0;\n\n\t\t\t// If the position would end up in the middle of a high-low surrogate pair, we move it to before the pair\n\t\t\tif (startColumn > 1) {\n\t\t\t\tconst charCodeBefore = lineContent.charCodeAt(startColumn - 2);\n\t\t\t\tif (strings.isHighSurrogate(charCodeBefore)) {\n\t\t\t\t\tstartColumn--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (endColumn > 1) {\n\t\t\t\tconst charCodeBefore = lineContent.charCodeAt(endColumn - 2);\n\t\t\t\tif (strings.isHighSurrogate(charCodeBefore)) {\n\t\t\t\t\tendColumn--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst currentStartOffset = startColumn - 1;\n\t\t\tconst currentEndOffset = endColumn - 2;\n\n\t\t\tnextStartOffset = stack.consumeLowerThan(\n\t\t\t\tcurrentStartOffset,\n\t\t\t\tnextStartOffset,\n\t\t\t\tresult,\n\t\t\t);\n\n\t\t\tif (stack.count === 0) {\n\t\t\t\tnextStartOffset = currentStartOffset;\n\t\t\t}\n\t\t\tstack.insert(currentEndOffset, className, metadata);\n\t\t}\n\n\t\tstack.consumeLowerThan(\n\t\t\tConstants.MAX_SAFE_SMALL_INTEGER,\n\t\t\tnextStartOffset,\n\t\t\tresult,\n\t\t);\n\n\t\treturn result;\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
