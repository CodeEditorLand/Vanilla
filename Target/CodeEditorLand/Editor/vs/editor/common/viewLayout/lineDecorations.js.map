{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/viewLayout/lineDecorations.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from '../../../base/common/strings.js';\nimport { Constants } from '../../../base/common/uint.js';\nimport { LinePartMetadata } from './linePart.js';\nimport { InlineDecoration, InlineDecorationType } from '../viewModel.js';\n\nexport class LineDecoration {\n\t_lineDecorationBrand: void = undefined;\n\n\tconstructor(\n\t\tpublic readonly startColumn: number,\n\t\tpublic readonly endColumn: number,\n\t\tpublic readonly className: string,\n\t\tpublic readonly type: InlineDecorationType\n\t) {\n\t}\n\n\tprivate static _equals(a: LineDecoration, b: LineDecoration): boolean {\n\t\treturn (\n\t\t\ta.startColumn === b.startColumn\n\t\t\t&& a.endColumn === b.endColumn\n\t\t\t&& a.className === b.className\n\t\t\t&& a.type === b.type\n\t\t);\n\t}\n\n\tpublic static equalsArr(a: LineDecoration[], b: LineDecoration[]): boolean {\n\t\tconst aLen = a.length;\n\t\tconst bLen = b.length;\n\t\tif (aLen !== bLen) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0; i < aLen; i++) {\n\t\t\tif (!LineDecoration._equals(a[i], b[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static extractWrapped(arr: LineDecoration[], startOffset: number, endOffset: number): LineDecoration[] {\n\t\tif (arr.length === 0) {\n\t\t\treturn arr;\n\t\t}\n\t\tconst startColumn = startOffset + 1;\n\t\tconst endColumn = endOffset + 1;\n\t\tconst lineLength = endOffset - startOffset;\n\t\tconst r = [];\n\t\tlet rLength = 0;\n\t\tfor (const dec of arr) {\n\t\t\tif (dec.endColumn <= startColumn || dec.startColumn >= endColumn) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr[rLength++] = new LineDecoration(Math.max(1, dec.startColumn - startColumn + 1), Math.min(lineLength + 1, dec.endColumn - startColumn + 1), dec.className, dec.type);\n\t\t}\n\t\treturn r;\n\t}\n\n\tpublic static filter(lineDecorations: InlineDecoration[], lineNumber: number, minLineColumn: number, maxLineColumn: number): LineDecoration[] {\n\t\tif (lineDecorations.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst result: LineDecoration[] = [];\n\t\tlet resultLen = 0;\n\n\t\tfor (let i = 0, len = lineDecorations.length; i < len; i++) {\n\t\t\tconst d = lineDecorations[i];\n\t\t\tconst range = d.range;\n\n\t\t\tif (range.endLineNumber < lineNumber || range.startLineNumber > lineNumber) {\n\t\t\t\t// Ignore decorations that sit outside this line\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (range.isEmpty() && (d.type === InlineDecorationType.Regular || d.type === InlineDecorationType.RegularAffectingLetterSpacing)) {\n\t\t\t\t// Ignore empty range decorations\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst startColumn = (range.startLineNumber === lineNumber ? range.startColumn : minLineColumn);\n\t\t\tconst endColumn = (range.endLineNumber === lineNumber ? range.endColumn : maxLineColumn);\n\n\t\t\tresult[resultLen++] = new LineDecoration(startColumn, endColumn, d.inlineClassName, d.type);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate static _typeCompare(a: InlineDecorationType, b: InlineDecorationType): number {\n\t\tconst ORDER = [2, 0, 1, 3];\n\t\treturn ORDER[a] - ORDER[b];\n\t}\n\n\tpublic static compare(a: LineDecoration, b: LineDecoration): number {\n\t\tif (a.startColumn !== b.startColumn) {\n\t\t\treturn a.startColumn - b.startColumn;\n\t\t}\n\n\t\tif (a.endColumn !== b.endColumn) {\n\t\t\treturn a.endColumn - b.endColumn;\n\t\t}\n\n\t\tconst typeCmp = LineDecoration._typeCompare(a.type, b.type);\n\t\tif (typeCmp !== 0) {\n\t\t\treturn typeCmp;\n\t\t}\n\n\t\tif (a.className !== b.className) {\n\t\t\treturn a.className < b.className ? -1 : 1;\n\t\t}\n\n\t\treturn 0;\n\t}\n}\n\nexport class DecorationSegment {\n\tstartOffset: number;\n\tendOffset: number;\n\tclassName: string;\n\tmetadata: number;\n\n\tconstructor(startOffset: number, endOffset: number, className: string, metadata: number) {\n\t\tthis.startOffset = startOffset;\n\t\tthis.endOffset = endOffset;\n\t\tthis.className = className;\n\t\tthis.metadata = metadata;\n\t}\n}\n\nclass Stack {\n\tpublic count: number;\n\tprivate readonly stopOffsets: number[];\n\tprivate readonly classNames: string[];\n\tprivate readonly metadata: number[];\n\n\tconstructor() {\n\t\tthis.stopOffsets = [];\n\t\tthis.classNames = [];\n\t\tthis.metadata = [];\n\t\tthis.count = 0;\n\t}\n\n\tprivate static _metadata(metadata: number[]): number {\n\t\tlet result = 0;\n\t\tfor (let i = 0, len = metadata.length; i < len; i++) {\n\t\t\tresult |= metadata[i];\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic consumeLowerThan(maxStopOffset: number, nextStartOffset: number, result: DecorationSegment[]): number {\n\n\t\twhile (this.count > 0 && this.stopOffsets[0] < maxStopOffset) {\n\t\t\tlet i = 0;\n\n\t\t\t// Take all equal stopping offsets\n\t\t\twhile (i + 1 < this.count && this.stopOffsets[i] === this.stopOffsets[i + 1]) {\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\t// Basically we are consuming the first i + 1 elements of the stack\n\t\t\tresult.push(new DecorationSegment(nextStartOffset, this.stopOffsets[i], this.classNames.join(' '), Stack._metadata(this.metadata)));\n\t\t\tnextStartOffset = this.stopOffsets[i] + 1;\n\n\t\t\t// Consume them\n\t\t\tthis.stopOffsets.splice(0, i + 1);\n\t\t\tthis.classNames.splice(0, i + 1);\n\t\t\tthis.metadata.splice(0, i + 1);\n\t\t\tthis.count -= (i + 1);\n\t\t}\n\n\t\tif (this.count > 0 && nextStartOffset < maxStopOffset) {\n\t\t\tresult.push(new DecorationSegment(nextStartOffset, maxStopOffset - 1, this.classNames.join(' '), Stack._metadata(this.metadata)));\n\t\t\tnextStartOffset = maxStopOffset;\n\t\t}\n\n\t\treturn nextStartOffset;\n\t}\n\n\tpublic insert(stopOffset: number, className: string, metadata: number): void {\n\t\tif (this.count === 0 || this.stopOffsets[this.count - 1] <= stopOffset) {\n\t\t\t// Insert at the end\n\t\t\tthis.stopOffsets.push(stopOffset);\n\t\t\tthis.classNames.push(className);\n\t\t\tthis.metadata.push(metadata);\n\t\t} else {\n\t\t\t// Find the insertion position for `stopOffset`\n\t\t\tfor (let i = 0; i < this.count; i++) {\n\t\t\t\tif (this.stopOffsets[i] >= stopOffset) {\n\t\t\t\t\tthis.stopOffsets.splice(i, 0, stopOffset);\n\t\t\t\t\tthis.classNames.splice(i, 0, className);\n\t\t\t\t\tthis.metadata.splice(i, 0, metadata);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.count++;\n\t\treturn;\n\t}\n}\n\nexport class LineDecorationsNormalizer {\n\t/**\n\t * Normalize line decorations. Overlapping decorations will generate multiple segments\n\t */\n\tpublic static normalize(lineContent: string, lineDecorations: LineDecoration[]): DecorationSegment[] {\n\t\tif (lineDecorations.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst result: DecorationSegment[] = [];\n\n\t\tconst stack = new Stack();\n\t\tlet nextStartOffset = 0;\n\n\t\tfor (let i = 0, len = lineDecorations.length; i < len; i++) {\n\t\t\tconst d = lineDecorations[i];\n\t\t\tlet startColumn = d.startColumn;\n\t\t\tlet endColumn = d.endColumn;\n\t\t\tconst className = d.className;\n\t\t\tconst metadata = (\n\t\t\t\td.type === InlineDecorationType.Before\n\t\t\t\t\t? LinePartMetadata.PSEUDO_BEFORE\n\t\t\t\t\t: d.type === InlineDecorationType.After\n\t\t\t\t\t\t? LinePartMetadata.PSEUDO_AFTER\n\t\t\t\t\t\t: 0\n\t\t\t);\n\n\t\t\t// If the position would end up in the middle of a high-low surrogate pair, we move it to before the pair\n\t\t\tif (startColumn > 1) {\n\t\t\t\tconst charCodeBefore = lineContent.charCodeAt(startColumn - 2);\n\t\t\t\tif (strings.isHighSurrogate(charCodeBefore)) {\n\t\t\t\t\tstartColumn--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (endColumn > 1) {\n\t\t\t\tconst charCodeBefore = lineContent.charCodeAt(endColumn - 2);\n\t\t\t\tif (strings.isHighSurrogate(charCodeBefore)) {\n\t\t\t\t\tendColumn--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst currentStartOffset = startColumn - 1;\n\t\t\tconst currentEndOffset = endColumn - 2;\n\n\t\t\tnextStartOffset = stack.consumeLowerThan(currentStartOffset, nextStartOffset, result);\n\n\t\t\tif (stack.count === 0) {\n\t\t\t\tnextStartOffset = currentStartOffset;\n\t\t\t}\n\t\t\tstack.insert(currentEndOffset, className, metadata);\n\t\t}\n\n\t\tstack.consumeLowerThan(Constants.MAX_SAFE_SMALL_INTEGER, nextStartOffset, result);\n\n\t\treturn result;\n\t}\n\n}\n"],
  "mappings": ";;AAKA,YAAY,aAAa;AACzB,SAAS,iBAAiB;AAC1B,SAAS,wBAAwB;AACjC,SAAS,kBAAkB,4BAA4B;AAEhD,MAAM,eAAe;AAAA,EAG3B,YACiB,aACA,WACA,WACA,MACf;AAJe;AACA;AACA;AACA;AAAA,EAEjB;AAAA,EAnBD,OAU4B;AAAA;AAAA;AAAA,EAC3B,uBAA6B;AAAA,EAU7B,OAAe,QAAQ,GAAmB,GAA4B;AACrE,WACC,EAAE,gBAAgB,EAAE,eACjB,EAAE,cAAc,EAAE,aAClB,EAAE,cAAc,EAAE,aAClB,EAAE,SAAS,EAAE;AAAA,EAElB;AAAA,EAEA,OAAc,UAAU,GAAqB,GAA8B;AAC1E,UAAM,OAAO,EAAE;AACf,UAAM,OAAO,EAAE;AACf,QAAI,SAAS,MAAM;AAClB,aAAO;AAAA,IACR;AACA,aAAS,IAAI,GAAG,IAAI,MAAM,KAAK;AAC9B,UAAI,CAAC,eAAe,QAAQ,EAAE,CAAC,GAAG,EAAE,CAAC,CAAC,GAAG;AACxC,eAAO;AAAA,MACR;AAAA,IACD;AACA,WAAO;AAAA,EACR;AAAA,EAEA,OAAc,eAAe,KAAuB,aAAqB,WAAqC;AAC7G,QAAI,IAAI,WAAW,GAAG;AACrB,aAAO;AAAA,IACR;AACA,UAAM,cAAc,cAAc;AAClC,UAAM,YAAY,YAAY;AAC9B,UAAM,aAAa,YAAY;AAC/B,UAAM,IAAI,CAAC;AACX,QAAI,UAAU;AACd,eAAW,OAAO,KAAK;AACtB,UAAI,IAAI,aAAa,eAAe,IAAI,eAAe,WAAW;AACjE;AAAA,MACD;AACA,QAAE,SAAS,IAAI,IAAI,eAAe,KAAK,IAAI,GAAG,IAAI,cAAc,cAAc,CAAC,GAAG,KAAK,IAAI,aAAa,GAAG,IAAI,YAAY,cAAc,CAAC,GAAG,IAAI,WAAW,IAAI,IAAI;AAAA,IACrK;AACA,WAAO;AAAA,EACR;AAAA,EAEA,OAAc,OAAO,iBAAqC,YAAoB,eAAuB,eAAyC;AAC7I,QAAI,gBAAgB,WAAW,GAAG;AACjC,aAAO,CAAC;AAAA,IACT;AAEA,UAAM,SAA2B,CAAC;AAClC,QAAI,YAAY;AAEhB,aAAS,IAAI,GAAG,MAAM,gBAAgB,QAAQ,IAAI,KAAK,KAAK;AAC3D,YAAM,IAAI,gBAAgB,CAAC;AAC3B,YAAM,QAAQ,EAAE;AAEhB,UAAI,MAAM,gBAAgB,cAAc,MAAM,kBAAkB,YAAY;AAE3E;AAAA,MACD;AAEA,UAAI,MAAM,QAAQ,MAAM,EAAE,SAAS,qBAAqB,WAAW,EAAE,SAAS,qBAAqB,gCAAgC;AAElI;AAAA,MACD;AAEA,YAAM,cAAe,MAAM,oBAAoB,aAAa,MAAM,cAAc;AAChF,YAAM,YAAa,MAAM,kBAAkB,aAAa,MAAM,YAAY;AAE1E,aAAO,WAAW,IAAI,IAAI,eAAe,aAAa,WAAW,EAAE,iBAAiB,EAAE,IAAI;AAAA,IAC3F;AAEA,WAAO;AAAA,EACR;AAAA,EAEA,OAAe,aAAa,GAAyB,GAAiC;AACrF,UAAM,QAAQ,CAAC,GAAG,GAAG,GAAG,CAAC;AACzB,WAAO,MAAM,CAAC,IAAI,MAAM,CAAC;AAAA,EAC1B;AAAA,EAEA,OAAc,QAAQ,GAAmB,GAA2B;AACnE,QAAI,EAAE,gBAAgB,EAAE,aAAa;AACpC,aAAO,EAAE,cAAc,EAAE;AAAA,IAC1B;AAEA,QAAI,EAAE,cAAc,EAAE,WAAW;AAChC,aAAO,EAAE,YAAY,EAAE;AAAA,IACxB;AAEA,UAAM,UAAU,eAAe,aAAa,EAAE,MAAM,EAAE,IAAI;AAC1D,QAAI,YAAY,GAAG;AAClB,aAAO;AAAA,IACR;AAEA,QAAI,EAAE,cAAc,EAAE,WAAW;AAChC,aAAO,EAAE,YAAY,EAAE,YAAY,KAAK;AAAA,IACzC;AAEA,WAAO;AAAA,EACR;AACD;AAEO,MAAM,kBAAkB;AAAA,EAxH/B,OAwH+B;AAAA;AAAA;AAAA,EAC9B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAEA,YAAY,aAAqB,WAAmB,WAAmB,UAAkB;AACxF,SAAK,cAAc;AACnB,SAAK,YAAY;AACjB,SAAK,YAAY;AACjB,SAAK,WAAW;AAAA,EACjB;AACD;AAEA,MAAM,MAAM;AAAA,EAtIZ,OAsIY;AAAA;AAAA;AAAA,EACJ;AAAA,EACU;AAAA,EACA;AAAA,EACA;AAAA,EAEjB,cAAc;AACb,SAAK,cAAc,CAAC;AACpB,SAAK,aAAa,CAAC;AACnB,SAAK,WAAW,CAAC;AACjB,SAAK,QAAQ;AAAA,EACd;AAAA,EAEA,OAAe,UAAU,UAA4B;AACpD,QAAI,SAAS;AACb,aAAS,IAAI,GAAG,MAAM,SAAS,QAAQ,IAAI,KAAK,KAAK;AACpD,gBAAU,SAAS,CAAC;AAAA,IACrB;AACA,WAAO;AAAA,EACR;AAAA,EAEO,iBAAiB,eAAuB,iBAAyB,QAAqC;AAE5G,WAAO,KAAK,QAAQ,KAAK,KAAK,YAAY,CAAC,IAAI,eAAe;AAC7D,UAAI,IAAI;AAGR,aAAO,IAAI,IAAI,KAAK,SAAS,KAAK,YAAY,CAAC,MAAM,KAAK,YAAY,IAAI,CAAC,GAAG;AAC7E;AAAA,MACD;AAGA,aAAO,KAAK,IAAI,kBAAkB,iBAAiB,KAAK,YAAY,CAAC,GAAG,KAAK,WAAW,KAAK,GAAG,GAAG,MAAM,UAAU,KAAK,QAAQ,CAAC,CAAC;AAClI,wBAAkB,KAAK,YAAY,CAAC,IAAI;AAGxC,WAAK,YAAY,OAAO,GAAG,IAAI,CAAC;AAChC,WAAK,WAAW,OAAO,GAAG,IAAI,CAAC;AAC/B,WAAK,SAAS,OAAO,GAAG,IAAI,CAAC;AAC7B,WAAK,SAAU,IAAI;AAAA,IACpB;AAEA,QAAI,KAAK,QAAQ,KAAK,kBAAkB,eAAe;AACtD,aAAO,KAAK,IAAI,kBAAkB,iBAAiB,gBAAgB,GAAG,KAAK,WAAW,KAAK,GAAG,GAAG,MAAM,UAAU,KAAK,QAAQ,CAAC,CAAC;AAChI,wBAAkB;AAAA,IACnB;AAEA,WAAO;AAAA,EACR;AAAA,EAEO,OAAO,YAAoB,WAAmB,UAAwB;AAC5E,QAAI,KAAK,UAAU,KAAK,KAAK,YAAY,KAAK,QAAQ,CAAC,KAAK,YAAY;AAEvE,WAAK,YAAY,KAAK,UAAU;AAChC,WAAK,WAAW,KAAK,SAAS;AAC9B,WAAK,SAAS,KAAK,QAAQ;AAAA,IAC5B,OAAO;AAEN,eAAS,IAAI,GAAG,IAAI,KAAK,OAAO,KAAK;AACpC,YAAI,KAAK,YAAY,CAAC,KAAK,YAAY;AACtC,eAAK,YAAY,OAAO,GAAG,GAAG,UAAU;AACxC,eAAK,WAAW,OAAO,GAAG,GAAG,SAAS;AACtC,eAAK,SAAS,OAAO,GAAG,GAAG,QAAQ;AACnC;AAAA,QACD;AAAA,MACD;AAAA,IACD;AACA,SAAK;AACL;AAAA,EACD;AACD;AAEO,MAAM,0BAA0B;AAAA,EA9MvC,OA8MuC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAItC,OAAc,UAAU,aAAqB,iBAAwD;AACpG,QAAI,gBAAgB,WAAW,GAAG;AACjC,aAAO,CAAC;AAAA,IACT;AAEA,UAAM,SAA8B,CAAC;AAErC,UAAM,QAAQ,IAAI,MAAM;AACxB,QAAI,kBAAkB;AAEtB,aAAS,IAAI,GAAG,MAAM,gBAAgB,QAAQ,IAAI,KAAK,KAAK;AAC3D,YAAM,IAAI,gBAAgB,CAAC;AAC3B,UAAI,cAAc,EAAE;AACpB,UAAI,YAAY,EAAE;AAClB,YAAM,YAAY,EAAE;AACpB,YAAM,WACL,EAAE,SAAS,qBAAqB,SAC7B,iBAAiB,gBACjB,EAAE,SAAS,qBAAqB,QAC/B,iBAAiB,eACjB;AAIL,UAAI,cAAc,GAAG;AACpB,cAAM,iBAAiB,YAAY,WAAW,cAAc,CAAC;AAC7D,YAAI,QAAQ,gBAAgB,cAAc,GAAG;AAC5C;AAAA,QACD;AAAA,MACD;AAEA,UAAI,YAAY,GAAG;AAClB,cAAM,iBAAiB,YAAY,WAAW,YAAY,CAAC;AAC3D,YAAI,QAAQ,gBAAgB,cAAc,GAAG;AAC5C;AAAA,QACD;AAAA,MACD;AAEA,YAAM,qBAAqB,cAAc;AACzC,YAAM,mBAAmB,YAAY;AAErC,wBAAkB,MAAM,iBAAiB,oBAAoB,iBAAiB,MAAM;AAEpF,UAAI,MAAM,UAAU,GAAG;AACtB,0BAAkB;AAAA,MACnB;AACA,YAAM,OAAO,kBAAkB,WAAW,QAAQ;AAAA,IACnD;AAEA,UAAM,iBAAiB,UAAU,wBAAwB,iBAAiB,MAAM;AAEhF,WAAO;AAAA,EACR;AAED;",
  "names": []
}
