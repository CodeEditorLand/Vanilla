{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/viewModel/monospaceLineBreaksComputer.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { WrappingIndent, IComputedEditorOptions, EditorOption } from '../config/editorOptions.js';\nimport { CharacterClassifier } from '../core/characterClassifier.js';\nimport { FontInfo } from '../config/fontInfo.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport { InjectedTextOptions } from '../model.js';\nimport { ILineBreaksComputerFactory, ILineBreaksComputer, ModelLineProjectionData } from '../modelLineProjectionData.js';\n\nexport class MonospaceLineBreaksComputerFactory implements ILineBreaksComputerFactory {\n\tpublic static create(options: IComputedEditorOptions): MonospaceLineBreaksComputerFactory {\n\t\treturn new MonospaceLineBreaksComputerFactory(\n\t\t\toptions.get(EditorOption.wordWrapBreakBeforeCharacters),\n\t\t\toptions.get(EditorOption.wordWrapBreakAfterCharacters)\n\t\t);\n\t}\n\n\tprivate readonly classifier: WrappingCharacterClassifier;\n\n\tconstructor(breakBeforeChars: string, breakAfterChars: string) {\n\t\tthis.classifier = new WrappingCharacterClassifier(breakBeforeChars, breakAfterChars);\n\t}\n\n\tpublic createLineBreaksComputer(fontInfo: FontInfo, tabSize: number, wrappingColumn: number, wrappingIndent: WrappingIndent, wordBreak: 'normal' | 'keepAll'): ILineBreaksComputer {\n\t\tconst requests: string[] = [];\n\t\tconst injectedTexts: (LineInjectedText[] | null)[] = [];\n\t\tconst previousBreakingData: (ModelLineProjectionData | null)[] = [];\n\t\treturn {\n\t\t\taddRequest: (lineText: string, injectedText: LineInjectedText[] | null, previousLineBreakData: ModelLineProjectionData | null) => {\n\t\t\t\trequests.push(lineText);\n\t\t\t\tinjectedTexts.push(injectedText);\n\t\t\t\tpreviousBreakingData.push(previousLineBreakData);\n\t\t\t},\n\t\t\tfinalize: () => {\n\t\t\t\tconst columnsForFullWidthChar = fontInfo.typicalFullwidthCharacterWidth / fontInfo.typicalHalfwidthCharacterWidth;\n\t\t\t\tconst result: (ModelLineProjectionData | null)[] = [];\n\t\t\t\tfor (let i = 0, len = requests.length; i < len; i++) {\n\t\t\t\t\tconst injectedText = injectedTexts[i];\n\t\t\t\t\tconst previousLineBreakData = previousBreakingData[i];\n\t\t\t\t\tif (previousLineBreakData && !previousLineBreakData.injectionOptions && !injectedText) {\n\t\t\t\t\t\tresult[i] = createLineBreaksFromPreviousLineBreaks(this.classifier, previousLineBreakData, requests[i], tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent, wordBreak);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult[i] = createLineBreaks(this.classifier, requests[i], injectedText, tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent, wordBreak);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tarrPool1.length = 0;\n\t\t\t\tarrPool2.length = 0;\n\t\t\t\treturn result;\n\t\t\t}\n\t\t};\n\t}\n}\n\nconst enum CharacterClass {\n\tNONE = 0,\n\tBREAK_BEFORE = 1,\n\tBREAK_AFTER = 2,\n\tBREAK_IDEOGRAPHIC = 3 // for Han and Kana.\n}\n\nclass WrappingCharacterClassifier extends CharacterClassifier<CharacterClass> {\n\n\tconstructor(BREAK_BEFORE: string, BREAK_AFTER: string) {\n\t\tsuper(CharacterClass.NONE);\n\n\t\tfor (let i = 0; i < BREAK_BEFORE.length; i++) {\n\t\t\tthis.set(BREAK_BEFORE.charCodeAt(i), CharacterClass.BREAK_BEFORE);\n\t\t}\n\n\t\tfor (let i = 0; i < BREAK_AFTER.length; i++) {\n\t\t\tthis.set(BREAK_AFTER.charCodeAt(i), CharacterClass.BREAK_AFTER);\n\t\t}\n\t}\n\n\tpublic override get(charCode: number): CharacterClass {\n\t\tif (charCode >= 0 && charCode < 256) {\n\t\t\treturn <CharacterClass>this._asciiMap[charCode];\n\t\t} else {\n\t\t\t// Initialize CharacterClass.BREAK_IDEOGRAPHIC for these Unicode ranges:\n\t\t\t// 1. CJK Unified Ideographs (0x4E00 -- 0x9FFF)\n\t\t\t// 2. CJK Unified Ideographs Extension A (0x3400 -- 0x4DBF)\n\t\t\t// 3. Hiragana and Katakana (0x3040 -- 0x30FF)\n\t\t\tif (\n\t\t\t\t(charCode >= 0x3040 && charCode <= 0x30FF)\n\t\t\t\t|| (charCode >= 0x3400 && charCode <= 0x4DBF)\n\t\t\t\t|| (charCode >= 0x4E00 && charCode <= 0x9FFF)\n\t\t\t) {\n\t\t\t\treturn CharacterClass.BREAK_IDEOGRAPHIC;\n\t\t\t}\n\n\t\t\treturn <CharacterClass>(this._map.get(charCode) || this._defaultValue);\n\t\t}\n\t}\n}\n\nlet arrPool1: number[] = [];\nlet arrPool2: number[] = [];\n\nfunction createLineBreaksFromPreviousLineBreaks(classifier: WrappingCharacterClassifier, previousBreakingData: ModelLineProjectionData, lineText: string, tabSize: number, firstLineBreakColumn: number, columnsForFullWidthChar: number, wrappingIndent: WrappingIndent, wordBreak: 'normal' | 'keepAll'): ModelLineProjectionData | null {\n\tif (firstLineBreakColumn === -1) {\n\t\treturn null;\n\t}\n\n\tconst len = lineText.length;\n\tif (len <= 1) {\n\t\treturn null;\n\t}\n\n\tconst isKeepAll = (wordBreak === 'keepAll');\n\n\tconst prevBreakingOffsets = previousBreakingData.breakOffsets;\n\tconst prevBreakingOffsetsVisibleColumn = previousBreakingData.breakOffsetsVisibleColumn;\n\n\tconst wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);\n\tconst wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;\n\n\tconst breakingOffsets: number[] = arrPool1;\n\tconst breakingOffsetsVisibleColumn: number[] = arrPool2;\n\tlet breakingOffsetsCount = 0;\n\tlet lastBreakingOffset = 0;\n\tlet lastBreakingOffsetVisibleColumn = 0;\n\n\tlet breakingColumn = firstLineBreakColumn;\n\tconst prevLen = prevBreakingOffsets.length;\n\tlet prevIndex = 0;\n\n\tif (prevIndex >= 0) {\n\t\tlet bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);\n\t\twhile (prevIndex + 1 < prevLen) {\n\t\t\tconst distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);\n\t\t\tif (distance >= bestDistance) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbestDistance = distance;\n\t\t\tprevIndex++;\n\t\t}\n\t}\n\n\twhile (prevIndex < prevLen) {\n\t\t// Allow for prevIndex to be -1 (for the case where we hit a tab when walking backwards from the first break)\n\t\tlet prevBreakOffset = prevIndex < 0 ? 0 : prevBreakingOffsets[prevIndex];\n\t\tlet prevBreakOffsetVisibleColumn = prevIndex < 0 ? 0 : prevBreakingOffsetsVisibleColumn[prevIndex];\n\t\tif (lastBreakingOffset > prevBreakOffset) {\n\t\t\tprevBreakOffset = lastBreakingOffset;\n\t\t\tprevBreakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn;\n\t\t}\n\n\t\tlet breakOffset = 0;\n\t\tlet breakOffsetVisibleColumn = 0;\n\n\t\tlet forcedBreakOffset = 0;\n\t\tlet forcedBreakOffsetVisibleColumn = 0;\n\n\t\t// initially, we search as much as possible to the right (if it fits)\n\t\tif (prevBreakOffsetVisibleColumn <= breakingColumn) {\n\t\t\tlet visibleColumn = prevBreakOffsetVisibleColumn;\n\t\t\tlet prevCharCode = prevBreakOffset === 0 ? CharCode.Null : lineText.charCodeAt(prevBreakOffset - 1);\n\t\t\tlet prevCharCodeClass = prevBreakOffset === 0 ? CharacterClass.NONE : classifier.get(prevCharCode);\n\t\t\tlet entireLineFits = true;\n\t\t\tfor (let i = prevBreakOffset; i < len; i++) {\n\t\t\t\tconst charStartOffset = i;\n\t\t\t\tconst charCode = lineText.charCodeAt(i);\n\t\t\t\tlet charCodeClass: number;\n\t\t\t\tlet charWidth: number;\n\n\t\t\t\tif (strings.isHighSurrogate(charCode)) {\n\t\t\t\t\t// A surrogate pair must always be considered as a single unit, so it is never to be broken\n\t\t\t\t\ti++;\n\t\t\t\t\tcharCodeClass = CharacterClass.NONE;\n\t\t\t\t\tcharWidth = 2;\n\t\t\t\t} else {\n\t\t\t\t\tcharCodeClass = classifier.get(charCode);\n\t\t\t\t\tcharWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);\n\t\t\t\t}\n\n\t\t\t\tif (charStartOffset > lastBreakingOffset && canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass, isKeepAll)) {\n\t\t\t\t\tbreakOffset = charStartOffset;\n\t\t\t\t\tbreakOffsetVisibleColumn = visibleColumn;\n\t\t\t\t}\n\n\t\t\t\tvisibleColumn += charWidth;\n\n\t\t\t\t// check if adding character at `i` will go over the breaking column\n\t\t\t\tif (visibleColumn > breakingColumn) {\n\t\t\t\t\t// We need to break at least before character at `i`:\n\t\t\t\t\tif (charStartOffset > lastBreakingOffset) {\n\t\t\t\t\t\tforcedBreakOffset = charStartOffset;\n\t\t\t\t\t\tforcedBreakOffsetVisibleColumn = visibleColumn - charWidth;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// we need to advance at least by one character\n\t\t\t\t\t\tforcedBreakOffset = i + 1;\n\t\t\t\t\t\tforcedBreakOffsetVisibleColumn = visibleColumn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {\n\t\t\t\t\t\t// Cannot break at `breakOffset` => reset it if it was set\n\t\t\t\t\t\tbreakOffset = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tentireLineFits = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tprevCharCode = charCode;\n\t\t\t\tprevCharCodeClass = charCodeClass;\n\t\t\t}\n\n\t\t\tif (entireLineFits) {\n\t\t\t\t// there is no more need to break => stop the outer loop!\n\t\t\t\tif (breakingOffsetsCount > 0) {\n\t\t\t\t\t// Add last segment, no need to assign to `lastBreakingOffset` and `lastBreakingOffsetVisibleColumn`\n\t\t\t\t\tbreakingOffsets[breakingOffsetsCount] = prevBreakingOffsets[prevBreakingOffsets.length - 1];\n\t\t\t\t\tbreakingOffsetsVisibleColumn[breakingOffsetsCount] = prevBreakingOffsetsVisibleColumn[prevBreakingOffsets.length - 1];\n\t\t\t\t\tbreakingOffsetsCount++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (breakOffset === 0) {\n\t\t\t// must search left\n\t\t\tlet visibleColumn = prevBreakOffsetVisibleColumn;\n\t\t\tlet charCode = lineText.charCodeAt(prevBreakOffset);\n\t\t\tlet charCodeClass = classifier.get(charCode);\n\t\t\tlet hitATabCharacter = false;\n\t\t\tfor (let i = prevBreakOffset - 1; i >= lastBreakingOffset; i--) {\n\t\t\t\tconst charStartOffset = i + 1;\n\t\t\t\tconst prevCharCode = lineText.charCodeAt(i);\n\n\t\t\t\tif (prevCharCode === CharCode.Tab) {\n\t\t\t\t\t// cannot determine the width of a tab when going backwards, so we must go forwards\n\t\t\t\t\thitATabCharacter = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tlet prevCharCodeClass: number;\n\t\t\t\tlet prevCharWidth: number;\n\n\t\t\t\tif (strings.isLowSurrogate(prevCharCode)) {\n\t\t\t\t\t// A surrogate pair must always be considered as a single unit, so it is never to be broken\n\t\t\t\t\ti--;\n\t\t\t\t\tprevCharCodeClass = CharacterClass.NONE;\n\t\t\t\t\tprevCharWidth = 2;\n\t\t\t\t} else {\n\t\t\t\t\tprevCharCodeClass = classifier.get(prevCharCode);\n\t\t\t\t\tprevCharWidth = (strings.isFullWidthCharacter(prevCharCode) ? columnsForFullWidthChar : 1);\n\t\t\t\t}\n\n\t\t\t\tif (visibleColumn <= breakingColumn) {\n\t\t\t\t\tif (forcedBreakOffset === 0) {\n\t\t\t\t\t\tforcedBreakOffset = charStartOffset;\n\t\t\t\t\t\tforcedBreakOffsetVisibleColumn = visibleColumn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (visibleColumn <= breakingColumn - wrappedLineBreakColumn) {\n\t\t\t\t\t\t// went too far!\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass, isKeepAll)) {\n\t\t\t\t\t\tbreakOffset = charStartOffset;\n\t\t\t\t\t\tbreakOffsetVisibleColumn = visibleColumn;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvisibleColumn -= prevCharWidth;\n\t\t\t\tcharCode = prevCharCode;\n\t\t\t\tcharCodeClass = prevCharCodeClass;\n\t\t\t}\n\n\t\t\tif (breakOffset !== 0) {\n\t\t\t\tconst remainingWidthOfNextLine = wrappedLineBreakColumn - (forcedBreakOffsetVisibleColumn - breakOffsetVisibleColumn);\n\t\t\t\tif (remainingWidthOfNextLine <= tabSize) {\n\t\t\t\t\tconst charCodeAtForcedBreakOffset = lineText.charCodeAt(forcedBreakOffset);\n\t\t\t\t\tlet charWidth: number;\n\t\t\t\t\tif (strings.isHighSurrogate(charCodeAtForcedBreakOffset)) {\n\t\t\t\t\t\t// A surrogate pair must always be considered as a single unit, so it is never to be broken\n\t\t\t\t\t\tcharWidth = 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcharWidth = computeCharWidth(charCodeAtForcedBreakOffset, forcedBreakOffsetVisibleColumn, tabSize, columnsForFullWidthChar);\n\t\t\t\t\t}\n\t\t\t\t\tif (remainingWidthOfNextLine - charWidth < 0) {\n\t\t\t\t\t\t// it is not worth it to break at breakOffset, it just introduces an extra needless line!\n\t\t\t\t\t\tbreakOffset = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hitATabCharacter) {\n\t\t\t\t// cannot determine the width of a tab when going backwards, so we must go forwards from the previous break\n\t\t\t\tprevIndex--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (breakOffset === 0) {\n\t\t\t// Could not find a good breaking point\n\t\t\tbreakOffset = forcedBreakOffset;\n\t\t\tbreakOffsetVisibleColumn = forcedBreakOffsetVisibleColumn;\n\t\t}\n\n\t\tif (breakOffset <= lastBreakingOffset) {\n\t\t\t// Make sure that we are advancing (at least one character)\n\t\t\tconst charCode = lineText.charCodeAt(lastBreakingOffset);\n\t\t\tif (strings.isHighSurrogate(charCode)) {\n\t\t\t\t// A surrogate pair must always be considered as a single unit, so it is never to be broken\n\t\t\t\tbreakOffset = lastBreakingOffset + 2;\n\t\t\t\tbreakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn + 2;\n\t\t\t} else {\n\t\t\t\tbreakOffset = lastBreakingOffset + 1;\n\t\t\t\tbreakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn + computeCharWidth(charCode, lastBreakingOffsetVisibleColumn, tabSize, columnsForFullWidthChar);\n\t\t\t}\n\t\t}\n\n\t\tlastBreakingOffset = breakOffset;\n\t\tbreakingOffsets[breakingOffsetsCount] = breakOffset;\n\t\tlastBreakingOffsetVisibleColumn = breakOffsetVisibleColumn;\n\t\tbreakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;\n\t\tbreakingOffsetsCount++;\n\t\tbreakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\n\n\t\twhile (prevIndex < 0 || (prevIndex < prevLen && prevBreakingOffsetsVisibleColumn[prevIndex] < breakOffsetVisibleColumn)) {\n\t\t\tprevIndex++;\n\t\t}\n\n\t\tlet bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);\n\t\twhile (prevIndex + 1 < prevLen) {\n\t\t\tconst distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);\n\t\t\tif (distance >= bestDistance) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbestDistance = distance;\n\t\t\tprevIndex++;\n\t\t}\n\t}\n\n\tif (breakingOffsetsCount === 0) {\n\t\treturn null;\n\t}\n\n\t// Doing here some object reuse which ends up helping a huge deal with GC pauses!\n\tbreakingOffsets.length = breakingOffsetsCount;\n\tbreakingOffsetsVisibleColumn.length = breakingOffsetsCount;\n\tarrPool1 = previousBreakingData.breakOffsets;\n\tarrPool2 = previousBreakingData.breakOffsetsVisibleColumn;\n\tpreviousBreakingData.breakOffsets = breakingOffsets;\n\tpreviousBreakingData.breakOffsetsVisibleColumn = breakingOffsetsVisibleColumn;\n\tpreviousBreakingData.wrappedTextIndentLength = wrappedTextIndentLength;\n\treturn previousBreakingData;\n}\n\nfunction createLineBreaks(classifier: WrappingCharacterClassifier, _lineText: string, injectedTexts: LineInjectedText[] | null, tabSize: number, firstLineBreakColumn: number, columnsForFullWidthChar: number, wrappingIndent: WrappingIndent, wordBreak: 'normal' | 'keepAll'): ModelLineProjectionData | null {\n\tconst lineText = LineInjectedText.applyInjectedText(_lineText, injectedTexts);\n\n\tlet injectionOptions: InjectedTextOptions[] | null;\n\tlet injectionOffsets: number[] | null;\n\tif (injectedTexts && injectedTexts.length > 0) {\n\t\tinjectionOptions = injectedTexts.map(t => t.options);\n\t\tinjectionOffsets = injectedTexts.map(text => text.column - 1);\n\t} else {\n\t\tinjectionOptions = null;\n\t\tinjectionOffsets = null;\n\t}\n\n\tif (firstLineBreakColumn === -1) {\n\t\tif (!injectionOptions) {\n\t\t\treturn null;\n\t\t}\n\t\t// creating a `LineBreakData` with an invalid `breakOffsetsVisibleColumn` is OK\n\t\t// because `breakOffsetsVisibleColumn` will never be used because it contains injected text\n\t\treturn new ModelLineProjectionData(injectionOffsets, injectionOptions, [lineText.length], [], 0);\n\t}\n\n\tconst len = lineText.length;\n\tif (len <= 1) {\n\t\tif (!injectionOptions) {\n\t\t\treturn null;\n\t\t}\n\t\t// creating a `LineBreakData` with an invalid `breakOffsetsVisibleColumn` is OK\n\t\t// because `breakOffsetsVisibleColumn` will never be used because it contains injected text\n\t\treturn new ModelLineProjectionData(injectionOffsets, injectionOptions, [lineText.length], [], 0);\n\t}\n\n\tconst isKeepAll = (wordBreak === 'keepAll');\n\tconst wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);\n\tconst wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;\n\n\tconst breakingOffsets: number[] = [];\n\tconst breakingOffsetsVisibleColumn: number[] = [];\n\tlet breakingOffsetsCount: number = 0;\n\tlet breakOffset = 0;\n\tlet breakOffsetVisibleColumn = 0;\n\n\tlet breakingColumn = firstLineBreakColumn;\n\tlet prevCharCode = lineText.charCodeAt(0);\n\tlet prevCharCodeClass = classifier.get(prevCharCode);\n\tlet visibleColumn = computeCharWidth(prevCharCode, 0, tabSize, columnsForFullWidthChar);\n\n\tlet startOffset = 1;\n\tif (strings.isHighSurrogate(prevCharCode)) {\n\t\t// A surrogate pair must always be considered as a single unit, so it is never to be broken\n\t\tvisibleColumn += 1;\n\t\tprevCharCode = lineText.charCodeAt(1);\n\t\tprevCharCodeClass = classifier.get(prevCharCode);\n\t\tstartOffset++;\n\t}\n\n\tfor (let i = startOffset; i < len; i++) {\n\t\tconst charStartOffset = i;\n\t\tconst charCode = lineText.charCodeAt(i);\n\t\tlet charCodeClass: CharacterClass;\n\t\tlet charWidth: number;\n\n\t\tif (strings.isHighSurrogate(charCode)) {\n\t\t\t// A surrogate pair must always be considered as a single unit, so it is never to be broken\n\t\t\ti++;\n\t\t\tcharCodeClass = CharacterClass.NONE;\n\t\t\tcharWidth = 2;\n\t\t} else {\n\t\t\tcharCodeClass = classifier.get(charCode);\n\t\t\tcharWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);\n\t\t}\n\n\t\tif (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass, isKeepAll)) {\n\t\t\tbreakOffset = charStartOffset;\n\t\t\tbreakOffsetVisibleColumn = visibleColumn;\n\t\t}\n\n\t\tvisibleColumn += charWidth;\n\n\t\t// check if adding character at `i` will go over the breaking column\n\t\tif (visibleColumn > breakingColumn) {\n\t\t\t// We need to break at least before character at `i`:\n\n\t\t\tif (breakOffset === 0 || visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {\n\t\t\t\t// Cannot break at `breakOffset`, must break at `i`\n\t\t\t\tbreakOffset = charStartOffset;\n\t\t\t\tbreakOffsetVisibleColumn = visibleColumn - charWidth;\n\t\t\t}\n\n\t\t\tbreakingOffsets[breakingOffsetsCount] = breakOffset;\n\t\t\tbreakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;\n\t\t\tbreakingOffsetsCount++;\n\t\t\tbreakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\n\t\t\tbreakOffset = 0;\n\t\t}\n\n\t\tprevCharCode = charCode;\n\t\tprevCharCodeClass = charCodeClass;\n\t}\n\n\tif (breakingOffsetsCount === 0 && (!injectedTexts || injectedTexts.length === 0)) {\n\t\treturn null;\n\t}\n\n\t// Add last segment\n\tbreakingOffsets[breakingOffsetsCount] = len;\n\tbreakingOffsetsVisibleColumn[breakingOffsetsCount] = visibleColumn;\n\n\treturn new ModelLineProjectionData(injectionOffsets, injectionOptions, breakingOffsets, breakingOffsetsVisibleColumn, wrappedTextIndentLength);\n}\n\nfunction computeCharWidth(charCode: number, visibleColumn: number, tabSize: number, columnsForFullWidthChar: number): number {\n\tif (charCode === CharCode.Tab) {\n\t\treturn (tabSize - (visibleColumn % tabSize));\n\t}\n\tif (strings.isFullWidthCharacter(charCode)) {\n\t\treturn columnsForFullWidthChar;\n\t}\n\tif (charCode < 32) {\n\t\t// when using `editor.renderControlCharacters`, the substitutions are often wide\n\t\treturn columnsForFullWidthChar;\n\t}\n\treturn 1;\n}\n\nfunction tabCharacterWidth(visibleColumn: number, tabSize: number): number {\n\treturn (tabSize - (visibleColumn % tabSize));\n}\n\n/**\n * Kinsoku Shori : Don't break after a leading character, like an open bracket\n * Kinsoku Shori : Don't break before a trailing character, like a period\n */\nfunction canBreak(prevCharCode: number, prevCharCodeClass: CharacterClass, charCode: number, charCodeClass: CharacterClass, isKeepAll: boolean): boolean {\n\treturn (\n\t\tcharCode !== CharCode.Space\n\t\t&& (\n\t\t\t(prevCharCodeClass === CharacterClass.BREAK_AFTER && charCodeClass !== CharacterClass.BREAK_AFTER) // break at the end of multiple BREAK_AFTER\n\t\t\t|| (prevCharCodeClass !== CharacterClass.BREAK_BEFORE && charCodeClass === CharacterClass.BREAK_BEFORE) // break at the start of multiple BREAK_BEFORE\n\t\t\t|| (!isKeepAll && prevCharCodeClass === CharacterClass.BREAK_IDEOGRAPHIC && charCodeClass !== CharacterClass.BREAK_AFTER)\n\t\t\t|| (!isKeepAll && charCodeClass === CharacterClass.BREAK_IDEOGRAPHIC && prevCharCodeClass !== CharacterClass.BREAK_BEFORE)\n\t\t)\n\t);\n}\n\nfunction computeWrappedTextIndentLength(lineText: string, tabSize: number, firstLineBreakColumn: number, columnsForFullWidthChar: number, wrappingIndent: WrappingIndent): number {\n\tlet wrappedTextIndentLength = 0;\n\tif (wrappingIndent !== WrappingIndent.None) {\n\t\tconst firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineText);\n\t\tif (firstNonWhitespaceIndex !== -1) {\n\t\t\t// Track existing indent\n\n\t\t\tfor (let i = 0; i < firstNonWhitespaceIndex; i++) {\n\t\t\t\tconst charWidth = (lineText.charCodeAt(i) === CharCode.Tab ? tabCharacterWidth(wrappedTextIndentLength, tabSize) : 1);\n\t\t\t\twrappedTextIndentLength += charWidth;\n\t\t\t}\n\n\t\t\t// Increase indent of continuation lines, if desired\n\t\t\tconst numberOfAdditionalTabs = (wrappingIndent === WrappingIndent.DeepIndent ? 2 : wrappingIndent === WrappingIndent.Indent ? 1 : 0);\n\t\t\tfor (let i = 0; i < numberOfAdditionalTabs; i++) {\n\t\t\t\tconst charWidth = tabCharacterWidth(wrappedTextIndentLength, tabSize);\n\t\t\t\twrappedTextIndentLength += charWidth;\n\t\t\t}\n\n\t\t\t// Force sticking to beginning of line if no character would fit except for the indentation\n\t\t\tif (wrappedTextIndentLength + columnsForFullWidthChar > firstLineBreakColumn) {\n\t\t\t\twrappedTextIndentLength = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn wrappedTextIndentLength;\n}\n"],
  "mappings": "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",
  "names": ["CharacterClass"]
}
