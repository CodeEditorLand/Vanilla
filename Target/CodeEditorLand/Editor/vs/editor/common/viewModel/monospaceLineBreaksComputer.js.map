{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/viewModel/monospaceLineBreaksComputer.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from \"../../../base/common/charCode.js\";\nimport * as strings from \"../../../base/common/strings.js\";\nimport {\n\tEditorOption,\n\ttype IComputedEditorOptions,\n\tWrappingIndent,\n} from \"../config/editorOptions.js\";\nimport type { FontInfo } from \"../config/fontInfo.js\";\nimport { CharacterClassifier } from \"../core/characterClassifier.js\";\nimport type { InjectedTextOptions } from \"../model.js\";\nimport {\n\ttype ILineBreaksComputer,\n\ttype ILineBreaksComputerFactory,\n\tModelLineProjectionData,\n} from \"../modelLineProjectionData.js\";\nimport { LineInjectedText } from \"../textModelEvents.js\";\n\nexport class MonospaceLineBreaksComputerFactory\n\timplements ILineBreaksComputerFactory\n{\n\tpublic static create(\n\t\toptions: IComputedEditorOptions,\n\t): MonospaceLineBreaksComputerFactory {\n\t\treturn new MonospaceLineBreaksComputerFactory(\n\t\t\toptions.get(EditorOption.wordWrapBreakBeforeCharacters),\n\t\t\toptions.get(EditorOption.wordWrapBreakAfterCharacters),\n\t\t);\n\t}\n\n\tprivate readonly classifier: WrappingCharacterClassifier;\n\n\tconstructor(breakBeforeChars: string, breakAfterChars: string) {\n\t\tthis.classifier = new WrappingCharacterClassifier(\n\t\t\tbreakBeforeChars,\n\t\t\tbreakAfterChars,\n\t\t);\n\t}\n\n\tpublic createLineBreaksComputer(\n\t\tfontInfo: FontInfo,\n\t\ttabSize: number,\n\t\twrappingColumn: number,\n\t\twrappingIndent: WrappingIndent,\n\t\twordBreak: \"normal\" | \"keepAll\",\n\t): ILineBreaksComputer {\n\t\tconst requests: string[] = [];\n\t\tconst injectedTexts: (LineInjectedText[] | null)[] = [];\n\t\tconst previousBreakingData: (ModelLineProjectionData | null)[] = [];\n\t\treturn {\n\t\t\taddRequest: (\n\t\t\t\tlineText: string,\n\t\t\t\tinjectedText: LineInjectedText[] | null,\n\t\t\t\tpreviousLineBreakData: ModelLineProjectionData | null,\n\t\t\t) => {\n\t\t\t\trequests.push(lineText);\n\t\t\t\tinjectedTexts.push(injectedText);\n\t\t\t\tpreviousBreakingData.push(previousLineBreakData);\n\t\t\t},\n\t\t\tfinalize: () => {\n\t\t\t\tconst columnsForFullWidthChar =\n\t\t\t\t\tfontInfo.typicalFullwidthCharacterWidth /\n\t\t\t\t\tfontInfo.typicalHalfwidthCharacterWidth;\n\t\t\t\tconst result: (ModelLineProjectionData | null)[] = [];\n\t\t\t\tfor (let i = 0, len = requests.length; i < len; i++) {\n\t\t\t\t\tconst injectedText = injectedTexts[i];\n\t\t\t\t\tconst previousLineBreakData = previousBreakingData[i];\n\t\t\t\t\tif (\n\t\t\t\t\t\tpreviousLineBreakData &&\n\t\t\t\t\t\t!previousLineBreakData.injectionOptions &&\n\t\t\t\t\t\t!injectedText\n\t\t\t\t\t) {\n\t\t\t\t\t\tresult[i] = createLineBreaksFromPreviousLineBreaks(\n\t\t\t\t\t\t\tthis.classifier,\n\t\t\t\t\t\t\tpreviousLineBreakData,\n\t\t\t\t\t\t\trequests[i],\n\t\t\t\t\t\t\ttabSize,\n\t\t\t\t\t\t\twrappingColumn,\n\t\t\t\t\t\t\tcolumnsForFullWidthChar,\n\t\t\t\t\t\t\twrappingIndent,\n\t\t\t\t\t\t\twordBreak,\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult[i] = createLineBreaks(\n\t\t\t\t\t\t\tthis.classifier,\n\t\t\t\t\t\t\trequests[i],\n\t\t\t\t\t\t\tinjectedText,\n\t\t\t\t\t\t\ttabSize,\n\t\t\t\t\t\t\twrappingColumn,\n\t\t\t\t\t\t\tcolumnsForFullWidthChar,\n\t\t\t\t\t\t\twrappingIndent,\n\t\t\t\t\t\t\twordBreak,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tarrPool1.length = 0;\n\t\t\t\tarrPool2.length = 0;\n\t\t\t\treturn result;\n\t\t\t},\n\t\t};\n\t}\n}\n\nenum CharacterClass {\n\tNONE = 0,\n\tBREAK_BEFORE = 1,\n\tBREAK_AFTER = 2,\n\tBREAK_IDEOGRAPHIC = 3, // for Han and Kana.\n}\n\nclass WrappingCharacterClassifier extends CharacterClassifier<CharacterClass> {\n\tconstructor(BREAK_BEFORE: string, BREAK_AFTER: string) {\n\t\tsuper(CharacterClass.NONE);\n\n\t\tfor (let i = 0; i < BREAK_BEFORE.length; i++) {\n\t\t\tthis.set(BREAK_BEFORE.charCodeAt(i), CharacterClass.BREAK_BEFORE);\n\t\t}\n\n\t\tfor (let i = 0; i < BREAK_AFTER.length; i++) {\n\t\t\tthis.set(BREAK_AFTER.charCodeAt(i), CharacterClass.BREAK_AFTER);\n\t\t}\n\t}\n\n\tpublic override get(charCode: number): CharacterClass {\n\t\tif (charCode >= 0 && charCode < 256) {\n\t\t\treturn <CharacterClass>this._asciiMap[charCode];\n\t\t} else {\n\t\t\t// Initialize CharacterClass.BREAK_IDEOGRAPHIC for these Unicode ranges:\n\t\t\t// 1. CJK Unified Ideographs (0x4E00 -- 0x9FFF)\n\t\t\t// 2. CJK Unified Ideographs Extension A (0x3400 -- 0x4DBF)\n\t\t\t// 3. Hiragana and Katakana (0x3040 -- 0x30FF)\n\t\t\tif (\n\t\t\t\t(charCode >= 0x3040 && charCode <= 0x30ff) ||\n\t\t\t\t(charCode >= 0x3400 && charCode <= 0x4dbf) ||\n\t\t\t\t(charCode >= 0x4e00 && charCode <= 0x9fff)\n\t\t\t) {\n\t\t\t\treturn CharacterClass.BREAK_IDEOGRAPHIC;\n\t\t\t}\n\n\t\t\treturn <CharacterClass>(\n\t\t\t\t(this._map.get(charCode) || this._defaultValue)\n\t\t\t);\n\t\t}\n\t}\n}\n\nlet arrPool1: number[] = [];\nlet arrPool2: number[] = [];\n\nfunction createLineBreaksFromPreviousLineBreaks(\n\tclassifier: WrappingCharacterClassifier,\n\tpreviousBreakingData: ModelLineProjectionData,\n\tlineText: string,\n\ttabSize: number,\n\tfirstLineBreakColumn: number,\n\tcolumnsForFullWidthChar: number,\n\twrappingIndent: WrappingIndent,\n\twordBreak: \"normal\" | \"keepAll\",\n): ModelLineProjectionData | null {\n\tif (firstLineBreakColumn === -1) {\n\t\treturn null;\n\t}\n\n\tconst len = lineText.length;\n\tif (len <= 1) {\n\t\treturn null;\n\t}\n\n\tconst isKeepAll = wordBreak === \"keepAll\";\n\n\tconst prevBreakingOffsets = previousBreakingData.breakOffsets;\n\tconst prevBreakingOffsetsVisibleColumn =\n\t\tpreviousBreakingData.breakOffsetsVisibleColumn;\n\n\tconst wrappedTextIndentLength = computeWrappedTextIndentLength(\n\t\tlineText,\n\t\ttabSize,\n\t\tfirstLineBreakColumn,\n\t\tcolumnsForFullWidthChar,\n\t\twrappingIndent,\n\t);\n\tconst wrappedLineBreakColumn =\n\t\tfirstLineBreakColumn - wrappedTextIndentLength;\n\n\tconst breakingOffsets: number[] = arrPool1;\n\tconst breakingOffsetsVisibleColumn: number[] = arrPool2;\n\tlet breakingOffsetsCount = 0;\n\tlet lastBreakingOffset = 0;\n\tlet lastBreakingOffsetVisibleColumn = 0;\n\n\tlet breakingColumn = firstLineBreakColumn;\n\tconst prevLen = prevBreakingOffsets.length;\n\tlet prevIndex = 0;\n\n\tif (prevIndex >= 0) {\n\t\tlet bestDistance = Math.abs(\n\t\t\tprevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn,\n\t\t);\n\t\twhile (prevIndex + 1 < prevLen) {\n\t\t\tconst distance = Math.abs(\n\t\t\t\tprevBreakingOffsetsVisibleColumn[prevIndex + 1] -\n\t\t\t\t\tbreakingColumn,\n\t\t\t);\n\t\t\tif (distance >= bestDistance) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbestDistance = distance;\n\t\t\tprevIndex++;\n\t\t}\n\t}\n\n\twhile (prevIndex < prevLen) {\n\t\t// Allow for prevIndex to be -1 (for the case where we hit a tab when walking backwards from the first break)\n\t\tlet prevBreakOffset =\n\t\t\tprevIndex < 0 ? 0 : prevBreakingOffsets[prevIndex];\n\t\tlet prevBreakOffsetVisibleColumn =\n\t\t\tprevIndex < 0 ? 0 : prevBreakingOffsetsVisibleColumn[prevIndex];\n\t\tif (lastBreakingOffset > prevBreakOffset) {\n\t\t\tprevBreakOffset = lastBreakingOffset;\n\t\t\tprevBreakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn;\n\t\t}\n\n\t\tlet breakOffset = 0;\n\t\tlet breakOffsetVisibleColumn = 0;\n\n\t\tlet forcedBreakOffset = 0;\n\t\tlet forcedBreakOffsetVisibleColumn = 0;\n\n\t\t// initially, we search as much as possible to the right (if it fits)\n\t\tif (prevBreakOffsetVisibleColumn <= breakingColumn) {\n\t\t\tlet visibleColumn = prevBreakOffsetVisibleColumn;\n\t\t\tlet prevCharCode =\n\t\t\t\tprevBreakOffset === 0\n\t\t\t\t\t? CharCode.Null\n\t\t\t\t\t: lineText.charCodeAt(prevBreakOffset - 1);\n\t\t\tlet prevCharCodeClass =\n\t\t\t\tprevBreakOffset === 0\n\t\t\t\t\t? CharacterClass.NONE\n\t\t\t\t\t: classifier.get(prevCharCode);\n\t\t\tlet entireLineFits = true;\n\t\t\tfor (let i = prevBreakOffset; i < len; i++) {\n\t\t\t\tconst charStartOffset = i;\n\t\t\t\tconst charCode = lineText.charCodeAt(i);\n\t\t\t\tlet charCodeClass: number;\n\t\t\t\tlet charWidth: number;\n\n\t\t\t\tif (strings.isHighSurrogate(charCode)) {\n\t\t\t\t\t// A surrogate pair must always be considered as a single unit, so it is never to be broken\n\t\t\t\t\ti++;\n\t\t\t\t\tcharCodeClass = CharacterClass.NONE;\n\t\t\t\t\tcharWidth = 2;\n\t\t\t\t} else {\n\t\t\t\t\tcharCodeClass = classifier.get(charCode);\n\t\t\t\t\tcharWidth = computeCharWidth(\n\t\t\t\t\t\tcharCode,\n\t\t\t\t\t\tvisibleColumn,\n\t\t\t\t\t\ttabSize,\n\t\t\t\t\t\tcolumnsForFullWidthChar,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tcharStartOffset > lastBreakingOffset &&\n\t\t\t\t\tcanBreak(\n\t\t\t\t\t\tprevCharCode,\n\t\t\t\t\t\tprevCharCodeClass,\n\t\t\t\t\t\tcharCode,\n\t\t\t\t\t\tcharCodeClass,\n\t\t\t\t\t\tisKeepAll,\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tbreakOffset = charStartOffset;\n\t\t\t\t\tbreakOffsetVisibleColumn = visibleColumn;\n\t\t\t\t}\n\n\t\t\t\tvisibleColumn += charWidth;\n\n\t\t\t\t// check if adding character at `i` will go over the breaking column\n\t\t\t\tif (visibleColumn > breakingColumn) {\n\t\t\t\t\t// We need to break at least before character at `i`:\n\t\t\t\t\tif (charStartOffset > lastBreakingOffset) {\n\t\t\t\t\t\tforcedBreakOffset = charStartOffset;\n\t\t\t\t\t\tforcedBreakOffsetVisibleColumn =\n\t\t\t\t\t\t\tvisibleColumn - charWidth;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// we need to advance at least by one character\n\t\t\t\t\t\tforcedBreakOffset = i + 1;\n\t\t\t\t\t\tforcedBreakOffsetVisibleColumn = visibleColumn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tvisibleColumn - breakOffsetVisibleColumn >\n\t\t\t\t\t\twrappedLineBreakColumn\n\t\t\t\t\t) {\n\t\t\t\t\t\t// Cannot break at `breakOffset` => reset it if it was set\n\t\t\t\t\t\tbreakOffset = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tentireLineFits = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tprevCharCode = charCode;\n\t\t\t\tprevCharCodeClass = charCodeClass;\n\t\t\t}\n\n\t\t\tif (entireLineFits) {\n\t\t\t\t// there is no more need to break => stop the outer loop!\n\t\t\t\tif (breakingOffsetsCount > 0) {\n\t\t\t\t\t// Add last segment, no need to assign to `lastBreakingOffset` and `lastBreakingOffsetVisibleColumn`\n\t\t\t\t\tbreakingOffsets[breakingOffsetsCount] =\n\t\t\t\t\t\tprevBreakingOffsets[prevBreakingOffsets.length - 1];\n\t\t\t\t\tbreakingOffsetsVisibleColumn[breakingOffsetsCount] =\n\t\t\t\t\t\tprevBreakingOffsetsVisibleColumn[\n\t\t\t\t\t\t\tprevBreakingOffsets.length - 1\n\t\t\t\t\t\t];\n\t\t\t\t\tbreakingOffsetsCount++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (breakOffset === 0) {\n\t\t\t// must search left\n\t\t\tlet visibleColumn = prevBreakOffsetVisibleColumn;\n\t\t\tlet charCode = lineText.charCodeAt(prevBreakOffset);\n\t\t\tlet charCodeClass = classifier.get(charCode);\n\t\t\tlet hitATabCharacter = false;\n\t\t\tfor (let i = prevBreakOffset - 1; i >= lastBreakingOffset; i--) {\n\t\t\t\tconst charStartOffset = i + 1;\n\t\t\t\tconst prevCharCode = lineText.charCodeAt(i);\n\n\t\t\t\tif (prevCharCode === CharCode.Tab) {\n\t\t\t\t\t// cannot determine the width of a tab when going backwards, so we must go forwards\n\t\t\t\t\thitATabCharacter = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tlet prevCharCodeClass: number;\n\t\t\t\tlet prevCharWidth: number;\n\n\t\t\t\tif (strings.isLowSurrogate(prevCharCode)) {\n\t\t\t\t\t// A surrogate pair must always be considered as a single unit, so it is never to be broken\n\t\t\t\t\ti--;\n\t\t\t\t\tprevCharCodeClass = CharacterClass.NONE;\n\t\t\t\t\tprevCharWidth = 2;\n\t\t\t\t} else {\n\t\t\t\t\tprevCharCodeClass = classifier.get(prevCharCode);\n\t\t\t\t\tprevCharWidth = strings.isFullWidthCharacter(prevCharCode)\n\t\t\t\t\t\t? columnsForFullWidthChar\n\t\t\t\t\t\t: 1;\n\t\t\t\t}\n\n\t\t\t\tif (visibleColumn <= breakingColumn) {\n\t\t\t\t\tif (forcedBreakOffset === 0) {\n\t\t\t\t\t\tforcedBreakOffset = charStartOffset;\n\t\t\t\t\t\tforcedBreakOffsetVisibleColumn = visibleColumn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tvisibleColumn <=\n\t\t\t\t\t\tbreakingColumn - wrappedLineBreakColumn\n\t\t\t\t\t) {\n\t\t\t\t\t\t// went too far!\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tcanBreak(\n\t\t\t\t\t\t\tprevCharCode,\n\t\t\t\t\t\t\tprevCharCodeClass,\n\t\t\t\t\t\t\tcharCode,\n\t\t\t\t\t\t\tcharCodeClass,\n\t\t\t\t\t\t\tisKeepAll,\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tbreakOffset = charStartOffset;\n\t\t\t\t\t\tbreakOffsetVisibleColumn = visibleColumn;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvisibleColumn -= prevCharWidth;\n\t\t\t\tcharCode = prevCharCode;\n\t\t\t\tcharCodeClass = prevCharCodeClass;\n\t\t\t}\n\n\t\t\tif (breakOffset !== 0) {\n\t\t\t\tconst remainingWidthOfNextLine =\n\t\t\t\t\twrappedLineBreakColumn -\n\t\t\t\t\t(forcedBreakOffsetVisibleColumn - breakOffsetVisibleColumn);\n\t\t\t\tif (remainingWidthOfNextLine <= tabSize) {\n\t\t\t\t\tconst charCodeAtForcedBreakOffset =\n\t\t\t\t\t\tlineText.charCodeAt(forcedBreakOffset);\n\t\t\t\t\tlet charWidth: number;\n\t\t\t\t\tif (strings.isHighSurrogate(charCodeAtForcedBreakOffset)) {\n\t\t\t\t\t\t// A surrogate pair must always be considered as a single unit, so it is never to be broken\n\t\t\t\t\t\tcharWidth = 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcharWidth = computeCharWidth(\n\t\t\t\t\t\t\tcharCodeAtForcedBreakOffset,\n\t\t\t\t\t\t\tforcedBreakOffsetVisibleColumn,\n\t\t\t\t\t\t\ttabSize,\n\t\t\t\t\t\t\tcolumnsForFullWidthChar,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif (remainingWidthOfNextLine - charWidth < 0) {\n\t\t\t\t\t\t// it is not worth it to break at breakOffset, it just introduces an extra needless line!\n\t\t\t\t\t\tbreakOffset = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hitATabCharacter) {\n\t\t\t\t// cannot determine the width of a tab when going backwards, so we must go forwards from the previous break\n\t\t\t\tprevIndex--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (breakOffset === 0) {\n\t\t\t// Could not find a good breaking point\n\t\t\tbreakOffset = forcedBreakOffset;\n\t\t\tbreakOffsetVisibleColumn = forcedBreakOffsetVisibleColumn;\n\t\t}\n\n\t\tif (breakOffset <= lastBreakingOffset) {\n\t\t\t// Make sure that we are advancing (at least one character)\n\t\t\tconst charCode = lineText.charCodeAt(lastBreakingOffset);\n\t\t\tif (strings.isHighSurrogate(charCode)) {\n\t\t\t\t// A surrogate pair must always be considered as a single unit, so it is never to be broken\n\t\t\t\tbreakOffset = lastBreakingOffset + 2;\n\t\t\t\tbreakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn + 2;\n\t\t\t} else {\n\t\t\t\tbreakOffset = lastBreakingOffset + 1;\n\t\t\t\tbreakOffsetVisibleColumn =\n\t\t\t\t\tlastBreakingOffsetVisibleColumn +\n\t\t\t\t\tcomputeCharWidth(\n\t\t\t\t\t\tcharCode,\n\t\t\t\t\t\tlastBreakingOffsetVisibleColumn,\n\t\t\t\t\t\ttabSize,\n\t\t\t\t\t\tcolumnsForFullWidthChar,\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tlastBreakingOffset = breakOffset;\n\t\tbreakingOffsets[breakingOffsetsCount] = breakOffset;\n\t\tlastBreakingOffsetVisibleColumn = breakOffsetVisibleColumn;\n\t\tbreakingOffsetsVisibleColumn[breakingOffsetsCount] =\n\t\t\tbreakOffsetVisibleColumn;\n\t\tbreakingOffsetsCount++;\n\t\tbreakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\n\n\t\twhile (\n\t\t\tprevIndex < 0 ||\n\t\t\t(prevIndex < prevLen &&\n\t\t\t\tprevBreakingOffsetsVisibleColumn[prevIndex] <\n\t\t\t\t\tbreakOffsetVisibleColumn)\n\t\t) {\n\t\t\tprevIndex++;\n\t\t}\n\n\t\tlet bestDistance = Math.abs(\n\t\t\tprevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn,\n\t\t);\n\t\twhile (prevIndex + 1 < prevLen) {\n\t\t\tconst distance = Math.abs(\n\t\t\t\tprevBreakingOffsetsVisibleColumn[prevIndex + 1] -\n\t\t\t\t\tbreakingColumn,\n\t\t\t);\n\t\t\tif (distance >= bestDistance) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbestDistance = distance;\n\t\t\tprevIndex++;\n\t\t}\n\t}\n\n\tif (breakingOffsetsCount === 0) {\n\t\treturn null;\n\t}\n\n\t// Doing here some object reuse which ends up helping a huge deal with GC pauses!\n\tbreakingOffsets.length = breakingOffsetsCount;\n\tbreakingOffsetsVisibleColumn.length = breakingOffsetsCount;\n\tarrPool1 = previousBreakingData.breakOffsets;\n\tarrPool2 = previousBreakingData.breakOffsetsVisibleColumn;\n\tpreviousBreakingData.breakOffsets = breakingOffsets;\n\tpreviousBreakingData.breakOffsetsVisibleColumn =\n\t\tbreakingOffsetsVisibleColumn;\n\tpreviousBreakingData.wrappedTextIndentLength = wrappedTextIndentLength;\n\treturn previousBreakingData;\n}\n\nfunction createLineBreaks(\n\tclassifier: WrappingCharacterClassifier,\n\t_lineText: string,\n\tinjectedTexts: LineInjectedText[] | null,\n\ttabSize: number,\n\tfirstLineBreakColumn: number,\n\tcolumnsForFullWidthChar: number,\n\twrappingIndent: WrappingIndent,\n\twordBreak: \"normal\" | \"keepAll\",\n): ModelLineProjectionData | null {\n\tconst lineText = LineInjectedText.applyInjectedText(\n\t\t_lineText,\n\t\tinjectedTexts,\n\t);\n\n\tlet injectionOptions: InjectedTextOptions[] | null;\n\tlet injectionOffsets: number[] | null;\n\tif (injectedTexts && injectedTexts.length > 0) {\n\t\tinjectionOptions = injectedTexts.map((t) => t.options);\n\t\tinjectionOffsets = injectedTexts.map((text) => text.column - 1);\n\t} else {\n\t\tinjectionOptions = null;\n\t\tinjectionOffsets = null;\n\t}\n\n\tif (firstLineBreakColumn === -1) {\n\t\tif (!injectionOptions) {\n\t\t\treturn null;\n\t\t}\n\t\t// creating a `LineBreakData` with an invalid `breakOffsetsVisibleColumn` is OK\n\t\t// because `breakOffsetsVisibleColumn` will never be used because it contains injected text\n\t\treturn new ModelLineProjectionData(\n\t\t\tinjectionOffsets,\n\t\t\tinjectionOptions,\n\t\t\t[lineText.length],\n\t\t\t[],\n\t\t\t0,\n\t\t);\n\t}\n\n\tconst len = lineText.length;\n\tif (len <= 1) {\n\t\tif (!injectionOptions) {\n\t\t\treturn null;\n\t\t}\n\t\t// creating a `LineBreakData` with an invalid `breakOffsetsVisibleColumn` is OK\n\t\t// because `breakOffsetsVisibleColumn` will never be used because it contains injected text\n\t\treturn new ModelLineProjectionData(\n\t\t\tinjectionOffsets,\n\t\t\tinjectionOptions,\n\t\t\t[lineText.length],\n\t\t\t[],\n\t\t\t0,\n\t\t);\n\t}\n\n\tconst isKeepAll = wordBreak === \"keepAll\";\n\tconst wrappedTextIndentLength = computeWrappedTextIndentLength(\n\t\tlineText,\n\t\ttabSize,\n\t\tfirstLineBreakColumn,\n\t\tcolumnsForFullWidthChar,\n\t\twrappingIndent,\n\t);\n\tconst wrappedLineBreakColumn =\n\t\tfirstLineBreakColumn - wrappedTextIndentLength;\n\n\tconst breakingOffsets: number[] = [];\n\tconst breakingOffsetsVisibleColumn: number[] = [];\n\tlet breakingOffsetsCount = 0;\n\tlet breakOffset = 0;\n\tlet breakOffsetVisibleColumn = 0;\n\n\tlet breakingColumn = firstLineBreakColumn;\n\tlet prevCharCode = lineText.charCodeAt(0);\n\tlet prevCharCodeClass = classifier.get(prevCharCode);\n\tlet visibleColumn = computeCharWidth(\n\t\tprevCharCode,\n\t\t0,\n\t\ttabSize,\n\t\tcolumnsForFullWidthChar,\n\t);\n\n\tlet startOffset = 1;\n\tif (strings.isHighSurrogate(prevCharCode)) {\n\t\t// A surrogate pair must always be considered as a single unit, so it is never to be broken\n\t\tvisibleColumn += 1;\n\t\tprevCharCode = lineText.charCodeAt(1);\n\t\tprevCharCodeClass = classifier.get(prevCharCode);\n\t\tstartOffset++;\n\t}\n\n\tfor (let i = startOffset; i < len; i++) {\n\t\tconst charStartOffset = i;\n\t\tconst charCode = lineText.charCodeAt(i);\n\t\tlet charCodeClass: CharacterClass;\n\t\tlet charWidth: number;\n\n\t\tif (strings.isHighSurrogate(charCode)) {\n\t\t\t// A surrogate pair must always be considered as a single unit, so it is never to be broken\n\t\t\ti++;\n\t\t\tcharCodeClass = CharacterClass.NONE;\n\t\t\tcharWidth = 2;\n\t\t} else {\n\t\t\tcharCodeClass = classifier.get(charCode);\n\t\t\tcharWidth = computeCharWidth(\n\t\t\t\tcharCode,\n\t\t\t\tvisibleColumn,\n\t\t\t\ttabSize,\n\t\t\t\tcolumnsForFullWidthChar,\n\t\t\t);\n\t\t}\n\n\t\tif (\n\t\t\tcanBreak(\n\t\t\t\tprevCharCode,\n\t\t\t\tprevCharCodeClass,\n\t\t\t\tcharCode,\n\t\t\t\tcharCodeClass,\n\t\t\t\tisKeepAll,\n\t\t\t)\n\t\t) {\n\t\t\tbreakOffset = charStartOffset;\n\t\t\tbreakOffsetVisibleColumn = visibleColumn;\n\t\t}\n\n\t\tvisibleColumn += charWidth;\n\n\t\t// check if adding character at `i` will go over the breaking column\n\t\tif (visibleColumn > breakingColumn) {\n\t\t\t// We need to break at least before character at `i`:\n\n\t\t\tif (\n\t\t\t\tbreakOffset === 0 ||\n\t\t\t\tvisibleColumn - breakOffsetVisibleColumn >\n\t\t\t\t\twrappedLineBreakColumn\n\t\t\t) {\n\t\t\t\t// Cannot break at `breakOffset`, must break at `i`\n\t\t\t\tbreakOffset = charStartOffset;\n\t\t\t\tbreakOffsetVisibleColumn = visibleColumn - charWidth;\n\t\t\t}\n\n\t\t\tbreakingOffsets[breakingOffsetsCount] = breakOffset;\n\t\t\tbreakingOffsetsVisibleColumn[breakingOffsetsCount] =\n\t\t\t\tbreakOffsetVisibleColumn;\n\t\t\tbreakingOffsetsCount++;\n\t\t\tbreakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\n\t\t\tbreakOffset = 0;\n\t\t}\n\n\t\tprevCharCode = charCode;\n\t\tprevCharCodeClass = charCodeClass;\n\t}\n\n\tif (\n\t\tbreakingOffsetsCount === 0 &&\n\t\t(!injectedTexts || injectedTexts.length === 0)\n\t) {\n\t\treturn null;\n\t}\n\n\t// Add last segment\n\tbreakingOffsets[breakingOffsetsCount] = len;\n\tbreakingOffsetsVisibleColumn[breakingOffsetsCount] = visibleColumn;\n\n\treturn new ModelLineProjectionData(\n\t\tinjectionOffsets,\n\t\tinjectionOptions,\n\t\tbreakingOffsets,\n\t\tbreakingOffsetsVisibleColumn,\n\t\twrappedTextIndentLength,\n\t);\n}\n\nfunction computeCharWidth(\n\tcharCode: number,\n\tvisibleColumn: number,\n\ttabSize: number,\n\tcolumnsForFullWidthChar: number,\n): number {\n\tif (charCode === CharCode.Tab) {\n\t\treturn tabSize - (visibleColumn % tabSize);\n\t}\n\tif (strings.isFullWidthCharacter(charCode)) {\n\t\treturn columnsForFullWidthChar;\n\t}\n\tif (charCode < 32) {\n\t\t// when using `editor.renderControlCharacters`, the substitutions are often wide\n\t\treturn columnsForFullWidthChar;\n\t}\n\treturn 1;\n}\n\nfunction tabCharacterWidth(visibleColumn: number, tabSize: number): number {\n\treturn tabSize - (visibleColumn % tabSize);\n}\n\n/**\n * Kinsoku Shori : Don't break after a leading character, like an open bracket\n * Kinsoku Shori : Don't break before a trailing character, like a period\n */\nfunction canBreak(\n\tprevCharCode: number,\n\tprevCharCodeClass: CharacterClass,\n\tcharCode: number,\n\tcharCodeClass: CharacterClass,\n\tisKeepAll: boolean,\n): boolean {\n\treturn (\n\t\tcharCode !== CharCode.Space &&\n\t\t((prevCharCodeClass === CharacterClass.BREAK_AFTER &&\n\t\t\tcharCodeClass !== CharacterClass.BREAK_AFTER) || // break at the end of multiple BREAK_AFTER\n\t\t\t(prevCharCodeClass !== CharacterClass.BREAK_BEFORE &&\n\t\t\t\tcharCodeClass === CharacterClass.BREAK_BEFORE) || // break at the start of multiple BREAK_BEFORE\n\t\t\t(!isKeepAll &&\n\t\t\t\tprevCharCodeClass === CharacterClass.BREAK_IDEOGRAPHIC &&\n\t\t\t\tcharCodeClass !== CharacterClass.BREAK_AFTER) ||\n\t\t\t(!isKeepAll &&\n\t\t\t\tcharCodeClass === CharacterClass.BREAK_IDEOGRAPHIC &&\n\t\t\t\tprevCharCodeClass !== CharacterClass.BREAK_BEFORE))\n\t);\n}\n\nfunction computeWrappedTextIndentLength(\n\tlineText: string,\n\ttabSize: number,\n\tfirstLineBreakColumn: number,\n\tcolumnsForFullWidthChar: number,\n\twrappingIndent: WrappingIndent,\n): number {\n\tlet wrappedTextIndentLength = 0;\n\tif (wrappingIndent !== WrappingIndent.None) {\n\t\tconst firstNonWhitespaceIndex =\n\t\t\tstrings.firstNonWhitespaceIndex(lineText);\n\t\tif (firstNonWhitespaceIndex !== -1) {\n\t\t\t// Track existing indent\n\n\t\t\tfor (let i = 0; i < firstNonWhitespaceIndex; i++) {\n\t\t\t\tconst charWidth =\n\t\t\t\t\tlineText.charCodeAt(i) === CharCode.Tab\n\t\t\t\t\t\t? tabCharacterWidth(wrappedTextIndentLength, tabSize)\n\t\t\t\t\t\t: 1;\n\t\t\t\twrappedTextIndentLength += charWidth;\n\t\t\t}\n\n\t\t\t// Increase indent of continuation lines, if desired\n\t\t\tconst numberOfAdditionalTabs =\n\t\t\t\twrappingIndent === WrappingIndent.DeepIndent\n\t\t\t\t\t? 2\n\t\t\t\t\t: wrappingIndent === WrappingIndent.Indent\n\t\t\t\t\t\t? 1\n\t\t\t\t\t\t: 0;\n\t\t\tfor (let i = 0; i < numberOfAdditionalTabs; i++) {\n\t\t\t\tconst charWidth = tabCharacterWidth(\n\t\t\t\t\twrappedTextIndentLength,\n\t\t\t\t\ttabSize,\n\t\t\t\t);\n\t\t\t\twrappedTextIndentLength += charWidth;\n\t\t\t}\n\n\t\t\t// Force sticking to beginning of line if no character would fit except for the indentation\n\t\t\tif (\n\t\t\t\twrappedTextIndentLength + columnsForFullWidthChar >\n\t\t\t\tfirstLineBreakColumn\n\t\t\t) {\n\t\t\t\twrappedTextIndentLength = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn wrappedTextIndentLength;\n}\n"],
  "mappings": "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",
  "names": ["CharacterClass"]
}
