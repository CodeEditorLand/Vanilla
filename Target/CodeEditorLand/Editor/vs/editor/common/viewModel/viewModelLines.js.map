{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/viewModel/viewModelLines.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from '../../../base/common/arrays.js';\nimport { IDisposable } from '../../../base/common/lifecycle.js';\nimport { WrappingIndent } from '../config/editorOptions.js';\nimport { FontInfo } from '../config/fontInfo.js';\nimport { IPosition, Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { IModelDecoration, IModelDeltaDecoration, ITextModel, PositionAffinity } from '../model.js';\nimport { IActiveIndentGuideInfo, BracketGuideOptions, IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nimport { ModelDecorationOptions } from '../model/textModel.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport * as viewEvents from '../viewEvents.js';\nimport { createModelLineProjection, IModelLineProjection } from './modelLineProjection.js';\nimport { ILineBreaksComputer, ModelLineProjectionData, InjectedText, ILineBreaksComputerFactory } from '../modelLineProjectionData.js';\nimport { ConstantTimePrefixSumComputer } from '../model/prefixSumComputer.js';\nimport { ICoordinatesConverter, ViewLineData } from '../viewModel.js';\n\nexport interface IViewModelLines extends IDisposable {\n\tcreateCoordinatesConverter(): ICoordinatesConverter;\n\n\tsetWrappingSettings(fontInfo: FontInfo, wrappingStrategy: 'simple' | 'advanced', wrappingColumn: number, wrappingIndent: WrappingIndent, wordBreak: 'normal' | 'keepAll'): boolean;\n\tsetTabSize(newTabSize: number): boolean;\n\tgetHiddenAreas(): Range[];\n\tsetHiddenAreas(_ranges: readonly Range[]): boolean;\n\n\tcreateLineBreaksComputer(): ILineBreaksComputer;\n\tonModelFlushed(): void;\n\tonModelLinesDeleted(versionId: number | null, fromLineNumber: number, toLineNumber: number): viewEvents.ViewLinesDeletedEvent | null;\n\tonModelLinesInserted(versionId: number | null, fromLineNumber: number, toLineNumber: number, lineBreaks: (ModelLineProjectionData | null)[]): viewEvents.ViewLinesInsertedEvent | null;\n\tonModelLineChanged(versionId: number | null, lineNumber: number, lineBreakData: ModelLineProjectionData | null): [boolean, viewEvents.ViewLinesChangedEvent | null, viewEvents.ViewLinesInsertedEvent | null, viewEvents.ViewLinesDeletedEvent | null];\n\tacceptVersionId(versionId: number): void;\n\n\tgetViewLineCount(): number;\n\tgetActiveIndentGuide(viewLineNumber: number, minLineNumber: number, maxLineNumber: number): IActiveIndentGuideInfo;\n\tgetViewLinesIndentGuides(viewStartLineNumber: number, viewEndLineNumber: number): number[];\n\tgetViewLinesBracketGuides(startLineNumber: number, endLineNumber: number, activePosition: IPosition | null, options: BracketGuideOptions): IndentGuide[][];\n\tgetViewLineContent(viewLineNumber: number): string;\n\tgetViewLineLength(viewLineNumber: number): number;\n\tgetViewLineMinColumn(viewLineNumber: number): number;\n\tgetViewLineMaxColumn(viewLineNumber: number): number;\n\tgetViewLineData(viewLineNumber: number): ViewLineData;\n\tgetViewLinesData(viewStartLineNumber: number, viewEndLineNumber: number, needed: boolean[]): Array<ViewLineData | null>;\n\n\tgetDecorationsInRange(range: Range, ownerId: number, filterOutValidation: boolean, onlyMinimapDecorations: boolean, onlyMarginDecorations: boolean): IModelDecoration[];\n\n\tgetInjectedTextAt(viewPosition: Position): InjectedText | null;\n\n\tnormalizePosition(position: Position, affinity: PositionAffinity): Position;\n\t/**\n\t * Gets the column at which indentation stops at a given line.\n\t * @internal\n\t*/\n\tgetLineIndentColumn(lineNumber: number): number;\n}\n\nexport class ViewModelLinesFromProjectedModel implements IViewModelLines {\n\tprivate readonly _editorId: number;\n\tprivate readonly model: ITextModel;\n\tprivate _validModelVersionId: number;\n\n\tprivate readonly _domLineBreaksComputerFactory: ILineBreaksComputerFactory;\n\tprivate readonly _monospaceLineBreaksComputerFactory: ILineBreaksComputerFactory;\n\n\tprivate fontInfo: FontInfo;\n\tprivate tabSize: number;\n\tprivate wrappingColumn: number;\n\tprivate wrappingIndent: WrappingIndent;\n\tprivate wordBreak: 'normal' | 'keepAll';\n\tprivate wrappingStrategy: 'simple' | 'advanced';\n\n\tprivate modelLineProjections!: IModelLineProjection[];\n\n\t/**\n\t * Reflects the sum of the line counts of all projected model lines.\n\t*/\n\tprivate projectedModelLineLineCounts!: ConstantTimePrefixSumComputer;\n\n\tprivate hiddenAreasDecorationIds!: string[];\n\n\tconstructor(\n\t\teditorId: number,\n\t\tmodel: ITextModel,\n\t\tdomLineBreaksComputerFactory: ILineBreaksComputerFactory,\n\t\tmonospaceLineBreaksComputerFactory: ILineBreaksComputerFactory,\n\t\tfontInfo: FontInfo,\n\t\ttabSize: number,\n\t\twrappingStrategy: 'simple' | 'advanced',\n\t\twrappingColumn: number,\n\t\twrappingIndent: WrappingIndent,\n\t\twordBreak: 'normal' | 'keepAll'\n\t) {\n\t\tthis._editorId = editorId;\n\t\tthis.model = model;\n\t\tthis._validModelVersionId = -1;\n\t\tthis._domLineBreaksComputerFactory = domLineBreaksComputerFactory;\n\t\tthis._monospaceLineBreaksComputerFactory = monospaceLineBreaksComputerFactory;\n\t\tthis.fontInfo = fontInfo;\n\t\tthis.tabSize = tabSize;\n\t\tthis.wrappingStrategy = wrappingStrategy;\n\t\tthis.wrappingColumn = wrappingColumn;\n\t\tthis.wrappingIndent = wrappingIndent;\n\t\tthis.wordBreak = wordBreak;\n\n\t\tthis._constructLines(/*resetHiddenAreas*/true, null);\n\t}\n\n\tpublic dispose(): void {\n\t\tthis.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);\n\t}\n\n\tpublic createCoordinatesConverter(): ICoordinatesConverter {\n\t\treturn new CoordinatesConverter(this);\n\t}\n\n\tprivate _constructLines(resetHiddenAreas: boolean, previousLineBreaks: ((ModelLineProjectionData | null)[]) | null): void {\n\t\tthis.modelLineProjections = [];\n\n\t\tif (resetHiddenAreas) {\n\t\t\tthis.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);\n\t\t}\n\n\t\tconst linesContent = this.model.getLinesContent();\n\t\tconst injectedTextDecorations = this.model.getInjectedTextDecorations(this._editorId);\n\t\tconst lineCount = linesContent.length;\n\t\tconst lineBreaksComputer = this.createLineBreaksComputer();\n\n\t\tconst injectedTextQueue = new arrays.ArrayQueue(LineInjectedText.fromDecorations(injectedTextDecorations));\n\t\tfor (let i = 0; i < lineCount; i++) {\n\t\t\tconst lineInjectedText = injectedTextQueue.takeWhile(t => t.lineNumber === i + 1);\n\t\t\tlineBreaksComputer.addRequest(linesContent[i], lineInjectedText, previousLineBreaks ? previousLineBreaks[i] : null);\n\t\t}\n\t\tconst linesBreaks = lineBreaksComputer.finalize();\n\n\t\tconst values: number[] = [];\n\n\t\tconst hiddenAreas = this.hiddenAreasDecorationIds.map((areaId) => this.model.getDecorationRange(areaId)!).sort(Range.compareRangesUsingStarts);\n\t\tlet hiddenAreaStart = 1, hiddenAreaEnd = 0;\n\t\tlet hiddenAreaIdx = -1;\n\t\tlet nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\n\n\t\tfor (let i = 0; i < lineCount; i++) {\n\t\t\tconst lineNumber = i + 1;\n\n\t\t\tif (lineNumber === nextLineNumberToUpdateHiddenArea) {\n\t\t\t\thiddenAreaIdx++;\n\t\t\t\thiddenAreaStart = hiddenAreas[hiddenAreaIdx]!.startLineNumber;\n\t\t\t\thiddenAreaEnd = hiddenAreas[hiddenAreaIdx]!.endLineNumber;\n\t\t\t\tnextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\n\t\t\t}\n\n\t\t\tconst isInHiddenArea = (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd);\n\t\t\tconst line = createModelLineProjection(linesBreaks[i], !isInHiddenArea);\n\t\t\tvalues[i] = line.getViewLineCount();\n\t\t\tthis.modelLineProjections[i] = line;\n\t\t}\n\n\t\tthis._validModelVersionId = this.model.getVersionId();\n\n\t\tthis.projectedModelLineLineCounts = new ConstantTimePrefixSumComputer(values);\n\t}\n\n\tpublic getHiddenAreas(): Range[] {\n\t\treturn this.hiddenAreasDecorationIds.map(\n\t\t\t(decId) => this.model.getDecorationRange(decId)!\n\t\t);\n\t}\n\n\tpublic setHiddenAreas(_ranges: Range[]): boolean {\n\t\tconst validatedRanges = _ranges.map(r => this.model.validateRange(r));\n\t\tconst newRanges = normalizeLineRanges(validatedRanges);\n\n\t\t// TODO@Martin: Please stop calling this method on each model change!\n\n\t\t// This checks if there really was a change\n\t\tconst oldRanges = this.hiddenAreasDecorationIds.map((areaId) => this.model.getDecorationRange(areaId)!).sort(Range.compareRangesUsingStarts);\n\t\tif (newRanges.length === oldRanges.length) {\n\t\t\tlet hasDifference = false;\n\t\t\tfor (let i = 0; i < newRanges.length; i++) {\n\t\t\t\tif (!newRanges[i].equalsRange(oldRanges[i])) {\n\t\t\t\t\thasDifference = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!hasDifference) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tconst newDecorations = newRanges.map<IModelDeltaDecoration>(\n\t\t\t(r) =>\n\t\t\t({\n\t\t\t\trange: r,\n\t\t\t\toptions: ModelDecorationOptions.EMPTY,\n\t\t\t})\n\t\t);\n\n\t\tthis.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, newDecorations);\n\n\t\tconst hiddenAreas = newRanges;\n\t\tlet hiddenAreaStart = 1, hiddenAreaEnd = 0;\n\t\tlet hiddenAreaIdx = -1;\n\t\tlet nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.modelLineProjections.length + 2;\n\n\t\tlet hasVisibleLine = false;\n\t\tfor (let i = 0; i < this.modelLineProjections.length; i++) {\n\t\t\tconst lineNumber = i + 1;\n\n\t\t\tif (lineNumber === nextLineNumberToUpdateHiddenArea) {\n\t\t\t\thiddenAreaIdx++;\n\t\t\t\thiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n\t\t\t\thiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n\t\t\t\tnextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.modelLineProjections.length + 2;\n\t\t\t}\n\n\t\t\tlet lineChanged = false;\n\t\t\tif (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd) {\n\t\t\t\t// Line should be hidden\n\t\t\t\tif (this.modelLineProjections[i].isVisible()) {\n\t\t\t\t\tthis.modelLineProjections[i] = this.modelLineProjections[i].setVisible(false);\n\t\t\t\t\tlineChanged = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thasVisibleLine = true;\n\t\t\t\t// Line should be visible\n\t\t\t\tif (!this.modelLineProjections[i].isVisible()) {\n\t\t\t\t\tthis.modelLineProjections[i] = this.modelLineProjections[i].setVisible(true);\n\t\t\t\t\tlineChanged = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lineChanged) {\n\t\t\t\tconst newOutputLineCount = this.modelLineProjections[i].getViewLineCount();\n\t\t\t\tthis.projectedModelLineLineCounts.setValue(i, newOutputLineCount);\n\t\t\t}\n\t\t}\n\n\t\tif (!hasVisibleLine) {\n\t\t\t// Cannot have everything be hidden => reveal everything!\n\t\t\tthis.setHiddenAreas([]);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic modelPositionIsVisible(modelLineNumber: number, _modelColumn: number): boolean {\n\t\tif (modelLineNumber < 1 || modelLineNumber > this.modelLineProjections.length) {\n\t\t\t// invalid arguments\n\t\t\treturn false;\n\t\t}\n\t\treturn this.modelLineProjections[modelLineNumber - 1].isVisible();\n\t}\n\n\tpublic getModelLineViewLineCount(modelLineNumber: number): number {\n\t\tif (modelLineNumber < 1 || modelLineNumber > this.modelLineProjections.length) {\n\t\t\t// invalid arguments\n\t\t\treturn 1;\n\t\t}\n\t\treturn this.modelLineProjections[modelLineNumber - 1].getViewLineCount();\n\t}\n\n\tpublic setTabSize(newTabSize: number): boolean {\n\t\tif (this.tabSize === newTabSize) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.tabSize = newTabSize;\n\n\t\tthis._constructLines(/*resetHiddenAreas*/false, null);\n\n\t\treturn true;\n\t}\n\n\tpublic setWrappingSettings(fontInfo: FontInfo, wrappingStrategy: 'simple' | 'advanced', wrappingColumn: number, wrappingIndent: WrappingIndent, wordBreak: 'normal' | 'keepAll'): boolean {\n\t\tconst equalFontInfo = this.fontInfo.equals(fontInfo);\n\t\tconst equalWrappingStrategy = (this.wrappingStrategy === wrappingStrategy);\n\t\tconst equalWrappingColumn = (this.wrappingColumn === wrappingColumn);\n\t\tconst equalWrappingIndent = (this.wrappingIndent === wrappingIndent);\n\t\tconst equalWordBreak = (this.wordBreak === wordBreak);\n\t\tif (equalFontInfo && equalWrappingStrategy && equalWrappingColumn && equalWrappingIndent && equalWordBreak) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst onlyWrappingColumnChanged = (equalFontInfo && equalWrappingStrategy && !equalWrappingColumn && equalWrappingIndent && equalWordBreak);\n\n\t\tthis.fontInfo = fontInfo;\n\t\tthis.wrappingStrategy = wrappingStrategy;\n\t\tthis.wrappingColumn = wrappingColumn;\n\t\tthis.wrappingIndent = wrappingIndent;\n\t\tthis.wordBreak = wordBreak;\n\n\t\tlet previousLineBreaks: ((ModelLineProjectionData | null)[]) | null = null;\n\t\tif (onlyWrappingColumnChanged) {\n\t\t\tpreviousLineBreaks = [];\n\t\t\tfor (let i = 0, len = this.modelLineProjections.length; i < len; i++) {\n\t\t\t\tpreviousLineBreaks[i] = this.modelLineProjections[i].getProjectionData();\n\t\t\t}\n\t\t}\n\n\t\tthis._constructLines(/*resetHiddenAreas*/false, previousLineBreaks);\n\n\t\treturn true;\n\t}\n\n\tpublic createLineBreaksComputer(): ILineBreaksComputer {\n\t\tconst lineBreaksComputerFactory = (\n\t\t\tthis.wrappingStrategy === 'advanced'\n\t\t\t\t? this._domLineBreaksComputerFactory\n\t\t\t\t: this._monospaceLineBreaksComputerFactory\n\t\t);\n\t\treturn lineBreaksComputerFactory.createLineBreaksComputer(this.fontInfo, this.tabSize, this.wrappingColumn, this.wrappingIndent, this.wordBreak);\n\t}\n\n\tpublic onModelFlushed(): void {\n\t\tthis._constructLines(/*resetHiddenAreas*/true, null);\n\t}\n\n\tpublic onModelLinesDeleted(versionId: number | null, fromLineNumber: number, toLineNumber: number): viewEvents.ViewLinesDeletedEvent | null {\n\t\tif (!versionId || versionId <= this._validModelVersionId) {\n\t\t\t// Here we check for versionId in case the lines were reconstructed in the meantime.\n\t\t\t// We don't want to apply stale change events on top of a newer read model state.\n\t\t\treturn null;\n\t\t}\n\n\t\tconst outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(fromLineNumber - 1) + 1);\n\t\tconst outputToLineNumber = this.projectedModelLineLineCounts.getPrefixSum(toLineNumber);\n\n\t\tthis.modelLineProjections.splice(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n\t\tthis.projectedModelLineLineCounts.removeValues(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n\n\t\treturn new viewEvents.ViewLinesDeletedEvent(outputFromLineNumber, outputToLineNumber);\n\t}\n\n\tpublic onModelLinesInserted(versionId: number | null, fromLineNumber: number, _toLineNumber: number, lineBreaks: (ModelLineProjectionData | null)[]): viewEvents.ViewLinesInsertedEvent | null {\n\t\tif (!versionId || versionId <= this._validModelVersionId) {\n\t\t\t// Here we check for versionId in case the lines were reconstructed in the meantime.\n\t\t\t// We don't want to apply stale change events on top of a newer read model state.\n\t\t\treturn null;\n\t\t}\n\n\t\t// cannot use this.getHiddenAreas() because those decorations have already seen the effect of this model change\n\t\tconst isInHiddenArea = (fromLineNumber > 2 && !this.modelLineProjections[fromLineNumber - 2].isVisible());\n\n\t\tconst outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(fromLineNumber - 1) + 1);\n\n\t\tlet totalOutputLineCount = 0;\n\t\tconst insertLines: IModelLineProjection[] = [];\n\t\tconst insertPrefixSumValues: number[] = [];\n\n\t\tfor (let i = 0, len = lineBreaks.length; i < len; i++) {\n\t\t\tconst line = createModelLineProjection(lineBreaks[i], !isInHiddenArea);\n\t\t\tinsertLines.push(line);\n\n\t\t\tconst outputLineCount = line.getViewLineCount();\n\t\t\ttotalOutputLineCount += outputLineCount;\n\t\t\tinsertPrefixSumValues[i] = outputLineCount;\n\t\t}\n\n\t\t// TODO@Alex: use arrays.arrayInsert\n\t\tthis.modelLineProjections =\n\t\t\tthis.modelLineProjections.slice(0, fromLineNumber - 1)\n\t\t\t\t.concat(insertLines)\n\t\t\t\t.concat(this.modelLineProjections.slice(fromLineNumber - 1));\n\n\t\tthis.projectedModelLineLineCounts.insertValues(fromLineNumber - 1, insertPrefixSumValues);\n\n\t\treturn new viewEvents.ViewLinesInsertedEvent(outputFromLineNumber, outputFromLineNumber + totalOutputLineCount - 1);\n\t}\n\n\tpublic onModelLineChanged(versionId: number | null, lineNumber: number, lineBreakData: ModelLineProjectionData | null): [boolean, viewEvents.ViewLinesChangedEvent | null, viewEvents.ViewLinesInsertedEvent | null, viewEvents.ViewLinesDeletedEvent | null] {\n\t\tif (versionId !== null && versionId <= this._validModelVersionId) {\n\t\t\t// Here we check for versionId in case the lines were reconstructed in the meantime.\n\t\t\t// We don't want to apply stale change events on top of a newer read model state.\n\t\t\treturn [false, null, null, null];\n\t\t}\n\n\t\tconst lineIndex = lineNumber - 1;\n\n\t\tconst oldOutputLineCount = this.modelLineProjections[lineIndex].getViewLineCount();\n\t\tconst isVisible = this.modelLineProjections[lineIndex].isVisible();\n\t\tconst line = createModelLineProjection(lineBreakData, isVisible);\n\t\tthis.modelLineProjections[lineIndex] = line;\n\t\tconst newOutputLineCount = this.modelLineProjections[lineIndex].getViewLineCount();\n\n\t\tlet lineMappingChanged = false;\n\t\tlet changeFrom = 0;\n\t\tlet changeTo = -1;\n\t\tlet insertFrom = 0;\n\t\tlet insertTo = -1;\n\t\tlet deleteFrom = 0;\n\t\tlet deleteTo = -1;\n\n\t\tif (oldOutputLineCount > newOutputLineCount) {\n\t\t\tchangeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n\t\t\tchangeTo = changeFrom + newOutputLineCount - 1;\n\t\t\tdeleteFrom = changeTo + 1;\n\t\t\tdeleteTo = deleteFrom + (oldOutputLineCount - newOutputLineCount) - 1;\n\t\t\tlineMappingChanged = true;\n\t\t} else if (oldOutputLineCount < newOutputLineCount) {\n\t\t\tchangeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n\t\t\tchangeTo = changeFrom + oldOutputLineCount - 1;\n\t\t\tinsertFrom = changeTo + 1;\n\t\t\tinsertTo = insertFrom + (newOutputLineCount - oldOutputLineCount) - 1;\n\t\t\tlineMappingChanged = true;\n\t\t} else {\n\t\t\tchangeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n\t\t\tchangeTo = changeFrom + newOutputLineCount - 1;\n\t\t}\n\n\t\tthis.projectedModelLineLineCounts.setValue(lineIndex, newOutputLineCount);\n\n\t\tconst viewLinesChangedEvent = (changeFrom <= changeTo ? new viewEvents.ViewLinesChangedEvent(changeFrom, changeTo - changeFrom + 1) : null);\n\t\tconst viewLinesInsertedEvent = (insertFrom <= insertTo ? new viewEvents.ViewLinesInsertedEvent(insertFrom, insertTo) : null);\n\t\tconst viewLinesDeletedEvent = (deleteFrom <= deleteTo ? new viewEvents.ViewLinesDeletedEvent(deleteFrom, deleteTo) : null);\n\n\t\treturn [lineMappingChanged, viewLinesChangedEvent, viewLinesInsertedEvent, viewLinesDeletedEvent];\n\t}\n\n\tpublic acceptVersionId(versionId: number): void {\n\t\tthis._validModelVersionId = versionId;\n\t\tif (this.modelLineProjections.length === 1 && !this.modelLineProjections[0].isVisible()) {\n\t\t\t// At least one line must be visible => reset hidden areas\n\t\t\tthis.setHiddenAreas([]);\n\t\t}\n\t}\n\n\tpublic getViewLineCount(): number {\n\t\treturn this.projectedModelLineLineCounts.getTotalSum();\n\t}\n\n\tprivate _toValidViewLineNumber(viewLineNumber: number): number {\n\t\tif (viewLineNumber < 1) {\n\t\t\treturn 1;\n\t\t}\n\t\tconst viewLineCount = this.getViewLineCount();\n\t\tif (viewLineNumber > viewLineCount) {\n\t\t\treturn viewLineCount;\n\t\t}\n\t\treturn viewLineNumber | 0;\n\t}\n\n\tpublic getActiveIndentGuide(viewLineNumber: number, minLineNumber: number, maxLineNumber: number): IActiveIndentGuideInfo {\n\t\tviewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n\t\tminLineNumber = this._toValidViewLineNumber(minLineNumber);\n\t\tmaxLineNumber = this._toValidViewLineNumber(maxLineNumber);\n\n\t\tconst modelPosition = this.convertViewPositionToModelPosition(viewLineNumber, this.getViewLineMinColumn(viewLineNumber));\n\t\tconst modelMinPosition = this.convertViewPositionToModelPosition(minLineNumber, this.getViewLineMinColumn(minLineNumber));\n\t\tconst modelMaxPosition = this.convertViewPositionToModelPosition(maxLineNumber, this.getViewLineMinColumn(maxLineNumber));\n\t\tconst result = this.model.guides.getActiveIndentGuide(modelPosition.lineNumber, modelMinPosition.lineNumber, modelMaxPosition.lineNumber);\n\n\t\tconst viewStartPosition = this.convertModelPositionToViewPosition(result.startLineNumber, 1);\n\t\tconst viewEndPosition = this.convertModelPositionToViewPosition(result.endLineNumber, this.model.getLineMaxColumn(result.endLineNumber));\n\t\treturn {\n\t\t\tstartLineNumber: viewStartPosition.lineNumber,\n\t\t\tendLineNumber: viewEndPosition.lineNumber,\n\t\t\tindent: result.indent\n\t\t};\n\t}\n\n\t// #region ViewLineInfo\n\n\tprivate getViewLineInfo(viewLineNumber: number): ViewLineInfo {\n\t\tviewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n\t\tconst r = this.projectedModelLineLineCounts.getIndexOf(viewLineNumber - 1);\n\t\tconst lineIndex = r.index;\n\t\tconst remainder = r.remainder;\n\t\treturn new ViewLineInfo(lineIndex + 1, remainder);\n\t}\n\n\tprivate getMinColumnOfViewLine(viewLineInfo: ViewLineInfo): number {\n\t\treturn this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewLineMinColumn(\n\t\t\tthis.model,\n\t\t\tviewLineInfo.modelLineNumber,\n\t\t\tviewLineInfo.modelLineWrappedLineIdx\n\t\t);\n\t}\n\n\tprivate getMaxColumnOfViewLine(viewLineInfo: ViewLineInfo): number {\n\t\treturn this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewLineMaxColumn(\n\t\t\tthis.model,\n\t\t\tviewLineInfo.modelLineNumber,\n\t\t\tviewLineInfo.modelLineWrappedLineIdx\n\t\t);\n\t}\n\n\tprivate getModelStartPositionOfViewLine(viewLineInfo: ViewLineInfo): Position {\n\t\tconst line = this.modelLineProjections[viewLineInfo.modelLineNumber - 1];\n\t\tconst minViewColumn = line.getViewLineMinColumn(\n\t\t\tthis.model,\n\t\t\tviewLineInfo.modelLineNumber,\n\t\t\tviewLineInfo.modelLineWrappedLineIdx\n\t\t);\n\t\tconst column = line.getModelColumnOfViewPosition(\n\t\t\tviewLineInfo.modelLineWrappedLineIdx,\n\t\t\tminViewColumn\n\t\t);\n\t\treturn new Position(viewLineInfo.modelLineNumber, column);\n\t}\n\n\tprivate getModelEndPositionOfViewLine(viewLineInfo: ViewLineInfo): Position {\n\t\tconst line = this.modelLineProjections[viewLineInfo.modelLineNumber - 1];\n\t\tconst maxViewColumn = line.getViewLineMaxColumn(\n\t\t\tthis.model,\n\t\t\tviewLineInfo.modelLineNumber,\n\t\t\tviewLineInfo.modelLineWrappedLineIdx\n\t\t);\n\t\tconst column = line.getModelColumnOfViewPosition(\n\t\t\tviewLineInfo.modelLineWrappedLineIdx,\n\t\t\tmaxViewColumn\n\t\t);\n\t\treturn new Position(viewLineInfo.modelLineNumber, column);\n\t}\n\n\tprivate getViewLineInfosGroupedByModelRanges(viewStartLineNumber: number, viewEndLineNumber: number): ViewLineInfoGroupedByModelRange[] {\n\t\tconst startViewLine = this.getViewLineInfo(viewStartLineNumber);\n\t\tconst endViewLine = this.getViewLineInfo(viewEndLineNumber);\n\n\t\tconst result = new Array<ViewLineInfoGroupedByModelRange>();\n\t\tlet lastVisibleModelPos: Position | null = this.getModelStartPositionOfViewLine(startViewLine);\n\t\tlet viewLines = new Array<ViewLineInfo>();\n\n\t\tfor (let curModelLine = startViewLine.modelLineNumber; curModelLine <= endViewLine.modelLineNumber; curModelLine++) {\n\t\t\tconst line = this.modelLineProjections[curModelLine - 1];\n\n\t\t\tif (line.isVisible()) {\n\t\t\t\tconst startOffset =\n\t\t\t\t\tcurModelLine === startViewLine.modelLineNumber\n\t\t\t\t\t\t? startViewLine.modelLineWrappedLineIdx\n\t\t\t\t\t\t: 0;\n\n\t\t\t\tconst endOffset =\n\t\t\t\t\tcurModelLine === endViewLine.modelLineNumber\n\t\t\t\t\t\t? endViewLine.modelLineWrappedLineIdx + 1\n\t\t\t\t\t\t: line.getViewLineCount();\n\n\t\t\t\tfor (let i = startOffset; i < endOffset; i++) {\n\t\t\t\t\tviewLines.push(new ViewLineInfo(curModelLine, i));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!line.isVisible() && lastVisibleModelPos) {\n\t\t\t\tconst lastVisibleModelPos2 = new Position(curModelLine - 1, this.model.getLineMaxColumn(curModelLine - 1) + 1);\n\n\t\t\t\tconst modelRange = Range.fromPositions(lastVisibleModelPos, lastVisibleModelPos2);\n\t\t\t\tresult.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n\t\t\t\tviewLines = [];\n\n\t\t\t\tlastVisibleModelPos = null;\n\t\t\t} else if (line.isVisible() && !lastVisibleModelPos) {\n\t\t\t\tlastVisibleModelPos = new Position(curModelLine, 1);\n\t\t\t}\n\t\t}\n\n\t\tif (lastVisibleModelPos) {\n\t\t\tconst modelRange = Range.fromPositions(lastVisibleModelPos, this.getModelEndPositionOfViewLine(endViewLine));\n\t\t\tresult.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// #endregion\n\n\tpublic getViewLinesBracketGuides(viewStartLineNumber: number, viewEndLineNumber: number, activeViewPosition: IPosition | null, options: BracketGuideOptions): IndentGuide[][] {\n\t\tconst modelActivePosition = activeViewPosition ? this.convertViewPositionToModelPosition(activeViewPosition.lineNumber, activeViewPosition.column) : null;\n\t\tconst resultPerViewLine: IndentGuide[][] = [];\n\n\t\tfor (const group of this.getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber)) {\n\t\t\tconst modelRangeStartLineNumber = group.modelRange.startLineNumber;\n\n\t\t\tconst bracketGuidesPerModelLine = this.model.guides.getLinesBracketGuides(\n\t\t\t\tmodelRangeStartLineNumber,\n\t\t\t\tgroup.modelRange.endLineNumber,\n\t\t\t\tmodelActivePosition,\n\t\t\t\toptions\n\t\t\t);\n\n\t\t\tfor (const viewLineInfo of group.viewLines) {\n\n\t\t\t\tconst bracketGuides = bracketGuidesPerModelLine[viewLineInfo.modelLineNumber - modelRangeStartLineNumber];\n\n\t\t\t\t// visibleColumns stay as they are (this is a bug and needs to be fixed, but it is not a regression)\n\t\t\t\t// model-columns must be converted to view-model columns.\n\t\t\t\tconst result = bracketGuides.map(g => {\n\t\t\t\t\tif (g.forWrappedLinesAfterColumn !== -1) {\n\t\t\t\t\t\tconst p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.forWrappedLinesAfterColumn);\n\t\t\t\t\t\tif (p.lineNumber >= viewLineInfo.modelLineWrappedLineIdx) {\n\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (g.forWrappedLinesBeforeOrAtColumn !== -1) {\n\t\t\t\t\t\tconst p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.forWrappedLinesBeforeOrAtColumn);\n\t\t\t\t\t\tif (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!g.horizontalLine) {\n\t\t\t\t\t\treturn g;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet column = -1;\n\t\t\t\t\tif (g.column !== -1) {\n\t\t\t\t\t\tconst p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.column);\n\t\t\t\t\t\tif (p.lineNumber === viewLineInfo.modelLineWrappedLineIdx) {\n\t\t\t\t\t\t\tcolumn = p.column;\n\t\t\t\t\t\t} else if (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n\t\t\t\t\t\t\tcolumn = this.getMinColumnOfViewLine(viewLineInfo);\n\t\t\t\t\t\t} else if (p.lineNumber > viewLineInfo.modelLineWrappedLineIdx) {\n\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst viewPosition = this.convertModelPositionToViewPosition(viewLineInfo.modelLineNumber, g.horizontalLine.endColumn);\n\t\t\t\t\tconst p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.horizontalLine.endColumn);\n\t\t\t\t\tif (p.lineNumber === viewLineInfo.modelLineWrappedLineIdx) {\n\t\t\t\t\t\treturn new IndentGuide(g.visibleColumn, column, g.className,\n\t\t\t\t\t\t\tnew IndentGuideHorizontalLine(g.horizontalLine.top,\n\t\t\t\t\t\t\t\tviewPosition.column),\n\t\t\t\t\t\t\t- 1,\n\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (g.visibleColumn !== -1) {\n\t\t\t\t\t\t\t// Don't repeat horizontal lines that use visibleColumn for unrelated lines.\n\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn new IndentGuide(g.visibleColumn, column, g.className,\n\t\t\t\t\t\t\tnew IndentGuideHorizontalLine(g.horizontalLine.top,\n\t\t\t\t\t\t\t\tthis.getMaxColumnOfViewLine(viewLineInfo)\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tresultPerViewLine.push(result.filter((r): r is IndentGuide => !!r));\n\n\t\t\t}\n\t\t}\n\n\t\treturn resultPerViewLine;\n\t}\n\n\tpublic getViewLinesIndentGuides(viewStartLineNumber: number, viewEndLineNumber: number): number[] {\n\t\t// TODO: Use the same code as in `getViewLinesBracketGuides`.\n\t\t// Future TODO: Merge with `getViewLinesBracketGuides`.\n\t\t// However, this requires more refactoring of indent guides.\n\t\tviewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n\t\tviewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n\n\t\tconst modelStart = this.convertViewPositionToModelPosition(viewStartLineNumber, this.getViewLineMinColumn(viewStartLineNumber));\n\t\tconst modelEnd = this.convertViewPositionToModelPosition(viewEndLineNumber, this.getViewLineMaxColumn(viewEndLineNumber));\n\n\t\tlet result: number[] = [];\n\t\tconst resultRepeatCount: number[] = [];\n\t\tconst resultRepeatOption: IndentGuideRepeatOption[] = [];\n\t\tconst modelStartLineIndex = modelStart.lineNumber - 1;\n\t\tconst modelEndLineIndex = modelEnd.lineNumber - 1;\n\n\t\tlet reqStart: Position | null = null;\n\t\tfor (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n\t\t\tconst line = this.modelLineProjections[modelLineIndex];\n\t\t\tif (line.isVisible()) {\n\t\t\t\tconst viewLineStartIndex = line.getViewLineNumberOfModelPosition(0, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n\t\t\t\tconst viewLineEndIndex = line.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(modelLineIndex + 1));\n\t\t\t\tconst count = viewLineEndIndex - viewLineStartIndex + 1;\n\t\t\t\tlet option = IndentGuideRepeatOption.BlockNone;\n\t\t\t\tif (count > 1 && line.getViewLineMinColumn(this.model, modelLineIndex + 1, viewLineEndIndex) === 1) {\n\t\t\t\t\t// wrapped lines should block indent guides\n\t\t\t\t\toption = (viewLineStartIndex === 0 ? IndentGuideRepeatOption.BlockSubsequent : IndentGuideRepeatOption.BlockAll);\n\t\t\t\t}\n\t\t\t\tresultRepeatCount.push(count);\n\t\t\t\tresultRepeatOption.push(option);\n\t\t\t\t// merge into previous request\n\t\t\t\tif (reqStart === null) {\n\t\t\t\t\treqStart = new Position(modelLineIndex + 1, 0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// hit invisible line => flush request\n\t\t\t\tif (reqStart !== null) {\n\t\t\t\t\tresult = result.concat(this.model.guides.getLinesIndentGuides(reqStart.lineNumber, modelLineIndex));\n\t\t\t\t\treqStart = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (reqStart !== null) {\n\t\t\tresult = result.concat(this.model.guides.getLinesIndentGuides(reqStart.lineNumber, modelEnd.lineNumber));\n\t\t\treqStart = null;\n\t\t}\n\n\t\tconst viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n\t\tconst viewIndents = new Array<number>(viewLineCount);\n\t\tlet currIndex = 0;\n\t\tfor (let i = 0, len = result.length; i < len; i++) {\n\t\t\tlet value = result[i];\n\t\t\tconst count = Math.min(viewLineCount - currIndex, resultRepeatCount[i]);\n\t\t\tconst option = resultRepeatOption[i];\n\t\t\tlet blockAtIndex: number;\n\t\t\tif (option === IndentGuideRepeatOption.BlockAll) {\n\t\t\t\tblockAtIndex = 0;\n\t\t\t} else if (option === IndentGuideRepeatOption.BlockSubsequent) {\n\t\t\t\tblockAtIndex = 1;\n\t\t\t} else {\n\t\t\t\tblockAtIndex = count;\n\t\t\t}\n\t\t\tfor (let j = 0; j < count; j++) {\n\t\t\t\tif (j === blockAtIndex) {\n\t\t\t\t\tvalue = 0;\n\t\t\t\t}\n\t\t\t\tviewIndents[currIndex++] = value;\n\t\t\t}\n\t\t}\n\t\treturn viewIndents;\n\t}\n\n\tpublic getViewLineContent(viewLineNumber: number): string {\n\t\tconst info = this.getViewLineInfo(viewLineNumber);\n\t\treturn this.modelLineProjections[info.modelLineNumber - 1].getViewLineContent(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n\t}\n\n\tpublic getViewLineLength(viewLineNumber: number): number {\n\t\tconst info = this.getViewLineInfo(viewLineNumber);\n\t\treturn this.modelLineProjections[info.modelLineNumber - 1].getViewLineLength(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n\t}\n\n\tpublic getViewLineMinColumn(viewLineNumber: number): number {\n\t\tconst info = this.getViewLineInfo(viewLineNumber);\n\t\treturn this.modelLineProjections[info.modelLineNumber - 1].getViewLineMinColumn(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n\t}\n\n\tpublic getViewLineMaxColumn(viewLineNumber: number): number {\n\t\tconst info = this.getViewLineInfo(viewLineNumber);\n\t\treturn this.modelLineProjections[info.modelLineNumber - 1].getViewLineMaxColumn(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n\t}\n\n\tpublic getViewLineData(viewLineNumber: number): ViewLineData {\n\t\tconst info = this.getViewLineInfo(viewLineNumber);\n\t\treturn this.modelLineProjections[info.modelLineNumber - 1].getViewLineData(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n\t}\n\n\tpublic getViewLinesData(viewStartLineNumber: number, viewEndLineNumber: number, needed: boolean[]): ViewLineData[] {\n\n\t\tviewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n\t\tviewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n\n\t\tconst start = this.projectedModelLineLineCounts.getIndexOf(viewStartLineNumber - 1);\n\t\tlet viewLineNumber = viewStartLineNumber;\n\t\tconst startModelLineIndex = start.index;\n\t\tconst startRemainder = start.remainder;\n\n\t\tconst result: ViewLineData[] = [];\n\t\tfor (let modelLineIndex = startModelLineIndex, len = this.model.getLineCount(); modelLineIndex < len; modelLineIndex++) {\n\t\t\tconst line = this.modelLineProjections[modelLineIndex];\n\t\t\tif (!line.isVisible()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst fromViewLineIndex = (modelLineIndex === startModelLineIndex ? startRemainder : 0);\n\t\t\tlet remainingViewLineCount = line.getViewLineCount() - fromViewLineIndex;\n\n\t\t\tlet lastLine = false;\n\t\t\tif (viewLineNumber + remainingViewLineCount > viewEndLineNumber) {\n\t\t\t\tlastLine = true;\n\t\t\t\tremainingViewLineCount = viewEndLineNumber - viewLineNumber + 1;\n\t\t\t}\n\n\t\t\tline.getViewLinesData(this.model, modelLineIndex + 1, fromViewLineIndex, remainingViewLineCount, viewLineNumber - viewStartLineNumber, needed, result);\n\n\t\t\tviewLineNumber += remainingViewLineCount;\n\n\t\t\tif (lastLine) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic validateViewPosition(viewLineNumber: number, viewColumn: number, expectedModelPosition: Position): Position {\n\t\tviewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n\n\t\tconst r = this.projectedModelLineLineCounts.getIndexOf(viewLineNumber - 1);\n\t\tconst lineIndex = r.index;\n\t\tconst remainder = r.remainder;\n\n\t\tconst line = this.modelLineProjections[lineIndex];\n\n\t\tconst minColumn = line.getViewLineMinColumn(this.model, lineIndex + 1, remainder);\n\t\tconst maxColumn = line.getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\n\t\tif (viewColumn < minColumn) {\n\t\t\tviewColumn = minColumn;\n\t\t}\n\t\tif (viewColumn > maxColumn) {\n\t\t\tviewColumn = maxColumn;\n\t\t}\n\n\t\tconst computedModelColumn = line.getModelColumnOfViewPosition(remainder, viewColumn);\n\t\tconst computedModelPosition = this.model.validatePosition(new Position(lineIndex + 1, computedModelColumn));\n\n\t\tif (computedModelPosition.equals(expectedModelPosition)) {\n\t\t\treturn new Position(viewLineNumber, viewColumn);\n\t\t}\n\n\t\treturn this.convertModelPositionToViewPosition(expectedModelPosition.lineNumber, expectedModelPosition.column);\n\t}\n\n\tpublic validateViewRange(viewRange: Range, expectedModelRange: Range): Range {\n\t\tconst validViewStart = this.validateViewPosition(viewRange.startLineNumber, viewRange.startColumn, expectedModelRange.getStartPosition());\n\t\tconst validViewEnd = this.validateViewPosition(viewRange.endLineNumber, viewRange.endColumn, expectedModelRange.getEndPosition());\n\t\treturn new Range(validViewStart.lineNumber, validViewStart.column, validViewEnd.lineNumber, validViewEnd.column);\n\t}\n\n\tpublic convertViewPositionToModelPosition(viewLineNumber: number, viewColumn: number): Position {\n\t\tconst info = this.getViewLineInfo(viewLineNumber);\n\n\t\tconst inputColumn = this.modelLineProjections[info.modelLineNumber - 1].getModelColumnOfViewPosition(info.modelLineWrappedLineIdx, viewColumn);\n\t\t// console.log('out -> in ' + viewLineNumber + ',' + viewColumn + ' ===> ' + (lineIndex+1) + ',' + inputColumn);\n\t\treturn this.model.validatePosition(new Position(info.modelLineNumber, inputColumn));\n\t}\n\n\tpublic convertViewRangeToModelRange(viewRange: Range): Range {\n\t\tconst start = this.convertViewPositionToModelPosition(viewRange.startLineNumber, viewRange.startColumn);\n\t\tconst end = this.convertViewPositionToModelPosition(viewRange.endLineNumber, viewRange.endColumn);\n\t\treturn new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n\t}\n\n\tpublic convertModelPositionToViewPosition(_modelLineNumber: number, _modelColumn: number, affinity: PositionAffinity = PositionAffinity.None, allowZeroLineNumber: boolean = false, belowHiddenRanges: boolean = false): Position {\n\n\t\tconst validPosition = this.model.validatePosition(new Position(_modelLineNumber, _modelColumn));\n\t\tconst inputLineNumber = validPosition.lineNumber;\n\t\tconst inputColumn = validPosition.column;\n\n\t\tlet lineIndex = inputLineNumber - 1, lineIndexChanged = false;\n\t\tif (belowHiddenRanges) {\n\t\t\twhile (lineIndex < this.modelLineProjections.length && !this.modelLineProjections[lineIndex].isVisible()) {\n\t\t\t\tlineIndex++;\n\t\t\t\tlineIndexChanged = true;\n\t\t\t}\n\t\t} else {\n\t\t\twhile (lineIndex > 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n\t\t\t\tlineIndex--;\n\t\t\t\tlineIndexChanged = true;\n\t\t\t}\n\t\t}\n\t\tif (lineIndex === 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n\t\t\t// Could not reach a real line\n\t\t\t// console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + 1 + ',' + 1);\n\t\t\t// TODO@alexdima@hediet this isn't soo pretty\n\t\t\treturn new Position(allowZeroLineNumber ? 0 : 1, 1);\n\t\t}\n\t\tconst deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n\n\t\tlet r: Position;\n\t\tif (lineIndexChanged) {\n\t\t\tif (belowHiddenRanges) {\n\t\t\t\tr = this.modelLineProjections[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, 1, affinity);\n\t\t\t} else {\n\t\t\t\tr = this.modelLineProjections[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1), affinity);\n\t\t\t}\n\t\t} else {\n\t\t\tr = this.modelLineProjections[inputLineNumber - 1].getViewPositionOfModelPosition(deltaLineNumber, inputColumn, affinity);\n\t\t}\n\n\t\t// console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + r.lineNumber + ',' + r);\n\t\treturn r;\n\t}\n\n\t/**\n\t * @param affinity The affinity in case of an empty range. Has no effect for non-empty ranges.\n\t*/\n\tpublic convertModelRangeToViewRange(modelRange: Range, affinity: PositionAffinity = PositionAffinity.Left): Range {\n\t\tif (modelRange.isEmpty()) {\n\t\t\tconst start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, affinity);\n\t\t\treturn Range.fromPositions(start);\n\t\t} else {\n\t\t\tconst start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, PositionAffinity.Right);\n\t\t\tconst end = this.convertModelPositionToViewPosition(modelRange.endLineNumber, modelRange.endColumn, PositionAffinity.Left);\n\t\t\treturn new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n\t\t}\n\t}\n\n\tpublic getViewLineNumberOfModelPosition(modelLineNumber: number, modelColumn: number): number {\n\t\tlet lineIndex = modelLineNumber - 1;\n\t\tif (this.modelLineProjections[lineIndex].isVisible()) {\n\t\t\t// this model line is visible\n\t\t\tconst deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n\t\t\treturn this.modelLineProjections[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, modelColumn);\n\t\t}\n\n\t\t// this model line is not visible\n\t\twhile (lineIndex > 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n\t\t\tlineIndex--;\n\t\t}\n\t\tif (lineIndex === 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n\t\t\t// Could not reach a real line\n\t\t\treturn 1;\n\t\t}\n\t\tconst deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n\t\treturn this.modelLineProjections[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));\n\t}\n\n\tpublic getDecorationsInRange(range: Range, ownerId: number, filterOutValidation: boolean, onlyMinimapDecorations: boolean, onlyMarginDecorations: boolean): IModelDecoration[] {\n\t\tconst modelStart = this.convertViewPositionToModelPosition(range.startLineNumber, range.startColumn);\n\t\tconst modelEnd = this.convertViewPositionToModelPosition(range.endLineNumber, range.endColumn);\n\n\t\tif (modelEnd.lineNumber - modelStart.lineNumber <= range.endLineNumber - range.startLineNumber) {\n\t\t\t// most likely there are no hidden lines => fast path\n\t\t\t// fetch decorations from column 1 to cover the case of wrapped lines that have whole line decorations at column 1\n\t\t\treturn this.model.getDecorationsInRange(new Range(modelStart.lineNumber, 1, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation, onlyMinimapDecorations, onlyMarginDecorations);\n\t\t}\n\n\t\tlet result: IModelDecoration[] = [];\n\t\tconst modelStartLineIndex = modelStart.lineNumber - 1;\n\t\tconst modelEndLineIndex = modelEnd.lineNumber - 1;\n\n\t\tlet reqStart: Position | null = null;\n\t\tfor (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n\t\t\tconst line = this.modelLineProjections[modelLineIndex];\n\t\t\tif (line.isVisible()) {\n\t\t\t\t// merge into previous request\n\t\t\t\tif (reqStart === null) {\n\t\t\t\t\treqStart = new Position(modelLineIndex + 1, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// hit invisible line => flush request\n\t\t\t\tif (reqStart !== null) {\n\t\t\t\t\tconst maxLineColumn = this.model.getLineMaxColumn(modelLineIndex);\n\t\t\t\t\tresult = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelLineIndex, maxLineColumn), ownerId, filterOutValidation, onlyMinimapDecorations));\n\t\t\t\t\treqStart = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (reqStart !== null) {\n\t\t\tresult = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation, onlyMinimapDecorations));\n\t\t\treqStart = null;\n\t\t}\n\n\t\tresult.sort((a, b) => {\n\t\t\tconst res = Range.compareRangesUsingStarts(a.range, b.range);\n\t\t\tif (res === 0) {\n\t\t\t\tif (a.id < b.id) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (a.id > b.id) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn res;\n\t\t});\n\n\t\t// Eliminate duplicate decorations that might have intersected our visible ranges multiple times\n\t\tconst finalResult: IModelDecoration[] = [];\n\t\tlet finalResultLen = 0;\n\t\tlet prevDecId: string | null = null;\n\t\tfor (const dec of result) {\n\t\t\tconst decId = dec.id;\n\t\t\tif (prevDecId === decId) {\n\t\t\t\t// skip\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprevDecId = decId;\n\t\t\tfinalResult[finalResultLen++] = dec;\n\t\t}\n\n\t\treturn finalResult;\n\t}\n\n\tpublic getInjectedTextAt(position: Position): InjectedText | null {\n\t\tconst info = this.getViewLineInfo(position.lineNumber);\n\t\treturn this.modelLineProjections[info.modelLineNumber - 1].getInjectedTextAt(info.modelLineWrappedLineIdx, position.column);\n\t}\n\n\tnormalizePosition(position: Position, affinity: PositionAffinity): Position {\n\t\tconst info = this.getViewLineInfo(position.lineNumber);\n\t\treturn this.modelLineProjections[info.modelLineNumber - 1].normalizePosition(info.modelLineWrappedLineIdx, position, affinity);\n\t}\n\n\tpublic getLineIndentColumn(lineNumber: number): number {\n\t\tconst info = this.getViewLineInfo(lineNumber);\n\t\tif (info.modelLineWrappedLineIdx === 0) {\n\t\t\treturn this.model.getLineIndentColumn(info.modelLineNumber);\n\t\t}\n\n\t\t// wrapped lines have no indentation.\n\t\t// We deliberately don't handle the case that indentation is wrapped\n\t\t// to avoid two view lines reporting indentation for the very same model line.\n\t\treturn 0;\n\t}\n}\n\n/**\n * Overlapping unsorted ranges:\n * [   )      [ )       [  )\n *    [    )      [       )\n * ->\n * Non overlapping sorted ranges:\n * [       )  [ ) [        )\n *\n * Note: This function only considers line information! Columns are ignored.\n*/\nfunction normalizeLineRanges(ranges: Range[]): Range[] {\n\tif (ranges.length === 0) {\n\t\treturn [];\n\t}\n\n\tconst sortedRanges = ranges.slice();\n\tsortedRanges.sort(Range.compareRangesUsingStarts);\n\n\tconst result: Range[] = [];\n\tlet currentRangeStart = sortedRanges[0].startLineNumber;\n\tlet currentRangeEnd = sortedRanges[0].endLineNumber;\n\n\tfor (let i = 1, len = sortedRanges.length; i < len; i++) {\n\t\tconst range = sortedRanges[i];\n\n\t\tif (range.startLineNumber > currentRangeEnd + 1) {\n\t\t\tresult.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n\t\t\tcurrentRangeStart = range.startLineNumber;\n\t\t\tcurrentRangeEnd = range.endLineNumber;\n\t\t} else if (range.endLineNumber > currentRangeEnd) {\n\t\t\tcurrentRangeEnd = range.endLineNumber;\n\t\t}\n\t}\n\tresult.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n\treturn result;\n}\n\n/**\n * Represents a view line. Can be used to efficiently query more information about it.\n */\nclass ViewLineInfo {\n\tpublic get isWrappedLineContinuation(): boolean {\n\t\treturn this.modelLineWrappedLineIdx > 0;\n\t}\n\n\tconstructor(\n\t\tpublic readonly modelLineNumber: number,\n\t\tpublic readonly modelLineWrappedLineIdx: number,\n\t) { }\n}\n\n/**\n * A list of view lines that have a contiguous span in the model.\n*/\nclass ViewLineInfoGroupedByModelRange {\n\tconstructor(public readonly modelRange: Range, public readonly viewLines: ViewLineInfo[]) {\n\t}\n}\n\nclass CoordinatesConverter implements ICoordinatesConverter {\n\tprivate readonly _lines: ViewModelLinesFromProjectedModel;\n\n\tconstructor(lines: ViewModelLinesFromProjectedModel) {\n\t\tthis._lines = lines;\n\t}\n\n\t// View -> Model conversion and related methods\n\n\tpublic convertViewPositionToModelPosition(viewPosition: Position): Position {\n\t\treturn this._lines.convertViewPositionToModelPosition(viewPosition.lineNumber, viewPosition.column);\n\t}\n\n\tpublic convertViewRangeToModelRange(viewRange: Range): Range {\n\t\treturn this._lines.convertViewRangeToModelRange(viewRange);\n\t}\n\n\tpublic validateViewPosition(viewPosition: Position, expectedModelPosition: Position): Position {\n\t\treturn this._lines.validateViewPosition(viewPosition.lineNumber, viewPosition.column, expectedModelPosition);\n\t}\n\n\tpublic validateViewRange(viewRange: Range, expectedModelRange: Range): Range {\n\t\treturn this._lines.validateViewRange(viewRange, expectedModelRange);\n\t}\n\n\t// Model -> View conversion and related methods\n\n\tpublic convertModelPositionToViewPosition(modelPosition: Position, affinity?: PositionAffinity, allowZero?: boolean, belowHiddenRanges?: boolean): Position {\n\t\treturn this._lines.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column, affinity, allowZero, belowHiddenRanges);\n\t}\n\n\tpublic convertModelRangeToViewRange(modelRange: Range, affinity?: PositionAffinity): Range {\n\t\treturn this._lines.convertModelRangeToViewRange(modelRange, affinity);\n\t}\n\n\tpublic modelPositionIsVisible(modelPosition: Position): boolean {\n\t\treturn this._lines.modelPositionIsVisible(modelPosition.lineNumber, modelPosition.column);\n\t}\n\n\tpublic getModelLineViewLineCount(modelLineNumber: number): number {\n\t\treturn this._lines.getModelLineViewLineCount(modelLineNumber);\n\t}\n\n\tpublic getViewLineNumberOfModelPosition(modelLineNumber: number, modelColumn: number): number {\n\t\treturn this._lines.getViewLineNumberOfModelPosition(modelLineNumber, modelColumn);\n\t}\n}\n\nconst enum IndentGuideRepeatOption {\n\tBlockNone = 0,\n\tBlockSubsequent = 1,\n\tBlockAll = 2\n}\n\nexport class ViewModelLinesFromModelAsIs implements IViewModelLines {\n\tpublic readonly model: ITextModel;\n\n\tconstructor(model: ITextModel) {\n\t\tthis.model = model;\n\t}\n\n\tpublic dispose(): void {\n\t}\n\n\tpublic createCoordinatesConverter(): ICoordinatesConverter {\n\t\treturn new IdentityCoordinatesConverter(this);\n\t}\n\n\tpublic getHiddenAreas(): Range[] {\n\t\treturn [];\n\t}\n\n\tpublic setHiddenAreas(_ranges: Range[]): boolean {\n\t\treturn false;\n\t}\n\n\tpublic setTabSize(_newTabSize: number): boolean {\n\t\treturn false;\n\t}\n\n\tpublic setWrappingSettings(_fontInfo: FontInfo, _wrappingStrategy: 'simple' | 'advanced', _wrappingColumn: number, _wrappingIndent: WrappingIndent): boolean {\n\t\treturn false;\n\t}\n\n\tpublic createLineBreaksComputer(): ILineBreaksComputer {\n\t\tconst result: null[] = [];\n\t\treturn {\n\t\t\taddRequest: (lineText: string, injectedText: LineInjectedText[] | null, previousLineBreakData: ModelLineProjectionData | null) => {\n\t\t\t\tresult.push(null);\n\t\t\t},\n\t\t\tfinalize: () => {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic onModelFlushed(): void {\n\t}\n\n\tpublic onModelLinesDeleted(_versionId: number | null, fromLineNumber: number, toLineNumber: number): viewEvents.ViewLinesDeletedEvent | null {\n\t\treturn new viewEvents.ViewLinesDeletedEvent(fromLineNumber, toLineNumber);\n\t}\n\n\tpublic onModelLinesInserted(_versionId: number | null, fromLineNumber: number, toLineNumber: number, lineBreaks: (ModelLineProjectionData | null)[]): viewEvents.ViewLinesInsertedEvent | null {\n\t\treturn new viewEvents.ViewLinesInsertedEvent(fromLineNumber, toLineNumber);\n\t}\n\n\tpublic onModelLineChanged(_versionId: number | null, lineNumber: number, lineBreakData: ModelLineProjectionData | null): [boolean, viewEvents.ViewLinesChangedEvent | null, viewEvents.ViewLinesInsertedEvent | null, viewEvents.ViewLinesDeletedEvent | null] {\n\t\treturn [false, new viewEvents.ViewLinesChangedEvent(lineNumber, 1), null, null];\n\t}\n\n\tpublic acceptVersionId(_versionId: number): void {\n\t}\n\n\tpublic getViewLineCount(): number {\n\t\treturn this.model.getLineCount();\n\t}\n\n\tpublic getActiveIndentGuide(viewLineNumber: number, _minLineNumber: number, _maxLineNumber: number): IActiveIndentGuideInfo {\n\t\treturn {\n\t\t\tstartLineNumber: viewLineNumber,\n\t\t\tendLineNumber: viewLineNumber,\n\t\t\tindent: 0\n\t\t};\n\t}\n\n\tpublic getViewLinesBracketGuides(startLineNumber: number, endLineNumber: number, activePosition: IPosition | null): IndentGuide[][] {\n\t\treturn new Array(endLineNumber - startLineNumber + 1).fill([]);\n\t}\n\n\tpublic getViewLinesIndentGuides(viewStartLineNumber: number, viewEndLineNumber: number): number[] {\n\t\tconst viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n\t\tconst result = new Array<number>(viewLineCount);\n\t\tfor (let i = 0; i < viewLineCount; i++) {\n\t\t\tresult[i] = 0;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic getViewLineContent(viewLineNumber: number): string {\n\t\treturn this.model.getLineContent(viewLineNumber);\n\t}\n\n\tpublic getViewLineLength(viewLineNumber: number): number {\n\t\treturn this.model.getLineLength(viewLineNumber);\n\t}\n\n\tpublic getViewLineMinColumn(viewLineNumber: number): number {\n\t\treturn this.model.getLineMinColumn(viewLineNumber);\n\t}\n\n\tpublic getViewLineMaxColumn(viewLineNumber: number): number {\n\t\treturn this.model.getLineMaxColumn(viewLineNumber);\n\t}\n\n\tpublic getViewLineData(viewLineNumber: number): ViewLineData {\n\t\tconst lineTokens = this.model.tokenization.getLineTokens(viewLineNumber);\n\t\tconst lineContent = lineTokens.getLineContent();\n\t\treturn new ViewLineData(\n\t\t\tlineContent,\n\t\t\tfalse,\n\t\t\t1,\n\t\t\tlineContent.length + 1,\n\t\t\t0,\n\t\t\tlineTokens.inflate(),\n\t\t\tnull\n\t\t);\n\t}\n\n\tpublic getViewLinesData(viewStartLineNumber: number, viewEndLineNumber: number, needed: boolean[]): Array<ViewLineData | null> {\n\t\tconst lineCount = this.model.getLineCount();\n\t\tviewStartLineNumber = Math.min(Math.max(1, viewStartLineNumber), lineCount);\n\t\tviewEndLineNumber = Math.min(Math.max(1, viewEndLineNumber), lineCount);\n\n\t\tconst result: Array<ViewLineData | null> = [];\n\t\tfor (let lineNumber = viewStartLineNumber; lineNumber <= viewEndLineNumber; lineNumber++) {\n\t\t\tconst idx = lineNumber - viewStartLineNumber;\n\t\t\tresult[idx] = needed[idx] ? this.getViewLineData(lineNumber) : null;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic getDecorationsInRange(range: Range, ownerId: number, filterOutValidation: boolean, onlyMinimapDecorations: boolean, onlyMarginDecorations: boolean): IModelDecoration[] {\n\t\treturn this.model.getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations, onlyMarginDecorations);\n\t}\n\n\tnormalizePosition(position: Position, affinity: PositionAffinity): Position {\n\t\treturn this.model.normalizePosition(position, affinity);\n\t}\n\n\tpublic getLineIndentColumn(lineNumber: number): number {\n\t\treturn this.model.getLineIndentColumn(lineNumber);\n\t}\n\n\tpublic getInjectedTextAt(position: Position): InjectedText | null {\n\t\t// Identity lines collection does not support injected text.\n\t\treturn null;\n\t}\n}\n\nclass IdentityCoordinatesConverter implements ICoordinatesConverter {\n\tprivate readonly _lines: ViewModelLinesFromModelAsIs;\n\n\tconstructor(lines: ViewModelLinesFromModelAsIs) {\n\t\tthis._lines = lines;\n\t}\n\n\tprivate _validPosition(pos: Position): Position {\n\t\treturn this._lines.model.validatePosition(pos);\n\t}\n\n\tprivate _validRange(range: Range): Range {\n\t\treturn this._lines.model.validateRange(range);\n\t}\n\n\t// View -> Model conversion and related methods\n\n\tpublic convertViewPositionToModelPosition(viewPosition: Position): Position {\n\t\treturn this._validPosition(viewPosition);\n\t}\n\n\tpublic convertViewRangeToModelRange(viewRange: Range): Range {\n\t\treturn this._validRange(viewRange);\n\t}\n\n\tpublic validateViewPosition(_viewPosition: Position, expectedModelPosition: Position): Position {\n\t\treturn this._validPosition(expectedModelPosition);\n\t}\n\n\tpublic validateViewRange(_viewRange: Range, expectedModelRange: Range): Range {\n\t\treturn this._validRange(expectedModelRange);\n\t}\n\n\t// Model -> View conversion and related methods\n\n\tpublic convertModelPositionToViewPosition(modelPosition: Position): Position {\n\t\treturn this._validPosition(modelPosition);\n\t}\n\n\tpublic convertModelRangeToViewRange(modelRange: Range): Range {\n\t\treturn this._validRange(modelRange);\n\t}\n\n\tpublic modelPositionIsVisible(modelPosition: Position): boolean {\n\t\tconst lineCount = this._lines.model.getLineCount();\n\t\tif (modelPosition.lineNumber < 1 || modelPosition.lineNumber > lineCount) {\n\t\t\t// invalid arguments\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic modelRangeIsVisible(modelRange: Range): boolean {\n\t\tconst lineCount = this._lines.model.getLineCount();\n\t\tif (modelRange.startLineNumber < 1 || modelRange.startLineNumber > lineCount) {\n\t\t\t// invalid arguments\n\t\t\treturn false;\n\t\t}\n\t\tif (modelRange.endLineNumber < 1 || modelRange.endLineNumber > lineCount) {\n\t\t\t// invalid arguments\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic getModelLineViewLineCount(modelLineNumber: number): number {\n\t\treturn 1;\n\t}\n\n\tpublic getViewLineNumberOfModelPosition(modelLineNumber: number, modelColumn: number): number {\n\t\treturn modelLineNumber;\n\t}\n}\n"],
  "mappings": "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",
  "names": ["p", "deltaLineNumber", "IndentGuideRepeatOption"]
}
