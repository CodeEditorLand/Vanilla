{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/viewModel/viewModelLines.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from \"../../../base/common/arrays.js\";\nimport type { IDisposable } from \"../../../base/common/lifecycle.js\";\nimport type { WrappingIndent } from \"../config/editorOptions.js\";\nimport type { FontInfo } from \"../config/fontInfo.js\";\nimport { type IPosition, Position } from \"../core/position.js\";\nimport { Range } from \"../core/range.js\";\nimport {\n\ttype IModelDecoration,\n\ttype IModelDeltaDecoration,\n\ttype ITextModel,\n\tPositionAffinity,\n} from \"../model.js\";\nimport { ConstantTimePrefixSumComputer } from \"../model/prefixSumComputer.js\";\nimport { ModelDecorationOptions } from \"../model/textModel.js\";\nimport type {\n\tILineBreaksComputer,\n\tILineBreaksComputerFactory,\n\tInjectedText,\n\tModelLineProjectionData,\n} from \"../modelLineProjectionData.js\";\nimport { LineInjectedText } from \"../textModelEvents.js\";\nimport {\n\ttype BracketGuideOptions,\n\ttype IActiveIndentGuideInfo,\n\tIndentGuide,\n\tIndentGuideHorizontalLine,\n} from \"../textModelGuides.js\";\nimport * as viewEvents from \"../viewEvents.js\";\nimport { type ICoordinatesConverter, ViewLineData } from \"../viewModel.js\";\nimport {\n\ttype IModelLineProjection,\n\tcreateModelLineProjection,\n} from \"./modelLineProjection.js\";\n\nexport interface IViewModelLines extends IDisposable {\n\tcreateCoordinatesConverter(): ICoordinatesConverter;\n\n\tsetWrappingSettings(\n\t\tfontInfo: FontInfo,\n\t\twrappingStrategy: \"simple\" | \"advanced\",\n\t\twrappingColumn: number,\n\t\twrappingIndent: WrappingIndent,\n\t\twordBreak: \"normal\" | \"keepAll\",\n\t): boolean;\n\tsetTabSize(newTabSize: number): boolean;\n\tgetHiddenAreas(): Range[];\n\tsetHiddenAreas(_ranges: readonly Range[]): boolean;\n\n\tcreateLineBreaksComputer(): ILineBreaksComputer;\n\tonModelFlushed(): void;\n\tonModelLinesDeleted(\n\t\tversionId: number | null,\n\t\tfromLineNumber: number,\n\t\ttoLineNumber: number,\n\t): viewEvents.ViewLinesDeletedEvent | null;\n\tonModelLinesInserted(\n\t\tversionId: number | null,\n\t\tfromLineNumber: number,\n\t\ttoLineNumber: number,\n\t\tlineBreaks: (ModelLineProjectionData | null)[],\n\t): viewEvents.ViewLinesInsertedEvent | null;\n\tonModelLineChanged(\n\t\tversionId: number | null,\n\t\tlineNumber: number,\n\t\tlineBreakData: ModelLineProjectionData | null,\n\t): [\n\t\tboolean,\n\t\tviewEvents.ViewLinesChangedEvent | null,\n\t\tviewEvents.ViewLinesInsertedEvent | null,\n\t\tviewEvents.ViewLinesDeletedEvent | null,\n\t];\n\tacceptVersionId(versionId: number): void;\n\n\tgetViewLineCount(): number;\n\tgetActiveIndentGuide(\n\t\tviewLineNumber: number,\n\t\tminLineNumber: number,\n\t\tmaxLineNumber: number,\n\t): IActiveIndentGuideInfo;\n\tgetViewLinesIndentGuides(\n\t\tviewStartLineNumber: number,\n\t\tviewEndLineNumber: number,\n\t): number[];\n\tgetViewLinesBracketGuides(\n\t\tstartLineNumber: number,\n\t\tendLineNumber: number,\n\t\tactivePosition: IPosition | null,\n\t\toptions: BracketGuideOptions,\n\t): IndentGuide[][];\n\tgetViewLineContent(viewLineNumber: number): string;\n\tgetViewLineLength(viewLineNumber: number): number;\n\tgetViewLineMinColumn(viewLineNumber: number): number;\n\tgetViewLineMaxColumn(viewLineNumber: number): number;\n\tgetViewLineData(viewLineNumber: number): ViewLineData;\n\tgetViewLinesData(\n\t\tviewStartLineNumber: number,\n\t\tviewEndLineNumber: number,\n\t\tneeded: boolean[],\n\t): Array<ViewLineData | null>;\n\n\tgetDecorationsInRange(\n\t\trange: Range,\n\t\townerId: number,\n\t\tfilterOutValidation: boolean,\n\t\tonlyMinimapDecorations: boolean,\n\t\tonlyMarginDecorations: boolean,\n\t): IModelDecoration[];\n\n\tgetInjectedTextAt(viewPosition: Position): InjectedText | null;\n\n\tnormalizePosition(position: Position, affinity: PositionAffinity): Position;\n\t/**\n\t * Gets the column at which indentation stops at a given line.\n\t * @internal\n\t */\n\tgetLineIndentColumn(lineNumber: number): number;\n}\n\nexport class ViewModelLinesFromProjectedModel implements IViewModelLines {\n\tprivate readonly _editorId: number;\n\tprivate readonly model: ITextModel;\n\tprivate _validModelVersionId: number;\n\n\tprivate readonly _domLineBreaksComputerFactory: ILineBreaksComputerFactory;\n\tprivate readonly _monospaceLineBreaksComputerFactory: ILineBreaksComputerFactory;\n\n\tprivate fontInfo: FontInfo;\n\tprivate tabSize: number;\n\tprivate wrappingColumn: number;\n\tprivate wrappingIndent: WrappingIndent;\n\tprivate wordBreak: \"normal\" | \"keepAll\";\n\tprivate wrappingStrategy: \"simple\" | \"advanced\";\n\n\tprivate modelLineProjections!: IModelLineProjection[];\n\n\t/**\n\t * Reflects the sum of the line counts of all projected model lines.\n\t */\n\tprivate projectedModelLineLineCounts!: ConstantTimePrefixSumComputer;\n\n\tprivate hiddenAreasDecorationIds!: string[];\n\n\tconstructor(\n\t\teditorId: number,\n\t\tmodel: ITextModel,\n\t\tdomLineBreaksComputerFactory: ILineBreaksComputerFactory,\n\t\tmonospaceLineBreaksComputerFactory: ILineBreaksComputerFactory,\n\t\tfontInfo: FontInfo,\n\t\ttabSize: number,\n\t\twrappingStrategy: \"simple\" | \"advanced\",\n\t\twrappingColumn: number,\n\t\twrappingIndent: WrappingIndent,\n\t\twordBreak: \"normal\" | \"keepAll\",\n\t) {\n\t\tthis._editorId = editorId;\n\t\tthis.model = model;\n\t\tthis._validModelVersionId = -1;\n\t\tthis._domLineBreaksComputerFactory = domLineBreaksComputerFactory;\n\t\tthis._monospaceLineBreaksComputerFactory =\n\t\t\tmonospaceLineBreaksComputerFactory;\n\t\tthis.fontInfo = fontInfo;\n\t\tthis.tabSize = tabSize;\n\t\tthis.wrappingStrategy = wrappingStrategy;\n\t\tthis.wrappingColumn = wrappingColumn;\n\t\tthis.wrappingIndent = wrappingIndent;\n\t\tthis.wordBreak = wordBreak;\n\n\t\tthis._constructLines(/*resetHiddenAreas*/ true, null);\n\t}\n\n\tpublic dispose(): void {\n\t\tthis.hiddenAreasDecorationIds = this.model.deltaDecorations(\n\t\t\tthis.hiddenAreasDecorationIds,\n\t\t\t[],\n\t\t);\n\t}\n\n\tpublic createCoordinatesConverter(): ICoordinatesConverter {\n\t\treturn new CoordinatesConverter(this);\n\t}\n\n\tprivate _constructLines(\n\t\tresetHiddenAreas: boolean,\n\t\tpreviousLineBreaks: (ModelLineProjectionData | null)[] | null,\n\t): void {\n\t\tthis.modelLineProjections = [];\n\n\t\tif (resetHiddenAreas) {\n\t\t\tthis.hiddenAreasDecorationIds = this.model.deltaDecorations(\n\t\t\t\tthis.hiddenAreasDecorationIds,\n\t\t\t\t[],\n\t\t\t);\n\t\t}\n\n\t\tconst linesContent = this.model.getLinesContent();\n\t\tconst injectedTextDecorations = this.model.getInjectedTextDecorations(\n\t\t\tthis._editorId,\n\t\t);\n\t\tconst lineCount = linesContent.length;\n\t\tconst lineBreaksComputer = this.createLineBreaksComputer();\n\n\t\tconst injectedTextQueue = new arrays.ArrayQueue(\n\t\t\tLineInjectedText.fromDecorations(injectedTextDecorations),\n\t\t);\n\t\tfor (let i = 0; i < lineCount; i++) {\n\t\t\tconst lineInjectedText = injectedTextQueue.takeWhile(\n\t\t\t\t(t) => t.lineNumber === i + 1,\n\t\t\t);\n\t\t\tlineBreaksComputer.addRequest(\n\t\t\t\tlinesContent[i],\n\t\t\t\tlineInjectedText,\n\t\t\t\tpreviousLineBreaks ? previousLineBreaks[i] : null,\n\t\t\t);\n\t\t}\n\t\tconst linesBreaks = lineBreaksComputer.finalize();\n\n\t\tconst values: number[] = [];\n\n\t\tconst hiddenAreas = this.hiddenAreasDecorationIds\n\t\t\t.map((areaId) => this.model.getDecorationRange(areaId)!)\n\t\t\t.sort(Range.compareRangesUsingStarts);\n\t\tlet hiddenAreaStart = 1,\n\t\t\thiddenAreaEnd = 0;\n\t\tlet hiddenAreaIdx = -1;\n\t\tlet nextLineNumberToUpdateHiddenArea =\n\t\t\thiddenAreaIdx + 1 < hiddenAreas.length\n\t\t\t\t? hiddenAreaEnd + 1\n\t\t\t\t: lineCount + 2;\n\n\t\tfor (let i = 0; i < lineCount; i++) {\n\t\t\tconst lineNumber = i + 1;\n\n\t\t\tif (lineNumber === nextLineNumberToUpdateHiddenArea) {\n\t\t\t\thiddenAreaIdx++;\n\t\t\t\thiddenAreaStart = hiddenAreas[hiddenAreaIdx]!.startLineNumber;\n\t\t\t\thiddenAreaEnd = hiddenAreas[hiddenAreaIdx]!.endLineNumber;\n\t\t\t\tnextLineNumberToUpdateHiddenArea =\n\t\t\t\t\thiddenAreaIdx + 1 < hiddenAreas.length\n\t\t\t\t\t\t? hiddenAreaEnd + 1\n\t\t\t\t\t\t: lineCount + 2;\n\t\t\t}\n\n\t\t\tconst isInHiddenArea =\n\t\t\t\tlineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd;\n\t\t\tconst line = createModelLineProjection(\n\t\t\t\tlinesBreaks[i],\n\t\t\t\t!isInHiddenArea,\n\t\t\t);\n\t\t\tvalues[i] = line.getViewLineCount();\n\t\t\tthis.modelLineProjections[i] = line;\n\t\t}\n\n\t\tthis._validModelVersionId = this.model.getVersionId();\n\n\t\tthis.projectedModelLineLineCounts = new ConstantTimePrefixSumComputer(\n\t\t\tvalues,\n\t\t);\n\t}\n\n\tpublic getHiddenAreas(): Range[] {\n\t\treturn this.hiddenAreasDecorationIds.map(\n\t\t\t(decId) => this.model.getDecorationRange(decId)!,\n\t\t);\n\t}\n\n\tpublic setHiddenAreas(_ranges: Range[]): boolean {\n\t\tconst validatedRanges = _ranges.map((r) => this.model.validateRange(r));\n\t\tconst newRanges = normalizeLineRanges(validatedRanges);\n\n\t\t// TODO@Martin: Please stop calling this method on each model change!\n\n\t\t// This checks if there really was a change\n\t\tconst oldRanges = this.hiddenAreasDecorationIds\n\t\t\t.map((areaId) => this.model.getDecorationRange(areaId)!)\n\t\t\t.sort(Range.compareRangesUsingStarts);\n\t\tif (newRanges.length === oldRanges.length) {\n\t\t\tlet hasDifference = false;\n\t\t\tfor (let i = 0; i < newRanges.length; i++) {\n\t\t\t\tif (!newRanges[i].equalsRange(oldRanges[i])) {\n\t\t\t\t\thasDifference = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!hasDifference) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tconst newDecorations = newRanges.map<IModelDeltaDecoration>((r) => ({\n\t\t\trange: r,\n\t\t\toptions: ModelDecorationOptions.EMPTY,\n\t\t}));\n\n\t\tthis.hiddenAreasDecorationIds = this.model.deltaDecorations(\n\t\t\tthis.hiddenAreasDecorationIds,\n\t\t\tnewDecorations,\n\t\t);\n\n\t\tconst hiddenAreas = newRanges;\n\t\tlet hiddenAreaStart = 1,\n\t\t\thiddenAreaEnd = 0;\n\t\tlet hiddenAreaIdx = -1;\n\t\tlet nextLineNumberToUpdateHiddenArea =\n\t\t\thiddenAreaIdx + 1 < hiddenAreas.length\n\t\t\t\t? hiddenAreaEnd + 1\n\t\t\t\t: this.modelLineProjections.length + 2;\n\n\t\tlet hasVisibleLine = false;\n\t\tfor (let i = 0; i < this.modelLineProjections.length; i++) {\n\t\t\tconst lineNumber = i + 1;\n\n\t\t\tif (lineNumber === nextLineNumberToUpdateHiddenArea) {\n\t\t\t\thiddenAreaIdx++;\n\t\t\t\thiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n\t\t\t\thiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n\t\t\t\tnextLineNumberToUpdateHiddenArea =\n\t\t\t\t\thiddenAreaIdx + 1 < hiddenAreas.length\n\t\t\t\t\t\t? hiddenAreaEnd + 1\n\t\t\t\t\t\t: this.modelLineProjections.length + 2;\n\t\t\t}\n\n\t\t\tlet lineChanged = false;\n\t\t\tif (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd) {\n\t\t\t\t// Line should be hidden\n\t\t\t\tif (this.modelLineProjections[i].isVisible()) {\n\t\t\t\t\tthis.modelLineProjections[i] =\n\t\t\t\t\t\tthis.modelLineProjections[i].setVisible(false);\n\t\t\t\t\tlineChanged = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thasVisibleLine = true;\n\t\t\t\t// Line should be visible\n\t\t\t\tif (!this.modelLineProjections[i].isVisible()) {\n\t\t\t\t\tthis.modelLineProjections[i] =\n\t\t\t\t\t\tthis.modelLineProjections[i].setVisible(true);\n\t\t\t\t\tlineChanged = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lineChanged) {\n\t\t\t\tconst newOutputLineCount =\n\t\t\t\t\tthis.modelLineProjections[i].getViewLineCount();\n\t\t\t\tthis.projectedModelLineLineCounts.setValue(\n\t\t\t\t\ti,\n\t\t\t\t\tnewOutputLineCount,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tif (!hasVisibleLine) {\n\t\t\t// Cannot have everything be hidden => reveal everything!\n\t\t\tthis.setHiddenAreas([]);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic modelPositionIsVisible(\n\t\tmodelLineNumber: number,\n\t\t_modelColumn: number,\n\t): boolean {\n\t\tif (\n\t\t\tmodelLineNumber < 1 ||\n\t\t\tmodelLineNumber > this.modelLineProjections.length\n\t\t) {\n\t\t\t// invalid arguments\n\t\t\treturn false;\n\t\t}\n\t\treturn this.modelLineProjections[modelLineNumber - 1].isVisible();\n\t}\n\n\tpublic getModelLineViewLineCount(modelLineNumber: number): number {\n\t\tif (\n\t\t\tmodelLineNumber < 1 ||\n\t\t\tmodelLineNumber > this.modelLineProjections.length\n\t\t) {\n\t\t\t// invalid arguments\n\t\t\treturn 1;\n\t\t}\n\t\treturn this.modelLineProjections[\n\t\t\tmodelLineNumber - 1\n\t\t].getViewLineCount();\n\t}\n\n\tpublic setTabSize(newTabSize: number): boolean {\n\t\tif (this.tabSize === newTabSize) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.tabSize = newTabSize;\n\n\t\tthis._constructLines(/*resetHiddenAreas*/ false, null);\n\n\t\treturn true;\n\t}\n\n\tpublic setWrappingSettings(\n\t\tfontInfo: FontInfo,\n\t\twrappingStrategy: \"simple\" | \"advanced\",\n\t\twrappingColumn: number,\n\t\twrappingIndent: WrappingIndent,\n\t\twordBreak: \"normal\" | \"keepAll\",\n\t): boolean {\n\t\tconst equalFontInfo = this.fontInfo.equals(fontInfo);\n\t\tconst equalWrappingStrategy =\n\t\t\tthis.wrappingStrategy === wrappingStrategy;\n\t\tconst equalWrappingColumn = this.wrappingColumn === wrappingColumn;\n\t\tconst equalWrappingIndent = this.wrappingIndent === wrappingIndent;\n\t\tconst equalWordBreak = this.wordBreak === wordBreak;\n\t\tif (\n\t\t\tequalFontInfo &&\n\t\t\tequalWrappingStrategy &&\n\t\t\tequalWrappingColumn &&\n\t\t\tequalWrappingIndent &&\n\t\t\tequalWordBreak\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst onlyWrappingColumnChanged =\n\t\t\tequalFontInfo &&\n\t\t\tequalWrappingStrategy &&\n\t\t\t!equalWrappingColumn &&\n\t\t\tequalWrappingIndent &&\n\t\t\tequalWordBreak;\n\n\t\tthis.fontInfo = fontInfo;\n\t\tthis.wrappingStrategy = wrappingStrategy;\n\t\tthis.wrappingColumn = wrappingColumn;\n\t\tthis.wrappingIndent = wrappingIndent;\n\t\tthis.wordBreak = wordBreak;\n\n\t\tlet previousLineBreaks: (ModelLineProjectionData | null)[] | null =\n\t\t\tnull;\n\t\tif (onlyWrappingColumnChanged) {\n\t\t\tpreviousLineBreaks = [];\n\t\t\tfor (\n\t\t\t\tlet i = 0, len = this.modelLineProjections.length;\n\t\t\t\ti < len;\n\t\t\t\ti++\n\t\t\t) {\n\t\t\t\tpreviousLineBreaks[i] =\n\t\t\t\t\tthis.modelLineProjections[i].getProjectionData();\n\t\t\t}\n\t\t}\n\n\t\tthis._constructLines(/*resetHiddenAreas*/ false, previousLineBreaks);\n\n\t\treturn true;\n\t}\n\n\tpublic createLineBreaksComputer(): ILineBreaksComputer {\n\t\tconst lineBreaksComputerFactory =\n\t\t\tthis.wrappingStrategy === \"advanced\"\n\t\t\t\t? this._domLineBreaksComputerFactory\n\t\t\t\t: this._monospaceLineBreaksComputerFactory;\n\t\treturn lineBreaksComputerFactory.createLineBreaksComputer(\n\t\t\tthis.fontInfo,\n\t\t\tthis.tabSize,\n\t\t\tthis.wrappingColumn,\n\t\t\tthis.wrappingIndent,\n\t\t\tthis.wordBreak,\n\t\t);\n\t}\n\n\tpublic onModelFlushed(): void {\n\t\tthis._constructLines(/*resetHiddenAreas*/ true, null);\n\t}\n\n\tpublic onModelLinesDeleted(\n\t\tversionId: number | null,\n\t\tfromLineNumber: number,\n\t\ttoLineNumber: number,\n\t): viewEvents.ViewLinesDeletedEvent | null {\n\t\tif (!versionId || versionId <= this._validModelVersionId) {\n\t\t\t// Here we check for versionId in case the lines were reconstructed in the meantime.\n\t\t\t// We don't want to apply stale change events on top of a newer read model state.\n\t\t\treturn null;\n\t\t}\n\n\t\tconst outputFromLineNumber =\n\t\t\tfromLineNumber === 1\n\t\t\t\t? 1\n\t\t\t\t: this.projectedModelLineLineCounts.getPrefixSum(\n\t\t\t\t\t\tfromLineNumber - 1,\n\t\t\t\t\t) + 1;\n\t\tconst outputToLineNumber =\n\t\t\tthis.projectedModelLineLineCounts.getPrefixSum(toLineNumber);\n\n\t\tthis.modelLineProjections.splice(\n\t\t\tfromLineNumber - 1,\n\t\t\ttoLineNumber - fromLineNumber + 1,\n\t\t);\n\t\tthis.projectedModelLineLineCounts.removeValues(\n\t\t\tfromLineNumber - 1,\n\t\t\ttoLineNumber - fromLineNumber + 1,\n\t\t);\n\n\t\treturn new viewEvents.ViewLinesDeletedEvent(\n\t\t\toutputFromLineNumber,\n\t\t\toutputToLineNumber,\n\t\t);\n\t}\n\n\tpublic onModelLinesInserted(\n\t\tversionId: number | null,\n\t\tfromLineNumber: number,\n\t\t_toLineNumber: number,\n\t\tlineBreaks: (ModelLineProjectionData | null)[],\n\t): viewEvents.ViewLinesInsertedEvent | null {\n\t\tif (!versionId || versionId <= this._validModelVersionId) {\n\t\t\t// Here we check for versionId in case the lines were reconstructed in the meantime.\n\t\t\t// We don't want to apply stale change events on top of a newer read model state.\n\t\t\treturn null;\n\t\t}\n\n\t\t// cannot use this.getHiddenAreas() because those decorations have already seen the effect of this model change\n\t\tconst isInHiddenArea =\n\t\t\tfromLineNumber > 2 &&\n\t\t\t!this.modelLineProjections[fromLineNumber - 2].isVisible();\n\n\t\tconst outputFromLineNumber =\n\t\t\tfromLineNumber === 1\n\t\t\t\t? 1\n\t\t\t\t: this.projectedModelLineLineCounts.getPrefixSum(\n\t\t\t\t\t\tfromLineNumber - 1,\n\t\t\t\t\t) + 1;\n\n\t\tlet totalOutputLineCount = 0;\n\t\tconst insertLines: IModelLineProjection[] = [];\n\t\tconst insertPrefixSumValues: number[] = [];\n\n\t\tfor (let i = 0, len = lineBreaks.length; i < len; i++) {\n\t\t\tconst line = createModelLineProjection(\n\t\t\t\tlineBreaks[i],\n\t\t\t\t!isInHiddenArea,\n\t\t\t);\n\t\t\tinsertLines.push(line);\n\n\t\t\tconst outputLineCount = line.getViewLineCount();\n\t\t\ttotalOutputLineCount += outputLineCount;\n\t\t\tinsertPrefixSumValues[i] = outputLineCount;\n\t\t}\n\n\t\t// TODO@Alex: use arrays.arrayInsert\n\t\tthis.modelLineProjections = this.modelLineProjections\n\t\t\t.slice(0, fromLineNumber - 1)\n\t\t\t.concat(insertLines)\n\t\t\t.concat(this.modelLineProjections.slice(fromLineNumber - 1));\n\n\t\tthis.projectedModelLineLineCounts.insertValues(\n\t\t\tfromLineNumber - 1,\n\t\t\tinsertPrefixSumValues,\n\t\t);\n\n\t\treturn new viewEvents.ViewLinesInsertedEvent(\n\t\t\toutputFromLineNumber,\n\t\t\toutputFromLineNumber + totalOutputLineCount - 1,\n\t\t);\n\t}\n\n\tpublic onModelLineChanged(\n\t\tversionId: number | null,\n\t\tlineNumber: number,\n\t\tlineBreakData: ModelLineProjectionData | null,\n\t): [\n\t\tboolean,\n\t\tviewEvents.ViewLinesChangedEvent | null,\n\t\tviewEvents.ViewLinesInsertedEvent | null,\n\t\tviewEvents.ViewLinesDeletedEvent | null,\n\t] {\n\t\tif (versionId !== null && versionId <= this._validModelVersionId) {\n\t\t\t// Here we check for versionId in case the lines were reconstructed in the meantime.\n\t\t\t// We don't want to apply stale change events on top of a newer read model state.\n\t\t\treturn [false, null, null, null];\n\t\t}\n\n\t\tconst lineIndex = lineNumber - 1;\n\n\t\tconst oldOutputLineCount =\n\t\t\tthis.modelLineProjections[lineIndex].getViewLineCount();\n\t\tconst isVisible = this.modelLineProjections[lineIndex].isVisible();\n\t\tconst line = createModelLineProjection(lineBreakData, isVisible);\n\t\tthis.modelLineProjections[lineIndex] = line;\n\t\tconst newOutputLineCount =\n\t\t\tthis.modelLineProjections[lineIndex].getViewLineCount();\n\n\t\tlet lineMappingChanged = false;\n\t\tlet changeFrom = 0;\n\t\tlet changeTo = -1;\n\t\tlet insertFrom = 0;\n\t\tlet insertTo = -1;\n\t\tlet deleteFrom = 0;\n\t\tlet deleteTo = -1;\n\n\t\tif (oldOutputLineCount > newOutputLineCount) {\n\t\t\tchangeFrom =\n\t\t\t\tthis.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) +\n\t\t\t\t1;\n\t\t\tchangeTo = changeFrom + newOutputLineCount - 1;\n\t\t\tdeleteFrom = changeTo + 1;\n\t\t\tdeleteTo =\n\t\t\t\tdeleteFrom + (oldOutputLineCount - newOutputLineCount) - 1;\n\t\t\tlineMappingChanged = true;\n\t\t} else if (oldOutputLineCount < newOutputLineCount) {\n\t\t\tchangeFrom =\n\t\t\t\tthis.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) +\n\t\t\t\t1;\n\t\t\tchangeTo = changeFrom + oldOutputLineCount - 1;\n\t\t\tinsertFrom = changeTo + 1;\n\t\t\tinsertTo =\n\t\t\t\tinsertFrom + (newOutputLineCount - oldOutputLineCount) - 1;\n\t\t\tlineMappingChanged = true;\n\t\t} else {\n\t\t\tchangeFrom =\n\t\t\t\tthis.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) +\n\t\t\t\t1;\n\t\t\tchangeTo = changeFrom + newOutputLineCount - 1;\n\t\t}\n\n\t\tthis.projectedModelLineLineCounts.setValue(\n\t\t\tlineIndex,\n\t\t\tnewOutputLineCount,\n\t\t);\n\n\t\tconst viewLinesChangedEvent =\n\t\t\tchangeFrom <= changeTo\n\t\t\t\t? new viewEvents.ViewLinesChangedEvent(\n\t\t\t\t\t\tchangeFrom,\n\t\t\t\t\t\tchangeTo - changeFrom + 1,\n\t\t\t\t\t)\n\t\t\t\t: null;\n\t\tconst viewLinesInsertedEvent =\n\t\t\tinsertFrom <= insertTo\n\t\t\t\t? new viewEvents.ViewLinesInsertedEvent(insertFrom, insertTo)\n\t\t\t\t: null;\n\t\tconst viewLinesDeletedEvent =\n\t\t\tdeleteFrom <= deleteTo\n\t\t\t\t? new viewEvents.ViewLinesDeletedEvent(deleteFrom, deleteTo)\n\t\t\t\t: null;\n\n\t\treturn [\n\t\t\tlineMappingChanged,\n\t\t\tviewLinesChangedEvent,\n\t\t\tviewLinesInsertedEvent,\n\t\t\tviewLinesDeletedEvent,\n\t\t];\n\t}\n\n\tpublic acceptVersionId(versionId: number): void {\n\t\tthis._validModelVersionId = versionId;\n\t\tif (\n\t\t\tthis.modelLineProjections.length === 1 &&\n\t\t\t!this.modelLineProjections[0].isVisible()\n\t\t) {\n\t\t\t// At least one line must be visible => reset hidden areas\n\t\t\tthis.setHiddenAreas([]);\n\t\t}\n\t}\n\n\tpublic getViewLineCount(): number {\n\t\treturn this.projectedModelLineLineCounts.getTotalSum();\n\t}\n\n\tprivate _toValidViewLineNumber(viewLineNumber: number): number {\n\t\tif (viewLineNumber < 1) {\n\t\t\treturn 1;\n\t\t}\n\t\tconst viewLineCount = this.getViewLineCount();\n\t\tif (viewLineNumber > viewLineCount) {\n\t\t\treturn viewLineCount;\n\t\t}\n\t\treturn viewLineNumber | 0;\n\t}\n\n\tpublic getActiveIndentGuide(\n\t\tviewLineNumber: number,\n\t\tminLineNumber: number,\n\t\tmaxLineNumber: number,\n\t): IActiveIndentGuideInfo {\n\t\tviewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n\t\tminLineNumber = this._toValidViewLineNumber(minLineNumber);\n\t\tmaxLineNumber = this._toValidViewLineNumber(maxLineNumber);\n\n\t\tconst modelPosition = this.convertViewPositionToModelPosition(\n\t\t\tviewLineNumber,\n\t\t\tthis.getViewLineMinColumn(viewLineNumber),\n\t\t);\n\t\tconst modelMinPosition = this.convertViewPositionToModelPosition(\n\t\t\tminLineNumber,\n\t\t\tthis.getViewLineMinColumn(minLineNumber),\n\t\t);\n\t\tconst modelMaxPosition = this.convertViewPositionToModelPosition(\n\t\t\tmaxLineNumber,\n\t\t\tthis.getViewLineMinColumn(maxLineNumber),\n\t\t);\n\t\tconst result = this.model.guides.getActiveIndentGuide(\n\t\t\tmodelPosition.lineNumber,\n\t\t\tmodelMinPosition.lineNumber,\n\t\t\tmodelMaxPosition.lineNumber,\n\t\t);\n\n\t\tconst viewStartPosition = this.convertModelPositionToViewPosition(\n\t\t\tresult.startLineNumber,\n\t\t\t1,\n\t\t);\n\t\tconst viewEndPosition = this.convertModelPositionToViewPosition(\n\t\t\tresult.endLineNumber,\n\t\t\tthis.model.getLineMaxColumn(result.endLineNumber),\n\t\t);\n\t\treturn {\n\t\t\tstartLineNumber: viewStartPosition.lineNumber,\n\t\t\tendLineNumber: viewEndPosition.lineNumber,\n\t\t\tindent: result.indent,\n\t\t};\n\t}\n\n\t// #region ViewLineInfo\n\n\tprivate getViewLineInfo(viewLineNumber: number): ViewLineInfo {\n\t\tviewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n\t\tconst r = this.projectedModelLineLineCounts.getIndexOf(\n\t\t\tviewLineNumber - 1,\n\t\t);\n\t\tconst lineIndex = r.index;\n\t\tconst remainder = r.remainder;\n\t\treturn new ViewLineInfo(lineIndex + 1, remainder);\n\t}\n\n\tprivate getMinColumnOfViewLine(viewLineInfo: ViewLineInfo): number {\n\t\treturn this.modelLineProjections[\n\t\t\tviewLineInfo.modelLineNumber - 1\n\t\t].getViewLineMinColumn(\n\t\t\tthis.model,\n\t\t\tviewLineInfo.modelLineNumber,\n\t\t\tviewLineInfo.modelLineWrappedLineIdx,\n\t\t);\n\t}\n\n\tprivate getMaxColumnOfViewLine(viewLineInfo: ViewLineInfo): number {\n\t\treturn this.modelLineProjections[\n\t\t\tviewLineInfo.modelLineNumber - 1\n\t\t].getViewLineMaxColumn(\n\t\t\tthis.model,\n\t\t\tviewLineInfo.modelLineNumber,\n\t\t\tviewLineInfo.modelLineWrappedLineIdx,\n\t\t);\n\t}\n\n\tprivate getModelStartPositionOfViewLine(\n\t\tviewLineInfo: ViewLineInfo,\n\t): Position {\n\t\tconst line =\n\t\t\tthis.modelLineProjections[viewLineInfo.modelLineNumber - 1];\n\t\tconst minViewColumn = line.getViewLineMinColumn(\n\t\t\tthis.model,\n\t\t\tviewLineInfo.modelLineNumber,\n\t\t\tviewLineInfo.modelLineWrappedLineIdx,\n\t\t);\n\t\tconst column = line.getModelColumnOfViewPosition(\n\t\t\tviewLineInfo.modelLineWrappedLineIdx,\n\t\t\tminViewColumn,\n\t\t);\n\t\treturn new Position(viewLineInfo.modelLineNumber, column);\n\t}\n\n\tprivate getModelEndPositionOfViewLine(\n\t\tviewLineInfo: ViewLineInfo,\n\t): Position {\n\t\tconst line =\n\t\t\tthis.modelLineProjections[viewLineInfo.modelLineNumber - 1];\n\t\tconst maxViewColumn = line.getViewLineMaxColumn(\n\t\t\tthis.model,\n\t\t\tviewLineInfo.modelLineNumber,\n\t\t\tviewLineInfo.modelLineWrappedLineIdx,\n\t\t);\n\t\tconst column = line.getModelColumnOfViewPosition(\n\t\t\tviewLineInfo.modelLineWrappedLineIdx,\n\t\t\tmaxViewColumn,\n\t\t);\n\t\treturn new Position(viewLineInfo.modelLineNumber, column);\n\t}\n\n\tprivate getViewLineInfosGroupedByModelRanges(\n\t\tviewStartLineNumber: number,\n\t\tviewEndLineNumber: number,\n\t): ViewLineInfoGroupedByModelRange[] {\n\t\tconst startViewLine = this.getViewLineInfo(viewStartLineNumber);\n\t\tconst endViewLine = this.getViewLineInfo(viewEndLineNumber);\n\n\t\tconst result = new Array<ViewLineInfoGroupedByModelRange>();\n\t\tlet lastVisibleModelPos: Position | null =\n\t\t\tthis.getModelStartPositionOfViewLine(startViewLine);\n\t\tlet viewLines = new Array<ViewLineInfo>();\n\n\t\tfor (\n\t\t\tlet curModelLine = startViewLine.modelLineNumber;\n\t\t\tcurModelLine <= endViewLine.modelLineNumber;\n\t\t\tcurModelLine++\n\t\t) {\n\t\t\tconst line = this.modelLineProjections[curModelLine - 1];\n\n\t\t\tif (line.isVisible()) {\n\t\t\t\tconst startOffset =\n\t\t\t\t\tcurModelLine === startViewLine.modelLineNumber\n\t\t\t\t\t\t? startViewLine.modelLineWrappedLineIdx\n\t\t\t\t\t\t: 0;\n\n\t\t\t\tconst endOffset =\n\t\t\t\t\tcurModelLine === endViewLine.modelLineNumber\n\t\t\t\t\t\t? endViewLine.modelLineWrappedLineIdx + 1\n\t\t\t\t\t\t: line.getViewLineCount();\n\n\t\t\t\tfor (let i = startOffset; i < endOffset; i++) {\n\t\t\t\t\tviewLines.push(new ViewLineInfo(curModelLine, i));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!line.isVisible() && lastVisibleModelPos) {\n\t\t\t\tconst lastVisibleModelPos2 = new Position(\n\t\t\t\t\tcurModelLine - 1,\n\t\t\t\t\tthis.model.getLineMaxColumn(curModelLine - 1) + 1,\n\t\t\t\t);\n\n\t\t\t\tconst modelRange = Range.fromPositions(\n\t\t\t\t\tlastVisibleModelPos,\n\t\t\t\t\tlastVisibleModelPos2,\n\t\t\t\t);\n\t\t\t\tresult.push(\n\t\t\t\t\tnew ViewLineInfoGroupedByModelRange(modelRange, viewLines),\n\t\t\t\t);\n\t\t\t\tviewLines = [];\n\n\t\t\t\tlastVisibleModelPos = null;\n\t\t\t} else if (line.isVisible() && !lastVisibleModelPos) {\n\t\t\t\tlastVisibleModelPos = new Position(curModelLine, 1);\n\t\t\t}\n\t\t}\n\n\t\tif (lastVisibleModelPos) {\n\t\t\tconst modelRange = Range.fromPositions(\n\t\t\t\tlastVisibleModelPos,\n\t\t\t\tthis.getModelEndPositionOfViewLine(endViewLine),\n\t\t\t);\n\t\t\tresult.push(\n\t\t\t\tnew ViewLineInfoGroupedByModelRange(modelRange, viewLines),\n\t\t\t);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// #endregion\n\n\tpublic getViewLinesBracketGuides(\n\t\tviewStartLineNumber: number,\n\t\tviewEndLineNumber: number,\n\t\tactiveViewPosition: IPosition | null,\n\t\toptions: BracketGuideOptions,\n\t): IndentGuide[][] {\n\t\tconst modelActivePosition = activeViewPosition\n\t\t\t? this.convertViewPositionToModelPosition(\n\t\t\t\t\tactiveViewPosition.lineNumber,\n\t\t\t\t\tactiveViewPosition.column,\n\t\t\t\t)\n\t\t\t: null;\n\t\tconst resultPerViewLine: IndentGuide[][] = [];\n\n\t\tfor (const group of this.getViewLineInfosGroupedByModelRanges(\n\t\t\tviewStartLineNumber,\n\t\t\tviewEndLineNumber,\n\t\t)) {\n\t\t\tconst modelRangeStartLineNumber = group.modelRange.startLineNumber;\n\n\t\t\tconst bracketGuidesPerModelLine =\n\t\t\t\tthis.model.guides.getLinesBracketGuides(\n\t\t\t\t\tmodelRangeStartLineNumber,\n\t\t\t\t\tgroup.modelRange.endLineNumber,\n\t\t\t\t\tmodelActivePosition,\n\t\t\t\t\toptions,\n\t\t\t\t);\n\n\t\t\tfor (const viewLineInfo of group.viewLines) {\n\t\t\t\tconst bracketGuides =\n\t\t\t\t\tbracketGuidesPerModelLine[\n\t\t\t\t\t\tviewLineInfo.modelLineNumber - modelRangeStartLineNumber\n\t\t\t\t\t];\n\n\t\t\t\t// visibleColumns stay as they are (this is a bug and needs to be fixed, but it is not a regression)\n\t\t\t\t// model-columns must be converted to view-model columns.\n\t\t\t\tconst result = bracketGuides.map((g) => {\n\t\t\t\t\tif (g.forWrappedLinesAfterColumn !== -1) {\n\t\t\t\t\t\tconst p = this.modelLineProjections[\n\t\t\t\t\t\t\tviewLineInfo.modelLineNumber - 1\n\t\t\t\t\t\t].getViewPositionOfModelPosition(\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\tg.forWrappedLinesAfterColumn,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tp.lineNumber >= viewLineInfo.modelLineWrappedLineIdx\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (g.forWrappedLinesBeforeOrAtColumn !== -1) {\n\t\t\t\t\t\tconst p = this.modelLineProjections[\n\t\t\t\t\t\t\tviewLineInfo.modelLineNumber - 1\n\t\t\t\t\t\t].getViewPositionOfModelPosition(\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\tg.forWrappedLinesBeforeOrAtColumn,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tp.lineNumber < viewLineInfo.modelLineWrappedLineIdx\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!g.horizontalLine) {\n\t\t\t\t\t\treturn g;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet column = -1;\n\t\t\t\t\tif (g.column !== -1) {\n\t\t\t\t\t\tconst p = this.modelLineProjections[\n\t\t\t\t\t\t\tviewLineInfo.modelLineNumber - 1\n\t\t\t\t\t\t].getViewPositionOfModelPosition(0, g.column);\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tp.lineNumber ===\n\t\t\t\t\t\t\tviewLineInfo.modelLineWrappedLineIdx\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcolumn = p.column;\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tp.lineNumber < viewLineInfo.modelLineWrappedLineIdx\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcolumn = this.getMinColumnOfViewLine(viewLineInfo);\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tp.lineNumber > viewLineInfo.modelLineWrappedLineIdx\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst viewPosition =\n\t\t\t\t\t\tthis.convertModelPositionToViewPosition(\n\t\t\t\t\t\t\tviewLineInfo.modelLineNumber,\n\t\t\t\t\t\t\tg.horizontalLine.endColumn,\n\t\t\t\t\t\t);\n\t\t\t\t\tconst p = this.modelLineProjections[\n\t\t\t\t\t\tviewLineInfo.modelLineNumber - 1\n\t\t\t\t\t].getViewPositionOfModelPosition(\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tg.horizontalLine.endColumn,\n\t\t\t\t\t);\n\t\t\t\t\tif (p.lineNumber === viewLineInfo.modelLineWrappedLineIdx) {\n\t\t\t\t\t\treturn new IndentGuide(\n\t\t\t\t\t\t\tg.visibleColumn,\n\t\t\t\t\t\t\tcolumn,\n\t\t\t\t\t\t\tg.className,\n\t\t\t\t\t\t\tnew IndentGuideHorizontalLine(\n\t\t\t\t\t\t\t\tg.horizontalLine.top,\n\t\t\t\t\t\t\t\tviewPosition.column,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tp.lineNumber < viewLineInfo.modelLineWrappedLineIdx\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (g.visibleColumn !== -1) {\n\t\t\t\t\t\t\t// Don't repeat horizontal lines that use visibleColumn for unrelated lines.\n\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn new IndentGuide(\n\t\t\t\t\t\t\tg.visibleColumn,\n\t\t\t\t\t\t\tcolumn,\n\t\t\t\t\t\t\tg.className,\n\t\t\t\t\t\t\tnew IndentGuideHorizontalLine(\n\t\t\t\t\t\t\t\tg.horizontalLine.top,\n\t\t\t\t\t\t\t\tthis.getMaxColumnOfViewLine(viewLineInfo),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tresultPerViewLine.push(\n\t\t\t\t\tresult.filter((r): r is IndentGuide => !!r),\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn resultPerViewLine;\n\t}\n\n\tpublic getViewLinesIndentGuides(\n\t\tviewStartLineNumber: number,\n\t\tviewEndLineNumber: number,\n\t): number[] {\n\t\t// TODO: Use the same code as in `getViewLinesBracketGuides`.\n\t\t// Future TODO: Merge with `getViewLinesBracketGuides`.\n\t\t// However, this requires more refactoring of indent guides.\n\t\tviewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n\t\tviewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n\n\t\tconst modelStart = this.convertViewPositionToModelPosition(\n\t\t\tviewStartLineNumber,\n\t\t\tthis.getViewLineMinColumn(viewStartLineNumber),\n\t\t);\n\t\tconst modelEnd = this.convertViewPositionToModelPosition(\n\t\t\tviewEndLineNumber,\n\t\t\tthis.getViewLineMaxColumn(viewEndLineNumber),\n\t\t);\n\n\t\tlet result: number[] = [];\n\t\tconst resultRepeatCount: number[] = [];\n\t\tconst resultRepeatOption: IndentGuideRepeatOption[] = [];\n\t\tconst modelStartLineIndex = modelStart.lineNumber - 1;\n\t\tconst modelEndLineIndex = modelEnd.lineNumber - 1;\n\n\t\tlet reqStart: Position | null = null;\n\t\tfor (\n\t\t\tlet modelLineIndex = modelStartLineIndex;\n\t\t\tmodelLineIndex <= modelEndLineIndex;\n\t\t\tmodelLineIndex++\n\t\t) {\n\t\t\tconst line = this.modelLineProjections[modelLineIndex];\n\t\t\tif (line.isVisible()) {\n\t\t\t\tconst viewLineStartIndex =\n\t\t\t\t\tline.getViewLineNumberOfModelPosition(\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tmodelLineIndex === modelStartLineIndex\n\t\t\t\t\t\t\t? modelStart.column\n\t\t\t\t\t\t\t: 1,\n\t\t\t\t\t);\n\t\t\t\tconst viewLineEndIndex = line.getViewLineNumberOfModelPosition(\n\t\t\t\t\t0,\n\t\t\t\t\tthis.model.getLineMaxColumn(modelLineIndex + 1),\n\t\t\t\t);\n\t\t\t\tconst count = viewLineEndIndex - viewLineStartIndex + 1;\n\t\t\t\tlet option = IndentGuideRepeatOption.BlockNone;\n\t\t\t\tif (\n\t\t\t\t\tcount > 1 &&\n\t\t\t\t\tline.getViewLineMinColumn(\n\t\t\t\t\t\tthis.model,\n\t\t\t\t\t\tmodelLineIndex + 1,\n\t\t\t\t\t\tviewLineEndIndex,\n\t\t\t\t\t) === 1\n\t\t\t\t) {\n\t\t\t\t\t// wrapped lines should block indent guides\n\t\t\t\t\toption =\n\t\t\t\t\t\tviewLineStartIndex === 0\n\t\t\t\t\t\t\t? IndentGuideRepeatOption.BlockSubsequent\n\t\t\t\t\t\t\t: IndentGuideRepeatOption.BlockAll;\n\t\t\t\t}\n\t\t\t\tresultRepeatCount.push(count);\n\t\t\t\tresultRepeatOption.push(option);\n\t\t\t\t// merge into previous request\n\t\t\t\tif (reqStart === null) {\n\t\t\t\t\treqStart = new Position(modelLineIndex + 1, 0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// hit invisible line => flush request\n\t\t\t\tif (reqStart !== null) {\n\t\t\t\t\tresult = result.concat(\n\t\t\t\t\t\tthis.model.guides.getLinesIndentGuides(\n\t\t\t\t\t\t\treqStart.lineNumber,\n\t\t\t\t\t\t\tmodelLineIndex,\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t\treqStart = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (reqStart !== null) {\n\t\t\tresult = result.concat(\n\t\t\t\tthis.model.guides.getLinesIndentGuides(\n\t\t\t\t\treqStart.lineNumber,\n\t\t\t\t\tmodelEnd.lineNumber,\n\t\t\t\t),\n\t\t\t);\n\t\t\treqStart = null;\n\t\t}\n\n\t\tconst viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n\t\tconst viewIndents = new Array<number>(viewLineCount);\n\t\tlet currIndex = 0;\n\t\tfor (let i = 0, len = result.length; i < len; i++) {\n\t\t\tlet value = result[i];\n\t\t\tconst count = Math.min(\n\t\t\t\tviewLineCount - currIndex,\n\t\t\t\tresultRepeatCount[i],\n\t\t\t);\n\t\t\tconst option = resultRepeatOption[i];\n\t\t\tlet blockAtIndex: number;\n\t\t\tif (option === IndentGuideRepeatOption.BlockAll) {\n\t\t\t\tblockAtIndex = 0;\n\t\t\t} else if (option === IndentGuideRepeatOption.BlockSubsequent) {\n\t\t\t\tblockAtIndex = 1;\n\t\t\t} else {\n\t\t\t\tblockAtIndex = count;\n\t\t\t}\n\t\t\tfor (let j = 0; j < count; j++) {\n\t\t\t\tif (j === blockAtIndex) {\n\t\t\t\t\tvalue = 0;\n\t\t\t\t}\n\t\t\t\tviewIndents[currIndex++] = value;\n\t\t\t}\n\t\t}\n\t\treturn viewIndents;\n\t}\n\n\tpublic getViewLineContent(viewLineNumber: number): string {\n\t\tconst info = this.getViewLineInfo(viewLineNumber);\n\t\treturn this.modelLineProjections[\n\t\t\tinfo.modelLineNumber - 1\n\t\t].getViewLineContent(\n\t\t\tthis.model,\n\t\t\tinfo.modelLineNumber,\n\t\t\tinfo.modelLineWrappedLineIdx,\n\t\t);\n\t}\n\n\tpublic getViewLineLength(viewLineNumber: number): number {\n\t\tconst info = this.getViewLineInfo(viewLineNumber);\n\t\treturn this.modelLineProjections[\n\t\t\tinfo.modelLineNumber - 1\n\t\t].getViewLineLength(\n\t\t\tthis.model,\n\t\t\tinfo.modelLineNumber,\n\t\t\tinfo.modelLineWrappedLineIdx,\n\t\t);\n\t}\n\n\tpublic getViewLineMinColumn(viewLineNumber: number): number {\n\t\tconst info = this.getViewLineInfo(viewLineNumber);\n\t\treturn this.modelLineProjections[\n\t\t\tinfo.modelLineNumber - 1\n\t\t].getViewLineMinColumn(\n\t\t\tthis.model,\n\t\t\tinfo.modelLineNumber,\n\t\t\tinfo.modelLineWrappedLineIdx,\n\t\t);\n\t}\n\n\tpublic getViewLineMaxColumn(viewLineNumber: number): number {\n\t\tconst info = this.getViewLineInfo(viewLineNumber);\n\t\treturn this.modelLineProjections[\n\t\t\tinfo.modelLineNumber - 1\n\t\t].getViewLineMaxColumn(\n\t\t\tthis.model,\n\t\t\tinfo.modelLineNumber,\n\t\t\tinfo.modelLineWrappedLineIdx,\n\t\t);\n\t}\n\n\tpublic getViewLineData(viewLineNumber: number): ViewLineData {\n\t\tconst info = this.getViewLineInfo(viewLineNumber);\n\t\treturn this.modelLineProjections[\n\t\t\tinfo.modelLineNumber - 1\n\t\t].getViewLineData(\n\t\t\tthis.model,\n\t\t\tinfo.modelLineNumber,\n\t\t\tinfo.modelLineWrappedLineIdx,\n\t\t);\n\t}\n\n\tpublic getViewLinesData(\n\t\tviewStartLineNumber: number,\n\t\tviewEndLineNumber: number,\n\t\tneeded: boolean[],\n\t): ViewLineData[] {\n\t\tviewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n\t\tviewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n\n\t\tconst start = this.projectedModelLineLineCounts.getIndexOf(\n\t\t\tviewStartLineNumber - 1,\n\t\t);\n\t\tlet viewLineNumber = viewStartLineNumber;\n\t\tconst startModelLineIndex = start.index;\n\t\tconst startRemainder = start.remainder;\n\n\t\tconst result: ViewLineData[] = [];\n\t\tfor (\n\t\t\tlet modelLineIndex = startModelLineIndex,\n\t\t\t\tlen = this.model.getLineCount();\n\t\t\tmodelLineIndex < len;\n\t\t\tmodelLineIndex++\n\t\t) {\n\t\t\tconst line = this.modelLineProjections[modelLineIndex];\n\t\t\tif (!line.isVisible()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst fromViewLineIndex =\n\t\t\t\tmodelLineIndex === startModelLineIndex ? startRemainder : 0;\n\t\t\tlet remainingViewLineCount =\n\t\t\t\tline.getViewLineCount() - fromViewLineIndex;\n\n\t\t\tlet lastLine = false;\n\t\t\tif (viewLineNumber + remainingViewLineCount > viewEndLineNumber) {\n\t\t\t\tlastLine = true;\n\t\t\t\tremainingViewLineCount = viewEndLineNumber - viewLineNumber + 1;\n\t\t\t}\n\n\t\t\tline.getViewLinesData(\n\t\t\t\tthis.model,\n\t\t\t\tmodelLineIndex + 1,\n\t\t\t\tfromViewLineIndex,\n\t\t\t\tremainingViewLineCount,\n\t\t\t\tviewLineNumber - viewStartLineNumber,\n\t\t\t\tneeded,\n\t\t\t\tresult,\n\t\t\t);\n\n\t\t\tviewLineNumber += remainingViewLineCount;\n\n\t\t\tif (lastLine) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic validateViewPosition(\n\t\tviewLineNumber: number,\n\t\tviewColumn: number,\n\t\texpectedModelPosition: Position,\n\t): Position {\n\t\tviewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n\n\t\tconst r = this.projectedModelLineLineCounts.getIndexOf(\n\t\t\tviewLineNumber - 1,\n\t\t);\n\t\tconst lineIndex = r.index;\n\t\tconst remainder = r.remainder;\n\n\t\tconst line = this.modelLineProjections[lineIndex];\n\n\t\tconst minColumn = line.getViewLineMinColumn(\n\t\t\tthis.model,\n\t\t\tlineIndex + 1,\n\t\t\tremainder,\n\t\t);\n\t\tconst maxColumn = line.getViewLineMaxColumn(\n\t\t\tthis.model,\n\t\t\tlineIndex + 1,\n\t\t\tremainder,\n\t\t);\n\t\tif (viewColumn < minColumn) {\n\t\t\tviewColumn = minColumn;\n\t\t}\n\t\tif (viewColumn > maxColumn) {\n\t\t\tviewColumn = maxColumn;\n\t\t}\n\n\t\tconst computedModelColumn = line.getModelColumnOfViewPosition(\n\t\t\tremainder,\n\t\t\tviewColumn,\n\t\t);\n\t\tconst computedModelPosition = this.model.validatePosition(\n\t\t\tnew Position(lineIndex + 1, computedModelColumn),\n\t\t);\n\n\t\tif (computedModelPosition.equals(expectedModelPosition)) {\n\t\t\treturn new Position(viewLineNumber, viewColumn);\n\t\t}\n\n\t\treturn this.convertModelPositionToViewPosition(\n\t\t\texpectedModelPosition.lineNumber,\n\t\t\texpectedModelPosition.column,\n\t\t);\n\t}\n\n\tpublic validateViewRange(\n\t\tviewRange: Range,\n\t\texpectedModelRange: Range,\n\t): Range {\n\t\tconst validViewStart = this.validateViewPosition(\n\t\t\tviewRange.startLineNumber,\n\t\t\tviewRange.startColumn,\n\t\t\texpectedModelRange.getStartPosition(),\n\t\t);\n\t\tconst validViewEnd = this.validateViewPosition(\n\t\t\tviewRange.endLineNumber,\n\t\t\tviewRange.endColumn,\n\t\t\texpectedModelRange.getEndPosition(),\n\t\t);\n\t\treturn new Range(\n\t\t\tvalidViewStart.lineNumber,\n\t\t\tvalidViewStart.column,\n\t\t\tvalidViewEnd.lineNumber,\n\t\t\tvalidViewEnd.column,\n\t\t);\n\t}\n\n\tpublic convertViewPositionToModelPosition(\n\t\tviewLineNumber: number,\n\t\tviewColumn: number,\n\t): Position {\n\t\tconst info = this.getViewLineInfo(viewLineNumber);\n\n\t\tconst inputColumn = this.modelLineProjections[\n\t\t\tinfo.modelLineNumber - 1\n\t\t].getModelColumnOfViewPosition(\n\t\t\tinfo.modelLineWrappedLineIdx,\n\t\t\tviewColumn,\n\t\t);\n\t\t// console.log('out -> in ' + viewLineNumber + ',' + viewColumn + ' ===> ' + (lineIndex+1) + ',' + inputColumn);\n\t\treturn this.model.validatePosition(\n\t\t\tnew Position(info.modelLineNumber, inputColumn),\n\t\t);\n\t}\n\n\tpublic convertViewRangeToModelRange(viewRange: Range): Range {\n\t\tconst start = this.convertViewPositionToModelPosition(\n\t\t\tviewRange.startLineNumber,\n\t\t\tviewRange.startColumn,\n\t\t);\n\t\tconst end = this.convertViewPositionToModelPosition(\n\t\t\tviewRange.endLineNumber,\n\t\t\tviewRange.endColumn,\n\t\t);\n\t\treturn new Range(\n\t\t\tstart.lineNumber,\n\t\t\tstart.column,\n\t\t\tend.lineNumber,\n\t\t\tend.column,\n\t\t);\n\t}\n\n\tpublic convertModelPositionToViewPosition(\n\t\t_modelLineNumber: number,\n\t\t_modelColumn: number,\n\t\taffinity: PositionAffinity = PositionAffinity.None,\n\t\tallowZeroLineNumber = false,\n\t\tbelowHiddenRanges = false,\n\t): Position {\n\t\tconst validPosition = this.model.validatePosition(\n\t\t\tnew Position(_modelLineNumber, _modelColumn),\n\t\t);\n\t\tconst inputLineNumber = validPosition.lineNumber;\n\t\tconst inputColumn = validPosition.column;\n\n\t\tlet lineIndex = inputLineNumber - 1,\n\t\t\tlineIndexChanged = false;\n\t\tif (belowHiddenRanges) {\n\t\t\twhile (\n\t\t\t\tlineIndex < this.modelLineProjections.length &&\n\t\t\t\t!this.modelLineProjections[lineIndex].isVisible()\n\t\t\t) {\n\t\t\t\tlineIndex++;\n\t\t\t\tlineIndexChanged = true;\n\t\t\t}\n\t\t} else {\n\t\t\twhile (\n\t\t\t\tlineIndex > 0 &&\n\t\t\t\t!this.modelLineProjections[lineIndex].isVisible()\n\t\t\t) {\n\t\t\t\tlineIndex--;\n\t\t\t\tlineIndexChanged = true;\n\t\t\t}\n\t\t}\n\t\tif (\n\t\t\tlineIndex === 0 &&\n\t\t\t!this.modelLineProjections[lineIndex].isVisible()\n\t\t) {\n\t\t\t// Could not reach a real line\n\t\t\t// console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + 1 + ',' + 1);\n\t\t\t// TODO@alexdima@hediet this isn't soo pretty\n\t\t\treturn new Position(allowZeroLineNumber ? 0 : 1, 1);\n\t\t}\n\t\tconst deltaLineNumber =\n\t\t\t1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n\n\t\tlet r: Position;\n\t\tif (lineIndexChanged) {\n\t\t\tif (belowHiddenRanges) {\n\t\t\t\tr = this.modelLineProjections[\n\t\t\t\t\tlineIndex\n\t\t\t\t].getViewPositionOfModelPosition(deltaLineNumber, 1, affinity);\n\t\t\t} else {\n\t\t\t\tr = this.modelLineProjections[\n\t\t\t\t\tlineIndex\n\t\t\t\t].getViewPositionOfModelPosition(\n\t\t\t\t\tdeltaLineNumber,\n\t\t\t\t\tthis.model.getLineMaxColumn(lineIndex + 1),\n\t\t\t\t\taffinity,\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tr = this.modelLineProjections[\n\t\t\t\tinputLineNumber - 1\n\t\t\t].getViewPositionOfModelPosition(\n\t\t\t\tdeltaLineNumber,\n\t\t\t\tinputColumn,\n\t\t\t\taffinity,\n\t\t\t);\n\t\t}\n\n\t\t// console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + r.lineNumber + ',' + r);\n\t\treturn r;\n\t}\n\n\t/**\n\t * @param affinity The affinity in case of an empty range. Has no effect for non-empty ranges.\n\t */\n\tpublic convertModelRangeToViewRange(\n\t\tmodelRange: Range,\n\t\taffinity: PositionAffinity = PositionAffinity.Left,\n\t): Range {\n\t\tif (modelRange.isEmpty()) {\n\t\t\tconst start = this.convertModelPositionToViewPosition(\n\t\t\t\tmodelRange.startLineNumber,\n\t\t\t\tmodelRange.startColumn,\n\t\t\t\taffinity,\n\t\t\t);\n\t\t\treturn Range.fromPositions(start);\n\t\t} else {\n\t\t\tconst start = this.convertModelPositionToViewPosition(\n\t\t\t\tmodelRange.startLineNumber,\n\t\t\t\tmodelRange.startColumn,\n\t\t\t\tPositionAffinity.Right,\n\t\t\t);\n\t\t\tconst end = this.convertModelPositionToViewPosition(\n\t\t\t\tmodelRange.endLineNumber,\n\t\t\t\tmodelRange.endColumn,\n\t\t\t\tPositionAffinity.Left,\n\t\t\t);\n\t\t\treturn new Range(\n\t\t\t\tstart.lineNumber,\n\t\t\t\tstart.column,\n\t\t\t\tend.lineNumber,\n\t\t\t\tend.column,\n\t\t\t);\n\t\t}\n\t}\n\n\tpublic getViewLineNumberOfModelPosition(\n\t\tmodelLineNumber: number,\n\t\tmodelColumn: number,\n\t): number {\n\t\tlet lineIndex = modelLineNumber - 1;\n\t\tif (this.modelLineProjections[lineIndex].isVisible()) {\n\t\t\t// this model line is visible\n\t\t\tconst deltaLineNumber =\n\t\t\t\t1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n\t\t\treturn this.modelLineProjections[\n\t\t\t\tlineIndex\n\t\t\t].getViewLineNumberOfModelPosition(deltaLineNumber, modelColumn);\n\t\t}\n\n\t\t// this model line is not visible\n\t\twhile (\n\t\t\tlineIndex > 0 &&\n\t\t\t!this.modelLineProjections[lineIndex].isVisible()\n\t\t) {\n\t\t\tlineIndex--;\n\t\t}\n\t\tif (\n\t\t\tlineIndex === 0 &&\n\t\t\t!this.modelLineProjections[lineIndex].isVisible()\n\t\t) {\n\t\t\t// Could not reach a real line\n\t\t\treturn 1;\n\t\t}\n\t\tconst deltaLineNumber =\n\t\t\t1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n\t\treturn this.modelLineProjections[\n\t\t\tlineIndex\n\t\t].getViewLineNumberOfModelPosition(\n\t\t\tdeltaLineNumber,\n\t\t\tthis.model.getLineMaxColumn(lineIndex + 1),\n\t\t);\n\t}\n\n\tpublic getDecorationsInRange(\n\t\trange: Range,\n\t\townerId: number,\n\t\tfilterOutValidation: boolean,\n\t\tonlyMinimapDecorations: boolean,\n\t\tonlyMarginDecorations: boolean,\n\t): IModelDecoration[] {\n\t\tconst modelStart = this.convertViewPositionToModelPosition(\n\t\t\trange.startLineNumber,\n\t\t\trange.startColumn,\n\t\t);\n\t\tconst modelEnd = this.convertViewPositionToModelPosition(\n\t\t\trange.endLineNumber,\n\t\t\trange.endColumn,\n\t\t);\n\n\t\tif (\n\t\t\tmodelEnd.lineNumber - modelStart.lineNumber <=\n\t\t\trange.endLineNumber - range.startLineNumber\n\t\t) {\n\t\t\t// most likely there are no hidden lines => fast path\n\t\t\t// fetch decorations from column 1 to cover the case of wrapped lines that have whole line decorations at column 1\n\t\t\treturn this.model.getDecorationsInRange(\n\t\t\t\tnew Range(\n\t\t\t\t\tmodelStart.lineNumber,\n\t\t\t\t\t1,\n\t\t\t\t\tmodelEnd.lineNumber,\n\t\t\t\t\tmodelEnd.column,\n\t\t\t\t),\n\t\t\t\townerId,\n\t\t\t\tfilterOutValidation,\n\t\t\t\tonlyMinimapDecorations,\n\t\t\t\tonlyMarginDecorations,\n\t\t\t);\n\t\t}\n\n\t\tlet result: IModelDecoration[] = [];\n\t\tconst modelStartLineIndex = modelStart.lineNumber - 1;\n\t\tconst modelEndLineIndex = modelEnd.lineNumber - 1;\n\n\t\tlet reqStart: Position | null = null;\n\t\tfor (\n\t\t\tlet modelLineIndex = modelStartLineIndex;\n\t\t\tmodelLineIndex <= modelEndLineIndex;\n\t\t\tmodelLineIndex++\n\t\t) {\n\t\t\tconst line = this.modelLineProjections[modelLineIndex];\n\t\t\tif (line.isVisible()) {\n\t\t\t\t// merge into previous request\n\t\t\t\tif (reqStart === null) {\n\t\t\t\t\treqStart = new Position(\n\t\t\t\t\t\tmodelLineIndex + 1,\n\t\t\t\t\t\tmodelLineIndex === modelStartLineIndex\n\t\t\t\t\t\t\t? modelStart.column\n\t\t\t\t\t\t\t: 1,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// hit invisible line => flush request\n\t\t\t\tif (reqStart !== null) {\n\t\t\t\t\tconst maxLineColumn =\n\t\t\t\t\t\tthis.model.getLineMaxColumn(modelLineIndex);\n\t\t\t\t\tresult = result.concat(\n\t\t\t\t\t\tthis.model.getDecorationsInRange(\n\t\t\t\t\t\t\tnew Range(\n\t\t\t\t\t\t\t\treqStart.lineNumber,\n\t\t\t\t\t\t\t\treqStart.column,\n\t\t\t\t\t\t\t\tmodelLineIndex,\n\t\t\t\t\t\t\t\tmaxLineColumn,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\townerId,\n\t\t\t\t\t\t\tfilterOutValidation,\n\t\t\t\t\t\t\tonlyMinimapDecorations,\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t\treqStart = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (reqStart !== null) {\n\t\t\tresult = result.concat(\n\t\t\t\tthis.model.getDecorationsInRange(\n\t\t\t\t\tnew Range(\n\t\t\t\t\t\treqStart.lineNumber,\n\t\t\t\t\t\treqStart.column,\n\t\t\t\t\t\tmodelEnd.lineNumber,\n\t\t\t\t\t\tmodelEnd.column,\n\t\t\t\t\t),\n\t\t\t\t\townerId,\n\t\t\t\t\tfilterOutValidation,\n\t\t\t\t\tonlyMinimapDecorations,\n\t\t\t\t),\n\t\t\t);\n\t\t\treqStart = null;\n\t\t}\n\n\t\tresult.sort((a, b) => {\n\t\t\tconst res = Range.compareRangesUsingStarts(a.range, b.range);\n\t\t\tif (res === 0) {\n\t\t\t\tif (a.id < b.id) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (a.id > b.id) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn res;\n\t\t});\n\n\t\t// Eliminate duplicate decorations that might have intersected our visible ranges multiple times\n\t\tconst finalResult: IModelDecoration[] = [];\n\t\tlet finalResultLen = 0;\n\t\tlet prevDecId: string | null = null;\n\t\tfor (const dec of result) {\n\t\t\tconst decId = dec.id;\n\t\t\tif (prevDecId === decId) {\n\t\t\t\t// skip\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprevDecId = decId;\n\t\t\tfinalResult[finalResultLen++] = dec;\n\t\t}\n\n\t\treturn finalResult;\n\t}\n\n\tpublic getInjectedTextAt(position: Position): InjectedText | null {\n\t\tconst info = this.getViewLineInfo(position.lineNumber);\n\t\treturn this.modelLineProjections[\n\t\t\tinfo.modelLineNumber - 1\n\t\t].getInjectedTextAt(info.modelLineWrappedLineIdx, position.column);\n\t}\n\n\tnormalizePosition(\n\t\tposition: Position,\n\t\taffinity: PositionAffinity,\n\t): Position {\n\t\tconst info = this.getViewLineInfo(position.lineNumber);\n\t\treturn this.modelLineProjections[\n\t\t\tinfo.modelLineNumber - 1\n\t\t].normalizePosition(info.modelLineWrappedLineIdx, position, affinity);\n\t}\n\n\tpublic getLineIndentColumn(lineNumber: number): number {\n\t\tconst info = this.getViewLineInfo(lineNumber);\n\t\tif (info.modelLineWrappedLineIdx === 0) {\n\t\t\treturn this.model.getLineIndentColumn(info.modelLineNumber);\n\t\t}\n\n\t\t// wrapped lines have no indentation.\n\t\t// We deliberately don't handle the case that indentation is wrapped\n\t\t// to avoid two view lines reporting indentation for the very same model line.\n\t\treturn 0;\n\t}\n}\n\n/**\n * Overlapping unsorted ranges:\n * [   )      [ )       [  )\n *    [    )      [       )\n * ->\n * Non overlapping sorted ranges:\n * [       )  [ ) [        )\n *\n * Note: This function only considers line information! Columns are ignored.\n */\nfunction normalizeLineRanges(ranges: Range[]): Range[] {\n\tif (ranges.length === 0) {\n\t\treturn [];\n\t}\n\n\tconst sortedRanges = ranges.slice();\n\tsortedRanges.sort(Range.compareRangesUsingStarts);\n\n\tconst result: Range[] = [];\n\tlet currentRangeStart = sortedRanges[0].startLineNumber;\n\tlet currentRangeEnd = sortedRanges[0].endLineNumber;\n\n\tfor (let i = 1, len = sortedRanges.length; i < len; i++) {\n\t\tconst range = sortedRanges[i];\n\n\t\tif (range.startLineNumber > currentRangeEnd + 1) {\n\t\t\tresult.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n\t\t\tcurrentRangeStart = range.startLineNumber;\n\t\t\tcurrentRangeEnd = range.endLineNumber;\n\t\t} else if (range.endLineNumber > currentRangeEnd) {\n\t\t\tcurrentRangeEnd = range.endLineNumber;\n\t\t}\n\t}\n\tresult.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n\treturn result;\n}\n\n/**\n * Represents a view line. Can be used to efficiently query more information about it.\n */\nclass ViewLineInfo {\n\tpublic get isWrappedLineContinuation(): boolean {\n\t\treturn this.modelLineWrappedLineIdx > 0;\n\t}\n\n\tconstructor(\n\t\tpublic readonly modelLineNumber: number,\n\t\tpublic readonly modelLineWrappedLineIdx: number,\n\t) {}\n}\n\n/**\n * A list of view lines that have a contiguous span in the model.\n */\nclass ViewLineInfoGroupedByModelRange {\n\tconstructor(\n\t\tpublic readonly modelRange: Range,\n\t\tpublic readonly viewLines: ViewLineInfo[],\n\t) {}\n}\n\nclass CoordinatesConverter implements ICoordinatesConverter {\n\tprivate readonly _lines: ViewModelLinesFromProjectedModel;\n\n\tconstructor(lines: ViewModelLinesFromProjectedModel) {\n\t\tthis._lines = lines;\n\t}\n\n\t// View -> Model conversion and related methods\n\n\tpublic convertViewPositionToModelPosition(\n\t\tviewPosition: Position,\n\t): Position {\n\t\treturn this._lines.convertViewPositionToModelPosition(\n\t\t\tviewPosition.lineNumber,\n\t\t\tviewPosition.column,\n\t\t);\n\t}\n\n\tpublic convertViewRangeToModelRange(viewRange: Range): Range {\n\t\treturn this._lines.convertViewRangeToModelRange(viewRange);\n\t}\n\n\tpublic validateViewPosition(\n\t\tviewPosition: Position,\n\t\texpectedModelPosition: Position,\n\t): Position {\n\t\treturn this._lines.validateViewPosition(\n\t\t\tviewPosition.lineNumber,\n\t\t\tviewPosition.column,\n\t\t\texpectedModelPosition,\n\t\t);\n\t}\n\n\tpublic validateViewRange(\n\t\tviewRange: Range,\n\t\texpectedModelRange: Range,\n\t): Range {\n\t\treturn this._lines.validateViewRange(viewRange, expectedModelRange);\n\t}\n\n\t// Model -> View conversion and related methods\n\n\tpublic convertModelPositionToViewPosition(\n\t\tmodelPosition: Position,\n\t\taffinity?: PositionAffinity,\n\t\tallowZero?: boolean,\n\t\tbelowHiddenRanges?: boolean,\n\t): Position {\n\t\treturn this._lines.convertModelPositionToViewPosition(\n\t\t\tmodelPosition.lineNumber,\n\t\t\tmodelPosition.column,\n\t\t\taffinity,\n\t\t\tallowZero,\n\t\t\tbelowHiddenRanges,\n\t\t);\n\t}\n\n\tpublic convertModelRangeToViewRange(\n\t\tmodelRange: Range,\n\t\taffinity?: PositionAffinity,\n\t): Range {\n\t\treturn this._lines.convertModelRangeToViewRange(modelRange, affinity);\n\t}\n\n\tpublic modelPositionIsVisible(modelPosition: Position): boolean {\n\t\treturn this._lines.modelPositionIsVisible(\n\t\t\tmodelPosition.lineNumber,\n\t\t\tmodelPosition.column,\n\t\t);\n\t}\n\n\tpublic getModelLineViewLineCount(modelLineNumber: number): number {\n\t\treturn this._lines.getModelLineViewLineCount(modelLineNumber);\n\t}\n\n\tpublic getViewLineNumberOfModelPosition(\n\t\tmodelLineNumber: number,\n\t\tmodelColumn: number,\n\t): number {\n\t\treturn this._lines.getViewLineNumberOfModelPosition(\n\t\t\tmodelLineNumber,\n\t\t\tmodelColumn,\n\t\t);\n\t}\n}\n\nenum IndentGuideRepeatOption {\n\tBlockNone = 0,\n\tBlockSubsequent = 1,\n\tBlockAll = 2,\n}\n\nexport class ViewModelLinesFromModelAsIs implements IViewModelLines {\n\tpublic readonly model: ITextModel;\n\n\tconstructor(model: ITextModel) {\n\t\tthis.model = model;\n\t}\n\n\tpublic dispose(): void {}\n\n\tpublic createCoordinatesConverter(): ICoordinatesConverter {\n\t\treturn new IdentityCoordinatesConverter(this);\n\t}\n\n\tpublic getHiddenAreas(): Range[] {\n\t\treturn [];\n\t}\n\n\tpublic setHiddenAreas(_ranges: Range[]): boolean {\n\t\treturn false;\n\t}\n\n\tpublic setTabSize(_newTabSize: number): boolean {\n\t\treturn false;\n\t}\n\n\tpublic setWrappingSettings(\n\t\t_fontInfo: FontInfo,\n\t\t_wrappingStrategy: \"simple\" | \"advanced\",\n\t\t_wrappingColumn: number,\n\t\t_wrappingIndent: WrappingIndent,\n\t): boolean {\n\t\treturn false;\n\t}\n\n\tpublic createLineBreaksComputer(): ILineBreaksComputer {\n\t\tconst result: null[] = [];\n\t\treturn {\n\t\t\taddRequest: (\n\t\t\t\tlineText: string,\n\t\t\t\tinjectedText: LineInjectedText[] | null,\n\t\t\t\tpreviousLineBreakData: ModelLineProjectionData | null,\n\t\t\t) => {\n\t\t\t\tresult.push(null);\n\t\t\t},\n\t\t\tfinalize: () => {\n\t\t\t\treturn result;\n\t\t\t},\n\t\t};\n\t}\n\n\tpublic onModelFlushed(): void {}\n\n\tpublic onModelLinesDeleted(\n\t\t_versionId: number | null,\n\t\tfromLineNumber: number,\n\t\ttoLineNumber: number,\n\t): viewEvents.ViewLinesDeletedEvent | null {\n\t\treturn new viewEvents.ViewLinesDeletedEvent(\n\t\t\tfromLineNumber,\n\t\t\ttoLineNumber,\n\t\t);\n\t}\n\n\tpublic onModelLinesInserted(\n\t\t_versionId: number | null,\n\t\tfromLineNumber: number,\n\t\ttoLineNumber: number,\n\t\tlineBreaks: (ModelLineProjectionData | null)[],\n\t): viewEvents.ViewLinesInsertedEvent | null {\n\t\treturn new viewEvents.ViewLinesInsertedEvent(\n\t\t\tfromLineNumber,\n\t\t\ttoLineNumber,\n\t\t);\n\t}\n\n\tpublic onModelLineChanged(\n\t\t_versionId: number | null,\n\t\tlineNumber: number,\n\t\tlineBreakData: ModelLineProjectionData | null,\n\t): [\n\t\tboolean,\n\t\tviewEvents.ViewLinesChangedEvent | null,\n\t\tviewEvents.ViewLinesInsertedEvent | null,\n\t\tviewEvents.ViewLinesDeletedEvent | null,\n\t] {\n\t\treturn [\n\t\t\tfalse,\n\t\t\tnew viewEvents.ViewLinesChangedEvent(lineNumber, 1),\n\t\t\tnull,\n\t\t\tnull,\n\t\t];\n\t}\n\n\tpublic acceptVersionId(_versionId: number): void {}\n\n\tpublic getViewLineCount(): number {\n\t\treturn this.model.getLineCount();\n\t}\n\n\tpublic getActiveIndentGuide(\n\t\tviewLineNumber: number,\n\t\t_minLineNumber: number,\n\t\t_maxLineNumber: number,\n\t): IActiveIndentGuideInfo {\n\t\treturn {\n\t\t\tstartLineNumber: viewLineNumber,\n\t\t\tendLineNumber: viewLineNumber,\n\t\t\tindent: 0,\n\t\t};\n\t}\n\n\tpublic getViewLinesBracketGuides(\n\t\tstartLineNumber: number,\n\t\tendLineNumber: number,\n\t\tactivePosition: IPosition | null,\n\t): IndentGuide[][] {\n\t\treturn new Array(endLineNumber - startLineNumber + 1).fill([]);\n\t}\n\n\tpublic getViewLinesIndentGuides(\n\t\tviewStartLineNumber: number,\n\t\tviewEndLineNumber: number,\n\t): number[] {\n\t\tconst viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n\t\tconst result = new Array<number>(viewLineCount);\n\t\tfor (let i = 0; i < viewLineCount; i++) {\n\t\t\tresult[i] = 0;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic getViewLineContent(viewLineNumber: number): string {\n\t\treturn this.model.getLineContent(viewLineNumber);\n\t}\n\n\tpublic getViewLineLength(viewLineNumber: number): number {\n\t\treturn this.model.getLineLength(viewLineNumber);\n\t}\n\n\tpublic getViewLineMinColumn(viewLineNumber: number): number {\n\t\treturn this.model.getLineMinColumn(viewLineNumber);\n\t}\n\n\tpublic getViewLineMaxColumn(viewLineNumber: number): number {\n\t\treturn this.model.getLineMaxColumn(viewLineNumber);\n\t}\n\n\tpublic getViewLineData(viewLineNumber: number): ViewLineData {\n\t\tconst lineTokens =\n\t\t\tthis.model.tokenization.getLineTokens(viewLineNumber);\n\t\tconst lineContent = lineTokens.getLineContent();\n\t\treturn new ViewLineData(\n\t\t\tlineContent,\n\t\t\tfalse,\n\t\t\t1,\n\t\t\tlineContent.length + 1,\n\t\t\t0,\n\t\t\tlineTokens.inflate(),\n\t\t\tnull,\n\t\t);\n\t}\n\n\tpublic getViewLinesData(\n\t\tviewStartLineNumber: number,\n\t\tviewEndLineNumber: number,\n\t\tneeded: boolean[],\n\t): Array<ViewLineData | null> {\n\t\tconst lineCount = this.model.getLineCount();\n\t\tviewStartLineNumber = Math.min(\n\t\t\tMath.max(1, viewStartLineNumber),\n\t\t\tlineCount,\n\t\t);\n\t\tviewEndLineNumber = Math.min(Math.max(1, viewEndLineNumber), lineCount);\n\n\t\tconst result: Array<ViewLineData | null> = [];\n\t\tfor (\n\t\t\tlet lineNumber = viewStartLineNumber;\n\t\t\tlineNumber <= viewEndLineNumber;\n\t\t\tlineNumber++\n\t\t) {\n\t\t\tconst idx = lineNumber - viewStartLineNumber;\n\t\t\tresult[idx] = needed[idx] ? this.getViewLineData(lineNumber) : null;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic getDecorationsInRange(\n\t\trange: Range,\n\t\townerId: number,\n\t\tfilterOutValidation: boolean,\n\t\tonlyMinimapDecorations: boolean,\n\t\tonlyMarginDecorations: boolean,\n\t): IModelDecoration[] {\n\t\treturn this.model.getDecorationsInRange(\n\t\t\trange,\n\t\t\townerId,\n\t\t\tfilterOutValidation,\n\t\t\tonlyMinimapDecorations,\n\t\t\tonlyMarginDecorations,\n\t\t);\n\t}\n\n\tnormalizePosition(\n\t\tposition: Position,\n\t\taffinity: PositionAffinity,\n\t): Position {\n\t\treturn this.model.normalizePosition(position, affinity);\n\t}\n\n\tpublic getLineIndentColumn(lineNumber: number): number {\n\t\treturn this.model.getLineIndentColumn(lineNumber);\n\t}\n\n\tpublic getInjectedTextAt(position: Position): InjectedText | null {\n\t\t// Identity lines collection does not support injected text.\n\t\treturn null;\n\t}\n}\n\nclass IdentityCoordinatesConverter implements ICoordinatesConverter {\n\tprivate readonly _lines: ViewModelLinesFromModelAsIs;\n\n\tconstructor(lines: ViewModelLinesFromModelAsIs) {\n\t\tthis._lines = lines;\n\t}\n\n\tprivate _validPosition(pos: Position): Position {\n\t\treturn this._lines.model.validatePosition(pos);\n\t}\n\n\tprivate _validRange(range: Range): Range {\n\t\treturn this._lines.model.validateRange(range);\n\t}\n\n\t// View -> Model conversion and related methods\n\n\tpublic convertViewPositionToModelPosition(\n\t\tviewPosition: Position,\n\t): Position {\n\t\treturn this._validPosition(viewPosition);\n\t}\n\n\tpublic convertViewRangeToModelRange(viewRange: Range): Range {\n\t\treturn this._validRange(viewRange);\n\t}\n\n\tpublic validateViewPosition(\n\t\t_viewPosition: Position,\n\t\texpectedModelPosition: Position,\n\t): Position {\n\t\treturn this._validPosition(expectedModelPosition);\n\t}\n\n\tpublic validateViewRange(\n\t\t_viewRange: Range,\n\t\texpectedModelRange: Range,\n\t): Range {\n\t\treturn this._validRange(expectedModelRange);\n\t}\n\n\t// Model -> View conversion and related methods\n\n\tpublic convertModelPositionToViewPosition(\n\t\tmodelPosition: Position,\n\t): Position {\n\t\treturn this._validPosition(modelPosition);\n\t}\n\n\tpublic convertModelRangeToViewRange(modelRange: Range): Range {\n\t\treturn this._validRange(modelRange);\n\t}\n\n\tpublic modelPositionIsVisible(modelPosition: Position): boolean {\n\t\tconst lineCount = this._lines.model.getLineCount();\n\t\tif (\n\t\t\tmodelPosition.lineNumber < 1 ||\n\t\t\tmodelPosition.lineNumber > lineCount\n\t\t) {\n\t\t\t// invalid arguments\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic modelRangeIsVisible(modelRange: Range): boolean {\n\t\tconst lineCount = this._lines.model.getLineCount();\n\t\tif (\n\t\t\tmodelRange.startLineNumber < 1 ||\n\t\t\tmodelRange.startLineNumber > lineCount\n\t\t) {\n\t\t\t// invalid arguments\n\t\t\treturn false;\n\t\t}\n\t\tif (\n\t\t\tmodelRange.endLineNumber < 1 ||\n\t\t\tmodelRange.endLineNumber > lineCount\n\t\t) {\n\t\t\t// invalid arguments\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic getModelLineViewLineCount(modelLineNumber: number): number {\n\t\treturn 1;\n\t}\n\n\tpublic getViewLineNumberOfModelPosition(\n\t\tmodelLineNumber: number,\n\t\tmodelColumn: number,\n\t): number {\n\t\treturn modelLineNumber;\n\t}\n}\n"],
  "mappings": "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",
  "names": ["p", "deltaLineNumber", "IndentGuideRepeatOption"]
}
