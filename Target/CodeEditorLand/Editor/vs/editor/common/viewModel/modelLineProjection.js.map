{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/viewModel/modelLineProjection.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { LineTokens } from '../tokens/lineTokens.js';\nimport { Position } from '../core/position.js';\nimport { IRange } from '../core/range.js';\nimport { EndOfLinePreference, ITextModel, PositionAffinity } from '../model.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport { InjectedText, ModelLineProjectionData } from '../modelLineProjectionData.js';\nimport { SingleLineInlineDecoration, ViewLineData } from '../viewModel.js';\n\nexport interface IModelLineProjection {\n\tisVisible(): boolean;\n\n\t/**\n\t * This invalidates the current instance (potentially reuses and returns it again).\n\t*/\n\tsetVisible(isVisible: boolean): IModelLineProjection;\n\n\tgetProjectionData(): ModelLineProjectionData | null;\n\tgetViewLineCount(): number;\n\tgetViewLineContent(model: ISimpleModel, modelLineNumber: number, outputLineIndex: number): string;\n\tgetViewLineLength(model: ISimpleModel, modelLineNumber: number, outputLineIndex: number): number;\n\tgetViewLineMinColumn(model: ISimpleModel, modelLineNumber: number, outputLineIndex: number): number;\n\tgetViewLineMaxColumn(model: ISimpleModel, modelLineNumber: number, outputLineIndex: number): number;\n\tgetViewLineData(model: ISimpleModel, modelLineNumber: number, outputLineIndex: number): ViewLineData;\n\tgetViewLinesData(model: ISimpleModel, modelLineNumber: number, outputLineIdx: number, lineCount: number, globalStartIndex: number, needed: boolean[], result: Array<ViewLineData | null>): void;\n\n\tgetModelColumnOfViewPosition(outputLineIndex: number, outputColumn: number): number;\n\tgetViewPositionOfModelPosition(deltaLineNumber: number, inputColumn: number, affinity?: PositionAffinity): Position;\n\tgetViewLineNumberOfModelPosition(deltaLineNumber: number, inputColumn: number): number;\n\tnormalizePosition(outputLineIndex: number, outputPosition: Position, affinity: PositionAffinity): Position;\n\n\tgetInjectedTextAt(outputLineIndex: number, column: number): InjectedText | null;\n}\n\nexport interface ISimpleModel {\n\ttokenization: {\n\t\tgetLineTokens(lineNumber: number): LineTokens;\n\t};\n\tgetLineContent(lineNumber: number): string;\n\tgetLineLength(lineNumber: number): number;\n\tgetLineMinColumn(lineNumber: number): number;\n\tgetLineMaxColumn(lineNumber: number): number;\n\tgetValueInRange(range: IRange, eol?: EndOfLinePreference): string;\n}\n\nexport function createModelLineProjection(lineBreakData: ModelLineProjectionData | null, isVisible: boolean): IModelLineProjection {\n\tif (lineBreakData === null) {\n\t\t// No mapping needed\n\t\tif (isVisible) {\n\t\t\treturn IdentityModelLineProjection.INSTANCE;\n\t\t}\n\t\treturn HiddenModelLineProjection.INSTANCE;\n\t} else {\n\t\treturn new ModelLineProjection(lineBreakData, isVisible);\n\t}\n}\n\n/**\n * This projection is used to\n * * wrap model lines\n * * inject text\n */\nclass ModelLineProjection implements IModelLineProjection {\n\tprivate readonly _projectionData: ModelLineProjectionData;\n\tprivate _isVisible: boolean;\n\n\tconstructor(lineBreakData: ModelLineProjectionData, isVisible: boolean) {\n\t\tthis._projectionData = lineBreakData;\n\t\tthis._isVisible = isVisible;\n\t}\n\n\tpublic isVisible(): boolean {\n\t\treturn this._isVisible;\n\t}\n\n\tpublic setVisible(isVisible: boolean): IModelLineProjection {\n\t\tthis._isVisible = isVisible;\n\t\treturn this;\n\t}\n\n\tpublic getProjectionData(): ModelLineProjectionData | null {\n\t\treturn this._projectionData;\n\t}\n\n\tpublic getViewLineCount(): number {\n\t\tif (!this._isVisible) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this._projectionData.getOutputLineCount();\n\t}\n\n\tpublic getViewLineContent(model: ISimpleModel, modelLineNumber: number, outputLineIndex: number): string {\n\t\tthis._assertVisible();\n\n\t\tconst startOffsetInInputWithInjections = outputLineIndex > 0 ? this._projectionData.breakOffsets[outputLineIndex - 1] : 0;\n\t\tconst endOffsetInInputWithInjections = this._projectionData.breakOffsets[outputLineIndex];\n\n\t\tlet r: string;\n\t\tif (this._projectionData.injectionOffsets !== null) {\n\t\t\tconst injectedTexts = this._projectionData.injectionOffsets.map(\n\t\t\t\t(offset, idx) => new LineInjectedText(\n\t\t\t\t\t0,\n\t\t\t\t\t0,\n\t\t\t\t\toffset + 1,\n\t\t\t\t\tthis._projectionData.injectionOptions![idx],\n\t\t\t\t\t0\n\t\t\t\t)\n\t\t\t);\n\t\t\tconst lineWithInjections = LineInjectedText.applyInjectedText(\n\t\t\t\tmodel.getLineContent(modelLineNumber),\n\t\t\t\tinjectedTexts\n\t\t\t);\n\t\t\tr = lineWithInjections.substring(startOffsetInInputWithInjections, endOffsetInInputWithInjections);\n\t\t} else {\n\t\t\tr = model.getValueInRange({\n\t\t\t\tstartLineNumber: modelLineNumber,\n\t\t\t\tstartColumn: startOffsetInInputWithInjections + 1,\n\t\t\t\tendLineNumber: modelLineNumber,\n\t\t\t\tendColumn: endOffsetInInputWithInjections + 1\n\t\t\t});\n\t\t}\n\n\t\tif (outputLineIndex > 0) {\n\t\t\tr = spaces(this._projectionData.wrappedTextIndentLength) + r;\n\t\t}\n\n\t\treturn r;\n\t}\n\n\tpublic getViewLineLength(model: ISimpleModel, modelLineNumber: number, outputLineIndex: number): number {\n\t\tthis._assertVisible();\n\t\treturn this._projectionData.getLineLength(outputLineIndex);\n\t}\n\n\tpublic getViewLineMinColumn(_model: ITextModel, _modelLineNumber: number, outputLineIndex: number): number {\n\t\tthis._assertVisible();\n\t\treturn this._projectionData.getMinOutputOffset(outputLineIndex) + 1;\n\t}\n\n\tpublic getViewLineMaxColumn(model: ISimpleModel, modelLineNumber: number, outputLineIndex: number): number {\n\t\tthis._assertVisible();\n\t\treturn this._projectionData.getMaxOutputOffset(outputLineIndex) + 1;\n\t}\n\n\t/**\n\t * Try using {@link getViewLinesData} instead.\n\t*/\n\tpublic getViewLineData(model: ISimpleModel, modelLineNumber: number, outputLineIndex: number): ViewLineData {\n\t\tconst arr = new Array<ViewLineData>();\n\t\tthis.getViewLinesData(model, modelLineNumber, outputLineIndex, 1, 0, [true], arr);\n\t\treturn arr[0];\n\t}\n\n\tpublic getViewLinesData(model: ISimpleModel, modelLineNumber: number, outputLineIdx: number, lineCount: number, globalStartIndex: number, needed: boolean[], result: Array<ViewLineData | null>): void {\n\t\tthis._assertVisible();\n\n\t\tconst lineBreakData = this._projectionData;\n\n\t\tconst injectionOffsets = lineBreakData.injectionOffsets;\n\t\tconst injectionOptions = lineBreakData.injectionOptions;\n\n\t\tlet inlineDecorationsPerOutputLine: SingleLineInlineDecoration[][] | null = null;\n\n\t\tif (injectionOffsets) {\n\t\t\tinlineDecorationsPerOutputLine = [];\n\t\t\tlet totalInjectedTextLengthBefore = 0;\n\t\t\tlet currentInjectedOffset = 0;\n\n\t\t\tfor (let outputLineIndex = 0; outputLineIndex < lineBreakData.getOutputLineCount(); outputLineIndex++) {\n\t\t\t\tconst inlineDecorations = new Array<SingleLineInlineDecoration>();\n\t\t\t\tinlineDecorationsPerOutputLine[outputLineIndex] = inlineDecorations;\n\n\t\t\t\tconst lineStartOffsetInInputWithInjections = outputLineIndex > 0 ? lineBreakData.breakOffsets[outputLineIndex - 1] : 0;\n\t\t\t\tconst lineEndOffsetInInputWithInjections = lineBreakData.breakOffsets[outputLineIndex];\n\n\t\t\t\twhile (currentInjectedOffset < injectionOffsets.length) {\n\t\t\t\t\tconst length = injectionOptions![currentInjectedOffset].content.length;\n\t\t\t\t\tconst injectedTextStartOffsetInInputWithInjections = injectionOffsets[currentInjectedOffset] + totalInjectedTextLengthBefore;\n\t\t\t\t\tconst injectedTextEndOffsetInInputWithInjections = injectedTextStartOffsetInInputWithInjections + length;\n\n\t\t\t\t\tif (injectedTextStartOffsetInInputWithInjections > lineEndOffsetInInputWithInjections) {\n\t\t\t\t\t\t// Injected text only starts in later wrapped lines.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (lineStartOffsetInInputWithInjections < injectedTextEndOffsetInInputWithInjections) {\n\t\t\t\t\t\t// Injected text ends after or in this line (but also starts in or before this line).\n\t\t\t\t\t\tconst options = injectionOptions![currentInjectedOffset];\n\t\t\t\t\t\tif (options.inlineClassName) {\n\t\t\t\t\t\t\tconst offset = (outputLineIndex > 0 ? lineBreakData.wrappedTextIndentLength : 0);\n\t\t\t\t\t\t\tconst start = offset + Math.max(injectedTextStartOffsetInInputWithInjections - lineStartOffsetInInputWithInjections, 0);\n\t\t\t\t\t\t\tconst end = offset + Math.min(injectedTextEndOffsetInInputWithInjections - lineStartOffsetInInputWithInjections, lineEndOffsetInInputWithInjections - lineStartOffsetInInputWithInjections);\n\t\t\t\t\t\t\tif (start !== end) {\n\t\t\t\t\t\t\t\tinlineDecorations.push(new SingleLineInlineDecoration(start, end, options.inlineClassName, options.inlineClassNameAffectsLetterSpacing!));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (injectedTextEndOffsetInInputWithInjections <= lineEndOffsetInInputWithInjections) {\n\t\t\t\t\t\ttotalInjectedTextLengthBefore += length;\n\t\t\t\t\t\tcurrentInjectedOffset++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// injected text breaks into next line, process it again\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet lineWithInjections: LineTokens;\n\t\tif (injectionOffsets) {\n\t\t\tconst tokensToInsert: { offset: number; text: string; tokenMetadata: number }[] = [];\n\n\t\t\tfor (let idx = 0; idx < injectionOffsets.length; idx++) {\n\t\t\t\tconst offset = injectionOffsets[idx];\n\t\t\t\tconst tokens = injectionOptions![idx].tokens;\n\t\t\t\tif (tokens) {\n\t\t\t\t\ttokens.forEach((range, info) => {\n\t\t\t\t\t\ttokensToInsert.push({\n\t\t\t\t\t\t\toffset,\n\t\t\t\t\t\t\ttext: range.substring(injectionOptions![idx].content),\n\t\t\t\t\t\t\ttokenMetadata: info.metadata,\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\ttokensToInsert.push({\n\t\t\t\t\t\toffset,\n\t\t\t\t\t\ttext: injectionOptions![idx].content,\n\t\t\t\t\t\ttokenMetadata: LineTokens.defaultTokenMetadata,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlineWithInjections = model.tokenization.getLineTokens(modelLineNumber).withInserted(tokensToInsert);\n\t\t} else {\n\t\t\tlineWithInjections = model.tokenization.getLineTokens(modelLineNumber);\n\t\t}\n\n\t\tfor (let outputLineIndex = outputLineIdx; outputLineIndex < outputLineIdx + lineCount; outputLineIndex++) {\n\t\t\tconst globalIndex = globalStartIndex + outputLineIndex - outputLineIdx;\n\t\t\tif (!needed[globalIndex]) {\n\t\t\t\tresult[globalIndex] = null;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tresult[globalIndex] = this._getViewLineData(lineWithInjections, inlineDecorationsPerOutputLine ? inlineDecorationsPerOutputLine[outputLineIndex] : null, outputLineIndex);\n\t\t}\n\t}\n\n\tprivate _getViewLineData(lineWithInjections: LineTokens, inlineDecorations: null | SingleLineInlineDecoration[], outputLineIndex: number): ViewLineData {\n\t\tthis._assertVisible();\n\t\tconst lineBreakData = this._projectionData;\n\t\tconst deltaStartIndex = (outputLineIndex > 0 ? lineBreakData.wrappedTextIndentLength : 0);\n\n\t\tconst lineStartOffsetInInputWithInjections = outputLineIndex > 0 ? lineBreakData.breakOffsets[outputLineIndex - 1] : 0;\n\t\tconst lineEndOffsetInInputWithInjections = lineBreakData.breakOffsets[outputLineIndex];\n\t\tconst tokens = lineWithInjections.sliceAndInflate(lineStartOffsetInInputWithInjections, lineEndOffsetInInputWithInjections, deltaStartIndex);\n\n\t\tlet lineContent = tokens.getLineContent();\n\t\tif (outputLineIndex > 0) {\n\t\t\tlineContent = spaces(lineBreakData.wrappedTextIndentLength) + lineContent;\n\t\t}\n\n\t\tconst minColumn = this._projectionData.getMinOutputOffset(outputLineIndex) + 1;\n\t\tconst maxColumn = lineContent.length + 1;\n\t\tconst continuesWithWrappedLine = (outputLineIndex + 1 < this.getViewLineCount());\n\t\tconst startVisibleColumn = (outputLineIndex === 0 ? 0 : lineBreakData.breakOffsetsVisibleColumn[outputLineIndex - 1]);\n\n\t\treturn new ViewLineData(\n\t\t\tlineContent,\n\t\t\tcontinuesWithWrappedLine,\n\t\t\tminColumn,\n\t\t\tmaxColumn,\n\t\t\tstartVisibleColumn,\n\t\t\ttokens,\n\t\t\tinlineDecorations\n\t\t);\n\t}\n\n\tpublic getModelColumnOfViewPosition(outputLineIndex: number, outputColumn: number): number {\n\t\tthis._assertVisible();\n\t\treturn this._projectionData.translateToInputOffset(outputLineIndex, outputColumn - 1) + 1;\n\t}\n\n\tpublic getViewPositionOfModelPosition(deltaLineNumber: number, inputColumn: number, affinity: PositionAffinity = PositionAffinity.None): Position {\n\t\tthis._assertVisible();\n\t\tconst r = this._projectionData.translateToOutputPosition(inputColumn - 1, affinity);\n\t\treturn r.toPosition(deltaLineNumber);\n\t}\n\n\tpublic getViewLineNumberOfModelPosition(deltaLineNumber: number, inputColumn: number): number {\n\t\tthis._assertVisible();\n\t\tconst r = this._projectionData.translateToOutputPosition(inputColumn - 1);\n\t\treturn deltaLineNumber + r.outputLineIndex;\n\t}\n\n\tpublic normalizePosition(outputLineIndex: number, outputPosition: Position, affinity: PositionAffinity): Position {\n\t\tconst baseViewLineNumber = outputPosition.lineNumber - outputLineIndex;\n\t\tconst normalizedOutputPosition = this._projectionData.normalizeOutputPosition(outputLineIndex, outputPosition.column - 1, affinity);\n\t\tconst result = normalizedOutputPosition.toPosition(baseViewLineNumber);\n\t\treturn result;\n\t}\n\n\tpublic getInjectedTextAt(outputLineIndex: number, outputColumn: number): InjectedText | null {\n\t\treturn this._projectionData.getInjectedText(outputLineIndex, outputColumn - 1);\n\t}\n\n\tprivate _assertVisible() {\n\t\tif (!this._isVisible) {\n\t\t\tthrow new Error('Not supported');\n\t\t}\n\t}\n}\n\n/**\n * This projection does not change the model line.\n*/\nclass IdentityModelLineProjection implements IModelLineProjection {\n\tpublic static readonly INSTANCE = new IdentityModelLineProjection();\n\n\tprivate constructor() { }\n\n\tpublic isVisible(): boolean {\n\t\treturn true;\n\t}\n\n\tpublic setVisible(isVisible: boolean): IModelLineProjection {\n\t\tif (isVisible) {\n\t\t\treturn this;\n\t\t}\n\t\treturn HiddenModelLineProjection.INSTANCE;\n\t}\n\n\tpublic getProjectionData(): ModelLineProjectionData | null {\n\t\treturn null;\n\t}\n\n\tpublic getViewLineCount(): number {\n\t\treturn 1;\n\t}\n\n\tpublic getViewLineContent(model: ISimpleModel, modelLineNumber: number, _outputLineIndex: number): string {\n\t\treturn model.getLineContent(modelLineNumber);\n\t}\n\n\tpublic getViewLineLength(model: ISimpleModel, modelLineNumber: number, _outputLineIndex: number): number {\n\t\treturn model.getLineLength(modelLineNumber);\n\t}\n\n\tpublic getViewLineMinColumn(model: ISimpleModel, modelLineNumber: number, _outputLineIndex: number): number {\n\t\treturn model.getLineMinColumn(modelLineNumber);\n\t}\n\n\tpublic getViewLineMaxColumn(model: ISimpleModel, modelLineNumber: number, _outputLineIndex: number): number {\n\t\treturn model.getLineMaxColumn(modelLineNumber);\n\t}\n\n\tpublic getViewLineData(model: ISimpleModel, modelLineNumber: number, _outputLineIndex: number): ViewLineData {\n\t\tconst lineTokens = model.tokenization.getLineTokens(modelLineNumber);\n\t\tconst lineContent = lineTokens.getLineContent();\n\t\treturn new ViewLineData(\n\t\t\tlineContent,\n\t\t\tfalse,\n\t\t\t1,\n\t\t\tlineContent.length + 1,\n\t\t\t0,\n\t\t\tlineTokens.inflate(),\n\t\t\tnull\n\t\t);\n\t}\n\n\tpublic getViewLinesData(model: ISimpleModel, modelLineNumber: number, _fromOuputLineIndex: number, _toOutputLineIndex: number, globalStartIndex: number, needed: boolean[], result: Array<ViewLineData | null>): void {\n\t\tif (!needed[globalStartIndex]) {\n\t\t\tresult[globalStartIndex] = null;\n\t\t\treturn;\n\t\t}\n\t\tresult[globalStartIndex] = this.getViewLineData(model, modelLineNumber, 0);\n\t}\n\n\tpublic getModelColumnOfViewPosition(_outputLineIndex: number, outputColumn: number): number {\n\t\treturn outputColumn;\n\t}\n\n\tpublic getViewPositionOfModelPosition(deltaLineNumber: number, inputColumn: number): Position {\n\t\treturn new Position(deltaLineNumber, inputColumn);\n\t}\n\n\tpublic getViewLineNumberOfModelPosition(deltaLineNumber: number, _inputColumn: number): number {\n\t\treturn deltaLineNumber;\n\t}\n\n\tpublic normalizePosition(outputLineIndex: number, outputPosition: Position, affinity: PositionAffinity): Position {\n\t\treturn outputPosition;\n\t}\n\n\tpublic getInjectedTextAt(_outputLineIndex: number, _outputColumn: number): InjectedText | null {\n\t\treturn null;\n\t}\n}\n\n/**\n * This projection hides the model line.\n */\nclass HiddenModelLineProjection implements IModelLineProjection {\n\tpublic static readonly INSTANCE = new HiddenModelLineProjection();\n\n\tprivate constructor() { }\n\n\tpublic isVisible(): boolean {\n\t\treturn false;\n\t}\n\n\tpublic setVisible(isVisible: boolean): IModelLineProjection {\n\t\tif (!isVisible) {\n\t\t\treturn this;\n\t\t}\n\t\treturn IdentityModelLineProjection.INSTANCE;\n\t}\n\n\tpublic getProjectionData(): ModelLineProjectionData | null {\n\t\treturn null;\n\t}\n\n\tpublic getViewLineCount(): number {\n\t\treturn 0;\n\t}\n\n\tpublic getViewLineContent(_model: ISimpleModel, _modelLineNumber: number, _outputLineIndex: number): string {\n\t\tthrow new Error('Not supported');\n\t}\n\n\tpublic getViewLineLength(_model: ISimpleModel, _modelLineNumber: number, _outputLineIndex: number): number {\n\t\tthrow new Error('Not supported');\n\t}\n\n\tpublic getViewLineMinColumn(_model: ISimpleModel, _modelLineNumber: number, _outputLineIndex: number): number {\n\t\tthrow new Error('Not supported');\n\t}\n\n\tpublic getViewLineMaxColumn(_model: ISimpleModel, _modelLineNumber: number, _outputLineIndex: number): number {\n\t\tthrow new Error('Not supported');\n\t}\n\n\tpublic getViewLineData(_model: ISimpleModel, _modelLineNumber: number, _outputLineIndex: number): ViewLineData {\n\t\tthrow new Error('Not supported');\n\t}\n\n\tpublic getViewLinesData(_model: ISimpleModel, _modelLineNumber: number, _fromOuputLineIndex: number, _toOutputLineIndex: number, _globalStartIndex: number, _needed: boolean[], _result: ViewLineData[]): void {\n\t\tthrow new Error('Not supported');\n\t}\n\n\tpublic getModelColumnOfViewPosition(_outputLineIndex: number, _outputColumn: number): number {\n\t\tthrow new Error('Not supported');\n\t}\n\n\tpublic getViewPositionOfModelPosition(_deltaLineNumber: number, _inputColumn: number): Position {\n\t\tthrow new Error('Not supported');\n\t}\n\n\tpublic getViewLineNumberOfModelPosition(_deltaLineNumber: number, _inputColumn: number): number {\n\t\tthrow new Error('Not supported');\n\t}\n\n\tpublic normalizePosition(outputLineIndex: number, outputPosition: Position, affinity: PositionAffinity): Position {\n\t\tthrow new Error('Not supported');\n\t}\n\n\tpublic getInjectedTextAt(_outputLineIndex: number, _outputColumn: number): InjectedText | null {\n\t\tthrow new Error('Not supported');\n\t}\n}\n\nconst _spaces: string[] = [''];\nfunction spaces(count: number): string {\n\tif (count >= _spaces.length) {\n\t\tfor (let i = 1; i <= count; i++) {\n\t\t\t_spaces[i] = _makeSpaces(i);\n\t\t}\n\t}\n\treturn _spaces[count];\n}\n\nfunction _makeSpaces(count: number): string {\n\treturn new Array(count + 1).join(' ');\n}\n"],
  "mappings": ";;AAKA,SAAS,kBAAkB;AAC3B,SAAS,gBAAgB;AACzB,SAAS,cAAc;AACvB,SAAS,qBAAqB,YAAY,wBAAwB;AAClE,SAAS,wBAAwB;AACjC,SAAS,cAAc,+BAA+B;AACtD,SAAS,4BAA4B,oBAAoB;AAsClD,SAAS,0BAA0B,eAA+C,WAA0C;AAClI,MAAI,kBAAkB,MAAM;AAE3B,QAAI,WAAW;AACd,aAAO,4BAA4B;AAAA,IACpC;AACA,WAAO,0BAA0B;AAAA,EAClC,OAAO;AACN,WAAO,IAAI,oBAAoB,eAAe,SAAS;AAAA,EACxD;AACD;AAVgB;AAiBhB,MAAM,oBAAoD;AAAA,EAlE1D,OAkE0D;AAAA;AAAA;AAAA,EACxC;AAAA,EACT;AAAA,EAER,YAAY,eAAwC,WAAoB;AACvE,SAAK,kBAAkB;AACvB,SAAK,aAAa;AAAA,EACnB;AAAA,EAEO,YAAqB;AAC3B,WAAO,KAAK;AAAA,EACb;AAAA,EAEO,WAAW,WAA0C;AAC3D,SAAK,aAAa;AAClB,WAAO;AAAA,EACR;AAAA,EAEO,oBAAoD;AAC1D,WAAO,KAAK;AAAA,EACb;AAAA,EAEO,mBAA2B;AACjC,QAAI,CAAC,KAAK,YAAY;AACrB,aAAO;AAAA,IACR;AACA,WAAO,KAAK,gBAAgB,mBAAmB;AAAA,EAChD;AAAA,EAEO,mBAAmB,OAAqB,iBAAyB,iBAAiC;AACxG,SAAK,eAAe;AAEpB,UAAM,mCAAmC,kBAAkB,IAAI,KAAK,gBAAgB,aAAa,kBAAkB,CAAC,IAAI;AACxH,UAAM,iCAAiC,KAAK,gBAAgB,aAAa,eAAe;AAExF,QAAI;AACJ,QAAI,KAAK,gBAAgB,qBAAqB,MAAM;AACnD,YAAM,gBAAgB,KAAK,gBAAgB,iBAAiB;AAAA,QAC3D,CAAC,QAAQ,QAAQ,IAAI;AAAA,UACpB;AAAA,UACA;AAAA,UACA,SAAS;AAAA,UACT,KAAK,gBAAgB,iBAAkB,GAAG;AAAA,UAC1C;AAAA,QACD;AAAA,MACD;AACA,YAAM,qBAAqB,iBAAiB;AAAA,QAC3C,MAAM,eAAe,eAAe;AAAA,QACpC;AAAA,MACD;AACA,UAAI,mBAAmB,UAAU,kCAAkC,8BAA8B;AAAA,IAClG,OAAO;AACN,UAAI,MAAM,gBAAgB;AAAA,QACzB,iBAAiB;AAAA,QACjB,aAAa,mCAAmC;AAAA,QAChD,eAAe;AAAA,QACf,WAAW,iCAAiC;AAAA,MAC7C,CAAC;AAAA,IACF;AAEA,QAAI,kBAAkB,GAAG;AACxB,UAAI,OAAO,KAAK,gBAAgB,uBAAuB,IAAI;AAAA,IAC5D;AAEA,WAAO;AAAA,EACR;AAAA,EAEO,kBAAkB,OAAqB,iBAAyB,iBAAiC;AACvG,SAAK,eAAe;AACpB,WAAO,KAAK,gBAAgB,cAAc,eAAe;AAAA,EAC1D;AAAA,EAEO,qBAAqB,QAAoB,kBAA0B,iBAAiC;AAC1G,SAAK,eAAe;AACpB,WAAO,KAAK,gBAAgB,mBAAmB,eAAe,IAAI;AAAA,EACnE;AAAA,EAEO,qBAAqB,OAAqB,iBAAyB,iBAAiC;AAC1G,SAAK,eAAe;AACpB,WAAO,KAAK,gBAAgB,mBAAmB,eAAe,IAAI;AAAA,EACnE;AAAA;AAAA;AAAA;AAAA,EAKO,gBAAgB,OAAqB,iBAAyB,iBAAuC;AAC3G,UAAM,MAAM,IAAI,MAAoB;AACpC,SAAK,iBAAiB,OAAO,iBAAiB,iBAAiB,GAAG,GAAG,CAAC,IAAI,GAAG,GAAG;AAChF,WAAO,IAAI,CAAC;AAAA,EACb;AAAA,EAEO,iBAAiB,OAAqB,iBAAyB,eAAuB,WAAmB,kBAA0B,QAAmB,QAA0C;AACtM,SAAK,eAAe;AAEpB,UAAM,gBAAgB,KAAK;AAE3B,UAAM,mBAAmB,cAAc;AACvC,UAAM,mBAAmB,cAAc;AAEvC,QAAI,iCAAwE;AAE5E,QAAI,kBAAkB;AACrB,uCAAiC,CAAC;AAClC,UAAI,gCAAgC;AACpC,UAAI,wBAAwB;AAE5B,eAAS,kBAAkB,GAAG,kBAAkB,cAAc,mBAAmB,GAAG,mBAAmB;AACtG,cAAM,oBAAoB,IAAI,MAAkC;AAChE,uCAA+B,eAAe,IAAI;AAElD,cAAM,uCAAuC,kBAAkB,IAAI,cAAc,aAAa,kBAAkB,CAAC,IAAI;AACrH,cAAM,qCAAqC,cAAc,aAAa,eAAe;AAErF,eAAO,wBAAwB,iBAAiB,QAAQ;AACvD,gBAAM,SAAS,iBAAkB,qBAAqB,EAAE,QAAQ;AAChE,gBAAM,+CAA+C,iBAAiB,qBAAqB,IAAI;AAC/F,gBAAM,6CAA6C,+CAA+C;AAElG,cAAI,+CAA+C,oCAAoC;AAEtF;AAAA,UACD;AAEA,cAAI,uCAAuC,4CAA4C;AAEtF,kBAAM,UAAU,iBAAkB,qBAAqB;AACvD,gBAAI,QAAQ,iBAAiB;AAC5B,oBAAM,SAAU,kBAAkB,IAAI,cAAc,0BAA0B;AAC9E,oBAAM,QAAQ,SAAS,KAAK,IAAI,+CAA+C,sCAAsC,CAAC;AACtH,oBAAM,MAAM,SAAS,KAAK,IAAI,6CAA6C,sCAAsC,qCAAqC,oCAAoC;AAC1L,kBAAI,UAAU,KAAK;AAClB,kCAAkB,KAAK,IAAI,2BAA2B,OAAO,KAAK,QAAQ,iBAAiB,QAAQ,mCAAoC,CAAC;AAAA,cACzI;AAAA,YACD;AAAA,UACD;AAEA,cAAI,8CAA8C,oCAAoC;AACrF,6CAAiC;AACjC;AAAA,UACD,OAAO;AAEN;AAAA,UACD;AAAA,QACD;AAAA,MACD;AAAA,IACD;AAEA,QAAI;AACJ,QAAI,kBAAkB;AACrB,YAAM,iBAA4E,CAAC;AAEnF,eAAS,MAAM,GAAG,MAAM,iBAAiB,QAAQ,OAAO;AACvD,cAAM,SAAS,iBAAiB,GAAG;AACnC,cAAM,SAAS,iBAAkB,GAAG,EAAE;AACtC,YAAI,QAAQ;AACX,iBAAO,QAAQ,CAAC,OAAO,SAAS;AAC/B,2BAAe,KAAK;AAAA,cACnB;AAAA,cACA,MAAM,MAAM,UAAU,iBAAkB,GAAG,EAAE,OAAO;AAAA,cACpD,eAAe,KAAK;AAAA,YACrB,CAAC;AAAA,UACF,CAAC;AAAA,QACF,OAAO;AACN,yBAAe,KAAK;AAAA,YACnB;AAAA,YACA,MAAM,iBAAkB,GAAG,EAAE;AAAA,YAC7B,eAAe,WAAW;AAAA,UAC3B,CAAC;AAAA,QACF;AAAA,MACD;AAEA,2BAAqB,MAAM,aAAa,cAAc,eAAe,EAAE,aAAa,cAAc;AAAA,IACnG,OAAO;AACN,2BAAqB,MAAM,aAAa,cAAc,eAAe;AAAA,IACtE;AAEA,aAAS,kBAAkB,eAAe,kBAAkB,gBAAgB,WAAW,mBAAmB;AACzG,YAAM,cAAc,mBAAmB,kBAAkB;AACzD,UAAI,CAAC,OAAO,WAAW,GAAG;AACzB,eAAO,WAAW,IAAI;AACtB;AAAA,MACD;AACA,aAAO,WAAW,IAAI,KAAK,iBAAiB,oBAAoB,iCAAiC,+BAA+B,eAAe,IAAI,MAAM,eAAe;AAAA,IACzK;AAAA,EACD;AAAA,EAEQ,iBAAiB,oBAAgC,mBAAwD,iBAAuC;AACvJ,SAAK,eAAe;AACpB,UAAM,gBAAgB,KAAK;AAC3B,UAAM,kBAAmB,kBAAkB,IAAI,cAAc,0BAA0B;AAEvF,UAAM,uCAAuC,kBAAkB,IAAI,cAAc,aAAa,kBAAkB,CAAC,IAAI;AACrH,UAAM,qCAAqC,cAAc,aAAa,eAAe;AACrF,UAAM,SAAS,mBAAmB,gBAAgB,sCAAsC,oCAAoC,eAAe;AAE3I,QAAI,cAAc,OAAO,eAAe;AACxC,QAAI,kBAAkB,GAAG;AACxB,oBAAc,OAAO,cAAc,uBAAuB,IAAI;AAAA,IAC/D;AAEA,UAAM,YAAY,KAAK,gBAAgB,mBAAmB,eAAe,IAAI;AAC7E,UAAM,YAAY,YAAY,SAAS;AACvC,UAAM,2BAA4B,kBAAkB,IAAI,KAAK,iBAAiB;AAC9E,UAAM,qBAAsB,oBAAoB,IAAI,IAAI,cAAc,0BAA0B,kBAAkB,CAAC;AAEnH,WAAO,IAAI;AAAA,MACV;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACD;AAAA,EACD;AAAA,EAEO,6BAA6B,iBAAyB,cAA8B;AAC1F,SAAK,eAAe;AACpB,WAAO,KAAK,gBAAgB,uBAAuB,iBAAiB,eAAe,CAAC,IAAI;AAAA,EACzF;AAAA,EAEO,+BAA+B,iBAAyB,aAAqB,WAA6B,iBAAiB,MAAgB;AACjJ,SAAK,eAAe;AACpB,UAAM,IAAI,KAAK,gBAAgB,0BAA0B,cAAc,GAAG,QAAQ;AAClF,WAAO,EAAE,WAAW,eAAe;AAAA,EACpC;AAAA,EAEO,iCAAiC,iBAAyB,aAA6B;AAC7F,SAAK,eAAe;AACpB,UAAM,IAAI,KAAK,gBAAgB,0BAA0B,cAAc,CAAC;AACxE,WAAO,kBAAkB,EAAE;AAAA,EAC5B;AAAA,EAEO,kBAAkB,iBAAyB,gBAA0B,UAAsC;AACjH,UAAM,qBAAqB,eAAe,aAAa;AACvD,UAAM,2BAA2B,KAAK,gBAAgB,wBAAwB,iBAAiB,eAAe,SAAS,GAAG,QAAQ;AAClI,UAAM,SAAS,yBAAyB,WAAW,kBAAkB;AACrE,WAAO;AAAA,EACR;AAAA,EAEO,kBAAkB,iBAAyB,cAA2C;AAC5F,WAAO,KAAK,gBAAgB,gBAAgB,iBAAiB,eAAe,CAAC;AAAA,EAC9E;AAAA,EAEQ,iBAAiB;AACxB,QAAI,CAAC,KAAK,YAAY;AACrB,YAAM,IAAI,MAAM,eAAe;AAAA,IAChC;AAAA,EACD;AACD;AAKA,MAAM,4BAA4D;AAAA,EAhUlE,OAgUkE;AAAA;AAAA;AAAA,EACjE,OAAuB,WAAW,IAAI,4BAA4B;AAAA,EAE1D,cAAc;AAAA,EAAE;AAAA,EAEjB,YAAqB;AAC3B,WAAO;AAAA,EACR;AAAA,EAEO,WAAW,WAA0C;AAC3D,QAAI,WAAW;AACd,aAAO;AAAA,IACR;AACA,WAAO,0BAA0B;AAAA,EAClC;AAAA,EAEO,oBAAoD;AAC1D,WAAO;AAAA,EACR;AAAA,EAEO,mBAA2B;AACjC,WAAO;AAAA,EACR;AAAA,EAEO,mBAAmB,OAAqB,iBAAyB,kBAAkC;AACzG,WAAO,MAAM,eAAe,eAAe;AAAA,EAC5C;AAAA,EAEO,kBAAkB,OAAqB,iBAAyB,kBAAkC;AACxG,WAAO,MAAM,cAAc,eAAe;AAAA,EAC3C;AAAA,EAEO,qBAAqB,OAAqB,iBAAyB,kBAAkC;AAC3G,WAAO,MAAM,iBAAiB,eAAe;AAAA,EAC9C;AAAA,EAEO,qBAAqB,OAAqB,iBAAyB,kBAAkC;AAC3G,WAAO,MAAM,iBAAiB,eAAe;AAAA,EAC9C;AAAA,EAEO,gBAAgB,OAAqB,iBAAyB,kBAAwC;AAC5G,UAAM,aAAa,MAAM,aAAa,cAAc,eAAe;AACnE,UAAM,cAAc,WAAW,eAAe;AAC9C,WAAO,IAAI;AAAA,MACV;AAAA,MACA;AAAA,MACA;AAAA,MACA,YAAY,SAAS;AAAA,MACrB;AAAA,MACA,WAAW,QAAQ;AAAA,MACnB;AAAA,IACD;AAAA,EACD;AAAA,EAEO,iBAAiB,OAAqB,iBAAyB,qBAA6B,oBAA4B,kBAA0B,QAAmB,QAA0C;AACrN,QAAI,CAAC,OAAO,gBAAgB,GAAG;AAC9B,aAAO,gBAAgB,IAAI;AAC3B;AAAA,IACD;AACA,WAAO,gBAAgB,IAAI,KAAK,gBAAgB,OAAO,iBAAiB,CAAC;AAAA,EAC1E;AAAA,EAEO,6BAA6B,kBAA0B,cAA8B;AAC3F,WAAO;AAAA,EACR;AAAA,EAEO,+BAA+B,iBAAyB,aAA+B;AAC7F,WAAO,IAAI,SAAS,iBAAiB,WAAW;AAAA,EACjD;AAAA,EAEO,iCAAiC,iBAAyB,cAA8B;AAC9F,WAAO;AAAA,EACR;AAAA,EAEO,kBAAkB,iBAAyB,gBAA0B,UAAsC;AACjH,WAAO;AAAA,EACR;AAAA,EAEO,kBAAkB,kBAA0B,eAA4C;AAC9F,WAAO;AAAA,EACR;AACD;AAKA,MAAM,0BAA0D;AAAA,EAtZhE,OAsZgE;AAAA;AAAA;AAAA,EAC/D,OAAuB,WAAW,IAAI,0BAA0B;AAAA,EAExD,cAAc;AAAA,EAAE;AAAA,EAEjB,YAAqB;AAC3B,WAAO;AAAA,EACR;AAAA,EAEO,WAAW,WAA0C;AAC3D,QAAI,CAAC,WAAW;AACf,aAAO;AAAA,IACR;AACA,WAAO,4BAA4B;AAAA,EACpC;AAAA,EAEO,oBAAoD;AAC1D,WAAO;AAAA,EACR;AAAA,EAEO,mBAA2B;AACjC,WAAO;AAAA,EACR;AAAA,EAEO,mBAAmB,QAAsB,kBAA0B,kBAAkC;AAC3G,UAAM,IAAI,MAAM,eAAe;AAAA,EAChC;AAAA,EAEO,kBAAkB,QAAsB,kBAA0B,kBAAkC;AAC1G,UAAM,IAAI,MAAM,eAAe;AAAA,EAChC;AAAA,EAEO,qBAAqB,QAAsB,kBAA0B,kBAAkC;AAC7G,UAAM,IAAI,MAAM,eAAe;AAAA,EAChC;AAAA,EAEO,qBAAqB,QAAsB,kBAA0B,kBAAkC;AAC7G,UAAM,IAAI,MAAM,eAAe;AAAA,EAChC;AAAA,EAEO,gBAAgB,QAAsB,kBAA0B,kBAAwC;AAC9G,UAAM,IAAI,MAAM,eAAe;AAAA,EAChC;AAAA,EAEO,iBAAiB,QAAsB,kBAA0B,qBAA6B,oBAA4B,mBAA2B,SAAoB,SAA+B;AAC9M,UAAM,IAAI,MAAM,eAAe;AAAA,EAChC;AAAA,EAEO,6BAA6B,kBAA0B,eAA+B;AAC5F,UAAM,IAAI,MAAM,eAAe;AAAA,EAChC;AAAA,EAEO,+BAA+B,kBAA0B,cAAgC;AAC/F,UAAM,IAAI,MAAM,eAAe;AAAA,EAChC;AAAA,EAEO,iCAAiC,kBAA0B,cAA8B;AAC/F,UAAM,IAAI,MAAM,eAAe;AAAA,EAChC;AAAA,EAEO,kBAAkB,iBAAyB,gBAA0B,UAAsC;AACjH,UAAM,IAAI,MAAM,eAAe;AAAA,EAChC;AAAA,EAEO,kBAAkB,kBAA0B,eAA4C;AAC9F,UAAM,IAAI,MAAM,eAAe;AAAA,EAChC;AACD;AAEA,MAAM,UAAoB,CAAC,EAAE;AAC7B,SAAS,OAAO,OAAuB;AACtC,MAAI,SAAS,QAAQ,QAAQ;AAC5B,aAAS,IAAI,GAAG,KAAK,OAAO,KAAK;AAChC,cAAQ,CAAC,IAAI,YAAY,CAAC;AAAA,IAC3B;AAAA,EACD;AACA,SAAO,QAAQ,KAAK;AACrB;AAPS;AAST,SAAS,YAAY,OAAuB;AAC3C,SAAO,IAAI,MAAM,QAAQ,CAAC,EAAE,KAAK,GAAG;AACrC;AAFS;",
  "names": []
}
