{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/common/viewModel/modelLineProjection.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Position } from \"../core/position.js\";\nimport type { IRange } from \"../core/range.js\";\nimport {\n\ttype EndOfLinePreference,\n\ttype ITextModel,\n\tPositionAffinity,\n} from \"../model.js\";\nimport type {\n\tInjectedText,\n\tModelLineProjectionData,\n} from \"../modelLineProjectionData.js\";\nimport { LineInjectedText } from \"../textModelEvents.js\";\nimport { LineTokens } from \"../tokens/lineTokens.js\";\nimport { SingleLineInlineDecoration, ViewLineData } from \"../viewModel.js\";\n\nexport interface IModelLineProjection {\n\tisVisible(): boolean;\n\n\t/**\n\t * This invalidates the current instance (potentially reuses and returns it again).\n\t */\n\tsetVisible(isVisible: boolean): IModelLineProjection;\n\n\tgetProjectionData(): ModelLineProjectionData | null;\n\tgetViewLineCount(): number;\n\tgetViewLineContent(\n\t\tmodel: ISimpleModel,\n\t\tmodelLineNumber: number,\n\t\toutputLineIndex: number,\n\t): string;\n\tgetViewLineLength(\n\t\tmodel: ISimpleModel,\n\t\tmodelLineNumber: number,\n\t\toutputLineIndex: number,\n\t): number;\n\tgetViewLineMinColumn(\n\t\tmodel: ISimpleModel,\n\t\tmodelLineNumber: number,\n\t\toutputLineIndex: number,\n\t): number;\n\tgetViewLineMaxColumn(\n\t\tmodel: ISimpleModel,\n\t\tmodelLineNumber: number,\n\t\toutputLineIndex: number,\n\t): number;\n\tgetViewLineData(\n\t\tmodel: ISimpleModel,\n\t\tmodelLineNumber: number,\n\t\toutputLineIndex: number,\n\t): ViewLineData;\n\tgetViewLinesData(\n\t\tmodel: ISimpleModel,\n\t\tmodelLineNumber: number,\n\t\toutputLineIdx: number,\n\t\tlineCount: number,\n\t\tglobalStartIndex: number,\n\t\tneeded: boolean[],\n\t\tresult: Array<ViewLineData | null>,\n\t): void;\n\n\tgetModelColumnOfViewPosition(\n\t\toutputLineIndex: number,\n\t\toutputColumn: number,\n\t): number;\n\tgetViewPositionOfModelPosition(\n\t\tdeltaLineNumber: number,\n\t\tinputColumn: number,\n\t\taffinity?: PositionAffinity,\n\t): Position;\n\tgetViewLineNumberOfModelPosition(\n\t\tdeltaLineNumber: number,\n\t\tinputColumn: number,\n\t): number;\n\tnormalizePosition(\n\t\toutputLineIndex: number,\n\t\toutputPosition: Position,\n\t\taffinity: PositionAffinity,\n\t): Position;\n\n\tgetInjectedTextAt(\n\t\toutputLineIndex: number,\n\t\tcolumn: number,\n\t): InjectedText | null;\n}\n\nexport interface ISimpleModel {\n\ttokenization: {\n\t\tgetLineTokens(lineNumber: number): LineTokens;\n\t};\n\tgetLineContent(lineNumber: number): string;\n\tgetLineLength(lineNumber: number): number;\n\tgetLineMinColumn(lineNumber: number): number;\n\tgetLineMaxColumn(lineNumber: number): number;\n\tgetValueInRange(range: IRange, eol?: EndOfLinePreference): string;\n}\n\nexport function createModelLineProjection(\n\tlineBreakData: ModelLineProjectionData | null,\n\tisVisible: boolean,\n): IModelLineProjection {\n\tif (lineBreakData === null) {\n\t\t// No mapping needed\n\t\tif (isVisible) {\n\t\t\treturn IdentityModelLineProjection.INSTANCE;\n\t\t}\n\t\treturn HiddenModelLineProjection.INSTANCE;\n\t} else {\n\t\treturn new ModelLineProjection(lineBreakData, isVisible);\n\t}\n}\n\n/**\n * This projection is used to\n * * wrap model lines\n * * inject text\n */\nclass ModelLineProjection implements IModelLineProjection {\n\tprivate readonly _projectionData: ModelLineProjectionData;\n\tprivate _isVisible: boolean;\n\n\tconstructor(lineBreakData: ModelLineProjectionData, isVisible: boolean) {\n\t\tthis._projectionData = lineBreakData;\n\t\tthis._isVisible = isVisible;\n\t}\n\n\tpublic isVisible(): boolean {\n\t\treturn this._isVisible;\n\t}\n\n\tpublic setVisible(isVisible: boolean): IModelLineProjection {\n\t\tthis._isVisible = isVisible;\n\t\treturn this;\n\t}\n\n\tpublic getProjectionData(): ModelLineProjectionData | null {\n\t\treturn this._projectionData;\n\t}\n\n\tpublic getViewLineCount(): number {\n\t\tif (!this._isVisible) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this._projectionData.getOutputLineCount();\n\t}\n\n\tpublic getViewLineContent(\n\t\tmodel: ISimpleModel,\n\t\tmodelLineNumber: number,\n\t\toutputLineIndex: number,\n\t): string {\n\t\tthis._assertVisible();\n\n\t\tconst startOffsetInInputWithInjections =\n\t\t\toutputLineIndex > 0\n\t\t\t\t? this._projectionData.breakOffsets[outputLineIndex - 1]\n\t\t\t\t: 0;\n\t\tconst endOffsetInInputWithInjections =\n\t\t\tthis._projectionData.breakOffsets[outputLineIndex];\n\n\t\tlet r: string;\n\t\tif (this._projectionData.injectionOffsets !== null) {\n\t\t\tconst injectedTexts = this._projectionData.injectionOffsets.map(\n\t\t\t\t(offset, idx) =>\n\t\t\t\t\tnew LineInjectedText(\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\toffset + 1,\n\t\t\t\t\t\tthis._projectionData.injectionOptions![idx],\n\t\t\t\t\t\t0,\n\t\t\t\t\t),\n\t\t\t);\n\t\t\tconst lineWithInjections = LineInjectedText.applyInjectedText(\n\t\t\t\tmodel.getLineContent(modelLineNumber),\n\t\t\t\tinjectedTexts,\n\t\t\t);\n\t\t\tr = lineWithInjections.substring(\n\t\t\t\tstartOffsetInInputWithInjections,\n\t\t\t\tendOffsetInInputWithInjections,\n\t\t\t);\n\t\t} else {\n\t\t\tr = model.getValueInRange({\n\t\t\t\tstartLineNumber: modelLineNumber,\n\t\t\t\tstartColumn: startOffsetInInputWithInjections + 1,\n\t\t\t\tendLineNumber: modelLineNumber,\n\t\t\t\tendColumn: endOffsetInInputWithInjections + 1,\n\t\t\t});\n\t\t}\n\n\t\tif (outputLineIndex > 0) {\n\t\t\tr = spaces(this._projectionData.wrappedTextIndentLength) + r;\n\t\t}\n\n\t\treturn r;\n\t}\n\n\tpublic getViewLineLength(\n\t\tmodel: ISimpleModel,\n\t\tmodelLineNumber: number,\n\t\toutputLineIndex: number,\n\t): number {\n\t\tthis._assertVisible();\n\t\treturn this._projectionData.getLineLength(outputLineIndex);\n\t}\n\n\tpublic getViewLineMinColumn(\n\t\t_model: ITextModel,\n\t\t_modelLineNumber: number,\n\t\toutputLineIndex: number,\n\t): number {\n\t\tthis._assertVisible();\n\t\treturn this._projectionData.getMinOutputOffset(outputLineIndex) + 1;\n\t}\n\n\tpublic getViewLineMaxColumn(\n\t\tmodel: ISimpleModel,\n\t\tmodelLineNumber: number,\n\t\toutputLineIndex: number,\n\t): number {\n\t\tthis._assertVisible();\n\t\treturn this._projectionData.getMaxOutputOffset(outputLineIndex) + 1;\n\t}\n\n\t/**\n\t * Try using {@link getViewLinesData} instead.\n\t */\n\tpublic getViewLineData(\n\t\tmodel: ISimpleModel,\n\t\tmodelLineNumber: number,\n\t\toutputLineIndex: number,\n\t): ViewLineData {\n\t\tconst arr = new Array<ViewLineData>();\n\t\tthis.getViewLinesData(\n\t\t\tmodel,\n\t\t\tmodelLineNumber,\n\t\t\toutputLineIndex,\n\t\t\t1,\n\t\t\t0,\n\t\t\t[true],\n\t\t\tarr,\n\t\t);\n\t\treturn arr[0];\n\t}\n\n\tpublic getViewLinesData(\n\t\tmodel: ISimpleModel,\n\t\tmodelLineNumber: number,\n\t\toutputLineIdx: number,\n\t\tlineCount: number,\n\t\tglobalStartIndex: number,\n\t\tneeded: boolean[],\n\t\tresult: Array<ViewLineData | null>,\n\t): void {\n\t\tthis._assertVisible();\n\n\t\tconst lineBreakData = this._projectionData;\n\n\t\tconst injectionOffsets = lineBreakData.injectionOffsets;\n\t\tconst injectionOptions = lineBreakData.injectionOptions;\n\n\t\tlet inlineDecorationsPerOutputLine:\n\t\t\t| SingleLineInlineDecoration[][]\n\t\t\t| null = null;\n\n\t\tif (injectionOffsets) {\n\t\t\tinlineDecorationsPerOutputLine = [];\n\t\t\tlet totalInjectedTextLengthBefore = 0;\n\t\t\tlet currentInjectedOffset = 0;\n\n\t\t\tfor (\n\t\t\t\tlet outputLineIndex = 0;\n\t\t\t\toutputLineIndex < lineBreakData.getOutputLineCount();\n\t\t\t\toutputLineIndex++\n\t\t\t) {\n\t\t\t\tconst inlineDecorations =\n\t\t\t\t\tnew Array<SingleLineInlineDecoration>();\n\t\t\t\tinlineDecorationsPerOutputLine[outputLineIndex] =\n\t\t\t\t\tinlineDecorations;\n\n\t\t\t\tconst lineStartOffsetInInputWithInjections =\n\t\t\t\t\toutputLineIndex > 0\n\t\t\t\t\t\t? lineBreakData.breakOffsets[outputLineIndex - 1]\n\t\t\t\t\t\t: 0;\n\t\t\t\tconst lineEndOffsetInInputWithInjections =\n\t\t\t\t\tlineBreakData.breakOffsets[outputLineIndex];\n\n\t\t\t\twhile (currentInjectedOffset < injectionOffsets.length) {\n\t\t\t\t\tconst length =\n\t\t\t\t\t\tinjectionOptions![currentInjectedOffset].content.length;\n\t\t\t\t\tconst injectedTextStartOffsetInInputWithInjections =\n\t\t\t\t\t\tinjectionOffsets[currentInjectedOffset] +\n\t\t\t\t\t\ttotalInjectedTextLengthBefore;\n\t\t\t\t\tconst injectedTextEndOffsetInInputWithInjections =\n\t\t\t\t\t\tinjectedTextStartOffsetInInputWithInjections + length;\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tinjectedTextStartOffsetInInputWithInjections >\n\t\t\t\t\t\tlineEndOffsetInInputWithInjections\n\t\t\t\t\t) {\n\t\t\t\t\t\t// Injected text only starts in later wrapped lines.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tlineStartOffsetInInputWithInjections <\n\t\t\t\t\t\tinjectedTextEndOffsetInInputWithInjections\n\t\t\t\t\t) {\n\t\t\t\t\t\t// Injected text ends after or in this line (but also starts in or before this line).\n\t\t\t\t\t\tconst options =\n\t\t\t\t\t\t\tinjectionOptions![currentInjectedOffset];\n\t\t\t\t\t\tif (options.inlineClassName) {\n\t\t\t\t\t\t\tconst offset =\n\t\t\t\t\t\t\t\toutputLineIndex > 0\n\t\t\t\t\t\t\t\t\t? lineBreakData.wrappedTextIndentLength\n\t\t\t\t\t\t\t\t\t: 0;\n\t\t\t\t\t\t\tconst start =\n\t\t\t\t\t\t\t\toffset +\n\t\t\t\t\t\t\t\tMath.max(\n\t\t\t\t\t\t\t\t\tinjectedTextStartOffsetInInputWithInjections -\n\t\t\t\t\t\t\t\t\t\tlineStartOffsetInInputWithInjections,\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst end =\n\t\t\t\t\t\t\t\toffset +\n\t\t\t\t\t\t\t\tMath.min(\n\t\t\t\t\t\t\t\t\tinjectedTextEndOffsetInInputWithInjections -\n\t\t\t\t\t\t\t\t\t\tlineStartOffsetInInputWithInjections,\n\t\t\t\t\t\t\t\t\tlineEndOffsetInInputWithInjections -\n\t\t\t\t\t\t\t\t\t\tlineStartOffsetInInputWithInjections,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (start !== end) {\n\t\t\t\t\t\t\t\tinlineDecorations.push(\n\t\t\t\t\t\t\t\t\tnew SingleLineInlineDecoration(\n\t\t\t\t\t\t\t\t\t\tstart,\n\t\t\t\t\t\t\t\t\t\tend,\n\t\t\t\t\t\t\t\t\t\toptions.inlineClassName,\n\t\t\t\t\t\t\t\t\t\toptions.inlineClassNameAffectsLetterSpacing!,\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tinjectedTextEndOffsetInInputWithInjections <=\n\t\t\t\t\t\tlineEndOffsetInInputWithInjections\n\t\t\t\t\t) {\n\t\t\t\t\t\ttotalInjectedTextLengthBefore += length;\n\t\t\t\t\t\tcurrentInjectedOffset++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// injected text breaks into next line, process it again\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet lineWithInjections: LineTokens;\n\t\tif (injectionOffsets) {\n\t\t\tconst tokensToInsert: {\n\t\t\t\toffset: number;\n\t\t\t\ttext: string;\n\t\t\t\ttokenMetadata: number;\n\t\t\t}[] = [];\n\n\t\t\tfor (let idx = 0; idx < injectionOffsets.length; idx++) {\n\t\t\t\tconst offset = injectionOffsets[idx];\n\t\t\t\tconst tokens = injectionOptions![idx].tokens;\n\t\t\t\tif (tokens) {\n\t\t\t\t\ttokens.forEach((range, info) => {\n\t\t\t\t\t\ttokensToInsert.push({\n\t\t\t\t\t\t\toffset,\n\t\t\t\t\t\t\ttext: range.substring(\n\t\t\t\t\t\t\t\tinjectionOptions![idx].content,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\ttokenMetadata: info.metadata,\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\ttokensToInsert.push({\n\t\t\t\t\t\toffset,\n\t\t\t\t\t\ttext: injectionOptions![idx].content,\n\t\t\t\t\t\ttokenMetadata: LineTokens.defaultTokenMetadata,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlineWithInjections = model.tokenization\n\t\t\t\t.getLineTokens(modelLineNumber)\n\t\t\t\t.withInserted(tokensToInsert);\n\t\t} else {\n\t\t\tlineWithInjections =\n\t\t\t\tmodel.tokenization.getLineTokens(modelLineNumber);\n\t\t}\n\n\t\tfor (\n\t\t\tlet outputLineIndex = outputLineIdx;\n\t\t\toutputLineIndex < outputLineIdx + lineCount;\n\t\t\toutputLineIndex++\n\t\t) {\n\t\t\tconst globalIndex =\n\t\t\t\tglobalStartIndex + outputLineIndex - outputLineIdx;\n\t\t\tif (!needed[globalIndex]) {\n\t\t\t\tresult[globalIndex] = null;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tresult[globalIndex] = this._getViewLineData(\n\t\t\t\tlineWithInjections,\n\t\t\t\tinlineDecorationsPerOutputLine\n\t\t\t\t\t? inlineDecorationsPerOutputLine[outputLineIndex]\n\t\t\t\t\t: null,\n\t\t\t\toutputLineIndex,\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate _getViewLineData(\n\t\tlineWithInjections: LineTokens,\n\t\tinlineDecorations: null | SingleLineInlineDecoration[],\n\t\toutputLineIndex: number,\n\t): ViewLineData {\n\t\tthis._assertVisible();\n\t\tconst lineBreakData = this._projectionData;\n\t\tconst deltaStartIndex =\n\t\t\toutputLineIndex > 0 ? lineBreakData.wrappedTextIndentLength : 0;\n\n\t\tconst lineStartOffsetInInputWithInjections =\n\t\t\toutputLineIndex > 0\n\t\t\t\t? lineBreakData.breakOffsets[outputLineIndex - 1]\n\t\t\t\t: 0;\n\t\tconst lineEndOffsetInInputWithInjections =\n\t\t\tlineBreakData.breakOffsets[outputLineIndex];\n\t\tconst tokens = lineWithInjections.sliceAndInflate(\n\t\t\tlineStartOffsetInInputWithInjections,\n\t\t\tlineEndOffsetInInputWithInjections,\n\t\t\tdeltaStartIndex,\n\t\t);\n\n\t\tlet lineContent = tokens.getLineContent();\n\t\tif (outputLineIndex > 0) {\n\t\t\tlineContent =\n\t\t\t\tspaces(lineBreakData.wrappedTextIndentLength) + lineContent;\n\t\t}\n\n\t\tconst minColumn =\n\t\t\tthis._projectionData.getMinOutputOffset(outputLineIndex) + 1;\n\t\tconst maxColumn = lineContent.length + 1;\n\t\tconst continuesWithWrappedLine =\n\t\t\toutputLineIndex + 1 < this.getViewLineCount();\n\t\tconst startVisibleColumn =\n\t\t\toutputLineIndex === 0\n\t\t\t\t? 0\n\t\t\t\t: lineBreakData.breakOffsetsVisibleColumn[outputLineIndex - 1];\n\n\t\treturn new ViewLineData(\n\t\t\tlineContent,\n\t\t\tcontinuesWithWrappedLine,\n\t\t\tminColumn,\n\t\t\tmaxColumn,\n\t\t\tstartVisibleColumn,\n\t\t\ttokens,\n\t\t\tinlineDecorations,\n\t\t);\n\t}\n\n\tpublic getModelColumnOfViewPosition(\n\t\toutputLineIndex: number,\n\t\toutputColumn: number,\n\t): number {\n\t\tthis._assertVisible();\n\t\treturn (\n\t\t\tthis._projectionData.translateToInputOffset(\n\t\t\t\toutputLineIndex,\n\t\t\t\toutputColumn - 1,\n\t\t\t) + 1\n\t\t);\n\t}\n\n\tpublic getViewPositionOfModelPosition(\n\t\tdeltaLineNumber: number,\n\t\tinputColumn: number,\n\t\taffinity: PositionAffinity = PositionAffinity.None,\n\t): Position {\n\t\tthis._assertVisible();\n\t\tconst r = this._projectionData.translateToOutputPosition(\n\t\t\tinputColumn - 1,\n\t\t\taffinity,\n\t\t);\n\t\treturn r.toPosition(deltaLineNumber);\n\t}\n\n\tpublic getViewLineNumberOfModelPosition(\n\t\tdeltaLineNumber: number,\n\t\tinputColumn: number,\n\t): number {\n\t\tthis._assertVisible();\n\t\tconst r = this._projectionData.translateToOutputPosition(\n\t\t\tinputColumn - 1,\n\t\t);\n\t\treturn deltaLineNumber + r.outputLineIndex;\n\t}\n\n\tpublic normalizePosition(\n\t\toutputLineIndex: number,\n\t\toutputPosition: Position,\n\t\taffinity: PositionAffinity,\n\t): Position {\n\t\tconst baseViewLineNumber = outputPosition.lineNumber - outputLineIndex;\n\t\tconst normalizedOutputPosition =\n\t\t\tthis._projectionData.normalizeOutputPosition(\n\t\t\t\toutputLineIndex,\n\t\t\t\toutputPosition.column - 1,\n\t\t\t\taffinity,\n\t\t\t);\n\t\tconst result = normalizedOutputPosition.toPosition(baseViewLineNumber);\n\t\treturn result;\n\t}\n\n\tpublic getInjectedTextAt(\n\t\toutputLineIndex: number,\n\t\toutputColumn: number,\n\t): InjectedText | null {\n\t\treturn this._projectionData.getInjectedText(\n\t\t\toutputLineIndex,\n\t\t\toutputColumn - 1,\n\t\t);\n\t}\n\n\tprivate _assertVisible() {\n\t\tif (!this._isVisible) {\n\t\t\tthrow new Error(\"Not supported\");\n\t\t}\n\t}\n}\n\n/**\n * This projection does not change the model line.\n */\nclass IdentityModelLineProjection implements IModelLineProjection {\n\tpublic static readonly INSTANCE = new IdentityModelLineProjection();\n\n\tprivate constructor() {}\n\n\tpublic isVisible(): boolean {\n\t\treturn true;\n\t}\n\n\tpublic setVisible(isVisible: boolean): IModelLineProjection {\n\t\tif (isVisible) {\n\t\t\treturn this;\n\t\t}\n\t\treturn HiddenModelLineProjection.INSTANCE;\n\t}\n\n\tpublic getProjectionData(): ModelLineProjectionData | null {\n\t\treturn null;\n\t}\n\n\tpublic getViewLineCount(): number {\n\t\treturn 1;\n\t}\n\n\tpublic getViewLineContent(\n\t\tmodel: ISimpleModel,\n\t\tmodelLineNumber: number,\n\t\t_outputLineIndex: number,\n\t): string {\n\t\treturn model.getLineContent(modelLineNumber);\n\t}\n\n\tpublic getViewLineLength(\n\t\tmodel: ISimpleModel,\n\t\tmodelLineNumber: number,\n\t\t_outputLineIndex: number,\n\t): number {\n\t\treturn model.getLineLength(modelLineNumber);\n\t}\n\n\tpublic getViewLineMinColumn(\n\t\tmodel: ISimpleModel,\n\t\tmodelLineNumber: number,\n\t\t_outputLineIndex: number,\n\t): number {\n\t\treturn model.getLineMinColumn(modelLineNumber);\n\t}\n\n\tpublic getViewLineMaxColumn(\n\t\tmodel: ISimpleModel,\n\t\tmodelLineNumber: number,\n\t\t_outputLineIndex: number,\n\t): number {\n\t\treturn model.getLineMaxColumn(modelLineNumber);\n\t}\n\n\tpublic getViewLineData(\n\t\tmodel: ISimpleModel,\n\t\tmodelLineNumber: number,\n\t\t_outputLineIndex: number,\n\t): ViewLineData {\n\t\tconst lineTokens = model.tokenization.getLineTokens(modelLineNumber);\n\t\tconst lineContent = lineTokens.getLineContent();\n\t\treturn new ViewLineData(\n\t\t\tlineContent,\n\t\t\tfalse,\n\t\t\t1,\n\t\t\tlineContent.length + 1,\n\t\t\t0,\n\t\t\tlineTokens.inflate(),\n\t\t\tnull,\n\t\t);\n\t}\n\n\tpublic getViewLinesData(\n\t\tmodel: ISimpleModel,\n\t\tmodelLineNumber: number,\n\t\t_fromOuputLineIndex: number,\n\t\t_toOutputLineIndex: number,\n\t\tglobalStartIndex: number,\n\t\tneeded: boolean[],\n\t\tresult: Array<ViewLineData | null>,\n\t): void {\n\t\tif (!needed[globalStartIndex]) {\n\t\t\tresult[globalStartIndex] = null;\n\t\t\treturn;\n\t\t}\n\t\tresult[globalStartIndex] = this.getViewLineData(\n\t\t\tmodel,\n\t\t\tmodelLineNumber,\n\t\t\t0,\n\t\t);\n\t}\n\n\tpublic getModelColumnOfViewPosition(\n\t\t_outputLineIndex: number,\n\t\toutputColumn: number,\n\t): number {\n\t\treturn outputColumn;\n\t}\n\n\tpublic getViewPositionOfModelPosition(\n\t\tdeltaLineNumber: number,\n\t\tinputColumn: number,\n\t): Position {\n\t\treturn new Position(deltaLineNumber, inputColumn);\n\t}\n\n\tpublic getViewLineNumberOfModelPosition(\n\t\tdeltaLineNumber: number,\n\t\t_inputColumn: number,\n\t): number {\n\t\treturn deltaLineNumber;\n\t}\n\n\tpublic normalizePosition(\n\t\toutputLineIndex: number,\n\t\toutputPosition: Position,\n\t\taffinity: PositionAffinity,\n\t): Position {\n\t\treturn outputPosition;\n\t}\n\n\tpublic getInjectedTextAt(\n\t\t_outputLineIndex: number,\n\t\t_outputColumn: number,\n\t): InjectedText | null {\n\t\treturn null;\n\t}\n}\n\n/**\n * This projection hides the model line.\n */\nclass HiddenModelLineProjection implements IModelLineProjection {\n\tpublic static readonly INSTANCE = new HiddenModelLineProjection();\n\n\tprivate constructor() {}\n\n\tpublic isVisible(): boolean {\n\t\treturn false;\n\t}\n\n\tpublic setVisible(isVisible: boolean): IModelLineProjection {\n\t\tif (!isVisible) {\n\t\t\treturn this;\n\t\t}\n\t\treturn IdentityModelLineProjection.INSTANCE;\n\t}\n\n\tpublic getProjectionData(): ModelLineProjectionData | null {\n\t\treturn null;\n\t}\n\n\tpublic getViewLineCount(): number {\n\t\treturn 0;\n\t}\n\n\tpublic getViewLineContent(\n\t\t_model: ISimpleModel,\n\t\t_modelLineNumber: number,\n\t\t_outputLineIndex: number,\n\t): string {\n\t\tthrow new Error(\"Not supported\");\n\t}\n\n\tpublic getViewLineLength(\n\t\t_model: ISimpleModel,\n\t\t_modelLineNumber: number,\n\t\t_outputLineIndex: number,\n\t): number {\n\t\tthrow new Error(\"Not supported\");\n\t}\n\n\tpublic getViewLineMinColumn(\n\t\t_model: ISimpleModel,\n\t\t_modelLineNumber: number,\n\t\t_outputLineIndex: number,\n\t): number {\n\t\tthrow new Error(\"Not supported\");\n\t}\n\n\tpublic getViewLineMaxColumn(\n\t\t_model: ISimpleModel,\n\t\t_modelLineNumber: number,\n\t\t_outputLineIndex: number,\n\t): number {\n\t\tthrow new Error(\"Not supported\");\n\t}\n\n\tpublic getViewLineData(\n\t\t_model: ISimpleModel,\n\t\t_modelLineNumber: number,\n\t\t_outputLineIndex: number,\n\t): ViewLineData {\n\t\tthrow new Error(\"Not supported\");\n\t}\n\n\tpublic getViewLinesData(\n\t\t_model: ISimpleModel,\n\t\t_modelLineNumber: number,\n\t\t_fromOuputLineIndex: number,\n\t\t_toOutputLineIndex: number,\n\t\t_globalStartIndex: number,\n\t\t_needed: boolean[],\n\t\t_result: ViewLineData[],\n\t): void {\n\t\tthrow new Error(\"Not supported\");\n\t}\n\n\tpublic getModelColumnOfViewPosition(\n\t\t_outputLineIndex: number,\n\t\t_outputColumn: number,\n\t): number {\n\t\tthrow new Error(\"Not supported\");\n\t}\n\n\tpublic getViewPositionOfModelPosition(\n\t\t_deltaLineNumber: number,\n\t\t_inputColumn: number,\n\t): Position {\n\t\tthrow new Error(\"Not supported\");\n\t}\n\n\tpublic getViewLineNumberOfModelPosition(\n\t\t_deltaLineNumber: number,\n\t\t_inputColumn: number,\n\t): number {\n\t\tthrow new Error(\"Not supported\");\n\t}\n\n\tpublic normalizePosition(\n\t\toutputLineIndex: number,\n\t\toutputPosition: Position,\n\t\taffinity: PositionAffinity,\n\t): Position {\n\t\tthrow new Error(\"Not supported\");\n\t}\n\n\tpublic getInjectedTextAt(\n\t\t_outputLineIndex: number,\n\t\t_outputColumn: number,\n\t): InjectedText | null {\n\t\tthrow new Error(\"Not supported\");\n\t}\n}\n\nconst _spaces: string[] = [\"\"];\nfunction spaces(count: number): string {\n\tif (count >= _spaces.length) {\n\t\tfor (let i = 1; i <= count; i++) {\n\t\t\t_spaces[i] = _makeSpaces(i);\n\t\t}\n\t}\n\treturn _spaces[count];\n}\n\nfunction _makeSpaces(count: number): string {\n\treturn new Array(count + 1).join(\" \");\n}\n"],
  "mappings": "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",
  "names": []
}
