import{Position as S}from"../../../../vs/editor/common/core/position.js";import"../../../../vs/editor/common/core/range.js";import{PositionAffinity as k}from"../../../../vs/editor/common/model.js";import"../../../../vs/editor/common/modelLineProjectionData.js";import{LineInjectedText as O}from"../../../../vs/editor/common/textModelEvents.js";import{LineTokens as A}from"../../../../vs/editor/common/tokens/lineTokens.js";import{SingleLineInlineDecoration as E,ViewLineData as x}from"../../../../vs/editor/common/viewModel.js";function X(b,e){return b===null?e?g.INSTANCE:I.INSTANCE:new y(b,e)}class y{_projectionData;_isVisible;constructor(e,n){this._projectionData=e,this._isVisible=n}isVisible(){return this._isVisible}setVisible(e){return this._isVisible=e,this}getProjectionData(){return this._projectionData}getViewLineCount(){return this._isVisible?this._projectionData.getOutputLineCount():0}getViewLineContent(e,n,t){this._assertVisible();const i=t>0?this._projectionData.breakOffsets[t-1]:0,o=this._projectionData.breakOffsets[t];let r;if(this._projectionData.injectionOffsets!==null){const m=this._projectionData.injectionOffsets.map((u,p)=>new O(0,0,u+1,this._projectionData.injectionOptions[p],0));r=O.applyInjectedText(e.getLineContent(n),m).substring(i,o)}else r=e.getValueInRange({startLineNumber:n,startColumn:i+1,endLineNumber:n,endColumn:o+1});return t>0&&(r=T(this._projectionData.wrappedTextIndentLength)+r),r}getViewLineLength(e,n,t){return this._assertVisible(),this._projectionData.getLineLength(t)}getViewLineMinColumn(e,n,t){return this._assertVisible(),this._projectionData.getMinOutputOffset(t)+1}getViewLineMaxColumn(e,n,t){return this._assertVisible(),this._projectionData.getMaxOutputOffset(t)+1}getViewLineData(e,n,t){const i=new Array;return this.getViewLinesData(e,n,t,1,0,[!0],i),i[0]}getViewLinesData(e,n,t,i,o,r,m){this._assertVisible();const a=this._projectionData,u=a.injectionOffsets,p=a.injectionOptions;let d=null;if(u){d=[];let l=0,s=0;for(let c=0;c<a.getOutputLineCount();c++){const M=new Array;d[c]=M;const f=c>0?a.breakOffsets[c-1]:0,w=a.breakOffsets[c];for(;s<u.length;){const P=p[s].content.length,h=u[s]+l,V=h+P;if(h>w)break;if(f<V){const _=p[s];if(_.inlineClassName){const D=c>0?a.wrappedTextIndentLength:0,C=D+Math.max(h-f,0),N=D+Math.min(V-f,w-f);C!==N&&M.push(new E(C,N,_.inlineClassName,_.inlineClassNameAffectsLetterSpacing))}}if(V<=w)l+=P,s++;else break}}}let L;u?L=e.tokenization.getLineTokens(n).withInserted(u.map((l,s)=>({offset:l,text:p[s].content,tokenMetadata:A.defaultTokenMetadata}))):L=e.tokenization.getLineTokens(n);for(let l=t;l<t+i;l++){const s=o+l-t;if(!r[s]){m[s]=null;continue}m[s]=this._getViewLineData(L,d?d[l]:null,l)}}_getViewLineData(e,n,t){this._assertVisible();const i=this._projectionData,o=t>0?i.wrappedTextIndentLength:0,r=t>0?i.breakOffsets[t-1]:0,m=i.breakOffsets[t],a=e.sliceAndInflate(r,m,o);let u=a.getLineContent();t>0&&(u=T(i.wrappedTextIndentLength)+u);const p=this._projectionData.getMinOutputOffset(t)+1,d=u.length+1,L=t+1<this.getViewLineCount(),l=t===0?0:i.breakOffsetsVisibleColumn[t-1];return new x(u,L,p,d,l,a,n)}getModelColumnOfViewPosition(e,n){return this._assertVisible(),this._projectionData.translateToInputOffset(e,n-1)+1}getViewPositionOfModelPosition(e,n,t=k.None){return this._assertVisible(),this._projectionData.translateToOutputPosition(n-1,t).toPosition(e)}getViewLineNumberOfModelPosition(e,n){this._assertVisible();const t=this._projectionData.translateToOutputPosition(n-1);return e+t.outputLineIndex}normalizePosition(e,n,t){const i=n.lineNumber-e;return this._projectionData.normalizeOutputPosition(e,n.column-1,t).toPosition(i)}getInjectedTextAt(e,n){return this._projectionData.getInjectedText(e,n-1)}_assertVisible(){if(!this._isVisible)throw new Error("Not supported")}}class g{static INSTANCE=new g;constructor(){}isVisible(){return!0}setVisible(e){return e?this:I.INSTANCE}getProjectionData(){return null}getViewLineCount(){return 1}getViewLineContent(e,n,t){return e.getLineContent(n)}getViewLineLength(e,n,t){return e.getLineLength(n)}getViewLineMinColumn(e,n,t){return e.getLineMinColumn(n)}getViewLineMaxColumn(e,n,t){return e.getLineMaxColumn(n)}getViewLineData(e,n,t){const i=e.tokenization.getLineTokens(n),o=i.getLineContent();return new x(o,!1,1,o.length+1,0,i.inflate(),null)}getViewLinesData(e,n,t,i,o,r,m){if(!r[o]){m[o]=null;return}m[o]=this.getViewLineData(e,n,0)}getModelColumnOfViewPosition(e,n){return n}getViewPositionOfModelPosition(e,n){return new S(e,n)}getViewLineNumberOfModelPosition(e,n){return e}normalizePosition(e,n,t){return n}getInjectedTextAt(e,n){return null}}class I{static INSTANCE=new I;constructor(){}isVisible(){return!1}setVisible(e){return e?g.INSTANCE:this}getProjectionData(){return null}getViewLineCount(){return 0}getViewLineContent(e,n,t){throw new Error("Not supported")}getViewLineLength(e,n,t){throw new Error("Not supported")}getViewLineMinColumn(e,n,t){throw new Error("Not supported")}getViewLineMaxColumn(e,n,t){throw new Error("Not supported")}getViewLineData(e,n,t){throw new Error("Not supported")}getViewLinesData(e,n,t,i,o,r,m){throw new Error("Not supported")}getModelColumnOfViewPosition(e,n){throw new Error("Not supported")}getViewPositionOfModelPosition(e,n){throw new Error("Not supported")}getViewLineNumberOfModelPosition(e,n){throw new Error("Not supported")}normalizePosition(e,n,t){throw new Error("Not supported")}getInjectedTextAt(e,n){throw new Error("Not supported")}}const j=[""];function T(b){if(b>=j.length)for(let e=1;e<=b;e++)j[e]=W(e);return j[b]}function W(b){return new Array(b+1).join(" ")}export{X as createModelLineProjection};
