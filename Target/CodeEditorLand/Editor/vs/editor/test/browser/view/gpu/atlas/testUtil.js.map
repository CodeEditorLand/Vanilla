{
  "version": 3,
  "sources": ["../../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/test/browser/view/gpu/atlas/testUtil.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { fail, ok } from 'assert';\nimport type { ITextureAtlasPageGlyph } from '../../../../../browser/gpu/atlas/atlas.js';\nimport { TextureAtlas } from '../../../../../browser/gpu/atlas/textureAtlas.js';\nimport { isNumber } from '../../../../../../base/common/types.js';\nimport { ensureNonNullable } from '../../../../../browser/gpu/gpuUtils.js';\n\nexport function assertIsValidGlyph(glyph: Readonly<ITextureAtlasPageGlyph> | undefined, atlasOrSource: TextureAtlas | OffscreenCanvas) {\n\tif (glyph === undefined) {\n\t\tfail('glyph is undefined');\n\t}\n\tconst pageW = atlasOrSource instanceof TextureAtlas ? atlasOrSource.pageSize : atlasOrSource.width;\n\tconst pageH = atlasOrSource instanceof TextureAtlas ? atlasOrSource.pageSize : atlasOrSource.width;\n\tconst source = atlasOrSource instanceof TextureAtlas ? atlasOrSource.pages[glyph.pageIndex].source : atlasOrSource;\n\n\t// (x,y) are valid coordinates\n\tok(isNumber(glyph.x));\n\tok(glyph.x >= 0);\n\tok(glyph.x < pageW);\n\tok(isNumber(glyph.y));\n\tok(glyph.y >= 0);\n\tok(glyph.y < pageH);\n\n\t// (w,h) are valid dimensions\n\tok(isNumber(glyph.w));\n\tok(glyph.w > 0);\n\tok(glyph.w <= pageW);\n\tok(isNumber(glyph.h));\n\tok(glyph.h > 0);\n\tok(glyph.h <= pageH);\n\n\t// (originOffsetX, originOffsetY) are valid offsets\n\tok(isNumber(glyph.originOffsetX));\n\tok(isNumber(glyph.originOffsetY));\n\n\t// (x,y) + (w,h) are within the bounds of the atlas\n\tok(glyph.x + glyph.w <= pageW);\n\tok(glyph.y + glyph.h <= pageH);\n\n\t// Each of the glyph's outer pixel edges contain at least 1 non-transparent pixel\n\tconst ctx = ensureNonNullable(source.getContext('2d'));\n\tconst edges = [\n\t\tctx.getImageData(glyph.x, glyph.y, glyph.w, 1).data,\n\t\tctx.getImageData(glyph.x, glyph.y + glyph.h - 1, glyph.w, 1).data,\n\t\tctx.getImageData(glyph.x, glyph.y, 1, glyph.h).data,\n\t\tctx.getImageData(glyph.x + glyph.w - 1, glyph.y, 1, glyph.h).data,\n\t];\n\tfor (const edge of edges) {\n\t\tok(edge.some(color => (color & 0xFF) !== 0));\n\t}\n}\n"],
  "mappings": ";;AAKA,SAAS,MAAM,UAAU;AAEzB,SAAS,oBAAoB;AAC7B,SAAS,gBAAgB;AACzB,SAAS,yBAAyB;AAE3B,SAAS,mBAAmB,OAAqD,eAA+C;AACtI,MAAI,UAAU,QAAW;AACxB,SAAK,oBAAoB;AAAA,EAC1B;AACA,QAAM,QAAQ,yBAAyB,eAAe,cAAc,WAAW,cAAc;AAC7F,QAAM,QAAQ,yBAAyB,eAAe,cAAc,WAAW,cAAc;AAC7F,QAAM,SAAS,yBAAyB,eAAe,cAAc,MAAM,MAAM,SAAS,EAAE,SAAS;AAGrG,KAAG,SAAS,MAAM,CAAC,CAAC;AACpB,KAAG,MAAM,KAAK,CAAC;AACf,KAAG,MAAM,IAAI,KAAK;AAClB,KAAG,SAAS,MAAM,CAAC,CAAC;AACpB,KAAG,MAAM,KAAK,CAAC;AACf,KAAG,MAAM,IAAI,KAAK;AAGlB,KAAG,SAAS,MAAM,CAAC,CAAC;AACpB,KAAG,MAAM,IAAI,CAAC;AACd,KAAG,MAAM,KAAK,KAAK;AACnB,KAAG,SAAS,MAAM,CAAC,CAAC;AACpB,KAAG,MAAM,IAAI,CAAC;AACd,KAAG,MAAM,KAAK,KAAK;AAGnB,KAAG,SAAS,MAAM,aAAa,CAAC;AAChC,KAAG,SAAS,MAAM,aAAa,CAAC;AAGhC,KAAG,MAAM,IAAI,MAAM,KAAK,KAAK;AAC7B,KAAG,MAAM,IAAI,MAAM,KAAK,KAAK;AAG7B,QAAM,MAAM,kBAAkB,OAAO,WAAW,IAAI,CAAC;AACrD,QAAM,QAAQ;AAAA,IACb,IAAI,aAAa,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,CAAC,EAAE;AAAA,IAC/C,IAAI,aAAa,MAAM,GAAG,MAAM,IAAI,MAAM,IAAI,GAAG,MAAM,GAAG,CAAC,EAAE;AAAA,IAC7D,IAAI,aAAa,MAAM,GAAG,MAAM,GAAG,GAAG,MAAM,CAAC,EAAE;AAAA,IAC/C,IAAI,aAAa,MAAM,IAAI,MAAM,IAAI,GAAG,MAAM,GAAG,GAAG,MAAM,CAAC,EAAE;AAAA,EAC9D;AACA,aAAW,QAAQ,OAAO;AACzB,OAAG,KAAK,KAAK,YAAU,QAAQ,SAAU,CAAC,CAAC;AAAA,EAC5C;AACD;AA3CgB;",
  "names": []
}
