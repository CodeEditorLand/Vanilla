import"../../../common/tokens/lineTokens.js";import{TokenMetadata as o}from"../../../common/encodedTokenAttributes.js";import"../../../common/languages.js";class i{endIndex;_metadata;constructor(e,t){this.endIndex=e,this._metadata=t}getStandardTokenType(){return o.getTokenType(this._metadata)}getForeground(){return o.getForeground(this._metadata)}getType(){return o.getClassNameFromMetadata(this._metadata)}getInlineStyle(e){return o.getInlineStyleFromMetadata(this._metadata,e)}getPresentation(){return o.getPresentationFromMetadata(this._metadata)}static _equals(e,t){return e.endIndex===t.endIndex&&e._metadata===t._metadata}static equalsArr(e,t){const a=e.length,n=t.length;if(a!==n)return!1;for(let r=0;r<a;r++)if(!this._equals(e[r],t[r]))return!1;return!0}}class u{_actual;constructor(e){this._actual=e}equals(e){return e instanceof u?i.equalsArr(this._actual,e._actual):!1}getCount(){return this._actual.length}getStandardTokenType(e){return this._actual[e].getStandardTokenType()}getForeground(e){return this._actual[e].getForeground()}getEndOffset(e){return this._actual[e].endIndex}getClassName(e){return this._actual[e].getType()}getInlineStyle(e,t){return this._actual[e].getInlineStyle(t)}getPresentation(e){return this._actual[e].getPresentation()}findTokenIndexAtOffset(e){throw new Error("Not implemented")}getLineContent(){throw new Error("Not implemented")}getMetadata(e){throw new Error("Method not implemented.")}getLanguageId(e){throw new Error("Method not implemented.")}getTokenText(e){throw new Error("Method not implemented.")}forEach(e){throw new Error("Not implemented")}get languageIdCodec(){throw new Error("Not implemented")}}class k{static inflateArr(e){const t=e.length>>>1,a=new Array(t);for(let n=0;n<t;n++){const r=e[n<<1],s=e[(n<<1)+1];a[n]=new i(r,s)}return a}}export{i as TestLineToken,k as TestLineTokenFactory,u as TestLineTokens};
