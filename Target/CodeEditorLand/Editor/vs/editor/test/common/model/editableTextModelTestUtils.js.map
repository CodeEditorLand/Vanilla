{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/test/common/model/editableTextModelTestUtils.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport { ISingleEditOperation } from '../../../common/core/editOperation.js';\nimport { Position } from '../../../common/core/position.js';\nimport { EndOfLinePreference, EndOfLineSequence } from '../../../common/model.js';\nimport { MirrorTextModel } from '../../../common/model/mirrorTextModel.js';\nimport { TextModel } from '../../../common/model/textModel.js';\nimport { IModelContentChangedEvent } from '../../../common/textModelEvents.js';\nimport { createTextModel } from '../testTextModel.js';\n\nexport function testApplyEditsWithSyncedModels(original: string[], edits: ISingleEditOperation[], expected: string[], inputEditsAreInvalid: boolean = false): void {\n\tconst originalStr = original.join('\\n');\n\tconst expectedStr = expected.join('\\n');\n\n\tassertSyncedModels(originalStr, (model, assertMirrorModels) => {\n\t\t// Apply edits & collect inverse edits\n\t\tconst inverseEdits = model.applyEdits(edits, true);\n\n\t\t// Assert edits produced expected result\n\t\tassert.deepStrictEqual(model.getValue(EndOfLinePreference.LF), expectedStr);\n\n\t\tassertMirrorModels();\n\n\t\t// Apply the inverse edits\n\t\tconst inverseInverseEdits = model.applyEdits(inverseEdits, true);\n\n\t\t// Assert the inverse edits brought back model to original state\n\t\tassert.deepStrictEqual(model.getValue(EndOfLinePreference.LF), originalStr);\n\n\t\tif (!inputEditsAreInvalid) {\n\t\t\tconst simplifyEdit = (edit: ISingleEditOperation) => {\n\t\t\t\treturn {\n\t\t\t\t\trange: edit.range,\n\t\t\t\t\ttext: edit.text,\n\t\t\t\t\tforceMoveMarkers: edit.forceMoveMarkers || false\n\t\t\t\t};\n\t\t\t};\n\t\t\t// Assert the inverse of the inverse edits are the original edits\n\t\t\tassert.deepStrictEqual(inverseInverseEdits.map(simplifyEdit), edits.map(simplifyEdit));\n\t\t}\n\n\t\tassertMirrorModels();\n\t});\n}\n\nconst enum AssertDocumentLineMappingDirection {\n\tOffsetToPosition,\n\tPositionToOffset\n}\n\nfunction assertOneDirectionLineMapping(model: TextModel, direction: AssertDocumentLineMappingDirection, msg: string): void {\n\tconst allText = model.getValue();\n\n\tlet line = 1, column = 1, previousIsCarriageReturn = false;\n\tfor (let offset = 0; offset <= allText.length; offset++) {\n\t\t// The position coordinate system cannot express the position between \\r and \\n\n\t\tconst position: Position = new Position(line, column + (previousIsCarriageReturn ? -1 : 0));\n\n\t\tif (direction === AssertDocumentLineMappingDirection.OffsetToPosition) {\n\t\t\tconst actualPosition = model.getPositionAt(offset);\n\t\t\tassert.strictEqual(actualPosition.toString(), position.toString(), msg + ' - getPositionAt mismatch for offset ' + offset);\n\t\t} else {\n\t\t\t// The position coordinate system cannot express the position between \\r and \\n\n\t\t\tconst expectedOffset: number = offset + (previousIsCarriageReturn ? -1 : 0);\n\t\t\tconst actualOffset = model.getOffsetAt(position);\n\t\t\tassert.strictEqual(actualOffset, expectedOffset, msg + ' - getOffsetAt mismatch for position ' + position.toString());\n\t\t}\n\n\t\tif (allText.charAt(offset) === '\\n') {\n\t\t\tline++;\n\t\t\tcolumn = 1;\n\t\t} else {\n\t\t\tcolumn++;\n\t\t}\n\n\t\tpreviousIsCarriageReturn = (allText.charAt(offset) === '\\r');\n\t}\n}\n\nfunction assertLineMapping(model: TextModel, msg: string): void {\n\tassertOneDirectionLineMapping(model, AssertDocumentLineMappingDirection.PositionToOffset, msg);\n\tassertOneDirectionLineMapping(model, AssertDocumentLineMappingDirection.OffsetToPosition, msg);\n}\n\n\nexport function assertSyncedModels(text: string, callback: (model: TextModel, assertMirrorModels: () => void) => void, setup: ((model: TextModel) => void) | null = null): void {\n\tconst model = createTextModel(text);\n\tmodel.setEOL(EndOfLineSequence.LF);\n\tassertLineMapping(model, 'model');\n\n\tif (setup) {\n\t\tsetup(model);\n\t\tassertLineMapping(model, 'model');\n\t}\n\n\tconst mirrorModel2 = new MirrorTextModel(null!, model.getLinesContent(), model.getEOL(), model.getVersionId());\n\tlet mirrorModel2PrevVersionId = model.getVersionId();\n\n\tconst disposable = model.onDidChangeContent((e: IModelContentChangedEvent) => {\n\t\tconst versionId = e.versionId;\n\t\tif (versionId < mirrorModel2PrevVersionId) {\n\t\t\tconsole.warn('Model version id did not advance between edits (2)');\n\t\t}\n\t\tmirrorModel2PrevVersionId = versionId;\n\t\tmirrorModel2.onEvents(e);\n\t});\n\n\tconst assertMirrorModels = () => {\n\t\tassertLineMapping(model, 'model');\n\t\tassert.strictEqual(mirrorModel2.getText(), model.getValue(), 'mirror model 2 text OK');\n\t\tassert.strictEqual(mirrorModel2.version, model.getVersionId(), 'mirror model 2 version OK');\n\t};\n\n\tcallback(model, assertMirrorModels);\n\n\tdisposable.dispose();\n\tmodel.dispose();\n\tmirrorModel2.dispose();\n}\n"],
  "mappings": "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",
  "names": ["AssertDocumentLineMappingDirection"]
}
