{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/test/node/diffing/fixtures.test.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport { existsSync, readFileSync, readdirSync, rmSync, writeFileSync } from 'fs';\nimport { join, resolve } from 'path';\nimport { setUnexpectedErrorHandler } from '../../../../base/common/errors.js';\nimport { FileAccess } from '../../../../base/common/network.js';\nimport { DetailedLineRangeMapping, RangeMapping } from '../../../common/diff/rangeMapping.js';\nimport { LegacyLinesDiffComputer } from '../../../common/diff/legacyLinesDiffComputer.js';\nimport { DefaultLinesDiffComputer } from '../../../common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.js';\nimport { Range } from '../../../common/core/range.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../base/test/common/utils.js';\nimport { AbstractText, ArrayText, SingleTextEdit, TextEdit } from '../../../common/core/textEdit.js';\nimport { LinesDiff } from '../../../common/diff/linesDiffComputer.js';\n\nsuite('diffing fixtures', () => {\n\tensureNoDisposablesAreLeakedInTestSuite();\n\n\tsetup(() => {\n\t\tsetUnexpectedErrorHandler(e => {\n\t\t\tthrow e;\n\t\t});\n\t});\n\n\n\tconst fixturesOutDir = FileAccess.asFileUri('vs/editor/test/node/diffing/fixtures').fsPath;\n\t// We want the dir in src, so we can directly update the source files if they disagree and create invalid files to capture the previous state.\n\t// This makes it very easy to update the fixtures.\n\tconst fixturesSrcDir = resolve(fixturesOutDir).replaceAll('\\\\', '/').replace('/out/vs/editor/', '/src/vs/editor/');\n\tconst folders = readdirSync(fixturesSrcDir);\n\n\tfunction runTest(folder: string, diffingAlgoName: 'legacy' | 'advanced') {\n\t\tconst folderPath = join(fixturesSrcDir, folder);\n\t\tconst files = readdirSync(folderPath);\n\n\t\tconst firstFileName = files.find(f => f.startsWith('1.'))!;\n\t\tconst secondFileName = files.find(f => f.startsWith('2.'))!;\n\n\t\tconst firstContent = readFileSync(join(folderPath, firstFileName), 'utf8').replaceAll('\\r\\n', '\\n').replaceAll('\\r', '\\n');\n\t\tconst firstContentLines = firstContent.split(/\\n/);\n\t\tconst secondContent = readFileSync(join(folderPath, secondFileName), 'utf8').replaceAll('\\r\\n', '\\n').replaceAll('\\r', '\\n');\n\t\tconst secondContentLines = secondContent.split(/\\n/);\n\n\t\tconst diffingAlgo = diffingAlgoName === 'legacy' ? new LegacyLinesDiffComputer() : new DefaultLinesDiffComputer();\n\n\t\tconst ignoreTrimWhitespace = folder.indexOf('trimws') >= 0;\n\t\tconst diff = diffingAlgo.computeDiff(firstContentLines, secondContentLines, { ignoreTrimWhitespace, maxComputationTimeMs: Number.MAX_SAFE_INTEGER, computeMoves: true });\n\n\t\tif (diffingAlgoName === 'advanced' && !ignoreTrimWhitespace) {\n\t\t\tassertDiffCorrectness(diff, firstContentLines, secondContentLines);\n\t\t}\n\n\t\tfunction getDiffs(changes: readonly DetailedLineRangeMapping[]): IDetailedDiff[] {\n\t\t\tfor (const c of changes) {\n\t\t\t\tRangeMapping.assertSorted(c.innerChanges ?? []);\n\t\t\t}\n\n\t\t\treturn changes.map<IDetailedDiff>(c => ({\n\t\t\t\toriginalRange: c.original.toString(),\n\t\t\t\tmodifiedRange: c.modified.toString(),\n\t\t\t\tinnerChanges: c.innerChanges?.map<IDiff>(c => ({\n\t\t\t\t\toriginalRange: formatRange(c.originalRange, firstContentLines),\n\t\t\t\t\tmodifiedRange: formatRange(c.modifiedRange, secondContentLines),\n\t\t\t\t})) || null\n\t\t\t}));\n\t\t}\n\n\t\tfunction formatRange(range: Range, lines: string[]): string {\n\t\t\tconst toLastChar = range.endColumn === lines[range.endLineNumber - 1].length + 1;\n\n\t\t\treturn '[' + range.startLineNumber + ',' + range.startColumn + ' -> ' + range.endLineNumber + ',' + range.endColumn + (toLastChar ? ' EOL' : '') + ']';\n\t\t}\n\n\t\tconst actualDiffingResult: DiffingResult = {\n\t\t\toriginal: { content: firstContent, fileName: `./${firstFileName}` },\n\t\t\tmodified: { content: secondContent, fileName: `./${secondFileName}` },\n\t\t\tdiffs: getDiffs(diff.changes),\n\t\t\tmoves: diff.moves.map(v => ({\n\t\t\t\toriginalRange: v.lineRangeMapping.original.toString(),\n\t\t\t\tmodifiedRange: v.lineRangeMapping.modified.toString(),\n\t\t\t\tchanges: getDiffs(v.changes),\n\t\t\t}))\n\t\t};\n\t\tif (actualDiffingResult.moves?.length === 0) {\n\t\t\tdelete actualDiffingResult.moves;\n\t\t}\n\n\t\tconst expectedFilePath = join(folderPath, `${diffingAlgoName}.expected.diff.json`);\n\t\tconst invalidFilePath = join(folderPath, `${diffingAlgoName}.invalid.diff.json`);\n\n\t\tconst actualJsonStr = JSON.stringify(actualDiffingResult, null, '\\t');\n\n\t\tif (!existsSync(expectedFilePath)) {\n\t\t\t// New test, create expected file\n\t\t\twriteFileSync(expectedFilePath, actualJsonStr);\n\t\t\t// Create invalid file so that this test fails on a re-run\n\t\t\twriteFileSync(invalidFilePath, '');\n\t\t\tthrow new Error('No expected file! Expected and invalid files were written. Delete the invalid file to make the test pass.');\n\t\t} if (existsSync(invalidFilePath)) {\n\t\t\tconst invalidJsonStr = readFileSync(invalidFilePath, 'utf8');\n\t\t\tif (invalidJsonStr === '') {\n\t\t\t\t// Update expected file\n\t\t\t\twriteFileSync(expectedFilePath, actualJsonStr);\n\t\t\t\tthrow new Error(`Delete the invalid ${invalidFilePath} file to make the test pass.`);\n\t\t\t} else {\n\t\t\t\tconst expectedFileDiffResult: DiffingResult = JSON.parse(invalidJsonStr);\n\t\t\t\ttry {\n\t\t\t\t\tassert.deepStrictEqual(actualDiffingResult, expectedFileDiffResult);\n\t\t\t\t} catch (e) {\n\t\t\t\t\twriteFileSync(expectedFilePath, actualJsonStr);\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t\t// Test succeeded with the invalid file, restore expected file from invalid\n\t\t\t\twriteFileSync(expectedFilePath, invalidJsonStr);\n\t\t\t\trmSync(invalidFilePath);\n\t\t\t}\n\t\t} else {\n\t\t\tconst expectedJsonStr = readFileSync(expectedFilePath, 'utf8');\n\t\t\tconst expectedFileDiffResult: DiffingResult = JSON.parse(expectedJsonStr);\n\t\t\ttry {\n\t\t\t\tassert.deepStrictEqual(actualDiffingResult, expectedFileDiffResult);\n\t\t\t} catch (e) {\n\t\t\t\t// Backup expected file\n\t\t\t\twriteFileSync(invalidFilePath, expectedJsonStr);\n\t\t\t\t// Update expected file\n\t\t\t\twriteFileSync(expectedFilePath, actualJsonStr);\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}\n\n\ttest(`test`, () => {\n\t\trunTest('invalid-diff-trimws', 'advanced');\n\t});\n\n\tfor (const folder of folders) {\n\t\tfor (const diffingAlgoName of ['legacy', 'advanced'] as const) {\n\t\t\ttest(`${folder}-${diffingAlgoName}`, () => {\n\t\t\t\trunTest(folder, diffingAlgoName);\n\t\t\t});\n\t\t}\n\t}\n});\n\ninterface DiffingResult {\n\toriginal: { content: string; fileName: string };\n\tmodified: { content: string; fileName: string };\n\n\tdiffs: IDetailedDiff[];\n\tmoves?: IMoveInfo[];\n}\n\ninterface IDetailedDiff {\n\toriginalRange: string; // [startLineNumber, endLineNumberExclusive)\n\tmodifiedRange: string; // [startLineNumber, endLineNumberExclusive)\n\tinnerChanges: IDiff[] | null;\n}\n\ninterface IDiff {\n\toriginalRange: string; // [1,18 -> 1,19]\n\tmodifiedRange: string; // [1,18 -> 1,19]\n}\n\ninterface IMoveInfo {\n\toriginalRange: string; // [startLineNumber, endLineNumberExclusive)\n\tmodifiedRange: string; // [startLineNumber, endLineNumberExclusive)\n\n\tchanges: IDetailedDiff[];\n}\n\nfunction assertDiffCorrectness(diff: LinesDiff, original: string[], modified: string[]) {\n\tconst allInnerChanges = diff.changes.flatMap(c => c.innerChanges!);\n\tconst edit = rangeMappingsToTextEdit(allInnerChanges, new ArrayText(modified));\n\tconst result = edit.normalize().apply(new ArrayText(original));\n\n\tassert.deepStrictEqual(result, modified.join('\\n'));\n}\n\nfunction rangeMappingsToTextEdit(rangeMappings: readonly RangeMapping[], modified: AbstractText): TextEdit {\n\treturn new TextEdit(rangeMappings.map(m => {\n\t\treturn new SingleTextEdit(\n\t\t\tm.originalRange,\n\t\t\tmodified.getValueOfRange(m.modifiedRange)\n\t\t);\n\t}));\n}\n"],
  "mappings": "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",
  "names": ["c"]
}
