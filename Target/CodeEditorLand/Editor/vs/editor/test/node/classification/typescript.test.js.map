{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/test/node/classification/typescript.test.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport { StandardTokenType } from '../../../common/encodedTokenAttributes.js';\nimport * as fs from 'fs';\n// import { getPathFromAmdModule } from 'vs/base/test/node/testUtils';\n// import { parse } from 'vs/editor/common/modes/tokenization/typescript';\nimport { toStandardTokenType } from '../../../common/languages/supports/tokenization.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../base/test/common/utils.js';\n\ninterface IParseFunc {\n\t(text: string): number[];\n}\n\ninterface IAssertion {\n\ttestLineNumber: number;\n\tstartOffset: number;\n\tlength: number;\n\ttokenType: StandardTokenType;\n}\n\ninterface ITest {\n\tcontent: string;\n\tassertions: IAssertion[];\n}\n\nfunction parseTest(fileName: string): ITest {\n\tinterface ILineWithAssertions {\n\t\tline: string;\n\t\tassertions: ILineAssertion[];\n\t}\n\n\tinterface ILineAssertion {\n\t\ttestLineNumber: number;\n\t\tstartOffset: number;\n\t\tlength: number;\n\t\texpectedTokenType: StandardTokenType;\n\t}\n\n\tconst testContents = fs.readFileSync(fileName).toString();\n\tconst lines = testContents.split(/\\r\\n|\\n/);\n\tconst magicToken = lines[0];\n\n\tlet currentElement: ILineWithAssertions = {\n\t\tline: lines[1],\n\t\tassertions: []\n\t};\n\n\tconst parsedTest: ILineWithAssertions[] = [];\n\tfor (let i = 2; i < lines.length; i++) {\n\t\tconst line = lines[i];\n\t\tif (line.substr(0, magicToken.length) === magicToken) {\n\t\t\t// this is an assertion line\n\t\t\tconst m1 = line.substr(magicToken.length).match(/^( +)([\\^]+) (\\w+)\\\\?$/);\n\t\t\tif (m1) {\n\t\t\t\tcurrentElement.assertions.push({\n\t\t\t\t\ttestLineNumber: i + 1,\n\t\t\t\t\tstartOffset: magicToken.length + m1[1].length,\n\t\t\t\t\tlength: m1[2].length,\n\t\t\t\t\texpectedTokenType: toStandardTokenType(m1[3])\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tconst m2 = line.substr(magicToken.length).match(/^( +)<(-+) (\\w+)\\\\?$/);\n\t\t\t\tif (m2) {\n\t\t\t\t\tcurrentElement.assertions.push({\n\t\t\t\t\t\ttestLineNumber: i + 1,\n\t\t\t\t\t\tstartOffset: 0,\n\t\t\t\t\t\tlength: m2[2].length,\n\t\t\t\t\t\texpectedTokenType: toStandardTokenType(m2[3])\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(`Invalid test line at line number ${i + 1}.`);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// this is a line to be parsed\n\t\t\tparsedTest.push(currentElement);\n\t\t\tcurrentElement = {\n\t\t\t\tline: line,\n\t\t\t\tassertions: []\n\t\t\t};\n\t\t}\n\t}\n\tparsedTest.push(currentElement);\n\n\tconst assertions: IAssertion[] = [];\n\n\tlet offset = 0;\n\tfor (let i = 0; i < parsedTest.length; i++) {\n\t\tconst parsedTestLine = parsedTest[i];\n\t\tfor (let j = 0; j < parsedTestLine.assertions.length; j++) {\n\t\t\tconst assertion = parsedTestLine.assertions[j];\n\t\t\tassertions.push({\n\t\t\t\ttestLineNumber: assertion.testLineNumber,\n\t\t\t\tstartOffset: offset + assertion.startOffset,\n\t\t\t\tlength: assertion.length,\n\t\t\t\ttokenType: assertion.expectedTokenType\n\t\t\t});\n\t\t}\n\t\toffset += parsedTestLine.line.length + 1;\n\t}\n\n\tconst content: string = parsedTest.map(parsedTestLine => parsedTestLine.line).join('\\n');\n\n\treturn { content, assertions };\n}\n\n// @ts-expect-error\nfunction executeTest(fileName: string, parseFunc: IParseFunc): void {\n\tconst { content, assertions } = parseTest(fileName);\n\tconst actual = parseFunc(content);\n\n\tlet actualIndex = 0;\n\tconst actualCount = actual.length / 3;\n\tfor (let i = 0; i < assertions.length; i++) {\n\t\tconst assertion = assertions[i];\n\t\twhile (actualIndex < actualCount && actual[3 * actualIndex] + actual[3 * actualIndex + 1] <= assertion.startOffset) {\n\t\t\tactualIndex++;\n\t\t}\n\t\tassert.ok(\n\t\t\tactual[3 * actualIndex] <= assertion.startOffset,\n\t\t\t`Line ${assertion.testLineNumber} : startOffset : ${actual[3 * actualIndex]} <= ${assertion.startOffset}`\n\t\t);\n\t\tassert.ok(\n\t\t\tactual[3 * actualIndex] + actual[3 * actualIndex + 1] >= assertion.startOffset + assertion.length,\n\t\t\t`Line ${assertion.testLineNumber} : length : ${actual[3 * actualIndex]} + ${actual[3 * actualIndex + 1]} >= ${assertion.startOffset} + ${assertion.length}.`\n\t\t);\n\t\tassert.strictEqual(\n\t\t\tactual[3 * actualIndex + 2],\n\t\t\tassertion.tokenType,\n\t\t\t`Line ${assertion.testLineNumber} : tokenType`);\n\t}\n}\n\nsuite('Classification', () => {\n\n\tensureNoDisposablesAreLeakedInTestSuite();\n\n\ttest('TypeScript', () => {\n\t\t// executeTest(getPathFromAmdModule(require, 'vs/editor/test/node/classification/typescript-test.ts').replace(/\\bout\\b/, 'src'), parse);\n\t});\n});\n"],
  "mappings": "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",
  "names": []
}
