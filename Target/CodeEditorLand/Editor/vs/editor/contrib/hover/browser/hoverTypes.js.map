{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/contrib/hover/browser/hoverTypes.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Dimension } from '../../../../base/browser/dom.js';\nimport { AsyncIterableObject } from '../../../../base/common/async.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { IDisposable } from '../../../../base/common/lifecycle.js';\nimport { ICodeEditor, IEditorMouseEvent } from '../../../browser/editorBrowser.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { IModelDecoration } from '../../../common/model.js';\nimport { BrandedService, IConstructorSignature } from '../../../../platform/instantiation/common/instantiation.js';\n\nexport interface IHoverPart {\n\t/**\n\t * The creator of this hover part.\n\t */\n\treadonly owner: IEditorHoverParticipant;\n\t/**\n\t * The range where this hover part applies.\n\t */\n\treadonly range: Range;\n\t/**\n\t * Force the hover to always be rendered at this specific range,\n\t * even in the case of multiple hover parts.\n\t */\n\treadonly forceShowAtRange?: boolean;\n\n\t/**\n\t * If true, the hover item should appear before content\n\t */\n\treadonly isBeforeContent?: boolean;\n\t/**\n\t * Is this hover part still valid for this new anchor?\n\t */\n\tisValidForHoverAnchor(anchor: HoverAnchor): boolean;\n}\n\nexport const enum HoverAnchorType {\n\tRange = 1,\n\tForeignElement = 2\n}\n\nexport class HoverRangeAnchor {\n\tpublic readonly type = HoverAnchorType.Range;\n\tconstructor(\n\t\tpublic readonly priority: number,\n\t\tpublic readonly range: Range,\n\t\tpublic readonly initialMousePosX: number | undefined,\n\t\tpublic readonly initialMousePosY: number | undefined,\n\t) {\n\t}\n\tpublic equals(other: HoverAnchor) {\n\t\treturn (other.type === HoverAnchorType.Range && this.range.equalsRange(other.range));\n\t}\n\tpublic canAdoptVisibleHover(lastAnchor: HoverAnchor, showAtPosition: Position): boolean {\n\t\treturn (lastAnchor.type === HoverAnchorType.Range && showAtPosition.lineNumber === this.range.startLineNumber);\n\t}\n}\n\nexport class HoverForeignElementAnchor {\n\tpublic readonly type = HoverAnchorType.ForeignElement;\n\tconstructor(\n\t\tpublic readonly priority: number,\n\t\tpublic readonly owner: IEditorHoverParticipant,\n\t\tpublic readonly range: Range,\n\t\tpublic readonly initialMousePosX: number | undefined,\n\t\tpublic readonly initialMousePosY: number | undefined,\n\t\tpublic readonly supportsMarkerHover: boolean | undefined\n\t) {\n\t}\n\tpublic equals(other: HoverAnchor) {\n\t\treturn (other.type === HoverAnchorType.ForeignElement && this.owner === other.owner);\n\t}\n\tpublic canAdoptVisibleHover(lastAnchor: HoverAnchor, showAtPosition: Position): boolean {\n\t\treturn (lastAnchor.type === HoverAnchorType.ForeignElement && this.owner === lastAnchor.owner);\n\t}\n}\n\nexport type HoverAnchor = HoverRangeAnchor | HoverForeignElementAnchor;\n\nexport interface IEditorHoverStatusBar {\n\taddAction(actionOptions: { label: string; iconClass?: string; run: (target: HTMLElement) => void; commandId: string }): IEditorHoverAction;\n\tappend(element: HTMLElement): HTMLElement;\n}\n\nexport interface IEditorHoverAction {\n\tsetEnabled(enabled: boolean): void;\n}\n\nexport interface IEditorHoverColorPickerWidget {\n\tlayout(): void;\n}\n\nexport interface IEditorHoverContext {\n\t/**\n\t * The contents rendered inside the fragment have been changed, which means that the hover should relayout.\n\t */\n\tonContentsChanged(): void;\n\t/**\n\t * Set the minimum dimensions of the resizable hover\n\t */\n\tsetMinimumDimensions?(dimensions: Dimension): void;\n\t/**\n\t * Hide the hover.\n\t */\n\thide(): void;\n}\n\nexport interface IEditorHoverRenderContext extends IEditorHoverContext {\n\t/**\n\t * The fragment where dom elements should be attached.\n\t */\n\treadonly fragment: DocumentFragment;\n\t/**\n\t * The status bar for actions for this hover.\n\t */\n\treadonly statusBar: IEditorHoverStatusBar;\n}\n\nexport interface IRenderedHoverPart<T extends IHoverPart> extends IDisposable {\n\t/**\n\t * The rendered hover part.\n\t */\n\thoverPart: T;\n\t/**\n\t * The HTML element containing the hover part.\n\t */\n\thoverElement: HTMLElement;\n}\n\nexport interface IRenderedHoverParts<T extends IHoverPart> extends IDisposable {\n\t/**\n\t * Array of rendered hover parts.\n\t */\n\trenderedHoverParts: IRenderedHoverPart<T>[];\n}\n\n/**\n * Default implementation of IRenderedHoverParts.\n */\nexport class RenderedHoverParts<T extends IHoverPart> implements IRenderedHoverParts<T> {\n\n\tconstructor(public readonly renderedHoverParts: IRenderedHoverPart<T>[]) { }\n\n\tdispose() {\n\t\tfor (const part of this.renderedHoverParts) {\n\t\t\tpart.dispose();\n\t\t}\n\t}\n}\n\nexport interface IEditorHoverParticipant<T extends IHoverPart = IHoverPart> {\n\treadonly hoverOrdinal: number;\n\tsuggestHoverAnchor?(mouseEvent: IEditorMouseEvent): HoverAnchor | null;\n\tcomputeSync(anchor: HoverAnchor, lineDecorations: IModelDecoration[]): T[];\n\tcomputeAsync?(anchor: HoverAnchor, lineDecorations: IModelDecoration[], token: CancellationToken): AsyncIterableObject<T>;\n\tcreateLoadingMessage?(anchor: HoverAnchor): T | null;\n\trenderHoverParts(context: IEditorHoverRenderContext, hoverParts: T[]): IRenderedHoverParts<T>;\n\tgetAccessibleContent(hoverPart: T): string;\n\thandleResize?(): void;\n}\n\nexport type IEditorHoverParticipantCtor = IConstructorSignature<IEditorHoverParticipant, [ICodeEditor]>;\n\nexport const HoverParticipantRegistry = (new class HoverParticipantRegistry {\n\n\t_participants: IEditorHoverParticipantCtor[] = [];\n\n\tpublic register<Services extends BrandedService[]>(ctor: { new(editor: ICodeEditor, ...services: Services): IEditorHoverParticipant }): void {\n\t\tthis._participants.push(ctor as IEditorHoverParticipantCtor);\n\t}\n\n\tpublic getAll(): IEditorHoverParticipantCtor[] {\n\t\treturn this._participants;\n\t}\n\n}());\n\nexport interface IHoverWidget {\n\t/**\n\t * Returns whether the hover widget is shown or should show in the future.\n\t * If the widget should show, this triggers the display.\n\t * @param mouseEvent editor mouse event\n\t */\n\tshowsOrWillShow(mouseEvent: IEditorMouseEvent): boolean;\n\n\t/**\n\t * Hides the hover.\n\t */\n\thide(): void;\n}\n"],
  "mappings": ";;AAKA,SAAS,iBAAiB;AAC1B,SAAS,2BAA2B;AACpC,SAAS,yBAAyB;AAClC,SAAS,mBAAmB;AAC5B,SAAS,aAAa,yBAAyB;AAC/C,SAAS,gBAAgB;AACzB,SAAS,aAAa;AACtB,SAAS,wBAAwB;AACjC,SAAS,gBAAgB,6BAA6B;AA2B/C,IAAW,kBAAX,kBAAWA,qBAAX;AACN,EAAAA,kCAAA,WAAQ,KAAR;AACA,EAAAA,kCAAA,oBAAiB,KAAjB;AAFiB,SAAAA;AAAA,GAAA;AAKX,MAAM,iBAAiB;AAAA,EAE7B,YACiB,UACA,OACA,kBACA,kBACf;AAJe;AACA;AACA;AACA;AAAA,EAEjB;AAAA,EArDD,OA6C8B;AAAA;AAAA;AAAA,EACb,OAAO;AAAA,EAQhB,OAAO,OAAoB;AACjC,WAAQ,MAAM,SAAS,iBAAyB,KAAK,MAAM,YAAY,MAAM,KAAK;AAAA,EACnF;AAAA,EACO,qBAAqB,YAAyB,gBAAmC;AACvF,WAAQ,WAAW,SAAS,iBAAyB,eAAe,eAAe,KAAK,MAAM;AAAA,EAC/F;AACD;AAEO,MAAM,0BAA0B;AAAA,EAEtC,YACiB,UACA,OACA,OACA,kBACA,kBACA,qBACf;AANe;AACA;AACA;AACA;AACA;AACA;AAAA,EAEjB;AAAA,EAxED,OA8DuC;AAAA;AAAA;AAAA,EACtB,OAAO;AAAA,EAUhB,OAAO,OAAoB;AACjC,WAAQ,MAAM,SAAS,0BAAkC,KAAK,UAAU,MAAM;AAAA,EAC/E;AAAA,EACO,qBAAqB,YAAyB,gBAAmC;AACvF,WAAQ,WAAW,SAAS,0BAAkC,KAAK,UAAU,WAAW;AAAA,EACzF;AACD;AAgEO,MAAM,mBAA2E;AAAA,EAEvF,YAA4B,oBAA6C;AAA7C;AAAA,EAA+C;AAAA,EAjJ5E,OA+IwF;AAAA;AAAA;AAAA,EAIvF,UAAU;AACT,eAAW,QAAQ,KAAK,oBAAoB;AAC3C,WAAK,QAAQ;AAAA,IACd;AAAA,EACD;AACD;AAeO,MAAM,2BAA4B,IAAI,MAAMC,0BAAyB;AAAA,EAvK5E,OAuK4E;AAAA;AAAA;AAAA,EAE3E,gBAA+C,CAAC;AAAA,EAEzC,SAA4C,MAA0F;AAC5I,SAAK,cAAc,KAAK,IAAmC;AAAA,EAC5D;AAAA,EAEO,SAAwC;AAC9C,WAAO,KAAK;AAAA,EACb;AAED,EAAE;",
  "names": ["HoverAnchorType", "HoverParticipantRegistry"]
}
