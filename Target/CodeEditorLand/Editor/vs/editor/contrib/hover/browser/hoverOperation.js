import{createCancelableAsyncIterable as c,RunOnceScheduler as l}from"../../../../base/common/async.js";import{onUnexpectedError as u}from"../../../../base/common/errors.js";import{Emitter as h}from"../../../../base/common/event.js";import{Disposable as o}from"../../../../base/common/lifecycle.js";import{EditorOption as d}from"../../../common/config/editorOptions.js";var _=(i=>(i[i.Idle=0]="Idle",i[i.FirstWait=1]="FirstWait",i[i.SecondWait=2]="SecondWait",i[i.WaitingForAsync=3]="WaitingForAsync",i[i.WaitingForAsyncShowingLoading=4]="WaitingForAsyncShowingLoading",i))(_||{}),p=(e=>(e[e.Delayed=0]="Delayed",e[e.Immediate=1]="Immediate",e))(p||{}),g=(e=>(e[e.Mouse=0]="Mouse",e[e.Keyboard=1]="Keyboard",e))(g||{});class m{constructor(s,e,t,n){this.value=s;this.isComplete=e;this.hasLoadingMessage=t;this.options=n}}class O extends o{constructor(e,t){super();this._editor=e;this._computer=t}_onResult=this._register(new h);onResult=this._onResult.event;_asyncComputationScheduler=this._register(new r(e=>this._triggerAsyncComputation(e),0));_syncComputationScheduler=this._register(new r(e=>this._triggerSyncComputation(e),0));_loadingMessageScheduler=this._register(new r(e=>this._triggerLoadingMessage(e),0));_state=0;_asyncIterable=null;_asyncIterableDone=!1;_result=[];_options;dispose(){this._asyncIterable&&(this._asyncIterable.cancel(),this._asyncIterable=null),this._options=void 0,super.dispose()}get _hoverTime(){return this._editor.getOption(d.hover).delay}get _firstWaitTime(){return this._hoverTime/2}get _secondWaitTime(){return this._hoverTime-this._firstWaitTime}get _loadingMessageTime(){return 3*this._hoverTime}_setState(e,t){this._state=e,this._fireResult(t)}_triggerAsyncComputation(e){this._setState(2,e),this._syncComputationScheduler.schedule(e,this._secondWaitTime),this._computer.computeAsync?(this._asyncIterableDone=!1,this._asyncIterable=c(t=>this._computer.computeAsync(e,t)),(async()=>{try{for await(const t of this._asyncIterable)t&&(this._result.push(t),this._fireResult(e));this._asyncIterableDone=!0,(this._state===3||this._state===4)&&this._setState(0,e)}catch(t){u(t)}})()):this._asyncIterableDone=!0}_triggerSyncComputation(e){this._computer.computeSync&&(this._result=this._result.concat(this._computer.computeSync(e))),this._setState(this._asyncIterableDone?0:3,e)}_triggerLoadingMessage(e){this._state===3&&this._setState(4,e)}_fireResult(e){if(this._state===1||this._state===2)return;const t=this._state===0,n=this._state===4;this._onResult.fire(new m(this._result.slice(0),t,n,e))}start(e,t){if(e===0)this._state===0&&(this._setState(1,t),this._asyncComputationScheduler.schedule(t,this._firstWaitTime),this._loadingMessageScheduler.schedule(t,this._loadingMessageTime));else switch(this._state){case 0:this._triggerAsyncComputation(t),this._syncComputationScheduler.cancel(),this._triggerSyncComputation(t);break;case 2:this._syncComputationScheduler.cancel(),this._triggerSyncComputation(t);break}}cancel(){this._asyncComputationScheduler.cancel(),this._syncComputationScheduler.cancel(),this._loadingMessageScheduler.cancel(),this._asyncIterable&&(this._asyncIterable.cancel(),this._asyncIterable=null),this._result=[],this._options=void 0,this._state=0}get options(){return this._options}}class r extends o{_scheduler;_options;constructor(s,e){super(),this._scheduler=this._register(new l(()=>s(this._options),e))}schedule(s,e){this._options=s,this._scheduler.schedule(e)}cancel(){this._scheduler.cancel()}}export{O as HoverOperation,m as HoverResult,p as HoverStartMode,g as HoverStartSource};
