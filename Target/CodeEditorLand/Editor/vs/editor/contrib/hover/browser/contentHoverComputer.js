import{coalesce as u}from"../../../../base/common/arrays.js";import{AsyncIterableObject as a}from"../../../../base/common/async.js";import{HoverAnchorType as l}from"./hoverTypes.js";class s{constructor(r,e){this._editor=r;this._participants=e}static _getLineDecorations(r,e){if(e.type!==l.Range&&!e.supportsMarkerHover)return[];const t=r.getModel(),o=e.range.startLineNumber;if(o>t.getLineCount())return[];const n=t.getLineMaxColumn(o);return r.getLineDecorations(o).filter(i=>{if(i.options.isWholeLine)return!0;const c=i.range.startLineNumber===o?i.range.startColumn:1,p=i.range.endLineNumber===o?i.range.endColumn:n;if(i.options.showIfCollapsed){if(c>e.range.startColumn+1||e.range.endColumn-1>p)return!1}else if(c>e.range.startColumn||e.range.endColumn>p)return!1;return!0})}computeAsync(r,e){const t=r.anchor;if(!this._editor.hasModel()||!t)return a.EMPTY;const o=s._getLineDecorations(this._editor,t);return a.merge(this._participants.map(n=>n.computeAsync?n.computeAsync(t,o,e):a.EMPTY))}computeSync(r){if(!this._editor.hasModel())return[];const e=r.anchor,t=s._getLineDecorations(this._editor,e);let o=[];for(const n of this._participants)o=o.concat(n.computeSync(e,t));return u(o)}}export{s as ContentHoverComputer};
