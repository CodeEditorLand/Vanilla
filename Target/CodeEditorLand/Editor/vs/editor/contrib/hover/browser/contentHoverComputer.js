import{coalesce as l}from"../../../../../vs/base/common/arrays.js";import{AsyncIterableObject as i}from"../../../../../vs/base/common/async.js";import"../../../../../vs/base/common/cancellation.js";import"../../../../../vs/editor/browser/editorBrowser.js";import"../../../../../vs/editor/common/model.js";import{HoverStartSource as p}from"../../../../../vs/editor/contrib/hover/browser/hoverOperation.js";import{HoverAnchorType as m}from"../../../../../vs/editor/contrib/hover/browser/hoverTypes.js";class s{constructor(r,e){this._editor=r;this._participants=e}_anchor=null;get anchor(){return this._anchor}set anchor(r){this._anchor=r}_shouldFocus=!1;get shouldFocus(){return this._shouldFocus}set shouldFocus(r){this._shouldFocus=r}_source=p.Mouse;get source(){return this._source}set source(r){this._source=r}_insistOnKeepingHoverVisible=!1;get insistOnKeepingHoverVisible(){return this._insistOnKeepingHoverVisible}set insistOnKeepingHoverVisible(r){this._insistOnKeepingHoverVisible=r}static _getLineDecorations(r,e){if(e.type!==m.Range&&!e.supportsMarkerHover)return[];const t=r.getModel(),o=e.range.startLineNumber;if(o>t.getLineCount())return[];const u=t.getLineMaxColumn(o);return r.getLineDecorations(o).filter(n=>{if(n.options.isWholeLine)return!0;const a=n.range.startLineNumber===o?n.range.startColumn:1,c=n.range.endLineNumber===o?n.range.endColumn:u;if(n.options.showIfCollapsed){if(a>e.range.startColumn+1||e.range.endColumn-1>c)return!1}else if(a>e.range.startColumn||e.range.endColumn>c)return!1;return!0})}computeAsync(r){const e=this._anchor;if(!this._editor.hasModel()||!e)return i.EMPTY;const t=s._getLineDecorations(this._editor,e);return i.merge(this._participants.map(o=>o.computeAsync?o.computeAsync(e,t,r):i.EMPTY))}computeSync(){if(!this._editor.hasModel()||!this._anchor)return[];const r=s._getLineDecorations(this._editor,this._anchor);let e=[];for(const t of this._participants)e=e.concat(t.computeSync(this._anchor,r));return l(e)}}export{s as ContentHoverComputer};
