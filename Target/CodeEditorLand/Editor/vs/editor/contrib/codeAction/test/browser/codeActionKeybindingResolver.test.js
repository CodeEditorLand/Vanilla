import t from"assert";import{KeyCodeChord as u}from"../../../../../base/common/keybindings.js";import{KeyCode as d}from"../../../../../base/common/keyCodes.js";import{OperatingSystem as f}from"../../../../../base/common/platform.js";import{ensureNoDisposablesAreLeakedInTestSuite as m}from"../../../../../base/test/common/utils.js";import{organizeImportsCommandId as y,refactorCommandId as c}from"../../browser/codeAction.js";import{CodeActionKeybindingResolver as s}from"../../browser/codeActionKeybindingResolver.js";import{CodeActionKind as i}from"../../common/types.js";import"../../../../../platform/keybinding/common/keybinding.js";import{ResolvedKeybindingItem as g}from"../../../../../platform/keybinding/common/resolvedKeybindingItem.js";import{USLayoutResolvedKeybinding as v}from"../../../../../platform/keybinding/common/usLayoutResolvedKeybinding.js";suite("CodeActionKeybindingResolver",()=>{m();const e=l(d.KeyA,c,{kind:i.Refactor.value}),r=l(d.KeyB,c,{kind:i.Refactor.append("extract").value}),o=l(d.KeyC,y,void 0);test("Should match refactor keybindings",async function(){const n=new s(a([e])).getResolver();t.strictEqual(n({title:""}),void 0),t.strictEqual(n({title:"",kind:i.Refactor.value}),e.resolvedKeybinding),t.strictEqual(n({title:"",kind:i.Refactor.append("extract").value}),e.resolvedKeybinding),t.strictEqual(n({title:"",kind:i.QuickFix.value}),void 0)}),test("Should prefer most specific keybinding",async function(){const n=new s(a([e,r,o])).getResolver();t.strictEqual(n({title:"",kind:i.Refactor.value}),e.resolvedKeybinding),t.strictEqual(n({title:"",kind:i.Refactor.append("extract").value}),r.resolvedKeybinding)}),test("Organize imports should still return a keybinding even though it does not have args",async function(){const n=new s(a([e,r,o])).getResolver();t.strictEqual(n({title:"",kind:i.SourceOrganizeImports.value}),o.resolvedKeybinding)})});function a(e){return{getKeybindings:()=>e}}function l(e,r,o){return new g(new v([new u(!1,!0,!1,!1,e)],f.Linux),r,o,void 0,!1,null,!1)}
