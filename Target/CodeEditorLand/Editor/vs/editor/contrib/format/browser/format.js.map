{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/contrib/format/browser/format.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { asArray, isNonEmptyArray } from '../../../../base/common/arrays.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { Iterable } from '../../../../base/common/iterator.js';\nimport { IDisposable } from '../../../../base/common/lifecycle.js';\nimport { LinkedList } from '../../../../base/common/linkedList.js';\nimport { assertType } from '../../../../base/common/types.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { CodeEditorStateFlag, EditorStateCancellationTokenSource, TextModelCancellationTokenSource } from '../../editorState/browser/editorState.js';\nimport { IActiveCodeEditor, isCodeEditor } from '../../../browser/editorBrowser.js';\nimport { ServicesAccessor } from '../../../browser/editorExtensions.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { ScrollType } from '../../../common/editorCommon.js';\nimport { ITextModel } from '../../../common/model.js';\nimport { DocumentFormattingEditProvider, DocumentRangeFormattingEditProvider, FormattingOptions, TextEdit } from '../../../common/languages.js';\nimport { IEditorWorkerService } from '../../../common/services/editorWorker.js';\nimport { ITextModelService } from '../../../common/services/resolverService.js';\nimport { FormattingEdit } from './formattingEdit.js';\nimport { CommandsRegistry } from '../../../../platform/commands/common/commands.js';\nimport { ExtensionIdentifierSet } from '../../../../platform/extensions/common/extensions.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IProgress } from '../../../../platform/progress/common/progress.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { LanguageFeatureRegistry } from '../../../common/languageFeatureRegistry.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { AccessibilitySignal, IAccessibilitySignalService } from '../../../../platform/accessibilitySignal/browser/accessibilitySignalService.js';\n\nexport function getRealAndSyntheticDocumentFormattersOrdered(\n\tdocumentFormattingEditProvider: LanguageFeatureRegistry<DocumentFormattingEditProvider>,\n\tdocumentRangeFormattingEditProvider: LanguageFeatureRegistry<DocumentRangeFormattingEditProvider>,\n\tmodel: ITextModel\n): DocumentFormattingEditProvider[] {\n\tconst result: DocumentFormattingEditProvider[] = [];\n\tconst seen = new ExtensionIdentifierSet();\n\n\t// (1) add all document formatter\n\tconst docFormatter = documentFormattingEditProvider.ordered(model);\n\tfor (const formatter of docFormatter) {\n\t\tresult.push(formatter);\n\t\tif (formatter.extensionId) {\n\t\t\tseen.add(formatter.extensionId);\n\t\t}\n\t}\n\n\t// (2) add all range formatter as document formatter (unless the same extension already did that)\n\tconst rangeFormatter = documentRangeFormattingEditProvider.ordered(model);\n\tfor (const formatter of rangeFormatter) {\n\t\tif (formatter.extensionId) {\n\t\t\tif (seen.has(formatter.extensionId)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tseen.add(formatter.extensionId);\n\t\t}\n\t\tresult.push({\n\t\t\tdisplayName: formatter.displayName,\n\t\t\textensionId: formatter.extensionId,\n\t\t\tprovideDocumentFormattingEdits(model, options, token) {\n\t\t\t\treturn formatter.provideDocumentRangeFormattingEdits(model, model.getFullModelRange(), options, token);\n\t\t\t}\n\t\t});\n\t}\n\treturn result;\n}\n\nexport const enum FormattingKind {\n\tFile = 1,\n\tSelection = 2\n}\n\nexport const enum FormattingMode {\n\tExplicit = 1,\n\tSilent = 2\n}\n\nexport interface IFormattingEditProviderSelector {\n\t<T extends (DocumentFormattingEditProvider | DocumentRangeFormattingEditProvider)>(formatter: T[], document: ITextModel, mode: FormattingMode, kind: FormattingKind): Promise<T | undefined>;\n}\n\nexport abstract class FormattingConflicts {\n\n\tprivate static readonly _selectors = new LinkedList<IFormattingEditProviderSelector>();\n\n\tstatic setFormatterSelector(selector: IFormattingEditProviderSelector): IDisposable {\n\t\tconst remove = FormattingConflicts._selectors.unshift(selector);\n\t\treturn { dispose: remove };\n\t}\n\n\tstatic async select<T extends (DocumentFormattingEditProvider | DocumentRangeFormattingEditProvider)>(formatter: T[], document: ITextModel, mode: FormattingMode, kind: FormattingKind): Promise<T | undefined> {\n\t\tif (formatter.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst selector = Iterable.first(FormattingConflicts._selectors);\n\t\tif (selector) {\n\t\t\treturn await selector(formatter, document, mode, kind);\n\t\t}\n\t\treturn undefined;\n\t}\n}\n\nexport async function formatDocumentRangesWithSelectedProvider(\n\taccessor: ServicesAccessor,\n\teditorOrModel: ITextModel | IActiveCodeEditor,\n\trangeOrRanges: Range | Range[],\n\tmode: FormattingMode,\n\tprogress: IProgress<DocumentRangeFormattingEditProvider>,\n\ttoken: CancellationToken,\n\tuserGesture: boolean\n): Promise<void> {\n\n\tconst instaService = accessor.get(IInstantiationService);\n\tconst { documentRangeFormattingEditProvider: documentRangeFormattingEditProviderRegistry } = accessor.get(ILanguageFeaturesService);\n\tconst model = isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;\n\tconst provider = documentRangeFormattingEditProviderRegistry.ordered(model);\n\tconst selected = await FormattingConflicts.select(provider, model, mode, FormattingKind.Selection);\n\tif (selected) {\n\t\tprogress.report(selected);\n\t\tawait instaService.invokeFunction(formatDocumentRangesWithProvider, selected, editorOrModel, rangeOrRanges, token, userGesture);\n\t}\n}\n\nexport async function formatDocumentRangesWithProvider(\n\taccessor: ServicesAccessor,\n\tprovider: DocumentRangeFormattingEditProvider,\n\teditorOrModel: ITextModel | IActiveCodeEditor,\n\trangeOrRanges: Range | Range[],\n\ttoken: CancellationToken,\n\tuserGesture: boolean\n): Promise<boolean> {\n\tconst workerService = accessor.get(IEditorWorkerService);\n\tconst logService = accessor.get(ILogService);\n\tconst accessibilitySignalService = accessor.get(IAccessibilitySignalService);\n\n\tlet model: ITextModel;\n\tlet cts: CancellationTokenSource;\n\tif (isCodeEditor(editorOrModel)) {\n\t\tmodel = editorOrModel.getModel();\n\t\tcts = new EditorStateCancellationTokenSource(editorOrModel, CodeEditorStateFlag.Value | CodeEditorStateFlag.Position, undefined, token);\n\t} else {\n\t\tmodel = editorOrModel;\n\t\tcts = new TextModelCancellationTokenSource(editorOrModel, token);\n\t}\n\n\t// make sure that ranges don't overlap nor touch each other\n\tconst ranges: Range[] = [];\n\tlet len = 0;\n\tfor (const range of asArray(rangeOrRanges).sort(Range.compareRangesUsingStarts)) {\n\t\tif (len > 0 && Range.areIntersectingOrTouching(ranges[len - 1], range)) {\n\t\t\tranges[len - 1] = Range.fromPositions(ranges[len - 1].getStartPosition(), range.getEndPosition());\n\t\t} else {\n\t\t\tlen = ranges.push(range);\n\t\t}\n\t}\n\n\tconst computeEdits = async (range: Range) => {\n\t\tlogService.trace(`[format][provideDocumentRangeFormattingEdits] (request)`, provider.extensionId?.value, range);\n\n\t\tconst result = (await provider.provideDocumentRangeFormattingEdits(\n\t\t\tmodel,\n\t\t\trange,\n\t\t\tmodel.getFormattingOptions(),\n\t\t\tcts.token\n\t\t)) || [];\n\n\t\tlogService.trace(`[format][provideDocumentRangeFormattingEdits] (response)`, provider.extensionId?.value, result);\n\n\t\treturn result;\n\t};\n\n\tconst hasIntersectingEdit = (a: TextEdit[], b: TextEdit[]) => {\n\t\tif (!a.length || !b.length) {\n\t\t\treturn false;\n\t\t}\n\t\t// quick exit if the list of ranges are completely unrelated [O(n)]\n\t\tconst mergedA = a.reduce((acc, val) => { return Range.plusRange(acc, val.range); }, a[0].range);\n\t\tif (!b.some(x => { return Range.intersectRanges(mergedA, x.range); })) {\n\t\t\treturn false;\n\t\t}\n\t\t// fallback to a complete check [O(n^2)]\n\t\tfor (const edit of a) {\n\t\t\tfor (const otherEdit of b) {\n\t\t\t\tif (Range.intersectRanges(edit.range, otherEdit.range)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t};\n\n\tconst allEdits: TextEdit[] = [];\n\tconst rawEditsList: TextEdit[][] = [];\n\ttry {\n\t\tif (typeof provider.provideDocumentRangesFormattingEdits === 'function') {\n\t\t\tlogService.trace(`[format][provideDocumentRangeFormattingEdits] (request)`, provider.extensionId?.value, ranges);\n\t\t\tconst result = (await provider.provideDocumentRangesFormattingEdits(\n\t\t\t\tmodel,\n\t\t\t\tranges,\n\t\t\t\tmodel.getFormattingOptions(),\n\t\t\t\tcts.token\n\t\t\t)) || [];\n\t\t\tlogService.trace(`[format][provideDocumentRangeFormattingEdits] (response)`, provider.extensionId?.value, result);\n\t\t\trawEditsList.push(result);\n\t\t} else {\n\n\t\t\tfor (const range of ranges) {\n\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\trawEditsList.push(await computeEdits(range));\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < ranges.length; ++i) {\n\t\t\t\tfor (let j = i + 1; j < ranges.length; ++j) {\n\t\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tif (hasIntersectingEdit(rawEditsList[i], rawEditsList[j])) {\n\t\t\t\t\t\t// Merge ranges i and j into a single range, recompute the associated edits\n\t\t\t\t\t\tconst mergedRange = Range.plusRange(ranges[i], ranges[j]);\n\t\t\t\t\t\tconst edits = await computeEdits(mergedRange);\n\t\t\t\t\t\tranges.splice(j, 1);\n\t\t\t\t\t\tranges.splice(i, 1);\n\t\t\t\t\t\tranges.push(mergedRange);\n\t\t\t\t\t\trawEditsList.splice(j, 1);\n\t\t\t\t\t\trawEditsList.splice(i, 1);\n\t\t\t\t\t\trawEditsList.push(edits);\n\t\t\t\t\t\t// Restart scanning\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const rawEdits of rawEditsList) {\n\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tconst minimalEdits = await workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n\t\t\tif (minimalEdits) {\n\t\t\t\tallEdits.push(...minimalEdits);\n\t\t\t}\n\t\t}\n\t} finally {\n\t\tcts.dispose();\n\t}\n\n\tif (allEdits.length === 0) {\n\t\treturn false;\n\t}\n\n\tif (isCodeEditor(editorOrModel)) {\n\t\t// use editor to apply edits\n\t\tFormattingEdit.execute(editorOrModel, allEdits, true);\n\t\teditorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), ScrollType.Immediate);\n\n\t} else {\n\t\t// use model to apply edits\n\t\tconst [{ range }] = allEdits;\n\t\tconst initialSelection = new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n\t\tmodel.pushEditOperations([initialSelection], allEdits.map(edit => {\n\t\t\treturn {\n\t\t\t\ttext: edit.text,\n\t\t\t\trange: Range.lift(edit.range),\n\t\t\t\tforceMoveMarkers: true\n\t\t\t};\n\t\t}), undoEdits => {\n\t\t\tfor (const { range } of undoEdits) {\n\t\t\t\tif (Range.areIntersectingOrTouching(range, initialSelection)) {\n\t\t\t\t\treturn [new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn)];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\t}\n\taccessibilitySignalService.playSignal(AccessibilitySignal.format, { userGesture });\n\treturn true;\n}\n\nexport async function formatDocumentWithSelectedProvider(\n\taccessor: ServicesAccessor,\n\teditorOrModel: ITextModel | IActiveCodeEditor,\n\tmode: FormattingMode,\n\tprogress: IProgress<DocumentFormattingEditProvider>,\n\ttoken: CancellationToken,\n\tuserGesture?: boolean\n): Promise<void> {\n\n\tconst instaService = accessor.get(IInstantiationService);\n\tconst languageFeaturesService = accessor.get(ILanguageFeaturesService);\n\tconst model = isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;\n\tconst provider = getRealAndSyntheticDocumentFormattersOrdered(languageFeaturesService.documentFormattingEditProvider, languageFeaturesService.documentRangeFormattingEditProvider, model);\n\tconst selected = await FormattingConflicts.select(provider, model, mode, FormattingKind.File);\n\tif (selected) {\n\t\tprogress.report(selected);\n\t\tawait instaService.invokeFunction(formatDocumentWithProvider, selected, editorOrModel, mode, token, userGesture);\n\t}\n}\n\nexport async function formatDocumentWithProvider(\n\taccessor: ServicesAccessor,\n\tprovider: DocumentFormattingEditProvider,\n\teditorOrModel: ITextModel | IActiveCodeEditor,\n\tmode: FormattingMode,\n\ttoken: CancellationToken,\n\tuserGesture?: boolean\n): Promise<boolean> {\n\tconst workerService = accessor.get(IEditorWorkerService);\n\tconst accessibilitySignalService = accessor.get(IAccessibilitySignalService);\n\n\tlet model: ITextModel;\n\tlet cts: CancellationTokenSource;\n\tif (isCodeEditor(editorOrModel)) {\n\t\tmodel = editorOrModel.getModel();\n\t\tcts = new EditorStateCancellationTokenSource(editorOrModel, CodeEditorStateFlag.Value | CodeEditorStateFlag.Position, undefined, token);\n\t} else {\n\t\tmodel = editorOrModel;\n\t\tcts = new TextModelCancellationTokenSource(editorOrModel, token);\n\t}\n\n\tlet edits: TextEdit[] | undefined;\n\ttry {\n\t\tconst rawEdits = await provider.provideDocumentFormattingEdits(\n\t\t\tmodel,\n\t\t\tmodel.getFormattingOptions(),\n\t\t\tcts.token\n\t\t);\n\n\t\tedits = await workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n\n\t\tif (cts.token.isCancellationRequested) {\n\t\t\treturn true;\n\t\t}\n\n\t} finally {\n\t\tcts.dispose();\n\t}\n\n\tif (!edits || edits.length === 0) {\n\t\treturn false;\n\t}\n\n\tif (isCodeEditor(editorOrModel)) {\n\t\t// use editor to apply edits\n\t\tFormattingEdit.execute(editorOrModel, edits, mode !== FormattingMode.Silent);\n\n\t\tif (mode !== FormattingMode.Silent) {\n\t\t\teditorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), ScrollType.Immediate);\n\t\t}\n\n\t} else {\n\t\t// use model to apply edits\n\t\tconst [{ range }] = edits;\n\t\tconst initialSelection = new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n\t\tmodel.pushEditOperations([initialSelection], edits.map(edit => {\n\t\t\treturn {\n\t\t\t\ttext: edit.text,\n\t\t\t\trange: Range.lift(edit.range),\n\t\t\t\tforceMoveMarkers: true\n\t\t\t};\n\t\t}), undoEdits => {\n\t\t\tfor (const { range } of undoEdits) {\n\t\t\t\tif (Range.areIntersectingOrTouching(range, initialSelection)) {\n\t\t\t\t\treturn [new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn)];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\t}\n\taccessibilitySignalService.playSignal(AccessibilitySignal.format, { userGesture });\n\treturn true;\n}\n\nexport async function getDocumentRangeFormattingEditsUntilResult(\n\tworkerService: IEditorWorkerService,\n\tlanguageFeaturesService: ILanguageFeaturesService,\n\tmodel: ITextModel,\n\trange: Range,\n\toptions: FormattingOptions,\n\ttoken: CancellationToken\n): Promise<TextEdit[] | undefined> {\n\n\tconst providers = languageFeaturesService.documentRangeFormattingEditProvider.ordered(model);\n\tfor (const provider of providers) {\n\t\tconst rawEdits = await Promise.resolve(provider.provideDocumentRangeFormattingEdits(model, range, options, token)).catch(onUnexpectedExternalError);\n\t\tif (isNonEmptyArray(rawEdits)) {\n\t\t\treturn await workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n\t\t}\n\t}\n\treturn undefined;\n}\n\nexport async function getDocumentFormattingEditsUntilResult(\n\tworkerService: IEditorWorkerService,\n\tlanguageFeaturesService: ILanguageFeaturesService,\n\tmodel: ITextModel,\n\toptions: FormattingOptions,\n\ttoken: CancellationToken\n): Promise<TextEdit[] | undefined> {\n\n\tconst providers = getRealAndSyntheticDocumentFormattersOrdered(languageFeaturesService.documentFormattingEditProvider, languageFeaturesService.documentRangeFormattingEditProvider, model);\n\tfor (const provider of providers) {\n\t\tconst rawEdits = await Promise.resolve(provider.provideDocumentFormattingEdits(model, options, token)).catch(onUnexpectedExternalError);\n\t\tif (isNonEmptyArray(rawEdits)) {\n\t\t\treturn await workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n\t\t}\n\t}\n\treturn undefined;\n}\n\nexport async function getDocumentFormattingEditsWithSelectedProvider(\n\tworkerService: IEditorWorkerService,\n\tlanguageFeaturesService: ILanguageFeaturesService,\n\teditorOrModel: ITextModel | IActiveCodeEditor,\n\tmode: FormattingMode,\n\ttoken: CancellationToken,\n): Promise<TextEdit[] | undefined> {\n\tconst model = isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;\n\tconst provider = getRealAndSyntheticDocumentFormattersOrdered(languageFeaturesService.documentFormattingEditProvider, languageFeaturesService.documentRangeFormattingEditProvider, model);\n\tconst selected = await FormattingConflicts.select(provider, model, mode, FormattingKind.File);\n\tif (selected) {\n\t\tconst rawEdits = await Promise.resolve(selected.provideDocumentFormattingEdits(model, model.getOptions(), token)).catch(onUnexpectedExternalError);\n\t\treturn await workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n\t}\n\treturn undefined;\n}\n\nexport function getOnTypeFormattingEdits(\n\tworkerService: IEditorWorkerService,\n\tlanguageFeaturesService: ILanguageFeaturesService,\n\tmodel: ITextModel,\n\tposition: Position,\n\tch: string,\n\toptions: FormattingOptions,\n\ttoken: CancellationToken\n): Promise<TextEdit[] | null | undefined> {\n\n\tconst providers = languageFeaturesService.onTypeFormattingEditProvider.ordered(model);\n\n\tif (providers.length === 0) {\n\t\treturn Promise.resolve(undefined);\n\t}\n\n\tif (providers[0].autoFormatTriggerCharacters.indexOf(ch) < 0) {\n\t\treturn Promise.resolve(undefined);\n\t}\n\n\treturn Promise.resolve(providers[0].provideOnTypeFormattingEdits(model, position, ch, options, token)).catch(onUnexpectedExternalError).then(edits => {\n\t\treturn workerService.computeMoreMinimalEdits(model.uri, edits);\n\t});\n}\n\nCommandsRegistry.registerCommand('_executeFormatRangeProvider', async function (accessor, ...args) {\n\tconst [resource, range, options] = args;\n\tassertType(URI.isUri(resource));\n\tassertType(Range.isIRange(range));\n\n\tconst resolverService = accessor.get(ITextModelService);\n\tconst workerService = accessor.get(IEditorWorkerService);\n\tconst languageFeaturesService = accessor.get(ILanguageFeaturesService);\n\tconst reference = await resolverService.createModelReference(resource);\n\ttry {\n\t\treturn getDocumentRangeFormattingEditsUntilResult(workerService, languageFeaturesService, reference.object.textEditorModel, Range.lift(range), options, CancellationToken.None);\n\t} finally {\n\t\treference.dispose();\n\t}\n});\n\nCommandsRegistry.registerCommand('_executeFormatDocumentProvider', async function (accessor, ...args) {\n\tconst [resource, options] = args;\n\tassertType(URI.isUri(resource));\n\n\tconst resolverService = accessor.get(ITextModelService);\n\tconst workerService = accessor.get(IEditorWorkerService);\n\tconst languageFeaturesService = accessor.get(ILanguageFeaturesService);\n\tconst reference = await resolverService.createModelReference(resource);\n\ttry {\n\t\treturn getDocumentFormattingEditsUntilResult(workerService, languageFeaturesService, reference.object.textEditorModel, options, CancellationToken.None);\n\t} finally {\n\t\treference.dispose();\n\t}\n});\n\nCommandsRegistry.registerCommand('_executeFormatOnTypeProvider', async function (accessor, ...args) {\n\tconst [resource, position, ch, options] = args;\n\tassertType(URI.isUri(resource));\n\tassertType(Position.isIPosition(position));\n\tassertType(typeof ch === 'string');\n\n\tconst resolverService = accessor.get(ITextModelService);\n\tconst workerService = accessor.get(IEditorWorkerService);\n\tconst languageFeaturesService = accessor.get(ILanguageFeaturesService);\n\tconst reference = await resolverService.createModelReference(resource);\n\ttry {\n\t\treturn getOnTypeFormattingEdits(workerService, languageFeaturesService, reference.object.textEditorModel, Position.lift(position), ch, options, CancellationToken.None);\n\t} finally {\n\t\treference.dispose();\n\t}\n});\n"],
  "mappings": "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",
  "names": ["model", "FormattingKind", "FormattingMode", "range"]
}
