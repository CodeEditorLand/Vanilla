{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/contrib/indentation/common/indentation.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from '../../../../base/common/strings.js';\nimport { ShiftCommand } from '../../../common/commands/shiftCommand.js';\nimport { EditOperation, ISingleEditOperation } from '../../../common/core/editOperation.js';\nimport { normalizeIndentation } from '../../../common/core/indentation.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { StandardTokenType } from '../../../common/encodedTokenAttributes.js';\nimport { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry.js';\nimport { ProcessedIndentRulesSupport } from '../../../common/languages/supports/indentationLineProcessor.js';\nimport { ITextModel } from '../../../common/model.js';\n\nexport function getReindentEditOperations(model: ITextModel, languageConfigurationService: ILanguageConfigurationService, startLineNumber: number, endLineNumber: number): ISingleEditOperation[] {\n\tif (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {\n\t\t// Model is empty\n\t\treturn [];\n\t}\n\n\tconst indentationRulesSupport = languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).indentRulesSupport;\n\tif (!indentationRulesSupport) {\n\t\treturn [];\n\t}\n\n\tconst processedIndentRulesSupport = new ProcessedIndentRulesSupport(model, indentationRulesSupport, languageConfigurationService);\n\tendLineNumber = Math.min(endLineNumber, model.getLineCount());\n\n\t// Skip `unIndentedLinePattern` lines\n\twhile (startLineNumber <= endLineNumber) {\n\t\tif (!processedIndentRulesSupport.shouldIgnore(startLineNumber)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tstartLineNumber++;\n\t}\n\n\tif (startLineNumber > endLineNumber - 1) {\n\t\treturn [];\n\t}\n\n\tconst { tabSize, indentSize, insertSpaces } = model.getOptions();\n\tconst shiftIndent = (indentation: string, count?: number) => {\n\t\tcount = count || 1;\n\t\treturn ShiftCommand.shiftIndent(indentation, indentation.length + count, tabSize, indentSize, insertSpaces);\n\t};\n\tconst unshiftIndent = (indentation: string, count?: number) => {\n\t\tcount = count || 1;\n\t\treturn ShiftCommand.unshiftIndent(indentation, indentation.length + count, tabSize, indentSize, insertSpaces);\n\t};\n\tconst indentEdits: ISingleEditOperation[] = [];\n\n\t// indentation being passed to lines below\n\n\t// Calculate indentation for the first line\n\t// If there is no passed-in indentation, we use the indentation of the first line as base.\n\tconst currentLineText = model.getLineContent(startLineNumber);\n\tlet globalIndent = strings.getLeadingWhitespace(currentLineText);\n\t// idealIndentForNextLine doesn't equal globalIndent when there is a line matching `indentNextLinePattern`.\n\tlet idealIndentForNextLine: string = globalIndent;\n\n\tif (processedIndentRulesSupport.shouldIncrease(startLineNumber)) {\n\t\tidealIndentForNextLine = shiftIndent(idealIndentForNextLine);\n\t\tglobalIndent = shiftIndent(globalIndent);\n\t}\n\telse if (processedIndentRulesSupport.shouldIndentNextLine(startLineNumber)) {\n\t\tidealIndentForNextLine = shiftIndent(idealIndentForNextLine);\n\t}\n\n\tstartLineNumber++;\n\n\t// Calculate indentation adjustment for all following lines\n\tfor (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n\t\tif (doesLineStartWithString(model, lineNumber)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst text = model.getLineContent(lineNumber);\n\t\tconst oldIndentation = strings.getLeadingWhitespace(text);\n\t\tconst currentIdealIndent = idealIndentForNextLine;\n\n\t\tif (processedIndentRulesSupport.shouldDecrease(lineNumber, currentIdealIndent)) {\n\t\t\tidealIndentForNextLine = unshiftIndent(idealIndentForNextLine);\n\t\t\tglobalIndent = unshiftIndent(globalIndent);\n\t\t}\n\n\t\tif (oldIndentation !== idealIndentForNextLine) {\n\t\t\tindentEdits.push(EditOperation.replaceMove(new Selection(lineNumber, 1, lineNumber, oldIndentation.length + 1), normalizeIndentation(idealIndentForNextLine, indentSize, insertSpaces)));\n\t\t}\n\n\t\t// calculate idealIndentForNextLine\n\t\tif (processedIndentRulesSupport.shouldIgnore(lineNumber)) {\n\t\t\t// In reindent phase, if the line matches `unIndentedLinePattern` we inherit indentation from above lines\n\t\t\t// but don't change globalIndent and idealIndentForNextLine.\n\t\t\tcontinue;\n\t\t} else if (processedIndentRulesSupport.shouldIncrease(lineNumber, currentIdealIndent)) {\n\t\t\tglobalIndent = shiftIndent(globalIndent);\n\t\t\tidealIndentForNextLine = globalIndent;\n\t\t} else if (processedIndentRulesSupport.shouldIndentNextLine(lineNumber, currentIdealIndent)) {\n\t\t\tidealIndentForNextLine = shiftIndent(idealIndentForNextLine);\n\t\t} else {\n\t\t\tidealIndentForNextLine = globalIndent;\n\t\t}\n\t}\n\n\treturn indentEdits;\n}\n\nfunction doesLineStartWithString(model: ITextModel, lineNumber: number): boolean {\n\tif (!model.tokenization.isCheapToTokenize(lineNumber)) {\n\t\treturn false;\n\t}\n\tconst lineTokens = model.tokenization.getLineTokens(lineNumber);\n\treturn lineTokens.getStandardTokenType(0) === StandardTokenType.String;\n}\n"],
  "mappings": "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",
  "names": []
}
