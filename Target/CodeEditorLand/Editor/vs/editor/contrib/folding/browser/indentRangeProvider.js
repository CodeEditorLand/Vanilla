import{computeIndentLevel as f}from"../../../common/model/utils.js";import{FoldingRegions as p,MAX_LINE_NUMBER as _}from"./foldingRanges.js";const R=5e3,I="indent";class F{constructor(l,n,t){this.editorModel=l;this.languageConfigurationService=n;this.foldingRangesLimit=t}id=I;dispose(){}compute(l){const n=this.languageConfigurationService.getLanguageConfiguration(this.editorModel.getLanguageId()).foldingRules,t=n&&!!n.offSide,s=n&&n.markers;return Promise.resolve(x(this.editorModel,t,s,this.foldingRangesLimit))}}class v{_startIndexes;_endIndexes;_indentOccurrences;_length;_foldingRangesLimit;constructor(l){this._startIndexes=[],this._endIndexes=[],this._indentOccurrences=[],this._length=0,this._foldingRangesLimit=l}insertFirst(l,n,t){if(l>_||n>_)return;const s=this._length;this._startIndexes[s]=l,this._endIndexes[s]=n,this._length++,t<1e3&&(this._indentOccurrences[t]=(this._indentOccurrences[t]||0)+1)}toIndentRanges(l){const n=this._foldingRangesLimit.limit;if(this._length<=n){this._foldingRangesLimit.update(this._length,!1);const t=new Uint32Array(this._length),s=new Uint32Array(this._length);for(let d=this._length-1,a=0;d>=0;d--,a++)t[a]=this._startIndexes[d],s[a]=this._endIndexes[d];return new p(t,s)}else{this._foldingRangesLimit.update(this._length,n);let t=0,s=this._indentOccurrences.length;for(let r=0;r<this._indentOccurrences.length;r++){const e=this._indentOccurrences[r];if(e){if(e+t>n){s=r;break}t+=e}}const d=l.getOptions().tabSize,a=new Uint32Array(n),i=new Uint32Array(n);for(let r=this._length-1,e=0;r>=0;r--){const h=this._startIndexes[r],g=l.getLineContent(h),o=f(g,d);(o<s||o===s&&t++<n)&&(a[e]=h,i[e]=this._endIndexes[r],e++)}return new p(a,i)}}}const b={limit:R,update:()=>{}};function x(u,l,n,t=b){const s=u.getOptions().tabSize,d=new v(t);let a;n&&(a=new RegExp(`(${n.start.source})|(?:${n.end.source})`));const i=[],r=u.getLineCount()+1;i.push({indent:-1,endAbove:r,line:r});for(let e=u.getLineCount();e>0;e--){const h=u.getLineContent(e),g=f(h,s);let o=i[i.length-1];if(g===-1){l&&(o.endAbove=e);continue}let m;if(a&&(m=h.match(a)))if(m[1]){let c=i.length-1;for(;c>0&&i[c].indent!==-2;)c--;if(c>0){i.length=c+1,o=i[c],d.insertFirst(e,o.line,g),o.line=e,o.indent=g,o.endAbove=e;continue}}else{i.push({indent:-2,endAbove:e,line:e});continue}if(o.indent>g){do i.pop(),o=i[i.length-1];while(o.indent>g);const c=o.endAbove-1;c-e>=1&&d.insertFirst(e,c,g)}o.indent===g?o.endAbove=e:i.push({indent:g,endAbove:e,line:e})}return d.toIndentRanges(u)}export{F as IndentRangeProvider,v as RangesCollector,x as computeRanges};
