var j=Object.defineProperty;var W=Object.getOwnPropertyDescriptor;var w=(d,n,e,o)=>{for(var t=o>1?void 0:o?W(n,e):n,i=d.length-1,r;i>=0;i--)(r=d[i])&&(t=(o?r(n,e,t):r(t))||t);return o&&t&&j(n,e,t),t},M=(d,n)=>(e,o)=>n(e,o,d);import{createCancelablePromise as q,Delayer as J,RunOnceScheduler as Y}from"../../../../../vs/base/common/async.js";import{CancellationToken as $}from"../../../../../vs/base/common/cancellation.js";import{illegalArgument as N,onUnexpectedError as O}from"../../../../../vs/base/common/errors.js";import{KeyChord as R,KeyCode as g,KeyMod as s}from"../../../../../vs/base/common/keyCodes.js";import{Disposable as Q,DisposableStore as Z}from"../../../../../vs/base/common/lifecycle.js";import{escapeRegExpCharacters as ee}from"../../../../../vs/base/common/strings.js";import*as L from"../../../../../vs/base/common/types.js";import"vs/css!./folding";import{Emitter as oe}from"../../../../../vs/base/common/event.js";import{StopWatch as te}from"../../../../../vs/base/common/stopwatch.js";import{URI as ie}from"../../../../../vs/base/common/uri.js";import{MouseTargetType as P}from"../../../../../vs/editor/browser/editorBrowser.js";import{EditorAction as ne,EditorContributionInstantiation as re,registerEditorAction as C,registerEditorContribution as le,registerInstantiatedEditorAction as de}from"../../../../../vs/editor/browser/editorExtensions.js";import{StableEditorScrollState as se}from"../../../../../vs/editor/browser/stableEditorScroll.js";import{EditorOption as c}from"../../../../../vs/editor/common/config/editorOptions.js";import"../../../../../vs/editor/common/core/position.js";import"../../../../../vs/editor/common/core/range.js";import"../../../../../vs/editor/common/core/selection.js";import{ScrollType as ae}from"../../../../../vs/editor/common/editorCommon.js";import{EditorContextKeys as f}from"../../../../../vs/editor/common/editorContextKeys.js";import{FoldingRangeKind as x}from"../../../../../vs/editor/common/languages.js";import{ILanguageConfigurationService as _}from"../../../../../vs/editor/common/languages/languageConfigurationRegistry.js";import"../../../../../vs/editor/common/model.js";import{ILanguageFeatureDebounceService as ge}from"../../../../../vs/editor/common/services/languageFeatureDebounce.js";import{ILanguageFeaturesService as K}from"../../../../../vs/editor/common/services/languageFeatures.js";import{IModelService as ce}from"../../../../../vs/editor/common/services/model.js";import"../../../../../vs/editor/common/textModelEvents.js";import{FoldingModel as ue,getNextFoldLine as fe,getParentFoldLine as pe,getPreviousFoldLine as he,setCollapseStateAtLevel as me,setCollapseStateForMatchingLines as D,setCollapseStateForRest as U,setCollapseStateForType as T,setCollapseStateLevelsDown as I,setCollapseStateLevelsUp as B,setCollapseStateUp as Ce,toggleCollapseState as z}from"../../../../../vs/editor/contrib/folding/browser/foldingModel.js";import{HiddenRangeModel as ve}from"../../../../../vs/editor/contrib/folding/browser/hiddenRangeModel.js";import{IndentRangeProvider as H}from"../../../../../vs/editor/contrib/folding/browser/indentRangeProvider.js";import*as p from"../../../../../vs/nls.js";import{CommandsRegistry as be}from"../../../../../vs/platform/commands/common/commands.js";import{IConfigurationService as Fe}from"../../../../../vs/platform/configuration/common/configuration.js";import{IContextKeyService as Re,RawContextKey as Ee}from"../../../../../vs/platform/contextkey/common/contextkey.js";import{KeybindingWeight as h}from"../../../../../vs/platform/keybinding/common/keybindingsRegistry.js";import{INotificationService as ye}from"../../../../../vs/platform/notification/common/notification.js";import{FoldingDecorationProvider as Se}from"./foldingDecorations.js";import{FoldingRegions as V,FoldSource as Le}from"./foldingRanges.js";import{SyntaxRangeProvider as G}from"./syntaxRangeProvider.js";const u=new Ee("foldingEnabled",!1);let E=class extends Q{constructor(e,o,t,i,r,l){super();this.contextKeyService=o;this.languageConfigurationService=t;this.languageFeaturesService=l;this.editor=e,this._foldingLimitReporter=new Me(e);const a=this.editor.getOptions();this._isEnabled=a.get(c.folding),this._useFoldingProviders=a.get(c.foldingStrategy)!=="indentation",this._unfoldOnClickAfterEndOfLine=a.get(c.unfoldOnClickAfterEndOfLine),this._restoringViewState=!1,this._currentModelHasFoldedImports=!1,this._foldingImportsByDefault=a.get(c.foldingImportsByDefault),this.updateDebounceInfo=r.for(l.foldingRangeProvider,"Folding",{min:200}),this.foldingModel=null,this.hiddenRangeModel=null,this.rangeProvider=null,this.foldingRegionPromise=null,this.foldingModelPromise=null,this.updateScheduler=null,this.cursorChangedScheduler=null,this.mouseDownInfo=null,this.foldingDecorationProvider=new Se(e),this.foldingDecorationProvider.showFoldingControls=a.get(c.showFoldingControls),this.foldingDecorationProvider.showFoldingHighlights=a.get(c.foldingHighlight),this.foldingEnabled=u.bindTo(this.contextKeyService),this.foldingEnabled.set(this._isEnabled),this._register(this.editor.onDidChangeModel(()=>this.onModelChanged())),this._register(this.editor.onDidChangeConfiguration(F=>{if(F.hasChanged(c.folding)&&(this._isEnabled=this.editor.getOptions().get(c.folding),this.foldingEnabled.set(this._isEnabled),this.onModelChanged()),F.hasChanged(c.foldingMaximumRegions)&&this.onModelChanged(),F.hasChanged(c.showFoldingControls)||F.hasChanged(c.foldingHighlight)){const v=this.editor.getOptions();this.foldingDecorationProvider.showFoldingControls=v.get(c.showFoldingControls),this.foldingDecorationProvider.showFoldingHighlights=v.get(c.foldingHighlight),this.triggerFoldingModelChanged()}F.hasChanged(c.foldingStrategy)&&(this._useFoldingProviders=this.editor.getOptions().get(c.foldingStrategy)!=="indentation",this.onFoldingStrategyChanged()),F.hasChanged(c.unfoldOnClickAfterEndOfLine)&&(this._unfoldOnClickAfterEndOfLine=this.editor.getOptions().get(c.unfoldOnClickAfterEndOfLine)),F.hasChanged(c.foldingImportsByDefault)&&(this._foldingImportsByDefault=this.editor.getOptions().get(c.foldingImportsByDefault))})),this.onModelChanged()}static ID="editor.contrib.folding";static get(e){return e.getContribution(E.ID)}static _foldingRangeSelector;static getFoldingRangeProviders(e,o){const t=e.foldingRangeProvider.ordered(o);return E._foldingRangeSelector?.(t,o)??t}static setFoldingRangeProviderSelector(e){return E._foldingRangeSelector=e,{dispose:()=>{E._foldingRangeSelector=void 0}}}editor;_isEnabled;_useFoldingProviders;_unfoldOnClickAfterEndOfLine;_restoringViewState;_foldingImportsByDefault;_currentModelHasFoldedImports;foldingDecorationProvider;foldingModel;hiddenRangeModel;rangeProvider;foldingRegionPromise;foldingModelPromise;updateScheduler;updateDebounceInfo;foldingEnabled;cursorChangedScheduler;localToDispose=this._register(new Z);mouseDownInfo;_foldingLimitReporter;get limitReporter(){return this._foldingLimitReporter}saveViewState(){const e=this.editor.getModel();if(!e||!this._isEnabled||e.isTooLargeForTokenization())return{};if(this.foldingModel){const o=this.foldingModel.getMemento(),t=this.rangeProvider?this.rangeProvider.id:void 0;return{collapsedRegions:o,lineCount:e.getLineCount(),provider:t,foldedImports:this._currentModelHasFoldedImports}}}restoreViewState(e){const o=this.editor.getModel();if(!(!o||!this._isEnabled||o.isTooLargeForTokenization()||!this.hiddenRangeModel)&&e&&(this._currentModelHasFoldedImports=!!e.foldedImports,e.collapsedRegions&&e.collapsedRegions.length>0&&this.foldingModel)){this._restoringViewState=!0;try{this.foldingModel.applyMemento(e.collapsedRegions)}finally{this._restoringViewState=!1}}}onModelChanged(){this.localToDispose.clear();const e=this.editor.getModel();!this._isEnabled||!e||e.isTooLargeForTokenization()||(this._currentModelHasFoldedImports=!1,this.foldingModel=new ue(e,this.foldingDecorationProvider),this.localToDispose.add(this.foldingModel),this.hiddenRangeModel=new ve(this.foldingModel),this.localToDispose.add(this.hiddenRangeModel),this.localToDispose.add(this.hiddenRangeModel.onDidChange(o=>this.onHiddenRangesChanges(o))),this.updateScheduler=new J(this.updateDebounceInfo.get(e)),this.cursorChangedScheduler=new Y(()=>this.revealCursor(),200),this.localToDispose.add(this.cursorChangedScheduler),this.localToDispose.add(this.languageFeaturesService.foldingRangeProvider.onDidChange(()=>this.onFoldingStrategyChanged())),this.localToDispose.add(this.editor.onDidChangeModelLanguageConfiguration(()=>this.onFoldingStrategyChanged())),this.localToDispose.add(this.editor.onDidChangeModelContent(o=>this.onDidChangeModelContent(o))),this.localToDispose.add(this.editor.onDidChangeCursorPosition(()=>this.onCursorPositionChanged())),this.localToDispose.add(this.editor.onMouseDown(o=>this.onEditorMouseDown(o))),this.localToDispose.add(this.editor.onMouseUp(o=>this.onEditorMouseUp(o))),this.localToDispose.add({dispose:()=>{this.foldingRegionPromise&&(this.foldingRegionPromise.cancel(),this.foldingRegionPromise=null),this.updateScheduler?.cancel(),this.updateScheduler=null,this.foldingModel=null,this.foldingModelPromise=null,this.hiddenRangeModel=null,this.cursorChangedScheduler=null,this.rangeProvider?.dispose(),this.rangeProvider=null}}),this.triggerFoldingModelChanged())}onFoldingStrategyChanged(){this.rangeProvider?.dispose(),this.rangeProvider=null,this.triggerFoldingModelChanged()}getRangeProvider(e){if(this.rangeProvider)return this.rangeProvider;const o=new H(e,this.languageConfigurationService,this._foldingLimitReporter);if(this.rangeProvider=o,this._useFoldingProviders&&this.foldingModel){const t=E.getFoldingRangeProviders(this.languageFeaturesService,e);t.length>0&&(this.rangeProvider=new G(e,t,()=>this.triggerFoldingModelChanged(),this._foldingLimitReporter,o))}return this.rangeProvider}getFoldingModel(){return this.foldingModelPromise}onDidChangeModelContent(e){this.hiddenRangeModel?.notifyChangeModelContent(e),this.triggerFoldingModelChanged()}triggerFoldingModelChanged(){this.updateScheduler&&(this.foldingRegionPromise&&(this.foldingRegionPromise.cancel(),this.foldingRegionPromise=null),this.foldingModelPromise=this.updateScheduler.trigger(()=>{const e=this.foldingModel;if(!e)return null;const o=new te,t=this.getRangeProvider(e.textModel),i=this.foldingRegionPromise=q(r=>t.compute(r));return i.then(r=>{if(r&&i===this.foldingRegionPromise){let l;if(this._foldingImportsByDefault&&!this._currentModelHasFoldedImports){const v=r.setCollapsedAllOfType(x.Imports.value,!0);v&&(l=se.capture(this.editor),this._currentModelHasFoldedImports=v)}const a=this.editor.getSelections();e.update(r,Ie(a)),l?.restore(this.editor);const F=this.updateDebounceInfo.update(e.textModel,o.elapsed());this.updateScheduler&&(this.updateScheduler.defaultDelay=F)}return e})}).then(void 0,e=>(O(e),null)))}onHiddenRangesChanges(e){if(this.hiddenRangeModel&&e.length&&!this._restoringViewState){const o=this.editor.getSelections();o&&this.hiddenRangeModel.adjustSelections(o)&&this.editor.setSelections(o)}this.editor.setHiddenAreas(e,this)}onCursorPositionChanged(){this.hiddenRangeModel&&this.hiddenRangeModel.hasRanges()&&this.cursorChangedScheduler.schedule()}revealCursor(){const e=this.getFoldingModel();e&&e.then(o=>{if(o){const t=this.editor.getSelections();if(t&&t.length>0){const i=[];for(const r of t){const l=r.selectionStartLineNumber;this.hiddenRangeModel&&this.hiddenRangeModel.isHidden(l)&&i.push(...o.getAllRegionsAtLine(l,a=>a.isCollapsed&&l>a.startLineNumber))}i.length&&(o.toggleCollapseState(i),this.reveal(t[0].getPosition()))}}}).then(void 0,O)}onEditorMouseDown(e){if(this.mouseDownInfo=null,!this.hiddenRangeModel||!e.target||!e.target.range||!e.event.leftButton&&!e.event.middleButton)return;const o=e.target.range;let t=!1;switch(e.target.type){case P.GUTTER_LINE_DECORATIONS:{const i=e.target.detail,r=e.target.element.offsetLeft;if(i.offsetX-r<4)return;t=!0;break}case P.CONTENT_EMPTY:{if(this._unfoldOnClickAfterEndOfLine&&this.hiddenRangeModel.hasRanges()&&!e.target.detail.isAfterLines)break;return}case P.CONTENT_TEXT:{if(this.hiddenRangeModel.hasRanges()){const i=this.editor.getModel();if(i&&o.startColumn===i.getLineMaxColumn(o.startLineNumber))break}return}default:return}this.mouseDownInfo={lineNumber:o.startLineNumber,iconClicked:t}}onEditorMouseUp(e){const o=this.foldingModel;if(!o||!this.mouseDownInfo||!e.target)return;const t=this.mouseDownInfo.lineNumber,i=this.mouseDownInfo.iconClicked,r=e.target.range;if(!r||r.startLineNumber!==t)return;if(i){if(e.target.type!==P.GUTTER_LINE_DECORATIONS)return}else{const a=this.editor.getModel();if(!a||r.startColumn!==a.getLineMaxColumn(t))return}const l=o.getRegionAtLine(t);if(l&&l.startLineNumber===t){const a=l.isCollapsed;if(i||a){const F=e.event.altKey;let v=[];if(F){const y=b=>!b.containedBy(l)&&!l.containedBy(b),S=o.getRegionsInside(null,y);for(const b of S)b.isCollapsed&&v.push(b);v.length===0&&(v=S)}else{const y=e.event.middleButton||e.event.shiftKey;if(y)for(const S of o.getRegionsInside(l))S.isCollapsed===a&&v.push(S);(a||!y||v.length===0)&&v.push(l)}o.toggleCollapseState(v),this.reveal({lineNumber:t,column:1})}}}reveal(e){this.editor.revealPositionInCenterIfOutsideViewport(e,ae.Smooth)}};E=w([M(1,Re),M(2,_),M(3,ye),M(4,ge),M(5,K)],E);class Me{constructor(n){this.editor=n}get limit(){return this.editor.getOptions().get(c.foldingMaximumRegions)}_onDidChange=new oe;onDidChange=this._onDidChange.event;_computed=0;_limited=!1;get computed(){return this._computed}get limited(){return this._limited}update(n,e){(n!==this._computed||e!==this._limited)&&(this._computed=n,this._limited=e,this._onDidChange.fire())}}class m extends ne{runEditorCommand(n,e,o){const t=n.get(_),i=E.get(e);if(!i)return;const r=i.getFoldingModel();if(r)return this.reportTelemetry(n,e),r.then(l=>{if(l){this.invoke(i,l,e,o,t);const a=e.getSelection();a&&i.reveal(a.getStartPosition())}})}getSelectedLines(n){const e=n.getSelections();return e?e.map(o=>o.startLineNumber):[]}getLineNumbers(n,e){return n&&n.selectionLines?n.selectionLines.map(o=>o+1):this.getSelectedLines(e)}run(n,e){}}function Ie(d){return!d||d.length===0?{startsInside:()=>!1}:{startsInside(n,e){for(const o of d){const t=o.startLineNumber;if(t>=n&&t<=e)return!0}return!1}}}function X(d){if(!L.isUndefined(d)){if(!L.isObject(d))return!1;const n=d;if(!L.isUndefined(n.levels)&&!L.isNumber(n.levels)||!L.isUndefined(n.direction)&&!L.isString(n.direction)||!L.isUndefined(n.selectionLines)&&(!Array.isArray(n.selectionLines)||!n.selectionLines.every(L.isNumber)))return!1}return!0}class xe extends m{constructor(){super({id:"editor.unfold",label:p.localize("unfoldAction.label","Unfold"),alias:"Unfold",precondition:u,kbOpts:{kbExpr:f.editorTextFocus,primary:s.CtrlCmd|s.Shift|g.BracketRight,mac:{primary:s.CtrlCmd|s.Alt|g.BracketRight},weight:h.EditorContrib},metadata:{description:"Unfold the content in the editor",args:[{name:"Unfold editor argument",description:`Property-value pairs that can be passed through this argument:
						* 'levels': Number of levels to unfold. If not set, defaults to 1.
						* 'direction': If 'up', unfold given number of levels up otherwise unfolds down.
						* 'selectionLines': Array of the start lines (0-based) of the editor selections to apply the unfold action to. If not set, the active selection(s) will be used.
						`,constraint:X,schema:{type:"object",properties:{levels:{type:"number",default:1},direction:{type:"string",enum:["up","down"],default:"down"},selectionLines:{type:"array",items:{type:"number"}}}}}]}})}invoke(n,e,o,t){const i=t&&t.levels||1,r=this.getLineNumbers(t,o);t&&t.direction==="up"?B(e,!1,i,r):I(e,!1,i,r)}}class Ae extends m{constructor(){super({id:"editor.unfoldRecursively",label:p.localize("unFoldRecursivelyAction.label","Unfold Recursively"),alias:"Unfold Recursively",precondition:u,kbOpts:{kbExpr:f.editorTextFocus,primary:R(s.CtrlCmd|g.KeyK,s.CtrlCmd|g.BracketRight),weight:h.EditorContrib}})}invoke(n,e,o,t){I(e,!1,Number.MAX_VALUE,this.getSelectedLines(o))}}class Pe extends m{constructor(){super({id:"editor.fold",label:p.localize("foldAction.label","Fold"),alias:"Fold",precondition:u,kbOpts:{kbExpr:f.editorTextFocus,primary:s.CtrlCmd|s.Shift|g.BracketLeft,mac:{primary:s.CtrlCmd|s.Alt|g.BracketLeft},weight:h.EditorContrib},metadata:{description:"Fold the content in the editor",args:[{name:"Fold editor argument",description:`Property-value pairs that can be passed through this argument:
							* 'levels': Number of levels to fold.
							* 'direction': If 'up', folds given number of levels up otherwise folds down.
							* 'selectionLines': Array of the start lines (0-based) of the editor selections to apply the fold action to. If not set, the active selection(s) will be used.
							If no levels or direction is set, folds the region at the locations or if already collapsed, the first uncollapsed parent instead.
						`,constraint:X,schema:{type:"object",properties:{levels:{type:"number"},direction:{type:"string",enum:["up","down"]},selectionLines:{type:"array",items:{type:"number"}}}}}]}})}invoke(n,e,o,t){const i=this.getLineNumbers(t,o),r=t&&t.levels,l=t&&t.direction;typeof r!="number"&&typeof l!="string"?Ce(e,!0,i):l==="up"?B(e,!0,r||1,i):I(e,!0,r||1,i)}}class ke extends m{constructor(){super({id:"editor.toggleFold",label:p.localize("toggleFoldAction.label","Toggle Fold"),alias:"Toggle Fold",precondition:u,kbOpts:{kbExpr:f.editorTextFocus,primary:R(s.CtrlCmd|g.KeyK,s.CtrlCmd|g.KeyL),weight:h.EditorContrib}})}invoke(n,e,o){const t=this.getSelectedLines(o);z(e,1,t)}}class _e extends m{constructor(){super({id:"editor.foldRecursively",label:p.localize("foldRecursivelyAction.label","Fold Recursively"),alias:"Fold Recursively",precondition:u,kbOpts:{kbExpr:f.editorTextFocus,primary:R(s.CtrlCmd|g.KeyK,s.CtrlCmd|g.BracketLeft),weight:h.EditorContrib}})}invoke(n,e,o){const t=this.getSelectedLines(o);I(e,!0,Number.MAX_VALUE,t)}}class De extends m{constructor(){super({id:"editor.toggleFoldRecursively",label:p.localize("toggleFoldRecursivelyAction.label","Toggle Fold Recursively"),alias:"Toggle Fold Recursively",precondition:u,kbOpts:{kbExpr:f.editorTextFocus,primary:R(s.CtrlCmd|g.KeyK,s.CtrlCmd|s.Shift|g.KeyL),weight:h.EditorContrib}})}invoke(n,e,o){const t=this.getSelectedLines(o);z(e,Number.MAX_VALUE,t)}}class Te extends m{constructor(){super({id:"editor.foldAllBlockComments",label:p.localize("foldAllBlockComments.label","Fold All Block Comments"),alias:"Fold All Block Comments",precondition:u,kbOpts:{kbExpr:f.editorTextFocus,primary:R(s.CtrlCmd|g.KeyK,s.CtrlCmd|g.Slash),weight:h.EditorContrib}})}invoke(n,e,o,t,i){if(e.regions.hasTypes())T(e,x.Comment.value,!0);else{const r=o.getModel();if(!r)return;const l=i.getLanguageConfiguration(r.getLanguageId()).comments;if(l&&l.blockCommentStartToken){const a=new RegExp("^\\s*"+ee(l.blockCommentStartToken));D(e,a,!0)}}}}class we extends m{constructor(){super({id:"editor.foldAllMarkerRegions",label:p.localize("foldAllMarkerRegions.label","Fold All Regions"),alias:"Fold All Regions",precondition:u,kbOpts:{kbExpr:f.editorTextFocus,primary:R(s.CtrlCmd|g.KeyK,s.CtrlCmd|g.Digit8),weight:h.EditorContrib}})}invoke(n,e,o,t,i){if(e.regions.hasTypes())T(e,x.Region.value,!0);else{const r=o.getModel();if(!r)return;const l=i.getLanguageConfiguration(r.getLanguageId()).foldingRules;if(l&&l.markers&&l.markers.start){const a=new RegExp(l.markers.start);D(e,a,!0)}}}}class Ne extends m{constructor(){super({id:"editor.unfoldAllMarkerRegions",label:p.localize("unfoldAllMarkerRegions.label","Unfold All Regions"),alias:"Unfold All Regions",precondition:u,kbOpts:{kbExpr:f.editorTextFocus,primary:R(s.CtrlCmd|g.KeyK,s.CtrlCmd|g.Digit9),weight:h.EditorContrib}})}invoke(n,e,o,t,i){if(e.regions.hasTypes())T(e,x.Region.value,!1);else{const r=o.getModel();if(!r)return;const l=i.getLanguageConfiguration(r.getLanguageId()).foldingRules;if(l&&l.markers&&l.markers.start){const a=new RegExp(l.markers.start);D(e,a,!1)}}}}class Oe extends m{constructor(){super({id:"editor.foldAllExcept",label:p.localize("foldAllExcept.label","Fold All Except Selected"),alias:"Fold All Except Selected",precondition:u,kbOpts:{kbExpr:f.editorTextFocus,primary:R(s.CtrlCmd|g.KeyK,s.CtrlCmd|g.Minus),weight:h.EditorContrib}})}invoke(n,e,o){const t=this.getSelectedLines(o);U(e,!0,t)}}class Ke extends m{constructor(){super({id:"editor.unfoldAllExcept",label:p.localize("unfoldAllExcept.label","Unfold All Except Selected"),alias:"Unfold All Except Selected",precondition:u,kbOpts:{kbExpr:f.editorTextFocus,primary:R(s.CtrlCmd|g.KeyK,s.CtrlCmd|g.Equal),weight:h.EditorContrib}})}invoke(n,e,o){const t=this.getSelectedLines(o);U(e,!1,t)}}class Ue extends m{constructor(){super({id:"editor.foldAll",label:p.localize("foldAllAction.label","Fold All"),alias:"Fold All",precondition:u,kbOpts:{kbExpr:f.editorTextFocus,primary:R(s.CtrlCmd|g.KeyK,s.CtrlCmd|g.Digit0),weight:h.EditorContrib}})}invoke(n,e,o){I(e,!0)}}class Be extends m{constructor(){super({id:"editor.unfoldAll",label:p.localize("unfoldAllAction.label","Unfold All"),alias:"Unfold All",precondition:u,kbOpts:{kbExpr:f.editorTextFocus,primary:R(s.CtrlCmd|g.KeyK,s.CtrlCmd|g.KeyJ),weight:h.EditorContrib}})}invoke(n,e,o){I(e,!1)}}class A extends m{static ID_PREFIX="editor.foldLevel";static ID=n=>A.ID_PREFIX+n;getFoldingLevel(){return parseInt(this.id.substr(A.ID_PREFIX.length))}invoke(n,e,o){me(e,this.getFoldingLevel(),!0,this.getSelectedLines(o))}}class ze extends m{constructor(){super({id:"editor.gotoParentFold",label:p.localize("gotoParentFold.label","Go to Parent Fold"),alias:"Go to Parent Fold",precondition:u,kbOpts:{kbExpr:f.editorTextFocus,weight:h.EditorContrib}})}invoke(n,e,o){const t=this.getSelectedLines(o);if(t.length>0){const i=pe(t[0],e);i!==null&&o.setSelection({startLineNumber:i,startColumn:1,endLineNumber:i,endColumn:1})}}}class He extends m{constructor(){super({id:"editor.gotoPreviousFold",label:p.localize("gotoPreviousFold.label","Go to Previous Folding Range"),alias:"Go to Previous Folding Range",precondition:u,kbOpts:{kbExpr:f.editorTextFocus,weight:h.EditorContrib}})}invoke(n,e,o){const t=this.getSelectedLines(o);if(t.length>0){const i=he(t[0],e);i!==null&&o.setSelection({startLineNumber:i,startColumn:1,endLineNumber:i,endColumn:1})}}}class Ve extends m{constructor(){super({id:"editor.gotoNextFold",label:p.localize("gotoNextFold.label","Go to Next Folding Range"),alias:"Go to Next Folding Range",precondition:u,kbOpts:{kbExpr:f.editorTextFocus,weight:h.EditorContrib}})}invoke(n,e,o){const t=this.getSelectedLines(o);if(t.length>0){const i=fe(t[0],e);i!==null&&o.setSelection({startLineNumber:i,startColumn:1,endLineNumber:i,endColumn:1})}}}class Ge extends m{constructor(){super({id:"editor.createFoldingRangeFromSelection",label:p.localize("createManualFoldRange.label","Create Folding Range from Selection"),alias:"Create Folding Range from Selection",precondition:u,kbOpts:{kbExpr:f.editorTextFocus,primary:R(s.CtrlCmd|g.KeyK,s.CtrlCmd|g.Comma),weight:h.EditorContrib}})}invoke(n,e,o){const t=[],i=o.getSelections();if(i){for(const r of i){let l=r.endLineNumber;r.endColumn===1&&--l,l>r.startLineNumber&&(t.push({startLineNumber:r.startLineNumber,endLineNumber:l,type:void 0,isCollapsed:!0,source:Le.userDefined}),o.setSelection({startLineNumber:r.startLineNumber,startColumn:1,endLineNumber:r.startLineNumber,endColumn:1}))}if(t.length>0){t.sort((l,a)=>l.startLineNumber-a.startLineNumber);const r=V.sanitizeAndMerge(e.regions,t,o.getModel()?.getLineCount());e.updatePost(V.fromFoldRanges(r))}}}}class Xe extends m{constructor(){super({id:"editor.removeManualFoldingRanges",label:p.localize("removeManualFoldingRanges.label","Remove Manual Folding Ranges"),alias:"Remove Manual Folding Ranges",precondition:u,kbOpts:{kbExpr:f.editorTextFocus,primary:R(s.CtrlCmd|g.KeyK,s.CtrlCmd|g.Period),weight:h.EditorContrib}})}invoke(n,e,o){const t=o.getSelections();if(t){const i=[];for(const r of t){const{startLineNumber:l,endLineNumber:a}=r;i.push(a>=l?{startLineNumber:l,endLineNumber:a}:{endLineNumber:a,startLineNumber:l})}e.removeManualRanges(i),n.triggerFoldingModelChanged()}}}le(E.ID,E,re.Eager),C(xe),C(Ae),C(Pe),C(_e),C(De),C(Ue),C(Be),C(Te),C(we),C(Ne),C(Oe),C(Ke),C(ke),C(ze),C(He),C(Ve),C(Ge),C(Xe);for(let d=1;d<=7;d++)de(new A({id:A.ID(d),label:p.localize("foldLevelAction.label","Fold Level {0}",d),alias:`Fold Level ${d}`,precondition:u,kbOpts:{kbExpr:f.editorTextFocus,primary:R(s.CtrlCmd|g.KeyK,s.CtrlCmd|g.Digit0+d),weight:h.EditorContrib}}));be.registerCommand("_executeFoldingRangeProvider",async function(d,...n){const[e]=n;if(!(e instanceof ie))throw N();const o=d.get(K),t=d.get(ce).getModel(e);if(!t)throw N();const i=d.get(Fe);if(!i.getValue("editor.folding",{resource:e}))return[];const r=d.get(_),l=i.getValue("editor.foldingStrategy",{resource:e}),a={get limit(){return i.getValue("editor.foldingMaximumRegions",{resource:e})},update:(b,k)=>{}},F=new H(t,r,a);let v=F;if(l!=="indentation"){const b=E.getFoldingRangeProviders(o,t);b.length&&(v=new G(t,b,()=>{},a,F))}const y=await v.compute($.None),S=[];try{if(y)for(let b=0;b<y.length;b++){const k=y.getType(b);S.push({start:y.getStartLineNumber(b),end:y.getEndLineNumber(b),kind:k?x.fromValue(k):void 0})}return S}finally{v.dispose()}});export{E as FoldingController,Me as RangesLimitReporter,Ie as toSelectedLines};
