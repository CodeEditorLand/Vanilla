{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/contrib/folding/browser/foldingModel.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, type Event } from \"../../../../base/common/event.js\";\nimport { hash } from \"../../../../base/common/hash.js\";\nimport type {\n\tIModelDecorationOptions,\n\tIModelDecorationsChangeAccessor,\n\tIModelDeltaDecoration,\n\tITextModel,\n} from \"../../../common/model.js\";\nimport type { SelectedLines } from \"./folding.js\";\nimport {\n\ttype FoldRange,\n\tFoldSource,\n\ttype FoldingRegion,\n\tFoldingRegions,\n\ttype ILineRange,\n} from \"./foldingRanges.js\";\n\nexport interface IDecorationProvider {\n\tgetDecorationOption(\n\t\tisCollapsed: boolean,\n\t\tisHidden: boolean,\n\t\tisManual: boolean,\n\t): IModelDecorationOptions;\n\tchangeDecorations<T>(\n\t\tcallback: (changeAccessor: IModelDecorationsChangeAccessor) => T,\n\t): T | null;\n\tremoveDecorations(decorationIds: string[]): void;\n}\n\nexport interface FoldingModelChangeEvent {\n\tmodel: FoldingModel;\n\tcollapseStateChanged?: FoldingRegion[];\n}\n\ninterface ILineMemento extends ILineRange {\n\tchecksum?: number;\n\tisCollapsed?: boolean;\n\tsource?: FoldSource;\n}\n\nexport type CollapseMemento = ILineMemento[];\n\nexport class FoldingModel {\n\tprivate readonly _textModel: ITextModel;\n\tprivate readonly _decorationProvider: IDecorationProvider;\n\n\tprivate _regions: FoldingRegions;\n\tprivate _editorDecorationIds: string[];\n\n\tprivate readonly _updateEventEmitter =\n\t\tnew Emitter<FoldingModelChangeEvent>();\n\tpublic readonly onDidChange: Event<FoldingModelChangeEvent> =\n\t\tthis._updateEventEmitter.event;\n\n\tpublic get regions(): FoldingRegions {\n\t\treturn this._regions;\n\t}\n\tpublic get textModel() {\n\t\treturn this._textModel;\n\t}\n\tpublic get decorationProvider() {\n\t\treturn this._decorationProvider;\n\t}\n\n\tconstructor(\n\t\ttextModel: ITextModel,\n\t\tdecorationProvider: IDecorationProvider,\n\t) {\n\t\tthis._textModel = textModel;\n\t\tthis._decorationProvider = decorationProvider;\n\t\tthis._regions = new FoldingRegions(\n\t\t\tnew Uint32Array(0),\n\t\t\tnew Uint32Array(0),\n\t\t);\n\t\tthis._editorDecorationIds = [];\n\t}\n\n\tpublic toggleCollapseState(toggledRegions: FoldingRegion[]) {\n\t\tif (!toggledRegions.length) {\n\t\t\treturn;\n\t\t}\n\t\ttoggledRegions = toggledRegions.sort(\n\t\t\t(r1, r2) => r1.regionIndex - r2.regionIndex,\n\t\t);\n\n\t\tconst processed: { [key: string]: boolean | undefined } = {};\n\t\tthis._decorationProvider.changeDecorations((accessor) => {\n\t\t\tlet k = 0; // index from [0 ... this.regions.length]\n\t\t\tlet dirtyRegionEndLine = -1; // end of the range where decorations need to be updated\n\t\t\tlet lastHiddenLine = -1; // the end of the last hidden lines\n\t\t\tconst updateDecorationsUntil = (index: number) => {\n\t\t\t\twhile (k < index) {\n\t\t\t\t\tconst endLineNumber = this._regions.getEndLineNumber(k);\n\t\t\t\t\tconst isCollapsed = this._regions.isCollapsed(k);\n\t\t\t\t\tif (endLineNumber <= dirtyRegionEndLine) {\n\t\t\t\t\t\tconst isManual =\n\t\t\t\t\t\t\tthis.regions.getSource(k) !== FoldSource.provider;\n\t\t\t\t\t\taccessor.changeDecorationOptions(\n\t\t\t\t\t\t\tthis._editorDecorationIds[k],\n\t\t\t\t\t\t\tthis._decorationProvider.getDecorationOption(\n\t\t\t\t\t\t\t\tisCollapsed,\n\t\t\t\t\t\t\t\tendLineNumber <= lastHiddenLine,\n\t\t\t\t\t\t\t\tisManual,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif (isCollapsed && endLineNumber > lastHiddenLine) {\n\t\t\t\t\t\tlastHiddenLine = endLineNumber;\n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t};\n\t\t\tfor (const region of toggledRegions) {\n\t\t\t\tconst index = region.regionIndex;\n\t\t\t\tconst editorDecorationId = this._editorDecorationIds[index];\n\t\t\t\tif (editorDecorationId && !processed[editorDecorationId]) {\n\t\t\t\t\tprocessed[editorDecorationId] = true;\n\n\t\t\t\t\tupdateDecorationsUntil(index); // update all decorations up to current index using the old dirtyRegionEndLine\n\n\t\t\t\t\tconst newCollapseState = !this._regions.isCollapsed(index);\n\t\t\t\t\tthis._regions.setCollapsed(index, newCollapseState);\n\n\t\t\t\t\tdirtyRegionEndLine = Math.max(\n\t\t\t\t\t\tdirtyRegionEndLine,\n\t\t\t\t\t\tthis._regions.getEndLineNumber(index),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tupdateDecorationsUntil(this._regions.length);\n\t\t});\n\t\tthis._updateEventEmitter.fire({\n\t\t\tmodel: this,\n\t\t\tcollapseStateChanged: toggledRegions,\n\t\t});\n\t}\n\n\tpublic removeManualRanges(ranges: ILineRange[]) {\n\t\tconst newFoldingRanges: FoldRange[] = new Array();\n\t\tconst intersects = (foldRange: FoldRange) => {\n\t\t\tfor (const range of ranges) {\n\t\t\t\tif (\n\t\t\t\t\t!(\n\t\t\t\t\t\trange.startLineNumber > foldRange.endLineNumber ||\n\t\t\t\t\t\tfoldRange.startLineNumber > range.endLineNumber\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tfor (let i = 0; i < this._regions.length; i++) {\n\t\t\tconst foldRange = this._regions.toFoldRange(i);\n\t\t\tif (\n\t\t\t\tfoldRange.source === FoldSource.provider ||\n\t\t\t\t!intersects(foldRange)\n\t\t\t) {\n\t\t\t\tnewFoldingRanges.push(foldRange);\n\t\t\t}\n\t\t}\n\t\tthis.updatePost(FoldingRegions.fromFoldRanges(newFoldingRanges));\n\t}\n\n\tpublic update(newRegions: FoldingRegions, selection?: SelectedLines): void {\n\t\tconst foldedOrManualRanges =\n\t\t\tthis._currentFoldedOrManualRanges(selection);\n\t\tconst newRanges = FoldingRegions.sanitizeAndMerge(\n\t\t\tnewRegions,\n\t\t\tfoldedOrManualRanges,\n\t\t\tthis._textModel.getLineCount(),\n\t\t\tselection,\n\t\t);\n\t\tthis.updatePost(FoldingRegions.fromFoldRanges(newRanges));\n\t}\n\n\tpublic updatePost(newRegions: FoldingRegions) {\n\t\tconst newEditorDecorations: IModelDeltaDecoration[] = [];\n\t\tlet lastHiddenLine = -1;\n\t\tfor (let index = 0, limit = newRegions.length; index < limit; index++) {\n\t\t\tconst startLineNumber = newRegions.getStartLineNumber(index);\n\t\t\tconst endLineNumber = newRegions.getEndLineNumber(index);\n\t\t\tconst isCollapsed = newRegions.isCollapsed(index);\n\t\t\tconst isManual =\n\t\t\t\tnewRegions.getSource(index) !== FoldSource.provider;\n\t\t\tconst decorationRange = {\n\t\t\t\tstartLineNumber: startLineNumber,\n\t\t\t\tstartColumn: this._textModel.getLineMaxColumn(startLineNumber),\n\t\t\t\tendLineNumber: endLineNumber,\n\t\t\t\tendColumn: this._textModel.getLineMaxColumn(endLineNumber) + 1,\n\t\t\t};\n\t\t\tnewEditorDecorations.push({\n\t\t\t\trange: decorationRange,\n\t\t\t\toptions: this._decorationProvider.getDecorationOption(\n\t\t\t\t\tisCollapsed,\n\t\t\t\t\tendLineNumber <= lastHiddenLine,\n\t\t\t\t\tisManual,\n\t\t\t\t),\n\t\t\t});\n\t\t\tif (isCollapsed && endLineNumber > lastHiddenLine) {\n\t\t\t\tlastHiddenLine = endLineNumber;\n\t\t\t}\n\t\t}\n\t\tthis._decorationProvider.changeDecorations(\n\t\t\t(accessor) =>\n\t\t\t\t(this._editorDecorationIds = accessor.deltaDecorations(\n\t\t\t\t\tthis._editorDecorationIds,\n\t\t\t\t\tnewEditorDecorations,\n\t\t\t\t)),\n\t\t);\n\t\tthis._regions = newRegions;\n\t\tthis._updateEventEmitter.fire({ model: this });\n\t}\n\n\tprivate _currentFoldedOrManualRanges(\n\t\tselection?: SelectedLines,\n\t): FoldRange[] {\n\t\tconst foldedRanges: FoldRange[] = [];\n\t\tfor (let i = 0, limit = this._regions.length; i < limit; i++) {\n\t\t\tlet isCollapsed = this.regions.isCollapsed(i);\n\t\t\tconst source = this.regions.getSource(i);\n\t\t\tif (isCollapsed || source !== FoldSource.provider) {\n\t\t\t\tconst foldRange = this._regions.toFoldRange(i);\n\t\t\t\tconst decRange = this._textModel.getDecorationRange(\n\t\t\t\t\tthis._editorDecorationIds[i],\n\t\t\t\t);\n\t\t\t\tif (decRange) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tisCollapsed &&\n\t\t\t\t\t\tselection?.startsInside(\n\t\t\t\t\t\t\tdecRange.startLineNumber + 1,\n\t\t\t\t\t\t\tdecRange.endLineNumber,\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tisCollapsed = false; // uncollapse is the range is blocked\n\t\t\t\t\t}\n\t\t\t\t\tfoldedRanges.push({\n\t\t\t\t\t\tstartLineNumber: decRange.startLineNumber,\n\t\t\t\t\t\tendLineNumber: decRange.endLineNumber,\n\t\t\t\t\t\ttype: foldRange.type,\n\t\t\t\t\t\tisCollapsed,\n\t\t\t\t\t\tsource,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn foldedRanges;\n\t}\n\n\t/**\n\t * Collapse state memento, for persistence only\n\t */\n\tpublic getMemento(): CollapseMemento | undefined {\n\t\tconst foldedOrManualRanges = this._currentFoldedOrManualRanges();\n\t\tconst result: ILineMemento[] = [];\n\t\tconst maxLineNumber = this._textModel.getLineCount();\n\t\tfor (let i = 0, limit = foldedOrManualRanges.length; i < limit; i++) {\n\t\t\tconst range = foldedOrManualRanges[i];\n\t\t\tif (\n\t\t\t\trange.startLineNumber >= range.endLineNumber ||\n\t\t\t\trange.startLineNumber < 1 ||\n\t\t\t\trange.endLineNumber > maxLineNumber\n\t\t\t) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst checksum = this._getLinesChecksum(\n\t\t\t\trange.startLineNumber + 1,\n\t\t\t\trange.endLineNumber,\n\t\t\t);\n\t\t\tresult.push({\n\t\t\t\tstartLineNumber: range.startLineNumber,\n\t\t\t\tendLineNumber: range.endLineNumber,\n\t\t\t\tisCollapsed: range.isCollapsed,\n\t\t\t\tsource: range.source,\n\t\t\t\tchecksum: checksum,\n\t\t\t});\n\t\t}\n\t\treturn result.length > 0 ? result : undefined;\n\t}\n\n\t/**\n\t * Apply persisted state, for persistence only\n\t */\n\tpublic applyMemento(state: CollapseMemento) {\n\t\tif (!Array.isArray(state)) {\n\t\t\treturn;\n\t\t}\n\t\tconst rangesToRestore: FoldRange[] = [];\n\t\tconst maxLineNumber = this._textModel.getLineCount();\n\t\tfor (const range of state) {\n\t\t\tif (\n\t\t\t\trange.startLineNumber >= range.endLineNumber ||\n\t\t\t\trange.startLineNumber < 1 ||\n\t\t\t\trange.endLineNumber > maxLineNumber\n\t\t\t) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst checksum = this._getLinesChecksum(\n\t\t\t\trange.startLineNumber + 1,\n\t\t\t\trange.endLineNumber,\n\t\t\t);\n\t\t\tif (!range.checksum || checksum === range.checksum) {\n\t\t\t\trangesToRestore.push({\n\t\t\t\t\tstartLineNumber: range.startLineNumber,\n\t\t\t\t\tendLineNumber: range.endLineNumber,\n\t\t\t\t\ttype: undefined,\n\t\t\t\t\tisCollapsed: range.isCollapsed ?? true,\n\t\t\t\t\tsource: range.source ?? FoldSource.provider,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tconst newRanges = FoldingRegions.sanitizeAndMerge(\n\t\t\tthis._regions,\n\t\t\trangesToRestore,\n\t\t\tmaxLineNumber,\n\t\t);\n\t\tthis.updatePost(FoldingRegions.fromFoldRanges(newRanges));\n\t}\n\n\tprivate _getLinesChecksum(\n\t\tlineNumber1: number,\n\t\tlineNumber2: number,\n\t): number {\n\t\tconst h = hash(\n\t\t\tthis._textModel.getLineContent(lineNumber1) +\n\t\t\t\tthis._textModel.getLineContent(lineNumber2),\n\t\t);\n\t\treturn h % 1000000; // 6 digits is plenty\n\t}\n\n\tpublic dispose() {\n\t\tthis._decorationProvider.removeDecorations(this._editorDecorationIds);\n\t}\n\n\tgetAllRegionsAtLine(\n\t\tlineNumber: number,\n\t\tfilter?: (r: FoldingRegion, level: number) => boolean,\n\t): FoldingRegion[] {\n\t\tconst result: FoldingRegion[] = [];\n\t\tif (this._regions) {\n\t\t\tlet index = this._regions.findRange(lineNumber);\n\t\t\tlet level = 1;\n\t\t\twhile (index >= 0) {\n\t\t\t\tconst current = this._regions.toRegion(index);\n\t\t\t\tif (!filter || filter(current, level)) {\n\t\t\t\t\tresult.push(current);\n\t\t\t\t}\n\t\t\t\tlevel++;\n\t\t\t\tindex = current.parentIndex;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tgetRegionAtLine(lineNumber: number): FoldingRegion | null {\n\t\tif (this._regions) {\n\t\t\tconst index = this._regions.findRange(lineNumber);\n\t\t\tif (index >= 0) {\n\t\t\t\treturn this._regions.toRegion(index);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tgetRegionsInside(\n\t\tregion: FoldingRegion | null,\n\t\tfilter?: RegionFilter | RegionFilterWithLevel,\n\t): FoldingRegion[] {\n\t\tconst result: FoldingRegion[] = [];\n\t\tconst index = region ? region.regionIndex + 1 : 0;\n\t\tconst endLineNumber = region ? region.endLineNumber : Number.MAX_VALUE;\n\n\t\tif (filter && filter.length === 2) {\n\t\t\tconst levelStack: FoldingRegion[] = [];\n\t\t\tfor (let i = index, len = this._regions.length; i < len; i++) {\n\t\t\t\tconst current = this._regions.toRegion(i);\n\t\t\t\tif (this._regions.getStartLineNumber(i) < endLineNumber) {\n\t\t\t\t\twhile (\n\t\t\t\t\t\tlevelStack.length > 0 &&\n\t\t\t\t\t\t!current.containedBy(levelStack[levelStack.length - 1])\n\t\t\t\t\t) {\n\t\t\t\t\t\tlevelStack.pop();\n\t\t\t\t\t}\n\t\t\t\t\tlevelStack.push(current);\n\t\t\t\t\tif (filter(current, levelStack.length)) {\n\t\t\t\t\t\tresult.push(current);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = index, len = this._regions.length; i < len; i++) {\n\t\t\t\tconst current = this._regions.toRegion(i);\n\t\t\t\tif (this._regions.getStartLineNumber(i) < endLineNumber) {\n\t\t\t\t\tif (!filter || (filter as RegionFilter)(current)) {\n\t\t\t\t\t\tresult.push(current);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n\ntype RegionFilter = (r: FoldingRegion) => boolean;\ntype RegionFilterWithLevel = (r: FoldingRegion, level: number) => boolean;\n\n/**\n * Collapse or expand the regions at the given locations\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\n */\nexport function toggleCollapseState(\n\tfoldingModel: FoldingModel,\n\tlevels: number,\n\tlineNumbers: number[],\n) {\n\tconst toToggle: FoldingRegion[] = [];\n\tfor (const lineNumber of lineNumbers) {\n\t\tconst region = foldingModel.getRegionAtLine(lineNumber);\n\t\tif (region) {\n\t\t\tconst doCollapse = !region.isCollapsed;\n\t\t\ttoToggle.push(region);\n\t\t\tif (levels > 1) {\n\t\t\t\tconst regionsInside = foldingModel.getRegionsInside(\n\t\t\t\t\tregion,\n\t\t\t\t\t(r, level: number) =>\n\t\t\t\t\t\tr.isCollapsed !== doCollapse && level < levels,\n\t\t\t\t);\n\t\t\t\ttoToggle.push(...regionsInside);\n\t\t\t}\n\t\t}\n\t}\n\tfoldingModel.toggleCollapseState(toToggle);\n}\n\n/**\n * Collapse or expand the regions at the given locations including all children.\n * @param doCollapse Whether to collapse or expand\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\n */\nexport function setCollapseStateLevelsDown(\n\tfoldingModel: FoldingModel,\n\tdoCollapse: boolean,\n\tlevels = Number.MAX_VALUE,\n\tlineNumbers?: number[],\n): void {\n\tconst toToggle: FoldingRegion[] = [];\n\tif (lineNumbers && lineNumbers.length > 0) {\n\t\tfor (const lineNumber of lineNumbers) {\n\t\t\tconst region = foldingModel.getRegionAtLine(lineNumber);\n\t\t\tif (region) {\n\t\t\t\tif (region.isCollapsed !== doCollapse) {\n\t\t\t\t\ttoToggle.push(region);\n\t\t\t\t}\n\t\t\t\tif (levels > 1) {\n\t\t\t\t\tconst regionsInside = foldingModel.getRegionsInside(\n\t\t\t\t\t\tregion,\n\t\t\t\t\t\t(r, level: number) =>\n\t\t\t\t\t\t\tr.isCollapsed !== doCollapse && level < levels,\n\t\t\t\t\t);\n\t\t\t\t\ttoToggle.push(...regionsInside);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tconst regionsInside = foldingModel.getRegionsInside(\n\t\t\tnull,\n\t\t\t(r, level: number) =>\n\t\t\t\tr.isCollapsed !== doCollapse && level < levels,\n\t\t);\n\t\ttoToggle.push(...regionsInside);\n\t}\n\tfoldingModel.toggleCollapseState(toToggle);\n}\n\n/**\n * Collapse or expand the regions at the given locations including all parents.\n * @param doCollapse Whether to collapse or expand\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand.\n */\nexport function setCollapseStateLevelsUp(\n\tfoldingModel: FoldingModel,\n\tdoCollapse: boolean,\n\tlevels: number,\n\tlineNumbers: number[],\n): void {\n\tconst toToggle: FoldingRegion[] = [];\n\tfor (const lineNumber of lineNumbers) {\n\t\tconst regions = foldingModel.getAllRegionsAtLine(\n\t\t\tlineNumber,\n\t\t\t(region, level) =>\n\t\t\t\tregion.isCollapsed !== doCollapse && level <= levels,\n\t\t);\n\t\ttoToggle.push(...regions);\n\t}\n\tfoldingModel.toggleCollapseState(toToggle);\n}\n\n/**\n * Collapse or expand a region at the given locations. If the inner most region is already collapsed/expanded, uses the first parent instead.\n * @param doCollapse Whether to collapse or expand\n * @param lineNumbers the location of the regions to collapse or expand.\n */\nexport function setCollapseStateUp(\n\tfoldingModel: FoldingModel,\n\tdoCollapse: boolean,\n\tlineNumbers: number[],\n): void {\n\tconst toToggle: FoldingRegion[] = [];\n\tfor (const lineNumber of lineNumbers) {\n\t\tconst regions = foldingModel.getAllRegionsAtLine(\n\t\t\tlineNumber,\n\t\t\t(region) => region.isCollapsed !== doCollapse,\n\t\t);\n\t\tif (regions.length > 0) {\n\t\t\ttoToggle.push(regions[0]);\n\t\t}\n\t}\n\tfoldingModel.toggleCollapseState(toToggle);\n}\n\n/**\n * Folds or unfolds all regions that have a given level, except if they contain one of the blocked lines.\n * @param foldLevel level. Level == 1 is the top level\n * @param doCollapse Whether to collapse or expand\n */\nexport function setCollapseStateAtLevel(\n\tfoldingModel: FoldingModel,\n\tfoldLevel: number,\n\tdoCollapse: boolean,\n\tblockedLineNumbers: number[],\n): void {\n\tconst filter = (region: FoldingRegion, level: number) =>\n\t\tlevel === foldLevel &&\n\t\tregion.isCollapsed !== doCollapse &&\n\t\t!blockedLineNumbers.some((line) => region.containsLine(line));\n\tconst toToggle = foldingModel.getRegionsInside(null, filter);\n\tfoldingModel.toggleCollapseState(toToggle);\n}\n\n/**\n * Folds or unfolds all regions, except if they contain or are contained by a region of one of the blocked lines.\n * @param doCollapse Whether to collapse or expand\n * @param blockedLineNumbers the location of regions to not collapse or expand\n */\nexport function setCollapseStateForRest(\n\tfoldingModel: FoldingModel,\n\tdoCollapse: boolean,\n\tblockedLineNumbers: number[],\n): void {\n\tconst filteredRegions: FoldingRegion[] = [];\n\tfor (const lineNumber of blockedLineNumbers) {\n\t\tconst regions = foldingModel.getAllRegionsAtLine(lineNumber, undefined);\n\t\tif (regions.length > 0) {\n\t\t\tfilteredRegions.push(regions[0]);\n\t\t}\n\t}\n\tconst filter = (region: FoldingRegion) =>\n\t\tfilteredRegions.every(\n\t\t\t(filteredRegion) =>\n\t\t\t\t!filteredRegion.containedBy(region) &&\n\t\t\t\t!region.containedBy(filteredRegion),\n\t\t) && region.isCollapsed !== doCollapse;\n\tconst toToggle = foldingModel.getRegionsInside(null, filter);\n\tfoldingModel.toggleCollapseState(toToggle);\n}\n\n/**\n * Folds all regions for which the lines start with a given regex\n * @param foldingModel the folding model\n */\nexport function setCollapseStateForMatchingLines(\n\tfoldingModel: FoldingModel,\n\tregExp: RegExp,\n\tdoCollapse: boolean,\n): void {\n\tconst editorModel = foldingModel.textModel;\n\tconst regions = foldingModel.regions;\n\tconst toToggle: FoldingRegion[] = [];\n\tfor (let i = regions.length - 1; i >= 0; i--) {\n\t\tif (doCollapse !== regions.isCollapsed(i)) {\n\t\t\tconst startLineNumber = regions.getStartLineNumber(i);\n\t\t\tif (regExp.test(editorModel.getLineContent(startLineNumber))) {\n\t\t\t\ttoToggle.push(regions.toRegion(i));\n\t\t\t}\n\t\t}\n\t}\n\tfoldingModel.toggleCollapseState(toToggle);\n}\n\n/**\n * Folds all regions of the given type\n * @param foldingModel the folding model\n */\nexport function setCollapseStateForType(\n\tfoldingModel: FoldingModel,\n\ttype: string,\n\tdoCollapse: boolean,\n): void {\n\tconst regions = foldingModel.regions;\n\tconst toToggle: FoldingRegion[] = [];\n\tfor (let i = regions.length - 1; i >= 0; i--) {\n\t\tif (\n\t\t\tdoCollapse !== regions.isCollapsed(i) &&\n\t\t\ttype === regions.getType(i)\n\t\t) {\n\t\t\ttoToggle.push(regions.toRegion(i));\n\t\t}\n\t}\n\tfoldingModel.toggleCollapseState(toToggle);\n}\n\n/**\n * Get line to go to for parent fold of current line\n * @param lineNumber the current line number\n * @param foldingModel the folding model\n *\n * @return Parent fold start line\n */\nexport function getParentFoldLine(\n\tlineNumber: number,\n\tfoldingModel: FoldingModel,\n): number | null {\n\tlet startLineNumber: number | null = null;\n\tconst foldingRegion = foldingModel.getRegionAtLine(lineNumber);\n\tif (foldingRegion !== null) {\n\t\tstartLineNumber = foldingRegion.startLineNumber;\n\t\t// If current line is not the start of the current fold, go to top line of current fold. If not, go to parent fold\n\t\tif (lineNumber === startLineNumber) {\n\t\t\tconst parentFoldingIdx = foldingRegion.parentIndex;\n\t\t\tif (parentFoldingIdx !== -1) {\n\t\t\t\tstartLineNumber =\n\t\t\t\t\tfoldingModel.regions.getStartLineNumber(parentFoldingIdx);\n\t\t\t} else {\n\t\t\t\tstartLineNumber = null;\n\t\t\t}\n\t\t}\n\t}\n\treturn startLineNumber;\n}\n\n/**\n * Get line to go to for previous fold at the same level of current line\n * @param lineNumber the current line number\n * @param foldingModel the folding model\n *\n * @return Previous fold start line\n */\nexport function getPreviousFoldLine(\n\tlineNumber: number,\n\tfoldingModel: FoldingModel,\n): number | null {\n\tlet foldingRegion = foldingModel.getRegionAtLine(lineNumber);\n\t// If on the folding range start line, go to previous sibling.\n\tif (\n\t\tfoldingRegion !== null &&\n\t\tfoldingRegion.startLineNumber === lineNumber\n\t) {\n\t\t// If current line is not the start of the current fold, go to top line of current fold. If not, go to previous fold.\n\t\tif (lineNumber !== foldingRegion.startLineNumber) {\n\t\t\treturn foldingRegion.startLineNumber;\n\t\t} else {\n\t\t\t// Find min line number to stay within parent.\n\t\t\tconst expectedParentIndex = foldingRegion.parentIndex;\n\t\t\tlet minLineNumber = 0;\n\t\t\tif (expectedParentIndex !== -1) {\n\t\t\t\tminLineNumber = foldingModel.regions.getStartLineNumber(\n\t\t\t\t\tfoldingRegion.parentIndex,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Find fold at same level.\n\t\t\twhile (foldingRegion !== null) {\n\t\t\t\tif (foldingRegion.regionIndex > 0) {\n\t\t\t\t\tfoldingRegion = foldingModel.regions.toRegion(\n\t\t\t\t\t\tfoldingRegion.regionIndex - 1,\n\t\t\t\t\t);\n\n\t\t\t\t\t// Keep at same level.\n\t\t\t\t\tif (foldingRegion.startLineNumber <= minLineNumber) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tfoldingRegion.parentIndex === expectedParentIndex\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn foldingRegion.startLineNumber;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Go to last fold that's before the current line.\n\t\tif (foldingModel.regions.length > 0) {\n\t\t\tfoldingRegion = foldingModel.regions.toRegion(\n\t\t\t\tfoldingModel.regions.length - 1,\n\t\t\t);\n\t\t\twhile (foldingRegion !== null) {\n\t\t\t\t// Found fold before current line.\n\t\t\t\tif (foldingRegion.startLineNumber < lineNumber) {\n\t\t\t\t\treturn foldingRegion.startLineNumber;\n\t\t\t\t}\n\t\t\t\tif (foldingRegion.regionIndex > 0) {\n\t\t\t\t\tfoldingRegion = foldingModel.regions.toRegion(\n\t\t\t\t\t\tfoldingRegion.regionIndex - 1,\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tfoldingRegion = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n}\n\n/**\n * Get line to go to next fold at the same level of current line\n * @param lineNumber the current line number\n * @param foldingModel the folding model\n *\n * @return Next fold start line\n */\nexport function getNextFoldLine(\n\tlineNumber: number,\n\tfoldingModel: FoldingModel,\n): number | null {\n\tlet foldingRegion = foldingModel.getRegionAtLine(lineNumber);\n\t// If on the folding range start line, go to next sibling.\n\tif (\n\t\tfoldingRegion !== null &&\n\t\tfoldingRegion.startLineNumber === lineNumber\n\t) {\n\t\t// Find max line number to stay within parent.\n\t\tconst expectedParentIndex = foldingRegion.parentIndex;\n\t\tlet maxLineNumber = 0;\n\t\tif (expectedParentIndex !== -1) {\n\t\t\tmaxLineNumber = foldingModel.regions.getEndLineNumber(\n\t\t\t\tfoldingRegion.parentIndex,\n\t\t\t);\n\t\t} else if (foldingModel.regions.length === 0) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tmaxLineNumber = foldingModel.regions.getEndLineNumber(\n\t\t\t\tfoldingModel.regions.length - 1,\n\t\t\t);\n\t\t}\n\n\t\t// Find fold at same level.\n\t\twhile (foldingRegion !== null) {\n\t\t\tif (foldingRegion.regionIndex < foldingModel.regions.length) {\n\t\t\t\tfoldingRegion = foldingModel.regions.toRegion(\n\t\t\t\t\tfoldingRegion.regionIndex + 1,\n\t\t\t\t);\n\n\t\t\t\t// Keep at same level.\n\t\t\t\tif (foldingRegion.startLineNumber >= maxLineNumber) {\n\t\t\t\t\treturn null;\n\t\t\t\t} else if (foldingRegion.parentIndex === expectedParentIndex) {\n\t\t\t\t\treturn foldingRegion.startLineNumber;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Go to first fold that's after the current line.\n\t\tif (foldingModel.regions.length > 0) {\n\t\t\tfoldingRegion = foldingModel.regions.toRegion(0);\n\t\t\twhile (foldingRegion !== null) {\n\t\t\t\t// Found fold after current line.\n\t\t\t\tif (foldingRegion.startLineNumber > lineNumber) {\n\t\t\t\t\treturn foldingRegion.startLineNumber;\n\t\t\t\t}\n\t\t\t\tif (foldingRegion.regionIndex < foldingModel.regions.length) {\n\t\t\t\t\tfoldingRegion = foldingModel.regions.toRegion(\n\t\t\t\t\t\tfoldingRegion.regionIndex + 1,\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tfoldingRegion = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n}\n"],
  "mappings": "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",
  "names": []
}
