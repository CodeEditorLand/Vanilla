{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/contrib/folding/browser/foldingModel.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { IModelDecorationOptions, IModelDecorationsChangeAccessor, IModelDeltaDecoration, ITextModel } from '../../../common/model.js';\nimport { FoldingRegion, FoldingRegions, ILineRange, FoldRange, FoldSource } from './foldingRanges.js';\nimport { hash } from '../../../../base/common/hash.js';\nimport { SelectedLines } from './folding.js';\n\nexport interface IDecorationProvider {\n\tgetDecorationOption(isCollapsed: boolean, isHidden: boolean, isManual: boolean): IModelDecorationOptions;\n\tchangeDecorations<T>(callback: (changeAccessor: IModelDecorationsChangeAccessor) => T): T | null;\n\tremoveDecorations(decorationIds: string[]): void;\n}\n\nexport interface FoldingModelChangeEvent {\n\tmodel: FoldingModel;\n\tcollapseStateChanged?: FoldingRegion[];\n}\n\ninterface ILineMemento extends ILineRange {\n\tchecksum?: number;\n\tisCollapsed?: boolean;\n\tsource?: FoldSource;\n}\n\nexport type CollapseMemento = ILineMemento[];\n\nexport class FoldingModel {\n\tprivate readonly _textModel: ITextModel;\n\tprivate readonly _decorationProvider: IDecorationProvider;\n\n\tprivate _regions: FoldingRegions;\n\tprivate _editorDecorationIds: string[];\n\n\tprivate readonly _updateEventEmitter = new Emitter<FoldingModelChangeEvent>();\n\tpublic readonly onDidChange: Event<FoldingModelChangeEvent> = this._updateEventEmitter.event;\n\n\tpublic get regions(): FoldingRegions { return this._regions; }\n\tpublic get textModel() { return this._textModel; }\n\tpublic get decorationProvider() { return this._decorationProvider; }\n\n\tconstructor(textModel: ITextModel, decorationProvider: IDecorationProvider) {\n\t\tthis._textModel = textModel;\n\t\tthis._decorationProvider = decorationProvider;\n\t\tthis._regions = new FoldingRegions(new Uint32Array(0), new Uint32Array(0));\n\t\tthis._editorDecorationIds = [];\n\t}\n\n\tpublic toggleCollapseState(toggledRegions: FoldingRegion[]) {\n\t\tif (!toggledRegions.length) {\n\t\t\treturn;\n\t\t}\n\t\ttoggledRegions = toggledRegions.sort((r1, r2) => r1.regionIndex - r2.regionIndex);\n\n\t\tconst processed: { [key: string]: boolean | undefined } = {};\n\t\tthis._decorationProvider.changeDecorations(accessor => {\n\t\t\tlet k = 0; // index from [0 ... this.regions.length]\n\t\t\tlet dirtyRegionEndLine = -1; // end of the range where decorations need to be updated\n\t\t\tlet lastHiddenLine = -1; // the end of the last hidden lines\n\t\t\tconst updateDecorationsUntil = (index: number) => {\n\t\t\t\twhile (k < index) {\n\t\t\t\t\tconst endLineNumber = this._regions.getEndLineNumber(k);\n\t\t\t\t\tconst isCollapsed = this._regions.isCollapsed(k);\n\t\t\t\t\tif (endLineNumber <= dirtyRegionEndLine) {\n\t\t\t\t\t\tconst isManual = this.regions.getSource(k) !== FoldSource.provider;\n\t\t\t\t\t\taccessor.changeDecorationOptions(this._editorDecorationIds[k], this._decorationProvider.getDecorationOption(isCollapsed, endLineNumber <= lastHiddenLine, isManual));\n\t\t\t\t\t}\n\t\t\t\t\tif (isCollapsed && endLineNumber > lastHiddenLine) {\n\t\t\t\t\t\tlastHiddenLine = endLineNumber;\n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t};\n\t\t\tfor (const region of toggledRegions) {\n\t\t\t\tconst index = region.regionIndex;\n\t\t\t\tconst editorDecorationId = this._editorDecorationIds[index];\n\t\t\t\tif (editorDecorationId && !processed[editorDecorationId]) {\n\t\t\t\t\tprocessed[editorDecorationId] = true;\n\n\t\t\t\t\tupdateDecorationsUntil(index); // update all decorations up to current index using the old dirtyRegionEndLine\n\n\t\t\t\t\tconst newCollapseState = !this._regions.isCollapsed(index);\n\t\t\t\t\tthis._regions.setCollapsed(index, newCollapseState);\n\n\t\t\t\t\tdirtyRegionEndLine = Math.max(dirtyRegionEndLine, this._regions.getEndLineNumber(index));\n\t\t\t\t}\n\t\t\t}\n\t\t\tupdateDecorationsUntil(this._regions.length);\n\t\t});\n\t\tthis._updateEventEmitter.fire({ model: this, collapseStateChanged: toggledRegions });\n\t}\n\n\tpublic removeManualRanges(ranges: ILineRange[]) {\n\t\tconst newFoldingRanges: FoldRange[] = new Array();\n\t\tconst intersects = (foldRange: FoldRange) => {\n\t\t\tfor (const range of ranges) {\n\t\t\t\tif (!(range.startLineNumber > foldRange.endLineNumber || foldRange.startLineNumber > range.endLineNumber)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tfor (let i = 0; i < this._regions.length; i++) {\n\t\t\tconst foldRange = this._regions.toFoldRange(i);\n\t\t\tif (foldRange.source === FoldSource.provider || !intersects(foldRange)) {\n\t\t\t\tnewFoldingRanges.push(foldRange);\n\t\t\t}\n\t\t}\n\t\tthis.updatePost(FoldingRegions.fromFoldRanges(newFoldingRanges));\n\t}\n\n\tpublic update(newRegions: FoldingRegions, selection?: SelectedLines): void {\n\t\tconst foldedOrManualRanges = this._currentFoldedOrManualRanges(selection);\n\t\tconst newRanges = FoldingRegions.sanitizeAndMerge(newRegions, foldedOrManualRanges, this._textModel.getLineCount(), selection);\n\t\tthis.updatePost(FoldingRegions.fromFoldRanges(newRanges));\n\t}\n\n\tpublic updatePost(newRegions: FoldingRegions) {\n\t\tconst newEditorDecorations: IModelDeltaDecoration[] = [];\n\t\tlet lastHiddenLine = -1;\n\t\tfor (let index = 0, limit = newRegions.length; index < limit; index++) {\n\t\t\tconst startLineNumber = newRegions.getStartLineNumber(index);\n\t\t\tconst endLineNumber = newRegions.getEndLineNumber(index);\n\t\t\tconst isCollapsed = newRegions.isCollapsed(index);\n\t\t\tconst isManual = newRegions.getSource(index) !== FoldSource.provider;\n\t\t\tconst decorationRange = {\n\t\t\t\tstartLineNumber: startLineNumber,\n\t\t\t\tstartColumn: this._textModel.getLineMaxColumn(startLineNumber),\n\t\t\t\tendLineNumber: endLineNumber,\n\t\t\t\tendColumn: this._textModel.getLineMaxColumn(endLineNumber) + 1\n\t\t\t};\n\t\t\tnewEditorDecorations.push({ range: decorationRange, options: this._decorationProvider.getDecorationOption(isCollapsed, endLineNumber <= lastHiddenLine, isManual) });\n\t\t\tif (isCollapsed && endLineNumber > lastHiddenLine) {\n\t\t\t\tlastHiddenLine = endLineNumber;\n\t\t\t}\n\t\t}\n\t\tthis._decorationProvider.changeDecorations(accessor => this._editorDecorationIds = accessor.deltaDecorations(this._editorDecorationIds, newEditorDecorations));\n\t\tthis._regions = newRegions;\n\t\tthis._updateEventEmitter.fire({ model: this });\n\t}\n\n\tprivate _currentFoldedOrManualRanges(selection?: SelectedLines): FoldRange[] {\n\t\tconst foldedRanges: FoldRange[] = [];\n\t\tfor (let i = 0, limit = this._regions.length; i < limit; i++) {\n\t\t\tlet isCollapsed = this.regions.isCollapsed(i);\n\t\t\tconst source = this.regions.getSource(i);\n\t\t\tif (isCollapsed || source !== FoldSource.provider) {\n\t\t\t\tconst foldRange = this._regions.toFoldRange(i);\n\t\t\t\tconst decRange = this._textModel.getDecorationRange(this._editorDecorationIds[i]);\n\t\t\t\tif (decRange) {\n\t\t\t\t\tif (isCollapsed && selection?.startsInside(decRange.startLineNumber + 1, decRange.endLineNumber)) {\n\t\t\t\t\t\tisCollapsed = false; // uncollapse is the range is blocked\n\t\t\t\t\t}\n\t\t\t\t\tfoldedRanges.push({\n\t\t\t\t\t\tstartLineNumber: decRange.startLineNumber,\n\t\t\t\t\t\tendLineNumber: decRange.endLineNumber,\n\t\t\t\t\t\ttype: foldRange.type,\n\t\t\t\t\t\tisCollapsed,\n\t\t\t\t\t\tsource\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn foldedRanges;\n\t}\n\n\t/**\n\t * Collapse state memento, for persistence only\n\t */\n\tpublic getMemento(): CollapseMemento | undefined {\n\t\tconst foldedOrManualRanges = this._currentFoldedOrManualRanges();\n\t\tconst result: ILineMemento[] = [];\n\t\tconst maxLineNumber = this._textModel.getLineCount();\n\t\tfor (let i = 0, limit = foldedOrManualRanges.length; i < limit; i++) {\n\t\t\tconst range = foldedOrManualRanges[i];\n\t\t\tif (range.startLineNumber >= range.endLineNumber || range.startLineNumber < 1 || range.endLineNumber > maxLineNumber) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst checksum = this._getLinesChecksum(range.startLineNumber + 1, range.endLineNumber);\n\t\t\tresult.push({\n\t\t\t\tstartLineNumber: range.startLineNumber,\n\t\t\t\tendLineNumber: range.endLineNumber,\n\t\t\t\tisCollapsed: range.isCollapsed,\n\t\t\t\tsource: range.source,\n\t\t\t\tchecksum: checksum\n\t\t\t});\n\t\t}\n\t\treturn (result.length > 0) ? result : undefined;\n\t}\n\n\t/**\n\t * Apply persisted state, for persistence only\n\t */\n\tpublic applyMemento(state: CollapseMemento) {\n\t\tif (!Array.isArray(state)) {\n\t\t\treturn;\n\t\t}\n\t\tconst rangesToRestore: FoldRange[] = [];\n\t\tconst maxLineNumber = this._textModel.getLineCount();\n\t\tfor (const range of state) {\n\t\t\tif (range.startLineNumber >= range.endLineNumber || range.startLineNumber < 1 || range.endLineNumber > maxLineNumber) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst checksum = this._getLinesChecksum(range.startLineNumber + 1, range.endLineNumber);\n\t\t\tif (!range.checksum || checksum === range.checksum) {\n\t\t\t\trangesToRestore.push({\n\t\t\t\t\tstartLineNumber: range.startLineNumber,\n\t\t\t\t\tendLineNumber: range.endLineNumber,\n\t\t\t\t\ttype: undefined,\n\t\t\t\t\tisCollapsed: range.isCollapsed ?? true,\n\t\t\t\t\tsource: range.source ?? FoldSource.provider\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tconst newRanges = FoldingRegions.sanitizeAndMerge(this._regions, rangesToRestore, maxLineNumber);\n\t\tthis.updatePost(FoldingRegions.fromFoldRanges(newRanges));\n\t}\n\n\tprivate _getLinesChecksum(lineNumber1: number, lineNumber2: number): number {\n\t\tconst h = hash(this._textModel.getLineContent(lineNumber1)\n\t\t\t+ this._textModel.getLineContent(lineNumber2));\n\t\treturn h % 1000000; // 6 digits is plenty\n\t}\n\n\tpublic dispose() {\n\t\tthis._decorationProvider.removeDecorations(this._editorDecorationIds);\n\t}\n\n\tgetAllRegionsAtLine(lineNumber: number, filter?: (r: FoldingRegion, level: number) => boolean): FoldingRegion[] {\n\t\tconst result: FoldingRegion[] = [];\n\t\tif (this._regions) {\n\t\t\tlet index = this._regions.findRange(lineNumber);\n\t\t\tlet level = 1;\n\t\t\twhile (index >= 0) {\n\t\t\t\tconst current = this._regions.toRegion(index);\n\t\t\t\tif (!filter || filter(current, level)) {\n\t\t\t\t\tresult.push(current);\n\t\t\t\t}\n\t\t\t\tlevel++;\n\t\t\t\tindex = current.parentIndex;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tgetRegionAtLine(lineNumber: number): FoldingRegion | null {\n\t\tif (this._regions) {\n\t\t\tconst index = this._regions.findRange(lineNumber);\n\t\t\tif (index >= 0) {\n\t\t\t\treturn this._regions.toRegion(index);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tgetRegionsInside(region: FoldingRegion | null, filter?: RegionFilter | RegionFilterWithLevel): FoldingRegion[] {\n\t\tconst result: FoldingRegion[] = [];\n\t\tconst index = region ? region.regionIndex + 1 : 0;\n\t\tconst endLineNumber = region ? region.endLineNumber : Number.MAX_VALUE;\n\n\t\tif (filter && filter.length === 2) {\n\t\t\tconst levelStack: FoldingRegion[] = [];\n\t\t\tfor (let i = index, len = this._regions.length; i < len; i++) {\n\t\t\t\tconst current = this._regions.toRegion(i);\n\t\t\t\tif (this._regions.getStartLineNumber(i) < endLineNumber) {\n\t\t\t\t\twhile (levelStack.length > 0 && !current.containedBy(levelStack[levelStack.length - 1])) {\n\t\t\t\t\t\tlevelStack.pop();\n\t\t\t\t\t}\n\t\t\t\t\tlevelStack.push(current);\n\t\t\t\t\tif (filter(current, levelStack.length)) {\n\t\t\t\t\t\tresult.push(current);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = index, len = this._regions.length; i < len; i++) {\n\t\t\t\tconst current = this._regions.toRegion(i);\n\t\t\t\tif (this._regions.getStartLineNumber(i) < endLineNumber) {\n\t\t\t\t\tif (!filter || (filter as RegionFilter)(current)) {\n\t\t\t\t\t\tresult.push(current);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n}\n\ntype RegionFilter = (r: FoldingRegion) => boolean;\ntype RegionFilterWithLevel = (r: FoldingRegion, level: number) => boolean;\n\n\n/**\n * Collapse or expand the regions at the given locations\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\n */\nexport function toggleCollapseState(foldingModel: FoldingModel, levels: number, lineNumbers: number[]) {\n\tconst toToggle: FoldingRegion[] = [];\n\tfor (const lineNumber of lineNumbers) {\n\t\tconst region = foldingModel.getRegionAtLine(lineNumber);\n\t\tif (region) {\n\t\t\tconst doCollapse = !region.isCollapsed;\n\t\t\ttoToggle.push(region);\n\t\t\tif (levels > 1) {\n\t\t\t\tconst regionsInside = foldingModel.getRegionsInside(region, (r, level: number) => r.isCollapsed !== doCollapse && level < levels);\n\t\t\t\ttoToggle.push(...regionsInside);\n\t\t\t}\n\t\t}\n\t}\n\tfoldingModel.toggleCollapseState(toToggle);\n}\n\n\n/**\n * Collapse or expand the regions at the given locations including all children.\n * @param doCollapse Whether to collapse or expand\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\n */\nexport function setCollapseStateLevelsDown(foldingModel: FoldingModel, doCollapse: boolean, levels = Number.MAX_VALUE, lineNumbers?: number[]): void {\n\tconst toToggle: FoldingRegion[] = [];\n\tif (lineNumbers && lineNumbers.length > 0) {\n\t\tfor (const lineNumber of lineNumbers) {\n\t\t\tconst region = foldingModel.getRegionAtLine(lineNumber);\n\t\t\tif (region) {\n\t\t\t\tif (region.isCollapsed !== doCollapse) {\n\t\t\t\t\ttoToggle.push(region);\n\t\t\t\t}\n\t\t\t\tif (levels > 1) {\n\t\t\t\t\tconst regionsInside = foldingModel.getRegionsInside(region, (r, level: number) => r.isCollapsed !== doCollapse && level < levels);\n\t\t\t\t\ttoToggle.push(...regionsInside);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tconst regionsInside = foldingModel.getRegionsInside(null, (r, level: number) => r.isCollapsed !== doCollapse && level < levels);\n\t\ttoToggle.push(...regionsInside);\n\t}\n\tfoldingModel.toggleCollapseState(toToggle);\n}\n\n/**\n * Collapse or expand the regions at the given locations including all parents.\n * @param doCollapse Whether to collapse or expand\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand.\n */\nexport function setCollapseStateLevelsUp(foldingModel: FoldingModel, doCollapse: boolean, levels: number, lineNumbers: number[]): void {\n\tconst toToggle: FoldingRegion[] = [];\n\tfor (const lineNumber of lineNumbers) {\n\t\tconst regions = foldingModel.getAllRegionsAtLine(lineNumber, (region, level) => region.isCollapsed !== doCollapse && level <= levels);\n\t\ttoToggle.push(...regions);\n\t}\n\tfoldingModel.toggleCollapseState(toToggle);\n}\n\n/**\n * Collapse or expand a region at the given locations. If the inner most region is already collapsed/expanded, uses the first parent instead.\n * @param doCollapse Whether to collapse or expand\n * @param lineNumbers the location of the regions to collapse or expand.\n */\nexport function setCollapseStateUp(foldingModel: FoldingModel, doCollapse: boolean, lineNumbers: number[]): void {\n\tconst toToggle: FoldingRegion[] = [];\n\tfor (const lineNumber of lineNumbers) {\n\t\tconst regions = foldingModel.getAllRegionsAtLine(lineNumber, (region,) => region.isCollapsed !== doCollapse);\n\t\tif (regions.length > 0) {\n\t\t\ttoToggle.push(regions[0]);\n\t\t}\n\t}\n\tfoldingModel.toggleCollapseState(toToggle);\n}\n\n/**\n * Folds or unfolds all regions that have a given level, except if they contain one of the blocked lines.\n * @param foldLevel level. Level == 1 is the top level\n * @param doCollapse Whether to collapse or expand\n*/\nexport function setCollapseStateAtLevel(foldingModel: FoldingModel, foldLevel: number, doCollapse: boolean, blockedLineNumbers: number[]): void {\n\tconst filter = (region: FoldingRegion, level: number) => level === foldLevel && region.isCollapsed !== doCollapse && !blockedLineNumbers.some(line => region.containsLine(line));\n\tconst toToggle = foldingModel.getRegionsInside(null, filter);\n\tfoldingModel.toggleCollapseState(toToggle);\n}\n\n/**\n * Folds or unfolds all regions, except if they contain or are contained by a region of one of the blocked lines.\n * @param doCollapse Whether to collapse or expand\n * @param blockedLineNumbers the location of regions to not collapse or expand\n */\nexport function setCollapseStateForRest(foldingModel: FoldingModel, doCollapse: boolean, blockedLineNumbers: number[]): void {\n\tconst filteredRegions: FoldingRegion[] = [];\n\tfor (const lineNumber of blockedLineNumbers) {\n\t\tconst regions = foldingModel.getAllRegionsAtLine(lineNumber, undefined);\n\t\tif (regions.length > 0) {\n\t\t\tfilteredRegions.push(regions[0]);\n\t\t}\n\t}\n\tconst filter = (region: FoldingRegion) => filteredRegions.every((filteredRegion) => !filteredRegion.containedBy(region) && !region.containedBy(filteredRegion)) && region.isCollapsed !== doCollapse;\n\tconst toToggle = foldingModel.getRegionsInside(null, filter);\n\tfoldingModel.toggleCollapseState(toToggle);\n}\n\n/**\n * Folds all regions for which the lines start with a given regex\n * @param foldingModel the folding model\n */\nexport function setCollapseStateForMatchingLines(foldingModel: FoldingModel, regExp: RegExp, doCollapse: boolean): void {\n\tconst editorModel = foldingModel.textModel;\n\tconst regions = foldingModel.regions;\n\tconst toToggle: FoldingRegion[] = [];\n\tfor (let i = regions.length - 1; i >= 0; i--) {\n\t\tif (doCollapse !== regions.isCollapsed(i)) {\n\t\t\tconst startLineNumber = regions.getStartLineNumber(i);\n\t\t\tif (regExp.test(editorModel.getLineContent(startLineNumber))) {\n\t\t\t\ttoToggle.push(regions.toRegion(i));\n\t\t\t}\n\t\t}\n\t}\n\tfoldingModel.toggleCollapseState(toToggle);\n}\n\n/**\n * Folds all regions of the given type\n * @param foldingModel the folding model\n */\nexport function setCollapseStateForType(foldingModel: FoldingModel, type: string, doCollapse: boolean): void {\n\tconst regions = foldingModel.regions;\n\tconst toToggle: FoldingRegion[] = [];\n\tfor (let i = regions.length - 1; i >= 0; i--) {\n\t\tif (doCollapse !== regions.isCollapsed(i) && type === regions.getType(i)) {\n\t\t\ttoToggle.push(regions.toRegion(i));\n\t\t}\n\t}\n\tfoldingModel.toggleCollapseState(toToggle);\n}\n\n/**\n * Get line to go to for parent fold of current line\n * @param lineNumber the current line number\n * @param foldingModel the folding model\n *\n * @return Parent fold start line\n */\nexport function getParentFoldLine(lineNumber: number, foldingModel: FoldingModel): number | null {\n\tlet startLineNumber: number | null = null;\n\tconst foldingRegion = foldingModel.getRegionAtLine(lineNumber);\n\tif (foldingRegion !== null) {\n\t\tstartLineNumber = foldingRegion.startLineNumber;\n\t\t// If current line is not the start of the current fold, go to top line of current fold. If not, go to parent fold\n\t\tif (lineNumber === startLineNumber) {\n\t\t\tconst parentFoldingIdx = foldingRegion.parentIndex;\n\t\t\tif (parentFoldingIdx !== -1) {\n\t\t\t\tstartLineNumber = foldingModel.regions.getStartLineNumber(parentFoldingIdx);\n\t\t\t} else {\n\t\t\t\tstartLineNumber = null;\n\t\t\t}\n\t\t}\n\t}\n\treturn startLineNumber;\n}\n\n/**\n * Get line to go to for previous fold at the same level of current line\n * @param lineNumber the current line number\n * @param foldingModel the folding model\n *\n * @return Previous fold start line\n */\nexport function getPreviousFoldLine(lineNumber: number, foldingModel: FoldingModel): number | null {\n\tlet foldingRegion = foldingModel.getRegionAtLine(lineNumber);\n\t// If on the folding range start line, go to previous sibling.\n\tif (foldingRegion !== null && foldingRegion.startLineNumber === lineNumber) {\n\t\t// If current line is not the start of the current fold, go to top line of current fold. If not, go to previous fold.\n\t\tif (lineNumber !== foldingRegion.startLineNumber) {\n\t\t\treturn foldingRegion.startLineNumber;\n\t\t} else {\n\t\t\t// Find min line number to stay within parent.\n\t\t\tconst expectedParentIndex = foldingRegion.parentIndex;\n\t\t\tlet minLineNumber = 0;\n\t\t\tif (expectedParentIndex !== -1) {\n\t\t\t\tminLineNumber = foldingModel.regions.getStartLineNumber(foldingRegion.parentIndex);\n\t\t\t}\n\n\t\t\t// Find fold at same level.\n\t\t\twhile (foldingRegion !== null) {\n\t\t\t\tif (foldingRegion.regionIndex > 0) {\n\t\t\t\t\tfoldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex - 1);\n\n\t\t\t\t\t// Keep at same level.\n\t\t\t\t\tif (foldingRegion.startLineNumber <= minLineNumber) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t} else if (foldingRegion.parentIndex === expectedParentIndex) {\n\t\t\t\t\t\treturn foldingRegion.startLineNumber;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Go to last fold that's before the current line.\n\t\tif (foldingModel.regions.length > 0) {\n\t\t\tfoldingRegion = foldingModel.regions.toRegion(foldingModel.regions.length - 1);\n\t\t\twhile (foldingRegion !== null) {\n\t\t\t\t// Found fold before current line.\n\t\t\t\tif (foldingRegion.startLineNumber < lineNumber) {\n\t\t\t\t\treturn foldingRegion.startLineNumber;\n\t\t\t\t}\n\t\t\t\tif (foldingRegion.regionIndex > 0) {\n\t\t\t\t\tfoldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex - 1);\n\t\t\t\t} else {\n\t\t\t\t\tfoldingRegion = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n}\n\n/**\n * Get line to go to next fold at the same level of current line\n * @param lineNumber the current line number\n * @param foldingModel the folding model\n *\n * @return Next fold start line\n */\nexport function getNextFoldLine(lineNumber: number, foldingModel: FoldingModel): number | null {\n\tlet foldingRegion = foldingModel.getRegionAtLine(lineNumber);\n\t// If on the folding range start line, go to next sibling.\n\tif (foldingRegion !== null && foldingRegion.startLineNumber === lineNumber) {\n\t\t// Find max line number to stay within parent.\n\t\tconst expectedParentIndex = foldingRegion.parentIndex;\n\t\tlet maxLineNumber = 0;\n\t\tif (expectedParentIndex !== -1) {\n\t\t\tmaxLineNumber = foldingModel.regions.getEndLineNumber(foldingRegion.parentIndex);\n\t\t} else if (foldingModel.regions.length === 0) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tmaxLineNumber = foldingModel.regions.getEndLineNumber(foldingModel.regions.length - 1);\n\t\t}\n\n\t\t// Find fold at same level.\n\t\twhile (foldingRegion !== null) {\n\t\t\tif (foldingRegion.regionIndex < foldingModel.regions.length) {\n\t\t\t\tfoldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex + 1);\n\n\t\t\t\t// Keep at same level.\n\t\t\t\tif (foldingRegion.startLineNumber >= maxLineNumber) {\n\t\t\t\t\treturn null;\n\t\t\t\t} else if (foldingRegion.parentIndex === expectedParentIndex) {\n\t\t\t\t\treturn foldingRegion.startLineNumber;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Go to first fold that's after the current line.\n\t\tif (foldingModel.regions.length > 0) {\n\t\t\tfoldingRegion = foldingModel.regions.toRegion(0);\n\t\t\twhile (foldingRegion !== null) {\n\t\t\t\t// Found fold after current line.\n\t\t\t\tif (foldingRegion.startLineNumber > lineNumber) {\n\t\t\t\t\treturn foldingRegion.startLineNumber;\n\t\t\t\t}\n\t\t\t\tif (foldingRegion.regionIndex < foldingModel.regions.length) {\n\t\t\t\t\tfoldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex + 1);\n\t\t\t\t} else {\n\t\t\t\t\tfoldingRegion = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n}\n"],
  "mappings": "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",
  "names": []
}
