import"../../../../../vs/editor/contrib/folding/browser/folding.js";var x=(n=>(n[n.provider=0]="provider",n[n.userDefined=1]="userDefined",n[n.recovered=2]="recovered",n))(x||{});const I={0:" ",1:"u",2:"r"},_=65535,p=16777215,y=4278190080;class m{_states;constructor(e){const t=Math.ceil(e/32);this._states=new Uint32Array(t)}get(e){const t=e/32|0,n=e%32;return(this._states[t]&1<<n)!==0}set(e,t){const n=e/32|0,s=e%32,i=this._states[n];t?this._states[n]=i|1<<s:this._states[n]=i&~(1<<s)}}class v{_startIndexes;_endIndexes;_collapseStates;_userDefinedStates;_recoveredStates;_parentsComputed;_types;constructor(e,t,n){if(e.length!==t.length||e.length>_)throw new Error("invalid startIndexes or endIndexes size");this._startIndexes=e,this._endIndexes=t,this._collapseStates=new m(e.length),this._userDefinedStates=new m(e.length),this._recoveredStates=new m(e.length),this._types=n,this._parentsComputed=!1}ensureParentIndices(){if(!this._parentsComputed){this._parentsComputed=!0;const e=[],t=(n,s)=>{const i=e[e.length-1];return this.getStartLineNumber(i)<=n&&this.getEndLineNumber(i)>=s};for(let n=0,s=this._startIndexes.length;n<s;n++){const i=this._startIndexes[n],l=this._endIndexes[n];if(i>p||l>p)throw new Error("startLineNumber or endLineNumber must not exceed "+p);for(;e.length>0&&!t(i,l);)e.pop();const b=e.length>0?e[e.length-1]:-1;e.push(n),this._startIndexes[n]=i+((b&255)<<24),this._endIndexes[n]=l+((b&65280)<<16)}}}get length(){return this._startIndexes.length}getStartLineNumber(e){return this._startIndexes[e]&p}getEndLineNumber(e){return this._endIndexes[e]&p}getType(e){return this._types?this._types[e]:void 0}hasTypes(){return!!this._types}isCollapsed(e){return this._collapseStates.get(e)}setCollapsed(e,t){this._collapseStates.set(e,t)}isUserDefined(e){return this._userDefinedStates.get(e)}setUserDefined(e,t){return this._userDefinedStates.set(e,t)}isRecovered(e){return this._recoveredStates.get(e)}setRecovered(e,t){return this._recoveredStates.set(e,t)}getSource(e){return this.isUserDefined(e)?1:this.isRecovered(e)?2:0}setSource(e,t){t===1?(this.setUserDefined(e,!0),this.setRecovered(e,!1)):t===2?(this.setUserDefined(e,!1),this.setRecovered(e,!0)):(this.setUserDefined(e,!1),this.setRecovered(e,!1))}setCollapsedAllOfType(e,t){let n=!1;if(this._types)for(let s=0;s<this._types.length;s++)this._types[s]===e&&(this.setCollapsed(s,t),n=!0);return n}toRegion(e){return new F(this,e)}getParentIndex(e){this.ensureParentIndices();const t=((this._startIndexes[e]&y)>>>24)+((this._endIndexes[e]&y)>>>16);return t===_?-1:t}contains(e,t){return this.getStartLineNumber(e)<=t&&this.getEndLineNumber(e)>=t}findIndex(e){let t=0,n=this._startIndexes.length;if(n===0)return-1;for(;t<n;){const s=Math.floor((t+n)/2);e<this.getStartLineNumber(s)?n=s:t=s+1}return t-1}findRange(e){let t=this.findIndex(e);if(t>=0){if(this.getEndLineNumber(t)>=e)return t;for(t=this.getParentIndex(t);t!==-1;){if(this.contains(t,e))return t;t=this.getParentIndex(t)}}return-1}toString(){const e=[];for(let t=0;t<this.length;t++)e[t]=`[${I[this.getSource(t)]}${this.isCollapsed(t)?"+":"-"}] ${this.getStartLineNumber(t)}/${this.getEndLineNumber(t)}`;return e.join(", ")}toFoldRange(e){return{startLineNumber:this._startIndexes[e]&p,endLineNumber:this._endIndexes[e]&p,type:this._types?this._types[e]:void 0,isCollapsed:this.isCollapsed(e),source:this.getSource(e)}}static fromFoldRanges(e){const t=e.length,n=new Uint32Array(t),s=new Uint32Array(t);let i=[],l=!1;for(let u=0;u<t;u++){const h=e[u];n[u]=h.startLineNumber,s[u]=h.endLineNumber,i.push(h.type),h.type&&(l=!0)}l||(i=void 0);const b=new v(n,s,i);for(let u=0;u<t;u++)e[u].isCollapsed&&b.setCollapsed(u,!0),b.setSource(u,e[u].source);return b}static sanitizeAndMerge(e,t,n,s){n=n??Number.MAX_VALUE;const i=(r,g)=>Array.isArray(r)?a=>a<g?r[a]:void 0:a=>a<g?r.toFoldRange(a):void 0,l=i(e,e.length),b=i(t,t.length);let u=0,h=0,o=l(0),d=b(0);const f=[];let c,L=0;const N=[];for(;o||d;){let r;if(d&&(!o||o.startLineNumber>=d.startLineNumber))o&&o.startLineNumber===d.startLineNumber?(d.source===1?r=d:(r=o,r.isCollapsed=d.isCollapsed&&(o.endLineNumber===d.endLineNumber||!s?.startsInside(o.startLineNumber+1,o.endLineNumber+1)),r.source=0),o=l(++u)):(r=d,d.isCollapsed&&d.source===0&&(r.source=2)),d=b(++h);else{let g=h,a=d;for(;;){if(!a||a.startLineNumber>o.endLineNumber){r=o;break}if(a.source===1&&a.endLineNumber>o.endLineNumber)break;a=b(++g)}o=l(++u)}if(r){for(;c&&c.endLineNumber<r.startLineNumber;)c=f.pop();r.endLineNumber>r.startLineNumber&&r.startLineNumber>L&&r.endLineNumber<=n&&(!c||c.endLineNumber>=r.endLineNumber)&&(N.push(r),L=r.startLineNumber,c&&f.push(c),c=r)}}return N}}class F{constructor(e,t){this.ranges=e;this.index=t}get startLineNumber(){return this.ranges.getStartLineNumber(this.index)}get endLineNumber(){return this.ranges.getEndLineNumber(this.index)}get regionIndex(){return this.index}get parentIndex(){return this.ranges.getParentIndex(this.index)}get isCollapsed(){return this.ranges.isCollapsed(this.index)}containedBy(e){return e.startLineNumber<=this.startLineNumber&&e.endLineNumber>=this.endLineNumber}containsLine(e){return this.startLineNumber<=e&&e<=this.endLineNumber}hidesLine(e){return this.startLineNumber<e&&e<=this.endLineNumber}}export{x as FoldSource,F as FoldingRegion,v as FoldingRegions,_ as MAX_FOLDING_REGIONS,p as MAX_LINE_NUMBER,I as foldSourceAbbr};
