{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/contrib/folding/browser/foldingRanges.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { SelectedLines } from './folding.js';\n\nexport interface ILineRange {\n\tstartLineNumber: number;\n\tendLineNumber: number;\n}\n\nexport const enum FoldSource {\n\tprovider = 0,\n\tuserDefined = 1,\n\trecovered = 2\n}\n\nexport const foldSourceAbbr = {\n\t[FoldSource.provider]: ' ',\n\t[FoldSource.userDefined]: 'u',\n\t[FoldSource.recovered]: 'r',\n};\n\nexport interface FoldRange {\n\tstartLineNumber: number;\n\tendLineNumber: number;\n\ttype: string | undefined;\n\tisCollapsed: boolean;\n\tsource: FoldSource;\n}\n\nexport const MAX_FOLDING_REGIONS = 0xFFFF;\nexport const MAX_LINE_NUMBER = 0xFFFFFF;\n\nconst MASK_INDENT = 0xFF000000;\n\nclass BitField {\n\tprivate readonly _states: Uint32Array;\n\tconstructor(size: number) {\n\t\tconst numWords = Math.ceil(size / 32);\n\t\tthis._states = new Uint32Array(numWords);\n\t}\n\n\tpublic get(index: number): boolean {\n\t\tconst arrayIndex = (index / 32) | 0;\n\t\tconst bit = index % 32;\n\t\treturn (this._states[arrayIndex] & (1 << bit)) !== 0;\n\t}\n\n\tpublic set(index: number, newState: boolean) {\n\t\tconst arrayIndex = (index / 32) | 0;\n\t\tconst bit = index % 32;\n\t\tconst value = this._states[arrayIndex];\n\t\tif (newState) {\n\t\t\tthis._states[arrayIndex] = value | (1 << bit);\n\t\t} else {\n\t\t\tthis._states[arrayIndex] = value & ~(1 << bit);\n\t\t}\n\t}\n}\n\nexport class FoldingRegions {\n\tprivate readonly _startIndexes: Uint32Array;\n\tprivate readonly _endIndexes: Uint32Array;\n\tprivate readonly _collapseStates: BitField;\n\tprivate readonly _userDefinedStates: BitField;\n\tprivate readonly _recoveredStates: BitField;\n\n\tprivate _parentsComputed: boolean;\n\tprivate readonly _types: Array<string | undefined> | undefined;\n\n\tconstructor(startIndexes: Uint32Array, endIndexes: Uint32Array, types?: Array<string | undefined>) {\n\t\tif (startIndexes.length !== endIndexes.length || startIndexes.length > MAX_FOLDING_REGIONS) {\n\t\t\tthrow new Error('invalid startIndexes or endIndexes size');\n\t\t}\n\t\tthis._startIndexes = startIndexes;\n\t\tthis._endIndexes = endIndexes;\n\t\tthis._collapseStates = new BitField(startIndexes.length);\n\t\tthis._userDefinedStates = new BitField(startIndexes.length);\n\t\tthis._recoveredStates = new BitField(startIndexes.length);\n\t\tthis._types = types;\n\t\tthis._parentsComputed = false;\n\t}\n\n\tprivate ensureParentIndices() {\n\t\tif (!this._parentsComputed) {\n\t\t\tthis._parentsComputed = true;\n\t\t\tconst parentIndexes: number[] = [];\n\t\t\tconst isInsideLast = (startLineNumber: number, endLineNumber: number) => {\n\t\t\t\tconst index = parentIndexes[parentIndexes.length - 1];\n\t\t\t\treturn this.getStartLineNumber(index) <= startLineNumber && this.getEndLineNumber(index) >= endLineNumber;\n\t\t\t};\n\t\t\tfor (let i = 0, len = this._startIndexes.length; i < len; i++) {\n\t\t\t\tconst startLineNumber = this._startIndexes[i];\n\t\t\t\tconst endLineNumber = this._endIndexes[i];\n\t\t\t\tif (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {\n\t\t\t\t\tthrow new Error('startLineNumber or endLineNumber must not exceed ' + MAX_LINE_NUMBER);\n\t\t\t\t}\n\t\t\t\twhile (parentIndexes.length > 0 && !isInsideLast(startLineNumber, endLineNumber)) {\n\t\t\t\t\tparentIndexes.pop();\n\t\t\t\t}\n\t\t\t\tconst parentIndex = parentIndexes.length > 0 ? parentIndexes[parentIndexes.length - 1] : -1;\n\t\t\t\tparentIndexes.push(i);\n\t\t\t\tthis._startIndexes[i] = startLineNumber + ((parentIndex & 0xFF) << 24);\n\t\t\t\tthis._endIndexes[i] = endLineNumber + ((parentIndex & 0xFF00) << 16);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic get length(): number {\n\t\treturn this._startIndexes.length;\n\t}\n\n\tpublic getStartLineNumber(index: number): number {\n\t\treturn this._startIndexes[index] & MAX_LINE_NUMBER;\n\t}\n\n\tpublic getEndLineNumber(index: number): number {\n\t\treturn this._endIndexes[index] & MAX_LINE_NUMBER;\n\t}\n\n\tpublic getType(index: number): string | undefined {\n\t\treturn this._types ? this._types[index] : undefined;\n\t}\n\n\tpublic hasTypes() {\n\t\treturn !!this._types;\n\t}\n\n\tpublic isCollapsed(index: number): boolean {\n\t\treturn this._collapseStates.get(index);\n\t}\n\n\tpublic setCollapsed(index: number, newState: boolean) {\n\t\tthis._collapseStates.set(index, newState);\n\t}\n\n\tprivate isUserDefined(index: number): boolean {\n\t\treturn this._userDefinedStates.get(index);\n\t}\n\n\tprivate setUserDefined(index: number, newState: boolean) {\n\t\treturn this._userDefinedStates.set(index, newState);\n\t}\n\n\tprivate isRecovered(index: number): boolean {\n\t\treturn this._recoveredStates.get(index);\n\t}\n\n\tprivate setRecovered(index: number, newState: boolean) {\n\t\treturn this._recoveredStates.set(index, newState);\n\t}\n\n\tpublic getSource(index: number): FoldSource {\n\t\tif (this.isUserDefined(index)) {\n\t\t\treturn FoldSource.userDefined;\n\t\t} else if (this.isRecovered(index)) {\n\t\t\treturn FoldSource.recovered;\n\t\t}\n\t\treturn FoldSource.provider;\n\t}\n\n\tpublic setSource(index: number, source: FoldSource): void {\n\t\tif (source === FoldSource.userDefined) {\n\t\t\tthis.setUserDefined(index, true);\n\t\t\tthis.setRecovered(index, false);\n\t\t} else if (source === FoldSource.recovered) {\n\t\t\tthis.setUserDefined(index, false);\n\t\t\tthis.setRecovered(index, true);\n\t\t} else {\n\t\t\tthis.setUserDefined(index, false);\n\t\t\tthis.setRecovered(index, false);\n\t\t}\n\t}\n\n\tpublic setCollapsedAllOfType(type: string, newState: boolean) {\n\t\tlet hasChanged = false;\n\t\tif (this._types) {\n\t\t\tfor (let i = 0; i < this._types.length; i++) {\n\t\t\t\tif (this._types[i] === type) {\n\t\t\t\t\tthis.setCollapsed(i, newState);\n\t\t\t\t\thasChanged = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn hasChanged;\n\t}\n\n\tpublic toRegion(index: number): FoldingRegion {\n\t\treturn new FoldingRegion(this, index);\n\t}\n\n\tpublic getParentIndex(index: number) {\n\t\tthis.ensureParentIndices();\n\t\tconst parent = ((this._startIndexes[index] & MASK_INDENT) >>> 24) + ((this._endIndexes[index] & MASK_INDENT) >>> 16);\n\t\tif (parent === MAX_FOLDING_REGIONS) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn parent;\n\t}\n\n\tpublic contains(index: number, line: number) {\n\t\treturn this.getStartLineNumber(index) <= line && this.getEndLineNumber(index) >= line;\n\t}\n\n\tprivate findIndex(line: number) {\n\t\tlet low = 0, high = this._startIndexes.length;\n\t\tif (high === 0) {\n\t\t\treturn -1; // no children\n\t\t}\n\t\twhile (low < high) {\n\t\t\tconst mid = Math.floor((low + high) / 2);\n\t\t\tif (line < this.getStartLineNumber(mid)) {\n\t\t\t\thigh = mid;\n\t\t\t} else {\n\t\t\t\tlow = mid + 1;\n\t\t\t}\n\t\t}\n\t\treturn low - 1;\n\t}\n\n\tpublic findRange(line: number): number {\n\t\tlet index = this.findIndex(line);\n\t\tif (index >= 0) {\n\t\t\tconst endLineNumber = this.getEndLineNumber(index);\n\t\t\tif (endLineNumber >= line) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t\tindex = this.getParentIndex(index);\n\t\t\twhile (index !== -1) {\n\t\t\t\tif (this.contains(index, line)) {\n\t\t\t\t\treturn index;\n\t\t\t\t}\n\t\t\t\tindex = this.getParentIndex(index);\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\n\tpublic toString() {\n\t\tconst res: string[] = [];\n\t\tfor (let i = 0; i < this.length; i++) {\n\t\t\tres[i] = `[${foldSourceAbbr[this.getSource(i)]}${this.isCollapsed(i) ? '+' : '-'}] ${this.getStartLineNumber(i)}/${this.getEndLineNumber(i)}`;\n\t\t}\n\t\treturn res.join(', ');\n\t}\n\n\tpublic toFoldRange(index: number): FoldRange {\n\t\treturn {\n\t\t\tstartLineNumber: this._startIndexes[index] & MAX_LINE_NUMBER,\n\t\t\tendLineNumber: this._endIndexes[index] & MAX_LINE_NUMBER,\n\t\t\ttype: this._types ? this._types[index] : undefined,\n\t\t\tisCollapsed: this.isCollapsed(index),\n\t\t\tsource: this.getSource(index)\n\t\t};\n\t}\n\n\tpublic static fromFoldRanges(ranges: FoldRange[]): FoldingRegions {\n\t\tconst rangesLength = ranges.length;\n\t\tconst startIndexes = new Uint32Array(rangesLength);\n\t\tconst endIndexes = new Uint32Array(rangesLength);\n\t\tlet types: Array<string | undefined> | undefined = [];\n\t\tlet gotTypes = false;\n\t\tfor (let i = 0; i < rangesLength; i++) {\n\t\t\tconst range = ranges[i];\n\t\t\tstartIndexes[i] = range.startLineNumber;\n\t\t\tendIndexes[i] = range.endLineNumber;\n\t\t\ttypes.push(range.type);\n\t\t\tif (range.type) {\n\t\t\t\tgotTypes = true;\n\t\t\t}\n\t\t}\n\t\tif (!gotTypes) {\n\t\t\ttypes = undefined;\n\t\t}\n\t\tconst regions = new FoldingRegions(startIndexes, endIndexes, types);\n\t\tfor (let i = 0; i < rangesLength; i++) {\n\t\t\tif (ranges[i].isCollapsed) {\n\t\t\t\tregions.setCollapsed(i, true);\n\t\t\t}\n\t\t\tregions.setSource(i, ranges[i].source);\n\t\t}\n\t\treturn regions;\n\t}\n\n\t/**\n\t * Two inputs, each a FoldingRegions or a FoldRange[], are merged.\n\t * Each input must be pre-sorted on startLineNumber.\n\t * The first list is assumed to always include all regions currently defined by range providers.\n\t * The second list only contains the previously collapsed and all manual ranges.\n\t * If the line position matches, the range of the new range is taken, and the range is no longer manual\n\t * When an entry in one list overlaps an entry in the other, the second list's entry \"wins\" and\n\t * overlapping entries in the first list are discarded.\n\t * Invalid entries are discarded. An entry is invalid if:\n\t * \t\tthe start and end line numbers aren't a valid range of line numbers,\n\t * \t\tit is out of sequence or has the same start line as a preceding entry,\n\t * \t\tit overlaps a preceding entry and is not fully contained by that entry.\n\t */\n\tpublic static sanitizeAndMerge(\n\t\trangesA: FoldingRegions | FoldRange[],\n\t\trangesB: FoldingRegions | FoldRange[],\n\t\tmaxLineNumber: number | undefined,\n\t\tselection?: SelectedLines\n\t): FoldRange[] {\n\n\t\tmaxLineNumber = maxLineNumber ?? Number.MAX_VALUE;\n\n\t\tconst getIndexedFunction = (r: FoldingRegions | FoldRange[], limit: number) => {\n\t\t\treturn Array.isArray(r)\n\t\t\t\t? ((i: number) => { return (i < limit) ? r[i] : undefined; })\n\t\t\t\t: ((i: number) => { return (i < limit) ? r.toFoldRange(i) : undefined; });\n\t\t};\n\t\tconst getA = getIndexedFunction(rangesA, rangesA.length);\n\t\tconst getB = getIndexedFunction(rangesB, rangesB.length);\n\t\tlet indexA = 0;\n\t\tlet indexB = 0;\n\t\tlet nextA = getA(0);\n\t\tlet nextB = getB(0);\n\n\t\tconst stackedRanges: FoldRange[] = [];\n\t\tlet topStackedRange: FoldRange | undefined;\n\t\tlet prevLineNumber = 0;\n\t\tconst resultRanges: FoldRange[] = [];\n\n\t\twhile (nextA || nextB) {\n\n\t\t\tlet useRange: FoldRange | undefined = undefined;\n\t\t\tif (nextB && (!nextA || nextA.startLineNumber >= nextB.startLineNumber)) {\n\t\t\t\tif (nextA && nextA.startLineNumber === nextB.startLineNumber) {\n\t\t\t\t\tif (nextB.source === FoldSource.userDefined) {\n\t\t\t\t\t\t// a user defined range (possibly unfolded)\n\t\t\t\t\t\tuseRange = nextB;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// a previously folded range or a (possibly unfolded) recovered range\n\t\t\t\t\t\tuseRange = nextA;\n\t\t\t\t\t\t// stays collapsed if the range still has the same number of lines or the selection is not in the range or after it\n\t\t\t\t\t\tuseRange.isCollapsed = nextB.isCollapsed && (nextA.endLineNumber === nextB.endLineNumber || !selection?.startsInside(nextA.startLineNumber + 1, nextA.endLineNumber + 1));\n\t\t\t\t\t\tuseRange.source = FoldSource.provider;\n\t\t\t\t\t}\n\t\t\t\t\tnextA = getA(++indexA); // not necessary, just for speed\n\t\t\t\t} else {\n\t\t\t\t\tuseRange = nextB;\n\t\t\t\t\tif (nextB.isCollapsed && nextB.source === FoldSource.provider) {\n\t\t\t\t\t\t// a previously collapsed range\n\t\t\t\t\t\tuseRange.source = FoldSource.recovered;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnextB = getB(++indexB);\n\t\t\t} else {\n\t\t\t\t// nextA is next. The user folded B set takes precedence and we sometimes need to look\n\t\t\t\t// ahead in it to check for an upcoming conflict.\n\t\t\t\tlet scanIndex = indexB;\n\t\t\t\tlet prescanB = nextB;\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (!prescanB || prescanB.startLineNumber > nextA!.endLineNumber) {\n\t\t\t\t\t\tuseRange = nextA;\n\t\t\t\t\t\tbreak; // no conflict, use this nextA\n\t\t\t\t\t}\n\t\t\t\t\tif (prescanB.source === FoldSource.userDefined && prescanB.endLineNumber > nextA!.endLineNumber) {\n\t\t\t\t\t\t// we found a user folded range, it wins\n\t\t\t\t\t\tbreak; // without setting nextResult, so this nextA gets skipped\n\t\t\t\t\t}\n\t\t\t\t\tprescanB = getB(++scanIndex);\n\t\t\t\t}\n\t\t\t\tnextA = getA(++indexA);\n\t\t\t}\n\n\t\t\tif (useRange) {\n\t\t\t\twhile (topStackedRange\n\t\t\t\t\t&& topStackedRange.endLineNumber < useRange.startLineNumber) {\n\t\t\t\t\ttopStackedRange = stackedRanges.pop();\n\t\t\t\t}\n\t\t\t\tif (useRange.endLineNumber > useRange.startLineNumber\n\t\t\t\t\t&& useRange.startLineNumber > prevLineNumber\n\t\t\t\t\t&& useRange.endLineNumber <= maxLineNumber\n\t\t\t\t\t&& (!topStackedRange\n\t\t\t\t\t\t|| topStackedRange.endLineNumber >= useRange.endLineNumber)) {\n\t\t\t\t\tresultRanges.push(useRange);\n\t\t\t\t\tprevLineNumber = useRange.startLineNumber;\n\t\t\t\t\tif (topStackedRange) {\n\t\t\t\t\t\tstackedRanges.push(topStackedRange);\n\t\t\t\t\t}\n\t\t\t\t\ttopStackedRange = useRange;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\treturn resultRanges;\n\t}\n\n}\n\nexport class FoldingRegion {\n\n\tconstructor(private readonly ranges: FoldingRegions, private index: number) {\n\t}\n\n\tpublic get startLineNumber() {\n\t\treturn this.ranges.getStartLineNumber(this.index);\n\t}\n\n\tpublic get endLineNumber() {\n\t\treturn this.ranges.getEndLineNumber(this.index);\n\t}\n\n\tpublic get regionIndex() {\n\t\treturn this.index;\n\t}\n\n\tpublic get parentIndex() {\n\t\treturn this.ranges.getParentIndex(this.index);\n\t}\n\n\tpublic get isCollapsed() {\n\t\treturn this.ranges.isCollapsed(this.index);\n\t}\n\n\tcontainedBy(range: ILineRange): boolean {\n\t\treturn range.startLineNumber <= this.startLineNumber && range.endLineNumber >= this.endLineNumber;\n\t}\n\tcontainsLine(lineNumber: number) {\n\t\treturn this.startLineNumber <= lineNumber && lineNumber <= this.endLineNumber;\n\t}\n\thidesLine(lineNumber: number) {\n\t\treturn this.startLineNumber < lineNumber && lineNumber <= this.endLineNumber;\n\t}\n}\n"],
  "mappings": "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",
  "names": ["FoldSource"]
}
