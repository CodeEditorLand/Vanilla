{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/contrib/folding/browser/foldingRanges.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { SelectedLines } from \"./folding.js\";\n\nexport interface ILineRange {\n\tstartLineNumber: number;\n\tendLineNumber: number;\n}\n\nexport enum FoldSource {\n\tprovider = 0,\n\tuserDefined = 1,\n\trecovered = 2,\n}\n\nexport const foldSourceAbbr = {\n\t[FoldSource.provider]: \" \",\n\t[FoldSource.userDefined]: \"u\",\n\t[FoldSource.recovered]: \"r\",\n};\n\nexport interface FoldRange {\n\tstartLineNumber: number;\n\tendLineNumber: number;\n\ttype: string | undefined;\n\tisCollapsed: boolean;\n\tsource: FoldSource;\n}\n\nexport const MAX_FOLDING_REGIONS = 0xffff;\nexport const MAX_LINE_NUMBER = 0xffffff;\n\nconst MASK_INDENT = 0xff000000;\n\nclass BitField {\n\tprivate readonly _states: Uint32Array;\n\tconstructor(size: number) {\n\t\tconst numWords = Math.ceil(size / 32);\n\t\tthis._states = new Uint32Array(numWords);\n\t}\n\n\tpublic get(index: number): boolean {\n\t\tconst arrayIndex = (index / 32) | 0;\n\t\tconst bit = index % 32;\n\t\treturn (this._states[arrayIndex] & (1 << bit)) !== 0;\n\t}\n\n\tpublic set(index: number, newState: boolean) {\n\t\tconst arrayIndex = (index / 32) | 0;\n\t\tconst bit = index % 32;\n\t\tconst value = this._states[arrayIndex];\n\t\tif (newState) {\n\t\t\tthis._states[arrayIndex] = value | (1 << bit);\n\t\t} else {\n\t\t\tthis._states[arrayIndex] = value & ~(1 << bit);\n\t\t}\n\t}\n}\n\nexport class FoldingRegions {\n\tprivate readonly _startIndexes: Uint32Array;\n\tprivate readonly _endIndexes: Uint32Array;\n\tprivate readonly _collapseStates: BitField;\n\tprivate readonly _userDefinedStates: BitField;\n\tprivate readonly _recoveredStates: BitField;\n\n\tprivate _parentsComputed: boolean;\n\tprivate readonly _types: Array<string | undefined> | undefined;\n\n\tconstructor(\n\t\tstartIndexes: Uint32Array,\n\t\tendIndexes: Uint32Array,\n\t\ttypes?: Array<string | undefined>,\n\t) {\n\t\tif (\n\t\t\tstartIndexes.length !== endIndexes.length ||\n\t\t\tstartIndexes.length > MAX_FOLDING_REGIONS\n\t\t) {\n\t\t\tthrow new Error(\"invalid startIndexes or endIndexes size\");\n\t\t}\n\t\tthis._startIndexes = startIndexes;\n\t\tthis._endIndexes = endIndexes;\n\t\tthis._collapseStates = new BitField(startIndexes.length);\n\t\tthis._userDefinedStates = new BitField(startIndexes.length);\n\t\tthis._recoveredStates = new BitField(startIndexes.length);\n\t\tthis._types = types;\n\t\tthis._parentsComputed = false;\n\t}\n\n\tprivate ensureParentIndices() {\n\t\tif (!this._parentsComputed) {\n\t\t\tthis._parentsComputed = true;\n\t\t\tconst parentIndexes: number[] = [];\n\t\t\tconst isInsideLast = (\n\t\t\t\tstartLineNumber: number,\n\t\t\t\tendLineNumber: number,\n\t\t\t) => {\n\t\t\t\tconst index = parentIndexes[parentIndexes.length - 1];\n\t\t\t\treturn (\n\t\t\t\t\tthis.getStartLineNumber(index) <= startLineNumber &&\n\t\t\t\t\tthis.getEndLineNumber(index) >= endLineNumber\n\t\t\t\t);\n\t\t\t};\n\t\t\tfor (let i = 0, len = this._startIndexes.length; i < len; i++) {\n\t\t\t\tconst startLineNumber = this._startIndexes[i];\n\t\t\t\tconst endLineNumber = this._endIndexes[i];\n\t\t\t\tif (\n\t\t\t\t\tstartLineNumber > MAX_LINE_NUMBER ||\n\t\t\t\t\tendLineNumber > MAX_LINE_NUMBER\n\t\t\t\t) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\"startLineNumber or endLineNumber must not exceed \" +\n\t\t\t\t\t\t\tMAX_LINE_NUMBER,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\twhile (\n\t\t\t\t\tparentIndexes.length > 0 &&\n\t\t\t\t\t!isInsideLast(startLineNumber, endLineNumber)\n\t\t\t\t) {\n\t\t\t\t\tparentIndexes.pop();\n\t\t\t\t}\n\t\t\t\tconst parentIndex =\n\t\t\t\t\tparentIndexes.length > 0\n\t\t\t\t\t\t? parentIndexes[parentIndexes.length - 1]\n\t\t\t\t\t\t: -1;\n\t\t\t\tparentIndexes.push(i);\n\t\t\t\tthis._startIndexes[i] =\n\t\t\t\t\tstartLineNumber + ((parentIndex & 0xff) << 24);\n\t\t\t\tthis._endIndexes[i] =\n\t\t\t\t\tendLineNumber + ((parentIndex & 0xff00) << 16);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic get length(): number {\n\t\treturn this._startIndexes.length;\n\t}\n\n\tpublic getStartLineNumber(index: number): number {\n\t\treturn this._startIndexes[index] & MAX_LINE_NUMBER;\n\t}\n\n\tpublic getEndLineNumber(index: number): number {\n\t\treturn this._endIndexes[index] & MAX_LINE_NUMBER;\n\t}\n\n\tpublic getType(index: number): string | undefined {\n\t\treturn this._types ? this._types[index] : undefined;\n\t}\n\n\tpublic hasTypes() {\n\t\treturn !!this._types;\n\t}\n\n\tpublic isCollapsed(index: number): boolean {\n\t\treturn this._collapseStates.get(index);\n\t}\n\n\tpublic setCollapsed(index: number, newState: boolean) {\n\t\tthis._collapseStates.set(index, newState);\n\t}\n\n\tprivate isUserDefined(index: number): boolean {\n\t\treturn this._userDefinedStates.get(index);\n\t}\n\n\tprivate setUserDefined(index: number, newState: boolean) {\n\t\treturn this._userDefinedStates.set(index, newState);\n\t}\n\n\tprivate isRecovered(index: number): boolean {\n\t\treturn this._recoveredStates.get(index);\n\t}\n\n\tprivate setRecovered(index: number, newState: boolean) {\n\t\treturn this._recoveredStates.set(index, newState);\n\t}\n\n\tpublic getSource(index: number): FoldSource {\n\t\tif (this.isUserDefined(index)) {\n\t\t\treturn FoldSource.userDefined;\n\t\t} else if (this.isRecovered(index)) {\n\t\t\treturn FoldSource.recovered;\n\t\t}\n\t\treturn FoldSource.provider;\n\t}\n\n\tpublic setSource(index: number, source: FoldSource): void {\n\t\tif (source === FoldSource.userDefined) {\n\t\t\tthis.setUserDefined(index, true);\n\t\t\tthis.setRecovered(index, false);\n\t\t} else if (source === FoldSource.recovered) {\n\t\t\tthis.setUserDefined(index, false);\n\t\t\tthis.setRecovered(index, true);\n\t\t} else {\n\t\t\tthis.setUserDefined(index, false);\n\t\t\tthis.setRecovered(index, false);\n\t\t}\n\t}\n\n\tpublic setCollapsedAllOfType(type: string, newState: boolean) {\n\t\tlet hasChanged = false;\n\t\tif (this._types) {\n\t\t\tfor (let i = 0; i < this._types.length; i++) {\n\t\t\t\tif (this._types[i] === type) {\n\t\t\t\t\tthis.setCollapsed(i, newState);\n\t\t\t\t\thasChanged = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn hasChanged;\n\t}\n\n\tpublic toRegion(index: number): FoldingRegion {\n\t\treturn new FoldingRegion(this, index);\n\t}\n\n\tpublic getParentIndex(index: number) {\n\t\tthis.ensureParentIndices();\n\t\tconst parent =\n\t\t\t((this._startIndexes[index] & MASK_INDENT) >>> 24) +\n\t\t\t((this._endIndexes[index] & MASK_INDENT) >>> 16);\n\t\tif (parent === MAX_FOLDING_REGIONS) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn parent;\n\t}\n\n\tpublic contains(index: number, line: number) {\n\t\treturn (\n\t\t\tthis.getStartLineNumber(index) <= line &&\n\t\t\tthis.getEndLineNumber(index) >= line\n\t\t);\n\t}\n\n\tprivate findIndex(line: number) {\n\t\tlet low = 0,\n\t\t\thigh = this._startIndexes.length;\n\t\tif (high === 0) {\n\t\t\treturn -1; // no children\n\t\t}\n\t\twhile (low < high) {\n\t\t\tconst mid = Math.floor((low + high) / 2);\n\t\t\tif (line < this.getStartLineNumber(mid)) {\n\t\t\t\thigh = mid;\n\t\t\t} else {\n\t\t\t\tlow = mid + 1;\n\t\t\t}\n\t\t}\n\t\treturn low - 1;\n\t}\n\n\tpublic findRange(line: number): number {\n\t\tlet index = this.findIndex(line);\n\t\tif (index >= 0) {\n\t\t\tconst endLineNumber = this.getEndLineNumber(index);\n\t\t\tif (endLineNumber >= line) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t\tindex = this.getParentIndex(index);\n\t\t\twhile (index !== -1) {\n\t\t\t\tif (this.contains(index, line)) {\n\t\t\t\t\treturn index;\n\t\t\t\t}\n\t\t\t\tindex = this.getParentIndex(index);\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tpublic toString() {\n\t\tconst res: string[] = [];\n\t\tfor (let i = 0; i < this.length; i++) {\n\t\t\tres[i] =\n\t\t\t\t`[${foldSourceAbbr[this.getSource(i)]}${this.isCollapsed(i) ? \"+\" : \"-\"}] ${this.getStartLineNumber(i)}/${this.getEndLineNumber(i)}`;\n\t\t}\n\t\treturn res.join(\", \");\n\t}\n\n\tpublic toFoldRange(index: number): FoldRange {\n\t\treturn {\n\t\t\tstartLineNumber: this._startIndexes[index] & MAX_LINE_NUMBER,\n\t\t\tendLineNumber: this._endIndexes[index] & MAX_LINE_NUMBER,\n\t\t\ttype: this._types ? this._types[index] : undefined,\n\t\t\tisCollapsed: this.isCollapsed(index),\n\t\t\tsource: this.getSource(index),\n\t\t};\n\t}\n\n\tpublic static fromFoldRanges(ranges: FoldRange[]): FoldingRegions {\n\t\tconst rangesLength = ranges.length;\n\t\tconst startIndexes = new Uint32Array(rangesLength);\n\t\tconst endIndexes = new Uint32Array(rangesLength);\n\t\tlet types: Array<string | undefined> | undefined = [];\n\t\tlet gotTypes = false;\n\t\tfor (let i = 0; i < rangesLength; i++) {\n\t\t\tconst range = ranges[i];\n\t\t\tstartIndexes[i] = range.startLineNumber;\n\t\t\tendIndexes[i] = range.endLineNumber;\n\t\t\ttypes.push(range.type);\n\t\t\tif (range.type) {\n\t\t\t\tgotTypes = true;\n\t\t\t}\n\t\t}\n\t\tif (!gotTypes) {\n\t\t\ttypes = undefined;\n\t\t}\n\t\tconst regions = new FoldingRegions(startIndexes, endIndexes, types);\n\t\tfor (let i = 0; i < rangesLength; i++) {\n\t\t\tif (ranges[i].isCollapsed) {\n\t\t\t\tregions.setCollapsed(i, true);\n\t\t\t}\n\t\t\tregions.setSource(i, ranges[i].source);\n\t\t}\n\t\treturn regions;\n\t}\n\n\t/**\n\t * Two inputs, each a FoldingRegions or a FoldRange[], are merged.\n\t * Each input must be pre-sorted on startLineNumber.\n\t * The first list is assumed to always include all regions currently defined by range providers.\n\t * The second list only contains the previously collapsed and all manual ranges.\n\t * If the line position matches, the range of the new range is taken, and the range is no longer manual\n\t * When an entry in one list overlaps an entry in the other, the second list's entry \"wins\" and\n\t * overlapping entries in the first list are discarded.\n\t * Invalid entries are discarded. An entry is invalid if:\n\t * \t\tthe start and end line numbers aren't a valid range of line numbers,\n\t * \t\tit is out of sequence or has the same start line as a preceding entry,\n\t * \t\tit overlaps a preceding entry and is not fully contained by that entry.\n\t */\n\tpublic static sanitizeAndMerge(\n\t\trangesA: FoldingRegions | FoldRange[],\n\t\trangesB: FoldingRegions | FoldRange[],\n\t\tmaxLineNumber: number | undefined,\n\t\tselection?: SelectedLines,\n\t): FoldRange[] {\n\t\tmaxLineNumber = maxLineNumber ?? Number.MAX_VALUE;\n\n\t\tconst getIndexedFunction = (\n\t\t\tr: FoldingRegions | FoldRange[],\n\t\t\tlimit: number,\n\t\t) => {\n\t\t\treturn Array.isArray(r)\n\t\t\t\t? (i: number) => {\n\t\t\t\t\t\treturn i < limit ? r[i] : undefined;\n\t\t\t\t\t}\n\t\t\t\t: (i: number) => {\n\t\t\t\t\t\treturn i < limit ? r.toFoldRange(i) : undefined;\n\t\t\t\t\t};\n\t\t};\n\t\tconst getA = getIndexedFunction(rangesA, rangesA.length);\n\t\tconst getB = getIndexedFunction(rangesB, rangesB.length);\n\t\tlet indexA = 0;\n\t\tlet indexB = 0;\n\t\tlet nextA = getA(0);\n\t\tlet nextB = getB(0);\n\n\t\tconst stackedRanges: FoldRange[] = [];\n\t\tlet topStackedRange: FoldRange | undefined;\n\t\tlet prevLineNumber = 0;\n\t\tconst resultRanges: FoldRange[] = [];\n\n\t\twhile (nextA || nextB) {\n\t\t\tlet useRange: FoldRange | undefined;\n\t\t\tif (\n\t\t\t\tnextB &&\n\t\t\t\t(!nextA || nextA.startLineNumber >= nextB.startLineNumber)\n\t\t\t) {\n\t\t\t\tif (nextA && nextA.startLineNumber === nextB.startLineNumber) {\n\t\t\t\t\tif (nextB.source === FoldSource.userDefined) {\n\t\t\t\t\t\t// a user defined range (possibly unfolded)\n\t\t\t\t\t\tuseRange = nextB;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// a previously folded range or a (possibly unfolded) recovered range\n\t\t\t\t\t\tuseRange = nextA;\n\t\t\t\t\t\t// stays collapsed if the range still has the same number of lines or the selection is not in the range or after it\n\t\t\t\t\t\tuseRange.isCollapsed =\n\t\t\t\t\t\t\tnextB.isCollapsed &&\n\t\t\t\t\t\t\t(nextA.endLineNumber === nextB.endLineNumber ||\n\t\t\t\t\t\t\t\t!selection?.startsInside(\n\t\t\t\t\t\t\t\t\tnextA.startLineNumber + 1,\n\t\t\t\t\t\t\t\t\tnextA.endLineNumber + 1,\n\t\t\t\t\t\t\t\t));\n\t\t\t\t\t\tuseRange.source = FoldSource.provider;\n\t\t\t\t\t}\n\t\t\t\t\tnextA = getA(++indexA); // not necessary, just for speed\n\t\t\t\t} else {\n\t\t\t\t\tuseRange = nextB;\n\t\t\t\t\tif (\n\t\t\t\t\t\tnextB.isCollapsed &&\n\t\t\t\t\t\tnextB.source === FoldSource.provider\n\t\t\t\t\t) {\n\t\t\t\t\t\t// a previously collapsed range\n\t\t\t\t\t\tuseRange.source = FoldSource.recovered;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnextB = getB(++indexB);\n\t\t\t} else {\n\t\t\t\t// nextA is next. The user folded B set takes precedence and we sometimes need to look\n\t\t\t\t// ahead in it to check for an upcoming conflict.\n\t\t\t\tlet scanIndex = indexB;\n\t\t\t\tlet prescanB = nextB;\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (\n\t\t\t\t\t\t!prescanB ||\n\t\t\t\t\t\tprescanB.startLineNumber > nextA!.endLineNumber\n\t\t\t\t\t) {\n\t\t\t\t\t\tuseRange = nextA;\n\t\t\t\t\t\tbreak; // no conflict, use this nextA\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\tprescanB.source === FoldSource.userDefined &&\n\t\t\t\t\t\tprescanB.endLineNumber > nextA!.endLineNumber\n\t\t\t\t\t) {\n\t\t\t\t\t\t// we found a user folded range, it wins\n\t\t\t\t\t\tbreak; // without setting nextResult, so this nextA gets skipped\n\t\t\t\t\t}\n\t\t\t\t\tprescanB = getB(++scanIndex);\n\t\t\t\t}\n\t\t\t\tnextA = getA(++indexA);\n\t\t\t}\n\n\t\t\tif (useRange) {\n\t\t\t\twhile (\n\t\t\t\t\ttopStackedRange &&\n\t\t\t\t\ttopStackedRange.endLineNumber < useRange.startLineNumber\n\t\t\t\t) {\n\t\t\t\t\ttopStackedRange = stackedRanges.pop();\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\tuseRange.endLineNumber > useRange.startLineNumber &&\n\t\t\t\t\tuseRange.startLineNumber > prevLineNumber &&\n\t\t\t\t\tuseRange.endLineNumber <= maxLineNumber &&\n\t\t\t\t\t(!topStackedRange ||\n\t\t\t\t\t\ttopStackedRange.endLineNumber >= useRange.endLineNumber)\n\t\t\t\t) {\n\t\t\t\t\tresultRanges.push(useRange);\n\t\t\t\t\tprevLineNumber = useRange.startLineNumber;\n\t\t\t\t\tif (topStackedRange) {\n\t\t\t\t\t\tstackedRanges.push(topStackedRange);\n\t\t\t\t\t}\n\t\t\t\t\ttopStackedRange = useRange;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn resultRanges;\n\t}\n}\n\nexport class FoldingRegion {\n\tconstructor(\n\t\tprivate readonly ranges: FoldingRegions,\n\t\tprivate index: number,\n\t) {}\n\n\tpublic get startLineNumber() {\n\t\treturn this.ranges.getStartLineNumber(this.index);\n\t}\n\n\tpublic get endLineNumber() {\n\t\treturn this.ranges.getEndLineNumber(this.index);\n\t}\n\n\tpublic get regionIndex() {\n\t\treturn this.index;\n\t}\n\n\tpublic get parentIndex() {\n\t\treturn this.ranges.getParentIndex(this.index);\n\t}\n\n\tpublic get isCollapsed() {\n\t\treturn this.ranges.isCollapsed(this.index);\n\t}\n\n\tcontainedBy(range: ILineRange): boolean {\n\t\treturn (\n\t\t\trange.startLineNumber <= this.startLineNumber &&\n\t\t\trange.endLineNumber >= this.endLineNumber\n\t\t);\n\t}\n\tcontainsLine(lineNumber: number) {\n\t\treturn (\n\t\t\tthis.startLineNumber <= lineNumber &&\n\t\t\tlineNumber <= this.endLineNumber\n\t\t);\n\t}\n\thidesLine(lineNumber: number) {\n\t\treturn (\n\t\t\tthis.startLineNumber < lineNumber &&\n\t\t\tlineNumber <= this.endLineNumber\n\t\t);\n\t}\n}\n"],
  "mappings": ";;AAYO,IAAK,aAAL,kBAAKA,gBAAL;AACN,EAAAA,wBAAA,cAAW,KAAX;AACA,EAAAA,wBAAA,iBAAc,KAAd;AACA,EAAAA,wBAAA,eAAY,KAAZ;AAHW,SAAAA;AAAA,GAAA;AAML,MAAM,iBAAiB;AAAA,EAC7B,CAAC,gBAAmB,GAAG;AAAA,EACvB,CAAC,mBAAsB,GAAG;AAAA,EAC1B,CAAC,iBAAoB,GAAG;AACzB;AAUO,MAAM,sBAAsB;AAC5B,MAAM,kBAAkB;AAE/B,MAAM,cAAc;AAEpB,MAAM,SAAS;AAAA,EArCf,OAqCe;AAAA;AAAA;AAAA,EACG;AAAA,EACjB,YAAY,MAAc;AACzB,UAAM,WAAW,KAAK,KAAK,OAAO,EAAE;AACpC,SAAK,UAAU,IAAI,YAAY,QAAQ;AAAA,EACxC;AAAA,EAEO,IAAI,OAAwB;AAClC,UAAM,aAAc,QAAQ,KAAM;AAClC,UAAM,MAAM,QAAQ;AACpB,YAAQ,KAAK,QAAQ,UAAU,IAAK,KAAK,SAAU;AAAA,EACpD;AAAA,EAEO,IAAI,OAAe,UAAmB;AAC5C,UAAM,aAAc,QAAQ,KAAM;AAClC,UAAM,MAAM,QAAQ;AACpB,UAAM,QAAQ,KAAK,QAAQ,UAAU;AACrC,QAAI,UAAU;AACb,WAAK,QAAQ,UAAU,IAAI,QAAS,KAAK;AAAA,IAC1C,OAAO;AACN,WAAK,QAAQ,UAAU,IAAI,QAAQ,EAAE,KAAK;AAAA,IAC3C;AAAA,EACD;AACD;AAEO,MAAM,eAAe;AAAA,EA9D5B,OA8D4B;AAAA;AAAA;AAAA,EACV;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAET;AAAA,EACS;AAAA,EAEjB,YACC,cACA,YACA,OACC;AACD,QACC,aAAa,WAAW,WAAW,UACnC,aAAa,SAAS,qBACrB;AACD,YAAM,IAAI,MAAM,yCAAyC;AAAA,IAC1D;AACA,SAAK,gBAAgB;AACrB,SAAK,cAAc;AACnB,SAAK,kBAAkB,IAAI,SAAS,aAAa,MAAM;AACvD,SAAK,qBAAqB,IAAI,SAAS,aAAa,MAAM;AAC1D,SAAK,mBAAmB,IAAI,SAAS,aAAa,MAAM;AACxD,SAAK,SAAS;AACd,SAAK,mBAAmB;AAAA,EACzB;AAAA,EAEQ,sBAAsB;AAC7B,QAAI,CAAC,KAAK,kBAAkB;AAC3B,WAAK,mBAAmB;AACxB,YAAM,gBAA0B,CAAC;AACjC,YAAM,eAAe,wBACpB,iBACA,kBACI;AACJ,cAAM,QAAQ,cAAc,cAAc,SAAS,CAAC;AACpD,eACC,KAAK,mBAAmB,KAAK,KAAK,mBAClC,KAAK,iBAAiB,KAAK,KAAK;AAAA,MAElC,GATqB;AAUrB,eAAS,IAAI,GAAG,MAAM,KAAK,cAAc,QAAQ,IAAI,KAAK,KAAK;AAC9D,cAAM,kBAAkB,KAAK,cAAc,CAAC;AAC5C,cAAM,gBAAgB,KAAK,YAAY,CAAC;AACxC,YACC,kBAAkB,mBAClB,gBAAgB,iBACf;AACD,gBAAM,IAAI;AAAA,YACT,sDACC;AAAA,UACF;AAAA,QACD;AACA,eACC,cAAc,SAAS,KACvB,CAAC,aAAa,iBAAiB,aAAa,GAC3C;AACD,wBAAc,IAAI;AAAA,QACnB;AACA,cAAM,cACL,cAAc,SAAS,IACpB,cAAc,cAAc,SAAS,CAAC,IACtC;AACJ,sBAAc,KAAK,CAAC;AACpB,aAAK,cAAc,CAAC,IACnB,oBAAoB,cAAc,QAAS;AAC5C,aAAK,YAAY,CAAC,IACjB,kBAAkB,cAAc,UAAW;AAAA,MAC7C;AAAA,IACD;AAAA,EACD;AAAA,EAEA,IAAW,SAAiB;AAC3B,WAAO,KAAK,cAAc;AAAA,EAC3B;AAAA,EAEO,mBAAmB,OAAuB;AAChD,WAAO,KAAK,cAAc,KAAK,IAAI;AAAA,EACpC;AAAA,EAEO,iBAAiB,OAAuB;AAC9C,WAAO,KAAK,YAAY,KAAK,IAAI;AAAA,EAClC;AAAA,EAEO,QAAQ,OAAmC;AACjD,WAAO,KAAK,SAAS,KAAK,OAAO,KAAK,IAAI;AAAA,EAC3C;AAAA,EAEO,WAAW;AACjB,WAAO,CAAC,CAAC,KAAK;AAAA,EACf;AAAA,EAEO,YAAY,OAAwB;AAC1C,WAAO,KAAK,gBAAgB,IAAI,KAAK;AAAA,EACtC;AAAA,EAEO,aAAa,OAAe,UAAmB;AACrD,SAAK,gBAAgB,IAAI,OAAO,QAAQ;AAAA,EACzC;AAAA,EAEQ,cAAc,OAAwB;AAC7C,WAAO,KAAK,mBAAmB,IAAI,KAAK;AAAA,EACzC;AAAA,EAEQ,eAAe,OAAe,UAAmB;AACxD,WAAO,KAAK,mBAAmB,IAAI,OAAO,QAAQ;AAAA,EACnD;AAAA,EAEQ,YAAY,OAAwB;AAC3C,WAAO,KAAK,iBAAiB,IAAI,KAAK;AAAA,EACvC;AAAA,EAEQ,aAAa,OAAe,UAAmB;AACtD,WAAO,KAAK,iBAAiB,IAAI,OAAO,QAAQ;AAAA,EACjD;AAAA,EAEO,UAAU,OAA2B;AAC3C,QAAI,KAAK,cAAc,KAAK,GAAG;AAC9B,aAAO;AAAA,IACR,WAAW,KAAK,YAAY,KAAK,GAAG;AACnC,aAAO;AAAA,IACR;AACA,WAAO;AAAA,EACR;AAAA,EAEO,UAAU,OAAe,QAA0B;AACzD,QAAI,WAAW,qBAAwB;AACtC,WAAK,eAAe,OAAO,IAAI;AAC/B,WAAK,aAAa,OAAO,KAAK;AAAA,IAC/B,WAAW,WAAW,mBAAsB;AAC3C,WAAK,eAAe,OAAO,KAAK;AAChC,WAAK,aAAa,OAAO,IAAI;AAAA,IAC9B,OAAO;AACN,WAAK,eAAe,OAAO,KAAK;AAChC,WAAK,aAAa,OAAO,KAAK;AAAA,IAC/B;AAAA,EACD;AAAA,EAEO,sBAAsB,MAAc,UAAmB;AAC7D,QAAI,aAAa;AACjB,QAAI,KAAK,QAAQ;AAChB,eAAS,IAAI,GAAG,IAAI,KAAK,OAAO,QAAQ,KAAK;AAC5C,YAAI,KAAK,OAAO,CAAC,MAAM,MAAM;AAC5B,eAAK,aAAa,GAAG,QAAQ;AAC7B,uBAAa;AAAA,QACd;AAAA,MACD;AAAA,IACD;AACA,WAAO;AAAA,EACR;AAAA,EAEO,SAAS,OAA8B;AAC7C,WAAO,IAAI,cAAc,MAAM,KAAK;AAAA,EACrC;AAAA,EAEO,eAAe,OAAe;AACpC,SAAK,oBAAoB;AACzB,UAAM,WACH,KAAK,cAAc,KAAK,IAAI,iBAAiB,QAC7C,KAAK,YAAY,KAAK,IAAI,iBAAiB;AAC9C,QAAI,WAAW,qBAAqB;AACnC,aAAO;AAAA,IACR;AACA,WAAO;AAAA,EACR;AAAA,EAEO,SAAS,OAAe,MAAc;AAC5C,WACC,KAAK,mBAAmB,KAAK,KAAK,QAClC,KAAK,iBAAiB,KAAK,KAAK;AAAA,EAElC;AAAA,EAEQ,UAAU,MAAc;AAC/B,QAAI,MAAM,GACT,OAAO,KAAK,cAAc;AAC3B,QAAI,SAAS,GAAG;AACf,aAAO;AAAA,IACR;AACA,WAAO,MAAM,MAAM;AAClB,YAAM,MAAM,KAAK,OAAO,MAAM,QAAQ,CAAC;AACvC,UAAI,OAAO,KAAK,mBAAmB,GAAG,GAAG;AACxC,eAAO;AAAA,MACR,OAAO;AACN,cAAM,MAAM;AAAA,MACb;AAAA,IACD;AACA,WAAO,MAAM;AAAA,EACd;AAAA,EAEO,UAAU,MAAsB;AACtC,QAAI,QAAQ,KAAK,UAAU,IAAI;AAC/B,QAAI,SAAS,GAAG;AACf,YAAM,gBAAgB,KAAK,iBAAiB,KAAK;AACjD,UAAI,iBAAiB,MAAM;AAC1B,eAAO;AAAA,MACR;AACA,cAAQ,KAAK,eAAe,KAAK;AACjC,aAAO,UAAU,IAAI;AACpB,YAAI,KAAK,SAAS,OAAO,IAAI,GAAG;AAC/B,iBAAO;AAAA,QACR;AACA,gBAAQ,KAAK,eAAe,KAAK;AAAA,MAClC;AAAA,IACD;AACA,WAAO;AAAA,EACR;AAAA,EAEO,WAAW;AACjB,UAAM,MAAgB,CAAC;AACvB,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACrC,UAAI,CAAC,IACJ,IAAI,eAAe,KAAK,UAAU,CAAC,CAAC,CAAC,GAAG,KAAK,YAAY,CAAC,IAAI,MAAM,GAAG,KAAK,KAAK,mBAAmB,CAAC,CAAC,IAAI,KAAK,iBAAiB,CAAC,CAAC;AAAA,IACpI;AACA,WAAO,IAAI,KAAK,IAAI;AAAA,EACrB;AAAA,EAEO,YAAY,OAA0B;AAC5C,WAAO;AAAA,MACN,iBAAiB,KAAK,cAAc,KAAK,IAAI;AAAA,MAC7C,eAAe,KAAK,YAAY,KAAK,IAAI;AAAA,MACzC,MAAM,KAAK,SAAS,KAAK,OAAO,KAAK,IAAI;AAAA,MACzC,aAAa,KAAK,YAAY,KAAK;AAAA,MACnC,QAAQ,KAAK,UAAU,KAAK;AAAA,IAC7B;AAAA,EACD;AAAA,EAEA,OAAc,eAAe,QAAqC;AACjE,UAAM,eAAe,OAAO;AAC5B,UAAM,eAAe,IAAI,YAAY,YAAY;AACjD,UAAM,aAAa,IAAI,YAAY,YAAY;AAC/C,QAAI,QAA+C,CAAC;AACpD,QAAI,WAAW;AACf,aAAS,IAAI,GAAG,IAAI,cAAc,KAAK;AACtC,YAAM,QAAQ,OAAO,CAAC;AACtB,mBAAa,CAAC,IAAI,MAAM;AACxB,iBAAW,CAAC,IAAI,MAAM;AACtB,YAAM,KAAK,MAAM,IAAI;AACrB,UAAI,MAAM,MAAM;AACf,mBAAW;AAAA,MACZ;AAAA,IACD;AACA,QAAI,CAAC,UAAU;AACd,cAAQ;AAAA,IACT;AACA,UAAM,UAAU,IAAI,eAAe,cAAc,YAAY,KAAK;AAClE,aAAS,IAAI,GAAG,IAAI,cAAc,KAAK;AACtC,UAAI,OAAO,CAAC,EAAE,aAAa;AAC1B,gBAAQ,aAAa,GAAG,IAAI;AAAA,MAC7B;AACA,cAAQ,UAAU,GAAG,OAAO,CAAC,EAAE,MAAM;AAAA,IACtC;AACA,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAeA,OAAc,iBACb,SACA,SACA,eACA,WACc;AACd,oBAAgB,iBAAiB,OAAO;AAExC,UAAM,qBAAqB,wBAC1B,GACA,UACI;AACJ,aAAO,MAAM,QAAQ,CAAC,IACnB,CAAC,MAAc;AACf,eAAO,IAAI,QAAQ,EAAE,CAAC,IAAI;AAAA,MAC3B,IACC,CAAC,MAAc;AACf,eAAO,IAAI,QAAQ,EAAE,YAAY,CAAC,IAAI;AAAA,MACvC;AAAA,IACH,GAX2B;AAY3B,UAAM,OAAO,mBAAmB,SAAS,QAAQ,MAAM;AACvD,UAAM,OAAO,mBAAmB,SAAS,QAAQ,MAAM;AACvD,QAAI,SAAS;AACb,QAAI,SAAS;AACb,QAAI,QAAQ,KAAK,CAAC;AAClB,QAAI,QAAQ,KAAK,CAAC;AAElB,UAAM,gBAA6B,CAAC;AACpC,QAAI;AACJ,QAAI,iBAAiB;AACrB,UAAM,eAA4B,CAAC;AAEnC,WAAO,SAAS,OAAO;AACtB,UAAI;AACJ,UACC,UACC,CAAC,SAAS,MAAM,mBAAmB,MAAM,kBACzC;AACD,YAAI,SAAS,MAAM,oBAAoB,MAAM,iBAAiB;AAC7D,cAAI,MAAM,WAAW,qBAAwB;AAE5C,uBAAW;AAAA,UACZ,OAAO;AAEN,uBAAW;AAEX,qBAAS,cACR,MAAM,gBACL,MAAM,kBAAkB,MAAM,iBAC9B,CAAC,WAAW;AAAA,cACX,MAAM,kBAAkB;AAAA,cACxB,MAAM,gBAAgB;AAAA,YACvB;AACF,qBAAS,SAAS;AAAA,UACnB;AACA,kBAAQ,KAAK,EAAE,MAAM;AAAA,QACtB,OAAO;AACN,qBAAW;AACX,cACC,MAAM,eACN,MAAM,WAAW,kBAChB;AAED,qBAAS,SAAS;AAAA,UACnB;AAAA,QACD;AACA,gBAAQ,KAAK,EAAE,MAAM;AAAA,MACtB,OAAO;AAGN,YAAI,YAAY;AAChB,YAAI,WAAW;AACf,eAAO,MAAM;AACZ,cACC,CAAC,YACD,SAAS,kBAAkB,MAAO,eACjC;AACD,uBAAW;AACX;AAAA,UACD;AACA,cACC,SAAS,WAAW,uBACpB,SAAS,gBAAgB,MAAO,eAC/B;AAED;AAAA,UACD;AACA,qBAAW,KAAK,EAAE,SAAS;AAAA,QAC5B;AACA,gBAAQ,KAAK,EAAE,MAAM;AAAA,MACtB;AAEA,UAAI,UAAU;AACb,eACC,mBACA,gBAAgB,gBAAgB,SAAS,iBACxC;AACD,4BAAkB,cAAc,IAAI;AAAA,QACrC;AACA,YACC,SAAS,gBAAgB,SAAS,mBAClC,SAAS,kBAAkB,kBAC3B,SAAS,iBAAiB,kBACzB,CAAC,mBACD,gBAAgB,iBAAiB,SAAS,gBAC1C;AACD,uBAAa,KAAK,QAAQ;AAC1B,2BAAiB,SAAS;AAC1B,cAAI,iBAAiB;AACpB,0BAAc,KAAK,eAAe;AAAA,UACnC;AACA,4BAAkB;AAAA,QACnB;AAAA,MACD;AAAA,IACD;AACA,WAAO;AAAA,EACR;AACD;AAEO,MAAM,cAAc;AAAA,EAC1B,YACkB,QACT,OACP;AAFgB;AACT;AAAA,EACN;AAAA,EAxcJ,OAoc2B;AAAA;AAAA;AAAA,EAM1B,IAAW,kBAAkB;AAC5B,WAAO,KAAK,OAAO,mBAAmB,KAAK,KAAK;AAAA,EACjD;AAAA,EAEA,IAAW,gBAAgB;AAC1B,WAAO,KAAK,OAAO,iBAAiB,KAAK,KAAK;AAAA,EAC/C;AAAA,EAEA,IAAW,cAAc;AACxB,WAAO,KAAK;AAAA,EACb;AAAA,EAEA,IAAW,cAAc;AACxB,WAAO,KAAK,OAAO,eAAe,KAAK,KAAK;AAAA,EAC7C;AAAA,EAEA,IAAW,cAAc;AACxB,WAAO,KAAK,OAAO,YAAY,KAAK,KAAK;AAAA,EAC1C;AAAA,EAEA,YAAY,OAA4B;AACvC,WACC,MAAM,mBAAmB,KAAK,mBAC9B,MAAM,iBAAiB,KAAK;AAAA,EAE9B;AAAA,EACA,aAAa,YAAoB;AAChC,WACC,KAAK,mBAAmB,cACxB,cAAc,KAAK;AAAA,EAErB;AAAA,EACA,UAAU,YAAoB;AAC7B,WACC,KAAK,kBAAkB,cACvB,cAAc,KAAK;AAAA,EAErB;AACD;",
  "names": ["FoldSource"]
}
