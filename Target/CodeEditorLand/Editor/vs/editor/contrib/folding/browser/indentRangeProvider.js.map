{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/contrib/folding/browser/indentRangeProvider.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { CancellationToken } from \"../../../../base/common/cancellation.js\";\nimport type { FoldingMarkers } from \"../../../common/languages/languageConfiguration.js\";\nimport type { ILanguageConfigurationService } from \"../../../common/languages/languageConfigurationRegistry.js\";\nimport type { ITextModel } from \"../../../common/model.js\";\nimport { computeIndentLevel } from \"../../../common/model/utils.js\";\nimport type { FoldingLimitReporter, RangeProvider } from \"./folding.js\";\nimport { FoldingRegions, MAX_LINE_NUMBER } from \"./foldingRanges.js\";\n\nconst MAX_FOLDING_REGIONS_FOR_INDENT_DEFAULT = 5000;\n\nconst ID_INDENT_PROVIDER = \"indent\";\n\nexport class IndentRangeProvider implements RangeProvider {\n\treadonly id = ID_INDENT_PROVIDER;\n\n\tconstructor(\n\t\tprivate readonly editorModel: ITextModel,\n\t\tprivate readonly languageConfigurationService: ILanguageConfigurationService,\n\t\tprivate readonly foldingRangesLimit: FoldingLimitReporter,\n\t) {}\n\n\tdispose() {}\n\n\tcompute(cancelationToken: CancellationToken): Promise<FoldingRegions> {\n\t\tconst foldingRules =\n\t\t\tthis.languageConfigurationService.getLanguageConfiguration(\n\t\t\t\tthis.editorModel.getLanguageId(),\n\t\t\t).foldingRules;\n\t\tconst offSide = foldingRules && !!foldingRules.offSide;\n\t\tconst markers = foldingRules && foldingRules.markers;\n\t\treturn Promise.resolve(\n\t\t\tcomputeRanges(\n\t\t\t\tthis.editorModel,\n\t\t\t\toffSide,\n\t\t\t\tmarkers,\n\t\t\t\tthis.foldingRangesLimit,\n\t\t\t),\n\t\t);\n\t}\n}\n\n// public only for testing\nexport class RangesCollector {\n\tprivate readonly _startIndexes: number[];\n\tprivate readonly _endIndexes: number[];\n\tprivate readonly _indentOccurrences: number[];\n\tprivate _length: number;\n\tprivate readonly _foldingRangesLimit: FoldingLimitReporter;\n\n\tconstructor(foldingRangesLimit: FoldingLimitReporter) {\n\t\tthis._startIndexes = [];\n\t\tthis._endIndexes = [];\n\t\tthis._indentOccurrences = [];\n\t\tthis._length = 0;\n\t\tthis._foldingRangesLimit = foldingRangesLimit;\n\t}\n\n\tpublic insertFirst(\n\t\tstartLineNumber: number,\n\t\tendLineNumber: number,\n\t\tindent: number,\n\t) {\n\t\tif (\n\t\t\tstartLineNumber > MAX_LINE_NUMBER ||\n\t\t\tendLineNumber > MAX_LINE_NUMBER\n\t\t) {\n\t\t\treturn;\n\t\t}\n\t\tconst index = this._length;\n\t\tthis._startIndexes[index] = startLineNumber;\n\t\tthis._endIndexes[index] = endLineNumber;\n\t\tthis._length++;\n\t\tif (indent < 1000) {\n\t\t\tthis._indentOccurrences[indent] =\n\t\t\t\t(this._indentOccurrences[indent] || 0) + 1;\n\t\t}\n\t}\n\n\tpublic toIndentRanges(model: ITextModel) {\n\t\tconst limit = this._foldingRangesLimit.limit;\n\t\tif (this._length <= limit) {\n\t\t\tthis._foldingRangesLimit.update(this._length, false);\n\n\t\t\t// reverse and create arrays of the exact length\n\t\t\tconst startIndexes = new Uint32Array(this._length);\n\t\t\tconst endIndexes = new Uint32Array(this._length);\n\t\t\tfor (let i = this._length - 1, k = 0; i >= 0; i--, k++) {\n\t\t\t\tstartIndexes[k] = this._startIndexes[i];\n\t\t\t\tendIndexes[k] = this._endIndexes[i];\n\t\t\t}\n\t\t\treturn new FoldingRegions(startIndexes, endIndexes);\n\t\t} else {\n\t\t\tthis._foldingRangesLimit.update(this._length, limit);\n\n\t\t\tlet entries = 0;\n\t\t\tlet maxIndent = this._indentOccurrences.length;\n\t\t\tfor (let i = 0; i < this._indentOccurrences.length; i++) {\n\t\t\t\tconst n = this._indentOccurrences[i];\n\t\t\t\tif (n) {\n\t\t\t\t\tif (n + entries > limit) {\n\t\t\t\t\t\tmaxIndent = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tentries += n;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst tabSize = model.getOptions().tabSize;\n\t\t\t// reverse and create arrays of the exact length\n\t\t\tconst startIndexes = new Uint32Array(limit);\n\t\t\tconst endIndexes = new Uint32Array(limit);\n\t\t\tfor (let i = this._length - 1, k = 0; i >= 0; i--) {\n\t\t\t\tconst startIndex = this._startIndexes[i];\n\t\t\t\tconst lineContent = model.getLineContent(startIndex);\n\t\t\t\tconst indent = computeIndentLevel(lineContent, tabSize);\n\t\t\t\tif (\n\t\t\t\t\tindent < maxIndent ||\n\t\t\t\t\t(indent === maxIndent && entries++ < limit)\n\t\t\t\t) {\n\t\t\t\t\tstartIndexes[k] = startIndex;\n\t\t\t\t\tendIndexes[k] = this._endIndexes[i];\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new FoldingRegions(startIndexes, endIndexes);\n\t\t}\n\t}\n}\n\ninterface PreviousRegion {\n\tindent: number; // indent or -2 if a marker\n\tendAbove: number; // end line number for the region above\n\tline: number; // start line of the region. Only used for marker regions.\n}\n\nconst foldingRangesLimitDefault: FoldingLimitReporter = {\n\tlimit: MAX_FOLDING_REGIONS_FOR_INDENT_DEFAULT,\n\tupdate: () => {},\n};\n\nexport function computeRanges(\n\tmodel: ITextModel,\n\toffSide: boolean,\n\tmarkers?: FoldingMarkers,\n\tfoldingRangesLimit: FoldingLimitReporter = foldingRangesLimitDefault,\n): FoldingRegions {\n\tconst tabSize = model.getOptions().tabSize;\n\tconst result = new RangesCollector(foldingRangesLimit);\n\n\tlet pattern: RegExp | undefined;\n\tif (markers) {\n\t\tpattern = new RegExp(\n\t\t\t`(${markers.start.source})|(?:${markers.end.source})`,\n\t\t);\n\t}\n\n\tconst previousRegions: PreviousRegion[] = [];\n\tconst line = model.getLineCount() + 1;\n\tpreviousRegions.push({ indent: -1, endAbove: line, line }); // sentinel, to make sure there's at least one entry\n\n\tfor (let line = model.getLineCount(); line > 0; line--) {\n\t\tconst lineContent = model.getLineContent(line);\n\t\tconst indent = computeIndentLevel(lineContent, tabSize);\n\t\tlet previous = previousRegions[previousRegions.length - 1];\n\t\tif (indent === -1) {\n\t\t\tif (offSide) {\n\t\t\t\t// for offSide languages, empty lines are associated to the previous block\n\t\t\t\t// note: the next block is already written to the results, so this only\n\t\t\t\t// impacts the end position of the block before\n\t\t\t\tprevious.endAbove = line;\n\t\t\t}\n\t\t\tcontinue; // only whitespace\n\t\t}\n\t\tlet m;\n\t\tif (pattern && (m = lineContent.match(pattern))) {\n\t\t\t// folding pattern match\n\t\t\tif (m[1]) {\n\t\t\t\t// start pattern match\n\t\t\t\t// discard all regions until the folding pattern\n\t\t\t\tlet i = previousRegions.length - 1;\n\t\t\t\twhile (i > 0 && previousRegions[i].indent !== -2) {\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tpreviousRegions.length = i + 1;\n\t\t\t\t\tprevious = previousRegions[i];\n\n\t\t\t\t\t// new folding range from pattern, includes the end line\n\t\t\t\t\tresult.insertFirst(line, previous.line, indent);\n\t\t\t\t\tprevious.line = line;\n\t\t\t\t\tprevious.indent = indent;\n\t\t\t\t\tprevious.endAbove = line;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\t// no end marker found, treat line as a regular line\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// end pattern match\n\t\t\t\tpreviousRegions.push({ indent: -2, endAbove: line, line });\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (previous.indent > indent) {\n\t\t\t// discard all regions with larger indent\n\t\t\tdo {\n\t\t\t\tpreviousRegions.pop();\n\t\t\t\tprevious = previousRegions[previousRegions.length - 1];\n\t\t\t} while (previous.indent > indent);\n\n\t\t\t// new folding range\n\t\t\tconst endLineNumber = previous.endAbove - 1;\n\t\t\tif (endLineNumber - line >= 1) {\n\t\t\t\t// needs at east size 1\n\t\t\t\tresult.insertFirst(line, endLineNumber, indent);\n\t\t\t}\n\t\t}\n\t\tif (previous.indent === indent) {\n\t\t\tprevious.endAbove = line;\n\t\t} else {\n\t\t\t// previous.indent < indent\n\t\t\t// new region with a bigger indent\n\t\t\tpreviousRegions.push({ indent, endAbove: line, line });\n\t\t}\n\t}\n\treturn result.toIndentRanges(model);\n}\n"],
  "mappings": "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",
  "names": ["line"]
}
