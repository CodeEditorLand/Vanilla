import{assertNever as E}from"../../../../../base/common/assert.js";import{DeferredPromise as N}from"../../../../../base/common/async.js";import{CancellationToken as k}from"../../../../../base/common/cancellation.js";import{onUnexpectedExternalError as w}from"../../../../../base/common/errors.js";import{SetMap as M}from"../../../../../base/common/map.js";import{OffsetRange as j}from"../../../../common/core/offsetRange.js";import{Position as L}from"../../../../common/core/position.js";import{Range as h}from"../../../../common/core/range.js";import{SingleTextEdit as A}from"../../../../common/core/textEdit.js";import{fixBracketsInLine as B}from"../../../../common/model/bracketPairsTextModelPart/fixBrackets.js";import{LineEditWithAdditionalLines as D}from"../../../../common/tokenizationTextModelPart.js";import{SnippetParser as G,Text as F}from"../../../snippet/browser/snippetParser.js";import{getReadonlyEmptyArray as W}from"../utils.js";async function te(r,e,i,a,u=k.None,m){const l=e instanceof L?J(e,i):e,c=r.all(i),t=new M;for(const n of c)n.groupId&&t.add(n.groupId,n);function f(n){if(!n.yieldsToGroupIds)return[];const s=[];for(const p of n.yieldsToGroupIds||[]){const d=t.get(p);for(const o of d)s.push(o)}return s}const g=new Map,I=new Set;function P(n,s){if(s=[...s,n],I.has(n))return s;I.add(n);try{const p=f(n);for(const d of p){const o=P(d,s);if(o)return o}}finally{I.delete(n)}}function x(n){const s=g.get(n);if(s)return s;const p=P(n,[]);p&&w(new Error(`Inline completions: cyclic yield-to dependency detected. Path: ${p.map(o=>o.toString?o.toString():""+o).join(" -> ")}`));const d=new N;return g.set(n,d.p),(async()=>{if(!p){const o=f(n);for(const b of o){const v=await x(b);if(v&&v.items.length>0)return}}try{return e instanceof L?await n.provideInlineCompletions(i,e,a,u):await n.provideInlineEdits?.(i,e,a,u)}catch(o){w(o);return}})().then(o=>d.complete(o),o=>d.error(o)),d.p}const R=await Promise.all(c.map(async n=>({provider:n,completions:await x(n)}))),C=new Map,T=[];for(const n of R){const s=n.completions;if(!s)continue;const p=new H(s,n.provider);T.push(p);for(const d of s.items){const o=y.from(d,p,l,i,m);C.set(o.hash(),o)}}return new z(Array.from(C.values()),new Set(C.keys()),T)}class z{constructor(e,i,a){this.completions=e;this.hashs=i;this.providerResults=a}has(e){return this.hashs.has(e.hash())}dispose(){for(const e of this.providerResults)e.removeRef()}}class H{constructor(e,i){this.inlineCompletions=e;this.provider=i}refCount=1;addRef(){this.refCount++}removeRef(){this.refCount--,this.refCount===0&&this.provider.freeInlineCompletions(this.inlineCompletions)}}class y{constructor(e,i,a,u,m,l,c,t){this.filterText=e;this.command=i;this.range=a;this.insertText=u;this.snippetInfo=m;this.additionalTextEdits=l;this.sourceInlineCompletion=c;this.source=t;e=e.replace(/\r\n|\r/g,`
`),u=e.replace(/\r\n|\r/g,`
`)}static from(e,i,a,u,m){let l,c,t=e.range?h.lift(e.range):a;if(typeof e.insertText=="string"){if(l=e.insertText,m&&e.completeBracketPairs){l=S(l,t.getStartPosition(),u,m);const f=l.length-e.insertText.length;f!==0&&(t=new h(t.startLineNumber,t.startColumn,t.endLineNumber,t.endColumn+f))}c=void 0}else if("snippet"in e.insertText){const f=e.insertText.snippet.length;if(m&&e.completeBracketPairs){e.insertText.snippet=S(e.insertText.snippet,t.getStartPosition(),u,m);const I=e.insertText.snippet.length-f;I!==0&&(t=new h(t.startLineNumber,t.startColumn,t.endLineNumber,t.endColumn+I))}const g=new G().parse(e.insertText.snippet);g.children.length===1&&g.children[0]instanceof F?(l=g.children[0].value,c=void 0):(l=g.toString(),c={snippet:e.insertText.snippet,range:t})}else E(e.insertText);return new y(l,e.command,t,l,c,e.additionalTextEdits||W(),e,i)}withRange(e){return new y(this.filterText,this.command,e,this.insertText,this.snippetInfo,this.additionalTextEdits,this.sourceInlineCompletion,this.source)}hash(){return JSON.stringify({insertText:this.insertText,range:this.range.toString()})}toSingleTextEdit(){return new A(this.range,this.insertText)}}function J(r,e){const i=e.getWordAtPosition(r),a=e.getLineMaxColumn(r.lineNumber);return i?new h(r.lineNumber,i.startColumn,r.lineNumber,a):h.fromPositions(r,r.with(void 0,a))}function S(r,e,i,a){const m=i.getLineContent(e.lineNumber).substring(0,e.column-1)+r,l=D.replace(j.ofStartAndLength(e.column-1,m.length-(e.column-1)),r),t=i.tokenization.tokenizeLineWithEdit(e.lineNumber,l)?.mainLineTokens?.sliceAndInflate(e.column-1,m.length,0);return t?B(t,a):r}export{y as InlineCompletionItem,H as InlineCompletionList,z as InlineCompletionProviderResult,te as provideInlineCompletions};
