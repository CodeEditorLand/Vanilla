import{BugIndicatingError as a}from"../../../../base/common/errors.js";import{DisposableStore as u}from"../../../../base/common/lifecycle.js";import{autorunOpts as m}from"../../../../base/common/observable.js";import{Position as t}from"../../../common/core/position.js";import{Range as s}from"../../../common/core/range.js";const c=[];function C(){return c}class g{constructor(o,n){this.startColumn=o;this.endColumnExclusive=n;if(o>n)throw new a(`startColumn ${o} cannot be after endColumnExclusive ${n}`)}toRange(o){return new s(o,this.startColumn,o,this.endColumnExclusive)}equals(o){return this.startColumn===o.startColumn&&this.endColumnExclusive===o.endColumnExclusive}}function D(e,o){const n=new u,r=e.createDecorationsCollection();return n.add(m({debugName:()=>`Apply decorations from ${o.debugName}`},i=>{const l=o.read(i);r.set(l)})),n.add({dispose:()=>{r.clear()}}),n}function I(e,o){return new t(e.lineNumber+o.lineNumber-1,o.lineNumber===1?e.column+o.column-1:o.column)}function P(e,o){return new t(e.lineNumber-o.lineNumber+1,e.lineNumber-o.lineNumber===0?e.column-o.column+1:e.column)}export{g as ColumnRange,I as addPositions,D as applyObservableDecorations,C as getReadonlyEmptyArray,P as subtractPositions};
