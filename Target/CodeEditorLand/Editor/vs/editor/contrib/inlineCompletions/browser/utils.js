import{Permutation as c,compareBy as g}from"../../../../base/common/arrays.js";import{BugIndicatingError as d}from"../../../../base/common/errors.js";import"../../../../base/common/lifecycle.js";import{observableValue as a,autorun as f,transaction as p}from"../../../../base/common/observable.js";import{splitLinesIncludeSeparators as P}from"../../../../base/common/strings.js";import{Position as u}from"../../../common/core/position.js";import{Range as m}from"../../../common/core/range.js";import{TextEdit as y}from"../../../common/core/textEdit.js";const v=[];function B(){return v}class D{constructor(e,r){this.startColumn=e;this.endColumnExclusive=r;if(e>r)throw new d(`startColumn ${e} cannot be after endColumnExclusive ${r}`)}toRange(e){return new m(e,this.startColumn,e,this.endColumnExclusive)}equals(e){return this.startColumn===e.startColumn&&this.endColumnExclusive===e.endColumnExclusive}}function V(n,e){return new u(n.lineNumber+e.lineNumber-1,e.lineNumber===1?n.column+e.column-1:e.column)}function $(n,e){return new u(n.lineNumber-e.lineNumber+1,n.lineNumber-e.lineNumber===0?n.column-e.column+1:n.column)}function q(n,e){let r="";const t=P(n);for(let i=e.lineNumber-1;i<t.length;i++)r+=t[i].substring(i===e.lineNumber-1?e.column-1:0);return r}function L(n){const e=c.createSortPermutation(n,g(o=>o.range,m.compareRangesUsingStarts)),t=new y(e.apply(n)).getNewRanges();return e.inverse().apply(t).map(o=>o.getEndPosition())}function U(n,e){const r=a("result",[]),t=[];return e.add(f(i=>{const o=n.read(i);p(s=>{if(o.length!==t.length){t.length=o.length;for(let l=0;l<t.length;l++)t[l]||(t[l]=a("item",o[l]));r.set([...t],s)}t.forEach((l,b)=>l.set(o[b],s))})})),r}export{D as ColumnRange,V as addPositions,U as convertItemsToStableObservables,L as getEndPositionsAfterApplying,B as getReadonlyEmptyArray,q as substringPos,$ as subtractPositions};
