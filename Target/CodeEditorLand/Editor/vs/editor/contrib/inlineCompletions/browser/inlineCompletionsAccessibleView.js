import{Emitter as s}from"../../../../../vs/base/common/event.js";import{Disposable as l}from"../../../../../vs/base/common/lifecycle.js";import"../../../../../vs/editor/browser/editorBrowser.js";import{ICodeEditorService as d}from"../../../../../vs/editor/browser/services/codeEditorService.js";import{InlineCompletionContextKeys as m}from"../../../../../vs/editor/contrib/inlineCompletions/browser/controller/inlineCompletionContextKeys.js";import{InlineCompletionsController as p}from"../../../../../vs/editor/contrib/inlineCompletions/browser/controller/inlineCompletionsController.js";import"../../../../../vs/editor/contrib/inlineCompletions/browser/model/inlineCompletionsModel.js";import{AccessibleViewProviderId as c,AccessibleViewType as n}from"../../../../../vs/platform/accessibility/browser/accessibleView.js";import"../../../../../vs/platform/accessibility/browser/accessibleViewRegistry.js";import{ContextKeyExpr as a}from"../../../../../vs/platform/contextkey/common/contextkey.js";import"../../../../../vs/platform/instantiation/common/instantiation.js";class T{type=n.View;priority=95;name="inline-completions";when=a.and(m.inlineSuggestionVisible);getProvider(o){const e=o.get(d),t=e.getActiveCodeEditor()||e.getFocusedCodeEditor();if(!t)return;const i=p.get(t)?.model.get();if(i?.state.get())return new C(t,i)}}class C extends l{constructor(e,t){super();this._editor=e;this._model=t}_onDidChangeContent=this._register(new s);onDidChangeContent=this._onDidChangeContent.event;id=c.InlineCompletions;verbositySettingKey="accessibility.verbosity.inlineCompletions";options={language:this._editor.getModel()?.getLanguageId()??void 0,type:n.View};provideContent(){const e=this._model.state.get();if(!e)throw new Error("Inline completion is visible but state is not available");const t=this._model.textModel.getLineContent(e.primaryGhostText.lineNumber),i=e.primaryGhostText.renderForScreenReader(t);if(!i)throw new Error("Inline completion is visible but ghost text is not available");return t+i}provideNextContent(){this._model.next().then(()=>this._onDidChangeContent.fire())}providePreviousContent(){this._model.previous().then(()=>this._onDidChangeContent.fire())}onClose(){this._model.stop(),this._editor.focus()}}export{T as InlineCompletionsAccessibleView};
