import{Emitter as s}from"../../../../base/common/event.js";import{ICodeEditorService as l}from"../../../browser/services/codeEditorService.js";import{InlineCompletionContextKeys as d}from"./controller/inlineCompletionContextKeys.js";import{InlineCompletionsController as m}from"./controller/inlineCompletionsController.js";import{AccessibleViewType as n,AccessibleViewProviderId as p}from"../../../../platform/accessibility/browser/accessibleView.js";import{ContextKeyExpr as c}from"../../../../platform/contextkey/common/contextkey.js";import{Disposable as a}from"../../../../base/common/lifecycle.js";class T{type=n.View;priority=95;name="inline-completions";when=c.and(d.inlineSuggestionVisible);getProvider(o){const e=o.get(l),t=e.getActiveCodeEditor()||e.getFocusedCodeEditor();if(!t)return;const i=m.get(t)?.model.get();if(i?.state.get())return new C(t,i)}}class C extends a{constructor(e,t){super();this._editor=e;this._model=t}_onDidChangeContent=this._register(new s);onDidChangeContent=this._onDidChangeContent.event;id=p.InlineCompletions;verbositySettingKey="accessibility.verbosity.inlineCompletions";options={language:this._editor.getModel()?.getLanguageId()??void 0,type:n.View};provideContent(){const e=this._model.state.get();if(!e)throw new Error("Inline completion is visible but state is not available");const t=this._model.textModel.getLineContent(e.primaryGhostText.lineNumber),i=e.primaryGhostText.renderForScreenReader(t);if(!i)throw new Error("Inline completion is visible but ghost text is not available");return t+i}provideNextContent(){this._model.next().then(()=>this._onDidChangeContent.fire())}providePreviousContent(){this._model.previous().then(()=>this._onDidChangeContent.fire())}onClose(){this._model.stop(),this._editor.focus()}}export{T as InlineCompletionsAccessibleView};
