{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/contrib/inlineCompletions/browser/model/singleTextEdit.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport {\n\ttype IDiffChange,\n\tLcsDiff,\n} from \"../../../../../base/common/diff/diff.js\";\nimport {\n\tcommonPrefixLength,\n\tgetLeadingWhitespace,\n} from \"../../../../../base/common/strings.js\";\nimport type { Position } from \"../../../../common/core/position.js\";\nimport { Range } from \"../../../../common/core/range.js\";\nimport { SingleTextEdit } from \"../../../../common/core/textEdit.js\";\nimport { TextLength } from \"../../../../common/core/textLength.js\";\nimport {\n\tEndOfLinePreference,\n\ttype ITextModel,\n} from \"../../../../common/model.js\";\nimport { GhostText, GhostTextPart } from \"./ghostText.js\";\n\nexport function singleTextRemoveCommonPrefix(\n\tedit: SingleTextEdit,\n\tmodel: ITextModel,\n\tvalidModelRange?: Range,\n): SingleTextEdit {\n\tconst modelRange = validModelRange\n\t\t? edit.range.intersectRanges(validModelRange)\n\t\t: edit.range;\n\tif (!modelRange) {\n\t\treturn edit;\n\t}\n\tconst valueToReplace = model.getValueInRange(\n\t\tmodelRange,\n\t\tEndOfLinePreference.LF,\n\t);\n\tconst commonPrefixLen = commonPrefixLength(valueToReplace, edit.text);\n\tconst start = TextLength.ofText(\n\t\tvalueToReplace.substring(0, commonPrefixLen),\n\t).addToPosition(edit.range.getStartPosition());\n\tconst text = edit.text.substring(commonPrefixLen);\n\tconst range = Range.fromPositions(start, edit.range.getEndPosition());\n\treturn new SingleTextEdit(range, text);\n}\n\nexport function singleTextEditAugments(\n\tedit: SingleTextEdit,\n\tbase: SingleTextEdit,\n): boolean {\n\t// The augmented completion must replace the base range, but can replace even more\n\treturn (\n\t\tedit.text.startsWith(base.text) && rangeExtends(edit.range, base.range)\n\t);\n}\n\n/**\n * @param previewSuffixLength Sets where to split `inlineCompletion.text`.\n * \tIf the text is `hello` and the suffix length is 2, the non-preview part is `hel` and the preview-part is `lo`.\n */\nexport function computeGhostText(\n\tedit: SingleTextEdit,\n\tmodel: ITextModel,\n\tmode: \"prefix\" | \"subword\" | \"subwordSmart\",\n\tcursorPosition?: Position,\n\tpreviewSuffixLength = 0,\n): GhostText | undefined {\n\tlet e = singleTextRemoveCommonPrefix(edit, model);\n\n\tif (e.range.endLineNumber !== e.range.startLineNumber) {\n\t\t// This edit might span multiple lines, but the first lines must be a common prefix.\n\t\treturn undefined;\n\t}\n\n\tconst sourceLine = model.getLineContent(e.range.startLineNumber);\n\tconst sourceIndentationLength = getLeadingWhitespace(sourceLine).length;\n\n\tconst suggestionTouchesIndentation =\n\t\te.range.startColumn - 1 <= sourceIndentationLength;\n\tif (suggestionTouchesIndentation) {\n\t\t// source:      \u00B7\u00B7\u00B7\u00B7\u00B7\u00B7\u00B7\u00B7\u00B7\u00B7[\u00B7\u00B7\u00B7\u00B7\u00B7\u00B7abc]\n\t\t//                         ^^^^^^^^^ inlineCompletion.range\n\t\t//              ^^^^^^^^^^ ^^^^^^ sourceIndentationLength\n\t\t//                         ^^^^^^ replacedIndentation.length\n\t\t//                               ^^^ rangeThatDoesNotReplaceIndentation\n\n\t\t// inlineCompletion.text: '\u00B7\u00B7foo'\n\t\t//                         ^^ suggestionAddedIndentationLength\n\n\t\tconst suggestionAddedIndentationLength = getLeadingWhitespace(\n\t\t\te.text,\n\t\t).length;\n\n\t\tconst replacedIndentation = sourceLine.substring(\n\t\t\te.range.startColumn - 1,\n\t\t\tsourceIndentationLength,\n\t\t);\n\n\t\tconst [startPosition, endPosition] = [\n\t\t\te.range.getStartPosition(),\n\t\t\te.range.getEndPosition(),\n\t\t];\n\t\tconst newStartPosition =\n\t\t\tstartPosition.column + replacedIndentation.length <=\n\t\t\tendPosition.column\n\t\t\t\t? startPosition.delta(0, replacedIndentation.length)\n\t\t\t\t: endPosition;\n\t\tconst rangeThatDoesNotReplaceIndentation = Range.fromPositions(\n\t\t\tnewStartPosition,\n\t\t\tendPosition,\n\t\t);\n\n\t\tconst suggestionWithoutIndentationChange = e.text.startsWith(\n\t\t\treplacedIndentation,\n\t\t)\n\t\t\t? // Adds more indentation without changing existing indentation: We can add ghost text for this\n\t\t\t\te.text.substring(replacedIndentation.length)\n\t\t\t: // Changes or removes existing indentation. Only add ghost text for the non-indentation part.\n\t\t\t\te.text.substring(suggestionAddedIndentationLength);\n\n\t\te = new SingleTextEdit(\n\t\t\trangeThatDoesNotReplaceIndentation,\n\t\t\tsuggestionWithoutIndentationChange,\n\t\t);\n\t}\n\n\t// This is a single line string\n\tconst valueToBeReplaced = model.getValueInRange(e.range);\n\n\tconst changes = cachingDiff(valueToBeReplaced, e.text);\n\n\tif (!changes) {\n\t\t// No ghost text in case the diff would be too slow to compute\n\t\treturn undefined;\n\t}\n\n\tconst lineNumber = e.range.startLineNumber;\n\n\tconst parts = new Array<GhostTextPart>();\n\n\tif (mode === \"prefix\") {\n\t\tconst filteredChanges = changes.filter((c) => c.originalLength === 0);\n\t\tif (\n\t\t\tfilteredChanges.length > 1 ||\n\t\t\t(filteredChanges.length === 1 &&\n\t\t\t\tfilteredChanges[0].originalStart !== valueToBeReplaced.length)\n\t\t) {\n\t\t\t// Prefixes only have a single change.\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tconst previewStartInCompletionText = e.text.length - previewSuffixLength;\n\n\tfor (const c of changes) {\n\t\tconst insertColumn =\n\t\t\te.range.startColumn + c.originalStart + c.originalLength;\n\n\t\tif (\n\t\t\tmode === \"subwordSmart\" &&\n\t\t\tcursorPosition &&\n\t\t\tcursorPosition.lineNumber === e.range.startLineNumber &&\n\t\t\tinsertColumn < cursorPosition.column\n\t\t) {\n\t\t\t// No ghost text before cursor\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (c.originalLength > 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (c.modifiedLength === 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst modifiedEnd = c.modifiedStart + c.modifiedLength;\n\t\tconst nonPreviewTextEnd = Math.max(\n\t\t\tc.modifiedStart,\n\t\t\tMath.min(modifiedEnd, previewStartInCompletionText),\n\t\t);\n\t\tconst nonPreviewText = e.text.substring(\n\t\t\tc.modifiedStart,\n\t\t\tnonPreviewTextEnd,\n\t\t);\n\t\tconst italicText = e.text.substring(\n\t\t\tnonPreviewTextEnd,\n\t\t\tMath.max(c.modifiedStart, modifiedEnd),\n\t\t);\n\n\t\tif (nonPreviewText.length > 0) {\n\t\t\tparts.push(new GhostTextPart(insertColumn, nonPreviewText, false));\n\t\t}\n\t\tif (italicText.length > 0) {\n\t\t\tparts.push(new GhostTextPart(insertColumn, italicText, true));\n\t\t}\n\t}\n\n\treturn new GhostText(lineNumber, parts);\n}\n\nfunction rangeExtends(extendingRange: Range, rangeToExtend: Range): boolean {\n\treturn (\n\t\trangeToExtend\n\t\t\t.getStartPosition()\n\t\t\t.equals(extendingRange.getStartPosition()) &&\n\t\trangeToExtend\n\t\t\t.getEndPosition()\n\t\t\t.isBeforeOrEqual(extendingRange.getEndPosition())\n\t);\n}\n\nlet lastRequest:\n\t| {\n\t\t\toriginalValue: string;\n\t\t\tnewValue: string;\n\t\t\tchanges: readonly IDiffChange[] | undefined;\n\t  }\n\t| undefined;\nfunction cachingDiff(\n\toriginalValue: string,\n\tnewValue: string,\n): readonly IDiffChange[] | undefined {\n\tif (\n\t\tlastRequest?.originalValue === originalValue &&\n\t\tlastRequest?.newValue === newValue\n\t) {\n\t\treturn lastRequest?.changes;\n\t} else {\n\t\tlet changes = smartDiff(originalValue, newValue, true);\n\t\tif (changes) {\n\t\t\tconst deletedChars = deletedCharacters(changes);\n\t\t\tif (deletedChars > 0) {\n\t\t\t\t// For performance reasons, don't compute diff if there is nothing to improve\n\t\t\t\tconst newChanges = smartDiff(originalValue, newValue, false);\n\t\t\t\tif (\n\t\t\t\t\tnewChanges &&\n\t\t\t\t\tdeletedCharacters(newChanges) < deletedChars\n\t\t\t\t) {\n\t\t\t\t\t// Disabling smartness seems to be better here\n\t\t\t\t\tchanges = newChanges;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlastRequest = {\n\t\t\toriginalValue,\n\t\t\tnewValue,\n\t\t\tchanges,\n\t\t};\n\t\treturn changes;\n\t}\n}\n\nfunction deletedCharacters(changes: readonly IDiffChange[]): number {\n\tlet sum = 0;\n\tfor (const c of changes) {\n\t\tsum += c.originalLength;\n\t}\n\treturn sum;\n}\n\n/**\n * When matching `if ()` with `if (f() = 1) { g(); }`,\n * align it like this:        `if (       )`\n * Not like this:\t\t\t  `if (  )`\n * Also not like this:\t\t  `if (             )`.\n *\n * The parenthesis are preprocessed to ensure that they match correctly.\n */\nfunction smartDiff(\n\toriginalValue: string,\n\tnewValue: string,\n\tsmartBracketMatching: boolean,\n): readonly IDiffChange[] | undefined {\n\tif (originalValue.length > 5000 || newValue.length > 5000) {\n\t\t// We don't want to work on strings that are too big\n\t\treturn undefined;\n\t}\n\n\tfunction getMaxCharCode(val: string): number {\n\t\tlet maxCharCode = 0;\n\t\tfor (let i = 0, len = val.length; i < len; i++) {\n\t\t\tconst charCode = val.charCodeAt(i);\n\t\t\tif (charCode > maxCharCode) {\n\t\t\t\tmaxCharCode = charCode;\n\t\t\t}\n\t\t}\n\t\treturn maxCharCode;\n\t}\n\n\tconst maxCharCode = Math.max(\n\t\tgetMaxCharCode(originalValue),\n\t\tgetMaxCharCode(newValue),\n\t);\n\tfunction getUniqueCharCode(id: number): number {\n\t\tif (id < 0) {\n\t\t\tthrow new Error(\"unexpected\");\n\t\t}\n\t\treturn maxCharCode + id + 1;\n\t}\n\n\tfunction getElements(source: string): Int32Array {\n\t\tlet level = 0;\n\t\tlet group = 0;\n\t\tconst characters = new Int32Array(source.length);\n\t\tfor (let i = 0, len = source.length; i < len; i++) {\n\t\t\t// TODO support more brackets\n\t\t\tif (smartBracketMatching && source[i] === \"(\") {\n\t\t\t\tconst id = group * 100 + level;\n\t\t\t\tcharacters[i] = getUniqueCharCode(2 * id);\n\t\t\t\tlevel++;\n\t\t\t} else if (smartBracketMatching && source[i] === \")\") {\n\t\t\t\tlevel = Math.max(level - 1, 0);\n\t\t\t\tconst id = group * 100 + level;\n\t\t\t\tcharacters[i] = getUniqueCharCode(2 * id + 1);\n\t\t\t\tif (level === 0) {\n\t\t\t\t\tgroup++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcharacters[i] = source.charCodeAt(i);\n\t\t\t}\n\t\t}\n\t\treturn characters;\n\t}\n\n\tconst elements1 = getElements(originalValue);\n\tconst elements2 = getElements(newValue);\n\n\treturn new LcsDiff(\n\t\t{ getElements: () => elements1 },\n\t\t{ getElements: () => elements2 },\n\t).ComputeDiff(false).changes;\n}\n"],
  "mappings": "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",
  "names": ["maxCharCode"]
}
