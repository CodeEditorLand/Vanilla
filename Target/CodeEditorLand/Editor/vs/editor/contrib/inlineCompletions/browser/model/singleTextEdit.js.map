{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/contrib/inlineCompletions/browser/model/singleTextEdit.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IDiffChange, LcsDiff } from '../../../../../base/common/diff/diff.js';\nimport { commonPrefixLength, getLeadingWhitespace } from '../../../../../base/common/strings.js';\nimport { Position } from '../../../../common/core/position.js';\nimport { Range } from '../../../../common/core/range.js';\nimport { TextLength } from '../../../../common/core/textLength.js';\nimport { SingleTextEdit } from '../../../../common/core/textEdit.js';\nimport { EndOfLinePreference, ITextModel } from '../../../../common/model.js';\nimport { GhostText, GhostTextPart } from './ghostText.js';\n\nexport function singleTextRemoveCommonPrefix(edit: SingleTextEdit, model: ITextModel, validModelRange?: Range): SingleTextEdit {\n\tconst modelRange = validModelRange ? edit.range.intersectRanges(validModelRange) : edit.range;\n\tif (!modelRange) {\n\t\treturn edit;\n\t}\n\tconst valueToReplace = model.getValueInRange(modelRange, EndOfLinePreference.LF);\n\tconst commonPrefixLen = commonPrefixLength(valueToReplace, edit.text);\n\tconst start = TextLength.ofText(valueToReplace.substring(0, commonPrefixLen)).addToPosition(edit.range.getStartPosition());\n\tconst text = edit.text.substring(commonPrefixLen);\n\tconst range = Range.fromPositions(start, edit.range.getEndPosition());\n\treturn new SingleTextEdit(range, text);\n}\n\nexport function singleTextEditAugments(edit: SingleTextEdit, base: SingleTextEdit): boolean {\n\t// The augmented completion must replace the base range, but can replace even more\n\treturn edit.text.startsWith(base.text) && rangeExtends(edit.range, base.range);\n}\n\n/**\n * @param previewSuffixLength Sets where to split `inlineCompletion.text`.\n * \tIf the text is `hello` and the suffix length is 2, the non-preview part is `hel` and the preview-part is `lo`.\n*/\nexport function computeGhostText(\n\tedit: SingleTextEdit,\n\tmodel: ITextModel,\n\tmode: 'prefix' | 'subword' | 'subwordSmart',\n\tcursorPosition?: Position,\n\tpreviewSuffixLength = 0\n): GhostText | undefined {\n\tlet e = singleTextRemoveCommonPrefix(edit, model);\n\n\tif (e.range.endLineNumber !== e.range.startLineNumber) {\n\t\t// This edit might span multiple lines, but the first lines must be a common prefix.\n\t\treturn undefined;\n\t}\n\n\tconst sourceLine = model.getLineContent(e.range.startLineNumber);\n\tconst sourceIndentationLength = getLeadingWhitespace(sourceLine).length;\n\n\tconst suggestionTouchesIndentation = e.range.startColumn - 1 <= sourceIndentationLength;\n\tif (suggestionTouchesIndentation) {\n\t\t// source:      \u00B7\u00B7\u00B7\u00B7\u00B7\u00B7\u00B7\u00B7\u00B7\u00B7[\u00B7\u00B7\u00B7\u00B7\u00B7\u00B7abc]\n\t\t//                         ^^^^^^^^^ inlineCompletion.range\n\t\t//              ^^^^^^^^^^ ^^^^^^ sourceIndentationLength\n\t\t//                         ^^^^^^ replacedIndentation.length\n\t\t//                               ^^^ rangeThatDoesNotReplaceIndentation\n\n\t\t// inlineCompletion.text: '\u00B7\u00B7foo'\n\t\t//                         ^^ suggestionAddedIndentationLength\n\n\t\tconst suggestionAddedIndentationLength = getLeadingWhitespace(e.text).length;\n\n\t\tconst replacedIndentation = sourceLine.substring(e.range.startColumn - 1, sourceIndentationLength);\n\n\t\tconst [startPosition, endPosition] = [e.range.getStartPosition(), e.range.getEndPosition()];\n\t\tconst newStartPosition =\n\t\t\tstartPosition.column + replacedIndentation.length <= endPosition.column\n\t\t\t\t? startPosition.delta(0, replacedIndentation.length)\n\t\t\t\t: endPosition;\n\t\tconst rangeThatDoesNotReplaceIndentation = Range.fromPositions(newStartPosition, endPosition);\n\n\t\tconst suggestionWithoutIndentationChange =\n\t\t\te.text.startsWith(replacedIndentation)\n\t\t\t\t// Adds more indentation without changing existing indentation: We can add ghost text for this\n\t\t\t\t? e.text.substring(replacedIndentation.length)\n\t\t\t\t// Changes or removes existing indentation. Only add ghost text for the non-indentation part.\n\t\t\t\t: e.text.substring(suggestionAddedIndentationLength);\n\n\t\te = new SingleTextEdit(rangeThatDoesNotReplaceIndentation, suggestionWithoutIndentationChange);\n\t}\n\n\t// This is a single line string\n\tconst valueToBeReplaced = model.getValueInRange(e.range);\n\n\tconst changes = cachingDiff(valueToBeReplaced, e.text);\n\n\tif (!changes) {\n\t\t// No ghost text in case the diff would be too slow to compute\n\t\treturn undefined;\n\t}\n\n\tconst lineNumber = e.range.startLineNumber;\n\n\tconst parts = new Array<GhostTextPart>();\n\n\tif (mode === 'prefix') {\n\t\tconst filteredChanges = changes.filter(c => c.originalLength === 0);\n\t\tif (filteredChanges.length > 1 || filteredChanges.length === 1 && filteredChanges[0].originalStart !== valueToBeReplaced.length) {\n\t\t\t// Prefixes only have a single change.\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tconst previewStartInCompletionText = e.text.length - previewSuffixLength;\n\n\tfor (const c of changes) {\n\t\tconst insertColumn = e.range.startColumn + c.originalStart + c.originalLength;\n\n\t\tif (mode === 'subwordSmart' && cursorPosition && cursorPosition.lineNumber === e.range.startLineNumber && insertColumn < cursorPosition.column) {\n\t\t\t// No ghost text before cursor\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (c.originalLength > 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (c.modifiedLength === 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst modifiedEnd = c.modifiedStart + c.modifiedLength;\n\t\tconst nonPreviewTextEnd = Math.max(c.modifiedStart, Math.min(modifiedEnd, previewStartInCompletionText));\n\t\tconst nonPreviewText = e.text.substring(c.modifiedStart, nonPreviewTextEnd);\n\t\tconst italicText = e.text.substring(nonPreviewTextEnd, Math.max(c.modifiedStart, modifiedEnd));\n\n\t\tif (nonPreviewText.length > 0) {\n\t\t\tparts.push(new GhostTextPart(insertColumn, nonPreviewText, false));\n\t\t}\n\t\tif (italicText.length > 0) {\n\t\t\tparts.push(new GhostTextPart(insertColumn, italicText, true));\n\t\t}\n\t}\n\n\treturn new GhostText(lineNumber, parts);\n}\n\nfunction rangeExtends(extendingRange: Range, rangeToExtend: Range): boolean {\n\treturn rangeToExtend.getStartPosition().equals(extendingRange.getStartPosition())\n\t\t&& rangeToExtend.getEndPosition().isBeforeOrEqual(extendingRange.getEndPosition());\n}\n\nlet lastRequest: { originalValue: string; newValue: string; changes: readonly IDiffChange[] | undefined } | undefined = undefined;\nfunction cachingDiff(originalValue: string, newValue: string): readonly IDiffChange[] | undefined {\n\tif (lastRequest?.originalValue === originalValue && lastRequest?.newValue === newValue) {\n\t\treturn lastRequest?.changes;\n\t} else {\n\t\tlet changes = smartDiff(originalValue, newValue, true);\n\t\tif (changes) {\n\t\t\tconst deletedChars = deletedCharacters(changes);\n\t\t\tif (deletedChars > 0) {\n\t\t\t\t// For performance reasons, don't compute diff if there is nothing to improve\n\t\t\t\tconst newChanges = smartDiff(originalValue, newValue, false);\n\t\t\t\tif (newChanges && deletedCharacters(newChanges) < deletedChars) {\n\t\t\t\t\t// Disabling smartness seems to be better here\n\t\t\t\t\tchanges = newChanges;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlastRequest = {\n\t\t\toriginalValue,\n\t\t\tnewValue,\n\t\t\tchanges\n\t\t};\n\t\treturn changes;\n\t}\n}\n\nfunction deletedCharacters(changes: readonly IDiffChange[]): number {\n\tlet sum = 0;\n\tfor (const c of changes) {\n\t\tsum += c.originalLength;\n\t}\n\treturn sum;\n}\n\n/**\n * When matching `if ()` with `if (f() = 1) { g(); }`,\n * align it like this:        `if (       )`\n * Not like this:\t\t\t  `if (  )`\n * Also not like this:\t\t  `if (             )`.\n *\n * The parenthesis are preprocessed to ensure that they match correctly.\n */\nfunction smartDiff(originalValue: string, newValue: string, smartBracketMatching: boolean): (readonly IDiffChange[]) | undefined {\n\tif (originalValue.length > 5000 || newValue.length > 5000) {\n\t\t// We don't want to work on strings that are too big\n\t\treturn undefined;\n\t}\n\n\tfunction getMaxCharCode(val: string): number {\n\t\tlet maxCharCode = 0;\n\t\tfor (let i = 0, len = val.length; i < len; i++) {\n\t\t\tconst charCode = val.charCodeAt(i);\n\t\t\tif (charCode > maxCharCode) {\n\t\t\t\tmaxCharCode = charCode;\n\t\t\t}\n\t\t}\n\t\treturn maxCharCode;\n\t}\n\n\tconst maxCharCode = Math.max(getMaxCharCode(originalValue), getMaxCharCode(newValue));\n\tfunction getUniqueCharCode(id: number): number {\n\t\tif (id < 0) {\n\t\t\tthrow new Error('unexpected');\n\t\t}\n\t\treturn maxCharCode + id + 1;\n\t}\n\n\tfunction getElements(source: string): Int32Array {\n\t\tlet level = 0;\n\t\tlet group = 0;\n\t\tconst characters = new Int32Array(source.length);\n\t\tfor (let i = 0, len = source.length; i < len; i++) {\n\t\t\t// TODO support more brackets\n\t\t\tif (smartBracketMatching && source[i] === '(') {\n\t\t\t\tconst id = group * 100 + level;\n\t\t\t\tcharacters[i] = getUniqueCharCode(2 * id);\n\t\t\t\tlevel++;\n\t\t\t} else if (smartBracketMatching && source[i] === ')') {\n\t\t\t\tlevel = Math.max(level - 1, 0);\n\t\t\t\tconst id = group * 100 + level;\n\t\t\t\tcharacters[i] = getUniqueCharCode(2 * id + 1);\n\t\t\t\tif (level === 0) {\n\t\t\t\t\tgroup++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcharacters[i] = source.charCodeAt(i);\n\t\t\t}\n\t\t}\n\t\treturn characters;\n\t}\n\n\tconst elements1 = getElements(originalValue);\n\tconst elements2 = getElements(newValue);\n\n\treturn new LcsDiff({ getElements: () => elements1 }, { getElements: () => elements2 }).ComputeDiff(false).changes;\n}\n"],
  "mappings": "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",
  "names": ["maxCharCode"]
}
