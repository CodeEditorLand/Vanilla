{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { findLast } from \"../../../../base/common/arraysFind.js\";\nimport { DeferredPromise } from \"../../../../base/common/async.js\";\nimport {\n\ttype CancellationToken,\n\tCancellationTokenSource,\n} from \"../../../../base/common/cancellation.js\";\nimport { Codicon } from \"../../../../base/common/codicons.js\";\nimport type { IMatch } from \"../../../../base/common/filters.js\";\nimport {\n\ttype IPreparedQuery,\n\tpieceToQuery,\n\tprepareQuery,\n\tscoreFuzzy2,\n} from \"../../../../base/common/fuzzyScorer.js\";\nimport {\n\tDisposable,\n\tDisposableStore,\n\ttype IDisposable,\n\ttoDisposable,\n} from \"../../../../base/common/lifecycle.js\";\nimport { format, trim } from \"../../../../base/common/strings.js\";\nimport { ThemeIcon } from \"../../../../base/common/themables.js\";\nimport type { URI } from \"../../../../base/common/uri.js\";\nimport { localize } from \"../../../../nls.js\";\nimport type { IQuickAccessProviderRunOptions } from \"../../../../platform/quickinput/common/quickAccess.js\";\nimport type {\n\tIQuickInputButton,\n\tIQuickPick,\n\tIQuickPickItem,\n\tIQuickPickSeparator,\n} from \"../../../../platform/quickinput/common/quickInput.js\";\nimport type { Position } from \"../../../common/core/position.js\";\nimport { type IRange, Range } from \"../../../common/core/range.js\";\nimport { ScrollType } from \"../../../common/editorCommon.js\";\nimport {\n\ttype DocumentSymbol,\n\tSymbolKind,\n\tSymbolKinds,\n\tSymbolTag,\n\tgetAriaLabelForSymbol,\n} from \"../../../common/languages.js\";\nimport type { ITextModel } from \"../../../common/model.js\";\nimport { ILanguageFeaturesService } from \"../../../common/services/languageFeatures.js\";\nimport { IOutlineModelService } from \"../../documentSymbols/browser/outlineModel.js\";\nimport {\n\tAbstractEditorNavigationQuickAccessProvider,\n\ttype IEditorNavigationQuickAccessOptions,\n\ttype IQuickAccessTextEditorContext,\n} from \"./editorNavigationQuickAccess.js\";\n\nexport interface IGotoSymbolQuickPickItem extends IQuickPickItem {\n\tkind: SymbolKind;\n\tindex: number;\n\tscore?: number;\n\turi?: URI;\n\tsymbolName?: string;\n\trange?: { decoration: IRange; selection: IRange };\n}\n\nexport interface IGotoSymbolQuickAccessProviderOptions\n\textends IEditorNavigationQuickAccessOptions {\n\topenSideBySideDirection?: () => undefined | \"right\" | \"down\";\n\t/**\n\t * A handler to invoke when an item is accepted for\n\t * this particular showing of the quick access.\n\t * @param item The item that was accepted.\n\t */\n\treadonly handleAccept?: (item: IQuickPickItem) => void;\n}\n\nexport abstract class AbstractGotoSymbolQuickAccessProvider extends AbstractEditorNavigationQuickAccessProvider {\n\tstatic PREFIX = \"@\";\n\tstatic SCOPE_PREFIX = \":\";\n\tstatic PREFIX_BY_CATEGORY = `${this.PREFIX}${this.SCOPE_PREFIX}`;\n\n\tprotected override readonly options: IGotoSymbolQuickAccessProviderOptions;\n\n\tconstructor(\n\t\t@ILanguageFeaturesService\n\t\tprivate readonly _languageFeaturesService: ILanguageFeaturesService,\n\t\t@IOutlineModelService\n\t\tprivate readonly _outlineModelService: IOutlineModelService,\n\t\toptions: IGotoSymbolQuickAccessProviderOptions = Object.create(null),\n\t) {\n\t\tsuper(options);\n\n\t\tthis.options = options;\n\t\tthis.options.canAcceptInBackground = true;\n\t}\n\n\tprotected provideWithoutTextEditor(\n\t\tpicker: IQuickPick<IGotoSymbolQuickPickItem, { useSeparators: true }>,\n\t): IDisposable {\n\t\tthis.provideLabelPick(\n\t\t\tpicker,\n\t\t\tlocalize(\n\t\t\t\t\"cannotRunGotoSymbolWithoutEditor\",\n\t\t\t\t\"To go to a symbol, first open a text editor with symbol information.\",\n\t\t\t),\n\t\t);\n\n\t\treturn Disposable.None;\n\t}\n\n\tprotected provideWithTextEditor(\n\t\tcontext: IQuickAccessTextEditorContext,\n\t\tpicker: IQuickPick<IGotoSymbolQuickPickItem, { useSeparators: true }>,\n\t\ttoken: CancellationToken,\n\t\trunOptions?: IQuickAccessProviderRunOptions,\n\t): IDisposable {\n\t\tconst editor = context.editor;\n\t\tconst model = this.getModel(editor);\n\t\tif (!model) {\n\t\t\treturn Disposable.None;\n\t\t}\n\n\t\t// Provide symbols from model if available in registry\n\t\tif (this._languageFeaturesService.documentSymbolProvider.has(model)) {\n\t\t\treturn this.doProvideWithEditorSymbols(\n\t\t\t\tcontext,\n\t\t\t\tmodel,\n\t\t\t\tpicker,\n\t\t\t\ttoken,\n\t\t\t\trunOptions,\n\t\t\t);\n\t\t}\n\n\t\t// Otherwise show an entry for a model without registry\n\t\t// But give a chance to resolve the symbols at a later\n\t\t// point if possible\n\t\treturn this.doProvideWithoutEditorSymbols(\n\t\t\tcontext,\n\t\t\tmodel,\n\t\t\tpicker,\n\t\t\ttoken,\n\t\t);\n\t}\n\n\tprivate doProvideWithoutEditorSymbols(\n\t\tcontext: IQuickAccessTextEditorContext,\n\t\tmodel: ITextModel,\n\t\tpicker: IQuickPick<IGotoSymbolQuickPickItem, { useSeparators: true }>,\n\t\ttoken: CancellationToken,\n\t): IDisposable {\n\t\tconst disposables = new DisposableStore();\n\n\t\t// Generic pick for not having any symbol information\n\t\tthis.provideLabelPick(\n\t\t\tpicker,\n\t\t\tlocalize(\n\t\t\t\t\"cannotRunGotoSymbolWithoutSymbolProvider\",\n\t\t\t\t\"The active text editor does not provide symbol information.\",\n\t\t\t),\n\t\t);\n\n\t\t// Wait for changes to the registry and see if eventually\n\t\t// we do get symbols. This can happen if the picker is opened\n\t\t// very early after the model has loaded but before the\n\t\t// language registry is ready.\n\t\t// https://github.com/microsoft/vscode/issues/70607\n\t\t(async () => {\n\t\t\tconst result = await this.waitForLanguageSymbolRegistry(\n\t\t\t\tmodel,\n\t\t\t\tdisposables,\n\t\t\t);\n\t\t\tif (!result || token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdisposables.add(\n\t\t\t\tthis.doProvideWithEditorSymbols(context, model, picker, token),\n\t\t\t);\n\t\t})();\n\n\t\treturn disposables;\n\t}\n\n\tprivate provideLabelPick(\n\t\tpicker: IQuickPick<IGotoSymbolQuickPickItem, { useSeparators: true }>,\n\t\tlabel: string,\n\t): void {\n\t\tpicker.items = [{ label, index: 0, kind: SymbolKind.String }];\n\t\tpicker.ariaLabel = label;\n\t}\n\n\tprotected async waitForLanguageSymbolRegistry(\n\t\tmodel: ITextModel,\n\t\tdisposables: DisposableStore,\n\t): Promise<boolean> {\n\t\tif (this._languageFeaturesService.documentSymbolProvider.has(model)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tconst symbolProviderRegistryPromise = new DeferredPromise<boolean>();\n\n\t\t// Resolve promise when registry knows model\n\t\tconst symbolProviderListener = disposables.add(\n\t\t\tthis._languageFeaturesService.documentSymbolProvider.onDidChange(\n\t\t\t\t() => {\n\t\t\t\t\tif (\n\t\t\t\t\t\tthis._languageFeaturesService.documentSymbolProvider.has(\n\t\t\t\t\t\t\tmodel,\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tsymbolProviderListener.dispose();\n\n\t\t\t\t\t\tsymbolProviderRegistryPromise.complete(true);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t),\n\t\t);\n\n\t\t// Resolve promise when we get disposed too\n\t\tdisposables.add(\n\t\t\ttoDisposable(() => symbolProviderRegistryPromise.complete(false)),\n\t\t);\n\n\t\treturn symbolProviderRegistryPromise.p;\n\t}\n\n\tprivate doProvideWithEditorSymbols(\n\t\tcontext: IQuickAccessTextEditorContext,\n\t\tmodel: ITextModel,\n\t\tpicker: IQuickPick<IGotoSymbolQuickPickItem, { useSeparators: true }>,\n\t\ttoken: CancellationToken,\n\t\trunOptions?: IQuickAccessProviderRunOptions,\n\t): IDisposable {\n\t\tconst editor = context.editor;\n\t\tconst disposables = new DisposableStore();\n\n\t\t// Goto symbol once picked\n\t\tdisposables.add(\n\t\t\tpicker.onDidAccept((event) => {\n\t\t\t\tconst [item] = picker.selectedItems;\n\t\t\t\tif (item && item.range) {\n\t\t\t\t\tthis.gotoLocation(context, {\n\t\t\t\t\t\trange: item.range.selection,\n\t\t\t\t\t\tkeyMods: picker.keyMods,\n\t\t\t\t\t\tpreserveFocus: event.inBackground,\n\t\t\t\t\t});\n\n\t\t\t\t\trunOptions?.handleAccept?.(item);\n\n\t\t\t\t\tif (!event.inBackground) {\n\t\t\t\t\t\tpicker.hide();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\n\t\t// Goto symbol side by side if enabled\n\t\tdisposables.add(\n\t\t\tpicker.onDidTriggerItemButton(({ item }) => {\n\t\t\t\tif (item && item.range) {\n\t\t\t\t\tthis.gotoLocation(context, {\n\t\t\t\t\t\trange: item.range.selection,\n\t\t\t\t\t\tkeyMods: picker.keyMods,\n\t\t\t\t\t\tforceSideBySide: true,\n\t\t\t\t\t});\n\n\t\t\t\t\tpicker.hide();\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\n\t\t// Resolve symbols from document once and reuse this\n\t\t// request for all filtering and typing then on\n\t\tconst symbolsPromise = this.getDocumentSymbols(model, token);\n\n\t\t// Set initial picks and update on type\n\t\tlet picksCts: CancellationTokenSource | undefined;\n\t\tconst updatePickerItems = async (\n\t\t\tpositionToEnclose: Position | undefined,\n\t\t) => {\n\t\t\t// Cancel any previous ask for picks and busy\n\t\t\tpicksCts?.dispose(true);\n\t\t\tpicker.busy = false;\n\n\t\t\t// Create new cancellation source for this run\n\t\t\tpicksCts = new CancellationTokenSource(token);\n\n\t\t\t// Collect symbol picks\n\t\t\tpicker.busy = true;\n\t\t\ttry {\n\t\t\t\tconst query = prepareQuery(\n\t\t\t\t\tpicker.value\n\t\t\t\t\t\t.substr(\n\t\t\t\t\t\t\tAbstractGotoSymbolQuickAccessProvider.PREFIX.length,\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.trim(),\n\t\t\t\t);\n\t\t\t\tconst items = await this.doGetSymbolPicks(\n\t\t\t\t\tsymbolsPromise,\n\t\t\t\t\tquery,\n\t\t\t\t\tundefined,\n\t\t\t\t\tpicksCts.token,\n\t\t\t\t\tmodel,\n\t\t\t\t);\n\t\t\t\tif (token.isCancellationRequested) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (items.length > 0) {\n\t\t\t\t\tpicker.items = items;\n\t\t\t\t\tif (positionToEnclose && query.original.length === 0) {\n\t\t\t\t\t\tconst candidate = <IGotoSymbolQuickPickItem>(\n\t\t\t\t\t\t\tfindLast(items, (item) =>\n\t\t\t\t\t\t\t\tBoolean(\n\t\t\t\t\t\t\t\t\titem.type !== \"separator\" &&\n\t\t\t\t\t\t\t\t\t\titem.range &&\n\t\t\t\t\t\t\t\t\t\tRange.containsPosition(\n\t\t\t\t\t\t\t\t\t\t\titem.range.decoration,\n\t\t\t\t\t\t\t\t\t\t\tpositionToEnclose,\n\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (candidate) {\n\t\t\t\t\t\t\tpicker.activeItems = [candidate];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (query.original.length > 0) {\n\t\t\t\t\tthis.provideLabelPick(\n\t\t\t\t\t\tpicker,\n\t\t\t\t\t\tlocalize(\n\t\t\t\t\t\t\t\"noMatchingSymbolResults\",\n\t\t\t\t\t\t\t\"No matching editor symbols\",\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tthis.provideLabelPick(\n\t\t\t\t\t\tpicker,\n\t\t\t\t\t\tlocalize(\"noSymbolResults\", \"No editor symbols\"),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (!token.isCancellationRequested) {\n\t\t\t\t\tpicker.busy = false;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tdisposables.add(\n\t\t\tpicker.onDidChangeValue(() => updatePickerItems(undefined)),\n\t\t);\n\t\tupdatePickerItems(editor.getSelection()?.getPosition());\n\n\t\t// Reveal and decorate when active item changes\n\t\tdisposables.add(\n\t\t\tpicker.onDidChangeActive(() => {\n\t\t\t\tconst [item] = picker.activeItems;\n\t\t\t\tif (item && item.range) {\n\t\t\t\t\t// Reveal\n\t\t\t\t\teditor.revealRangeInCenter(\n\t\t\t\t\t\titem.range.selection,\n\t\t\t\t\t\tScrollType.Smooth,\n\t\t\t\t\t);\n\n\t\t\t\t\t// Decorate\n\t\t\t\t\tthis.addDecorations(editor, item.range.decoration);\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\n\t\treturn disposables;\n\t}\n\n\tprotected async doGetSymbolPicks(\n\t\tsymbolsPromise: Promise<DocumentSymbol[]>,\n\t\tquery: IPreparedQuery,\n\t\toptions: { extraContainerLabel?: string } | undefined,\n\t\ttoken: CancellationToken,\n\t\tmodel: ITextModel,\n\t): Promise<Array<IGotoSymbolQuickPickItem | IQuickPickSeparator>> {\n\t\tconst symbols = await symbolsPromise;\n\t\tif (token.isCancellationRequested) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst filterBySymbolKind =\n\t\t\tquery.original.indexOf(\n\t\t\t\tAbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX,\n\t\t\t) === 0;\n\t\tconst filterPos = filterBySymbolKind ? 1 : 0;\n\n\t\t// Split between symbol and container query\n\t\tlet symbolQuery: IPreparedQuery;\n\t\tlet containerQuery: IPreparedQuery | undefined;\n\t\tif (query.values && query.values.length > 1) {\n\t\t\tsymbolQuery = pieceToQuery(query.values[0]); // symbol: only match on first part\n\t\t\tcontainerQuery = pieceToQuery(query.values.slice(1)); // container: match on all but first parts\n\t\t} else {\n\t\t\tsymbolQuery = query;\n\t\t}\n\n\t\t// Convert to symbol picks and apply filtering\n\n\t\tlet buttons: IQuickInputButton[] | undefined;\n\t\tconst openSideBySideDirection =\n\t\t\tthis.options?.openSideBySideDirection?.();\n\t\tif (openSideBySideDirection) {\n\t\t\tbuttons = [\n\t\t\t\t{\n\t\t\t\t\ticonClass:\n\t\t\t\t\t\topenSideBySideDirection === \"right\"\n\t\t\t\t\t\t\t? ThemeIcon.asClassName(Codicon.splitHorizontal)\n\t\t\t\t\t\t\t: ThemeIcon.asClassName(Codicon.splitVertical),\n\t\t\t\t\ttooltip:\n\t\t\t\t\t\topenSideBySideDirection === \"right\"\n\t\t\t\t\t\t\t? localize(\"openToSide\", \"Open to the Side\")\n\t\t\t\t\t\t\t: localize(\"openToBottom\", \"Open to the Bottom\"),\n\t\t\t\t},\n\t\t\t];\n\t\t}\n\n\t\tconst filteredSymbolPicks: IGotoSymbolQuickPickItem[] = [];\n\t\tfor (let index = 0; index < symbols.length; index++) {\n\t\t\tconst symbol = symbols[index];\n\n\t\t\tconst symbolLabel = trim(symbol.name);\n\t\t\tconst symbolLabelWithIcon = `$(${SymbolKinds.toIcon(symbol.kind).id}) ${symbolLabel}`;\n\t\t\tconst symbolLabelIconOffset =\n\t\t\t\tsymbolLabelWithIcon.length - symbolLabel.length;\n\n\t\t\tlet containerLabel = symbol.containerName;\n\t\t\tif (options?.extraContainerLabel) {\n\t\t\t\tif (containerLabel) {\n\t\t\t\t\tcontainerLabel = `${options.extraContainerLabel} \u2022 ${containerLabel}`;\n\t\t\t\t} else {\n\t\t\t\t\tcontainerLabel = options.extraContainerLabel;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet symbolScore: number | undefined;\n\t\t\tlet symbolMatches: IMatch[] | undefined;\n\n\t\t\tlet containerScore: number | undefined;\n\t\t\tlet containerMatches: IMatch[] | undefined;\n\n\t\t\tif (query.original.length > filterPos) {\n\t\t\t\t// First: try to score on the entire query, it is possible that\n\t\t\t\t// the symbol matches perfectly (e.g. searching for \"change log\"\n\t\t\t\t// can be a match on a markdown symbol \"change log\"). In that\n\t\t\t\t// case we want to skip the container query altogether.\n\t\t\t\tlet skipContainerQuery = false;\n\t\t\t\tif (symbolQuery !== query) {\n\t\t\t\t\t[symbolScore, symbolMatches] = scoreFuzzy2(\n\t\t\t\t\t\tsymbolLabelWithIcon,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t...query,\n\t\t\t\t\t\t\tvalues: undefined /* disable multi-query support */,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfilterPos,\n\t\t\t\t\t\tsymbolLabelIconOffset,\n\t\t\t\t\t);\n\t\t\t\t\tif (typeof symbolScore === \"number\") {\n\t\t\t\t\t\tskipContainerQuery = true; // since we consumed the query, skip any container matching\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Otherwise: score on the symbol query and match on the container later\n\t\t\t\tif (typeof symbolScore !== \"number\") {\n\t\t\t\t\t[symbolScore, symbolMatches] = scoreFuzzy2(\n\t\t\t\t\t\tsymbolLabelWithIcon,\n\t\t\t\t\t\tsymbolQuery,\n\t\t\t\t\t\tfilterPos,\n\t\t\t\t\t\tsymbolLabelIconOffset,\n\t\t\t\t\t);\n\t\t\t\t\tif (typeof symbolScore !== \"number\") {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Score by container if specified\n\t\t\t\tif (!skipContainerQuery && containerQuery) {\n\t\t\t\t\tif (containerLabel && containerQuery.original.length > 0) {\n\t\t\t\t\t\t[containerScore, containerMatches] = scoreFuzzy2(\n\t\t\t\t\t\t\tcontainerLabel,\n\t\t\t\t\t\t\tcontainerQuery,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (typeof containerScore !== \"number\") {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (typeof symbolScore === \"number\") {\n\t\t\t\t\t\tsymbolScore += containerScore; // boost symbolScore by containerScore\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst deprecated =\n\t\t\t\tsymbol.tags && symbol.tags.indexOf(SymbolTag.Deprecated) >= 0;\n\n\t\t\tfilteredSymbolPicks.push({\n\t\t\t\tindex,\n\t\t\t\tkind: symbol.kind,\n\t\t\t\tscore: symbolScore,\n\t\t\t\tlabel: symbolLabelWithIcon,\n\t\t\t\tariaLabel: getAriaLabelForSymbol(symbol.name, symbol.kind),\n\t\t\t\tdescription: containerLabel,\n\t\t\t\thighlights: deprecated\n\t\t\t\t\t? undefined\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tlabel: symbolMatches,\n\t\t\t\t\t\t\tdescription: containerMatches,\n\t\t\t\t\t\t},\n\t\t\t\trange: {\n\t\t\t\t\tselection: Range.collapseToStart(symbol.selectionRange),\n\t\t\t\t\tdecoration: symbol.range,\n\t\t\t\t},\n\t\t\t\turi: model.uri,\n\t\t\t\tsymbolName: symbolLabel,\n\t\t\t\tstrikethrough: deprecated,\n\t\t\t\tbuttons,\n\t\t\t});\n\t\t}\n\n\t\t// Sort by score\n\t\tconst sortedFilteredSymbolPicks = filteredSymbolPicks.sort(\n\t\t\t(symbolA, symbolB) =>\n\t\t\t\tfilterBySymbolKind\n\t\t\t\t\t? this.compareByKindAndScore(symbolA, symbolB)\n\t\t\t\t\t: this.compareByScore(symbolA, symbolB),\n\t\t);\n\n\t\t// Add separator for types\n\t\t// - @  only total number of symbols\n\t\t// - @: grouped by symbol kind\n\t\tlet symbolPicks: Array<IGotoSymbolQuickPickItem | IQuickPickSeparator> =\n\t\t\t[];\n\t\tif (filterBySymbolKind) {\n\t\t\tlet lastSymbolKind: SymbolKind | undefined;\n\t\t\tlet lastSeparator: IQuickPickSeparator | undefined;\n\t\t\tlet lastSymbolKindCounter = 0;\n\n\t\t\tfunction updateLastSeparatorLabel(): void {\n\t\t\t\tif (\n\t\t\t\t\tlastSeparator &&\n\t\t\t\t\ttypeof lastSymbolKind === \"number\" &&\n\t\t\t\t\tlastSymbolKindCounter > 0\n\t\t\t\t) {\n\t\t\t\t\tlastSeparator.label = format(\n\t\t\t\t\t\tNLS_SYMBOL_KIND_CACHE[lastSymbolKind] ||\n\t\t\t\t\t\t\tFALLBACK_NLS_SYMBOL_KIND,\n\t\t\t\t\t\tlastSymbolKindCounter,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const symbolPick of sortedFilteredSymbolPicks) {\n\t\t\t\t// Found new kind\n\t\t\t\tif (lastSymbolKind !== symbolPick.kind) {\n\t\t\t\t\t// Update last separator with number of symbols we found for kind\n\t\t\t\t\tupdateLastSeparatorLabel();\n\n\t\t\t\t\tlastSymbolKind = symbolPick.kind;\n\t\t\t\t\tlastSymbolKindCounter = 1;\n\n\t\t\t\t\t// Add new separator for new kind\n\t\t\t\t\tlastSeparator = { type: \"separator\" };\n\t\t\t\t\tsymbolPicks.push(lastSeparator);\n\t\t\t\t}\n\n\t\t\t\t// Existing kind, keep counting\n\t\t\t\telse {\n\t\t\t\t\tlastSymbolKindCounter++;\n\t\t\t\t}\n\n\t\t\t\t// Add to final result\n\t\t\t\tsymbolPicks.push(symbolPick);\n\t\t\t}\n\n\t\t\t// Update last separator with number of symbols we found for kind\n\t\t\tupdateLastSeparatorLabel();\n\t\t} else if (sortedFilteredSymbolPicks.length > 0) {\n\t\t\tsymbolPicks = [\n\t\t\t\t{\n\t\t\t\t\tlabel: localize(\n\t\t\t\t\t\t\"symbols\",\n\t\t\t\t\t\t\"symbols ({0})\",\n\t\t\t\t\t\tfilteredSymbolPicks.length,\n\t\t\t\t\t),\n\t\t\t\t\ttype: \"separator\",\n\t\t\t\t},\n\t\t\t\t...sortedFilteredSymbolPicks,\n\t\t\t];\n\t\t}\n\n\t\treturn symbolPicks;\n\t}\n\n\tprivate compareByScore(\n\t\tsymbolA: IGotoSymbolQuickPickItem,\n\t\tsymbolB: IGotoSymbolQuickPickItem,\n\t): number {\n\t\tif (\n\t\t\ttypeof symbolA.score !== \"number\" &&\n\t\t\ttypeof symbolB.score === \"number\"\n\t\t) {\n\t\t\treturn 1;\n\t\t} else if (\n\t\t\ttypeof symbolA.score === \"number\" &&\n\t\t\ttypeof symbolB.score !== \"number\"\n\t\t) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (\n\t\t\ttypeof symbolA.score === \"number\" &&\n\t\t\ttypeof symbolB.score === \"number\"\n\t\t) {\n\t\t\tif (symbolA.score > symbolB.score) {\n\t\t\t\treturn -1;\n\t\t\t} else if (symbolA.score < symbolB.score) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tif (symbolA.index < symbolB.index) {\n\t\t\treturn -1;\n\t\t} else if (symbolA.index > symbolB.index) {\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tprivate compareByKindAndScore(\n\t\tsymbolA: IGotoSymbolQuickPickItem,\n\t\tsymbolB: IGotoSymbolQuickPickItem,\n\t): number {\n\t\tconst kindA =\n\t\t\tNLS_SYMBOL_KIND_CACHE[symbolA.kind] || FALLBACK_NLS_SYMBOL_KIND;\n\t\tconst kindB =\n\t\t\tNLS_SYMBOL_KIND_CACHE[symbolB.kind] || FALLBACK_NLS_SYMBOL_KIND;\n\n\t\t// Sort by type first if scoped search\n\t\tconst result = kindA.localeCompare(kindB);\n\t\tif (result === 0) {\n\t\t\treturn this.compareByScore(symbolA, symbolB);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprotected async getDocumentSymbols(\n\t\tdocument: ITextModel,\n\t\ttoken: CancellationToken,\n\t): Promise<DocumentSymbol[]> {\n\t\tconst model = await this._outlineModelService.getOrCreate(\n\t\t\tdocument,\n\t\t\ttoken,\n\t\t);\n\t\treturn token.isCancellationRequested\n\t\t\t? []\n\t\t\t: model.asListOfDocumentSymbols();\n\t}\n}\n\n// #region NLS Helpers\n\nconst FALLBACK_NLS_SYMBOL_KIND = localize(\"property\", \"properties ({0})\");\nconst NLS_SYMBOL_KIND_CACHE: { [type: number]: string } = {\n\t[SymbolKind.Method]: localize(\"method\", \"methods ({0})\"),\n\t[SymbolKind.Function]: localize(\"function\", \"functions ({0})\"),\n\t[SymbolKind.Constructor]: localize(\"_constructor\", \"constructors ({0})\"),\n\t[SymbolKind.Variable]: localize(\"variable\", \"variables ({0})\"),\n\t[SymbolKind.Class]: localize(\"class\", \"classes ({0})\"),\n\t[SymbolKind.Struct]: localize(\"struct\", \"structs ({0})\"),\n\t[SymbolKind.Event]: localize(\"event\", \"events ({0})\"),\n\t[SymbolKind.Operator]: localize(\"operator\", \"operators ({0})\"),\n\t[SymbolKind.Interface]: localize(\"interface\", \"interfaces ({0})\"),\n\t[SymbolKind.Namespace]: localize(\"namespace\", \"namespaces ({0})\"),\n\t[SymbolKind.Package]: localize(\"package\", \"packages ({0})\"),\n\t[SymbolKind.TypeParameter]: localize(\n\t\t\"typeParameter\",\n\t\t\"type parameters ({0})\",\n\t),\n\t[SymbolKind.Module]: localize(\"modules\", \"modules ({0})\"),\n\t[SymbolKind.Property]: localize(\"property\", \"properties ({0})\"),\n\t[SymbolKind.Enum]: localize(\"enum\", \"enumerations ({0})\"),\n\t[SymbolKind.EnumMember]: localize(\n\t\t\"enumMember\",\n\t\t\"enumeration members ({0})\",\n\t),\n\t[SymbolKind.String]: localize(\"string\", \"strings ({0})\"),\n\t[SymbolKind.File]: localize(\"file\", \"files ({0})\"),\n\t[SymbolKind.Array]: localize(\"array\", \"arrays ({0})\"),\n\t[SymbolKind.Number]: localize(\"number\", \"numbers ({0})\"),\n\t[SymbolKind.Boolean]: localize(\"boolean\", \"booleans ({0})\"),\n\t[SymbolKind.Object]: localize(\"object\", \"objects ({0})\"),\n\t[SymbolKind.Key]: localize(\"key\", \"keys ({0})\"),\n\t[SymbolKind.Field]: localize(\"field\", \"fields ({0})\"),\n\t[SymbolKind.Constant]: localize(\"constant\", \"constants ({0})\"),\n};\n\n//#endregion\n"],
  "mappings": "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",
  "names": ["updateLastSeparatorLabel"]
}
