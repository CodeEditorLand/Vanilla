import{CancellationToken as p}from"../../../../base/common/cancellation.js";import{illegalArgument as y,onUnexpectedExternalError as L}from"../../../../base/common/errors.js";import{DisposableStore as u}from"../../../../base/common/lifecycle.js";import{assertType as g}from"../../../../base/common/types.js";import{URI as c}from"../../../../base/common/uri.js";import{CommandsRegistry as C}from"../../../../platform/commands/common/commands.js";import{ILanguageFeaturesService as v}from"../../../common/services/languageFeatures.js";import{IModelService as b}from"../../../common/services/model.js";class h{lenses=[];_disposables=new u;dispose(){this._disposables.dispose()}get isDisposed(){return this._disposables.isDisposed}add(n,l){this._disposables.add(n);for(const s of n.lenses)this.lenses.push({symbol:s,provider:l})}}async function P(m,n,l){const s=m.ordered(n),t=new Map,r=new h,a=s.map(async(e,o)=>{t.set(e,o);try{const i=await Promise.resolve(e.provideCodeLenses(n,l));i&&r.add(i,e)}catch(i){L(i)}});return await Promise.all(a),r.lenses=r.lenses.sort((e,o)=>e.symbol.range.startLineNumber<o.symbol.range.startLineNumber?-1:e.symbol.range.startLineNumber>o.symbol.range.startLineNumber?1:t.get(e.provider)<t.get(o.provider)?-1:t.get(e.provider)>t.get(o.provider)?1:e.symbol.range.startColumn<o.symbol.range.startColumn?-1:e.symbol.range.startColumn>o.symbol.range.startColumn?1:0),r}C.registerCommand("_executeCodeLensProvider",(m,...n)=>{let[l,s]=n;g(c.isUri(l)),g(typeof s=="number"||!s);const{codeLensProvider:t}=m.get(v),r=m.get(b).getModel(l);if(!r)throw y();const a=[],e=new u;return P(t,r,p.None).then(o=>{e.add(o);const i=[];for(const d of o.lenses)s==null||d.symbol.command?a.push(d.symbol):s-- >0&&d.provider.resolveCodeLens&&i.push(Promise.resolve(d.provider.resolveCodeLens(r,d.symbol,p.None)).then(f=>a.push(f||d.symbol)));return Promise.all(i)}).then(()=>a).finally(()=>{setTimeout(()=>e.dispose(),100)})});export{h as CodeLensModel,P as getCodeLensModel};
