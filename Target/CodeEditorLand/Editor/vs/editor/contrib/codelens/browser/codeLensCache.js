var f=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var c=(s,e,o,n)=>{for(var t=n>1?void 0:n?h(e,o):e,i=s.length-1,r;i>=0;i--)(r=s[i])&&(t=(n?r(e,o,t):r(t))||t);return n&&t&&f(e,o,t),t},m=(s,e)=>(o,n)=>e(o,n,s);import{runWhenWindowIdle as S}from"../../../../base/browser/dom.js";import{mainWindow as g}from"../../../../base/browser/window.js";import{Event as u}from"../../../../base/common/event.js";import{LRUCache as v}from"../../../../base/common/map.js";import{InstantiationType as I,registerSingleton as L}from"../../../../platform/instantiation/common/extensions.js";import{createDecorator as y}from"../../../../platform/instantiation/common/instantiation.js";import{IStorageService as _,StorageScope as d,StorageTarget as w,WillSaveStateReason as M}from"../../../../platform/storage/common/storage.js";import{Range as b}from"../../../common/core/range.js";import"../../../common/languages.js";import"../../../common/model.js";import{CodeLensModel as C}from"./codelens.js";const x=y("ICodeLensCache");class p{constructor(e,o){this.lineCount=e;this.data=o}}let a=class{_fakeProvider=new class{provideCodeLenses(){throw new Error("not supported")}};_cache=new v(20,.75);constructor(e){const o="codelens/cache";S(g,()=>e.remove(o,d.WORKSPACE));const n="codelens/cache2",t=e.get(n,d.WORKSPACE,"{}");this._deserialize(t);const i=u.filter(e.onWillSaveState,r=>r.reason===M.SHUTDOWN);u.once(i)(r=>{e.store(n,this._serialize(),d.WORKSPACE,w.MACHINE)})}put(e,o){const n=o.lenses.map(r=>({range:r.symbol.range,command:r.symbol.command&&{id:"",title:r.symbol.command?.title}})),t=new C;t.add({lenses:n,dispose:()=>{}},this._fakeProvider);const i=new p(e.getLineCount(),t);this._cache.set(e.uri.toString(),i)}get(e){const o=this._cache.get(e.uri.toString());return o&&o.lineCount===e.getLineCount()?o.data:void 0}delete(e){this._cache.delete(e.uri.toString())}_serialize(){const e=Object.create(null);for(const[o,n]of this._cache){const t=new Set;for(const i of n.data.lenses)t.add(i.symbol.range.startLineNumber);e[o]={lineCount:n.lineCount,lines:[...t.values()]}}return JSON.stringify(e)}_deserialize(e){try{const o=JSON.parse(e);for(const n in o){const t=o[n],i=[];for(const l of t.lines)i.push({range:new b(l,1,l,11)});const r=new C;r.add({lenses:i,dispose(){}},this._fakeProvider),this._cache.set(n,new p(t.lineCount,r))}}catch{}}};a=c([m(0,_)],a),L(x,a,I.Delayed);export{a as CodeLensCache,x as ICodeLensCache};
