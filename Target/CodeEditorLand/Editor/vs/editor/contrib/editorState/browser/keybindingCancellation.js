import{CancellationTokenSource as c}from"../../../../base/common/cancellation.js";import{KeyCode as l}from"../../../../base/common/keyCodes.js";import{LinkedList as k}from"../../../../base/common/linkedList.js";import{localize as p}from"../../../../nls.js";import{IContextKeyService as C,RawContextKey as m}from"../../../../platform/contextkey/common/contextkey.js";import{InstantiationType as u,registerSingleton as y}from"../../../../platform/instantiation/common/extensions.js";import{createDecorator as f}from"../../../../platform/instantiation/common/instantiation.js";import{KeybindingWeight as E}from"../../../../platform/keybinding/common/keybindingsRegistry.js";import"../../../browser/editorBrowser.js";import{EditorCommand as v,registerEditorCommand as I}from"../../../browser/editorExtensions.js";const r=f("IEditorCancelService"),a=new m("cancellableOperation",!1,p("cancellableOperation","Whether the editor runs a cancellable operation, e.g. like 'Peek References'"));y(r,class{_tokens=new WeakMap;add(t,o){let e=this._tokens.get(t);e||(e=t.invokeWithinContext(i=>{const d=a.bindTo(i.get(C)),s=new k;return{key:d,tokens:s}}),this._tokens.set(t,e));let n;return e.key.set(!0),n=e.tokens.push(o),()=>{n&&(n(),e.key.set(!e.tokens.isEmpty()),n=void 0)}}cancel(t){const o=this._tokens.get(t);if(!o)return;const e=o.tokens.pop();e&&(e.cancel(),o.key.set(!o.tokens.isEmpty()))}},u.Delayed);class B extends c{constructor(e,n){super(n);this.editor=e;this._unregister=e.invokeWithinContext(i=>i.get(r).add(e,this))}_unregister;dispose(){this._unregister(),super.dispose()}}I(new class extends v{constructor(){super({id:"editor.cancelOperation",kbOpts:{weight:E.EditorContrib,primary:l.Escape},precondition:a})}runEditorCommand(t,o){t.get(r).cancel(o)}});export{B as EditorKeybindingCancellationTokenSource};
