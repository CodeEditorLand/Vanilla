import{KeyCode as c}from"../../../../base/common/keyCodes.js";import{EditorCommand as l,registerEditorCommand as k}from"../../../browser/editorExtensions.js";import"../../../browser/editorBrowser.js";import{IContextKeyService as p,RawContextKey as C}from"../../../../platform/contextkey/common/contextkey.js";import{KeybindingWeight as m}from"../../../../platform/keybinding/common/keybindingsRegistry.js";import{CancellationTokenSource as u}from"../../../../base/common/cancellation.js";import{LinkedList as y}from"../../../../base/common/linkedList.js";import{createDecorator as f}from"../../../../platform/instantiation/common/instantiation.js";import{InstantiationType as E,registerSingleton as v}from"../../../../platform/instantiation/common/extensions.js";import{localize as I}from"../../../../nls.js";const r=f("IEditorCancelService"),a=new C("cancellableOperation",!1,I("cancellableOperation","Whether the editor runs a cancellable operation, e.g. like 'Peek References'"));v(r,class{_tokens=new WeakMap;add(t,o){let e=this._tokens.get(t);e||(e=t.invokeWithinContext(i=>{const d=a.bindTo(i.get(p)),s=new y;return{key:d,tokens:s}}),this._tokens.set(t,e));let n;return e.key.set(!0),n=e.tokens.push(o),()=>{n&&(n(),e.key.set(!e.tokens.isEmpty()),n=void 0)}}cancel(t){const o=this._tokens.get(t);if(!o)return;const e=o.tokens.pop();e&&(e.cancel(),o.key.set(!o.tokens.isEmpty()))}},E.Delayed);class B extends u{constructor(e,n){super(n);this.editor=e;this._unregister=e.invokeWithinContext(i=>i.get(r).add(e,this))}_unregister;dispose(){this._unregister(),super.dispose()}}k(new class extends l{constructor(){super({id:"editor.cancelOperation",kbOpts:{weight:m.EditorContrib,primary:c.Escape},precondition:a})}runEditorCommand(t,o){t.get(r).cancel(o)}});export{B as EditorKeybindingCancellationTokenSource};
