import{CancellationTokenSource as c}from"../../../../../vs/base/common/cancellation.js";import{KeyCode as l}from"../../../../../vs/base/common/keyCodes.js";import{LinkedList as k}from"../../../../../vs/base/common/linkedList.js";import"../../../../../vs/editor/browser/editorBrowser.js";import{EditorCommand as p,registerEditorCommand as C}from"../../../../../vs/editor/browser/editorExtensions.js";import{localize as m}from"../../../../../vs/nls.js";import{IContextKeyService as u,RawContextKey as y}from"../../../../../vs/platform/contextkey/common/contextkey.js";import{InstantiationType as f,registerSingleton as E}from"../../../../../vs/platform/instantiation/common/extensions.js";import{createDecorator as v}from"../../../../../vs/platform/instantiation/common/instantiation.js";import{KeybindingWeight as I}from"../../../../../vs/platform/keybinding/common/keybindingsRegistry.js";const r=v("IEditorCancelService"),a=new y("cancellableOperation",!1,m("cancellableOperation","Whether the editor runs a cancellable operation, e.g. like 'Peek References'"));E(r,class{_tokens=new WeakMap;add(t,o){let e=this._tokens.get(t);e||(e=t.invokeWithinContext(i=>{const d=a.bindTo(i.get(u)),s=new k;return{key:d,tokens:s}}),this._tokens.set(t,e));let n;return e.key.set(!0),n=e.tokens.push(o),()=>{n&&(n(),e.key.set(!e.tokens.isEmpty()),n=void 0)}}cancel(t){const o=this._tokens.get(t);if(!o)return;const e=o.tokens.pop();e&&(e.cancel(),o.key.set(!o.tokens.isEmpty()))}},f.Delayed);class B extends c{constructor(e,n){super(n);this.editor=e;this._unregister=e.invokeWithinContext(i=>i.get(r).add(e,this))}_unregister;dispose(){this._unregister(),super.dispose()}}C(new class extends p{constructor(){super({id:"editor.cancelOperation",kbOpts:{weight:I.EditorContrib,primary:l.Escape},precondition:a})}runEditorCommand(t,o){t.get(r).cancel(o)}});export{B as EditorKeybindingCancellationTokenSource};
