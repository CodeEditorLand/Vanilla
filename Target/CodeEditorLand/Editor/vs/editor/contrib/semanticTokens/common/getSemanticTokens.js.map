{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/contrib/semanticTokens/common/getSemanticTokens.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { VSBuffer } from \"../../../../base/common/buffer.js\";\nimport { CancellationToken } from \"../../../../base/common/cancellation.js\";\nimport { onUnexpectedExternalError } from \"../../../../base/common/errors.js\";\nimport { assertType } from \"../../../../base/common/types.js\";\nimport { URI } from \"../../../../base/common/uri.js\";\nimport {\n\tCommandsRegistry,\n\tICommandService,\n} from \"../../../../platform/commands/common/commands.js\";\nimport { Range } from \"../../../common/core/range.js\";\nimport type { LanguageFeatureRegistry } from \"../../../common/languageFeatureRegistry.js\";\nimport type {\n\tDocumentRangeSemanticTokensProvider,\n\tDocumentSemanticTokensProvider,\n\tSemanticTokens,\n\tSemanticTokensEdits,\n\tSemanticTokensLegend,\n} from \"../../../common/languages.js\";\nimport type { ITextModel } from \"../../../common/model.js\";\nimport { ILanguageFeaturesService } from \"../../../common/services/languageFeatures.js\";\nimport { IModelService } from \"../../../common/services/model.js\";\nimport { encodeSemanticTokensDto } from \"../../../common/services/semanticTokensDto.js\";\n\nexport function isSemanticTokens(\n\tv: SemanticTokens | SemanticTokensEdits,\n): v is SemanticTokens {\n\treturn v && !!(<SemanticTokens>v).data;\n}\n\nexport function isSemanticTokensEdits(\n\tv: SemanticTokens | SemanticTokensEdits,\n): v is SemanticTokensEdits {\n\treturn v && Array.isArray((<SemanticTokensEdits>v).edits);\n}\n\nexport class DocumentSemanticTokensResult {\n\tconstructor(\n\t\tpublic readonly provider: DocumentSemanticTokensProvider,\n\t\tpublic readonly tokens: SemanticTokens | SemanticTokensEdits | null,\n\t\tpublic readonly error: any,\n\t) {}\n}\n\nexport function hasDocumentSemanticTokensProvider(\n\tregistry: LanguageFeatureRegistry<DocumentSemanticTokensProvider>,\n\tmodel: ITextModel,\n): boolean {\n\treturn registry.has(model);\n}\n\nfunction getDocumentSemanticTokensProviders(\n\tregistry: LanguageFeatureRegistry<DocumentSemanticTokensProvider>,\n\tmodel: ITextModel,\n): DocumentSemanticTokensProvider[] {\n\tconst groups = registry.orderedGroups(model);\n\treturn groups.length > 0 ? groups[0] : [];\n}\n\nexport async function getDocumentSemanticTokens(\n\tregistry: LanguageFeatureRegistry<DocumentSemanticTokensProvider>,\n\tmodel: ITextModel,\n\tlastProvider: DocumentSemanticTokensProvider | null,\n\tlastResultId: string | null,\n\ttoken: CancellationToken,\n): Promise<DocumentSemanticTokensResult | null> {\n\tconst providers = getDocumentSemanticTokensProviders(registry, model);\n\n\t// Get tokens from all providers at the same time.\n\tconst results = await Promise.all(\n\t\tproviders.map(async (provider) => {\n\t\t\tlet result: SemanticTokens | SemanticTokensEdits | null | undefined;\n\t\t\tlet error: any = null;\n\t\t\ttry {\n\t\t\t\tresult = await provider.provideDocumentSemanticTokens(\n\t\t\t\t\tmodel,\n\t\t\t\t\tprovider === lastProvider ? lastResultId : null,\n\t\t\t\t\ttoken,\n\t\t\t\t);\n\t\t\t} catch (err) {\n\t\t\t\terror = err;\n\t\t\t\tresult = null;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t!result ||\n\t\t\t\t(!isSemanticTokens(result) && !isSemanticTokensEdits(result))\n\t\t\t) {\n\t\t\t\tresult = null;\n\t\t\t}\n\n\t\t\treturn new DocumentSemanticTokensResult(provider, result, error);\n\t\t}),\n\t);\n\n\t// Try to return the first result with actual tokens or\n\t// the first result which threw an error (!!)\n\tfor (const result of results) {\n\t\tif (result.error) {\n\t\t\tthrow result.error;\n\t\t}\n\t\tif (result.tokens) {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t// Return the first result, even if it doesn't have tokens\n\tif (results.length > 0) {\n\t\treturn results[0];\n\t}\n\n\treturn null;\n}\n\nfunction _getDocumentSemanticTokensProviderHighestGroup(\n\tregistry: LanguageFeatureRegistry<DocumentSemanticTokensProvider>,\n\tmodel: ITextModel,\n): DocumentSemanticTokensProvider[] | null {\n\tconst result = registry.orderedGroups(model);\n\treturn result.length > 0 ? result[0] : null;\n}\n\nclass DocumentRangeSemanticTokensResult {\n\tconstructor(\n\t\tpublic readonly provider: DocumentRangeSemanticTokensProvider,\n\t\tpublic readonly tokens: SemanticTokens | null,\n\t) {}\n}\n\nexport function hasDocumentRangeSemanticTokensProvider(\n\tproviders: LanguageFeatureRegistry<DocumentRangeSemanticTokensProvider>,\n\tmodel: ITextModel,\n): boolean {\n\treturn providers.has(model);\n}\n\nfunction getDocumentRangeSemanticTokensProviders(\n\tproviders: LanguageFeatureRegistry<DocumentRangeSemanticTokensProvider>,\n\tmodel: ITextModel,\n): DocumentRangeSemanticTokensProvider[] {\n\tconst groups = providers.orderedGroups(model);\n\treturn groups.length > 0 ? groups[0] : [];\n}\n\nexport async function getDocumentRangeSemanticTokens(\n\tregistry: LanguageFeatureRegistry<DocumentRangeSemanticTokensProvider>,\n\tmodel: ITextModel,\n\trange: Range,\n\ttoken: CancellationToken,\n): Promise<DocumentRangeSemanticTokensResult | null> {\n\tconst providers = getDocumentRangeSemanticTokensProviders(registry, model);\n\n\t// Get tokens from all providers at the same time.\n\tconst results = await Promise.all(\n\t\tproviders.map(async (provider) => {\n\t\t\tlet result: SemanticTokens | null | undefined;\n\t\t\ttry {\n\t\t\t\tresult = await provider.provideDocumentRangeSemanticTokens(\n\t\t\t\t\tmodel,\n\t\t\t\t\trange,\n\t\t\t\t\ttoken,\n\t\t\t\t);\n\t\t\t} catch (err) {\n\t\t\t\tonUnexpectedExternalError(err);\n\t\t\t\tresult = null;\n\t\t\t}\n\n\t\t\tif (!result || !isSemanticTokens(result)) {\n\t\t\t\tresult = null;\n\t\t\t}\n\n\t\t\treturn new DocumentRangeSemanticTokensResult(provider, result);\n\t\t}),\n\t);\n\n\t// Try to return the first result with actual tokens\n\tfor (const result of results) {\n\t\tif (result.tokens) {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t// Return the first result, even if it doesn't have tokens\n\tif (results.length > 0) {\n\t\treturn results[0];\n\t}\n\n\treturn null;\n}\n\nCommandsRegistry.registerCommand(\n\t\"_provideDocumentSemanticTokensLegend\",\n\tasync (accessor, ...args): Promise<SemanticTokensLegend | undefined> => {\n\t\tconst [uri] = args;\n\t\tassertType(uri instanceof URI);\n\n\t\tconst model = accessor.get(IModelService).getModel(uri);\n\t\tif (!model) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst { documentSemanticTokensProvider } = accessor.get(\n\t\t\tILanguageFeaturesService,\n\t\t);\n\n\t\tconst providers = _getDocumentSemanticTokensProviderHighestGroup(\n\t\t\tdocumentSemanticTokensProvider,\n\t\t\tmodel,\n\t\t);\n\t\tif (!providers) {\n\t\t\t// there is no provider => fall back to a document range semantic tokens provider\n\t\t\treturn accessor\n\t\t\t\t.get(ICommandService)\n\t\t\t\t.executeCommand(\n\t\t\t\t\t\"_provideDocumentRangeSemanticTokensLegend\",\n\t\t\t\t\turi,\n\t\t\t\t);\n\t\t}\n\n\t\treturn providers[0].getLegend();\n\t},\n);\n\nCommandsRegistry.registerCommand(\n\t\"_provideDocumentSemanticTokens\",\n\tasync (accessor, ...args): Promise<VSBuffer | undefined> => {\n\t\tconst [uri] = args;\n\t\tassertType(uri instanceof URI);\n\n\t\tconst model = accessor.get(IModelService).getModel(uri);\n\t\tif (!model) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst { documentSemanticTokensProvider } = accessor.get(\n\t\t\tILanguageFeaturesService,\n\t\t);\n\t\tif (\n\t\t\t!hasDocumentSemanticTokensProvider(\n\t\t\t\tdocumentSemanticTokensProvider,\n\t\t\t\tmodel,\n\t\t\t)\n\t\t) {\n\t\t\t// there is no provider => fall back to a document range semantic tokens provider\n\t\t\treturn accessor\n\t\t\t\t.get(ICommandService)\n\t\t\t\t.executeCommand(\n\t\t\t\t\t\"_provideDocumentRangeSemanticTokens\",\n\t\t\t\t\turi,\n\t\t\t\t\tmodel.getFullModelRange(),\n\t\t\t\t);\n\t\t}\n\n\t\tconst r = await getDocumentSemanticTokens(\n\t\t\tdocumentSemanticTokensProvider,\n\t\t\tmodel,\n\t\t\tnull,\n\t\t\tnull,\n\t\t\tCancellationToken.None,\n\t\t);\n\t\tif (!r) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst { provider, tokens } = r;\n\n\t\tif (!tokens || !isSemanticTokens(tokens)) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst buff = encodeSemanticTokensDto({\n\t\t\tid: 0,\n\t\t\ttype: \"full\",\n\t\t\tdata: tokens.data,\n\t\t});\n\t\tif (tokens.resultId) {\n\t\t\tprovider.releaseDocumentSemanticTokens(tokens.resultId);\n\t\t}\n\t\treturn buff;\n\t},\n);\n\nCommandsRegistry.registerCommand(\n\t\"_provideDocumentRangeSemanticTokensLegend\",\n\tasync (accessor, ...args): Promise<SemanticTokensLegend | undefined> => {\n\t\tconst [uri, range] = args;\n\t\tassertType(uri instanceof URI);\n\n\t\tconst model = accessor.get(IModelService).getModel(uri);\n\t\tif (!model) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst { documentRangeSemanticTokensProvider } = accessor.get(\n\t\t\tILanguageFeaturesService,\n\t\t);\n\t\tconst providers = getDocumentRangeSemanticTokensProviders(\n\t\t\tdocumentRangeSemanticTokensProvider,\n\t\t\tmodel,\n\t\t);\n\t\tif (providers.length === 0) {\n\t\t\t// no providers\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (providers.length === 1) {\n\t\t\t// straight forward case, just a single provider\n\t\t\treturn providers[0].getLegend();\n\t\t}\n\n\t\tif (!range || !Range.isIRange(range)) {\n\t\t\t// if no range is provided, we cannot support multiple providers\n\t\t\t// as we cannot fall back to the one which would give results\n\t\t\t// => return the first legend for backwards compatibility and print a warning\n\t\t\tconsole.warn(\n\t\t\t\t`provideDocumentRangeSemanticTokensLegend might be out-of-sync with provideDocumentRangeSemanticTokens unless a range argument is passed in`,\n\t\t\t);\n\t\t\treturn providers[0].getLegend();\n\t\t}\n\n\t\tconst result = await getDocumentRangeSemanticTokens(\n\t\t\tdocumentRangeSemanticTokensProvider,\n\t\t\tmodel,\n\t\t\tRange.lift(range),\n\t\t\tCancellationToken.None,\n\t\t);\n\t\tif (!result) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn result.provider.getLegend();\n\t},\n);\n\nCommandsRegistry.registerCommand(\n\t\"_provideDocumentRangeSemanticTokens\",\n\tasync (accessor, ...args): Promise<VSBuffer | undefined> => {\n\t\tconst [uri, range] = args;\n\t\tassertType(uri instanceof URI);\n\t\tassertType(Range.isIRange(range));\n\n\t\tconst model = accessor.get(IModelService).getModel(uri);\n\t\tif (!model) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst { documentRangeSemanticTokensProvider } = accessor.get(\n\t\t\tILanguageFeaturesService,\n\t\t);\n\n\t\tconst result = await getDocumentRangeSemanticTokens(\n\t\t\tdocumentRangeSemanticTokensProvider,\n\t\t\tmodel,\n\t\t\tRange.lift(range),\n\t\t\tCancellationToken.None,\n\t\t);\n\t\tif (!result || !result.tokens) {\n\t\t\t// there is no provider or it didn't return tokens\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn encodeSemanticTokensDto({\n\t\t\tid: 0,\n\t\t\ttype: \"full\",\n\t\t\tdata: result.tokens.data,\n\t\t});\n\t},\n);\n"],
  "mappings": "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",
  "names": []
}
