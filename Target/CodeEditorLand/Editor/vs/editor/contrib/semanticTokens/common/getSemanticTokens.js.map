{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/contrib/semanticTokens/common/getSemanticTokens.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { ITextModel } from '../../../common/model.js';\nimport { DocumentSemanticTokensProvider, SemanticTokens, SemanticTokensEdits, SemanticTokensLegend, DocumentRangeSemanticTokensProvider } from '../../../common/languages.js';\nimport { IModelService } from '../../../common/services/model.js';\nimport { CommandsRegistry, ICommandService } from '../../../../platform/commands/common/commands.js';\nimport { assertType } from '../../../../base/common/types.js';\nimport { VSBuffer } from '../../../../base/common/buffer.js';\nimport { encodeSemanticTokensDto } from '../../../common/services/semanticTokensDto.js';\nimport { Range } from '../../../common/core/range.js';\nimport { LanguageFeatureRegistry } from '../../../common/languageFeatureRegistry.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\n\nexport function isSemanticTokens(v: SemanticTokens | SemanticTokensEdits): v is SemanticTokens {\n\treturn v && !!((<SemanticTokens>v).data);\n}\n\nexport function isSemanticTokensEdits(v: SemanticTokens | SemanticTokensEdits): v is SemanticTokensEdits {\n\treturn v && Array.isArray((<SemanticTokensEdits>v).edits);\n}\n\nexport class DocumentSemanticTokensResult {\n\tconstructor(\n\t\tpublic readonly provider: DocumentSemanticTokensProvider,\n\t\tpublic readonly tokens: SemanticTokens | SemanticTokensEdits | null,\n\t\tpublic readonly error: any\n\t) { }\n}\n\nexport function hasDocumentSemanticTokensProvider(registry: LanguageFeatureRegistry<DocumentSemanticTokensProvider>, model: ITextModel): boolean {\n\treturn registry.has(model);\n}\n\nfunction getDocumentSemanticTokensProviders(registry: LanguageFeatureRegistry<DocumentSemanticTokensProvider>, model: ITextModel): DocumentSemanticTokensProvider[] {\n\tconst groups = registry.orderedGroups(model);\n\treturn (groups.length > 0 ? groups[0] : []);\n}\n\nexport async function getDocumentSemanticTokens(registry: LanguageFeatureRegistry<DocumentSemanticTokensProvider>, model: ITextModel, lastProvider: DocumentSemanticTokensProvider | null, lastResultId: string | null, token: CancellationToken): Promise<DocumentSemanticTokensResult | null> {\n\tconst providers = getDocumentSemanticTokensProviders(registry, model);\n\n\t// Get tokens from all providers at the same time.\n\tconst results = await Promise.all(providers.map(async (provider) => {\n\t\tlet result: SemanticTokens | SemanticTokensEdits | null | undefined;\n\t\tlet error: any = null;\n\t\ttry {\n\t\t\tresult = await provider.provideDocumentSemanticTokens(model, (provider === lastProvider ? lastResultId : null), token);\n\t\t} catch (err) {\n\t\t\terror = err;\n\t\t\tresult = null;\n\t\t}\n\n\t\tif (!result || (!isSemanticTokens(result) && !isSemanticTokensEdits(result))) {\n\t\t\tresult = null;\n\t\t}\n\n\t\treturn new DocumentSemanticTokensResult(provider, result, error);\n\t}));\n\n\t// Try to return the first result with actual tokens or\n\t// the first result which threw an error (!!)\n\tfor (const result of results) {\n\t\tif (result.error) {\n\t\t\tthrow result.error;\n\t\t}\n\t\tif (result.tokens) {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t// Return the first result, even if it doesn't have tokens\n\tif (results.length > 0) {\n\t\treturn results[0];\n\t}\n\n\treturn null;\n}\n\nfunction _getDocumentSemanticTokensProviderHighestGroup(registry: LanguageFeatureRegistry<DocumentSemanticTokensProvider>, model: ITextModel): DocumentSemanticTokensProvider[] | null {\n\tconst result = registry.orderedGroups(model);\n\treturn (result.length > 0 ? result[0] : null);\n}\n\nclass DocumentRangeSemanticTokensResult {\n\tconstructor(\n\t\tpublic readonly provider: DocumentRangeSemanticTokensProvider,\n\t\tpublic readonly tokens: SemanticTokens | null,\n\t) { }\n}\n\nexport function hasDocumentRangeSemanticTokensProvider(providers: LanguageFeatureRegistry<DocumentRangeSemanticTokensProvider>, model: ITextModel): boolean {\n\treturn providers.has(model);\n}\n\nfunction getDocumentRangeSemanticTokensProviders(providers: LanguageFeatureRegistry<DocumentRangeSemanticTokensProvider>, model: ITextModel): DocumentRangeSemanticTokensProvider[] {\n\tconst groups = providers.orderedGroups(model);\n\treturn (groups.length > 0 ? groups[0] : []);\n}\n\nexport async function getDocumentRangeSemanticTokens(registry: LanguageFeatureRegistry<DocumentRangeSemanticTokensProvider>, model: ITextModel, range: Range, token: CancellationToken): Promise<DocumentRangeSemanticTokensResult | null> {\n\tconst providers = getDocumentRangeSemanticTokensProviders(registry, model);\n\n\t// Get tokens from all providers at the same time.\n\tconst results = await Promise.all(providers.map(async (provider) => {\n\t\tlet result: SemanticTokens | null | undefined;\n\t\ttry {\n\t\t\tresult = await provider.provideDocumentRangeSemanticTokens(model, range, token);\n\t\t} catch (err) {\n\t\t\tonUnexpectedExternalError(err);\n\t\t\tresult = null;\n\t\t}\n\n\t\tif (!result || !isSemanticTokens(result)) {\n\t\t\tresult = null;\n\t\t}\n\n\t\treturn new DocumentRangeSemanticTokensResult(provider, result);\n\t}));\n\n\t// Try to return the first result with actual tokens\n\tfor (const result of results) {\n\t\tif (result.tokens) {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t// Return the first result, even if it doesn't have tokens\n\tif (results.length > 0) {\n\t\treturn results[0];\n\t}\n\n\treturn null;\n}\n\nCommandsRegistry.registerCommand('_provideDocumentSemanticTokensLegend', async (accessor, ...args): Promise<SemanticTokensLegend | undefined> => {\n\tconst [uri] = args;\n\tassertType(uri instanceof URI);\n\n\tconst model = accessor.get(IModelService).getModel(uri);\n\tif (!model) {\n\t\treturn undefined;\n\t}\n\tconst { documentSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);\n\n\tconst providers = _getDocumentSemanticTokensProviderHighestGroup(documentSemanticTokensProvider, model);\n\tif (!providers) {\n\t\t// there is no provider => fall back to a document range semantic tokens provider\n\t\treturn accessor.get(ICommandService).executeCommand('_provideDocumentRangeSemanticTokensLegend', uri);\n\t}\n\n\treturn providers[0].getLegend();\n});\n\nCommandsRegistry.registerCommand('_provideDocumentSemanticTokens', async (accessor, ...args): Promise<VSBuffer | undefined> => {\n\tconst [uri] = args;\n\tassertType(uri instanceof URI);\n\n\tconst model = accessor.get(IModelService).getModel(uri);\n\tif (!model) {\n\t\treturn undefined;\n\t}\n\tconst { documentSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);\n\tif (!hasDocumentSemanticTokensProvider(documentSemanticTokensProvider, model)) {\n\t\t// there is no provider => fall back to a document range semantic tokens provider\n\t\treturn accessor.get(ICommandService).executeCommand('_provideDocumentRangeSemanticTokens', uri, model.getFullModelRange());\n\t}\n\n\tconst r = await getDocumentSemanticTokens(documentSemanticTokensProvider, model, null, null, CancellationToken.None);\n\tif (!r) {\n\t\treturn undefined;\n\t}\n\n\tconst { provider, tokens } = r;\n\n\tif (!tokens || !isSemanticTokens(tokens)) {\n\t\treturn undefined;\n\t}\n\n\tconst buff = encodeSemanticTokensDto({\n\t\tid: 0,\n\t\ttype: 'full',\n\t\tdata: tokens.data\n\t});\n\tif (tokens.resultId) {\n\t\tprovider.releaseDocumentSemanticTokens(tokens.resultId);\n\t}\n\treturn buff;\n});\n\nCommandsRegistry.registerCommand('_provideDocumentRangeSemanticTokensLegend', async (accessor, ...args): Promise<SemanticTokensLegend | undefined> => {\n\tconst [uri, range] = args;\n\tassertType(uri instanceof URI);\n\n\tconst model = accessor.get(IModelService).getModel(uri);\n\tif (!model) {\n\t\treturn undefined;\n\t}\n\tconst { documentRangeSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);\n\tconst providers = getDocumentRangeSemanticTokensProviders(documentRangeSemanticTokensProvider, model);\n\tif (providers.length === 0) {\n\t\t// no providers\n\t\treturn undefined;\n\t}\n\n\tif (providers.length === 1) {\n\t\t// straight forward case, just a single provider\n\t\treturn providers[0].getLegend();\n\t}\n\n\tif (!range || !Range.isIRange(range)) {\n\t\t// if no range is provided, we cannot support multiple providers\n\t\t// as we cannot fall back to the one which would give results\n\t\t// => return the first legend for backwards compatibility and print a warning\n\t\tconsole.warn(`provideDocumentRangeSemanticTokensLegend might be out-of-sync with provideDocumentRangeSemanticTokens unless a range argument is passed in`);\n\t\treturn providers[0].getLegend();\n\t}\n\n\tconst result = await getDocumentRangeSemanticTokens(documentRangeSemanticTokensProvider, model, Range.lift(range), CancellationToken.None);\n\tif (!result) {\n\t\treturn undefined;\n\t}\n\n\treturn result.provider.getLegend();\n});\n\nCommandsRegistry.registerCommand('_provideDocumentRangeSemanticTokens', async (accessor, ...args): Promise<VSBuffer | undefined> => {\n\tconst [uri, range] = args;\n\tassertType(uri instanceof URI);\n\tassertType(Range.isIRange(range));\n\n\tconst model = accessor.get(IModelService).getModel(uri);\n\tif (!model) {\n\t\treturn undefined;\n\t}\n\tconst { documentRangeSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);\n\n\tconst result = await getDocumentRangeSemanticTokens(documentRangeSemanticTokensProvider, model, Range.lift(range), CancellationToken.None);\n\tif (!result || !result.tokens) {\n\t\t// there is no provider or it didn't return tokens\n\t\treturn undefined;\n\t}\n\n\treturn encodeSemanticTokensDto({\n\t\tid: 0,\n\t\ttype: 'full',\n\t\tdata: result.tokens.data\n\t});\n});\n"],
  "mappings": "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",
  "names": []
}
