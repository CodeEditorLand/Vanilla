import{CancellationToken as T}from"../../../../base/common/cancellation.js";import{onUnexpectedExternalError as P}from"../../../../base/common/errors.js";import{URI as m}from"../../../../base/common/uri.js";import{IModelService as d}from"../../../common/services/model.js";import{CommandsRegistry as l,ICommandService as p}from"../../../../platform/commands/common/commands.js";import{assertType as c}from"../../../../base/common/types.js";import{encodeSemanticTokensDto as v}from"../../../common/services/semanticTokensDto.js";import{Range as g}from"../../../common/core/range.js";import{ILanguageFeaturesService as f}from"../../../common/services/languageFeatures.js";function k(e){return e&&!!e.data}function L(e){return e&&Array.isArray(e.edits)}class x{constructor(t,n,i){this.provider=t;this.tokens=n;this.error=i}}function h(e,t){return e.has(t)}function I(e,t){const n=e.orderedGroups(t);return n.length>0?n[0]:[]}async function M(e,t,n,i,s){const a=I(e,t),r=await Promise.all(a.map(async o=>{let u,S=null;try{u=await o.provideDocumentSemanticTokens(t,o===n?i:null,s)}catch(y){S=y,u=null}return(!u||!k(u)&&!L(u))&&(u=null),new x(o,u,S)}));for(const o of r){if(o.error)throw o.error;if(o.tokens)return o}return r.length>0?r[0]:null}function w(e,t){const n=e.orderedGroups(t);return n.length>0?n[0]:null}class C{constructor(t,n){this.provider=t;this.tokens=n}}function Z(e,t){return e.has(t)}function R(e,t){const n=e.orderedGroups(t);return n.length>0?n[0]:[]}async function D(e,t,n,i){const s=R(e,t),a=await Promise.all(s.map(async r=>{let o;try{o=await r.provideDocumentRangeSemanticTokens(t,n,i)}catch(u){P(u),o=null}return(!o||!k(o))&&(o=null),new C(r,o)}));for(const r of a)if(r.tokens)return r;return a.length>0?a[0]:null}l.registerCommand("_provideDocumentSemanticTokensLegend",async(e,...t)=>{const[n]=t;c(n instanceof m);const i=e.get(d).getModel(n);if(!i)return;const{documentSemanticTokensProvider:s}=e.get(f),a=w(s,i);return a?a[0].getLegend():e.get(p).executeCommand("_provideDocumentRangeSemanticTokensLegend",n)}),l.registerCommand("_provideDocumentSemanticTokens",async(e,...t)=>{const[n]=t;c(n instanceof m);const i=e.get(d).getModel(n);if(!i)return;const{documentSemanticTokensProvider:s}=e.get(f);if(!h(s,i))return e.get(p).executeCommand("_provideDocumentRangeSemanticTokens",n,i.getFullModelRange());const a=await M(s,i,null,null,T.None);if(!a)return;const{provider:r,tokens:o}=a;if(!o||!k(o))return;const u=v({id:0,type:"full",data:o.data});return o.resultId&&r.releaseDocumentSemanticTokens(o.resultId),u}),l.registerCommand("_provideDocumentRangeSemanticTokensLegend",async(e,...t)=>{const[n,i]=t;c(n instanceof m);const s=e.get(d).getModel(n);if(!s)return;const{documentRangeSemanticTokensProvider:a}=e.get(f),r=R(a,s);if(r.length===0)return;if(r.length===1)return r[0].getLegend();if(!i||!g.isIRange(i))return console.warn("provideDocumentRangeSemanticTokensLegend might be out-of-sync with provideDocumentRangeSemanticTokens unless a range argument is passed in"),r[0].getLegend();const o=await D(a,s,g.lift(i),T.None);if(o)return o.provider.getLegend()}),l.registerCommand("_provideDocumentRangeSemanticTokens",async(e,...t)=>{const[n,i]=t;c(n instanceof m),c(g.isIRange(i));const s=e.get(d).getModel(n);if(!s)return;const{documentRangeSemanticTokensProvider:a}=e.get(f),r=await D(a,s,g.lift(i),T.None);if(!(!r||!r.tokens))return v({id:0,type:"full",data:r.tokens.data})});export{x as DocumentSemanticTokensResult,D as getDocumentRangeSemanticTokens,M as getDocumentSemanticTokens,Z as hasDocumentRangeSemanticTokensProvider,h as hasDocumentSemanticTokensProvider,k as isSemanticTokens,L as isSemanticTokensEdits};
