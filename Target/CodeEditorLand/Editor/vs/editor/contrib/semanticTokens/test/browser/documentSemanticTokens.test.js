import t from"assert";import{Barrier as k,timeout as m}from"../../../../../base/common/async.js";import{CancellationToken as g}from"../../../../../base/common/cancellation.js";import{Emitter as f,Event as S}from"../../../../../base/common/event.js";import{DisposableStore as w}from"../../../../../base/common/lifecycle.js";import{mock as M}from"../../../../../base/test/common/mock.js";import{runWithFakedTimers as u}from"../../../../../base/test/common/timeTravelScheduler.js";import{ensureNoDisposablesAreLeakedInTestSuite as y}from"../../../../../base/test/common/utils.js";import{Range as T}from"../../../../common/core/range.js";import"../../../../common/languages.js";import{ILanguageService as h}from"../../../../common/languages/language.js";import{ILanguageConfigurationService as I}from"../../../../common/languages/languageConfigurationRegistry.js";import"../../../../common/model.js";import{LanguageFeatureDebounceService as D}from"../../../../common/services/languageFeatureDebounce.js";import"../../../../common/services/languageFeatures.js";import{LanguageFeaturesService as L}from"../../../../common/services/languageFeaturesService.js";import{LanguageService as C}from"../../../../common/services/languageService.js";import"../../../../common/services/model.js";import{ModelService as E}from"../../../../common/services/modelService.js";import{SemanticTokensStylingService as P}from"../../../../common/services/semanticTokensStylingService.js";import{DocumentSemanticTokensFeature as x}from"../../browser/documentSemanticTokens.js";import{getDocumentSemanticTokens as p,isSemanticTokens as v}from"../../common/getSemanticTokens.js";import{TestLanguageConfigurationService as b}from"../../../../test/common/modes/testLanguageConfigurationService.js";import{TestTextResourcePropertiesService as q}from"../../../../test/common/services/testTextResourcePropertiesService.js";import{TestConfigurationService as A}from"../../../../../platform/configuration/test/common/testConfigurationService.js";import{TestDialogService as R}from"../../../../../platform/dialogs/test/common/testDialogService.js";import"../../../../../platform/environment/common/environment.js";import{TestInstantiationService as B}from"../../../../../platform/instantiation/test/common/instantiationServiceMock.js";import{NullLogService as F}from"../../../../../platform/log/common/log.js";import{TestNotificationService as U}from"../../../../../platform/notification/test/common/testNotificationService.js";import{ColorScheme as N}from"../../../../../platform/theme/common/theme.js";import{TestColorTheme as H,TestThemeService as W}from"../../../../../platform/theme/test/common/testThemeService.js";import{UndoRedoService as K}from"../../../../../platform/undoRedo/common/undoRedoService.js";suite("ModelSemanticColoring",()=>{const o=new w;let c,a,l;setup(()=>{const n=new A({editor:{semanticHighlighting:!0}}),r=new W;r.setTheme(new H({},N.DARK,!0));const s=new F;l=new L,a=o.add(new C(!1));const e=o.add(new P(r,s,a)),i=new B;i.set(h,a),i.set(I,new b),c=o.add(new E(n,new q(n),new K(new R,new U),i));const d=new class extends M(){isBuilt=!0;isExtensionDevelopment=!1};o.add(new x(e,c,r,n,new D(s,d),l))}),teardown(()=>{o.clear()}),y(),test("DocumentSemanticTokens should be fetched when the result is empty if there are pending changes",async()=>{await u({},async()=>{o.add(a.registerLanguage({id:"testMode"}));const n=new k,r=new k,s=new k;let e=0;o.add(l.documentSemanticTokensProvider.register("testMode",new class{getLegend(){return{tokenTypes:["class"],tokenModifiers:[]}}async provideDocumentSemanticTokens(d,V,j){if(e++,e===1)return t.ok("called once"),n.open(),await r.wait(),await m(0),null;if(e===2)return t.ok("called twice"),s.open(),null;t.fail("Unexpected call")}releaseDocumentSemanticTokens(d){}}));const i=o.add(c.createModel("Hello world",a.createById("testMode")));i.onBeforeAttached(),await n.wait(),i.applyEdits([{range:new T(1,1,1,1),text:"x"}]),r.open(),await s.wait(),t.strictEqual(e,2)})}),test("issue #149412: VS Code hangs when bad semantic token data is received",async()=>{await u({},async()=>{o.add(a.registerLanguage({id:"testMode"}));let n=null;o.add(l.documentSemanticTokensProvider.register("testMode",new class{getLegend(){return{tokenTypes:["class"],tokenModifiers:[]}}async provideDocumentSemanticTokens(s,e,i){return e?n={resultId:"2",edits:[{start:4294967276,deleteCount:0,data:new Uint32Array([2,0,3,11,0])}]}:n={resultId:"1",data:new Uint32Array([4294967293,0,7,16,0,1,4,3,11,1])},n}releaseDocumentSemanticTokens(s){}}));const r=o.add(c.createModel("",a.createById("testMode")));r.onBeforeAttached(),await S.toPromise(r.onDidChangeTokens),t.strictEqual(n.resultId,"1"),r.applyEdits([{range:new T(1,1,1,1),text:"foo"}]),await S.toPromise(r.onDidChangeTokens),t.strictEqual(n.resultId,"2")})}),test("issue #161573: onDidChangeSemanticTokens doesn't consistently trigger provideDocumentSemanticTokens",async()=>{await u({},async()=>{o.add(a.registerLanguage({id:"testMode"}));const n=new f;let r=0;o.add(l.documentSemanticTokensProvider.register("testMode",new class{onDidChange=n.event;getLegend(){return{tokenTypes:["class"],tokenModifiers:[]}}async provideDocumentSemanticTokens(e,i,d){return r++,r===1&&(await m(1e3),n.fire(),await m(1e3)),null}releaseDocumentSemanticTokens(e){}})),o.add(c.createModel("",a.createById("testMode"))).onBeforeAttached(),await m(5e3),t.deepStrictEqual(r,2)})}),test("DocumentSemanticTokens should be pick the token provider with actual items",async()=>{await u({},async()=>{let n=0;o.add(a.registerLanguage({id:"testMode2"})),o.add(l.documentSemanticTokensProvider.register("testMode2",new class{getLegend(){return{tokenTypes:["class1"],tokenModifiers:[]}}async provideDocumentSemanticTokens(e,i,d){return n++,i?{data:new Uint32Array([2,1,1,1,1,0,2,1,1,1])}:{resultId:"1",data:new Uint32Array([0,1,1,1,1,0,2,1,1,1])}}releaseDocumentSemanticTokens(e){}})),o.add(l.documentSemanticTokensProvider.register("testMode2",new class{getLegend(){return{tokenTypes:["class2"],tokenModifiers:[]}}async provideDocumentSemanticTokens(e,i,d){return n++,null}releaseDocumentSemanticTokens(e){}}));function r(e){const i=[];for(let d=0;d<e.length;d++)i[d]=e[d];return i}const s=c.createModel("Hello world 2",a.createById("testMode2"));try{let e=await p(l.documentSemanticTokensProvider,s,null,null,g.None);t.ok(e,"We should have tokens (1)"),t.ok(e.tokens,"Tokens are found from multiple providers (1)"),t.ok(v(e.tokens),"Tokens are full (1)"),t.ok(e.tokens.resultId,"Token result id found from multiple providers (1)"),t.deepStrictEqual(r(e.tokens.data),[0,1,1,1,1,0,2,1,1,1],"Token data returned for multiple providers (1)"),t.deepStrictEqual(n,2,"Called both token providers (1)"),t.deepStrictEqual(e.provider.getLegend(),{tokenTypes:["class1"],tokenModifiers:[]},"Legend matches the tokens (1)"),e=await p(l.documentSemanticTokensProvider,s,e.provider,e.tokens.resultId,g.None),t.ok(e,"We should have tokens (2)"),t.ok(e.tokens,"Tokens are found from multiple providers (2)"),t.ok(v(e.tokens),"Tokens are full (2)"),t.ok(!e.tokens.resultId,"Token result id found from multiple providers (2)"),t.deepStrictEqual(r(e.tokens.data),[2,1,1,1,1,0,2,1,1,1],"Token data returned for multiple providers (2)"),t.deepStrictEqual(n,4,"Called both token providers (2)"),t.deepStrictEqual(e.provider.getLegend(),{tokenTypes:["class1"],tokenModifiers:[]},"Legend matches the tokens (2)")}finally{o.clear(),await m(0),s.dispose()}})})});
