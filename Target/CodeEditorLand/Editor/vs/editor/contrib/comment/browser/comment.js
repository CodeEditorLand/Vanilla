import{KeyChord as h,KeyCode as r,KeyMod as t}from"../../../../base/common/keyCodes.js";import*as m from"../../../../nls.js";import{MenuId as x}from"../../../../platform/actions/common/actions.js";import{KeybindingWeight as C}from"../../../../platform/keybinding/common/keybindingsRegistry.js";import{EditorAction as A,registerEditorAction as g}from"../../../browser/editorExtensions.js";import{EditorOption as S}from"../../../common/config/editorOptions.js";import{Range as E}from"../../../common/core/range.js";import{EditorContextKeys as i}from"../../../common/editorContextKeys.js";import{ILanguageConfigurationService as k}from"../../../common/languages/languageConfigurationRegistry.js";import{BlockCommentCommand as T}from"./blockCommentCommand.js";import{LineCommentCommand as v,Type as f}from"./lineCommentCommand.js";class L extends A{_type;constructor(s,e){super(e),this._type=s}run(s,e){const u=s.get(k);if(!e.hasModel())return;const b=e.getModel(),c=[],y=b.getOptions(),a=e.getOption(S.comments),l=e.getSelections().map((o,n)=>({selection:o,index:n,ignoreFirstLine:!1}));l.sort((o,n)=>E.compareRangesUsingStarts(o.selection,n.selection));let p=l[0];for(let o=1;o<l.length;o++){const n=l[o];p.selection.endLineNumber===n.selection.startLineNumber&&(p.index<n.index?n.ignoreFirstLine=!0:(p.ignoreFirstLine=!0,p=n))}for(const o of l)c.push(new v(u,o.selection,y.indentSize,this._type,a.insertSpace,a.ignoreEmptyLines,o.ignoreFirstLine));e.pushUndoStop(),e.executeCommands(this.id,c),e.pushUndoStop()}}class O extends L{constructor(){super(f.Toggle,{id:"editor.action.commentLine",label:m.localize("comment.line","Toggle Line Comment"),alias:"Toggle Line Comment",precondition:i.writable,kbOpts:{kbExpr:i.editorTextFocus,primary:t.CtrlCmd|r.Slash,weight:C.EditorContrib},menuOpts:{menuId:x.MenubarEditMenu,group:"5_insert",title:m.localize({key:"miToggleLineComment",comment:["&& denotes a mnemonic"]},"&&Toggle Line Comment"),order:1}})}}class K extends L{constructor(){super(f.ForceAdd,{id:"editor.action.addCommentLine",label:m.localize("comment.line.add","Add Line Comment"),alias:"Add Line Comment",precondition:i.writable,kbOpts:{kbExpr:i.editorTextFocus,primary:h(t.CtrlCmd|r.KeyK,t.CtrlCmd|r.KeyC),weight:C.EditorContrib}})}}class w extends L{constructor(){super(f.ForceRemove,{id:"editor.action.removeCommentLine",label:m.localize("comment.line.remove","Remove Line Comment"),alias:"Remove Line Comment",precondition:i.writable,kbOpts:{kbExpr:i.editorTextFocus,primary:h(t.CtrlCmd|r.KeyK,t.CtrlCmd|r.KeyU),weight:C.EditorContrib}})}}class I extends A{constructor(){super({id:"editor.action.blockComment",label:m.localize("comment.block","Toggle Block Comment"),alias:"Toggle Block Comment",precondition:i.writable,kbOpts:{kbExpr:i.editorTextFocus,primary:t.Shift|t.Alt|r.KeyA,linux:{primary:t.CtrlCmd|t.Shift|r.KeyA},weight:C.EditorContrib},menuOpts:{menuId:x.MenubarEditMenu,group:"5_insert",title:m.localize({key:"miToggleBlockComment",comment:["&& denotes a mnemonic"]},"Toggle &&Block Comment"),order:2}})}run(s,e){const u=s.get(k);if(!e.hasModel())return;const b=e.getOption(S.comments),c=[],y=e.getSelections();for(const a of y)c.push(new T(a,b.insertSpace,u));e.pushUndoStop(),e.executeCommands(this.id,c),e.pushUndoStop()}}g(O),g(K),g(w),g(I);
