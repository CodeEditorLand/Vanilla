{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/contrib/comment/browser/lineCommentCommand.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../../base/common/charCode.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { Constants } from '../../../../base/common/uint.js';\nimport { EditOperation, ISingleEditOperation } from '../../../common/core/editOperation.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { ICommand, ICursorStateComputerData, IEditOperationBuilder } from '../../../common/editorCommon.js';\nimport { ITextModel } from '../../../common/model.js';\nimport { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry.js';\nimport { BlockCommentCommand } from './blockCommentCommand.js';\n\nexport interface IInsertionPoint {\n\tignore: boolean;\n\tcommentStrOffset: number;\n}\n\nexport interface ILinePreflightData {\n\tignore: boolean;\n\tcommentStr: string;\n\tcommentStrOffset: number;\n\tcommentStrLength: number;\n}\n\nexport interface IPreflightDataSupported {\n\tsupported: true;\n\tshouldRemoveComments: boolean;\n\tlines: ILinePreflightData[];\n}\nexport interface IPreflightDataUnsupported {\n\tsupported: false;\n}\nexport type IPreflightData = IPreflightDataSupported | IPreflightDataUnsupported;\n\nexport interface ISimpleModel {\n\tgetLineContent(lineNumber: number): string;\n}\n\nexport const enum Type {\n\tToggle = 0,\n\tForceAdd = 1,\n\tForceRemove = 2\n}\n\nexport class LineCommentCommand implements ICommand {\n\n\tprivate readonly _selection: Selection;\n\tprivate readonly _indentSize: number;\n\tprivate readonly _type: Type;\n\tprivate readonly _insertSpace: boolean;\n\tprivate readonly _ignoreEmptyLines: boolean;\n\tprivate _selectionId: string | null;\n\tprivate _deltaColumn: number;\n\tprivate _moveEndPositionDown: boolean;\n\tprivate _ignoreFirstLine: boolean;\n\n\tconstructor(\n\t\tprivate readonly languageConfigurationService: ILanguageConfigurationService,\n\t\tselection: Selection,\n\t\tindentSize: number,\n\t\ttype: Type,\n\t\tinsertSpace: boolean,\n\t\tignoreEmptyLines: boolean,\n\t\tignoreFirstLine?: boolean,\n\t) {\n\t\tthis._selection = selection;\n\t\tthis._indentSize = indentSize;\n\t\tthis._type = type;\n\t\tthis._insertSpace = insertSpace;\n\t\tthis._selectionId = null;\n\t\tthis._deltaColumn = 0;\n\t\tthis._moveEndPositionDown = false;\n\t\tthis._ignoreEmptyLines = ignoreEmptyLines;\n\t\tthis._ignoreFirstLine = ignoreFirstLine || false;\n\t}\n\n\t/**\n\t * Do an initial pass over the lines and gather info about the line comment string.\n\t * Returns null if any of the lines doesn't support a line comment string.\n\t */\n\tprivate static _gatherPreflightCommentStrings(model: ITextModel, startLineNumber: number, endLineNumber: number, languageConfigurationService: ILanguageConfigurationService): ILinePreflightData[] | null {\n\n\t\tmodel.tokenization.tokenizeIfCheap(startLineNumber);\n\t\tconst languageId = model.getLanguageIdAtPosition(startLineNumber, 1);\n\n\t\tconst config = languageConfigurationService.getLanguageConfiguration(languageId).comments;\n\t\tconst commentStr = (config ? config.lineCommentToken : null);\n\t\tif (!commentStr) {\n\t\t\t// Mode does not support line comments\n\t\t\treturn null;\n\t\t}\n\n\t\tconst lines: ILinePreflightData[] = [];\n\t\tfor (let i = 0, lineCount = endLineNumber - startLineNumber + 1; i < lineCount; i++) {\n\t\t\tlines[i] = {\n\t\t\t\tignore: false,\n\t\t\t\tcommentStr: commentStr,\n\t\t\t\tcommentStrOffset: 0,\n\t\t\t\tcommentStrLength: commentStr.length\n\t\t\t};\n\t\t}\n\n\t\treturn lines;\n\t}\n\n\t/**\n\t * Analyze lines and decide which lines are relevant and what the toggle should do.\n\t * Also, build up several offsets and lengths useful in the generation of editor operations.\n\t */\n\tpublic static _analyzeLines(type: Type, insertSpace: boolean, model: ISimpleModel, lines: ILinePreflightData[], startLineNumber: number, ignoreEmptyLines: boolean, ignoreFirstLine: boolean, languageConfigurationService: ILanguageConfigurationService): IPreflightData {\n\t\tlet onlyWhitespaceLines = true;\n\n\t\tlet shouldRemoveComments: boolean;\n\t\tif (type === Type.Toggle) {\n\t\t\tshouldRemoveComments = true;\n\t\t} else if (type === Type.ForceAdd) {\n\t\t\tshouldRemoveComments = false;\n\t\t} else {\n\t\t\tshouldRemoveComments = true;\n\t\t}\n\n\t\tfor (let i = 0, lineCount = lines.length; i < lineCount; i++) {\n\t\t\tconst lineData = lines[i];\n\t\t\tconst lineNumber = startLineNumber + i;\n\n\t\t\tif (lineNumber === startLineNumber && ignoreFirstLine) {\n\t\t\t\t// first line ignored\n\t\t\t\tlineData.ignore = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst lineContent = model.getLineContent(lineNumber);\n\t\t\tconst lineContentStartOffset = strings.firstNonWhitespaceIndex(lineContent);\n\n\t\t\tif (lineContentStartOffset === -1) {\n\t\t\t\t// Empty or whitespace only line\n\t\t\t\tlineData.ignore = ignoreEmptyLines;\n\t\t\t\tlineData.commentStrOffset = lineContent.length;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tonlyWhitespaceLines = false;\n\t\t\tlineData.ignore = false;\n\t\t\tlineData.commentStrOffset = lineContentStartOffset;\n\n\t\t\tif (shouldRemoveComments && !BlockCommentCommand._haystackHasNeedleAtOffset(lineContent, lineData.commentStr, lineContentStartOffset)) {\n\t\t\t\tif (type === Type.Toggle) {\n\t\t\t\t\t// Every line so far has been a line comment, but this one is not\n\t\t\t\t\tshouldRemoveComments = false;\n\t\t\t\t} else if (type === Type.ForceAdd) {\n\t\t\t\t\t// Will not happen\n\t\t\t\t} else {\n\t\t\t\t\tlineData.ignore = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (shouldRemoveComments && insertSpace) {\n\t\t\t\t// Remove a following space if present\n\t\t\t\tconst commentStrEndOffset = lineContentStartOffset + lineData.commentStrLength;\n\t\t\t\tif (commentStrEndOffset < lineContent.length && lineContent.charCodeAt(commentStrEndOffset) === CharCode.Space) {\n\t\t\t\t\tlineData.commentStrLength += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (type === Type.Toggle && onlyWhitespaceLines) {\n\t\t\t// For only whitespace lines, we insert comments\n\t\t\tshouldRemoveComments = false;\n\n\t\t\t// Also, no longer ignore them\n\t\t\tfor (let i = 0, lineCount = lines.length; i < lineCount; i++) {\n\t\t\t\tlines[i].ignore = false;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tsupported: true,\n\t\t\tshouldRemoveComments: shouldRemoveComments,\n\t\t\tlines: lines\n\t\t};\n\t}\n\n\t/**\n\t * Analyze all lines and decide exactly what to do => not supported | insert line comments | remove line comments\n\t */\n\tpublic static _gatherPreflightData(type: Type, insertSpace: boolean, model: ITextModel, startLineNumber: number, endLineNumber: number, ignoreEmptyLines: boolean, ignoreFirstLine: boolean, languageConfigurationService: ILanguageConfigurationService): IPreflightData {\n\t\tconst lines = LineCommentCommand._gatherPreflightCommentStrings(model, startLineNumber, endLineNumber, languageConfigurationService);\n\t\tif (lines === null) {\n\t\t\treturn {\n\t\t\t\tsupported: false\n\t\t\t};\n\t\t}\n\n\t\treturn LineCommentCommand._analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService);\n\t}\n\n\t/**\n\t * Given a successful analysis, execute either insert line comments, either remove line comments\n\t */\n\tprivate _executeLineComments(model: ISimpleModel, builder: IEditOperationBuilder, data: IPreflightDataSupported, s: Selection): void {\n\n\t\tlet ops: ISingleEditOperation[];\n\n\t\tif (data.shouldRemoveComments) {\n\t\t\tops = LineCommentCommand._createRemoveLineCommentsOperations(data.lines, s.startLineNumber);\n\t\t} else {\n\t\t\tLineCommentCommand._normalizeInsertionPoint(model, data.lines, s.startLineNumber, this._indentSize);\n\t\t\tops = this._createAddLineCommentsOperations(data.lines, s.startLineNumber);\n\t\t}\n\n\t\tconst cursorPosition = new Position(s.positionLineNumber, s.positionColumn);\n\n\t\tfor (let i = 0, len = ops.length; i < len; i++) {\n\t\t\tbuilder.addEditOperation(ops[i].range, ops[i].text);\n\t\t\tif (Range.isEmpty(ops[i].range) && Range.getStartPosition(ops[i].range).equals(cursorPosition)) {\n\t\t\t\tconst lineContent = model.getLineContent(cursorPosition.lineNumber);\n\t\t\t\tif (lineContent.length + 1 === cursorPosition.column) {\n\t\t\t\t\tthis._deltaColumn = (ops[i].text || '').length;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._selectionId = builder.trackSelection(s);\n\t}\n\n\tprivate _attemptRemoveBlockComment(model: ITextModel, s: Selection, startToken: string, endToken: string): ISingleEditOperation[] | null {\n\t\tlet startLineNumber = s.startLineNumber;\n\t\tlet endLineNumber = s.endLineNumber;\n\n\t\tconst startTokenAllowedBeforeColumn = endToken.length + Math.max(\n\t\t\tmodel.getLineFirstNonWhitespaceColumn(s.startLineNumber),\n\t\t\ts.startColumn\n\t\t);\n\n\t\tlet startTokenIndex = model.getLineContent(startLineNumber).lastIndexOf(startToken, startTokenAllowedBeforeColumn - 1);\n\t\tlet endTokenIndex = model.getLineContent(endLineNumber).indexOf(endToken, s.endColumn - 1 - startToken.length);\n\n\t\tif (startTokenIndex !== -1 && endTokenIndex === -1) {\n\t\t\tendTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n\t\t\tendLineNumber = startLineNumber;\n\t\t}\n\n\t\tif (startTokenIndex === -1 && endTokenIndex !== -1) {\n\t\t\tstartTokenIndex = model.getLineContent(endLineNumber).lastIndexOf(startToken, endTokenIndex);\n\t\t\tstartLineNumber = endLineNumber;\n\t\t}\n\n\t\tif (s.isEmpty() && (startTokenIndex === -1 || endTokenIndex === -1)) {\n\t\t\tstartTokenIndex = model.getLineContent(startLineNumber).indexOf(startToken);\n\t\t\tif (startTokenIndex !== -1) {\n\t\t\t\tendTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n\t\t\t}\n\t\t}\n\n\t\t// We have to adjust to possible inner white space.\n\t\t// For Space after startToken, add Space to startToken - range math will work out.\n\t\tif (startTokenIndex !== -1 && model.getLineContent(startLineNumber).charCodeAt(startTokenIndex + startToken.length) === CharCode.Space) {\n\t\t\tstartToken += ' ';\n\t\t}\n\n\t\t// For Space before endToken, add Space before endToken and shift index one left.\n\t\tif (endTokenIndex !== -1 && model.getLineContent(endLineNumber).charCodeAt(endTokenIndex - 1) === CharCode.Space) {\n\t\t\tendToken = ' ' + endToken;\n\t\t\tendTokenIndex -= 1;\n\t\t}\n\n\t\tif (startTokenIndex !== -1 && endTokenIndex !== -1) {\n\t\t\treturn BlockCommentCommand._createRemoveBlockCommentOperations(\n\t\t\t\tnew Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken\n\t\t\t);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Given an unsuccessful analysis, delegate to the block comment command\n\t */\n\tprivate _executeBlockComment(model: ITextModel, builder: IEditOperationBuilder, s: Selection): void {\n\t\tmodel.tokenization.tokenizeIfCheap(s.startLineNumber);\n\t\tconst languageId = model.getLanguageIdAtPosition(s.startLineNumber, 1);\n\t\tconst config = this.languageConfigurationService.getLanguageConfiguration(languageId).comments;\n\t\tif (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {\n\t\t\t// Mode does not support block comments\n\t\t\treturn;\n\t\t}\n\n\t\tconst startToken = config.blockCommentStartToken;\n\t\tconst endToken = config.blockCommentEndToken;\n\n\t\tlet ops = this._attemptRemoveBlockComment(model, s, startToken, endToken);\n\t\tif (!ops) {\n\t\t\tif (s.isEmpty()) {\n\t\t\t\tconst lineContent = model.getLineContent(s.startLineNumber);\n\t\t\t\tlet firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n\t\t\t\tif (firstNonWhitespaceIndex === -1) {\n\t\t\t\t\t// Line is empty or contains only whitespace\n\t\t\t\t\tfirstNonWhitespaceIndex = lineContent.length;\n\t\t\t\t}\n\t\t\t\tops = BlockCommentCommand._createAddBlockCommentOperations(\n\t\t\t\t\tnew Range(s.startLineNumber, firstNonWhitespaceIndex + 1, s.startLineNumber, lineContent.length + 1),\n\t\t\t\t\tstartToken,\n\t\t\t\t\tendToken,\n\t\t\t\t\tthis._insertSpace\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tops = BlockCommentCommand._createAddBlockCommentOperations(\n\t\t\t\t\tnew Range(s.startLineNumber, model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)),\n\t\t\t\t\tstartToken,\n\t\t\t\t\tendToken,\n\t\t\t\t\tthis._insertSpace\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (ops.length === 1) {\n\t\t\t\t// Leave cursor after token and Space\n\t\t\t\tthis._deltaColumn = startToken.length + 1;\n\t\t\t}\n\t\t}\n\t\tthis._selectionId = builder.trackSelection(s);\n\t\tfor (const op of ops) {\n\t\t\tbuilder.addEditOperation(op.range, op.text);\n\t\t}\n\t}\n\n\tpublic getEditOperations(model: ITextModel, builder: IEditOperationBuilder): void {\n\n\t\tlet s = this._selection;\n\t\tthis._moveEndPositionDown = false;\n\n\t\tif (s.startLineNumber === s.endLineNumber && this._ignoreFirstLine) {\n\t\t\tbuilder.addEditOperation(new Range(s.startLineNumber, model.getLineMaxColumn(s.startLineNumber), s.startLineNumber + 1, 1), s.startLineNumber === model.getLineCount() ? '' : '\\n');\n\t\t\tthis._selectionId = builder.trackSelection(s);\n\t\t\treturn;\n\t\t}\n\n\t\tif (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n\t\t\tthis._moveEndPositionDown = true;\n\t\t\ts = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\n\t\t}\n\n\t\tconst data = LineCommentCommand._gatherPreflightData(\n\t\t\tthis._type,\n\t\t\tthis._insertSpace,\n\t\t\tmodel,\n\t\t\ts.startLineNumber,\n\t\t\ts.endLineNumber,\n\t\t\tthis._ignoreEmptyLines,\n\t\t\tthis._ignoreFirstLine,\n\t\t\tthis.languageConfigurationService\n\t\t);\n\n\t\tif (data.supported) {\n\t\t\treturn this._executeLineComments(model, builder, data, s);\n\t\t}\n\n\t\treturn this._executeBlockComment(model, builder, s);\n\t}\n\n\tpublic computeCursorState(model: ITextModel, helper: ICursorStateComputerData): Selection {\n\t\tlet result = helper.getTrackedSelection(this._selectionId!);\n\n\t\tif (this._moveEndPositionDown) {\n\t\t\tresult = result.setEndPosition(result.endLineNumber + 1, 1);\n\t\t}\n\n\t\treturn new Selection(\n\t\t\tresult.selectionStartLineNumber,\n\t\t\tresult.selectionStartColumn + this._deltaColumn,\n\t\t\tresult.positionLineNumber,\n\t\t\tresult.positionColumn + this._deltaColumn\n\t\t);\n\t}\n\n\t/**\n\t * Generate edit operations in the remove line comment case\n\t */\n\tpublic static _createRemoveLineCommentsOperations(lines: ILinePreflightData[], startLineNumber: number): ISingleEditOperation[] {\n\t\tconst res: ISingleEditOperation[] = [];\n\n\t\tfor (let i = 0, len = lines.length; i < len; i++) {\n\t\t\tconst lineData = lines[i];\n\n\t\t\tif (lineData.ignore) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tres.push(EditOperation.delete(new Range(\n\t\t\t\tstartLineNumber + i, lineData.commentStrOffset + 1,\n\t\t\t\tstartLineNumber + i, lineData.commentStrOffset + lineData.commentStrLength + 1\n\t\t\t)));\n\t\t}\n\n\t\treturn res;\n\t}\n\n\t/**\n\t * Generate edit operations in the add line comment case\n\t */\n\tprivate _createAddLineCommentsOperations(lines: ILinePreflightData[], startLineNumber: number): ISingleEditOperation[] {\n\t\tconst res: ISingleEditOperation[] = [];\n\t\tconst afterCommentStr = this._insertSpace ? ' ' : '';\n\n\n\t\tfor (let i = 0, len = lines.length; i < len; i++) {\n\t\t\tconst lineData = lines[i];\n\n\t\t\tif (lineData.ignore) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tres.push(EditOperation.insert(new Position(startLineNumber + i, lineData.commentStrOffset + 1), lineData.commentStr + afterCommentStr));\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tprivate static nextVisibleColumn(currentVisibleColumn: number, indentSize: number, isTab: boolean, columnSize: number): number {\n\t\tif (isTab) {\n\t\t\treturn currentVisibleColumn + (indentSize - (currentVisibleColumn % indentSize));\n\t\t}\n\t\treturn currentVisibleColumn + columnSize;\n\t}\n\n\t/**\n\t * Adjust insertion points to have them vertically aligned in the add line comment case\n\t */\n\tpublic static _normalizeInsertionPoint(model: ISimpleModel, lines: IInsertionPoint[], startLineNumber: number, indentSize: number): void {\n\t\tlet minVisibleColumn = Constants.MAX_SAFE_SMALL_INTEGER;\n\t\tlet j: number;\n\t\tlet lenJ: number;\n\n\t\tfor (let i = 0, len = lines.length; i < len; i++) {\n\t\t\tif (lines[i].ignore) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst lineContent = model.getLineContent(startLineNumber + i);\n\n\t\t\tlet currentVisibleColumn = 0;\n\t\t\tfor (let j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\n\t\t\t\tcurrentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, indentSize, lineContent.charCodeAt(j) === CharCode.Tab, 1);\n\t\t\t}\n\n\t\t\tif (currentVisibleColumn < minVisibleColumn) {\n\t\t\t\tminVisibleColumn = currentVisibleColumn;\n\t\t\t}\n\t\t}\n\n\t\tminVisibleColumn = Math.floor(minVisibleColumn / indentSize) * indentSize;\n\n\t\tfor (let i = 0, len = lines.length; i < len; i++) {\n\t\t\tif (lines[i].ignore) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst lineContent = model.getLineContent(startLineNumber + i);\n\n\t\t\tlet currentVisibleColumn = 0;\n\t\t\tfor (j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\n\t\t\t\tcurrentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, indentSize, lineContent.charCodeAt(j) === CharCode.Tab, 1);\n\t\t\t}\n\n\t\t\tif (currentVisibleColumn > minVisibleColumn) {\n\t\t\t\tlines[i].commentStrOffset = j - 1;\n\t\t\t} else {\n\t\t\t\tlines[i].commentStrOffset = j;\n\t\t\t}\n\t\t}\n\t}\n}\n"],
  "mappings": "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",
  "names": ["Type", "j", "lenJ"]
}
