{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/contrib/suggest/browser/completionModel.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { quickSelect } from \"../../../../base/common/arrays.js\";\nimport { CharCode } from \"../../../../base/common/charCode.js\";\nimport {\n\tFuzzyScore,\n\tFuzzyScoreOptions,\n\ttype FuzzyScorer,\n\tanyScore,\n\tfuzzyScore,\n\tfuzzyScoreGracefulAggressive,\n} from \"../../../../base/common/filters.js\";\nimport { compareIgnoreCase } from \"../../../../base/common/strings.js\";\nimport type { InternalSuggestOptions } from \"../../../common/config/editorOptions.js\";\nimport {\n\tCompletionItemKind,\n\ttype CompletionItemProvider,\n} from \"../../../common/languages.js\";\nimport type { CompletionItem } from \"./suggest.js\";\nimport type { WordDistance } from \"./wordDistance.js\";\n\ntype StrictCompletionItem = Required<CompletionItem>;\n\nexport interface ICompletionStats {\n\tpLabelLen: number;\n}\n\nexport class LineContext {\n\tconstructor(\n\t\treadonly leadingLineContent: string,\n\t\treadonly characterCountDelta: number,\n\t) {}\n}\n\nenum Refilter {\n\tNothing = 0,\n\tAll = 1,\n\tIncr = 2,\n}\n\n/**\n * Sorted, filtered completion view model\n * */\nexport class CompletionModel {\n\tprivate readonly _items: CompletionItem[];\n\tprivate readonly _column: number;\n\tprivate readonly _wordDistance: WordDistance;\n\tprivate readonly _options: InternalSuggestOptions;\n\tprivate readonly _snippetCompareFn =\n\t\tCompletionModel._compareCompletionItems;\n\tprivate readonly _fuzzyScoreOptions: FuzzyScoreOptions;\n\n\tprivate _lineContext: LineContext;\n\tprivate _refilterKind: Refilter;\n\tprivate _filteredItems?: StrictCompletionItem[];\n\n\tprivate _itemsByProvider?: Map<CompletionItemProvider, CompletionItem[]>;\n\tprivate _stats?: ICompletionStats;\n\n\tconstructor(\n\t\titems: CompletionItem[],\n\t\tcolumn: number,\n\t\tlineContext: LineContext,\n\t\twordDistance: WordDistance,\n\t\toptions: InternalSuggestOptions,\n\t\tsnippetSuggestions: \"top\" | \"bottom\" | \"inline\" | \"none\",\n\t\tfuzzyScoreOptions:\n\t\t\t| FuzzyScoreOptions\n\t\t\t| undefined = FuzzyScoreOptions.default,\n\t\treadonly clipboardText: string | undefined = undefined,\n\t) {\n\t\tthis._items = items;\n\t\tthis._column = column;\n\t\tthis._wordDistance = wordDistance;\n\t\tthis._options = options;\n\t\tthis._refilterKind = Refilter.All;\n\t\tthis._lineContext = lineContext;\n\t\tthis._fuzzyScoreOptions = fuzzyScoreOptions;\n\n\t\tif (snippetSuggestions === \"top\") {\n\t\t\tthis._snippetCompareFn =\n\t\t\t\tCompletionModel._compareCompletionItemsSnippetsUp;\n\t\t} else if (snippetSuggestions === \"bottom\") {\n\t\t\tthis._snippetCompareFn =\n\t\t\t\tCompletionModel._compareCompletionItemsSnippetsDown;\n\t\t}\n\t}\n\n\tget lineContext(): LineContext {\n\t\treturn this._lineContext;\n\t}\n\n\tset lineContext(value: LineContext) {\n\t\tif (\n\t\t\tthis._lineContext.leadingLineContent !== value.leadingLineContent ||\n\t\t\tthis._lineContext.characterCountDelta !== value.characterCountDelta\n\t\t) {\n\t\t\tthis._refilterKind =\n\t\t\t\tthis._lineContext.characterCountDelta <\n\t\t\t\t\tvalue.characterCountDelta && this._filteredItems\n\t\t\t\t\t? Refilter.Incr\n\t\t\t\t\t: Refilter.All;\n\t\t\tthis._lineContext = value;\n\t\t}\n\t}\n\n\tget items(): CompletionItem[] {\n\t\tthis._ensureCachedState();\n\t\treturn this._filteredItems!;\n\t}\n\n\tgetItemsByProvider(): ReadonlyMap<\n\t\tCompletionItemProvider,\n\t\tCompletionItem[]\n\t> {\n\t\tthis._ensureCachedState();\n\t\treturn this._itemsByProvider!;\n\t}\n\n\tgetIncompleteProvider(): Set<CompletionItemProvider> {\n\t\tthis._ensureCachedState();\n\t\tconst result = new Set<CompletionItemProvider>();\n\t\tfor (const [provider, items] of this.getItemsByProvider()) {\n\t\t\tif (items.length > 0 && items[0].container.incomplete) {\n\t\t\t\tresult.add(provider);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tget stats(): ICompletionStats {\n\t\tthis._ensureCachedState();\n\t\treturn this._stats!;\n\t}\n\n\tprivate _ensureCachedState(): void {\n\t\tif (this._refilterKind !== Refilter.Nothing) {\n\t\t\tthis._createCachedState();\n\t\t}\n\t}\n\n\tprivate _createCachedState(): void {\n\t\tthis._itemsByProvider = new Map();\n\n\t\tconst labelLengths: number[] = [];\n\n\t\tconst { leadingLineContent, characterCountDelta } = this._lineContext;\n\t\tlet word = \"\";\n\t\tlet wordLow = \"\";\n\n\t\t// incrementally filter less\n\t\tconst source =\n\t\t\tthis._refilterKind === Refilter.All\n\t\t\t\t? this._items\n\t\t\t\t: this._filteredItems!;\n\t\tconst target: StrictCompletionItem[] = [];\n\n\t\t// picks a score function based on the number of\n\t\t// items that we have to score/filter and based on the\n\t\t// user-configuration\n\t\tconst scoreFn: FuzzyScorer =\n\t\t\t!this._options.filterGraceful || source.length > 2000\n\t\t\t\t? fuzzyScore\n\t\t\t\t: fuzzyScoreGracefulAggressive;\n\n\t\tfor (let i = 0; i < source.length; i++) {\n\t\t\tconst item = source[i];\n\n\t\t\tif (item.isInvalid) {\n\t\t\t\tcontinue; // SKIP invalid items\n\t\t\t}\n\n\t\t\t// keep all items by their provider\n\t\t\tconst arr = this._itemsByProvider.get(item.provider);\n\t\t\tif (arr) {\n\t\t\t\tarr.push(item);\n\t\t\t} else {\n\t\t\t\tthis._itemsByProvider.set(item.provider, [item]);\n\t\t\t}\n\n\t\t\t// 'word' is that remainder of the current line that we\n\t\t\t// filter and score against. In theory each suggestion uses a\n\t\t\t// different word, but in practice not - that's why we cache\n\t\t\tconst overwriteBefore =\n\t\t\t\titem.position.column - item.editStart.column;\n\t\t\tconst wordLen =\n\t\t\t\toverwriteBefore +\n\t\t\t\tcharacterCountDelta -\n\t\t\t\t(item.position.column - this._column);\n\t\t\tif (word.length !== wordLen) {\n\t\t\t\tword = wordLen === 0 ? \"\" : leadingLineContent.slice(-wordLen);\n\t\t\t\twordLow = word.toLowerCase();\n\t\t\t}\n\n\t\t\t// remember the word against which this item was\n\t\t\t// scored\n\t\t\titem.word = word;\n\n\t\t\tif (wordLen === 0) {\n\t\t\t\t// when there is nothing to score against, don't\n\t\t\t\t// event try to do. Use a const rank and rely on\n\t\t\t\t// the fallback-sort using the initial sort order.\n\t\t\t\t// use a score of `-100` because that is out of the\n\t\t\t\t// bound of values `fuzzyScore` will return\n\t\t\t\titem.score = FuzzyScore.Default;\n\t\t\t} else {\n\t\t\t\t// skip word characters that are whitespace until\n\t\t\t\t// we have hit the replace range (overwriteBefore)\n\t\t\t\tlet wordPos = 0;\n\t\t\t\twhile (wordPos < overwriteBefore) {\n\t\t\t\t\tconst ch = word.charCodeAt(wordPos);\n\t\t\t\t\tif (ch === CharCode.Space || ch === CharCode.Tab) {\n\t\t\t\t\t\twordPos += 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (wordPos >= wordLen) {\n\t\t\t\t\t// the wordPos at which scoring starts is the whole word\n\t\t\t\t\t// and therefore the same rules as not having a word apply\n\t\t\t\t\titem.score = FuzzyScore.Default;\n\t\t\t\t} else if (typeof item.completion.filterText === \"string\") {\n\t\t\t\t\t// when there is a `filterText` it must match the `word`.\n\t\t\t\t\t// if it matches we check with the label to compute highlights\n\t\t\t\t\t// and if that doesn't yield a result we have no highlights,\n\t\t\t\t\t// despite having the match\n\t\t\t\t\tconst match = scoreFn(\n\t\t\t\t\t\tword,\n\t\t\t\t\t\twordLow,\n\t\t\t\t\t\twordPos,\n\t\t\t\t\t\titem.completion.filterText,\n\t\t\t\t\t\titem.filterTextLow!,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tthis._fuzzyScoreOptions,\n\t\t\t\t\t);\n\t\t\t\t\tif (!match) {\n\t\t\t\t\t\tcontinue; // NO match\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\tcompareIgnoreCase(\n\t\t\t\t\t\t\titem.completion.filterText,\n\t\t\t\t\t\t\titem.textLabel,\n\t\t\t\t\t\t) === 0\n\t\t\t\t\t) {\n\t\t\t\t\t\t// filterText and label are actually the same -> use good highlights\n\t\t\t\t\t\titem.score = match;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// re-run the scorer on the label in the hope of a result BUT use the rank\n\t\t\t\t\t\t// of the filterText-match\n\t\t\t\t\t\titem.score = anyScore(\n\t\t\t\t\t\t\tword,\n\t\t\t\t\t\t\twordLow,\n\t\t\t\t\t\t\twordPos,\n\t\t\t\t\t\t\titem.textLabel,\n\t\t\t\t\t\t\titem.labelLow,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t);\n\t\t\t\t\t\titem.score[0] = match[0]; // use score from filterText\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// by default match `word` against the `label`\n\t\t\t\t\tconst match = scoreFn(\n\t\t\t\t\t\tword,\n\t\t\t\t\t\twordLow,\n\t\t\t\t\t\twordPos,\n\t\t\t\t\t\titem.textLabel,\n\t\t\t\t\t\titem.labelLow,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tthis._fuzzyScoreOptions,\n\t\t\t\t\t);\n\t\t\t\t\tif (!match) {\n\t\t\t\t\t\tcontinue; // NO match\n\t\t\t\t\t}\n\t\t\t\t\titem.score = match;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\titem.idx = i;\n\t\t\titem.distance = this._wordDistance.distance(\n\t\t\t\titem.position,\n\t\t\t\titem.completion,\n\t\t\t);\n\t\t\ttarget.push(item as StrictCompletionItem);\n\n\t\t\t// update stats\n\t\t\tlabelLengths.push(item.textLabel.length);\n\t\t}\n\n\t\tthis._filteredItems = target.sort(this._snippetCompareFn);\n\t\tthis._refilterKind = Refilter.Nothing;\n\t\tthis._stats = {\n\t\t\tpLabelLen: labelLengths.length\n\t\t\t\t? quickSelect(\n\t\t\t\t\t\tlabelLengths.length - 0.85,\n\t\t\t\t\t\tlabelLengths,\n\t\t\t\t\t\t(a, b) => a - b,\n\t\t\t\t\t)\n\t\t\t\t: 0,\n\t\t};\n\t}\n\n\tprivate static _compareCompletionItems(\n\t\ta: StrictCompletionItem,\n\t\tb: StrictCompletionItem,\n\t): number {\n\t\tif (a.score[0] > b.score[0]) {\n\t\t\treturn -1;\n\t\t} else if (a.score[0] < b.score[0]) {\n\t\t\treturn 1;\n\t\t} else if (a.distance < b.distance) {\n\t\t\treturn -1;\n\t\t} else if (a.distance > b.distance) {\n\t\t\treturn 1;\n\t\t} else if (a.idx < b.idx) {\n\t\t\treturn -1;\n\t\t} else if (a.idx > b.idx) {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tprivate static _compareCompletionItemsSnippetsDown(\n\t\ta: StrictCompletionItem,\n\t\tb: StrictCompletionItem,\n\t): number {\n\t\tif (a.completion.kind !== b.completion.kind) {\n\t\t\tif (a.completion.kind === CompletionItemKind.Snippet) {\n\t\t\t\treturn 1;\n\t\t\t} else if (b.completion.kind === CompletionItemKind.Snippet) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\treturn CompletionModel._compareCompletionItems(a, b);\n\t}\n\n\tprivate static _compareCompletionItemsSnippetsUp(\n\t\ta: StrictCompletionItem,\n\t\tb: StrictCompletionItem,\n\t): number {\n\t\tif (a.completion.kind !== b.completion.kind) {\n\t\t\tif (a.completion.kind === CompletionItemKind.Snippet) {\n\t\t\t\treturn -1;\n\t\t\t} else if (b.completion.kind === CompletionItemKind.Snippet) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn CompletionModel._compareCompletionItems(a, b);\n\t}\n}\n"],
  "mappings": "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",
  "names": ["Refilter"]
}
