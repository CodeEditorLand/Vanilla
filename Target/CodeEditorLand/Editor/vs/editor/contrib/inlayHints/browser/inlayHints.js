import{CancellationError as v,onUnexpectedExternalError as y}from"../../../../base/common/errors.js";import{DisposableStore as g}from"../../../../base/common/lifecycle.js";import{Schemas as u}from"../../../../base/common/network.js";import{URI as I}from"../../../../base/common/uri.js";import{Position as R}from"../../../common/core/position.js";import{Range as c}from"../../../common/core/range.js";class H{constructor(e,t){this.range=e;this.direction=t}}class m{constructor(e,t,s){this.hint=e;this.anchor=t;this.provider=s}_isResolved=!1;_currentResolve;with(e){const t=new m(this.hint,e.anchor,this.provider);return t._isResolved=this._isResolved,t._currentResolve=this._currentResolve,t}async resolve(e){if(typeof this.provider.resolveInlayHint=="function"){if(this._currentResolve)return await this._currentResolve,e.isCancellationRequested?void 0:this.resolve(e);this._isResolved||(this._currentResolve=this._doResolve(e).finally(()=>this._currentResolve=void 0)),await this._currentResolve}}async _doResolve(e){try{const t=await Promise.resolve(this.provider.resolveInlayHint(this.hint,e));this.hint.tooltip=t?.tooltip??this.hint.tooltip,this.hint.label=t?.label??this.hint.label,this.hint.textEdits=t?.textEdits??this.hint.textEdits,this._isResolved=!0}catch(t){y(t),this._isResolved=!1}}}class f{static _emptyInlayHintList=Object.freeze({dispose(){},hints:[]});static async create(e,t,s,l){const n=[],a=e.ordered(t).reverse().map(i=>s.map(async r=>{try{const o=await i.provideInlayHints(t,r,l);(o?.hints.length||i.onDidChangeInlayHints)&&n.push([o??f._emptyInlayHintList,i])}catch(o){y(o)}}));if(await Promise.all(a.flat()),l.isCancellationRequested||t.isDisposed())throw new v;return new f(s,n,t)}_disposables=new g;items;ranges;provider;constructor(e,t,s){this.ranges=e,this.provider=new Set;const l=[];for(const[n,a]of t){this._disposables.add(n),this.provider.add(a);for(const i of n.hints){const r=s.validatePosition(i.position);let o="before";const h=f._getRangeAtPosition(s,r);let p;h.getStartPosition().isBefore(r)?(p=c.fromPositions(h.getStartPosition(),r),o="after"):(p=c.fromPositions(r,h.getEndPosition()),o="before"),l.push(new m(i,new H(p,o),a))}}this.items=l.sort((n,a)=>R.compare(n.hint.position,a.hint.position))}dispose(){this._disposables.dispose()}static _getRangeAtPosition(e,t){const s=t.lineNumber,l=e.getWordAtPosition(t);if(l)return new c(s,l.startColumn,s,l.endColumn);e.tokenization.tokenizeIfCheap(s);const n=e.tokenization.getLineTokens(s),a=t.column-1,i=n.findTokenIndexAtOffset(a);let r=n.getStartOffset(i),o=n.getEndOffset(i);return o-r===1&&(r===a&&i>1?(r=n.getStartOffset(i-1),o=n.getEndOffset(i-1)):o===a&&i<n.getCount()-1&&(r=n.getStartOffset(i+1),o=n.getEndOffset(i+1))),new c(s,r+1,s,o+1)}}function S(d){return I.from({scheme:u.command,path:d.id,query:d.arguments&&encodeURIComponent(JSON.stringify(d.arguments))}).toString()}export{H as InlayHintAnchor,m as InlayHintItem,f as InlayHintsFragments,S as asCommandLink};
