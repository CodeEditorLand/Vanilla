import{CancellationToken as p}from"../../../../base/common/cancellation.js";import{onUnexpectedExternalError as m}from"../../../../base/common/errors.js";import{assertType as g}from"../../../../base/common/types.js";import{URI as f}from"../../../../base/common/uri.js";import{CommandsRegistry as d}from"../../../../platform/commands/common/commands.js";import{RawContextKey as u}from"../../../../platform/contextkey/common/contextkey.js";import{Position as l}from"../../../common/core/position.js";import*as c from"../../../common/languages.js";import{ILanguageFeaturesService as y}from"../../../common/services/languageFeatures.js";import{ITextModelService as x}from"../../../common/services/resolverService.js";const b={Visible:new u("parameterHintsVisible",!1),MultipleSignatures:new u("parameterHintsMultipleSignatures",!1)};async function S(r,o,i,n,t){const s=r.ordered(o);for(const a of s)try{const e=await a.provideSignatureHelp(o,i,t,n);if(e)return e}catch(e){m(e)}}d.registerCommand("_executeSignatureHelpProvider",async(r,...o)=>{const[i,n,t]=o;g(f.isUri(i)),g(l.isIPosition(n)),g(typeof t=="string"||!t);const s=r.get(y),a=await r.get(x).createModelReference(i);try{const e=await S(s.signatureHelpProvider,a.object.textEditorModel,l.lift(n),{triggerKind:c.SignatureHelpTriggerKind.Invoke,isRetrigger:!1,triggerCharacter:t},p.None);return e?(setTimeout(()=>e.dispose(),0),e.value):void 0}finally{a.dispose()}});export{b as Context,S as provideSignatureHelp};
