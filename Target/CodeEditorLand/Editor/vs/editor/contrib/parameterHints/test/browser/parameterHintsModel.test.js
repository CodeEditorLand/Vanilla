import e from"assert";import{promiseWithResolvers as C}from"../../../../../base/common/async.js";import"../../../../../base/common/cancellation.js";import{DisposableStore as P}from"../../../../../base/common/lifecycle.js";import{URI as q}from"../../../../../base/common/uri.js";import{runWithFakedTimers as h}from"../../../../../base/test/common/timeTravelScheduler.js";import{ensureNoDisposablesAreLeakedInTestSuite as b}from"../../../../../base/test/common/utils.js";import"../../../../common/core/position.js";import{Handler as p}from"../../../../common/editorCommon.js";import{LanguageFeatureRegistry as E}from"../../../../common/languageFeatureRegistry.js";import*as m from"../../../../common/languages.js";import"../../../../common/model.js";import{ParameterHintsModel as S}from"../../browser/parameterHintsModel.js";import{createTestCodeEditor as R}from"../../../../test/browser/testCodeEditor.js";import{createTextModel as _}from"../../../../test/common/testTextModel.js";import{ServiceCollection as K}from"../../../../../platform/instantiation/common/serviceCollection.js";import{InMemoryStorageService as I,IStorageService as M}from"../../../../../platform/storage/common/storage.js";import{ITelemetryService as x}from"../../../../../platform/telemetry/common/telemetry.js";import{NullTelemetryService as F}from"../../../../../platform/telemetry/common/telemetryUtils.js";const U=q.parse("test:somefile.ttt"),v={scheme:"test"},w={signatures:[{label:"none",parameters:[]}],activeParameter:0,activeSignature:0},y={value:w,dispose:()=>{}};suite("ParameterHintsModel",()=>{const a=new P;let u;setup(()=>{a.clear(),u=new E}),teardown(()=>{a.clear()}),b();function T(n){const o=a.add(_(n,void 0,void 0,U));return a.add(R(o,{serviceCollection:new K([x,F],[M,a.add(new I)])}))}function k(n){return new Promise(o=>{const r=a.add(n.onChangedHints(t=>(r.dispose(),o(t?{value:t,dispose:()=>{}}:void 0))))})}test("Provider should get trigger character on type",async()=>{const{promise:n,resolve:o}=C(),r="(",t=T("");a.add(new S(t,u)),a.add(u.register(v,new class{signatureHelpTriggerCharacters=[r];signatureHelpRetriggerCharacters=[];provideSignatureHelp(l,d,c,s){e.strictEqual(s.triggerKind,m.SignatureHelpTriggerKind.TriggerCharacter),e.strictEqual(s.triggerCharacter,r),o()}})),await h({useFakeTimers:!0},async()=>{t.trigger("keyboard",p.Type,{text:r}),await n})}),test("Provider should be retriggered if already active",async()=>{const{promise:n,resolve:o}=C(),r="(",t=T("");a.add(new S(t,u));let l=0;a.add(u.register(v,new class{signatureHelpTriggerCharacters=[r];signatureHelpRetriggerCharacters=[];provideSignatureHelp(d,c,s,i){++l;try{return l===1?(e.strictEqual(i.triggerKind,m.SignatureHelpTriggerKind.TriggerCharacter),e.strictEqual(i.triggerCharacter,r),e.strictEqual(i.isRetrigger,!1),e.strictEqual(i.activeSignatureHelp,void 0),setTimeout(()=>t.trigger("keyboard",p.Type,{text:r}),0)):(e.strictEqual(l,2),e.strictEqual(i.triggerKind,m.SignatureHelpTriggerKind.TriggerCharacter),e.strictEqual(i.isRetrigger,!0),e.strictEqual(i.triggerCharacter,r),e.strictEqual(i.activeSignatureHelp,w),o()),y}catch(g){throw console.error(g),g}}})),await h({useFakeTimers:!0},async()=>{t.trigger("keyboard",p.Type,{text:r}),await n})}),test("Provider should not be retriggered if previous help is canceled first",async()=>{const{promise:n,resolve:o}=C(),r="(",t=T(""),l=a.add(new S(t,u));let d=0;a.add(u.register(v,new class{signatureHelpTriggerCharacters=[r];signatureHelpRetriggerCharacters=[];provideSignatureHelp(c,s,i,g){try{return++d,d===1?(e.strictEqual(g.triggerKind,m.SignatureHelpTriggerKind.TriggerCharacter),e.strictEqual(g.triggerCharacter,r),e.strictEqual(g.isRetrigger,!1),e.strictEqual(g.activeSignatureHelp,void 0),l.cancel(),t.trigger("keyboard",p.Type,{text:r})):(e.strictEqual(d,2),e.strictEqual(g.triggerKind,m.SignatureHelpTriggerKind.TriggerCharacter),e.strictEqual(g.triggerCharacter,r),e.strictEqual(g.isRetrigger,!0),e.strictEqual(g.activeSignatureHelp,void 0),o()),y}catch(H){throw console.error(H),H}}})),await h({useFakeTimers:!0},()=>(t.trigger("keyboard",p.Type,{text:r}),n))}),test("Provider should get last trigger character when triggered multiple times and only be invoked once",async()=>{const{promise:n,resolve:o}=C(),r=T("");a.add(new S(r,u,5));let t=0;a.add(u.register(v,new class{signatureHelpTriggerCharacters=["a","b","c"];signatureHelpRetriggerCharacters=[];provideSignatureHelp(l,d,c,s){try{++t,e.strictEqual(s.triggerKind,m.SignatureHelpTriggerKind.TriggerCharacter),e.strictEqual(s.isRetrigger,!1),e.strictEqual(s.triggerCharacter,"c"),setTimeout(()=>{e.strictEqual(t,1),o()},50);return}catch(i){throw console.error(i),i}}})),await h({useFakeTimers:!0},async()=>{r.trigger("keyboard",p.Type,{text:"a"}),r.trigger("keyboard",p.Type,{text:"b"}),r.trigger("keyboard",p.Type,{text:"c"}),await n})}),test("Provider should be retriggered if already active",async()=>{const{promise:n,resolve:o}=C(),r=T("");a.add(new S(r,u,5));let t=0;a.add(u.register(v,new class{signatureHelpTriggerCharacters=["a","b"];signatureHelpRetriggerCharacters=[];provideSignatureHelp(l,d,c,s){try{return++t,t===1?(e.strictEqual(s.triggerKind,m.SignatureHelpTriggerKind.TriggerCharacter),e.strictEqual(s.triggerCharacter,"a"),setTimeout(()=>r.trigger("keyboard",p.Type,{text:"b"}),50)):t===2?(e.strictEqual(s.triggerKind,m.SignatureHelpTriggerKind.TriggerCharacter),e.ok(s.isRetrigger),e.strictEqual(s.triggerCharacter,"b"),o()):e.fail("Unexpected invoke"),y}catch(i){throw console.error(i),i}}})),await h({useFakeTimers:!0},()=>(r.trigger("keyboard",p.Type,{text:"a"}),n))}),test("Should cancel existing request when new request comes in",async()=>{const n=T("abc def"),o=a.add(new S(n,u));let r=-1,t=0;const l=new class{signatureHelpTriggerCharacters=[];signatureHelpRetriggerCharacters=[];provideSignatureHelp(d,c,s){try{const i=t++;return a.add(s.onCancellationRequested(()=>{r=i})),i===0&&o.trigger({triggerKind:m.SignatureHelpTriggerKind.Invoke},0),new Promise(g=>{setTimeout(()=>{g({value:{signatures:[{label:""+i,parameters:[]}],activeParameter:0,activeSignature:0},dispose:()=>{}})},100)})}catch(i){throw console.error(i),i}}};a.add(u.register(v,l)),await h({useFakeTimers:!0},async()=>(o.trigger({triggerKind:m.SignatureHelpTriggerKind.Invoke},0),e.strictEqual(-1,r),new Promise((d,c)=>a.add(o.onChangedHints(s=>{try{e.strictEqual(0,r),e.strictEqual("1",s.signatures[0].label),d()}catch(i){c(i)}})))))}),test("Provider should be retriggered by retrigger character",async()=>{const{promise:n,resolve:o}=C(),r="a",t="b",l=T("");a.add(new S(l,u,5));let d=0;a.add(u.register(v,new class{signatureHelpTriggerCharacters=[r];signatureHelpRetriggerCharacters=[t];provideSignatureHelp(c,s,i,g){try{return++d,d===1?(e.strictEqual(g.triggerKind,m.SignatureHelpTriggerKind.TriggerCharacter),e.strictEqual(g.triggerCharacter,r),setTimeout(()=>l.trigger("keyboard",p.Type,{text:t}),50)):d===2?(e.strictEqual(g.triggerKind,m.SignatureHelpTriggerKind.TriggerCharacter),e.ok(g.isRetrigger),e.strictEqual(g.triggerCharacter,t),o()):e.fail("Unexpected invoke"),y}catch(H){throw console.error(H),H}}})),await h({useFakeTimers:!0},async()=>(l.trigger("keyboard",p.Type,{text:t}),l.trigger("keyboard",p.Type,{text:r}),n))}),test("should use first result from multiple providers",async()=>{const n="a",o="firstProvider",r="secondProvider",t="parameter",l=T(""),d=a.add(new S(l,u,5));a.add(u.register(v,new class{signatureHelpTriggerCharacters=[n];signatureHelpRetriggerCharacters=[];async provideSignatureHelp(c,s,i,g){try{return g.isRetrigger?void 0:(setTimeout(()=>l.trigger("keyboard",p.Type,{text:n}),50),{value:{activeParameter:0,activeSignature:0,signatures:[{label:o,parameters:[{label:t}]}]},dispose:()=>{}})}catch(H){throw console.error(H),H}}})),a.add(u.register(v,new class{signatureHelpTriggerCharacters=[n];signatureHelpRetriggerCharacters=[];async provideSignatureHelp(c,s,i,g){if(g.isRetrigger)return{value:{activeParameter:0,activeSignature:g.activeSignatureHelp?g.activeSignatureHelp.activeSignature+1:0,signatures:[{label:r,parameters:g.activeSignatureHelp?g.activeSignatureHelp.signatures[0].parameters:[]}]},dispose:()=>{}}}})),await h({useFakeTimers:!0},async()=>{l.trigger("keyboard",p.Type,{text:n});const c=(await k(d)).value;e.strictEqual(c.signatures[0].label,o),e.strictEqual(c.activeSignature,0),e.strictEqual(c.signatures[0].parameters[0].label,t);const s=(await k(d)).value;e.strictEqual(s.signatures[0].label,r),e.strictEqual(s.activeSignature,1),e.strictEqual(s.signatures[0].parameters[0].label,t)})}),test("Quick typing should use the first trigger character",async()=>{const n=T(""),o=a.add(new S(n,u,50)),r="a";let t=0;a.add(u.register(v,new class{signatureHelpTriggerCharacters=[r];signatureHelpRetriggerCharacters=[];provideSignatureHelp(l,d,c,s){try{return++t,t===1?(e.strictEqual(s.triggerKind,m.SignatureHelpTriggerKind.TriggerCharacter),e.strictEqual(s.triggerCharacter,r)):e.fail("Unexpected invoke"),y}catch(i){throw console.error(i),i}}})),await h({useFakeTimers:!0},async()=>{n.trigger("keyboard",p.Type,{text:r}),n.trigger("keyboard",p.Type,{text:"x"}),await k(o)})}),test("Retrigger while a pending resolve is still going on should preserve last active signature #96702",async()=>{const{promise:n,resolve:o}=C(),r=T(""),t=a.add(new S(r,u,50)),l="a",d="b";let c=0;a.add(u.register(v,new class{signatureHelpTriggerCharacters=[l];signatureHelpRetriggerCharacters=[d];async provideSignatureHelp(s,i,g,H){try{return++c,c===1?(e.strictEqual(H.triggerKind,m.SignatureHelpTriggerKind.TriggerCharacter),e.strictEqual(H.triggerCharacter,l),setTimeout(()=>r.trigger("keyboard",p.Type,{text:d}),50)):c===2?(setTimeout(()=>r.trigger("keyboard",p.Type,{text:d}),50),await new Promise(f=>setTimeout(f,1e3))):c===3?(e.strictEqual(H.activeSignatureHelp,w),o()):e.fail("Unexpected invoke"),y}catch(f){throw console.error(f),o(f),f}}})),await h({useFakeTimers:!0},async()=>{r.trigger("keyboard",p.Type,{text:l}),await k(t),await k(t),await n})})});
