{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/standalone/browser/standaloneWebWorker.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getAllMethodNames } from '../../../base/common/objects.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { IWorkerDescriptor } from '../../../base/common/worker/simpleWorker.js';\nimport { EditorWorkerClient } from '../../browser/services/editorWorkerService.js';\nimport { IModelService } from '../../common/services/model.js';\nimport { standaloneEditorWorkerDescriptor } from './standaloneServices.js';\n\n/**\n * Create a new web worker that has model syncing capabilities built in.\n * Specify an AMD module to load that will `create` an object that will be proxied.\n */\nexport function createWebWorker<T extends object>(modelService: IModelService, opts: IWebWorkerOptions): MonacoWebWorker<T> {\n\treturn new MonacoWebWorkerImpl<T>(modelService, opts);\n}\n\n/**\n * A web worker that can provide a proxy to an arbitrary file.\n */\nexport interface MonacoWebWorker<T> {\n\t/**\n\t * Terminate the web worker, thus invalidating the returned proxy.\n\t */\n\tdispose(): void;\n\t/**\n\t * Get a proxy to the arbitrary loaded code.\n\t */\n\tgetProxy(): Promise<T>;\n\t/**\n\t * Synchronize (send) the models at `resources` to the web worker,\n\t * making them available in the monaco.worker.getMirrorModels().\n\t */\n\twithSyncedResources(resources: URI[]): Promise<T>;\n}\n\nexport interface IWebWorkerOptions {\n\t/**\n\t * The AMD moduleId to load.\n\t * It should export a function `create` that should return the exported proxy.\n\t */\n\tmoduleId: string;\n\t/**\n\t * The data to send over when calling create on the module.\n\t */\n\tcreateData?: any;\n\t/**\n\t * A label to be used to identify the web worker for debugging purposes.\n\t */\n\tlabel?: string;\n\t/**\n\t * An object that can be used by the web worker to make calls back to the main thread.\n\t */\n\thost?: any;\n\t/**\n\t * Keep idle models.\n\t * Defaults to false, which means that idle models will stop syncing after a while.\n\t */\n\tkeepIdleModels?: boolean;\n}\n\nclass MonacoWebWorkerImpl<T extends object> extends EditorWorkerClient implements MonacoWebWorker<T> {\n\n\tprivate readonly _foreignModuleId: string;\n\tprivate readonly _foreignModuleHost: { [method: string]: Function } | null;\n\tprivate _foreignModuleCreateData: any | null;\n\tprivate _foreignProxy: Promise<T> | null;\n\n\tconstructor(modelService: IModelService, opts: IWebWorkerOptions) {\n\t\tconst workerDescriptor: IWorkerDescriptor = {\n\t\t\tamdModuleId: standaloneEditorWorkerDescriptor.amdModuleId,\n\t\t\tesmModuleLocation: standaloneEditorWorkerDescriptor.esmModuleLocation,\n\t\t\tlabel: opts.label,\n\t\t};\n\t\tsuper(workerDescriptor, opts.keepIdleModels || false, modelService);\n\t\tthis._foreignModuleId = opts.moduleId;\n\t\tthis._foreignModuleCreateData = opts.createData || null;\n\t\tthis._foreignModuleHost = opts.host || null;\n\t\tthis._foreignProxy = null;\n\t}\n\n\t// foreign host request\n\tpublic override fhr(method: string, args: any[]): Promise<any> {\n\t\tif (!this._foreignModuleHost || typeof this._foreignModuleHost[method] !== 'function') {\n\t\t\treturn Promise.reject(new Error('Missing method ' + method + ' or missing main thread foreign host.'));\n\t\t}\n\n\t\ttry {\n\t\t\treturn Promise.resolve(this._foreignModuleHost[method].apply(this._foreignModuleHost, args));\n\t\t} catch (e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n\n\tprivate _getForeignProxy(): Promise<T> {\n\t\tif (!this._foreignProxy) {\n\t\t\tthis._foreignProxy = this._getProxy().then((proxy) => {\n\t\t\t\tconst foreignHostMethods = this._foreignModuleHost ? getAllMethodNames(this._foreignModuleHost) : [];\n\t\t\t\treturn proxy.$loadForeignModule(this._foreignModuleId, this._foreignModuleCreateData, foreignHostMethods).then((foreignMethods) => {\n\t\t\t\t\tthis._foreignModuleCreateData = null;\n\n\t\t\t\t\tconst proxyMethodRequest = (method: string, args: any[]): Promise<any> => {\n\t\t\t\t\t\treturn proxy.$fmr(method, args);\n\t\t\t\t\t};\n\n\t\t\t\t\tconst createProxyMethod = (method: string, proxyMethodRequest: (method: string, args: any[]) => Promise<any>): () => Promise<any> => {\n\t\t\t\t\t\treturn function () {\n\t\t\t\t\t\t\tconst args = Array.prototype.slice.call(arguments, 0);\n\t\t\t\t\t\t\treturn proxyMethodRequest(method, args);\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\n\t\t\t\t\tconst foreignProxy = {} as T;\n\t\t\t\t\tfor (const foreignMethod of foreignMethods) {\n\t\t\t\t\t\t(<any>foreignProxy)[foreignMethod] = createProxyMethod(foreignMethod, proxyMethodRequest);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn foreignProxy;\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\treturn this._foreignProxy;\n\t}\n\n\tpublic getProxy(): Promise<T> {\n\t\treturn this._getForeignProxy();\n\t}\n\n\tpublic withSyncedResources(resources: URI[]): Promise<T> {\n\t\treturn this.workerWithSyncedResources(resources).then(_ => this.getProxy());\n\t}\n}\n"],
  "mappings": ";;AAKA,SAAS,yBAAyB;AAClC,SAAS,WAAW;AACpB,SAAS,yBAAyB;AAClC,SAAS,0BAA0B;AACnC,SAAS,qBAAqB;AAC9B,SAAS,wCAAwC;AAM1C,SAAS,gBAAkC,cAA6B,MAA6C;AAC3H,SAAO,IAAI,oBAAuB,cAAc,IAAI;AACrD;AAFgB;AAgDhB,MAAM,4BAA8C,mBAAiD;AAAA,EAhErG,OAgEqG;AAAA;AAAA;AAAA,EAEnF;AAAA,EACA;AAAA,EACT;AAAA,EACA;AAAA,EAER,YAAY,cAA6B,MAAyB;AACjE,UAAM,mBAAsC;AAAA,MAC3C,aAAa,iCAAiC;AAAA,MAC9C,mBAAmB,iCAAiC;AAAA,MACpD,OAAO,KAAK;AAAA,IACb;AACA,UAAM,kBAAkB,KAAK,kBAAkB,OAAO,YAAY;AAClE,SAAK,mBAAmB,KAAK;AAC7B,SAAK,2BAA2B,KAAK,cAAc;AACnD,SAAK,qBAAqB,KAAK,QAAQ;AACvC,SAAK,gBAAgB;AAAA,EACtB;AAAA;AAAA,EAGgB,IAAI,QAAgB,MAA2B;AAC9D,QAAI,CAAC,KAAK,sBAAsB,OAAO,KAAK,mBAAmB,MAAM,MAAM,YAAY;AACtF,aAAO,QAAQ,OAAO,IAAI,MAAM,oBAAoB,SAAS,uCAAuC,CAAC;AAAA,IACtG;AAEA,QAAI;AACH,aAAO,QAAQ,QAAQ,KAAK,mBAAmB,MAAM,EAAE,MAAM,KAAK,oBAAoB,IAAI,CAAC;AAAA,IAC5F,SAAS,GAAG;AACX,aAAO,QAAQ,OAAO,CAAC;AAAA,IACxB;AAAA,EACD;AAAA,EAEQ,mBAA+B;AACtC,QAAI,CAAC,KAAK,eAAe;AACxB,WAAK,gBAAgB,KAAK,UAAU,EAAE,KAAK,CAAC,UAAU;AACrD,cAAM,qBAAqB,KAAK,qBAAqB,kBAAkB,KAAK,kBAAkB,IAAI,CAAC;AACnG,eAAO,MAAM,mBAAmB,KAAK,kBAAkB,KAAK,0BAA0B,kBAAkB,EAAE,KAAK,CAAC,mBAAmB;AAClI,eAAK,2BAA2B;AAEhC,gBAAM,qBAAqB,wBAAC,QAAgB,SAA8B;AACzE,mBAAO,MAAM,KAAK,QAAQ,IAAI;AAAA,UAC/B,GAF2B;AAI3B,gBAAM,oBAAoB,wBAAC,QAAgBA,wBAA0F;AACpI,mBAAO,WAAY;AAClB,oBAAM,OAAO,MAAM,UAAU,MAAM,KAAK,WAAW,CAAC;AACpD,qBAAOA,oBAAmB,QAAQ,IAAI;AAAA,YACvC;AAAA,UACD,GAL0B;AAO1B,gBAAM,eAAe,CAAC;AACtB,qBAAW,iBAAiB,gBAAgB;AAC3C,YAAM,aAAc,aAAa,IAAI,kBAAkB,eAAe,kBAAkB;AAAA,UACzF;AAEA,iBAAO;AAAA,QACR,CAAC;AAAA,MACF,CAAC;AAAA,IACF;AACA,WAAO,KAAK;AAAA,EACb;AAAA,EAEO,WAAuB;AAC7B,WAAO,KAAK,iBAAiB;AAAA,EAC9B;AAAA,EAEO,oBAAoB,WAA8B;AACxD,WAAO,KAAK,0BAA0B,SAAS,EAAE,KAAK,OAAK,KAAK,SAAS,CAAC;AAAA,EAC3E;AACD;",
  "names": ["proxyMethodRequest"]
}
