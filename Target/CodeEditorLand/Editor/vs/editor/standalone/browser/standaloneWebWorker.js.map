{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/editor/standalone/browser/standaloneWebWorker.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getAllMethodNames } from \"../../../base/common/objects.js\";\nimport type { URI } from \"../../../base/common/uri.js\";\nimport type { IWorkerDescriptor } from \"../../../base/common/worker/simpleWorker.js\";\nimport { EditorWorkerClient } from \"../../browser/services/editorWorkerService.js\";\nimport type { IModelService } from \"../../common/services/model.js\";\nimport { standaloneEditorWorkerDescriptor } from \"./standaloneServices.js\";\n\n/**\n * Create a new web worker that has model syncing capabilities built in.\n * Specify an AMD module to load that will `create` an object that will be proxied.\n */\nexport function createWebWorker<T extends object>(\n\tmodelService: IModelService,\n\topts: IWebWorkerOptions,\n): MonacoWebWorker<T> {\n\treturn new MonacoWebWorkerImpl<T>(modelService, opts);\n}\n\n/**\n * A web worker that can provide a proxy to an arbitrary file.\n */\nexport interface MonacoWebWorker<T> {\n\t/**\n\t * Terminate the web worker, thus invalidating the returned proxy.\n\t */\n\tdispose(): void;\n\t/**\n\t * Get a proxy to the arbitrary loaded code.\n\t */\n\tgetProxy(): Promise<T>;\n\t/**\n\t * Synchronize (send) the models at `resources` to the web worker,\n\t * making them available in the monaco.worker.getMirrorModels().\n\t */\n\twithSyncedResources(resources: URI[]): Promise<T>;\n}\n\nexport interface IWebWorkerOptions {\n\t/**\n\t * The AMD moduleId to load.\n\t * It should export a function `create` that should return the exported proxy.\n\t */\n\tmoduleId: string;\n\t/**\n\t * The data to send over when calling create on the module.\n\t */\n\tcreateData?: any;\n\t/**\n\t * A label to be used to identify the web worker for debugging purposes.\n\t */\n\tlabel?: string;\n\t/**\n\t * An object that can be used by the web worker to make calls back to the main thread.\n\t */\n\thost?: any;\n\t/**\n\t * Keep idle models.\n\t * Defaults to false, which means that idle models will stop syncing after a while.\n\t */\n\tkeepIdleModels?: boolean;\n}\n\nclass MonacoWebWorkerImpl<T extends object>\n\textends EditorWorkerClient\n\timplements MonacoWebWorker<T>\n{\n\tprivate readonly _foreignModuleId: string;\n\tprivate readonly _foreignModuleHost: { [method: string]: Function } | null;\n\tprivate _foreignModuleCreateData: any | null;\n\tprivate _foreignProxy: Promise<T> | null;\n\n\tconstructor(modelService: IModelService, opts: IWebWorkerOptions) {\n\t\tconst workerDescriptor: IWorkerDescriptor = {\n\t\t\tamdModuleId: standaloneEditorWorkerDescriptor.amdModuleId,\n\t\t\tesmModuleLocation:\n\t\t\t\tstandaloneEditorWorkerDescriptor.esmModuleLocation,\n\t\t\tlabel: opts.label,\n\t\t};\n\t\tsuper(workerDescriptor, opts.keepIdleModels || false, modelService);\n\t\tthis._foreignModuleId = opts.moduleId;\n\t\tthis._foreignModuleCreateData = opts.createData || null;\n\t\tthis._foreignModuleHost = opts.host || null;\n\t\tthis._foreignProxy = null;\n\t}\n\n\t// foreign host request\n\tpublic override fhr(method: string, args: any[]): Promise<any> {\n\t\tif (\n\t\t\t!this._foreignModuleHost ||\n\t\t\ttypeof this._foreignModuleHost[method] !== \"function\"\n\t\t) {\n\t\t\treturn Promise.reject(\n\t\t\t\tnew Error(\n\t\t\t\t\t\"Missing method \" +\n\t\t\t\t\t\tmethod +\n\t\t\t\t\t\t\" or missing main thread foreign host.\",\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\n\t\ttry {\n\t\t\treturn Promise.resolve(\n\t\t\t\tthis._foreignModuleHost[method].apply(\n\t\t\t\t\tthis._foreignModuleHost,\n\t\t\t\t\targs,\n\t\t\t\t),\n\t\t\t);\n\t\t} catch (e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n\n\tprivate _getForeignProxy(): Promise<T> {\n\t\tif (!this._foreignProxy) {\n\t\t\tthis._foreignProxy = this._getProxy().then((proxy) => {\n\t\t\t\tconst foreignHostMethods = this._foreignModuleHost\n\t\t\t\t\t? getAllMethodNames(this._foreignModuleHost)\n\t\t\t\t\t: [];\n\t\t\t\treturn proxy\n\t\t\t\t\t.$loadForeignModule(\n\t\t\t\t\t\tthis._foreignModuleId,\n\t\t\t\t\t\tthis._foreignModuleCreateData,\n\t\t\t\t\t\tforeignHostMethods,\n\t\t\t\t\t)\n\t\t\t\t\t.then((foreignMethods) => {\n\t\t\t\t\t\tthis._foreignModuleCreateData = null;\n\n\t\t\t\t\t\tconst proxyMethodRequest = (\n\t\t\t\t\t\t\tmethod: string,\n\t\t\t\t\t\t\targs: any[],\n\t\t\t\t\t\t): Promise<any> => {\n\t\t\t\t\t\t\treturn proxy.$fmr(method, args);\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tconst createProxyMethod = (\n\t\t\t\t\t\t\tmethod: string,\n\t\t\t\t\t\t\tproxyMethodRequest: (\n\t\t\t\t\t\t\t\tmethod: string,\n\t\t\t\t\t\t\t\targs: any[],\n\t\t\t\t\t\t\t) => Promise<any>,\n\t\t\t\t\t\t): (() => Promise<any>) => {\n\t\t\t\t\t\t\treturn () => {\n\t\t\t\t\t\t\t\tconst args = Array.prototype.slice.call(\n\t\t\t\t\t\t\t\t\targuments,\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\treturn proxyMethodRequest(method, args);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tconst foreignProxy = {} as T;\n\t\t\t\t\t\tfor (const foreignMethod of foreignMethods) {\n\t\t\t\t\t\t\t(<any>foreignProxy)[foreignMethod] =\n\t\t\t\t\t\t\t\tcreateProxyMethod(\n\t\t\t\t\t\t\t\t\tforeignMethod,\n\t\t\t\t\t\t\t\t\tproxyMethodRequest,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn foreignProxy;\n\t\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\treturn this._foreignProxy;\n\t}\n\n\tpublic getProxy(): Promise<T> {\n\t\treturn this._getForeignProxy();\n\t}\n\n\tpublic withSyncedResources(resources: URI[]): Promise<T> {\n\t\treturn this.workerWithSyncedResources(resources).then((_) =>\n\t\t\tthis.getProxy(),\n\t\t);\n\t}\n}\n"],
  "mappings": ";;AAKA,SAAS,yBAAyB;AAGlC,SAAS,0BAA0B;AAEnC,SAAS,wCAAwC;AAM1C,SAAS,gBACf,cACA,MACqB;AACrB,SAAO,IAAI,oBAAuB,cAAc,IAAI;AACrD;AALgB;AAmDhB,MAAM,4BACG,mBAET;AAAA,EAtEA,OAsEA;AAAA;AAAA;AAAA,EACkB;AAAA,EACA;AAAA,EACT;AAAA,EACA;AAAA,EAER,YAAY,cAA6B,MAAyB;AACjE,UAAM,mBAAsC;AAAA,MAC3C,aAAa,iCAAiC;AAAA,MAC9C,mBACC,iCAAiC;AAAA,MAClC,OAAO,KAAK;AAAA,IACb;AACA,UAAM,kBAAkB,KAAK,kBAAkB,OAAO,YAAY;AAClE,SAAK,mBAAmB,KAAK;AAC7B,SAAK,2BAA2B,KAAK,cAAc;AACnD,SAAK,qBAAqB,KAAK,QAAQ;AACvC,SAAK,gBAAgB;AAAA,EACtB;AAAA;AAAA,EAGgB,IAAI,QAAgB,MAA2B;AAC9D,QACC,CAAC,KAAK,sBACN,OAAO,KAAK,mBAAmB,MAAM,MAAM,YAC1C;AACD,aAAO,QAAQ;AAAA,QACd,IAAI;AAAA,UACH,oBACC,SACA;AAAA,QACF;AAAA,MACD;AAAA,IACD;AAEA,QAAI;AACH,aAAO,QAAQ;AAAA,QACd,KAAK,mBAAmB,MAAM,EAAE;AAAA,UAC/B,KAAK;AAAA,UACL;AAAA,QACD;AAAA,MACD;AAAA,IACD,SAAS,GAAG;AACX,aAAO,QAAQ,OAAO,CAAC;AAAA,IACxB;AAAA,EACD;AAAA,EAEQ,mBAA+B;AACtC,QAAI,CAAC,KAAK,eAAe;AACxB,WAAK,gBAAgB,KAAK,UAAU,EAAE,KAAK,CAAC,UAAU;AACrD,cAAM,qBAAqB,KAAK,qBAC7B,kBAAkB,KAAK,kBAAkB,IACzC,CAAC;AACJ,eAAO,MACL;AAAA,UACA,KAAK;AAAA,UACL,KAAK;AAAA,UACL;AAAA,QACD,EACC,KAAK,CAAC,mBAAmB;AACzB,eAAK,2BAA2B;AAEhC,gBAAM,qBAAqB,wBAC1B,QACA,SACkB;AAClB,mBAAO,MAAM,KAAK,QAAQ,IAAI;AAAA,UAC/B,GAL2B;AAO3B,gBAAM,oBAAoB,wBACzB,QACAA,wBAI0B;AAC1B,mBAAO,MAAM;AACZ,oBAAM,OAAO,MAAM,UAAU,MAAM;AAAA,gBAClC;AAAA,gBACA;AAAA,cACD;AACA,qBAAOA,oBAAmB,QAAQ,IAAI;AAAA,YACvC;AAAA,UACD,GAd0B;AAgB1B,gBAAM,eAAe,CAAC;AACtB,qBAAW,iBAAiB,gBAAgB;AAC3C,YAAM,aAAc,aAAa,IAChC;AAAA,cACC;AAAA,cACA;AAAA,YACD;AAAA,UACF;AAEA,iBAAO;AAAA,QACR,CAAC;AAAA,MACH,CAAC;AAAA,IACF;AACA,WAAO,KAAK;AAAA,EACb;AAAA,EAEO,WAAuB;AAC7B,WAAO,KAAK,iBAAiB;AAAA,EAC9B;AAAA,EAEO,oBAAoB,WAA8B;AACxD,WAAO,KAAK,0BAA0B,SAAS,EAAE;AAAA,MAAK,CAAC,MACtD,KAAK,SAAS;AAAA,IACf;AAAA,EACD;AACD;",
  "names": ["proxyMethodRequest"]
}
