{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/parts/ipc/electron-main/ipc.electron.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { WebContents } from \"electron\";\nimport { VSBuffer } from \"../../../common/buffer.js\";\nimport { Emitter, Event } from \"../../../common/event.js\";\nimport { type IDisposable, toDisposable } from \"../../../common/lifecycle.js\";\nimport { Protocol as ElectronProtocol } from \"../common/ipc.electron.js\";\nimport { type ClientConnectionEvent, IPCServer } from \"../common/ipc.js\";\nimport { validatedIpcMain } from \"./ipcMain.js\";\n\ninterface IIPCEvent {\n\tevent: { sender: WebContents };\n\tmessage: Buffer | null;\n}\n\nfunction createScopedOnMessageEvent(\n\tsenderId: number,\n\teventName: string,\n): Event<VSBuffer | null> {\n\tconst onMessage = Event.fromNodeEventEmitter<IIPCEvent>(\n\t\tvalidatedIpcMain,\n\t\teventName,\n\t\t(event, message) => ({ event, message }),\n\t);\n\tconst onMessageFromSender = Event.filter(\n\t\tonMessage,\n\t\t({ event }) => event.sender.id === senderId,\n\t);\n\n\treturn Event.map(onMessageFromSender, ({ message }) =>\n\t\tmessage ? VSBuffer.wrap(message) : message,\n\t);\n}\n\n/**\n * An implementation of `IPCServer` on top of Electron `ipcMain` API.\n */\nexport class Server extends IPCServer {\n\tprivate static readonly Clients = new Map<number, IDisposable>();\n\n\tprivate static getOnDidClientConnect(): Event<ClientConnectionEvent> {\n\t\tconst onHello = Event.fromNodeEventEmitter<WebContents>(\n\t\t\tvalidatedIpcMain,\n\t\t\t\"vscode:hello\",\n\t\t\t({ sender }) => sender,\n\t\t);\n\n\t\treturn Event.map(onHello, (webContents) => {\n\t\t\tconst id = webContents.id;\n\t\t\tconst client = Server.Clients.get(id);\n\n\t\t\tclient?.dispose();\n\n\t\t\tconst onDidClientReconnect = new Emitter<void>();\n\t\t\tServer.Clients.set(\n\t\t\t\tid,\n\t\t\t\ttoDisposable(() => onDidClientReconnect.fire()),\n\t\t\t);\n\n\t\t\tconst onMessage = createScopedOnMessageEvent(\n\t\t\t\tid,\n\t\t\t\t\"vscode:message\",\n\t\t\t) as Event<VSBuffer>;\n\t\t\tconst onDidClientDisconnect = Event.any(\n\t\t\t\tEvent.signal(\n\t\t\t\t\tcreateScopedOnMessageEvent(id, \"vscode:disconnect\"),\n\t\t\t\t),\n\t\t\t\tonDidClientReconnect.event,\n\t\t\t);\n\t\t\tconst protocol = new ElectronProtocol(webContents, onMessage);\n\n\t\t\treturn { protocol, onDidClientDisconnect };\n\t\t});\n\t}\n\n\tconstructor() {\n\t\tsuper(Server.getOnDidClientConnect());\n\t}\n}\n"],
  "mappings": ";;AAMA,SAAS,gBAAgB;AACzB,SAAS,SAAS,aAAa;AAC/B,SAA2B,oBAAoB;AAC/C,SAAS,YAAY,wBAAwB;AAC7C,SAAqC,iBAAiB;AACtD,SAAS,wBAAwB;AAOjC,SAAS,2BACR,UACA,WACyB;AACzB,QAAM,YAAY,MAAM;AAAA,IACvB;AAAA,IACA;AAAA,IACA,CAAC,OAAO,aAAa,EAAE,OAAO,QAAQ;AAAA,EACvC;AACA,QAAM,sBAAsB,MAAM;AAAA,IACjC;AAAA,IACA,CAAC,EAAE,MAAM,MAAM,MAAM,OAAO,OAAO;AAAA,EACpC;AAEA,SAAO,MAAM;AAAA,IAAI;AAAA,IAAqB,CAAC,EAAE,QAAQ,MAChD,UAAU,SAAS,KAAK,OAAO,IAAI;AAAA,EACpC;AACD;AAjBS;AAsBF,MAAM,eAAe,UAAU;AAAA,EAxCtC,OAwCsC;AAAA;AAAA;AAAA,EACrC,OAAwB,UAAU,oBAAI,IAAyB;AAAA,EAE/D,OAAe,wBAAsD;AACpE,UAAM,UAAU,MAAM;AAAA,MACrB;AAAA,MACA;AAAA,MACA,CAAC,EAAE,OAAO,MAAM;AAAA,IACjB;AAEA,WAAO,MAAM,IAAI,SAAS,CAAC,gBAAgB;AAC1C,YAAM,KAAK,YAAY;AACvB,YAAM,SAAS,OAAO,QAAQ,IAAI,EAAE;AAEpC,cAAQ,QAAQ;AAEhB,YAAM,uBAAuB,IAAI,QAAc;AAC/C,aAAO,QAAQ;AAAA,QACd;AAAA,QACA,aAAa,MAAM,qBAAqB,KAAK,CAAC;AAAA,MAC/C;AAEA,YAAM,YAAY;AAAA,QACjB;AAAA,QACA;AAAA,MACD;AACA,YAAM,wBAAwB,MAAM;AAAA,QACnC,MAAM;AAAA,UACL,2BAA2B,IAAI,mBAAmB;AAAA,QACnD;AAAA,QACA,qBAAqB;AAAA,MACtB;AACA,YAAM,WAAW,IAAI,iBAAiB,aAAa,SAAS;AAE5D,aAAO,EAAE,UAAU,sBAAsB;AAAA,IAC1C,CAAC;AAAA,EACF;AAAA,EAEA,cAAc;AACb,UAAM,OAAO,sBAAsB,CAAC;AAAA,EACrC;AACD;",
  "names": []
}
