{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/parts/ipc/electron-main/ipc.electron.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { WebContents } from 'electron';\nimport { validatedIpcMain } from './ipcMain.js';\nimport { VSBuffer } from '../../../common/buffer.js';\nimport { Emitter, Event } from '../../../common/event.js';\nimport { IDisposable, toDisposable } from '../../../common/lifecycle.js';\nimport { ClientConnectionEvent, IPCServer } from '../common/ipc.js';\nimport { Protocol as ElectronProtocol } from '../common/ipc.electron.js';\n\ninterface IIPCEvent {\n\tevent: { sender: WebContents };\n\tmessage: Buffer | null;\n}\n\nfunction createScopedOnMessageEvent(senderId: number, eventName: string): Event<VSBuffer | null> {\n\tconst onMessage = Event.fromNodeEventEmitter<IIPCEvent>(validatedIpcMain, eventName, (event, message) => ({ event, message }));\n\tconst onMessageFromSender = Event.filter(onMessage, ({ event }) => event.sender.id === senderId);\n\n\treturn Event.map(onMessageFromSender, ({ message }) => message ? VSBuffer.wrap(message) : message);\n}\n\n/**\n * An implementation of `IPCServer` on top of Electron `ipcMain` API.\n */\nexport class Server extends IPCServer {\n\n\tprivate static readonly Clients = new Map<number, IDisposable>();\n\n\tprivate static getOnDidClientConnect(): Event<ClientConnectionEvent> {\n\t\tconst onHello = Event.fromNodeEventEmitter<WebContents>(validatedIpcMain, 'vscode:hello', ({ sender }) => sender);\n\n\t\treturn Event.map(onHello, webContents => {\n\t\t\tconst id = webContents.id;\n\t\t\tconst client = Server.Clients.get(id);\n\n\t\t\tclient?.dispose();\n\n\t\t\tconst onDidClientReconnect = new Emitter<void>();\n\t\t\tServer.Clients.set(id, toDisposable(() => onDidClientReconnect.fire()));\n\n\t\t\tconst onMessage = createScopedOnMessageEvent(id, 'vscode:message') as Event<VSBuffer>;\n\t\t\tconst onDidClientDisconnect = Event.any(Event.signal(createScopedOnMessageEvent(id, 'vscode:disconnect')), onDidClientReconnect.event);\n\t\t\tconst protocol = new ElectronProtocol(webContents, onMessage);\n\n\t\t\treturn { protocol, onDidClientDisconnect };\n\t\t});\n\t}\n\n\tconstructor() {\n\t\tsuper(Server.getOnDidClientConnect());\n\t}\n}\n"],
  "mappings": ";;AAKA,SAAS,mBAAmB;AAC5B,SAAS,wBAAwB;AACjC,SAAS,gBAAgB;AACzB,SAAS,SAAS,aAAa;AAC/B,SAAS,aAAa,oBAAoB;AAC1C,SAAS,uBAAuB,iBAAiB;AACjD,SAAS,YAAY,wBAAwB;AAO7C,SAAS,2BAA2B,UAAkB,WAA2C;AAChG,QAAM,YAAY,MAAM,qBAAgC,kBAAkB,WAAW,CAAC,OAAO,aAAa,EAAE,OAAO,QAAQ,EAAE;AAC7H,QAAM,sBAAsB,MAAM,OAAO,WAAW,CAAC,EAAE,MAAM,MAAM,MAAM,OAAO,OAAO,QAAQ;AAE/F,SAAO,MAAM,IAAI,qBAAqB,CAAC,EAAE,QAAQ,MAAM,UAAU,SAAS,KAAK,OAAO,IAAI,OAAO;AAClG;AALS;AAUF,MAAM,eAAe,UAAU;AAAA,EA5BtC,OA4BsC;AAAA;AAAA;AAAA,EAErC,OAAwB,UAAU,oBAAI,IAAyB;AAAA,EAE/D,OAAe,wBAAsD;AACpE,UAAM,UAAU,MAAM,qBAAkC,kBAAkB,gBAAgB,CAAC,EAAE,OAAO,MAAM,MAAM;AAEhH,WAAO,MAAM,IAAI,SAAS,iBAAe;AACxC,YAAM,KAAK,YAAY;AACvB,YAAM,SAAS,OAAO,QAAQ,IAAI,EAAE;AAEpC,cAAQ,QAAQ;AAEhB,YAAM,uBAAuB,IAAI,QAAc;AAC/C,aAAO,QAAQ,IAAI,IAAI,aAAa,MAAM,qBAAqB,KAAK,CAAC,CAAC;AAEtE,YAAM,YAAY,2BAA2B,IAAI,gBAAgB;AACjE,YAAM,wBAAwB,MAAM,IAAI,MAAM,OAAO,2BAA2B,IAAI,mBAAmB,CAAC,GAAG,qBAAqB,KAAK;AACrI,YAAM,WAAW,IAAI,iBAAiB,aAAa,SAAS;AAE5D,aAAO,EAAE,UAAU,sBAAsB;AAAA,IAC1C,CAAC;AAAA,EACF;AAAA,EAEA,cAAc;AACb,UAAM,OAAO,sBAAsB,CAAC;AAAA,EACrC;AACD;",
  "names": []
}
