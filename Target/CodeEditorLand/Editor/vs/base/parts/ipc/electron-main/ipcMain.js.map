{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/parts/ipc/electron-main/ipcMain.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport electron from 'electron';\nimport { onUnexpectedError } from '../../../common/errors.js';\nimport { Event } from '../../../common/event.js';\nimport { VSCODE_AUTHORITY } from '../../../common/network.js';\n\ntype ipcMainListener = (event: electron.IpcMainEvent, ...args: any[]) => void;\n\nclass ValidatedIpcMain implements Event.NodeEventEmitter {\n\n\t// We need to keep a map of original listener to the wrapped variant in order\n\t// to properly implement `removeListener`. We use a `WeakMap` because we do\n\t// not want to prevent the `key` of the map to get garbage collected.\n\tprivate readonly mapListenerToWrapper = new WeakMap<ipcMainListener, ipcMainListener>();\n\n\t/**\n\t * Listens to `channel`, when a new message arrives `listener` would be called with\n\t * `listener(event, args...)`.\n\t */\n\ton(channel: string, listener: ipcMainListener): this {\n\n\t\t// Remember the wrapped listener so that later we can\n\t\t// properly implement `removeListener`.\n\t\tconst wrappedListener = (event: electron.IpcMainEvent, ...args: any[]) => {\n\t\t\tif (this.validateEvent(channel, event)) {\n\t\t\t\tlistener(event, ...args);\n\t\t\t}\n\t\t};\n\n\t\tthis.mapListenerToWrapper.set(listener, wrappedListener);\n\n\t\telectron.ipcMain.on(channel, wrappedListener);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds a one time `listener` function for the event. This `listener` is invoked\n\t * only the next time a message is sent to `channel`, after which it is removed.\n\t */\n\tonce(channel: string, listener: ipcMainListener): this {\n\t\telectron.ipcMain.once(channel, (event: electron.IpcMainEvent, ...args: any[]) => {\n\t\t\tif (this.validateEvent(channel, event)) {\n\t\t\t\tlistener(event, ...args);\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds a handler for an `invoke`able IPC. This handler will be called whenever a\n\t * renderer calls `ipcRenderer.invoke(channel, ...args)`.\n\t *\n\t * If `listener` returns a Promise, the eventual result of the promise will be\n\t * returned as a reply to the remote caller. Otherwise, the return value of the\n\t * listener will be used as the value of the reply.\n\t *\n\t * The `event` that is passed as the first argument to the handler is the same as\n\t * that passed to a regular event listener. It includes information about which\n\t * WebContents is the source of the invoke request.\n\t *\n\t * Errors thrown through `handle` in the main process are not transparent as they\n\t * are serialized and only the `message` property from the original error is\n\t * provided to the renderer process. Please refer to #24427 for details.\n\t */\n\thandle(channel: string, listener: (event: electron.IpcMainInvokeEvent, ...args: any[]) => Promise<unknown>): this {\n\t\telectron.ipcMain.handle(channel, (event: electron.IpcMainInvokeEvent, ...args: any[]) => {\n\t\t\tif (this.validateEvent(channel, event)) {\n\t\t\t\treturn listener(event, ...args);\n\t\t\t}\n\n\t\t\treturn Promise.reject(`Invalid channel '${channel}' or sender for ipcMain.handle() usage.`);\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Removes any handler for `channel`, if present.\n\t */\n\tremoveHandler(channel: string): this {\n\t\telectron.ipcMain.removeHandler(channel);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Removes the specified `listener` from the listener array for the specified\n\t * `channel`.\n\t */\n\tremoveListener(channel: string, listener: ipcMainListener): this {\n\t\tconst wrappedListener = this.mapListenerToWrapper.get(listener);\n\t\tif (wrappedListener) {\n\t\t\telectron.ipcMain.removeListener(channel, wrappedListener);\n\t\t\tthis.mapListenerToWrapper.delete(listener);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprivate validateEvent(channel: string, event: electron.IpcMainEvent | electron.IpcMainInvokeEvent): boolean {\n\t\tif (!channel || !channel.startsWith('vscode:')) {\n\t\t\tonUnexpectedError(`Refused to handle ipcMain event for channel '${channel}' because the channel is unknown.`);\n\t\t\treturn false; // unexpected channel\n\t\t}\n\n\t\tconst sender = event.senderFrame;\n\n\t\tconst url = sender.url;\n\t\t// `url` can be `undefined` when running tests from playwright https://github.com/microsoft/vscode/issues/147301\n\t\t// and `url` can be `about:blank` when reloading the window\n\t\t// from performance tab of devtools https://github.com/electron/electron/issues/39427.\n\t\t// It is fine to skip the checks in these cases.\n\t\tif (!url || url === 'about:blank') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet host = 'unknown';\n\t\ttry {\n\t\t\thost = new URL(url).host;\n\t\t} catch (error) {\n\t\t\tonUnexpectedError(`Refused to handle ipcMain event for channel '${channel}' because of a malformed URL '${url}'.`);\n\t\t\treturn false; // unexpected URL\n\t\t}\n\n\t\tif (host !== VSCODE_AUTHORITY) {\n\t\t\tonUnexpectedError(`Refused to handle ipcMain event for channel '${channel}' because of a bad origin of '${host}'.`);\n\t\t\treturn false; // unexpected sender\n\t\t}\n\n\t\tif (sender.parent !== null) {\n\t\t\tonUnexpectedError(`Refused to handle ipcMain event for channel '${channel}' because sender of origin '${host}' is not a main frame.`);\n\t\t\treturn false; // unexpected frame\n\t\t}\n\n\t\treturn true;\n\t}\n}\n\n/**\n * A drop-in replacement of `ipcMain` that validates the sender of a message\n * according to https://github.com/electron/electron/blob/main/docs/tutorial/security.md\n *\n * @deprecated direct use of Electron IPC is not encouraged. We have utilities in place\n * to create services on top of IPC, see `ProxyChannel` for more information.\n */\nexport const validatedIpcMain = new ValidatedIpcMain();\n"],
  "mappings": ";;AAKA,OAAO,cAAc;AACrB,SAAS,yBAAyB;AAClC,SAAS,aAAa;AACtB,SAAS,wBAAwB;AAIjC,MAAM,iBAAmD;AAAA,EAZzD,OAYyD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAKvC,uBAAuB,oBAAI,QAA0C;AAAA;AAAA;AAAA;AAAA;AAAA,EAMtF,GAAG,SAAiB,UAAiC;AAIpD,UAAM,kBAAkB,wBAAC,UAAiC,SAAgB;AACzE,UAAI,KAAK,cAAc,SAAS,KAAK,GAAG;AACvC,iBAAS,OAAO,GAAG,IAAI;AAAA,MACxB;AAAA,IACD,GAJwB;AAMxB,SAAK,qBAAqB,IAAI,UAAU,eAAe;AAEvD,aAAS,QAAQ,GAAG,SAAS,eAAe;AAE5C,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,KAAK,SAAiB,UAAiC;AACtD,aAAS,QAAQ,KAAK,SAAS,CAAC,UAAiC,SAAgB;AAChF,UAAI,KAAK,cAAc,SAAS,KAAK,GAAG;AACvC,iBAAS,OAAO,GAAG,IAAI;AAAA,MACxB;AAAA,IACD,CAAC;AAED,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAkBA,OAAO,SAAiB,UAA0F;AACjH,aAAS,QAAQ,OAAO,SAAS,CAAC,UAAuC,SAAgB;AACxF,UAAI,KAAK,cAAc,SAAS,KAAK,GAAG;AACvC,eAAO,SAAS,OAAO,GAAG,IAAI;AAAA,MAC/B;AAEA,aAAO,QAAQ,OAAO,oBAAoB,OAAO,yCAAyC;AAAA,IAC3F,CAAC;AAED,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA,EAKA,cAAc,SAAuB;AACpC,aAAS,QAAQ,cAAc,OAAO;AAEtC,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,eAAe,SAAiB,UAAiC;AAChE,UAAM,kBAAkB,KAAK,qBAAqB,IAAI,QAAQ;AAC9D,QAAI,iBAAiB;AACpB,eAAS,QAAQ,eAAe,SAAS,eAAe;AACxD,WAAK,qBAAqB,OAAO,QAAQ;AAAA,IAC1C;AAEA,WAAO;AAAA,EACR;AAAA,EAEQ,cAAc,SAAiB,OAAqE;AAC3G,QAAI,CAAC,WAAW,CAAC,QAAQ,WAAW,SAAS,GAAG;AAC/C,wBAAkB,gDAAgD,OAAO,mCAAmC;AAC5G,aAAO;AAAA,IACR;AAEA,UAAM,SAAS,MAAM;AAErB,UAAM,MAAM,OAAO;AAKnB,QAAI,CAAC,OAAO,QAAQ,eAAe;AAClC,aAAO;AAAA,IACR;AAEA,QAAI,OAAO;AACX,QAAI;AACH,aAAO,IAAI,IAAI,GAAG,EAAE;AAAA,IACrB,SAAS,OAAO;AACf,wBAAkB,gDAAgD,OAAO,iCAAiC,GAAG,IAAI;AACjH,aAAO;AAAA,IACR;AAEA,QAAI,SAAS,kBAAkB;AAC9B,wBAAkB,gDAAgD,OAAO,iCAAiC,IAAI,IAAI;AAClH,aAAO;AAAA,IACR;AAEA,QAAI,OAAO,WAAW,MAAM;AAC3B,wBAAkB,gDAAgD,OAAO,+BAA+B,IAAI,wBAAwB;AACpI,aAAO;AAAA,IACR;AAEA,WAAO;AAAA,EACR;AACD;AASO,MAAM,mBAAmB,IAAI,iBAAiB;",
  "names": []
}
