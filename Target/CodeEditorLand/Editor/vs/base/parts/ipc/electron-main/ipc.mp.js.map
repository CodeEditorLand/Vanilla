{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/parts/ipc/electron-main/ipc.mp.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BrowserWindow, IpcMainEvent, MessagePortMain } from 'electron';\nimport { validatedIpcMain } from './ipcMain.js';\nimport { Event } from '../../../common/event.js';\nimport { IDisposable } from '../../../common/lifecycle.js';\nimport { generateUuid } from '../../../common/uuid.js';\nimport { Client as MessagePortClient } from '../common/ipc.mp.js';\n\n/**\n * An implementation of a `IPCClient` on top of Electron `MessagePortMain`.\n */\nexport class Client extends MessagePortClient implements IDisposable {\n\n\t/**\n\t * @param clientId a way to uniquely identify this client among\n\t * other clients. this is important for routing because every\n\t * client can also be a server\n\t */\n\tconstructor(port: MessagePortMain, clientId: string) {\n\t\tsuper({\n\t\t\taddEventListener: (type, listener) => port.addListener(type, listener),\n\t\t\tremoveEventListener: (type, listener) => port.removeListener(type, listener),\n\t\t\tpostMessage: message => port.postMessage(message),\n\t\t\tstart: () => port.start(),\n\t\t\tclose: () => port.close()\n\t\t}, clientId);\n\t}\n}\n\n/**\n * This method opens a message channel connection\n * in the target window. The target window needs\n * to use the `Server` from `electron-sandbox/ipc.mp`.\n */\nexport async function connect(window: BrowserWindow): Promise<MessagePortMain> {\n\n\t// Assert healthy window to talk to\n\tif (window.isDestroyed() || window.webContents.isDestroyed()) {\n\t\tthrow new Error('ipc.mp#connect: Cannot talk to window because it is closed or destroyed');\n\t}\n\n\t// Ask to create message channel inside the window\n\t// and send over a UUID to correlate the response\n\tconst nonce = generateUuid();\n\twindow.webContents.send('vscode:createMessageChannel', nonce);\n\n\t// Wait until the window has returned the `MessagePort`\n\t// We need to filter by the `nonce` to ensure we listen\n\t// to the right response.\n\tconst onMessageChannelResult = Event.fromNodeEventEmitter<{ nonce: string; port: MessagePortMain }>(validatedIpcMain, 'vscode:createMessageChannelResult', (e: IpcMainEvent, nonce: string) => ({ nonce, port: e.ports[0] }));\n\tconst { port } = await Event.toPromise(Event.once(Event.filter(onMessageChannelResult, e => e.nonce === nonce)));\n\n\treturn port;\n}\n"],
  "mappings": ";;AAKA,SAAS,eAAe,cAAc,uBAAuB;AAC7D,SAAS,wBAAwB;AACjC,SAAS,aAAa;AACtB,SAAS,mBAAmB;AAC5B,SAAS,oBAAoB;AAC7B,SAAS,UAAU,yBAAyB;AAKrC,MAAM,eAAe,kBAAyC;AAAA,EAfrE,OAeqE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOpE,YAAY,MAAuB,UAAkB;AACpD,UAAM;AAAA,MACL,kBAAkB,wBAAC,MAAM,aAAa,KAAK,YAAY,MAAM,QAAQ,GAAnD;AAAA,MAClB,qBAAqB,wBAAC,MAAM,aAAa,KAAK,eAAe,MAAM,QAAQ,GAAtD;AAAA,MACrB,aAAa,oCAAW,KAAK,YAAY,OAAO,GAAnC;AAAA,MACb,OAAO,6BAAM,KAAK,MAAM,GAAjB;AAAA,MACP,OAAO,6BAAM,KAAK,MAAM,GAAjB;AAAA,IACR,GAAG,QAAQ;AAAA,EACZ;AACD;AAOA,eAAsB,QAAQ,QAAiD;AAG9E,MAAI,OAAO,YAAY,KAAK,OAAO,YAAY,YAAY,GAAG;AAC7D,UAAM,IAAI,MAAM,yEAAyE;AAAA,EAC1F;AAIA,QAAM,QAAQ,aAAa;AAC3B,SAAO,YAAY,KAAK,+BAA+B,KAAK;AAK5D,QAAM,yBAAyB,MAAM,qBAA+D,kBAAkB,qCAAqC,CAAC,GAAiBA,YAAmB,EAAE,OAAAA,QAAO,MAAM,EAAE,MAAM,CAAC,EAAE,EAAE;AAC5N,QAAM,EAAE,KAAK,IAAI,MAAM,MAAM,UAAU,MAAM,KAAK,MAAM,OAAO,wBAAwB,OAAK,EAAE,UAAU,KAAK,CAAC,CAAC;AAE/G,SAAO;AACR;AAnBsB;",
  "names": ["nonce"]
}
