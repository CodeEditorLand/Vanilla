{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/parts/ipc/electron-main/ipc.mp.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { BrowserWindow, IpcMainEvent, MessagePortMain } from \"electron\";\nimport { Event } from \"../../../common/event.js\";\nimport type { IDisposable } from \"../../../common/lifecycle.js\";\nimport { generateUuid } from \"../../../common/uuid.js\";\nimport { Client as MessagePortClient } from \"../common/ipc.mp.js\";\nimport { validatedIpcMain } from \"./ipcMain.js\";\n\n/**\n * An implementation of a `IPCClient` on top of Electron `MessagePortMain`.\n */\nexport class Client extends MessagePortClient implements IDisposable {\n\t/**\n\t * @param clientId a way to uniquely identify this client among\n\t * other clients. this is important for routing because every\n\t * client can also be a server\n\t */\n\tconstructor(port: MessagePortMain, clientId: string) {\n\t\tsuper(\n\t\t\t{\n\t\t\t\taddEventListener: (type, listener) =>\n\t\t\t\t\tport.addListener(type, listener),\n\t\t\t\tremoveEventListener: (type, listener) =>\n\t\t\t\t\tport.removeListener(type, listener),\n\t\t\t\tpostMessage: (message) => port.postMessage(message),\n\t\t\t\tstart: () => port.start(),\n\t\t\t\tclose: () => port.close(),\n\t\t\t},\n\t\t\tclientId,\n\t\t);\n\t}\n}\n\n/**\n * This method opens a message channel connection\n * in the target window. The target window needs\n * to use the `Server` from `electron-sandbox/ipc.mp`.\n */\nexport async function connect(window: BrowserWindow): Promise<MessagePortMain> {\n\t// Assert healthy window to talk to\n\tif (window.isDestroyed() || window.webContents.isDestroyed()) {\n\t\tthrow new Error(\n\t\t\t\"ipc.mp#connect: Cannot talk to window because it is closed or destroyed\",\n\t\t);\n\t}\n\n\t// Ask to create message channel inside the window\n\t// and send over a UUID to correlate the response\n\tconst nonce = generateUuid();\n\twindow.webContents.send(\"vscode:createMessageChannel\", nonce);\n\n\t// Wait until the window has returned the `MessagePort`\n\t// We need to filter by the `nonce` to ensure we listen\n\t// to the right response.\n\tconst onMessageChannelResult = Event.fromNodeEventEmitter<{\n\t\tnonce: string;\n\t\tport: MessagePortMain;\n\t}>(\n\t\tvalidatedIpcMain,\n\t\t\"vscode:createMessageChannelResult\",\n\t\t(e: IpcMainEvent, nonce: string) => ({ nonce, port: e.ports[0] }),\n\t);\n\tconst { port } = await Event.toPromise(\n\t\tEvent.once(\n\t\t\tEvent.filter(onMessageChannelResult, (e) => e.nonce === nonce),\n\t\t),\n\t);\n\n\treturn port;\n}\n"],
  "mappings": ";;AAMA,SAAS,aAAa;AAEtB,SAAS,oBAAoB;AAC7B,SAAS,UAAU,yBAAyB;AAC5C,SAAS,wBAAwB;AAK1B,MAAM,eAAe,kBAAyC;AAAA,EAfrE,OAeqE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMpE,YAAY,MAAuB,UAAkB;AACpD;AAAA,MACC;AAAA,QACC,kBAAkB,wBAAC,MAAM,aACxB,KAAK,YAAY,MAAM,QAAQ,GADd;AAAA,QAElB,qBAAqB,wBAAC,MAAM,aAC3B,KAAK,eAAe,MAAM,QAAQ,GADd;AAAA,QAErB,aAAa,wBAAC,YAAY,KAAK,YAAY,OAAO,GAArC;AAAA,QACb,OAAO,6BAAM,KAAK,MAAM,GAAjB;AAAA,QACP,OAAO,6BAAM,KAAK,MAAM,GAAjB;AAAA,MACR;AAAA,MACA;AAAA,IACD;AAAA,EACD;AACD;AAOA,eAAsB,QAAQ,QAAiD;AAE9E,MAAI,OAAO,YAAY,KAAK,OAAO,YAAY,YAAY,GAAG;AAC7D,UAAM,IAAI;AAAA,MACT;AAAA,IACD;AAAA,EACD;AAIA,QAAM,QAAQ,aAAa;AAC3B,SAAO,YAAY,KAAK,+BAA+B,KAAK;AAK5D,QAAM,yBAAyB,MAAM;AAAA,IAIpC;AAAA,IACA;AAAA,IACA,CAAC,GAAiBA,YAAmB,EAAE,OAAAA,QAAO,MAAM,EAAE,MAAM,CAAC,EAAE;AAAA,EAChE;AACA,QAAM,EAAE,KAAK,IAAI,MAAM,MAAM;AAAA,IAC5B,MAAM;AAAA,MACL,MAAM,OAAO,wBAAwB,CAAC,MAAM,EAAE,UAAU,KAAK;AAAA,IAC9D;AAAA,EACD;AAEA,SAAO;AACR;AA/BsB;",
  "names": ["nonce"]
}
