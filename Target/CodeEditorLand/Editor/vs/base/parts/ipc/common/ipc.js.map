{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/parts/ipc/common/ipc.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getRandomElement } from \"../../../common/arrays.js\";\nimport {\n\ttype CancelablePromise,\n\tcreateCancelablePromise,\n\ttimeout,\n} from \"../../../common/async.js\";\nimport { VSBuffer } from \"../../../common/buffer.js\";\nimport {\n\tCancellationToken,\n\tCancellationTokenSource,\n} from \"../../../common/cancellation.js\";\nimport { memoize } from \"../../../common/decorators.js\";\nimport { CancellationError, ErrorNoTelemetry } from \"../../../common/errors.js\";\nimport {\n\tEmitter,\n\tEvent,\n\tEventMultiplexer,\n\tRelay,\n} from \"../../../common/event.js\";\nimport {\n\tDisposableStore,\n\ttype IDisposable,\n\tcombinedDisposable,\n\tdispose,\n\ttoDisposable,\n} from \"../../../common/lifecycle.js\";\nimport { revive } from \"../../../common/marshalling.js\";\nimport * as strings from \"../../../common/strings.js\";\nimport { isFunction, isUndefinedOrNull } from \"../../../common/types.js\";\n\n/**\n * An `IChannel` is an abstraction over a collection of commands.\n * You can `call` several commands on a channel, each taking at\n * most one single argument. A `call` always returns a promise\n * with at most one single return value.\n */\nexport interface IChannel {\n\tcall<T>(\n\t\tcommand: string,\n\t\targ?: any,\n\t\tcancellationToken?: CancellationToken,\n\t): Promise<T>;\n\tlisten<T>(event: string, arg?: any): Event<T>;\n}\n\n/**\n * An `IServerChannel` is the counter part to `IChannel`,\n * on the server-side. You should implement this interface\n * if you'd like to handle remote promises or events.\n */\nexport interface IServerChannel<TContext = string> {\n\tcall<T>(\n\t\tctx: TContext,\n\t\tcommand: string,\n\t\targ?: any,\n\t\tcancellationToken?: CancellationToken,\n\t): Promise<T>;\n\tlisten<T>(ctx: TContext, event: string, arg?: any): Event<T>;\n}\n\nenum RequestType {\n\tPromise = 100,\n\tPromiseCancel = 101,\n\tEventListen = 102,\n\tEventDispose = 103,\n}\n\nfunction requestTypeToStr(type: RequestType): string {\n\tswitch (type) {\n\t\tcase RequestType.Promise:\n\t\t\treturn \"req\";\n\t\tcase RequestType.PromiseCancel:\n\t\t\treturn \"cancel\";\n\t\tcase RequestType.EventListen:\n\t\t\treturn \"subscribe\";\n\t\tcase RequestType.EventDispose:\n\t\t\treturn \"unsubscribe\";\n\t}\n}\n\ntype IRawPromiseRequest = {\n\ttype: RequestType.Promise;\n\tid: number;\n\tchannelName: string;\n\tname: string;\n\targ: any;\n};\ntype IRawPromiseCancelRequest = { type: RequestType.PromiseCancel; id: number };\ntype IRawEventListenRequest = {\n\ttype: RequestType.EventListen;\n\tid: number;\n\tchannelName: string;\n\tname: string;\n\targ: any;\n};\ntype IRawEventDisposeRequest = { type: RequestType.EventDispose; id: number };\ntype IRawRequest =\n\t| IRawPromiseRequest\n\t| IRawPromiseCancelRequest\n\t| IRawEventListenRequest\n\t| IRawEventDisposeRequest;\n\nenum ResponseType {\n\tInitialize = 200,\n\tPromiseSuccess = 201,\n\tPromiseError = 202,\n\tPromiseErrorObj = 203,\n\tEventFire = 204,\n}\n\nfunction responseTypeToStr(type: ResponseType): string {\n\tswitch (type) {\n\t\tcase ResponseType.Initialize:\n\t\t\treturn `init`;\n\t\tcase ResponseType.PromiseSuccess:\n\t\t\treturn `reply:`;\n\t\tcase ResponseType.PromiseError:\n\t\tcase ResponseType.PromiseErrorObj:\n\t\t\treturn `replyErr:`;\n\t\tcase ResponseType.EventFire:\n\t\t\treturn `event:`;\n\t}\n}\n\ntype IRawInitializeResponse = { type: ResponseType.Initialize };\ntype IRawPromiseSuccessResponse = {\n\ttype: ResponseType.PromiseSuccess;\n\tid: number;\n\tdata: any;\n};\ntype IRawPromiseErrorResponse = {\n\ttype: ResponseType.PromiseError;\n\tid: number;\n\tdata: { message: string; name: string; stack: string[] | undefined };\n};\ntype IRawPromiseErrorObjResponse = {\n\ttype: ResponseType.PromiseErrorObj;\n\tid: number;\n\tdata: any;\n};\ntype IRawEventFireResponse = {\n\ttype: ResponseType.EventFire;\n\tid: number;\n\tdata: any;\n};\ntype IRawResponse =\n\t| IRawInitializeResponse\n\t| IRawPromiseSuccessResponse\n\t| IRawPromiseErrorResponse\n\t| IRawPromiseErrorObjResponse\n\t| IRawEventFireResponse;\n\ninterface IHandler {\n\t(response: IRawResponse): void;\n}\n\nexport interface IMessagePassingProtocol {\n\tsend(buffer: VSBuffer): void;\n\tonMessage: Event<VSBuffer>;\n\t/**\n\t * Wait for the write buffer (if applicable) to become empty.\n\t */\n\tdrain?(): Promise<void>;\n}\n\nenum State {\n\tUninitialized = 0,\n\tIdle = 1,\n}\n\n/**\n * An `IChannelServer` hosts a collection of channels. You are\n * able to register channels onto it, provided a channel name.\n */\nexport interface IChannelServer<TContext = string> {\n\tregisterChannel(\n\t\tchannelName: string,\n\t\tchannel: IServerChannel<TContext>,\n\t): void;\n}\n\n/**\n * An `IChannelClient` has access to a collection of channels. You\n * are able to get those channels, given their channel name.\n */\nexport interface IChannelClient {\n\tgetChannel<T extends IChannel>(channelName: string): T;\n}\n\nexport interface Client<TContext> {\n\treadonly ctx: TContext;\n}\n\nexport interface IConnectionHub<TContext> {\n\treadonly connections: Connection<TContext>[];\n\treadonly onDidAddConnection: Event<Connection<TContext>>;\n\treadonly onDidRemoveConnection: Event<Connection<TContext>>;\n}\n\n/**\n * An `IClientRouter` is responsible for routing calls to specific\n * channels, in scenarios in which there are multiple possible\n * channels (each from a separate client) to pick from.\n */\nexport interface IClientRouter<TContext = string> {\n\trouteCall(\n\t\thub: IConnectionHub<TContext>,\n\t\tcommand: string,\n\t\targ?: any,\n\t\tcancellationToken?: CancellationToken,\n\t): Promise<Client<TContext>>;\n\trouteEvent(\n\t\thub: IConnectionHub<TContext>,\n\t\tevent: string,\n\t\targ?: any,\n\t): Promise<Client<TContext>>;\n}\n\n/**\n * Similar to the `IChannelClient`, you can get channels from this\n * collection of channels. The difference being that in the\n * `IRoutingChannelClient`, there are multiple clients providing\n * the same channel. You'll need to pass in an `IClientRouter` in\n * order to pick the right one.\n */\nexport interface IRoutingChannelClient<TContext = string> {\n\tgetChannel<T extends IChannel>(\n\t\tchannelName: string,\n\t\trouter?: IClientRouter<TContext>,\n\t): T;\n}\n\ninterface IReader {\n\tread(bytes: number): VSBuffer;\n}\n\ninterface IWriter {\n\twrite(buffer: VSBuffer): void;\n}\n\n/**\n * @see https://en.wikipedia.org/wiki/Variable-length_quantity\n */\nfunction readIntVQL(reader: IReader) {\n\tlet value = 0;\n\tfor (let n = 0; ; n += 7) {\n\t\tconst next = reader.read(1);\n\t\tvalue |= (next.buffer[0] & 0b01111111) << n;\n\t\tif (!(next.buffer[0] & 0b10000000)) {\n\t\t\treturn value;\n\t\t}\n\t}\n}\n\nconst vqlZero = createOneByteBuffer(0);\n\n/**\n * @see https://en.wikipedia.org/wiki/Variable-length_quantity\n */\nfunction writeInt32VQL(writer: IWriter, value: number) {\n\tif (value === 0) {\n\t\twriter.write(vqlZero);\n\t\treturn;\n\t}\n\n\tlet len = 0;\n\tfor (let v2 = value; v2 !== 0; v2 = v2 >>> 7) {\n\t\tlen++;\n\t}\n\n\tconst scratch = VSBuffer.alloc(len);\n\tfor (let i = 0; value !== 0; i++) {\n\t\tscratch.buffer[i] = value & 0b01111111;\n\t\tvalue = value >>> 7;\n\t\tif (value > 0) {\n\t\t\tscratch.buffer[i] |= 0b10000000;\n\t\t}\n\t}\n\n\twriter.write(scratch);\n}\n\nexport class BufferReader implements IReader {\n\tprivate pos = 0;\n\n\tconstructor(private buffer: VSBuffer) {}\n\n\tread(bytes: number): VSBuffer {\n\t\tconst result = this.buffer.slice(this.pos, this.pos + bytes);\n\t\tthis.pos += result.byteLength;\n\t\treturn result;\n\t}\n}\n\nexport class BufferWriter implements IWriter {\n\tprivate buffers: VSBuffer[] = [];\n\n\tget buffer(): VSBuffer {\n\t\treturn VSBuffer.concat(this.buffers);\n\t}\n\n\twrite(buffer: VSBuffer): void {\n\t\tthis.buffers.push(buffer);\n\t}\n}\n\nenum DataType {\n\tUndefined = 0,\n\tString = 1,\n\tBuffer = 2,\n\tVSBuffer = 3,\n\tArray = 4,\n\tObject = 5,\n\tInt = 6,\n}\n\nfunction createOneByteBuffer(value: number): VSBuffer {\n\tconst result = VSBuffer.alloc(1);\n\tresult.writeUInt8(value, 0);\n\treturn result;\n}\n\nconst BufferPresets = {\n\tUndefined: createOneByteBuffer(DataType.Undefined),\n\tString: createOneByteBuffer(DataType.String),\n\tBuffer: createOneByteBuffer(DataType.Buffer),\n\tVSBuffer: createOneByteBuffer(DataType.VSBuffer),\n\tArray: createOneByteBuffer(DataType.Array),\n\tObject: createOneByteBuffer(DataType.Object),\n\tUint: createOneByteBuffer(DataType.Int),\n};\n\ndeclare const Buffer: any;\nconst hasBuffer = typeof Buffer !== \"undefined\";\n\nexport function serialize(writer: IWriter, data: any): void {\n\tif (typeof data === \"undefined\") {\n\t\twriter.write(BufferPresets.Undefined);\n\t} else if (typeof data === \"string\") {\n\t\tconst buffer = VSBuffer.fromString(data);\n\t\twriter.write(BufferPresets.String);\n\t\twriteInt32VQL(writer, buffer.byteLength);\n\t\twriter.write(buffer);\n\t} else if (hasBuffer && Buffer.isBuffer(data)) {\n\t\tconst buffer = VSBuffer.wrap(data);\n\t\twriter.write(BufferPresets.Buffer);\n\t\twriteInt32VQL(writer, buffer.byteLength);\n\t\twriter.write(buffer);\n\t} else if (data instanceof VSBuffer) {\n\t\twriter.write(BufferPresets.VSBuffer);\n\t\twriteInt32VQL(writer, data.byteLength);\n\t\twriter.write(data);\n\t} else if (Array.isArray(data)) {\n\t\twriter.write(BufferPresets.Array);\n\t\twriteInt32VQL(writer, data.length);\n\n\t\tfor (const el of data) {\n\t\t\tserialize(writer, el);\n\t\t}\n\t} else if (typeof data === \"number\" && (data | 0) === data) {\n\t\t// write a vql if it's a number that we can do bitwise operations on\n\t\twriter.write(BufferPresets.Uint);\n\t\twriteInt32VQL(writer, data);\n\t} else {\n\t\tconst buffer = VSBuffer.fromString(JSON.stringify(data));\n\t\twriter.write(BufferPresets.Object);\n\t\twriteInt32VQL(writer, buffer.byteLength);\n\t\twriter.write(buffer);\n\t}\n}\n\nexport function deserialize(reader: IReader): any {\n\tconst type = reader.read(1).readUInt8(0);\n\n\tswitch (type) {\n\t\tcase DataType.Undefined:\n\t\t\treturn undefined;\n\t\tcase DataType.String:\n\t\t\treturn reader.read(readIntVQL(reader)).toString();\n\t\tcase DataType.Buffer:\n\t\t\treturn reader.read(readIntVQL(reader)).buffer;\n\t\tcase DataType.VSBuffer:\n\t\t\treturn reader.read(readIntVQL(reader));\n\t\tcase DataType.Array: {\n\t\t\tconst length = readIntVQL(reader);\n\t\t\tconst result: any[] = [];\n\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tresult.push(deserialize(reader));\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t\tcase DataType.Object:\n\t\t\treturn JSON.parse(reader.read(readIntVQL(reader)).toString());\n\t\tcase DataType.Int:\n\t\t\treturn readIntVQL(reader);\n\t}\n}\n\ninterface PendingRequest {\n\trequest: IRawPromiseRequest | IRawEventListenRequest;\n\ttimeoutTimer: any;\n}\n\nexport class ChannelServer<TContext = string>\n\timplements IChannelServer<TContext>, IDisposable\n{\n\tprivate channels = new Map<string, IServerChannel<TContext>>();\n\tprivate activeRequests = new Map<number, IDisposable>();\n\tprivate protocolListener: IDisposable | null;\n\n\t// Requests might come in for channels which are not yet registered.\n\t// They will timeout after `timeoutDelay`.\n\tprivate pendingRequests = new Map<string, PendingRequest[]>();\n\n\tconstructor(\n\t\tprivate protocol: IMessagePassingProtocol,\n\t\tprivate ctx: TContext,\n\t\tprivate logger: IIPCLogger | null = null,\n\t\tprivate timeoutDelay = 1000,\n\t) {\n\t\tthis.protocolListener = this.protocol.onMessage((msg) =>\n\t\t\tthis.onRawMessage(msg),\n\t\t);\n\t\tthis.sendResponse({ type: ResponseType.Initialize });\n\t}\n\n\tregisterChannel(\n\t\tchannelName: string,\n\t\tchannel: IServerChannel<TContext>,\n\t): void {\n\t\tthis.channels.set(channelName, channel);\n\n\t\t// https://github.com/microsoft/vscode/issues/72531\n\t\tsetTimeout(() => this.flushPendingRequests(channelName), 0);\n\t}\n\n\tprivate sendResponse(response: IRawResponse): void {\n\t\tswitch (response.type) {\n\t\t\tcase ResponseType.Initialize: {\n\t\t\t\tconst msgLength = this.send([response.type]);\n\t\t\t\tthis.logger?.logOutgoing(\n\t\t\t\t\tmsgLength,\n\t\t\t\t\t0,\n\t\t\t\t\tRequestInitiator.OtherSide,\n\t\t\t\t\tresponseTypeToStr(response.type),\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\tcase ResponseType.PromiseError:\n\t\t\tcase ResponseType.EventFire:\n\t\t\tcase ResponseType.PromiseErrorObj: {\n\t\t\t\tconst msgLength = this.send(\n\t\t\t\t\t[response.type, response.id],\n\t\t\t\t\tresponse.data,\n\t\t\t\t);\n\t\t\t\tthis.logger?.logOutgoing(\n\t\t\t\t\tmsgLength,\n\t\t\t\t\tresponse.id,\n\t\t\t\t\tRequestInitiator.OtherSide,\n\t\t\t\t\tresponseTypeToStr(response.type),\n\t\t\t\t\tresponse.data,\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate send(header: any, body: any = undefined): number {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, header);\n\t\tserialize(writer, body);\n\t\treturn this.sendBuffer(writer.buffer);\n\t}\n\n\tprivate sendBuffer(message: VSBuffer): number {\n\t\ttry {\n\t\t\tthis.protocol.send(message);\n\t\t\treturn message.byteLength;\n\t\t} catch (err) {\n\t\t\t// noop\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tprivate onRawMessage(message: VSBuffer): void {\n\t\tconst reader = new BufferReader(message);\n\t\tconst header = deserialize(reader);\n\t\tconst body = deserialize(reader);\n\t\tconst type = header[0] as RequestType;\n\n\t\tswitch (type) {\n\t\t\tcase RequestType.Promise:\n\t\t\t\tthis.logger?.logIncoming(\n\t\t\t\t\tmessage.byteLength,\n\t\t\t\t\theader[1],\n\t\t\t\t\tRequestInitiator.OtherSide,\n\t\t\t\t\t`${requestTypeToStr(type)}: ${header[2]}.${header[3]}`,\n\t\t\t\t\tbody,\n\t\t\t\t);\n\t\t\t\treturn this.onPromise({\n\t\t\t\t\ttype,\n\t\t\t\t\tid: header[1],\n\t\t\t\t\tchannelName: header[2],\n\t\t\t\t\tname: header[3],\n\t\t\t\t\targ: body,\n\t\t\t\t});\n\t\t\tcase RequestType.EventListen:\n\t\t\t\tthis.logger?.logIncoming(\n\t\t\t\t\tmessage.byteLength,\n\t\t\t\t\theader[1],\n\t\t\t\t\tRequestInitiator.OtherSide,\n\t\t\t\t\t`${requestTypeToStr(type)}: ${header[2]}.${header[3]}`,\n\t\t\t\t\tbody,\n\t\t\t\t);\n\t\t\t\treturn this.onEventListen({\n\t\t\t\t\ttype,\n\t\t\t\t\tid: header[1],\n\t\t\t\t\tchannelName: header[2],\n\t\t\t\t\tname: header[3],\n\t\t\t\t\targ: body,\n\t\t\t\t});\n\t\t\tcase RequestType.PromiseCancel:\n\t\t\t\tthis.logger?.logIncoming(\n\t\t\t\t\tmessage.byteLength,\n\t\t\t\t\theader[1],\n\t\t\t\t\tRequestInitiator.OtherSide,\n\t\t\t\t\t`${requestTypeToStr(type)}`,\n\t\t\t\t);\n\t\t\t\treturn this.disposeActiveRequest({ type, id: header[1] });\n\t\t\tcase RequestType.EventDispose:\n\t\t\t\tthis.logger?.logIncoming(\n\t\t\t\t\tmessage.byteLength,\n\t\t\t\t\theader[1],\n\t\t\t\t\tRequestInitiator.OtherSide,\n\t\t\t\t\t`${requestTypeToStr(type)}`,\n\t\t\t\t);\n\t\t\t\treturn this.disposeActiveRequest({ type, id: header[1] });\n\t\t}\n\t}\n\n\tprivate onPromise(request: IRawPromiseRequest): void {\n\t\tconst channel = this.channels.get(request.channelName);\n\n\t\tif (!channel) {\n\t\t\tthis.collectPendingRequest(request);\n\t\t\treturn;\n\t\t}\n\n\t\tconst cancellationTokenSource = new CancellationTokenSource();\n\t\tlet promise: Promise<any>;\n\n\t\ttry {\n\t\t\tpromise = channel.call(\n\t\t\t\tthis.ctx,\n\t\t\t\trequest.name,\n\t\t\t\trequest.arg,\n\t\t\t\tcancellationTokenSource.token,\n\t\t\t);\n\t\t} catch (err) {\n\t\t\tpromise = Promise.reject(err);\n\t\t}\n\n\t\tconst id = request.id;\n\n\t\tpromise\n\t\t\t.then(\n\t\t\t\t(data) => {\n\t\t\t\t\tthis.sendResponse({\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tdata,\n\t\t\t\t\t\ttype: ResponseType.PromiseSuccess,\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\t(err) => {\n\t\t\t\t\tif (err instanceof Error) {\n\t\t\t\t\t\tthis.sendResponse({\n\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\tmessage: err.message,\n\t\t\t\t\t\t\t\tname: err.name,\n\t\t\t\t\t\t\t\tstack: err.stack\n\t\t\t\t\t\t\t\t\t? err.stack.split(\"\\n\")\n\t\t\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\ttype: ResponseType.PromiseError,\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.sendResponse({\n\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\tdata: err,\n\t\t\t\t\t\t\ttype: ResponseType.PromiseErrorObj,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t)\n\t\t\t.finally(() => {\n\t\t\t\tdisposable.dispose();\n\t\t\t\tthis.activeRequests.delete(request.id);\n\t\t\t});\n\n\t\tconst disposable = toDisposable(() => cancellationTokenSource.cancel());\n\t\tthis.activeRequests.set(request.id, disposable);\n\t}\n\n\tprivate onEventListen(request: IRawEventListenRequest): void {\n\t\tconst channel = this.channels.get(request.channelName);\n\n\t\tif (!channel) {\n\t\t\tthis.collectPendingRequest(request);\n\t\t\treturn;\n\t\t}\n\n\t\tconst id = request.id;\n\t\tconst event = channel.listen(this.ctx, request.name, request.arg);\n\t\tconst disposable = event((data) =>\n\t\t\tthis.sendResponse({ id, data, type: ResponseType.EventFire }),\n\t\t);\n\n\t\tthis.activeRequests.set(request.id, disposable);\n\t}\n\n\tprivate disposeActiveRequest(request: IRawRequest): void {\n\t\tconst disposable = this.activeRequests.get(request.id);\n\n\t\tif (disposable) {\n\t\t\tdisposable.dispose();\n\t\t\tthis.activeRequests.delete(request.id);\n\t\t}\n\t}\n\n\tprivate collectPendingRequest(\n\t\trequest: IRawPromiseRequest | IRawEventListenRequest,\n\t): void {\n\t\tlet pendingRequests = this.pendingRequests.get(request.channelName);\n\n\t\tif (!pendingRequests) {\n\t\t\tpendingRequests = [];\n\t\t\tthis.pendingRequests.set(request.channelName, pendingRequests);\n\t\t}\n\n\t\tconst timer = setTimeout(() => {\n\t\t\tconsole.error(`Unknown channel: ${request.channelName}`);\n\n\t\t\tif (request.type === RequestType.Promise) {\n\t\t\t\tthis.sendResponse({\n\t\t\t\t\tid: request.id,\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tname: \"Unknown channel\",\n\t\t\t\t\t\tmessage: `Channel name '${request.channelName}' timed out after ${this.timeoutDelay}ms`,\n\t\t\t\t\t\tstack: undefined,\n\t\t\t\t\t},\n\t\t\t\t\ttype: ResponseType.PromiseError,\n\t\t\t\t});\n\t\t\t}\n\t\t}, this.timeoutDelay);\n\n\t\tpendingRequests.push({ request, timeoutTimer: timer });\n\t}\n\n\tprivate flushPendingRequests(channelName: string): void {\n\t\tconst requests = this.pendingRequests.get(channelName);\n\n\t\tif (requests) {\n\t\t\tfor (const request of requests) {\n\t\t\t\tclearTimeout(request.timeoutTimer);\n\n\t\t\t\tswitch (request.request.type) {\n\t\t\t\t\tcase RequestType.Promise:\n\t\t\t\t\t\tthis.onPromise(request.request);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase RequestType.EventListen:\n\t\t\t\t\t\tthis.onEventListen(request.request);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.pendingRequests.delete(channelName);\n\t\t}\n\t}\n\n\tpublic dispose(): void {\n\t\tif (this.protocolListener) {\n\t\t\tthis.protocolListener.dispose();\n\t\t\tthis.protocolListener = null;\n\t\t}\n\t\tdispose(this.activeRequests.values());\n\t\tthis.activeRequests.clear();\n\t}\n}\n\nexport enum RequestInitiator {\n\tLocalSide = 0,\n\tOtherSide = 1,\n}\n\nexport interface IIPCLogger {\n\tlogIncoming(\n\t\tmsgLength: number,\n\t\trequestId: number,\n\t\tinitiator: RequestInitiator,\n\t\tstr: string,\n\t\tdata?: any,\n\t): void;\n\tlogOutgoing(\n\t\tmsgLength: number,\n\t\trequestId: number,\n\t\tinitiator: RequestInitiator,\n\t\tstr: string,\n\t\tdata?: any,\n\t): void;\n}\n\nexport class ChannelClient implements IChannelClient, IDisposable {\n\tprivate isDisposed = false;\n\tprivate state: State = State.Uninitialized;\n\tprivate activeRequests = new Set<IDisposable>();\n\tprivate handlers = new Map<number, IHandler>();\n\tprivate lastRequestId = 0;\n\tprivate protocolListener: IDisposable | null;\n\tprivate logger: IIPCLogger | null;\n\n\tprivate readonly _onDidInitialize = new Emitter<void>();\n\treadonly onDidInitialize = this._onDidInitialize.event;\n\n\tconstructor(\n\t\tprivate protocol: IMessagePassingProtocol,\n\t\tlogger: IIPCLogger | null = null,\n\t) {\n\t\tthis.protocolListener = this.protocol.onMessage((msg) =>\n\t\t\tthis.onBuffer(msg),\n\t\t);\n\t\tthis.logger = logger;\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string): T {\n\t\tconst that = this;\n\n\t\treturn {\n\t\t\tcall(\n\t\t\t\tcommand: string,\n\t\t\t\targ?: any,\n\t\t\t\tcancellationToken?: CancellationToken,\n\t\t\t) {\n\t\t\t\tif (that.isDisposed) {\n\t\t\t\t\treturn Promise.reject(new CancellationError());\n\t\t\t\t}\n\t\t\t\treturn that.requestPromise(\n\t\t\t\t\tchannelName,\n\t\t\t\t\tcommand,\n\t\t\t\t\targ,\n\t\t\t\t\tcancellationToken,\n\t\t\t\t);\n\t\t\t},\n\t\t\tlisten(event: string, arg: any) {\n\t\t\t\tif (that.isDisposed) {\n\t\t\t\t\treturn Event.None;\n\t\t\t\t}\n\t\t\t\treturn that.requestEvent(channelName, event, arg);\n\t\t\t},\n\t\t} as T;\n\t}\n\n\tprivate requestPromise(\n\t\tchannelName: string,\n\t\tname: string,\n\t\targ?: any,\n\t\tcancellationToken = CancellationToken.None,\n\t): Promise<any> {\n\t\tconst id = this.lastRequestId++;\n\t\tconst type = RequestType.Promise;\n\t\tconst request: IRawRequest = { id, type, channelName, name, arg };\n\n\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\treturn Promise.reject(new CancellationError());\n\t\t}\n\n\t\tlet disposable: IDisposable;\n\n\t\tconst result = new Promise((c, e) => {\n\t\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\t\treturn e(new CancellationError());\n\t\t\t}\n\n\t\t\tconst doRequest = () => {\n\t\t\t\tconst handler: IHandler = (response) => {\n\t\t\t\t\tswitch (response.type) {\n\t\t\t\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\tc(response.data);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase ResponseType.PromiseError: {\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\tconst error = new Error(response.data.message);\n\t\t\t\t\t\t\t(<any>error).stack = Array.isArray(\n\t\t\t\t\t\t\t\tresponse.data.stack,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t? response.data.stack.join(\"\\n\")\n\t\t\t\t\t\t\t\t: response.data.stack;\n\t\t\t\t\t\t\terror.name = response.data.name;\n\t\t\t\t\t\t\te(error);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase ResponseType.PromiseErrorObj:\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\te(response.data);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tthis.handlers.set(id, handler);\n\t\t\t\tthis.sendRequest(request);\n\t\t\t};\n\n\t\t\tlet uninitializedPromise: CancelablePromise<void> | null = null;\n\t\t\tif (this.state === State.Idle) {\n\t\t\t\tdoRequest();\n\t\t\t} else {\n\t\t\t\tuninitializedPromise = createCancelablePromise((_) =>\n\t\t\t\t\tthis.whenInitialized(),\n\t\t\t\t);\n\t\t\t\tuninitializedPromise.then(() => {\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t\tdoRequest();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst cancel = () => {\n\t\t\t\tif (uninitializedPromise) {\n\t\t\t\t\tuninitializedPromise.cancel();\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t} else {\n\t\t\t\t\tthis.sendRequest({ id, type: RequestType.PromiseCancel });\n\t\t\t\t}\n\n\t\t\t\te(new CancellationError());\n\t\t\t};\n\n\t\t\tconst cancellationTokenListener =\n\t\t\t\tcancellationToken.onCancellationRequested(cancel);\n\t\t\tdisposable = combinedDisposable(\n\t\t\t\ttoDisposable(cancel),\n\t\t\t\tcancellationTokenListener,\n\t\t\t);\n\t\t\tthis.activeRequests.add(disposable);\n\t\t});\n\n\t\treturn result.finally(() => {\n\t\t\tdisposable.dispose();\n\t\t\tthis.activeRequests.delete(disposable);\n\t\t});\n\t}\n\n\tprivate requestEvent(\n\t\tchannelName: string,\n\t\tname: string,\n\t\targ?: any,\n\t): Event<any> {\n\t\tconst id = this.lastRequestId++;\n\t\tconst type = RequestType.EventListen;\n\t\tconst request: IRawRequest = { id, type, channelName, name, arg };\n\n\t\tlet uninitializedPromise: CancelablePromise<void> | null = null;\n\n\t\tconst emitter = new Emitter<any>({\n\t\t\tonWillAddFirstListener: () => {\n\t\t\t\tuninitializedPromise = createCancelablePromise((_) =>\n\t\t\t\t\tthis.whenInitialized(),\n\t\t\t\t);\n\t\t\t\tuninitializedPromise.then(() => {\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t\tthis.activeRequests.add(emitter);\n\t\t\t\t\tthis.sendRequest(request);\n\t\t\t\t});\n\t\t\t},\n\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\tif (uninitializedPromise) {\n\t\t\t\t\tuninitializedPromise.cancel();\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t} else {\n\t\t\t\t\tthis.activeRequests.delete(emitter);\n\t\t\t\t\tthis.sendRequest({ id, type: RequestType.EventDispose });\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\n\t\tconst handler: IHandler = (res: IRawResponse) =>\n\t\t\temitter.fire((res as IRawEventFireResponse).data);\n\t\tthis.handlers.set(id, handler);\n\n\t\treturn emitter.event;\n\t}\n\n\tprivate sendRequest(request: IRawRequest): void {\n\t\tswitch (request.type) {\n\t\t\tcase RequestType.Promise:\n\t\t\tcase RequestType.EventListen: {\n\t\t\t\tconst msgLength = this.send(\n\t\t\t\t\t[\n\t\t\t\t\t\trequest.type,\n\t\t\t\t\t\trequest.id,\n\t\t\t\t\t\trequest.channelName,\n\t\t\t\t\t\trequest.name,\n\t\t\t\t\t],\n\t\t\t\t\trequest.arg,\n\t\t\t\t);\n\t\t\t\tthis.logger?.logOutgoing(\n\t\t\t\t\tmsgLength,\n\t\t\t\t\trequest.id,\n\t\t\t\t\tRequestInitiator.LocalSide,\n\t\t\t\t\t`${requestTypeToStr(request.type)}: ${request.channelName}.${request.name}`,\n\t\t\t\t\trequest.arg,\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcase RequestType.PromiseCancel:\n\t\t\tcase RequestType.EventDispose: {\n\t\t\t\tconst msgLength = this.send([request.type, request.id]);\n\t\t\t\tthis.logger?.logOutgoing(\n\t\t\t\t\tmsgLength,\n\t\t\t\t\trequest.id,\n\t\t\t\t\tRequestInitiator.LocalSide,\n\t\t\t\t\trequestTypeToStr(request.type),\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate send(header: any, body: any = undefined): number {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, header);\n\t\tserialize(writer, body);\n\t\treturn this.sendBuffer(writer.buffer);\n\t}\n\n\tprivate sendBuffer(message: VSBuffer): number {\n\t\ttry {\n\t\t\tthis.protocol.send(message);\n\t\t\treturn message.byteLength;\n\t\t} catch (err) {\n\t\t\t// noop\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tprivate onBuffer(message: VSBuffer): void {\n\t\tconst reader = new BufferReader(message);\n\t\tconst header = deserialize(reader);\n\t\tconst body = deserialize(reader);\n\t\tconst type: ResponseType = header[0];\n\n\t\tswitch (type) {\n\t\t\tcase ResponseType.Initialize:\n\t\t\t\tthis.logger?.logIncoming(\n\t\t\t\t\tmessage.byteLength,\n\t\t\t\t\t0,\n\t\t\t\t\tRequestInitiator.LocalSide,\n\t\t\t\t\tresponseTypeToStr(type),\n\t\t\t\t);\n\t\t\t\treturn this.onResponse({ type: header[0] });\n\n\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\tcase ResponseType.PromiseError:\n\t\t\tcase ResponseType.EventFire:\n\t\t\tcase ResponseType.PromiseErrorObj:\n\t\t\t\tthis.logger?.logIncoming(\n\t\t\t\t\tmessage.byteLength,\n\t\t\t\t\theader[1],\n\t\t\t\t\tRequestInitiator.LocalSide,\n\t\t\t\t\tresponseTypeToStr(type),\n\t\t\t\t\tbody,\n\t\t\t\t);\n\t\t\t\treturn this.onResponse({\n\t\t\t\t\ttype: header[0],\n\t\t\t\t\tid: header[1],\n\t\t\t\t\tdata: body,\n\t\t\t\t});\n\t\t}\n\t}\n\n\tprivate onResponse(response: IRawResponse): void {\n\t\tif (response.type === ResponseType.Initialize) {\n\t\t\tthis.state = State.Idle;\n\t\t\tthis._onDidInitialize.fire();\n\t\t\treturn;\n\t\t}\n\n\t\tconst handler = this.handlers.get(response.id);\n\n\t\thandler?.(response);\n\t}\n\n\t@memoize\n\tget onDidInitializePromise(): Promise<void> {\n\t\treturn Event.toPromise(this.onDidInitialize);\n\t}\n\n\tprivate whenInitialized(): Promise<void> {\n\t\tif (this.state === State.Idle) {\n\t\t\treturn Promise.resolve();\n\t\t} else {\n\t\t\treturn this.onDidInitializePromise;\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.isDisposed = true;\n\t\tif (this.protocolListener) {\n\t\t\tthis.protocolListener.dispose();\n\t\t\tthis.protocolListener = null;\n\t\t}\n\t\tdispose(this.activeRequests.values());\n\t\tthis.activeRequests.clear();\n\t}\n}\n\nexport interface ClientConnectionEvent {\n\tprotocol: IMessagePassingProtocol;\n\tonDidClientDisconnect: Event<void>;\n}\n\ninterface Connection<TContext> extends Client<TContext> {\n\treadonly channelServer: ChannelServer<TContext>;\n\treadonly channelClient: ChannelClient;\n}\n\n/**\n * An `IPCServer` is both a channel server and a routing channel\n * client.\n *\n * As the owner of a protocol, you should extend both this\n * and the `IPCClient` classes to get IPC implementations\n * for your protocol.\n */\nexport class IPCServer<TContext = string>\n\timplements\n\t\tIChannelServer<TContext>,\n\t\tIRoutingChannelClient<TContext>,\n\t\tIConnectionHub<TContext>,\n\t\tIDisposable\n{\n\tprivate channels = new Map<string, IServerChannel<TContext>>();\n\tprivate _connections = new Set<Connection<TContext>>();\n\n\tprivate readonly _onDidAddConnection = new Emitter<Connection<TContext>>();\n\treadonly onDidAddConnection: Event<Connection<TContext>> =\n\t\tthis._onDidAddConnection.event;\n\n\tprivate readonly _onDidRemoveConnection = new Emitter<\n\t\tConnection<TContext>\n\t>();\n\treadonly onDidRemoveConnection: Event<Connection<TContext>> =\n\t\tthis._onDidRemoveConnection.event;\n\n\tprivate readonly disposables = new DisposableStore();\n\n\tget connections(): Connection<TContext>[] {\n\t\tconst result: Connection<TContext>[] = [];\n\t\tthis._connections.forEach((ctx) => result.push(ctx));\n\t\treturn result;\n\t}\n\n\tconstructor(\n\t\tonDidClientConnect: Event<ClientConnectionEvent>,\n\t\tipcLogger?: IIPCLogger | null,\n\t\ttimeoutDelay?: number,\n\t) {\n\t\tthis.disposables.add(\n\t\t\tonDidClientConnect(({ protocol, onDidClientDisconnect }) => {\n\t\t\t\tconst onFirstMessage = Event.once(protocol.onMessage);\n\n\t\t\t\tthis.disposables.add(\n\t\t\t\t\tonFirstMessage((msg) => {\n\t\t\t\t\t\tconst reader = new BufferReader(msg);\n\t\t\t\t\t\tconst ctx = deserialize(reader) as TContext;\n\n\t\t\t\t\t\tconst channelServer = new ChannelServer(\n\t\t\t\t\t\t\tprotocol,\n\t\t\t\t\t\t\tctx,\n\t\t\t\t\t\t\tipcLogger,\n\t\t\t\t\t\t\ttimeoutDelay,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst channelClient = new ChannelClient(\n\t\t\t\t\t\t\tprotocol,\n\t\t\t\t\t\t\tipcLogger,\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tthis.channels.forEach((channel, name) =>\n\t\t\t\t\t\t\tchannelServer.registerChannel(name, channel),\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tconst connection: Connection<TContext> = {\n\t\t\t\t\t\t\tchannelServer,\n\t\t\t\t\t\t\tchannelClient,\n\t\t\t\t\t\t\tctx,\n\t\t\t\t\t\t};\n\t\t\t\t\t\tthis._connections.add(connection);\n\t\t\t\t\t\tthis._onDidAddConnection.fire(connection);\n\n\t\t\t\t\t\tthis.disposables.add(\n\t\t\t\t\t\t\tonDidClientDisconnect(() => {\n\t\t\t\t\t\t\t\tchannelServer.dispose();\n\t\t\t\t\t\t\t\tchannelClient.dispose();\n\t\t\t\t\t\t\t\tthis._connections.delete(connection);\n\t\t\t\t\t\t\t\tthis._onDidRemoveConnection.fire(connection);\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t);\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t}),\n\t\t);\n\t}\n\n\t/**\n\t * Get a channel from a remote client. When passed a router,\n\t * one can specify which client it wants to call and listen to/from.\n\t * Otherwise, when calling without a router, a random client will\n\t * be selected and when listening without a router, every client\n\t * will be listened to.\n\t */\n\tgetChannel<T extends IChannel>(\n\t\tchannelName: string,\n\t\trouter: IClientRouter<TContext>,\n\t): T;\n\tgetChannel<T extends IChannel>(\n\t\tchannelName: string,\n\t\tclientFilter: (client: Client<TContext>) => boolean,\n\t): T;\n\tgetChannel<T extends IChannel>(\n\t\tchannelName: string,\n\t\trouterOrClientFilter:\n\t\t\t| IClientRouter<TContext>\n\t\t\t| ((client: Client<TContext>) => boolean),\n\t): T {\n\t\tconst that = this;\n\n\t\treturn {\n\t\t\tcall(\n\t\t\t\tcommand: string,\n\t\t\t\targ?: any,\n\t\t\t\tcancellationToken?: CancellationToken,\n\t\t\t): Promise<T> {\n\t\t\t\tlet connectionPromise: Promise<Client<TContext>>;\n\n\t\t\t\tif (isFunction(routerOrClientFilter)) {\n\t\t\t\t\t// when no router is provided, we go random client picking\n\t\t\t\t\tconst connection = getRandomElement(\n\t\t\t\t\t\tthat.connections.filter(routerOrClientFilter),\n\t\t\t\t\t);\n\n\t\t\t\t\tconnectionPromise = connection\n\t\t\t\t\t\t? // if we found a client, let's call on it\n\t\t\t\t\t\t\tPromise.resolve(connection)\n\t\t\t\t\t\t: // else, let's wait for a client to come along\n\t\t\t\t\t\t\tEvent.toPromise(\n\t\t\t\t\t\t\t\tEvent.filter(\n\t\t\t\t\t\t\t\t\tthat.onDidAddConnection,\n\t\t\t\t\t\t\t\t\trouterOrClientFilter,\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tconnectionPromise = routerOrClientFilter.routeCall(\n\t\t\t\t\t\tthat,\n\t\t\t\t\t\tcommand,\n\t\t\t\t\t\targ,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst channelPromise = connectionPromise.then((connection) =>\n\t\t\t\t\t(\n\t\t\t\t\t\tconnection as Connection<TContext>\n\t\t\t\t\t).channelClient.getChannel(channelName),\n\t\t\t\t);\n\n\t\t\t\treturn getDelayedChannel(channelPromise).call(\n\t\t\t\t\tcommand,\n\t\t\t\t\targ,\n\t\t\t\t\tcancellationToken,\n\t\t\t\t);\n\t\t\t},\n\t\t\tlisten(event: string, arg: any): Event<T> {\n\t\t\t\tif (isFunction(routerOrClientFilter)) {\n\t\t\t\t\treturn that.getMulticastEvent(\n\t\t\t\t\t\tchannelName,\n\t\t\t\t\t\trouterOrClientFilter,\n\t\t\t\t\t\tevent,\n\t\t\t\t\t\targ,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst channelPromise = routerOrClientFilter\n\t\t\t\t\t.routeEvent(that, event, arg)\n\t\t\t\t\t.then((connection) =>\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tconnection as Connection<TContext>\n\t\t\t\t\t\t).channelClient.getChannel(channelName),\n\t\t\t\t\t);\n\n\t\t\t\treturn getDelayedChannel(channelPromise).listen(event, arg);\n\t\t\t},\n\t\t} as T;\n\t}\n\n\tprivate getMulticastEvent<T extends IChannel>(\n\t\tchannelName: string,\n\t\tclientFilter: (client: Client<TContext>) => boolean,\n\t\teventName: string,\n\t\targ: any,\n\t): Event<T> {\n\t\tlet disposables: DisposableStore | undefined;\n\n\t\t// Create an emitter which hooks up to all clients\n\t\t// as soon as first listener is added. It also\n\t\t// disconnects from all clients as soon as the last listener\n\t\t// is removed.\n\t\tconst emitter = new Emitter<T>({\n\t\t\tonWillAddFirstListener: () => {\n\t\t\t\tdisposables = new DisposableStore();\n\n\t\t\t\t// The event multiplexer is useful since the active\n\t\t\t\t// client list is dynamic. We need to hook up and disconnection\n\t\t\t\t// to/from clients as they come and go.\n\t\t\t\tconst eventMultiplexer = new EventMultiplexer<T>();\n\t\t\t\tconst map = new Map<Connection<TContext>, IDisposable>();\n\n\t\t\t\tconst onDidAddConnection = (\n\t\t\t\t\tconnection: Connection<TContext>,\n\t\t\t\t) => {\n\t\t\t\t\tconst channel =\n\t\t\t\t\t\tconnection.channelClient.getChannel(channelName);\n\t\t\t\t\tconst event = channel.listen<T>(eventName, arg);\n\t\t\t\t\tconst disposable = eventMultiplexer.add(event);\n\n\t\t\t\t\tmap.set(connection, disposable);\n\t\t\t\t};\n\n\t\t\t\tconst onDidRemoveConnection = (\n\t\t\t\t\tconnection: Connection<TContext>,\n\t\t\t\t) => {\n\t\t\t\t\tconst disposable = map.get(connection);\n\n\t\t\t\t\tif (!disposable) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tdisposable.dispose();\n\t\t\t\t\tmap.delete(connection);\n\t\t\t\t};\n\n\t\t\t\tthis.connections\n\t\t\t\t\t.filter(clientFilter)\n\t\t\t\t\t.forEach(onDidAddConnection);\n\t\t\t\tEvent.filter(this.onDidAddConnection, clientFilter)(\n\t\t\t\t\tonDidAddConnection,\n\t\t\t\t\tundefined,\n\t\t\t\t\tdisposables,\n\t\t\t\t);\n\t\t\t\tthis.onDidRemoveConnection(\n\t\t\t\t\tonDidRemoveConnection,\n\t\t\t\t\tundefined,\n\t\t\t\t\tdisposables,\n\t\t\t\t);\n\t\t\t\teventMultiplexer.event(emitter.fire, emitter, disposables);\n\n\t\t\t\tdisposables.add(eventMultiplexer);\n\t\t\t},\n\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\tdisposables?.dispose();\n\t\t\t\tdisposables = undefined;\n\t\t\t},\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\tregisterChannel(\n\t\tchannelName: string,\n\t\tchannel: IServerChannel<TContext>,\n\t): void {\n\t\tthis.channels.set(channelName, channel);\n\n\t\tfor (const connection of this._connections) {\n\t\t\tconnection.channelServer.registerChannel(channelName, channel);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.disposables.dispose();\n\n\t\tfor (const connection of this._connections) {\n\t\t\tconnection.channelClient.dispose();\n\t\t\tconnection.channelServer.dispose();\n\t\t}\n\n\t\tthis._connections.clear();\n\t\tthis.channels.clear();\n\t\tthis._onDidAddConnection.dispose();\n\t\tthis._onDidRemoveConnection.dispose();\n\t}\n}\n\n/**\n * An `IPCClient` is both a channel client and a channel server.\n *\n * As the owner of a protocol, you should extend both this\n * and the `IPCServer` classes to get IPC implementations\n * for your protocol.\n */\nexport class IPCClient<TContext = string>\n\timplements IChannelClient, IChannelServer<TContext>, IDisposable\n{\n\tprivate channelClient: ChannelClient;\n\tprivate channelServer: ChannelServer<TContext>;\n\n\tconstructor(\n\t\tprotocol: IMessagePassingProtocol,\n\t\tctx: TContext,\n\t\tipcLogger: IIPCLogger | null = null,\n\t) {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, ctx);\n\t\tprotocol.send(writer.buffer);\n\n\t\tthis.channelClient = new ChannelClient(protocol, ipcLogger);\n\t\tthis.channelServer = new ChannelServer(protocol, ctx, ipcLogger);\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string): T {\n\t\treturn this.channelClient.getChannel(channelName) as T;\n\t}\n\n\tregisterChannel(\n\t\tchannelName: string,\n\t\tchannel: IServerChannel<TContext>,\n\t): void {\n\t\tthis.channelServer.registerChannel(channelName, channel);\n\t}\n\n\tdispose(): void {\n\t\tthis.channelClient.dispose();\n\t\tthis.channelServer.dispose();\n\t}\n}\n\nexport function getDelayedChannel<T extends IChannel>(promise: Promise<T>): T {\n\treturn {\n\t\tcall(\n\t\t\tcommand: string,\n\t\t\targ?: any,\n\t\t\tcancellationToken?: CancellationToken,\n\t\t): Promise<T> {\n\t\t\treturn promise.then((c) =>\n\t\t\t\tc.call<T>(command, arg, cancellationToken),\n\t\t\t);\n\t\t},\n\n\t\tlisten<T>(event: string, arg?: any): Event<T> {\n\t\t\tconst relay = new Relay<any>();\n\t\t\tpromise.then((c) => (relay.input = c.listen(event, arg)));\n\t\t\treturn relay.event;\n\t\t},\n\t} as T;\n}\n\nexport function getNextTickChannel<T extends IChannel>(channel: T): T {\n\tlet didTick = false;\n\n\treturn {\n\t\tcall<T>(\n\t\t\tcommand: string,\n\t\t\targ?: any,\n\t\t\tcancellationToken?: CancellationToken,\n\t\t): Promise<T> {\n\t\t\tif (didTick) {\n\t\t\t\treturn channel.call(command, arg, cancellationToken);\n\t\t\t}\n\n\t\t\treturn timeout(0)\n\t\t\t\t.then(() => (didTick = true))\n\t\t\t\t.then(() => channel.call<T>(command, arg, cancellationToken));\n\t\t},\n\t\tlisten<T>(event: string, arg?: any): Event<T> {\n\t\t\tif (didTick) {\n\t\t\t\treturn channel.listen<T>(event, arg);\n\t\t\t}\n\n\t\t\tconst relay = new Relay<T>();\n\n\t\t\ttimeout(0)\n\t\t\t\t.then(() => (didTick = true))\n\t\t\t\t.then(() => (relay.input = channel.listen<T>(event, arg)));\n\n\t\t\treturn relay.event;\n\t\t},\n\t} as T;\n}\n\nexport class StaticRouter<TContext = string>\n\timplements IClientRouter<TContext>\n{\n\tconstructor(private fn: (ctx: TContext) => boolean | Promise<boolean>) {}\n\n\trouteCall(hub: IConnectionHub<TContext>): Promise<Client<TContext>> {\n\t\treturn this.route(hub);\n\t}\n\n\trouteEvent(hub: IConnectionHub<TContext>): Promise<Client<TContext>> {\n\t\treturn this.route(hub);\n\t}\n\n\tprivate async route(\n\t\thub: IConnectionHub<TContext>,\n\t): Promise<Client<TContext>> {\n\t\tfor (const connection of hub.connections) {\n\t\t\tif (await Promise.resolve(this.fn(connection.ctx))) {\n\t\t\t\treturn Promise.resolve(connection);\n\t\t\t}\n\t\t}\n\n\t\tawait Event.toPromise(hub.onDidAddConnection);\n\t\treturn await this.route(hub);\n\t}\n}\n\n/**\n * Use ProxyChannels to automatically wrapping and unwrapping\n * services to/from IPC channels, instead of manually wrapping\n * each service method and event.\n *\n * Restrictions:\n * - If marshalling is enabled, only `URI` and `RegExp` is converted\n *   automatically for you\n * - Events must follow the naming convention `onUpperCase`\n * - `CancellationToken` is currently not supported\n * - If a context is provided, you can use `AddFirstParameterToFunctions`\n *   utility to signal this in the receiving side type\n */\nexport namespace ProxyChannel {\n\texport interface IProxyOptions {\n\t\t/**\n\t\t * Disables automatic marshalling of `URI`.\n\t\t * If marshalling is disabled, `UriComponents`\n\t\t * must be used instead.\n\t\t */\n\t\tdisableMarshalling?: boolean;\n\t}\n\n\texport interface ICreateServiceChannelOptions extends IProxyOptions {}\n\n\texport function fromService<TContext>(\n\t\tservice: unknown,\n\t\tdisposables: DisposableStore,\n\t\toptions?: ICreateServiceChannelOptions,\n\t): IServerChannel<TContext> {\n\t\tconst handler = service as { [key: string]: unknown };\n\t\tconst disableMarshalling = options && options.disableMarshalling;\n\n\t\t// Buffer any event that should be supported by\n\t\t// iterating over all property keys and finding them\n\t\t// However, this will not work for services that\n\t\t// are lazy and use a Proxy within. For that we\n\t\t// still need to check later (see below).\n\t\tconst mapEventNameToEvent = new Map<string, Event<unknown>>();\n\t\tfor (const key in handler) {\n\t\t\tif (propertyIsEvent(key)) {\n\t\t\t\tmapEventNameToEvent.set(\n\t\t\t\t\tkey,\n\t\t\t\t\tEvent.buffer(\n\t\t\t\t\t\thandler[key] as Event<unknown>,\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tdisposables,\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn new (class implements IServerChannel {\n\t\t\tlisten<T>(_: unknown, event: string, arg: any): Event<T> {\n\t\t\t\tconst eventImpl = mapEventNameToEvent.get(event);\n\t\t\t\tif (eventImpl) {\n\t\t\t\t\treturn eventImpl as Event<T>;\n\t\t\t\t}\n\n\t\t\t\tconst target = handler[event];\n\t\t\t\tif (typeof target === \"function\") {\n\t\t\t\t\tif (propertyIsDynamicEvent(event)) {\n\t\t\t\t\t\treturn target.call(handler, arg);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (propertyIsEvent(event)) {\n\t\t\t\t\t\tmapEventNameToEvent.set(\n\t\t\t\t\t\t\tevent,\n\t\t\t\t\t\t\tEvent.buffer(\n\t\t\t\t\t\t\t\thandler[event] as Event<unknown>,\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\tdisposables,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\treturn mapEventNameToEvent.get(event) as Event<T>;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthrow new ErrorNoTelemetry(`Event not found: ${event}`);\n\t\t\t}\n\n\t\t\tcall(_: unknown, command: string, args?: any[]): Promise<any> {\n\t\t\t\tconst target = handler[command];\n\t\t\t\tif (typeof target === \"function\") {\n\t\t\t\t\t// Revive unless marshalling disabled\n\t\t\t\t\tif (!disableMarshalling && Array.isArray(args)) {\n\t\t\t\t\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\t\t\t\t\targs[i] = revive(args[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlet res = target.apply(handler, args);\n\t\t\t\t\tif (!(res instanceof Promise)) {\n\t\t\t\t\t\tres = Promise.resolve(res);\n\t\t\t\t\t}\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\n\t\t\t\tthrow new ErrorNoTelemetry(`Method not found: ${command}`);\n\t\t\t}\n\t\t})();\n\t}\n\n\texport interface ICreateProxyServiceOptions extends IProxyOptions {\n\t\t/**\n\t\t * If provided, will add the value of `context`\n\t\t * to each method call to the target.\n\t\t */\n\t\tcontext?: unknown;\n\n\t\t/**\n\t\t * If provided, will not proxy any of the properties\n\t\t * that are part of the Map but rather return that value.\n\t\t */\n\t\tproperties?: Map<string, unknown>;\n\t}\n\n\texport function toService<T extends object>(\n\t\tchannel: IChannel,\n\t\toptions?: ICreateProxyServiceOptions,\n\t): T {\n\t\tconst disableMarshalling = options && options.disableMarshalling;\n\n\t\treturn new Proxy(\n\t\t\t{},\n\t\t\t{\n\t\t\t\tget(_target: T, propKey: PropertyKey) {\n\t\t\t\t\tif (typeof propKey === \"string\") {\n\t\t\t\t\t\t// Check for predefined values\n\t\t\t\t\t\tif (options?.properties?.has(propKey)) {\n\t\t\t\t\t\t\treturn options.properties.get(propKey);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Dynamic Event\n\t\t\t\t\t\tif (propertyIsDynamicEvent(propKey)) {\n\t\t\t\t\t\t\treturn (arg: any) => channel.listen(propKey, arg);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Event\n\t\t\t\t\t\tif (propertyIsEvent(propKey)) {\n\t\t\t\t\t\t\treturn channel.listen(propKey);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Function\n\t\t\t\t\t\treturn async (...args: any[]) => {\n\t\t\t\t\t\t\t// Add context if any\n\t\t\t\t\t\t\tlet methodArgs: any[];\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\toptions &&\n\t\t\t\t\t\t\t\t!isUndefinedOrNull(options.context)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tmethodArgs = [options.context, ...args];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tmethodArgs = args;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst result = await channel.call(\n\t\t\t\t\t\t\t\tpropKey,\n\t\t\t\t\t\t\t\tmethodArgs,\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// Revive unless marshalling disabled\n\t\t\t\t\t\t\tif (!disableMarshalling) {\n\t\t\t\t\t\t\t\treturn revive(result);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new ErrorNoTelemetry(\n\t\t\t\t\t\t`Property not found: ${String(propKey)}`,\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t},\n\t\t) as T;\n\t}\n\n\tfunction propertyIsEvent(name: string): boolean {\n\t\t// Assume a property is an event if it has a form of \"onSomething\"\n\t\treturn (\n\t\t\tname[0] === \"o\" &&\n\t\t\tname[1] === \"n\" &&\n\t\t\tstrings.isUpperAsciiLetter(name.charCodeAt(2))\n\t\t);\n\t}\n\n\tfunction propertyIsDynamicEvent(name: string): boolean {\n\t\t// Assume a property is a dynamic event (a method that returns an event) if it has a form of \"onDynamicSomething\"\n\t\treturn (\n\t\t\t/^onDynamic/.test(name) &&\n\t\t\tstrings.isUpperAsciiLetter(name.charCodeAt(9))\n\t\t);\n\t}\n}\n\nconst colorTables = [\n\t[\"#2977B1\", \"#FC802D\", \"#34A13A\", \"#D3282F\", \"#9366BA\"],\n\t[\"#8B564C\", \"#E177C0\", \"#7F7F7F\", \"#BBBE3D\", \"#2EBECD\"],\n];\n\nfunction prettyWithoutArrays(data: any): any {\n\tif (Array.isArray(data)) {\n\t\treturn data;\n\t}\n\tif (\n\t\tdata &&\n\t\ttypeof data === \"object\" &&\n\t\ttypeof data.toString === \"function\"\n\t) {\n\t\tconst result = data.toString();\n\t\tif (result !== \"[object Object]\") {\n\t\t\treturn result;\n\t\t}\n\t}\n\treturn data;\n}\n\nfunction pretty(data: any): any {\n\tif (Array.isArray(data)) {\n\t\treturn data.map(prettyWithoutArrays);\n\t}\n\treturn prettyWithoutArrays(data);\n}\n\nfunction logWithColors(\n\tdirection: string,\n\ttotalLength: number,\n\tmsgLength: number,\n\treq: number,\n\tinitiator: RequestInitiator,\n\tstr: string,\n\tdata: any,\n): void {\n\tdata = pretty(data);\n\n\tconst colorTable = colorTables[initiator];\n\tconst color = colorTable[req % colorTable.length];\n\tlet args = [\n\t\t`%c[${direction}]%c[${String(totalLength).padStart(7, \" \")}]%c[len: ${String(msgLength).padStart(5, \" \")}]%c${String(req).padStart(5, \" \")} - ${str}`,\n\t\t\"color: darkgreen\",\n\t\t\"color: grey\",\n\t\t\"color: grey\",\n\t\t`color: ${color}`,\n\t];\n\tif (/\\($/.test(str)) {\n\t\targs = args.concat(data);\n\t\targs.push(\")\");\n\t} else {\n\t\targs.push(data);\n\t}\n\tconsole.log.apply(console, args as [string, ...string[]]);\n}\n\nexport class IPCLogger implements IIPCLogger {\n\tprivate _totalIncoming = 0;\n\tprivate _totalOutgoing = 0;\n\n\tconstructor(\n\t\tprivate readonly _outgoingPrefix: string,\n\t\tprivate readonly _incomingPrefix: string,\n\t) {}\n\n\tpublic logOutgoing(\n\t\tmsgLength: number,\n\t\trequestId: number,\n\t\tinitiator: RequestInitiator,\n\t\tstr: string,\n\t\tdata?: any,\n\t): void {\n\t\tthis._totalOutgoing += msgLength;\n\t\tlogWithColors(\n\t\t\tthis._outgoingPrefix,\n\t\t\tthis._totalOutgoing,\n\t\t\tmsgLength,\n\t\t\trequestId,\n\t\t\tinitiator,\n\t\t\tstr,\n\t\t\tdata,\n\t\t);\n\t}\n\n\tpublic logIncoming(\n\t\tmsgLength: number,\n\t\trequestId: number,\n\t\tinitiator: RequestInitiator,\n\t\tstr: string,\n\t\tdata?: any,\n\t): void {\n\t\tthis._totalIncoming += msgLength;\n\t\tlogWithColors(\n\t\t\tthis._incomingPrefix,\n\t\t\tthis._totalIncoming,\n\t\t\tmsgLength,\n\t\t\trequestId,\n\t\t\tinitiator,\n\t\t\tstr,\n\t\t\tdata,\n\t\t);\n\t}\n}\n"],
  "mappings": "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",
  "names": ["RequestType", "ResponseType", "State", "DataType", "RequestInitiator", "ProxyChannel"]
}
