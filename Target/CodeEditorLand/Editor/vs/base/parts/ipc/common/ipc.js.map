{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/parts/ipc/common/ipc.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getRandomElement } from '../../../common/arrays.js';\nimport { CancelablePromise, createCancelablePromise, timeout } from '../../../common/async.js';\nimport { VSBuffer } from '../../../common/buffer.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../common/cancellation.js';\nimport { memoize } from '../../../common/decorators.js';\nimport { CancellationError, ErrorNoTelemetry } from '../../../common/errors.js';\nimport { Emitter, Event, EventMultiplexer, Relay } from '../../../common/event.js';\nimport { combinedDisposable, DisposableStore, dispose, IDisposable, toDisposable } from '../../../common/lifecycle.js';\nimport { revive } from '../../../common/marshalling.js';\nimport * as strings from '../../../common/strings.js';\nimport { isFunction, isUndefinedOrNull } from '../../../common/types.js';\n\n/**\n * An `IChannel` is an abstraction over a collection of commands.\n * You can `call` several commands on a channel, each taking at\n * most one single argument. A `call` always returns a promise\n * with at most one single return value.\n */\nexport interface IChannel {\n\tcall<T>(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T>;\n\tlisten<T>(event: string, arg?: any): Event<T>;\n}\n\n/**\n * An `IServerChannel` is the counter part to `IChannel`,\n * on the server-side. You should implement this interface\n * if you'd like to handle remote promises or events.\n */\nexport interface IServerChannel<TContext = string> {\n\tcall<T>(ctx: TContext, command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T>;\n\tlisten<T>(ctx: TContext, event: string, arg?: any): Event<T>;\n}\n\nconst enum RequestType {\n\tPromise = 100,\n\tPromiseCancel = 101,\n\tEventListen = 102,\n\tEventDispose = 103\n}\n\nfunction requestTypeToStr(type: RequestType): string {\n\tswitch (type) {\n\t\tcase RequestType.Promise:\n\t\t\treturn 'req';\n\t\tcase RequestType.PromiseCancel:\n\t\t\treturn 'cancel';\n\t\tcase RequestType.EventListen:\n\t\t\treturn 'subscribe';\n\t\tcase RequestType.EventDispose:\n\t\t\treturn 'unsubscribe';\n\t}\n}\n\ntype IRawPromiseRequest = { type: RequestType.Promise; id: number; channelName: string; name: string; arg: any };\ntype IRawPromiseCancelRequest = { type: RequestType.PromiseCancel; id: number };\ntype IRawEventListenRequest = { type: RequestType.EventListen; id: number; channelName: string; name: string; arg: any };\ntype IRawEventDisposeRequest = { type: RequestType.EventDispose; id: number };\ntype IRawRequest = IRawPromiseRequest | IRawPromiseCancelRequest | IRawEventListenRequest | IRawEventDisposeRequest;\n\nconst enum ResponseType {\n\tInitialize = 200,\n\tPromiseSuccess = 201,\n\tPromiseError = 202,\n\tPromiseErrorObj = 203,\n\tEventFire = 204\n}\n\nfunction responseTypeToStr(type: ResponseType): string {\n\tswitch (type) {\n\t\tcase ResponseType.Initialize:\n\t\t\treturn `init`;\n\t\tcase ResponseType.PromiseSuccess:\n\t\t\treturn `reply:`;\n\t\tcase ResponseType.PromiseError:\n\t\tcase ResponseType.PromiseErrorObj:\n\t\t\treturn `replyErr:`;\n\t\tcase ResponseType.EventFire:\n\t\t\treturn `event:`;\n\t}\n}\n\ntype IRawInitializeResponse = { type: ResponseType.Initialize };\ntype IRawPromiseSuccessResponse = { type: ResponseType.PromiseSuccess; id: number; data: any };\ntype IRawPromiseErrorResponse = { type: ResponseType.PromiseError; id: number; data: { message: string; name: string; stack: string[] | undefined } };\ntype IRawPromiseErrorObjResponse = { type: ResponseType.PromiseErrorObj; id: number; data: any };\ntype IRawEventFireResponse = { type: ResponseType.EventFire; id: number; data: any };\ntype IRawResponse = IRawInitializeResponse | IRawPromiseSuccessResponse | IRawPromiseErrorResponse | IRawPromiseErrorObjResponse | IRawEventFireResponse;\n\ninterface IHandler {\n\t(response: IRawResponse): void;\n}\n\nexport interface IMessagePassingProtocol {\n\tsend(buffer: VSBuffer): void;\n\tonMessage: Event<VSBuffer>;\n\t/**\n\t * Wait for the write buffer (if applicable) to become empty.\n\t */\n\tdrain?(): Promise<void>;\n}\n\nenum State {\n\tUninitialized,\n\tIdle\n}\n\n/**\n * An `IChannelServer` hosts a collection of channels. You are\n * able to register channels onto it, provided a channel name.\n */\nexport interface IChannelServer<TContext = string> {\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void;\n}\n\n/**\n * An `IChannelClient` has access to a collection of channels. You\n * are able to get those channels, given their channel name.\n */\nexport interface IChannelClient {\n\tgetChannel<T extends IChannel>(channelName: string): T;\n}\n\nexport interface Client<TContext> {\n\treadonly ctx: TContext;\n}\n\nexport interface IConnectionHub<TContext> {\n\treadonly connections: Connection<TContext>[];\n\treadonly onDidAddConnection: Event<Connection<TContext>>;\n\treadonly onDidRemoveConnection: Event<Connection<TContext>>;\n}\n\n/**\n * An `IClientRouter` is responsible for routing calls to specific\n * channels, in scenarios in which there are multiple possible\n * channels (each from a separate client) to pick from.\n */\nexport interface IClientRouter<TContext = string> {\n\trouteCall(hub: IConnectionHub<TContext>, command: string, arg?: any, cancellationToken?: CancellationToken): Promise<Client<TContext>>;\n\trouteEvent(hub: IConnectionHub<TContext>, event: string, arg?: any): Promise<Client<TContext>>;\n}\n\n/**\n * Similar to the `IChannelClient`, you can get channels from this\n * collection of channels. The difference being that in the\n * `IRoutingChannelClient`, there are multiple clients providing\n * the same channel. You'll need to pass in an `IClientRouter` in\n * order to pick the right one.\n */\nexport interface IRoutingChannelClient<TContext = string> {\n\tgetChannel<T extends IChannel>(channelName: string, router?: IClientRouter<TContext>): T;\n}\n\ninterface IReader {\n\tread(bytes: number): VSBuffer;\n}\n\ninterface IWriter {\n\twrite(buffer: VSBuffer): void;\n}\n\n\n/**\n * @see https://en.wikipedia.org/wiki/Variable-length_quantity\n */\nfunction readIntVQL(reader: IReader) {\n\tlet value = 0;\n\tfor (let n = 0; ; n += 7) {\n\t\tconst next = reader.read(1);\n\t\tvalue |= (next.buffer[0] & 0b01111111) << n;\n\t\tif (!(next.buffer[0] & 0b10000000)) {\n\t\t\treturn value;\n\t\t}\n\t}\n}\n\nconst vqlZero = createOneByteBuffer(0);\n\n/**\n * @see https://en.wikipedia.org/wiki/Variable-length_quantity\n */\nfunction writeInt32VQL(writer: IWriter, value: number) {\n\tif (value === 0) {\n\t\twriter.write(vqlZero);\n\t\treturn;\n\t}\n\n\tlet len = 0;\n\tfor (let v2 = value; v2 !== 0; v2 = v2 >>> 7) {\n\t\tlen++;\n\t}\n\n\tconst scratch = VSBuffer.alloc(len);\n\tfor (let i = 0; value !== 0; i++) {\n\t\tscratch.buffer[i] = value & 0b01111111;\n\t\tvalue = value >>> 7;\n\t\tif (value > 0) {\n\t\t\tscratch.buffer[i] |= 0b10000000;\n\t\t}\n\t}\n\n\twriter.write(scratch);\n}\n\nexport class BufferReader implements IReader {\n\n\tprivate pos = 0;\n\n\tconstructor(private buffer: VSBuffer) { }\n\n\tread(bytes: number): VSBuffer {\n\t\tconst result = this.buffer.slice(this.pos, this.pos + bytes);\n\t\tthis.pos += result.byteLength;\n\t\treturn result;\n\t}\n}\n\nexport class BufferWriter implements IWriter {\n\n\tprivate buffers: VSBuffer[] = [];\n\n\tget buffer(): VSBuffer {\n\t\treturn VSBuffer.concat(this.buffers);\n\t}\n\n\twrite(buffer: VSBuffer): void {\n\t\tthis.buffers.push(buffer);\n\t}\n}\n\nenum DataType {\n\tUndefined = 0,\n\tString = 1,\n\tBuffer = 2,\n\tVSBuffer = 3,\n\tArray = 4,\n\tObject = 5,\n\tInt = 6\n}\n\nfunction createOneByteBuffer(value: number): VSBuffer {\n\tconst result = VSBuffer.alloc(1);\n\tresult.writeUInt8(value, 0);\n\treturn result;\n}\n\nconst BufferPresets = {\n\tUndefined: createOneByteBuffer(DataType.Undefined),\n\tString: createOneByteBuffer(DataType.String),\n\tBuffer: createOneByteBuffer(DataType.Buffer),\n\tVSBuffer: createOneByteBuffer(DataType.VSBuffer),\n\tArray: createOneByteBuffer(DataType.Array),\n\tObject: createOneByteBuffer(DataType.Object),\n\tUint: createOneByteBuffer(DataType.Int),\n};\n\ndeclare const Buffer: any;\nconst hasBuffer = (typeof Buffer !== 'undefined');\n\nexport function serialize(writer: IWriter, data: any): void {\n\tif (typeof data === 'undefined') {\n\t\twriter.write(BufferPresets.Undefined);\n\t} else if (typeof data === 'string') {\n\t\tconst buffer = VSBuffer.fromString(data);\n\t\twriter.write(BufferPresets.String);\n\t\twriteInt32VQL(writer, buffer.byteLength);\n\t\twriter.write(buffer);\n\t} else if (hasBuffer && Buffer.isBuffer(data)) {\n\t\tconst buffer = VSBuffer.wrap(data);\n\t\twriter.write(BufferPresets.Buffer);\n\t\twriteInt32VQL(writer, buffer.byteLength);\n\t\twriter.write(buffer);\n\t} else if (data instanceof VSBuffer) {\n\t\twriter.write(BufferPresets.VSBuffer);\n\t\twriteInt32VQL(writer, data.byteLength);\n\t\twriter.write(data);\n\t} else if (Array.isArray(data)) {\n\t\twriter.write(BufferPresets.Array);\n\t\twriteInt32VQL(writer, data.length);\n\n\t\tfor (const el of data) {\n\t\t\tserialize(writer, el);\n\t\t}\n\t} else if (typeof data === 'number' && (data | 0) === data) {\n\t\t// write a vql if it's a number that we can do bitwise operations on\n\t\twriter.write(BufferPresets.Uint);\n\t\twriteInt32VQL(writer, data);\n\t} else {\n\t\tconst buffer = VSBuffer.fromString(JSON.stringify(data));\n\t\twriter.write(BufferPresets.Object);\n\t\twriteInt32VQL(writer, buffer.byteLength);\n\t\twriter.write(buffer);\n\t}\n}\n\nexport function deserialize(reader: IReader): any {\n\tconst type = reader.read(1).readUInt8(0);\n\n\tswitch (type) {\n\t\tcase DataType.Undefined: return undefined;\n\t\tcase DataType.String: return reader.read(readIntVQL(reader)).toString();\n\t\tcase DataType.Buffer: return reader.read(readIntVQL(reader)).buffer;\n\t\tcase DataType.VSBuffer: return reader.read(readIntVQL(reader));\n\t\tcase DataType.Array: {\n\t\t\tconst length = readIntVQL(reader);\n\t\t\tconst result: any[] = [];\n\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tresult.push(deserialize(reader));\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t\tcase DataType.Object: return JSON.parse(reader.read(readIntVQL(reader)).toString());\n\t\tcase DataType.Int: return readIntVQL(reader);\n\t}\n}\n\ninterface PendingRequest {\n\trequest: IRawPromiseRequest | IRawEventListenRequest;\n\ttimeoutTimer: any;\n}\n\nexport class ChannelServer<TContext = string> implements IChannelServer<TContext>, IDisposable {\n\n\tprivate channels = new Map<string, IServerChannel<TContext>>();\n\tprivate activeRequests = new Map<number, IDisposable>();\n\tprivate protocolListener: IDisposable | null;\n\n\t// Requests might come in for channels which are not yet registered.\n\t// They will timeout after `timeoutDelay`.\n\tprivate pendingRequests = new Map<string, PendingRequest[]>();\n\n\tconstructor(private protocol: IMessagePassingProtocol, private ctx: TContext, private logger: IIPCLogger | null = null, private timeoutDelay: number = 1000) {\n\t\tthis.protocolListener = this.protocol.onMessage(msg => this.onRawMessage(msg));\n\t\tthis.sendResponse({ type: ResponseType.Initialize });\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void {\n\t\tthis.channels.set(channelName, channel);\n\n\t\t// https://github.com/microsoft/vscode/issues/72531\n\t\tsetTimeout(() => this.flushPendingRequests(channelName), 0);\n\t}\n\n\tprivate sendResponse(response: IRawResponse): void {\n\t\tswitch (response.type) {\n\t\t\tcase ResponseType.Initialize: {\n\t\t\t\tconst msgLength = this.send([response.type]);\n\t\t\t\tthis.logger?.logOutgoing(msgLength, 0, RequestInitiator.OtherSide, responseTypeToStr(response.type));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\tcase ResponseType.PromiseError:\n\t\t\tcase ResponseType.EventFire:\n\t\t\tcase ResponseType.PromiseErrorObj: {\n\t\t\t\tconst msgLength = this.send([response.type, response.id], response.data);\n\t\t\t\tthis.logger?.logOutgoing(msgLength, response.id, RequestInitiator.OtherSide, responseTypeToStr(response.type), response.data);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate send(header: any, body: any = undefined): number {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, header);\n\t\tserialize(writer, body);\n\t\treturn this.sendBuffer(writer.buffer);\n\t}\n\n\tprivate sendBuffer(message: VSBuffer): number {\n\t\ttry {\n\t\t\tthis.protocol.send(message);\n\t\t\treturn message.byteLength;\n\t\t} catch (err) {\n\t\t\t// noop\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tprivate onRawMessage(message: VSBuffer): void {\n\t\tconst reader = new BufferReader(message);\n\t\tconst header = deserialize(reader);\n\t\tconst body = deserialize(reader);\n\t\tconst type = header[0] as RequestType;\n\n\t\tswitch (type) {\n\t\t\tcase RequestType.Promise:\n\t\t\t\tthis.logger?.logIncoming(message.byteLength, header[1], RequestInitiator.OtherSide, `${requestTypeToStr(type)}: ${header[2]}.${header[3]}`, body);\n\t\t\t\treturn this.onPromise({ type, id: header[1], channelName: header[2], name: header[3], arg: body });\n\t\t\tcase RequestType.EventListen:\n\t\t\t\tthis.logger?.logIncoming(message.byteLength, header[1], RequestInitiator.OtherSide, `${requestTypeToStr(type)}: ${header[2]}.${header[3]}`, body);\n\t\t\t\treturn this.onEventListen({ type, id: header[1], channelName: header[2], name: header[3], arg: body });\n\t\t\tcase RequestType.PromiseCancel:\n\t\t\t\tthis.logger?.logIncoming(message.byteLength, header[1], RequestInitiator.OtherSide, `${requestTypeToStr(type)}`);\n\t\t\t\treturn this.disposeActiveRequest({ type, id: header[1] });\n\t\t\tcase RequestType.EventDispose:\n\t\t\t\tthis.logger?.logIncoming(message.byteLength, header[1], RequestInitiator.OtherSide, `${requestTypeToStr(type)}`);\n\t\t\t\treturn this.disposeActiveRequest({ type, id: header[1] });\n\t\t}\n\t}\n\n\tprivate onPromise(request: IRawPromiseRequest): void {\n\t\tconst channel = this.channels.get(request.channelName);\n\n\t\tif (!channel) {\n\t\t\tthis.collectPendingRequest(request);\n\t\t\treturn;\n\t\t}\n\n\t\tconst cancellationTokenSource = new CancellationTokenSource();\n\t\tlet promise: Promise<any>;\n\n\t\ttry {\n\t\t\tpromise = channel.call(this.ctx, request.name, request.arg, cancellationTokenSource.token);\n\t\t} catch (err) {\n\t\t\tpromise = Promise.reject(err);\n\t\t}\n\n\t\tconst id = request.id;\n\n\t\tpromise.then(data => {\n\t\t\tthis.sendResponse({ id, data, type: ResponseType.PromiseSuccess });\n\t\t}, err => {\n\t\t\tif (err instanceof Error) {\n\t\t\t\tthis.sendResponse({\n\t\t\t\t\tid, data: {\n\t\t\t\t\t\tmessage: err.message,\n\t\t\t\t\t\tname: err.name,\n\t\t\t\t\t\tstack: err.stack ? err.stack.split('\\n') : undefined\n\t\t\t\t\t}, type: ResponseType.PromiseError\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.sendResponse({ id, data: err, type: ResponseType.PromiseErrorObj });\n\t\t\t}\n\t\t}).finally(() => {\n\t\t\tdisposable.dispose();\n\t\t\tthis.activeRequests.delete(request.id);\n\t\t});\n\n\t\tconst disposable = toDisposable(() => cancellationTokenSource.cancel());\n\t\tthis.activeRequests.set(request.id, disposable);\n\t}\n\n\tprivate onEventListen(request: IRawEventListenRequest): void {\n\t\tconst channel = this.channels.get(request.channelName);\n\n\t\tif (!channel) {\n\t\t\tthis.collectPendingRequest(request);\n\t\t\treturn;\n\t\t}\n\n\t\tconst id = request.id;\n\t\tconst event = channel.listen(this.ctx, request.name, request.arg);\n\t\tconst disposable = event(data => this.sendResponse({ id, data, type: ResponseType.EventFire }));\n\n\t\tthis.activeRequests.set(request.id, disposable);\n\t}\n\n\tprivate disposeActiveRequest(request: IRawRequest): void {\n\t\tconst disposable = this.activeRequests.get(request.id);\n\n\t\tif (disposable) {\n\t\t\tdisposable.dispose();\n\t\t\tthis.activeRequests.delete(request.id);\n\t\t}\n\t}\n\n\tprivate collectPendingRequest(request: IRawPromiseRequest | IRawEventListenRequest): void {\n\t\tlet pendingRequests = this.pendingRequests.get(request.channelName);\n\n\t\tif (!pendingRequests) {\n\t\t\tpendingRequests = [];\n\t\t\tthis.pendingRequests.set(request.channelName, pendingRequests);\n\t\t}\n\n\t\tconst timer = setTimeout(() => {\n\t\t\tconsole.error(`Unknown channel: ${request.channelName}`);\n\n\t\t\tif (request.type === RequestType.Promise) {\n\t\t\t\tthis.sendResponse({\n\t\t\t\t\tid: request.id,\n\t\t\t\t\tdata: { name: 'Unknown channel', message: `Channel name '${request.channelName}' timed out after ${this.timeoutDelay}ms`, stack: undefined },\n\t\t\t\t\ttype: ResponseType.PromiseError\n\t\t\t\t});\n\t\t\t}\n\t\t}, this.timeoutDelay);\n\n\t\tpendingRequests.push({ request, timeoutTimer: timer });\n\t}\n\n\tprivate flushPendingRequests(channelName: string): void {\n\t\tconst requests = this.pendingRequests.get(channelName);\n\n\t\tif (requests) {\n\t\t\tfor (const request of requests) {\n\t\t\t\tclearTimeout(request.timeoutTimer);\n\n\t\t\t\tswitch (request.request.type) {\n\t\t\t\t\tcase RequestType.Promise: this.onPromise(request.request); break;\n\t\t\t\t\tcase RequestType.EventListen: this.onEventListen(request.request); break;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.pendingRequests.delete(channelName);\n\t\t}\n\t}\n\n\tpublic dispose(): void {\n\t\tif (this.protocolListener) {\n\t\t\tthis.protocolListener.dispose();\n\t\t\tthis.protocolListener = null;\n\t\t}\n\t\tdispose(this.activeRequests.values());\n\t\tthis.activeRequests.clear();\n\t}\n}\n\nexport const enum RequestInitiator {\n\tLocalSide = 0,\n\tOtherSide = 1\n}\n\nexport interface IIPCLogger {\n\tlogIncoming(msgLength: number, requestId: number, initiator: RequestInitiator, str: string, data?: any): void;\n\tlogOutgoing(msgLength: number, requestId: number, initiator: RequestInitiator, str: string, data?: any): void;\n}\n\nexport class ChannelClient implements IChannelClient, IDisposable {\n\n\tprivate isDisposed: boolean = false;\n\tprivate state: State = State.Uninitialized;\n\tprivate activeRequests = new Set<IDisposable>();\n\tprivate handlers = new Map<number, IHandler>();\n\tprivate lastRequestId: number = 0;\n\tprivate protocolListener: IDisposable | null;\n\tprivate logger: IIPCLogger | null;\n\n\tprivate readonly _onDidInitialize = new Emitter<void>();\n\treadonly onDidInitialize = this._onDidInitialize.event;\n\n\tconstructor(private protocol: IMessagePassingProtocol, logger: IIPCLogger | null = null) {\n\t\tthis.protocolListener = this.protocol.onMessage(msg => this.onBuffer(msg));\n\t\tthis.logger = logger;\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string): T {\n\t\tconst that = this;\n\n\t\treturn {\n\t\t\tcall(command: string, arg?: any, cancellationToken?: CancellationToken) {\n\t\t\t\tif (that.isDisposed) {\n\t\t\t\t\treturn Promise.reject(new CancellationError());\n\t\t\t\t}\n\t\t\t\treturn that.requestPromise(channelName, command, arg, cancellationToken);\n\t\t\t},\n\t\t\tlisten(event: string, arg: any) {\n\t\t\t\tif (that.isDisposed) {\n\t\t\t\t\treturn Event.None;\n\t\t\t\t}\n\t\t\t\treturn that.requestEvent(channelName, event, arg);\n\t\t\t}\n\t\t} as T;\n\t}\n\n\tprivate requestPromise(channelName: string, name: string, arg?: any, cancellationToken = CancellationToken.None): Promise<any> {\n\t\tconst id = this.lastRequestId++;\n\t\tconst type = RequestType.Promise;\n\t\tconst request: IRawRequest = { id, type, channelName, name, arg };\n\n\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\treturn Promise.reject(new CancellationError());\n\t\t}\n\n\t\tlet disposable: IDisposable;\n\n\t\tconst result = new Promise((c, e) => {\n\t\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\t\treturn e(new CancellationError());\n\t\t\t}\n\n\t\t\tconst doRequest = () => {\n\t\t\t\tconst handler: IHandler = response => {\n\t\t\t\t\tswitch (response.type) {\n\t\t\t\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\tc(response.data);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase ResponseType.PromiseError: {\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\tconst error = new Error(response.data.message);\n\t\t\t\t\t\t\t(<any>error).stack = Array.isArray(response.data.stack) ? response.data.stack.join('\\n') : response.data.stack;\n\t\t\t\t\t\t\terror.name = response.data.name;\n\t\t\t\t\t\t\te(error);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase ResponseType.PromiseErrorObj:\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\te(response.data);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tthis.handlers.set(id, handler);\n\t\t\t\tthis.sendRequest(request);\n\t\t\t};\n\n\t\t\tlet uninitializedPromise: CancelablePromise<void> | null = null;\n\t\t\tif (this.state === State.Idle) {\n\t\t\t\tdoRequest();\n\t\t\t} else {\n\t\t\t\tuninitializedPromise = createCancelablePromise(_ => this.whenInitialized());\n\t\t\t\tuninitializedPromise.then(() => {\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t\tdoRequest();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst cancel = () => {\n\t\t\t\tif (uninitializedPromise) {\n\t\t\t\t\tuninitializedPromise.cancel();\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t} else {\n\t\t\t\t\tthis.sendRequest({ id, type: RequestType.PromiseCancel });\n\t\t\t\t}\n\n\t\t\t\te(new CancellationError());\n\t\t\t};\n\n\t\t\tconst cancellationTokenListener = cancellationToken.onCancellationRequested(cancel);\n\t\t\tdisposable = combinedDisposable(toDisposable(cancel), cancellationTokenListener);\n\t\t\tthis.activeRequests.add(disposable);\n\t\t});\n\n\t\treturn result.finally(() => {\n\t\t\tdisposable.dispose();\n\t\t\tthis.activeRequests.delete(disposable);\n\t\t});\n\t}\n\n\tprivate requestEvent(channelName: string, name: string, arg?: any): Event<any> {\n\t\tconst id = this.lastRequestId++;\n\t\tconst type = RequestType.EventListen;\n\t\tconst request: IRawRequest = { id, type, channelName, name, arg };\n\n\t\tlet uninitializedPromise: CancelablePromise<void> | null = null;\n\n\t\tconst emitter = new Emitter<any>({\n\t\t\tonWillAddFirstListener: () => {\n\t\t\t\tuninitializedPromise = createCancelablePromise(_ => this.whenInitialized());\n\t\t\t\tuninitializedPromise.then(() => {\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t\tthis.activeRequests.add(emitter);\n\t\t\t\t\tthis.sendRequest(request);\n\t\t\t\t});\n\t\t\t},\n\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\tif (uninitializedPromise) {\n\t\t\t\t\tuninitializedPromise.cancel();\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t} else {\n\t\t\t\t\tthis.activeRequests.delete(emitter);\n\t\t\t\t\tthis.sendRequest({ id, type: RequestType.EventDispose });\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tconst handler: IHandler = (res: IRawResponse) => emitter.fire((res as IRawEventFireResponse).data);\n\t\tthis.handlers.set(id, handler);\n\n\t\treturn emitter.event;\n\t}\n\n\tprivate sendRequest(request: IRawRequest): void {\n\t\tswitch (request.type) {\n\t\t\tcase RequestType.Promise:\n\t\t\tcase RequestType.EventListen: {\n\t\t\t\tconst msgLength = this.send([request.type, request.id, request.channelName, request.name], request.arg);\n\t\t\t\tthis.logger?.logOutgoing(msgLength, request.id, RequestInitiator.LocalSide, `${requestTypeToStr(request.type)}: ${request.channelName}.${request.name}`, request.arg);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcase RequestType.PromiseCancel:\n\t\t\tcase RequestType.EventDispose: {\n\t\t\t\tconst msgLength = this.send([request.type, request.id]);\n\t\t\t\tthis.logger?.logOutgoing(msgLength, request.id, RequestInitiator.LocalSide, requestTypeToStr(request.type));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate send(header: any, body: any = undefined): number {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, header);\n\t\tserialize(writer, body);\n\t\treturn this.sendBuffer(writer.buffer);\n\t}\n\n\tprivate sendBuffer(message: VSBuffer): number {\n\t\ttry {\n\t\t\tthis.protocol.send(message);\n\t\t\treturn message.byteLength;\n\t\t} catch (err) {\n\t\t\t// noop\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tprivate onBuffer(message: VSBuffer): void {\n\t\tconst reader = new BufferReader(message);\n\t\tconst header = deserialize(reader);\n\t\tconst body = deserialize(reader);\n\t\tconst type: ResponseType = header[0];\n\n\t\tswitch (type) {\n\t\t\tcase ResponseType.Initialize:\n\t\t\t\tthis.logger?.logIncoming(message.byteLength, 0, RequestInitiator.LocalSide, responseTypeToStr(type));\n\t\t\t\treturn this.onResponse({ type: header[0] });\n\n\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\tcase ResponseType.PromiseError:\n\t\t\tcase ResponseType.EventFire:\n\t\t\tcase ResponseType.PromiseErrorObj:\n\t\t\t\tthis.logger?.logIncoming(message.byteLength, header[1], RequestInitiator.LocalSide, responseTypeToStr(type), body);\n\t\t\t\treturn this.onResponse({ type: header[0], id: header[1], data: body });\n\t\t}\n\t}\n\n\tprivate onResponse(response: IRawResponse): void {\n\t\tif (response.type === ResponseType.Initialize) {\n\t\t\tthis.state = State.Idle;\n\t\t\tthis._onDidInitialize.fire();\n\t\t\treturn;\n\t\t}\n\n\t\tconst handler = this.handlers.get(response.id);\n\n\t\thandler?.(response);\n\t}\n\n\t@memoize\n\tget onDidInitializePromise(): Promise<void> {\n\t\treturn Event.toPromise(this.onDidInitialize);\n\t}\n\n\tprivate whenInitialized(): Promise<void> {\n\t\tif (this.state === State.Idle) {\n\t\t\treturn Promise.resolve();\n\t\t} else {\n\t\t\treturn this.onDidInitializePromise;\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.isDisposed = true;\n\t\tif (this.protocolListener) {\n\t\t\tthis.protocolListener.dispose();\n\t\t\tthis.protocolListener = null;\n\t\t}\n\t\tdispose(this.activeRequests.values());\n\t\tthis.activeRequests.clear();\n\t}\n}\n\nexport interface ClientConnectionEvent {\n\tprotocol: IMessagePassingProtocol;\n\tonDidClientDisconnect: Event<void>;\n}\n\ninterface Connection<TContext> extends Client<TContext> {\n\treadonly channelServer: ChannelServer<TContext>;\n\treadonly channelClient: ChannelClient;\n}\n\n/**\n * An `IPCServer` is both a channel server and a routing channel\n * client.\n *\n * As the owner of a protocol, you should extend both this\n * and the `IPCClient` classes to get IPC implementations\n * for your protocol.\n */\nexport class IPCServer<TContext = string> implements IChannelServer<TContext>, IRoutingChannelClient<TContext>, IConnectionHub<TContext>, IDisposable {\n\n\tprivate channels = new Map<string, IServerChannel<TContext>>();\n\tprivate _connections = new Set<Connection<TContext>>();\n\n\tprivate readonly _onDidAddConnection = new Emitter<Connection<TContext>>();\n\treadonly onDidAddConnection: Event<Connection<TContext>> = this._onDidAddConnection.event;\n\n\tprivate readonly _onDidRemoveConnection = new Emitter<Connection<TContext>>();\n\treadonly onDidRemoveConnection: Event<Connection<TContext>> = this._onDidRemoveConnection.event;\n\n\tprivate readonly disposables = new DisposableStore();\n\n\tget connections(): Connection<TContext>[] {\n\t\tconst result: Connection<TContext>[] = [];\n\t\tthis._connections.forEach(ctx => result.push(ctx));\n\t\treturn result;\n\t}\n\n\tconstructor(onDidClientConnect: Event<ClientConnectionEvent>, ipcLogger?: IIPCLogger | null, timeoutDelay?: number) {\n\t\tthis.disposables.add(onDidClientConnect(({ protocol, onDidClientDisconnect }) => {\n\t\t\tconst onFirstMessage = Event.once(protocol.onMessage);\n\n\t\t\tthis.disposables.add(onFirstMessage(msg => {\n\t\t\t\tconst reader = new BufferReader(msg);\n\t\t\t\tconst ctx = deserialize(reader) as TContext;\n\n\t\t\t\tconst channelServer = new ChannelServer(protocol, ctx, ipcLogger, timeoutDelay);\n\t\t\t\tconst channelClient = new ChannelClient(protocol, ipcLogger);\n\n\t\t\t\tthis.channels.forEach((channel, name) => channelServer.registerChannel(name, channel));\n\n\t\t\t\tconst connection: Connection<TContext> = { channelServer, channelClient, ctx };\n\t\t\t\tthis._connections.add(connection);\n\t\t\t\tthis._onDidAddConnection.fire(connection);\n\n\t\t\t\tthis.disposables.add(onDidClientDisconnect(() => {\n\t\t\t\t\tchannelServer.dispose();\n\t\t\t\t\tchannelClient.dispose();\n\t\t\t\t\tthis._connections.delete(connection);\n\t\t\t\t\tthis._onDidRemoveConnection.fire(connection);\n\t\t\t\t}));\n\t\t\t}));\n\t\t}));\n\t}\n\n\t/**\n\t * Get a channel from a remote client. When passed a router,\n\t * one can specify which client it wants to call and listen to/from.\n\t * Otherwise, when calling without a router, a random client will\n\t * be selected and when listening without a router, every client\n\t * will be listened to.\n\t */\n\tgetChannel<T extends IChannel>(channelName: string, router: IClientRouter<TContext>): T;\n\tgetChannel<T extends IChannel>(channelName: string, clientFilter: (client: Client<TContext>) => boolean): T;\n\tgetChannel<T extends IChannel>(channelName: string, routerOrClientFilter: IClientRouter<TContext> | ((client: Client<TContext>) => boolean)): T {\n\t\tconst that = this;\n\n\t\treturn {\n\t\t\tcall(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T> {\n\t\t\t\tlet connectionPromise: Promise<Client<TContext>>;\n\n\t\t\t\tif (isFunction(routerOrClientFilter)) {\n\t\t\t\t\t// when no router is provided, we go random client picking\n\t\t\t\t\tconst connection = getRandomElement(that.connections.filter(routerOrClientFilter));\n\n\t\t\t\t\tconnectionPromise = connection\n\t\t\t\t\t\t// if we found a client, let's call on it\n\t\t\t\t\t\t? Promise.resolve(connection)\n\t\t\t\t\t\t// else, let's wait for a client to come along\n\t\t\t\t\t\t: Event.toPromise(Event.filter(that.onDidAddConnection, routerOrClientFilter));\n\t\t\t\t} else {\n\t\t\t\t\tconnectionPromise = routerOrClientFilter.routeCall(that, command, arg);\n\t\t\t\t}\n\n\t\t\t\tconst channelPromise = connectionPromise\n\t\t\t\t\t.then(connection => (connection as Connection<TContext>).channelClient.getChannel(channelName));\n\n\t\t\t\treturn getDelayedChannel(channelPromise)\n\t\t\t\t\t.call(command, arg, cancellationToken);\n\t\t\t},\n\t\t\tlisten(event: string, arg: any): Event<T> {\n\t\t\t\tif (isFunction(routerOrClientFilter)) {\n\t\t\t\t\treturn that.getMulticastEvent(channelName, routerOrClientFilter, event, arg);\n\t\t\t\t}\n\n\t\t\t\tconst channelPromise = routerOrClientFilter.routeEvent(that, event, arg)\n\t\t\t\t\t.then(connection => (connection as Connection<TContext>).channelClient.getChannel(channelName));\n\n\t\t\t\treturn getDelayedChannel(channelPromise)\n\t\t\t\t\t.listen(event, arg);\n\t\t\t}\n\t\t} as T;\n\t}\n\n\tprivate getMulticastEvent<T extends IChannel>(channelName: string, clientFilter: (client: Client<TContext>) => boolean, eventName: string, arg: any): Event<T> {\n\t\tconst that = this;\n\t\tlet disposables: DisposableStore | undefined;\n\n\t\t// Create an emitter which hooks up to all clients\n\t\t// as soon as first listener is added. It also\n\t\t// disconnects from all clients as soon as the last listener\n\t\t// is removed.\n\t\tconst emitter = new Emitter<T>({\n\t\t\tonWillAddFirstListener: () => {\n\t\t\t\tdisposables = new DisposableStore();\n\n\t\t\t\t// The event multiplexer is useful since the active\n\t\t\t\t// client list is dynamic. We need to hook up and disconnection\n\t\t\t\t// to/from clients as they come and go.\n\t\t\t\tconst eventMultiplexer = new EventMultiplexer<T>();\n\t\t\t\tconst map = new Map<Connection<TContext>, IDisposable>();\n\n\t\t\t\tconst onDidAddConnection = (connection: Connection<TContext>) => {\n\t\t\t\t\tconst channel = connection.channelClient.getChannel(channelName);\n\t\t\t\t\tconst event = channel.listen<T>(eventName, arg);\n\t\t\t\t\tconst disposable = eventMultiplexer.add(event);\n\n\t\t\t\t\tmap.set(connection, disposable);\n\t\t\t\t};\n\n\t\t\t\tconst onDidRemoveConnection = (connection: Connection<TContext>) => {\n\t\t\t\t\tconst disposable = map.get(connection);\n\n\t\t\t\t\tif (!disposable) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tdisposable.dispose();\n\t\t\t\t\tmap.delete(connection);\n\t\t\t\t};\n\n\t\t\t\tthat.connections.filter(clientFilter).forEach(onDidAddConnection);\n\t\t\t\tEvent.filter(that.onDidAddConnection, clientFilter)(onDidAddConnection, undefined, disposables);\n\t\t\t\tthat.onDidRemoveConnection(onDidRemoveConnection, undefined, disposables);\n\t\t\t\teventMultiplexer.event(emitter.fire, emitter, disposables);\n\n\t\t\t\tdisposables.add(eventMultiplexer);\n\t\t\t},\n\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\tdisposables?.dispose();\n\t\t\t\tdisposables = undefined;\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void {\n\t\tthis.channels.set(channelName, channel);\n\n\t\tfor (const connection of this._connections) {\n\t\t\tconnection.channelServer.registerChannel(channelName, channel);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.disposables.dispose();\n\n\t\tfor (const connection of this._connections) {\n\t\t\tconnection.channelClient.dispose();\n\t\t\tconnection.channelServer.dispose();\n\t\t}\n\n\t\tthis._connections.clear();\n\t\tthis.channels.clear();\n\t\tthis._onDidAddConnection.dispose();\n\t\tthis._onDidRemoveConnection.dispose();\n\t}\n}\n\n/**\n * An `IPCClient` is both a channel client and a channel server.\n *\n * As the owner of a protocol, you should extend both this\n * and the `IPCServer` classes to get IPC implementations\n * for your protocol.\n */\nexport class IPCClient<TContext = string> implements IChannelClient, IChannelServer<TContext>, IDisposable {\n\n\tprivate channelClient: ChannelClient;\n\tprivate channelServer: ChannelServer<TContext>;\n\n\tconstructor(protocol: IMessagePassingProtocol, ctx: TContext, ipcLogger: IIPCLogger | null = null) {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, ctx);\n\t\tprotocol.send(writer.buffer);\n\n\t\tthis.channelClient = new ChannelClient(protocol, ipcLogger);\n\t\tthis.channelServer = new ChannelServer(protocol, ctx, ipcLogger);\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string): T {\n\t\treturn this.channelClient.getChannel(channelName) as T;\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void {\n\t\tthis.channelServer.registerChannel(channelName, channel);\n\t}\n\n\tdispose(): void {\n\t\tthis.channelClient.dispose();\n\t\tthis.channelServer.dispose();\n\t}\n}\n\nexport function getDelayedChannel<T extends IChannel>(promise: Promise<T>): T {\n\treturn {\n\t\tcall(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T> {\n\t\t\treturn promise.then(c => c.call<T>(command, arg, cancellationToken));\n\t\t},\n\n\t\tlisten<T>(event: string, arg?: any): Event<T> {\n\t\t\tconst relay = new Relay<any>();\n\t\t\tpromise.then(c => relay.input = c.listen(event, arg));\n\t\t\treturn relay.event;\n\t\t}\n\t} as T;\n}\n\nexport function getNextTickChannel<T extends IChannel>(channel: T): T {\n\tlet didTick = false;\n\n\treturn {\n\t\tcall<T>(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T> {\n\t\t\tif (didTick) {\n\t\t\t\treturn channel.call(command, arg, cancellationToken);\n\t\t\t}\n\n\t\t\treturn timeout(0)\n\t\t\t\t.then(() => didTick = true)\n\t\t\t\t.then(() => channel.call<T>(command, arg, cancellationToken));\n\t\t},\n\t\tlisten<T>(event: string, arg?: any): Event<T> {\n\t\t\tif (didTick) {\n\t\t\t\treturn channel.listen<T>(event, arg);\n\t\t\t}\n\n\t\t\tconst relay = new Relay<T>();\n\n\t\t\ttimeout(0)\n\t\t\t\t.then(() => didTick = true)\n\t\t\t\t.then(() => relay.input = channel.listen<T>(event, arg));\n\n\t\t\treturn relay.event;\n\t\t}\n\t} as T;\n}\n\nexport class StaticRouter<TContext = string> implements IClientRouter<TContext> {\n\n\tconstructor(private fn: (ctx: TContext) => boolean | Promise<boolean>) { }\n\n\trouteCall(hub: IConnectionHub<TContext>): Promise<Client<TContext>> {\n\t\treturn this.route(hub);\n\t}\n\n\trouteEvent(hub: IConnectionHub<TContext>): Promise<Client<TContext>> {\n\t\treturn this.route(hub);\n\t}\n\n\tprivate async route(hub: IConnectionHub<TContext>): Promise<Client<TContext>> {\n\t\tfor (const connection of hub.connections) {\n\t\t\tif (await Promise.resolve(this.fn(connection.ctx))) {\n\t\t\t\treturn Promise.resolve(connection);\n\t\t\t}\n\t\t}\n\n\t\tawait Event.toPromise(hub.onDidAddConnection);\n\t\treturn await this.route(hub);\n\t}\n}\n\n/**\n * Use ProxyChannels to automatically wrapping and unwrapping\n * services to/from IPC channels, instead of manually wrapping\n * each service method and event.\n *\n * Restrictions:\n * - If marshalling is enabled, only `URI` and `RegExp` is converted\n *   automatically for you\n * - Events must follow the naming convention `onUpperCase`\n * - `CancellationToken` is currently not supported\n * - If a context is provided, you can use `AddFirstParameterToFunctions`\n *   utility to signal this in the receiving side type\n */\nexport namespace ProxyChannel {\n\n\texport interface IProxyOptions {\n\n\t\t/**\n\t\t * Disables automatic marshalling of `URI`.\n\t\t * If marshalling is disabled, `UriComponents`\n\t\t * must be used instead.\n\t\t */\n\t\tdisableMarshalling?: boolean;\n\t}\n\n\texport interface ICreateServiceChannelOptions extends IProxyOptions { }\n\n\texport function fromService<TContext>(service: unknown, disposables: DisposableStore, options?: ICreateServiceChannelOptions): IServerChannel<TContext> {\n\t\tconst handler = service as { [key: string]: unknown };\n\t\tconst disableMarshalling = options && options.disableMarshalling;\n\n\t\t// Buffer any event that should be supported by\n\t\t// iterating over all property keys and finding them\n\t\t// However, this will not work for services that\n\t\t// are lazy and use a Proxy within. For that we\n\t\t// still need to check later (see below).\n\t\tconst mapEventNameToEvent = new Map<string, Event<unknown>>();\n\t\tfor (const key in handler) {\n\t\t\tif (propertyIsEvent(key)) {\n\t\t\t\tmapEventNameToEvent.set(key, Event.buffer(handler[key] as Event<unknown>, true, undefined, disposables));\n\t\t\t}\n\t\t}\n\n\t\treturn new class implements IServerChannel {\n\n\t\t\tlisten<T>(_: unknown, event: string, arg: any): Event<T> {\n\t\t\t\tconst eventImpl = mapEventNameToEvent.get(event);\n\t\t\t\tif (eventImpl) {\n\t\t\t\t\treturn eventImpl as Event<T>;\n\t\t\t\t}\n\n\t\t\t\tconst target = handler[event];\n\t\t\t\tif (typeof target === 'function') {\n\t\t\t\t\tif (propertyIsDynamicEvent(event)) {\n\t\t\t\t\t\treturn target.call(handler, arg);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (propertyIsEvent(event)) {\n\t\t\t\t\t\tmapEventNameToEvent.set(event, Event.buffer(handler[event] as Event<unknown>, true, undefined, disposables));\n\n\t\t\t\t\t\treturn mapEventNameToEvent.get(event) as Event<T>;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthrow new ErrorNoTelemetry(`Event not found: ${event}`);\n\t\t\t}\n\n\t\t\tcall(_: unknown, command: string, args?: any[]): Promise<any> {\n\t\t\t\tconst target = handler[command];\n\t\t\t\tif (typeof target === 'function') {\n\n\t\t\t\t\t// Revive unless marshalling disabled\n\t\t\t\t\tif (!disableMarshalling && Array.isArray(args)) {\n\t\t\t\t\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\t\t\t\t\targs[i] = revive(args[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlet res = target.apply(handler, args);\n\t\t\t\t\tif (!(res instanceof Promise)) {\n\t\t\t\t\t\tres = Promise.resolve(res);\n\t\t\t\t\t}\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\n\t\t\t\tthrow new ErrorNoTelemetry(`Method not found: ${command}`);\n\t\t\t}\n\t\t};\n\t}\n\n\texport interface ICreateProxyServiceOptions extends IProxyOptions {\n\n\t\t/**\n\t\t * If provided, will add the value of `context`\n\t\t * to each method call to the target.\n\t\t */\n\t\tcontext?: unknown;\n\n\t\t/**\n\t\t * If provided, will not proxy any of the properties\n\t\t * that are part of the Map but rather return that value.\n\t\t */\n\t\tproperties?: Map<string, unknown>;\n\t}\n\n\texport function toService<T extends object>(channel: IChannel, options?: ICreateProxyServiceOptions): T {\n\t\tconst disableMarshalling = options && options.disableMarshalling;\n\n\t\treturn new Proxy({}, {\n\t\t\tget(_target: T, propKey: PropertyKey) {\n\t\t\t\tif (typeof propKey === 'string') {\n\n\t\t\t\t\t// Check for predefined values\n\t\t\t\t\tif (options?.properties?.has(propKey)) {\n\t\t\t\t\t\treturn options.properties.get(propKey);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Dynamic Event\n\t\t\t\t\tif (propertyIsDynamicEvent(propKey)) {\n\t\t\t\t\t\treturn function (arg: any) {\n\t\t\t\t\t\t\treturn channel.listen(propKey, arg);\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Event\n\t\t\t\t\tif (propertyIsEvent(propKey)) {\n\t\t\t\t\t\treturn channel.listen(propKey);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Function\n\t\t\t\t\treturn async function (...args: any[]) {\n\n\t\t\t\t\t\t// Add context if any\n\t\t\t\t\t\tlet methodArgs: any[];\n\t\t\t\t\t\tif (options && !isUndefinedOrNull(options.context)) {\n\t\t\t\t\t\t\tmethodArgs = [options.context, ...args];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmethodArgs = args;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst result = await channel.call(propKey, methodArgs);\n\n\t\t\t\t\t\t// Revive unless marshalling disabled\n\t\t\t\t\t\tif (!disableMarshalling) {\n\t\t\t\t\t\t\treturn revive(result);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tthrow new ErrorNoTelemetry(`Property not found: ${String(propKey)}`);\n\t\t\t}\n\t\t}) as T;\n\t}\n\n\tfunction propertyIsEvent(name: string): boolean {\n\t\t// Assume a property is an event if it has a form of \"onSomething\"\n\t\treturn name[0] === 'o' && name[1] === 'n' && strings.isUpperAsciiLetter(name.charCodeAt(2));\n\t}\n\n\tfunction propertyIsDynamicEvent(name: string): boolean {\n\t\t// Assume a property is a dynamic event (a method that returns an event) if it has a form of \"onDynamicSomething\"\n\t\treturn /^onDynamic/.test(name) && strings.isUpperAsciiLetter(name.charCodeAt(9));\n\t}\n}\n\nconst colorTables = [\n\t['#2977B1', '#FC802D', '#34A13A', '#D3282F', '#9366BA'],\n\t['#8B564C', '#E177C0', '#7F7F7F', '#BBBE3D', '#2EBECD']\n];\n\nfunction prettyWithoutArrays(data: any): any {\n\tif (Array.isArray(data)) {\n\t\treturn data;\n\t}\n\tif (data && typeof data === 'object' && typeof data.toString === 'function') {\n\t\tconst result = data.toString();\n\t\tif (result !== '[object Object]') {\n\t\t\treturn result;\n\t\t}\n\t}\n\treturn data;\n}\n\nfunction pretty(data: any): any {\n\tif (Array.isArray(data)) {\n\t\treturn data.map(prettyWithoutArrays);\n\t}\n\treturn prettyWithoutArrays(data);\n}\n\nfunction logWithColors(direction: string, totalLength: number, msgLength: number, req: number, initiator: RequestInitiator, str: string, data: any): void {\n\tdata = pretty(data);\n\n\tconst colorTable = colorTables[initiator];\n\tconst color = colorTable[req % colorTable.length];\n\tlet args = [`%c[${direction}]%c[${String(totalLength).padStart(7, ' ')}]%c[len: ${String(msgLength).padStart(5, ' ')}]%c${String(req).padStart(5, ' ')} - ${str}`, 'color: darkgreen', 'color: grey', 'color: grey', `color: ${color}`];\n\tif (/\\($/.test(str)) {\n\t\targs = args.concat(data);\n\t\targs.push(')');\n\t} else {\n\t\targs.push(data);\n\t}\n\tconsole.log.apply(console, args as [string, ...string[]]);\n}\n\nexport class IPCLogger implements IIPCLogger {\n\tprivate _totalIncoming = 0;\n\tprivate _totalOutgoing = 0;\n\n\tconstructor(\n\t\tprivate readonly _outgoingPrefix: string,\n\t\tprivate readonly _incomingPrefix: string,\n\t) { }\n\n\tpublic logOutgoing(msgLength: number, requestId: number, initiator: RequestInitiator, str: string, data?: any): void {\n\t\tthis._totalOutgoing += msgLength;\n\t\tlogWithColors(this._outgoingPrefix, this._totalOutgoing, msgLength, requestId, initiator, str, data);\n\t}\n\n\tpublic logIncoming(msgLength: number, requestId: number, initiator: RequestInitiator, str: string, data?: any): void {\n\t\tthis._totalIncoming += msgLength;\n\t\tlogWithColors(this._incomingPrefix, this._totalIncoming, msgLength, requestId, initiator, str, data);\n\t}\n}\n"],
  "mappings": "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",
  "names": ["RequestType", "ResponseType", "State", "DataType", "RequestInitiator", "ProxyChannel"]
}
