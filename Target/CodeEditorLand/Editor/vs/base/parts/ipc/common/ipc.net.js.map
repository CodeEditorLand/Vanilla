{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/parts/ipc/common/ipc.net.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { VSBuffer } from '../../../common/buffer.js';\nimport { Emitter, Event } from '../../../common/event.js';\nimport { Disposable, DisposableStore, IDisposable } from '../../../common/lifecycle.js';\nimport { IIPCLogger, IMessagePassingProtocol, IPCClient } from './ipc.js';\n\nexport const enum SocketDiagnosticsEventType {\n\tCreated = 'created',\n\tRead = 'read',\n\tWrite = 'write',\n\tOpen = 'open',\n\tError = 'error',\n\tClose = 'close',\n\n\tBrowserWebSocketBlobReceived = 'browserWebSocketBlobReceived',\n\n\tNodeEndReceived = 'nodeEndReceived',\n\tNodeEndSent = 'nodeEndSent',\n\tNodeDrainBegin = 'nodeDrainBegin',\n\tNodeDrainEnd = 'nodeDrainEnd',\n\n\tzlibInflateError = 'zlibInflateError',\n\tzlibInflateData = 'zlibInflateData',\n\tzlibInflateInitialWrite = 'zlibInflateInitialWrite',\n\tzlibInflateInitialFlushFired = 'zlibInflateInitialFlushFired',\n\tzlibInflateWrite = 'zlibInflateWrite',\n\tzlibInflateFlushFired = 'zlibInflateFlushFired',\n\tzlibDeflateError = 'zlibDeflateError',\n\tzlibDeflateData = 'zlibDeflateData',\n\tzlibDeflateWrite = 'zlibDeflateWrite',\n\tzlibDeflateFlushFired = 'zlibDeflateFlushFired',\n\n\tWebSocketNodeSocketWrite = 'webSocketNodeSocketWrite',\n\tWebSocketNodeSocketPeekedHeader = 'webSocketNodeSocketPeekedHeader',\n\tWebSocketNodeSocketReadHeader = 'webSocketNodeSocketReadHeader',\n\tWebSocketNodeSocketReadData = 'webSocketNodeSocketReadData',\n\tWebSocketNodeSocketUnmaskedData = 'webSocketNodeSocketUnmaskedData',\n\tWebSocketNodeSocketDrainBegin = 'webSocketNodeSocketDrainBegin',\n\tWebSocketNodeSocketDrainEnd = 'webSocketNodeSocketDrainEnd',\n\n\tProtocolHeaderRead = 'protocolHeaderRead',\n\tProtocolMessageRead = 'protocolMessageRead',\n\tProtocolHeaderWrite = 'protocolHeaderWrite',\n\tProtocolMessageWrite = 'protocolMessageWrite',\n\tProtocolWrite = 'protocolWrite',\n}\n\nexport namespace SocketDiagnostics {\n\n\texport const enableDiagnostics = false;\n\n\texport interface IRecord {\n\t\ttimestamp: number;\n\t\tid: string;\n\t\tlabel: string;\n\t\ttype: SocketDiagnosticsEventType;\n\t\tbuff?: VSBuffer;\n\t\tdata?: any;\n\t}\n\n\texport const records: IRecord[] = [];\n\tconst socketIds = new WeakMap<any, string>();\n\tlet lastUsedSocketId = 0;\n\n\tfunction getSocketId(nativeObject: any, label: string): string {\n\t\tif (!socketIds.has(nativeObject)) {\n\t\t\tconst id = String(++lastUsedSocketId);\n\t\t\tsocketIds.set(nativeObject, id);\n\t\t}\n\t\treturn socketIds.get(nativeObject)!;\n\t}\n\n\texport function traceSocketEvent(nativeObject: any, socketDebugLabel: string, type: SocketDiagnosticsEventType, data?: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView | any): void {\n\t\tif (!enableDiagnostics) {\n\t\t\treturn;\n\t\t}\n\t\tconst id = getSocketId(nativeObject, socketDebugLabel);\n\n\t\tif (data instanceof VSBuffer || data instanceof Uint8Array || data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {\n\t\t\tconst copiedData = VSBuffer.alloc(data.byteLength);\n\t\t\tcopiedData.set(data);\n\t\t\trecords.push({ timestamp: Date.now(), id, label: socketDebugLabel, type, buff: copiedData });\n\t\t} else {\n\t\t\t// data is a custom object\n\t\t\trecords.push({ timestamp: Date.now(), id, label: socketDebugLabel, type, data: data });\n\t\t}\n\t}\n}\n\nexport const enum SocketCloseEventType {\n\tNodeSocketCloseEvent = 0,\n\tWebSocketCloseEvent = 1\n}\n\nexport interface NodeSocketCloseEvent {\n\t/**\n\t * The type of the event\n\t */\n\treadonly type: SocketCloseEventType.NodeSocketCloseEvent;\n\t/**\n\t * `true` if the socket had a transmission error.\n\t */\n\treadonly hadError: boolean;\n\t/**\n\t * Underlying error.\n\t */\n\treadonly error: Error | undefined;\n}\n\nexport interface WebSocketCloseEvent {\n\t/**\n\t * The type of the event\n\t */\n\treadonly type: SocketCloseEventType.WebSocketCloseEvent;\n\t/**\n\t * Returns the WebSocket connection close code provided by the server.\n\t */\n\treadonly code: number;\n\t/**\n\t * Returns the WebSocket connection close reason provided by the server.\n\t */\n\treadonly reason: string;\n\t/**\n\t * Returns true if the connection closed cleanly; false otherwise.\n\t */\n\treadonly wasClean: boolean;\n\t/**\n\t * Underlying event.\n\t */\n\treadonly event: any | undefined;\n}\n\nexport type SocketCloseEvent = NodeSocketCloseEvent | WebSocketCloseEvent | undefined;\n\nexport interface SocketTimeoutEvent {\n\treadonly unacknowledgedMsgCount: number;\n\treadonly timeSinceOldestUnacknowledgedMsg: number;\n\treadonly timeSinceLastReceivedSomeData: number;\n}\n\nexport interface ISocket extends IDisposable {\n\tonData(listener: (e: VSBuffer) => void): IDisposable;\n\tonClose(listener: (e: SocketCloseEvent) => void): IDisposable;\n\tonEnd(listener: () => void): IDisposable;\n\twrite(buffer: VSBuffer): void;\n\tend(): void;\n\tdrain(): Promise<void>;\n\n\ttraceSocketEvent(type: SocketDiagnosticsEventType, data?: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView | any): void;\n}\n\nlet emptyBuffer: VSBuffer | null = null;\nfunction getEmptyBuffer(): VSBuffer {\n\tif (!emptyBuffer) {\n\t\temptyBuffer = VSBuffer.alloc(0);\n\t}\n\treturn emptyBuffer;\n}\n\nexport class ChunkStream {\n\n\tprivate _chunks: VSBuffer[];\n\tprivate _totalLength: number;\n\n\tpublic get byteLength() {\n\t\treturn this._totalLength;\n\t}\n\n\tconstructor() {\n\t\tthis._chunks = [];\n\t\tthis._totalLength = 0;\n\t}\n\n\tpublic acceptChunk(buff: VSBuffer) {\n\t\tthis._chunks.push(buff);\n\t\tthis._totalLength += buff.byteLength;\n\t}\n\n\tpublic read(byteCount: number): VSBuffer {\n\t\treturn this._read(byteCount, true);\n\t}\n\n\tpublic peek(byteCount: number): VSBuffer {\n\t\treturn this._read(byteCount, false);\n\t}\n\n\tprivate _read(byteCount: number, advance: boolean): VSBuffer {\n\n\t\tif (byteCount === 0) {\n\t\t\treturn getEmptyBuffer();\n\t\t}\n\n\t\tif (byteCount > this._totalLength) {\n\t\t\tthrow new Error(`Cannot read so many bytes!`);\n\t\t}\n\n\t\tif (this._chunks[0].byteLength === byteCount) {\n\t\t\t// super fast path, precisely first chunk must be returned\n\t\t\tconst result = this._chunks[0];\n\t\t\tif (advance) {\n\t\t\t\tthis._chunks.shift();\n\t\t\t\tthis._totalLength -= byteCount;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tif (this._chunks[0].byteLength > byteCount) {\n\t\t\t// fast path, the reading is entirely within the first chunk\n\t\t\tconst result = this._chunks[0].slice(0, byteCount);\n\t\t\tif (advance) {\n\t\t\t\tthis._chunks[0] = this._chunks[0].slice(byteCount);\n\t\t\t\tthis._totalLength -= byteCount;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tconst result = VSBuffer.alloc(byteCount);\n\t\tlet resultOffset = 0;\n\t\tlet chunkIndex = 0;\n\t\twhile (byteCount > 0) {\n\t\t\tconst chunk = this._chunks[chunkIndex];\n\t\t\tif (chunk.byteLength > byteCount) {\n\t\t\t\t// this chunk will survive\n\t\t\t\tconst chunkPart = chunk.slice(0, byteCount);\n\t\t\t\tresult.set(chunkPart, resultOffset);\n\t\t\t\tresultOffset += byteCount;\n\n\t\t\t\tif (advance) {\n\t\t\t\t\tthis._chunks[chunkIndex] = chunk.slice(byteCount);\n\t\t\t\t\tthis._totalLength -= byteCount;\n\t\t\t\t}\n\n\t\t\t\tbyteCount -= byteCount;\n\t\t\t} else {\n\t\t\t\t// this chunk will be entirely read\n\t\t\t\tresult.set(chunk, resultOffset);\n\t\t\t\tresultOffset += chunk.byteLength;\n\n\t\t\t\tif (advance) {\n\t\t\t\t\tthis._chunks.shift();\n\t\t\t\t\tthis._totalLength -= chunk.byteLength;\n\t\t\t\t} else {\n\t\t\t\t\tchunkIndex++;\n\t\t\t\t}\n\n\t\t\t\tbyteCount -= chunk.byteLength;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n\nconst enum ProtocolMessageType {\n\tNone = 0,\n\tRegular = 1,\n\tControl = 2,\n\tAck = 3,\n\tDisconnect = 5,\n\tReplayRequest = 6,\n\tPause = 7,\n\tResume = 8,\n\tKeepAlive = 9\n}\n\nfunction protocolMessageTypeToString(messageType: ProtocolMessageType) {\n\tswitch (messageType) {\n\t\tcase ProtocolMessageType.None: return 'None';\n\t\tcase ProtocolMessageType.Regular: return 'Regular';\n\t\tcase ProtocolMessageType.Control: return 'Control';\n\t\tcase ProtocolMessageType.Ack: return 'Ack';\n\t\tcase ProtocolMessageType.Disconnect: return 'Disconnect';\n\t\tcase ProtocolMessageType.ReplayRequest: return 'ReplayRequest';\n\t\tcase ProtocolMessageType.Pause: return 'PauseWriting';\n\t\tcase ProtocolMessageType.Resume: return 'ResumeWriting';\n\t\tcase ProtocolMessageType.KeepAlive: return 'KeepAlive';\n\t}\n}\n\nexport const enum ProtocolConstants {\n\tHeaderLength = 13,\n\t/**\n\t * Send an Acknowledge message at most 2 seconds later...\n\t */\n\tAcknowledgeTime = 2000, // 2 seconds\n\t/**\n\t * If there is a sent message that has been unacknowledged for 20 seconds,\n\t * and we didn't see any incoming server data in the past 20 seconds,\n\t * then consider the connection has timed out.\n\t */\n\tTimeoutTime = 20000, // 20 seconds\n\t/**\n\t * If there is no reconnection within this time-frame, consider the connection permanently closed...\n\t */\n\tReconnectionGraceTime = 3 * 60 * 60 * 1000, // 3hrs\n\t/**\n\t * Maximal grace time between the first and the last reconnection...\n\t */\n\tReconnectionShortGraceTime = 5 * 60 * 1000, // 5min\n\t/**\n\t * Send a message every 5 seconds to avoid that the connection is closed by the OS.\n\t */\n\tKeepAliveSendTime = 5000, // 5 seconds\n}\n\nclass ProtocolMessage {\n\n\tpublic writtenTime: number;\n\n\tconstructor(\n\t\tpublic readonly type: ProtocolMessageType,\n\t\tpublic readonly id: number,\n\t\tpublic readonly ack: number,\n\t\tpublic readonly data: VSBuffer\n\t) {\n\t\tthis.writtenTime = 0;\n\t}\n\n\tpublic get size(): number {\n\t\treturn this.data.byteLength;\n\t}\n}\n\nclass ProtocolReader extends Disposable {\n\n\tprivate readonly _socket: ISocket;\n\tprivate _isDisposed: boolean;\n\tprivate readonly _incomingData: ChunkStream;\n\tpublic lastReadTime: number;\n\n\tprivate readonly _onMessage = this._register(new Emitter<ProtocolMessage>());\n\tpublic readonly onMessage: Event<ProtocolMessage> = this._onMessage.event;\n\n\tprivate readonly _state = {\n\t\treadHead: true,\n\t\treadLen: ProtocolConstants.HeaderLength,\n\t\tmessageType: ProtocolMessageType.None,\n\t\tid: 0,\n\t\tack: 0\n\t};\n\n\tconstructor(socket: ISocket) {\n\t\tsuper();\n\t\tthis._socket = socket;\n\t\tthis._isDisposed = false;\n\t\tthis._incomingData = new ChunkStream();\n\t\tthis._register(this._socket.onData(data => this.acceptChunk(data)));\n\t\tthis.lastReadTime = Date.now();\n\t}\n\n\tpublic acceptChunk(data: VSBuffer | null): void {\n\t\tif (!data || data.byteLength === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.lastReadTime = Date.now();\n\n\t\tthis._incomingData.acceptChunk(data);\n\n\t\twhile (this._incomingData.byteLength >= this._state.readLen) {\n\n\t\t\tconst buff = this._incomingData.read(this._state.readLen);\n\n\t\t\tif (this._state.readHead) {\n\t\t\t\t// buff is the header\n\n\t\t\t\t// save new state => next time will read the body\n\t\t\t\tthis._state.readHead = false;\n\t\t\t\tthis._state.readLen = buff.readUInt32BE(9);\n\t\t\t\tthis._state.messageType = buff.readUInt8(0);\n\t\t\t\tthis._state.id = buff.readUInt32BE(1);\n\t\t\t\tthis._state.ack = buff.readUInt32BE(5);\n\n\t\t\t\tthis._socket.traceSocketEvent(SocketDiagnosticsEventType.ProtocolHeaderRead, { messageType: protocolMessageTypeToString(this._state.messageType), id: this._state.id, ack: this._state.ack, messageSize: this._state.readLen });\n\n\t\t\t} else {\n\t\t\t\t// buff is the body\n\t\t\t\tconst messageType = this._state.messageType;\n\t\t\t\tconst id = this._state.id;\n\t\t\t\tconst ack = this._state.ack;\n\n\t\t\t\t// save new state => next time will read the header\n\t\t\t\tthis._state.readHead = true;\n\t\t\t\tthis._state.readLen = ProtocolConstants.HeaderLength;\n\t\t\t\tthis._state.messageType = ProtocolMessageType.None;\n\t\t\t\tthis._state.id = 0;\n\t\t\t\tthis._state.ack = 0;\n\n\t\t\t\tthis._socket.traceSocketEvent(SocketDiagnosticsEventType.ProtocolMessageRead, buff);\n\n\t\t\t\tthis._onMessage.fire(new ProtocolMessage(messageType, id, ack, buff));\n\n\t\t\t\tif (this._isDisposed) {\n\t\t\t\t\t// check if an event listener lead to our disposal\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic readEntireBuffer(): VSBuffer {\n\t\treturn this._incomingData.read(this._incomingData.byteLength);\n\t}\n\n\tpublic override dispose(): void {\n\t\tthis._isDisposed = true;\n\t\tsuper.dispose();\n\t}\n}\n\nclass ProtocolWriter {\n\n\tprivate _isDisposed: boolean;\n\tprivate _isPaused: boolean;\n\tprivate readonly _socket: ISocket;\n\tprivate _data: VSBuffer[];\n\tprivate _totalLength: number;\n\tpublic lastWriteTime: number;\n\n\tconstructor(socket: ISocket) {\n\t\tthis._isDisposed = false;\n\t\tthis._isPaused = false;\n\t\tthis._socket = socket;\n\t\tthis._data = [];\n\t\tthis._totalLength = 0;\n\t\tthis.lastWriteTime = 0;\n\t}\n\n\tpublic dispose(): void {\n\t\ttry {\n\t\t\tthis.flush();\n\t\t} catch (err) {\n\t\t\t// ignore error, since the socket could be already closed\n\t\t}\n\t\tthis._isDisposed = true;\n\t}\n\n\tpublic drain(): Promise<void> {\n\t\tthis.flush();\n\t\treturn this._socket.drain();\n\t}\n\n\tpublic flush(): void {\n\t\t// flush\n\t\tthis._writeNow();\n\t}\n\n\tpublic pause(): void {\n\t\tthis._isPaused = true;\n\t}\n\n\tpublic resume(): void {\n\t\tthis._isPaused = false;\n\t\tthis._scheduleWriting();\n\t}\n\n\tpublic write(msg: ProtocolMessage) {\n\t\tif (this._isDisposed) {\n\t\t\t// ignore: there could be left-over promises which complete and then\n\t\t\t// decide to write a response, etc...\n\t\t\treturn;\n\t\t}\n\t\tmsg.writtenTime = Date.now();\n\t\tthis.lastWriteTime = Date.now();\n\t\tconst header = VSBuffer.alloc(ProtocolConstants.HeaderLength);\n\t\theader.writeUInt8(msg.type, 0);\n\t\theader.writeUInt32BE(msg.id, 1);\n\t\theader.writeUInt32BE(msg.ack, 5);\n\t\theader.writeUInt32BE(msg.data.byteLength, 9);\n\n\t\tthis._socket.traceSocketEvent(SocketDiagnosticsEventType.ProtocolHeaderWrite, { messageType: protocolMessageTypeToString(msg.type), id: msg.id, ack: msg.ack, messageSize: msg.data.byteLength });\n\t\tthis._socket.traceSocketEvent(SocketDiagnosticsEventType.ProtocolMessageWrite, msg.data);\n\n\t\tthis._writeSoon(header, msg.data);\n\t}\n\n\tprivate _bufferAdd(head: VSBuffer, body: VSBuffer): boolean {\n\t\tconst wasEmpty = this._totalLength === 0;\n\t\tthis._data.push(head, body);\n\t\tthis._totalLength += head.byteLength + body.byteLength;\n\t\treturn wasEmpty;\n\t}\n\n\tprivate _bufferTake(): VSBuffer {\n\t\tconst ret = VSBuffer.concat(this._data, this._totalLength);\n\t\tthis._data.length = 0;\n\t\tthis._totalLength = 0;\n\t\treturn ret;\n\t}\n\n\tprivate _writeSoon(header: VSBuffer, data: VSBuffer): void {\n\t\tif (this._bufferAdd(header, data)) {\n\t\t\tthis._scheduleWriting();\n\t\t}\n\t}\n\n\tprivate _writeNowTimeout: any = null;\n\tprivate _scheduleWriting(): void {\n\t\tif (this._writeNowTimeout) {\n\t\t\treturn;\n\t\t}\n\t\tthis._writeNowTimeout = setTimeout(() => {\n\t\t\tthis._writeNowTimeout = null;\n\t\t\tthis._writeNow();\n\t\t});\n\t}\n\n\tprivate _writeNow(): void {\n\t\tif (this._totalLength === 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._isPaused) {\n\t\t\treturn;\n\t\t}\n\t\tconst data = this._bufferTake();\n\t\tthis._socket.traceSocketEvent(SocketDiagnosticsEventType.ProtocolWrite, { byteLength: data.byteLength });\n\t\tthis._socket.write(data);\n\t}\n}\n\n/**\n * A message has the following format:\n * ```\n *     /-------------------------------|------\\\n *     |             HEADER            |      |\n *     |-------------------------------| DATA |\n *     | TYPE | ID | ACK | DATA_LENGTH |      |\n *     \\-------------------------------|------/\n * ```\n * The header is 9 bytes and consists of:\n *  - TYPE is 1 byte (ProtocolMessageType) - the message type\n *  - ID is 4 bytes (u32be) - the message id (can be 0 to indicate to be ignored)\n *  - ACK is 4 bytes (u32be) - the acknowledged message id (can be 0 to indicate to be ignored)\n *  - DATA_LENGTH is 4 bytes (u32be) - the length in bytes of DATA\n *\n * Only Regular messages are counted, other messages are not counted, nor acknowledged.\n */\nexport class Protocol extends Disposable implements IMessagePassingProtocol {\n\n\tprivate _socket: ISocket;\n\tprivate _socketWriter: ProtocolWriter;\n\tprivate _socketReader: ProtocolReader;\n\n\tprivate readonly _onMessage = new Emitter<VSBuffer>();\n\treadonly onMessage: Event<VSBuffer> = this._onMessage.event;\n\n\tprivate readonly _onDidDispose = new Emitter<void>();\n\treadonly onDidDispose: Event<void> = this._onDidDispose.event;\n\n\tconstructor(socket: ISocket) {\n\t\tsuper();\n\t\tthis._socket = socket;\n\t\tthis._socketWriter = this._register(new ProtocolWriter(this._socket));\n\t\tthis._socketReader = this._register(new ProtocolReader(this._socket));\n\n\t\tthis._register(this._socketReader.onMessage((msg) => {\n\t\t\tif (msg.type === ProtocolMessageType.Regular) {\n\t\t\t\tthis._onMessage.fire(msg.data);\n\t\t\t}\n\t\t}));\n\n\t\tthis._register(this._socket.onClose(() => this._onDidDispose.fire()));\n\t}\n\n\tdrain(): Promise<void> {\n\t\treturn this._socketWriter.drain();\n\t}\n\n\tgetSocket(): ISocket {\n\t\treturn this._socket;\n\t}\n\n\tsendDisconnect(): void {\n\t\t// Nothing to do...\n\t}\n\n\tsend(buffer: VSBuffer): void {\n\t\tthis._socketWriter.write(new ProtocolMessage(ProtocolMessageType.Regular, 0, 0, buffer));\n\t}\n}\n\nexport class Client<TContext = string> extends IPCClient<TContext> {\n\n\tstatic fromSocket<TContext = string>(socket: ISocket, id: TContext): Client<TContext> {\n\t\treturn new Client(new Protocol(socket), id);\n\t}\n\n\tget onDidDispose(): Event<void> { return this.protocol.onDidDispose; }\n\n\tconstructor(private protocol: Protocol | PersistentProtocol, id: TContext, ipcLogger: IIPCLogger | null = null) {\n\t\tsuper(protocol, id, ipcLogger);\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\t\tconst socket = this.protocol.getSocket();\n\t\t// should be sent gracefully with a .flush(), but try to send it out as a\n\t\t// last resort here if nothing else:\n\t\tthis.protocol.sendDisconnect();\n\t\tthis.protocol.dispose();\n\t\tsocket.end();\n\t}\n}\n\n/**\n * Will ensure no messages are lost if there are no event listeners.\n */\nexport class BufferedEmitter<T> {\n\tprivate _emitter: Emitter<T>;\n\tpublic readonly event: Event<T>;\n\n\tprivate _hasListeners = false;\n\tprivate _isDeliveringMessages = false;\n\tprivate _bufferedMessages: T[] = [];\n\n\tconstructor() {\n\t\tthis._emitter = new Emitter<T>({\n\t\t\tonWillAddFirstListener: () => {\n\t\t\t\tthis._hasListeners = true;\n\t\t\t\t// it is important to deliver these messages after this call, but before\n\t\t\t\t// other messages have a chance to be received (to guarantee in order delivery)\n\t\t\t\t// that's why we're using here queueMicrotask and not other types of timeouts\n\t\t\t\tqueueMicrotask(() => this._deliverMessages());\n\t\t\t},\n\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\tthis._hasListeners = false;\n\t\t\t}\n\t\t});\n\n\t\tthis.event = this._emitter.event;\n\t}\n\n\tprivate _deliverMessages(): void {\n\t\tif (this._isDeliveringMessages) {\n\t\t\treturn;\n\t\t}\n\t\tthis._isDeliveringMessages = true;\n\t\twhile (this._hasListeners && this._bufferedMessages.length > 0) {\n\t\t\tthis._emitter.fire(this._bufferedMessages.shift()!);\n\t\t}\n\t\tthis._isDeliveringMessages = false;\n\t}\n\n\tpublic fire(event: T): void {\n\t\tif (this._hasListeners) {\n\t\t\tif (this._bufferedMessages.length > 0) {\n\t\t\t\tthis._bufferedMessages.push(event);\n\t\t\t} else {\n\t\t\t\tthis._emitter.fire(event);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._bufferedMessages.push(event);\n\t\t}\n\t}\n\n\tpublic flushBuffer(): void {\n\t\tthis._bufferedMessages = [];\n\t}\n}\n\nclass QueueElement<T> {\n\tpublic readonly data: T;\n\tpublic next: QueueElement<T> | null;\n\n\tconstructor(data: T) {\n\t\tthis.data = data;\n\t\tthis.next = null;\n\t}\n}\n\nclass Queue<T> {\n\n\tprivate _first: QueueElement<T> | null;\n\tprivate _last: QueueElement<T> | null;\n\n\tconstructor() {\n\t\tthis._first = null;\n\t\tthis._last = null;\n\t}\n\n\tpublic length(): number {\n\t\tlet result = 0;\n\t\tlet current = this._first;\n\t\twhile (current) {\n\t\t\tcurrent = current.next;\n\t\t\tresult++;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic peek(): T | null {\n\t\tif (!this._first) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this._first.data;\n\t}\n\n\tpublic toArray(): T[] {\n\t\tconst result: T[] = [];\n\t\tlet resultLen = 0;\n\t\tlet it = this._first;\n\t\twhile (it) {\n\t\t\tresult[resultLen++] = it.data;\n\t\t\tit = it.next;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic pop(): void {\n\t\tif (!this._first) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._first === this._last) {\n\t\t\tthis._first = null;\n\t\t\tthis._last = null;\n\t\t\treturn;\n\t\t}\n\t\tthis._first = this._first.next;\n\t}\n\n\tpublic push(item: T): void {\n\t\tconst element = new QueueElement(item);\n\t\tif (!this._first) {\n\t\t\tthis._first = element;\n\t\t\tthis._last = element;\n\t\t\treturn;\n\t\t}\n\t\tthis._last!.next = element;\n\t\tthis._last = element;\n\t}\n}\n\nclass LoadEstimator {\n\n\tprivate static _HISTORY_LENGTH = 10;\n\tprivate static _INSTANCE: LoadEstimator | null = null;\n\tpublic static getInstance(): LoadEstimator {\n\t\tif (!LoadEstimator._INSTANCE) {\n\t\t\tLoadEstimator._INSTANCE = new LoadEstimator();\n\t\t}\n\t\treturn LoadEstimator._INSTANCE;\n\t}\n\n\tprivate lastRuns: number[];\n\n\tconstructor() {\n\t\tthis.lastRuns = [];\n\t\tconst now = Date.now();\n\t\tfor (let i = 0; i < LoadEstimator._HISTORY_LENGTH; i++) {\n\t\t\tthis.lastRuns[i] = now - 1000 * i;\n\t\t}\n\t\tsetInterval(() => {\n\t\t\tfor (let i = LoadEstimator._HISTORY_LENGTH; i >= 1; i--) {\n\t\t\t\tthis.lastRuns[i] = this.lastRuns[i - 1];\n\t\t\t}\n\t\t\tthis.lastRuns[0] = Date.now();\n\t\t}, 1000);\n\t}\n\n\t/**\n\t * returns an estimative number, from 0 (low load) to 1 (high load)\n\t */\n\tprivate load(): number {\n\t\tconst now = Date.now();\n\t\tconst historyLimit = (1 + LoadEstimator._HISTORY_LENGTH) * 1000;\n\t\tlet score = 0;\n\t\tfor (let i = 0; i < LoadEstimator._HISTORY_LENGTH; i++) {\n\t\t\tif (now - this.lastRuns[i] <= historyLimit) {\n\t\t\t\tscore++;\n\t\t\t}\n\t\t}\n\t\treturn 1 - score / LoadEstimator._HISTORY_LENGTH;\n\t}\n\n\tpublic hasHighLoad(): boolean {\n\t\treturn this.load() >= 0.5;\n\t}\n}\n\nexport interface ILoadEstimator {\n\thasHighLoad(): boolean;\n}\n\nexport interface PersistentProtocolOptions {\n\t/**\n\t * The socket to use.\n\t */\n\tsocket: ISocket;\n\t/**\n\t * The initial chunk of data that has already been received from the socket.\n\t */\n\tinitialChunk?: VSBuffer | null;\n\t/**\n\t * The CPU load estimator to use.\n\t */\n\tloadEstimator?: ILoadEstimator;\n\t/**\n\t * Whether to send keep alive messages. Defaults to true.\n\t */\n\tsendKeepAlive?: boolean;\n}\n\n/**\n * Same as Protocol, but will actually track messages and acks.\n * Moreover, it will ensure no messages are lost if there are no event listeners.\n */\nexport class PersistentProtocol implements IMessagePassingProtocol {\n\n\tprivate _isReconnecting: boolean;\n\tprivate _didSendDisconnect?: boolean;\n\n\tprivate _outgoingUnackMsg: Queue<ProtocolMessage>;\n\tprivate _outgoingMsgId: number;\n\tprivate _outgoingAckId: number;\n\tprivate _outgoingAckTimeout: any | null;\n\n\tprivate _incomingMsgId: number;\n\tprivate _incomingAckId: number;\n\tprivate _incomingMsgLastTime: number;\n\tprivate _incomingAckTimeout: any | null;\n\n\tprivate _keepAliveInterval: any | null;\n\n\tprivate _lastReplayRequestTime: number;\n\tprivate _lastSocketTimeoutTime: number;\n\n\tprivate _socket: ISocket;\n\tprivate _socketWriter: ProtocolWriter;\n\tprivate _socketReader: ProtocolReader;\n\t// eslint-disable-next-line local/code-no-potentially-unsafe-disposables\n\tprivate _socketDisposables: DisposableStore;\n\n\tprivate readonly _loadEstimator: ILoadEstimator;\n\tprivate readonly _shouldSendKeepAlive: boolean;\n\n\tprivate readonly _onControlMessage = new BufferedEmitter<VSBuffer>();\n\treadonly onControlMessage: Event<VSBuffer> = this._onControlMessage.event;\n\n\tprivate readonly _onMessage = new BufferedEmitter<VSBuffer>();\n\treadonly onMessage: Event<VSBuffer> = this._onMessage.event;\n\n\tprivate readonly _onDidDispose = new BufferedEmitter<void>();\n\treadonly onDidDispose: Event<void> = this._onDidDispose.event;\n\n\tprivate readonly _onSocketClose = new BufferedEmitter<SocketCloseEvent>();\n\treadonly onSocketClose: Event<SocketCloseEvent> = this._onSocketClose.event;\n\n\tprivate readonly _onSocketTimeout = new BufferedEmitter<SocketTimeoutEvent>();\n\treadonly onSocketTimeout: Event<SocketTimeoutEvent> = this._onSocketTimeout.event;\n\n\tpublic get unacknowledgedCount(): number {\n\t\treturn this._outgoingMsgId - this._outgoingAckId;\n\t}\n\n\tconstructor(opts: PersistentProtocolOptions) {\n\t\tthis._loadEstimator = opts.loadEstimator ?? LoadEstimator.getInstance();\n\t\tthis._shouldSendKeepAlive = opts.sendKeepAlive ?? true;\n\t\tthis._isReconnecting = false;\n\t\tthis._outgoingUnackMsg = new Queue<ProtocolMessage>();\n\t\tthis._outgoingMsgId = 0;\n\t\tthis._outgoingAckId = 0;\n\t\tthis._outgoingAckTimeout = null;\n\n\t\tthis._incomingMsgId = 0;\n\t\tthis._incomingAckId = 0;\n\t\tthis._incomingMsgLastTime = 0;\n\t\tthis._incomingAckTimeout = null;\n\n\t\tthis._lastReplayRequestTime = 0;\n\t\tthis._lastSocketTimeoutTime = Date.now();\n\n\t\tthis._socketDisposables = new DisposableStore();\n\t\tthis._socket = opts.socket;\n\t\tthis._socketWriter = this._socketDisposables.add(new ProtocolWriter(this._socket));\n\t\tthis._socketReader = this._socketDisposables.add(new ProtocolReader(this._socket));\n\t\tthis._socketDisposables.add(this._socketReader.onMessage(msg => this._receiveMessage(msg)));\n\t\tthis._socketDisposables.add(this._socket.onClose(e => this._onSocketClose.fire(e)));\n\n\t\tif (opts.initialChunk) {\n\t\t\tthis._socketReader.acceptChunk(opts.initialChunk);\n\t\t}\n\n\t\tif (this._shouldSendKeepAlive) {\n\t\t\tthis._keepAliveInterval = setInterval(() => {\n\t\t\t\tthis._sendKeepAlive();\n\t\t\t}, ProtocolConstants.KeepAliveSendTime);\n\t\t} else {\n\t\t\tthis._keepAliveInterval = null;\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tif (this._outgoingAckTimeout) {\n\t\t\tclearTimeout(this._outgoingAckTimeout);\n\t\t\tthis._outgoingAckTimeout = null;\n\t\t}\n\t\tif (this._incomingAckTimeout) {\n\t\t\tclearTimeout(this._incomingAckTimeout);\n\t\t\tthis._incomingAckTimeout = null;\n\t\t}\n\t\tif (this._keepAliveInterval) {\n\t\t\tclearInterval(this._keepAliveInterval);\n\t\t\tthis._keepAliveInterval = null;\n\t\t}\n\t\tthis._socketDisposables.dispose();\n\t}\n\n\tdrain(): Promise<void> {\n\t\treturn this._socketWriter.drain();\n\t}\n\n\tsendDisconnect(): void {\n\t\tif (!this._didSendDisconnect) {\n\t\t\tthis._didSendDisconnect = true;\n\t\t\tconst msg = new ProtocolMessage(ProtocolMessageType.Disconnect, 0, 0, getEmptyBuffer());\n\t\t\tthis._socketWriter.write(msg);\n\t\t\tthis._socketWriter.flush();\n\t\t}\n\t}\n\n\tsendPause(): void {\n\t\tconst msg = new ProtocolMessage(ProtocolMessageType.Pause, 0, 0, getEmptyBuffer());\n\t\tthis._socketWriter.write(msg);\n\t}\n\n\tsendResume(): void {\n\t\tconst msg = new ProtocolMessage(ProtocolMessageType.Resume, 0, 0, getEmptyBuffer());\n\t\tthis._socketWriter.write(msg);\n\t}\n\n\tpauseSocketWriting() {\n\t\tthis._socketWriter.pause();\n\t}\n\n\tpublic getSocket(): ISocket {\n\t\treturn this._socket;\n\t}\n\n\tpublic getMillisSinceLastIncomingData(): number {\n\t\treturn Date.now() - this._socketReader.lastReadTime;\n\t}\n\n\tpublic beginAcceptReconnection(socket: ISocket, initialDataChunk: VSBuffer | null): void {\n\t\tthis._isReconnecting = true;\n\n\t\tthis._socketDisposables.dispose();\n\t\tthis._socketDisposables = new DisposableStore();\n\t\tthis._onControlMessage.flushBuffer();\n\t\tthis._onSocketClose.flushBuffer();\n\t\tthis._onSocketTimeout.flushBuffer();\n\t\tthis._socket.dispose();\n\n\t\tthis._lastReplayRequestTime = 0;\n\t\tthis._lastSocketTimeoutTime = Date.now();\n\n\t\tthis._socket = socket;\n\t\tthis._socketWriter = this._socketDisposables.add(new ProtocolWriter(this._socket));\n\t\tthis._socketReader = this._socketDisposables.add(new ProtocolReader(this._socket));\n\t\tthis._socketDisposables.add(this._socketReader.onMessage(msg => this._receiveMessage(msg)));\n\t\tthis._socketDisposables.add(this._socket.onClose(e => this._onSocketClose.fire(e)));\n\n\t\tthis._socketReader.acceptChunk(initialDataChunk);\n\t}\n\n\tpublic endAcceptReconnection(): void {\n\t\tthis._isReconnecting = false;\n\n\t\t// After a reconnection, let the other party know (again) which messages have been received.\n\t\t// (perhaps the other party didn't receive a previous ACK)\n\t\tthis._incomingAckId = this._incomingMsgId;\n\t\tconst msg = new ProtocolMessage(ProtocolMessageType.Ack, 0, this._incomingAckId, getEmptyBuffer());\n\t\tthis._socketWriter.write(msg);\n\n\t\t// Send again all unacknowledged messages\n\t\tconst toSend = this._outgoingUnackMsg.toArray();\n\t\tfor (let i = 0, len = toSend.length; i < len; i++) {\n\t\t\tthis._socketWriter.write(toSend[i]);\n\t\t}\n\t\tthis._recvAckCheck();\n\t}\n\n\tpublic acceptDisconnect(): void {\n\t\tthis._onDidDispose.fire();\n\t}\n\n\tprivate _receiveMessage(msg: ProtocolMessage): void {\n\t\tif (msg.ack > this._outgoingAckId) {\n\t\t\tthis._outgoingAckId = msg.ack;\n\t\t\tdo {\n\t\t\t\tconst first = this._outgoingUnackMsg.peek();\n\t\t\t\tif (first && first.id <= msg.ack) {\n\t\t\t\t\t// this message has been confirmed, remove it\n\t\t\t\t\tthis._outgoingUnackMsg.pop();\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (true);\n\t\t}\n\n\t\tswitch (msg.type) {\n\t\t\tcase ProtocolMessageType.None: {\n\t\t\t\t// N/A\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.Regular: {\n\t\t\t\tif (msg.id > this._incomingMsgId) {\n\t\t\t\t\tif (msg.id !== this._incomingMsgId + 1) {\n\t\t\t\t\t\t// in case we missed some messages we ask the other party to resend them\n\t\t\t\t\t\tconst now = Date.now();\n\t\t\t\t\t\tif (now - this._lastReplayRequestTime > 10000) {\n\t\t\t\t\t\t\t// send a replay request at most once every 10s\n\t\t\t\t\t\t\tthis._lastReplayRequestTime = now;\n\t\t\t\t\t\t\tthis._socketWriter.write(new ProtocolMessage(ProtocolMessageType.ReplayRequest, 0, 0, getEmptyBuffer()));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._incomingMsgId = msg.id;\n\t\t\t\t\t\tthis._incomingMsgLastTime = Date.now();\n\t\t\t\t\t\tthis._sendAckCheck();\n\t\t\t\t\t\tthis._onMessage.fire(msg.data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.Control: {\n\t\t\t\tthis._onControlMessage.fire(msg.data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.Ack: {\n\t\t\t\t// nothing to do, .ack is handled above already\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.Disconnect: {\n\t\t\t\tthis._onDidDispose.fire();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.ReplayRequest: {\n\t\t\t\t// Send again all unacknowledged messages\n\t\t\t\tconst toSend = this._outgoingUnackMsg.toArray();\n\t\t\t\tfor (let i = 0, len = toSend.length; i < len; i++) {\n\t\t\t\t\tthis._socketWriter.write(toSend[i]);\n\t\t\t\t}\n\t\t\t\tthis._recvAckCheck();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.Pause: {\n\t\t\t\tthis._socketWriter.pause();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.Resume: {\n\t\t\t\tthis._socketWriter.resume();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.KeepAlive: {\n\t\t\t\t// nothing to do\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treadEntireBuffer(): VSBuffer {\n\t\treturn this._socketReader.readEntireBuffer();\n\t}\n\n\tflush(): void {\n\t\tthis._socketWriter.flush();\n\t}\n\n\tsend(buffer: VSBuffer): void {\n\t\tconst myId = ++this._outgoingMsgId;\n\t\tthis._incomingAckId = this._incomingMsgId;\n\t\tconst msg = new ProtocolMessage(ProtocolMessageType.Regular, myId, this._incomingAckId, buffer);\n\t\tthis._outgoingUnackMsg.push(msg);\n\t\tif (!this._isReconnecting) {\n\t\t\tthis._socketWriter.write(msg);\n\t\t\tthis._recvAckCheck();\n\t\t}\n\t}\n\n\t/**\n\t * Send a message which will not be part of the regular acknowledge flow.\n\t * Use this for early control messages which are repeated in case of reconnection.\n\t */\n\tsendControl(buffer: VSBuffer): void {\n\t\tconst msg = new ProtocolMessage(ProtocolMessageType.Control, 0, 0, buffer);\n\t\tthis._socketWriter.write(msg);\n\t}\n\n\tprivate _sendAckCheck(): void {\n\t\tif (this._incomingMsgId <= this._incomingAckId) {\n\t\t\t// nothink to acknowledge\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._incomingAckTimeout) {\n\t\t\t// there will be a check in the near future\n\t\t\treturn;\n\t\t}\n\n\t\tconst timeSinceLastIncomingMsg = Date.now() - this._incomingMsgLastTime;\n\t\tif (timeSinceLastIncomingMsg >= ProtocolConstants.AcknowledgeTime) {\n\t\t\t// sufficient time has passed since this message has been received,\n\t\t\t// and no message from our side needed to be sent in the meantime,\n\t\t\t// so we will send a message containing only an ack.\n\t\t\tthis._sendAck();\n\t\t\treturn;\n\t\t}\n\n\t\tthis._incomingAckTimeout = setTimeout(() => {\n\t\t\tthis._incomingAckTimeout = null;\n\t\t\tthis._sendAckCheck();\n\t\t}, ProtocolConstants.AcknowledgeTime - timeSinceLastIncomingMsg + 5);\n\t}\n\n\tprivate _recvAckCheck(): void {\n\t\tif (this._outgoingMsgId <= this._outgoingAckId) {\n\t\t\t// everything has been acknowledged\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._outgoingAckTimeout) {\n\t\t\t// there will be a check in the near future\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._isReconnecting) {\n\t\t\t// do not cause a timeout during reconnection,\n\t\t\t// because messages will not be actually written until `endAcceptReconnection`\n\t\t\treturn;\n\t\t}\n\n\t\tconst oldestUnacknowledgedMsg = this._outgoingUnackMsg.peek()!;\n\t\tconst timeSinceOldestUnacknowledgedMsg = Date.now() - oldestUnacknowledgedMsg.writtenTime;\n\t\tconst timeSinceLastReceivedSomeData = Date.now() - this._socketReader.lastReadTime;\n\t\tconst timeSinceLastTimeout = Date.now() - this._lastSocketTimeoutTime;\n\n\t\tif (\n\t\t\ttimeSinceOldestUnacknowledgedMsg >= ProtocolConstants.TimeoutTime\n\t\t\t&& timeSinceLastReceivedSomeData >= ProtocolConstants.TimeoutTime\n\t\t\t&& timeSinceLastTimeout >= ProtocolConstants.TimeoutTime\n\t\t) {\n\t\t\t// It's been a long time since our sent message was acknowledged\n\t\t\t// and a long time since we received some data\n\n\t\t\t// But this might be caused by the event loop being busy and failing to read messages\n\t\t\tif (!this._loadEstimator.hasHighLoad()) {\n\t\t\t\t// Trash the socket\n\t\t\t\tthis._lastSocketTimeoutTime = Date.now();\n\t\t\t\tthis._onSocketTimeout.fire({\n\t\t\t\t\tunacknowledgedMsgCount: this._outgoingUnackMsg.length(),\n\t\t\t\t\ttimeSinceOldestUnacknowledgedMsg,\n\t\t\t\t\ttimeSinceLastReceivedSomeData\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tconst minimumTimeUntilTimeout = Math.max(\n\t\t\tProtocolConstants.TimeoutTime - timeSinceOldestUnacknowledgedMsg,\n\t\t\tProtocolConstants.TimeoutTime - timeSinceLastReceivedSomeData,\n\t\t\tProtocolConstants.TimeoutTime - timeSinceLastTimeout,\n\t\t\t500\n\t\t);\n\n\t\tthis._outgoingAckTimeout = setTimeout(() => {\n\t\t\tthis._outgoingAckTimeout = null;\n\t\t\tthis._recvAckCheck();\n\t\t}, minimumTimeUntilTimeout);\n\t}\n\n\tprivate _sendAck(): void {\n\t\tif (this._incomingMsgId <= this._incomingAckId) {\n\t\t\t// nothink to acknowledge\n\t\t\treturn;\n\t\t}\n\n\t\tthis._incomingAckId = this._incomingMsgId;\n\t\tconst msg = new ProtocolMessage(ProtocolMessageType.Ack, 0, this._incomingAckId, getEmptyBuffer());\n\t\tthis._socketWriter.write(msg);\n\t}\n\n\tprivate _sendKeepAlive(): void {\n\t\tthis._incomingAckId = this._incomingMsgId;\n\t\tconst msg = new ProtocolMessage(ProtocolMessageType.KeepAlive, 0, this._incomingAckId, getEmptyBuffer());\n\t\tthis._socketWriter.write(msg);\n\t}\n}\n\n// (() => {\n// \tif (!SocketDiagnostics.enableDiagnostics) {\n// \t\treturn;\n// \t}\n// \tif (typeof require.__$__nodeRequire !== 'function') {\n// \t\tconsole.log(`Can only log socket diagnostics on native platforms.`);\n// \t\treturn;\n// \t}\n// \tconst type = (\n// \t\tprocess.argv.includes('--type=renderer')\n// \t\t\t? 'renderer'\n// \t\t\t: (process.argv.includes('--type=extensionHost')\n// \t\t\t\t? 'extensionHost'\n// \t\t\t\t: (process.argv.some(item => item.includes('server-main'))\n// \t\t\t\t\t? 'server'\n// \t\t\t\t\t: 'unknown'\n// \t\t\t\t)\n// \t\t\t)\n// \t);\n// \tsetTimeout(() => {\n// \t\tSocketDiagnostics.records.forEach(r => {\n// \t\t\tif (r.buff) {\n// \t\t\t\tr.data = Buffer.from(r.buff.buffer).toString('base64');\n// \t\t\t\tr.buff = undefined;\n// \t\t\t}\n// \t\t});\n\n// \t\tconst fs = <typeof import('fs')>require.__$__nodeRequire('fs');\n// \t\tconst path = <typeof import('path')>require.__$__nodeRequire('path');\n// \t\tconst logPath = path.join(process.cwd(),`${type}-${process.pid}`);\n\n// \t\tconsole.log(`dumping socket diagnostics at ${logPath}`);\n// \t\tfs.writeFileSync(logPath, JSON.stringify(SocketDiagnostics.records));\n// \t}, 20000);\n// })();\n"],
  "mappings": "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",
  "names": ["SocketDiagnosticsEventType", "SocketDiagnostics", "SocketCloseEventType", "result", "ProtocolMessageType", "ProtocolConstants"]
}
