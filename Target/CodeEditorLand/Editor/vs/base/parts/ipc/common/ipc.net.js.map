{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/parts/ipc/common/ipc.net.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { VSBuffer } from \"../../../common/buffer.js\";\nimport { Emitter, type Event } from \"../../../common/event.js\";\nimport {\n\tDisposable,\n\tDisposableStore,\n\ttype IDisposable,\n} from \"../../../common/lifecycle.js\";\nimport {\n\ttype IIPCLogger,\n\ttype IMessagePassingProtocol,\n\tIPCClient,\n} from \"./ipc.js\";\n\nexport enum SocketDiagnosticsEventType {\n\tCreated = \"created\",\n\tRead = \"read\",\n\tWrite = \"write\",\n\tOpen = \"open\",\n\tError = \"error\",\n\tClose = \"close\",\n\n\tBrowserWebSocketBlobReceived = \"browserWebSocketBlobReceived\",\n\n\tNodeEndReceived = \"nodeEndReceived\",\n\tNodeEndSent = \"nodeEndSent\",\n\tNodeDrainBegin = \"nodeDrainBegin\",\n\tNodeDrainEnd = \"nodeDrainEnd\",\n\n\tzlibInflateError = \"zlibInflateError\",\n\tzlibInflateData = \"zlibInflateData\",\n\tzlibInflateInitialWrite = \"zlibInflateInitialWrite\",\n\tzlibInflateInitialFlushFired = \"zlibInflateInitialFlushFired\",\n\tzlibInflateWrite = \"zlibInflateWrite\",\n\tzlibInflateFlushFired = \"zlibInflateFlushFired\",\n\tzlibDeflateError = \"zlibDeflateError\",\n\tzlibDeflateData = \"zlibDeflateData\",\n\tzlibDeflateWrite = \"zlibDeflateWrite\",\n\tzlibDeflateFlushFired = \"zlibDeflateFlushFired\",\n\n\tWebSocketNodeSocketWrite = \"webSocketNodeSocketWrite\",\n\tWebSocketNodeSocketPeekedHeader = \"webSocketNodeSocketPeekedHeader\",\n\tWebSocketNodeSocketReadHeader = \"webSocketNodeSocketReadHeader\",\n\tWebSocketNodeSocketReadData = \"webSocketNodeSocketReadData\",\n\tWebSocketNodeSocketUnmaskedData = \"webSocketNodeSocketUnmaskedData\",\n\tWebSocketNodeSocketDrainBegin = \"webSocketNodeSocketDrainBegin\",\n\tWebSocketNodeSocketDrainEnd = \"webSocketNodeSocketDrainEnd\",\n\n\tProtocolHeaderRead = \"protocolHeaderRead\",\n\tProtocolMessageRead = \"protocolMessageRead\",\n\tProtocolHeaderWrite = \"protocolHeaderWrite\",\n\tProtocolMessageWrite = \"protocolMessageWrite\",\n\tProtocolWrite = \"protocolWrite\",\n}\n\nexport namespace SocketDiagnostics {\n\texport const enableDiagnostics = false;\n\n\texport interface IRecord {\n\t\ttimestamp: number;\n\t\tid: string;\n\t\tlabel: string;\n\t\ttype: SocketDiagnosticsEventType;\n\t\tbuff?: VSBuffer;\n\t\tdata?: any;\n\t}\n\n\texport const records: IRecord[] = [];\n\tconst socketIds = new WeakMap<any, string>();\n\tlet lastUsedSocketId = 0;\n\n\tfunction getSocketId(nativeObject: any, label: string): string {\n\t\tif (!socketIds.has(nativeObject)) {\n\t\t\tconst id = String(++lastUsedSocketId);\n\t\t\tsocketIds.set(nativeObject, id);\n\t\t}\n\t\treturn socketIds.get(nativeObject)!;\n\t}\n\n\texport function traceSocketEvent(\n\t\tnativeObject: any,\n\t\tsocketDebugLabel: string,\n\t\ttype: SocketDiagnosticsEventType,\n\t\tdata?: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView | any,\n\t): void {\n\t\tif (!enableDiagnostics) {\n\t\t\treturn;\n\t\t}\n\t\tconst id = getSocketId(nativeObject, socketDebugLabel);\n\n\t\tif (\n\t\t\tdata instanceof VSBuffer ||\n\t\t\tdata instanceof Uint8Array ||\n\t\t\tdata instanceof ArrayBuffer ||\n\t\t\tArrayBuffer.isView(data)\n\t\t) {\n\t\t\tconst copiedData = VSBuffer.alloc(data.byteLength);\n\t\t\tcopiedData.set(data);\n\t\t\trecords.push({\n\t\t\t\ttimestamp: Date.now(),\n\t\t\t\tid,\n\t\t\t\tlabel: socketDebugLabel,\n\t\t\t\ttype,\n\t\t\t\tbuff: copiedData,\n\t\t\t});\n\t\t} else {\n\t\t\t// data is a custom object\n\t\t\trecords.push({\n\t\t\t\ttimestamp: Date.now(),\n\t\t\t\tid,\n\t\t\t\tlabel: socketDebugLabel,\n\t\t\t\ttype,\n\t\t\t\tdata: data,\n\t\t\t});\n\t\t}\n\t}\n}\n\nexport enum SocketCloseEventType {\n\tNodeSocketCloseEvent = 0,\n\tWebSocketCloseEvent = 1,\n}\n\nexport interface NodeSocketCloseEvent {\n\t/**\n\t * The type of the event\n\t */\n\treadonly type: SocketCloseEventType.NodeSocketCloseEvent;\n\t/**\n\t * `true` if the socket had a transmission error.\n\t */\n\treadonly hadError: boolean;\n\t/**\n\t * Underlying error.\n\t */\n\treadonly error: Error | undefined;\n}\n\nexport interface WebSocketCloseEvent {\n\t/**\n\t * The type of the event\n\t */\n\treadonly type: SocketCloseEventType.WebSocketCloseEvent;\n\t/**\n\t * Returns the WebSocket connection close code provided by the server.\n\t */\n\treadonly code: number;\n\t/**\n\t * Returns the WebSocket connection close reason provided by the server.\n\t */\n\treadonly reason: string;\n\t/**\n\t * Returns true if the connection closed cleanly; false otherwise.\n\t */\n\treadonly wasClean: boolean;\n\t/**\n\t * Underlying event.\n\t */\n\treadonly event: any | undefined;\n}\n\nexport type SocketCloseEvent =\n\t| NodeSocketCloseEvent\n\t| WebSocketCloseEvent\n\t| undefined;\n\nexport interface SocketTimeoutEvent {\n\treadonly unacknowledgedMsgCount: number;\n\treadonly timeSinceOldestUnacknowledgedMsg: number;\n\treadonly timeSinceLastReceivedSomeData: number;\n}\n\nexport interface ISocket extends IDisposable {\n\tonData(listener: (e: VSBuffer) => void): IDisposable;\n\tonClose(listener: (e: SocketCloseEvent) => void): IDisposable;\n\tonEnd(listener: () => void): IDisposable;\n\twrite(buffer: VSBuffer): void;\n\tend(): void;\n\tdrain(): Promise<void>;\n\n\ttraceSocketEvent(\n\t\ttype: SocketDiagnosticsEventType,\n\t\tdata?: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView | any,\n\t): void;\n}\n\nlet emptyBuffer: VSBuffer | null = null;\nfunction getEmptyBuffer(): VSBuffer {\n\tif (!emptyBuffer) {\n\t\temptyBuffer = VSBuffer.alloc(0);\n\t}\n\treturn emptyBuffer;\n}\n\nexport class ChunkStream {\n\tprivate _chunks: VSBuffer[];\n\tprivate _totalLength: number;\n\n\tpublic get byteLength() {\n\t\treturn this._totalLength;\n\t}\n\n\tconstructor() {\n\t\tthis._chunks = [];\n\t\tthis._totalLength = 0;\n\t}\n\n\tpublic acceptChunk(buff: VSBuffer) {\n\t\tthis._chunks.push(buff);\n\t\tthis._totalLength += buff.byteLength;\n\t}\n\n\tpublic read(byteCount: number): VSBuffer {\n\t\treturn this._read(byteCount, true);\n\t}\n\n\tpublic peek(byteCount: number): VSBuffer {\n\t\treturn this._read(byteCount, false);\n\t}\n\n\tprivate _read(byteCount: number, advance: boolean): VSBuffer {\n\t\tif (byteCount === 0) {\n\t\t\treturn getEmptyBuffer();\n\t\t}\n\n\t\tif (byteCount > this._totalLength) {\n\t\t\tthrow new Error(`Cannot read so many bytes!`);\n\t\t}\n\n\t\tif (this._chunks[0].byteLength === byteCount) {\n\t\t\t// super fast path, precisely first chunk must be returned\n\t\t\tconst result = this._chunks[0];\n\t\t\tif (advance) {\n\t\t\t\tthis._chunks.shift();\n\t\t\t\tthis._totalLength -= byteCount;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tif (this._chunks[0].byteLength > byteCount) {\n\t\t\t// fast path, the reading is entirely within the first chunk\n\t\t\tconst result = this._chunks[0].slice(0, byteCount);\n\t\t\tif (advance) {\n\t\t\t\tthis._chunks[0] = this._chunks[0].slice(byteCount);\n\t\t\t\tthis._totalLength -= byteCount;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tconst result = VSBuffer.alloc(byteCount);\n\t\tlet resultOffset = 0;\n\t\tlet chunkIndex = 0;\n\t\twhile (byteCount > 0) {\n\t\t\tconst chunk = this._chunks[chunkIndex];\n\t\t\tif (chunk.byteLength > byteCount) {\n\t\t\t\t// this chunk will survive\n\t\t\t\tconst chunkPart = chunk.slice(0, byteCount);\n\t\t\t\tresult.set(chunkPart, resultOffset);\n\t\t\t\tresultOffset += byteCount;\n\n\t\t\t\tif (advance) {\n\t\t\t\t\tthis._chunks[chunkIndex] = chunk.slice(byteCount);\n\t\t\t\t\tthis._totalLength -= byteCount;\n\t\t\t\t}\n\n\t\t\t\tbyteCount -= byteCount;\n\t\t\t} else {\n\t\t\t\t// this chunk will be entirely read\n\t\t\t\tresult.set(chunk, resultOffset);\n\t\t\t\tresultOffset += chunk.byteLength;\n\n\t\t\t\tif (advance) {\n\t\t\t\t\tthis._chunks.shift();\n\t\t\t\t\tthis._totalLength -= chunk.byteLength;\n\t\t\t\t} else {\n\t\t\t\t\tchunkIndex++;\n\t\t\t\t}\n\n\t\t\t\tbyteCount -= chunk.byteLength;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n\nenum ProtocolMessageType {\n\tNone = 0,\n\tRegular = 1,\n\tControl = 2,\n\tAck = 3,\n\tDisconnect = 5,\n\tReplayRequest = 6,\n\tPause = 7,\n\tResume = 8,\n\tKeepAlive = 9,\n}\n\nfunction protocolMessageTypeToString(messageType: ProtocolMessageType) {\n\tswitch (messageType) {\n\t\tcase ProtocolMessageType.None:\n\t\t\treturn \"None\";\n\t\tcase ProtocolMessageType.Regular:\n\t\t\treturn \"Regular\";\n\t\tcase ProtocolMessageType.Control:\n\t\t\treturn \"Control\";\n\t\tcase ProtocolMessageType.Ack:\n\t\t\treturn \"Ack\";\n\t\tcase ProtocolMessageType.Disconnect:\n\t\t\treturn \"Disconnect\";\n\t\tcase ProtocolMessageType.ReplayRequest:\n\t\t\treturn \"ReplayRequest\";\n\t\tcase ProtocolMessageType.Pause:\n\t\t\treturn \"PauseWriting\";\n\t\tcase ProtocolMessageType.Resume:\n\t\t\treturn \"ResumeWriting\";\n\t\tcase ProtocolMessageType.KeepAlive:\n\t\t\treturn \"KeepAlive\";\n\t}\n}\n\nexport enum ProtocolConstants {\n\tHeaderLength = 13,\n\t/**\n\t * Send an Acknowledge message at most 2 seconds later...\n\t */\n\tAcknowledgeTime = 2000, // 2 seconds\n\t/**\n\t * If there is a sent message that has been unacknowledged for 20 seconds,\n\t * and we didn't see any incoming server data in the past 20 seconds,\n\t * then consider the connection has timed out.\n\t */\n\tTimeoutTime = 20000, // 20 seconds\n\t/**\n\t * If there is no reconnection within this time-frame, consider the connection permanently closed...\n\t */\n\tReconnectionGraceTime = 3 * 60 * 60 * 1000, // 3hrs\n\t/**\n\t * Maximal grace time between the first and the last reconnection...\n\t */\n\tReconnectionShortGraceTime = 5 * 60 * 1000, // 5min\n\t/**\n\t * Send a message every 5 seconds to avoid that the connection is closed by the OS.\n\t */\n\tKeepAliveSendTime = 5000, // 5 seconds\n}\n\nclass ProtocolMessage {\n\tpublic writtenTime: number;\n\n\tconstructor(\n\t\tpublic readonly type: ProtocolMessageType,\n\t\tpublic readonly id: number,\n\t\tpublic readonly ack: number,\n\t\tpublic readonly data: VSBuffer,\n\t) {\n\t\tthis.writtenTime = 0;\n\t}\n\n\tpublic get size(): number {\n\t\treturn this.data.byteLength;\n\t}\n}\n\nclass ProtocolReader extends Disposable {\n\tprivate readonly _socket: ISocket;\n\tprivate _isDisposed: boolean;\n\tprivate readonly _incomingData: ChunkStream;\n\tpublic lastReadTime: number;\n\n\tprivate readonly _onMessage = this._register(\n\t\tnew Emitter<ProtocolMessage>(),\n\t);\n\tpublic readonly onMessage: Event<ProtocolMessage> = this._onMessage.event;\n\n\tprivate readonly _state = {\n\t\treadHead: true,\n\t\treadLen: ProtocolConstants.HeaderLength,\n\t\tmessageType: ProtocolMessageType.None,\n\t\tid: 0,\n\t\tack: 0,\n\t};\n\n\tconstructor(socket: ISocket) {\n\t\tsuper();\n\t\tthis._socket = socket;\n\t\tthis._isDisposed = false;\n\t\tthis._incomingData = new ChunkStream();\n\t\tthis._register(this._socket.onData((data) => this.acceptChunk(data)));\n\t\tthis.lastReadTime = Date.now();\n\t}\n\n\tpublic acceptChunk(data: VSBuffer | null): void {\n\t\tif (!data || data.byteLength === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.lastReadTime = Date.now();\n\n\t\tthis._incomingData.acceptChunk(data);\n\n\t\twhile (this._incomingData.byteLength >= this._state.readLen) {\n\t\t\tconst buff = this._incomingData.read(this._state.readLen);\n\n\t\t\tif (this._state.readHead) {\n\t\t\t\t// buff is the header\n\n\t\t\t\t// save new state => next time will read the body\n\t\t\t\tthis._state.readHead = false;\n\t\t\t\tthis._state.readLen = buff.readUInt32BE(9);\n\t\t\t\tthis._state.messageType = buff.readUInt8(0);\n\t\t\t\tthis._state.id = buff.readUInt32BE(1);\n\t\t\t\tthis._state.ack = buff.readUInt32BE(5);\n\n\t\t\t\tthis._socket.traceSocketEvent(\n\t\t\t\t\tSocketDiagnosticsEventType.ProtocolHeaderRead,\n\t\t\t\t\t{\n\t\t\t\t\t\tmessageType: protocolMessageTypeToString(\n\t\t\t\t\t\t\tthis._state.messageType,\n\t\t\t\t\t\t),\n\t\t\t\t\t\tid: this._state.id,\n\t\t\t\t\t\tack: this._state.ack,\n\t\t\t\t\t\tmessageSize: this._state.readLen,\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t// buff is the body\n\t\t\t\tconst messageType = this._state.messageType;\n\t\t\t\tconst id = this._state.id;\n\t\t\t\tconst ack = this._state.ack;\n\n\t\t\t\t// save new state => next time will read the header\n\t\t\t\tthis._state.readHead = true;\n\t\t\t\tthis._state.readLen = ProtocolConstants.HeaderLength;\n\t\t\t\tthis._state.messageType = ProtocolMessageType.None;\n\t\t\t\tthis._state.id = 0;\n\t\t\t\tthis._state.ack = 0;\n\n\t\t\t\tthis._socket.traceSocketEvent(\n\t\t\t\t\tSocketDiagnosticsEventType.ProtocolMessageRead,\n\t\t\t\t\tbuff,\n\t\t\t\t);\n\n\t\t\t\tthis._onMessage.fire(\n\t\t\t\t\tnew ProtocolMessage(messageType, id, ack, buff),\n\t\t\t\t);\n\n\t\t\t\tif (this._isDisposed) {\n\t\t\t\t\t// check if an event listener lead to our disposal\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic readEntireBuffer(): VSBuffer {\n\t\treturn this._incomingData.read(this._incomingData.byteLength);\n\t}\n\n\tpublic override dispose(): void {\n\t\tthis._isDisposed = true;\n\t\tsuper.dispose();\n\t}\n}\n\nclass ProtocolWriter {\n\tprivate _isDisposed: boolean;\n\tprivate _isPaused: boolean;\n\tprivate readonly _socket: ISocket;\n\tprivate _data: VSBuffer[];\n\tprivate _totalLength: number;\n\tpublic lastWriteTime: number;\n\n\tconstructor(socket: ISocket) {\n\t\tthis._isDisposed = false;\n\t\tthis._isPaused = false;\n\t\tthis._socket = socket;\n\t\tthis._data = [];\n\t\tthis._totalLength = 0;\n\t\tthis.lastWriteTime = 0;\n\t}\n\n\tpublic dispose(): void {\n\t\ttry {\n\t\t\tthis.flush();\n\t\t} catch (err) {\n\t\t\t// ignore error, since the socket could be already closed\n\t\t}\n\t\tthis._isDisposed = true;\n\t}\n\n\tpublic drain(): Promise<void> {\n\t\tthis.flush();\n\t\treturn this._socket.drain();\n\t}\n\n\tpublic flush(): void {\n\t\t// flush\n\t\tthis._writeNow();\n\t}\n\n\tpublic pause(): void {\n\t\tthis._isPaused = true;\n\t}\n\n\tpublic resume(): void {\n\t\tthis._isPaused = false;\n\t\tthis._scheduleWriting();\n\t}\n\n\tpublic write(msg: ProtocolMessage) {\n\t\tif (this._isDisposed) {\n\t\t\t// ignore: there could be left-over promises which complete and then\n\t\t\t// decide to write a response, etc...\n\t\t\treturn;\n\t\t}\n\t\tmsg.writtenTime = Date.now();\n\t\tthis.lastWriteTime = Date.now();\n\t\tconst header = VSBuffer.alloc(ProtocolConstants.HeaderLength);\n\t\theader.writeUInt8(msg.type, 0);\n\t\theader.writeUInt32BE(msg.id, 1);\n\t\theader.writeUInt32BE(msg.ack, 5);\n\t\theader.writeUInt32BE(msg.data.byteLength, 9);\n\n\t\tthis._socket.traceSocketEvent(\n\t\t\tSocketDiagnosticsEventType.ProtocolHeaderWrite,\n\t\t\t{\n\t\t\t\tmessageType: protocolMessageTypeToString(msg.type),\n\t\t\t\tid: msg.id,\n\t\t\t\tack: msg.ack,\n\t\t\t\tmessageSize: msg.data.byteLength,\n\t\t\t},\n\t\t);\n\t\tthis._socket.traceSocketEvent(\n\t\t\tSocketDiagnosticsEventType.ProtocolMessageWrite,\n\t\t\tmsg.data,\n\t\t);\n\n\t\tthis._writeSoon(header, msg.data);\n\t}\n\n\tprivate _bufferAdd(head: VSBuffer, body: VSBuffer): boolean {\n\t\tconst wasEmpty = this._totalLength === 0;\n\t\tthis._data.push(head, body);\n\t\tthis._totalLength += head.byteLength + body.byteLength;\n\t\treturn wasEmpty;\n\t}\n\n\tprivate _bufferTake(): VSBuffer {\n\t\tconst ret = VSBuffer.concat(this._data, this._totalLength);\n\t\tthis._data.length = 0;\n\t\tthis._totalLength = 0;\n\t\treturn ret;\n\t}\n\n\tprivate _writeSoon(header: VSBuffer, data: VSBuffer): void {\n\t\tif (this._bufferAdd(header, data)) {\n\t\t\tthis._scheduleWriting();\n\t\t}\n\t}\n\n\tprivate _writeNowTimeout: any = null;\n\tprivate _scheduleWriting(): void {\n\t\tif (this._writeNowTimeout) {\n\t\t\treturn;\n\t\t}\n\t\tthis._writeNowTimeout = setTimeout(() => {\n\t\t\tthis._writeNowTimeout = null;\n\t\t\tthis._writeNow();\n\t\t});\n\t}\n\n\tprivate _writeNow(): void {\n\t\tif (this._totalLength === 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._isPaused) {\n\t\t\treturn;\n\t\t}\n\t\tconst data = this._bufferTake();\n\t\tthis._socket.traceSocketEvent(\n\t\t\tSocketDiagnosticsEventType.ProtocolWrite,\n\t\t\t{ byteLength: data.byteLength },\n\t\t);\n\t\tthis._socket.write(data);\n\t}\n}\n\n/**\n * A message has the following format:\n * ```\n *     /-------------------------------|------\\\n *     |             HEADER            |      |\n *     |-------------------------------| DATA |\n *     | TYPE | ID | ACK | DATA_LENGTH |      |\n *     \\-------------------------------|------/\n * ```\n * The header is 9 bytes and consists of:\n *  - TYPE is 1 byte (ProtocolMessageType) - the message type\n *  - ID is 4 bytes (u32be) - the message id (can be 0 to indicate to be ignored)\n *  - ACK is 4 bytes (u32be) - the acknowledged message id (can be 0 to indicate to be ignored)\n *  - DATA_LENGTH is 4 bytes (u32be) - the length in bytes of DATA\n *\n * Only Regular messages are counted, other messages are not counted, nor acknowledged.\n */\nexport class Protocol extends Disposable implements IMessagePassingProtocol {\n\tprivate _socket: ISocket;\n\tprivate _socketWriter: ProtocolWriter;\n\tprivate _socketReader: ProtocolReader;\n\n\tprivate readonly _onMessage = new Emitter<VSBuffer>();\n\treadonly onMessage: Event<VSBuffer> = this._onMessage.event;\n\n\tprivate readonly _onDidDispose = new Emitter<void>();\n\treadonly onDidDispose: Event<void> = this._onDidDispose.event;\n\n\tconstructor(socket: ISocket) {\n\t\tsuper();\n\t\tthis._socket = socket;\n\t\tthis._socketWriter = this._register(new ProtocolWriter(this._socket));\n\t\tthis._socketReader = this._register(new ProtocolReader(this._socket));\n\n\t\tthis._register(\n\t\t\tthis._socketReader.onMessage((msg) => {\n\t\t\t\tif (msg.type === ProtocolMessageType.Regular) {\n\t\t\t\t\tthis._onMessage.fire(msg.data);\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\n\t\tthis._register(this._socket.onClose(() => this._onDidDispose.fire()));\n\t}\n\n\tdrain(): Promise<void> {\n\t\treturn this._socketWriter.drain();\n\t}\n\n\tgetSocket(): ISocket {\n\t\treturn this._socket;\n\t}\n\n\tsendDisconnect(): void {\n\t\t// Nothing to do...\n\t}\n\n\tsend(buffer: VSBuffer): void {\n\t\tthis._socketWriter.write(\n\t\t\tnew ProtocolMessage(ProtocolMessageType.Regular, 0, 0, buffer),\n\t\t);\n\t}\n}\n\nexport class Client<TContext = string> extends IPCClient<TContext> {\n\tstatic fromSocket<TContext = string>(\n\t\tsocket: ISocket,\n\t\tid: TContext,\n\t): Client<TContext> {\n\t\treturn new Client(new Protocol(socket), id);\n\t}\n\n\tget onDidDispose(): Event<void> {\n\t\treturn this.protocol.onDidDispose;\n\t}\n\n\tconstructor(\n\t\tprivate protocol: Protocol | PersistentProtocol,\n\t\tid: TContext,\n\t\tipcLogger: IIPCLogger | null = null,\n\t) {\n\t\tsuper(protocol, id, ipcLogger);\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\t\tconst socket = this.protocol.getSocket();\n\t\t// should be sent gracefully with a .flush(), but try to send it out as a\n\t\t// last resort here if nothing else:\n\t\tthis.protocol.sendDisconnect();\n\t\tthis.protocol.dispose();\n\t\tsocket.end();\n\t}\n}\n\n/**\n * Will ensure no messages are lost if there are no event listeners.\n */\nexport class BufferedEmitter<T> {\n\tprivate _emitter: Emitter<T>;\n\tpublic readonly event: Event<T>;\n\n\tprivate _hasListeners = false;\n\tprivate _isDeliveringMessages = false;\n\tprivate _bufferedMessages: T[] = [];\n\n\tconstructor() {\n\t\tthis._emitter = new Emitter<T>({\n\t\t\tonWillAddFirstListener: () => {\n\t\t\t\tthis._hasListeners = true;\n\t\t\t\t// it is important to deliver these messages after this call, but before\n\t\t\t\t// other messages have a chance to be received (to guarantee in order delivery)\n\t\t\t\t// that's why we're using here queueMicrotask and not other types of timeouts\n\t\t\t\tqueueMicrotask(() => this._deliverMessages());\n\t\t\t},\n\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\tthis._hasListeners = false;\n\t\t\t},\n\t\t});\n\n\t\tthis.event = this._emitter.event;\n\t}\n\n\tprivate _deliverMessages(): void {\n\t\tif (this._isDeliveringMessages) {\n\t\t\treturn;\n\t\t}\n\t\tthis._isDeliveringMessages = true;\n\t\twhile (this._hasListeners && this._bufferedMessages.length > 0) {\n\t\t\tthis._emitter.fire(this._bufferedMessages.shift()!);\n\t\t}\n\t\tthis._isDeliveringMessages = false;\n\t}\n\n\tpublic fire(event: T): void {\n\t\tif (this._hasListeners) {\n\t\t\tif (this._bufferedMessages.length > 0) {\n\t\t\t\tthis._bufferedMessages.push(event);\n\t\t\t} else {\n\t\t\t\tthis._emitter.fire(event);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._bufferedMessages.push(event);\n\t\t}\n\t}\n\n\tpublic flushBuffer(): void {\n\t\tthis._bufferedMessages = [];\n\t}\n}\n\nclass QueueElement<T> {\n\tpublic readonly data: T;\n\tpublic next: QueueElement<T> | null;\n\n\tconstructor(data: T) {\n\t\tthis.data = data;\n\t\tthis.next = null;\n\t}\n}\n\nclass Queue<T> {\n\tprivate _first: QueueElement<T> | null;\n\tprivate _last: QueueElement<T> | null;\n\n\tconstructor() {\n\t\tthis._first = null;\n\t\tthis._last = null;\n\t}\n\n\tpublic length(): number {\n\t\tlet result = 0;\n\t\tlet current = this._first;\n\t\twhile (current) {\n\t\t\tcurrent = current.next;\n\t\t\tresult++;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic peek(): T | null {\n\t\tif (!this._first) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this._first.data;\n\t}\n\n\tpublic toArray(): T[] {\n\t\tconst result: T[] = [];\n\t\tlet resultLen = 0;\n\t\tlet it = this._first;\n\t\twhile (it) {\n\t\t\tresult[resultLen++] = it.data;\n\t\t\tit = it.next;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic pop(): void {\n\t\tif (!this._first) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._first === this._last) {\n\t\t\tthis._first = null;\n\t\t\tthis._last = null;\n\t\t\treturn;\n\t\t}\n\t\tthis._first = this._first.next;\n\t}\n\n\tpublic push(item: T): void {\n\t\tconst element = new QueueElement(item);\n\t\tif (!this._first) {\n\t\t\tthis._first = element;\n\t\t\tthis._last = element;\n\t\t\treturn;\n\t\t}\n\t\tthis._last!.next = element;\n\t\tthis._last = element;\n\t}\n}\n\nclass LoadEstimator {\n\tprivate static _HISTORY_LENGTH = 10;\n\tprivate static _INSTANCE: LoadEstimator | null = null;\n\tpublic static getInstance(): LoadEstimator {\n\t\tif (!LoadEstimator._INSTANCE) {\n\t\t\tLoadEstimator._INSTANCE = new LoadEstimator();\n\t\t}\n\t\treturn LoadEstimator._INSTANCE;\n\t}\n\n\tprivate lastRuns: number[];\n\n\tconstructor() {\n\t\tthis.lastRuns = [];\n\t\tconst now = Date.now();\n\t\tfor (let i = 0; i < LoadEstimator._HISTORY_LENGTH; i++) {\n\t\t\tthis.lastRuns[i] = now - 1000 * i;\n\t\t}\n\t\tsetInterval(() => {\n\t\t\tfor (let i = LoadEstimator._HISTORY_LENGTH; i >= 1; i--) {\n\t\t\t\tthis.lastRuns[i] = this.lastRuns[i - 1];\n\t\t\t}\n\t\t\tthis.lastRuns[0] = Date.now();\n\t\t}, 1000);\n\t}\n\n\t/**\n\t * returns an estimative number, from 0 (low load) to 1 (high load)\n\t */\n\tprivate load(): number {\n\t\tconst now = Date.now();\n\t\tconst historyLimit = (1 + LoadEstimator._HISTORY_LENGTH) * 1000;\n\t\tlet score = 0;\n\t\tfor (let i = 0; i < LoadEstimator._HISTORY_LENGTH; i++) {\n\t\t\tif (now - this.lastRuns[i] <= historyLimit) {\n\t\t\t\tscore++;\n\t\t\t}\n\t\t}\n\t\treturn 1 - score / LoadEstimator._HISTORY_LENGTH;\n\t}\n\n\tpublic hasHighLoad(): boolean {\n\t\treturn this.load() >= 0.5;\n\t}\n}\n\nexport interface ILoadEstimator {\n\thasHighLoad(): boolean;\n}\n\nexport interface PersistentProtocolOptions {\n\t/**\n\t * The socket to use.\n\t */\n\tsocket: ISocket;\n\t/**\n\t * The initial chunk of data that has already been received from the socket.\n\t */\n\tinitialChunk?: VSBuffer | null;\n\t/**\n\t * The CPU load estimator to use.\n\t */\n\tloadEstimator?: ILoadEstimator;\n\t/**\n\t * Whether to send keep alive messages. Defaults to true.\n\t */\n\tsendKeepAlive?: boolean;\n}\n\n/**\n * Same as Protocol, but will actually track messages and acks.\n * Moreover, it will ensure no messages are lost if there are no event listeners.\n */\nexport class PersistentProtocol implements IMessagePassingProtocol {\n\tprivate _isReconnecting: boolean;\n\tprivate _didSendDisconnect?: boolean;\n\n\tprivate _outgoingUnackMsg: Queue<ProtocolMessage>;\n\tprivate _outgoingMsgId: number;\n\tprivate _outgoingAckId: number;\n\tprivate _outgoingAckTimeout: any | null;\n\n\tprivate _incomingMsgId: number;\n\tprivate _incomingAckId: number;\n\tprivate _incomingMsgLastTime: number;\n\tprivate _incomingAckTimeout: any | null;\n\n\tprivate _keepAliveInterval: any | null;\n\n\tprivate _lastReplayRequestTime: number;\n\tprivate _lastSocketTimeoutTime: number;\n\n\tprivate _socket: ISocket;\n\tprivate _socketWriter: ProtocolWriter;\n\tprivate _socketReader: ProtocolReader;\n\t// eslint-disable-next-line local/code-no-potentially-unsafe-disposables\n\tprivate _socketDisposables: DisposableStore;\n\n\tprivate readonly _loadEstimator: ILoadEstimator;\n\tprivate readonly _shouldSendKeepAlive: boolean;\n\n\tprivate readonly _onControlMessage = new BufferedEmitter<VSBuffer>();\n\treadonly onControlMessage: Event<VSBuffer> = this._onControlMessage.event;\n\n\tprivate readonly _onMessage = new BufferedEmitter<VSBuffer>();\n\treadonly onMessage: Event<VSBuffer> = this._onMessage.event;\n\n\tprivate readonly _onDidDispose = new BufferedEmitter<void>();\n\treadonly onDidDispose: Event<void> = this._onDidDispose.event;\n\n\tprivate readonly _onSocketClose = new BufferedEmitter<SocketCloseEvent>();\n\treadonly onSocketClose: Event<SocketCloseEvent> = this._onSocketClose.event;\n\n\tprivate readonly _onSocketTimeout =\n\t\tnew BufferedEmitter<SocketTimeoutEvent>();\n\treadonly onSocketTimeout: Event<SocketTimeoutEvent> =\n\t\tthis._onSocketTimeout.event;\n\n\tpublic get unacknowledgedCount(): number {\n\t\treturn this._outgoingMsgId - this._outgoingAckId;\n\t}\n\n\tconstructor(opts: PersistentProtocolOptions) {\n\t\tthis._loadEstimator = opts.loadEstimator ?? LoadEstimator.getInstance();\n\t\tthis._shouldSendKeepAlive = opts.sendKeepAlive ?? true;\n\t\tthis._isReconnecting = false;\n\t\tthis._outgoingUnackMsg = new Queue<ProtocolMessage>();\n\t\tthis._outgoingMsgId = 0;\n\t\tthis._outgoingAckId = 0;\n\t\tthis._outgoingAckTimeout = null;\n\n\t\tthis._incomingMsgId = 0;\n\t\tthis._incomingAckId = 0;\n\t\tthis._incomingMsgLastTime = 0;\n\t\tthis._incomingAckTimeout = null;\n\n\t\tthis._lastReplayRequestTime = 0;\n\t\tthis._lastSocketTimeoutTime = Date.now();\n\n\t\tthis._socketDisposables = new DisposableStore();\n\t\tthis._socket = opts.socket;\n\t\tthis._socketWriter = this._socketDisposables.add(\n\t\t\tnew ProtocolWriter(this._socket),\n\t\t);\n\t\tthis._socketReader = this._socketDisposables.add(\n\t\t\tnew ProtocolReader(this._socket),\n\t\t);\n\t\tthis._socketDisposables.add(\n\t\t\tthis._socketReader.onMessage((msg) => this._receiveMessage(msg)),\n\t\t);\n\t\tthis._socketDisposables.add(\n\t\t\tthis._socket.onClose((e) => this._onSocketClose.fire(e)),\n\t\t);\n\n\t\tif (opts.initialChunk) {\n\t\t\tthis._socketReader.acceptChunk(opts.initialChunk);\n\t\t}\n\n\t\tif (this._shouldSendKeepAlive) {\n\t\t\tthis._keepAliveInterval = setInterval(() => {\n\t\t\t\tthis._sendKeepAlive();\n\t\t\t}, ProtocolConstants.KeepAliveSendTime);\n\t\t} else {\n\t\t\tthis._keepAliveInterval = null;\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tif (this._outgoingAckTimeout) {\n\t\t\tclearTimeout(this._outgoingAckTimeout);\n\t\t\tthis._outgoingAckTimeout = null;\n\t\t}\n\t\tif (this._incomingAckTimeout) {\n\t\t\tclearTimeout(this._incomingAckTimeout);\n\t\t\tthis._incomingAckTimeout = null;\n\t\t}\n\t\tif (this._keepAliveInterval) {\n\t\t\tclearInterval(this._keepAliveInterval);\n\t\t\tthis._keepAliveInterval = null;\n\t\t}\n\t\tthis._socketDisposables.dispose();\n\t}\n\n\tdrain(): Promise<void> {\n\t\treturn this._socketWriter.drain();\n\t}\n\n\tsendDisconnect(): void {\n\t\tif (!this._didSendDisconnect) {\n\t\t\tthis._didSendDisconnect = true;\n\t\t\tconst msg = new ProtocolMessage(\n\t\t\t\tProtocolMessageType.Disconnect,\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tgetEmptyBuffer(),\n\t\t\t);\n\t\t\tthis._socketWriter.write(msg);\n\t\t\tthis._socketWriter.flush();\n\t\t}\n\t}\n\n\tsendPause(): void {\n\t\tconst msg = new ProtocolMessage(\n\t\t\tProtocolMessageType.Pause,\n\t\t\t0,\n\t\t\t0,\n\t\t\tgetEmptyBuffer(),\n\t\t);\n\t\tthis._socketWriter.write(msg);\n\t}\n\n\tsendResume(): void {\n\t\tconst msg = new ProtocolMessage(\n\t\t\tProtocolMessageType.Resume,\n\t\t\t0,\n\t\t\t0,\n\t\t\tgetEmptyBuffer(),\n\t\t);\n\t\tthis._socketWriter.write(msg);\n\t}\n\n\tpauseSocketWriting() {\n\t\tthis._socketWriter.pause();\n\t}\n\n\tpublic getSocket(): ISocket {\n\t\treturn this._socket;\n\t}\n\n\tpublic getMillisSinceLastIncomingData(): number {\n\t\treturn Date.now() - this._socketReader.lastReadTime;\n\t}\n\n\tpublic beginAcceptReconnection(\n\t\tsocket: ISocket,\n\t\tinitialDataChunk: VSBuffer | null,\n\t): void {\n\t\tthis._isReconnecting = true;\n\n\t\tthis._socketDisposables.dispose();\n\t\tthis._socketDisposables = new DisposableStore();\n\t\tthis._onControlMessage.flushBuffer();\n\t\tthis._onSocketClose.flushBuffer();\n\t\tthis._onSocketTimeout.flushBuffer();\n\t\tthis._socket.dispose();\n\n\t\tthis._lastReplayRequestTime = 0;\n\t\tthis._lastSocketTimeoutTime = Date.now();\n\n\t\tthis._socket = socket;\n\t\tthis._socketWriter = this._socketDisposables.add(\n\t\t\tnew ProtocolWriter(this._socket),\n\t\t);\n\t\tthis._socketReader = this._socketDisposables.add(\n\t\t\tnew ProtocolReader(this._socket),\n\t\t);\n\t\tthis._socketDisposables.add(\n\t\t\tthis._socketReader.onMessage((msg) => this._receiveMessage(msg)),\n\t\t);\n\t\tthis._socketDisposables.add(\n\t\t\tthis._socket.onClose((e) => this._onSocketClose.fire(e)),\n\t\t);\n\n\t\tthis._socketReader.acceptChunk(initialDataChunk);\n\t}\n\n\tpublic endAcceptReconnection(): void {\n\t\tthis._isReconnecting = false;\n\n\t\t// After a reconnection, let the other party know (again) which messages have been received.\n\t\t// (perhaps the other party didn't receive a previous ACK)\n\t\tthis._incomingAckId = this._incomingMsgId;\n\t\tconst msg = new ProtocolMessage(\n\t\t\tProtocolMessageType.Ack,\n\t\t\t0,\n\t\t\tthis._incomingAckId,\n\t\t\tgetEmptyBuffer(),\n\t\t);\n\t\tthis._socketWriter.write(msg);\n\n\t\t// Send again all unacknowledged messages\n\t\tconst toSend = this._outgoingUnackMsg.toArray();\n\t\tfor (let i = 0, len = toSend.length; i < len; i++) {\n\t\t\tthis._socketWriter.write(toSend[i]);\n\t\t}\n\t\tthis._recvAckCheck();\n\t}\n\n\tpublic acceptDisconnect(): void {\n\t\tthis._onDidDispose.fire();\n\t}\n\n\tprivate _receiveMessage(msg: ProtocolMessage): void {\n\t\tif (msg.ack > this._outgoingAckId) {\n\t\t\tthis._outgoingAckId = msg.ack;\n\t\t\tdo {\n\t\t\t\tconst first = this._outgoingUnackMsg.peek();\n\t\t\t\tif (first && first.id <= msg.ack) {\n\t\t\t\t\t// this message has been confirmed, remove it\n\t\t\t\t\tthis._outgoingUnackMsg.pop();\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (true);\n\t\t}\n\n\t\tswitch (msg.type) {\n\t\t\tcase ProtocolMessageType.None: {\n\t\t\t\t// N/A\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.Regular: {\n\t\t\t\tif (msg.id > this._incomingMsgId) {\n\t\t\t\t\tif (msg.id !== this._incomingMsgId + 1) {\n\t\t\t\t\t\t// in case we missed some messages we ask the other party to resend them\n\t\t\t\t\t\tconst now = Date.now();\n\t\t\t\t\t\tif (now - this._lastReplayRequestTime > 10000) {\n\t\t\t\t\t\t\t// send a replay request at most once every 10s\n\t\t\t\t\t\t\tthis._lastReplayRequestTime = now;\n\t\t\t\t\t\t\tthis._socketWriter.write(\n\t\t\t\t\t\t\t\tnew ProtocolMessage(\n\t\t\t\t\t\t\t\t\tProtocolMessageType.ReplayRequest,\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t\tgetEmptyBuffer(),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._incomingMsgId = msg.id;\n\t\t\t\t\t\tthis._incomingMsgLastTime = Date.now();\n\t\t\t\t\t\tthis._sendAckCheck();\n\t\t\t\t\t\tthis._onMessage.fire(msg.data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.Control: {\n\t\t\t\tthis._onControlMessage.fire(msg.data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.Ack: {\n\t\t\t\t// nothing to do, .ack is handled above already\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.Disconnect: {\n\t\t\t\tthis._onDidDispose.fire();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.ReplayRequest: {\n\t\t\t\t// Send again all unacknowledged messages\n\t\t\t\tconst toSend = this._outgoingUnackMsg.toArray();\n\t\t\t\tfor (let i = 0, len = toSend.length; i < len; i++) {\n\t\t\t\t\tthis._socketWriter.write(toSend[i]);\n\t\t\t\t}\n\t\t\t\tthis._recvAckCheck();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.Pause: {\n\t\t\t\tthis._socketWriter.pause();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.Resume: {\n\t\t\t\tthis._socketWriter.resume();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.KeepAlive: {\n\t\t\t\t// nothing to do\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treadEntireBuffer(): VSBuffer {\n\t\treturn this._socketReader.readEntireBuffer();\n\t}\n\n\tflush(): void {\n\t\tthis._socketWriter.flush();\n\t}\n\n\tsend(buffer: VSBuffer): void {\n\t\tconst myId = ++this._outgoingMsgId;\n\t\tthis._incomingAckId = this._incomingMsgId;\n\t\tconst msg = new ProtocolMessage(\n\t\t\tProtocolMessageType.Regular,\n\t\t\tmyId,\n\t\t\tthis._incomingAckId,\n\t\t\tbuffer,\n\t\t);\n\t\tthis._outgoingUnackMsg.push(msg);\n\t\tif (!this._isReconnecting) {\n\t\t\tthis._socketWriter.write(msg);\n\t\t\tthis._recvAckCheck();\n\t\t}\n\t}\n\n\t/**\n\t * Send a message which will not be part of the regular acknowledge flow.\n\t * Use this for early control messages which are repeated in case of reconnection.\n\t */\n\tsendControl(buffer: VSBuffer): void {\n\t\tconst msg = new ProtocolMessage(\n\t\t\tProtocolMessageType.Control,\n\t\t\t0,\n\t\t\t0,\n\t\t\tbuffer,\n\t\t);\n\t\tthis._socketWriter.write(msg);\n\t}\n\n\tprivate _sendAckCheck(): void {\n\t\tif (this._incomingMsgId <= this._incomingAckId) {\n\t\t\t// nothink to acknowledge\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._incomingAckTimeout) {\n\t\t\t// there will be a check in the near future\n\t\t\treturn;\n\t\t}\n\n\t\tconst timeSinceLastIncomingMsg = Date.now() - this._incomingMsgLastTime;\n\t\tif (timeSinceLastIncomingMsg >= ProtocolConstants.AcknowledgeTime) {\n\t\t\t// sufficient time has passed since this message has been received,\n\t\t\t// and no message from our side needed to be sent in the meantime,\n\t\t\t// so we will send a message containing only an ack.\n\t\t\tthis._sendAck();\n\t\t\treturn;\n\t\t}\n\n\t\tthis._incomingAckTimeout = setTimeout(\n\t\t\t() => {\n\t\t\t\tthis._incomingAckTimeout = null;\n\t\t\t\tthis._sendAckCheck();\n\t\t\t},\n\t\t\tProtocolConstants.AcknowledgeTime - timeSinceLastIncomingMsg + 5,\n\t\t);\n\t}\n\n\tprivate _recvAckCheck(): void {\n\t\tif (this._outgoingMsgId <= this._outgoingAckId) {\n\t\t\t// everything has been acknowledged\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._outgoingAckTimeout) {\n\t\t\t// there will be a check in the near future\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._isReconnecting) {\n\t\t\t// do not cause a timeout during reconnection,\n\t\t\t// because messages will not be actually written until `endAcceptReconnection`\n\t\t\treturn;\n\t\t}\n\n\t\tconst oldestUnacknowledgedMsg = this._outgoingUnackMsg.peek()!;\n\t\tconst timeSinceOldestUnacknowledgedMsg =\n\t\t\tDate.now() - oldestUnacknowledgedMsg.writtenTime;\n\t\tconst timeSinceLastReceivedSomeData =\n\t\t\tDate.now() - this._socketReader.lastReadTime;\n\t\tconst timeSinceLastTimeout = Date.now() - this._lastSocketTimeoutTime;\n\n\t\tif (\n\t\t\ttimeSinceOldestUnacknowledgedMsg >= ProtocolConstants.TimeoutTime &&\n\t\t\ttimeSinceLastReceivedSomeData >= ProtocolConstants.TimeoutTime &&\n\t\t\ttimeSinceLastTimeout >= ProtocolConstants.TimeoutTime\n\t\t) {\n\t\t\t// It's been a long time since our sent message was acknowledged\n\t\t\t// and a long time since we received some data\n\n\t\t\t// But this might be caused by the event loop being busy and failing to read messages\n\t\t\tif (!this._loadEstimator.hasHighLoad()) {\n\t\t\t\t// Trash the socket\n\t\t\t\tthis._lastSocketTimeoutTime = Date.now();\n\t\t\t\tthis._onSocketTimeout.fire({\n\t\t\t\t\tunacknowledgedMsgCount: this._outgoingUnackMsg.length(),\n\t\t\t\t\ttimeSinceOldestUnacknowledgedMsg,\n\t\t\t\t\ttimeSinceLastReceivedSomeData,\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tconst minimumTimeUntilTimeout = Math.max(\n\t\t\tProtocolConstants.TimeoutTime - timeSinceOldestUnacknowledgedMsg,\n\t\t\tProtocolConstants.TimeoutTime - timeSinceLastReceivedSomeData,\n\t\t\tProtocolConstants.TimeoutTime - timeSinceLastTimeout,\n\t\t\t500,\n\t\t);\n\n\t\tthis._outgoingAckTimeout = setTimeout(() => {\n\t\t\tthis._outgoingAckTimeout = null;\n\t\t\tthis._recvAckCheck();\n\t\t}, minimumTimeUntilTimeout);\n\t}\n\n\tprivate _sendAck(): void {\n\t\tif (this._incomingMsgId <= this._incomingAckId) {\n\t\t\t// nothink to acknowledge\n\t\t\treturn;\n\t\t}\n\n\t\tthis._incomingAckId = this._incomingMsgId;\n\t\tconst msg = new ProtocolMessage(\n\t\t\tProtocolMessageType.Ack,\n\t\t\t0,\n\t\t\tthis._incomingAckId,\n\t\t\tgetEmptyBuffer(),\n\t\t);\n\t\tthis._socketWriter.write(msg);\n\t}\n\n\tprivate _sendKeepAlive(): void {\n\t\tthis._incomingAckId = this._incomingMsgId;\n\t\tconst msg = new ProtocolMessage(\n\t\t\tProtocolMessageType.KeepAlive,\n\t\t\t0,\n\t\t\tthis._incomingAckId,\n\t\t\tgetEmptyBuffer(),\n\t\t);\n\t\tthis._socketWriter.write(msg);\n\t}\n}\n\n// (() => {\n// \tif (!SocketDiagnostics.enableDiagnostics) {\n// \t\treturn;\n// \t}\n// \tif (typeof require.__$__nodeRequire !== 'function') {\n// \t\tconsole.log(`Can only log socket diagnostics on native platforms.`);\n// \t\treturn;\n// \t}\n// \tconst type = (\n// \t\tprocess.argv.includes('--type=renderer')\n// \t\t\t? 'renderer'\n// \t\t\t: (process.argv.includes('--type=extensionHost')\n// \t\t\t\t? 'extensionHost'\n// \t\t\t\t: (process.argv.some(item => item.includes('server-main'))\n// \t\t\t\t\t? 'server'\n// \t\t\t\t\t: 'unknown'\n// \t\t\t\t)\n// \t\t\t)\n// \t);\n// \tsetTimeout(() => {\n// \t\tSocketDiagnostics.records.forEach(r => {\n// \t\t\tif (r.buff) {\n// \t\t\t\tr.data = Buffer.from(r.buff.buffer).toString('base64');\n// \t\t\t\tr.buff = undefined;\n// \t\t\t}\n// \t\t});\n\n// \t\tconst fs = <typeof import('fs')>require.__$__nodeRequire('fs');\n// \t\tconst path = <typeof import('path')>require.__$__nodeRequire('path');\n// \t\tconst logPath = path.join(process.cwd(),`${type}-${process.pid}`);\n\n// \t\tconsole.log(`dumping socket diagnostics at ${logPath}`);\n// \t\tfs.writeFileSync(logPath, JSON.stringify(SocketDiagnostics.records));\n// \t}, 20000);\n// })();\n"],
  "mappings": "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",
  "names": ["SocketDiagnosticsEventType", "SocketDiagnostics", "SocketCloseEventType", "result", "ProtocolMessageType", "ProtocolConstants"]
}
