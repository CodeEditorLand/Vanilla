{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/parts/ipc/node/ipc.mp.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { VSBuffer } from \"../../../common/buffer.js\";\nimport { Emitter, Event } from \"../../../common/event.js\";\nimport { assertType } from \"../../../common/types.js\";\nimport {\n\ttype MessageEvent,\n\ttype MessagePortMain,\n\tisUtilityProcess,\n} from \"../../sandbox/node/electronTypes.js\";\nimport {\n\ttype ClientConnectionEvent,\n\ttype IMessagePassingProtocol,\n\tIPCServer,\n} from \"../common/ipc.js\";\n\n/**\n * The MessagePort `Protocol` leverages MessagePortMain style IPC communication\n * for the implementation of the `IMessagePassingProtocol`.\n */\nclass Protocol implements IMessagePassingProtocol {\n\treadonly onMessage = Event.fromNodeEventEmitter<VSBuffer>(\n\t\tthis.port,\n\t\t\"message\",\n\t\t(e: MessageEvent) => {\n\t\t\tif (e.data) {\n\t\t\t\treturn VSBuffer.wrap(e.data);\n\t\t\t}\n\t\t\treturn VSBuffer.alloc(0);\n\t\t},\n\t);\n\n\tconstructor(private port: MessagePortMain) {\n\t\t// we must call start() to ensure messages are flowing\n\t\tport.start();\n\t}\n\n\tsend(message: VSBuffer): void {\n\t\tthis.port.postMessage(message.buffer);\n\t}\n\n\tdisconnect(): void {\n\t\tthis.port.close();\n\t}\n}\n\nexport interface IClientConnectionFilter {\n\t/**\n\t * Allows to filter incoming messages to the\n\t * server to handle them differently.\n\t *\n\t * @param e the message event to handle\n\t * @returns `true` if the event was handled\n\t * and should not be processed by the server.\n\t */\n\thandledClientConnection(e: MessageEvent): boolean;\n}\n\n/**\n * An implementation of a `IPCServer` on top of MessagePort style IPC communication.\n * The clients register themselves via Electron Utility Process IPC transfer.\n */\nexport class Server extends IPCServer {\n\tprivate static getOnDidClientConnect(\n\t\tfilter?: IClientConnectionFilter,\n\t): Event<ClientConnectionEvent> {\n\t\tassertType(isUtilityProcess(process), \"Electron Utility Process\");\n\n\t\tconst onCreateMessageChannel = new Emitter<MessagePortMain>();\n\n\t\tprocess.parentPort.on(\"message\", (e: MessageEvent) => {\n\t\t\tif (filter?.handledClientConnection(e)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst port = e.ports.at(0);\n\t\t\tif (port) {\n\t\t\t\tonCreateMessageChannel.fire(port);\n\t\t\t}\n\t\t});\n\n\t\treturn Event.map(onCreateMessageChannel.event, (port) => {\n\t\t\tconst protocol = new Protocol(port);\n\n\t\t\tconst result: ClientConnectionEvent = {\n\t\t\t\tprotocol,\n\t\t\t\t// Not part of the standard spec, but in Electron we get a `close` event\n\t\t\t\t// when the other side closes. We can use this to detect disconnects\n\t\t\t\t// (https://github.com/electron/electron/blob/11-x-y/docs/api/message-port-main.md#event-close)\n\t\t\t\tonDidClientDisconnect: Event.fromNodeEventEmitter(\n\t\t\t\t\tport,\n\t\t\t\t\t\"close\",\n\t\t\t\t),\n\t\t\t};\n\n\t\t\treturn result;\n\t\t});\n\t}\n\n\tconstructor(filter?: IClientConnectionFilter) {\n\t\tsuper(Server.getOnDidClientConnect(filter));\n\t}\n}\n\ninterface INodeMessagePortFragment {\n\ton(event: \"message\", listener: (messageEvent: MessageEvent) => void): this;\n\tremoveListener(\n\t\tevent: \"message\",\n\t\tlistener: (messageEvent: MessageEvent) => void,\n\t): this;\n}\n\nexport function once(\n\tport: INodeMessagePortFragment,\n\tmessage: unknown,\n\tcallback: () => void,\n): void {\n\tconst listener = (e: MessageEvent) => {\n\t\tif (e.data === message) {\n\t\t\tport.removeListener(\"message\", listener);\n\t\t\tcallback();\n\t\t}\n\t};\n\n\tport.on(\"message\", listener);\n}\n"],
  "mappings": ";;AAKA,SAAS,gBAAgB;AACzB,SAAS,SAAS,aAAa;AAC/B,SAAS,kBAAkB;AAC3B;AAAA,EAGC;AAAA,OACM;AACP;AAAA,EAGC;AAAA,OACM;AAMP,MAAM,SAA4C;AAAA,EAYjD,YAAoB,MAAuB;AAAvB;AAEnB,SAAK,MAAM;AAAA,EACZ;AAAA,EAtCD,OAuBkD;AAAA;AAAA;AAAA,EACxC,YAAY,MAAM;AAAA,IAC1B,KAAK;AAAA,IACL;AAAA,IACA,CAAC,MAAoB;AACpB,UAAI,EAAE,MAAM;AACX,eAAO,SAAS,KAAK,EAAE,IAAI;AAAA,MAC5B;AACA,aAAO,SAAS,MAAM,CAAC;AAAA,IACxB;AAAA,EACD;AAAA,EAOA,KAAK,SAAyB;AAC7B,SAAK,KAAK,YAAY,QAAQ,MAAM;AAAA,EACrC;AAAA,EAEA,aAAmB;AAClB,SAAK,KAAK,MAAM;AAAA,EACjB;AACD;AAkBO,MAAM,eAAe,UAAU;AAAA,EAjEtC,OAiEsC;AAAA;AAAA;AAAA,EACrC,OAAe,sBACd,QAC+B;AAC/B,eAAW,iBAAiB,OAAO,GAAG,0BAA0B;AAEhE,UAAM,yBAAyB,IAAI,QAAyB;AAE5D,YAAQ,WAAW,GAAG,WAAW,CAAC,MAAoB;AACrD,UAAI,QAAQ,wBAAwB,CAAC,GAAG;AACvC;AAAA,MACD;AAEA,YAAM,OAAO,EAAE,MAAM,GAAG,CAAC;AACzB,UAAI,MAAM;AACT,+BAAuB,KAAK,IAAI;AAAA,MACjC;AAAA,IACD,CAAC;AAED,WAAO,MAAM,IAAI,uBAAuB,OAAO,CAAC,SAAS;AACxD,YAAM,WAAW,IAAI,SAAS,IAAI;AAElC,YAAM,SAAgC;AAAA,QACrC;AAAA;AAAA;AAAA;AAAA,QAIA,uBAAuB,MAAM;AAAA,UAC5B;AAAA,UACA;AAAA,QACD;AAAA,MACD;AAEA,aAAO;AAAA,IACR,CAAC;AAAA,EACF;AAAA,EAEA,YAAY,QAAkC;AAC7C,UAAM,OAAO,sBAAsB,MAAM,CAAC;AAAA,EAC3C;AACD;AAUO,SAAS,KACf,MACA,SACA,UACO;AACP,QAAM,WAAW,wBAAC,MAAoB;AACrC,QAAI,EAAE,SAAS,SAAS;AACvB,WAAK,eAAe,WAAW,QAAQ;AACvC,eAAS;AAAA,IACV;AAAA,EACD,GALiB;AAOjB,OAAK,GAAG,WAAW,QAAQ;AAC5B;AAbgB;",
  "names": []
}
