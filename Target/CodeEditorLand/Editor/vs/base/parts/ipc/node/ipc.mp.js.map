{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/parts/ipc/node/ipc.mp.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { MessagePortMain, isUtilityProcess, MessageEvent } from '../../sandbox/node/electronTypes.js';\nimport { VSBuffer } from '../../../common/buffer.js';\nimport { ClientConnectionEvent, IMessagePassingProtocol, IPCServer } from '../common/ipc.js';\nimport { Emitter, Event } from '../../../common/event.js';\nimport { assertType } from '../../../common/types.js';\n\n/**\n * The MessagePort `Protocol` leverages MessagePortMain style IPC communication\n * for the implementation of the `IMessagePassingProtocol`.\n */\nclass Protocol implements IMessagePassingProtocol {\n\n\treadonly onMessage = Event.fromNodeEventEmitter<VSBuffer>(this.port, 'message', (e: MessageEvent) => {\n\t\tif (e.data) {\n\t\t\treturn VSBuffer.wrap(e.data);\n\t\t}\n\t\treturn VSBuffer.alloc(0);\n\t});\n\n\tconstructor(private port: MessagePortMain) {\n\n\t\t// we must call start() to ensure messages are flowing\n\t\tport.start();\n\t}\n\n\tsend(message: VSBuffer): void {\n\t\tthis.port.postMessage(message.buffer);\n\t}\n\n\tdisconnect(): void {\n\t\tthis.port.close();\n\t}\n}\n\nexport interface IClientConnectionFilter {\n\n\t/**\n\t * Allows to filter incoming messages to the\n\t * server to handle them differently.\n\t *\n\t * @param e the message event to handle\n\t * @returns `true` if the event was handled\n\t * and should not be processed by the server.\n\t */\n\thandledClientConnection(e: MessageEvent): boolean;\n}\n\n/**\n * An implementation of a `IPCServer` on top of MessagePort style IPC communication.\n * The clients register themselves via Electron Utility Process IPC transfer.\n */\nexport class Server extends IPCServer {\n\n\tprivate static getOnDidClientConnect(filter?: IClientConnectionFilter): Event<ClientConnectionEvent> {\n\t\tassertType(isUtilityProcess(process), 'Electron Utility Process');\n\n\t\tconst onCreateMessageChannel = new Emitter<MessagePortMain>();\n\n\t\tprocess.parentPort.on('message', (e: MessageEvent) => {\n\t\t\tif (filter?.handledClientConnection(e)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst port = e.ports.at(0);\n\t\t\tif (port) {\n\t\t\t\tonCreateMessageChannel.fire(port);\n\t\t\t}\n\t\t});\n\n\t\treturn Event.map(onCreateMessageChannel.event, port => {\n\t\t\tconst protocol = new Protocol(port);\n\n\t\t\tconst result: ClientConnectionEvent = {\n\t\t\t\tprotocol,\n\t\t\t\t// Not part of the standard spec, but in Electron we get a `close` event\n\t\t\t\t// when the other side closes. We can use this to detect disconnects\n\t\t\t\t// (https://github.com/electron/electron/blob/11-x-y/docs/api/message-port-main.md#event-close)\n\t\t\t\tonDidClientDisconnect: Event.fromNodeEventEmitter(port, 'close')\n\t\t\t};\n\n\t\t\treturn result;\n\t\t});\n\t}\n\n\tconstructor(filter?: IClientConnectionFilter) {\n\t\tsuper(Server.getOnDidClientConnect(filter));\n\t}\n}\n\ninterface INodeMessagePortFragment {\n\ton(event: 'message', listener: (messageEvent: MessageEvent) => void): this;\n\tremoveListener(event: 'message', listener: (messageEvent: MessageEvent) => void): this;\n}\n\nexport function once(port: INodeMessagePortFragment, message: unknown, callback: () => void): void {\n\tconst listener = (e: MessageEvent) => {\n\t\tif (e.data === message) {\n\t\t\tport.removeListener('message', listener);\n\t\t\tcallback();\n\t\t}\n\t};\n\n\tport.on('message', listener);\n}\n"],
  "mappings": ";;AAKA,SAAS,iBAAiB,kBAAkB,oBAAoB;AAChE,SAAS,gBAAgB;AACzB,SAAS,uBAAuB,yBAAyB,iBAAiB;AAC1E,SAAS,SAAS,aAAa;AAC/B,SAAS,kBAAkB;AAM3B,MAAM,SAA4C;AAAA,EASjD,YAAoB,MAAuB;AAAvB;AAGnB,SAAK,MAAM;AAAA,EACZ;AAAA,EA5BD,OAekD;AAAA;AAAA;AAAA,EAExC,YAAY,MAAM,qBAA+B,KAAK,MAAM,WAAW,CAAC,MAAoB;AACpG,QAAI,EAAE,MAAM;AACX,aAAO,SAAS,KAAK,EAAE,IAAI;AAAA,IAC5B;AACA,WAAO,SAAS,MAAM,CAAC;AAAA,EACxB,CAAC;AAAA,EAQD,KAAK,SAAyB;AAC7B,SAAK,KAAK,YAAY,QAAQ,MAAM;AAAA,EACrC;AAAA,EAEA,aAAmB;AAClB,SAAK,KAAK,MAAM;AAAA,EACjB;AACD;AAmBO,MAAM,eAAe,UAAU;AAAA,EAxDtC,OAwDsC;AAAA;AAAA;AAAA,EAErC,OAAe,sBAAsB,QAAgE;AACpG,eAAW,iBAAiB,OAAO,GAAG,0BAA0B;AAEhE,UAAM,yBAAyB,IAAI,QAAyB;AAE5D,YAAQ,WAAW,GAAG,WAAW,CAAC,MAAoB;AACrD,UAAI,QAAQ,wBAAwB,CAAC,GAAG;AACvC;AAAA,MACD;AAEA,YAAM,OAAO,EAAE,MAAM,GAAG,CAAC;AACzB,UAAI,MAAM;AACT,+BAAuB,KAAK,IAAI;AAAA,MACjC;AAAA,IACD,CAAC;AAED,WAAO,MAAM,IAAI,uBAAuB,OAAO,UAAQ;AACtD,YAAM,WAAW,IAAI,SAAS,IAAI;AAElC,YAAM,SAAgC;AAAA,QACrC;AAAA;AAAA;AAAA;AAAA,QAIA,uBAAuB,MAAM,qBAAqB,MAAM,OAAO;AAAA,MAChE;AAEA,aAAO;AAAA,IACR,CAAC;AAAA,EACF;AAAA,EAEA,YAAY,QAAkC;AAC7C,UAAM,OAAO,sBAAsB,MAAM,CAAC;AAAA,EAC3C;AACD;AAOO,SAAS,KAAK,MAAgC,SAAkB,UAA4B;AAClG,QAAM,WAAW,wBAAC,MAAoB;AACrC,QAAI,EAAE,SAAS,SAAS;AACvB,WAAK,eAAe,WAAW,QAAQ;AACvC,eAAS;AAAA,IACV;AAAA,EACD,GALiB;AAOjB,OAAK,GAAG,WAAW,QAAQ;AAC5B;AATgB;",
  "names": []
}
