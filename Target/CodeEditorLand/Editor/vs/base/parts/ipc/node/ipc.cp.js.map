{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/parts/ipc/node/ipc.cp.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { type ChildProcess, type ForkOptions, fork } from \"child_process\";\nimport { Delayer, createCancelablePromise } from \"../../../common/async.js\";\nimport { VSBuffer } from \"../../../common/buffer.js\";\nimport { CancellationToken } from \"../../../common/cancellation.js\";\nimport { isRemoteConsoleLog, log } from \"../../../common/console.js\";\nimport * as errors from \"../../../common/errors.js\";\nimport { Emitter, Event } from \"../../../common/event.js\";\nimport {\n\ttype IDisposable,\n\tdispose,\n\ttoDisposable,\n} from \"../../../common/lifecycle.js\";\nimport { deepClone } from \"../../../common/objects.js\";\nimport { removeDangerousEnvVariables } from \"../../../common/processes.js\";\nimport { createQueuedSender } from \"../../../node/processes.js\";\nimport {\n\ttype IChannel,\n\ttype IChannelClient,\n\tChannelClient as IPCClient,\n\tChannelServer as IPCServer,\n} from \"../common/ipc.js\";\n\n/**\n * This implementation doesn't perform well since it uses base64 encoding for buffers.\n * We should move all implementations to use named ipc.net, so we stop depending on cp.fork.\n */\n\nexport class Server<TContext extends string> extends IPCServer<TContext> {\n\tconstructor(ctx: TContext) {\n\t\tsuper(\n\t\t\t{\n\t\t\t\tsend: (r) => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tprocess.send?.((<Buffer>r.buffer).toString(\"base64\"));\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t/* not much to do */\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tonMessage: Event.fromNodeEventEmitter(\n\t\t\t\t\tprocess,\n\t\t\t\t\t\"message\",\n\t\t\t\t\t(msg) => VSBuffer.wrap(Buffer.from(msg, \"base64\")),\n\t\t\t\t),\n\t\t\t},\n\t\t\tctx,\n\t\t);\n\n\t\tprocess.once(\"disconnect\", () => this.dispose());\n\t}\n}\n\nexport interface IIPCOptions {\n\t/**\n\t * A descriptive name for the server this connection is to. Used in logging.\n\t */\n\tserverName: string;\n\n\t/**\n\t * Time in millies before killing the ipc process. The next request after killing will start it again.\n\t */\n\ttimeout?: number;\n\n\t/**\n\t * Arguments to the module to execute.\n\t */\n\targs?: string[];\n\n\t/**\n\t * Environment key-value pairs to be passed to the process that gets spawned for the ipc.\n\t */\n\tenv?: any;\n\n\t/**\n\t * Allows to assign a debug port for debugging the application executed.\n\t */\n\tdebug?: number;\n\n\t/**\n\t * Allows to assign a debug port for debugging the application and breaking it on the first line.\n\t */\n\tdebugBrk?: number;\n\n\t/**\n\t * If set, starts the fork with empty execArgv. If not set, execArgv from the parent process are inherited,\n\t * except --inspect= and --inspect-brk= which are filtered as they would result in a port conflict.\n\t */\n\tfreshExecArgv?: boolean;\n\n\t/**\n\t * Enables our createQueuedSender helper for this Client. Uses a queue when the internal Node.js queue is\n\t * full of messages - see notes on that method.\n\t */\n\tuseQueue?: boolean;\n}\n\nexport class Client implements IChannelClient, IDisposable {\n\tprivate disposeDelayer: Delayer<void> | undefined;\n\tprivate activeRequests = new Set<IDisposable>();\n\tprivate child: ChildProcess | null;\n\tprivate _client: IPCClient | null;\n\tprivate channels = new Map<string, IChannel>();\n\n\tprivate readonly _onDidProcessExit = new Emitter<{\n\t\tcode: number;\n\t\tsignal: string;\n\t}>();\n\treadonly onDidProcessExit = this._onDidProcessExit.event;\n\n\tconstructor(\n\t\tprivate modulePath: string,\n\t\tprivate options: IIPCOptions,\n\t) {\n\t\tconst timeout = options && options.timeout ? options.timeout : 60000;\n\t\tthis.disposeDelayer = new Delayer<void>(timeout);\n\t\tthis.child = null;\n\t\tthis._client = null;\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string): T {\n\t\tconst that = this;\n\n\t\treturn {\n\t\t\tcall<T>(\n\t\t\t\tcommand: string,\n\t\t\t\targ?: any,\n\t\t\t\tcancellationToken?: CancellationToken,\n\t\t\t): Promise<T> {\n\t\t\t\treturn that.requestPromise<T>(\n\t\t\t\t\tchannelName,\n\t\t\t\t\tcommand,\n\t\t\t\t\targ,\n\t\t\t\t\tcancellationToken,\n\t\t\t\t);\n\t\t\t},\n\t\t\tlisten(event: string, arg?: any) {\n\t\t\t\treturn that.requestEvent(channelName, event, arg);\n\t\t\t},\n\t\t} as T;\n\t}\n\n\tprotected requestPromise<T>(\n\t\tchannelName: string,\n\t\tname: string,\n\t\targ?: any,\n\t\tcancellationToken = CancellationToken.None,\n\t): Promise<T> {\n\t\tif (!this.disposeDelayer) {\n\t\t\treturn Promise.reject(new Error(\"disposed\"));\n\t\t}\n\n\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\treturn Promise.reject(errors.canceled());\n\t\t}\n\n\t\tthis.disposeDelayer.cancel();\n\n\t\tconst channel = this.getCachedChannel(channelName);\n\t\tconst result = createCancelablePromise((token) =>\n\t\t\tchannel.call<T>(name, arg, token),\n\t\t);\n\t\tconst cancellationTokenListener =\n\t\t\tcancellationToken.onCancellationRequested(() => result.cancel());\n\n\t\tconst disposable = toDisposable(() => result.cancel());\n\t\tthis.activeRequests.add(disposable);\n\n\t\tresult.finally(() => {\n\t\t\tcancellationTokenListener.dispose();\n\t\t\tthis.activeRequests.delete(disposable);\n\n\t\t\tif (this.activeRequests.size === 0 && this.disposeDelayer) {\n\t\t\t\tthis.disposeDelayer.trigger(() => this.disposeClient());\n\t\t\t}\n\t\t});\n\n\t\treturn result;\n\t}\n\n\tprotected requestEvent<T>(\n\t\tchannelName: string,\n\t\tname: string,\n\t\targ?: any,\n\t): Event<T> {\n\t\tif (!this.disposeDelayer) {\n\t\t\treturn Event.None;\n\t\t}\n\n\t\tthis.disposeDelayer.cancel();\n\n\t\tlet listener: IDisposable;\n\t\tconst emitter = new Emitter<any>({\n\t\t\tonWillAddFirstListener: () => {\n\t\t\t\tconst channel = this.getCachedChannel(channelName);\n\t\t\t\tconst event: Event<T> = channel.listen(name, arg);\n\n\t\t\t\tlistener = event(emitter.fire, emitter);\n\t\t\t\tthis.activeRequests.add(listener);\n\t\t\t},\n\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\tthis.activeRequests.delete(listener);\n\t\t\t\tlistener.dispose();\n\n\t\t\t\tif (this.activeRequests.size === 0 && this.disposeDelayer) {\n\t\t\t\t\tthis.disposeDelayer.trigger(() => this.disposeClient());\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\tprivate get client(): IPCClient {\n\t\tif (!this._client) {\n\t\t\tconst args =\n\t\t\t\tthis.options && this.options.args ? this.options.args : [];\n\t\t\tconst forkOpts: ForkOptions = Object.create(null);\n\n\t\t\tforkOpts.env = {\n\t\t\t\t...deepClone(process.env),\n\t\t\t\tVSCODE_PARENT_PID: String(process.pid),\n\t\t\t};\n\n\t\t\tif (this.options && this.options.env) {\n\t\t\t\tforkOpts.env = { ...forkOpts.env, ...this.options.env };\n\t\t\t}\n\n\t\t\tif (this.options && this.options.freshExecArgv) {\n\t\t\t\tforkOpts.execArgv = [];\n\t\t\t}\n\n\t\t\tif (this.options && typeof this.options.debug === \"number\") {\n\t\t\t\tforkOpts.execArgv = [\n\t\t\t\t\t\"--nolazy\",\n\t\t\t\t\t\"--inspect=\" + this.options.debug,\n\t\t\t\t];\n\t\t\t}\n\n\t\t\tif (this.options && typeof this.options.debugBrk === \"number\") {\n\t\t\t\tforkOpts.execArgv = [\n\t\t\t\t\t\"--nolazy\",\n\t\t\t\t\t\"--inspect-brk=\" + this.options.debugBrk,\n\t\t\t\t];\n\t\t\t}\n\n\t\t\tif (forkOpts.execArgv === undefined) {\n\t\t\t\tforkOpts.execArgv = process.execArgv // if not set, the forked process inherits the execArgv of the parent process\n\t\t\t\t\t.filter((a) => !/^--inspect(-brk)?=/.test(a)) // --inspect and --inspect-brk can not be inherited as the port would conflict\n\t\t\t\t\t.filter((a) => !a.startsWith(\"--vscode-\")); // --vscode-* arguments are unsupported by node.js and thus need to remove\n\t\t\t}\n\n\t\t\tremoveDangerousEnvVariables(forkOpts.env);\n\n\t\t\tthis.child = fork(this.modulePath, args, forkOpts);\n\n\t\t\tconst onMessageEmitter = new Emitter<VSBuffer>();\n\t\t\tconst onRawMessage = Event.fromNodeEventEmitter(\n\t\t\t\tthis.child,\n\t\t\t\t\"message\",\n\t\t\t\t(msg) => msg,\n\t\t\t);\n\n\t\t\tconst rawMessageDisposable = onRawMessage((msg) => {\n\t\t\t\t// Handle remote console logs specially\n\t\t\t\tif (isRemoteConsoleLog(msg)) {\n\t\t\t\t\tlog(msg, `IPC Library: ${this.options.serverName}`);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Anything else goes to the outside\n\t\t\t\tonMessageEmitter.fire(\n\t\t\t\t\tVSBuffer.wrap(Buffer.from(msg, \"base64\")),\n\t\t\t\t);\n\t\t\t});\n\n\t\t\tconst sender = this.options.useQueue\n\t\t\t\t? createQueuedSender(this.child)\n\t\t\t\t: this.child;\n\t\t\tconst send = (r: VSBuffer) =>\n\t\t\t\tthis.child &&\n\t\t\t\tthis.child.connected &&\n\t\t\t\tsender.send((<Buffer>r.buffer).toString(\"base64\"));\n\t\t\tconst onMessage = onMessageEmitter.event;\n\t\t\tconst protocol = { send, onMessage };\n\n\t\t\tthis._client = new IPCClient(protocol);\n\n\t\t\tconst onExit = () => this.disposeClient();\n\t\t\tprocess.once(\"exit\", onExit);\n\n\t\t\tthis.child.on(\"error\", (err) =>\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'IPC \"' + this.options.serverName + '\" errored with ' + err,\n\t\t\t\t),\n\t\t\t);\n\n\t\t\tthis.child.on(\"exit\", (code: any, signal: any) => {\n\t\t\t\tprocess.removeListener(\"exit\" as \"loaded\", onExit); // https://github.com/electron/electron/issues/21475\n\t\t\t\trawMessageDisposable.dispose();\n\n\t\t\t\tthis.activeRequests.forEach((r) => dispose(r));\n\t\t\t\tthis.activeRequests.clear();\n\n\t\t\t\tif (code !== 0 && signal !== \"SIGTERM\") {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t'IPC \"' +\n\t\t\t\t\t\t\tthis.options.serverName +\n\t\t\t\t\t\t\t'\" crashed with exit code ' +\n\t\t\t\t\t\t\tcode +\n\t\t\t\t\t\t\t\" and signal \" +\n\t\t\t\t\t\t\tsignal,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tthis.disposeDelayer?.cancel();\n\t\t\t\tthis.disposeClient();\n\t\t\t\tthis._onDidProcessExit.fire({ code, signal });\n\t\t\t});\n\t\t}\n\n\t\treturn this._client;\n\t}\n\n\tprivate getCachedChannel(name: string): IChannel {\n\t\tlet channel = this.channels.get(name);\n\n\t\tif (!channel) {\n\t\t\tchannel = this.client.getChannel(name);\n\t\t\tthis.channels.set(name, channel);\n\t\t}\n\n\t\treturn channel;\n\t}\n\n\tprivate disposeClient() {\n\t\tif (this._client) {\n\t\t\tif (this.child) {\n\t\t\t\tthis.child.kill();\n\t\t\t\tthis.child = null;\n\t\t\t}\n\t\t\tthis._client = null;\n\t\t\tthis.channels.clear();\n\t\t}\n\t}\n\n\tdispose() {\n\t\tthis._onDidProcessExit.dispose();\n\t\tthis.disposeDelayer?.cancel();\n\t\tthis.disposeDelayer = undefined;\n\t\tthis.disposeClient();\n\t\tthis.activeRequests.clear();\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
