{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/parts/ipc/node/ipc.net.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createHash } from 'crypto';\nimport { Server as NetServer, Socket, createServer, createConnection } from 'net';\nimport { tmpdir } from 'os';\nimport { createDeflateRaw, ZlibOptions, InflateRaw, DeflateRaw, createInflateRaw } from 'zlib';\nimport { VSBuffer } from '../../../common/buffer.js';\nimport { onUnexpectedError } from '../../../common/errors.js';\nimport { Emitter, Event } from '../../../common/event.js';\nimport { Disposable, IDisposable } from '../../../common/lifecycle.js';\nimport { join } from '../../../common/path.js';\nimport { Platform, platform } from '../../../common/platform.js';\nimport { generateUuid } from '../../../common/uuid.js';\nimport { ClientConnectionEvent, IPCServer } from '../common/ipc.js';\nimport { ChunkStream, Client, ISocket, Protocol, SocketCloseEvent, SocketCloseEventType, SocketDiagnostics, SocketDiagnosticsEventType } from '../common/ipc.net.js';\n\n/**\n * Maximum time to wait for a 'close' event to fire after the socket stream\n * ends. For unix domain sockets, the close event may not fire consistently\n * due to what appears to be a Node.js bug.\n *\n * @see https://github.com/microsoft/vscode/issues/211462#issuecomment-2155471996\n */\nconst socketEndTimeoutMs = 30_000;\n\nexport class NodeSocket implements ISocket {\n\n\tpublic readonly debugLabel: string;\n\tpublic readonly socket: Socket;\n\tprivate readonly _errorListener: (err: any) => void;\n\tprivate readonly _closeListener: (hadError: boolean) => void;\n\tprivate readonly _endListener: () => void;\n\tprivate _canWrite = true;\n\n\tpublic traceSocketEvent(type: SocketDiagnosticsEventType, data?: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView | any): void {\n\t\tSocketDiagnostics.traceSocketEvent(this.socket, this.debugLabel, type, data);\n\t}\n\n\tconstructor(socket: Socket, debugLabel: string = '') {\n\t\tthis.debugLabel = debugLabel;\n\t\tthis.socket = socket;\n\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.Created, { type: 'NodeSocket' });\n\t\tthis._errorListener = (err: any) => {\n\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.Error, { code: err?.code, message: err?.message });\n\t\t\tif (err) {\n\t\t\t\tif (err.code === 'EPIPE') {\n\t\t\t\t\t// An EPIPE exception at the wrong time can lead to a renderer process crash\n\t\t\t\t\t// so ignore the error since the socket will fire the close event soon anyways:\n\t\t\t\t\t// > https://nodejs.org/api/errors.html#errors_common_system_errors\n\t\t\t\t\t// > EPIPE (Broken pipe): A write on a pipe, socket, or FIFO for which there is no\n\t\t\t\t\t// > process to read the data. Commonly encountered at the net and http layers,\n\t\t\t\t\t// > indicative that the remote side of the stream being written to has been closed.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tonUnexpectedError(err);\n\t\t\t}\n\t\t};\n\t\tthis.socket.on('error', this._errorListener);\n\n\t\tlet endTimeoutHandle: NodeJS.Timeout | undefined;\n\t\tthis._closeListener = (hadError: boolean) => {\n\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.Close, { hadError });\n\t\t\tthis._canWrite = false;\n\t\t\tif (endTimeoutHandle) {\n\t\t\t\tclearTimeout(endTimeoutHandle);\n\t\t\t}\n\t\t};\n\t\tthis.socket.on('close', this._closeListener);\n\n\t\tthis._endListener = () => {\n\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.NodeEndReceived);\n\t\t\tthis._canWrite = false;\n\t\t\tendTimeoutHandle = setTimeout(() => socket.destroy(), socketEndTimeoutMs);\n\t\t};\n\t\tthis.socket.on('end', this._endListener);\n\t}\n\n\tpublic dispose(): void {\n\t\tthis.socket.off('error', this._errorListener);\n\t\tthis.socket.off('close', this._closeListener);\n\t\tthis.socket.off('end', this._endListener);\n\t\tthis.socket.destroy();\n\t}\n\n\tpublic onData(_listener: (e: VSBuffer) => void): IDisposable {\n\t\tconst listener = (buff: Buffer) => {\n\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.Read, buff);\n\t\t\t_listener(VSBuffer.wrap(buff));\n\t\t};\n\t\tthis.socket.on('data', listener);\n\t\treturn {\n\t\t\tdispose: () => this.socket.off('data', listener)\n\t\t};\n\t}\n\n\tpublic onClose(listener: (e: SocketCloseEvent) => void): IDisposable {\n\t\tconst adapter = (hadError: boolean) => {\n\t\t\tlistener({\n\t\t\t\ttype: SocketCloseEventType.NodeSocketCloseEvent,\n\t\t\t\thadError: hadError,\n\t\t\t\terror: undefined\n\t\t\t});\n\t\t};\n\t\tthis.socket.on('close', adapter);\n\t\treturn {\n\t\t\tdispose: () => this.socket.off('close', adapter)\n\t\t};\n\t}\n\n\tpublic onEnd(listener: () => void): IDisposable {\n\t\tconst adapter = () => {\n\t\t\tlistener();\n\t\t};\n\t\tthis.socket.on('end', adapter);\n\t\treturn {\n\t\t\tdispose: () => this.socket.off('end', adapter)\n\t\t};\n\t}\n\n\tpublic write(buffer: VSBuffer): void {\n\t\t// return early if socket has been destroyed in the meantime\n\t\tif (this.socket.destroyed || !this._canWrite) {\n\t\t\treturn;\n\t\t}\n\n\t\t// we ignore the returned value from `write` because we would have to cached the data\n\t\t// anyways and nodejs is already doing that for us:\n\t\t// > https://nodejs.org/api/stream.html#stream_writable_write_chunk_encoding_callback\n\t\t// > However, the false return value is only advisory and the writable stream will unconditionally\n\t\t// > accept and buffer chunk even if it has not been allowed to drain.\n\t\ttry {\n\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.Write, buffer);\n\t\t\tthis.socket.write(buffer.buffer, (err: any) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tif (err.code === 'EPIPE') {\n\t\t\t\t\t\t// An EPIPE exception at the wrong time can lead to a renderer process crash\n\t\t\t\t\t\t// so ignore the error since the socket will fire the close event soon anyways:\n\t\t\t\t\t\t// > https://nodejs.org/api/errors.html#errors_common_system_errors\n\t\t\t\t\t\t// > EPIPE (Broken pipe): A write on a pipe, socket, or FIFO for which there is no\n\t\t\t\t\t\t// > process to read the data. Commonly encountered at the net and http layers,\n\t\t\t\t\t\t// > indicative that the remote side of the stream being written to has been closed.\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tonUnexpectedError(err);\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (err) {\n\t\t\tif (err.code === 'EPIPE') {\n\t\t\t\t// An EPIPE exception at the wrong time can lead to a renderer process crash\n\t\t\t\t// so ignore the error since the socket will fire the close event soon anyways:\n\t\t\t\t// > https://nodejs.org/api/errors.html#errors_common_system_errors\n\t\t\t\t// > EPIPE (Broken pipe): A write on a pipe, socket, or FIFO for which there is no\n\t\t\t\t// > process to read the data. Commonly encountered at the net and http layers,\n\t\t\t\t// > indicative that the remote side of the stream being written to has been closed.\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tonUnexpectedError(err);\n\t\t}\n\t}\n\n\tpublic end(): void {\n\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.NodeEndSent);\n\t\tthis.socket.end();\n\t}\n\n\tpublic drain(): Promise<void> {\n\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.NodeDrainBegin);\n\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\tif (this.socket.bufferSize === 0) {\n\t\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.NodeDrainEnd);\n\t\t\t\tresolve();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst finished = () => {\n\t\t\t\tthis.socket.off('close', finished);\n\t\t\t\tthis.socket.off('end', finished);\n\t\t\t\tthis.socket.off('error', finished);\n\t\t\t\tthis.socket.off('timeout', finished);\n\t\t\t\tthis.socket.off('drain', finished);\n\t\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.NodeDrainEnd);\n\t\t\t\tresolve();\n\t\t\t};\n\t\t\tthis.socket.on('close', finished);\n\t\t\tthis.socket.on('end', finished);\n\t\t\tthis.socket.on('error', finished);\n\t\t\tthis.socket.on('timeout', finished);\n\t\t\tthis.socket.on('drain', finished);\n\t\t});\n\t}\n}\n\nconst enum Constants {\n\tMinHeaderByteSize = 2,\n\t/**\n\t * If we need to write a large buffer, we will split it into 256KB chunks and\n\t * send each chunk as a websocket message. This is to prevent that the sending\n\t * side is stuck waiting for the entire buffer to be compressed before writing\n\t * to the underlying socket or that the receiving side is stuck waiting for the\n\t * entire message to be received before processing the bytes.\n\t */\n\tMaxWebSocketMessageLength = 256 * 1024 // 256 KB\n}\n\nconst enum ReadState {\n\tPeekHeader = 1,\n\tReadHeader = 2,\n\tReadBody = 3,\n\tFin = 4\n}\n\ninterface ISocketTracer {\n\ttraceSocketEvent(type: SocketDiagnosticsEventType, data?: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView | any): void;\n}\n\ninterface FrameOptions {\n\tcompressed: boolean;\n\topcode: number;\n}\n\n/**\n * See https://tools.ietf.org/html/rfc6455#section-5.2\n */\nexport class WebSocketNodeSocket extends Disposable implements ISocket, ISocketTracer {\n\n\tpublic readonly socket: NodeSocket;\n\tprivate readonly _flowManager: WebSocketFlowManager;\n\tprivate readonly _incomingData: ChunkStream;\n\tprivate readonly _onData = this._register(new Emitter<VSBuffer>());\n\tprivate readonly _onClose = this._register(new Emitter<SocketCloseEvent>());\n\tprivate _isEnded: boolean = false;\n\n\tprivate readonly _state = {\n\t\tstate: ReadState.PeekHeader,\n\t\treadLen: Constants.MinHeaderByteSize,\n\t\tfin: 0,\n\t\tcompressed: false,\n\t\tfirstFrameOfMessage: true,\n\t\tmask: 0,\n\t\topcode: 0\n\t};\n\n\tpublic get permessageDeflate(): boolean {\n\t\treturn this._flowManager.permessageDeflate;\n\t}\n\n\tpublic get recordedInflateBytes(): VSBuffer {\n\t\treturn this._flowManager.recordedInflateBytes;\n\t}\n\n\tpublic traceSocketEvent(type: SocketDiagnosticsEventType, data?: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView | any): void {\n\t\tthis.socket.traceSocketEvent(type, data);\n\t}\n\n\t/**\n\t * Create a socket which can communicate using WebSocket frames.\n\t *\n\t * **NOTE**: When using the permessage-deflate WebSocket extension, if parts of inflating was done\n\t *  in a different zlib instance, we need to pass all those bytes into zlib, otherwise the inflate\n\t *  might hit an inflated portion referencing a distance too far back.\n\t *\n\t * @param socket The underlying socket\n\t * @param permessageDeflate Use the permessage-deflate WebSocket extension\n\t * @param inflateBytes \"Seed\" zlib inflate with these bytes.\n\t * @param recordInflateBytes Record all bytes sent to inflate\n\t */\n\tconstructor(socket: NodeSocket, permessageDeflate: boolean, inflateBytes: VSBuffer | null, recordInflateBytes: boolean) {\n\t\tsuper();\n\t\tthis.socket = socket;\n\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.Created, { type: 'WebSocketNodeSocket', permessageDeflate, inflateBytesLength: inflateBytes?.byteLength || 0, recordInflateBytes });\n\t\tthis._flowManager = this._register(new WebSocketFlowManager(\n\t\t\tthis,\n\t\t\tpermessageDeflate,\n\t\t\tinflateBytes,\n\t\t\trecordInflateBytes,\n\t\t\tthis._onData,\n\t\t\t(data, options) => this._write(data, options)\n\t\t));\n\t\tthis._register(this._flowManager.onError((err) => {\n\t\t\t// zlib errors are fatal, since we have no idea how to recover\n\t\t\tconsole.error(err);\n\t\t\tonUnexpectedError(err);\n\t\t\tthis._onClose.fire({\n\t\t\t\ttype: SocketCloseEventType.NodeSocketCloseEvent,\n\t\t\t\thadError: true,\n\t\t\t\terror: err\n\t\t\t});\n\t\t}));\n\t\tthis._incomingData = new ChunkStream();\n\t\tthis._register(this.socket.onData(data => this._acceptChunk(data)));\n\t\tthis._register(this.socket.onClose(async (e) => {\n\t\t\t// Delay surfacing the close event until the async inflating is done\n\t\t\t// and all data has been emitted\n\t\t\tif (this._flowManager.isProcessingReadQueue()) {\n\t\t\t\tawait Event.toPromise(this._flowManager.onDidFinishProcessingReadQueue);\n\t\t\t}\n\t\t\tthis._onClose.fire(e);\n\t\t}));\n\t}\n\n\tpublic override dispose(): void {\n\t\tif (this._flowManager.isProcessingWriteQueue()) {\n\t\t\t// Wait for any outstanding writes to finish before disposing\n\t\t\tthis._register(this._flowManager.onDidFinishProcessingWriteQueue(() => {\n\t\t\t\tthis.dispose();\n\t\t\t}));\n\t\t} else {\n\t\t\tthis.socket.dispose();\n\t\t\tsuper.dispose();\n\t\t}\n\t}\n\n\tpublic onData(listener: (e: VSBuffer) => void): IDisposable {\n\t\treturn this._onData.event(listener);\n\t}\n\n\tpublic onClose(listener: (e: SocketCloseEvent) => void): IDisposable {\n\t\treturn this._onClose.event(listener);\n\t}\n\n\tpublic onEnd(listener: () => void): IDisposable {\n\t\treturn this.socket.onEnd(listener);\n\t}\n\n\tpublic write(buffer: VSBuffer): void {\n\t\t// If we write many logical messages (let's say 1000 messages of 100KB) during a single process tick, we do\n\t\t// this thing where we install a process.nextTick timer and group all of them together and we then issue a\n\t\t// single WebSocketNodeSocket.write with a 100MB buffer.\n\t\t//\n\t\t// The first problem is that the actual writing to the underlying node socket will only happen after all of\n\t\t// the 100MB have been deflated (due to waiting on zlib flush). The second problem is on the reading side,\n\t\t// where we will get a single WebSocketNodeSocket.onData event fired when all the 100MB have arrived,\n\t\t// delaying processing the 1000 received messages until all have arrived, instead of processing them as each\n\t\t// one arrives.\n\t\t//\n\t\t// We therefore split the buffer into chunks, and issue a write for each chunk.\n\n\t\tlet start = 0;\n\t\twhile (start < buffer.byteLength) {\n\t\t\tthis._flowManager.writeMessage(buffer.slice(start, Math.min(start + Constants.MaxWebSocketMessageLength, buffer.byteLength)), { compressed: true, opcode: 0x02 /* Binary frame */ });\n\t\t\tstart += Constants.MaxWebSocketMessageLength;\n\t\t}\n\t}\n\n\tprivate _write(buffer: VSBuffer, { compressed, opcode }: FrameOptions): void {\n\t\tif (this._isEnded) {\n\t\t\t// Avoid ERR_STREAM_WRITE_AFTER_END\n\t\t\treturn;\n\t\t}\n\n\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.WebSocketNodeSocketWrite, buffer);\n\t\tlet headerLen = Constants.MinHeaderByteSize;\n\t\tif (buffer.byteLength < 126) {\n\t\t\theaderLen += 0;\n\t\t} else if (buffer.byteLength < 2 ** 16) {\n\t\t\theaderLen += 2;\n\t\t} else {\n\t\t\theaderLen += 8;\n\t\t}\n\t\tconst header = VSBuffer.alloc(headerLen);\n\n\t\t// The RSV1 bit indicates a compressed frame\n\t\tconst compressedFlag = compressed ? 0b01000000 : 0;\n\t\tconst opcodeFlag = opcode & 0b00001111;\n\t\theader.writeUInt8(0b10000000 | compressedFlag | opcodeFlag, 0);\n\t\tif (buffer.byteLength < 126) {\n\t\t\theader.writeUInt8(buffer.byteLength, 1);\n\t\t} else if (buffer.byteLength < 2 ** 16) {\n\t\t\theader.writeUInt8(126, 1);\n\t\t\tlet offset = 1;\n\t\t\theader.writeUInt8((buffer.byteLength >>> 8) & 0b11111111, ++offset);\n\t\t\theader.writeUInt8((buffer.byteLength >>> 0) & 0b11111111, ++offset);\n\t\t} else {\n\t\t\theader.writeUInt8(127, 1);\n\t\t\tlet offset = 1;\n\t\t\theader.writeUInt8(0, ++offset);\n\t\t\theader.writeUInt8(0, ++offset);\n\t\t\theader.writeUInt8(0, ++offset);\n\t\t\theader.writeUInt8(0, ++offset);\n\t\t\theader.writeUInt8((buffer.byteLength >>> 24) & 0b11111111, ++offset);\n\t\t\theader.writeUInt8((buffer.byteLength >>> 16) & 0b11111111, ++offset);\n\t\t\theader.writeUInt8((buffer.byteLength >>> 8) & 0b11111111, ++offset);\n\t\t\theader.writeUInt8((buffer.byteLength >>> 0) & 0b11111111, ++offset);\n\t\t}\n\n\t\tthis.socket.write(VSBuffer.concat([header, buffer]));\n\t}\n\n\tpublic end(): void {\n\t\tthis._isEnded = true;\n\t\tthis.socket.end();\n\t}\n\n\tprivate _acceptChunk(data: VSBuffer): void {\n\t\tif (data.byteLength === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._incomingData.acceptChunk(data);\n\n\t\twhile (this._incomingData.byteLength >= this._state.readLen) {\n\n\t\t\tif (this._state.state === ReadState.PeekHeader) {\n\t\t\t\t// peek to see if we can read the entire header\n\t\t\t\tconst peekHeader = this._incomingData.peek(this._state.readLen);\n\t\t\t\tconst firstByte = peekHeader.readUInt8(0);\n\t\t\t\tconst finBit = (firstByte & 0b10000000) >>> 7;\n\t\t\t\tconst rsv1Bit = (firstByte & 0b01000000) >>> 6;\n\t\t\t\tconst opcode = (firstByte & 0b00001111);\n\n\t\t\t\tconst secondByte = peekHeader.readUInt8(1);\n\t\t\t\tconst hasMask = (secondByte & 0b10000000) >>> 7;\n\t\t\t\tconst len = (secondByte & 0b01111111);\n\n\t\t\t\tthis._state.state = ReadState.ReadHeader;\n\t\t\t\tthis._state.readLen = Constants.MinHeaderByteSize + (hasMask ? 4 : 0) + (len === 126 ? 2 : 0) + (len === 127 ? 8 : 0);\n\t\t\t\tthis._state.fin = finBit;\n\t\t\t\tif (this._state.firstFrameOfMessage) {\n\t\t\t\t\t// if the frame is compressed, the RSV1 bit is set only for the first frame of the message\n\t\t\t\t\tthis._state.compressed = Boolean(rsv1Bit);\n\t\t\t\t}\n\t\t\t\tthis._state.firstFrameOfMessage = Boolean(finBit);\n\t\t\t\tthis._state.mask = 0;\n\t\t\t\tthis._state.opcode = opcode;\n\n\t\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.WebSocketNodeSocketPeekedHeader, { headerSize: this._state.readLen, compressed: this._state.compressed, fin: this._state.fin, opcode: this._state.opcode });\n\n\t\t\t} else if (this._state.state === ReadState.ReadHeader) {\n\t\t\t\t// read entire header\n\t\t\t\tconst header = this._incomingData.read(this._state.readLen);\n\t\t\t\tconst secondByte = header.readUInt8(1);\n\t\t\t\tconst hasMask = (secondByte & 0b10000000) >>> 7;\n\t\t\t\tlet len = (secondByte & 0b01111111);\n\n\t\t\t\tlet offset = 1;\n\t\t\t\tif (len === 126) {\n\t\t\t\t\tlen = (\n\t\t\t\t\t\theader.readUInt8(++offset) * 2 ** 8\n\t\t\t\t\t\t+ header.readUInt8(++offset)\n\t\t\t\t\t);\n\t\t\t\t} else if (len === 127) {\n\t\t\t\t\tlen = (\n\t\t\t\t\t\theader.readUInt8(++offset) * 0\n\t\t\t\t\t\t+ header.readUInt8(++offset) * 0\n\t\t\t\t\t\t+ header.readUInt8(++offset) * 0\n\t\t\t\t\t\t+ header.readUInt8(++offset) * 0\n\t\t\t\t\t\t+ header.readUInt8(++offset) * 2 ** 24\n\t\t\t\t\t\t+ header.readUInt8(++offset) * 2 ** 16\n\t\t\t\t\t\t+ header.readUInt8(++offset) * 2 ** 8\n\t\t\t\t\t\t+ header.readUInt8(++offset)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tlet mask = 0;\n\t\t\t\tif (hasMask) {\n\t\t\t\t\tmask = (\n\t\t\t\t\t\theader.readUInt8(++offset) * 2 ** 24\n\t\t\t\t\t\t+ header.readUInt8(++offset) * 2 ** 16\n\t\t\t\t\t\t+ header.readUInt8(++offset) * 2 ** 8\n\t\t\t\t\t\t+ header.readUInt8(++offset)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tthis._state.state = ReadState.ReadBody;\n\t\t\t\tthis._state.readLen = len;\n\t\t\t\tthis._state.mask = mask;\n\n\t\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.WebSocketNodeSocketPeekedHeader, { bodySize: this._state.readLen, compressed: this._state.compressed, fin: this._state.fin, mask: this._state.mask, opcode: this._state.opcode });\n\n\t\t\t} else if (this._state.state === ReadState.ReadBody) {\n\t\t\t\t// read body\n\n\t\t\t\tconst body = this._incomingData.read(this._state.readLen);\n\t\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.WebSocketNodeSocketReadData, body);\n\n\t\t\t\tunmask(body, this._state.mask);\n\t\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.WebSocketNodeSocketUnmaskedData, body);\n\n\t\t\t\tthis._state.state = ReadState.PeekHeader;\n\t\t\t\tthis._state.readLen = Constants.MinHeaderByteSize;\n\t\t\t\tthis._state.mask = 0;\n\n\t\t\t\tif (this._state.opcode <= 0x02 /* Continuation frame or Text frame or binary frame */) {\n\t\t\t\t\tthis._flowManager.acceptFrame(body, this._state.compressed, !!this._state.fin);\n\t\t\t\t} else if (this._state.opcode === 0x09 /* Ping frame */) {\n\t\t\t\t\t// Ping frames could be send by some browsers e.g. Firefox\n\t\t\t\t\tthis._flowManager.writeMessage(body, { compressed: false, opcode: 0x0A /* Pong frame */ });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic async drain(): Promise<void> {\n\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.WebSocketNodeSocketDrainBegin);\n\t\tif (this._flowManager.isProcessingWriteQueue()) {\n\t\t\tawait Event.toPromise(this._flowManager.onDidFinishProcessingWriteQueue);\n\t\t}\n\t\tawait this.socket.drain();\n\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.WebSocketNodeSocketDrainEnd);\n\t}\n}\n\nclass WebSocketFlowManager extends Disposable {\n\n\tprivate readonly _onError = this._register(new Emitter<Error>());\n\tpublic readonly onError = this._onError.event;\n\n\tprivate readonly _zlibInflateStream: ZlibInflateStream | null;\n\tprivate readonly _zlibDeflateStream: ZlibDeflateStream | null;\n\tprivate readonly _writeQueue: { data: VSBuffer; options: FrameOptions }[] = [];\n\tprivate readonly _readQueue: { data: VSBuffer; isCompressed: boolean; isLastFrameOfMessage: boolean }[] = [];\n\n\tprivate readonly _onDidFinishProcessingReadQueue = this._register(new Emitter<void>());\n\tpublic readonly onDidFinishProcessingReadQueue = this._onDidFinishProcessingReadQueue.event;\n\n\tprivate readonly _onDidFinishProcessingWriteQueue = this._register(new Emitter<void>());\n\tpublic readonly onDidFinishProcessingWriteQueue = this._onDidFinishProcessingWriteQueue.event;\n\n\tpublic get permessageDeflate(): boolean {\n\t\treturn Boolean(this._zlibInflateStream && this._zlibDeflateStream);\n\t}\n\n\tpublic get recordedInflateBytes(): VSBuffer {\n\t\tif (this._zlibInflateStream) {\n\t\t\treturn this._zlibInflateStream.recordedInflateBytes;\n\t\t}\n\t\treturn VSBuffer.alloc(0);\n\t}\n\n\tconstructor(\n\t\tprivate readonly _tracer: ISocketTracer,\n\t\tpermessageDeflate: boolean,\n\t\tinflateBytes: VSBuffer | null,\n\t\trecordInflateBytes: boolean,\n\t\tprivate readonly _onData: Emitter<VSBuffer>,\n\t\tprivate readonly _writeFn: (data: VSBuffer, options: FrameOptions) => void\n\t) {\n\t\tsuper();\n\t\tif (permessageDeflate) {\n\t\t\t// See https://tools.ietf.org/html/rfc7692#page-16\n\t\t\t// To simplify our logic, we don't negotiate the window size\n\t\t\t// and simply dedicate (2^15) / 32kb per web socket\n\t\t\tthis._zlibInflateStream = this._register(new ZlibInflateStream(this._tracer, recordInflateBytes, inflateBytes, { windowBits: 15 }));\n\t\t\tthis._zlibDeflateStream = this._register(new ZlibDeflateStream(this._tracer, { windowBits: 15 }));\n\t\t\tthis._register(this._zlibInflateStream.onError((err) => this._onError.fire(err)));\n\t\t\tthis._register(this._zlibDeflateStream.onError((err) => this._onError.fire(err)));\n\t\t} else {\n\t\t\tthis._zlibInflateStream = null;\n\t\t\tthis._zlibDeflateStream = null;\n\t\t}\n\t}\n\n\tpublic writeMessage(data: VSBuffer, options: FrameOptions): void {\n\t\tthis._writeQueue.push({ data, options });\n\t\tthis._processWriteQueue();\n\t}\n\n\tprivate _isProcessingWriteQueue = false;\n\tprivate async _processWriteQueue(): Promise<void> {\n\t\tif (this._isProcessingWriteQueue) {\n\t\t\treturn;\n\t\t}\n\t\tthis._isProcessingWriteQueue = true;\n\t\twhile (this._writeQueue.length > 0) {\n\t\t\tconst { data, options } = this._writeQueue.shift()!;\n\t\t\tif (this._zlibDeflateStream && options.compressed) {\n\t\t\t\tconst compressedData = await this._deflateMessage(this._zlibDeflateStream, data);\n\t\t\t\tthis._writeFn(compressedData, options);\n\t\t\t} else {\n\t\t\t\tthis._writeFn(data, { ...options, compressed: false });\n\t\t\t}\n\t\t}\n\t\tthis._isProcessingWriteQueue = false;\n\t\tthis._onDidFinishProcessingWriteQueue.fire();\n\t}\n\n\tpublic isProcessingWriteQueue(): boolean {\n\t\treturn (this._isProcessingWriteQueue);\n\t}\n\n\t/**\n\t * Subsequent calls should wait for the previous `_deflateBuffer` call to complete.\n\t */\n\tprivate _deflateMessage(zlibDeflateStream: ZlibDeflateStream, buffer: VSBuffer): Promise<VSBuffer> {\n\t\treturn new Promise<VSBuffer>((resolve, reject) => {\n\t\t\tzlibDeflateStream.write(buffer);\n\t\t\tzlibDeflateStream.flush(data => resolve(data));\n\t\t});\n\t}\n\n\tpublic acceptFrame(data: VSBuffer, isCompressed: boolean, isLastFrameOfMessage: boolean): void {\n\t\tthis._readQueue.push({ data, isCompressed, isLastFrameOfMessage });\n\t\tthis._processReadQueue();\n\t}\n\n\tprivate _isProcessingReadQueue = false;\n\tprivate async _processReadQueue(): Promise<void> {\n\t\tif (this._isProcessingReadQueue) {\n\t\t\treturn;\n\t\t}\n\t\tthis._isProcessingReadQueue = true;\n\t\twhile (this._readQueue.length > 0) {\n\t\t\tconst frameInfo = this._readQueue.shift()!;\n\t\t\tif (this._zlibInflateStream && frameInfo.isCompressed) {\n\t\t\t\t// See https://datatracker.ietf.org/doc/html/rfc7692#section-9.2\n\t\t\t\t// Even if permessageDeflate is negotiated, it is possible\n\t\t\t\t// that the other side might decide to send uncompressed messages\n\t\t\t\t// So only decompress messages that have the RSV 1 bit set\n\t\t\t\tconst data = await this._inflateFrame(this._zlibInflateStream, frameInfo.data, frameInfo.isLastFrameOfMessage);\n\t\t\t\tthis._onData.fire(data);\n\t\t\t} else {\n\t\t\t\tthis._onData.fire(frameInfo.data);\n\t\t\t}\n\t\t}\n\t\tthis._isProcessingReadQueue = false;\n\t\tthis._onDidFinishProcessingReadQueue.fire();\n\t}\n\n\tpublic isProcessingReadQueue(): boolean {\n\t\treturn (this._isProcessingReadQueue);\n\t}\n\n\t/**\n\t * Subsequent calls should wait for the previous `transformRead` call to complete.\n\t */\n\tprivate _inflateFrame(zlibInflateStream: ZlibInflateStream, buffer: VSBuffer, isLastFrameOfMessage: boolean): Promise<VSBuffer> {\n\t\treturn new Promise<VSBuffer>((resolve, reject) => {\n\t\t\t// See https://tools.ietf.org/html/rfc7692#section-7.2.2\n\t\t\tzlibInflateStream.write(buffer);\n\t\t\tif (isLastFrameOfMessage) {\n\t\t\t\tzlibInflateStream.write(VSBuffer.fromByteArray([0x00, 0x00, 0xff, 0xff]));\n\t\t\t}\n\t\t\tzlibInflateStream.flush(data => resolve(data));\n\t\t});\n\t}\n}\n\nclass ZlibInflateStream extends Disposable {\n\n\tprivate readonly _onError = this._register(new Emitter<Error>());\n\tpublic readonly onError = this._onError.event;\n\n\tprivate readonly _zlibInflate: InflateRaw;\n\tprivate readonly _recordedInflateBytes: VSBuffer[] = [];\n\tprivate readonly _pendingInflateData: VSBuffer[] = [];\n\n\tpublic get recordedInflateBytes(): VSBuffer {\n\t\tif (this._recordInflateBytes) {\n\t\t\treturn VSBuffer.concat(this._recordedInflateBytes);\n\t\t}\n\t\treturn VSBuffer.alloc(0);\n\t}\n\n\tconstructor(\n\t\tprivate readonly _tracer: ISocketTracer,\n\t\tprivate readonly _recordInflateBytes: boolean,\n\t\tinflateBytes: VSBuffer | null,\n\t\toptions: ZlibOptions\n\t) {\n\t\tsuper();\n\t\tthis._zlibInflate = createInflateRaw(options);\n\t\tthis._zlibInflate.on('error', (err) => {\n\t\t\tthis._tracer.traceSocketEvent(SocketDiagnosticsEventType.zlibInflateError, { message: err?.message, code: (<any>err)?.code });\n\t\t\tthis._onError.fire(err);\n\t\t});\n\t\tthis._zlibInflate.on('data', (data: Buffer) => {\n\t\t\tthis._tracer.traceSocketEvent(SocketDiagnosticsEventType.zlibInflateData, data);\n\t\t\tthis._pendingInflateData.push(VSBuffer.wrap(data));\n\t\t});\n\t\tif (inflateBytes) {\n\t\t\tthis._tracer.traceSocketEvent(SocketDiagnosticsEventType.zlibInflateInitialWrite, inflateBytes.buffer);\n\t\t\tthis._zlibInflate.write(inflateBytes.buffer);\n\t\t\tthis._zlibInflate.flush(() => {\n\t\t\t\tthis._tracer.traceSocketEvent(SocketDiagnosticsEventType.zlibInflateInitialFlushFired);\n\t\t\t\tthis._pendingInflateData.length = 0;\n\t\t\t});\n\t\t}\n\t}\n\n\tpublic write(buffer: VSBuffer): void {\n\t\tif (this._recordInflateBytes) {\n\t\t\tthis._recordedInflateBytes.push(buffer.clone());\n\t\t}\n\t\tthis._tracer.traceSocketEvent(SocketDiagnosticsEventType.zlibInflateWrite, buffer);\n\t\tthis._zlibInflate.write(buffer.buffer);\n\t}\n\n\tpublic flush(callback: (data: VSBuffer) => void): void {\n\t\tthis._zlibInflate.flush(() => {\n\t\t\tthis._tracer.traceSocketEvent(SocketDiagnosticsEventType.zlibInflateFlushFired);\n\t\t\tconst data = VSBuffer.concat(this._pendingInflateData);\n\t\t\tthis._pendingInflateData.length = 0;\n\t\t\tcallback(data);\n\t\t});\n\t}\n}\n\nclass ZlibDeflateStream extends Disposable {\n\n\tprivate readonly _onError = this._register(new Emitter<Error>());\n\tpublic readonly onError = this._onError.event;\n\n\tprivate readonly _zlibDeflate: DeflateRaw;\n\tprivate readonly _pendingDeflateData: VSBuffer[] = [];\n\n\tconstructor(\n\t\tprivate readonly _tracer: ISocketTracer,\n\t\toptions: ZlibOptions\n\t) {\n\t\tsuper();\n\n\t\tthis._zlibDeflate = createDeflateRaw({\n\t\t\twindowBits: 15\n\t\t});\n\t\tthis._zlibDeflate.on('error', (err) => {\n\t\t\tthis._tracer.traceSocketEvent(SocketDiagnosticsEventType.zlibDeflateError, { message: err?.message, code: (<any>err)?.code });\n\t\t\tthis._onError.fire(err);\n\t\t});\n\t\tthis._zlibDeflate.on('data', (data: Buffer) => {\n\t\t\tthis._tracer.traceSocketEvent(SocketDiagnosticsEventType.zlibDeflateData, data);\n\t\t\tthis._pendingDeflateData.push(VSBuffer.wrap(data));\n\t\t});\n\t}\n\n\tpublic write(buffer: VSBuffer): void {\n\t\tthis._tracer.traceSocketEvent(SocketDiagnosticsEventType.zlibDeflateWrite, buffer.buffer);\n\t\tthis._zlibDeflate.write(<Buffer>buffer.buffer);\n\t}\n\n\tpublic flush(callback: (data: VSBuffer) => void): void {\n\t\t// See https://zlib.net/manual.html#Constants\n\t\tthis._zlibDeflate.flush(/*Z_SYNC_FLUSH*/2, () => {\n\t\t\tthis._tracer.traceSocketEvent(SocketDiagnosticsEventType.zlibDeflateFlushFired);\n\n\t\t\tlet data = VSBuffer.concat(this._pendingDeflateData);\n\t\t\tthis._pendingDeflateData.length = 0;\n\n\t\t\t// See https://tools.ietf.org/html/rfc7692#section-7.2.1\n\t\t\tdata = data.slice(0, data.byteLength - 4);\n\n\t\t\tcallback(data);\n\t\t});\n\t}\n}\n\nfunction unmask(buffer: VSBuffer, mask: number): void {\n\tif (mask === 0) {\n\t\treturn;\n\t}\n\tconst cnt = buffer.byteLength >>> 2;\n\tfor (let i = 0; i < cnt; i++) {\n\t\tconst v = buffer.readUInt32BE(i * 4);\n\t\tbuffer.writeUInt32BE(v ^ mask, i * 4);\n\t}\n\tconst offset = cnt * 4;\n\tconst bytesLeft = buffer.byteLength - offset;\n\tconst m3 = (mask >>> 24) & 0b11111111;\n\tconst m2 = (mask >>> 16) & 0b11111111;\n\tconst m1 = (mask >>> 8) & 0b11111111;\n\tif (bytesLeft >= 1) {\n\t\tbuffer.writeUInt8(buffer.readUInt8(offset) ^ m3, offset);\n\t}\n\tif (bytesLeft >= 2) {\n\t\tbuffer.writeUInt8(buffer.readUInt8(offset + 1) ^ m2, offset + 1);\n\t}\n\tif (bytesLeft >= 3) {\n\t\tbuffer.writeUInt8(buffer.readUInt8(offset + 2) ^ m1, offset + 2);\n\t}\n}\n\n// Read this before there's any chance it is overwritten\n// Related to https://github.com/microsoft/vscode/issues/30624\nexport const XDG_RUNTIME_DIR = <string | undefined>process.env['XDG_RUNTIME_DIR'];\n\nconst safeIpcPathLengths: { [platform: number]: number } = {\n\t[Platform.Linux]: 107,\n\t[Platform.Mac]: 103\n};\n\nexport function createRandomIPCHandle(): string {\n\tconst randomSuffix = generateUuid();\n\n\t// Windows: use named pipe\n\tif (process.platform === 'win32') {\n\t\treturn `\\\\\\\\.\\\\pipe\\\\vscode-ipc-${randomSuffix}-sock`;\n\t}\n\n\t// Mac & Unix: Use socket file\n\t// Unix: Prefer XDG_RUNTIME_DIR over user data path\n\tconst basePath = process.platform !== 'darwin' && XDG_RUNTIME_DIR ? XDG_RUNTIME_DIR : tmpdir();\n\tconst result = join(basePath, `vscode-ipc-${randomSuffix}.sock`);\n\n\t// Validate length\n\tvalidateIPCHandleLength(result);\n\n\treturn result;\n}\n\nexport function createStaticIPCHandle(directoryPath: string, type: string, version: string): string {\n\tconst scope = createHash('sha256').update(directoryPath).digest('hex');\n\tconst scopeForSocket = scope.substr(0, 8);\n\n\t// Windows: use named pipe\n\tif (process.platform === 'win32') {\n\t\treturn `\\\\\\\\.\\\\pipe\\\\${scopeForSocket}-${version}-${type}-sock`;\n\t}\n\n\t// Mac & Unix: Use socket file\n\t// Unix: Prefer XDG_RUNTIME_DIR over user data path, unless portable\n\t// Trim the version and type values for the socket to prevent too large\n\t// file names causing issues: https://unix.stackexchange.com/q/367008\n\n\tconst versionForSocket = version.substr(0, 4);\n\tconst typeForSocket = type.substr(0, 6);\n\n\tlet result: string;\n\tif (process.platform !== 'darwin' && XDG_RUNTIME_DIR && !process.env['VSCODE_PORTABLE']) {\n\t\tresult = join(XDG_RUNTIME_DIR, `vscode-${scopeForSocket}-${versionForSocket}-${typeForSocket}.sock`);\n\t} else {\n\t\tresult = join(directoryPath, `${versionForSocket}-${typeForSocket}.sock`);\n\t}\n\n\t// Validate length\n\tvalidateIPCHandleLength(result);\n\n\treturn result;\n}\n\nfunction validateIPCHandleLength(handle: string): void {\n\tconst limit = safeIpcPathLengths[platform];\n\tif (typeof limit === 'number' && handle.length >= limit) {\n\t\t// https://nodejs.org/api/net.html#net_identifying_paths_for_ipc_connections\n\t\tconsole.warn(`WARNING: IPC handle \"${handle}\" is longer than ${limit} chars, try a shorter --user-data-dir`);\n\t}\n}\n\nexport class Server extends IPCServer {\n\n\tprivate static toClientConnectionEvent(server: NetServer): Event<ClientConnectionEvent> {\n\t\tconst onConnection = Event.fromNodeEventEmitter<Socket>(server, 'connection');\n\n\t\treturn Event.map(onConnection, socket => ({\n\t\t\tprotocol: new Protocol(new NodeSocket(socket, 'ipc-server-connection')),\n\t\t\tonDidClientDisconnect: Event.once(Event.fromNodeEventEmitter<void>(socket, 'close'))\n\t\t}));\n\t}\n\n\tprivate server: NetServer | null;\n\n\tconstructor(server: NetServer) {\n\t\tsuper(Server.toClientConnectionEvent(server));\n\t\tthis.server = server;\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\t\tif (this.server) {\n\t\t\tthis.server.close();\n\t\t\tthis.server = null;\n\t\t}\n\t}\n}\n\nexport function serve(port: number): Promise<Server>;\nexport function serve(namedPipe: string): Promise<Server>;\nexport function serve(hook: any): Promise<Server> {\n\treturn new Promise<Server>((c, e) => {\n\t\tconst server = createServer();\n\n\t\tserver.on('error', e);\n\t\tserver.listen(hook, () => {\n\t\t\tserver.removeListener('error', e);\n\t\t\tc(new Server(server));\n\t\t});\n\t});\n}\n\nexport function connect(options: { host: string; port: number }, clientId: string): Promise<Client>;\nexport function connect(port: number, clientId: string): Promise<Client>;\nexport function connect(namedPipe: string, clientId: string): Promise<Client>;\nexport function connect(hook: any, clientId: string): Promise<Client> {\n\treturn new Promise<Client>((c, e) => {\n\t\tconst socket = createConnection(hook, () => {\n\t\t\tsocket.removeListener('error', e);\n\t\t\tc(Client.fromSocket(new NodeSocket(socket, `ipc-client${clientId}`), clientId));\n\t\t});\n\n\t\tsocket.once('error', e);\n\t});\n}\n"],
  "mappings": "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",
  "names": ["Constants", "ReadState"]
}
