{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/parts/ipc/node/ipc.net.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createHash } from \"crypto\";\nimport {\n\ttype Server as NetServer,\n\ttype Socket,\n\tcreateConnection,\n\tcreateServer,\n} from \"net\";\nimport { tmpdir } from \"os\";\nimport {\n\ttype DeflateRaw,\n\ttype InflateRaw,\n\ttype ZlibOptions,\n\tcreateDeflateRaw,\n\tcreateInflateRaw,\n} from \"zlib\";\nimport { VSBuffer } from \"../../../common/buffer.js\";\nimport { onUnexpectedError } from \"../../../common/errors.js\";\nimport { Emitter, Event } from \"../../../common/event.js\";\nimport { Disposable, type IDisposable } from \"../../../common/lifecycle.js\";\nimport { join } from \"../../../common/path.js\";\nimport { Platform, platform } from \"../../../common/platform.js\";\nimport { generateUuid } from \"../../../common/uuid.js\";\nimport { type ClientConnectionEvent, IPCServer } from \"../common/ipc.js\";\nimport {\n\tChunkStream,\n\tClient,\n\ttype ISocket,\n\tProtocol,\n\ttype SocketCloseEvent,\n\tSocketCloseEventType,\n\tSocketDiagnostics,\n\tSocketDiagnosticsEventType,\n} from \"../common/ipc.net.js\";\n\n/**\n * Maximum time to wait for a 'close' event to fire after the socket stream\n * ends. For unix domain sockets, the close event may not fire consistently\n * due to what appears to be a Node.js bug.\n *\n * @see https://github.com/microsoft/vscode/issues/211462#issuecomment-2155471996\n */\nconst socketEndTimeoutMs = 30_000;\n\nexport class NodeSocket implements ISocket {\n\tpublic readonly debugLabel: string;\n\tpublic readonly socket: Socket;\n\tprivate readonly _errorListener: (err: any) => void;\n\tprivate readonly _closeListener: (hadError: boolean) => void;\n\tprivate readonly _endListener: () => void;\n\tprivate _canWrite = true;\n\n\tpublic traceSocketEvent(\n\t\ttype: SocketDiagnosticsEventType,\n\t\tdata?: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView | any,\n\t): void {\n\t\tSocketDiagnostics.traceSocketEvent(\n\t\t\tthis.socket,\n\t\t\tthis.debugLabel,\n\t\t\ttype,\n\t\t\tdata,\n\t\t);\n\t}\n\n\tconstructor(socket: Socket, debugLabel = \"\") {\n\t\tthis.debugLabel = debugLabel;\n\t\tthis.socket = socket;\n\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.Created, {\n\t\t\ttype: \"NodeSocket\",\n\t\t});\n\t\tthis._errorListener = (err: any) => {\n\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.Error, {\n\t\t\t\tcode: err?.code,\n\t\t\t\tmessage: err?.message,\n\t\t\t});\n\t\t\tif (err) {\n\t\t\t\tif (err.code === \"EPIPE\") {\n\t\t\t\t\t// An EPIPE exception at the wrong time can lead to a renderer process crash\n\t\t\t\t\t// so ignore the error since the socket will fire the close event soon anyways:\n\t\t\t\t\t// > https://nodejs.org/api/errors.html#errors_common_system_errors\n\t\t\t\t\t// > EPIPE (Broken pipe): A write on a pipe, socket, or FIFO for which there is no\n\t\t\t\t\t// > process to read the data. Commonly encountered at the net and http layers,\n\t\t\t\t\t// > indicative that the remote side of the stream being written to has been closed.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tonUnexpectedError(err);\n\t\t\t}\n\t\t};\n\t\tthis.socket.on(\"error\", this._errorListener);\n\n\t\tlet endTimeoutHandle: NodeJS.Timeout | undefined;\n\t\tthis._closeListener = (hadError: boolean) => {\n\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.Close, {\n\t\t\t\thadError,\n\t\t\t});\n\t\t\tthis._canWrite = false;\n\t\t\tif (endTimeoutHandle) {\n\t\t\t\tclearTimeout(endTimeoutHandle);\n\t\t\t}\n\t\t};\n\t\tthis.socket.on(\"close\", this._closeListener);\n\n\t\tthis._endListener = () => {\n\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.NodeEndReceived);\n\t\t\tthis._canWrite = false;\n\t\t\tendTimeoutHandle = setTimeout(\n\t\t\t\t() => socket.destroy(),\n\t\t\t\tsocketEndTimeoutMs,\n\t\t\t);\n\t\t};\n\t\tthis.socket.on(\"end\", this._endListener);\n\t}\n\n\tpublic dispose(): void {\n\t\tthis.socket.off(\"error\", this._errorListener);\n\t\tthis.socket.off(\"close\", this._closeListener);\n\t\tthis.socket.off(\"end\", this._endListener);\n\t\tthis.socket.destroy();\n\t}\n\n\tpublic onData(_listener: (e: VSBuffer) => void): IDisposable {\n\t\tconst listener = (buff: Buffer) => {\n\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.Read, buff);\n\t\t\t_listener(VSBuffer.wrap(buff));\n\t\t};\n\t\tthis.socket.on(\"data\", listener);\n\t\treturn {\n\t\t\tdispose: () => this.socket.off(\"data\", listener),\n\t\t};\n\t}\n\n\tpublic onClose(listener: (e: SocketCloseEvent) => void): IDisposable {\n\t\tconst adapter = (hadError: boolean) => {\n\t\t\tlistener({\n\t\t\t\ttype: SocketCloseEventType.NodeSocketCloseEvent,\n\t\t\t\thadError: hadError,\n\t\t\t\terror: undefined,\n\t\t\t});\n\t\t};\n\t\tthis.socket.on(\"close\", adapter);\n\t\treturn {\n\t\t\tdispose: () => this.socket.off(\"close\", adapter),\n\t\t};\n\t}\n\n\tpublic onEnd(listener: () => void): IDisposable {\n\t\tconst adapter = () => {\n\t\t\tlistener();\n\t\t};\n\t\tthis.socket.on(\"end\", adapter);\n\t\treturn {\n\t\t\tdispose: () => this.socket.off(\"end\", adapter),\n\t\t};\n\t}\n\n\tpublic write(buffer: VSBuffer): void {\n\t\t// return early if socket has been destroyed in the meantime\n\t\tif (this.socket.destroyed || !this._canWrite) {\n\t\t\treturn;\n\t\t}\n\n\t\t// we ignore the returned value from `write` because we would have to cached the data\n\t\t// anyways and nodejs is already doing that for us:\n\t\t// > https://nodejs.org/api/stream.html#stream_writable_write_chunk_encoding_callback\n\t\t// > However, the false return value is only advisory and the writable stream will unconditionally\n\t\t// > accept and buffer chunk even if it has not been allowed to drain.\n\t\ttry {\n\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.Write, buffer);\n\t\t\tthis.socket.write(buffer.buffer, (err: any) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tif (err.code === \"EPIPE\") {\n\t\t\t\t\t\t// An EPIPE exception at the wrong time can lead to a renderer process crash\n\t\t\t\t\t\t// so ignore the error since the socket will fire the close event soon anyways:\n\t\t\t\t\t\t// > https://nodejs.org/api/errors.html#errors_common_system_errors\n\t\t\t\t\t\t// > EPIPE (Broken pipe): A write on a pipe, socket, or FIFO for which there is no\n\t\t\t\t\t\t// > process to read the data. Commonly encountered at the net and http layers,\n\t\t\t\t\t\t// > indicative that the remote side of the stream being written to has been closed.\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tonUnexpectedError(err);\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (err) {\n\t\t\tif (err.code === \"EPIPE\") {\n\t\t\t\t// An EPIPE exception at the wrong time can lead to a renderer process crash\n\t\t\t\t// so ignore the error since the socket will fire the close event soon anyways:\n\t\t\t\t// > https://nodejs.org/api/errors.html#errors_common_system_errors\n\t\t\t\t// > EPIPE (Broken pipe): A write on a pipe, socket, or FIFO for which there is no\n\t\t\t\t// > process to read the data. Commonly encountered at the net and http layers,\n\t\t\t\t// > indicative that the remote side of the stream being written to has been closed.\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tonUnexpectedError(err);\n\t\t}\n\t}\n\n\tpublic end(): void {\n\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.NodeEndSent);\n\t\tthis.socket.end();\n\t}\n\n\tpublic drain(): Promise<void> {\n\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.NodeDrainBegin);\n\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\tif (this.socket.bufferSize === 0) {\n\t\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.NodeDrainEnd);\n\t\t\t\tresolve();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst finished = () => {\n\t\t\t\tthis.socket.off(\"close\", finished);\n\t\t\t\tthis.socket.off(\"end\", finished);\n\t\t\t\tthis.socket.off(\"error\", finished);\n\t\t\t\tthis.socket.off(\"timeout\", finished);\n\t\t\t\tthis.socket.off(\"drain\", finished);\n\t\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.NodeDrainEnd);\n\t\t\t\tresolve();\n\t\t\t};\n\t\t\tthis.socket.on(\"close\", finished);\n\t\t\tthis.socket.on(\"end\", finished);\n\t\t\tthis.socket.on(\"error\", finished);\n\t\t\tthis.socket.on(\"timeout\", finished);\n\t\t\tthis.socket.on(\"drain\", finished);\n\t\t});\n\t}\n}\n\nenum Constants {\n\tMinHeaderByteSize = 2,\n\t/**\n\t * If we need to write a large buffer, we will split it into 256KB chunks and\n\t * send each chunk as a websocket message. This is to prevent that the sending\n\t * side is stuck waiting for the entire buffer to be compressed before writing\n\t * to the underlying socket or that the receiving side is stuck waiting for the\n\t * entire message to be received before processing the bytes.\n\t */\n\tMaxWebSocketMessageLength = 256 * 1024, // 256 KB\n}\n\nenum ReadState {\n\tPeekHeader = 1,\n\tReadHeader = 2,\n\tReadBody = 3,\n\tFin = 4,\n}\n\ninterface ISocketTracer {\n\ttraceSocketEvent(\n\t\ttype: SocketDiagnosticsEventType,\n\t\tdata?: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView | any,\n\t): void;\n}\n\ninterface FrameOptions {\n\tcompressed: boolean;\n\topcode: number;\n}\n\n/**\n * See https://tools.ietf.org/html/rfc6455#section-5.2\n */\nexport class WebSocketNodeSocket\n\textends Disposable\n\timplements ISocket, ISocketTracer\n{\n\tpublic readonly socket: NodeSocket;\n\tprivate readonly _flowManager: WebSocketFlowManager;\n\tprivate readonly _incomingData: ChunkStream;\n\tprivate readonly _onData = this._register(new Emitter<VSBuffer>());\n\tprivate readonly _onClose = this._register(new Emitter<SocketCloseEvent>());\n\tprivate _isEnded = false;\n\n\tprivate readonly _state = {\n\t\tstate: ReadState.PeekHeader,\n\t\treadLen: Constants.MinHeaderByteSize,\n\t\tfin: 0,\n\t\tcompressed: false,\n\t\tfirstFrameOfMessage: true,\n\t\tmask: 0,\n\t\topcode: 0,\n\t};\n\n\tpublic get permessageDeflate(): boolean {\n\t\treturn this._flowManager.permessageDeflate;\n\t}\n\n\tpublic get recordedInflateBytes(): VSBuffer {\n\t\treturn this._flowManager.recordedInflateBytes;\n\t}\n\n\tpublic traceSocketEvent(\n\t\ttype: SocketDiagnosticsEventType,\n\t\tdata?: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView | any,\n\t): void {\n\t\tthis.socket.traceSocketEvent(type, data);\n\t}\n\n\t/**\n\t * Create a socket which can communicate using WebSocket frames.\n\t *\n\t * **NOTE**: When using the permessage-deflate WebSocket extension, if parts of inflating was done\n\t *  in a different zlib instance, we need to pass all those bytes into zlib, otherwise the inflate\n\t *  might hit an inflated portion referencing a distance too far back.\n\t *\n\t * @param socket The underlying socket\n\t * @param permessageDeflate Use the permessage-deflate WebSocket extension\n\t * @param inflateBytes \"Seed\" zlib inflate with these bytes.\n\t * @param recordInflateBytes Record all bytes sent to inflate\n\t */\n\tconstructor(\n\t\tsocket: NodeSocket,\n\t\tpermessageDeflate: boolean,\n\t\tinflateBytes: VSBuffer | null,\n\t\trecordInflateBytes: boolean,\n\t) {\n\t\tsuper();\n\t\tthis.socket = socket;\n\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.Created, {\n\t\t\ttype: \"WebSocketNodeSocket\",\n\t\t\tpermessageDeflate,\n\t\t\tinflateBytesLength: inflateBytes?.byteLength || 0,\n\t\t\trecordInflateBytes,\n\t\t});\n\t\tthis._flowManager = this._register(\n\t\t\tnew WebSocketFlowManager(\n\t\t\t\tthis,\n\t\t\t\tpermessageDeflate,\n\t\t\t\tinflateBytes,\n\t\t\t\trecordInflateBytes,\n\t\t\t\tthis._onData,\n\t\t\t\t(data, options) => this._write(data, options),\n\t\t\t),\n\t\t);\n\t\tthis._register(\n\t\t\tthis._flowManager.onError((err) => {\n\t\t\t\t// zlib errors are fatal, since we have no idea how to recover\n\t\t\t\tconsole.error(err);\n\t\t\t\tonUnexpectedError(err);\n\t\t\t\tthis._onClose.fire({\n\t\t\t\t\ttype: SocketCloseEventType.NodeSocketCloseEvent,\n\t\t\t\t\thadError: true,\n\t\t\t\t\terror: err,\n\t\t\t\t});\n\t\t\t}),\n\t\t);\n\t\tthis._incomingData = new ChunkStream();\n\t\tthis._register(this.socket.onData((data) => this._acceptChunk(data)));\n\t\tthis._register(\n\t\t\tthis.socket.onClose(async (e) => {\n\t\t\t\t// Delay surfacing the close event until the async inflating is done\n\t\t\t\t// and all data has been emitted\n\t\t\t\tif (this._flowManager.isProcessingReadQueue()) {\n\t\t\t\t\tawait Event.toPromise(\n\t\t\t\t\t\tthis._flowManager.onDidFinishProcessingReadQueue,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tthis._onClose.fire(e);\n\t\t\t}),\n\t\t);\n\t}\n\n\tpublic override dispose(): void {\n\t\tif (this._flowManager.isProcessingWriteQueue()) {\n\t\t\t// Wait for any outstanding writes to finish before disposing\n\t\t\tthis._register(\n\t\t\t\tthis._flowManager.onDidFinishProcessingWriteQueue(() => {\n\t\t\t\t\tthis.dispose();\n\t\t\t\t}),\n\t\t\t);\n\t\t} else {\n\t\t\tthis.socket.dispose();\n\t\t\tsuper.dispose();\n\t\t}\n\t}\n\n\tpublic onData(listener: (e: VSBuffer) => void): IDisposable {\n\t\treturn this._onData.event(listener);\n\t}\n\n\tpublic onClose(listener: (e: SocketCloseEvent) => void): IDisposable {\n\t\treturn this._onClose.event(listener);\n\t}\n\n\tpublic onEnd(listener: () => void): IDisposable {\n\t\treturn this.socket.onEnd(listener);\n\t}\n\n\tpublic write(buffer: VSBuffer): void {\n\t\t// If we write many logical messages (let's say 1000 messages of 100KB) during a single process tick, we do\n\t\t// this thing where we install a process.nextTick timer and group all of them together and we then issue a\n\t\t// single WebSocketNodeSocket.write with a 100MB buffer.\n\t\t//\n\t\t// The first problem is that the actual writing to the underlying node socket will only happen after all of\n\t\t// the 100MB have been deflated (due to waiting on zlib flush). The second problem is on the reading side,\n\t\t// where we will get a single WebSocketNodeSocket.onData event fired when all the 100MB have arrived,\n\t\t// delaying processing the 1000 received messages until all have arrived, instead of processing them as each\n\t\t// one arrives.\n\t\t//\n\t\t// We therefore split the buffer into chunks, and issue a write for each chunk.\n\n\t\tlet start = 0;\n\t\twhile (start < buffer.byteLength) {\n\t\t\tthis._flowManager.writeMessage(\n\t\t\t\tbuffer.slice(\n\t\t\t\t\tstart,\n\t\t\t\t\tMath.min(\n\t\t\t\t\t\tstart + Constants.MaxWebSocketMessageLength,\n\t\t\t\t\t\tbuffer.byteLength,\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\t{ compressed: true, opcode: 0x02 /* Binary frame */ },\n\t\t\t);\n\t\t\tstart += Constants.MaxWebSocketMessageLength;\n\t\t}\n\t}\n\n\tprivate _write(\n\t\tbuffer: VSBuffer,\n\t\t{ compressed, opcode }: FrameOptions,\n\t): void {\n\t\tif (this._isEnded) {\n\t\t\t// Avoid ERR_STREAM_WRITE_AFTER_END\n\t\t\treturn;\n\t\t}\n\n\t\tthis.traceSocketEvent(\n\t\t\tSocketDiagnosticsEventType.WebSocketNodeSocketWrite,\n\t\t\tbuffer,\n\t\t);\n\t\tlet headerLen = Constants.MinHeaderByteSize;\n\t\tif (buffer.byteLength < 126) {\n\t\t\theaderLen += 0;\n\t\t} else if (buffer.byteLength < 2 ** 16) {\n\t\t\theaderLen += 2;\n\t\t} else {\n\t\t\theaderLen += 8;\n\t\t}\n\t\tconst header = VSBuffer.alloc(headerLen);\n\n\t\t// The RSV1 bit indicates a compressed frame\n\t\tconst compressedFlag = compressed ? 0b01000000 : 0;\n\t\tconst opcodeFlag = opcode & 0b00001111;\n\t\theader.writeUInt8(0b10000000 | compressedFlag | opcodeFlag, 0);\n\t\tif (buffer.byteLength < 126) {\n\t\t\theader.writeUInt8(buffer.byteLength, 1);\n\t\t} else if (buffer.byteLength < 2 ** 16) {\n\t\t\theader.writeUInt8(126, 1);\n\t\t\tlet offset = 1;\n\t\t\theader.writeUInt8((buffer.byteLength >>> 8) & 0b11111111, ++offset);\n\t\t\theader.writeUInt8((buffer.byteLength >>> 0) & 0b11111111, ++offset);\n\t\t} else {\n\t\t\theader.writeUInt8(127, 1);\n\t\t\tlet offset = 1;\n\t\t\theader.writeUInt8(0, ++offset);\n\t\t\theader.writeUInt8(0, ++offset);\n\t\t\theader.writeUInt8(0, ++offset);\n\t\t\theader.writeUInt8(0, ++offset);\n\t\t\theader.writeUInt8(\n\t\t\t\t(buffer.byteLength >>> 24) & 0b11111111,\n\t\t\t\t++offset,\n\t\t\t);\n\t\t\theader.writeUInt8(\n\t\t\t\t(buffer.byteLength >>> 16) & 0b11111111,\n\t\t\t\t++offset,\n\t\t\t);\n\t\t\theader.writeUInt8((buffer.byteLength >>> 8) & 0b11111111, ++offset);\n\t\t\theader.writeUInt8((buffer.byteLength >>> 0) & 0b11111111, ++offset);\n\t\t}\n\n\t\tthis.socket.write(VSBuffer.concat([header, buffer]));\n\t}\n\n\tpublic end(): void {\n\t\tthis._isEnded = true;\n\t\tthis.socket.end();\n\t}\n\n\tprivate _acceptChunk(data: VSBuffer): void {\n\t\tif (data.byteLength === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._incomingData.acceptChunk(data);\n\n\t\twhile (this._incomingData.byteLength >= this._state.readLen) {\n\t\t\tif (this._state.state === ReadState.PeekHeader) {\n\t\t\t\t// peek to see if we can read the entire header\n\t\t\t\tconst peekHeader = this._incomingData.peek(this._state.readLen);\n\t\t\t\tconst firstByte = peekHeader.readUInt8(0);\n\t\t\t\tconst finBit = (firstByte & 0b10000000) >>> 7;\n\t\t\t\tconst rsv1Bit = (firstByte & 0b01000000) >>> 6;\n\t\t\t\tconst opcode = firstByte & 0b00001111;\n\n\t\t\t\tconst secondByte = peekHeader.readUInt8(1);\n\t\t\t\tconst hasMask = (secondByte & 0b10000000) >>> 7;\n\t\t\t\tconst len = secondByte & 0b01111111;\n\n\t\t\t\tthis._state.state = ReadState.ReadHeader;\n\t\t\t\tthis._state.readLen =\n\t\t\t\t\tConstants.MinHeaderByteSize +\n\t\t\t\t\t(hasMask ? 4 : 0) +\n\t\t\t\t\t(len === 126 ? 2 : 0) +\n\t\t\t\t\t(len === 127 ? 8 : 0);\n\t\t\t\tthis._state.fin = finBit;\n\t\t\t\tif (this._state.firstFrameOfMessage) {\n\t\t\t\t\t// if the frame is compressed, the RSV1 bit is set only for the first frame of the message\n\t\t\t\t\tthis._state.compressed = Boolean(rsv1Bit);\n\t\t\t\t}\n\t\t\t\tthis._state.firstFrameOfMessage = Boolean(finBit);\n\t\t\t\tthis._state.mask = 0;\n\t\t\t\tthis._state.opcode = opcode;\n\n\t\t\t\tthis.traceSocketEvent(\n\t\t\t\t\tSocketDiagnosticsEventType.WebSocketNodeSocketPeekedHeader,\n\t\t\t\t\t{\n\t\t\t\t\t\theaderSize: this._state.readLen,\n\t\t\t\t\t\tcompressed: this._state.compressed,\n\t\t\t\t\t\tfin: this._state.fin,\n\t\t\t\t\t\topcode: this._state.opcode,\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t} else if (this._state.state === ReadState.ReadHeader) {\n\t\t\t\t// read entire header\n\t\t\t\tconst header = this._incomingData.read(this._state.readLen);\n\t\t\t\tconst secondByte = header.readUInt8(1);\n\t\t\t\tconst hasMask = (secondByte & 0b10000000) >>> 7;\n\t\t\t\tlet len = secondByte & 0b01111111;\n\n\t\t\t\tlet offset = 1;\n\t\t\t\tif (len === 126) {\n\t\t\t\t\tlen =\n\t\t\t\t\t\theader.readUInt8(++offset) * 2 ** 8 +\n\t\t\t\t\t\theader.readUInt8(++offset);\n\t\t\t\t} else if (len === 127) {\n\t\t\t\t\tlen =\n\t\t\t\t\t\theader.readUInt8(++offset) * 0 +\n\t\t\t\t\t\theader.readUInt8(++offset) * 0 +\n\t\t\t\t\t\theader.readUInt8(++offset) * 0 +\n\t\t\t\t\t\theader.readUInt8(++offset) * 0 +\n\t\t\t\t\t\theader.readUInt8(++offset) * 2 ** 24 +\n\t\t\t\t\t\theader.readUInt8(++offset) * 2 ** 16 +\n\t\t\t\t\t\theader.readUInt8(++offset) * 2 ** 8 +\n\t\t\t\t\t\theader.readUInt8(++offset);\n\t\t\t\t}\n\n\t\t\t\tlet mask = 0;\n\t\t\t\tif (hasMask) {\n\t\t\t\t\tmask =\n\t\t\t\t\t\theader.readUInt8(++offset) * 2 ** 24 +\n\t\t\t\t\t\theader.readUInt8(++offset) * 2 ** 16 +\n\t\t\t\t\t\theader.readUInt8(++offset) * 2 ** 8 +\n\t\t\t\t\t\theader.readUInt8(++offset);\n\t\t\t\t}\n\n\t\t\t\tthis._state.state = ReadState.ReadBody;\n\t\t\t\tthis._state.readLen = len;\n\t\t\t\tthis._state.mask = mask;\n\n\t\t\t\tthis.traceSocketEvent(\n\t\t\t\t\tSocketDiagnosticsEventType.WebSocketNodeSocketPeekedHeader,\n\t\t\t\t\t{\n\t\t\t\t\t\tbodySize: this._state.readLen,\n\t\t\t\t\t\tcompressed: this._state.compressed,\n\t\t\t\t\t\tfin: this._state.fin,\n\t\t\t\t\t\tmask: this._state.mask,\n\t\t\t\t\t\topcode: this._state.opcode,\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t} else if (this._state.state === ReadState.ReadBody) {\n\t\t\t\t// read body\n\n\t\t\t\tconst body = this._incomingData.read(this._state.readLen);\n\t\t\t\tthis.traceSocketEvent(\n\t\t\t\t\tSocketDiagnosticsEventType.WebSocketNodeSocketReadData,\n\t\t\t\t\tbody,\n\t\t\t\t);\n\n\t\t\t\tunmask(body, this._state.mask);\n\t\t\t\tthis.traceSocketEvent(\n\t\t\t\t\tSocketDiagnosticsEventType.WebSocketNodeSocketUnmaskedData,\n\t\t\t\t\tbody,\n\t\t\t\t);\n\n\t\t\t\tthis._state.state = ReadState.PeekHeader;\n\t\t\t\tthis._state.readLen = Constants.MinHeaderByteSize;\n\t\t\t\tthis._state.mask = 0;\n\n\t\t\t\tif (\n\t\t\t\t\tthis._state.opcode <=\n\t\t\t\t\t0x02 /* Continuation frame or Text frame or binary frame */\n\t\t\t\t) {\n\t\t\t\t\tthis._flowManager.acceptFrame(\n\t\t\t\t\t\tbody,\n\t\t\t\t\t\tthis._state.compressed,\n\t\t\t\t\t\t!!this._state.fin,\n\t\t\t\t\t);\n\t\t\t\t} else if (this._state.opcode === 0x09 /* Ping frame */) {\n\t\t\t\t\t// Ping frames could be send by some browsers e.g. Firefox\n\t\t\t\t\tthis._flowManager.writeMessage(body, {\n\t\t\t\t\t\tcompressed: false,\n\t\t\t\t\t\topcode: 0x0a /* Pong frame */,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic async drain(): Promise<void> {\n\t\tthis.traceSocketEvent(\n\t\t\tSocketDiagnosticsEventType.WebSocketNodeSocketDrainBegin,\n\t\t);\n\t\tif (this._flowManager.isProcessingWriteQueue()) {\n\t\t\tawait Event.toPromise(\n\t\t\t\tthis._flowManager.onDidFinishProcessingWriteQueue,\n\t\t\t);\n\t\t}\n\t\tawait this.socket.drain();\n\t\tthis.traceSocketEvent(\n\t\t\tSocketDiagnosticsEventType.WebSocketNodeSocketDrainEnd,\n\t\t);\n\t}\n}\n\nclass WebSocketFlowManager extends Disposable {\n\tprivate readonly _onError = this._register(new Emitter<Error>());\n\tpublic readonly onError = this._onError.event;\n\n\tprivate readonly _zlibInflateStream: ZlibInflateStream | null;\n\tprivate readonly _zlibDeflateStream: ZlibDeflateStream | null;\n\tprivate readonly _writeQueue: { data: VSBuffer; options: FrameOptions }[] =\n\t\t[];\n\tprivate readonly _readQueue: {\n\t\tdata: VSBuffer;\n\t\tisCompressed: boolean;\n\t\tisLastFrameOfMessage: boolean;\n\t}[] = [];\n\n\tprivate readonly _onDidFinishProcessingReadQueue = this._register(\n\t\tnew Emitter<void>(),\n\t);\n\tpublic readonly onDidFinishProcessingReadQueue =\n\t\tthis._onDidFinishProcessingReadQueue.event;\n\n\tprivate readonly _onDidFinishProcessingWriteQueue = this._register(\n\t\tnew Emitter<void>(),\n\t);\n\tpublic readonly onDidFinishProcessingWriteQueue =\n\t\tthis._onDidFinishProcessingWriteQueue.event;\n\n\tpublic get permessageDeflate(): boolean {\n\t\treturn Boolean(this._zlibInflateStream && this._zlibDeflateStream);\n\t}\n\n\tpublic get recordedInflateBytes(): VSBuffer {\n\t\tif (this._zlibInflateStream) {\n\t\t\treturn this._zlibInflateStream.recordedInflateBytes;\n\t\t}\n\t\treturn VSBuffer.alloc(0);\n\t}\n\n\tconstructor(\n\t\tprivate readonly _tracer: ISocketTracer,\n\t\tpermessageDeflate: boolean,\n\t\tinflateBytes: VSBuffer | null,\n\t\trecordInflateBytes: boolean,\n\t\tprivate readonly _onData: Emitter<VSBuffer>,\n\t\tprivate readonly _writeFn: (\n\t\t\tdata: VSBuffer,\n\t\t\toptions: FrameOptions,\n\t\t) => void,\n\t) {\n\t\tsuper();\n\t\tif (permessageDeflate) {\n\t\t\t// See https://tools.ietf.org/html/rfc7692#page-16\n\t\t\t// To simplify our logic, we don't negotiate the window size\n\t\t\t// and simply dedicate (2^15) / 32kb per web socket\n\t\t\tthis._zlibInflateStream = this._register(\n\t\t\t\tnew ZlibInflateStream(\n\t\t\t\t\tthis._tracer,\n\t\t\t\t\trecordInflateBytes,\n\t\t\t\t\tinflateBytes,\n\t\t\t\t\t{ windowBits: 15 },\n\t\t\t\t),\n\t\t\t);\n\t\t\tthis._zlibDeflateStream = this._register(\n\t\t\t\tnew ZlibDeflateStream(this._tracer, { windowBits: 15 }),\n\t\t\t);\n\t\t\tthis._register(\n\t\t\t\tthis._zlibInflateStream.onError((err) =>\n\t\t\t\t\tthis._onError.fire(err),\n\t\t\t\t),\n\t\t\t);\n\t\t\tthis._register(\n\t\t\t\tthis._zlibDeflateStream.onError((err) =>\n\t\t\t\t\tthis._onError.fire(err),\n\t\t\t\t),\n\t\t\t);\n\t\t} else {\n\t\t\tthis._zlibInflateStream = null;\n\t\t\tthis._zlibDeflateStream = null;\n\t\t}\n\t}\n\n\tpublic writeMessage(data: VSBuffer, options: FrameOptions): void {\n\t\tthis._writeQueue.push({ data, options });\n\t\tthis._processWriteQueue();\n\t}\n\n\tprivate _isProcessingWriteQueue = false;\n\tprivate async _processWriteQueue(): Promise<void> {\n\t\tif (this._isProcessingWriteQueue) {\n\t\t\treturn;\n\t\t}\n\t\tthis._isProcessingWriteQueue = true;\n\t\twhile (this._writeQueue.length > 0) {\n\t\t\tconst { data, options } = this._writeQueue.shift()!;\n\t\t\tif (this._zlibDeflateStream && options.compressed) {\n\t\t\t\tconst compressedData = await this._deflateMessage(\n\t\t\t\t\tthis._zlibDeflateStream,\n\t\t\t\t\tdata,\n\t\t\t\t);\n\t\t\t\tthis._writeFn(compressedData, options);\n\t\t\t} else {\n\t\t\t\tthis._writeFn(data, { ...options, compressed: false });\n\t\t\t}\n\t\t}\n\t\tthis._isProcessingWriteQueue = false;\n\t\tthis._onDidFinishProcessingWriteQueue.fire();\n\t}\n\n\tpublic isProcessingWriteQueue(): boolean {\n\t\treturn this._isProcessingWriteQueue;\n\t}\n\n\t/**\n\t * Subsequent calls should wait for the previous `_deflateBuffer` call to complete.\n\t */\n\tprivate _deflateMessage(\n\t\tzlibDeflateStream: ZlibDeflateStream,\n\t\tbuffer: VSBuffer,\n\t): Promise<VSBuffer> {\n\t\treturn new Promise<VSBuffer>((resolve, reject) => {\n\t\t\tzlibDeflateStream.write(buffer);\n\t\t\tzlibDeflateStream.flush((data) => resolve(data));\n\t\t});\n\t}\n\n\tpublic acceptFrame(\n\t\tdata: VSBuffer,\n\t\tisCompressed: boolean,\n\t\tisLastFrameOfMessage: boolean,\n\t): void {\n\t\tthis._readQueue.push({ data, isCompressed, isLastFrameOfMessage });\n\t\tthis._processReadQueue();\n\t}\n\n\tprivate _isProcessingReadQueue = false;\n\tprivate async _processReadQueue(): Promise<void> {\n\t\tif (this._isProcessingReadQueue) {\n\t\t\treturn;\n\t\t}\n\t\tthis._isProcessingReadQueue = true;\n\t\twhile (this._readQueue.length > 0) {\n\t\t\tconst frameInfo = this._readQueue.shift()!;\n\t\t\tif (this._zlibInflateStream && frameInfo.isCompressed) {\n\t\t\t\t// See https://datatracker.ietf.org/doc/html/rfc7692#section-9.2\n\t\t\t\t// Even if permessageDeflate is negotiated, it is possible\n\t\t\t\t// that the other side might decide to send uncompressed messages\n\t\t\t\t// So only decompress messages that have the RSV 1 bit set\n\t\t\t\tconst data = await this._inflateFrame(\n\t\t\t\t\tthis._zlibInflateStream,\n\t\t\t\t\tframeInfo.data,\n\t\t\t\t\tframeInfo.isLastFrameOfMessage,\n\t\t\t\t);\n\t\t\t\tthis._onData.fire(data);\n\t\t\t} else {\n\t\t\t\tthis._onData.fire(frameInfo.data);\n\t\t\t}\n\t\t}\n\t\tthis._isProcessingReadQueue = false;\n\t\tthis._onDidFinishProcessingReadQueue.fire();\n\t}\n\n\tpublic isProcessingReadQueue(): boolean {\n\t\treturn this._isProcessingReadQueue;\n\t}\n\n\t/**\n\t * Subsequent calls should wait for the previous `transformRead` call to complete.\n\t */\n\tprivate _inflateFrame(\n\t\tzlibInflateStream: ZlibInflateStream,\n\t\tbuffer: VSBuffer,\n\t\tisLastFrameOfMessage: boolean,\n\t): Promise<VSBuffer> {\n\t\treturn new Promise<VSBuffer>((resolve, reject) => {\n\t\t\t// See https://tools.ietf.org/html/rfc7692#section-7.2.2\n\t\t\tzlibInflateStream.write(buffer);\n\t\t\tif (isLastFrameOfMessage) {\n\t\t\t\tzlibInflateStream.write(\n\t\t\t\t\tVSBuffer.fromByteArray([0x00, 0x00, 0xff, 0xff]),\n\t\t\t\t);\n\t\t\t}\n\t\t\tzlibInflateStream.flush((data) => resolve(data));\n\t\t});\n\t}\n}\n\nclass ZlibInflateStream extends Disposable {\n\tprivate readonly _onError = this._register(new Emitter<Error>());\n\tpublic readonly onError = this._onError.event;\n\n\tprivate readonly _zlibInflate: InflateRaw;\n\tprivate readonly _recordedInflateBytes: VSBuffer[] = [];\n\tprivate readonly _pendingInflateData: VSBuffer[] = [];\n\n\tpublic get recordedInflateBytes(): VSBuffer {\n\t\tif (this._recordInflateBytes) {\n\t\t\treturn VSBuffer.concat(this._recordedInflateBytes);\n\t\t}\n\t\treturn VSBuffer.alloc(0);\n\t}\n\n\tconstructor(\n\t\tprivate readonly _tracer: ISocketTracer,\n\t\tprivate readonly _recordInflateBytes: boolean,\n\t\tinflateBytes: VSBuffer | null,\n\t\toptions: ZlibOptions,\n\t) {\n\t\tsuper();\n\t\tthis._zlibInflate = createInflateRaw(options);\n\t\tthis._zlibInflate.on(\"error\", (err) => {\n\t\t\tthis._tracer.traceSocketEvent(\n\t\t\t\tSocketDiagnosticsEventType.zlibInflateError,\n\t\t\t\t{ message: err?.message, code: (<any>err)?.code },\n\t\t\t);\n\t\t\tthis._onError.fire(err);\n\t\t});\n\t\tthis._zlibInflate.on(\"data\", (data: Buffer) => {\n\t\t\tthis._tracer.traceSocketEvent(\n\t\t\t\tSocketDiagnosticsEventType.zlibInflateData,\n\t\t\t\tdata,\n\t\t\t);\n\t\t\tthis._pendingInflateData.push(VSBuffer.wrap(data));\n\t\t});\n\t\tif (inflateBytes) {\n\t\t\tthis._tracer.traceSocketEvent(\n\t\t\t\tSocketDiagnosticsEventType.zlibInflateInitialWrite,\n\t\t\t\tinflateBytes.buffer,\n\t\t\t);\n\t\t\tthis._zlibInflate.write(inflateBytes.buffer);\n\t\t\tthis._zlibInflate.flush(() => {\n\t\t\t\tthis._tracer.traceSocketEvent(\n\t\t\t\t\tSocketDiagnosticsEventType.zlibInflateInitialFlushFired,\n\t\t\t\t);\n\t\t\t\tthis._pendingInflateData.length = 0;\n\t\t\t});\n\t\t}\n\t}\n\n\tpublic write(buffer: VSBuffer): void {\n\t\tif (this._recordInflateBytes) {\n\t\t\tthis._recordedInflateBytes.push(buffer.clone());\n\t\t}\n\t\tthis._tracer.traceSocketEvent(\n\t\t\tSocketDiagnosticsEventType.zlibInflateWrite,\n\t\t\tbuffer,\n\t\t);\n\t\tthis._zlibInflate.write(buffer.buffer);\n\t}\n\n\tpublic flush(callback: (data: VSBuffer) => void): void {\n\t\tthis._zlibInflate.flush(() => {\n\t\t\tthis._tracer.traceSocketEvent(\n\t\t\t\tSocketDiagnosticsEventType.zlibInflateFlushFired,\n\t\t\t);\n\t\t\tconst data = VSBuffer.concat(this._pendingInflateData);\n\t\t\tthis._pendingInflateData.length = 0;\n\t\t\tcallback(data);\n\t\t});\n\t}\n}\n\nclass ZlibDeflateStream extends Disposable {\n\tprivate readonly _onError = this._register(new Emitter<Error>());\n\tpublic readonly onError = this._onError.event;\n\n\tprivate readonly _zlibDeflate: DeflateRaw;\n\tprivate readonly _pendingDeflateData: VSBuffer[] = [];\n\n\tconstructor(\n\t\tprivate readonly _tracer: ISocketTracer,\n\t\toptions: ZlibOptions,\n\t) {\n\t\tsuper();\n\n\t\tthis._zlibDeflate = createDeflateRaw({\n\t\t\twindowBits: 15,\n\t\t});\n\t\tthis._zlibDeflate.on(\"error\", (err) => {\n\t\t\tthis._tracer.traceSocketEvent(\n\t\t\t\tSocketDiagnosticsEventType.zlibDeflateError,\n\t\t\t\t{ message: err?.message, code: (<any>err)?.code },\n\t\t\t);\n\t\t\tthis._onError.fire(err);\n\t\t});\n\t\tthis._zlibDeflate.on(\"data\", (data: Buffer) => {\n\t\t\tthis._tracer.traceSocketEvent(\n\t\t\t\tSocketDiagnosticsEventType.zlibDeflateData,\n\t\t\t\tdata,\n\t\t\t);\n\t\t\tthis._pendingDeflateData.push(VSBuffer.wrap(data));\n\t\t});\n\t}\n\n\tpublic write(buffer: VSBuffer): void {\n\t\tthis._tracer.traceSocketEvent(\n\t\t\tSocketDiagnosticsEventType.zlibDeflateWrite,\n\t\t\tbuffer.buffer,\n\t\t);\n\t\tthis._zlibDeflate.write(<Buffer>buffer.buffer);\n\t}\n\n\tpublic flush(callback: (data: VSBuffer) => void): void {\n\t\t// See https://zlib.net/manual.html#Constants\n\t\tthis._zlibDeflate.flush(/*Z_SYNC_FLUSH*/ 2, () => {\n\t\t\tthis._tracer.traceSocketEvent(\n\t\t\t\tSocketDiagnosticsEventType.zlibDeflateFlushFired,\n\t\t\t);\n\n\t\t\tlet data = VSBuffer.concat(this._pendingDeflateData);\n\t\t\tthis._pendingDeflateData.length = 0;\n\n\t\t\t// See https://tools.ietf.org/html/rfc7692#section-7.2.1\n\t\t\tdata = data.slice(0, data.byteLength - 4);\n\n\t\t\tcallback(data);\n\t\t});\n\t}\n}\n\nfunction unmask(buffer: VSBuffer, mask: number): void {\n\tif (mask === 0) {\n\t\treturn;\n\t}\n\tconst cnt = buffer.byteLength >>> 2;\n\tfor (let i = 0; i < cnt; i++) {\n\t\tconst v = buffer.readUInt32BE(i * 4);\n\t\tbuffer.writeUInt32BE(v ^ mask, i * 4);\n\t}\n\tconst offset = cnt * 4;\n\tconst bytesLeft = buffer.byteLength - offset;\n\tconst m3 = (mask >>> 24) & 0b11111111;\n\tconst m2 = (mask >>> 16) & 0b11111111;\n\tconst m1 = (mask >>> 8) & 0b11111111;\n\tif (bytesLeft >= 1) {\n\t\tbuffer.writeUInt8(buffer.readUInt8(offset) ^ m3, offset);\n\t}\n\tif (bytesLeft >= 2) {\n\t\tbuffer.writeUInt8(buffer.readUInt8(offset + 1) ^ m2, offset + 1);\n\t}\n\tif (bytesLeft >= 3) {\n\t\tbuffer.writeUInt8(buffer.readUInt8(offset + 2) ^ m1, offset + 2);\n\t}\n}\n\n// Read this before there's any chance it is overwritten\n// Related to https://github.com/microsoft/vscode/issues/30624\nexport const XDG_RUNTIME_DIR = <string | undefined>(\n\tprocess.env[\"XDG_RUNTIME_DIR\"]\n);\n\nconst safeIpcPathLengths: { [platform: number]: number } = {\n\t[Platform.Linux]: 107,\n\t[Platform.Mac]: 103,\n};\n\nexport function createRandomIPCHandle(): string {\n\tconst randomSuffix = generateUuid();\n\n\t// Windows: use named pipe\n\tif (process.platform === \"win32\") {\n\t\treturn `\\\\\\\\.\\\\pipe\\\\vscode-ipc-${randomSuffix}-sock`;\n\t}\n\n\t// Mac & Unix: Use socket file\n\t// Unix: Prefer XDG_RUNTIME_DIR over user data path\n\tconst basePath =\n\t\tprocess.platform !== \"darwin\" && XDG_RUNTIME_DIR\n\t\t\t? XDG_RUNTIME_DIR\n\t\t\t: tmpdir();\n\tconst result = join(basePath, `vscode-ipc-${randomSuffix}.sock`);\n\n\t// Validate length\n\tvalidateIPCHandleLength(result);\n\n\treturn result;\n}\n\nexport function createStaticIPCHandle(\n\tdirectoryPath: string,\n\ttype: string,\n\tversion: string,\n): string {\n\tconst scope = createHash(\"sha256\").update(directoryPath).digest(\"hex\");\n\tconst scopeForSocket = scope.substr(0, 8);\n\n\t// Windows: use named pipe\n\tif (process.platform === \"win32\") {\n\t\treturn `\\\\\\\\.\\\\pipe\\\\${scopeForSocket}-${version}-${type}-sock`;\n\t}\n\n\t// Mac & Unix: Use socket file\n\t// Unix: Prefer XDG_RUNTIME_DIR over user data path, unless portable\n\t// Trim the version and type values for the socket to prevent too large\n\t// file names causing issues: https://unix.stackexchange.com/q/367008\n\n\tconst versionForSocket = version.substr(0, 4);\n\tconst typeForSocket = type.substr(0, 6);\n\n\tlet result: string;\n\tif (\n\t\tprocess.platform !== \"darwin\" &&\n\t\tXDG_RUNTIME_DIR &&\n\t\t!process.env[\"VSCODE_PORTABLE\"]\n\t) {\n\t\tresult = join(\n\t\t\tXDG_RUNTIME_DIR,\n\t\t\t`vscode-${scopeForSocket}-${versionForSocket}-${typeForSocket}.sock`,\n\t\t);\n\t} else {\n\t\tresult = join(\n\t\t\tdirectoryPath,\n\t\t\t`${versionForSocket}-${typeForSocket}.sock`,\n\t\t);\n\t}\n\n\t// Validate length\n\tvalidateIPCHandleLength(result);\n\n\treturn result;\n}\n\nfunction validateIPCHandleLength(handle: string): void {\n\tconst limit = safeIpcPathLengths[platform];\n\tif (typeof limit === \"number\" && handle.length >= limit) {\n\t\t// https://nodejs.org/api/net.html#net_identifying_paths_for_ipc_connections\n\t\tconsole.warn(\n\t\t\t`WARNING: IPC handle \"${handle}\" is longer than ${limit} chars, try a shorter --user-data-dir`,\n\t\t);\n\t}\n}\n\nexport class Server extends IPCServer {\n\tprivate static toClientConnectionEvent(\n\t\tserver: NetServer,\n\t): Event<ClientConnectionEvent> {\n\t\tconst onConnection = Event.fromNodeEventEmitter<Socket>(\n\t\t\tserver,\n\t\t\t\"connection\",\n\t\t);\n\n\t\treturn Event.map(onConnection, (socket) => ({\n\t\t\tprotocol: new Protocol(\n\t\t\t\tnew NodeSocket(socket, \"ipc-server-connection\"),\n\t\t\t),\n\t\t\tonDidClientDisconnect: Event.once(\n\t\t\t\tEvent.fromNodeEventEmitter<void>(socket, \"close\"),\n\t\t\t),\n\t\t}));\n\t}\n\n\tprivate server: NetServer | null;\n\n\tconstructor(server: NetServer) {\n\t\tsuper(Server.toClientConnectionEvent(server));\n\t\tthis.server = server;\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\t\tif (this.server) {\n\t\t\tthis.server.close();\n\t\t\tthis.server = null;\n\t\t}\n\t}\n}\n\nexport function serve(port: number): Promise<Server>;\nexport function serve(namedPipe: string): Promise<Server>;\nexport function serve(hook: any): Promise<Server> {\n\treturn new Promise<Server>((c, e) => {\n\t\tconst server = createServer();\n\n\t\tserver.on(\"error\", e);\n\t\tserver.listen(hook, () => {\n\t\t\tserver.removeListener(\"error\", e);\n\t\t\tc(new Server(server));\n\t\t});\n\t});\n}\n\nexport function connect(\n\toptions: { host: string; port: number },\n\tclientId: string,\n): Promise<Client>;\nexport function connect(port: number, clientId: string): Promise<Client>;\nexport function connect(namedPipe: string, clientId: string): Promise<Client>;\nexport function connect(hook: any, clientId: string): Promise<Client> {\n\treturn new Promise<Client>((c, e) => {\n\t\tconst socket = createConnection(hook, () => {\n\t\t\tsocket.removeListener(\"error\", e);\n\t\t\tc(\n\t\t\t\tClient.fromSocket(\n\t\t\t\t\tnew NodeSocket(socket, `ipc-client${clientId}`),\n\t\t\t\t\tclientId,\n\t\t\t\t),\n\t\t\t);\n\t\t});\n\n\t\tsocket.once(\"error\", e);\n\t});\n}\n"],
  "mappings": "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",
  "names": ["Constants", "ReadState"]
}
