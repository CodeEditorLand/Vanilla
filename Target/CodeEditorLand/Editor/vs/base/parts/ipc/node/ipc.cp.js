import{fork as g}from"child_process";import{createCancelablePromise as C,Delayer as b}from"../../../common/async.js";import{VSBuffer as f}from"../../../common/buffer.js";import{CancellationToken as y}from"../../../common/cancellation.js";import{isRemoteConsoleLog as D,log as x}from"../../../common/console.js";import*as P from"../../../common/errors.js";import{Emitter as d,Event as p}from"../../../common/event.js";import{dispose as E,toDisposable as I}from"../../../common/lifecycle.js";import{deepClone as T}from"../../../common/objects.js";import{createQueuedSender as R}from"../../../node/processes.js";import{removeDangerousEnvVariables as w}from"../../../common/processes.js";import{ChannelClient as q,ChannelServer as S}from"../common/ipc.js";class H extends S{constructor(t){super({send:e=>{try{process.send?.(e.buffer.toString("base64"))}catch{}},onMessage:p.fromNodeEventEmitter(process,"message",e=>f.wrap(Buffer.from(e,"base64")))},t),process.once("disconnect",()=>this.dispose())}}class J{constructor(t,e){this.modulePath=t;this.options=e;const i=e&&e.timeout?e.timeout:6e4;this.disposeDelayer=new b(i),this.child=null,this._client=null}disposeDelayer;activeRequests=new Set;child;_client;channels=new Map;_onDidProcessExit=new d;onDidProcessExit=this._onDidProcessExit.event;getChannel(t){const e=this;return{call(i,n,r){return e.requestPromise(t,i,n,r)},listen(i,n){return e.requestEvent(t,i,n)}}}requestPromise(t,e,i,n=y.None){if(!this.disposeDelayer)return Promise.reject(new Error("disposed"));if(n.isCancellationRequested)return Promise.reject(P.canceled());this.disposeDelayer.cancel();const r=this.getCachedChannel(t),o=C(c=>r.call(e,i,c)),a=n.onCancellationRequested(()=>o.cancel()),l=I(()=>o.cancel());return this.activeRequests.add(l),o.finally(()=>{a.dispose(),this.activeRequests.delete(l),this.activeRequests.size===0&&this.disposeDelayer&&this.disposeDelayer.trigger(()=>this.disposeClient())}),o}requestEvent(t,e,i){if(!this.disposeDelayer)return p.None;this.disposeDelayer.cancel();let n;const r=new d({onWillAddFirstListener:()=>{n=this.getCachedChannel(t).listen(e,i)(r.fire,r),this.activeRequests.add(n)},onDidRemoveLastListener:()=>{this.activeRequests.delete(n),n.dispose(),this.activeRequests.size===0&&this.disposeDelayer&&this.disposeDelayer.trigger(()=>this.disposeClient())}});return r.event}get client(){if(!this._client){const t=this.options&&this.options.args?this.options.args:[],e=Object.create(null);e.env={...T(process.env),VSCODE_PARENT_PID:String(process.pid)},this.options&&this.options.env&&(e.env={...e.env,...this.options.env}),this.options&&this.options.freshExecArgv&&(e.execArgv=[]),this.options&&typeof this.options.debug=="number"&&(e.execArgv=["--nolazy","--inspect="+this.options.debug]),this.options&&typeof this.options.debugBrk=="number"&&(e.execArgv=["--nolazy","--inspect-brk="+this.options.debugBrk]),e.execArgv===void 0&&(e.execArgv=process.execArgv.filter(s=>!/^--inspect(-brk)?=/.test(s)).filter(s=>!s.startsWith("--vscode-"))),w(e.env),this.child=g(this.modulePath,t,e);const i=new d,r=p.fromNodeEventEmitter(this.child,"message",s=>s)(s=>{if(D(s)){x(s,`IPC Library: ${this.options.serverName}`);return}i.fire(f.wrap(Buffer.from(s,"base64")))}),o=this.options.useQueue?R(this.child):this.child,a=s=>this.child&&this.child.connected&&o.send(s.buffer.toString("base64")),l=i.event,c={send:a,onMessage:l};this._client=new q(c);const u=()=>this.disposeClient();process.once("exit",u),this.child.on("error",s=>console.warn('IPC "'+this.options.serverName+'" errored with '+s)),this.child.on("exit",(s,h)=>{process.removeListener("exit",u),r.dispose(),this.activeRequests.forEach(m=>E(m)),this.activeRequests.clear(),s!==0&&h!=="SIGTERM"&&console.warn('IPC "'+this.options.serverName+'" crashed with exit code '+s+" and signal "+h),this.disposeDelayer?.cancel(),this.disposeClient(),this._onDidProcessExit.fire({code:s,signal:h})})}return this._client}getCachedChannel(t){let e=this.channels.get(t);return e||(e=this.client.getChannel(t),this.channels.set(t,e)),e}disposeClient(){this._client&&(this.child&&(this.child.kill(),this.child=null),this._client=null,this.channels.clear())}dispose(){this._onDidProcessExit.dispose(),this.disposeDelayer?.cancel(),this.disposeDelayer=void 0,this.disposeClient(),this.activeRequests.clear()}}export{J as Client,H as Server};
