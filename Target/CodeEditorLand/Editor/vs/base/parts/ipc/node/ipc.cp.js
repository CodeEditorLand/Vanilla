import{fork as g}from"child_process";import{Delayer as C,createCancelablePromise as y}from"../../../common/async.js";import{VSBuffer as f}from"../../../common/buffer.js";import{CancellationToken as b}from"../../../common/cancellation.js";import{isRemoteConsoleLog as D,log as x}from"../../../common/console.js";import*as P from"../../../common/errors.js";import{Emitter as h,Event as p}from"../../../common/event.js";import{dispose as E,toDisposable as I}from"../../../common/lifecycle.js";import{deepClone as T}from"../../../common/objects.js";import{removeDangerousEnvVariables as R}from"../../../common/processes.js";import{createQueuedSender as w}from"../../../node/processes.js";import{ChannelClient as q,ChannelServer as S}from"../common/ipc.js";class F extends S{constructor(s){super({send:e=>{try{process.send?.(e.buffer.toString("base64"))}catch{}},onMessage:p.fromNodeEventEmitter(process,"message",e=>f.wrap(Buffer.from(e,"base64")))},s),process.once("disconnect",()=>this.dispose())}}class Q{constructor(s,e){this.modulePath=s;this.options=e;const i=e&&e.timeout?e.timeout:6e4;this.disposeDelayer=new C(i),this.child=null,this._client=null}disposeDelayer;activeRequests=new Set;child;_client;channels=new Map;_onDidProcessExit=new h;onDidProcessExit=this._onDidProcessExit.event;getChannel(s){const e=this;return{call(i,n,r){return e.requestPromise(s,i,n,r)},listen(i,n){return e.requestEvent(s,i,n)}}}requestPromise(s,e,i,n=b.None){if(!this.disposeDelayer)return Promise.reject(new Error("disposed"));if(n.isCancellationRequested)return Promise.reject(P.canceled());this.disposeDelayer.cancel();const r=this.getCachedChannel(s),o=y(c=>r.call(e,i,c)),a=n.onCancellationRequested(()=>o.cancel()),l=I(()=>o.cancel());return this.activeRequests.add(l),o.finally(()=>{a.dispose(),this.activeRequests.delete(l),this.activeRequests.size===0&&this.disposeDelayer&&this.disposeDelayer.trigger(()=>this.disposeClient())}),o}requestEvent(s,e,i){if(!this.disposeDelayer)return p.None;this.disposeDelayer.cancel();let n;const r=new h({onWillAddFirstListener:()=>{n=this.getCachedChannel(s).listen(e,i)(r.fire,r),this.activeRequests.add(n)},onDidRemoveLastListener:()=>{this.activeRequests.delete(n),n.dispose(),this.activeRequests.size===0&&this.disposeDelayer&&this.disposeDelayer.trigger(()=>this.disposeClient())}});return r.event}get client(){if(!this._client){const s=this.options&&this.options.args?this.options.args:[],e=Object.create(null);e.env={...T(process.env),VSCODE_PARENT_PID:String(process.pid)},this.options&&this.options.env&&(e.env={...e.env,...this.options.env}),this.options&&this.options.freshExecArgv&&(e.execArgv=[]),this.options&&typeof this.options.debug=="number"&&(e.execArgv=["--nolazy","--inspect="+this.options.debug]),this.options&&typeof this.options.debugBrk=="number"&&(e.execArgv=["--nolazy","--inspect-brk="+this.options.debugBrk]),e.execArgv===void 0&&(e.execArgv=process.execArgv.filter(t=>!/^--inspect(-brk)?=/.test(t)).filter(t=>!t.startsWith("--vscode-"))),R(e.env),this.child=g(this.modulePath,s,e);const i=new h,r=p.fromNodeEventEmitter(this.child,"message",t=>t)(t=>{if(D(t)){x(t,`IPC Library: ${this.options.serverName}`);return}i.fire(f.wrap(Buffer.from(t,"base64")))}),o=this.options.useQueue?w(this.child):this.child,a=t=>this.child&&this.child.connected&&o.send(t.buffer.toString("base64")),l=i.event,c={send:a,onMessage:l};this._client=new q(c);const d=()=>this.disposeClient();process.once("exit",d),this.child.on("error",t=>{}),this.child.on("exit",(t,u)=>{process.removeListener("exit",d),r.dispose(),this.activeRequests.forEach(m=>E(m)),this.activeRequests.clear(),this.disposeDelayer?.cancel(),this.disposeClient(),this._onDidProcessExit.fire({code:t,signal:u})})}return this._client}getCachedChannel(s){let e=this.channels.get(s);return e||(e=this.client.getChannel(s),this.channels.set(s,e)),e}disposeClient(){this._client&&(this.child&&(this.child.kill(),this.child=null),this._client=null,this.channels.clear())}dispose(){this._onDidProcessExit.dispose(),this.disposeDelayer?.cancel(),this.disposeDelayer=void 0,this.disposeClient(),this.activeRequests.clear()}}export{Q as Client,F as Server};
