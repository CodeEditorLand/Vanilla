{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/parts/storage/common/storage.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ThrottledDelayer } from \"../../../common/async.js\";\nimport { Event, PauseableEmitter } from \"../../../common/event.js\";\nimport { Disposable, type IDisposable } from \"../../../common/lifecycle.js\";\nimport { parse, stringify } from \"../../../common/marshalling.js\";\nimport { isObject, isUndefinedOrNull } from \"../../../common/types.js\";\n\nexport enum StorageHint {\n\t// A hint to the storage that the storage\n\t// does not exist on disk yet. This allows\n\t// the storage library to improve startup\n\t// time by not checking the storage for data.\n\tSTORAGE_DOES_NOT_EXIST = 0,\n\n\t// A hint to the storage that the storage\n\t// is backed by an in-memory storage.\n\tSTORAGE_IN_MEMORY = 1,\n}\n\nexport interface IStorageOptions {\n\treadonly hint?: StorageHint;\n}\n\nexport interface IUpdateRequest {\n\treadonly insert?: Map<string, string>;\n\treadonly delete?: Set<string>;\n}\n\nexport interface IStorageItemsChangeEvent {\n\treadonly changed?: Map<string, string>;\n\treadonly deleted?: Set<string>;\n}\n\nexport function isStorageItemsChangeEvent(\n\tthing: unknown,\n): thing is IStorageItemsChangeEvent {\n\tconst candidate = thing as IStorageItemsChangeEvent | undefined;\n\n\treturn (\n\t\tcandidate?.changed instanceof Map || candidate?.deleted instanceof Set\n\t);\n}\n\nexport interface IStorageDatabase {\n\treadonly onDidChangeItemsExternal: Event<IStorageItemsChangeEvent>;\n\n\tgetItems(): Promise<Map<string, string>>;\n\tupdateItems(request: IUpdateRequest): Promise<void>;\n\n\toptimize(): Promise<void>;\n\n\tclose(recovery?: () => Map<string, string>): Promise<void>;\n}\n\nexport interface IStorageChangeEvent {\n\t/**\n\t * The `key` of the storage entry that was changed\n\t * or was removed.\n\t */\n\treadonly key: string;\n\n\t/**\n\t * A hint how the storage change event was triggered. If\n\t * `true`, the storage change was triggered by an external\n\t * source, such as:\n\t * - another process (for example another window)\n\t * - operations such as settings sync or profiles change\n\t */\n\treadonly external?: boolean;\n}\n\nexport type StorageValue =\n\t| string\n\t| boolean\n\t| number\n\t| undefined\n\t| null\n\t| object;\n\nexport interface IStorage extends IDisposable {\n\treadonly onDidChangeStorage: Event<IStorageChangeEvent>;\n\n\treadonly items: Map<string, string>;\n\treadonly size: number;\n\n\tinit(): Promise<void>;\n\n\tget(key: string, fallbackValue: string): string;\n\tget(key: string, fallbackValue?: string): string | undefined;\n\n\tgetBoolean(key: string, fallbackValue: boolean): boolean;\n\tgetBoolean(key: string, fallbackValue?: boolean): boolean | undefined;\n\n\tgetNumber(key: string, fallbackValue: number): number;\n\tgetNumber(key: string, fallbackValue?: number): number | undefined;\n\n\tgetObject<T extends object>(key: string, fallbackValue: T): T;\n\tgetObject<T extends object>(key: string, fallbackValue?: T): T | undefined;\n\n\tset(key: string, value: StorageValue, external?: boolean): Promise<void>;\n\tdelete(key: string, external?: boolean): Promise<void>;\n\n\tflush(delay?: number): Promise<void>;\n\twhenFlushed(): Promise<void>;\n\n\toptimize(): Promise<void>;\n\n\tclose(): Promise<void>;\n}\n\nexport enum StorageState {\n\tNone = 0,\n\tInitialized = 1,\n\tClosed = 2,\n}\n\nexport class Storage extends Disposable implements IStorage {\n\tprivate static readonly DEFAULT_FLUSH_DELAY = 100;\n\n\tprivate readonly _onDidChangeStorage = this._register(\n\t\tnew PauseableEmitter<IStorageChangeEvent>(),\n\t);\n\treadonly onDidChangeStorage = this._onDidChangeStorage.event;\n\n\tprivate state = StorageState.None;\n\n\tprivate cache = new Map<string, string>();\n\n\tprivate readonly flushDelayer = this._register(\n\t\tnew ThrottledDelayer<void>(Storage.DEFAULT_FLUSH_DELAY),\n\t);\n\n\tprivate pendingDeletes = new Set<string>();\n\tprivate pendingInserts = new Map<string, string>();\n\n\tprivate pendingClose: Promise<void> | undefined = undefined;\n\n\tprivate readonly whenFlushedCallbacks: Function[] = [];\n\n\tconstructor(\n\t\tprotected readonly database: IStorageDatabase,\n\t\tprivate readonly options: IStorageOptions = Object.create(null),\n\t) {\n\t\tsuper();\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tthis._register(\n\t\t\tthis.database.onDidChangeItemsExternal((e) =>\n\t\t\t\tthis.onDidChangeItemsExternal(e),\n\t\t\t),\n\t\t);\n\t}\n\n\tprivate onDidChangeItemsExternal(e: IStorageItemsChangeEvent): void {\n\t\tthis._onDidChangeStorage.pause();\n\n\t\ttry {\n\t\t\t// items that change external require us to update our\n\t\t\t// caches with the values. we just accept the value and\n\t\t\t// emit an event if there is a change.\n\n\t\t\te.changed?.forEach((value, key) => this.acceptExternal(key, value));\n\t\t\te.deleted?.forEach((key) => this.acceptExternal(key, undefined));\n\t\t} finally {\n\t\t\tthis._onDidChangeStorage.resume();\n\t\t}\n\t}\n\n\tprivate acceptExternal(key: string, value: string | undefined): void {\n\t\tif (this.state === StorageState.Closed) {\n\t\t\treturn; // Return early if we are already closed\n\t\t}\n\n\t\tlet changed = false;\n\n\t\t// Item got removed, check for deletion\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\tchanged = this.cache.delete(key);\n\t\t}\n\n\t\t// Item got updated, check for change\n\t\telse {\n\t\t\tconst currentValue = this.cache.get(key);\n\t\t\tif (currentValue !== value) {\n\t\t\t\tthis.cache.set(key, value);\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\n\t\t// Signal to outside listeners\n\t\tif (changed) {\n\t\t\tthis._onDidChangeStorage.fire({ key, external: true });\n\t\t}\n\t}\n\n\tget items(): Map<string, string> {\n\t\treturn this.cache;\n\t}\n\n\tget size(): number {\n\t\treturn this.cache.size;\n\t}\n\n\tasync init(): Promise<void> {\n\t\tif (this.state !== StorageState.None) {\n\t\t\treturn; // either closed or already initialized\n\t\t}\n\n\t\tthis.state = StorageState.Initialized;\n\n\t\tif (this.options.hint === StorageHint.STORAGE_DOES_NOT_EXIST) {\n\t\t\t// return early if we know the storage file does not exist. this is a performance\n\t\t\t// optimization to not load all items of the underlying storage if we know that\n\t\t\t// there can be no items because the storage does not exist.\n\t\t\treturn;\n\t\t}\n\n\t\tthis.cache = await this.database.getItems();\n\t}\n\n\tget(key: string, fallbackValue: string): string;\n\tget(key: string, fallbackValue?: string): string | undefined;\n\tget(key: string, fallbackValue?: string): string | undefined {\n\t\tconst value = this.cache.get(key);\n\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn fallbackValue;\n\t\t}\n\n\t\treturn value;\n\t}\n\n\tgetBoolean(key: string, fallbackValue: boolean): boolean;\n\tgetBoolean(key: string, fallbackValue?: boolean): boolean | undefined;\n\tgetBoolean(key: string, fallbackValue?: boolean): boolean | undefined {\n\t\tconst value = this.get(key);\n\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn fallbackValue;\n\t\t}\n\n\t\treturn value === \"true\";\n\t}\n\n\tgetNumber(key: string, fallbackValue: number): number;\n\tgetNumber(key: string, fallbackValue?: number): number | undefined;\n\tgetNumber(key: string, fallbackValue?: number): number | undefined {\n\t\tconst value = this.get(key);\n\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn fallbackValue;\n\t\t}\n\n\t\treturn Number.parseInt(value, 10);\n\t}\n\n\tgetObject(key: string, fallbackValue: object): object;\n\tgetObject(\n\t\tkey: string,\n\t\tfallbackValue?: object | undefined,\n\t): object | undefined;\n\tgetObject(key: string, fallbackValue?: object): object | undefined {\n\t\tconst value = this.get(key);\n\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn fallbackValue;\n\t\t}\n\n\t\treturn parse(value);\n\t}\n\n\tasync set(\n\t\tkey: string,\n\t\tvalue: string | boolean | number | null | undefined | object,\n\t\texternal = false,\n\t): Promise<void> {\n\t\tif (this.state === StorageState.Closed) {\n\t\t\treturn; // Return early if we are already closed\n\t\t}\n\n\t\t// We remove the key for undefined/null values\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn this.delete(key, external);\n\t\t}\n\n\t\t// Otherwise, convert to String and store\n\t\tconst valueStr =\n\t\t\tisObject(value) || Array.isArray(value)\n\t\t\t\t? stringify(value)\n\t\t\t\t: String(value);\n\n\t\t// Return early if value already set\n\t\tconst currentValue = this.cache.get(key);\n\t\tif (currentValue === valueStr) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Update in cache and pending\n\t\tthis.cache.set(key, valueStr);\n\t\tthis.pendingInserts.set(key, valueStr);\n\t\tthis.pendingDeletes.delete(key);\n\n\t\t// Event\n\t\tthis._onDidChangeStorage.fire({ key, external });\n\n\t\t// Accumulate work by scheduling after timeout\n\t\treturn this.doFlush();\n\t}\n\n\tasync delete(key: string, external = false): Promise<void> {\n\t\tif (this.state === StorageState.Closed) {\n\t\t\treturn; // Return early if we are already closed\n\t\t}\n\n\t\t// Remove from cache and add to pending\n\t\tconst wasDeleted = this.cache.delete(key);\n\t\tif (!wasDeleted) {\n\t\t\treturn; // Return early if value already deleted\n\t\t}\n\n\t\tif (!this.pendingDeletes.has(key)) {\n\t\t\tthis.pendingDeletes.add(key);\n\t\t}\n\n\t\tthis.pendingInserts.delete(key);\n\n\t\t// Event\n\t\tthis._onDidChangeStorage.fire({ key, external });\n\n\t\t// Accumulate work by scheduling after timeout\n\t\treturn this.doFlush();\n\t}\n\n\tasync optimize(): Promise<void> {\n\t\tif (this.state === StorageState.Closed) {\n\t\t\treturn; // Return early if we are already closed\n\t\t}\n\n\t\t// Await pending data to be flushed to the DB\n\t\t// before attempting to optimize the DB\n\t\tawait this.flush(0);\n\n\t\treturn this.database.optimize();\n\t}\n\n\tasync close(): Promise<void> {\n\t\tif (!this.pendingClose) {\n\t\t\tthis.pendingClose = this.doClose();\n\t\t}\n\n\t\treturn this.pendingClose;\n\t}\n\n\tprivate async doClose(): Promise<void> {\n\t\t// Update state\n\t\tthis.state = StorageState.Closed;\n\n\t\t// Trigger new flush to ensure data is persisted and then close\n\t\t// even if there is an error flushing. We must always ensure\n\t\t// the DB is closed to avoid corruption.\n\t\t//\n\t\t// Recovery: we pass our cache over as recovery option in case\n\t\t// the DB is not healthy.\n\t\ttry {\n\t\t\tawait this.doFlush(0 /* as soon as possible */);\n\t\t} catch (error) {\n\t\t\t// Ignore\n\t\t}\n\n\t\tawait this.database.close(() => this.cache);\n\t}\n\n\tprivate get hasPending() {\n\t\treturn this.pendingInserts.size > 0 || this.pendingDeletes.size > 0;\n\t}\n\n\tprivate async flushPending(): Promise<void> {\n\t\tif (!this.hasPending) {\n\t\t\treturn; // return early if nothing to do\n\t\t}\n\n\t\t// Get pending data\n\t\tconst updateRequest: IUpdateRequest = {\n\t\t\tinsert: this.pendingInserts,\n\t\t\tdelete: this.pendingDeletes,\n\t\t};\n\n\t\t// Reset pending data for next run\n\t\tthis.pendingDeletes = new Set<string>();\n\t\tthis.pendingInserts = new Map<string, string>();\n\n\t\t// Update in storage and release any\n\t\t// waiters we have once done\n\t\treturn this.database.updateItems(updateRequest).finally(() => {\n\t\t\tif (!this.hasPending) {\n\t\t\t\twhile (this.whenFlushedCallbacks.length) {\n\t\t\t\t\tthis.whenFlushedCallbacks.pop()?.();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tasync flush(delay?: number): Promise<void> {\n\t\tif (\n\t\t\tthis.state === StorageState.Closed || // Return early if we are already closed\n\t\t\tthis.pendingClose // return early if nothing to do\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn this.doFlush(delay);\n\t}\n\n\tprivate async doFlush(delay?: number): Promise<void> {\n\t\tif (this.options.hint === StorageHint.STORAGE_IN_MEMORY) {\n\t\t\treturn this.flushPending(); // return early if in-memory\n\t\t}\n\n\t\treturn this.flushDelayer.trigger(() => this.flushPending(), delay);\n\t}\n\n\tasync whenFlushed(): Promise<void> {\n\t\tif (!this.hasPending) {\n\t\t\treturn; // return early if nothing to do\n\t\t}\n\n\t\treturn new Promise((resolve) =>\n\t\t\tthis.whenFlushedCallbacks.push(resolve),\n\t\t);\n\t}\n\n\tisInMemory(): boolean {\n\t\treturn this.options.hint === StorageHint.STORAGE_IN_MEMORY;\n\t}\n}\n\nexport class InMemoryStorageDatabase implements IStorageDatabase {\n\treadonly onDidChangeItemsExternal = Event.None;\n\n\tprivate readonly items = new Map<string, string>();\n\n\tasync getItems(): Promise<Map<string, string>> {\n\t\treturn this.items;\n\t}\n\n\tasync updateItems(request: IUpdateRequest): Promise<void> {\n\t\trequest.insert?.forEach((value, key) => this.items.set(key, value));\n\n\t\trequest.delete?.forEach((key) => this.items.delete(key));\n\t}\n\n\tasync optimize(): Promise<void> {}\n\tasync close(): Promise<void> {}\n}\n"],
  "mappings": "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",
  "names": ["StorageHint", "StorageState"]
}
