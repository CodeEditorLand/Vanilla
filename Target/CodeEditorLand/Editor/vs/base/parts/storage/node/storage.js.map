{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/parts/storage/node/storage.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from \"fs\";\nimport type { Database, Statement } from \"@vscode/sqlite3\";\nimport { timeout } from \"../../../common/async.js\";\nimport { Event } from \"../../../common/event.js\";\nimport { mapToString, setToString } from \"../../../common/map.js\";\nimport { basename } from \"../../../common/path.js\";\nimport { Promises } from \"../../../node/pfs.js\";\nimport type {\n\tIStorageDatabase,\n\tIStorageItemsChangeEvent,\n\tIUpdateRequest,\n} from \"../common/storage.js\";\n\ninterface IDatabaseConnection {\n\treadonly db: Database;\n\treadonly isInMemory: boolean;\n\n\tisErroneous?: boolean;\n\tlastError?: string;\n}\n\nexport interface ISQLiteStorageDatabaseOptions {\n\treadonly logging?: ISQLiteStorageDatabaseLoggingOptions;\n}\n\nexport interface ISQLiteStorageDatabaseLoggingOptions {\n\tlogError?: (error: string | Error) => void;\n\tlogTrace?: (msg: string) => void;\n}\n\nexport class SQLiteStorageDatabase implements IStorageDatabase {\n\tstatic readonly IN_MEMORY_PATH = \":memory:\";\n\n\tget onDidChangeItemsExternal(): Event<IStorageItemsChangeEvent> {\n\t\treturn Event.None;\n\t} // since we are the only client, there can be no external changes\n\n\tprivate static readonly BUSY_OPEN_TIMEOUT = 2000; // timeout in ms to retry when opening DB fails with SQLITE_BUSY\n\tprivate static readonly MAX_HOST_PARAMETERS = 256; // maximum number of parameters within a statement\n\n\tprivate readonly name = basename(this.path);\n\n\tprivate readonly logger = new SQLiteStorageDatabaseLogger(\n\t\tthis.options.logging,\n\t);\n\n\tprivate readonly whenConnected = this.connect(this.path);\n\n\tconstructor(\n\t\tprivate readonly path: string,\n\t\tprivate readonly options: ISQLiteStorageDatabaseOptions = Object.create(\n\t\t\tnull,\n\t\t),\n\t) {}\n\n\tasync getItems(): Promise<Map<string, string>> {\n\t\tconst connection = await this.whenConnected;\n\n\t\tconst items = new Map<string, string>();\n\n\t\tconst rows = await this.all(connection, \"SELECT * FROM ItemTable\");\n\t\trows.forEach((row) => items.set(row.key, row.value));\n\n\t\tif (this.logger.isTracing) {\n\t\t\tthis.logger.trace(\n\t\t\t\t`[storage ${this.name}] getItems(): ${items.size} rows`,\n\t\t\t);\n\t\t}\n\n\t\treturn items;\n\t}\n\n\tasync updateItems(request: IUpdateRequest): Promise<void> {\n\t\tconst connection = await this.whenConnected;\n\n\t\treturn this.doUpdateItems(connection, request);\n\t}\n\n\tprivate doUpdateItems(\n\t\tconnection: IDatabaseConnection,\n\t\trequest: IUpdateRequest,\n\t): Promise<void> {\n\t\tif (this.logger.isTracing) {\n\t\t\tthis.logger.trace(\n\t\t\t\t`[storage ${this.name}] updateItems(): insert(${request.insert ? mapToString(request.insert) : \"0\"}), delete(${request.delete ? setToString(request.delete) : \"0\"})`,\n\t\t\t);\n\t\t}\n\n\t\treturn this.transaction(connection, () => {\n\t\t\tconst toInsert = request.insert;\n\t\t\tconst toDelete = request.delete;\n\n\t\t\t// INSERT\n\t\t\tif (toInsert && toInsert.size > 0) {\n\t\t\t\tconst keysValuesChunks: string[][] = [];\n\t\t\t\tkeysValuesChunks.push([]); // seed with initial empty chunk\n\n\t\t\t\t// Split key/values into chunks of SQLiteStorageDatabase.MAX_HOST_PARAMETERS\n\t\t\t\t// so that we can efficiently run the INSERT with as many HOST parameters as possible\n\t\t\t\tlet currentChunkIndex = 0;\n\t\t\t\ttoInsert.forEach((value, key) => {\n\t\t\t\t\tlet keyValueChunk = keysValuesChunks[currentChunkIndex];\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tkeyValueChunk.length >\n\t\t\t\t\t\tSQLiteStorageDatabase.MAX_HOST_PARAMETERS\n\t\t\t\t\t) {\n\t\t\t\t\t\tcurrentChunkIndex++;\n\t\t\t\t\t\tkeyValueChunk = [];\n\t\t\t\t\t\tkeysValuesChunks.push(keyValueChunk);\n\t\t\t\t\t}\n\n\t\t\t\t\tkeyValueChunk.push(key, value);\n\t\t\t\t});\n\n\t\t\t\tkeysValuesChunks.forEach((keysValuesChunk) => {\n\t\t\t\t\tthis.prepare(\n\t\t\t\t\t\tconnection,\n\t\t\t\t\t\t`INSERT INTO ItemTable VALUES ${new Array(keysValuesChunk.length / 2).fill(\"(?,?)\").join(\",\")}`,\n\t\t\t\t\t\t(stmt) => stmt.run(keysValuesChunk),\n\t\t\t\t\t\t() => {\n\t\t\t\t\t\t\tconst keys: string[] = [];\n\t\t\t\t\t\t\tlet length = 0;\n\t\t\t\t\t\t\ttoInsert.forEach((value, key) => {\n\t\t\t\t\t\t\t\tkeys.push(key);\n\t\t\t\t\t\t\t\tlength += value.length;\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\treturn `Keys: ${keys.join(\", \")} Length: ${length}`;\n\t\t\t\t\t\t},\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// DELETE\n\t\t\tif (toDelete && toDelete.size) {\n\t\t\t\tconst keysChunks: string[][] = [];\n\t\t\t\tkeysChunks.push([]); // seed with initial empty chunk\n\n\t\t\t\t// Split keys into chunks of SQLiteStorageDatabase.MAX_HOST_PARAMETERS\n\t\t\t\t// so that we can efficiently run the DELETE with as many HOST parameters\n\t\t\t\t// as possible\n\t\t\t\tlet currentChunkIndex = 0;\n\t\t\t\ttoDelete.forEach((key) => {\n\t\t\t\t\tlet keyChunk = keysChunks[currentChunkIndex];\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tkeyChunk.length >\n\t\t\t\t\t\tSQLiteStorageDatabase.MAX_HOST_PARAMETERS\n\t\t\t\t\t) {\n\t\t\t\t\t\tcurrentChunkIndex++;\n\t\t\t\t\t\tkeyChunk = [];\n\t\t\t\t\t\tkeysChunks.push(keyChunk);\n\t\t\t\t\t}\n\n\t\t\t\t\tkeyChunk.push(key);\n\t\t\t\t});\n\n\t\t\t\tkeysChunks.forEach((keysChunk) => {\n\t\t\t\t\tthis.prepare(\n\t\t\t\t\t\tconnection,\n\t\t\t\t\t\t`DELETE FROM ItemTable WHERE key IN (${new Array(keysChunk.length).fill(\"?\").join(\",\")})`,\n\t\t\t\t\t\t(stmt) => stmt.run(keysChunk),\n\t\t\t\t\t\t() => {\n\t\t\t\t\t\t\tconst keys: string[] = [];\n\t\t\t\t\t\t\ttoDelete.forEach((key) => {\n\t\t\t\t\t\t\t\tkeys.push(key);\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\treturn `Keys: ${keys.join(\", \")}`;\n\t\t\t\t\t\t},\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\tasync optimize(): Promise<void> {\n\t\tthis.logger.trace(`[storage ${this.name}] vacuum()`);\n\n\t\tconst connection = await this.whenConnected;\n\n\t\treturn this.exec(connection, \"VACUUM\");\n\t}\n\n\tasync close(recovery?: () => Map<string, string>): Promise<void> {\n\t\tthis.logger.trace(`[storage ${this.name}] close()`);\n\n\t\tconst connection = await this.whenConnected;\n\n\t\treturn this.doClose(connection, recovery);\n\t}\n\n\tprivate doClose(\n\t\tconnection: IDatabaseConnection,\n\t\trecovery?: () => Map<string, string>,\n\t): Promise<void> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconnection.db.close((closeError) => {\n\t\t\t\tif (closeError) {\n\t\t\t\t\tthis.handleSQLiteError(\n\t\t\t\t\t\tconnection,\n\t\t\t\t\t\t`[storage ${this.name}] close(): ${closeError}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// Return early if this storage was created only in-memory\n\t\t\t\t// e.g. when running tests we do not need to backup.\n\t\t\t\tif (this.path === SQLiteStorageDatabase.IN_MEMORY_PATH) {\n\t\t\t\t\treturn resolve();\n\t\t\t\t}\n\n\t\t\t\t// If the DB closed successfully and we are not running in-memory\n\t\t\t\t// and the DB did not get errors during runtime, make a backup\n\t\t\t\t// of the DB so that we can use it as fallback in case the actual\n\t\t\t\t// DB becomes corrupt in the future.\n\t\t\t\tif (!connection.isErroneous && !connection.isInMemory) {\n\t\t\t\t\treturn this.backup().then(resolve, (error) => {\n\t\t\t\t\t\tthis.logger.error(\n\t\t\t\t\t\t\t`[storage ${this.name}] backup(): ${error}`,\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\treturn resolve(); // ignore failing backup\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Recovery: if we detected errors while using the DB or we are using\n\t\t\t\t// an inmemory DB (as a fallback to not being able to open the DB initially)\n\t\t\t\t// and we have a recovery function provided, we recreate the DB with this\n\t\t\t\t// data to recover all known data without loss if possible.\n\t\t\t\tif (typeof recovery === \"function\") {\n\t\t\t\t\t// Delete the existing DB. If the path does not exist or fails to\n\t\t\t\t\t// be deleted, we do not try to recover anymore because we assume\n\t\t\t\t\t// that the path is no longer writeable for us.\n\t\t\t\t\treturn fs.promises\n\t\t\t\t\t\t.unlink(this.path)\n\t\t\t\t\t\t.then(() => {\n\t\t\t\t\t\t\t// Re-open the DB fresh\n\t\t\t\t\t\t\treturn this.doConnect(this.path).then(\n\t\t\t\t\t\t\t\t(recoveryConnection) => {\n\t\t\t\t\t\t\t\t\tconst closeRecoveryConnection = () => {\n\t\t\t\t\t\t\t\t\t\treturn this.doClose(\n\t\t\t\t\t\t\t\t\t\t\trecoveryConnection,\n\t\t\t\t\t\t\t\t\t\t\tundefined /* do not attempt to recover again */,\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\t// Store items\n\t\t\t\t\t\t\t\t\treturn this.doUpdateItems(\n\t\t\t\t\t\t\t\t\t\trecoveryConnection,\n\t\t\t\t\t\t\t\t\t\t{ insert: recovery() },\n\t\t\t\t\t\t\t\t\t).then(\n\t\t\t\t\t\t\t\t\t\t() => closeRecoveryConnection(),\n\t\t\t\t\t\t\t\t\t\t(error) => {\n\t\t\t\t\t\t\t\t\t\t\t// In case of an error updating items, still ensure to close the connection\n\t\t\t\t\t\t\t\t\t\t\t// to prevent SQLITE_BUSY errors when the connection is reestablished\n\t\t\t\t\t\t\t\t\t\t\tcloseRecoveryConnection();\n\n\t\t\t\t\t\t\t\t\t\t\treturn Promise.reject(error);\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.then(resolve, reject);\n\t\t\t\t}\n\n\t\t\t\t// Finally without recovery we just reject\n\t\t\t\treturn reject(\n\t\t\t\t\tcloseError ||\n\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\"Database has errors or is in-memory without recovery option\",\n\t\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate backup(): Promise<void> {\n\t\tconst backupPath = this.toBackupPath(this.path);\n\n\t\treturn Promises.copy(this.path, backupPath, {\n\t\t\tpreserveSymlinks: false,\n\t\t});\n\t}\n\n\tprivate toBackupPath(path: string): string {\n\t\treturn `${path}.backup`;\n\t}\n\n\tasync checkIntegrity(full: boolean): Promise<string> {\n\t\tthis.logger.trace(\n\t\t\t`[storage ${this.name}] checkIntegrity(full: ${full})`,\n\t\t);\n\n\t\tconst connection = await this.whenConnected;\n\t\tconst row = await this.get(\n\t\t\tconnection,\n\t\t\tfull ? \"PRAGMA integrity_check\" : \"PRAGMA quick_check\",\n\t\t);\n\n\t\tconst integrity = full\n\t\t\t? (row as any)[\"integrity_check\"]\n\t\t\t: (row as any)[\"quick_check\"];\n\n\t\tif (connection.isErroneous) {\n\t\t\treturn `${integrity} (last error: ${connection.lastError})`;\n\t\t}\n\n\t\tif (connection.isInMemory) {\n\t\t\treturn `${integrity} (in-memory!)`;\n\t\t}\n\n\t\treturn integrity;\n\t}\n\n\tprivate async connect(\n\t\tpath: string,\n\t\tretryOnBusy = true,\n\t): Promise<IDatabaseConnection> {\n\t\tthis.logger.trace(\n\t\t\t`[storage ${this.name}] open(${path}, retryOnBusy: ${retryOnBusy})`,\n\t\t);\n\n\t\ttry {\n\t\t\treturn await this.doConnect(path);\n\t\t} catch (error) {\n\t\t\tthis.logger.error(\n\t\t\t\t`[storage ${this.name}] open(): Unable to open DB due to ${error}`,\n\t\t\t);\n\n\t\t\t// SQLITE_BUSY should only arise if another process is locking the same DB we want\n\t\t\t// to open at that time. This typically never happens because a DB connection is\n\t\t\t// limited per window. However, in the event of a window reload, it may be possible\n\t\t\t// that the previous connection was not properly closed while the new connection is\n\t\t\t// already established.\n\t\t\t//\n\t\t\t// In this case we simply wait for some time and retry once to establish the connection.\n\t\t\t//\n\t\t\tif (error.code === \"SQLITE_BUSY\" && retryOnBusy) {\n\t\t\t\tawait timeout(SQLiteStorageDatabase.BUSY_OPEN_TIMEOUT);\n\n\t\t\t\treturn this.connect(path, false /* not another retry */);\n\t\t\t}\n\n\t\t\t// Otherwise, best we can do is to recover from a backup if that exists, as such we\n\t\t\t// move the DB to a different filename and try to load from backup. If that fails,\n\t\t\t// a new empty DB is being created automatically.\n\t\t\t//\n\t\t\t// The final fallback is to use an in-memory DB which should only happen if the target\n\t\t\t// folder is really not writeable for us.\n\t\t\t//\n\t\t\ttry {\n\t\t\t\tawait fs.promises.unlink(path);\n\t\t\t\ttry {\n\t\t\t\t\tawait Promises.rename(\n\t\t\t\t\t\tthis.toBackupPath(path),\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\tfalse /* no retry */,\n\t\t\t\t\t);\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\n\t\t\t\treturn await this.doConnect(path);\n\t\t\t} catch (error) {\n\t\t\t\tthis.logger.error(\n\t\t\t\t\t`[storage ${this.name}] open(): Unable to use backup due to ${error}`,\n\t\t\t\t);\n\n\t\t\t\t// In case of any error to open the DB, use an in-memory\n\t\t\t\t// DB so that we always have a valid DB to talk to.\n\t\t\t\treturn this.doConnect(SQLiteStorageDatabase.IN_MEMORY_PATH);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate handleSQLiteError(\n\t\tconnection: IDatabaseConnection,\n\t\tmsg: string,\n\t): void {\n\t\tconnection.isErroneous = true;\n\t\tconnection.lastError = msg;\n\n\t\tthis.logger.error(msg);\n\t}\n\n\tprivate doConnect(path: string): Promise<IDatabaseConnection> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\timport(\"@vscode/sqlite3\").then((sqlite3) => {\n\t\t\t\t// ESM-comment-begin\n\t\t\t\t// const ctor = (this.logger.isTracing ? sqlite3.verbose().Database : sqlite3.Database);\n\t\t\t\t// ESM-comment-end\n\t\t\t\t// ESM-uncomment-begin\n\t\t\t\tconst ctor = this.logger.isTracing\n\t\t\t\t\t? sqlite3.default.verbose().Database\n\t\t\t\t\t: sqlite3.default.Database;\n\t\t\t\t// ESM-uncomment-end\n\t\t\t\tconst connection: IDatabaseConnection = {\n\t\t\t\t\tdb: new ctor(\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\t(error: (Error & { code?: string }) | null) => {\n\t\t\t\t\t\t\tif (error) {\n\t\t\t\t\t\t\t\treturn connection.db &&\n\t\t\t\t\t\t\t\t\terror.code !==\n\t\t\t\t\t\t\t\t\t\t\"SQLITE_CANTOPEN\" /* https://github.com/TryGhost/node-sqlite3/issues/1617 */\n\t\t\t\t\t\t\t\t\t? connection.db.close(() => reject(error))\n\t\t\t\t\t\t\t\t\t: reject(error);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// The following exec() statement serves two purposes:\n\t\t\t\t\t\t\t// - create the DB if it does not exist yet\n\t\t\t\t\t\t\t// - validate that the DB is not corrupt (the open() call does not throw otherwise)\n\t\t\t\t\t\t\treturn this.exec(\n\t\t\t\t\t\t\t\tconnection,\n\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\"PRAGMA user_version = 1;\",\n\t\t\t\t\t\t\t\t\t\"CREATE TABLE IF NOT EXISTS ItemTable (key TEXT UNIQUE ON CONFLICT REPLACE, value BLOB)\",\n\t\t\t\t\t\t\t\t].join(\"\"),\n\t\t\t\t\t\t\t).then(\n\t\t\t\t\t\t\t\t() => {\n\t\t\t\t\t\t\t\t\treturn resolve(connection);\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t(error) => {\n\t\t\t\t\t\t\t\t\treturn connection.db.close(() =>\n\t\t\t\t\t\t\t\t\t\treject(error),\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t\tisInMemory: path === SQLiteStorageDatabase.IN_MEMORY_PATH,\n\t\t\t\t};\n\n\t\t\t\t// Errors\n\t\t\t\tconnection.db.on(\"error\", (error) =>\n\t\t\t\t\tthis.handleSQLiteError(\n\t\t\t\t\t\tconnection,\n\t\t\t\t\t\t`[storage ${this.name}] Error (event): ${error}`,\n\t\t\t\t\t),\n\t\t\t\t);\n\n\t\t\t\t// Tracing\n\t\t\t\tif (this.logger.isTracing) {\n\t\t\t\t\tconnection.db.on(\"trace\", (sql) =>\n\t\t\t\t\t\tthis.logger.trace(\n\t\t\t\t\t\t\t`[storage ${this.name}] Trace (event): ${sql}`,\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}, reject);\n\t\t});\n\t}\n\n\tprivate exec(connection: IDatabaseConnection, sql: string): Promise<void> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconnection.db.exec(sql, (error) => {\n\t\t\t\tif (error) {\n\t\t\t\t\tthis.handleSQLiteError(\n\t\t\t\t\t\tconnection,\n\t\t\t\t\t\t`[storage ${this.name}] exec(): ${error}`,\n\t\t\t\t\t);\n\n\t\t\t\t\treturn reject(error);\n\t\t\t\t}\n\n\t\t\t\treturn resolve();\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate get(connection: IDatabaseConnection, sql: string): Promise<object> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconnection.db.get(sql, (error, row) => {\n\t\t\t\tif (error) {\n\t\t\t\t\tthis.handleSQLiteError(\n\t\t\t\t\t\tconnection,\n\t\t\t\t\t\t`[storage ${this.name}] get(): ${error}`,\n\t\t\t\t\t);\n\n\t\t\t\t\treturn reject(error);\n\t\t\t\t}\n\n\t\t\t\treturn resolve(row);\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate all(\n\t\tconnection: IDatabaseConnection,\n\t\tsql: string,\n\t): Promise<{ key: string; value: string }[]> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconnection.db.all(sql, (error, rows) => {\n\t\t\t\tif (error) {\n\t\t\t\t\tthis.handleSQLiteError(\n\t\t\t\t\t\tconnection,\n\t\t\t\t\t\t`[storage ${this.name}] all(): ${error}`,\n\t\t\t\t\t);\n\n\t\t\t\t\treturn reject(error);\n\t\t\t\t}\n\n\t\t\t\treturn resolve(rows);\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate transaction(\n\t\tconnection: IDatabaseConnection,\n\t\ttransactions: () => void,\n\t): Promise<void> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconnection.db.serialize(() => {\n\t\t\t\tconnection.db.run(\"BEGIN TRANSACTION\");\n\n\t\t\t\ttransactions();\n\n\t\t\t\tconnection.db.run(\"END TRANSACTION\", (error) => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tthis.handleSQLiteError(\n\t\t\t\t\t\t\tconnection,\n\t\t\t\t\t\t\t`[storage ${this.name}] transaction(): ${error}`,\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\treturn reject(error);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn resolve();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate prepare(\n\t\tconnection: IDatabaseConnection,\n\t\tsql: string,\n\t\trunCallback: (stmt: Statement) => void,\n\t\terrorDetails: () => string,\n\t): void {\n\t\tconst stmt = connection.db.prepare(sql);\n\n\t\tconst statementErrorListener = (error: Error) => {\n\t\t\tthis.handleSQLiteError(\n\t\t\t\tconnection,\n\t\t\t\t`[storage ${this.name}] prepare(): ${error} (${sql}). Details: ${errorDetails()}`,\n\t\t\t);\n\t\t};\n\n\t\tstmt.on(\"error\", statementErrorListener);\n\n\t\trunCallback(stmt);\n\n\t\tstmt.finalize((error) => {\n\t\t\tif (error) {\n\t\t\t\tstatementErrorListener(error);\n\t\t\t}\n\n\t\t\tstmt.removeListener(\"error\", statementErrorListener);\n\t\t});\n\t}\n}\n\nclass SQLiteStorageDatabaseLogger {\n\t// to reduce lots of output, require an environment variable to enable tracing\n\t// this helps when running with --verbose normally where the storage tracing\n\t// might hide useful output to look at\n\tprivate static readonly VSCODE_TRACE_STORAGE = \"VSCODE_TRACE_STORAGE\";\n\n\tprivate readonly logTrace: ((msg: string) => void) | undefined;\n\tprivate readonly logError: ((error: string | Error) => void) | undefined;\n\n\tconstructor(options?: ISQLiteStorageDatabaseLoggingOptions) {\n\t\tif (\n\t\t\toptions &&\n\t\t\ttypeof options.logTrace === \"function\" &&\n\t\t\tprocess.env[SQLiteStorageDatabaseLogger.VSCODE_TRACE_STORAGE]\n\t\t) {\n\t\t\tthis.logTrace = options.logTrace;\n\t\t}\n\n\t\tif (options && typeof options.logError === \"function\") {\n\t\t\tthis.logError = options.logError;\n\t\t}\n\t}\n\n\tget isTracing(): boolean {\n\t\treturn !!this.logTrace;\n\t}\n\n\ttrace(msg: string): void {\n\t\tthis.logTrace?.(msg);\n\t}\n\n\terror(error: string | Error): void {\n\t\tthis.logError?.(error);\n\t}\n}\n"],
  "mappings": ";;AAKA,YAAY,QAAQ;AAEpB,SAAS,eAAe;AACxB,SAAS,aAAa;AACtB,SAAS,aAAa,mBAAmB;AACzC,SAAS,gBAAgB;AACzB,SAAS,gBAAgB;AAwBlB,MAAM,sBAAkD;AAAA,EAkB9D,YACkB,MACA,UAAyC,uBAAO;AAAA,IAChE;AAAA,EACD,GACC;AAJgB;AACA;AAAA,EAGf;AAAA,EA1DJ,OAmC+D;AAAA;AAAA;AAAA,EAC9D,OAAgB,iBAAiB;AAAA,EAEjC,IAAI,2BAA4D;AAC/D,WAAO,MAAM;AAAA,EACd;AAAA;AAAA,EAEA,OAAwB,oBAAoB;AAAA;AAAA,EAC5C,OAAwB,sBAAsB;AAAA;AAAA,EAE7B,OAAO,SAAS,KAAK,IAAI;AAAA,EAEzB,SAAS,IAAI;AAAA,IAC7B,KAAK,QAAQ;AAAA,EACd;AAAA,EAEiB,gBAAgB,KAAK,QAAQ,KAAK,IAAI;AAAA,EASvD,MAAM,WAAyC;AAC9C,UAAM,aAAa,MAAM,KAAK;AAE9B,UAAM,QAAQ,oBAAI,IAAoB;AAEtC,UAAM,OAAO,MAAM,KAAK,IAAI,YAAY,yBAAyB;AACjE,SAAK,QAAQ,CAAC,QAAQ,MAAM,IAAI,IAAI,KAAK,IAAI,KAAK,CAAC;AAEnD,QAAI,KAAK,OAAO,WAAW;AAC1B,WAAK,OAAO;AAAA,QACX,YAAY,KAAK,IAAI,iBAAiB,MAAM,IAAI;AAAA,MACjD;AAAA,IACD;AAEA,WAAO;AAAA,EACR;AAAA,EAEA,MAAM,YAAY,SAAwC;AACzD,UAAM,aAAa,MAAM,KAAK;AAE9B,WAAO,KAAK,cAAc,YAAY,OAAO;AAAA,EAC9C;AAAA,EAEQ,cACP,YACA,SACgB;AAChB,QAAI,KAAK,OAAO,WAAW;AAC1B,WAAK,OAAO;AAAA,QACX,YAAY,KAAK,IAAI,2BAA2B,QAAQ,SAAS,YAAY,QAAQ,MAAM,IAAI,GAAG,aAAa,QAAQ,SAAS,YAAY,QAAQ,MAAM,IAAI,GAAG;AAAA,MAClK;AAAA,IACD;AAEA,WAAO,KAAK,YAAY,YAAY,MAAM;AACzC,YAAM,WAAW,QAAQ;AACzB,YAAM,WAAW,QAAQ;AAGzB,UAAI,YAAY,SAAS,OAAO,GAAG;AAClC,cAAM,mBAA+B,CAAC;AACtC,yBAAiB,KAAK,CAAC,CAAC;AAIxB,YAAI,oBAAoB;AACxB,iBAAS,QAAQ,CAAC,OAAO,QAAQ;AAChC,cAAI,gBAAgB,iBAAiB,iBAAiB;AAEtD,cACC,cAAc,SACd,sBAAsB,qBACrB;AACD;AACA,4BAAgB,CAAC;AACjB,6BAAiB,KAAK,aAAa;AAAA,UACpC;AAEA,wBAAc,KAAK,KAAK,KAAK;AAAA,QAC9B,CAAC;AAED,yBAAiB,QAAQ,CAAC,oBAAoB;AAC7C,eAAK;AAAA,YACJ;AAAA,YACA,gCAAgC,IAAI,MAAM,gBAAgB,SAAS,CAAC,EAAE,KAAK,OAAO,EAAE,KAAK,GAAG,CAAC;AAAA,YAC7F,CAAC,SAAS,KAAK,IAAI,eAAe;AAAA,YAClC,MAAM;AACL,oBAAM,OAAiB,CAAC;AACxB,kBAAI,SAAS;AACb,uBAAS,QAAQ,CAAC,OAAO,QAAQ;AAChC,qBAAK,KAAK,GAAG;AACb,0BAAU,MAAM;AAAA,cACjB,CAAC;AAED,qBAAO,SAAS,KAAK,KAAK,IAAI,CAAC,YAAY,MAAM;AAAA,YAClD;AAAA,UACD;AAAA,QACD,CAAC;AAAA,MACF;AAGA,UAAI,YAAY,SAAS,MAAM;AAC9B,cAAM,aAAyB,CAAC;AAChC,mBAAW,KAAK,CAAC,CAAC;AAKlB,YAAI,oBAAoB;AACxB,iBAAS,QAAQ,CAAC,QAAQ;AACzB,cAAI,WAAW,WAAW,iBAAiB;AAE3C,cACC,SAAS,SACT,sBAAsB,qBACrB;AACD;AACA,uBAAW,CAAC;AACZ,uBAAW,KAAK,QAAQ;AAAA,UACzB;AAEA,mBAAS,KAAK,GAAG;AAAA,QAClB,CAAC;AAED,mBAAW,QAAQ,CAAC,cAAc;AACjC,eAAK;AAAA,YACJ;AAAA,YACA,uCAAuC,IAAI,MAAM,UAAU,MAAM,EAAE,KAAK,GAAG,EAAE,KAAK,GAAG,CAAC;AAAA,YACtF,CAAC,SAAS,KAAK,IAAI,SAAS;AAAA,YAC5B,MAAM;AACL,oBAAM,OAAiB,CAAC;AACxB,uBAAS,QAAQ,CAAC,QAAQ;AACzB,qBAAK,KAAK,GAAG;AAAA,cACd,CAAC;AAED,qBAAO,SAAS,KAAK,KAAK,IAAI,CAAC;AAAA,YAChC;AAAA,UACD;AAAA,QACD,CAAC;AAAA,MACF;AAAA,IACD,CAAC;AAAA,EACF;AAAA,EAEA,MAAM,WAA0B;AAC/B,SAAK,OAAO,MAAM,YAAY,KAAK,IAAI,YAAY;AAEnD,UAAM,aAAa,MAAM,KAAK;AAE9B,WAAO,KAAK,KAAK,YAAY,QAAQ;AAAA,EACtC;AAAA,EAEA,MAAM,MAAM,UAAqD;AAChE,SAAK,OAAO,MAAM,YAAY,KAAK,IAAI,WAAW;AAElD,UAAM,aAAa,MAAM,KAAK;AAE9B,WAAO,KAAK,QAAQ,YAAY,QAAQ;AAAA,EACzC;AAAA,EAEQ,QACP,YACA,UACgB;AAChB,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACvC,iBAAW,GAAG,MAAM,CAAC,eAAe;AACnC,YAAI,YAAY;AACf,eAAK;AAAA,YACJ;AAAA,YACA,YAAY,KAAK,IAAI,cAAc,UAAU;AAAA,UAC9C;AAAA,QACD;AAIA,YAAI,KAAK,SAAS,sBAAsB,gBAAgB;AACvD,iBAAO,QAAQ;AAAA,QAChB;AAMA,YAAI,CAAC,WAAW,eAAe,CAAC,WAAW,YAAY;AACtD,iBAAO,KAAK,OAAO,EAAE,KAAK,SAAS,CAAC,UAAU;AAC7C,iBAAK,OAAO;AAAA,cACX,YAAY,KAAK,IAAI,eAAe,KAAK;AAAA,YAC1C;AAEA,mBAAO,QAAQ;AAAA,UAChB,CAAC;AAAA,QACF;AAMA,YAAI,OAAO,aAAa,YAAY;AAInC,iBAAO,GAAG,SACR,OAAO,KAAK,IAAI,EAChB,KAAK,MAAM;AAEX,mBAAO,KAAK,UAAU,KAAK,IAAI,EAAE;AAAA,cAChC,CAAC,uBAAuB;AACvB,sBAAM,0BAA0B,6BAAM;AACrC,yBAAO,KAAK;AAAA,oBACX;AAAA,oBACA;AAAA,kBACD;AAAA,gBACD,GALgC;AAQhC,uBAAO,KAAK;AAAA,kBACX;AAAA,kBACA,EAAE,QAAQ,SAAS,EAAE;AAAA,gBACtB,EAAE;AAAA,kBACD,MAAM,wBAAwB;AAAA,kBAC9B,CAAC,UAAU;AAGV,4CAAwB;AAExB,2BAAO,QAAQ,OAAO,KAAK;AAAA,kBAC5B;AAAA,gBACD;AAAA,cACD;AAAA,YACD;AAAA,UACD,CAAC,EACA,KAAK,SAAS,MAAM;AAAA,QACvB;AAGA,eAAO;AAAA,UACN,cACC,IAAI;AAAA,YACH;AAAA,UACD;AAAA,QACF;AAAA,MACD,CAAC;AAAA,IACF,CAAC;AAAA,EACF;AAAA,EAEQ,SAAwB;AAC/B,UAAM,aAAa,KAAK,aAAa,KAAK,IAAI;AAE9C,WAAO,SAAS,KAAK,KAAK,MAAM,YAAY;AAAA,MAC3C,kBAAkB;AAAA,IACnB,CAAC;AAAA,EACF;AAAA,EAEQ,aAAa,MAAsB;AAC1C,WAAO,GAAG,IAAI;AAAA,EACf;AAAA,EAEA,MAAM,eAAe,MAAgC;AACpD,SAAK,OAAO;AAAA,MACX,YAAY,KAAK,IAAI,0BAA0B,IAAI;AAAA,IACpD;AAEA,UAAM,aAAa,MAAM,KAAK;AAC9B,UAAM,MAAM,MAAM,KAAK;AAAA,MACtB;AAAA,MACA,OAAO,2BAA2B;AAAA,IACnC;AAEA,UAAM,YAAY,OACd,IAAY,iBAAiB,IAC7B,IAAY,aAAa;AAE7B,QAAI,WAAW,aAAa;AAC3B,aAAO,GAAG,SAAS,iBAAiB,WAAW,SAAS;AAAA,IACzD;AAEA,QAAI,WAAW,YAAY;AAC1B,aAAO,GAAG,SAAS;AAAA,IACpB;AAEA,WAAO;AAAA,EACR;AAAA,EAEA,MAAc,QACb,MACA,cAAc,MACiB;AAC/B,SAAK,OAAO;AAAA,MACX,YAAY,KAAK,IAAI,UAAU,IAAI,kBAAkB,WAAW;AAAA,IACjE;AAEA,QAAI;AACH,aAAO,MAAM,KAAK,UAAU,IAAI;AAAA,IACjC,SAAS,OAAO;AACf,WAAK,OAAO;AAAA,QACX,YAAY,KAAK,IAAI,sCAAsC,KAAK;AAAA,MACjE;AAUA,UAAI,MAAM,SAAS,iBAAiB,aAAa;AAChD,cAAM,QAAQ,sBAAsB,iBAAiB;AAErD,eAAO,KAAK;AAAA,UAAQ;AAAA,UAAM;AAAA;AAAA,QAA6B;AAAA,MACxD;AASA,UAAI;AACH,cAAM,GAAG,SAAS,OAAO,IAAI;AAC7B,YAAI;AACH,gBAAM,SAAS;AAAA,YACd,KAAK,aAAa,IAAI;AAAA,YACtB;AAAA,YACA;AAAA,UACD;AAAA,QACD,SAASA,QAAO;AAAA,QAEhB;AAEA,eAAO,MAAM,KAAK,UAAU,IAAI;AAAA,MACjC,SAASA,QAAO;AACf,aAAK,OAAO;AAAA,UACX,YAAY,KAAK,IAAI,yCAAyCA,MAAK;AAAA,QACpE;AAIA,eAAO,KAAK,UAAU,sBAAsB,cAAc;AAAA,MAC3D;AAAA,IACD;AAAA,EACD;AAAA,EAEQ,kBACP,YACA,KACO;AACP,eAAW,cAAc;AACzB,eAAW,YAAY;AAEvB,SAAK,OAAO,MAAM,GAAG;AAAA,EACtB;AAAA,EAEQ,UAAU,MAA4C;AAC7D,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACvC,aAAO,iBAAiB,EAAE,KAAK,CAAC,YAAY;AAK3C,cAAM,OAAO,KAAK,OAAO,YACtB,QAAQ,QAAQ,QAAQ,EAAE,WAC1B,QAAQ,QAAQ;AAEnB,cAAM,aAAkC;AAAA,UACvC,IAAI,IAAI;AAAA,YACP;AAAA,YACA,CAAC,UAA8C;AAC9C,kBAAI,OAAO;AACV,uBAAO,WAAW,MACjB,MAAM,SACL,oBACC,WAAW,GAAG,MAAM,MAAM,OAAO,KAAK,CAAC,IACvC,OAAO,KAAK;AAAA,cAChB;AAKA,qBAAO,KAAK;AAAA,gBACX;AAAA,gBACA;AAAA,kBACC;AAAA,kBACA;AAAA,gBACD,EAAE,KAAK,EAAE;AAAA,cACV,EAAE;AAAA,gBACD,MAAM;AACL,yBAAO,QAAQ,UAAU;AAAA,gBAC1B;AAAA,gBACA,CAACA,WAAU;AACV,yBAAO,WAAW,GAAG;AAAA,oBAAM,MAC1B,OAAOA,MAAK;AAAA,kBACb;AAAA,gBACD;AAAA,cACD;AAAA,YACD;AAAA,UACD;AAAA,UACA,YAAY,SAAS,sBAAsB;AAAA,QAC5C;AAGA,mBAAW,GAAG;AAAA,UAAG;AAAA,UAAS,CAAC,UAC1B,KAAK;AAAA,YACJ;AAAA,YACA,YAAY,KAAK,IAAI,oBAAoB,KAAK;AAAA,UAC/C;AAAA,QACD;AAGA,YAAI,KAAK,OAAO,WAAW;AAC1B,qBAAW,GAAG;AAAA,YAAG;AAAA,YAAS,CAAC,QAC1B,KAAK,OAAO;AAAA,cACX,YAAY,KAAK,IAAI,oBAAoB,GAAG;AAAA,YAC7C;AAAA,UACD;AAAA,QACD;AAAA,MACD,GAAG,MAAM;AAAA,IACV,CAAC;AAAA,EACF;AAAA,EAEQ,KAAK,YAAiC,KAA4B;AACzE,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACvC,iBAAW,GAAG,KAAK,KAAK,CAAC,UAAU;AAClC,YAAI,OAAO;AACV,eAAK;AAAA,YACJ;AAAA,YACA,YAAY,KAAK,IAAI,aAAa,KAAK;AAAA,UACxC;AAEA,iBAAO,OAAO,KAAK;AAAA,QACpB;AAEA,eAAO,QAAQ;AAAA,MAChB,CAAC;AAAA,IACF,CAAC;AAAA,EACF;AAAA,EAEQ,IAAI,YAAiC,KAA8B;AAC1E,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACvC,iBAAW,GAAG,IAAI,KAAK,CAAC,OAAO,QAAQ;AACtC,YAAI,OAAO;AACV,eAAK;AAAA,YACJ;AAAA,YACA,YAAY,KAAK,IAAI,YAAY,KAAK;AAAA,UACvC;AAEA,iBAAO,OAAO,KAAK;AAAA,QACpB;AAEA,eAAO,QAAQ,GAAG;AAAA,MACnB,CAAC;AAAA,IACF,CAAC;AAAA,EACF;AAAA,EAEQ,IACP,YACA,KAC4C;AAC5C,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACvC,iBAAW,GAAG,IAAI,KAAK,CAAC,OAAO,SAAS;AACvC,YAAI,OAAO;AACV,eAAK;AAAA,YACJ;AAAA,YACA,YAAY,KAAK,IAAI,YAAY,KAAK;AAAA,UACvC;AAEA,iBAAO,OAAO,KAAK;AAAA,QACpB;AAEA,eAAO,QAAQ,IAAI;AAAA,MACpB,CAAC;AAAA,IACF,CAAC;AAAA,EACF;AAAA,EAEQ,YACP,YACA,cACgB;AAChB,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACvC,iBAAW,GAAG,UAAU,MAAM;AAC7B,mBAAW,GAAG,IAAI,mBAAmB;AAErC,qBAAa;AAEb,mBAAW,GAAG,IAAI,mBAAmB,CAAC,UAAU;AAC/C,cAAI,OAAO;AACV,iBAAK;AAAA,cACJ;AAAA,cACA,YAAY,KAAK,IAAI,oBAAoB,KAAK;AAAA,YAC/C;AAEA,mBAAO,OAAO,KAAK;AAAA,UACpB;AAEA,iBAAO,QAAQ;AAAA,QAChB,CAAC;AAAA,MACF,CAAC;AAAA,IACF,CAAC;AAAA,EACF;AAAA,EAEQ,QACP,YACA,KACA,aACA,cACO;AACP,UAAM,OAAO,WAAW,GAAG,QAAQ,GAAG;AAEtC,UAAM,yBAAyB,wBAAC,UAAiB;AAChD,WAAK;AAAA,QACJ;AAAA,QACA,YAAY,KAAK,IAAI,gBAAgB,KAAK,KAAK,GAAG,eAAe,aAAa,CAAC;AAAA,MAChF;AAAA,IACD,GAL+B;AAO/B,SAAK,GAAG,SAAS,sBAAsB;AAEvC,gBAAY,IAAI;AAEhB,SAAK,SAAS,CAAC,UAAU;AACxB,UAAI,OAAO;AACV,+BAAuB,KAAK;AAAA,MAC7B;AAEA,WAAK,eAAe,SAAS,sBAAsB;AAAA,IACpD,CAAC;AAAA,EACF;AACD;AAEA,MAAM,4BAA4B;AAAA,EAxjBlC,OAwjBkC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAIjC,OAAwB,uBAAuB;AAAA,EAE9B;AAAA,EACA;AAAA,EAEjB,YAAY,SAAgD;AAC3D,QACC,WACA,OAAO,QAAQ,aAAa,cAC5B,QAAQ,IAAI,4BAA4B,oBAAoB,GAC3D;AACD,WAAK,WAAW,QAAQ;AAAA,IACzB;AAEA,QAAI,WAAW,OAAO,QAAQ,aAAa,YAAY;AACtD,WAAK,WAAW,QAAQ;AAAA,IACzB;AAAA,EACD;AAAA,EAEA,IAAI,YAAqB;AACxB,WAAO,CAAC,CAAC,KAAK;AAAA,EACf;AAAA,EAEA,MAAM,KAAmB;AACxB,SAAK,WAAW,GAAG;AAAA,EACpB;AAAA,EAEA,MAAM,OAA6B;AAClC,SAAK,WAAW,KAAK;AAAA,EACtB;AACD;",
  "names": ["error"]
}
