{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/parts/storage/node/storage.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport { timeout } from '../../../common/async.js';\nimport { Event } from '../../../common/event.js';\nimport { mapToString, setToString } from '../../../common/map.js';\nimport { basename } from '../../../common/path.js';\nimport { Promises } from '../../../node/pfs.js';\nimport { IStorageDatabase, IStorageItemsChangeEvent, IUpdateRequest } from '../common/storage.js';\nimport type { Database, Statement } from '@vscode/sqlite3';\n\ninterface IDatabaseConnection {\n\treadonly db: Database;\n\treadonly isInMemory: boolean;\n\n\tisErroneous?: boolean;\n\tlastError?: string;\n}\n\nexport interface ISQLiteStorageDatabaseOptions {\n\treadonly logging?: ISQLiteStorageDatabaseLoggingOptions;\n}\n\nexport interface ISQLiteStorageDatabaseLoggingOptions {\n\tlogError?: (error: string | Error) => void;\n\tlogTrace?: (msg: string) => void;\n}\n\nexport class SQLiteStorageDatabase implements IStorageDatabase {\n\n\tstatic readonly IN_MEMORY_PATH = ':memory:';\n\n\tget onDidChangeItemsExternal(): Event<IStorageItemsChangeEvent> { return Event.None; } // since we are the only client, there can be no external changes\n\n\tprivate static readonly BUSY_OPEN_TIMEOUT = 2000; // timeout in ms to retry when opening DB fails with SQLITE_BUSY\n\tprivate static readonly MAX_HOST_PARAMETERS = 256; // maximum number of parameters within a statement\n\n\tprivate readonly name = basename(this.path);\n\n\tprivate readonly logger = new SQLiteStorageDatabaseLogger(this.options.logging);\n\n\tprivate readonly whenConnected = this.connect(this.path);\n\n\tconstructor(private readonly path: string, private readonly options: ISQLiteStorageDatabaseOptions = Object.create(null)) { }\n\n\tasync getItems(): Promise<Map<string, string>> {\n\t\tconst connection = await this.whenConnected;\n\n\t\tconst items = new Map<string, string>();\n\n\t\tconst rows = await this.all(connection, 'SELECT * FROM ItemTable');\n\t\trows.forEach(row => items.set(row.key, row.value));\n\n\t\tif (this.logger.isTracing) {\n\t\t\tthis.logger.trace(`[storage ${this.name}] getItems(): ${items.size} rows`);\n\t\t}\n\n\t\treturn items;\n\t}\n\n\tasync updateItems(request: IUpdateRequest): Promise<void> {\n\t\tconst connection = await this.whenConnected;\n\n\t\treturn this.doUpdateItems(connection, request);\n\t}\n\n\tprivate doUpdateItems(connection: IDatabaseConnection, request: IUpdateRequest): Promise<void> {\n\t\tif (this.logger.isTracing) {\n\t\t\tthis.logger.trace(`[storage ${this.name}] updateItems(): insert(${request.insert ? mapToString(request.insert) : '0'}), delete(${request.delete ? setToString(request.delete) : '0'})`);\n\t\t}\n\n\t\treturn this.transaction(connection, () => {\n\t\t\tconst toInsert = request.insert;\n\t\t\tconst toDelete = request.delete;\n\n\t\t\t// INSERT\n\t\t\tif (toInsert && toInsert.size > 0) {\n\t\t\t\tconst keysValuesChunks: (string[])[] = [];\n\t\t\t\tkeysValuesChunks.push([]); // seed with initial empty chunk\n\n\t\t\t\t// Split key/values into chunks of SQLiteStorageDatabase.MAX_HOST_PARAMETERS\n\t\t\t\t// so that we can efficiently run the INSERT with as many HOST parameters as possible\n\t\t\t\tlet currentChunkIndex = 0;\n\t\t\t\ttoInsert.forEach((value, key) => {\n\t\t\t\t\tlet keyValueChunk = keysValuesChunks[currentChunkIndex];\n\n\t\t\t\t\tif (keyValueChunk.length > SQLiteStorageDatabase.MAX_HOST_PARAMETERS) {\n\t\t\t\t\t\tcurrentChunkIndex++;\n\t\t\t\t\t\tkeyValueChunk = [];\n\t\t\t\t\t\tkeysValuesChunks.push(keyValueChunk);\n\t\t\t\t\t}\n\n\t\t\t\t\tkeyValueChunk.push(key, value);\n\t\t\t\t});\n\n\t\t\t\tkeysValuesChunks.forEach(keysValuesChunk => {\n\t\t\t\t\tthis.prepare(connection, `INSERT INTO ItemTable VALUES ${new Array(keysValuesChunk.length / 2).fill('(?,?)').join(',')}`, stmt => stmt.run(keysValuesChunk), () => {\n\t\t\t\t\t\tconst keys: string[] = [];\n\t\t\t\t\t\tlet length = 0;\n\t\t\t\t\t\ttoInsert.forEach((value, key) => {\n\t\t\t\t\t\t\tkeys.push(key);\n\t\t\t\t\t\t\tlength += value.length;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn `Keys: ${keys.join(', ')} Length: ${length}`;\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// DELETE\n\t\t\tif (toDelete && toDelete.size) {\n\t\t\t\tconst keysChunks: (string[])[] = [];\n\t\t\t\tkeysChunks.push([]); // seed with initial empty chunk\n\n\t\t\t\t// Split keys into chunks of SQLiteStorageDatabase.MAX_HOST_PARAMETERS\n\t\t\t\t// so that we can efficiently run the DELETE with as many HOST parameters\n\t\t\t\t// as possible\n\t\t\t\tlet currentChunkIndex = 0;\n\t\t\t\ttoDelete.forEach(key => {\n\t\t\t\t\tlet keyChunk = keysChunks[currentChunkIndex];\n\n\t\t\t\t\tif (keyChunk.length > SQLiteStorageDatabase.MAX_HOST_PARAMETERS) {\n\t\t\t\t\t\tcurrentChunkIndex++;\n\t\t\t\t\t\tkeyChunk = [];\n\t\t\t\t\t\tkeysChunks.push(keyChunk);\n\t\t\t\t\t}\n\n\t\t\t\t\tkeyChunk.push(key);\n\t\t\t\t});\n\n\t\t\t\tkeysChunks.forEach(keysChunk => {\n\t\t\t\t\tthis.prepare(connection, `DELETE FROM ItemTable WHERE key IN (${new Array(keysChunk.length).fill('?').join(',')})`, stmt => stmt.run(keysChunk), () => {\n\t\t\t\t\t\tconst keys: string[] = [];\n\t\t\t\t\t\ttoDelete.forEach(key => {\n\t\t\t\t\t\t\tkeys.push(key);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn `Keys: ${keys.join(', ')}`;\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\tasync optimize(): Promise<void> {\n\t\tthis.logger.trace(`[storage ${this.name}] vacuum()`);\n\n\t\tconst connection = await this.whenConnected;\n\n\t\treturn this.exec(connection, 'VACUUM');\n\t}\n\n\tasync close(recovery?: () => Map<string, string>): Promise<void> {\n\t\tthis.logger.trace(`[storage ${this.name}] close()`);\n\n\t\tconst connection = await this.whenConnected;\n\n\t\treturn this.doClose(connection, recovery);\n\t}\n\n\tprivate doClose(connection: IDatabaseConnection, recovery?: () => Map<string, string>): Promise<void> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconnection.db.close(closeError => {\n\t\t\t\tif (closeError) {\n\t\t\t\t\tthis.handleSQLiteError(connection, `[storage ${this.name}] close(): ${closeError}`);\n\t\t\t\t}\n\n\t\t\t\t// Return early if this storage was created only in-memory\n\t\t\t\t// e.g. when running tests we do not need to backup.\n\t\t\t\tif (this.path === SQLiteStorageDatabase.IN_MEMORY_PATH) {\n\t\t\t\t\treturn resolve();\n\t\t\t\t}\n\n\t\t\t\t// If the DB closed successfully and we are not running in-memory\n\t\t\t\t// and the DB did not get errors during runtime, make a backup\n\t\t\t\t// of the DB so that we can use it as fallback in case the actual\n\t\t\t\t// DB becomes corrupt in the future.\n\t\t\t\tif (!connection.isErroneous && !connection.isInMemory) {\n\t\t\t\t\treturn this.backup().then(resolve, error => {\n\t\t\t\t\t\tthis.logger.error(`[storage ${this.name}] backup(): ${error}`);\n\n\t\t\t\t\t\treturn resolve(); // ignore failing backup\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Recovery: if we detected errors while using the DB or we are using\n\t\t\t\t// an inmemory DB (as a fallback to not being able to open the DB initially)\n\t\t\t\t// and we have a recovery function provided, we recreate the DB with this\n\t\t\t\t// data to recover all known data without loss if possible.\n\t\t\t\tif (typeof recovery === 'function') {\n\n\t\t\t\t\t// Delete the existing DB. If the path does not exist or fails to\n\t\t\t\t\t// be deleted, we do not try to recover anymore because we assume\n\t\t\t\t\t// that the path is no longer writeable for us.\n\t\t\t\t\treturn fs.promises.unlink(this.path).then(() => {\n\n\t\t\t\t\t\t// Re-open the DB fresh\n\t\t\t\t\t\treturn this.doConnect(this.path).then(recoveryConnection => {\n\t\t\t\t\t\t\tconst closeRecoveryConnection = () => {\n\t\t\t\t\t\t\t\treturn this.doClose(recoveryConnection, undefined /* do not attempt to recover again */);\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// Store items\n\t\t\t\t\t\t\treturn this.doUpdateItems(recoveryConnection, { insert: recovery() }).then(() => closeRecoveryConnection(), error => {\n\n\t\t\t\t\t\t\t\t// In case of an error updating items, still ensure to close the connection\n\t\t\t\t\t\t\t\t// to prevent SQLITE_BUSY errors when the connection is reestablished\n\t\t\t\t\t\t\t\tcloseRecoveryConnection();\n\n\t\t\t\t\t\t\t\treturn Promise.reject(error);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t}).then(resolve, reject);\n\t\t\t\t}\n\n\t\t\t\t// Finally without recovery we just reject\n\t\t\t\treturn reject(closeError || new Error('Database has errors or is in-memory without recovery option'));\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate backup(): Promise<void> {\n\t\tconst backupPath = this.toBackupPath(this.path);\n\n\t\treturn Promises.copy(this.path, backupPath, { preserveSymlinks: false });\n\t}\n\n\tprivate toBackupPath(path: string): string {\n\t\treturn `${path}.backup`;\n\t}\n\n\tasync checkIntegrity(full: boolean): Promise<string> {\n\t\tthis.logger.trace(`[storage ${this.name}] checkIntegrity(full: ${full})`);\n\n\t\tconst connection = await this.whenConnected;\n\t\tconst row = await this.get(connection, full ? 'PRAGMA integrity_check' : 'PRAGMA quick_check');\n\n\t\tconst integrity = full ? (row as any)['integrity_check'] : (row as any)['quick_check'];\n\n\t\tif (connection.isErroneous) {\n\t\t\treturn `${integrity} (last error: ${connection.lastError})`;\n\t\t}\n\n\t\tif (connection.isInMemory) {\n\t\t\treturn `${integrity} (in-memory!)`;\n\t\t}\n\n\t\treturn integrity;\n\t}\n\n\tprivate async connect(path: string, retryOnBusy: boolean = true): Promise<IDatabaseConnection> {\n\t\tthis.logger.trace(`[storage ${this.name}] open(${path}, retryOnBusy: ${retryOnBusy})`);\n\n\t\ttry {\n\t\t\treturn await this.doConnect(path);\n\t\t} catch (error) {\n\t\t\tthis.logger.error(`[storage ${this.name}] open(): Unable to open DB due to ${error}`);\n\n\t\t\t// SQLITE_BUSY should only arise if another process is locking the same DB we want\n\t\t\t// to open at that time. This typically never happens because a DB connection is\n\t\t\t// limited per window. However, in the event of a window reload, it may be possible\n\t\t\t// that the previous connection was not properly closed while the new connection is\n\t\t\t// already established.\n\t\t\t//\n\t\t\t// In this case we simply wait for some time and retry once to establish the connection.\n\t\t\t//\n\t\t\tif (error.code === 'SQLITE_BUSY' && retryOnBusy) {\n\t\t\t\tawait timeout(SQLiteStorageDatabase.BUSY_OPEN_TIMEOUT);\n\n\t\t\t\treturn this.connect(path, false /* not another retry */);\n\t\t\t}\n\n\t\t\t// Otherwise, best we can do is to recover from a backup if that exists, as such we\n\t\t\t// move the DB to a different filename and try to load from backup. If that fails,\n\t\t\t// a new empty DB is being created automatically.\n\t\t\t//\n\t\t\t// The final fallback is to use an in-memory DB which should only happen if the target\n\t\t\t// folder is really not writeable for us.\n\t\t\t//\n\t\t\ttry {\n\t\t\t\tawait fs.promises.unlink(path);\n\t\t\t\ttry {\n\t\t\t\t\tawait Promises.rename(this.toBackupPath(path), path, false /* no retry */);\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\n\t\t\t\treturn await this.doConnect(path);\n\t\t\t} catch (error) {\n\t\t\t\tthis.logger.error(`[storage ${this.name}] open(): Unable to use backup due to ${error}`);\n\n\t\t\t\t// In case of any error to open the DB, use an in-memory\n\t\t\t\t// DB so that we always have a valid DB to talk to.\n\t\t\t\treturn this.doConnect(SQLiteStorageDatabase.IN_MEMORY_PATH);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate handleSQLiteError(connection: IDatabaseConnection, msg: string): void {\n\t\tconnection.isErroneous = true;\n\t\tconnection.lastError = msg;\n\n\t\tthis.logger.error(msg);\n\t}\n\n\tprivate doConnect(path: string): Promise<IDatabaseConnection> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\timport('@vscode/sqlite3').then(sqlite3 => {\n\t\t\t\t// ESM-comment-begin\n\t\t\t\t// const ctor = (this.logger.isTracing ? sqlite3.verbose().Database : sqlite3.Database);\n\t\t\t\t// ESM-comment-end\n\t\t\t\t// ESM-uncomment-begin\n\t\t\t\tconst ctor = (this.logger.isTracing ? sqlite3.default.verbose().Database : sqlite3.default.Database);\n\t\t\t\t// ESM-uncomment-end\n\t\t\t\tconst connection: IDatabaseConnection = {\n\t\t\t\t\tdb: new ctor(path, (error: (Error & { code?: string }) | null) => {\n\t\t\t\t\t\tif (error) {\n\t\t\t\t\t\t\treturn (connection.db && error.code !== 'SQLITE_CANTOPEN' /* https://github.com/TryGhost/node-sqlite3/issues/1617 */) ? connection.db.close(() => reject(error)) : reject(error);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// The following exec() statement serves two purposes:\n\t\t\t\t\t\t// - create the DB if it does not exist yet\n\t\t\t\t\t\t// - validate that the DB is not corrupt (the open() call does not throw otherwise)\n\t\t\t\t\t\treturn this.exec(connection, [\n\t\t\t\t\t\t\t'PRAGMA user_version = 1;',\n\t\t\t\t\t\t\t'CREATE TABLE IF NOT EXISTS ItemTable (key TEXT UNIQUE ON CONFLICT REPLACE, value BLOB)'\n\t\t\t\t\t\t].join('')).then(() => {\n\t\t\t\t\t\t\treturn resolve(connection);\n\t\t\t\t\t\t}, error => {\n\t\t\t\t\t\t\treturn connection.db.close(() => reject(error));\n\t\t\t\t\t\t});\n\t\t\t\t\t}),\n\t\t\t\t\tisInMemory: path === SQLiteStorageDatabase.IN_MEMORY_PATH\n\t\t\t\t};\n\n\t\t\t\t// Errors\n\t\t\t\tconnection.db.on('error', error => this.handleSQLiteError(connection, `[storage ${this.name}] Error (event): ${error}`));\n\n\t\t\t\t// Tracing\n\t\t\t\tif (this.logger.isTracing) {\n\t\t\t\t\tconnection.db.on('trace', sql => this.logger.trace(`[storage ${this.name}] Trace (event): ${sql}`));\n\t\t\t\t}\n\t\t\t}, reject);\n\t\t});\n\t}\n\n\tprivate exec(connection: IDatabaseConnection, sql: string): Promise<void> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconnection.db.exec(sql, error => {\n\t\t\t\tif (error) {\n\t\t\t\t\tthis.handleSQLiteError(connection, `[storage ${this.name}] exec(): ${error}`);\n\n\t\t\t\t\treturn reject(error);\n\t\t\t\t}\n\n\t\t\t\treturn resolve();\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate get(connection: IDatabaseConnection, sql: string): Promise<object> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconnection.db.get(sql, (error, row) => {\n\t\t\t\tif (error) {\n\t\t\t\t\tthis.handleSQLiteError(connection, `[storage ${this.name}] get(): ${error}`);\n\n\t\t\t\t\treturn reject(error);\n\t\t\t\t}\n\n\t\t\t\treturn resolve(row);\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate all(connection: IDatabaseConnection, sql: string): Promise<{ key: string; value: string }[]> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconnection.db.all(sql, (error, rows) => {\n\t\t\t\tif (error) {\n\t\t\t\t\tthis.handleSQLiteError(connection, `[storage ${this.name}] all(): ${error}`);\n\n\t\t\t\t\treturn reject(error);\n\t\t\t\t}\n\n\t\t\t\treturn resolve(rows);\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate transaction(connection: IDatabaseConnection, transactions: () => void): Promise<void> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconnection.db.serialize(() => {\n\t\t\t\tconnection.db.run('BEGIN TRANSACTION');\n\n\t\t\t\ttransactions();\n\n\t\t\t\tconnection.db.run('END TRANSACTION', error => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tthis.handleSQLiteError(connection, `[storage ${this.name}] transaction(): ${error}`);\n\n\t\t\t\t\t\treturn reject(error);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn resolve();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate prepare(connection: IDatabaseConnection, sql: string, runCallback: (stmt: Statement) => void, errorDetails: () => string): void {\n\t\tconst stmt = connection.db.prepare(sql);\n\n\t\tconst statementErrorListener = (error: Error) => {\n\t\t\tthis.handleSQLiteError(connection, `[storage ${this.name}] prepare(): ${error} (${sql}). Details: ${errorDetails()}`);\n\t\t};\n\n\t\tstmt.on('error', statementErrorListener);\n\n\t\trunCallback(stmt);\n\n\t\tstmt.finalize(error => {\n\t\t\tif (error) {\n\t\t\t\tstatementErrorListener(error);\n\t\t\t}\n\n\t\t\tstmt.removeListener('error', statementErrorListener);\n\t\t});\n\t}\n}\n\nclass SQLiteStorageDatabaseLogger {\n\n\t// to reduce lots of output, require an environment variable to enable tracing\n\t// this helps when running with --verbose normally where the storage tracing\n\t// might hide useful output to look at\n\tprivate static readonly VSCODE_TRACE_STORAGE = 'VSCODE_TRACE_STORAGE';\n\n\tprivate readonly logTrace: ((msg: string) => void) | undefined;\n\tprivate readonly logError: ((error: string | Error) => void) | undefined;\n\n\tconstructor(options?: ISQLiteStorageDatabaseLoggingOptions) {\n\t\tif (options && typeof options.logTrace === 'function' && process.env[SQLiteStorageDatabaseLogger.VSCODE_TRACE_STORAGE]) {\n\t\t\tthis.logTrace = options.logTrace;\n\t\t}\n\n\t\tif (options && typeof options.logError === 'function') {\n\t\t\tthis.logError = options.logError;\n\t\t}\n\t}\n\n\tget isTracing(): boolean {\n\t\treturn !!this.logTrace;\n\t}\n\n\ttrace(msg: string): void {\n\t\tthis.logTrace?.(msg);\n\t}\n\n\terror(error: string | Error): void {\n\t\tthis.logError?.(error);\n\t}\n}\n"],
  "mappings": ";;AAKA,YAAY,QAAQ;AACpB,SAAS,eAAe;AACxB,SAAS,aAAa;AACtB,SAAS,aAAa,mBAAmB;AACzC,SAAS,gBAAgB;AACzB,SAAS,gBAAgB;AACzB,SAAS,kBAAkB,0BAA0B,sBAAsB;AAoBpE,MAAM,sBAAkD;AAAA,EAe9D,YAA6B,MAA+B,UAAyC,uBAAO,OAAO,IAAI,GAAG;AAA7F;AAA+B;AAAA,EAAgE;AAAA,EA9C7H,OA+B+D;AAAA;AAAA;AAAA,EAE9D,OAAgB,iBAAiB;AAAA,EAEjC,IAAI,2BAA4D;AAAE,WAAO,MAAM;AAAA,EAAM;AAAA;AAAA,EAErF,OAAwB,oBAAoB;AAAA;AAAA,EAC5C,OAAwB,sBAAsB;AAAA;AAAA,EAE7B,OAAO,SAAS,KAAK,IAAI;AAAA,EAEzB,SAAS,IAAI,4BAA4B,KAAK,QAAQ,OAAO;AAAA,EAE7D,gBAAgB,KAAK,QAAQ,KAAK,IAAI;AAAA,EAIvD,MAAM,WAAyC;AAC9C,UAAM,aAAa,MAAM,KAAK;AAE9B,UAAM,QAAQ,oBAAI,IAAoB;AAEtC,UAAM,OAAO,MAAM,KAAK,IAAI,YAAY,yBAAyB;AACjE,SAAK,QAAQ,SAAO,MAAM,IAAI,IAAI,KAAK,IAAI,KAAK,CAAC;AAEjD,QAAI,KAAK,OAAO,WAAW;AAC1B,WAAK,OAAO,MAAM,YAAY,KAAK,IAAI,iBAAiB,MAAM,IAAI,OAAO;AAAA,IAC1E;AAEA,WAAO;AAAA,EACR;AAAA,EAEA,MAAM,YAAY,SAAwC;AACzD,UAAM,aAAa,MAAM,KAAK;AAE9B,WAAO,KAAK,cAAc,YAAY,OAAO;AAAA,EAC9C;AAAA,EAEQ,cAAc,YAAiC,SAAwC;AAC9F,QAAI,KAAK,OAAO,WAAW;AAC1B,WAAK,OAAO,MAAM,YAAY,KAAK,IAAI,2BAA2B,QAAQ,SAAS,YAAY,QAAQ,MAAM,IAAI,GAAG,aAAa,QAAQ,SAAS,YAAY,QAAQ,MAAM,IAAI,GAAG,GAAG;AAAA,IACvL;AAEA,WAAO,KAAK,YAAY,YAAY,MAAM;AACzC,YAAM,WAAW,QAAQ;AACzB,YAAM,WAAW,QAAQ;AAGzB,UAAI,YAAY,SAAS,OAAO,GAAG;AAClC,cAAM,mBAAiC,CAAC;AACxC,yBAAiB,KAAK,CAAC,CAAC;AAIxB,YAAI,oBAAoB;AACxB,iBAAS,QAAQ,CAAC,OAAO,QAAQ;AAChC,cAAI,gBAAgB,iBAAiB,iBAAiB;AAEtD,cAAI,cAAc,SAAS,sBAAsB,qBAAqB;AACrE;AACA,4BAAgB,CAAC;AACjB,6BAAiB,KAAK,aAAa;AAAA,UACpC;AAEA,wBAAc,KAAK,KAAK,KAAK;AAAA,QAC9B,CAAC;AAED,yBAAiB,QAAQ,qBAAmB;AAC3C,eAAK,QAAQ,YAAY,gCAAgC,IAAI,MAAM,gBAAgB,SAAS,CAAC,EAAE,KAAK,OAAO,EAAE,KAAK,GAAG,CAAC,IAAI,UAAQ,KAAK,IAAI,eAAe,GAAG,MAAM;AAClK,kBAAM,OAAiB,CAAC;AACxB,gBAAI,SAAS;AACb,qBAAS,QAAQ,CAAC,OAAO,QAAQ;AAChC,mBAAK,KAAK,GAAG;AACb,wBAAU,MAAM;AAAA,YACjB,CAAC;AAED,mBAAO,SAAS,KAAK,KAAK,IAAI,CAAC,YAAY,MAAM;AAAA,UAClD,CAAC;AAAA,QACF,CAAC;AAAA,MACF;AAGA,UAAI,YAAY,SAAS,MAAM;AAC9B,cAAM,aAA2B,CAAC;AAClC,mBAAW,KAAK,CAAC,CAAC;AAKlB,YAAI,oBAAoB;AACxB,iBAAS,QAAQ,SAAO;AACvB,cAAI,WAAW,WAAW,iBAAiB;AAE3C,cAAI,SAAS,SAAS,sBAAsB,qBAAqB;AAChE;AACA,uBAAW,CAAC;AACZ,uBAAW,KAAK,QAAQ;AAAA,UACzB;AAEA,mBAAS,KAAK,GAAG;AAAA,QAClB,CAAC;AAED,mBAAW,QAAQ,eAAa;AAC/B,eAAK,QAAQ,YAAY,uCAAuC,IAAI,MAAM,UAAU,MAAM,EAAE,KAAK,GAAG,EAAE,KAAK,GAAG,CAAC,KAAK,UAAQ,KAAK,IAAI,SAAS,GAAG,MAAM;AACtJ,kBAAM,OAAiB,CAAC;AACxB,qBAAS,QAAQ,SAAO;AACvB,mBAAK,KAAK,GAAG;AAAA,YACd,CAAC;AAED,mBAAO,SAAS,KAAK,KAAK,IAAI,CAAC;AAAA,UAChC,CAAC;AAAA,QACF,CAAC;AAAA,MACF;AAAA,IACD,CAAC;AAAA,EACF;AAAA,EAEA,MAAM,WAA0B;AAC/B,SAAK,OAAO,MAAM,YAAY,KAAK,IAAI,YAAY;AAEnD,UAAM,aAAa,MAAM,KAAK;AAE9B,WAAO,KAAK,KAAK,YAAY,QAAQ;AAAA,EACtC;AAAA,EAEA,MAAM,MAAM,UAAqD;AAChE,SAAK,OAAO,MAAM,YAAY,KAAK,IAAI,WAAW;AAElD,UAAM,aAAa,MAAM,KAAK;AAE9B,WAAO,KAAK,QAAQ,YAAY,QAAQ;AAAA,EACzC;AAAA,EAEQ,QAAQ,YAAiC,UAAqD;AACrG,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACvC,iBAAW,GAAG,MAAM,gBAAc;AACjC,YAAI,YAAY;AACf,eAAK,kBAAkB,YAAY,YAAY,KAAK,IAAI,cAAc,UAAU,EAAE;AAAA,QACnF;AAIA,YAAI,KAAK,SAAS,sBAAsB,gBAAgB;AACvD,iBAAO,QAAQ;AAAA,QAChB;AAMA,YAAI,CAAC,WAAW,eAAe,CAAC,WAAW,YAAY;AACtD,iBAAO,KAAK,OAAO,EAAE,KAAK,SAAS,WAAS;AAC3C,iBAAK,OAAO,MAAM,YAAY,KAAK,IAAI,eAAe,KAAK,EAAE;AAE7D,mBAAO,QAAQ;AAAA,UAChB,CAAC;AAAA,QACF;AAMA,YAAI,OAAO,aAAa,YAAY;AAKnC,iBAAO,GAAG,SAAS,OAAO,KAAK,IAAI,EAAE,KAAK,MAAM;AAG/C,mBAAO,KAAK,UAAU,KAAK,IAAI,EAAE,KAAK,wBAAsB;AAC3D,oBAAM,0BAA0B,6BAAM;AACrC,uBAAO,KAAK;AAAA,kBAAQ;AAAA,kBAAoB;AAAA;AAAA,gBAA+C;AAAA,cACxF,GAFgC;AAKhC,qBAAO,KAAK,cAAc,oBAAoB,EAAE,QAAQ,SAAS,EAAE,CAAC,EAAE,KAAK,MAAM,wBAAwB,GAAG,WAAS;AAIpH,wCAAwB;AAExB,uBAAO,QAAQ,OAAO,KAAK;AAAA,cAC5B,CAAC;AAAA,YACF,CAAC;AAAA,UACF,CAAC,EAAE,KAAK,SAAS,MAAM;AAAA,QACxB;AAGA,eAAO,OAAO,cAAc,IAAI,MAAM,6DAA6D,CAAC;AAAA,MACrG,CAAC;AAAA,IACF,CAAC;AAAA,EACF;AAAA,EAEQ,SAAwB;AAC/B,UAAM,aAAa,KAAK,aAAa,KAAK,IAAI;AAE9C,WAAO,SAAS,KAAK,KAAK,MAAM,YAAY,EAAE,kBAAkB,MAAM,CAAC;AAAA,EACxE;AAAA,EAEQ,aAAa,MAAsB;AAC1C,WAAO,GAAG,IAAI;AAAA,EACf;AAAA,EAEA,MAAM,eAAe,MAAgC;AACpD,SAAK,OAAO,MAAM,YAAY,KAAK,IAAI,0BAA0B,IAAI,GAAG;AAExE,UAAM,aAAa,MAAM,KAAK;AAC9B,UAAM,MAAM,MAAM,KAAK,IAAI,YAAY,OAAO,2BAA2B,oBAAoB;AAE7F,UAAM,YAAY,OAAQ,IAAY,iBAAiB,IAAK,IAAY,aAAa;AAErF,QAAI,WAAW,aAAa;AAC3B,aAAO,GAAG,SAAS,iBAAiB,WAAW,SAAS;AAAA,IACzD;AAEA,QAAI,WAAW,YAAY;AAC1B,aAAO,GAAG,SAAS;AAAA,IACpB;AAEA,WAAO;AAAA,EACR;AAAA,EAEA,MAAc,QAAQ,MAAc,cAAuB,MAAoC;AAC9F,SAAK,OAAO,MAAM,YAAY,KAAK,IAAI,UAAU,IAAI,kBAAkB,WAAW,GAAG;AAErF,QAAI;AACH,aAAO,MAAM,KAAK,UAAU,IAAI;AAAA,IACjC,SAAS,OAAO;AACf,WAAK,OAAO,MAAM,YAAY,KAAK,IAAI,sCAAsC,KAAK,EAAE;AAUpF,UAAI,MAAM,SAAS,iBAAiB,aAAa;AAChD,cAAM,QAAQ,sBAAsB,iBAAiB;AAErD,eAAO,KAAK;AAAA,UAAQ;AAAA,UAAM;AAAA;AAAA,QAA6B;AAAA,MACxD;AASA,UAAI;AACH,cAAM,GAAG,SAAS,OAAO,IAAI;AAC7B,YAAI;AACH,gBAAM,SAAS;AAAA,YAAO,KAAK,aAAa,IAAI;AAAA,YAAG;AAAA,YAAM;AAAA;AAAA,UAAoB;AAAA,QAC1E,SAASA,QAAO;AAAA,QAEhB;AAEA,eAAO,MAAM,KAAK,UAAU,IAAI;AAAA,MACjC,SAASA,QAAO;AACf,aAAK,OAAO,MAAM,YAAY,KAAK,IAAI,yCAAyCA,MAAK,EAAE;AAIvF,eAAO,KAAK,UAAU,sBAAsB,cAAc;AAAA,MAC3D;AAAA,IACD;AAAA,EACD;AAAA,EAEQ,kBAAkB,YAAiC,KAAmB;AAC7E,eAAW,cAAc;AACzB,eAAW,YAAY;AAEvB,SAAK,OAAO,MAAM,GAAG;AAAA,EACtB;AAAA,EAEQ,UAAU,MAA4C;AAC7D,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACvC,aAAO,iBAAiB,EAAE,KAAK,aAAW;AAKzC,cAAM,OAAQ,KAAK,OAAO,YAAY,QAAQ,QAAQ,QAAQ,EAAE,WAAW,QAAQ,QAAQ;AAE3F,cAAM,aAAkC;AAAA,UACvC,IAAI,IAAI,KAAK,MAAM,CAAC,UAA8C;AACjE,gBAAI,OAAO;AACV,qBAAQ,WAAW,MAAM,MAAM,SAAS,oBAAgF,WAAW,GAAG,MAAM,MAAM,OAAO,KAAK,CAAC,IAAI,OAAO,KAAK;AAAA,YAChL;AAKA,mBAAO,KAAK,KAAK,YAAY;AAAA,cAC5B;AAAA,cACA;AAAA,YACD,EAAE,KAAK,EAAE,CAAC,EAAE,KAAK,MAAM;AACtB,qBAAO,QAAQ,UAAU;AAAA,YAC1B,GAAG,CAAAA,WAAS;AACX,qBAAO,WAAW,GAAG,MAAM,MAAM,OAAOA,MAAK,CAAC;AAAA,YAC/C,CAAC;AAAA,UACF,CAAC;AAAA,UACD,YAAY,SAAS,sBAAsB;AAAA,QAC5C;AAGA,mBAAW,GAAG,GAAG,SAAS,WAAS,KAAK,kBAAkB,YAAY,YAAY,KAAK,IAAI,oBAAoB,KAAK,EAAE,CAAC;AAGvH,YAAI,KAAK,OAAO,WAAW;AAC1B,qBAAW,GAAG,GAAG,SAAS,SAAO,KAAK,OAAO,MAAM,YAAY,KAAK,IAAI,oBAAoB,GAAG,EAAE,CAAC;AAAA,QACnG;AAAA,MACD,GAAG,MAAM;AAAA,IACV,CAAC;AAAA,EACF;AAAA,EAEQ,KAAK,YAAiC,KAA4B;AACzE,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACvC,iBAAW,GAAG,KAAK,KAAK,WAAS;AAChC,YAAI,OAAO;AACV,eAAK,kBAAkB,YAAY,YAAY,KAAK,IAAI,aAAa,KAAK,EAAE;AAE5E,iBAAO,OAAO,KAAK;AAAA,QACpB;AAEA,eAAO,QAAQ;AAAA,MAChB,CAAC;AAAA,IACF,CAAC;AAAA,EACF;AAAA,EAEQ,IAAI,YAAiC,KAA8B;AAC1E,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACvC,iBAAW,GAAG,IAAI,KAAK,CAAC,OAAO,QAAQ;AACtC,YAAI,OAAO;AACV,eAAK,kBAAkB,YAAY,YAAY,KAAK,IAAI,YAAY,KAAK,EAAE;AAE3E,iBAAO,OAAO,KAAK;AAAA,QACpB;AAEA,eAAO,QAAQ,GAAG;AAAA,MACnB,CAAC;AAAA,IACF,CAAC;AAAA,EACF;AAAA,EAEQ,IAAI,YAAiC,KAAwD;AACpG,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACvC,iBAAW,GAAG,IAAI,KAAK,CAAC,OAAO,SAAS;AACvC,YAAI,OAAO;AACV,eAAK,kBAAkB,YAAY,YAAY,KAAK,IAAI,YAAY,KAAK,EAAE;AAE3E,iBAAO,OAAO,KAAK;AAAA,QACpB;AAEA,eAAO,QAAQ,IAAI;AAAA,MACpB,CAAC;AAAA,IACF,CAAC;AAAA,EACF;AAAA,EAEQ,YAAY,YAAiC,cAAyC;AAC7F,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACvC,iBAAW,GAAG,UAAU,MAAM;AAC7B,mBAAW,GAAG,IAAI,mBAAmB;AAErC,qBAAa;AAEb,mBAAW,GAAG,IAAI,mBAAmB,WAAS;AAC7C,cAAI,OAAO;AACV,iBAAK,kBAAkB,YAAY,YAAY,KAAK,IAAI,oBAAoB,KAAK,EAAE;AAEnF,mBAAO,OAAO,KAAK;AAAA,UACpB;AAEA,iBAAO,QAAQ;AAAA,QAChB,CAAC;AAAA,MACF,CAAC;AAAA,IACF,CAAC;AAAA,EACF;AAAA,EAEQ,QAAQ,YAAiC,KAAa,aAAwC,cAAkC;AACvI,UAAM,OAAO,WAAW,GAAG,QAAQ,GAAG;AAEtC,UAAM,yBAAyB,wBAAC,UAAiB;AAChD,WAAK,kBAAkB,YAAY,YAAY,KAAK,IAAI,gBAAgB,KAAK,KAAK,GAAG,eAAe,aAAa,CAAC,EAAE;AAAA,IACrH,GAF+B;AAI/B,SAAK,GAAG,SAAS,sBAAsB;AAEvC,gBAAY,IAAI;AAEhB,SAAK,SAAS,WAAS;AACtB,UAAI,OAAO;AACV,+BAAuB,KAAK;AAAA,MAC7B;AAEA,WAAK,eAAe,SAAS,sBAAsB;AAAA,IACpD,CAAC;AAAA,EACF;AACD;AAEA,MAAM,4BAA4B;AAAA,EAhblC,OAgbkC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAKjC,OAAwB,uBAAuB;AAAA,EAE9B;AAAA,EACA;AAAA,EAEjB,YAAY,SAAgD;AAC3D,QAAI,WAAW,OAAO,QAAQ,aAAa,cAAc,QAAQ,IAAI,4BAA4B,oBAAoB,GAAG;AACvH,WAAK,WAAW,QAAQ;AAAA,IACzB;AAEA,QAAI,WAAW,OAAO,QAAQ,aAAa,YAAY;AACtD,WAAK,WAAW,QAAQ;AAAA,IACzB;AAAA,EACD;AAAA,EAEA,IAAI,YAAqB;AACxB,WAAO,CAAC,CAAC,KAAK;AAAA,EACf;AAAA,EAEA,MAAM,KAAmB;AACxB,SAAK,WAAW,GAAG;AAAA,EACpB;AAAA,EAEA,MAAM,OAA6B;AAClC,SAAK,WAAW,KAAK;AAAA,EACtB;AACD;",
  "names": ["error"]
}
