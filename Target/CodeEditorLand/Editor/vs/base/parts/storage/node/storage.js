import*as l from"fs";import{timeout as p}from"../../../common/async.js";import{Event as E}from"../../../common/event.js";import{mapToString as I,setToString as f}from"../../../common/map.js";import{basename as T}from"../../../common/path.js";import{Promises as u}from"../../../node/pfs.js";import"../common/storage.js";class h{constructor(e,t=Object.create(null)){this.path=e;this.options=t}static IN_MEMORY_PATH=":memory:";get onDidChangeItemsExternal(){return E.None}static BUSY_OPEN_TIMEOUT=2e3;static MAX_HOST_PARAMETERS=256;name=T(this.path);logger=new c(this.options.logging);whenConnected=this.connect(this.path);async getItems(){const e=await this.whenConnected,t=new Map;return(await this.all(e,"SELECT * FROM ItemTable")).forEach(i=>t.set(i.key,i.value)),this.logger.isTracing&&this.logger.trace(`[storage ${this.name}] getItems(): ${t.size} rows`),t}async updateItems(e){const t=await this.whenConnected;return this.doUpdateItems(t,e)}doUpdateItems(e,t){return this.logger.isTracing&&this.logger.trace(`[storage ${this.name}] updateItems(): insert(${t.insert?I(t.insert):"0"}), delete(${t.delete?f(t.delete):"0"})`),this.transaction(e,()=>{const n=t.insert,i=t.delete;if(n&&n.size>0){const r=[];r.push([]);let o=0;n.forEach((s,a)=>{let g=r[o];g.length>h.MAX_HOST_PARAMETERS&&(o++,g=[],r.push(g)),g.push(a,s)}),r.forEach(s=>{this.prepare(e,`INSERT INTO ItemTable VALUES ${new Array(s.length/2).fill("(?,?)").join(",")}`,a=>a.run(s),()=>{const a=[];let g=0;return n.forEach((d,m)=>{a.push(m),g+=d.length}),`Keys: ${a.join(", ")} Length: ${g}`})})}if(i&&i.size){const r=[];r.push([]);let o=0;i.forEach(s=>{let a=r[o];a.length>h.MAX_HOST_PARAMETERS&&(o++,a=[],r.push(a)),a.push(s)}),r.forEach(s=>{this.prepare(e,`DELETE FROM ItemTable WHERE key IN (${new Array(s.length).fill("?").join(",")})`,a=>a.run(s),()=>{const a=[];return i.forEach(g=>{a.push(g)}),`Keys: ${a.join(", ")}`})})}})}async optimize(){this.logger.trace(`[storage ${this.name}] vacuum()`);const e=await this.whenConnected;return this.exec(e,"VACUUM")}async close(e){this.logger.trace(`[storage ${this.name}] close()`);const t=await this.whenConnected;return this.doClose(t,e)}doClose(e,t){return new Promise((n,i)=>{e.db.close(r=>(r&&this.handleSQLiteError(e,`[storage ${this.name}] close(): ${r}`),this.path===h.IN_MEMORY_PATH?n():!e.isErroneous&&!e.isInMemory?this.backup().then(n,o=>(this.logger.error(`[storage ${this.name}] backup(): ${o}`),n())):typeof t=="function"?l.promises.unlink(this.path).then(()=>this.doConnect(this.path).then(o=>{const s=()=>this.doClose(o,void 0);return this.doUpdateItems(o,{insert:t()}).then(()=>s(),a=>(s(),Promise.reject(a)))})).then(n,i):i(r||new Error("Database has errors or is in-memory without recovery option"))))})}backup(){const e=this.toBackupPath(this.path);return u.copy(this.path,e,{preserveSymlinks:!1})}toBackupPath(e){return`${e}.backup`}async checkIntegrity(e){this.logger.trace(`[storage ${this.name}] checkIntegrity(full: ${e})`);const t=await this.whenConnected,n=await this.get(t,e?"PRAGMA integrity_check":"PRAGMA quick_check"),i=e?n.integrity_check:n.quick_check;return t.isErroneous?`${i} (last error: ${t.lastError})`:t.isInMemory?`${i} (in-memory!)`:i}async connect(e,t=!0){this.logger.trace(`[storage ${this.name}] open(${e}, retryOnBusy: ${t})`);try{return await this.doConnect(e)}catch(n){if(this.logger.error(`[storage ${this.name}] open(): Unable to open DB due to ${n}`),n.code==="SQLITE_BUSY"&&t)return await p(h.BUSY_OPEN_TIMEOUT),this.connect(e,!1);try{await l.promises.unlink(e);try{await u.rename(this.toBackupPath(e),e,!1)}catch{}return await this.doConnect(e)}catch(i){return this.logger.error(`[storage ${this.name}] open(): Unable to use backup due to ${i}`),this.doConnect(h.IN_MEMORY_PATH)}}}handleSQLiteError(e,t){e.isErroneous=!0,e.lastError=t,this.logger.error(t)}doConnect(e){return new Promise((t,n)=>{import("@vscode/sqlite3").then(i=>{const r=this.logger.isTracing?i.default.verbose().Database:i.default.Database,o={db:new r(e,s=>s?o.db&&s.code!=="SQLITE_CANTOPEN"?o.db.close(()=>n(s)):n(s):this.exec(o,["PRAGMA user_version = 1;","CREATE TABLE IF NOT EXISTS ItemTable (key TEXT UNIQUE ON CONFLICT REPLACE, value BLOB)"].join("")).then(()=>t(o),a=>o.db.close(()=>n(a)))),isInMemory:e===h.IN_MEMORY_PATH};o.db.on("error",s=>this.handleSQLiteError(o,`[storage ${this.name}] Error (event): ${s}`)),this.logger.isTracing&&o.db.on("trace",s=>this.logger.trace(`[storage ${this.name}] Trace (event): ${s}`))},n)})}exec(e,t){return new Promise((n,i)=>{e.db.exec(t,r=>r?(this.handleSQLiteError(e,`[storage ${this.name}] exec(): ${r}`),i(r)):n())})}get(e,t){return new Promise((n,i)=>{e.db.get(t,(r,o)=>r?(this.handleSQLiteError(e,`[storage ${this.name}] get(): ${r}`),i(r)):n(o))})}all(e,t){return new Promise((n,i)=>{e.db.all(t,(r,o)=>r?(this.handleSQLiteError(e,`[storage ${this.name}] all(): ${r}`),i(r)):n(o))})}transaction(e,t){return new Promise((n,i)=>{e.db.serialize(()=>{e.db.run("BEGIN TRANSACTION"),t(),e.db.run("END TRANSACTION",r=>r?(this.handleSQLiteError(e,`[storage ${this.name}] transaction(): ${r}`),i(r)):n())})})}prepare(e,t,n,i){const r=e.db.prepare(t),o=s=>{this.handleSQLiteError(e,`[storage ${this.name}] prepare(): ${s} (${t}). Details: ${i()}`)};r.on("error",o),n(r),r.finalize(s=>{s&&o(s),r.removeListener("error",o)})}}class c{static VSCODE_TRACE_STORAGE="VSCODE_TRACE_STORAGE";logTrace;logError;constructor(e){e&&typeof e.logTrace=="function"&&process.env[c.VSCODE_TRACE_STORAGE]&&(this.logTrace=e.logTrace),e&&typeof e.logError=="function"&&(this.logError=e.logError)}get isTracing(){return!!this.logTrace}trace(e){this.logTrace?.(e)}error(e){this.logError?.(e)}}export{h as SQLiteStorageDatabase};
