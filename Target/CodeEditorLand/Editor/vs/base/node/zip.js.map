{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/node/zip.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createWriteStream, WriteStream, promises } from 'fs';\nimport { Readable } from 'stream';\nimport { createCancelablePromise, Sequencer } from '../common/async.js';\nimport { CancellationToken } from '../common/cancellation.js';\nimport * as path from '../common/path.js';\nimport { assertIsDefined } from '../common/types.js';\nimport { Promises } from './pfs.js';\nimport * as nls from '../../nls.js';\nimport type { Entry, ZipFile } from 'yauzl';\n\nexport const CorruptZipMessage: string = 'end of central directory record signature not found';\nconst CORRUPT_ZIP_PATTERN = new RegExp(CorruptZipMessage);\n\nexport interface IExtractOptions {\n\toverwrite?: boolean;\n\n\t/**\n\t * Source path within the ZIP archive. Only the files contained in this\n\t * path will be extracted.\n\t */\n\tsourcePath?: string;\n}\n\ninterface IOptions {\n\tsourcePathRegex: RegExp;\n}\n\nexport type ExtractErrorType = 'CorruptZip' | 'Incomplete';\n\nexport class ExtractError extends Error {\n\n\treadonly type?: ExtractErrorType;\n\n\tconstructor(type: ExtractErrorType | undefined, cause: Error) {\n\t\tlet message = cause.message;\n\n\t\tswitch (type) {\n\t\t\tcase 'CorruptZip': message = `Corrupt ZIP: ${message}`; break;\n\t\t}\n\n\t\tsuper(message);\n\t\tthis.type = type;\n\t\tthis.cause = cause;\n\t}\n}\n\nfunction modeFromEntry(entry: Entry) {\n\tconst attr = entry.externalFileAttributes >> 16 || 33188;\n\n\treturn [448 /* S_IRWXU */, 56 /* S_IRWXG */, 7 /* S_IRWXO */]\n\t\t.map(mask => attr & mask)\n\t\t.reduce((a, b) => a + b, attr & 61440 /* S_IFMT */);\n}\n\nfunction toExtractError(err: Error): ExtractError {\n\tif (err instanceof ExtractError) {\n\t\treturn err;\n\t}\n\n\tlet type: ExtractErrorType | undefined = undefined;\n\n\tif (CORRUPT_ZIP_PATTERN.test(err.message)) {\n\t\ttype = 'CorruptZip';\n\t}\n\n\treturn new ExtractError(type, err);\n}\n\nfunction extractEntry(stream: Readable, fileName: string, mode: number, targetPath: string, options: IOptions, token: CancellationToken): Promise<void> {\n\tconst dirName = path.dirname(fileName);\n\tconst targetDirName = path.join(targetPath, dirName);\n\tif (!targetDirName.startsWith(targetPath)) {\n\t\treturn Promise.reject(new Error(nls.localize('invalid file', \"Error extracting {0}. Invalid file.\", fileName)));\n\t}\n\tconst targetFileName = path.join(targetPath, fileName);\n\n\tlet istream: WriteStream;\n\n\ttoken.onCancellationRequested(() => {\n\t\tistream?.destroy();\n\t});\n\n\treturn Promise.resolve(promises.mkdir(targetDirName, { recursive: true })).then(() => new Promise<void>((c, e) => {\n\t\tif (token.isCancellationRequested) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tistream = createWriteStream(targetFileName, { mode });\n\t\t\tistream.once('close', () => c());\n\t\t\tistream.once('error', e);\n\t\t\tstream.once('error', e);\n\t\t\tstream.pipe(istream);\n\t\t} catch (error) {\n\t\t\te(error);\n\t\t}\n\t}));\n}\n\nfunction extractZip(zipfile: ZipFile, targetPath: string, options: IOptions, token: CancellationToken): Promise<void> {\n\tlet last = createCancelablePromise<void>(() => Promise.resolve());\n\tlet extractedEntriesCount = 0;\n\n\tconst listener = token.onCancellationRequested(() => {\n\t\tlast.cancel();\n\t\tzipfile.close();\n\t});\n\n\treturn new Promise<void>((c, e) => {\n\t\tconst throttler = new Sequencer();\n\n\t\tconst readNextEntry = (token: CancellationToken) => {\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\textractedEntriesCount++;\n\t\t\tzipfile.readEntry();\n\t\t};\n\n\t\tzipfile.once('error', e);\n\t\tzipfile.once('close', () => last.then(() => {\n\t\t\tif (token.isCancellationRequested || zipfile.entryCount === extractedEntriesCount) {\n\t\t\t\tc();\n\t\t\t} else {\n\t\t\t\te(new ExtractError('Incomplete', new Error(nls.localize('incompleteExtract', \"Incomplete. Found {0} of {1} entries\", extractedEntriesCount, zipfile.entryCount))));\n\t\t\t}\n\t\t}, e));\n\t\tzipfile.readEntry();\n\t\tzipfile.on('entry', (entry: Entry) => {\n\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!options.sourcePathRegex.test(entry.fileName)) {\n\t\t\t\treadNextEntry(token);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst fileName = entry.fileName.replace(options.sourcePathRegex, '');\n\n\t\t\t// directory file names end with '/'\n\t\t\tif (/\\/$/.test(fileName)) {\n\t\t\t\tconst targetFileName = path.join(targetPath, fileName);\n\t\t\t\tlast = createCancelablePromise(token => promises.mkdir(targetFileName, { recursive: true }).then(() => readNextEntry(token)).then(undefined, e));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst stream = openZipStream(zipfile, entry);\n\t\t\tconst mode = modeFromEntry(entry);\n\n\t\t\tlast = createCancelablePromise(token => throttler.queue(() => stream.then(stream => extractEntry(stream, fileName, mode, targetPath, options, token).then(() => readNextEntry(token)))).then(null, e));\n\t\t});\n\t}).finally(() => listener.dispose());\n}\n\nasync function openZip(zipFile: string, lazy: boolean = false): Promise<ZipFile> {\n\tconst { open } = await import('yauzl');\n\n\treturn new Promise<ZipFile>((resolve, reject) => {\n\t\topen(zipFile, lazy ? { lazyEntries: true } : undefined!, (error: Error | null, zipfile?: ZipFile) => {\n\t\t\tif (error) {\n\t\t\t\treject(toExtractError(error));\n\t\t\t} else {\n\t\t\t\tresolve(assertIsDefined(zipfile));\n\t\t\t}\n\t\t});\n\t});\n}\n\nfunction openZipStream(zipFile: ZipFile, entry: Entry): Promise<Readable> {\n\treturn new Promise<Readable>((resolve, reject) => {\n\t\tzipFile.openReadStream(entry, (error: Error | null, stream?: Readable) => {\n\t\t\tif (error) {\n\t\t\t\treject(toExtractError(error));\n\t\t\t} else {\n\t\t\t\tresolve(assertIsDefined(stream));\n\t\t\t}\n\t\t});\n\t});\n}\n\nexport interface IFile {\n\tpath: string;\n\tcontents?: Buffer | string;\n\tlocalPath?: string;\n}\n\nexport async function zip(zipPath: string, files: IFile[]): Promise<string> {\n\tconst { ZipFile } = await import('yazl');\n\n\treturn new Promise<string>((c, e) => {\n\t\tconst zip = new ZipFile();\n\t\tfiles.forEach(f => {\n\t\t\tif (f.contents) {\n\t\t\t\tzip.addBuffer(typeof f.contents === 'string' ? Buffer.from(f.contents, 'utf8') : f.contents, f.path);\n\t\t\t} else if (f.localPath) {\n\t\t\t\tzip.addFile(f.localPath, f.path);\n\t\t\t}\n\t\t});\n\t\tzip.end();\n\n\t\tconst zipStream = createWriteStream(zipPath);\n\t\tzip.outputStream.pipe(zipStream);\n\n\t\tzip.outputStream.once('error', e);\n\t\tzipStream.once('error', e);\n\t\tzipStream.once('finish', () => c(zipPath));\n\t});\n}\n\nexport function extract(zipPath: string, targetPath: string, options: IExtractOptions = {}, token: CancellationToken): Promise<void> {\n\tconst sourcePathRegex = new RegExp(options.sourcePath ? `^${options.sourcePath}` : '');\n\n\tlet promise = openZip(zipPath, true);\n\n\tif (options.overwrite) {\n\t\tpromise = promise.then(zipfile => Promises.rm(targetPath).then(() => zipfile));\n\t}\n\n\treturn promise.then(zipfile => extractZip(zipfile, targetPath, { sourcePathRegex }, token));\n}\n\nfunction read(zipPath: string, filePath: string): Promise<Readable> {\n\treturn openZip(zipPath).then(zipfile => {\n\t\treturn new Promise<Readable>((c, e) => {\n\t\t\tzipfile.on('entry', (entry: Entry) => {\n\t\t\t\tif (entry.fileName === filePath) {\n\t\t\t\t\topenZipStream(zipfile, entry).then(stream => c(stream), err => e(err));\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tzipfile.once('close', () => e(new Error(nls.localize('notFound', \"{0} not found inside zip.\", filePath))));\n\t\t});\n\t});\n}\n\nexport function buffer(zipPath: string, filePath: string): Promise<Buffer> {\n\treturn read(zipPath, filePath).then(stream => {\n\t\treturn new Promise<Buffer>((c, e) => {\n\t\t\tconst buffers: Buffer[] = [];\n\t\t\tstream.once('error', e);\n\t\t\tstream.on('data', (b: Buffer) => buffers.push(b));\n\t\t\tstream.on('end', () => c(Buffer.concat(buffers)));\n\t\t});\n\t});\n}\n"],
  "mappings": "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",
  "names": ["token", "stream", "zip"]
}
