{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/node/zip.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { type WriteStream, createWriteStream, promises } from \"fs\";\nimport type { Readable } from \"stream\";\nimport type { Entry, ZipFile } from \"yauzl\";\nimport * as nls from \"../../nls.js\";\nimport { Sequencer, createCancelablePromise } from \"../common/async.js\";\nimport type { CancellationToken } from \"../common/cancellation.js\";\nimport * as path from \"../common/path.js\";\nimport { assertIsDefined } from \"../common/types.js\";\nimport { Promises } from \"./pfs.js\";\n\nexport const CorruptZipMessage: string =\n\t\"end of central directory record signature not found\";\nconst CORRUPT_ZIP_PATTERN = new RegExp(CorruptZipMessage);\n\nexport interface IExtractOptions {\n\toverwrite?: boolean;\n\n\t/**\n\t * Source path within the ZIP archive. Only the files contained in this\n\t * path will be extracted.\n\t */\n\tsourcePath?: string;\n}\n\ninterface IOptions {\n\tsourcePathRegex: RegExp;\n}\n\nexport type ExtractErrorType = \"CorruptZip\" | \"Incomplete\";\n\nexport class ExtractError extends Error {\n\treadonly type?: ExtractErrorType;\n\n\tconstructor(type: ExtractErrorType | undefined, cause: Error) {\n\t\tlet message = cause.message;\n\n\t\tswitch (type) {\n\t\t\tcase \"CorruptZip\":\n\t\t\t\tmessage = `Corrupt ZIP: ${message}`;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tsuper(message);\n\t\tthis.type = type;\n\t\tthis.cause = cause;\n\t}\n}\n\nfunction modeFromEntry(entry: Entry) {\n\tconst attr = entry.externalFileAttributes >> 16 || 33188;\n\n\treturn [448 /* S_IRWXU */, 56 /* S_IRWXG */, 7 /* S_IRWXO */]\n\t\t.map((mask) => attr & mask)\n\t\t.reduce((a, b) => a + b, attr & 61440 /* S_IFMT */);\n}\n\nfunction toExtractError(err: Error): ExtractError {\n\tif (err instanceof ExtractError) {\n\t\treturn err;\n\t}\n\n\tlet type: ExtractErrorType | undefined;\n\n\tif (CORRUPT_ZIP_PATTERN.test(err.message)) {\n\t\ttype = \"CorruptZip\";\n\t}\n\n\treturn new ExtractError(type, err);\n}\n\nfunction extractEntry(\n\tstream: Readable,\n\tfileName: string,\n\tmode: number,\n\ttargetPath: string,\n\toptions: IOptions,\n\ttoken: CancellationToken,\n): Promise<void> {\n\tconst dirName = path.dirname(fileName);\n\tconst targetDirName = path.join(targetPath, dirName);\n\tif (!targetDirName.startsWith(targetPath)) {\n\t\treturn Promise.reject(\n\t\t\tnew Error(\n\t\t\t\tnls.localize(\n\t\t\t\t\t\"invalid file\",\n\t\t\t\t\t\"Error extracting {0}. Invalid file.\",\n\t\t\t\t\tfileName,\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\t}\n\tconst targetFileName = path.join(targetPath, fileName);\n\n\tlet istream: WriteStream;\n\n\ttoken.onCancellationRequested(() => {\n\t\tistream?.destroy();\n\t});\n\n\treturn Promise.resolve(\n\t\tpromises.mkdir(targetDirName, { recursive: true }),\n\t).then(\n\t\t() =>\n\t\t\tnew Promise<void>((c, e) => {\n\t\t\t\tif (token.isCancellationRequested) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tistream = createWriteStream(targetFileName, { mode });\n\t\t\t\t\tistream.once(\"close\", () => c());\n\t\t\t\t\tistream.once(\"error\", e);\n\t\t\t\t\tstream.once(\"error\", e);\n\t\t\t\t\tstream.pipe(istream);\n\t\t\t\t} catch (error) {\n\t\t\t\t\te(error);\n\t\t\t\t}\n\t\t\t}),\n\t);\n}\n\nfunction extractZip(\n\tzipfile: ZipFile,\n\ttargetPath: string,\n\toptions: IOptions,\n\ttoken: CancellationToken,\n): Promise<void> {\n\tlet last = createCancelablePromise<void>(() => Promise.resolve());\n\tlet extractedEntriesCount = 0;\n\n\tconst listener = token.onCancellationRequested(() => {\n\t\tlast.cancel();\n\t\tzipfile.close();\n\t});\n\n\treturn new Promise<void>((c, e) => {\n\t\tconst throttler = new Sequencer();\n\n\t\tconst readNextEntry = (token: CancellationToken) => {\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\textractedEntriesCount++;\n\t\t\tzipfile.readEntry();\n\t\t};\n\n\t\tzipfile.once(\"error\", e);\n\t\tzipfile.once(\"close\", () =>\n\t\t\tlast.then(() => {\n\t\t\t\tif (\n\t\t\t\t\ttoken.isCancellationRequested ||\n\t\t\t\t\tzipfile.entryCount === extractedEntriesCount\n\t\t\t\t) {\n\t\t\t\t\tc();\n\t\t\t\t} else {\n\t\t\t\t\te(\n\t\t\t\t\t\tnew ExtractError(\n\t\t\t\t\t\t\t\"Incomplete\",\n\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\tnls.localize(\n\t\t\t\t\t\t\t\t\t\"incompleteExtract\",\n\t\t\t\t\t\t\t\t\t\"Incomplete. Found {0} of {1} entries\",\n\t\t\t\t\t\t\t\t\textractedEntriesCount,\n\t\t\t\t\t\t\t\t\tzipfile.entryCount,\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}, e),\n\t\t);\n\t\tzipfile.readEntry();\n\t\tzipfile.on(\"entry\", (entry: Entry) => {\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!options.sourcePathRegex.test(entry.fileName)) {\n\t\t\t\treadNextEntry(token);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst fileName = entry.fileName.replace(\n\t\t\t\toptions.sourcePathRegex,\n\t\t\t\t\"\",\n\t\t\t);\n\n\t\t\t// directory file names end with '/'\n\t\t\tif (/\\/$/.test(fileName)) {\n\t\t\t\tconst targetFileName = path.join(targetPath, fileName);\n\t\t\t\tlast = createCancelablePromise((token) =>\n\t\t\t\t\tpromises\n\t\t\t\t\t\t.mkdir(targetFileName, { recursive: true })\n\t\t\t\t\t\t.then(() => readNextEntry(token))\n\t\t\t\t\t\t.then(undefined, e),\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst stream = openZipStream(zipfile, entry);\n\t\t\tconst mode = modeFromEntry(entry);\n\n\t\t\tlast = createCancelablePromise((token) =>\n\t\t\t\tthrottler\n\t\t\t\t\t.queue(() =>\n\t\t\t\t\t\tstream.then((stream) =>\n\t\t\t\t\t\t\textractEntry(\n\t\t\t\t\t\t\t\tstream,\n\t\t\t\t\t\t\t\tfileName,\n\t\t\t\t\t\t\t\tmode,\n\t\t\t\t\t\t\t\ttargetPath,\n\t\t\t\t\t\t\t\toptions,\n\t\t\t\t\t\t\t\ttoken,\n\t\t\t\t\t\t\t).then(() => readNextEntry(token)),\n\t\t\t\t\t\t),\n\t\t\t\t\t)\n\t\t\t\t\t.then(null, e),\n\t\t\t);\n\t\t});\n\t}).finally(() => listener.dispose());\n}\n\nasync function openZip(zipFile: string, lazy = false): Promise<ZipFile> {\n\tconst { open } = await import(\"yauzl\");\n\n\treturn new Promise<ZipFile>((resolve, reject) => {\n\t\topen(\n\t\t\tzipFile,\n\t\t\tlazy ? { lazyEntries: true } : undefined!,\n\t\t\t(error: Error | null, zipfile?: ZipFile) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treject(toExtractError(error));\n\t\t\t\t} else {\n\t\t\t\t\tresolve(assertIsDefined(zipfile));\n\t\t\t\t}\n\t\t\t},\n\t\t);\n\t});\n}\n\nfunction openZipStream(zipFile: ZipFile, entry: Entry): Promise<Readable> {\n\treturn new Promise<Readable>((resolve, reject) => {\n\t\tzipFile.openReadStream(\n\t\t\tentry,\n\t\t\t(error: Error | null, stream?: Readable) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treject(toExtractError(error));\n\t\t\t\t} else {\n\t\t\t\t\tresolve(assertIsDefined(stream));\n\t\t\t\t}\n\t\t\t},\n\t\t);\n\t});\n}\n\nexport interface IFile {\n\tpath: string;\n\tcontents?: Buffer | string;\n\tlocalPath?: string;\n}\n\nexport async function zip(zipPath: string, files: IFile[]): Promise<string> {\n\tconst { ZipFile } = await import(\"yazl\");\n\n\treturn new Promise<string>((c, e) => {\n\t\tconst zip = new ZipFile();\n\t\tfiles.forEach((f) => {\n\t\t\tif (f.contents) {\n\t\t\t\tzip.addBuffer(\n\t\t\t\t\ttypeof f.contents === \"string\"\n\t\t\t\t\t\t? Buffer.from(f.contents, \"utf8\")\n\t\t\t\t\t\t: f.contents,\n\t\t\t\t\tf.path,\n\t\t\t\t);\n\t\t\t} else if (f.localPath) {\n\t\t\t\tzip.addFile(f.localPath, f.path);\n\t\t\t}\n\t\t});\n\t\tzip.end();\n\n\t\tconst zipStream = createWriteStream(zipPath);\n\t\tzip.outputStream.pipe(zipStream);\n\n\t\tzip.outputStream.once(\"error\", e);\n\t\tzipStream.once(\"error\", e);\n\t\tzipStream.once(\"finish\", () => c(zipPath));\n\t});\n}\n\nexport function extract(\n\tzipPath: string,\n\ttargetPath: string,\n\toptions: IExtractOptions = {},\n\ttoken: CancellationToken,\n): Promise<void> {\n\tconst sourcePathRegex = new RegExp(\n\t\toptions.sourcePath ? `^${options.sourcePath}` : \"\",\n\t);\n\n\tlet promise = openZip(zipPath, true);\n\n\tif (options.overwrite) {\n\t\tpromise = promise.then((zipfile) =>\n\t\t\tPromises.rm(targetPath).then(() => zipfile),\n\t\t);\n\t}\n\n\treturn promise.then((zipfile) =>\n\t\textractZip(zipfile, targetPath, { sourcePathRegex }, token),\n\t);\n}\n\nfunction read(zipPath: string, filePath: string): Promise<Readable> {\n\treturn openZip(zipPath).then((zipfile) => {\n\t\treturn new Promise<Readable>((c, e) => {\n\t\t\tzipfile.on(\"entry\", (entry: Entry) => {\n\t\t\t\tif (entry.fileName === filePath) {\n\t\t\t\t\topenZipStream(zipfile, entry).then(\n\t\t\t\t\t\t(stream) => c(stream),\n\t\t\t\t\t\t(err) => e(err),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tzipfile.once(\"close\", () =>\n\t\t\t\te(\n\t\t\t\t\tnew Error(\n\t\t\t\t\t\tnls.localize(\n\t\t\t\t\t\t\t\"notFound\",\n\t\t\t\t\t\t\t\"{0} not found inside zip.\",\n\t\t\t\t\t\t\tfilePath,\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t);\n\t\t});\n\t});\n}\n\nexport function buffer(zipPath: string, filePath: string): Promise<Buffer> {\n\treturn read(zipPath, filePath).then((stream) => {\n\t\treturn new Promise<Buffer>((c, e) => {\n\t\t\tconst buffers: Buffer[] = [];\n\t\t\tstream.once(\"error\", e);\n\t\t\tstream.on(\"data\", (b: Buffer) => buffers.push(b));\n\t\t\tstream.on(\"end\", () => c(Buffer.concat(buffers)));\n\t\t});\n\t});\n}\n"],
  "mappings": "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",
  "names": ["token", "stream", "zip"]
}
