{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/node/processes.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type * as cp from \"child_process\";\nimport { type Stats, promises } from \"fs\";\nimport * as path from \"../common/path.js\";\nimport * as Platform from \"../common/platform.js\";\nimport * as process from \"../common/process.js\";\nimport {\n\ttype CommandOptions,\n\ttype ForkOptions,\n\tSource,\n\ttype SuccessData,\n\ttype TerminateResponse,\n\tTerminateResponseCode,\n} from \"../common/processes.js\";\nimport * as Types from \"../common/types.js\";\nimport * as pfs from \"./pfs.js\";\nexport {\n\ttype CommandOptions,\n\ttype ForkOptions,\n\ttype SuccessData,\n\tSource,\n\ttype TerminateResponse,\n\tTerminateResponseCode,\n};\n\nexport type ValueCallback<T> = (value: T | Promise<T>) => void;\nexport type ErrorCallback = (error?: any) => void;\nexport type ProgressCallback<T> = (progress: T) => void;\n\nexport function getWindowsShell(\n\tenv = process.env as Platform.IProcessEnvironment,\n): string {\n\treturn env[\"comspec\"] || \"cmd.exe\";\n}\n\nexport interface IQueuedSender {\n\tsend: (msg: any) => void;\n}\n\n// Wrapper around process.send() that will queue any messages if the internal node.js\n// queue is filled with messages and only continue sending messages when the internal\n// queue is free again to consume messages.\n// On Windows we always wait for the send() method to return before sending the next message\n// to workaround https://github.com/nodejs/node/issues/7657 (IPC can freeze process)\nexport function createQueuedSender(\n\tchildProcess: cp.ChildProcess,\n): IQueuedSender {\n\tlet msgQueue: string[] = [];\n\tlet useQueue = false;\n\n\tconst send = (msg: any): void => {\n\t\tif (useQueue) {\n\t\t\tmsgQueue.push(msg); // add to the queue if the process cannot handle more messages\n\t\t\treturn;\n\t\t}\n\n\t\tconst result = childProcess.send(msg, (error: Error | null) => {\n\t\t\tif (error) {\n\t\t\t\tconsole.error(error); // unlikely to happen, best we can do is log this error\n\t\t\t}\n\n\t\t\tuseQueue = false; // we are good again to send directly without queue\n\n\t\t\t// now send all the messages that we have in our queue and did not send yet\n\t\t\tif (msgQueue.length > 0) {\n\t\t\t\tconst msgQueueCopy = msgQueue.slice(0);\n\t\t\t\tmsgQueue = [];\n\t\t\t\tmsgQueueCopy.forEach((entry) => send(entry));\n\t\t\t}\n\t\t});\n\n\t\tif (\n\t\t\t!result ||\n\t\t\tPlatform.isWindows /* workaround https://github.com/nodejs/node/issues/7657 */\n\t\t) {\n\t\t\tuseQueue = true;\n\t\t}\n\t};\n\n\treturn { send };\n}\n\nexport namespace win32 {\n\texport async function findExecutable(\n\t\tcommand: string,\n\t\tcwd?: string,\n\t\tpaths?: string[],\n\t): Promise<string> {\n\t\t// If we have an absolute path then we take it.\n\t\tif (path.isAbsolute(command)) {\n\t\t\treturn command;\n\t\t}\n\t\tif (cwd === undefined) {\n\t\t\tcwd = process.cwd();\n\t\t}\n\t\tconst dir = path.dirname(command);\n\t\tif (dir !== \".\") {\n\t\t\t// We have a directory and the directory is relative (see above). Make the path absolute\n\t\t\t// to the current working directory.\n\t\t\treturn path.join(cwd, command);\n\t\t}\n\t\tif (paths === undefined && Types.isString(process.env[\"PATH\"])) {\n\t\t\tpaths = process.env[\"PATH\"].split(path.delimiter);\n\t\t}\n\t\t// No PATH environment. Make path absolute to the cwd.\n\t\tif (paths === undefined || paths.length === 0) {\n\t\t\treturn path.join(cwd, command);\n\t\t}\n\n\t\tasync function fileExists(path: string): Promise<boolean> {\n\t\t\tif (await pfs.Promises.exists(path)) {\n\t\t\t\tlet statValue: Stats | undefined;\n\t\t\t\ttry {\n\t\t\t\t\tstatValue = await promises.stat(path);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (e.message.startsWith(\"EACCES\")) {\n\t\t\t\t\t\t// it might be symlink\n\t\t\t\t\t\tstatValue = await promises.lstat(path);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn statValue ? !statValue.isDirectory() : false;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t// We have a simple file name. We get the path variable from the env\n\t\t// and try to find the executable on the path.\n\t\tfor (const pathEntry of paths) {\n\t\t\t// The path entry is absolute.\n\t\t\tlet fullPath: string;\n\t\t\tif (path.isAbsolute(pathEntry)) {\n\t\t\t\tfullPath = path.join(pathEntry, command);\n\t\t\t} else {\n\t\t\t\tfullPath = path.join(cwd, pathEntry, command);\n\t\t\t}\n\t\t\tif (await fileExists(fullPath)) {\n\t\t\t\treturn fullPath;\n\t\t\t}\n\t\t\tlet withExtension = fullPath + \".com\";\n\t\t\tif (await fileExists(withExtension)) {\n\t\t\t\treturn withExtension;\n\t\t\t}\n\t\t\twithExtension = fullPath + \".exe\";\n\t\t\tif (await fileExists(withExtension)) {\n\t\t\t\treturn withExtension;\n\t\t\t}\n\t\t}\n\t\treturn path.join(cwd, command);\n\t}\n}\n"],
  "mappings": ";;AAMA,SAAqB,gBAAgB;AACrC,YAAY,UAAU;AACtB,YAAY,cAAc;AAC1B,YAAY,aAAa;AACzB;AAAA,EAGC;AAAA,EAGA;AAAA,OACM;AACP,YAAY,WAAW;AACvB,YAAY,SAAS;AAcd,SAAS,gBACf,MAAM,QAAQ,KACL;AACT,SAAO,IAAI,SAAS,KAAK;AAC1B;AAJgB;AAeT,SAAS,mBACf,cACgB;AAChB,MAAI,WAAqB,CAAC;AAC1B,MAAI,WAAW;AAEf,QAAM,OAAO,wBAAC,QAAmB;AAChC,QAAI,UAAU;AACb,eAAS,KAAK,GAAG;AACjB;AAAA,IACD;AAEA,UAAM,SAAS,aAAa,KAAK,KAAK,CAAC,UAAwB;AAC9D,UAAI,OAAO;AACV,gBAAQ,MAAM,KAAK;AAAA,MACpB;AAEA,iBAAW;AAGX,UAAI,SAAS,SAAS,GAAG;AACxB,cAAM,eAAe,SAAS,MAAM,CAAC;AACrC,mBAAW,CAAC;AACZ,qBAAa,QAAQ,CAAC,UAAU,KAAK,KAAK,CAAC;AAAA,MAC5C;AAAA,IACD,CAAC;AAED,QACC,CAAC,UACD,SAAS,WACR;AACD,iBAAW;AAAA,IACZ;AAAA,EACD,GA3Ba;AA6Bb,SAAO,EAAE,KAAK;AACf;AApCgB;AAsCT,IAAU;AAAA,CAAV,CAAUA,WAAV;AACN,iBAAsB,eACrB,SACA,KACA,OACkB;AAElB,QAAI,KAAK,WAAW,OAAO,GAAG;AAC7B,aAAO;AAAA,IACR;AACA,QAAI,QAAQ,QAAW;AACtB,YAAM,QAAQ,IAAI;AAAA,IACnB;AACA,UAAM,MAAM,KAAK,QAAQ,OAAO;AAChC,QAAI,QAAQ,KAAK;AAGhB,aAAO,KAAK,KAAK,KAAK,OAAO;AAAA,IAC9B;AACA,QAAI,UAAU,UAAa,MAAM,SAAS,QAAQ,IAAI,MAAM,CAAC,GAAG;AAC/D,cAAQ,QAAQ,IAAI,MAAM,EAAE,MAAM,KAAK,SAAS;AAAA,IACjD;AAEA,QAAI,UAAU,UAAa,MAAM,WAAW,GAAG;AAC9C,aAAO,KAAK,KAAK,KAAK,OAAO;AAAA,IAC9B;AAEA,mBAAe,WAAWC,OAAgC;AACzD,UAAI,MAAM,IAAI,SAAS,OAAOA,KAAI,GAAG;AACpC,YAAI;AACJ,YAAI;AACH,sBAAY,MAAM,SAAS,KAAKA,KAAI;AAAA,QACrC,SAAS,GAAG;AACX,cAAI,EAAE,QAAQ,WAAW,QAAQ,GAAG;AAEnC,wBAAY,MAAM,SAAS,MAAMA,KAAI;AAAA,UACtC;AAAA,QACD;AACA,eAAO,YAAY,CAAC,UAAU,YAAY,IAAI;AAAA,MAC/C;AACA,aAAO;AAAA,IACR;AAde;AAkBf,eAAW,aAAa,OAAO;AAE9B,UAAI;AACJ,UAAI,KAAK,WAAW,SAAS,GAAG;AAC/B,mBAAW,KAAK,KAAK,WAAW,OAAO;AAAA,MACxC,OAAO;AACN,mBAAW,KAAK,KAAK,KAAK,WAAW,OAAO;AAAA,MAC7C;AACA,UAAI,MAAM,WAAW,QAAQ,GAAG;AAC/B,eAAO;AAAA,MACR;AACA,UAAI,gBAAgB,WAAW;AAC/B,UAAI,MAAM,WAAW,aAAa,GAAG;AACpC,eAAO;AAAA,MACR;AACA,sBAAgB,WAAW;AAC3B,UAAI,MAAM,WAAW,aAAa,GAAG;AACpC,eAAO;AAAA,MACR;AAAA,IACD;AACA,WAAO,KAAK,KAAK,KAAK,OAAO;AAAA,EAC9B;AAjEA,EAAAD,OAAsB;AAAA;AAAA,GADN;",
  "names": ["win32", "path"]
}
