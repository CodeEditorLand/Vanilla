{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/node/processes.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as cp from 'child_process';\nimport { Stats, promises } from 'fs';\nimport * as path from '../common/path.js';\nimport * as Platform from '../common/platform.js';\nimport * as process from '../common/process.js';\nimport { CommandOptions, ForkOptions, Source, SuccessData, TerminateResponse, TerminateResponseCode } from '../common/processes.js';\nimport * as Types from '../common/types.js';\nimport * as pfs from './pfs.js';\nexport { type CommandOptions, type ForkOptions, type SuccessData, Source, type TerminateResponse, TerminateResponseCode };\n\nexport type ValueCallback<T> = (value: T | Promise<T>) => void;\nexport type ErrorCallback = (error?: any) => void;\nexport type ProgressCallback<T> = (progress: T) => void;\n\n\nexport function getWindowsShell(env = process.env as Platform.IProcessEnvironment): string {\n\treturn env['comspec'] || 'cmd.exe';\n}\n\nexport interface IQueuedSender {\n\tsend: (msg: any) => void;\n}\n\n// Wrapper around process.send() that will queue any messages if the internal node.js\n// queue is filled with messages and only continue sending messages when the internal\n// queue is free again to consume messages.\n// On Windows we always wait for the send() method to return before sending the next message\n// to workaround https://github.com/nodejs/node/issues/7657 (IPC can freeze process)\nexport function createQueuedSender(childProcess: cp.ChildProcess): IQueuedSender {\n\tlet msgQueue: string[] = [];\n\tlet useQueue = false;\n\n\tconst send = function (msg: any): void {\n\t\tif (useQueue) {\n\t\t\tmsgQueue.push(msg); // add to the queue if the process cannot handle more messages\n\t\t\treturn;\n\t\t}\n\n\t\tconst result = childProcess.send(msg, (error: Error | null) => {\n\t\t\tif (error) {\n\t\t\t\tconsole.error(error); // unlikely to happen, best we can do is log this error\n\t\t\t}\n\n\t\t\tuseQueue = false; // we are good again to send directly without queue\n\n\t\t\t// now send all the messages that we have in our queue and did not send yet\n\t\t\tif (msgQueue.length > 0) {\n\t\t\t\tconst msgQueueCopy = msgQueue.slice(0);\n\t\t\t\tmsgQueue = [];\n\t\t\t\tmsgQueueCopy.forEach(entry => send(entry));\n\t\t\t}\n\t\t});\n\n\t\tif (!result || Platform.isWindows /* workaround https://github.com/nodejs/node/issues/7657 */) {\n\t\t\tuseQueue = true;\n\t\t}\n\t};\n\n\treturn { send };\n}\n\nexport namespace win32 {\n\texport async function findExecutable(command: string, cwd?: string, paths?: string[]): Promise<string> {\n\t\t// If we have an absolute path then we take it.\n\t\tif (path.isAbsolute(command)) {\n\t\t\treturn command;\n\t\t}\n\t\tif (cwd === undefined) {\n\t\t\tcwd = process.cwd();\n\t\t}\n\t\tconst dir = path.dirname(command);\n\t\tif (dir !== '.') {\n\t\t\t// We have a directory and the directory is relative (see above). Make the path absolute\n\t\t\t// to the current working directory.\n\t\t\treturn path.join(cwd, command);\n\t\t}\n\t\tif (paths === undefined && Types.isString(process.env['PATH'])) {\n\t\t\tpaths = process.env['PATH'].split(path.delimiter);\n\t\t}\n\t\t// No PATH environment. Make path absolute to the cwd.\n\t\tif (paths === undefined || paths.length === 0) {\n\t\t\treturn path.join(cwd, command);\n\t\t}\n\n\t\tasync function fileExists(path: string): Promise<boolean> {\n\t\t\tif (await pfs.Promises.exists(path)) {\n\t\t\t\tlet statValue: Stats | undefined;\n\t\t\t\ttry {\n\t\t\t\t\tstatValue = await promises.stat(path);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (e.message.startsWith('EACCES')) {\n\t\t\t\t\t\t// it might be symlink\n\t\t\t\t\t\tstatValue = await promises.lstat(path);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn statValue ? !statValue.isDirectory() : false;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t// We have a simple file name. We get the path variable from the env\n\t\t// and try to find the executable on the path.\n\t\tfor (const pathEntry of paths) {\n\t\t\t// The path entry is absolute.\n\t\t\tlet fullPath: string;\n\t\t\tif (path.isAbsolute(pathEntry)) {\n\t\t\t\tfullPath = path.join(pathEntry, command);\n\t\t\t} else {\n\t\t\t\tfullPath = path.join(cwd, pathEntry, command);\n\t\t\t}\n\t\t\tif (await fileExists(fullPath)) {\n\t\t\t\treturn fullPath;\n\t\t\t}\n\t\t\tlet withExtension = fullPath + '.com';\n\t\t\tif (await fileExists(withExtension)) {\n\t\t\t\treturn withExtension;\n\t\t\t}\n\t\t\twithExtension = fullPath + '.exe';\n\t\t\tif (await fileExists(withExtension)) {\n\t\t\t\treturn withExtension;\n\t\t\t}\n\t\t}\n\t\treturn path.join(cwd, command);\n\t}\n}\n"],
  "mappings": ";;AAKA,YAAY,QAAQ;AACpB,SAAS,OAAO,gBAAgB;AAChC,YAAY,UAAU;AACtB,YAAY,cAAc;AAC1B,YAAY,aAAa;AACzB,SAAS,gBAAgB,aAAa,QAAQ,aAAa,mBAAmB,6BAA6B;AAC3G,YAAY,WAAW;AACvB,YAAY,SAAS;AAQd,SAAS,gBAAgB,MAAM,QAAQ,KAA6C;AAC1F,SAAO,IAAI,SAAS,KAAK;AAC1B;AAFgB;AAaT,SAAS,mBAAmB,cAA8C;AAChF,MAAI,WAAqB,CAAC;AAC1B,MAAI,WAAW;AAEf,QAAM,OAAO,gCAAU,KAAgB;AACtC,QAAI,UAAU;AACb,eAAS,KAAK,GAAG;AACjB;AAAA,IACD;AAEA,UAAM,SAAS,aAAa,KAAK,KAAK,CAAC,UAAwB;AAC9D,UAAI,OAAO;AACV,gBAAQ,MAAM,KAAK;AAAA,MACpB;AAEA,iBAAW;AAGX,UAAI,SAAS,SAAS,GAAG;AACxB,cAAM,eAAe,SAAS,MAAM,CAAC;AACrC,mBAAW,CAAC;AACZ,qBAAa,QAAQ,WAAS,KAAK,KAAK,CAAC;AAAA,MAC1C;AAAA,IACD,CAAC;AAED,QAAI,CAAC,UAAU,SAAS,WAAuE;AAC9F,iBAAW;AAAA,IACZ;AAAA,EACD,GAxBa;AA0Bb,SAAO,EAAE,KAAK;AACf;AA/BgB;AAiCT,IAAU;AAAA,CAAV,CAAUA,WAAV;AACN,iBAAsB,eAAe,SAAiB,KAAc,OAAmC;AAEtG,QAAI,KAAK,WAAW,OAAO,GAAG;AAC7B,aAAO;AAAA,IACR;AACA,QAAI,QAAQ,QAAW;AACtB,YAAM,QAAQ,IAAI;AAAA,IACnB;AACA,UAAM,MAAM,KAAK,QAAQ,OAAO;AAChC,QAAI,QAAQ,KAAK;AAGhB,aAAO,KAAK,KAAK,KAAK,OAAO;AAAA,IAC9B;AACA,QAAI,UAAU,UAAa,MAAM,SAAS,QAAQ,IAAI,MAAM,CAAC,GAAG;AAC/D,cAAQ,QAAQ,IAAI,MAAM,EAAE,MAAM,KAAK,SAAS;AAAA,IACjD;AAEA,QAAI,UAAU,UAAa,MAAM,WAAW,GAAG;AAC9C,aAAO,KAAK,KAAK,KAAK,OAAO;AAAA,IAC9B;AAEA,mBAAe,WAAWC,OAAgC;AACzD,UAAI,MAAM,IAAI,SAAS,OAAOA,KAAI,GAAG;AACpC,YAAI;AACJ,YAAI;AACH,sBAAY,MAAM,SAAS,KAAKA,KAAI;AAAA,QACrC,SAAS,GAAG;AACX,cAAI,EAAE,QAAQ,WAAW,QAAQ,GAAG;AAEnC,wBAAY,MAAM,SAAS,MAAMA,KAAI;AAAA,UACtC;AAAA,QACD;AACA,eAAO,YAAY,CAAC,UAAU,YAAY,IAAI;AAAA,MAC/C;AACA,aAAO;AAAA,IACR;AAde;AAkBf,eAAW,aAAa,OAAO;AAE9B,UAAI;AACJ,UAAI,KAAK,WAAW,SAAS,GAAG;AAC/B,mBAAW,KAAK,KAAK,WAAW,OAAO;AAAA,MACxC,OAAO;AACN,mBAAW,KAAK,KAAK,KAAK,WAAW,OAAO;AAAA,MAC7C;AACA,UAAI,MAAM,WAAW,QAAQ,GAAG;AAC/B,eAAO;AAAA,MACR;AACA,UAAI,gBAAgB,WAAW;AAC/B,UAAI,MAAM,WAAW,aAAa,GAAG;AACpC,eAAO;AAAA,MACR;AACA,sBAAgB,WAAW;AAC3B,UAAI,MAAM,WAAW,aAAa,GAAG;AACpC,eAAO;AAAA,MACR;AAAA,IACD;AACA,WAAO,KAAK,KAAK,KAAK,OAAO;AAAA,EAC9B;AA7DA,EAAAD,OAAsB;AAAA;AAAA,GADN;",
  "names": ["win32", "path"]
}
