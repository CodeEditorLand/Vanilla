{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/node/extpath.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport { CancellationToken } from '../common/cancellation.js';\nimport { basename, dirname, join, normalize, sep } from '../common/path.js';\nimport { isLinux } from '../common/platform.js';\nimport { rtrim } from '../common/strings.js';\nimport { Promises, readdirSync } from './pfs.js';\n\n/**\n * Copied from: https://github.com/microsoft/vscode-node-debug/blob/master/src/node/pathUtilities.ts#L83\n *\n * Given an absolute, normalized, and existing file path 'realcase' returns the exact path that the file has on disk.\n * On a case insensitive file system, the returned path might differ from the original path by character casing.\n * On a case sensitive file system, the returned path will always be identical to the original path.\n * In case of errors, null is returned. But you cannot use this function to verify that a path exists.\n * realcaseSync does not handle '..' or '.' path segments and it does not take the locale into account.\n */\nexport function realcaseSync(path: string): string | null {\n\tif (isLinux) {\n\t\t// This method is unsupported on OS that have case sensitive\n\t\t// file system where the same path can exist in different forms\n\t\t// (see also https://github.com/microsoft/vscode/issues/139709)\n\t\treturn path;\n\t}\n\n\tconst dir = dirname(path);\n\tif (path === dir) {\t// end recursion\n\t\treturn path;\n\t}\n\n\tconst name = (basename(path) /* can be '' for windows drive letters */ || path).toLowerCase();\n\ttry {\n\t\tconst entries = readdirSync(dir);\n\t\tconst found = entries.filter(e => e.toLowerCase() === name);\t// use a case insensitive search\n\t\tif (found.length === 1) {\n\t\t\t// on a case sensitive filesystem we cannot determine here, whether the file exists or not, hence we need the 'file exists' precondition\n\t\t\tconst prefix = realcaseSync(dir);   // recurse\n\t\t\tif (prefix) {\n\t\t\t\treturn join(prefix, found[0]);\n\t\t\t}\n\t\t} else if (found.length > 1) {\n\t\t\t// must be a case sensitive $filesystem\n\t\t\tconst ix = found.indexOf(name);\n\t\t\tif (ix >= 0) {\t// case sensitive\n\t\t\t\tconst prefix = realcaseSync(dir);   // recurse\n\t\t\t\tif (prefix) {\n\t\t\t\t\treturn join(prefix, found[ix]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} catch (error) {\n\t\t// silently ignore error\n\t}\n\n\treturn null;\n}\n\nexport async function realcase(path: string, token?: CancellationToken): Promise<string | null> {\n\tif (isLinux) {\n\t\t// This method is unsupported on OS that have case sensitive\n\t\t// file system where the same path can exist in different forms\n\t\t// (see also https://github.com/microsoft/vscode/issues/139709)\n\t\treturn path;\n\t}\n\n\tconst dir = dirname(path);\n\tif (path === dir) {\t// end recursion\n\t\treturn path;\n\t}\n\n\tconst name = (basename(path) /* can be '' for windows drive letters */ || path).toLowerCase();\n\ttry {\n\t\tif (token?.isCancellationRequested) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst entries = await Promises.readdir(dir);\n\t\tconst found = entries.filter(e => e.toLowerCase() === name);\t// use a case insensitive search\n\t\tif (found.length === 1) {\n\t\t\t// on a case sensitive filesystem we cannot determine here, whether the file exists or not, hence we need the 'file exists' precondition\n\t\t\tconst prefix = await realcase(dir, token);   // recurse\n\t\t\tif (prefix) {\n\t\t\t\treturn join(prefix, found[0]);\n\t\t\t}\n\t\t} else if (found.length > 1) {\n\t\t\t// must be a case sensitive $filesystem\n\t\t\tconst ix = found.indexOf(name);\n\t\t\tif (ix >= 0) {\t// case sensitive\n\t\t\t\tconst prefix = await realcase(dir, token);   // recurse\n\t\t\t\tif (prefix) {\n\t\t\t\t\treturn join(prefix, found[ix]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} catch (error) {\n\t\t// silently ignore error\n\t}\n\n\treturn null;\n}\n\nexport async function realpath(path: string): Promise<string> {\n\ttry {\n\t\t// DO NOT USE `fs.promises.realpath` here as it internally\n\t\t// calls `fs.native.realpath` which will result in subst\n\t\t// drives to be resolved to their target on Windows\n\t\t// https://github.com/microsoft/vscode/issues/118562\n\t\treturn await Promises.realpath(path);\n\t} catch (error) {\n\n\t\t// We hit an error calling fs.realpath(). Since fs.realpath() is doing some path normalization\n\t\t// we now do a similar normalization and then try again if we can access the path with read\n\t\t// permissions at least. If that succeeds, we return that path.\n\t\t// fs.realpath() is resolving symlinks and that can fail in certain cases. The workaround is\n\t\t// to not resolve links but to simply see if the path is read accessible or not.\n\t\tconst normalizedPath = normalizePath(path);\n\n\t\tawait fs.promises.access(normalizedPath, fs.constants.R_OK);\n\n\t\treturn normalizedPath;\n\t}\n}\n\nexport function realpathSync(path: string): string {\n\ttry {\n\t\treturn fs.realpathSync(path);\n\t} catch (error) {\n\n\t\t// We hit an error calling fs.realpathSync(). Since fs.realpathSync() is doing some path normalization\n\t\t// we now do a similar normalization and then try again if we can access the path with read\n\t\t// permissions at least. If that succeeds, we return that path.\n\t\t// fs.realpath() is resolving symlinks and that can fail in certain cases. The workaround is\n\t\t// to not resolve links but to simply see if the path is read accessible or not.\n\t\tconst normalizedPath = normalizePath(path);\n\n\t\tfs.accessSync(normalizedPath, fs.constants.R_OK); // throws in case of an error\n\n\t\treturn normalizedPath;\n\t}\n}\n\nfunction normalizePath(path: string): string {\n\treturn rtrim(normalize(path), sep);\n}\n"],
  "mappings": ";;AAKA,YAAY,QAAQ;AACpB,SAAS,yBAAyB;AAClC,SAAS,UAAU,SAAS,MAAM,WAAW,WAAW;AACxD,SAAS,eAAe;AACxB,SAAS,aAAa;AACtB,SAAS,UAAU,mBAAmB;AAW/B,SAAS,aAAa,MAA6B;AACzD,MAAI,SAAS;AAIZ,WAAO;AAAA,EACR;AAEA,QAAM,MAAM,QAAQ,IAAI;AACxB,MAAI,SAAS,KAAK;AACjB,WAAO;AAAA,EACR;AAEA,QAAM,QAAQ,SAAS,IAAI,KAA+C,MAAM,YAAY;AAC5F,MAAI;AACH,UAAM,UAAU,YAAY,GAAG;AAC/B,UAAM,QAAQ,QAAQ,OAAO,OAAK,EAAE,YAAY,MAAM,IAAI;AAC1D,QAAI,MAAM,WAAW,GAAG;AAEvB,YAAM,SAAS,aAAa,GAAG;AAC/B,UAAI,QAAQ;AACX,eAAO,KAAK,QAAQ,MAAM,CAAC,CAAC;AAAA,MAC7B;AAAA,IACD,WAAW,MAAM,SAAS,GAAG;AAE5B,YAAM,KAAK,MAAM,QAAQ,IAAI;AAC7B,UAAI,MAAM,GAAG;AACZ,cAAM,SAAS,aAAa,GAAG;AAC/B,YAAI,QAAQ;AACX,iBAAO,KAAK,QAAQ,MAAM,EAAE,CAAC;AAAA,QAC9B;AAAA,MACD;AAAA,IACD;AAAA,EACD,SAAS,OAAO;AAAA,EAEhB;AAEA,SAAO;AACR;AAtCgB;AAwChB,eAAsB,SAAS,MAAc,OAAmD;AAC/F,MAAI,SAAS;AAIZ,WAAO;AAAA,EACR;AAEA,QAAM,MAAM,QAAQ,IAAI;AACxB,MAAI,SAAS,KAAK;AACjB,WAAO;AAAA,EACR;AAEA,QAAM,QAAQ,SAAS,IAAI,KAA+C,MAAM,YAAY;AAC5F,MAAI;AACH,QAAI,OAAO,yBAAyB;AACnC,aAAO;AAAA,IACR;AAEA,UAAM,UAAU,MAAM,SAAS,QAAQ,GAAG;AAC1C,UAAM,QAAQ,QAAQ,OAAO,OAAK,EAAE,YAAY,MAAM,IAAI;AAC1D,QAAI,MAAM,WAAW,GAAG;AAEvB,YAAM,SAAS,MAAM,SAAS,KAAK,KAAK;AACxC,UAAI,QAAQ;AACX,eAAO,KAAK,QAAQ,MAAM,CAAC,CAAC;AAAA,MAC7B;AAAA,IACD,WAAW,MAAM,SAAS,GAAG;AAE5B,YAAM,KAAK,MAAM,QAAQ,IAAI;AAC7B,UAAI,MAAM,GAAG;AACZ,cAAM,SAAS,MAAM,SAAS,KAAK,KAAK;AACxC,YAAI,QAAQ;AACX,iBAAO,KAAK,QAAQ,MAAM,EAAE,CAAC;AAAA,QAC9B;AAAA,MACD;AAAA,IACD;AAAA,EACD,SAAS,OAAO;AAAA,EAEhB;AAEA,SAAO;AACR;AA1CsB;AA4CtB,eAAsB,SAAS,MAA+B;AAC7D,MAAI;AAKH,WAAO,MAAM,SAAS,SAAS,IAAI;AAAA,EACpC,SAAS,OAAO;AAOf,UAAM,iBAAiB,cAAc,IAAI;AAEzC,UAAM,GAAG,SAAS,OAAO,gBAAgB,GAAG,UAAU,IAAI;AAE1D,WAAO;AAAA,EACR;AACD;AApBsB;AAsBf,SAAS,aAAa,MAAsB;AAClD,MAAI;AACH,WAAO,GAAG,aAAa,IAAI;AAAA,EAC5B,SAAS,OAAO;AAOf,UAAM,iBAAiB,cAAc,IAAI;AAEzC,OAAG,WAAW,gBAAgB,GAAG,UAAU,IAAI;AAE/C,WAAO;AAAA,EACR;AACD;AAhBgB;AAkBhB,SAAS,cAAc,MAAsB;AAC5C,SAAO,MAAM,UAAU,IAAI,GAAG,GAAG;AAClC;AAFS;",
  "names": []
}
