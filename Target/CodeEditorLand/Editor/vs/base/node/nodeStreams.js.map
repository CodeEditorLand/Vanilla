{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/node/nodeStreams.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Transform } from \"stream\";\nimport { binaryIndexOf } from \"../common/buffer.js\";\n\n/**\n * A Transform stream that splits the input on the \"splitter\" substring.\n * The resulting chunks will contain (and trail with) the splitter match.\n * The last chunk when the stream ends will be emitted even if a splitter\n * is not encountered.\n */\nexport class StreamSplitter extends Transform {\n\tprivate buffer: Buffer | undefined;\n\tprivate readonly splitter: Buffer | number;\n\tprivate readonly spitterLen: number;\n\n\tconstructor(splitter: string | number | Buffer) {\n\t\tsuper();\n\t\tif (typeof splitter === \"number\") {\n\t\t\tthis.splitter = splitter;\n\t\t\tthis.spitterLen = 1;\n\t\t} else {\n\t\t\tconst buf = Buffer.isBuffer(splitter)\n\t\t\t\t? splitter\n\t\t\t\t: Buffer.from(splitter);\n\t\t\tthis.splitter = buf.length === 1 ? buf[0] : buf;\n\t\t\tthis.spitterLen = buf.length;\n\t\t}\n\t}\n\n\toverride _transform(\n\t\tchunk: Buffer,\n\t\t_encoding: string,\n\t\tcallback: (error?: Error | null, data?: any) => void,\n\t): void {\n\t\tif (this.buffer) {\n\t\t\tthis.buffer = Buffer.concat([this.buffer, chunk]);\n\t\t} else {\n\t\t\tthis.buffer = chunk;\n\t\t}\n\n\t\tlet offset = 0;\n\t\twhile (offset < this.buffer.length) {\n\t\t\tconst index =\n\t\t\t\ttypeof this.splitter === \"number\"\n\t\t\t\t\t? this.buffer.indexOf(this.splitter, offset)\n\t\t\t\t\t: binaryIndexOf(this.buffer, this.splitter, offset);\n\t\t\tif (index === -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tthis.push(this.buffer.slice(offset, index + this.spitterLen));\n\t\t\toffset = index + this.spitterLen;\n\t\t}\n\n\t\tthis.buffer =\n\t\t\toffset === this.buffer.length\n\t\t\t\t? undefined\n\t\t\t\t: this.buffer.slice(offset);\n\t\tcallback();\n\t}\n\n\toverride _flush(\n\t\tcallback: (error?: Error | null, data?: any) => void,\n\t): void {\n\t\tif (this.buffer) {\n\t\t\tthis.push(this.buffer);\n\t\t}\n\n\t\tcallback();\n\t}\n}\n"],
  "mappings": ";;AAIA,SAAS,iBAAiB;AAC1B,SAAS,qBAAqB;AAQvB,MAAM,uBAAuB,UAAU;AAAA,EAb9C,OAa8C;AAAA;AAAA;AAAA,EACrC;AAAA,EACS;AAAA,EACA;AAAA,EAEjB,YAAY,UAAoC;AAC/C,UAAM;AACN,QAAI,OAAO,aAAa,UAAU;AACjC,WAAK,WAAW;AAChB,WAAK,aAAa;AAAA,IACnB,OAAO;AACN,YAAM,MAAM,OAAO,SAAS,QAAQ,IACjC,WACA,OAAO,KAAK,QAAQ;AACvB,WAAK,WAAW,IAAI,WAAW,IAAI,IAAI,CAAC,IAAI;AAC5C,WAAK,aAAa,IAAI;AAAA,IACvB;AAAA,EACD;AAAA,EAES,WACR,OACA,WACA,UACO;AACP,QAAI,KAAK,QAAQ;AAChB,WAAK,SAAS,OAAO,OAAO,CAAC,KAAK,QAAQ,KAAK,CAAC;AAAA,IACjD,OAAO;AACN,WAAK,SAAS;AAAA,IACf;AAEA,QAAI,SAAS;AACb,WAAO,SAAS,KAAK,OAAO,QAAQ;AACnC,YAAM,QACL,OAAO,KAAK,aAAa,WACtB,KAAK,OAAO,QAAQ,KAAK,UAAU,MAAM,IACzC,cAAc,KAAK,QAAQ,KAAK,UAAU,MAAM;AACpD,UAAI,UAAU,IAAI;AACjB;AAAA,MACD;AAEA,WAAK,KAAK,KAAK,OAAO,MAAM,QAAQ,QAAQ,KAAK,UAAU,CAAC;AAC5D,eAAS,QAAQ,KAAK;AAAA,IACvB;AAEA,SAAK,SACJ,WAAW,KAAK,OAAO,SACpB,SACA,KAAK,OAAO,MAAM,MAAM;AAC5B,aAAS;AAAA,EACV;AAAA,EAES,OACR,UACO;AACP,QAAI,KAAK,QAAQ;AAChB,WAAK,KAAK,KAAK,MAAM;AAAA,IACtB;AAEA,aAAS;AAAA,EACV;AACD;",
  "names": []
}
