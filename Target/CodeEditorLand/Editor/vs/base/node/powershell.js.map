{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/node/powershell.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as os from 'os';\nimport * as path from '../common/path.js';\nimport * as pfs from './pfs.js';\n\n// This is required, since parseInt(\"7-preview\") will return 7.\nconst IntRegex: RegExp = /^\\d+$/;\n\nconst PwshMsixRegex: RegExp = /^Microsoft.PowerShell_.*/;\nconst PwshPreviewMsixRegex: RegExp = /^Microsoft.PowerShellPreview_.*/;\n\nconst enum Arch {\n\tx64,\n\tx86,\n\tARM\n}\n\nlet processArch: Arch;\nswitch (process.arch) {\n\tcase 'ia32':\n\t\tprocessArch = Arch.x86;\n\t\tbreak;\n\tcase 'arm':\n\tcase 'arm64':\n\t\tprocessArch = Arch.ARM;\n\t\tbreak;\n\tdefault:\n\t\tprocessArch = Arch.x64;\n\t\tbreak;\n}\n\n/*\nCurrently, here are the values for these environment variables on their respective archs:\n\nOn x86 process on x86:\nPROCESSOR_ARCHITECTURE is X86\nPROCESSOR_ARCHITEW6432 is undefined\n\nOn x86 process on x64:\nPROCESSOR_ARCHITECTURE is X86\nPROCESSOR_ARCHITEW6432 is AMD64\n\nOn x64 process on x64:\nPROCESSOR_ARCHITECTURE is AMD64\nPROCESSOR_ARCHITEW6432 is undefined\n\nOn ARM process on ARM:\nPROCESSOR_ARCHITECTURE is ARM64\nPROCESSOR_ARCHITEW6432 is undefined\n\nOn x86 process on ARM:\nPROCESSOR_ARCHITECTURE is X86\nPROCESSOR_ARCHITEW6432 is ARM64\n\nOn x64 process on ARM:\nPROCESSOR_ARCHITECTURE is ARM64\nPROCESSOR_ARCHITEW6432 is undefined\n*/\nlet osArch: Arch;\nif (process.env['PROCESSOR_ARCHITEW6432']) {\n\tosArch = process.env['PROCESSOR_ARCHITEW6432'] === 'ARM64'\n\t\t? Arch.ARM\n\t\t: Arch.x64;\n} else if (process.env['PROCESSOR_ARCHITECTURE'] === 'ARM64') {\n\tosArch = Arch.ARM;\n} else if (process.env['PROCESSOR_ARCHITECTURE'] === 'X86') {\n\tosArch = Arch.x86;\n} else {\n\tosArch = Arch.x64;\n}\n\nexport interface IPowerShellExeDetails {\n\treadonly displayName: string;\n\treadonly exePath: string;\n}\n\ninterface IPossiblePowerShellExe extends IPowerShellExeDetails {\n\texists(): Promise<boolean>;\n}\n\nclass PossiblePowerShellExe implements IPossiblePowerShellExe {\n\tconstructor(\n\t\tpublic readonly exePath: string,\n\t\tpublic readonly displayName: string,\n\t\tprivate knownToExist?: boolean) { }\n\n\tpublic async exists(): Promise<boolean> {\n\t\tif (this.knownToExist === undefined) {\n\t\t\tthis.knownToExist = await pfs.SymlinkSupport.existsFile(this.exePath);\n\t\t}\n\t\treturn this.knownToExist;\n\t}\n}\n\nfunction getProgramFilesPath(\n\t{ useAlternateBitness = false }: { useAlternateBitness?: boolean } = {}): string | null {\n\n\tif (!useAlternateBitness) {\n\t\t// Just use the native system bitness\n\t\treturn process.env.ProgramFiles || null;\n\t}\n\n\t// We might be a 64-bit process looking for 32-bit program files\n\tif (processArch === Arch.x64) {\n\t\treturn process.env['ProgramFiles(x86)'] || null;\n\t}\n\n\t// We might be a 32-bit process looking for 64-bit program files\n\tif (osArch === Arch.x64) {\n\t\treturn process.env.ProgramW6432 || null;\n\t}\n\n\t// We're a 32-bit process on 32-bit Windows, there is no other Program Files dir\n\treturn null;\n}\n\nasync function findPSCoreWindowsInstallation(\n\t{ useAlternateBitness = false, findPreview = false }:\n\t\t{ useAlternateBitness?: boolean; findPreview?: boolean } = {}): Promise<IPossiblePowerShellExe | null> {\n\n\tconst programFilesPath = getProgramFilesPath({ useAlternateBitness });\n\tif (!programFilesPath) {\n\t\treturn null;\n\t}\n\n\tconst powerShellInstallBaseDir = path.join(programFilesPath, 'PowerShell');\n\n\t// Ensure the base directory exists\n\tif (!await pfs.SymlinkSupport.existsDirectory(powerShellInstallBaseDir)) {\n\t\treturn null;\n\t}\n\n\tlet highestSeenVersion: number = -1;\n\tlet pwshExePath: string | null = null;\n\tfor (const item of await pfs.Promises.readdir(powerShellInstallBaseDir)) {\n\n\t\tlet currentVersion: number = -1;\n\t\tif (findPreview) {\n\t\t\t// We are looking for something like \"7-preview\"\n\n\t\t\t// Preview dirs all have dashes in them\n\t\t\tconst dashIndex = item.indexOf('-');\n\t\t\tif (dashIndex < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Verify that the part before the dash is an integer\n\t\t\t// and that the part after the dash is \"preview\"\n\t\t\tconst intPart: string = item.substring(0, dashIndex);\n\t\t\tif (!IntRegex.test(intPart) || item.substring(dashIndex + 1) !== 'preview') {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcurrentVersion = parseInt(intPart, 10);\n\t\t} else {\n\t\t\t// Search for a directory like \"6\" or \"7\"\n\t\t\tif (!IntRegex.test(item)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcurrentVersion = parseInt(item, 10);\n\t\t}\n\n\t\t// Ensure we haven't already seen a higher version\n\t\tif (currentVersion <= highestSeenVersion) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Now look for the file\n\t\tconst exePath = path.join(powerShellInstallBaseDir, item, 'pwsh.exe');\n\t\tif (!await pfs.SymlinkSupport.existsFile(exePath)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tpwshExePath = exePath;\n\t\thighestSeenVersion = currentVersion;\n\t}\n\n\tif (!pwshExePath) {\n\t\treturn null;\n\t}\n\n\tconst bitness: string = programFilesPath.includes('x86') ? ' (x86)' : '';\n\tconst preview: string = findPreview ? ' Preview' : '';\n\n\treturn new PossiblePowerShellExe(pwshExePath, `PowerShell${preview}${bitness}`, true);\n}\n\nasync function findPSCoreMsix({ findPreview }: { findPreview?: boolean } = {}): Promise<IPossiblePowerShellExe | null> {\n\t// We can't proceed if there's no LOCALAPPDATA path\n\tif (!process.env.LOCALAPPDATA) {\n\t\treturn null;\n\t}\n\n\t// Find the base directory for MSIX application exe shortcuts\n\tconst msixAppDir = path.join(process.env.LOCALAPPDATA, 'Microsoft', 'WindowsApps');\n\n\tif (!await pfs.SymlinkSupport.existsDirectory(msixAppDir)) {\n\t\treturn null;\n\t}\n\n\t// Define whether we're looking for the preview or the stable\n\tconst { pwshMsixDirRegex, pwshMsixName } = findPreview\n\t\t? { pwshMsixDirRegex: PwshPreviewMsixRegex, pwshMsixName: 'PowerShell Preview (Store)' }\n\t\t: { pwshMsixDirRegex: PwshMsixRegex, pwshMsixName: 'PowerShell (Store)' };\n\n\t// We should find only one such application, so return on the first one\n\tfor (const subdir of await pfs.Promises.readdir(msixAppDir)) {\n\t\tif (pwshMsixDirRegex.test(subdir)) {\n\t\t\tconst pwshMsixPath = path.join(msixAppDir, subdir, 'pwsh.exe');\n\t\t\treturn new PossiblePowerShellExe(pwshMsixPath, pwshMsixName);\n\t\t}\n\t}\n\n\t// If we find nothing, return null\n\treturn null;\n}\n\nfunction findPSCoreDotnetGlobalTool(): IPossiblePowerShellExe {\n\tconst dotnetGlobalToolExePath: string = path.join(os.homedir(), '.dotnet', 'tools', 'pwsh.exe');\n\n\treturn new PossiblePowerShellExe(dotnetGlobalToolExePath, '.NET Core PowerShell Global Tool');\n}\n\nfunction findWinPS(): IPossiblePowerShellExe | null {\n\tconst winPSPath = path.join(\n\t\tprocess.env.windir!,\n\t\tprocessArch === Arch.x86 && osArch !== Arch.x86 ? 'SysNative' : 'System32',\n\t\t'WindowsPowerShell', 'v1.0', 'powershell.exe');\n\n\treturn new PossiblePowerShellExe(winPSPath, 'Windows PowerShell', true);\n}\n\n/**\n * Iterates through all the possible well-known PowerShell installations on a machine.\n * Returned values may not exist, but come with an .exists property\n * which will check whether the executable exists.\n */\nasync function* enumerateDefaultPowerShellInstallations(): AsyncIterable<IPossiblePowerShellExe> {\n\t// Find PSCore stable first\n\tlet pwshExe = await findPSCoreWindowsInstallation();\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n\n\t// Windows may have a 32-bit pwsh.exe\n\tpwshExe = await findPSCoreWindowsInstallation({ useAlternateBitness: true });\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n\n\t// Also look for the MSIX/UWP installation\n\tpwshExe = await findPSCoreMsix();\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n\n\t// Look for the .NET global tool\n\t// Some older versions of PowerShell have a bug in this where startup will fail,\n\t// but this is fixed in newer versions\n\tpwshExe = findPSCoreDotnetGlobalTool();\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n\n\t// Look for PSCore preview\n\tpwshExe = await findPSCoreWindowsInstallation({ findPreview: true });\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n\n\t// Find a preview MSIX\n\tpwshExe = await findPSCoreMsix({ findPreview: true });\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n\n\t// Look for pwsh-preview with the opposite bitness\n\tpwshExe = await findPSCoreWindowsInstallation({ useAlternateBitness: true, findPreview: true });\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n\n\t// Finally, get Windows PowerShell\n\tpwshExe = findWinPS();\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n}\n\n/**\n * Iterates through PowerShell installations on the machine according\n * to configuration passed in through the constructor.\n * PowerShell items returned by this object are verified\n * to exist on the filesystem.\n */\nexport async function* enumeratePowerShellInstallations(): AsyncIterable<IPowerShellExeDetails> {\n\t// Get the default PowerShell installations first\n\tfor await (const defaultPwsh of enumerateDefaultPowerShellInstallations()) {\n\t\tif (await defaultPwsh.exists()) {\n\t\t\tyield defaultPwsh;\n\t\t}\n\t}\n}\n\n/**\n* Returns the first available PowerShell executable found in the search order.\n*/\nexport async function getFirstAvailablePowerShellInstallation(): Promise<IPowerShellExeDetails | null> {\n\tfor await (const pwsh of enumeratePowerShellInstallations()) {\n\t\treturn pwsh;\n\t}\n\treturn null;\n}\n"],
  "mappings": "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",
  "names": ["Arch"]
}
