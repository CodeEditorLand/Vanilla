{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/node/powershell.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as os from \"os\";\nimport * as path from \"../common/path.js\";\nimport * as pfs from \"./pfs.js\";\n\n// This is required, since parseInt(\"7-preview\") will return 7.\nconst IntRegex: RegExp = /^\\d+$/;\n\nconst PwshMsixRegex: RegExp = /^Microsoft.PowerShell_.*/;\nconst PwshPreviewMsixRegex: RegExp = /^Microsoft.PowerShellPreview_.*/;\n\nenum Arch {\n\tx64 = 0,\n\tx86 = 1,\n\tARM = 2,\n}\n\nlet processArch: Arch;\nswitch (process.arch) {\n\tcase \"ia32\":\n\t\tprocessArch = Arch.x86;\n\t\tbreak;\n\tcase \"arm\":\n\tcase \"arm64\":\n\t\tprocessArch = Arch.ARM;\n\t\tbreak;\n\tdefault:\n\t\tprocessArch = Arch.x64;\n\t\tbreak;\n}\n\n/*\nCurrently, here are the values for these environment variables on their respective archs:\n\nOn x86 process on x86:\nPROCESSOR_ARCHITECTURE is X86\nPROCESSOR_ARCHITEW6432 is undefined\n\nOn x86 process on x64:\nPROCESSOR_ARCHITECTURE is X86\nPROCESSOR_ARCHITEW6432 is AMD64\n\nOn x64 process on x64:\nPROCESSOR_ARCHITECTURE is AMD64\nPROCESSOR_ARCHITEW6432 is undefined\n\nOn ARM process on ARM:\nPROCESSOR_ARCHITECTURE is ARM64\nPROCESSOR_ARCHITEW6432 is undefined\n\nOn x86 process on ARM:\nPROCESSOR_ARCHITECTURE is X86\nPROCESSOR_ARCHITEW6432 is ARM64\n\nOn x64 process on ARM:\nPROCESSOR_ARCHITECTURE is ARM64\nPROCESSOR_ARCHITEW6432 is undefined\n*/\nlet osArch: Arch;\nif (process.env[\"PROCESSOR_ARCHITEW6432\"]) {\n\tosArch =\n\t\tprocess.env[\"PROCESSOR_ARCHITEW6432\"] === \"ARM64\" ? Arch.ARM : Arch.x64;\n} else if (process.env[\"PROCESSOR_ARCHITECTURE\"] === \"ARM64\") {\n\tosArch = Arch.ARM;\n} else if (process.env[\"PROCESSOR_ARCHITECTURE\"] === \"X86\") {\n\tosArch = Arch.x86;\n} else {\n\tosArch = Arch.x64;\n}\n\nexport interface IPowerShellExeDetails {\n\treadonly displayName: string;\n\treadonly exePath: string;\n}\n\ninterface IPossiblePowerShellExe extends IPowerShellExeDetails {\n\texists(): Promise<boolean>;\n}\n\nclass PossiblePowerShellExe implements IPossiblePowerShellExe {\n\tconstructor(\n\t\tpublic readonly exePath: string,\n\t\tpublic readonly displayName: string,\n\t\tprivate knownToExist?: boolean,\n\t) {}\n\n\tpublic async exists(): Promise<boolean> {\n\t\tif (this.knownToExist === undefined) {\n\t\t\tthis.knownToExist = await pfs.SymlinkSupport.existsFile(\n\t\t\t\tthis.exePath,\n\t\t\t);\n\t\t}\n\t\treturn this.knownToExist;\n\t}\n}\n\nfunction getProgramFilesPath({\n\tuseAlternateBitness = false,\n}: { useAlternateBitness?: boolean } = {}): string | null {\n\tif (!useAlternateBitness) {\n\t\t// Just use the native system bitness\n\t\treturn process.env.ProgramFiles || null;\n\t}\n\n\t// We might be a 64-bit process looking for 32-bit program files\n\tif (processArch === Arch.x64) {\n\t\treturn process.env[\"ProgramFiles(x86)\"] || null;\n\t}\n\n\t// We might be a 32-bit process looking for 64-bit program files\n\tif (osArch === Arch.x64) {\n\t\treturn process.env.ProgramW6432 || null;\n\t}\n\n\t// We're a 32-bit process on 32-bit Windows, there is no other Program Files dir\n\treturn null;\n}\n\nasync function findPSCoreWindowsInstallation({\n\tuseAlternateBitness = false,\n\tfindPreview = false,\n}: {\n\tuseAlternateBitness?: boolean;\n\tfindPreview?: boolean;\n} = {}): Promise<IPossiblePowerShellExe | null> {\n\tconst programFilesPath = getProgramFilesPath({ useAlternateBitness });\n\tif (!programFilesPath) {\n\t\treturn null;\n\t}\n\n\tconst powerShellInstallBaseDir = path.join(programFilesPath, \"PowerShell\");\n\n\t// Ensure the base directory exists\n\tif (!(await pfs.SymlinkSupport.existsDirectory(powerShellInstallBaseDir))) {\n\t\treturn null;\n\t}\n\n\tlet highestSeenVersion = -1;\n\tlet pwshExePath: string | null = null;\n\tfor (const item of await pfs.Promises.readdir(powerShellInstallBaseDir)) {\n\t\tlet currentVersion = -1;\n\t\tif (findPreview) {\n\t\t\t// We are looking for something like \"7-preview\"\n\n\t\t\t// Preview dirs all have dashes in them\n\t\t\tconst dashIndex = item.indexOf(\"-\");\n\t\t\tif (dashIndex < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Verify that the part before the dash is an integer\n\t\t\t// and that the part after the dash is \"preview\"\n\t\t\tconst intPart: string = item.substring(0, dashIndex);\n\t\t\tif (\n\t\t\t\t!IntRegex.test(intPart) ||\n\t\t\t\titem.substring(dashIndex + 1) !== \"preview\"\n\t\t\t) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcurrentVersion = Number.parseInt(intPart, 10);\n\t\t} else {\n\t\t\t// Search for a directory like \"6\" or \"7\"\n\t\t\tif (!IntRegex.test(item)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcurrentVersion = Number.parseInt(item, 10);\n\t\t}\n\n\t\t// Ensure we haven't already seen a higher version\n\t\tif (currentVersion <= highestSeenVersion) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Now look for the file\n\t\tconst exePath = path.join(powerShellInstallBaseDir, item, \"pwsh.exe\");\n\t\tif (!(await pfs.SymlinkSupport.existsFile(exePath))) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tpwshExePath = exePath;\n\t\thighestSeenVersion = currentVersion;\n\t}\n\n\tif (!pwshExePath) {\n\t\treturn null;\n\t}\n\n\tconst bitness: string = programFilesPath.includes(\"x86\") ? \" (x86)\" : \"\";\n\tconst preview: string = findPreview ? \" Preview\" : \"\";\n\n\treturn new PossiblePowerShellExe(\n\t\tpwshExePath,\n\t\t`PowerShell${preview}${bitness}`,\n\t\ttrue,\n\t);\n}\n\nasync function findPSCoreMsix({\n\tfindPreview,\n}: { findPreview?: boolean } = {}): Promise<IPossiblePowerShellExe | null> {\n\t// We can't proceed if there's no LOCALAPPDATA path\n\tif (!process.env.LOCALAPPDATA) {\n\t\treturn null;\n\t}\n\n\t// Find the base directory for MSIX application exe shortcuts\n\tconst msixAppDir = path.join(\n\t\tprocess.env.LOCALAPPDATA,\n\t\t\"Microsoft\",\n\t\t\"WindowsApps\",\n\t);\n\n\tif (!(await pfs.SymlinkSupport.existsDirectory(msixAppDir))) {\n\t\treturn null;\n\t}\n\n\t// Define whether we're looking for the preview or the stable\n\tconst { pwshMsixDirRegex, pwshMsixName } = findPreview\n\t\t? {\n\t\t\t\tpwshMsixDirRegex: PwshPreviewMsixRegex,\n\t\t\t\tpwshMsixName: \"PowerShell Preview (Store)\",\n\t\t\t}\n\t\t: {\n\t\t\t\tpwshMsixDirRegex: PwshMsixRegex,\n\t\t\t\tpwshMsixName: \"PowerShell (Store)\",\n\t\t\t};\n\n\t// We should find only one such application, so return on the first one\n\tfor (const subdir of await pfs.Promises.readdir(msixAppDir)) {\n\t\tif (pwshMsixDirRegex.test(subdir)) {\n\t\t\tconst pwshMsixPath = path.join(msixAppDir, subdir, \"pwsh.exe\");\n\t\t\treturn new PossiblePowerShellExe(pwshMsixPath, pwshMsixName);\n\t\t}\n\t}\n\n\t// If we find nothing, return null\n\treturn null;\n}\n\nfunction findPSCoreDotnetGlobalTool(): IPossiblePowerShellExe {\n\tconst dotnetGlobalToolExePath: string = path.join(\n\t\tos.homedir(),\n\t\t\".dotnet\",\n\t\t\"tools\",\n\t\t\"pwsh.exe\",\n\t);\n\n\treturn new PossiblePowerShellExe(\n\t\tdotnetGlobalToolExePath,\n\t\t\".NET Core PowerShell Global Tool\",\n\t);\n}\n\nfunction findWinPS(): IPossiblePowerShellExe | null {\n\tconst winPSPath = path.join(\n\t\tprocess.env.windir!,\n\t\tprocessArch === Arch.x86 && osArch !== Arch.x86\n\t\t\t? \"SysNative\"\n\t\t\t: \"System32\",\n\t\t\"WindowsPowerShell\",\n\t\t\"v1.0\",\n\t\t\"powershell.exe\",\n\t);\n\n\treturn new PossiblePowerShellExe(winPSPath, \"Windows PowerShell\", true);\n}\n\n/**\n * Iterates through all the possible well-known PowerShell installations on a machine.\n * Returned values may not exist, but come with an .exists property\n * which will check whether the executable exists.\n */\nasync function* enumerateDefaultPowerShellInstallations(): AsyncIterable<IPossiblePowerShellExe> {\n\t// Find PSCore stable first\n\tlet pwshExe = await findPSCoreWindowsInstallation();\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n\n\t// Windows may have a 32-bit pwsh.exe\n\tpwshExe = await findPSCoreWindowsInstallation({\n\t\tuseAlternateBitness: true,\n\t});\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n\n\t// Also look for the MSIX/UWP installation\n\tpwshExe = await findPSCoreMsix();\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n\n\t// Look for the .NET global tool\n\t// Some older versions of PowerShell have a bug in this where startup will fail,\n\t// but this is fixed in newer versions\n\tpwshExe = findPSCoreDotnetGlobalTool();\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n\n\t// Look for PSCore preview\n\tpwshExe = await findPSCoreWindowsInstallation({ findPreview: true });\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n\n\t// Find a preview MSIX\n\tpwshExe = await findPSCoreMsix({ findPreview: true });\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n\n\t// Look for pwsh-preview with the opposite bitness\n\tpwshExe = await findPSCoreWindowsInstallation({\n\t\tuseAlternateBitness: true,\n\t\tfindPreview: true,\n\t});\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n\n\t// Finally, get Windows PowerShell\n\tpwshExe = findWinPS();\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n}\n\n/**\n * Iterates through PowerShell installations on the machine according\n * to configuration passed in through the constructor.\n * PowerShell items returned by this object are verified\n * to exist on the filesystem.\n */\nexport async function* enumeratePowerShellInstallations(): AsyncIterable<IPowerShellExeDetails> {\n\t// Get the default PowerShell installations first\n\tfor await (const defaultPwsh of enumerateDefaultPowerShellInstallations()) {\n\t\tif (await defaultPwsh.exists()) {\n\t\t\tyield defaultPwsh;\n\t\t}\n\t}\n}\n\n/**\n * Returns the first available PowerShell executable found in the search order.\n */\nexport async function getFirstAvailablePowerShellInstallation(): Promise<IPowerShellExeDetails | null> {\n\tfor await (const pwsh of enumeratePowerShellInstallations()) {\n\t\treturn pwsh;\n\t}\n\treturn null;\n}\n"],
  "mappings": "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",
  "names": ["Arch"]
}
