{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/node/pfs.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from \"fs\";\nimport { tmpdir } from \"os\";\nimport { promisify } from \"util\";\nimport { ResourceQueue, timeout } from \"../common/async.js\";\nimport {\n\tisEqualOrParent,\n\tisRootOrDriveLetter,\n\trandomPath,\n} from \"../common/extpath.js\";\nimport { normalizeNFC } from \"../common/normalization.js\";\nimport { join } from \"../common/path.js\";\nimport { isLinux, isMacintosh, isWindows } from \"../common/platform.js\";\nimport { extUriBiasedIgnorePathCase } from \"../common/resources.js\";\nimport { URI } from \"../common/uri.js\";\n\n//#region rimraf\n\nexport enum RimRafMode {\n\t/**\n\t * Slow version that unlinks each file and folder.\n\t */\n\tUNLINK = 0,\n\n\t/**\n\t * Fast version that first moves the file/folder\n\t * into a temp directory and then deletes that\n\t * without waiting for it.\n\t */\n\tMOVE = 1,\n}\n\n/**\n * Allows to delete the provided path (either file or folder) recursively\n * with the options:\n * - `UNLINK`: direct removal from disk\n * - `MOVE`: faster variant that first moves the target to temp dir and then\n *           deletes it in the background without waiting for that to finish.\n *           the optional `moveToPath` allows to override where to rename the\n *           path to before deleting it.\n */\nasync function rimraf(path: string, mode: RimRafMode.UNLINK): Promise<void>;\nasync function rimraf(\n\tpath: string,\n\tmode: RimRafMode.MOVE,\n\tmoveToPath?: string,\n): Promise<void>;\nasync function rimraf(\n\tpath: string,\n\tmode?: RimRafMode,\n\tmoveToPath?: string,\n): Promise<void>;\nasync function rimraf(\n\tpath: string,\n\tmode = RimRafMode.UNLINK,\n\tmoveToPath?: string,\n): Promise<void> {\n\tif (isRootOrDriveLetter(path)) {\n\t\tthrow new Error(\"rimraf - will refuse to recursively delete root\");\n\t}\n\n\t// delete: via rm\n\tif (mode === RimRafMode.UNLINK) {\n\t\treturn rimrafUnlink(path);\n\t}\n\n\t// delete: via move\n\treturn rimrafMove(path, moveToPath);\n}\n\nasync function rimrafMove(\n\tpath: string,\n\tmoveToPath = randomPath(tmpdir()),\n): Promise<void> {\n\ttry {\n\t\ttry {\n\t\t\tawait fs.promises.rename(path, moveToPath);\n\t\t} catch (error) {\n\t\t\tif (error.code === \"ENOENT\") {\n\t\t\t\treturn; // ignore - path to delete did not exist\n\t\t\t}\n\n\t\t\treturn rimrafUnlink(path); // otherwise fallback to unlink\n\t\t}\n\n\t\t// Delete but do not return as promise\n\t\trimrafUnlink(moveToPath).catch((error) => {\n\t\t\t/* ignore */\n\t\t});\n\t} catch (error) {\n\t\tif (error.code !== \"ENOENT\") {\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\nasync function rimrafUnlink(path: string): Promise<void> {\n\treturn fs.promises.rm(path, {\n\t\trecursive: true,\n\t\tforce: true,\n\t\tmaxRetries: 3,\n\t});\n}\n\nexport function rimrafSync(path: string): void {\n\tif (isRootOrDriveLetter(path)) {\n\t\tthrow new Error(\"rimraf - will refuse to recursively delete root\");\n\t}\n\n\tfs.rmSync(path, { recursive: true, force: true, maxRetries: 3 });\n}\n\n//#endregion\n\n//#region readdir with NFC support (macos)\n\nexport interface IDirent {\n\tname: string;\n\n\tisFile(): boolean;\n\tisDirectory(): boolean;\n\tisSymbolicLink(): boolean;\n}\n\n/**\n * Drop-in replacement of `fs.readdir` with support\n * for converting from macOS NFD unicon form to NFC\n * (https://github.com/nodejs/node/issues/2165)\n */\nasync function readdir(path: string): Promise<string[]>;\nasync function readdir(\n\tpath: string,\n\toptions: { withFileTypes: true },\n): Promise<IDirent[]>;\nasync function readdir(\n\tpath: string,\n\toptions?: { withFileTypes: true },\n): Promise<(string | IDirent)[]> {\n\treturn handleDirectoryChildren(\n\t\tawait (options\n\t\t\t? safeReaddirWithFileTypes(path)\n\t\t\t: fs.promises.readdir(path)),\n\t);\n}\n\nasync function safeReaddirWithFileTypes(path: string): Promise<IDirent[]> {\n\ttry {\n\t\treturn await fs.promises.readdir(path, { withFileTypes: true });\n\t} catch (error) {\n\t\tconsole.warn(\n\t\t\t\"[node.js fs] readdir with filetypes failed with error: \",\n\t\t\terror,\n\t\t);\n\t}\n\n\t// Fallback to manually reading and resolving each\n\t// children of the folder in case we hit an error\n\t// previously.\n\t// This can only really happen on exotic file systems\n\t// such as explained in #115645 where we get entries\n\t// from `readdir` that we can later not `lstat`.\n\tconst result: IDirent[] = [];\n\tconst children = await readdir(path);\n\tfor (const child of children) {\n\t\tlet isFile = false;\n\t\tlet isDirectory = false;\n\t\tlet isSymbolicLink = false;\n\n\t\ttry {\n\t\t\tconst lstat = await fs.promises.lstat(join(path, child));\n\n\t\t\tisFile = lstat.isFile();\n\t\t\tisDirectory = lstat.isDirectory();\n\t\t\tisSymbolicLink = lstat.isSymbolicLink();\n\t\t} catch (error) {\n\t\t\tconsole.warn(\n\t\t\t\t\"[node.js fs] unexpected error from lstat after readdir: \",\n\t\t\t\terror,\n\t\t\t);\n\t\t}\n\n\t\tresult.push({\n\t\t\tname: child,\n\t\t\tisFile: () => isFile,\n\t\t\tisDirectory: () => isDirectory,\n\t\t\tisSymbolicLink: () => isSymbolicLink,\n\t\t});\n\t}\n\n\treturn result;\n}\n\n/**\n * Drop-in replacement of `fs.readdirSync` with support\n * for converting from macOS NFD unicon form to NFC\n * (https://github.com/nodejs/node/issues/2165)\n */\nexport function readdirSync(path: string): string[] {\n\treturn handleDirectoryChildren(fs.readdirSync(path));\n}\n\nfunction handleDirectoryChildren(children: string[]): string[];\nfunction handleDirectoryChildren(children: IDirent[]): IDirent[];\nfunction handleDirectoryChildren(\n\tchildren: (string | IDirent)[],\n): (string | IDirent)[];\nfunction handleDirectoryChildren(\n\tchildren: (string | IDirent)[],\n): (string | IDirent)[] {\n\treturn children.map((child) => {\n\t\t// Mac: uses NFD unicode form on disk, but we want NFC\n\t\t// See also https://github.com/nodejs/node/issues/2165\n\n\t\tif (typeof child === \"string\") {\n\t\t\treturn isMacintosh ? normalizeNFC(child) : child;\n\t\t}\n\n\t\tchild.name = isMacintosh ? normalizeNFC(child.name) : child.name;\n\n\t\treturn child;\n\t});\n}\n\n/**\n * A convenience method to read all children of a path that\n * are directories.\n */\nasync function readDirsInDir(dirPath: string): Promise<string[]> {\n\tconst children = await readdir(dirPath);\n\tconst directories: string[] = [];\n\n\tfor (const child of children) {\n\t\tif (await SymlinkSupport.existsDirectory(join(dirPath, child))) {\n\t\t\tdirectories.push(child);\n\t\t}\n\t}\n\n\treturn directories;\n}\n\n//#endregion\n\n//#region whenDeleted()\n\n/**\n * A `Promise` that resolves when the provided `path`\n * is deleted from disk.\n */\nexport function whenDeleted(path: string, intervalMs = 1000): Promise<void> {\n\treturn new Promise<void>((resolve) => {\n\t\tlet running = false;\n\t\tconst interval = setInterval(() => {\n\t\t\tif (!running) {\n\t\t\t\trunning = true;\n\t\t\t\tfs.access(path, (err) => {\n\t\t\t\t\trunning = false;\n\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tclearInterval(interval);\n\t\t\t\t\t\tresolve(undefined);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}, intervalMs);\n\t});\n}\n\n//#endregion\n\n//#region Methods with symbolic links support\n\nexport namespace SymlinkSupport {\n\texport interface IStats {\n\t\t// The stats of the file. If the file is a symbolic\n\t\t// link, the stats will be of that target file and\n\t\t// not the link itself.\n\t\t// If the file is a symbolic link pointing to a non\n\t\t// existing file, the stat will be of the link and\n\t\t// the `dangling` flag will indicate this.\n\t\tstat: fs.Stats;\n\n\t\t// Will be provided if the resource is a symbolic link\n\t\t// on disk. Use the `dangling` flag to find out if it\n\t\t// points to a resource that does not exist on disk.\n\t\tsymbolicLink?: { dangling: boolean };\n\t}\n\n\t/**\n\t * Resolves the `fs.Stats` of the provided path. If the path is a\n\t * symbolic link, the `fs.Stats` will be from the target it points\n\t * to. If the target does not exist, `dangling: true` will be returned\n\t * as `symbolicLink` value.\n\t */\n\texport async function stat(path: string): Promise<IStats> {\n\t\t// First stat the link\n\t\tlet lstats: fs.Stats | undefined;\n\t\ttry {\n\t\t\tlstats = await fs.promises.lstat(path);\n\n\t\t\t// Return early if the stat is not a symbolic link at all\n\t\t\tif (!lstats.isSymbolicLink()) {\n\t\t\t\treturn { stat: lstats };\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t/* ignore - use stat() instead */\n\t\t}\n\n\t\t// If the stat is a symbolic link or failed to stat, use fs.stat()\n\t\t// which for symbolic links will stat the target they point to\n\t\ttry {\n\t\t\tconst stats = await fs.promises.stat(path);\n\n\t\t\treturn {\n\t\t\t\tstat: stats,\n\t\t\t\tsymbolicLink: lstats?.isSymbolicLink()\n\t\t\t\t\t? { dangling: false }\n\t\t\t\t\t: undefined,\n\t\t\t};\n\t\t} catch (error) {\n\t\t\t// If the link points to a nonexistent file we still want\n\t\t\t// to return it as result while setting dangling: true flag\n\t\t\tif (error.code === \"ENOENT\" && lstats) {\n\t\t\t\treturn { stat: lstats, symbolicLink: { dangling: true } };\n\t\t\t}\n\n\t\t\t// Windows: workaround a node.js bug where reparse points\n\t\t\t// are not supported (https://github.com/nodejs/node/issues/36790)\n\t\t\tif (isWindows && error.code === \"EACCES\") {\n\t\t\t\ttry {\n\t\t\t\t\tconst stats = await fs.promises.stat(\n\t\t\t\t\t\tawait fs.promises.readlink(path),\n\t\t\t\t\t);\n\n\t\t\t\t\treturn { stat: stats, symbolicLink: { dangling: false } };\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// If the link points to a nonexistent file we still want\n\t\t\t\t\t// to return it as result while setting dangling: true flag\n\t\t\t\t\tif (error.code === \"ENOENT\" && lstats) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tstat: lstats,\n\t\t\t\t\t\t\tsymbolicLink: { dangling: true },\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Figures out if the `path` exists and is a file with support\n\t * for symlinks.\n\t *\n\t * Note: this will return `false` for a symlink that exists on\n\t * disk but is dangling (pointing to a nonexistent path).\n\t *\n\t * Use `exists` if you only care about the path existing on disk\n\t * or not without support for symbolic links.\n\t */\n\texport async function existsFile(path: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst { stat, symbolicLink } = await SymlinkSupport.stat(path);\n\n\t\t\treturn stat.isFile() && symbolicLink?.dangling !== true;\n\t\t} catch (error) {\n\t\t\t// Ignore, path might not exist\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Figures out if the `path` exists and is a directory with support for\n\t * symlinks.\n\t *\n\t * Note: this will return `false` for a symlink that exists on\n\t * disk but is dangling (pointing to a nonexistent path).\n\t *\n\t * Use `exists` if you only care about the path existing on disk\n\t * or not without support for symbolic links.\n\t */\n\texport async function existsDirectory(path: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst { stat, symbolicLink } = await SymlinkSupport.stat(path);\n\n\t\t\treturn stat.isDirectory() && symbolicLink?.dangling !== true;\n\t\t} catch (error) {\n\t\t\t// Ignore, path might not exist\n\t\t}\n\n\t\treturn false;\n\t}\n}\n\n//#endregion\n\n//#region Write File\n\n// According to node.js docs (https://nodejs.org/docs/v14.16.0/api/fs.html#fs_fs_writefile_file_data_options_callback)\n// it is not safe to call writeFile() on the same path multiple times without waiting for the callback to return.\n// Therefor we use a Queue on the path that is given to us to sequentialize calls to the same path properly.\nconst writeQueues = new ResourceQueue();\n\n/**\n * Same as `fs.writeFile` but with an additional call to\n * `fs.fdatasync` after writing to ensure changes are\n * flushed to disk.\n *\n * In addition, multiple writes to the same path are queued.\n */\nfunction writeFile(\n\tpath: string,\n\tdata: string,\n\toptions?: IWriteFileOptions,\n): Promise<void>;\nfunction writeFile(\n\tpath: string,\n\tdata: Buffer,\n\toptions?: IWriteFileOptions,\n): Promise<void>;\nfunction writeFile(\n\tpath: string,\n\tdata: Uint8Array,\n\toptions?: IWriteFileOptions,\n): Promise<void>;\nfunction writeFile(\n\tpath: string,\n\tdata: string | Buffer | Uint8Array,\n\toptions?: IWriteFileOptions,\n): Promise<void>;\nfunction writeFile(\n\tpath: string,\n\tdata: string | Buffer | Uint8Array,\n\toptions?: IWriteFileOptions,\n): Promise<void> {\n\treturn writeQueues.queueFor(\n\t\tURI.file(path),\n\t\t() => {\n\t\t\tconst ensuredOptions = ensureWriteOptions(options);\n\n\t\t\treturn new Promise((resolve, reject) =>\n\t\t\t\tdoWriteFileAndFlush(path, data, ensuredOptions, (error) =>\n\t\t\t\t\terror ? reject(error) : resolve(),\n\t\t\t\t),\n\t\t\t);\n\t\t},\n\t\textUriBiasedIgnorePathCase,\n\t);\n}\n\ninterface IWriteFileOptions {\n\tmode?: number;\n\tflag?: string;\n}\n\ninterface IEnsuredWriteFileOptions extends IWriteFileOptions {\n\tmode: number;\n\tflag: string;\n}\n\nlet canFlush = true;\nexport function configureFlushOnWrite(enabled: boolean): void {\n\tcanFlush = enabled;\n}\n\n// Calls fs.writeFile() followed by a fs.sync() call to flush the changes to disk\n// We do this in cases where we want to make sure the data is really on disk and\n// not in some cache.\n//\n// See https://github.com/nodejs/node/blob/v5.10.0/lib/fs.js#L1194\nfunction doWriteFileAndFlush(\n\tpath: string,\n\tdata: string | Buffer | Uint8Array,\n\toptions: IEnsuredWriteFileOptions,\n\tcallback: (error: Error | null) => void,\n): void {\n\tif (!canFlush) {\n\t\treturn fs.writeFile(\n\t\t\tpath,\n\t\t\tdata,\n\t\t\t{ mode: options.mode, flag: options.flag },\n\t\t\tcallback,\n\t\t);\n\t}\n\n\t// Open the file with same flags and mode as fs.writeFile()\n\tfs.open(path, options.flag, options.mode, (openError, fd) => {\n\t\tif (openError) {\n\t\t\treturn callback(openError);\n\t\t}\n\n\t\t// It is valid to pass a fd handle to fs.writeFile() and this will keep the handle open!\n\t\tfs.writeFile(fd, data, (writeError) => {\n\t\t\tif (writeError) {\n\t\t\t\treturn fs.close(fd, () => callback(writeError)); // still need to close the handle on error!\n\t\t\t}\n\n\t\t\t// Flush contents (not metadata) of the file to disk\n\t\t\t// https://github.com/microsoft/vscode/issues/9589\n\t\t\tfs.fdatasync(fd, (syncError: Error | null) => {\n\t\t\t\t// In some exotic setups it is well possible that node fails to sync\n\t\t\t\t// In that case we disable flushing and warn to the console\n\t\t\t\tif (syncError) {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t\"[node.js fs] fdatasync is now disabled for this session because it failed: \",\n\t\t\t\t\t\tsyncError,\n\t\t\t\t\t);\n\t\t\t\t\tconfigureFlushOnWrite(false);\n\t\t\t\t}\n\n\t\t\t\treturn fs.close(fd, (closeError) => callback(closeError));\n\t\t\t});\n\t\t});\n\t});\n}\n\n/**\n * Same as `fs.writeFileSync` but with an additional call to\n * `fs.fdatasyncSync` after writing to ensure changes are\n * flushed to disk.\n */\nexport function writeFileSync(\n\tpath: string,\n\tdata: string | Buffer,\n\toptions?: IWriteFileOptions,\n): void {\n\tconst ensuredOptions = ensureWriteOptions(options);\n\n\tif (!canFlush) {\n\t\treturn fs.writeFileSync(path, data, {\n\t\t\tmode: ensuredOptions.mode,\n\t\t\tflag: ensuredOptions.flag,\n\t\t});\n\t}\n\n\t// Open the file with same flags and mode as fs.writeFile()\n\tconst fd = fs.openSync(path, ensuredOptions.flag, ensuredOptions.mode);\n\n\ttry {\n\t\t// It is valid to pass a fd handle to fs.writeFile() and this will keep the handle open!\n\t\tfs.writeFileSync(fd, data);\n\n\t\t// Flush contents (not metadata) of the file to disk\n\t\ttry {\n\t\t\tfs.fdatasyncSync(fd); // https://github.com/microsoft/vscode/issues/9589\n\t\t} catch (syncError) {\n\t\t\tconsole.warn(\n\t\t\t\t\"[node.js fs] fdatasyncSync is now disabled for this session because it failed: \",\n\t\t\t\tsyncError,\n\t\t\t);\n\t\t\tconfigureFlushOnWrite(false);\n\t\t}\n\t} finally {\n\t\tfs.closeSync(fd);\n\t}\n}\n\nfunction ensureWriteOptions(\n\toptions?: IWriteFileOptions,\n): IEnsuredWriteFileOptions {\n\tif (!options) {\n\t\treturn { mode: 0o666 /* default node.js mode for files */, flag: \"w\" };\n\t}\n\n\treturn {\n\t\tmode:\n\t\t\ttypeof options.mode === \"number\"\n\t\t\t\t? options.mode\n\t\t\t\t: 0o666 /* default node.js mode for files */,\n\t\tflag: typeof options.flag === \"string\" ? options.flag : \"w\",\n\t};\n}\n\n//#endregion\n\n//#region Move / Copy\n\n/**\n * A drop-in replacement for `fs.rename` that:\n * - allows to move across multiple disks\n * - attempts to retry the operation for certain error codes on Windows\n */\nasync function rename(\n\tsource: string,\n\ttarget: string,\n\twindowsRetryTimeout: number | false = 60000,\n): Promise<void> {\n\tif (source === target) {\n\t\treturn; // simulate node.js behaviour here and do a no-op if paths match\n\t}\n\n\ttry {\n\t\tif (isWindows && typeof windowsRetryTimeout === \"number\") {\n\t\t\t// On Windows, a rename can fail when either source or target\n\t\t\t// is locked by AV software.\n\t\t\tawait renameWithRetry(\n\t\t\t\tsource,\n\t\t\t\ttarget,\n\t\t\t\tDate.now(),\n\t\t\t\twindowsRetryTimeout,\n\t\t\t);\n\t\t} else {\n\t\t\tawait fs.promises.rename(source, target);\n\t\t}\n\t} catch (error) {\n\t\t// In two cases we fallback to classic copy and delete:\n\t\t//\n\t\t// 1.) The EXDEV error indicates that source and target are on different devices\n\t\t// In this case, fallback to using a copy() operation as there is no way to\n\t\t// rename() between different devices.\n\t\t//\n\t\t// 2.) The user tries to rename a file/folder that ends with a dot. This is not\n\t\t// really possible to move then, at least on UNC devices.\n\t\tif (\n\t\t\t(source.toLowerCase() !== target.toLowerCase() &&\n\t\t\t\terror.code === \"EXDEV\") ||\n\t\t\tsource.endsWith(\".\")\n\t\t) {\n\t\t\tawait copy(source, target, {\n\t\t\t\tpreserveSymlinks: false /* copying to another device */,\n\t\t\t});\n\t\t\tawait rimraf(source, RimRafMode.MOVE);\n\t\t} else {\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\nasync function renameWithRetry(\n\tsource: string,\n\ttarget: string,\n\tstartTime: number,\n\tretryTimeout: number,\n\tattempt = 0,\n): Promise<void> {\n\ttry {\n\t\treturn await fs.promises.rename(source, target);\n\t} catch (error) {\n\t\tif (\n\t\t\terror.code !== \"EACCES\" &&\n\t\t\terror.code !== \"EPERM\" &&\n\t\t\terror.code !== \"EBUSY\"\n\t\t) {\n\t\t\tthrow error; // only for errors we think are temporary\n\t\t}\n\n\t\tif (Date.now() - startTime >= retryTimeout) {\n\t\t\tconsole.error(\n\t\t\t\t`[node.js fs] rename failed after ${attempt} retries with error: ${error}`,\n\t\t\t);\n\n\t\t\tthrow error; // give up after configurable timeout\n\t\t}\n\n\t\tif (attempt === 0) {\n\t\t\tlet abortRetry = false;\n\t\t\ttry {\n\t\t\t\tconst { stat } = await SymlinkSupport.stat(target);\n\t\t\t\tif (!stat.isFile()) {\n\t\t\t\t\tabortRetry = true; // if target is not a file, EPERM error may be raised and we should not attempt to retry\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\t// Ignore\n\t\t\t}\n\n\t\t\tif (abortRetry) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\n\t\t// Delay with incremental backoff up to 100ms\n\t\tawait timeout(Math.min(100, attempt * 10));\n\n\t\t// Attempt again\n\t\treturn renameWithRetry(\n\t\t\tsource,\n\t\t\ttarget,\n\t\t\tstartTime,\n\t\t\tretryTimeout,\n\t\t\tattempt + 1,\n\t\t);\n\t}\n}\n\ninterface ICopyPayload {\n\treadonly root: { source: string; target: string };\n\treadonly options: { preserveSymlinks: boolean };\n\treadonly handledSourcePaths: Set<string>;\n}\n\n/**\n * Recursively copies all of `source` to `target`.\n *\n * The options `preserveSymlinks` configures how symbolic\n * links should be handled when encountered. Set to\n * `false` to not preserve them and `true` otherwise.\n */\nasync function copy(\n\tsource: string,\n\ttarget: string,\n\toptions: { preserveSymlinks: boolean },\n): Promise<void> {\n\treturn doCopy(source, target, {\n\t\troot: { source, target },\n\t\toptions,\n\t\thandledSourcePaths: new Set<string>(),\n\t});\n}\n\n// When copying a file or folder, we want to preserve the mode\n// it had and as such provide it when creating. However, modes\n// can go beyond what we expect (see link below), so we mask it.\n// (https://github.com/nodejs/node-v0.x-archive/issues/3045#issuecomment-4862588)\nconst COPY_MODE_MASK = 0o777;\n\nasync function doCopy(\n\tsource: string,\n\ttarget: string,\n\tpayload: ICopyPayload,\n): Promise<void> {\n\t// Keep track of paths already copied to prevent\n\t// cycles from symbolic links to cause issues\n\tif (payload.handledSourcePaths.has(source)) {\n\t\treturn;\n\t} else {\n\t\tpayload.handledSourcePaths.add(source);\n\t}\n\n\tconst { stat, symbolicLink } = await SymlinkSupport.stat(source);\n\n\t// Symlink\n\tif (symbolicLink) {\n\t\t// Try to re-create the symlink unless `preserveSymlinks: false`\n\t\tif (payload.options.preserveSymlinks) {\n\t\t\ttry {\n\t\t\t\treturn await doCopySymlink(source, target, payload);\n\t\t\t} catch (error) {\n\t\t\t\t// in any case of an error fallback to normal copy via dereferencing\n\t\t\t}\n\t\t}\n\n\t\tif (symbolicLink.dangling) {\n\t\t\treturn; // skip dangling symbolic links from here on (https://github.com/microsoft/vscode/issues/111621)\n\t\t}\n\t}\n\n\t// Folder\n\tif (stat.isDirectory()) {\n\t\treturn doCopyDirectory(\n\t\t\tsource,\n\t\t\ttarget,\n\t\t\tstat.mode & COPY_MODE_MASK,\n\t\t\tpayload,\n\t\t);\n\t}\n\n\t// File or file-like\n\telse {\n\t\treturn doCopyFile(source, target, stat.mode & COPY_MODE_MASK);\n\t}\n}\n\nasync function doCopyDirectory(\n\tsource: string,\n\ttarget: string,\n\tmode: number,\n\tpayload: ICopyPayload,\n): Promise<void> {\n\t// Create folder\n\tawait fs.promises.mkdir(target, { recursive: true, mode });\n\n\t// Copy each file recursively\n\tconst files = await readdir(source);\n\tfor (const file of files) {\n\t\tawait doCopy(join(source, file), join(target, file), payload);\n\t}\n}\n\nasync function doCopyFile(\n\tsource: string,\n\ttarget: string,\n\tmode: number,\n): Promise<void> {\n\t// Copy file\n\tawait fs.promises.copyFile(source, target);\n\n\t// restore mode (https://github.com/nodejs/node/issues/1104)\n\tawait fs.promises.chmod(target, mode);\n}\n\nasync function doCopySymlink(\n\tsource: string,\n\ttarget: string,\n\tpayload: ICopyPayload,\n): Promise<void> {\n\t// Figure out link target\n\tlet linkTarget = await fs.promises.readlink(source);\n\n\t// Special case: the symlink points to a target that is\n\t// actually within the path that is being copied. In that\n\t// case we want the symlink to point to the target and\n\t// not the source\n\tif (isEqualOrParent(linkTarget, payload.root.source, !isLinux)) {\n\t\tlinkTarget = join(\n\t\t\tpayload.root.target,\n\t\t\tlinkTarget.substr(payload.root.source.length + 1),\n\t\t);\n\t}\n\n\t// Create symlink\n\tawait fs.promises.symlink(linkTarget, target);\n}\n\n//#endregion\n\n//#region Promise based fs methods\n\n/**\n * Some low level `fs` methods provided as `Promises` similar to\n * `fs.promises` but with notable differences, either implemented\n * by us or by restoring the original callback based behavior.\n *\n * At least `realpath` is implemented differently in the promise\n * based implementation compared to the callback based one. The\n * promise based implementation actually calls `fs.realpath.native`.\n * (https://github.com/microsoft/vscode/issues/118562)\n */\nexport const Promises = new (class {\n\t//#region Implemented by node.js\n\n\tget read() {\n\t\t// Not using `promisify` here for a reason: the return\n\t\t// type is not an object as indicated by TypeScript but\n\t\t// just the bytes read, so we create our own wrapper.\n\n\t\treturn (\n\t\t\tfd: number,\n\t\t\tbuffer: Uint8Array,\n\t\t\toffset: number,\n\t\t\tlength: number,\n\t\t\tposition: number | null,\n\t\t) => {\n\t\t\treturn new Promise<{ bytesRead: number; buffer: Uint8Array }>(\n\t\t\t\t(resolve, reject) => {\n\t\t\t\t\tfs.read(\n\t\t\t\t\t\tfd,\n\t\t\t\t\t\tbuffer,\n\t\t\t\t\t\toffset,\n\t\t\t\t\t\tlength,\n\t\t\t\t\t\tposition,\n\t\t\t\t\t\t(err, bytesRead, buffer) => {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn resolve({ bytesRead, buffer });\n\t\t\t\t\t\t},\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t);\n\t\t};\n\t}\n\n\tget write() {\n\t\t// Not using `promisify` here for a reason: the return\n\t\t// type is not an object as indicated by TypeScript but\n\t\t// just the bytes written, so we create our own wrapper.\n\n\t\treturn (\n\t\t\tfd: number,\n\t\t\tbuffer: Uint8Array,\n\t\t\toffset: number | undefined | null,\n\t\t\tlength: number | undefined | null,\n\t\t\tposition: number | undefined | null,\n\t\t) => {\n\t\t\treturn new Promise<{ bytesWritten: number; buffer: Uint8Array }>(\n\t\t\t\t(resolve, reject) => {\n\t\t\t\t\tfs.write(\n\t\t\t\t\t\tfd,\n\t\t\t\t\t\tbuffer,\n\t\t\t\t\t\toffset,\n\t\t\t\t\t\tlength,\n\t\t\t\t\t\tposition,\n\t\t\t\t\t\t(err, bytesWritten, buffer) => {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn resolve({ bytesWritten, buffer });\n\t\t\t\t\t\t},\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t);\n\t\t};\n\t}\n\n\tget fdatasync() {\n\t\treturn promisify(fs.fdatasync);\n\t} // not exposed as API in 20.x yet\n\n\tget open() {\n\t\treturn promisify(fs.open);\n\t} // changed to return `FileHandle` in promise API\n\tget close() {\n\t\treturn promisify(fs.close);\n\t} // not exposed as API due to the `FileHandle` return type of `open`\n\n\tget realpath() {\n\t\treturn promisify(fs.realpath);\n\t} // `fs.promises.realpath` will use `fs.realpath.native` which we do not want\n\n\t//#endregion\n\n\t//#region Implemented by us\n\n\tasync exists(path: string): Promise<boolean> {\n\t\ttry {\n\t\t\tawait fs.promises.access(path);\n\n\t\t\treturn true;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tget readdir() {\n\t\treturn readdir;\n\t}\n\tget readDirsInDir() {\n\t\treturn readDirsInDir;\n\t}\n\n\tget writeFile() {\n\t\treturn writeFile;\n\t}\n\n\tget rm() {\n\t\treturn rimraf;\n\t}\n\n\tget rename() {\n\t\treturn rename;\n\t}\n\tget copy() {\n\t\treturn copy;\n\t}\n\n\t//#endregion\n})();\n\n//#endregion\n"],
  "mappings": "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",
  "names": ["RimRafMode", "SymlinkSupport", "error", "stat", "buffer"]
}
