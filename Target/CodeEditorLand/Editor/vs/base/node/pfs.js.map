{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/node/pfs.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport { tmpdir } from 'os';\nimport { promisify } from 'util';\nimport { ResourceQueue, timeout } from '../common/async.js';\nimport { isEqualOrParent, isRootOrDriveLetter, randomPath } from '../common/extpath.js';\nimport { normalizeNFC } from '../common/normalization.js';\nimport { join } from '../common/path.js';\nimport { isLinux, isMacintosh, isWindows } from '../common/platform.js';\nimport { extUriBiasedIgnorePathCase } from '../common/resources.js';\nimport { URI } from '../common/uri.js';\n\n//#region rimraf\n\nexport enum RimRafMode {\n\n\t/**\n\t * Slow version that unlinks each file and folder.\n\t */\n\tUNLINK,\n\n\t/**\n\t * Fast version that first moves the file/folder\n\t * into a temp directory and then deletes that\n\t * without waiting for it.\n\t */\n\tMOVE\n}\n\n/**\n * Allows to delete the provided path (either file or folder) recursively\n * with the options:\n * - `UNLINK`: direct removal from disk\n * - `MOVE`: faster variant that first moves the target to temp dir and then\n *           deletes it in the background without waiting for that to finish.\n *           the optional `moveToPath` allows to override where to rename the\n *           path to before deleting it.\n */\nasync function rimraf(path: string, mode: RimRafMode.UNLINK): Promise<void>;\nasync function rimraf(path: string, mode: RimRafMode.MOVE, moveToPath?: string): Promise<void>;\nasync function rimraf(path: string, mode?: RimRafMode, moveToPath?: string): Promise<void>;\nasync function rimraf(path: string, mode = RimRafMode.UNLINK, moveToPath?: string): Promise<void> {\n\tif (isRootOrDriveLetter(path)) {\n\t\tthrow new Error('rimraf - will refuse to recursively delete root');\n\t}\n\n\t// delete: via rm\n\tif (mode === RimRafMode.UNLINK) {\n\t\treturn rimrafUnlink(path);\n\t}\n\n\t// delete: via move\n\treturn rimrafMove(path, moveToPath);\n}\n\nasync function rimrafMove(path: string, moveToPath = randomPath(tmpdir())): Promise<void> {\n\ttry {\n\t\ttry {\n\t\t\tawait fs.promises.rename(path, moveToPath);\n\t\t} catch (error) {\n\t\t\tif (error.code === 'ENOENT') {\n\t\t\t\treturn; // ignore - path to delete did not exist\n\t\t\t}\n\n\t\t\treturn rimrafUnlink(path); // otherwise fallback to unlink\n\t\t}\n\n\t\t// Delete but do not return as promise\n\t\trimrafUnlink(moveToPath).catch(error => {/* ignore */ });\n\t} catch (error) {\n\t\tif (error.code !== 'ENOENT') {\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\nasync function rimrafUnlink(path: string): Promise<void> {\n\treturn fs.promises.rm(path, { recursive: true, force: true, maxRetries: 3 });\n}\n\nexport function rimrafSync(path: string): void {\n\tif (isRootOrDriveLetter(path)) {\n\t\tthrow new Error('rimraf - will refuse to recursively delete root');\n\t}\n\n\tfs.rmSync(path, { recursive: true, force: true, maxRetries: 3 });\n}\n\n//#endregion\n\n//#region readdir with NFC support (macos)\n\nexport interface IDirent {\n\tname: string;\n\n\tisFile(): boolean;\n\tisDirectory(): boolean;\n\tisSymbolicLink(): boolean;\n}\n\n/**\n * Drop-in replacement of `fs.readdir` with support\n * for converting from macOS NFD unicon form to NFC\n * (https://github.com/nodejs/node/issues/2165)\n */\nasync function readdir(path: string): Promise<string[]>;\nasync function readdir(path: string, options: { withFileTypes: true }): Promise<IDirent[]>;\nasync function readdir(path: string, options?: { withFileTypes: true }): Promise<(string | IDirent)[]> {\n\treturn handleDirectoryChildren(await (options ? safeReaddirWithFileTypes(path) : fs.promises.readdir(path)));\n}\n\nasync function safeReaddirWithFileTypes(path: string): Promise<IDirent[]> {\n\ttry {\n\t\treturn await fs.promises.readdir(path, { withFileTypes: true });\n\t} catch (error) {\n\t\tconsole.warn('[node.js fs] readdir with filetypes failed with error: ', error);\n\t}\n\n\t// Fallback to manually reading and resolving each\n\t// children of the folder in case we hit an error\n\t// previously.\n\t// This can only really happen on exotic file systems\n\t// such as explained in #115645 where we get entries\n\t// from `readdir` that we can later not `lstat`.\n\tconst result: IDirent[] = [];\n\tconst children = await readdir(path);\n\tfor (const child of children) {\n\t\tlet isFile = false;\n\t\tlet isDirectory = false;\n\t\tlet isSymbolicLink = false;\n\n\t\ttry {\n\t\t\tconst lstat = await fs.promises.lstat(join(path, child));\n\n\t\t\tisFile = lstat.isFile();\n\t\t\tisDirectory = lstat.isDirectory();\n\t\t\tisSymbolicLink = lstat.isSymbolicLink();\n\t\t} catch (error) {\n\t\t\tconsole.warn('[node.js fs] unexpected error from lstat after readdir: ', error);\n\t\t}\n\n\t\tresult.push({\n\t\t\tname: child,\n\t\t\tisFile: () => isFile,\n\t\t\tisDirectory: () => isDirectory,\n\t\t\tisSymbolicLink: () => isSymbolicLink\n\t\t});\n\t}\n\n\treturn result;\n}\n\n/**\n * Drop-in replacement of `fs.readdirSync` with support\n * for converting from macOS NFD unicon form to NFC\n * (https://github.com/nodejs/node/issues/2165)\n */\nexport function readdirSync(path: string): string[] {\n\treturn handleDirectoryChildren(fs.readdirSync(path));\n}\n\nfunction handleDirectoryChildren(children: string[]): string[];\nfunction handleDirectoryChildren(children: IDirent[]): IDirent[];\nfunction handleDirectoryChildren(children: (string | IDirent)[]): (string | IDirent)[];\nfunction handleDirectoryChildren(children: (string | IDirent)[]): (string | IDirent)[] {\n\treturn children.map(child => {\n\n\t\t// Mac: uses NFD unicode form on disk, but we want NFC\n\t\t// See also https://github.com/nodejs/node/issues/2165\n\n\t\tif (typeof child === 'string') {\n\t\t\treturn isMacintosh ? normalizeNFC(child) : child;\n\t\t}\n\n\t\tchild.name = isMacintosh ? normalizeNFC(child.name) : child.name;\n\n\t\treturn child;\n\t});\n}\n\n/**\n * A convenience method to read all children of a path that\n * are directories.\n */\nasync function readDirsInDir(dirPath: string): Promise<string[]> {\n\tconst children = await readdir(dirPath);\n\tconst directories: string[] = [];\n\n\tfor (const child of children) {\n\t\tif (await SymlinkSupport.existsDirectory(join(dirPath, child))) {\n\t\t\tdirectories.push(child);\n\t\t}\n\t}\n\n\treturn directories;\n}\n\n//#endregion\n\n//#region whenDeleted()\n\n/**\n * A `Promise` that resolves when the provided `path`\n * is deleted from disk.\n */\nexport function whenDeleted(path: string, intervalMs = 1000): Promise<void> {\n\treturn new Promise<void>(resolve => {\n\t\tlet running = false;\n\t\tconst interval = setInterval(() => {\n\t\t\tif (!running) {\n\t\t\t\trunning = true;\n\t\t\t\tfs.access(path, err => {\n\t\t\t\t\trunning = false;\n\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tclearInterval(interval);\n\t\t\t\t\t\tresolve(undefined);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}, intervalMs);\n\t});\n}\n\n//#endregion\n\n//#region Methods with symbolic links support\n\nexport namespace SymlinkSupport {\n\n\texport interface IStats {\n\n\t\t// The stats of the file. If the file is a symbolic\n\t\t// link, the stats will be of that target file and\n\t\t// not the link itself.\n\t\t// If the file is a symbolic link pointing to a non\n\t\t// existing file, the stat will be of the link and\n\t\t// the `dangling` flag will indicate this.\n\t\tstat: fs.Stats;\n\n\t\t// Will be provided if the resource is a symbolic link\n\t\t// on disk. Use the `dangling` flag to find out if it\n\t\t// points to a resource that does not exist on disk.\n\t\tsymbolicLink?: { dangling: boolean };\n\t}\n\n\t/**\n\t * Resolves the `fs.Stats` of the provided path. If the path is a\n\t * symbolic link, the `fs.Stats` will be from the target it points\n\t * to. If the target does not exist, `dangling: true` will be returned\n\t * as `symbolicLink` value.\n\t */\n\texport async function stat(path: string): Promise<IStats> {\n\n\t\t// First stat the link\n\t\tlet lstats: fs.Stats | undefined;\n\t\ttry {\n\t\t\tlstats = await fs.promises.lstat(path);\n\n\t\t\t// Return early if the stat is not a symbolic link at all\n\t\t\tif (!lstats.isSymbolicLink()) {\n\t\t\t\treturn { stat: lstats };\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t/* ignore - use stat() instead */\n\t\t}\n\n\t\t// If the stat is a symbolic link or failed to stat, use fs.stat()\n\t\t// which for symbolic links will stat the target they point to\n\t\ttry {\n\t\t\tconst stats = await fs.promises.stat(path);\n\n\t\t\treturn { stat: stats, symbolicLink: lstats?.isSymbolicLink() ? { dangling: false } : undefined };\n\t\t} catch (error) {\n\n\t\t\t// If the link points to a nonexistent file we still want\n\t\t\t// to return it as result while setting dangling: true flag\n\t\t\tif (error.code === 'ENOENT' && lstats) {\n\t\t\t\treturn { stat: lstats, symbolicLink: { dangling: true } };\n\t\t\t}\n\n\t\t\t// Windows: workaround a node.js bug where reparse points\n\t\t\t// are not supported (https://github.com/nodejs/node/issues/36790)\n\t\t\tif (isWindows && error.code === 'EACCES') {\n\t\t\t\ttry {\n\t\t\t\t\tconst stats = await fs.promises.stat(await fs.promises.readlink(path));\n\n\t\t\t\t\treturn { stat: stats, symbolicLink: { dangling: false } };\n\t\t\t\t} catch (error) {\n\n\t\t\t\t\t// If the link points to a nonexistent file we still want\n\t\t\t\t\t// to return it as result while setting dangling: true flag\n\t\t\t\t\tif (error.code === 'ENOENT' && lstats) {\n\t\t\t\t\t\treturn { stat: lstats, symbolicLink: { dangling: true } };\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Figures out if the `path` exists and is a file with support\n\t * for symlinks.\n\t *\n\t * Note: this will return `false` for a symlink that exists on\n\t * disk but is dangling (pointing to a nonexistent path).\n\t *\n\t * Use `exists` if you only care about the path existing on disk\n\t * or not without support for symbolic links.\n\t */\n\texport async function existsFile(path: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst { stat, symbolicLink } = await SymlinkSupport.stat(path);\n\n\t\t\treturn stat.isFile() && symbolicLink?.dangling !== true;\n\t\t} catch (error) {\n\t\t\t// Ignore, path might not exist\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Figures out if the `path` exists and is a directory with support for\n\t * symlinks.\n\t *\n\t * Note: this will return `false` for a symlink that exists on\n\t * disk but is dangling (pointing to a nonexistent path).\n\t *\n\t * Use `exists` if you only care about the path existing on disk\n\t * or not without support for symbolic links.\n\t */\n\texport async function existsDirectory(path: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst { stat, symbolicLink } = await SymlinkSupport.stat(path);\n\n\t\t\treturn stat.isDirectory() && symbolicLink?.dangling !== true;\n\t\t} catch (error) {\n\t\t\t// Ignore, path might not exist\n\t\t}\n\n\t\treturn false;\n\t}\n}\n\n//#endregion\n\n//#region Write File\n\n// According to node.js docs (https://nodejs.org/docs/v14.16.0/api/fs.html#fs_fs_writefile_file_data_options_callback)\n// it is not safe to call writeFile() on the same path multiple times without waiting for the callback to return.\n// Therefor we use a Queue on the path that is given to us to sequentialize calls to the same path properly.\nconst writeQueues = new ResourceQueue();\n\n/**\n * Same as `fs.writeFile` but with an additional call to\n * `fs.fdatasync` after writing to ensure changes are\n * flushed to disk.\n *\n * In addition, multiple writes to the same path are queued.\n */\nfunction writeFile(path: string, data: string, options?: IWriteFileOptions): Promise<void>;\nfunction writeFile(path: string, data: Buffer, options?: IWriteFileOptions): Promise<void>;\nfunction writeFile(path: string, data: Uint8Array, options?: IWriteFileOptions): Promise<void>;\nfunction writeFile(path: string, data: string | Buffer | Uint8Array, options?: IWriteFileOptions): Promise<void>;\nfunction writeFile(path: string, data: string | Buffer | Uint8Array, options?: IWriteFileOptions): Promise<void> {\n\treturn writeQueues.queueFor(URI.file(path), () => {\n\t\tconst ensuredOptions = ensureWriteOptions(options);\n\n\t\treturn new Promise((resolve, reject) => doWriteFileAndFlush(path, data, ensuredOptions, error => error ? reject(error) : resolve()));\n\t}, extUriBiasedIgnorePathCase);\n}\n\ninterface IWriteFileOptions {\n\tmode?: number;\n\tflag?: string;\n}\n\ninterface IEnsuredWriteFileOptions extends IWriteFileOptions {\n\tmode: number;\n\tflag: string;\n}\n\nlet canFlush = true;\nexport function configureFlushOnWrite(enabled: boolean): void {\n\tcanFlush = enabled;\n}\n\n// Calls fs.writeFile() followed by a fs.sync() call to flush the changes to disk\n// We do this in cases where we want to make sure the data is really on disk and\n// not in some cache.\n//\n// See https://github.com/nodejs/node/blob/v5.10.0/lib/fs.js#L1194\nfunction doWriteFileAndFlush(path: string, data: string | Buffer | Uint8Array, options: IEnsuredWriteFileOptions, callback: (error: Error | null) => void): void {\n\tif (!canFlush) {\n\t\treturn fs.writeFile(path, data, { mode: options.mode, flag: options.flag }, callback);\n\t}\n\n\t// Open the file with same flags and mode as fs.writeFile()\n\tfs.open(path, options.flag, options.mode, (openError, fd) => {\n\t\tif (openError) {\n\t\t\treturn callback(openError);\n\t\t}\n\n\t\t// It is valid to pass a fd handle to fs.writeFile() and this will keep the handle open!\n\t\tfs.writeFile(fd, data, writeError => {\n\t\t\tif (writeError) {\n\t\t\t\treturn fs.close(fd, () => callback(writeError)); // still need to close the handle on error!\n\t\t\t}\n\n\t\t\t// Flush contents (not metadata) of the file to disk\n\t\t\t// https://github.com/microsoft/vscode/issues/9589\n\t\t\tfs.fdatasync(fd, (syncError: Error | null) => {\n\n\t\t\t\t// In some exotic setups it is well possible that node fails to sync\n\t\t\t\t// In that case we disable flushing and warn to the console\n\t\t\t\tif (syncError) {\n\t\t\t\t\tconsole.warn('[node.js fs] fdatasync is now disabled for this session because it failed: ', syncError);\n\t\t\t\t\tconfigureFlushOnWrite(false);\n\t\t\t\t}\n\n\t\t\t\treturn fs.close(fd, closeError => callback(closeError));\n\t\t\t});\n\t\t});\n\t});\n}\n\n/**\n * Same as `fs.writeFileSync` but with an additional call to\n * `fs.fdatasyncSync` after writing to ensure changes are\n * flushed to disk.\n */\nexport function writeFileSync(path: string, data: string | Buffer, options?: IWriteFileOptions): void {\n\tconst ensuredOptions = ensureWriteOptions(options);\n\n\tif (!canFlush) {\n\t\treturn fs.writeFileSync(path, data, { mode: ensuredOptions.mode, flag: ensuredOptions.flag });\n\t}\n\n\t// Open the file with same flags and mode as fs.writeFile()\n\tconst fd = fs.openSync(path, ensuredOptions.flag, ensuredOptions.mode);\n\n\ttry {\n\n\t\t// It is valid to pass a fd handle to fs.writeFile() and this will keep the handle open!\n\t\tfs.writeFileSync(fd, data);\n\n\t\t// Flush contents (not metadata) of the file to disk\n\t\ttry {\n\t\t\tfs.fdatasyncSync(fd); // https://github.com/microsoft/vscode/issues/9589\n\t\t} catch (syncError) {\n\t\t\tconsole.warn('[node.js fs] fdatasyncSync is now disabled for this session because it failed: ', syncError);\n\t\t\tconfigureFlushOnWrite(false);\n\t\t}\n\t} finally {\n\t\tfs.closeSync(fd);\n\t}\n}\n\nfunction ensureWriteOptions(options?: IWriteFileOptions): IEnsuredWriteFileOptions {\n\tif (!options) {\n\t\treturn { mode: 0o666 /* default node.js mode for files */, flag: 'w' };\n\t}\n\n\treturn {\n\t\tmode: typeof options.mode === 'number' ? options.mode : 0o666 /* default node.js mode for files */,\n\t\tflag: typeof options.flag === 'string' ? options.flag : 'w'\n\t};\n}\n\n//#endregion\n\n//#region Move / Copy\n\n/**\n * A drop-in replacement for `fs.rename` that:\n * - allows to move across multiple disks\n * - attempts to retry the operation for certain error codes on Windows\n */\nasync function rename(source: string, target: string, windowsRetryTimeout: number | false = 60000): Promise<void> {\n\tif (source === target) {\n\t\treturn;  // simulate node.js behaviour here and do a no-op if paths match\n\t}\n\n\ttry {\n\t\tif (isWindows && typeof windowsRetryTimeout === 'number') {\n\t\t\t// On Windows, a rename can fail when either source or target\n\t\t\t// is locked by AV software.\n\t\t\tawait renameWithRetry(source, target, Date.now(), windowsRetryTimeout);\n\t\t} else {\n\t\t\tawait fs.promises.rename(source, target);\n\t\t}\n\t} catch (error) {\n\t\t// In two cases we fallback to classic copy and delete:\n\t\t//\n\t\t// 1.) The EXDEV error indicates that source and target are on different devices\n\t\t// In this case, fallback to using a copy() operation as there is no way to\n\t\t// rename() between different devices.\n\t\t//\n\t\t// 2.) The user tries to rename a file/folder that ends with a dot. This is not\n\t\t// really possible to move then, at least on UNC devices.\n\t\tif (source.toLowerCase() !== target.toLowerCase() && error.code === 'EXDEV' || source.endsWith('.')) {\n\t\t\tawait copy(source, target, { preserveSymlinks: false /* copying to another device */ });\n\t\t\tawait rimraf(source, RimRafMode.MOVE);\n\t\t} else {\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\nasync function renameWithRetry(source: string, target: string, startTime: number, retryTimeout: number, attempt = 0): Promise<void> {\n\ttry {\n\t\treturn await fs.promises.rename(source, target);\n\t} catch (error) {\n\t\tif (error.code !== 'EACCES' && error.code !== 'EPERM' && error.code !== 'EBUSY') {\n\t\t\tthrow error; // only for errors we think are temporary\n\t\t}\n\n\t\tif (Date.now() - startTime >= retryTimeout) {\n\t\t\tconsole.error(`[node.js fs] rename failed after ${attempt} retries with error: ${error}`);\n\n\t\t\tthrow error; // give up after configurable timeout\n\t\t}\n\n\t\tif (attempt === 0) {\n\t\t\tlet abortRetry = false;\n\t\t\ttry {\n\t\t\t\tconst { stat } = await SymlinkSupport.stat(target);\n\t\t\t\tif (!stat.isFile()) {\n\t\t\t\t\tabortRetry = true; // if target is not a file, EPERM error may be raised and we should not attempt to retry\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\t// Ignore\n\t\t\t}\n\n\t\t\tif (abortRetry) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\n\t\t// Delay with incremental backoff up to 100ms\n\t\tawait timeout(Math.min(100, attempt * 10));\n\n\t\t// Attempt again\n\t\treturn renameWithRetry(source, target, startTime, retryTimeout, attempt + 1);\n\t}\n}\n\ninterface ICopyPayload {\n\treadonly root: { source: string; target: string };\n\treadonly options: { preserveSymlinks: boolean };\n\treadonly handledSourcePaths: Set<string>;\n}\n\n/**\n * Recursively copies all of `source` to `target`.\n *\n * The options `preserveSymlinks` configures how symbolic\n * links should be handled when encountered. Set to\n * `false` to not preserve them and `true` otherwise.\n */\nasync function copy(source: string, target: string, options: { preserveSymlinks: boolean }): Promise<void> {\n\treturn doCopy(source, target, { root: { source, target }, options, handledSourcePaths: new Set<string>() });\n}\n\n// When copying a file or folder, we want to preserve the mode\n// it had and as such provide it when creating. However, modes\n// can go beyond what we expect (see link below), so we mask it.\n// (https://github.com/nodejs/node-v0.x-archive/issues/3045#issuecomment-4862588)\nconst COPY_MODE_MASK = 0o777;\n\nasync function doCopy(source: string, target: string, payload: ICopyPayload): Promise<void> {\n\n\t// Keep track of paths already copied to prevent\n\t// cycles from symbolic links to cause issues\n\tif (payload.handledSourcePaths.has(source)) {\n\t\treturn;\n\t} else {\n\t\tpayload.handledSourcePaths.add(source);\n\t}\n\n\tconst { stat, symbolicLink } = await SymlinkSupport.stat(source);\n\n\t// Symlink\n\tif (symbolicLink) {\n\n\t\t// Try to re-create the symlink unless `preserveSymlinks: false`\n\t\tif (payload.options.preserveSymlinks) {\n\t\t\ttry {\n\t\t\t\treturn await doCopySymlink(source, target, payload);\n\t\t\t} catch (error) {\n\t\t\t\t// in any case of an error fallback to normal copy via dereferencing\n\t\t\t}\n\t\t}\n\n\t\tif (symbolicLink.dangling) {\n\t\t\treturn; // skip dangling symbolic links from here on (https://github.com/microsoft/vscode/issues/111621)\n\t\t}\n\t}\n\n\t// Folder\n\tif (stat.isDirectory()) {\n\t\treturn doCopyDirectory(source, target, stat.mode & COPY_MODE_MASK, payload);\n\t}\n\n\t// File or file-like\n\telse {\n\t\treturn doCopyFile(source, target, stat.mode & COPY_MODE_MASK);\n\t}\n}\n\nasync function doCopyDirectory(source: string, target: string, mode: number, payload: ICopyPayload): Promise<void> {\n\n\t// Create folder\n\tawait fs.promises.mkdir(target, { recursive: true, mode });\n\n\t// Copy each file recursively\n\tconst files = await readdir(source);\n\tfor (const file of files) {\n\t\tawait doCopy(join(source, file), join(target, file), payload);\n\t}\n}\n\nasync function doCopyFile(source: string, target: string, mode: number): Promise<void> {\n\n\t// Copy file\n\tawait fs.promises.copyFile(source, target);\n\n\t// restore mode (https://github.com/nodejs/node/issues/1104)\n\tawait fs.promises.chmod(target, mode);\n}\n\nasync function doCopySymlink(source: string, target: string, payload: ICopyPayload): Promise<void> {\n\n\t// Figure out link target\n\tlet linkTarget = await fs.promises.readlink(source);\n\n\t// Special case: the symlink points to a target that is\n\t// actually within the path that is being copied. In that\n\t// case we want the symlink to point to the target and\n\t// not the source\n\tif (isEqualOrParent(linkTarget, payload.root.source, !isLinux)) {\n\t\tlinkTarget = join(payload.root.target, linkTarget.substr(payload.root.source.length + 1));\n\t}\n\n\t// Create symlink\n\tawait fs.promises.symlink(linkTarget, target);\n}\n\n//#endregion\n\n//#region Promise based fs methods\n\n/**\n * Some low level `fs` methods provided as `Promises` similar to\n * `fs.promises` but with notable differences, either implemented\n * by us or by restoring the original callback based behavior.\n *\n * At least `realpath` is implemented differently in the promise\n * based implementation compared to the callback based one. The\n * promise based implementation actually calls `fs.realpath.native`.\n * (https://github.com/microsoft/vscode/issues/118562)\n */\nexport const Promises = new class {\n\n\t//#region Implemented by node.js\n\n\tget read() {\n\n\t\t// Not using `promisify` here for a reason: the return\n\t\t// type is not an object as indicated by TypeScript but\n\t\t// just the bytes read, so we create our own wrapper.\n\n\t\treturn (fd: number, buffer: Uint8Array, offset: number, length: number, position: number | null) => {\n\t\t\treturn new Promise<{ bytesRead: number; buffer: Uint8Array }>((resolve, reject) => {\n\t\t\t\tfs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn resolve({ bytesRead, buffer });\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\t}\n\n\tget write() {\n\n\t\t// Not using `promisify` here for a reason: the return\n\t\t// type is not an object as indicated by TypeScript but\n\t\t// just the bytes written, so we create our own wrapper.\n\n\t\treturn (fd: number, buffer: Uint8Array, offset: number | undefined | null, length: number | undefined | null, position: number | undefined | null) => {\n\t\t\treturn new Promise<{ bytesWritten: number; buffer: Uint8Array }>((resolve, reject) => {\n\t\t\t\tfs.write(fd, buffer, offset, length, position, (err, bytesWritten, buffer) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn resolve({ bytesWritten, buffer });\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\t}\n\n\tget fdatasync() { return promisify(fs.fdatasync); } // not exposed as API in 20.x yet\n\n\tget open() { return promisify(fs.open); } \t\t\t// changed to return `FileHandle` in promise API\n\tget close() { return promisify(fs.close); } \t\t// not exposed as API due to the `FileHandle` return type of `open`\n\n\tget realpath() { return promisify(fs.realpath); }\t// `fs.promises.realpath` will use `fs.realpath.native` which we do not want\n\n\t//#endregion\n\n\t//#region Implemented by us\n\n\tasync exists(path: string): Promise<boolean> {\n\t\ttry {\n\t\t\tawait fs.promises.access(path);\n\n\t\t\treturn true;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tget readdir() { return readdir; }\n\tget readDirsInDir() { return readDirsInDir; }\n\n\tget writeFile() { return writeFile; }\n\n\tget rm() { return rimraf; }\n\n\tget rename() { return rename; }\n\tget copy() { return copy; }\n\n\t//#endregion\n};\n\n//#endregion\n"],
  "mappings": "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",
  "names": ["RimRafMode", "SymlinkSupport", "error", "stat", "buffer"]
}
