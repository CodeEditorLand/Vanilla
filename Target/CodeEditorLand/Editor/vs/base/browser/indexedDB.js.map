{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/browser/indexedDB.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { toErrorMessage } from \"../common/errorMessage.js\";\nimport { ErrorNoTelemetry, getErrorMessage } from \"../common/errors.js\";\nimport { mark } from \"../common/performance.js\";\n\nclass MissingStoresError extends Error {\n\tconstructor(readonly db: IDBDatabase) {\n\t\tsuper(\"Missing stores\");\n\t}\n}\n\nexport class DBClosedError extends Error {\n\treadonly code = \"DBClosed\";\n\tconstructor(dbName: string) {\n\t\tsuper(`IndexedDB database '${dbName}' is closed.`);\n\t}\n}\n\nexport class IndexedDB {\n\tstatic async create(\n\t\tname: string,\n\t\tversion: number | undefined,\n\t\tstores: string[],\n\t): Promise<IndexedDB> {\n\t\tconst database = await IndexedDB.openDatabase(name, version, stores);\n\t\treturn new IndexedDB(database, name);\n\t}\n\n\tprivate static async openDatabase(\n\t\tname: string,\n\t\tversion: number | undefined,\n\t\tstores: string[],\n\t): Promise<IDBDatabase> {\n\t\tmark(`code/willOpenDatabase/${name}`);\n\t\ttry {\n\t\t\treturn await IndexedDB.doOpenDatabase(name, version, stores);\n\t\t} catch (err) {\n\t\t\tif (err instanceof MissingStoresError) {\n\t\t\t\tconsole.info(\n\t\t\t\t\t`Attempting to recreate the IndexedDB once.`,\n\t\t\t\t\tname,\n\t\t\t\t);\n\n\t\t\t\ttry {\n\t\t\t\t\t// Try to delete the db\n\t\t\t\t\tawait IndexedDB.deleteDatabase(err.db);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t`Error while deleting the IndexedDB`,\n\t\t\t\t\t\tgetErrorMessage(error),\n\t\t\t\t\t);\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\n\t\t\t\treturn await IndexedDB.doOpenDatabase(name, version, stores);\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t} finally {\n\t\t\tmark(`code/didOpenDatabase/${name}`);\n\t\t}\n\t}\n\n\tprivate static doOpenDatabase(\n\t\tname: string,\n\t\tversion: number | undefined,\n\t\tstores: string[],\n\t): Promise<IDBDatabase> {\n\t\treturn new Promise((c, e) => {\n\t\t\tconst request = indexedDB.open(name, version);\n\t\t\trequest.onerror = () => e(request.error);\n\t\t\trequest.onsuccess = () => {\n\t\t\t\tconst db = request.result;\n\t\t\t\tfor (const store of stores) {\n\t\t\t\t\tif (!db.objectStoreNames.contains(store)) {\n\t\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t\t`Error while opening IndexedDB. Could not find '${store}'' object store`,\n\t\t\t\t\t\t);\n\t\t\t\t\t\te(new MissingStoresError(db));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc(db);\n\t\t\t};\n\t\t\trequest.onupgradeneeded = () => {\n\t\t\t\tconst db = request.result;\n\t\t\t\tfor (const store of stores) {\n\t\t\t\t\tif (!db.objectStoreNames.contains(store)) {\n\t\t\t\t\t\tdb.createObjectStore(store);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t}\n\n\tprivate static deleteDatabase(database: IDBDatabase): Promise<void> {\n\t\treturn new Promise((c, e) => {\n\t\t\t// Close any opened connections\n\t\t\tdatabase.close();\n\n\t\t\t// Delete the db\n\t\t\tconst deleteRequest = indexedDB.deleteDatabase(database.name);\n\t\t\tdeleteRequest.onerror = (err) => e(deleteRequest.error);\n\t\t\tdeleteRequest.onsuccess = () => c();\n\t\t});\n\t}\n\n\tprivate database: IDBDatabase | null = null;\n\tprivate readonly pendingTransactions: IDBTransaction[] = [];\n\n\tconstructor(\n\t\tdatabase: IDBDatabase,\n\t\tprivate readonly name: string,\n\t) {\n\t\tthis.database = database;\n\t}\n\n\thasPendingTransactions(): boolean {\n\t\treturn this.pendingTransactions.length > 0;\n\t}\n\n\tclose(): void {\n\t\tif (this.pendingTransactions.length) {\n\t\t\tthis.pendingTransactions\n\t\t\t\t.splice(0, this.pendingTransactions.length)\n\t\t\t\t.forEach((transaction) => transaction.abort());\n\t\t}\n\t\tthis.database?.close();\n\t\tthis.database = null;\n\t}\n\n\trunInTransaction<T>(\n\t\tstore: string,\n\t\ttransactionMode: IDBTransactionMode,\n\t\tdbRequestFn: (store: IDBObjectStore) => IDBRequest<T>[],\n\t): Promise<T[]>;\n\trunInTransaction<T>(\n\t\tstore: string,\n\t\ttransactionMode: IDBTransactionMode,\n\t\tdbRequestFn: (store: IDBObjectStore) => IDBRequest<T>,\n\t): Promise<T>;\n\tasync runInTransaction<T>(\n\t\tstore: string,\n\t\ttransactionMode: IDBTransactionMode,\n\t\tdbRequestFn: (store: IDBObjectStore) => IDBRequest<T> | IDBRequest<T>[],\n\t): Promise<T | T[]> {\n\t\tif (!this.database) {\n\t\t\tthrow new DBClosedError(this.name);\n\t\t}\n\t\tconst transaction = this.database.transaction(store, transactionMode);\n\t\tthis.pendingTransactions.push(transaction);\n\t\treturn new Promise<T | T[]>((c, e) => {\n\t\t\ttransaction.oncomplete = () => {\n\t\t\t\tif (Array.isArray(request)) {\n\t\t\t\t\tc(request.map((r) => r.result));\n\t\t\t\t} else {\n\t\t\t\t\tc(request.result);\n\t\t\t\t}\n\t\t\t};\n\t\t\ttransaction.onerror = () =>\n\t\t\t\te(\n\t\t\t\t\ttransaction.error\n\t\t\t\t\t\t? ErrorNoTelemetry.fromError(transaction.error)\n\t\t\t\t\t\t: new ErrorNoTelemetry(\"unknown error\"),\n\t\t\t\t);\n\t\t\ttransaction.onabort = () =>\n\t\t\t\te(\n\t\t\t\t\ttransaction.error\n\t\t\t\t\t\t? ErrorNoTelemetry.fromError(transaction.error)\n\t\t\t\t\t\t: new ErrorNoTelemetry(\"unknown error\"),\n\t\t\t\t);\n\t\t\tconst request = dbRequestFn(transaction.objectStore(store));\n\t\t}).finally(() =>\n\t\t\tthis.pendingTransactions.splice(\n\t\t\t\tthis.pendingTransactions.indexOf(transaction),\n\t\t\t\t1,\n\t\t\t),\n\t\t);\n\t}\n\n\tasync getKeyValues<V>(\n\t\tstore: string,\n\t\tisValid: (value: unknown) => value is V,\n\t): Promise<Map<string, V>> {\n\t\tif (!this.database) {\n\t\t\tthrow new DBClosedError(this.name);\n\t\t}\n\t\tconst transaction = this.database.transaction(store, \"readonly\");\n\t\tthis.pendingTransactions.push(transaction);\n\t\treturn new Promise<Map<string, V>>((resolve) => {\n\t\t\tconst items = new Map<string, V>();\n\n\t\t\tconst objectStore = transaction.objectStore(store);\n\n\t\t\t// Open a IndexedDB Cursor to iterate over key/values\n\t\t\tconst cursor = objectStore.openCursor();\n\t\t\tif (!cursor) {\n\t\t\t\treturn resolve(items); // this means the `ItemTable` was empty\n\t\t\t}\n\n\t\t\t// Iterate over rows of `ItemTable` until the end\n\t\t\tcursor.onsuccess = () => {\n\t\t\t\tif (cursor.result) {\n\t\t\t\t\t// Keep cursor key/value in our map\n\t\t\t\t\tif (isValid(cursor.result.value)) {\n\t\t\t\t\t\titems.set(\n\t\t\t\t\t\t\tcursor.result.key.toString(),\n\t\t\t\t\t\t\tcursor.result.value,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Advance cursor to next row\n\t\t\t\t\tcursor.result.continue();\n\t\t\t\t} else {\n\t\t\t\t\tresolve(items); // reached end of table\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Error handlers\n\t\t\tconst onError = (error: Error | null) => {\n\t\t\t\tconsole.error(\n\t\t\t\t\t`IndexedDB getKeyValues(): ${toErrorMessage(error, true)}`,\n\t\t\t\t);\n\n\t\t\t\tresolve(items);\n\t\t\t};\n\t\t\tcursor.onerror = () => onError(cursor.error);\n\t\t\ttransaction.onerror = () => onError(transaction.error);\n\t\t}).finally(() =>\n\t\t\tthis.pendingTransactions.splice(\n\t\t\t\tthis.pendingTransactions.indexOf(transaction),\n\t\t\t\t1,\n\t\t\t),\n\t\t);\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
