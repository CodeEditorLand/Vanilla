{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/browser/performance.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport namespace inputLatency {\n\t// Measurements are recorded as totals, the average is calculated when the final measurements\n\t// are created.\n\tinterface ICumulativeMeasurement {\n\t\ttotal: number;\n\t\tmin: number;\n\t\tmax: number;\n\t}\n\tconst totalKeydownTime: ICumulativeMeasurement = {\n\t\ttotal: 0,\n\t\tmin: Number.MAX_VALUE,\n\t\tmax: 0,\n\t};\n\tconst totalInputTime: ICumulativeMeasurement = { ...totalKeydownTime };\n\tconst totalRenderTime: ICumulativeMeasurement = { ...totalKeydownTime };\n\tconst totalInputLatencyTime: ICumulativeMeasurement = {\n\t\t...totalKeydownTime,\n\t};\n\tlet measurementsCount = 0;\n\n\t// The state of each event, this helps ensure the integrity of the measurement and that\n\t// something unexpected didn't happen that could skew the measurement.\n\tenum EventPhase {\n\t\tBefore = 0,\n\t\tInProgress = 1,\n\t\tFinished = 2,\n\t}\n\tconst state = {\n\t\tkeydown: EventPhase.Before,\n\t\tinput: EventPhase.Before,\n\t\trender: EventPhase.Before,\n\t};\n\n\t/**\n\t * Record the start of the keydown event.\n\t */\n\texport function onKeyDown() {\n\t\t/** Direct Check C. See explanation in {@link recordIfFinished} */\n\t\trecordIfFinished();\n\t\tperformance.mark(\"inputlatency/start\");\n\t\tperformance.mark(\"keydown/start\");\n\t\tstate.keydown = EventPhase.InProgress;\n\t\tqueueMicrotask(markKeyDownEnd);\n\t}\n\n\t/**\n\t * Mark the end of the keydown event.\n\t */\n\tfunction markKeyDownEnd() {\n\t\tif (state.keydown === EventPhase.InProgress) {\n\t\t\tperformance.mark(\"keydown/end\");\n\t\t\tstate.keydown = EventPhase.Finished;\n\t\t}\n\t}\n\n\t/**\n\t * Record the start of the beforeinput event.\n\t */\n\texport function onBeforeInput() {\n\t\tperformance.mark(\"input/start\");\n\t\tstate.input = EventPhase.InProgress;\n\t\t/** Schedule Task A. See explanation in {@link recordIfFinished} */\n\t\tscheduleRecordIfFinishedTask();\n\t}\n\n\t/**\n\t * Record the start of the input event.\n\t */\n\texport function onInput() {\n\t\tif (state.input === EventPhase.Before) {\n\t\t\t// it looks like we didn't receive a `beforeinput`\n\t\t\tonBeforeInput();\n\t\t}\n\t\tqueueMicrotask(markInputEnd);\n\t}\n\n\tfunction markInputEnd() {\n\t\tif (state.input === EventPhase.InProgress) {\n\t\t\tperformance.mark(\"input/end\");\n\t\t\tstate.input = EventPhase.Finished;\n\t\t}\n\t}\n\n\t/**\n\t * Record the start of the keyup event.\n\t */\n\texport function onKeyUp() {\n\t\t/** Direct Check D. See explanation in {@link recordIfFinished} */\n\t\trecordIfFinished();\n\t}\n\n\t/**\n\t * Record the start of the selectionchange event.\n\t */\n\texport function onSelectionChange() {\n\t\t/** Direct Check E. See explanation in {@link recordIfFinished} */\n\t\trecordIfFinished();\n\t}\n\n\t/**\n\t * Record the start of the animation frame performing the rendering.\n\t */\n\texport function onRenderStart() {\n\t\t// Render may be triggered during input, but we only measure the following animation frame\n\t\tif (\n\t\t\tstate.keydown === EventPhase.Finished &&\n\t\t\tstate.input === EventPhase.Finished &&\n\t\t\tstate.render === EventPhase.Before\n\t\t) {\n\t\t\t// Only measure the first render after keyboard input\n\t\t\tperformance.mark(\"render/start\");\n\t\t\tstate.render = EventPhase.InProgress;\n\t\t\tqueueMicrotask(markRenderEnd);\n\t\t\t/** Schedule Task B. See explanation in {@link recordIfFinished} */\n\t\t\tscheduleRecordIfFinishedTask();\n\t\t}\n\t}\n\n\t/**\n\t * Mark the end of the animation frame performing the rendering.\n\t */\n\tfunction markRenderEnd() {\n\t\tif (state.render === EventPhase.InProgress) {\n\t\t\tperformance.mark(\"render/end\");\n\t\t\tstate.render = EventPhase.Finished;\n\t\t}\n\t}\n\n\tfunction scheduleRecordIfFinishedTask() {\n\t\t// Here we can safely assume that the `setTimeout` will not be\n\t\t// artificially delayed by 4ms because we schedule it from\n\t\t// event handlers\n\t\tsetTimeout(recordIfFinished);\n\t}\n\n\t/**\n\t * Record the input latency sample if input handling and rendering are finished.\n\t *\n\t * The challenge here is that we want to record the latency in such a way that it includes\n\t * also the layout and painting work the browser does during the animation frame task.\n\t *\n\t * Simply scheduling a new task (via `setTimeout`) from the animation frame task would\n\t * schedule the new task at the end of the task queue (after other code that uses `setTimeout`),\n\t * so we need to use multiple strategies to make sure our task runs before others:\n\t *\n\t * We schedule tasks (A and B):\n\t *    - we schedule a task A (via a `setTimeout` call) when the input starts in `markInputStart`.\n\t *      If the animation frame task is scheduled quickly by the browser, then task A has a very good\n\t *      chance of being the very first task after the animation frame and thus will record the input latency.\n\t *    - however, if the animation frame task is scheduled a bit later, then task A might execute\n\t *      before the animation frame task. We therefore schedule another task B from `markRenderStart`.\n\t *\n\t * We do direct checks in browser event handlers (C, D, E):\n\t *    - if the browser has multiple keydown events queued up, they will be scheduled before the `setTimeout` tasks,\n\t *      so we do a direct check in the keydown event handler (C).\n\t *    - depending on timing, sometimes the animation frame is scheduled even before the `keyup` event, so we\n\t *      do a direct check there too (E).\n\t *    - the browser oftentimes emits a `selectionchange` event after an `input`, so we do a direct check there (D).\n\t */\n\tfunction recordIfFinished() {\n\t\tif (\n\t\t\tstate.keydown === EventPhase.Finished &&\n\t\t\tstate.input === EventPhase.Finished &&\n\t\t\tstate.render === EventPhase.Finished\n\t\t) {\n\t\t\tperformance.mark(\"inputlatency/end\");\n\n\t\t\tperformance.measure(\"keydown\", \"keydown/start\", \"keydown/end\");\n\t\t\tperformance.measure(\"input\", \"input/start\", \"input/end\");\n\t\t\tperformance.measure(\"render\", \"render/start\", \"render/end\");\n\t\t\tperformance.measure(\n\t\t\t\t\"inputlatency\",\n\t\t\t\t\"inputlatency/start\",\n\t\t\t\t\"inputlatency/end\",\n\t\t\t);\n\n\t\t\taddMeasure(\"keydown\", totalKeydownTime);\n\t\t\taddMeasure(\"input\", totalInputTime);\n\t\t\taddMeasure(\"render\", totalRenderTime);\n\t\t\taddMeasure(\"inputlatency\", totalInputLatencyTime);\n\n\t\t\t// console.info(\n\t\t\t// \t`input latency=${performance.getEntriesByName('inputlatency')[0].duration.toFixed(1)} [` +\n\t\t\t// \t`keydown=${performance.getEntriesByName('keydown')[0].duration.toFixed(1)}, ` +\n\t\t\t// \t`input=${performance.getEntriesByName('input')[0].duration.toFixed(1)}, ` +\n\t\t\t// \t`render=${performance.getEntriesByName('render')[0].duration.toFixed(1)}` +\n\t\t\t// \t`]`\n\t\t\t// );\n\n\t\t\tmeasurementsCount++;\n\n\t\t\treset();\n\t\t}\n\t}\n\n\tfunction addMeasure(\n\t\tentryName: string,\n\t\tcumulativeMeasurement: ICumulativeMeasurement,\n\t): void {\n\t\tconst duration = performance.getEntriesByName(entryName)[0].duration;\n\t\tcumulativeMeasurement.total += duration;\n\t\tcumulativeMeasurement.min = Math.min(\n\t\t\tcumulativeMeasurement.min,\n\t\t\tduration,\n\t\t);\n\t\tcumulativeMeasurement.max = Math.max(\n\t\t\tcumulativeMeasurement.max,\n\t\t\tduration,\n\t\t);\n\t}\n\n\t/**\n\t * Clear the current sample.\n\t */\n\tfunction reset() {\n\t\tperformance.clearMarks(\"keydown/start\");\n\t\tperformance.clearMarks(\"keydown/end\");\n\t\tperformance.clearMarks(\"input/start\");\n\t\tperformance.clearMarks(\"input/end\");\n\t\tperformance.clearMarks(\"render/start\");\n\t\tperformance.clearMarks(\"render/end\");\n\t\tperformance.clearMarks(\"inputlatency/start\");\n\t\tperformance.clearMarks(\"inputlatency/end\");\n\n\t\tperformance.clearMeasures(\"keydown\");\n\t\tperformance.clearMeasures(\"input\");\n\t\tperformance.clearMeasures(\"render\");\n\t\tperformance.clearMeasures(\"inputlatency\");\n\n\t\tstate.keydown = EventPhase.Before;\n\t\tstate.input = EventPhase.Before;\n\t\tstate.render = EventPhase.Before;\n\t}\n\n\texport interface IInputLatencyMeasurements {\n\t\tkeydown: IInputLatencySingleMeasurement;\n\t\tinput: IInputLatencySingleMeasurement;\n\t\trender: IInputLatencySingleMeasurement;\n\t\ttotal: IInputLatencySingleMeasurement;\n\t\tsampleCount: number;\n\t}\n\n\texport interface IInputLatencySingleMeasurement {\n\t\taverage: number;\n\t\tmin: number;\n\t\tmax: number;\n\t}\n\n\t/**\n\t * Gets all input latency samples and clears the internal buffers to start recording a new set\n\t * of samples.\n\t */\n\texport function getAndClearMeasurements():\n\t\t| IInputLatencyMeasurements\n\t\t| undefined {\n\t\tif (measurementsCount === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Assemble the result\n\t\tconst result = {\n\t\t\tkeydown: cumulativeToFinalMeasurement(totalKeydownTime),\n\t\t\tinput: cumulativeToFinalMeasurement(totalInputTime),\n\t\t\trender: cumulativeToFinalMeasurement(totalRenderTime),\n\t\t\ttotal: cumulativeToFinalMeasurement(totalInputLatencyTime),\n\t\t\tsampleCount: measurementsCount,\n\t\t};\n\n\t\t// Clear the cumulative measurements\n\t\tclearCumulativeMeasurement(totalKeydownTime);\n\t\tclearCumulativeMeasurement(totalInputTime);\n\t\tclearCumulativeMeasurement(totalRenderTime);\n\t\tclearCumulativeMeasurement(totalInputLatencyTime);\n\t\tmeasurementsCount = 0;\n\n\t\treturn result;\n\t}\n\n\tfunction cumulativeToFinalMeasurement(\n\t\tcumulative: ICumulativeMeasurement,\n\t): IInputLatencySingleMeasurement {\n\t\treturn {\n\t\t\taverage: cumulative.total / measurementsCount,\n\t\t\tmax: cumulative.max,\n\t\t\tmin: cumulative.min,\n\t\t};\n\t}\n\n\tfunction clearCumulativeMeasurement(\n\t\tcumulative: ICumulativeMeasurement,\n\t): void {\n\t\tcumulative.total = 0;\n\t\tcumulative.min = Number.MAX_VALUE;\n\t\tcumulative.max = 0;\n\t}\n}\n"],
  "mappings": "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",
  "names": ["inputLatency", "EventPhase"]
}
