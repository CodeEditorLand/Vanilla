{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/browser/performance.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport namespace inputLatency {\n\n\t// Measurements are recorded as totals, the average is calculated when the final measurements\n\t// are created.\n\tinterface ICumulativeMeasurement {\n\t\ttotal: number;\n\t\tmin: number;\n\t\tmax: number;\n\t}\n\tconst totalKeydownTime: ICumulativeMeasurement = { total: 0, min: Number.MAX_VALUE, max: 0 };\n\tconst totalInputTime: ICumulativeMeasurement = { ...totalKeydownTime };\n\tconst totalRenderTime: ICumulativeMeasurement = { ...totalKeydownTime };\n\tconst totalInputLatencyTime: ICumulativeMeasurement = { ...totalKeydownTime };\n\tlet measurementsCount = 0;\n\n\n\n\t// The state of each event, this helps ensure the integrity of the measurement and that\n\t// something unexpected didn't happen that could skew the measurement.\n\tconst enum EventPhase {\n\t\tBefore = 0,\n\t\tInProgress = 1,\n\t\tFinished = 2\n\t}\n\tconst state = {\n\t\tkeydown: EventPhase.Before,\n\t\tinput: EventPhase.Before,\n\t\trender: EventPhase.Before,\n\t};\n\n\t/**\n\t * Record the start of the keydown event.\n\t */\n\texport function onKeyDown() {\n\t\t/** Direct Check C. See explanation in {@link recordIfFinished} */\n\t\trecordIfFinished();\n\t\tperformance.mark('inputlatency/start');\n\t\tperformance.mark('keydown/start');\n\t\tstate.keydown = EventPhase.InProgress;\n\t\tqueueMicrotask(markKeyDownEnd);\n\t}\n\n\t/**\n\t * Mark the end of the keydown event.\n\t */\n\tfunction markKeyDownEnd() {\n\t\tif (state.keydown === EventPhase.InProgress) {\n\t\t\tperformance.mark('keydown/end');\n\t\t\tstate.keydown = EventPhase.Finished;\n\t\t}\n\t}\n\n\t/**\n\t * Record the start of the beforeinput event.\n\t */\n\texport function onBeforeInput() {\n\t\tperformance.mark('input/start');\n\t\tstate.input = EventPhase.InProgress;\n\t\t/** Schedule Task A. See explanation in {@link recordIfFinished} */\n\t\tscheduleRecordIfFinishedTask();\n\t}\n\n\t/**\n\t * Record the start of the input event.\n\t */\n\texport function onInput() {\n\t\tif (state.input === EventPhase.Before) {\n\t\t\t// it looks like we didn't receive a `beforeinput`\n\t\t\tonBeforeInput();\n\t\t}\n\t\tqueueMicrotask(markInputEnd);\n\t}\n\n\tfunction markInputEnd() {\n\t\tif (state.input === EventPhase.InProgress) {\n\t\t\tperformance.mark('input/end');\n\t\t\tstate.input = EventPhase.Finished;\n\t\t}\n\t}\n\n\t/**\n\t * Record the start of the keyup event.\n\t */\n\texport function onKeyUp() {\n\t\t/** Direct Check D. See explanation in {@link recordIfFinished} */\n\t\trecordIfFinished();\n\t}\n\n\t/**\n\t * Record the start of the selectionchange event.\n\t */\n\texport function onSelectionChange() {\n\t\t/** Direct Check E. See explanation in {@link recordIfFinished} */\n\t\trecordIfFinished();\n\t}\n\n\t/**\n\t * Record the start of the animation frame performing the rendering.\n\t */\n\texport function onRenderStart() {\n\t\t// Render may be triggered during input, but we only measure the following animation frame\n\t\tif (state.keydown === EventPhase.Finished && state.input === EventPhase.Finished && state.render === EventPhase.Before) {\n\t\t\t// Only measure the first render after keyboard input\n\t\t\tperformance.mark('render/start');\n\t\t\tstate.render = EventPhase.InProgress;\n\t\t\tqueueMicrotask(markRenderEnd);\n\t\t\t/** Schedule Task B. See explanation in {@link recordIfFinished} */\n\t\t\tscheduleRecordIfFinishedTask();\n\t\t}\n\t}\n\n\t/**\n\t * Mark the end of the animation frame performing the rendering.\n\t */\n\tfunction markRenderEnd() {\n\t\tif (state.render === EventPhase.InProgress) {\n\t\t\tperformance.mark('render/end');\n\t\t\tstate.render = EventPhase.Finished;\n\t\t}\n\t}\n\n\tfunction scheduleRecordIfFinishedTask() {\n\t\t// Here we can safely assume that the `setTimeout` will not be\n\t\t// artificially delayed by 4ms because we schedule it from\n\t\t// event handlers\n\t\tsetTimeout(recordIfFinished);\n\t}\n\n\t/**\n\t * Record the input latency sample if input handling and rendering are finished.\n\t *\n\t * The challenge here is that we want to record the latency in such a way that it includes\n\t * also the layout and painting work the browser does during the animation frame task.\n\t *\n\t * Simply scheduling a new task (via `setTimeout`) from the animation frame task would\n\t * schedule the new task at the end of the task queue (after other code that uses `setTimeout`),\n\t * so we need to use multiple strategies to make sure our task runs before others:\n\t *\n\t * We schedule tasks (A and B):\n\t *    - we schedule a task A (via a `setTimeout` call) when the input starts in `markInputStart`.\n\t *      If the animation frame task is scheduled quickly by the browser, then task A has a very good\n\t *      chance of being the very first task after the animation frame and thus will record the input latency.\n\t *    - however, if the animation frame task is scheduled a bit later, then task A might execute\n\t *      before the animation frame task. We therefore schedule another task B from `markRenderStart`.\n\t *\n\t * We do direct checks in browser event handlers (C, D, E):\n\t *    - if the browser has multiple keydown events queued up, they will be scheduled before the `setTimeout` tasks,\n\t *      so we do a direct check in the keydown event handler (C).\n\t *    - depending on timing, sometimes the animation frame is scheduled even before the `keyup` event, so we\n\t *      do a direct check there too (E).\n\t *    - the browser oftentimes emits a `selectionchange` event after an `input`, so we do a direct check there (D).\n\t */\n\tfunction recordIfFinished() {\n\t\tif (state.keydown === EventPhase.Finished && state.input === EventPhase.Finished && state.render === EventPhase.Finished) {\n\t\t\tperformance.mark('inputlatency/end');\n\n\t\t\tperformance.measure('keydown', 'keydown/start', 'keydown/end');\n\t\t\tperformance.measure('input', 'input/start', 'input/end');\n\t\t\tperformance.measure('render', 'render/start', 'render/end');\n\t\t\tperformance.measure('inputlatency', 'inputlatency/start', 'inputlatency/end');\n\n\t\t\taddMeasure('keydown', totalKeydownTime);\n\t\t\taddMeasure('input', totalInputTime);\n\t\t\taddMeasure('render', totalRenderTime);\n\t\t\taddMeasure('inputlatency', totalInputLatencyTime);\n\n\t\t\t// console.info(\n\t\t\t// \t`input latency=${performance.getEntriesByName('inputlatency')[0].duration.toFixed(1)} [` +\n\t\t\t// \t`keydown=${performance.getEntriesByName('keydown')[0].duration.toFixed(1)}, ` +\n\t\t\t// \t`input=${performance.getEntriesByName('input')[0].duration.toFixed(1)}, ` +\n\t\t\t// \t`render=${performance.getEntriesByName('render')[0].duration.toFixed(1)}` +\n\t\t\t// \t`]`\n\t\t\t// );\n\n\t\t\tmeasurementsCount++;\n\n\t\t\treset();\n\t\t}\n\t}\n\n\tfunction addMeasure(entryName: string, cumulativeMeasurement: ICumulativeMeasurement): void {\n\t\tconst duration = performance.getEntriesByName(entryName)[0].duration;\n\t\tcumulativeMeasurement.total += duration;\n\t\tcumulativeMeasurement.min = Math.min(cumulativeMeasurement.min, duration);\n\t\tcumulativeMeasurement.max = Math.max(cumulativeMeasurement.max, duration);\n\t}\n\n\t/**\n\t * Clear the current sample.\n\t */\n\tfunction reset() {\n\t\tperformance.clearMarks('keydown/start');\n\t\tperformance.clearMarks('keydown/end');\n\t\tperformance.clearMarks('input/start');\n\t\tperformance.clearMarks('input/end');\n\t\tperformance.clearMarks('render/start');\n\t\tperformance.clearMarks('render/end');\n\t\tperformance.clearMarks('inputlatency/start');\n\t\tperformance.clearMarks('inputlatency/end');\n\n\t\tperformance.clearMeasures('keydown');\n\t\tperformance.clearMeasures('input');\n\t\tperformance.clearMeasures('render');\n\t\tperformance.clearMeasures('inputlatency');\n\n\t\tstate.keydown = EventPhase.Before;\n\t\tstate.input = EventPhase.Before;\n\t\tstate.render = EventPhase.Before;\n\t}\n\n\texport interface IInputLatencyMeasurements {\n\t\tkeydown: IInputLatencySingleMeasurement;\n\t\tinput: IInputLatencySingleMeasurement;\n\t\trender: IInputLatencySingleMeasurement;\n\t\ttotal: IInputLatencySingleMeasurement;\n\t\tsampleCount: number;\n\t}\n\n\texport interface IInputLatencySingleMeasurement {\n\t\taverage: number;\n\t\tmin: number;\n\t\tmax: number;\n\t}\n\n\t/**\n\t * Gets all input latency samples and clears the internal buffers to start recording a new set\n\t * of samples.\n\t */\n\texport function getAndClearMeasurements(): IInputLatencyMeasurements | undefined {\n\t\tif (measurementsCount === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Assemble the result\n\t\tconst result = {\n\t\t\tkeydown: cumulativeToFinalMeasurement(totalKeydownTime),\n\t\t\tinput: cumulativeToFinalMeasurement(totalInputTime),\n\t\t\trender: cumulativeToFinalMeasurement(totalRenderTime),\n\t\t\ttotal: cumulativeToFinalMeasurement(totalInputLatencyTime),\n\t\t\tsampleCount: measurementsCount\n\t\t};\n\n\t\t// Clear the cumulative measurements\n\t\tclearCumulativeMeasurement(totalKeydownTime);\n\t\tclearCumulativeMeasurement(totalInputTime);\n\t\tclearCumulativeMeasurement(totalRenderTime);\n\t\tclearCumulativeMeasurement(totalInputLatencyTime);\n\t\tmeasurementsCount = 0;\n\n\t\treturn result;\n\t}\n\n\tfunction cumulativeToFinalMeasurement(cumulative: ICumulativeMeasurement): IInputLatencySingleMeasurement {\n\t\treturn {\n\t\t\taverage: cumulative.total / measurementsCount,\n\t\t\tmax: cumulative.max,\n\t\t\tmin: cumulative.min,\n\t\t};\n\t}\n\n\tfunction clearCumulativeMeasurement(cumulative: ICumulativeMeasurement): void {\n\t\tcumulative.total = 0;\n\t\tcumulative.min = Number.MAX_VALUE;\n\t\tcumulative.max = 0;\n\t}\n\n}\n"],
  "mappings": "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",
  "names": ["inputLatency", "EventPhase"]
}
