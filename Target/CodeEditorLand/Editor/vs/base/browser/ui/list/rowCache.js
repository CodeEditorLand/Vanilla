import{$ as s}from"../../dom.js";class d{constructor(e){this.renderers=e}cache=new Map;transactionNodesPendingRemoval=new Set;inTransaction=!1;alloc(e){let t=this.getTemplateCache(e).pop(),o=!1;if(t)o=this.transactionNodesPendingRemoval.has(t.domNode),o&&this.transactionNodesPendingRemoval.delete(t.domNode);else{const r=s(".monaco-list-row"),n=this.getRenderer(e).renderTemplate(r);t={domNode:r,templateId:e,templateData:n}}return{row:t,isReusingConnectedDomNode:o}}release(e){e&&this.releaseRow(e)}transact(e){if(this.inTransaction)throw new Error("Already in transaction");this.inTransaction=!0;try{e()}finally{for(const t of this.transactionNodesPendingRemoval)this.doRemoveNode(t);this.transactionNodesPendingRemoval.clear(),this.inTransaction=!1}}releaseRow(e){const{domNode:t,templateId:o}=e;t&&(this.inTransaction?this.transactionNodesPendingRemoval.add(t):this.doRemoveNode(t)),this.getTemplateCache(o).push(e)}doRemoveNode(e){e.classList.remove("scrolling"),e.remove()}getTemplateCache(e){let t=this.cache.get(e);return t||(t=[],this.cache.set(e,t)),t}dispose(){this.cache.forEach((e,t)=>{for(const o of e)this.getRenderer(t).disposeTemplate(o.templateData),o.templateData=null}),this.cache.clear(),this.transactionNodesPendingRemoval.clear()}getRenderer(e){const t=this.renderers.get(e);if(!t)throw new Error(`No renderer found for ${e}`);return t}}export{d as RowCache};
