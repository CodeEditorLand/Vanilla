{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/browser/ui/tree/tree.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { Event } from \"../../../common/event.js\";\nimport type { IDragAndDropData } from \"../../dnd.js\";\nimport type { IMouseEvent } from \"../../mouseEvent.js\";\nimport {\n\ttype IListDragAndDrop,\n\ttype IListDragOverReaction,\n\ttype IListRenderer,\n\tListDragOverEffectPosition,\n\tListDragOverEffectType,\n} from \"../list/list.js\";\nimport type { ListViewTargetSector } from \"../list/listView.js\";\n\nexport enum TreeVisibility {\n\t/**\n\t * The tree node should be hidden.\n\t */\n\tHidden = 0,\n\n\t/**\n\t * The tree node should be visible.\n\t */\n\tVisible = 1,\n\n\t/**\n\t * The tree node should be visible if any of its descendants is visible.\n\t */\n\tRecurse = 2,\n}\n\n/**\n * A composed filter result containing the visibility result as well as\n * metadata.\n */\nexport interface ITreeFilterDataResult<TFilterData> {\n\t/**\n\t * Whether the node should be visible.\n\t */\n\tvisibility: boolean | TreeVisibility;\n\n\t/**\n\t * Metadata about the element's visibility which gets forwarded to the\n\t * renderer once the element gets rendered.\n\t */\n\tdata: TFilterData;\n}\n\n/**\n * The result of a filter call can be a boolean value indicating whether\n * the element should be visible or not, a value of type `TreeVisibility` or\n * an object composed of the visibility result as well as additional metadata\n * which gets forwarded to the renderer once the element gets rendered.\n */\nexport type TreeFilterResult<TFilterData> =\n\t| boolean\n\t| TreeVisibility\n\t| ITreeFilterDataResult<TFilterData>;\n\n/**\n * A tree filter is responsible for controlling the visibility of\n * elements in a tree.\n */\nexport interface ITreeFilter<T, TFilterData = void> {\n\t/**\n\t * Returns whether this elements should be visible and, if affirmative,\n\t * additional metadata which gets forwarded to the renderer once the element\n\t * gets rendered.\n\t *\n\t * @param element The tree element.\n\t */\n\tfilter(\n\t\telement: T,\n\t\tparentVisibility: TreeVisibility,\n\t): TreeFilterResult<TFilterData>;\n}\n\nexport interface ITreeSorter<T> {\n\tcompare(element: T, otherElement: T): number;\n}\n\nexport interface ITreeElement<T> {\n\treadonly element: T;\n\treadonly children?: Iterable<ITreeElement<T>>;\n\treadonly collapsible?: boolean;\n\treadonly collapsed?: boolean;\n}\n\nexport enum ObjectTreeElementCollapseState {\n\tExpanded = 0,\n\tCollapsed = 1,\n\n\t/**\n\t * If the element is already in the tree, preserve its current state. Else, expand it.\n\t */\n\tPreserveOrExpanded = 2,\n\n\t/**\n\t * If the element is already in the tree, preserve its current state. Else, collapse it.\n\t */\n\tPreserveOrCollapsed = 3,\n}\n\nexport interface IObjectTreeElement<T> {\n\treadonly element: T;\n\treadonly children?: Iterable<IObjectTreeElement<T>>;\n\treadonly collapsible?: boolean;\n\treadonly collapsed?: boolean | ObjectTreeElementCollapseState;\n}\n\nexport interface ITreeNode<T, TFilterData = void> {\n\treadonly element: T;\n\treadonly children: ITreeNode<T, TFilterData>[];\n\treadonly depth: number;\n\treadonly visibleChildrenCount: number;\n\treadonly visibleChildIndex: number;\n\treadonly collapsible: boolean;\n\treadonly collapsed: boolean;\n\treadonly visible: boolean;\n\treadonly filterData: TFilterData | undefined;\n}\n\nexport interface ICollapseStateChangeEvent<T, TFilterData> {\n\tnode: ITreeNode<T, TFilterData>;\n\tdeep: boolean;\n}\n\nexport interface ITreeListSpliceData<T, TFilterData> {\n\tstart: number;\n\tdeleteCount: number;\n\telements: ITreeNode<T, TFilterData>[];\n}\n\nexport interface ITreeModelSpliceEvent<T, TFilterData> {\n\tinsertedNodes: ITreeNode<T, TFilterData>[];\n\tdeletedNodes: ITreeNode<T, TFilterData>[];\n}\n\nexport interface ITreeModel<T, TFilterData, TRef> {\n\treadonly rootRef: TRef;\n\n\treadonly onDidSpliceModel: Event<ITreeModelSpliceEvent<T, TFilterData>>;\n\treadonly onDidSpliceRenderedNodes: Event<\n\t\tITreeListSpliceData<T, TFilterData>\n\t>;\n\treadonly onDidChangeCollapseState: Event<\n\t\tICollapseStateChangeEvent<T, TFilterData>\n\t>;\n\treadonly onDidChangeRenderNodeCount: Event<ITreeNode<T, TFilterData>>;\n\n\thas(location: TRef): boolean;\n\n\tgetListIndex(location: TRef): number;\n\tgetListRenderCount(location: TRef): number;\n\tgetNode(location?: TRef): ITreeNode<T, any>;\n\tgetNodeLocation(node: ITreeNode<T, any>): TRef;\n\tgetParentNodeLocation(location: TRef): TRef | undefined;\n\n\tgetFirstElementChild(location: TRef): T | undefined;\n\tgetLastElementAncestor(location?: TRef): T | undefined;\n\n\tisCollapsible(location: TRef): boolean;\n\tsetCollapsible(location: TRef, collapsible?: boolean): boolean;\n\tisCollapsed(location: TRef): boolean;\n\tsetCollapsed(\n\t\tlocation: TRef,\n\t\tcollapsed?: boolean,\n\t\trecursive?: boolean,\n\t): boolean;\n\texpandTo(location: TRef): void;\n\n\trerender(location: TRef): void;\n\trefilter(): void;\n}\n\nexport interface ITreeRenderer<T, TFilterData = void, TTemplateData = void>\n\textends IListRenderer<ITreeNode<T, TFilterData>, TTemplateData> {\n\trenderTwistie?(element: T, twistieElement: HTMLElement): boolean;\n\tonDidChangeTwistieState?: Event<T>;\n}\n\nexport interface ITreeEvent<T> {\n\treadonly elements: readonly T[];\n\treadonly browserEvent?: UIEvent;\n}\n\nexport enum TreeMouseEventTarget {\n\tUnknown = 0,\n\tTwistie = 1,\n\tElement = 2,\n\tFilter = 3,\n}\n\nexport interface ITreeMouseEvent<T> {\n\treadonly browserEvent: MouseEvent;\n\treadonly element: T | null;\n\treadonly target: TreeMouseEventTarget;\n}\n\nexport interface ITreeContextMenuEvent<T> {\n\treadonly browserEvent: UIEvent;\n\treadonly element: T | null;\n\treadonly anchor: HTMLElement | IMouseEvent;\n\treadonly isStickyScroll: boolean;\n}\n\nexport interface ITreeNavigator<T> {\n\tcurrent(): T | null;\n\tprevious(): T | null;\n\tfirst(): T | null;\n\tlast(): T | null;\n\tnext(): T | null;\n}\n\nexport interface IDataSource<TInput, T> {\n\thasChildren?(element: TInput | T): boolean;\n\tgetChildren(element: TInput | T): Iterable<T>;\n}\n\nexport interface IAsyncDataSource<TInput, T> {\n\thasChildren(element: TInput | T): boolean;\n\tgetChildren(element: TInput | T): Iterable<T> | Promise<Iterable<T>>;\n\tgetParent?(element: T): TInput | T;\n}\n\nexport enum TreeDragOverBubble {\n\tDown = 0,\n\tUp = 1,\n}\n\nexport interface ITreeDragOverReaction extends IListDragOverReaction {\n\tbubble?: TreeDragOverBubble;\n\tautoExpand?: boolean;\n}\n\nexport const TreeDragOverReactions = {\n\tacceptBubbleUp(): ITreeDragOverReaction {\n\t\treturn { accept: true, bubble: TreeDragOverBubble.Up };\n\t},\n\tacceptBubbleDown(autoExpand = false): ITreeDragOverReaction {\n\t\treturn { accept: true, bubble: TreeDragOverBubble.Down, autoExpand };\n\t},\n\tacceptCopyBubbleUp(): ITreeDragOverReaction {\n\t\treturn {\n\t\t\taccept: true,\n\t\t\tbubble: TreeDragOverBubble.Up,\n\t\t\teffect: {\n\t\t\t\ttype: ListDragOverEffectType.Copy,\n\t\t\t\tposition: ListDragOverEffectPosition.Over,\n\t\t\t},\n\t\t};\n\t},\n\tacceptCopyBubbleDown(autoExpand = false): ITreeDragOverReaction {\n\t\treturn {\n\t\t\taccept: true,\n\t\t\tbubble: TreeDragOverBubble.Down,\n\t\t\teffect: {\n\t\t\t\ttype: ListDragOverEffectType.Copy,\n\t\t\t\tposition: ListDragOverEffectPosition.Over,\n\t\t\t},\n\t\t\tautoExpand,\n\t\t};\n\t},\n};\n\nexport interface ITreeDragAndDrop<T> extends IListDragAndDrop<T> {\n\tonDragOver(\n\t\tdata: IDragAndDropData,\n\t\ttargetElement: T | undefined,\n\t\ttargetIndex: number | undefined,\n\t\ttargetSector: ListViewTargetSector | undefined,\n\t\toriginalEvent: DragEvent,\n\t): boolean | ITreeDragOverReaction;\n}\n\nexport class TreeError extends Error {\n\tconstructor(user: string, message: string) {\n\t\tsuper(`TreeError [${user}] ${message}`);\n\t}\n}\n\nexport class WeakMapper<K extends object, V> {\n\tconstructor(private fn: (k: K) => V) {}\n\n\tprivate _map = new WeakMap<K, V>();\n\n\tmap(key: K): V {\n\t\tlet result = this._map.get(key);\n\n\t\tif (!result) {\n\t\t\tresult = this.fn(key);\n\t\t\tthis._map.set(key, result);\n\t\t}\n\n\t\treturn result;\n\t}\n}\n"],
  "mappings": ";;AAQA;AAAA,EAIC;AAAA,EACA;AAAA,OACM;AAGA,IAAK,iBAAL,kBAAKA,oBAAL;AAIN,EAAAA,gCAAA,YAAS,KAAT;AAKA,EAAAA,gCAAA,aAAU,KAAV;AAKA,EAAAA,gCAAA,aAAU,KAAV;AAdW,SAAAA;AAAA,GAAA;AA0EL,IAAK,iCAAL,kBAAKC,oCAAL;AACN,EAAAA,gEAAA,cAAW,KAAX;AACA,EAAAA,gEAAA,eAAY,KAAZ;AAKA,EAAAA,gEAAA,wBAAqB,KAArB;AAKA,EAAAA,gEAAA,yBAAsB,KAAtB;AAZW,SAAAA;AAAA,GAAA;AAkGL,IAAK,uBAAL,kBAAKC,0BAAL;AACN,EAAAA,4CAAA,aAAU,KAAV;AACA,EAAAA,4CAAA,aAAU,KAAV;AACA,EAAAA,4CAAA,aAAU,KAAV;AACA,EAAAA,4CAAA,YAAS,KAAT;AAJW,SAAAA;AAAA,GAAA;AAuCL,IAAK,qBAAL,kBAAKC,wBAAL;AACN,EAAAA,wCAAA,UAAO,KAAP;AACA,EAAAA,wCAAA,QAAK,KAAL;AAFW,SAAAA;AAAA,GAAA;AAUL,MAAM,wBAAwB;AAAA,EACpC,iBAAwC;AACvC,WAAO,EAAE,QAAQ,MAAM,QAAQ,WAAsB;AAAA,EACtD;AAAA,EACA,iBAAiB,aAAa,OAA8B;AAC3D,WAAO,EAAE,QAAQ,MAAM,QAAQ,cAAyB,WAAW;AAAA,EACpE;AAAA,EACA,qBAA4C;AAC3C,WAAO;AAAA,MACN,QAAQ;AAAA,MACR,QAAQ;AAAA,MACR,QAAQ;AAAA,QACP,MAAM,uBAAuB;AAAA,QAC7B,UAAU,2BAA2B;AAAA,MACtC;AAAA,IACD;AAAA,EACD;AAAA,EACA,qBAAqB,aAAa,OAA8B;AAC/D,WAAO;AAAA,MACN,QAAQ;AAAA,MACR,QAAQ;AAAA,MACR,QAAQ;AAAA,QACP,MAAM,uBAAuB;AAAA,QAC7B,UAAU,2BAA2B;AAAA,MACtC;AAAA,MACA;AAAA,IACD;AAAA,EACD;AACD;AAYO,MAAM,kBAAkB,MAAM;AAAA,EAtRrC,OAsRqC;AAAA;AAAA;AAAA,EACpC,YAAY,MAAc,SAAiB;AAC1C,UAAM,cAAc,IAAI,KAAK,OAAO,EAAE;AAAA,EACvC;AACD;AAEO,MAAM,WAAgC;AAAA,EAC5C,YAAoB,IAAiB;AAAjB;AAAA,EAAkB;AAAA,EA7RvC,OA4R6C;AAAA;AAAA;AAAA,EAGpC,OAAO,oBAAI,QAAc;AAAA,EAEjC,IAAI,KAAW;AACd,QAAI,SAAS,KAAK,KAAK,IAAI,GAAG;AAE9B,QAAI,CAAC,QAAQ;AACZ,eAAS,KAAK,GAAG,GAAG;AACpB,WAAK,KAAK,IAAI,KAAK,MAAM;AAAA,IAC1B;AAEA,WAAO;AAAA,EACR;AACD;",
  "names": ["TreeVisibility", "ObjectTreeElementCollapseState", "TreeMouseEventTarget", "TreeDragOverBubble"]
}
