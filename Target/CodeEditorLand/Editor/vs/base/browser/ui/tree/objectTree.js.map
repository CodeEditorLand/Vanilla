{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/browser/ui/tree/objectTree.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IIdentityProvider, IKeyboardNavigationLabelProvider, IListVirtualDelegate } from '../list/list.js';\nimport { AbstractTree, IAbstractTreeOptions, IAbstractTreeOptionsUpdate, IStickyScrollDelegate, StickyScrollNode } from './abstractTree.js';\nimport { CompressibleObjectTreeModel, ElementMapper, ICompressedTreeElement, ICompressedTreeNode } from './compressedObjectTreeModel.js';\nimport { IObjectTreeModel, ObjectTreeModel } from './objectTreeModel.js';\nimport { ICollapseStateChangeEvent, IObjectTreeElement, ITreeModel, ITreeNode, ITreeRenderer, ITreeSorter } from './tree.js';\nimport { memoize } from '../../../common/decorators.js';\nimport { Event } from '../../../common/event.js';\nimport { Iterable } from '../../../common/iterator.js';\n\nexport interface IObjectTreeOptions<T, TFilterData = void> extends IAbstractTreeOptions<T, TFilterData> {\n\treadonly sorter?: ITreeSorter<T>;\n}\n\nexport interface IObjectTreeSetChildrenOptions<T> {\n\n\t/**\n\t * If set, child updates will recurse the given number of levels even if\n\t * items in the splice operation are unchanged. `Infinity` is a valid value.\n\t */\n\treadonly diffDepth?: number;\n\n\t/**\n\t * Identity provider used to optimize splice() calls in the IndexTree. If\n\t * this is not present, optimized splicing is not enabled.\n\t *\n\t * Warning: if this is present, calls to `setChildren()` will not replace\n\t * or update nodes if their identity is the same, even if the elements are\n\t * different. For this, you should call `rerender()`.\n\t */\n\treadonly diffIdentityProvider?: IIdentityProvider<T>;\n}\n\nexport class ObjectTree<T extends NonNullable<any>, TFilterData = void> extends AbstractTree<T | null, TFilterData, T | null> {\n\n\tprotected declare model: IObjectTreeModel<T, TFilterData>;\n\n\toverride get onDidChangeCollapseState(): Event<ICollapseStateChangeEvent<T | null, TFilterData>> { return this.model.onDidChangeCollapseState; }\n\n\tconstructor(\n\t\tprotected readonly user: string,\n\t\tcontainer: HTMLElement,\n\t\tdelegate: IListVirtualDelegate<T>,\n\t\trenderers: ITreeRenderer<T, TFilterData, any>[],\n\t\toptions: IObjectTreeOptions<T, TFilterData> = {}\n\t) {\n\t\tsuper(user, container, delegate, renderers, options as IObjectTreeOptions<T | null, TFilterData>);\n\t}\n\n\tsetChildren(element: T | null, children: Iterable<IObjectTreeElement<T>> = Iterable.empty(), options?: IObjectTreeSetChildrenOptions<T>): void {\n\t\tthis.model.setChildren(element, children, options);\n\t}\n\n\trerender(element?: T): void {\n\t\tif (element === undefined) {\n\t\t\tthis.view.rerender();\n\t\t\treturn;\n\t\t}\n\n\t\tthis.model.rerender(element);\n\t}\n\n\tupdateElementHeight(element: T, height: number | undefined): void {\n\t\tconst elementIndex = this.model.getListIndex(element);\n\t\tif (elementIndex === -1) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.view.updateElementHeight(elementIndex, height);\n\t}\n\n\tresort(element: T | null, recursive = true): void {\n\t\tthis.model.resort(element, recursive);\n\t}\n\n\thasElement(element: T): boolean {\n\t\treturn this.model.has(element);\n\t}\n\n\tprotected createModel(user: string, options: IObjectTreeOptions<T, TFilterData>): ITreeModel<T | null, TFilterData, T | null> {\n\t\treturn new ObjectTreeModel(user, options);\n\t}\n}\n\ninterface ICompressedTreeNodeProvider<T, TFilterData> {\n\tgetCompressedTreeNode(location: T | null): ITreeNode<ICompressedTreeNode<T> | null, TFilterData>;\n}\n\nexport interface ICompressibleTreeRenderer<T, TFilterData = void, TTemplateData = void> extends ITreeRenderer<T, TFilterData, TTemplateData> {\n\trenderCompressedElements(node: ITreeNode<ICompressedTreeNode<T>, TFilterData>, index: number, templateData: TTemplateData, height: number | undefined): void;\n\tdisposeCompressedElements?(node: ITreeNode<ICompressedTreeNode<T>, TFilterData>, index: number, templateData: TTemplateData, height: number | undefined): void;\n}\n\ninterface CompressibleTemplateData<T, TFilterData, TTemplateData> {\n\tcompressedTreeNode: ITreeNode<ICompressedTreeNode<T>, TFilterData> | undefined;\n\treadonly data: TTemplateData;\n}\n\nclass CompressibleRenderer<T extends NonNullable<any>, TFilterData, TTemplateData> implements ITreeRenderer<T, TFilterData, CompressibleTemplateData<T, TFilterData, TTemplateData>> {\n\n\treadonly templateId: string;\n\treadonly onDidChangeTwistieState: Event<T> | undefined;\n\n\t@memoize\n\tprivate get compressedTreeNodeProvider(): ICompressedTreeNodeProvider<T, TFilterData> {\n\t\treturn this._compressedTreeNodeProvider();\n\t}\n\n\tconstructor(private _compressedTreeNodeProvider: () => ICompressedTreeNodeProvider<T, TFilterData>, private stickyScrollDelegate: CompressibleStickyScrollDelegate<T, TFilterData>, private renderer: ICompressibleTreeRenderer<T, TFilterData, TTemplateData>) {\n\t\tthis.templateId = renderer.templateId;\n\n\t\tif (renderer.onDidChangeTwistieState) {\n\t\t\tthis.onDidChangeTwistieState = renderer.onDidChangeTwistieState;\n\t\t}\n\t}\n\n\trenderTemplate(container: HTMLElement): CompressibleTemplateData<T, TFilterData, TTemplateData> {\n\t\tconst data = this.renderer.renderTemplate(container);\n\t\treturn { compressedTreeNode: undefined, data };\n\t}\n\n\trenderElement(node: ITreeNode<T, TFilterData>, index: number, templateData: CompressibleTemplateData<T, TFilterData, TTemplateData>, height: number | undefined): void {\n\t\tlet compressedTreeNode = this.stickyScrollDelegate.getCompressedNode(node);\n\t\tif (!compressedTreeNode) {\n\t\t\tcompressedTreeNode = this.compressedTreeNodeProvider.getCompressedTreeNode(node.element) as ITreeNode<ICompressedTreeNode<T>, TFilterData>;\n\t\t}\n\n\t\tif (compressedTreeNode.element.elements.length === 1) {\n\t\t\ttemplateData.compressedTreeNode = undefined;\n\t\t\tthis.renderer.renderElement(node, index, templateData.data, height);\n\t\t} else {\n\t\t\ttemplateData.compressedTreeNode = compressedTreeNode;\n\t\t\tthis.renderer.renderCompressedElements(compressedTreeNode, index, templateData.data, height);\n\t\t}\n\t}\n\n\tdisposeElement(node: ITreeNode<T, TFilterData>, index: number, templateData: CompressibleTemplateData<T, TFilterData, TTemplateData>, height: number | undefined): void {\n\t\tif (templateData.compressedTreeNode) {\n\t\t\tthis.renderer.disposeCompressedElements?.(templateData.compressedTreeNode, index, templateData.data, height);\n\t\t} else {\n\t\t\tthis.renderer.disposeElement?.(node, index, templateData.data, height);\n\t\t}\n\t}\n\n\tdisposeTemplate(templateData: CompressibleTemplateData<T, TFilterData, TTemplateData>): void {\n\t\tthis.renderer.disposeTemplate(templateData.data);\n\t}\n\n\trenderTwistie?(element: T, twistieElement: HTMLElement): boolean {\n\t\tif (this.renderer.renderTwistie) {\n\t\t\treturn this.renderer.renderTwistie(element, twistieElement);\n\t\t}\n\t\treturn false;\n\t}\n}\n\nclass CompressibleStickyScrollDelegate<T, TFilterData> implements IStickyScrollDelegate<T, TFilterData> {\n\n\tprivate readonly compressedStickyNodes = new Map<ITreeNode<T, TFilterData>, ITreeNode<ICompressedTreeNode<T>, TFilterData>>();\n\n\tconstructor(private readonly modelProvider: () => CompressibleObjectTreeModel<T, TFilterData>) { }\n\n\tgetCompressedNode(node: ITreeNode<T, TFilterData>): ITreeNode<ICompressedTreeNode<T>, TFilterData> | undefined {\n\t\treturn this.compressedStickyNodes.get(node);\n\t}\n\n\tconstrainStickyScrollNodes(stickyNodes: StickyScrollNode<T, TFilterData>[], stickyScrollMaxItemCount: number, maxWidgetHeight: number): StickyScrollNode<T, TFilterData>[] {\n\t\tthis.compressedStickyNodes.clear();\n\t\tif (stickyNodes.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\tfor (let i = 0; i < stickyNodes.length; i++) {\n\t\t\tconst stickyNode = stickyNodes[i];\n\t\t\tconst stickyNodeBottom = stickyNode.position + stickyNode.height;\n\t\t\tconst followingReachesMaxHeight = i + 1 < stickyNodes.length && stickyNodeBottom + stickyNodes[i + 1].height > maxWidgetHeight;\n\n\t\t\tif (followingReachesMaxHeight || i >= stickyScrollMaxItemCount - 1 && stickyScrollMaxItemCount < stickyNodes.length) {\n\t\t\t\tconst uncompressedStickyNodes = stickyNodes.slice(0, i);\n\t\t\t\tconst overflowingStickyNodes = stickyNodes.slice(i);\n\t\t\t\tconst compressedStickyNode = this.compressStickyNodes(overflowingStickyNodes);\n\t\t\t\treturn [...uncompressedStickyNodes, compressedStickyNode];\n\t\t\t}\n\n\t\t}\n\n\t\treturn stickyNodes;\n\t}\n\n\tprivate compressStickyNodes(stickyNodes: StickyScrollNode<T, TFilterData>[]): StickyScrollNode<T, TFilterData> {\n\n\t\tif (stickyNodes.length === 0) {\n\t\t\tthrow new Error('Can\\'t compress empty sticky nodes');\n\t\t}\n\t\tconst compressionModel = this.modelProvider();\n\t\tif (!compressionModel.isCompressionEnabled()) {\n\t\t\treturn stickyNodes[0];\n\t\t}\n\n\t\t// Collect all elements to be compressed\n\t\tconst elements: T[] = [];\n\t\tfor (let i = 0; i < stickyNodes.length; i++) {\n\t\t\tconst stickyNode = stickyNodes[i];\n\t\t\tconst compressedNode = compressionModel.getCompressedTreeNode(stickyNode.node.element);\n\n\t\t\tif (compressedNode.element) {\n\t\t\t\t// if an element is incompressible, it can't be compressed with it's parent element\n\t\t\t\tif (i !== 0 && compressedNode.element.incompressible) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telements.push(...compressedNode.element.elements);\n\t\t\t}\n\t\t}\n\n\t\tif (elements.length < 2) {\n\t\t\treturn stickyNodes[0];\n\t\t}\n\n\t\t// Compress the elements\n\t\tconst lastStickyNode = stickyNodes[stickyNodes.length - 1];\n\t\tconst compressedElement: ICompressedTreeNode<T> = { elements, incompressible: false };\n\t\tconst compressedNode: ITreeNode<ICompressedTreeNode<T>, TFilterData> = { ...lastStickyNode.node, children: [], element: compressedElement };\n\n\t\tconst stickyTreeNode = new Proxy(stickyNodes[0].node, {});\n\n\t\tconst compressedStickyNode: StickyScrollNode<T, TFilterData> = {\n\t\t\tnode: stickyTreeNode,\n\t\t\tstartIndex: stickyNodes[0].startIndex,\n\t\t\tendIndex: lastStickyNode.endIndex,\n\t\t\tposition: stickyNodes[0].position,\n\t\t\theight: stickyNodes[0].height,\n\t\t};\n\n\t\tthis.compressedStickyNodes.set(stickyTreeNode, compressedNode);\n\n\t\treturn compressedStickyNode;\n\t}\n}\n\nexport interface ICompressibleKeyboardNavigationLabelProvider<T> extends IKeyboardNavigationLabelProvider<T> {\n\tgetCompressedNodeKeyboardNavigationLabel(elements: T[]): { toString(): string | undefined } | undefined;\n}\n\nexport interface ICompressibleObjectTreeOptions<T, TFilterData = void> extends IObjectTreeOptions<T, TFilterData> {\n\treadonly compressionEnabled?: boolean;\n\treadonly elementMapper?: ElementMapper<T>;\n\treadonly keyboardNavigationLabelProvider?: ICompressibleKeyboardNavigationLabelProvider<T>;\n}\n\nfunction asObjectTreeOptions<T, TFilterData>(compressedTreeNodeProvider: () => ICompressedTreeNodeProvider<T, TFilterData>, options?: ICompressibleObjectTreeOptions<T, TFilterData>): IObjectTreeOptions<T, TFilterData> | undefined {\n\treturn options && {\n\t\t...options,\n\t\tkeyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && {\n\t\t\tgetKeyboardNavigationLabel(e: T) {\n\t\t\t\tlet compressedTreeNode: ITreeNode<ICompressedTreeNode<T>, TFilterData>;\n\n\t\t\t\ttry {\n\t\t\t\t\tcompressedTreeNode = compressedTreeNodeProvider().getCompressedTreeNode(e) as ITreeNode<ICompressedTreeNode<T>, TFilterData>;\n\t\t\t\t} catch {\n\t\t\t\t\treturn options.keyboardNavigationLabelProvider!.getKeyboardNavigationLabel(e);\n\t\t\t\t}\n\n\t\t\t\tif (compressedTreeNode.element.elements.length === 1) {\n\t\t\t\t\treturn options.keyboardNavigationLabelProvider!.getKeyboardNavigationLabel(e);\n\t\t\t\t} else {\n\t\t\t\t\treturn options.keyboardNavigationLabelProvider!.getCompressedNodeKeyboardNavigationLabel(compressedTreeNode.element.elements);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\nexport interface ICompressibleObjectTreeOptionsUpdate extends IAbstractTreeOptionsUpdate {\n\treadonly compressionEnabled?: boolean;\n}\n\nexport class CompressibleObjectTree<T extends NonNullable<any>, TFilterData = void> extends ObjectTree<T, TFilterData> implements ICompressedTreeNodeProvider<T, TFilterData> {\n\n\tprotected declare model: CompressibleObjectTreeModel<T, TFilterData>;\n\n\tconstructor(\n\t\tuser: string,\n\t\tcontainer: HTMLElement,\n\t\tdelegate: IListVirtualDelegate<T>,\n\t\trenderers: ICompressibleTreeRenderer<T, TFilterData, any>[],\n\t\toptions: ICompressibleObjectTreeOptions<T, TFilterData> = {}\n\t) {\n\t\tconst compressedTreeNodeProvider = () => this;\n\t\tconst stickyScrollDelegate = new CompressibleStickyScrollDelegate<T, TFilterData>(() => this.model);\n\t\tconst compressibleRenderers = renderers.map(r => new CompressibleRenderer<T, TFilterData, any>(compressedTreeNodeProvider, stickyScrollDelegate, r));\n\n\t\tsuper(user, container, delegate, compressibleRenderers, { ...asObjectTreeOptions<T, TFilterData>(compressedTreeNodeProvider, options), stickyScrollDelegate });\n\t}\n\n\toverride setChildren(element: T | null, children: Iterable<ICompressedTreeElement<T>> = Iterable.empty(), options?: IObjectTreeSetChildrenOptions<T>): void {\n\t\tthis.model.setChildren(element, children, options);\n\t}\n\n\tprotected override createModel(user: string, options: ICompressibleObjectTreeOptions<T, TFilterData>): ITreeModel<T | null, TFilterData, T | null> {\n\t\treturn new CompressibleObjectTreeModel(user, options);\n\t}\n\n\toverride updateOptions(optionsUpdate: ICompressibleObjectTreeOptionsUpdate = {}): void {\n\t\tsuper.updateOptions(optionsUpdate);\n\n\t\tif (typeof optionsUpdate.compressionEnabled !== 'undefined') {\n\t\t\tthis.model.setCompressionEnabled(optionsUpdate.compressionEnabled);\n\t\t}\n\t}\n\n\tgetCompressedTreeNode(element: T | null = null): ITreeNode<ICompressedTreeNode<T> | null, TFilterData> {\n\t\treturn this.model.getCompressedTreeNode(element);\n\t}\n}\n"],
  "mappings": ";;;;;;;;;;;AAKA,SAAS,mBAAmB,kCAAkC,4BAA4B;AAC1F,SAAS,cAAc,sBAAsB,4BAA4B,uBAAuB,wBAAwB;AACxH,SAAS,6BAA6B,eAAe,wBAAwB,2BAA2B;AACxG,SAAS,kBAAkB,uBAAuB;AAClD,SAAS,2BAA2B,oBAAoB,YAAY,WAAW,eAAe,mBAAmB;AACjH,SAAS,eAAe;AACxB,SAAS,aAAa;AACtB,SAAS,gBAAgB;AAyBlB,MAAM,mBAAmE,aAA8C;AAAA,EAM7H,YACoB,MACnB,WACA,UACA,WACA,UAA8C,CAAC,GAC9C;AACD,UAAM,MAAM,WAAW,UAAU,WAAW,OAAoD;AAN7E;AAAA,EAOpB;AAAA,EAnDD,OAqC8H;AAAA;AAAA;AAAA,EAI7H,IAAa,2BAAoF;AAAE,WAAO,KAAK,MAAM;AAAA,EAA0B;AAAA,EAY/I,YAAY,SAAmB,WAA4C,SAAS,MAAM,GAAG,SAAkD;AAC9I,SAAK,MAAM,YAAY,SAAS,UAAU,OAAO;AAAA,EAClD;AAAA,EAEA,SAAS,SAAmB;AAC3B,QAAI,YAAY,QAAW;AAC1B,WAAK,KAAK,SAAS;AACnB;AAAA,IACD;AAEA,SAAK,MAAM,SAAS,OAAO;AAAA,EAC5B;AAAA,EAEA,oBAAoB,SAAY,QAAkC;AACjE,UAAM,eAAe,KAAK,MAAM,aAAa,OAAO;AACpD,QAAI,iBAAiB,IAAI;AACxB;AAAA,IACD;AAEA,SAAK,KAAK,oBAAoB,cAAc,MAAM;AAAA,EACnD;AAAA,EAEA,OAAO,SAAmB,YAAY,MAAY;AACjD,SAAK,MAAM,OAAO,SAAS,SAAS;AAAA,EACrC;AAAA,EAEA,WAAW,SAAqB;AAC/B,WAAO,KAAK,MAAM,IAAI,OAAO;AAAA,EAC9B;AAAA,EAEU,YAAY,MAAc,SAA0F;AAC7H,WAAO,IAAI,gBAAgB,MAAM,OAAO;AAAA,EACzC;AACD;AAgBA,MAAM,qBAA+K;AAAA,EAUpL,YAAoB,6BAAwF,sBAAgF,UAAoE;AAA5O;AAAwF;AAAgF;AAC3L,SAAK,aAAa,SAAS;AAE3B,QAAI,SAAS,yBAAyB;AACrC,WAAK,0BAA0B,SAAS;AAAA,IACzC;AAAA,EACD;AAAA,EAtHD,OAsGqL;AAAA;AAAA;AAAA,EAE3K;AAAA,EACA;AAAA,EAGT,IAAY,6BAA0E;AACrF,WAAO,KAAK,4BAA4B;AAAA,EACzC;AAAA,EAUA,eAAe,WAAiF;AAC/F,UAAM,OAAO,KAAK,SAAS,eAAe,SAAS;AACnD,WAAO,EAAE,oBAAoB,QAAW,KAAK;AAAA,EAC9C;AAAA,EAEA,cAAc,MAAiC,OAAe,cAAuE,QAAkC;AACtK,QAAI,qBAAqB,KAAK,qBAAqB,kBAAkB,IAAI;AACzE,QAAI,CAAC,oBAAoB;AACxB,2BAAqB,KAAK,2BAA2B,sBAAsB,KAAK,OAAO;AAAA,IACxF;AAEA,QAAI,mBAAmB,QAAQ,SAAS,WAAW,GAAG;AACrD,mBAAa,qBAAqB;AAClC,WAAK,SAAS,cAAc,MAAM,OAAO,aAAa,MAAM,MAAM;AAAA,IACnE,OAAO;AACN,mBAAa,qBAAqB;AAClC,WAAK,SAAS,yBAAyB,oBAAoB,OAAO,aAAa,MAAM,MAAM;AAAA,IAC5F;AAAA,EACD;AAAA,EAEA,eAAe,MAAiC,OAAe,cAAuE,QAAkC;AACvK,QAAI,aAAa,oBAAoB;AACpC,WAAK,SAAS,4BAA4B,aAAa,oBAAoB,OAAO,aAAa,MAAM,MAAM;AAAA,IAC5G,OAAO;AACN,WAAK,SAAS,iBAAiB,MAAM,OAAO,aAAa,MAAM,MAAM;AAAA,IACtE;AAAA,EACD;AAAA,EAEA,gBAAgB,cAA6E;AAC5F,SAAK,SAAS,gBAAgB,aAAa,IAAI;AAAA,EAChD;AAAA,EAEA,cAAe,SAAY,gBAAsC;AAChE,QAAI,KAAK,SAAS,eAAe;AAChC,aAAO,KAAK,SAAS,cAAc,SAAS,cAAc;AAAA,IAC3D;AACA,WAAO;AAAA,EACR;AACD;AAlDa;AAAA,EADX;AAAA,GALI,qBAMO;AAoDb,MAAM,iCAAkG;AAAA,EAIvG,YAA6B,eAAkE;AAAlE;AAAA,EAAoE;AAAA,EApKlG,OAgKwG;AAAA;AAAA;AAAA,EAEtF,wBAAwB,oBAAI,IAA+E;AAAA,EAI5H,kBAAkB,MAA6F;AAC9G,WAAO,KAAK,sBAAsB,IAAI,IAAI;AAAA,EAC3C;AAAA,EAEA,2BAA2B,aAAiD,0BAAkC,iBAA6D;AAC1K,SAAK,sBAAsB,MAAM;AACjC,QAAI,YAAY,WAAW,GAAG;AAC7B,aAAO,CAAC;AAAA,IACT;AAEA,aAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK;AAC5C,YAAM,aAAa,YAAY,CAAC;AAChC,YAAM,mBAAmB,WAAW,WAAW,WAAW;AAC1D,YAAM,4BAA4B,IAAI,IAAI,YAAY,UAAU,mBAAmB,YAAY,IAAI,CAAC,EAAE,SAAS;AAE/G,UAAI,6BAA6B,KAAK,2BAA2B,KAAK,2BAA2B,YAAY,QAAQ;AACpH,cAAM,0BAA0B,YAAY,MAAM,GAAG,CAAC;AACtD,cAAM,yBAAyB,YAAY,MAAM,CAAC;AAClD,cAAM,uBAAuB,KAAK,oBAAoB,sBAAsB;AAC5E,eAAO,CAAC,GAAG,yBAAyB,oBAAoB;AAAA,MACzD;AAAA,IAED;AAEA,WAAO;AAAA,EACR;AAAA,EAEQ,oBAAoB,aAAmF;AAE9G,QAAI,YAAY,WAAW,GAAG;AAC7B,YAAM,IAAI,MAAM,mCAAoC;AAAA,IACrD;AACA,UAAM,mBAAmB,KAAK,cAAc;AAC5C,QAAI,CAAC,iBAAiB,qBAAqB,GAAG;AAC7C,aAAO,YAAY,CAAC;AAAA,IACrB;AAGA,UAAM,WAAgB,CAAC;AACvB,aAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK;AAC5C,YAAM,aAAa,YAAY,CAAC;AAChC,YAAMA,kBAAiB,iBAAiB,sBAAsB,WAAW,KAAK,OAAO;AAErF,UAAIA,gBAAe,SAAS;AAE3B,YAAI,MAAM,KAAKA,gBAAe,QAAQ,gBAAgB;AACrD;AAAA,QACD;AACA,iBAAS,KAAK,GAAGA,gBAAe,QAAQ,QAAQ;AAAA,MACjD;AAAA,IACD;AAEA,QAAI,SAAS,SAAS,GAAG;AACxB,aAAO,YAAY,CAAC;AAAA,IACrB;AAGA,UAAM,iBAAiB,YAAY,YAAY,SAAS,CAAC;AACzD,UAAM,oBAA4C,EAAE,UAAU,gBAAgB,MAAM;AACpF,UAAM,iBAAiE,EAAE,GAAG,eAAe,MAAM,UAAU,CAAC,GAAG,SAAS,kBAAkB;AAE1I,UAAM,iBAAiB,IAAI,MAAM,YAAY,CAAC,EAAE,MAAM,CAAC,CAAC;AAExD,UAAM,uBAAyD;AAAA,MAC9D,MAAM;AAAA,MACN,YAAY,YAAY,CAAC,EAAE;AAAA,MAC3B,UAAU,eAAe;AAAA,MACzB,UAAU,YAAY,CAAC,EAAE;AAAA,MACzB,QAAQ,YAAY,CAAC,EAAE;AAAA,IACxB;AAEA,SAAK,sBAAsB,IAAI,gBAAgB,cAAc;AAE7D,WAAO;AAAA,EACR;AACD;AAYA,SAAS,oBAAoC,4BAA+E,SAA0G;AACrO,SAAO,WAAW;AAAA,IACjB,GAAG;AAAA,IACH,iCAAiC,QAAQ,mCAAmC;AAAA,MAC3E,2BAA2B,GAAM;AAChC,YAAI;AAEJ,YAAI;AACH,+BAAqB,2BAA2B,EAAE,sBAAsB,CAAC;AAAA,QAC1E,QAAQ;AACP,iBAAO,QAAQ,gCAAiC,2BAA2B,CAAC;AAAA,QAC7E;AAEA,YAAI,mBAAmB,QAAQ,SAAS,WAAW,GAAG;AACrD,iBAAO,QAAQ,gCAAiC,2BAA2B,CAAC;AAAA,QAC7E,OAAO;AACN,iBAAO,QAAQ,gCAAiC,yCAAyC,mBAAmB,QAAQ,QAAQ;AAAA,QAC7H;AAAA,MACD;AAAA,IACD;AAAA,EACD;AACD;AArBS;AA2BF,MAAM,+BAA+E,WAAkF;AAAA,EAxR9K,OAwR8K;AAAA;AAAA;AAAA,EAI7K,YACC,MACA,WACA,UACA,WACA,UAA0D,CAAC,GAC1D;AACD,UAAM,6BAA6B,6BAAM,MAAN;AACnC,UAAM,uBAAuB,IAAI,iCAAiD,MAAM,KAAK,KAAK;AAClG,UAAM,wBAAwB,UAAU,IAAI,OAAK,IAAI,qBAA0C,4BAA4B,sBAAsB,CAAC,CAAC;AAEnJ,UAAM,MAAM,WAAW,UAAU,uBAAuB,EAAE,GAAG,oBAAoC,4BAA4B,OAAO,GAAG,qBAAqB,CAAC;AAAA,EAC9J;AAAA,EAES,YAAY,SAAmB,WAAgD,SAAS,MAAM,GAAG,SAAkD;AAC3J,SAAK,MAAM,YAAY,SAAS,UAAU,OAAO;AAAA,EAClD;AAAA,EAEmB,YAAY,MAAc,SAAsG;AAClJ,WAAO,IAAI,4BAA4B,MAAM,OAAO;AAAA,EACrD;AAAA,EAES,cAAc,gBAAsD,CAAC,GAAS;AACtF,UAAM,cAAc,aAAa;AAEjC,QAAI,OAAO,cAAc,uBAAuB,aAAa;AAC5D,WAAK,MAAM,sBAAsB,cAAc,kBAAkB;AAAA,IAClE;AAAA,EACD;AAAA,EAEA,sBAAsB,UAAoB,MAA6D;AACtG,WAAO,KAAK,MAAM,sBAAsB,OAAO;AAAA,EAChD;AACD;",
  "names": ["compressedNode"]
}
