{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/browser/ui/tree/objectTree.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { memoize } from \"../../../common/decorators.js\";\nimport type { Event } from \"../../../common/event.js\";\nimport { Iterable } from \"../../../common/iterator.js\";\nimport type {\n\tIIdentityProvider,\n\tIKeyboardNavigationLabelProvider,\n\tIListVirtualDelegate,\n} from \"../list/list.js\";\nimport {\n\tAbstractTree,\n\ttype IAbstractTreeOptions,\n\ttype IAbstractTreeOptionsUpdate,\n\ttype IStickyScrollDelegate,\n\ttype StickyScrollNode,\n} from \"./abstractTree.js\";\nimport {\n\tCompressibleObjectTreeModel,\n\ttype ElementMapper,\n\ttype ICompressedTreeElement,\n\ttype ICompressedTreeNode,\n} from \"./compressedObjectTreeModel.js\";\nimport { type IObjectTreeModel, ObjectTreeModel } from \"./objectTreeModel.js\";\nimport type {\n\tICollapseStateChangeEvent,\n\tIObjectTreeElement,\n\tITreeModel,\n\tITreeNode,\n\tITreeRenderer,\n\tITreeSorter,\n} from \"./tree.js\";\n\nexport interface IObjectTreeOptions<T, TFilterData = void>\n\textends IAbstractTreeOptions<T, TFilterData> {\n\treadonly sorter?: ITreeSorter<T>;\n}\n\nexport interface IObjectTreeSetChildrenOptions<T> {\n\t/**\n\t * If set, child updates will recurse the given number of levels even if\n\t * items in the splice operation are unchanged. `Infinity` is a valid value.\n\t */\n\treadonly diffDepth?: number;\n\n\t/**\n\t * Identity provider used to optimize splice() calls in the IndexTree. If\n\t * this is not present, optimized splicing is not enabled.\n\t *\n\t * Warning: if this is present, calls to `setChildren()` will not replace\n\t * or update nodes if their identity is the same, even if the elements are\n\t * different. For this, you should call `rerender()`.\n\t */\n\treadonly diffIdentityProvider?: IIdentityProvider<T>;\n}\n\nexport class ObjectTree<\n\tT extends NonNullable<any>,\n\tTFilterData = void,\n> extends AbstractTree<T | null, TFilterData, T | null> {\n\tprotected declare model: IObjectTreeModel<T, TFilterData>;\n\n\toverride get onDidChangeCollapseState(): Event<\n\t\tICollapseStateChangeEvent<T | null, TFilterData>\n\t> {\n\t\treturn this.model.onDidChangeCollapseState;\n\t}\n\n\tconstructor(\n\t\tprotected readonly user: string,\n\t\tcontainer: HTMLElement,\n\t\tdelegate: IListVirtualDelegate<T>,\n\t\trenderers: ITreeRenderer<T, TFilterData, any>[],\n\t\toptions: IObjectTreeOptions<T, TFilterData> = {},\n\t) {\n\t\tsuper(\n\t\t\tuser,\n\t\t\tcontainer,\n\t\t\tdelegate,\n\t\t\trenderers,\n\t\t\toptions as IObjectTreeOptions<T | null, TFilterData>,\n\t\t);\n\t}\n\n\tsetChildren(\n\t\telement: T | null,\n\t\tchildren: Iterable<IObjectTreeElement<T>> = Iterable.empty(),\n\t\toptions?: IObjectTreeSetChildrenOptions<T>,\n\t): void {\n\t\tthis.model.setChildren(element, children, options);\n\t}\n\n\trerender(element?: T): void {\n\t\tif (element === undefined) {\n\t\t\tthis.view.rerender();\n\t\t\treturn;\n\t\t}\n\n\t\tthis.model.rerender(element);\n\t}\n\n\tupdateElementHeight(element: T, height: number | undefined): void {\n\t\tconst elementIndex = this.model.getListIndex(element);\n\t\tif (elementIndex === -1) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.view.updateElementHeight(elementIndex, height);\n\t}\n\n\tresort(element: T | null, recursive = true): void {\n\t\tthis.model.resort(element, recursive);\n\t}\n\n\thasElement(element: T): boolean {\n\t\treturn this.model.has(element);\n\t}\n\n\tprotected createModel(\n\t\tuser: string,\n\t\toptions: IObjectTreeOptions<T, TFilterData>,\n\t): ITreeModel<T | null, TFilterData, T | null> {\n\t\treturn new ObjectTreeModel(user, options);\n\t}\n}\n\ninterface ICompressedTreeNodeProvider<T, TFilterData> {\n\tgetCompressedTreeNode(\n\t\tlocation: T | null,\n\t): ITreeNode<ICompressedTreeNode<T> | null, TFilterData>;\n}\n\nexport interface ICompressibleTreeRenderer<\n\tT,\n\tTFilterData = void,\n\tTTemplateData = void,\n> extends ITreeRenderer<T, TFilterData, TTemplateData> {\n\trenderCompressedElements(\n\t\tnode: ITreeNode<ICompressedTreeNode<T>, TFilterData>,\n\t\tindex: number,\n\t\ttemplateData: TTemplateData,\n\t\theight: number | undefined,\n\t): void;\n\tdisposeCompressedElements?(\n\t\tnode: ITreeNode<ICompressedTreeNode<T>, TFilterData>,\n\t\tindex: number,\n\t\ttemplateData: TTemplateData,\n\t\theight: number | undefined,\n\t): void;\n}\n\ninterface CompressibleTemplateData<T, TFilterData, TTemplateData> {\n\tcompressedTreeNode:\n\t\t| ITreeNode<ICompressedTreeNode<T>, TFilterData>\n\t\t| undefined;\n\treadonly data: TTemplateData;\n}\n\nclass CompressibleRenderer<\n\tT extends NonNullable<any>,\n\tTFilterData,\n\tTTemplateData,\n> implements\n\t\tITreeRenderer<\n\t\t\tT,\n\t\t\tTFilterData,\n\t\t\tCompressibleTemplateData<T, TFilterData, TTemplateData>\n\t\t>\n{\n\treadonly templateId: string;\n\treadonly onDidChangeTwistieState: Event<T> | undefined;\n\n\t@memoize\n\tprivate get compressedTreeNodeProvider(): ICompressedTreeNodeProvider<\n\t\tT,\n\t\tTFilterData\n\t> {\n\t\treturn this._compressedTreeNodeProvider();\n\t}\n\n\tconstructor(\n\t\tprivate _compressedTreeNodeProvider: () => ICompressedTreeNodeProvider<\n\t\t\tT,\n\t\t\tTFilterData\n\t\t>,\n\t\tprivate stickyScrollDelegate: CompressibleStickyScrollDelegate<\n\t\t\tT,\n\t\t\tTFilterData\n\t\t>,\n\t\tprivate renderer: ICompressibleTreeRenderer<\n\t\t\tT,\n\t\t\tTFilterData,\n\t\t\tTTemplateData\n\t\t>,\n\t) {\n\t\tthis.templateId = renderer.templateId;\n\n\t\tif (renderer.onDidChangeTwistieState) {\n\t\t\tthis.onDidChangeTwistieState = renderer.onDidChangeTwistieState;\n\t\t}\n\t}\n\n\trenderTemplate(\n\t\tcontainer: HTMLElement,\n\t): CompressibleTemplateData<T, TFilterData, TTemplateData> {\n\t\tconst data = this.renderer.renderTemplate(container);\n\t\treturn { compressedTreeNode: undefined, data };\n\t}\n\n\trenderElement(\n\t\tnode: ITreeNode<T, TFilterData>,\n\t\tindex: number,\n\t\ttemplateData: CompressibleTemplateData<T, TFilterData, TTemplateData>,\n\t\theight: number | undefined,\n\t): void {\n\t\tlet compressedTreeNode =\n\t\t\tthis.stickyScrollDelegate.getCompressedNode(node);\n\t\tif (!compressedTreeNode) {\n\t\t\tcompressedTreeNode =\n\t\t\t\tthis.compressedTreeNodeProvider.getCompressedTreeNode(\n\t\t\t\t\tnode.element,\n\t\t\t\t) as ITreeNode<ICompressedTreeNode<T>, TFilterData>;\n\t\t}\n\n\t\tif (compressedTreeNode.element.elements.length === 1) {\n\t\t\ttemplateData.compressedTreeNode = undefined;\n\t\t\tthis.renderer.renderElement(node, index, templateData.data, height);\n\t\t} else {\n\t\t\ttemplateData.compressedTreeNode = compressedTreeNode;\n\t\t\tthis.renderer.renderCompressedElements(\n\t\t\t\tcompressedTreeNode,\n\t\t\t\tindex,\n\t\t\t\ttemplateData.data,\n\t\t\t\theight,\n\t\t\t);\n\t\t}\n\t}\n\n\tdisposeElement(\n\t\tnode: ITreeNode<T, TFilterData>,\n\t\tindex: number,\n\t\ttemplateData: CompressibleTemplateData<T, TFilterData, TTemplateData>,\n\t\theight: number | undefined,\n\t): void {\n\t\tif (templateData.compressedTreeNode) {\n\t\t\tthis.renderer.disposeCompressedElements?.(\n\t\t\t\ttemplateData.compressedTreeNode,\n\t\t\t\tindex,\n\t\t\t\ttemplateData.data,\n\t\t\t\theight,\n\t\t\t);\n\t\t} else {\n\t\t\tthis.renderer.disposeElement?.(\n\t\t\t\tnode,\n\t\t\t\tindex,\n\t\t\t\ttemplateData.data,\n\t\t\t\theight,\n\t\t\t);\n\t\t}\n\t}\n\n\tdisposeTemplate(\n\t\ttemplateData: CompressibleTemplateData<T, TFilterData, TTemplateData>,\n\t): void {\n\t\tthis.renderer.disposeTemplate(templateData.data);\n\t}\n\n\trenderTwistie?(element: T, twistieElement: HTMLElement): boolean {\n\t\tif (this.renderer.renderTwistie) {\n\t\t\treturn this.renderer.renderTwistie(element, twistieElement);\n\t\t}\n\t\treturn false;\n\t}\n}\n\nclass CompressibleStickyScrollDelegate<T, TFilterData>\n\timplements IStickyScrollDelegate<T, TFilterData>\n{\n\tprivate readonly compressedStickyNodes = new Map<\n\t\tITreeNode<T, TFilterData>,\n\t\tITreeNode<ICompressedTreeNode<T>, TFilterData>\n\t>();\n\n\tconstructor(\n\t\tprivate readonly modelProvider: () => CompressibleObjectTreeModel<\n\t\t\tT,\n\t\t\tTFilterData\n\t\t>,\n\t) {}\n\n\tgetCompressedNode(\n\t\tnode: ITreeNode<T, TFilterData>,\n\t): ITreeNode<ICompressedTreeNode<T>, TFilterData> | undefined {\n\t\treturn this.compressedStickyNodes.get(node);\n\t}\n\n\tconstrainStickyScrollNodes(\n\t\tstickyNodes: StickyScrollNode<T, TFilterData>[],\n\t\tstickyScrollMaxItemCount: number,\n\t\tmaxWidgetHeight: number,\n\t): StickyScrollNode<T, TFilterData>[] {\n\t\tthis.compressedStickyNodes.clear();\n\t\tif (stickyNodes.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\tfor (let i = 0; i < stickyNodes.length; i++) {\n\t\t\tconst stickyNode = stickyNodes[i];\n\t\t\tconst stickyNodeBottom = stickyNode.position + stickyNode.height;\n\t\t\tconst followingReachesMaxHeight =\n\t\t\t\ti + 1 < stickyNodes.length &&\n\t\t\t\tstickyNodeBottom + stickyNodes[i + 1].height > maxWidgetHeight;\n\n\t\t\tif (\n\t\t\t\tfollowingReachesMaxHeight ||\n\t\t\t\t(i >= stickyScrollMaxItemCount - 1 &&\n\t\t\t\t\tstickyScrollMaxItemCount < stickyNodes.length)\n\t\t\t) {\n\t\t\t\tconst uncompressedStickyNodes = stickyNodes.slice(0, i);\n\t\t\t\tconst overflowingStickyNodes = stickyNodes.slice(i);\n\t\t\t\tconst compressedStickyNode = this.compressStickyNodes(\n\t\t\t\t\toverflowingStickyNodes,\n\t\t\t\t);\n\t\t\t\treturn [...uncompressedStickyNodes, compressedStickyNode];\n\t\t\t}\n\t\t}\n\n\t\treturn stickyNodes;\n\t}\n\n\tprivate compressStickyNodes(\n\t\tstickyNodes: StickyScrollNode<T, TFilterData>[],\n\t): StickyScrollNode<T, TFilterData> {\n\t\tif (stickyNodes.length === 0) {\n\t\t\tthrow new Error(\"Can't compress empty sticky nodes\");\n\t\t}\n\t\tconst compressionModel = this.modelProvider();\n\t\tif (!compressionModel.isCompressionEnabled()) {\n\t\t\treturn stickyNodes[0];\n\t\t}\n\n\t\t// Collect all elements to be compressed\n\t\tconst elements: T[] = [];\n\t\tfor (let i = 0; i < stickyNodes.length; i++) {\n\t\t\tconst stickyNode = stickyNodes[i];\n\t\t\tconst compressedNode = compressionModel.getCompressedTreeNode(\n\t\t\t\tstickyNode.node.element,\n\t\t\t);\n\n\t\t\tif (compressedNode.element) {\n\t\t\t\t// if an element is incompressible, it can't be compressed with it's parent element\n\t\t\t\tif (i !== 0 && compressedNode.element.incompressible) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telements.push(...compressedNode.element.elements);\n\t\t\t}\n\t\t}\n\n\t\tif (elements.length < 2) {\n\t\t\treturn stickyNodes[0];\n\t\t}\n\n\t\t// Compress the elements\n\t\tconst lastStickyNode = stickyNodes[stickyNodes.length - 1];\n\t\tconst compressedElement: ICompressedTreeNode<T> = {\n\t\t\telements,\n\t\t\tincompressible: false,\n\t\t};\n\t\tconst compressedNode: ITreeNode<ICompressedTreeNode<T>, TFilterData> = {\n\t\t\t...lastStickyNode.node,\n\t\t\tchildren: [],\n\t\t\telement: compressedElement,\n\t\t};\n\n\t\tconst stickyTreeNode = new Proxy(stickyNodes[0].node, {});\n\n\t\tconst compressedStickyNode: StickyScrollNode<T, TFilterData> = {\n\t\t\tnode: stickyTreeNode,\n\t\t\tstartIndex: stickyNodes[0].startIndex,\n\t\t\tendIndex: lastStickyNode.endIndex,\n\t\t\tposition: stickyNodes[0].position,\n\t\t\theight: stickyNodes[0].height,\n\t\t};\n\n\t\tthis.compressedStickyNodes.set(stickyTreeNode, compressedNode);\n\n\t\treturn compressedStickyNode;\n\t}\n}\n\nexport interface ICompressibleKeyboardNavigationLabelProvider<T>\n\textends IKeyboardNavigationLabelProvider<T> {\n\tgetCompressedNodeKeyboardNavigationLabel(\n\t\telements: T[],\n\t): { toString(): string | undefined } | undefined;\n}\n\nexport interface ICompressibleObjectTreeOptions<T, TFilterData = void>\n\textends IObjectTreeOptions<T, TFilterData> {\n\treadonly compressionEnabled?: boolean;\n\treadonly elementMapper?: ElementMapper<T>;\n\treadonly keyboardNavigationLabelProvider?: ICompressibleKeyboardNavigationLabelProvider<T>;\n}\n\nfunction asObjectTreeOptions<T, TFilterData>(\n\tcompressedTreeNodeProvider: () => ICompressedTreeNodeProvider<\n\t\tT,\n\t\tTFilterData\n\t>,\n\toptions?: ICompressibleObjectTreeOptions<T, TFilterData>,\n): IObjectTreeOptions<T, TFilterData> | undefined {\n\treturn (\n\t\toptions && {\n\t\t\t...options,\n\t\t\tkeyboardNavigationLabelProvider:\n\t\t\t\toptions.keyboardNavigationLabelProvider && {\n\t\t\t\t\tgetKeyboardNavigationLabel(e: T) {\n\t\t\t\t\t\tlet compressedTreeNode: ITreeNode<\n\t\t\t\t\t\t\tICompressedTreeNode<T>,\n\t\t\t\t\t\t\tTFilterData\n\t\t\t\t\t\t>;\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tcompressedTreeNode =\n\t\t\t\t\t\t\t\tcompressedTreeNodeProvider().getCompressedTreeNode(\n\t\t\t\t\t\t\t\t\te,\n\t\t\t\t\t\t\t\t) as ITreeNode<\n\t\t\t\t\t\t\t\t\tICompressedTreeNode<T>,\n\t\t\t\t\t\t\t\t\tTFilterData\n\t\t\t\t\t\t\t\t>;\n\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\treturn options.keyboardNavigationLabelProvider!.getKeyboardNavigationLabel(\n\t\t\t\t\t\t\t\te,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (compressedTreeNode.element.elements.length === 1) {\n\t\t\t\t\t\t\treturn options.keyboardNavigationLabelProvider!.getKeyboardNavigationLabel(\n\t\t\t\t\t\t\t\te,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn options.keyboardNavigationLabelProvider!.getCompressedNodeKeyboardNavigationLabel(\n\t\t\t\t\t\t\t\tcompressedTreeNode.element.elements,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t}\n\t);\n}\n\nexport interface ICompressibleObjectTreeOptionsUpdate\n\textends IAbstractTreeOptionsUpdate {\n\treadonly compressionEnabled?: boolean;\n}\n\nexport class CompressibleObjectTree<\n\t\tT extends NonNullable<any>,\n\t\tTFilterData = void,\n\t>\n\textends ObjectTree<T, TFilterData>\n\timplements ICompressedTreeNodeProvider<T, TFilterData>\n{\n\tprotected declare model: CompressibleObjectTreeModel<T, TFilterData>;\n\n\tconstructor(\n\t\tuser: string,\n\t\tcontainer: HTMLElement,\n\t\tdelegate: IListVirtualDelegate<T>,\n\t\trenderers: ICompressibleTreeRenderer<T, TFilterData, any>[],\n\t\toptions: ICompressibleObjectTreeOptions<T, TFilterData> = {},\n\t) {\n\t\tconst compressedTreeNodeProvider = () => this;\n\t\tconst stickyScrollDelegate = new CompressibleStickyScrollDelegate<\n\t\t\tT,\n\t\t\tTFilterData\n\t\t>(() => this.model);\n\t\tconst compressibleRenderers = renderers.map(\n\t\t\t(r) =>\n\t\t\t\tnew CompressibleRenderer<T, TFilterData, any>(\n\t\t\t\t\tcompressedTreeNodeProvider,\n\t\t\t\t\tstickyScrollDelegate,\n\t\t\t\t\tr,\n\t\t\t\t),\n\t\t);\n\n\t\tsuper(user, container, delegate, compressibleRenderers, {\n\t\t\t...asObjectTreeOptions<T, TFilterData>(\n\t\t\t\tcompressedTreeNodeProvider,\n\t\t\t\toptions,\n\t\t\t),\n\t\t\tstickyScrollDelegate,\n\t\t});\n\t}\n\n\toverride setChildren(\n\t\telement: T | null,\n\t\tchildren: Iterable<ICompressedTreeElement<T>> = Iterable.empty(),\n\t\toptions?: IObjectTreeSetChildrenOptions<T>,\n\t): void {\n\t\tthis.model.setChildren(element, children, options);\n\t}\n\n\tprotected override createModel(\n\t\tuser: string,\n\t\toptions: ICompressibleObjectTreeOptions<T, TFilterData>,\n\t): ITreeModel<T | null, TFilterData, T | null> {\n\t\treturn new CompressibleObjectTreeModel(user, options);\n\t}\n\n\toverride updateOptions(\n\t\toptionsUpdate: ICompressibleObjectTreeOptionsUpdate = {},\n\t): void {\n\t\tsuper.updateOptions(optionsUpdate);\n\n\t\tif (typeof optionsUpdate.compressionEnabled !== \"undefined\") {\n\t\t\tthis.model.setCompressionEnabled(optionsUpdate.compressionEnabled);\n\t\t}\n\t}\n\n\tgetCompressedTreeNode(\n\t\telement: T | null = null,\n\t): ITreeNode<ICompressedTreeNode<T> | null, TFilterData> {\n\t\treturn this.model.getCompressedTreeNode(element);\n\t}\n}\n"],
  "mappings": "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",
  "names": ["compressedNode"]
}
