{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/browser/ui/tree/objectTreeModel.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { Event } from \"../../../common/event.js\";\nimport { Iterable } from \"../../../common/iterator.js\";\nimport type { IIdentityProvider } from \"../list/list.js\";\nimport {\n\ttype IIndexTreeModelOptions,\n\ttype IIndexTreeModelSpliceOptions,\n\tIndexTreeModel,\n} from \"./indexTreeModel.js\";\nimport {\n\ttype ICollapseStateChangeEvent,\n\ttype IObjectTreeElement,\n\ttype ITreeElement,\n\ttype ITreeListSpliceData,\n\ttype ITreeModel,\n\ttype ITreeModelSpliceEvent,\n\ttype ITreeNode,\n\ttype ITreeSorter,\n\tObjectTreeElementCollapseState,\n\tTreeError,\n} from \"./tree.js\";\n\nexport type ITreeNodeCallback<T, TFilterData> = (\n\tnode: ITreeNode<T, TFilterData>,\n) => void;\n\nexport interface IObjectTreeModel<\n\tT extends NonNullable<any>,\n\tTFilterData extends NonNullable<any> = void,\n> extends ITreeModel<T | null, TFilterData, T | null> {\n\tsetChildren(\n\t\telement: T | null,\n\t\tchildren: Iterable<IObjectTreeElement<T>> | undefined,\n\t\toptions?: IObjectTreeModelSetChildrenOptions<T, TFilterData>,\n\t): void;\n\tresort(element?: T | null, recursive?: boolean): void;\n}\n\nexport interface IObjectTreeModelSetChildrenOptions<T, TFilterData>\n\textends IIndexTreeModelSpliceOptions<T, TFilterData> {}\n\nexport interface IObjectTreeModelOptions<T, TFilterData>\n\textends IIndexTreeModelOptions<T, TFilterData> {\n\treadonly sorter?: ITreeSorter<T>;\n\treadonly identityProvider?: IIdentityProvider<T>;\n}\n\nexport class ObjectTreeModel<\n\tT extends NonNullable<any>,\n\tTFilterData extends NonNullable<any> = void,\n> implements IObjectTreeModel<T, TFilterData>\n{\n\treadonly rootRef = null;\n\n\tprivate model: IndexTreeModel<T | null, TFilterData>;\n\tprivate nodes = new Map<T | null, ITreeNode<T, TFilterData>>();\n\tprivate readonly nodesByIdentity = new Map<\n\t\tstring,\n\t\tITreeNode<T, TFilterData>\n\t>();\n\tprivate readonly identityProvider?: IIdentityProvider<T>;\n\tprivate sorter?: ITreeSorter<{ element: T }>;\n\n\treadonly onDidSpliceModel: Event<\n\t\tITreeModelSpliceEvent<T | null, TFilterData>\n\t>;\n\treadonly onDidSpliceRenderedNodes: Event<\n\t\tITreeListSpliceData<T | null, TFilterData>\n\t>;\n\treadonly onDidChangeCollapseState: Event<\n\t\tICollapseStateChangeEvent<T, TFilterData>\n\t>;\n\treadonly onDidChangeRenderNodeCount: Event<ITreeNode<T, TFilterData>>;\n\n\tget size(): number {\n\t\treturn this.nodes.size;\n\t}\n\n\tconstructor(\n\t\tprivate user: string,\n\t\toptions: IObjectTreeModelOptions<T, TFilterData> = {},\n\t) {\n\t\tthis.model = new IndexTreeModel(user, null, options);\n\t\tthis.onDidSpliceModel = this.model.onDidSpliceModel;\n\t\tthis.onDidSpliceRenderedNodes = this.model.onDidSpliceRenderedNodes;\n\t\tthis.onDidChangeCollapseState = this.model\n\t\t\t.onDidChangeCollapseState as Event<\n\t\t\tICollapseStateChangeEvent<T, TFilterData>\n\t\t>;\n\t\tthis.onDidChangeRenderNodeCount = this.model\n\t\t\t.onDidChangeRenderNodeCount as Event<ITreeNode<T, TFilterData>>;\n\n\t\tif (options.sorter) {\n\t\t\tthis.sorter = {\n\t\t\t\tcompare(a, b) {\n\t\t\t\t\treturn options.sorter!.compare(a.element, b.element);\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\tthis.identityProvider = options.identityProvider;\n\t}\n\n\tsetChildren(\n\t\telement: T | null,\n\t\tchildren: Iterable<IObjectTreeElement<T>> = Iterable.empty(),\n\t\toptions: IObjectTreeModelSetChildrenOptions<T, TFilterData> = {},\n\t): void {\n\t\tconst location = this.getElementLocation(element);\n\t\tthis._setChildren(\n\t\t\tlocation,\n\t\t\tthis.preserveCollapseState(children),\n\t\t\toptions,\n\t\t);\n\t}\n\n\tprivate _setChildren(\n\t\tlocation: number[],\n\t\tchildren: Iterable<ITreeElement<T>> = Iterable.empty(),\n\t\toptions: IObjectTreeModelSetChildrenOptions<T, TFilterData>,\n\t): void {\n\t\tconst insertedElements = new Set<T | null>();\n\t\tconst insertedElementIds = new Set<string>();\n\n\t\tconst onDidCreateNode = (node: ITreeNode<T | null, TFilterData>) => {\n\t\t\tif (node.element === null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst tnode = node as ITreeNode<T, TFilterData>;\n\n\t\t\tinsertedElements.add(tnode.element);\n\t\t\tthis.nodes.set(tnode.element, tnode);\n\n\t\t\tif (this.identityProvider) {\n\t\t\t\tconst id = this.identityProvider\n\t\t\t\t\t.getId(tnode.element)\n\t\t\t\t\t.toString();\n\t\t\t\tinsertedElementIds.add(id);\n\t\t\t\tthis.nodesByIdentity.set(id, tnode);\n\t\t\t}\n\n\t\t\toptions.onDidCreateNode?.(tnode);\n\t\t};\n\n\t\tconst onDidDeleteNode = (node: ITreeNode<T | null, TFilterData>) => {\n\t\t\tif (node.element === null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst tnode = node as ITreeNode<T, TFilterData>;\n\n\t\t\tif (!insertedElements.has(tnode.element)) {\n\t\t\t\tthis.nodes.delete(tnode.element);\n\t\t\t}\n\n\t\t\tif (this.identityProvider) {\n\t\t\t\tconst id = this.identityProvider\n\t\t\t\t\t.getId(tnode.element)\n\t\t\t\t\t.toString();\n\t\t\t\tif (!insertedElementIds.has(id)) {\n\t\t\t\t\tthis.nodesByIdentity.delete(id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toptions.onDidDeleteNode?.(tnode);\n\t\t};\n\n\t\tthis.model.splice([...location, 0], Number.MAX_VALUE, children, {\n\t\t\t...options,\n\t\t\tonDidCreateNode,\n\t\t\tonDidDeleteNode,\n\t\t});\n\t}\n\n\tprivate preserveCollapseState(\n\t\telements: Iterable<IObjectTreeElement<T>> = Iterable.empty(),\n\t): Iterable<ITreeElement<T>> {\n\t\tif (this.sorter) {\n\t\t\telements = [...elements].sort(\n\t\t\t\tthis.sorter.compare.bind(this.sorter),\n\t\t\t);\n\t\t}\n\n\t\treturn Iterable.map(elements, (treeElement) => {\n\t\t\tlet node = this.nodes.get(treeElement.element);\n\n\t\t\tif (!node && this.identityProvider) {\n\t\t\t\tconst id = this.identityProvider\n\t\t\t\t\t.getId(treeElement.element)\n\t\t\t\t\t.toString();\n\t\t\t\tnode = this.nodesByIdentity.get(id);\n\t\t\t}\n\n\t\t\tif (!node) {\n\t\t\t\tlet collapsed: boolean | undefined;\n\n\t\t\t\tif (typeof treeElement.collapsed === \"undefined\") {\n\t\t\t\t\tcollapsed = undefined;\n\t\t\t\t} else if (\n\t\t\t\t\ttreeElement.collapsed ===\n\t\t\t\t\t\tObjectTreeElementCollapseState.Collapsed ||\n\t\t\t\t\ttreeElement.collapsed ===\n\t\t\t\t\t\tObjectTreeElementCollapseState.PreserveOrCollapsed\n\t\t\t\t) {\n\t\t\t\t\tcollapsed = true;\n\t\t\t\t} else if (\n\t\t\t\t\ttreeElement.collapsed ===\n\t\t\t\t\t\tObjectTreeElementCollapseState.Expanded ||\n\t\t\t\t\ttreeElement.collapsed ===\n\t\t\t\t\t\tObjectTreeElementCollapseState.PreserveOrExpanded\n\t\t\t\t) {\n\t\t\t\t\tcollapsed = false;\n\t\t\t\t} else {\n\t\t\t\t\tcollapsed = Boolean(treeElement.collapsed);\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\t...treeElement,\n\t\t\t\t\tchildren: this.preserveCollapseState(treeElement.children),\n\t\t\t\t\tcollapsed,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst collapsible =\n\t\t\t\ttypeof treeElement.collapsible === \"boolean\"\n\t\t\t\t\t? treeElement.collapsible\n\t\t\t\t\t: node.collapsible;\n\t\t\tlet collapsed: boolean | undefined;\n\n\t\t\tif (\n\t\t\t\ttypeof treeElement.collapsed === \"undefined\" ||\n\t\t\t\ttreeElement.collapsed ===\n\t\t\t\t\tObjectTreeElementCollapseState.PreserveOrCollapsed ||\n\t\t\t\ttreeElement.collapsed ===\n\t\t\t\t\tObjectTreeElementCollapseState.PreserveOrExpanded\n\t\t\t) {\n\t\t\t\tcollapsed = node.collapsed;\n\t\t\t} else if (\n\t\t\t\ttreeElement.collapsed ===\n\t\t\t\tObjectTreeElementCollapseState.Collapsed\n\t\t\t) {\n\t\t\t\tcollapsed = true;\n\t\t\t} else if (\n\t\t\t\ttreeElement.collapsed ===\n\t\t\t\tObjectTreeElementCollapseState.Expanded\n\t\t\t) {\n\t\t\t\tcollapsed = false;\n\t\t\t} else {\n\t\t\t\tcollapsed = Boolean(treeElement.collapsed);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\t...treeElement,\n\t\t\t\tcollapsible,\n\t\t\t\tcollapsed,\n\t\t\t\tchildren: this.preserveCollapseState(treeElement.children),\n\t\t\t};\n\t\t});\n\t}\n\n\trerender(element: T | null): void {\n\t\tconst location = this.getElementLocation(element);\n\t\tthis.model.rerender(location);\n\t}\n\n\tresort(element: T | null = null, recursive = true): void {\n\t\tif (!this.sorter) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst location = this.getElementLocation(element);\n\t\tconst node = this.model.getNode(location);\n\n\t\tthis._setChildren(location, this.resortChildren(node, recursive), {});\n\t}\n\n\tprivate resortChildren(\n\t\tnode: ITreeNode<T | null, TFilterData>,\n\t\trecursive: boolean,\n\t\tfirst = true,\n\t): Iterable<ITreeElement<T>> {\n\t\tlet childrenNodes = [...node.children] as ITreeNode<T, TFilterData>[];\n\n\t\tif (recursive || first) {\n\t\t\tchildrenNodes = childrenNodes.sort(\n\t\t\t\tthis.sorter!.compare.bind(this.sorter),\n\t\t\t);\n\t\t}\n\n\t\treturn Iterable.map<ITreeNode<T | null, TFilterData>, ITreeElement<T>>(\n\t\t\tchildrenNodes,\n\t\t\t(node) => ({\n\t\t\t\telement: node.element as T,\n\t\t\t\tcollapsible: node.collapsible,\n\t\t\t\tcollapsed: node.collapsed,\n\t\t\t\tchildren: this.resortChildren(node, recursive, false),\n\t\t\t}),\n\t\t);\n\t}\n\n\tgetFirstElementChild(ref: T | null = null): T | null | undefined {\n\t\tconst location = this.getElementLocation(ref);\n\t\treturn this.model.getFirstElementChild(location);\n\t}\n\n\tgetLastElementAncestor(ref: T | null = null): T | null | undefined {\n\t\tconst location = this.getElementLocation(ref);\n\t\treturn this.model.getLastElementAncestor(location);\n\t}\n\n\thas(element: T | null): boolean {\n\t\treturn this.nodes.has(element);\n\t}\n\n\tgetListIndex(element: T | null): number {\n\t\tconst location = this.getElementLocation(element);\n\t\treturn this.model.getListIndex(location);\n\t}\n\n\tgetListRenderCount(element: T | null): number {\n\t\tconst location = this.getElementLocation(element);\n\t\treturn this.model.getListRenderCount(location);\n\t}\n\n\tisCollapsible(element: T | null): boolean {\n\t\tconst location = this.getElementLocation(element);\n\t\treturn this.model.isCollapsible(location);\n\t}\n\n\tsetCollapsible(element: T | null, collapsible?: boolean): boolean {\n\t\tconst location = this.getElementLocation(element);\n\t\treturn this.model.setCollapsible(location, collapsible);\n\t}\n\n\tisCollapsed(element: T | null): boolean {\n\t\tconst location = this.getElementLocation(element);\n\t\treturn this.model.isCollapsed(location);\n\t}\n\n\tsetCollapsed(\n\t\telement: T | null,\n\t\tcollapsed?: boolean,\n\t\trecursive?: boolean,\n\t): boolean {\n\t\tconst location = this.getElementLocation(element);\n\t\treturn this.model.setCollapsed(location, collapsed, recursive);\n\t}\n\n\texpandTo(element: T | null): void {\n\t\tconst location = this.getElementLocation(element);\n\t\tthis.model.expandTo(location);\n\t}\n\n\trefilter(): void {\n\t\tthis.model.refilter();\n\t}\n\n\tgetNode(element: T | null = null): ITreeNode<T | null, TFilterData> {\n\t\tif (element === null) {\n\t\t\treturn this.model.getNode(this.model.rootRef);\n\t\t}\n\n\t\tconst node = this.nodes.get(element);\n\n\t\tif (!node) {\n\t\t\tthrow new TreeError(\n\t\t\t\tthis.user,\n\t\t\t\t`Tree element not found: ${element}`,\n\t\t\t);\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tgetNodeLocation(node: ITreeNode<T, TFilterData>): T | null {\n\t\treturn node.element;\n\t}\n\n\tgetParentNodeLocation(element: T | null): T | null {\n\t\tif (element === null) {\n\t\t\tthrow new TreeError(\n\t\t\t\tthis.user,\n\t\t\t\t`Invalid getParentNodeLocation call`,\n\t\t\t);\n\t\t}\n\n\t\tconst node = this.nodes.get(element);\n\n\t\tif (!node) {\n\t\t\tthrow new TreeError(\n\t\t\t\tthis.user,\n\t\t\t\t`Tree element not found: ${element}`,\n\t\t\t);\n\t\t}\n\n\t\tconst location = this.model.getNodeLocation(node);\n\t\tconst parentLocation = this.model.getParentNodeLocation(location);\n\t\tconst parent = this.model.getNode(parentLocation);\n\n\t\treturn parent.element;\n\t}\n\n\tprivate getElementLocation(element: T | null): number[] {\n\t\tif (element === null) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst node = this.nodes.get(element);\n\n\t\tif (!node) {\n\t\t\tthrow new TreeError(\n\t\t\t\tthis.user,\n\t\t\t\t`Tree element not found: ${element}`,\n\t\t\t);\n\t\t}\n\n\t\treturn this.model.getNodeLocation(node);\n\t}\n}\n"],
  "mappings": "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",
  "names": ["collapsed", "node"]
}
