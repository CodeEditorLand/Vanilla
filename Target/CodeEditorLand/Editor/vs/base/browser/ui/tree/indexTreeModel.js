import{splice as E,tail2 as w}from"../../../common/arrays.js";import{Delayer as L}from"../../../common/async.js";import{LcsDiff as V}from"../../../common/diff/diff.js";import{Emitter as S,EventBufferer as A}from"../../../common/event.js";import{Iterable as D}from"../../../common/iterator.js";import{MicrotaskDelay as M}from"../../../common/symbols.js";import{TreeError as m,TreeVisibility as d}from"./tree.js";function P(c){return typeof c=="object"&&"visibility"in c&&"data"in c}function R(c){switch(c){case!0:return d.Visible;case!1:return d.Hidden;default:return c}}function F(c){return typeof c.collapsible=="boolean"}class q{constructor(e,t,i={}){this.user=e;this.collapseByDefault=typeof i.collapseByDefault>"u"?!1:i.collapseByDefault,this.allowNonCollapsibleParents=i.allowNonCollapsibleParents??!1,this.filter=i.filter,this.autoExpandSingleChildren=typeof i.autoExpandSingleChildren>"u"?!1:i.autoExpandSingleChildren,this.root={parent:void 0,element:t,children:[],depth:0,visibleChildrenCount:0,visibleChildIndex:-1,collapsible:!1,collapsed:!1,renderNodeCount:0,visibility:d.Visible,visible:!0,filterData:void 0}}rootRef=[];root;eventBufferer=new A;_onDidSpliceModel=new S;onDidSpliceModel=this._onDidSpliceModel.event;_onDidSpliceRenderedNodes=new S;onDidSpliceRenderedNodes=this._onDidSpliceRenderedNodes.event;_onDidChangeCollapseState=new S;onDidChangeCollapseState=this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event);_onDidChangeRenderNodeCount=new S;onDidChangeRenderNodeCount=this.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event);collapseByDefault;allowNonCollapsibleParents;filter;autoExpandSingleChildren;refilterDelayer=new L(M);splice(e,t,i=D.empty(),l={}){if(e.length===0)throw new m(this.user,"Invalid tree location");l.diffIdentityProvider?this.spliceSmart(l.diffIdentityProvider,e,t,i,l):this.spliceSimple(e,t,i,l)}spliceSmart(e,t,i,l=D.empty(),n,o=n.diffDepth??0){const{parentNode:r}=this.getParentNodeWithListIndex(t);if(!r.lastDiffIds)return this.spliceSimple(t,i,l,n);const a=[...l],p=t[t.length-1],v=new V({getElements:()=>r.lastDiffIds},{getElements:()=>[...r.children.slice(0,p),...a,...r.children.slice(p+i)].map(h=>e.getId(h.element).toString())}).ComputeDiff(!1);if(v.quitEarly)return r.lastDiffIds=void 0,this.spliceSimple(t,i,a,n);const b=t.slice(0,-1),N=(h,C,g)=>{if(o>0)for(let I=0;I<g;I++)h--,C--,this.spliceSmart(e,[...b,h,0],Number.MAX_SAFE_INTEGER,a[C].children,n,o-1)};let f=Math.min(r.children.length,p+i),u=a.length;for(const h of v.changes.sort((C,g)=>g.originalStart-C.originalStart))N(f,u,f-(h.originalStart+h.originalLength)),f=h.originalStart,u=h.modifiedStart-p,this.spliceSimple([...b,f],h.originalLength,D.slice(a,u,u+h.modifiedLength),n);N(f,u,f)}spliceSimple(e,t,i=D.empty(),{onDidCreateNode:l,onDidDeleteNode:n,diffIdentityProvider:o}){const{parentNode:r,listIndex:a,revealed:p,visible:v}=this.getParentNodeWithListIndex(e),b=[],N=D.map(i,s=>this.createTreeNode(s,r,r.visible?d.Visible:d.Hidden,p,b,l)),f=e[e.length-1];let u=0;for(let s=f;s>=0&&s<r.children.length;s--){const T=r.children[s];if(T.visible){u=T.visibleChildIndex;break}}const h=[];let C=0,g=0;for(const s of N)h.push(s),g+=s.renderNodeCount,s.visible&&(s.visibleChildIndex=u+C++);const I=E(r.children,f,t,h);o?r.lastDiffIds?E(r.lastDiffIds,f,t,h.map(s=>o.getId(s.element).toString())):r.lastDiffIds=r.children.map(s=>o.getId(s.element).toString()):r.lastDiffIds=void 0;let y=0;for(const s of I)s.visible&&y++;if(y!==0)for(let s=f+h.length;s<r.children.length;s++){const T=r.children[s];T.visible&&(T.visibleChildIndex-=y)}if(r.visibleChildrenCount+=C-y,p&&v){const s=I.reduce((T,_)=>T+(_.visible?_.renderNodeCount:0),0);this._updateAncestorsRenderNodeCount(r,g-s),this._onDidSpliceRenderedNodes.fire({start:a,deleteCount:s,elements:b})}if(I.length>0&&n){const s=T=>{n(T),T.children.forEach(s)};I.forEach(s)}this._onDidSpliceModel.fire({insertedNodes:h,deletedNodes:I});let x=r;for(;x;){if(x.visibility===d.Recurse){this.refilterDelayer.trigger(()=>this.refilter());break}x=x.parent}}rerender(e){if(e.length===0)throw new m(this.user,"Invalid tree location");const{node:t,listIndex:i,revealed:l}=this.getTreeNodeWithListIndex(e);t.visible&&l&&this._onDidSpliceRenderedNodes.fire({start:i,deleteCount:1,elements:[t]})}has(e){return this.hasTreeNode(e)}getListIndex(e){const{listIndex:t,visible:i,revealed:l}=this.getTreeNodeWithListIndex(e);return i&&l?t:-1}getListRenderCount(e){return this.getTreeNode(e).renderNodeCount}isCollapsible(e){return this.getTreeNode(e).collapsible}setCollapsible(e,t){const i=this.getTreeNode(e);typeof t>"u"&&(t=!i.collapsible);const l={collapsible:t};return this.eventBufferer.bufferEvents(()=>this._setCollapseState(e,l))}isCollapsed(e){return this.getTreeNode(e).collapsed}setCollapsed(e,t,i){const l=this.getTreeNode(e);typeof t>"u"&&(t=!l.collapsed);const n={collapsed:t,recursive:i||!1};return this.eventBufferer.bufferEvents(()=>this._setCollapseState(e,n))}_setCollapseState(e,t){const{node:i,listIndex:l,revealed:n}=this.getTreeNodeWithListIndex(e),o=this._setListNodeCollapseState(i,l,n,t);if(i!==this.root&&this.autoExpandSingleChildren&&o&&!F(t)&&i.collapsible&&!i.collapsed&&!t.recursive){let r=-1;for(let a=0;a<i.children.length;a++)if(i.children[a].visible)if(r>-1){r=-1;break}else r=a;r>-1&&this._setCollapseState([...e,r],t)}return o}_setListNodeCollapseState(e,t,i,l){const n=this._setNodeCollapseState(e,l,!1);if(!i||!e.visible||!n)return n;const o=e.renderNodeCount,r=this.updateNodeAfterCollapseChange(e),a=o-(t===-1?0:1);return this._onDidSpliceRenderedNodes.fire({start:t+1,deleteCount:a,elements:r.slice(1)}),n}_setNodeCollapseState(e,t,i){let l;if(e===this.root?l=!1:(F(t)?(l=e.collapsible!==t.collapsible,e.collapsible=t.collapsible):e.collapsible?(l=e.collapsed!==t.collapsed,e.collapsed=t.collapsed):l=!1,l&&this._onDidChangeCollapseState.fire({node:e,deep:i})),!F(t)&&t.recursive)for(const n of e.children)l=this._setNodeCollapseState(n,t,!0)||l;return l}expandTo(e){this.eventBufferer.bufferEvents(()=>{let t=this.getTreeNode(e);for(;t.parent;)t=t.parent,e=e.slice(0,e.length-1),t.collapsed&&this._setCollapseState(e,{collapsed:!1,recursive:!1})})}refilter(){const e=this.root.renderNodeCount,t=this.updateNodeAfterFilterChange(this.root);this._onDidSpliceRenderedNodes.fire({start:0,deleteCount:e,elements:t}),this.refilterDelayer.cancel()}createTreeNode(e,t,i,l,n,o){const r={parent:t,element:e.element,children:[],depth:t.depth+1,visibleChildrenCount:0,visibleChildIndex:-1,collapsible:typeof e.collapsible=="boolean"?e.collapsible:typeof e.collapsed<"u",collapsed:typeof e.collapsed>"u"?this.collapseByDefault:e.collapsed,renderNodeCount:1,visibility:d.Visible,visible:!0,filterData:void 0},a=this._filterNode(r,i);r.visibility=a,l&&n.push(r);const p=e.children||D.empty(),v=l&&a!==d.Hidden&&!r.collapsed;let b=0,N=1;for(const f of p){const u=this.createTreeNode(f,r,a,v,n,o);r.children.push(u),N+=u.renderNodeCount,u.visible&&(u.visibleChildIndex=b++)}return this.allowNonCollapsibleParents||(r.collapsible=r.collapsible||r.children.length>0),r.visibleChildrenCount=b,r.visible=a===d.Recurse?b>0:a===d.Visible,r.visible?r.collapsed||(r.renderNodeCount=N):(r.renderNodeCount=0,l&&n.pop()),o?.(r),r}updateNodeAfterCollapseChange(e){const t=e.renderNodeCount,i=[];return this._updateNodeAfterCollapseChange(e,i),this._updateAncestorsRenderNodeCount(e.parent,i.length-t),i}_updateNodeAfterCollapseChange(e,t){if(e.visible===!1)return 0;if(t.push(e),e.renderNodeCount=1,!e.collapsed)for(const i of e.children)e.renderNodeCount+=this._updateNodeAfterCollapseChange(i,t);return this._onDidChangeRenderNodeCount.fire(e),e.renderNodeCount}updateNodeAfterFilterChange(e){const t=e.renderNodeCount,i=[];return this._updateNodeAfterFilterChange(e,e.visible?d.Visible:d.Hidden,i),this._updateAncestorsRenderNodeCount(e.parent,i.length-t),i}_updateNodeAfterFilterChange(e,t,i,l=!0){let n;if(e!==this.root){if(n=this._filterNode(e,t),n===d.Hidden)return e.visible=!1,e.renderNodeCount=0,!1;l&&i.push(e)}const o=i.length;e.renderNodeCount=e===this.root?0:1;let r=!1;if(!e.collapsed||n!==d.Hidden){let a=0;for(const p of e.children)r=this._updateNodeAfterFilterChange(p,n,i,l&&!e.collapsed)||r,p.visible&&(p.visibleChildIndex=a++);e.visibleChildrenCount=a}else e.visibleChildrenCount=0;return e!==this.root&&(e.visible=n===d.Recurse?r:n===d.Visible,e.visibility=n),e.visible?e.collapsed||(e.renderNodeCount+=i.length-o):(e.renderNodeCount=0,l&&i.pop()),this._onDidChangeRenderNodeCount.fire(e),e.visible}_updateAncestorsRenderNodeCount(e,t){if(t!==0)for(;e;)e.renderNodeCount+=t,this._onDidChangeRenderNodeCount.fire(e),e=e.parent}_filterNode(e,t){const i=this.filter?this.filter.filter(e.element,t):d.Visible;return typeof i=="boolean"?(e.filterData=void 0,i?d.Visible:d.Hidden):P(i)?(e.filterData=i.data,R(i.visibility)):(e.filterData=void 0,R(i))}hasTreeNode(e,t=this.root){if(!e||e.length===0)return!0;const[i,...l]=e;return i<0||i>t.children.length?!1:this.hasTreeNode(l,t.children[i])}getTreeNode(e,t=this.root){if(!e||e.length===0)return t;const[i,...l]=e;if(i<0||i>t.children.length)throw new m(this.user,"Invalid tree location");return this.getTreeNode(l,t.children[i])}getTreeNodeWithListIndex(e){if(e.length===0)return{node:this.root,listIndex:-1,revealed:!0,visible:!1};const{parentNode:t,listIndex:i,revealed:l,visible:n}=this.getParentNodeWithListIndex(e),o=e[e.length-1];if(o<0||o>t.children.length)throw new m(this.user,"Invalid tree location");const r=t.children[o];return{node:r,listIndex:i,revealed:l,visible:n&&r.visible}}getParentNodeWithListIndex(e,t=this.root,i=0,l=!0,n=!0){const[o,...r]=e;if(o<0||o>t.children.length)throw new m(this.user,"Invalid tree location");for(let a=0;a<o;a++)i+=t.children[a].renderNodeCount;return l=l&&!t.collapsed,n=n&&t.visible,r.length===0?{parentNode:t,listIndex:i,revealed:l,visible:n}:this.getParentNodeWithListIndex(r,t.children[o],i+1,l,n)}getNode(e=[]){return this.getTreeNode(e)}getNodeLocation(e){const t=[];let i=e;for(;i.parent;)t.push(i.parent.children.indexOf(i)),i=i.parent;return t.reverse()}getParentNodeLocation(e){if(e.length!==0)return e.length===1?[]:w(e)[0]}getFirstElementChild(e){const t=this.getTreeNode(e);if(t.children.length!==0)return t.children[0].element}getLastElementAncestor(e=[]){const t=this.getTreeNode(e);if(t.children.length!==0)return this._getLastElementAncestor(t)}_getLastElementAncestor(e){return e.children.length===0?e.element:this._getLastElementAncestor(e.children[e.children.length-1])}}export{q as IndexTreeModel,R as getVisibleState,P as isFilterResult};
