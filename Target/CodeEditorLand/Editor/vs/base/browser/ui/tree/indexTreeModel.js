import"../../../../../vs/base/browser/ui/list/list.js";import{TreeError as m,TreeVisibility as d}from"../../../../../vs/base/browser/ui/tree/tree.js";import{splice as E,tail2 as L}from"../../../../../vs/base/common/arrays.js";import{Delayer as R}from"../../../../../vs/base/common/async.js";import{LcsDiff as V}from"../../../../../vs/base/common/diff/diff.js";import{Emitter as F,EventBufferer as A}from"../../../../../vs/base/common/event.js";import{Iterable as D}from"../../../../../vs/base/common/iterator.js";import"../../../../../vs/base/common/sequence.js";import{MicrotaskDelay as P}from"../../../../../vs/base/common/symbols.js";function M(c){return typeof c=="object"&&"visibility"in c&&"data"in c}function w(c){switch(c){case!0:return d.Visible;case!1:return d.Hidden;default:return c}}function S(c){return typeof c.collapsible=="boolean"}class ie{constructor(e,t,i,l={}){this.user=e;this.list=t;this.collapseByDefault=typeof l.collapseByDefault>"u"?!1:l.collapseByDefault,this.allowNonCollapsibleParents=l.allowNonCollapsibleParents??!1,this.filter=l.filter,this.autoExpandSingleChildren=typeof l.autoExpandSingleChildren>"u"?!1:l.autoExpandSingleChildren,this.root={parent:void 0,element:i,children:[],depth:0,visibleChildrenCount:0,visibleChildIndex:-1,collapsible:!1,collapsed:!1,renderNodeCount:0,visibility:d.Visible,visible:!0,filterData:void 0}}rootRef=[];root;eventBufferer=new A;_onDidChangeCollapseState=new F;onDidChangeCollapseState=this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event);_onDidChangeRenderNodeCount=new F;onDidChangeRenderNodeCount=this.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event);collapseByDefault;allowNonCollapsibleParents;filter;autoExpandSingleChildren;_onDidSplice=new F;onDidSplice=this._onDidSplice.event;refilterDelayer=new R(P);splice(e,t,i=D.empty(),l={}){if(e.length===0)throw new m(this.user,"Invalid tree location");l.diffIdentityProvider?this.spliceSmart(l.diffIdentityProvider,e,t,i,l):this.spliceSimple(e,t,i,l)}spliceSmart(e,t,i,l=D.empty(),n,o=n.diffDepth??0){const{parentNode:r}=this.getParentNodeWithListIndex(t);if(!r.lastDiffIds)return this.spliceSimple(t,i,l,n);const a=[...l],f=t[t.length-1],C=new V({getElements:()=>r.lastDiffIds},{getElements:()=>[...r.children.slice(0,f),...a,...r.children.slice(f+i)].map(h=>e.getId(h.element).toString())}).ComputeDiff(!1);if(C.quitEarly)return r.lastDiffIds=void 0,this.spliceSimple(t,i,a,n);const b=t.slice(0,-1),N=(h,v,g)=>{if(o>0)for(let I=0;I<g;I++)h--,v--,this.spliceSmart(e,[...b,h,0],Number.MAX_SAFE_INTEGER,a[v].children,n,o-1)};let u=Math.min(r.children.length,f+i),p=a.length;for(const h of C.changes.sort((v,g)=>g.originalStart-v.originalStart))N(u,p,u-(h.originalStart+h.originalLength)),u=h.originalStart,p=h.modifiedStart-f,this.spliceSimple([...b,u],h.originalLength,D.slice(a,p,p+h.modifiedLength),n);N(u,p,u)}spliceSimple(e,t,i=D.empty(),{onDidCreateNode:l,onDidDeleteNode:n,diffIdentityProvider:o}){const{parentNode:r,listIndex:a,revealed:f,visible:C}=this.getParentNodeWithListIndex(e),b=[],N=D.map(i,s=>this.createTreeNode(s,r,r.visible?d.Visible:d.Hidden,f,b,l)),u=e[e.length-1];let p=0;for(let s=u;s>=0&&s<r.children.length;s--){const T=r.children[s];if(T.visible){p=T.visibleChildIndex;break}}const h=[];let v=0,g=0;for(const s of N)h.push(s),g+=s.renderNodeCount,s.visible&&(s.visibleChildIndex=p+v++);const I=E(r.children,u,t,h);o?r.lastDiffIds?E(r.lastDiffIds,u,t,h.map(s=>o.getId(s.element).toString())):r.lastDiffIds=r.children.map(s=>o.getId(s.element).toString()):r.lastDiffIds=void 0;let x=0;for(const s of I)s.visible&&x++;if(x!==0)for(let s=u+h.length;s<r.children.length;s++){const T=r.children[s];T.visible&&(T.visibleChildIndex-=x)}if(r.visibleChildrenCount+=v-x,f&&C){const s=I.reduce((T,_)=>T+(_.visible?_.renderNodeCount:0),0);this._updateAncestorsRenderNodeCount(r,g-s),this.list.splice(a,s,b)}if(I.length>0&&n){const s=T=>{n(T),T.children.forEach(s)};I.forEach(s)}this._onDidSplice.fire({insertedNodes:h,deletedNodes:I});let y=r;for(;y;){if(y.visibility===d.Recurse){this.refilterDelayer.trigger(()=>this.refilter());break}y=y.parent}}rerender(e){if(e.length===0)throw new m(this.user,"Invalid tree location");const{node:t,listIndex:i,revealed:l}=this.getTreeNodeWithListIndex(e);t.visible&&l&&this.list.splice(i,1,[t])}updateElementHeight(e,t){if(e.length===0)throw new m(this.user,"Invalid tree location");const{listIndex:i}=this.getTreeNodeWithListIndex(e);this.list.updateElementHeight(i,t)}has(e){return this.hasTreeNode(e)}getListIndex(e){const{listIndex:t,visible:i,revealed:l}=this.getTreeNodeWithListIndex(e);return i&&l?t:-1}getListRenderCount(e){return this.getTreeNode(e).renderNodeCount}isCollapsible(e){return this.getTreeNode(e).collapsible}setCollapsible(e,t){const i=this.getTreeNode(e);typeof t>"u"&&(t=!i.collapsible);const l={collapsible:t};return this.eventBufferer.bufferEvents(()=>this._setCollapseState(e,l))}isCollapsed(e){return this.getTreeNode(e).collapsed}setCollapsed(e,t,i){const l=this.getTreeNode(e);typeof t>"u"&&(t=!l.collapsed);const n={collapsed:t,recursive:i||!1};return this.eventBufferer.bufferEvents(()=>this._setCollapseState(e,n))}_setCollapseState(e,t){const{node:i,listIndex:l,revealed:n}=this.getTreeNodeWithListIndex(e),o=this._setListNodeCollapseState(i,l,n,t);if(i!==this.root&&this.autoExpandSingleChildren&&o&&!S(t)&&i.collapsible&&!i.collapsed&&!t.recursive){let r=-1;for(let a=0;a<i.children.length;a++)if(i.children[a].visible)if(r>-1){r=-1;break}else r=a;r>-1&&this._setCollapseState([...e,r],t)}return o}_setListNodeCollapseState(e,t,i,l){const n=this._setNodeCollapseState(e,l,!1);if(!i||!e.visible||!n)return n;const o=e.renderNodeCount,r=this.updateNodeAfterCollapseChange(e),a=o-(t===-1?0:1);return this.list.splice(t+1,a,r.slice(1)),n}_setNodeCollapseState(e,t,i){let l;if(e===this.root?l=!1:(S(t)?(l=e.collapsible!==t.collapsible,e.collapsible=t.collapsible):e.collapsible?(l=e.collapsed!==t.collapsed,e.collapsed=t.collapsed):l=!1,l&&this._onDidChangeCollapseState.fire({node:e,deep:i})),!S(t)&&t.recursive)for(const n of e.children)l=this._setNodeCollapseState(n,t,!0)||l;return l}expandTo(e){this.eventBufferer.bufferEvents(()=>{let t=this.getTreeNode(e);for(;t.parent;)t=t.parent,e=e.slice(0,e.length-1),t.collapsed&&this._setCollapseState(e,{collapsed:!1,recursive:!1})})}refilter(){const e=this.root.renderNodeCount,t=this.updateNodeAfterFilterChange(this.root);this.list.splice(0,e,t),this.refilterDelayer.cancel()}createTreeNode(e,t,i,l,n,o){const r={parent:t,element:e.element,children:[],depth:t.depth+1,visibleChildrenCount:0,visibleChildIndex:-1,collapsible:typeof e.collapsible=="boolean"?e.collapsible:typeof e.collapsed<"u",collapsed:typeof e.collapsed>"u"?this.collapseByDefault:e.collapsed,renderNodeCount:1,visibility:d.Visible,visible:!0,filterData:void 0},a=this._filterNode(r,i);r.visibility=a,l&&n.push(r);const f=e.children||D.empty(),C=l&&a!==d.Hidden&&!r.collapsed;let b=0,N=1;for(const u of f){const p=this.createTreeNode(u,r,a,C,n,o);r.children.push(p),N+=p.renderNodeCount,p.visible&&(p.visibleChildIndex=b++)}return this.allowNonCollapsibleParents||(r.collapsible=r.collapsible||r.children.length>0),r.visibleChildrenCount=b,r.visible=a===d.Recurse?b>0:a===d.Visible,r.visible?r.collapsed||(r.renderNodeCount=N):(r.renderNodeCount=0,l&&n.pop()),o?.(r),r}updateNodeAfterCollapseChange(e){const t=e.renderNodeCount,i=[];return this._updateNodeAfterCollapseChange(e,i),this._updateAncestorsRenderNodeCount(e.parent,i.length-t),i}_updateNodeAfterCollapseChange(e,t){if(e.visible===!1)return 0;if(t.push(e),e.renderNodeCount=1,!e.collapsed)for(const i of e.children)e.renderNodeCount+=this._updateNodeAfterCollapseChange(i,t);return this._onDidChangeRenderNodeCount.fire(e),e.renderNodeCount}updateNodeAfterFilterChange(e){const t=e.renderNodeCount,i=[];return this._updateNodeAfterFilterChange(e,e.visible?d.Visible:d.Hidden,i),this._updateAncestorsRenderNodeCount(e.parent,i.length-t),i}_updateNodeAfterFilterChange(e,t,i,l=!0){let n;if(e!==this.root){if(n=this._filterNode(e,t),n===d.Hidden)return e.visible=!1,e.renderNodeCount=0,!1;l&&i.push(e)}const o=i.length;e.renderNodeCount=e===this.root?0:1;let r=!1;if(!e.collapsed||n!==d.Hidden){let a=0;for(const f of e.children)r=this._updateNodeAfterFilterChange(f,n,i,l&&!e.collapsed)||r,f.visible&&(f.visibleChildIndex=a++);e.visibleChildrenCount=a}else e.visibleChildrenCount=0;return e!==this.root&&(e.visible=n===d.Recurse?r:n===d.Visible,e.visibility=n),e.visible?e.collapsed||(e.renderNodeCount+=i.length-o):(e.renderNodeCount=0,l&&i.pop()),this._onDidChangeRenderNodeCount.fire(e),e.visible}_updateAncestorsRenderNodeCount(e,t){if(t!==0)for(;e;)e.renderNodeCount+=t,this._onDidChangeRenderNodeCount.fire(e),e=e.parent}_filterNode(e,t){const i=this.filter?this.filter.filter(e.element,t):d.Visible;return typeof i=="boolean"?(e.filterData=void 0,i?d.Visible:d.Hidden):M(i)?(e.filterData=i.data,w(i.visibility)):(e.filterData=void 0,w(i))}hasTreeNode(e,t=this.root){if(!e||e.length===0)return!0;const[i,...l]=e;return i<0||i>t.children.length?!1:this.hasTreeNode(l,t.children[i])}getTreeNode(e,t=this.root){if(!e||e.length===0)return t;const[i,...l]=e;if(i<0||i>t.children.length)throw new m(this.user,"Invalid tree location");return this.getTreeNode(l,t.children[i])}getTreeNodeWithListIndex(e){if(e.length===0)return{node:this.root,listIndex:-1,revealed:!0,visible:!1};const{parentNode:t,listIndex:i,revealed:l,visible:n}=this.getParentNodeWithListIndex(e),o=e[e.length-1];if(o<0||o>t.children.length)throw new m(this.user,"Invalid tree location");const r=t.children[o];return{node:r,listIndex:i,revealed:l,visible:n&&r.visible}}getParentNodeWithListIndex(e,t=this.root,i=0,l=!0,n=!0){const[o,...r]=e;if(o<0||o>t.children.length)throw new m(this.user,"Invalid tree location");for(let a=0;a<o;a++)i+=t.children[a].renderNodeCount;return l=l&&!t.collapsed,n=n&&t.visible,r.length===0?{parentNode:t,listIndex:i,revealed:l,visible:n}:this.getParentNodeWithListIndex(r,t.children[o],i+1,l,n)}getNode(e=[]){return this.getTreeNode(e)}getNodeLocation(e){const t=[];let i=e;for(;i.parent;)t.push(i.parent.children.indexOf(i)),i=i.parent;return t.reverse()}getParentNodeLocation(e){if(e.length!==0)return e.length===1?[]:L(e)[0]}getFirstElementChild(e){const t=this.getTreeNode(e);if(t.children.length!==0)return t.children[0].element}getLastElementAncestor(e=[]){const t=this.getTreeNode(e);if(t.children.length!==0)return this._getLastElementAncestor(t)}_getLastElementAncestor(e){return e.children.length===0?e.element:this._getLastElementAncestor(e.children[e.children.length-1])}}export{ie as IndexTreeModel,w as getVisibleState,M as isFilterResult};
