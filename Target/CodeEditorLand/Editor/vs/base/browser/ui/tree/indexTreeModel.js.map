{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/browser/ui/tree/indexTreeModel.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IIdentityProvider } from '../list/list.js';\nimport { ICollapseStateChangeEvent, ITreeElement, ITreeFilter, ITreeFilterDataResult, ITreeListSpliceData, ITreeModel, ITreeModelSpliceEvent, ITreeNode, TreeError, TreeVisibility } from './tree.js';\nimport { splice, tail2 } from '../../../common/arrays.js';\nimport { Delayer } from '../../../common/async.js';\nimport { MicrotaskDelay } from '../../../common/symbols.js';\nimport { LcsDiff } from '../../../common/diff/diff.js';\nimport { Emitter, Event, EventBufferer } from '../../../common/event.js';\nimport { Iterable } from '../../../common/iterator.js';\n\n// Exported for tests\nexport interface IIndexTreeNode<T, TFilterData = void> extends ITreeNode<T, TFilterData> {\n\treadonly parent: IIndexTreeNode<T, TFilterData> | undefined;\n\treadonly children: IIndexTreeNode<T, TFilterData>[];\n\tvisibleChildrenCount: number;\n\tvisibleChildIndex: number;\n\tcollapsible: boolean;\n\tcollapsed: boolean;\n\trenderNodeCount: number;\n\tvisibility: TreeVisibility;\n\tvisible: boolean;\n\tfilterData: TFilterData | undefined;\n\tlastDiffIds?: string[];\n}\n\nexport function isFilterResult<T>(obj: any): obj is ITreeFilterDataResult<T> {\n\treturn typeof obj === 'object' && 'visibility' in obj && 'data' in obj;\n}\n\nexport function getVisibleState(visibility: boolean | TreeVisibility): TreeVisibility {\n\tswitch (visibility) {\n\t\tcase true: return TreeVisibility.Visible;\n\t\tcase false: return TreeVisibility.Hidden;\n\t\tdefault: return visibility;\n\t}\n}\n\nexport interface IIndexTreeModelOptions<T, TFilterData> {\n\treadonly collapseByDefault?: boolean; // defaults to false\n\treadonly allowNonCollapsibleParents?: boolean; // defaults to false\n\treadonly filter?: ITreeFilter<T, TFilterData>;\n\treadonly autoExpandSingleChildren?: boolean;\n}\n\nexport interface IIndexTreeModelSpliceOptions<T, TFilterData> {\n\t/**\n\t * If set, child updates will recurse the given number of levels even if\n\t * items in the splice operation are unchanged. `Infinity` is a valid value.\n\t */\n\treadonly diffDepth?: number;\n\n\t/**\n\t * Identity provider used to optimize splice() calls in the IndexTree. If\n\t * this is not present, optimized splicing is not enabled.\n\t *\n\t * Warning: if this is present, calls to `setChildren()` will not replace\n\t * or update nodes if their identity is the same, even if the elements are\n\t * different. For this, you should call `rerender()`.\n\t */\n\treadonly diffIdentityProvider?: IIdentityProvider<T>;\n\n\t/**\n\t * Callback for when a node is created.\n\t */\n\tonDidCreateNode?: (node: ITreeNode<T, TFilterData>) => void;\n\n\t/**\n\t * Callback for when a node is deleted.\n\t */\n\tonDidDeleteNode?: (node: ITreeNode<T, TFilterData>) => void;\n}\n\ninterface CollapsibleStateUpdate {\n\treadonly collapsible: boolean;\n}\n\ninterface CollapsedStateUpdate {\n\treadonly collapsed: boolean;\n\treadonly recursive: boolean;\n}\n\ntype CollapseStateUpdate = CollapsibleStateUpdate | CollapsedStateUpdate;\n\nfunction isCollapsibleStateUpdate(update: CollapseStateUpdate): update is CollapsibleStateUpdate {\n\treturn typeof (update as any).collapsible === 'boolean';\n}\n\nexport class IndexTreeModel<T extends Exclude<any, undefined>, TFilterData = void> implements ITreeModel<T, TFilterData, number[]> {\n\n\treadonly rootRef = [];\n\n\tprivate root: IIndexTreeNode<T, TFilterData>;\n\tprivate eventBufferer = new EventBufferer();\n\n\tprivate readonly _onDidSpliceModel = new Emitter<ITreeModelSpliceEvent<T, TFilterData>>();\n\treadonly onDidSpliceModel = this._onDidSpliceModel.event;\n\n\tprivate readonly _onDidSpliceRenderedNodes = new Emitter<ITreeListSpliceData<T, TFilterData>>();\n\treadonly onDidSpliceRenderedNodes = this._onDidSpliceRenderedNodes.event;\n\n\tprivate readonly _onDidChangeCollapseState = new Emitter<ICollapseStateChangeEvent<T, TFilterData>>();\n\treadonly onDidChangeCollapseState: Event<ICollapseStateChangeEvent<T, TFilterData>> = this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event);\n\n\tprivate readonly _onDidChangeRenderNodeCount = new Emitter<ITreeNode<T, TFilterData>>();\n\treadonly onDidChangeRenderNodeCount: Event<ITreeNode<T, TFilterData>> = this.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event);\n\n\tprivate collapseByDefault: boolean;\n\tprivate allowNonCollapsibleParents: boolean;\n\tprivate filter?: ITreeFilter<T, TFilterData>;\n\tprivate autoExpandSingleChildren: boolean;\n\n\tprivate readonly refilterDelayer = new Delayer(MicrotaskDelay);\n\n\tconstructor(\n\t\tprivate user: string,\n\t\trootElement: T,\n\t\toptions: IIndexTreeModelOptions<T, TFilterData> = {}\n\t) {\n\t\tthis.collapseByDefault = typeof options.collapseByDefault === 'undefined' ? false : options.collapseByDefault;\n\t\tthis.allowNonCollapsibleParents = options.allowNonCollapsibleParents ?? false;\n\t\tthis.filter = options.filter;\n\t\tthis.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;\n\n\t\tthis.root = {\n\t\t\tparent: undefined,\n\t\t\telement: rootElement,\n\t\t\tchildren: [],\n\t\t\tdepth: 0,\n\t\t\tvisibleChildrenCount: 0,\n\t\t\tvisibleChildIndex: -1,\n\t\t\tcollapsible: false,\n\t\t\tcollapsed: false,\n\t\t\trenderNodeCount: 0,\n\t\t\tvisibility: TreeVisibility.Visible,\n\t\t\tvisible: true,\n\t\t\tfilterData: undefined\n\t\t};\n\t}\n\n\tsplice(\n\t\tlocation: number[],\n\t\tdeleteCount: number,\n\t\ttoInsert: Iterable<ITreeElement<T>> = Iterable.empty(),\n\t\toptions: IIndexTreeModelSpliceOptions<T, TFilterData> = {},\n\t): void {\n\t\tif (location.length === 0) {\n\t\t\tthrow new TreeError(this.user, 'Invalid tree location');\n\t\t}\n\n\t\tif (options.diffIdentityProvider) {\n\t\t\tthis.spliceSmart(options.diffIdentityProvider, location, deleteCount, toInsert, options);\n\t\t} else {\n\t\t\tthis.spliceSimple(location, deleteCount, toInsert, options);\n\t\t}\n\t}\n\n\tprivate spliceSmart(\n\t\tidentity: IIdentityProvider<T>,\n\t\tlocation: number[],\n\t\tdeleteCount: number,\n\t\ttoInsertIterable: Iterable<ITreeElement<T>> = Iterable.empty(),\n\t\toptions: IIndexTreeModelSpliceOptions<T, TFilterData>,\n\t\trecurseLevels = options.diffDepth ?? 0,\n\t) {\n\t\tconst { parentNode } = this.getParentNodeWithListIndex(location);\n\t\tif (!parentNode.lastDiffIds) {\n\t\t\treturn this.spliceSimple(location, deleteCount, toInsertIterable, options);\n\t\t}\n\n\t\tconst toInsert = [...toInsertIterable];\n\t\tconst index = location[location.length - 1];\n\t\tconst diff = new LcsDiff(\n\t\t\t{ getElements: () => parentNode.lastDiffIds! },\n\t\t\t{\n\t\t\t\tgetElements: () => [\n\t\t\t\t\t...parentNode.children.slice(0, index),\n\t\t\t\t\t...toInsert,\n\t\t\t\t\t...parentNode.children.slice(index + deleteCount),\n\t\t\t\t].map(e => identity.getId(e.element).toString())\n\t\t\t},\n\t\t).ComputeDiff(false);\n\n\t\t// if we were given a 'best effort' diff, use default behavior\n\t\tif (diff.quitEarly) {\n\t\t\tparentNode.lastDiffIds = undefined;\n\t\t\treturn this.spliceSimple(location, deleteCount, toInsert, options);\n\t\t}\n\n\t\tconst locationPrefix = location.slice(0, -1);\n\t\tconst recurseSplice = (fromOriginal: number, fromModified: number, count: number) => {\n\t\t\tif (recurseLevels > 0) {\n\t\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\t\tfromOriginal--;\n\t\t\t\t\tfromModified--;\n\t\t\t\t\tthis.spliceSmart(\n\t\t\t\t\t\tidentity,\n\t\t\t\t\t\t[...locationPrefix, fromOriginal, 0],\n\t\t\t\t\t\tNumber.MAX_SAFE_INTEGER,\n\t\t\t\t\t\ttoInsert[fromModified].children,\n\t\t\t\t\t\toptions,\n\t\t\t\t\t\trecurseLevels - 1,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tlet lastStartO = Math.min(parentNode.children.length, index + deleteCount);\n\t\tlet lastStartM = toInsert.length;\n\t\tfor (const change of diff.changes.sort((a, b) => b.originalStart - a.originalStart)) {\n\t\t\trecurseSplice(lastStartO, lastStartM, lastStartO - (change.originalStart + change.originalLength));\n\t\t\tlastStartO = change.originalStart;\n\t\t\tlastStartM = change.modifiedStart - index;\n\n\t\t\tthis.spliceSimple(\n\t\t\t\t[...locationPrefix, lastStartO],\n\t\t\t\tchange.originalLength,\n\t\t\t\tIterable.slice(toInsert, lastStartM, lastStartM + change.modifiedLength),\n\t\t\t\toptions,\n\t\t\t);\n\t\t}\n\n\t\t// at this point, startO === startM === count since any remaining prefix should match\n\t\trecurseSplice(lastStartO, lastStartM, lastStartO);\n\t}\n\n\tprivate spliceSimple(\n\t\tlocation: number[],\n\t\tdeleteCount: number,\n\t\ttoInsert: Iterable<ITreeElement<T>> = Iterable.empty(),\n\t\t{ onDidCreateNode, onDidDeleteNode, diffIdentityProvider }: IIndexTreeModelSpliceOptions<T, TFilterData>,\n\t) {\n\t\tconst { parentNode, listIndex, revealed, visible } = this.getParentNodeWithListIndex(location);\n\t\tconst treeListElementsToInsert: ITreeNode<T, TFilterData>[] = [];\n\t\tconst nodesToInsertIterator = Iterable.map(toInsert, el => this.createTreeNode(el, parentNode, parentNode.visible ? TreeVisibility.Visible : TreeVisibility.Hidden, revealed, treeListElementsToInsert, onDidCreateNode));\n\n\t\tconst lastIndex = location[location.length - 1];\n\n\t\t// figure out what's the visible child start index right before the\n\t\t// splice point\n\t\tlet visibleChildStartIndex = 0;\n\n\t\tfor (let i = lastIndex; i >= 0 && i < parentNode.children.length; i--) {\n\t\t\tconst child = parentNode.children[i];\n\n\t\t\tif (child.visible) {\n\t\t\t\tvisibleChildStartIndex = child.visibleChildIndex;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tconst nodesToInsert: IIndexTreeNode<T, TFilterData>[] = [];\n\t\tlet insertedVisibleChildrenCount = 0;\n\t\tlet renderNodeCount = 0;\n\n\t\tfor (const child of nodesToInsertIterator) {\n\t\t\tnodesToInsert.push(child);\n\t\t\trenderNodeCount += child.renderNodeCount;\n\n\t\t\tif (child.visible) {\n\t\t\t\tchild.visibleChildIndex = visibleChildStartIndex + insertedVisibleChildrenCount++;\n\t\t\t}\n\t\t}\n\n\t\tconst deletedNodes = splice(parentNode.children, lastIndex, deleteCount, nodesToInsert);\n\n\t\tif (!diffIdentityProvider) {\n\t\t\tparentNode.lastDiffIds = undefined;\n\t\t} else if (parentNode.lastDiffIds) {\n\t\t\tsplice(parentNode.lastDiffIds, lastIndex, deleteCount, nodesToInsert.map(n => diffIdentityProvider.getId(n.element).toString()));\n\t\t} else {\n\t\t\tparentNode.lastDiffIds = parentNode.children.map(n => diffIdentityProvider.getId(n.element).toString());\n\t\t}\n\n\t\t// figure out what is the count of deleted visible children\n\t\tlet deletedVisibleChildrenCount = 0;\n\n\t\tfor (const child of deletedNodes) {\n\t\t\tif (child.visible) {\n\t\t\t\tdeletedVisibleChildrenCount++;\n\t\t\t}\n\t\t}\n\n\t\t// and adjust for all visible children after the splice point\n\t\tif (deletedVisibleChildrenCount !== 0) {\n\t\t\tfor (let i = lastIndex + nodesToInsert.length; i < parentNode.children.length; i++) {\n\t\t\t\tconst child = parentNode.children[i];\n\n\t\t\t\tif (child.visible) {\n\t\t\t\t\tchild.visibleChildIndex -= deletedVisibleChildrenCount;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// update parent's visible children count\n\t\tparentNode.visibleChildrenCount += insertedVisibleChildrenCount - deletedVisibleChildrenCount;\n\n\t\tif (revealed && visible) {\n\t\t\tconst visibleDeleteCount = deletedNodes.reduce((r, node) => r + (node.visible ? node.renderNodeCount : 0), 0);\n\n\t\t\tthis._updateAncestorsRenderNodeCount(parentNode, renderNodeCount - visibleDeleteCount);\n\t\t\tthis._onDidSpliceRenderedNodes.fire({ start: listIndex, deleteCount: visibleDeleteCount, elements: treeListElementsToInsert });\n\t\t}\n\n\t\tif (deletedNodes.length > 0 && onDidDeleteNode) {\n\t\t\tconst visit = (node: ITreeNode<T, TFilterData>) => {\n\t\t\t\tonDidDeleteNode(node);\n\t\t\t\tnode.children.forEach(visit);\n\t\t\t};\n\n\t\t\tdeletedNodes.forEach(visit);\n\t\t}\n\n\t\tthis._onDidSpliceModel.fire({ insertedNodes: nodesToInsert, deletedNodes });\n\n\t\tlet node: IIndexTreeNode<T, TFilterData> | undefined = parentNode;\n\n\t\twhile (node) {\n\t\t\tif (node.visibility === TreeVisibility.Recurse) {\n\t\t\t\t// delayed to avoid excessive refiltering, see #135941\n\t\t\t\tthis.refilterDelayer.trigger(() => this.refilter());\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnode = node.parent;\n\t\t}\n\t}\n\n\trerender(location: number[]): void {\n\t\tif (location.length === 0) {\n\t\t\tthrow new TreeError(this.user, 'Invalid tree location');\n\t\t}\n\n\t\tconst { node, listIndex, revealed } = this.getTreeNodeWithListIndex(location);\n\n\t\tif (node.visible && revealed) {\n\t\t\tthis._onDidSpliceRenderedNodes.fire({ start: listIndex, deleteCount: 1, elements: [node] });\n\t\t}\n\t}\n\n\thas(location: number[]): boolean {\n\t\treturn this.hasTreeNode(location);\n\t}\n\n\tgetListIndex(location: number[]): number {\n\t\tconst { listIndex, visible, revealed } = this.getTreeNodeWithListIndex(location);\n\t\treturn visible && revealed ? listIndex : -1;\n\t}\n\n\tgetListRenderCount(location: number[]): number {\n\t\treturn this.getTreeNode(location).renderNodeCount;\n\t}\n\n\tisCollapsible(location: number[]): boolean {\n\t\treturn this.getTreeNode(location).collapsible;\n\t}\n\n\tsetCollapsible(location: number[], collapsible?: boolean): boolean {\n\t\tconst node = this.getTreeNode(location);\n\n\t\tif (typeof collapsible === 'undefined') {\n\t\t\tcollapsible = !node.collapsible;\n\t\t}\n\n\t\tconst update: CollapsibleStateUpdate = { collapsible };\n\t\treturn this.eventBufferer.bufferEvents(() => this._setCollapseState(location, update));\n\t}\n\n\tisCollapsed(location: number[]): boolean {\n\t\treturn this.getTreeNode(location).collapsed;\n\t}\n\n\tsetCollapsed(location: number[], collapsed?: boolean, recursive?: boolean): boolean {\n\t\tconst node = this.getTreeNode(location);\n\n\t\tif (typeof collapsed === 'undefined') {\n\t\t\tcollapsed = !node.collapsed;\n\t\t}\n\n\t\tconst update: CollapsedStateUpdate = { collapsed, recursive: recursive || false };\n\t\treturn this.eventBufferer.bufferEvents(() => this._setCollapseState(location, update));\n\t}\n\n\tprivate _setCollapseState(location: number[], update: CollapseStateUpdate): boolean {\n\t\tconst { node, listIndex, revealed } = this.getTreeNodeWithListIndex(location);\n\n\t\tconst result = this._setListNodeCollapseState(node, listIndex, revealed, update);\n\n\t\tif (node !== this.root && this.autoExpandSingleChildren && result && !isCollapsibleStateUpdate(update) && node.collapsible && !node.collapsed && !update.recursive) {\n\t\t\tlet onlyVisibleChildIndex = -1;\n\n\t\t\tfor (let i = 0; i < node.children.length; i++) {\n\t\t\t\tconst child = node.children[i];\n\n\t\t\t\tif (child.visible) {\n\t\t\t\t\tif (onlyVisibleChildIndex > -1) {\n\t\t\t\t\t\tonlyVisibleChildIndex = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tonlyVisibleChildIndex = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (onlyVisibleChildIndex > -1) {\n\t\t\t\tthis._setCollapseState([...location, onlyVisibleChildIndex], update);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate _setListNodeCollapseState(node: IIndexTreeNode<T, TFilterData>, listIndex: number, revealed: boolean, update: CollapseStateUpdate): boolean {\n\t\tconst result = this._setNodeCollapseState(node, update, false);\n\n\t\tif (!revealed || !node.visible || !result) {\n\t\t\treturn result;\n\t\t}\n\n\t\tconst previousRenderNodeCount = node.renderNodeCount;\n\t\tconst toInsert = this.updateNodeAfterCollapseChange(node);\n\t\tconst deleteCount = previousRenderNodeCount - (listIndex === -1 ? 0 : 1);\n\t\tthis._onDidSpliceRenderedNodes.fire({ start: listIndex + 1, deleteCount: deleteCount, elements: toInsert.slice(1) });\n\n\t\treturn result;\n\t}\n\n\tprivate _setNodeCollapseState(node: IIndexTreeNode<T, TFilterData>, update: CollapseStateUpdate, deep: boolean): boolean {\n\t\tlet result: boolean;\n\n\t\tif (node === this.root) {\n\t\t\tresult = false;\n\t\t} else {\n\t\t\tif (isCollapsibleStateUpdate(update)) {\n\t\t\t\tresult = node.collapsible !== update.collapsible;\n\t\t\t\tnode.collapsible = update.collapsible;\n\t\t\t} else if (!node.collapsible) {\n\t\t\t\tresult = false;\n\t\t\t} else {\n\t\t\t\tresult = node.collapsed !== update.collapsed;\n\t\t\t\tnode.collapsed = update.collapsed;\n\t\t\t}\n\n\t\t\tif (result) {\n\t\t\t\tthis._onDidChangeCollapseState.fire({ node, deep });\n\t\t\t}\n\t\t}\n\n\t\tif (!isCollapsibleStateUpdate(update) && update.recursive) {\n\t\t\tfor (const child of node.children) {\n\t\t\t\tresult = this._setNodeCollapseState(child, update, true) || result;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\texpandTo(location: number[]): void {\n\t\tthis.eventBufferer.bufferEvents(() => {\n\t\t\tlet node = this.getTreeNode(location);\n\n\t\t\twhile (node.parent) {\n\t\t\t\tnode = node.parent;\n\t\t\t\tlocation = location.slice(0, location.length - 1);\n\n\t\t\t\tif (node.collapsed) {\n\t\t\t\t\tthis._setCollapseState(location, { collapsed: false, recursive: false });\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\trefilter(): void {\n\t\tconst previousRenderNodeCount = this.root.renderNodeCount;\n\t\tconst toInsert = this.updateNodeAfterFilterChange(this.root);\n\t\tthis._onDidSpliceRenderedNodes.fire({ start: 0, deleteCount: previousRenderNodeCount, elements: toInsert });\n\t\tthis.refilterDelayer.cancel();\n\t}\n\n\tprivate createTreeNode(\n\t\ttreeElement: ITreeElement<T>,\n\t\tparent: IIndexTreeNode<T, TFilterData>,\n\t\tparentVisibility: TreeVisibility,\n\t\trevealed: boolean,\n\t\ttreeListElements: ITreeNode<T, TFilterData>[],\n\t\tonDidCreateNode?: (node: ITreeNode<T, TFilterData>) => void\n\t): IIndexTreeNode<T, TFilterData> {\n\t\tconst node: IIndexTreeNode<T, TFilterData> = {\n\t\t\tparent,\n\t\t\telement: treeElement.element,\n\t\t\tchildren: [],\n\t\t\tdepth: parent.depth + 1,\n\t\t\tvisibleChildrenCount: 0,\n\t\t\tvisibleChildIndex: -1,\n\t\t\tcollapsible: typeof treeElement.collapsible === 'boolean' ? treeElement.collapsible : (typeof treeElement.collapsed !== 'undefined'),\n\t\t\tcollapsed: typeof treeElement.collapsed === 'undefined' ? this.collapseByDefault : treeElement.collapsed,\n\t\t\trenderNodeCount: 1,\n\t\t\tvisibility: TreeVisibility.Visible,\n\t\t\tvisible: true,\n\t\t\tfilterData: undefined\n\t\t};\n\n\t\tconst visibility = this._filterNode(node, parentVisibility);\n\t\tnode.visibility = visibility;\n\n\t\tif (revealed) {\n\t\t\ttreeListElements.push(node);\n\t\t}\n\n\t\tconst childElements = treeElement.children || Iterable.empty();\n\t\tconst childRevealed = revealed && visibility !== TreeVisibility.Hidden && !node.collapsed;\n\n\t\tlet visibleChildrenCount = 0;\n\t\tlet renderNodeCount = 1;\n\n\t\tfor (const el of childElements) {\n\t\t\tconst child = this.createTreeNode(el, node, visibility, childRevealed, treeListElements, onDidCreateNode);\n\t\t\tnode.children.push(child);\n\t\t\trenderNodeCount += child.renderNodeCount;\n\n\t\t\tif (child.visible) {\n\t\t\t\tchild.visibleChildIndex = visibleChildrenCount++;\n\t\t\t}\n\t\t}\n\n\t\tif (!this.allowNonCollapsibleParents) {\n\t\t\tnode.collapsible = node.collapsible || node.children.length > 0;\n\t\t}\n\n\t\tnode.visibleChildrenCount = visibleChildrenCount;\n\t\tnode.visible = visibility === TreeVisibility.Recurse ? visibleChildrenCount > 0 : (visibility === TreeVisibility.Visible);\n\n\t\tif (!node.visible) {\n\t\t\tnode.renderNodeCount = 0;\n\n\t\t\tif (revealed) {\n\t\t\t\ttreeListElements.pop();\n\t\t\t}\n\t\t} else if (!node.collapsed) {\n\t\t\tnode.renderNodeCount = renderNodeCount;\n\t\t}\n\n\t\tonDidCreateNode?.(node);\n\n\t\treturn node;\n\t}\n\n\tprivate updateNodeAfterCollapseChange(node: IIndexTreeNode<T, TFilterData>): ITreeNode<T, TFilterData>[] {\n\t\tconst previousRenderNodeCount = node.renderNodeCount;\n\t\tconst result: ITreeNode<T, TFilterData>[] = [];\n\n\t\tthis._updateNodeAfterCollapseChange(node, result);\n\t\tthis._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\n\n\t\treturn result;\n\t}\n\n\tprivate _updateNodeAfterCollapseChange(node: IIndexTreeNode<T, TFilterData>, result: ITreeNode<T, TFilterData>[]): number {\n\t\tif (node.visible === false) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tresult.push(node);\n\t\tnode.renderNodeCount = 1;\n\n\t\tif (!node.collapsed) {\n\t\t\tfor (const child of node.children) {\n\t\t\t\tnode.renderNodeCount += this._updateNodeAfterCollapseChange(child, result);\n\t\t\t}\n\t\t}\n\n\t\tthis._onDidChangeRenderNodeCount.fire(node);\n\t\treturn node.renderNodeCount;\n\t}\n\n\tprivate updateNodeAfterFilterChange(node: IIndexTreeNode<T, TFilterData>): ITreeNode<T, TFilterData>[] {\n\t\tconst previousRenderNodeCount = node.renderNodeCount;\n\t\tconst result: ITreeNode<T, TFilterData>[] = [];\n\n\t\tthis._updateNodeAfterFilterChange(node, node.visible ? TreeVisibility.Visible : TreeVisibility.Hidden, result);\n\t\tthis._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\n\n\t\treturn result;\n\t}\n\n\tprivate _updateNodeAfterFilterChange(node: IIndexTreeNode<T, TFilterData>, parentVisibility: TreeVisibility, result: ITreeNode<T, TFilterData>[], revealed = true): boolean {\n\t\tlet visibility: TreeVisibility;\n\n\t\tif (node !== this.root) {\n\t\t\tvisibility = this._filterNode(node, parentVisibility);\n\n\t\t\tif (visibility === TreeVisibility.Hidden) {\n\t\t\t\tnode.visible = false;\n\t\t\t\tnode.renderNodeCount = 0;\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (revealed) {\n\t\t\t\tresult.push(node);\n\t\t\t}\n\t\t}\n\n\t\tconst resultStartLength = result.length;\n\t\tnode.renderNodeCount = node === this.root ? 0 : 1;\n\n\t\tlet hasVisibleDescendants = false;\n\t\tif (!node.collapsed || visibility! !== TreeVisibility.Hidden) {\n\t\t\tlet visibleChildIndex = 0;\n\n\t\t\tfor (const child of node.children) {\n\t\t\t\thasVisibleDescendants = this._updateNodeAfterFilterChange(child, visibility!, result, revealed && !node.collapsed) || hasVisibleDescendants;\n\n\t\t\t\tif (child.visible) {\n\t\t\t\t\tchild.visibleChildIndex = visibleChildIndex++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnode.visibleChildrenCount = visibleChildIndex;\n\t\t} else {\n\t\t\tnode.visibleChildrenCount = 0;\n\t\t}\n\n\t\tif (node !== this.root) {\n\t\t\tnode.visible = visibility! === TreeVisibility.Recurse ? hasVisibleDescendants : (visibility! === TreeVisibility.Visible);\n\t\t\tnode.visibility = visibility!;\n\t\t}\n\n\t\tif (!node.visible) {\n\t\t\tnode.renderNodeCount = 0;\n\n\t\t\tif (revealed) {\n\t\t\t\tresult.pop();\n\t\t\t}\n\t\t} else if (!node.collapsed) {\n\t\t\tnode.renderNodeCount += result.length - resultStartLength;\n\t\t}\n\n\t\tthis._onDidChangeRenderNodeCount.fire(node);\n\t\treturn node.visible;\n\t}\n\n\tprivate _updateAncestorsRenderNodeCount(node: IIndexTreeNode<T, TFilterData> | undefined, diff: number): void {\n\t\tif (diff === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\twhile (node) {\n\t\t\tnode.renderNodeCount += diff;\n\t\t\tthis._onDidChangeRenderNodeCount.fire(node);\n\t\t\tnode = node.parent;\n\t\t}\n\t}\n\n\tprivate _filterNode(node: IIndexTreeNode<T, TFilterData>, parentVisibility: TreeVisibility): TreeVisibility {\n\t\tconst result = this.filter ? this.filter.filter(node.element, parentVisibility) : TreeVisibility.Visible;\n\n\t\tif (typeof result === 'boolean') {\n\t\t\tnode.filterData = undefined;\n\t\t\treturn result ? TreeVisibility.Visible : TreeVisibility.Hidden;\n\t\t} else if (isFilterResult<TFilterData>(result)) {\n\t\t\tnode.filterData = result.data;\n\t\t\treturn getVisibleState(result.visibility);\n\t\t} else {\n\t\t\tnode.filterData = undefined;\n\t\t\treturn getVisibleState(result);\n\t\t}\n\t}\n\n\t// cheap\n\tprivate hasTreeNode(location: number[], node: IIndexTreeNode<T, TFilterData> = this.root): boolean {\n\t\tif (!location || location.length === 0) {\n\t\t\treturn true;\n\t\t}\n\n\t\tconst [index, ...rest] = location;\n\n\t\tif (index < 0 || index > node.children.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this.hasTreeNode(rest, node.children[index]);\n\t}\n\n\t// cheap\n\tprivate getTreeNode(location: number[], node: IIndexTreeNode<T, TFilterData> = this.root): IIndexTreeNode<T, TFilterData> {\n\t\tif (!location || location.length === 0) {\n\t\t\treturn node;\n\t\t}\n\n\t\tconst [index, ...rest] = location;\n\n\t\tif (index < 0 || index > node.children.length) {\n\t\t\tthrow new TreeError(this.user, 'Invalid tree location');\n\t\t}\n\n\t\treturn this.getTreeNode(rest, node.children[index]);\n\t}\n\n\t// expensive\n\tprivate getTreeNodeWithListIndex(location: number[]): { node: IIndexTreeNode<T, TFilterData>; listIndex: number; revealed: boolean; visible: boolean } {\n\t\tif (location.length === 0) {\n\t\t\treturn { node: this.root, listIndex: -1, revealed: true, visible: false };\n\t\t}\n\n\t\tconst { parentNode, listIndex, revealed, visible } = this.getParentNodeWithListIndex(location);\n\t\tconst index = location[location.length - 1];\n\n\t\tif (index < 0 || index > parentNode.children.length) {\n\t\t\tthrow new TreeError(this.user, 'Invalid tree location');\n\t\t}\n\n\t\tconst node = parentNode.children[index];\n\n\t\treturn { node, listIndex, revealed, visible: visible && node.visible };\n\t}\n\n\tprivate getParentNodeWithListIndex(location: number[], node: IIndexTreeNode<T, TFilterData> = this.root, listIndex: number = 0, revealed = true, visible = true): { parentNode: IIndexTreeNode<T, TFilterData>; listIndex: number; revealed: boolean; visible: boolean } {\n\t\tconst [index, ...rest] = location;\n\n\t\tif (index < 0 || index > node.children.length) {\n\t\t\tthrow new TreeError(this.user, 'Invalid tree location');\n\t\t}\n\n\t\t// TODO@joao perf!\n\t\tfor (let i = 0; i < index; i++) {\n\t\t\tlistIndex += node.children[i].renderNodeCount;\n\t\t}\n\n\t\trevealed = revealed && !node.collapsed;\n\t\tvisible = visible && node.visible;\n\n\t\tif (rest.length === 0) {\n\t\t\treturn { parentNode: node, listIndex, revealed, visible };\n\t\t}\n\n\t\treturn this.getParentNodeWithListIndex(rest, node.children[index], listIndex + 1, revealed, visible);\n\t}\n\n\tgetNode(location: number[] = []): ITreeNode<T, TFilterData> {\n\t\treturn this.getTreeNode(location);\n\t}\n\n\t// TODO@joao perf!\n\tgetNodeLocation(node: ITreeNode<T, TFilterData>): number[] {\n\t\tconst location: number[] = [];\n\t\tlet indexTreeNode = node as IIndexTreeNode<T, TFilterData>; // typing woes\n\n\t\twhile (indexTreeNode.parent) {\n\t\t\tlocation.push(indexTreeNode.parent.children.indexOf(indexTreeNode));\n\t\t\tindexTreeNode = indexTreeNode.parent;\n\t\t}\n\n\t\treturn location.reverse();\n\t}\n\n\tgetParentNodeLocation(location: number[]): number[] | undefined {\n\t\tif (location.length === 0) {\n\t\t\treturn undefined;\n\t\t} else if (location.length === 1) {\n\t\t\treturn [];\n\t\t} else {\n\t\t\treturn tail2(location)[0];\n\t\t}\n\t}\n\n\tgetFirstElementChild(location: number[]): T | undefined {\n\t\tconst node = this.getTreeNode(location);\n\n\t\tif (node.children.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn node.children[0].element;\n\t}\n\n\tgetLastElementAncestor(location: number[] = []): T | undefined {\n\t\tconst node = this.getTreeNode(location);\n\n\t\tif (node.children.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn this._getLastElementAncestor(node);\n\t}\n\n\tprivate _getLastElementAncestor(node: ITreeNode<T, TFilterData>): T {\n\t\tif (node.children.length === 0) {\n\t\t\treturn node.element;\n\t\t}\n\n\t\treturn this._getLastElementAncestor(node.children[node.children.length - 1]);\n\t}\n}\n"],
  "mappings": "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",
  "names": ["node"]
}
