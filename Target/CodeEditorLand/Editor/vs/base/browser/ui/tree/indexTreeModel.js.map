{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/browser/ui/tree/indexTreeModel.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { splice, tail2 } from \"../../../common/arrays.js\";\nimport { Delayer } from \"../../../common/async.js\";\nimport { LcsDiff } from \"../../../common/diff/diff.js\";\nimport { Emitter, type Event, EventBufferer } from \"../../../common/event.js\";\nimport { Iterable } from \"../../../common/iterator.js\";\nimport { MicrotaskDelay } from \"../../../common/symbols.js\";\nimport type { IIdentityProvider } from \"../list/list.js\";\nimport {\n\ttype ICollapseStateChangeEvent,\n\ttype ITreeElement,\n\ttype ITreeFilter,\n\ttype ITreeFilterDataResult,\n\ttype ITreeListSpliceData,\n\ttype ITreeModel,\n\ttype ITreeModelSpliceEvent,\n\ttype ITreeNode,\n\tTreeError,\n\tTreeVisibility,\n} from \"./tree.js\";\n\n// Exported for tests\nexport interface IIndexTreeNode<T, TFilterData = void>\n\textends ITreeNode<T, TFilterData> {\n\treadonly parent: IIndexTreeNode<T, TFilterData> | undefined;\n\treadonly children: IIndexTreeNode<T, TFilterData>[];\n\tvisibleChildrenCount: number;\n\tvisibleChildIndex: number;\n\tcollapsible: boolean;\n\tcollapsed: boolean;\n\trenderNodeCount: number;\n\tvisibility: TreeVisibility;\n\tvisible: boolean;\n\tfilterData: TFilterData | undefined;\n\tlastDiffIds?: string[];\n}\n\nexport function isFilterResult<T>(obj: any): obj is ITreeFilterDataResult<T> {\n\treturn typeof obj === \"object\" && \"visibility\" in obj && \"data\" in obj;\n}\n\nexport function getVisibleState(\n\tvisibility: boolean | TreeVisibility,\n): TreeVisibility {\n\tswitch (visibility) {\n\t\tcase true:\n\t\t\treturn TreeVisibility.Visible;\n\t\tcase false:\n\t\t\treturn TreeVisibility.Hidden;\n\t\tdefault:\n\t\t\treturn visibility;\n\t}\n}\n\nexport interface IIndexTreeModelOptions<T, TFilterData> {\n\treadonly collapseByDefault?: boolean; // defaults to false\n\treadonly allowNonCollapsibleParents?: boolean; // defaults to false\n\treadonly filter?: ITreeFilter<T, TFilterData>;\n\treadonly autoExpandSingleChildren?: boolean;\n}\n\nexport interface IIndexTreeModelSpliceOptions<T, TFilterData> {\n\t/**\n\t * If set, child updates will recurse the given number of levels even if\n\t * items in the splice operation are unchanged. `Infinity` is a valid value.\n\t */\n\treadonly diffDepth?: number;\n\n\t/**\n\t * Identity provider used to optimize splice() calls in the IndexTree. If\n\t * this is not present, optimized splicing is not enabled.\n\t *\n\t * Warning: if this is present, calls to `setChildren()` will not replace\n\t * or update nodes if their identity is the same, even if the elements are\n\t * different. For this, you should call `rerender()`.\n\t */\n\treadonly diffIdentityProvider?: IIdentityProvider<T>;\n\n\t/**\n\t * Callback for when a node is created.\n\t */\n\tonDidCreateNode?: (node: ITreeNode<T, TFilterData>) => void;\n\n\t/**\n\t * Callback for when a node is deleted.\n\t */\n\tonDidDeleteNode?: (node: ITreeNode<T, TFilterData>) => void;\n}\n\ninterface CollapsibleStateUpdate {\n\treadonly collapsible: boolean;\n}\n\ninterface CollapsedStateUpdate {\n\treadonly collapsed: boolean;\n\treadonly recursive: boolean;\n}\n\ntype CollapseStateUpdate = CollapsibleStateUpdate | CollapsedStateUpdate;\n\nfunction isCollapsibleStateUpdate(\n\tupdate: CollapseStateUpdate,\n): update is CollapsibleStateUpdate {\n\treturn typeof (update as any).collapsible === \"boolean\";\n}\n\nexport class IndexTreeModel<\n\tT extends Exclude<any, undefined>,\n\tTFilterData = void,\n> implements ITreeModel<T, TFilterData, number[]>\n{\n\treadonly rootRef = [];\n\n\tprivate root: IIndexTreeNode<T, TFilterData>;\n\tprivate eventBufferer = new EventBufferer();\n\n\tprivate readonly _onDidSpliceModel = new Emitter<\n\t\tITreeModelSpliceEvent<T, TFilterData>\n\t>();\n\treadonly onDidSpliceModel = this._onDidSpliceModel.event;\n\n\tprivate readonly _onDidSpliceRenderedNodes = new Emitter<\n\t\tITreeListSpliceData<T, TFilterData>\n\t>();\n\treadonly onDidSpliceRenderedNodes = this._onDidSpliceRenderedNodes.event;\n\n\tprivate readonly _onDidChangeCollapseState = new Emitter<\n\t\tICollapseStateChangeEvent<T, TFilterData>\n\t>();\n\treadonly onDidChangeCollapseState: Event<\n\t\tICollapseStateChangeEvent<T, TFilterData>\n\t> = this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event);\n\n\tprivate readonly _onDidChangeRenderNodeCount = new Emitter<\n\t\tITreeNode<T, TFilterData>\n\t>();\n\treadonly onDidChangeRenderNodeCount: Event<ITreeNode<T, TFilterData>> =\n\t\tthis.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event);\n\n\tprivate collapseByDefault: boolean;\n\tprivate allowNonCollapsibleParents: boolean;\n\tprivate filter?: ITreeFilter<T, TFilterData>;\n\tprivate autoExpandSingleChildren: boolean;\n\n\tprivate readonly refilterDelayer = new Delayer(MicrotaskDelay);\n\n\tconstructor(\n\t\tprivate user: string,\n\t\trootElement: T,\n\t\toptions: IIndexTreeModelOptions<T, TFilterData> = {},\n\t) {\n\t\tthis.collapseByDefault =\n\t\t\ttypeof options.collapseByDefault === \"undefined\"\n\t\t\t\t? false\n\t\t\t\t: options.collapseByDefault;\n\t\tthis.allowNonCollapsibleParents =\n\t\t\toptions.allowNonCollapsibleParents ?? false;\n\t\tthis.filter = options.filter;\n\t\tthis.autoExpandSingleChildren =\n\t\t\ttypeof options.autoExpandSingleChildren === \"undefined\"\n\t\t\t\t? false\n\t\t\t\t: options.autoExpandSingleChildren;\n\n\t\tthis.root = {\n\t\t\tparent: undefined,\n\t\t\telement: rootElement,\n\t\t\tchildren: [],\n\t\t\tdepth: 0,\n\t\t\tvisibleChildrenCount: 0,\n\t\t\tvisibleChildIndex: -1,\n\t\t\tcollapsible: false,\n\t\t\tcollapsed: false,\n\t\t\trenderNodeCount: 0,\n\t\t\tvisibility: TreeVisibility.Visible,\n\t\t\tvisible: true,\n\t\t\tfilterData: undefined,\n\t\t};\n\t}\n\n\tsplice(\n\t\tlocation: number[],\n\t\tdeleteCount: number,\n\t\ttoInsert: Iterable<ITreeElement<T>> = Iterable.empty(),\n\t\toptions: IIndexTreeModelSpliceOptions<T, TFilterData> = {},\n\t): void {\n\t\tif (location.length === 0) {\n\t\t\tthrow new TreeError(this.user, \"Invalid tree location\");\n\t\t}\n\n\t\tif (options.diffIdentityProvider) {\n\t\t\tthis.spliceSmart(\n\t\t\t\toptions.diffIdentityProvider,\n\t\t\t\tlocation,\n\t\t\t\tdeleteCount,\n\t\t\t\ttoInsert,\n\t\t\t\toptions,\n\t\t\t);\n\t\t} else {\n\t\t\tthis.spliceSimple(location, deleteCount, toInsert, options);\n\t\t}\n\t}\n\n\tprivate spliceSmart(\n\t\tidentity: IIdentityProvider<T>,\n\t\tlocation: number[],\n\t\tdeleteCount: number,\n\t\ttoInsertIterable: Iterable<ITreeElement<T>> = Iterable.empty(),\n\t\toptions: IIndexTreeModelSpliceOptions<T, TFilterData>,\n\t\trecurseLevels = options.diffDepth ?? 0,\n\t) {\n\t\tconst { parentNode } = this.getParentNodeWithListIndex(location);\n\t\tif (!parentNode.lastDiffIds) {\n\t\t\treturn this.spliceSimple(\n\t\t\t\tlocation,\n\t\t\t\tdeleteCount,\n\t\t\t\ttoInsertIterable,\n\t\t\t\toptions,\n\t\t\t);\n\t\t}\n\n\t\tconst toInsert = [...toInsertIterable];\n\t\tconst index = location[location.length - 1];\n\t\tconst diff = new LcsDiff(\n\t\t\t{ getElements: () => parentNode.lastDiffIds! },\n\t\t\t{\n\t\t\t\tgetElements: () =>\n\t\t\t\t\t[\n\t\t\t\t\t\t...parentNode.children.slice(0, index),\n\t\t\t\t\t\t...toInsert,\n\t\t\t\t\t\t...parentNode.children.slice(index + deleteCount),\n\t\t\t\t\t].map((e) => identity.getId(e.element).toString()),\n\t\t\t},\n\t\t).ComputeDiff(false);\n\n\t\t// if we were given a 'best effort' diff, use default behavior\n\t\tif (diff.quitEarly) {\n\t\t\tparentNode.lastDiffIds = undefined;\n\t\t\treturn this.spliceSimple(location, deleteCount, toInsert, options);\n\t\t}\n\n\t\tconst locationPrefix = location.slice(0, -1);\n\t\tconst recurseSplice = (\n\t\t\tfromOriginal: number,\n\t\t\tfromModified: number,\n\t\t\tcount: number,\n\t\t) => {\n\t\t\tif (recurseLevels > 0) {\n\t\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\t\tfromOriginal--;\n\t\t\t\t\tfromModified--;\n\t\t\t\t\tthis.spliceSmart(\n\t\t\t\t\t\tidentity,\n\t\t\t\t\t\t[...locationPrefix, fromOriginal, 0],\n\t\t\t\t\t\tNumber.MAX_SAFE_INTEGER,\n\t\t\t\t\t\ttoInsert[fromModified].children,\n\t\t\t\t\t\toptions,\n\t\t\t\t\t\trecurseLevels - 1,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tlet lastStartO = Math.min(\n\t\t\tparentNode.children.length,\n\t\t\tindex + deleteCount,\n\t\t);\n\t\tlet lastStartM = toInsert.length;\n\t\tfor (const change of diff.changes.sort(\n\t\t\t(a, b) => b.originalStart - a.originalStart,\n\t\t)) {\n\t\t\trecurseSplice(\n\t\t\t\tlastStartO,\n\t\t\t\tlastStartM,\n\t\t\t\tlastStartO - (change.originalStart + change.originalLength),\n\t\t\t);\n\t\t\tlastStartO = change.originalStart;\n\t\t\tlastStartM = change.modifiedStart - index;\n\n\t\t\tthis.spliceSimple(\n\t\t\t\t[...locationPrefix, lastStartO],\n\t\t\t\tchange.originalLength,\n\t\t\t\tIterable.slice(\n\t\t\t\t\ttoInsert,\n\t\t\t\t\tlastStartM,\n\t\t\t\t\tlastStartM + change.modifiedLength,\n\t\t\t\t),\n\t\t\t\toptions,\n\t\t\t);\n\t\t}\n\n\t\t// at this point, startO === startM === count since any remaining prefix should match\n\t\trecurseSplice(lastStartO, lastStartM, lastStartO);\n\t}\n\n\tprivate spliceSimple(\n\t\tlocation: number[],\n\t\tdeleteCount: number,\n\t\ttoInsert: Iterable<ITreeElement<T>> = Iterable.empty(),\n\t\t{\n\t\t\tonDidCreateNode,\n\t\t\tonDidDeleteNode,\n\t\t\tdiffIdentityProvider,\n\t\t}: IIndexTreeModelSpliceOptions<T, TFilterData>,\n\t) {\n\t\tconst { parentNode, listIndex, revealed, visible } =\n\t\t\tthis.getParentNodeWithListIndex(location);\n\t\tconst treeListElementsToInsert: ITreeNode<T, TFilterData>[] = [];\n\t\tconst nodesToInsertIterator = Iterable.map(toInsert, (el) =>\n\t\t\tthis.createTreeNode(\n\t\t\t\tel,\n\t\t\t\tparentNode,\n\t\t\t\tparentNode.visible\n\t\t\t\t\t? TreeVisibility.Visible\n\t\t\t\t\t: TreeVisibility.Hidden,\n\t\t\t\trevealed,\n\t\t\t\ttreeListElementsToInsert,\n\t\t\t\tonDidCreateNode,\n\t\t\t),\n\t\t);\n\n\t\tconst lastIndex = location[location.length - 1];\n\n\t\t// figure out what's the visible child start index right before the\n\t\t// splice point\n\t\tlet visibleChildStartIndex = 0;\n\n\t\tfor (let i = lastIndex; i >= 0 && i < parentNode.children.length; i--) {\n\t\t\tconst child = parentNode.children[i];\n\n\t\t\tif (child.visible) {\n\t\t\t\tvisibleChildStartIndex = child.visibleChildIndex;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tconst nodesToInsert: IIndexTreeNode<T, TFilterData>[] = [];\n\t\tlet insertedVisibleChildrenCount = 0;\n\t\tlet renderNodeCount = 0;\n\n\t\tfor (const child of nodesToInsertIterator) {\n\t\t\tnodesToInsert.push(child);\n\t\t\trenderNodeCount += child.renderNodeCount;\n\n\t\t\tif (child.visible) {\n\t\t\t\tchild.visibleChildIndex =\n\t\t\t\t\tvisibleChildStartIndex + insertedVisibleChildrenCount++;\n\t\t\t}\n\t\t}\n\n\t\tconst deletedNodes = splice(\n\t\t\tparentNode.children,\n\t\t\tlastIndex,\n\t\t\tdeleteCount,\n\t\t\tnodesToInsert,\n\t\t);\n\n\t\tif (!diffIdentityProvider) {\n\t\t\tparentNode.lastDiffIds = undefined;\n\t\t} else if (parentNode.lastDiffIds) {\n\t\t\tsplice(\n\t\t\t\tparentNode.lastDiffIds,\n\t\t\t\tlastIndex,\n\t\t\t\tdeleteCount,\n\t\t\t\tnodesToInsert.map((n) =>\n\t\t\t\t\tdiffIdentityProvider.getId(n.element).toString(),\n\t\t\t\t),\n\t\t\t);\n\t\t} else {\n\t\t\tparentNode.lastDiffIds = parentNode.children.map((n) =>\n\t\t\t\tdiffIdentityProvider.getId(n.element).toString(),\n\t\t\t);\n\t\t}\n\n\t\t// figure out what is the count of deleted visible children\n\t\tlet deletedVisibleChildrenCount = 0;\n\n\t\tfor (const child of deletedNodes) {\n\t\t\tif (child.visible) {\n\t\t\t\tdeletedVisibleChildrenCount++;\n\t\t\t}\n\t\t}\n\n\t\t// and adjust for all visible children after the splice point\n\t\tif (deletedVisibleChildrenCount !== 0) {\n\t\t\tfor (\n\t\t\t\tlet i = lastIndex + nodesToInsert.length;\n\t\t\t\ti < parentNode.children.length;\n\t\t\t\ti++\n\t\t\t) {\n\t\t\t\tconst child = parentNode.children[i];\n\n\t\t\t\tif (child.visible) {\n\t\t\t\t\tchild.visibleChildIndex -= deletedVisibleChildrenCount;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// update parent's visible children count\n\t\tparentNode.visibleChildrenCount +=\n\t\t\tinsertedVisibleChildrenCount - deletedVisibleChildrenCount;\n\n\t\tif (revealed && visible) {\n\t\t\tconst visibleDeleteCount = deletedNodes.reduce(\n\t\t\t\t(r, node) => r + (node.visible ? node.renderNodeCount : 0),\n\t\t\t\t0,\n\t\t\t);\n\n\t\t\tthis._updateAncestorsRenderNodeCount(\n\t\t\t\tparentNode,\n\t\t\t\trenderNodeCount - visibleDeleteCount,\n\t\t\t);\n\t\t\tthis._onDidSpliceRenderedNodes.fire({\n\t\t\t\tstart: listIndex,\n\t\t\t\tdeleteCount: visibleDeleteCount,\n\t\t\t\telements: treeListElementsToInsert,\n\t\t\t});\n\t\t}\n\n\t\tif (deletedNodes.length > 0 && onDidDeleteNode) {\n\t\t\tconst visit = (node: ITreeNode<T, TFilterData>) => {\n\t\t\t\tonDidDeleteNode(node);\n\t\t\t\tnode.children.forEach(visit);\n\t\t\t};\n\n\t\t\tdeletedNodes.forEach(visit);\n\t\t}\n\n\t\tthis._onDidSpliceModel.fire({\n\t\t\tinsertedNodes: nodesToInsert,\n\t\t\tdeletedNodes,\n\t\t});\n\n\t\tlet node: IIndexTreeNode<T, TFilterData> | undefined = parentNode;\n\n\t\twhile (node) {\n\t\t\tif (node.visibility === TreeVisibility.Recurse) {\n\t\t\t\t// delayed to avoid excessive refiltering, see #135941\n\t\t\t\tthis.refilterDelayer.trigger(() => this.refilter());\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnode = node.parent;\n\t\t}\n\t}\n\n\trerender(location: number[]): void {\n\t\tif (location.length === 0) {\n\t\t\tthrow new TreeError(this.user, \"Invalid tree location\");\n\t\t}\n\n\t\tconst { node, listIndex, revealed } =\n\t\t\tthis.getTreeNodeWithListIndex(location);\n\n\t\tif (node.visible && revealed) {\n\t\t\tthis._onDidSpliceRenderedNodes.fire({\n\t\t\t\tstart: listIndex,\n\t\t\t\tdeleteCount: 1,\n\t\t\t\telements: [node],\n\t\t\t});\n\t\t}\n\t}\n\n\thas(location: number[]): boolean {\n\t\treturn this.hasTreeNode(location);\n\t}\n\n\tgetListIndex(location: number[]): number {\n\t\tconst { listIndex, visible, revealed } =\n\t\t\tthis.getTreeNodeWithListIndex(location);\n\t\treturn visible && revealed ? listIndex : -1;\n\t}\n\n\tgetListRenderCount(location: number[]): number {\n\t\treturn this.getTreeNode(location).renderNodeCount;\n\t}\n\n\tisCollapsible(location: number[]): boolean {\n\t\treturn this.getTreeNode(location).collapsible;\n\t}\n\n\tsetCollapsible(location: number[], collapsible?: boolean): boolean {\n\t\tconst node = this.getTreeNode(location);\n\n\t\tif (typeof collapsible === \"undefined\") {\n\t\t\tcollapsible = !node.collapsible;\n\t\t}\n\n\t\tconst update: CollapsibleStateUpdate = { collapsible };\n\t\treturn this.eventBufferer.bufferEvents(() =>\n\t\t\tthis._setCollapseState(location, update),\n\t\t);\n\t}\n\n\tisCollapsed(location: number[]): boolean {\n\t\treturn this.getTreeNode(location).collapsed;\n\t}\n\n\tsetCollapsed(\n\t\tlocation: number[],\n\t\tcollapsed?: boolean,\n\t\trecursive?: boolean,\n\t): boolean {\n\t\tconst node = this.getTreeNode(location);\n\n\t\tif (typeof collapsed === \"undefined\") {\n\t\t\tcollapsed = !node.collapsed;\n\t\t}\n\n\t\tconst update: CollapsedStateUpdate = {\n\t\t\tcollapsed,\n\t\t\trecursive: recursive || false,\n\t\t};\n\t\treturn this.eventBufferer.bufferEvents(() =>\n\t\t\tthis._setCollapseState(location, update),\n\t\t);\n\t}\n\n\tprivate _setCollapseState(\n\t\tlocation: number[],\n\t\tupdate: CollapseStateUpdate,\n\t): boolean {\n\t\tconst { node, listIndex, revealed } =\n\t\t\tthis.getTreeNodeWithListIndex(location);\n\n\t\tconst result = this._setListNodeCollapseState(\n\t\t\tnode,\n\t\t\tlistIndex,\n\t\t\trevealed,\n\t\t\tupdate,\n\t\t);\n\n\t\tif (\n\t\t\tnode !== this.root &&\n\t\t\tthis.autoExpandSingleChildren &&\n\t\t\tresult &&\n\t\t\t!isCollapsibleStateUpdate(update) &&\n\t\t\tnode.collapsible &&\n\t\t\t!node.collapsed &&\n\t\t\t!update.recursive\n\t\t) {\n\t\t\tlet onlyVisibleChildIndex = -1;\n\n\t\t\tfor (let i = 0; i < node.children.length; i++) {\n\t\t\t\tconst child = node.children[i];\n\n\t\t\t\tif (child.visible) {\n\t\t\t\t\tif (onlyVisibleChildIndex > -1) {\n\t\t\t\t\t\tonlyVisibleChildIndex = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tonlyVisibleChildIndex = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (onlyVisibleChildIndex > -1) {\n\t\t\t\tthis._setCollapseState(\n\t\t\t\t\t[...location, onlyVisibleChildIndex],\n\t\t\t\t\tupdate,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate _setListNodeCollapseState(\n\t\tnode: IIndexTreeNode<T, TFilterData>,\n\t\tlistIndex: number,\n\t\trevealed: boolean,\n\t\tupdate: CollapseStateUpdate,\n\t): boolean {\n\t\tconst result = this._setNodeCollapseState(node, update, false);\n\n\t\tif (!revealed || !node.visible || !result) {\n\t\t\treturn result;\n\t\t}\n\n\t\tconst previousRenderNodeCount = node.renderNodeCount;\n\t\tconst toInsert = this.updateNodeAfterCollapseChange(node);\n\t\tconst deleteCount =\n\t\t\tpreviousRenderNodeCount - (listIndex === -1 ? 0 : 1);\n\t\tthis._onDidSpliceRenderedNodes.fire({\n\t\t\tstart: listIndex + 1,\n\t\t\tdeleteCount: deleteCount,\n\t\t\telements: toInsert.slice(1),\n\t\t});\n\n\t\treturn result;\n\t}\n\n\tprivate _setNodeCollapseState(\n\t\tnode: IIndexTreeNode<T, TFilterData>,\n\t\tupdate: CollapseStateUpdate,\n\t\tdeep: boolean,\n\t): boolean {\n\t\tlet result: boolean;\n\n\t\tif (node === this.root) {\n\t\t\tresult = false;\n\t\t} else {\n\t\t\tif (isCollapsibleStateUpdate(update)) {\n\t\t\t\tresult = node.collapsible !== update.collapsible;\n\t\t\t\tnode.collapsible = update.collapsible;\n\t\t\t} else if (node.collapsible) {\n\t\t\t\tresult = node.collapsed !== update.collapsed;\n\t\t\t\tnode.collapsed = update.collapsed;\n\t\t\t} else {\n\t\t\t\tresult = false;\n\t\t\t}\n\n\t\t\tif (result) {\n\t\t\t\tthis._onDidChangeCollapseState.fire({ node, deep });\n\t\t\t}\n\t\t}\n\n\t\tif (!isCollapsibleStateUpdate(update) && update.recursive) {\n\t\t\tfor (const child of node.children) {\n\t\t\t\tresult =\n\t\t\t\t\tthis._setNodeCollapseState(child, update, true) || result;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\texpandTo(location: number[]): void {\n\t\tthis.eventBufferer.bufferEvents(() => {\n\t\t\tlet node = this.getTreeNode(location);\n\n\t\t\twhile (node.parent) {\n\t\t\t\tnode = node.parent;\n\t\t\t\tlocation = location.slice(0, location.length - 1);\n\n\t\t\t\tif (node.collapsed) {\n\t\t\t\t\tthis._setCollapseState(location, {\n\t\t\t\t\t\tcollapsed: false,\n\t\t\t\t\t\trecursive: false,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\trefilter(): void {\n\t\tconst previousRenderNodeCount = this.root.renderNodeCount;\n\t\tconst toInsert = this.updateNodeAfterFilterChange(this.root);\n\t\tthis._onDidSpliceRenderedNodes.fire({\n\t\t\tstart: 0,\n\t\t\tdeleteCount: previousRenderNodeCount,\n\t\t\telements: toInsert,\n\t\t});\n\t\tthis.refilterDelayer.cancel();\n\t}\n\n\tprivate createTreeNode(\n\t\ttreeElement: ITreeElement<T>,\n\t\tparent: IIndexTreeNode<T, TFilterData>,\n\t\tparentVisibility: TreeVisibility,\n\t\trevealed: boolean,\n\t\ttreeListElements: ITreeNode<T, TFilterData>[],\n\t\tonDidCreateNode?: (node: ITreeNode<T, TFilterData>) => void,\n\t): IIndexTreeNode<T, TFilterData> {\n\t\tconst node: IIndexTreeNode<T, TFilterData> = {\n\t\t\tparent,\n\t\t\telement: treeElement.element,\n\t\t\tchildren: [],\n\t\t\tdepth: parent.depth + 1,\n\t\t\tvisibleChildrenCount: 0,\n\t\t\tvisibleChildIndex: -1,\n\t\t\tcollapsible:\n\t\t\t\ttypeof treeElement.collapsible === \"boolean\"\n\t\t\t\t\t? treeElement.collapsible\n\t\t\t\t\t: typeof treeElement.collapsed !== \"undefined\",\n\t\t\tcollapsed:\n\t\t\t\ttypeof treeElement.collapsed === \"undefined\"\n\t\t\t\t\t? this.collapseByDefault\n\t\t\t\t\t: treeElement.collapsed,\n\t\t\trenderNodeCount: 1,\n\t\t\tvisibility: TreeVisibility.Visible,\n\t\t\tvisible: true,\n\t\t\tfilterData: undefined,\n\t\t};\n\n\t\tconst visibility = this._filterNode(node, parentVisibility);\n\t\tnode.visibility = visibility;\n\n\t\tif (revealed) {\n\t\t\ttreeListElements.push(node);\n\t\t}\n\n\t\tconst childElements = treeElement.children || Iterable.empty();\n\t\tconst childRevealed =\n\t\t\trevealed && visibility !== TreeVisibility.Hidden && !node.collapsed;\n\n\t\tlet visibleChildrenCount = 0;\n\t\tlet renderNodeCount = 1;\n\n\t\tfor (const el of childElements) {\n\t\t\tconst child = this.createTreeNode(\n\t\t\t\tel,\n\t\t\t\tnode,\n\t\t\t\tvisibility,\n\t\t\t\tchildRevealed,\n\t\t\t\ttreeListElements,\n\t\t\t\tonDidCreateNode,\n\t\t\t);\n\t\t\tnode.children.push(child);\n\t\t\trenderNodeCount += child.renderNodeCount;\n\n\t\t\tif (child.visible) {\n\t\t\t\tchild.visibleChildIndex = visibleChildrenCount++;\n\t\t\t}\n\t\t}\n\n\t\tif (!this.allowNonCollapsibleParents) {\n\t\t\tnode.collapsible = node.collapsible || node.children.length > 0;\n\t\t}\n\n\t\tnode.visibleChildrenCount = visibleChildrenCount;\n\t\tnode.visible =\n\t\t\tvisibility === TreeVisibility.Recurse\n\t\t\t\t? visibleChildrenCount > 0\n\t\t\t\t: visibility === TreeVisibility.Visible;\n\n\t\tif (!node.visible) {\n\t\t\tnode.renderNodeCount = 0;\n\n\t\t\tif (revealed) {\n\t\t\t\ttreeListElements.pop();\n\t\t\t}\n\t\t} else if (!node.collapsed) {\n\t\t\tnode.renderNodeCount = renderNodeCount;\n\t\t}\n\n\t\tonDidCreateNode?.(node);\n\n\t\treturn node;\n\t}\n\n\tprivate updateNodeAfterCollapseChange(\n\t\tnode: IIndexTreeNode<T, TFilterData>,\n\t): ITreeNode<T, TFilterData>[] {\n\t\tconst previousRenderNodeCount = node.renderNodeCount;\n\t\tconst result: ITreeNode<T, TFilterData>[] = [];\n\n\t\tthis._updateNodeAfterCollapseChange(node, result);\n\t\tthis._updateAncestorsRenderNodeCount(\n\t\t\tnode.parent,\n\t\t\tresult.length - previousRenderNodeCount,\n\t\t);\n\n\t\treturn result;\n\t}\n\n\tprivate _updateNodeAfterCollapseChange(\n\t\tnode: IIndexTreeNode<T, TFilterData>,\n\t\tresult: ITreeNode<T, TFilterData>[],\n\t): number {\n\t\tif (node.visible === false) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tresult.push(node);\n\t\tnode.renderNodeCount = 1;\n\n\t\tif (!node.collapsed) {\n\t\t\tfor (const child of node.children) {\n\t\t\t\tnode.renderNodeCount += this._updateNodeAfterCollapseChange(\n\t\t\t\t\tchild,\n\t\t\t\t\tresult,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tthis._onDidChangeRenderNodeCount.fire(node);\n\t\treturn node.renderNodeCount;\n\t}\n\n\tprivate updateNodeAfterFilterChange(\n\t\tnode: IIndexTreeNode<T, TFilterData>,\n\t): ITreeNode<T, TFilterData>[] {\n\t\tconst previousRenderNodeCount = node.renderNodeCount;\n\t\tconst result: ITreeNode<T, TFilterData>[] = [];\n\n\t\tthis._updateNodeAfterFilterChange(\n\t\t\tnode,\n\t\t\tnode.visible ? TreeVisibility.Visible : TreeVisibility.Hidden,\n\t\t\tresult,\n\t\t);\n\t\tthis._updateAncestorsRenderNodeCount(\n\t\t\tnode.parent,\n\t\t\tresult.length - previousRenderNodeCount,\n\t\t);\n\n\t\treturn result;\n\t}\n\n\tprivate _updateNodeAfterFilterChange(\n\t\tnode: IIndexTreeNode<T, TFilterData>,\n\t\tparentVisibility: TreeVisibility,\n\t\tresult: ITreeNode<T, TFilterData>[],\n\t\trevealed = true,\n\t): boolean {\n\t\tlet visibility: TreeVisibility;\n\n\t\tif (node !== this.root) {\n\t\t\tvisibility = this._filterNode(node, parentVisibility);\n\n\t\t\tif (visibility === TreeVisibility.Hidden) {\n\t\t\t\tnode.visible = false;\n\t\t\t\tnode.renderNodeCount = 0;\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (revealed) {\n\t\t\t\tresult.push(node);\n\t\t\t}\n\t\t}\n\n\t\tconst resultStartLength = result.length;\n\t\tnode.renderNodeCount = node === this.root ? 0 : 1;\n\n\t\tlet hasVisibleDescendants = false;\n\t\tif (!node.collapsed || visibility! !== TreeVisibility.Hidden) {\n\t\t\tlet visibleChildIndex = 0;\n\n\t\t\tfor (const child of node.children) {\n\t\t\t\thasVisibleDescendants =\n\t\t\t\t\tthis._updateNodeAfterFilterChange(\n\t\t\t\t\t\tchild,\n\t\t\t\t\t\tvisibility!,\n\t\t\t\t\t\tresult,\n\t\t\t\t\t\trevealed && !node.collapsed,\n\t\t\t\t\t) || hasVisibleDescendants;\n\n\t\t\t\tif (child.visible) {\n\t\t\t\t\tchild.visibleChildIndex = visibleChildIndex++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnode.visibleChildrenCount = visibleChildIndex;\n\t\t} else {\n\t\t\tnode.visibleChildrenCount = 0;\n\t\t}\n\n\t\tif (node !== this.root) {\n\t\t\tnode.visible =\n\t\t\t\tvisibility! === TreeVisibility.Recurse\n\t\t\t\t\t? hasVisibleDescendants\n\t\t\t\t\t: visibility! === TreeVisibility.Visible;\n\t\t\tnode.visibility = visibility!;\n\t\t}\n\n\t\tif (!node.visible) {\n\t\t\tnode.renderNodeCount = 0;\n\n\t\t\tif (revealed) {\n\t\t\t\tresult.pop();\n\t\t\t}\n\t\t} else if (!node.collapsed) {\n\t\t\tnode.renderNodeCount += result.length - resultStartLength;\n\t\t}\n\n\t\tthis._onDidChangeRenderNodeCount.fire(node);\n\t\treturn node.visible;\n\t}\n\n\tprivate _updateAncestorsRenderNodeCount(\n\t\tnode: IIndexTreeNode<T, TFilterData> | undefined,\n\t\tdiff: number,\n\t): void {\n\t\tif (diff === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\twhile (node) {\n\t\t\tnode.renderNodeCount += diff;\n\t\t\tthis._onDidChangeRenderNodeCount.fire(node);\n\t\t\tnode = node.parent;\n\t\t}\n\t}\n\n\tprivate _filterNode(\n\t\tnode: IIndexTreeNode<T, TFilterData>,\n\t\tparentVisibility: TreeVisibility,\n\t): TreeVisibility {\n\t\tconst result = this.filter\n\t\t\t? this.filter.filter(node.element, parentVisibility)\n\t\t\t: TreeVisibility.Visible;\n\n\t\tif (typeof result === \"boolean\") {\n\t\t\tnode.filterData = undefined;\n\t\t\treturn result ? TreeVisibility.Visible : TreeVisibility.Hidden;\n\t\t} else if (isFilterResult<TFilterData>(result)) {\n\t\t\tnode.filterData = result.data;\n\t\t\treturn getVisibleState(result.visibility);\n\t\t} else {\n\t\t\tnode.filterData = undefined;\n\t\t\treturn getVisibleState(result);\n\t\t}\n\t}\n\n\t// cheap\n\tprivate hasTreeNode(\n\t\tlocation: number[],\n\t\tnode: IIndexTreeNode<T, TFilterData> = this.root,\n\t): boolean {\n\t\tif (!location || location.length === 0) {\n\t\t\treturn true;\n\t\t}\n\n\t\tconst [index, ...rest] = location;\n\n\t\tif (index < 0 || index > node.children.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this.hasTreeNode(rest, node.children[index]);\n\t}\n\n\t// cheap\n\tprivate getTreeNode(\n\t\tlocation: number[],\n\t\tnode: IIndexTreeNode<T, TFilterData> = this.root,\n\t): IIndexTreeNode<T, TFilterData> {\n\t\tif (!location || location.length === 0) {\n\t\t\treturn node;\n\t\t}\n\n\t\tconst [index, ...rest] = location;\n\n\t\tif (index < 0 || index > node.children.length) {\n\t\t\tthrow new TreeError(this.user, \"Invalid tree location\");\n\t\t}\n\n\t\treturn this.getTreeNode(rest, node.children[index]);\n\t}\n\n\t// expensive\n\tprivate getTreeNodeWithListIndex(location: number[]): {\n\t\tnode: IIndexTreeNode<T, TFilterData>;\n\t\tlistIndex: number;\n\t\trevealed: boolean;\n\t\tvisible: boolean;\n\t} {\n\t\tif (location.length === 0) {\n\t\t\treturn {\n\t\t\t\tnode: this.root,\n\t\t\t\tlistIndex: -1,\n\t\t\t\trevealed: true,\n\t\t\t\tvisible: false,\n\t\t\t};\n\t\t}\n\n\t\tconst { parentNode, listIndex, revealed, visible } =\n\t\t\tthis.getParentNodeWithListIndex(location);\n\t\tconst index = location[location.length - 1];\n\n\t\tif (index < 0 || index > parentNode.children.length) {\n\t\t\tthrow new TreeError(this.user, \"Invalid tree location\");\n\t\t}\n\n\t\tconst node = parentNode.children[index];\n\n\t\treturn { node, listIndex, revealed, visible: visible && node.visible };\n\t}\n\n\tprivate getParentNodeWithListIndex(\n\t\tlocation: number[],\n\t\tnode: IIndexTreeNode<T, TFilterData> = this.root,\n\t\tlistIndex = 0,\n\t\trevealed = true,\n\t\tvisible = true,\n\t): {\n\t\tparentNode: IIndexTreeNode<T, TFilterData>;\n\t\tlistIndex: number;\n\t\trevealed: boolean;\n\t\tvisible: boolean;\n\t} {\n\t\tconst [index, ...rest] = location;\n\n\t\tif (index < 0 || index > node.children.length) {\n\t\t\tthrow new TreeError(this.user, \"Invalid tree location\");\n\t\t}\n\n\t\t// TODO@joao perf!\n\t\tfor (let i = 0; i < index; i++) {\n\t\t\tlistIndex += node.children[i].renderNodeCount;\n\t\t}\n\n\t\trevealed = revealed && !node.collapsed;\n\t\tvisible = visible && node.visible;\n\n\t\tif (rest.length === 0) {\n\t\t\treturn { parentNode: node, listIndex, revealed, visible };\n\t\t}\n\n\t\treturn this.getParentNodeWithListIndex(\n\t\t\trest,\n\t\t\tnode.children[index],\n\t\t\tlistIndex + 1,\n\t\t\trevealed,\n\t\t\tvisible,\n\t\t);\n\t}\n\n\tgetNode(location: number[] = []): ITreeNode<T, TFilterData> {\n\t\treturn this.getTreeNode(location);\n\t}\n\n\t// TODO@joao perf!\n\tgetNodeLocation(node: ITreeNode<T, TFilterData>): number[] {\n\t\tconst location: number[] = [];\n\t\tlet indexTreeNode = node as IIndexTreeNode<T, TFilterData>; // typing woes\n\n\t\twhile (indexTreeNode.parent) {\n\t\t\tlocation.push(indexTreeNode.parent.children.indexOf(indexTreeNode));\n\t\t\tindexTreeNode = indexTreeNode.parent;\n\t\t}\n\n\t\treturn location.reverse();\n\t}\n\n\tgetParentNodeLocation(location: number[]): number[] | undefined {\n\t\tif (location.length === 0) {\n\t\t\treturn undefined;\n\t\t} else if (location.length === 1) {\n\t\t\treturn [];\n\t\t} else {\n\t\t\treturn tail2(location)[0];\n\t\t}\n\t}\n\n\tgetFirstElementChild(location: number[]): T | undefined {\n\t\tconst node = this.getTreeNode(location);\n\n\t\tif (node.children.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn node.children[0].element;\n\t}\n\n\tgetLastElementAncestor(location: number[] = []): T | undefined {\n\t\tconst node = this.getTreeNode(location);\n\n\t\tif (node.children.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn this._getLastElementAncestor(node);\n\t}\n\n\tprivate _getLastElementAncestor(node: ITreeNode<T, TFilterData>): T {\n\t\tif (node.children.length === 0) {\n\t\t\treturn node.element;\n\t\t}\n\n\t\treturn this._getLastElementAncestor(\n\t\t\tnode.children[node.children.length - 1],\n\t\t);\n\t}\n}\n"],
  "mappings": "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",
  "names": ["node"]
}
