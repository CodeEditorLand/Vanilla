import"../../../../../vs/base/browser/ui/list/list.js";import{AbstractTree as u}from"../../../../../vs/base/browser/ui/tree/abstractTree.js";import"../../../../../vs/base/browser/ui/tree/indexTreeModel.js";import{ObjectTreeModel as h}from"../../../../../vs/base/browser/ui/tree/objectTreeModel.js";import{TreeError as a}from"../../../../../vs/base/browser/ui/tree/tree.js";import{Iterable as T}from"../../../../../vs/base/common/iterator.js";class A extends u{constructor(t,e,r,s,i,o={}){super(t,e,r,s,o);this.user=t;this.dataSource=i;this.identityProvider=o.identityProvider}input;identityProvider;nodesByIdentity=new Map;getInput(){return this.input}setInput(t,e){if(e&&!this.identityProvider)throw new a(this.user,"Can't restore tree view state without an identity provider");if(this.input=t,!t){this.nodesByIdentity.clear(),this.model.setChildren(null,T.empty());return}if(!e){this._refresh(t);return}const r=[],s=[],i=n=>{const d=this.identityProvider.getId(n).toString();return!e.expanded[d]},o=n=>{const d=this.identityProvider.getId(n.element).toString();e.focus.has(d)&&r.push(n.element),e.selection.has(d)&&s.push(n.element)};this._refresh(t,i,o),this.setFocus(r),this.setSelection(s),e&&typeof e.scrollTop=="number"&&(this.scrollTop=e.scrollTop)}updateChildren(t=this.input){if(typeof this.input>"u")throw new a(this.user,"Tree input not set");let e;this.identityProvider&&(e=r=>{const s=this.identityProvider.getId(r).toString(),i=this.nodesByIdentity.get(s);if(i)return i.collapsed}),this._refresh(t,e)}resort(t=this.input,e=!0){this.model.resort(t===this.input?null:t,e)}refresh(t){if(t===void 0){this.view.rerender();return}this.model.rerender(t)}_refresh(t,e,r){let s;if(this.identityProvider){const i=new Set,o=r;r=n=>{const d=this.identityProvider.getId(n.element).toString();i.add(d),this.nodesByIdentity.set(d,n),o?.(n)},s=n=>{const d=this.identityProvider.getId(n.element).toString();i.has(d)||this.nodesByIdentity.delete(d)}}this.model.setChildren(t===this.input?null:t,this.iterate(t,e).elements,{onDidCreateNode:r,onDidDeleteNode:s})}iterate(t,e){const r=[...this.dataSource.getChildren(t)];return{elements:T.map(r,i=>{const{elements:o,size:n}=this.iterate(i,e),d=this.dataSource.hasChildren?this.dataSource.hasChildren(i):void 0,l=n===0?void 0:e&&e(i);return{element:i,children:o,collapsible:d,collapsed:l}}),size:r.length}}createModel(t,e,r){return new h(t,e,r)}}export{A as DataTree};
