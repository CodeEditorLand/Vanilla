{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/browser/ui/grid/grid.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { equals, tail2 as tail } from \"../../../common/arrays.js\";\nimport type { Event } from \"../../../common/event.js\";\nimport { Disposable } from \"../../../common/lifecycle.js\";\nimport { type IBoundarySashes, Orientation } from \"../sash/sash.js\";\nimport \"./gridview.css\";\nimport type { AutoSizing as SplitViewAutoSizing } from \"../splitview/splitview.js\";\nimport {\n\ttype Box,\n\ttype GridLocation,\n\tGridView,\n\tSizing as GridViewSizing,\n\ttype IGridViewOptions,\n\ttype IGridViewStyles,\n\ttype IView as IGridViewView,\n\ttype IViewSize,\n\torthogonal,\n} from \"./gridview.js\";\n\nexport type { IViewSize };\nexport { LayoutPriority, Orientation, orthogonal } from \"./gridview.js\";\n\nexport enum Direction {\n\tUp = 0,\n\tDown = 1,\n\tLeft = 2,\n\tRight = 3,\n}\n\nfunction oppositeDirection(direction: Direction): Direction {\n\tswitch (direction) {\n\t\tcase Direction.Up:\n\t\t\treturn Direction.Down;\n\t\tcase Direction.Down:\n\t\t\treturn Direction.Up;\n\t\tcase Direction.Left:\n\t\t\treturn Direction.Right;\n\t\tcase Direction.Right:\n\t\t\treturn Direction.Left;\n\t}\n}\n\n/**\n * The interface to implement for views within a {@link Grid}.\n */\nexport interface IView extends IGridViewView {\n\t/**\n\t * The preferred width for when the user double clicks a sash\n\t * adjacent to this view.\n\t */\n\treadonly preferredWidth?: number;\n\n\t/**\n\t * The preferred height for when the user double clicks a sash\n\t * adjacent to this view.\n\t */\n\treadonly preferredHeight?: number;\n}\n\nexport interface GridLeafNode<T extends IView> {\n\treadonly view: T;\n\treadonly box: Box;\n\treadonly cachedVisibleSize: number | undefined;\n\treadonly maximized: boolean;\n}\n\nexport interface GridBranchNode<T extends IView> {\n\treadonly children: GridNode<T>[];\n\treadonly box: Box;\n}\n\nexport type GridNode<T extends IView> = GridLeafNode<T> | GridBranchNode<T>;\n\nexport function isGridBranchNode<T extends IView>(\n\tnode: GridNode<T>,\n): node is GridBranchNode<T> {\n\treturn !!(node as any).children;\n}\n\nfunction getGridNode<T extends IView>(\n\tnode: GridNode<T>,\n\tlocation: GridLocation,\n): GridNode<T> {\n\tif (location.length === 0) {\n\t\treturn node;\n\t}\n\n\tif (!isGridBranchNode(node)) {\n\t\tthrow new Error(\"Invalid location\");\n\t}\n\n\tconst [index, ...rest] = location;\n\treturn getGridNode(node.children[index], rest);\n}\n\ninterface Range {\n\treadonly start: number;\n\treadonly end: number;\n}\n\nfunction intersects(one: Range, other: Range): boolean {\n\treturn !(one.start >= other.end || other.start >= one.end);\n}\n\ninterface Boundary {\n\treadonly offset: number;\n\treadonly range: Range;\n}\n\nfunction getBoxBoundary(box: Box, direction: Direction): Boundary {\n\tconst orientation = getDirectionOrientation(direction);\n\tconst offset =\n\t\tdirection === Direction.Up\n\t\t\t? box.top\n\t\t\t: direction === Direction.Right\n\t\t\t\t? box.left + box.width\n\t\t\t\t: direction === Direction.Down\n\t\t\t\t\t? box.top + box.height\n\t\t\t\t\t: box.left;\n\n\tconst range = {\n\t\tstart: orientation === Orientation.HORIZONTAL ? box.top : box.left,\n\t\tend:\n\t\t\torientation === Orientation.HORIZONTAL\n\t\t\t\t? box.top + box.height\n\t\t\t\t: box.left + box.width,\n\t};\n\n\treturn { offset, range };\n}\n\nfunction findAdjacentBoxLeafNodes<T extends IView>(\n\tboxNode: GridNode<T>,\n\tdirection: Direction,\n\tboundary: Boundary,\n): GridLeafNode<T>[] {\n\tconst result: GridLeafNode<T>[] = [];\n\n\tfunction _(\n\t\tboxNode: GridNode<T>,\n\t\tdirection: Direction,\n\t\tboundary: Boundary,\n\t): void {\n\t\tif (isGridBranchNode(boxNode)) {\n\t\t\tfor (const child of boxNode.children) {\n\t\t\t\t_(child, direction, boundary);\n\t\t\t}\n\t\t} else {\n\t\t\tconst { offset, range } = getBoxBoundary(boxNode.box, direction);\n\n\t\t\tif (\n\t\t\t\toffset === boundary.offset &&\n\t\t\t\tintersects(range, boundary.range)\n\t\t\t) {\n\t\t\t\tresult.push(boxNode);\n\t\t\t}\n\t\t}\n\t}\n\n\t_(boxNode, direction, boundary);\n\treturn result;\n}\n\nfunction getLocationOrientation(\n\trootOrientation: Orientation,\n\tlocation: GridLocation,\n): Orientation {\n\treturn location.length % 2 === 0\n\t\t? orthogonal(rootOrientation)\n\t\t: rootOrientation;\n}\n\nfunction getDirectionOrientation(direction: Direction): Orientation {\n\treturn direction === Direction.Up || direction === Direction.Down\n\t\t? Orientation.VERTICAL\n\t\t: Orientation.HORIZONTAL;\n}\n\nexport function getRelativeLocation(\n\trootOrientation: Orientation,\n\tlocation: GridLocation,\n\tdirection: Direction,\n): GridLocation {\n\tconst orientation = getLocationOrientation(rootOrientation, location);\n\tconst directionOrientation = getDirectionOrientation(direction);\n\n\tif (orientation === directionOrientation) {\n\t\tlet [rest, index] = tail(location);\n\n\t\tif (direction === Direction.Right || direction === Direction.Down) {\n\t\t\tindex += 1;\n\t\t}\n\n\t\treturn [...rest, index];\n\t} else {\n\t\tconst index =\n\t\t\tdirection === Direction.Right || direction === Direction.Down\n\t\t\t\t? 1\n\t\t\t\t: 0;\n\t\treturn [...location, index];\n\t}\n}\n\nfunction indexInParent(element: HTMLElement): number {\n\tconst parentElement = element.parentElement;\n\n\tif (!parentElement) {\n\t\tthrow new Error(\"Invalid grid element\");\n\t}\n\n\tlet el = parentElement.firstElementChild;\n\tlet index = 0;\n\n\twhile (el !== element && el !== parentElement.lastElementChild && el) {\n\t\tel = el.nextElementSibling;\n\t\tindex++;\n\t}\n\n\treturn index;\n}\n\n/**\n * Find the grid location of a specific DOM element by traversing the parent\n * chain and finding each child index on the way.\n *\n * This will break as soon as DOM structures of the Splitview or Gridview change.\n */\nfunction getGridLocation(element: HTMLElement): GridLocation {\n\tconst parentElement = element.parentElement;\n\n\tif (!parentElement) {\n\t\tthrow new Error(\"Invalid grid element\");\n\t}\n\n\tif (/\\bmonaco-grid-view\\b/.test(parentElement.className)) {\n\t\treturn [];\n\t}\n\n\tconst index = indexInParent(parentElement);\n\tconst ancestor =\n\t\tparentElement.parentElement!.parentElement!.parentElement!\n\t\t\t.parentElement!;\n\treturn [...getGridLocation(ancestor), index];\n}\n\nexport type DistributeSizing = { type: \"distribute\" };\nexport type SplitSizing = { type: \"split\" };\nexport type AutoSizing = { type: \"auto\" };\nexport type InvisibleSizing = { type: \"invisible\"; cachedVisibleSize: number };\nexport type Sizing =\n\t| DistributeSizing\n\t| SplitSizing\n\t| AutoSizing\n\t| InvisibleSizing;\n\nexport namespace Sizing {\n\texport const Distribute: DistributeSizing = { type: \"distribute\" };\n\texport const Split: SplitSizing = { type: \"split\" };\n\texport const Auto: AutoSizing = { type: \"auto\" };\n\texport function Invisible(cachedVisibleSize: number): InvisibleSizing {\n\t\treturn { type: \"invisible\", cachedVisibleSize };\n\t}\n}\n\nexport interface IGridStyles extends IGridViewStyles {}\nexport interface IGridOptions extends IGridViewOptions {}\n\n/**\n * The {@link Grid} exposes a Grid widget in a friendlier API than the underlying\n * {@link GridView} widget. Namely, all mutation operations are addressed by the\n * model elements, rather than indexes.\n *\n * It support the same features as the {@link GridView}.\n */\nexport class Grid<T extends IView = IView> extends Disposable {\n\tprotected gridview: GridView;\n\tprivate views = new Map<T, HTMLElement>();\n\n\t/**\n\t * The orientation of the grid. Matches the orientation of the root\n\t * {@link SplitView} in the grid's {@link GridLocation} model.\n\t */\n\tget orientation(): Orientation {\n\t\treturn this.gridview.orientation;\n\t}\n\tset orientation(orientation: Orientation) {\n\t\tthis.gridview.orientation = orientation;\n\t}\n\n\t/**\n\t * The width of the grid.\n\t */\n\tget width(): number {\n\t\treturn this.gridview.width;\n\t}\n\n\t/**\n\t * The height of the grid.\n\t */\n\tget height(): number {\n\t\treturn this.gridview.height;\n\t}\n\n\t/**\n\t * The minimum width of the grid.\n\t */\n\tget minimumWidth(): number {\n\t\treturn this.gridview.minimumWidth;\n\t}\n\n\t/**\n\t * The minimum height of the grid.\n\t */\n\tget minimumHeight(): number {\n\t\treturn this.gridview.minimumHeight;\n\t}\n\n\t/**\n\t * The maximum width of the grid.\n\t */\n\tget maximumWidth(): number {\n\t\treturn this.gridview.maximumWidth;\n\t}\n\n\t/**\n\t * The maximum height of the grid.\n\t */\n\tget maximumHeight(): number {\n\t\treturn this.gridview.maximumHeight;\n\t}\n\n\t/**\n\t * Fires whenever a view within the grid changes its size constraints.\n\t */\n\treadonly onDidChange: Event<{ width: number; height: number } | undefined>;\n\n\t/**\n\t * Fires whenever the user scrolls a {@link SplitView} within\n\t * the grid.\n\t */\n\treadonly onDidScroll: Event<void>;\n\n\t/**\n\t * A collection of sashes perpendicular to each edge of the grid.\n\t * Corner sashes will be created for each intersection.\n\t */\n\tget boundarySashes(): IBoundarySashes {\n\t\treturn this.gridview.boundarySashes;\n\t}\n\tset boundarySashes(boundarySashes: IBoundarySashes) {\n\t\tthis.gridview.boundarySashes = boundarySashes;\n\t}\n\n\t/**\n\t * Enable/disable edge snapping across all grid views.\n\t */\n\tset edgeSnapping(edgeSnapping: boolean) {\n\t\tthis.gridview.edgeSnapping = edgeSnapping;\n\t}\n\n\t/**\n\t * The DOM element for this view.\n\t */\n\tget element(): HTMLElement {\n\t\treturn this.gridview.element;\n\t}\n\n\tprivate didLayout = false;\n\n\treadonly onDidChangeViewMaximized: Event<boolean>;\n\t/**\n\t * Create a new {@link Grid}. A grid must *always* have a view\n\t * inside.\n\t *\n\t * @param view An initial view for this Grid.\n\t */\n\tconstructor(view: T | GridView, options: IGridOptions = {}) {\n\t\tsuper();\n\n\t\tif (view instanceof GridView) {\n\t\t\tthis.gridview = view;\n\t\t\tthis.gridview.getViewMap(this.views);\n\t\t} else {\n\t\t\tthis.gridview = new GridView(options);\n\t\t}\n\n\t\tthis._register(this.gridview);\n\t\tthis._register(this.gridview.onDidSashReset(this.onDidSashReset, this));\n\n\t\tif (!(view instanceof GridView)) {\n\t\t\tthis._addView(view, 0, [0]);\n\t\t}\n\n\t\tthis.onDidChange = this.gridview.onDidChange;\n\t\tthis.onDidScroll = this.gridview.onDidScroll;\n\t\tthis.onDidChangeViewMaximized = this.gridview.onDidChangeViewMaximized;\n\t}\n\n\tstyle(styles: IGridStyles): void {\n\t\tthis.gridview.style(styles);\n\t}\n\n\t/**\n\t * Layout the {@link Grid}.\n\t *\n\t * Optionally provide a `top` and `left` positions, those will propagate\n\t * as an origin for positions passed to {@link IView.layout}.\n\t *\n\t * @param width The width of the {@link Grid}.\n\t * @param height The height of the {@link Grid}.\n\t * @param top Optional, the top location of the {@link Grid}.\n\t * @param left Optional, the left location of the {@link Grid}.\n\t */\n\tlayout(width: number, height: number, top = 0, left = 0): void {\n\t\tthis.gridview.layout(width, height, top, left);\n\t\tthis.didLayout = true;\n\t}\n\n\t/**\n\t * Add a {@link IView view} to this {@link Grid}, based on another reference view.\n\t *\n\t * Take this grid as an example:\n\t *\n\t * ```\n\t *  +-----+---------------+\n\t *  |  A  |      B        |\n\t *  +-----+---------+-----+\n\t *  |        C      |     |\n\t *  +---------------+  D  |\n\t *  |        E      |     |\n\t *  +---------------+-----+\n\t * ```\n\t *\n\t * Calling `addView(X, Sizing.Distribute, C, Direction.Right)` will make the following\n\t * changes:\n\t *\n\t * ```\n\t *  +-----+---------------+\n\t *  |  A  |      B        |\n\t *  +-----+-+-------+-----+\n\t *  |   C   |   X   |     |\n\t *  +-------+-------+  D  |\n\t *  |        E      |     |\n\t *  +---------------+-----+\n\t * ```\n\t *\n\t * Or `addView(X, Sizing.Distribute, D, Direction.Down)`:\n\t *\n\t * ```\n\t *  +-----+---------------+\n\t *  |  A  |      B        |\n\t *  +-----+---------+-----+\n\t *  |        C      |  D  |\n\t *  +---------------+-----+\n\t *  |        E      |  X  |\n\t *  +---------------+-----+\n\t * ```\n\t *\n\t * @param newView The view to add.\n\t * @param size Either a fixed size, or a dynamic {@link Sizing} strategy.\n\t * @param referenceView Another view to place this new view next to.\n\t * @param direction The direction the new view should be placed next to the reference view.\n\t */\n\taddView(\n\t\tnewView: T,\n\t\tsize: number | Sizing,\n\t\treferenceView: T,\n\t\tdirection: Direction,\n\t): void {\n\t\tif (this.views.has(newView)) {\n\t\t\tthrow new Error(\"Can't add same view twice\");\n\t\t}\n\n\t\tconst orientation = getDirectionOrientation(direction);\n\n\t\tif (this.views.size === 1 && this.orientation !== orientation) {\n\t\t\tthis.orientation = orientation;\n\t\t}\n\n\t\tconst referenceLocation = this.getViewLocation(referenceView);\n\t\tconst location = getRelativeLocation(\n\t\t\tthis.gridview.orientation,\n\t\t\treferenceLocation,\n\t\t\tdirection,\n\t\t);\n\n\t\tlet viewSize: number | GridViewSizing;\n\n\t\tif (typeof size === \"number\") {\n\t\t\tviewSize = size;\n\t\t} else if (size.type === \"split\") {\n\t\t\tconst [, index] = tail(referenceLocation);\n\t\t\tviewSize = GridViewSizing.Split(index);\n\t\t} else if (size.type === \"distribute\") {\n\t\t\tviewSize = GridViewSizing.Distribute;\n\t\t} else if (size.type === \"auto\") {\n\t\t\tconst [, index] = tail(referenceLocation);\n\t\t\tviewSize = GridViewSizing.Auto(index);\n\t\t} else {\n\t\t\tviewSize = size;\n\t\t}\n\n\t\tthis._addView(newView, viewSize, location);\n\t}\n\n\tprivate addViewAt(\n\t\tnewView: T,\n\t\tsize: number | DistributeSizing | InvisibleSizing,\n\t\tlocation: GridLocation,\n\t): void {\n\t\tif (this.views.has(newView)) {\n\t\t\tthrow new Error(\"Can't add same view twice\");\n\t\t}\n\n\t\tlet viewSize: number | GridViewSizing;\n\n\t\tif (typeof size === \"number\") {\n\t\t\tviewSize = size;\n\t\t} else if (size.type === \"distribute\") {\n\t\t\tviewSize = GridViewSizing.Distribute;\n\t\t} else {\n\t\t\tviewSize = size;\n\t\t}\n\n\t\tthis._addView(newView, viewSize, location);\n\t}\n\n\tprotected _addView(\n\t\tnewView: T,\n\t\tsize: number | GridViewSizing,\n\t\tlocation: GridLocation,\n\t): void {\n\t\tthis.views.set(newView, newView.element);\n\t\tthis.gridview.addView(newView, size, location);\n\t}\n\n\t/**\n\t * Remove a {@link IView view} from this {@link Grid}.\n\t *\n\t * @param view The {@link IView view} to remove.\n\t * @param sizing Whether to distribute other {@link IView view}'s sizes.\n\t */\n\tremoveView(view: T, sizing?: Sizing): void {\n\t\tif (this.views.size === 1) {\n\t\t\tthrow new Error(\"Can't remove last view\");\n\t\t}\n\n\t\tconst location = this.getViewLocation(view);\n\n\t\tlet gridViewSizing: DistributeSizing | SplitViewAutoSizing | undefined;\n\n\t\tif (sizing?.type === \"distribute\") {\n\t\t\tgridViewSizing = GridViewSizing.Distribute;\n\t\t} else if (sizing?.type === \"auto\") {\n\t\t\tconst index = location[location.length - 1];\n\t\t\tgridViewSizing = GridViewSizing.Auto(index === 0 ? 1 : index - 1);\n\t\t}\n\n\t\tthis.gridview.removeView(location, gridViewSizing);\n\t\tthis.views.delete(view);\n\t}\n\n\t/**\n\t * Move a {@link IView view} to another location in the grid.\n\t *\n\t * @remarks See {@link Grid.addView}.\n\t *\n\t * @param view The {@link IView view} to move.\n\t * @param sizing Either a fixed size, or a dynamic {@link Sizing} strategy.\n\t * @param referenceView Another view to place the view next to.\n\t * @param direction The direction the view should be placed next to the reference view.\n\t */\n\tmoveView(\n\t\tview: T,\n\t\tsizing: number | Sizing,\n\t\treferenceView: T,\n\t\tdirection: Direction,\n\t): void {\n\t\tconst sourceLocation = this.getViewLocation(view);\n\t\tconst [sourceParentLocation, from] = tail(sourceLocation);\n\n\t\tconst referenceLocation = this.getViewLocation(referenceView);\n\t\tconst targetLocation = getRelativeLocation(\n\t\t\tthis.gridview.orientation,\n\t\t\treferenceLocation,\n\t\t\tdirection,\n\t\t);\n\t\tconst [targetParentLocation, to] = tail(targetLocation);\n\n\t\tif (equals(sourceParentLocation, targetParentLocation)) {\n\t\t\tthis.gridview.moveView(sourceParentLocation, from, to);\n\t\t} else {\n\t\t\tthis.removeView(\n\t\t\t\tview,\n\t\t\t\ttypeof sizing === \"number\" ? undefined : sizing,\n\t\t\t);\n\t\t\tthis.addView(view, sizing, referenceView, direction);\n\t\t}\n\t}\n\n\t/**\n\t * Move a {@link IView view} to another location in the grid.\n\t *\n\t * @remarks Internal method, do not use without knowing what you're doing.\n\t * @remarks See {@link GridView.moveView}.\n\t *\n\t * @param view The {@link IView view} to move.\n\t * @param location The {@link GridLocation location} to insert the view on.\n\t */\n\tmoveViewTo(view: T, location: GridLocation): void {\n\t\tconst sourceLocation = this.getViewLocation(view);\n\t\tconst [sourceParentLocation, from] = tail(sourceLocation);\n\t\tconst [targetParentLocation, to] = tail(location);\n\n\t\tif (equals(sourceParentLocation, targetParentLocation)) {\n\t\t\tthis.gridview.moveView(sourceParentLocation, from, to);\n\t\t} else {\n\t\t\tconst size = this.getViewSize(view);\n\t\t\tconst orientation = getLocationOrientation(\n\t\t\t\tthis.gridview.orientation,\n\t\t\t\tsourceLocation,\n\t\t\t);\n\t\t\tconst cachedViewSize = this.getViewCachedVisibleSize(view);\n\t\t\tconst sizing =\n\t\t\t\ttypeof cachedViewSize === \"undefined\"\n\t\t\t\t\t? orientation === Orientation.HORIZONTAL\n\t\t\t\t\t\t? size.width\n\t\t\t\t\t\t: size.height\n\t\t\t\t\t: Sizing.Invisible(cachedViewSize);\n\n\t\t\tthis.removeView(view);\n\t\t\tthis.addViewAt(view, sizing, location);\n\t\t}\n\t}\n\n\t/**\n\t * Swap two {@link IView views} within the {@link Grid}.\n\t *\n\t * @param from One {@link IView view}.\n\t * @param to Another {@link IView view}.\n\t */\n\tswapViews(from: T, to: T): void {\n\t\tconst fromLocation = this.getViewLocation(from);\n\t\tconst toLocation = this.getViewLocation(to);\n\t\treturn this.gridview.swapViews(fromLocation, toLocation);\n\t}\n\n\t/**\n\t * Resize a {@link IView view}.\n\t *\n\t * @param view The {@link IView view} to resize.\n\t * @param size The size the view should be.\n\t */\n\tresizeView(view: T, size: IViewSize): void {\n\t\tconst location = this.getViewLocation(view);\n\t\treturn this.gridview.resizeView(location, size);\n\t}\n\n\t/**\n\t * Returns whether all other {@link IView views} are at their minimum size.\n\t *\n\t * @param view The reference {@link IView view}.\n\t */\n\tisViewExpanded(view: T): boolean {\n\t\tconst location = this.getViewLocation(view);\n\t\treturn this.gridview.isViewExpanded(location);\n\t}\n\n\t/**\n\t * Returns whether the {@link IView view} is maximized.\n\t *\n\t * @param view The reference {@link IView view}.\n\t */\n\tisViewMaximized(view: T): boolean {\n\t\tconst location = this.getViewLocation(view);\n\t\treturn this.gridview.isViewMaximized(location);\n\t}\n\n\t/**\n\t * Returns whether the {@link IView view} is maximized.\n\t *\n\t * @param view The reference {@link IView view}.\n\t */\n\thasMaximizedView(): boolean {\n\t\treturn this.gridview.hasMaximizedView();\n\t}\n\n\t/**\n\t * Get the size of a {@link IView view}.\n\t *\n\t * @param view The {@link IView view}. Provide `undefined` to get the size\n\t * of the grid itself.\n\t */\n\tgetViewSize(view?: T): IViewSize {\n\t\tif (!view) {\n\t\t\treturn this.gridview.getViewSize();\n\t\t}\n\n\t\tconst location = this.getViewLocation(view);\n\t\treturn this.gridview.getViewSize(location);\n\t}\n\n\t/**\n\t * Get the cached visible size of a {@link IView view}. This was the size\n\t * of the view at the moment it last became hidden.\n\t *\n\t * @param view The {@link IView view}.\n\t */\n\tgetViewCachedVisibleSize(view: T): number | undefined {\n\t\tconst location = this.getViewLocation(view);\n\t\treturn this.gridview.getViewCachedVisibleSize(location);\n\t}\n\n\t/**\n\t * Maximizes the specified view and hides all other views.\n\t * @param view The view to maximize.\n\t */\n\tmaximizeView(view: T) {\n\t\tif (this.views.size < 2) {\n\t\t\tthrow new Error(\n\t\t\t\t\"At least two views are required to maximize a view\",\n\t\t\t);\n\t\t}\n\t\tconst location = this.getViewLocation(view);\n\t\tthis.gridview.maximizeView(location);\n\t}\n\n\texitMaximizedView(): void {\n\t\tthis.gridview.exitMaximizedView();\n\t}\n\n\t/**\n\t * Expand the size of a {@link IView view} by collapsing all other views\n\t * to their minimum sizes.\n\t *\n\t * @param view The {@link IView view}.\n\t */\n\texpandView(view: T): void {\n\t\tconst location = this.getViewLocation(view);\n\t\tthis.gridview.expandView(location);\n\t}\n\n\t/**\n\t * Distribute the size among all {@link IView views} within the entire\n\t * grid or within a single {@link SplitView}.\n\t */\n\tdistributeViewSizes(): void {\n\t\tthis.gridview.distributeViewSizes();\n\t}\n\n\t/**\n\t * Returns whether a {@link IView view} is visible.\n\t *\n\t * @param view The {@link IView view}.\n\t */\n\tisViewVisible(view: T): boolean {\n\t\tconst location = this.getViewLocation(view);\n\t\treturn this.gridview.isViewVisible(location);\n\t}\n\n\t/**\n\t * Set the visibility state of a {@link IView view}.\n\t *\n\t * @param view The {@link IView view}.\n\t */\n\tsetViewVisible(view: T, visible: boolean): void {\n\t\tconst location = this.getViewLocation(view);\n\t\tthis.gridview.setViewVisible(location, visible);\n\t}\n\n\t/**\n\t * Returns a descriptor for the entire grid.\n\t */\n\tgetViews(): GridBranchNode<T> {\n\t\treturn this.gridview.getView() as GridBranchNode<T>;\n\t}\n\n\t/**\n\t * Utility method to return the collection all views which intersect\n\t * a view's edge.\n\t *\n\t * @param view The {@link IView view}.\n\t * @param direction Which direction edge to be considered.\n\t * @param wrap Whether the grid wraps around (from right to left, from bottom to top).\n\t */\n\tgetNeighborViews(view: T, direction: Direction, wrap = false): T[] {\n\t\tif (!this.didLayout) {\n\t\t\tthrow new Error(\"Can't call getNeighborViews before first layout\");\n\t\t}\n\n\t\tconst location = this.getViewLocation(view);\n\t\tconst root = this.getViews();\n\t\tconst node = getGridNode(root, location);\n\t\tlet boundary = getBoxBoundary(node.box, direction);\n\n\t\tif (wrap) {\n\t\t\tif (direction === Direction.Up && node.box.top === 0) {\n\t\t\t\tboundary = {\n\t\t\t\t\toffset: root.box.top + root.box.height,\n\t\t\t\t\trange: boundary.range,\n\t\t\t\t};\n\t\t\t} else if (\n\t\t\t\tdirection === Direction.Right &&\n\t\t\t\tnode.box.left + node.box.width === root.box.width\n\t\t\t) {\n\t\t\t\tboundary = { offset: 0, range: boundary.range };\n\t\t\t} else if (\n\t\t\t\tdirection === Direction.Down &&\n\t\t\t\tnode.box.top + node.box.height === root.box.height\n\t\t\t) {\n\t\t\t\tboundary = { offset: 0, range: boundary.range };\n\t\t\t} else if (direction === Direction.Left && node.box.left === 0) {\n\t\t\t\tboundary = {\n\t\t\t\t\toffset: root.box.left + root.box.width,\n\t\t\t\t\trange: boundary.range,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\treturn findAdjacentBoxLeafNodes(\n\t\t\troot,\n\t\t\toppositeDirection(direction),\n\t\t\tboundary,\n\t\t).map((node) => node.view);\n\t}\n\n\tprivate getViewLocation(view: T): GridLocation {\n\t\tconst element = this.views.get(view);\n\n\t\tif (!element) {\n\t\t\tthrow new Error(\"View not found\");\n\t\t}\n\n\t\treturn getGridLocation(element);\n\t}\n\n\tprivate onDidSashReset(location: GridLocation): void {\n\t\tconst resizeToPreferredSize = (location: GridLocation): boolean => {\n\t\t\tconst node = this.gridview.getView(location) as GridNode<T>;\n\n\t\t\tif (isGridBranchNode(node)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst direction = getLocationOrientation(\n\t\t\t\tthis.orientation,\n\t\t\t\tlocation,\n\t\t\t);\n\t\t\tconst size =\n\t\t\t\tdirection === Orientation.HORIZONTAL\n\t\t\t\t\t? node.view.preferredWidth\n\t\t\t\t\t: node.view.preferredHeight;\n\n\t\t\tif (typeof size !== \"number\") {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst viewSize =\n\t\t\t\tdirection === Orientation.HORIZONTAL\n\t\t\t\t\t? { width: Math.round(size) }\n\t\t\t\t\t: { height: Math.round(size) };\n\t\t\tthis.gridview.resizeView(location, viewSize);\n\t\t\treturn true;\n\t\t};\n\n\t\tif (resizeToPreferredSize(location)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst [parentLocation, index] = tail(location);\n\n\t\tif (resizeToPreferredSize([...parentLocation, index + 1])) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.gridview.distributeViewSizes(parentLocation);\n\t}\n}\n\nexport interface ISerializableView extends IView {\n\ttoJSON(): object;\n}\n\nexport interface IViewDeserializer<T extends ISerializableView> {\n\tfromJSON(json: any): T;\n}\n\nexport interface ISerializedLeafNode {\n\ttype: \"leaf\";\n\tdata: any;\n\tsize: number;\n\tvisible?: boolean;\n\tmaximized?: boolean;\n}\n\nexport interface ISerializedBranchNode {\n\ttype: \"branch\";\n\tdata: ISerializedNode[];\n\tsize: number;\n\tvisible?: boolean;\n}\n\nexport type ISerializedNode = ISerializedLeafNode | ISerializedBranchNode;\n\nexport interface ISerializedGrid {\n\troot: ISerializedNode;\n\torientation: Orientation;\n\twidth: number;\n\theight: number;\n}\n\n/**\n * A {@link Grid} which can serialize itself.\n */\nexport class SerializableGrid<T extends ISerializableView> extends Grid<T> {\n\tprivate static serializeNode<T extends ISerializableView>(\n\t\tnode: GridNode<T>,\n\t\torientation: Orientation,\n\t): ISerializedNode {\n\t\tconst size =\n\t\t\torientation === Orientation.VERTICAL\n\t\t\t\t? node.box.width\n\t\t\t\t: node.box.height;\n\n\t\tif (!isGridBranchNode(node)) {\n\t\t\tconst serializedLeafNode: ISerializedLeafNode = {\n\t\t\t\ttype: \"leaf\",\n\t\t\t\tdata: node.view.toJSON(),\n\t\t\t\tsize,\n\t\t\t};\n\n\t\t\tif (typeof node.cachedVisibleSize === \"number\") {\n\t\t\t\tserializedLeafNode.size = node.cachedVisibleSize;\n\t\t\t\tserializedLeafNode.visible = false;\n\t\t\t} else if (node.maximized) {\n\t\t\t\tserializedLeafNode.maximized = true;\n\t\t\t}\n\n\t\t\treturn serializedLeafNode;\n\t\t}\n\n\t\tconst data = node.children.map((c) =>\n\t\t\tSerializableGrid.serializeNode(c, orthogonal(orientation)),\n\t\t);\n\t\tif (data.some((c) => c.visible !== false)) {\n\t\t\treturn { type: \"branch\", data: data, size };\n\t\t}\n\t\treturn { type: \"branch\", data: data, size, visible: false };\n\t}\n\n\t/**\n\t * Construct a new {@link SerializableGrid} from a JSON object.\n\t *\n\t * @param json The JSON object.\n\t * @param deserializer A deserializer which can revive each view.\n\t * @returns A new {@link SerializableGrid} instance.\n\t */\n\tstatic deserialize<T extends ISerializableView>(\n\t\tjson: ISerializedGrid,\n\t\tdeserializer: IViewDeserializer<T>,\n\t\toptions: IGridOptions = {},\n\t): SerializableGrid<T> {\n\t\tif (typeof json.orientation !== \"number\") {\n\t\t\tthrow new Error(\n\t\t\t\t\"Invalid JSON: 'orientation' property must be a number.\",\n\t\t\t);\n\t\t} else if (typeof json.width !== \"number\") {\n\t\t\tthrow new Error(\"Invalid JSON: 'width' property must be a number.\");\n\t\t} else if (typeof json.height !== \"number\") {\n\t\t\tthrow new Error(\n\t\t\t\t\"Invalid JSON: 'height' property must be a number.\",\n\t\t\t);\n\t\t}\n\n\t\tconst gridview = GridView.deserialize(json, deserializer, options);\n\t\tconst result = new SerializableGrid<T>(gridview, options);\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Construct a new {@link SerializableGrid} from a grid descriptor.\n\t *\n\t * @param gridDescriptor A grid descriptor in which leaf nodes point to actual views.\n\t * @returns A new {@link SerializableGrid} instance.\n\t */\n\tstatic from<T extends ISerializableView>(\n\t\tgridDescriptor: GridDescriptor<T>,\n\t\toptions: IGridOptions = {},\n\t): SerializableGrid<T> {\n\t\treturn SerializableGrid.deserialize(\n\t\t\tcreateSerializedGrid(gridDescriptor),\n\t\t\t{ fromJSON: (view) => view },\n\t\t\toptions,\n\t\t);\n\t}\n\n\t/**\n\t * Useful information in order to proportionally restore view sizes\n\t * upon the very first layout call.\n\t */\n\tprivate initialLayoutContext = true;\n\n\t/**\n\t * Serialize this grid into a JSON object.\n\t */\n\tserialize(): ISerializedGrid {\n\t\treturn {\n\t\t\troot: SerializableGrid.serializeNode(\n\t\t\t\tthis.getViews(),\n\t\t\t\tthis.orientation,\n\t\t\t),\n\t\t\torientation: this.orientation,\n\t\t\twidth: this.width,\n\t\t\theight: this.height,\n\t\t};\n\t}\n\n\toverride layout(width: number, height: number, top = 0, left = 0): void {\n\t\tsuper.layout(width, height, top, left);\n\n\t\tif (this.initialLayoutContext) {\n\t\t\tthis.initialLayoutContext = false;\n\t\t\tthis.gridview.trySet2x2();\n\t\t}\n\t}\n}\n\nexport type GridLeafNodeDescriptor<T> = { size?: number; data?: any };\nexport type GridBranchNodeDescriptor<T> = {\n\tsize?: number;\n\tgroups: GridNodeDescriptor<T>[];\n};\nexport type GridNodeDescriptor<T> =\n\t| GridBranchNodeDescriptor<T>\n\t| GridLeafNodeDescriptor<T>;\nexport type GridDescriptor<T> = {\n\torientation: Orientation;\n} & GridBranchNodeDescriptor<T>;\n\nfunction isGridBranchNodeDescriptor<T>(\n\tnodeDescriptor: GridNodeDescriptor<T>,\n): nodeDescriptor is GridBranchNodeDescriptor<T> {\n\treturn !!(nodeDescriptor as GridBranchNodeDescriptor<T>).groups;\n}\n\nexport function sanitizeGridNodeDescriptor<T>(\n\tnodeDescriptor: GridNodeDescriptor<T>,\n\trootNode: boolean,\n): void {\n\tif (\n\t\t!rootNode &&\n\t\t(nodeDescriptor as any).groups &&\n\t\t(nodeDescriptor as any).groups.length <= 1\n\t) {\n\t\t(nodeDescriptor as any).groups = undefined;\n\t}\n\n\tif (!isGridBranchNodeDescriptor(nodeDescriptor)) {\n\t\treturn;\n\t}\n\n\tlet totalDefinedSize = 0;\n\tlet totalDefinedSizeCount = 0;\n\n\tfor (const child of nodeDescriptor.groups) {\n\t\tsanitizeGridNodeDescriptor(child, false);\n\n\t\tif (child.size) {\n\t\t\ttotalDefinedSize += child.size;\n\t\t\ttotalDefinedSizeCount++;\n\t\t}\n\t}\n\n\tconst totalUndefinedSize = totalDefinedSizeCount > 0 ? totalDefinedSize : 1;\n\tconst totalUndefinedSizeCount =\n\t\tnodeDescriptor.groups.length - totalDefinedSizeCount;\n\tconst eachUndefinedSize = totalUndefinedSize / totalUndefinedSizeCount;\n\n\tfor (const child of nodeDescriptor.groups) {\n\t\tif (!child.size) {\n\t\t\tchild.size = eachUndefinedSize;\n\t\t}\n\t}\n}\n\nfunction createSerializedNode<T>(\n\tnodeDescriptor: GridNodeDescriptor<T>,\n): ISerializedNode {\n\tif (isGridBranchNodeDescriptor(nodeDescriptor)) {\n\t\treturn {\n\t\t\ttype: \"branch\",\n\t\t\tdata: nodeDescriptor.groups.map((c) => createSerializedNode(c)),\n\t\t\tsize: nodeDescriptor.size!,\n\t\t};\n\t} else {\n\t\treturn {\n\t\t\ttype: \"leaf\",\n\t\t\tdata: nodeDescriptor.data,\n\t\t\tsize: nodeDescriptor.size!,\n\t\t};\n\t}\n}\n\nfunction getDimensions(\n\tnode: ISerializedNode,\n\torientation: Orientation,\n): { width?: number; height?: number } {\n\tif (node.type === \"branch\") {\n\t\tconst childrenDimensions = node.data.map((c) =>\n\t\t\tgetDimensions(c, orthogonal(orientation)),\n\t\t);\n\n\t\tif (orientation === Orientation.VERTICAL) {\n\t\t\tconst width =\n\t\t\t\tnode.size ||\n\t\t\t\t(childrenDimensions.length === 0\n\t\t\t\t\t? undefined\n\t\t\t\t\t: Math.max(...childrenDimensions.map((d) => d.width || 0)));\n\t\t\tconst height =\n\t\t\t\tchildrenDimensions.length === 0\n\t\t\t\t\t? undefined\n\t\t\t\t\t: childrenDimensions.reduce(\n\t\t\t\t\t\t\t(r, d) => r + (d.height || 0),\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t);\n\t\t\treturn { width, height };\n\t\t} else {\n\t\t\tconst width =\n\t\t\t\tchildrenDimensions.length === 0\n\t\t\t\t\t? undefined\n\t\t\t\t\t: childrenDimensions.reduce(\n\t\t\t\t\t\t\t(r, d) => r + (d.width || 0),\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t);\n\t\t\tconst height =\n\t\t\t\tnode.size ||\n\t\t\t\t(childrenDimensions.length === 0\n\t\t\t\t\t? undefined\n\t\t\t\t\t: Math.max(\n\t\t\t\t\t\t\t...childrenDimensions.map((d) => d.height || 0),\n\t\t\t\t\t\t));\n\t\t\treturn { width, height };\n\t\t}\n\t} else {\n\t\tconst width =\n\t\t\torientation === Orientation.VERTICAL ? node.size : undefined;\n\t\tconst height =\n\t\t\torientation === Orientation.VERTICAL ? undefined : node.size;\n\t\treturn { width, height };\n\t}\n}\n\n/**\n * Creates a new JSON object from a {@link GridDescriptor}, which can\n * be deserialized by {@link SerializableGrid.deserialize}.\n */\nexport function createSerializedGrid<T>(\n\tgridDescriptor: GridDescriptor<T>,\n): ISerializedGrid {\n\tsanitizeGridNodeDescriptor(gridDescriptor, true);\n\n\tconst root = createSerializedNode(gridDescriptor);\n\tconst { width, height } = getDimensions(root, gridDescriptor.orientation);\n\n\treturn {\n\t\troot,\n\t\torientation: gridDescriptor.orientation,\n\t\twidth: width || 1,\n\t\theight: height || 1,\n\t};\n}\n"],
  "mappings": "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",
  "names": ["Orientation", "orthogonal", "Direction", "boxNode", "direction", "boundary", "Sizing", "node", "location"]
}
