{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/browser/ui/scrollbar/scrollbarState.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * The minimal size of the slider (such that it can still be clickable) -- it is artificially enlarged.\n */\nconst MINIMUM_SLIDER_SIZE = 20;\n\nexport class ScrollbarState {\n\n\t/**\n\t * For the vertical scrollbar: the width.\n\t * For the horizontal scrollbar: the height.\n\t */\n\tprivate _scrollbarSize: number;\n\n\t/**\n\t * For the vertical scrollbar: the height of the pair horizontal scrollbar.\n\t * For the horizontal scrollbar: the width of the pair vertical scrollbar.\n\t */\n\tprivate _oppositeScrollbarSize: number;\n\n\t/**\n\t * For the vertical scrollbar: the height of the scrollbar's arrows.\n\t * For the horizontal scrollbar: the width of the scrollbar's arrows.\n\t */\n\tprivate readonly _arrowSize: number;\n\n\t// --- variables\n\t/**\n\t * For the vertical scrollbar: the viewport height.\n\t * For the horizontal scrollbar: the viewport width.\n\t */\n\tprivate _visibleSize: number;\n\n\t/**\n\t * For the vertical scrollbar: the scroll height.\n\t * For the horizontal scrollbar: the scroll width.\n\t */\n\tprivate _scrollSize: number;\n\n\t/**\n\t * For the vertical scrollbar: the scroll top.\n\t * For the horizontal scrollbar: the scroll left.\n\t */\n\tprivate _scrollPosition: number;\n\n\t// --- computed variables\n\n\t/**\n\t * `visibleSize` - `oppositeScrollbarSize`\n\t */\n\tprivate _computedAvailableSize: number;\n\t/**\n\t * (`scrollSize` > 0 && `scrollSize` > `visibleSize`)\n\t */\n\tprivate _computedIsNeeded: boolean;\n\n\tprivate _computedSliderSize: number;\n\tprivate _computedSliderRatio: number;\n\tprivate _computedSliderPosition: number;\n\n\tconstructor(arrowSize: number, scrollbarSize: number, oppositeScrollbarSize: number, visibleSize: number, scrollSize: number, scrollPosition: number) {\n\t\tthis._scrollbarSize = Math.round(scrollbarSize);\n\t\tthis._oppositeScrollbarSize = Math.round(oppositeScrollbarSize);\n\t\tthis._arrowSize = Math.round(arrowSize);\n\n\t\tthis._visibleSize = visibleSize;\n\t\tthis._scrollSize = scrollSize;\n\t\tthis._scrollPosition = scrollPosition;\n\n\t\tthis._computedAvailableSize = 0;\n\t\tthis._computedIsNeeded = false;\n\t\tthis._computedSliderSize = 0;\n\t\tthis._computedSliderRatio = 0;\n\t\tthis._computedSliderPosition = 0;\n\n\t\tthis._refreshComputedValues();\n\t}\n\n\tpublic clone(): ScrollbarState {\n\t\treturn new ScrollbarState(this._arrowSize, this._scrollbarSize, this._oppositeScrollbarSize, this._visibleSize, this._scrollSize, this._scrollPosition);\n\t}\n\n\tpublic setVisibleSize(visibleSize: number): boolean {\n\t\tconst iVisibleSize = Math.round(visibleSize);\n\t\tif (this._visibleSize !== iVisibleSize) {\n\t\t\tthis._visibleSize = iVisibleSize;\n\t\t\tthis._refreshComputedValues();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic setScrollSize(scrollSize: number): boolean {\n\t\tconst iScrollSize = Math.round(scrollSize);\n\t\tif (this._scrollSize !== iScrollSize) {\n\t\t\tthis._scrollSize = iScrollSize;\n\t\t\tthis._refreshComputedValues();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic setScrollPosition(scrollPosition: number): boolean {\n\t\tconst iScrollPosition = Math.round(scrollPosition);\n\t\tif (this._scrollPosition !== iScrollPosition) {\n\t\t\tthis._scrollPosition = iScrollPosition;\n\t\t\tthis._refreshComputedValues();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic setScrollbarSize(scrollbarSize: number): void {\n\t\tthis._scrollbarSize = Math.round(scrollbarSize);\n\t}\n\n\tpublic setOppositeScrollbarSize(oppositeScrollbarSize: number): void {\n\t\tthis._oppositeScrollbarSize = Math.round(oppositeScrollbarSize);\n\t}\n\n\tprivate static _computeValues(oppositeScrollbarSize: number, arrowSize: number, visibleSize: number, scrollSize: number, scrollPosition: number) {\n\t\tconst computedAvailableSize = Math.max(0, visibleSize - oppositeScrollbarSize);\n\t\tconst computedRepresentableSize = Math.max(0, computedAvailableSize - 2 * arrowSize);\n\t\tconst computedIsNeeded = (scrollSize > 0 && scrollSize > visibleSize);\n\n\t\tif (!computedIsNeeded) {\n\t\t\t// There is no need for a slider\n\t\t\treturn {\n\t\t\t\tcomputedAvailableSize: Math.round(computedAvailableSize),\n\t\t\t\tcomputedIsNeeded: computedIsNeeded,\n\t\t\t\tcomputedSliderSize: Math.round(computedRepresentableSize),\n\t\t\t\tcomputedSliderRatio: 0,\n\t\t\t\tcomputedSliderPosition: 0,\n\t\t\t};\n\t\t}\n\n\t\t// We must artificially increase the size of the slider if needed, since the slider would be too small to grab with the mouse otherwise\n\t\tconst computedSliderSize = Math.round(Math.max(MINIMUM_SLIDER_SIZE, Math.floor(visibleSize * computedRepresentableSize / scrollSize)));\n\n\t\t// The slider can move from 0 to `computedRepresentableSize` - `computedSliderSize`\n\t\t// in the same way `scrollPosition` can move from 0 to `scrollSize` - `visibleSize`.\n\t\tconst computedSliderRatio = (computedRepresentableSize - computedSliderSize) / (scrollSize - visibleSize);\n\t\tconst computedSliderPosition = (scrollPosition * computedSliderRatio);\n\n\t\treturn {\n\t\t\tcomputedAvailableSize: Math.round(computedAvailableSize),\n\t\t\tcomputedIsNeeded: computedIsNeeded,\n\t\t\tcomputedSliderSize: Math.round(computedSliderSize),\n\t\t\tcomputedSliderRatio: computedSliderRatio,\n\t\t\tcomputedSliderPosition: Math.round(computedSliderPosition),\n\t\t};\n\t}\n\n\tprivate _refreshComputedValues(): void {\n\t\tconst r = ScrollbarState._computeValues(this._oppositeScrollbarSize, this._arrowSize, this._visibleSize, this._scrollSize, this._scrollPosition);\n\t\tthis._computedAvailableSize = r.computedAvailableSize;\n\t\tthis._computedIsNeeded = r.computedIsNeeded;\n\t\tthis._computedSliderSize = r.computedSliderSize;\n\t\tthis._computedSliderRatio = r.computedSliderRatio;\n\t\tthis._computedSliderPosition = r.computedSliderPosition;\n\t}\n\n\tpublic getArrowSize(): number {\n\t\treturn this._arrowSize;\n\t}\n\n\tpublic getScrollPosition(): number {\n\t\treturn this._scrollPosition;\n\t}\n\n\tpublic getRectangleLargeSize(): number {\n\t\treturn this._computedAvailableSize;\n\t}\n\n\tpublic getRectangleSmallSize(): number {\n\t\treturn this._scrollbarSize;\n\t}\n\n\tpublic isNeeded(): boolean {\n\t\treturn this._computedIsNeeded;\n\t}\n\n\tpublic getSliderSize(): number {\n\t\treturn this._computedSliderSize;\n\t}\n\n\tpublic getSliderPosition(): number {\n\t\treturn this._computedSliderPosition;\n\t}\n\n\t/**\n\t * Compute a desired `scrollPosition` such that `offset` ends up in the center of the slider.\n\t * `offset` is based on the same coordinate system as the `sliderPosition`.\n\t */\n\tpublic getDesiredScrollPositionFromOffset(offset: number): number {\n\t\tif (!this._computedIsNeeded) {\n\t\t\t// no need for a slider\n\t\t\treturn 0;\n\t\t}\n\n\t\tconst desiredSliderPosition = offset - this._arrowSize - this._computedSliderSize / 2;\n\t\treturn Math.round(desiredSliderPosition / this._computedSliderRatio);\n\t}\n\n\t/**\n\t * Compute a desired `scrollPosition` from if offset is before or after the slider position.\n\t * If offset is before slider, treat as a page up (or left).  If after, page down (or right).\n\t * `offset` and `_computedSliderPosition` are based on the same coordinate system.\n\t * `_visibleSize` corresponds to a \"page\" of lines in the returned coordinate system.\n\t */\n\tpublic getDesiredScrollPositionFromOffsetPaged(offset: number): number {\n\t\tif (!this._computedIsNeeded) {\n\t\t\t// no need for a slider\n\t\t\treturn 0;\n\t\t}\n\n\t\tconst correctedOffset = offset - this._arrowSize;  // compensate if has arrows\n\t\tlet desiredScrollPosition = this._scrollPosition;\n\t\tif (correctedOffset < this._computedSliderPosition) {\n\t\t\tdesiredScrollPosition -= this._visibleSize;  // page up/left\n\t\t} else {\n\t\t\tdesiredScrollPosition += this._visibleSize;  // page down/right\n\t\t}\n\t\treturn desiredScrollPosition;\n\t}\n\n\t/**\n\t * Compute a desired `scrollPosition` such that the slider moves by `delta`.\n\t */\n\tpublic getDesiredScrollPositionFromDelta(delta: number): number {\n\t\tif (!this._computedIsNeeded) {\n\t\t\t// no need for a slider\n\t\t\treturn 0;\n\t\t}\n\n\t\tconst desiredSliderPosition = this._computedSliderPosition + delta;\n\t\treturn Math.round(desiredSliderPosition / this._computedSliderRatio);\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
