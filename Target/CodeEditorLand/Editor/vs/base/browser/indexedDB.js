import{toErrorMessage as D}from"../common/errorMessage.js";import{ErrorNoTelemetry as d,getErrorMessage as h}from"../common/errors.js";import{mark as l}from"../common/performance.js";class u extends Error{constructor(s){super("Missing stores");this.db=s}}class b extends Error{code="DBClosed";constructor(e){super(`IndexedDB database '${e}' is closed.`)}}class c{constructor(e,s){this.name=s;this.database=e}static async create(e,s,n){const r=await c.openDatabase(e,s,n);return new c(r,e)}static async openDatabase(e,s,n){l(`code/willOpenDatabase/${e}`);try{return await c.doOpenDatabase(e,s,n)}catch(r){if(r instanceof u){console.info("Attempting to recreate the IndexedDB once.",e);try{await c.deleteDatabase(r.db)}catch(o){throw console.error("Error while deleting the IndexedDB",h(o)),o}return await c.doOpenDatabase(e,s,n)}throw r}finally{l(`code/didOpenDatabase/${e}`)}}static doOpenDatabase(e,s,n){return new Promise((r,o)=>{const a=indexedDB.open(e,s);a.onerror=()=>o(a.error),a.onsuccess=()=>{const t=a.result;for(const i of n)if(!t.objectStoreNames.contains(i)){console.error(`Error while opening IndexedDB. Could not find '${i}'' object store`),o(new u(t));return}r(t)},a.onupgradeneeded=()=>{const t=a.result;for(const i of n)t.objectStoreNames.contains(i)||t.createObjectStore(i)}})}static deleteDatabase(e){return new Promise((s,n)=>{e.close();const r=indexedDB.deleteDatabase(e.name);r.onerror=o=>n(r.error),r.onsuccess=()=>s()})}database=null;pendingTransactions=[];hasPendingTransactions(){return this.pendingTransactions.length>0}close(){this.pendingTransactions.length&&this.pendingTransactions.splice(0,this.pendingTransactions.length).forEach(e=>e.abort()),this.database?.close(),this.database=null}async runInTransaction(e,s,n){if(!this.database)throw new b(this.name);const r=this.database.transaction(e,s);return this.pendingTransactions.push(r),new Promise((o,a)=>{r.oncomplete=()=>{Array.isArray(t)?o(t.map(i=>i.result)):o(t.result)},r.onerror=()=>a(r.error?d.fromError(r.error):new d("unknown error")),r.onabort=()=>a(r.error?d.fromError(r.error):new d("unknown error"));const t=n(r.objectStore(e))}).finally(()=>this.pendingTransactions.splice(this.pendingTransactions.indexOf(r),1))}async getKeyValues(e,s){if(!this.database)throw new b(this.name);const n=this.database.transaction(e,"readonly");return this.pendingTransactions.push(n),new Promise(r=>{const o=new Map,t=n.objectStore(e).openCursor();if(!t)return r(o);t.onsuccess=()=>{t.result?(s(t.result.value)&&o.set(t.result.key.toString(),t.result.value),t.result.continue()):r(o)};const i=g=>{console.error(`IndexedDB getKeyValues(): ${D(g,!0)}`),r(o)};t.onerror=()=>i(t.error),n.onerror=()=>i(n.error)}).finally(()=>this.pendingTransactions.splice(this.pendingTransactions.indexOf(n),1))}}export{b as DBClosedError,c as IndexedDB};
