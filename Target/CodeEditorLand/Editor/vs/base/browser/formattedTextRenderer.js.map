{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/browser/formattedTextRenderer.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as DOM from './dom.js';\nimport { IKeyboardEvent } from './keyboardEvent.js';\nimport { IMouseEvent } from './mouseEvent.js';\nimport { DisposableStore } from '../common/lifecycle.js';\n\nexport interface IContentActionHandler {\n\tcallback: (content: string, event: IMouseEvent | IKeyboardEvent) => void;\n\treadonly disposables: DisposableStore;\n}\n\nexport interface FormattedTextRenderOptions {\n\treadonly className?: string;\n\treadonly inline?: boolean;\n\treadonly actionHandler?: IContentActionHandler;\n\treadonly renderCodeSegments?: boolean;\n}\n\nexport function renderText(text: string, options: FormattedTextRenderOptions = {}): HTMLElement {\n\tconst element = createElement(options);\n\telement.textContent = text;\n\treturn element;\n}\n\nexport function renderFormattedText(formattedText: string, options: FormattedTextRenderOptions = {}): HTMLElement {\n\tconst element = createElement(options);\n\t_renderFormattedText(element, parseFormattedText(formattedText, !!options.renderCodeSegments), options.actionHandler, options.renderCodeSegments);\n\treturn element;\n}\n\nexport function createElement(options: FormattedTextRenderOptions): HTMLElement {\n\tconst tagName = options.inline ? 'span' : 'div';\n\tconst element = document.createElement(tagName);\n\tif (options.className) {\n\t\telement.className = options.className;\n\t}\n\treturn element;\n}\n\nclass StringStream {\n\tprivate source: string;\n\tprivate index: number;\n\n\tconstructor(source: string) {\n\t\tthis.source = source;\n\t\tthis.index = 0;\n\t}\n\n\tpublic eos(): boolean {\n\t\treturn this.index >= this.source.length;\n\t}\n\n\tpublic next(): string {\n\t\tconst next = this.peek();\n\t\tthis.advance();\n\t\treturn next;\n\t}\n\n\tpublic peek(): string {\n\t\treturn this.source[this.index];\n\t}\n\n\tpublic advance(): void {\n\t\tthis.index++;\n\t}\n}\n\nconst enum FormatType {\n\tInvalid,\n\tRoot,\n\tText,\n\tBold,\n\tItalics,\n\tAction,\n\tActionClose,\n\tCode,\n\tNewLine\n}\n\ninterface IFormatParseTree {\n\ttype: FormatType;\n\tcontent?: string;\n\tindex?: number;\n\tchildren?: IFormatParseTree[];\n}\n\nfunction _renderFormattedText(element: Node, treeNode: IFormatParseTree, actionHandler?: IContentActionHandler, renderCodeSegments?: boolean) {\n\tlet child: Node | undefined;\n\n\tif (treeNode.type === FormatType.Text) {\n\t\tchild = document.createTextNode(treeNode.content || '');\n\t} else if (treeNode.type === FormatType.Bold) {\n\t\tchild = document.createElement('b');\n\t} else if (treeNode.type === FormatType.Italics) {\n\t\tchild = document.createElement('i');\n\t} else if (treeNode.type === FormatType.Code && renderCodeSegments) {\n\t\tchild = document.createElement('code');\n\t} else if (treeNode.type === FormatType.Action && actionHandler) {\n\t\tconst a = document.createElement('a');\n\t\tactionHandler.disposables.add(DOM.addStandardDisposableListener(a, 'click', (event) => {\n\t\t\tactionHandler.callback(String(treeNode.index), event);\n\t\t}));\n\n\t\tchild = a;\n\t} else if (treeNode.type === FormatType.NewLine) {\n\t\tchild = document.createElement('br');\n\t} else if (treeNode.type === FormatType.Root) {\n\t\tchild = element;\n\t}\n\n\tif (child && element !== child) {\n\t\telement.appendChild(child);\n\t}\n\n\tif (child && Array.isArray(treeNode.children)) {\n\t\ttreeNode.children.forEach((nodeChild) => {\n\t\t\t_renderFormattedText(child, nodeChild, actionHandler, renderCodeSegments);\n\t\t});\n\t}\n}\n\nfunction parseFormattedText(content: string, parseCodeSegments: boolean): IFormatParseTree {\n\n\tconst root: IFormatParseTree = {\n\t\ttype: FormatType.Root,\n\t\tchildren: []\n\t};\n\n\tlet actionViewItemIndex = 0;\n\tlet current = root;\n\tconst stack: IFormatParseTree[] = [];\n\tconst stream = new StringStream(content);\n\n\twhile (!stream.eos()) {\n\t\tlet next = stream.next();\n\n\t\tconst isEscapedFormatType = (next === '\\\\' && formatTagType(stream.peek(), parseCodeSegments) !== FormatType.Invalid);\n\t\tif (isEscapedFormatType) {\n\t\t\tnext = stream.next(); // unread the backslash if it escapes a format tag type\n\t\t}\n\n\t\tif (!isEscapedFormatType && isFormatTag(next, parseCodeSegments) && next === stream.peek()) {\n\t\t\tstream.advance();\n\n\t\t\tif (current.type === FormatType.Text) {\n\t\t\t\tcurrent = stack.pop()!;\n\t\t\t}\n\n\t\t\tconst type = formatTagType(next, parseCodeSegments);\n\t\t\tif (current.type === type || (current.type === FormatType.Action && type === FormatType.ActionClose)) {\n\t\t\t\tcurrent = stack.pop()!;\n\t\t\t} else {\n\t\t\t\tconst newCurrent: IFormatParseTree = {\n\t\t\t\t\ttype: type,\n\t\t\t\t\tchildren: []\n\t\t\t\t};\n\n\t\t\t\tif (type === FormatType.Action) {\n\t\t\t\t\tnewCurrent.index = actionViewItemIndex;\n\t\t\t\t\tactionViewItemIndex++;\n\t\t\t\t}\n\n\t\t\t\tcurrent.children!.push(newCurrent);\n\t\t\t\tstack.push(current);\n\t\t\t\tcurrent = newCurrent;\n\t\t\t}\n\t\t} else if (next === '\\n') {\n\t\t\tif (current.type === FormatType.Text) {\n\t\t\t\tcurrent = stack.pop()!;\n\t\t\t}\n\n\t\t\tcurrent.children!.push({\n\t\t\t\ttype: FormatType.NewLine\n\t\t\t});\n\n\t\t} else {\n\t\t\tif (current.type !== FormatType.Text) {\n\t\t\t\tconst textCurrent: IFormatParseTree = {\n\t\t\t\t\ttype: FormatType.Text,\n\t\t\t\t\tcontent: next\n\t\t\t\t};\n\t\t\t\tcurrent.children!.push(textCurrent);\n\t\t\t\tstack.push(current);\n\t\t\t\tcurrent = textCurrent;\n\n\t\t\t} else {\n\t\t\t\tcurrent.content += next;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (current.type === FormatType.Text) {\n\t\tcurrent = stack.pop()!;\n\t}\n\n\tif (stack.length) {\n\t\t// incorrectly formatted string literal\n\t}\n\n\treturn root;\n}\n\nfunction isFormatTag(char: string, supportCodeSegments: boolean): boolean {\n\treturn formatTagType(char, supportCodeSegments) !== FormatType.Invalid;\n}\n\nfunction formatTagType(char: string, supportCodeSegments: boolean): FormatType {\n\tswitch (char) {\n\t\tcase '*':\n\t\t\treturn FormatType.Bold;\n\t\tcase '_':\n\t\t\treturn FormatType.Italics;\n\t\tcase '[':\n\t\t\treturn FormatType.Action;\n\t\tcase ']':\n\t\t\treturn FormatType.ActionClose;\n\t\tcase '`':\n\t\t\treturn supportCodeSegments ? FormatType.Code : FormatType.Invalid;\n\t\tdefault:\n\t\t\treturn FormatType.Invalid;\n\t}\n}\n"],
  "mappings": "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",
  "names": ["FormatType"]
}
