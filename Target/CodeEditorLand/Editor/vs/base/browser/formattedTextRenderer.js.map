{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/browser/formattedTextRenderer.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { DisposableStore } from \"../common/lifecycle.js\";\nimport * as DOM from \"./dom.js\";\nimport type { IKeyboardEvent } from \"./keyboardEvent.js\";\nimport type { IMouseEvent } from \"./mouseEvent.js\";\n\nexport interface IContentActionHandler {\n\tcallback: (content: string, event: IMouseEvent | IKeyboardEvent) => void;\n\treadonly disposables: DisposableStore;\n}\n\nexport interface FormattedTextRenderOptions {\n\treadonly className?: string;\n\treadonly inline?: boolean;\n\treadonly actionHandler?: IContentActionHandler;\n\treadonly renderCodeSegments?: boolean;\n}\n\nexport function renderText(\n\ttext: string,\n\toptions: FormattedTextRenderOptions = {},\n): HTMLElement {\n\tconst element = createElement(options);\n\telement.textContent = text;\n\treturn element;\n}\n\nexport function renderFormattedText(\n\tformattedText: string,\n\toptions: FormattedTextRenderOptions = {},\n): HTMLElement {\n\tconst element = createElement(options);\n\t_renderFormattedText(\n\t\telement,\n\t\tparseFormattedText(formattedText, !!options.renderCodeSegments),\n\t\toptions.actionHandler,\n\t\toptions.renderCodeSegments,\n\t);\n\treturn element;\n}\n\nexport function createElement(\n\toptions: FormattedTextRenderOptions,\n): HTMLElement {\n\tconst tagName = options.inline ? \"span\" : \"div\";\n\tconst element = document.createElement(tagName);\n\tif (options.className) {\n\t\telement.className = options.className;\n\t}\n\treturn element;\n}\n\nclass StringStream {\n\tprivate source: string;\n\tprivate index: number;\n\n\tconstructor(source: string) {\n\t\tthis.source = source;\n\t\tthis.index = 0;\n\t}\n\n\tpublic eos(): boolean {\n\t\treturn this.index >= this.source.length;\n\t}\n\n\tpublic next(): string {\n\t\tconst next = this.peek();\n\t\tthis.advance();\n\t\treturn next;\n\t}\n\n\tpublic peek(): string {\n\t\treturn this.source[this.index];\n\t}\n\n\tpublic advance(): void {\n\t\tthis.index++;\n\t}\n}\n\nenum FormatType {\n\tInvalid = 0,\n\tRoot = 1,\n\tText = 2,\n\tBold = 3,\n\tItalics = 4,\n\tAction = 5,\n\tActionClose = 6,\n\tCode = 7,\n\tNewLine = 8,\n}\n\ninterface IFormatParseTree {\n\ttype: FormatType;\n\tcontent?: string;\n\tindex?: number;\n\tchildren?: IFormatParseTree[];\n}\n\nfunction _renderFormattedText(\n\telement: Node,\n\ttreeNode: IFormatParseTree,\n\tactionHandler?: IContentActionHandler,\n\trenderCodeSegments?: boolean,\n) {\n\tlet child: Node | undefined;\n\n\tif (treeNode.type === FormatType.Text) {\n\t\tchild = document.createTextNode(treeNode.content || \"\");\n\t} else if (treeNode.type === FormatType.Bold) {\n\t\tchild = document.createElement(\"b\");\n\t} else if (treeNode.type === FormatType.Italics) {\n\t\tchild = document.createElement(\"i\");\n\t} else if (treeNode.type === FormatType.Code && renderCodeSegments) {\n\t\tchild = document.createElement(\"code\");\n\t} else if (treeNode.type === FormatType.Action && actionHandler) {\n\t\tconst a = document.createElement(\"a\");\n\t\tactionHandler.disposables.add(\n\t\t\tDOM.addStandardDisposableListener(a, \"click\", (event) => {\n\t\t\t\tactionHandler.callback(String(treeNode.index), event);\n\t\t\t}),\n\t\t);\n\n\t\tchild = a;\n\t} else if (treeNode.type === FormatType.NewLine) {\n\t\tchild = document.createElement(\"br\");\n\t} else if (treeNode.type === FormatType.Root) {\n\t\tchild = element;\n\t}\n\n\tif (child && element !== child) {\n\t\telement.appendChild(child);\n\t}\n\n\tif (child && Array.isArray(treeNode.children)) {\n\t\ttreeNode.children.forEach((nodeChild) => {\n\t\t\t_renderFormattedText(\n\t\t\t\tchild,\n\t\t\t\tnodeChild,\n\t\t\t\tactionHandler,\n\t\t\t\trenderCodeSegments,\n\t\t\t);\n\t\t});\n\t}\n}\n\nfunction parseFormattedText(\n\tcontent: string,\n\tparseCodeSegments: boolean,\n): IFormatParseTree {\n\tconst root: IFormatParseTree = {\n\t\ttype: FormatType.Root,\n\t\tchildren: [],\n\t};\n\n\tlet actionViewItemIndex = 0;\n\tlet current = root;\n\tconst stack: IFormatParseTree[] = [];\n\tconst stream = new StringStream(content);\n\n\twhile (!stream.eos()) {\n\t\tlet next = stream.next();\n\n\t\tconst isEscapedFormatType =\n\t\t\tnext === \"\\\\\" &&\n\t\t\tformatTagType(stream.peek(), parseCodeSegments) !==\n\t\t\t\tFormatType.Invalid;\n\t\tif (isEscapedFormatType) {\n\t\t\tnext = stream.next(); // unread the backslash if it escapes a format tag type\n\t\t}\n\n\t\tif (\n\t\t\t!isEscapedFormatType &&\n\t\t\tisFormatTag(next, parseCodeSegments) &&\n\t\t\tnext === stream.peek()\n\t\t) {\n\t\t\tstream.advance();\n\n\t\t\tif (current.type === FormatType.Text) {\n\t\t\t\tcurrent = stack.pop()!;\n\t\t\t}\n\n\t\t\tconst type = formatTagType(next, parseCodeSegments);\n\t\t\tif (\n\t\t\t\tcurrent.type === type ||\n\t\t\t\t(current.type === FormatType.Action &&\n\t\t\t\t\ttype === FormatType.ActionClose)\n\t\t\t) {\n\t\t\t\tcurrent = stack.pop()!;\n\t\t\t} else {\n\t\t\t\tconst newCurrent: IFormatParseTree = {\n\t\t\t\t\ttype: type,\n\t\t\t\t\tchildren: [],\n\t\t\t\t};\n\n\t\t\t\tif (type === FormatType.Action) {\n\t\t\t\t\tnewCurrent.index = actionViewItemIndex;\n\t\t\t\t\tactionViewItemIndex++;\n\t\t\t\t}\n\n\t\t\t\tcurrent.children!.push(newCurrent);\n\t\t\t\tstack.push(current);\n\t\t\t\tcurrent = newCurrent;\n\t\t\t}\n\t\t} else if (next === \"\\n\") {\n\t\t\tif (current.type === FormatType.Text) {\n\t\t\t\tcurrent = stack.pop()!;\n\t\t\t}\n\n\t\t\tcurrent.children!.push({\n\t\t\t\ttype: FormatType.NewLine,\n\t\t\t});\n\t\t} else if (current.type !== FormatType.Text) {\n\t\t\tconst textCurrent: IFormatParseTree = {\n\t\t\t\ttype: FormatType.Text,\n\t\t\t\tcontent: next,\n\t\t\t};\n\t\t\tcurrent.children!.push(textCurrent);\n\t\t\tstack.push(current);\n\t\t\tcurrent = textCurrent;\n\t\t} else {\n\t\t\tcurrent.content += next;\n\t\t}\n\t}\n\n\tif (current.type === FormatType.Text) {\n\t\tcurrent = stack.pop()!;\n\t}\n\n\tif (stack.length) {\n\t\t// incorrectly formatted string literal\n\t}\n\n\treturn root;\n}\n\nfunction isFormatTag(char: string, supportCodeSegments: boolean): boolean {\n\treturn formatTagType(char, supportCodeSegments) !== FormatType.Invalid;\n}\n\nfunction formatTagType(char: string, supportCodeSegments: boolean): FormatType {\n\tswitch (char) {\n\t\tcase \"*\":\n\t\t\treturn FormatType.Bold;\n\t\tcase \"_\":\n\t\t\treturn FormatType.Italics;\n\t\tcase \"[\":\n\t\t\treturn FormatType.Action;\n\t\tcase \"]\":\n\t\t\treturn FormatType.ActionClose;\n\t\tcase \"`\":\n\t\t\treturn supportCodeSegments ? FormatType.Code : FormatType.Invalid;\n\t\tdefault:\n\t\t\treturn FormatType.Invalid;\n\t}\n}\n"],
  "mappings": "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",
  "names": ["FormatType"]
}
