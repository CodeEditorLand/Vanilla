{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/json.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport const enum ScanError {\n\tNone = 0,\n\tUnexpectedEndOfComment = 1,\n\tUnexpectedEndOfString = 2,\n\tUnexpectedEndOfNumber = 3,\n\tInvalidUnicode = 4,\n\tInvalidEscapeCharacter = 5,\n\tInvalidCharacter = 6\n}\n\nexport const enum SyntaxKind {\n\tOpenBraceToken = 1,\n\tCloseBraceToken = 2,\n\tOpenBracketToken = 3,\n\tCloseBracketToken = 4,\n\tCommaToken = 5,\n\tColonToken = 6,\n\tNullKeyword = 7,\n\tTrueKeyword = 8,\n\tFalseKeyword = 9,\n\tStringLiteral = 10,\n\tNumericLiteral = 11,\n\tLineCommentTrivia = 12,\n\tBlockCommentTrivia = 13,\n\tLineBreakTrivia = 14,\n\tTrivia = 15,\n\tUnknown = 16,\n\tEOF = 17\n}\n\n/**\n * The scanner object, representing a JSON scanner at a position in the input string.\n */\nexport interface JSONScanner {\n\t/**\n\t * Sets the scan position to a new offset. A call to 'scan' is needed to get the first token.\n\t */\n\tsetPosition(pos: number): void;\n\t/**\n\t * Read the next token. Returns the token code.\n\t */\n\tscan(): SyntaxKind;\n\t/**\n\t * Returns the current scan position, which is after the last read token.\n\t */\n\tgetPosition(): number;\n\t/**\n\t * Returns the last read token.\n\t */\n\tgetToken(): SyntaxKind;\n\t/**\n\t * Returns the last read token value. The value for strings is the decoded string content. For numbers its of type number, for boolean it's true or false.\n\t */\n\tgetTokenValue(): string;\n\t/**\n\t * The start offset of the last read token.\n\t */\n\tgetTokenOffset(): number;\n\t/**\n\t * The length of the last read token.\n\t */\n\tgetTokenLength(): number;\n\t/**\n\t * An error code of the last scan.\n\t */\n\tgetTokenError(): ScanError;\n}\n\n\n\nexport interface ParseError {\n\terror: ParseErrorCode;\n\toffset: number;\n\tlength: number;\n}\n\nexport const enum ParseErrorCode {\n\tInvalidSymbol = 1,\n\tInvalidNumberFormat = 2,\n\tPropertyNameExpected = 3,\n\tValueExpected = 4,\n\tColonExpected = 5,\n\tCommaExpected = 6,\n\tCloseBraceExpected = 7,\n\tCloseBracketExpected = 8,\n\tEndOfFileExpected = 9,\n\tInvalidCommentToken = 10,\n\tUnexpectedEndOfComment = 11,\n\tUnexpectedEndOfString = 12,\n\tUnexpectedEndOfNumber = 13,\n\tInvalidUnicode = 14,\n\tInvalidEscapeCharacter = 15,\n\tInvalidCharacter = 16\n}\n\nexport type NodeType = 'object' | 'array' | 'property' | 'string' | 'number' | 'boolean' | 'null';\n\nexport interface Node {\n\treadonly type: NodeType;\n\treadonly value?: any;\n\treadonly offset: number;\n\treadonly length: number;\n\treadonly colonOffset?: number;\n\treadonly parent?: Node;\n\treadonly children?: Node[];\n}\n\nexport type Segment = string | number;\nexport type JSONPath = Segment[];\n\nexport interface Location {\n\t/**\n\t * The previous property key or literal value (string, number, boolean or null) or undefined.\n\t */\n\tpreviousNode?: Node;\n\t/**\n\t * The path describing the location in the JSON document. The path consists of a sequence strings\n\t * representing an object property or numbers for array indices.\n\t */\n\tpath: JSONPath;\n\t/**\n\t * Matches the locations path against a pattern consisting of strings (for properties) and numbers (for array indices).\n\t * '*' will match a single segment, of any property name or index.\n\t * '**' will match a sequence of segments or no segment, of any property name or index.\n\t */\n\tmatches: (patterns: JSONPath) => boolean;\n\t/**\n\t * If set, the location's offset is at a property key.\n\t */\n\tisAtPropertyKey: boolean;\n}\n\nexport interface ParseOptions {\n\tdisallowComments?: boolean;\n\tallowTrailingComma?: boolean;\n\tallowEmptyContent?: boolean;\n}\n\nexport namespace ParseOptions {\n\texport const DEFAULT = {\n\t\tallowTrailingComma: true\n\t};\n}\n\nexport interface JSONVisitor {\n\t/**\n\t * Invoked when an open brace is encountered and an object is started. The offset and length represent the location of the open brace.\n\t */\n\tonObjectBegin?: (offset: number, length: number) => void;\n\n\t/**\n\t * Invoked when a property is encountered. The offset and length represent the location of the property name.\n\t */\n\tonObjectProperty?: (property: string, offset: number, length: number) => void;\n\n\t/**\n\t * Invoked when a closing brace is encountered and an object is completed. The offset and length represent the location of the closing brace.\n\t */\n\tonObjectEnd?: (offset: number, length: number) => void;\n\n\t/**\n\t * Invoked when an open bracket is encountered. The offset and length represent the location of the open bracket.\n\t */\n\tonArrayBegin?: (offset: number, length: number) => void;\n\n\t/**\n\t * Invoked when a closing bracket is encountered. The offset and length represent the location of the closing bracket.\n\t */\n\tonArrayEnd?: (offset: number, length: number) => void;\n\n\t/**\n\t * Invoked when a literal value is encountered. The offset and length represent the location of the literal value.\n\t */\n\tonLiteralValue?: (value: any, offset: number, length: number) => void;\n\n\t/**\n\t * Invoked when a comma or colon separator is encountered. The offset and length represent the location of the separator.\n\t */\n\tonSeparator?: (character: string, offset: number, length: number) => void;\n\n\t/**\n\t * When comments are allowed, invoked when a line or block comment is encountered. The offset and length represent the location of the comment.\n\t */\n\tonComment?: (offset: number, length: number) => void;\n\n\t/**\n\t * Invoked on an error.\n\t */\n\tonError?: (error: ParseErrorCode, offset: number, length: number) => void;\n}\n\n/**\n * Creates a JSON scanner on the given text.\n * If ignoreTrivia is set, whitespaces or comments are ignored.\n */\nexport function createScanner(text: string, ignoreTrivia: boolean = false): JSONScanner {\n\n\tlet pos = 0;\n\tconst len = text.length;\n\tlet value: string = '';\n\tlet tokenOffset = 0;\n\tlet token: SyntaxKind = SyntaxKind.Unknown;\n\tlet scanError: ScanError = ScanError.None;\n\n\tfunction scanHexDigits(count: number): number {\n\t\tlet digits = 0;\n\t\tlet hexValue = 0;\n\t\twhile (digits < count) {\n\t\t\tconst ch = text.charCodeAt(pos);\n\t\t\tif (ch >= CharacterCodes._0 && ch <= CharacterCodes._9) {\n\t\t\t\thexValue = hexValue * 16 + ch - CharacterCodes._0;\n\t\t\t}\n\t\t\telse if (ch >= CharacterCodes.A && ch <= CharacterCodes.F) {\n\t\t\t\thexValue = hexValue * 16 + ch - CharacterCodes.A + 10;\n\t\t\t}\n\t\t\telse if (ch >= CharacterCodes.a && ch <= CharacterCodes.f) {\n\t\t\t\thexValue = hexValue * 16 + ch - CharacterCodes.a + 10;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpos++;\n\t\t\tdigits++;\n\t\t}\n\t\tif (digits < count) {\n\t\t\thexValue = -1;\n\t\t}\n\t\treturn hexValue;\n\t}\n\n\tfunction setPosition(newPosition: number) {\n\t\tpos = newPosition;\n\t\tvalue = '';\n\t\ttokenOffset = 0;\n\t\ttoken = SyntaxKind.Unknown;\n\t\tscanError = ScanError.None;\n\t}\n\n\tfunction scanNumber(): string {\n\t\tconst start = pos;\n\t\tif (text.charCodeAt(pos) === CharacterCodes._0) {\n\t\t\tpos++;\n\t\t} else {\n\t\t\tpos++;\n\t\t\twhile (pos < text.length && isDigit(text.charCodeAt(pos))) {\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t\tif (pos < text.length && text.charCodeAt(pos) === CharacterCodes.dot) {\n\t\t\tpos++;\n\t\t\tif (pos < text.length && isDigit(text.charCodeAt(pos))) {\n\t\t\t\tpos++;\n\t\t\t\twhile (pos < text.length && isDigit(text.charCodeAt(pos))) {\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tscanError = ScanError.UnexpectedEndOfNumber;\n\t\t\t\treturn text.substring(start, pos);\n\t\t\t}\n\t\t}\n\t\tlet end = pos;\n\t\tif (pos < text.length && (text.charCodeAt(pos) === CharacterCodes.E || text.charCodeAt(pos) === CharacterCodes.e)) {\n\t\t\tpos++;\n\t\t\tif (pos < text.length && text.charCodeAt(pos) === CharacterCodes.plus || text.charCodeAt(pos) === CharacterCodes.minus) {\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\tif (pos < text.length && isDigit(text.charCodeAt(pos))) {\n\t\t\t\tpos++;\n\t\t\t\twhile (pos < text.length && isDigit(text.charCodeAt(pos))) {\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t\tend = pos;\n\t\t\t} else {\n\t\t\t\tscanError = ScanError.UnexpectedEndOfNumber;\n\t\t\t}\n\t\t}\n\t\treturn text.substring(start, end);\n\t}\n\n\tfunction scanString(): string {\n\n\t\tlet result = '',\n\t\t\tstart = pos;\n\n\t\twhile (true) {\n\t\t\tif (pos >= len) {\n\t\t\t\tresult += text.substring(start, pos);\n\t\t\t\tscanError = ScanError.UnexpectedEndOfString;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst ch = text.charCodeAt(pos);\n\t\t\tif (ch === CharacterCodes.doubleQuote) {\n\t\t\t\tresult += text.substring(start, pos);\n\t\t\t\tpos++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ch === CharacterCodes.backslash) {\n\t\t\t\tresult += text.substring(start, pos);\n\t\t\t\tpos++;\n\t\t\t\tif (pos >= len) {\n\t\t\t\t\tscanError = ScanError.UnexpectedEndOfString;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tconst ch2 = text.charCodeAt(pos++);\n\t\t\t\tswitch (ch2) {\n\t\t\t\t\tcase CharacterCodes.doubleQuote:\n\t\t\t\t\t\tresult += '\\\"';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.backslash:\n\t\t\t\t\t\tresult += '\\\\';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.slash:\n\t\t\t\t\t\tresult += '/';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.b:\n\t\t\t\t\t\tresult += '\\b';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.f:\n\t\t\t\t\t\tresult += '\\f';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.n:\n\t\t\t\t\t\tresult += '\\n';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.r:\n\t\t\t\t\t\tresult += '\\r';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.t:\n\t\t\t\t\t\tresult += '\\t';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.u: {\n\t\t\t\t\t\tconst ch3 = scanHexDigits(4);\n\t\t\t\t\t\tif (ch3 >= 0) {\n\t\t\t\t\t\t\tresult += String.fromCharCode(ch3);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tscanError = ScanError.InvalidUnicode;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tscanError = ScanError.InvalidEscapeCharacter;\n\t\t\t\t}\n\t\t\t\tstart = pos;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ch >= 0 && ch <= 0x1F) {\n\t\t\t\tif (isLineBreak(ch)) {\n\t\t\t\t\tresult += text.substring(start, pos);\n\t\t\t\t\tscanError = ScanError.UnexpectedEndOfString;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tscanError = ScanError.InvalidCharacter;\n\t\t\t\t\t// mark as error but continue with string\n\t\t\t\t}\n\t\t\t}\n\t\t\tpos++;\n\t\t}\n\t\treturn result;\n\t}\n\n\tfunction scanNext(): SyntaxKind {\n\n\t\tvalue = '';\n\t\tscanError = ScanError.None;\n\n\t\ttokenOffset = pos;\n\n\t\tif (pos >= len) {\n\t\t\t// at the end\n\t\t\ttokenOffset = len;\n\t\t\treturn token = SyntaxKind.EOF;\n\t\t}\n\n\t\tlet code = text.charCodeAt(pos);\n\t\t// trivia: whitespace\n\t\tif (isWhitespace(code)) {\n\t\t\tdo {\n\t\t\t\tpos++;\n\t\t\t\tvalue += String.fromCharCode(code);\n\t\t\t\tcode = text.charCodeAt(pos);\n\t\t\t} while (isWhitespace(code));\n\n\t\t\treturn token = SyntaxKind.Trivia;\n\t\t}\n\n\t\t// trivia: newlines\n\t\tif (isLineBreak(code)) {\n\t\t\tpos++;\n\t\t\tvalue += String.fromCharCode(code);\n\t\t\tif (code === CharacterCodes.carriageReturn && text.charCodeAt(pos) === CharacterCodes.lineFeed) {\n\t\t\t\tpos++;\n\t\t\t\tvalue += '\\n';\n\t\t\t}\n\t\t\treturn token = SyntaxKind.LineBreakTrivia;\n\t\t}\n\n\t\tswitch (code) {\n\t\t\t// tokens: []{}:,\n\t\t\tcase CharacterCodes.openBrace:\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.OpenBraceToken;\n\t\t\tcase CharacterCodes.closeBrace:\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.CloseBraceToken;\n\t\t\tcase CharacterCodes.openBracket:\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.OpenBracketToken;\n\t\t\tcase CharacterCodes.closeBracket:\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.CloseBracketToken;\n\t\t\tcase CharacterCodes.colon:\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.ColonToken;\n\t\t\tcase CharacterCodes.comma:\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.CommaToken;\n\n\t\t\t// strings\n\t\t\tcase CharacterCodes.doubleQuote:\n\t\t\t\tpos++;\n\t\t\t\tvalue = scanString();\n\t\t\t\treturn token = SyntaxKind.StringLiteral;\n\n\t\t\t// comments\n\t\t\tcase CharacterCodes.slash: {\n\t\t\t\tconst start = pos - 1;\n\t\t\t\t// Single-line comment\n\t\t\t\tif (text.charCodeAt(pos + 1) === CharacterCodes.slash) {\n\t\t\t\t\tpos += 2;\n\n\t\t\t\t\twhile (pos < len) {\n\t\t\t\t\t\tif (isLineBreak(text.charCodeAt(pos))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpos++;\n\n\t\t\t\t\t}\n\t\t\t\t\tvalue = text.substring(start, pos);\n\t\t\t\t\treturn token = SyntaxKind.LineCommentTrivia;\n\t\t\t\t}\n\n\t\t\t\t// Multi-line comment\n\t\t\t\tif (text.charCodeAt(pos + 1) === CharacterCodes.asterisk) {\n\t\t\t\t\tpos += 2;\n\n\t\t\t\t\tconst safeLength = len - 1; // For lookahead.\n\t\t\t\t\tlet commentClosed = false;\n\t\t\t\t\twhile (pos < safeLength) {\n\t\t\t\t\t\tconst ch = text.charCodeAt(pos);\n\n\t\t\t\t\t\tif (ch === CharacterCodes.asterisk && text.charCodeAt(pos + 1) === CharacterCodes.slash) {\n\t\t\t\t\t\t\tpos += 2;\n\t\t\t\t\t\t\tcommentClosed = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!commentClosed) {\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t\tscanError = ScanError.UnexpectedEndOfComment;\n\t\t\t\t\t}\n\n\t\t\t\t\tvalue = text.substring(start, pos);\n\t\t\t\t\treturn token = SyntaxKind.BlockCommentTrivia;\n\t\t\t\t}\n\t\t\t\t// just a single slash\n\t\t\t\tvalue += String.fromCharCode(code);\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.Unknown;\n\t\t\t}\n\t\t\t// numbers\n\t\t\tcase CharacterCodes.minus:\n\t\t\t\tvalue += String.fromCharCode(code);\n\t\t\t\tpos++;\n\t\t\t\tif (pos === len || !isDigit(text.charCodeAt(pos))) {\n\t\t\t\t\treturn token = SyntaxKind.Unknown;\n\t\t\t\t}\n\t\t\t// found a minus, followed by a number so\n\t\t\t// we fall through to proceed with scanning\n\t\t\t// numbers\n\t\t\tcase CharacterCodes._0:\n\t\t\tcase CharacterCodes._1:\n\t\t\tcase CharacterCodes._2:\n\t\t\tcase CharacterCodes._3:\n\t\t\tcase CharacterCodes._4:\n\t\t\tcase CharacterCodes._5:\n\t\t\tcase CharacterCodes._6:\n\t\t\tcase CharacterCodes._7:\n\t\t\tcase CharacterCodes._8:\n\t\t\tcase CharacterCodes._9:\n\t\t\t\tvalue += scanNumber();\n\t\t\t\treturn token = SyntaxKind.NumericLiteral;\n\t\t\t// literals and unknown symbols\n\t\t\tdefault:\n\t\t\t\t// is a literal? Read the full word.\n\t\t\t\twhile (pos < len && isUnknownContentCharacter(code)) {\n\t\t\t\t\tpos++;\n\t\t\t\t\tcode = text.charCodeAt(pos);\n\t\t\t\t}\n\t\t\t\tif (tokenOffset !== pos) {\n\t\t\t\t\tvalue = text.substring(tokenOffset, pos);\n\t\t\t\t\t// keywords: true, false, null\n\t\t\t\t\tswitch (value) {\n\t\t\t\t\t\tcase 'true': return token = SyntaxKind.TrueKeyword;\n\t\t\t\t\t\tcase 'false': return token = SyntaxKind.FalseKeyword;\n\t\t\t\t\t\tcase 'null': return token = SyntaxKind.NullKeyword;\n\t\t\t\t\t}\n\t\t\t\t\treturn token = SyntaxKind.Unknown;\n\t\t\t\t}\n\t\t\t\t// some\n\t\t\t\tvalue += String.fromCharCode(code);\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.Unknown;\n\t\t}\n\t}\n\n\tfunction isUnknownContentCharacter(code: CharacterCodes) {\n\t\tif (isWhitespace(code) || isLineBreak(code)) {\n\t\t\treturn false;\n\t\t}\n\t\tswitch (code) {\n\t\t\tcase CharacterCodes.closeBrace:\n\t\t\tcase CharacterCodes.closeBracket:\n\t\t\tcase CharacterCodes.openBrace:\n\t\t\tcase CharacterCodes.openBracket:\n\t\t\tcase CharacterCodes.doubleQuote:\n\t\t\tcase CharacterCodes.colon:\n\t\t\tcase CharacterCodes.comma:\n\t\t\tcase CharacterCodes.slash:\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\n\tfunction scanNextNonTrivia(): SyntaxKind {\n\t\tlet result: SyntaxKind;\n\t\tdo {\n\t\t\tresult = scanNext();\n\t\t} while (result >= SyntaxKind.LineCommentTrivia && result <= SyntaxKind.Trivia);\n\t\treturn result;\n\t}\n\n\treturn {\n\t\tsetPosition: setPosition,\n\t\tgetPosition: () => pos,\n\t\tscan: ignoreTrivia ? scanNextNonTrivia : scanNext,\n\t\tgetToken: () => token,\n\t\tgetTokenValue: () => value,\n\t\tgetTokenOffset: () => tokenOffset,\n\t\tgetTokenLength: () => pos - tokenOffset,\n\t\tgetTokenError: () => scanError\n\t};\n}\n\nfunction isWhitespace(ch: number): boolean {\n\treturn ch === CharacterCodes.space || ch === CharacterCodes.tab || ch === CharacterCodes.verticalTab || ch === CharacterCodes.formFeed ||\n\t\tch === CharacterCodes.nonBreakingSpace || ch === CharacterCodes.ogham || ch >= CharacterCodes.enQuad && ch <= CharacterCodes.zeroWidthSpace ||\n\t\tch === CharacterCodes.narrowNoBreakSpace || ch === CharacterCodes.mathematicalSpace || ch === CharacterCodes.ideographicSpace || ch === CharacterCodes.byteOrderMark;\n}\n\nfunction isLineBreak(ch: number): boolean {\n\treturn ch === CharacterCodes.lineFeed || ch === CharacterCodes.carriageReturn || ch === CharacterCodes.lineSeparator || ch === CharacterCodes.paragraphSeparator;\n}\n\nfunction isDigit(ch: number): boolean {\n\treturn ch >= CharacterCodes._0 && ch <= CharacterCodes._9;\n}\n\nconst enum CharacterCodes {\n\tnullCharacter = 0,\n\tmaxAsciiCharacter = 0x7F,\n\n\tlineFeed = 0x0A,              // \\n\n\tcarriageReturn = 0x0D,        // \\r\n\tlineSeparator = 0x2028,\n\tparagraphSeparator = 0x2029,\n\n\t// REVIEW: do we need to support this?  The scanner doesn't, but our IText does.  This seems\n\t// like an odd disparity?  (Or maybe it's completely fine for them to be different).\n\tnextLine = 0x0085,\n\n\t// Unicode 3.0 space characters\n\tspace = 0x0020,   // \" \"\n\tnonBreakingSpace = 0x00A0,   //\n\tenQuad = 0x2000,\n\temQuad = 0x2001,\n\tenSpace = 0x2002,\n\temSpace = 0x2003,\n\tthreePerEmSpace = 0x2004,\n\tfourPerEmSpace = 0x2005,\n\tsixPerEmSpace = 0x2006,\n\tfigureSpace = 0x2007,\n\tpunctuationSpace = 0x2008,\n\tthinSpace = 0x2009,\n\thairSpace = 0x200A,\n\tzeroWidthSpace = 0x200B,\n\tnarrowNoBreakSpace = 0x202F,\n\tideographicSpace = 0x3000,\n\tmathematicalSpace = 0x205F,\n\togham = 0x1680,\n\n\t_ = 0x5F,\n\t$ = 0x24,\n\n\t_0 = 0x30,\n\t_1 = 0x31,\n\t_2 = 0x32,\n\t_3 = 0x33,\n\t_4 = 0x34,\n\t_5 = 0x35,\n\t_6 = 0x36,\n\t_7 = 0x37,\n\t_8 = 0x38,\n\t_9 = 0x39,\n\n\ta = 0x61,\n\tb = 0x62,\n\tc = 0x63,\n\td = 0x64,\n\te = 0x65,\n\tf = 0x66,\n\tg = 0x67,\n\th = 0x68,\n\ti = 0x69,\n\tj = 0x6A,\n\tk = 0x6B,\n\tl = 0x6C,\n\tm = 0x6D,\n\tn = 0x6E,\n\to = 0x6F,\n\tp = 0x70,\n\tq = 0x71,\n\tr = 0x72,\n\ts = 0x73,\n\tt = 0x74,\n\tu = 0x75,\n\tv = 0x76,\n\tw = 0x77,\n\tx = 0x78,\n\ty = 0x79,\n\tz = 0x7A,\n\n\tA = 0x41,\n\tB = 0x42,\n\tC = 0x43,\n\tD = 0x44,\n\tE = 0x45,\n\tF = 0x46,\n\tG = 0x47,\n\tH = 0x48,\n\tI = 0x49,\n\tJ = 0x4A,\n\tK = 0x4B,\n\tL = 0x4C,\n\tM = 0x4D,\n\tN = 0x4E,\n\tO = 0x4F,\n\tP = 0x50,\n\tQ = 0x51,\n\tR = 0x52,\n\tS = 0x53,\n\tT = 0x54,\n\tU = 0x55,\n\tV = 0x56,\n\tW = 0x57,\n\tX = 0x58,\n\tY = 0x59,\n\tZ = 0x5A,\n\n\tampersand = 0x26,             // &\n\tasterisk = 0x2A,              // *\n\tat = 0x40,                    // @\n\tbackslash = 0x5C,             // \\\n\tbar = 0x7C,                   // |\n\tcaret = 0x5E,                 // ^\n\tcloseBrace = 0x7D,            // }\n\tcloseBracket = 0x5D,          // ]\n\tcloseParen = 0x29,            // )\n\tcolon = 0x3A,                 // :\n\tcomma = 0x2C,                 // ,\n\tdot = 0x2E,                   // .\n\tdoubleQuote = 0x22,           // \"\n\tequals = 0x3D,                // =\n\texclamation = 0x21,           // !\n\tgreaterThan = 0x3E,           // >\n\tlessThan = 0x3C,              // <\n\tminus = 0x2D,                 // -\n\topenBrace = 0x7B,             // {\n\topenBracket = 0x5B,           // [\n\topenParen = 0x28,             // (\n\tpercent = 0x25,               // %\n\tplus = 0x2B,                  // +\n\tquestion = 0x3F,              // ?\n\tsemicolon = 0x3B,             // ;\n\tsingleQuote = 0x27,           // '\n\tslash = 0x2F,                 // /\n\ttilde = 0x7E,                 // ~\n\n\tbackspace = 0x08,             // \\b\n\tformFeed = 0x0C,              // \\f\n\tbyteOrderMark = 0xFEFF,\n\ttab = 0x09,                   // \\t\n\tverticalTab = 0x0B,           // \\v\n}\n\ninterface NodeImpl extends Node {\n\ttype: NodeType;\n\tvalue?: any;\n\toffset: number;\n\tlength: number;\n\tcolonOffset?: number;\n\tparent?: NodeImpl;\n\tchildren?: NodeImpl[];\n}\n\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\nexport function getLocation(text: string, position: number): Location {\n\tconst segments: Segment[] = []; // strings or numbers\n\tconst earlyReturnException = new Object();\n\tlet previousNode: NodeImpl | undefined = undefined;\n\tconst previousNodeInst: NodeImpl = {\n\t\tvalue: {},\n\t\toffset: 0,\n\t\tlength: 0,\n\t\ttype: 'object',\n\t\tparent: undefined\n\t};\n\tlet isAtPropertyKey = false;\n\tfunction setPreviousNode(value: string, offset: number, length: number, type: NodeType) {\n\t\tpreviousNodeInst.value = value;\n\t\tpreviousNodeInst.offset = offset;\n\t\tpreviousNodeInst.length = length;\n\t\tpreviousNodeInst.type = type;\n\t\tpreviousNodeInst.colonOffset = undefined;\n\t\tpreviousNode = previousNodeInst;\n\t}\n\ttry {\n\n\t\tvisit(text, {\n\t\t\tonObjectBegin: (offset: number, length: number) => {\n\t\t\t\tif (position <= offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tpreviousNode = undefined;\n\t\t\t\tisAtPropertyKey = position > offset;\n\t\t\t\tsegments.push(''); // push a placeholder (will be replaced)\n\t\t\t},\n\t\t\tonObjectProperty: (name: string, offset: number, length: number) => {\n\t\t\t\tif (position < offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tsetPreviousNode(name, offset, length, 'property');\n\t\t\t\tsegments[segments.length - 1] = name;\n\t\t\t\tif (position <= offset + length) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t},\n\t\t\tonObjectEnd: (offset: number, length: number) => {\n\t\t\t\tif (position <= offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tpreviousNode = undefined;\n\t\t\t\tsegments.pop();\n\t\t\t},\n\t\t\tonArrayBegin: (offset: number, length: number) => {\n\t\t\t\tif (position <= offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tpreviousNode = undefined;\n\t\t\t\tsegments.push(0);\n\t\t\t},\n\t\t\tonArrayEnd: (offset: number, length: number) => {\n\t\t\t\tif (position <= offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tpreviousNode = undefined;\n\t\t\t\tsegments.pop();\n\t\t\t},\n\t\t\tonLiteralValue: (value: any, offset: number, length: number) => {\n\t\t\t\tif (position < offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tsetPreviousNode(value, offset, length, getNodeType(value));\n\n\t\t\t\tif (position <= offset + length) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t},\n\t\t\tonSeparator: (sep: string, offset: number, length: number) => {\n\t\t\t\tif (position <= offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tif (sep === ':' && previousNode && previousNode.type === 'property') {\n\t\t\t\t\tpreviousNode.colonOffset = offset;\n\t\t\t\t\tisAtPropertyKey = false;\n\t\t\t\t\tpreviousNode = undefined;\n\t\t\t\t} else if (sep === ',') {\n\t\t\t\t\tconst last = segments[segments.length - 1];\n\t\t\t\t\tif (typeof last === 'number') {\n\t\t\t\t\t\tsegments[segments.length - 1] = last + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tisAtPropertyKey = true;\n\t\t\t\t\t\tsegments[segments.length - 1] = '';\n\t\t\t\t\t}\n\t\t\t\t\tpreviousNode = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t} catch (e) {\n\t\tif (e !== earlyReturnException) {\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\treturn {\n\t\tpath: segments,\n\t\tpreviousNode,\n\t\tisAtPropertyKey,\n\t\tmatches: (pattern: Segment[]) => {\n\t\t\tlet k = 0;\n\t\t\tfor (let i = 0; k < pattern.length && i < segments.length; i++) {\n\t\t\t\tif (pattern[k] === segments[i] || pattern[k] === '*') {\n\t\t\t\t\tk++;\n\t\t\t\t} else if (pattern[k] !== '**') {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn k === pattern.length;\n\t\t}\n\t};\n}\n\n\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore always check the errors list to find out if the input was valid.\n */\nexport function parse(text: string, errors: ParseError[] = [], options: ParseOptions = ParseOptions.DEFAULT): any {\n\tlet currentProperty: string | null = null;\n\tlet currentParent: any = [];\n\tconst previousParents: any[] = [];\n\n\tfunction onValue(value: any) {\n\t\tif (Array.isArray(currentParent)) {\n\t\t\t(<any[]>currentParent).push(value);\n\t\t} else if (currentProperty !== null) {\n\t\t\tcurrentParent[currentProperty] = value;\n\t\t}\n\t}\n\n\tconst visitor: JSONVisitor = {\n\t\tonObjectBegin: () => {\n\t\t\tconst object = {};\n\t\t\tonValue(object);\n\t\t\tpreviousParents.push(currentParent);\n\t\t\tcurrentParent = object;\n\t\t\tcurrentProperty = null;\n\t\t},\n\t\tonObjectProperty: (name: string) => {\n\t\t\tcurrentProperty = name;\n\t\t},\n\t\tonObjectEnd: () => {\n\t\t\tcurrentParent = previousParents.pop();\n\t\t},\n\t\tonArrayBegin: () => {\n\t\t\tconst array: any[] = [];\n\t\t\tonValue(array);\n\t\t\tpreviousParents.push(currentParent);\n\t\t\tcurrentParent = array;\n\t\t\tcurrentProperty = null;\n\t\t},\n\t\tonArrayEnd: () => {\n\t\t\tcurrentParent = previousParents.pop();\n\t\t},\n\t\tonLiteralValue: onValue,\n\t\tonError: (error: ParseErrorCode, offset: number, length: number) => {\n\t\t\terrors.push({ error, offset, length });\n\t\t}\n\t};\n\tvisit(text, visitor, options);\n\treturn currentParent[0];\n}\n\n\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\nexport function parseTree(text: string, errors: ParseError[] = [], options: ParseOptions = ParseOptions.DEFAULT): Node {\n\tlet currentParent: NodeImpl = { type: 'array', offset: -1, length: -1, children: [], parent: undefined }; // artificial root\n\n\tfunction ensurePropertyComplete(endOffset: number) {\n\t\tif (currentParent.type === 'property') {\n\t\t\tcurrentParent.length = endOffset - currentParent.offset;\n\t\t\tcurrentParent = currentParent.parent!;\n\t\t}\n\t}\n\n\tfunction onValue(valueNode: Node): Node {\n\t\tcurrentParent.children!.push(valueNode);\n\t\treturn valueNode;\n\t}\n\n\tconst visitor: JSONVisitor = {\n\t\tonObjectBegin: (offset: number) => {\n\t\t\tcurrentParent = onValue({ type: 'object', offset, length: -1, parent: currentParent, children: [] });\n\t\t},\n\t\tonObjectProperty: (name: string, offset: number, length: number) => {\n\t\t\tcurrentParent = onValue({ type: 'property', offset, length: -1, parent: currentParent, children: [] });\n\t\t\tcurrentParent.children!.push({ type: 'string', value: name, offset, length, parent: currentParent });\n\t\t},\n\t\tonObjectEnd: (offset: number, length: number) => {\n\t\t\tcurrentParent.length = offset + length - currentParent.offset;\n\t\t\tcurrentParent = currentParent.parent!;\n\t\t\tensurePropertyComplete(offset + length);\n\t\t},\n\t\tonArrayBegin: (offset: number, length: number) => {\n\t\t\tcurrentParent = onValue({ type: 'array', offset, length: -1, parent: currentParent, children: [] });\n\t\t},\n\t\tonArrayEnd: (offset: number, length: number) => {\n\t\t\tcurrentParent.length = offset + length - currentParent.offset;\n\t\t\tcurrentParent = currentParent.parent!;\n\t\t\tensurePropertyComplete(offset + length);\n\t\t},\n\t\tonLiteralValue: (value: any, offset: number, length: number) => {\n\t\t\tonValue({ type: getNodeType(value), offset, length, parent: currentParent, value });\n\t\t\tensurePropertyComplete(offset + length);\n\t\t},\n\t\tonSeparator: (sep: string, offset: number, length: number) => {\n\t\t\tif (currentParent.type === 'property') {\n\t\t\t\tif (sep === ':') {\n\t\t\t\t\tcurrentParent.colonOffset = offset;\n\t\t\t\t} else if (sep === ',') {\n\t\t\t\t\tensurePropertyComplete(offset);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tonError: (error: ParseErrorCode, offset: number, length: number) => {\n\t\t\terrors.push({ error, offset, length });\n\t\t}\n\t};\n\tvisit(text, visitor, options);\n\n\tconst result = currentParent.children![0];\n\tif (result) {\n\t\tdelete result.parent;\n\t}\n\treturn result;\n}\n\n/**\n * Finds the node at the given path in a JSON DOM.\n */\nexport function findNodeAtLocation(root: Node, path: JSONPath): Node | undefined {\n\tif (!root) {\n\t\treturn undefined;\n\t}\n\tlet node = root;\n\tfor (const segment of path) {\n\t\tif (typeof segment === 'string') {\n\t\t\tif (node.type !== 'object' || !Array.isArray(node.children)) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tlet found = false;\n\t\t\tfor (const propertyNode of node.children) {\n\t\t\t\tif (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment) {\n\t\t\t\t\tnode = propertyNode.children[1];\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t} else {\n\t\t\tconst index = <number>segment;\n\t\t\tif (node.type !== 'array' || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tnode = node.children[index];\n\t\t}\n\t}\n\treturn node;\n}\n\n/**\n * Gets the JSON path of the given JSON DOM node\n */\nexport function getNodePath(node: Node): JSONPath {\n\tif (!node.parent || !node.parent.children) {\n\t\treturn [];\n\t}\n\tconst path = getNodePath(node.parent);\n\tif (node.parent.type === 'property') {\n\t\tconst key = node.parent.children[0].value;\n\t\tpath.push(key);\n\t} else if (node.parent.type === 'array') {\n\t\tconst index = node.parent.children.indexOf(node);\n\t\tif (index !== -1) {\n\t\t\tpath.push(index);\n\t\t}\n\t}\n\treturn path;\n}\n\n/**\n * Evaluates the JavaScript object of the given JSON DOM node\n */\nexport function getNodeValue(node: Node): any {\n\tswitch (node.type) {\n\t\tcase 'array':\n\t\t\treturn node.children!.map(getNodeValue);\n\t\tcase 'object': {\n\t\t\tconst obj = Object.create(null);\n\t\t\tfor (const prop of node.children!) {\n\t\t\t\tconst valueNode = prop.children![1];\n\t\t\t\tif (valueNode) {\n\t\t\t\t\tobj[prop.children![0].value] = getNodeValue(valueNode);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\t\tcase 'null':\n\t\tcase 'string':\n\t\tcase 'number':\n\t\tcase 'boolean':\n\t\t\treturn node.value;\n\t\tdefault:\n\t\t\treturn undefined;\n\t}\n\n}\n\nexport function contains(node: Node, offset: number, includeRightBound = false): boolean {\n\treturn (offset >= node.offset && offset < (node.offset + node.length)) || includeRightBound && (offset === (node.offset + node.length));\n}\n\n/**\n * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n */\nexport function findNodeAtOffset(node: Node, offset: number, includeRightBound = false): Node | undefined {\n\tif (contains(node, offset, includeRightBound)) {\n\t\tconst children = node.children;\n\t\tif (Array.isArray(children)) {\n\t\t\tfor (let i = 0; i < children.length && children[i].offset <= offset; i++) {\n\t\t\t\tconst item = findNodeAtOffset(children[i], offset, includeRightBound);\n\t\t\t\tif (item) {\n\t\t\t\t\treturn item;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\treturn node;\n\t}\n\treturn undefined;\n}\n\n\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\nexport function visit(text: string, visitor: JSONVisitor, options: ParseOptions = ParseOptions.DEFAULT): any {\n\n\tconst _scanner = createScanner(text, false);\n\n\tfunction toNoArgVisit(visitFunction?: (offset: number, length: number) => void): () => void {\n\t\treturn visitFunction ? () => visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength()) : () => true;\n\t}\n\tfunction toOneArgVisit<T>(visitFunction?: (arg: T, offset: number, length: number) => void): (arg: T) => void {\n\t\treturn visitFunction ? (arg: T) => visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength()) : () => true;\n\t}\n\n\tconst onObjectBegin = toNoArgVisit(visitor.onObjectBegin),\n\t\tonObjectProperty = toOneArgVisit(visitor.onObjectProperty),\n\t\tonObjectEnd = toNoArgVisit(visitor.onObjectEnd),\n\t\tonArrayBegin = toNoArgVisit(visitor.onArrayBegin),\n\t\tonArrayEnd = toNoArgVisit(visitor.onArrayEnd),\n\t\tonLiteralValue = toOneArgVisit(visitor.onLiteralValue),\n\t\tonSeparator = toOneArgVisit(visitor.onSeparator),\n\t\tonComment = toNoArgVisit(visitor.onComment),\n\t\tonError = toOneArgVisit(visitor.onError);\n\n\tconst disallowComments = options && options.disallowComments;\n\tconst allowTrailingComma = options && options.allowTrailingComma;\n\tfunction scanNext(): SyntaxKind {\n\t\twhile (true) {\n\t\t\tconst token = _scanner.scan();\n\t\t\tswitch (_scanner.getTokenError()) {\n\t\t\t\tcase ScanError.InvalidUnicode:\n\t\t\t\t\thandleError(ParseErrorCode.InvalidUnicode);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ScanError.InvalidEscapeCharacter:\n\t\t\t\t\thandleError(ParseErrorCode.InvalidEscapeCharacter);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ScanError.UnexpectedEndOfNumber:\n\t\t\t\t\thandleError(ParseErrorCode.UnexpectedEndOfNumber);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ScanError.UnexpectedEndOfComment:\n\t\t\t\t\tif (!disallowComments) {\n\t\t\t\t\t\thandleError(ParseErrorCode.UnexpectedEndOfComment);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase ScanError.UnexpectedEndOfString:\n\t\t\t\t\thandleError(ParseErrorCode.UnexpectedEndOfString);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ScanError.InvalidCharacter:\n\t\t\t\t\thandleError(ParseErrorCode.InvalidCharacter);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswitch (token) {\n\t\t\t\tcase SyntaxKind.LineCommentTrivia:\n\t\t\t\tcase SyntaxKind.BlockCommentTrivia:\n\t\t\t\t\tif (disallowComments) {\n\t\t\t\t\t\thandleError(ParseErrorCode.InvalidCommentToken);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tonComment();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SyntaxKind.Unknown:\n\t\t\t\t\thandleError(ParseErrorCode.InvalidSymbol);\n\t\t\t\t\tbreak;\n\t\t\t\tcase SyntaxKind.Trivia:\n\t\t\t\tcase SyntaxKind.LineBreakTrivia:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn token;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction handleError(error: ParseErrorCode, skipUntilAfter: SyntaxKind[] = [], skipUntil: SyntaxKind[] = []): void {\n\t\tonError(error);\n\t\tif (skipUntilAfter.length + skipUntil.length > 0) {\n\t\t\tlet token = _scanner.getToken();\n\t\t\twhile (token !== SyntaxKind.EOF) {\n\t\t\t\tif (skipUntilAfter.indexOf(token) !== -1) {\n\t\t\t\t\tscanNext();\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (skipUntil.indexOf(token) !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttoken = scanNext();\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction parseString(isValue: boolean): boolean {\n\t\tconst value = _scanner.getTokenValue();\n\t\tif (isValue) {\n\t\t\tonLiteralValue(value);\n\t\t} else {\n\t\t\tonObjectProperty(value);\n\t\t}\n\t\tscanNext();\n\t\treturn true;\n\t}\n\n\tfunction parseLiteral(): boolean {\n\t\tswitch (_scanner.getToken()) {\n\t\t\tcase SyntaxKind.NumericLiteral: {\n\t\t\t\tlet value = 0;\n\t\t\t\ttry {\n\t\t\t\t\tvalue = JSON.parse(_scanner.getTokenValue());\n\t\t\t\t\tif (typeof value !== 'number') {\n\t\t\t\t\t\thandleError(ParseErrorCode.InvalidNumberFormat);\n\t\t\t\t\t\tvalue = 0;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\thandleError(ParseErrorCode.InvalidNumberFormat);\n\t\t\t\t}\n\t\t\t\tonLiteralValue(value);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase SyntaxKind.NullKeyword:\n\t\t\t\tonLiteralValue(null);\n\t\t\t\tbreak;\n\t\t\tcase SyntaxKind.TrueKeyword:\n\t\t\t\tonLiteralValue(true);\n\t\t\t\tbreak;\n\t\t\tcase SyntaxKind.FalseKeyword:\n\t\t\t\tonLiteralValue(false);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t\tscanNext();\n\t\treturn true;\n\t}\n\n\tfunction parseProperty(): boolean {\n\t\tif (_scanner.getToken() !== SyntaxKind.StringLiteral) {\n\t\t\thandleError(ParseErrorCode.PropertyNameExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);\n\t\t\treturn false;\n\t\t}\n\t\tparseString(false);\n\t\tif (_scanner.getToken() === SyntaxKind.ColonToken) {\n\t\t\tonSeparator(':');\n\t\t\tscanNext(); // consume colon\n\n\t\t\tif (!parseValue()) {\n\t\t\t\thandleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);\n\t\t\t}\n\t\t} else {\n\t\t\thandleError(ParseErrorCode.ColonExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction parseObject(): boolean {\n\t\tonObjectBegin();\n\t\tscanNext(); // consume open brace\n\n\t\tlet needsComma = false;\n\t\twhile (_scanner.getToken() !== SyntaxKind.CloseBraceToken && _scanner.getToken() !== SyntaxKind.EOF) {\n\t\t\tif (_scanner.getToken() === SyntaxKind.CommaToken) {\n\t\t\t\tif (!needsComma) {\n\t\t\t\t\thandleError(ParseErrorCode.ValueExpected, [], []);\n\t\t\t\t}\n\t\t\t\tonSeparator(',');\n\t\t\t\tscanNext(); // consume comma\n\t\t\t\tif (_scanner.getToken() === SyntaxKind.CloseBraceToken && allowTrailingComma) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (needsComma) {\n\t\t\t\thandleError(ParseErrorCode.CommaExpected, [], []);\n\t\t\t}\n\t\t\tif (!parseProperty()) {\n\t\t\t\thandleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);\n\t\t\t}\n\t\t\tneedsComma = true;\n\t\t}\n\t\tonObjectEnd();\n\t\tif (_scanner.getToken() !== SyntaxKind.CloseBraceToken) {\n\t\t\thandleError(ParseErrorCode.CloseBraceExpected, [SyntaxKind.CloseBraceToken], []);\n\t\t} else {\n\t\t\tscanNext(); // consume close brace\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction parseArray(): boolean {\n\t\tonArrayBegin();\n\t\tscanNext(); // consume open bracket\n\n\t\tlet needsComma = false;\n\t\twhile (_scanner.getToken() !== SyntaxKind.CloseBracketToken && _scanner.getToken() !== SyntaxKind.EOF) {\n\t\t\tif (_scanner.getToken() === SyntaxKind.CommaToken) {\n\t\t\t\tif (!needsComma) {\n\t\t\t\t\thandleError(ParseErrorCode.ValueExpected, [], []);\n\t\t\t\t}\n\t\t\t\tonSeparator(',');\n\t\t\t\tscanNext(); // consume comma\n\t\t\t\tif (_scanner.getToken() === SyntaxKind.CloseBracketToken && allowTrailingComma) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (needsComma) {\n\t\t\t\thandleError(ParseErrorCode.CommaExpected, [], []);\n\t\t\t}\n\t\t\tif (!parseValue()) {\n\t\t\t\thandleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBracketToken, SyntaxKind.CommaToken]);\n\t\t\t}\n\t\t\tneedsComma = true;\n\t\t}\n\t\tonArrayEnd();\n\t\tif (_scanner.getToken() !== SyntaxKind.CloseBracketToken) {\n\t\t\thandleError(ParseErrorCode.CloseBracketExpected, [SyntaxKind.CloseBracketToken], []);\n\t\t} else {\n\t\t\tscanNext(); // consume close bracket\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction parseValue(): boolean {\n\t\tswitch (_scanner.getToken()) {\n\t\t\tcase SyntaxKind.OpenBracketToken:\n\t\t\t\treturn parseArray();\n\t\t\tcase SyntaxKind.OpenBraceToken:\n\t\t\t\treturn parseObject();\n\t\t\tcase SyntaxKind.StringLiteral:\n\t\t\t\treturn parseString(true);\n\t\t\tdefault:\n\t\t\t\treturn parseLiteral();\n\t\t}\n\t}\n\n\tscanNext();\n\tif (_scanner.getToken() === SyntaxKind.EOF) {\n\t\tif (options.allowEmptyContent) {\n\t\t\treturn true;\n\t\t}\n\t\thandleError(ParseErrorCode.ValueExpected, [], []);\n\t\treturn false;\n\t}\n\tif (!parseValue()) {\n\t\thandleError(ParseErrorCode.ValueExpected, [], []);\n\t\treturn false;\n\t}\n\tif (_scanner.getToken() !== SyntaxKind.EOF) {\n\t\thandleError(ParseErrorCode.EndOfFileExpected, [], []);\n\t}\n\treturn true;\n}\n\nexport function getNodeType(value: any): NodeType {\n\tswitch (typeof value) {\n\t\tcase 'boolean': return 'boolean';\n\t\tcase 'number': return 'number';\n\t\tcase 'string': return 'string';\n\t\tcase 'object': {\n\t\t\tif (!value) {\n\t\t\t\treturn 'null';\n\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\treturn 'array';\n\t\t\t}\n\t\t\treturn 'object';\n\t\t}\n\t\tdefault: return 'null';\n\t}\n}\n"],
  "mappings": "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",
  "names": ["ScanError", "SyntaxKind", "ParseErrorCode", "ParseOptions", "CharacterCodes"]
}
