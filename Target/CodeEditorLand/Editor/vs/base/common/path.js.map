{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/path.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace\n// Copied from: https://github.com/nodejs/node/commits/v20.9.0/lib/path.js\n// Excluding: the change that adds primordials\n// (https://github.com/nodejs/node/commit/187a862d221dec42fa9a5c4214e7034d9092792f and others)\n\n/**\n * Copyright Joyent, Inc. and other Node contributors.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport * as process from \"./process.js\";\n\nconst CHAR_UPPERCASE_A = 65; /* A */\nconst CHAR_LOWERCASE_A = 97; /* a */\nconst CHAR_UPPERCASE_Z = 90; /* Z */\nconst CHAR_LOWERCASE_Z = 122; /* z */\nconst CHAR_DOT = 46; /* . */\nconst CHAR_FORWARD_SLASH = 47; /* / */\nconst CHAR_BACKWARD_SLASH = 92; /* \\ */\nconst CHAR_COLON = 58; /* : */\nconst CHAR_QUESTION_MARK = 63; /* ? */\n\nclass ErrorInvalidArgType extends Error {\n\tcode: \"ERR_INVALID_ARG_TYPE\";\n\tconstructor(name: string, expected: string, actual: unknown) {\n\t\t// determiner: 'must be' or 'must not be'\n\t\tlet determiner;\n\t\tif (typeof expected === \"string\" && expected.indexOf(\"not \") === 0) {\n\t\t\tdeterminer = \"must not be\";\n\t\t\texpected = expected.replace(/^not /, \"\");\n\t\t} else {\n\t\t\tdeterminer = \"must be\";\n\t\t}\n\n\t\tconst type = name.indexOf(\".\") !== -1 ? \"property\" : \"argument\";\n\t\tlet msg = `The \"${name}\" ${type} ${determiner} of type ${expected}`;\n\n\t\tmsg += `. Received type ${typeof actual}`;\n\t\tsuper(msg);\n\n\t\tthis.code = \"ERR_INVALID_ARG_TYPE\";\n\t}\n}\n\nfunction validateObject(pathObject: object, name: string) {\n\tif (pathObject === null || typeof pathObject !== \"object\") {\n\t\tthrow new ErrorInvalidArgType(name, \"Object\", pathObject);\n\t}\n}\n\nfunction validateString(value: string, name: string) {\n\tif (typeof value !== \"string\") {\n\t\tthrow new ErrorInvalidArgType(name, \"string\", value);\n\t}\n}\n\nconst platformIsWin32 = process.platform === \"win32\";\n\nfunction isPathSeparator(code: number | undefined) {\n\treturn code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\n\nfunction isPosixPathSeparator(code: number | undefined) {\n\treturn code === CHAR_FORWARD_SLASH;\n}\n\nfunction isWindowsDeviceRoot(code: number) {\n\treturn (\n\t\t(code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z) ||\n\t\t(code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z)\n\t);\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(\n\tpath: string,\n\tallowAboveRoot: boolean,\n\tseparator: string,\n\tisPathSeparator: (code?: number) => boolean,\n) {\n\tlet res = \"\";\n\tlet lastSegmentLength = 0;\n\tlet lastSlash = -1;\n\tlet dots = 0;\n\tlet code = 0;\n\tfor (let i = 0; i <= path.length; ++i) {\n\t\tif (i < path.length) {\n\t\t\tcode = path.charCodeAt(i);\n\t\t} else if (isPathSeparator(code)) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\tcode = CHAR_FORWARD_SLASH;\n\t\t}\n\n\t\tif (isPathSeparator(code)) {\n\t\t\tif (lastSlash === i - 1 || dots === 1) {\n\t\t\t\t// NOOP\n\t\t\t} else if (dots === 2) {\n\t\t\t\tif (\n\t\t\t\t\tres.length < 2 ||\n\t\t\t\t\tlastSegmentLength !== 2 ||\n\t\t\t\t\tres.charCodeAt(res.length - 1) !== CHAR_DOT ||\n\t\t\t\t\tres.charCodeAt(res.length - 2) !== CHAR_DOT\n\t\t\t\t) {\n\t\t\t\t\tif (res.length > 2) {\n\t\t\t\t\t\tconst lastSlashIndex = res.lastIndexOf(separator);\n\t\t\t\t\t\tif (lastSlashIndex === -1) {\n\t\t\t\t\t\t\tres = \"\";\n\t\t\t\t\t\t\tlastSegmentLength = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tres = res.slice(0, lastSlashIndex);\n\t\t\t\t\t\t\tlastSegmentLength =\n\t\t\t\t\t\t\t\tres.length - 1 - res.lastIndexOf(separator);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastSlash = i;\n\t\t\t\t\t\tdots = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (res.length !== 0) {\n\t\t\t\t\t\tres = \"\";\n\t\t\t\t\t\tlastSegmentLength = 0;\n\t\t\t\t\t\tlastSlash = i;\n\t\t\t\t\t\tdots = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (allowAboveRoot) {\n\t\t\t\t\tres += res.length > 0 ? `${separator}..` : \"..\";\n\t\t\t\t\tlastSegmentLength = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (res.length > 0) {\n\t\t\t\t\tres += `${separator}${path.slice(lastSlash + 1, i)}`;\n\t\t\t\t} else {\n\t\t\t\t\tres = path.slice(lastSlash + 1, i);\n\t\t\t\t}\n\t\t\t\tlastSegmentLength = i - lastSlash - 1;\n\t\t\t}\n\t\t\tlastSlash = i;\n\t\t\tdots = 0;\n\t\t} else if (code === CHAR_DOT && dots !== -1) {\n\t\t\t++dots;\n\t\t} else {\n\t\t\tdots = -1;\n\t\t}\n\t}\n\treturn res;\n}\n\nfunction formatExt(ext: string): string {\n\treturn ext ? `${ext[0] === \".\" ? \"\" : \".\"}${ext}` : \"\";\n}\n\nfunction _format(sep: string, pathObject: ParsedPath) {\n\tvalidateObject(pathObject, \"pathObject\");\n\tconst dir = pathObject.dir || pathObject.root;\n\tconst base =\n\t\tpathObject.base ||\n\t\t`${pathObject.name || \"\"}${formatExt(pathObject.ext)}`;\n\tif (!dir) {\n\t\treturn base;\n\t}\n\treturn dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\n}\n\nexport interface ParsedPath {\n\troot: string;\n\tdir: string;\n\tbase: string;\n\text: string;\n\tname: string;\n}\n\nexport interface IPath {\n\tnormalize(path: string): string;\n\tisAbsolute(path: string): boolean;\n\tjoin(...paths: string[]): string;\n\tresolve(...pathSegments: string[]): string;\n\trelative(from: string, to: string): string;\n\tdirname(path: string): string;\n\tbasename(path: string, suffix?: string): string;\n\textname(path: string): string;\n\tformat(pathObject: ParsedPath): string;\n\tparse(path: string): ParsedPath;\n\ttoNamespacedPath(path: string): string;\n\tsep: \"\\\\\" | \"/\";\n\tdelimiter: string;\n\twin32: IPath | null;\n\tposix: IPath | null;\n}\n\nexport const win32: IPath = {\n\t// path.resolve([from ...], to)\n\tresolve(...pathSegments: string[]): string {\n\t\tlet resolvedDevice = \"\";\n\t\tlet resolvedTail = \"\";\n\t\tlet resolvedAbsolute = false;\n\n\t\tfor (let i = pathSegments.length - 1; i >= -1; i--) {\n\t\t\tlet path;\n\t\t\tif (i >= 0) {\n\t\t\t\tpath = pathSegments[i];\n\t\t\t\tvalidateString(path, `paths[${i}]`);\n\n\t\t\t\t// Skip empty entries\n\t\t\t\tif (path.length === 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (resolvedDevice.length === 0) {\n\t\t\t\tpath = process.cwd();\n\t\t\t} else {\n\t\t\t\t// Windows has the concept of drive-specific current working\n\t\t\t\t// directories. If we've resolved a drive letter but not yet an\n\t\t\t\t// absolute path, get cwd for that drive, or the process cwd if\n\t\t\t\t// the drive cwd is not available. We're sure the device is not\n\t\t\t\t// a UNC path at this points, because UNC paths are always absolute.\n\t\t\t\tpath = process.env[`=${resolvedDevice}`] || process.cwd();\n\n\t\t\t\t// Verify that a cwd was found and that it actually points\n\t\t\t\t// to our drive. If not, default to the drive's root.\n\t\t\t\tif (\n\t\t\t\t\tpath === undefined ||\n\t\t\t\t\t(path.slice(0, 2).toLowerCase() !==\n\t\t\t\t\t\tresolvedDevice.toLowerCase() &&\n\t\t\t\t\t\tpath.charCodeAt(2) === CHAR_BACKWARD_SLASH)\n\t\t\t\t) {\n\t\t\t\t\tpath = `${resolvedDevice}\\\\`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst len = path.length;\n\t\t\tlet rootEnd = 0;\n\t\t\tlet device = \"\";\n\t\t\tlet isAbsolute = false;\n\t\t\tconst code = path.charCodeAt(0);\n\n\t\t\t// Try to match a root\n\t\t\tif (len === 1) {\n\t\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t\t// `path` contains just a path separator\n\t\t\t\t\trootEnd = 1;\n\t\t\t\t\tisAbsolute = true;\n\t\t\t\t}\n\t\t\t} else if (isPathSeparator(code)) {\n\t\t\t\t// Possible UNC root\n\n\t\t\t\t// If we started with a separator, we know we at least have an\n\t\t\t\t// absolute path of some kind (UNC or otherwise)\n\t\t\t\tisAbsolute = true;\n\n\t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t\t// Matched double path separator at beginning\n\t\t\t\t\tlet j = 2;\n\t\t\t\t\tlet last = j;\n\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\tconst firstPart = path.slice(last, j);\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\t\twhile (\n\t\t\t\t\t\t\t\tj < len &&\n\t\t\t\t\t\t\t\t!isPathSeparator(path.charCodeAt(j))\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j === len || j !== last) {\n\t\t\t\t\t\t\t\t// We matched a UNC root\n\t\t\t\t\t\t\t\tdevice = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n\t\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trootEnd = 1;\n\t\t\t\t}\n\t\t\t} else if (\n\t\t\t\tisWindowsDeviceRoot(code) &&\n\t\t\t\tpath.charCodeAt(1) === CHAR_COLON\n\t\t\t) {\n\t\t\t\t// Possible device root\n\t\t\t\tdevice = path.slice(0, 2);\n\t\t\t\trootEnd = 2;\n\t\t\t\tif (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\t// Treat separator following drive name as an absolute path\n\t\t\t\t\t// indicator\n\t\t\t\t\tisAbsolute = true;\n\t\t\t\t\trootEnd = 3;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (device.length > 0) {\n\t\t\t\tif (resolvedDevice.length > 0) {\n\t\t\t\t\tif (device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n\t\t\t\t\t\t// This path points to another device so it is not applicable\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresolvedDevice = device;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (resolvedAbsolute) {\n\t\t\t\tif (resolvedDevice.length > 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresolvedTail = `${path.slice(rootEnd)}\\\\${resolvedTail}`;\n\t\t\t\tresolvedAbsolute = isAbsolute;\n\t\t\t\tif (isAbsolute && resolvedDevice.length > 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// At this point the path should be resolved to a full absolute path,\n\t\t// but handle relative paths to be safe (might happen when process.cwd()\n\t\t// fails)\n\n\t\t// Normalize the tail path\n\t\tresolvedTail = normalizeString(\n\t\t\tresolvedTail,\n\t\t\t!resolvedAbsolute,\n\t\t\t\"\\\\\",\n\t\t\tisPathSeparator,\n\t\t);\n\n\t\treturn resolvedAbsolute\n\t\t\t? `${resolvedDevice}\\\\${resolvedTail}`\n\t\t\t: `${resolvedDevice}${resolvedTail}` || \".\";\n\t},\n\n\tnormalize(path: string): string {\n\t\tvalidateString(path, \"path\");\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn \".\";\n\t\t}\n\t\tlet rootEnd = 0;\n\t\tlet device;\n\t\tlet isAbsolute = false;\n\t\tconst code = path.charCodeAt(0);\n\n\t\t// Try to match a root\n\t\tif (len === 1) {\n\t\t\t// `path` contains just a single char, exit early to avoid\n\t\t\t// unnecessary work\n\t\t\treturn isPosixPathSeparator(code) ? \"\\\\\" : path;\n\t\t}\n\t\tif (isPathSeparator(code)) {\n\t\t\t// Possible UNC root\n\n\t\t\t// If we started with a separator, we know we at least have an absolute\n\t\t\t// path of some kind (UNC or otherwise)\n\t\t\tisAbsolute = true;\n\n\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t// Matched double path separator at beginning\n\t\t\t\tlet j = 2;\n\t\t\t\tlet last = j;\n\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\tconst firstPart = path.slice(last, j);\n\t\t\t\t\t// Matched!\n\t\t\t\t\tlast = j;\n\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\twhile (\n\t\t\t\t\t\t\tj < len &&\n\t\t\t\t\t\t\t!isPathSeparator(path.charCodeAt(j))\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\t// Return the normalized version of the UNC root since there\n\t\t\t\t\t\t\t// is nothing left to process\n\t\t\t\t\t\t\treturn `\\\\\\\\${firstPart}\\\\${path.slice(last)}\\\\`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j !== last) {\n\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\t\t\t\t\t\t\tdevice = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trootEnd = 1;\n\t\t\t}\n\t\t} else if (\n\t\t\tisWindowsDeviceRoot(code) &&\n\t\t\tpath.charCodeAt(1) === CHAR_COLON\n\t\t) {\n\t\t\t// Possible device root\n\t\t\tdevice = path.slice(0, 2);\n\t\t\trootEnd = 2;\n\t\t\tif (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t// Treat separator following drive name as an absolute path\n\t\t\t\t// indicator\n\t\t\t\tisAbsolute = true;\n\t\t\t\trootEnd = 3;\n\t\t\t}\n\t\t}\n\n\t\tlet tail =\n\t\t\trootEnd < len\n\t\t\t\t? normalizeString(\n\t\t\t\t\t\tpath.slice(rootEnd),\n\t\t\t\t\t\t!isAbsolute,\n\t\t\t\t\t\t\"\\\\\",\n\t\t\t\t\t\tisPathSeparator,\n\t\t\t\t\t)\n\t\t\t\t: \"\";\n\t\tif (tail.length === 0 && !isAbsolute) {\n\t\t\ttail = \".\";\n\t\t}\n\t\tif (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n\t\t\ttail += \"\\\\\";\n\t\t}\n\t\tif (device === undefined) {\n\t\t\treturn isAbsolute ? `\\\\${tail}` : tail;\n\t\t}\n\t\treturn isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n\t},\n\n\tisAbsolute(path: string): boolean {\n\t\tvalidateString(path, \"path\");\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst code = path.charCodeAt(0);\n\t\treturn (\n\t\t\tisPathSeparator(code) ||\n\t\t\t// Possible device root\n\t\t\t(len > 2 &&\n\t\t\t\tisWindowsDeviceRoot(code) &&\n\t\t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n\t\t\t\tisPathSeparator(path.charCodeAt(2)))\n\t\t);\n\t},\n\n\tjoin(...paths: string[]): string {\n\t\tif (paths.length === 0) {\n\t\t\treturn \".\";\n\t\t}\n\n\t\tlet joined;\n\t\tlet firstPart: string | undefined;\n\t\tfor (let i = 0; i < paths.length; ++i) {\n\t\t\tconst arg = paths[i];\n\t\t\tvalidateString(arg, \"path\");\n\t\t\tif (arg.length > 0) {\n\t\t\t\tif (joined === undefined) {\n\t\t\t\t\tjoined = firstPart = arg;\n\t\t\t\t} else {\n\t\t\t\t\tjoined += `\\\\${arg}`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (joined === undefined) {\n\t\t\treturn \".\";\n\t\t}\n\n\t\t// Make sure that the joined path doesn't start with two slashes, because\n\t\t// normalize() will mistake it for a UNC path then.\n\t\t//\n\t\t// This step is skipped when it is very clear that the user actually\n\t\t// intended to point at a UNC path. This is assumed when the first\n\t\t// non-empty string arguments starts with exactly two slashes followed by\n\t\t// at least one more non-slash character.\n\t\t//\n\t\t// Note that for normalize() to treat a path as a UNC path it needs to\n\t\t// have at least 2 components, so we don't filter for that here.\n\t\t// This means that the user can use join to construct UNC paths from\n\t\t// a server name and a share name; for example:\n\t\t//   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n\t\tlet needsReplace = true;\n\t\tlet slashCount = 0;\n\t\tif (\n\t\t\ttypeof firstPart === \"string\" &&\n\t\t\tisPathSeparator(firstPart.charCodeAt(0))\n\t\t) {\n\t\t\t++slashCount;\n\t\t\tconst firstLen = firstPart.length;\n\t\t\tif (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {\n\t\t\t\t++slashCount;\n\t\t\t\tif (firstLen > 2) {\n\t\t\t\t\tif (isPathSeparator(firstPart.charCodeAt(2))) {\n\t\t\t\t\t\t++slashCount;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// We matched a UNC path in the first part\n\t\t\t\t\t\tneedsReplace = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (needsReplace) {\n\t\t\t// Find any more consecutive slashes we need to replace\n\t\t\twhile (\n\t\t\t\tslashCount < joined.length &&\n\t\t\t\tisPathSeparator(joined.charCodeAt(slashCount))\n\t\t\t) {\n\t\t\t\tslashCount++;\n\t\t\t}\n\n\t\t\t// Replace the slashes if needed\n\t\t\tif (slashCount >= 2) {\n\t\t\t\tjoined = `\\\\${joined.slice(slashCount)}`;\n\t\t\t}\n\t\t}\n\n\t\treturn win32.normalize(joined);\n\t},\n\n\t// It will solve the relative path from `from` to `to`, for instance:\n\t//  from = 'C:\\\\orandea\\\\test\\\\aaa'\n\t//  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n\t// The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n\trelative(from: string, to: string): string {\n\t\tvalidateString(from, \"from\");\n\t\tvalidateString(to, \"to\");\n\n\t\tif (from === to) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tconst fromOrig = win32.resolve(from);\n\t\tconst toOrig = win32.resolve(to);\n\n\t\tif (fromOrig === toOrig) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tfrom = fromOrig.toLowerCase();\n\t\tto = toOrig.toLowerCase();\n\n\t\tif (from === to) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\t// Trim any leading backslashes\n\t\tlet fromStart = 0;\n\t\twhile (\n\t\t\tfromStart < from.length &&\n\t\t\tfrom.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH\n\t\t) {\n\t\t\tfromStart++;\n\t\t}\n\t\t// Trim trailing backslashes (applicable to UNC paths only)\n\t\tlet fromEnd = from.length;\n\t\twhile (\n\t\t\tfromEnd - 1 > fromStart &&\n\t\t\tfrom.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH\n\t\t) {\n\t\t\tfromEnd--;\n\t\t}\n\t\tconst fromLen = fromEnd - fromStart;\n\n\t\t// Trim any leading backslashes\n\t\tlet toStart = 0;\n\t\twhile (\n\t\t\ttoStart < to.length &&\n\t\t\tto.charCodeAt(toStart) === CHAR_BACKWARD_SLASH\n\t\t) {\n\t\t\ttoStart++;\n\t\t}\n\t\t// Trim trailing backslashes (applicable to UNC paths only)\n\t\tlet toEnd = to.length;\n\t\twhile (\n\t\t\ttoEnd - 1 > toStart &&\n\t\t\tto.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH\n\t\t) {\n\t\t\ttoEnd--;\n\t\t}\n\t\tconst toLen = toEnd - toStart;\n\n\t\t// Compare paths to find the longest common path from root\n\t\tconst length = fromLen < toLen ? fromLen : toLen;\n\t\tlet lastCommonSep = -1;\n\t\tlet i = 0;\n\t\tfor (; i < length; i++) {\n\t\t\tconst fromCode = from.charCodeAt(fromStart + i);\n\t\t\tif (fromCode !== to.charCodeAt(toStart + i)) {\n\t\t\t\tbreak;\n\t\t\t} else if (fromCode === CHAR_BACKWARD_SLASH) {\n\t\t\t\tlastCommonSep = i;\n\t\t\t}\n\t\t}\n\n\t\t// We found a mismatch before the first common path separator was seen, so\n\t\t// return the original `to`.\n\t\tif (i !== length) {\n\t\t\tif (lastCommonSep === -1) {\n\t\t\t\treturn toOrig;\n\t\t\t}\n\t\t} else {\n\t\t\tif (toLen > length) {\n\t\t\t\tif (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\t// We get here if `from` is the exact base path for `to`.\n\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n\t\t\t\t\treturn toOrig.slice(toStart + i + 1);\n\t\t\t\t}\n\t\t\t\tif (i === 2) {\n\t\t\t\t\t// We get here if `from` is the device root.\n\t\t\t\t\t// For example: from='C:\\\\'; to='C:\\\\foo'\n\t\t\t\t\treturn toOrig.slice(toStart + i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (fromLen > length) {\n\t\t\t\tif (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\t// We get here if `to` is the exact base path for `from`.\n\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n\t\t\t\t\tlastCommonSep = i;\n\t\t\t\t} else if (i === 2) {\n\t\t\t\t\t// We get here if `to` is the device root.\n\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n\t\t\t\t\tlastCommonSep = 3;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lastCommonSep === -1) {\n\t\t\t\tlastCommonSep = 0;\n\t\t\t}\n\t\t}\n\n\t\tlet out = \"\";\n\t\t// Generate the relative path based on the path difference between `to` and\n\t\t// `from`\n\t\tfor (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n\t\t\tif (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\tout += out.length === 0 ? \"..\" : \"\\\\..\";\n\t\t\t}\n\t\t}\n\n\t\ttoStart += lastCommonSep;\n\n\t\t// Lastly, append the rest of the destination (`to`) path that comes after\n\t\t// the common path parts\n\t\tif (out.length > 0) {\n\t\t\treturn `${out}${toOrig.slice(toStart, toEnd)}`;\n\t\t}\n\n\t\tif (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n\t\t\t++toStart;\n\t\t}\n\n\t\treturn toOrig.slice(toStart, toEnd);\n\t},\n\n\ttoNamespacedPath(path: string): string {\n\t\t// Note: this will *probably* throw somewhere.\n\t\tif (typeof path !== \"string\" || path.length === 0) {\n\t\t\treturn path;\n\t\t}\n\n\t\tconst resolvedPath = win32.resolve(path);\n\n\t\tif (resolvedPath.length <= 2) {\n\t\t\treturn path;\n\t\t}\n\n\t\tif (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n\t\t\t// Possible UNC root\n\t\t\tif (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n\t\t\t\tconst code = resolvedPath.charCodeAt(2);\n\t\t\t\tif (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n\t\t\t\t\t// Matched non-long UNC root, convert the path to a long UNC path\n\t\t\t\t\treturn `\\\\\\\\?\\\\UNC\\\\${resolvedPath.slice(2)}`;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (\n\t\t\tisWindowsDeviceRoot(resolvedPath.charCodeAt(0)) &&\n\t\t\tresolvedPath.charCodeAt(1) === CHAR_COLON &&\n\t\t\tresolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH\n\t\t) {\n\t\t\t// Matched device root, convert the path to a long UNC path\n\t\t\treturn `\\\\\\\\?\\\\${resolvedPath}`;\n\t\t}\n\n\t\treturn path;\n\t},\n\n\tdirname(path: string): string {\n\t\tvalidateString(path, \"path\");\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn \".\";\n\t\t}\n\t\tlet rootEnd = -1;\n\t\tlet offset = 0;\n\t\tconst code = path.charCodeAt(0);\n\n\t\tif (len === 1) {\n\t\t\t// `path` contains just a path separator, exit early to avoid\n\t\t\t// unnecessary work or a dot.\n\t\t\treturn isPathSeparator(code) ? path : \".\";\n\t\t}\n\n\t\t// Try to match a root\n\t\tif (isPathSeparator(code)) {\n\t\t\t// Possible UNC root\n\n\t\t\trootEnd = offset = 1;\n\n\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t// Matched double path separator at beginning\n\t\t\t\tlet j = 2;\n\t\t\t\tlet last = j;\n\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t// Matched!\n\t\t\t\t\tlast = j;\n\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\twhile (\n\t\t\t\t\t\t\tj < len &&\n\t\t\t\t\t\t\t!isPathSeparator(path.charCodeAt(j))\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\treturn path;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j !== last) {\n\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\n\t\t\t\t\t\t\t// Offset by 1 to include the separator after the UNC root to\n\t\t\t\t\t\t\t// treat it as a \"normal root\" on top of a (UNC) root\n\t\t\t\t\t\t\trootEnd = offset = j + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Possible device root\n\t\t} else if (\n\t\t\tisWindowsDeviceRoot(code) &&\n\t\t\tpath.charCodeAt(1) === CHAR_COLON\n\t\t) {\n\t\t\trootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;\n\t\t\toffset = rootEnd;\n\t\t}\n\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tfor (let i = len - 1; i >= offset; --i) {\n\t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tend = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We saw the first non-path separator\n\t\t\t\tmatchedSlash = false;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\tif (rootEnd === -1) {\n\t\t\t\treturn \".\";\n\t\t\t}\n\n\t\t\tend = rootEnd;\n\t\t}\n\t\treturn path.slice(0, end);\n\t},\n\n\tbasename(path: string, suffix?: string): string {\n\t\tif (suffix !== undefined) {\n\t\t\tvalidateString(suffix, \"suffix\");\n\t\t}\n\t\tvalidateString(path, \"path\");\n\t\tlet start = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i;\n\n\t\t// Check for a drive letter prefix so as not to mistake the following\n\t\t// path separator as an extra separator at the end of the path that can be\n\t\t// disregarded\n\t\tif (\n\t\t\tpath.length >= 2 &&\n\t\t\tisWindowsDeviceRoot(path.charCodeAt(0)) &&\n\t\t\tpath.charCodeAt(1) === CHAR_COLON\n\t\t) {\n\t\t\tstart = 2;\n\t\t}\n\n\t\tif (\n\t\t\tsuffix !== undefined &&\n\t\t\tsuffix.length > 0 &&\n\t\t\tsuffix.length <= path.length\n\t\t) {\n\t\t\tif (suffix === path) {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t\tlet extIdx = suffix.length - 1;\n\t\t\tlet firstNonSlashEnd = -1;\n\t\t\tfor (i = path.length - 1; i >= start; --i) {\n\t\t\t\tconst code = path.charCodeAt(i);\n\t\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (firstNonSlashEnd === -1) {\n\t\t\t\t\t\t// We saw the first non-path separator, remember this index in case\n\t\t\t\t\t\t// we need it if the extension ends up not matching\n\t\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\t\tfirstNonSlashEnd = i + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (extIdx >= 0) {\n\t\t\t\t\t\t// Try to match the explicit extension\n\t\t\t\t\t\tif (code === suffix.charCodeAt(extIdx)) {\n\t\t\t\t\t\t\tif (--extIdx === -1) {\n\t\t\t\t\t\t\t\t// We matched the extension, so mark this as the end of our path\n\t\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\t\tend = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Extension does not match, so our result is the entire path\n\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\textIdx = -1;\n\t\t\t\t\t\t\tend = firstNonSlashEnd;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (start === end) {\n\t\t\t\tend = firstNonSlashEnd;\n\t\t\t} else if (end === -1) {\n\t\t\t\tend = path.length;\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t}\n\t\tfor (i = path.length - 1; i >= start; --i) {\n\t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// path component\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\treturn \"\";\n\t\t}\n\t\treturn path.slice(start, end);\n\t},\n\n\textname(path: string): string {\n\t\tvalidateString(path, \"path\");\n\t\tlet start = 0;\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Check for a drive letter prefix so as not to mistake the following\n\t\t// path separator as an extra separator at the end of the path that can be\n\t\t// disregarded\n\n\t\tif (\n\t\t\tpath.length >= 2 &&\n\t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n\t\t\tisWindowsDeviceRoot(path.charCodeAt(0))\n\t\t) {\n\t\t\tstart = startPart = 2;\n\t\t}\n\n\t\tfor (let i = path.length - 1; i >= start; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t} else if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (\n\t\t\tstartDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)\n\t\t) {\n\t\t\treturn \"\";\n\t\t}\n\t\treturn path.slice(startDot, end);\n\t},\n\n\tformat: _format.bind(null, \"\\\\\"),\n\n\tparse(path) {\n\t\tvalidateString(path, \"path\");\n\n\t\tconst ret = { root: \"\", dir: \"\", base: \"\", ext: \"\", name: \"\" };\n\t\tif (path.length === 0) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tconst len = path.length;\n\t\tlet rootEnd = 0;\n\t\tlet code = path.charCodeAt(0);\n\n\t\tif (len === 1) {\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// `path` contains just a path separator, exit early to avoid\n\t\t\t\t// unnecessary work\n\t\t\t\tret.root = ret.dir = path;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tret.base = ret.name = path;\n\t\t\treturn ret;\n\t\t}\n\t\t// Try to match a root\n\t\tif (isPathSeparator(code)) {\n\t\t\t// Possible UNC root\n\n\t\t\trootEnd = 1;\n\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t// Matched double path separator at beginning\n\t\t\t\tlet j = 2;\n\t\t\t\tlet last = j;\n\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t// Matched!\n\t\t\t\t\tlast = j;\n\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\twhile (\n\t\t\t\t\t\t\tj < len &&\n\t\t\t\t\t\t\t!isPathSeparator(path.charCodeAt(j))\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t} else if (j !== last) {\n\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\t\t\t\t\t\t\trootEnd = j + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (\n\t\t\tisWindowsDeviceRoot(code) &&\n\t\t\tpath.charCodeAt(1) === CHAR_COLON\n\t\t) {\n\t\t\t// Possible device root\n\t\t\tif (len <= 2) {\n\t\t\t\t// `path` contains just a drive root, exit early to avoid\n\t\t\t\t// unnecessary work\n\t\t\t\tret.root = ret.dir = path;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\trootEnd = 2;\n\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\tif (len === 3) {\n\t\t\t\t\t// `path` contains just a drive root, exit early to avoid\n\t\t\t\t\t// unnecessary work\n\t\t\t\t\tret.root = ret.dir = path;\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\trootEnd = 3;\n\t\t\t}\n\t\t}\n\t\tif (rootEnd > 0) {\n\t\t\tret.root = path.slice(0, rootEnd);\n\t\t}\n\n\t\tlet startDot = -1;\n\t\tlet startPart = rootEnd;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i = path.length - 1;\n\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Get non-dir info\n\t\tfor (; i >= rootEnd; --i) {\n\t\t\tcode = path.charCodeAt(i);\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t} else if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (end !== -1) {\n\t\t\tif (\n\t\t\t\tstartDot === -1 ||\n\t\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\t\tpreDotState === 0 ||\n\t\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t\t(preDotState === 1 &&\n\t\t\t\t\tstartDot === end - 1 &&\n\t\t\t\t\tstartDot === startPart + 1)\n\t\t\t) {\n\t\t\t\tret.base = ret.name = path.slice(startPart, end);\n\t\t\t} else {\n\t\t\t\tret.name = path.slice(startPart, startDot);\n\t\t\t\tret.base = path.slice(startPart, end);\n\t\t\t\tret.ext = path.slice(startDot, end);\n\t\t\t}\n\t\t}\n\n\t\t// If the directory is the root, use the entire root as the `dir` including\n\t\t// the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n\t\t// trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n\t\tif (startPart > 0 && startPart !== rootEnd) {\n\t\t\tret.dir = path.slice(0, startPart - 1);\n\t\t} else {\n\t\t\tret.dir = ret.root;\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tsep: \"\\\\\",\n\tdelimiter: \";\",\n\twin32: null,\n\tposix: null,\n};\n\nconst posixCwd = (() => {\n\tif (platformIsWin32) {\n\t\t// Converts Windows' backslash path separators to POSIX forward slashes\n\t\t// and truncates any drive indicator\n\t\tconst regexp = /\\\\/g;\n\t\treturn () => {\n\t\t\tconst cwd = process.cwd().replace(regexp, \"/\");\n\t\t\treturn cwd.slice(cwd.indexOf(\"/\"));\n\t\t};\n\t}\n\n\t// We're already on POSIX, no need for any transformations\n\treturn () => process.cwd();\n})();\n\nexport const posix: IPath = {\n\t// path.resolve([from ...], to)\n\tresolve(...pathSegments: string[]): string {\n\t\tlet resolvedPath = \"\";\n\t\tlet resolvedAbsolute = false;\n\n\t\tfor (\n\t\t\tlet i = pathSegments.length - 1;\n\t\t\ti >= -1 && !resolvedAbsolute;\n\t\t\ti--\n\t\t) {\n\t\t\tconst path = i >= 0 ? pathSegments[i] : posixCwd();\n\n\t\t\tvalidateString(path, `paths[${i}]`);\n\n\t\t\t// Skip empty entries\n\t\t\tif (path.length === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tresolvedPath = `${path}/${resolvedPath}`;\n\t\t\tresolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\t}\n\n\t\t// At this point the path should be resolved to a full absolute path, but\n\t\t// handle relative paths to be safe (might happen when process.cwd() fails)\n\n\t\t// Normalize the path\n\t\tresolvedPath = normalizeString(\n\t\t\tresolvedPath,\n\t\t\t!resolvedAbsolute,\n\t\t\t\"/\",\n\t\t\tisPosixPathSeparator,\n\t\t);\n\n\t\tif (resolvedAbsolute) {\n\t\t\treturn `/${resolvedPath}`;\n\t\t}\n\t\treturn resolvedPath.length > 0 ? resolvedPath : \".\";\n\t},\n\n\tnormalize(path: string): string {\n\t\tvalidateString(path, \"path\");\n\n\t\tif (path.length === 0) {\n\t\t\treturn \".\";\n\t\t}\n\n\t\tconst isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tconst trailingSeparator =\n\t\t\tpath.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\n\n\t\t// Normalize the path\n\t\tpath = normalizeString(path, !isAbsolute, \"/\", isPosixPathSeparator);\n\n\t\tif (path.length === 0) {\n\t\t\tif (isAbsolute) {\n\t\t\t\treturn \"/\";\n\t\t\t}\n\t\t\treturn trailingSeparator ? \"./\" : \".\";\n\t\t}\n\t\tif (trailingSeparator) {\n\t\t\tpath += \"/\";\n\t\t}\n\n\t\treturn isAbsolute ? `/${path}` : path;\n\t},\n\n\tisAbsolute(path: string): boolean {\n\t\tvalidateString(path, \"path\");\n\t\treturn path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t},\n\n\tjoin(...paths: string[]): string {\n\t\tif (paths.length === 0) {\n\t\t\treturn \".\";\n\t\t}\n\t\tlet joined;\n\t\tfor (let i = 0; i < paths.length; ++i) {\n\t\t\tconst arg = paths[i];\n\t\t\tvalidateString(arg, \"path\");\n\t\t\tif (arg.length > 0) {\n\t\t\t\tif (joined === undefined) {\n\t\t\t\t\tjoined = arg;\n\t\t\t\t} else {\n\t\t\t\t\tjoined += `/${arg}`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (joined === undefined) {\n\t\t\treturn \".\";\n\t\t}\n\t\treturn posix.normalize(joined);\n\t},\n\n\trelative(from: string, to: string): string {\n\t\tvalidateString(from, \"from\");\n\t\tvalidateString(to, \"to\");\n\n\t\tif (from === to) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\t// Trim leading forward slashes.\n\t\tfrom = posix.resolve(from);\n\t\tto = posix.resolve(to);\n\n\t\tif (from === to) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tconst fromStart = 1;\n\t\tconst fromEnd = from.length;\n\t\tconst fromLen = fromEnd - fromStart;\n\t\tconst toStart = 1;\n\t\tconst toLen = to.length - toStart;\n\n\t\t// Compare paths to find the longest common path from root\n\t\tconst length = fromLen < toLen ? fromLen : toLen;\n\t\tlet lastCommonSep = -1;\n\t\tlet i = 0;\n\t\tfor (; i < length; i++) {\n\t\t\tconst fromCode = from.charCodeAt(fromStart + i);\n\t\t\tif (fromCode !== to.charCodeAt(toStart + i)) {\n\t\t\t\tbreak;\n\t\t\t} else if (fromCode === CHAR_FORWARD_SLASH) {\n\t\t\t\tlastCommonSep = i;\n\t\t\t}\n\t\t}\n\t\tif (i === length) {\n\t\t\tif (toLen > length) {\n\t\t\t\tif (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// We get here if `from` is the exact base path for `to`.\n\t\t\t\t\t// For example: from='/foo/bar'; to='/foo/bar/baz'\n\t\t\t\t\treturn to.slice(toStart + i + 1);\n\t\t\t\t}\n\t\t\t\tif (i === 0) {\n\t\t\t\t\t// We get here if `from` is the root\n\t\t\t\t\t// For example: from='/'; to='/foo'\n\t\t\t\t\treturn to.slice(toStart + i);\n\t\t\t\t}\n\t\t\t} else if (fromLen > length) {\n\t\t\t\tif (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// We get here if `to` is the exact base path for `from`.\n\t\t\t\t\t// For example: from='/foo/bar/baz'; to='/foo/bar'\n\t\t\t\t\tlastCommonSep = i;\n\t\t\t\t} else if (i === 0) {\n\t\t\t\t\t// We get here if `to` is the root.\n\t\t\t\t\t// For example: from='/foo/bar'; to='/'\n\t\t\t\t\tlastCommonSep = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet out = \"\";\n\t\t// Generate the relative path based on the path difference between `to`\n\t\t// and `from`.\n\t\tfor (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n\t\t\tif (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\tout += out.length === 0 ? \"..\" : \"/..\";\n\t\t\t}\n\t\t}\n\n\t\t// Lastly, append the rest of the destination (`to`) path that comes after\n\t\t// the common path parts.\n\t\treturn `${out}${to.slice(toStart + lastCommonSep)}`;\n\t},\n\n\ttoNamespacedPath(path: string): string {\n\t\t// Non-op on posix systems\n\t\treturn path;\n\t},\n\n\tdirname(path: string): string {\n\t\tvalidateString(path, \"path\");\n\t\tif (path.length === 0) {\n\t\t\treturn \".\";\n\t\t}\n\t\tconst hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tfor (let i = path.length - 1; i >= 1; --i) {\n\t\t\tif (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tend = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We saw the first non-path separator\n\t\t\t\tmatchedSlash = false;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\treturn hasRoot ? \"/\" : \".\";\n\t\t}\n\t\tif (hasRoot && end === 1) {\n\t\t\treturn \"//\";\n\t\t}\n\t\treturn path.slice(0, end);\n\t},\n\n\tbasename(path: string, suffix?: string): string {\n\t\tif (suffix !== undefined) {\n\t\t\tvalidateString(suffix, \"ext\");\n\t\t}\n\t\tvalidateString(path, \"path\");\n\n\t\tlet start = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i;\n\n\t\tif (\n\t\t\tsuffix !== undefined &&\n\t\t\tsuffix.length > 0 &&\n\t\t\tsuffix.length <= path.length\n\t\t) {\n\t\t\tif (suffix === path) {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t\tlet extIdx = suffix.length - 1;\n\t\t\tlet firstNonSlashEnd = -1;\n\t\t\tfor (i = path.length - 1; i >= 0; --i) {\n\t\t\t\tconst code = path.charCodeAt(i);\n\t\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (firstNonSlashEnd === -1) {\n\t\t\t\t\t\t// We saw the first non-path separator, remember this index in case\n\t\t\t\t\t\t// we need it if the extension ends up not matching\n\t\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\t\tfirstNonSlashEnd = i + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (extIdx >= 0) {\n\t\t\t\t\t\t// Try to match the explicit extension\n\t\t\t\t\t\tif (code === suffix.charCodeAt(extIdx)) {\n\t\t\t\t\t\t\tif (--extIdx === -1) {\n\t\t\t\t\t\t\t\t// We matched the extension, so mark this as the end of our path\n\t\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\t\tend = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Extension does not match, so our result is the entire path\n\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\textIdx = -1;\n\t\t\t\t\t\t\tend = firstNonSlashEnd;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (start === end) {\n\t\t\t\tend = firstNonSlashEnd;\n\t\t\t} else if (end === -1) {\n\t\t\t\tend = path.length;\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t}\n\t\tfor (i = path.length - 1; i >= 0; --i) {\n\t\t\tif (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// path component\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\treturn \"\";\n\t\t}\n\t\treturn path.slice(start, end);\n\t},\n\n\textname(path: string): string {\n\t\tvalidateString(path, \"path\");\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\t\tfor (let i = path.length - 1; i >= 0; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t} else if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (\n\t\t\tstartDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)\n\t\t) {\n\t\t\treturn \"\";\n\t\t}\n\t\treturn path.slice(startDot, end);\n\t},\n\n\tformat: _format.bind(null, \"/\"),\n\n\tparse(path: string): ParsedPath {\n\t\tvalidateString(path, \"path\");\n\n\t\tconst ret = { root: \"\", dir: \"\", base: \"\", ext: \"\", name: \"\" };\n\t\tif (path.length === 0) {\n\t\t\treturn ret;\n\t\t}\n\t\tconst isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tlet start;\n\t\tif (isAbsolute) {\n\t\t\tret.root = \"/\";\n\t\t\tstart = 1;\n\t\t} else {\n\t\t\tstart = 0;\n\t\t}\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i = path.length - 1;\n\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Get non-dir info\n\t\tfor (; i >= start; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t} else if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (end !== -1) {\n\t\t\tconst start = startPart === 0 && isAbsolute ? 1 : startPart;\n\t\t\tif (\n\t\t\t\tstartDot === -1 ||\n\t\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\t\tpreDotState === 0 ||\n\t\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t\t(preDotState === 1 &&\n\t\t\t\t\tstartDot === end - 1 &&\n\t\t\t\t\tstartDot === startPart + 1)\n\t\t\t) {\n\t\t\t\tret.base = ret.name = path.slice(start, end);\n\t\t\t} else {\n\t\t\t\tret.name = path.slice(start, startDot);\n\t\t\t\tret.base = path.slice(start, end);\n\t\t\t\tret.ext = path.slice(startDot, end);\n\t\t\t}\n\t\t}\n\n\t\tif (startPart > 0) {\n\t\t\tret.dir = path.slice(0, startPart - 1);\n\t\t} else if (isAbsolute) {\n\t\t\tret.dir = \"/\";\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tsep: \"/\",\n\tdelimiter: \":\",\n\twin32: null,\n\tposix: null,\n};\n\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\n\nexport const normalize = platformIsWin32 ? win32.normalize : posix.normalize;\nexport const isAbsolute = platformIsWin32 ? win32.isAbsolute : posix.isAbsolute;\nexport const join = platformIsWin32 ? win32.join : posix.join;\nexport const resolve = platformIsWin32 ? win32.resolve : posix.resolve;\nexport const relative = platformIsWin32 ? win32.relative : posix.relative;\nexport const dirname = platformIsWin32 ? win32.dirname : posix.dirname;\nexport const basename = platformIsWin32 ? win32.basename : posix.basename;\nexport const extname = platformIsWin32 ? win32.extname : posix.extname;\nexport const format = platformIsWin32 ? win32.format : posix.format;\nexport const parse = platformIsWin32 ? win32.parse : posix.parse;\nexport const toNamespacedPath = platformIsWin32\n\t? win32.toNamespacedPath\n\t: posix.toNamespacedPath;\nexport const sep = platformIsWin32 ? win32.sep : posix.sep;\nexport const delimiter = platformIsWin32 ? win32.delimiter : posix.delimiter;\n"],
  "mappings": "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",
  "names": ["isPathSeparator", "sep", "isAbsolute", "start"]
}
