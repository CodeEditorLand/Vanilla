var o=class{unexpectedErrorHandler;listeners;constructor(){this.listeners=[],this.unexpectedErrorHandler=function(r){setTimeout(()=>{throw r.stack?t.isErrorNoTelemetry(r)?new t(r.message+`

`+r.stack):new Error(r.message+`

`+r.stack):r},0)}}addListener(r){return this.listeners.push(r),()=>{this._removeListener(r)}}emit(r){this.listeners.forEach(e=>{e(r)})}_removeListener(r){this.listeners.splice(this.listeners.indexOf(r),1)}setUnexpectedErrorHandler(r){this.unexpectedErrorHandler=r}getUnexpectedErrorHandler(){return this.unexpectedErrorHandler}onUnexpectedError(r){this.unexpectedErrorHandler(r),this.emit(r)}onUnexpectedExternalError(r){this.unexpectedErrorHandler(r)}},a=new o;var t=class n extends Error{name;constructor(r){super(r),this.name="CodeExpectedError"}static fromError(r){if(r instanceof n)return r;let e=new n;return e.message=r.message,e.stack=r.stack,e}static isErrorNoTelemetry(r){return r.name==="CodeExpectedError"}},i=class n extends Error{constructor(r){super(r||"An unexpected bug occurred."),Object.setPrototypeOf(this,n.prototype)}};var s=class{_isOccupied=!1;runExclusivelyOrSkip(r){if(!this._isOccupied){this._isOccupied=!0;try{r()}finally{this._isOccupied=!1}}}runExclusivelyOrThrow(r){if(this._isOccupied)throw new i("ReentrancyBarrier: reentrant call detected!");this._isOccupied=!0;try{r()}finally{this._isOccupied=!1}}get isOccupied(){return this._isOccupied}makeExclusiveOrSkip(r){return(...e)=>{if(!this._isOccupied){this._isOccupied=!0;try{return r(...e)}finally{this._isOccupied=!1}}}}};export{s as ReentrancyBarrier};
