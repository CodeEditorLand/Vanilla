function P(n,t,e){return Math.min(Math.max(n,t),e)}function T(n,t){return(t+n%t)%t}var d=class{_next=0;getNext(){return this._next++}},f=class{_n=1;_val=0;update(t){return this._val=this._val+(t-this._val)/this._n,this._n+=1,this._val}get value(){return this._val}},y=class{_n=0;_val=0;_values=[];_index=0;_sum=0;constructor(t){this._values=new Array(t),this._values.fill(0,0,t)}update(t){let e=this._values[this._index];return this._values[this._index]=t,this._index=(this._index+1)%this._values.length,this._sum-=e,this._sum+=t,this._n<this._values.length&&(this._n+=1),this._val=this._sum/this._n,this._val}get value(){return this._val}};function V(n,t,e,a,g,D,M,N){let r=M-e,s=N-a,u=g-e,i=D-a,h=n-e,m=t-a,v=r*r+s*s,_=r*u+s*i,o=r*h+s*m,l=u*u+i*i,b=u*h+i*m,c=1/(v*l-_*_),p=(l*o-_*b)*c,x=(v*b-_*o)*c;return p>=0&&x>=0&&p+x<1}export{d as Counter,f as MovingAverage,y as SlidingWindowAverage,P as clamp,V as isPointWithinTriangle,T as rot};
