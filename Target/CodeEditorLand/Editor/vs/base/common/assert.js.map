{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/assert.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError, onUnexpectedError } from \"./errors.js\";\n\n/**\n * Throws an error with the provided message if the provided value does not evaluate to a true Javascript value.\n *\n * @deprecated Use `assert(...)` instead.\n * This method is usually used like this:\n * ```ts\n * import * as assert from 'vs/base/common/assert';\n * assert.ok(...);\n * ```\n *\n * However, `assert` in that example is a user chosen name.\n * There is no tooling for generating such an import statement.\n * Thus, the `assert(...)` function should be used instead.\n */\nexport function ok(value?: unknown, message?: string) {\n\tif (!value) {\n\t\tthrow new Error(\n\t\t\tmessage ? `Assertion failed (${message})` : \"Assertion Failed\",\n\t\t);\n\t}\n}\n\nexport function assertNever(value: never, message = \"Unreachable\"): never {\n\tthrow new Error(message);\n}\n\nexport function assert(\n\tcondition: boolean,\n\tmessage = \"unexpected state\",\n): asserts condition {\n\tif (!condition) {\n\t\tthrow new BugIndicatingError(`Assertion Failed: ${message}`);\n\t}\n}\n\n/**\n * Like assert, but doesn't throw.\n */\nexport function softAssert(condition: boolean): void {\n\tif (!condition) {\n\t\tonUnexpectedError(new BugIndicatingError(\"Soft Assertion Failed\"));\n\t}\n}\n\n/**\n * condition must be side-effect free!\n */\nexport function assertFn(condition: () => boolean): void {\n\tif (!condition()) {\n\t\t// eslint-disable-next-line no-debugger\n\t\tdebugger;\n\t\t// Reevaluate `condition` again to make debugging easier\n\t\tcondition();\n\t\tonUnexpectedError(new BugIndicatingError(\"Assertion Failed\"));\n\t}\n}\n\nexport function checkAdjacentItems<T>(\n\titems: readonly T[],\n\tpredicate: (item1: T, item2: T) => boolean,\n): boolean {\n\tlet i = 0;\n\twhile (i < items.length - 1) {\n\t\tconst a = items[i];\n\t\tconst b = items[i + 1];\n\t\tif (!predicate(a, b)) {\n\t\t\treturn false;\n\t\t}\n\t\ti++;\n\t}\n\treturn true;\n}\n"],
  "mappings": ";;AAKA,SAAS,oBAAoB,yBAAyB;AAgB/C,SAAS,GAAG,OAAiB,SAAkB;AACrD,MAAI,CAAC,OAAO;AACX,UAAM,IAAI;AAAA,MACT,UAAU,qBAAqB,OAAO,MAAM;AAAA,IAC7C;AAAA,EACD;AACD;AANgB;AAQT,SAAS,YAAY,OAAc,UAAU,eAAsB;AACzE,QAAM,IAAI,MAAM,OAAO;AACxB;AAFgB;AAIT,SAAS,OACf,WACA,UAAU,oBACU;AACpB,MAAI,CAAC,WAAW;AACf,UAAM,IAAI,mBAAmB,qBAAqB,OAAO,EAAE;AAAA,EAC5D;AACD;AAPgB;AAYT,SAAS,WAAW,WAA0B;AACpD,MAAI,CAAC,WAAW;AACf,sBAAkB,IAAI,mBAAmB,uBAAuB,CAAC;AAAA,EAClE;AACD;AAJgB;AAST,SAAS,SAAS,WAAgC;AACxD,MAAI,CAAC,UAAU,GAAG;AAEjB;AAEA,cAAU;AACV,sBAAkB,IAAI,mBAAmB,kBAAkB,CAAC;AAAA,EAC7D;AACD;AARgB;AAUT,SAAS,mBACf,OACA,WACU;AACV,MAAI,IAAI;AACR,SAAO,IAAI,MAAM,SAAS,GAAG;AAC5B,UAAM,IAAI,MAAM,CAAC;AACjB,UAAM,IAAI,MAAM,IAAI,CAAC;AACrB,QAAI,CAAC,UAAU,GAAG,CAAC,GAAG;AACrB,aAAO;AAAA,IACR;AACA;AAAA,EACD;AACA,SAAO;AACR;AAdgB;",
  "names": []
}
