{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/diff/diff.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DiffChange } from './diffChange.js';\nimport { stringHash } from '../hash.js';\nimport { Constants } from '../uint.js';\n\nexport class StringDiffSequence implements ISequence {\n\n\tconstructor(private source: string) { }\n\n\tgetElements(): Int32Array | number[] | string[] {\n\t\tconst source = this.source;\n\t\tconst characters = new Int32Array(source.length);\n\t\tfor (let i = 0, len = source.length; i < len; i++) {\n\t\t\tcharacters[i] = source.charCodeAt(i);\n\t\t}\n\t\treturn characters;\n\t}\n}\n\nexport function stringDiff(original: string, modified: string, pretty: boolean): IDiffChange[] {\n\treturn new LcsDiff(new StringDiffSequence(original), new StringDiffSequence(modified)).ComputeDiff(pretty).changes;\n}\n\nexport interface ISequence {\n\tgetElements(): Int32Array | number[] | string[];\n\tgetStrictElement?(index: number): string;\n}\n\nexport interface IDiffChange {\n\t/**\n\t * The position of the first element in the original sequence which\n\t * this change affects.\n\t */\n\toriginalStart: number;\n\n\t/**\n\t * The number of elements from the original sequence which were\n\t * affected.\n\t */\n\toriginalLength: number;\n\n\t/**\n\t * The position of the first element in the modified sequence which\n\t * this change affects.\n\t */\n\tmodifiedStart: number;\n\n\t/**\n\t * The number of elements from the modified sequence which were\n\t * affected (added).\n\t */\n\tmodifiedLength: number;\n}\n\nexport interface IContinueProcessingPredicate {\n\t(furthestOriginalIndex: number, matchLengthOfLongest: number): boolean;\n}\n\nexport interface IDiffResult {\n\tquitEarly: boolean;\n\tchanges: IDiffChange[];\n}\n\n//\n// The code below has been ported from a C# implementation in VS\n//\n\nclass Debug {\n\n\tpublic static Assert(condition: boolean, message: string): void {\n\t\tif (!condition) {\n\t\t\tthrow new Error(message);\n\t\t}\n\t}\n}\n\nclass MyArray {\n\t/**\n\t * Copies a range of elements from an Array starting at the specified source index and pastes\n\t * them to another Array starting at the specified destination index. The length and the indexes\n\t * are specified as 64-bit integers.\n\t * sourceArray:\n\t *\t\tThe Array that contains the data to copy.\n\t * sourceIndex:\n\t *\t\tA 64-bit integer that represents the index in the sourceArray at which copying begins.\n\t * destinationArray:\n\t *\t\tThe Array that receives the data.\n\t * destinationIndex:\n\t *\t\tA 64-bit integer that represents the index in the destinationArray at which storing begins.\n\t * length:\n\t *\t\tA 64-bit integer that represents the number of elements to copy.\n\t */\n\tpublic static Copy(sourceArray: any[], sourceIndex: number, destinationArray: any[], destinationIndex: number, length: number) {\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tdestinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n\t\t}\n\t}\n\tpublic static Copy2(sourceArray: Int32Array, sourceIndex: number, destinationArray: Int32Array, destinationIndex: number, length: number) {\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tdestinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n\t\t}\n\t}\n}\n\n//*****************************************************************************\n// LcsDiff.cs\n//\n// An implementation of the difference algorithm described in\n// \"An O(ND) Difference Algorithm and its variations\" by Eugene W. Myers\n//\n// Copyright (C) 2008 Microsoft Corporation @minifier_do_not_preserve\n//*****************************************************************************\n\n// Our total memory usage for storing history is (worst-case):\n// 2 * [(MaxDifferencesHistory + 1) * (MaxDifferencesHistory + 1) - 1] * sizeof(int)\n// 2 * [1448*1448 - 1] * 4 = 16773624 = 16MB\nconst enum LocalConstants {\n\tMaxDifferencesHistory = 1447\n}\n\n/**\n * A utility class which helps to create the set of DiffChanges from\n * a difference operation. This class accepts original DiffElements and\n * modified DiffElements that are involved in a particular change. The\n * MarkNextChange() method can be called to mark the separation between\n * distinct changes. At the end, the Changes property can be called to retrieve\n * the constructed changes.\n */\nclass DiffChangeHelper {\n\n\tprivate m_changes: DiffChange[];\n\tprivate m_originalStart: number;\n\tprivate m_modifiedStart: number;\n\tprivate m_originalCount: number;\n\tprivate m_modifiedCount: number;\n\n\t/**\n\t * Constructs a new DiffChangeHelper for the given DiffSequences.\n\t */\n\tconstructor() {\n\t\tthis.m_changes = [];\n\t\tthis.m_originalStart = Constants.MAX_SAFE_SMALL_INTEGER;\n\t\tthis.m_modifiedStart = Constants.MAX_SAFE_SMALL_INTEGER;\n\t\tthis.m_originalCount = 0;\n\t\tthis.m_modifiedCount = 0;\n\t}\n\n\t/**\n\t * Marks the beginning of the next change in the set of differences.\n\t */\n\tpublic MarkNextChange(): void {\n\t\t// Only add to the list if there is something to add\n\t\tif (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n\t\t\t// Add the new change to our list\n\t\t\tthis.m_changes.push(new DiffChange(this.m_originalStart, this.m_originalCount,\n\t\t\t\tthis.m_modifiedStart, this.m_modifiedCount));\n\t\t}\n\n\t\t// Reset for the next change\n\t\tthis.m_originalCount = 0;\n\t\tthis.m_modifiedCount = 0;\n\t\tthis.m_originalStart = Constants.MAX_SAFE_SMALL_INTEGER;\n\t\tthis.m_modifiedStart = Constants.MAX_SAFE_SMALL_INTEGER;\n\t}\n\n\t/**\n\t * Adds the original element at the given position to the elements\n\t * affected by the current change. The modified index gives context\n\t * to the change position with respect to the original sequence.\n\t * @param originalIndex The index of the original element to add.\n\t * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.\n\t */\n\tpublic AddOriginalElement(originalIndex: number, modifiedIndex: number) {\n\t\t// The 'true' start index is the smallest of the ones we've seen\n\t\tthis.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n\t\tthis.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n\n\t\tthis.m_originalCount++;\n\t}\n\n\t/**\n\t * Adds the modified element at the given position to the elements\n\t * affected by the current change. The original index gives context\n\t * to the change position with respect to the modified sequence.\n\t * @param originalIndex The index of the original element that provides corresponding position in the original sequence.\n\t * @param modifiedIndex The index of the modified element to add.\n\t */\n\tpublic AddModifiedElement(originalIndex: number, modifiedIndex: number): void {\n\t\t// The 'true' start index is the smallest of the ones we've seen\n\t\tthis.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n\t\tthis.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n\n\t\tthis.m_modifiedCount++;\n\t}\n\n\t/**\n\t * Retrieves all of the changes marked by the class.\n\t */\n\tpublic getChanges(): DiffChange[] {\n\t\tif (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n\t\t\t// Finish up on whatever is left\n\t\t\tthis.MarkNextChange();\n\t\t}\n\n\t\treturn this.m_changes;\n\t}\n\n\t/**\n\t * Retrieves all of the changes marked by the class in the reverse order\n\t */\n\tpublic getReverseChanges(): DiffChange[] {\n\t\tif (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n\t\t\t// Finish up on whatever is left\n\t\t\tthis.MarkNextChange();\n\t\t}\n\n\t\tthis.m_changes.reverse();\n\t\treturn this.m_changes;\n\t}\n\n}\n\n/**\n * An implementation of the difference algorithm described in\n * \"An O(ND) Difference Algorithm and its variations\" by Eugene W. Myers\n */\nexport class LcsDiff {\n\n\tprivate readonly ContinueProcessingPredicate: IContinueProcessingPredicate | null;\n\n\tprivate readonly _originalSequence: ISequence;\n\tprivate readonly _modifiedSequence: ISequence;\n\tprivate readonly _hasStrings: boolean;\n\tprivate readonly _originalStringElements: string[];\n\tprivate readonly _originalElementsOrHash: Int32Array;\n\tprivate readonly _modifiedStringElements: string[];\n\tprivate readonly _modifiedElementsOrHash: Int32Array;\n\n\tprivate m_forwardHistory: Int32Array[];\n\tprivate m_reverseHistory: Int32Array[];\n\n\t/**\n\t * Constructs the DiffFinder\n\t */\n\tconstructor(originalSequence: ISequence, modifiedSequence: ISequence, continueProcessingPredicate: IContinueProcessingPredicate | null = null) {\n\t\tthis.ContinueProcessingPredicate = continueProcessingPredicate;\n\n\t\tthis._originalSequence = originalSequence;\n\t\tthis._modifiedSequence = modifiedSequence;\n\n\t\tconst [originalStringElements, originalElementsOrHash, originalHasStrings] = LcsDiff._getElements(originalSequence);\n\t\tconst [modifiedStringElements, modifiedElementsOrHash, modifiedHasStrings] = LcsDiff._getElements(modifiedSequence);\n\n\t\tthis._hasStrings = (originalHasStrings && modifiedHasStrings);\n\t\tthis._originalStringElements = originalStringElements;\n\t\tthis._originalElementsOrHash = originalElementsOrHash;\n\t\tthis._modifiedStringElements = modifiedStringElements;\n\t\tthis._modifiedElementsOrHash = modifiedElementsOrHash;\n\n\t\tthis.m_forwardHistory = [];\n\t\tthis.m_reverseHistory = [];\n\t}\n\n\tprivate static _isStringArray(arr: Int32Array | number[] | string[]): arr is string[] {\n\t\treturn (arr.length > 0 && typeof arr[0] === 'string');\n\t}\n\n\tprivate static _getElements(sequence: ISequence): [string[], Int32Array, boolean] {\n\t\tconst elements = sequence.getElements();\n\n\t\tif (LcsDiff._isStringArray(elements)) {\n\t\t\tconst hashes = new Int32Array(elements.length);\n\t\t\tfor (let i = 0, len = elements.length; i < len; i++) {\n\t\t\t\thashes[i] = stringHash(elements[i], 0);\n\t\t\t}\n\t\t\treturn [elements, hashes, true];\n\t\t}\n\n\t\tif (elements instanceof Int32Array) {\n\t\t\treturn [[], elements, false];\n\t\t}\n\n\t\treturn [[], new Int32Array(elements), false];\n\t}\n\n\tprivate ElementsAreEqual(originalIndex: number, newIndex: number): boolean {\n\t\tif (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true);\n\t}\n\n\tprivate ElementsAreStrictEqual(originalIndex: number, newIndex: number): boolean {\n\t\tif (!this.ElementsAreEqual(originalIndex, newIndex)) {\n\t\t\treturn false;\n\t\t}\n\t\tconst originalElement = LcsDiff._getStrictElement(this._originalSequence, originalIndex);\n\t\tconst modifiedElement = LcsDiff._getStrictElement(this._modifiedSequence, newIndex);\n\t\treturn (originalElement === modifiedElement);\n\t}\n\n\tprivate static _getStrictElement(sequence: ISequence, index: number): string | null {\n\t\tif (typeof sequence.getStrictElement === 'function') {\n\t\t\treturn sequence.getStrictElement(index);\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate OriginalElementsAreEqual(index1: number, index2: number): boolean {\n\t\tif (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2]) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : true);\n\t}\n\n\tprivate ModifiedElementsAreEqual(index1: number, index2: number): boolean {\n\t\tif (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2]) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : true);\n\t}\n\n\tpublic ComputeDiff(pretty: boolean): IDiffResult {\n\t\treturn this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);\n\t}\n\n\t/**\n\t * Computes the differences between the original and modified input\n\t * sequences on the bounded range.\n\t * @returns An array of the differences between the two input sequences.\n\t */\n\tprivate _ComputeDiff(originalStart: number, originalEnd: number, modifiedStart: number, modifiedEnd: number, pretty: boolean): IDiffResult {\n\t\tconst quitEarlyArr = [false];\n\t\tlet changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);\n\n\t\tif (pretty) {\n\t\t\t// We have to clean up the computed diff to be more intuitive\n\t\t\t// but it turns out this cannot be done correctly until the entire set\n\t\t\t// of diffs have been computed\n\t\t\tchanges = this.PrettifyChanges(changes);\n\t\t}\n\n\t\treturn {\n\t\t\tquitEarly: quitEarlyArr[0],\n\t\t\tchanges: changes\n\t\t};\n\t}\n\n\t/**\n\t * Private helper method which computes the differences on the bounded range\n\t * recursively.\n\t * @returns An array of the differences between the two input sequences.\n\t */\n\tprivate ComputeDiffRecursive(originalStart: number, originalEnd: number, modifiedStart: number, modifiedEnd: number, quitEarlyArr: boolean[]): DiffChange[] {\n\t\tquitEarlyArr[0] = false;\n\n\t\t// Find the start of the differences\n\t\twhile (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {\n\t\t\toriginalStart++;\n\t\t\tmodifiedStart++;\n\t\t}\n\n\t\t// Find the end of the differences\n\t\twhile (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {\n\t\t\toriginalEnd--;\n\t\t\tmodifiedEnd--;\n\t\t}\n\n\t\t// In the special case where we either have all insertions or all deletions or the sequences are identical\n\t\tif (originalStart > originalEnd || modifiedStart > modifiedEnd) {\n\t\t\tlet changes: DiffChange[];\n\n\t\t\tif (modifiedStart <= modifiedEnd) {\n\t\t\t\tDebug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n\n\t\t\t\t// All insertions\n\t\t\t\tchanges = [\n\t\t\t\t\tnew DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)\n\t\t\t\t];\n\t\t\t} else if (originalStart <= originalEnd) {\n\t\t\t\tDebug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\n\n\t\t\t\t// All deletions\n\t\t\t\tchanges = [\n\t\t\t\t\tnew DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\tDebug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n\t\t\t\tDebug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\n\n\t\t\t\t// Identical sequences - No differences\n\t\t\t\tchanges = [];\n\t\t\t}\n\n\t\t\treturn changes;\n\t\t}\n\n\t\t// This problem can be solved using the Divide-And-Conquer technique.\n\t\tconst midOriginalArr = [0];\n\t\tconst midModifiedArr = [0];\n\t\tconst result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);\n\n\t\tconst midOriginal = midOriginalArr[0];\n\t\tconst midModified = midModifiedArr[0];\n\n\t\tif (result !== null) {\n\t\t\t// Result is not-null when there was enough memory to compute the changes while\n\t\t\t// searching for the recursion point\n\t\t\treturn result;\n\t\t} else if (!quitEarlyArr[0]) {\n\t\t\t// We can break the problem down recursively by finding the changes in the\n\t\t\t// First Half:   (originalStart, modifiedStart) to (midOriginal, midModified)\n\t\t\t// Second Half:  (midOriginal + 1, minModified + 1) to (originalEnd, modifiedEnd)\n\t\t\t// NOTE: ComputeDiff() is inclusive, therefore the second range starts on the next point\n\n\t\t\tconst leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);\n\t\t\tlet rightChanges: DiffChange[] = [];\n\n\t\t\tif (!quitEarlyArr[0]) {\n\t\t\t\trightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);\n\t\t\t} else {\n\t\t\t\t// We didn't have time to finish the first half, so we don't have time to compute this half.\n\t\t\t\t// Consider the entire rest of the sequence different.\n\t\t\t\trightChanges = [\n\t\t\t\t\tnew DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)\n\t\t\t\t];\n\t\t\t}\n\n\t\t\treturn this.ConcatenateChanges(leftChanges, rightChanges);\n\t\t}\n\n\t\t// If we hit here, we quit early, and so can't return anything meaningful\n\t\treturn [\n\t\t\tnew DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\n\t\t];\n\t}\n\n\tprivate WALKTRACE(diagonalForwardBase: number, diagonalForwardStart: number, diagonalForwardEnd: number, diagonalForwardOffset: number,\n\t\tdiagonalReverseBase: number, diagonalReverseStart: number, diagonalReverseEnd: number, diagonalReverseOffset: number,\n\t\tforwardPoints: Int32Array, reversePoints: Int32Array,\n\t\toriginalIndex: number, originalEnd: number, midOriginalArr: number[],\n\t\tmodifiedIndex: number, modifiedEnd: number, midModifiedArr: number[],\n\t\tdeltaIsEven: boolean, quitEarlyArr: boolean[]\n\t): DiffChange[] {\n\t\tlet forwardChanges: DiffChange[] | null = null;\n\t\tlet reverseChanges: DiffChange[] | null = null;\n\n\t\t// First, walk backward through the forward diagonals history\n\t\tlet changeHelper = new DiffChangeHelper();\n\t\tlet diagonalMin = diagonalForwardStart;\n\t\tlet diagonalMax = diagonalForwardEnd;\n\t\tlet diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalForwardOffset;\n\t\tlet lastOriginalIndex = Constants.MIN_SAFE_SMALL_INTEGER;\n\t\tlet historyIndex = this.m_forwardHistory.length - 1;\n\n\t\tdo {\n\t\t\t// Get the diagonal index from the relative diagonal number\n\t\t\tconst diagonal = diagonalRelative + diagonalForwardBase;\n\n\t\t\t// Figure out where we came from\n\t\t\tif (diagonal === diagonalMin || (diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\n\t\t\t\t// Vertical line (the element is an insert)\n\t\t\t\toriginalIndex = forwardPoints[diagonal + 1];\n\t\t\t\tmodifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n\t\t\t\tif (originalIndex < lastOriginalIndex) {\n\t\t\t\t\tchangeHelper.MarkNextChange();\n\t\t\t\t}\n\t\t\t\tlastOriginalIndex = originalIndex;\n\t\t\t\tchangeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);\n\t\t\t\tdiagonalRelative = (diagonal + 1) - diagonalForwardBase; //Setup for the next iteration\n\t\t\t} else {\n\t\t\t\t// Horizontal line (the element is a deletion)\n\t\t\t\toriginalIndex = forwardPoints[diagonal - 1] + 1;\n\t\t\t\tmodifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n\t\t\t\tif (originalIndex < lastOriginalIndex) {\n\t\t\t\t\tchangeHelper.MarkNextChange();\n\t\t\t\t}\n\t\t\t\tlastOriginalIndex = originalIndex - 1;\n\t\t\t\tchangeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);\n\t\t\t\tdiagonalRelative = (diagonal - 1) - diagonalForwardBase; //Setup for the next iteration\n\t\t\t}\n\n\t\t\tif (historyIndex >= 0) {\n\t\t\t\tforwardPoints = this.m_forwardHistory[historyIndex];\n\t\t\t\tdiagonalForwardBase = forwardPoints[0]; //We stored this in the first spot\n\t\t\t\tdiagonalMin = 1;\n\t\t\t\tdiagonalMax = forwardPoints.length - 1;\n\t\t\t}\n\t\t} while (--historyIndex >= -1);\n\n\t\t// Ironically, we get the forward changes as the reverse of the\n\t\t// order we added them since we technically added them backwards\n\t\tforwardChanges = changeHelper.getReverseChanges();\n\n\t\tif (quitEarlyArr[0]) {\n\t\t\t// TODO: Calculate a partial from the reverse diagonals.\n\t\t\t//       For now, just assume everything after the midOriginal/midModified point is a diff\n\n\t\t\tlet originalStartPoint = midOriginalArr[0] + 1;\n\t\t\tlet modifiedStartPoint = midModifiedArr[0] + 1;\n\n\t\t\tif (forwardChanges !== null && forwardChanges.length > 0) {\n\t\t\t\tconst lastForwardChange = forwardChanges[forwardChanges.length - 1];\n\t\t\t\toriginalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());\n\t\t\t\tmodifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());\n\t\t\t}\n\n\t\t\treverseChanges = [\n\t\t\t\tnew DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1,\n\t\t\t\t\tmodifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)\n\t\t\t];\n\t\t} else {\n\t\t\t// Now walk backward through the reverse diagonals history\n\t\t\tchangeHelper = new DiffChangeHelper();\n\t\t\tdiagonalMin = diagonalReverseStart;\n\t\t\tdiagonalMax = diagonalReverseEnd;\n\t\t\tdiagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalReverseOffset;\n\t\t\tlastOriginalIndex = Constants.MAX_SAFE_SMALL_INTEGER;\n\t\t\thistoryIndex = (deltaIsEven) ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;\n\n\t\t\tdo {\n\t\t\t\t// Get the diagonal index from the relative diagonal number\n\t\t\t\tconst diagonal = diagonalRelative + diagonalReverseBase;\n\n\t\t\t\t// Figure out where we came from\n\t\t\t\tif (diagonal === diagonalMin || (diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\n\t\t\t\t\t// Horizontal line (the element is a deletion))\n\t\t\t\t\toriginalIndex = reversePoints[diagonal + 1] - 1;\n\t\t\t\t\tmodifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n\t\t\t\t\tif (originalIndex > lastOriginalIndex) {\n\t\t\t\t\t\tchangeHelper.MarkNextChange();\n\t\t\t\t\t}\n\t\t\t\t\tlastOriginalIndex = originalIndex + 1;\n\t\t\t\t\tchangeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);\n\t\t\t\t\tdiagonalRelative = (diagonal + 1) - diagonalReverseBase; //Setup for the next iteration\n\t\t\t\t} else {\n\t\t\t\t\t// Vertical line (the element is an insertion)\n\t\t\t\t\toriginalIndex = reversePoints[diagonal - 1];\n\t\t\t\t\tmodifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n\t\t\t\t\tif (originalIndex > lastOriginalIndex) {\n\t\t\t\t\t\tchangeHelper.MarkNextChange();\n\t\t\t\t\t}\n\t\t\t\t\tlastOriginalIndex = originalIndex;\n\t\t\t\t\tchangeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);\n\t\t\t\t\tdiagonalRelative = (diagonal - 1) - diagonalReverseBase; //Setup for the next iteration\n\t\t\t\t}\n\n\t\t\t\tif (historyIndex >= 0) {\n\t\t\t\t\treversePoints = this.m_reverseHistory[historyIndex];\n\t\t\t\t\tdiagonalReverseBase = reversePoints[0]; //We stored this in the first spot\n\t\t\t\t\tdiagonalMin = 1;\n\t\t\t\t\tdiagonalMax = reversePoints.length - 1;\n\t\t\t\t}\n\t\t\t} while (--historyIndex >= -1);\n\n\t\t\t// There are cases where the reverse history will find diffs that\n\t\t\t// are correct, but not intuitive, so we need shift them.\n\t\t\treverseChanges = changeHelper.getChanges();\n\t\t}\n\n\t\treturn this.ConcatenateChanges(forwardChanges, reverseChanges);\n\t}\n\n\t/**\n\t * Given the range to compute the diff on, this method finds the point:\n\t * (midOriginal, midModified)\n\t * that exists in the middle of the LCS of the two sequences and\n\t * is the point at which the LCS problem may be broken down recursively.\n\t * This method will try to keep the LCS trace in memory. If the LCS recursion\n\t * point is calculated and the full trace is available in memory, then this method\n\t * will return the change list.\n\t * @param originalStart The start bound of the original sequence range\n\t * @param originalEnd The end bound of the original sequence range\n\t * @param modifiedStart The start bound of the modified sequence range\n\t * @param modifiedEnd The end bound of the modified sequence range\n\t * @param midOriginal The middle point of the original sequence range\n\t * @param midModified The middle point of the modified sequence range\n\t * @returns The diff changes, if available, otherwise null\n\t */\n\tprivate ComputeRecursionPoint(originalStart: number, originalEnd: number, modifiedStart: number, modifiedEnd: number, midOriginalArr: number[], midModifiedArr: number[], quitEarlyArr: boolean[]) {\n\t\tlet originalIndex = 0, modifiedIndex = 0;\n\t\tlet diagonalForwardStart = 0, diagonalForwardEnd = 0;\n\t\tlet diagonalReverseStart = 0, diagonalReverseEnd = 0;\n\n\t\t// To traverse the edit graph and produce the proper LCS, our actual\n\t\t// start position is just outside the given boundary\n\t\toriginalStart--;\n\t\tmodifiedStart--;\n\n\t\t// We set these up to make the compiler happy, but they will\n\t\t// be replaced before we return with the actual recursion point\n\t\tmidOriginalArr[0] = 0;\n\t\tmidModifiedArr[0] = 0;\n\n\t\t// Clear out the history\n\t\tthis.m_forwardHistory = [];\n\t\tthis.m_reverseHistory = [];\n\n\t\t// Each cell in the two arrays corresponds to a diagonal in the edit graph.\n\t\t// The integer value in the cell represents the originalIndex of the furthest\n\t\t// reaching point found so far that ends in that diagonal.\n\t\t// The modifiedIndex can be computed mathematically from the originalIndex and the diagonal number.\n\t\tconst maxDifferences = (originalEnd - originalStart) + (modifiedEnd - modifiedStart);\n\t\tconst numDiagonals = maxDifferences + 1;\n\t\tconst forwardPoints = new Int32Array(numDiagonals);\n\t\tconst reversePoints = new Int32Array(numDiagonals);\n\t\t// diagonalForwardBase: Index into forwardPoints of the diagonal which passes through (originalStart, modifiedStart)\n\t\t// diagonalReverseBase: Index into reversePoints of the diagonal which passes through (originalEnd, modifiedEnd)\n\t\tconst diagonalForwardBase = (modifiedEnd - modifiedStart);\n\t\tconst diagonalReverseBase = (originalEnd - originalStart);\n\t\t// diagonalForwardOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n\t\t//    diagonal number (relative to diagonalForwardBase)\n\t\t// diagonalReverseOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n\t\t//    diagonal number (relative to diagonalReverseBase)\n\t\tconst diagonalForwardOffset = (originalStart - modifiedStart);\n\t\tconst diagonalReverseOffset = (originalEnd - modifiedEnd);\n\n\t\t// delta: The difference between the end diagonal and the start diagonal. This is used to relate diagonal numbers\n\t\t//   relative to the start diagonal with diagonal numbers relative to the end diagonal.\n\t\t// The Even/Oddn-ness of this delta is important for determining when we should check for overlap\n\t\tconst delta = diagonalReverseBase - diagonalForwardBase;\n\t\tconst deltaIsEven = (delta % 2 === 0);\n\n\t\t// Here we set up the start and end points as the furthest points found so far\n\t\t// in both the forward and reverse directions, respectively\n\t\tforwardPoints[diagonalForwardBase] = originalStart;\n\t\treversePoints[diagonalReverseBase] = originalEnd;\n\n\t\t// Remember if we quit early, and thus need to do a best-effort result instead of a real result.\n\t\tquitEarlyArr[0] = false;\n\n\n\n\t\t// A couple of points:\n\t\t// --With this method, we iterate on the number of differences between the two sequences.\n\t\t//   The more differences there actually are, the longer this will take.\n\t\t// --Also, as the number of differences increases, we have to search on diagonals further\n\t\t//   away from the reference diagonal (which is diagonalForwardBase for forward, diagonalReverseBase for reverse).\n\t\t// --We extend on even diagonals (relative to the reference diagonal) only when numDifferences\n\t\t//   is even and odd diagonals only when numDifferences is odd.\n\t\tfor (let numDifferences = 1; numDifferences <= (maxDifferences / 2) + 1; numDifferences++) {\n\t\t\tlet furthestOriginalIndex = 0;\n\t\t\tlet furthestModifiedIndex = 0;\n\n\t\t\t// Run the algorithm in the forward direction\n\t\t\tdiagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n\t\t\tdiagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n\t\t\tfor (let diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {\n\t\t\t\t// STEP 1: We extend the furthest reaching point in the present diagonal\n\t\t\t\t// by looking at the diagonals above and below and picking the one whose point\n\t\t\t\t// is further away from the start point (originalStart, modifiedStart)\n\t\t\t\tif (diagonal === diagonalForwardStart || (diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\n\t\t\t\t\toriginalIndex = forwardPoints[diagonal + 1];\n\t\t\t\t} else {\n\t\t\t\t\toriginalIndex = forwardPoints[diagonal - 1] + 1;\n\t\t\t\t}\n\t\t\t\tmodifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;\n\n\t\t\t\t// Save the current originalIndex so we can test for false overlap in step 3\n\t\t\t\tconst tempOriginalIndex = originalIndex;\n\n\t\t\t\t// STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n\t\t\t\t// so long as the elements are equal.\n\t\t\t\twhile (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {\n\t\t\t\t\toriginalIndex++;\n\t\t\t\t\tmodifiedIndex++;\n\t\t\t\t}\n\t\t\t\tforwardPoints[diagonal] = originalIndex;\n\n\t\t\t\tif (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {\n\t\t\t\t\tfurthestOriginalIndex = originalIndex;\n\t\t\t\t\tfurthestModifiedIndex = modifiedIndex;\n\t\t\t\t}\n\n\t\t\t\t// STEP 3: If delta is odd (overlap first happens on forward when delta is odd)\n\t\t\t\t// and diagonal is in the range of reverse diagonals computed for numDifferences-1\n\t\t\t\t// (the previous iteration; we haven't computed reverse diagonals for numDifferences yet)\n\t\t\t\t// then check for overlap.\n\t\t\t\tif (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= (numDifferences - 1)) {\n\t\t\t\t\tif (originalIndex >= reversePoints[diagonal]) {\n\t\t\t\t\t\tmidOriginalArr[0] = originalIndex;\n\t\t\t\t\t\tmidModifiedArr[0] = modifiedIndex;\n\n\t\t\t\t\t\tif (tempOriginalIndex <= reversePoints[diagonal] && LocalConstants.MaxDifferencesHistory > 0 && numDifferences <= (LocalConstants.MaxDifferencesHistory + 1)) {\n\t\t\t\t\t\t\t// BINGO! We overlapped, and we have the full trace in memory!\n\t\t\t\t\t\t\treturn this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset,\n\t\t\t\t\t\t\t\tdiagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset,\n\t\t\t\t\t\t\t\tforwardPoints, reversePoints,\n\t\t\t\t\t\t\t\toriginalIndex, originalEnd, midOriginalArr,\n\t\t\t\t\t\t\t\tmodifiedIndex, modifiedEnd, midModifiedArr,\n\t\t\t\t\t\t\t\tdeltaIsEven, quitEarlyArr\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Either false overlap, or we didn't have enough memory for the full trace\n\t\t\t\t\t\t\t// Just return the recursion point\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check to see if we should be quitting early, before moving on to the next iteration.\n\t\t\tconst matchLengthOfLongest = ((furthestOriginalIndex - originalStart) + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;\n\n\t\t\tif (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {\n\t\t\t\t// We can't finish, so skip ahead to generating a result from what we have.\n\t\t\t\tquitEarlyArr[0] = true;\n\n\t\t\t\t// Use the furthest distance we got in the forward direction.\n\t\t\t\tmidOriginalArr[0] = furthestOriginalIndex;\n\t\t\t\tmidModifiedArr[0] = furthestModifiedIndex;\n\n\t\t\t\tif (matchLengthOfLongest > 0 && LocalConstants.MaxDifferencesHistory > 0 && numDifferences <= (LocalConstants.MaxDifferencesHistory + 1)) {\n\t\t\t\t\t// Enough of the history is in memory to walk it backwards\n\t\t\t\t\treturn this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset,\n\t\t\t\t\t\tdiagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset,\n\t\t\t\t\t\tforwardPoints, reversePoints,\n\t\t\t\t\t\toriginalIndex, originalEnd, midOriginalArr,\n\t\t\t\t\t\tmodifiedIndex, modifiedEnd, midModifiedArr,\n\t\t\t\t\t\tdeltaIsEven, quitEarlyArr\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\t// We didn't actually remember enough of the history.\n\n\t\t\t\t\t//Since we are quitting the diff early, we need to shift back the originalStart and modified start\n\t\t\t\t\t//back into the boundary limits since we decremented their value above beyond the boundary limit.\n\t\t\t\t\toriginalStart++;\n\t\t\t\t\tmodifiedStart++;\n\n\t\t\t\t\treturn [\n\t\t\t\t\t\tnew DiffChange(originalStart, originalEnd - originalStart + 1,\n\t\t\t\t\t\t\tmodifiedStart, modifiedEnd - modifiedStart + 1)\n\t\t\t\t\t];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Run the algorithm in the reverse direction\n\t\t\tdiagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n\t\t\tdiagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n\t\t\tfor (let diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {\n\t\t\t\t// STEP 1: We extend the furthest reaching point in the present diagonal\n\t\t\t\t// by looking at the diagonals above and below and picking the one whose point\n\t\t\t\t// is further away from the start point (originalEnd, modifiedEnd)\n\t\t\t\tif (diagonal === diagonalReverseStart || (diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\n\t\t\t\t\toriginalIndex = reversePoints[diagonal + 1] - 1;\n\t\t\t\t} else {\n\t\t\t\t\toriginalIndex = reversePoints[diagonal - 1];\n\t\t\t\t}\n\t\t\t\tmodifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;\n\n\t\t\t\t// Save the current originalIndex so we can test for false overlap\n\t\t\t\tconst tempOriginalIndex = originalIndex;\n\n\t\t\t\t// STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n\t\t\t\t// as long as the elements are equal.\n\t\t\t\twhile (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {\n\t\t\t\t\toriginalIndex--;\n\t\t\t\t\tmodifiedIndex--;\n\t\t\t\t}\n\t\t\t\treversePoints[diagonal] = originalIndex;\n\n\t\t\t\t// STEP 4: If delta is even (overlap first happens on reverse when delta is even)\n\t\t\t\t// and diagonal is in the range of forward diagonals computed for numDifferences\n\t\t\t\t// then check for overlap.\n\t\t\t\tif (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {\n\t\t\t\t\tif (originalIndex <= forwardPoints[diagonal]) {\n\t\t\t\t\t\tmidOriginalArr[0] = originalIndex;\n\t\t\t\t\t\tmidModifiedArr[0] = modifiedIndex;\n\n\t\t\t\t\t\tif (tempOriginalIndex >= forwardPoints[diagonal] && LocalConstants.MaxDifferencesHistory > 0 && numDifferences <= (LocalConstants.MaxDifferencesHistory + 1)) {\n\t\t\t\t\t\t\t// BINGO! We overlapped, and we have the full trace in memory!\n\t\t\t\t\t\t\treturn this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset,\n\t\t\t\t\t\t\t\tdiagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset,\n\t\t\t\t\t\t\t\tforwardPoints, reversePoints,\n\t\t\t\t\t\t\t\toriginalIndex, originalEnd, midOriginalArr,\n\t\t\t\t\t\t\t\tmodifiedIndex, modifiedEnd, midModifiedArr,\n\t\t\t\t\t\t\t\tdeltaIsEven, quitEarlyArr\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Either false overlap, or we didn't have enough memory for the full trace\n\t\t\t\t\t\t\t// Just return the recursion point\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Save current vectors to history before the next iteration\n\t\t\tif (numDifferences <= LocalConstants.MaxDifferencesHistory) {\n\t\t\t\t// We are allocating space for one extra int, which we fill with\n\t\t\t\t// the index of the diagonal base index\n\t\t\t\tlet temp = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2);\n\t\t\t\ttemp[0] = diagonalForwardBase - diagonalForwardStart + 1;\n\t\t\t\tMyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);\n\t\t\t\tthis.m_forwardHistory.push(temp);\n\n\t\t\t\ttemp = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2);\n\t\t\t\ttemp[0] = diagonalReverseBase - diagonalReverseStart + 1;\n\t\t\t\tMyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);\n\t\t\t\tthis.m_reverseHistory.push(temp);\n\t\t\t}\n\n\t\t}\n\n\t\t// If we got here, then we have the full trace in history. We just have to convert it to a change list\n\t\t// NOTE: This part is a bit messy\n\t\treturn this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset,\n\t\t\tdiagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset,\n\t\t\tforwardPoints, reversePoints,\n\t\t\toriginalIndex, originalEnd, midOriginalArr,\n\t\t\tmodifiedIndex, modifiedEnd, midModifiedArr,\n\t\t\tdeltaIsEven, quitEarlyArr\n\t\t);\n\t}\n\n\t/**\n\t * Shifts the given changes to provide a more intuitive diff.\n\t * While the first element in a diff matches the first element after the diff,\n\t * we shift the diff down.\n\t *\n\t * @param changes The list of changes to shift\n\t * @returns The shifted changes\n\t */\n\tprivate PrettifyChanges(changes: DiffChange[]): DiffChange[] {\n\n\t\t// Shift all the changes down first\n\t\tfor (let i = 0; i < changes.length; i++) {\n\t\t\tconst change = changes[i];\n\t\t\tconst originalStop = (i < changes.length - 1) ? changes[i + 1].originalStart : this._originalElementsOrHash.length;\n\t\t\tconst modifiedStop = (i < changes.length - 1) ? changes[i + 1].modifiedStart : this._modifiedElementsOrHash.length;\n\t\t\tconst checkOriginal = change.originalLength > 0;\n\t\t\tconst checkModified = change.modifiedLength > 0;\n\n\t\t\twhile (\n\t\t\t\tchange.originalStart + change.originalLength < originalStop\n\t\t\t\t&& change.modifiedStart + change.modifiedLength < modifiedStop\n\t\t\t\t&& (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength))\n\t\t\t\t&& (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))\n\t\t\t) {\n\t\t\t\tconst startStrictEqual = this.ElementsAreStrictEqual(change.originalStart, change.modifiedStart);\n\t\t\t\tconst endStrictEqual = this.ElementsAreStrictEqual(change.originalStart + change.originalLength, change.modifiedStart + change.modifiedLength);\n\t\t\t\tif (endStrictEqual && !startStrictEqual) {\n\t\t\t\t\t// moving the change down would create an equal change, but the elements are not strict equal\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchange.originalStart++;\n\t\t\t\tchange.modifiedStart++;\n\t\t\t}\n\n\t\t\tconst mergedChangeArr: Array<DiffChange | null> = [null];\n\t\t\tif (i < changes.length - 1 && this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {\n\t\t\t\tchanges[i] = mergedChangeArr[0]!;\n\t\t\t\tchanges.splice(i + 1, 1);\n\t\t\t\ti--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// Shift changes back up until we hit empty or whitespace-only lines\n\t\tfor (let i = changes.length - 1; i >= 0; i--) {\n\t\t\tconst change = changes[i];\n\n\t\t\tlet originalStop = 0;\n\t\t\tlet modifiedStop = 0;\n\t\t\tif (i > 0) {\n\t\t\t\tconst prevChange = changes[i - 1];\n\t\t\t\toriginalStop = prevChange.originalStart + prevChange.originalLength;\n\t\t\t\tmodifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;\n\t\t\t}\n\n\t\t\tconst checkOriginal = change.originalLength > 0;\n\t\t\tconst checkModified = change.modifiedLength > 0;\n\n\t\t\tlet bestDelta = 0;\n\t\t\tlet bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);\n\n\t\t\tfor (let delta = 1; ; delta++) {\n\t\t\t\tconst originalStart = change.originalStart - delta;\n\t\t\t\tconst modifiedStart = change.modifiedStart - delta;\n\n\t\t\t\tif (originalStart < originalStop || modifiedStart < modifiedStop) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tconst touchingPreviousChange = (originalStart === originalStop && modifiedStart === modifiedStop);\n\t\t\t\tconst score = (\n\t\t\t\t\t(touchingPreviousChange ? 5 : 0)\n\t\t\t\t\t+ this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength)\n\t\t\t\t);\n\n\t\t\t\tif (score > bestScore) {\n\t\t\t\t\tbestScore = score;\n\t\t\t\t\tbestDelta = delta;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchange.originalStart -= bestDelta;\n\t\t\tchange.modifiedStart -= bestDelta;\n\n\t\t\tconst mergedChangeArr: Array<DiffChange | null> = [null];\n\t\t\tif (i > 0 && this.ChangesOverlap(changes[i - 1], changes[i], mergedChangeArr)) {\n\t\t\t\tchanges[i - 1] = mergedChangeArr[0]!;\n\t\t\t\tchanges.splice(i, 1);\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// There could be multiple longest common substrings.\n\t\t// Give preference to the ones containing longer lines\n\t\tif (this._hasStrings) {\n\t\t\tfor (let i = 1, len = changes.length; i < len; i++) {\n\t\t\t\tconst aChange = changes[i - 1];\n\t\t\t\tconst bChange = changes[i];\n\t\t\t\tconst matchedLength = bChange.originalStart - aChange.originalStart - aChange.originalLength;\n\t\t\t\tconst aOriginalStart = aChange.originalStart;\n\t\t\t\tconst bOriginalEnd = bChange.originalStart + bChange.originalLength;\n\t\t\t\tconst abOriginalLength = bOriginalEnd - aOriginalStart;\n\t\t\t\tconst aModifiedStart = aChange.modifiedStart;\n\t\t\t\tconst bModifiedEnd = bChange.modifiedStart + bChange.modifiedLength;\n\t\t\t\tconst abModifiedLength = bModifiedEnd - aModifiedStart;\n\t\t\t\t// Avoid wasting a lot of time with these searches\n\t\t\t\tif (matchedLength < 5 && abOriginalLength < 20 && abModifiedLength < 20) {\n\t\t\t\t\tconst t = this._findBetterContiguousSequence(\n\t\t\t\t\t\taOriginalStart, abOriginalLength,\n\t\t\t\t\t\taModifiedStart, abModifiedLength,\n\t\t\t\t\t\tmatchedLength\n\t\t\t\t\t);\n\t\t\t\t\tif (t) {\n\t\t\t\t\t\tconst [originalMatchStart, modifiedMatchStart] = t;\n\t\t\t\t\t\tif (originalMatchStart !== aChange.originalStart + aChange.originalLength || modifiedMatchStart !== aChange.modifiedStart + aChange.modifiedLength) {\n\t\t\t\t\t\t\t// switch to another sequence that has a better score\n\t\t\t\t\t\t\taChange.originalLength = originalMatchStart - aChange.originalStart;\n\t\t\t\t\t\t\taChange.modifiedLength = modifiedMatchStart - aChange.modifiedStart;\n\t\t\t\t\t\t\tbChange.originalStart = originalMatchStart + matchedLength;\n\t\t\t\t\t\t\tbChange.modifiedStart = modifiedMatchStart + matchedLength;\n\t\t\t\t\t\t\tbChange.originalLength = bOriginalEnd - bChange.originalStart;\n\t\t\t\t\t\t\tbChange.modifiedLength = bModifiedEnd - bChange.modifiedStart;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn changes;\n\t}\n\n\tprivate _findBetterContiguousSequence(originalStart: number, originalLength: number, modifiedStart: number, modifiedLength: number, desiredLength: number): [number, number] | null {\n\t\tif (originalLength < desiredLength || modifiedLength < desiredLength) {\n\t\t\treturn null;\n\t\t}\n\t\tconst originalMax = originalStart + originalLength - desiredLength + 1;\n\t\tconst modifiedMax = modifiedStart + modifiedLength - desiredLength + 1;\n\t\tlet bestScore = 0;\n\t\tlet bestOriginalStart = 0;\n\t\tlet bestModifiedStart = 0;\n\t\tfor (let i = originalStart; i < originalMax; i++) {\n\t\t\tfor (let j = modifiedStart; j < modifiedMax; j++) {\n\t\t\t\tconst score = this._contiguousSequenceScore(i, j, desiredLength);\n\t\t\t\tif (score > 0 && score > bestScore) {\n\t\t\t\t\tbestScore = score;\n\t\t\t\t\tbestOriginalStart = i;\n\t\t\t\t\tbestModifiedStart = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (bestScore > 0) {\n\t\t\treturn [bestOriginalStart, bestModifiedStart];\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate _contiguousSequenceScore(originalStart: number, modifiedStart: number, length: number): number {\n\t\tlet score = 0;\n\t\tfor (let l = 0; l < length; l++) {\n\t\t\tif (!this.ElementsAreEqual(originalStart + l, modifiedStart + l)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tscore += this._originalStringElements[originalStart + l].length;\n\t\t}\n\t\treturn score;\n\t}\n\n\tprivate _OriginalIsBoundary(index: number): boolean {\n\t\tif (index <= 0 || index >= this._originalElementsOrHash.length - 1) {\n\t\t\treturn true;\n\t\t}\n\t\treturn (this._hasStrings && /^\\s*$/.test(this._originalStringElements[index]));\n\t}\n\n\tprivate _OriginalRegionIsBoundary(originalStart: number, originalLength: number): boolean {\n\t\tif (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (originalLength > 0) {\n\t\t\tconst originalEnd = originalStart + originalLength;\n\t\t\tif (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate _ModifiedIsBoundary(index: number): boolean {\n\t\tif (index <= 0 || index >= this._modifiedElementsOrHash.length - 1) {\n\t\t\treturn true;\n\t\t}\n\t\treturn (this._hasStrings && /^\\s*$/.test(this._modifiedStringElements[index]));\n\t}\n\n\tprivate _ModifiedRegionIsBoundary(modifiedStart: number, modifiedLength: number): boolean {\n\t\tif (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (modifiedLength > 0) {\n\t\t\tconst modifiedEnd = modifiedStart + modifiedLength;\n\t\t\tif (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate _boundaryScore(originalStart: number, originalLength: number, modifiedStart: number, modifiedLength: number): number {\n\t\tconst originalScore = (this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0);\n\t\tconst modifiedScore = (this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0);\n\t\treturn (originalScore + modifiedScore);\n\t}\n\n\t/**\n\t * Concatenates the two input DiffChange lists and returns the resulting\n\t * list.\n\t * @param The left changes\n\t * @param The right changes\n\t * @returns The concatenated list\n\t */\n\tprivate ConcatenateChanges(left: DiffChange[], right: DiffChange[]): DiffChange[] {\n\t\tconst mergedChangeArr: DiffChange[] = [];\n\n\t\tif (left.length === 0 || right.length === 0) {\n\t\t\treturn (right.length > 0) ? right : left;\n\t\t} else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {\n\t\t\t// Since we break the problem down recursively, it is possible that we\n\t\t\t// might recurse in the middle of a change thereby splitting it into\n\t\t\t// two changes. Here in the combining stage, we detect and fuse those\n\t\t\t// changes back together\n\t\t\tconst result = new Array<DiffChange>(left.length + right.length - 1);\n\t\t\tMyArray.Copy(left, 0, result, 0, left.length - 1);\n\t\t\tresult[left.length - 1] = mergedChangeArr[0];\n\t\t\tMyArray.Copy(right, 1, result, left.length, right.length - 1);\n\n\t\t\treturn result;\n\t\t} else {\n\t\t\tconst result = new Array<DiffChange>(left.length + right.length);\n\t\t\tMyArray.Copy(left, 0, result, 0, left.length);\n\t\t\tMyArray.Copy(right, 0, result, left.length, right.length);\n\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t/**\n\t * Returns true if the two changes overlap and can be merged into a single\n\t * change\n\t * @param left The left change\n\t * @param right The right change\n\t * @param mergedChange The merged change if the two overlap, null otherwise\n\t * @returns True if the two changes overlap\n\t */\n\tprivate ChangesOverlap(left: DiffChange, right: DiffChange, mergedChangeArr: Array<DiffChange | null>): boolean {\n\t\tDebug.Assert(left.originalStart <= right.originalStart, 'Left change is not less than or equal to right change');\n\t\tDebug.Assert(left.modifiedStart <= right.modifiedStart, 'Left change is not less than or equal to right change');\n\n\t\tif (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n\t\t\tconst originalStart = left.originalStart;\n\t\t\tlet originalLength = left.originalLength;\n\t\t\tconst modifiedStart = left.modifiedStart;\n\t\t\tlet modifiedLength = left.modifiedLength;\n\n\t\t\tif (left.originalStart + left.originalLength >= right.originalStart) {\n\t\t\t\toriginalLength = right.originalStart + right.originalLength - left.originalStart;\n\t\t\t}\n\t\t\tif (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n\t\t\t\tmodifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;\n\t\t\t}\n\n\t\t\tmergedChangeArr[0] = new DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);\n\t\t\treturn true;\n\t\t} else {\n\t\t\tmergedChangeArr[0] = null;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Helper method used to clip a diagonal index to the range of valid\n\t * diagonals. This also decides whether or not the diagonal index,\n\t * if it exceeds the boundary, should be clipped to the boundary or clipped\n\t * one inside the boundary depending on the Even/Odd status of the boundary\n\t * and numDifferences.\n\t * @param diagonal The index of the diagonal to clip.\n\t * @param numDifferences The current number of differences being iterated upon.\n\t * @param diagonalBaseIndex The base reference diagonal.\n\t * @param numDiagonals The total number of diagonals.\n\t * @returns The clipped diagonal index.\n\t */\n\tprivate ClipDiagonalBound(diagonal: number, numDifferences: number, diagonalBaseIndex: number, numDiagonals: number): number {\n\t\tif (diagonal >= 0 && diagonal < numDiagonals) {\n\t\t\t// Nothing to clip, its in range\n\t\t\treturn diagonal;\n\t\t}\n\n\t\t// diagonalsBelow: The number of diagonals below the reference diagonal\n\t\t// diagonalsAbove: The number of diagonals above the reference diagonal\n\t\tconst diagonalsBelow = diagonalBaseIndex;\n\t\tconst diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;\n\t\tconst diffEven = (numDifferences % 2 === 0);\n\n\t\tif (diagonal < 0) {\n\t\t\tconst lowerBoundEven = (diagonalsBelow % 2 === 0);\n\t\t\treturn (diffEven === lowerBoundEven) ? 0 : 1;\n\t\t} else {\n\t\t\tconst upperBoundEven = (diagonalsAbove % 2 === 0);\n\t\t\treturn (diffEven === upperBoundEven) ? numDiagonals - 1 : numDiagonals - 2;\n\t\t}\n\t}\n}\n"],
  "mappings": "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",
  "names": ["LocalConstants"]
}
