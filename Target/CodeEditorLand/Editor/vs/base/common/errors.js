class c{unexpectedErrorHandler;listeners;constructor(){this.listeners=[],this.unexpectedErrorHandler=function(e){setTimeout(()=>{throw e.stack?t.isErrorNoTelemetry(e)?new t(e.message+`

`+e.stack):new Error(e.message+`

`+e.stack):e},0)}}addListener(e){return this.listeners.push(e),()=>{this._removeListener(e)}}emit(e){this.listeners.forEach(n=>{n(e)})}_removeListener(e){this.listeners.splice(this.listeners.indexOf(e),1)}setUnexpectedErrorHandler(e){this.unexpectedErrorHandler=e}getUnexpectedErrorHandler(){return this.unexpectedErrorHandler}onUnexpectedError(e){this.unexpectedErrorHandler(e),this.emit(e)}onUnexpectedExternalError(e){this.unexpectedErrorHandler(e)}}const o=new c;function u(r){o.setUnexpectedErrorHandler(r)}function E(r){if(!r||typeof r!="object")return!1;const e=r;return e.code==="EPIPE"&&e.syscall?.toUpperCase()==="WRITE"}function p(r){o.onUnexpectedError(r)}function g(r){i(r)||o.onUnexpectedError(r)}function x(r){i(r)||o.onUnexpectedExternalError(r)}function f(r){if(r instanceof Error){const{name:e,message:n}=r,l=r.stacktrace||r.stack;return{$isError:!0,name:e,message:n,stack:l,noTelemetry:t.isErrorNoTelemetry(r)}}return r}function m(r){let e;return r.noTelemetry?e=new t:(e=new Error,e.name=r.name),e.message=r.message,e.stack=r.stack,e}const s="Canceled";function i(r){return r instanceof d?!0:r instanceof Error&&r.name===s&&r.message===s}class d extends Error{constructor(){super(s),this.name=this.message}}function y(){const r=new Error(s);return r.name=r.message,r}function h(r){return r?new Error(`Illegal argument: ${r}`):new Error("Illegal argument")}function v(r){return r?new Error(`Illegal state: ${r}`):new Error("Illegal state")}class b extends TypeError{constructor(e){super(e?`${e} is read-only and cannot be changed`:"Cannot change read-only property")}}function k(r){return r?r.message?r.message:r.stack?r.stack.split(`
`)[0]:String(r):"Error"}class w extends Error{constructor(e){super("NotImplemented"),e&&(this.message=e)}}class N extends Error{constructor(e){super("NotSupported"),e&&(this.message=e)}}class C extends Error{isExpected=!0}class t extends Error{name;constructor(e){super(e),this.name="CodeExpectedError"}static fromError(e){if(e instanceof t)return e;const n=new t;return n.message=e.message,n.stack=e.stack,n}static isErrorNoTelemetry(e){return e.name==="CodeExpectedError"}}class a extends Error{constructor(e){super(e||"An unexpected bug occurred."),Object.setPrototypeOf(this,a.prototype)}}export{a as BugIndicatingError,d as CancellationError,c as ErrorHandler,t as ErrorNoTelemetry,C as ExpectedError,w as NotImplementedError,N as NotSupportedError,b as ReadonlyError,y as canceled,o as errorHandler,k as getErrorMessage,h as illegalArgument,v as illegalState,i as isCancellationError,E as isSigPipeError,p as onBugIndicatingError,g as onUnexpectedError,x as onUnexpectedExternalError,u as setUnexpectedErrorHandler,f as transformErrorForSerialization,m as transformErrorFromSerialization};
