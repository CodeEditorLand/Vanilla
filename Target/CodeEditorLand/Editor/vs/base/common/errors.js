class c{unexpectedErrorHandler;listeners;constructor(){this.listeners=[],this.unexpectedErrorHandler=function(r){setTimeout(()=>{throw r.stack?t.isErrorNoTelemetry(r)?new t(r.message+`

`+r.stack):new Error(r.message+`

`+r.stack):r},0)}}addListener(r){return this.listeners.push(r),()=>{this._removeListener(r)}}emit(r){this.listeners.forEach(n=>{n(r)})}_removeListener(r){this.listeners.splice(this.listeners.indexOf(r),1)}setUnexpectedErrorHandler(r){this.unexpectedErrorHandler=r}getUnexpectedErrorHandler(){return this.unexpectedErrorHandler}onUnexpectedError(r){this.unexpectedErrorHandler(r),this.emit(r)}onUnexpectedExternalError(r){this.unexpectedErrorHandler(r)}}const s=new c;function u(e){s.setUnexpectedErrorHandler(e)}function E(e){if(!e||typeof e!="object")return!1;const r=e;return r.code==="EPIPE"&&r.syscall?.toUpperCase()==="WRITE"}function p(e){i(e)||s.onUnexpectedError(e)}function g(e){i(e)||s.onUnexpectedExternalError(e)}function x(e){if(e instanceof Error){const{name:r,message:n}=e,l=e.stacktrace||e.stack;return{$isError:!0,name:r,message:n,stack:l,noTelemetry:t.isErrorNoTelemetry(e)}}return e}function f(e){let r;return e.noTelemetry?r=new t:(r=new Error,r.name=e.name),r.message=e.message,r.stack=e.stack,r}const o="Canceled";function i(e){return e instanceof d?!0:e instanceof Error&&e.name===o&&e.message===o}class d extends Error{constructor(){super(o),this.name=this.message}}function m(){const e=new Error(o);return e.name=e.message,e}function y(e){return e?new Error(`Illegal argument: ${e}`):new Error("Illegal argument")}function h(e){return e?new Error(`Illegal state: ${e}`):new Error("Illegal state")}class v extends TypeError{constructor(r){super(r?`${r} is read-only and cannot be changed`:"Cannot change read-only property")}}function b(e){return e?e.message?e.message:e.stack?e.stack.split(`
`)[0]:String(e):"Error"}class k extends Error{constructor(r){super("NotImplemented"),r&&(this.message=r)}}class w extends Error{constructor(r){super("NotSupported"),r&&(this.message=r)}}class N extends Error{isExpected=!0}class t extends Error{name;constructor(r){super(r),this.name="CodeExpectedError"}static fromError(r){if(r instanceof t)return r;const n=new t;return n.message=r.message,n.stack=r.stack,n}static isErrorNoTelemetry(r){return r.name==="CodeExpectedError"}}class a extends Error{constructor(r){super(r||"An unexpected bug occurred."),Object.setPrototypeOf(this,a.prototype)}}export{a as BugIndicatingError,d as CancellationError,c as ErrorHandler,t as ErrorNoTelemetry,N as ExpectedError,k as NotImplementedError,w as NotSupportedError,v as ReadonlyError,m as canceled,s as errorHandler,b as getErrorMessage,y as illegalArgument,h as illegalState,i as isCancellationError,E as isSigPipeError,p as onUnexpectedError,g as onUnexpectedExternalError,u as setUnexpectedErrorHandler,x as transformErrorForSerialization,f as transformErrorFromSerialization};
