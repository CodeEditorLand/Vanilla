{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/arraysFind.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { Comparator } from './arrays.js';\n\nexport function findLast<T>(array: readonly T[], predicate: (item: T) => boolean): T | undefined {\n\tconst idx = findLastIdx(array, predicate);\n\tif (idx === -1) {\n\t\treturn undefined;\n\t}\n\treturn array[idx];\n}\n\nexport function findLastIdx<T>(array: readonly T[], predicate: (item: T) => boolean, fromIndex = array.length - 1): number {\n\tfor (let i = fromIndex; i >= 0; i--) {\n\t\tconst element = array[i];\n\n\t\tif (predicate(element)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n\n/**\n * Finds the last item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n *\n * @returns `undefined` if no item matches, otherwise the last item that matches the predicate.\n */\nexport function findLastMonotonous<T>(array: readonly T[], predicate: (item: T) => boolean): T | undefined {\n\tconst idx = findLastIdxMonotonous(array, predicate);\n\treturn idx === -1 ? undefined : array[idx];\n}\n\n/**\n * Finds the last item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n *\n * @returns `startIdx - 1` if predicate is false for all items, otherwise the index of the last item that matches the predicate.\n */\nexport function findLastIdxMonotonous<T>(array: readonly T[], predicate: (item: T) => boolean, startIdx = 0, endIdxEx = array.length): number {\n\tlet i = startIdx;\n\tlet j = endIdxEx;\n\twhile (i < j) {\n\t\tconst k = Math.floor((i + j) / 2);\n\t\tif (predicate(array[k])) {\n\t\t\ti = k + 1;\n\t\t} else {\n\t\t\tj = k;\n\t\t}\n\t}\n\treturn i - 1;\n}\n\n/**\n * Finds the first item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[false, ..., false, true, ..., true]`!\n *\n * @returns `undefined` if no item matches, otherwise the first item that matches the predicate.\n */\nexport function findFirstMonotonous<T>(array: readonly T[], predicate: (item: T) => boolean): T | undefined {\n\tconst idx = findFirstIdxMonotonousOrArrLen(array, predicate);\n\treturn idx === array.length ? undefined : array[idx];\n}\n\n/**\n * Finds the first item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[false, ..., false, true, ..., true]`!\n *\n * @returns `endIdxEx` if predicate is false for all items, otherwise the index of the first item that matches the predicate.\n */\nexport function findFirstIdxMonotonousOrArrLen<T>(array: readonly T[], predicate: (item: T) => boolean, startIdx = 0, endIdxEx = array.length): number {\n\tlet i = startIdx;\n\tlet j = endIdxEx;\n\twhile (i < j) {\n\t\tconst k = Math.floor((i + j) / 2);\n\t\tif (predicate(array[k])) {\n\t\t\tj = k;\n\t\t} else {\n\t\t\ti = k + 1;\n\t\t}\n\t}\n\treturn i;\n}\n\nexport function findFirstIdxMonotonous<T>(array: readonly T[], predicate: (item: T) => boolean, startIdx = 0, endIdxEx = array.length): number {\n\tconst idx = findFirstIdxMonotonousOrArrLen(array, predicate, startIdx, endIdxEx);\n\treturn idx === array.length ? -1 : idx;\n}\n\n/**\n * Use this when\n * * You have a sorted array\n * * You query this array with a monotonous predicate to find the last item that has a certain property.\n * * You query this array multiple times with monotonous predicates that get weaker and weaker.\n */\nexport class MonotonousArray<T> {\n\tpublic static assertInvariants = false;\n\n\tprivate _findLastMonotonousLastIdx = 0;\n\tprivate _prevFindLastPredicate: ((item: T) => boolean) | undefined;\n\n\tconstructor(private readonly _array: readonly T[]) {\n\t}\n\n\t/**\n\t * The predicate must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n\t * For subsequent calls, current predicate must be weaker than (or equal to) the previous predicate, i.e. more entries must be `true`.\n\t */\n\tfindLastMonotonous(predicate: (item: T) => boolean): T | undefined {\n\t\tif (MonotonousArray.assertInvariants) {\n\t\t\tif (this._prevFindLastPredicate) {\n\t\t\t\tfor (const item of this._array) {\n\t\t\t\t\tif (this._prevFindLastPredicate(item) && !predicate(item)) {\n\t\t\t\t\t\tthrow new Error('MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._prevFindLastPredicate = predicate;\n\t\t}\n\n\t\tconst idx = findLastIdxMonotonous(this._array, predicate, this._findLastMonotonousLastIdx);\n\t\tthis._findLastMonotonousLastIdx = idx + 1;\n\t\treturn idx === -1 ? undefined : this._array[idx];\n\t}\n}\n\n/**\n * Returns the first item that is equal to or greater than every other item.\n*/\nexport function findFirstMax<T>(array: readonly T[], comparator: Comparator<T>): T | undefined {\n\tif (array.length === 0) {\n\t\treturn undefined;\n\t}\n\n\tlet max = array[0];\n\tfor (let i = 1; i < array.length; i++) {\n\t\tconst item = array[i];\n\t\tif (comparator(item, max) > 0) {\n\t\t\tmax = item;\n\t\t}\n\t}\n\treturn max;\n}\n\n/**\n * Returns the last item that is equal to or greater than every other item.\n*/\nexport function findLastMax<T>(array: readonly T[], comparator: Comparator<T>): T | undefined {\n\tif (array.length === 0) {\n\t\treturn undefined;\n\t}\n\n\tlet max = array[0];\n\tfor (let i = 1; i < array.length; i++) {\n\t\tconst item = array[i];\n\t\tif (comparator(item, max) >= 0) {\n\t\t\tmax = item;\n\t\t}\n\t}\n\treturn max;\n}\n\n/**\n * Returns the first item that is equal to or less than every other item.\n*/\nexport function findFirstMin<T>(array: readonly T[], comparator: Comparator<T>): T | undefined {\n\treturn findFirstMax(array, (a, b) => -comparator(a, b));\n}\n\nexport function findMaxIdx<T>(array: readonly T[], comparator: Comparator<T>): number {\n\tif (array.length === 0) {\n\t\treturn -1;\n\t}\n\n\tlet maxIdx = 0;\n\tfor (let i = 1; i < array.length; i++) {\n\t\tconst item = array[i];\n\t\tif (comparator(item, array[maxIdx]) > 0) {\n\t\t\tmaxIdx = i;\n\t\t}\n\t}\n\treturn maxIdx;\n}\n\n/**\n * Returns the first mapped value of the array which is not undefined.\n */\nexport function mapFindFirst<T, R>(items: Iterable<T>, mapFn: (value: T) => R | undefined): R | undefined {\n\tfor (const value of items) {\n\t\tconst mapped = mapFn(value);\n\t\tif (mapped !== undefined) {\n\t\t\treturn mapped;\n\t\t}\n\t}\n\n\treturn undefined;\n}\n"],
  "mappings": "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",
  "names": []
}
