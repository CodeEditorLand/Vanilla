{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/prefixTree.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Iterable } from \"./iterator.js\";\n\nconst unset = Symbol(\"unset\");\n\nexport interface IPrefixTreeNode<T> {\n\t/** Possible children of the node. */\n\tchildren?: ReadonlyMap<string, Node<T>>;\n\n\t/** The value if data exists for this node in the tree. Mutable. */\n\tvalue: T | undefined;\n}\n\n/**\n * A simple prefix tree implementation where a value is stored based on\n * well-defined prefix segments.\n */\nexport class WellDefinedPrefixTree<V> {\n\tprivate readonly root = new Node<V>();\n\tprivate _size = 0;\n\n\tpublic get size() {\n\t\treturn this._size;\n\t}\n\n\t/** Gets the top-level nodes of the tree */\n\tpublic get nodes(): Iterable<IPrefixTreeNode<V>> {\n\t\treturn this.root.children?.values() || Iterable.empty();\n\t}\n\n\t/** Gets the top-level nodes of the tree */\n\tpublic get entries(): Iterable<[string, IPrefixTreeNode<V>]> {\n\t\treturn this.root.children?.entries() || Iterable.empty();\n\t}\n\n\t/**\n\t * Inserts a new value in the prefix tree.\n\t * @param onNode - called for each node as we descend to the insertion point,\n\t * including the insertion point itself.\n\t */\n\tinsert(\n\t\tkey: Iterable<string>,\n\t\tvalue: V,\n\t\tonNode?: (n: IPrefixTreeNode<V>) => void,\n\t): void {\n\t\tthis.opNode(key, (n) => (n._value = value), onNode);\n\t}\n\n\t/** Mutates a value in the prefix tree. */\n\tmutate(key: Iterable<string>, mutate: (value?: V) => V): void {\n\t\tthis.opNode(\n\t\t\tkey,\n\t\t\t(n) =>\n\t\t\t\t(n._value = mutate(n._value === unset ? undefined : n._value)),\n\t\t);\n\t}\n\n\t/** Mutates nodes along the path in the prefix tree. */\n\tmutatePath(\n\t\tkey: Iterable<string>,\n\t\tmutate: (node: IPrefixTreeNode<V>) => void,\n\t): void {\n\t\tthis.opNode(\n\t\t\tkey,\n\t\t\t() => {},\n\t\t\t(n) => mutate(n),\n\t\t);\n\t}\n\n\t/** Deletes a node from the prefix tree, returning the value it contained. */\n\tdelete(key: Iterable<string>): V | undefined {\n\t\tconst path = this.getPathToKey(key);\n\t\tif (!path) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet i = path.length - 1;\n\t\tconst value = path[i].node._value;\n\t\tif (value === unset) {\n\t\t\treturn; // not actually a real node\n\t\t}\n\n\t\tthis._size--;\n\t\tpath[i].node._value = unset;\n\n\t\tfor (; i > 0; i--) {\n\t\t\tconst { node, part } = path[i];\n\t\t\tif (node.children?.size || node._value !== unset) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tpath[i - 1].node.children!.delete(part);\n\t\t}\n\n\t\treturn value;\n\t}\n\n\t/** Deletes a subtree from the prefix tree, returning the values they contained. */\n\t*deleteRecursive(key: Iterable<string>): Iterable<V> {\n\t\tconst path = this.getPathToKey(key);\n\t\tif (!path) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst subtree = path[path.length - 1].node;\n\n\t\t// important: run the deletion before we start to yield results, so that\n\t\t// it still runs even if the caller doesn't consumer the iterator\n\t\tfor (let i = path.length - 1; i > 0; i--) {\n\t\t\tconst parent = path[i - 1];\n\t\t\tparent.node.children!.delete(path[i].part);\n\t\t\tif (\n\t\t\t\tparent.node.children!.size > 0 ||\n\t\t\t\tparent.node._value !== unset\n\t\t\t) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (const node of bfsIterate(subtree)) {\n\t\t\tif (node._value !== unset) {\n\t\t\t\tthis._size--;\n\t\t\t\tyield node._value;\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Gets a value from the tree. */\n\tfind(key: Iterable<string>): V | undefined {\n\t\tlet node = this.root;\n\t\tfor (const segment of key) {\n\t\t\tconst next = node.children?.get(segment);\n\t\t\tif (!next) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tnode = next;\n\t\t}\n\n\t\treturn node._value === unset ? undefined : node._value;\n\t}\n\n\t/** Gets whether the tree has the key, or a parent of the key, already inserted. */\n\thasKeyOrParent(key: Iterable<string>): boolean {\n\t\tlet node = this.root;\n\t\tfor (const segment of key) {\n\t\t\tconst next = node.children?.get(segment);\n\t\t\tif (!next) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (next._value !== unset) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tnode = next;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/** Gets whether the tree has the given key or any children. */\n\thasKeyOrChildren(key: Iterable<string>): boolean {\n\t\tlet node = this.root;\n\t\tfor (const segment of key) {\n\t\t\tconst next = node.children?.get(segment);\n\t\t\tif (!next) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tnode = next;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/** Gets whether the tree has the given key. */\n\thasKey(key: Iterable<string>): boolean {\n\t\tlet node = this.root;\n\t\tfor (const segment of key) {\n\t\t\tconst next = node.children?.get(segment);\n\t\t\tif (!next) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tnode = next;\n\t\t}\n\n\t\treturn node._value !== unset;\n\t}\n\n\tprivate getPathToKey(key: Iterable<string>) {\n\t\tconst path = [{ part: \"\", node: this.root }];\n\t\tlet i = 0;\n\t\tfor (const part of key) {\n\t\t\tconst node = path[i].node.children?.get(part);\n\t\t\tif (!node) {\n\t\t\t\treturn; // node not in tree\n\t\t\t}\n\n\t\t\tpath.push({ part, node });\n\t\t\ti++;\n\t\t}\n\n\t\treturn path;\n\t}\n\n\tprivate opNode(\n\t\tkey: Iterable<string>,\n\t\tfn: (node: Node<V>) => void,\n\t\tonDescend?: (node: Node<V>) => void,\n\t): void {\n\t\tlet node = this.root;\n\t\tfor (const part of key) {\n\t\t\tif (!node.children) {\n\t\t\t\tconst next = new Node<V>();\n\t\t\t\tnode.children = new Map([[part, next]]);\n\t\t\t\tnode = next;\n\t\t\t} else if (node.children.has(part)) {\n\t\t\t\tnode = node.children.get(part)!;\n\t\t\t} else {\n\t\t\t\tconst next = new Node<V>();\n\t\t\t\tnode.children.set(part, next);\n\t\t\t\tnode = next;\n\t\t\t}\n\t\t\tonDescend?.(node);\n\t\t}\n\n\t\tconst sizeBefore = node._value === unset ? 0 : 1;\n\t\tfn(node);\n\t\tconst sizeAfter = node._value === unset ? 0 : 1;\n\t\tthis._size += sizeAfter - sizeBefore;\n\t}\n\n\t/** Returns an iterable of the tree values in no defined order. */\n\t*values() {\n\t\tfor (const { _value } of bfsIterate(this.root)) {\n\t\t\tif (_value !== unset) {\n\t\t\t\tyield _value;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction* bfsIterate<T>(root: Node<T>): Iterable<Node<T>> {\n\tconst stack = [root];\n\twhile (stack.length > 0) {\n\t\tconst node = stack.pop()!;\n\t\tyield node;\n\n\t\tif (node.children) {\n\t\t\tfor (const child of node.children.values()) {\n\t\t\t\tstack.push(child);\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass Node<T> implements IPrefixTreeNode<T> {\n\tpublic children?: Map<string, Node<T>>;\n\n\tpublic get value() {\n\t\treturn this._value === unset ? undefined : this._value;\n\t}\n\n\tpublic set value(value: T | undefined) {\n\t\tthis._value = value === undefined ? unset : value;\n\t}\n\n\tpublic _value: T | typeof unset = unset;\n}\n"],
  "mappings": "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",
  "names": []
}
