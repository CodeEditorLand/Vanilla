{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/hash.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from './strings.js';\n\n/**\n * Return a hash value for an object.\n */\nexport function hash(obj: any): number {\n\treturn doHash(obj, 0);\n}\n\nexport function doHash(obj: any, hashVal: number): number {\n\tswitch (typeof obj) {\n\t\tcase 'object':\n\t\t\tif (obj === null) {\n\t\t\t\treturn numberHash(349, hashVal);\n\t\t\t} else if (Array.isArray(obj)) {\n\t\t\t\treturn arrayHash(obj, hashVal);\n\t\t\t}\n\t\t\treturn objectHash(obj, hashVal);\n\t\tcase 'string':\n\t\t\treturn stringHash(obj, hashVal);\n\t\tcase 'boolean':\n\t\t\treturn booleanHash(obj, hashVal);\n\t\tcase 'number':\n\t\t\treturn numberHash(obj, hashVal);\n\t\tcase 'undefined':\n\t\t\treturn numberHash(937, hashVal);\n\t\tdefault:\n\t\t\treturn numberHash(617, hashVal);\n\t}\n}\n\nexport function numberHash(val: number, initialHashVal: number): number {\n\treturn (((initialHashVal << 5) - initialHashVal) + val) | 0;  // hashVal * 31 + ch, keep as int32\n}\n\nfunction booleanHash(b: boolean, initialHashVal: number): number {\n\treturn numberHash(b ? 433 : 863, initialHashVal);\n}\n\nexport function stringHash(s: string, hashVal: number) {\n\thashVal = numberHash(149417, hashVal);\n\tfor (let i = 0, length = s.length; i < length; i++) {\n\t\thashVal = numberHash(s.charCodeAt(i), hashVal);\n\t}\n\treturn hashVal;\n}\n\nfunction arrayHash(arr: any[], initialHashVal: number): number {\n\tinitialHashVal = numberHash(104579, initialHashVal);\n\treturn arr.reduce((hashVal, item) => doHash(item, hashVal), initialHashVal);\n}\n\nfunction objectHash(obj: any, initialHashVal: number): number {\n\tinitialHashVal = numberHash(181387, initialHashVal);\n\treturn Object.keys(obj).sort().reduce((hashVal, key) => {\n\t\thashVal = stringHash(key, hashVal);\n\t\treturn doHash(obj[key], hashVal);\n\t}, initialHashVal);\n}\n\nexport class Hasher {\n\n\tprivate _value = 0;\n\n\tget value(): number {\n\t\treturn this._value;\n\t}\n\n\thash(obj: any): number {\n\t\tthis._value = doHash(obj, this._value);\n\t\treturn this._value;\n\t}\n}\n\nconst enum SHA1Constant {\n\tBLOCK_SIZE = 64, // 512 / 8\n\tUNICODE_REPLACEMENT = 0xFFFD,\n}\n\nfunction leftRotate(value: number, bits: number, totalBits: number = 32): number {\n\t// delta + bits = totalBits\n\tconst delta = totalBits - bits;\n\n\t// All ones, expect `delta` zeros aligned to the right\n\tconst mask = ~((1 << delta) - 1);\n\n\t// Join (value left-shifted `bits` bits) with (masked value right-shifted `delta` bits)\n\treturn ((value << bits) | ((mask & value) >>> delta)) >>> 0;\n}\n\nfunction fill(dest: Uint8Array, index: number = 0, count: number = dest.byteLength, value: number = 0): void {\n\tfor (let i = 0; i < count; i++) {\n\t\tdest[index + i] = value;\n\t}\n}\n\nfunction leftPad(value: string, length: number, char: string = '0'): string {\n\twhile (value.length < length) {\n\t\tvalue = char + value;\n\t}\n\treturn value;\n}\n\nexport function toHexString(buffer: ArrayBuffer): string;\nexport function toHexString(value: number, bitsize?: number): string;\nexport function toHexString(bufferOrValue: ArrayBuffer | number, bitsize: number = 32): string {\n\tif (bufferOrValue instanceof ArrayBuffer) {\n\t\treturn Array.from(new Uint8Array(bufferOrValue)).map(b => b.toString(16).padStart(2, '0')).join('');\n\t}\n\n\treturn leftPad((bufferOrValue >>> 0).toString(16), bitsize / 4);\n}\n\n/**\n * A SHA1 implementation that works with strings and does not allocate.\n */\nexport class StringSHA1 {\n\tprivate static _bigBlock32 = new DataView(new ArrayBuffer(320)); // 80 * 4 = 320\n\n\tprivate _h0 = 0x67452301;\n\tprivate _h1 = 0xEFCDAB89;\n\tprivate _h2 = 0x98BADCFE;\n\tprivate _h3 = 0x10325476;\n\tprivate _h4 = 0xC3D2E1F0;\n\n\tprivate readonly _buff: Uint8Array;\n\tprivate readonly _buffDV: DataView;\n\tprivate _buffLen: number;\n\tprivate _totalLen: number;\n\tprivate _leftoverHighSurrogate: number;\n\tprivate _finished: boolean;\n\n\tconstructor() {\n\t\tthis._buff = new Uint8Array(SHA1Constant.BLOCK_SIZE + 3 /* to fit any utf-8 */);\n\t\tthis._buffDV = new DataView(this._buff.buffer);\n\t\tthis._buffLen = 0;\n\t\tthis._totalLen = 0;\n\t\tthis._leftoverHighSurrogate = 0;\n\t\tthis._finished = false;\n\t}\n\n\tpublic update(str: string): void {\n\t\tconst strLen = str.length;\n\t\tif (strLen === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst buff = this._buff;\n\t\tlet buffLen = this._buffLen;\n\t\tlet leftoverHighSurrogate = this._leftoverHighSurrogate;\n\t\tlet charCode: number;\n\t\tlet offset: number;\n\n\t\tif (leftoverHighSurrogate !== 0) {\n\t\t\tcharCode = leftoverHighSurrogate;\n\t\t\toffset = -1;\n\t\t\tleftoverHighSurrogate = 0;\n\t\t} else {\n\t\t\tcharCode = str.charCodeAt(0);\n\t\t\toffset = 0;\n\t\t}\n\n\t\twhile (true) {\n\t\t\tlet codePoint = charCode;\n\t\t\tif (strings.isHighSurrogate(charCode)) {\n\t\t\t\tif (offset + 1 < strLen) {\n\t\t\t\t\tconst nextCharCode = str.charCodeAt(offset + 1);\n\t\t\t\t\tif (strings.isLowSurrogate(nextCharCode)) {\n\t\t\t\t\t\toffset++;\n\t\t\t\t\t\tcodePoint = strings.computeCodePoint(charCode, nextCharCode);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// illegal => unicode replacement character\n\t\t\t\t\t\tcodePoint = SHA1Constant.UNICODE_REPLACEMENT;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// last character is a surrogate pair\n\t\t\t\t\tleftoverHighSurrogate = charCode;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (strings.isLowSurrogate(charCode)) {\n\t\t\t\t// illegal => unicode replacement character\n\t\t\t\tcodePoint = SHA1Constant.UNICODE_REPLACEMENT;\n\t\t\t}\n\n\t\t\tbuffLen = this._push(buff, buffLen, codePoint);\n\t\t\toffset++;\n\t\t\tif (offset < strLen) {\n\t\t\t\tcharCode = str.charCodeAt(offset);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tthis._buffLen = buffLen;\n\t\tthis._leftoverHighSurrogate = leftoverHighSurrogate;\n\t}\n\n\tprivate _push(buff: Uint8Array, buffLen: number, codePoint: number): number {\n\t\tif (codePoint < 0x0080) {\n\t\t\tbuff[buffLen++] = codePoint;\n\t\t} else if (codePoint < 0x0800) {\n\t\t\tbuff[buffLen++] = 0b11000000 | ((codePoint & 0b00000000000000000000011111000000) >>> 6);\n\t\t\tbuff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);\n\t\t} else if (codePoint < 0x10000) {\n\t\t\tbuff[buffLen++] = 0b11100000 | ((codePoint & 0b00000000000000001111000000000000) >>> 12);\n\t\t\tbuff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000111111000000) >>> 6);\n\t\t\tbuff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);\n\t\t} else {\n\t\t\tbuff[buffLen++] = 0b11110000 | ((codePoint & 0b00000000000111000000000000000000) >>> 18);\n\t\t\tbuff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000111111000000000000) >>> 12);\n\t\t\tbuff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000111111000000) >>> 6);\n\t\t\tbuff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);\n\t\t}\n\n\t\tif (buffLen >= SHA1Constant.BLOCK_SIZE) {\n\t\t\tthis._step();\n\t\t\tbuffLen -= SHA1Constant.BLOCK_SIZE;\n\t\t\tthis._totalLen += SHA1Constant.BLOCK_SIZE;\n\t\t\t// take last 3 in case of UTF8 overflow\n\t\t\tbuff[0] = buff[SHA1Constant.BLOCK_SIZE + 0];\n\t\t\tbuff[1] = buff[SHA1Constant.BLOCK_SIZE + 1];\n\t\t\tbuff[2] = buff[SHA1Constant.BLOCK_SIZE + 2];\n\t\t}\n\n\t\treturn buffLen;\n\t}\n\n\tpublic digest(): string {\n\t\tif (!this._finished) {\n\t\t\tthis._finished = true;\n\t\t\tif (this._leftoverHighSurrogate) {\n\t\t\t\t// illegal => unicode replacement character\n\t\t\t\tthis._leftoverHighSurrogate = 0;\n\t\t\t\tthis._buffLen = this._push(this._buff, this._buffLen, SHA1Constant.UNICODE_REPLACEMENT);\n\t\t\t}\n\t\t\tthis._totalLen += this._buffLen;\n\t\t\tthis._wrapUp();\n\t\t}\n\n\t\treturn toHexString(this._h0) + toHexString(this._h1) + toHexString(this._h2) + toHexString(this._h3) + toHexString(this._h4);\n\t}\n\n\tprivate _wrapUp(): void {\n\t\tthis._buff[this._buffLen++] = 0x80;\n\t\tfill(this._buff, this._buffLen);\n\n\t\tif (this._buffLen > 56) {\n\t\t\tthis._step();\n\t\t\tfill(this._buff);\n\t\t}\n\n\t\t// this will fit because the mantissa can cover up to 52 bits\n\t\tconst ml = 8 * this._totalLen;\n\n\t\tthis._buffDV.setUint32(56, Math.floor(ml / 4294967296), false);\n\t\tthis._buffDV.setUint32(60, ml % 4294967296, false);\n\n\t\tthis._step();\n\t}\n\n\tprivate _step(): void {\n\t\tconst bigBlock32 = StringSHA1._bigBlock32;\n\t\tconst data = this._buffDV;\n\n\t\tfor (let j = 0; j < 64 /* 16*4 */; j += 4) {\n\t\t\tbigBlock32.setUint32(j, data.getUint32(j, false), false);\n\t\t}\n\n\t\tfor (let j = 64; j < 320 /* 80*4 */; j += 4) {\n\t\t\tbigBlock32.setUint32(j, leftRotate((bigBlock32.getUint32(j - 12, false) ^ bigBlock32.getUint32(j - 32, false) ^ bigBlock32.getUint32(j - 56, false) ^ bigBlock32.getUint32(j - 64, false)), 1), false);\n\t\t}\n\n\t\tlet a = this._h0;\n\t\tlet b = this._h1;\n\t\tlet c = this._h2;\n\t\tlet d = this._h3;\n\t\tlet e = this._h4;\n\n\t\tlet f: number, k: number;\n\t\tlet temp: number;\n\n\t\tfor (let j = 0; j < 80; j++) {\n\t\t\tif (j < 20) {\n\t\t\t\tf = (b & c) | ((~b) & d);\n\t\t\t\tk = 0x5A827999;\n\t\t\t} else if (j < 40) {\n\t\t\t\tf = b ^ c ^ d;\n\t\t\t\tk = 0x6ED9EBA1;\n\t\t\t} else if (j < 60) {\n\t\t\t\tf = (b & c) | (b & d) | (c & d);\n\t\t\t\tk = 0x8F1BBCDC;\n\t\t\t} else {\n\t\t\t\tf = b ^ c ^ d;\n\t\t\t\tk = 0xCA62C1D6;\n\t\t\t}\n\n\t\t\ttemp = (leftRotate(a, 5) + f + e + k + bigBlock32.getUint32(j * 4, false)) & 0xffffffff;\n\t\t\te = d;\n\t\t\td = c;\n\t\t\tc = leftRotate(b, 30);\n\t\t\tb = a;\n\t\t\ta = temp;\n\t\t}\n\n\t\tthis._h0 = (this._h0 + a) & 0xffffffff;\n\t\tthis._h1 = (this._h1 + b) & 0xffffffff;\n\t\tthis._h2 = (this._h2 + c) & 0xffffffff;\n\t\tthis._h3 = (this._h3 + d) & 0xffffffff;\n\t\tthis._h4 = (this._h4 + e) & 0xffffffff;\n\t}\n}\n"],
  "mappings": "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",
  "names": ["SHA1Constant"]
}
