{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/jsonc.js"],
  "sourcesContent": ["// ESM-uncomment-begin\n/** @type any */\nconst module = { exports: {} };\n// ESM-uncomment-end\n\n(() => {\n\t// ESM-comment-begin\n\t// const isESM = false;\n\t// ESM-comment-end\n\t// ESM-uncomment-begin\n\tconst isESM = true;\n\t// ESM-uncomment-end\n\n\tfunction factory() {\n\t\t// First group matches a double quoted string\n\t\t// Second group matches a single quoted string\n\t\t// Third group matches a multi line comment\n\t\t// Forth group matches a single line comment\n\t\t// Fifth group matches a trailing comma\n\t\tconst regexp =\n\t\t\t/(\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\")|('[^'\\\\]*(?:\\\\.[^'\\\\]*)*')|(\\/\\*[^/*]*(?:(?:\\*|\\/)[^/*]*)*?\\*\\/)|(\\/{2,}.*?(?:(?:\\r?\\n)|$))|(,\\s*[}\\]])/g;\n\n\t\t/**\n\t\t * @param {string} content\n\t\t * @returns {string}\n\t\t */\n\t\tfunction stripComments(content) {\n\t\t\treturn content.replace(regexp, (match, _m1, _m2, m3, m4, m5) => {\n\t\t\t\t// Only one of m1, m2, m3, m4, m5 matches\n\t\t\t\tif (m3) {\n\t\t\t\t\t// A block comment. Replace with nothing\n\t\t\t\t\treturn \"\";\n\t\t\t\t} else if (m4) {\n\t\t\t\t\t// Since m4 is a single line comment is is at least of length 2 (e.g. //)\n\t\t\t\t\t// If it ends in \\r?\\n then keep it.\n\t\t\t\t\tconst length = m4.length;\n\t\t\t\t\tif (m4[length - 1] === \"\\n\") {\n\t\t\t\t\t\treturn m4[length - 2] === \"\\r\" ? \"\\r\\n\" : \"\\n\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t}\n\t\t\t\t} else if (m5) {\n\t\t\t\t\t// Remove the trailing comma\n\t\t\t\t\treturn match.substring(1);\n\t\t\t\t} else {\n\t\t\t\t\t// We match a string\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * @param {string} content\n\t\t * @returns {any}\n\t\t */\n\t\tfunction parse(content) {\n\t\t\tconst commentsStripped = stripComments(content);\n\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(commentsStripped);\n\t\t\t} catch (error) {\n\t\t\t\tconst trailingCommasStriped = commentsStripped.replace(\n\t\t\t\t\t/,\\s*([}\\]])/g,\n\t\t\t\t\t\"$1\",\n\t\t\t\t);\n\t\t\t\treturn JSON.parse(trailingCommasStriped);\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tstripComments,\n\t\t\tparse,\n\t\t};\n\t}\n\n\tif (!isESM && typeof define === \"function\") {\n\t\t// amd\n\t\tdefine([], () => factory());\n\t} else if (\n\t\ttypeof module === \"object\" &&\n\t\ttypeof module.exports === \"object\"\n\t) {\n\t\t// commonjs\n\t\tmodule.exports = factory();\n\t} else {\n\t\tconsole.trace(\n\t\t\t\"jsonc defined in UNKNOWN context (neither requirejs or commonjs)\",\n\t\t);\n\t}\n})();\n\n// ESM-uncomment-begin\nexport const stripComments = module.exports.stripComments;\nexport const parse = module.exports.parse;\n// ESM-uncomment-end\n"],
  "mappings": ";;AAEA,MAAM,SAAS,EAAE,SAAS,CAAC,EAAE;AAAA,CAG5B,MAAM;AAKN,QAAM,QAAQ;AAGd,WAAS,UAAU;AAMlB,UAAM,SACL;AAMD,aAASA,eAAc,SAAS;AAC/B,aAAO,QAAQ,QAAQ,QAAQ,CAAC,OAAO,KAAK,KAAK,IAAI,IAAI,OAAO;AAE/D,YAAI,IAAI;AAEP,iBAAO;AAAA,QACR,WAAW,IAAI;AAGd,gBAAM,SAAS,GAAG;AAClB,cAAI,GAAG,SAAS,CAAC,MAAM,MAAM;AAC5B,mBAAO,GAAG,SAAS,CAAC,MAAM,OAAO,SAAS;AAAA,UAC3C,OAAO;AACN,mBAAO;AAAA,UACR;AAAA,QACD,WAAW,IAAI;AAEd,iBAAO,MAAM,UAAU,CAAC;AAAA,QACzB,OAAO;AAEN,iBAAO;AAAA,QACR;AAAA,MACD,CAAC;AAAA,IACF;AAvBS,WAAAA,gBAAA;AA6BT,aAASC,OAAM,SAAS;AACvB,YAAM,mBAAmBD,eAAc,OAAO;AAE9C,UAAI;AACH,eAAO,KAAK,MAAM,gBAAgB;AAAA,MACnC,SAAS,OAAO;AACf,cAAM,wBAAwB,iBAAiB;AAAA,UAC9C;AAAA,UACA;AAAA,QACD;AACA,eAAO,KAAK,MAAM,qBAAqB;AAAA,MACxC;AAAA,IACD;AAZS,WAAAC,QAAA;AAaT,WAAO;AAAA,MACN,eAAAD;AAAA,MACA,OAAAC;AAAA,IACD;AAAA,EACD;AA3DS;AA6DT,MAAI,CAAC,SAAS,OAAO,WAAW,YAAY;AAE3C,WAAO,CAAC,GAAG,MAAM,QAAQ,CAAC;AAAA,EAC3B,WACC,OAAO,WAAW,YAClB,OAAO,OAAO,YAAY,UACzB;AAED,WAAO,UAAU,QAAQ;AAAA,EAC1B,OAAO;AACN,YAAQ;AAAA,MACP;AAAA,IACD;AAAA,EACD;AACD,GAAG;AAGI,MAAM,gBAAgB,OAAO,QAAQ;AACrC,MAAM,QAAQ,OAAO,QAAQ;",
  "names": ["stripComments", "parse"]
}
