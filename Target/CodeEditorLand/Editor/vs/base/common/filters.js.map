{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/filters.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from \"./charCode.js\";\nimport { LRUCache } from \"./map.js\";\nimport { getKoreanAltChars } from \"./naturalLanguage/korean.js\";\nimport * as strings from \"./strings.js\";\n\nexport interface IFilter {\n\t// Returns null if word doesn't match.\n\t(word: string, wordToMatchAgainst: string): IMatch[] | null;\n}\n\nexport interface IMatch {\n\tstart: number;\n\tend: number;\n}\n\n// Combined filters\n\n/**\n * @returns A filter which combines the provided set\n * of filters with an or. The *first* filters that\n * matches defined the return value of the returned\n * filter.\n */\nexport function or(...filter: IFilter[]): IFilter {\n\treturn (word: string, wordToMatchAgainst: string): IMatch[] | null => {\n\t\tfor (let i = 0, len = filter.length; i < len; i++) {\n\t\t\tconst match = filter[i](word, wordToMatchAgainst);\n\t\t\tif (match) {\n\t\t\t\treturn match;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n}\n\n// Prefix\n\nexport const matchesStrictPrefix: IFilter = _matchesPrefix.bind(\n\tundefined,\n\tfalse,\n);\nexport const matchesPrefix: IFilter = _matchesPrefix.bind(undefined, true);\n\nfunction _matchesPrefix(\n\tignoreCase: boolean,\n\tword: string,\n\twordToMatchAgainst: string,\n): IMatch[] | null {\n\tif (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {\n\t\treturn null;\n\t}\n\n\tlet matches: boolean;\n\tif (ignoreCase) {\n\t\tmatches = strings.startsWithIgnoreCase(wordToMatchAgainst, word);\n\t} else {\n\t\tmatches = wordToMatchAgainst.indexOf(word) === 0;\n\t}\n\n\tif (!matches) {\n\t\treturn null;\n\t}\n\n\treturn word.length > 0 ? [{ start: 0, end: word.length }] : [];\n}\n\n// Contiguous Substring\n\nexport function matchesContiguousSubString(\n\tword: string,\n\twordToMatchAgainst: string,\n): IMatch[] | null {\n\tconst index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());\n\tif (index === -1) {\n\t\treturn null;\n\t}\n\n\treturn [{ start: index, end: index + word.length }];\n}\n\n// Substring\n\nexport function matchesSubString(\n\tword: string,\n\twordToMatchAgainst: string,\n): IMatch[] | null {\n\treturn _matchesSubString(\n\t\tword.toLowerCase(),\n\t\twordToMatchAgainst.toLowerCase(),\n\t\t0,\n\t\t0,\n\t);\n}\n\nfunction _matchesSubString(\n\tword: string,\n\twordToMatchAgainst: string,\n\ti: number,\n\tj: number,\n): IMatch[] | null {\n\tif (i === word.length) {\n\t\treturn [];\n\t} else if (j === wordToMatchAgainst.length) {\n\t\treturn null;\n\t} else {\n\t\tif (word[i] === wordToMatchAgainst[j]) {\n\t\t\tlet result: IMatch[] | null = null;\n\t\t\tif (\n\t\t\t\t(result = _matchesSubString(\n\t\t\t\t\tword,\n\t\t\t\t\twordToMatchAgainst,\n\t\t\t\t\ti + 1,\n\t\t\t\t\tj + 1,\n\t\t\t\t))\n\t\t\t) {\n\t\t\t\treturn join({ start: j, end: j + 1 }, result);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\treturn _matchesSubString(word, wordToMatchAgainst, i, j + 1);\n\t}\n}\n\n// CamelCase\n\nfunction isLower(code: number): boolean {\n\treturn CharCode.a <= code && code <= CharCode.z;\n}\n\nexport function isUpper(code: number): boolean {\n\treturn CharCode.A <= code && code <= CharCode.Z;\n}\n\nfunction isNumber(code: number): boolean {\n\treturn CharCode.Digit0 <= code && code <= CharCode.Digit9;\n}\n\nfunction isWhitespace(code: number): boolean {\n\treturn (\n\t\tcode === CharCode.Space ||\n\t\tcode === CharCode.Tab ||\n\t\tcode === CharCode.LineFeed ||\n\t\tcode === CharCode.CarriageReturn\n\t);\n}\n\nconst wordSeparators = new Set<number>();\n// These are chosen as natural word separators based on writen text.\n// It is a subset of the word separators used by the monaco editor.\n\"()[]{}<>`'\\\"-/;:,.?!\"\n\t.split(\"\")\n\t.forEach((s) => wordSeparators.add(s.charCodeAt(0)));\n\nfunction isWordSeparator(code: number): boolean {\n\treturn isWhitespace(code) || wordSeparators.has(code);\n}\n\nfunction charactersMatch(codeA: number, codeB: number): boolean {\n\treturn (\n\t\tcodeA === codeB || (isWordSeparator(codeA) && isWordSeparator(codeB))\n\t);\n}\n\nconst alternateCharsCache: Map<number, ArrayLike<number> | undefined> =\n\tnew Map();\n/**\n * Gets alternative codes to the character code passed in. This comes in the\n * form of an array of character codes, all of which must match _in order_ to\n * successfully match.\n *\n * @param code The character code to check.\n */\nfunction getAlternateCodes(code: number): ArrayLike<number> | undefined {\n\tif (alternateCharsCache.has(code)) {\n\t\treturn alternateCharsCache.get(code);\n\t}\n\n\t// NOTE: This function is written in such a way that it can be extended in\n\t// the future, but right now the return type takes into account it's only\n\t// supported by a single \"alt codes provider\".\n\t// `ArrayLike<ArrayLike<number>>` is a more appropriate type if changed.\n\tlet result: ArrayLike<number> | undefined;\n\tconst codes = getKoreanAltChars(code);\n\tif (codes) {\n\t\tresult = codes;\n\t}\n\n\talternateCharsCache.set(code, result);\n\treturn result;\n}\n\nfunction isAlphanumeric(code: number): boolean {\n\treturn isLower(code) || isUpper(code) || isNumber(code);\n}\n\nfunction join(head: IMatch, tail: IMatch[]): IMatch[] {\n\tif (tail.length === 0) {\n\t\ttail = [head];\n\t} else if (head.end === tail[0].start) {\n\t\ttail[0].start = head.start;\n\t} else {\n\t\ttail.unshift(head);\n\t}\n\treturn tail;\n}\n\nfunction nextAnchor(camelCaseWord: string, start: number): number {\n\tfor (let i = start; i < camelCaseWord.length; i++) {\n\t\tconst c = camelCaseWord.charCodeAt(i);\n\t\tif (\n\t\t\tisUpper(c) ||\n\t\t\tisNumber(c) ||\n\t\t\t(i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1)))\n\t\t) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn camelCaseWord.length;\n}\n\nfunction _matchesCamelCase(\n\tword: string,\n\tcamelCaseWord: string,\n\ti: number,\n\tj: number,\n): IMatch[] | null {\n\tif (i === word.length) {\n\t\treturn [];\n\t} else if (j === camelCaseWord.length) {\n\t\treturn null;\n\t} else if (word[i] !== camelCaseWord[j].toLowerCase()) {\n\t\treturn null;\n\t} else {\n\t\tlet result: IMatch[] | null = null;\n\t\tlet nextUpperIndex = j + 1;\n\t\tresult = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);\n\t\twhile (\n\t\t\t!result &&\n\t\t\t(nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) <\n\t\t\t\tcamelCaseWord.length\n\t\t) {\n\t\t\tresult = _matchesCamelCase(\n\t\t\t\tword,\n\t\t\t\tcamelCaseWord,\n\t\t\t\ti + 1,\n\t\t\t\tnextUpperIndex,\n\t\t\t);\n\t\t\tnextUpperIndex++;\n\t\t}\n\t\treturn result === null ? null : join({ start: j, end: j + 1 }, result);\n\t}\n}\n\ninterface ICamelCaseAnalysis {\n\tupperPercent: number;\n\tlowerPercent: number;\n\talphaPercent: number;\n\tnumericPercent: number;\n}\n\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camelCaseWords.\nfunction analyzeCamelCaseWord(word: string): ICamelCaseAnalysis {\n\tlet upper = 0,\n\t\tlower = 0,\n\t\talpha = 0,\n\t\tnumeric = 0,\n\t\tcode = 0;\n\n\tfor (let i = 0; i < word.length; i++) {\n\t\tcode = word.charCodeAt(i);\n\n\t\tif (isUpper(code)) {\n\t\t\tupper++;\n\t\t}\n\t\tif (isLower(code)) {\n\t\t\tlower++;\n\t\t}\n\t\tif (isAlphanumeric(code)) {\n\t\t\talpha++;\n\t\t}\n\t\tif (isNumber(code)) {\n\t\t\tnumeric++;\n\t\t}\n\t}\n\n\tconst upperPercent = upper / word.length;\n\tconst lowerPercent = lower / word.length;\n\tconst alphaPercent = alpha / word.length;\n\tconst numericPercent = numeric / word.length;\n\n\treturn { upperPercent, lowerPercent, alphaPercent, numericPercent };\n}\n\nfunction isUpperCaseWord(analysis: ICamelCaseAnalysis): boolean {\n\tconst { upperPercent, lowerPercent } = analysis;\n\treturn lowerPercent === 0 && upperPercent > 0.6;\n}\n\nfunction isCamelCaseWord(analysis: ICamelCaseAnalysis): boolean {\n\tconst { upperPercent, lowerPercent, alphaPercent, numericPercent } =\n\t\tanalysis;\n\treturn (\n\t\tlowerPercent > 0.2 &&\n\t\tupperPercent < 0.8 &&\n\t\talphaPercent > 0.6 &&\n\t\tnumericPercent < 0.2\n\t);\n}\n\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camel case patterns.\nfunction isCamelCasePattern(word: string): boolean {\n\tlet upper = 0,\n\t\tlower = 0,\n\t\tcode = 0,\n\t\twhitespace = 0;\n\n\tfor (let i = 0; i < word.length; i++) {\n\t\tcode = word.charCodeAt(i);\n\n\t\tif (isUpper(code)) {\n\t\t\tupper++;\n\t\t}\n\t\tif (isLower(code)) {\n\t\t\tlower++;\n\t\t}\n\t\tif (isWhitespace(code)) {\n\t\t\twhitespace++;\n\t\t}\n\t}\n\n\tif ((upper === 0 || lower === 0) && whitespace === 0) {\n\t\treturn word.length <= 30;\n\t} else {\n\t\treturn upper <= 5;\n\t}\n}\n\nexport function matchesCamelCase(\n\tword: string,\n\tcamelCaseWord: string,\n): IMatch[] | null {\n\tif (!camelCaseWord) {\n\t\treturn null;\n\t}\n\n\tcamelCaseWord = camelCaseWord.trim();\n\n\tif (camelCaseWord.length === 0) {\n\t\treturn null;\n\t}\n\n\tif (!isCamelCasePattern(word)) {\n\t\treturn null;\n\t}\n\n\t// TODO: Consider removing this check\n\tif (camelCaseWord.length > 60) {\n\t\tcamelCaseWord = camelCaseWord.substring(0, 60);\n\t}\n\n\tconst analysis = analyzeCamelCaseWord(camelCaseWord);\n\n\tif (!isCamelCaseWord(analysis)) {\n\t\tif (!isUpperCaseWord(analysis)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tcamelCaseWord = camelCaseWord.toLowerCase();\n\t}\n\n\tlet result: IMatch[] | null = null;\n\tlet i = 0;\n\n\tword = word.toLowerCase();\n\twhile (\n\t\ti < camelCaseWord.length &&\n\t\t(result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null\n\t) {\n\t\ti = nextAnchor(camelCaseWord, i + 1);\n\t}\n\n\treturn result;\n}\n\n// Matches beginning of words supporting non-ASCII languages\n// If `contiguous` is true then matches word with beginnings of the words in the target. E.g. \"pul\" will match \"Git: Pull\"\n// Otherwise also matches sub string of the word with beginnings of the words in the target. E.g. \"gp\" or \"g p\" will match \"Git: Pull\"\n// Useful in cases where the target is words (e.g. command labels)\n\nexport function matchesWords(\n\tword: string,\n\ttarget: string,\n\tcontiguous = false,\n): IMatch[] | null {\n\tif (!target || target.length === 0) {\n\t\treturn null;\n\t}\n\n\tlet result: IMatch[] | null = null;\n\tlet targetIndex = 0;\n\n\tword = word.toLowerCase();\n\ttarget = target.toLowerCase();\n\twhile (targetIndex < target.length) {\n\t\tresult = _matchesWords(word, target, 0, targetIndex, contiguous);\n\t\tif (result !== null) {\n\t\t\tbreak;\n\t\t}\n\t\ttargetIndex = nextWord(target, targetIndex + 1);\n\t}\n\n\treturn result;\n}\n\nfunction _matchesWords(\n\tword: string,\n\ttarget: string,\n\twordIndex: number,\n\ttargetIndex: number,\n\tcontiguous: boolean,\n): IMatch[] | null {\n\tlet targetIndexOffset = 0;\n\n\tif (wordIndex === word.length) {\n\t\treturn [];\n\t} else if (targetIndex === target.length) {\n\t\treturn null;\n\t} else if (\n\t\t!charactersMatch(\n\t\t\tword.charCodeAt(wordIndex),\n\t\t\ttarget.charCodeAt(targetIndex),\n\t\t)\n\t) {\n\t\t// Verify alternate characters before exiting\n\t\tconst altChars = getAlternateCodes(word.charCodeAt(wordIndex));\n\t\tif (!altChars) {\n\t\t\treturn null;\n\t\t}\n\t\tfor (let k = 0; k < altChars.length; k++) {\n\t\t\tif (\n\t\t\t\t!charactersMatch(\n\t\t\t\t\taltChars[k],\n\t\t\t\t\ttarget.charCodeAt(targetIndex + k),\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\ttargetIndexOffset += altChars.length - 1;\n\t}\n\n\tlet result: IMatch[] | null = null;\n\tlet nextWordIndex = targetIndex + targetIndexOffset + 1;\n\tresult = _matchesWords(\n\t\tword,\n\t\ttarget,\n\t\twordIndex + 1,\n\t\tnextWordIndex,\n\t\tcontiguous,\n\t);\n\tif (!contiguous) {\n\t\twhile (\n\t\t\t!result &&\n\t\t\t(nextWordIndex = nextWord(target, nextWordIndex)) < target.length\n\t\t) {\n\t\t\tresult = _matchesWords(\n\t\t\t\tword,\n\t\t\t\ttarget,\n\t\t\t\twordIndex + 1,\n\t\t\t\tnextWordIndex,\n\t\t\t\tcontiguous,\n\t\t\t);\n\t\t\tnextWordIndex++;\n\t\t}\n\t}\n\n\tif (!result) {\n\t\treturn null;\n\t}\n\n\t// If the characters don't exactly match, then they must be word separators (see charactersMatch(...)).\n\t// We don't want to include this in the matches but we don't want to throw the target out all together so we return `result`.\n\tif (word.charCodeAt(wordIndex) !== target.charCodeAt(targetIndex)) {\n\t\t// Verify alternate characters before exiting\n\t\tconst altChars = getAlternateCodes(word.charCodeAt(wordIndex));\n\t\tif (!altChars) {\n\t\t\treturn result;\n\t\t}\n\t\tfor (let k = 0; k < altChars.length; k++) {\n\t\t\tif (altChars[k] !== target.charCodeAt(targetIndex + k)) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn join(\n\t\t{ start: targetIndex, end: targetIndex + targetIndexOffset + 1 },\n\t\tresult,\n\t);\n}\n\nfunction nextWord(word: string, start: number): number {\n\tfor (let i = start; i < word.length; i++) {\n\t\tif (\n\t\t\tisWordSeparator(word.charCodeAt(i)) ||\n\t\t\t(i > 0 && isWordSeparator(word.charCodeAt(i - 1)))\n\t\t) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn word.length;\n}\n\n// Fuzzy\n\nconst fuzzyContiguousFilter = or(\n\tmatchesPrefix,\n\tmatchesCamelCase,\n\tmatchesContiguousSubString,\n);\nconst fuzzySeparateFilter = or(\n\tmatchesPrefix,\n\tmatchesCamelCase,\n\tmatchesSubString,\n);\nconst fuzzyRegExpCache = new LRUCache<string, RegExp>(10000); // bounded to 10000 elements\n\nexport function matchesFuzzy(\n\tword: string,\n\twordToMatchAgainst: string,\n\tenableSeparateSubstringMatching = false,\n): IMatch[] | null {\n\tif (typeof word !== \"string\" || typeof wordToMatchAgainst !== \"string\") {\n\t\treturn null; // return early for invalid input\n\t}\n\n\t// Form RegExp for wildcard matches\n\tlet regexp = fuzzyRegExpCache.get(word);\n\tif (!regexp) {\n\t\tregexp = new RegExp(strings.convertSimple2RegExpPattern(word), \"i\");\n\t\tfuzzyRegExpCache.set(word, regexp);\n\t}\n\n\t// RegExp Filter\n\tconst match = regexp.exec(wordToMatchAgainst);\n\tif (match) {\n\t\treturn [{ start: match.index, end: match.index + match[0].length }];\n\t}\n\n\t// Default Filter\n\treturn enableSeparateSubstringMatching\n\t\t? fuzzySeparateFilter(word, wordToMatchAgainst)\n\t\t: fuzzyContiguousFilter(word, wordToMatchAgainst);\n}\n\n/**\n * Match pattern against word in a fuzzy way. As in IntelliSense and faster and more\n * powerful than `matchesFuzzy`\n */\nexport function matchesFuzzy2(pattern: string, word: string): IMatch[] | null {\n\tconst score = fuzzyScore(\n\t\tpattern,\n\t\tpattern.toLowerCase(),\n\t\t0,\n\t\tword,\n\t\tword.toLowerCase(),\n\t\t0,\n\t\t{ firstMatchCanBeWeak: true, boostFullMatch: true },\n\t);\n\treturn score ? createMatches(score) : null;\n}\n\nexport function anyScore(\n\tpattern: string,\n\tlowPattern: string,\n\tpatternPos: number,\n\tword: string,\n\tlowWord: string,\n\twordPos: number,\n): FuzzyScore {\n\tconst max = Math.min(13, pattern.length);\n\tfor (; patternPos < max; patternPos++) {\n\t\tconst result = fuzzyScore(\n\t\t\tpattern,\n\t\t\tlowPattern,\n\t\t\tpatternPos,\n\t\t\tword,\n\t\t\tlowWord,\n\t\t\twordPos,\n\t\t\t{ firstMatchCanBeWeak: true, boostFullMatch: true },\n\t\t);\n\t\tif (result) {\n\t\t\treturn result;\n\t\t}\n\t}\n\treturn [0, wordPos];\n}\n\n//#region --- fuzzyScore ---\n\nexport function createMatches(score: undefined | FuzzyScore): IMatch[] {\n\tif (typeof score === \"undefined\") {\n\t\treturn [];\n\t}\n\tconst res: IMatch[] = [];\n\tconst wordPos = score[1];\n\tfor (let i = score.length - 1; i > 1; i--) {\n\t\tconst pos = score[i] + wordPos;\n\t\tconst last = res[res.length - 1];\n\t\tif (last && last.end === pos) {\n\t\t\tlast.end = pos + 1;\n\t\t} else {\n\t\t\tres.push({ start: pos, end: pos + 1 });\n\t\t}\n\t}\n\treturn res;\n}\n\nconst _maxLen = 128;\n\nfunction initTable() {\n\tconst table: number[][] = [];\n\tconst row: number[] = [];\n\tfor (let i = 0; i <= _maxLen; i++) {\n\t\trow[i] = 0;\n\t}\n\tfor (let i = 0; i <= _maxLen; i++) {\n\t\ttable.push(row.slice(0));\n\t}\n\treturn table;\n}\n\nfunction initArr(maxLen: number) {\n\tconst row: number[] = [];\n\tfor (let i = 0; i <= maxLen; i++) {\n\t\trow[i] = 0;\n\t}\n\treturn row;\n}\n\nconst _minWordMatchPos = initArr(2 * _maxLen); // min word position for a certain pattern position\nconst _maxWordMatchPos = initArr(2 * _maxLen); // max word position for a certain pattern position\nconst _diag = initTable(); // the length of a contiguous diagonal match\nconst _table = initTable();\nconst _arrows = <Arrow[][]>initTable();\nconst _debug = false;\n\nfunction printTable(\n\ttable: number[][],\n\tpattern: string,\n\tpatternLen: number,\n\tword: string,\n\twordLen: number,\n): string {\n\tfunction pad(s: string, n: number, pad = \" \") {\n\t\twhile (s.length < n) {\n\t\t\ts = pad + s;\n\t\t}\n\t\treturn s;\n\t}\n\tlet ret = ` |   |${word\n\t\t.split(\"\")\n\t\t.map((c) => pad(c, 3))\n\t\t.join(\"|\")}\\n`;\n\n\tfor (let i = 0; i <= patternLen; i++) {\n\t\tif (i === 0) {\n\t\t\tret += \" |\";\n\t\t} else {\n\t\t\tret += `${pattern[i - 1]}|`;\n\t\t}\n\t\tret +=\n\t\t\ttable[i]\n\t\t\t\t.slice(0, wordLen + 1)\n\t\t\t\t.map((n) => pad(n.toString(), 3))\n\t\t\t\t.join(\"|\") + \"\\n\";\n\t}\n\treturn ret;\n}\n\nfunction printTables(\n\tpattern: string,\n\tpatternStart: number,\n\tword: string,\n\twordStart: number,\n): void {\n\tpattern = pattern.substr(patternStart);\n\tword = word.substr(wordStart);\n\tconsole.log(printTable(_table, pattern, pattern.length, word, word.length));\n\tconsole.log(\n\t\tprintTable(_arrows, pattern, pattern.length, word, word.length),\n\t);\n\tconsole.log(printTable(_diag, pattern, pattern.length, word, word.length));\n}\n\nfunction isSeparatorAtPos(value: string, index: number): boolean {\n\tif (index < 0 || index >= value.length) {\n\t\treturn false;\n\t}\n\tconst code = value.codePointAt(index);\n\tswitch (code) {\n\t\tcase CharCode.Underline:\n\t\tcase CharCode.Dash:\n\t\tcase CharCode.Period:\n\t\tcase CharCode.Space:\n\t\tcase CharCode.Slash:\n\t\tcase CharCode.Backslash:\n\t\tcase CharCode.SingleQuote:\n\t\tcase CharCode.DoubleQuote:\n\t\tcase CharCode.Colon:\n\t\tcase CharCode.DollarSign:\n\t\tcase CharCode.LessThan:\n\t\tcase CharCode.GreaterThan:\n\t\tcase CharCode.OpenParen:\n\t\tcase CharCode.CloseParen:\n\t\tcase CharCode.OpenSquareBracket:\n\t\tcase CharCode.CloseSquareBracket:\n\t\tcase CharCode.OpenCurlyBrace:\n\t\tcase CharCode.CloseCurlyBrace:\n\t\t\treturn true;\n\t\tcase undefined:\n\t\t\treturn false;\n\t\tdefault:\n\t\t\tif (strings.isEmojiImprecise(code)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t}\n}\n\nfunction isWhitespaceAtPos(value: string, index: number): boolean {\n\tif (index < 0 || index >= value.length) {\n\t\treturn false;\n\t}\n\tconst code = value.charCodeAt(index);\n\tswitch (code) {\n\t\tcase CharCode.Space:\n\t\tcase CharCode.Tab:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\nfunction isUpperCaseAtPos(pos: number, word: string, wordLow: string): boolean {\n\treturn word[pos] !== wordLow[pos];\n}\n\nexport function isPatternInWord(\n\tpatternLow: string,\n\tpatternPos: number,\n\tpatternLen: number,\n\twordLow: string,\n\twordPos: number,\n\twordLen: number,\n\tfillMinWordPosArr = false,\n): boolean {\n\twhile (patternPos < patternLen && wordPos < wordLen) {\n\t\tif (patternLow[patternPos] === wordLow[wordPos]) {\n\t\t\tif (fillMinWordPosArr) {\n\t\t\t\t// Remember the min word position for each pattern position\n\t\t\t\t_minWordMatchPos[patternPos] = wordPos;\n\t\t\t}\n\t\t\tpatternPos += 1;\n\t\t}\n\t\twordPos += 1;\n\t}\n\treturn patternPos === patternLen; // pattern must be exhausted\n}\n\nenum Arrow {\n\tDiag = 1,\n\tLeft = 2,\n\tLeftLeft = 3,\n}\n\n/**\n * An array representing a fuzzy match.\n *\n * 0. the score\n * 1. the offset at which matching started\n * 2. `<match_pos_N>`\n * 3. `<match_pos_1>`\n * 4. `<match_pos_0>` etc\n */\nexport type FuzzyScore = [\n\tscore: number,\n\twordStart: number,\n\t...matches: number[],\n];\n\nexport namespace FuzzyScore {\n\t/**\n\t * No matches and value `-100`\n\t */\n\texport const Default: FuzzyScore = [-100, 0];\n\n\texport function isDefault(score?: FuzzyScore): score is [-100, 0] {\n\t\treturn (\n\t\t\t!score ||\n\t\t\t(score.length === 2 && score[0] === -100 && score[1] === 0)\n\t\t);\n\t}\n}\n\nexport abstract class FuzzyScoreOptions {\n\tstatic default = { boostFullMatch: true, firstMatchCanBeWeak: false };\n\n\tconstructor(\n\t\treadonly firstMatchCanBeWeak: boolean,\n\t\treadonly boostFullMatch: boolean,\n\t) {}\n}\n\nexport interface FuzzyScorer {\n\t(\n\t\tpattern: string,\n\t\tlowPattern: string,\n\t\tpatternPos: number,\n\t\tword: string,\n\t\tlowWord: string,\n\t\twordPos: number,\n\t\toptions?: FuzzyScoreOptions,\n\t): FuzzyScore | undefined;\n}\n\nexport function fuzzyScore(\n\tpattern: string,\n\tpatternLow: string,\n\tpatternStart: number,\n\tword: string,\n\twordLow: string,\n\twordStart: number,\n\toptions: FuzzyScoreOptions = FuzzyScoreOptions.default,\n): FuzzyScore | undefined {\n\tconst patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;\n\tconst wordLen = word.length > _maxLen ? _maxLen : word.length;\n\n\tif (\n\t\tpatternStart >= patternLen ||\n\t\twordStart >= wordLen ||\n\t\tpatternLen - patternStart > wordLen - wordStart\n\t) {\n\t\treturn undefined;\n\t}\n\n\t// Run a simple check if the characters of pattern occur\n\t// (in order) at all in word. If that isn't the case we\n\t// stop because no match will be possible\n\tif (\n\t\t!isPatternInWord(\n\t\t\tpatternLow,\n\t\t\tpatternStart,\n\t\t\tpatternLen,\n\t\t\twordLow,\n\t\t\twordStart,\n\t\t\twordLen,\n\t\t\ttrue,\n\t\t)\n\t) {\n\t\treturn undefined;\n\t}\n\n\t// Find the max matching word position for each pattern position\n\t// NOTE: the min matching word position was filled in above, in the `isPatternInWord` call\n\t_fillInMaxWordMatchPos(\n\t\tpatternLen,\n\t\twordLen,\n\t\tpatternStart,\n\t\twordStart,\n\t\tpatternLow,\n\t\twordLow,\n\t);\n\n\tlet row = 1;\n\tlet column = 1;\n\tlet patternPos = patternStart;\n\tlet wordPos = wordStart;\n\n\tconst hasStrongFirstMatch = [false];\n\n\t// There will be a match, fill in tables\n\tfor (\n\t\trow = 1, patternPos = patternStart;\n\t\tpatternPos < patternLen;\n\t\trow++, patternPos++\n\t) {\n\t\t// Reduce search space to possible matching word positions and to possible access from next row\n\t\tconst minWordMatchPos = _minWordMatchPos[patternPos];\n\t\tconst maxWordMatchPos = _maxWordMatchPos[patternPos];\n\t\tconst nextMaxWordMatchPos =\n\t\t\tpatternPos + 1 < patternLen\n\t\t\t\t? _maxWordMatchPos[patternPos + 1]\n\t\t\t\t: wordLen;\n\n\t\tfor (\n\t\t\tcolumn = minWordMatchPos - wordStart + 1, wordPos = minWordMatchPos;\n\t\t\twordPos < nextMaxWordMatchPos;\n\t\t\tcolumn++, wordPos++\n\t\t) {\n\t\t\tlet score = Number.MIN_SAFE_INTEGER;\n\t\t\tlet canComeDiag = false;\n\n\t\t\tif (wordPos <= maxWordMatchPos) {\n\t\t\t\tscore = _doScore(\n\t\t\t\t\tpattern,\n\t\t\t\t\tpatternLow,\n\t\t\t\t\tpatternPos,\n\t\t\t\t\tpatternStart,\n\t\t\t\t\tword,\n\t\t\t\t\twordLow,\n\t\t\t\t\twordPos,\n\t\t\t\t\twordLen,\n\t\t\t\t\twordStart,\n\t\t\t\t\t_diag[row - 1][column - 1] === 0,\n\t\t\t\t\thasStrongFirstMatch,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tlet diagScore = 0;\n\t\t\tif (score !== Number.MAX_SAFE_INTEGER) {\n\t\t\t\tcanComeDiag = true;\n\t\t\t\tdiagScore = score + _table[row - 1][column - 1];\n\t\t\t}\n\n\t\t\tconst canComeLeft = wordPos > minWordMatchPos;\n\t\t\tconst leftScore = canComeLeft\n\t\t\t\t? _table[row][column - 1] +\n\t\t\t\t\t(_diag[row][column - 1] > 0 ? -5 : 0)\n\t\t\t\t: 0; // penalty for a gap start\n\n\t\t\tconst canComeLeftLeft =\n\t\t\t\twordPos > minWordMatchPos + 1 && _diag[row][column - 1] > 0;\n\t\t\tconst leftLeftScore = canComeLeftLeft\n\t\t\t\t? _table[row][column - 2] +\n\t\t\t\t\t(_diag[row][column - 2] > 0 ? -5 : 0)\n\t\t\t\t: 0; // penalty for a gap start\n\n\t\t\tif (\n\t\t\t\tcanComeLeftLeft &&\n\t\t\t\t(!canComeLeft || leftLeftScore >= leftScore) &&\n\t\t\t\t(!canComeDiag || leftLeftScore >= diagScore)\n\t\t\t) {\n\t\t\t\t// always prefer choosing left left to jump over a diagonal because that means a match is earlier in the word\n\t\t\t\t_table[row][column] = leftLeftScore;\n\t\t\t\t_arrows[row][column] = Arrow.LeftLeft;\n\t\t\t\t_diag[row][column] = 0;\n\t\t\t} else if (\n\t\t\t\tcanComeLeft &&\n\t\t\t\t(!canComeDiag || leftScore >= diagScore)\n\t\t\t) {\n\t\t\t\t// always prefer choosing left since that means a match is earlier in the word\n\t\t\t\t_table[row][column] = leftScore;\n\t\t\t\t_arrows[row][column] = Arrow.Left;\n\t\t\t\t_diag[row][column] = 0;\n\t\t\t} else if (canComeDiag) {\n\t\t\t\t_table[row][column] = diagScore;\n\t\t\t\t_arrows[row][column] = Arrow.Diag;\n\t\t\t\t_diag[row][column] = _diag[row - 1][column - 1] + 1;\n\t\t\t} else {\n\t\t\t\tthrow new Error(`not possible`);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (_debug) {\n\t\tprintTables(pattern, patternStart, word, wordStart);\n\t}\n\n\tif (!hasStrongFirstMatch[0] && !options.firstMatchCanBeWeak) {\n\t\treturn undefined;\n\t}\n\n\trow--;\n\tcolumn--;\n\n\tconst result: FuzzyScore = [_table[row][column], wordStart];\n\n\tlet backwardsDiagLength = 0;\n\tlet maxMatchColumn = 0;\n\n\twhile (row >= 1) {\n\t\t// Find the column where we go diagonally up\n\t\tlet diagColumn = column;\n\t\tdo {\n\t\t\tconst arrow = _arrows[row][diagColumn];\n\t\t\tif (arrow === Arrow.LeftLeft) {\n\t\t\t\tdiagColumn = diagColumn - 2;\n\t\t\t} else if (arrow === Arrow.Left) {\n\t\t\t\tdiagColumn = diagColumn - 1;\n\t\t\t} else {\n\t\t\t\t// found the diagonal\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (diagColumn >= 1);\n\n\t\t// Overturn the \"forwards\" decision if keeping the \"backwards\" diagonal would give a better match\n\t\tif (\n\t\t\tbackwardsDiagLength > 1 && // only if we would have a contiguous match of 3 characters\n\t\t\tpatternLow[patternStart + row - 1] ===\n\t\t\t\twordLow[wordStart + column - 1] && // only if we can do a contiguous match diagonally\n\t\t\t!isUpperCaseAtPos(diagColumn + wordStart - 1, word, wordLow) && // only if the forwards chose diagonal is not an uppercase\n\t\t\tbackwardsDiagLength + 1 > _diag[row][diagColumn] // only if our contiguous match would be longer than the \"forwards\" contiguous match\n\t\t) {\n\t\t\tdiagColumn = column;\n\t\t}\n\n\t\tif (diagColumn === column) {\n\t\t\t// this is a contiguous match\n\t\t\tbackwardsDiagLength++;\n\t\t} else {\n\t\t\tbackwardsDiagLength = 1;\n\t\t}\n\n\t\tif (!maxMatchColumn) {\n\t\t\t// remember the last matched column\n\t\t\tmaxMatchColumn = diagColumn;\n\t\t}\n\n\t\trow--;\n\t\tcolumn = diagColumn - 1;\n\t\tresult.push(column);\n\t}\n\n\tif (wordLen - wordStart === patternLen && options.boostFullMatch) {\n\t\t// the word matches the pattern with all characters!\n\t\t// giving the score a total match boost (to come up ahead other words)\n\t\tresult[0] += 2;\n\t}\n\n\t// Add 1 penalty for each skipped character in the word\n\tconst skippedCharsCount = maxMatchColumn - patternLen;\n\tresult[0] -= skippedCharsCount;\n\n\treturn result;\n}\n\nfunction _fillInMaxWordMatchPos(\n\tpatternLen: number,\n\twordLen: number,\n\tpatternStart: number,\n\twordStart: number,\n\tpatternLow: string,\n\twordLow: string,\n) {\n\tlet patternPos = patternLen - 1;\n\tlet wordPos = wordLen - 1;\n\twhile (patternPos >= patternStart && wordPos >= wordStart) {\n\t\tif (patternLow[patternPos] === wordLow[wordPos]) {\n\t\t\t_maxWordMatchPos[patternPos] = wordPos;\n\t\t\tpatternPos--;\n\t\t}\n\t\twordPos--;\n\t}\n}\n\nfunction _doScore(\n\tpattern: string,\n\tpatternLow: string,\n\tpatternPos: number,\n\tpatternStart: number,\n\tword: string,\n\twordLow: string,\n\twordPos: number,\n\twordLen: number,\n\twordStart: number,\n\tnewMatchStart: boolean,\n\toutFirstMatchStrong: boolean[],\n): number {\n\tif (patternLow[patternPos] !== wordLow[wordPos]) {\n\t\treturn Number.MIN_SAFE_INTEGER;\n\t}\n\n\tlet score = 1;\n\tlet isGapLocation = false;\n\tif (wordPos === patternPos - patternStart) {\n\t\t// common prefix: `foobar <-> foobaz`\n\t\t//                            ^^^^^\n\t\tscore = pattern[patternPos] === word[wordPos] ? 7 : 5;\n\t} else if (\n\t\tisUpperCaseAtPos(wordPos, word, wordLow) &&\n\t\t(wordPos === 0 || !isUpperCaseAtPos(wordPos - 1, word, wordLow))\n\t) {\n\t\t// hitting upper-case: `foo <-> forOthers`\n\t\t//                              ^^ ^\n\t\tscore = pattern[patternPos] === word[wordPos] ? 7 : 5;\n\t\tisGapLocation = true;\n\t} else if (\n\t\tisSeparatorAtPos(wordLow, wordPos) &&\n\t\t(wordPos === 0 || !isSeparatorAtPos(wordLow, wordPos - 1))\n\t) {\n\t\t// hitting a separator: `. <-> foo.bar`\n\t\t//                                ^\n\t\tscore = 5;\n\t} else if (\n\t\tisSeparatorAtPos(wordLow, wordPos - 1) ||\n\t\tisWhitespaceAtPos(wordLow, wordPos - 1)\n\t) {\n\t\t// post separator: `foo <-> bar_foo`\n\t\t//                              ^^^\n\t\tscore = 5;\n\t\tisGapLocation = true;\n\t}\n\n\tif (score > 1 && patternPos === patternStart) {\n\t\toutFirstMatchStrong[0] = true;\n\t}\n\n\tif (!isGapLocation) {\n\t\tisGapLocation =\n\t\t\tisUpperCaseAtPos(wordPos, word, wordLow) ||\n\t\t\tisSeparatorAtPos(wordLow, wordPos - 1) ||\n\t\t\tisWhitespaceAtPos(wordLow, wordPos - 1);\n\t}\n\n\t//\n\tif (patternPos === patternStart) {\n\t\t// first character in pattern\n\t\tif (wordPos > wordStart) {\n\t\t\t// the first pattern character would match a word character that is not at the word start\n\t\t\t// so introduce a penalty to account for the gap preceding this match\n\t\t\tscore -= isGapLocation ? 3 : 5;\n\t\t}\n\t} else if (newMatchStart) {\n\t\t// this would be the beginning of a new match (i.e. there would be a gap before this location)\n\t\tscore += isGapLocation ? 2 : 0;\n\t} else {\n\t\t// this is part of a contiguous match, so give it a slight bonus, but do so only if it would not be a preferred gap location\n\t\tscore += isGapLocation ? 0 : 1;\n\t}\n\n\tif (wordPos + 1 === wordLen) {\n\t\t// we always penalize gaps, but this gives unfair advantages to a match that would match the last character in the word\n\t\t// so pretend there is a gap after the last character in the word to normalize things\n\t\tscore -= isGapLocation ? 3 : 5;\n\t}\n\n\treturn score;\n}\n\n//#endregion\n\n//#region --- graceful ---\n\nexport function fuzzyScoreGracefulAggressive(\n\tpattern: string,\n\tlowPattern: string,\n\tpatternPos: number,\n\tword: string,\n\tlowWord: string,\n\twordPos: number,\n\toptions?: FuzzyScoreOptions,\n): FuzzyScore | undefined {\n\treturn fuzzyScoreWithPermutations(\n\t\tpattern,\n\t\tlowPattern,\n\t\tpatternPos,\n\t\tword,\n\t\tlowWord,\n\t\twordPos,\n\t\ttrue,\n\t\toptions,\n\t);\n}\n\nexport function fuzzyScoreGraceful(\n\tpattern: string,\n\tlowPattern: string,\n\tpatternPos: number,\n\tword: string,\n\tlowWord: string,\n\twordPos: number,\n\toptions?: FuzzyScoreOptions,\n): FuzzyScore | undefined {\n\treturn fuzzyScoreWithPermutations(\n\t\tpattern,\n\t\tlowPattern,\n\t\tpatternPos,\n\t\tword,\n\t\tlowWord,\n\t\twordPos,\n\t\tfalse,\n\t\toptions,\n\t);\n}\n\nfunction fuzzyScoreWithPermutations(\n\tpattern: string,\n\tlowPattern: string,\n\tpatternPos: number,\n\tword: string,\n\tlowWord: string,\n\twordPos: number,\n\taggressive: boolean,\n\toptions?: FuzzyScoreOptions,\n): FuzzyScore | undefined {\n\tlet top = fuzzyScore(\n\t\tpattern,\n\t\tlowPattern,\n\t\tpatternPos,\n\t\tword,\n\t\tlowWord,\n\t\twordPos,\n\t\toptions,\n\t);\n\n\tif (top && !aggressive) {\n\t\t// when using the original pattern yield a result we`\n\t\t// return it unless we are aggressive and try to find\n\t\t// a better alignment, e.g. `cno` -> `^co^ns^ole` or `^c^o^nsole`.\n\t\treturn top;\n\t}\n\n\tif (pattern.length >= 3) {\n\t\t// When the pattern is long enough then try a few (max 7)\n\t\t// permutations of the pattern to find a better match. The\n\t\t// permutations only swap neighbouring characters, e.g\n\t\t// `cnoso` becomes `conso`, `cnsoo`, `cnoos`.\n\t\tconst tries = Math.min(7, pattern.length - 1);\n\t\tfor (\n\t\t\tlet movingPatternPos = patternPos + 1;\n\t\t\tmovingPatternPos < tries;\n\t\t\tmovingPatternPos++\n\t\t) {\n\t\t\tconst newPattern = nextTypoPermutation(pattern, movingPatternPos);\n\t\t\tif (newPattern) {\n\t\t\t\tconst candidate = fuzzyScore(\n\t\t\t\t\tnewPattern,\n\t\t\t\t\tnewPattern.toLowerCase(),\n\t\t\t\t\tpatternPos,\n\t\t\t\t\tword,\n\t\t\t\t\tlowWord,\n\t\t\t\t\twordPos,\n\t\t\t\t\toptions,\n\t\t\t\t);\n\t\t\t\tif (candidate) {\n\t\t\t\t\tcandidate[0] -= 3; // permutation penalty\n\t\t\t\t\tif (!top || candidate[0] > top[0]) {\n\t\t\t\t\t\ttop = candidate;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn top;\n}\n\nfunction nextTypoPermutation(\n\tpattern: string,\n\tpatternPos: number,\n): string | undefined {\n\tif (patternPos + 1 >= pattern.length) {\n\t\treturn undefined;\n\t}\n\n\tconst swap1 = pattern[patternPos];\n\tconst swap2 = pattern[patternPos + 1];\n\n\tif (swap1 === swap2) {\n\t\treturn undefined;\n\t}\n\n\treturn (\n\t\tpattern.slice(0, patternPos) +\n\t\tswap2 +\n\t\tswap1 +\n\t\tpattern.slice(patternPos + 2)\n\t);\n}\n\n//#endregion\n"],
  "mappings": "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",
  "names": ["pad", "Arrow", "FuzzyScore"]
}
