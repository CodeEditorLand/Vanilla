{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/filters.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from './charCode.js';\nimport { LRUCache } from './map.js';\nimport { getKoreanAltChars } from './naturalLanguage/korean.js';\nimport * as strings from './strings.js';\n\nexport interface IFilter {\n\t// Returns null if word doesn't match.\n\t(word: string, wordToMatchAgainst: string): IMatch[] | null;\n}\n\nexport interface IMatch {\n\tstart: number;\n\tend: number;\n}\n\n// Combined filters\n\n/**\n * @returns A filter which combines the provided set\n * of filters with an or. The *first* filters that\n * matches defined the return value of the returned\n * filter.\n */\nexport function or(...filter: IFilter[]): IFilter {\n\treturn function (word: string, wordToMatchAgainst: string): IMatch[] | null {\n\t\tfor (let i = 0, len = filter.length; i < len; i++) {\n\t\t\tconst match = filter[i](word, wordToMatchAgainst);\n\t\t\tif (match) {\n\t\t\t\treturn match;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n}\n\n// Prefix\n\nexport const matchesStrictPrefix: IFilter = _matchesPrefix.bind(undefined, false);\nexport const matchesPrefix: IFilter = _matchesPrefix.bind(undefined, true);\n\nfunction _matchesPrefix(ignoreCase: boolean, word: string, wordToMatchAgainst: string): IMatch[] | null {\n\tif (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {\n\t\treturn null;\n\t}\n\n\tlet matches: boolean;\n\tif (ignoreCase) {\n\t\tmatches = strings.startsWithIgnoreCase(wordToMatchAgainst, word);\n\t} else {\n\t\tmatches = wordToMatchAgainst.indexOf(word) === 0;\n\t}\n\n\tif (!matches) {\n\t\treturn null;\n\t}\n\n\treturn word.length > 0 ? [{ start: 0, end: word.length }] : [];\n}\n\n// Contiguous Substring\n\nexport function matchesContiguousSubString(word: string, wordToMatchAgainst: string): IMatch[] | null {\n\tconst index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());\n\tif (index === -1) {\n\t\treturn null;\n\t}\n\n\treturn [{ start: index, end: index + word.length }];\n}\n\n// Substring\n\nexport function matchesSubString(word: string, wordToMatchAgainst: string): IMatch[] | null {\n\treturn _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);\n}\n\nfunction _matchesSubString(word: string, wordToMatchAgainst: string, i: number, j: number): IMatch[] | null {\n\tif (i === word.length) {\n\t\treturn [];\n\t} else if (j === wordToMatchAgainst.length) {\n\t\treturn null;\n\t} else {\n\t\tif (word[i] === wordToMatchAgainst[j]) {\n\t\t\tlet result: IMatch[] | null = null;\n\t\t\tif (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {\n\t\t\t\treturn join({ start: j, end: j + 1 }, result);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\treturn _matchesSubString(word, wordToMatchAgainst, i, j + 1);\n\t}\n}\n\n// CamelCase\n\nfunction isLower(code: number): boolean {\n\treturn CharCode.a <= code && code <= CharCode.z;\n}\n\nexport function isUpper(code: number): boolean {\n\treturn CharCode.A <= code && code <= CharCode.Z;\n}\n\nfunction isNumber(code: number): boolean {\n\treturn CharCode.Digit0 <= code && code <= CharCode.Digit9;\n}\n\nfunction isWhitespace(code: number): boolean {\n\treturn (\n\t\tcode === CharCode.Space\n\t\t|| code === CharCode.Tab\n\t\t|| code === CharCode.LineFeed\n\t\t|| code === CharCode.CarriageReturn\n\t);\n}\n\nconst wordSeparators = new Set<number>();\n// These are chosen as natural word separators based on writen text.\n// It is a subset of the word separators used by the monaco editor.\n'()[]{}<>`\\'\"-/;:,.?!'\n\t.split('')\n\t.forEach(s => wordSeparators.add(s.charCodeAt(0)));\n\nfunction isWordSeparator(code: number): boolean {\n\treturn isWhitespace(code) || wordSeparators.has(code);\n}\n\nfunction charactersMatch(codeA: number, codeB: number): boolean {\n\treturn (codeA === codeB) || (isWordSeparator(codeA) && isWordSeparator(codeB));\n}\n\nconst alternateCharsCache: Map<number, ArrayLike<number> | undefined> = new Map();\n/**\n * Gets alternative codes to the character code passed in. This comes in the\n * form of an array of character codes, all of which must match _in order_ to\n * successfully match.\n *\n * @param code The character code to check.\n */\nfunction getAlternateCodes(code: number): ArrayLike<number> | undefined {\n\tif (alternateCharsCache.has(code)) {\n\t\treturn alternateCharsCache.get(code);\n\t}\n\n\t// NOTE: This function is written in such a way that it can be extended in\n\t// the future, but right now the return type takes into account it's only\n\t// supported by a single \"alt codes provider\".\n\t// `ArrayLike<ArrayLike<number>>` is a more appropriate type if changed.\n\tlet result: ArrayLike<number> | undefined;\n\tconst codes = getKoreanAltChars(code);\n\tif (codes) {\n\t\tresult = codes;\n\t}\n\n\talternateCharsCache.set(code, result);\n\treturn result;\n}\n\nfunction isAlphanumeric(code: number): boolean {\n\treturn isLower(code) || isUpper(code) || isNumber(code);\n}\n\nfunction join(head: IMatch, tail: IMatch[]): IMatch[] {\n\tif (tail.length === 0) {\n\t\ttail = [head];\n\t} else if (head.end === tail[0].start) {\n\t\ttail[0].start = head.start;\n\t} else {\n\t\ttail.unshift(head);\n\t}\n\treturn tail;\n}\n\nfunction nextAnchor(camelCaseWord: string, start: number): number {\n\tfor (let i = start; i < camelCaseWord.length; i++) {\n\t\tconst c = camelCaseWord.charCodeAt(i);\n\t\tif (isUpper(c) || isNumber(c) || (i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1)))) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn camelCaseWord.length;\n}\n\nfunction _matchesCamelCase(word: string, camelCaseWord: string, i: number, j: number): IMatch[] | null {\n\tif (i === word.length) {\n\t\treturn [];\n\t} else if (j === camelCaseWord.length) {\n\t\treturn null;\n\t} else if (word[i] !== camelCaseWord[j].toLowerCase()) {\n\t\treturn null;\n\t} else {\n\t\tlet result: IMatch[] | null = null;\n\t\tlet nextUpperIndex = j + 1;\n\t\tresult = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);\n\t\twhile (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {\n\t\t\tresult = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);\n\t\t\tnextUpperIndex++;\n\t\t}\n\t\treturn result === null ? null : join({ start: j, end: j + 1 }, result);\n\t}\n}\n\ninterface ICamelCaseAnalysis {\n\tupperPercent: number;\n\tlowerPercent: number;\n\talphaPercent: number;\n\tnumericPercent: number;\n}\n\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camelCaseWords.\nfunction analyzeCamelCaseWord(word: string): ICamelCaseAnalysis {\n\tlet upper = 0, lower = 0, alpha = 0, numeric = 0, code = 0;\n\n\tfor (let i = 0; i < word.length; i++) {\n\t\tcode = word.charCodeAt(i);\n\n\t\tif (isUpper(code)) { upper++; }\n\t\tif (isLower(code)) { lower++; }\n\t\tif (isAlphanumeric(code)) { alpha++; }\n\t\tif (isNumber(code)) { numeric++; }\n\t}\n\n\tconst upperPercent = upper / word.length;\n\tconst lowerPercent = lower / word.length;\n\tconst alphaPercent = alpha / word.length;\n\tconst numericPercent = numeric / word.length;\n\n\treturn { upperPercent, lowerPercent, alphaPercent, numericPercent };\n}\n\nfunction isUpperCaseWord(analysis: ICamelCaseAnalysis): boolean {\n\tconst { upperPercent, lowerPercent } = analysis;\n\treturn lowerPercent === 0 && upperPercent > 0.6;\n}\n\nfunction isCamelCaseWord(analysis: ICamelCaseAnalysis): boolean {\n\tconst { upperPercent, lowerPercent, alphaPercent, numericPercent } = analysis;\n\treturn lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;\n}\n\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camel case patterns.\nfunction isCamelCasePattern(word: string): boolean {\n\tlet upper = 0, lower = 0, code = 0, whitespace = 0;\n\n\tfor (let i = 0; i < word.length; i++) {\n\t\tcode = word.charCodeAt(i);\n\n\t\tif (isUpper(code)) { upper++; }\n\t\tif (isLower(code)) { lower++; }\n\t\tif (isWhitespace(code)) { whitespace++; }\n\t}\n\n\tif ((upper === 0 || lower === 0) && whitespace === 0) {\n\t\treturn word.length <= 30;\n\t} else {\n\t\treturn upper <= 5;\n\t}\n}\n\nexport function matchesCamelCase(word: string, camelCaseWord: string): IMatch[] | null {\n\tif (!camelCaseWord) {\n\t\treturn null;\n\t}\n\n\tcamelCaseWord = camelCaseWord.trim();\n\n\tif (camelCaseWord.length === 0) {\n\t\treturn null;\n\t}\n\n\tif (!isCamelCasePattern(word)) {\n\t\treturn null;\n\t}\n\n\t// TODO: Consider removing this check\n\tif (camelCaseWord.length > 60) {\n\t\tcamelCaseWord = camelCaseWord.substring(0, 60);\n\t}\n\n\tconst analysis = analyzeCamelCaseWord(camelCaseWord);\n\n\tif (!isCamelCaseWord(analysis)) {\n\t\tif (!isUpperCaseWord(analysis)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tcamelCaseWord = camelCaseWord.toLowerCase();\n\t}\n\n\tlet result: IMatch[] | null = null;\n\tlet i = 0;\n\n\tword = word.toLowerCase();\n\twhile (i < camelCaseWord.length && (result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null) {\n\t\ti = nextAnchor(camelCaseWord, i + 1);\n\t}\n\n\treturn result;\n}\n\n// Matches beginning of words supporting non-ASCII languages\n// If `contiguous` is true then matches word with beginnings of the words in the target. E.g. \"pul\" will match \"Git: Pull\"\n// Otherwise also matches sub string of the word with beginnings of the words in the target. E.g. \"gp\" or \"g p\" will match \"Git: Pull\"\n// Useful in cases where the target is words (e.g. command labels)\n\nexport function matchesWords(word: string, target: string, contiguous: boolean = false): IMatch[] | null {\n\tif (!target || target.length === 0) {\n\t\treturn null;\n\t}\n\n\tlet result: IMatch[] | null = null;\n\tlet targetIndex = 0;\n\n\tword = word.toLowerCase();\n\ttarget = target.toLowerCase();\n\twhile (targetIndex < target.length) {\n\t\tresult = _matchesWords(word, target, 0, targetIndex, contiguous);\n\t\tif (result !== null) {\n\t\t\tbreak;\n\t\t}\n\t\ttargetIndex = nextWord(target, targetIndex + 1);\n\t}\n\n\treturn result;\n}\n\nfunction _matchesWords(word: string, target: string, wordIndex: number, targetIndex: number, contiguous: boolean): IMatch[] | null {\n\tlet targetIndexOffset = 0;\n\n\tif (wordIndex === word.length) {\n\t\treturn [];\n\t} else if (targetIndex === target.length) {\n\t\treturn null;\n\t} else if (!charactersMatch(word.charCodeAt(wordIndex), target.charCodeAt(targetIndex))) {\n\t\t// Verify alternate characters before exiting\n\t\tconst altChars = getAlternateCodes(word.charCodeAt(wordIndex));\n\t\tif (!altChars) {\n\t\t\treturn null;\n\t\t}\n\t\tfor (let k = 0; k < altChars.length; k++) {\n\t\t\tif (!charactersMatch(altChars[k], target.charCodeAt(targetIndex + k))) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\ttargetIndexOffset += altChars.length - 1;\n\t}\n\n\tlet result: IMatch[] | null = null;\n\tlet nextWordIndex = targetIndex + targetIndexOffset + 1;\n\tresult = _matchesWords(word, target, wordIndex + 1, nextWordIndex, contiguous);\n\tif (!contiguous) {\n\t\twhile (!result && (nextWordIndex = nextWord(target, nextWordIndex)) < target.length) {\n\t\t\tresult = _matchesWords(word, target, wordIndex + 1, nextWordIndex, contiguous);\n\t\t\tnextWordIndex++;\n\t\t}\n\t}\n\n\tif (!result) {\n\t\treturn null;\n\t}\n\n\t// If the characters don't exactly match, then they must be word separators (see charactersMatch(...)).\n\t// We don't want to include this in the matches but we don't want to throw the target out all together so we return `result`.\n\tif (word.charCodeAt(wordIndex) !== target.charCodeAt(targetIndex)) {\n\t\t// Verify alternate characters before exiting\n\t\tconst altChars = getAlternateCodes(word.charCodeAt(wordIndex));\n\t\tif (!altChars) {\n\t\t\treturn result;\n\t\t}\n\t\tfor (let k = 0; k < altChars.length; k++) {\n\t\t\tif (altChars[k] !== target.charCodeAt(targetIndex + k)) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn join({ start: targetIndex, end: targetIndex + targetIndexOffset + 1 }, result);\n}\n\nfunction nextWord(word: string, start: number): number {\n\tfor (let i = start; i < word.length; i++) {\n\t\tif (isWordSeparator(word.charCodeAt(i)) ||\n\t\t\t(i > 0 && isWordSeparator(word.charCodeAt(i - 1)))) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn word.length;\n}\n\n// Fuzzy\n\nconst fuzzyContiguousFilter = or(matchesPrefix, matchesCamelCase, matchesContiguousSubString);\nconst fuzzySeparateFilter = or(matchesPrefix, matchesCamelCase, matchesSubString);\nconst fuzzyRegExpCache = new LRUCache<string, RegExp>(10000); // bounded to 10000 elements\n\nexport function matchesFuzzy(word: string, wordToMatchAgainst: string, enableSeparateSubstringMatching = false): IMatch[] | null {\n\tif (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {\n\t\treturn null; // return early for invalid input\n\t}\n\n\t// Form RegExp for wildcard matches\n\tlet regexp = fuzzyRegExpCache.get(word);\n\tif (!regexp) {\n\t\tregexp = new RegExp(strings.convertSimple2RegExpPattern(word), 'i');\n\t\tfuzzyRegExpCache.set(word, regexp);\n\t}\n\n\t// RegExp Filter\n\tconst match = regexp.exec(wordToMatchAgainst);\n\tif (match) {\n\t\treturn [{ start: match.index, end: match.index + match[0].length }];\n\t}\n\n\t// Default Filter\n\treturn enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);\n}\n\n/**\n * Match pattern against word in a fuzzy way. As in IntelliSense and faster and more\n * powerful than `matchesFuzzy`\n */\nexport function matchesFuzzy2(pattern: string, word: string): IMatch[] | null {\n\tconst score = fuzzyScore(pattern, pattern.toLowerCase(), 0, word, word.toLowerCase(), 0, { firstMatchCanBeWeak: true, boostFullMatch: true });\n\treturn score ? createMatches(score) : null;\n}\n\nexport function anyScore(pattern: string, lowPattern: string, patternPos: number, word: string, lowWord: string, wordPos: number): FuzzyScore {\n\tconst max = Math.min(13, pattern.length);\n\tfor (; patternPos < max; patternPos++) {\n\t\tconst result = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, { firstMatchCanBeWeak: true, boostFullMatch: true });\n\t\tif (result) {\n\t\t\treturn result;\n\t\t}\n\t}\n\treturn [0, wordPos];\n}\n\n//#region --- fuzzyScore ---\n\nexport function createMatches(score: undefined | FuzzyScore): IMatch[] {\n\tif (typeof score === 'undefined') {\n\t\treturn [];\n\t}\n\tconst res: IMatch[] = [];\n\tconst wordPos = score[1];\n\tfor (let i = score.length - 1; i > 1; i--) {\n\t\tconst pos = score[i] + wordPos;\n\t\tconst last = res[res.length - 1];\n\t\tif (last && last.end === pos) {\n\t\t\tlast.end = pos + 1;\n\t\t} else {\n\t\t\tres.push({ start: pos, end: pos + 1 });\n\t\t}\n\t}\n\treturn res;\n}\n\nconst _maxLen = 128;\n\nfunction initTable() {\n\tconst table: number[][] = [];\n\tconst row: number[] = [];\n\tfor (let i = 0; i <= _maxLen; i++) {\n\t\trow[i] = 0;\n\t}\n\tfor (let i = 0; i <= _maxLen; i++) {\n\t\ttable.push(row.slice(0));\n\t}\n\treturn table;\n}\n\nfunction initArr(maxLen: number) {\n\tconst row: number[] = [];\n\tfor (let i = 0; i <= maxLen; i++) {\n\t\trow[i] = 0;\n\t}\n\treturn row;\n}\n\nconst _minWordMatchPos = initArr(2 * _maxLen); // min word position for a certain pattern position\nconst _maxWordMatchPos = initArr(2 * _maxLen); // max word position for a certain pattern position\nconst _diag = initTable(); // the length of a contiguous diagonal match\nconst _table = initTable();\nconst _arrows = <Arrow[][]>initTable();\nconst _debug = false;\n\nfunction printTable(table: number[][], pattern: string, patternLen: number, word: string, wordLen: number): string {\n\tfunction pad(s: string, n: number, pad = ' ') {\n\t\twhile (s.length < n) {\n\t\t\ts = pad + s;\n\t\t}\n\t\treturn s;\n\t}\n\tlet ret = ` |   |${word.split('').map(c => pad(c, 3)).join('|')}\\n`;\n\n\tfor (let i = 0; i <= patternLen; i++) {\n\t\tif (i === 0) {\n\t\t\tret += ' |';\n\t\t} else {\n\t\t\tret += `${pattern[i - 1]}|`;\n\t\t}\n\t\tret += table[i].slice(0, wordLen + 1).map(n => pad(n.toString(), 3)).join('|') + '\\n';\n\t}\n\treturn ret;\n}\n\nfunction printTables(pattern: string, patternStart: number, word: string, wordStart: number): void {\n\tpattern = pattern.substr(patternStart);\n\tword = word.substr(wordStart);\n\tconsole.log(printTable(_table, pattern, pattern.length, word, word.length));\n\tconsole.log(printTable(_arrows, pattern, pattern.length, word, word.length));\n\tconsole.log(printTable(_diag, pattern, pattern.length, word, word.length));\n}\n\nfunction isSeparatorAtPos(value: string, index: number): boolean {\n\tif (index < 0 || index >= value.length) {\n\t\treturn false;\n\t}\n\tconst code = value.codePointAt(index);\n\tswitch (code) {\n\t\tcase CharCode.Underline:\n\t\tcase CharCode.Dash:\n\t\tcase CharCode.Period:\n\t\tcase CharCode.Space:\n\t\tcase CharCode.Slash:\n\t\tcase CharCode.Backslash:\n\t\tcase CharCode.SingleQuote:\n\t\tcase CharCode.DoubleQuote:\n\t\tcase CharCode.Colon:\n\t\tcase CharCode.DollarSign:\n\t\tcase CharCode.LessThan:\n\t\tcase CharCode.GreaterThan:\n\t\tcase CharCode.OpenParen:\n\t\tcase CharCode.CloseParen:\n\t\tcase CharCode.OpenSquareBracket:\n\t\tcase CharCode.CloseSquareBracket:\n\t\tcase CharCode.OpenCurlyBrace:\n\t\tcase CharCode.CloseCurlyBrace:\n\t\t\treturn true;\n\t\tcase undefined:\n\t\t\treturn false;\n\t\tdefault:\n\t\t\tif (strings.isEmojiImprecise(code)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t}\n}\n\nfunction isWhitespaceAtPos(value: string, index: number): boolean {\n\tif (index < 0 || index >= value.length) {\n\t\treturn false;\n\t}\n\tconst code = value.charCodeAt(index);\n\tswitch (code) {\n\t\tcase CharCode.Space:\n\t\tcase CharCode.Tab:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\nfunction isUpperCaseAtPos(pos: number, word: string, wordLow: string): boolean {\n\treturn word[pos] !== wordLow[pos];\n}\n\nexport function isPatternInWord(patternLow: string, patternPos: number, patternLen: number, wordLow: string, wordPos: number, wordLen: number, fillMinWordPosArr = false): boolean {\n\twhile (patternPos < patternLen && wordPos < wordLen) {\n\t\tif (patternLow[patternPos] === wordLow[wordPos]) {\n\t\t\tif (fillMinWordPosArr) {\n\t\t\t\t// Remember the min word position for each pattern position\n\t\t\t\t_minWordMatchPos[patternPos] = wordPos;\n\t\t\t}\n\t\t\tpatternPos += 1;\n\t\t}\n\t\twordPos += 1;\n\t}\n\treturn patternPos === patternLen; // pattern must be exhausted\n}\n\nconst enum Arrow { Diag = 1, Left = 2, LeftLeft = 3 }\n\n/**\n * An array representing a fuzzy match.\n *\n * 0. the score\n * 1. the offset at which matching started\n * 2. `<match_pos_N>`\n * 3. `<match_pos_1>`\n * 4. `<match_pos_0>` etc\n */\nexport type FuzzyScore = [score: number, wordStart: number, ...matches: number[]];\n\nexport namespace FuzzyScore {\n\t/**\n\t * No matches and value `-100`\n\t */\n\texport const Default: FuzzyScore = ([-100, 0]);\n\n\texport function isDefault(score?: FuzzyScore): score is [-100, 0] {\n\t\treturn !score || (score.length === 2 && score[0] === -100 && score[1] === 0);\n\t}\n}\n\nexport abstract class FuzzyScoreOptions {\n\n\tstatic default = { boostFullMatch: true, firstMatchCanBeWeak: false };\n\n\tconstructor(\n\t\treadonly firstMatchCanBeWeak: boolean,\n\t\treadonly boostFullMatch: boolean,\n\t) { }\n}\n\nexport interface FuzzyScorer {\n\t(pattern: string, lowPattern: string, patternPos: number, word: string, lowWord: string, wordPos: number, options?: FuzzyScoreOptions): FuzzyScore | undefined;\n}\n\nexport function fuzzyScore(pattern: string, patternLow: string, patternStart: number, word: string, wordLow: string, wordStart: number, options: FuzzyScoreOptions = FuzzyScoreOptions.default): FuzzyScore | undefined {\n\n\tconst patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;\n\tconst wordLen = word.length > _maxLen ? _maxLen : word.length;\n\n\tif (patternStart >= patternLen || wordStart >= wordLen || (patternLen - patternStart) > (wordLen - wordStart)) {\n\t\treturn undefined;\n\t}\n\n\t// Run a simple check if the characters of pattern occur\n\t// (in order) at all in word. If that isn't the case we\n\t// stop because no match will be possible\n\tif (!isPatternInWord(patternLow, patternStart, patternLen, wordLow, wordStart, wordLen, true)) {\n\t\treturn undefined;\n\t}\n\n\t// Find the max matching word position for each pattern position\n\t// NOTE: the min matching word position was filled in above, in the `isPatternInWord` call\n\t_fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow);\n\n\tlet row: number = 1;\n\tlet column: number = 1;\n\tlet patternPos = patternStart;\n\tlet wordPos = wordStart;\n\n\tconst hasStrongFirstMatch = [false];\n\n\t// There will be a match, fill in tables\n\tfor (row = 1, patternPos = patternStart; patternPos < patternLen; row++, patternPos++) {\n\n\t\t// Reduce search space to possible matching word positions and to possible access from next row\n\t\tconst minWordMatchPos = _minWordMatchPos[patternPos];\n\t\tconst maxWordMatchPos = _maxWordMatchPos[patternPos];\n\t\tconst nextMaxWordMatchPos = (patternPos + 1 < patternLen ? _maxWordMatchPos[patternPos + 1] : wordLen);\n\n\t\tfor (column = minWordMatchPos - wordStart + 1, wordPos = minWordMatchPos; wordPos < nextMaxWordMatchPos; column++, wordPos++) {\n\n\t\t\tlet score = Number.MIN_SAFE_INTEGER;\n\t\t\tlet canComeDiag = false;\n\n\t\t\tif (wordPos <= maxWordMatchPos) {\n\t\t\t\tscore = _doScore(\n\t\t\t\t\tpattern, patternLow, patternPos, patternStart,\n\t\t\t\t\tword, wordLow, wordPos, wordLen, wordStart,\n\t\t\t\t\t_diag[row - 1][column - 1] === 0,\n\t\t\t\t\thasStrongFirstMatch\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tlet diagScore = 0;\n\t\t\tif (score !== Number.MAX_SAFE_INTEGER) {\n\t\t\t\tcanComeDiag = true;\n\t\t\t\tdiagScore = score + _table[row - 1][column - 1];\n\t\t\t}\n\n\t\t\tconst canComeLeft = wordPos > minWordMatchPos;\n\t\t\tconst leftScore = canComeLeft ? _table[row][column - 1] + (_diag[row][column - 1] > 0 ? -5 : 0) : 0; // penalty for a gap start\n\n\t\t\tconst canComeLeftLeft = wordPos > minWordMatchPos + 1 && _diag[row][column - 1] > 0;\n\t\t\tconst leftLeftScore = canComeLeftLeft ? _table[row][column - 2] + (_diag[row][column - 2] > 0 ? -5 : 0) : 0; // penalty for a gap start\n\n\t\t\tif (canComeLeftLeft && (!canComeLeft || leftLeftScore >= leftScore) && (!canComeDiag || leftLeftScore >= diagScore)) {\n\t\t\t\t// always prefer choosing left left to jump over a diagonal because that means a match is earlier in the word\n\t\t\t\t_table[row][column] = leftLeftScore;\n\t\t\t\t_arrows[row][column] = Arrow.LeftLeft;\n\t\t\t\t_diag[row][column] = 0;\n\t\t\t} else if (canComeLeft && (!canComeDiag || leftScore >= diagScore)) {\n\t\t\t\t// always prefer choosing left since that means a match is earlier in the word\n\t\t\t\t_table[row][column] = leftScore;\n\t\t\t\t_arrows[row][column] = Arrow.Left;\n\t\t\t\t_diag[row][column] = 0;\n\t\t\t} else if (canComeDiag) {\n\t\t\t\t_table[row][column] = diagScore;\n\t\t\t\t_arrows[row][column] = Arrow.Diag;\n\t\t\t\t_diag[row][column] = _diag[row - 1][column - 1] + 1;\n\t\t\t} else {\n\t\t\t\tthrow new Error(`not possible`);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (_debug) {\n\t\tprintTables(pattern, patternStart, word, wordStart);\n\t}\n\n\tif (!hasStrongFirstMatch[0] && !options.firstMatchCanBeWeak) {\n\t\treturn undefined;\n\t}\n\n\trow--;\n\tcolumn--;\n\n\tconst result: FuzzyScore = [_table[row][column], wordStart];\n\n\tlet backwardsDiagLength = 0;\n\tlet maxMatchColumn = 0;\n\n\twhile (row >= 1) {\n\t\t// Find the column where we go diagonally up\n\t\tlet diagColumn = column;\n\t\tdo {\n\t\t\tconst arrow = _arrows[row][diagColumn];\n\t\t\tif (arrow === Arrow.LeftLeft) {\n\t\t\t\tdiagColumn = diagColumn - 2;\n\t\t\t} else if (arrow === Arrow.Left) {\n\t\t\t\tdiagColumn = diagColumn - 1;\n\t\t\t} else {\n\t\t\t\t// found the diagonal\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (diagColumn >= 1);\n\n\t\t// Overturn the \"forwards\" decision if keeping the \"backwards\" diagonal would give a better match\n\t\tif (\n\t\t\tbackwardsDiagLength > 1 // only if we would have a contiguous match of 3 characters\n\t\t\t&& patternLow[patternStart + row - 1] === wordLow[wordStart + column - 1] // only if we can do a contiguous match diagonally\n\t\t\t&& !isUpperCaseAtPos(diagColumn + wordStart - 1, word, wordLow) // only if the forwards chose diagonal is not an uppercase\n\t\t\t&& backwardsDiagLength + 1 > _diag[row][diagColumn] // only if our contiguous match would be longer than the \"forwards\" contiguous match\n\t\t) {\n\t\t\tdiagColumn = column;\n\t\t}\n\n\t\tif (diagColumn === column) {\n\t\t\t// this is a contiguous match\n\t\t\tbackwardsDiagLength++;\n\t\t} else {\n\t\t\tbackwardsDiagLength = 1;\n\t\t}\n\n\t\tif (!maxMatchColumn) {\n\t\t\t// remember the last matched column\n\t\t\tmaxMatchColumn = diagColumn;\n\t\t}\n\n\t\trow--;\n\t\tcolumn = diagColumn - 1;\n\t\tresult.push(column);\n\t}\n\n\tif (wordLen - wordStart === patternLen && options.boostFullMatch) {\n\t\t// the word matches the pattern with all characters!\n\t\t// giving the score a total match boost (to come up ahead other words)\n\t\tresult[0] += 2;\n\t}\n\n\t// Add 1 penalty for each skipped character in the word\n\tconst skippedCharsCount = maxMatchColumn - patternLen;\n\tresult[0] -= skippedCharsCount;\n\n\treturn result;\n}\n\nfunction _fillInMaxWordMatchPos(patternLen: number, wordLen: number, patternStart: number, wordStart: number, patternLow: string, wordLow: string) {\n\tlet patternPos = patternLen - 1;\n\tlet wordPos = wordLen - 1;\n\twhile (patternPos >= patternStart && wordPos >= wordStart) {\n\t\tif (patternLow[patternPos] === wordLow[wordPos]) {\n\t\t\t_maxWordMatchPos[patternPos] = wordPos;\n\t\t\tpatternPos--;\n\t\t}\n\t\twordPos--;\n\t}\n}\n\nfunction _doScore(\n\tpattern: string, patternLow: string, patternPos: number, patternStart: number,\n\tword: string, wordLow: string, wordPos: number, wordLen: number, wordStart: number,\n\tnewMatchStart: boolean,\n\toutFirstMatchStrong: boolean[],\n): number {\n\tif (patternLow[patternPos] !== wordLow[wordPos]) {\n\t\treturn Number.MIN_SAFE_INTEGER;\n\t}\n\n\tlet score = 1;\n\tlet isGapLocation = false;\n\tif (wordPos === (patternPos - patternStart)) {\n\t\t// common prefix: `foobar <-> foobaz`\n\t\t//                            ^^^^^\n\t\tscore = pattern[patternPos] === word[wordPos] ? 7 : 5;\n\n\t} else if (isUpperCaseAtPos(wordPos, word, wordLow) && (wordPos === 0 || !isUpperCaseAtPos(wordPos - 1, word, wordLow))) {\n\t\t// hitting upper-case: `foo <-> forOthers`\n\t\t//                              ^^ ^\n\t\tscore = pattern[patternPos] === word[wordPos] ? 7 : 5;\n\t\tisGapLocation = true;\n\n\t} else if (isSeparatorAtPos(wordLow, wordPos) && (wordPos === 0 || !isSeparatorAtPos(wordLow, wordPos - 1))) {\n\t\t// hitting a separator: `. <-> foo.bar`\n\t\t//                                ^\n\t\tscore = 5;\n\n\t} else if (isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1)) {\n\t\t// post separator: `foo <-> bar_foo`\n\t\t//                              ^^^\n\t\tscore = 5;\n\t\tisGapLocation = true;\n\t}\n\n\tif (score > 1 && patternPos === patternStart) {\n\t\toutFirstMatchStrong[0] = true;\n\t}\n\n\tif (!isGapLocation) {\n\t\tisGapLocation = isUpperCaseAtPos(wordPos, word, wordLow) || isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1);\n\t}\n\n\t//\n\tif (patternPos === patternStart) { // first character in pattern\n\t\tif (wordPos > wordStart) {\n\t\t\t// the first pattern character would match a word character that is not at the word start\n\t\t\t// so introduce a penalty to account for the gap preceding this match\n\t\t\tscore -= isGapLocation ? 3 : 5;\n\t\t}\n\t} else {\n\t\tif (newMatchStart) {\n\t\t\t// this would be the beginning of a new match (i.e. there would be a gap before this location)\n\t\t\tscore += isGapLocation ? 2 : 0;\n\t\t} else {\n\t\t\t// this is part of a contiguous match, so give it a slight bonus, but do so only if it would not be a preferred gap location\n\t\t\tscore += isGapLocation ? 0 : 1;\n\t\t}\n\t}\n\n\tif (wordPos + 1 === wordLen) {\n\t\t// we always penalize gaps, but this gives unfair advantages to a match that would match the last character in the word\n\t\t// so pretend there is a gap after the last character in the word to normalize things\n\t\tscore -= isGapLocation ? 3 : 5;\n\t}\n\n\treturn score;\n}\n\n//#endregion\n\n\n//#region --- graceful ---\n\nexport function fuzzyScoreGracefulAggressive(pattern: string, lowPattern: string, patternPos: number, word: string, lowWord: string, wordPos: number, options?: FuzzyScoreOptions): FuzzyScore | undefined {\n\treturn fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, true, options);\n}\n\nexport function fuzzyScoreGraceful(pattern: string, lowPattern: string, patternPos: number, word: string, lowWord: string, wordPos: number, options?: FuzzyScoreOptions): FuzzyScore | undefined {\n\treturn fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, false, options);\n}\n\nfunction fuzzyScoreWithPermutations(pattern: string, lowPattern: string, patternPos: number, word: string, lowWord: string, wordPos: number, aggressive: boolean, options?: FuzzyScoreOptions): FuzzyScore | undefined {\n\tlet top = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, options);\n\n\tif (top && !aggressive) {\n\t\t// when using the original pattern yield a result we`\n\t\t// return it unless we are aggressive and try to find\n\t\t// a better alignment, e.g. `cno` -> `^co^ns^ole` or `^c^o^nsole`.\n\t\treturn top;\n\t}\n\n\tif (pattern.length >= 3) {\n\t\t// When the pattern is long enough then try a few (max 7)\n\t\t// permutations of the pattern to find a better match. The\n\t\t// permutations only swap neighbouring characters, e.g\n\t\t// `cnoso` becomes `conso`, `cnsoo`, `cnoos`.\n\t\tconst tries = Math.min(7, pattern.length - 1);\n\t\tfor (let movingPatternPos = patternPos + 1; movingPatternPos < tries; movingPatternPos++) {\n\t\t\tconst newPattern = nextTypoPermutation(pattern, movingPatternPos);\n\t\t\tif (newPattern) {\n\t\t\t\tconst candidate = fuzzyScore(newPattern, newPattern.toLowerCase(), patternPos, word, lowWord, wordPos, options);\n\t\t\t\tif (candidate) {\n\t\t\t\t\tcandidate[0] -= 3; // permutation penalty\n\t\t\t\t\tif (!top || candidate[0] > top[0]) {\n\t\t\t\t\t\ttop = candidate;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn top;\n}\n\nfunction nextTypoPermutation(pattern: string, patternPos: number): string | undefined {\n\n\tif (patternPos + 1 >= pattern.length) {\n\t\treturn undefined;\n\t}\n\n\tconst swap1 = pattern[patternPos];\n\tconst swap2 = pattern[patternPos + 1];\n\n\tif (swap1 === swap2) {\n\t\treturn undefined;\n\t}\n\n\treturn pattern.slice(0, patternPos)\n\t\t+ swap2\n\t\t+ swap1\n\t\t+ pattern.slice(patternPos + 2);\n}\n\n//#endregion\n"],
  "mappings": "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",
  "names": ["pad", "Arrow", "FuzzyScore"]
}
