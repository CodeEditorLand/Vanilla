{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/lifecycle.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { compareBy, numberComparator } from './arrays.js';\nimport { groupBy } from './collections.js';\nimport { SetMap } from './map.js';\nimport { createSingleCallFunction } from './functional.js';\nimport { Iterable } from './iterator.js';\n\n// #region Disposable Tracking\n\n/**\n * Enables logging of potentially leaked disposables.\n *\n * A disposable is considered leaked if it is not disposed or not registered as the child of\n * another disposable. This tracking is very simple an only works for classes that either\n * extend Disposable or use a DisposableStore. This means there are a lot of false positives.\n */\nconst TRACK_DISPOSABLES = false;\nlet disposableTracker: IDisposableTracker | null = null;\n\nexport interface IDisposableTracker {\n\t/**\n\t * Is called on construction of a disposable.\n\t*/\n\ttrackDisposable(disposable: IDisposable): void;\n\n\t/**\n\t * Is called when a disposable is registered as child of another disposable (e.g. {@link DisposableStore}).\n\t * If parent is `null`, the disposable is removed from its former parent.\n\t*/\n\tsetParent(child: IDisposable, parent: IDisposable | null): void;\n\n\t/**\n\t * Is called after a disposable is disposed.\n\t*/\n\tmarkAsDisposed(disposable: IDisposable): void;\n\n\t/**\n\t * Indicates that the given object is a singleton which does not need to be disposed.\n\t*/\n\tmarkAsSingleton(disposable: IDisposable): void;\n}\n\nexport interface DisposableInfo {\n\tvalue: IDisposable;\n\tsource: string | null;\n\tparent: IDisposable | null;\n\tisSingleton: boolean;\n\tidx: number;\n}\n\nexport class DisposableTracker implements IDisposableTracker {\n\tprivate static idx = 0;\n\n\tprivate readonly livingDisposables = new Map<IDisposable, DisposableInfo>();\n\n\tprivate getDisposableData(d: IDisposable): DisposableInfo {\n\t\tlet val = this.livingDisposables.get(d);\n\t\tif (!val) {\n\t\t\tval = { parent: null, source: null, isSingleton: false, value: d, idx: DisposableTracker.idx++ };\n\t\t\tthis.livingDisposables.set(d, val);\n\t\t}\n\t\treturn val;\n\t}\n\n\ttrackDisposable(d: IDisposable): void {\n\t\tconst data = this.getDisposableData(d);\n\t\tif (!data.source) {\n\t\t\tdata.source =\n\t\t\t\tnew Error().stack!;\n\t\t}\n\t}\n\n\tsetParent(child: IDisposable, parent: IDisposable | null): void {\n\t\tconst data = this.getDisposableData(child);\n\t\tdata.parent = parent;\n\t}\n\n\tmarkAsDisposed(x: IDisposable): void {\n\t\tthis.livingDisposables.delete(x);\n\t}\n\n\tmarkAsSingleton(disposable: IDisposable): void {\n\t\tthis.getDisposableData(disposable).isSingleton = true;\n\t}\n\n\tprivate getRootParent(data: DisposableInfo, cache: Map<DisposableInfo, DisposableInfo>): DisposableInfo {\n\t\tconst cacheValue = cache.get(data);\n\t\tif (cacheValue) {\n\t\t\treturn cacheValue;\n\t\t}\n\n\t\tconst result = data.parent ? this.getRootParent(this.getDisposableData(data.parent), cache) : data;\n\t\tcache.set(data, result);\n\t\treturn result;\n\t}\n\n\tgetTrackedDisposables(): IDisposable[] {\n\t\tconst rootParentCache = new Map<DisposableInfo, DisposableInfo>();\n\n\t\tconst leaking = [...this.livingDisposables.entries()]\n\t\t\t.filter(([, v]) => v.source !== null && !this.getRootParent(v, rootParentCache).isSingleton)\n\t\t\t.flatMap(([k]) => k);\n\n\t\treturn leaking;\n\t}\n\n\tcomputeLeakingDisposables(maxReported = 10, preComputedLeaks?: DisposableInfo[]): { leaks: DisposableInfo[]; details: string } | undefined {\n\t\tlet uncoveredLeakingObjs: DisposableInfo[] | undefined;\n\t\tif (preComputedLeaks) {\n\t\t\tuncoveredLeakingObjs = preComputedLeaks;\n\t\t} else {\n\t\t\tconst rootParentCache = new Map<DisposableInfo, DisposableInfo>();\n\n\t\t\tconst leakingObjects = [...this.livingDisposables.values()]\n\t\t\t\t.filter((info) => info.source !== null && !this.getRootParent(info, rootParentCache).isSingleton);\n\n\t\t\tif (leakingObjects.length === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst leakingObjsSet = new Set(leakingObjects.map(o => o.value));\n\n\t\t\t// Remove all objects that are a child of other leaking objects. Assumes there are no cycles.\n\t\t\tuncoveredLeakingObjs = leakingObjects.filter(l => {\n\t\t\t\treturn !(l.parent && leakingObjsSet.has(l.parent));\n\t\t\t});\n\n\t\t\tif (uncoveredLeakingObjs.length === 0) {\n\t\t\t\tthrow new Error('There are cyclic diposable chains!');\n\t\t\t}\n\t\t}\n\n\t\tif (!uncoveredLeakingObjs) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tfunction getStackTracePath(leaking: DisposableInfo): string[] {\n\t\t\tfunction removePrefix(array: string[], linesToRemove: (string | RegExp)[]) {\n\t\t\t\twhile (array.length > 0 && linesToRemove.some(regexp => typeof regexp === 'string' ? regexp === array[0] : array[0].match(regexp))) {\n\t\t\t\t\tarray.shift();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst lines = leaking.source!.split('\\n').map(p => p.trim().replace('at ', '')).filter(l => l !== '');\n\t\t\tremovePrefix(lines, ['Error', /^trackDisposable \\(.*\\)$/, /^DisposableTracker.trackDisposable \\(.*\\)$/]);\n\t\t\treturn lines.reverse();\n\t\t}\n\n\t\tconst stackTraceStarts = new SetMap<string, DisposableInfo>();\n\t\tfor (const leaking of uncoveredLeakingObjs) {\n\t\t\tconst stackTracePath = getStackTracePath(leaking);\n\t\t\tfor (let i = 0; i <= stackTracePath.length; i++) {\n\t\t\t\tstackTraceStarts.add(stackTracePath.slice(0, i).join('\\n'), leaking);\n\t\t\t}\n\t\t}\n\n\t\t// Put earlier leaks first\n\t\tuncoveredLeakingObjs.sort(compareBy(l => l.idx, numberComparator));\n\n\t\tlet message = '';\n\n\t\tlet i = 0;\n\t\tfor (const leaking of uncoveredLeakingObjs.slice(0, maxReported)) {\n\t\t\ti++;\n\t\t\tconst stackTracePath = getStackTracePath(leaking);\n\t\t\tconst stackTraceFormattedLines = [];\n\n\t\t\tfor (let i = 0; i < stackTracePath.length; i++) {\n\t\t\t\tlet line = stackTracePath[i];\n\t\t\t\tconst starts = stackTraceStarts.get(stackTracePath.slice(0, i + 1).join('\\n'));\n\t\t\t\tline = `(shared with ${starts.size}/${uncoveredLeakingObjs.length} leaks) at ${line}`;\n\n\t\t\t\tconst prevStarts = stackTraceStarts.get(stackTracePath.slice(0, i).join('\\n'));\n\t\t\t\tconst continuations = groupBy([...prevStarts].map(d => getStackTracePath(d)[i]), v => v);\n\t\t\t\tdelete continuations[stackTracePath[i]];\n\t\t\t\tfor (const [cont, set] of Object.entries(continuations)) {\n\t\t\t\t\tstackTraceFormattedLines.unshift(`    - stacktraces of ${set.length} other leaks continue with ${cont}`);\n\t\t\t\t}\n\n\t\t\t\tstackTraceFormattedLines.unshift(line);\n\t\t\t}\n\n\t\t\tmessage += `\\n\\n\\n==================== Leaking disposable ${i}/${uncoveredLeakingObjs.length}: ${leaking.value.constructor.name} ====================\\n${stackTraceFormattedLines.join('\\n')}\\n============================================================\\n\\n`;\n\t\t}\n\n\t\tif (uncoveredLeakingObjs.length > maxReported) {\n\t\t\tmessage += `\\n\\n\\n... and ${uncoveredLeakingObjs.length - maxReported} more leaking disposables\\n\\n`;\n\t\t}\n\n\t\treturn { leaks: uncoveredLeakingObjs, details: message };\n\t}\n}\n\nexport function setDisposableTracker(tracker: IDisposableTracker | null): void {\n\tdisposableTracker = tracker;\n}\n\nif (TRACK_DISPOSABLES) {\n\tconst __is_disposable_tracked__ = '__is_disposable_tracked__';\n\tsetDisposableTracker(new class implements IDisposableTracker {\n\t\ttrackDisposable(x: IDisposable): void {\n\t\t\tconst stack = new Error('Potentially leaked disposable').stack!;\n\t\t\tsetTimeout(() => {\n\t\t\t\tif (!(x as any)[__is_disposable_tracked__]) {\n\t\t\t\t\tconsole.log(stack);\n\t\t\t\t}\n\t\t\t}, 3000);\n\t\t}\n\n\t\tsetParent(child: IDisposable, parent: IDisposable | null): void {\n\t\t\tif (child && child !== Disposable.None) {\n\t\t\t\ttry {\n\t\t\t\t\t(child as any)[__is_disposable_tracked__] = true;\n\t\t\t\t} catch {\n\t\t\t\t\t// noop\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmarkAsDisposed(disposable: IDisposable): void {\n\t\t\tif (disposable && disposable !== Disposable.None) {\n\t\t\t\ttry {\n\t\t\t\t\t(disposable as any)[__is_disposable_tracked__] = true;\n\t\t\t\t} catch {\n\t\t\t\t\t// noop\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmarkAsSingleton(disposable: IDisposable): void { }\n\t});\n}\n\nexport function trackDisposable<T extends IDisposable>(x: T): T {\n\tdisposableTracker?.trackDisposable(x);\n\treturn x;\n}\n\nexport function markAsDisposed(disposable: IDisposable): void {\n\tdisposableTracker?.markAsDisposed(disposable);\n}\n\nfunction setParentOfDisposable(child: IDisposable, parent: IDisposable | null): void {\n\tdisposableTracker?.setParent(child, parent);\n}\n\nfunction setParentOfDisposables(children: IDisposable[], parent: IDisposable | null): void {\n\tif (!disposableTracker) {\n\t\treturn;\n\t}\n\tfor (const child of children) {\n\t\tdisposableTracker.setParent(child, parent);\n\t}\n}\n\n/**\n * Indicates that the given object is a singleton which does not need to be disposed.\n*/\nexport function markAsSingleton<T extends IDisposable>(singleton: T): T {\n\tdisposableTracker?.markAsSingleton(singleton);\n\treturn singleton;\n}\n\n// #endregion\n\n/**\n * An object that performs a cleanup operation when `.dispose()` is called.\n *\n * Some examples of how disposables are used:\n *\n * - An event listener that removes itself when `.dispose()` is called.\n * - A resource such as a file system watcher that cleans up the resource when `.dispose()` is called.\n * - The return value from registering a provider. When `.dispose()` is called, the provider is unregistered.\n */\nexport interface IDisposable {\n\tdispose(): void;\n}\n\n/**\n * Check if `thing` is {@link IDisposable disposable}.\n */\nexport function isDisposable<E extends any>(thing: E): thing is E & IDisposable {\n\treturn typeof thing === 'object' && thing !== null && typeof (<IDisposable><any>thing).dispose === 'function' && (<IDisposable><any>thing).dispose.length === 0;\n}\n\n/**\n * Disposes of the value(s) passed in.\n */\nexport function dispose<T extends IDisposable>(disposable: T): T;\nexport function dispose<T extends IDisposable>(disposable: T | undefined): T | undefined;\nexport function dispose<T extends IDisposable, A extends Iterable<T> = Iterable<T>>(disposables: A): A;\nexport function dispose<T extends IDisposable>(disposables: Array<T>): Array<T>;\nexport function dispose<T extends IDisposable>(disposables: ReadonlyArray<T>): ReadonlyArray<T>;\nexport function dispose<T extends IDisposable>(arg: T | Iterable<T> | undefined): any {\n\tif (Iterable.is(arg)) {\n\t\tconst errors: any[] = [];\n\n\t\tfor (const d of arg) {\n\t\t\tif (d) {\n\t\t\t\ttry {\n\t\t\t\t\td.dispose();\n\t\t\t\t} catch (e) {\n\t\t\t\t\terrors.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (errors.length === 1) {\n\t\t\tthrow errors[0];\n\t\t} else if (errors.length > 1) {\n\t\t\tthrow new AggregateError(errors, 'Encountered errors while disposing of store');\n\t\t}\n\n\t\treturn Array.isArray(arg) ? [] : arg;\n\t} else if (arg) {\n\t\targ.dispose();\n\t\treturn arg;\n\t}\n}\n\nexport function disposeIfDisposable<T extends IDisposable | object>(disposables: Array<T>): Array<T> {\n\tfor (const d of disposables) {\n\t\tif (isDisposable(d)) {\n\t\t\td.dispose();\n\t\t}\n\t}\n\treturn [];\n}\n\n/**\n * Combine multiple disposable values into a single {@link IDisposable}.\n */\nexport function combinedDisposable(...disposables: IDisposable[]): IDisposable {\n\tconst parent = toDisposable(() => dispose(disposables));\n\tsetParentOfDisposables(disposables, parent);\n\treturn parent;\n}\n\n/**\n * Turn a function that implements dispose into an {@link IDisposable}.\n *\n * @param fn Clean up function, guaranteed to be called only **once**.\n */\nexport function toDisposable(fn: () => void): IDisposable {\n\tconst self = trackDisposable({\n\t\tdispose: createSingleCallFunction(() => {\n\t\t\tmarkAsDisposed(self);\n\t\t\tfn();\n\t\t})\n\t});\n\treturn self;\n}\n\n/**\n * Manages a collection of disposable values.\n *\n * This is the preferred way to manage multiple disposables. A `DisposableStore` is safer to work with than an\n * `IDisposable[]` as it considers edge cases, such as registering the same value multiple times or adding an item to a\n * store that has already been disposed of.\n */\nexport class DisposableStore implements IDisposable {\n\n\tstatic DISABLE_DISPOSED_WARNING = false;\n\n\tprivate readonly _toDispose = new Set<IDisposable>();\n\tprivate _isDisposed = false;\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t}\n\n\t/**\n\t * Dispose of all registered disposables and mark this object as disposed.\n\t *\n\t * Any future disposables added to this object will be disposed of on `add`.\n\t */\n\tpublic dispose(): void {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\n\t\tmarkAsDisposed(this);\n\t\tthis._isDisposed = true;\n\t\tthis.clear();\n\t}\n\n\t/**\n\t * @return `true` if this object has been disposed of.\n\t */\n\tpublic get isDisposed(): boolean {\n\t\treturn this._isDisposed;\n\t}\n\n\t/**\n\t * Dispose of all registered disposables but do not mark this object as disposed.\n\t */\n\tpublic clear(): void {\n\t\tif (this._toDispose.size === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tdispose(this._toDispose);\n\t\t} finally {\n\t\t\tthis._toDispose.clear();\n\t\t}\n\t}\n\n\t/**\n\t * Add a new {@link IDisposable disposable} to the collection.\n\t */\n\tpublic add<T extends IDisposable>(o: T): T {\n\t\tif (!o) {\n\t\t\treturn o;\n\t\t}\n\t\tif ((o as unknown as DisposableStore) === this) {\n\t\t\tthrow new Error('Cannot register a disposable on itself!');\n\t\t}\n\n\t\tsetParentOfDisposable(o, this);\n\t\tif (this._isDisposed) {\n\t\t\tif (!DisposableStore.DISABLE_DISPOSED_WARNING) {\n\t\t\t\tconsole.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._toDispose.add(o);\n\t\t}\n\n\t\treturn o;\n\t}\n\n\t/**\n\t * Deletes a disposable from store and disposes of it. This will not throw or warn and proceed to dispose the\n\t * disposable even when the disposable is not part in the store.\n\t */\n\tpublic delete<T extends IDisposable>(o: T): void {\n\t\tif (!o) {\n\t\t\treturn;\n\t\t}\n\t\tif ((o as unknown as DisposableStore) === this) {\n\t\t\tthrow new Error('Cannot dispose a disposable on itself!');\n\t\t}\n\t\tthis._toDispose.delete(o);\n\t\to.dispose();\n\t}\n\n\t/**\n\t * Deletes the value from the store, but does not dispose it.\n\t */\n\tpublic deleteAndLeak<T extends IDisposable>(o: T): void {\n\t\tif (!o) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._toDispose.has(o)) {\n\t\t\tthis._toDispose.delete(o);\n\t\t\tsetParentOfDisposable(o, null);\n\t\t}\n\t}\n}\n\n/**\n * Abstract base class for a {@link IDisposable disposable} object.\n *\n * Subclasses can {@linkcode _register} disposables that will be automatically cleaned up when this object is disposed of.\n */\nexport abstract class Disposable implements IDisposable {\n\n\t/**\n\t * A disposable that does nothing when it is disposed of.\n\t *\n\t * TODO: This should not be a static property.\n\t */\n\tstatic readonly None = Object.freeze<IDisposable>({ dispose() { } });\n\n\tprotected readonly _store = new DisposableStore();\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t\tsetParentOfDisposable(this._store, this);\n\t}\n\n\tpublic dispose(): void {\n\t\tmarkAsDisposed(this);\n\n\t\tthis._store.dispose();\n\t}\n\n\t/**\n\t * Adds `o` to the collection of disposables managed by this object.\n\t */\n\tprotected _register<T extends IDisposable>(o: T): T {\n\t\tif ((o as unknown as Disposable) === this) {\n\t\t\tthrow new Error('Cannot register a disposable on itself!');\n\t\t}\n\t\treturn this._store.add(o);\n\t}\n}\n\n/**\n * Manages the lifecycle of a disposable value that may be changed.\n *\n * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can\n * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.\n */\nexport class MutableDisposable<T extends IDisposable> implements IDisposable {\n\tprivate _value?: T;\n\tprivate _isDisposed = false;\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t}\n\n\tget value(): T | undefined {\n\t\treturn this._isDisposed ? undefined : this._value;\n\t}\n\n\tset value(value: T | undefined) {\n\t\tif (this._isDisposed || value === this._value) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._value?.dispose();\n\t\tif (value) {\n\t\t\tsetParentOfDisposable(value, this);\n\t\t}\n\t\tthis._value = value;\n\t}\n\n\t/**\n\t * Resets the stored value and disposed of the previously stored value.\n\t */\n\tclear(): void {\n\t\tthis.value = undefined;\n\t}\n\n\tdispose(): void {\n\t\tthis._isDisposed = true;\n\t\tmarkAsDisposed(this);\n\t\tthis._value?.dispose();\n\t\tthis._value = undefined;\n\t}\n\n\t/**\n\t * Clears the value, but does not dispose it.\n\t * The old value is returned.\n\t*/\n\tclearAndLeak(): T | undefined {\n\t\tconst oldValue = this._value;\n\t\tthis._value = undefined;\n\t\tif (oldValue) {\n\t\t\tsetParentOfDisposable(oldValue, null);\n\t\t}\n\t\treturn oldValue;\n\t}\n}\n\n/**\n * Manages the lifecycle of a disposable value that may be changed like {@link MutableDisposable}, but the value must\n * exist and cannot be undefined.\n */\nexport class MandatoryMutableDisposable<T extends IDisposable> implements IDisposable {\n\tprivate readonly _disposable = new MutableDisposable<T>();\n\tprivate _isDisposed = false;\n\n\tconstructor(initialValue: T) {\n\t\tthis._disposable.value = initialValue;\n\t}\n\n\tget value(): T {\n\t\treturn this._disposable.value!;\n\t}\n\n\tset value(value: T) {\n\t\tif (this._isDisposed || value === this._disposable.value) {\n\t\t\treturn;\n\t\t}\n\t\tthis._disposable.value = value;\n\t}\n\n\tdispose() {\n\t\tthis._isDisposed = true;\n\t\tthis._disposable.dispose();\n\t}\n}\n\nexport class RefCountedDisposable {\n\n\tprivate _counter: number = 1;\n\n\tconstructor(\n\t\tprivate readonly _disposable: IDisposable,\n\t) { }\n\n\tacquire() {\n\t\tthis._counter++;\n\t\treturn this;\n\t}\n\n\trelease() {\n\t\tif (--this._counter === 0) {\n\t\t\tthis._disposable.dispose();\n\t\t}\n\t\treturn this;\n\t}\n}\n\n/**\n * A safe disposable can be `unset` so that a leaked reference (listener)\n * can be cut-off.\n */\nexport class SafeDisposable implements IDisposable {\n\n\tdispose: () => void = () => { };\n\tunset: () => void = () => { };\n\tisset: () => boolean = () => false;\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t}\n\n\tset(fn: Function) {\n\t\tlet callback: Function | undefined = fn;\n\t\tthis.unset = () => callback = undefined;\n\t\tthis.isset = () => callback !== undefined;\n\t\tthis.dispose = () => {\n\t\t\tif (callback) {\n\t\t\t\tcallback();\n\t\t\t\tcallback = undefined;\n\t\t\t\tmarkAsDisposed(this);\n\t\t\t}\n\t\t};\n\t\treturn this;\n\t}\n}\n\nexport interface IReference<T> extends IDisposable {\n\treadonly object: T;\n}\n\nexport abstract class ReferenceCollection<T> {\n\n\tprivate readonly references: Map<string, { readonly object: T; counter: number }> = new Map();\n\n\tacquire(key: string, ...args: any[]): IReference<T> {\n\t\tlet reference = this.references.get(key);\n\n\t\tif (!reference) {\n\t\t\treference = { counter: 0, object: this.createReferencedObject(key, ...args) };\n\t\t\tthis.references.set(key, reference);\n\t\t}\n\n\t\tconst { object } = reference;\n\t\tconst dispose = createSingleCallFunction(() => {\n\t\t\tif (--reference.counter === 0) {\n\t\t\t\tthis.destroyReferencedObject(key, reference.object);\n\t\t\t\tthis.references.delete(key);\n\t\t\t}\n\t\t});\n\n\t\treference.counter++;\n\n\t\treturn { object, dispose };\n\t}\n\n\tprotected abstract createReferencedObject(key: string, ...args: any[]): T;\n\tprotected abstract destroyReferencedObject(key: string, object: T): void;\n}\n\n/**\n * Unwraps a reference collection of promised values. Makes sure\n * references are disposed whenever promises get rejected.\n */\nexport class AsyncReferenceCollection<T> {\n\n\tconstructor(private referenceCollection: ReferenceCollection<Promise<T>>) { }\n\n\tasync acquire(key: string, ...args: any[]): Promise<IReference<T>> {\n\t\tconst ref = this.referenceCollection.acquire(key, ...args);\n\n\t\ttry {\n\t\t\tconst object = await ref.object;\n\n\t\t\treturn {\n\t\t\t\tobject,\n\t\t\t\tdispose: () => ref.dispose()\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tref.dispose();\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\nexport class ImmortalReference<T> implements IReference<T> {\n\tconstructor(public object: T) { }\n\tdispose(): void { /* noop */ }\n}\n\nexport function disposeOnReturn(fn: (store: DisposableStore) => void): void {\n\tconst store = new DisposableStore();\n\ttry {\n\t\tfn(store);\n\t} finally {\n\t\tstore.dispose();\n\t}\n}\n\n/**\n * A map the manages the lifecycle of the values that it stores.\n */\nexport class DisposableMap<K, V extends IDisposable = IDisposable> implements IDisposable {\n\n\tprivate readonly _store = new Map<K, V>();\n\tprivate _isDisposed = false;\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t}\n\n\t/**\n\t * Disposes of all stored values and mark this object as disposed.\n\t *\n\t * Trying to use this object after it has been disposed of is an error.\n\t */\n\tdispose(): void {\n\t\tmarkAsDisposed(this);\n\t\tthis._isDisposed = true;\n\t\tthis.clearAndDisposeAll();\n\t}\n\n\t/**\n\t * Disposes of all stored values and clear the map, but DO NOT mark this object as disposed.\n\t */\n\tclearAndDisposeAll(): void {\n\t\tif (!this._store.size) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tdispose(this._store.values());\n\t\t} finally {\n\t\t\tthis._store.clear();\n\t\t}\n\t}\n\n\thas(key: K): boolean {\n\t\treturn this._store.has(key);\n\t}\n\n\tget size(): number {\n\t\treturn this._store.size;\n\t}\n\n\tget(key: K): V | undefined {\n\t\treturn this._store.get(key);\n\t}\n\n\tset(key: K, value: V, skipDisposeOnOverwrite = false): void {\n\t\tif (this._isDisposed) {\n\t\t\tconsole.warn(new Error('Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!').stack);\n\t\t}\n\n\t\tif (!skipDisposeOnOverwrite) {\n\t\t\tthis._store.get(key)?.dispose();\n\t\t}\n\n\t\tthis._store.set(key, value);\n\t}\n\n\t/**\n\t * Delete the value stored for `key` from this map and also dispose of it.\n\t */\n\tdeleteAndDispose(key: K): void {\n\t\tthis._store.get(key)?.dispose();\n\t\tthis._store.delete(key);\n\t}\n\n\t/**\n\t * Delete the value stored for `key` from this map but return it. The caller is\n\t * responsible for disposing of the value.\n\t */\n\tdeleteAndLeak(key: K): V | undefined {\n\t\tconst value = this._store.get(key);\n\t\tthis._store.delete(key);\n\t\treturn value;\n\t}\n\n\tkeys(): IterableIterator<K> {\n\t\treturn this._store.keys();\n\t}\n\n\tvalues(): IterableIterator<V> {\n\t\treturn this._store.values();\n\t}\n\n\t[Symbol.iterator](): IterableIterator<[K, V]> {\n\t\treturn this._store[Symbol.iterator]();\n\t}\n}\n"],
  "mappings": "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",
  "names": ["i", "dispose"]
}
