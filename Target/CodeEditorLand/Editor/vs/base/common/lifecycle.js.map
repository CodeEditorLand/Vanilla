{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/lifecycle.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { compareBy, numberComparator } from \"./arrays.js\";\nimport { groupBy } from \"./collections.js\";\nimport { createSingleCallFunction } from \"./functional.js\";\nimport { Iterable } from \"./iterator.js\";\nimport { SetMap } from \"./map.js\";\n\n// #region Disposable Tracking\n\n/**\n * Enables logging of potentially leaked disposables.\n *\n * A disposable is considered leaked if it is not disposed or not registered as the child of\n * another disposable. This tracking is very simple an only works for classes that either\n * extend Disposable or use a DisposableStore. This means there are a lot of false positives.\n */\nconst TRACK_DISPOSABLES = false;\nlet disposableTracker: IDisposableTracker | null = null;\n\nexport interface IDisposableTracker {\n\t/**\n\t * Is called on construction of a disposable.\n\t */\n\ttrackDisposable(disposable: IDisposable): void;\n\n\t/**\n\t * Is called when a disposable is registered as child of another disposable (e.g. {@link DisposableStore}).\n\t * If parent is `null`, the disposable is removed from its former parent.\n\t */\n\tsetParent(child: IDisposable, parent: IDisposable | null): void;\n\n\t/**\n\t * Is called after a disposable is disposed.\n\t */\n\tmarkAsDisposed(disposable: IDisposable): void;\n\n\t/**\n\t * Indicates that the given object is a singleton which does not need to be disposed.\n\t */\n\tmarkAsSingleton(disposable: IDisposable): void;\n}\n\nexport interface DisposableInfo {\n\tvalue: IDisposable;\n\tsource: string | null;\n\tparent: IDisposable | null;\n\tisSingleton: boolean;\n\tidx: number;\n}\n\nexport class DisposableTracker implements IDisposableTracker {\n\tprivate static idx = 0;\n\n\tprivate readonly livingDisposables = new Map<IDisposable, DisposableInfo>();\n\n\tprivate getDisposableData(d: IDisposable): DisposableInfo {\n\t\tlet val = this.livingDisposables.get(d);\n\t\tif (!val) {\n\t\t\tval = {\n\t\t\t\tparent: null,\n\t\t\t\tsource: null,\n\t\t\t\tisSingleton: false,\n\t\t\t\tvalue: d,\n\t\t\t\tidx: DisposableTracker.idx++,\n\t\t\t};\n\t\t\tthis.livingDisposables.set(d, val);\n\t\t}\n\t\treturn val;\n\t}\n\n\ttrackDisposable(d: IDisposable): void {\n\t\tconst data = this.getDisposableData(d);\n\t\tif (!data.source) {\n\t\t\tdata.source = new Error().stack!;\n\t\t}\n\t}\n\n\tsetParent(child: IDisposable, parent: IDisposable | null): void {\n\t\tconst data = this.getDisposableData(child);\n\t\tdata.parent = parent;\n\t}\n\n\tmarkAsDisposed(x: IDisposable): void {\n\t\tthis.livingDisposables.delete(x);\n\t}\n\n\tmarkAsSingleton(disposable: IDisposable): void {\n\t\tthis.getDisposableData(disposable).isSingleton = true;\n\t}\n\n\tprivate getRootParent(\n\t\tdata: DisposableInfo,\n\t\tcache: Map<DisposableInfo, DisposableInfo>,\n\t): DisposableInfo {\n\t\tconst cacheValue = cache.get(data);\n\t\tif (cacheValue) {\n\t\t\treturn cacheValue;\n\t\t}\n\n\t\tconst result = data.parent\n\t\t\t? this.getRootParent(this.getDisposableData(data.parent), cache)\n\t\t\t: data;\n\t\tcache.set(data, result);\n\t\treturn result;\n\t}\n\n\tgetTrackedDisposables(): IDisposable[] {\n\t\tconst rootParentCache = new Map<DisposableInfo, DisposableInfo>();\n\n\t\tconst leaking = [...this.livingDisposables.entries()]\n\t\t\t.filter(\n\t\t\t\t([, v]) =>\n\t\t\t\t\tv.source !== null &&\n\t\t\t\t\t!this.getRootParent(v, rootParentCache).isSingleton,\n\t\t\t)\n\t\t\t.flatMap(([k]) => k);\n\n\t\treturn leaking;\n\t}\n\n\tcomputeLeakingDisposables(\n\t\tmaxReported = 10,\n\t\tpreComputedLeaks?: DisposableInfo[],\n\t): { leaks: DisposableInfo[]; details: string } | undefined {\n\t\tlet uncoveredLeakingObjs: DisposableInfo[] | undefined;\n\t\tif (preComputedLeaks) {\n\t\t\tuncoveredLeakingObjs = preComputedLeaks;\n\t\t} else {\n\t\t\tconst rootParentCache = new Map<DisposableInfo, DisposableInfo>();\n\n\t\t\tconst leakingObjects = [...this.livingDisposables.values()].filter(\n\t\t\t\t(info) =>\n\t\t\t\t\tinfo.source !== null &&\n\t\t\t\t\t!this.getRootParent(info, rootParentCache).isSingleton,\n\t\t\t);\n\n\t\t\tif (leakingObjects.length === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst leakingObjsSet = new Set(leakingObjects.map((o) => o.value));\n\n\t\t\t// Remove all objects that are a child of other leaking objects. Assumes there are no cycles.\n\t\t\tuncoveredLeakingObjs = leakingObjects.filter((l) => {\n\t\t\t\treturn !(l.parent && leakingObjsSet.has(l.parent));\n\t\t\t});\n\n\t\t\tif (uncoveredLeakingObjs.length === 0) {\n\t\t\t\tthrow new Error(\"There are cyclic diposable chains!\");\n\t\t\t}\n\t\t}\n\n\t\tif (!uncoveredLeakingObjs) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tfunction getStackTracePath(leaking: DisposableInfo): string[] {\n\t\t\tfunction removePrefix(\n\t\t\t\tarray: string[],\n\t\t\t\tlinesToRemove: (string | RegExp)[],\n\t\t\t) {\n\t\t\t\twhile (\n\t\t\t\t\tarray.length > 0 &&\n\t\t\t\t\tlinesToRemove.some((regexp) =>\n\t\t\t\t\t\ttypeof regexp === \"string\"\n\t\t\t\t\t\t\t? regexp === array[0]\n\t\t\t\t\t\t\t: array[0].match(regexp),\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tarray.shift();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst lines = leaking\n\t\t\t\t.source!.split(\"\\n\")\n\t\t\t\t.map((p) => p.trim().replace(\"at \", \"\"))\n\t\t\t\t.filter((l) => l !== \"\");\n\t\t\tremovePrefix(lines, [\n\t\t\t\t\"Error\",\n\t\t\t\t/^trackDisposable \\(.*\\)$/,\n\t\t\t\t/^DisposableTracker.trackDisposable \\(.*\\)$/,\n\t\t\t]);\n\t\t\treturn lines.reverse();\n\t\t}\n\n\t\tconst stackTraceStarts = new SetMap<string, DisposableInfo>();\n\t\tfor (const leaking of uncoveredLeakingObjs) {\n\t\t\tconst stackTracePath = getStackTracePath(leaking);\n\t\t\tfor (let i = 0; i <= stackTracePath.length; i++) {\n\t\t\t\tstackTraceStarts.add(\n\t\t\t\t\tstackTracePath.slice(0, i).join(\"\\n\"),\n\t\t\t\t\tleaking,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Put earlier leaks first\n\t\tuncoveredLeakingObjs.sort(compareBy((l) => l.idx, numberComparator));\n\n\t\tlet message = \"\";\n\n\t\tlet i = 0;\n\t\tfor (const leaking of uncoveredLeakingObjs.slice(0, maxReported)) {\n\t\t\ti++;\n\t\t\tconst stackTracePath = getStackTracePath(leaking);\n\t\t\tconst stackTraceFormattedLines = [];\n\n\t\t\tfor (let i = 0; i < stackTracePath.length; i++) {\n\t\t\t\tlet line = stackTracePath[i];\n\t\t\t\tconst starts = stackTraceStarts.get(\n\t\t\t\t\tstackTracePath.slice(0, i + 1).join(\"\\n\"),\n\t\t\t\t);\n\t\t\t\tline = `(shared with ${starts.size}/${uncoveredLeakingObjs.length} leaks) at ${line}`;\n\n\t\t\t\tconst prevStarts = stackTraceStarts.get(\n\t\t\t\t\tstackTracePath.slice(0, i).join(\"\\n\"),\n\t\t\t\t);\n\t\t\t\tconst continuations = groupBy(\n\t\t\t\t\t[...prevStarts].map((d) => getStackTracePath(d)[i]),\n\t\t\t\t\t(v) => v,\n\t\t\t\t);\n\t\t\t\tdelete continuations[stackTracePath[i]];\n\t\t\t\tfor (const [cont, set] of Object.entries(continuations)) {\n\t\t\t\t\tstackTraceFormattedLines.unshift(\n\t\t\t\t\t\t`    - stacktraces of ${set.length} other leaks continue with ${cont}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tstackTraceFormattedLines.unshift(line);\n\t\t\t}\n\n\t\t\tmessage += `\\n\\n\\n==================== Leaking disposable ${i}/${uncoveredLeakingObjs.length}: ${leaking.value.constructor.name} ====================\\n${stackTraceFormattedLines.join(\"\\n\")}\\n============================================================\\n\\n`;\n\t\t}\n\n\t\tif (uncoveredLeakingObjs.length > maxReported) {\n\t\t\tmessage += `\\n\\n\\n... and ${uncoveredLeakingObjs.length - maxReported} more leaking disposables\\n\\n`;\n\t\t}\n\n\t\treturn { leaks: uncoveredLeakingObjs, details: message };\n\t}\n}\n\nexport function setDisposableTracker(tracker: IDisposableTracker | null): void {\n\tdisposableTracker = tracker;\n}\n\nif (TRACK_DISPOSABLES) {\n\tconst __is_disposable_tracked__ = \"__is_disposable_tracked__\";\n\tsetDisposableTracker(\n\t\tnew (class implements IDisposableTracker {\n\t\t\ttrackDisposable(x: IDisposable): void {\n\t\t\t\tconst stack = new Error(\"Potentially leaked disposable\").stack!;\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tif (!(x as any)[__is_disposable_tracked__]) {\n\t\t\t\t\t\tconsole.log(stack);\n\t\t\t\t\t}\n\t\t\t\t}, 3000);\n\t\t\t}\n\n\t\t\tsetParent(child: IDisposable, parent: IDisposable | null): void {\n\t\t\t\tif (child && child !== Disposable.None) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t(child as any)[__is_disposable_tracked__] = true;\n\t\t\t\t\t} catch {\n\t\t\t\t\t\t// noop\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmarkAsDisposed(disposable: IDisposable): void {\n\t\t\t\tif (disposable && disposable !== Disposable.None) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t(disposable as any)[__is_disposable_tracked__] = true;\n\t\t\t\t\t} catch {\n\t\t\t\t\t\t// noop\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmarkAsSingleton(disposable: IDisposable): void {}\n\t\t})(),\n\t);\n}\n\nexport function trackDisposable<T extends IDisposable>(x: T): T {\n\tdisposableTracker?.trackDisposable(x);\n\treturn x;\n}\n\nexport function markAsDisposed(disposable: IDisposable): void {\n\tdisposableTracker?.markAsDisposed(disposable);\n}\n\nfunction setParentOfDisposable(\n\tchild: IDisposable,\n\tparent: IDisposable | null,\n): void {\n\tdisposableTracker?.setParent(child, parent);\n}\n\nfunction setParentOfDisposables(\n\tchildren: IDisposable[],\n\tparent: IDisposable | null,\n): void {\n\tif (!disposableTracker) {\n\t\treturn;\n\t}\n\tfor (const child of children) {\n\t\tdisposableTracker.setParent(child, parent);\n\t}\n}\n\n/**\n * Indicates that the given object is a singleton which does not need to be disposed.\n */\nexport function markAsSingleton<T extends IDisposable>(singleton: T): T {\n\tdisposableTracker?.markAsSingleton(singleton);\n\treturn singleton;\n}\n\n// #endregion\n\n/**\n * An object that performs a cleanup operation when `.dispose()` is called.\n *\n * Some examples of how disposables are used:\n *\n * - An event listener that removes itself when `.dispose()` is called.\n * - A resource such as a file system watcher that cleans up the resource when `.dispose()` is called.\n * - The return value from registering a provider. When `.dispose()` is called, the provider is unregistered.\n */\nexport interface IDisposable {\n\tdispose(): void;\n}\n\n/**\n * Check if `thing` is {@link IDisposable disposable}.\n */\nexport function isDisposable<E>(thing: E): thing is E & IDisposable {\n\treturn (\n\t\ttypeof thing === \"object\" &&\n\t\tthing !== null &&\n\t\ttypeof (<IDisposable>(<any>thing)).dispose === \"function\" &&\n\t\t(<IDisposable>(<any>thing)).dispose.length === 0\n\t);\n}\n\n/**\n * Disposes of the value(s) passed in.\n */\nexport function dispose<T extends IDisposable>(disposable: T): T;\nexport function dispose<T extends IDisposable>(\n\tdisposable: T | undefined,\n): T | undefined;\nexport function dispose<\n\tT extends IDisposable,\n\tA extends Iterable<T> = Iterable<T>,\n>(disposables: A): A;\nexport function dispose<T extends IDisposable>(disposables: Array<T>): Array<T>;\nexport function dispose<T extends IDisposable>(\n\tdisposables: ReadonlyArray<T>,\n): ReadonlyArray<T>;\nexport function dispose<T extends IDisposable>(\n\targ: T | Iterable<T> | undefined,\n): any {\n\tif (Iterable.is(arg)) {\n\t\tconst errors: any[] = [];\n\n\t\tfor (const d of arg) {\n\t\t\tif (d) {\n\t\t\t\ttry {\n\t\t\t\t\td.dispose();\n\t\t\t\t} catch (e) {\n\t\t\t\t\terrors.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (errors.length === 1) {\n\t\t\tthrow errors[0];\n\t\t} else if (errors.length > 1) {\n\t\t\tthrow new AggregateError(\n\t\t\t\terrors,\n\t\t\t\t\"Encountered errors while disposing of store\",\n\t\t\t);\n\t\t}\n\n\t\treturn Array.isArray(arg) ? [] : arg;\n\t} else if (arg) {\n\t\targ.dispose();\n\t\treturn arg;\n\t}\n}\n\nexport function disposeIfDisposable<T extends IDisposable | object>(\n\tdisposables: Array<T>,\n): Array<T> {\n\tfor (const d of disposables) {\n\t\tif (isDisposable(d)) {\n\t\t\td.dispose();\n\t\t}\n\t}\n\treturn [];\n}\n\n/**\n * Combine multiple disposable values into a single {@link IDisposable}.\n */\nexport function combinedDisposable(...disposables: IDisposable[]): IDisposable {\n\tconst parent = toDisposable(() => dispose(disposables));\n\tsetParentOfDisposables(disposables, parent);\n\treturn parent;\n}\n\n/**\n * Turn a function that implements dispose into an {@link IDisposable}.\n *\n * @param fn Clean up function, guaranteed to be called only **once**.\n */\nexport function toDisposable(fn: () => void): IDisposable {\n\tconst self = trackDisposable({\n\t\tdispose: createSingleCallFunction(() => {\n\t\t\tmarkAsDisposed(self);\n\t\t\tfn();\n\t\t}),\n\t});\n\treturn self;\n}\n\n/**\n * Manages a collection of disposable values.\n *\n * This is the preferred way to manage multiple disposables. A `DisposableStore` is safer to work with than an\n * `IDisposable[]` as it considers edge cases, such as registering the same value multiple times or adding an item to a\n * store that has already been disposed of.\n */\nexport class DisposableStore implements IDisposable {\n\tstatic DISABLE_DISPOSED_WARNING = false;\n\n\tprivate readonly _toDispose = new Set<IDisposable>();\n\tprivate _isDisposed = false;\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t}\n\n\t/**\n\t * Dispose of all registered disposables and mark this object as disposed.\n\t *\n\t * Any future disposables added to this object will be disposed of on `add`.\n\t */\n\tpublic dispose(): void {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\n\t\tmarkAsDisposed(this);\n\t\tthis._isDisposed = true;\n\t\tthis.clear();\n\t}\n\n\t/**\n\t * @return `true` if this object has been disposed of.\n\t */\n\tpublic get isDisposed(): boolean {\n\t\treturn this._isDisposed;\n\t}\n\n\t/**\n\t * Dispose of all registered disposables but do not mark this object as disposed.\n\t */\n\tpublic clear(): void {\n\t\tif (this._toDispose.size === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tdispose(this._toDispose);\n\t\t} finally {\n\t\t\tthis._toDispose.clear();\n\t\t}\n\t}\n\n\t/**\n\t * Add a new {@link IDisposable disposable} to the collection.\n\t */\n\tpublic add<T extends IDisposable>(o: T): T {\n\t\tif (!o) {\n\t\t\treturn o;\n\t\t}\n\t\tif ((o as unknown as DisposableStore) === this) {\n\t\t\tthrow new Error(\"Cannot register a disposable on itself!\");\n\t\t}\n\n\t\tsetParentOfDisposable(o, this);\n\t\tif (this._isDisposed) {\n\t\t\tif (!DisposableStore.DISABLE_DISPOSED_WARNING) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\"Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!\",\n\t\t\t\t\t).stack,\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._toDispose.add(o);\n\t\t}\n\n\t\treturn o;\n\t}\n\n\t/**\n\t * Deletes a disposable from store and disposes of it. This will not throw or warn and proceed to dispose the\n\t * disposable even when the disposable is not part in the store.\n\t */\n\tpublic delete<T extends IDisposable>(o: T): void {\n\t\tif (!o) {\n\t\t\treturn;\n\t\t}\n\t\tif ((o as unknown as DisposableStore) === this) {\n\t\t\tthrow new Error(\"Cannot dispose a disposable on itself!\");\n\t\t}\n\t\tthis._toDispose.delete(o);\n\t\to.dispose();\n\t}\n\n\t/**\n\t * Deletes the value from the store, but does not dispose it.\n\t */\n\tpublic deleteAndLeak<T extends IDisposable>(o: T): void {\n\t\tif (!o) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._toDispose.has(o)) {\n\t\t\tthis._toDispose.delete(o);\n\t\t\tsetParentOfDisposable(o, null);\n\t\t}\n\t}\n}\n\n/**\n * Abstract base class for a {@link IDisposable disposable} object.\n *\n * Subclasses can {@linkcode _register} disposables that will be automatically cleaned up when this object is disposed of.\n */\nexport abstract class Disposable implements IDisposable {\n\t/**\n\t * A disposable that does nothing when it is disposed of.\n\t *\n\t * TODO: This should not be a static property.\n\t */\n\tstatic readonly None = Object.freeze<IDisposable>({ dispose() {} });\n\n\tprotected readonly _store = new DisposableStore();\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t\tsetParentOfDisposable(this._store, this);\n\t}\n\n\tpublic dispose(): void {\n\t\tmarkAsDisposed(this);\n\n\t\tthis._store.dispose();\n\t}\n\n\t/**\n\t * Adds `o` to the collection of disposables managed by this object.\n\t */\n\tprotected _register<T extends IDisposable>(o: T): T {\n\t\tif ((o as unknown as Disposable) === this) {\n\t\t\tthrow new Error(\"Cannot register a disposable on itself!\");\n\t\t}\n\t\treturn this._store.add(o);\n\t}\n}\n\n/**\n * Manages the lifecycle of a disposable value that may be changed.\n *\n * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can\n * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.\n */\nexport class MutableDisposable<T extends IDisposable> implements IDisposable {\n\tprivate _value?: T;\n\tprivate _isDisposed = false;\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t}\n\n\tget value(): T | undefined {\n\t\treturn this._isDisposed ? undefined : this._value;\n\t}\n\n\tset value(value: T | undefined) {\n\t\tif (this._isDisposed || value === this._value) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._value?.dispose();\n\t\tif (value) {\n\t\t\tsetParentOfDisposable(value, this);\n\t\t}\n\t\tthis._value = value;\n\t}\n\n\t/**\n\t * Resets the stored value and disposed of the previously stored value.\n\t */\n\tclear(): void {\n\t\tthis.value = undefined;\n\t}\n\n\tdispose(): void {\n\t\tthis._isDisposed = true;\n\t\tmarkAsDisposed(this);\n\t\tthis._value?.dispose();\n\t\tthis._value = undefined;\n\t}\n\n\t/**\n\t * Clears the value, but does not dispose it.\n\t * The old value is returned.\n\t */\n\tclearAndLeak(): T | undefined {\n\t\tconst oldValue = this._value;\n\t\tthis._value = undefined;\n\t\tif (oldValue) {\n\t\t\tsetParentOfDisposable(oldValue, null);\n\t\t}\n\t\treturn oldValue;\n\t}\n}\n\n/**\n * Manages the lifecycle of a disposable value that may be changed like {@link MutableDisposable}, but the value must\n * exist and cannot be undefined.\n */\nexport class MandatoryMutableDisposable<T extends IDisposable>\n\timplements IDisposable\n{\n\tprivate readonly _disposable = new MutableDisposable<T>();\n\tprivate _isDisposed = false;\n\n\tconstructor(initialValue: T) {\n\t\tthis._disposable.value = initialValue;\n\t}\n\n\tget value(): T {\n\t\treturn this._disposable.value!;\n\t}\n\n\tset value(value: T) {\n\t\tif (this._isDisposed || value === this._disposable.value) {\n\t\t\treturn;\n\t\t}\n\t\tthis._disposable.value = value;\n\t}\n\n\tdispose() {\n\t\tthis._isDisposed = true;\n\t\tthis._disposable.dispose();\n\t}\n}\n\nexport class RefCountedDisposable {\n\tprivate _counter = 1;\n\n\tconstructor(private readonly _disposable: IDisposable) {}\n\n\tacquire() {\n\t\tthis._counter++;\n\t\treturn this;\n\t}\n\n\trelease() {\n\t\tif (--this._counter === 0) {\n\t\t\tthis._disposable.dispose();\n\t\t}\n\t\treturn this;\n\t}\n}\n\n/**\n * A safe disposable can be `unset` so that a leaked reference (listener)\n * can be cut-off.\n */\nexport class SafeDisposable implements IDisposable {\n\tdispose: () => void = () => {};\n\tunset: () => void = () => {};\n\tisset: () => boolean = () => false;\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t}\n\n\tset(fn: Function) {\n\t\tlet callback: Function | undefined = fn;\n\t\tthis.unset = () => (callback = undefined);\n\t\tthis.isset = () => callback !== undefined;\n\t\tthis.dispose = () => {\n\t\t\tif (callback) {\n\t\t\t\tcallback();\n\t\t\t\tcallback = undefined;\n\t\t\t\tmarkAsDisposed(this);\n\t\t\t}\n\t\t};\n\t\treturn this;\n\t}\n}\n\nexport interface IReference<T> extends IDisposable {\n\treadonly object: T;\n}\n\nexport abstract class ReferenceCollection<T> {\n\tprivate readonly references: Map<\n\t\tstring,\n\t\t{ readonly object: T; counter: number }\n\t> = new Map();\n\n\tacquire(key: string, ...args: any[]): IReference<T> {\n\t\tlet reference = this.references.get(key);\n\n\t\tif (!reference) {\n\t\t\treference = {\n\t\t\t\tcounter: 0,\n\t\t\t\tobject: this.createReferencedObject(key, ...args),\n\t\t\t};\n\t\t\tthis.references.set(key, reference);\n\t\t}\n\n\t\tconst { object } = reference;\n\t\tconst dispose = createSingleCallFunction(() => {\n\t\t\tif (--reference.counter === 0) {\n\t\t\t\tthis.destroyReferencedObject(key, reference.object);\n\t\t\t\tthis.references.delete(key);\n\t\t\t}\n\t\t});\n\n\t\treference.counter++;\n\n\t\treturn { object, dispose };\n\t}\n\n\tprotected abstract createReferencedObject(key: string, ...args: any[]): T;\n\tprotected abstract destroyReferencedObject(key: string, object: T): void;\n}\n\n/**\n * Unwraps a reference collection of promised values. Makes sure\n * references are disposed whenever promises get rejected.\n */\nexport class AsyncReferenceCollection<T> {\n\tconstructor(private referenceCollection: ReferenceCollection<Promise<T>>) {}\n\n\tasync acquire(key: string, ...args: any[]): Promise<IReference<T>> {\n\t\tconst ref = this.referenceCollection.acquire(key, ...args);\n\n\t\ttry {\n\t\t\tconst object = await ref.object;\n\n\t\t\treturn {\n\t\t\t\tobject,\n\t\t\t\tdispose: () => ref.dispose(),\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tref.dispose();\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\nexport class ImmortalReference<T> implements IReference<T> {\n\tconstructor(public object: T) {}\n\tdispose(): void {\n\t\t/* noop */\n\t}\n}\n\nexport function disposeOnReturn(fn: (store: DisposableStore) => void): void {\n\tconst store = new DisposableStore();\n\ttry {\n\t\tfn(store);\n\t} finally {\n\t\tstore.dispose();\n\t}\n}\n\n/**\n * A map the manages the lifecycle of the values that it stores.\n */\nexport class DisposableMap<K, V extends IDisposable = IDisposable>\n\timplements IDisposable\n{\n\tprivate readonly _store = new Map<K, V>();\n\tprivate _isDisposed = false;\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t}\n\n\t/**\n\t * Disposes of all stored values and mark this object as disposed.\n\t *\n\t * Trying to use this object after it has been disposed of is an error.\n\t */\n\tdispose(): void {\n\t\tmarkAsDisposed(this);\n\t\tthis._isDisposed = true;\n\t\tthis.clearAndDisposeAll();\n\t}\n\n\t/**\n\t * Disposes of all stored values and clear the map, but DO NOT mark this object as disposed.\n\t */\n\tclearAndDisposeAll(): void {\n\t\tif (!this._store.size) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tdispose(this._store.values());\n\t\t} finally {\n\t\t\tthis._store.clear();\n\t\t}\n\t}\n\n\thas(key: K): boolean {\n\t\treturn this._store.has(key);\n\t}\n\n\tget size(): number {\n\t\treturn this._store.size;\n\t}\n\n\tget(key: K): V | undefined {\n\t\treturn this._store.get(key);\n\t}\n\n\tset(key: K, value: V, skipDisposeOnOverwrite = false): void {\n\t\tif (this._isDisposed) {\n\t\t\tconsole.warn(\n\t\t\t\tnew Error(\n\t\t\t\t\t\"Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!\",\n\t\t\t\t).stack,\n\t\t\t);\n\t\t}\n\n\t\tif (!skipDisposeOnOverwrite) {\n\t\t\tthis._store.get(key)?.dispose();\n\t\t}\n\n\t\tthis._store.set(key, value);\n\t}\n\n\t/**\n\t * Delete the value stored for `key` from this map and also dispose of it.\n\t */\n\tdeleteAndDispose(key: K): void {\n\t\tthis._store.get(key)?.dispose();\n\t\tthis._store.delete(key);\n\t}\n\n\t/**\n\t * Delete the value stored for `key` from this map but return it. The caller is\n\t * responsible for disposing of the value.\n\t */\n\tdeleteAndLeak(key: K): V | undefined {\n\t\tconst value = this._store.get(key);\n\t\tthis._store.delete(key);\n\t\treturn value;\n\t}\n\n\tkeys(): IterableIterator<K> {\n\t\treturn this._store.keys();\n\t}\n\n\tvalues(): IterableIterator<V> {\n\t\treturn this._store.values();\n\t}\n\n\t[Symbol.iterator](): IterableIterator<[K, V]> {\n\t\treturn this._store[Symbol.iterator]();\n\t}\n}\n"],
  "mappings": "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",
  "names": ["i", "dispose"]
}
