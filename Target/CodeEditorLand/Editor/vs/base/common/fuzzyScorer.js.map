{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/fuzzyScorer.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from './charCode.js';\nimport { compareAnything } from './comparers.js';\nimport { createMatches as createFuzzyMatches, fuzzyScore, IMatch, isUpper, matchesPrefix } from './filters.js';\nimport { hash } from './hash.js';\nimport { sep } from './path.js';\nimport { isLinux, isWindows } from './platform.js';\nimport { equalsIgnoreCase, stripWildcards } from './strings.js';\n\n//#region Fuzzy scorer\n\nexport type FuzzyScore = [number /* score */, number[] /* match positions */];\nexport type FuzzyScorerCache = { [key: string]: IItemScore };\n\nconst NO_MATCH = 0;\nconst NO_SCORE: FuzzyScore = [NO_MATCH, []];\n\n// const DEBUG = true;\n// const DEBUG_MATRIX = false;\n\nexport function scoreFuzzy(target: string, query: string, queryLower: string, allowNonContiguousMatches: boolean): FuzzyScore {\n\tif (!target || !query) {\n\t\treturn NO_SCORE; // return early if target or query are undefined\n\t}\n\n\tconst targetLength = target.length;\n\tconst queryLength = query.length;\n\n\tif (targetLength < queryLength) {\n\t\treturn NO_SCORE; // impossible for query to be contained in target\n\t}\n\n\t// if (DEBUG) {\n\t// \tconsole.group(`Target: ${target}, Query: ${query}`);\n\t// }\n\n\tconst targetLower = target.toLowerCase();\n\tconst res = doScoreFuzzy(query, queryLower, queryLength, target, targetLower, targetLength, allowNonContiguousMatches);\n\n\t// if (DEBUG) {\n\t// \tconsole.log(`%cFinal Score: ${res[0]}`, 'font-weight: bold');\n\t// \tconsole.groupEnd();\n\t// }\n\n\treturn res;\n}\n\nfunction doScoreFuzzy(query: string, queryLower: string, queryLength: number, target: string, targetLower: string, targetLength: number, allowNonContiguousMatches: boolean): FuzzyScore {\n\tconst scores: number[] = [];\n\tconst matches: number[] = [];\n\n\t//\n\t// Build Scorer Matrix:\n\t//\n\t// The matrix is composed of query q and target t. For each index we score\n\t// q[i] with t[i] and compare that with the previous score. If the score is\n\t// equal or larger, we keep the match. In addition to the score, we also keep\n\t// the length of the consecutive matches to use as boost for the score.\n\t//\n\t//      t   a   r   g   e   t\n\t//  q\n\t//  u\n\t//  e\n\t//  r\n\t//  y\n\t//\n\tfor (let queryIndex = 0; queryIndex < queryLength; queryIndex++) {\n\t\tconst queryIndexOffset = queryIndex * targetLength;\n\t\tconst queryIndexPreviousOffset = queryIndexOffset - targetLength;\n\n\t\tconst queryIndexGtNull = queryIndex > 0;\n\n\t\tconst queryCharAtIndex = query[queryIndex];\n\t\tconst queryLowerCharAtIndex = queryLower[queryIndex];\n\n\t\tfor (let targetIndex = 0; targetIndex < targetLength; targetIndex++) {\n\t\t\tconst targetIndexGtNull = targetIndex > 0;\n\n\t\t\tconst currentIndex = queryIndexOffset + targetIndex;\n\t\t\tconst leftIndex = currentIndex - 1;\n\t\t\tconst diagIndex = queryIndexPreviousOffset + targetIndex - 1;\n\n\t\t\tconst leftScore = targetIndexGtNull ? scores[leftIndex] : 0;\n\t\t\tconst diagScore = queryIndexGtNull && targetIndexGtNull ? scores[diagIndex] : 0;\n\n\t\t\tconst matchesSequenceLength = queryIndexGtNull && targetIndexGtNull ? matches[diagIndex] : 0;\n\n\t\t\t// If we are not matching on the first query character any more, we only produce a\n\t\t\t// score if we had a score previously for the last query index (by looking at the diagScore).\n\t\t\t// This makes sure that the query always matches in sequence on the target. For example\n\t\t\t// given a target of \"ede\" and a query of \"de\", we would otherwise produce a wrong high score\n\t\t\t// for query[1] (\"e\") matching on target[0] (\"e\") because of the \"beginning of word\" boost.\n\t\t\tlet score: number;\n\t\t\tif (!diagScore && queryIndexGtNull) {\n\t\t\t\tscore = 0;\n\t\t\t} else {\n\t\t\t\tscore = computeCharScore(queryCharAtIndex, queryLowerCharAtIndex, target, targetLower, targetIndex, matchesSequenceLength);\n\t\t\t}\n\n\t\t\t// We have a score and its equal or larger than the left score\n\t\t\t// Match: sequence continues growing from previous diag value\n\t\t\t// Score: increases by diag score value\n\t\t\tconst isValidScore = score && diagScore + score >= leftScore;\n\t\t\tif (isValidScore && (\n\t\t\t\t// We don't need to check if it's contiguous if we allow non-contiguous matches\n\t\t\t\tallowNonContiguousMatches ||\n\t\t\t\t// We must be looking for a contiguous match.\n\t\t\t\t// Looking at an index higher than 0 in the query means we must have already\n\t\t\t\t// found out this is contiguous otherwise there wouldn't have been a score\n\t\t\t\tqueryIndexGtNull ||\n\t\t\t\t// lastly check if the query is completely contiguous at this index in the target\n\t\t\t\ttargetLower.startsWith(queryLower, targetIndex)\n\t\t\t)) {\n\t\t\t\tmatches[currentIndex] = matchesSequenceLength + 1;\n\t\t\t\tscores[currentIndex] = diagScore + score;\n\t\t\t}\n\n\t\t\t// We either have no score or the score is lower than the left score\n\t\t\t// Match: reset to 0\n\t\t\t// Score: pick up from left hand side\n\t\t\telse {\n\t\t\t\tmatches[currentIndex] = NO_MATCH;\n\t\t\t\tscores[currentIndex] = leftScore;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Restore Positions (starting from bottom right of matrix)\n\tconst positions: number[] = [];\n\tlet queryIndex = queryLength - 1;\n\tlet targetIndex = targetLength - 1;\n\twhile (queryIndex >= 0 && targetIndex >= 0) {\n\t\tconst currentIndex = queryIndex * targetLength + targetIndex;\n\t\tconst match = matches[currentIndex];\n\t\tif (match === NO_MATCH) {\n\t\t\ttargetIndex--; // go left\n\t\t} else {\n\t\t\tpositions.push(targetIndex);\n\n\t\t\t// go up and left\n\t\t\tqueryIndex--;\n\t\t\ttargetIndex--;\n\t\t}\n\t}\n\n\t// Print matrix\n\t// if (DEBUG_MATRIX) {\n\t// \tprintMatrix(query, target, matches, scores);\n\t// }\n\n\treturn [scores[queryLength * targetLength - 1], positions.reverse()];\n}\n\nfunction computeCharScore(queryCharAtIndex: string, queryLowerCharAtIndex: string, target: string, targetLower: string, targetIndex: number, matchesSequenceLength: number): number {\n\tlet score = 0;\n\n\tif (!considerAsEqual(queryLowerCharAtIndex, targetLower[targetIndex])) {\n\t\treturn score; // no match of characters\n\t}\n\n\t// if (DEBUG) {\n\t// \tconsole.groupCollapsed(`%cFound a match of char: ${queryLowerCharAtIndex} at index ${targetIndex}`, 'font-weight: normal');\n\t// }\n\n\t// Character match bonus\n\tscore += 1;\n\n\t// if (DEBUG) {\n\t// \tconsole.log(`%cCharacter match bonus: +1`, 'font-weight: normal');\n\t// }\n\n\t// Consecutive match bonus\n\tif (matchesSequenceLength > 0) {\n\t\tscore += (matchesSequenceLength * 5);\n\n\t\t// if (DEBUG) {\n\t\t// \tconsole.log(`Consecutive match bonus: +${matchesSequenceLength * 5}`);\n\t\t// }\n\t}\n\n\t// Same case bonus\n\tif (queryCharAtIndex === target[targetIndex]) {\n\t\tscore += 1;\n\n\t\t// if (DEBUG) {\n\t\t// \tconsole.log('Same case bonus: +1');\n\t\t// }\n\t}\n\n\t// Start of word bonus\n\tif (targetIndex === 0) {\n\t\tscore += 8;\n\n\t\t// if (DEBUG) {\n\t\t// \tconsole.log('Start of word bonus: +8');\n\t\t// }\n\t}\n\n\telse {\n\n\t\t// After separator bonus\n\t\tconst separatorBonus = scoreSeparatorAtPos(target.charCodeAt(targetIndex - 1));\n\t\tif (separatorBonus) {\n\t\t\tscore += separatorBonus;\n\n\t\t\t// if (DEBUG) {\n\t\t\t// \tconsole.log(`After separator bonus: +${separatorBonus}`);\n\t\t\t// }\n\t\t}\n\n\t\t// Inside word upper case bonus (camel case). We only give this bonus if we're not in a contiguous sequence.\n\t\t// For example:\n\t\t// NPE => NullPointerException = boost\n\t\t// HTTP => HTTP = not boost\n\t\telse if (isUpper(target.charCodeAt(targetIndex)) && matchesSequenceLength === 0) {\n\t\t\tscore += 2;\n\n\t\t\t// if (DEBUG) {\n\t\t\t// \tconsole.log('Inside word upper case bonus: +2');\n\t\t\t// }\n\t\t}\n\t}\n\n\t// if (DEBUG) {\n\t// \tconsole.log(`Total score: ${score}`);\n\t// \tconsole.groupEnd();\n\t// }\n\n\treturn score;\n}\n\nfunction considerAsEqual(a: string, b: string): boolean {\n\tif (a === b) {\n\t\treturn true;\n\t}\n\n\t// Special case path separators: ignore platform differences\n\tif (a === '/' || a === '\\\\') {\n\t\treturn b === '/' || b === '\\\\';\n\t}\n\n\treturn false;\n}\n\nfunction scoreSeparatorAtPos(charCode: number): number {\n\tswitch (charCode) {\n\t\tcase CharCode.Slash:\n\t\tcase CharCode.Backslash:\n\t\t\treturn 5; // prefer path separators...\n\t\tcase CharCode.Underline:\n\t\tcase CharCode.Dash:\n\t\tcase CharCode.Period:\n\t\tcase CharCode.Space:\n\t\tcase CharCode.SingleQuote:\n\t\tcase CharCode.DoubleQuote:\n\t\tcase CharCode.Colon:\n\t\t\treturn 4; // ...over other separators\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n}\n\n// function printMatrix(query: string, target: string, matches: number[], scores: number[]): void {\n// \tconsole.log('\\t' + target.split('').join('\\t'));\n// \tfor (let queryIndex = 0; queryIndex < query.length; queryIndex++) {\n// \t\tlet line = query[queryIndex] + '\\t';\n// \t\tfor (let targetIndex = 0; targetIndex < target.length; targetIndex++) {\n// \t\t\tconst currentIndex = queryIndex * target.length + targetIndex;\n// \t\t\tline = line + 'M' + matches[currentIndex] + '/' + 'S' + scores[currentIndex] + '\\t';\n// \t\t}\n\n// \t\tconsole.log(line);\n// \t}\n// }\n\n//#endregion\n\n\n//#region Alternate fuzzy scorer implementation that is e.g. used for symbols\n\nexport type FuzzyScore2 = [number | undefined /* score */, IMatch[]];\n\nconst NO_SCORE2: FuzzyScore2 = [undefined, []];\n\nexport function scoreFuzzy2(target: string, query: IPreparedQuery | IPreparedQueryPiece, patternStart = 0, wordStart = 0): FuzzyScore2 {\n\n\t// Score: multiple inputs\n\tconst preparedQuery = query as IPreparedQuery;\n\tif (preparedQuery.values && preparedQuery.values.length > 1) {\n\t\treturn doScoreFuzzy2Multiple(target, preparedQuery.values, patternStart, wordStart);\n\t}\n\n\t// Score: single input\n\treturn doScoreFuzzy2Single(target, query, patternStart, wordStart);\n}\n\nfunction doScoreFuzzy2Multiple(target: string, query: IPreparedQueryPiece[], patternStart: number, wordStart: number): FuzzyScore2 {\n\tlet totalScore = 0;\n\tconst totalMatches: IMatch[] = [];\n\n\tfor (const queryPiece of query) {\n\t\tconst [score, matches] = doScoreFuzzy2Single(target, queryPiece, patternStart, wordStart);\n\t\tif (typeof score !== 'number') {\n\t\t\t// if a single query value does not match, return with\n\t\t\t// no score entirely, we require all queries to match\n\t\t\treturn NO_SCORE2;\n\t\t}\n\n\t\ttotalScore += score;\n\t\ttotalMatches.push(...matches);\n\t}\n\n\t// if we have a score, ensure that the positions are\n\t// sorted in ascending order and distinct\n\treturn [totalScore, normalizeMatches(totalMatches)];\n}\n\nfunction doScoreFuzzy2Single(target: string, query: IPreparedQueryPiece, patternStart: number, wordStart: number): FuzzyScore2 {\n\tconst score = fuzzyScore(query.original, query.originalLowercase, patternStart, target, target.toLowerCase(), wordStart, { firstMatchCanBeWeak: true, boostFullMatch: true });\n\tif (!score) {\n\t\treturn NO_SCORE2;\n\t}\n\n\treturn [score[0], createFuzzyMatches(score)];\n}\n\n//#endregion\n\n\n//#region Item (label, description, path) scorer\n\n/**\n * Scoring on structural items that have a label and optional description.\n */\nexport interface IItemScore {\n\n\t/**\n\t * Overall score.\n\t */\n\tscore: number;\n\n\t/**\n\t * Matches within the label.\n\t */\n\tlabelMatch?: IMatch[];\n\n\t/**\n\t * Matches within the description.\n\t */\n\tdescriptionMatch?: IMatch[];\n}\n\nconst NO_ITEM_SCORE = Object.freeze<IItemScore>({ score: 0 });\n\nexport interface IItemAccessor<T> {\n\n\t/**\n\t * Just the label of the item to score on.\n\t */\n\tgetItemLabel(item: T): string | undefined;\n\n\t/**\n\t * The optional description of the item to score on.\n\t */\n\tgetItemDescription(item: T): string | undefined;\n\n\t/**\n\t * If the item is a file, the path of the file to score on.\n\t */\n\tgetItemPath(file: T): string | undefined;\n}\n\nconst PATH_IDENTITY_SCORE = 1 << 18;\nconst LABEL_PREFIX_SCORE_THRESHOLD = 1 << 17;\nconst LABEL_SCORE_THRESHOLD = 1 << 16;\n\nfunction getCacheHash(label: string, description: string | undefined, allowNonContiguousMatches: boolean, query: IPreparedQuery) {\n\tconst values = query.values ? query.values : [query];\n\tconst cacheHash = hash({\n\t\t[query.normalized]: {\n\t\t\tvalues: values.map(v => ({ value: v.normalized, expectContiguousMatch: v.expectContiguousMatch })),\n\t\t\tlabel,\n\t\t\tdescription,\n\t\t\tallowNonContiguousMatches\n\t\t}\n\t});\n\treturn cacheHash;\n}\n\nexport function scoreItemFuzzy<T>(item: T, query: IPreparedQuery, allowNonContiguousMatches: boolean, accessor: IItemAccessor<T>, cache: FuzzyScorerCache): IItemScore {\n\tif (!item || !query.normalized) {\n\t\treturn NO_ITEM_SCORE; // we need an item and query to score on at least\n\t}\n\n\tconst label = accessor.getItemLabel(item);\n\tif (!label) {\n\t\treturn NO_ITEM_SCORE; // we need a label at least\n\t}\n\n\tconst description = accessor.getItemDescription(item);\n\n\t// in order to speed up scoring, we cache the score with a unique hash based on:\n\t// - label\n\t// - description (if provided)\n\t// - whether non-contiguous matching is enabled or not\n\t// - hash of the query (normalized) values\n\tconst cacheHash = getCacheHash(label, description, allowNonContiguousMatches, query);\n\tconst cached = cache[cacheHash];\n\tif (cached) {\n\t\treturn cached;\n\t}\n\n\tconst itemScore = doScoreItemFuzzy(label, description, accessor.getItemPath(item), query, allowNonContiguousMatches);\n\tcache[cacheHash] = itemScore;\n\n\treturn itemScore;\n}\n\nfunction doScoreItemFuzzy(label: string, description: string | undefined, path: string | undefined, query: IPreparedQuery, allowNonContiguousMatches: boolean): IItemScore {\n\tconst preferLabelMatches = !path || !query.containsPathSeparator;\n\n\t// Treat identity matches on full path highest\n\tif (path && (isLinux ? query.pathNormalized === path : equalsIgnoreCase(query.pathNormalized, path))) {\n\t\treturn { score: PATH_IDENTITY_SCORE, labelMatch: [{ start: 0, end: label.length }], descriptionMatch: description ? [{ start: 0, end: description.length }] : undefined };\n\t}\n\n\t// Score: multiple inputs\n\tif (query.values && query.values.length > 1) {\n\t\treturn doScoreItemFuzzyMultiple(label, description, path, query.values, preferLabelMatches, allowNonContiguousMatches);\n\t}\n\n\t// Score: single input\n\treturn doScoreItemFuzzySingle(label, description, path, query, preferLabelMatches, allowNonContiguousMatches);\n}\n\nfunction doScoreItemFuzzyMultiple(label: string, description: string | undefined, path: string | undefined, query: IPreparedQueryPiece[], preferLabelMatches: boolean, allowNonContiguousMatches: boolean): IItemScore {\n\tlet totalScore = 0;\n\tconst totalLabelMatches: IMatch[] = [];\n\tconst totalDescriptionMatches: IMatch[] = [];\n\n\tfor (const queryPiece of query) {\n\t\tconst { score, labelMatch, descriptionMatch } = doScoreItemFuzzySingle(label, description, path, queryPiece, preferLabelMatches, allowNonContiguousMatches);\n\t\tif (score === NO_MATCH) {\n\t\t\t// if a single query value does not match, return with\n\t\t\t// no score entirely, we require all queries to match\n\t\t\treturn NO_ITEM_SCORE;\n\t\t}\n\n\t\ttotalScore += score;\n\t\tif (labelMatch) {\n\t\t\ttotalLabelMatches.push(...labelMatch);\n\t\t}\n\n\t\tif (descriptionMatch) {\n\t\t\ttotalDescriptionMatches.push(...descriptionMatch);\n\t\t}\n\t}\n\n\t// if we have a score, ensure that the positions are\n\t// sorted in ascending order and distinct\n\treturn {\n\t\tscore: totalScore,\n\t\tlabelMatch: normalizeMatches(totalLabelMatches),\n\t\tdescriptionMatch: normalizeMatches(totalDescriptionMatches)\n\t};\n}\n\nfunction doScoreItemFuzzySingle(label: string, description: string | undefined, path: string | undefined, query: IPreparedQueryPiece, preferLabelMatches: boolean, allowNonContiguousMatches: boolean): IItemScore {\n\n\t// Prefer label matches if told so or we have no description\n\tif (preferLabelMatches || !description) {\n\t\tconst [labelScore, labelPositions] = scoreFuzzy(\n\t\t\tlabel,\n\t\t\tquery.normalized,\n\t\t\tquery.normalizedLowercase,\n\t\t\tallowNonContiguousMatches && !query.expectContiguousMatch);\n\t\tif (labelScore) {\n\n\t\t\t// If we have a prefix match on the label, we give a much\n\t\t\t// higher baseScore to elevate these matches over others\n\t\t\t// This ensures that typing a file name wins over results\n\t\t\t// that are present somewhere in the label, but not the\n\t\t\t// beginning.\n\t\t\tconst labelPrefixMatch = matchesPrefix(query.normalized, label);\n\t\t\tlet baseScore: number;\n\t\t\tif (labelPrefixMatch) {\n\t\t\t\tbaseScore = LABEL_PREFIX_SCORE_THRESHOLD;\n\n\t\t\t\t// We give another boost to labels that are short, e.g. given\n\t\t\t\t// files \"window.ts\" and \"windowActions.ts\" and a query of\n\t\t\t\t// \"window\", we want \"window.ts\" to receive a higher score.\n\t\t\t\t// As such we compute the percentage the query has within the\n\t\t\t\t// label and add that to the baseScore.\n\t\t\t\tconst prefixLengthBoost = Math.round((query.normalized.length / label.length) * 100);\n\t\t\t\tbaseScore += prefixLengthBoost;\n\t\t\t} else {\n\t\t\t\tbaseScore = LABEL_SCORE_THRESHOLD;\n\t\t\t}\n\n\t\t\treturn { score: baseScore + labelScore, labelMatch: labelPrefixMatch || createMatches(labelPositions) };\n\t\t}\n\t}\n\n\t// Finally compute description + label scores if we have a description\n\tif (description) {\n\t\tlet descriptionPrefix = description;\n\t\tif (!!path) {\n\t\t\tdescriptionPrefix = `${description}${sep}`; // assume this is a file path\n\t\t}\n\n\t\tconst descriptionPrefixLength = descriptionPrefix.length;\n\t\tconst descriptionAndLabel = `${descriptionPrefix}${label}`;\n\n\t\tconst [labelDescriptionScore, labelDescriptionPositions] = scoreFuzzy(\n\t\t\tdescriptionAndLabel,\n\t\t\tquery.normalized,\n\t\t\tquery.normalizedLowercase,\n\t\t\tallowNonContiguousMatches && !query.expectContiguousMatch);\n\t\tif (labelDescriptionScore) {\n\t\t\tconst labelDescriptionMatches = createMatches(labelDescriptionPositions);\n\t\t\tconst labelMatch: IMatch[] = [];\n\t\t\tconst descriptionMatch: IMatch[] = [];\n\n\t\t\t// We have to split the matches back onto the label and description portions\n\t\t\tlabelDescriptionMatches.forEach(h => {\n\n\t\t\t\t// Match overlaps label and description part, we need to split it up\n\t\t\t\tif (h.start < descriptionPrefixLength && h.end > descriptionPrefixLength) {\n\t\t\t\t\tlabelMatch.push({ start: 0, end: h.end - descriptionPrefixLength });\n\t\t\t\t\tdescriptionMatch.push({ start: h.start, end: descriptionPrefixLength });\n\t\t\t\t}\n\n\t\t\t\t// Match on label part\n\t\t\t\telse if (h.start >= descriptionPrefixLength) {\n\t\t\t\t\tlabelMatch.push({ start: h.start - descriptionPrefixLength, end: h.end - descriptionPrefixLength });\n\t\t\t\t}\n\n\t\t\t\t// Match on description part\n\t\t\t\telse {\n\t\t\t\t\tdescriptionMatch.push(h);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn { score: labelDescriptionScore, labelMatch, descriptionMatch };\n\t\t}\n\t}\n\n\treturn NO_ITEM_SCORE;\n}\n\nfunction createMatches(offsets: number[] | undefined): IMatch[] {\n\tconst ret: IMatch[] = [];\n\tif (!offsets) {\n\t\treturn ret;\n\t}\n\n\tlet last: IMatch | undefined;\n\tfor (const pos of offsets) {\n\t\tif (last && last.end === pos) {\n\t\t\tlast.end += 1;\n\t\t} else {\n\t\t\tlast = { start: pos, end: pos + 1 };\n\t\t\tret.push(last);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nfunction normalizeMatches(matches: IMatch[]): IMatch[] {\n\n\t// sort matches by start to be able to normalize\n\tconst sortedMatches = matches.sort((matchA, matchB) => {\n\t\treturn matchA.start - matchB.start;\n\t});\n\n\t// merge matches that overlap\n\tconst normalizedMatches: IMatch[] = [];\n\tlet currentMatch: IMatch | undefined = undefined;\n\tfor (const match of sortedMatches) {\n\n\t\t// if we have no current match or the matches\n\t\t// do not overlap, we take it as is and remember\n\t\t// it for future merging\n\t\tif (!currentMatch || !matchOverlaps(currentMatch, match)) {\n\t\t\tcurrentMatch = match;\n\t\t\tnormalizedMatches.push(match);\n\t\t}\n\n\t\t// otherwise we merge the matches\n\t\telse {\n\t\t\tcurrentMatch.start = Math.min(currentMatch.start, match.start);\n\t\t\tcurrentMatch.end = Math.max(currentMatch.end, match.end);\n\t\t}\n\t}\n\n\treturn normalizedMatches;\n}\n\nfunction matchOverlaps(matchA: IMatch, matchB: IMatch): boolean {\n\tif (matchA.end < matchB.start) {\n\t\treturn false;\t// A ends before B starts\n\t}\n\n\tif (matchB.end < matchA.start) {\n\t\treturn false; // B ends before A starts\n\t}\n\n\treturn true;\n}\n\n//#endregion\n\n\n//#region Comparers\n\nexport function compareItemsByFuzzyScore<T>(itemA: T, itemB: T, query: IPreparedQuery, allowNonContiguousMatches: boolean, accessor: IItemAccessor<T>, cache: FuzzyScorerCache): number {\n\tconst itemScoreA = scoreItemFuzzy(itemA, query, allowNonContiguousMatches, accessor, cache);\n\tconst itemScoreB = scoreItemFuzzy(itemB, query, allowNonContiguousMatches, accessor, cache);\n\n\tconst scoreA = itemScoreA.score;\n\tconst scoreB = itemScoreB.score;\n\n\t// 1.) identity matches have highest score\n\tif (scoreA === PATH_IDENTITY_SCORE || scoreB === PATH_IDENTITY_SCORE) {\n\t\tif (scoreA !== scoreB) {\n\t\t\treturn scoreA === PATH_IDENTITY_SCORE ? -1 : 1;\n\t\t}\n\t}\n\n\t// 2.) matches on label are considered higher compared to label+description matches\n\tif (scoreA > LABEL_SCORE_THRESHOLD || scoreB > LABEL_SCORE_THRESHOLD) {\n\t\tif (scoreA !== scoreB) {\n\t\t\treturn scoreA > scoreB ? -1 : 1;\n\t\t}\n\n\t\t// prefer more compact matches over longer in label (unless this is a prefix match where\n\t\t// longer prefix matches are actually preferred)\n\t\tif (scoreA < LABEL_PREFIX_SCORE_THRESHOLD && scoreB < LABEL_PREFIX_SCORE_THRESHOLD) {\n\t\t\tconst comparedByMatchLength = compareByMatchLength(itemScoreA.labelMatch, itemScoreB.labelMatch);\n\t\t\tif (comparedByMatchLength !== 0) {\n\t\t\t\treturn comparedByMatchLength;\n\t\t\t}\n\t\t}\n\n\t\t// prefer shorter labels over longer labels\n\t\tconst labelA = accessor.getItemLabel(itemA) || '';\n\t\tconst labelB = accessor.getItemLabel(itemB) || '';\n\t\tif (labelA.length !== labelB.length) {\n\t\t\treturn labelA.length - labelB.length;\n\t\t}\n\t}\n\n\t// 3.) compare by score in label+description\n\tif (scoreA !== scoreB) {\n\t\treturn scoreA > scoreB ? -1 : 1;\n\t}\n\n\t// 4.) scores are identical: prefer matches in label over non-label matches\n\tconst itemAHasLabelMatches = Array.isArray(itemScoreA.labelMatch) && itemScoreA.labelMatch.length > 0;\n\tconst itemBHasLabelMatches = Array.isArray(itemScoreB.labelMatch) && itemScoreB.labelMatch.length > 0;\n\tif (itemAHasLabelMatches && !itemBHasLabelMatches) {\n\t\treturn -1;\n\t} else if (itemBHasLabelMatches && !itemAHasLabelMatches) {\n\t\treturn 1;\n\t}\n\n\t// 5.) scores are identical: prefer more compact matches (label and description)\n\tconst itemAMatchDistance = computeLabelAndDescriptionMatchDistance(itemA, itemScoreA, accessor);\n\tconst itemBMatchDistance = computeLabelAndDescriptionMatchDistance(itemB, itemScoreB, accessor);\n\tif (itemAMatchDistance && itemBMatchDistance && itemAMatchDistance !== itemBMatchDistance) {\n\t\treturn itemBMatchDistance > itemAMatchDistance ? -1 : 1;\n\t}\n\n\t// 6.) scores are identical: start to use the fallback compare\n\treturn fallbackCompare(itemA, itemB, query, accessor);\n}\n\nfunction computeLabelAndDescriptionMatchDistance<T>(item: T, score: IItemScore, accessor: IItemAccessor<T>): number {\n\tlet matchStart: number = -1;\n\tlet matchEnd: number = -1;\n\n\t// If we have description matches, the start is first of description match\n\tif (score.descriptionMatch && score.descriptionMatch.length) {\n\t\tmatchStart = score.descriptionMatch[0].start;\n\t}\n\n\t// Otherwise, the start is the first label match\n\telse if (score.labelMatch && score.labelMatch.length) {\n\t\tmatchStart = score.labelMatch[0].start;\n\t}\n\n\t// If we have label match, the end is the last label match\n\t// If we had a description match, we add the length of the description\n\t// as offset to the end to indicate this.\n\tif (score.labelMatch && score.labelMatch.length) {\n\t\tmatchEnd = score.labelMatch[score.labelMatch.length - 1].end;\n\t\tif (score.descriptionMatch && score.descriptionMatch.length) {\n\t\t\tconst itemDescription = accessor.getItemDescription(item);\n\t\t\tif (itemDescription) {\n\t\t\t\tmatchEnd += itemDescription.length;\n\t\t\t}\n\t\t}\n\t}\n\n\t// If we have just a description match, the end is the last description match\n\telse if (score.descriptionMatch && score.descriptionMatch.length) {\n\t\tmatchEnd = score.descriptionMatch[score.descriptionMatch.length - 1].end;\n\t}\n\n\treturn matchEnd - matchStart;\n}\n\nfunction compareByMatchLength(matchesA?: IMatch[], matchesB?: IMatch[]): number {\n\tif ((!matchesA && !matchesB) || ((!matchesA || !matchesA.length) && (!matchesB || !matchesB.length))) {\n\t\treturn 0; // make sure to not cause bad comparing when matches are not provided\n\t}\n\n\tif (!matchesB || !matchesB.length) {\n\t\treturn -1;\n\t}\n\n\tif (!matchesA || !matchesA.length) {\n\t\treturn 1;\n\t}\n\n\t// Compute match length of A (first to last match)\n\tconst matchStartA = matchesA[0].start;\n\tconst matchEndA = matchesA[matchesA.length - 1].end;\n\tconst matchLengthA = matchEndA - matchStartA;\n\n\t// Compute match length of B (first to last match)\n\tconst matchStartB = matchesB[0].start;\n\tconst matchEndB = matchesB[matchesB.length - 1].end;\n\tconst matchLengthB = matchEndB - matchStartB;\n\n\t// Prefer shorter match length\n\treturn matchLengthA === matchLengthB ? 0 : matchLengthB < matchLengthA ? 1 : -1;\n}\n\nfunction fallbackCompare<T>(itemA: T, itemB: T, query: IPreparedQuery, accessor: IItemAccessor<T>): number {\n\n\t// check for label + description length and prefer shorter\n\tconst labelA = accessor.getItemLabel(itemA) || '';\n\tconst labelB = accessor.getItemLabel(itemB) || '';\n\n\tconst descriptionA = accessor.getItemDescription(itemA);\n\tconst descriptionB = accessor.getItemDescription(itemB);\n\n\tconst labelDescriptionALength = labelA.length + (descriptionA ? descriptionA.length : 0);\n\tconst labelDescriptionBLength = labelB.length + (descriptionB ? descriptionB.length : 0);\n\n\tif (labelDescriptionALength !== labelDescriptionBLength) {\n\t\treturn labelDescriptionALength - labelDescriptionBLength;\n\t}\n\n\t// check for path length and prefer shorter\n\tconst pathA = accessor.getItemPath(itemA);\n\tconst pathB = accessor.getItemPath(itemB);\n\n\tif (pathA && pathB && pathA.length !== pathB.length) {\n\t\treturn pathA.length - pathB.length;\n\t}\n\n\t// 7.) finally we have equal scores and equal length, we fallback to comparer\n\n\t// compare by label\n\tif (labelA !== labelB) {\n\t\treturn compareAnything(labelA, labelB, query.normalized);\n\t}\n\n\t// compare by description\n\tif (descriptionA && descriptionB && descriptionA !== descriptionB) {\n\t\treturn compareAnything(descriptionA, descriptionB, query.normalized);\n\t}\n\n\t// compare by path\n\tif (pathA && pathB && pathA !== pathB) {\n\t\treturn compareAnything(pathA, pathB, query.normalized);\n\t}\n\n\t// equal\n\treturn 0;\n}\n\n//#endregion\n\n\n//#region Query Normalizer\n\nexport interface IPreparedQueryPiece {\n\n\t/**\n\t * The original query as provided as input.\n\t */\n\toriginal: string;\n\toriginalLowercase: string;\n\n\t/**\n\t * Original normalized to platform separators:\n\t * - Windows: \\\n\t * - Posix: /\n\t */\n\tpathNormalized: string;\n\n\t/**\n\t * In addition to the normalized path, will have\n\t * whitespace and wildcards removed.\n\t */\n\tnormalized: string;\n\tnormalizedLowercase: string;\n\n\t/**\n\t * The query is wrapped in quotes which means\n\t * this query must be a substring of the input.\n\t * In other words, no fuzzy matching is used.\n\t */\n\texpectContiguousMatch: boolean;\n}\n\nexport interface IPreparedQuery extends IPreparedQueryPiece {\n\n\t/**\n\t * Query split by spaces into pieces.\n\t */\n\tvalues: IPreparedQueryPiece[] | undefined;\n\n\t/**\n\t * Whether the query contains path separator(s) or not.\n\t */\n\tcontainsPathSeparator: boolean;\n}\n\n/*\n * If a query is wrapped in quotes, the user does not want to\n * use fuzzy search for this query.\n */\nfunction queryExpectsExactMatch(query: string) {\n\treturn query.startsWith('\"') && query.endsWith('\"');\n}\n\n/**\n * Helper function to prepare a search value for scoring by removing unwanted characters\n * and allowing to score on multiple pieces separated by whitespace character.\n */\nconst MULTIPLE_QUERY_VALUES_SEPARATOR = ' ';\nexport function prepareQuery(original: string): IPreparedQuery {\n\tif (typeof original !== 'string') {\n\t\toriginal = '';\n\t}\n\n\tconst originalLowercase = original.toLowerCase();\n\tconst { pathNormalized, normalized, normalizedLowercase } = normalizeQuery(original);\n\tconst containsPathSeparator = pathNormalized.indexOf(sep) >= 0;\n\tconst expectExactMatch = queryExpectsExactMatch(original);\n\n\tlet values: IPreparedQueryPiece[] | undefined = undefined;\n\n\tconst originalSplit = original.split(MULTIPLE_QUERY_VALUES_SEPARATOR);\n\tif (originalSplit.length > 1) {\n\t\tfor (const originalPiece of originalSplit) {\n\t\t\tconst expectExactMatchPiece = queryExpectsExactMatch(originalPiece);\n\t\t\tconst {\n\t\t\t\tpathNormalized: pathNormalizedPiece,\n\t\t\t\tnormalized: normalizedPiece,\n\t\t\t\tnormalizedLowercase: normalizedLowercasePiece\n\t\t\t} = normalizeQuery(originalPiece);\n\n\t\t\tif (normalizedPiece) {\n\t\t\t\tif (!values) {\n\t\t\t\t\tvalues = [];\n\t\t\t\t}\n\n\t\t\t\tvalues.push({\n\t\t\t\t\toriginal: originalPiece,\n\t\t\t\t\toriginalLowercase: originalPiece.toLowerCase(),\n\t\t\t\t\tpathNormalized: pathNormalizedPiece,\n\t\t\t\t\tnormalized: normalizedPiece,\n\t\t\t\t\tnormalizedLowercase: normalizedLowercasePiece,\n\t\t\t\t\texpectContiguousMatch: expectExactMatchPiece\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { original, originalLowercase, pathNormalized, normalized, normalizedLowercase, values, containsPathSeparator, expectContiguousMatch: expectExactMatch };\n}\n\nfunction normalizeQuery(original: string): { pathNormalized: string; normalized: string; normalizedLowercase: string } {\n\tlet pathNormalized: string;\n\tif (isWindows) {\n\t\tpathNormalized = original.replace(/\\//g, sep); // Help Windows users to search for paths when using slash\n\t} else {\n\t\tpathNormalized = original.replace(/\\\\/g, sep); // Help macOS/Linux users to search for paths when using backslash\n\t}\n\n\t// we remove quotes here because quotes are used for exact match search\n\tconst normalized = stripWildcards(pathNormalized).replace(/\\s|\"/g, '');\n\n\treturn {\n\t\tpathNormalized,\n\t\tnormalized,\n\t\tnormalizedLowercase: normalized.toLowerCase()\n\t};\n}\n\nexport function pieceToQuery(piece: IPreparedQueryPiece): IPreparedQuery;\nexport function pieceToQuery(pieces: IPreparedQueryPiece[]): IPreparedQuery;\nexport function pieceToQuery(arg1: IPreparedQueryPiece | IPreparedQueryPiece[]): IPreparedQuery {\n\tif (Array.isArray(arg1)) {\n\t\treturn prepareQuery(arg1.map(piece => piece.original).join(MULTIPLE_QUERY_VALUES_SEPARATOR));\n\t}\n\n\treturn prepareQuery(arg1.original);\n}\n\n//#endregion\n"],
  "mappings": "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",
  "names": ["queryIndex", "targetIndex"]
}
