{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/fuzzyScorer.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from \"./charCode.js\";\nimport { compareAnything } from \"./comparers.js\";\nimport {\n\ttype IMatch,\n\tcreateMatches as createFuzzyMatches,\n\tfuzzyScore,\n\tisUpper,\n\tmatchesPrefix,\n} from \"./filters.js\";\nimport { hash } from \"./hash.js\";\nimport { sep } from \"./path.js\";\nimport { isLinux, isWindows } from \"./platform.js\";\nimport { equalsIgnoreCase, stripWildcards } from \"./strings.js\";\n\n//#region Fuzzy scorer\n\nexport type FuzzyScore = [number /* score */, number[] /* match positions */];\nexport type FuzzyScorerCache = { [key: string]: IItemScore };\n\nconst NO_MATCH = 0;\nconst NO_SCORE: FuzzyScore = [NO_MATCH, []];\n\n// const DEBUG = true;\n// const DEBUG_MATRIX = false;\n\nexport function scoreFuzzy(\n\ttarget: string,\n\tquery: string,\n\tqueryLower: string,\n\tallowNonContiguousMatches: boolean,\n): FuzzyScore {\n\tif (!target || !query) {\n\t\treturn NO_SCORE; // return early if target or query are undefined\n\t}\n\n\tconst targetLength = target.length;\n\tconst queryLength = query.length;\n\n\tif (targetLength < queryLength) {\n\t\treturn NO_SCORE; // impossible for query to be contained in target\n\t}\n\n\t// if (DEBUG) {\n\t// \tconsole.group(`Target: ${target}, Query: ${query}`);\n\t// }\n\n\tconst targetLower = target.toLowerCase();\n\tconst res = doScoreFuzzy(\n\t\tquery,\n\t\tqueryLower,\n\t\tqueryLength,\n\t\ttarget,\n\t\ttargetLower,\n\t\ttargetLength,\n\t\tallowNonContiguousMatches,\n\t);\n\n\t// if (DEBUG) {\n\t// \tconsole.log(`%cFinal Score: ${res[0]}`, 'font-weight: bold');\n\t// \tconsole.groupEnd();\n\t// }\n\n\treturn res;\n}\n\nfunction doScoreFuzzy(\n\tquery: string,\n\tqueryLower: string,\n\tqueryLength: number,\n\ttarget: string,\n\ttargetLower: string,\n\ttargetLength: number,\n\tallowNonContiguousMatches: boolean,\n): FuzzyScore {\n\tconst scores: number[] = [];\n\tconst matches: number[] = [];\n\n\t//\n\t// Build Scorer Matrix:\n\t//\n\t// The matrix is composed of query q and target t. For each index we score\n\t// q[i] with t[i] and compare that with the previous score. If the score is\n\t// equal or larger, we keep the match. In addition to the score, we also keep\n\t// the length of the consecutive matches to use as boost for the score.\n\t//\n\t//      t   a   r   g   e   t\n\t//  q\n\t//  u\n\t//  e\n\t//  r\n\t//  y\n\t//\n\tfor (let queryIndex = 0; queryIndex < queryLength; queryIndex++) {\n\t\tconst queryIndexOffset = queryIndex * targetLength;\n\t\tconst queryIndexPreviousOffset = queryIndexOffset - targetLength;\n\n\t\tconst queryIndexGtNull = queryIndex > 0;\n\n\t\tconst queryCharAtIndex = query[queryIndex];\n\t\tconst queryLowerCharAtIndex = queryLower[queryIndex];\n\n\t\tfor (let targetIndex = 0; targetIndex < targetLength; targetIndex++) {\n\t\t\tconst targetIndexGtNull = targetIndex > 0;\n\n\t\t\tconst currentIndex = queryIndexOffset + targetIndex;\n\t\t\tconst leftIndex = currentIndex - 1;\n\t\t\tconst diagIndex = queryIndexPreviousOffset + targetIndex - 1;\n\n\t\t\tconst leftScore = targetIndexGtNull ? scores[leftIndex] : 0;\n\t\t\tconst diagScore =\n\t\t\t\tqueryIndexGtNull && targetIndexGtNull ? scores[diagIndex] : 0;\n\n\t\t\tconst matchesSequenceLength =\n\t\t\t\tqueryIndexGtNull && targetIndexGtNull ? matches[diagIndex] : 0;\n\n\t\t\t// If we are not matching on the first query character any more, we only produce a\n\t\t\t// score if we had a score previously for the last query index (by looking at the diagScore).\n\t\t\t// This makes sure that the query always matches in sequence on the target. For example\n\t\t\t// given a target of \"ede\" and a query of \"de\", we would otherwise produce a wrong high score\n\t\t\t// for query[1] (\"e\") matching on target[0] (\"e\") because of the \"beginning of word\" boost.\n\t\t\tlet score: number;\n\t\t\tif (!diagScore && queryIndexGtNull) {\n\t\t\t\tscore = 0;\n\t\t\t} else {\n\t\t\t\tscore = computeCharScore(\n\t\t\t\t\tqueryCharAtIndex,\n\t\t\t\t\tqueryLowerCharAtIndex,\n\t\t\t\t\ttarget,\n\t\t\t\t\ttargetLower,\n\t\t\t\t\ttargetIndex,\n\t\t\t\t\tmatchesSequenceLength,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// We have a score and its equal or larger than the left score\n\t\t\t// Match: sequence continues growing from previous diag value\n\t\t\t// Score: increases by diag score value\n\t\t\tconst isValidScore = score && diagScore + score >= leftScore;\n\t\t\tif (\n\t\t\t\tisValidScore &&\n\t\t\t\t// We don't need to check if it's contiguous if we allow non-contiguous matches\n\t\t\t\t(allowNonContiguousMatches ||\n\t\t\t\t\t// We must be looking for a contiguous match.\n\t\t\t\t\t// Looking at an index higher than 0 in the query means we must have already\n\t\t\t\t\t// found out this is contiguous otherwise there wouldn't have been a score\n\t\t\t\t\tqueryIndexGtNull ||\n\t\t\t\t\t// lastly check if the query is completely contiguous at this index in the target\n\t\t\t\t\ttargetLower.startsWith(queryLower, targetIndex))\n\t\t\t) {\n\t\t\t\tmatches[currentIndex] = matchesSequenceLength + 1;\n\t\t\t\tscores[currentIndex] = diagScore + score;\n\t\t\t}\n\n\t\t\t// We either have no score or the score is lower than the left score\n\t\t\t// Match: reset to 0\n\t\t\t// Score: pick up from left hand side\n\t\t\telse {\n\t\t\t\tmatches[currentIndex] = NO_MATCH;\n\t\t\t\tscores[currentIndex] = leftScore;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Restore Positions (starting from bottom right of matrix)\n\tconst positions: number[] = [];\n\tlet queryIndex = queryLength - 1;\n\tlet targetIndex = targetLength - 1;\n\twhile (queryIndex >= 0 && targetIndex >= 0) {\n\t\tconst currentIndex = queryIndex * targetLength + targetIndex;\n\t\tconst match = matches[currentIndex];\n\t\tif (match === NO_MATCH) {\n\t\t\ttargetIndex--; // go left\n\t\t} else {\n\t\t\tpositions.push(targetIndex);\n\n\t\t\t// go up and left\n\t\t\tqueryIndex--;\n\t\t\ttargetIndex--;\n\t\t}\n\t}\n\n\t// Print matrix\n\t// if (DEBUG_MATRIX) {\n\t// \tprintMatrix(query, target, matches, scores);\n\t// }\n\n\treturn [scores[queryLength * targetLength - 1], positions.reverse()];\n}\n\nfunction computeCharScore(\n\tqueryCharAtIndex: string,\n\tqueryLowerCharAtIndex: string,\n\ttarget: string,\n\ttargetLower: string,\n\ttargetIndex: number,\n\tmatchesSequenceLength: number,\n): number {\n\tlet score = 0;\n\n\tif (!considerAsEqual(queryLowerCharAtIndex, targetLower[targetIndex])) {\n\t\treturn score; // no match of characters\n\t}\n\n\t// if (DEBUG) {\n\t// \tconsole.groupCollapsed(`%cFound a match of char: ${queryLowerCharAtIndex} at index ${targetIndex}`, 'font-weight: normal');\n\t// }\n\n\t// Character match bonus\n\tscore += 1;\n\n\t// if (DEBUG) {\n\t// \tconsole.log(`%cCharacter match bonus: +1`, 'font-weight: normal');\n\t// }\n\n\t// Consecutive match bonus\n\tif (matchesSequenceLength > 0) {\n\t\tscore += matchesSequenceLength * 5;\n\n\t\t// if (DEBUG) {\n\t\t// \tconsole.log(`Consecutive match bonus: +${matchesSequenceLength * 5}`);\n\t\t// }\n\t}\n\n\t// Same case bonus\n\tif (queryCharAtIndex === target[targetIndex]) {\n\t\tscore += 1;\n\n\t\t// if (DEBUG) {\n\t\t// \tconsole.log('Same case bonus: +1');\n\t\t// }\n\t}\n\n\t// Start of word bonus\n\tif (targetIndex === 0) {\n\t\tscore += 8;\n\n\t\t// if (DEBUG) {\n\t\t// \tconsole.log('Start of word bonus: +8');\n\t\t// }\n\t} else {\n\t\t// After separator bonus\n\t\tconst separatorBonus = scoreSeparatorAtPos(\n\t\t\ttarget.charCodeAt(targetIndex - 1),\n\t\t);\n\t\tif (separatorBonus) {\n\t\t\tscore += separatorBonus;\n\n\t\t\t// if (DEBUG) {\n\t\t\t// \tconsole.log(`After separator bonus: +${separatorBonus}`);\n\t\t\t// }\n\t\t}\n\n\t\t// Inside word upper case bonus (camel case). We only give this bonus if we're not in a contiguous sequence.\n\t\t// For example:\n\t\t// NPE => NullPointerException = boost\n\t\t// HTTP => HTTP = not boost\n\t\telse if (\n\t\t\tisUpper(target.charCodeAt(targetIndex)) &&\n\t\t\tmatchesSequenceLength === 0\n\t\t) {\n\t\t\tscore += 2;\n\n\t\t\t// if (DEBUG) {\n\t\t\t// \tconsole.log('Inside word upper case bonus: +2');\n\t\t\t// }\n\t\t}\n\t}\n\n\t// if (DEBUG) {\n\t// \tconsole.log(`Total score: ${score}`);\n\t// \tconsole.groupEnd();\n\t// }\n\n\treturn score;\n}\n\nfunction considerAsEqual(a: string, b: string): boolean {\n\tif (a === b) {\n\t\treturn true;\n\t}\n\n\t// Special case path separators: ignore platform differences\n\tif (a === \"/\" || a === \"\\\\\") {\n\t\treturn b === \"/\" || b === \"\\\\\";\n\t}\n\n\treturn false;\n}\n\nfunction scoreSeparatorAtPos(charCode: number): number {\n\tswitch (charCode) {\n\t\tcase CharCode.Slash:\n\t\tcase CharCode.Backslash:\n\t\t\treturn 5; // prefer path separators...\n\t\tcase CharCode.Underline:\n\t\tcase CharCode.Dash:\n\t\tcase CharCode.Period:\n\t\tcase CharCode.Space:\n\t\tcase CharCode.SingleQuote:\n\t\tcase CharCode.DoubleQuote:\n\t\tcase CharCode.Colon:\n\t\t\treturn 4; // ...over other separators\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n}\n\n// function printMatrix(query: string, target: string, matches: number[], scores: number[]): void {\n// \tconsole.log('\\t' + target.split('').join('\\t'));\n// \tfor (let queryIndex = 0; queryIndex < query.length; queryIndex++) {\n// \t\tlet line = query[queryIndex] + '\\t';\n// \t\tfor (let targetIndex = 0; targetIndex < target.length; targetIndex++) {\n// \t\t\tconst currentIndex = queryIndex * target.length + targetIndex;\n// \t\t\tline = line + 'M' + matches[currentIndex] + '/' + 'S' + scores[currentIndex] + '\\t';\n// \t\t}\n\n// \t\tconsole.log(line);\n// \t}\n// }\n\n//#endregion\n\n//#region Alternate fuzzy scorer implementation that is e.g. used for symbols\n\nexport type FuzzyScore2 = [number | undefined /* score */, IMatch[]];\n\nconst NO_SCORE2: FuzzyScore2 = [undefined, []];\n\nexport function scoreFuzzy2(\n\ttarget: string,\n\tquery: IPreparedQuery | IPreparedQueryPiece,\n\tpatternStart = 0,\n\twordStart = 0,\n): FuzzyScore2 {\n\t// Score: multiple inputs\n\tconst preparedQuery = query as IPreparedQuery;\n\tif (preparedQuery.values && preparedQuery.values.length > 1) {\n\t\treturn doScoreFuzzy2Multiple(\n\t\t\ttarget,\n\t\t\tpreparedQuery.values,\n\t\t\tpatternStart,\n\t\t\twordStart,\n\t\t);\n\t}\n\n\t// Score: single input\n\treturn doScoreFuzzy2Single(target, query, patternStart, wordStart);\n}\n\nfunction doScoreFuzzy2Multiple(\n\ttarget: string,\n\tquery: IPreparedQueryPiece[],\n\tpatternStart: number,\n\twordStart: number,\n): FuzzyScore2 {\n\tlet totalScore = 0;\n\tconst totalMatches: IMatch[] = [];\n\n\tfor (const queryPiece of query) {\n\t\tconst [score, matches] = doScoreFuzzy2Single(\n\t\t\ttarget,\n\t\t\tqueryPiece,\n\t\t\tpatternStart,\n\t\t\twordStart,\n\t\t);\n\t\tif (typeof score !== \"number\") {\n\t\t\t// if a single query value does not match, return with\n\t\t\t// no score entirely, we require all queries to match\n\t\t\treturn NO_SCORE2;\n\t\t}\n\n\t\ttotalScore += score;\n\t\ttotalMatches.push(...matches);\n\t}\n\n\t// if we have a score, ensure that the positions are\n\t// sorted in ascending order and distinct\n\treturn [totalScore, normalizeMatches(totalMatches)];\n}\n\nfunction doScoreFuzzy2Single(\n\ttarget: string,\n\tquery: IPreparedQueryPiece,\n\tpatternStart: number,\n\twordStart: number,\n): FuzzyScore2 {\n\tconst score = fuzzyScore(\n\t\tquery.original,\n\t\tquery.originalLowercase,\n\t\tpatternStart,\n\t\ttarget,\n\t\ttarget.toLowerCase(),\n\t\twordStart,\n\t\t{ firstMatchCanBeWeak: true, boostFullMatch: true },\n\t);\n\tif (!score) {\n\t\treturn NO_SCORE2;\n\t}\n\n\treturn [score[0], createFuzzyMatches(score)];\n}\n\n//#endregion\n\n//#region Item (label, description, path) scorer\n\n/**\n * Scoring on structural items that have a label and optional description.\n */\nexport interface IItemScore {\n\t/**\n\t * Overall score.\n\t */\n\tscore: number;\n\n\t/**\n\t * Matches within the label.\n\t */\n\tlabelMatch?: IMatch[];\n\n\t/**\n\t * Matches within the description.\n\t */\n\tdescriptionMatch?: IMatch[];\n}\n\nconst NO_ITEM_SCORE = Object.freeze<IItemScore>({ score: 0 });\n\nexport interface IItemAccessor<T> {\n\t/**\n\t * Just the label of the item to score on.\n\t */\n\tgetItemLabel(item: T): string | undefined;\n\n\t/**\n\t * The optional description of the item to score on.\n\t */\n\tgetItemDescription(item: T): string | undefined;\n\n\t/**\n\t * If the item is a file, the path of the file to score on.\n\t */\n\tgetItemPath(file: T): string | undefined;\n}\n\nconst PATH_IDENTITY_SCORE = 1 << 18;\nconst LABEL_PREFIX_SCORE_THRESHOLD = 1 << 17;\nconst LABEL_SCORE_THRESHOLD = 1 << 16;\n\nfunction getCacheHash(\n\tlabel: string,\n\tdescription: string | undefined,\n\tallowNonContiguousMatches: boolean,\n\tquery: IPreparedQuery,\n) {\n\tconst values = query.values ? query.values : [query];\n\tconst cacheHash = hash({\n\t\t[query.normalized]: {\n\t\t\tvalues: values.map((v) => ({\n\t\t\t\tvalue: v.normalized,\n\t\t\t\texpectContiguousMatch: v.expectContiguousMatch,\n\t\t\t})),\n\t\t\tlabel,\n\t\t\tdescription,\n\t\t\tallowNonContiguousMatches,\n\t\t},\n\t});\n\treturn cacheHash;\n}\n\nexport function scoreItemFuzzy<T>(\n\titem: T,\n\tquery: IPreparedQuery,\n\tallowNonContiguousMatches: boolean,\n\taccessor: IItemAccessor<T>,\n\tcache: FuzzyScorerCache,\n): IItemScore {\n\tif (!item || !query.normalized) {\n\t\treturn NO_ITEM_SCORE; // we need an item and query to score on at least\n\t}\n\n\tconst label = accessor.getItemLabel(item);\n\tif (!label) {\n\t\treturn NO_ITEM_SCORE; // we need a label at least\n\t}\n\n\tconst description = accessor.getItemDescription(item);\n\n\t// in order to speed up scoring, we cache the score with a unique hash based on:\n\t// - label\n\t// - description (if provided)\n\t// - whether non-contiguous matching is enabled or not\n\t// - hash of the query (normalized) values\n\tconst cacheHash = getCacheHash(\n\t\tlabel,\n\t\tdescription,\n\t\tallowNonContiguousMatches,\n\t\tquery,\n\t);\n\tconst cached = cache[cacheHash];\n\tif (cached) {\n\t\treturn cached;\n\t}\n\n\tconst itemScore = doScoreItemFuzzy(\n\t\tlabel,\n\t\tdescription,\n\t\taccessor.getItemPath(item),\n\t\tquery,\n\t\tallowNonContiguousMatches,\n\t);\n\tcache[cacheHash] = itemScore;\n\n\treturn itemScore;\n}\n\nfunction doScoreItemFuzzy(\n\tlabel: string,\n\tdescription: string | undefined,\n\tpath: string | undefined,\n\tquery: IPreparedQuery,\n\tallowNonContiguousMatches: boolean,\n): IItemScore {\n\tconst preferLabelMatches = !path || !query.containsPathSeparator;\n\n\t// Treat identity matches on full path highest\n\tif (\n\t\tpath &&\n\t\t(isLinux\n\t\t\t? query.pathNormalized === path\n\t\t\t: equalsIgnoreCase(query.pathNormalized, path))\n\t) {\n\t\treturn {\n\t\t\tscore: PATH_IDENTITY_SCORE,\n\t\t\tlabelMatch: [{ start: 0, end: label.length }],\n\t\t\tdescriptionMatch: description\n\t\t\t\t? [{ start: 0, end: description.length }]\n\t\t\t\t: undefined,\n\t\t};\n\t}\n\n\t// Score: multiple inputs\n\tif (query.values && query.values.length > 1) {\n\t\treturn doScoreItemFuzzyMultiple(\n\t\t\tlabel,\n\t\t\tdescription,\n\t\t\tpath,\n\t\t\tquery.values,\n\t\t\tpreferLabelMatches,\n\t\t\tallowNonContiguousMatches,\n\t\t);\n\t}\n\n\t// Score: single input\n\treturn doScoreItemFuzzySingle(\n\t\tlabel,\n\t\tdescription,\n\t\tpath,\n\t\tquery,\n\t\tpreferLabelMatches,\n\t\tallowNonContiguousMatches,\n\t);\n}\n\nfunction doScoreItemFuzzyMultiple(\n\tlabel: string,\n\tdescription: string | undefined,\n\tpath: string | undefined,\n\tquery: IPreparedQueryPiece[],\n\tpreferLabelMatches: boolean,\n\tallowNonContiguousMatches: boolean,\n): IItemScore {\n\tlet totalScore = 0;\n\tconst totalLabelMatches: IMatch[] = [];\n\tconst totalDescriptionMatches: IMatch[] = [];\n\n\tfor (const queryPiece of query) {\n\t\tconst { score, labelMatch, descriptionMatch } = doScoreItemFuzzySingle(\n\t\t\tlabel,\n\t\t\tdescription,\n\t\t\tpath,\n\t\t\tqueryPiece,\n\t\t\tpreferLabelMatches,\n\t\t\tallowNonContiguousMatches,\n\t\t);\n\t\tif (score === NO_MATCH) {\n\t\t\t// if a single query value does not match, return with\n\t\t\t// no score entirely, we require all queries to match\n\t\t\treturn NO_ITEM_SCORE;\n\t\t}\n\n\t\ttotalScore += score;\n\t\tif (labelMatch) {\n\t\t\ttotalLabelMatches.push(...labelMatch);\n\t\t}\n\n\t\tif (descriptionMatch) {\n\t\t\ttotalDescriptionMatches.push(...descriptionMatch);\n\t\t}\n\t}\n\n\t// if we have a score, ensure that the positions are\n\t// sorted in ascending order and distinct\n\treturn {\n\t\tscore: totalScore,\n\t\tlabelMatch: normalizeMatches(totalLabelMatches),\n\t\tdescriptionMatch: normalizeMatches(totalDescriptionMatches),\n\t};\n}\n\nfunction doScoreItemFuzzySingle(\n\tlabel: string,\n\tdescription: string | undefined,\n\tpath: string | undefined,\n\tquery: IPreparedQueryPiece,\n\tpreferLabelMatches: boolean,\n\tallowNonContiguousMatches: boolean,\n): IItemScore {\n\t// Prefer label matches if told so or we have no description\n\tif (preferLabelMatches || !description) {\n\t\tconst [labelScore, labelPositions] = scoreFuzzy(\n\t\t\tlabel,\n\t\t\tquery.normalized,\n\t\t\tquery.normalizedLowercase,\n\t\t\tallowNonContiguousMatches && !query.expectContiguousMatch,\n\t\t);\n\t\tif (labelScore) {\n\t\t\t// If we have a prefix match on the label, we give a much\n\t\t\t// higher baseScore to elevate these matches over others\n\t\t\t// This ensures that typing a file name wins over results\n\t\t\t// that are present somewhere in the label, but not the\n\t\t\t// beginning.\n\t\t\tconst labelPrefixMatch = matchesPrefix(query.normalized, label);\n\t\t\tlet baseScore: number;\n\t\t\tif (labelPrefixMatch) {\n\t\t\t\tbaseScore = LABEL_PREFIX_SCORE_THRESHOLD;\n\n\t\t\t\t// We give another boost to labels that are short, e.g. given\n\t\t\t\t// files \"window.ts\" and \"windowActions.ts\" and a query of\n\t\t\t\t// \"window\", we want \"window.ts\" to receive a higher score.\n\t\t\t\t// As such we compute the percentage the query has within the\n\t\t\t\t// label and add that to the baseScore.\n\t\t\t\tconst prefixLengthBoost = Math.round(\n\t\t\t\t\t(query.normalized.length / label.length) * 100,\n\t\t\t\t);\n\t\t\t\tbaseScore += prefixLengthBoost;\n\t\t\t} else {\n\t\t\t\tbaseScore = LABEL_SCORE_THRESHOLD;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tscore: baseScore + labelScore,\n\t\t\t\tlabelMatch: labelPrefixMatch || createMatches(labelPositions),\n\t\t\t};\n\t\t}\n\t}\n\n\t// Finally compute description + label scores if we have a description\n\tif (description) {\n\t\tlet descriptionPrefix = description;\n\t\tif (!!path) {\n\t\t\tdescriptionPrefix = `${description}${sep}`; // assume this is a file path\n\t\t}\n\n\t\tconst descriptionPrefixLength = descriptionPrefix.length;\n\t\tconst descriptionAndLabel = `${descriptionPrefix}${label}`;\n\n\t\tconst [labelDescriptionScore, labelDescriptionPositions] = scoreFuzzy(\n\t\t\tdescriptionAndLabel,\n\t\t\tquery.normalized,\n\t\t\tquery.normalizedLowercase,\n\t\t\tallowNonContiguousMatches && !query.expectContiguousMatch,\n\t\t);\n\t\tif (labelDescriptionScore) {\n\t\t\tconst labelDescriptionMatches = createMatches(\n\t\t\t\tlabelDescriptionPositions,\n\t\t\t);\n\t\t\tconst labelMatch: IMatch[] = [];\n\t\t\tconst descriptionMatch: IMatch[] = [];\n\n\t\t\t// We have to split the matches back onto the label and description portions\n\t\t\tlabelDescriptionMatches.forEach((h) => {\n\t\t\t\t// Match overlaps label and description part, we need to split it up\n\t\t\t\tif (\n\t\t\t\t\th.start < descriptionPrefixLength &&\n\t\t\t\t\th.end > descriptionPrefixLength\n\t\t\t\t) {\n\t\t\t\t\tlabelMatch.push({\n\t\t\t\t\t\tstart: 0,\n\t\t\t\t\t\tend: h.end - descriptionPrefixLength,\n\t\t\t\t\t});\n\t\t\t\t\tdescriptionMatch.push({\n\t\t\t\t\t\tstart: h.start,\n\t\t\t\t\t\tend: descriptionPrefixLength,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Match on label part\n\t\t\t\telse if (h.start >= descriptionPrefixLength) {\n\t\t\t\t\tlabelMatch.push({\n\t\t\t\t\t\tstart: h.start - descriptionPrefixLength,\n\t\t\t\t\t\tend: h.end - descriptionPrefixLength,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Match on description part\n\t\t\t\telse {\n\t\t\t\t\tdescriptionMatch.push(h);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tscore: labelDescriptionScore,\n\t\t\t\tlabelMatch,\n\t\t\t\tdescriptionMatch,\n\t\t\t};\n\t\t}\n\t}\n\n\treturn NO_ITEM_SCORE;\n}\n\nfunction createMatches(offsets: number[] | undefined): IMatch[] {\n\tconst ret: IMatch[] = [];\n\tif (!offsets) {\n\t\treturn ret;\n\t}\n\n\tlet last: IMatch | undefined;\n\tfor (const pos of offsets) {\n\t\tif (last && last.end === pos) {\n\t\t\tlast.end += 1;\n\t\t} else {\n\t\t\tlast = { start: pos, end: pos + 1 };\n\t\t\tret.push(last);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nfunction normalizeMatches(matches: IMatch[]): IMatch[] {\n\t// sort matches by start to be able to normalize\n\tconst sortedMatches = matches.sort((matchA, matchB) => {\n\t\treturn matchA.start - matchB.start;\n\t});\n\n\t// merge matches that overlap\n\tconst normalizedMatches: IMatch[] = [];\n\tlet currentMatch: IMatch | undefined;\n\tfor (const match of sortedMatches) {\n\t\t// if we have no current match or the matches\n\t\t// do not overlap, we take it as is and remember\n\t\t// it for future merging\n\t\tif (!currentMatch || !matchOverlaps(currentMatch, match)) {\n\t\t\tcurrentMatch = match;\n\t\t\tnormalizedMatches.push(match);\n\t\t}\n\n\t\t// otherwise we merge the matches\n\t\telse {\n\t\t\tcurrentMatch.start = Math.min(currentMatch.start, match.start);\n\t\t\tcurrentMatch.end = Math.max(currentMatch.end, match.end);\n\t\t}\n\t}\n\n\treturn normalizedMatches;\n}\n\nfunction matchOverlaps(matchA: IMatch, matchB: IMatch): boolean {\n\tif (matchA.end < matchB.start) {\n\t\treturn false; // A ends before B starts\n\t}\n\n\tif (matchB.end < matchA.start) {\n\t\treturn false; // B ends before A starts\n\t}\n\n\treturn true;\n}\n\n//#endregion\n\n//#region Comparers\n\nexport function compareItemsByFuzzyScore<T>(\n\titemA: T,\n\titemB: T,\n\tquery: IPreparedQuery,\n\tallowNonContiguousMatches: boolean,\n\taccessor: IItemAccessor<T>,\n\tcache: FuzzyScorerCache,\n): number {\n\tconst itemScoreA = scoreItemFuzzy(\n\t\titemA,\n\t\tquery,\n\t\tallowNonContiguousMatches,\n\t\taccessor,\n\t\tcache,\n\t);\n\tconst itemScoreB = scoreItemFuzzy(\n\t\titemB,\n\t\tquery,\n\t\tallowNonContiguousMatches,\n\t\taccessor,\n\t\tcache,\n\t);\n\n\tconst scoreA = itemScoreA.score;\n\tconst scoreB = itemScoreB.score;\n\n\t// 1.) identity matches have highest score\n\tif (scoreA === PATH_IDENTITY_SCORE || scoreB === PATH_IDENTITY_SCORE) {\n\t\tif (scoreA !== scoreB) {\n\t\t\treturn scoreA === PATH_IDENTITY_SCORE ? -1 : 1;\n\t\t}\n\t}\n\n\t// 2.) matches on label are considered higher compared to label+description matches\n\tif (scoreA > LABEL_SCORE_THRESHOLD || scoreB > LABEL_SCORE_THRESHOLD) {\n\t\tif (scoreA !== scoreB) {\n\t\t\treturn scoreA > scoreB ? -1 : 1;\n\t\t}\n\n\t\t// prefer more compact matches over longer in label (unless this is a prefix match where\n\t\t// longer prefix matches are actually preferred)\n\t\tif (\n\t\t\tscoreA < LABEL_PREFIX_SCORE_THRESHOLD &&\n\t\t\tscoreB < LABEL_PREFIX_SCORE_THRESHOLD\n\t\t) {\n\t\t\tconst comparedByMatchLength = compareByMatchLength(\n\t\t\t\titemScoreA.labelMatch,\n\t\t\t\titemScoreB.labelMatch,\n\t\t\t);\n\t\t\tif (comparedByMatchLength !== 0) {\n\t\t\t\treturn comparedByMatchLength;\n\t\t\t}\n\t\t}\n\n\t\t// prefer shorter labels over longer labels\n\t\tconst labelA = accessor.getItemLabel(itemA) || \"\";\n\t\tconst labelB = accessor.getItemLabel(itemB) || \"\";\n\t\tif (labelA.length !== labelB.length) {\n\t\t\treturn labelA.length - labelB.length;\n\t\t}\n\t}\n\n\t// 3.) compare by score in label+description\n\tif (scoreA !== scoreB) {\n\t\treturn scoreA > scoreB ? -1 : 1;\n\t}\n\n\t// 4.) scores are identical: prefer matches in label over non-label matches\n\tconst itemAHasLabelMatches =\n\t\tArray.isArray(itemScoreA.labelMatch) &&\n\t\titemScoreA.labelMatch.length > 0;\n\tconst itemBHasLabelMatches =\n\t\tArray.isArray(itemScoreB.labelMatch) &&\n\t\titemScoreB.labelMatch.length > 0;\n\tif (itemAHasLabelMatches && !itemBHasLabelMatches) {\n\t\treturn -1;\n\t} else if (itemBHasLabelMatches && !itemAHasLabelMatches) {\n\t\treturn 1;\n\t}\n\n\t// 5.) scores are identical: prefer more compact matches (label and description)\n\tconst itemAMatchDistance = computeLabelAndDescriptionMatchDistance(\n\t\titemA,\n\t\titemScoreA,\n\t\taccessor,\n\t);\n\tconst itemBMatchDistance = computeLabelAndDescriptionMatchDistance(\n\t\titemB,\n\t\titemScoreB,\n\t\taccessor,\n\t);\n\tif (\n\t\titemAMatchDistance &&\n\t\titemBMatchDistance &&\n\t\titemAMatchDistance !== itemBMatchDistance\n\t) {\n\t\treturn itemBMatchDistance > itemAMatchDistance ? -1 : 1;\n\t}\n\n\t// 6.) scores are identical: start to use the fallback compare\n\treturn fallbackCompare(itemA, itemB, query, accessor);\n}\n\nfunction computeLabelAndDescriptionMatchDistance<T>(\n\titem: T,\n\tscore: IItemScore,\n\taccessor: IItemAccessor<T>,\n): number {\n\tlet matchStart = -1;\n\tlet matchEnd = -1;\n\n\t// If we have description matches, the start is first of description match\n\tif (score.descriptionMatch && score.descriptionMatch.length) {\n\t\tmatchStart = score.descriptionMatch[0].start;\n\t}\n\n\t// Otherwise, the start is the first label match\n\telse if (score.labelMatch && score.labelMatch.length) {\n\t\tmatchStart = score.labelMatch[0].start;\n\t}\n\n\t// If we have label match, the end is the last label match\n\t// If we had a description match, we add the length of the description\n\t// as offset to the end to indicate this.\n\tif (score.labelMatch && score.labelMatch.length) {\n\t\tmatchEnd = score.labelMatch[score.labelMatch.length - 1].end;\n\t\tif (score.descriptionMatch && score.descriptionMatch.length) {\n\t\t\tconst itemDescription = accessor.getItemDescription(item);\n\t\t\tif (itemDescription) {\n\t\t\t\tmatchEnd += itemDescription.length;\n\t\t\t}\n\t\t}\n\t}\n\n\t// If we have just a description match, the end is the last description match\n\telse if (score.descriptionMatch && score.descriptionMatch.length) {\n\t\tmatchEnd =\n\t\t\tscore.descriptionMatch[score.descriptionMatch.length - 1].end;\n\t}\n\n\treturn matchEnd - matchStart;\n}\n\nfunction compareByMatchLength(\n\tmatchesA?: IMatch[],\n\tmatchesB?: IMatch[],\n): number {\n\tif (\n\t\t(!matchesA && !matchesB) ||\n\t\t((!matchesA || !matchesA.length) && (!matchesB || !matchesB.length))\n\t) {\n\t\treturn 0; // make sure to not cause bad comparing when matches are not provided\n\t}\n\n\tif (!matchesB || !matchesB.length) {\n\t\treturn -1;\n\t}\n\n\tif (!matchesA || !matchesA.length) {\n\t\treturn 1;\n\t}\n\n\t// Compute match length of A (first to last match)\n\tconst matchStartA = matchesA[0].start;\n\tconst matchEndA = matchesA[matchesA.length - 1].end;\n\tconst matchLengthA = matchEndA - matchStartA;\n\n\t// Compute match length of B (first to last match)\n\tconst matchStartB = matchesB[0].start;\n\tconst matchEndB = matchesB[matchesB.length - 1].end;\n\tconst matchLengthB = matchEndB - matchStartB;\n\n\t// Prefer shorter match length\n\treturn matchLengthA === matchLengthB\n\t\t? 0\n\t\t: matchLengthB < matchLengthA\n\t\t\t? 1\n\t\t\t: -1;\n}\n\nfunction fallbackCompare<T>(\n\titemA: T,\n\titemB: T,\n\tquery: IPreparedQuery,\n\taccessor: IItemAccessor<T>,\n): number {\n\t// check for label + description length and prefer shorter\n\tconst labelA = accessor.getItemLabel(itemA) || \"\";\n\tconst labelB = accessor.getItemLabel(itemB) || \"\";\n\n\tconst descriptionA = accessor.getItemDescription(itemA);\n\tconst descriptionB = accessor.getItemDescription(itemB);\n\n\tconst labelDescriptionALength =\n\t\tlabelA.length + (descriptionA ? descriptionA.length : 0);\n\tconst labelDescriptionBLength =\n\t\tlabelB.length + (descriptionB ? descriptionB.length : 0);\n\n\tif (labelDescriptionALength !== labelDescriptionBLength) {\n\t\treturn labelDescriptionALength - labelDescriptionBLength;\n\t}\n\n\t// check for path length and prefer shorter\n\tconst pathA = accessor.getItemPath(itemA);\n\tconst pathB = accessor.getItemPath(itemB);\n\n\tif (pathA && pathB && pathA.length !== pathB.length) {\n\t\treturn pathA.length - pathB.length;\n\t}\n\n\t// 7.) finally we have equal scores and equal length, we fallback to comparer\n\n\t// compare by label\n\tif (labelA !== labelB) {\n\t\treturn compareAnything(labelA, labelB, query.normalized);\n\t}\n\n\t// compare by description\n\tif (descriptionA && descriptionB && descriptionA !== descriptionB) {\n\t\treturn compareAnything(descriptionA, descriptionB, query.normalized);\n\t}\n\n\t// compare by path\n\tif (pathA && pathB && pathA !== pathB) {\n\t\treturn compareAnything(pathA, pathB, query.normalized);\n\t}\n\n\t// equal\n\treturn 0;\n}\n\n//#endregion\n\n//#region Query Normalizer\n\nexport interface IPreparedQueryPiece {\n\t/**\n\t * The original query as provided as input.\n\t */\n\toriginal: string;\n\toriginalLowercase: string;\n\n\t/**\n\t * Original normalized to platform separators:\n\t * - Windows: \\\n\t * - Posix: /\n\t */\n\tpathNormalized: string;\n\n\t/**\n\t * In addition to the normalized path, will have\n\t * whitespace and wildcards removed.\n\t */\n\tnormalized: string;\n\tnormalizedLowercase: string;\n\n\t/**\n\t * The query is wrapped in quotes which means\n\t * this query must be a substring of the input.\n\t * In other words, no fuzzy matching is used.\n\t */\n\texpectContiguousMatch: boolean;\n}\n\nexport interface IPreparedQuery extends IPreparedQueryPiece {\n\t/**\n\t * Query split by spaces into pieces.\n\t */\n\tvalues: IPreparedQueryPiece[] | undefined;\n\n\t/**\n\t * Whether the query contains path separator(s) or not.\n\t */\n\tcontainsPathSeparator: boolean;\n}\n\n/*\n * If a query is wrapped in quotes, the user does not want to\n * use fuzzy search for this query.\n */\nfunction queryExpectsExactMatch(query: string) {\n\treturn query.startsWith('\"') && query.endsWith('\"');\n}\n\n/**\n * Helper function to prepare a search value for scoring by removing unwanted characters\n * and allowing to score on multiple pieces separated by whitespace character.\n */\nconst MULTIPLE_QUERY_VALUES_SEPARATOR = \" \";\nexport function prepareQuery(original: string): IPreparedQuery {\n\tif (typeof original !== \"string\") {\n\t\toriginal = \"\";\n\t}\n\n\tconst originalLowercase = original.toLowerCase();\n\tconst { pathNormalized, normalized, normalizedLowercase } =\n\t\tnormalizeQuery(original);\n\tconst containsPathSeparator = pathNormalized.indexOf(sep) >= 0;\n\tconst expectExactMatch = queryExpectsExactMatch(original);\n\n\tlet values: IPreparedQueryPiece[] | undefined;\n\n\tconst originalSplit = original.split(MULTIPLE_QUERY_VALUES_SEPARATOR);\n\tif (originalSplit.length > 1) {\n\t\tfor (const originalPiece of originalSplit) {\n\t\t\tconst expectExactMatchPiece = queryExpectsExactMatch(originalPiece);\n\t\t\tconst {\n\t\t\t\tpathNormalized: pathNormalizedPiece,\n\t\t\t\tnormalized: normalizedPiece,\n\t\t\t\tnormalizedLowercase: normalizedLowercasePiece,\n\t\t\t} = normalizeQuery(originalPiece);\n\n\t\t\tif (normalizedPiece) {\n\t\t\t\tif (!values) {\n\t\t\t\t\tvalues = [];\n\t\t\t\t}\n\n\t\t\t\tvalues.push({\n\t\t\t\t\toriginal: originalPiece,\n\t\t\t\t\toriginalLowercase: originalPiece.toLowerCase(),\n\t\t\t\t\tpathNormalized: pathNormalizedPiece,\n\t\t\t\t\tnormalized: normalizedPiece,\n\t\t\t\t\tnormalizedLowercase: normalizedLowercasePiece,\n\t\t\t\t\texpectContiguousMatch: expectExactMatchPiece,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\toriginal,\n\t\toriginalLowercase,\n\t\tpathNormalized,\n\t\tnormalized,\n\t\tnormalizedLowercase,\n\t\tvalues,\n\t\tcontainsPathSeparator,\n\t\texpectContiguousMatch: expectExactMatch,\n\t};\n}\n\nfunction normalizeQuery(original: string): {\n\tpathNormalized: string;\n\tnormalized: string;\n\tnormalizedLowercase: string;\n} {\n\tlet pathNormalized: string;\n\tif (isWindows) {\n\t\tpathNormalized = original.replace(/\\//g, sep); // Help Windows users to search for paths when using slash\n\t} else {\n\t\tpathNormalized = original.replace(/\\\\/g, sep); // Help macOS/Linux users to search for paths when using backslash\n\t}\n\n\t// we remove quotes here because quotes are used for exact match search\n\tconst normalized = stripWildcards(pathNormalized).replace(/\\s|\"/g, \"\");\n\n\treturn {\n\t\tpathNormalized,\n\t\tnormalized,\n\t\tnormalizedLowercase: normalized.toLowerCase(),\n\t};\n}\n\nexport function pieceToQuery(piece: IPreparedQueryPiece): IPreparedQuery;\nexport function pieceToQuery(pieces: IPreparedQueryPiece[]): IPreparedQuery;\nexport function pieceToQuery(\n\targ1: IPreparedQueryPiece | IPreparedQueryPiece[],\n): IPreparedQuery {\n\tif (Array.isArray(arg1)) {\n\t\treturn prepareQuery(\n\t\t\targ1\n\t\t\t\t.map((piece) => piece.original)\n\t\t\t\t.join(MULTIPLE_QUERY_VALUES_SEPARATOR),\n\t\t);\n\t}\n\n\treturn prepareQuery(arg1.original);\n}\n\n//#endregion\n"],
  "mappings": "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",
  "names": ["queryIndex", "targetIndex"]
}
