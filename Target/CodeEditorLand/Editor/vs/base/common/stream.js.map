{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/stream.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { CancellationToken } from \"./cancellation.js\";\nimport { onUnexpectedError } from \"./errors.js\";\nimport { DisposableStore, toDisposable } from \"./lifecycle.js\";\n\n/**\n * The payload that flows in readable stream events.\n */\nexport type ReadableStreamEventPayload<T> = T | Error | \"end\";\n\nexport interface ReadableStreamEvents<T> {\n\t/**\n\t * The 'data' event is emitted whenever the stream is\n\t * relinquishing ownership of a chunk of data to a consumer.\n\t *\n\t * NOTE: PLEASE UNDERSTAND THAT ADDING A DATA LISTENER CAN\n\t * TURN THE STREAM INTO FLOWING MODE. IT IS THEREFOR THE\n\t * LAST LISTENER THAT SHOULD BE ADDED AND NOT THE FIRST\n\t *\n\t * Use `listenStream` as a helper method to listen to\n\t * stream events in the right order.\n\t */\n\ton(event: \"data\", callback: (data: T) => void): void;\n\n\t/**\n\t * Emitted when any error occurs.\n\t */\n\ton(event: \"error\", callback: (err: Error) => void): void;\n\n\t/**\n\t * The 'end' event is emitted when there is no more data\n\t * to be consumed from the stream. The 'end' event will\n\t * not be emitted unless the data is completely consumed.\n\t */\n\ton(event: \"end\", callback: () => void): void;\n}\n\n/**\n * A interface that emulates the API shape of a node.js readable\n * stream for use in native and web environments.\n */\nexport interface ReadableStream<T> extends ReadableStreamEvents<T> {\n\t/**\n\t * Stops emitting any events until resume() is called.\n\t */\n\tpause(): void;\n\n\t/**\n\t * Starts emitting events again after pause() was called.\n\t */\n\tresume(): void;\n\n\t/**\n\t * Destroys the stream and stops emitting any event.\n\t */\n\tdestroy(): void;\n\n\t/**\n\t * Allows to remove a listener that was previously added.\n\t */\n\tremoveListener(event: string, callback: Function): void;\n}\n\n/**\n * A interface that emulates the API shape of a node.js readable\n * for use in native and web environments.\n */\nexport interface Readable<T> {\n\t/**\n\t * Read data from the underlying source. Will return\n\t * null to indicate that no more data can be read.\n\t */\n\tread(): T | null;\n}\n\nexport function isReadable<T>(obj: unknown): obj is Readable<T> {\n\tconst candidate = obj as Readable<T> | undefined;\n\tif (!candidate) {\n\t\treturn false;\n\t}\n\n\treturn typeof candidate.read === \"function\";\n}\n\n/**\n * A interface that emulates the API shape of a node.js writeable\n * stream for use in native and web environments.\n */\nexport interface WriteableStream<T> extends ReadableStream<T> {\n\t/**\n\t * Writing data to the stream will trigger the on('data')\n\t * event listener if the stream is flowing and buffer the\n\t * data otherwise until the stream is flowing.\n\t *\n\t * If a `highWaterMark` is configured and writing to the\n\t * stream reaches this mark, a promise will be returned\n\t * that should be awaited on before writing more data.\n\t * Otherwise there is a risk of buffering a large number\n\t * of data chunks without consumer.\n\t */\n\twrite(data: T): void | Promise<void>;\n\n\t/**\n\t * Signals an error to the consumer of the stream via the\n\t * on('error') handler if the stream is flowing.\n\t *\n\t * NOTE: call `end` to signal that the stream has ended,\n\t * this DOES NOT happen automatically from `error`.\n\t */\n\terror(error: Error): void;\n\n\t/**\n\t * Signals the end of the stream to the consumer. If the\n\t * result is provided, will trigger the on('data') event\n\t * listener if the stream is flowing and buffer the data\n\t * otherwise until the stream is flowing.\n\t */\n\tend(result?: T): void;\n}\n\n/**\n * A stream that has a buffer already read. Returns the original stream\n * that was read as well as the chunks that got read.\n *\n * The `ended` flag indicates if the stream has been fully consumed.\n */\nexport interface ReadableBufferedStream<T> {\n\t/**\n\t * The original stream that is being read.\n\t */\n\tstream: ReadableStream<T>;\n\n\t/**\n\t * An array of chunks already read from this stream.\n\t */\n\tbuffer: T[];\n\n\t/**\n\t * Signals if the stream has ended or not. If not, consumers\n\t * should continue to read from the stream until consumed.\n\t */\n\tended: boolean;\n}\n\nexport function isReadableStream<T>(obj: unknown): obj is ReadableStream<T> {\n\tconst candidate = obj as ReadableStream<T> | undefined;\n\tif (!candidate) {\n\t\treturn false;\n\t}\n\n\treturn [\n\t\tcandidate.on,\n\t\tcandidate.pause,\n\t\tcandidate.resume,\n\t\tcandidate.destroy,\n\t].every((fn) => typeof fn === \"function\");\n}\n\nexport function isReadableBufferedStream<T>(\n\tobj: unknown,\n): obj is ReadableBufferedStream<T> {\n\tconst candidate = obj as ReadableBufferedStream<T> | undefined;\n\tif (!candidate) {\n\t\treturn false;\n\t}\n\n\treturn (\n\t\tisReadableStream(candidate.stream) &&\n\t\tArray.isArray(candidate.buffer) &&\n\t\ttypeof candidate.ended === \"boolean\"\n\t);\n}\n\nexport interface IReducer<T, R = T> {\n\t(data: T[]): R;\n}\n\nexport interface IDataTransformer<Original, Transformed> {\n\t(data: Original): Transformed;\n}\n\nexport interface IErrorTransformer {\n\t(error: Error): Error;\n}\n\nexport interface ITransformer<Original, Transformed> {\n\tdata: IDataTransformer<Original, Transformed>;\n\terror?: IErrorTransformer;\n}\n\nexport function newWriteableStream<T>(\n\treducer: IReducer<T>,\n\toptions?: WriteableStreamOptions,\n): WriteableStream<T> {\n\treturn new WriteableStreamImpl<T>(reducer, options);\n}\n\nexport interface WriteableStreamOptions {\n\t/**\n\t * The number of objects to buffer before WriteableStream#write()\n\t * signals back that the buffer is full. Can be used to reduce\n\t * the memory pressure when the stream is not flowing.\n\t */\n\thighWaterMark?: number;\n}\n\nclass WriteableStreamImpl<T> implements WriteableStream<T> {\n\tprivate readonly state = {\n\t\tflowing: false,\n\t\tended: false,\n\t\tdestroyed: false,\n\t};\n\n\tprivate readonly buffer = {\n\t\tdata: [] as T[],\n\t\terror: [] as Error[],\n\t};\n\n\tprivate readonly listeners = {\n\t\tdata: [] as { (data: T): void }[],\n\t\terror: [] as { (error: Error): void }[],\n\t\tend: [] as { (): void }[],\n\t};\n\n\tprivate readonly pendingWritePromises: Function[] = [];\n\n\tconstructor(\n\t\tprivate reducer: IReducer<T>,\n\t\tprivate options?: WriteableStreamOptions,\n\t) {}\n\n\tpause(): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.state.flowing = false;\n\t}\n\n\tresume(): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.state.flowing) {\n\t\t\tthis.state.flowing = true;\n\n\t\t\t// emit buffered events\n\t\t\tthis.flowData();\n\t\t\tthis.flowErrors();\n\t\t\tthis.flowEnd();\n\t\t}\n\t}\n\n\twrite(data: T): void | Promise<void> {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// flowing: directly send the data to listeners\n\t\tif (this.state.flowing) {\n\t\t\tthis.emitData(data);\n\t\t}\n\n\t\t// not yet flowing: buffer data until flowing\n\t\telse {\n\t\t\tthis.buffer.data.push(data);\n\n\t\t\t// highWaterMark: if configured, signal back when buffer reached limits\n\t\t\tif (\n\t\t\t\ttypeof this.options?.highWaterMark === \"number\" &&\n\t\t\t\tthis.buffer.data.length > this.options.highWaterMark\n\t\t\t) {\n\t\t\t\treturn new Promise((resolve) =>\n\t\t\t\t\tthis.pendingWritePromises.push(resolve),\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\terror(error: Error): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// flowing: directly send the error to listeners\n\t\tif (this.state.flowing) {\n\t\t\tthis.emitError(error);\n\t\t}\n\n\t\t// not yet flowing: buffer errors until flowing\n\t\telse {\n\t\t\tthis.buffer.error.push(error);\n\t\t}\n\t}\n\n\tend(result?: T): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// end with data if provided\n\t\tif (typeof result !== \"undefined\") {\n\t\t\tthis.write(result);\n\t\t}\n\n\t\t// flowing: send end event to listeners\n\t\tif (this.state.flowing) {\n\t\t\tthis.emitEnd();\n\n\t\t\tthis.destroy();\n\t\t}\n\n\t\t// not yet flowing: remember state\n\t\telse {\n\t\t\tthis.state.ended = true;\n\t\t}\n\t}\n\n\tprivate emitData(data: T): void {\n\t\tthis.listeners.data.slice(0).forEach((listener) => listener(data)); // slice to avoid listener mutation from delivering event\n\t}\n\n\tprivate emitError(error: Error): void {\n\t\tif (this.listeners.error.length === 0) {\n\t\t\tonUnexpectedError(error); // nobody listened to this error so we log it as unexpected\n\t\t} else {\n\t\t\tthis.listeners.error\n\t\t\t\t.slice(0)\n\t\t\t\t.forEach((listener) => listener(error)); // slice to avoid listener mutation from delivering event\n\t\t}\n\t}\n\n\tprivate emitEnd(): void {\n\t\tthis.listeners.end.slice(0).forEach((listener) => listener()); // slice to avoid listener mutation from delivering event\n\t}\n\n\ton(event: \"data\", callback: (data: T) => void): void;\n\ton(event: \"error\", callback: (err: Error) => void): void;\n\ton(event: \"end\", callback: () => void): void;\n\ton(event: \"data\" | \"error\" | \"end\", callback: (arg0?: any) => void): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (event) {\n\t\t\tcase \"data\":\n\t\t\t\tthis.listeners.data.push(callback);\n\n\t\t\t\t// switch into flowing mode as soon as the first 'data'\n\t\t\t\t// listener is added and we are not yet in flowing mode\n\t\t\t\tthis.resume();\n\n\t\t\t\tbreak;\n\n\t\t\tcase \"end\":\n\t\t\t\tthis.listeners.end.push(callback);\n\n\t\t\t\t// emit 'end' event directly if we are flowing\n\t\t\t\t// and the end has already been reached\n\t\t\t\t//\n\t\t\t\t// finish() when it went through\n\t\t\t\tif (this.state.flowing && this.flowEnd()) {\n\t\t\t\t\tthis.destroy();\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase \"error\":\n\t\t\t\tthis.listeners.error.push(callback);\n\n\t\t\t\t// emit buffered 'error' events unless done already\n\t\t\t\t// now that we know that we have at least one listener\n\t\t\t\tif (this.state.flowing) {\n\t\t\t\t\tthis.flowErrors();\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tremoveListener(event: string, callback: Function): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet listeners: unknown[] | undefined;\n\n\t\tswitch (event) {\n\t\t\tcase \"data\":\n\t\t\t\tlisteners = this.listeners.data;\n\t\t\t\tbreak;\n\n\t\t\tcase \"end\":\n\t\t\t\tlisteners = this.listeners.end;\n\t\t\t\tbreak;\n\n\t\t\tcase \"error\":\n\t\t\t\tlisteners = this.listeners.error;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (listeners) {\n\t\t\tconst index = listeners.indexOf(callback);\n\t\t\tif (index >= 0) {\n\t\t\t\tlisteners.splice(index, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate flowData(): void {\n\t\tif (this.buffer.data.length > 0) {\n\t\t\tconst fullDataBuffer = this.reducer(this.buffer.data);\n\n\t\t\tthis.emitData(fullDataBuffer);\n\n\t\t\tthis.buffer.data.length = 0;\n\n\t\t\t// When the buffer is empty, resolve all pending writers\n\t\t\tconst pendingWritePromises = [...this.pendingWritePromises];\n\t\t\tthis.pendingWritePromises.length = 0;\n\t\t\tpendingWritePromises.forEach((pendingWritePromise) =>\n\t\t\t\tpendingWritePromise(),\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate flowErrors(): void {\n\t\tif (this.listeners.error.length > 0) {\n\t\t\tfor (const error of this.buffer.error) {\n\t\t\t\tthis.emitError(error);\n\t\t\t}\n\n\t\t\tthis.buffer.error.length = 0;\n\t\t}\n\t}\n\n\tprivate flowEnd(): boolean {\n\t\tif (this.state.ended) {\n\t\t\tthis.emitEnd();\n\n\t\t\treturn this.listeners.end.length > 0;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tdestroy(): void {\n\t\tif (!this.state.destroyed) {\n\t\t\tthis.state.destroyed = true;\n\t\t\tthis.state.ended = true;\n\n\t\t\tthis.buffer.data.length = 0;\n\t\t\tthis.buffer.error.length = 0;\n\n\t\t\tthis.listeners.data.length = 0;\n\t\t\tthis.listeners.error.length = 0;\n\t\t\tthis.listeners.end.length = 0;\n\n\t\t\tthis.pendingWritePromises.length = 0;\n\t\t}\n\t}\n}\n\n/**\n * Helper to fully read a T readable into a T.\n */\nexport function consumeReadable<T>(\n\treadable: Readable<T>,\n\treducer: IReducer<T>,\n): T {\n\tconst chunks: T[] = [];\n\n\tlet chunk: T | null;\n\twhile ((chunk = readable.read()) !== null) {\n\t\tchunks.push(chunk);\n\t}\n\n\treturn reducer(chunks);\n}\n\n/**\n * Helper to read a T readable up to a maximum of chunks. If the limit is\n * reached, will return a readable instead to ensure all data can still\n * be read.\n */\nexport function peekReadable<T>(\n\treadable: Readable<T>,\n\treducer: IReducer<T>,\n\tmaxChunks: number,\n): T | Readable<T> {\n\tconst chunks: T[] = [];\n\n\tlet chunk: T | null | undefined;\n\twhile ((chunk = readable.read()) !== null && chunks.length < maxChunks) {\n\t\tchunks.push(chunk);\n\t}\n\n\t// If the last chunk is null, it means we reached the end of\n\t// the readable and return all the data at once\n\tif (chunk === null && chunks.length > 0) {\n\t\treturn reducer(chunks);\n\t}\n\n\t// Otherwise, we still have a chunk, it means we reached the maxChunks\n\t// value and as such we return a new Readable that first returns\n\t// the existing read chunks and then continues with reading from\n\t// the underlying readable.\n\treturn {\n\t\tread: () => {\n\t\t\t// First consume chunks from our array\n\t\t\tif (chunks.length > 0) {\n\t\t\t\treturn chunks.shift()!;\n\t\t\t}\n\n\t\t\t// Then ensure to return our last read chunk\n\t\t\tif (typeof chunk !== \"undefined\") {\n\t\t\t\tconst lastReadChunk = chunk;\n\n\t\t\t\t// explicitly use undefined here to indicate that we consumed\n\t\t\t\t// the chunk, which could have either been null or valued.\n\t\t\t\tchunk = undefined;\n\n\t\t\t\treturn lastReadChunk;\n\t\t\t}\n\n\t\t\t// Finally delegate back to the Readable\n\t\t\treturn readable.read();\n\t\t},\n\t};\n}\n\n/**\n * Helper to fully read a T stream into a T or consuming\n * a stream fully, awaiting all the events without caring\n * about the data.\n */\nexport function consumeStream<T, R = T>(\n\tstream: ReadableStreamEvents<T>,\n\treducer: IReducer<T, R>,\n): Promise<R>;\nexport function consumeStream(\n\tstream: ReadableStreamEvents<unknown>,\n): Promise<undefined>;\nexport function consumeStream<T, R = T>(\n\tstream: ReadableStreamEvents<T>,\n\treducer?: IReducer<T, R>,\n): Promise<R | undefined> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst chunks: T[] = [];\n\n\t\tlistenStream(stream, {\n\t\t\tonData: (chunk) => {\n\t\t\t\tif (reducer) {\n\t\t\t\t\tchunks.push(chunk);\n\t\t\t\t}\n\t\t\t},\n\t\t\tonError: (error) => {\n\t\t\t\tif (reducer) {\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(undefined);\n\t\t\t\t}\n\t\t\t},\n\t\t\tonEnd: () => {\n\t\t\t\tif (reducer) {\n\t\t\t\t\tresolve(reducer(chunks));\n\t\t\t\t} else {\n\t\t\t\t\tresolve(undefined);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t});\n}\n\nexport interface IStreamListener<T> {\n\t/**\n\t * The 'data' event is emitted whenever the stream is\n\t * relinquishing ownership of a chunk of data to a consumer.\n\t */\n\tonData(data: T): void;\n\n\t/**\n\t * Emitted when any error occurs.\n\t */\n\tonError(err: Error): void;\n\n\t/**\n\t * The 'end' event is emitted when there is no more data\n\t * to be consumed from the stream. The 'end' event will\n\t * not be emitted unless the data is completely consumed.\n\t */\n\tonEnd(): void;\n}\n\n/**\n * Helper to listen to all events of a T stream in proper order.\n */\nexport function listenStream<T>(\n\tstream: ReadableStreamEvents<T>,\n\tlistener: IStreamListener<T>,\n\ttoken?: CancellationToken,\n): void {\n\tstream.on(\"error\", (error) => {\n\t\tif (!token?.isCancellationRequested) {\n\t\t\tlistener.onError(error);\n\t\t}\n\t});\n\n\tstream.on(\"end\", () => {\n\t\tif (!token?.isCancellationRequested) {\n\t\t\tlistener.onEnd();\n\t\t}\n\t});\n\n\t// Adding the `data` listener will turn the stream\n\t// into flowing mode. As such it is important to\n\t// add this listener last (DO NOT CHANGE!)\n\tstream.on(\"data\", (data) => {\n\t\tif (!token?.isCancellationRequested) {\n\t\t\tlistener.onData(data);\n\t\t}\n\t});\n}\n\n/**\n * Helper to peek up to `maxChunks` into a stream. The return type signals if\n * the stream has ended or not. If not, caller needs to add a `data` listener\n * to continue reading.\n */\nexport function peekStream<T>(\n\tstream: ReadableStream<T>,\n\tmaxChunks: number,\n): Promise<ReadableBufferedStream<T>> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst streamListeners = new DisposableStore();\n\t\tconst buffer: T[] = [];\n\n\t\t// Data Listener\n\t\tconst dataListener = (chunk: T) => {\n\t\t\t// Add to buffer\n\t\t\tbuffer.push(chunk);\n\n\t\t\t// We reached maxChunks and thus need to return\n\t\t\tif (buffer.length > maxChunks) {\n\t\t\t\t// Dispose any listeners and ensure to pause the\n\t\t\t\t// stream so that it can be consumed again by caller\n\t\t\t\tstreamListeners.dispose();\n\t\t\t\tstream.pause();\n\n\t\t\t\treturn resolve({ stream, buffer, ended: false });\n\t\t\t}\n\t\t};\n\n\t\t// Error Listener\n\t\tconst errorListener = (error: Error) => {\n\t\t\tstreamListeners.dispose();\n\n\t\t\treturn reject(error);\n\t\t};\n\n\t\t// End Listener\n\t\tconst endListener = () => {\n\t\t\tstreamListeners.dispose();\n\n\t\t\treturn resolve({ stream, buffer, ended: true });\n\t\t};\n\n\t\tstreamListeners.add(\n\t\t\ttoDisposable(() => stream.removeListener(\"error\", errorListener)),\n\t\t);\n\t\tstream.on(\"error\", errorListener);\n\n\t\tstreamListeners.add(\n\t\t\ttoDisposable(() => stream.removeListener(\"end\", endListener)),\n\t\t);\n\t\tstream.on(\"end\", endListener);\n\n\t\t// Important: leave the `data` listener last because\n\t\t// this can turn the stream into flowing mode and we\n\t\t// want `error` events to be received as well.\n\t\tstreamListeners.add(\n\t\t\ttoDisposable(() => stream.removeListener(\"data\", dataListener)),\n\t\t);\n\t\tstream.on(\"data\", dataListener);\n\t});\n}\n\n/**\n * Helper to create a readable stream from an existing T.\n */\nexport function toStream<T>(t: T, reducer: IReducer<T>): ReadableStream<T> {\n\tconst stream = newWriteableStream<T>(reducer);\n\n\tstream.end(t);\n\n\treturn stream;\n}\n\n/**\n * Helper to create an empty stream\n */\nexport function emptyStream(): ReadableStream<never> {\n\tconst stream = newWriteableStream<never>(() => {\n\t\tthrow new Error(\"not supported\");\n\t});\n\tstream.end();\n\n\treturn stream;\n}\n\n/**\n * Helper to convert a T into a Readable<T>.\n */\nexport function toReadable<T>(t: T): Readable<T> {\n\tlet consumed = false;\n\n\treturn {\n\t\tread: () => {\n\t\t\tif (consumed) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconsumed = true;\n\n\t\t\treturn t;\n\t\t},\n\t};\n}\n\n/**\n * Helper to transform a readable stream into another stream.\n */\nexport function transform<Original, Transformed>(\n\tstream: ReadableStreamEvents<Original>,\n\ttransformer: ITransformer<Original, Transformed>,\n\treducer: IReducer<Transformed>,\n): ReadableStream<Transformed> {\n\tconst target = newWriteableStream<Transformed>(reducer);\n\n\tlistenStream(stream, {\n\t\tonData: (data) => target.write(transformer.data(data)),\n\t\tonError: (error) =>\n\t\t\ttarget.error(transformer.error ? transformer.error(error) : error),\n\t\tonEnd: () => target.end(),\n\t});\n\n\treturn target;\n}\n\n/**\n * Helper to take an existing readable that will\n * have a prefix injected to the beginning.\n */\nexport function prefixedReadable<T>(\n\tprefix: T,\n\treadable: Readable<T>,\n\treducer: IReducer<T>,\n): Readable<T> {\n\tlet prefixHandled = false;\n\n\treturn {\n\t\tread: () => {\n\t\t\tconst chunk = readable.read();\n\n\t\t\t// Handle prefix only once\n\t\t\tif (!prefixHandled) {\n\t\t\t\tprefixHandled = true;\n\n\t\t\t\t// If we have also a read-result, make\n\t\t\t\t// sure to reduce it to a single result\n\t\t\t\tif (chunk !== null) {\n\t\t\t\t\treturn reducer([prefix, chunk]);\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, just return prefix directly\n\t\t\t\treturn prefix;\n\t\t\t}\n\n\t\t\treturn chunk;\n\t\t},\n\t};\n}\n\n/**\n * Helper to take an existing stream that will\n * have a prefix injected to the beginning.\n */\nexport function prefixedStream<T>(\n\tprefix: T,\n\tstream: ReadableStream<T>,\n\treducer: IReducer<T>,\n): ReadableStream<T> {\n\tlet prefixHandled = false;\n\n\tconst target = newWriteableStream<T>(reducer);\n\n\tlistenStream(stream, {\n\t\tonData: (data) => {\n\t\t\t// Handle prefix only once\n\t\t\tif (!prefixHandled) {\n\t\t\t\tprefixHandled = true;\n\n\t\t\t\treturn target.write(reducer([prefix, data]));\n\t\t\t}\n\n\t\t\treturn target.write(data);\n\t\t},\n\t\tonError: (error) => target.error(error),\n\t\tonEnd: () => {\n\t\t\t// Handle prefix only once\n\t\t\tif (!prefixHandled) {\n\t\t\t\tprefixHandled = true;\n\n\t\t\t\ttarget.write(prefix);\n\t\t\t}\n\n\t\t\ttarget.end();\n\t\t},\n\t});\n\n\treturn target;\n}\n"],
  "mappings": "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",
  "names": []
}
