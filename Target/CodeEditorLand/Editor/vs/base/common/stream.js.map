{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/stream.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from './cancellation.js';\nimport { onUnexpectedError } from './errors.js';\nimport { DisposableStore, toDisposable } from './lifecycle.js';\n\n/**\n * The payload that flows in readable stream events.\n */\nexport type ReadableStreamEventPayload<T> = T | Error | 'end';\n\nexport interface ReadableStreamEvents<T> {\n\n\t/**\n\t * The 'data' event is emitted whenever the stream is\n\t * relinquishing ownership of a chunk of data to a consumer.\n\t *\n\t * NOTE: PLEASE UNDERSTAND THAT ADDING A DATA LISTENER CAN\n\t * TURN THE STREAM INTO FLOWING MODE. IT IS THEREFOR THE\n\t * LAST LISTENER THAT SHOULD BE ADDED AND NOT THE FIRST\n\t *\n\t * Use `listenStream` as a helper method to listen to\n\t * stream events in the right order.\n\t */\n\ton(event: 'data', callback: (data: T) => void): void;\n\n\t/**\n\t * Emitted when any error occurs.\n\t */\n\ton(event: 'error', callback: (err: Error) => void): void;\n\n\t/**\n\t * The 'end' event is emitted when there is no more data\n\t * to be consumed from the stream. The 'end' event will\n\t * not be emitted unless the data is completely consumed.\n\t */\n\ton(event: 'end', callback: () => void): void;\n}\n\n/**\n * A interface that emulates the API shape of a node.js readable\n * stream for use in native and web environments.\n */\nexport interface ReadableStream<T> extends ReadableStreamEvents<T> {\n\n\t/**\n\t * Stops emitting any events until resume() is called.\n\t */\n\tpause(): void;\n\n\t/**\n\t * Starts emitting events again after pause() was called.\n\t */\n\tresume(): void;\n\n\t/**\n\t * Destroys the stream and stops emitting any event.\n\t */\n\tdestroy(): void;\n\n\t/**\n\t * Allows to remove a listener that was previously added.\n\t */\n\tremoveListener(event: string, callback: Function): void;\n}\n\n/**\n * A interface that emulates the API shape of a node.js readable\n * for use in native and web environments.\n */\nexport interface Readable<T> {\n\n\t/**\n\t * Read data from the underlying source. Will return\n\t * null to indicate that no more data can be read.\n\t */\n\tread(): T | null;\n}\n\nexport function isReadable<T>(obj: unknown): obj is Readable<T> {\n\tconst candidate = obj as Readable<T> | undefined;\n\tif (!candidate) {\n\t\treturn false;\n\t}\n\n\treturn typeof candidate.read === 'function';\n}\n\n/**\n * A interface that emulates the API shape of a node.js writeable\n * stream for use in native and web environments.\n */\nexport interface WriteableStream<T> extends ReadableStream<T> {\n\n\t/**\n\t * Writing data to the stream will trigger the on('data')\n\t * event listener if the stream is flowing and buffer the\n\t * data otherwise until the stream is flowing.\n\t *\n\t * If a `highWaterMark` is configured and writing to the\n\t * stream reaches this mark, a promise will be returned\n\t * that should be awaited on before writing more data.\n\t * Otherwise there is a risk of buffering a large number\n\t * of data chunks without consumer.\n\t */\n\twrite(data: T): void | Promise<void>;\n\n\t/**\n\t * Signals an error to the consumer of the stream via the\n\t * on('error') handler if the stream is flowing.\n\t *\n\t * NOTE: call `end` to signal that the stream has ended,\n\t * this DOES NOT happen automatically from `error`.\n\t */\n\terror(error: Error): void;\n\n\t/**\n\t * Signals the end of the stream to the consumer. If the\n\t * result is provided, will trigger the on('data') event\n\t * listener if the stream is flowing and buffer the data\n\t * otherwise until the stream is flowing.\n\t */\n\tend(result?: T): void;\n}\n\n/**\n * A stream that has a buffer already read. Returns the original stream\n * that was read as well as the chunks that got read.\n *\n * The `ended` flag indicates if the stream has been fully consumed.\n */\nexport interface ReadableBufferedStream<T> {\n\n\t/**\n\t * The original stream that is being read.\n\t */\n\tstream: ReadableStream<T>;\n\n\t/**\n\t * An array of chunks already read from this stream.\n\t */\n\tbuffer: T[];\n\n\t/**\n\t * Signals if the stream has ended or not. If not, consumers\n\t * should continue to read from the stream until consumed.\n\t */\n\tended: boolean;\n}\n\nexport function isReadableStream<T>(obj: unknown): obj is ReadableStream<T> {\n\tconst candidate = obj as ReadableStream<T> | undefined;\n\tif (!candidate) {\n\t\treturn false;\n\t}\n\n\treturn [candidate.on, candidate.pause, candidate.resume, candidate.destroy].every(fn => typeof fn === 'function');\n}\n\nexport function isReadableBufferedStream<T>(obj: unknown): obj is ReadableBufferedStream<T> {\n\tconst candidate = obj as ReadableBufferedStream<T> | undefined;\n\tif (!candidate) {\n\t\treturn false;\n\t}\n\n\treturn isReadableStream(candidate.stream) && Array.isArray(candidate.buffer) && typeof candidate.ended === 'boolean';\n}\n\nexport interface IReducer<T, R = T> {\n\t(data: T[]): R;\n}\n\nexport interface IDataTransformer<Original, Transformed> {\n\t(data: Original): Transformed;\n}\n\nexport interface IErrorTransformer {\n\t(error: Error): Error;\n}\n\nexport interface ITransformer<Original, Transformed> {\n\tdata: IDataTransformer<Original, Transformed>;\n\terror?: IErrorTransformer;\n}\n\nexport function newWriteableStream<T>(reducer: IReducer<T>, options?: WriteableStreamOptions): WriteableStream<T> {\n\treturn new WriteableStreamImpl<T>(reducer, options);\n}\n\nexport interface WriteableStreamOptions {\n\n\t/**\n\t * The number of objects to buffer before WriteableStream#write()\n\t * signals back that the buffer is full. Can be used to reduce\n\t * the memory pressure when the stream is not flowing.\n\t */\n\thighWaterMark?: number;\n}\n\nclass WriteableStreamImpl<T> implements WriteableStream<T> {\n\n\tprivate readonly state = {\n\t\tflowing: false,\n\t\tended: false,\n\t\tdestroyed: false\n\t};\n\n\tprivate readonly buffer = {\n\t\tdata: [] as T[],\n\t\terror: [] as Error[]\n\t};\n\n\tprivate readonly listeners = {\n\t\tdata: [] as { (data: T): void }[],\n\t\terror: [] as { (error: Error): void }[],\n\t\tend: [] as { (): void }[]\n\t};\n\n\tprivate readonly pendingWritePromises: Function[] = [];\n\n\tconstructor(private reducer: IReducer<T>, private options?: WriteableStreamOptions) { }\n\n\tpause(): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.state.flowing = false;\n\t}\n\n\tresume(): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.state.flowing) {\n\t\t\tthis.state.flowing = true;\n\n\t\t\t// emit buffered events\n\t\t\tthis.flowData();\n\t\t\tthis.flowErrors();\n\t\t\tthis.flowEnd();\n\t\t}\n\t}\n\n\twrite(data: T): void | Promise<void> {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// flowing: directly send the data to listeners\n\t\tif (this.state.flowing) {\n\t\t\tthis.emitData(data);\n\t\t}\n\n\t\t// not yet flowing: buffer data until flowing\n\t\telse {\n\t\t\tthis.buffer.data.push(data);\n\n\t\t\t// highWaterMark: if configured, signal back when buffer reached limits\n\t\t\tif (typeof this.options?.highWaterMark === 'number' && this.buffer.data.length > this.options.highWaterMark) {\n\t\t\t\treturn new Promise(resolve => this.pendingWritePromises.push(resolve));\n\t\t\t}\n\t\t}\n\t}\n\n\terror(error: Error): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// flowing: directly send the error to listeners\n\t\tif (this.state.flowing) {\n\t\t\tthis.emitError(error);\n\t\t}\n\n\t\t// not yet flowing: buffer errors until flowing\n\t\telse {\n\t\t\tthis.buffer.error.push(error);\n\t\t}\n\t}\n\n\tend(result?: T): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// end with data if provided\n\t\tif (typeof result !== 'undefined') {\n\t\t\tthis.write(result);\n\t\t}\n\n\t\t// flowing: send end event to listeners\n\t\tif (this.state.flowing) {\n\t\t\tthis.emitEnd();\n\n\t\t\tthis.destroy();\n\t\t}\n\n\t\t// not yet flowing: remember state\n\t\telse {\n\t\t\tthis.state.ended = true;\n\t\t}\n\t}\n\n\tprivate emitData(data: T): void {\n\t\tthis.listeners.data.slice(0).forEach(listener => listener(data)); // slice to avoid listener mutation from delivering event\n\t}\n\n\tprivate emitError(error: Error): void {\n\t\tif (this.listeners.error.length === 0) {\n\t\t\tonUnexpectedError(error); // nobody listened to this error so we log it as unexpected\n\t\t} else {\n\t\t\tthis.listeners.error.slice(0).forEach(listener => listener(error)); // slice to avoid listener mutation from delivering event\n\t\t}\n\t}\n\n\tprivate emitEnd(): void {\n\t\tthis.listeners.end.slice(0).forEach(listener => listener()); // slice to avoid listener mutation from delivering event\n\t}\n\n\ton(event: 'data', callback: (data: T) => void): void;\n\ton(event: 'error', callback: (err: Error) => void): void;\n\ton(event: 'end', callback: () => void): void;\n\ton(event: 'data' | 'error' | 'end', callback: (arg0?: any) => void): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (event) {\n\t\t\tcase 'data':\n\t\t\t\tthis.listeners.data.push(callback);\n\n\t\t\t\t// switch into flowing mode as soon as the first 'data'\n\t\t\t\t// listener is added and we are not yet in flowing mode\n\t\t\t\tthis.resume();\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'end':\n\t\t\t\tthis.listeners.end.push(callback);\n\n\t\t\t\t// emit 'end' event directly if we are flowing\n\t\t\t\t// and the end has already been reached\n\t\t\t\t//\n\t\t\t\t// finish() when it went through\n\t\t\t\tif (this.state.flowing && this.flowEnd()) {\n\t\t\t\t\tthis.destroy();\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'error':\n\t\t\t\tthis.listeners.error.push(callback);\n\n\t\t\t\t// emit buffered 'error' events unless done already\n\t\t\t\t// now that we know that we have at least one listener\n\t\t\t\tif (this.state.flowing) {\n\t\t\t\t\tthis.flowErrors();\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tremoveListener(event: string, callback: Function): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet listeners: unknown[] | undefined = undefined;\n\n\t\tswitch (event) {\n\t\t\tcase 'data':\n\t\t\t\tlisteners = this.listeners.data;\n\t\t\t\tbreak;\n\n\t\t\tcase 'end':\n\t\t\t\tlisteners = this.listeners.end;\n\t\t\t\tbreak;\n\n\t\t\tcase 'error':\n\t\t\t\tlisteners = this.listeners.error;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (listeners) {\n\t\t\tconst index = listeners.indexOf(callback);\n\t\t\tif (index >= 0) {\n\t\t\t\tlisteners.splice(index, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate flowData(): void {\n\t\tif (this.buffer.data.length > 0) {\n\t\t\tconst fullDataBuffer = this.reducer(this.buffer.data);\n\n\t\t\tthis.emitData(fullDataBuffer);\n\n\t\t\tthis.buffer.data.length = 0;\n\n\t\t\t// When the buffer is empty, resolve all pending writers\n\t\t\tconst pendingWritePromises = [...this.pendingWritePromises];\n\t\t\tthis.pendingWritePromises.length = 0;\n\t\t\tpendingWritePromises.forEach(pendingWritePromise => pendingWritePromise());\n\t\t}\n\t}\n\n\tprivate flowErrors(): void {\n\t\tif (this.listeners.error.length > 0) {\n\t\t\tfor (const error of this.buffer.error) {\n\t\t\t\tthis.emitError(error);\n\t\t\t}\n\n\t\t\tthis.buffer.error.length = 0;\n\t\t}\n\t}\n\n\tprivate flowEnd(): boolean {\n\t\tif (this.state.ended) {\n\t\t\tthis.emitEnd();\n\n\t\t\treturn this.listeners.end.length > 0;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tdestroy(): void {\n\t\tif (!this.state.destroyed) {\n\t\t\tthis.state.destroyed = true;\n\t\t\tthis.state.ended = true;\n\n\t\t\tthis.buffer.data.length = 0;\n\t\t\tthis.buffer.error.length = 0;\n\n\t\t\tthis.listeners.data.length = 0;\n\t\t\tthis.listeners.error.length = 0;\n\t\t\tthis.listeners.end.length = 0;\n\n\t\t\tthis.pendingWritePromises.length = 0;\n\t\t}\n\t}\n}\n\n/**\n * Helper to fully read a T readable into a T.\n */\nexport function consumeReadable<T>(readable: Readable<T>, reducer: IReducer<T>): T {\n\tconst chunks: T[] = [];\n\n\tlet chunk: T | null;\n\twhile ((chunk = readable.read()) !== null) {\n\t\tchunks.push(chunk);\n\t}\n\n\treturn reducer(chunks);\n}\n\n/**\n * Helper to read a T readable up to a maximum of chunks. If the limit is\n * reached, will return a readable instead to ensure all data can still\n * be read.\n */\nexport function peekReadable<T>(readable: Readable<T>, reducer: IReducer<T>, maxChunks: number): T | Readable<T> {\n\tconst chunks: T[] = [];\n\n\tlet chunk: T | null | undefined = undefined;\n\twhile ((chunk = readable.read()) !== null && chunks.length < maxChunks) {\n\t\tchunks.push(chunk);\n\t}\n\n\t// If the last chunk is null, it means we reached the end of\n\t// the readable and return all the data at once\n\tif (chunk === null && chunks.length > 0) {\n\t\treturn reducer(chunks);\n\t}\n\n\t// Otherwise, we still have a chunk, it means we reached the maxChunks\n\t// value and as such we return a new Readable that first returns\n\t// the existing read chunks and then continues with reading from\n\t// the underlying readable.\n\treturn {\n\t\tread: () => {\n\n\t\t\t// First consume chunks from our array\n\t\t\tif (chunks.length > 0) {\n\t\t\t\treturn chunks.shift()!;\n\t\t\t}\n\n\t\t\t// Then ensure to return our last read chunk\n\t\t\tif (typeof chunk !== 'undefined') {\n\t\t\t\tconst lastReadChunk = chunk;\n\n\t\t\t\t// explicitly use undefined here to indicate that we consumed\n\t\t\t\t// the chunk, which could have either been null or valued.\n\t\t\t\tchunk = undefined;\n\n\t\t\t\treturn lastReadChunk;\n\t\t\t}\n\n\t\t\t// Finally delegate back to the Readable\n\t\t\treturn readable.read();\n\t\t}\n\t};\n}\n\n/**\n * Helper to fully read a T stream into a T or consuming\n * a stream fully, awaiting all the events without caring\n * about the data.\n */\nexport function consumeStream<T, R = T>(stream: ReadableStreamEvents<T>, reducer: IReducer<T, R>): Promise<R>;\nexport function consumeStream(stream: ReadableStreamEvents<unknown>): Promise<undefined>;\nexport function consumeStream<T, R = T>(stream: ReadableStreamEvents<T>, reducer?: IReducer<T, R>): Promise<R | undefined> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst chunks: T[] = [];\n\n\t\tlistenStream(stream, {\n\t\t\tonData: chunk => {\n\t\t\t\tif (reducer) {\n\t\t\t\t\tchunks.push(chunk);\n\t\t\t\t}\n\t\t\t},\n\t\t\tonError: error => {\n\t\t\t\tif (reducer) {\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(undefined);\n\t\t\t\t}\n\t\t\t},\n\t\t\tonEnd: () => {\n\t\t\t\tif (reducer) {\n\t\t\t\t\tresolve(reducer(chunks));\n\t\t\t\t} else {\n\t\t\t\t\tresolve(undefined);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\nexport interface IStreamListener<T> {\n\n\t/**\n\t * The 'data' event is emitted whenever the stream is\n\t * relinquishing ownership of a chunk of data to a consumer.\n\t */\n\tonData(data: T): void;\n\n\t/**\n\t * Emitted when any error occurs.\n\t */\n\tonError(err: Error): void;\n\n\t/**\n\t * The 'end' event is emitted when there is no more data\n\t * to be consumed from the stream. The 'end' event will\n\t * not be emitted unless the data is completely consumed.\n\t */\n\tonEnd(): void;\n}\n\n/**\n * Helper to listen to all events of a T stream in proper order.\n */\nexport function listenStream<T>(stream: ReadableStreamEvents<T>, listener: IStreamListener<T>, token?: CancellationToken): void {\n\n\tstream.on('error', error => {\n\t\tif (!token?.isCancellationRequested) {\n\t\t\tlistener.onError(error);\n\t\t}\n\t});\n\n\tstream.on('end', () => {\n\t\tif (!token?.isCancellationRequested) {\n\t\t\tlistener.onEnd();\n\t\t}\n\t});\n\n\t// Adding the `data` listener will turn the stream\n\t// into flowing mode. As such it is important to\n\t// add this listener last (DO NOT CHANGE!)\n\tstream.on('data', data => {\n\t\tif (!token?.isCancellationRequested) {\n\t\t\tlistener.onData(data);\n\t\t}\n\t});\n}\n\n/**\n * Helper to peek up to `maxChunks` into a stream. The return type signals if\n * the stream has ended or not. If not, caller needs to add a `data` listener\n * to continue reading.\n */\nexport function peekStream<T>(stream: ReadableStream<T>, maxChunks: number): Promise<ReadableBufferedStream<T>> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst streamListeners = new DisposableStore();\n\t\tconst buffer: T[] = [];\n\n\t\t// Data Listener\n\t\tconst dataListener = (chunk: T) => {\n\n\t\t\t// Add to buffer\n\t\t\tbuffer.push(chunk);\n\n\t\t\t// We reached maxChunks and thus need to return\n\t\t\tif (buffer.length > maxChunks) {\n\n\t\t\t\t// Dispose any listeners and ensure to pause the\n\t\t\t\t// stream so that it can be consumed again by caller\n\t\t\t\tstreamListeners.dispose();\n\t\t\t\tstream.pause();\n\n\t\t\t\treturn resolve({ stream, buffer, ended: false });\n\t\t\t}\n\t\t};\n\n\t\t// Error Listener\n\t\tconst errorListener = (error: Error) => {\n\t\t\tstreamListeners.dispose();\n\n\t\t\treturn reject(error);\n\t\t};\n\n\t\t// End Listener\n\t\tconst endListener = () => {\n\t\t\tstreamListeners.dispose();\n\n\t\t\treturn resolve({ stream, buffer, ended: true });\n\t\t};\n\n\t\tstreamListeners.add(toDisposable(() => stream.removeListener('error', errorListener)));\n\t\tstream.on('error', errorListener);\n\n\t\tstreamListeners.add(toDisposable(() => stream.removeListener('end', endListener)));\n\t\tstream.on('end', endListener);\n\n\t\t// Important: leave the `data` listener last because\n\t\t// this can turn the stream into flowing mode and we\n\t\t// want `error` events to be received as well.\n\t\tstreamListeners.add(toDisposable(() => stream.removeListener('data', dataListener)));\n\t\tstream.on('data', dataListener);\n\t});\n}\n\n/**\n * Helper to create a readable stream from an existing T.\n */\nexport function toStream<T>(t: T, reducer: IReducer<T>): ReadableStream<T> {\n\tconst stream = newWriteableStream<T>(reducer);\n\n\tstream.end(t);\n\n\treturn stream;\n}\n\n/**\n * Helper to create an empty stream\n */\nexport function emptyStream(): ReadableStream<never> {\n\tconst stream = newWriteableStream<never>(() => { throw new Error('not supported'); });\n\tstream.end();\n\n\treturn stream;\n}\n\n/**\n * Helper to convert a T into a Readable<T>.\n */\nexport function toReadable<T>(t: T): Readable<T> {\n\tlet consumed = false;\n\n\treturn {\n\t\tread: () => {\n\t\t\tif (consumed) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconsumed = true;\n\n\t\t\treturn t;\n\t\t}\n\t};\n}\n\n/**\n * Helper to transform a readable stream into another stream.\n */\nexport function transform<Original, Transformed>(stream: ReadableStreamEvents<Original>, transformer: ITransformer<Original, Transformed>, reducer: IReducer<Transformed>): ReadableStream<Transformed> {\n\tconst target = newWriteableStream<Transformed>(reducer);\n\n\tlistenStream(stream, {\n\t\tonData: data => target.write(transformer.data(data)),\n\t\tonError: error => target.error(transformer.error ? transformer.error(error) : error),\n\t\tonEnd: () => target.end()\n\t});\n\n\treturn target;\n}\n\n/**\n * Helper to take an existing readable that will\n * have a prefix injected to the beginning.\n */\nexport function prefixedReadable<T>(prefix: T, readable: Readable<T>, reducer: IReducer<T>): Readable<T> {\n\tlet prefixHandled = false;\n\n\treturn {\n\t\tread: () => {\n\t\t\tconst chunk = readable.read();\n\n\t\t\t// Handle prefix only once\n\t\t\tif (!prefixHandled) {\n\t\t\t\tprefixHandled = true;\n\n\t\t\t\t// If we have also a read-result, make\n\t\t\t\t// sure to reduce it to a single result\n\t\t\t\tif (chunk !== null) {\n\t\t\t\t\treturn reducer([prefix, chunk]);\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, just return prefix directly\n\t\t\t\treturn prefix;\n\t\t\t}\n\n\t\t\treturn chunk;\n\t\t}\n\t};\n}\n\n/**\n * Helper to take an existing stream that will\n * have a prefix injected to the beginning.\n */\nexport function prefixedStream<T>(prefix: T, stream: ReadableStream<T>, reducer: IReducer<T>): ReadableStream<T> {\n\tlet prefixHandled = false;\n\n\tconst target = newWriteableStream<T>(reducer);\n\n\tlistenStream(stream, {\n\t\tonData: data => {\n\n\t\t\t// Handle prefix only once\n\t\t\tif (!prefixHandled) {\n\t\t\t\tprefixHandled = true;\n\n\t\t\t\treturn target.write(reducer([prefix, data]));\n\t\t\t}\n\n\t\t\treturn target.write(data);\n\t\t},\n\t\tonError: error => target.error(error),\n\t\tonEnd: () => {\n\n\t\t\t// Handle prefix only once\n\t\t\tif (!prefixHandled) {\n\t\t\t\tprefixHandled = true;\n\n\t\t\t\ttarget.write(prefix);\n\t\t\t}\n\n\t\t\ttarget.end();\n\t\t}\n\t});\n\n\treturn target;\n}\n"],
  "mappings": "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",
  "names": []
}
