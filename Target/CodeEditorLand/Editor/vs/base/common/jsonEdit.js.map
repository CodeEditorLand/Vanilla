{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/jsonEdit.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport {\n\ttype JSONPath,\n\ttype Node,\n\ttype ParseError,\n\ttype Segment,\n\tfindNodeAtLocation,\n\tparseTree,\n} from \"./json.js\";\nimport {\n\ttype Edit,\n\ttype FormattingOptions,\n\tformat,\n\tisEOL,\n} from \"./jsonFormatter.js\";\n\nexport function removeProperty(\n\ttext: string,\n\tpath: JSONPath,\n\tformattingOptions: FormattingOptions,\n): Edit[] {\n\treturn setProperty(text, path, undefined, formattingOptions);\n}\n\nexport function setProperty(\n\ttext: string,\n\toriginalPath: JSONPath,\n\tvalue: any,\n\tformattingOptions: FormattingOptions,\n\tgetInsertionIndex?: (properties: string[]) => number,\n): Edit[] {\n\tconst path = originalPath.slice();\n\tconst errors: ParseError[] = [];\n\tconst root = parseTree(text, errors);\n\tlet parent: Node | undefined;\n\n\tlet lastSegment: Segment | undefined;\n\twhile (path.length > 0) {\n\t\tlastSegment = path.pop();\n\t\tparent = findNodeAtLocation(root, path);\n\t\tif (parent === undefined && value !== undefined) {\n\t\t\tif (typeof lastSegment === \"string\") {\n\t\t\t\tvalue = { [lastSegment]: value };\n\t\t\t} else {\n\t\t\t\tvalue = [value];\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!parent) {\n\t\t// empty document\n\t\tif (value === undefined) {\n\t\t\t// delete\n\t\t\treturn []; // property does not exist, nothing to do\n\t\t}\n\t\treturn withFormatting(\n\t\t\ttext,\n\t\t\t{\n\t\t\t\toffset: root ? root.offset : 0,\n\t\t\t\tlength: root ? root.length : 0,\n\t\t\t\tcontent: JSON.stringify(value),\n\t\t\t},\n\t\t\tformattingOptions,\n\t\t);\n\t} else if (\n\t\tparent.type === \"object\" &&\n\t\ttypeof lastSegment === \"string\" &&\n\t\tArray.isArray(parent.children)\n\t) {\n\t\tconst existing = findNodeAtLocation(parent, [lastSegment]);\n\t\tif (existing !== undefined) {\n\t\t\tif (value === undefined) {\n\t\t\t\t// delete\n\t\t\t\tif (!existing.parent) {\n\t\t\t\t\tthrow new Error(\"Malformed AST\");\n\t\t\t\t}\n\t\t\t\tconst propertyIndex = parent.children.indexOf(existing.parent);\n\t\t\t\tlet removeBegin: number;\n\t\t\t\tlet removeEnd = existing.parent.offset + existing.parent.length;\n\t\t\t\tif (propertyIndex > 0) {\n\t\t\t\t\t// remove the comma of the previous node\n\t\t\t\t\tconst previous = parent.children[propertyIndex - 1];\n\t\t\t\t\tremoveBegin = previous.offset + previous.length;\n\t\t\t\t} else {\n\t\t\t\t\tremoveBegin = parent.offset + 1;\n\t\t\t\t\tif (parent.children.length > 1) {\n\t\t\t\t\t\t// remove the comma of the next node\n\t\t\t\t\t\tconst next = parent.children[1];\n\t\t\t\t\t\tremoveEnd = next.offset;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn withFormatting(\n\t\t\t\t\ttext,\n\t\t\t\t\t{\n\t\t\t\t\t\toffset: removeBegin,\n\t\t\t\t\t\tlength: removeEnd - removeBegin,\n\t\t\t\t\t\tcontent: \"\",\n\t\t\t\t\t},\n\t\t\t\t\tformattingOptions,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t// set value of existing property\n\t\t\t\treturn withFormatting(\n\t\t\t\t\ttext,\n\t\t\t\t\t{\n\t\t\t\t\t\toffset: existing.offset,\n\t\t\t\t\t\tlength: existing.length,\n\t\t\t\t\t\tcontent: JSON.stringify(value),\n\t\t\t\t\t},\n\t\t\t\t\tformattingOptions,\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tif (value === undefined) {\n\t\t\t\t// delete\n\t\t\t\treturn []; // property does not exist, nothing to do\n\t\t\t}\n\t\t\tconst newProperty = `${JSON.stringify(lastSegment)}: ${JSON.stringify(value)}`;\n\t\t\tconst index = getInsertionIndex\n\t\t\t\t? getInsertionIndex(\n\t\t\t\t\t\tparent.children.map((p) => p.children![0].value),\n\t\t\t\t\t)\n\t\t\t\t: parent.children.length;\n\t\t\tlet edit: Edit;\n\t\t\tif (index > 0) {\n\t\t\t\tconst previous = parent.children[index - 1];\n\t\t\t\tedit = {\n\t\t\t\t\toffset: previous.offset + previous.length,\n\t\t\t\t\tlength: 0,\n\t\t\t\t\tcontent: \",\" + newProperty,\n\t\t\t\t};\n\t\t\t} else if (parent.children.length === 0) {\n\t\t\t\tedit = {\n\t\t\t\t\toffset: parent.offset + 1,\n\t\t\t\t\tlength: 0,\n\t\t\t\t\tcontent: newProperty,\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tedit = {\n\t\t\t\t\toffset: parent.offset + 1,\n\t\t\t\t\tlength: 0,\n\t\t\t\t\tcontent: newProperty + \",\",\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn withFormatting(text, edit, formattingOptions);\n\t\t}\n\t} else if (\n\t\tparent.type === \"array\" &&\n\t\ttypeof lastSegment === \"number\" &&\n\t\tArray.isArray(parent.children)\n\t) {\n\t\tif (value !== undefined) {\n\t\t\t// Insert\n\t\t\tconst newProperty = `${JSON.stringify(value)}`;\n\t\t\tlet edit: Edit;\n\t\t\tif (parent.children.length === 0 || lastSegment === 0) {\n\t\t\t\tedit = {\n\t\t\t\t\toffset: parent.offset + 1,\n\t\t\t\t\tlength: 0,\n\t\t\t\t\tcontent:\n\t\t\t\t\t\tparent.children.length === 0\n\t\t\t\t\t\t\t? newProperty\n\t\t\t\t\t\t\t: newProperty + \",\",\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tconst index =\n\t\t\t\t\tlastSegment === -1 || lastSegment > parent.children.length\n\t\t\t\t\t\t? parent.children.length\n\t\t\t\t\t\t: lastSegment;\n\t\t\t\tconst previous = parent.children[index - 1];\n\t\t\t\tedit = {\n\t\t\t\t\toffset: previous.offset + previous.length,\n\t\t\t\t\tlength: 0,\n\t\t\t\t\tcontent: \",\" + newProperty,\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn withFormatting(text, edit, formattingOptions);\n\t\t} else {\n\t\t\t//Removal\n\t\t\tconst removalIndex = lastSegment;\n\t\t\tconst toRemove = parent.children[removalIndex];\n\t\t\tlet edit: Edit;\n\t\t\tif (parent.children.length === 1) {\n\t\t\t\t// only item\n\t\t\t\tedit = {\n\t\t\t\t\toffset: parent.offset + 1,\n\t\t\t\t\tlength: parent.length - 2,\n\t\t\t\t\tcontent: \"\",\n\t\t\t\t};\n\t\t\t} else if (parent.children.length - 1 === removalIndex) {\n\t\t\t\t// last item\n\t\t\t\tconst previous = parent.children[removalIndex - 1];\n\t\t\t\tconst offset = previous.offset + previous.length;\n\t\t\t\tconst parentEndOffset = parent.offset + parent.length;\n\t\t\t\tedit = {\n\t\t\t\t\toffset,\n\t\t\t\t\tlength: parentEndOffset - 2 - offset,\n\t\t\t\t\tcontent: \"\",\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tedit = {\n\t\t\t\t\toffset: toRemove.offset,\n\t\t\t\t\tlength:\n\t\t\t\t\t\tparent.children[removalIndex + 1].offset -\n\t\t\t\t\t\ttoRemove.offset,\n\t\t\t\t\tcontent: \"\",\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn withFormatting(text, edit, formattingOptions);\n\t\t}\n\t} else {\n\t\tthrow new Error(\n\t\t\t`Can not add ${typeof lastSegment !== \"number\" ? \"index\" : \"property\"} to parent of type ${parent.type}`,\n\t\t);\n\t}\n}\n\nexport function withFormatting(\n\ttext: string,\n\tedit: Edit,\n\tformattingOptions: FormattingOptions,\n): Edit[] {\n\t// apply the edit\n\tlet newText = applyEdit(text, edit);\n\n\t// format the new text\n\tlet begin = edit.offset;\n\tlet end = edit.offset + edit.content.length;\n\tif (edit.length === 0 || edit.content.length === 0) {\n\t\t// insert or remove\n\t\twhile (begin > 0 && !isEOL(newText, begin - 1)) {\n\t\t\tbegin--;\n\t\t}\n\t\twhile (end < newText.length && !isEOL(newText, end)) {\n\t\t\tend++;\n\t\t}\n\t}\n\n\tconst edits = format(\n\t\tnewText,\n\t\t{ offset: begin, length: end - begin },\n\t\tformattingOptions,\n\t);\n\n\t// apply the formatting edits and track the begin and end offsets of the changes\n\tfor (let i = edits.length - 1; i >= 0; i--) {\n\t\tconst curr = edits[i];\n\t\tnewText = applyEdit(newText, curr);\n\t\tbegin = Math.min(begin, curr.offset);\n\t\tend = Math.max(end, curr.offset + curr.length);\n\t\tend += curr.content.length - curr.length;\n\t}\n\t// create a single edit with all changes\n\tconst editLength = text.length - (newText.length - end) - begin;\n\treturn [\n\t\t{\n\t\t\toffset: begin,\n\t\t\tlength: editLength,\n\t\t\tcontent: newText.substring(begin, end),\n\t\t},\n\t];\n}\n\nexport function applyEdit(text: string, edit: Edit): string {\n\treturn (\n\t\ttext.substring(0, edit.offset) +\n\t\tedit.content +\n\t\ttext.substring(edit.offset + edit.length)\n\t);\n}\n\nexport function applyEdits(text: string, edits: Edit[]): string {\n\tconst sortedEdits = edits.slice(0).sort((a, b) => {\n\t\tconst diff = a.offset - b.offset;\n\t\tif (diff === 0) {\n\t\t\treturn a.length - b.length;\n\t\t}\n\t\treturn diff;\n\t});\n\tlet lastModifiedOffset = text.length;\n\tfor (let i = sortedEdits.length - 1; i >= 0; i--) {\n\t\tconst e = sortedEdits[i];\n\t\tif (e.offset + e.length <= lastModifiedOffset) {\n\t\t\ttext = applyEdit(text, e);\n\t\t} else {\n\t\t\tthrow new Error(\"Overlapping edit\");\n\t\t}\n\t\tlastModifiedOffset = e.offset;\n\t}\n\treturn text;\n}\n"],
  "mappings": "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",
  "names": []
}
