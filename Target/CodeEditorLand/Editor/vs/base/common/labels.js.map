{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/labels.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { hasDriveLetter, toSlashes } from './extpath.js';\nimport { posix, sep, win32 } from './path.js';\nimport { isMacintosh, isWindows, OperatingSystem, OS } from './platform.js';\nimport { extUri, extUriIgnorePathCase } from './resources.js';\nimport { rtrim, startsWithIgnoreCase } from './strings.js';\nimport { URI } from './uri.js';\n\nexport interface IPathLabelFormatting {\n\n\t/**\n\t * The OS the path label is from to produce a label\n\t * that matches OS expectations.\n\t */\n\treadonly os: OperatingSystem;\n\n\t/**\n\t * Whether to add a `~` when the path is in the\n\t * user home directory.\n\t *\n\t * Note: this only applies to Linux, macOS but not\n\t * Windows.\n\t */\n\treadonly tildify?: IUserHomeProvider;\n\n\t/**\n\t * Whether to convert to a relative path if the path\n\t * is within any of the opened workspace folders.\n\t */\n\treadonly relative?: IRelativePathProvider;\n}\n\nexport interface IRelativePathProvider {\n\n\t/**\n\t * Whether to not add a prefix when in multi-root workspace.\n\t */\n\treadonly noPrefix?: boolean;\n\n\tgetWorkspace(): { folders: { uri: URI; name?: string }[] };\n\tgetWorkspaceFolder(resource: URI): { uri: URI; name?: string } | null;\n}\n\nexport interface IUserHomeProvider {\n\tuserHome: URI;\n}\n\nexport function getPathLabel(resource: URI, formatting: IPathLabelFormatting): string {\n\tconst { os, tildify: tildifier, relative: relatifier } = formatting;\n\n\t// return early with a relative path if we can resolve one\n\tif (relatifier) {\n\t\tconst relativePath = getRelativePathLabel(resource, relatifier, os);\n\t\tif (typeof relativePath === 'string') {\n\t\t\treturn relativePath;\n\t\t}\n\t}\n\n\t// otherwise try to resolve a absolute path label and\n\t// apply target OS standard path separators if target\n\t// OS differs from actual OS we are running in\n\tlet absolutePath = resource.fsPath;\n\tif (os === OperatingSystem.Windows && !isWindows) {\n\t\tabsolutePath = absolutePath.replace(/\\//g, '\\\\');\n\t} else if (os !== OperatingSystem.Windows && isWindows) {\n\t\tabsolutePath = absolutePath.replace(/\\\\/g, '/');\n\t}\n\n\t// macOS/Linux: tildify with provided user home directory\n\tif (os !== OperatingSystem.Windows && tildifier?.userHome) {\n\t\tconst userHome = tildifier.userHome.fsPath;\n\n\t\t// This is a bit of a hack, but in order to figure out if the\n\t\t// resource is in the user home, we need to make sure to convert it\n\t\t// to a user home resource. We cannot assume that the resource is\n\t\t// already a user home resource.\n\t\tlet userHomeCandidate: string;\n\t\tif (resource.scheme !== tildifier.userHome.scheme && resource.path[0] === posix.sep && resource.path[1] !== posix.sep) {\n\t\t\tuserHomeCandidate = tildifier.userHome.with({ path: resource.path }).fsPath;\n\t\t} else {\n\t\t\tuserHomeCandidate = absolutePath;\n\t\t}\n\n\t\tabsolutePath = tildify(userHomeCandidate, userHome, os);\n\t}\n\n\t// normalize\n\tconst pathLib = os === OperatingSystem.Windows ? win32 : posix;\n\treturn pathLib.normalize(normalizeDriveLetter(absolutePath, os === OperatingSystem.Windows));\n}\n\nfunction getRelativePathLabel(resource: URI, relativePathProvider: IRelativePathProvider, os: OperatingSystem): string | undefined {\n\tconst pathLib = os === OperatingSystem.Windows ? win32 : posix;\n\tconst extUriLib = os === OperatingSystem.Linux ? extUri : extUriIgnorePathCase;\n\n\tconst workspace = relativePathProvider.getWorkspace();\n\tconst firstFolder = workspace.folders.at(0);\n\tif (!firstFolder) {\n\t\treturn undefined;\n\t}\n\n\t// This is a bit of a hack, but in order to figure out the folder\n\t// the resource belongs to, we need to make sure to convert it\n\t// to a workspace resource. We cannot assume that the resource is\n\t// already matching the workspace.\n\tif (resource.scheme !== firstFolder.uri.scheme && resource.path[0] === posix.sep && resource.path[1] !== posix.sep) {\n\t\tresource = firstFolder.uri.with({ path: resource.path });\n\t}\n\n\tconst folder = relativePathProvider.getWorkspaceFolder(resource);\n\tif (!folder) {\n\t\treturn undefined;\n\t}\n\n\tlet relativePathLabel: string | undefined = undefined;\n\tif (extUriLib.isEqual(folder.uri, resource)) {\n\t\trelativePathLabel = ''; // no label if paths are identical\n\t} else {\n\t\trelativePathLabel = extUriLib.relativePath(folder.uri, resource) ?? '';\n\t}\n\n\t// normalize\n\tif (relativePathLabel) {\n\t\trelativePathLabel = pathLib.normalize(relativePathLabel);\n\t}\n\n\t// always show root basename if there are multiple folders\n\tif (workspace.folders.length > 1 && !relativePathProvider.noPrefix) {\n\t\tconst rootName = folder.name ? folder.name : extUriLib.basenameOrAuthority(folder.uri);\n\t\trelativePathLabel = relativePathLabel ? `${rootName} \u2022 ${relativePathLabel}` : rootName;\n\t}\n\n\treturn relativePathLabel;\n}\n\nexport function normalizeDriveLetter(path: string, isWindowsOS: boolean = isWindows): string {\n\tif (hasDriveLetter(path, isWindowsOS)) {\n\t\treturn path.charAt(0).toUpperCase() + path.slice(1);\n\t}\n\n\treturn path;\n}\n\nlet normalizedUserHomeCached: { original: string; normalized: string } = Object.create(null);\nexport function tildify(path: string, userHome: string, os = OS): string {\n\tif (os === OperatingSystem.Windows || !path || !userHome) {\n\t\treturn path; // unsupported on Windows\n\t}\n\n\tlet normalizedUserHome = normalizedUserHomeCached.original === userHome ? normalizedUserHomeCached.normalized : undefined;\n\tif (!normalizedUserHome) {\n\t\tnormalizedUserHome = userHome;\n\t\tif (isWindows) {\n\t\t\tnormalizedUserHome = toSlashes(normalizedUserHome); // make sure that the path is POSIX normalized on Windows\n\t\t}\n\t\tnormalizedUserHome = `${rtrim(normalizedUserHome, posix.sep)}${posix.sep}`;\n\t\tnormalizedUserHomeCached = { original: userHome, normalized: normalizedUserHome };\n\t}\n\n\tlet normalizedPath = path;\n\tif (isWindows) {\n\t\tnormalizedPath = toSlashes(normalizedPath); // make sure that the path is POSIX normalized on Windows\n\t}\n\n\t// Linux: case sensitive, macOS: case insensitive\n\tif (os === OperatingSystem.Linux ? normalizedPath.startsWith(normalizedUserHome) : startsWithIgnoreCase(normalizedPath, normalizedUserHome)) {\n\t\treturn `~/${normalizedPath.substr(normalizedUserHome.length)}`;\n\t}\n\n\treturn path;\n}\n\nexport function untildify(path: string, userHome: string): string {\n\treturn path.replace(/^~($|\\/|\\\\)/, `${userHome}$1`);\n}\n\n/**\n * Shortens the paths but keeps them easy to distinguish.\n * Replaces not important parts with ellipsis.\n * Every shorten path matches only one original path and vice versa.\n *\n * Algorithm for shortening paths is as follows:\n * 1. For every path in list, find unique substring of that path.\n * 2. Unique substring along with ellipsis is shortened path of that path.\n * 3. To find unique substring of path, consider every segment of length from 1 to path.length of path from end of string\n *    and if present segment is not substring to any other paths then present segment is unique path,\n *    else check if it is not present as suffix of any other path and present segment is suffix of path itself,\n *    if it is true take present segment as unique path.\n * 4. Apply ellipsis to unique segment according to whether segment is present at start/in-between/end of path.\n *\n * Example 1\n * 1. consider 2 paths i.e. ['a\\\\b\\\\c\\\\d', 'a\\\\f\\\\b\\\\c\\\\d']\n * 2. find unique path of first path,\n * \ta. 'd' is present in path2 and is suffix of path2, hence not unique of present path.\n * \tb. 'c' is present in path2 and 'c' is not suffix of present path, similarly for 'b' and 'a' also.\n * \tc. 'd\\\\c' is suffix of path2.\n *  d. 'b\\\\c' is not suffix of present path.\n *  e. 'a\\\\b' is not present in path2, hence unique path is 'a\\\\b...'.\n * 3. for path2, 'f' is not present in path1 hence unique is '...\\\\f\\\\...'.\n *\n * Example 2\n * 1. consider 2 paths i.e. ['a\\\\b', 'a\\\\b\\\\c'].\n * \ta. Even if 'b' is present in path2, as 'b' is suffix of path1 and is not suffix of path2, unique path will be '...\\\\b'.\n * 2. for path2, 'c' is not present in path1 hence unique path is '..\\\\c'.\n */\nconst ellipsis = '\\u2026';\nconst unc = '\\\\\\\\';\nconst home = '~';\nexport function shorten(paths: string[], pathSeparator: string = sep): string[] {\n\tconst shortenedPaths: string[] = new Array(paths.length);\n\n\t// for every path\n\tlet match = false;\n\tfor (let pathIndex = 0; pathIndex < paths.length; pathIndex++) {\n\t\tconst originalPath = paths[pathIndex];\n\n\t\tif (originalPath === '') {\n\t\t\tshortenedPaths[pathIndex] = `.${pathSeparator}`;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!originalPath) {\n\t\t\tshortenedPaths[pathIndex] = originalPath;\n\t\t\tcontinue;\n\t\t}\n\n\t\tmatch = true;\n\n\t\t// trim for now and concatenate unc path (e.g. \\\\network) or root path (/etc, ~/etc) later\n\t\tlet prefix = '';\n\t\tlet trimmedPath = originalPath;\n\t\tif (trimmedPath.indexOf(unc) === 0) {\n\t\t\tprefix = trimmedPath.substr(0, trimmedPath.indexOf(unc) + unc.length);\n\t\t\ttrimmedPath = trimmedPath.substr(trimmedPath.indexOf(unc) + unc.length);\n\t\t} else if (trimmedPath.indexOf(pathSeparator) === 0) {\n\t\t\tprefix = trimmedPath.substr(0, trimmedPath.indexOf(pathSeparator) + pathSeparator.length);\n\t\t\ttrimmedPath = trimmedPath.substr(trimmedPath.indexOf(pathSeparator) + pathSeparator.length);\n\t\t} else if (trimmedPath.indexOf(home) === 0) {\n\t\t\tprefix = trimmedPath.substr(0, trimmedPath.indexOf(home) + home.length);\n\t\t\ttrimmedPath = trimmedPath.substr(trimmedPath.indexOf(home) + home.length);\n\t\t}\n\n\t\t// pick the first shortest subpath found\n\t\tconst segments: string[] = trimmedPath.split(pathSeparator);\n\t\tfor (let subpathLength = 1; match && subpathLength <= segments.length; subpathLength++) {\n\t\t\tfor (let start = segments.length - subpathLength; match && start >= 0; start--) {\n\t\t\t\tmatch = false;\n\t\t\t\tlet subpath = segments.slice(start, start + subpathLength).join(pathSeparator);\n\n\t\t\t\t// that is unique to any other path\n\t\t\t\tfor (let otherPathIndex = 0; !match && otherPathIndex < paths.length; otherPathIndex++) {\n\n\t\t\t\t\t// suffix subpath treated specially as we consider no match 'x' and 'x/...'\n\t\t\t\t\tif (otherPathIndex !== pathIndex && paths[otherPathIndex] && paths[otherPathIndex].indexOf(subpath) > -1) {\n\t\t\t\t\t\tconst isSubpathEnding: boolean = (start + subpathLength === segments.length);\n\n\t\t\t\t\t\t// Adding separator as prefix for subpath, such that 'endsWith(src, trgt)' considers subpath as directory name instead of plain string.\n\t\t\t\t\t\t// prefix is not added when either subpath is root directory or path[otherPathIndex] does not have multiple directories.\n\t\t\t\t\t\tconst subpathWithSep: string = (start > 0 && paths[otherPathIndex].indexOf(pathSeparator) > -1) ? pathSeparator + subpath : subpath;\n\t\t\t\t\t\tconst isOtherPathEnding: boolean = paths[otherPathIndex].endsWith(subpathWithSep);\n\n\t\t\t\t\t\tmatch = !isSubpathEnding || isOtherPathEnding;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// found unique subpath\n\t\t\t\tif (!match) {\n\t\t\t\t\tlet result = '';\n\n\t\t\t\t\t// preserve disk drive or root prefix\n\t\t\t\t\tif (segments[0].endsWith(':') || prefix !== '') {\n\t\t\t\t\t\tif (start === 1) {\n\t\t\t\t\t\t\t// extend subpath to include disk drive prefix\n\t\t\t\t\t\t\tstart = 0;\n\t\t\t\t\t\t\tsubpathLength++;\n\t\t\t\t\t\t\tsubpath = segments[0] + pathSeparator + subpath;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (start > 0) {\n\t\t\t\t\t\t\tresult = segments[0] + pathSeparator;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresult = prefix + result;\n\t\t\t\t\t}\n\n\t\t\t\t\t// add ellipsis at the beginning if needed\n\t\t\t\t\tif (start > 0) {\n\t\t\t\t\t\tresult = result + ellipsis + pathSeparator;\n\t\t\t\t\t}\n\n\t\t\t\t\tresult = result + subpath;\n\n\t\t\t\t\t// add ellipsis at the end if needed\n\t\t\t\t\tif (start + subpathLength < segments.length) {\n\t\t\t\t\t\tresult = result + pathSeparator + ellipsis;\n\t\t\t\t\t}\n\n\t\t\t\t\tshortenedPaths[pathIndex] = result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (match) {\n\t\t\tshortenedPaths[pathIndex] = originalPath; // use original path if no unique subpaths found\n\t\t}\n\t}\n\n\treturn shortenedPaths;\n}\n\nexport interface ISeparator {\n\tlabel: string;\n}\n\nenum Type {\n\tTEXT,\n\tVARIABLE,\n\tSEPARATOR\n}\n\ninterface ISegment {\n\tvalue: string;\n\ttype: Type;\n}\n\n/**\n * Helper to insert values for specific template variables into the string. E.g. \"this $(is) a $(template)\" can be\n * passed to this function together with an object that maps \"is\" and \"template\" to strings to have them replaced.\n * @param value string to which template is applied\n * @param values the values of the templates to use\n */\nexport function template(template: string, values: { [key: string]: string | ISeparator | undefined | null } = Object.create(null)): string {\n\tconst segments: ISegment[] = [];\n\n\tlet inVariable = false;\n\tlet curVal = '';\n\tfor (const char of template) {\n\t\t// Beginning of variable\n\t\tif (char === '$' || (inVariable && char === '{')) {\n\t\t\tif (curVal) {\n\t\t\t\tsegments.push({ value: curVal, type: Type.TEXT });\n\t\t\t}\n\n\t\t\tcurVal = '';\n\t\t\tinVariable = true;\n\t\t}\n\n\t\t// End of variable\n\t\telse if (char === '}' && inVariable) {\n\t\t\tconst resolved = values[curVal];\n\n\t\t\t// Variable\n\t\t\tif (typeof resolved === 'string') {\n\t\t\t\tif (resolved.length) {\n\t\t\t\t\tsegments.push({ value: resolved, type: Type.VARIABLE });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Separator\n\t\t\telse if (resolved) {\n\t\t\t\tconst prevSegment = segments[segments.length - 1];\n\t\t\t\tif (!prevSegment || prevSegment.type !== Type.SEPARATOR) {\n\t\t\t\t\tsegments.push({ value: resolved.label, type: Type.SEPARATOR }); // prevent duplicate separators\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurVal = '';\n\t\t\tinVariable = false;\n\t\t}\n\n\t\t// Text or Variable Name\n\t\telse {\n\t\t\tcurVal += char;\n\t\t}\n\t}\n\n\t// Tail\n\tif (curVal && !inVariable) {\n\t\tsegments.push({ value: curVal, type: Type.TEXT });\n\t}\n\n\treturn segments.filter((segment, index) => {\n\n\t\t// Only keep separator if we have values to the left and right\n\t\tif (segment.type === Type.SEPARATOR) {\n\t\t\tconst left = segments[index - 1];\n\t\t\tconst right = segments[index + 1];\n\n\t\t\treturn [left, right].every(segment => segment && (segment.type === Type.VARIABLE || segment.type === Type.TEXT) && segment.value.length > 0);\n\t\t}\n\n\t\t// accept any TEXT and VARIABLE\n\t\treturn true;\n\t}).map(segment => segment.value).join('');\n}\n\n/**\n * Handles mnemonics for menu items. Depending on OS:\n * - Windows: Supported via & character (replace && with &)\n * -   Linux: Supported via & character (replace && with &)\n * -   macOS: Unsupported (replace && with empty string)\n */\nexport function mnemonicMenuLabel(label: string, forceDisableMnemonics?: boolean): string {\n\tif (isMacintosh || forceDisableMnemonics) {\n\t\treturn label.replace(/\\(&&\\w\\)|&&/g, '').replace(/&/g, isMacintosh ? '&' : '&&');\n\t}\n\n\treturn label.replace(/&&|&/g, m => m === '&' ? '&&' : '&');\n}\n\n/**\n * Handles mnemonics for buttons. Depending on OS:\n * - Windows: Supported via & character (replace && with & and & with && for escaping)\n * -   Linux: Supported via _ character (replace && with _)\n * -   macOS: Unsupported (replace && with empty string)\n */\nexport function mnemonicButtonLabel(label: string, forceDisableMnemonics?: boolean): string {\n\tif (isMacintosh || forceDisableMnemonics) {\n\t\treturn label.replace(/\\(&&\\w\\)|&&/g, '');\n\t}\n\n\tif (isWindows) {\n\t\treturn label.replace(/&&|&/g, m => m === '&' ? '&&' : '&');\n\t}\n\n\treturn label.replace(/&&/g, '_');\n}\n\nexport function unmnemonicLabel(label: string): string {\n\treturn label.replace(/&/g, '&&');\n}\n\n/**\n * Splits a recent label in name and parent path, supporting both '/' and '\\' and workspace suffixes.\n * If the location is remote, the remote name is included in the name part.\n */\nexport function splitRecentLabel(recentLabel: string): { name: string; parentPath: string } {\n\tif (recentLabel.endsWith(']')) {\n\t\t// label with workspace suffix\n\t\tconst lastIndexOfSquareBracket = recentLabel.lastIndexOf(' [', recentLabel.length - 2);\n\t\tif (lastIndexOfSquareBracket !== -1) {\n\t\t\tconst split = splitName(recentLabel.substring(0, lastIndexOfSquareBracket));\n\t\t\tconst remoteNameWithSpace = recentLabel.substring(lastIndexOfSquareBracket);\n\t\t\treturn { name: split.name + remoteNameWithSpace, parentPath: split.parentPath };\n\t\t}\n\t}\n\treturn splitName(recentLabel);\n}\n\nfunction splitName(fullPath: string): { name: string; parentPath: string } {\n\tconst p = fullPath.indexOf('/') !== -1 ? posix : win32;\n\tconst name = p.basename(fullPath);\n\tconst parentPath = p.dirname(fullPath);\n\tif (name.length) {\n\t\treturn { name, parentPath };\n\t}\n\t// only the root segment\n\treturn { name: parentPath, parentPath: '' };\n}\n"],
  "mappings": "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",
  "names": ["Type", "template", "segment"]
}
